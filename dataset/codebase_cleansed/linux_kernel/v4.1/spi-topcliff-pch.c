static inline void pch_spi_writereg(struct spi_master *master, int idx, u32 val)\r\n{\r\nstruct pch_spi_data *data = spi_master_get_devdata(master);\r\niowrite32(val, (data->io_remap_addr + idx));\r\n}\r\nstatic inline u32 pch_spi_readreg(struct spi_master *master, int idx)\r\n{\r\nstruct pch_spi_data *data = spi_master_get_devdata(master);\r\nreturn ioread32(data->io_remap_addr + idx);\r\n}\r\nstatic inline void pch_spi_setclr_reg(struct spi_master *master, int idx,\r\nu32 set, u32 clr)\r\n{\r\nu32 tmp = pch_spi_readreg(master, idx);\r\ntmp = (tmp & ~clr) | set;\r\npch_spi_writereg(master, idx, tmp);\r\n}\r\nstatic void pch_spi_set_master_mode(struct spi_master *master)\r\n{\r\npch_spi_setclr_reg(master, PCH_SPCR, SPCR_MSTR_BIT, 0);\r\n}\r\nstatic void pch_spi_clear_fifo(struct spi_master *master)\r\n{\r\npch_spi_setclr_reg(master, PCH_SPCR, SPCR_FICLR_BIT, 0);\r\npch_spi_setclr_reg(master, PCH_SPCR, 0, SPCR_FICLR_BIT);\r\n}\r\nstatic void pch_spi_handler_sub(struct pch_spi_data *data, u32 reg_spsr_val,\r\nvoid __iomem *io_remap_addr)\r\n{\r\nu32 n_read, tx_index, rx_index, bpw_len;\r\nu16 *pkt_rx_buffer, *pkt_tx_buff;\r\nint read_cnt;\r\nu32 reg_spcr_val;\r\nvoid __iomem *spsr;\r\nvoid __iomem *spdrr;\r\nvoid __iomem *spdwr;\r\nspsr = io_remap_addr + PCH_SPSR;\r\niowrite32(reg_spsr_val, spsr);\r\nif (data->transfer_active) {\r\nrx_index = data->rx_index;\r\ntx_index = data->tx_index;\r\nbpw_len = data->bpw_len;\r\npkt_rx_buffer = data->pkt_rx_buff;\r\npkt_tx_buff = data->pkt_tx_buff;\r\nspdrr = io_remap_addr + PCH_SPDRR;\r\nspdwr = io_remap_addr + PCH_SPDWR;\r\nn_read = PCH_READABLE(reg_spsr_val);\r\nfor (read_cnt = 0; (read_cnt < n_read); read_cnt++) {\r\npkt_rx_buffer[rx_index++] = ioread32(spdrr);\r\nif (tx_index < bpw_len)\r\niowrite32(pkt_tx_buff[tx_index++], spdwr);\r\n}\r\nif ((bpw_len - rx_index) <= PCH_MAX_FIFO_DEPTH) {\r\nreg_spcr_val = ioread32(io_remap_addr + PCH_SPCR);\r\nreg_spcr_val &= ~SPCR_RFIE_BIT;\r\nreg_spcr_val &= ~MASK_RFIC_SPCR_BITS;\r\nreg_spcr_val |= (PCH_RX_THOLD_MAX << SPCR_RFIC_FIELD);\r\niowrite32(reg_spcr_val, (io_remap_addr + PCH_SPCR));\r\n}\r\ndata->tx_index = tx_index;\r\ndata->rx_index = rx_index;\r\nif (reg_spsr_val & SPSR_FI_BIT) {\r\nif ((tx_index == bpw_len) && (rx_index == tx_index)) {\r\npch_spi_setclr_reg(data->master, PCH_SPCR, 0,\r\nPCH_ALL);\r\ndata->transfer_complete = true;\r\ndata->transfer_active = false;\r\nwake_up(&data->wait);\r\n} else {\r\ndev_vdbg(&data->master->dev,\r\n"%s : Transfer is not completed",\r\n__func__);\r\n}\r\n}\r\n}\r\n}\r\nstatic irqreturn_t pch_spi_handler(int irq, void *dev_id)\r\n{\r\nu32 reg_spsr_val;\r\nvoid __iomem *spsr;\r\nvoid __iomem *io_remap_addr;\r\nirqreturn_t ret = IRQ_NONE;\r\nstruct pch_spi_data *data = dev_id;\r\nstruct pch_spi_board_data *board_dat = data->board_dat;\r\nif (board_dat->suspend_sts) {\r\ndev_dbg(&board_dat->pdev->dev,\r\n"%s returning due to suspend\n", __func__);\r\nreturn IRQ_NONE;\r\n}\r\nio_remap_addr = data->io_remap_addr;\r\nspsr = io_remap_addr + PCH_SPSR;\r\nreg_spsr_val = ioread32(spsr);\r\nif (reg_spsr_val & SPSR_ORF_BIT) {\r\ndev_err(&board_dat->pdev->dev, "%s Over run error\n", __func__);\r\nif (data->current_msg->complete) {\r\ndata->transfer_complete = true;\r\ndata->current_msg->status = -EIO;\r\ndata->current_msg->complete(data->current_msg->context);\r\ndata->bcurrent_msg_processing = false;\r\ndata->current_msg = NULL;\r\ndata->cur_trans = NULL;\r\n}\r\n}\r\nif (data->use_dma)\r\nreturn IRQ_NONE;\r\nif (reg_spsr_val & (SPSR_FI_BIT | SPSR_RFI_BIT)) {\r\npch_spi_handler_sub(data, reg_spsr_val, io_remap_addr);\r\nret = IRQ_HANDLED;\r\n}\r\ndev_dbg(&board_dat->pdev->dev, "%s EXIT return value=%d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nstatic void pch_spi_set_baud_rate(struct spi_master *master, u32 speed_hz)\r\n{\r\nu32 n_spbr = PCH_CLOCK_HZ / (speed_hz * 2);\r\nif (n_spbr > PCH_MAX_SPBR)\r\nn_spbr = PCH_MAX_SPBR;\r\npch_spi_setclr_reg(master, PCH_SPBRR, n_spbr, MASK_SPBRR_SPBR_BITS);\r\n}\r\nstatic void pch_spi_set_bits_per_word(struct spi_master *master,\r\nu8 bits_per_word)\r\n{\r\nif (bits_per_word == 8)\r\npch_spi_setclr_reg(master, PCH_SPBRR, 0, SPBRR_SIZE_BIT);\r\nelse\r\npch_spi_setclr_reg(master, PCH_SPBRR, SPBRR_SIZE_BIT, 0);\r\n}\r\nstatic void pch_spi_setup_transfer(struct spi_device *spi)\r\n{\r\nu32 flags = 0;\r\ndev_dbg(&spi->dev, "%s SPBRR content =%x setting baud rate=%d\n",\r\n__func__, pch_spi_readreg(spi->master, PCH_SPBRR),\r\nspi->max_speed_hz);\r\npch_spi_set_baud_rate(spi->master, spi->max_speed_hz);\r\npch_spi_set_bits_per_word(spi->master, spi->bits_per_word);\r\nif (!(spi->mode & SPI_LSB_FIRST))\r\nflags |= SPCR_LSBF_BIT;\r\nif (spi->mode & SPI_CPOL)\r\nflags |= SPCR_CPOL_BIT;\r\nif (spi->mode & SPI_CPHA)\r\nflags |= SPCR_CPHA_BIT;\r\npch_spi_setclr_reg(spi->master, PCH_SPCR, flags,\r\n(SPCR_LSBF_BIT | SPCR_CPOL_BIT | SPCR_CPHA_BIT));\r\npch_spi_clear_fifo(spi->master);\r\n}\r\nstatic void pch_spi_reset(struct spi_master *master)\r\n{\r\npch_spi_writereg(master, PCH_SRST, 0x1);\r\npch_spi_writereg(master, PCH_SRST, 0x0);\r\n}\r\nstatic int pch_spi_transfer(struct spi_device *pspi, struct spi_message *pmsg)\r\n{\r\nstruct spi_transfer *transfer;\r\nstruct pch_spi_data *data = spi_master_get_devdata(pspi->master);\r\nint retval;\r\nunsigned long flags;\r\nspin_lock_irqsave(&data->lock, flags);\r\nlist_for_each_entry(transfer, &pmsg->transfers, transfer_list) {\r\nif (!transfer->tx_buf && !transfer->rx_buf) {\r\ndev_err(&pspi->dev,\r\n"%s Tx and Rx buffer NULL\n", __func__);\r\nretval = -EINVAL;\r\ngoto err_return_spinlock;\r\n}\r\nif (!transfer->len) {\r\ndev_err(&pspi->dev, "%s Transfer length invalid\n",\r\n__func__);\r\nretval = -EINVAL;\r\ngoto err_return_spinlock;\r\n}\r\ndev_dbg(&pspi->dev,\r\n"%s Tx/Rx buffer valid. Transfer length valid\n",\r\n__func__);\r\n}\r\nspin_unlock_irqrestore(&data->lock, flags);\r\nif (data->status == STATUS_EXITING) {\r\ndev_err(&pspi->dev, "%s status = STATUS_EXITING.\n", __func__);\r\nretval = -ESHUTDOWN;\r\ngoto err_out;\r\n}\r\nif (data->board_dat->suspend_sts) {\r\ndev_err(&pspi->dev, "%s suspend; returning EINVAL\n", __func__);\r\nretval = -EINVAL;\r\ngoto err_out;\r\n}\r\npmsg->actual_length = 0;\r\ndev_dbg(&pspi->dev, "%s - pmsg->status =%d\n", __func__, pmsg->status);\r\npmsg->status = -EINPROGRESS;\r\nspin_lock_irqsave(&data->lock, flags);\r\nlist_add_tail(&pmsg->queue, &data->queue);\r\nspin_unlock_irqrestore(&data->lock, flags);\r\ndev_dbg(&pspi->dev, "%s - Invoked list_add_tail\n", __func__);\r\nqueue_work(data->wk, &data->work);\r\ndev_dbg(&pspi->dev, "%s - Invoked queue work\n", __func__);\r\nretval = 0;\r\nerr_out:\r\ndev_dbg(&pspi->dev, "%s RETURN=%d\n", __func__, retval);\r\nreturn retval;\r\nerr_return_spinlock:\r\ndev_dbg(&pspi->dev, "%s RETURN=%d\n", __func__, retval);\r\nspin_unlock_irqrestore(&data->lock, flags);\r\nreturn retval;\r\n}\r\nstatic inline void pch_spi_select_chip(struct pch_spi_data *data,\r\nstruct spi_device *pspi)\r\n{\r\nif (data->current_chip != NULL) {\r\nif (pspi->chip_select != data->n_curnt_chip) {\r\ndev_dbg(&pspi->dev, "%s : different slave\n", __func__);\r\ndata->current_chip = NULL;\r\n}\r\n}\r\ndata->current_chip = pspi;\r\ndata->n_curnt_chip = data->current_chip->chip_select;\r\ndev_dbg(&pspi->dev, "%s :Invoking pch_spi_setup_transfer\n", __func__);\r\npch_spi_setup_transfer(pspi);\r\n}\r\nstatic void pch_spi_set_tx(struct pch_spi_data *data, int *bpw)\r\n{\r\nint size;\r\nu32 n_writes;\r\nint j;\r\nstruct spi_message *pmsg, *tmp;\r\nconst u8 *tx_buf;\r\nconst u16 *tx_sbuf;\r\nif (data->cur_trans->speed_hz) {\r\ndev_dbg(&data->master->dev, "%s:setting baud rate\n", __func__);\r\npch_spi_set_baud_rate(data->master, data->cur_trans->speed_hz);\r\n}\r\nif (data->cur_trans->bits_per_word &&\r\n(data->current_msg->spi->bits_per_word != data->cur_trans->bits_per_word)) {\r\ndev_dbg(&data->master->dev, "%s:set bits per word\n", __func__);\r\npch_spi_set_bits_per_word(data->master,\r\ndata->cur_trans->bits_per_word);\r\n*bpw = data->cur_trans->bits_per_word;\r\n} else {\r\n*bpw = data->current_msg->spi->bits_per_word;\r\n}\r\ndata->tx_index = 0;\r\ndata->rx_index = 0;\r\ndata->bpw_len = data->cur_trans->len / (*bpw / 8);\r\nsize = data->cur_trans->len * sizeof(*data->pkt_tx_buff);\r\ndata->pkt_tx_buff = kzalloc(size, GFP_KERNEL);\r\nif (data->pkt_tx_buff != NULL) {\r\ndata->pkt_rx_buff = kzalloc(size, GFP_KERNEL);\r\nif (!data->pkt_rx_buff)\r\nkfree(data->pkt_tx_buff);\r\n}\r\nif (!data->pkt_rx_buff) {\r\ndev_err(&data->master->dev, "%s :kzalloc failed\n", __func__);\r\nlist_for_each_entry_safe(pmsg, tmp, data->queue.next, queue) {\r\npmsg->status = -ENOMEM;\r\nif (pmsg->complete)\r\npmsg->complete(pmsg->context);\r\nlist_del_init(&pmsg->queue);\r\n}\r\nreturn;\r\n}\r\nif (data->cur_trans->tx_buf != NULL) {\r\nif (*bpw == 8) {\r\ntx_buf = data->cur_trans->tx_buf;\r\nfor (j = 0; j < data->bpw_len; j++)\r\ndata->pkt_tx_buff[j] = *tx_buf++;\r\n} else {\r\ntx_sbuf = data->cur_trans->tx_buf;\r\nfor (j = 0; j < data->bpw_len; j++)\r\ndata->pkt_tx_buff[j] = *tx_sbuf++;\r\n}\r\n}\r\nn_writes = data->bpw_len;\r\nif (n_writes > PCH_MAX_FIFO_DEPTH)\r\nn_writes = PCH_MAX_FIFO_DEPTH;\r\ndev_dbg(&data->master->dev, "\n%s:Pulling down SSN low - writing "\r\n"0x2 to SSNXCR\n", __func__);\r\npch_spi_writereg(data->master, PCH_SSNXCR, SSN_LOW);\r\nfor (j = 0; j < n_writes; j++)\r\npch_spi_writereg(data->master, PCH_SPDWR, data->pkt_tx_buff[j]);\r\ndata->tx_index = j;\r\ndata->transfer_complete = false;\r\ndata->transfer_active = true;\r\n}\r\nstatic void pch_spi_nomore_transfer(struct pch_spi_data *data)\r\n{\r\nstruct spi_message *pmsg, *tmp;\r\ndev_dbg(&data->master->dev, "%s called\n", __func__);\r\ndata->current_msg->status = 0;\r\nif (data->current_msg->complete) {\r\ndev_dbg(&data->master->dev,\r\n"%s:Invoking callback of SPI core\n", __func__);\r\ndata->current_msg->complete(data->current_msg->context);\r\n}\r\ndata->bcurrent_msg_processing = false;\r\ndev_dbg(&data->master->dev,\r\n"%s:data->bcurrent_msg_processing = false\n", __func__);\r\ndata->current_msg = NULL;\r\ndata->cur_trans = NULL;\r\nif ((list_empty(&data->queue) == 0) &&\r\n(!data->board_dat->suspend_sts) &&\r\n(data->status != STATUS_EXITING)) {\r\ndev_dbg(&data->master->dev, "%s:Invoke queue_work\n", __func__);\r\nqueue_work(data->wk, &data->work);\r\n} else if (data->board_dat->suspend_sts ||\r\ndata->status == STATUS_EXITING) {\r\ndev_dbg(&data->master->dev,\r\n"%s suspend/remove initiated, flushing queue\n",\r\n__func__);\r\nlist_for_each_entry_safe(pmsg, tmp, data->queue.next, queue) {\r\npmsg->status = -EIO;\r\nif (pmsg->complete)\r\npmsg->complete(pmsg->context);\r\nlist_del_init(&pmsg->queue);\r\n}\r\n}\r\n}\r\nstatic void pch_spi_set_ir(struct pch_spi_data *data)\r\n{\r\nif ((data->bpw_len) > PCH_MAX_FIFO_DEPTH)\r\npch_spi_setclr_reg(data->master, PCH_SPCR,\r\nPCH_RX_THOLD << SPCR_RFIC_FIELD |\r\nSPCR_FIE_BIT | SPCR_RFIE_BIT |\r\nSPCR_ORIE_BIT | SPCR_SPE_BIT,\r\nMASK_RFIC_SPCR_BITS | PCH_ALL);\r\nelse\r\npch_spi_setclr_reg(data->master, PCH_SPCR,\r\nPCH_RX_THOLD_MAX << SPCR_RFIC_FIELD |\r\nSPCR_FIE_BIT | SPCR_ORIE_BIT |\r\nSPCR_SPE_BIT,\r\nMASK_RFIC_SPCR_BITS | PCH_ALL);\r\ndev_dbg(&data->master->dev,\r\n"%s:waiting for transfer to get over\n", __func__);\r\nwait_event_interruptible(data->wait, data->transfer_complete);\r\npch_spi_writereg(data->master, PCH_SPSR,\r\npch_spi_readreg(data->master, PCH_SPSR));\r\npch_spi_setclr_reg(data->master, PCH_SPCR, 0, PCH_ALL | SPCR_SPE_BIT);\r\npch_spi_clear_fifo(data->master);\r\n}\r\nstatic void pch_spi_copy_rx_data(struct pch_spi_data *data, int bpw)\r\n{\r\nint j;\r\nu8 *rx_buf;\r\nu16 *rx_sbuf;\r\nif (!data->cur_trans->rx_buf)\r\nreturn;\r\nif (bpw == 8) {\r\nrx_buf = data->cur_trans->rx_buf;\r\nfor (j = 0; j < data->bpw_len; j++)\r\n*rx_buf++ = data->pkt_rx_buff[j] & 0xFF;\r\n} else {\r\nrx_sbuf = data->cur_trans->rx_buf;\r\nfor (j = 0; j < data->bpw_len; j++)\r\n*rx_sbuf++ = data->pkt_rx_buff[j];\r\n}\r\n}\r\nstatic void pch_spi_copy_rx_data_for_dma(struct pch_spi_data *data, int bpw)\r\n{\r\nint j;\r\nu8 *rx_buf;\r\nu16 *rx_sbuf;\r\nconst u8 *rx_dma_buf;\r\nconst u16 *rx_dma_sbuf;\r\nif (!data->cur_trans->rx_buf)\r\nreturn;\r\nif (bpw == 8) {\r\nrx_buf = data->cur_trans->rx_buf;\r\nrx_dma_buf = data->dma.rx_buf_virt;\r\nfor (j = 0; j < data->bpw_len; j++)\r\n*rx_buf++ = *rx_dma_buf++ & 0xFF;\r\ndata->cur_trans->rx_buf = rx_buf;\r\n} else {\r\nrx_sbuf = data->cur_trans->rx_buf;\r\nrx_dma_sbuf = data->dma.rx_buf_virt;\r\nfor (j = 0; j < data->bpw_len; j++)\r\n*rx_sbuf++ = *rx_dma_sbuf++;\r\ndata->cur_trans->rx_buf = rx_sbuf;\r\n}\r\n}\r\nstatic int pch_spi_start_transfer(struct pch_spi_data *data)\r\n{\r\nstruct pch_spi_dma_ctrl *dma;\r\nunsigned long flags;\r\nint rtn;\r\ndma = &data->dma;\r\nspin_lock_irqsave(&data->lock, flags);\r\npch_spi_setclr_reg(data->master, PCH_SPCR, SPCR_SPE_BIT, PCH_ALL);\r\nspin_unlock_irqrestore(&data->lock, flags);\r\ndev_dbg(&data->master->dev,\r\n"%s:waiting for transfer to get over\n", __func__);\r\nrtn = wait_event_interruptible_timeout(data->wait,\r\ndata->transfer_complete,\r\nmsecs_to_jiffies(2 * HZ));\r\nif (!rtn)\r\ndev_err(&data->master->dev,\r\n"%s wait-event timeout\n", __func__);\r\ndma_sync_sg_for_cpu(&data->master->dev, dma->sg_rx_p, dma->nent,\r\nDMA_FROM_DEVICE);\r\ndma_sync_sg_for_cpu(&data->master->dev, dma->sg_tx_p, dma->nent,\r\nDMA_FROM_DEVICE);\r\nmemset(data->dma.tx_buf_virt, 0, PAGE_SIZE);\r\nasync_tx_ack(dma->desc_rx);\r\nasync_tx_ack(dma->desc_tx);\r\nkfree(dma->sg_tx_p);\r\nkfree(dma->sg_rx_p);\r\nspin_lock_irqsave(&data->lock, flags);\r\npch_spi_setclr_reg(data->master, PCH_SPCR, 0,\r\nMASK_RFIC_SPCR_BITS | MASK_TFIC_SPCR_BITS | PCH_ALL |\r\nSPCR_SPE_BIT);\r\npch_spi_writereg(data->master, PCH_SPSR,\r\npch_spi_readreg(data->master, PCH_SPSR));\r\npch_spi_clear_fifo(data->master);\r\nspin_unlock_irqrestore(&data->lock, flags);\r\nreturn rtn;\r\n}\r\nstatic void pch_dma_rx_complete(void *arg)\r\n{\r\nstruct pch_spi_data *data = arg;\r\ndata->transfer_complete = true;\r\nwake_up_interruptible(&data->wait);\r\n}\r\nstatic bool pch_spi_filter(struct dma_chan *chan, void *slave)\r\n{\r\nstruct pch_dma_slave *param = slave;\r\nif ((chan->chan_id == param->chan_id) &&\r\n(param->dma_dev == chan->device->dev)) {\r\nchan->private = param;\r\nreturn true;\r\n} else {\r\nreturn false;\r\n}\r\n}\r\nstatic void pch_spi_request_dma(struct pch_spi_data *data, int bpw)\r\n{\r\ndma_cap_mask_t mask;\r\nstruct dma_chan *chan;\r\nstruct pci_dev *dma_dev;\r\nstruct pch_dma_slave *param;\r\nstruct pch_spi_dma_ctrl *dma;\r\nunsigned int width;\r\nif (bpw == 8)\r\nwidth = PCH_DMA_WIDTH_1_BYTE;\r\nelse\r\nwidth = PCH_DMA_WIDTH_2_BYTES;\r\ndma = &data->dma;\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\ndma_dev = pci_get_slot(data->board_dat->pdev->bus,\r\nPCI_DEVFN(PCI_SLOT(data->board_dat->pdev->devfn), 0));\r\nparam = &dma->param_tx;\r\nparam->dma_dev = &dma_dev->dev;\r\nparam->chan_id = data->ch * 2; ;\r\nparam->tx_reg = data->io_base_addr + PCH_SPDWR;\r\nparam->width = width;\r\nchan = dma_request_channel(mask, pch_spi_filter, param);\r\nif (!chan) {\r\ndev_err(&data->master->dev,\r\n"ERROR: dma_request_channel FAILS(Tx)\n");\r\ndata->use_dma = 0;\r\nreturn;\r\n}\r\ndma->chan_tx = chan;\r\nparam = &dma->param_rx;\r\nparam->dma_dev = &dma_dev->dev;\r\nparam->chan_id = data->ch * 2 + 1; ;\r\nparam->rx_reg = data->io_base_addr + PCH_SPDRR;\r\nparam->width = width;\r\nchan = dma_request_channel(mask, pch_spi_filter, param);\r\nif (!chan) {\r\ndev_err(&data->master->dev,\r\n"ERROR: dma_request_channel FAILS(Rx)\n");\r\ndma_release_channel(dma->chan_tx);\r\ndma->chan_tx = NULL;\r\ndata->use_dma = 0;\r\nreturn;\r\n}\r\ndma->chan_rx = chan;\r\n}\r\nstatic void pch_spi_release_dma(struct pch_spi_data *data)\r\n{\r\nstruct pch_spi_dma_ctrl *dma;\r\ndma = &data->dma;\r\nif (dma->chan_tx) {\r\ndma_release_channel(dma->chan_tx);\r\ndma->chan_tx = NULL;\r\n}\r\nif (dma->chan_rx) {\r\ndma_release_channel(dma->chan_rx);\r\ndma->chan_rx = NULL;\r\n}\r\nreturn;\r\n}\r\nstatic void pch_spi_handle_dma(struct pch_spi_data *data, int *bpw)\r\n{\r\nconst u8 *tx_buf;\r\nconst u16 *tx_sbuf;\r\nu8 *tx_dma_buf;\r\nu16 *tx_dma_sbuf;\r\nstruct scatterlist *sg;\r\nstruct dma_async_tx_descriptor *desc_tx;\r\nstruct dma_async_tx_descriptor *desc_rx;\r\nint num;\r\nint i;\r\nint size;\r\nint rem;\r\nint head;\r\nunsigned long flags;\r\nstruct pch_spi_dma_ctrl *dma;\r\ndma = &data->dma;\r\nif (data->cur_trans->speed_hz) {\r\ndev_dbg(&data->master->dev, "%s:setting baud rate\n", __func__);\r\nspin_lock_irqsave(&data->lock, flags);\r\npch_spi_set_baud_rate(data->master, data->cur_trans->speed_hz);\r\nspin_unlock_irqrestore(&data->lock, flags);\r\n}\r\nif (data->cur_trans->bits_per_word &&\r\n(data->current_msg->spi->bits_per_word !=\r\ndata->cur_trans->bits_per_word)) {\r\ndev_dbg(&data->master->dev, "%s:set bits per word\n", __func__);\r\nspin_lock_irqsave(&data->lock, flags);\r\npch_spi_set_bits_per_word(data->master,\r\ndata->cur_trans->bits_per_word);\r\nspin_unlock_irqrestore(&data->lock, flags);\r\n*bpw = data->cur_trans->bits_per_word;\r\n} else {\r\n*bpw = data->current_msg->spi->bits_per_word;\r\n}\r\ndata->bpw_len = data->cur_trans->len / (*bpw / 8);\r\nif (data->bpw_len > PCH_BUF_SIZE) {\r\ndata->bpw_len = PCH_BUF_SIZE;\r\ndata->cur_trans->len -= PCH_BUF_SIZE;\r\n}\r\nif (data->cur_trans->tx_buf != NULL) {\r\nif (*bpw == 8) {\r\ntx_buf = data->cur_trans->tx_buf;\r\ntx_dma_buf = dma->tx_buf_virt;\r\nfor (i = 0; i < data->bpw_len; i++)\r\n*tx_dma_buf++ = *tx_buf++;\r\n} else {\r\ntx_sbuf = data->cur_trans->tx_buf;\r\ntx_dma_sbuf = dma->tx_buf_virt;\r\nfor (i = 0; i < data->bpw_len; i++)\r\n*tx_dma_sbuf++ = *tx_sbuf++;\r\n}\r\n}\r\nif (data->bpw_len > PCH_DMA_TRANS_SIZE) {\r\nif (data->bpw_len % PCH_DMA_TRANS_SIZE) {\r\nnum = data->bpw_len / PCH_DMA_TRANS_SIZE + 1;\r\nrem = data->bpw_len % PCH_DMA_TRANS_SIZE;\r\n} else {\r\nnum = data->bpw_len / PCH_DMA_TRANS_SIZE;\r\nrem = PCH_DMA_TRANS_SIZE;\r\n}\r\nsize = PCH_DMA_TRANS_SIZE;\r\n} else {\r\nnum = 1;\r\nsize = data->bpw_len;\r\nrem = data->bpw_len;\r\n}\r\ndev_dbg(&data->master->dev, "%s num=%d size=%d rem=%d\n",\r\n__func__, num, size, rem);\r\nspin_lock_irqsave(&data->lock, flags);\r\npch_spi_setclr_reg(data->master, PCH_SPCR,\r\n((size - 1) << SPCR_RFIC_FIELD) |\r\n(PCH_TX_THOLD << SPCR_TFIC_FIELD),\r\nMASK_RFIC_SPCR_BITS | MASK_TFIC_SPCR_BITS);\r\nspin_unlock_irqrestore(&data->lock, flags);\r\ndma->sg_rx_p = kzalloc(sizeof(struct scatterlist)*num, GFP_ATOMIC);\r\nsg_init_table(dma->sg_rx_p, num);\r\nsg = dma->sg_rx_p;\r\nfor (i = 0; i < num; i++, sg++) {\r\nif (i == (num - 2)) {\r\nsg->offset = size * i;\r\nsg->offset = sg->offset * (*bpw / 8);\r\nsg_set_page(sg, virt_to_page(dma->rx_buf_virt), rem,\r\nsg->offset);\r\nsg_dma_len(sg) = rem;\r\n} else if (i == (num - 1)) {\r\nsg->offset = size * (i - 1) + rem;\r\nsg->offset = sg->offset * (*bpw / 8);\r\nsg_set_page(sg, virt_to_page(dma->rx_buf_virt), size,\r\nsg->offset);\r\nsg_dma_len(sg) = size;\r\n} else {\r\nsg->offset = size * i;\r\nsg->offset = sg->offset * (*bpw / 8);\r\nsg_set_page(sg, virt_to_page(dma->rx_buf_virt), size,\r\nsg->offset);\r\nsg_dma_len(sg) = size;\r\n}\r\nsg_dma_address(sg) = dma->rx_buf_dma + sg->offset;\r\n}\r\nsg = dma->sg_rx_p;\r\ndesc_rx = dmaengine_prep_slave_sg(dma->chan_rx, sg,\r\nnum, DMA_DEV_TO_MEM,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!desc_rx) {\r\ndev_err(&data->master->dev,\r\n"%s:dmaengine_prep_slave_sg Failed\n", __func__);\r\nreturn;\r\n}\r\ndma_sync_sg_for_device(&data->master->dev, sg, num, DMA_FROM_DEVICE);\r\ndesc_rx->callback = pch_dma_rx_complete;\r\ndesc_rx->callback_param = data;\r\ndma->nent = num;\r\ndma->desc_rx = desc_rx;\r\nif (data->bpw_len > PCH_MAX_FIFO_DEPTH) {\r\nhead = PCH_MAX_FIFO_DEPTH - PCH_DMA_TRANS_SIZE;\r\nif (data->bpw_len % PCH_DMA_TRANS_SIZE > 4) {\r\nnum = data->bpw_len / PCH_DMA_TRANS_SIZE + 1;\r\nrem = data->bpw_len % PCH_DMA_TRANS_SIZE - head;\r\n} else {\r\nnum = data->bpw_len / PCH_DMA_TRANS_SIZE;\r\nrem = data->bpw_len % PCH_DMA_TRANS_SIZE +\r\nPCH_DMA_TRANS_SIZE - head;\r\n}\r\nsize = PCH_DMA_TRANS_SIZE;\r\n} else {\r\nnum = 1;\r\nsize = data->bpw_len;\r\nrem = data->bpw_len;\r\nhead = 0;\r\n}\r\ndma->sg_tx_p = kzalloc(sizeof(struct scatterlist)*num, GFP_ATOMIC);\r\nsg_init_table(dma->sg_tx_p, num);\r\nsg = dma->sg_tx_p;\r\nfor (i = 0; i < num; i++, sg++) {\r\nif (i == 0) {\r\nsg->offset = 0;\r\nsg_set_page(sg, virt_to_page(dma->tx_buf_virt), size + head,\r\nsg->offset);\r\nsg_dma_len(sg) = size + head;\r\n} else if (i == (num - 1)) {\r\nsg->offset = head + size * i;\r\nsg->offset = sg->offset * (*bpw / 8);\r\nsg_set_page(sg, virt_to_page(dma->tx_buf_virt), rem,\r\nsg->offset);\r\nsg_dma_len(sg) = rem;\r\n} else {\r\nsg->offset = head + size * i;\r\nsg->offset = sg->offset * (*bpw / 8);\r\nsg_set_page(sg, virt_to_page(dma->tx_buf_virt), size,\r\nsg->offset);\r\nsg_dma_len(sg) = size;\r\n}\r\nsg_dma_address(sg) = dma->tx_buf_dma + sg->offset;\r\n}\r\nsg = dma->sg_tx_p;\r\ndesc_tx = dmaengine_prep_slave_sg(dma->chan_tx,\r\nsg, num, DMA_MEM_TO_DEV,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!desc_tx) {\r\ndev_err(&data->master->dev,\r\n"%s:dmaengine_prep_slave_sg Failed\n", __func__);\r\nreturn;\r\n}\r\ndma_sync_sg_for_device(&data->master->dev, sg, num, DMA_TO_DEVICE);\r\ndesc_tx->callback = NULL;\r\ndesc_tx->callback_param = data;\r\ndma->nent = num;\r\ndma->desc_tx = desc_tx;\r\ndev_dbg(&data->master->dev, "%s:Pulling down SSN low - writing 0x2 to SSNXCR\n", __func__);\r\nspin_lock_irqsave(&data->lock, flags);\r\npch_spi_writereg(data->master, PCH_SSNXCR, SSN_LOW);\r\ndesc_rx->tx_submit(desc_rx);\r\ndesc_tx->tx_submit(desc_tx);\r\nspin_unlock_irqrestore(&data->lock, flags);\r\ndata->transfer_complete = false;\r\n}\r\nstatic void pch_spi_process_messages(struct work_struct *pwork)\r\n{\r\nstruct spi_message *pmsg, *tmp;\r\nstruct pch_spi_data *data;\r\nint bpw;\r\ndata = container_of(pwork, struct pch_spi_data, work);\r\ndev_dbg(&data->master->dev, "%s data initialized\n", __func__);\r\nspin_lock(&data->lock);\r\nif (data->board_dat->suspend_sts || (data->status == STATUS_EXITING)) {\r\ndev_dbg(&data->master->dev,\r\n"%s suspend/remove initiated, flushing queue\n", __func__);\r\nlist_for_each_entry_safe(pmsg, tmp, data->queue.next, queue) {\r\npmsg->status = -EIO;\r\nif (pmsg->complete) {\r\nspin_unlock(&data->lock);\r\npmsg->complete(pmsg->context);\r\nspin_lock(&data->lock);\r\n}\r\nlist_del_init(&pmsg->queue);\r\n}\r\nspin_unlock(&data->lock);\r\nreturn;\r\n}\r\ndata->bcurrent_msg_processing = true;\r\ndev_dbg(&data->master->dev,\r\n"%s Set data->bcurrent_msg_processing= true\n", __func__);\r\ndata->current_msg = list_entry(data->queue.next, struct spi_message,\r\nqueue);\r\nlist_del_init(&data->current_msg->queue);\r\ndata->current_msg->status = 0;\r\npch_spi_select_chip(data, data->current_msg->spi);\r\nspin_unlock(&data->lock);\r\nif (data->use_dma)\r\npch_spi_request_dma(data,\r\ndata->current_msg->spi->bits_per_word);\r\npch_spi_writereg(data->master, PCH_SSNXCR, SSN_NO_CONTROL);\r\ndo {\r\nint cnt;\r\nspin_lock(&data->lock);\r\nif (data->cur_trans == NULL) {\r\ndata->cur_trans =\r\nlist_entry(data->current_msg->transfers.next,\r\nstruct spi_transfer, transfer_list);\r\ndev_dbg(&data->master->dev, "%s "\r\n":Getting 1st transfer message\n", __func__);\r\n} else {\r\ndata->cur_trans =\r\nlist_entry(data->cur_trans->transfer_list.next,\r\nstruct spi_transfer, transfer_list);\r\ndev_dbg(&data->master->dev, "%s "\r\n":Getting next transfer message\n", __func__);\r\n}\r\nspin_unlock(&data->lock);\r\nif (!data->cur_trans->len)\r\ngoto out;\r\ncnt = (data->cur_trans->len - 1) / PCH_BUF_SIZE + 1;\r\ndata->save_total_len = data->cur_trans->len;\r\nif (data->use_dma) {\r\nint i;\r\nchar *save_rx_buf = data->cur_trans->rx_buf;\r\nfor (i = 0; i < cnt; i ++) {\r\npch_spi_handle_dma(data, &bpw);\r\nif (!pch_spi_start_transfer(data)) {\r\ndata->transfer_complete = true;\r\ndata->current_msg->status = -EIO;\r\ndata->current_msg->complete\r\n(data->current_msg->context);\r\ndata->bcurrent_msg_processing = false;\r\ndata->current_msg = NULL;\r\ndata->cur_trans = NULL;\r\ngoto out;\r\n}\r\npch_spi_copy_rx_data_for_dma(data, bpw);\r\n}\r\ndata->cur_trans->rx_buf = save_rx_buf;\r\n} else {\r\npch_spi_set_tx(data, &bpw);\r\npch_spi_set_ir(data);\r\npch_spi_copy_rx_data(data, bpw);\r\nkfree(data->pkt_rx_buff);\r\ndata->pkt_rx_buff = NULL;\r\nkfree(data->pkt_tx_buff);\r\ndata->pkt_tx_buff = NULL;\r\n}\r\ndata->cur_trans->len = data->save_total_len;\r\ndata->current_msg->actual_length += data->cur_trans->len;\r\ndev_dbg(&data->master->dev,\r\n"%s:data->current_msg->actual_length=%d\n",\r\n__func__, data->current_msg->actual_length);\r\nif (data->cur_trans->delay_usecs) {\r\ndev_dbg(&data->master->dev, "%s:"\r\n"delay in usec=%d\n", __func__,\r\ndata->cur_trans->delay_usecs);\r\nudelay(data->cur_trans->delay_usecs);\r\n}\r\nspin_lock(&data->lock);\r\nif ((data->cur_trans->transfer_list.next) ==\r\n&(data->current_msg->transfers)) {\r\npch_spi_nomore_transfer(data);\r\n}\r\nspin_unlock(&data->lock);\r\n} while (data->cur_trans != NULL);\r\nout:\r\npch_spi_writereg(data->master, PCH_SSNXCR, SSN_HIGH);\r\nif (data->use_dma)\r\npch_spi_release_dma(data);\r\n}\r\nstatic void pch_spi_free_resources(struct pch_spi_board_data *board_dat,\r\nstruct pch_spi_data *data)\r\n{\r\ndev_dbg(&board_dat->pdev->dev, "%s ENTRY\n", __func__);\r\nif (data->wk != NULL) {\r\ndestroy_workqueue(data->wk);\r\ndata->wk = NULL;\r\ndev_dbg(&board_dat->pdev->dev,\r\n"%s destroy_workqueue invoked successfully\n",\r\n__func__);\r\n}\r\n}\r\nstatic int pch_spi_get_resources(struct pch_spi_board_data *board_dat,\r\nstruct pch_spi_data *data)\r\n{\r\nint retval = 0;\r\ndev_dbg(&board_dat->pdev->dev, "%s ENTRY\n", __func__);\r\ndata->wk = create_singlethread_workqueue(KBUILD_MODNAME);\r\nif (!data->wk) {\r\ndev_err(&board_dat->pdev->dev,\r\n"%s create_singlet hread_workqueue failed\n", __func__);\r\nretval = -EBUSY;\r\ngoto err_return;\r\n}\r\npch_spi_reset(data->master);\r\ndev_dbg(&board_dat->pdev->dev,\r\n"%s pch_spi_reset invoked successfully\n", __func__);\r\ndev_dbg(&board_dat->pdev->dev, "%s data->irq_reg_sts=true\n", __func__);\r\nerr_return:\r\nif (retval != 0) {\r\ndev_err(&board_dat->pdev->dev,\r\n"%s FAIL:invoking pch_spi_free_resources\n", __func__);\r\npch_spi_free_resources(board_dat, data);\r\n}\r\ndev_dbg(&board_dat->pdev->dev, "%s Return=%d\n", __func__, retval);\r\nreturn retval;\r\n}\r\nstatic void pch_free_dma_buf(struct pch_spi_board_data *board_dat,\r\nstruct pch_spi_data *data)\r\n{\r\nstruct pch_spi_dma_ctrl *dma;\r\ndma = &data->dma;\r\nif (dma->tx_buf_dma)\r\ndma_free_coherent(&board_dat->pdev->dev, PCH_BUF_SIZE,\r\ndma->tx_buf_virt, dma->tx_buf_dma);\r\nif (dma->rx_buf_dma)\r\ndma_free_coherent(&board_dat->pdev->dev, PCH_BUF_SIZE,\r\ndma->rx_buf_virt, dma->rx_buf_dma);\r\nreturn;\r\n}\r\nstatic void pch_alloc_dma_buf(struct pch_spi_board_data *board_dat,\r\nstruct pch_spi_data *data)\r\n{\r\nstruct pch_spi_dma_ctrl *dma;\r\ndma = &data->dma;\r\ndma->tx_buf_virt = dma_alloc_coherent(&board_dat->pdev->dev,\r\nPCH_BUF_SIZE, &dma->tx_buf_dma, GFP_KERNEL);\r\ndma->rx_buf_virt = dma_alloc_coherent(&board_dat->pdev->dev,\r\nPCH_BUF_SIZE, &dma->rx_buf_dma, GFP_KERNEL);\r\n}\r\nstatic int pch_spi_pd_probe(struct platform_device *plat_dev)\r\n{\r\nint ret;\r\nstruct spi_master *master;\r\nstruct pch_spi_board_data *board_dat = dev_get_platdata(&plat_dev->dev);\r\nstruct pch_spi_data *data;\r\ndev_dbg(&plat_dev->dev, "%s:debug\n", __func__);\r\nmaster = spi_alloc_master(&board_dat->pdev->dev,\r\nsizeof(struct pch_spi_data));\r\nif (!master) {\r\ndev_err(&plat_dev->dev, "spi_alloc_master[%d] failed.\n",\r\nplat_dev->id);\r\nreturn -ENOMEM;\r\n}\r\ndata = spi_master_get_devdata(master);\r\ndata->master = master;\r\nplatform_set_drvdata(plat_dev, data);\r\ndata->io_base_addr = pci_resource_start(board_dat->pdev, 1) +\r\nPCH_ADDRESS_SIZE * plat_dev->id;\r\ndata->io_remap_addr = pci_iomap(board_dat->pdev, 1, 0);\r\nif (!data->io_remap_addr) {\r\ndev_err(&plat_dev->dev, "%s pci_iomap failed\n", __func__);\r\nret = -ENOMEM;\r\ngoto err_pci_iomap;\r\n}\r\ndata->io_remap_addr += PCH_ADDRESS_SIZE * plat_dev->id;\r\ndev_dbg(&plat_dev->dev, "[ch%d] remap_addr=%p\n",\r\nplat_dev->id, data->io_remap_addr);\r\nmaster->num_chipselect = PCH_MAX_CS;\r\nmaster->transfer = pch_spi_transfer;\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_LSB_FIRST;\r\nmaster->bits_per_word_mask = SPI_BPW_MASK(8) | SPI_BPW_MASK(16);\r\nmaster->max_speed_hz = PCH_MAX_BAUDRATE;\r\ndata->board_dat = board_dat;\r\ndata->plat_dev = plat_dev;\r\ndata->n_curnt_chip = 255;\r\ndata->status = STATUS_RUNNING;\r\ndata->ch = plat_dev->id;\r\ndata->use_dma = use_dma;\r\nINIT_LIST_HEAD(&data->queue);\r\nspin_lock_init(&data->lock);\r\nINIT_WORK(&data->work, pch_spi_process_messages);\r\ninit_waitqueue_head(&data->wait);\r\nret = pch_spi_get_resources(board_dat, data);\r\nif (ret) {\r\ndev_err(&plat_dev->dev, "%s fail(retval=%d)\n", __func__, ret);\r\ngoto err_spi_get_resources;\r\n}\r\nret = request_irq(board_dat->pdev->irq, pch_spi_handler,\r\nIRQF_SHARED, KBUILD_MODNAME, data);\r\nif (ret) {\r\ndev_err(&plat_dev->dev,\r\n"%s request_irq failed\n", __func__);\r\ngoto err_request_irq;\r\n}\r\ndata->irq_reg_sts = true;\r\npch_spi_set_master_mode(master);\r\nif (use_dma) {\r\ndev_info(&plat_dev->dev, "Use DMA for data transfers\n");\r\npch_alloc_dma_buf(board_dat, data);\r\n}\r\nret = spi_register_master(master);\r\nif (ret != 0) {\r\ndev_err(&plat_dev->dev,\r\n"%s spi_register_master FAILED\n", __func__);\r\ngoto err_spi_register_master;\r\n}\r\nreturn 0;\r\nerr_spi_register_master:\r\npch_free_dma_buf(board_dat, data);\r\nfree_irq(board_dat->pdev->irq, data);\r\nerr_request_irq:\r\npch_spi_free_resources(board_dat, data);\r\nerr_spi_get_resources:\r\npci_iounmap(board_dat->pdev, data->io_remap_addr);\r\nerr_pci_iomap:\r\nspi_master_put(master);\r\nreturn ret;\r\n}\r\nstatic int pch_spi_pd_remove(struct platform_device *plat_dev)\r\n{\r\nstruct pch_spi_board_data *board_dat = dev_get_platdata(&plat_dev->dev);\r\nstruct pch_spi_data *data = platform_get_drvdata(plat_dev);\r\nint count;\r\nunsigned long flags;\r\ndev_dbg(&plat_dev->dev, "%s:[ch%d] irq=%d\n",\r\n__func__, plat_dev->id, board_dat->pdev->irq);\r\nif (use_dma)\r\npch_free_dma_buf(board_dat, data);\r\ncount = 500;\r\nspin_lock_irqsave(&data->lock, flags);\r\ndata->status = STATUS_EXITING;\r\nwhile ((list_empty(&data->queue) == 0) && --count) {\r\ndev_dbg(&board_dat->pdev->dev, "%s :queue not empty\n",\r\n__func__);\r\nspin_unlock_irqrestore(&data->lock, flags);\r\nmsleep(PCH_SLEEP_TIME);\r\nspin_lock_irqsave(&data->lock, flags);\r\n}\r\nspin_unlock_irqrestore(&data->lock, flags);\r\npch_spi_free_resources(board_dat, data);\r\nif (data->irq_reg_sts) {\r\npch_spi_setclr_reg(data->master, PCH_SPCR, 0, PCH_ALL);\r\ndata->irq_reg_sts = false;\r\nfree_irq(board_dat->pdev->irq, data);\r\n}\r\npci_iounmap(board_dat->pdev, data->io_remap_addr);\r\nspi_unregister_master(data->master);\r\nreturn 0;\r\n}\r\nstatic int pch_spi_pd_suspend(struct platform_device *pd_dev,\r\npm_message_t state)\r\n{\r\nu8 count;\r\nstruct pch_spi_board_data *board_dat = dev_get_platdata(&pd_dev->dev);\r\nstruct pch_spi_data *data = platform_get_drvdata(pd_dev);\r\ndev_dbg(&pd_dev->dev, "%s ENTRY\n", __func__);\r\nif (!board_dat) {\r\ndev_err(&pd_dev->dev,\r\n"%s pci_get_drvdata returned NULL\n", __func__);\r\nreturn -EFAULT;\r\n}\r\ncount = 255;\r\nwhile ((--count) > 0) {\r\nif (!(data->bcurrent_msg_processing))\r\nbreak;\r\nmsleep(PCH_SLEEP_TIME);\r\n}\r\nif (data->irq_reg_sts) {\r\npch_spi_setclr_reg(data->master, PCH_SPCR, 0, PCH_ALL);\r\npch_spi_reset(data->master);\r\nfree_irq(board_dat->pdev->irq, data);\r\ndata->irq_reg_sts = false;\r\ndev_dbg(&pd_dev->dev,\r\n"%s free_irq invoked successfully.\n", __func__);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pch_spi_pd_resume(struct platform_device *pd_dev)\r\n{\r\nstruct pch_spi_board_data *board_dat = dev_get_platdata(&pd_dev->dev);\r\nstruct pch_spi_data *data = platform_get_drvdata(pd_dev);\r\nint retval;\r\nif (!board_dat) {\r\ndev_err(&pd_dev->dev,\r\n"%s pci_get_drvdata returned NULL\n", __func__);\r\nreturn -EFAULT;\r\n}\r\nif (!data->irq_reg_sts) {\r\nretval = request_irq(board_dat->pdev->irq, pch_spi_handler,\r\nIRQF_SHARED, KBUILD_MODNAME, data);\r\nif (retval < 0) {\r\ndev_err(&pd_dev->dev,\r\n"%s request_irq failed\n", __func__);\r\nreturn retval;\r\n}\r\npch_spi_reset(data->master);\r\npch_spi_set_master_mode(data->master);\r\ndata->irq_reg_sts = true;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pch_spi_probe(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nstruct pch_spi_board_data *board_dat;\r\nstruct platform_device *pd_dev = NULL;\r\nint retval;\r\nint i;\r\nstruct pch_pd_dev_save *pd_dev_save;\r\npd_dev_save = kzalloc(sizeof(struct pch_pd_dev_save), GFP_KERNEL);\r\nif (!pd_dev_save)\r\nreturn -ENOMEM;\r\nboard_dat = kzalloc(sizeof(struct pch_spi_board_data), GFP_KERNEL);\r\nif (!board_dat) {\r\nretval = -ENOMEM;\r\ngoto err_no_mem;\r\n}\r\nretval = pci_request_regions(pdev, KBUILD_MODNAME);\r\nif (retval) {\r\ndev_err(&pdev->dev, "%s request_region failed\n", __func__);\r\ngoto pci_request_regions;\r\n}\r\nboard_dat->pdev = pdev;\r\nboard_dat->num = id->driver_data;\r\npd_dev_save->num = id->driver_data;\r\npd_dev_save->board_dat = board_dat;\r\nretval = pci_enable_device(pdev);\r\nif (retval) {\r\ndev_err(&pdev->dev, "%s pci_enable_device failed\n", __func__);\r\ngoto pci_enable_device;\r\n}\r\nfor (i = 0; i < board_dat->num; i++) {\r\npd_dev = platform_device_alloc("pch-spi", i);\r\nif (!pd_dev) {\r\ndev_err(&pdev->dev, "platform_device_alloc failed\n");\r\nretval = -ENOMEM;\r\ngoto err_platform_device;\r\n}\r\npd_dev_save->pd_save[i] = pd_dev;\r\npd_dev->dev.parent = &pdev->dev;\r\nretval = platform_device_add_data(pd_dev, board_dat,\r\nsizeof(*board_dat));\r\nif (retval) {\r\ndev_err(&pdev->dev,\r\n"platform_device_add_data failed\n");\r\nplatform_device_put(pd_dev);\r\ngoto err_platform_device;\r\n}\r\nretval = platform_device_add(pd_dev);\r\nif (retval) {\r\ndev_err(&pdev->dev, "platform_device_add failed\n");\r\nplatform_device_put(pd_dev);\r\ngoto err_platform_device;\r\n}\r\n}\r\npci_set_drvdata(pdev, pd_dev_save);\r\nreturn 0;\r\nerr_platform_device:\r\nwhile (--i >= 0)\r\nplatform_device_unregister(pd_dev_save->pd_save[i]);\r\npci_disable_device(pdev);\r\npci_enable_device:\r\npci_release_regions(pdev);\r\npci_request_regions:\r\nkfree(board_dat);\r\nerr_no_mem:\r\nkfree(pd_dev_save);\r\nreturn retval;\r\n}\r\nstatic void pch_spi_remove(struct pci_dev *pdev)\r\n{\r\nint i;\r\nstruct pch_pd_dev_save *pd_dev_save = pci_get_drvdata(pdev);\r\ndev_dbg(&pdev->dev, "%s ENTRY:pdev=%p\n", __func__, pdev);\r\nfor (i = 0; i < pd_dev_save->num; i++)\r\nplatform_device_unregister(pd_dev_save->pd_save[i]);\r\npci_disable_device(pdev);\r\npci_release_regions(pdev);\r\nkfree(pd_dev_save->board_dat);\r\nkfree(pd_dev_save);\r\n}\r\nstatic int pch_spi_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nint retval;\r\nstruct pch_pd_dev_save *pd_dev_save = pci_get_drvdata(pdev);\r\ndev_dbg(&pdev->dev, "%s ENTRY\n", __func__);\r\npd_dev_save->board_dat->suspend_sts = true;\r\nretval = pci_save_state(pdev);\r\nif (retval == 0) {\r\npci_enable_wake(pdev, PCI_D3hot, 0);\r\npci_disable_device(pdev);\r\npci_set_power_state(pdev, PCI_D3hot);\r\n} else {\r\ndev_err(&pdev->dev, "%s pci_save_state failed\n", __func__);\r\n}\r\nreturn retval;\r\n}\r\nstatic int pch_spi_resume(struct pci_dev *pdev)\r\n{\r\nint retval;\r\nstruct pch_pd_dev_save *pd_dev_save = pci_get_drvdata(pdev);\r\ndev_dbg(&pdev->dev, "%s ENTRY\n", __func__);\r\npci_set_power_state(pdev, PCI_D0);\r\npci_restore_state(pdev);\r\nretval = pci_enable_device(pdev);\r\nif (retval < 0) {\r\ndev_err(&pdev->dev,\r\n"%s pci_enable_device failed\n", __func__);\r\n} else {\r\npci_enable_wake(pdev, PCI_D3hot, 0);\r\npd_dev_save->board_dat->suspend_sts = false;\r\n}\r\nreturn retval;\r\n}\r\nstatic int __init pch_spi_init(void)\r\n{\r\nint ret;\r\nret = platform_driver_register(&pch_spi_pd_driver);\r\nif (ret)\r\nreturn ret;\r\nret = pci_register_driver(&pch_spi_pcidev_driver);\r\nif (ret) {\r\nplatform_driver_unregister(&pch_spi_pd_driver);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit pch_spi_exit(void)\r\n{\r\npci_unregister_driver(&pch_spi_pcidev_driver);\r\nplatform_driver_unregister(&pch_spi_pd_driver);\r\n}
