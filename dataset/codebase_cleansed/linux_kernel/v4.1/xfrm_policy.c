static inline bool\r\n__xfrm4_selector_match(const struct xfrm_selector *sel, const struct flowi *fl)\r\n{\r\nconst struct flowi4 *fl4 = &fl->u.ip4;\r\nreturn addr4_match(fl4->daddr, sel->daddr.a4, sel->prefixlen_d) &&\r\naddr4_match(fl4->saddr, sel->saddr.a4, sel->prefixlen_s) &&\r\n!((xfrm_flowi_dport(fl, &fl4->uli) ^ sel->dport) & sel->dport_mask) &&\r\n!((xfrm_flowi_sport(fl, &fl4->uli) ^ sel->sport) & sel->sport_mask) &&\r\n(fl4->flowi4_proto == sel->proto || !sel->proto) &&\r\n(fl4->flowi4_oif == sel->ifindex || !sel->ifindex);\r\n}\r\nstatic inline bool\r\n__xfrm6_selector_match(const struct xfrm_selector *sel, const struct flowi *fl)\r\n{\r\nconst struct flowi6 *fl6 = &fl->u.ip6;\r\nreturn addr_match(&fl6->daddr, &sel->daddr, sel->prefixlen_d) &&\r\naddr_match(&fl6->saddr, &sel->saddr, sel->prefixlen_s) &&\r\n!((xfrm_flowi_dport(fl, &fl6->uli) ^ sel->dport) & sel->dport_mask) &&\r\n!((xfrm_flowi_sport(fl, &fl6->uli) ^ sel->sport) & sel->sport_mask) &&\r\n(fl6->flowi6_proto == sel->proto || !sel->proto) &&\r\n(fl6->flowi6_oif == sel->ifindex || !sel->ifindex);\r\n}\r\nbool xfrm_selector_match(const struct xfrm_selector *sel, const struct flowi *fl,\r\nunsigned short family)\r\n{\r\nswitch (family) {\r\ncase AF_INET:\r\nreturn __xfrm4_selector_match(sel, fl);\r\ncase AF_INET6:\r\nreturn __xfrm6_selector_match(sel, fl);\r\n}\r\nreturn false;\r\n}\r\nstatic struct xfrm_policy_afinfo *xfrm_policy_get_afinfo(unsigned short family)\r\n{\r\nstruct xfrm_policy_afinfo *afinfo;\r\nif (unlikely(family >= NPROTO))\r\nreturn NULL;\r\nrcu_read_lock();\r\nafinfo = rcu_dereference(xfrm_policy_afinfo[family]);\r\nif (unlikely(!afinfo))\r\nrcu_read_unlock();\r\nreturn afinfo;\r\n}\r\nstatic void xfrm_policy_put_afinfo(struct xfrm_policy_afinfo *afinfo)\r\n{\r\nrcu_read_unlock();\r\n}\r\nstatic inline struct dst_entry *__xfrm_dst_lookup(struct net *net, int tos,\r\nconst xfrm_address_t *saddr,\r\nconst xfrm_address_t *daddr,\r\nint family)\r\n{\r\nstruct xfrm_policy_afinfo *afinfo;\r\nstruct dst_entry *dst;\r\nafinfo = xfrm_policy_get_afinfo(family);\r\nif (unlikely(afinfo == NULL))\r\nreturn ERR_PTR(-EAFNOSUPPORT);\r\ndst = afinfo->dst_lookup(net, tos, saddr, daddr);\r\nxfrm_policy_put_afinfo(afinfo);\r\nreturn dst;\r\n}\r\nstatic inline struct dst_entry *xfrm_dst_lookup(struct xfrm_state *x, int tos,\r\nxfrm_address_t *prev_saddr,\r\nxfrm_address_t *prev_daddr,\r\nint family)\r\n{\r\nstruct net *net = xs_net(x);\r\nxfrm_address_t *saddr = &x->props.saddr;\r\nxfrm_address_t *daddr = &x->id.daddr;\r\nstruct dst_entry *dst;\r\nif (x->type->flags & XFRM_TYPE_LOCAL_COADDR) {\r\nsaddr = x->coaddr;\r\ndaddr = prev_daddr;\r\n}\r\nif (x->type->flags & XFRM_TYPE_REMOTE_COADDR) {\r\nsaddr = prev_saddr;\r\ndaddr = x->coaddr;\r\n}\r\ndst = __xfrm_dst_lookup(net, tos, saddr, daddr, family);\r\nif (!IS_ERR(dst)) {\r\nif (prev_saddr != saddr)\r\nmemcpy(prev_saddr, saddr, sizeof(*prev_saddr));\r\nif (prev_daddr != daddr)\r\nmemcpy(prev_daddr, daddr, sizeof(*prev_daddr));\r\n}\r\nreturn dst;\r\n}\r\nstatic inline unsigned long make_jiffies(long secs)\r\n{\r\nif (secs >= (MAX_SCHEDULE_TIMEOUT-1)/HZ)\r\nreturn MAX_SCHEDULE_TIMEOUT-1;\r\nelse\r\nreturn secs*HZ;\r\n}\r\nstatic void xfrm_policy_timer(unsigned long data)\r\n{\r\nstruct xfrm_policy *xp = (struct xfrm_policy *)data;\r\nunsigned long now = get_seconds();\r\nlong next = LONG_MAX;\r\nint warn = 0;\r\nint dir;\r\nread_lock(&xp->lock);\r\nif (unlikely(xp->walk.dead))\r\ngoto out;\r\ndir = xfrm_policy_id2dir(xp->index);\r\nif (xp->lft.hard_add_expires_seconds) {\r\nlong tmo = xp->lft.hard_add_expires_seconds +\r\nxp->curlft.add_time - now;\r\nif (tmo <= 0)\r\ngoto expired;\r\nif (tmo < next)\r\nnext = tmo;\r\n}\r\nif (xp->lft.hard_use_expires_seconds) {\r\nlong tmo = xp->lft.hard_use_expires_seconds +\r\n(xp->curlft.use_time ? : xp->curlft.add_time) - now;\r\nif (tmo <= 0)\r\ngoto expired;\r\nif (tmo < next)\r\nnext = tmo;\r\n}\r\nif (xp->lft.soft_add_expires_seconds) {\r\nlong tmo = xp->lft.soft_add_expires_seconds +\r\nxp->curlft.add_time - now;\r\nif (tmo <= 0) {\r\nwarn = 1;\r\ntmo = XFRM_KM_TIMEOUT;\r\n}\r\nif (tmo < next)\r\nnext = tmo;\r\n}\r\nif (xp->lft.soft_use_expires_seconds) {\r\nlong tmo = xp->lft.soft_use_expires_seconds +\r\n(xp->curlft.use_time ? : xp->curlft.add_time) - now;\r\nif (tmo <= 0) {\r\nwarn = 1;\r\ntmo = XFRM_KM_TIMEOUT;\r\n}\r\nif (tmo < next)\r\nnext = tmo;\r\n}\r\nif (warn)\r\nkm_policy_expired(xp, dir, 0, 0);\r\nif (next != LONG_MAX &&\r\n!mod_timer(&xp->timer, jiffies + make_jiffies(next)))\r\nxfrm_pol_hold(xp);\r\nout:\r\nread_unlock(&xp->lock);\r\nxfrm_pol_put(xp);\r\nreturn;\r\nexpired:\r\nread_unlock(&xp->lock);\r\nif (!xfrm_policy_delete(xp, dir))\r\nkm_policy_expired(xp, dir, 1, 0);\r\nxfrm_pol_put(xp);\r\n}\r\nstatic struct flow_cache_object *xfrm_policy_flo_get(struct flow_cache_object *flo)\r\n{\r\nstruct xfrm_policy *pol = container_of(flo, struct xfrm_policy, flo);\r\nif (unlikely(pol->walk.dead))\r\nflo = NULL;\r\nelse\r\nxfrm_pol_hold(pol);\r\nreturn flo;\r\n}\r\nstatic int xfrm_policy_flo_check(struct flow_cache_object *flo)\r\n{\r\nstruct xfrm_policy *pol = container_of(flo, struct xfrm_policy, flo);\r\nreturn !pol->walk.dead;\r\n}\r\nstatic void xfrm_policy_flo_delete(struct flow_cache_object *flo)\r\n{\r\nxfrm_pol_put(container_of(flo, struct xfrm_policy, flo));\r\n}\r\nstruct xfrm_policy *xfrm_policy_alloc(struct net *net, gfp_t gfp)\r\n{\r\nstruct xfrm_policy *policy;\r\npolicy = kzalloc(sizeof(struct xfrm_policy), gfp);\r\nif (policy) {\r\nwrite_pnet(&policy->xp_net, net);\r\nINIT_LIST_HEAD(&policy->walk.all);\r\nINIT_HLIST_NODE(&policy->bydst);\r\nINIT_HLIST_NODE(&policy->byidx);\r\nrwlock_init(&policy->lock);\r\natomic_set(&policy->refcnt, 1);\r\nskb_queue_head_init(&policy->polq.hold_queue);\r\nsetup_timer(&policy->timer, xfrm_policy_timer,\r\n(unsigned long)policy);\r\nsetup_timer(&policy->polq.hold_timer, xfrm_policy_queue_process,\r\n(unsigned long)policy);\r\npolicy->flo.ops = &xfrm_policy_fc_ops;\r\n}\r\nreturn policy;\r\n}\r\nvoid xfrm_policy_destroy(struct xfrm_policy *policy)\r\n{\r\nBUG_ON(!policy->walk.dead);\r\nif (del_timer(&policy->timer) || del_timer(&policy->polq.hold_timer))\r\nBUG();\r\nsecurity_xfrm_policy_free(policy->security);\r\nkfree(policy);\r\n}\r\nstatic void xfrm_queue_purge(struct sk_buff_head *list)\r\n{\r\nstruct sk_buff *skb;\r\nwhile ((skb = skb_dequeue(list)) != NULL)\r\nkfree_skb(skb);\r\n}\r\nstatic void xfrm_policy_kill(struct xfrm_policy *policy)\r\n{\r\npolicy->walk.dead = 1;\r\natomic_inc(&policy->genid);\r\nif (del_timer(&policy->polq.hold_timer))\r\nxfrm_pol_put(policy);\r\nxfrm_queue_purge(&policy->polq.hold_queue);\r\nif (del_timer(&policy->timer))\r\nxfrm_pol_put(policy);\r\nxfrm_pol_put(policy);\r\n}\r\nstatic inline unsigned int idx_hash(struct net *net, u32 index)\r\n{\r\nreturn __idx_hash(index, net->xfrm.policy_idx_hmask);\r\n}\r\nstatic void __get_hash_thresh(struct net *net,\r\nunsigned short family, int dir,\r\nu8 *dbits, u8 *sbits)\r\n{\r\nswitch (family) {\r\ncase AF_INET:\r\n*dbits = net->xfrm.policy_bydst[dir].dbits4;\r\n*sbits = net->xfrm.policy_bydst[dir].sbits4;\r\nbreak;\r\ncase AF_INET6:\r\n*dbits = net->xfrm.policy_bydst[dir].dbits6;\r\n*sbits = net->xfrm.policy_bydst[dir].sbits6;\r\nbreak;\r\ndefault:\r\n*dbits = 0;\r\n*sbits = 0;\r\n}\r\n}\r\nstatic struct hlist_head *policy_hash_bysel(struct net *net,\r\nconst struct xfrm_selector *sel,\r\nunsigned short family, int dir)\r\n{\r\nunsigned int hmask = net->xfrm.policy_bydst[dir].hmask;\r\nunsigned int hash;\r\nu8 dbits;\r\nu8 sbits;\r\n__get_hash_thresh(net, family, dir, &dbits, &sbits);\r\nhash = __sel_hash(sel, family, hmask, dbits, sbits);\r\nreturn (hash == hmask + 1 ?\r\n&net->xfrm.policy_inexact[dir] :\r\nnet->xfrm.policy_bydst[dir].table + hash);\r\n}\r\nstatic struct hlist_head *policy_hash_direct(struct net *net,\r\nconst xfrm_address_t *daddr,\r\nconst xfrm_address_t *saddr,\r\nunsigned short family, int dir)\r\n{\r\nunsigned int hmask = net->xfrm.policy_bydst[dir].hmask;\r\nunsigned int hash;\r\nu8 dbits;\r\nu8 sbits;\r\n__get_hash_thresh(net, family, dir, &dbits, &sbits);\r\nhash = __addr_hash(daddr, saddr, family, hmask, dbits, sbits);\r\nreturn net->xfrm.policy_bydst[dir].table + hash;\r\n}\r\nstatic void xfrm_dst_hash_transfer(struct net *net,\r\nstruct hlist_head *list,\r\nstruct hlist_head *ndsttable,\r\nunsigned int nhashmask,\r\nint dir)\r\n{\r\nstruct hlist_node *tmp, *entry0 = NULL;\r\nstruct xfrm_policy *pol;\r\nunsigned int h0 = 0;\r\nu8 dbits;\r\nu8 sbits;\r\nredo:\r\nhlist_for_each_entry_safe(pol, tmp, list, bydst) {\r\nunsigned int h;\r\n__get_hash_thresh(net, pol->family, dir, &dbits, &sbits);\r\nh = __addr_hash(&pol->selector.daddr, &pol->selector.saddr,\r\npol->family, nhashmask, dbits, sbits);\r\nif (!entry0) {\r\nhlist_del(&pol->bydst);\r\nhlist_add_head(&pol->bydst, ndsttable+h);\r\nh0 = h;\r\n} else {\r\nif (h != h0)\r\ncontinue;\r\nhlist_del(&pol->bydst);\r\nhlist_add_behind(&pol->bydst, entry0);\r\n}\r\nentry0 = &pol->bydst;\r\n}\r\nif (!hlist_empty(list)) {\r\nentry0 = NULL;\r\ngoto redo;\r\n}\r\n}\r\nstatic void xfrm_idx_hash_transfer(struct hlist_head *list,\r\nstruct hlist_head *nidxtable,\r\nunsigned int nhashmask)\r\n{\r\nstruct hlist_node *tmp;\r\nstruct xfrm_policy *pol;\r\nhlist_for_each_entry_safe(pol, tmp, list, byidx) {\r\nunsigned int h;\r\nh = __idx_hash(pol->index, nhashmask);\r\nhlist_add_head(&pol->byidx, nidxtable+h);\r\n}\r\n}\r\nstatic unsigned long xfrm_new_hash_mask(unsigned int old_hmask)\r\n{\r\nreturn ((old_hmask + 1) << 1) - 1;\r\n}\r\nstatic void xfrm_bydst_resize(struct net *net, int dir)\r\n{\r\nunsigned int hmask = net->xfrm.policy_bydst[dir].hmask;\r\nunsigned int nhashmask = xfrm_new_hash_mask(hmask);\r\nunsigned int nsize = (nhashmask + 1) * sizeof(struct hlist_head);\r\nstruct hlist_head *odst = net->xfrm.policy_bydst[dir].table;\r\nstruct hlist_head *ndst = xfrm_hash_alloc(nsize);\r\nint i;\r\nif (!ndst)\r\nreturn;\r\nwrite_lock_bh(&net->xfrm.xfrm_policy_lock);\r\nfor (i = hmask; i >= 0; i--)\r\nxfrm_dst_hash_transfer(net, odst + i, ndst, nhashmask, dir);\r\nnet->xfrm.policy_bydst[dir].table = ndst;\r\nnet->xfrm.policy_bydst[dir].hmask = nhashmask;\r\nwrite_unlock_bh(&net->xfrm.xfrm_policy_lock);\r\nxfrm_hash_free(odst, (hmask + 1) * sizeof(struct hlist_head));\r\n}\r\nstatic void xfrm_byidx_resize(struct net *net, int total)\r\n{\r\nunsigned int hmask = net->xfrm.policy_idx_hmask;\r\nunsigned int nhashmask = xfrm_new_hash_mask(hmask);\r\nunsigned int nsize = (nhashmask + 1) * sizeof(struct hlist_head);\r\nstruct hlist_head *oidx = net->xfrm.policy_byidx;\r\nstruct hlist_head *nidx = xfrm_hash_alloc(nsize);\r\nint i;\r\nif (!nidx)\r\nreturn;\r\nwrite_lock_bh(&net->xfrm.xfrm_policy_lock);\r\nfor (i = hmask; i >= 0; i--)\r\nxfrm_idx_hash_transfer(oidx + i, nidx, nhashmask);\r\nnet->xfrm.policy_byidx = nidx;\r\nnet->xfrm.policy_idx_hmask = nhashmask;\r\nwrite_unlock_bh(&net->xfrm.xfrm_policy_lock);\r\nxfrm_hash_free(oidx, (hmask + 1) * sizeof(struct hlist_head));\r\n}\r\nstatic inline int xfrm_bydst_should_resize(struct net *net, int dir, int *total)\r\n{\r\nunsigned int cnt = net->xfrm.policy_count[dir];\r\nunsigned int hmask = net->xfrm.policy_bydst[dir].hmask;\r\nif (total)\r\n*total += cnt;\r\nif ((hmask + 1) < xfrm_policy_hashmax &&\r\ncnt > hmask)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic inline int xfrm_byidx_should_resize(struct net *net, int total)\r\n{\r\nunsigned int hmask = net->xfrm.policy_idx_hmask;\r\nif ((hmask + 1) < xfrm_policy_hashmax &&\r\ntotal > hmask)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nvoid xfrm_spd_getinfo(struct net *net, struct xfrmk_spdinfo *si)\r\n{\r\nread_lock_bh(&net->xfrm.xfrm_policy_lock);\r\nsi->incnt = net->xfrm.policy_count[XFRM_POLICY_IN];\r\nsi->outcnt = net->xfrm.policy_count[XFRM_POLICY_OUT];\r\nsi->fwdcnt = net->xfrm.policy_count[XFRM_POLICY_FWD];\r\nsi->inscnt = net->xfrm.policy_count[XFRM_POLICY_IN+XFRM_POLICY_MAX];\r\nsi->outscnt = net->xfrm.policy_count[XFRM_POLICY_OUT+XFRM_POLICY_MAX];\r\nsi->fwdscnt = net->xfrm.policy_count[XFRM_POLICY_FWD+XFRM_POLICY_MAX];\r\nsi->spdhcnt = net->xfrm.policy_idx_hmask;\r\nsi->spdhmcnt = xfrm_policy_hashmax;\r\nread_unlock_bh(&net->xfrm.xfrm_policy_lock);\r\n}\r\nstatic void xfrm_hash_resize(struct work_struct *work)\r\n{\r\nstruct net *net = container_of(work, struct net, xfrm.policy_hash_work);\r\nint dir, total;\r\nmutex_lock(&hash_resize_mutex);\r\ntotal = 0;\r\nfor (dir = 0; dir < XFRM_POLICY_MAX; dir++) {\r\nif (xfrm_bydst_should_resize(net, dir, &total))\r\nxfrm_bydst_resize(net, dir);\r\n}\r\nif (xfrm_byidx_should_resize(net, total))\r\nxfrm_byidx_resize(net, total);\r\nmutex_unlock(&hash_resize_mutex);\r\n}\r\nstatic void xfrm_hash_rebuild(struct work_struct *work)\r\n{\r\nstruct net *net = container_of(work, struct net,\r\nxfrm.policy_hthresh.work);\r\nunsigned int hmask;\r\nstruct xfrm_policy *pol;\r\nstruct xfrm_policy *policy;\r\nstruct hlist_head *chain;\r\nstruct hlist_head *odst;\r\nstruct hlist_node *newpos;\r\nint i;\r\nint dir;\r\nunsigned seq;\r\nu8 lbits4, rbits4, lbits6, rbits6;\r\nmutex_lock(&hash_resize_mutex);\r\ndo {\r\nseq = read_seqbegin(&net->xfrm.policy_hthresh.lock);\r\nlbits4 = net->xfrm.policy_hthresh.lbits4;\r\nrbits4 = net->xfrm.policy_hthresh.rbits4;\r\nlbits6 = net->xfrm.policy_hthresh.lbits6;\r\nrbits6 = net->xfrm.policy_hthresh.rbits6;\r\n} while (read_seqretry(&net->xfrm.policy_hthresh.lock, seq));\r\nwrite_lock_bh(&net->xfrm.xfrm_policy_lock);\r\nfor (dir = 0; dir < XFRM_POLICY_MAX; dir++) {\r\nINIT_HLIST_HEAD(&net->xfrm.policy_inexact[dir]);\r\nhmask = net->xfrm.policy_bydst[dir].hmask;\r\nodst = net->xfrm.policy_bydst[dir].table;\r\nfor (i = hmask; i >= 0; i--)\r\nINIT_HLIST_HEAD(odst + i);\r\nif ((dir & XFRM_POLICY_MASK) == XFRM_POLICY_OUT) {\r\nnet->xfrm.policy_bydst[dir].dbits4 = rbits4;\r\nnet->xfrm.policy_bydst[dir].sbits4 = lbits4;\r\nnet->xfrm.policy_bydst[dir].dbits6 = rbits6;\r\nnet->xfrm.policy_bydst[dir].sbits6 = lbits6;\r\n} else {\r\nnet->xfrm.policy_bydst[dir].dbits4 = lbits4;\r\nnet->xfrm.policy_bydst[dir].sbits4 = rbits4;\r\nnet->xfrm.policy_bydst[dir].dbits6 = lbits6;\r\nnet->xfrm.policy_bydst[dir].sbits6 = rbits6;\r\n}\r\n}\r\nlist_for_each_entry_reverse(policy, &net->xfrm.policy_all, walk.all) {\r\nnewpos = NULL;\r\nchain = policy_hash_bysel(net, &policy->selector,\r\npolicy->family,\r\nxfrm_policy_id2dir(policy->index));\r\nhlist_for_each_entry(pol, chain, bydst) {\r\nif (policy->priority >= pol->priority)\r\nnewpos = &pol->bydst;\r\nelse\r\nbreak;\r\n}\r\nif (newpos)\r\nhlist_add_behind(&policy->bydst, newpos);\r\nelse\r\nhlist_add_head(&policy->bydst, chain);\r\n}\r\nwrite_unlock_bh(&net->xfrm.xfrm_policy_lock);\r\nmutex_unlock(&hash_resize_mutex);\r\n}\r\nvoid xfrm_policy_hash_rebuild(struct net *net)\r\n{\r\nschedule_work(&net->xfrm.policy_hthresh.work);\r\n}\r\nstatic u32 xfrm_gen_index(struct net *net, int dir, u32 index)\r\n{\r\nstatic u32 idx_generator;\r\nfor (;;) {\r\nstruct hlist_head *list;\r\nstruct xfrm_policy *p;\r\nu32 idx;\r\nint found;\r\nif (!index) {\r\nidx = (idx_generator | dir);\r\nidx_generator += 8;\r\n} else {\r\nidx = index;\r\nindex = 0;\r\n}\r\nif (idx == 0)\r\nidx = 8;\r\nlist = net->xfrm.policy_byidx + idx_hash(net, idx);\r\nfound = 0;\r\nhlist_for_each_entry(p, list, byidx) {\r\nif (p->index == idx) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (!found)\r\nreturn idx;\r\n}\r\n}\r\nstatic inline int selector_cmp(struct xfrm_selector *s1, struct xfrm_selector *s2)\r\n{\r\nu32 *p1 = (u32 *) s1;\r\nu32 *p2 = (u32 *) s2;\r\nint len = sizeof(struct xfrm_selector) / sizeof(u32);\r\nint i;\r\nfor (i = 0; i < len; i++) {\r\nif (p1[i] != p2[i])\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void xfrm_policy_requeue(struct xfrm_policy *old,\r\nstruct xfrm_policy *new)\r\n{\r\nstruct xfrm_policy_queue *pq = &old->polq;\r\nstruct sk_buff_head list;\r\n__skb_queue_head_init(&list);\r\nspin_lock_bh(&pq->hold_queue.lock);\r\nskb_queue_splice_init(&pq->hold_queue, &list);\r\nif (del_timer(&pq->hold_timer))\r\nxfrm_pol_put(old);\r\nspin_unlock_bh(&pq->hold_queue.lock);\r\nif (skb_queue_empty(&list))\r\nreturn;\r\npq = &new->polq;\r\nspin_lock_bh(&pq->hold_queue.lock);\r\nskb_queue_splice(&list, &pq->hold_queue);\r\npq->timeout = XFRM_QUEUE_TMO_MIN;\r\nif (!mod_timer(&pq->hold_timer, jiffies))\r\nxfrm_pol_hold(new);\r\nspin_unlock_bh(&pq->hold_queue.lock);\r\n}\r\nstatic bool xfrm_policy_mark_match(struct xfrm_policy *policy,\r\nstruct xfrm_policy *pol)\r\n{\r\nu32 mark = policy->mark.v & policy->mark.m;\r\nif (policy->mark.v == pol->mark.v && policy->mark.m == pol->mark.m)\r\nreturn true;\r\nif ((mark & pol->mark.m) == pol->mark.v &&\r\npolicy->priority == pol->priority)\r\nreturn true;\r\nreturn false;\r\n}\r\nint xfrm_policy_insert(int dir, struct xfrm_policy *policy, int excl)\r\n{\r\nstruct net *net = xp_net(policy);\r\nstruct xfrm_policy *pol;\r\nstruct xfrm_policy *delpol;\r\nstruct hlist_head *chain;\r\nstruct hlist_node *newpos;\r\nwrite_lock_bh(&net->xfrm.xfrm_policy_lock);\r\nchain = policy_hash_bysel(net, &policy->selector, policy->family, dir);\r\ndelpol = NULL;\r\nnewpos = NULL;\r\nhlist_for_each_entry(pol, chain, bydst) {\r\nif (pol->type == policy->type &&\r\n!selector_cmp(&pol->selector, &policy->selector) &&\r\nxfrm_policy_mark_match(policy, pol) &&\r\nxfrm_sec_ctx_match(pol->security, policy->security) &&\r\n!WARN_ON(delpol)) {\r\nif (excl) {\r\nwrite_unlock_bh(&net->xfrm.xfrm_policy_lock);\r\nreturn -EEXIST;\r\n}\r\ndelpol = pol;\r\nif (policy->priority > pol->priority)\r\ncontinue;\r\n} else if (policy->priority >= pol->priority) {\r\nnewpos = &pol->bydst;\r\ncontinue;\r\n}\r\nif (delpol)\r\nbreak;\r\n}\r\nif (newpos)\r\nhlist_add_behind(&policy->bydst, newpos);\r\nelse\r\nhlist_add_head(&policy->bydst, chain);\r\n__xfrm_policy_link(policy, dir);\r\natomic_inc(&net->xfrm.flow_cache_genid);\r\nif (policy->family == AF_INET)\r\nrt_genid_bump_ipv4(net);\r\nelse\r\nrt_genid_bump_ipv6(net);\r\nif (delpol) {\r\nxfrm_policy_requeue(delpol, policy);\r\n__xfrm_policy_unlink(delpol, dir);\r\n}\r\npolicy->index = delpol ? delpol->index : xfrm_gen_index(net, dir, policy->index);\r\nhlist_add_head(&policy->byidx, net->xfrm.policy_byidx+idx_hash(net, policy->index));\r\npolicy->curlft.add_time = get_seconds();\r\npolicy->curlft.use_time = 0;\r\nif (!mod_timer(&policy->timer, jiffies + HZ))\r\nxfrm_pol_hold(policy);\r\nwrite_unlock_bh(&net->xfrm.xfrm_policy_lock);\r\nif (delpol)\r\nxfrm_policy_kill(delpol);\r\nelse if (xfrm_bydst_should_resize(net, dir, NULL))\r\nschedule_work(&net->xfrm.policy_hash_work);\r\nreturn 0;\r\n}\r\nstruct xfrm_policy *xfrm_policy_bysel_ctx(struct net *net, u32 mark, u8 type,\r\nint dir, struct xfrm_selector *sel,\r\nstruct xfrm_sec_ctx *ctx, int delete,\r\nint *err)\r\n{\r\nstruct xfrm_policy *pol, *ret;\r\nstruct hlist_head *chain;\r\n*err = 0;\r\nwrite_lock_bh(&net->xfrm.xfrm_policy_lock);\r\nchain = policy_hash_bysel(net, sel, sel->family, dir);\r\nret = NULL;\r\nhlist_for_each_entry(pol, chain, bydst) {\r\nif (pol->type == type &&\r\n(mark & pol->mark.m) == pol->mark.v &&\r\n!selector_cmp(sel, &pol->selector) &&\r\nxfrm_sec_ctx_match(ctx, pol->security)) {\r\nxfrm_pol_hold(pol);\r\nif (delete) {\r\n*err = security_xfrm_policy_delete(\r\npol->security);\r\nif (*err) {\r\nwrite_unlock_bh(&net->xfrm.xfrm_policy_lock);\r\nreturn pol;\r\n}\r\n__xfrm_policy_unlink(pol, dir);\r\n}\r\nret = pol;\r\nbreak;\r\n}\r\n}\r\nwrite_unlock_bh(&net->xfrm.xfrm_policy_lock);\r\nif (ret && delete)\r\nxfrm_policy_kill(ret);\r\nreturn ret;\r\n}\r\nstruct xfrm_policy *xfrm_policy_byid(struct net *net, u32 mark, u8 type,\r\nint dir, u32 id, int delete, int *err)\r\n{\r\nstruct xfrm_policy *pol, *ret;\r\nstruct hlist_head *chain;\r\n*err = -ENOENT;\r\nif (xfrm_policy_id2dir(id) != dir)\r\nreturn NULL;\r\n*err = 0;\r\nwrite_lock_bh(&net->xfrm.xfrm_policy_lock);\r\nchain = net->xfrm.policy_byidx + idx_hash(net, id);\r\nret = NULL;\r\nhlist_for_each_entry(pol, chain, byidx) {\r\nif (pol->type == type && pol->index == id &&\r\n(mark & pol->mark.m) == pol->mark.v) {\r\nxfrm_pol_hold(pol);\r\nif (delete) {\r\n*err = security_xfrm_policy_delete(\r\npol->security);\r\nif (*err) {\r\nwrite_unlock_bh(&net->xfrm.xfrm_policy_lock);\r\nreturn pol;\r\n}\r\n__xfrm_policy_unlink(pol, dir);\r\n}\r\nret = pol;\r\nbreak;\r\n}\r\n}\r\nwrite_unlock_bh(&net->xfrm.xfrm_policy_lock);\r\nif (ret && delete)\r\nxfrm_policy_kill(ret);\r\nreturn ret;\r\n}\r\nstatic inline int\r\nxfrm_policy_flush_secctx_check(struct net *net, u8 type, bool task_valid)\r\n{\r\nint dir, err = 0;\r\nfor (dir = 0; dir < XFRM_POLICY_MAX; dir++) {\r\nstruct xfrm_policy *pol;\r\nint i;\r\nhlist_for_each_entry(pol,\r\n&net->xfrm.policy_inexact[dir], bydst) {\r\nif (pol->type != type)\r\ncontinue;\r\nerr = security_xfrm_policy_delete(pol->security);\r\nif (err) {\r\nxfrm_audit_policy_delete(pol, 0, task_valid);\r\nreturn err;\r\n}\r\n}\r\nfor (i = net->xfrm.policy_bydst[dir].hmask; i >= 0; i--) {\r\nhlist_for_each_entry(pol,\r\nnet->xfrm.policy_bydst[dir].table + i,\r\nbydst) {\r\nif (pol->type != type)\r\ncontinue;\r\nerr = security_xfrm_policy_delete(\r\npol->security);\r\nif (err) {\r\nxfrm_audit_policy_delete(pol, 0,\r\ntask_valid);\r\nreturn err;\r\n}\r\n}\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic inline int\r\nxfrm_policy_flush_secctx_check(struct net *net, u8 type, bool task_valid)\r\n{\r\nreturn 0;\r\n}\r\nint xfrm_policy_flush(struct net *net, u8 type, bool task_valid)\r\n{\r\nint dir, err = 0, cnt = 0;\r\nwrite_lock_bh(&net->xfrm.xfrm_policy_lock);\r\nerr = xfrm_policy_flush_secctx_check(net, type, task_valid);\r\nif (err)\r\ngoto out;\r\nfor (dir = 0; dir < XFRM_POLICY_MAX; dir++) {\r\nstruct xfrm_policy *pol;\r\nint i;\r\nagain1:\r\nhlist_for_each_entry(pol,\r\n&net->xfrm.policy_inexact[dir], bydst) {\r\nif (pol->type != type)\r\ncontinue;\r\n__xfrm_policy_unlink(pol, dir);\r\nwrite_unlock_bh(&net->xfrm.xfrm_policy_lock);\r\ncnt++;\r\nxfrm_audit_policy_delete(pol, 1, task_valid);\r\nxfrm_policy_kill(pol);\r\nwrite_lock_bh(&net->xfrm.xfrm_policy_lock);\r\ngoto again1;\r\n}\r\nfor (i = net->xfrm.policy_bydst[dir].hmask; i >= 0; i--) {\r\nagain2:\r\nhlist_for_each_entry(pol,\r\nnet->xfrm.policy_bydst[dir].table + i,\r\nbydst) {\r\nif (pol->type != type)\r\ncontinue;\r\n__xfrm_policy_unlink(pol, dir);\r\nwrite_unlock_bh(&net->xfrm.xfrm_policy_lock);\r\ncnt++;\r\nxfrm_audit_policy_delete(pol, 1, task_valid);\r\nxfrm_policy_kill(pol);\r\nwrite_lock_bh(&net->xfrm.xfrm_policy_lock);\r\ngoto again2;\r\n}\r\n}\r\n}\r\nif (!cnt)\r\nerr = -ESRCH;\r\nout:\r\nwrite_unlock_bh(&net->xfrm.xfrm_policy_lock);\r\nreturn err;\r\n}\r\nint xfrm_policy_walk(struct net *net, struct xfrm_policy_walk *walk,\r\nint (*func)(struct xfrm_policy *, int, int, void*),\r\nvoid *data)\r\n{\r\nstruct xfrm_policy *pol;\r\nstruct xfrm_policy_walk_entry *x;\r\nint error = 0;\r\nif (walk->type >= XFRM_POLICY_TYPE_MAX &&\r\nwalk->type != XFRM_POLICY_TYPE_ANY)\r\nreturn -EINVAL;\r\nif (list_empty(&walk->walk.all) && walk->seq != 0)\r\nreturn 0;\r\nwrite_lock_bh(&net->xfrm.xfrm_policy_lock);\r\nif (list_empty(&walk->walk.all))\r\nx = list_first_entry(&net->xfrm.policy_all, struct xfrm_policy_walk_entry, all);\r\nelse\r\nx = list_entry(&walk->walk.all, struct xfrm_policy_walk_entry, all);\r\nlist_for_each_entry_from(x, &net->xfrm.policy_all, all) {\r\nif (x->dead)\r\ncontinue;\r\npol = container_of(x, struct xfrm_policy, walk);\r\nif (walk->type != XFRM_POLICY_TYPE_ANY &&\r\nwalk->type != pol->type)\r\ncontinue;\r\nerror = func(pol, xfrm_policy_id2dir(pol->index),\r\nwalk->seq, data);\r\nif (error) {\r\nlist_move_tail(&walk->walk.all, &x->all);\r\ngoto out;\r\n}\r\nwalk->seq++;\r\n}\r\nif (walk->seq == 0) {\r\nerror = -ENOENT;\r\ngoto out;\r\n}\r\nlist_del_init(&walk->walk.all);\r\nout:\r\nwrite_unlock_bh(&net->xfrm.xfrm_policy_lock);\r\nreturn error;\r\n}\r\nvoid xfrm_policy_walk_init(struct xfrm_policy_walk *walk, u8 type)\r\n{\r\nINIT_LIST_HEAD(&walk->walk.all);\r\nwalk->walk.dead = 1;\r\nwalk->type = type;\r\nwalk->seq = 0;\r\n}\r\nvoid xfrm_policy_walk_done(struct xfrm_policy_walk *walk, struct net *net)\r\n{\r\nif (list_empty(&walk->walk.all))\r\nreturn;\r\nwrite_lock_bh(&net->xfrm.xfrm_policy_lock);\r\nlist_del(&walk->walk.all);\r\nwrite_unlock_bh(&net->xfrm.xfrm_policy_lock);\r\n}\r\nstatic int xfrm_policy_match(const struct xfrm_policy *pol,\r\nconst struct flowi *fl,\r\nu8 type, u16 family, int dir)\r\n{\r\nconst struct xfrm_selector *sel = &pol->selector;\r\nint ret = -ESRCH;\r\nbool match;\r\nif (pol->family != family ||\r\n(fl->flowi_mark & pol->mark.m) != pol->mark.v ||\r\npol->type != type)\r\nreturn ret;\r\nmatch = xfrm_selector_match(sel, fl, family);\r\nif (match)\r\nret = security_xfrm_policy_lookup(pol->security, fl->flowi_secid,\r\ndir);\r\nreturn ret;\r\n}\r\nstatic struct xfrm_policy *xfrm_policy_lookup_bytype(struct net *net, u8 type,\r\nconst struct flowi *fl,\r\nu16 family, u8 dir)\r\n{\r\nint err;\r\nstruct xfrm_policy *pol, *ret;\r\nconst xfrm_address_t *daddr, *saddr;\r\nstruct hlist_head *chain;\r\nu32 priority = ~0U;\r\ndaddr = xfrm_flowi_daddr(fl, family);\r\nsaddr = xfrm_flowi_saddr(fl, family);\r\nif (unlikely(!daddr || !saddr))\r\nreturn NULL;\r\nread_lock_bh(&net->xfrm.xfrm_policy_lock);\r\nchain = policy_hash_direct(net, daddr, saddr, family, dir);\r\nret = NULL;\r\nhlist_for_each_entry(pol, chain, bydst) {\r\nerr = xfrm_policy_match(pol, fl, type, family, dir);\r\nif (err) {\r\nif (err == -ESRCH)\r\ncontinue;\r\nelse {\r\nret = ERR_PTR(err);\r\ngoto fail;\r\n}\r\n} else {\r\nret = pol;\r\npriority = ret->priority;\r\nbreak;\r\n}\r\n}\r\nchain = &net->xfrm.policy_inexact[dir];\r\nhlist_for_each_entry(pol, chain, bydst) {\r\nerr = xfrm_policy_match(pol, fl, type, family, dir);\r\nif (err) {\r\nif (err == -ESRCH)\r\ncontinue;\r\nelse {\r\nret = ERR_PTR(err);\r\ngoto fail;\r\n}\r\n} else if (pol->priority < priority) {\r\nret = pol;\r\nbreak;\r\n}\r\n}\r\nif (ret)\r\nxfrm_pol_hold(ret);\r\nfail:\r\nread_unlock_bh(&net->xfrm.xfrm_policy_lock);\r\nreturn ret;\r\n}\r\nstatic struct xfrm_policy *\r\n__xfrm_policy_lookup(struct net *net, const struct flowi *fl, u16 family, u8 dir)\r\n{\r\n#ifdef CONFIG_XFRM_SUB_POLICY\r\nstruct xfrm_policy *pol;\r\npol = xfrm_policy_lookup_bytype(net, XFRM_POLICY_TYPE_SUB, fl, family, dir);\r\nif (pol != NULL)\r\nreturn pol;\r\n#endif\r\nreturn xfrm_policy_lookup_bytype(net, XFRM_POLICY_TYPE_MAIN, fl, family, dir);\r\n}\r\nstatic int flow_to_policy_dir(int dir)\r\n{\r\nif (XFRM_POLICY_IN == FLOW_DIR_IN &&\r\nXFRM_POLICY_OUT == FLOW_DIR_OUT &&\r\nXFRM_POLICY_FWD == FLOW_DIR_FWD)\r\nreturn dir;\r\nswitch (dir) {\r\ndefault:\r\ncase FLOW_DIR_IN:\r\nreturn XFRM_POLICY_IN;\r\ncase FLOW_DIR_OUT:\r\nreturn XFRM_POLICY_OUT;\r\ncase FLOW_DIR_FWD:\r\nreturn XFRM_POLICY_FWD;\r\n}\r\n}\r\nstatic struct flow_cache_object *\r\nxfrm_policy_lookup(struct net *net, const struct flowi *fl, u16 family,\r\nu8 dir, struct flow_cache_object *old_obj, void *ctx)\r\n{\r\nstruct xfrm_policy *pol;\r\nif (old_obj)\r\nxfrm_pol_put(container_of(old_obj, struct xfrm_policy, flo));\r\npol = __xfrm_policy_lookup(net, fl, family, flow_to_policy_dir(dir));\r\nif (IS_ERR_OR_NULL(pol))\r\nreturn ERR_CAST(pol);\r\nxfrm_pol_hold(pol);\r\nreturn &pol->flo;\r\n}\r\nstatic inline int policy_to_flow_dir(int dir)\r\n{\r\nif (XFRM_POLICY_IN == FLOW_DIR_IN &&\r\nXFRM_POLICY_OUT == FLOW_DIR_OUT &&\r\nXFRM_POLICY_FWD == FLOW_DIR_FWD)\r\nreturn dir;\r\nswitch (dir) {\r\ndefault:\r\ncase XFRM_POLICY_IN:\r\nreturn FLOW_DIR_IN;\r\ncase XFRM_POLICY_OUT:\r\nreturn FLOW_DIR_OUT;\r\ncase XFRM_POLICY_FWD:\r\nreturn FLOW_DIR_FWD;\r\n}\r\n}\r\nstatic struct xfrm_policy *xfrm_sk_policy_lookup(struct sock *sk, int dir,\r\nconst struct flowi *fl)\r\n{\r\nstruct xfrm_policy *pol;\r\nstruct net *net = sock_net(sk);\r\nread_lock_bh(&net->xfrm.xfrm_policy_lock);\r\nif ((pol = sk->sk_policy[dir]) != NULL) {\r\nbool match = xfrm_selector_match(&pol->selector, fl,\r\nsk->sk_family);\r\nint err = 0;\r\nif (match) {\r\nif ((sk->sk_mark & pol->mark.m) != pol->mark.v) {\r\npol = NULL;\r\ngoto out;\r\n}\r\nerr = security_xfrm_policy_lookup(pol->security,\r\nfl->flowi_secid,\r\npolicy_to_flow_dir(dir));\r\nif (!err)\r\nxfrm_pol_hold(pol);\r\nelse if (err == -ESRCH)\r\npol = NULL;\r\nelse\r\npol = ERR_PTR(err);\r\n} else\r\npol = NULL;\r\n}\r\nout:\r\nread_unlock_bh(&net->xfrm.xfrm_policy_lock);\r\nreturn pol;\r\n}\r\nstatic void __xfrm_policy_link(struct xfrm_policy *pol, int dir)\r\n{\r\nstruct net *net = xp_net(pol);\r\nlist_add(&pol->walk.all, &net->xfrm.policy_all);\r\nnet->xfrm.policy_count[dir]++;\r\nxfrm_pol_hold(pol);\r\n}\r\nstatic struct xfrm_policy *__xfrm_policy_unlink(struct xfrm_policy *pol,\r\nint dir)\r\n{\r\nstruct net *net = xp_net(pol);\r\nif (list_empty(&pol->walk.all))\r\nreturn NULL;\r\nif (!hlist_unhashed(&pol->bydst)) {\r\nhlist_del(&pol->bydst);\r\nhlist_del(&pol->byidx);\r\n}\r\nlist_del_init(&pol->walk.all);\r\nnet->xfrm.policy_count[dir]--;\r\nreturn pol;\r\n}\r\nstatic void xfrm_sk_policy_link(struct xfrm_policy *pol, int dir)\r\n{\r\n__xfrm_policy_link(pol, XFRM_POLICY_MAX + dir);\r\n}\r\nstatic void xfrm_sk_policy_unlink(struct xfrm_policy *pol, int dir)\r\n{\r\n__xfrm_policy_unlink(pol, XFRM_POLICY_MAX + dir);\r\n}\r\nint xfrm_policy_delete(struct xfrm_policy *pol, int dir)\r\n{\r\nstruct net *net = xp_net(pol);\r\nwrite_lock_bh(&net->xfrm.xfrm_policy_lock);\r\npol = __xfrm_policy_unlink(pol, dir);\r\nwrite_unlock_bh(&net->xfrm.xfrm_policy_lock);\r\nif (pol) {\r\nxfrm_policy_kill(pol);\r\nreturn 0;\r\n}\r\nreturn -ENOENT;\r\n}\r\nint xfrm_sk_policy_insert(struct sock *sk, int dir, struct xfrm_policy *pol)\r\n{\r\nstruct net *net = xp_net(pol);\r\nstruct xfrm_policy *old_pol;\r\n#ifdef CONFIG_XFRM_SUB_POLICY\r\nif (pol && pol->type != XFRM_POLICY_TYPE_MAIN)\r\nreturn -EINVAL;\r\n#endif\r\nwrite_lock_bh(&net->xfrm.xfrm_policy_lock);\r\nold_pol = sk->sk_policy[dir];\r\nsk->sk_policy[dir] = pol;\r\nif (pol) {\r\npol->curlft.add_time = get_seconds();\r\npol->index = xfrm_gen_index(net, XFRM_POLICY_MAX+dir, 0);\r\nxfrm_sk_policy_link(pol, dir);\r\n}\r\nif (old_pol) {\r\nif (pol)\r\nxfrm_policy_requeue(old_pol, pol);\r\nxfrm_sk_policy_unlink(old_pol, dir);\r\n}\r\nwrite_unlock_bh(&net->xfrm.xfrm_policy_lock);\r\nif (old_pol) {\r\nxfrm_policy_kill(old_pol);\r\n}\r\nreturn 0;\r\n}\r\nstatic struct xfrm_policy *clone_policy(const struct xfrm_policy *old, int dir)\r\n{\r\nstruct xfrm_policy *newp = xfrm_policy_alloc(xp_net(old), GFP_ATOMIC);\r\nstruct net *net = xp_net(old);\r\nif (newp) {\r\nnewp->selector = old->selector;\r\nif (security_xfrm_policy_clone(old->security,\r\n&newp->security)) {\r\nkfree(newp);\r\nreturn NULL;\r\n}\r\nnewp->lft = old->lft;\r\nnewp->curlft = old->curlft;\r\nnewp->mark = old->mark;\r\nnewp->action = old->action;\r\nnewp->flags = old->flags;\r\nnewp->xfrm_nr = old->xfrm_nr;\r\nnewp->index = old->index;\r\nnewp->type = old->type;\r\nmemcpy(newp->xfrm_vec, old->xfrm_vec,\r\nnewp->xfrm_nr*sizeof(struct xfrm_tmpl));\r\nwrite_lock_bh(&net->xfrm.xfrm_policy_lock);\r\nxfrm_sk_policy_link(newp, dir);\r\nwrite_unlock_bh(&net->xfrm.xfrm_policy_lock);\r\nxfrm_pol_put(newp);\r\n}\r\nreturn newp;\r\n}\r\nint __xfrm_sk_clone_policy(struct sock *sk)\r\n{\r\nstruct xfrm_policy *p0 = sk->sk_policy[0],\r\n*p1 = sk->sk_policy[1];\r\nsk->sk_policy[0] = sk->sk_policy[1] = NULL;\r\nif (p0 && (sk->sk_policy[0] = clone_policy(p0, 0)) == NULL)\r\nreturn -ENOMEM;\r\nif (p1 && (sk->sk_policy[1] = clone_policy(p1, 1)) == NULL)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int\r\nxfrm_get_saddr(struct net *net, xfrm_address_t *local, xfrm_address_t *remote,\r\nunsigned short family)\r\n{\r\nint err;\r\nstruct xfrm_policy_afinfo *afinfo = xfrm_policy_get_afinfo(family);\r\nif (unlikely(afinfo == NULL))\r\nreturn -EINVAL;\r\nerr = afinfo->get_saddr(net, local, remote);\r\nxfrm_policy_put_afinfo(afinfo);\r\nreturn err;\r\n}\r\nstatic int\r\nxfrm_tmpl_resolve_one(struct xfrm_policy *policy, const struct flowi *fl,\r\nstruct xfrm_state **xfrm, unsigned short family)\r\n{\r\nstruct net *net = xp_net(policy);\r\nint nx;\r\nint i, error;\r\nxfrm_address_t *daddr = xfrm_flowi_daddr(fl, family);\r\nxfrm_address_t *saddr = xfrm_flowi_saddr(fl, family);\r\nxfrm_address_t tmp;\r\nfor (nx = 0, i = 0; i < policy->xfrm_nr; i++) {\r\nstruct xfrm_state *x;\r\nxfrm_address_t *remote = daddr;\r\nxfrm_address_t *local = saddr;\r\nstruct xfrm_tmpl *tmpl = &policy->xfrm_vec[i];\r\nif (tmpl->mode == XFRM_MODE_TUNNEL ||\r\ntmpl->mode == XFRM_MODE_BEET) {\r\nremote = &tmpl->id.daddr;\r\nlocal = &tmpl->saddr;\r\nif (xfrm_addr_any(local, tmpl->encap_family)) {\r\nerror = xfrm_get_saddr(net, &tmp, remote, tmpl->encap_family);\r\nif (error)\r\ngoto fail;\r\nlocal = &tmp;\r\n}\r\n}\r\nx = xfrm_state_find(remote, local, fl, tmpl, policy, &error, family);\r\nif (x && x->km.state == XFRM_STATE_VALID) {\r\nxfrm[nx++] = x;\r\ndaddr = remote;\r\nsaddr = local;\r\ncontinue;\r\n}\r\nif (x) {\r\nerror = (x->km.state == XFRM_STATE_ERROR ?\r\n-EINVAL : -EAGAIN);\r\nxfrm_state_put(x);\r\n} else if (error == -ESRCH) {\r\nerror = -EAGAIN;\r\n}\r\nif (!tmpl->optional)\r\ngoto fail;\r\n}\r\nreturn nx;\r\nfail:\r\nfor (nx--; nx >= 0; nx--)\r\nxfrm_state_put(xfrm[nx]);\r\nreturn error;\r\n}\r\nstatic int\r\nxfrm_tmpl_resolve(struct xfrm_policy **pols, int npols, const struct flowi *fl,\r\nstruct xfrm_state **xfrm, unsigned short family)\r\n{\r\nstruct xfrm_state *tp[XFRM_MAX_DEPTH];\r\nstruct xfrm_state **tpp = (npols > 1) ? tp : xfrm;\r\nint cnx = 0;\r\nint error;\r\nint ret;\r\nint i;\r\nfor (i = 0; i < npols; i++) {\r\nif (cnx + pols[i]->xfrm_nr >= XFRM_MAX_DEPTH) {\r\nerror = -ENOBUFS;\r\ngoto fail;\r\n}\r\nret = xfrm_tmpl_resolve_one(pols[i], fl, &tpp[cnx], family);\r\nif (ret < 0) {\r\nerror = ret;\r\ngoto fail;\r\n} else\r\ncnx += ret;\r\n}\r\nif (npols > 1)\r\nxfrm_state_sort(xfrm, tpp, cnx, family);\r\nreturn cnx;\r\nfail:\r\nfor (cnx--; cnx >= 0; cnx--)\r\nxfrm_state_put(tpp[cnx]);\r\nreturn error;\r\n}\r\nstatic inline int xfrm_get_tos(const struct flowi *fl, int family)\r\n{\r\nstruct xfrm_policy_afinfo *afinfo = xfrm_policy_get_afinfo(family);\r\nint tos;\r\nif (!afinfo)\r\nreturn -EINVAL;\r\ntos = afinfo->get_tos(fl);\r\nxfrm_policy_put_afinfo(afinfo);\r\nreturn tos;\r\n}\r\nstatic struct flow_cache_object *xfrm_bundle_flo_get(struct flow_cache_object *flo)\r\n{\r\nstruct xfrm_dst *xdst = container_of(flo, struct xfrm_dst, flo);\r\nstruct dst_entry *dst = &xdst->u.dst;\r\nif (xdst->route == NULL) {\r\nif (xdst->num_xfrms > 0)\r\nreturn NULL;\r\n} else if (dst->flags & DST_XFRM_QUEUE) {\r\nreturn NULL;\r\n} else {\r\nif (stale_bundle(dst))\r\nreturn NULL;\r\n}\r\ndst_hold(dst);\r\nreturn flo;\r\n}\r\nstatic int xfrm_bundle_flo_check(struct flow_cache_object *flo)\r\n{\r\nstruct xfrm_dst *xdst = container_of(flo, struct xfrm_dst, flo);\r\nstruct dst_entry *dst = &xdst->u.dst;\r\nif (!xdst->route)\r\nreturn 0;\r\nif (stale_bundle(dst))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void xfrm_bundle_flo_delete(struct flow_cache_object *flo)\r\n{\r\nstruct xfrm_dst *xdst = container_of(flo, struct xfrm_dst, flo);\r\nstruct dst_entry *dst = &xdst->u.dst;\r\ndst_free(dst);\r\n}\r\nstatic inline struct xfrm_dst *xfrm_alloc_dst(struct net *net, int family)\r\n{\r\nstruct xfrm_policy_afinfo *afinfo = xfrm_policy_get_afinfo(family);\r\nstruct dst_ops *dst_ops;\r\nstruct xfrm_dst *xdst;\r\nif (!afinfo)\r\nreturn ERR_PTR(-EINVAL);\r\nswitch (family) {\r\ncase AF_INET:\r\ndst_ops = &net->xfrm.xfrm4_dst_ops;\r\nbreak;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase AF_INET6:\r\ndst_ops = &net->xfrm.xfrm6_dst_ops;\r\nbreak;\r\n#endif\r\ndefault:\r\nBUG();\r\n}\r\nxdst = dst_alloc(dst_ops, NULL, 0, DST_OBSOLETE_NONE, 0);\r\nif (likely(xdst)) {\r\nstruct dst_entry *dst = &xdst->u.dst;\r\nmemset(dst + 1, 0, sizeof(*xdst) - sizeof(*dst));\r\nxdst->flo.ops = &xfrm_bundle_fc_ops;\r\nif (afinfo->init_dst)\r\nafinfo->init_dst(net, xdst);\r\n} else\r\nxdst = ERR_PTR(-ENOBUFS);\r\nxfrm_policy_put_afinfo(afinfo);\r\nreturn xdst;\r\n}\r\nstatic inline int xfrm_init_path(struct xfrm_dst *path, struct dst_entry *dst,\r\nint nfheader_len)\r\n{\r\nstruct xfrm_policy_afinfo *afinfo =\r\nxfrm_policy_get_afinfo(dst->ops->family);\r\nint err;\r\nif (!afinfo)\r\nreturn -EINVAL;\r\nerr = afinfo->init_path(path, dst, nfheader_len);\r\nxfrm_policy_put_afinfo(afinfo);\r\nreturn err;\r\n}\r\nstatic inline int xfrm_fill_dst(struct xfrm_dst *xdst, struct net_device *dev,\r\nconst struct flowi *fl)\r\n{\r\nstruct xfrm_policy_afinfo *afinfo =\r\nxfrm_policy_get_afinfo(xdst->u.dst.ops->family);\r\nint err;\r\nif (!afinfo)\r\nreturn -EINVAL;\r\nerr = afinfo->fill_dst(xdst, dev, fl);\r\nxfrm_policy_put_afinfo(afinfo);\r\nreturn err;\r\n}\r\nstatic struct dst_entry *xfrm_bundle_create(struct xfrm_policy *policy,\r\nstruct xfrm_state **xfrm, int nx,\r\nconst struct flowi *fl,\r\nstruct dst_entry *dst)\r\n{\r\nstruct net *net = xp_net(policy);\r\nunsigned long now = jiffies;\r\nstruct net_device *dev;\r\nstruct xfrm_mode *inner_mode;\r\nstruct dst_entry *dst_prev = NULL;\r\nstruct dst_entry *dst0 = NULL;\r\nint i = 0;\r\nint err;\r\nint header_len = 0;\r\nint nfheader_len = 0;\r\nint trailer_len = 0;\r\nint tos;\r\nint family = policy->selector.family;\r\nxfrm_address_t saddr, daddr;\r\nxfrm_flowi_addr_get(fl, &saddr, &daddr, family);\r\ntos = xfrm_get_tos(fl, family);\r\nerr = tos;\r\nif (tos < 0)\r\ngoto put_states;\r\ndst_hold(dst);\r\nfor (; i < nx; i++) {\r\nstruct xfrm_dst *xdst = xfrm_alloc_dst(net, family);\r\nstruct dst_entry *dst1 = &xdst->u.dst;\r\nerr = PTR_ERR(xdst);\r\nif (IS_ERR(xdst)) {\r\ndst_release(dst);\r\ngoto put_states;\r\n}\r\nif (xfrm[i]->sel.family == AF_UNSPEC) {\r\ninner_mode = xfrm_ip2inner_mode(xfrm[i],\r\nxfrm_af2proto(family));\r\nif (!inner_mode) {\r\nerr = -EAFNOSUPPORT;\r\ndst_release(dst);\r\ngoto put_states;\r\n}\r\n} else\r\ninner_mode = xfrm[i]->inner_mode;\r\nif (!dst_prev)\r\ndst0 = dst1;\r\nelse {\r\ndst_prev->child = dst_clone(dst1);\r\ndst1->flags |= DST_NOHASH;\r\n}\r\nxdst->route = dst;\r\ndst_copy_metrics(dst1, dst);\r\nif (xfrm[i]->props.mode != XFRM_MODE_TRANSPORT) {\r\nfamily = xfrm[i]->props.family;\r\ndst = xfrm_dst_lookup(xfrm[i], tos, &saddr, &daddr,\r\nfamily);\r\nerr = PTR_ERR(dst);\r\nif (IS_ERR(dst))\r\ngoto put_states;\r\n} else\r\ndst_hold(dst);\r\ndst1->xfrm = xfrm[i];\r\nxdst->xfrm_genid = xfrm[i]->genid;\r\ndst1->obsolete = DST_OBSOLETE_FORCE_CHK;\r\ndst1->flags |= DST_HOST;\r\ndst1->lastuse = now;\r\ndst1->input = dst_discard;\r\ndst1->output = inner_mode->afinfo->output;\r\ndst1->next = dst_prev;\r\ndst_prev = dst1;\r\nheader_len += xfrm[i]->props.header_len;\r\nif (xfrm[i]->type->flags & XFRM_TYPE_NON_FRAGMENT)\r\nnfheader_len += xfrm[i]->props.header_len;\r\ntrailer_len += xfrm[i]->props.trailer_len;\r\n}\r\ndst_prev->child = dst;\r\ndst0->path = dst;\r\nerr = -ENODEV;\r\ndev = dst->dev;\r\nif (!dev)\r\ngoto free_dst;\r\nxfrm_init_path((struct xfrm_dst *)dst0, dst, nfheader_len);\r\nxfrm_init_pmtu(dst_prev);\r\nfor (dst_prev = dst0; dst_prev != dst; dst_prev = dst_prev->child) {\r\nstruct xfrm_dst *xdst = (struct xfrm_dst *)dst_prev;\r\nerr = xfrm_fill_dst(xdst, dev, fl);\r\nif (err)\r\ngoto free_dst;\r\ndst_prev->header_len = header_len;\r\ndst_prev->trailer_len = trailer_len;\r\nheader_len -= xdst->u.dst.xfrm->props.header_len;\r\ntrailer_len -= xdst->u.dst.xfrm->props.trailer_len;\r\n}\r\nout:\r\nreturn dst0;\r\nput_states:\r\nfor (; i < nx; i++)\r\nxfrm_state_put(xfrm[i]);\r\nfree_dst:\r\nif (dst0)\r\ndst_free(dst0);\r\ndst0 = ERR_PTR(err);\r\ngoto out;\r\n}\r\nstatic int xfrm_dst_alloc_copy(void **target, const void *src, int size)\r\n{\r\nif (!*target) {\r\n*target = kmalloc(size, GFP_ATOMIC);\r\nif (!*target)\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(*target, src, size);\r\nreturn 0;\r\n}\r\nstatic int xfrm_dst_update_parent(struct dst_entry *dst,\r\nconst struct xfrm_selector *sel)\r\n{\r\n#ifdef CONFIG_XFRM_SUB_POLICY\r\nstruct xfrm_dst *xdst = (struct xfrm_dst *)dst;\r\nreturn xfrm_dst_alloc_copy((void **)&(xdst->partner),\r\nsel, sizeof(*sel));\r\n#else\r\nreturn 0;\r\n#endif\r\n}\r\nstatic int xfrm_dst_update_origin(struct dst_entry *dst,\r\nconst struct flowi *fl)\r\n{\r\n#ifdef CONFIG_XFRM_SUB_POLICY\r\nstruct xfrm_dst *xdst = (struct xfrm_dst *)dst;\r\nreturn xfrm_dst_alloc_copy((void **)&(xdst->origin), fl, sizeof(*fl));\r\n#else\r\nreturn 0;\r\n#endif\r\n}\r\nstatic int xfrm_expand_policies(const struct flowi *fl, u16 family,\r\nstruct xfrm_policy **pols,\r\nint *num_pols, int *num_xfrms)\r\n{\r\nint i;\r\nif (*num_pols == 0 || !pols[0]) {\r\n*num_pols = 0;\r\n*num_xfrms = 0;\r\nreturn 0;\r\n}\r\nif (IS_ERR(pols[0]))\r\nreturn PTR_ERR(pols[0]);\r\n*num_xfrms = pols[0]->xfrm_nr;\r\n#ifdef CONFIG_XFRM_SUB_POLICY\r\nif (pols[0] && pols[0]->action == XFRM_POLICY_ALLOW &&\r\npols[0]->type != XFRM_POLICY_TYPE_MAIN) {\r\npols[1] = xfrm_policy_lookup_bytype(xp_net(pols[0]),\r\nXFRM_POLICY_TYPE_MAIN,\r\nfl, family,\r\nXFRM_POLICY_OUT);\r\nif (pols[1]) {\r\nif (IS_ERR(pols[1])) {\r\nxfrm_pols_put(pols, *num_pols);\r\nreturn PTR_ERR(pols[1]);\r\n}\r\n(*num_pols)++;\r\n(*num_xfrms) += pols[1]->xfrm_nr;\r\n}\r\n}\r\n#endif\r\nfor (i = 0; i < *num_pols; i++) {\r\nif (pols[i]->action != XFRM_POLICY_ALLOW) {\r\n*num_xfrms = -1;\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic struct xfrm_dst *\r\nxfrm_resolve_and_create_bundle(struct xfrm_policy **pols, int num_pols,\r\nconst struct flowi *fl, u16 family,\r\nstruct dst_entry *dst_orig)\r\n{\r\nstruct net *net = xp_net(pols[0]);\r\nstruct xfrm_state *xfrm[XFRM_MAX_DEPTH];\r\nstruct dst_entry *dst;\r\nstruct xfrm_dst *xdst;\r\nint err;\r\nerr = xfrm_tmpl_resolve(pols, num_pols, fl, xfrm, family);\r\nif (err <= 0) {\r\nif (err != 0 && err != -EAGAIN)\r\nXFRM_INC_STATS(net, LINUX_MIB_XFRMOUTPOLERROR);\r\nreturn ERR_PTR(err);\r\n}\r\ndst = xfrm_bundle_create(pols[0], xfrm, err, fl, dst_orig);\r\nif (IS_ERR(dst)) {\r\nXFRM_INC_STATS(net, LINUX_MIB_XFRMOUTBUNDLEGENERROR);\r\nreturn ERR_CAST(dst);\r\n}\r\nxdst = (struct xfrm_dst *)dst;\r\nxdst->num_xfrms = err;\r\nif (num_pols > 1)\r\nerr = xfrm_dst_update_parent(dst, &pols[1]->selector);\r\nelse\r\nerr = xfrm_dst_update_origin(dst, fl);\r\nif (unlikely(err)) {\r\ndst_free(dst);\r\nXFRM_INC_STATS(net, LINUX_MIB_XFRMOUTBUNDLECHECKERROR);\r\nreturn ERR_PTR(err);\r\n}\r\nxdst->num_pols = num_pols;\r\nmemcpy(xdst->pols, pols, sizeof(struct xfrm_policy *) * num_pols);\r\nxdst->policy_genid = atomic_read(&pols[0]->genid);\r\nreturn xdst;\r\n}\r\nstatic void xfrm_policy_queue_process(unsigned long arg)\r\n{\r\nstruct sk_buff *skb;\r\nstruct sock *sk;\r\nstruct dst_entry *dst;\r\nstruct xfrm_policy *pol = (struct xfrm_policy *)arg;\r\nstruct xfrm_policy_queue *pq = &pol->polq;\r\nstruct flowi fl;\r\nstruct sk_buff_head list;\r\nspin_lock(&pq->hold_queue.lock);\r\nskb = skb_peek(&pq->hold_queue);\r\nif (!skb) {\r\nspin_unlock(&pq->hold_queue.lock);\r\ngoto out;\r\n}\r\ndst = skb_dst(skb);\r\nsk = skb->sk;\r\nxfrm_decode_session(skb, &fl, dst->ops->family);\r\nspin_unlock(&pq->hold_queue.lock);\r\ndst_hold(dst->path);\r\ndst = xfrm_lookup(xp_net(pol), dst->path, &fl,\r\nsk, 0);\r\nif (IS_ERR(dst))\r\ngoto purge_queue;\r\nif (dst->flags & DST_XFRM_QUEUE) {\r\ndst_release(dst);\r\nif (pq->timeout >= XFRM_QUEUE_TMO_MAX)\r\ngoto purge_queue;\r\npq->timeout = pq->timeout << 1;\r\nif (!mod_timer(&pq->hold_timer, jiffies + pq->timeout))\r\nxfrm_pol_hold(pol);\r\ngoto out;\r\n}\r\ndst_release(dst);\r\n__skb_queue_head_init(&list);\r\nspin_lock(&pq->hold_queue.lock);\r\npq->timeout = 0;\r\nskb_queue_splice_init(&pq->hold_queue, &list);\r\nspin_unlock(&pq->hold_queue.lock);\r\nwhile (!skb_queue_empty(&list)) {\r\nskb = __skb_dequeue(&list);\r\nxfrm_decode_session(skb, &fl, skb_dst(skb)->ops->family);\r\ndst_hold(skb_dst(skb)->path);\r\ndst = xfrm_lookup(xp_net(pol), skb_dst(skb)->path,\r\n&fl, skb->sk, 0);\r\nif (IS_ERR(dst)) {\r\nkfree_skb(skb);\r\ncontinue;\r\n}\r\nnf_reset(skb);\r\nskb_dst_drop(skb);\r\nskb_dst_set(skb, dst);\r\ndst_output(skb);\r\n}\r\nout:\r\nxfrm_pol_put(pol);\r\nreturn;\r\npurge_queue:\r\npq->timeout = 0;\r\nxfrm_queue_purge(&pq->hold_queue);\r\nxfrm_pol_put(pol);\r\n}\r\nstatic int xdst_queue_output(struct sock *sk, struct sk_buff *skb)\r\n{\r\nunsigned long sched_next;\r\nstruct dst_entry *dst = skb_dst(skb);\r\nstruct xfrm_dst *xdst = (struct xfrm_dst *) dst;\r\nstruct xfrm_policy *pol = xdst->pols[0];\r\nstruct xfrm_policy_queue *pq = &pol->polq;\r\nif (unlikely(skb_fclone_busy(sk, skb))) {\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nif (pq->hold_queue.qlen > XFRM_MAX_QUEUE_LEN) {\r\nkfree_skb(skb);\r\nreturn -EAGAIN;\r\n}\r\nskb_dst_force(skb);\r\nspin_lock_bh(&pq->hold_queue.lock);\r\nif (!pq->timeout)\r\npq->timeout = XFRM_QUEUE_TMO_MIN;\r\nsched_next = jiffies + pq->timeout;\r\nif (del_timer(&pq->hold_timer)) {\r\nif (time_before(pq->hold_timer.expires, sched_next))\r\nsched_next = pq->hold_timer.expires;\r\nxfrm_pol_put(pol);\r\n}\r\n__skb_queue_tail(&pq->hold_queue, skb);\r\nif (!mod_timer(&pq->hold_timer, sched_next))\r\nxfrm_pol_hold(pol);\r\nspin_unlock_bh(&pq->hold_queue.lock);\r\nreturn 0;\r\n}\r\nstatic struct xfrm_dst *xfrm_create_dummy_bundle(struct net *net,\r\nstruct xfrm_flo *xflo,\r\nconst struct flowi *fl,\r\nint num_xfrms,\r\nu16 family)\r\n{\r\nint err;\r\nstruct net_device *dev;\r\nstruct dst_entry *dst;\r\nstruct dst_entry *dst1;\r\nstruct xfrm_dst *xdst;\r\nxdst = xfrm_alloc_dst(net, family);\r\nif (IS_ERR(xdst))\r\nreturn xdst;\r\nif (!(xflo->flags & XFRM_LOOKUP_QUEUE) ||\r\nnet->xfrm.sysctl_larval_drop ||\r\nnum_xfrms <= 0)\r\nreturn xdst;\r\ndst = xflo->dst_orig;\r\ndst1 = &xdst->u.dst;\r\ndst_hold(dst);\r\nxdst->route = dst;\r\ndst_copy_metrics(dst1, dst);\r\ndst1->obsolete = DST_OBSOLETE_FORCE_CHK;\r\ndst1->flags |= DST_HOST | DST_XFRM_QUEUE;\r\ndst1->lastuse = jiffies;\r\ndst1->input = dst_discard;\r\ndst1->output = xdst_queue_output;\r\ndst_hold(dst);\r\ndst1->child = dst;\r\ndst1->path = dst;\r\nxfrm_init_path((struct xfrm_dst *)dst1, dst, 0);\r\nerr = -ENODEV;\r\ndev = dst->dev;\r\nif (!dev)\r\ngoto free_dst;\r\nerr = xfrm_fill_dst(xdst, dev, fl);\r\nif (err)\r\ngoto free_dst;\r\nout:\r\nreturn xdst;\r\nfree_dst:\r\ndst_release(dst1);\r\nxdst = ERR_PTR(err);\r\ngoto out;\r\n}\r\nstatic struct flow_cache_object *\r\nxfrm_bundle_lookup(struct net *net, const struct flowi *fl, u16 family, u8 dir,\r\nstruct flow_cache_object *oldflo, void *ctx)\r\n{\r\nstruct xfrm_flo *xflo = (struct xfrm_flo *)ctx;\r\nstruct xfrm_policy *pols[XFRM_POLICY_TYPE_MAX];\r\nstruct xfrm_dst *xdst, *new_xdst;\r\nint num_pols = 0, num_xfrms = 0, i, err, pol_dead;\r\nxdst = NULL;\r\nif (oldflo) {\r\nxdst = container_of(oldflo, struct xfrm_dst, flo);\r\nnum_pols = xdst->num_pols;\r\nnum_xfrms = xdst->num_xfrms;\r\npol_dead = 0;\r\nfor (i = 0; i < num_pols; i++) {\r\npols[i] = xdst->pols[i];\r\npol_dead |= pols[i]->walk.dead;\r\n}\r\nif (pol_dead) {\r\ndst_free(&xdst->u.dst);\r\nxdst = NULL;\r\nnum_pols = 0;\r\nnum_xfrms = 0;\r\noldflo = NULL;\r\n}\r\n}\r\nif (xdst == NULL) {\r\nnum_pols = 1;\r\npols[0] = __xfrm_policy_lookup(net, fl, family,\r\nflow_to_policy_dir(dir));\r\nerr = xfrm_expand_policies(fl, family, pols,\r\n&num_pols, &num_xfrms);\r\nif (err < 0)\r\ngoto inc_error;\r\nif (num_pols == 0)\r\nreturn NULL;\r\nif (num_xfrms <= 0)\r\ngoto make_dummy_bundle;\r\n}\r\nnew_xdst = xfrm_resolve_and_create_bundle(pols, num_pols, fl, family,\r\nxflo->dst_orig);\r\nif (IS_ERR(new_xdst)) {\r\nerr = PTR_ERR(new_xdst);\r\nif (err != -EAGAIN)\r\ngoto error;\r\nif (oldflo == NULL)\r\ngoto make_dummy_bundle;\r\ndst_hold(&xdst->u.dst);\r\nreturn oldflo;\r\n} else if (new_xdst == NULL) {\r\nnum_xfrms = 0;\r\nif (oldflo == NULL)\r\ngoto make_dummy_bundle;\r\nxdst->num_xfrms = 0;\r\ndst_hold(&xdst->u.dst);\r\nreturn oldflo;\r\n}\r\nif (xdst) {\r\nxdst->num_pols = 0;\r\ndst_free(&xdst->u.dst);\r\n}\r\ndst_hold(&new_xdst->u.dst);\r\nreturn &new_xdst->flo;\r\nmake_dummy_bundle:\r\nxdst = xfrm_create_dummy_bundle(net, xflo, fl, num_xfrms, family);\r\nif (IS_ERR(xdst)) {\r\nxfrm_pols_put(pols, num_pols);\r\nreturn ERR_CAST(xdst);\r\n}\r\nxdst->num_pols = num_pols;\r\nxdst->num_xfrms = num_xfrms;\r\nmemcpy(xdst->pols, pols, sizeof(struct xfrm_policy *) * num_pols);\r\ndst_hold(&xdst->u.dst);\r\nreturn &xdst->flo;\r\ninc_error:\r\nXFRM_INC_STATS(net, LINUX_MIB_XFRMOUTPOLERROR);\r\nerror:\r\nif (xdst != NULL)\r\ndst_free(&xdst->u.dst);\r\nelse\r\nxfrm_pols_put(pols, num_pols);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic struct dst_entry *make_blackhole(struct net *net, u16 family,\r\nstruct dst_entry *dst_orig)\r\n{\r\nstruct xfrm_policy_afinfo *afinfo = xfrm_policy_get_afinfo(family);\r\nstruct dst_entry *ret;\r\nif (!afinfo) {\r\ndst_release(dst_orig);\r\nreturn ERR_PTR(-EINVAL);\r\n} else {\r\nret = afinfo->blackhole_route(net, dst_orig);\r\n}\r\nxfrm_policy_put_afinfo(afinfo);\r\nreturn ret;\r\n}\r\nstruct dst_entry *xfrm_lookup(struct net *net, struct dst_entry *dst_orig,\r\nconst struct flowi *fl,\r\nstruct sock *sk, int flags)\r\n{\r\nstruct xfrm_policy *pols[XFRM_POLICY_TYPE_MAX];\r\nstruct flow_cache_object *flo;\r\nstruct xfrm_dst *xdst;\r\nstruct dst_entry *dst, *route;\r\nu16 family = dst_orig->ops->family;\r\nu8 dir = policy_to_flow_dir(XFRM_POLICY_OUT);\r\nint i, err, num_pols, num_xfrms = 0, drop_pols = 0;\r\ndst = NULL;\r\nxdst = NULL;\r\nroute = NULL;\r\nif (sk && sk->sk_policy[XFRM_POLICY_OUT]) {\r\nnum_pols = 1;\r\npols[0] = xfrm_sk_policy_lookup(sk, XFRM_POLICY_OUT, fl);\r\nerr = xfrm_expand_policies(fl, family, pols,\r\n&num_pols, &num_xfrms);\r\nif (err < 0)\r\ngoto dropdst;\r\nif (num_pols) {\r\nif (num_xfrms <= 0) {\r\ndrop_pols = num_pols;\r\ngoto no_transform;\r\n}\r\nxdst = xfrm_resolve_and_create_bundle(\r\npols, num_pols, fl,\r\nfamily, dst_orig);\r\nif (IS_ERR(xdst)) {\r\nxfrm_pols_put(pols, num_pols);\r\nerr = PTR_ERR(xdst);\r\ngoto dropdst;\r\n} else if (xdst == NULL) {\r\nnum_xfrms = 0;\r\ndrop_pols = num_pols;\r\ngoto no_transform;\r\n}\r\ndst_hold(&xdst->u.dst);\r\nxdst->u.dst.flags |= DST_NOCACHE;\r\nroute = xdst->route;\r\n}\r\n}\r\nif (xdst == NULL) {\r\nstruct xfrm_flo xflo;\r\nxflo.dst_orig = dst_orig;\r\nxflo.flags = flags;\r\nif ((dst_orig->flags & DST_NOXFRM) ||\r\n!net->xfrm.policy_count[XFRM_POLICY_OUT])\r\ngoto nopol;\r\nflo = flow_cache_lookup(net, fl, family, dir,\r\nxfrm_bundle_lookup, &xflo);\r\nif (flo == NULL)\r\ngoto nopol;\r\nif (IS_ERR(flo)) {\r\nerr = PTR_ERR(flo);\r\ngoto dropdst;\r\n}\r\nxdst = container_of(flo, struct xfrm_dst, flo);\r\nnum_pols = xdst->num_pols;\r\nnum_xfrms = xdst->num_xfrms;\r\nmemcpy(pols, xdst->pols, sizeof(struct xfrm_policy *) * num_pols);\r\nroute = xdst->route;\r\n}\r\ndst = &xdst->u.dst;\r\nif (route == NULL && num_xfrms > 0) {\r\nif (net->xfrm.sysctl_larval_drop) {\r\nXFRM_INC_STATS(net, LINUX_MIB_XFRMOUTNOSTATES);\r\nerr = -EREMOTE;\r\ngoto error;\r\n}\r\nerr = -EAGAIN;\r\nXFRM_INC_STATS(net, LINUX_MIB_XFRMOUTNOSTATES);\r\ngoto error;\r\n}\r\nno_transform:\r\nif (num_pols == 0)\r\ngoto nopol;\r\nif ((flags & XFRM_LOOKUP_ICMP) &&\r\n!(pols[0]->flags & XFRM_POLICY_ICMP)) {\r\nerr = -ENOENT;\r\ngoto error;\r\n}\r\nfor (i = 0; i < num_pols; i++)\r\npols[i]->curlft.use_time = get_seconds();\r\nif (num_xfrms < 0) {\r\nXFRM_INC_STATS(net, LINUX_MIB_XFRMOUTPOLBLOCK);\r\nerr = -EPERM;\r\ngoto error;\r\n} else if (num_xfrms > 0) {\r\ndst_release(dst_orig);\r\n} else {\r\ndst_release(dst);\r\ndst = dst_orig;\r\n}\r\nok:\r\nxfrm_pols_put(pols, drop_pols);\r\nif (dst && dst->xfrm &&\r\ndst->xfrm->props.mode == XFRM_MODE_TUNNEL)\r\ndst->flags |= DST_XFRM_TUNNEL;\r\nreturn dst;\r\nnopol:\r\nif (!(flags & XFRM_LOOKUP_ICMP)) {\r\ndst = dst_orig;\r\ngoto ok;\r\n}\r\nerr = -ENOENT;\r\nerror:\r\ndst_release(dst);\r\ndropdst:\r\nif (!(flags & XFRM_LOOKUP_KEEP_DST_REF))\r\ndst_release(dst_orig);\r\nxfrm_pols_put(pols, drop_pols);\r\nreturn ERR_PTR(err);\r\n}\r\nstruct dst_entry *xfrm_lookup_route(struct net *net, struct dst_entry *dst_orig,\r\nconst struct flowi *fl,\r\nstruct sock *sk, int flags)\r\n{\r\nstruct dst_entry *dst = xfrm_lookup(net, dst_orig, fl, sk,\r\nflags | XFRM_LOOKUP_QUEUE |\r\nXFRM_LOOKUP_KEEP_DST_REF);\r\nif (IS_ERR(dst) && PTR_ERR(dst) == -EREMOTE)\r\nreturn make_blackhole(net, dst_orig->ops->family, dst_orig);\r\nreturn dst;\r\n}\r\nstatic inline int\r\nxfrm_secpath_reject(int idx, struct sk_buff *skb, const struct flowi *fl)\r\n{\r\nstruct xfrm_state *x;\r\nif (!skb->sp || idx < 0 || idx >= skb->sp->len)\r\nreturn 0;\r\nx = skb->sp->xvec[idx];\r\nif (!x->type->reject)\r\nreturn 0;\r\nreturn x->type->reject(x, skb, fl);\r\n}\r\nstatic inline int\r\nxfrm_state_ok(const struct xfrm_tmpl *tmpl, const struct xfrm_state *x,\r\nunsigned short family)\r\n{\r\nif (xfrm_state_kern(x))\r\nreturn tmpl->optional && !xfrm_state_addr_cmp(tmpl, x, tmpl->encap_family);\r\nreturn x->id.proto == tmpl->id.proto &&\r\n(x->id.spi == tmpl->id.spi || !tmpl->id.spi) &&\r\n(x->props.reqid == tmpl->reqid || !tmpl->reqid) &&\r\nx->props.mode == tmpl->mode &&\r\n(tmpl->allalgs || (tmpl->aalgos & (1<<x->props.aalgo)) ||\r\n!(xfrm_id_proto_match(tmpl->id.proto, IPSEC_PROTO_ANY))) &&\r\n!(x->props.mode != XFRM_MODE_TRANSPORT &&\r\nxfrm_state_addr_cmp(tmpl, x, family));\r\n}\r\nstatic inline int\r\nxfrm_policy_ok(const struct xfrm_tmpl *tmpl, const struct sec_path *sp, int start,\r\nunsigned short family)\r\n{\r\nint idx = start;\r\nif (tmpl->optional) {\r\nif (tmpl->mode == XFRM_MODE_TRANSPORT)\r\nreturn start;\r\n} else\r\nstart = -1;\r\nfor (; idx < sp->len; idx++) {\r\nif (xfrm_state_ok(tmpl, sp->xvec[idx], family))\r\nreturn ++idx;\r\nif (sp->xvec[idx]->props.mode != XFRM_MODE_TRANSPORT) {\r\nif (start == -1)\r\nstart = -2-idx;\r\nbreak;\r\n}\r\n}\r\nreturn start;\r\n}\r\nint __xfrm_decode_session(struct sk_buff *skb, struct flowi *fl,\r\nunsigned int family, int reverse)\r\n{\r\nstruct xfrm_policy_afinfo *afinfo = xfrm_policy_get_afinfo(family);\r\nint err;\r\nif (unlikely(afinfo == NULL))\r\nreturn -EAFNOSUPPORT;\r\nafinfo->decode_session(skb, fl, reverse);\r\nerr = security_xfrm_decode_session(skb, &fl->flowi_secid);\r\nxfrm_policy_put_afinfo(afinfo);\r\nreturn err;\r\n}\r\nstatic inline int secpath_has_nontransport(const struct sec_path *sp, int k, int *idxp)\r\n{\r\nfor (; k < sp->len; k++) {\r\nif (sp->xvec[k]->props.mode != XFRM_MODE_TRANSPORT) {\r\n*idxp = k;\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint __xfrm_policy_check(struct sock *sk, int dir, struct sk_buff *skb,\r\nunsigned short family)\r\n{\r\nstruct net *net = dev_net(skb->dev);\r\nstruct xfrm_policy *pol;\r\nstruct xfrm_policy *pols[XFRM_POLICY_TYPE_MAX];\r\nint npols = 0;\r\nint xfrm_nr;\r\nint pi;\r\nint reverse;\r\nstruct flowi fl;\r\nu8 fl_dir;\r\nint xerr_idx = -1;\r\nreverse = dir & ~XFRM_POLICY_MASK;\r\ndir &= XFRM_POLICY_MASK;\r\nfl_dir = policy_to_flow_dir(dir);\r\nif (__xfrm_decode_session(skb, &fl, family, reverse) < 0) {\r\nXFRM_INC_STATS(net, LINUX_MIB_XFRMINHDRERROR);\r\nreturn 0;\r\n}\r\nnf_nat_decode_session(skb, &fl, family);\r\nif (skb->sp) {\r\nint i;\r\nfor (i = skb->sp->len-1; i >= 0; i--) {\r\nstruct xfrm_state *x = skb->sp->xvec[i];\r\nif (!xfrm_selector_match(&x->sel, &fl, family)) {\r\nXFRM_INC_STATS(net, LINUX_MIB_XFRMINSTATEMISMATCH);\r\nreturn 0;\r\n}\r\n}\r\n}\r\npol = NULL;\r\nif (sk && sk->sk_policy[dir]) {\r\npol = xfrm_sk_policy_lookup(sk, dir, &fl);\r\nif (IS_ERR(pol)) {\r\nXFRM_INC_STATS(net, LINUX_MIB_XFRMINPOLERROR);\r\nreturn 0;\r\n}\r\n}\r\nif (!pol) {\r\nstruct flow_cache_object *flo;\r\nflo = flow_cache_lookup(net, &fl, family, fl_dir,\r\nxfrm_policy_lookup, NULL);\r\nif (IS_ERR_OR_NULL(flo))\r\npol = ERR_CAST(flo);\r\nelse\r\npol = container_of(flo, struct xfrm_policy, flo);\r\n}\r\nif (IS_ERR(pol)) {\r\nXFRM_INC_STATS(net, LINUX_MIB_XFRMINPOLERROR);\r\nreturn 0;\r\n}\r\nif (!pol) {\r\nif (skb->sp && secpath_has_nontransport(skb->sp, 0, &xerr_idx)) {\r\nxfrm_secpath_reject(xerr_idx, skb, &fl);\r\nXFRM_INC_STATS(net, LINUX_MIB_XFRMINNOPOLS);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\npol->curlft.use_time = get_seconds();\r\npols[0] = pol;\r\nnpols++;\r\n#ifdef CONFIG_XFRM_SUB_POLICY\r\nif (pols[0]->type != XFRM_POLICY_TYPE_MAIN) {\r\npols[1] = xfrm_policy_lookup_bytype(net, XFRM_POLICY_TYPE_MAIN,\r\n&fl, family,\r\nXFRM_POLICY_IN);\r\nif (pols[1]) {\r\nif (IS_ERR(pols[1])) {\r\nXFRM_INC_STATS(net, LINUX_MIB_XFRMINPOLERROR);\r\nreturn 0;\r\n}\r\npols[1]->curlft.use_time = get_seconds();\r\nnpols++;\r\n}\r\n}\r\n#endif\r\nif (pol->action == XFRM_POLICY_ALLOW) {\r\nstruct sec_path *sp;\r\nstatic struct sec_path dummy;\r\nstruct xfrm_tmpl *tp[XFRM_MAX_DEPTH];\r\nstruct xfrm_tmpl *stp[XFRM_MAX_DEPTH];\r\nstruct xfrm_tmpl **tpp = tp;\r\nint ti = 0;\r\nint i, k;\r\nif ((sp = skb->sp) == NULL)\r\nsp = &dummy;\r\nfor (pi = 0; pi < npols; pi++) {\r\nif (pols[pi] != pol &&\r\npols[pi]->action != XFRM_POLICY_ALLOW) {\r\nXFRM_INC_STATS(net, LINUX_MIB_XFRMINPOLBLOCK);\r\ngoto reject;\r\n}\r\nif (ti + pols[pi]->xfrm_nr >= XFRM_MAX_DEPTH) {\r\nXFRM_INC_STATS(net, LINUX_MIB_XFRMINBUFFERERROR);\r\ngoto reject_error;\r\n}\r\nfor (i = 0; i < pols[pi]->xfrm_nr; i++)\r\ntpp[ti++] = &pols[pi]->xfrm_vec[i];\r\n}\r\nxfrm_nr = ti;\r\nif (npols > 1) {\r\nxfrm_tmpl_sort(stp, tpp, xfrm_nr, family, net);\r\ntpp = stp;\r\n}\r\nfor (i = xfrm_nr-1, k = 0; i >= 0; i--) {\r\nk = xfrm_policy_ok(tpp[i], sp, k, family);\r\nif (k < 0) {\r\nif (k < -1)\r\nxerr_idx = -(2+k);\r\nXFRM_INC_STATS(net, LINUX_MIB_XFRMINTMPLMISMATCH);\r\ngoto reject;\r\n}\r\n}\r\nif (secpath_has_nontransport(sp, k, &xerr_idx)) {\r\nXFRM_INC_STATS(net, LINUX_MIB_XFRMINTMPLMISMATCH);\r\ngoto reject;\r\n}\r\nxfrm_pols_put(pols, npols);\r\nreturn 1;\r\n}\r\nXFRM_INC_STATS(net, LINUX_MIB_XFRMINPOLBLOCK);\r\nreject:\r\nxfrm_secpath_reject(xerr_idx, skb, &fl);\r\nreject_error:\r\nxfrm_pols_put(pols, npols);\r\nreturn 0;\r\n}\r\nint __xfrm_route_forward(struct sk_buff *skb, unsigned short family)\r\n{\r\nstruct net *net = dev_net(skb->dev);\r\nstruct flowi fl;\r\nstruct dst_entry *dst;\r\nint res = 1;\r\nif (xfrm_decode_session(skb, &fl, family) < 0) {\r\nXFRM_INC_STATS(net, LINUX_MIB_XFRMFWDHDRERROR);\r\nreturn 0;\r\n}\r\nskb_dst_force(skb);\r\ndst = xfrm_lookup(net, skb_dst(skb), &fl, NULL, XFRM_LOOKUP_QUEUE);\r\nif (IS_ERR(dst)) {\r\nres = 0;\r\ndst = NULL;\r\n}\r\nskb_dst_set(skb, dst);\r\nreturn res;\r\n}\r\nstatic struct dst_entry *xfrm_dst_check(struct dst_entry *dst, u32 cookie)\r\n{\r\nif (dst->obsolete < 0 && !stale_bundle(dst))\r\nreturn dst;\r\nreturn NULL;\r\n}\r\nstatic int stale_bundle(struct dst_entry *dst)\r\n{\r\nreturn !xfrm_bundle_ok((struct xfrm_dst *)dst);\r\n}\r\nvoid xfrm_dst_ifdown(struct dst_entry *dst, struct net_device *dev)\r\n{\r\nwhile ((dst = dst->child) && dst->xfrm && dst->dev == dev) {\r\ndst->dev = dev_net(dev)->loopback_dev;\r\ndev_hold(dst->dev);\r\ndev_put(dev);\r\n}\r\n}\r\nstatic void xfrm_link_failure(struct sk_buff *skb)\r\n{\r\n}\r\nstatic struct dst_entry *xfrm_negative_advice(struct dst_entry *dst)\r\n{\r\nif (dst) {\r\nif (dst->obsolete) {\r\ndst_release(dst);\r\ndst = NULL;\r\n}\r\n}\r\nreturn dst;\r\n}\r\nvoid xfrm_garbage_collect(struct net *net)\r\n{\r\nflow_cache_flush(net);\r\n}\r\nstatic void xfrm_garbage_collect_deferred(struct net *net)\r\n{\r\nflow_cache_flush_deferred(net);\r\n}\r\nstatic void xfrm_init_pmtu(struct dst_entry *dst)\r\n{\r\ndo {\r\nstruct xfrm_dst *xdst = (struct xfrm_dst *)dst;\r\nu32 pmtu, route_mtu_cached;\r\npmtu = dst_mtu(dst->child);\r\nxdst->child_mtu_cached = pmtu;\r\npmtu = xfrm_state_mtu(dst->xfrm, pmtu);\r\nroute_mtu_cached = dst_mtu(xdst->route);\r\nxdst->route_mtu_cached = route_mtu_cached;\r\nif (pmtu > route_mtu_cached)\r\npmtu = route_mtu_cached;\r\ndst_metric_set(dst, RTAX_MTU, pmtu);\r\n} while ((dst = dst->next));\r\n}\r\nstatic int xfrm_bundle_ok(struct xfrm_dst *first)\r\n{\r\nstruct dst_entry *dst = &first->u.dst;\r\nstruct xfrm_dst *last;\r\nu32 mtu;\r\nif (!dst_check(dst->path, ((struct xfrm_dst *)dst)->path_cookie) ||\r\n(dst->dev && !netif_running(dst->dev)))\r\nreturn 0;\r\nif (dst->flags & DST_XFRM_QUEUE)\r\nreturn 1;\r\nlast = NULL;\r\ndo {\r\nstruct xfrm_dst *xdst = (struct xfrm_dst *)dst;\r\nif (dst->xfrm->km.state != XFRM_STATE_VALID)\r\nreturn 0;\r\nif (xdst->xfrm_genid != dst->xfrm->genid)\r\nreturn 0;\r\nif (xdst->num_pols > 0 &&\r\nxdst->policy_genid != atomic_read(&xdst->pols[0]->genid))\r\nreturn 0;\r\nmtu = dst_mtu(dst->child);\r\nif (xdst->child_mtu_cached != mtu) {\r\nlast = xdst;\r\nxdst->child_mtu_cached = mtu;\r\n}\r\nif (!dst_check(xdst->route, xdst->route_cookie))\r\nreturn 0;\r\nmtu = dst_mtu(xdst->route);\r\nif (xdst->route_mtu_cached != mtu) {\r\nlast = xdst;\r\nxdst->route_mtu_cached = mtu;\r\n}\r\ndst = dst->child;\r\n} while (dst->xfrm);\r\nif (likely(!last))\r\nreturn 1;\r\nmtu = last->child_mtu_cached;\r\nfor (;;) {\r\ndst = &last->u.dst;\r\nmtu = xfrm_state_mtu(dst->xfrm, mtu);\r\nif (mtu > last->route_mtu_cached)\r\nmtu = last->route_mtu_cached;\r\ndst_metric_set(dst, RTAX_MTU, mtu);\r\nif (last == first)\r\nbreak;\r\nlast = (struct xfrm_dst *)last->u.dst.next;\r\nlast->child_mtu_cached = mtu;\r\n}\r\nreturn 1;\r\n}\r\nstatic unsigned int xfrm_default_advmss(const struct dst_entry *dst)\r\n{\r\nreturn dst_metric_advmss(dst->path);\r\n}\r\nstatic unsigned int xfrm_mtu(const struct dst_entry *dst)\r\n{\r\nunsigned int mtu = dst_metric_raw(dst, RTAX_MTU);\r\nreturn mtu ? : dst_mtu(dst->path);\r\n}\r\nstatic struct neighbour *xfrm_neigh_lookup(const struct dst_entry *dst,\r\nstruct sk_buff *skb,\r\nconst void *daddr)\r\n{\r\nreturn dst->path->ops->neigh_lookup(dst, skb, daddr);\r\n}\r\nint xfrm_policy_register_afinfo(struct xfrm_policy_afinfo *afinfo)\r\n{\r\nstruct net *net;\r\nint err = 0;\r\nif (unlikely(afinfo == NULL))\r\nreturn -EINVAL;\r\nif (unlikely(afinfo->family >= NPROTO))\r\nreturn -EAFNOSUPPORT;\r\nspin_lock(&xfrm_policy_afinfo_lock);\r\nif (unlikely(xfrm_policy_afinfo[afinfo->family] != NULL))\r\nerr = -ENOBUFS;\r\nelse {\r\nstruct dst_ops *dst_ops = afinfo->dst_ops;\r\nif (likely(dst_ops->kmem_cachep == NULL))\r\ndst_ops->kmem_cachep = xfrm_dst_cache;\r\nif (likely(dst_ops->check == NULL))\r\ndst_ops->check = xfrm_dst_check;\r\nif (likely(dst_ops->default_advmss == NULL))\r\ndst_ops->default_advmss = xfrm_default_advmss;\r\nif (likely(dst_ops->mtu == NULL))\r\ndst_ops->mtu = xfrm_mtu;\r\nif (likely(dst_ops->negative_advice == NULL))\r\ndst_ops->negative_advice = xfrm_negative_advice;\r\nif (likely(dst_ops->link_failure == NULL))\r\ndst_ops->link_failure = xfrm_link_failure;\r\nif (likely(dst_ops->neigh_lookup == NULL))\r\ndst_ops->neigh_lookup = xfrm_neigh_lookup;\r\nif (likely(afinfo->garbage_collect == NULL))\r\nafinfo->garbage_collect = xfrm_garbage_collect_deferred;\r\nrcu_assign_pointer(xfrm_policy_afinfo[afinfo->family], afinfo);\r\n}\r\nspin_unlock(&xfrm_policy_afinfo_lock);\r\nrtnl_lock();\r\nfor_each_net(net) {\r\nstruct dst_ops *xfrm_dst_ops;\r\nswitch (afinfo->family) {\r\ncase AF_INET:\r\nxfrm_dst_ops = &net->xfrm.xfrm4_dst_ops;\r\nbreak;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase AF_INET6:\r\nxfrm_dst_ops = &net->xfrm.xfrm6_dst_ops;\r\nbreak;\r\n#endif\r\ndefault:\r\nBUG();\r\n}\r\n*xfrm_dst_ops = *afinfo->dst_ops;\r\n}\r\nrtnl_unlock();\r\nreturn err;\r\n}\r\nint xfrm_policy_unregister_afinfo(struct xfrm_policy_afinfo *afinfo)\r\n{\r\nint err = 0;\r\nif (unlikely(afinfo == NULL))\r\nreturn -EINVAL;\r\nif (unlikely(afinfo->family >= NPROTO))\r\nreturn -EAFNOSUPPORT;\r\nspin_lock(&xfrm_policy_afinfo_lock);\r\nif (likely(xfrm_policy_afinfo[afinfo->family] != NULL)) {\r\nif (unlikely(xfrm_policy_afinfo[afinfo->family] != afinfo))\r\nerr = -EINVAL;\r\nelse\r\nRCU_INIT_POINTER(xfrm_policy_afinfo[afinfo->family],\r\nNULL);\r\n}\r\nspin_unlock(&xfrm_policy_afinfo_lock);\r\nif (!err) {\r\nstruct dst_ops *dst_ops = afinfo->dst_ops;\r\nsynchronize_rcu();\r\ndst_ops->kmem_cachep = NULL;\r\ndst_ops->check = NULL;\r\ndst_ops->negative_advice = NULL;\r\ndst_ops->link_failure = NULL;\r\nafinfo->garbage_collect = NULL;\r\n}\r\nreturn err;\r\n}\r\nstatic void __net_init xfrm_dst_ops_init(struct net *net)\r\n{\r\nstruct xfrm_policy_afinfo *afinfo;\r\nrcu_read_lock();\r\nafinfo = rcu_dereference(xfrm_policy_afinfo[AF_INET]);\r\nif (afinfo)\r\nnet->xfrm.xfrm4_dst_ops = *afinfo->dst_ops;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nafinfo = rcu_dereference(xfrm_policy_afinfo[AF_INET6]);\r\nif (afinfo)\r\nnet->xfrm.xfrm6_dst_ops = *afinfo->dst_ops;\r\n#endif\r\nrcu_read_unlock();\r\n}\r\nstatic int xfrm_dev_event(struct notifier_block *this, unsigned long event, void *ptr)\r\n{\r\nstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\r\nswitch (event) {\r\ncase NETDEV_DOWN:\r\nxfrm_garbage_collect(dev_net(dev));\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int __net_init xfrm_statistics_init(struct net *net)\r\n{\r\nint rv;\r\nnet->mib.xfrm_statistics = alloc_percpu(struct linux_xfrm_mib);\r\nif (!net->mib.xfrm_statistics)\r\nreturn -ENOMEM;\r\nrv = xfrm_proc_init(net);\r\nif (rv < 0)\r\nfree_percpu(net->mib.xfrm_statistics);\r\nreturn rv;\r\n}\r\nstatic void xfrm_statistics_fini(struct net *net)\r\n{\r\nxfrm_proc_fini(net);\r\nfree_percpu(net->mib.xfrm_statistics);\r\n}\r\nstatic int __net_init xfrm_statistics_init(struct net *net)\r\n{\r\nreturn 0;\r\n}\r\nstatic void xfrm_statistics_fini(struct net *net)\r\n{\r\n}\r\nstatic int __net_init xfrm_policy_init(struct net *net)\r\n{\r\nunsigned int hmask, sz;\r\nint dir;\r\nif (net_eq(net, &init_net))\r\nxfrm_dst_cache = kmem_cache_create("xfrm_dst_cache",\r\nsizeof(struct xfrm_dst),\r\n0, SLAB_HWCACHE_ALIGN|SLAB_PANIC,\r\nNULL);\r\nhmask = 8 - 1;\r\nsz = (hmask+1) * sizeof(struct hlist_head);\r\nnet->xfrm.policy_byidx = xfrm_hash_alloc(sz);\r\nif (!net->xfrm.policy_byidx)\r\ngoto out_byidx;\r\nnet->xfrm.policy_idx_hmask = hmask;\r\nfor (dir = 0; dir < XFRM_POLICY_MAX; dir++) {\r\nstruct xfrm_policy_hash *htab;\r\nnet->xfrm.policy_count[dir] = 0;\r\nnet->xfrm.policy_count[XFRM_POLICY_MAX + dir] = 0;\r\nINIT_HLIST_HEAD(&net->xfrm.policy_inexact[dir]);\r\nhtab = &net->xfrm.policy_bydst[dir];\r\nhtab->table = xfrm_hash_alloc(sz);\r\nif (!htab->table)\r\ngoto out_bydst;\r\nhtab->hmask = hmask;\r\nhtab->dbits4 = 32;\r\nhtab->sbits4 = 32;\r\nhtab->dbits6 = 128;\r\nhtab->sbits6 = 128;\r\n}\r\nnet->xfrm.policy_hthresh.lbits4 = 32;\r\nnet->xfrm.policy_hthresh.rbits4 = 32;\r\nnet->xfrm.policy_hthresh.lbits6 = 128;\r\nnet->xfrm.policy_hthresh.rbits6 = 128;\r\nseqlock_init(&net->xfrm.policy_hthresh.lock);\r\nINIT_LIST_HEAD(&net->xfrm.policy_all);\r\nINIT_WORK(&net->xfrm.policy_hash_work, xfrm_hash_resize);\r\nINIT_WORK(&net->xfrm.policy_hthresh.work, xfrm_hash_rebuild);\r\nif (net_eq(net, &init_net))\r\nregister_netdevice_notifier(&xfrm_dev_notifier);\r\nreturn 0;\r\nout_bydst:\r\nfor (dir--; dir >= 0; dir--) {\r\nstruct xfrm_policy_hash *htab;\r\nhtab = &net->xfrm.policy_bydst[dir];\r\nxfrm_hash_free(htab->table, sz);\r\n}\r\nxfrm_hash_free(net->xfrm.policy_byidx, sz);\r\nout_byidx:\r\nreturn -ENOMEM;\r\n}\r\nstatic void xfrm_policy_fini(struct net *net)\r\n{\r\nunsigned int sz;\r\nint dir;\r\nflush_work(&net->xfrm.policy_hash_work);\r\n#ifdef CONFIG_XFRM_SUB_POLICY\r\nxfrm_policy_flush(net, XFRM_POLICY_TYPE_SUB, false);\r\n#endif\r\nxfrm_policy_flush(net, XFRM_POLICY_TYPE_MAIN, false);\r\nWARN_ON(!list_empty(&net->xfrm.policy_all));\r\nfor (dir = 0; dir < XFRM_POLICY_MAX; dir++) {\r\nstruct xfrm_policy_hash *htab;\r\nWARN_ON(!hlist_empty(&net->xfrm.policy_inexact[dir]));\r\nhtab = &net->xfrm.policy_bydst[dir];\r\nsz = (htab->hmask + 1) * sizeof(struct hlist_head);\r\nWARN_ON(!hlist_empty(htab->table));\r\nxfrm_hash_free(htab->table, sz);\r\n}\r\nsz = (net->xfrm.policy_idx_hmask + 1) * sizeof(struct hlist_head);\r\nWARN_ON(!hlist_empty(net->xfrm.policy_byidx));\r\nxfrm_hash_free(net->xfrm.policy_byidx, sz);\r\n}\r\nstatic int __net_init xfrm_net_init(struct net *net)\r\n{\r\nint rv;\r\nrv = xfrm_statistics_init(net);\r\nif (rv < 0)\r\ngoto out_statistics;\r\nrv = xfrm_state_init(net);\r\nif (rv < 0)\r\ngoto out_state;\r\nrv = xfrm_policy_init(net);\r\nif (rv < 0)\r\ngoto out_policy;\r\nxfrm_dst_ops_init(net);\r\nrv = xfrm_sysctl_init(net);\r\nif (rv < 0)\r\ngoto out_sysctl;\r\nrv = flow_cache_init(net);\r\nif (rv < 0)\r\ngoto out;\r\nspin_lock_init(&net->xfrm.xfrm_state_lock);\r\nrwlock_init(&net->xfrm.xfrm_policy_lock);\r\nmutex_init(&net->xfrm.xfrm_cfg_mutex);\r\nreturn 0;\r\nout:\r\nxfrm_sysctl_fini(net);\r\nout_sysctl:\r\nxfrm_policy_fini(net);\r\nout_policy:\r\nxfrm_state_fini(net);\r\nout_state:\r\nxfrm_statistics_fini(net);\r\nout_statistics:\r\nreturn rv;\r\n}\r\nstatic void __net_exit xfrm_net_exit(struct net *net)\r\n{\r\nflow_cache_fini(net);\r\nxfrm_sysctl_fini(net);\r\nxfrm_policy_fini(net);\r\nxfrm_state_fini(net);\r\nxfrm_statistics_fini(net);\r\n}\r\nvoid __init xfrm_init(void)\r\n{\r\nregister_pernet_subsys(&xfrm_net_ops);\r\nxfrm_input_init();\r\n}\r\nstatic void xfrm_audit_common_policyinfo(struct xfrm_policy *xp,\r\nstruct audit_buffer *audit_buf)\r\n{\r\nstruct xfrm_sec_ctx *ctx = xp->security;\r\nstruct xfrm_selector *sel = &xp->selector;\r\nif (ctx)\r\naudit_log_format(audit_buf, " sec_alg=%u sec_doi=%u sec_obj=%s",\r\nctx->ctx_alg, ctx->ctx_doi, ctx->ctx_str);\r\nswitch (sel->family) {\r\ncase AF_INET:\r\naudit_log_format(audit_buf, " src=%pI4", &sel->saddr.a4);\r\nif (sel->prefixlen_s != 32)\r\naudit_log_format(audit_buf, " src_prefixlen=%d",\r\nsel->prefixlen_s);\r\naudit_log_format(audit_buf, " dst=%pI4", &sel->daddr.a4);\r\nif (sel->prefixlen_d != 32)\r\naudit_log_format(audit_buf, " dst_prefixlen=%d",\r\nsel->prefixlen_d);\r\nbreak;\r\ncase AF_INET6:\r\naudit_log_format(audit_buf, " src=%pI6", sel->saddr.a6);\r\nif (sel->prefixlen_s != 128)\r\naudit_log_format(audit_buf, " src_prefixlen=%d",\r\nsel->prefixlen_s);\r\naudit_log_format(audit_buf, " dst=%pI6", sel->daddr.a6);\r\nif (sel->prefixlen_d != 128)\r\naudit_log_format(audit_buf, " dst_prefixlen=%d",\r\nsel->prefixlen_d);\r\nbreak;\r\n}\r\n}\r\nvoid xfrm_audit_policy_add(struct xfrm_policy *xp, int result, bool task_valid)\r\n{\r\nstruct audit_buffer *audit_buf;\r\naudit_buf = xfrm_audit_start("SPD-add");\r\nif (audit_buf == NULL)\r\nreturn;\r\nxfrm_audit_helper_usrinfo(task_valid, audit_buf);\r\naudit_log_format(audit_buf, " res=%u", result);\r\nxfrm_audit_common_policyinfo(xp, audit_buf);\r\naudit_log_end(audit_buf);\r\n}\r\nvoid xfrm_audit_policy_delete(struct xfrm_policy *xp, int result,\r\nbool task_valid)\r\n{\r\nstruct audit_buffer *audit_buf;\r\naudit_buf = xfrm_audit_start("SPD-delete");\r\nif (audit_buf == NULL)\r\nreturn;\r\nxfrm_audit_helper_usrinfo(task_valid, audit_buf);\r\naudit_log_format(audit_buf, " res=%u", result);\r\nxfrm_audit_common_policyinfo(xp, audit_buf);\r\naudit_log_end(audit_buf);\r\n}\r\nstatic bool xfrm_migrate_selector_match(const struct xfrm_selector *sel_cmp,\r\nconst struct xfrm_selector *sel_tgt)\r\n{\r\nif (sel_cmp->proto == IPSEC_ULPROTO_ANY) {\r\nif (sel_tgt->family == sel_cmp->family &&\r\nxfrm_addr_equal(&sel_tgt->daddr, &sel_cmp->daddr,\r\nsel_cmp->family) &&\r\nxfrm_addr_equal(&sel_tgt->saddr, &sel_cmp->saddr,\r\nsel_cmp->family) &&\r\nsel_tgt->prefixlen_d == sel_cmp->prefixlen_d &&\r\nsel_tgt->prefixlen_s == sel_cmp->prefixlen_s) {\r\nreturn true;\r\n}\r\n} else {\r\nif (memcmp(sel_tgt, sel_cmp, sizeof(*sel_tgt)) == 0) {\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic struct xfrm_policy *xfrm_migrate_policy_find(const struct xfrm_selector *sel,\r\nu8 dir, u8 type, struct net *net)\r\n{\r\nstruct xfrm_policy *pol, *ret = NULL;\r\nstruct hlist_head *chain;\r\nu32 priority = ~0U;\r\nread_lock_bh(&net->xfrm.xfrm_policy_lock);\r\nchain = policy_hash_direct(net, &sel->daddr, &sel->saddr, sel->family, dir);\r\nhlist_for_each_entry(pol, chain, bydst) {\r\nif (xfrm_migrate_selector_match(sel, &pol->selector) &&\r\npol->type == type) {\r\nret = pol;\r\npriority = ret->priority;\r\nbreak;\r\n}\r\n}\r\nchain = &net->xfrm.policy_inexact[dir];\r\nhlist_for_each_entry(pol, chain, bydst) {\r\nif (xfrm_migrate_selector_match(sel, &pol->selector) &&\r\npol->type == type &&\r\npol->priority < priority) {\r\nret = pol;\r\nbreak;\r\n}\r\n}\r\nif (ret)\r\nxfrm_pol_hold(ret);\r\nread_unlock_bh(&net->xfrm.xfrm_policy_lock);\r\nreturn ret;\r\n}\r\nstatic int migrate_tmpl_match(const struct xfrm_migrate *m, const struct xfrm_tmpl *t)\r\n{\r\nint match = 0;\r\nif (t->mode == m->mode && t->id.proto == m->proto &&\r\n(m->reqid == 0 || t->reqid == m->reqid)) {\r\nswitch (t->mode) {\r\ncase XFRM_MODE_TUNNEL:\r\ncase XFRM_MODE_BEET:\r\nif (xfrm_addr_equal(&t->id.daddr, &m->old_daddr,\r\nm->old_family) &&\r\nxfrm_addr_equal(&t->saddr, &m->old_saddr,\r\nm->old_family)) {\r\nmatch = 1;\r\n}\r\nbreak;\r\ncase XFRM_MODE_TRANSPORT:\r\nmatch = 1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn match;\r\n}\r\nstatic int xfrm_policy_migrate(struct xfrm_policy *pol,\r\nstruct xfrm_migrate *m, int num_migrate)\r\n{\r\nstruct xfrm_migrate *mp;\r\nint i, j, n = 0;\r\nwrite_lock_bh(&pol->lock);\r\nif (unlikely(pol->walk.dead)) {\r\nwrite_unlock_bh(&pol->lock);\r\nreturn -ENOENT;\r\n}\r\nfor (i = 0; i < pol->xfrm_nr; i++) {\r\nfor (j = 0, mp = m; j < num_migrate; j++, mp++) {\r\nif (!migrate_tmpl_match(mp, &pol->xfrm_vec[i]))\r\ncontinue;\r\nn++;\r\nif (pol->xfrm_vec[i].mode != XFRM_MODE_TUNNEL &&\r\npol->xfrm_vec[i].mode != XFRM_MODE_BEET)\r\ncontinue;\r\nmemcpy(&pol->xfrm_vec[i].id.daddr, &mp->new_daddr,\r\nsizeof(pol->xfrm_vec[i].id.daddr));\r\nmemcpy(&pol->xfrm_vec[i].saddr, &mp->new_saddr,\r\nsizeof(pol->xfrm_vec[i].saddr));\r\npol->xfrm_vec[i].encap_family = mp->new_family;\r\natomic_inc(&pol->genid);\r\n}\r\n}\r\nwrite_unlock_bh(&pol->lock);\r\nif (!n)\r\nreturn -ENODATA;\r\nreturn 0;\r\n}\r\nstatic int xfrm_migrate_check(const struct xfrm_migrate *m, int num_migrate)\r\n{\r\nint i, j;\r\nif (num_migrate < 1 || num_migrate > XFRM_MAX_DEPTH)\r\nreturn -EINVAL;\r\nfor (i = 0; i < num_migrate; i++) {\r\nif (xfrm_addr_equal(&m[i].old_daddr, &m[i].new_daddr,\r\nm[i].old_family) &&\r\nxfrm_addr_equal(&m[i].old_saddr, &m[i].new_saddr,\r\nm[i].old_family))\r\nreturn -EINVAL;\r\nif (xfrm_addr_any(&m[i].new_daddr, m[i].new_family) ||\r\nxfrm_addr_any(&m[i].new_saddr, m[i].new_family))\r\nreturn -EINVAL;\r\nfor (j = i + 1; j < num_migrate; j++) {\r\nif (!memcmp(&m[i].old_daddr, &m[j].old_daddr,\r\nsizeof(m[i].old_daddr)) &&\r\n!memcmp(&m[i].old_saddr, &m[j].old_saddr,\r\nsizeof(m[i].old_saddr)) &&\r\nm[i].proto == m[j].proto &&\r\nm[i].mode == m[j].mode &&\r\nm[i].reqid == m[j].reqid &&\r\nm[i].old_family == m[j].old_family)\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint xfrm_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,\r\nstruct xfrm_migrate *m, int num_migrate,\r\nstruct xfrm_kmaddress *k, struct net *net)\r\n{\r\nint i, err, nx_cur = 0, nx_new = 0;\r\nstruct xfrm_policy *pol = NULL;\r\nstruct xfrm_state *x, *xc;\r\nstruct xfrm_state *x_cur[XFRM_MAX_DEPTH];\r\nstruct xfrm_state *x_new[XFRM_MAX_DEPTH];\r\nstruct xfrm_migrate *mp;\r\nif ((err = xfrm_migrate_check(m, num_migrate)) < 0)\r\ngoto out;\r\nif ((pol = xfrm_migrate_policy_find(sel, dir, type, net)) == NULL) {\r\nerr = -ENOENT;\r\ngoto out;\r\n}\r\nfor (i = 0, mp = m; i < num_migrate; i++, mp++) {\r\nif ((x = xfrm_migrate_state_find(mp, net))) {\r\nx_cur[nx_cur] = x;\r\nnx_cur++;\r\nif ((xc = xfrm_state_migrate(x, mp))) {\r\nx_new[nx_new] = xc;\r\nnx_new++;\r\n} else {\r\nerr = -ENODATA;\r\ngoto restore_state;\r\n}\r\n}\r\n}\r\nif ((err = xfrm_policy_migrate(pol, m, num_migrate)) < 0)\r\ngoto restore_state;\r\nif (nx_cur) {\r\nxfrm_states_put(x_cur, nx_cur);\r\nxfrm_states_delete(x_cur, nx_cur);\r\n}\r\nkm_migrate(sel, dir, type, m, num_migrate, k);\r\nxfrm_pol_put(pol);\r\nreturn 0;\r\nout:\r\nreturn err;\r\nrestore_state:\r\nif (pol)\r\nxfrm_pol_put(pol);\r\nif (nx_cur)\r\nxfrm_states_put(x_cur, nx_cur);\r\nif (nx_new)\r\nxfrm_states_delete(x_new, nx_new);\r\nreturn err;\r\n}
