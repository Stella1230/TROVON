static void mlx4_en_cq_event(struct mlx4_cq *cq, enum mlx4_event event)\r\n{\r\nreturn;\r\n}\r\nint mlx4_en_create_cq(struct mlx4_en_priv *priv,\r\nstruct mlx4_en_cq **pcq,\r\nint entries, int ring, enum cq_type mode,\r\nint node)\r\n{\r\nstruct mlx4_en_dev *mdev = priv->mdev;\r\nstruct mlx4_en_cq *cq;\r\nint err;\r\ncq = kzalloc_node(sizeof(*cq), GFP_KERNEL, node);\r\nif (!cq) {\r\ncq = kzalloc(sizeof(*cq), GFP_KERNEL);\r\nif (!cq) {\r\nen_err(priv, "Failed to allocate CQ structure\n");\r\nreturn -ENOMEM;\r\n}\r\n}\r\ncq->size = entries;\r\ncq->buf_size = cq->size * mdev->dev->caps.cqe_size;\r\ncq->ring = ring;\r\ncq->is_tx = mode;\r\nset_dev_node(&mdev->dev->persist->pdev->dev, node);\r\nerr = mlx4_alloc_hwq_res(mdev->dev, &cq->wqres,\r\ncq->buf_size, 2 * PAGE_SIZE);\r\nset_dev_node(&mdev->dev->persist->pdev->dev, mdev->dev->numa_node);\r\nif (err)\r\ngoto err_cq;\r\nerr = mlx4_en_map_buffer(&cq->wqres.buf);\r\nif (err)\r\ngoto err_res;\r\ncq->buf = (struct mlx4_cqe *)cq->wqres.buf.direct.buf;\r\n*pcq = cq;\r\nreturn 0;\r\nerr_res:\r\nmlx4_free_hwq_res(mdev->dev, &cq->wqres, cq->buf_size);\r\nerr_cq:\r\nkfree(cq);\r\n*pcq = NULL;\r\nreturn err;\r\n}\r\nint mlx4_en_activate_cq(struct mlx4_en_priv *priv, struct mlx4_en_cq *cq,\r\nint cq_idx)\r\n{\r\nstruct mlx4_en_dev *mdev = priv->mdev;\r\nint err = 0;\r\nchar name[25];\r\nint timestamp_en = 0;\r\nstruct cpu_rmap *rmap =\r\n#ifdef CONFIG_RFS_ACCEL\r\npriv->dev->rx_cpu_rmap;\r\n#else\r\nNULL;\r\n#endif\r\ncq->dev = mdev->pndev[priv->port];\r\ncq->mcq.set_ci_db = cq->wqres.db.db;\r\ncq->mcq.arm_db = cq->wqres.db.db + 1;\r\n*cq->mcq.set_ci_db = 0;\r\n*cq->mcq.arm_db = 0;\r\nmemset(cq->buf, 0, cq->buf_size);\r\nif (cq->is_tx == RX) {\r\nif (mdev->dev->caps.comp_pool) {\r\nif (!cq->vector) {\r\nsprintf(name, "%s-%d", priv->dev->name,\r\ncq->ring);\r\nif (mlx4_assign_eq(mdev->dev, name, rmap,\r\n&cq->vector)) {\r\ncq->vector = (cq->ring + 1 + priv->port)\r\n% mdev->dev->caps.num_comp_vectors;\r\nmlx4_warn(mdev, "Failed assigning an EQ to %s, falling back to legacy EQ's\n",\r\nname);\r\n}\r\n}\r\n} else {\r\ncq->vector = (cq->ring + 1 + priv->port) %\r\nmdev->dev->caps.num_comp_vectors;\r\n}\r\ncq->irq_desc =\r\nirq_to_desc(mlx4_eq_get_irq(mdev->dev,\r\ncq->vector));\r\n} else {\r\nstruct mlx4_en_cq *rx_cq;\r\ncq_idx = cq_idx % priv->rx_ring_num;\r\nrx_cq = priv->rx_cq[cq_idx];\r\ncq->vector = rx_cq->vector;\r\n}\r\nif (!cq->is_tx)\r\ncq->size = priv->rx_ring[cq->ring]->actual_size;\r\nif ((cq->is_tx && priv->hwtstamp_config.tx_type) ||\r\n(!cq->is_tx && priv->hwtstamp_config.rx_filter))\r\ntimestamp_en = 1;\r\nerr = mlx4_cq_alloc(mdev->dev, cq->size, &cq->wqres.mtt,\r\n&mdev->priv_uar, cq->wqres.db.dma, &cq->mcq,\r\ncq->vector, 0, timestamp_en);\r\nif (err)\r\nreturn err;\r\ncq->mcq.comp = cq->is_tx ? mlx4_en_tx_irq : mlx4_en_rx_irq;\r\ncq->mcq.event = mlx4_en_cq_event;\r\nif (cq->is_tx) {\r\nnetif_napi_add(cq->dev, &cq->napi, mlx4_en_poll_tx_cq,\r\nNAPI_POLL_WEIGHT);\r\n} else {\r\nstruct mlx4_en_rx_ring *ring = priv->rx_ring[cq->ring];\r\nerr = irq_set_affinity_hint(cq->mcq.irq,\r\nring->affinity_mask);\r\nif (err)\r\nmlx4_warn(mdev, "Failed setting affinity hint\n");\r\nnetif_napi_add(cq->dev, &cq->napi, mlx4_en_poll_rx_cq, 64);\r\nnapi_hash_add(&cq->napi);\r\n}\r\nnapi_enable(&cq->napi);\r\nreturn 0;\r\n}\r\nvoid mlx4_en_destroy_cq(struct mlx4_en_priv *priv, struct mlx4_en_cq **pcq)\r\n{\r\nstruct mlx4_en_dev *mdev = priv->mdev;\r\nstruct mlx4_en_cq *cq = *pcq;\r\nmlx4_en_unmap_buffer(&cq->wqres.buf);\r\nmlx4_free_hwq_res(mdev->dev, &cq->wqres, cq->buf_size);\r\nif (priv->mdev->dev->caps.comp_pool && cq->vector) {\r\nmlx4_release_eq(priv->mdev->dev, cq->vector);\r\n}\r\ncq->vector = 0;\r\ncq->buf_size = 0;\r\ncq->buf = NULL;\r\nkfree(cq);\r\n*pcq = NULL;\r\n}\r\nvoid mlx4_en_deactivate_cq(struct mlx4_en_priv *priv, struct mlx4_en_cq *cq)\r\n{\r\nnapi_disable(&cq->napi);\r\nif (!cq->is_tx) {\r\nnapi_hash_del(&cq->napi);\r\nsynchronize_rcu();\r\nirq_set_affinity_hint(cq->mcq.irq, NULL);\r\n}\r\nnetif_napi_del(&cq->napi);\r\nmlx4_cq_free(priv->mdev->dev, &cq->mcq);\r\n}\r\nint mlx4_en_set_cq_moder(struct mlx4_en_priv *priv, struct mlx4_en_cq *cq)\r\n{\r\nreturn mlx4_cq_modify(priv->mdev->dev, &cq->mcq,\r\ncq->moder_cnt, cq->moder_time);\r\n}\r\nint mlx4_en_arm_cq(struct mlx4_en_priv *priv, struct mlx4_en_cq *cq)\r\n{\r\nmlx4_cq_arm(&cq->mcq, MLX4_CQ_DB_REQ_NOT, priv->mdev->uar_map,\r\n&priv->mdev->uar_lock);\r\nreturn 0;\r\n}
