static int hv_start_fcopy(struct hv_start_fcopy *smsg)\r\n{\r\nint error = HV_E_FAIL;\r\nchar *q, *p;\r\np = (char *)smsg->path_name;\r\nsnprintf(target_fname, sizeof(target_fname), "%s/%s",\r\n(char *)smsg->path_name, (char *)smsg->file_name);\r\nsyslog(LOG_INFO, "Target file name: %s", target_fname);\r\nwhile ((q = strchr(p, '/')) != NULL) {\r\nif (q == p) {\r\np++;\r\ncontinue;\r\n}\r\n*q = '\0';\r\nif (access((char *)smsg->path_name, F_OK)) {\r\nif (smsg->copy_flags & CREATE_PATH) {\r\nif (mkdir((char *)smsg->path_name, 0755)) {\r\nsyslog(LOG_ERR, "Failed to create %s",\r\n(char *)smsg->path_name);\r\ngoto done;\r\n}\r\n} else {\r\nsyslog(LOG_ERR, "Invalid path: %s",\r\n(char *)smsg->path_name);\r\ngoto done;\r\n}\r\n}\r\np = q + 1;\r\n*q = '/';\r\n}\r\nif (!access(target_fname, F_OK)) {\r\nsyslog(LOG_INFO, "File: %s exists", target_fname);\r\nif (!(smsg->copy_flags & OVER_WRITE)) {\r\nerror = HV_ERROR_ALREADY_EXISTS;\r\ngoto done;\r\n}\r\n}\r\ntarget_fd = open(target_fname,\r\nO_RDWR | O_CREAT | O_TRUNC | O_CLOEXEC, 0744);\r\nif (target_fd == -1) {\r\nsyslog(LOG_INFO, "Open Failed: %s", strerror(errno));\r\ngoto done;\r\n}\r\nerror = 0;\r\ndone:\r\nreturn error;\r\n}\r\nstatic int hv_copy_data(struct hv_do_fcopy *cpmsg)\r\n{\r\nssize_t bytes_written;\r\nbytes_written = pwrite(target_fd, cpmsg->data, cpmsg->size,\r\ncpmsg->offset);\r\nif (bytes_written != cpmsg->size)\r\nreturn HV_E_FAIL;\r\nreturn 0;\r\n}\r\nstatic int hv_copy_finished(void)\r\n{\r\nclose(target_fd);\r\nreturn 0;\r\n}\r\nstatic int hv_copy_cancel(void)\r\n{\r\nclose(target_fd);\r\nunlink(target_fname);\r\nreturn 0;\r\n}\r\nvoid print_usage(char *argv[])\r\n{\r\nfprintf(stderr, "Usage: %s [options]\n"\r\n"Options are:\n"\r\n" -n, --no-daemon stay in foreground, don't daemonize\n"\r\n" -h, --help print this help\n", argv[0]);\r\n}\r\nint main(int argc, char *argv[])\r\n{\r\nint fcopy_fd, len;\r\nint error;\r\nint daemonize = 1, long_index = 0, opt;\r\nint version = FCOPY_CURRENT_VERSION;\r\nchar *buffer[4096 * 2];\r\nstruct hv_fcopy_hdr *in_msg;\r\nstatic struct option long_options[] = {\r\n{"help", no_argument, 0, 'h' },\r\n{"no-daemon", no_argument, 0, 'n' },\r\n{0, 0, 0, 0 }\r\n};\r\nwhile ((opt = getopt_long(argc, argv, "hn", long_options,\r\n&long_index)) != -1) {\r\nswitch (opt) {\r\ncase 'n':\r\ndaemonize = 0;\r\nbreak;\r\ncase 'h':\r\ndefault:\r\nprint_usage(argv);\r\nexit(EXIT_FAILURE);\r\n}\r\n}\r\nif (daemonize && daemon(1, 0)) {\r\nsyslog(LOG_ERR, "daemon() failed; error: %s", strerror(errno));\r\nexit(EXIT_FAILURE);\r\n}\r\nopenlog("HV_FCOPY", 0, LOG_USER);\r\nsyslog(LOG_INFO, "HV_FCOPY starting; pid is:%d", getpid());\r\nfcopy_fd = open("/dev/vmbus/hv_fcopy", O_RDWR);\r\nif (fcopy_fd < 0) {\r\nsyslog(LOG_ERR, "open /dev/vmbus/hv_fcopy failed; error: %d %s",\r\nerrno, strerror(errno));\r\nexit(EXIT_FAILURE);\r\n}\r\nif ((write(fcopy_fd, &version, sizeof(int))) != sizeof(int)) {\r\nsyslog(LOG_ERR, "Registration failed: %s", strerror(errno));\r\nexit(EXIT_FAILURE);\r\n}\r\nwhile (1) {\r\nlen = pread(fcopy_fd, buffer, (4096 * 2), 0);\r\nif (len < 0) {\r\nsyslog(LOG_ERR, "pread failed: %s", strerror(errno));\r\nexit(EXIT_FAILURE);\r\n}\r\nin_msg = (struct hv_fcopy_hdr *)buffer;\r\nswitch (in_msg->operation) {\r\ncase START_FILE_COPY:\r\nerror = hv_start_fcopy((struct hv_start_fcopy *)in_msg);\r\nbreak;\r\ncase WRITE_TO_FILE:\r\nerror = hv_copy_data((struct hv_do_fcopy *)in_msg);\r\nbreak;\r\ncase COMPLETE_FCOPY:\r\nerror = hv_copy_finished();\r\nbreak;\r\ncase CANCEL_FCOPY:\r\nerror = hv_copy_cancel();\r\nbreak;\r\ndefault:\r\nsyslog(LOG_ERR, "Unknown operation: %d",\r\nin_msg->operation);\r\n}\r\nif (pwrite(fcopy_fd, &error, sizeof(int), 0) != sizeof(int)) {\r\nsyslog(LOG_ERR, "pwrite failed: %s", strerror(errno));\r\nexit(EXIT_FAILURE);\r\n}\r\n}\r\n}
