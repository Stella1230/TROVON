static bool ssm4567_readable_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase SSM4567_REG_POWER_CTRL ... SSM4567_REG_BOOST_CTRL_2:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool ssm4567_writeable_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase SSM4567_REG_POWER_CTRL ... SSM4567_REG_SAI_PLACEMENT_6:\r\ncase SSM4567_REG_LIMITER_CTRL_1 ... SSM4567_REG_LIMITER_CTRL_3:\r\ncase SSM4567_REG_FAULT_CTRL ... SSM4567_REG_BOOST_CTRL_2:\r\ncase SSM4567_REG_SOFT_RESET:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool ssm4567_volatile_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase SSM4567_REG_BATTERY_V_OUT:\r\ncase SSM4567_REG_STATUS_1 ... SSM4567_REG_STATUS_2:\r\ncase SSM4567_REG_SOFT_RESET:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int ssm4567_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct ssm4567 *ssm4567 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int rate = params_rate(params);\r\nunsigned int dacfs;\r\nif (rate >= 8000 && rate <= 12000)\r\ndacfs = SSM4567_DAC_FS_8000_12000;\r\nelse if (rate >= 16000 && rate <= 24000)\r\ndacfs = SSM4567_DAC_FS_16000_24000;\r\nelse if (rate >= 32000 && rate <= 48000)\r\ndacfs = SSM4567_DAC_FS_32000_48000;\r\nelse if (rate >= 64000 && rate <= 96000)\r\ndacfs = SSM4567_DAC_FS_64000_96000;\r\nelse if (rate >= 128000 && rate <= 192000)\r\ndacfs = SSM4567_DAC_FS_128000_192000;\r\nelse\r\nreturn -EINVAL;\r\nreturn regmap_update_bits(ssm4567->regmap, SSM4567_REG_DAC_CTRL,\r\nSSM4567_DAC_FS_MASK, dacfs);\r\n}\r\nstatic int ssm4567_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct ssm4567 *ssm4567 = snd_soc_codec_get_drvdata(dai->codec);\r\nunsigned int val;\r\nval = mute ? SSM4567_DAC_MUTE : 0;\r\nreturn regmap_update_bits(ssm4567->regmap, SSM4567_REG_DAC_CTRL,\r\nSSM4567_DAC_MUTE, val);\r\n}\r\nstatic int ssm4567_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,\r\nunsigned int rx_mask, int slots, int width)\r\n{\r\nstruct ssm4567 *ssm4567 = snd_soc_dai_get_drvdata(dai);\r\nunsigned int blcks;\r\nint slot;\r\nint ret;\r\nif (tx_mask == 0)\r\nreturn -EINVAL;\r\nif (rx_mask && rx_mask != tx_mask)\r\nreturn -EINVAL;\r\nslot = __ffs(tx_mask);\r\nif (tx_mask != BIT(slot))\r\nreturn -EINVAL;\r\nswitch (width) {\r\ncase 32:\r\nblcks = SSM4567_SAI_CTRL_1_TDM_BLCKS_32;\r\nbreak;\r\ncase 48:\r\nblcks = SSM4567_SAI_CTRL_1_TDM_BLCKS_48;\r\nbreak;\r\ncase 64:\r\nblcks = SSM4567_SAI_CTRL_1_TDM_BLCKS_64;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = regmap_update_bits(ssm4567->regmap, SSM4567_REG_SAI_CTRL_2,\r\nSSM4567_SAI_CTRL_2_AUTO_SLOT | SSM4567_SAI_CTRL_2_TDM_SLOT_MASK,\r\nSSM4567_SAI_CTRL_2_TDM_SLOT(slot));\r\nif (ret)\r\nreturn ret;\r\nreturn regmap_update_bits(ssm4567->regmap, SSM4567_REG_SAI_CTRL_1,\r\nSSM4567_SAI_CTRL_1_TDM_BLCKS_MASK, blcks);\r\n}\r\nstatic int ssm4567_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nstruct ssm4567 *ssm4567 = snd_soc_dai_get_drvdata(dai);\r\nunsigned int ctrl1 = 0;\r\nbool invert_fclk;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\ninvert_fclk = false;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nctrl1 |= SSM4567_SAI_CTRL_1_BCLK;\r\ninvert_fclk = false;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nctrl1 |= SSM4567_SAI_CTRL_1_FSYNC;\r\ninvert_fclk = true;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nctrl1 |= SSM4567_SAI_CTRL_1_BCLK;\r\ninvert_fclk = true;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nctrl1 |= SSM4567_SAI_CTRL_1_LJ;\r\ninvert_fclk = !invert_fclk;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\nctrl1 |= SSM4567_SAI_CTRL_1_TDM;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nctrl1 |= SSM4567_SAI_CTRL_1_TDM | SSM4567_SAI_CTRL_1_LJ;\r\nbreak;\r\ncase SND_SOC_DAIFMT_PDM:\r\nctrl1 |= SSM4567_SAI_CTRL_1_PDM;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (invert_fclk)\r\nctrl1 |= SSM4567_SAI_CTRL_1_FSYNC;\r\nreturn regmap_write(ssm4567->regmap, SSM4567_REG_SAI_CTRL_1, ctrl1);\r\n}\r\nstatic int ssm4567_set_power(struct ssm4567 *ssm4567, bool enable)\r\n{\r\nint ret = 0;\r\nif (!enable) {\r\nret = regmap_update_bits(ssm4567->regmap,\r\nSSM4567_REG_POWER_CTRL,\r\nSSM4567_POWER_SPWDN, SSM4567_POWER_SPWDN);\r\nregcache_mark_dirty(ssm4567->regmap);\r\n}\r\nregcache_cache_only(ssm4567->regmap, !enable);\r\nif (enable) {\r\nret = regmap_update_bits(ssm4567->regmap,\r\nSSM4567_REG_POWER_CTRL,\r\nSSM4567_POWER_SPWDN, 0x00);\r\nregcache_sync(ssm4567->regmap);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ssm4567_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct ssm4567 *ssm4567 = snd_soc_codec_get_drvdata(codec);\r\nint ret = 0;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_OFF)\r\nret = ssm4567_set_power(ssm4567, true);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nret = ssm4567_set_power(ssm4567, false);\r\nbreak;\r\n}\r\nif (ret)\r\nreturn ret;\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int ssm4567_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct ssm4567 *ssm4567;\r\nint ret;\r\nssm4567 = devm_kzalloc(&i2c->dev, sizeof(*ssm4567), GFP_KERNEL);\r\nif (ssm4567 == NULL)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(i2c, ssm4567);\r\nssm4567->regmap = devm_regmap_init_i2c(i2c, &ssm4567_regmap_config);\r\nif (IS_ERR(ssm4567->regmap))\r\nreturn PTR_ERR(ssm4567->regmap);\r\nret = regmap_write(ssm4567->regmap, SSM4567_REG_SOFT_RESET, 0x00);\r\nif (ret)\r\nreturn ret;\r\nret = ssm4567_set_power(ssm4567, false);\r\nif (ret)\r\nreturn ret;\r\nreturn snd_soc_register_codec(&i2c->dev, &ssm4567_codec_driver,\r\n&ssm4567_dai, 1);\r\n}\r\nstatic int ssm4567_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}
