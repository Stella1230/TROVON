void i915_gem_batch_pool_init(struct drm_device *dev,\r\nstruct i915_gem_batch_pool *pool)\r\n{\r\npool->dev = dev;\r\nINIT_LIST_HEAD(&pool->cache_list);\r\n}\r\nvoid i915_gem_batch_pool_fini(struct i915_gem_batch_pool *pool)\r\n{\r\nWARN_ON(!mutex_is_locked(&pool->dev->struct_mutex));\r\nwhile (!list_empty(&pool->cache_list)) {\r\nstruct drm_i915_gem_object *obj =\r\nlist_first_entry(&pool->cache_list,\r\nstruct drm_i915_gem_object,\r\nbatch_pool_list);\r\nWARN_ON(obj->active);\r\nlist_del_init(&obj->batch_pool_list);\r\ndrm_gem_object_unreference(&obj->base);\r\n}\r\n}\r\nstruct drm_i915_gem_object *\r\ni915_gem_batch_pool_get(struct i915_gem_batch_pool *pool,\r\nsize_t size)\r\n{\r\nstruct drm_i915_gem_object *obj = NULL;\r\nstruct drm_i915_gem_object *tmp, *next;\r\nWARN_ON(!mutex_is_locked(&pool->dev->struct_mutex));\r\nlist_for_each_entry_safe(tmp, next,\r\n&pool->cache_list, batch_pool_list) {\r\nif (tmp->active)\r\ncontinue;\r\nif (tmp->madv == __I915_MADV_PURGED) {\r\nlist_del(&tmp->batch_pool_list);\r\ndrm_gem_object_unreference(&tmp->base);\r\ncontinue;\r\n}\r\nif (tmp->base.size >= size &&\r\ntmp->base.size <= (2 * size)) {\r\nobj = tmp;\r\nbreak;\r\n}\r\n}\r\nif (!obj) {\r\nobj = i915_gem_alloc_object(pool->dev, size);\r\nif (!obj)\r\nreturn ERR_PTR(-ENOMEM);\r\nlist_add_tail(&obj->batch_pool_list, &pool->cache_list);\r\n}\r\nelse\r\nlist_move_tail(&obj->batch_pool_list, &pool->cache_list);\r\nobj->madv = I915_MADV_WILLNEED;\r\nreturn obj;\r\n}
