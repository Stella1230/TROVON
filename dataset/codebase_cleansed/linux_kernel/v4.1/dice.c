static int dice_interface_check(struct fw_unit *unit)\r\n{\r\nstatic const int min_values[10] = {\r\n10, 0x64 / 4,\r\n10, 0x18 / 4,\r\n10, 0x18 / 4,\r\n0, 0,\r\n0, 0,\r\n};\r\nstruct fw_device *device = fw_parent_device(unit);\r\nstruct fw_csr_iterator it;\r\nint key, val, vendor = -1, model = -1, err;\r\nunsigned int category, i;\r\n__be32 *pointers, value;\r\n__be32 version;\r\npointers = kmalloc_array(ARRAY_SIZE(min_values), sizeof(__be32),\r\nGFP_KERNEL);\r\nif (pointers == NULL)\r\nreturn -ENOMEM;\r\nfw_csr_iterator_init(&it, unit->directory);\r\nwhile (fw_csr_iterator_next(&it, &key, &val)) {\r\nswitch (key) {\r\ncase CSR_SPECIFIER_ID:\r\nvendor = val;\r\nbreak;\r\ncase CSR_MODEL:\r\nmodel = val;\r\nbreak;\r\n}\r\n}\r\nif (vendor == OUI_WEISS)\r\ncategory = WEISS_CATEGORY_ID;\r\nelse\r\ncategory = DICE_CATEGORY_ID;\r\nif (device->config_rom[3] != ((vendor << 8) | category) ||\r\ndevice->config_rom[4] >> 22 != model) {\r\nerr = -ENODEV;\r\ngoto end;\r\n}\r\nerr = snd_fw_transaction(unit, TCODE_READ_BLOCK_REQUEST,\r\nDICE_PRIVATE_SPACE, pointers,\r\nsizeof(__be32) * ARRAY_SIZE(min_values), 0);\r\nif (err < 0) {\r\nerr = -ENODEV;\r\ngoto end;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(min_values); ++i) {\r\nvalue = be32_to_cpu(pointers[i]);\r\nif (value < min_values[i] || value >= 0x40000) {\r\nerr = -ENODEV;\r\ngoto end;\r\n}\r\n}\r\nerr = snd_fw_transaction(unit, TCODE_READ_QUADLET_REQUEST,\r\nDICE_PRIVATE_SPACE +\r\nbe32_to_cpu(pointers[0]) * 4 + GLOBAL_VERSION,\r\n&version, 4, 0);\r\nif (err < 0) {\r\nerr = -ENODEV;\r\ngoto end;\r\n}\r\nif ((version & cpu_to_be32(0xff000000)) != cpu_to_be32(0x01000000)) {\r\ndev_err(&unit->device,\r\n"unknown DICE version: 0x%08x\n", be32_to_cpu(version));\r\nerr = -ENODEV;\r\ngoto end;\r\n}\r\nend:\r\nreturn err;\r\n}\r\nstatic int highest_supported_mode_rate(struct snd_dice *dice,\r\nunsigned int mode, unsigned int *rate)\r\n{\r\nunsigned int i, m;\r\nfor (i = ARRAY_SIZE(snd_dice_rates); i > 0; i--) {\r\n*rate = snd_dice_rates[i - 1];\r\nif (snd_dice_stream_get_rate_mode(dice, *rate, &m) < 0)\r\ncontinue;\r\nif (mode == m)\r\nbreak;\r\n}\r\nif (i == 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int dice_read_mode_params(struct snd_dice *dice, unsigned int mode)\r\n{\r\n__be32 values[2];\r\nunsigned int rate;\r\nint err;\r\nif (highest_supported_mode_rate(dice, mode, &rate) < 0) {\r\ndice->tx_channels[mode] = 0;\r\ndice->tx_midi_ports[mode] = 0;\r\ndice->rx_channels[mode] = 0;\r\ndice->rx_midi_ports[mode] = 0;\r\nreturn 0;\r\n}\r\nerr = snd_dice_transaction_set_rate(dice, rate);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_dice_transaction_read_tx(dice, TX_NUMBER_AUDIO,\r\nvalues, sizeof(values));\r\nif (err < 0)\r\nreturn err;\r\ndice->tx_channels[mode] = be32_to_cpu(values[0]);\r\ndice->tx_midi_ports[mode] = be32_to_cpu(values[1]);\r\nerr = snd_dice_transaction_read_rx(dice, RX_NUMBER_AUDIO,\r\nvalues, sizeof(values));\r\nif (err < 0)\r\nreturn err;\r\ndice->rx_channels[mode] = be32_to_cpu(values[0]);\r\ndice->rx_midi_ports[mode] = be32_to_cpu(values[1]);\r\nreturn 0;\r\n}\r\nstatic int dice_read_params(struct snd_dice *dice)\r\n{\r\n__be32 value;\r\nint mode, err;\r\nif (dice->clock_caps > 0) {\r\nerr = snd_dice_transaction_read_global(dice,\r\nGLOBAL_CLOCK_CAPABILITIES,\r\n&value, 4);\r\nif (err < 0)\r\nreturn err;\r\ndice->clock_caps = be32_to_cpu(value);\r\n} else {\r\ndice->clock_caps = CLOCK_CAP_RATE_44100 |\r\nCLOCK_CAP_RATE_48000 |\r\nCLOCK_CAP_SOURCE_ARX1 |\r\nCLOCK_CAP_SOURCE_INTERNAL;\r\n}\r\nfor (mode = 2; mode >= 0; --mode) {\r\nerr = dice_read_mode_params(dice, mode);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void dice_card_strings(struct snd_dice *dice)\r\n{\r\nstruct snd_card *card = dice->card;\r\nstruct fw_device *dev = fw_parent_device(dice->unit);\r\nchar vendor[32], model[32];\r\nunsigned int i;\r\nint err;\r\nstrcpy(card->driver, "DICE");\r\nstrcpy(card->shortname, "DICE");\r\nBUILD_BUG_ON(NICK_NAME_SIZE < sizeof(card->shortname));\r\nerr = snd_dice_transaction_read_global(dice, GLOBAL_NICK_NAME,\r\ncard->shortname,\r\nsizeof(card->shortname));\r\nif (err >= 0) {\r\nBUILD_BUG_ON(sizeof(card->shortname) % 4 != 0);\r\nfor (i = 0; i < sizeof(card->shortname); i += 4)\r\nswab32s((u32 *)&card->shortname[i]);\r\ncard->shortname[sizeof(card->shortname) - 1] = '\0';\r\n}\r\nstrcpy(vendor, "?");\r\nfw_csr_string(dev->config_rom + 5, CSR_VENDOR, vendor, sizeof(vendor));\r\nstrcpy(model, "?");\r\nfw_csr_string(dice->unit->directory, CSR_MODEL, model, sizeof(model));\r\nsnprintf(card->longname, sizeof(card->longname),\r\n"%s %s (serial %u) at %s, S%d",\r\nvendor, model, dev->config_rom[4] & 0x3fffff,\r\ndev_name(&dice->unit->device), 100 << dev->max_speed);\r\nstrcpy(card->mixername, "DICE");\r\n}\r\nstatic void dice_card_free(struct snd_card *card)\r\n{\r\nstruct snd_dice *dice = card->private_data;\r\nsnd_dice_stream_destroy_duplex(dice);\r\nsnd_dice_transaction_destroy(dice);\r\nfw_unit_put(dice->unit);\r\nmutex_destroy(&dice->mutex);\r\n}\r\nstatic int dice_probe(struct fw_unit *unit, const struct ieee1394_device_id *id)\r\n{\r\nstruct snd_card *card;\r\nstruct snd_dice *dice;\r\nint err;\r\nerr = dice_interface_check(unit);\r\nif (err < 0)\r\ngoto end;\r\nerr = snd_card_new(&unit->device, -1, NULL, THIS_MODULE,\r\nsizeof(*dice), &card);\r\nif (err < 0)\r\ngoto end;\r\ndice = card->private_data;\r\ndice->card = card;\r\ndice->unit = fw_unit_get(unit);\r\ncard->private_free = dice_card_free;\r\nspin_lock_init(&dice->lock);\r\nmutex_init(&dice->mutex);\r\ninit_completion(&dice->clock_accepted);\r\ninit_waitqueue_head(&dice->hwdep_wait);\r\nerr = snd_dice_transaction_init(dice);\r\nif (err < 0)\r\ngoto error;\r\nerr = dice_read_params(dice);\r\nif (err < 0)\r\ngoto error;\r\ndice_card_strings(dice);\r\nerr = snd_dice_create_pcm(dice);\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_dice_create_hwdep(dice);\r\nif (err < 0)\r\ngoto error;\r\nsnd_dice_create_proc(dice);\r\nerr = snd_dice_create_midi(dice);\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_dice_stream_init_duplex(dice);\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_card_register(card);\r\nif (err < 0) {\r\nsnd_dice_stream_destroy_duplex(dice);\r\ngoto error;\r\n}\r\ndev_set_drvdata(&unit->device, dice);\r\nend:\r\nreturn err;\r\nerror:\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nstatic void dice_remove(struct fw_unit *unit)\r\n{\r\nstruct snd_dice *dice = dev_get_drvdata(&unit->device);\r\nsnd_card_free_when_closed(dice->card);\r\n}\r\nstatic void dice_bus_reset(struct fw_unit *unit)\r\n{\r\nstruct snd_dice *dice = dev_get_drvdata(&unit->device);\r\nsnd_dice_transaction_reinit(dice);\r\nmutex_lock(&dice->mutex);\r\nsnd_dice_stream_update_duplex(dice);\r\nmutex_unlock(&dice->mutex);\r\n}\r\nstatic int __init alsa_dice_init(void)\r\n{\r\nreturn driver_register(&dice_driver.driver);\r\n}\r\nstatic void __exit alsa_dice_exit(void)\r\n{\r\ndriver_unregister(&dice_driver.driver);\r\n}
