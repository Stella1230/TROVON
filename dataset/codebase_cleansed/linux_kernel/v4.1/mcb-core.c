static const struct mcb_device_id *mcb_match_id(const struct mcb_device_id *ids,\r\nstruct mcb_device *dev)\r\n{\r\nif (ids) {\r\nwhile (ids->device) {\r\nif (ids->device == dev->id)\r\nreturn ids;\r\nids++;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic int mcb_match(struct device *dev, struct device_driver *drv)\r\n{\r\nstruct mcb_driver *mdrv = to_mcb_driver(drv);\r\nstruct mcb_device *mdev = to_mcb_device(dev);\r\nconst struct mcb_device_id *found_id;\r\nfound_id = mcb_match_id(mdrv->id_table, mdev);\r\nif (found_id)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int mcb_uevent(struct device *dev, struct kobj_uevent_env *env)\r\n{\r\nstruct mcb_device *mdev = to_mcb_device(dev);\r\nint ret;\r\nret = add_uevent_var(env, "MODALIAS=mcb:16z%03d", mdev->id);\r\nif (ret)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int mcb_probe(struct device *dev)\r\n{\r\nstruct mcb_driver *mdrv = to_mcb_driver(dev->driver);\r\nstruct mcb_device *mdev = to_mcb_device(dev);\r\nconst struct mcb_device_id *found_id;\r\nfound_id = mcb_match_id(mdrv->id_table, mdev);\r\nif (!found_id)\r\nreturn -ENODEV;\r\nreturn mdrv->probe(mdev, found_id);\r\n}\r\nstatic int mcb_remove(struct device *dev)\r\n{\r\nstruct mcb_driver *mdrv = to_mcb_driver(dev->driver);\r\nstruct mcb_device *mdev = to_mcb_device(dev);\r\nmdrv->remove(mdev);\r\nput_device(&mdev->dev);\r\nreturn 0;\r\n}\r\nstatic void mcb_shutdown(struct device *dev)\r\n{\r\nstruct mcb_device *mdev = to_mcb_device(dev);\r\nstruct mcb_driver *mdrv = mdev->driver;\r\nif (mdrv && mdrv->shutdown)\r\nmdrv->shutdown(mdev);\r\n}\r\nint __mcb_register_driver(struct mcb_driver *drv, struct module *owner,\r\nconst char *mod_name)\r\n{\r\nif (!drv->probe || !drv->remove)\r\nreturn -EINVAL;\r\ndrv->driver.owner = owner;\r\ndrv->driver.bus = &mcb_bus_type;\r\ndrv->driver.mod_name = mod_name;\r\nreturn driver_register(&drv->driver);\r\n}\r\nvoid mcb_unregister_driver(struct mcb_driver *drv)\r\n{\r\ndriver_unregister(&drv->driver);\r\n}\r\nstatic void mcb_release_dev(struct device *dev)\r\n{\r\nstruct mcb_device *mdev = to_mcb_device(dev);\r\nmcb_bus_put(mdev->bus);\r\nkfree(mdev);\r\n}\r\nint mcb_device_register(struct mcb_bus *bus, struct mcb_device *dev)\r\n{\r\nint ret;\r\nint device_id;\r\ndevice_initialize(&dev->dev);\r\ndev->dev.bus = &mcb_bus_type;\r\ndev->dev.parent = bus->dev.parent;\r\ndev->dev.release = mcb_release_dev;\r\ndevice_id = dev->id;\r\ndev_set_name(&dev->dev, "mcb%d-16z%03d-%d:%d:%d",\r\nbus->bus_nr, device_id, dev->inst, dev->group, dev->var);\r\nret = device_add(&dev->dev);\r\nif (ret < 0) {\r\npr_err("Failed registering device 16z%03d on bus mcb%d (%d)\n",\r\ndevice_id, bus->bus_nr, ret);\r\ngoto out;\r\n}\r\nreturn 0;\r\nout:\r\nreturn ret;\r\n}\r\nstruct mcb_bus *mcb_alloc_bus(struct device *carrier)\r\n{\r\nstruct mcb_bus *bus;\r\nint bus_nr;\r\nbus = kzalloc(sizeof(struct mcb_bus), GFP_KERNEL);\r\nif (!bus)\r\nreturn ERR_PTR(-ENOMEM);\r\nbus_nr = ida_simple_get(&mcb_ida, 0, 0, GFP_KERNEL);\r\nif (bus_nr < 0) {\r\nkfree(bus);\r\nreturn ERR_PTR(bus_nr);\r\n}\r\nINIT_LIST_HEAD(&bus->children);\r\nbus->bus_nr = bus_nr;\r\nbus->carrier = carrier;\r\nreturn bus;\r\n}\r\nstatic int __mcb_devices_unregister(struct device *dev, void *data)\r\n{\r\ndevice_unregister(dev);\r\nreturn 0;\r\n}\r\nstatic void mcb_devices_unregister(struct mcb_bus *bus)\r\n{\r\nbus_for_each_dev(&mcb_bus_type, NULL, NULL, __mcb_devices_unregister);\r\n}\r\nvoid mcb_release_bus(struct mcb_bus *bus)\r\n{\r\nmcb_devices_unregister(bus);\r\nida_simple_remove(&mcb_ida, bus->bus_nr);\r\nkfree(bus);\r\n}\r\nstruct mcb_bus *mcb_bus_get(struct mcb_bus *bus)\r\n{\r\nif (bus)\r\nget_device(&bus->dev);\r\nreturn bus;\r\n}\r\nvoid mcb_bus_put(struct mcb_bus *bus)\r\n{\r\nif (bus)\r\nput_device(&bus->dev);\r\n}\r\nstruct mcb_device *mcb_alloc_dev(struct mcb_bus *bus)\r\n{\r\nstruct mcb_device *dev;\r\ndev = kzalloc(sizeof(struct mcb_device), GFP_KERNEL);\r\nif (!dev)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&dev->bus_list);\r\ndev->bus = bus;\r\nreturn dev;\r\n}\r\nvoid mcb_free_dev(struct mcb_device *dev)\r\n{\r\nkfree(dev);\r\n}\r\nstatic int __mcb_bus_add_devices(struct device *dev, void *data)\r\n{\r\nstruct mcb_device *mdev = to_mcb_device(dev);\r\nint retval;\r\nif (mdev->is_added)\r\nreturn 0;\r\nretval = device_attach(dev);\r\nif (retval < 0)\r\ndev_err(dev, "Error adding device (%d)\n", retval);\r\nmdev->is_added = true;\r\nreturn 0;\r\n}\r\nstatic int __mcb_bus_add_child(struct device *dev, void *data)\r\n{\r\nstruct mcb_device *mdev = to_mcb_device(dev);\r\nstruct mcb_bus *child;\r\nBUG_ON(!mdev->is_added);\r\nchild = mdev->subordinate;\r\nif (child)\r\nmcb_bus_add_devices(child);\r\nreturn 0;\r\n}\r\nvoid mcb_bus_add_devices(const struct mcb_bus *bus)\r\n{\r\nbus_for_each_dev(&mcb_bus_type, NULL, NULL, __mcb_bus_add_devices);\r\nbus_for_each_dev(&mcb_bus_type, NULL, NULL, __mcb_bus_add_child);\r\n}\r\nstruct resource *mcb_request_mem(struct mcb_device *dev, const char *name)\r\n{\r\nstruct resource *mem;\r\nu32 size;\r\nif (!name)\r\nname = dev->dev.driver->name;\r\nsize = resource_size(&dev->mem);\r\nmem = request_mem_region(dev->mem.start, size, name);\r\nif (!mem)\r\nreturn ERR_PTR(-EBUSY);\r\nreturn mem;\r\n}\r\nvoid mcb_release_mem(struct resource *mem)\r\n{\r\nu32 size;\r\nsize = resource_size(mem);\r\nrelease_mem_region(mem->start, size);\r\n}\r\nstatic int __mcb_get_irq(struct mcb_device *dev)\r\n{\r\nstruct resource *irq = &dev->irq;\r\nreturn irq->start;\r\n}\r\nint mcb_get_irq(struct mcb_device *dev)\r\n{\r\nstruct mcb_bus *bus = dev->bus;\r\nif (bus->get_irq)\r\nreturn bus->get_irq(dev);\r\nreturn __mcb_get_irq(dev);\r\n}\r\nstatic int mcb_init(void)\r\n{\r\nreturn bus_register(&mcb_bus_type);\r\n}\r\nstatic void mcb_exit(void)\r\n{\r\nbus_unregister(&mcb_bus_type);\r\n}
