static void assert_out_naking(struct net2272_ep *ep, const char *where)\r\n{\r\nu8 tmp;\r\n#ifndef DEBUG\r\nreturn;\r\n#endif\r\ntmp = net2272_ep_read(ep, EP_STAT0);\r\nif ((tmp & (1 << NAK_OUT_PACKETS)) == 0) {\r\ndev_dbg(ep->dev->dev, "%s %s %02x !NAK\n",\r\nep->ep.name, where, tmp);\r\nnet2272_ep_write(ep, EP_RSPSET, 1 << ALT_NAK_OUT_PACKETS);\r\n}\r\n}\r\nstatic void stop_out_naking(struct net2272_ep *ep)\r\n{\r\nu8 tmp = net2272_ep_read(ep, EP_STAT0);\r\nif ((tmp & (1 << NAK_OUT_PACKETS)) != 0)\r\nnet2272_ep_write(ep, EP_RSPCLR, 1 << ALT_NAK_OUT_PACKETS);\r\n}\r\nstatic char *type_string(u8 bmAttributes)\r\n{\r\nswitch ((bmAttributes) & USB_ENDPOINT_XFERTYPE_MASK) {\r\ncase USB_ENDPOINT_XFER_BULK: return "bulk";\r\ncase USB_ENDPOINT_XFER_ISOC: return "iso";\r\ncase USB_ENDPOINT_XFER_INT: return "intr";\r\ndefault: return "control";\r\n}\r\n}\r\nstatic char *buf_state_string(unsigned state)\r\n{\r\nswitch (state) {\r\ncase BUFF_FREE: return "free";\r\ncase BUFF_VALID: return "valid";\r\ncase BUFF_LCL: return "local";\r\ncase BUFF_USB: return "usb";\r\ndefault: return "unknown";\r\n}\r\n}\r\nstatic char *dma_mode_string(void)\r\n{\r\nif (!use_dma)\r\nreturn "PIO";\r\nswitch (dma_mode) {\r\ncase 0: return "SLOW DREQ";\r\ncase 1: return "FAST DREQ";\r\ncase 2: return "BURST";\r\ndefault: return "invalid";\r\n}\r\n}\r\nstatic int\r\nnet2272_enable(struct usb_ep *_ep, const struct usb_endpoint_descriptor *desc)\r\n{\r\nstruct net2272 *dev;\r\nstruct net2272_ep *ep;\r\nu32 max;\r\nu8 tmp;\r\nunsigned long flags;\r\nep = container_of(_ep, struct net2272_ep, ep);\r\nif (!_ep || !desc || ep->desc || _ep->name == ep0name\r\n|| desc->bDescriptorType != USB_DT_ENDPOINT)\r\nreturn -EINVAL;\r\ndev = ep->dev;\r\nif (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN)\r\nreturn -ESHUTDOWN;\r\nmax = usb_endpoint_maxp(desc) & 0x1fff;\r\nspin_lock_irqsave(&dev->lock, flags);\r\n_ep->maxpacket = max & 0x7fff;\r\nep->desc = desc;\r\nep->stopped = 0;\r\nep->wedged = 0;\r\nnet2272_ep_write(ep, EP_MAXPKT0, max & 0xff);\r\nnet2272_ep_write(ep, EP_MAXPKT1, (max & 0xff00) >> 8);\r\nnet2272_ep_write(ep, EP_STAT1, 1 << BUFFER_FLUSH);\r\ntmp = usb_endpoint_type(desc);\r\nif (usb_endpoint_xfer_bulk(desc)) {\r\nif ((dev->gadget.speed == USB_SPEED_HIGH && max != 512) ||\r\n(dev->gadget.speed == USB_SPEED_FULL && max > 64)) {\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn -ERANGE;\r\n}\r\n}\r\nep->is_iso = usb_endpoint_xfer_isoc(desc) ? 1 : 0;\r\ntmp <<= ENDPOINT_TYPE;\r\ntmp |= ((desc->bEndpointAddress & 0x0f) << ENDPOINT_NUMBER);\r\ntmp |= usb_endpoint_dir_in(desc) << ENDPOINT_DIRECTION;\r\ntmp |= (1 << ENDPOINT_ENABLE);\r\nep->is_in = usb_endpoint_dir_in(desc);\r\nif (!ep->is_in)\r\nnet2272_ep_write(ep, EP_RSPSET, 1 << ALT_NAK_OUT_PACKETS);\r\nnet2272_ep_write(ep, EP_CFG, tmp);\r\ntmp = (1 << ep->num) | net2272_read(dev, IRQENB0);\r\nnet2272_write(dev, IRQENB0, tmp);\r\ntmp = (1 << DATA_PACKET_RECEIVED_INTERRUPT_ENABLE)\r\n| (1 << DATA_PACKET_TRANSMITTED_INTERRUPT_ENABLE)\r\n| net2272_ep_read(ep, EP_IRQENB);\r\nnet2272_ep_write(ep, EP_IRQENB, tmp);\r\ntmp = desc->bEndpointAddress;\r\ndev_dbg(dev->dev, "enabled %s (ep%d%s-%s) max %04x cfg %02x\n",\r\n_ep->name, tmp & 0x0f, PIPEDIR(tmp),\r\ntype_string(desc->bmAttributes), max,\r\nnet2272_ep_read(ep, EP_CFG));\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void net2272_ep_reset(struct net2272_ep *ep)\r\n{\r\nu8 tmp;\r\nep->desc = NULL;\r\nINIT_LIST_HEAD(&ep->queue);\r\nusb_ep_set_maxpacket_limit(&ep->ep, ~0);\r\nep->ep.ops = &net2272_ep_ops;\r\nnet2272_ep_write(ep, EP_IRQENB, 0);\r\ntmp = (1 << NAK_OUT_PACKETS_MODE) | (1 << ALT_NAK_OUT_PACKETS);\r\nnet2272_ep_write(ep, EP_RSPSET, tmp);\r\ntmp = (1 << INTERRUPT_MODE) | (1 << HIDE_STATUS_PHASE);\r\nif (ep->num != 0)\r\ntmp |= (1 << ENDPOINT_TOGGLE) | (1 << ENDPOINT_HALT);\r\nnet2272_ep_write(ep, EP_RSPCLR, tmp);\r\nnet2272_ep_write(ep, EP_STAT0,\r\n(1 << DATA_IN_TOKEN_INTERRUPT)\r\n| (1 << DATA_OUT_TOKEN_INTERRUPT)\r\n| (1 << DATA_PACKET_TRANSMITTED_INTERRUPT)\r\n| (1 << DATA_PACKET_RECEIVED_INTERRUPT)\r\n| (1 << SHORT_PACKET_TRANSFERRED_INTERRUPT));\r\nnet2272_ep_write(ep, EP_STAT1,\r\n(1 << TIMEOUT)\r\n| (1 << USB_OUT_ACK_SENT)\r\n| (1 << USB_OUT_NAK_SENT)\r\n| (1 << USB_IN_ACK_RCVD)\r\n| (1 << USB_IN_NAK_SENT)\r\n| (1 << USB_STALL_SENT)\r\n| (1 << LOCAL_OUT_ZLP)\r\n| (1 << BUFFER_FLUSH));\r\n}\r\nstatic int net2272_disable(struct usb_ep *_ep)\r\n{\r\nstruct net2272_ep *ep;\r\nunsigned long flags;\r\nep = container_of(_ep, struct net2272_ep, ep);\r\nif (!_ep || !ep->desc || _ep->name == ep0name)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&ep->dev->lock, flags);\r\nnet2272_dequeue_all(ep);\r\nnet2272_ep_reset(ep);\r\ndev_vdbg(ep->dev->dev, "disabled %s\n", _ep->name);\r\nspin_unlock_irqrestore(&ep->dev->lock, flags);\r\nreturn 0;\r\n}\r\nstatic struct usb_request *\r\nnet2272_alloc_request(struct usb_ep *_ep, gfp_t gfp_flags)\r\n{\r\nstruct net2272_ep *ep;\r\nstruct net2272_request *req;\r\nif (!_ep)\r\nreturn NULL;\r\nep = container_of(_ep, struct net2272_ep, ep);\r\nreq = kzalloc(sizeof(*req), gfp_flags);\r\nif (!req)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&req->queue);\r\nreturn &req->req;\r\n}\r\nstatic void\r\nnet2272_free_request(struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\nstruct net2272_ep *ep;\r\nstruct net2272_request *req;\r\nep = container_of(_ep, struct net2272_ep, ep);\r\nif (!_ep || !_req)\r\nreturn;\r\nreq = container_of(_req, struct net2272_request, req);\r\nWARN_ON(!list_empty(&req->queue));\r\nkfree(req);\r\n}\r\nstatic void\r\nnet2272_done(struct net2272_ep *ep, struct net2272_request *req, int status)\r\n{\r\nstruct net2272 *dev;\r\nunsigned stopped = ep->stopped;\r\nif (ep->num == 0) {\r\nif (ep->dev->protocol_stall) {\r\nep->stopped = 1;\r\nset_halt(ep);\r\n}\r\nallow_status(ep);\r\n}\r\nlist_del_init(&req->queue);\r\nif (req->req.status == -EINPROGRESS)\r\nreq->req.status = status;\r\nelse\r\nstatus = req->req.status;\r\ndev = ep->dev;\r\nif (use_dma && ep->dma)\r\nusb_gadget_unmap_request(&dev->gadget, &req->req,\r\nep->is_in);\r\nif (status && status != -ESHUTDOWN)\r\ndev_vdbg(dev->dev, "complete %s req %p stat %d len %u/%u buf %p\n",\r\nep->ep.name, &req->req, status,\r\nreq->req.actual, req->req.length, req->req.buf);\r\nep->stopped = 1;\r\nspin_unlock(&dev->lock);\r\nusb_gadget_giveback_request(&ep->ep, &req->req);\r\nspin_lock(&dev->lock);\r\nep->stopped = stopped;\r\n}\r\nstatic int\r\nnet2272_write_packet(struct net2272_ep *ep, u8 *buf,\r\nstruct net2272_request *req, unsigned max)\r\n{\r\nu16 __iomem *ep_data = net2272_reg_addr(ep->dev, EP_DATA);\r\nu16 *bufp;\r\nunsigned length, count;\r\nu8 tmp;\r\nlength = min(req->req.length - req->req.actual, max);\r\nreq->req.actual += length;\r\ndev_vdbg(ep->dev->dev, "write packet %s req %p max %u len %u avail %u\n",\r\nep->ep.name, req, max, length,\r\n(net2272_ep_read(ep, EP_AVAIL1) << 8) | net2272_ep_read(ep, EP_AVAIL0));\r\ncount = length;\r\nbufp = (u16 *)buf;\r\nwhile (likely(count >= 2)) {\r\nwritew(*bufp++, ep_data);\r\ncount -= 2;\r\n}\r\nbuf = (u8 *)bufp;\r\nif (unlikely(count)) {\r\ntmp = net2272_read(ep->dev, LOCCTL);\r\nnet2272_write(ep->dev, LOCCTL, tmp & ~(1 << DATA_WIDTH));\r\nwriteb(*buf, ep_data);\r\nnet2272_write(ep->dev, LOCCTL, tmp);\r\n}\r\nreturn length;\r\n}\r\nstatic int\r\nnet2272_write_fifo(struct net2272_ep *ep, struct net2272_request *req)\r\n{\r\nu8 *buf;\r\nunsigned count, max;\r\nint status;\r\ndev_vdbg(ep->dev->dev, "write_fifo %s actual %d len %d\n",\r\nep->ep.name, req->req.actual, req->req.length);\r\ntop:\r\nnet2272_ep_write(ep, EP_STAT0, (1 << DATA_PACKET_TRANSMITTED_INTERRUPT));\r\nwhile (!(net2272_ep_read(ep, EP_STAT0) & (1 << BUFFER_FULL))) {\r\nbuf = req->req.buf + req->req.actual;\r\nprefetch(buf);\r\nnet2272_ep_read(ep, EP_STAT0);\r\nmax = (net2272_ep_read(ep, EP_AVAIL1) << 8) |\r\n(net2272_ep_read(ep, EP_AVAIL0));\r\nif (max < ep->ep.maxpacket)\r\nmax = (net2272_ep_read(ep, EP_AVAIL1) << 8)\r\n| (net2272_ep_read(ep, EP_AVAIL0));\r\ncount = net2272_write_packet(ep, buf, req, max);\r\nif (req->req.length == req->req.actual) {\r\nif (count < ep->ep.maxpacket)\r\nset_fifo_bytecount(ep, 0);\r\nnet2272_done(ep, req, 0);\r\nif (!list_empty(&ep->queue)) {\r\nreq = list_entry(ep->queue.next,\r\nstruct net2272_request,\r\nqueue);\r\nstatus = net2272_kick_dma(ep, req);\r\nif (status < 0)\r\nif ((net2272_ep_read(ep, EP_STAT0)\r\n& (1 << BUFFER_EMPTY)))\r\ngoto top;\r\n}\r\nreturn 1;\r\n}\r\nnet2272_ep_write(ep, EP_STAT0, (1 << DATA_PACKET_TRANSMITTED_INTERRUPT));\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nnet2272_out_flush(struct net2272_ep *ep)\r\n{\r\nASSERT_OUT_NAKING(ep);\r\nnet2272_ep_write(ep, EP_STAT0, (1 << DATA_OUT_TOKEN_INTERRUPT)\r\n| (1 << DATA_PACKET_RECEIVED_INTERRUPT));\r\nnet2272_ep_write(ep, EP_STAT1, 1 << BUFFER_FLUSH);\r\n}\r\nstatic int\r\nnet2272_read_packet(struct net2272_ep *ep, u8 *buf,\r\nstruct net2272_request *req, unsigned avail)\r\n{\r\nu16 __iomem *ep_data = net2272_reg_addr(ep->dev, EP_DATA);\r\nunsigned is_short;\r\nu16 *bufp;\r\nreq->req.actual += avail;\r\ndev_vdbg(ep->dev->dev, "read packet %s req %p len %u avail %u\n",\r\nep->ep.name, req, avail,\r\n(net2272_ep_read(ep, EP_AVAIL1) << 8) | net2272_ep_read(ep, EP_AVAIL0));\r\nis_short = (avail < ep->ep.maxpacket);\r\nif (unlikely(avail == 0)) {\r\n(void)readw(ep_data);\r\nreturn is_short;\r\n}\r\nif (unlikely(avail % 2))\r\navail++;\r\nbufp = (u16 *)buf;\r\ndo {\r\n*bufp++ = readw(ep_data);\r\navail -= 2;\r\n} while (avail);\r\nif (net2272_ep_read(ep, EP_STAT0) & (1 << SHORT_PACKET_TRANSFERRED_INTERRUPT))\r\nnet2272_ep_read(ep, EP_STAT0);\r\nreturn is_short;\r\n}\r\nstatic int\r\nnet2272_read_fifo(struct net2272_ep *ep, struct net2272_request *req)\r\n{\r\nu8 *buf;\r\nunsigned is_short;\r\nint count;\r\nint tmp;\r\nint cleanup = 0;\r\nint status = -1;\r\ndev_vdbg(ep->dev->dev, "read_fifo %s actual %d len %d\n",\r\nep->ep.name, req->req.actual, req->req.length);\r\ntop:\r\ndo {\r\nbuf = req->req.buf + req->req.actual;\r\nprefetchw(buf);\r\ncount = (net2272_ep_read(ep, EP_AVAIL1) << 8)\r\n| net2272_ep_read(ep, EP_AVAIL0);\r\nnet2272_ep_write(ep, EP_STAT0,\r\n(1 << SHORT_PACKET_TRANSFERRED_INTERRUPT) |\r\n(1 << DATA_PACKET_RECEIVED_INTERRUPT));\r\ntmp = req->req.length - req->req.actual;\r\nif (count > tmp) {\r\nif ((tmp % ep->ep.maxpacket) != 0) {\r\ndev_err(ep->dev->dev,\r\n"%s out fifo %d bytes, expected %d\n",\r\nep->ep.name, count, tmp);\r\ncleanup = 1;\r\n}\r\ncount = (tmp > 0) ? tmp : 0;\r\n}\r\nis_short = net2272_read_packet(ep, buf, req, count);\r\nif (unlikely(cleanup || is_short ||\r\n((req->req.actual == req->req.length)\r\n&& !req->req.zero))) {\r\nif (cleanup) {\r\nnet2272_out_flush(ep);\r\nnet2272_done(ep, req, -EOVERFLOW);\r\n} else\r\nnet2272_done(ep, req, 0);\r\nif (unlikely(ep->num == 0)) {\r\nnet2272_ep_write(ep, EP_TRANSFER2, 0);\r\nnet2272_ep_write(ep, EP_TRANSFER1, 0);\r\nnet2272_ep_write(ep, EP_TRANSFER0, 0);\r\n}\r\nif (!list_empty(&ep->queue)) {\r\nreq = list_entry(ep->queue.next,\r\nstruct net2272_request, queue);\r\nstatus = net2272_kick_dma(ep, req);\r\nif ((status < 0) &&\r\n!(net2272_ep_read(ep, EP_STAT0) & (1 << BUFFER_EMPTY)))\r\ngoto top;\r\n}\r\nreturn 1;\r\n}\r\n} while (!(net2272_ep_read(ep, EP_STAT0) & (1 << BUFFER_EMPTY)));\r\nreturn 0;\r\n}\r\nstatic void\r\nnet2272_pio_advance(struct net2272_ep *ep)\r\n{\r\nstruct net2272_request *req;\r\nif (unlikely(list_empty(&ep->queue)))\r\nreturn;\r\nreq = list_entry(ep->queue.next, struct net2272_request, queue);\r\n(ep->is_in ? net2272_write_fifo : net2272_read_fifo)(ep, req);\r\n}\r\nstatic int\r\nnet2272_request_dma(struct net2272 *dev, unsigned ep, u32 buf,\r\nunsigned len, unsigned dir)\r\n{\r\ndev_vdbg(dev->dev, "request_dma ep %d buf %08x len %d dir %d\n",\r\nep, buf, len, dir);\r\nif (dev->dma_busy)\r\nreturn -EBUSY;\r\nif ((dir == 1) && (len > 0x1000000))\r\nreturn -EINVAL;\r\ndev->dma_busy = 1;\r\n#ifdef CONFIG_PCI\r\nswitch (dev->dev_id) {\r\ncase PCI_DEVICE_ID_RDK1:\r\nwritel((1 << LOCAL_BUS_WIDTH) |\r\n(1 << TA_READY_INPUT_ENABLE) |\r\n(0 << LOCAL_BURST_ENABLE) |\r\n(1 << DONE_INTERRUPT_ENABLE) |\r\n(1 << LOCAL_ADDRESSING_MODE) |\r\n(1 << DEMAND_MODE) |\r\n(1 << DMA_EOT_ENABLE) |\r\n(1 << FAST_SLOW_TERMINATE_MODE_SELECT) |\r\n(1 << DMA_CHANNEL_INTERRUPT_SELECT),\r\ndev->rdk1.plx9054_base_addr + DMAMODE0);\r\nwritel(0x100000, dev->rdk1.plx9054_base_addr + DMALADR0);\r\nwritel(buf, dev->rdk1.plx9054_base_addr + DMAPADR0);\r\nwritel(len, dev->rdk1.plx9054_base_addr + DMASIZ0);\r\nwritel((dir << DIRECTION_OF_TRANSFER) |\r\n(1 << INTERRUPT_AFTER_TERMINAL_COUNT),\r\ndev->rdk1.plx9054_base_addr + DMADPR0);\r\nwritel((1 << LOCAL_DMA_CHANNEL_0_INTERRUPT_ENABLE) |\r\nreadl(dev->rdk1.plx9054_base_addr + INTCSR),\r\ndev->rdk1.plx9054_base_addr + INTCSR);\r\nbreak;\r\n}\r\n#endif\r\nnet2272_write(dev, DMAREQ,\r\n(0 << DMA_BUFFER_VALID) |\r\n(1 << DMA_REQUEST_ENABLE) |\r\n(1 << DMA_CONTROL_DACK) |\r\n(dev->dma_eot_polarity << EOT_POLARITY) |\r\n(dev->dma_dack_polarity << DACK_POLARITY) |\r\n(dev->dma_dreq_polarity << DREQ_POLARITY) |\r\n((ep >> 1) << DMA_ENDPOINT_SELECT));\r\n(void) net2272_read(dev, SCRATCH);\r\nreturn 0;\r\n}\r\nstatic void\r\nnet2272_start_dma(struct net2272 *dev)\r\n{\r\n#ifdef CONFIG_PCI\r\nswitch (dev->dev_id) {\r\ncase PCI_DEVICE_ID_RDK1:\r\nwriteb((1 << CHANNEL_ENABLE) | (1 << CHANNEL_START),\r\ndev->rdk1.plx9054_base_addr + DMACSR0);\r\nbreak;\r\n}\r\n#endif\r\n}\r\nstatic int\r\nnet2272_kick_dma(struct net2272_ep *ep, struct net2272_request *req)\r\n{\r\nunsigned size;\r\nu8 tmp;\r\nif (!use_dma || (ep->num < 1) || (ep->num > 2) || !ep->dma)\r\nreturn -EINVAL;\r\nif (req->req.length & 1)\r\nreturn -EINVAL;\r\ndev_vdbg(ep->dev->dev, "kick_dma %s req %p dma %08llx\n",\r\nep->ep.name, req, (unsigned long long) req->req.dma);\r\nnet2272_ep_write(ep, EP_RSPSET, 1 << ALT_NAK_OUT_PACKETS);\r\nif (ep->dev->dma_busy)\r\nreturn -EBUSY;\r\nsize = req->req.length;\r\nsize &= ~1;\r\nif (ep->is_in) {\r\nif (net2272_request_dma(ep->dev, ep->num, req->req.dma, size, 0))\r\nreturn -EBUSY;\r\nreq->req.actual += size;\r\n} else {\r\ntmp = net2272_ep_read(ep, EP_STAT0);\r\nif (net2272_request_dma(ep->dev, ep->num, req->req.dma, size, 1))\r\nreturn -EBUSY;\r\nif (!(tmp & (1 << BUFFER_EMPTY)))\r\nep->not_empty = 1;\r\nelse\r\nep->not_empty = 0;\r\nnet2272_ep_write(ep, EP_RSPCLR, 1 << ALT_NAK_OUT_PACKETS);\r\nif (tmp & (1 << SHORT_PACKET_TRANSFERRED_INTERRUPT)) {\r\nnet2272_write(ep->dev, DMAREQ,\r\n(0 << DMA_BUFFER_VALID) |\r\n(0 << DMA_REQUEST_ENABLE) |\r\n(1 << DMA_CONTROL_DACK) |\r\n(ep->dev->dma_eot_polarity << EOT_POLARITY) |\r\n(ep->dev->dma_dack_polarity << DACK_POLARITY) |\r\n(ep->dev->dma_dreq_polarity << DREQ_POLARITY) |\r\n((ep->num >> 1) << DMA_ENDPOINT_SELECT));\r\nreturn -EBUSY;\r\n}\r\n}\r\nnet2272_ep_write(ep, EP_IRQENB, 0);\r\nnet2272_start_dma(ep->dev);\r\nreturn 0;\r\n}\r\nstatic void net2272_cancel_dma(struct net2272 *dev)\r\n{\r\n#ifdef CONFIG_PCI\r\nswitch (dev->dev_id) {\r\ncase PCI_DEVICE_ID_RDK1:\r\nwriteb(0, dev->rdk1.plx9054_base_addr + DMACSR0);\r\nwriteb(1 << CHANNEL_ABORT, dev->rdk1.plx9054_base_addr + DMACSR0);\r\nwhile (!(readb(dev->rdk1.plx9054_base_addr + DMACSR0) &\r\n(1 << CHANNEL_DONE)))\r\ncontinue;\r\nwriteb(1 << CHANNEL_CLEAR_INTERRUPT,\r\ndev->rdk1.plx9054_base_addr + DMACSR0);\r\nbreak;\r\n}\r\n#endif\r\ndev->dma_busy = 0;\r\n}\r\nstatic int\r\nnet2272_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)\r\n{\r\nstruct net2272_request *req;\r\nstruct net2272_ep *ep;\r\nstruct net2272 *dev;\r\nunsigned long flags;\r\nint status = -1;\r\nu8 s;\r\nreq = container_of(_req, struct net2272_request, req);\r\nif (!_req || !_req->complete || !_req->buf\r\n|| !list_empty(&req->queue))\r\nreturn -EINVAL;\r\nep = container_of(_ep, struct net2272_ep, ep);\r\nif (!_ep || (!ep->desc && ep->num != 0))\r\nreturn -EINVAL;\r\ndev = ep->dev;\r\nif (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN)\r\nreturn -ESHUTDOWN;\r\nif (use_dma && ep->dma) {\r\nstatus = usb_gadget_map_request(&dev->gadget, _req,\r\nep->is_in);\r\nif (status)\r\nreturn status;\r\n}\r\ndev_vdbg(dev->dev, "%s queue req %p, len %d buf %p dma %08llx %s\n",\r\n_ep->name, _req, _req->length, _req->buf,\r\n(unsigned long long) _req->dma, _req->zero ? "zero" : "!zero");\r\nspin_lock_irqsave(&dev->lock, flags);\r\n_req->status = -EINPROGRESS;\r\n_req->actual = 0;\r\nif (list_empty(&ep->queue) && !ep->stopped) {\r\nif (ep->num == 0 && _req->length == 0) {\r\nnet2272_done(ep, req, 0);\r\ndev_vdbg(dev->dev, "%s status ack\n", ep->ep.name);\r\ngoto done;\r\n}\r\ns = net2272_ep_read(ep, EP_STAT0);\r\nif (s & (1 << BUFFER_EMPTY)) {\r\nif ((s & (1 << NAK_OUT_PACKETS)) &&\r\nnet2272_ep_read(ep, EP_STAT1) & (1 << LOCAL_OUT_ZLP)) {\r\ndev_dbg(dev->dev, "WARNING: returning ZLP short packet termination!\n");\r\nstatus = net2272_read_fifo(ep, req);\r\nnet2272_ep_write(ep, EP_STAT0, (1 << NAK_OUT_PACKETS));\r\ngoto done;\r\n}\r\n}\r\nstatus = net2272_kick_dma(ep, req);\r\nif (status < 0) {\r\nstatus = 0;\r\nif (ep->is_in)\r\nstatus = net2272_write_fifo(ep, req);\r\nelse {\r\ns = net2272_ep_read(ep, EP_STAT0);\r\nif ((s & (1 << BUFFER_EMPTY)) == 0)\r\nstatus = net2272_read_fifo(ep, req);\r\n}\r\nif (unlikely(status != 0)) {\r\nif (status > 0)\r\nstatus = 0;\r\nreq = NULL;\r\n}\r\n}\r\n}\r\nif (likely(req))\r\nlist_add_tail(&req->queue, &ep->queue);\r\nif (likely(!list_empty(&ep->queue)))\r\nnet2272_ep_write(ep, EP_RSPCLR, 1 << ALT_NAK_OUT_PACKETS);\r\ndone:\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void\r\nnet2272_dequeue_all(struct net2272_ep *ep)\r\n{\r\nstruct net2272_request *req;\r\nep->stopped = 1;\r\nwhile (!list_empty(&ep->queue)) {\r\nreq = list_entry(ep->queue.next,\r\nstruct net2272_request,\r\nqueue);\r\nnet2272_done(ep, req, -ESHUTDOWN);\r\n}\r\n}\r\nstatic int\r\nnet2272_dequeue(struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\nstruct net2272_ep *ep;\r\nstruct net2272_request *req;\r\nunsigned long flags;\r\nint stopped;\r\nep = container_of(_ep, struct net2272_ep, ep);\r\nif (!_ep || (!ep->desc && ep->num != 0) || !_req)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&ep->dev->lock, flags);\r\nstopped = ep->stopped;\r\nep->stopped = 1;\r\nlist_for_each_entry(req, &ep->queue, queue) {\r\nif (&req->req == _req)\r\nbreak;\r\n}\r\nif (&req->req != _req) {\r\nspin_unlock_irqrestore(&ep->dev->lock, flags);\r\nreturn -EINVAL;\r\n}\r\nif (ep->queue.next == &req->queue) {\r\ndev_dbg(ep->dev->dev, "unlink (%s) pio\n", _ep->name);\r\nnet2272_done(ep, req, -ECONNRESET);\r\n}\r\nreq = NULL;\r\nep->stopped = stopped;\r\nspin_unlock_irqrestore(&ep->dev->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int\r\nnet2272_set_halt_and_wedge(struct usb_ep *_ep, int value, int wedged)\r\n{\r\nstruct net2272_ep *ep;\r\nunsigned long flags;\r\nint ret = 0;\r\nep = container_of(_ep, struct net2272_ep, ep);\r\nif (!_ep || (!ep->desc && ep->num != 0))\r\nreturn -EINVAL;\r\nif (!ep->dev->driver || ep->dev->gadget.speed == USB_SPEED_UNKNOWN)\r\nreturn -ESHUTDOWN;\r\nif (ep->desc && usb_endpoint_xfer_isoc(ep->desc))\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&ep->dev->lock, flags);\r\nif (!list_empty(&ep->queue))\r\nret = -EAGAIN;\r\nelse if (ep->is_in && value && net2272_fifo_status(_ep) != 0)\r\nret = -EAGAIN;\r\nelse {\r\ndev_vdbg(ep->dev->dev, "%s %s %s\n", _ep->name,\r\nvalue ? "set" : "clear",\r\nwedged ? "wedge" : "halt");\r\nif (value) {\r\nif (ep->num == 0)\r\nep->dev->protocol_stall = 1;\r\nelse\r\nset_halt(ep);\r\nif (wedged)\r\nep->wedged = 1;\r\n} else {\r\nclear_halt(ep);\r\nep->wedged = 0;\r\n}\r\n}\r\nspin_unlock_irqrestore(&ep->dev->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int\r\nnet2272_set_halt(struct usb_ep *_ep, int value)\r\n{\r\nreturn net2272_set_halt_and_wedge(_ep, value, 0);\r\n}\r\nstatic int\r\nnet2272_set_wedge(struct usb_ep *_ep)\r\n{\r\nif (!_ep || _ep->name == ep0name)\r\nreturn -EINVAL;\r\nreturn net2272_set_halt_and_wedge(_ep, 1, 1);\r\n}\r\nstatic int\r\nnet2272_fifo_status(struct usb_ep *_ep)\r\n{\r\nstruct net2272_ep *ep;\r\nu16 avail;\r\nep = container_of(_ep, struct net2272_ep, ep);\r\nif (!_ep || (!ep->desc && ep->num != 0))\r\nreturn -ENODEV;\r\nif (!ep->dev->driver || ep->dev->gadget.speed == USB_SPEED_UNKNOWN)\r\nreturn -ESHUTDOWN;\r\navail = net2272_ep_read(ep, EP_AVAIL1) << 8;\r\navail |= net2272_ep_read(ep, EP_AVAIL0);\r\nif (avail > ep->fifo_size)\r\nreturn -EOVERFLOW;\r\nif (ep->is_in)\r\navail = ep->fifo_size - avail;\r\nreturn avail;\r\n}\r\nstatic void\r\nnet2272_fifo_flush(struct usb_ep *_ep)\r\n{\r\nstruct net2272_ep *ep;\r\nep = container_of(_ep, struct net2272_ep, ep);\r\nif (!_ep || (!ep->desc && ep->num != 0))\r\nreturn;\r\nif (!ep->dev->driver || ep->dev->gadget.speed == USB_SPEED_UNKNOWN)\r\nreturn;\r\nnet2272_ep_write(ep, EP_STAT1, 1 << BUFFER_FLUSH);\r\n}\r\nstatic int\r\nnet2272_get_frame(struct usb_gadget *_gadget)\r\n{\r\nstruct net2272 *dev;\r\nunsigned long flags;\r\nu16 ret;\r\nif (!_gadget)\r\nreturn -ENODEV;\r\ndev = container_of(_gadget, struct net2272, gadget);\r\nspin_lock_irqsave(&dev->lock, flags);\r\nret = net2272_read(dev, FRAME1) << 8;\r\nret |= net2272_read(dev, FRAME0);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int\r\nnet2272_wakeup(struct usb_gadget *_gadget)\r\n{\r\nstruct net2272 *dev;\r\nu8 tmp;\r\nunsigned long flags;\r\nif (!_gadget)\r\nreturn 0;\r\ndev = container_of(_gadget, struct net2272, gadget);\r\nspin_lock_irqsave(&dev->lock, flags);\r\ntmp = net2272_read(dev, USBCTL0);\r\nif (tmp & (1 << IO_WAKEUP_ENABLE))\r\nnet2272_write(dev, USBCTL1, (1 << GENERATE_RESUME));\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int\r\nnet2272_set_selfpowered(struct usb_gadget *_gadget, int value)\r\n{\r\nif (!_gadget)\r\nreturn -ENODEV;\r\n_gadget->is_selfpowered = (value != 0);\r\nreturn 0;\r\n}\r\nstatic int\r\nnet2272_pullup(struct usb_gadget *_gadget, int is_on)\r\n{\r\nstruct net2272 *dev;\r\nu8 tmp;\r\nunsigned long flags;\r\nif (!_gadget)\r\nreturn -ENODEV;\r\ndev = container_of(_gadget, struct net2272, gadget);\r\nspin_lock_irqsave(&dev->lock, flags);\r\ntmp = net2272_read(dev, USBCTL0);\r\ndev->softconnect = (is_on != 0);\r\nif (is_on)\r\ntmp |= (1 << USB_DETECT_ENABLE);\r\nelse\r\ntmp &= ~(1 << USB_DETECT_ENABLE);\r\nnet2272_write(dev, USBCTL0, tmp);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nregisters_show(struct device *_dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct net2272 *dev;\r\nchar *next;\r\nunsigned size, t;\r\nunsigned long flags;\r\nu8 t1, t2;\r\nint i;\r\nconst char *s;\r\ndev = dev_get_drvdata(_dev);\r\nnext = buf;\r\nsize = PAGE_SIZE;\r\nspin_lock_irqsave(&dev->lock, flags);\r\nif (dev->driver)\r\ns = dev->driver->driver.name;\r\nelse\r\ns = "(none)";\r\nt = scnprintf(next, size, "%s version %s,"\r\n"chiprev %02x, locctl %02x\n"\r\n"irqenb0 %02x irqenb1 %02x "\r\n"irqstat0 %02x irqstat1 %02x\n",\r\ndriver_name, driver_vers, dev->chiprev,\r\nnet2272_read(dev, LOCCTL),\r\nnet2272_read(dev, IRQENB0),\r\nnet2272_read(dev, IRQENB1),\r\nnet2272_read(dev, IRQSTAT0),\r\nnet2272_read(dev, IRQSTAT1));\r\nsize -= t;\r\nnext += t;\r\nt1 = net2272_read(dev, DMAREQ);\r\nt = scnprintf(next, size, "\ndmareq %02x: %s %s%s%s%s\n",\r\nt1, ep_name[(t1 & 0x01) + 1],\r\nt1 & (1 << DMA_CONTROL_DACK) ? "dack " : "",\r\nt1 & (1 << DMA_REQUEST_ENABLE) ? "reqenb " : "",\r\nt1 & (1 << DMA_REQUEST) ? "req " : "",\r\nt1 & (1 << DMA_BUFFER_VALID) ? "valid " : "");\r\nsize -= t;\r\nnext += t;\r\nt1 = net2272_read(dev, USBCTL1);\r\nif (t1 & (1 << VBUS_PIN)) {\r\nif (t1 & (1 << USB_HIGH_SPEED))\r\ns = "high speed";\r\nelse if (dev->gadget.speed == USB_SPEED_UNKNOWN)\r\ns = "powered";\r\nelse\r\ns = "full speed";\r\n} else\r\ns = "not attached";\r\nt = scnprintf(next, size,\r\n"usbctl0 %02x usbctl1 %02x addr 0x%02x (%s)\n",\r\nnet2272_read(dev, USBCTL0), t1,\r\nnet2272_read(dev, OURADDR), s);\r\nsize -= t;\r\nnext += t;\r\nfor (i = 0; i < 4; ++i) {\r\nstruct net2272_ep *ep;\r\nep = &dev->ep[i];\r\nif (i && !ep->desc)\r\ncontinue;\r\nt1 = net2272_ep_read(ep, EP_CFG);\r\nt2 = net2272_ep_read(ep, EP_RSPSET);\r\nt = scnprintf(next, size,\r\n"\n%s\tcfg %02x rsp (%02x) %s%s%s%s%s%s%s%s"\r\n"irqenb %02x\n",\r\nep->ep.name, t1, t2,\r\n(t2 & (1 << ALT_NAK_OUT_PACKETS)) ? "NAK " : "",\r\n(t2 & (1 << HIDE_STATUS_PHASE)) ? "hide " : "",\r\n(t2 & (1 << AUTOVALIDATE)) ? "auto " : "",\r\n(t2 & (1 << INTERRUPT_MODE)) ? "interrupt " : "",\r\n(t2 & (1 << CONTROL_STATUS_PHASE_HANDSHAKE)) ? "status " : "",\r\n(t2 & (1 << NAK_OUT_PACKETS_MODE)) ? "NAKmode " : "",\r\n(t2 & (1 << ENDPOINT_TOGGLE)) ? "DATA1 " : "DATA0 ",\r\n(t2 & (1 << ENDPOINT_HALT)) ? "HALT " : "",\r\nnet2272_ep_read(ep, EP_IRQENB));\r\nsize -= t;\r\nnext += t;\r\nt = scnprintf(next, size,\r\n"\tstat0 %02x stat1 %02x avail %04x "\r\n"(ep%d%s-%s)%s\n",\r\nnet2272_ep_read(ep, EP_STAT0),\r\nnet2272_ep_read(ep, EP_STAT1),\r\n(net2272_ep_read(ep, EP_AVAIL1) << 8) | net2272_ep_read(ep, EP_AVAIL0),\r\nt1 & 0x0f,\r\nep->is_in ? "in" : "out",\r\ntype_string(t1 >> 5),\r\nep->stopped ? "*" : "");\r\nsize -= t;\r\nnext += t;\r\nt = scnprintf(next, size,\r\n"\tep_transfer %06x\n",\r\n((net2272_ep_read(ep, EP_TRANSFER2) & 0xff) << 16) |\r\n((net2272_ep_read(ep, EP_TRANSFER1) & 0xff) << 8) |\r\n((net2272_ep_read(ep, EP_TRANSFER0) & 0xff)));\r\nsize -= t;\r\nnext += t;\r\nt1 = net2272_ep_read(ep, EP_BUFF_STATES) & 0x03;\r\nt2 = (net2272_ep_read(ep, EP_BUFF_STATES) >> 2) & 0x03;\r\nt = scnprintf(next, size,\r\n"\tbuf-a %s buf-b %s\n",\r\nbuf_state_string(t1),\r\nbuf_state_string(t2));\r\nsize -= t;\r\nnext += t;\r\n}\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn PAGE_SIZE - size;\r\n}\r\nstatic void\r\nnet2272_set_fifo_mode(struct net2272 *dev, int mode)\r\n{\r\nu8 tmp;\r\ntmp = net2272_read(dev, LOCCTL) & 0x3f;\r\ntmp |= (mode << 6);\r\nnet2272_write(dev, LOCCTL, tmp);\r\nINIT_LIST_HEAD(&dev->gadget.ep_list);\r\nlist_add_tail(&dev->ep[1].ep.ep_list, &dev->gadget.ep_list);\r\nswitch (mode) {\r\ncase 0:\r\nlist_add_tail(&dev->ep[2].ep.ep_list, &dev->gadget.ep_list);\r\ndev->ep[1].fifo_size = dev->ep[2].fifo_size = 512;\r\nbreak;\r\ncase 1:\r\nlist_add_tail(&dev->ep[2].ep.ep_list, &dev->gadget.ep_list);\r\ndev->ep[1].fifo_size = 1024;\r\ndev->ep[2].fifo_size = 512;\r\nbreak;\r\ncase 2:\r\nlist_add_tail(&dev->ep[2].ep.ep_list, &dev->gadget.ep_list);\r\ndev->ep[1].fifo_size = dev->ep[2].fifo_size = 1024;\r\nbreak;\r\ncase 3:\r\ndev->ep[1].fifo_size = 1024;\r\nbreak;\r\n}\r\nlist_add_tail(&dev->ep[3].ep.ep_list, &dev->gadget.ep_list);\r\ndev->ep[3].fifo_size = 512;\r\n}\r\nstatic void\r\nnet2272_usb_reset(struct net2272 *dev)\r\n{\r\ndev->gadget.speed = USB_SPEED_UNKNOWN;\r\nnet2272_cancel_dma(dev);\r\nnet2272_write(dev, IRQENB0, 0);\r\nnet2272_write(dev, IRQENB1, 0);\r\nnet2272_write(dev, IRQSTAT0, 0xff);\r\nnet2272_write(dev, IRQSTAT1, ~(1 << SUSPEND_REQUEST_INTERRUPT));\r\nnet2272_write(dev, DMAREQ,\r\n(0 << DMA_BUFFER_VALID) |\r\n(0 << DMA_REQUEST_ENABLE) |\r\n(1 << DMA_CONTROL_DACK) |\r\n(dev->dma_eot_polarity << EOT_POLARITY) |\r\n(dev->dma_dack_polarity << DACK_POLARITY) |\r\n(dev->dma_dreq_polarity << DREQ_POLARITY) |\r\n((dma_ep >> 1) << DMA_ENDPOINT_SELECT));\r\nnet2272_cancel_dma(dev);\r\nnet2272_set_fifo_mode(dev, (fifo_mode <= 3) ? fifo_mode : 0);\r\nnet2272_write(dev, LOCCTL, net2272_read(dev, LOCCTL) | (1 << DATA_WIDTH));\r\nnet2272_write(dev, LOCCTL1, (dma_mode << DMA_MODE));\r\n}\r\nstatic void\r\nnet2272_usb_reinit(struct net2272 *dev)\r\n{\r\nint i;\r\nfor (i = 0; i < 4; ++i) {\r\nstruct net2272_ep *ep = &dev->ep[i];\r\nep->ep.name = ep_name[i];\r\nep->dev = dev;\r\nep->num = i;\r\nep->not_empty = 0;\r\nif (use_dma && ep->num == dma_ep)\r\nep->dma = 1;\r\nif (i > 0 && i <= 3)\r\nep->fifo_size = 512;\r\nelse\r\nep->fifo_size = 64;\r\nnet2272_ep_reset(ep);\r\n}\r\nusb_ep_set_maxpacket_limit(&dev->ep[0].ep, 64);\r\ndev->gadget.ep0 = &dev->ep[0].ep;\r\ndev->ep[0].stopped = 0;\r\nINIT_LIST_HEAD(&dev->gadget.ep0->ep_list);\r\n}\r\nstatic void\r\nnet2272_ep0_start(struct net2272 *dev)\r\n{\r\nstruct net2272_ep *ep0 = &dev->ep[0];\r\nnet2272_ep_write(ep0, EP_RSPSET,\r\n(1 << NAK_OUT_PACKETS_MODE) |\r\n(1 << ALT_NAK_OUT_PACKETS));\r\nnet2272_ep_write(ep0, EP_RSPCLR,\r\n(1 << HIDE_STATUS_PHASE) |\r\n(1 << CONTROL_STATUS_PHASE_HANDSHAKE));\r\nnet2272_write(dev, USBCTL0,\r\n(dev->softconnect << USB_DETECT_ENABLE) |\r\n(1 << USB_ROOT_PORT_WAKEUP_ENABLE) |\r\n(1 << IO_WAKEUP_ENABLE));\r\nnet2272_write(dev, IRQENB0,\r\n(1 << SETUP_PACKET_INTERRUPT_ENABLE) |\r\n(1 << ENDPOINT_0_INTERRUPT_ENABLE) |\r\n(1 << DMA_DONE_INTERRUPT_ENABLE));\r\nnet2272_write(dev, IRQENB1,\r\n(1 << VBUS_INTERRUPT_ENABLE) |\r\n(1 << ROOT_PORT_RESET_INTERRUPT_ENABLE) |\r\n(1 << SUSPEND_REQUEST_CHANGE_INTERRUPT_ENABLE));\r\n}\r\nstatic int net2272_start(struct usb_gadget *_gadget,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct net2272 *dev;\r\nunsigned i;\r\nif (!driver || !driver->setup ||\r\ndriver->max_speed != USB_SPEED_HIGH)\r\nreturn -EINVAL;\r\ndev = container_of(_gadget, struct net2272, gadget);\r\nfor (i = 0; i < 4; ++i)\r\ndev->ep[i].irqs = 0;\r\ndev->softconnect = 1;\r\ndriver->driver.bus = NULL;\r\ndev->driver = driver;\r\nnet2272_ep0_start(dev);\r\nreturn 0;\r\n}\r\nstatic void\r\nstop_activity(struct net2272 *dev, struct usb_gadget_driver *driver)\r\n{\r\nint i;\r\nif (dev->gadget.speed == USB_SPEED_UNKNOWN)\r\ndriver = NULL;\r\nnet2272_usb_reset(dev);\r\nfor (i = 0; i < 4; ++i)\r\nnet2272_dequeue_all(&dev->ep[i]);\r\nif (driver) {\r\nspin_unlock(&dev->lock);\r\ndriver->disconnect(&dev->gadget);\r\nspin_lock(&dev->lock);\r\n}\r\nnet2272_usb_reinit(dev);\r\n}\r\nstatic int net2272_stop(struct usb_gadget *_gadget)\r\n{\r\nstruct net2272 *dev;\r\nunsigned long flags;\r\ndev = container_of(_gadget, struct net2272, gadget);\r\nspin_lock_irqsave(&dev->lock, flags);\r\nstop_activity(dev, NULL);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\ndev->driver = NULL;\r\nreturn 0;\r\n}\r\nstatic void\r\nnet2272_handle_dma(struct net2272_ep *ep)\r\n{\r\nstruct net2272_request *req;\r\nunsigned len;\r\nint status;\r\nif (!list_empty(&ep->queue))\r\nreq = list_entry(ep->queue.next,\r\nstruct net2272_request, queue);\r\nelse\r\nreq = NULL;\r\ndev_vdbg(ep->dev->dev, "handle_dma %s req %p\n", ep->ep.name, req);\r\nnet2272_write(ep->dev, DMAREQ,\r\n(0 << DMA_BUFFER_VALID)\r\n| (0 << DMA_REQUEST_ENABLE)\r\n| (1 << DMA_CONTROL_DACK)\r\n| (ep->dev->dma_eot_polarity << EOT_POLARITY)\r\n| (ep->dev->dma_dack_polarity << DACK_POLARITY)\r\n| (ep->dev->dma_dreq_polarity << DREQ_POLARITY)\r\n| (ep->dma << DMA_ENDPOINT_SELECT));\r\nep->dev->dma_busy = 0;\r\nnet2272_ep_write(ep, EP_IRQENB,\r\n(1 << DATA_PACKET_RECEIVED_INTERRUPT_ENABLE)\r\n| (1 << DATA_PACKET_TRANSMITTED_INTERRUPT_ENABLE)\r\n| net2272_ep_read(ep, EP_IRQENB));\r\nif (ep->is_in) {\r\nif ((req->req.length % ep->ep.maxpacket != 0) ||\r\nreq->req.zero)\r\nset_fifo_bytecount(ep, 0);\r\nnet2272_done(ep, req, 0);\r\nif (!list_empty(&ep->queue)) {\r\nreq = list_entry(ep->queue.next,\r\nstruct net2272_request, queue);\r\nstatus = net2272_kick_dma(ep, req);\r\nif (status < 0)\r\nnet2272_pio_advance(ep);\r\n}\r\n} else {\r\nif (net2272_read(ep->dev, IRQSTAT0) &\r\n(1 << DMA_DONE_INTERRUPT)) {\r\nnet2272_cancel_dma(ep->dev);\r\n}\r\nlen = (net2272_ep_read(ep, EP_TRANSFER2) << 16)\r\n| (net2272_ep_read(ep, EP_TRANSFER1) << 8)\r\n| (net2272_ep_read(ep, EP_TRANSFER0));\r\nif (ep->not_empty)\r\nlen += 4;\r\nreq->req.actual += len;\r\nnet2272_pio_advance(ep);\r\n}\r\n}\r\nstatic void\r\nnet2272_handle_ep(struct net2272_ep *ep)\r\n{\r\nstruct net2272_request *req;\r\nu8 stat0, stat1;\r\nif (!list_empty(&ep->queue))\r\nreq = list_entry(ep->queue.next,\r\nstruct net2272_request, queue);\r\nelse\r\nreq = NULL;\r\nstat0 = net2272_ep_read(ep, EP_STAT0);\r\nstat1 = net2272_ep_read(ep, EP_STAT1);\r\nep->irqs++;\r\ndev_vdbg(ep->dev->dev, "%s ack ep_stat0 %02x, ep_stat1 %02x, req %p\n",\r\nep->ep.name, stat0, stat1, req ? &req->req : NULL);\r\nnet2272_ep_write(ep, EP_STAT0, stat0 &\r\n~((1 << NAK_OUT_PACKETS)\r\n| (1 << SHORT_PACKET_TRANSFERRED_INTERRUPT)));\r\nnet2272_ep_write(ep, EP_STAT1, stat1);\r\nif (!ep->is_in && (stat0 & (1 << DATA_PACKET_RECEIVED_INTERRUPT)))\r\nnet2272_pio_advance(ep);\r\nelse if (stat0 & (1 << DATA_PACKET_TRANSMITTED_INTERRUPT))\r\nnet2272_pio_advance(ep);\r\n}\r\nstatic struct net2272_ep *\r\nnet2272_get_ep_by_addr(struct net2272 *dev, u16 wIndex)\r\n{\r\nstruct net2272_ep *ep;\r\nif ((wIndex & USB_ENDPOINT_NUMBER_MASK) == 0)\r\nreturn &dev->ep[0];\r\nlist_for_each_entry(ep, &dev->gadget.ep_list, ep.ep_list) {\r\nu8 bEndpointAddress;\r\nif (!ep->desc)\r\ncontinue;\r\nbEndpointAddress = ep->desc->bEndpointAddress;\r\nif ((wIndex ^ bEndpointAddress) & USB_DIR_IN)\r\ncontinue;\r\nif ((wIndex & 0x0f) == (bEndpointAddress & 0x0f))\r\nreturn ep;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void\r\nnet2272_set_test_mode(struct net2272 *dev, int mode)\r\n{\r\nint i;\r\nnet2272_write(dev, IRQENB0, 0x00);\r\nnet2272_write(dev, IRQENB1, 0x00);\r\nnet2272_write(dev, XCVRDIAG, 1 << FORCE_HIGH_SPEED);\r\nnet2272_write(dev, PAGESEL, 0);\r\nnet2272_write(dev, EP_STAT0, 1 << DATA_PACKET_TRANSMITTED_INTERRUPT);\r\nnet2272_write(dev, EP_RSPCLR,\r\n(1 << CONTROL_STATUS_PHASE_HANDSHAKE)\r\n| (1 << HIDE_STATUS_PHASE));\r\nnet2272_write(dev, EP_CFG, 1 << ENDPOINT_DIRECTION);\r\nnet2272_write(dev, EP_STAT1, 1 << BUFFER_FLUSH);\r\nwhile (!(net2272_read(dev, EP_STAT0) &\r\n(1 << DATA_PACKET_TRANSMITTED_INTERRUPT)))\r\n;\r\nnet2272_write(dev, USBTEST, mode);\r\nif (mode == TEST_PACKET) {\r\nnet2272_write(dev, LOCCTL, net2272_read(dev, LOCCTL) &\r\n~(1 << DATA_WIDTH));\r\nfor (i = 0; i < sizeof(net2272_test_packet); ++i)\r\nnet2272_write(dev, EP_DATA, net2272_test_packet[i]);\r\nnet2272_write(dev, EP_TRANSFER0, 0);\r\n}\r\n}\r\nstatic void\r\nnet2272_handle_stat0_irqs(struct net2272 *dev, u8 stat)\r\n{\r\nstruct net2272_ep *ep;\r\nu8 num, scratch;\r\nif (unlikely(stat & (1 << SETUP_PACKET_INTERRUPT))) {\r\nunion {\r\nu8 raw[8];\r\nstruct usb_ctrlrequest r;\r\n} u;\r\nint tmp = 0;\r\nstruct net2272_request *req;\r\nif (dev->gadget.speed == USB_SPEED_UNKNOWN) {\r\nif (net2272_read(dev, USBCTL1) & (1 << USB_HIGH_SPEED))\r\ndev->gadget.speed = USB_SPEED_HIGH;\r\nelse\r\ndev->gadget.speed = USB_SPEED_FULL;\r\ndev_dbg(dev->dev, "%s\n",\r\nusb_speed_string(dev->gadget.speed));\r\n}\r\nep = &dev->ep[0];\r\nep->irqs++;\r\nstat &= ~(1 << ENDPOINT_0_INTERRUPT);\r\nwhile (!list_empty(&ep->queue)) {\r\nreq = list_entry(ep->queue.next,\r\nstruct net2272_request, queue);\r\nnet2272_done(ep, req,\r\n(req->req.actual == req->req.length) ? 0 : -EPROTO);\r\n}\r\nep->stopped = 0;\r\ndev->protocol_stall = 0;\r\nnet2272_ep_write(ep, EP_STAT0,\r\n(1 << DATA_IN_TOKEN_INTERRUPT)\r\n| (1 << DATA_OUT_TOKEN_INTERRUPT)\r\n| (1 << DATA_PACKET_TRANSMITTED_INTERRUPT)\r\n| (1 << DATA_PACKET_RECEIVED_INTERRUPT)\r\n| (1 << SHORT_PACKET_TRANSFERRED_INTERRUPT));\r\nnet2272_ep_write(ep, EP_STAT1,\r\n(1 << TIMEOUT)\r\n| (1 << USB_OUT_ACK_SENT)\r\n| (1 << USB_OUT_NAK_SENT)\r\n| (1 << USB_IN_ACK_RCVD)\r\n| (1 << USB_IN_NAK_SENT)\r\n| (1 << USB_STALL_SENT)\r\n| (1 << LOCAL_OUT_ZLP));\r\nnet2272_write(dev, PAGESEL, 0);\r\nnet2272_write(dev, EP_TRANSFER2, 0xff);\r\nnet2272_write(dev, EP_TRANSFER1, 0xff);\r\nnet2272_write(dev, EP_TRANSFER0, 0xff);\r\nu.raw[0] = net2272_read(dev, SETUP0);\r\nu.raw[1] = net2272_read(dev, SETUP1);\r\nu.raw[2] = net2272_read(dev, SETUP2);\r\nu.raw[3] = net2272_read(dev, SETUP3);\r\nu.raw[4] = net2272_read(dev, SETUP4);\r\nu.raw[5] = net2272_read(dev, SETUP5);\r\nu.raw[6] = net2272_read(dev, SETUP6);\r\nu.raw[7] = net2272_read(dev, SETUP7);\r\nle16_to_cpus(&u.r.wValue);\r\nle16_to_cpus(&u.r.wIndex);\r\nle16_to_cpus(&u.r.wLength);\r\nnet2272_write(dev, IRQSTAT0, 1 << SETUP_PACKET_INTERRUPT);\r\nstat ^= (1 << SETUP_PACKET_INTERRUPT);\r\nep->is_in = (u.r.bRequestType & USB_DIR_IN) != 0;\r\nif (ep->is_in) {\r\nscratch = (1 << DATA_PACKET_TRANSMITTED_INTERRUPT_ENABLE)\r\n| (1 << DATA_OUT_TOKEN_INTERRUPT_ENABLE)\r\n| (1 << DATA_IN_TOKEN_INTERRUPT_ENABLE);\r\nstop_out_naking(ep);\r\n} else\r\nscratch = (1 << DATA_PACKET_RECEIVED_INTERRUPT_ENABLE)\r\n| (1 << DATA_OUT_TOKEN_INTERRUPT_ENABLE)\r\n| (1 << DATA_IN_TOKEN_INTERRUPT_ENABLE);\r\nnet2272_ep_write(ep, EP_IRQENB, scratch);\r\nif ((u.r.bRequestType & USB_TYPE_MASK) != USB_TYPE_STANDARD)\r\ngoto delegate;\r\nswitch (u.r.bRequest) {\r\ncase USB_REQ_GET_STATUS: {\r\nstruct net2272_ep *e;\r\nu16 status = 0;\r\nswitch (u.r.bRequestType & USB_RECIP_MASK) {\r\ncase USB_RECIP_ENDPOINT:\r\ne = net2272_get_ep_by_addr(dev, u.r.wIndex);\r\nif (!e || u.r.wLength > 2)\r\ngoto do_stall;\r\nif (net2272_ep_read(e, EP_RSPSET) & (1 << ENDPOINT_HALT))\r\nstatus = __constant_cpu_to_le16(1);\r\nelse\r\nstatus = __constant_cpu_to_le16(0);\r\nnet2272_ep_write(&dev->ep[0], EP_IRQENB, 0);\r\nwritew(status, net2272_reg_addr(dev, EP_DATA));\r\nset_fifo_bytecount(&dev->ep[0], 0);\r\nallow_status(ep);\r\ndev_vdbg(dev->dev, "%s stat %02x\n",\r\nep->ep.name, status);\r\ngoto next_endpoints;\r\ncase USB_RECIP_DEVICE:\r\nif (u.r.wLength > 2)\r\ngoto do_stall;\r\nif (dev->gadget.is_selfpowered)\r\nstatus = (1 << USB_DEVICE_SELF_POWERED);\r\nnet2272_ep_write(&dev->ep[0], EP_IRQENB, 0);\r\nwritew(status, net2272_reg_addr(dev, EP_DATA));\r\nset_fifo_bytecount(&dev->ep[0], 0);\r\nallow_status(ep);\r\ndev_vdbg(dev->dev, "device stat %02x\n", status);\r\ngoto next_endpoints;\r\ncase USB_RECIP_INTERFACE:\r\nif (u.r.wLength > 2)\r\ngoto do_stall;\r\nnet2272_ep_write(&dev->ep[0], EP_IRQENB, 0);\r\nwritew(status, net2272_reg_addr(dev, EP_DATA));\r\nset_fifo_bytecount(&dev->ep[0], 0);\r\nallow_status(ep);\r\ndev_vdbg(dev->dev, "interface status %02x\n", status);\r\ngoto next_endpoints;\r\n}\r\nbreak;\r\n}\r\ncase USB_REQ_CLEAR_FEATURE: {\r\nstruct net2272_ep *e;\r\nif (u.r.bRequestType != USB_RECIP_ENDPOINT)\r\ngoto delegate;\r\nif (u.r.wValue != USB_ENDPOINT_HALT ||\r\nu.r.wLength != 0)\r\ngoto do_stall;\r\ne = net2272_get_ep_by_addr(dev, u.r.wIndex);\r\nif (!e)\r\ngoto do_stall;\r\nif (e->wedged) {\r\ndev_vdbg(dev->dev, "%s wedged, halt not cleared\n",\r\nep->ep.name);\r\n} else {\r\ndev_vdbg(dev->dev, "%s clear halt\n", ep->ep.name);\r\nclear_halt(e);\r\n}\r\nallow_status(ep);\r\ngoto next_endpoints;\r\n}\r\ncase USB_REQ_SET_FEATURE: {\r\nstruct net2272_ep *e;\r\nif (u.r.bRequestType == USB_RECIP_DEVICE) {\r\nif (u.r.wIndex != NORMAL_OPERATION)\r\nnet2272_set_test_mode(dev, (u.r.wIndex >> 8));\r\nallow_status(ep);\r\ndev_vdbg(dev->dev, "test mode: %d\n", u.r.wIndex);\r\ngoto next_endpoints;\r\n} else if (u.r.bRequestType != USB_RECIP_ENDPOINT)\r\ngoto delegate;\r\nif (u.r.wValue != USB_ENDPOINT_HALT ||\r\nu.r.wLength != 0)\r\ngoto do_stall;\r\ne = net2272_get_ep_by_addr(dev, u.r.wIndex);\r\nif (!e)\r\ngoto do_stall;\r\nset_halt(e);\r\nallow_status(ep);\r\ndev_vdbg(dev->dev, "%s set halt\n", ep->ep.name);\r\ngoto next_endpoints;\r\n}\r\ncase USB_REQ_SET_ADDRESS: {\r\nnet2272_write(dev, OURADDR, u.r.wValue & 0xff);\r\nallow_status(ep);\r\nbreak;\r\n}\r\ndefault:\r\ndelegate:\r\ndev_vdbg(dev->dev, "setup %02x.%02x v%04x i%04x "\r\n"ep_cfg %08x\n",\r\nu.r.bRequestType, u.r.bRequest,\r\nu.r.wValue, u.r.wIndex,\r\nnet2272_ep_read(ep, EP_CFG));\r\nspin_unlock(&dev->lock);\r\ntmp = dev->driver->setup(&dev->gadget, &u.r);\r\nspin_lock(&dev->lock);\r\n}\r\nif (tmp < 0) {\r\ndo_stall:\r\ndev_vdbg(dev->dev, "req %02x.%02x protocol STALL; stat %d\n",\r\nu.r.bRequestType, u.r.bRequest, tmp);\r\ndev->protocol_stall = 1;\r\n}\r\n} else if (stat & (1 << DMA_DONE_INTERRUPT)) {\r\nnet2272_cancel_dma(dev);\r\nnet2272_write(dev, IRQSTAT0, 1 << DMA_DONE_INTERRUPT);\r\nstat &= ~(1 << DMA_DONE_INTERRUPT);\r\nnum = (net2272_read(dev, DMAREQ) & (1 << DMA_ENDPOINT_SELECT))\r\n? 2 : 1;\r\nep = &dev->ep[num];\r\nnet2272_handle_dma(ep);\r\n}\r\nnext_endpoints:\r\nscratch = stat & 0x0f;\r\nstat &= ~0x0f;\r\nfor (num = 0; scratch; num++) {\r\nu8 t;\r\nt = 1 << num;\r\nif ((scratch & t) == 0)\r\ncontinue;\r\nscratch ^= t;\r\nep = &dev->ep[num];\r\nnet2272_handle_ep(ep);\r\n}\r\nstat &= ~(1 << SOF_INTERRUPT);\r\nif (stat)\r\ndev_dbg(dev->dev, "unhandled irqstat0 %02x\n", stat);\r\n}\r\nstatic void\r\nnet2272_handle_stat1_irqs(struct net2272 *dev, u8 stat)\r\n{\r\nu8 tmp, mask;\r\ntmp = (1 << VBUS_INTERRUPT) | (1 << ROOT_PORT_RESET_INTERRUPT);\r\nmask = (1 << USB_HIGH_SPEED) | (1 << USB_FULL_SPEED);\r\nif (stat & tmp) {\r\nbool reset = false;\r\nbool disconnect = false;\r\nnet2272_write(dev, IRQSTAT1, tmp);\r\nif (dev->gadget.speed != USB_SPEED_UNKNOWN) {\r\nif ((stat & (1 << VBUS_INTERRUPT)) &&\r\n(net2272_read(dev, USBCTL1) &\r\n(1 << VBUS_PIN)) == 0) {\r\ndisconnect = true;\r\ndev_dbg(dev->dev, "disconnect %s\n",\r\ndev->driver->driver.name);\r\n} else if ((stat & (1 << ROOT_PORT_RESET_INTERRUPT)) &&\r\n(net2272_read(dev, USBCTL1) & mask)\r\n== 0) {\r\nreset = true;\r\ndev_dbg(dev->dev, "reset %s\n",\r\ndev->driver->driver.name);\r\n}\r\nif (disconnect || reset) {\r\nstop_activity(dev, dev->driver);\r\nnet2272_ep0_start(dev);\r\nspin_unlock(&dev->lock);\r\nif (reset)\r\nusb_gadget_udc_reset\r\n(&dev->gadget, dev->driver);\r\nelse\r\n(dev->driver->disconnect)\r\n(&dev->gadget);\r\nspin_lock(&dev->lock);\r\nreturn;\r\n}\r\n}\r\nstat &= ~tmp;\r\nif (!stat)\r\nreturn;\r\n}\r\ntmp = (1 << SUSPEND_REQUEST_CHANGE_INTERRUPT);\r\nif (stat & tmp) {\r\nnet2272_write(dev, IRQSTAT1, tmp);\r\nif (stat & (1 << SUSPEND_REQUEST_INTERRUPT)) {\r\nif (dev->driver->suspend)\r\ndev->driver->suspend(&dev->gadget);\r\nif (!enable_suspend) {\r\nstat &= ~(1 << SUSPEND_REQUEST_INTERRUPT);\r\ndev_dbg(dev->dev, "Suspend disabled, ignoring\n");\r\n}\r\n} else {\r\nif (dev->driver->resume)\r\ndev->driver->resume(&dev->gadget);\r\n}\r\nstat &= ~tmp;\r\n}\r\nif (stat)\r\nnet2272_write(dev, IRQSTAT1, stat);\r\nstat &= ~((1 << CONTROL_STATUS_INTERRUPT)\r\n| (1 << SUSPEND_REQUEST_INTERRUPT)\r\n| (1 << RESUME_INTERRUPT));\r\nif (!stat)\r\nreturn;\r\nelse\r\ndev_dbg(dev->dev, "unhandled irqstat1 %02x\n", stat);\r\n}\r\nstatic irqreturn_t net2272_irq(int irq, void *_dev)\r\n{\r\nstruct net2272 *dev = _dev;\r\n#if defined(PLX_PCI_RDK) || defined(PLX_PCI_RDK2)\r\nu32 intcsr;\r\n#endif\r\n#if defined(PLX_PCI_RDK)\r\nu8 dmareq;\r\n#endif\r\nspin_lock(&dev->lock);\r\n#if defined(PLX_PCI_RDK)\r\nintcsr = readl(dev->rdk1.plx9054_base_addr + INTCSR);\r\nif ((intcsr & LOCAL_INTERRUPT_TEST) == LOCAL_INTERRUPT_TEST) {\r\nwritel(intcsr & ~(1 << PCI_INTERRUPT_ENABLE),\r\ndev->rdk1.plx9054_base_addr + INTCSR);\r\nnet2272_handle_stat1_irqs(dev, net2272_read(dev, IRQSTAT1));\r\nnet2272_handle_stat0_irqs(dev, net2272_read(dev, IRQSTAT0));\r\nintcsr = readl(dev->rdk1.plx9054_base_addr + INTCSR);\r\nwritel(intcsr | (1 << PCI_INTERRUPT_ENABLE),\r\ndev->rdk1.plx9054_base_addr + INTCSR);\r\n}\r\nif ((intcsr & DMA_CHANNEL_0_TEST) == DMA_CHANNEL_0_TEST) {\r\nwriteb((1 << CHANNEL_CLEAR_INTERRUPT | (0 << CHANNEL_ENABLE)),\r\ndev->rdk1.plx9054_base_addr + DMACSR0);\r\ndmareq = net2272_read(dev, DMAREQ);\r\nif (dmareq & 0x01)\r\nnet2272_handle_dma(&dev->ep[2]);\r\nelse\r\nnet2272_handle_dma(&dev->ep[1]);\r\n}\r\n#endif\r\n#if defined(PLX_PCI_RDK2)\r\nintcsr = readl(dev->rdk2.fpga_base_addr + RDK2_IRQSTAT);\r\nif (!intcsr & (1 << NET2272_PCI_IRQ)) {\r\nspin_unlock(&dev->lock);\r\nreturn IRQ_NONE;\r\n}\r\n#endif\r\n#if !defined(PLX_PCI_RDK)\r\nnet2272_handle_stat1_irqs(dev, net2272_read(dev, IRQSTAT1));\r\nnet2272_handle_stat0_irqs(dev, net2272_read(dev, IRQSTAT0));\r\n#endif\r\nspin_unlock(&dev->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int net2272_present(struct net2272 *dev)\r\n{\r\nunsigned int ii;\r\nu8 val, refval;\r\nrefval = net2272_read(dev, SCRATCH);\r\nfor (ii = 0; ii < 0x100; ii += 7) {\r\nnet2272_write(dev, SCRATCH, ii);\r\nval = net2272_read(dev, SCRATCH);\r\nif (val != ii) {\r\ndev_dbg(dev->dev,\r\n"%s: write/read SCRATCH register test failed: "\r\n"wrote:0x%2.2x, read:0x%2.2x\n",\r\n__func__, ii, val);\r\nreturn -EINVAL;\r\n}\r\n}\r\nnet2272_write(dev, SCRATCH, refval);\r\nrefval = net2272_read(dev, CHIPREV_2272);\r\nfor (ii = 0; ii < 0x100; ii += 7) {\r\nnet2272_write(dev, CHIPREV_2272, ii);\r\nval = net2272_read(dev, CHIPREV_2272);\r\nif (val != refval) {\r\ndev_dbg(dev->dev,\r\n"%s: write/read CHIPREV register test failed: "\r\n"wrote 0x%2.2x, read:0x%2.2x expected:0x%2.2x\n",\r\n__func__, ii, val, refval);\r\nreturn -EINVAL;\r\n}\r\n}\r\nval = net2272_read(dev, CHIPREV_LEGACY);\r\nif (val != NET2270_LEGACY_REV) {\r\ndev_dbg(dev->dev,\r\n"%s: WARNING: UNEXPECTED NET2272 LEGACY REGISTER VALUE:\n"\r\n" - CHIPREV_LEGACY: expected 0x%2.2x, got:0x%2.2x. (Not NET2272?)\n",\r\n__func__, NET2270_LEGACY_REV, val);\r\nreturn -EINVAL;\r\n}\r\nval = net2272_read(dev, CHIPREV_2272);\r\nswitch (val) {\r\ncase CHIPREV_NET2272_R1:\r\ndev_dbg(dev->dev,\r\n"%s: Rev 1 detected: newer silicon recommended for DMA support\n",\r\n__func__);\r\nbreak;\r\ncase CHIPREV_NET2272_R1A:\r\nbreak;\r\ndefault:\r\ndev_dbg(dev->dev,\r\n"%s: unexpected silicon revision register value: "\r\n" CHIPREV_2272: 0x%2.2x\n",\r\n__func__, val);\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nnet2272_gadget_release(struct device *_dev)\r\n{\r\nstruct net2272 *dev = dev_get_drvdata(_dev);\r\nkfree(dev);\r\n}\r\nstatic void\r\nnet2272_remove(struct net2272 *dev)\r\n{\r\nusb_del_gadget_udc(&dev->gadget);\r\nfree_irq(dev->irq, dev);\r\niounmap(dev->base_addr);\r\ndevice_remove_file(dev->dev, &dev_attr_registers);\r\ndev_info(dev->dev, "unbind\n");\r\n}\r\nstatic struct net2272 *net2272_probe_init(struct device *dev, unsigned int irq)\r\n{\r\nstruct net2272 *ret;\r\nif (!irq) {\r\ndev_dbg(dev, "No IRQ!\n");\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nret = kzalloc(sizeof(*ret), GFP_KERNEL);\r\nif (!ret)\r\nreturn ERR_PTR(-ENOMEM);\r\nspin_lock_init(&ret->lock);\r\nret->irq = irq;\r\nret->dev = dev;\r\nret->gadget.ops = &net2272_ops;\r\nret->gadget.max_speed = USB_SPEED_HIGH;\r\nret->gadget.name = driver_name;\r\nreturn ret;\r\n}\r\nstatic int\r\nnet2272_probe_fin(struct net2272 *dev, unsigned int irqflags)\r\n{\r\nint ret;\r\nif (net2272_present(dev)) {\r\ndev_warn(dev->dev, "2272 not found!\n");\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nnet2272_usb_reset(dev);\r\nnet2272_usb_reinit(dev);\r\nret = request_irq(dev->irq, net2272_irq, irqflags, driver_name, dev);\r\nif (ret) {\r\ndev_err(dev->dev, "request interrupt %i failed\n", dev->irq);\r\ngoto err;\r\n}\r\ndev->chiprev = net2272_read(dev, CHIPREV_2272);\r\ndev_info(dev->dev, "%s\n", driver_desc);\r\ndev_info(dev->dev, "irq %i, mem %p, chip rev %04x, dma %s\n",\r\ndev->irq, dev->base_addr, dev->chiprev,\r\ndma_mode_string());\r\ndev_info(dev->dev, "version: %s\n", driver_vers);\r\nret = device_create_file(dev->dev, &dev_attr_registers);\r\nif (ret)\r\ngoto err_irq;\r\nret = usb_add_gadget_udc_release(dev->dev, &dev->gadget,\r\nnet2272_gadget_release);\r\nif (ret)\r\ngoto err_add_udc;\r\nreturn 0;\r\nerr_add_udc:\r\ndevice_remove_file(dev->dev, &dev_attr_registers);\r\nerr_irq:\r\nfree_irq(dev->irq, dev);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int\r\nnet2272_rdk1_probe(struct pci_dev *pdev, struct net2272 *dev)\r\n{\r\nunsigned long resource, len, tmp;\r\nvoid __iomem *mem_mapped_addr[4];\r\nint ret, i;\r\nfor (i = 0; i < 4; ++i) {\r\nif (i == 1)\r\ncontinue;\r\nresource = pci_resource_start(pdev, i);\r\nlen = pci_resource_len(pdev, i);\r\nif (!request_mem_region(resource, len, driver_name)) {\r\ndev_dbg(dev->dev, "controller already in use\n");\r\nret = -EBUSY;\r\ngoto err;\r\n}\r\nmem_mapped_addr[i] = ioremap_nocache(resource, len);\r\nif (mem_mapped_addr[i] == NULL) {\r\nrelease_mem_region(resource, len);\r\ndev_dbg(dev->dev, "can't map memory\n");\r\nret = -EFAULT;\r\ngoto err;\r\n}\r\n}\r\ndev->rdk1.plx9054_base_addr = mem_mapped_addr[0];\r\ndev->rdk1.epld_base_addr = mem_mapped_addr[2];\r\ndev->base_addr = mem_mapped_addr[3];\r\ntmp = readl(dev->rdk1.plx9054_base_addr + LBRD1);\r\nwritel((tmp & ~(3 << MEMORY_SPACE_LOCAL_BUS_WIDTH)) | W16_BIT,\r\ndev->rdk1.plx9054_base_addr + LBRD1);\r\nwritel(readl(dev->rdk1.plx9054_base_addr + INTCSR) |\r\n(1 << PCI_INTERRUPT_ENABLE) |\r\n(1 << LOCAL_INTERRUPT_INPUT_ENABLE),\r\ndev->rdk1.plx9054_base_addr + INTCSR);\r\nwriteb((1 << CHANNEL_CLEAR_INTERRUPT | (0 << CHANNEL_ENABLE)),\r\ndev->rdk1.plx9054_base_addr + DMACSR0);\r\nwriteb((1 << EPLD_DMA_ENABLE) |\r\n(1 << DMA_CTL_DACK) |\r\n(1 << DMA_TIMEOUT_ENABLE) |\r\n(1 << USER) |\r\n(0 << MPX_MODE) |\r\n(1 << BUSWIDTH) |\r\n(1 << NET2272_RESET),\r\ndev->base_addr + EPLD_IO_CONTROL_REGISTER);\r\nmb();\r\nwriteb(readb(dev->base_addr + EPLD_IO_CONTROL_REGISTER) &\r\n~(1 << NET2272_RESET),\r\ndev->base_addr + EPLD_IO_CONTROL_REGISTER);\r\nudelay(200);\r\nreturn 0;\r\nerr:\r\nwhile (--i >= 0) {\r\niounmap(mem_mapped_addr[i]);\r\nrelease_mem_region(pci_resource_start(pdev, i),\r\npci_resource_len(pdev, i));\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nnet2272_rdk2_probe(struct pci_dev *pdev, struct net2272 *dev)\r\n{\r\nunsigned long resource, len;\r\nvoid __iomem *mem_mapped_addr[2];\r\nint ret, i;\r\nfor (i = 0; i < 2; ++i) {\r\nresource = pci_resource_start(pdev, i);\r\nlen = pci_resource_len(pdev, i);\r\nif (!request_mem_region(resource, len, driver_name)) {\r\ndev_dbg(dev->dev, "controller already in use\n");\r\nret = -EBUSY;\r\ngoto err;\r\n}\r\nmem_mapped_addr[i] = ioremap_nocache(resource, len);\r\nif (mem_mapped_addr[i] == NULL) {\r\nrelease_mem_region(resource, len);\r\ndev_dbg(dev->dev, "can't map memory\n");\r\nret = -EFAULT;\r\ngoto err;\r\n}\r\n}\r\ndev->rdk2.fpga_base_addr = mem_mapped_addr[0];\r\ndev->base_addr = mem_mapped_addr[1];\r\nmb();\r\nwritel((1 << CHIP_RESET), dev->rdk2.fpga_base_addr + RDK2_LOCCTLRDK);\r\nudelay(200);\r\nwritel((1 << BUS_WIDTH), dev->rdk2.fpga_base_addr + RDK2_LOCCTLRDK);\r\ndev_info(dev->dev, "RDK2 FPGA version %08x\n",\r\nreadl(dev->rdk2.fpga_base_addr + RDK2_FPGAREV));\r\nwritel((1 << NET2272_PCI_IRQ), dev->rdk2.fpga_base_addr + RDK2_IRQENB);\r\nreturn 0;\r\nerr:\r\nwhile (--i >= 0) {\r\niounmap(mem_mapped_addr[i]);\r\nrelease_mem_region(pci_resource_start(pdev, i),\r\npci_resource_len(pdev, i));\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nnet2272_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nstruct net2272 *dev;\r\nint ret;\r\ndev = net2272_probe_init(&pdev->dev, pdev->irq);\r\nif (IS_ERR(dev))\r\nreturn PTR_ERR(dev);\r\ndev->dev_id = pdev->device;\r\nif (pci_enable_device(pdev) < 0) {\r\nret = -ENODEV;\r\ngoto err_free;\r\n}\r\npci_set_master(pdev);\r\nswitch (pdev->device) {\r\ncase PCI_DEVICE_ID_RDK1: ret = net2272_rdk1_probe(pdev, dev); break;\r\ncase PCI_DEVICE_ID_RDK2: ret = net2272_rdk2_probe(pdev, dev); break;\r\ndefault: BUG();\r\n}\r\nif (ret)\r\ngoto err_pci;\r\nret = net2272_probe_fin(dev, 0);\r\nif (ret)\r\ngoto err_pci;\r\npci_set_drvdata(pdev, dev);\r\nreturn 0;\r\nerr_pci:\r\npci_disable_device(pdev);\r\nerr_free:\r\nkfree(dev);\r\nreturn ret;\r\n}\r\nstatic void\r\nnet2272_rdk1_remove(struct pci_dev *pdev, struct net2272 *dev)\r\n{\r\nint i;\r\nwritel(readl(dev->rdk1.plx9054_base_addr + INTCSR) &\r\n~(1 << PCI_INTERRUPT_ENABLE),\r\ndev->rdk1.plx9054_base_addr + INTCSR);\r\niounmap(dev->rdk1.plx9054_base_addr);\r\niounmap(dev->rdk1.epld_base_addr);\r\nfor (i = 0; i < 4; ++i) {\r\nif (i == 1)\r\ncontinue;\r\nrelease_mem_region(pci_resource_start(pdev, i),\r\npci_resource_len(pdev, i));\r\n}\r\n}\r\nstatic void\r\nnet2272_rdk2_remove(struct pci_dev *pdev, struct net2272 *dev)\r\n{\r\nint i;\r\niounmap(dev->rdk2.fpga_base_addr);\r\nfor (i = 0; i < 2; ++i)\r\nrelease_mem_region(pci_resource_start(pdev, i),\r\npci_resource_len(pdev, i));\r\n}\r\nstatic void\r\nnet2272_pci_remove(struct pci_dev *pdev)\r\n{\r\nstruct net2272 *dev = pci_get_drvdata(pdev);\r\nnet2272_remove(dev);\r\nswitch (pdev->device) {\r\ncase PCI_DEVICE_ID_RDK1: net2272_rdk1_remove(pdev, dev); break;\r\ncase PCI_DEVICE_ID_RDK2: net2272_rdk2_remove(pdev, dev); break;\r\ndefault: BUG();\r\n}\r\npci_disable_device(pdev);\r\nkfree(dev);\r\n}\r\nstatic int net2272_pci_register(void)\r\n{\r\nreturn pci_register_driver(&net2272_pci_driver);\r\n}\r\nstatic void net2272_pci_unregister(void)\r\n{\r\npci_unregister_driver(&net2272_pci_driver);\r\n}\r\nstatic inline int net2272_pci_register(void) { return 0; }\r\nstatic inline void net2272_pci_unregister(void) { }\r\nstatic int\r\nnet2272_plat_probe(struct platform_device *pdev)\r\n{\r\nstruct net2272 *dev;\r\nint ret;\r\nunsigned int irqflags;\r\nresource_size_t base, len;\r\nstruct resource *iomem, *iomem_bus, *irq_res;\r\nirq_res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\niomem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\niomem_bus = platform_get_resource(pdev, IORESOURCE_BUS, 0);\r\nif (!irq_res || !iomem) {\r\ndev_err(&pdev->dev, "must provide irq/base addr");\r\nreturn -EINVAL;\r\n}\r\ndev = net2272_probe_init(&pdev->dev, irq_res->start);\r\nif (IS_ERR(dev))\r\nreturn PTR_ERR(dev);\r\nirqflags = 0;\r\nif (irq_res->flags & IORESOURCE_IRQ_HIGHEDGE)\r\nirqflags |= IRQF_TRIGGER_RISING;\r\nif (irq_res->flags & IORESOURCE_IRQ_LOWEDGE)\r\nirqflags |= IRQF_TRIGGER_FALLING;\r\nif (irq_res->flags & IORESOURCE_IRQ_HIGHLEVEL)\r\nirqflags |= IRQF_TRIGGER_HIGH;\r\nif (irq_res->flags & IORESOURCE_IRQ_LOWLEVEL)\r\nirqflags |= IRQF_TRIGGER_LOW;\r\nbase = iomem->start;\r\nlen = resource_size(iomem);\r\nif (iomem_bus)\r\ndev->base_shift = iomem_bus->start;\r\nif (!request_mem_region(base, len, driver_name)) {\r\ndev_dbg(dev->dev, "get request memory region!\n");\r\nret = -EBUSY;\r\ngoto err;\r\n}\r\ndev->base_addr = ioremap_nocache(base, len);\r\nif (!dev->base_addr) {\r\ndev_dbg(dev->dev, "can't map memory\n");\r\nret = -EFAULT;\r\ngoto err_req;\r\n}\r\nret = net2272_probe_fin(dev, IRQF_TRIGGER_LOW);\r\nif (ret)\r\ngoto err_io;\r\nplatform_set_drvdata(pdev, dev);\r\ndev_info(&pdev->dev, "running in 16-bit, %sbyte swap local bus mode\n",\r\n(net2272_read(dev, LOCCTL) & (1 << BYTE_SWAP)) ? "" : "no ");\r\nreturn 0;\r\nerr_io:\r\niounmap(dev->base_addr);\r\nerr_req:\r\nrelease_mem_region(base, len);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int\r\nnet2272_plat_remove(struct platform_device *pdev)\r\n{\r\nstruct net2272 *dev = platform_get_drvdata(pdev);\r\nnet2272_remove(dev);\r\nrelease_mem_region(pdev->resource[0].start,\r\nresource_size(&pdev->resource[0]));\r\nkfree(dev);\r\nreturn 0;\r\n}\r\nstatic int __init net2272_init(void)\r\n{\r\nint ret;\r\nret = net2272_pci_register();\r\nif (ret)\r\nreturn ret;\r\nret = platform_driver_register(&net2272_plat_driver);\r\nif (ret)\r\ngoto err_pci;\r\nreturn ret;\r\nerr_pci:\r\nnet2272_pci_unregister();\r\nreturn ret;\r\n}\r\nstatic void __exit net2272_cleanup(void)\r\n{\r\nnet2272_pci_unregister();\r\nplatform_driver_unregister(&net2272_plat_driver);\r\n}
