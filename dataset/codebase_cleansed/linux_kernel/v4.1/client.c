static int\r\nnvkm_client_notify(struct nvkm_notify *n)\r\n{\r\nstruct nvkm_client_notify *notify = container_of(n, typeof(*notify), n);\r\nstruct nvkm_client *client = notify->client;\r\nreturn client->ntfy(&notify->rep, notify->size, n->data, n->size);\r\n}\r\nint\r\nnvkm_client_notify_put(struct nvkm_client *client, int index)\r\n{\r\nif (index < ARRAY_SIZE(client->notify)) {\r\nif (client->notify[index]) {\r\nnvkm_notify_put(&client->notify[index]->n);\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENOENT;\r\n}\r\nint\r\nnvkm_client_notify_get(struct nvkm_client *client, int index)\r\n{\r\nif (index < ARRAY_SIZE(client->notify)) {\r\nif (client->notify[index]) {\r\nnvkm_notify_get(&client->notify[index]->n);\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENOENT;\r\n}\r\nint\r\nnvkm_client_notify_del(struct nvkm_client *client, int index)\r\n{\r\nif (index < ARRAY_SIZE(client->notify)) {\r\nif (client->notify[index]) {\r\nnvkm_notify_fini(&client->notify[index]->n);\r\nkfree(client->notify[index]);\r\nclient->notify[index] = NULL;\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENOENT;\r\n}\r\nint\r\nnvkm_client_notify_new(struct nvkm_object *object,\r\nstruct nvkm_event *event, void *data, u32 size)\r\n{\r\nstruct nvkm_client *client = nvkm_client(object);\r\nstruct nvkm_client_notify *notify;\r\nunion {\r\nstruct nvif_notify_req_v0 v0;\r\n} *req = data;\r\nu8 index, reply;\r\nint ret;\r\nfor (index = 0; index < ARRAY_SIZE(client->notify); index++) {\r\nif (!client->notify[index])\r\nbreak;\r\n}\r\nif (index == ARRAY_SIZE(client->notify))\r\nreturn -ENOSPC;\r\nnotify = kzalloc(sizeof(*notify), GFP_KERNEL);\r\nif (!notify)\r\nreturn -ENOMEM;\r\nnv_ioctl(client, "notify new size %d\n", size);\r\nif (nvif_unpack(req->v0, 0, 0, true)) {\r\nnv_ioctl(client, "notify new vers %d reply %d route %02x "\r\n"token %llx\n", req->v0.version,\r\nreq->v0.reply, req->v0.route, req->v0.token);\r\nnotify->version = req->v0.version;\r\nnotify->size = sizeof(notify->rep.v0);\r\nnotify->rep.v0.version = req->v0.version;\r\nnotify->rep.v0.route = req->v0.route;\r\nnotify->rep.v0.token = req->v0.token;\r\nreply = req->v0.reply;\r\n}\r\nif (ret == 0) {\r\nret = nvkm_notify_init(object, event, nvkm_client_notify,\r\nfalse, data, size, reply, &notify->n);\r\nif (ret == 0) {\r\nclient->notify[index] = notify;\r\nnotify->client = client;\r\nreturn index;\r\n}\r\n}\r\nkfree(notify);\r\nreturn ret;\r\n}\r\nstatic int\r\nnvkm_client_mthd_devlist(struct nvkm_object *object, void *data, u32 size)\r\n{\r\nunion {\r\nstruct nv_client_devlist_v0 v0;\r\n} *args = data;\r\nint ret;\r\nnv_ioctl(object, "client devlist size %d\n", size);\r\nif (nvif_unpack(args->v0, 0, 0, true)) {\r\nnv_ioctl(object, "client devlist vers %d count %d\n",\r\nargs->v0.version, args->v0.count);\r\nif (size == sizeof(args->v0.device[0]) * args->v0.count) {\r\nret = nvkm_device_list(args->v0.device, args->v0.count);\r\nif (ret >= 0) {\r\nargs->v0.count = ret;\r\nret = 0;\r\n}\r\n} else {\r\nret = -EINVAL;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nnvkm_client_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)\r\n{\r\nswitch (mthd) {\r\ncase NV_CLIENT_DEVLIST:\r\nreturn nvkm_client_mthd_devlist(object, data, size);\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void\r\nnvkm_client_dtor(struct nvkm_object *object)\r\n{\r\nstruct nvkm_client *client = (void *)object;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(client->notify); i++)\r\nnvkm_client_notify_del(client, i);\r\nnvkm_object_ref(NULL, &client->device);\r\nnvkm_handle_destroy(client->root);\r\nnvkm_namedb_destroy(&client->namedb);\r\n}\r\nint\r\nnvkm_client_create_(const char *name, u64 devname, const char *cfg,\r\nconst char *dbg, int length, void **pobject)\r\n{\r\nstruct nvkm_object *device;\r\nstruct nvkm_client *client;\r\nint ret;\r\ndevice = (void *)nvkm_device_find(devname);\r\nif (!device)\r\nreturn -ENODEV;\r\nret = nvkm_namedb_create_(NULL, NULL, &nvkm_client_oclass,\r\nNV_CLIENT_CLASS, NULL,\r\n(1ULL << NVDEV_ENGINE_DEVICE),\r\nlength, pobject);\r\nclient = *pobject;\r\nif (ret)\r\nreturn ret;\r\nret = nvkm_handle_create(nv_object(client), ~0, ~0, nv_object(client),\r\n&client->root);\r\nif (ret)\r\nreturn ret;\r\natomic_set(&nv_object(client)->usecount, 2);\r\nnvkm_object_ref(device, &client->device);\r\nsnprintf(client->name, sizeof(client->name), "%s", name);\r\nclient->debug = nvkm_dbgopt(dbg, "CLIENT");\r\nreturn 0;\r\n}\r\nint\r\nnvkm_client_init(struct nvkm_client *client)\r\n{\r\nint ret;\r\nnv_debug(client, "init running\n");\r\nret = nvkm_handle_init(client->root);\r\nnv_debug(client, "init completed with %d\n", ret);\r\nreturn ret;\r\n}\r\nint\r\nnvkm_client_fini(struct nvkm_client *client, bool suspend)\r\n{\r\nconst char *name[2] = { "fini", "suspend" };\r\nint ret, i;\r\nnv_debug(client, "%s running\n", name[suspend]);\r\nnv_debug(client, "%s notify\n", name[suspend]);\r\nfor (i = 0; i < ARRAY_SIZE(client->notify); i++)\r\nnvkm_client_notify_put(client, i);\r\nnv_debug(client, "%s object\n", name[suspend]);\r\nret = nvkm_handle_fini(client->root, suspend);\r\nnv_debug(client, "%s completed with %d\n", name[suspend], ret);\r\nreturn ret;\r\n}\r\nconst char *\r\nnvkm_client_name(void *obj)\r\n{\r\nconst char *client_name = "unknown";\r\nstruct nvkm_client *client = nvkm_client(obj);\r\nif (client)\r\nclient_name = client->name;\r\nreturn client_name;\r\n}
