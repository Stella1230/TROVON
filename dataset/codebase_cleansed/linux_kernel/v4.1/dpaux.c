static inline struct tegra_dpaux *to_dpaux(struct drm_dp_aux *aux)\r\n{\r\nreturn container_of(aux, struct tegra_dpaux, aux);\r\n}\r\nstatic inline struct tegra_dpaux *work_to_dpaux(struct work_struct *work)\r\n{\r\nreturn container_of(work, struct tegra_dpaux, work);\r\n}\r\nstatic inline unsigned long tegra_dpaux_readl(struct tegra_dpaux *dpaux,\r\nunsigned long offset)\r\n{\r\nreturn readl(dpaux->regs + (offset << 2));\r\n}\r\nstatic inline void tegra_dpaux_writel(struct tegra_dpaux *dpaux,\r\nunsigned long value,\r\nunsigned long offset)\r\n{\r\nwritel(value, dpaux->regs + (offset << 2));\r\n}\r\nstatic void tegra_dpaux_write_fifo(struct tegra_dpaux *dpaux, const u8 *buffer,\r\nsize_t size)\r\n{\r\nunsigned long offset = DPAUX_DP_AUXDATA_WRITE(0);\r\nsize_t i, j;\r\nfor (i = 0; i < size; i += 4) {\r\nsize_t num = min_t(size_t, size - i, 4);\r\nunsigned long value = 0;\r\nfor (j = 0; j < num; j++)\r\nvalue |= buffer[i + j] << (j * 8);\r\ntegra_dpaux_writel(dpaux, value, offset++);\r\n}\r\n}\r\nstatic void tegra_dpaux_read_fifo(struct tegra_dpaux *dpaux, u8 *buffer,\r\nsize_t size)\r\n{\r\nunsigned long offset = DPAUX_DP_AUXDATA_READ(0);\r\nsize_t i, j;\r\nfor (i = 0; i < size; i += 4) {\r\nsize_t num = min_t(size_t, size - i, 4);\r\nunsigned long value;\r\nvalue = tegra_dpaux_readl(dpaux, offset++);\r\nfor (j = 0; j < num; j++)\r\nbuffer[i + j] = value >> (j * 8);\r\n}\r\n}\r\nstatic ssize_t tegra_dpaux_transfer(struct drm_dp_aux *aux,\r\nstruct drm_dp_aux_msg *msg)\r\n{\r\nunsigned long timeout = msecs_to_jiffies(250);\r\nstruct tegra_dpaux *dpaux = to_dpaux(aux);\r\nunsigned long status;\r\nssize_t ret = 0;\r\nu32 value;\r\nif (msg->size > 16)\r\nreturn -EINVAL;\r\nif (msg->size < 1) {\r\nswitch (msg->request & ~DP_AUX_I2C_MOT) {\r\ncase DP_AUX_I2C_WRITE:\r\ncase DP_AUX_I2C_READ:\r\nvalue = DPAUX_DP_AUXCTL_CMD_ADDRESS_ONLY;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nvalue = DPAUX_DP_AUXCTL_CMDLEN(msg->size - 1);\r\n}\r\nswitch (msg->request & ~DP_AUX_I2C_MOT) {\r\ncase DP_AUX_I2C_WRITE:\r\nif (msg->request & DP_AUX_I2C_MOT)\r\nvalue |= DPAUX_DP_AUXCTL_CMD_MOT_WR;\r\nelse\r\nvalue |= DPAUX_DP_AUXCTL_CMD_I2C_WR;\r\nbreak;\r\ncase DP_AUX_I2C_READ:\r\nif (msg->request & DP_AUX_I2C_MOT)\r\nvalue |= DPAUX_DP_AUXCTL_CMD_MOT_RD;\r\nelse\r\nvalue |= DPAUX_DP_AUXCTL_CMD_I2C_RD;\r\nbreak;\r\ncase DP_AUX_I2C_STATUS:\r\nif (msg->request & DP_AUX_I2C_MOT)\r\nvalue |= DPAUX_DP_AUXCTL_CMD_MOT_RQ;\r\nelse\r\nvalue |= DPAUX_DP_AUXCTL_CMD_I2C_RQ;\r\nbreak;\r\ncase DP_AUX_NATIVE_WRITE:\r\nvalue |= DPAUX_DP_AUXCTL_CMD_AUX_WR;\r\nbreak;\r\ncase DP_AUX_NATIVE_READ:\r\nvalue |= DPAUX_DP_AUXCTL_CMD_AUX_RD;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ntegra_dpaux_writel(dpaux, msg->address, DPAUX_DP_AUXADDR);\r\ntegra_dpaux_writel(dpaux, value, DPAUX_DP_AUXCTL);\r\nif ((msg->request & DP_AUX_I2C_READ) == 0) {\r\ntegra_dpaux_write_fifo(dpaux, msg->buffer, msg->size);\r\nret = msg->size;\r\n}\r\nvalue = tegra_dpaux_readl(dpaux, DPAUX_DP_AUXCTL);\r\nvalue |= DPAUX_DP_AUXCTL_TRANSACTREQ;\r\ntegra_dpaux_writel(dpaux, value, DPAUX_DP_AUXCTL);\r\nstatus = wait_for_completion_timeout(&dpaux->complete, timeout);\r\nif (!status)\r\nreturn -ETIMEDOUT;\r\nvalue = tegra_dpaux_readl(dpaux, DPAUX_DP_AUXSTAT);\r\ntegra_dpaux_writel(dpaux, 0xf00, DPAUX_DP_AUXSTAT);\r\nif (value & DPAUX_DP_AUXSTAT_TIMEOUT_ERROR)\r\nreturn -ETIMEDOUT;\r\nif ((value & DPAUX_DP_AUXSTAT_RX_ERROR) ||\r\n(value & DPAUX_DP_AUXSTAT_SINKSTAT_ERROR) ||\r\n(value & DPAUX_DP_AUXSTAT_NO_STOP_ERROR))\r\nreturn -EIO;\r\nswitch ((value & DPAUX_DP_AUXSTAT_REPLY_TYPE_MASK) >> 16) {\r\ncase 0x00:\r\nmsg->reply = DP_AUX_NATIVE_REPLY_ACK;\r\nbreak;\r\ncase 0x01:\r\nmsg->reply = DP_AUX_NATIVE_REPLY_NACK;\r\nbreak;\r\ncase 0x02:\r\nmsg->reply = DP_AUX_NATIVE_REPLY_DEFER;\r\nbreak;\r\ncase 0x04:\r\nmsg->reply = DP_AUX_I2C_REPLY_NACK;\r\nbreak;\r\ncase 0x08:\r\nmsg->reply = DP_AUX_I2C_REPLY_DEFER;\r\nbreak;\r\n}\r\nif ((msg->size > 0) && (msg->reply == DP_AUX_NATIVE_REPLY_ACK)) {\r\nif (msg->request & DP_AUX_I2C_READ) {\r\nsize_t count = value & DPAUX_DP_AUXSTAT_REPLY_MASK;\r\nif (WARN_ON(count != msg->size))\r\ncount = min_t(size_t, count, msg->size);\r\ntegra_dpaux_read_fifo(dpaux, msg->buffer, count);\r\nret = count;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void tegra_dpaux_hotplug(struct work_struct *work)\r\n{\r\nstruct tegra_dpaux *dpaux = work_to_dpaux(work);\r\nif (dpaux->output)\r\ndrm_helper_hpd_irq_event(dpaux->output->connector.dev);\r\n}\r\nstatic irqreturn_t tegra_dpaux_irq(int irq, void *data)\r\n{\r\nstruct tegra_dpaux *dpaux = data;\r\nirqreturn_t ret = IRQ_HANDLED;\r\nunsigned long value;\r\nvalue = tegra_dpaux_readl(dpaux, DPAUX_INTR_AUX);\r\ntegra_dpaux_writel(dpaux, value, DPAUX_INTR_AUX);\r\nif (value & (DPAUX_INTR_PLUG_EVENT | DPAUX_INTR_UNPLUG_EVENT))\r\nschedule_work(&dpaux->work);\r\nif (value & DPAUX_INTR_IRQ_EVENT) {\r\n}\r\nif (value & DPAUX_INTR_AUX_DONE)\r\ncomplete(&dpaux->complete);\r\nreturn ret;\r\n}\r\nstatic int tegra_dpaux_probe(struct platform_device *pdev)\r\n{\r\nstruct tegra_dpaux *dpaux;\r\nstruct resource *regs;\r\nunsigned long value;\r\nint err;\r\ndpaux = devm_kzalloc(&pdev->dev, sizeof(*dpaux), GFP_KERNEL);\r\nif (!dpaux)\r\nreturn -ENOMEM;\r\nINIT_WORK(&dpaux->work, tegra_dpaux_hotplug);\r\ninit_completion(&dpaux->complete);\r\nINIT_LIST_HEAD(&dpaux->list);\r\ndpaux->dev = &pdev->dev;\r\nregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndpaux->regs = devm_ioremap_resource(&pdev->dev, regs);\r\nif (IS_ERR(dpaux->regs))\r\nreturn PTR_ERR(dpaux->regs);\r\ndpaux->irq = platform_get_irq(pdev, 0);\r\nif (dpaux->irq < 0) {\r\ndev_err(&pdev->dev, "failed to get IRQ\n");\r\nreturn -ENXIO;\r\n}\r\ndpaux->rst = devm_reset_control_get(&pdev->dev, "dpaux");\r\nif (IS_ERR(dpaux->rst))\r\nreturn PTR_ERR(dpaux->rst);\r\ndpaux->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(dpaux->clk))\r\nreturn PTR_ERR(dpaux->clk);\r\nerr = clk_prepare_enable(dpaux->clk);\r\nif (err < 0)\r\nreturn err;\r\nreset_control_deassert(dpaux->rst);\r\ndpaux->clk_parent = devm_clk_get(&pdev->dev, "parent");\r\nif (IS_ERR(dpaux->clk_parent))\r\nreturn PTR_ERR(dpaux->clk_parent);\r\nerr = clk_prepare_enable(dpaux->clk_parent);\r\nif (err < 0)\r\nreturn err;\r\nerr = clk_set_rate(dpaux->clk_parent, 270000000);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to set clock to 270 MHz: %d\n",\r\nerr);\r\nreturn err;\r\n}\r\ndpaux->vdd = devm_regulator_get(&pdev->dev, "vdd");\r\nif (IS_ERR(dpaux->vdd))\r\nreturn PTR_ERR(dpaux->vdd);\r\nerr = devm_request_irq(dpaux->dev, dpaux->irq, tegra_dpaux_irq, 0,\r\ndev_name(dpaux->dev), dpaux);\r\nif (err < 0) {\r\ndev_err(dpaux->dev, "failed to request IRQ#%u: %d\n",\r\ndpaux->irq, err);\r\nreturn err;\r\n}\r\ndpaux->aux.transfer = tegra_dpaux_transfer;\r\ndpaux->aux.dev = &pdev->dev;\r\nerr = drm_dp_aux_register(&dpaux->aux);\r\nif (err < 0)\r\nreturn err;\r\nvalue = DPAUX_INTR_AUX_DONE | DPAUX_INTR_IRQ_EVENT |\r\nDPAUX_INTR_UNPLUG_EVENT | DPAUX_INTR_PLUG_EVENT;\r\ntegra_dpaux_writel(dpaux, value, DPAUX_INTR_EN_AUX);\r\ntegra_dpaux_writel(dpaux, value, DPAUX_INTR_AUX);\r\nmutex_lock(&dpaux_lock);\r\nlist_add_tail(&dpaux->list, &dpaux_list);\r\nmutex_unlock(&dpaux_lock);\r\nplatform_set_drvdata(pdev, dpaux);\r\nreturn 0;\r\n}\r\nstatic int tegra_dpaux_remove(struct platform_device *pdev)\r\n{\r\nstruct tegra_dpaux *dpaux = platform_get_drvdata(pdev);\r\ndrm_dp_aux_unregister(&dpaux->aux);\r\nmutex_lock(&dpaux_lock);\r\nlist_del(&dpaux->list);\r\nmutex_unlock(&dpaux_lock);\r\ncancel_work_sync(&dpaux->work);\r\nclk_disable_unprepare(dpaux->clk_parent);\r\nreset_control_assert(dpaux->rst);\r\nclk_disable_unprepare(dpaux->clk);\r\nreturn 0;\r\n}\r\nstruct tegra_dpaux *tegra_dpaux_find_by_of_node(struct device_node *np)\r\n{\r\nstruct tegra_dpaux *dpaux;\r\nmutex_lock(&dpaux_lock);\r\nlist_for_each_entry(dpaux, &dpaux_list, list)\r\nif (np == dpaux->dev->of_node) {\r\nmutex_unlock(&dpaux_lock);\r\nreturn dpaux;\r\n}\r\nmutex_unlock(&dpaux_lock);\r\nreturn NULL;\r\n}\r\nint tegra_dpaux_attach(struct tegra_dpaux *dpaux, struct tegra_output *output)\r\n{\r\nunsigned long timeout;\r\nint err;\r\noutput->connector.polled = DRM_CONNECTOR_POLL_HPD;\r\ndpaux->output = output;\r\nerr = regulator_enable(dpaux->vdd);\r\nif (err < 0)\r\nreturn err;\r\ntimeout = jiffies + msecs_to_jiffies(250);\r\nwhile (time_before(jiffies, timeout)) {\r\nenum drm_connector_status status;\r\nstatus = tegra_dpaux_detect(dpaux);\r\nif (status == connector_status_connected)\r\nreturn 0;\r\nusleep_range(1000, 2000);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nint tegra_dpaux_detach(struct tegra_dpaux *dpaux)\r\n{\r\nunsigned long timeout;\r\nint err;\r\nerr = regulator_disable(dpaux->vdd);\r\nif (err < 0)\r\nreturn err;\r\ntimeout = jiffies + msecs_to_jiffies(250);\r\nwhile (time_before(jiffies, timeout)) {\r\nenum drm_connector_status status;\r\nstatus = tegra_dpaux_detect(dpaux);\r\nif (status == connector_status_disconnected) {\r\ndpaux->output = NULL;\r\nreturn 0;\r\n}\r\nusleep_range(1000, 2000);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nenum drm_connector_status tegra_dpaux_detect(struct tegra_dpaux *dpaux)\r\n{\r\nunsigned long value;\r\nvalue = tegra_dpaux_readl(dpaux, DPAUX_DP_AUXSTAT);\r\nif (value & DPAUX_DP_AUXSTAT_HPD_STATUS)\r\nreturn connector_status_connected;\r\nreturn connector_status_disconnected;\r\n}\r\nint tegra_dpaux_enable(struct tegra_dpaux *dpaux)\r\n{\r\nunsigned long value;\r\nvalue = DPAUX_HYBRID_PADCTL_AUX_CMH(2) |\r\nDPAUX_HYBRID_PADCTL_AUX_DRVZ(4) |\r\nDPAUX_HYBRID_PADCTL_AUX_DRVI(0x18) |\r\nDPAUX_HYBRID_PADCTL_AUX_INPUT_RCV |\r\nDPAUX_HYBRID_PADCTL_MODE_AUX;\r\ntegra_dpaux_writel(dpaux, value, DPAUX_HYBRID_PADCTL);\r\nvalue = tegra_dpaux_readl(dpaux, DPAUX_HYBRID_SPARE);\r\nvalue &= ~DPAUX_HYBRID_SPARE_PAD_POWER_DOWN;\r\ntegra_dpaux_writel(dpaux, value, DPAUX_HYBRID_SPARE);\r\nreturn 0;\r\n}\r\nint tegra_dpaux_disable(struct tegra_dpaux *dpaux)\r\n{\r\nunsigned long value;\r\nvalue = tegra_dpaux_readl(dpaux, DPAUX_HYBRID_SPARE);\r\nvalue |= DPAUX_HYBRID_SPARE_PAD_POWER_DOWN;\r\ntegra_dpaux_writel(dpaux, value, DPAUX_HYBRID_SPARE);\r\nreturn 0;\r\n}\r\nint tegra_dpaux_prepare(struct tegra_dpaux *dpaux, u8 encoding)\r\n{\r\nint err;\r\nerr = drm_dp_dpcd_writeb(&dpaux->aux, DP_MAIN_LINK_CHANNEL_CODING_SET,\r\nencoding);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nint tegra_dpaux_train(struct tegra_dpaux *dpaux, struct drm_dp_link *link,\r\nu8 pattern)\r\n{\r\nu8 tp = pattern & DP_TRAINING_PATTERN_MASK;\r\nu8 status[DP_LINK_STATUS_SIZE], values[4];\r\nunsigned int i;\r\nint err;\r\nerr = drm_dp_dpcd_writeb(&dpaux->aux, DP_TRAINING_PATTERN_SET, pattern);\r\nif (err < 0)\r\nreturn err;\r\nif (tp == DP_TRAINING_PATTERN_DISABLE)\r\nreturn 0;\r\nfor (i = 0; i < link->num_lanes; i++)\r\nvalues[i] = DP_TRAIN_MAX_PRE_EMPHASIS_REACHED |\r\nDP_TRAIN_PRE_EMPH_LEVEL_0 |\r\nDP_TRAIN_MAX_SWING_REACHED |\r\nDP_TRAIN_VOLTAGE_SWING_LEVEL_0;\r\nerr = drm_dp_dpcd_write(&dpaux->aux, DP_TRAINING_LANE0_SET, values,\r\nlink->num_lanes);\r\nif (err < 0)\r\nreturn err;\r\nusleep_range(500, 1000);\r\nerr = drm_dp_dpcd_read_link_status(&dpaux->aux, status);\r\nif (err < 0)\r\nreturn err;\r\nswitch (tp) {\r\ncase DP_TRAINING_PATTERN_1:\r\nif (!drm_dp_clock_recovery_ok(status, link->num_lanes))\r\nreturn -EAGAIN;\r\nbreak;\r\ncase DP_TRAINING_PATTERN_2:\r\nif (!drm_dp_channel_eq_ok(status, link->num_lanes))\r\nreturn -EAGAIN;\r\nbreak;\r\ndefault:\r\ndev_err(dpaux->dev, "unsupported training pattern %u\n", tp);\r\nreturn -EINVAL;\r\n}\r\nerr = drm_dp_dpcd_writeb(&dpaux->aux, DP_EDP_CONFIGURATION_SET, 0);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}
