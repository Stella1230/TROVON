static bool wm8580_volatile(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase WM8580_RESET:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int wm8580_out_vu(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct soc_mixer_control *mc =\r\n(struct soc_mixer_control *)kcontrol->private_value;\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct wm8580_priv *wm8580 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int reg = mc->reg;\r\nunsigned int reg2 = mc->rreg;\r\nint ret;\r\nregcache_cache_only(wm8580->regmap, true);\r\nregmap_update_bits(wm8580->regmap, reg, 0x100, 0x000);\r\nregmap_update_bits(wm8580->regmap, reg2, 0x100, 0x000);\r\nregcache_cache_only(wm8580->regmap, false);\r\nret = snd_soc_put_volsw(kcontrol, ucontrol);\r\nif (ret < 0)\r\nreturn ret;\r\nsnd_soc_update_bits(codec, reg, 0x100, 0x100);\r\nsnd_soc_update_bits(codec, reg2, 0x100, 0x100);\r\nreturn 0;\r\n}\r\nstatic int pll_factors(struct _pll_div *pll_div, unsigned int target,\r\nunsigned int source)\r\n{\r\nu64 Kpart;\r\nunsigned int K, Ndiv, Nmod;\r\nint i;\r\npr_debug("wm8580: PLL %uHz->%uHz\n", source, target);\r\nfor (i = 0; i < ARRAY_SIZE(post_table); i++) {\r\nif (target * post_table[i].div >= 90000000 &&\r\ntarget * post_table[i].div <= 100000000) {\r\npll_div->freqmode = post_table[i].freqmode;\r\npll_div->postscale = post_table[i].postscale;\r\ntarget *= post_table[i].div;\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(post_table)) {\r\nprintk(KERN_ERR "wm8580: Unable to scale output frequency "\r\n"%u\n", target);\r\nreturn -EINVAL;\r\n}\r\nNdiv = target / source;\r\nif (Ndiv < 5) {\r\nsource /= 2;\r\npll_div->prescale = 1;\r\nNdiv = target / source;\r\n} else\r\npll_div->prescale = 0;\r\nif ((Ndiv < 5) || (Ndiv > 13)) {\r\nprintk(KERN_ERR\r\n"WM8580 N=%u outside supported range\n", Ndiv);\r\nreturn -EINVAL;\r\n}\r\npll_div->n = Ndiv;\r\nNmod = target % source;\r\nKpart = FIXED_PLL_SIZE * (long long)Nmod;\r\ndo_div(Kpart, source);\r\nK = Kpart & 0xFFFFFFFF;\r\npll_div->k = K;\r\npr_debug("PLL %x.%x prescale %d freqmode %d postscale %d\n",\r\npll_div->n, pll_div->k, pll_div->prescale, pll_div->freqmode,\r\npll_div->postscale);\r\nreturn 0;\r\n}\r\nstatic int wm8580_set_dai_pll(struct snd_soc_dai *codec_dai, int pll_id,\r\nint source, unsigned int freq_in, unsigned int freq_out)\r\n{\r\nint offset;\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct wm8580_priv *wm8580 = snd_soc_codec_get_drvdata(codec);\r\nstruct pll_state *state;\r\nstruct _pll_div pll_div;\r\nunsigned int reg;\r\nunsigned int pwr_mask;\r\nint ret;\r\nmemset(&pll_div, 0, sizeof(pll_div));\r\nswitch (pll_id) {\r\ncase WM8580_PLLA:\r\nstate = &wm8580->a;\r\noffset = 0;\r\npwr_mask = WM8580_PWRDN2_PLLAPD;\r\nbreak;\r\ncase WM8580_PLLB:\r\nstate = &wm8580->b;\r\noffset = 4;\r\npwr_mask = WM8580_PWRDN2_PLLBPD;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nif (freq_in && freq_out) {\r\nret = pll_factors(&pll_div, freq_out, freq_in);\r\nif (ret != 0)\r\nreturn ret;\r\n}\r\nstate->in = freq_in;\r\nstate->out = freq_out;\r\nsnd_soc_update_bits(codec, WM8580_PWRDN2, pwr_mask, pwr_mask);\r\nif (!freq_in || !freq_out)\r\nreturn 0;\r\nsnd_soc_write(codec, WM8580_PLLA1 + offset, pll_div.k & 0x1ff);\r\nsnd_soc_write(codec, WM8580_PLLA2 + offset, (pll_div.k >> 9) & 0x1ff);\r\nsnd_soc_write(codec, WM8580_PLLA3 + offset,\r\n(pll_div.k >> 18 & 0xf) | (pll_div.n << 4));\r\nreg = snd_soc_read(codec, WM8580_PLLA4 + offset);\r\nreg &= ~0x1b;\r\nreg |= pll_div.prescale | pll_div.postscale << 1 |\r\npll_div.freqmode << 3;\r\nsnd_soc_write(codec, WM8580_PLLA4 + offset, reg);\r\nsnd_soc_update_bits(codec, WM8580_PWRDN2, pwr_mask, 0);\r\nreturn 0;\r\n}\r\nstatic int wm8580_paif_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct wm8580_priv *wm8580 = snd_soc_codec_get_drvdata(codec);\r\nu16 paifa = 0;\r\nu16 paifb = 0;\r\nint i, ratio, osr;\r\nswitch (params_width(params)) {\r\ncase 16:\r\npaifa |= 0x8;\r\nbreak;\r\ncase 20:\r\npaifa |= 0x0;\r\npaifb |= WM8580_AIF_LENGTH_20;\r\nbreak;\r\ncase 24:\r\npaifa |= 0x0;\r\npaifb |= WM8580_AIF_LENGTH_24;\r\nbreak;\r\ncase 32:\r\npaifa |= 0x0;\r\npaifb |= WM8580_AIF_LENGTH_32;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nratio = wm8580->sysclk[dai->driver->id] / params_rate(params);\r\nfor (i = 0; i < ARRAY_SIZE(wm8580_sysclk_ratios); i++)\r\nif (ratio == wm8580_sysclk_ratios[i])\r\nbreak;\r\nif (i == ARRAY_SIZE(wm8580_sysclk_ratios)) {\r\ndev_err(codec->dev, "Invalid clock ratio %d/%d\n",\r\nwm8580->sysclk[dai->driver->id], params_rate(params));\r\nreturn -EINVAL;\r\n}\r\npaifa |= i;\r\ndev_dbg(codec->dev, "Running at %dfs with %dHz clock\n",\r\nwm8580_sysclk_ratios[i], wm8580->sysclk[dai->driver->id]);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nswitch (ratio) {\r\ncase 128:\r\ncase 192:\r\nosr = WM8580_DACOSR;\r\ndev_dbg(codec->dev, "Selecting 64x OSR\n");\r\nbreak;\r\ndefault:\r\nosr = 0;\r\ndev_dbg(codec->dev, "Selecting 128x OSR\n");\r\nbreak;\r\n}\r\nsnd_soc_update_bits(codec, WM8580_PAIF3, WM8580_DACOSR, osr);\r\n}\r\nsnd_soc_update_bits(codec, WM8580_PAIF1 + dai->driver->id,\r\nWM8580_AIF_RATE_MASK | WM8580_AIF_BCLKSEL_MASK,\r\npaifa);\r\nsnd_soc_update_bits(codec, WM8580_PAIF3 + dai->driver->id,\r\nWM8580_AIF_LENGTH_MASK, paifb);\r\nreturn 0;\r\n}\r\nstatic int wm8580_set_paif_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nunsigned int aifa;\r\nunsigned int aifb;\r\nint can_invert_lrclk;\r\naifa = snd_soc_read(codec, WM8580_PAIF1 + codec_dai->driver->id);\r\naifb = snd_soc_read(codec, WM8580_PAIF3 + codec_dai->driver->id);\r\naifb &= ~(WM8580_AIF_FMT_MASK | WM8580_AIF_LRP | WM8580_AIF_BCP);\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\naifa &= ~WM8580_AIF_MS;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\naifa |= WM8580_AIF_MS;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\ncan_invert_lrclk = 1;\r\naifb |= WM8580_AIF_FMT_I2S;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\ncan_invert_lrclk = 1;\r\naifb |= WM8580_AIF_FMT_RIGHTJ;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\ncan_invert_lrclk = 1;\r\naifb |= WM8580_AIF_FMT_LEFTJ;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\ncan_invert_lrclk = 0;\r\naifb |= WM8580_AIF_FMT_DSP;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\ncan_invert_lrclk = 0;\r\naifb |= WM8580_AIF_FMT_DSP;\r\naifb |= WM8580_AIF_LRP;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nif (!can_invert_lrclk)\r\nreturn -EINVAL;\r\naifb |= WM8580_AIF_BCP;\r\naifb |= WM8580_AIF_LRP;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\naifb |= WM8580_AIF_BCP;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nif (!can_invert_lrclk)\r\nreturn -EINVAL;\r\naifb |= WM8580_AIF_LRP;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_write(codec, WM8580_PAIF1 + codec_dai->driver->id, aifa);\r\nsnd_soc_write(codec, WM8580_PAIF3 + codec_dai->driver->id, aifb);\r\nreturn 0;\r\n}\r\nstatic int wm8580_set_dai_clkdiv(struct snd_soc_dai *codec_dai,\r\nint div_id, int div)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nunsigned int reg;\r\nswitch (div_id) {\r\ncase WM8580_MCLK:\r\nreg = snd_soc_read(codec, WM8580_PLLB4);\r\nreg &= ~WM8580_PLLB4_MCLKOUTSRC_MASK;\r\nswitch (div) {\r\ncase WM8580_CLKSRC_MCLK:\r\nbreak;\r\ncase WM8580_CLKSRC_PLLA:\r\nreg |= WM8580_PLLB4_MCLKOUTSRC_PLLA;\r\nbreak;\r\ncase WM8580_CLKSRC_PLLB:\r\nreg |= WM8580_PLLB4_MCLKOUTSRC_PLLB;\r\nbreak;\r\ncase WM8580_CLKSRC_OSC:\r\nreg |= WM8580_PLLB4_MCLKOUTSRC_OSC;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_write(codec, WM8580_PLLB4, reg);\r\nbreak;\r\ncase WM8580_CLKOUTSRC:\r\nreg = snd_soc_read(codec, WM8580_PLLB4);\r\nreg &= ~WM8580_PLLB4_CLKOUTSRC_MASK;\r\nswitch (div) {\r\ncase WM8580_CLKSRC_NONE:\r\nbreak;\r\ncase WM8580_CLKSRC_PLLA:\r\nreg |= WM8580_PLLB4_CLKOUTSRC_PLLACLK;\r\nbreak;\r\ncase WM8580_CLKSRC_PLLB:\r\nreg |= WM8580_PLLB4_CLKOUTSRC_PLLBCLK;\r\nbreak;\r\ncase WM8580_CLKSRC_OSC:\r\nreg |= WM8580_PLLB4_CLKOUTSRC_OSCCLK;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_write(codec, WM8580_PLLB4, reg);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8580_set_sysclk(struct snd_soc_dai *dai, int clk_id,\r\nunsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct wm8580_priv *wm8580 = snd_soc_codec_get_drvdata(codec);\r\nint ret, sel, sel_mask, sel_shift;\r\nswitch (dai->driver->id) {\r\ncase WM8580_DAI_PAIFRX:\r\nsel_mask = 0x3;\r\nsel_shift = 0;\r\nbreak;\r\ncase WM8580_DAI_PAIFTX:\r\nsel_mask = 0xc;\r\nsel_shift = 2;\r\nbreak;\r\ndefault:\r\nWARN(1, "Unknown DAI driver ID\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (clk_id) {\r\ncase WM8580_CLKSRC_ADCMCLK:\r\nif (dai->driver->id != WM8580_DAI_PAIFTX)\r\nreturn -EINVAL;\r\nsel = 0 << sel_shift;\r\nbreak;\r\ncase WM8580_CLKSRC_PLLA:\r\nsel = 1 << sel_shift;\r\nbreak;\r\ncase WM8580_CLKSRC_PLLB:\r\nsel = 2 << sel_shift;\r\nbreak;\r\ncase WM8580_CLKSRC_MCLK:\r\nsel = 3 << sel_shift;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Unknown clock %d\n", clk_id);\r\nreturn -EINVAL;\r\n}\r\nwm8580->sysclk[dai->driver->id] = freq;\r\nret = snd_soc_update_bits(codec, WM8580_CLKSEL, sel_mask, sel);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int wm8580_digital_mute(struct snd_soc_dai *codec_dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nunsigned int reg;\r\nreg = snd_soc_read(codec, WM8580_DAC_CONTROL5);\r\nif (mute)\r\nreg |= WM8580_DAC_CONTROL5_MUTEALL;\r\nelse\r\nreg &= ~WM8580_DAC_CONTROL5_MUTEALL;\r\nsnd_soc_write(codec, WM8580_DAC_CONTROL5, reg);\r\nreturn 0;\r\n}\r\nstatic int wm8580_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\ncase SND_SOC_BIAS_PREPARE:\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {\r\nsnd_soc_update_bits(codec, WM8580_PWRDN1,\r\nWM8580_PWRDN1_PWDN |\r\nWM8580_PWRDN1_ALLDACPD, 0);\r\nsnd_soc_update_bits(codec, WM8580_ADC_CONTROL1,\r\n0x100, 0);\r\n}\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nsnd_soc_update_bits(codec, WM8580_PWRDN1,\r\nWM8580_PWRDN1_PWDN, WM8580_PWRDN1_PWDN);\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int wm8580_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8580_priv *wm8580 = snd_soc_codec_get_drvdata(codec);\r\nint ret = 0;\r\nret = regulator_bulk_enable(ARRAY_SIZE(wm8580->supplies),\r\nwm8580->supplies);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to enable supplies: %d\n", ret);\r\ngoto err_regulator_get;\r\n}\r\nret = snd_soc_write(codec, WM8580_RESET, 0);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to reset codec: %d\n", ret);\r\ngoto err_regulator_enable;\r\n}\r\nreturn 0;\r\nerr_regulator_enable:\r\nregulator_bulk_disable(ARRAY_SIZE(wm8580->supplies), wm8580->supplies);\r\nerr_regulator_get:\r\nreturn ret;\r\n}\r\nstatic int wm8580_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8580_priv *wm8580 = snd_soc_codec_get_drvdata(codec);\r\nregulator_bulk_disable(ARRAY_SIZE(wm8580->supplies), wm8580->supplies);\r\nreturn 0;\r\n}\r\nstatic int wm8580_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct wm8580_priv *wm8580;\r\nint ret, i;\r\nwm8580 = devm_kzalloc(&i2c->dev, sizeof(struct wm8580_priv),\r\nGFP_KERNEL);\r\nif (wm8580 == NULL)\r\nreturn -ENOMEM;\r\nwm8580->regmap = devm_regmap_init_i2c(i2c, &wm8580_regmap);\r\nif (IS_ERR(wm8580->regmap))\r\nreturn PTR_ERR(wm8580->regmap);\r\nfor (i = 0; i < ARRAY_SIZE(wm8580->supplies); i++)\r\nwm8580->supplies[i].supply = wm8580_supply_names[i];\r\nret = devm_regulator_bulk_get(&i2c->dev, ARRAY_SIZE(wm8580->supplies),\r\nwm8580->supplies);\r\nif (ret != 0) {\r\ndev_err(&i2c->dev, "Failed to request supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\ni2c_set_clientdata(i2c, wm8580);\r\nret = snd_soc_register_codec(&i2c->dev,\r\n&soc_codec_dev_wm8580, wm8580_dai, ARRAY_SIZE(wm8580_dai));\r\nreturn ret;\r\n}\r\nstatic int wm8580_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}\r\nstatic int __init wm8580_modinit(void)\r\n{\r\nint ret = 0;\r\n#if IS_ENABLED(CONFIG_I2C)\r\nret = i2c_add_driver(&wm8580_i2c_driver);\r\nif (ret != 0) {\r\npr_err("Failed to register WM8580 I2C driver: %d\n", ret);\r\n}\r\n#endif\r\nreturn ret;\r\n}\r\nstatic void __exit wm8580_exit(void)\r\n{\r\n#if IS_ENABLED(CONFIG_I2C)\r\ni2c_del_driver(&wm8580_i2c_driver);\r\n#endif\r\n}
