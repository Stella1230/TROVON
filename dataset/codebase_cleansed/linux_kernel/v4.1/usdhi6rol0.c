static void usdhi6_write(struct usdhi6_host *host, u32 reg, u32 data)\r\n{\r\niowrite32(data, host->base + reg);\r\ndev_vdbg(mmc_dev(host->mmc), "%s(0x%p + 0x%x) = 0x%x\n", __func__,\r\nhost->base, reg, data);\r\n}\r\nstatic void usdhi6_write16(struct usdhi6_host *host, u32 reg, u16 data)\r\n{\r\niowrite16(data, host->base + reg);\r\ndev_vdbg(mmc_dev(host->mmc), "%s(0x%p + 0x%x) = 0x%x\n", __func__,\r\nhost->base, reg, data);\r\n}\r\nstatic u32 usdhi6_read(struct usdhi6_host *host, u32 reg)\r\n{\r\nu32 data = ioread32(host->base + reg);\r\ndev_vdbg(mmc_dev(host->mmc), "%s(0x%p + 0x%x) = 0x%x\n", __func__,\r\nhost->base, reg, data);\r\nreturn data;\r\n}\r\nstatic u16 usdhi6_read16(struct usdhi6_host *host, u32 reg)\r\n{\r\nu16 data = ioread16(host->base + reg);\r\ndev_vdbg(mmc_dev(host->mmc), "%s(0x%p + 0x%x) = 0x%x\n", __func__,\r\nhost->base, reg, data);\r\nreturn data;\r\n}\r\nstatic void usdhi6_irq_enable(struct usdhi6_host *host, u32 info1, u32 info2)\r\n{\r\nhost->status_mask = USDHI6_SD_INFO1_IRQ & ~info1;\r\nhost->status2_mask = USDHI6_SD_INFO2_IRQ & ~info2;\r\nusdhi6_write(host, USDHI6_SD_INFO1_MASK, host->status_mask);\r\nusdhi6_write(host, USDHI6_SD_INFO2_MASK, host->status2_mask);\r\n}\r\nstatic void usdhi6_wait_for_resp(struct usdhi6_host *host)\r\n{\r\nusdhi6_irq_enable(host, USDHI6_SD_INFO1_RSP_END |\r\nUSDHI6_SD_INFO1_ACCESS_END | USDHI6_SD_INFO1_CARD_CD,\r\nUSDHI6_SD_INFO2_ERR);\r\n}\r\nstatic void usdhi6_wait_for_brwe(struct usdhi6_host *host, bool read)\r\n{\r\nusdhi6_irq_enable(host, USDHI6_SD_INFO1_ACCESS_END |\r\nUSDHI6_SD_INFO1_CARD_CD, USDHI6_SD_INFO2_ERR |\r\n(read ? USDHI6_SD_INFO2_BRE : USDHI6_SD_INFO2_BWE));\r\n}\r\nstatic void usdhi6_only_cd(struct usdhi6_host *host)\r\n{\r\nusdhi6_irq_enable(host, USDHI6_SD_INFO1_CARD_CD, 0);\r\n}\r\nstatic void usdhi6_mask_all(struct usdhi6_host *host)\r\n{\r\nusdhi6_irq_enable(host, 0, 0);\r\n}\r\nstatic int usdhi6_error_code(struct usdhi6_host *host)\r\n{\r\nu32 err;\r\nusdhi6_write(host, USDHI6_SD_STOP, USDHI6_SD_STOP_STP);\r\nif (host->io_error &\r\n(USDHI6_SD_INFO2_RSP_TOUT | USDHI6_SD_INFO2_TOUT)) {\r\nu32 rsp54 = usdhi6_read(host, USDHI6_SD_RSP54);\r\nint opc = host->mrq ? host->mrq->cmd->opcode : -1;\r\nerr = usdhi6_read(host, USDHI6_SD_ERR_STS2);\r\nif (host->wait == USDHI6_WAIT_FOR_CMD)\r\ndev_dbg(mmc_dev(host->mmc),\r\n"T-out sts 0x%x, resp 0x%x, state %u, CMD%d\n",\r\nerr, rsp54, host->wait, opc);\r\nelse\r\ndev_warn(mmc_dev(host->mmc),\r\n"T-out sts 0x%x, resp 0x%x, state %u, CMD%d\n",\r\nerr, rsp54, host->wait, opc);\r\nreturn -ETIMEDOUT;\r\n}\r\nerr = usdhi6_read(host, USDHI6_SD_ERR_STS1);\r\nif (err != USDHI6_SD_ERR_STS1_CRC_NO_ERROR)\r\ndev_warn(mmc_dev(host->mmc), "Err sts 0x%x, state %u, CMD%d\n",\r\nerr, host->wait, host->mrq ? host->mrq->cmd->opcode : -1);\r\nif (host->io_error & USDHI6_SD_INFO2_ILA)\r\nreturn -EILSEQ;\r\nreturn -EIO;\r\n}\r\nstatic void usdhi6_blk_bounce(struct usdhi6_host *host,\r\nstruct scatterlist *sg)\r\n{\r\nstruct mmc_data *data = host->mrq->data;\r\nsize_t blk_head = host->head_len;\r\ndev_dbg(mmc_dev(host->mmc), "%s(): CMD%u of %u SG: %ux%u @ 0x%x\n",\r\n__func__, host->mrq->cmd->opcode, data->sg_len,\r\ndata->blksz, data->blocks, sg->offset);\r\nhost->head_pg.page = host->pg.page;\r\nhost->head_pg.mapped = host->pg.mapped;\r\nhost->pg.page = nth_page(host->pg.page, 1);\r\nhost->pg.mapped = kmap(host->pg.page);\r\nhost->blk_page = host->bounce_buf;\r\nhost->offset = 0;\r\nif (data->flags & MMC_DATA_READ)\r\nreturn;\r\nmemcpy(host->bounce_buf, host->head_pg.mapped + PAGE_SIZE - blk_head,\r\nblk_head);\r\nmemcpy(host->bounce_buf + blk_head, host->pg.mapped,\r\ndata->blksz - blk_head);\r\n}\r\nstatic void usdhi6_sg_prep(struct usdhi6_host *host)\r\n{\r\nstruct mmc_request *mrq = host->mrq;\r\nstruct mmc_data *data = mrq->data;\r\nusdhi6_write(host, USDHI6_SD_SECCNT, data->blocks);\r\nhost->sg = data->sg;\r\nhost->offset = host->sg->offset;\r\n}\r\nstatic void *usdhi6_sg_map(struct usdhi6_host *host)\r\n{\r\nstruct mmc_data *data = host->mrq->data;\r\nstruct scatterlist *sg = data->sg_len > 1 ? host->sg : data->sg;\r\nsize_t head = PAGE_SIZE - sg->offset;\r\nsize_t blk_head = head % data->blksz;\r\nWARN(host->pg.page, "%p not properly unmapped!\n", host->pg.page);\r\nif (WARN(sg_dma_len(sg) % data->blksz,\r\n"SG size %u isn't a multiple of block size %u\n",\r\nsg_dma_len(sg), data->blksz))\r\nreturn NULL;\r\nhost->pg.page = sg_page(sg);\r\nhost->pg.mapped = kmap(host->pg.page);\r\nhost->offset = sg->offset;\r\nhost->head_len = blk_head;\r\nif (head < data->blksz)\r\nusdhi6_blk_bounce(host, sg);\r\nelse\r\nhost->blk_page = host->pg.mapped;\r\ndev_dbg(mmc_dev(host->mmc), "Mapped %p (%lx) at %p + %u for CMD%u @ 0x%p\n",\r\nhost->pg.page, page_to_pfn(host->pg.page), host->pg.mapped,\r\nsg->offset, host->mrq->cmd->opcode, host->mrq);\r\nreturn host->blk_page + host->offset;\r\n}\r\nstatic void usdhi6_sg_unmap(struct usdhi6_host *host, bool force)\r\n{\r\nstruct mmc_data *data = host->mrq->data;\r\nstruct page *page = host->head_pg.page;\r\nif (page) {\r\nstruct scatterlist *sg = data->sg_len > 1 ?\r\nhost->sg : data->sg;\r\nsize_t blk_head = host->head_len;\r\nif (!data->error && data->flags & MMC_DATA_READ) {\r\nmemcpy(host->head_pg.mapped + PAGE_SIZE - blk_head,\r\nhost->bounce_buf, blk_head);\r\nmemcpy(host->pg.mapped, host->bounce_buf + blk_head,\r\ndata->blksz - blk_head);\r\n}\r\nflush_dcache_page(page);\r\nkunmap(page);\r\nhost->head_pg.page = NULL;\r\nif (!force && sg_dma_len(sg) + sg->offset >\r\n(host->page_idx << PAGE_SHIFT) + data->blksz - blk_head)\r\nreturn;\r\n}\r\npage = host->pg.page;\r\nif (!page)\r\nreturn;\r\nflush_dcache_page(page);\r\nkunmap(page);\r\nhost->pg.page = NULL;\r\n}\r\nstatic void usdhi6_sg_advance(struct usdhi6_host *host)\r\n{\r\nstruct mmc_data *data = host->mrq->data;\r\nsize_t done, total;\r\nif (host->head_pg.page) {\r\nhost->page_idx++;\r\nhost->offset = data->blksz - host->head_len;\r\nhost->blk_page = host->pg.mapped;\r\nusdhi6_sg_unmap(host, false);\r\n} else {\r\nhost->offset += data->blksz;\r\nif (host->offset == PAGE_SIZE) {\r\nhost->offset = 0;\r\nhost->page_idx++;\r\n}\r\n}\r\ndone = (host->page_idx << PAGE_SHIFT) + host->offset;\r\ntotal = host->sg->offset + sg_dma_len(host->sg);\r\ndev_dbg(mmc_dev(host->mmc), "%s(): %zu of %zu @ %zu\n", __func__,\r\ndone, total, host->offset);\r\nif (done < total && host->offset) {\r\nif (host->offset + data->blksz > PAGE_SIZE)\r\nusdhi6_blk_bounce(host, host->sg);\r\nreturn;\r\n}\r\nusdhi6_sg_unmap(host, false);\r\nif (done == total) {\r\nstruct scatterlist *next = sg_next(host->sg);\r\nhost->page_idx = 0;\r\nif (!next)\r\nhost->wait = USDHI6_WAIT_FOR_DATA_END;\r\nhost->sg = next;\r\nif (WARN(next && sg_dma_len(next) % data->blksz,\r\n"SG size %u isn't a multiple of block size %u\n",\r\nsg_dma_len(next), data->blksz))\r\ndata->error = -EINVAL;\r\nreturn;\r\n}\r\nhost->pg.page = nth_page(sg_page(host->sg), host->page_idx);\r\nhost->pg.mapped = kmap(host->pg.page);\r\nhost->blk_page = host->pg.mapped;\r\ndev_dbg(mmc_dev(host->mmc), "Mapped %p (%lx) at %p for CMD%u @ 0x%p\n",\r\nhost->pg.page, page_to_pfn(host->pg.page), host->pg.mapped,\r\nhost->mrq->cmd->opcode, host->mrq);\r\n}\r\nstatic void usdhi6_dma_release(struct usdhi6_host *host)\r\n{\r\nhost->dma_active = false;\r\nif (host->chan_tx) {\r\nstruct dma_chan *chan = host->chan_tx;\r\nhost->chan_tx = NULL;\r\ndma_release_channel(chan);\r\n}\r\nif (host->chan_rx) {\r\nstruct dma_chan *chan = host->chan_rx;\r\nhost->chan_rx = NULL;\r\ndma_release_channel(chan);\r\n}\r\n}\r\nstatic void usdhi6_dma_stop_unmap(struct usdhi6_host *host)\r\n{\r\nstruct mmc_data *data = host->mrq->data;\r\nif (!host->dma_active)\r\nreturn;\r\nusdhi6_write(host, USDHI6_CC_EXT_MODE, 0);\r\nhost->dma_active = false;\r\nif (data->flags & MMC_DATA_READ)\r\ndma_unmap_sg(host->chan_rx->device->dev, data->sg,\r\ndata->sg_len, DMA_FROM_DEVICE);\r\nelse\r\ndma_unmap_sg(host->chan_tx->device->dev, data->sg,\r\ndata->sg_len, DMA_TO_DEVICE);\r\n}\r\nstatic void usdhi6_dma_complete(void *arg)\r\n{\r\nstruct usdhi6_host *host = arg;\r\nstruct mmc_request *mrq = host->mrq;\r\nif (WARN(!mrq || !mrq->data, "%s: NULL data in DMA completion for %p!\n",\r\ndev_name(mmc_dev(host->mmc)), mrq))\r\nreturn;\r\ndev_dbg(mmc_dev(host->mmc), "%s(): CMD%u DMA completed\n", __func__,\r\nmrq->cmd->opcode);\r\nusdhi6_dma_stop_unmap(host);\r\nusdhi6_wait_for_brwe(host, mrq->data->flags & MMC_DATA_READ);\r\n}\r\nstatic int usdhi6_dma_setup(struct usdhi6_host *host, struct dma_chan *chan,\r\nenum dma_transfer_direction dir)\r\n{\r\nstruct mmc_data *data = host->mrq->data;\r\nstruct scatterlist *sg = data->sg;\r\nstruct dma_async_tx_descriptor *desc = NULL;\r\ndma_cookie_t cookie = -EINVAL;\r\nenum dma_data_direction data_dir;\r\nint ret;\r\nswitch (dir) {\r\ncase DMA_MEM_TO_DEV:\r\ndata_dir = DMA_TO_DEVICE;\r\nbreak;\r\ncase DMA_DEV_TO_MEM:\r\ndata_dir = DMA_FROM_DEVICE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = dma_map_sg(chan->device->dev, sg, data->sg_len, data_dir);\r\nif (ret > 0) {\r\nhost->dma_active = true;\r\ndesc = dmaengine_prep_slave_sg(chan, sg, ret, dir,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\n}\r\nif (desc) {\r\ndesc->callback = usdhi6_dma_complete;\r\ndesc->callback_param = host;\r\ncookie = dmaengine_submit(desc);\r\n}\r\ndev_dbg(mmc_dev(host->mmc), "%s(): mapped %d -> %d, cookie %d @ %p\n",\r\n__func__, data->sg_len, ret, cookie, desc);\r\nif (cookie < 0) {\r\nif (ret >= 0)\r\nret = cookie;\r\nusdhi6_dma_release(host);\r\ndev_warn(mmc_dev(host->mmc),\r\n"DMA failed: %d, falling back to PIO\n", ret);\r\n}\r\nreturn cookie;\r\n}\r\nstatic int usdhi6_dma_start(struct usdhi6_host *host)\r\n{\r\nif (!host->chan_rx || !host->chan_tx)\r\nreturn -ENODEV;\r\nif (host->mrq->data->flags & MMC_DATA_READ)\r\nreturn usdhi6_dma_setup(host, host->chan_rx, DMA_DEV_TO_MEM);\r\nreturn usdhi6_dma_setup(host, host->chan_tx, DMA_MEM_TO_DEV);\r\n}\r\nstatic void usdhi6_dma_kill(struct usdhi6_host *host)\r\n{\r\nstruct mmc_data *data = host->mrq->data;\r\ndev_dbg(mmc_dev(host->mmc), "%s(): SG of %u: %ux%u\n",\r\n__func__, data->sg_len, data->blocks, data->blksz);\r\nif (data->flags & MMC_DATA_READ)\r\ndmaengine_terminate_all(host->chan_rx);\r\nelse\r\ndmaengine_terminate_all(host->chan_tx);\r\n}\r\nstatic void usdhi6_dma_check_error(struct usdhi6_host *host)\r\n{\r\nstruct mmc_data *data = host->mrq->data;\r\ndev_dbg(mmc_dev(host->mmc), "%s(): IO error %d, status 0x%x\n",\r\n__func__, host->io_error, usdhi6_read(host, USDHI6_SD_INFO1));\r\nif (host->io_error) {\r\ndata->error = usdhi6_error_code(host);\r\ndata->bytes_xfered = 0;\r\nusdhi6_dma_kill(host);\r\nusdhi6_dma_release(host);\r\ndev_warn(mmc_dev(host->mmc),\r\n"DMA failed: %d, falling back to PIO\n", data->error);\r\nreturn;\r\n}\r\nif (host->irq_status & USDHI6_SD_INFO1_RSP_END)\r\ndev_warn(mmc_dev(host->mmc), "Unexpected response received!\n");\r\n}\r\nstatic void usdhi6_dma_kick(struct usdhi6_host *host)\r\n{\r\nif (host->mrq->data->flags & MMC_DATA_READ)\r\ndma_async_issue_pending(host->chan_rx);\r\nelse\r\ndma_async_issue_pending(host->chan_tx);\r\n}\r\nstatic void usdhi6_dma_request(struct usdhi6_host *host, phys_addr_t start)\r\n{\r\nstruct dma_slave_config cfg = {\r\n.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES,\r\n.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES,\r\n};\r\nint ret;\r\nhost->chan_tx = dma_request_slave_channel(mmc_dev(host->mmc), "tx");\r\ndev_dbg(mmc_dev(host->mmc), "%s: TX: got channel %p\n", __func__,\r\nhost->chan_tx);\r\nif (!host->chan_tx)\r\nreturn;\r\ncfg.direction = DMA_MEM_TO_DEV;\r\ncfg.dst_addr = start + USDHI6_SD_BUF0;\r\ncfg.dst_maxburst = 128;\r\ncfg.src_addr = 0;\r\nret = dmaengine_slave_config(host->chan_tx, &cfg);\r\nif (ret < 0)\r\ngoto e_release_tx;\r\nhost->chan_rx = dma_request_slave_channel(mmc_dev(host->mmc), "rx");\r\ndev_dbg(mmc_dev(host->mmc), "%s: RX: got channel %p\n", __func__,\r\nhost->chan_rx);\r\nif (!host->chan_rx)\r\ngoto e_release_tx;\r\ncfg.direction = DMA_DEV_TO_MEM;\r\ncfg.src_addr = cfg.dst_addr;\r\ncfg.src_maxburst = 128;\r\ncfg.dst_addr = 0;\r\nret = dmaengine_slave_config(host->chan_rx, &cfg);\r\nif (ret < 0)\r\ngoto e_release_rx;\r\nreturn;\r\ne_release_rx:\r\ndma_release_channel(host->chan_rx);\r\nhost->chan_rx = NULL;\r\ne_release_tx:\r\ndma_release_channel(host->chan_tx);\r\nhost->chan_tx = NULL;\r\n}\r\nstatic void usdhi6_clk_set(struct usdhi6_host *host, struct mmc_ios *ios)\r\n{\r\nunsigned long rate = ios->clock;\r\nu32 val;\r\nunsigned int i;\r\nfor (i = 1000; i; i--) {\r\nif (usdhi6_read(host, USDHI6_SD_INFO2) & USDHI6_SD_INFO2_SCLKDIVEN)\r\nbreak;\r\nusleep_range(10, 100);\r\n}\r\nif (!i) {\r\ndev_err(mmc_dev(host->mmc), "SD bus busy, clock set aborted\n");\r\nreturn;\r\n}\r\nval = usdhi6_read(host, USDHI6_SD_CLK_CTRL) & ~USDHI6_SD_CLK_CTRL_DIV_MASK;\r\nif (rate) {\r\nunsigned long new_rate;\r\nif (host->imclk <= rate) {\r\nif (ios->timing != MMC_TIMING_UHS_DDR50) {\r\nnew_rate = host->imclk;\r\nval |= 0xff;\r\n} else {\r\nnew_rate = host->imclk / 2;\r\n}\r\n} else {\r\nunsigned long div =\r\nroundup_pow_of_two(DIV_ROUND_UP(host->imclk, rate));\r\nval |= div >> 2;\r\nnew_rate = host->imclk / div;\r\n}\r\nif (host->rate == new_rate)\r\nreturn;\r\nhost->rate = new_rate;\r\ndev_dbg(mmc_dev(host->mmc), "target %lu, div %u, set %lu\n",\r\nrate, (val & 0xff) << 2, new_rate);\r\n}\r\nif (host->imclk == rate || host->imclk == host->rate || !rate)\r\nusdhi6_write(host, USDHI6_SD_CLK_CTRL,\r\nval & ~USDHI6_SD_CLK_CTRL_SCLKEN);\r\nif (!rate) {\r\nhost->rate = 0;\r\nreturn;\r\n}\r\nusdhi6_write(host, USDHI6_SD_CLK_CTRL, val);\r\nif (host->imclk == rate || host->imclk == host->rate ||\r\n!(val & USDHI6_SD_CLK_CTRL_SCLKEN))\r\nusdhi6_write(host, USDHI6_SD_CLK_CTRL,\r\nval | USDHI6_SD_CLK_CTRL_SCLKEN);\r\n}\r\nstatic void usdhi6_set_power(struct usdhi6_host *host, struct mmc_ios *ios)\r\n{\r\nstruct mmc_host *mmc = host->mmc;\r\nif (!IS_ERR(mmc->supply.vmmc))\r\nmmc_regulator_set_ocr(mmc, mmc->supply.vmmc,\r\nios->power_mode ? ios->vdd : 0);\r\n}\r\nstatic int usdhi6_reset(struct usdhi6_host *host)\r\n{\r\nint i;\r\nusdhi6_write(host, USDHI6_SOFT_RST, USDHI6_SOFT_RST_RESERVED);\r\ncpu_relax();\r\nusdhi6_write(host, USDHI6_SOFT_RST, USDHI6_SOFT_RST_RESERVED | USDHI6_SOFT_RST_RESET);\r\nfor (i = 1000; i; i--)\r\nif (usdhi6_read(host, USDHI6_SOFT_RST) & USDHI6_SOFT_RST_RESET)\r\nbreak;\r\nreturn i ? 0 : -ETIMEDOUT;\r\n}\r\nstatic void usdhi6_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\r\n{\r\nstruct usdhi6_host *host = mmc_priv(mmc);\r\nu32 option, mode;\r\nint ret;\r\ndev_dbg(mmc_dev(mmc), "%uHz, OCR: %u, power %u, bus-width %u, timing %u\n",\r\nios->clock, ios->vdd, ios->power_mode, ios->bus_width, ios->timing);\r\nswitch (ios->power_mode) {\r\ncase MMC_POWER_OFF:\r\nusdhi6_set_power(host, ios);\r\nusdhi6_only_cd(host);\r\nbreak;\r\ncase MMC_POWER_UP:\r\nret = usdhi6_reset(host);\r\nif (ret < 0) {\r\ndev_err(mmc_dev(mmc), "Cannot reset the interface!\n");\r\n} else {\r\nusdhi6_set_power(host, ios);\r\nusdhi6_only_cd(host);\r\n}\r\nbreak;\r\ncase MMC_POWER_ON:\r\noption = usdhi6_read(host, USDHI6_SD_OPTION);\r\nif (ios->bus_width == MMC_BUS_WIDTH_1) {\r\nif (ios->timing == MMC_TIMING_UHS_DDR50)\r\ndev_err(mmc_dev(mmc),\r\n"4 bits are required for DDR\n");\r\noption |= USDHI6_SD_OPTION_WIDTH_1;\r\nmode = 0;\r\n} else {\r\noption &= ~USDHI6_SD_OPTION_WIDTH_1;\r\nmode = ios->timing == MMC_TIMING_UHS_DDR50;\r\n}\r\nusdhi6_write(host, USDHI6_SD_OPTION, option);\r\nusdhi6_write(host, USDHI6_SDIF_MODE, mode);\r\nbreak;\r\n}\r\nif (host->rate != ios->clock)\r\nusdhi6_clk_set(host, ios);\r\n}\r\nstatic void usdhi6_timeout_set(struct usdhi6_host *host)\r\n{\r\nstruct mmc_request *mrq = host->mrq;\r\nu32 val;\r\nunsigned long ticks;\r\nif (!mrq->data)\r\nticks = host->rate / 1000 * mrq->cmd->busy_timeout;\r\nelse\r\nticks = host->rate / 1000000 * (mrq->data->timeout_ns / 1000) +\r\nmrq->data->timeout_clks;\r\nif (!ticks || ticks > 1 << 27)\r\nval = 14;\r\nelse if (ticks < 1 << 13)\r\nval = 0;\r\nelse\r\nval = order_base_2(ticks) - 13;\r\ndev_dbg(mmc_dev(host->mmc), "Set %s timeout %lu ticks @ %lu Hz\n",\r\nmrq->data ? "data" : "cmd", ticks, host->rate);\r\nusdhi6_write(host, USDHI6_SD_OPTION, (val << USDHI6_SD_OPTION_TIMEOUT_SHIFT) |\r\n(usdhi6_read(host, USDHI6_SD_OPTION) & ~USDHI6_SD_OPTION_TIMEOUT_MASK));\r\n}\r\nstatic void usdhi6_request_done(struct usdhi6_host *host)\r\n{\r\nstruct mmc_request *mrq = host->mrq;\r\nstruct mmc_data *data = mrq->data;\r\nif (WARN(host->pg.page || host->head_pg.page,\r\n"Page %p or %p not unmapped: wait %u, CMD%d(%c) @ +0x%zx %ux%u in SG%u!\n",\r\nhost->pg.page, host->head_pg.page, host->wait, mrq->cmd->opcode,\r\ndata ? (data->flags & MMC_DATA_READ ? 'R' : 'W') : '-',\r\ndata ? host->offset : 0, data ? data->blocks : 0,\r\ndata ? data->blksz : 0, data ? data->sg_len : 0))\r\nusdhi6_sg_unmap(host, true);\r\nif (mrq->cmd->error ||\r\n(data && data->error) ||\r\n(mrq->stop && mrq->stop->error))\r\ndev_dbg(mmc_dev(host->mmc), "%s(CMD%d: %ux%u): err %d %d %d\n",\r\n__func__, mrq->cmd->opcode, data ? data->blocks : 0,\r\ndata ? data->blksz : 0,\r\nmrq->cmd->error,\r\ndata ? data->error : 1,\r\nmrq->stop ? mrq->stop->error : 1);\r\nusdhi6_write(host, USDHI6_CC_EXT_MODE, 0);\r\nhost->wait = USDHI6_WAIT_FOR_REQUEST;\r\nhost->mrq = NULL;\r\nmmc_request_done(host->mmc, mrq);\r\n}\r\nstatic int usdhi6_cmd_flags(struct usdhi6_host *host)\r\n{\r\nstruct mmc_request *mrq = host->mrq;\r\nstruct mmc_command *cmd = mrq->cmd;\r\nu16 opc = cmd->opcode;\r\nif (host->app_cmd) {\r\nhost->app_cmd = false;\r\nopc |= USDHI6_SD_CMD_APP;\r\n}\r\nif (mrq->data) {\r\nopc |= USDHI6_SD_CMD_DATA;\r\nif (mrq->data->flags & MMC_DATA_READ)\r\nopc |= USDHI6_SD_CMD_READ;\r\nif (cmd->opcode == MMC_READ_MULTIPLE_BLOCK ||\r\ncmd->opcode == MMC_WRITE_MULTIPLE_BLOCK ||\r\n(cmd->opcode == SD_IO_RW_EXTENDED &&\r\nmrq->data->blocks > 1)) {\r\nopc |= USDHI6_SD_CMD_MULTI;\r\nif (!mrq->stop)\r\nopc |= USDHI6_SD_CMD_CMD12_AUTO_OFF;\r\n}\r\nswitch (mmc_resp_type(cmd)) {\r\ncase MMC_RSP_NONE:\r\nopc |= USDHI6_SD_CMD_MODE_RSP_NONE;\r\nbreak;\r\ncase MMC_RSP_R1:\r\nopc |= USDHI6_SD_CMD_MODE_RSP_R1;\r\nbreak;\r\ncase MMC_RSP_R1B:\r\nopc |= USDHI6_SD_CMD_MODE_RSP_R1B;\r\nbreak;\r\ncase MMC_RSP_R2:\r\nopc |= USDHI6_SD_CMD_MODE_RSP_R2;\r\nbreak;\r\ncase MMC_RSP_R3:\r\nopc |= USDHI6_SD_CMD_MODE_RSP_R3;\r\nbreak;\r\ndefault:\r\ndev_warn(mmc_dev(host->mmc),\r\n"Unknown response type %d\n",\r\nmmc_resp_type(cmd));\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn opc;\r\n}\r\nstatic int usdhi6_rq_start(struct usdhi6_host *host)\r\n{\r\nstruct mmc_request *mrq = host->mrq;\r\nstruct mmc_command *cmd = mrq->cmd;\r\nstruct mmc_data *data = mrq->data;\r\nint opc = usdhi6_cmd_flags(host);\r\nint i;\r\nif (opc < 0)\r\nreturn opc;\r\nfor (i = 1000; i; i--) {\r\nif (!(usdhi6_read(host, USDHI6_SD_INFO2) & USDHI6_SD_INFO2_CBSY))\r\nbreak;\r\nusleep_range(10, 100);\r\n}\r\nif (!i) {\r\ndev_dbg(mmc_dev(host->mmc), "Command active, request aborted\n");\r\nreturn -EAGAIN;\r\n}\r\nif (data) {\r\nbool use_dma;\r\nint ret = 0;\r\nhost->page_idx = 0;\r\nif (cmd->opcode == SD_IO_RW_EXTENDED && data->blocks > 1) {\r\nswitch (data->blksz) {\r\ncase 512:\r\nbreak;\r\ncase 32:\r\ncase 64:\r\ncase 128:\r\ncase 256:\r\nif (mrq->stop)\r\nret = -EINVAL;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\n} else if ((cmd->opcode == MMC_READ_MULTIPLE_BLOCK ||\r\ncmd->opcode == MMC_WRITE_MULTIPLE_BLOCK) &&\r\ndata->blksz != 512) {\r\nret = -EINVAL;\r\n}\r\nif (ret < 0) {\r\ndev_warn(mmc_dev(host->mmc), "%s(): %u blocks of %u bytes\n",\r\n__func__, data->blocks, data->blksz);\r\nreturn -EINVAL;\r\n}\r\nif (cmd->opcode == MMC_READ_MULTIPLE_BLOCK ||\r\ncmd->opcode == MMC_WRITE_MULTIPLE_BLOCK ||\r\n(cmd->opcode == SD_IO_RW_EXTENDED &&\r\ndata->blocks > 1))\r\nusdhi6_sg_prep(host);\r\nusdhi6_write(host, USDHI6_SD_SIZE, data->blksz);\r\nif ((data->blksz >= USDHI6_MIN_DMA ||\r\ndata->blocks > 1) &&\r\n(data->blksz % 4 ||\r\ndata->sg->offset % 4))\r\ndev_dbg(mmc_dev(host->mmc),\r\n"Bad SG of %u: %ux%u @ %u\n", data->sg_len,\r\ndata->blksz, data->blocks, data->sg->offset);\r\nuse_dma = data->blksz >= USDHI6_MIN_DMA &&\r\n!(data->blksz % 4) &&\r\nusdhi6_dma_start(host) >= DMA_MIN_COOKIE;\r\nif (use_dma)\r\nusdhi6_write(host, USDHI6_CC_EXT_MODE, USDHI6_CC_EXT_MODE_SDRW);\r\ndev_dbg(mmc_dev(host->mmc),\r\n"%s(): request opcode %u, %u blocks of %u bytes in %u segments, %s %s @+0x%x%s\n",\r\n__func__, cmd->opcode, data->blocks, data->blksz,\r\ndata->sg_len, use_dma ? "DMA" : "PIO",\r\ndata->flags & MMC_DATA_READ ? "read" : "write",\r\ndata->sg->offset, mrq->stop ? " + stop" : "");\r\n} else {\r\ndev_dbg(mmc_dev(host->mmc), "%s(): request opcode %u\n",\r\n__func__, cmd->opcode);\r\n}\r\nusdhi6_wait_for_resp(host);\r\nhost->wait = USDHI6_WAIT_FOR_CMD;\r\nschedule_delayed_work(&host->timeout_work, host->timeout);\r\nusdhi6_write(host, USDHI6_SD_STOP,\r\ndata && data->blocks > 1 ? USDHI6_SD_STOP_SEC : 0);\r\nusdhi6_write(host, USDHI6_SD_ARG, cmd->arg);\r\nusdhi6_write(host, USDHI6_SD_CMD, opc);\r\nreturn 0;\r\n}\r\nstatic void usdhi6_request(struct mmc_host *mmc, struct mmc_request *mrq)\r\n{\r\nstruct usdhi6_host *host = mmc_priv(mmc);\r\nint ret;\r\ncancel_delayed_work_sync(&host->timeout_work);\r\nhost->mrq = mrq;\r\nhost->sg = NULL;\r\nusdhi6_timeout_set(host);\r\nret = usdhi6_rq_start(host);\r\nif (ret < 0) {\r\nmrq->cmd->error = ret;\r\nusdhi6_request_done(host);\r\n}\r\n}\r\nstatic int usdhi6_get_cd(struct mmc_host *mmc)\r\n{\r\nstruct usdhi6_host *host = mmc_priv(mmc);\r\nu32 status = usdhi6_read(host, USDHI6_SD_INFO1) & USDHI6_SD_INFO1_CD;\r\nreturn !status ^ !(mmc->caps2 & MMC_CAP2_CD_ACTIVE_HIGH);\r\n}\r\nstatic int usdhi6_get_ro(struct mmc_host *mmc)\r\n{\r\nstruct usdhi6_host *host = mmc_priv(mmc);\r\nu32 status = usdhi6_read(host, USDHI6_SD_INFO1) & USDHI6_SD_INFO1_WP;\r\nreturn !status ^ !(mmc->caps2 & MMC_CAP2_RO_ACTIVE_HIGH);\r\n}\r\nstatic void usdhi6_enable_sdio_irq(struct mmc_host *mmc, int enable)\r\n{\r\nstruct usdhi6_host *host = mmc_priv(mmc);\r\ndev_dbg(mmc_dev(mmc), "%s(): %sable\n", __func__, enable ? "en" : "dis");\r\nif (enable) {\r\nhost->sdio_mask = USDHI6_SDIO_INFO1_IRQ & ~USDHI6_SDIO_INFO1_IOIRQ;\r\nusdhi6_write(host, USDHI6_SDIO_INFO1_MASK, host->sdio_mask);\r\nusdhi6_write(host, USDHI6_SDIO_MODE, 1);\r\n} else {\r\nusdhi6_write(host, USDHI6_SDIO_MODE, 0);\r\nusdhi6_write(host, USDHI6_SDIO_INFO1_MASK, USDHI6_SDIO_INFO1_IRQ);\r\nhost->sdio_mask = USDHI6_SDIO_INFO1_IRQ;\r\n}\r\n}\r\nstatic void usdhi6_resp_cmd12(struct usdhi6_host *host)\r\n{\r\nstruct mmc_command *cmd = host->mrq->stop;\r\ncmd->resp[0] = usdhi6_read(host, USDHI6_SD_RSP10);\r\n}\r\nstatic void usdhi6_resp_read(struct usdhi6_host *host)\r\n{\r\nstruct mmc_command *cmd = host->mrq->cmd;\r\nu32 *rsp = cmd->resp, tmp = 0;\r\nint i;\r\nif (mmc_resp_type(cmd) == MMC_RSP_NONE)\r\nreturn;\r\nif (!(host->irq_status & USDHI6_SD_INFO1_RSP_END)) {\r\ndev_err(mmc_dev(host->mmc),\r\n"CMD%d: response expected but is missing!\n", cmd->opcode);\r\nreturn;\r\n}\r\nif (mmc_resp_type(cmd) & MMC_RSP_136)\r\nfor (i = 0; i < 4; i++) {\r\nif (i)\r\nrsp[3 - i] = tmp >> 24;\r\ntmp = usdhi6_read(host, USDHI6_SD_RSP10 + i * 8);\r\nrsp[3 - i] |= tmp << 8;\r\n}\r\nelse if (cmd->opcode == MMC_READ_MULTIPLE_BLOCK ||\r\ncmd->opcode == MMC_WRITE_MULTIPLE_BLOCK)\r\nrsp[0] = usdhi6_read(host, USDHI6_SD_RSP54);\r\nelse\r\nrsp[0] = usdhi6_read(host, USDHI6_SD_RSP10);\r\ndev_dbg(mmc_dev(host->mmc), "Response 0x%x\n", rsp[0]);\r\n}\r\nstatic int usdhi6_blk_read(struct usdhi6_host *host)\r\n{\r\nstruct mmc_data *data = host->mrq->data;\r\nu32 *p;\r\nint i, rest;\r\nif (host->io_error) {\r\ndata->error = usdhi6_error_code(host);\r\ngoto error;\r\n}\r\nif (host->pg.page) {\r\np = host->blk_page + host->offset;\r\n} else {\r\np = usdhi6_sg_map(host);\r\nif (!p) {\r\ndata->error = -ENOMEM;\r\ngoto error;\r\n}\r\n}\r\nfor (i = 0; i < data->blksz / 4; i++, p++)\r\n*p = usdhi6_read(host, USDHI6_SD_BUF0);\r\nrest = data->blksz % 4;\r\nfor (i = 0; i < (rest + 1) / 2; i++) {\r\nu16 d = usdhi6_read16(host, USDHI6_SD_BUF0);\r\n((u8 *)p)[2 * i] = ((u8 *)&d)[0];\r\nif (rest > 1 && !i)\r\n((u8 *)p)[2 * i + 1] = ((u8 *)&d)[1];\r\n}\r\nreturn 0;\r\nerror:\r\ndev_dbg(mmc_dev(host->mmc), "%s(): %d\n", __func__, data->error);\r\nhost->wait = USDHI6_WAIT_FOR_REQUEST;\r\nreturn data->error;\r\n}\r\nstatic int usdhi6_blk_write(struct usdhi6_host *host)\r\n{\r\nstruct mmc_data *data = host->mrq->data;\r\nu32 *p;\r\nint i, rest;\r\nif (host->io_error) {\r\ndata->error = usdhi6_error_code(host);\r\ngoto error;\r\n}\r\nif (host->pg.page) {\r\np = host->blk_page + host->offset;\r\n} else {\r\np = usdhi6_sg_map(host);\r\nif (!p) {\r\ndata->error = -ENOMEM;\r\ngoto error;\r\n}\r\n}\r\nfor (i = 0; i < data->blksz / 4; i++, p++)\r\nusdhi6_write(host, USDHI6_SD_BUF0, *p);\r\nrest = data->blksz % 4;\r\nfor (i = 0; i < (rest + 1) / 2; i++) {\r\nu16 d;\r\n((u8 *)&d)[0] = ((u8 *)p)[2 * i];\r\nif (rest > 1 && !i)\r\n((u8 *)&d)[1] = ((u8 *)p)[2 * i + 1];\r\nelse\r\n((u8 *)&d)[1] = 0;\r\nusdhi6_write16(host, USDHI6_SD_BUF0, d);\r\n}\r\nreturn 0;\r\nerror:\r\ndev_dbg(mmc_dev(host->mmc), "%s(): %d\n", __func__, data->error);\r\nhost->wait = USDHI6_WAIT_FOR_REQUEST;\r\nreturn data->error;\r\n}\r\nstatic int usdhi6_stop_cmd(struct usdhi6_host *host)\r\n{\r\nstruct mmc_request *mrq = host->mrq;\r\nswitch (mrq->cmd->opcode) {\r\ncase MMC_READ_MULTIPLE_BLOCK:\r\ncase MMC_WRITE_MULTIPLE_BLOCK:\r\nif (mrq->stop->opcode == MMC_STOP_TRANSMISSION) {\r\nhost->wait = USDHI6_WAIT_FOR_STOP;\r\nreturn 0;\r\n}\r\ndefault:\r\ndev_err(mmc_dev(host->mmc),\r\n"unsupported stop CMD%d for CMD%d\n",\r\nmrq->stop->opcode, mrq->cmd->opcode);\r\nmrq->stop->error = -EOPNOTSUPP;\r\n}\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic bool usdhi6_end_cmd(struct usdhi6_host *host)\r\n{\r\nstruct mmc_request *mrq = host->mrq;\r\nstruct mmc_command *cmd = mrq->cmd;\r\nif (host->io_error) {\r\ncmd->error = usdhi6_error_code(host);\r\nreturn false;\r\n}\r\nusdhi6_resp_read(host);\r\nif (!mrq->data)\r\nreturn false;\r\nif (host->dma_active) {\r\nusdhi6_dma_kick(host);\r\nif (!mrq->stop)\r\nhost->wait = USDHI6_WAIT_FOR_DMA;\r\nelse if (usdhi6_stop_cmd(host) < 0)\r\nreturn false;\r\n} else if (mrq->data->flags & MMC_DATA_READ) {\r\nif (cmd->opcode == MMC_READ_MULTIPLE_BLOCK ||\r\n(cmd->opcode == SD_IO_RW_EXTENDED &&\r\nmrq->data->blocks > 1))\r\nhost->wait = USDHI6_WAIT_FOR_MREAD;\r\nelse\r\nhost->wait = USDHI6_WAIT_FOR_READ;\r\n} else {\r\nif (cmd->opcode == MMC_WRITE_MULTIPLE_BLOCK ||\r\n(cmd->opcode == SD_IO_RW_EXTENDED &&\r\nmrq->data->blocks > 1))\r\nhost->wait = USDHI6_WAIT_FOR_MWRITE;\r\nelse\r\nhost->wait = USDHI6_WAIT_FOR_WRITE;\r\n}\r\nreturn true;\r\n}\r\nstatic bool usdhi6_read_block(struct usdhi6_host *host)\r\n{\r\nint ret = usdhi6_blk_read(host);\r\nusdhi6_sg_unmap(host, true);\r\nif (ret < 0)\r\nreturn false;\r\nhost->wait = USDHI6_WAIT_FOR_DATA_END;\r\nreturn true;\r\n}\r\nstatic bool usdhi6_mread_block(struct usdhi6_host *host)\r\n{\r\nint ret = usdhi6_blk_read(host);\r\nif (ret < 0)\r\nreturn false;\r\nusdhi6_sg_advance(host);\r\nreturn !host->mrq->data->error &&\r\n(host->wait != USDHI6_WAIT_FOR_DATA_END || !host->mrq->stop);\r\n}\r\nstatic bool usdhi6_write_block(struct usdhi6_host *host)\r\n{\r\nint ret = usdhi6_blk_write(host);\r\nusdhi6_sg_unmap(host, true);\r\nif (ret < 0)\r\nreturn false;\r\nhost->wait = USDHI6_WAIT_FOR_DATA_END;\r\nreturn true;\r\n}\r\nstatic bool usdhi6_mwrite_block(struct usdhi6_host *host)\r\n{\r\nint ret = usdhi6_blk_write(host);\r\nif (ret < 0)\r\nreturn false;\r\nusdhi6_sg_advance(host);\r\nreturn !host->mrq->data->error &&\r\n(host->wait != USDHI6_WAIT_FOR_DATA_END || !host->mrq->stop);\r\n}\r\nstatic irqreturn_t usdhi6_sd_bh(int irq, void *dev_id)\r\n{\r\nstruct usdhi6_host *host = dev_id;\r\nstruct mmc_request *mrq;\r\nstruct mmc_command *cmd;\r\nstruct mmc_data *data;\r\nbool io_wait = false;\r\ncancel_delayed_work_sync(&host->timeout_work);\r\nmrq = host->mrq;\r\nif (!mrq)\r\nreturn IRQ_HANDLED;\r\ncmd = mrq->cmd;\r\ndata = mrq->data;\r\nswitch (host->wait) {\r\ncase USDHI6_WAIT_FOR_REQUEST:\r\nreturn IRQ_HANDLED;\r\ncase USDHI6_WAIT_FOR_CMD:\r\nio_wait = usdhi6_end_cmd(host);\r\nbreak;\r\ncase USDHI6_WAIT_FOR_MREAD:\r\nio_wait = usdhi6_mread_block(host);\r\nbreak;\r\ncase USDHI6_WAIT_FOR_READ:\r\nio_wait = usdhi6_read_block(host);\r\nbreak;\r\ncase USDHI6_WAIT_FOR_MWRITE:\r\nio_wait = usdhi6_mwrite_block(host);\r\nbreak;\r\ncase USDHI6_WAIT_FOR_WRITE:\r\nio_wait = usdhi6_write_block(host);\r\nbreak;\r\ncase USDHI6_WAIT_FOR_DMA:\r\nusdhi6_dma_check_error(host);\r\nbreak;\r\ncase USDHI6_WAIT_FOR_STOP:\r\nusdhi6_write(host, USDHI6_SD_STOP, 0);\r\nif (host->io_error) {\r\nint ret = usdhi6_error_code(host);\r\nif (mrq->stop)\r\nmrq->stop->error = ret;\r\nelse\r\nmrq->data->error = ret;\r\ndev_warn(mmc_dev(host->mmc), "%s(): %d\n", __func__, ret);\r\nbreak;\r\n}\r\nusdhi6_resp_cmd12(host);\r\nmrq->stop->error = 0;\r\nbreak;\r\ncase USDHI6_WAIT_FOR_DATA_END:\r\nif (host->io_error) {\r\nmrq->data->error = usdhi6_error_code(host);\r\ndev_warn(mmc_dev(host->mmc), "%s(): %d\n", __func__,\r\nmrq->data->error);\r\n}\r\nbreak;\r\ndefault:\r\ncmd->error = -EFAULT;\r\ndev_err(mmc_dev(host->mmc), "Invalid state %u\n", host->wait);\r\nusdhi6_request_done(host);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (io_wait) {\r\nschedule_delayed_work(&host->timeout_work, host->timeout);\r\nif (!host->dma_active)\r\nusdhi6_wait_for_brwe(host, mrq->data->flags & MMC_DATA_READ);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (!cmd->error) {\r\nif (data) {\r\nif (!data->error) {\r\nif (host->wait != USDHI6_WAIT_FOR_STOP &&\r\nhost->mrq->stop &&\r\n!host->mrq->stop->error &&\r\n!usdhi6_stop_cmd(host)) {\r\nusdhi6_wait_for_resp(host);\r\nschedule_delayed_work(&host->timeout_work,\r\nhost->timeout);\r\nreturn IRQ_HANDLED;\r\n}\r\ndata->bytes_xfered = data->blocks * data->blksz;\r\n} else {\r\ndev_warn(mmc_dev(host->mmc), "%s(): data error %d\n",\r\n__func__, data->error);\r\nusdhi6_sg_unmap(host, true);\r\n}\r\n} else if (cmd->opcode == MMC_APP_CMD) {\r\nhost->app_cmd = true;\r\n}\r\n}\r\nusdhi6_request_done(host);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t usdhi6_sd(int irq, void *dev_id)\r\n{\r\nstruct usdhi6_host *host = dev_id;\r\nu16 status, status2, error;\r\nstatus = usdhi6_read(host, USDHI6_SD_INFO1) & ~host->status_mask &\r\n~USDHI6_SD_INFO1_CARD;\r\nstatus2 = usdhi6_read(host, USDHI6_SD_INFO2) & ~host->status2_mask;\r\nusdhi6_only_cd(host);\r\ndev_dbg(mmc_dev(host->mmc),\r\n"IRQ status = 0x%08x, status2 = 0x%08x\n", status, status2);\r\nif (!status && !status2)\r\nreturn IRQ_NONE;\r\nerror = status2 & USDHI6_SD_INFO2_ERR;\r\nif (USDHI6_SD_INFO1_IRQ & status)\r\nusdhi6_write(host, USDHI6_SD_INFO1,\r\n0xffff & ~(USDHI6_SD_INFO1_IRQ & status));\r\nif (USDHI6_SD_INFO2_IRQ & status2) {\r\nif (error)\r\nstatus2 |= USDHI6_SD_INFO2_BWE | USDHI6_SD_INFO2_BRE;\r\nusdhi6_write(host, USDHI6_SD_INFO2,\r\n0xffff & ~(USDHI6_SD_INFO2_IRQ & status2));\r\n}\r\nhost->io_error = error;\r\nhost->irq_status = status;\r\nif (error) {\r\nif (host->wait != USDHI6_WAIT_FOR_CMD ||\r\nerror != USDHI6_SD_INFO2_RSP_TOUT)\r\ndev_warn(mmc_dev(host->mmc),\r\n"%s(): INFO2 error bits 0x%08x\n",\r\n__func__, error);\r\nelse\r\ndev_dbg(mmc_dev(host->mmc),\r\n"%s(): INFO2 error bits 0x%08x\n",\r\n__func__, error);\r\n}\r\nreturn IRQ_WAKE_THREAD;\r\n}\r\nstatic irqreturn_t usdhi6_sdio(int irq, void *dev_id)\r\n{\r\nstruct usdhi6_host *host = dev_id;\r\nu32 status = usdhi6_read(host, USDHI6_SDIO_INFO1) & ~host->sdio_mask;\r\ndev_dbg(mmc_dev(host->mmc), "%s(): status 0x%x\n", __func__, status);\r\nif (!status)\r\nreturn IRQ_NONE;\r\nusdhi6_write(host, USDHI6_SDIO_INFO1, ~status);\r\nmmc_signal_sdio_irq(host->mmc);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t usdhi6_cd(int irq, void *dev_id)\r\n{\r\nstruct usdhi6_host *host = dev_id;\r\nstruct mmc_host *mmc = host->mmc;\r\nu16 status;\r\nstatus = usdhi6_read(host, USDHI6_SD_INFO1) & ~host->status_mask &\r\nUSDHI6_SD_INFO1_CARD;\r\nif (!status)\r\nreturn IRQ_NONE;\r\nusdhi6_write(host, USDHI6_SD_INFO1, !status);\r\nif (!work_pending(&mmc->detect.work) &&\r\n(((status & USDHI6_SD_INFO1_CARD_INSERT) &&\r\n!mmc->card) ||\r\n((status & USDHI6_SD_INFO1_CARD_EJECT) &&\r\nmmc->card)))\r\nmmc_detect_change(mmc, msecs_to_jiffies(100));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void usdhi6_timeout_work(struct work_struct *work)\r\n{\r\nstruct delayed_work *d = container_of(work, struct delayed_work, work);\r\nstruct usdhi6_host *host = container_of(d, struct usdhi6_host, timeout_work);\r\nstruct mmc_request *mrq = host->mrq;\r\nstruct mmc_data *data = mrq ? mrq->data : NULL;\r\ndev_warn(mmc_dev(host->mmc),\r\n"%s timeout wait %u CMD%d: IRQ 0x%08x:0x%08x, last IRQ 0x%08x\n",\r\nhost->dma_active ? "DMA" : "PIO",\r\nhost->wait, mrq ? mrq->cmd->opcode : -1,\r\nusdhi6_read(host, USDHI6_SD_INFO1),\r\nusdhi6_read(host, USDHI6_SD_INFO2), host->irq_status);\r\nif (host->dma_active) {\r\nusdhi6_dma_kill(host);\r\nusdhi6_dma_stop_unmap(host);\r\n}\r\nswitch (host->wait) {\r\ndefault:\r\ndev_err(mmc_dev(host->mmc), "Invalid state %u\n", host->wait);\r\ncase USDHI6_WAIT_FOR_CMD:\r\nusdhi6_error_code(host);\r\nif (mrq)\r\nmrq->cmd->error = -ETIMEDOUT;\r\nbreak;\r\ncase USDHI6_WAIT_FOR_STOP:\r\nusdhi6_error_code(host);\r\nmrq->stop->error = -ETIMEDOUT;\r\nbreak;\r\ncase USDHI6_WAIT_FOR_DMA:\r\ncase USDHI6_WAIT_FOR_MREAD:\r\ncase USDHI6_WAIT_FOR_MWRITE:\r\ncase USDHI6_WAIT_FOR_READ:\r\ncase USDHI6_WAIT_FOR_WRITE:\r\ndev_dbg(mmc_dev(host->mmc),\r\n"%c: page #%u @ +0x%zx %ux%u in SG%u. Current SG %u bytes @ %u\n",\r\ndata->flags & MMC_DATA_READ ? 'R' : 'W', host->page_idx,\r\nhost->offset, data->blocks, data->blksz, data->sg_len,\r\nsg_dma_len(host->sg), host->sg->offset);\r\nusdhi6_sg_unmap(host, true);\r\ncase USDHI6_WAIT_FOR_DATA_END:\r\nusdhi6_error_code(host);\r\ndata->error = -ETIMEDOUT;\r\n}\r\nif (mrq)\r\nusdhi6_request_done(host);\r\n}\r\nstatic int usdhi6_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct mmc_host *mmc;\r\nstruct usdhi6_host *host;\r\nstruct resource *res;\r\nint irq_cd, irq_sd, irq_sdio;\r\nu32 version;\r\nint ret;\r\nif (!dev->of_node)\r\nreturn -ENODEV;\r\nirq_cd = platform_get_irq_byname(pdev, "card detect");\r\nirq_sd = platform_get_irq_byname(pdev, "data");\r\nirq_sdio = platform_get_irq_byname(pdev, "SDIO");\r\nif (irq_sd < 0 || irq_sdio < 0)\r\nreturn -ENODEV;\r\nmmc = mmc_alloc_host(sizeof(struct usdhi6_host), dev);\r\nif (!mmc)\r\nreturn -ENOMEM;\r\nret = mmc_of_parse(mmc);\r\nif (ret < 0)\r\ngoto e_free_mmc;\r\nmmc_regulator_get_supply(mmc);\r\nhost = mmc_priv(mmc);\r\nhost->mmc = mmc;\r\nhost->wait = USDHI6_WAIT_FOR_REQUEST;\r\nhost->timeout = msecs_to_jiffies(4000);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nhost->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(host->base)) {\r\nret = PTR_ERR(host->base);\r\ngoto e_free_mmc;\r\n}\r\nhost->clk = devm_clk_get(dev, NULL);\r\nif (IS_ERR(host->clk))\r\ngoto e_free_mmc;\r\nhost->imclk = clk_get_rate(host->clk);\r\nret = clk_prepare_enable(host->clk);\r\nif (ret < 0)\r\ngoto e_free_mmc;\r\nversion = usdhi6_read(host, USDHI6_VERSION);\r\nif ((version & 0xfff) != 0xa0d) {\r\ndev_err(dev, "Version not recognized %x\n", version);\r\ngoto e_clk_off;\r\n}\r\ndev_info(dev, "A USDHI6ROL0 SD host detected with %d ports\n",\r\nusdhi6_read(host, USDHI6_SD_PORT_SEL) >> USDHI6_SD_PORT_SEL_PORTS_SHIFT);\r\nusdhi6_mask_all(host);\r\nif (irq_cd >= 0) {\r\nret = devm_request_irq(dev, irq_cd, usdhi6_cd, 0,\r\ndev_name(dev), host);\r\nif (ret < 0)\r\ngoto e_clk_off;\r\n} else {\r\nmmc->caps |= MMC_CAP_NEEDS_POLL;\r\n}\r\nret = devm_request_threaded_irq(dev, irq_sd, usdhi6_sd, usdhi6_sd_bh, 0,\r\ndev_name(dev), host);\r\nif (ret < 0)\r\ngoto e_clk_off;\r\nret = devm_request_irq(dev, irq_sdio, usdhi6_sdio, 0,\r\ndev_name(dev), host);\r\nif (ret < 0)\r\ngoto e_clk_off;\r\nINIT_DELAYED_WORK(&host->timeout_work, usdhi6_timeout_work);\r\nusdhi6_dma_request(host, res->start);\r\nmmc->ops = &usdhi6_ops;\r\nmmc->caps |= MMC_CAP_SD_HIGHSPEED | MMC_CAP_MMC_HIGHSPEED |\r\nMMC_CAP_UHS_SDR50 | MMC_CAP_UHS_DDR50 | MMC_CAP_SDIO_IRQ;\r\nmmc->max_segs = 32;\r\nmmc->max_blk_size = 512;\r\nmmc->max_req_size = PAGE_CACHE_SIZE * mmc->max_segs;\r\nmmc->max_blk_count = mmc->max_req_size / mmc->max_blk_size;\r\nmmc->max_seg_size = mmc->max_req_size;\r\nif (!mmc->f_max)\r\nmmc->f_max = host->imclk;\r\nmmc->f_min = host->imclk / 512;\r\nplatform_set_drvdata(pdev, host);\r\nret = mmc_add_host(mmc);\r\nif (ret < 0)\r\ngoto e_clk_off;\r\nreturn 0;\r\ne_clk_off:\r\nclk_disable_unprepare(host->clk);\r\ne_free_mmc:\r\nmmc_free_host(mmc);\r\nreturn ret;\r\n}\r\nstatic int usdhi6_remove(struct platform_device *pdev)\r\n{\r\nstruct usdhi6_host *host = platform_get_drvdata(pdev);\r\nmmc_remove_host(host->mmc);\r\nusdhi6_mask_all(host);\r\ncancel_delayed_work_sync(&host->timeout_work);\r\nusdhi6_dma_release(host);\r\nclk_disable_unprepare(host->clk);\r\nmmc_free_host(host->mmc);\r\nreturn 0;\r\n}
