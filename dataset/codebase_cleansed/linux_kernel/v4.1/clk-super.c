static u8 clk_super_get_parent(struct clk_hw *hw)\r\n{\r\nstruct tegra_clk_super_mux *mux = to_clk_super_mux(hw);\r\nu32 val, state;\r\nu8 source, shift;\r\nval = readl_relaxed(mux->reg);\r\nstate = val & SUPER_STATE_MASK;\r\nBUG_ON((state != super_state(SUPER_STATE_RUN)) &&\r\n(state != super_state(SUPER_STATE_IDLE)));\r\nshift = (state == super_state(SUPER_STATE_IDLE)) ?\r\nsuper_state_to_src_shift(mux, SUPER_STATE_IDLE) :\r\nsuper_state_to_src_shift(mux, SUPER_STATE_RUN);\r\nsource = (val >> shift) & super_state_to_src_mask(mux);\r\nif ((mux->flags & TEGRA_DIVIDER_2) && !(val & SUPER_LP_DIV2_BYPASS) &&\r\n(source == mux->pllx_index))\r\nsource = mux->div2_index;\r\nreturn source;\r\n}\r\nstatic int clk_super_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct tegra_clk_super_mux *mux = to_clk_super_mux(hw);\r\nu32 val, state;\r\nint err = 0;\r\nu8 parent_index, shift;\r\nunsigned long flags = 0;\r\nif (mux->lock)\r\nspin_lock_irqsave(mux->lock, flags);\r\nval = readl_relaxed(mux->reg);\r\nstate = val & SUPER_STATE_MASK;\r\nBUG_ON((state != super_state(SUPER_STATE_RUN)) &&\r\n(state != super_state(SUPER_STATE_IDLE)));\r\nshift = (state == super_state(SUPER_STATE_IDLE)) ?\r\nsuper_state_to_src_shift(mux, SUPER_STATE_IDLE) :\r\nsuper_state_to_src_shift(mux, SUPER_STATE_RUN);\r\nif ((mux->flags & TEGRA_DIVIDER_2) && ((index == mux->div2_index) ||\r\n(index == mux->pllx_index))) {\r\nparent_index = clk_super_get_parent(hw);\r\nif ((parent_index == mux->div2_index) ||\r\n(parent_index == mux->pllx_index)) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nval ^= SUPER_LP_DIV2_BYPASS;\r\nwritel_relaxed(val, mux->reg);\r\nudelay(2);\r\nif (index == mux->div2_index)\r\nindex = mux->pllx_index;\r\n}\r\nval &= ~((super_state_to_src_mask(mux)) << shift);\r\nval |= (index & (super_state_to_src_mask(mux))) << shift;\r\nwritel_relaxed(val, mux->reg);\r\nudelay(2);\r\nout:\r\nif (mux->lock)\r\nspin_unlock_irqrestore(mux->lock, flags);\r\nreturn err;\r\n}\r\nstruct clk *tegra_clk_register_super_mux(const char *name,\r\nconst char **parent_names, u8 num_parents,\r\nunsigned long flags, void __iomem *reg, u8 clk_super_flags,\r\nu8 width, u8 pllx_index, u8 div2_index, spinlock_t *lock)\r\n{\r\nstruct tegra_clk_super_mux *super;\r\nstruct clk *clk;\r\nstruct clk_init_data init;\r\nsuper = kzalloc(sizeof(*super), GFP_KERNEL);\r\nif (!super) {\r\npr_err("%s: could not allocate super clk\n", __func__);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ninit.name = name;\r\ninit.ops = &tegra_clk_super_ops;\r\ninit.flags = flags;\r\ninit.parent_names = parent_names;\r\ninit.num_parents = num_parents;\r\nsuper->reg = reg;\r\nsuper->pllx_index = pllx_index;\r\nsuper->div2_index = div2_index;\r\nsuper->lock = lock;\r\nsuper->width = width;\r\nsuper->flags = clk_super_flags;\r\nsuper->hw.init = &init;\r\nclk = clk_register(NULL, &super->hw);\r\nif (IS_ERR(clk))\r\nkfree(super);\r\nreturn clk;\r\n}
