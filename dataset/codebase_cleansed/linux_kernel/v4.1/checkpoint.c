static inline void __buffer_unlink_first(struct journal_head *jh)\r\n{\r\ntransaction_t *transaction = jh->b_cp_transaction;\r\njh->b_cpnext->b_cpprev = jh->b_cpprev;\r\njh->b_cpprev->b_cpnext = jh->b_cpnext;\r\nif (transaction->t_checkpoint_list == jh) {\r\ntransaction->t_checkpoint_list = jh->b_cpnext;\r\nif (transaction->t_checkpoint_list == jh)\r\ntransaction->t_checkpoint_list = NULL;\r\n}\r\n}\r\nstatic inline void __buffer_unlink(struct journal_head *jh)\r\n{\r\ntransaction_t *transaction = jh->b_cp_transaction;\r\n__buffer_unlink_first(jh);\r\nif (transaction->t_checkpoint_io_list == jh) {\r\ntransaction->t_checkpoint_io_list = jh->b_cpnext;\r\nif (transaction->t_checkpoint_io_list == jh)\r\ntransaction->t_checkpoint_io_list = NULL;\r\n}\r\n}\r\nstatic inline void __buffer_relink_io(struct journal_head *jh)\r\n{\r\ntransaction_t *transaction = jh->b_cp_transaction;\r\n__buffer_unlink_first(jh);\r\nif (!transaction->t_checkpoint_io_list) {\r\njh->b_cpnext = jh->b_cpprev = jh;\r\n} else {\r\njh->b_cpnext = transaction->t_checkpoint_io_list;\r\njh->b_cpprev = transaction->t_checkpoint_io_list->b_cpprev;\r\njh->b_cpprev->b_cpnext = jh;\r\njh->b_cpnext->b_cpprev = jh;\r\n}\r\ntransaction->t_checkpoint_io_list = jh;\r\n}\r\nstatic int __try_to_free_cp_buf(struct journal_head *jh)\r\n{\r\nint ret = 0;\r\nstruct buffer_head *bh = jh2bh(jh);\r\nif (jh->b_jlist == BJ_None && !buffer_locked(bh) &&\r\n!buffer_dirty(bh) && !buffer_write_io_error(bh)) {\r\nget_bh(bh);\r\nJBUFFER_TRACE(jh, "remove from checkpoint list");\r\nret = __journal_remove_checkpoint(jh) + 1;\r\njbd_unlock_bh_state(bh);\r\nBUFFER_TRACE(bh, "release");\r\n__brelse(bh);\r\n} else {\r\njbd_unlock_bh_state(bh);\r\n}\r\nreturn ret;\r\n}\r\nvoid __log_wait_for_space(journal_t *journal)\r\n{\r\nint nblocks, space_left;\r\nassert_spin_locked(&journal->j_state_lock);\r\nnblocks = jbd_space_needed(journal);\r\nwhile (__log_space_left(journal) < nblocks) {\r\nif (journal->j_flags & JFS_ABORT)\r\nreturn;\r\nspin_unlock(&journal->j_state_lock);\r\nmutex_lock(&journal->j_checkpoint_mutex);\r\nspin_lock(&journal->j_state_lock);\r\nspin_lock(&journal->j_list_lock);\r\nnblocks = jbd_space_needed(journal);\r\nspace_left = __log_space_left(journal);\r\nif (space_left < nblocks) {\r\nint chkpt = journal->j_checkpoint_transactions != NULL;\r\ntid_t tid = 0;\r\nif (journal->j_committing_transaction)\r\ntid = journal->j_committing_transaction->t_tid;\r\nspin_unlock(&journal->j_list_lock);\r\nspin_unlock(&journal->j_state_lock);\r\nif (chkpt) {\r\nlog_do_checkpoint(journal);\r\n} else if (cleanup_journal_tail(journal) == 0) {\r\n;\r\n} else if (tid) {\r\nlog_wait_commit(journal, tid);\r\n} else {\r\nprintk(KERN_ERR "%s: needed %d blocks and "\r\n"only had %d space available\n",\r\n__func__, nblocks, space_left);\r\nprintk(KERN_ERR "%s: no way to get more "\r\n"journal space\n", __func__);\r\nWARN_ON(1);\r\njournal_abort(journal, 0);\r\n}\r\nspin_lock(&journal->j_state_lock);\r\n} else {\r\nspin_unlock(&journal->j_list_lock);\r\n}\r\nmutex_unlock(&journal->j_checkpoint_mutex);\r\n}\r\n}\r\nstatic void jbd_sync_bh(journal_t *journal, struct buffer_head *bh)\r\n__releases(journal->j_list_lock)\r\n{\r\nget_bh(bh);\r\nspin_unlock(&journal->j_list_lock);\r\njbd_lock_bh_state(bh);\r\njbd_unlock_bh_state(bh);\r\nput_bh(bh);\r\n}\r\nstatic int __wait_cp_io(journal_t *journal, transaction_t *transaction)\r\n{\r\nstruct journal_head *jh;\r\nstruct buffer_head *bh;\r\ntid_t this_tid;\r\nint released = 0;\r\nint ret = 0;\r\nthis_tid = transaction->t_tid;\r\nrestart:\r\nif (journal->j_checkpoint_transactions != transaction ||\r\ntransaction->t_tid != this_tid)\r\nreturn ret;\r\nwhile (!released && transaction->t_checkpoint_io_list) {\r\njh = transaction->t_checkpoint_io_list;\r\nbh = jh2bh(jh);\r\nif (!jbd_trylock_bh_state(bh)) {\r\njbd_sync_bh(journal, bh);\r\nspin_lock(&journal->j_list_lock);\r\ngoto restart;\r\n}\r\nget_bh(bh);\r\nif (buffer_locked(bh)) {\r\nspin_unlock(&journal->j_list_lock);\r\njbd_unlock_bh_state(bh);\r\nwait_on_buffer(bh);\r\nBUFFER_TRACE(bh, "brelse");\r\n__brelse(bh);\r\nspin_lock(&journal->j_list_lock);\r\ngoto restart;\r\n}\r\nif (unlikely(buffer_write_io_error(bh)))\r\nret = -EIO;\r\nreleased = __journal_remove_checkpoint(jh);\r\njbd_unlock_bh_state(bh);\r\n__brelse(bh);\r\n}\r\nreturn ret;\r\n}\r\nstatic void\r\n__flush_batch(journal_t *journal, struct buffer_head **bhs, int *batch_count)\r\n{\r\nint i;\r\nstruct blk_plug plug;\r\nblk_start_plug(&plug);\r\nfor (i = 0; i < *batch_count; i++)\r\nwrite_dirty_buffer(bhs[i], WRITE_SYNC);\r\nblk_finish_plug(&plug);\r\nfor (i = 0; i < *batch_count; i++) {\r\nstruct buffer_head *bh = bhs[i];\r\nclear_buffer_jwrite(bh);\r\nBUFFER_TRACE(bh, "brelse");\r\n__brelse(bh);\r\n}\r\n*batch_count = 0;\r\n}\r\nstatic int __process_buffer(journal_t *journal, struct journal_head *jh,\r\nstruct buffer_head **bhs, int *batch_count)\r\n{\r\nstruct buffer_head *bh = jh2bh(jh);\r\nint ret = 0;\r\nif (buffer_locked(bh)) {\r\nget_bh(bh);\r\nspin_unlock(&journal->j_list_lock);\r\njbd_unlock_bh_state(bh);\r\nwait_on_buffer(bh);\r\nBUFFER_TRACE(bh, "brelse");\r\n__brelse(bh);\r\nret = 1;\r\n} else if (jh->b_transaction != NULL) {\r\ntransaction_t *t = jh->b_transaction;\r\ntid_t tid = t->t_tid;\r\nspin_unlock(&journal->j_list_lock);\r\njbd_unlock_bh_state(bh);\r\nlog_start_commit(journal, tid);\r\nlog_wait_commit(journal, tid);\r\nret = 1;\r\n} else if (!buffer_dirty(bh)) {\r\nret = 1;\r\nif (unlikely(buffer_write_io_error(bh)))\r\nret = -EIO;\r\nget_bh(bh);\r\nJ_ASSERT_JH(jh, !buffer_jbddirty(bh));\r\nBUFFER_TRACE(bh, "remove from checkpoint");\r\n__journal_remove_checkpoint(jh);\r\nspin_unlock(&journal->j_list_lock);\r\njbd_unlock_bh_state(bh);\r\n__brelse(bh);\r\n} else {\r\nBUFFER_TRACE(bh, "queue");\r\nget_bh(bh);\r\nJ_ASSERT_BH(bh, !buffer_jwrite(bh));\r\nset_buffer_jwrite(bh);\r\nbhs[*batch_count] = bh;\r\n__buffer_relink_io(jh);\r\njbd_unlock_bh_state(bh);\r\n(*batch_count)++;\r\nif (*batch_count == NR_BATCH) {\r\nspin_unlock(&journal->j_list_lock);\r\n__flush_batch(journal, bhs, batch_count);\r\nret = 1;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint log_do_checkpoint(journal_t *journal)\r\n{\r\ntransaction_t *transaction;\r\ntid_t this_tid;\r\nint result;\r\njbd_debug(1, "Start checkpoint\n");\r\nresult = cleanup_journal_tail(journal);\r\ntrace_jbd_checkpoint(journal, result);\r\njbd_debug(1, "cleanup_journal_tail returned %d\n", result);\r\nif (result <= 0)\r\nreturn result;\r\nresult = 0;\r\nspin_lock(&journal->j_list_lock);\r\nif (!journal->j_checkpoint_transactions)\r\ngoto out;\r\ntransaction = journal->j_checkpoint_transactions;\r\nthis_tid = transaction->t_tid;\r\nrestart:\r\nif (journal->j_checkpoint_transactions == transaction &&\r\ntransaction->t_tid == this_tid) {\r\nint batch_count = 0;\r\nstruct buffer_head *bhs[NR_BATCH];\r\nstruct journal_head *jh;\r\nint retry = 0, err;\r\nwhile (!retry && transaction->t_checkpoint_list) {\r\nstruct buffer_head *bh;\r\njh = transaction->t_checkpoint_list;\r\nbh = jh2bh(jh);\r\nif (!jbd_trylock_bh_state(bh)) {\r\njbd_sync_bh(journal, bh);\r\nretry = 1;\r\nbreak;\r\n}\r\nretry = __process_buffer(journal, jh, bhs,&batch_count);\r\nif (retry < 0 && !result)\r\nresult = retry;\r\nif (!retry && (need_resched() ||\r\nspin_needbreak(&journal->j_list_lock))) {\r\nspin_unlock(&journal->j_list_lock);\r\nretry = 1;\r\nbreak;\r\n}\r\n}\r\nif (batch_count) {\r\nif (!retry) {\r\nspin_unlock(&journal->j_list_lock);\r\nretry = 1;\r\n}\r\n__flush_batch(journal, bhs, &batch_count);\r\n}\r\nif (retry) {\r\nspin_lock(&journal->j_list_lock);\r\ngoto restart;\r\n}\r\nerr = __wait_cp_io(journal, transaction);\r\nif (!result)\r\nresult = err;\r\n}\r\nout:\r\nspin_unlock(&journal->j_list_lock);\r\nif (result < 0)\r\njournal_abort(journal, result);\r\nelse\r\nresult = cleanup_journal_tail(journal);\r\nreturn (result < 0) ? result : 0;\r\n}\r\nint cleanup_journal_tail(journal_t *journal)\r\n{\r\ntransaction_t * transaction;\r\ntid_t first_tid;\r\nunsigned int blocknr, freed;\r\nif (is_journal_aborted(journal))\r\nreturn 1;\r\nspin_lock(&journal->j_state_lock);\r\nspin_lock(&journal->j_list_lock);\r\ntransaction = journal->j_checkpoint_transactions;\r\nif (transaction) {\r\nfirst_tid = transaction->t_tid;\r\nblocknr = transaction->t_log_start;\r\n} else if ((transaction = journal->j_committing_transaction) != NULL) {\r\nfirst_tid = transaction->t_tid;\r\nblocknr = transaction->t_log_start;\r\n} else if ((transaction = journal->j_running_transaction) != NULL) {\r\nfirst_tid = transaction->t_tid;\r\nblocknr = journal->j_head;\r\n} else {\r\nfirst_tid = journal->j_transaction_sequence;\r\nblocknr = journal->j_head;\r\n}\r\nspin_unlock(&journal->j_list_lock);\r\nJ_ASSERT(blocknr != 0);\r\nif (journal->j_tail_sequence == first_tid) {\r\nspin_unlock(&journal->j_state_lock);\r\nreturn 1;\r\n}\r\nspin_unlock(&journal->j_state_lock);\r\njournal_update_sb_log_tail(journal, first_tid, blocknr,\r\nWRITE_FLUSH_FUA);\r\nspin_lock(&journal->j_state_lock);\r\nfreed = blocknr - journal->j_tail;\r\nif (blocknr < journal->j_tail)\r\nfreed = freed + journal->j_last - journal->j_first;\r\ntrace_jbd_cleanup_journal_tail(journal, first_tid, blocknr, freed);\r\njbd_debug(1,\r\n"Cleaning journal tail from %d to %d (offset %u), "\r\n"freeing %u\n",\r\njournal->j_tail_sequence, first_tid, blocknr, freed);\r\njournal->j_free += freed;\r\njournal->j_tail_sequence = first_tid;\r\njournal->j_tail = blocknr;\r\nspin_unlock(&journal->j_state_lock);\r\nreturn 0;\r\n}\r\nstatic int journal_clean_one_cp_list(struct journal_head *jh, int *released)\r\n{\r\nstruct journal_head *last_jh;\r\nstruct journal_head *next_jh = jh;\r\nint ret, freed = 0;\r\n*released = 0;\r\nif (!jh)\r\nreturn 0;\r\nlast_jh = jh->b_cpprev;\r\ndo {\r\njh = next_jh;\r\nnext_jh = jh->b_cpnext;\r\nif (jbd_trylock_bh_state(jh2bh(jh))) {\r\nret = __try_to_free_cp_buf(jh);\r\nif (ret) {\r\nfreed++;\r\nif (ret == 2) {\r\n*released = 1;\r\nreturn freed;\r\n}\r\n}\r\n}\r\nif (need_resched())\r\nreturn freed;\r\n} while (jh != last_jh);\r\nreturn freed;\r\n}\r\nint __journal_clean_checkpoint_list(journal_t *journal)\r\n{\r\ntransaction_t *transaction, *last_transaction, *next_transaction;\r\nint ret = 0;\r\nint released;\r\ntransaction = journal->j_checkpoint_transactions;\r\nif (!transaction)\r\ngoto out;\r\nlast_transaction = transaction->t_cpprev;\r\nnext_transaction = transaction;\r\ndo {\r\ntransaction = next_transaction;\r\nnext_transaction = transaction->t_cpnext;\r\nret += journal_clean_one_cp_list(transaction->\r\nt_checkpoint_list, &released);\r\nif (need_resched())\r\ngoto out;\r\nif (released)\r\ncontinue;\r\nret += journal_clean_one_cp_list(transaction->\r\nt_checkpoint_io_list, &released);\r\nif (need_resched())\r\ngoto out;\r\n} while (transaction != last_transaction);\r\nout:\r\nreturn ret;\r\n}\r\nint __journal_remove_checkpoint(struct journal_head *jh)\r\n{\r\ntransaction_t *transaction;\r\njournal_t *journal;\r\nint ret = 0;\r\nJBUFFER_TRACE(jh, "entry");\r\nif ((transaction = jh->b_cp_transaction) == NULL) {\r\nJBUFFER_TRACE(jh, "not on transaction");\r\ngoto out;\r\n}\r\njournal = transaction->t_journal;\r\nJBUFFER_TRACE(jh, "removing from transaction");\r\n__buffer_unlink(jh);\r\njh->b_cp_transaction = NULL;\r\njournal_put_journal_head(jh);\r\nif (transaction->t_checkpoint_list != NULL ||\r\ntransaction->t_checkpoint_io_list != NULL)\r\ngoto out;\r\nif (transaction->t_state != T_FINISHED)\r\ngoto out;\r\n__journal_drop_transaction(journal, transaction);\r\nwake_up(&journal->j_wait_logspace);\r\nret = 1;\r\nout:\r\nreturn ret;\r\n}\r\nvoid __journal_insert_checkpoint(struct journal_head *jh,\r\ntransaction_t *transaction)\r\n{\r\nJBUFFER_TRACE(jh, "entry");\r\nJ_ASSERT_JH(jh, buffer_dirty(jh2bh(jh)) || buffer_jbddirty(jh2bh(jh)));\r\nJ_ASSERT_JH(jh, jh->b_cp_transaction == NULL);\r\njournal_grab_journal_head(jh2bh(jh));\r\njh->b_cp_transaction = transaction;\r\nif (!transaction->t_checkpoint_list) {\r\njh->b_cpnext = jh->b_cpprev = jh;\r\n} else {\r\njh->b_cpnext = transaction->t_checkpoint_list;\r\njh->b_cpprev = transaction->t_checkpoint_list->b_cpprev;\r\njh->b_cpprev->b_cpnext = jh;\r\njh->b_cpnext->b_cpprev = jh;\r\n}\r\ntransaction->t_checkpoint_list = jh;\r\n}\r\nvoid __journal_drop_transaction(journal_t *journal, transaction_t *transaction)\r\n{\r\nassert_spin_locked(&journal->j_list_lock);\r\nif (transaction->t_cpnext) {\r\ntransaction->t_cpnext->t_cpprev = transaction->t_cpprev;\r\ntransaction->t_cpprev->t_cpnext = transaction->t_cpnext;\r\nif (journal->j_checkpoint_transactions == transaction)\r\njournal->j_checkpoint_transactions =\r\ntransaction->t_cpnext;\r\nif (journal->j_checkpoint_transactions == transaction)\r\njournal->j_checkpoint_transactions = NULL;\r\n}\r\nJ_ASSERT(transaction->t_state == T_FINISHED);\r\nJ_ASSERT(transaction->t_buffers == NULL);\r\nJ_ASSERT(transaction->t_sync_datalist == NULL);\r\nJ_ASSERT(transaction->t_forget == NULL);\r\nJ_ASSERT(transaction->t_iobuf_list == NULL);\r\nJ_ASSERT(transaction->t_shadow_list == NULL);\r\nJ_ASSERT(transaction->t_log_list == NULL);\r\nJ_ASSERT(transaction->t_checkpoint_list == NULL);\r\nJ_ASSERT(transaction->t_checkpoint_io_list == NULL);\r\nJ_ASSERT(transaction->t_updates == 0);\r\nJ_ASSERT(journal->j_committing_transaction != transaction);\r\nJ_ASSERT(journal->j_running_transaction != transaction);\r\ntrace_jbd_drop_transaction(journal, transaction);\r\njbd_debug(1, "Dropping transaction %d, all done\n", transaction->t_tid);\r\nkfree(transaction);\r\n}
