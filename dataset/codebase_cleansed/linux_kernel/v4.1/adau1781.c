static int adau1781_dejitter_fixup(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct adau *adau = snd_soc_codec_get_drvdata(codec);\r\nregmap_write(adau->regmap, ADAU1781_DEJITTER, 0);\r\nif (!adau->master)\r\nregmap_write(adau->regmap, ADAU1781_DEJITTER, 5);\r\nreturn 0;\r\n}\r\nstatic int adau1781_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct adau *adau = snd_soc_codec_get_drvdata(codec);\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nregmap_update_bits(adau->regmap, ADAU17X1_CLOCK_CONTROL,\r\nADAU17X1_CLOCK_CONTROL_SYSCLK_EN,\r\nADAU17X1_CLOCK_CONTROL_SYSCLK_EN);\r\nregmap_update_bits(adau->regmap, ADAU1781_DIG_PWDN1, 0x8, 0x8);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nregmap_update_bits(adau->regmap, ADAU1781_DIG_PWDN1, 0xc, 0x0);\r\nregmap_update_bits(adau->regmap, ADAU17X1_CLOCK_CONTROL,\r\nADAU17X1_CLOCK_CONTROL_SYSCLK_EN, 0);\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic bool adau1781_readable_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase ADAU1781_DMIC_BEEP_CTRL:\r\ncase ADAU1781_LEFT_PGA:\r\ncase ADAU1781_RIGHT_PGA:\r\ncase ADAU1781_LEFT_PLAYBACK_MIXER:\r\ncase ADAU1781_RIGHT_PLAYBACK_MIXER:\r\ncase ADAU1781_MONO_PLAYBACK_MIXER:\r\ncase ADAU1781_LEFT_LINEOUT:\r\ncase ADAU1781_RIGHT_LINEOUT:\r\ncase ADAU1781_SPEAKER:\r\ncase ADAU1781_BEEP_ZC:\r\ncase ADAU1781_DEJITTER:\r\ncase ADAU1781_DIG_PWDN0:\r\ncase ADAU1781_DIG_PWDN1:\r\nreturn true;\r\ndefault:\r\nbreak;\r\n}\r\nreturn adau17x1_readable_register(dev, reg);\r\n}\r\nstatic int adau1781_set_input_mode(struct adau *adau, unsigned int reg,\r\nbool differential)\r\n{\r\nunsigned int val;\r\nif (differential)\r\nval = ADAU1781_INPUT_DIFFERNTIAL;\r\nelse\r\nval = 0;\r\nreturn regmap_update_bits(adau->regmap, reg,\r\nADAU1781_INPUT_DIFFERNTIAL, val);\r\n}\r\nstatic int adau1781_codec_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct adau1781_platform_data *pdata = dev_get_platdata(codec->dev);\r\nstruct adau *adau = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nret = adau17x1_add_widgets(codec);\r\nif (ret)\r\nreturn ret;\r\nif (pdata) {\r\nret = adau1781_set_input_mode(adau, ADAU1781_LEFT_PGA,\r\npdata->left_input_differential);\r\nif (ret)\r\nreturn ret;\r\nret = adau1781_set_input_mode(adau, ADAU1781_RIGHT_PGA,\r\npdata->right_input_differential);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (pdata && pdata->use_dmic) {\r\nret = snd_soc_dapm_new_controls(&codec->dapm,\r\nadau1781_dmic_dapm_widgets,\r\nARRAY_SIZE(adau1781_dmic_dapm_widgets));\r\nif (ret)\r\nreturn ret;\r\nret = snd_soc_dapm_add_routes(&codec->dapm,\r\nadau1781_dmic_dapm_routes,\r\nARRAY_SIZE(adau1781_dmic_dapm_routes));\r\nif (ret)\r\nreturn ret;\r\n} else {\r\nret = snd_soc_dapm_add_routes(&codec->dapm,\r\nadau1781_adc_dapm_routes,\r\nARRAY_SIZE(adau1781_adc_dapm_routes));\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = adau17x1_add_routes(codec);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nint adau1781_probe(struct device *dev, struct regmap *regmap,\r\nenum adau17x1_type type, void (*switch_mode)(struct device *dev))\r\n{\r\nconst char *firmware_name;\r\nint ret;\r\nswitch (type) {\r\ncase ADAU1381:\r\nfirmware_name = ADAU1381_FIRMWARE;\r\nbreak;\r\ncase ADAU1781:\r\nfirmware_name = ADAU1781_FIRMWARE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = adau17x1_probe(dev, regmap, type, switch_mode, firmware_name);\r\nif (ret)\r\nreturn ret;\r\nreturn snd_soc_register_codec(dev, &adau1781_codec_driver,\r\n&adau1781_dai_driver, 1);\r\n}
