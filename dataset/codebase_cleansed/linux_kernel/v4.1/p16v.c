static void snd_p16v_pcm_free_substream(struct snd_pcm_runtime *runtime)\r\n{\r\nstruct snd_emu10k1_pcm *epcm = runtime->private_data;\r\nkfree(epcm);\r\n}\r\nstatic int snd_p16v_pcm_open_playback_channel(struct snd_pcm_substream *substream, int channel_id)\r\n{\r\nstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\r\nstruct snd_emu10k1_voice *channel = &(emu->p16v_voices[channel_id]);\r\nstruct snd_emu10k1_pcm *epcm;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err;\r\nepcm = kzalloc(sizeof(*epcm), GFP_KERNEL);\r\nif (epcm == NULL)\r\nreturn -ENOMEM;\r\nepcm->emu = emu;\r\nepcm->substream = substream;\r\nruntime->private_data = epcm;\r\nruntime->private_free = snd_p16v_pcm_free_substream;\r\nruntime->hw = snd_p16v_playback_hw;\r\nchannel->emu = emu;\r\nchannel->number = channel_id;\r\nchannel->use=1;\r\n#if 0\r\ndev_dbg(emu->card->dev,\r\n"p16v: open channel_id=%d, channel=%p, use=0x%x\n",\r\nchannel_id, channel, channel->use);\r\ndev_dbg(emu->card->dev, "open:channel_id=%d, chip=%p, channel=%p\n",\r\nchannel_id, chip, channel);\r\n#endif\r\nchannel->epcm = epcm;\r\nif ((err = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS)) < 0)\r\nreturn err;\r\nruntime->sync.id32[0] = substream->pcm->card->number;\r\nruntime->sync.id32[1] = 'P';\r\nruntime->sync.id32[2] = 16;\r\nruntime->sync.id32[3] = 'V';\r\nreturn 0;\r\n}\r\nstatic int snd_p16v_pcm_open_capture_channel(struct snd_pcm_substream *substream, int channel_id)\r\n{\r\nstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\r\nstruct snd_emu10k1_voice *channel = &(emu->p16v_capture_voice);\r\nstruct snd_emu10k1_pcm *epcm;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err;\r\nepcm = kzalloc(sizeof(*epcm), GFP_KERNEL);\r\nif (epcm == NULL)\r\nreturn -ENOMEM;\r\nepcm->emu = emu;\r\nepcm->substream = substream;\r\nruntime->private_data = epcm;\r\nruntime->private_free = snd_p16v_pcm_free_substream;\r\nruntime->hw = snd_p16v_capture_hw;\r\nchannel->emu = emu;\r\nchannel->number = channel_id;\r\nchannel->use=1;\r\n#if 0\r\ndev_dbg(emu->card->dev,\r\n"p16v: open channel_id=%d, channel=%p, use=0x%x\n",\r\nchannel_id, channel, channel->use);\r\ndev_dbg(emu->card->dev, "open:channel_id=%d, chip=%p, channel=%p\n",\r\nchannel_id, chip, channel);\r\n#endif\r\nchannel->epcm = epcm;\r\nif ((err = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS)) < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int snd_p16v_pcm_close_playback(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\r\nemu->p16v_voices[substream->pcm->device - emu->p16v_device_offset].use = 0;\r\nreturn 0;\r\n}\r\nstatic int snd_p16v_pcm_close_capture(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\r\nemu->p16v_capture_voice.use = 0;\r\nreturn 0;\r\n}\r\nstatic int snd_p16v_pcm_open_playback_front(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_p16v_pcm_open_playback_channel(substream, PCM_FRONT_CHANNEL);\r\n}\r\nstatic int snd_p16v_pcm_open_capture(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_p16v_pcm_open_capture_channel(substream, 0);\r\n}\r\nstatic int snd_p16v_pcm_hw_params_playback(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nint result;\r\nresult = snd_pcm_lib_malloc_pages(substream,\r\nparams_buffer_bytes(hw_params));\r\nreturn result;\r\n}\r\nstatic int snd_p16v_pcm_hw_params_capture(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nint result;\r\nresult = snd_pcm_lib_malloc_pages(substream,\r\nparams_buffer_bytes(hw_params));\r\nreturn result;\r\n}\r\nstatic int snd_p16v_pcm_hw_free_playback(struct snd_pcm_substream *substream)\r\n{\r\nint result;\r\nresult = snd_pcm_lib_free_pages(substream);\r\nreturn result;\r\n}\r\nstatic int snd_p16v_pcm_hw_free_capture(struct snd_pcm_substream *substream)\r\n{\r\nint result;\r\nresult = snd_pcm_lib_free_pages(substream);\r\nreturn result;\r\n}\r\nstatic int snd_p16v_pcm_prepare_playback(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint channel = substream->pcm->device - emu->p16v_device_offset;\r\nu32 *table_base = (u32 *)(emu->p16v_buffer.area+(8*16*channel));\r\nu32 period_size_bytes = frames_to_bytes(runtime, runtime->period_size);\r\nint i;\r\nu32 tmp;\r\n#if 0\r\ndev_dbg(emu->card->dev,\r\n"prepare:channel_number=%d, rate=%d, "\r\n"format=0x%x, channels=%d, buffer_size=%ld, "\r\n"period_size=%ld, periods=%u, frames_to_bytes=%d\n",\r\nchannel, runtime->rate, runtime->format, runtime->channels,\r\nruntime->buffer_size, runtime->period_size,\r\nruntime->periods, frames_to_bytes(runtime, 1));\r\ndev_dbg(emu->card->dev,\r\n"dma_addr=%x, dma_area=%p, table_base=%p\n",\r\nruntime->dma_addr, runtime->dma_area, table_base);\r\ndev_dbg(emu->card->dev,\r\n"dma_addr=%x, dma_area=%p, dma_bytes(size)=%x\n",\r\nemu->p16v_buffer.addr, emu->p16v_buffer.area,\r\nemu->p16v_buffer.bytes);\r\n#endif\r\ntmp = snd_emu10k1_ptr_read(emu, A_SPDIF_SAMPLERATE, channel);\r\nswitch (runtime->rate) {\r\ncase 44100:\r\nsnd_emu10k1_ptr_write(emu, A_SPDIF_SAMPLERATE, channel, (tmp & ~0xe0e0) | 0x8080);\r\nbreak;\r\ncase 96000:\r\nsnd_emu10k1_ptr_write(emu, A_SPDIF_SAMPLERATE, channel, (tmp & ~0xe0e0) | 0x4040);\r\nbreak;\r\ncase 192000:\r\nsnd_emu10k1_ptr_write(emu, A_SPDIF_SAMPLERATE, channel, (tmp & ~0xe0e0) | 0x2020);\r\nbreak;\r\ncase 48000:\r\ndefault:\r\nsnd_emu10k1_ptr_write(emu, A_SPDIF_SAMPLERATE, channel, (tmp & ~0xe0e0) | 0x0000);\r\nbreak;\r\n}\r\nfor(i = 0; i < runtime->periods; i++) {\r\ntable_base[i*2]=runtime->dma_addr+(i*period_size_bytes);\r\ntable_base[(i*2)+1]=period_size_bytes<<16;\r\n}\r\nsnd_emu10k1_ptr20_write(emu, PLAYBACK_LIST_ADDR, channel, emu->p16v_buffer.addr+(8*16*channel));\r\nsnd_emu10k1_ptr20_write(emu, PLAYBACK_LIST_SIZE, channel, (runtime->periods - 1) << 19);\r\nsnd_emu10k1_ptr20_write(emu, PLAYBACK_LIST_PTR, channel, 0);\r\nsnd_emu10k1_ptr20_write(emu, PLAYBACK_DMA_ADDR, channel, runtime->dma_addr);\r\nsnd_emu10k1_ptr20_write(emu, PLAYBACK_PERIOD_SIZE, channel, 0);\r\nsnd_emu10k1_ptr20_write(emu, PLAYBACK_POINTER, channel, 0);\r\nsnd_emu10k1_ptr20_write(emu, 0x07, channel, 0x0);\r\nsnd_emu10k1_ptr20_write(emu, 0x08, channel, 0);\r\nreturn 0;\r\n}\r\nstatic int snd_p16v_pcm_prepare_capture(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint channel = substream->pcm->device - emu->p16v_device_offset;\r\nu32 tmp;\r\ntmp = snd_emu10k1_ptr_read(emu, A_SPDIF_SAMPLERATE, channel);\r\nswitch (runtime->rate) {\r\ncase 44100:\r\nsnd_emu10k1_ptr_write(emu, A_SPDIF_SAMPLERATE, channel, (tmp & ~0x0e00) | 0x0800);\r\nbreak;\r\ncase 96000:\r\nsnd_emu10k1_ptr_write(emu, A_SPDIF_SAMPLERATE, channel, (tmp & ~0x0e00) | 0x0400);\r\nbreak;\r\ncase 192000:\r\nsnd_emu10k1_ptr_write(emu, A_SPDIF_SAMPLERATE, channel, (tmp & ~0x0e00) | 0x0200);\r\nbreak;\r\ncase 48000:\r\ndefault:\r\nsnd_emu10k1_ptr_write(emu, A_SPDIF_SAMPLERATE, channel, (tmp & ~0x0e00) | 0x0000);\r\nbreak;\r\n}\r\nsnd_emu10k1_ptr20_write(emu, 0x13, channel, 0);\r\nsnd_emu10k1_ptr20_write(emu, CAPTURE_DMA_ADDR, channel, runtime->dma_addr);\r\nsnd_emu10k1_ptr20_write(emu, CAPTURE_BUFFER_SIZE, channel, frames_to_bytes(runtime, runtime->buffer_size) << 16);\r\nsnd_emu10k1_ptr20_write(emu, CAPTURE_POINTER, channel, 0);\r\nreturn 0;\r\n}\r\nstatic void snd_p16v_intr_enable(struct snd_emu10k1 *emu, unsigned int intrenb)\r\n{\r\nunsigned long flags;\r\nunsigned int enable;\r\nspin_lock_irqsave(&emu->emu_lock, flags);\r\nenable = inl(emu->port + INTE2) | intrenb;\r\noutl(enable, emu->port + INTE2);\r\nspin_unlock_irqrestore(&emu->emu_lock, flags);\r\n}\r\nstatic void snd_p16v_intr_disable(struct snd_emu10k1 *emu, unsigned int intrenb)\r\n{\r\nunsigned long flags;\r\nunsigned int disable;\r\nspin_lock_irqsave(&emu->emu_lock, flags);\r\ndisable = inl(emu->port + INTE2) & (~intrenb);\r\noutl(disable, emu->port + INTE2);\r\nspin_unlock_irqrestore(&emu->emu_lock, flags);\r\n}\r\nstatic int snd_p16v_pcm_trigger_playback(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime;\r\nstruct snd_emu10k1_pcm *epcm;\r\nint channel;\r\nint result = 0;\r\nstruct snd_pcm_substream *s;\r\nu32 basic = 0;\r\nu32 inte = 0;\r\nint running = 0;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nrunning=1;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ndefault:\r\nrunning = 0;\r\nbreak;\r\n}\r\nsnd_pcm_group_for_each_entry(s, substream) {\r\nif (snd_pcm_substream_chip(s) != emu ||\r\ns->stream != SNDRV_PCM_STREAM_PLAYBACK)\r\ncontinue;\r\nruntime = s->runtime;\r\nepcm = runtime->private_data;\r\nchannel = substream->pcm->device-emu->p16v_device_offset;\r\nepcm->running = running;\r\nbasic |= (0x1<<channel);\r\ninte |= (INTE2_PLAYBACK_CH_0_LOOP<<channel);\r\nsnd_pcm_trigger_done(s, substream);\r\n}\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nsnd_p16v_intr_enable(emu, inte);\r\nsnd_emu10k1_ptr20_write(emu, BASIC_INTERRUPT, 0, snd_emu10k1_ptr20_read(emu, BASIC_INTERRUPT, 0)| (basic));\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nsnd_emu10k1_ptr20_write(emu, BASIC_INTERRUPT, 0, snd_emu10k1_ptr20_read(emu, BASIC_INTERRUPT, 0) & ~(basic));\r\nsnd_p16v_intr_disable(emu, inte);\r\nbreak;\r\ndefault:\r\nresult = -EINVAL;\r\nbreak;\r\n}\r\nreturn result;\r\n}\r\nstatic int snd_p16v_pcm_trigger_capture(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_emu10k1_pcm *epcm = runtime->private_data;\r\nint channel = 0;\r\nint result = 0;\r\nu32 inte = INTE2_CAPTURE_CH_0_LOOP | INTE2_CAPTURE_CH_0_HALF_LOOP;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nsnd_p16v_intr_enable(emu, inte);\r\nsnd_emu10k1_ptr20_write(emu, BASIC_INTERRUPT, 0, snd_emu10k1_ptr20_read(emu, BASIC_INTERRUPT, 0)|(0x100<<channel));\r\nepcm->running = 1;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nsnd_emu10k1_ptr20_write(emu, BASIC_INTERRUPT, 0, snd_emu10k1_ptr20_read(emu, BASIC_INTERRUPT, 0) & ~(0x100<<channel));\r\nsnd_p16v_intr_disable(emu, inte);\r\nepcm->running = 0;\r\nbreak;\r\ndefault:\r\nresult = -EINVAL;\r\nbreak;\r\n}\r\nreturn result;\r\n}\r\nstatic snd_pcm_uframes_t\r\nsnd_p16v_pcm_pointer_playback(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_emu10k1_pcm *epcm = runtime->private_data;\r\nsnd_pcm_uframes_t ptr, ptr1, ptr2,ptr3,ptr4 = 0;\r\nint channel = substream->pcm->device - emu->p16v_device_offset;\r\nif (!epcm->running)\r\nreturn 0;\r\nptr3 = snd_emu10k1_ptr20_read(emu, PLAYBACK_LIST_PTR, channel);\r\nptr1 = snd_emu10k1_ptr20_read(emu, PLAYBACK_POINTER, channel);\r\nptr4 = snd_emu10k1_ptr20_read(emu, PLAYBACK_LIST_PTR, channel);\r\nif (ptr3 != ptr4) ptr1 = snd_emu10k1_ptr20_read(emu, PLAYBACK_POINTER, channel);\r\nptr2 = bytes_to_frames(runtime, ptr1);\r\nptr2+= (ptr4 >> 3) * runtime->period_size;\r\nptr=ptr2;\r\nif (ptr >= runtime->buffer_size)\r\nptr -= runtime->buffer_size;\r\nreturn ptr;\r\n}\r\nstatic snd_pcm_uframes_t\r\nsnd_p16v_pcm_pointer_capture(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_emu10k1_pcm *epcm = runtime->private_data;\r\nsnd_pcm_uframes_t ptr, ptr1, ptr2 = 0;\r\nint channel = 0;\r\nif (!epcm->running)\r\nreturn 0;\r\nptr1 = snd_emu10k1_ptr20_read(emu, CAPTURE_POINTER, channel);\r\nptr2 = bytes_to_frames(runtime, ptr1);\r\nptr=ptr2;\r\nif (ptr >= runtime->buffer_size) {\r\nptr -= runtime->buffer_size;\r\ndev_warn(emu->card->dev, "buffer capture limited!\n");\r\n}\r\nreturn ptr;\r\n}\r\nint snd_p16v_free(struct snd_emu10k1 *chip)\r\n{\r\nif (chip->p16v_buffer.area) {\r\nsnd_dma_free_pages(&chip->p16v_buffer);\r\n}\r\nreturn 0;\r\n}\r\nint snd_p16v_pcm(struct snd_emu10k1 *emu, int device)\r\n{\r\nstruct snd_pcm *pcm;\r\nstruct snd_pcm_substream *substream;\r\nint err;\r\nint capture=1;\r\nemu->p16v_device_offset = device;\r\nif ((err = snd_pcm_new(emu->card, "p16v", device, 1, capture, &pcm)) < 0)\r\nreturn err;\r\npcm->private_data = emu;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_p16v_playback_front_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_p16v_capture_ops);\r\npcm->info_flags = 0;\r\npcm->dev_subclass = SNDRV_PCM_SUBCLASS_GENERIC_MIX;\r\nstrcpy(pcm->name, "p16v");\r\nemu->pcm_p16v = pcm;\r\nfor(substream = pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream;\r\nsubstream;\r\nsubstream = substream->next) {\r\nif ((err = snd_pcm_lib_preallocate_pages(substream,\r\nSNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(emu->pci),\r\n((65536 - 64) * 8), ((65536 - 64) * 8))) < 0)\r\nreturn err;\r\n}\r\nfor (substream = pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream;\r\nsubstream;\r\nsubstream = substream->next) {\r\nif ((err = snd_pcm_lib_preallocate_pages(substream,\r\nSNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(emu->pci),\r\n65536 - 64, 65536 - 64)) < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_p16v_volume_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 255;\r\nreturn 0;\r\n}\r\nstatic int snd_p16v_volume_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\r\nint high_low = (kcontrol->private_value >> 8) & 0xff;\r\nint reg = kcontrol->private_value & 0xff;\r\nu32 value;\r\nvalue = snd_emu10k1_ptr20_read(emu, reg, high_low);\r\nif (high_low) {\r\nucontrol->value.integer.value[0] = 0xff - ((value >> 24) & 0xff);\r\nucontrol->value.integer.value[1] = 0xff - ((value >> 16) & 0xff);\r\n} else {\r\nucontrol->value.integer.value[0] = 0xff - ((value >> 8) & 0xff);\r\nucontrol->value.integer.value[1] = 0xff - ((value >> 0) & 0xff);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_p16v_volume_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\r\nint high_low = (kcontrol->private_value >> 8) & 0xff;\r\nint reg = kcontrol->private_value & 0xff;\r\nu32 value, oval;\r\noval = value = snd_emu10k1_ptr20_read(emu, reg, 0);\r\nif (high_low == 1) {\r\nvalue &= 0xffff;\r\nvalue |= ((0xff - ucontrol->value.integer.value[0]) << 24) |\r\n((0xff - ucontrol->value.integer.value[1]) << 16);\r\n} else {\r\nvalue &= 0xffff0000;\r\nvalue |= ((0xff - ucontrol->value.integer.value[0]) << 8) |\r\n((0xff - ucontrol->value.integer.value[1]) );\r\n}\r\nif (value != oval) {\r\nsnd_emu10k1_ptr20_write(emu, reg, 0, value);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_p16v_capture_source_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic const char * const texts[8] = {\r\n"SPDIF", "I2S", "SRC48", "SRCMulti_SPDIF", "SRCMulti_I2S",\r\n"CDIF", "FX", "AC97"\r\n};\r\nreturn snd_ctl_enum_info(uinfo, 1, 8, texts);\r\n}\r\nstatic int snd_p16v_capture_source_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.enumerated.item[0] = emu->p16v_capture_source;\r\nreturn 0;\r\n}\r\nstatic int snd_p16v_capture_source_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\r\nunsigned int val;\r\nint change = 0;\r\nu32 mask;\r\nu32 source;\r\nval = ucontrol->value.enumerated.item[0] ;\r\nif (val > 7)\r\nreturn -EINVAL;\r\nchange = (emu->p16v_capture_source != val);\r\nif (change) {\r\nemu->p16v_capture_source = val;\r\nsource = (val << 28) | (val << 24) | (val << 20) | (val << 16);\r\nmask = snd_emu10k1_ptr20_read(emu, BASIC_INTERRUPT, 0) & 0xffff;\r\nsnd_emu10k1_ptr20_write(emu, BASIC_INTERRUPT, 0, source | mask);\r\n}\r\nreturn change;\r\n}\r\nstatic int snd_p16v_capture_channel_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic const char * const texts[4] = { "0", "1", "2", "3", };\r\nreturn snd_ctl_enum_info(uinfo, 1, 4, texts);\r\n}\r\nstatic int snd_p16v_capture_channel_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.enumerated.item[0] = emu->p16v_capture_channel;\r\nreturn 0;\r\n}\r\nstatic int snd_p16v_capture_channel_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\r\nunsigned int val;\r\nint change = 0;\r\nu32 tmp;\r\nval = ucontrol->value.enumerated.item[0] ;\r\nif (val > 3)\r\nreturn -EINVAL;\r\nchange = (emu->p16v_capture_channel != val);\r\nif (change) {\r\nemu->p16v_capture_channel = val;\r\ntmp = snd_emu10k1_ptr20_read(emu, CAPTURE_P16V_SOURCE, 0) & 0xfffc;\r\nsnd_emu10k1_ptr20_write(emu, CAPTURE_P16V_SOURCE, 0, tmp | val);\r\n}\r\nreturn change;\r\n}\r\nint snd_p16v_mixer(struct snd_emu10k1 *emu)\r\n{\r\nint i, err;\r\nstruct snd_card *card = emu->card;\r\nfor (i = 0; i < ARRAY_SIZE(p16v_mixer_controls); i++) {\r\nif ((err = snd_ctl_add(card, snd_ctl_new1(&p16v_mixer_controls[i],\r\nemu))) < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nint snd_p16v_alloc_pm_buffer(struct snd_emu10k1 *emu)\r\n{\r\nemu->p16v_saved = vmalloc(NUM_CHS * 4 * 0x80);\r\nif (! emu->p16v_saved)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid snd_p16v_free_pm_buffer(struct snd_emu10k1 *emu)\r\n{\r\nvfree(emu->p16v_saved);\r\n}\r\nvoid snd_p16v_suspend(struct snd_emu10k1 *emu)\r\n{\r\nint i, ch;\r\nunsigned int *val;\r\nval = emu->p16v_saved;\r\nfor (ch = 0; ch < NUM_CHS; ch++)\r\nfor (i = 0; i < 0x80; i++, val++)\r\n*val = snd_emu10k1_ptr20_read(emu, i, ch);\r\n}\r\nvoid snd_p16v_resume(struct snd_emu10k1 *emu)\r\n{\r\nint i, ch;\r\nunsigned int *val;\r\nval = emu->p16v_saved;\r\nfor (ch = 0; ch < NUM_CHS; ch++)\r\nfor (i = 0; i < 0x80; i++, val++)\r\nsnd_emu10k1_ptr20_write(emu, i, ch, *val);\r\n}
