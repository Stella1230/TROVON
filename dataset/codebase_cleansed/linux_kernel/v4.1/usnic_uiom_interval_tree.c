static struct usnic_uiom_interval_node*\r\nusnic_uiom_interval_node_alloc(long int start, long int last, int ref_cnt,\r\nint flags)\r\n{\r\nstruct usnic_uiom_interval_node *interval = kzalloc(sizeof(*interval),\r\nGFP_ATOMIC);\r\nif (!interval)\r\nreturn NULL;\r\ninterval->start = start;\r\ninterval->last = last;\r\ninterval->flags = flags;\r\ninterval->ref_cnt = ref_cnt;\r\nreturn interval;\r\n}\r\nstatic int interval_cmp(void *priv, struct list_head *a, struct list_head *b)\r\n{\r\nstruct usnic_uiom_interval_node *node_a, *node_b;\r\nnode_a = list_entry(a, struct usnic_uiom_interval_node, link);\r\nnode_b = list_entry(b, struct usnic_uiom_interval_node, link);\r\nif (node_a->start < node_b->start)\r\nreturn -1;\r\nelse if (node_a->start > node_b->start)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void\r\nfind_intervals_intersection_sorted(struct rb_root *root, unsigned long start,\r\nunsigned long last,\r\nstruct list_head *list)\r\n{\r\nstruct usnic_uiom_interval_node *node;\r\nINIT_LIST_HEAD(list);\r\nfor (node = usnic_uiom_interval_tree_iter_first(root, start, last);\r\nnode;\r\nnode = usnic_uiom_interval_tree_iter_next(node, start, last))\r\nlist_add_tail(&node->link, list);\r\nlist_sort(NULL, list, interval_cmp);\r\n}\r\nint usnic_uiom_get_intervals_diff(unsigned long start, unsigned long last,\r\nint flags, int flag_mask,\r\nstruct rb_root *root,\r\nstruct list_head *diff_set)\r\n{\r\nstruct usnic_uiom_interval_node *interval, *tmp;\r\nint err = 0;\r\nlong int pivot = start;\r\nLIST_HEAD(intersection_set);\r\nINIT_LIST_HEAD(diff_set);\r\nfind_intervals_intersection_sorted(root, start, last,\r\n&intersection_set);\r\nlist_for_each_entry(interval, &intersection_set, link) {\r\nif (pivot < interval->start) {\r\nMAKE_NODE_AND_APPEND(tmp, pivot, interval->start - 1,\r\n1, flags, err, err_out,\r\ndiff_set);\r\npivot = interval->start;\r\n}\r\nif (pivot > interval->last) {\r\ncontinue;\r\n} else if (pivot <= interval->last &&\r\nFLAGS_EQUAL(interval->flags, flags,\r\nflag_mask)) {\r\npivot = interval->last + 1;\r\n}\r\n}\r\nif (pivot <= last)\r\nMAKE_NODE_AND_APPEND(tmp, pivot, last, 1, flags, err, err_out,\r\ndiff_set);\r\nreturn 0;\r\nerr_out:\r\nlist_for_each_entry_safe(interval, tmp, diff_set, link) {\r\nlist_del(&interval->link);\r\nkfree(interval);\r\n}\r\nreturn err;\r\n}\r\nvoid usnic_uiom_put_interval_set(struct list_head *intervals)\r\n{\r\nstruct usnic_uiom_interval_node *interval, *tmp;\r\nlist_for_each_entry_safe(interval, tmp, intervals, link)\r\nkfree(interval);\r\n}\r\nint usnic_uiom_insert_interval(struct rb_root *root, unsigned long start,\r\nunsigned long last, int flags)\r\n{\r\nstruct usnic_uiom_interval_node *interval, *tmp;\r\nunsigned long istart, ilast;\r\nint iref_cnt, iflags;\r\nunsigned long lpivot = start;\r\nint err = 0;\r\nLIST_HEAD(to_add);\r\nLIST_HEAD(intersection_set);\r\nfind_intervals_intersection_sorted(root, start, last,\r\n&intersection_set);\r\nlist_for_each_entry(interval, &intersection_set, link) {\r\nistart = interval->start;\r\nilast = interval->last;\r\niref_cnt = interval->ref_cnt;\r\niflags = interval->flags;\r\nif (istart < lpivot) {\r\nMAKE_NODE_AND_APPEND(tmp, istart, lpivot - 1, iref_cnt,\r\niflags, err, err_out, &to_add);\r\n} else if (istart > lpivot) {\r\nMAKE_NODE_AND_APPEND(tmp, lpivot, istart - 1, 1, flags,\r\nerr, err_out, &to_add);\r\nlpivot = istart;\r\n} else {\r\nlpivot = istart;\r\n}\r\nif (ilast > last) {\r\nMAKE_NODE_AND_APPEND(tmp, lpivot, last, iref_cnt + 1,\r\niflags | flags, err, err_out,\r\n&to_add);\r\nMAKE_NODE_AND_APPEND(tmp, last + 1, ilast, iref_cnt,\r\niflags, err, err_out, &to_add);\r\n} else {\r\nMAKE_NODE_AND_APPEND(tmp, lpivot, ilast, iref_cnt + 1,\r\niflags | flags, err, err_out,\r\n&to_add);\r\n}\r\nlpivot = ilast + 1;\r\n}\r\nif (lpivot <= last)\r\nMAKE_NODE_AND_APPEND(tmp, lpivot, last, 1, flags, err, err_out,\r\n&to_add);\r\nlist_for_each_entry_safe(interval, tmp, &intersection_set, link) {\r\nusnic_uiom_interval_tree_remove(interval, root);\r\nkfree(interval);\r\n}\r\nlist_for_each_entry(interval, &to_add, link)\r\nusnic_uiom_interval_tree_insert(interval, root);\r\nreturn 0;\r\nerr_out:\r\nlist_for_each_entry_safe(interval, tmp, &to_add, link)\r\nkfree(interval);\r\nreturn err;\r\n}\r\nvoid usnic_uiom_remove_interval(struct rb_root *root, unsigned long start,\r\nunsigned long last, struct list_head *removed)\r\n{\r\nstruct usnic_uiom_interval_node *interval;\r\nfor (interval = usnic_uiom_interval_tree_iter_first(root, start, last);\r\ninterval;\r\ninterval = usnic_uiom_interval_tree_iter_next(interval,\r\nstart,\r\nlast)) {\r\nif (--interval->ref_cnt == 0)\r\nlist_add_tail(&interval->link, removed);\r\n}\r\nlist_for_each_entry(interval, removed, link)\r\nusnic_uiom_interval_tree_remove(interval, root);\r\n}
