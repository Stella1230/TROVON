void\r\ngt215_link_train_calc(u32 *vals, struct gt215_ltrain *train)\r\n{\r\nint i, lo, hi;\r\nu8 median[8], bins[4] = {0, 0, 0, 0}, bin = 0, qty = 0;\r\nfor (i = 0; i < 8; i++) {\r\nfor (lo = 0; lo < 0x40; lo++) {\r\nif (!(vals[lo] & 0x80000000))\r\ncontinue;\r\nif (vals[lo] & (0x101 << i))\r\nbreak;\r\n}\r\nif (lo == 0x40)\r\nreturn;\r\nfor (hi = lo + 1; hi < 0x40; hi++) {\r\nif (!(vals[lo] & 0x80000000))\r\ncontinue;\r\nif (!(vals[hi] & (0x101 << i))) {\r\nhi--;\r\nbreak;\r\n}\r\n}\r\nmedian[i] = ((hi - lo) >> 1) + lo;\r\nbins[(median[i] & 0xf0) >> 4]++;\r\nmedian[i] += 0x30;\r\n}\r\nfor (i = 0; i < 4; i++) {\r\nif (bins[i] > qty) {\r\nbin = i + 3;\r\nqty = bins[i];\r\n}\r\n}\r\ntrain->r_100720 = 0;\r\nfor (i = 0; i < 8; i++) {\r\nmedian[i] = max(median[i], (u8) (bin << 4));\r\nmedian[i] = min(median[i], (u8) ((bin << 4) | 0xf));\r\ntrain->r_100720 |= ((median[i] & 0x0f) << (i << 2));\r\n}\r\ntrain->r_1111e0 = 0x02000000 | (bin * 0x101);\r\ntrain->r_111400 = 0x0;\r\n}\r\nint\r\ngt215_link_train(struct nvkm_fb *pfb)\r\n{\r\nstruct nvkm_bios *bios = nvkm_bios(pfb);\r\nstruct gt215_ram *ram = (void *)pfb->ram;\r\nstruct nvkm_clk *clk = nvkm_clk(pfb);\r\nstruct gt215_ltrain *train = &ram->ltrain;\r\nstruct nvkm_device *device = nv_device(pfb);\r\nstruct gt215_ramfuc *fuc = &ram->fuc;\r\nu32 *result, r1700;\r\nint ret, i;\r\nstruct nvbios_M0205T M0205T = { 0 };\r\nu8 ver, hdr, cnt, len, snr, ssz;\r\nunsigned int clk_current;\r\nunsigned long flags;\r\nunsigned long *f = &flags;\r\nif (nvkm_boolopt(device->cfgopt, "NvMemExec", true) != true)\r\nreturn -ENOSYS;\r\nresult = kmalloc(64 * sizeof(u32), GFP_KERNEL);\r\nif (!result)\r\nreturn -ENOMEM;\r\ntrain->state = NVA3_TRAIN_EXEC;\r\nnvbios_M0205Tp(bios, &ver, &hdr, &cnt, &len, &snr, &ssz, &M0205T);\r\nif (M0205T.freq == 0)\r\nreturn -ENOENT;\r\nclk_current = clk->read(clk, nv_clk_src_mem);\r\nret = gt215_clk_pre(clk, f);\r\nif (ret)\r\ngoto out;\r\nret = ram->base.calc(pfb, (u32) M0205T.freq * 1000);\r\nif (ret)\r\ngoto out;\r\nnv_wr32(pfb, 0x111400, 0x00000000);\r\nnv_mask(pfb, 0x100674, 0x0000ffff, 0x00000000);\r\nnv_mask(pfb, 0x1005e4, 0x0000ffff, 0x00000000);\r\nnv_mask(pfb, 0x100b0c, 0x000000ff, 0x00000000);\r\nnv_wr32(pfb, 0x100c04, 0x00000400);\r\nr1700 = ram_rd32(fuc, 0x001700);\r\nram_mask(fuc, 0x100200, 0x00000800, 0x00000000);\r\nram_wr32(fuc, 0x611200, 0x3300);\r\nram_wait_vblank(fuc);\r\nram_wait(fuc, 0x611200, 0x00000003, 0x00000000, 500000);\r\nram_mask(fuc, 0x001610, 0x00000083, 0x00000003);\r\nram_mask(fuc, 0x100080, 0x00000020, 0x00000000);\r\nram_mask(fuc, 0x10f804, 0x80000000, 0x00000000);\r\nram_wr32(fuc, 0x001700, 0x00000000);\r\nram_train(fuc);\r\nram_mask(fuc, 0x10f804, 0x80000000, 0x80000000);\r\nram_wr32(fuc, 0x10053c, 0x0);\r\nram_wr32(fuc, 0x100720, train->r_100720);\r\nram_wr32(fuc, 0x1111e0, train->r_1111e0);\r\nram_wr32(fuc, 0x111400, train->r_111400);\r\nram_nuke(fuc, 0x100080);\r\nram_mask(fuc, 0x100080, 0x00000020, 0x00000020);\r\nram_nsec(fuc, 1000);\r\nram_wr32(fuc, 0x001700, r1700);\r\nram_mask(fuc, 0x001610, 0x00000083, 0x00000080);\r\nram_wr32(fuc, 0x611200, 0x3330);\r\nram_mask(fuc, 0x100200, 0x00000800, 0x00000800);\r\nram_exec(fuc, true);\r\nram->base.calc(pfb, clk_current);\r\nram_exec(fuc, true);\r\nnv_mask(pfb, 0x616308, 0x10, 0x10);\r\nnv_mask(pfb, 0x616b08, 0x10, 0x10);\r\ngt215_clk_post(clk, f);\r\nram_train_result(pfb, result, 64);\r\nfor (i = 0; i < 64; i++)\r\nnv_debug(pfb, "Train: %08x", result[i]);\r\ngt215_link_train_calc(result, train);\r\nnv_debug(pfb, "Train: %08x %08x %08x", train->r_100720,\r\ntrain->r_1111e0, train->r_111400);\r\nkfree(result);\r\ntrain->state = NVA3_TRAIN_DONE;\r\nreturn ret;\r\nout:\r\nif(ret == -EBUSY)\r\nf = NULL;\r\ntrain->state = NVA3_TRAIN_UNSUPPORTED;\r\ngt215_clk_post(clk, f);\r\nreturn ret;\r\n}\r\nint\r\ngt215_link_train_init(struct nvkm_fb *pfb)\r\n{\r\nstatic const u32 pattern[16] = {\r\n0xaaaaaaaa, 0xcccccccc, 0xdddddddd, 0xeeeeeeee,\r\n0x00000000, 0x11111111, 0x44444444, 0xdddddddd,\r\n0x33333333, 0x55555555, 0x77777777, 0x66666666,\r\n0x99999999, 0x88888888, 0xeeeeeeee, 0xbbbbbbbb,\r\n};\r\nstruct nvkm_bios *bios = nvkm_bios(pfb);\r\nstruct gt215_ram *ram = (void *)pfb->ram;\r\nstruct gt215_ltrain *train = &ram->ltrain;\r\nstruct nvkm_mem *mem;\r\nstruct nvbios_M0205E M0205E;\r\nu8 ver, hdr, cnt, len;\r\nu32 r001700;\r\nint ret, i = 0;\r\ntrain->state = NVA3_TRAIN_UNSUPPORTED;\r\nif (!nvbios_M0205Ep(bios, i, &ver, &hdr, &cnt, &len, &M0205E))\r\nreturn -ENOENT;\r\nif (M0205E.type != 5)\r\nreturn 0;\r\ntrain->state = NVA3_TRAIN_ONCE;\r\nret = pfb->ram->get(pfb, 0x8000, 0x10000, 0, 0x800, &ram->ltrain.mem);\r\nif (ret)\r\nreturn ret;\r\nmem = ram->ltrain.mem;\r\nnv_wr32(pfb, 0x100538, 0x10000000 | (mem->offset >> 16));\r\nnv_wr32(pfb, 0x1005a8, 0x0000ffff);\r\nnv_mask(pfb, 0x10f800, 0x00000001, 0x00000001);\r\nfor (i = 0; i < 0x30; i++) {\r\nnv_wr32(pfb, 0x10f8c0, (i << 8) | i);\r\nnv_wr32(pfb, 0x10f900, pattern[i % 16]);\r\n}\r\nfor (i = 0; i < 0x30; i++) {\r\nnv_wr32(pfb, 0x10f8e0, (i << 8) | i);\r\nnv_wr32(pfb, 0x10f920, pattern[i % 16]);\r\n}\r\nr001700 = nv_rd32(pfb, 0x1700);\r\nnv_wr32(pfb, 0x1700, mem->offset >> 16);\r\nfor (i = 0; i < 16; i++)\r\nnv_wr32(pfb, 0x700000 + (i << 2), pattern[i]);\r\nfor (i = 0; i < 16; i++)\r\nnv_wr32(pfb, 0x700100 + (i << 2), pattern[i]);\r\nnv_wr32(pfb, 0x1700, r001700);\r\ntrain->r_100720 = nv_rd32(pfb, 0x100720);\r\ntrain->r_1111e0 = nv_rd32(pfb, 0x1111e0);\r\ntrain->r_111400 = nv_rd32(pfb, 0x111400);\r\nreturn 0;\r\n}\r\nvoid\r\ngt215_link_train_fini(struct nvkm_fb *pfb)\r\n{\r\nstruct gt215_ram *ram = (void *)pfb->ram;\r\nif (ram->ltrain.mem)\r\npfb->ram->put(pfb, &ram->ltrain.mem);\r\n}\r\nstatic int\r\ngt215_ram_timing_calc(struct nvkm_fb *pfb, u32 *timing)\r\n{\r\nstruct gt215_ram *ram = (void *)pfb->ram;\r\nstruct nvbios_ramcfg *cfg = &ram->base.target.bios;\r\nint tUNK_base, tUNK_40_0, prevCL;\r\nu32 cur2, cur3, cur7, cur8;\r\ncur2 = nv_rd32(pfb, 0x100228);\r\ncur3 = nv_rd32(pfb, 0x10022c);\r\ncur7 = nv_rd32(pfb, 0x10023c);\r\ncur8 = nv_rd32(pfb, 0x100240);\r\nswitch ((!T(CWL)) * ram->base.type) {\r\ncase NV_MEM_TYPE_DDR2:\r\nT(CWL) = T(CL) - 1;\r\nbreak;\r\ncase NV_MEM_TYPE_GDDR3:\r\nT(CWL) = ((cur2 & 0xff000000) >> 24) + 1;\r\nbreak;\r\n}\r\nprevCL = (cur3 & 0x000000ff) + 1;\r\ntUNK_base = ((cur7 & 0x00ff0000) >> 16) - prevCL;\r\ntiming[0] = (T(RP) << 24 | T(RAS) << 16 | T(RFC) << 8 | T(RC));\r\ntiming[1] = (T(WR) + 1 + T(CWL)) << 24 |\r\nmax_t(u8,T(18), 1) << 16 |\r\n(T(WTR) + 1 + T(CWL)) << 8 |\r\n(5 + T(CL) - T(CWL));\r\ntiming[2] = (T(CWL) - 1) << 24 |\r\n(T(RRD) << 16) |\r\n(T(RCDWR) << 8) |\r\nT(RCDRD);\r\ntiming[3] = (cur3 & 0x00ff0000) |\r\n(0x30 + T(CL)) << 24 |\r\n(0xb + T(CL)) << 8 |\r\n(T(CL) - 1);\r\ntiming[4] = T(20) << 24 |\r\nT(21) << 16 |\r\nT(13) << 8 |\r\nT(13);\r\ntiming[5] = T(RFC) << 24 |\r\nmax_t(u8,T(RCDRD), T(RCDWR)) << 16 |\r\nmax_t(u8, (T(CWL) + 6), (T(CL) + 2)) << 8 |\r\nT(RP);\r\ntiming[6] = (0x5a + T(CL)) << 16 |\r\nmax_t(u8, 1, (6 - T(CL) + T(CWL))) << 8 |\r\n(0x50 + T(CL) - T(CWL));\r\ntiming[7] = (cur7 & 0xff000000) |\r\n((tUNK_base + T(CL)) << 16) |\r\n0x202;\r\ntiming[8] = cur8 & 0xffffff00;\r\nswitch (ram->base.type) {\r\ncase NV_MEM_TYPE_DDR2:\r\ncase NV_MEM_TYPE_GDDR3:\r\ntUNK_40_0 = prevCL - (cur8 & 0xff);\r\nif (tUNK_40_0 > 0)\r\ntiming[8] |= T(CL);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nnv_debug(pfb, "Entry: 220: %08x %08x %08x %08x\n",\r\ntiming[0], timing[1], timing[2], timing[3]);\r\nnv_debug(pfb, " 230: %08x %08x %08x %08x\n",\r\ntiming[4], timing[5], timing[6], timing[7]);\r\nnv_debug(pfb, " 240: %08x\n", timing[8]);\r\nreturn 0;\r\n}\r\nstatic void\r\nnvkm_sddr2_dll_reset(struct gt215_ramfuc *fuc)\r\n{\r\nram_mask(fuc, mr[0], 0x100, 0x100);\r\nram_nsec(fuc, 1000);\r\nram_mask(fuc, mr[0], 0x100, 0x000);\r\nram_nsec(fuc, 1000);\r\n}\r\nstatic void\r\nnvkm_sddr3_dll_disable(struct gt215_ramfuc *fuc, u32 *mr)\r\n{\r\nu32 mr1_old = ram_rd32(fuc, mr[1]);\r\nif (!(mr1_old & 0x1)) {\r\nram_wr32(fuc, 0x1002d4, 0x00000001);\r\nram_wr32(fuc, mr[1], mr[1]);\r\nram_nsec(fuc, 1000);\r\n}\r\n}\r\nstatic void\r\nnvkm_gddr3_dll_disable(struct gt215_ramfuc *fuc, u32 *mr)\r\n{\r\nu32 mr1_old = ram_rd32(fuc, mr[1]);\r\nif (!(mr1_old & 0x40)) {\r\nram_wr32(fuc, mr[1], mr[1]);\r\nram_nsec(fuc, 1000);\r\n}\r\n}\r\nstatic void\r\ngt215_ram_lock_pll(struct gt215_ramfuc *fuc, struct gt215_clk_info *mclk)\r\n{\r\nram_wr32(fuc, 0x004004, mclk->pll);\r\nram_mask(fuc, 0x004000, 0x00000001, 0x00000001);\r\nram_mask(fuc, 0x004000, 0x00000010, 0x00000000);\r\nram_wait(fuc, 0x004000, 0x00020000, 0x00020000, 64000);\r\nram_mask(fuc, 0x004000, 0x00000010, 0x00000010);\r\n}\r\nstatic void\r\ngt215_ram_fbvref(struct gt215_ramfuc *fuc, u32 val)\r\n{\r\nstruct nvkm_gpio *gpio = nvkm_gpio(fuc->base.pfb);\r\nstruct dcb_gpio_func func;\r\nu32 reg, sh, gpio_val;\r\nint ret;\r\nif (gpio->get(gpio, 0, 0x2e, DCB_GPIO_UNUSED) != val) {\r\nret = gpio->find(gpio, 0, 0x2e, DCB_GPIO_UNUSED, &func);\r\nif (ret)\r\nreturn;\r\nnv50_gpio_location(func.line, &reg, &sh);\r\ngpio_val = ram_rd32(fuc, gpioFBVREF);\r\nif (gpio_val & (8 << sh))\r\nval = !val;\r\nram_mask(fuc, gpioFBVREF, (0x3 << sh), ((val | 0x2) << sh));\r\nram_nsec(fuc, 20000);\r\n}\r\n}\r\nstatic int\r\ngt215_ram_calc(struct nvkm_fb *pfb, u32 freq)\r\n{\r\nstruct nvkm_bios *bios = nvkm_bios(pfb);\r\nstruct gt215_ram *ram = (void *)pfb->ram;\r\nstruct gt215_ramfuc *fuc = &ram->fuc;\r\nstruct gt215_ltrain *train = &ram->ltrain;\r\nstruct gt215_clk_info mclk;\r\nstruct nvkm_ram_data *next;\r\nu8 ver, hdr, cnt, len, strap;\r\nu32 data;\r\nu32 r004018, r100760, r100da0, r111100, ctrl;\r\nu32 unk714, unk718, unk71c;\r\nint ret, i;\r\nu32 timing[9];\r\nbool pll2pll;\r\nnext = &ram->base.target;\r\nnext->freq = freq;\r\nram->base.next = next;\r\nif (ram->ltrain.state == NVA3_TRAIN_ONCE)\r\ngt215_link_train(pfb);\r\ni = 0;\r\ndata = nvbios_rammapEm(bios, freq / 1000, &ver, &hdr, &cnt, &len,\r\n&next->bios);\r\nif (!data || ver != 0x10 || hdr < 0x05) {\r\nnv_error(pfb, "invalid/missing rammap entry\n");\r\nreturn -EINVAL;\r\n}\r\nstrap = nvbios_ramcfg_index(nv_subdev(pfb));\r\nif (strap >= cnt) {\r\nnv_error(pfb, "invalid ramcfg strap\n");\r\nreturn -EINVAL;\r\n}\r\ndata = nvbios_rammapSp(bios, data, ver, hdr, cnt, len, strap,\r\n&ver, &hdr, &next->bios);\r\nif (!data || ver != 0x10 || hdr < 0x09) {\r\nnv_error(pfb, "invalid/missing ramcfg entry\n");\r\nreturn -EINVAL;\r\n}\r\nif (next->bios.ramcfg_timing != 0xff) {\r\ndata = nvbios_timingEp(bios, next->bios.ramcfg_timing,\r\n&ver, &hdr, &cnt, &len,\r\n&next->bios);\r\nif (!data || ver != 0x10 || hdr < 0x17) {\r\nnv_error(pfb, "invalid/missing timing entry\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nret = gt215_pll_info(nvkm_clk(pfb), 0x12, 0x4000, freq, &mclk);\r\nif (ret < 0) {\r\nnv_error(pfb, "failed mclk calculation\n");\r\nreturn ret;\r\n}\r\ngt215_ram_timing_calc(pfb, timing);\r\nret = ram_init(fuc, pfb);\r\nif (ret)\r\nreturn ret;\r\nram->base.mr[0] = ram_rd32(fuc, mr[0]);\r\nram->base.mr[1] = ram_rd32(fuc, mr[1]);\r\nram->base.mr[2] = ram_rd32(fuc, mr[2]);\r\nswitch (ram->base.type) {\r\ncase NV_MEM_TYPE_DDR2:\r\nret = nvkm_sddr2_calc(&ram->base);\r\nbreak;\r\ncase NV_MEM_TYPE_DDR3:\r\nret = nvkm_sddr3_calc(&ram->base);\r\nbreak;\r\ncase NV_MEM_TYPE_GDDR3:\r\nret = nvkm_gddr3_calc(&ram->base);\r\nbreak;\r\ndefault:\r\nret = -ENOSYS;\r\nbreak;\r\n}\r\nif (ret)\r\nreturn ret;\r\nif (freq <= 750000) {\r\nr004018 = 0x10000000;\r\nr100760 = 0x22222222;\r\nr100da0 = 0x00000010;\r\n} else {\r\nr004018 = 0x00000000;\r\nr100760 = 0x00000000;\r\nr100da0 = 0x00000000;\r\n}\r\nif (!next->bios.ramcfg_10_DLLoff)\r\nr004018 |= 0x00004000;\r\nctrl = ram_rd32(fuc, 0x004000);\r\npll2pll = (!(ctrl & 0x00000008)) && mclk.pll;\r\nif (next->bios.ramcfg_10_02_10) {\r\nram_mask(fuc, 0x111104, 0x00000600, 0x00000000);\r\n} else {\r\nram_mask(fuc, 0x111100, 0x40000000, 0x40000000);\r\nram_mask(fuc, 0x111104, 0x00000180, 0x00000000);\r\n}\r\nram_mask(fuc, 0x100200, 0x00000800, 0x00000000);\r\nif (mclk.pll && !pll2pll) {\r\nram_mask(fuc, 0x004128, 0x003f3141, mclk.clk | 0x00000101);\r\ngt215_ram_lock_pll(fuc, &mclk);\r\n}\r\nram_wait_vblank(fuc);\r\nram_wr32(fuc, 0x611200, 0x3300);\r\nram_mask(fuc, 0x002504, 0x1, 0x1);\r\nram_nsec(fuc, 10000);\r\nram_wait(fuc, 0x002504, 0x10, 0x10, 20000);\r\nram_block(fuc);\r\nram_nsec(fuc, 2000);\r\nif (!next->bios.ramcfg_10_02_10) {\r\nif (ram->base.type == NV_MEM_TYPE_GDDR3)\r\nram_mask(fuc, 0x111100, 0x04020000, 0x00020000);\r\nelse\r\nram_mask(fuc, 0x111100, 0x04020000, 0x04020000);\r\n}\r\nswitch (next->bios.ramcfg_10_DLLoff * ram->base.type) {\r\ncase NV_MEM_TYPE_DDR3:\r\nnvkm_sddr3_dll_disable(fuc, ram->base.mr);\r\nbreak;\r\ncase NV_MEM_TYPE_GDDR3:\r\nnvkm_gddr3_dll_disable(fuc, ram->base.mr);\r\nbreak;\r\n}\r\nif (fuc->r_gpioFBVREF.addr && next->bios.timing_10_ODT)\r\ngt215_ram_fbvref(fuc, 0);\r\nram_wr32(fuc, 0x1002d4, 0x00000001);\r\nram_wr32(fuc, 0x1002d0, 0x00000001);\r\nram_wr32(fuc, 0x1002d0, 0x00000001);\r\nram_wr32(fuc, 0x100210, 0x00000000);\r\nram_wr32(fuc, 0x1002dc, 0x00000001);\r\nram_nsec(fuc, 2000);\r\nif (nv_device(pfb)->chipset == 0xa3 && freq <= 500000)\r\nram_mask(fuc, 0x100700, 0x00000006, 0x00000006);\r\nif (pll2pll) {\r\nram_mask(fuc, 0x004000, 0x00000004, 0x00000004);\r\nram_mask(fuc, 0x004168, 0x003f3141, 0x00083101);\r\nram_mask(fuc, 0x004000, 0x00000008, 0x00000008);\r\nram_mask(fuc, 0x1110e0, 0x00088000, 0x00088000);\r\nram_wr32(fuc, 0x004018, 0x00001000);\r\ngt215_ram_lock_pll(fuc, &mclk);\r\n}\r\nif (mclk.pll) {\r\nram_mask(fuc, 0x004000, 0x00000105, 0x00000105);\r\nram_wr32(fuc, 0x004018, 0x00001000 | r004018);\r\nram_wr32(fuc, 0x100da0, r100da0);\r\n} else {\r\nram_mask(fuc, 0x004168, 0x003f3141, mclk.clk | 0x00000101);\r\nram_mask(fuc, 0x004000, 0x00000108, 0x00000008);\r\nram_mask(fuc, 0x1110e0, 0x00088000, 0x00088000);\r\nram_wr32(fuc, 0x004018, 0x00009000 | r004018);\r\nram_wr32(fuc, 0x100da0, r100da0);\r\n}\r\nram_nsec(fuc, 20000);\r\nif (next->bios.rammap_10_04_08) {\r\nram_wr32(fuc, 0x1005a0, next->bios.ramcfg_10_06 << 16 |\r\nnext->bios.ramcfg_10_05 << 8 |\r\nnext->bios.ramcfg_10_05);\r\nram_wr32(fuc, 0x1005a4, next->bios.ramcfg_10_08 << 8 |\r\nnext->bios.ramcfg_10_07);\r\nram_wr32(fuc, 0x10f804, next->bios.ramcfg_10_09_f0 << 20 |\r\nnext->bios.ramcfg_10_03_0f << 16 |\r\nnext->bios.ramcfg_10_09_0f |\r\n0x80000000);\r\nram_mask(fuc, 0x10053c, 0x00001000, 0x00000000);\r\n} else {\r\nif (train->state == NVA3_TRAIN_DONE) {\r\nram_wr32(fuc, 0x100080, 0x1020);\r\nram_mask(fuc, 0x111400, 0xffffffff, train->r_111400);\r\nram_mask(fuc, 0x1111e0, 0xffffffff, train->r_1111e0);\r\nram_mask(fuc, 0x100720, 0xffffffff, train->r_100720);\r\n}\r\nram_mask(fuc, 0x10053c, 0x00001000, 0x00001000);\r\nram_mask(fuc, 0x10f804, 0x80000000, 0x00000000);\r\nram_mask(fuc, 0x100760, 0x22222222, r100760);\r\nram_mask(fuc, 0x1007a0, 0x22222222, r100760);\r\nram_mask(fuc, 0x1007e0, 0x22222222, r100760);\r\n}\r\nif (nv_device(pfb)->chipset == 0xa3 && freq > 500000) {\r\nram_mask(fuc, 0x100700, 0x00000006, 0x00000000);\r\n}\r\nif (mclk.pll) {\r\nram_mask(fuc, 0x1110e0, 0x00088000, 0x00011000);\r\nram_mask(fuc, 0x004000, 0x00000008, 0x00000000);\r\n}\r\nram_wr32(fuc, 0x1002dc, 0x00000000);\r\nram_wr32(fuc, 0x1002d4, 0x00000001);\r\nram_wr32(fuc, 0x100210, 0x80000000);\r\nram_nsec(fuc, 2000);\r\nfor (i = 2; i >= 0; i--) {\r\nif (ram_rd32(fuc, mr[i]) != ram->base.mr[i]) {\r\nram_wr32(fuc, mr[i], ram->base.mr[i]);\r\nram_nsec(fuc, 1000);\r\n}\r\n}\r\nram_wr32(fuc, 0x100220[3], timing[3]);\r\nram_wr32(fuc, 0x100220[1], timing[1]);\r\nram_wr32(fuc, 0x100220[6], timing[6]);\r\nram_wr32(fuc, 0x100220[7], timing[7]);\r\nram_wr32(fuc, 0x100220[2], timing[2]);\r\nram_wr32(fuc, 0x100220[4], timing[4]);\r\nram_wr32(fuc, 0x100220[5], timing[5]);\r\nram_wr32(fuc, 0x100220[0], timing[0]);\r\nram_wr32(fuc, 0x100220[8], timing[8]);\r\nram_mask(fuc, 0x100200, 0x00001000, !next->bios.ramcfg_10_02_08 << 12);\r\nunk714 = ram_rd32(fuc, 0x100714) & ~0xf0000130;\r\nunk718 = ram_rd32(fuc, 0x100718) & ~0x00000100;\r\nunk71c = ram_rd32(fuc, 0x10071c) & ~0x00000100;\r\nr111100 = ram_rd32(fuc, 0x111100) & ~0x3a800000;\r\nif (next->bios.ramcfg_10_02_04) {\r\nswitch (ram->base.type) {\r\ncase NV_MEM_TYPE_DDR3:\r\nif (nv_device(pfb)->chipset != 0xa8)\r\nr111100 |= 0x00000004;\r\ncase NV_MEM_TYPE_DDR2:\r\nr111100 |= 0x08000000;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} else {\r\nswitch (ram->base.type) {\r\ncase NV_MEM_TYPE_DDR2:\r\nr111100 |= 0x1a800000;\r\nunk714 |= 0x00000010;\r\nbreak;\r\ncase NV_MEM_TYPE_DDR3:\r\nif (nv_device(pfb)->chipset == 0xa8) {\r\nr111100 |= 0x08000000;\r\n} else {\r\nr111100 &= ~0x00000004;\r\nr111100 |= 0x12800000;\r\n}\r\nunk714 |= 0x00000010;\r\nbreak;\r\ncase NV_MEM_TYPE_GDDR3:\r\nr111100 |= 0x30000000;\r\nunk714 |= 0x00000020;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nunk714 |= (next->bios.ramcfg_10_04_01) << 8;\r\nif (next->bios.ramcfg_10_02_20)\r\nunk714 |= 0xf0000000;\r\nif (next->bios.ramcfg_10_02_02)\r\nunk718 |= 0x00000100;\r\nif (next->bios.ramcfg_10_02_01)\r\nunk71c |= 0x00000100;\r\nif (next->bios.timing_10_24 != 0xff) {\r\nunk718 &= ~0xf0000000;\r\nunk718 |= next->bios.timing_10_24 << 28;\r\n}\r\nif (next->bios.ramcfg_10_02_10)\r\nr111100 &= ~0x04020000;\r\nram_mask(fuc, 0x100714, 0xffffffff, unk714);\r\nram_mask(fuc, 0x10071c, 0xffffffff, unk71c);\r\nram_mask(fuc, 0x100718, 0xffffffff, unk718);\r\nram_mask(fuc, 0x111100, 0xffffffff, r111100);\r\nif (fuc->r_gpioFBVREF.addr && !next->bios.timing_10_ODT)\r\ngt215_ram_fbvref(fuc, 1);\r\nif (!next->bios.ramcfg_10_DLLoff)\r\nnvkm_sddr2_dll_reset(fuc);\r\nif (ram->base.type == NV_MEM_TYPE_GDDR3) {\r\nram_nsec(fuc, 31000);\r\n} else {\r\nram_nsec(fuc, 14000);\r\n}\r\nif (ram->base.type == NV_MEM_TYPE_DDR3) {\r\nram_wr32(fuc, 0x100264, 0x1);\r\nram_nsec(fuc, 2000);\r\n}\r\nram_nuke(fuc, 0x100700);\r\nram_mask(fuc, 0x100700, 0x01000000, 0x01000000);\r\nram_mask(fuc, 0x100700, 0x01000000, 0x00000000);\r\nram_unblock(fuc);\r\nram_wr32(fuc, 0x611200, 0x3330);\r\nif (next->bios.rammap_10_04_02)\r\nram_mask(fuc, 0x100200, 0x00000800, 0x00000800);\r\nif (next->bios.ramcfg_10_02_10) {\r\nram_mask(fuc, 0x111104, 0x00000180, 0x00000180);\r\nram_mask(fuc, 0x111100, 0x40000000, 0x00000000);\r\n} else {\r\nram_mask(fuc, 0x111104, 0x00000600, 0x00000600);\r\n}\r\nif (mclk.pll) {\r\nram_mask(fuc, 0x004168, 0x00000001, 0x00000000);\r\nram_mask(fuc, 0x004168, 0x00000100, 0x00000000);\r\n} else {\r\nram_mask(fuc, 0x004000, 0x00000001, 0x00000000);\r\nram_mask(fuc, 0x004128, 0x00000001, 0x00000000);\r\nram_mask(fuc, 0x004128, 0x00000100, 0x00000000);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ngt215_ram_prog(struct nvkm_fb *pfb)\r\n{\r\nstruct nvkm_device *device = nv_device(pfb);\r\nstruct gt215_ram *ram = (void *)pfb->ram;\r\nstruct gt215_ramfuc *fuc = &ram->fuc;\r\nbool exec = nvkm_boolopt(device->cfgopt, "NvMemExec", true);\r\nif (exec) {\r\nnv_mask(pfb, 0x001534, 0x2, 0x2);\r\nram_exec(fuc, true);\r\nnv_mask(pfb, 0x002504, 0x1, 0x0);\r\nnv_mask(pfb, 0x001534, 0x2, 0x0);\r\nnv_mask(pfb, 0x616308, 0x10, 0x10);\r\nnv_mask(pfb, 0x616b08, 0x10, 0x10);\r\n} else {\r\nram_exec(fuc, false);\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\ngt215_ram_tidy(struct nvkm_fb *pfb)\r\n{\r\nstruct gt215_ram *ram = (void *)pfb->ram;\r\nstruct gt215_ramfuc *fuc = &ram->fuc;\r\nram_exec(fuc, false);\r\n}\r\nstatic int\r\ngt215_ram_init(struct nvkm_object *object)\r\n{\r\nstruct nvkm_fb *pfb = (void *)object->parent;\r\nstruct gt215_ram *ram = (void *)object;\r\nint ret;\r\nret = nvkm_ram_init(&ram->base);\r\nif (ret)\r\nreturn ret;\r\ngt215_link_train_init(pfb);\r\nreturn 0;\r\n}\r\nstatic int\r\ngt215_ram_fini(struct nvkm_object *object, bool suspend)\r\n{\r\nstruct nvkm_fb *pfb = (void *)object->parent;\r\nif (!suspend)\r\ngt215_link_train_fini(pfb);\r\nreturn 0;\r\n}\r\nstatic int\r\ngt215_ram_ctor(struct nvkm_object *parent, struct nvkm_object *engine,\r\nstruct nvkm_oclass *oclass, void *data, u32 datasize,\r\nstruct nvkm_object **pobject)\r\n{\r\nstruct nvkm_fb *pfb = nvkm_fb(parent);\r\nstruct nvkm_gpio *gpio = nvkm_gpio(pfb);\r\nstruct dcb_gpio_func func;\r\nstruct gt215_ram *ram;\r\nint ret, i;\r\nu32 reg, shift;\r\nret = nv50_ram_create(parent, engine, oclass, &ram);\r\n*pobject = nv_object(ram);\r\nif (ret)\r\nreturn ret;\r\nswitch (ram->base.type) {\r\ncase NV_MEM_TYPE_DDR2:\r\ncase NV_MEM_TYPE_DDR3:\r\ncase NV_MEM_TYPE_GDDR3:\r\nram->base.calc = gt215_ram_calc;\r\nram->base.prog = gt215_ram_prog;\r\nram->base.tidy = gt215_ram_tidy;\r\nbreak;\r\ndefault:\r\nnv_warn(ram, "reclocking of this ram type unsupported\n");\r\nreturn 0;\r\n}\r\nram->fuc.r_0x001610 = ramfuc_reg(0x001610);\r\nram->fuc.r_0x001700 = ramfuc_reg(0x001700);\r\nram->fuc.r_0x002504 = ramfuc_reg(0x002504);\r\nram->fuc.r_0x004000 = ramfuc_reg(0x004000);\r\nram->fuc.r_0x004004 = ramfuc_reg(0x004004);\r\nram->fuc.r_0x004018 = ramfuc_reg(0x004018);\r\nram->fuc.r_0x004128 = ramfuc_reg(0x004128);\r\nram->fuc.r_0x004168 = ramfuc_reg(0x004168);\r\nram->fuc.r_0x100080 = ramfuc_reg(0x100080);\r\nram->fuc.r_0x100200 = ramfuc_reg(0x100200);\r\nram->fuc.r_0x100210 = ramfuc_reg(0x100210);\r\nfor (i = 0; i < 9; i++)\r\nram->fuc.r_0x100220[i] = ramfuc_reg(0x100220 + (i * 4));\r\nram->fuc.r_0x100264 = ramfuc_reg(0x100264);\r\nram->fuc.r_0x1002d0 = ramfuc_reg(0x1002d0);\r\nram->fuc.r_0x1002d4 = ramfuc_reg(0x1002d4);\r\nram->fuc.r_0x1002dc = ramfuc_reg(0x1002dc);\r\nram->fuc.r_0x10053c = ramfuc_reg(0x10053c);\r\nram->fuc.r_0x1005a0 = ramfuc_reg(0x1005a0);\r\nram->fuc.r_0x1005a4 = ramfuc_reg(0x1005a4);\r\nram->fuc.r_0x100700 = ramfuc_reg(0x100700);\r\nram->fuc.r_0x100714 = ramfuc_reg(0x100714);\r\nram->fuc.r_0x100718 = ramfuc_reg(0x100718);\r\nram->fuc.r_0x10071c = ramfuc_reg(0x10071c);\r\nram->fuc.r_0x100720 = ramfuc_reg(0x100720);\r\nram->fuc.r_0x100760 = ramfuc_stride(0x100760, 4, ram->base.part_mask);\r\nram->fuc.r_0x1007a0 = ramfuc_stride(0x1007a0, 4, ram->base.part_mask);\r\nram->fuc.r_0x1007e0 = ramfuc_stride(0x1007e0, 4, ram->base.part_mask);\r\nram->fuc.r_0x100da0 = ramfuc_stride(0x100da0, 4, ram->base.part_mask);\r\nram->fuc.r_0x10f804 = ramfuc_reg(0x10f804);\r\nram->fuc.r_0x1110e0 = ramfuc_stride(0x1110e0, 4, ram->base.part_mask);\r\nram->fuc.r_0x111100 = ramfuc_reg(0x111100);\r\nram->fuc.r_0x111104 = ramfuc_reg(0x111104);\r\nram->fuc.r_0x1111e0 = ramfuc_reg(0x1111e0);\r\nram->fuc.r_0x111400 = ramfuc_reg(0x111400);\r\nram->fuc.r_0x611200 = ramfuc_reg(0x611200);\r\nif (ram->base.ranks > 1) {\r\nram->fuc.r_mr[0] = ramfuc_reg2(0x1002c0, 0x1002c8);\r\nram->fuc.r_mr[1] = ramfuc_reg2(0x1002c4, 0x1002cc);\r\nram->fuc.r_mr[2] = ramfuc_reg2(0x1002e0, 0x1002e8);\r\nram->fuc.r_mr[3] = ramfuc_reg2(0x1002e4, 0x1002ec);\r\n} else {\r\nram->fuc.r_mr[0] = ramfuc_reg(0x1002c0);\r\nram->fuc.r_mr[1] = ramfuc_reg(0x1002c4);\r\nram->fuc.r_mr[2] = ramfuc_reg(0x1002e0);\r\nram->fuc.r_mr[3] = ramfuc_reg(0x1002e4);\r\n}\r\nret = gpio->find(gpio, 0, 0x2e, DCB_GPIO_UNUSED, &func);\r\nif (ret == 0) {\r\nnv50_gpio_location(func.line, &reg, &shift);\r\nram->fuc.r_gpioFBVREF = ramfuc_reg(reg);\r\n}\r\nreturn 0;\r\n}
