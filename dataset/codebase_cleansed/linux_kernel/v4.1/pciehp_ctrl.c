static int queue_interrupt_event(struct slot *p_slot, u32 event_type)\r\n{\r\nstruct event_info *info;\r\ninfo = kmalloc(sizeof(*info), GFP_ATOMIC);\r\nif (!info)\r\nreturn -ENOMEM;\r\ninfo->event_type = event_type;\r\ninfo->p_slot = p_slot;\r\nINIT_WORK(&info->work, interrupt_event_handler);\r\nqueue_work(p_slot->wq, &info->work);\r\nreturn 0;\r\n}\r\nu8 pciehp_handle_attention_button(struct slot *p_slot)\r\n{\r\nu32 event_type;\r\nstruct controller *ctrl = p_slot->ctrl;\r\nctrl_dbg(ctrl, "Attention button interrupt received\n");\r\nctrl_info(ctrl, "Button pressed on Slot(%s)\n", slot_name(p_slot));\r\nevent_type = INT_BUTTON_PRESS;\r\nqueue_interrupt_event(p_slot, event_type);\r\nreturn 0;\r\n}\r\nu8 pciehp_handle_switch_change(struct slot *p_slot)\r\n{\r\nu8 getstatus;\r\nu32 event_type;\r\nstruct controller *ctrl = p_slot->ctrl;\r\nctrl_dbg(ctrl, "Switch interrupt received\n");\r\npciehp_get_latch_status(p_slot, &getstatus);\r\nif (getstatus) {\r\nctrl_info(ctrl, "Latch open on Slot(%s)\n", slot_name(p_slot));\r\nevent_type = INT_SWITCH_OPEN;\r\n} else {\r\nctrl_info(ctrl, "Latch close on Slot(%s)\n", slot_name(p_slot));\r\nevent_type = INT_SWITCH_CLOSE;\r\n}\r\nqueue_interrupt_event(p_slot, event_type);\r\nreturn 1;\r\n}\r\nu8 pciehp_handle_presence_change(struct slot *p_slot)\r\n{\r\nu32 event_type;\r\nu8 presence_save;\r\nstruct controller *ctrl = p_slot->ctrl;\r\nctrl_dbg(ctrl, "Presence/Notify input change\n");\r\npciehp_get_adapter_status(p_slot, &presence_save);\r\nif (presence_save) {\r\nctrl_info(ctrl, "Card present on Slot(%s)\n", slot_name(p_slot));\r\nevent_type = INT_PRESENCE_ON;\r\n} else {\r\nctrl_info(ctrl, "Card not present on Slot(%s)\n",\r\nslot_name(p_slot));\r\nevent_type = INT_PRESENCE_OFF;\r\n}\r\nqueue_interrupt_event(p_slot, event_type);\r\nreturn 1;\r\n}\r\nu8 pciehp_handle_power_fault(struct slot *p_slot)\r\n{\r\nu32 event_type;\r\nstruct controller *ctrl = p_slot->ctrl;\r\nctrl_dbg(ctrl, "Power fault interrupt received\n");\r\nctrl_err(ctrl, "Power fault on slot %s\n", slot_name(p_slot));\r\nevent_type = INT_POWER_FAULT;\r\nctrl_info(ctrl, "Power fault bit %x set\n", 0);\r\nqueue_interrupt_event(p_slot, event_type);\r\nreturn 1;\r\n}\r\nvoid pciehp_handle_linkstate_change(struct slot *p_slot)\r\n{\r\nu32 event_type;\r\nstruct controller *ctrl = p_slot->ctrl;\r\nctrl_dbg(ctrl, "Data Link Layer State change\n");\r\nif (pciehp_check_link_active(ctrl)) {\r\nctrl_info(ctrl, "slot(%s): Link Up event\n",\r\nslot_name(p_slot));\r\nevent_type = INT_LINK_UP;\r\n} else {\r\nctrl_info(ctrl, "slot(%s): Link Down event\n",\r\nslot_name(p_slot));\r\nevent_type = INT_LINK_DOWN;\r\n}\r\nqueue_interrupt_event(p_slot, event_type);\r\n}\r\nstatic void set_slot_off(struct controller *ctrl, struct slot *pslot)\r\n{\r\nif (POWER_CTRL(ctrl)) {\r\npciehp_power_off_slot(pslot);\r\nmsleep(1000);\r\n}\r\npciehp_green_led_off(pslot);\r\npciehp_set_attention_status(pslot, 1);\r\n}\r\nstatic int board_added(struct slot *p_slot)\r\n{\r\nint retval = 0;\r\nstruct controller *ctrl = p_slot->ctrl;\r\nstruct pci_bus *parent = ctrl->pcie->port->subordinate;\r\nif (POWER_CTRL(ctrl)) {\r\nretval = pciehp_power_on_slot(p_slot);\r\nif (retval)\r\nreturn retval;\r\n}\r\npciehp_green_led_blink(p_slot);\r\nretval = pciehp_check_link_status(ctrl);\r\nif (retval) {\r\nctrl_err(ctrl, "Failed to check link status\n");\r\ngoto err_exit;\r\n}\r\nif (ctrl->power_fault_detected || pciehp_query_power_fault(p_slot)) {\r\nctrl_err(ctrl, "Power fault on slot %s\n", slot_name(p_slot));\r\nretval = -EIO;\r\ngoto err_exit;\r\n}\r\nretval = pciehp_configure_device(p_slot);\r\nif (retval) {\r\nctrl_err(ctrl, "Cannot add device at %04x:%02x:00\n",\r\npci_domain_nr(parent), parent->number);\r\nif (retval != -EEXIST)\r\ngoto err_exit;\r\n}\r\npciehp_green_led_on(p_slot);\r\nreturn 0;\r\nerr_exit:\r\nset_slot_off(ctrl, p_slot);\r\nreturn retval;\r\n}\r\nstatic int remove_board(struct slot *p_slot)\r\n{\r\nint retval;\r\nstruct controller *ctrl = p_slot->ctrl;\r\nretval = pciehp_unconfigure_device(p_slot);\r\nif (retval)\r\nreturn retval;\r\nif (POWER_CTRL(ctrl)) {\r\npciehp_power_off_slot(p_slot);\r\nmsleep(1000);\r\n}\r\npciehp_green_led_off(p_slot);\r\nreturn 0;\r\n}\r\nstatic void pciehp_power_thread(struct work_struct *work)\r\n{\r\nstruct power_work_info *info =\r\ncontainer_of(work, struct power_work_info, work);\r\nstruct slot *p_slot = info->p_slot;\r\nint ret;\r\nswitch (info->req) {\r\ncase DISABLE_REQ:\r\nctrl_dbg(p_slot->ctrl,\r\n"Disabling domain:bus:device=%04x:%02x:00\n",\r\npci_domain_nr(p_slot->ctrl->pcie->port->subordinate),\r\np_slot->ctrl->pcie->port->subordinate->number);\r\nmutex_lock(&p_slot->hotplug_lock);\r\npciehp_disable_slot(p_slot);\r\nmutex_unlock(&p_slot->hotplug_lock);\r\nmutex_lock(&p_slot->lock);\r\np_slot->state = STATIC_STATE;\r\nmutex_unlock(&p_slot->lock);\r\nbreak;\r\ncase ENABLE_REQ:\r\nctrl_dbg(p_slot->ctrl,\r\n"Enabling domain:bus:device=%04x:%02x:00\n",\r\npci_domain_nr(p_slot->ctrl->pcie->port->subordinate),\r\np_slot->ctrl->pcie->port->subordinate->number);\r\nmutex_lock(&p_slot->hotplug_lock);\r\nret = pciehp_enable_slot(p_slot);\r\nmutex_unlock(&p_slot->hotplug_lock);\r\nif (ret)\r\npciehp_green_led_off(p_slot);\r\nmutex_lock(&p_slot->lock);\r\np_slot->state = STATIC_STATE;\r\nmutex_unlock(&p_slot->lock);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nkfree(info);\r\n}\r\nvoid pciehp_queue_pushbutton_work(struct work_struct *work)\r\n{\r\nstruct slot *p_slot = container_of(work, struct slot, work.work);\r\nstruct power_work_info *info;\r\ninfo = kmalloc(sizeof(*info), GFP_KERNEL);\r\nif (!info) {\r\nctrl_err(p_slot->ctrl, "%s: Cannot allocate memory\n",\r\n__func__);\r\nreturn;\r\n}\r\ninfo->p_slot = p_slot;\r\nINIT_WORK(&info->work, pciehp_power_thread);\r\nmutex_lock(&p_slot->lock);\r\nswitch (p_slot->state) {\r\ncase BLINKINGOFF_STATE:\r\np_slot->state = POWEROFF_STATE;\r\ninfo->req = DISABLE_REQ;\r\nbreak;\r\ncase BLINKINGON_STATE:\r\np_slot->state = POWERON_STATE;\r\ninfo->req = ENABLE_REQ;\r\nbreak;\r\ndefault:\r\nkfree(info);\r\ngoto out;\r\n}\r\nqueue_work(p_slot->wq, &info->work);\r\nout:\r\nmutex_unlock(&p_slot->lock);\r\n}\r\nstatic void handle_button_press_event(struct slot *p_slot)\r\n{\r\nstruct controller *ctrl = p_slot->ctrl;\r\nu8 getstatus;\r\nswitch (p_slot->state) {\r\ncase STATIC_STATE:\r\npciehp_get_power_status(p_slot, &getstatus);\r\nif (getstatus) {\r\np_slot->state = BLINKINGOFF_STATE;\r\nctrl_info(ctrl, "PCI slot #%s - powering off due to button press\n",\r\nslot_name(p_slot));\r\n} else {\r\np_slot->state = BLINKINGON_STATE;\r\nctrl_info(ctrl, "PCI slot #%s - powering on due to button press\n",\r\nslot_name(p_slot));\r\n}\r\npciehp_green_led_blink(p_slot);\r\npciehp_set_attention_status(p_slot, 0);\r\nqueue_delayed_work(p_slot->wq, &p_slot->work, 5*HZ);\r\nbreak;\r\ncase BLINKINGOFF_STATE:\r\ncase BLINKINGON_STATE:\r\nctrl_info(ctrl, "Button cancel on Slot(%s)\n", slot_name(p_slot));\r\ncancel_delayed_work(&p_slot->work);\r\nif (p_slot->state == BLINKINGOFF_STATE)\r\npciehp_green_led_on(p_slot);\r\nelse\r\npciehp_green_led_off(p_slot);\r\npciehp_set_attention_status(p_slot, 0);\r\nctrl_info(ctrl, "PCI slot #%s - action canceled due to button press\n",\r\nslot_name(p_slot));\r\np_slot->state = STATIC_STATE;\r\nbreak;\r\ncase POWEROFF_STATE:\r\ncase POWERON_STATE:\r\nctrl_info(ctrl, "Button ignore on Slot(%s)\n", slot_name(p_slot));\r\nbreak;\r\ndefault:\r\nctrl_warn(ctrl, "Not a valid state\n");\r\nbreak;\r\n}\r\n}\r\nstatic void handle_surprise_event(struct slot *p_slot)\r\n{\r\nu8 getstatus;\r\nstruct power_work_info *info;\r\ninfo = kmalloc(sizeof(*info), GFP_KERNEL);\r\nif (!info) {\r\nctrl_err(p_slot->ctrl, "%s: Cannot allocate memory\n",\r\n__func__);\r\nreturn;\r\n}\r\ninfo->p_slot = p_slot;\r\nINIT_WORK(&info->work, pciehp_power_thread);\r\npciehp_get_adapter_status(p_slot, &getstatus);\r\nif (!getstatus) {\r\np_slot->state = POWEROFF_STATE;\r\ninfo->req = DISABLE_REQ;\r\n} else {\r\np_slot->state = POWERON_STATE;\r\ninfo->req = ENABLE_REQ;\r\n}\r\nqueue_work(p_slot->wq, &info->work);\r\n}\r\nstatic void handle_link_event(struct slot *p_slot, u32 event)\r\n{\r\nstruct controller *ctrl = p_slot->ctrl;\r\nstruct power_work_info *info;\r\ninfo = kmalloc(sizeof(*info), GFP_KERNEL);\r\nif (!info) {\r\nctrl_err(p_slot->ctrl, "%s: Cannot allocate memory\n",\r\n__func__);\r\nreturn;\r\n}\r\ninfo->p_slot = p_slot;\r\ninfo->req = event == INT_LINK_UP ? ENABLE_REQ : DISABLE_REQ;\r\nINIT_WORK(&info->work, pciehp_power_thread);\r\nswitch (p_slot->state) {\r\ncase BLINKINGON_STATE:\r\ncase BLINKINGOFF_STATE:\r\ncancel_delayed_work(&p_slot->work);\r\ncase STATIC_STATE:\r\np_slot->state = event == INT_LINK_UP ?\r\nPOWERON_STATE : POWEROFF_STATE;\r\nqueue_work(p_slot->wq, &info->work);\r\nbreak;\r\ncase POWERON_STATE:\r\nif (event == INT_LINK_UP) {\r\nctrl_info(ctrl,\r\n"Link Up event ignored on slot(%s): already powering on\n",\r\nslot_name(p_slot));\r\nkfree(info);\r\n} else {\r\nctrl_info(ctrl,\r\n"Link Down event queued on slot(%s): currently getting powered on\n",\r\nslot_name(p_slot));\r\np_slot->state = POWEROFF_STATE;\r\nqueue_work(p_slot->wq, &info->work);\r\n}\r\nbreak;\r\ncase POWEROFF_STATE:\r\nif (event == INT_LINK_UP) {\r\nctrl_info(ctrl,\r\n"Link Up event queued on slot(%s): currently getting powered off\n",\r\nslot_name(p_slot));\r\np_slot->state = POWERON_STATE;\r\nqueue_work(p_slot->wq, &info->work);\r\n} else {\r\nctrl_info(ctrl,\r\n"Link Down event ignored on slot(%s): already powering off\n",\r\nslot_name(p_slot));\r\nkfree(info);\r\n}\r\nbreak;\r\ndefault:\r\nctrl_err(ctrl, "Not a valid state on slot(%s)\n",\r\nslot_name(p_slot));\r\nkfree(info);\r\nbreak;\r\n}\r\n}\r\nstatic void interrupt_event_handler(struct work_struct *work)\r\n{\r\nstruct event_info *info = container_of(work, struct event_info, work);\r\nstruct slot *p_slot = info->p_slot;\r\nstruct controller *ctrl = p_slot->ctrl;\r\nmutex_lock(&p_slot->lock);\r\nswitch (info->event_type) {\r\ncase INT_BUTTON_PRESS:\r\nhandle_button_press_event(p_slot);\r\nbreak;\r\ncase INT_POWER_FAULT:\r\nif (!POWER_CTRL(ctrl))\r\nbreak;\r\npciehp_set_attention_status(p_slot, 1);\r\npciehp_green_led_off(p_slot);\r\nbreak;\r\ncase INT_PRESENCE_ON:\r\nctrl_dbg(ctrl, "Surprise Insertion\n");\r\nhandle_surprise_event(p_slot);\r\nbreak;\r\ncase INT_PRESENCE_OFF:\r\nctrl_dbg(ctrl, "Surprise Removal\n");\r\nhandle_surprise_event(p_slot);\r\nbreak;\r\ncase INT_LINK_UP:\r\ncase INT_LINK_DOWN:\r\nhandle_link_event(p_slot, info->event_type);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nmutex_unlock(&p_slot->lock);\r\nkfree(info);\r\n}\r\nint pciehp_enable_slot(struct slot *p_slot)\r\n{\r\nu8 getstatus = 0;\r\nint rc;\r\nstruct controller *ctrl = p_slot->ctrl;\r\npciehp_get_adapter_status(p_slot, &getstatus);\r\nif (!getstatus) {\r\nctrl_info(ctrl, "No adapter on slot(%s)\n", slot_name(p_slot));\r\nreturn -ENODEV;\r\n}\r\nif (MRL_SENS(p_slot->ctrl)) {\r\npciehp_get_latch_status(p_slot, &getstatus);\r\nif (getstatus) {\r\nctrl_info(ctrl, "Latch open on slot(%s)\n",\r\nslot_name(p_slot));\r\nreturn -ENODEV;\r\n}\r\n}\r\nif (POWER_CTRL(p_slot->ctrl)) {\r\npciehp_get_power_status(p_slot, &getstatus);\r\nif (getstatus) {\r\nctrl_info(ctrl, "Already enabled on slot(%s)\n",\r\nslot_name(p_slot));\r\nreturn -EINVAL;\r\n}\r\n}\r\npciehp_get_latch_status(p_slot, &getstatus);\r\nrc = board_added(p_slot);\r\nif (rc)\r\npciehp_get_latch_status(p_slot, &getstatus);\r\nreturn rc;\r\n}\r\nint pciehp_disable_slot(struct slot *p_slot)\r\n{\r\nu8 getstatus = 0;\r\nstruct controller *ctrl = p_slot->ctrl;\r\nif (!p_slot->ctrl)\r\nreturn 1;\r\nif (POWER_CTRL(p_slot->ctrl)) {\r\npciehp_get_power_status(p_slot, &getstatus);\r\nif (!getstatus) {\r\nctrl_info(ctrl, "Already disabled on slot(%s)\n",\r\nslot_name(p_slot));\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn remove_board(p_slot);\r\n}\r\nint pciehp_sysfs_enable_slot(struct slot *p_slot)\r\n{\r\nint retval = -ENODEV;\r\nstruct controller *ctrl = p_slot->ctrl;\r\nmutex_lock(&p_slot->lock);\r\nswitch (p_slot->state) {\r\ncase BLINKINGON_STATE:\r\ncancel_delayed_work(&p_slot->work);\r\ncase STATIC_STATE:\r\np_slot->state = POWERON_STATE;\r\nmutex_unlock(&p_slot->lock);\r\nmutex_lock(&p_slot->hotplug_lock);\r\nretval = pciehp_enable_slot(p_slot);\r\nmutex_unlock(&p_slot->hotplug_lock);\r\nmutex_lock(&p_slot->lock);\r\np_slot->state = STATIC_STATE;\r\nbreak;\r\ncase POWERON_STATE:\r\nctrl_info(ctrl, "Slot %s is already in powering on state\n",\r\nslot_name(p_slot));\r\nbreak;\r\ncase BLINKINGOFF_STATE:\r\ncase POWEROFF_STATE:\r\nctrl_info(ctrl, "Already enabled on slot %s\n",\r\nslot_name(p_slot));\r\nbreak;\r\ndefault:\r\nctrl_err(ctrl, "Not a valid state on slot %s\n",\r\nslot_name(p_slot));\r\nbreak;\r\n}\r\nmutex_unlock(&p_slot->lock);\r\nreturn retval;\r\n}\r\nint pciehp_sysfs_disable_slot(struct slot *p_slot)\r\n{\r\nint retval = -ENODEV;\r\nstruct controller *ctrl = p_slot->ctrl;\r\nmutex_lock(&p_slot->lock);\r\nswitch (p_slot->state) {\r\ncase BLINKINGOFF_STATE:\r\ncancel_delayed_work(&p_slot->work);\r\ncase STATIC_STATE:\r\np_slot->state = POWEROFF_STATE;\r\nmutex_unlock(&p_slot->lock);\r\nretval = pciehp_disable_slot(p_slot);\r\nmutex_lock(&p_slot->lock);\r\np_slot->state = STATIC_STATE;\r\nbreak;\r\ncase POWEROFF_STATE:\r\nctrl_info(ctrl, "Slot %s is already in powering off state\n",\r\nslot_name(p_slot));\r\nbreak;\r\ncase BLINKINGON_STATE:\r\ncase POWERON_STATE:\r\nctrl_info(ctrl, "Already disabled on slot %s\n",\r\nslot_name(p_slot));\r\nbreak;\r\ndefault:\r\nctrl_err(ctrl, "Not a valid state on slot %s\n",\r\nslot_name(p_slot));\r\nbreak;\r\n}\r\nmutex_unlock(&p_slot->lock);\r\nreturn retval;\r\n}
