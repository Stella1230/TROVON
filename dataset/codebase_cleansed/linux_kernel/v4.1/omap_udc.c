static void use_ep(struct omap_ep *ep, u16 select)\r\n{\r\nu16 num = ep->bEndpointAddress & 0x0f;\r\nif (ep->bEndpointAddress & USB_DIR_IN)\r\nnum |= UDC_EP_DIR;\r\nomap_writew(num | select, UDC_EP_NUM);\r\n}\r\nstatic inline void deselect_ep(void)\r\n{\r\nu16 w;\r\nw = omap_readw(UDC_EP_NUM);\r\nw &= ~UDC_EP_SEL;\r\nomap_writew(w, UDC_EP_NUM);\r\n}\r\nstatic int omap_ep_enable(struct usb_ep *_ep,\r\nconst struct usb_endpoint_descriptor *desc)\r\n{\r\nstruct omap_ep *ep = container_of(_ep, struct omap_ep, ep);\r\nstruct omap_udc *udc;\r\nunsigned long flags;\r\nu16 maxp;\r\nif (!_ep || !desc\r\n|| desc->bDescriptorType != USB_DT_ENDPOINT\r\n|| ep->bEndpointAddress != desc->bEndpointAddress\r\n|| ep->maxpacket < usb_endpoint_maxp(desc)) {\r\nDBG("%s, bad ep or descriptor\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nmaxp = usb_endpoint_maxp(desc);\r\nif ((desc->bmAttributes == USB_ENDPOINT_XFER_BULK\r\n&& maxp != ep->maxpacket)\r\n|| usb_endpoint_maxp(desc) > ep->maxpacket\r\n|| !desc->wMaxPacketSize) {\r\nDBG("%s, bad %s maxpacket\n", __func__, _ep->name);\r\nreturn -ERANGE;\r\n}\r\n#ifdef USE_ISO\r\nif ((desc->bmAttributes == USB_ENDPOINT_XFER_ISOC\r\n&& desc->bInterval != 1)) {\r\nDBG("%s, unsupported ISO period %dms\n", _ep->name,\r\n1 << (desc->bInterval - 1));\r\nreturn -EDOM;\r\n}\r\n#else\r\nif (desc->bmAttributes == USB_ENDPOINT_XFER_ISOC) {\r\nDBG("%s, ISO nyet\n", _ep->name);\r\nreturn -EDOM;\r\n}\r\n#endif\r\nif (ep->bmAttributes != desc->bmAttributes\r\n&& ep->bmAttributes != USB_ENDPOINT_XFER_BULK\r\n&& desc->bmAttributes != USB_ENDPOINT_XFER_INT) {\r\nDBG("%s, %s type mismatch\n", __func__, _ep->name);\r\nreturn -EINVAL;\r\n}\r\nudc = ep->udc;\r\nif (!udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN) {\r\nDBG("%s, bogus device state\n", __func__);\r\nreturn -ESHUTDOWN;\r\n}\r\nspin_lock_irqsave(&udc->lock, flags);\r\nep->ep.desc = desc;\r\nep->irqs = 0;\r\nep->stopped = 0;\r\nep->ep.maxpacket = maxp;\r\nep->dma_channel = 0;\r\nep->has_dma = 0;\r\nep->lch = -1;\r\nuse_ep(ep, UDC_EP_SEL);\r\nomap_writew(udc->clr_halt, UDC_CTRL);\r\nep->ackwait = 0;\r\ndeselect_ep();\r\nif (ep->bmAttributes == USB_ENDPOINT_XFER_ISOC)\r\nlist_add(&ep->iso, &udc->iso);\r\nif (use_dma && desc->bmAttributes == USB_ENDPOINT_XFER_BULK)\r\ndma_channel_claim(ep, 0);\r\nif (desc->bmAttributes != USB_ENDPOINT_XFER_ISOC\r\n&& !ep->has_dma\r\n&& !(ep->bEndpointAddress & USB_DIR_IN)) {\r\nomap_writew(UDC_SET_FIFO_EN, UDC_CTRL);\r\nep->ackwait = 1 + ep->double_buf;\r\n}\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nVDBG("%s enabled\n", _ep->name);\r\nreturn 0;\r\n}\r\nstatic int omap_ep_disable(struct usb_ep *_ep)\r\n{\r\nstruct omap_ep *ep = container_of(_ep, struct omap_ep, ep);\r\nunsigned long flags;\r\nif (!_ep || !ep->ep.desc) {\r\nDBG("%s, %s not enabled\n", __func__,\r\n_ep ? ep->ep.name : NULL);\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&ep->udc->lock, flags);\r\nep->ep.desc = NULL;\r\nnuke(ep, -ESHUTDOWN);\r\nep->ep.maxpacket = ep->maxpacket;\r\nep->has_dma = 0;\r\nomap_writew(UDC_SET_HALT, UDC_CTRL);\r\nlist_del_init(&ep->iso);\r\ndel_timer(&ep->timer);\r\nspin_unlock_irqrestore(&ep->udc->lock, flags);\r\nVDBG("%s disabled\n", _ep->name);\r\nreturn 0;\r\n}\r\nstatic struct usb_request *\r\nomap_alloc_request(struct usb_ep *ep, gfp_t gfp_flags)\r\n{\r\nstruct omap_req *req;\r\nreq = kzalloc(sizeof(*req), gfp_flags);\r\nif (!req)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&req->queue);\r\nreturn &req->req;\r\n}\r\nstatic void\r\nomap_free_request(struct usb_ep *ep, struct usb_request *_req)\r\n{\r\nstruct omap_req *req = container_of(_req, struct omap_req, req);\r\nkfree(req);\r\n}\r\nstatic void\r\ndone(struct omap_ep *ep, struct omap_req *req, int status)\r\n{\r\nstruct omap_udc *udc = ep->udc;\r\nunsigned stopped = ep->stopped;\r\nlist_del_init(&req->queue);\r\nif (req->req.status == -EINPROGRESS)\r\nreq->req.status = status;\r\nelse\r\nstatus = req->req.status;\r\nif (use_dma && ep->has_dma)\r\nusb_gadget_unmap_request(&udc->gadget, &req->req,\r\n(ep->bEndpointAddress & USB_DIR_IN));\r\n#ifndef USB_TRACE\r\nif (status && status != -ESHUTDOWN)\r\n#endif\r\nVDBG("complete %s req %p stat %d len %u/%u\n",\r\nep->ep.name, &req->req, status,\r\nreq->req.actual, req->req.length);\r\nep->stopped = 1;\r\nspin_unlock(&ep->udc->lock);\r\nusb_gadget_giveback_request(&ep->ep, &req->req);\r\nspin_lock(&ep->udc->lock);\r\nep->stopped = stopped;\r\n}\r\nstatic inline int\r\nwrite_packet(u8 *buf, struct omap_req *req, unsigned max)\r\n{\r\nunsigned len;\r\nu16 *wp;\r\nlen = min(req->req.length - req->req.actual, max);\r\nreq->req.actual += len;\r\nmax = len;\r\nif (likely((((int)buf) & 1) == 0)) {\r\nwp = (u16 *)buf;\r\nwhile (max >= 2) {\r\nomap_writew(*wp++, UDC_DATA);\r\nmax -= 2;\r\n}\r\nbuf = (u8 *)wp;\r\n}\r\nwhile (max--)\r\nomap_writeb(*buf++, UDC_DATA);\r\nreturn len;\r\n}\r\nstatic int write_fifo(struct omap_ep *ep, struct omap_req *req)\r\n{\r\nu8 *buf;\r\nunsigned count;\r\nint is_last;\r\nu16 ep_stat;\r\nbuf = req->req.buf + req->req.actual;\r\nprefetch(buf);\r\nep_stat = omap_readw(UDC_STAT_FLG);\r\nif (ep_stat & UDC_FIFO_UNWRITABLE)\r\nreturn 0;\r\ncount = ep->ep.maxpacket;\r\ncount = write_packet(buf, req, count);\r\nomap_writew(UDC_SET_FIFO_EN, UDC_CTRL);\r\nep->ackwait = 1;\r\nif (count != ep->ep.maxpacket)\r\nis_last = 1;\r\nelse if (req->req.length == req->req.actual\r\n&& !req->req.zero)\r\nis_last = 1;\r\nelse\r\nis_last = 0;\r\nif (is_last)\r\ndone(ep, req, 0);\r\nreturn is_last;\r\n}\r\nstatic inline int\r\nread_packet(u8 *buf, struct omap_req *req, unsigned avail)\r\n{\r\nunsigned len;\r\nu16 *wp;\r\nlen = min(req->req.length - req->req.actual, avail);\r\nreq->req.actual += len;\r\navail = len;\r\nif (likely((((int)buf) & 1) == 0)) {\r\nwp = (u16 *)buf;\r\nwhile (avail >= 2) {\r\n*wp++ = omap_readw(UDC_DATA);\r\navail -= 2;\r\n}\r\nbuf = (u8 *)wp;\r\n}\r\nwhile (avail--)\r\n*buf++ = omap_readb(UDC_DATA);\r\nreturn len;\r\n}\r\nstatic int read_fifo(struct omap_ep *ep, struct omap_req *req)\r\n{\r\nu8 *buf;\r\nunsigned count, avail;\r\nint is_last;\r\nbuf = req->req.buf + req->req.actual;\r\nprefetchw(buf);\r\nfor (;;) {\r\nu16 ep_stat = omap_readw(UDC_STAT_FLG);\r\nis_last = 0;\r\nif (ep_stat & FIFO_EMPTY) {\r\nif (!ep->double_buf)\r\nbreak;\r\nep->fnf = 1;\r\n}\r\nif (ep_stat & UDC_EP_HALTED)\r\nbreak;\r\nif (ep_stat & UDC_FIFO_FULL)\r\navail = ep->ep.maxpacket;\r\nelse {\r\navail = omap_readw(UDC_RXFSTAT);\r\nep->fnf = ep->double_buf;\r\n}\r\ncount = read_packet(buf, req, avail);\r\nif (count < ep->ep.maxpacket) {\r\nis_last = 1;\r\nif (count != avail) {\r\nreq->req.status = -EOVERFLOW;\r\navail -= count;\r\nwhile (avail--)\r\nomap_readw(UDC_DATA);\r\n}\r\n} else if (req->req.length == req->req.actual)\r\nis_last = 1;\r\nelse\r\nis_last = 0;\r\nif (!ep->bEndpointAddress)\r\nbreak;\r\nif (is_last)\r\ndone(ep, req, 0);\r\nbreak;\r\n}\r\nreturn is_last;\r\n}\r\nstatic u16 dma_src_len(struct omap_ep *ep, dma_addr_t start)\r\n{\r\ndma_addr_t end;\r\nif (cpu_is_omap15xx())\r\nreturn 0;\r\nend = omap_get_dma_src_pos(ep->lch);\r\nif (end == ep->dma_counter)\r\nreturn 0;\r\nend |= start & (0xffff << 16);\r\nif (end < start)\r\nend += 0x10000;\r\nreturn end - start;\r\n}\r\nstatic u16 dma_dest_len(struct omap_ep *ep, dma_addr_t start)\r\n{\r\ndma_addr_t end;\r\nend = omap_get_dma_dst_pos(ep->lch);\r\nif (end == ep->dma_counter)\r\nreturn 0;\r\nend |= start & (0xffff << 16);\r\nif (cpu_is_omap15xx())\r\nend++;\r\nif (end < start)\r\nend += 0x10000;\r\nreturn end - start;\r\n}\r\nstatic void next_in_dma(struct omap_ep *ep, struct omap_req *req)\r\n{\r\nu16 txdma_ctrl, w;\r\nunsigned length = req->req.length - req->req.actual;\r\nconst int sync_mode = cpu_is_omap15xx()\r\n? OMAP_DMA_SYNC_FRAME\r\n: OMAP_DMA_SYNC_ELEMENT;\r\nint dma_trigger = 0;\r\nif ((cpu_is_omap16xx() && length <= UDC_TXN_TSC)\r\n|| (cpu_is_omap15xx() && length < ep->maxpacket)) {\r\ntxdma_ctrl = UDC_TXN_EOT | length;\r\nomap_set_dma_transfer_params(ep->lch, OMAP_DMA_DATA_TYPE_S8,\r\nlength, 1, sync_mode, dma_trigger, 0);\r\n} else {\r\nlength = min(length / ep->maxpacket,\r\n(unsigned) UDC_TXN_TSC + 1);\r\ntxdma_ctrl = length;\r\nomap_set_dma_transfer_params(ep->lch, OMAP_DMA_DATA_TYPE_S16,\r\nep->ep.maxpacket >> 1, length, sync_mode,\r\ndma_trigger, 0);\r\nlength *= ep->maxpacket;\r\n}\r\nomap_set_dma_src_params(ep->lch, OMAP_DMA_PORT_EMIFF,\r\nOMAP_DMA_AMODE_POST_INC, req->req.dma + req->req.actual,\r\n0, 0);\r\nomap_start_dma(ep->lch);\r\nep->dma_counter = omap_get_dma_src_pos(ep->lch);\r\nw = omap_readw(UDC_DMA_IRQ_EN);\r\nw |= UDC_TX_DONE_IE(ep->dma_channel);\r\nomap_writew(w, UDC_DMA_IRQ_EN);\r\nomap_writew(UDC_TXN_START | txdma_ctrl, UDC_TXDMA(ep->dma_channel));\r\nreq->dma_bytes = length;\r\n}\r\nstatic void finish_in_dma(struct omap_ep *ep, struct omap_req *req, int status)\r\n{\r\nu16 w;\r\nif (status == 0) {\r\nreq->req.actual += req->dma_bytes;\r\nif (req->req.actual < req->req.length)\r\nreturn;\r\nif (req->req.zero\r\n&& req->dma_bytes != 0\r\n&& (req->req.actual % ep->maxpacket) == 0)\r\nreturn;\r\n} else\r\nreq->req.actual += dma_src_len(ep, req->req.dma\r\n+ req->req.actual);\r\nomap_stop_dma(ep->lch);\r\nw = omap_readw(UDC_DMA_IRQ_EN);\r\nw &= ~UDC_TX_DONE_IE(ep->dma_channel);\r\nomap_writew(w, UDC_DMA_IRQ_EN);\r\ndone(ep, req, status);\r\n}\r\nstatic void next_out_dma(struct omap_ep *ep, struct omap_req *req)\r\n{\r\nunsigned packets = req->req.length - req->req.actual;\r\nint dma_trigger = 0;\r\nu16 w;\r\npackets /= ep->ep.maxpacket;\r\npackets = min(packets, (unsigned)UDC_RXN_TC + 1);\r\nreq->dma_bytes = packets * ep->ep.maxpacket;\r\nomap_set_dma_transfer_params(ep->lch, OMAP_DMA_DATA_TYPE_S16,\r\nep->ep.maxpacket >> 1, packets,\r\nOMAP_DMA_SYNC_ELEMENT,\r\ndma_trigger, 0);\r\nomap_set_dma_dest_params(ep->lch, OMAP_DMA_PORT_EMIFF,\r\nOMAP_DMA_AMODE_POST_INC, req->req.dma + req->req.actual,\r\n0, 0);\r\nep->dma_counter = omap_get_dma_dst_pos(ep->lch);\r\nomap_writew(UDC_RXN_STOP | (packets - 1), UDC_RXDMA(ep->dma_channel));\r\nw = omap_readw(UDC_DMA_IRQ_EN);\r\nw |= UDC_RX_EOT_IE(ep->dma_channel);\r\nomap_writew(w, UDC_DMA_IRQ_EN);\r\nomap_writew(ep->bEndpointAddress & 0xf, UDC_EP_NUM);\r\nomap_writew(UDC_SET_FIFO_EN, UDC_CTRL);\r\nomap_start_dma(ep->lch);\r\n}\r\nstatic void\r\nfinish_out_dma(struct omap_ep *ep, struct omap_req *req, int status, int one)\r\n{\r\nu16 count, w;\r\nif (status == 0)\r\nep->dma_counter = (u16) (req->req.dma + req->req.actual);\r\ncount = dma_dest_len(ep, req->req.dma + req->req.actual);\r\ncount += req->req.actual;\r\nif (one)\r\ncount--;\r\nif (count <= req->req.length)\r\nreq->req.actual = count;\r\nif (count != req->dma_bytes || status)\r\nomap_stop_dma(ep->lch);\r\nelse if (req->req.actual < req->req.length)\r\nreturn;\r\nw = omap_readw(UDC_DMA_IRQ_EN);\r\nw &= ~UDC_RX_EOT_IE(ep->dma_channel);\r\nomap_writew(w, UDC_DMA_IRQ_EN);\r\ndone(ep, req, status);\r\n}\r\nstatic void dma_irq(struct omap_udc *udc, u16 irq_src)\r\n{\r\nu16 dman_stat = omap_readw(UDC_DMAN_STAT);\r\nstruct omap_ep *ep;\r\nstruct omap_req *req;\r\nif (irq_src & UDC_TXN_DONE) {\r\nep = &udc->ep[16 + UDC_DMA_TX_SRC(dman_stat)];\r\nep->irqs++;\r\nif (!list_empty(&ep->queue)) {\r\nreq = container_of(ep->queue.next,\r\nstruct omap_req, queue);\r\nfinish_in_dma(ep, req, 0);\r\n}\r\nomap_writew(UDC_TXN_DONE, UDC_IRQ_SRC);\r\nif (!list_empty(&ep->queue)) {\r\nreq = container_of(ep->queue.next,\r\nstruct omap_req, queue);\r\nnext_in_dma(ep, req);\r\n}\r\n}\r\nif (irq_src & UDC_RXN_EOT) {\r\nep = &udc->ep[UDC_DMA_RX_SRC(dman_stat)];\r\nep->irqs++;\r\nif (!list_empty(&ep->queue)) {\r\nreq = container_of(ep->queue.next,\r\nstruct omap_req, queue);\r\nfinish_out_dma(ep, req, 0, dman_stat & UDC_DMA_RX_SB);\r\n}\r\nomap_writew(UDC_RXN_EOT, UDC_IRQ_SRC);\r\nif (!list_empty(&ep->queue)) {\r\nreq = container_of(ep->queue.next,\r\nstruct omap_req, queue);\r\nnext_out_dma(ep, req);\r\n}\r\n}\r\nif (irq_src & UDC_RXN_CNT) {\r\nep = &udc->ep[UDC_DMA_RX_SRC(dman_stat)];\r\nep->irqs++;\r\nVDBG("%s, RX_CNT irq?\n", ep->ep.name);\r\nomap_writew(UDC_RXN_CNT, UDC_IRQ_SRC);\r\n}\r\n}\r\nstatic void dma_error(int lch, u16 ch_status, void *data)\r\n{\r\nstruct omap_ep *ep = data;\r\nERR("%s dma error, lch %d status %02x\n", ep->ep.name, lch, ch_status);\r\n}\r\nstatic void dma_channel_claim(struct omap_ep *ep, unsigned channel)\r\n{\r\nu16 reg;\r\nint status, restart, is_in;\r\nint dma_channel;\r\nis_in = ep->bEndpointAddress & USB_DIR_IN;\r\nif (is_in)\r\nreg = omap_readw(UDC_TXDMA_CFG);\r\nelse\r\nreg = omap_readw(UDC_RXDMA_CFG);\r\nreg |= UDC_DMA_REQ;\r\nep->dma_channel = 0;\r\nep->lch = -1;\r\nif (channel == 0 || channel > 3) {\r\nif ((reg & 0x0f00) == 0)\r\nchannel = 3;\r\nelse if ((reg & 0x00f0) == 0)\r\nchannel = 2;\r\nelse if ((reg & 0x000f) == 0)\r\nchannel = 1;\r\nelse {\r\nstatus = -EMLINK;\r\ngoto just_restart;\r\n}\r\n}\r\nreg |= (0x0f & ep->bEndpointAddress) << (4 * (channel - 1));\r\nep->dma_channel = channel;\r\nif (is_in) {\r\ndma_channel = OMAP_DMA_USB_W2FC_TX0 - 1 + channel;\r\nstatus = omap_request_dma(dma_channel,\r\nep->ep.name, dma_error, ep, &ep->lch);\r\nif (status == 0) {\r\nomap_writew(reg, UDC_TXDMA_CFG);\r\nomap_set_dma_src_burst_mode(ep->lch,\r\nOMAP_DMA_DATA_BURST_4);\r\nomap_set_dma_src_data_pack(ep->lch, 1);\r\nomap_set_dma_dest_params(ep->lch,\r\nOMAP_DMA_PORT_TIPB,\r\nOMAP_DMA_AMODE_CONSTANT,\r\nUDC_DATA_DMA,\r\n0, 0);\r\n}\r\n} else {\r\ndma_channel = OMAP_DMA_USB_W2FC_RX0 - 1 + channel;\r\nstatus = omap_request_dma(dma_channel,\r\nep->ep.name, dma_error, ep, &ep->lch);\r\nif (status == 0) {\r\nomap_writew(reg, UDC_RXDMA_CFG);\r\nomap_set_dma_src_params(ep->lch,\r\nOMAP_DMA_PORT_TIPB,\r\nOMAP_DMA_AMODE_CONSTANT,\r\nUDC_DATA_DMA,\r\n0, 0);\r\nomap_set_dma_dest_burst_mode(ep->lch,\r\nOMAP_DMA_DATA_BURST_4);\r\nomap_set_dma_dest_data_pack(ep->lch, 1);\r\n}\r\n}\r\nif (status)\r\nep->dma_channel = 0;\r\nelse {\r\nep->has_dma = 1;\r\nomap_disable_dma_irq(ep->lch, OMAP_DMA_BLOCK_IRQ);\r\nif (!cpu_is_omap15xx())\r\nomap_set_dma_channel_mode(ep->lch, OMAP_DMA_LCH_P);\r\n}\r\njust_restart:\r\nrestart = !ep->stopped && !list_empty(&ep->queue);\r\nif (status)\r\nDBG("%s no dma channel: %d%s\n", ep->ep.name, status,\r\nrestart ? " (restart)" : "");\r\nelse\r\nDBG("%s claimed %cxdma%d lch %d%s\n", ep->ep.name,\r\nis_in ? 't' : 'r',\r\nep->dma_channel - 1, ep->lch,\r\nrestart ? " (restart)" : "");\r\nif (restart) {\r\nstruct omap_req *req;\r\nreq = container_of(ep->queue.next, struct omap_req, queue);\r\nif (ep->has_dma)\r\n(is_in ? next_in_dma : next_out_dma)(ep, req);\r\nelse {\r\nuse_ep(ep, UDC_EP_SEL);\r\n(is_in ? write_fifo : read_fifo)(ep, req);\r\ndeselect_ep();\r\nif (!is_in) {\r\nomap_writew(UDC_SET_FIFO_EN, UDC_CTRL);\r\nep->ackwait = 1 + ep->double_buf;\r\n}\r\n}\r\n}\r\n}\r\nstatic void dma_channel_release(struct omap_ep *ep)\r\n{\r\nint shift = 4 * (ep->dma_channel - 1);\r\nu16 mask = 0x0f << shift;\r\nstruct omap_req *req;\r\nint active;\r\nif (!list_empty(&ep->queue))\r\nreq = container_of(ep->queue.next, struct omap_req, queue);\r\nelse\r\nreq = NULL;\r\nactive = omap_get_dma_active_status(ep->lch);\r\nDBG("%s release %s %cxdma%d %p\n", ep->ep.name,\r\nactive ? "active" : "idle",\r\n(ep->bEndpointAddress & USB_DIR_IN) ? 't' : 'r',\r\nep->dma_channel - 1, req);\r\nif (ep->bEndpointAddress & USB_DIR_IN) {\r\nomap_writew((omap_readw(UDC_TXDMA_CFG) & ~mask) | UDC_DMA_REQ,\r\nUDC_TXDMA_CFG);\r\nif (req) {\r\nfinish_in_dma(ep, req, -ECONNRESET);\r\nuse_ep(ep, UDC_EP_SEL);\r\nomap_writew(UDC_CLR_EP, UDC_CTRL);\r\ndeselect_ep();\r\n}\r\nwhile (omap_readw(UDC_TXDMA_CFG) & mask)\r\nudelay(10);\r\n} else {\r\nomap_writew((omap_readw(UDC_RXDMA_CFG) & ~mask) | UDC_DMA_REQ,\r\nUDC_RXDMA_CFG);\r\nwhile (omap_readw(UDC_RXDMA_CFG) & mask)\r\nudelay(10);\r\nif (req)\r\nfinish_out_dma(ep, req, -ECONNRESET, 0);\r\n}\r\nomap_free_dma(ep->lch);\r\nep->dma_channel = 0;\r\nep->lch = -1;\r\n}\r\nstatic int\r\nomap_ep_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)\r\n{\r\nstruct omap_ep *ep = container_of(_ep, struct omap_ep, ep);\r\nstruct omap_req *req = container_of(_req, struct omap_req, req);\r\nstruct omap_udc *udc;\r\nunsigned long flags;\r\nint is_iso = 0;\r\nif (!_req || !req->req.complete || !req->req.buf\r\n|| !list_empty(&req->queue)) {\r\nDBG("%s, bad params\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (!_ep || (!ep->ep.desc && ep->bEndpointAddress)) {\r\nDBG("%s, bad ep\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (ep->bmAttributes == USB_ENDPOINT_XFER_ISOC) {\r\nif (req->req.length > ep->ep.maxpacket)\r\nreturn -EMSGSIZE;\r\nis_iso = 1;\r\n}\r\nif (use_dma\r\n&& ep->has_dma\r\n&& ep->bEndpointAddress != 0\r\n&& (ep->bEndpointAddress & USB_DIR_IN) == 0\r\n&& (req->req.length % ep->ep.maxpacket) != 0) {\r\nDBG("%s, no partial packet OUT reads\n", __func__);\r\nreturn -EMSGSIZE;\r\n}\r\nudc = ep->udc;\r\nif (!udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN)\r\nreturn -ESHUTDOWN;\r\nif (use_dma && ep->has_dma)\r\nusb_gadget_map_request(&udc->gadget, &req->req,\r\n(ep->bEndpointAddress & USB_DIR_IN));\r\nVDBG("%s queue req %p, len %d buf %p\n",\r\nep->ep.name, _req, _req->length, _req->buf);\r\nspin_lock_irqsave(&udc->lock, flags);\r\nreq->req.status = -EINPROGRESS;\r\nreq->req.actual = 0;\r\nif (is_iso) {\r\nu16 w;\r\nw = omap_readw(UDC_IRQ_EN);\r\nw |= UDC_SOF_IE;\r\nomap_writew(w, UDC_IRQ_EN);\r\n} else if (list_empty(&ep->queue) && !ep->stopped && !ep->ackwait) {\r\nint is_in;\r\nif (ep->bEndpointAddress == 0) {\r\nif (!udc->ep0_pending || !list_empty(&ep->queue)) {\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn -EL2HLT;\r\n}\r\nis_in = udc->ep0_in;\r\nif (!req->req.length) {\r\nif (udc->ep0_set_config) {\r\nu16 irq_en = omap_readw(UDC_IRQ_EN);\r\nirq_en |= UDC_DS_CHG_IE | UDC_EP0_IE;\r\nif (!udc->ep0_reset_config)\r\nirq_en |= UDC_EPN_RX_IE\r\n| UDC_EPN_TX_IE;\r\nomap_writew(irq_en, UDC_IRQ_EN);\r\n}\r\nomap_writew(UDC_EP_SEL | UDC_EP_DIR,\r\nUDC_EP_NUM);\r\nomap_writew(UDC_CLR_EP, UDC_CTRL);\r\nomap_writew(UDC_SET_FIFO_EN, UDC_CTRL);\r\nomap_writew(UDC_EP_DIR, UDC_EP_NUM);\r\nudc->ep0_pending = 0;\r\ndone(ep, req, 0);\r\nreq = NULL;\r\n} else if (is_in) {\r\nomap_writew(UDC_EP_SEL | UDC_EP_DIR,\r\nUDC_EP_NUM);\r\n} else {\r\nif (udc->ep0_setup)\r\ngoto irq_wait;\r\nomap_writew(UDC_EP_SEL, UDC_EP_NUM);\r\n}\r\n} else {\r\nis_in = ep->bEndpointAddress & USB_DIR_IN;\r\nif (!ep->has_dma)\r\nuse_ep(ep, UDC_EP_SEL);\r\n}\r\nif (ep->has_dma)\r\n(is_in ? next_in_dma : next_out_dma)(ep, req);\r\nelse if (req) {\r\nif ((is_in ? write_fifo : read_fifo)(ep, req) == 1)\r\nreq = NULL;\r\ndeselect_ep();\r\nif (!is_in) {\r\nomap_writew(UDC_SET_FIFO_EN, UDC_CTRL);\r\nep->ackwait = 1 + ep->double_buf;\r\n}\r\n}\r\n}\r\nirq_wait:\r\nif (req != NULL)\r\nlist_add_tail(&req->queue, &ep->queue);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int omap_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\nstruct omap_ep *ep = container_of(_ep, struct omap_ep, ep);\r\nstruct omap_req *req;\r\nunsigned long flags;\r\nif (!_ep || !_req)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&ep->udc->lock, flags);\r\nlist_for_each_entry(req, &ep->queue, queue) {\r\nif (&req->req == _req)\r\nbreak;\r\n}\r\nif (&req->req != _req) {\r\nspin_unlock_irqrestore(&ep->udc->lock, flags);\r\nreturn -EINVAL;\r\n}\r\nif (use_dma && ep->dma_channel && ep->queue.next == &req->queue) {\r\nint channel = ep->dma_channel;\r\ndma_channel_release(ep);\r\ndma_channel_claim(ep, channel);\r\n} else\r\ndone(ep, req, -ECONNRESET);\r\nspin_unlock_irqrestore(&ep->udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int omap_ep_set_halt(struct usb_ep *_ep, int value)\r\n{\r\nstruct omap_ep *ep = container_of(_ep, struct omap_ep, ep);\r\nunsigned long flags;\r\nint status = -EOPNOTSUPP;\r\nspin_lock_irqsave(&ep->udc->lock, flags);\r\nif (ep->bEndpointAddress == 0) {\r\nif (!ep->udc->ep0_pending)\r\nstatus = -EINVAL;\r\nelse if (value) {\r\nif (ep->udc->ep0_set_config) {\r\nWARNING("error changing config?\n");\r\nomap_writew(UDC_CLR_CFG, UDC_SYSCON2);\r\n}\r\nomap_writew(UDC_STALL_CMD, UDC_SYSCON2);\r\nep->udc->ep0_pending = 0;\r\nstatus = 0;\r\n} else\r\nstatus = 0;\r\n} else if (ep->bmAttributes != USB_ENDPOINT_XFER_ISOC && ep->ep.desc) {\r\nif ((ep->bEndpointAddress & USB_DIR_IN)\r\n&& !list_empty(&ep->queue)) {\r\nstatus = -EAGAIN;\r\ngoto done;\r\n}\r\nif (value) {\r\nint channel;\r\nif (use_dma && ep->dma_channel\r\n&& !list_empty(&ep->queue)) {\r\nchannel = ep->dma_channel;\r\ndma_channel_release(ep);\r\n} else\r\nchannel = 0;\r\nuse_ep(ep, UDC_EP_SEL);\r\nif (omap_readw(UDC_STAT_FLG) & UDC_NON_ISO_FIFO_EMPTY) {\r\nomap_writew(UDC_SET_HALT, UDC_CTRL);\r\nstatus = 0;\r\n} else\r\nstatus = -EAGAIN;\r\ndeselect_ep();\r\nif (channel)\r\ndma_channel_claim(ep, channel);\r\n} else {\r\nuse_ep(ep, 0);\r\nomap_writew(ep->udc->clr_halt, UDC_CTRL);\r\nep->ackwait = 0;\r\nif (!(ep->bEndpointAddress & USB_DIR_IN)) {\r\nomap_writew(UDC_SET_FIFO_EN, UDC_CTRL);\r\nep->ackwait = 1 + ep->double_buf;\r\n}\r\n}\r\n}\r\ndone:\r\nVDBG("%s %s halt stat %d\n", ep->ep.name,\r\nvalue ? "set" : "clear", status);\r\nspin_unlock_irqrestore(&ep->udc->lock, flags);\r\nreturn status;\r\n}\r\nstatic int omap_get_frame(struct usb_gadget *gadget)\r\n{\r\nu16 sof = omap_readw(UDC_SOF);\r\nreturn (sof & UDC_TS_OK) ? (sof & UDC_TS) : -EL2NSYNC;\r\n}\r\nstatic int omap_wakeup(struct usb_gadget *gadget)\r\n{\r\nstruct omap_udc *udc;\r\nunsigned long flags;\r\nint retval = -EHOSTUNREACH;\r\nudc = container_of(gadget, struct omap_udc, gadget);\r\nspin_lock_irqsave(&udc->lock, flags);\r\nif (udc->devstat & UDC_SUS) {\r\nif (udc->devstat & (UDC_B_HNP_ENABLE|UDC_R_WK_OK)) {\r\nDBG("remote wakeup...\n");\r\nomap_writew(UDC_RMT_WKP, UDC_SYSCON2);\r\nretval = 0;\r\n}\r\n} else if (!(udc->devstat & UDC_ATT)) {\r\nif (!IS_ERR_OR_NULL(udc->transceiver))\r\nretval = otg_start_srp(udc->transceiver->otg);\r\n}\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn retval;\r\n}\r\nstatic int\r\nomap_set_selfpowered(struct usb_gadget *gadget, int is_selfpowered)\r\n{\r\nstruct omap_udc *udc;\r\nunsigned long flags;\r\nu16 syscon1;\r\ngadget->is_selfpowered = (is_selfpowered != 0);\r\nudc = container_of(gadget, struct omap_udc, gadget);\r\nspin_lock_irqsave(&udc->lock, flags);\r\nsyscon1 = omap_readw(UDC_SYSCON1);\r\nif (is_selfpowered)\r\nsyscon1 |= UDC_SELF_PWR;\r\nelse\r\nsyscon1 &= ~UDC_SELF_PWR;\r\nomap_writew(syscon1, UDC_SYSCON1);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int can_pullup(struct omap_udc *udc)\r\n{\r\nreturn udc->driver && udc->softconnect && udc->vbus_active;\r\n}\r\nstatic void pullup_enable(struct omap_udc *udc)\r\n{\r\nu16 w;\r\nw = omap_readw(UDC_SYSCON1);\r\nw |= UDC_PULLUP_EN;\r\nomap_writew(w, UDC_SYSCON1);\r\nif (!gadget_is_otg(&udc->gadget) && !cpu_is_omap15xx()) {\r\nu32 l;\r\nl = omap_readl(OTG_CTRL);\r\nl |= OTG_BSESSVLD;\r\nomap_writel(l, OTG_CTRL);\r\n}\r\nomap_writew(UDC_DS_CHG_IE, UDC_IRQ_EN);\r\n}\r\nstatic void pullup_disable(struct omap_udc *udc)\r\n{\r\nu16 w;\r\nif (!gadget_is_otg(&udc->gadget) && !cpu_is_omap15xx()) {\r\nu32 l;\r\nl = omap_readl(OTG_CTRL);\r\nl &= ~OTG_BSESSVLD;\r\nomap_writel(l, OTG_CTRL);\r\n}\r\nomap_writew(UDC_DS_CHG_IE, UDC_IRQ_EN);\r\nw = omap_readw(UDC_SYSCON1);\r\nw &= ~UDC_PULLUP_EN;\r\nomap_writew(w, UDC_SYSCON1);\r\n}\r\nstatic void omap_udc_enable_clock(int enable)\r\n{\r\nif (udc == NULL || udc->dc_clk == NULL || udc->hhc_clk == NULL)\r\nreturn;\r\nif (enable) {\r\nclk_enable(udc->dc_clk);\r\nclk_enable(udc->hhc_clk);\r\nudelay(100);\r\n} else {\r\nclk_disable(udc->hhc_clk);\r\nclk_disable(udc->dc_clk);\r\n}\r\n}\r\nstatic int omap_vbus_session(struct usb_gadget *gadget, int is_active)\r\n{\r\nstruct omap_udc *udc;\r\nunsigned long flags;\r\nu32 l;\r\nudc = container_of(gadget, struct omap_udc, gadget);\r\nspin_lock_irqsave(&udc->lock, flags);\r\nVDBG("VBUS %s\n", is_active ? "on" : "off");\r\nudc->vbus_active = (is_active != 0);\r\nif (cpu_is_omap15xx()) {\r\nl = omap_readl(FUNC_MUX_CTRL_0);\r\nif (is_active)\r\nl |= VBUS_CTRL_1510;\r\nelse\r\nl &= ~VBUS_CTRL_1510;\r\nomap_writel(l, FUNC_MUX_CTRL_0);\r\n}\r\nif (udc->dc_clk != NULL && is_active) {\r\nif (!udc->clk_requested) {\r\nomap_udc_enable_clock(1);\r\nudc->clk_requested = 1;\r\n}\r\n}\r\nif (can_pullup(udc))\r\npullup_enable(udc);\r\nelse\r\npullup_disable(udc);\r\nif (udc->dc_clk != NULL && !is_active) {\r\nif (udc->clk_requested) {\r\nomap_udc_enable_clock(0);\r\nudc->clk_requested = 0;\r\n}\r\n}\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int omap_vbus_draw(struct usb_gadget *gadget, unsigned mA)\r\n{\r\nstruct omap_udc *udc;\r\nudc = container_of(gadget, struct omap_udc, gadget);\r\nif (!IS_ERR_OR_NULL(udc->transceiver))\r\nreturn usb_phy_set_power(udc->transceiver, mA);\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int omap_pullup(struct usb_gadget *gadget, int is_on)\r\n{\r\nstruct omap_udc *udc;\r\nunsigned long flags;\r\nudc = container_of(gadget, struct omap_udc, gadget);\r\nspin_lock_irqsave(&udc->lock, flags);\r\nudc->softconnect = (is_on != 0);\r\nif (can_pullup(udc))\r\npullup_enable(udc);\r\nelse\r\npullup_disable(udc);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void nuke(struct omap_ep *ep, int status)\r\n{\r\nstruct omap_req *req;\r\nep->stopped = 1;\r\nif (use_dma && ep->dma_channel)\r\ndma_channel_release(ep);\r\nuse_ep(ep, 0);\r\nomap_writew(UDC_CLR_EP, UDC_CTRL);\r\nif (ep->bEndpointAddress && ep->bmAttributes != USB_ENDPOINT_XFER_ISOC)\r\nomap_writew(UDC_SET_HALT, UDC_CTRL);\r\nwhile (!list_empty(&ep->queue)) {\r\nreq = list_entry(ep->queue.next, struct omap_req, queue);\r\ndone(ep, req, status);\r\n}\r\n}\r\nstatic void udc_quiesce(struct omap_udc *udc)\r\n{\r\nstruct omap_ep *ep;\r\nudc->gadget.speed = USB_SPEED_UNKNOWN;\r\nnuke(&udc->ep[0], -ESHUTDOWN);\r\nlist_for_each_entry(ep, &udc->gadget.ep_list, ep.ep_list)\r\nnuke(ep, -ESHUTDOWN);\r\n}\r\nstatic void update_otg(struct omap_udc *udc)\r\n{\r\nu16 devstat;\r\nif (!gadget_is_otg(&udc->gadget))\r\nreturn;\r\nif (omap_readl(OTG_CTRL) & OTG_ID)\r\ndevstat = omap_readw(UDC_DEVSTAT);\r\nelse\r\ndevstat = 0;\r\nudc->gadget.b_hnp_enable = !!(devstat & UDC_B_HNP_ENABLE);\r\nudc->gadget.a_hnp_support = !!(devstat & UDC_A_HNP_SUPPORT);\r\nudc->gadget.a_alt_hnp_support = !!(devstat & UDC_A_ALT_HNP_SUPPORT);\r\nif (udc->gadget.b_hnp_enable) {\r\nu32 l;\r\nl = omap_readl(OTG_CTRL);\r\nl |= OTG_B_HNPEN | OTG_B_BUSREQ;\r\nl &= ~OTG_PULLUP;\r\nomap_writel(l, OTG_CTRL);\r\n}\r\n}\r\nstatic void ep0_irq(struct omap_udc *udc, u16 irq_src)\r\n{\r\nstruct omap_ep *ep0 = &udc->ep[0];\r\nstruct omap_req *req = NULL;\r\nep0->irqs++;\r\nif (irq_src & UDC_SETUP) {\r\nu16 ack = irq_src & (UDC_EP0_TX|UDC_EP0_RX);\r\nnuke(ep0, 0);\r\nif (ack) {\r\nomap_writew(ack, UDC_IRQ_SRC);\r\nirq_src = UDC_SETUP;\r\n}\r\n}\r\nif (!list_empty(&ep0->queue))\r\nreq = container_of(ep0->queue.next, struct omap_req, queue);\r\nif (irq_src & UDC_EP0_TX) {\r\nint stat;\r\nomap_writew(UDC_EP0_TX, UDC_IRQ_SRC);\r\nomap_writew(UDC_EP_SEL|UDC_EP_DIR, UDC_EP_NUM);\r\nstat = omap_readw(UDC_STAT_FLG);\r\nif (stat & UDC_ACK) {\r\nif (udc->ep0_in) {\r\nif (req)\r\nstat = write_fifo(ep0, req);\r\nomap_writew(UDC_EP_DIR, UDC_EP_NUM);\r\nif (!req && udc->ep0_pending) {\r\nomap_writew(UDC_EP_SEL, UDC_EP_NUM);\r\nomap_writew(UDC_CLR_EP, UDC_CTRL);\r\nomap_writew(UDC_SET_FIFO_EN, UDC_CTRL);\r\nomap_writew(0, UDC_EP_NUM);\r\nudc->ep0_pending = 0;\r\n}\r\n} else {\r\nomap_writew(UDC_EP_DIR, UDC_EP_NUM);\r\nif (req)\r\ndone(ep0, req, 0);\r\n}\r\nreq = NULL;\r\n} else if (stat & UDC_STALL) {\r\nomap_writew(UDC_CLR_HALT, UDC_CTRL);\r\nomap_writew(UDC_EP_DIR, UDC_EP_NUM);\r\n} else {\r\nomap_writew(UDC_EP_DIR, UDC_EP_NUM);\r\n}\r\n}\r\nif (irq_src & UDC_EP0_RX) {\r\nint stat;\r\nomap_writew(UDC_EP0_RX, UDC_IRQ_SRC);\r\nomap_writew(UDC_EP_SEL, UDC_EP_NUM);\r\nstat = omap_readw(UDC_STAT_FLG);\r\nif (stat & UDC_ACK) {\r\nif (!udc->ep0_in) {\r\nstat = 0;\r\nstat = read_fifo(ep0, req);\r\nif (!req || stat < 0) {\r\nomap_writew(UDC_STALL_CMD, UDC_SYSCON2);\r\nudc->ep0_pending = 0;\r\nstat = 0;\r\n} else if (stat == 0)\r\nomap_writew(UDC_SET_FIFO_EN, UDC_CTRL);\r\nomap_writew(0, UDC_EP_NUM);\r\nif (stat == 1) {\r\ndone(ep0, req, 0);\r\nomap_writew(UDC_EP_SEL | UDC_EP_DIR,\r\nUDC_EP_NUM);\r\nomap_writew(UDC_CLR_EP, UDC_CTRL);\r\nomap_writew(UDC_SET_FIFO_EN, UDC_CTRL);\r\nomap_writew(UDC_EP_DIR, UDC_EP_NUM);\r\nudc->ep0_pending = 0;\r\n}\r\n} else {\r\nomap_writew(0, UDC_EP_NUM);\r\nif (req)\r\ndone(ep0, req, 0);\r\n}\r\n} else if (stat & UDC_STALL) {\r\nomap_writew(UDC_CLR_HALT, UDC_CTRL);\r\nomap_writew(0, UDC_EP_NUM);\r\n} else {\r\nomap_writew(0, UDC_EP_NUM);\r\n}\r\n}\r\nif (irq_src & UDC_SETUP) {\r\nunion u {\r\nu16 word[4];\r\nstruct usb_ctrlrequest r;\r\n} u;\r\nint status = -EINVAL;\r\nstruct omap_ep *ep;\r\ndo {\r\nomap_writew(UDC_SETUP_SEL, UDC_EP_NUM);\r\nu.word[0] = omap_readw(UDC_DATA);\r\nu.word[1] = omap_readw(UDC_DATA);\r\nu.word[2] = omap_readw(UDC_DATA);\r\nu.word[3] = omap_readw(UDC_DATA);\r\nomap_writew(0, UDC_EP_NUM);\r\n} while (omap_readw(UDC_IRQ_SRC) & UDC_SETUP);\r\n#define w_value le16_to_cpu(u.r.wValue)\r\n#define w_index le16_to_cpu(u.r.wIndex)\r\n#define w_length le16_to_cpu(u.r.wLength)\r\nudc->ep0_in = (u.r.bRequestType & USB_DIR_IN) != 0;\r\nudc->ep0_set_config = 0;\r\nudc->ep0_pending = 1;\r\nep0->stopped = 0;\r\nep0->ackwait = 0;\r\nswitch (u.r.bRequest) {\r\ncase USB_REQ_SET_CONFIGURATION:\r\nif (u.r.bRequestType != USB_RECIP_DEVICE)\r\ngoto delegate;\r\nif (w_length != 0)\r\ngoto do_stall;\r\nudc->ep0_set_config = 1;\r\nudc->ep0_reset_config = (w_value == 0);\r\nVDBG("set config %d\n", w_value);\r\nif (udc->ep0_reset_config)\r\nomap_writew(UDC_CLR_CFG, UDC_SYSCON2);\r\nelse\r\nomap_writew(UDC_DEV_CFG, UDC_SYSCON2);\r\nupdate_otg(udc);\r\ngoto delegate;\r\ncase USB_REQ_CLEAR_FEATURE:\r\nif (u.r.bRequestType != USB_RECIP_ENDPOINT)\r\ngoto delegate;\r\nif (w_value != USB_ENDPOINT_HALT\r\n|| w_length != 0)\r\ngoto do_stall;\r\nep = &udc->ep[w_index & 0xf];\r\nif (ep != ep0) {\r\nif (w_index & USB_DIR_IN)\r\nep += 16;\r\nif (ep->bmAttributes == USB_ENDPOINT_XFER_ISOC\r\n|| !ep->ep.desc)\r\ngoto do_stall;\r\nuse_ep(ep, 0);\r\nomap_writew(udc->clr_halt, UDC_CTRL);\r\nep->ackwait = 0;\r\nif (!(ep->bEndpointAddress & USB_DIR_IN)) {\r\nomap_writew(UDC_SET_FIFO_EN, UDC_CTRL);\r\nep->ackwait = 1 + ep->double_buf;\r\n}\r\n}\r\nVDBG("%s halt cleared by host\n", ep->name);\r\ngoto ep0out_status_stage;\r\ncase USB_REQ_SET_FEATURE:\r\nif (u.r.bRequestType != USB_RECIP_ENDPOINT)\r\ngoto delegate;\r\nif (w_value != USB_ENDPOINT_HALT\r\n|| w_length != 0)\r\ngoto do_stall;\r\nep = &udc->ep[w_index & 0xf];\r\nif (w_index & USB_DIR_IN)\r\nep += 16;\r\nif (ep->bmAttributes == USB_ENDPOINT_XFER_ISOC\r\n|| ep == ep0 || !ep->ep.desc)\r\ngoto do_stall;\r\nif (use_dma && ep->has_dma) {\r\nDBG("%s host set_halt, NYET\n", ep->name);\r\ngoto do_stall;\r\n}\r\nuse_ep(ep, 0);\r\nomap_writew(UDC_CLR_EP, UDC_CTRL);\r\nomap_writew(UDC_SET_HALT, UDC_CTRL);\r\nVDBG("%s halted by host\n", ep->name);\r\nep0out_status_stage:\r\nstatus = 0;\r\nomap_writew(UDC_EP_SEL|UDC_EP_DIR, UDC_EP_NUM);\r\nomap_writew(UDC_CLR_EP, UDC_CTRL);\r\nomap_writew(UDC_SET_FIFO_EN, UDC_CTRL);\r\nomap_writew(UDC_EP_DIR, UDC_EP_NUM);\r\nudc->ep0_pending = 0;\r\nbreak;\r\ncase USB_REQ_GET_STATUS:\r\nif (u.r.bRequestType != (USB_DIR_IN|USB_RECIP_ENDPOINT))\r\ngoto intf_status;\r\nif (!(w_index & 0xf))\r\ngoto zero_status;\r\nep = &udc->ep[w_index & 0xf];\r\nif (w_index & USB_DIR_IN)\r\nep += 16;\r\nif (!ep->ep.desc)\r\ngoto do_stall;\r\nif (ep->bmAttributes == USB_ENDPOINT_XFER_ISOC)\r\ngoto zero_status;\r\nERR("%s status, can't report\n", ep->ep.name);\r\ngoto do_stall;\r\nintf_status:\r\nif (u.r.bRequestType\r\n!= (USB_DIR_IN|USB_RECIP_INTERFACE))\r\ngoto delegate;\r\nzero_status:\r\nomap_writew(UDC_EP_SEL|UDC_EP_DIR, UDC_EP_NUM);\r\nomap_writew(0, UDC_DATA);\r\nomap_writew(UDC_SET_FIFO_EN, UDC_CTRL);\r\nomap_writew(UDC_EP_DIR, UDC_EP_NUM);\r\nstatus = 0;\r\nVDBG("GET_STATUS, interface %d\n", w_index);\r\nbreak;\r\ndefault:\r\ndelegate:\r\nif (!udc->ep0_in && w_length) {\r\nomap_writew(0, UDC_EP_NUM);\r\nomap_writew(UDC_SET_FIFO_EN, UDC_CTRL);\r\n}\r\nVDBG("SETUP %02x.%02x v%04x i%04x l%04x\n",\r\nu.r.bRequestType, u.r.bRequest,\r\nw_value, w_index, w_length);\r\n#undef w_value\r\n#undef w_index\r\n#undef w_length\r\nudc->ep0_setup = 1;\r\nspin_unlock(&udc->lock);\r\nstatus = udc->driver->setup(&udc->gadget, &u.r);\r\nspin_lock(&udc->lock);\r\nudc->ep0_setup = 0;\r\n}\r\nif (status < 0) {\r\ndo_stall:\r\nVDBG("req %02x.%02x protocol STALL; stat %d\n",\r\nu.r.bRequestType, u.r.bRequest, status);\r\nif (udc->ep0_set_config) {\r\nif (udc->ep0_reset_config)\r\nWARNING("error resetting config?\n");\r\nelse\r\nomap_writew(UDC_CLR_CFG, UDC_SYSCON2);\r\n}\r\nomap_writew(UDC_STALL_CMD, UDC_SYSCON2);\r\nudc->ep0_pending = 0;\r\n}\r\n}\r\n}\r\nstatic void devstate_irq(struct omap_udc *udc, u16 irq_src)\r\n{\r\nu16 devstat, change;\r\ndevstat = omap_readw(UDC_DEVSTAT);\r\nchange = devstat ^ udc->devstat;\r\nudc->devstat = devstat;\r\nif (change & (UDC_USB_RESET|UDC_ATT)) {\r\nudc_quiesce(udc);\r\nif (change & UDC_ATT) {\r\nif (devstat & UDC_ATT) {\r\nudc->gadget.speed = USB_SPEED_FULL;\r\nVDBG("connect\n");\r\nif (IS_ERR_OR_NULL(udc->transceiver))\r\npullup_enable(udc);\r\n} else if (udc->gadget.speed != USB_SPEED_UNKNOWN) {\r\nudc->gadget.speed = USB_SPEED_UNKNOWN;\r\nif (IS_ERR_OR_NULL(udc->transceiver))\r\npullup_disable(udc);\r\nDBG("disconnect, gadget %s\n",\r\nudc->driver->driver.name);\r\nif (udc->driver->disconnect) {\r\nspin_unlock(&udc->lock);\r\nudc->driver->disconnect(&udc->gadget);\r\nspin_lock(&udc->lock);\r\n}\r\n}\r\nchange &= ~UDC_ATT;\r\n}\r\nif (change & UDC_USB_RESET) {\r\nif (devstat & UDC_USB_RESET) {\r\nVDBG("RESET=1\n");\r\n} else {\r\nudc->gadget.speed = USB_SPEED_FULL;\r\nINFO("USB reset done, gadget %s\n",\r\nudc->driver->driver.name);\r\nomap_writew(UDC_DS_CHG_IE | UDC_EP0_IE,\r\nUDC_IRQ_EN);\r\n}\r\nchange &= ~UDC_USB_RESET;\r\n}\r\n}\r\nif (change & UDC_SUS) {\r\nif (udc->gadget.speed != USB_SPEED_UNKNOWN) {\r\nif (devstat & UDC_SUS) {\r\nVDBG("suspend\n");\r\nupdate_otg(udc);\r\nif (udc->gadget.speed == USB_SPEED_FULL\r\n&& udc->driver->suspend) {\r\nspin_unlock(&udc->lock);\r\nudc->driver->suspend(&udc->gadget);\r\nspin_lock(&udc->lock);\r\n}\r\nif (!IS_ERR_OR_NULL(udc->transceiver))\r\nusb_phy_set_suspend(\r\nudc->transceiver, 1);\r\n} else {\r\nVDBG("resume\n");\r\nif (!IS_ERR_OR_NULL(udc->transceiver))\r\nusb_phy_set_suspend(\r\nudc->transceiver, 0);\r\nif (udc->gadget.speed == USB_SPEED_FULL\r\n&& udc->driver->resume) {\r\nspin_unlock(&udc->lock);\r\nudc->driver->resume(&udc->gadget);\r\nspin_lock(&udc->lock);\r\n}\r\n}\r\n}\r\nchange &= ~UDC_SUS;\r\n}\r\nif (!cpu_is_omap15xx() && (change & OTG_FLAGS)) {\r\nupdate_otg(udc);\r\nchange &= ~OTG_FLAGS;\r\n}\r\nchange &= ~(UDC_CFG|UDC_DEF|UDC_ADD);\r\nif (change)\r\nVDBG("devstat %03x, ignore change %03x\n",\r\ndevstat, change);\r\nomap_writew(UDC_DS_CHG, UDC_IRQ_SRC);\r\n}\r\nstatic irqreturn_t omap_udc_irq(int irq, void *_udc)\r\n{\r\nstruct omap_udc *udc = _udc;\r\nu16 irq_src;\r\nirqreturn_t status = IRQ_NONE;\r\nunsigned long flags;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nirq_src = omap_readw(UDC_IRQ_SRC);\r\nif (irq_src & UDC_DS_CHG) {\r\ndevstate_irq(_udc, irq_src);\r\nstatus = IRQ_HANDLED;\r\nirq_src &= ~UDC_DS_CHG;\r\n}\r\nif (irq_src & (UDC_EP0_RX|UDC_SETUP|UDC_EP0_TX)) {\r\nep0_irq(_udc, irq_src);\r\nstatus = IRQ_HANDLED;\r\nirq_src &= ~(UDC_EP0_RX|UDC_SETUP|UDC_EP0_TX);\r\n}\r\nif (use_dma && (irq_src & (UDC_TXN_DONE|UDC_RXN_CNT|UDC_RXN_EOT))) {\r\ndma_irq(_udc, irq_src);\r\nstatus = IRQ_HANDLED;\r\nirq_src &= ~(UDC_TXN_DONE|UDC_RXN_CNT|UDC_RXN_EOT);\r\n}\r\nirq_src &= ~(UDC_IRQ_SOF | UDC_EPN_TX|UDC_EPN_RX);\r\nif (irq_src)\r\nDBG("udc_irq, unhandled %03x\n", irq_src);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn status;\r\n}\r\nstatic void pio_out_timer(unsigned long _ep)\r\n{\r\nstruct omap_ep *ep = (void *) _ep;\r\nunsigned long flags;\r\nu16 stat_flg;\r\nspin_lock_irqsave(&ep->udc->lock, flags);\r\nif (!list_empty(&ep->queue) && ep->ackwait) {\r\nuse_ep(ep, UDC_EP_SEL);\r\nstat_flg = omap_readw(UDC_STAT_FLG);\r\nif ((stat_flg & UDC_ACK) && (!(stat_flg & UDC_FIFO_EN)\r\n|| (ep->double_buf && HALF_FULL(stat_flg)))) {\r\nstruct omap_req *req;\r\nVDBG("%s: lose, %04x\n", ep->ep.name, stat_flg);\r\nreq = container_of(ep->queue.next,\r\nstruct omap_req, queue);\r\n(void) read_fifo(ep, req);\r\nomap_writew(ep->bEndpointAddress, UDC_EP_NUM);\r\nomap_writew(UDC_SET_FIFO_EN, UDC_CTRL);\r\nep->ackwait = 1 + ep->double_buf;\r\n} else\r\ndeselect_ep();\r\n}\r\nmod_timer(&ep->timer, PIO_OUT_TIMEOUT);\r\nspin_unlock_irqrestore(&ep->udc->lock, flags);\r\n}\r\nstatic irqreturn_t omap_udc_pio_irq(int irq, void *_dev)\r\n{\r\nu16 epn_stat, irq_src;\r\nirqreturn_t status = IRQ_NONE;\r\nstruct omap_ep *ep;\r\nint epnum;\r\nstruct omap_udc *udc = _dev;\r\nstruct omap_req *req;\r\nunsigned long flags;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nepn_stat = omap_readw(UDC_EPN_STAT);\r\nirq_src = omap_readw(UDC_IRQ_SRC);\r\nif (irq_src & UDC_EPN_RX) {\r\nepnum = (epn_stat >> 8) & 0x0f;\r\nomap_writew(UDC_EPN_RX, UDC_IRQ_SRC);\r\nstatus = IRQ_HANDLED;\r\nep = &udc->ep[epnum];\r\nep->irqs++;\r\nomap_writew(epnum | UDC_EP_SEL, UDC_EP_NUM);\r\nep->fnf = 0;\r\nif (omap_readw(UDC_STAT_FLG) & UDC_ACK) {\r\nep->ackwait--;\r\nif (!list_empty(&ep->queue)) {\r\nint stat;\r\nreq = container_of(ep->queue.next,\r\nstruct omap_req, queue);\r\nstat = read_fifo(ep, req);\r\nif (!ep->double_buf)\r\nep->fnf = 1;\r\n}\r\n}\r\nepn_stat = omap_readw(UDC_EPN_STAT);\r\nepn_stat = omap_readw(UDC_EPN_STAT);\r\nomap_writew(epnum, UDC_EP_NUM);\r\nif (ep->fnf) {\r\nomap_writew(UDC_SET_FIFO_EN, UDC_CTRL);\r\nep->ackwait = 1 + ep->double_buf;\r\n}\r\nmod_timer(&ep->timer, PIO_OUT_TIMEOUT);\r\n}\r\nelse if (irq_src & UDC_EPN_TX) {\r\nepnum = epn_stat & 0x0f;\r\nomap_writew(UDC_EPN_TX, UDC_IRQ_SRC);\r\nstatus = IRQ_HANDLED;\r\nep = &udc->ep[16 + epnum];\r\nep->irqs++;\r\nomap_writew(epnum | UDC_EP_DIR | UDC_EP_SEL, UDC_EP_NUM);\r\nif (omap_readw(UDC_STAT_FLG) & UDC_ACK) {\r\nep->ackwait = 0;\r\nif (!list_empty(&ep->queue)) {\r\nreq = container_of(ep->queue.next,\r\nstruct omap_req, queue);\r\n(void) write_fifo(ep, req);\r\n}\r\n}\r\nepn_stat = omap_readw(UDC_EPN_STAT);\r\nepn_stat = omap_readw(UDC_EPN_STAT);\r\nomap_writew(epnum | UDC_EP_DIR, UDC_EP_NUM);\r\n}\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn status;\r\n}\r\nstatic irqreturn_t omap_udc_iso_irq(int irq, void *_dev)\r\n{\r\nstruct omap_udc *udc = _dev;\r\nstruct omap_ep *ep;\r\nint pending = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nlist_for_each_entry(ep, &udc->iso, iso) {\r\nu16 stat;\r\nstruct omap_req *req;\r\nif (ep->has_dma || list_empty(&ep->queue))\r\ncontinue;\r\nreq = list_entry(ep->queue.next, struct omap_req, queue);\r\nuse_ep(ep, UDC_EP_SEL);\r\nstat = omap_readw(UDC_STAT_FLG);\r\nif (ep->bEndpointAddress & USB_DIR_IN) {\r\nif (stat & UDC_MISS_IN)\r\n;\r\nelse\r\nwrite_fifo(ep, req);\r\n} else {\r\nint status = 0;\r\nif (stat & UDC_NO_RXPACKET)\r\nstatus = -EREMOTEIO;\r\nelse if (stat & UDC_ISO_ERR)\r\nstatus = -EILSEQ;\r\nelse if (stat & UDC_DATA_FLUSH)\r\nstatus = -ENOSR;\r\nif (status)\r\n;\r\nelse\r\nread_fifo(ep, req);\r\n}\r\ndeselect_ep();\r\nep->irqs++;\r\nif (!list_empty(&ep->queue))\r\npending = 1;\r\n}\r\nif (!pending) {\r\nu16 w;\r\nw = omap_readw(UDC_IRQ_EN);\r\nw &= ~UDC_SOF_IE;\r\nomap_writew(w, UDC_IRQ_EN);\r\n}\r\nomap_writew(UDC_IRQ_SOF, UDC_IRQ_SRC);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic inline int machine_without_vbus_sense(void)\r\n{\r\nreturn machine_is_omap_innovator()\r\n|| machine_is_omap_osk()\r\n|| machine_is_sx1()\r\n|| cpu_is_omap7xx();\r\n}\r\nstatic int omap_udc_start(struct usb_gadget *g,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nint status = -ENODEV;\r\nstruct omap_ep *ep;\r\nunsigned long flags;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nlist_for_each_entry(ep, &udc->gadget.ep_list, ep.ep_list) {\r\nep->irqs = 0;\r\nif (ep->bmAttributes == USB_ENDPOINT_XFER_ISOC)\r\ncontinue;\r\nuse_ep(ep, 0);\r\nomap_writew(UDC_SET_HALT, UDC_CTRL);\r\n}\r\nudc->ep0_pending = 0;\r\nudc->ep[0].irqs = 0;\r\nudc->softconnect = 1;\r\ndriver->driver.bus = NULL;\r\nudc->driver = driver;\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nif (udc->dc_clk != NULL)\r\nomap_udc_enable_clock(1);\r\nomap_writew(UDC_IRQ_SRC_MASK, UDC_IRQ_SRC);\r\nif (!IS_ERR_OR_NULL(udc->transceiver)) {\r\nstatus = otg_set_peripheral(udc->transceiver->otg,\r\n&udc->gadget);\r\nif (status < 0) {\r\nERR("can't bind to transceiver\n");\r\nudc->driver = NULL;\r\ngoto done;\r\n}\r\n} else {\r\nif (can_pullup(udc))\r\npullup_enable(udc);\r\nelse\r\npullup_disable(udc);\r\n}\r\nif (machine_without_vbus_sense())\r\nomap_vbus_session(&udc->gadget, 1);\r\ndone:\r\nif (udc->dc_clk != NULL)\r\nomap_udc_enable_clock(0);\r\nreturn status;\r\n}\r\nstatic int omap_udc_stop(struct usb_gadget *g)\r\n{\r\nunsigned long flags;\r\nint status = -ENODEV;\r\nif (udc->dc_clk != NULL)\r\nomap_udc_enable_clock(1);\r\nif (machine_without_vbus_sense())\r\nomap_vbus_session(&udc->gadget, 0);\r\nif (!IS_ERR_OR_NULL(udc->transceiver))\r\n(void) otg_set_peripheral(udc->transceiver->otg, NULL);\r\nelse\r\npullup_disable(udc);\r\nspin_lock_irqsave(&udc->lock, flags);\r\nudc_quiesce(udc);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nudc->driver = NULL;\r\nif (udc->dc_clk != NULL)\r\nomap_udc_enable_clock(0);\r\nreturn status;\r\n}\r\nstatic void proc_ep_show(struct seq_file *s, struct omap_ep *ep)\r\n{\r\nu16 stat_flg;\r\nstruct omap_req *req;\r\nchar buf[20];\r\nuse_ep(ep, 0);\r\nif (use_dma && ep->has_dma)\r\nsnprintf(buf, sizeof buf, "(%cxdma%d lch%d) ",\r\n(ep->bEndpointAddress & USB_DIR_IN) ? 't' : 'r',\r\nep->dma_channel - 1, ep->lch);\r\nelse\r\nbuf[0] = 0;\r\nstat_flg = omap_readw(UDC_STAT_FLG);\r\nseq_printf(s,\r\n"\n%s %s%s%sirqs %ld stat %04x " EIGHTBITS FOURBITS "%s\n",\r\nep->name, buf,\r\nep->double_buf ? "dbuf " : "",\r\n({ char *s;\r\nswitch (ep->ackwait) {\r\ncase 0:\r\ns = "";\r\nbreak;\r\ncase 1:\r\ns = "(ackw) ";\r\nbreak;\r\ncase 2:\r\ns = "(ackw2) ";\r\nbreak;\r\ndefault:\r\ns = "(?) ";\r\nbreak;\r\n} s; }),\r\nep->irqs, stat_flg,\r\n(stat_flg & UDC_NO_RXPACKET) ? "no_rxpacket " : "",\r\n(stat_flg & UDC_MISS_IN) ? "miss_in " : "",\r\n(stat_flg & UDC_DATA_FLUSH) ? "data_flush " : "",\r\n(stat_flg & UDC_ISO_ERR) ? "iso_err " : "",\r\n(stat_flg & UDC_ISO_FIFO_EMPTY) ? "iso_fifo_empty " : "",\r\n(stat_flg & UDC_ISO_FIFO_FULL) ? "iso_fifo_full " : "",\r\n(stat_flg & UDC_EP_HALTED) ? "HALT " : "",\r\n(stat_flg & UDC_STALL) ? "STALL " : "",\r\n(stat_flg & UDC_NAK) ? "NAK " : "",\r\n(stat_flg & UDC_ACK) ? "ACK " : "",\r\n(stat_flg & UDC_FIFO_EN) ? "fifo_en " : "",\r\n(stat_flg & UDC_NON_ISO_FIFO_EMPTY) ? "fifo_empty " : "",\r\n(stat_flg & UDC_NON_ISO_FIFO_FULL) ? "fifo_full " : "");\r\nif (list_empty(&ep->queue))\r\nseq_printf(s, "\t(queue empty)\n");\r\nelse\r\nlist_for_each_entry(req, &ep->queue, queue) {\r\nunsigned length = req->req.actual;\r\nif (use_dma && buf[0]) {\r\nlength += ((ep->bEndpointAddress & USB_DIR_IN)\r\n? dma_src_len : dma_dest_len)\r\n(ep, req->req.dma + length);\r\nbuf[0] = 0;\r\n}\r\nseq_printf(s, "\treq %p len %d/%d buf %p\n",\r\n&req->req, length,\r\nreq->req.length, req->req.buf);\r\n}\r\n}\r\nstatic char *trx_mode(unsigned m, int enabled)\r\n{\r\nswitch (m) {\r\ncase 0:\r\nreturn enabled ? "*6wire" : "unused";\r\ncase 1:\r\nreturn "4wire";\r\ncase 2:\r\nreturn "3wire";\r\ncase 3:\r\nreturn "6wire";\r\ndefault:\r\nreturn "unknown";\r\n}\r\n}\r\nstatic int proc_otg_show(struct seq_file *s)\r\n{\r\nu32 tmp;\r\nu32 trans = 0;\r\nchar *ctrl_name = "(UNKNOWN)";\r\ntmp = omap_readl(OTG_REV);\r\nctrl_name = "tranceiver_ctrl";\r\ntrans = omap_readw(USB_TRANSCEIVER_CTRL);\r\nseq_printf(s, "\nOTG rev %d.%d, %s %05x\n",\r\ntmp >> 4, tmp & 0xf, ctrl_name, trans);\r\ntmp = omap_readw(OTG_SYSCON_1);\r\nseq_printf(s, "otg_syscon1 %08x usb2 %s, usb1 %s, usb0 %s,"\r\nFOURBITS "\n", tmp,\r\ntrx_mode(USB2_TRX_MODE(tmp), trans & CONF_USB2_UNI_R),\r\ntrx_mode(USB1_TRX_MODE(tmp), trans & CONF_USB1_UNI_R),\r\n(USB0_TRX_MODE(tmp) == 0 && !cpu_is_omap1710())\r\n? "internal"\r\n: trx_mode(USB0_TRX_MODE(tmp), 1),\r\n(tmp & OTG_IDLE_EN) ? " !otg" : "",\r\n(tmp & HST_IDLE_EN) ? " !host" : "",\r\n(tmp & DEV_IDLE_EN) ? " !dev" : "",\r\n(tmp & OTG_RESET_DONE) ? " reset_done" : " reset_active");\r\ntmp = omap_readl(OTG_SYSCON_2);\r\nseq_printf(s, "otg_syscon2 %08x%s" EIGHTBITS\r\n" b_ase_brst=%d hmc=%d\n", tmp,\r\n(tmp & OTG_EN) ? " otg_en" : "",\r\n(tmp & USBX_SYNCHRO) ? " synchro" : "",\r\n(tmp & SRP_DATA) ? " srp_data" : "",\r\n(tmp & SRP_VBUS) ? " srp_vbus" : "",\r\n(tmp & OTG_PADEN) ? " otg_paden" : "",\r\n(tmp & HMC_PADEN) ? " hmc_paden" : "",\r\n(tmp & UHOST_EN) ? " uhost_en" : "",\r\n(tmp & HMC_TLLSPEED) ? " tllspeed" : "",\r\n(tmp & HMC_TLLATTACH) ? " tllattach" : "",\r\nB_ASE_BRST(tmp),\r\nOTG_HMC(tmp));\r\ntmp = omap_readl(OTG_CTRL);\r\nseq_printf(s, "otg_ctrl %06x" EIGHTBITS EIGHTBITS "%s\n", tmp,\r\n(tmp & OTG_ASESSVLD) ? " asess" : "",\r\n(tmp & OTG_BSESSEND) ? " bsess_end" : "",\r\n(tmp & OTG_BSESSVLD) ? " bsess" : "",\r\n(tmp & OTG_VBUSVLD) ? " vbus" : "",\r\n(tmp & OTG_ID) ? " id" : "",\r\n(tmp & OTG_DRIVER_SEL) ? " DEVICE" : " HOST",\r\n(tmp & OTG_A_SETB_HNPEN) ? " a_setb_hnpen" : "",\r\n(tmp & OTG_A_BUSREQ) ? " a_bus" : "",\r\n(tmp & OTG_B_HNPEN) ? " b_hnpen" : "",\r\n(tmp & OTG_B_BUSREQ) ? " b_bus" : "",\r\n(tmp & OTG_BUSDROP) ? " busdrop" : "",\r\n(tmp & OTG_PULLDOWN) ? " down" : "",\r\n(tmp & OTG_PULLUP) ? " up" : "",\r\n(tmp & OTG_DRV_VBUS) ? " drv" : "",\r\n(tmp & OTG_PD_VBUS) ? " pd_vb" : "",\r\n(tmp & OTG_PU_VBUS) ? " pu_vb" : "",\r\n(tmp & OTG_PU_ID) ? " pu_id" : ""\r\n);\r\ntmp = omap_readw(OTG_IRQ_EN);\r\nseq_printf(s, "otg_irq_en %04x" "\n", tmp);\r\ntmp = omap_readw(OTG_IRQ_SRC);\r\nseq_printf(s, "otg_irq_src %04x" "\n", tmp);\r\ntmp = omap_readw(OTG_OUTCTRL);\r\nseq_printf(s, "otg_outctrl %04x" "\n", tmp);\r\ntmp = omap_readw(OTG_TEST);\r\nseq_printf(s, "otg_test %04x" "\n", tmp);\r\nreturn 0;\r\n}\r\nstatic int proc_udc_show(struct seq_file *s, void *_)\r\n{\r\nu32 tmp;\r\nstruct omap_ep *ep;\r\nunsigned long flags;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nseq_printf(s, "%s, version: " DRIVER_VERSION\r\n#ifdef USE_ISO\r\n" (iso)"\r\n#endif\r\n"%s\n",\r\ndriver_desc,\r\nuse_dma ? " (dma)" : "");\r\ntmp = omap_readw(UDC_REV) & 0xff;\r\nseq_printf(s,\r\n"UDC rev %d.%d, fifo mode %d, gadget %s\n"\r\n"hmc %d, transceiver %s\n",\r\ntmp >> 4, tmp & 0xf,\r\nfifo_mode,\r\nudc->driver ? udc->driver->driver.name : "(none)",\r\nHMC,\r\nudc->transceiver\r\n? udc->transceiver->label\r\n: (cpu_is_omap1710()\r\n? "external" : "(none)"));\r\nseq_printf(s, "ULPD control %04x req %04x status %04x\n",\r\nomap_readw(ULPD_CLOCK_CTRL),\r\nomap_readw(ULPD_SOFT_REQ),\r\nomap_readw(ULPD_STATUS_REQ));\r\nif (!cpu_is_omap15xx())\r\nproc_otg_show(s);\r\ntmp = omap_readw(UDC_SYSCON1);\r\nseq_printf(s, "\nsyscon1 %04x" EIGHTBITS "\n", tmp,\r\n(tmp & UDC_CFG_LOCK) ? " cfg_lock" : "",\r\n(tmp & UDC_DATA_ENDIAN) ? " data_endian" : "",\r\n(tmp & UDC_DMA_ENDIAN) ? " dma_endian" : "",\r\n(tmp & UDC_NAK_EN) ? " nak" : "",\r\n(tmp & UDC_AUTODECODE_DIS) ? " autodecode_dis" : "",\r\n(tmp & UDC_SELF_PWR) ? " self_pwr" : "",\r\n(tmp & UDC_SOFF_DIS) ? " soff_dis" : "",\r\n(tmp & UDC_PULLUP_EN) ? " PULLUP" : "");\r\nif (!(tmp & UDC_PULLUP_EN)) {\r\nseq_printf(s, "(suspended)\n");\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\ntmp = omap_readw(UDC_DEVSTAT);\r\nseq_printf(s, "devstat %04x" EIGHTBITS "%s%s\n", tmp,\r\n(tmp & UDC_B_HNP_ENABLE) ? " b_hnp" : "",\r\n(tmp & UDC_A_HNP_SUPPORT) ? " a_hnp" : "",\r\n(tmp & UDC_A_ALT_HNP_SUPPORT) ? " a_alt_hnp" : "",\r\n(tmp & UDC_R_WK_OK) ? " r_wk_ok" : "",\r\n(tmp & UDC_USB_RESET) ? " usb_reset" : "",\r\n(tmp & UDC_SUS) ? " SUS" : "",\r\n(tmp & UDC_CFG) ? " CFG" : "",\r\n(tmp & UDC_ADD) ? " ADD" : "",\r\n(tmp & UDC_DEF) ? " DEF" : "",\r\n(tmp & UDC_ATT) ? " ATT" : "");\r\nseq_printf(s, "sof %04x\n", omap_readw(UDC_SOF));\r\ntmp = omap_readw(UDC_IRQ_EN);\r\nseq_printf(s, "irq_en %04x" FOURBITS "%s\n", tmp,\r\n(tmp & UDC_SOF_IE) ? " sof" : "",\r\n(tmp & UDC_EPN_RX_IE) ? " epn_rx" : "",\r\n(tmp & UDC_EPN_TX_IE) ? " epn_tx" : "",\r\n(tmp & UDC_DS_CHG_IE) ? " ds_chg" : "",\r\n(tmp & UDC_EP0_IE) ? " ep0" : "");\r\ntmp = omap_readw(UDC_IRQ_SRC);\r\nseq_printf(s, "irq_src %04x" EIGHTBITS "%s%s\n", tmp,\r\n(tmp & UDC_TXN_DONE) ? " txn_done" : "",\r\n(tmp & UDC_RXN_CNT) ? " rxn_cnt" : "",\r\n(tmp & UDC_RXN_EOT) ? " rxn_eot" : "",\r\n(tmp & UDC_IRQ_SOF) ? " sof" : "",\r\n(tmp & UDC_EPN_RX) ? " epn_rx" : "",\r\n(tmp & UDC_EPN_TX) ? " epn_tx" : "",\r\n(tmp & UDC_DS_CHG) ? " ds_chg" : "",\r\n(tmp & UDC_SETUP) ? " setup" : "",\r\n(tmp & UDC_EP0_RX) ? " ep0out" : "",\r\n(tmp & UDC_EP0_TX) ? " ep0in" : "");\r\nif (use_dma) {\r\nunsigned i;\r\ntmp = omap_readw(UDC_DMA_IRQ_EN);\r\nseq_printf(s, "dma_irq_en %04x%s" EIGHTBITS "\n", tmp,\r\n(tmp & UDC_TX_DONE_IE(3)) ? " tx2_done" : "",\r\n(tmp & UDC_RX_CNT_IE(3)) ? " rx2_cnt" : "",\r\n(tmp & UDC_RX_EOT_IE(3)) ? " rx2_eot" : "",\r\n(tmp & UDC_TX_DONE_IE(2)) ? " tx1_done" : "",\r\n(tmp & UDC_RX_CNT_IE(2)) ? " rx1_cnt" : "",\r\n(tmp & UDC_RX_EOT_IE(2)) ? " rx1_eot" : "",\r\n(tmp & UDC_TX_DONE_IE(1)) ? " tx0_done" : "",\r\n(tmp & UDC_RX_CNT_IE(1)) ? " rx0_cnt" : "",\r\n(tmp & UDC_RX_EOT_IE(1)) ? " rx0_eot" : "");\r\ntmp = omap_readw(UDC_RXDMA_CFG);\r\nseq_printf(s, "rxdma_cfg %04x\n", tmp);\r\nif (tmp) {\r\nfor (i = 0; i < 3; i++) {\r\nif ((tmp & (0x0f << (i * 4))) == 0)\r\ncontinue;\r\nseq_printf(s, "rxdma[%d] %04x\n", i,\r\nomap_readw(UDC_RXDMA(i + 1)));\r\n}\r\n}\r\ntmp = omap_readw(UDC_TXDMA_CFG);\r\nseq_printf(s, "txdma_cfg %04x\n", tmp);\r\nif (tmp) {\r\nfor (i = 0; i < 3; i++) {\r\nif (!(tmp & (0x0f << (i * 4))))\r\ncontinue;\r\nseq_printf(s, "txdma[%d] %04x\n", i,\r\nomap_readw(UDC_TXDMA(i + 1)));\r\n}\r\n}\r\n}\r\ntmp = omap_readw(UDC_DEVSTAT);\r\nif (tmp & UDC_ATT) {\r\nproc_ep_show(s, &udc->ep[0]);\r\nif (tmp & UDC_ADD) {\r\nlist_for_each_entry(ep, &udc->gadget.ep_list,\r\nep.ep_list) {\r\nif (ep->ep.desc)\r\nproc_ep_show(s, ep);\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int proc_udc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, proc_udc_show, NULL);\r\n}\r\nstatic void create_proc_file(void)\r\n{\r\nproc_create(proc_filename, 0, NULL, &proc_ops);\r\n}\r\nstatic void remove_proc_file(void)\r\n{\r\nremove_proc_entry(proc_filename, NULL);\r\n}\r\nstatic inline void create_proc_file(void) {}\r\nstatic inline void remove_proc_file(void) {}\r\nstatic unsigned\r\nomap_ep_setup(char *name, u8 addr, u8 type,\r\nunsigned buf, unsigned maxp, int dbuf)\r\n{\r\nstruct omap_ep *ep;\r\nu16 epn_rxtx = 0;\r\nep = &udc->ep[addr & 0xf];\r\nif (addr & USB_DIR_IN)\r\nep += 16;\r\nBUG_ON(ep->name[0]);\r\nif (type == USB_ENDPOINT_XFER_ISOC) {\r\nswitch (maxp) {\r\ncase 8:\r\nepn_rxtx = 0 << 12;\r\nbreak;\r\ncase 16:\r\nepn_rxtx = 1 << 12;\r\nbreak;\r\ncase 32:\r\nepn_rxtx = 2 << 12;\r\nbreak;\r\ncase 64:\r\nepn_rxtx = 3 << 12;\r\nbreak;\r\ncase 128:\r\nepn_rxtx = 4 << 12;\r\nbreak;\r\ncase 256:\r\nepn_rxtx = 5 << 12;\r\nbreak;\r\ncase 512:\r\nepn_rxtx = 6 << 12;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nepn_rxtx |= UDC_EPN_RX_ISO;\r\ndbuf = 1;\r\n} else {\r\nif (!use_dma || cpu_is_omap15xx())\r\ndbuf = 0;\r\nswitch (maxp) {\r\ncase 8:\r\nepn_rxtx = 0 << 12;\r\nbreak;\r\ncase 16:\r\nepn_rxtx = 1 << 12;\r\nbreak;\r\ncase 32:\r\nepn_rxtx = 2 << 12;\r\nbreak;\r\ncase 64:\r\nepn_rxtx = 3 << 12;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nif (dbuf && addr)\r\nepn_rxtx |= UDC_EPN_RX_DB;\r\ninit_timer(&ep->timer);\r\nep->timer.function = pio_out_timer;\r\nep->timer.data = (unsigned long) ep;\r\n}\r\nif (addr)\r\nepn_rxtx |= UDC_EPN_RX_VALID;\r\nBUG_ON(buf & 0x07);\r\nepn_rxtx |= buf >> 3;\r\nDBG("%s addr %02x rxtx %04x maxp %d%s buf %d\n",\r\nname, addr, epn_rxtx, maxp, dbuf ? "x2" : "", buf);\r\nif (addr & USB_DIR_IN)\r\nomap_writew(epn_rxtx, UDC_EP_TX(addr & 0xf));\r\nelse\r\nomap_writew(epn_rxtx, UDC_EP_RX(addr));\r\nbuf += maxp;\r\nif (dbuf)\r\nbuf += maxp;\r\nBUG_ON(buf > 2048);\r\nBUG_ON(strlen(name) >= sizeof ep->name);\r\nstrlcpy(ep->name, name, sizeof ep->name);\r\nINIT_LIST_HEAD(&ep->queue);\r\nINIT_LIST_HEAD(&ep->iso);\r\nep->bEndpointAddress = addr;\r\nep->bmAttributes = type;\r\nep->double_buf = dbuf;\r\nep->udc = udc;\r\nep->ep.name = ep->name;\r\nep->ep.ops = &omap_ep_ops;\r\nep->maxpacket = maxp;\r\nusb_ep_set_maxpacket_limit(&ep->ep, ep->maxpacket);\r\nlist_add_tail(&ep->ep.ep_list, &udc->gadget.ep_list);\r\nreturn buf;\r\n}\r\nstatic void omap_udc_release(struct device *dev)\r\n{\r\ncomplete(udc->done);\r\nkfree(udc);\r\nudc = NULL;\r\n}\r\nstatic int\r\nomap_udc_setup(struct platform_device *odev, struct usb_phy *xceiv)\r\n{\r\nunsigned tmp, buf;\r\nomap_writew(0, UDC_SYSCON1);\r\nomap_writew(0, UDC_IRQ_EN);\r\nomap_writew(UDC_IRQ_SRC_MASK, UDC_IRQ_SRC);\r\nomap_writew(0, UDC_DMA_IRQ_EN);\r\nomap_writew(0, UDC_RXDMA_CFG);\r\nomap_writew(0, UDC_TXDMA_CFG);\r\nudc = kzalloc(sizeof(*udc), GFP_KERNEL);\r\nif (!udc)\r\nreturn -ENOMEM;\r\nspin_lock_init(&udc->lock);\r\nudc->gadget.ops = &omap_gadget_ops;\r\nudc->gadget.ep0 = &udc->ep[0].ep;\r\nINIT_LIST_HEAD(&udc->gadget.ep_list);\r\nINIT_LIST_HEAD(&udc->iso);\r\nudc->gadget.speed = USB_SPEED_UNKNOWN;\r\nudc->gadget.max_speed = USB_SPEED_FULL;\r\nudc->gadget.name = driver_name;\r\nudc->transceiver = xceiv;\r\nbuf = omap_ep_setup("ep0", 0, USB_ENDPOINT_XFER_CONTROL,\r\n8 , 64 , 0);\r\nlist_del_init(&udc->ep[0].ep.ep_list);\r\nfor (tmp = 1; tmp < 15; tmp++) {\r\nomap_writew(0, UDC_EP_RX(tmp));\r\nomap_writew(0, UDC_EP_TX(tmp));\r\n}\r\n#define OMAP_BULK_EP(name, addr) \\r\nbuf = omap_ep_setup(name "-bulk", addr, \\r\nUSB_ENDPOINT_XFER_BULK, buf, 64, 1);\r\n#define OMAP_INT_EP(name, addr, maxp) \\r\nbuf = omap_ep_setup(name "-int", addr, \\r\nUSB_ENDPOINT_XFER_INT, buf, maxp, 0);\r\n#define OMAP_ISO_EP(name, addr, maxp) \\r\nbuf = omap_ep_setup(name "-iso", addr, \\r\nUSB_ENDPOINT_XFER_ISOC, buf, maxp, 1);\r\nswitch (fifo_mode) {\r\ncase 0:\r\nOMAP_BULK_EP("ep1in", USB_DIR_IN | 1);\r\nOMAP_BULK_EP("ep2out", USB_DIR_OUT | 2);\r\nOMAP_INT_EP("ep3in", USB_DIR_IN | 3, 16);\r\nbreak;\r\ncase 1:\r\nOMAP_BULK_EP("ep1in", USB_DIR_IN | 1);\r\nOMAP_BULK_EP("ep2out", USB_DIR_OUT | 2);\r\nOMAP_INT_EP("ep9in", USB_DIR_IN | 9, 16);\r\nOMAP_BULK_EP("ep3in", USB_DIR_IN | 3);\r\nOMAP_BULK_EP("ep4out", USB_DIR_OUT | 4);\r\nOMAP_INT_EP("ep10in", USB_DIR_IN | 10, 16);\r\nOMAP_BULK_EP("ep5in", USB_DIR_IN | 5);\r\nOMAP_BULK_EP("ep5out", USB_DIR_OUT | 5);\r\nOMAP_INT_EP("ep11in", USB_DIR_IN | 11, 16);\r\nOMAP_BULK_EP("ep6in", USB_DIR_IN | 6);\r\nOMAP_BULK_EP("ep6out", USB_DIR_OUT | 6);\r\nOMAP_INT_EP("ep12in", USB_DIR_IN | 12, 16);\r\nOMAP_BULK_EP("ep7in", USB_DIR_IN | 7);\r\nOMAP_BULK_EP("ep7out", USB_DIR_OUT | 7);\r\nOMAP_INT_EP("ep13in", USB_DIR_IN | 13, 16);\r\nOMAP_INT_EP("ep13out", USB_DIR_OUT | 13, 16);\r\nOMAP_BULK_EP("ep8in", USB_DIR_IN | 8);\r\nOMAP_BULK_EP("ep8out", USB_DIR_OUT | 8);\r\nOMAP_INT_EP("ep14in", USB_DIR_IN | 14, 16);\r\nOMAP_INT_EP("ep14out", USB_DIR_OUT | 14, 16);\r\nOMAP_BULK_EP("ep15in", USB_DIR_IN | 15);\r\nOMAP_BULK_EP("ep15out", USB_DIR_OUT | 15);\r\nbreak;\r\n#ifdef USE_ISO\r\ncase 2:\r\nOMAP_ISO_EP("ep1in", USB_DIR_IN | 1, 256);\r\nOMAP_ISO_EP("ep2out", USB_DIR_OUT | 2, 256);\r\nOMAP_ISO_EP("ep3in", USB_DIR_IN | 3, 128);\r\nOMAP_ISO_EP("ep4out", USB_DIR_OUT | 4, 128);\r\nOMAP_INT_EP("ep5in", USB_DIR_IN | 5, 16);\r\nOMAP_BULK_EP("ep6in", USB_DIR_IN | 6);\r\nOMAP_BULK_EP("ep7out", USB_DIR_OUT | 7);\r\nOMAP_INT_EP("ep8in", USB_DIR_IN | 8, 16);\r\nbreak;\r\ncase 3:\r\nOMAP_BULK_EP("ep1in", USB_DIR_IN | 1);\r\nOMAP_BULK_EP("ep2out", USB_DIR_OUT | 2);\r\nOMAP_INT_EP("ep3in", USB_DIR_IN | 3, 16);\r\nOMAP_BULK_EP("ep4in", USB_DIR_IN | 4);\r\nOMAP_BULK_EP("ep5out", USB_DIR_OUT | 5);\r\nOMAP_INT_EP("ep6in", USB_DIR_IN | 6, 16);\r\nOMAP_ISO_EP("ep7in", USB_DIR_IN | 7, 256);\r\nOMAP_ISO_EP("ep8out", USB_DIR_OUT | 8, 256);\r\nOMAP_INT_EP("ep9in", USB_DIR_IN | 9, 16);\r\nbreak;\r\n#endif\r\ndefault:\r\nERR("unsupported fifo_mode #%d\n", fifo_mode);\r\nreturn -ENODEV;\r\n}\r\nomap_writew(UDC_CFG_LOCK|UDC_SELF_PWR, UDC_SYSCON1);\r\nINFO("fifo mode %d, %d bytes not used\n", fifo_mode, 2048 - buf);\r\nreturn 0;\r\n}\r\nstatic int omap_udc_probe(struct platform_device *pdev)\r\n{\r\nint status = -ENODEV;\r\nint hmc;\r\nstruct usb_phy *xceiv = NULL;\r\nconst char *type = NULL;\r\nstruct omap_usb_config *config = dev_get_platdata(&pdev->dev);\r\nstruct clk *dc_clk = NULL;\r\nstruct clk *hhc_clk = NULL;\r\nif (cpu_is_omap7xx())\r\nuse_dma = 0;\r\nif (!request_mem_region(pdev->resource[0].start,\r\npdev->resource[0].end - pdev->resource[0].start + 1,\r\ndriver_name)) {\r\nDBG("request_mem_region failed\n");\r\nreturn -EBUSY;\r\n}\r\nif (cpu_is_omap16xx()) {\r\ndc_clk = clk_get(&pdev->dev, "usb_dc_ck");\r\nhhc_clk = clk_get(&pdev->dev, "usb_hhc_ck");\r\nBUG_ON(IS_ERR(dc_clk) || IS_ERR(hhc_clk));\r\nclk_enable(dc_clk);\r\nclk_enable(hhc_clk);\r\nudelay(100);\r\n}\r\nif (cpu_is_omap7xx()) {\r\ndc_clk = clk_get(&pdev->dev, "usb_dc_ck");\r\nhhc_clk = clk_get(&pdev->dev, "l3_ocpi_ck");\r\nBUG_ON(IS_ERR(dc_clk) || IS_ERR(hhc_clk));\r\nclk_enable(dc_clk);\r\nclk_enable(hhc_clk);\r\nudelay(100);\r\n}\r\nINFO("OMAP UDC rev %d.%d%s\n",\r\nomap_readw(UDC_REV) >> 4, omap_readw(UDC_REV) & 0xf,\r\nconfig->otg ? ", Mini-AB" : "");\r\nif (cpu_is_omap15xx()) {\r\nhmc = HMC_1510;\r\ntype = "(unknown)";\r\nif (machine_without_vbus_sense()) {\r\nu32 tmp = omap_readl(FUNC_MUX_CTRL_0);\r\ntmp &= ~VBUS_CTRL_1510;\r\nomap_writel(tmp, FUNC_MUX_CTRL_0);\r\ntmp |= VBUS_MODE_1510;\r\ntmp &= ~VBUS_CTRL_1510;\r\nomap_writel(tmp, FUNC_MUX_CTRL_0);\r\n}\r\n} else {\r\nxceiv = usb_get_phy(USB_PHY_TYPE_USB2);\r\nif (!IS_ERR_OR_NULL(xceiv))\r\ntype = xceiv->label;\r\nelse if (config->otg) {\r\nDBG("OTG requires external transceiver!\n");\r\ngoto cleanup0;\r\n}\r\nhmc = HMC_1610;\r\nswitch (hmc) {\r\ncase 0:\r\ncase 4:\r\ncase 12:\r\ncase 20:\r\nif (!cpu_is_omap1710()) {\r\ntype = "integrated";\r\nbreak;\r\n}\r\ncase 3:\r\ncase 11:\r\ncase 16:\r\ncase 19:\r\ncase 25:\r\nif (IS_ERR_OR_NULL(xceiv)) {\r\nDBG("external transceiver not registered!\n");\r\ntype = "unknown";\r\n}\r\nbreak;\r\ncase 21:\r\ntype = "loopback";\r\nbreak;\r\ncase 14:\r\nif (cpu_is_omap1710())\r\ngoto bad_on_1710;\r\ncase 13:\r\ncase 15:\r\ntype = "no";\r\nbreak;\r\ndefault:\r\nbad_on_1710:\r\nERR("unrecognized UDC HMC mode %d\n", hmc);\r\ngoto cleanup0;\r\n}\r\n}\r\nINFO("hmc mode %d, %s transceiver\n", hmc, type);\r\nstatus = omap_udc_setup(pdev, xceiv);\r\nif (status)\r\ngoto cleanup0;\r\nxceiv = NULL;\r\npullup_disable(udc);\r\n#if defined(CONFIG_USB_OHCI_HCD) || defined(CONFIG_USB_OHCI_HCD_MODULE)\r\nudc->gadget.is_otg = (config->otg != 0);\r\n#endif\r\nif (omap_readw(UDC_REV) >= 0x61)\r\nudc->clr_halt = UDC_RESET_EP | UDC_CLRDATA_TOGGLE;\r\nelse\r\nudc->clr_halt = UDC_RESET_EP;\r\nstatus = request_irq(pdev->resource[1].start, omap_udc_irq,\r\n0, driver_name, udc);\r\nif (status != 0) {\r\nERR("can't get irq %d, err %d\n",\r\n(int) pdev->resource[1].start, status);\r\ngoto cleanup1;\r\n}\r\nstatus = request_irq(pdev->resource[2].start, omap_udc_pio_irq,\r\n0, "omap_udc pio", udc);\r\nif (status != 0) {\r\nERR("can't get irq %d, err %d\n",\r\n(int) pdev->resource[2].start, status);\r\ngoto cleanup2;\r\n}\r\n#ifdef USE_ISO\r\nstatus = request_irq(pdev->resource[3].start, omap_udc_iso_irq,\r\n0, "omap_udc iso", udc);\r\nif (status != 0) {\r\nERR("can't get irq %d, err %d\n",\r\n(int) pdev->resource[3].start, status);\r\ngoto cleanup3;\r\n}\r\n#endif\r\nif (cpu_is_omap16xx() || cpu_is_omap7xx()) {\r\nudc->dc_clk = dc_clk;\r\nudc->hhc_clk = hhc_clk;\r\nclk_disable(hhc_clk);\r\nclk_disable(dc_clk);\r\n}\r\ncreate_proc_file();\r\nstatus = usb_add_gadget_udc_release(&pdev->dev, &udc->gadget,\r\nomap_udc_release);\r\nif (status)\r\ngoto cleanup4;\r\nreturn 0;\r\ncleanup4:\r\nremove_proc_file();\r\n#ifdef USE_ISO\r\ncleanup3:\r\nfree_irq(pdev->resource[2].start, udc);\r\n#endif\r\ncleanup2:\r\nfree_irq(pdev->resource[1].start, udc);\r\ncleanup1:\r\nkfree(udc);\r\nudc = NULL;\r\ncleanup0:\r\nif (!IS_ERR_OR_NULL(xceiv))\r\nusb_put_phy(xceiv);\r\nif (cpu_is_omap16xx() || cpu_is_omap7xx()) {\r\nclk_disable(hhc_clk);\r\nclk_disable(dc_clk);\r\nclk_put(hhc_clk);\r\nclk_put(dc_clk);\r\n}\r\nrelease_mem_region(pdev->resource[0].start,\r\npdev->resource[0].end - pdev->resource[0].start + 1);\r\nreturn status;\r\n}\r\nstatic int omap_udc_remove(struct platform_device *pdev)\r\n{\r\nDECLARE_COMPLETION_ONSTACK(done);\r\nif (!udc)\r\nreturn -ENODEV;\r\nusb_del_gadget_udc(&udc->gadget);\r\nif (udc->driver)\r\nreturn -EBUSY;\r\nudc->done = &done;\r\npullup_disable(udc);\r\nif (!IS_ERR_OR_NULL(udc->transceiver)) {\r\nusb_put_phy(udc->transceiver);\r\nudc->transceiver = NULL;\r\n}\r\nomap_writew(0, UDC_SYSCON1);\r\nremove_proc_file();\r\n#ifdef USE_ISO\r\nfree_irq(pdev->resource[3].start, udc);\r\n#endif\r\nfree_irq(pdev->resource[2].start, udc);\r\nfree_irq(pdev->resource[1].start, udc);\r\nif (udc->dc_clk) {\r\nif (udc->clk_requested)\r\nomap_udc_enable_clock(0);\r\nclk_put(udc->hhc_clk);\r\nclk_put(udc->dc_clk);\r\n}\r\nrelease_mem_region(pdev->resource[0].start,\r\npdev->resource[0].end - pdev->resource[0].start + 1);\r\nwait_for_completion(&done);\r\nreturn 0;\r\n}\r\nstatic int omap_udc_suspend(struct platform_device *dev, pm_message_t message)\r\n{\r\nu32 devstat;\r\ndevstat = omap_readw(UDC_DEVSTAT);\r\nif ((devstat & UDC_ATT) != 0 && (devstat & UDC_SUS) == 0) {\r\nWARNING("session active; suspend requires disconnect\n");\r\nomap_pullup(&udc->gadget, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int omap_udc_resume(struct platform_device *dev)\r\n{\r\nDBG("resume + wakeup/SRP\n");\r\nomap_pullup(&udc->gadget, 1);\r\nmsleep(100);\r\nreturn omap_wakeup(&udc->gadget);\r\n}
