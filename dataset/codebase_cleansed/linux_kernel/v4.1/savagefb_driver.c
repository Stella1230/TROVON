static void vgaHWSeqReset(struct savagefb_par *par, int start)\r\n{\r\nif (start)\r\nVGAwSEQ(0x00, 0x01, par);\r\nelse\r\nVGAwSEQ(0x00, 0x03, par);\r\n}\r\nstatic void vgaHWProtect(struct savagefb_par *par, int on)\r\n{\r\nunsigned char tmp;\r\nif (on) {\r\ntmp = VGArSEQ(0x01, par);\r\nvgaHWSeqReset(par, 1);\r\nVGAwSEQ(0x01, tmp | 0x20, par);\r\nVGAenablePalette(par);\r\n} else {\r\ntmp = VGArSEQ(0x01, par);\r\nVGAwSEQ(0x01, tmp & ~0x20, par);\r\nvgaHWSeqReset(par, 0);\r\nVGAdisablePalette(par);\r\n}\r\n}\r\nstatic void vgaHWRestore(struct savagefb_par *par, struct savage_reg *reg)\r\n{\r\nint i;\r\nVGAwMISC(reg->MiscOutReg, par);\r\nfor (i = 1; i < 5; i++)\r\nVGAwSEQ(i, reg->Sequencer[i], par);\r\nVGAwCR(17, reg->CRTC[17] & ~0x80, par);\r\nfor (i = 0; i < 25; i++)\r\nVGAwCR(i, reg->CRTC[i], par);\r\nfor (i = 0; i < 9; i++)\r\nVGAwGR(i, reg->Graphics[i], par);\r\nVGAenablePalette(par);\r\nfor (i = 0; i < 21; i++)\r\nVGAwATTR(i, reg->Attribute[i], par);\r\nVGAdisablePalette(par);\r\n}\r\nstatic void vgaHWInit(struct fb_var_screeninfo *var,\r\nstruct savagefb_par *par,\r\nstruct xtimings *timings,\r\nstruct savage_reg *reg)\r\n{\r\nreg->MiscOutReg = 0x23;\r\nif (!(timings->sync & FB_SYNC_HOR_HIGH_ACT))\r\nreg->MiscOutReg |= 0x40;\r\nif (!(timings->sync & FB_SYNC_VERT_HIGH_ACT))\r\nreg->MiscOutReg |= 0x80;\r\nreg->Sequencer[0x00] = 0x00;\r\nreg->Sequencer[0x01] = 0x01;\r\nreg->Sequencer[0x02] = 0x0F;\r\nreg->Sequencer[0x03] = 0x00;\r\nreg->Sequencer[0x04] = 0x0E;\r\nreg->CRTC[0x00] = (timings->HTotal >> 3) - 5;\r\nreg->CRTC[0x01] = (timings->HDisplay >> 3) - 1;\r\nreg->CRTC[0x02] = (timings->HSyncStart >> 3) - 1;\r\nreg->CRTC[0x03] = (((timings->HSyncEnd >> 3) - 1) & 0x1f) | 0x80;\r\nreg->CRTC[0x04] = (timings->HSyncStart >> 3);\r\nreg->CRTC[0x05] = ((((timings->HSyncEnd >> 3) - 1) & 0x20) << 2) |\r\n(((timings->HSyncEnd >> 3)) & 0x1f);\r\nreg->CRTC[0x06] = (timings->VTotal - 2) & 0xFF;\r\nreg->CRTC[0x07] = (((timings->VTotal - 2) & 0x100) >> 8) |\r\n(((timings->VDisplay - 1) & 0x100) >> 7) |\r\n((timings->VSyncStart & 0x100) >> 6) |\r\n(((timings->VSyncStart - 1) & 0x100) >> 5) |\r\n0x10 |\r\n(((timings->VTotal - 2) & 0x200) >> 4) |\r\n(((timings->VDisplay - 1) & 0x200) >> 3) |\r\n((timings->VSyncStart & 0x200) >> 2);\r\nreg->CRTC[0x08] = 0x00;\r\nreg->CRTC[0x09] = (((timings->VSyncStart - 1) & 0x200) >> 4) | 0x40;\r\nif (timings->dblscan)\r\nreg->CRTC[0x09] |= 0x80;\r\nreg->CRTC[0x0a] = 0x00;\r\nreg->CRTC[0x0b] = 0x00;\r\nreg->CRTC[0x0c] = 0x00;\r\nreg->CRTC[0x0d] = 0x00;\r\nreg->CRTC[0x0e] = 0x00;\r\nreg->CRTC[0x0f] = 0x00;\r\nreg->CRTC[0x10] = timings->VSyncStart & 0xff;\r\nreg->CRTC[0x11] = (timings->VSyncEnd & 0x0f) | 0x20;\r\nreg->CRTC[0x12] = (timings->VDisplay - 1) & 0xff;\r\nreg->CRTC[0x13] = var->xres_virtual >> 4;\r\nreg->CRTC[0x14] = 0x00;\r\nreg->CRTC[0x15] = (timings->VSyncStart - 1) & 0xff;\r\nreg->CRTC[0x16] = (timings->VSyncEnd - 1) & 0xff;\r\nreg->CRTC[0x17] = 0xc3;\r\nreg->CRTC[0x18] = 0xff;\r\nreg->Graphics[0x00] = 0x00;\r\nreg->Graphics[0x01] = 0x00;\r\nreg->Graphics[0x02] = 0x00;\r\nreg->Graphics[0x03] = 0x00;\r\nreg->Graphics[0x04] = 0x00;\r\nreg->Graphics[0x05] = 0x40;\r\nreg->Graphics[0x06] = 0x05;\r\nreg->Graphics[0x07] = 0x0F;\r\nreg->Graphics[0x08] = 0xFF;\r\nreg->Attribute[0x00] = 0x00;\r\nreg->Attribute[0x01] = 0x01;\r\nreg->Attribute[0x02] = 0x02;\r\nreg->Attribute[0x03] = 0x03;\r\nreg->Attribute[0x04] = 0x04;\r\nreg->Attribute[0x05] = 0x05;\r\nreg->Attribute[0x06] = 0x06;\r\nreg->Attribute[0x07] = 0x07;\r\nreg->Attribute[0x08] = 0x08;\r\nreg->Attribute[0x09] = 0x09;\r\nreg->Attribute[0x0a] = 0x0A;\r\nreg->Attribute[0x0b] = 0x0B;\r\nreg->Attribute[0x0c] = 0x0C;\r\nreg->Attribute[0x0d] = 0x0D;\r\nreg->Attribute[0x0e] = 0x0E;\r\nreg->Attribute[0x0f] = 0x0F;\r\nreg->Attribute[0x10] = 0x41;\r\nreg->Attribute[0x11] = 0xFF;\r\nreg->Attribute[0x12] = 0x0F;\r\nreg->Attribute[0x13] = 0x00;\r\nreg->Attribute[0x14] = 0x00;\r\n}\r\nstatic void\r\nsavage3D_waitfifo(struct savagefb_par *par, int space)\r\n{\r\nint slots = MAXFIFO - space;\r\nwhile ((savage_in32(0x48C00, par) & 0x0000ffff) > slots);\r\n}\r\nstatic void\r\nsavage4_waitfifo(struct savagefb_par *par, int space)\r\n{\r\nint slots = MAXFIFO - space;\r\nwhile ((savage_in32(0x48C60, par) & 0x001fffff) > slots);\r\n}\r\nstatic void\r\nsavage2000_waitfifo(struct savagefb_par *par, int space)\r\n{\r\nint slots = MAXFIFO - space;\r\nwhile ((savage_in32(0x48C60, par) & 0x0000ffff) > slots);\r\n}\r\nstatic void\r\nsavage3D_waitidle(struct savagefb_par *par)\r\n{\r\nwhile ((savage_in32(0x48C00, par) & 0x0008ffff) != 0x80000);\r\n}\r\nstatic void\r\nsavage4_waitidle(struct savagefb_par *par)\r\n{\r\nwhile ((savage_in32(0x48C60, par) & 0x00a00000) != 0x00a00000);\r\n}\r\nstatic void\r\nsavage2000_waitidle(struct savagefb_par *par)\r\n{\r\nwhile ((savage_in32(0x48C60, par) & 0x009fffff));\r\n}\r\nstatic void\r\nSavageSetup2DEngine(struct savagefb_par *par)\r\n{\r\nunsigned long GlobalBitmapDescriptor;\r\nGlobalBitmapDescriptor = 1 | 8 | BCI_BD_BW_DISABLE;\r\nBCI_BD_SET_BPP(GlobalBitmapDescriptor, par->depth);\r\nBCI_BD_SET_STRIDE(GlobalBitmapDescriptor, par->vwidth);\r\nswitch(par->chip) {\r\ncase S3_SAVAGE3D:\r\ncase S3_SAVAGE_MX:\r\nsavage_out32(0x48C18, savage_in32(0x48C18, par) & 0x3FF0, par);\r\nsavage_out32(0x48C14,\r\n(par->cob_offset >> 11) | (par->cob_index << 29),\r\npar);\r\nsavage_out32(0x48C10, 0x78207220, par);\r\nsavage_out32(0x48C0C, 0, par);\r\nsavage_out32(0x48C18, savage_in32(0x48C18, par) | 0x0C, par);\r\nbreak;\r\ncase S3_SAVAGE4:\r\ncase S3_TWISTER:\r\ncase S3_PROSAVAGE:\r\ncase S3_PROSAVAGEDDR:\r\ncase S3_SUPERSAVAGE:\r\nsavage_out32(0x48C18, savage_in32(0x48C18, par) & 0x3FF0, par);\r\nsavage_out32(0x48C10, 0x00700040, par);\r\nsavage_out32(0x48C0C, 0, par);\r\nsavage_out32(0x48C18, savage_in32(0x48C18, par) | 0x08, par);\r\nbreak;\r\ncase S3_SAVAGE2000:\r\nsavage_out32(0x48C18, 0, par);\r\nsavage_out32(0x48C18,\r\n(par->cob_offset >> 7) | (par->cob_index),\r\npar);\r\nsavage_out32(0x48A30, 0, par);\r\nsavage_out32(0x48C18, savage_in32(0x48C18, par) | 0x00280000,\r\npar);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nvga_out8(0x3d4, 0x31, par);\r\nvga_out8(0x3d5, 0x0c, par);\r\nvga_out8(0x3d4, 0x50, par);\r\nvga_out8(0x3d5, vga_in8(0x3d5, par) | 0xC1, par);\r\nvga_out8(0x3d4, 0x40, par);\r\nvga_out8(0x3d5, 0x01, par);\r\nsavage_out32(MONO_PAT_0, ~0, par);\r\nsavage_out32(MONO_PAT_1, ~0, par);\r\nsavage_out32(0x8128, ~0, par);\r\nsavage_out32(0x812C, ~0, par);\r\nsavage_out16(0x8134, 0x27, par);\r\nsavage_out16(0x8136, 0x07, par);\r\npar->bci_ptr = 0;\r\npar->SavageWaitFifo(par, 4);\r\nBCI_SEND(BCI_CMD_SETREG | (1 << 16) | BCI_GBD1);\r\nBCI_SEND(0);\r\nBCI_SEND(BCI_CMD_SETREG | (1 << 16) | BCI_GBD2);\r\nBCI_SEND(GlobalBitmapDescriptor);\r\npar->bci_ptr = 0;\r\npar->SavageWaitFifo(par, 4);\r\nBCI_SEND(BCI_CMD_SETREG | (1 << 16) | BCI_GBD1);\r\nBCI_SEND(0);\r\nBCI_SEND(BCI_CMD_SETREG | (1 << 16) | BCI_GBD2);\r\nBCI_SEND(GlobalBitmapDescriptor);\r\n}\r\nstatic void savagefb_set_clip(struct fb_info *info)\r\n{\r\nstruct savagefb_par *par = info->par;\r\nint cmd;\r\ncmd = BCI_CMD_NOP | BCI_CMD_CLIP_NEW;\r\npar->bci_ptr = 0;\r\npar->SavageWaitFifo(par,3);\r\nBCI_SEND(cmd);\r\nBCI_SEND(BCI_CLIP_TL(0, 0));\r\nBCI_SEND(BCI_CLIP_BR(0xfff, 0xfff));\r\n}\r\nstatic void SavageSetup2DEngine(struct savagefb_par *par) {}\r\nstatic void SavageCalcClock(long freq, int min_m, int min_n1, int max_n1,\r\nint min_n2, int max_n2, long freq_min,\r\nlong freq_max, unsigned int *mdiv,\r\nunsigned int *ndiv, unsigned int *r)\r\n{\r\nlong diff, best_diff;\r\nunsigned int m;\r\nunsigned char n1, n2, best_n1=16+2, best_n2=2, best_m=125+2;\r\nif (freq < freq_min / (1 << max_n2)) {\r\nprintk(KERN_ERR "invalid frequency %ld Khz\n", freq);\r\nfreq = freq_min / (1 << max_n2);\r\n}\r\nif (freq > freq_max / (1 << min_n2)) {\r\nprintk(KERN_ERR "invalid frequency %ld Khz\n", freq);\r\nfreq = freq_max / (1 << min_n2);\r\n}\r\nbest_diff = freq;\r\nfor (n2=min_n2; n2<=max_n2; n2++) {\r\nfor (n1=min_n1+2; n1<=max_n1+2; n1++) {\r\nm = (freq * n1 * (1 << n2) + HALF_BASE_FREQ) /\r\nBASE_FREQ;\r\nif (m < min_m+2 || m > 127+2)\r\ncontinue;\r\nif ((m * BASE_FREQ >= freq_min * n1) &&\r\n(m * BASE_FREQ <= freq_max * n1)) {\r\ndiff = freq * (1 << n2) * n1 - BASE_FREQ * m;\r\nif (diff < 0)\r\ndiff = -diff;\r\nif (diff < best_diff) {\r\nbest_diff = diff;\r\nbest_m = m;\r\nbest_n1 = n1;\r\nbest_n2 = n2;\r\n}\r\n}\r\n}\r\n}\r\n*ndiv = best_n1 - 2;\r\n*r = best_n2;\r\n*mdiv = best_m - 2;\r\n}\r\nstatic int common_calc_clock(long freq, int min_m, int min_n1, int max_n1,\r\nint min_n2, int max_n2, long freq_min,\r\nlong freq_max, unsigned char *mdiv,\r\nunsigned char *ndiv)\r\n{\r\nlong diff, best_diff;\r\nunsigned int m;\r\nunsigned char n1, n2;\r\nunsigned char best_n1 = 16+2, best_n2 = 2, best_m = 125+2;\r\nbest_diff = freq;\r\nfor (n2 = min_n2; n2 <= max_n2; n2++) {\r\nfor (n1 = min_n1+2; n1 <= max_n1+2; n1++) {\r\nm = (freq * n1 * (1 << n2) + HALF_BASE_FREQ) /\r\nBASE_FREQ;\r\nif (m < min_m + 2 || m > 127+2)\r\ncontinue;\r\nif ((m * BASE_FREQ >= freq_min * n1) &&\r\n(m * BASE_FREQ <= freq_max * n1)) {\r\ndiff = freq * (1 << n2) * n1 - BASE_FREQ * m;\r\nif (diff < 0)\r\ndiff = -diff;\r\nif (diff < best_diff) {\r\nbest_diff = diff;\r\nbest_m = m;\r\nbest_n1 = n1;\r\nbest_n2 = n2;\r\n}\r\n}\r\n}\r\n}\r\nif (max_n1 == 63)\r\n*ndiv = (best_n1 - 2) | (best_n2 << 6);\r\nelse\r\n*ndiv = (best_n1 - 2) | (best_n2 << 5);\r\n*mdiv = best_m - 2;\r\nreturn 0;\r\n}\r\nstatic void SavagePrintRegs(struct savagefb_par *par)\r\n{\r\nunsigned char i;\r\nint vgaCRIndex = 0x3d4;\r\nint vgaCRReg = 0x3d5;\r\nprintk(KERN_DEBUG "SR x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 xA xB xC xD xE "\r\n"xF");\r\nfor (i = 0; i < 0x70; i++) {\r\nif (!(i % 16))\r\nprintk(KERN_DEBUG "\nSR%xx ", i >> 4);\r\nvga_out8(0x3c4, i, par);\r\nprintk(KERN_DEBUG " %02x", vga_in8(0x3c5, par));\r\n}\r\nprintk(KERN_DEBUG "\n\nCR x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 xA xB xC "\r\n"xD xE xF");\r\nfor (i = 0; i < 0xB7; i++) {\r\nif (!(i % 16))\r\nprintk(KERN_DEBUG "\nCR%xx ", i >> 4);\r\nvga_out8(vgaCRIndex, i, par);\r\nprintk(KERN_DEBUG " %02x", vga_in8(vgaCRReg, par));\r\n}\r\nprintk(KERN_DEBUG "\n\n");\r\n}\r\nstatic void savage_get_default_par(struct savagefb_par *par, struct savage_reg *reg)\r\n{\r\nunsigned char cr3a, cr53, cr66;\r\nvga_out16(0x3d4, 0x4838, par);\r\nvga_out16(0x3d4, 0xa039, par);\r\nvga_out16(0x3c4, 0x0608, par);\r\nvga_out8(0x3d4, 0x66, par);\r\ncr66 = vga_in8(0x3d5, par);\r\nvga_out8(0x3d5, cr66 | 0x80, par);\r\nvga_out8(0x3d4, 0x3a, par);\r\ncr3a = vga_in8(0x3d5, par);\r\nvga_out8(0x3d5, cr3a | 0x80, par);\r\nvga_out8(0x3d4, 0x53, par);\r\ncr53 = vga_in8(0x3d5, par);\r\nvga_out8(0x3d5, cr53 & 0x7f, par);\r\nvga_out8(0x3d4, 0x66, par);\r\nvga_out8(0x3d5, cr66, par);\r\nvga_out8(0x3d4, 0x3a, par);\r\nvga_out8(0x3d5, cr3a, par);\r\nvga_out8(0x3d4, 0x66, par);\r\nvga_out8(0x3d5, cr66, par);\r\nvga_out8(0x3d4, 0x3a, par);\r\nvga_out8(0x3d5, cr3a, par);\r\nvga_out8(0x3c4, 0x08, par);\r\nreg->SR08 = vga_in8(0x3c5, par);\r\nvga_out8(0x3c5, 0x06, par);\r\nvga_out8(0x3d4, 0x31, par);\r\nreg->CR31 = vga_in8(0x3d5, par);\r\nvga_out8(0x3d4, 0x32, par);\r\nreg->CR32 = vga_in8(0x3d5, par);\r\nvga_out8(0x3d4, 0x34, par);\r\nreg->CR34 = vga_in8(0x3d5, par);\r\nvga_out8(0x3d4, 0x36, par);\r\nreg->CR36 = vga_in8(0x3d5, par);\r\nvga_out8(0x3d4, 0x3a, par);\r\nreg->CR3A = vga_in8(0x3d5, par);\r\nvga_out8(0x3d4, 0x40, par);\r\nreg->CR40 = vga_in8(0x3d5, par);\r\nvga_out8(0x3d4, 0x42, par);\r\nreg->CR42 = vga_in8(0x3d5, par);\r\nvga_out8(0x3d4, 0x45, par);\r\nreg->CR45 = vga_in8(0x3d5, par);\r\nvga_out8(0x3d4, 0x50, par);\r\nreg->CR50 = vga_in8(0x3d5, par);\r\nvga_out8(0x3d4, 0x51, par);\r\nreg->CR51 = vga_in8(0x3d5, par);\r\nvga_out8(0x3d4, 0x53, par);\r\nreg->CR53 = vga_in8(0x3d5, par);\r\nvga_out8(0x3d4, 0x58, par);\r\nreg->CR58 = vga_in8(0x3d5, par);\r\nvga_out8(0x3d4, 0x60, par);\r\nreg->CR60 = vga_in8(0x3d5, par);\r\nvga_out8(0x3d4, 0x66, par);\r\nreg->CR66 = vga_in8(0x3d5, par);\r\nvga_out8(0x3d4, 0x67, par);\r\nreg->CR67 = vga_in8(0x3d5, par);\r\nvga_out8(0x3d4, 0x68, par);\r\nreg->CR68 = vga_in8(0x3d5, par);\r\nvga_out8(0x3d4, 0x69, par);\r\nreg->CR69 = vga_in8(0x3d5, par);\r\nvga_out8(0x3d4, 0x6f, par);\r\nreg->CR6F = vga_in8(0x3d5, par);\r\nvga_out8(0x3d4, 0x33, par);\r\nreg->CR33 = vga_in8(0x3d5, par);\r\nvga_out8(0x3d4, 0x86, par);\r\nreg->CR86 = vga_in8(0x3d5, par);\r\nvga_out8(0x3d4, 0x88, par);\r\nreg->CR88 = vga_in8(0x3d5, par);\r\nvga_out8(0x3d4, 0x90, par);\r\nreg->CR90 = vga_in8(0x3d5, par);\r\nvga_out8(0x3d4, 0x91, par);\r\nreg->CR91 = vga_in8(0x3d5, par);\r\nvga_out8(0x3d4, 0xb0, par);\r\nreg->CRB0 = vga_in8(0x3d5, par) | 0x80;\r\nvga_out8(0x3d4, 0x3b, par);\r\nreg->CR3B = vga_in8(0x3d5, par);\r\nvga_out8(0x3d4, 0x3c, par);\r\nreg->CR3C = vga_in8(0x3d5, par);\r\nvga_out8(0x3d4, 0x43, par);\r\nreg->CR43 = vga_in8(0x3d5, par);\r\nvga_out8(0x3d4, 0x5d, par);\r\nreg->CR5D = vga_in8(0x3d5, par);\r\nvga_out8(0x3d4, 0x5e, par);\r\nreg->CR5E = vga_in8(0x3d5, par);\r\nvga_out8(0x3d4, 0x65, par);\r\nreg->CR65 = vga_in8(0x3d5, par);\r\nvga_out8(0x3c4, 0x0e, par);\r\nreg->SR0E = vga_in8(0x3c5, par);\r\nvga_out8(0x3c4, 0x0f, par);\r\nreg->SR0F = vga_in8(0x3c5, par);\r\nvga_out8(0x3c4, 0x10, par);\r\nreg->SR10 = vga_in8(0x3c5, par);\r\nvga_out8(0x3c4, 0x11, par);\r\nreg->SR11 = vga_in8(0x3c5, par);\r\nvga_out8(0x3c4, 0x12, par);\r\nreg->SR12 = vga_in8(0x3c5, par);\r\nvga_out8(0x3c4, 0x13, par);\r\nreg->SR13 = vga_in8(0x3c5, par);\r\nvga_out8(0x3c4, 0x29, par);\r\nreg->SR29 = vga_in8(0x3c5, par);\r\nvga_out8(0x3c4, 0x15, par);\r\nreg->SR15 = vga_in8(0x3c5, par);\r\nvga_out8(0x3c4, 0x30, par);\r\nreg->SR30 = vga_in8(0x3c5, par);\r\nvga_out8(0x3c4, 0x18, par);\r\nreg->SR18 = vga_in8(0x3c5, par);\r\nif (par->chip == S3_SAVAGE_MX) {\r\nint i;\r\nfor (i = 0; i < 8; i++) {\r\nvga_out8(0x3c4, 0x54+i, par);\r\nreg->SR54[i] = vga_in8(0x3c5, par);\r\n}\r\n}\r\nvga_out8(0x3d4, 0x66, par);\r\ncr66 = vga_in8(0x3d5, par);\r\nvga_out8(0x3d5, cr66 | 0x80, par);\r\nvga_out8(0x3d4, 0x3a, par);\r\ncr3a = vga_in8(0x3d5, par);\r\nvga_out8(0x3d5, cr3a | 0x80, par);\r\nif (par->chip != S3_SAVAGE_MX) {\r\nreg->MMPR0 = savage_in32(FIFO_CONTROL_REG, par);\r\nreg->MMPR1 = savage_in32(MIU_CONTROL_REG, par);\r\nreg->MMPR2 = savage_in32(STREAMS_TIMEOUT_REG, par);\r\nreg->MMPR3 = savage_in32(MISC_TIMEOUT_REG, par);\r\n}\r\nvga_out8(0x3d4, 0x3a, par);\r\nvga_out8(0x3d5, cr3a, par);\r\nvga_out8(0x3d4, 0x66, par);\r\nvga_out8(0x3d5, cr66, par);\r\n}\r\nstatic void savage_set_default_par(struct savagefb_par *par,\r\nstruct savage_reg *reg)\r\n{\r\nunsigned char cr3a, cr53, cr66;\r\nvga_out16(0x3d4, 0x4838, par);\r\nvga_out16(0x3d4, 0xa039, par);\r\nvga_out16(0x3c4, 0x0608, par);\r\nvga_out8(0x3d4, 0x66, par);\r\ncr66 = vga_in8(0x3d5, par);\r\nvga_out8(0x3d5, cr66 | 0x80, par);\r\nvga_out8(0x3d4, 0x3a, par);\r\ncr3a = vga_in8(0x3d5, par);\r\nvga_out8(0x3d5, cr3a | 0x80, par);\r\nvga_out8(0x3d4, 0x53, par);\r\ncr53 = vga_in8(0x3d5, par);\r\nvga_out8(0x3d5, cr53 & 0x7f, par);\r\nvga_out8(0x3d4, 0x66, par);\r\nvga_out8(0x3d5, cr66, par);\r\nvga_out8(0x3d4, 0x3a, par);\r\nvga_out8(0x3d5, cr3a, par);\r\nvga_out8(0x3d4, 0x66, par);\r\nvga_out8(0x3d5, cr66, par);\r\nvga_out8(0x3d4, 0x3a, par);\r\nvga_out8(0x3d5, cr3a, par);\r\nvga_out8(0x3c4, 0x08, par);\r\nvga_out8(0x3c5, reg->SR08, par);\r\nvga_out8(0x3c5, 0x06, par);\r\nvga_out8(0x3d4, 0x31, par);\r\nvga_out8(0x3d5, reg->CR31, par);\r\nvga_out8(0x3d4, 0x32, par);\r\nvga_out8(0x3d5, reg->CR32, par);\r\nvga_out8(0x3d4, 0x34, par);\r\nvga_out8(0x3d5, reg->CR34, par);\r\nvga_out8(0x3d4, 0x36, par);\r\nvga_out8(0x3d5,reg->CR36, par);\r\nvga_out8(0x3d4, 0x3a, par);\r\nvga_out8(0x3d5, reg->CR3A, par);\r\nvga_out8(0x3d4, 0x40, par);\r\nvga_out8(0x3d5, reg->CR40, par);\r\nvga_out8(0x3d4, 0x42, par);\r\nvga_out8(0x3d5, reg->CR42, par);\r\nvga_out8(0x3d4, 0x45, par);\r\nvga_out8(0x3d5, reg->CR45, par);\r\nvga_out8(0x3d4, 0x50, par);\r\nvga_out8(0x3d5, reg->CR50, par);\r\nvga_out8(0x3d4, 0x51, par);\r\nvga_out8(0x3d5, reg->CR51, par);\r\nvga_out8(0x3d4, 0x53, par);\r\nvga_out8(0x3d5, reg->CR53, par);\r\nvga_out8(0x3d4, 0x58, par);\r\nvga_out8(0x3d5, reg->CR58, par);\r\nvga_out8(0x3d4, 0x60, par);\r\nvga_out8(0x3d5, reg->CR60, par);\r\nvga_out8(0x3d4, 0x66, par);\r\nvga_out8(0x3d5, reg->CR66, par);\r\nvga_out8(0x3d4, 0x67, par);\r\nvga_out8(0x3d5, reg->CR67, par);\r\nvga_out8(0x3d4, 0x68, par);\r\nvga_out8(0x3d5, reg->CR68, par);\r\nvga_out8(0x3d4, 0x69, par);\r\nvga_out8(0x3d5, reg->CR69, par);\r\nvga_out8(0x3d4, 0x6f, par);\r\nvga_out8(0x3d5, reg->CR6F, par);\r\nvga_out8(0x3d4, 0x33, par);\r\nvga_out8(0x3d5, reg->CR33, par);\r\nvga_out8(0x3d4, 0x86, par);\r\nvga_out8(0x3d5, reg->CR86, par);\r\nvga_out8(0x3d4, 0x88, par);\r\nvga_out8(0x3d5, reg->CR88, par);\r\nvga_out8(0x3d4, 0x90, par);\r\nvga_out8(0x3d5, reg->CR90, par);\r\nvga_out8(0x3d4, 0x91, par);\r\nvga_out8(0x3d5, reg->CR91, par);\r\nvga_out8(0x3d4, 0xb0, par);\r\nvga_out8(0x3d5, reg->CRB0, par);\r\nvga_out8(0x3d4, 0x3b, par);\r\nvga_out8(0x3d5, reg->CR3B, par);\r\nvga_out8(0x3d4, 0x3c, par);\r\nvga_out8(0x3d5, reg->CR3C, par);\r\nvga_out8(0x3d4, 0x43, par);\r\nvga_out8(0x3d5, reg->CR43, par);\r\nvga_out8(0x3d4, 0x5d, par);\r\nvga_out8(0x3d5, reg->CR5D, par);\r\nvga_out8(0x3d4, 0x5e, par);\r\nvga_out8(0x3d5, reg->CR5E, par);\r\nvga_out8(0x3d4, 0x65, par);\r\nvga_out8(0x3d5, reg->CR65, par);\r\nvga_out8(0x3c4, 0x0e, par);\r\nvga_out8(0x3c5, reg->SR0E, par);\r\nvga_out8(0x3c4, 0x0f, par);\r\nvga_out8(0x3c5, reg->SR0F, par);\r\nvga_out8(0x3c4, 0x10, par);\r\nvga_out8(0x3c5, reg->SR10, par);\r\nvga_out8(0x3c4, 0x11, par);\r\nvga_out8(0x3c5, reg->SR11, par);\r\nvga_out8(0x3c4, 0x12, par);\r\nvga_out8(0x3c5, reg->SR12, par);\r\nvga_out8(0x3c4, 0x13, par);\r\nvga_out8(0x3c5, reg->SR13, par);\r\nvga_out8(0x3c4, 0x29, par);\r\nvga_out8(0x3c5, reg->SR29, par);\r\nvga_out8(0x3c4, 0x15, par);\r\nvga_out8(0x3c5, reg->SR15, par);\r\nvga_out8(0x3c4, 0x30, par);\r\nvga_out8(0x3c5, reg->SR30, par);\r\nvga_out8(0x3c4, 0x18, par);\r\nvga_out8(0x3c5, reg->SR18, par);\r\nif (par->chip == S3_SAVAGE_MX) {\r\nint i;\r\nfor (i = 0; i < 8; i++) {\r\nvga_out8(0x3c4, 0x54+i, par);\r\nvga_out8(0x3c5, reg->SR54[i], par);\r\n}\r\n}\r\nvga_out8(0x3d4, 0x66, par);\r\ncr66 = vga_in8(0x3d5, par);\r\nvga_out8(0x3d5, cr66 | 0x80, par);\r\nvga_out8(0x3d4, 0x3a, par);\r\ncr3a = vga_in8(0x3d5, par);\r\nvga_out8(0x3d5, cr3a | 0x80, par);\r\nif (par->chip != S3_SAVAGE_MX) {\r\nsavage_out32(FIFO_CONTROL_REG, reg->MMPR0, par);\r\nsavage_out32(MIU_CONTROL_REG, reg->MMPR1, par);\r\nsavage_out32(STREAMS_TIMEOUT_REG, reg->MMPR2, par);\r\nsavage_out32(MISC_TIMEOUT_REG, reg->MMPR3, par);\r\n}\r\nvga_out8(0x3d4, 0x3a, par);\r\nvga_out8(0x3d5, cr3a, par);\r\nvga_out8(0x3d4, 0x66, par);\r\nvga_out8(0x3d5, cr66, par);\r\n}\r\nstatic void savage_update_var(struct fb_var_screeninfo *var,\r\nconst struct fb_videomode *modedb)\r\n{\r\nvar->xres = var->xres_virtual = modedb->xres;\r\nvar->yres = modedb->yres;\r\nif (var->yres_virtual < var->yres)\r\nvar->yres_virtual = var->yres;\r\nvar->xoffset = var->yoffset = 0;\r\nvar->pixclock = modedb->pixclock;\r\nvar->left_margin = modedb->left_margin;\r\nvar->right_margin = modedb->right_margin;\r\nvar->upper_margin = modedb->upper_margin;\r\nvar->lower_margin = modedb->lower_margin;\r\nvar->hsync_len = modedb->hsync_len;\r\nvar->vsync_len = modedb->vsync_len;\r\nvar->sync = modedb->sync;\r\nvar->vmode = modedb->vmode;\r\n}\r\nstatic int savagefb_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct savagefb_par *par = info->par;\r\nint memlen, vramlen, mode_valid = 0;\r\nDBG("savagefb_check_var");\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nswitch (var->bits_per_pixel) {\r\ncase 8:\r\nvar->red.offset = var->green.offset =\r\nvar->blue.offset = 0;\r\nvar->red.length = var->green.length =\r\nvar->blue.length = var->bits_per_pixel;\r\nbreak;\r\ncase 16:\r\nvar->red.offset = 11;\r\nvar->red.length = 5;\r\nvar->green.offset = 5;\r\nvar->green.length = 6;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 5;\r\nbreak;\r\ncase 32:\r\nvar->transp.offset = 24;\r\nvar->transp.length = 8;\r\nvar->red.offset = 16;\r\nvar->red.length = 8;\r\nvar->green.offset = 8;\r\nvar->green.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 8;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (!info->monspecs.hfmax || !info->monspecs.vfmax ||\r\n!info->monspecs.dclkmax || !fb_validate_mode(var, info))\r\nmode_valid = 1;\r\nif (!mode_valid && info->monspecs.gtf) {\r\nif (!fb_get_mode(FB_MAXTIMINGS, 0, var, info))\r\nmode_valid = 1;\r\n}\r\nif (!mode_valid) {\r\nconst struct fb_videomode *mode;\r\nmode = fb_find_best_mode(var, &info->modelist);\r\nif (mode) {\r\nsavage_update_var(var, mode);\r\nmode_valid = 1;\r\n}\r\n}\r\nif (!mode_valid && info->monspecs.modedb_len)\r\nreturn -EINVAL;\r\nif (par->SavagePanelWidth &&\r\n(var->xres > par->SavagePanelWidth ||\r\nvar->yres > par->SavagePanelHeight)) {\r\nprintk(KERN_INFO "Mode (%dx%d) larger than the LCD panel "\r\n"(%dx%d)\n", var->xres, var->yres,\r\npar->SavagePanelWidth,\r\npar->SavagePanelHeight);\r\nreturn -1;\r\n}\r\nif (var->yres_virtual < var->yres)\r\nvar->yres_virtual = var->yres;\r\nif (var->xres_virtual < var->xres)\r\nvar->xres_virtual = var->xres;\r\nvramlen = info->fix.smem_len;\r\nmemlen = var->xres_virtual * var->bits_per_pixel *\r\nvar->yres_virtual / 8;\r\nif (memlen > vramlen) {\r\nvar->yres_virtual = vramlen * 8 /\r\n(var->xres_virtual * var->bits_per_pixel);\r\nmemlen = var->xres_virtual * var->bits_per_pixel *\r\nvar->yres_virtual / 8;\r\n}\r\nif (var->yres_virtual < var->yres)\r\nvar->yres = var->yres_virtual;\r\nif (var->xres_virtual < var->xres)\r\nvar->xres = var->xres_virtual;\r\nif (var->xoffset + var->xres > var->xres_virtual)\r\nvar->xoffset = var->xres_virtual - var->xres;\r\nif (var->yoffset + var->yres > var->yres_virtual)\r\nvar->yoffset = var->yres_virtual - var->yres;\r\nreturn 0;\r\n}\r\nstatic int savagefb_decode_var(struct fb_var_screeninfo *var,\r\nstruct savagefb_par *par,\r\nstruct savage_reg *reg)\r\n{\r\nstruct xtimings timings;\r\nint width, dclk, i, j;\r\nunsigned int m, n, r;\r\nunsigned char tmp = 0;\r\nunsigned int pixclock = var->pixclock;\r\nDBG("savagefb_decode_var");\r\nmemset(&timings, 0, sizeof(timings));\r\nif (!pixclock) pixclock = 10000;\r\ntimings.Clock = 1000000000 / pixclock;\r\nif (timings.Clock < 1) timings.Clock = 1;\r\ntimings.dblscan = var->vmode & FB_VMODE_DOUBLE;\r\ntimings.interlaced = var->vmode & FB_VMODE_INTERLACED;\r\ntimings.HDisplay = var->xres;\r\ntimings.HSyncStart = timings.HDisplay + var->right_margin;\r\ntimings.HSyncEnd = timings.HSyncStart + var->hsync_len;\r\ntimings.HTotal = timings.HSyncEnd + var->left_margin;\r\ntimings.VDisplay = var->yres;\r\ntimings.VSyncStart = timings.VDisplay + var->lower_margin;\r\ntimings.VSyncEnd = timings.VSyncStart + var->vsync_len;\r\ntimings.VTotal = timings.VSyncEnd + var->upper_margin;\r\ntimings.sync = var->sync;\r\npar->depth = var->bits_per_pixel;\r\npar->vwidth = var->xres_virtual;\r\nif (var->bits_per_pixel == 16 && par->chip == S3_SAVAGE3D) {\r\ntimings.HDisplay *= 2;\r\ntimings.HSyncStart *= 2;\r\ntimings.HSyncEnd *= 2;\r\ntimings.HTotal *= 2;\r\n}\r\nvgaHWInit(var, par, &timings, reg);\r\ndclk = timings.Clock;\r\nreg->CR67 = 0x00;\r\nswitch(var->bits_per_pixel) {\r\ncase 8:\r\nif ((par->chip == S3_SAVAGE2000) && (dclk >= 230000))\r\nreg->CR67 = 0x10;\r\nelse\r\nreg->CR67 = 0x00;\r\nbreak;\r\ncase 15:\r\nif (S3_SAVAGE_MOBILE_SERIES(par->chip) ||\r\n((par->chip == S3_SAVAGE2000) && (dclk >= 230000)))\r\nreg->CR67 = 0x30;\r\nelse\r\nreg->CR67 = 0x20;\r\nbreak;\r\ncase 16:\r\nif (S3_SAVAGE_MOBILE_SERIES(par->chip) ||\r\n((par->chip == S3_SAVAGE2000) && (dclk >= 230000)))\r\nreg->CR67 = 0x50;\r\nelse\r\nreg->CR67 = 0x40;\r\nbreak;\r\ncase 24:\r\nreg->CR67 = 0x70;\r\nbreak;\r\ncase 32:\r\nreg->CR67 = 0xd0;\r\nbreak;\r\n}\r\nvga_out8(0x3d4, 0x3a, par);\r\ntmp = vga_in8(0x3d5, par);\r\nif (1 )\r\nreg->CR3A = (tmp & 0x7f) | 0x15;\r\nelse\r\nreg->CR3A = tmp | 0x95;\r\nreg->CR53 = 0x00;\r\nreg->CR31 = 0x8c;\r\nreg->CR66 = 0x89;\r\nvga_out8(0x3d4, 0x58, par);\r\nreg->CR58 = vga_in8(0x3d5, par) & 0x80;\r\nreg->CR58 |= 0x13;\r\nreg->SR15 = 0x03 | 0x80;\r\nreg->SR18 = 0x00;\r\nreg->CR43 = reg->CR45 = reg->CR65 = 0x00;\r\nvga_out8(0x3d4, 0x40, par);\r\nreg->CR40 = vga_in8(0x3d5, par) & ~0x01;\r\nreg->MMPR0 = 0x010400;\r\nreg->MMPR1 = 0x00;\r\nreg->MMPR2 = 0x0808;\r\nreg->MMPR3 = 0x08080810;\r\nSavageCalcClock(dclk, 1, 1, 127, 0, 4, 180000, 360000, &m, &n, &r);\r\nif (par->MCLK <= 0) {\r\nreg->SR10 = 255;\r\nreg->SR11 = 255;\r\n} else {\r\ncommon_calc_clock(par->MCLK, 1, 1, 31, 0, 3, 135000, 270000,\r\n&reg->SR11, &reg->SR10);\r\n}\r\nreg->SR12 = (r << 6) | (n & 0x3f);\r\nreg->SR13 = m & 0xff;\r\nreg->SR29 = (r & 4) | (m & 0x100) >> 5 | (n & 0x40) >> 2;\r\nif (var->bits_per_pixel < 24)\r\nreg->MMPR0 -= 0x8000;\r\nelse\r\nreg->MMPR0 -= 0x4000;\r\nif (timings.interlaced)\r\nreg->CR42 = 0x20;\r\nelse\r\nreg->CR42 = 0x00;\r\nreg->CR34 = 0x10;\r\ni = ((((timings.HTotal >> 3) - 5) & 0x100) >> 8) |\r\n((((timings.HDisplay >> 3) - 1) & 0x100) >> 7) |\r\n((((timings.HSyncStart >> 3) - 1) & 0x100) >> 6) |\r\n((timings.HSyncStart & 0x800) >> 7);\r\nif ((timings.HSyncEnd >> 3) - (timings.HSyncStart >> 3) > 64)\r\ni |= 0x08;\r\nif ((timings.HSyncEnd >> 3) - (timings.HSyncStart >> 3) > 32)\r\ni |= 0x20;\r\nj = (reg->CRTC[0] + ((i & 0x01) << 8) +\r\nreg->CRTC[4] + ((i & 0x10) << 4) + 1) / 2;\r\nif (j - (reg->CRTC[4] + ((i & 0x10) << 4)) < 4) {\r\nif (reg->CRTC[4] + ((i & 0x10) << 4) + 4 <=\r\nreg->CRTC[0] + ((i & 0x01) << 8))\r\nj = reg->CRTC[4] + ((i & 0x10) << 4) + 4;\r\nelse\r\nj = reg->CRTC[0] + ((i & 0x01) << 8) + 1;\r\n}\r\nreg->CR3B = j & 0xff;\r\ni |= (j & 0x100) >> 2;\r\nreg->CR3C = (reg->CRTC[0] + ((i & 0x01) << 8)) / 2;\r\nreg->CR5D = i;\r\nreg->CR5E = (((timings.VTotal - 2) & 0x400) >> 10) |\r\n(((timings.VDisplay - 1) & 0x400) >> 9) |\r\n(((timings.VSyncStart) & 0x400) >> 8) |\r\n(((timings.VSyncStart) & 0x400) >> 6) | 0x40;\r\nwidth = (var->xres_virtual * ((var->bits_per_pixel+7) / 8)) >> 3;\r\nreg->CR91 = reg->CRTC[19] = 0xff & width;\r\nreg->CR51 = (0x300 & width) >> 4;\r\nreg->CR90 = 0x80 | (width >> 8);\r\nreg->MiscOutReg |= 0x0c;\r\nif (var->bits_per_pixel <= 8)\r\nreg->CR50 = 0;\r\nelse if (var->bits_per_pixel <= 16)\r\nreg->CR50 = 0x10;\r\nelse\r\nreg->CR50 = 0x30;\r\nif (var->xres_virtual <= 640)\r\nreg->CR50 |= 0x40;\r\nelse if (var->xres_virtual == 800)\r\nreg->CR50 |= 0x80;\r\nelse if (var->xres_virtual == 1024)\r\nreg->CR50 |= 0x00;\r\nelse if (var->xres_virtual == 1152)\r\nreg->CR50 |= 0x01;\r\nelse if (var->xres_virtual == 1280)\r\nreg->CR50 |= 0xc0;\r\nelse if (var->xres_virtual == 1600)\r\nreg->CR50 |= 0x81;\r\nelse\r\nreg->CR50 |= 0xc1;\r\nif (par->chip == S3_SAVAGE2000)\r\nreg->CR33 = 0x08;\r\nelse\r\nreg->CR33 = 0x20;\r\nreg->CRTC[0x17] = 0xeb;\r\nreg->CR67 |= 1;\r\nvga_out8(0x3d4, 0x36, par);\r\nreg->CR36 = vga_in8(0x3d5, par);\r\nvga_out8(0x3d4, 0x68, par);\r\nreg->CR68 = vga_in8(0x3d5, par);\r\nreg->CR69 = 0;\r\nvga_out8(0x3d4, 0x6f, par);\r\nreg->CR6F = vga_in8(0x3d5, par);\r\nvga_out8(0x3d4, 0x86, par);\r\nreg->CR86 = vga_in8(0x3d5, par);\r\nvga_out8(0x3d4, 0x88, par);\r\nreg->CR88 = vga_in8(0x3d5, par) | 0x08;\r\nvga_out8(0x3d4, 0xb0, par);\r\nreg->CRB0 = vga_in8(0x3d5, par) | 0x80;\r\nreturn 0;\r\n}\r\nstatic int savagefb_setcolreg(unsigned regno,\r\nunsigned red,\r\nunsigned green,\r\nunsigned blue,\r\nunsigned transp,\r\nstruct fb_info *info)\r\n{\r\nstruct savagefb_par *par = info->par;\r\nif (regno >= NR_PALETTE)\r\nreturn -EINVAL;\r\npar->palette[regno].red = red;\r\npar->palette[regno].green = green;\r\npar->palette[regno].blue = blue;\r\npar->palette[regno].transp = transp;\r\nswitch (info->var.bits_per_pixel) {\r\ncase 8:\r\nvga_out8(0x3c8, regno, par);\r\nvga_out8(0x3c9, red >> 10, par);\r\nvga_out8(0x3c9, green >> 10, par);\r\nvga_out8(0x3c9, blue >> 10, par);\r\nbreak;\r\ncase 16:\r\nif (regno < 16)\r\n((u32 *)info->pseudo_palette)[regno] =\r\n((red & 0xf800) ) |\r\n((green & 0xfc00) >> 5) |\r\n((blue & 0xf800) >> 11);\r\nbreak;\r\ncase 24:\r\nif (regno < 16)\r\n((u32 *)info->pseudo_palette)[regno] =\r\n((red & 0xff00) << 8) |\r\n((green & 0xff00) ) |\r\n((blue & 0xff00) >> 8);\r\nbreak;\r\ncase 32:\r\nif (regno < 16)\r\n((u32 *)info->pseudo_palette)[regno] =\r\n((transp & 0xff00) << 16) |\r\n((red & 0xff00) << 8) |\r\n((green & 0xff00) ) |\r\n((blue & 0xff00) >> 8);\r\nbreak;\r\ndefault:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void savagefb_set_par_int(struct savagefb_par *par, struct savage_reg *reg)\r\n{\r\nunsigned char tmp, cr3a, cr66, cr67;\r\nDBG("savagefb_set_par_int");\r\npar->SavageWaitIdle(par);\r\nvga_out8(0x3c2, 0x23, par);\r\nvga_out16(0x3d4, 0x4838, par);\r\nvga_out16(0x3d4, 0xa539, par);\r\nvga_out16(0x3c4, 0x0608, par);\r\nvgaHWProtect(par, 1);\r\nVerticalRetraceWait(par);\r\nvga_out8(0x3d4, 0x67, par);\r\ncr67 = vga_in8(0x3d5, par);\r\nvga_out8(0x3d5, cr67 & ~0x0c, par);\r\nvga_out8(0x3d4, 0x23, par);\r\nvga_out8(0x3d5, 0x00, par);\r\nvga_out8(0x3d4, 0x26, par);\r\nvga_out8(0x3d5, 0x00, par);\r\nvga_out8(0x3d4, 0x66, par);\r\nvga_out8(0x3d5, reg->CR66, par);\r\nvga_out8(0x3d4, 0x3a, par);\r\nvga_out8(0x3d5, reg->CR3A, par);\r\nvga_out8(0x3d4, 0x31, par);\r\nvga_out8(0x3d5, reg->CR31, par);\r\nvga_out8(0x3d4, 0x32, par);\r\nvga_out8(0x3d5, reg->CR32, par);\r\nvga_out8(0x3d4, 0x58, par);\r\nvga_out8(0x3d5, reg->CR58, par);\r\nvga_out8(0x3d4, 0x53, par);\r\nvga_out8(0x3d5, reg->CR53 & 0x7f, par);\r\nvga_out16(0x3c4, 0x0608, par);\r\nvga_out8(0x3c4, 0x0e, par);\r\nvga_out8(0x3c5, reg->SR0E, par);\r\nvga_out8(0x3c4, 0x0f, par);\r\nvga_out8(0x3c5, reg->SR0F, par);\r\nvga_out8(0x3c4, 0x29, par);\r\nvga_out8(0x3c5, reg->SR29, par);\r\nvga_out8(0x3c4, 0x15, par);\r\nvga_out8(0x3c5, reg->SR15, par);\r\nif (par->chip == S3_SAVAGE_MX) {\r\nint i;\r\nfor (i = 0; i < 8; i++) {\r\nvga_out8(0x3c4, 0x54+i, par);\r\nvga_out8(0x3c5, reg->SR54[i], par);\r\n}\r\n}\r\nvgaHWRestore (par, reg);\r\nvga_out8(0x3d4, 0x53, par);\r\nvga_out8(0x3d5, reg->CR53, par);\r\nvga_out8(0x3d4, 0x5d, par);\r\nvga_out8(0x3d5, reg->CR5D, par);\r\nvga_out8(0x3d4, 0x5e, par);\r\nvga_out8(0x3d5, reg->CR5E, par);\r\nvga_out8(0x3d4, 0x3b, par);\r\nvga_out8(0x3d5, reg->CR3B, par);\r\nvga_out8(0x3d4, 0x3c, par);\r\nvga_out8(0x3d5, reg->CR3C, par);\r\nvga_out8(0x3d4, 0x43, par);\r\nvga_out8(0x3d5, reg->CR43, par);\r\nvga_out8(0x3d4, 0x65, par);\r\nvga_out8(0x3d5, reg->CR65, par);\r\nvga_out8(0x3d4, 0x67, par);\r\ncr67 = vga_in8(0x3d5, par) & 0xf;\r\nvga_out8(0x3d5, 0x50 | cr67, par);\r\nmdelay(10);\r\nvga_out8(0x3d4, 0x67, par);\r\nvga_out8(0x3d5, reg->CR67 & ~0x0c, par);\r\nvga_out8(0x3d4, 0x34, par);\r\nvga_out8(0x3d5, reg->CR34, par);\r\nvga_out8(0x3d4, 0x40, par);\r\nvga_out8(0x3d5, reg->CR40, par);\r\nvga_out8(0x3d4, 0x42, par);\r\nvga_out8(0x3d5, reg->CR42, par);\r\nvga_out8(0x3d4, 0x45, par);\r\nvga_out8(0x3d5, reg->CR45, par);\r\nvga_out8(0x3d4, 0x50, par);\r\nvga_out8(0x3d5, reg->CR50, par);\r\nvga_out8(0x3d4, 0x51, par);\r\nvga_out8(0x3d5, reg->CR51, par);\r\nvga_out8(0x3d4, 0x36, par);\r\nvga_out8(0x3d5, reg->CR36, par);\r\nvga_out8(0x3d4, 0x60, par);\r\nvga_out8(0x3d5, reg->CR60, par);\r\nvga_out8(0x3d4, 0x68, par);\r\nvga_out8(0x3d5, reg->CR68, par);\r\nvga_out8(0x3d4, 0x69, par);\r\nvga_out8(0x3d5, reg->CR69, par);\r\nvga_out8(0x3d4, 0x6f, par);\r\nvga_out8(0x3d5, reg->CR6F, par);\r\nvga_out8(0x3d4, 0x33, par);\r\nvga_out8(0x3d5, reg->CR33, par);\r\nvga_out8(0x3d4, 0x86, par);\r\nvga_out8(0x3d5, reg->CR86, par);\r\nvga_out8(0x3d4, 0x88, par);\r\nvga_out8(0x3d5, reg->CR88, par);\r\nvga_out8(0x3d4, 0x90, par);\r\nvga_out8(0x3d5, reg->CR90, par);\r\nvga_out8(0x3d4, 0x91, par);\r\nvga_out8(0x3d5, reg->CR91, par);\r\nif (par->chip == S3_SAVAGE4) {\r\nvga_out8(0x3d4, 0xb0, par);\r\nvga_out8(0x3d5, reg->CRB0, par);\r\n}\r\nvga_out8(0x3d4, 0x32, par);\r\nvga_out8(0x3d5, reg->CR32, par);\r\nvga_out8(0x3c4, 0x08, par);\r\nvga_out8(0x3c5, 0x06, par);\r\nif (reg->SR10 != 255) {\r\nvga_out8(0x3c4, 0x10, par);\r\nvga_out8(0x3c5, reg->SR10, par);\r\nvga_out8(0x3c4, 0x11, par);\r\nvga_out8(0x3c5, reg->SR11, par);\r\n}\r\nvga_out8(0x3c4, 0x0e, par);\r\nvga_out8(0x3c5, reg->SR0E, par);\r\nvga_out8(0x3c4, 0x0f, par);\r\nvga_out8(0x3c5, reg->SR0F, par);\r\nvga_out8(0x3c4, 0x12, par);\r\nvga_out8(0x3c5, reg->SR12, par);\r\nvga_out8(0x3c4, 0x13, par);\r\nvga_out8(0x3c5, reg->SR13, par);\r\nvga_out8(0x3c4, 0x29, par);\r\nvga_out8(0x3c5, reg->SR29, par);\r\nvga_out8(0x3c4, 0x18, par);\r\nvga_out8(0x3c5, reg->SR18, par);\r\nvga_out8(0x3c4, 0x15, par);\r\ntmp = vga_in8(0x3c5, par) & ~0x21;\r\nvga_out8(0x3c5, tmp | 0x03, par);\r\nvga_out8(0x3c5, tmp | 0x23, par);\r\nvga_out8(0x3c5, tmp | 0x03, par);\r\nvga_out8(0x3c5, reg->SR15, par);\r\nudelay(100);\r\nvga_out8(0x3c4, 0x30, par);\r\nvga_out8(0x3c5, reg->SR30, par);\r\nvga_out8(0x3c4, 0x08, par);\r\nvga_out8(0x3c5, reg->SR08, par);\r\nVerticalRetraceWait(par);\r\nvga_out8(0x3d4, 0x67, par);\r\nvga_out8(0x3d5, reg->CR67, par);\r\nvga_out8(0x3d4, 0x66, par);\r\ncr66 = vga_in8(0x3d5, par);\r\nvga_out8(0x3d5, cr66 | 0x80, par);\r\nvga_out8(0x3d4, 0x3a, par);\r\ncr3a = vga_in8(0x3d5, par);\r\nvga_out8(0x3d5, cr3a | 0x80, par);\r\nif (par->chip != S3_SAVAGE_MX) {\r\nVerticalRetraceWait(par);\r\nsavage_out32(FIFO_CONTROL_REG, reg->MMPR0, par);\r\npar->SavageWaitIdle(par);\r\nsavage_out32(MIU_CONTROL_REG, reg->MMPR1, par);\r\npar->SavageWaitIdle(par);\r\nsavage_out32(STREAMS_TIMEOUT_REG, reg->MMPR2, par);\r\npar->SavageWaitIdle(par);\r\nsavage_out32(MISC_TIMEOUT_REG, reg->MMPR3, par);\r\n}\r\nvga_out8(0x3d4, 0x66, par);\r\nvga_out8(0x3d5, cr66, par);\r\nvga_out8(0x3d4, 0x3a, par);\r\nvga_out8(0x3d5, cr3a, par);\r\nSavageSetup2DEngine(par);\r\nvgaHWProtect(par, 0);\r\n}\r\nstatic void savagefb_update_start(struct savagefb_par *par, int base)\r\n{\r\nvga_out16(0x3d4, (base & 0x00ff00) | 0x0c, par);\r\nvga_out16(0x3d4, ((base & 0x00ff) << 8) | 0x0d, par);\r\nvga_out8(0x3d4, 0x69, par);\r\nvga_out8(0x3d5, (base & 0x7f0000) >> 16, par);\r\n}\r\nstatic void savagefb_set_fix(struct fb_info *info)\r\n{\r\ninfo->fix.line_length = info->var.xres_virtual *\r\ninfo->var.bits_per_pixel / 8;\r\nif (info->var.bits_per_pixel == 8) {\r\ninfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\r\ninfo->fix.xpanstep = 4;\r\n} else {\r\ninfo->fix.visual = FB_VISUAL_TRUECOLOR;\r\ninfo->fix.xpanstep = 2;\r\n}\r\n}\r\nstatic int savagefb_set_par(struct fb_info *info)\r\n{\r\nstruct savagefb_par *par = info->par;\r\nstruct fb_var_screeninfo *var = &info->var;\r\nint err;\r\nDBG("savagefb_set_par");\r\nerr = savagefb_decode_var(var, par, &par->state);\r\nif (err)\r\nreturn err;\r\nif (par->dacSpeedBpp <= 0) {\r\nif (var->bits_per_pixel > 24)\r\npar->dacSpeedBpp = par->clock[3];\r\nelse if (var->bits_per_pixel >= 24)\r\npar->dacSpeedBpp = par->clock[2];\r\nelse if ((var->bits_per_pixel > 8) && (var->bits_per_pixel < 24))\r\npar->dacSpeedBpp = par->clock[1];\r\nelse if (var->bits_per_pixel <= 8)\r\npar->dacSpeedBpp = par->clock[0];\r\n}\r\npar->maxClock = par->dacSpeedBpp;\r\npar->minClock = 10000;\r\nsavagefb_set_par_int(par, &par->state);\r\nfb_set_cmap(&info->cmap, info);\r\nsavagefb_set_fix(info);\r\nsavagefb_set_clip(info);\r\nSavagePrintRegs(par);\r\nreturn 0;\r\n}\r\nstatic int savagefb_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct savagefb_par *par = info->par;\r\nint base;\r\nbase = (var->yoffset * info->fix.line_length\r\n+ (var->xoffset & ~1) * ((info->var.bits_per_pixel+7) / 8)) >> 2;\r\nsavagefb_update_start(par, base);\r\nreturn 0;\r\n}\r\nstatic int savagefb_blank(int blank, struct fb_info *info)\r\n{\r\nstruct savagefb_par *par = info->par;\r\nu8 sr8 = 0, srd = 0;\r\nif (par->display_type == DISP_CRT) {\r\nvga_out8(0x3c4, 0x08, par);\r\nsr8 = vga_in8(0x3c5, par);\r\nsr8 |= 0x06;\r\nvga_out8(0x3c5, sr8, par);\r\nvga_out8(0x3c4, 0x0d, par);\r\nsrd = vga_in8(0x3c5, par);\r\nsrd &= 0x50;\r\nswitch (blank) {\r\ncase FB_BLANK_UNBLANK:\r\ncase FB_BLANK_NORMAL:\r\nbreak;\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\nsrd |= 0x10;\r\nbreak;\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\nsrd |= 0x40;\r\nbreak;\r\ncase FB_BLANK_POWERDOWN:\r\nsrd |= 0x50;\r\nbreak;\r\n}\r\nvga_out8(0x3c4, 0x0d, par);\r\nvga_out8(0x3c5, srd, par);\r\n}\r\nif (par->display_type == DISP_LCD ||\r\npar->display_type == DISP_DFP) {\r\nswitch(blank) {\r\ncase FB_BLANK_UNBLANK:\r\ncase FB_BLANK_NORMAL:\r\nvga_out8(0x3c4, 0x31, par);\r\nvga_out8(0x3c5, vga_in8(0x3c5, par) | 0x10, par);\r\nbreak;\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\ncase FB_BLANK_POWERDOWN:\r\nvga_out8(0x3c4, 0x31, par);\r\nvga_out8(0x3c5, vga_in8(0x3c5, par) & ~0x10, par);\r\nbreak;\r\n}\r\n}\r\nreturn (blank == FB_BLANK_NORMAL) ? 1 : 0;\r\n}\r\nstatic int savagefb_open(struct fb_info *info, int user)\r\n{\r\nstruct savagefb_par *par = info->par;\r\nmutex_lock(&par->open_lock);\r\nif (!par->open_count) {\r\nmemset(&par->vgastate, 0, sizeof(par->vgastate));\r\npar->vgastate.flags = VGA_SAVE_CMAP | VGA_SAVE_FONTS |\r\nVGA_SAVE_MODE;\r\npar->vgastate.vgabase = par->mmio.vbase + 0x8000;\r\nsave_vga(&par->vgastate);\r\nsavage_get_default_par(par, &par->initial);\r\n}\r\npar->open_count++;\r\nmutex_unlock(&par->open_lock);\r\nreturn 0;\r\n}\r\nstatic int savagefb_release(struct fb_info *info, int user)\r\n{\r\nstruct savagefb_par *par = info->par;\r\nmutex_lock(&par->open_lock);\r\nif (par->open_count == 1) {\r\nsavage_set_default_par(par, &par->initial);\r\nrestore_vga(&par->vgastate);\r\n}\r\npar->open_count--;\r\nmutex_unlock(&par->open_lock);\r\nreturn 0;\r\n}\r\nstatic void savage_enable_mmio(struct savagefb_par *par)\r\n{\r\nunsigned char val;\r\nDBG("savage_enable_mmio\n");\r\nval = vga_in8(0x3c3, par);\r\nvga_out8(0x3c3, val | 0x01, par);\r\nval = vga_in8(0x3cc, par);\r\nvga_out8(0x3c2, val | 0x01, par);\r\nif (par->chip >= S3_SAVAGE4) {\r\nvga_out8(0x3d4, 0x40, par);\r\nval = vga_in8(0x3d5, par);\r\nvga_out8(0x3d5, val | 1, par);\r\n}\r\n}\r\nstatic void savage_disable_mmio(struct savagefb_par *par)\r\n{\r\nunsigned char val;\r\nDBG("savage_disable_mmio\n");\r\nif (par->chip >= S3_SAVAGE4) {\r\nvga_out8(0x3d4, 0x40, par);\r\nval = vga_in8(0x3d5, par);\r\nvga_out8(0x3d5, val | 1, par);\r\n}\r\n}\r\nstatic int savage_map_mmio(struct fb_info *info)\r\n{\r\nstruct savagefb_par *par = info->par;\r\nDBG("savage_map_mmio");\r\nif (S3_SAVAGE3D_SERIES(par->chip))\r\npar->mmio.pbase = pci_resource_start(par->pcidev, 0) +\r\nSAVAGE_NEWMMIO_REGBASE_S3;\r\nelse\r\npar->mmio.pbase = pci_resource_start(par->pcidev, 0) +\r\nSAVAGE_NEWMMIO_REGBASE_S4;\r\npar->mmio.len = SAVAGE_NEWMMIO_REGSIZE;\r\npar->mmio.vbase = ioremap(par->mmio.pbase, par->mmio.len);\r\nif (!par->mmio.vbase) {\r\nprintk("savagefb: unable to map memory mapped IO\n");\r\nreturn -ENOMEM;\r\n} else\r\nprintk(KERN_INFO "savagefb: mapped io at %p\n",\r\npar->mmio.vbase);\r\ninfo->fix.mmio_start = par->mmio.pbase;\r\ninfo->fix.mmio_len = par->mmio.len;\r\npar->bci_base = (u32 __iomem *)(par->mmio.vbase + BCI_BUFFER_OFFSET);\r\npar->bci_ptr = 0;\r\nsavage_enable_mmio(par);\r\nreturn 0;\r\n}\r\nstatic void savage_unmap_mmio(struct fb_info *info)\r\n{\r\nstruct savagefb_par *par = info->par;\r\nDBG("savage_unmap_mmio");\r\nsavage_disable_mmio(par);\r\nif (par->mmio.vbase) {\r\niounmap(par->mmio.vbase);\r\npar->mmio.vbase = NULL;\r\n}\r\n}\r\nstatic int savage_map_video(struct fb_info *info, int video_len)\r\n{\r\nstruct savagefb_par *par = info->par;\r\nint resource;\r\nDBG("savage_map_video");\r\nif (S3_SAVAGE3D_SERIES(par->chip))\r\nresource = 0;\r\nelse\r\nresource = 1;\r\npar->video.pbase = pci_resource_start(par->pcidev, resource);\r\npar->video.len = video_len;\r\npar->video.vbase = ioremap(par->video.pbase, par->video.len);\r\nif (!par->video.vbase) {\r\nprintk("savagefb: unable to map screen memory\n");\r\nreturn -ENOMEM;\r\n} else\r\nprintk(KERN_INFO "savagefb: mapped framebuffer at %p, "\r\n"pbase == %x\n", par->video.vbase, par->video.pbase);\r\ninfo->fix.smem_start = par->video.pbase;\r\ninfo->fix.smem_len = par->video.len - par->cob_size;\r\ninfo->screen_base = par->video.vbase;\r\n#ifdef CONFIG_MTRR\r\npar->video.mtrr = mtrr_add(par->video.pbase, video_len,\r\nMTRR_TYPE_WRCOMB, 1);\r\n#endif\r\nmemset_io(par->video.vbase, 0, par->video.len);\r\nreturn 0;\r\n}\r\nstatic void savage_unmap_video(struct fb_info *info)\r\n{\r\nstruct savagefb_par *par = info->par;\r\nDBG("savage_unmap_video");\r\nif (par->video.vbase) {\r\n#ifdef CONFIG_MTRR\r\nmtrr_del(par->video.mtrr, par->video.pbase, par->video.len);\r\n#endif\r\niounmap(par->video.vbase);\r\npar->video.vbase = NULL;\r\ninfo->screen_base = NULL;\r\n}\r\n}\r\nstatic int savage_init_hw(struct savagefb_par *par)\r\n{\r\nunsigned char config1, m, n, n1, n2, sr8, cr3f, cr66 = 0, tmp;\r\nstatic unsigned char RamSavage3D[] = { 8, 4, 4, 2 };\r\nstatic unsigned char RamSavage4[] = { 2, 4, 8, 12, 16, 32, 64, 32 };\r\nstatic unsigned char RamSavageMX[] = { 2, 8, 4, 16, 8, 16, 4, 16 };\r\nstatic unsigned char RamSavageNB[] = { 0, 2, 4, 8, 16, 32, 2, 2 };\r\nint videoRam, videoRambytes, dvi;\r\nDBG("savage_init_hw");\r\nvga_out8(0x3d4, 0x11, par);\r\ntmp = vga_in8(0x3d5, par);\r\nvga_out8(0x3d5, tmp & 0x7f, par);\r\nvga_out16(0x3d4, 0x4838, par);\r\nvga_out16(0x3d4, 0xa039, par);\r\nvga_out16(0x3c4, 0x0608, par);\r\nvga_out8(0x3d4, 0x40, par);\r\ntmp = vga_in8(0x3d5, par);\r\nvga_out8(0x3d5, tmp & ~0x01, par);\r\nvga_out8(0x3d4, 0x38, par);\r\nvga_out8(0x3d5, 0x48, par);\r\nvga_out16(0x3d4, 0x4838, par);\r\nvga_out8(0x3d4, 0x36, par);\r\nconfig1 = vga_in8(0x3d5, par);\r\nswitch (par->chip) {\r\ncase S3_SAVAGE3D:\r\nvideoRam = RamSavage3D[(config1 & 0xC0) >> 6 ] * 1024;\r\nbreak;\r\ncase S3_SAVAGE4:\r\nvga_out8(0x3d4, 0x68, par);\r\nif ((vga_in8(0x3d5, par) & 0xC0) == (0x01 << 6))\r\nRamSavage4[1] = 8;\r\ncase S3_SAVAGE2000:\r\nvideoRam = RamSavage4[(config1 & 0xE0) >> 5] * 1024;\r\nbreak;\r\ncase S3_SAVAGE_MX:\r\ncase S3_SUPERSAVAGE:\r\nvideoRam = RamSavageMX[(config1 & 0x0E) >> 1] * 1024;\r\nbreak;\r\ncase S3_PROSAVAGE:\r\ncase S3_PROSAVAGEDDR:\r\ncase S3_TWISTER:\r\nvideoRam = RamSavageNB[(config1 & 0xE0) >> 5] * 1024;\r\nbreak;\r\ndefault:\r\nvideoRam = 0;\r\nbreak;\r\n}\r\nvideoRambytes = videoRam * 1024;\r\nprintk(KERN_INFO "savagefb: probed videoram: %dk\n", videoRam);\r\nvga_out8(0x3d4, 0x66, par);\r\ncr66 = vga_in8(0x3d5, par);\r\nvga_out8(0x3d5, cr66 | 0x02, par);\r\nmdelay(10);\r\nvga_out8(0x3d4, 0x66, par);\r\nvga_out8(0x3d5, cr66 & ~0x02, par);\r\nmdelay(10);\r\nvga_out8(0x3d4, 0x3f, par);\r\ncr3f = vga_in8(0x3d5, par);\r\nvga_out8(0x3d5, cr3f | 0x08, par);\r\nmdelay(10);\r\nvga_out8(0x3d4, 0x3f, par);\r\nvga_out8(0x3d5, cr3f & ~0x08, par);\r\nmdelay(10);\r\npar->numClocks = 4;\r\npar->clock[0] = 250000;\r\npar->clock[1] = 250000;\r\npar->clock[2] = 220000;\r\npar->clock[3] = 220000;\r\nvga_out8(0x3c4, 0x08, par);\r\nsr8 = vga_in8(0x3c5, par);\r\nvga_out8(0x3c5, 0x06, par);\r\nvga_out8(0x3c4, 0x10, par);\r\nn = vga_in8(0x3c5, par);\r\nvga_out8(0x3c4, 0x11, par);\r\nm = vga_in8(0x3c5, par);\r\nvga_out8(0x3c4, 0x08, par);\r\nvga_out8(0x3c5, sr8, par);\r\nm &= 0x7f;\r\nn1 = n & 0x1f;\r\nn2 = (n >> 5) & 0x03;\r\npar->MCLK = ((1431818 * (m+2)) / (n1+2) / (1 << n2) + 50) / 100;\r\nprintk(KERN_INFO "savagefb: Detected current MCLK value of %d kHz\n",\r\npar->MCLK);\r\ndvi = 0;\r\nif (par->chip == S3_SAVAGE4) {\r\nunsigned char sr30 = 0x00;\r\nvga_out8(0x3c4, 0x30, par);\r\nvga_out8(0x3c5, vga_in8(0x3c5, par) & ~0x02, par);\r\nsr30 = vga_in8(0x3c5, par);\r\nif (sr30 & 0x02 ) {\r\ndvi = 1;\r\nprintk("savagefb: Digital Flat Panel Detected\n");\r\n}\r\n}\r\nif ((S3_SAVAGE_MOBILE_SERIES(par->chip) ||\r\nS3_MOBILE_TWISTER_SERIES(par->chip)) && !par->crtonly)\r\npar->display_type = DISP_LCD;\r\nelse if (dvi || (par->chip == S3_SAVAGE4 && par->dvi))\r\npar->display_type = DISP_DFP;\r\nelse\r\npar->display_type = DISP_CRT;\r\nif (par->display_type == DISP_LCD) {\r\nunsigned char cr6b = VGArCR(0x6b, par);\r\nint panelX = (VGArSEQ(0x61, par) +\r\n((VGArSEQ(0x66, par) & 0x02) << 7) + 1) * 8;\r\nint panelY = (VGArSEQ(0x69, par) +\r\n((VGArSEQ(0x6e, par) & 0x70) << 4) + 1);\r\nchar * sTechnology = "Unknown";\r\nenum ACTIVE_DISPLAYS {\r\nActiveCRT = 0x01,\r\nActiveLCD = 0x02,\r\nActiveTV = 0x04,\r\nActiveCRT2 = 0x20,\r\nActiveDUO = 0x80\r\n};\r\nif ((VGArSEQ(0x39, par) & 0x03) == 0) {\r\nsTechnology = "TFT";\r\n} else if ((VGArSEQ(0x30, par) & 0x01) == 0) {\r\nsTechnology = "DSTN";\r\n} else {\r\nsTechnology = "STN";\r\n}\r\nprintk(KERN_INFO "savagefb: %dx%d %s LCD panel detected %s\n",\r\npanelX, panelY, sTechnology,\r\ncr6b & ActiveLCD ? "and active" : "but not active");\r\nif (cr6b & ActiveLCD) {\r\nprintk(KERN_INFO "savagefb: Limiting video mode to "\r\n"%dx%d\n", panelX, panelY);\r\npar->SavagePanelWidth = panelX;\r\npar->SavagePanelHeight = panelY;\r\n} else\r\npar->display_type = DISP_CRT;\r\n}\r\nsavage_get_default_par(par, &par->state);\r\npar->save = par->state;\r\nif (S3_SAVAGE4_SERIES(par->chip)) {\r\npar->cob_index = 2;\r\npar->cob_size = 0x8000 << par->cob_index;\r\npar->cob_offset = videoRambytes;\r\n} else {\r\npar->cob_index = 7;\r\npar->cob_size = 0x400 << par->cob_index;\r\npar->cob_offset = videoRambytes - par->cob_size;\r\n}\r\nreturn videoRambytes;\r\n}\r\nstatic int savage_init_fb_info(struct fb_info *info, struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nstruct savagefb_par *par = info->par;\r\nint err = 0;\r\npar->pcidev = dev;\r\ninfo->fix.type = FB_TYPE_PACKED_PIXELS;\r\ninfo->fix.type_aux = 0;\r\ninfo->fix.ypanstep = 1;\r\ninfo->fix.ywrapstep = 0;\r\ninfo->fix.accel = id->driver_data;\r\nswitch (info->fix.accel) {\r\ncase FB_ACCEL_SUPERSAVAGE:\r\npar->chip = S3_SUPERSAVAGE;\r\nsnprintf(info->fix.id, 16, "SuperSavage");\r\nbreak;\r\ncase FB_ACCEL_SAVAGE4:\r\npar->chip = S3_SAVAGE4;\r\nsnprintf(info->fix.id, 16, "Savage4");\r\nbreak;\r\ncase FB_ACCEL_SAVAGE3D:\r\npar->chip = S3_SAVAGE3D;\r\nsnprintf(info->fix.id, 16, "Savage3D");\r\nbreak;\r\ncase FB_ACCEL_SAVAGE3D_MV:\r\npar->chip = S3_SAVAGE3D;\r\nsnprintf(info->fix.id, 16, "Savage3D-MV");\r\nbreak;\r\ncase FB_ACCEL_SAVAGE2000:\r\npar->chip = S3_SAVAGE2000;\r\nsnprintf(info->fix.id, 16, "Savage2000");\r\nbreak;\r\ncase FB_ACCEL_SAVAGE_MX_MV:\r\npar->chip = S3_SAVAGE_MX;\r\nsnprintf(info->fix.id, 16, "Savage/MX-MV");\r\nbreak;\r\ncase FB_ACCEL_SAVAGE_MX:\r\npar->chip = S3_SAVAGE_MX;\r\nsnprintf(info->fix.id, 16, "Savage/MX");\r\nbreak;\r\ncase FB_ACCEL_SAVAGE_IX_MV:\r\npar->chip = S3_SAVAGE_MX;\r\nsnprintf(info->fix.id, 16, "Savage/IX-MV");\r\nbreak;\r\ncase FB_ACCEL_SAVAGE_IX:\r\npar->chip = S3_SAVAGE_MX;\r\nsnprintf(info->fix.id, 16, "Savage/IX");\r\nbreak;\r\ncase FB_ACCEL_PROSAVAGE_PM:\r\npar->chip = S3_PROSAVAGE;\r\nsnprintf(info->fix.id, 16, "ProSavagePM");\r\nbreak;\r\ncase FB_ACCEL_PROSAVAGE_KM:\r\npar->chip = S3_PROSAVAGE;\r\nsnprintf(info->fix.id, 16, "ProSavageKM");\r\nbreak;\r\ncase FB_ACCEL_S3TWISTER_P:\r\npar->chip = S3_TWISTER;\r\nsnprintf(info->fix.id, 16, "TwisterP");\r\nbreak;\r\ncase FB_ACCEL_S3TWISTER_K:\r\npar->chip = S3_TWISTER;\r\nsnprintf(info->fix.id, 16, "TwisterK");\r\nbreak;\r\ncase FB_ACCEL_PROSAVAGE_DDR:\r\npar->chip = S3_PROSAVAGEDDR;\r\nsnprintf(info->fix.id, 16, "ProSavageDDR");\r\nbreak;\r\ncase FB_ACCEL_PROSAVAGE_DDRK:\r\npar->chip = S3_PROSAVAGEDDR;\r\nsnprintf(info->fix.id, 16, "ProSavage8");\r\nbreak;\r\n}\r\nif (S3_SAVAGE3D_SERIES(par->chip)) {\r\npar->SavageWaitIdle = savage3D_waitidle;\r\npar->SavageWaitFifo = savage3D_waitfifo;\r\n} else if (S3_SAVAGE4_SERIES(par->chip) ||\r\nS3_SUPERSAVAGE == par->chip) {\r\npar->SavageWaitIdle = savage4_waitidle;\r\npar->SavageWaitFifo = savage4_waitfifo;\r\n} else {\r\npar->SavageWaitIdle = savage2000_waitidle;\r\npar->SavageWaitFifo = savage2000_waitfifo;\r\n}\r\ninfo->var.nonstd = 0;\r\ninfo->var.activate = FB_ACTIVATE_NOW;\r\ninfo->var.width = -1;\r\ninfo->var.height = -1;\r\ninfo->var.accel_flags = 0;\r\ninfo->fbops = &savagefb_ops;\r\ninfo->flags = FBINFO_DEFAULT |\r\nFBINFO_HWACCEL_YPAN |\r\nFBINFO_HWACCEL_XPAN;\r\ninfo->pseudo_palette = par->pseudo_palette;\r\n#if defined(CONFIG_FB_SAVAGE_ACCEL)\r\ninfo->pixmap.addr = kcalloc(8, 1024, GFP_KERNEL);\r\nerr = -ENOMEM;\r\nif (info->pixmap.addr) {\r\ninfo->pixmap.size = 8*1024;\r\ninfo->pixmap.scan_align = 4;\r\ninfo->pixmap.buf_align = 4;\r\ninfo->pixmap.access_align = 32;\r\nerr = fb_alloc_cmap(&info->cmap, NR_PALETTE, 0);\r\nif (!err)\r\ninfo->flags |= FBINFO_HWACCEL_COPYAREA |\r\nFBINFO_HWACCEL_FILLRECT |\r\nFBINFO_HWACCEL_IMAGEBLIT;\r\n}\r\n#endif\r\nreturn err;\r\n}\r\nstatic int savagefb_probe(struct pci_dev *dev, const struct pci_device_id *id)\r\n{\r\nstruct fb_info *info;\r\nstruct savagefb_par *par;\r\nu_int h_sync, v_sync;\r\nint err, lpitch;\r\nint video_len;\r\nDBG("savagefb_probe");\r\ninfo = framebuffer_alloc(sizeof(struct savagefb_par), &dev->dev);\r\nif (!info)\r\nreturn -ENOMEM;\r\npar = info->par;\r\nmutex_init(&par->open_lock);\r\nerr = pci_enable_device(dev);\r\nif (err)\r\ngoto failed_enable;\r\nif ((err = pci_request_regions(dev, "savagefb"))) {\r\nprintk(KERN_ERR "cannot request PCI regions\n");\r\ngoto failed_enable;\r\n}\r\nerr = -ENOMEM;\r\nif ((err = savage_init_fb_info(info, dev, id)))\r\ngoto failed_init;\r\nerr = savage_map_mmio(info);\r\nif (err)\r\ngoto failed_mmio;\r\nvideo_len = savage_init_hw(par);\r\nif (video_len < 0) {\r\nerr = video_len;\r\ngoto failed_mmio;\r\n}\r\nerr = savage_map_video(info, video_len);\r\nif (err)\r\ngoto failed_video;\r\nINIT_LIST_HEAD(&info->modelist);\r\n#if defined(CONFIG_FB_SAVAGE_I2C)\r\nsavagefb_create_i2c_busses(info);\r\nsavagefb_probe_i2c_connector(info, &par->edid);\r\nfb_edid_to_monspecs(par->edid, &info->monspecs);\r\nkfree(par->edid);\r\nfb_videomode_to_modelist(info->monspecs.modedb,\r\ninfo->monspecs.modedb_len,\r\n&info->modelist);\r\n#endif\r\ninfo->var = savagefb_var800x600x8;\r\nif (par->SavagePanelWidth) {\r\nstruct fb_videomode cvt_mode;\r\nmemset(&cvt_mode, 0, sizeof(cvt_mode));\r\ncvt_mode.xres = par->SavagePanelWidth;\r\ncvt_mode.yres = par->SavagePanelHeight;\r\ncvt_mode.refresh = 60;\r\nif (fb_find_mode_cvt(&cvt_mode, 0, 0))\r\nprintk(KERN_WARNING "No CVT mode found for panel\n");\r\nelse if (fb_find_mode(&info->var, info, NULL, NULL, 0,\r\n&cvt_mode, 0) != 3)\r\ninfo->var = savagefb_var800x600x8;\r\n}\r\nif (mode_option) {\r\nfb_find_mode(&info->var, info, mode_option,\r\ninfo->monspecs.modedb, info->monspecs.modedb_len,\r\nNULL, 8);\r\n} else if (info->monspecs.modedb != NULL) {\r\nconst struct fb_videomode *mode;\r\nmode = fb_find_best_display(&info->monspecs, &info->modelist);\r\nsavage_update_var(&info->var, mode);\r\n}\r\nlpitch = info->var.xres_virtual*((info->var.bits_per_pixel + 7) >> 3);\r\ninfo->var.yres_virtual = info->fix.smem_len/lpitch;\r\nif (info->var.yres_virtual < info->var.yres) {\r\nerr = -ENOMEM;\r\ngoto failed;\r\n}\r\n#if defined(CONFIG_FB_SAVAGE_ACCEL)\r\nif (info->var.yres_virtual > 0x1000)\r\ninfo->var.yres_virtual = 0x1000;\r\nif (info->var.xres_virtual > 0x1000)\r\ninfo->var.xres_virtual = 0x1000;\r\n#endif\r\nsavagefb_check_var(&info->var, info);\r\nsavagefb_set_fix(info);\r\nh_sync = 1953125000 / info->var.pixclock;\r\nh_sync = h_sync * 512 / (info->var.xres + info->var.left_margin +\r\ninfo->var.right_margin +\r\ninfo->var.hsync_len);\r\nv_sync = h_sync / (info->var.yres + info->var.upper_margin +\r\ninfo->var.lower_margin + info->var.vsync_len);\r\nprintk(KERN_INFO "savagefb v" SAVAGEFB_VERSION ": "\r\n"%dkB VRAM, using %dx%d, %d.%03dkHz, %dHz\n",\r\ninfo->fix.smem_len >> 10,\r\ninfo->var.xres, info->var.yres,\r\nh_sync / 1000, h_sync % 1000, v_sync);\r\nfb_destroy_modedb(info->monspecs.modedb);\r\ninfo->monspecs.modedb = NULL;\r\nerr = register_framebuffer(info);\r\nif (err < 0)\r\ngoto failed;\r\nprintk(KERN_INFO "fb: S3 %s frame buffer device\n",\r\ninfo->fix.id);\r\npci_set_drvdata(dev, info);\r\nreturn 0;\r\nfailed:\r\n#ifdef CONFIG_FB_SAVAGE_I2C\r\nsavagefb_delete_i2c_busses(info);\r\n#endif\r\nfb_alloc_cmap(&info->cmap, 0, 0);\r\nsavage_unmap_video(info);\r\nfailed_video:\r\nsavage_unmap_mmio(info);\r\nfailed_mmio:\r\nkfree(info->pixmap.addr);\r\nfailed_init:\r\npci_release_regions(dev);\r\nfailed_enable:\r\nframebuffer_release(info);\r\nreturn err;\r\n}\r\nstatic void savagefb_remove(struct pci_dev *dev)\r\n{\r\nstruct fb_info *info = pci_get_drvdata(dev);\r\nDBG("savagefb_remove");\r\nif (info) {\r\nif (unregister_framebuffer(info))\r\nprintk(KERN_WARNING "savagefb: danger danger! "\r\n"Oopsen imminent!\n");\r\n#ifdef CONFIG_FB_SAVAGE_I2C\r\nsavagefb_delete_i2c_busses(info);\r\n#endif\r\nfb_alloc_cmap(&info->cmap, 0, 0);\r\nsavage_unmap_video(info);\r\nsavage_unmap_mmio(info);\r\nkfree(info->pixmap.addr);\r\npci_release_regions(dev);\r\nframebuffer_release(info);\r\n}\r\n}\r\nstatic int savagefb_suspend(struct pci_dev *dev, pm_message_t mesg)\r\n{\r\nstruct fb_info *info = pci_get_drvdata(dev);\r\nstruct savagefb_par *par = info->par;\r\nDBG("savagefb_suspend");\r\nif (mesg.event == PM_EVENT_PRETHAW)\r\nmesg.event = PM_EVENT_FREEZE;\r\npar->pm_state = mesg.event;\r\ndev->dev.power.power_state = mesg;\r\nif (mesg.event == PM_EVENT_FREEZE)\r\nreturn 0;\r\nconsole_lock();\r\nfb_set_suspend(info, 1);\r\nif (info->fbops->fb_sync)\r\ninfo->fbops->fb_sync(info);\r\nsavagefb_blank(FB_BLANK_POWERDOWN, info);\r\nsavage_set_default_par(par, &par->save);\r\nsavage_disable_mmio(par);\r\npci_save_state(dev);\r\npci_disable_device(dev);\r\npci_set_power_state(dev, pci_choose_state(dev, mesg));\r\nconsole_unlock();\r\nreturn 0;\r\n}\r\nstatic int savagefb_resume(struct pci_dev* dev)\r\n{\r\nstruct fb_info *info = pci_get_drvdata(dev);\r\nstruct savagefb_par *par = info->par;\r\nint cur_state = par->pm_state;\r\nDBG("savage_resume");\r\npar->pm_state = PM_EVENT_ON;\r\nif (cur_state == PM_EVENT_FREEZE) {\r\npci_set_power_state(dev, PCI_D0);\r\nreturn 0;\r\n}\r\nconsole_lock();\r\npci_set_power_state(dev, PCI_D0);\r\npci_restore_state(dev);\r\nif (pci_enable_device(dev))\r\nDBG("err");\r\npci_set_master(dev);\r\nsavage_enable_mmio(par);\r\nsavage_init_hw(par);\r\nsavagefb_set_par(info);\r\nfb_set_suspend(info, 0);\r\nsavagefb_blank(FB_BLANK_UNBLANK, info);\r\nconsole_unlock();\r\nreturn 0;\r\n}\r\nstatic void __exit savage_done(void)\r\n{\r\nDBG("savage_done");\r\npci_unregister_driver(&savagefb_driver);\r\n}\r\nstatic int __init savagefb_setup(char *options)\r\n{\r\n#ifndef MODULE\r\nchar *this_opt;\r\nif (!options || !*options)\r\nreturn 0;\r\nwhile ((this_opt = strsep(&options, ",")) != NULL) {\r\nmode_option = this_opt;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int __init savagefb_init(void)\r\n{\r\nchar *option;\r\nDBG("savagefb_init");\r\nif (fb_get_options("savagefb", &option))\r\nreturn -ENODEV;\r\nsavagefb_setup(option);\r\nreturn pci_register_driver(&savagefb_driver);\r\n}
