static int bfd_error(const char *string)\r\n{\r\nconst char *errmsg;\r\nerrmsg = bfd_errmsg(bfd_get_error());\r\nfflush(stdout);\r\nif (string)\r\npr_debug("%s: %s\n", string, errmsg);\r\nelse\r\npr_debug("%s\n", errmsg);\r\nreturn -1;\r\n}\r\nstatic int slurp_symtab(bfd *abfd, struct a2l_data *a2l)\r\n{\r\nlong storage;\r\nlong symcount;\r\nasymbol **syms;\r\nbfd_boolean dynamic = FALSE;\r\nif ((bfd_get_file_flags(abfd) & HAS_SYMS) == 0)\r\nreturn bfd_error(bfd_get_filename(abfd));\r\nstorage = bfd_get_symtab_upper_bound(abfd);\r\nif (storage == 0L) {\r\nstorage = bfd_get_dynamic_symtab_upper_bound(abfd);\r\ndynamic = TRUE;\r\n}\r\nif (storage < 0L)\r\nreturn bfd_error(bfd_get_filename(abfd));\r\nsyms = malloc(storage);\r\nif (dynamic)\r\nsymcount = bfd_canonicalize_dynamic_symtab(abfd, syms);\r\nelse\r\nsymcount = bfd_canonicalize_symtab(abfd, syms);\r\nif (symcount < 0) {\r\nfree(syms);\r\nreturn bfd_error(bfd_get_filename(abfd));\r\n}\r\na2l->syms = syms;\r\nreturn 0;\r\n}\r\nstatic void find_address_in_section(bfd *abfd, asection *section, void *data)\r\n{\r\nbfd_vma pc, vma;\r\nbfd_size_type size;\r\nstruct a2l_data *a2l = data;\r\nif (a2l->found)\r\nreturn;\r\nif ((bfd_get_section_flags(abfd, section) & SEC_ALLOC) == 0)\r\nreturn;\r\npc = a2l->addr;\r\nvma = bfd_get_section_vma(abfd, section);\r\nsize = bfd_get_section_size(section);\r\nif (pc < vma || pc >= vma + size)\r\nreturn;\r\na2l->found = bfd_find_nearest_line(abfd, section, a2l->syms, pc - vma,\r\n&a2l->filename, &a2l->funcname,\r\n&a2l->line);\r\n}\r\nstatic struct a2l_data *addr2line_init(const char *path)\r\n{\r\nbfd *abfd;\r\nstruct a2l_data *a2l = NULL;\r\nabfd = bfd_openr(path, NULL);\r\nif (abfd == NULL)\r\nreturn NULL;\r\nif (!bfd_check_format(abfd, bfd_object))\r\ngoto out;\r\na2l = zalloc(sizeof(*a2l));\r\nif (a2l == NULL)\r\ngoto out;\r\na2l->abfd = abfd;\r\na2l->input = strdup(path);\r\nif (a2l->input == NULL)\r\ngoto out;\r\nif (slurp_symtab(abfd, a2l))\r\ngoto out;\r\nreturn a2l;\r\nout:\r\nif (a2l) {\r\nzfree((char **)&a2l->input);\r\nfree(a2l);\r\n}\r\nbfd_close(abfd);\r\nreturn NULL;\r\n}\r\nstatic void addr2line_cleanup(struct a2l_data *a2l)\r\n{\r\nif (a2l->abfd)\r\nbfd_close(a2l->abfd);\r\nzfree((char **)&a2l->input);\r\nzfree(&a2l->syms);\r\nfree(a2l);\r\n}\r\nstatic int addr2line(const char *dso_name, u64 addr,\r\nchar **file, unsigned int *line, struct dso *dso)\r\n{\r\nint ret = 0;\r\nstruct a2l_data *a2l = dso->a2l;\r\nif (!a2l) {\r\ndso->a2l = addr2line_init(dso_name);\r\na2l = dso->a2l;\r\n}\r\nif (a2l == NULL) {\r\npr_warning("addr2line_init failed for %s\n", dso_name);\r\nreturn 0;\r\n}\r\na2l->addr = addr;\r\na2l->found = false;\r\nbfd_map_over_sections(a2l->abfd, find_address_in_section, a2l);\r\nif (a2l->found && a2l->filename) {\r\n*file = strdup(a2l->filename);\r\n*line = a2l->line;\r\nif (*file)\r\nret = 1;\r\n}\r\nreturn ret;\r\n}\r\nvoid dso__free_a2l(struct dso *dso)\r\n{\r\nstruct a2l_data *a2l = dso->a2l;\r\nif (!a2l)\r\nreturn;\r\naddr2line_cleanup(a2l);\r\ndso->a2l = NULL;\r\n}\r\nstatic int addr2line(const char *dso_name, u64 addr,\r\nchar **file, unsigned int *line_nr,\r\nstruct dso *dso __maybe_unused)\r\n{\r\nFILE *fp;\r\nchar cmd[PATH_MAX];\r\nchar *filename = NULL;\r\nsize_t len;\r\nchar *sep;\r\nint ret = 0;\r\nscnprintf(cmd, sizeof(cmd), "addr2line -e %s %016"PRIx64,\r\ndso_name, addr);\r\nfp = popen(cmd, "r");\r\nif (fp == NULL) {\r\npr_warning("popen failed for %s\n", dso_name);\r\nreturn 0;\r\n}\r\nif (getline(&filename, &len, fp) < 0 || !len) {\r\npr_warning("addr2line has no output for %s\n", dso_name);\r\ngoto out;\r\n}\r\nsep = strchr(filename, '\n');\r\nif (sep)\r\n*sep = '\0';\r\nif (!strcmp(filename, "??:0")) {\r\npr_debug("no debugging info in %s\n", dso_name);\r\nfree(filename);\r\ngoto out;\r\n}\r\nsep = strchr(filename, ':');\r\nif (sep) {\r\n*sep++ = '\0';\r\n*file = filename;\r\n*line_nr = strtoul(sep, NULL, 0);\r\nret = 1;\r\n}\r\nout:\r\npclose(fp);\r\nreturn ret;\r\n}\r\nvoid dso__free_a2l(struct dso *dso __maybe_unused)\r\n{\r\n}\r\nchar *get_srcline(struct dso *dso, u64 addr, struct symbol *sym,\r\nbool show_sym)\r\n{\r\nchar *file = NULL;\r\nunsigned line = 0;\r\nchar *srcline;\r\nconst char *dso_name;\r\nif (!dso->has_srcline)\r\ngoto out;\r\nif (dso->symsrc_filename)\r\ndso_name = dso->symsrc_filename;\r\nelse\r\ndso_name = dso->long_name;\r\nif (dso_name[0] == '[')\r\ngoto out;\r\nif (!strncmp(dso_name, "/tmp/perf-", 10))\r\ngoto out;\r\nif (!addr2line(dso_name, addr, &file, &line, dso))\r\ngoto out;\r\nif (asprintf(&srcline, "%s:%u", basename(file), line) < 0) {\r\nfree(file);\r\ngoto out;\r\n}\r\ndso->a2l_fails = 0;\r\nfree(file);\r\nreturn srcline;\r\nout:\r\nif (dso->a2l_fails && ++dso->a2l_fails > A2L_FAIL_LIMIT) {\r\ndso->has_srcline = 0;\r\ndso__free_a2l(dso);\r\n}\r\nif (sym) {\r\nif (asprintf(&srcline, "%s+%" PRIu64, show_sym ? sym->name : "",\r\naddr - sym->start) < 0)\r\nreturn SRCLINE_UNKNOWN;\r\n} else if (asprintf(&srcline, "%s[%" PRIx64 "]", dso->short_name, addr) < 0)\r\nreturn SRCLINE_UNKNOWN;\r\nreturn srcline;\r\n}\r\nvoid free_srcline(char *srcline)\r\n{\r\nif (srcline && strcmp(srcline, SRCLINE_UNKNOWN) != 0)\r\nfree(srcline);\r\n}
