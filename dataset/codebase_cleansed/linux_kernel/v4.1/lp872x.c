static int lp872x_read_byte(struct lp872x *lp, u8 addr, u8 *data)\r\n{\r\nint ret;\r\nunsigned int val;\r\nret = regmap_read(lp->regmap, addr, &val);\r\nif (ret < 0) {\r\ndev_err(lp->dev, "failed to read 0x%.2x\n", addr);\r\nreturn ret;\r\n}\r\n*data = (u8)val;\r\nreturn 0;\r\n}\r\nstatic inline int lp872x_write_byte(struct lp872x *lp, u8 addr, u8 data)\r\n{\r\nreturn regmap_write(lp->regmap, addr, data);\r\n}\r\nstatic inline int lp872x_update_bits(struct lp872x *lp, u8 addr,\r\nunsigned int mask, u8 data)\r\n{\r\nreturn regmap_update_bits(lp->regmap, addr, mask, data);\r\n}\r\nstatic int lp872x_get_timestep_usec(struct lp872x *lp)\r\n{\r\nenum lp872x_id chip = lp->chipid;\r\nu8 val, mask, shift;\r\nint *time_usec, size, ret;\r\nint lp8720_time_usec[] = { 25, 50 };\r\nint lp8725_time_usec[] = { 32, 64, 128, 256 };\r\nswitch (chip) {\r\ncase LP8720:\r\nmask = LP8720_TIMESTEP_M;\r\nshift = LP8720_TIMESTEP_S;\r\ntime_usec = &lp8720_time_usec[0];\r\nsize = ARRAY_SIZE(lp8720_time_usec);\r\nbreak;\r\ncase LP8725:\r\nmask = LP8725_TIMESTEP_M;\r\nshift = LP8725_TIMESTEP_S;\r\ntime_usec = &lp8725_time_usec[0];\r\nsize = ARRAY_SIZE(lp8725_time_usec);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = lp872x_read_byte(lp, LP872X_GENERAL_CFG, &val);\r\nif (ret)\r\nreturn ret;\r\nval = (val & mask) >> shift;\r\nif (val >= size)\r\nreturn -EINVAL;\r\nreturn *(time_usec + val);\r\n}\r\nstatic int lp872x_regulator_enable_time(struct regulator_dev *rdev)\r\n{\r\nstruct lp872x *lp = rdev_get_drvdata(rdev);\r\nenum lp872x_regulator_id rid = rdev_get_id(rdev);\r\nint time_step_us = lp872x_get_timestep_usec(lp);\r\nint ret;\r\nu8 addr, val;\r\nif (time_step_us < 0)\r\nreturn time_step_us;\r\nswitch (rid) {\r\ncase LP8720_ID_LDO1 ... LP8720_ID_BUCK:\r\naddr = LP872X_LDO1_VOUT + rid;\r\nbreak;\r\ncase LP8725_ID_LDO1 ... LP8725_ID_BUCK1:\r\naddr = LP872X_LDO1_VOUT + rid - LP8725_ID_BASE;\r\nbreak;\r\ncase LP8725_ID_BUCK2:\r\naddr = LP8725_BUCK2_VOUT1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = lp872x_read_byte(lp, addr, &val);\r\nif (ret)\r\nreturn ret;\r\nval = (val & LP872X_START_DELAY_M) >> LP872X_START_DELAY_S;\r\nreturn val > MAX_DELAY ? 0 : val * time_step_us;\r\n}\r\nstatic void lp872x_set_dvs(struct lp872x *lp, enum lp872x_dvs_sel dvs_sel,\r\nint gpio)\r\n{\r\nenum lp872x_dvs_state state;\r\nstate = dvs_sel == SEL_V1 ? DVS_HIGH : DVS_LOW;\r\ngpio_set_value(gpio, state);\r\nlp->dvs_pin = state;\r\n}\r\nstatic u8 lp872x_select_buck_vout_addr(struct lp872x *lp,\r\nenum lp872x_regulator_id buck)\r\n{\r\nu8 val, addr;\r\nif (lp872x_read_byte(lp, LP872X_GENERAL_CFG, &val))\r\nreturn 0;\r\nswitch (buck) {\r\ncase LP8720_ID_BUCK:\r\nif (val & LP8720_EXT_DVS_M) {\r\naddr = (lp->dvs_pin == DVS_HIGH) ?\r\nLP8720_BUCK_VOUT1 : LP8720_BUCK_VOUT2;\r\n} else {\r\nif (lp872x_read_byte(lp, LP8720_ENABLE, &val))\r\nreturn 0;\r\naddr = val & LP8720_DVS_SEL_M ?\r\nLP8720_BUCK_VOUT1 : LP8720_BUCK_VOUT2;\r\n}\r\nbreak;\r\ncase LP8725_ID_BUCK1:\r\nif (val & LP8725_DVS1_M)\r\naddr = LP8725_BUCK1_VOUT1;\r\nelse\r\naddr = (lp->dvs_pin == DVS_HIGH) ?\r\nLP8725_BUCK1_VOUT1 : LP8725_BUCK1_VOUT2;\r\nbreak;\r\ncase LP8725_ID_BUCK2:\r\naddr = val & LP8725_DVS2_M ?\r\nLP8725_BUCK2_VOUT1 : LP8725_BUCK2_VOUT2;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn addr;\r\n}\r\nstatic bool lp872x_is_valid_buck_addr(u8 addr)\r\n{\r\nswitch (addr) {\r\ncase LP8720_BUCK_VOUT1:\r\ncase LP8720_BUCK_VOUT2:\r\ncase LP8725_BUCK1_VOUT1:\r\ncase LP8725_BUCK1_VOUT2:\r\ncase LP8725_BUCK2_VOUT1:\r\ncase LP8725_BUCK2_VOUT2:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int lp872x_buck_set_voltage_sel(struct regulator_dev *rdev,\r\nunsigned selector)\r\n{\r\nstruct lp872x *lp = rdev_get_drvdata(rdev);\r\nenum lp872x_regulator_id buck = rdev_get_id(rdev);\r\nu8 addr, mask = LP872X_VOUT_M;\r\nstruct lp872x_dvs *dvs = lp->pdata ? lp->pdata->dvs : NULL;\r\nif (dvs && gpio_is_valid(dvs->gpio))\r\nlp872x_set_dvs(lp, dvs->vsel, dvs->gpio);\r\naddr = lp872x_select_buck_vout_addr(lp, buck);\r\nif (!lp872x_is_valid_buck_addr(addr))\r\nreturn -EINVAL;\r\nreturn lp872x_update_bits(lp, addr, mask, selector);\r\n}\r\nstatic int lp872x_buck_get_voltage_sel(struct regulator_dev *rdev)\r\n{\r\nstruct lp872x *lp = rdev_get_drvdata(rdev);\r\nenum lp872x_regulator_id buck = rdev_get_id(rdev);\r\nu8 addr, val;\r\nint ret;\r\naddr = lp872x_select_buck_vout_addr(lp, buck);\r\nif (!lp872x_is_valid_buck_addr(addr))\r\nreturn -EINVAL;\r\nret = lp872x_read_byte(lp, addr, &val);\r\nif (ret)\r\nreturn ret;\r\nreturn val & LP872X_VOUT_M;\r\n}\r\nstatic int lp8725_buck_set_current_limit(struct regulator_dev *rdev,\r\nint min_uA, int max_uA)\r\n{\r\nstruct lp872x *lp = rdev_get_drvdata(rdev);\r\nenum lp872x_regulator_id buck = rdev_get_id(rdev);\r\nint i;\r\nu8 addr;\r\nswitch (buck) {\r\ncase LP8725_ID_BUCK1:\r\naddr = LP8725_BUCK1_VOUT2;\r\nbreak;\r\ncase LP8725_ID_BUCK2:\r\naddr = LP8725_BUCK2_VOUT2;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nfor (i = ARRAY_SIZE(lp8725_buck_uA) - 1; i >= 0; i--) {\r\nif (lp8725_buck_uA[i] >= min_uA &&\r\nlp8725_buck_uA[i] <= max_uA)\r\nreturn lp872x_update_bits(lp, addr,\r\nLP8725_BUCK_CL_M,\r\ni << LP8725_BUCK_CL_S);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int lp8725_buck_get_current_limit(struct regulator_dev *rdev)\r\n{\r\nstruct lp872x *lp = rdev_get_drvdata(rdev);\r\nenum lp872x_regulator_id buck = rdev_get_id(rdev);\r\nu8 addr, val;\r\nint ret;\r\nswitch (buck) {\r\ncase LP8725_ID_BUCK1:\r\naddr = LP8725_BUCK1_VOUT2;\r\nbreak;\r\ncase LP8725_ID_BUCK2:\r\naddr = LP8725_BUCK2_VOUT2;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = lp872x_read_byte(lp, addr, &val);\r\nif (ret)\r\nreturn ret;\r\nval = (val & LP8725_BUCK_CL_M) >> LP8725_BUCK_CL_S;\r\nreturn (val < ARRAY_SIZE(lp8725_buck_uA)) ?\r\nlp8725_buck_uA[val] : -EINVAL;\r\n}\r\nstatic int lp872x_buck_set_mode(struct regulator_dev *rdev, unsigned int mode)\r\n{\r\nstruct lp872x *lp = rdev_get_drvdata(rdev);\r\nenum lp872x_regulator_id buck = rdev_get_id(rdev);\r\nu8 addr, mask, shift, val;\r\nswitch (buck) {\r\ncase LP8720_ID_BUCK:\r\naddr = LP8720_BUCK_VOUT2;\r\nmask = LP8720_BUCK_FPWM_M;\r\nshift = LP8720_BUCK_FPWM_S;\r\nbreak;\r\ncase LP8725_ID_BUCK1:\r\naddr = LP8725_BUCK_CTRL;\r\nmask = LP8725_BUCK1_FPWM_M;\r\nshift = LP8725_BUCK1_FPWM_S;\r\nbreak;\r\ncase LP8725_ID_BUCK2:\r\naddr = LP8725_BUCK_CTRL;\r\nmask = LP8725_BUCK2_FPWM_M;\r\nshift = LP8725_BUCK2_FPWM_S;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (mode == REGULATOR_MODE_FAST)\r\nval = LP872X_FORCE_PWM << shift;\r\nelse if (mode == REGULATOR_MODE_NORMAL)\r\nval = LP872X_AUTO_PWM << shift;\r\nelse\r\nreturn -EINVAL;\r\nreturn lp872x_update_bits(lp, addr, mask, val);\r\n}\r\nstatic unsigned int lp872x_buck_get_mode(struct regulator_dev *rdev)\r\n{\r\nstruct lp872x *lp = rdev_get_drvdata(rdev);\r\nenum lp872x_regulator_id buck = rdev_get_id(rdev);\r\nu8 addr, mask, val;\r\nint ret;\r\nswitch (buck) {\r\ncase LP8720_ID_BUCK:\r\naddr = LP8720_BUCK_VOUT2;\r\nmask = LP8720_BUCK_FPWM_M;\r\nbreak;\r\ncase LP8725_ID_BUCK1:\r\naddr = LP8725_BUCK_CTRL;\r\nmask = LP8725_BUCK1_FPWM_M;\r\nbreak;\r\ncase LP8725_ID_BUCK2:\r\naddr = LP8725_BUCK_CTRL;\r\nmask = LP8725_BUCK2_FPWM_M;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = lp872x_read_byte(lp, addr, &val);\r\nif (ret)\r\nreturn ret;\r\nreturn val & mask ? REGULATOR_MODE_FAST : REGULATOR_MODE_NORMAL;\r\n}\r\nstatic int lp872x_init_dvs(struct lp872x *lp)\r\n{\r\nint ret, gpio;\r\nstruct lp872x_dvs *dvs = lp->pdata ? lp->pdata->dvs : NULL;\r\nenum lp872x_dvs_state pinstate;\r\nu8 mask[] = { LP8720_EXT_DVS_M, LP8725_DVS1_M | LP8725_DVS2_M };\r\nu8 default_dvs_mode[] = { LP8720_DEFAULT_DVS, LP8725_DEFAULT_DVS };\r\nif (!dvs)\r\ngoto set_default_dvs_mode;\r\ngpio = dvs->gpio;\r\nif (!gpio_is_valid(gpio)) {\r\ndev_warn(lp->dev, "invalid gpio: %d\n", gpio);\r\ngoto set_default_dvs_mode;\r\n}\r\npinstate = dvs->init_state;\r\nret = devm_gpio_request_one(lp->dev, gpio, pinstate, "LP872X DVS");\r\nif (ret) {\r\ndev_err(lp->dev, "gpio request err: %d\n", ret);\r\nreturn ret;\r\n}\r\nlp->dvs_pin = pinstate;\r\nlp->dvs_gpio = gpio;\r\nreturn 0;\r\nset_default_dvs_mode:\r\nreturn lp872x_update_bits(lp, LP872X_GENERAL_CFG, mask[lp->chipid],\r\ndefault_dvs_mode[lp->chipid]);\r\n}\r\nstatic int lp872x_config(struct lp872x *lp)\r\n{\r\nstruct lp872x_platform_data *pdata = lp->pdata;\r\nint ret;\r\nif (!pdata || !pdata->update_config)\r\ngoto init_dvs;\r\nret = lp872x_write_byte(lp, LP872X_GENERAL_CFG, pdata->general_config);\r\nif (ret)\r\nreturn ret;\r\ninit_dvs:\r\nreturn lp872x_init_dvs(lp);\r\n}\r\nstatic struct regulator_init_data\r\n*lp872x_find_regulator_init_data(int id, struct lp872x *lp)\r\n{\r\nstruct lp872x_platform_data *pdata = lp->pdata;\r\nint i;\r\nif (!pdata)\r\nreturn NULL;\r\nfor (i = 0; i < lp->num_regulators; i++) {\r\nif (pdata->regulator_data[i].id == id)\r\nreturn pdata->regulator_data[i].init_data;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int lp872x_regulator_register(struct lp872x *lp)\r\n{\r\nstruct regulator_desc *desc;\r\nstruct regulator_config cfg = { };\r\nstruct regulator_dev *rdev;\r\nint i;\r\nfor (i = 0; i < lp->num_regulators; i++) {\r\ndesc = (lp->chipid == LP8720) ? &lp8720_regulator_desc[i] :\r\n&lp8725_regulator_desc[i];\r\ncfg.dev = lp->dev;\r\ncfg.init_data = lp872x_find_regulator_init_data(desc->id, lp);\r\ncfg.driver_data = lp;\r\ncfg.regmap = lp->regmap;\r\nrdev = devm_regulator_register(lp->dev, desc, &cfg);\r\nif (IS_ERR(rdev)) {\r\ndev_err(lp->dev, "regulator register err");\r\nreturn PTR_ERR(rdev);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic struct lp872x_platform_data\r\n*lp872x_populate_pdata_from_dt(struct device *dev, enum lp872x_id which)\r\n{\r\nstruct device_node *np = dev->of_node;\r\nstruct lp872x_platform_data *pdata;\r\nstruct of_regulator_match *match;\r\nint num_matches;\r\nint count;\r\nint i;\r\nu8 dvs_state;\r\npdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\ngoto out;\r\nof_property_read_u8(np, "ti,general-config", &pdata->general_config);\r\nif (of_find_property(np, "ti,update-config", NULL))\r\npdata->update_config = true;\r\npdata->dvs = devm_kzalloc(dev, sizeof(struct lp872x_dvs), GFP_KERNEL);\r\nif (!pdata->dvs)\r\ngoto out;\r\npdata->dvs->gpio = of_get_named_gpio(np, "ti,dvs-gpio", 0);\r\nof_property_read_u8(np, "ti,dvs-vsel", (u8 *)&pdata->dvs->vsel);\r\nof_property_read_u8(np, "ti,dvs-state", &dvs_state);\r\npdata->dvs->init_state = dvs_state ? DVS_HIGH : DVS_LOW;\r\nif (of_get_child_count(np) == 0)\r\ngoto out;\r\nswitch (which) {\r\ncase LP8720:\r\nmatch = lp8720_matches;\r\nnum_matches = ARRAY_SIZE(lp8720_matches);\r\nbreak;\r\ncase LP8725:\r\nmatch = lp8725_matches;\r\nnum_matches = ARRAY_SIZE(lp8725_matches);\r\nbreak;\r\ndefault:\r\ngoto out;\r\n}\r\ncount = of_regulator_match(dev, np, match, num_matches);\r\nif (count <= 0)\r\ngoto out;\r\nfor (i = 0; i < num_matches; i++) {\r\npdata->regulator_data[i].id =\r\n(enum lp872x_regulator_id)match[i].driver_data;\r\npdata->regulator_data[i].init_data = match[i].init_data;\r\n}\r\nout:\r\nreturn pdata;\r\n}\r\nstatic struct lp872x_platform_data\r\n*lp872x_populate_pdata_from_dt(struct device *dev, enum lp872x_id which)\r\n{\r\nreturn NULL;\r\n}\r\nstatic int lp872x_probe(struct i2c_client *cl, const struct i2c_device_id *id)\r\n{\r\nstruct lp872x *lp;\r\nint ret;\r\nconst int lp872x_num_regulators[] = {\r\n[LP8720] = LP8720_NUM_REGULATORS,\r\n[LP8725] = LP8725_NUM_REGULATORS,\r\n};\r\nif (cl->dev.of_node)\r\ncl->dev.platform_data = lp872x_populate_pdata_from_dt(&cl->dev,\r\n(enum lp872x_id)id->driver_data);\r\nlp = devm_kzalloc(&cl->dev, sizeof(struct lp872x), GFP_KERNEL);\r\nif (!lp)\r\nreturn -ENOMEM;\r\nlp->num_regulators = lp872x_num_regulators[id->driver_data];\r\nlp->regmap = devm_regmap_init_i2c(cl, &lp872x_regmap_config);\r\nif (IS_ERR(lp->regmap)) {\r\nret = PTR_ERR(lp->regmap);\r\ndev_err(&cl->dev, "regmap init i2c err: %d\n", ret);\r\nreturn ret;\r\n}\r\nlp->dev = &cl->dev;\r\nlp->pdata = dev_get_platdata(&cl->dev);\r\nlp->chipid = id->driver_data;\r\ni2c_set_clientdata(cl, lp);\r\nret = lp872x_config(lp);\r\nif (ret)\r\nreturn ret;\r\nreturn lp872x_regulator_register(lp);\r\n}
