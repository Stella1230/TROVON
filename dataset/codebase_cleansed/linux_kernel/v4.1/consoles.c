static int show_console_dev(struct seq_file *m, void *v)\r\n{\r\nstatic const struct {\r\nshort flag;\r\nchar name;\r\n} con_flags[] = {\r\n{ CON_ENABLED, 'E' },\r\n{ CON_CONSDEV, 'C' },\r\n{ CON_BOOT, 'B' },\r\n{ CON_PRINTBUFFER, 'p' },\r\n{ CON_BRL, 'b' },\r\n{ CON_ANYTIME, 'a' },\r\n};\r\nchar flags[ARRAY_SIZE(con_flags) + 1];\r\nstruct console *con = v;\r\nunsigned int a;\r\ndev_t dev = 0;\r\nif (con->device) {\r\nconst struct tty_driver *driver;\r\nint index;\r\ndriver = con->device(con, &index);\r\nif (driver) {\r\ndev = MKDEV(driver->major, driver->minor_start);\r\ndev += index;\r\n}\r\n}\r\nfor (a = 0; a < ARRAY_SIZE(con_flags); a++)\r\nflags[a] = (con->flags & con_flags[a].flag) ?\r\ncon_flags[a].name : ' ';\r\nflags[a] = 0;\r\nseq_setwidth(m, 21 - 1);\r\nseq_printf(m, "%s%d", con->name, con->index);\r\nseq_pad(m, ' ');\r\nseq_printf(m, "%c%c%c (%s)", con->read ? 'R' : '-',\r\ncon->write ? 'W' : '-', con->unblank ? 'U' : '-',\r\nflags);\r\nif (dev)\r\nseq_printf(m, " %4d:%d", MAJOR(dev), MINOR(dev));\r\nseq_printf(m, "\n");\r\nreturn 0;\r\n}\r\nstatic void *c_start(struct seq_file *m, loff_t *pos)\r\n{\r\nstruct console *con;\r\nloff_t off = 0;\r\nconsole_lock();\r\nfor_each_console(con)\r\nif (off++ == *pos)\r\nbreak;\r\nreturn con;\r\n}\r\nstatic void *c_next(struct seq_file *m, void *v, loff_t *pos)\r\n{\r\nstruct console *con = v;\r\n++*pos;\r\nreturn con->next;\r\n}\r\nstatic void c_stop(struct seq_file *m, void *v)\r\n{\r\nconsole_unlock();\r\n}\r\nstatic int consoles_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &consoles_op);\r\n}\r\nstatic int __init proc_consoles_init(void)\r\n{\r\nproc_create("consoles", 0, NULL, &proc_consoles_operations);\r\nreturn 0;\r\n}
