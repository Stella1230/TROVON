static void try_init_preload(void)\r\n{\r\nif (__init_state != done)\r\ninit_preload();\r\n}\r\nstatic struct rb_node **__get_lock_node(void *lock, struct rb_node **parent)\r\n{\r\nstruct rb_node **node = &locks.rb_node;\r\nstruct lock_lookup *l;\r\n*parent = NULL;\r\nwhile (*node) {\r\nl = rb_entry(*node, struct lock_lookup, node);\r\n*parent = *node;\r\nif (lock < l->orig)\r\nnode = &l->node.rb_left;\r\nelse if (lock > l->orig)\r\nnode = &l->node.rb_right;\r\nelse\r\nreturn node;\r\n}\r\nreturn node;\r\n}\r\nstatic inline bool is_static_lock(struct lock_lookup *lock)\r\n{\r\nreturn lock >= __locks && lock < __locks + ARRAY_SIZE(__locks);\r\n}\r\nstatic struct lock_lookup *alloc_lock(void)\r\n{\r\nif (__init_state != done) {\r\nint idx = __locks_nr++;\r\nif (idx >= ARRAY_SIZE(__locks)) {\r\nfprintf(stderr,\r\n"LOCKDEP error: insufficient LIBLOCKDEP_STATIC_ENTRIES\n");\r\nexit(EX_UNAVAILABLE);\r\n}\r\nreturn __locks + idx;\r\n}\r\nreturn malloc(sizeof(struct lock_lookup));\r\n}\r\nstatic inline void free_lock(struct lock_lookup *lock)\r\n{\r\nif (likely(!is_static_lock(lock)))\r\nfree(lock);\r\n}\r\nstatic struct lock_lookup *__get_lock(void *lock)\r\n{\r\nstruct rb_node **node, *parent;\r\nstruct lock_lookup *l;\r\nll_pthread_rwlock_rdlock(&locks_rwlock);\r\nnode = __get_lock_node(lock, &parent);\r\nll_pthread_rwlock_unlock(&locks_rwlock);\r\nif (*node) {\r\nreturn rb_entry(*node, struct lock_lookup, node);\r\n}\r\nl = alloc_lock();\r\nif (l == NULL)\r\nreturn NULL;\r\nl->orig = lock;\r\nsprintf(l->name, "%p", lock);\r\nlockdep_init_map(&l->dep_map, l->name, &l->key, 0);\r\nll_pthread_rwlock_wrlock(&locks_rwlock);\r\nnode = __get_lock_node(lock, &parent);\r\nrb_link_node(&l->node, parent, node);\r\nrb_insert_color(&l->node, &locks);\r\nll_pthread_rwlock_unlock(&locks_rwlock);\r\nreturn l;\r\n}\r\nstatic void __del_lock(struct lock_lookup *lock)\r\n{\r\nll_pthread_rwlock_wrlock(&locks_rwlock);\r\nrb_erase(&lock->node, &locks);\r\nll_pthread_rwlock_unlock(&locks_rwlock);\r\nfree_lock(lock);\r\n}\r\nint pthread_mutex_init(pthread_mutex_t *mutex,\r\nconst pthread_mutexattr_t *attr)\r\n{\r\nint r;\r\ntry_init_preload();\r\nr = ll_pthread_mutex_init(mutex, attr);\r\nif (r == 0)\r\n__get_lock(mutex);\r\nreturn r;\r\n}\r\nint pthread_mutex_lock(pthread_mutex_t *mutex)\r\n{\r\nint r;\r\ntry_init_preload();\r\nlock_acquire(&__get_lock(mutex)->dep_map, 0, 0, 0, 1, NULL,\r\n(unsigned long)_RET_IP_);\r\nr = ll_pthread_mutex_lock(mutex);\r\nif (r)\r\nlock_release(&__get_lock(mutex)->dep_map, 0, (unsigned long)_RET_IP_);\r\nreturn r;\r\n}\r\nint pthread_mutex_trylock(pthread_mutex_t *mutex)\r\n{\r\nint r;\r\ntry_init_preload();\r\nlock_acquire(&__get_lock(mutex)->dep_map, 0, 1, 0, 1, NULL, (unsigned long)_RET_IP_);\r\nr = ll_pthread_mutex_trylock(mutex);\r\nif (r)\r\nlock_release(&__get_lock(mutex)->dep_map, 0, (unsigned long)_RET_IP_);\r\nreturn r;\r\n}\r\nint pthread_mutex_unlock(pthread_mutex_t *mutex)\r\n{\r\nint r;\r\ntry_init_preload();\r\nlock_release(&__get_lock(mutex)->dep_map, 0, (unsigned long)_RET_IP_);\r\nr = ll_pthread_mutex_unlock(mutex);\r\nif (r)\r\nlock_acquire(&__get_lock(mutex)->dep_map, 0, 0, 0, 1, NULL, (unsigned long)_RET_IP_);\r\nreturn r;\r\n}\r\nint pthread_mutex_destroy(pthread_mutex_t *mutex)\r\n{\r\ntry_init_preload();\r\ndebug_check_no_locks_freed(mutex, sizeof(*mutex));\r\n__del_lock(__get_lock(mutex));\r\nreturn ll_pthread_mutex_destroy(mutex);\r\n}\r\nint pthread_rwlock_init(pthread_rwlock_t *rwlock,\r\nconst pthread_rwlockattr_t *attr)\r\n{\r\nint r;\r\ntry_init_preload();\r\nr = ll_pthread_rwlock_init(rwlock, attr);\r\nif (r == 0)\r\n__get_lock(rwlock);\r\nreturn r;\r\n}\r\nint pthread_rwlock_destroy(pthread_rwlock_t *rwlock)\r\n{\r\ntry_init_preload();\r\ndebug_check_no_locks_freed(rwlock, sizeof(*rwlock));\r\n__del_lock(__get_lock(rwlock));\r\nreturn ll_pthread_rwlock_destroy(rwlock);\r\n}\r\nint pthread_rwlock_rdlock(pthread_rwlock_t *rwlock)\r\n{\r\nint r;\r\ninit_preload();\r\nlock_acquire(&__get_lock(rwlock)->dep_map, 0, 0, 2, 1, NULL, (unsigned long)_RET_IP_);\r\nr = ll_pthread_rwlock_rdlock(rwlock);\r\nif (r)\r\nlock_release(&__get_lock(rwlock)->dep_map, 0, (unsigned long)_RET_IP_);\r\nreturn r;\r\n}\r\nint pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock)\r\n{\r\nint r;\r\ninit_preload();\r\nlock_acquire(&__get_lock(rwlock)->dep_map, 0, 1, 2, 1, NULL, (unsigned long)_RET_IP_);\r\nr = ll_pthread_rwlock_tryrdlock(rwlock);\r\nif (r)\r\nlock_release(&__get_lock(rwlock)->dep_map, 0, (unsigned long)_RET_IP_);\r\nreturn r;\r\n}\r\nint pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock)\r\n{\r\nint r;\r\ninit_preload();\r\nlock_acquire(&__get_lock(rwlock)->dep_map, 0, 1, 0, 1, NULL, (unsigned long)_RET_IP_);\r\nr = ll_pthread_rwlock_trywrlock(rwlock);\r\nif (r)\r\nlock_release(&__get_lock(rwlock)->dep_map, 0, (unsigned long)_RET_IP_);\r\nreturn r;\r\n}\r\nint pthread_rwlock_wrlock(pthread_rwlock_t *rwlock)\r\n{\r\nint r;\r\ninit_preload();\r\nlock_acquire(&__get_lock(rwlock)->dep_map, 0, 0, 0, 1, NULL, (unsigned long)_RET_IP_);\r\nr = ll_pthread_rwlock_wrlock(rwlock);\r\nif (r)\r\nlock_release(&__get_lock(rwlock)->dep_map, 0, (unsigned long)_RET_IP_);\r\nreturn r;\r\n}\r\nint pthread_rwlock_unlock(pthread_rwlock_t *rwlock)\r\n{\r\nint r;\r\ninit_preload();\r\nlock_release(&__get_lock(rwlock)->dep_map, 0, (unsigned long)_RET_IP_);\r\nr = ll_pthread_rwlock_unlock(rwlock);\r\nif (r)\r\nlock_acquire(&__get_lock(rwlock)->dep_map, 0, 0, 0, 1, NULL, (unsigned long)_RET_IP_);\r\nreturn r;\r\n}\r\nstatic void init_preload(void)\r\n{\r\nif (__init_state == done)\r\nreturn;\r\n#ifndef __GLIBC__\r\n__init_state = prepare;\r\nll_pthread_mutex_init = dlsym(RTLD_NEXT, "pthread_mutex_init");\r\nll_pthread_mutex_lock = dlsym(RTLD_NEXT, "pthread_mutex_lock");\r\nll_pthread_mutex_trylock = dlsym(RTLD_NEXT, "pthread_mutex_trylock");\r\nll_pthread_mutex_unlock = dlsym(RTLD_NEXT, "pthread_mutex_unlock");\r\nll_pthread_mutex_destroy = dlsym(RTLD_NEXT, "pthread_mutex_destroy");\r\nll_pthread_rwlock_init = dlsym(RTLD_NEXT, "pthread_rwlock_init");\r\nll_pthread_rwlock_destroy = dlsym(RTLD_NEXT, "pthread_rwlock_destroy");\r\nll_pthread_rwlock_rdlock = dlsym(RTLD_NEXT, "pthread_rwlock_rdlock");\r\nll_pthread_rwlock_tryrdlock = dlsym(RTLD_NEXT, "pthread_rwlock_tryrdlock");\r\nll_pthread_rwlock_wrlock = dlsym(RTLD_NEXT, "pthread_rwlock_wrlock");\r\nll_pthread_rwlock_trywrlock = dlsym(RTLD_NEXT, "pthread_rwlock_trywrlock");\r\nll_pthread_rwlock_unlock = dlsym(RTLD_NEXT, "pthread_rwlock_unlock");\r\n#endif\r\nlockdep_init();\r\n__init_state = done;\r\n}
