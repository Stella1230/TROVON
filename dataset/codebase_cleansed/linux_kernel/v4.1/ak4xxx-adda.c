void snd_akm4xxx_write(struct snd_akm4xxx *ak, int chip, unsigned char reg,\r\nunsigned char val)\r\n{\r\nak->ops.lock(ak, chip);\r\nak->ops.write(ak, chip, reg, val);\r\nsnd_akm4xxx_set(ak, chip, reg, val);\r\nak->ops.unlock(ak, chip);\r\n}\r\nstatic void ak4524_reset(struct snd_akm4xxx *ak, int state)\r\n{\r\nunsigned int chip;\r\nunsigned char reg;\r\nfor (chip = 0; chip < ak->num_dacs/2; chip++) {\r\nsnd_akm4xxx_write(ak, chip, 0x01, state ? 0x00 : 0x03);\r\nif (state)\r\ncontinue;\r\nfor (reg = 0x04; reg < ak->total_regs; reg++)\r\nsnd_akm4xxx_write(ak, chip, reg,\r\nsnd_akm4xxx_get(ak, chip, reg));\r\n}\r\n}\r\nstatic void ak435X_reset(struct snd_akm4xxx *ak, int state)\r\n{\r\nunsigned char reg;\r\nif (state) {\r\nsnd_akm4xxx_write(ak, 0, 0x01, 0x02);\r\nreturn;\r\n}\r\nfor (reg = 0x00; reg < ak->total_regs; reg++)\r\nif (reg != 0x01)\r\nsnd_akm4xxx_write(ak, 0, reg,\r\nsnd_akm4xxx_get(ak, 0, reg));\r\nsnd_akm4xxx_write(ak, 0, 0x01, 0x01);\r\n}\r\nstatic void ak4381_reset(struct snd_akm4xxx *ak, int state)\r\n{\r\nunsigned int chip;\r\nunsigned char reg;\r\nfor (chip = 0; chip < ak->num_dacs/2; chip++) {\r\nsnd_akm4xxx_write(ak, chip, 0x00, state ? 0x0c : 0x0f);\r\nif (state)\r\ncontinue;\r\nfor (reg = 0x01; reg < ak->total_regs; reg++)\r\nsnd_akm4xxx_write(ak, chip, reg,\r\nsnd_akm4xxx_get(ak, chip, reg));\r\n}\r\n}\r\nvoid snd_akm4xxx_reset(struct snd_akm4xxx *ak, int state)\r\n{\r\nswitch (ak->type) {\r\ncase SND_AK4524:\r\ncase SND_AK4528:\r\ncase SND_AK4620:\r\nak4524_reset(ak, state);\r\nbreak;\r\ncase SND_AK4529:\r\nbreak;\r\ncase SND_AK4355:\r\nak435X_reset(ak, state);\r\nbreak;\r\ncase SND_AK4358:\r\nak435X_reset(ak, state);\r\nbreak;\r\ncase SND_AK4381:\r\nak4381_reset(ak, state);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nvoid snd_akm4xxx_init(struct snd_akm4xxx *ak)\r\n{\r\nstatic const unsigned char inits_ak4524[] = {\r\n0x00, 0x07,\r\n0x01, 0x00,\r\n0x02, 0x60,\r\n0x03, 0x19,\r\n0x01, 0x03,\r\n0x04, 0x00,\r\n0x05, 0x00,\r\n0x06, 0x00,\r\n0x07, 0x00,\r\n0xff, 0xff\r\n};\r\nstatic const unsigned char inits_ak4528[] = {\r\n0x00, 0x07,\r\n0x01, 0x00,\r\n0x02, 0x60,\r\n0x03, 0x0d,\r\n0x01, 0x03,\r\n0x04, 0x00,\r\n0x05, 0x00,\r\n0xff, 0xff\r\n};\r\nstatic const unsigned char inits_ak4529[] = {\r\n0x09, 0x01,\r\n0x0a, 0x3f,\r\n0x00, 0x0c,\r\n0x01, 0x00,\r\n0x02, 0xff,\r\n0x03, 0xff,\r\n0x04, 0xff,\r\n0x05, 0xff,\r\n0x06, 0xff,\r\n0x07, 0xff,\r\n0x0b, 0xff,\r\n0x0c, 0xff,\r\n0x08, 0x55,\r\n0xff, 0xff\r\n};\r\nstatic const unsigned char inits_ak4355[] = {\r\n0x01, 0x02,\r\n0x00, 0x06,\r\n0x02, 0x0e,\r\n0x03, 0x01,\r\n0x04, 0x00,\r\n0x05, 0x00,\r\n0x06, 0x00,\r\n0x07, 0x00,\r\n0x08, 0x00,\r\n0x09, 0x00,\r\n0x0a, 0x00,\r\n0x01, 0x01,\r\n0xff, 0xff\r\n};\r\nstatic const unsigned char inits_ak4358[] = {\r\n0x01, 0x02,\r\n0x00, 0x06,\r\n0x02, 0x4e,\r\n0x03, 0x01,\r\n0x04, 0x00,\r\n0x05, 0x00,\r\n0x06, 0x00,\r\n0x07, 0x00,\r\n0x08, 0x00,\r\n0x09, 0x00,\r\n0x0b, 0x00,\r\n0x0c, 0x00,\r\n0x0a, 0x00,\r\n0x01, 0x01,\r\n0xff, 0xff\r\n};\r\nstatic const unsigned char inits_ak4381[] = {\r\n0x00, 0x0c,\r\n0x01, 0x02,\r\n0x02, 0x00,\r\n0x03, 0x00,\r\n0x04, 0x00,\r\n0x00, 0x0f,\r\n0xff, 0xff\r\n};\r\nstatic const unsigned char inits_ak4620[] = {\r\n0x00, 0x07,\r\n0x01, 0x00,\r\n0x01, 0x02,\r\n0x01, 0x03,\r\n0x01, 0x0f,\r\n0x02, 0x60,\r\n0x03, 0x01,\r\n0x04, 0x00,\r\n0x05, 0x00,\r\n0x06, 0x00,\r\n0x07, 0x00,\r\n0xff, 0xff\r\n};\r\nint chip;\r\nconst unsigned char *ptr, *inits;\r\nunsigned char reg, data;\r\nmemset(ak->images, 0, sizeof(ak->images));\r\nmemset(ak->volumes, 0, sizeof(ak->volumes));\r\nswitch (ak->type) {\r\ncase SND_AK4524:\r\ninits = inits_ak4524;\r\nak->num_chips = ak->num_dacs / 2;\r\nak->name = "ak4524";\r\nak->total_regs = 0x08;\r\nbreak;\r\ncase SND_AK4528:\r\ninits = inits_ak4528;\r\nak->num_chips = ak->num_dacs / 2;\r\nak->name = "ak4528";\r\nak->total_regs = 0x06;\r\nbreak;\r\ncase SND_AK4529:\r\ninits = inits_ak4529;\r\nak->num_chips = 1;\r\nak->name = "ak4529";\r\nak->total_regs = 0x0d;\r\nbreak;\r\ncase SND_AK4355:\r\ninits = inits_ak4355;\r\nak->num_chips = 1;\r\nak->name = "ak4355";\r\nak->total_regs = 0x0b;\r\nbreak;\r\ncase SND_AK4358:\r\ninits = inits_ak4358;\r\nak->num_chips = 1;\r\nak->name = "ak4358";\r\nak->total_regs = 0x10;\r\nbreak;\r\ncase SND_AK4381:\r\ninits = inits_ak4381;\r\nak->num_chips = ak->num_dacs / 2;\r\nak->name = "ak4381";\r\nak->total_regs = 0x05;\r\nbreak;\r\ncase SND_AK5365:\r\nak->num_chips = 1;\r\nak->name = "ak5365";\r\nak->total_regs = 0x08;\r\nreturn;\r\ncase SND_AK4620:\r\ninits = inits_ak4620;\r\nak->num_chips = ak->num_dacs / 2;\r\nak->name = "ak4620";\r\nak->total_regs = 0x08;\r\nbreak;\r\ndefault:\r\nsnd_BUG();\r\nreturn;\r\n}\r\nfor (chip = 0; chip < ak->num_chips; chip++) {\r\nptr = inits;\r\nwhile (*ptr != 0xff) {\r\nreg = *ptr++;\r\ndata = *ptr++;\r\nsnd_akm4xxx_write(ak, chip, reg, data);\r\nudelay(10);\r\n}\r\n}\r\n}\r\nstatic int snd_akm4xxx_volume_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nunsigned int mask = AK_GET_MASK(kcontrol->private_value);\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = mask;\r\nreturn 0;\r\n}\r\nstatic int snd_akm4xxx_volume_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_akm4xxx *ak = snd_kcontrol_chip(kcontrol);\r\nint chip = AK_GET_CHIP(kcontrol->private_value);\r\nint addr = AK_GET_ADDR(kcontrol->private_value);\r\nucontrol->value.integer.value[0] = snd_akm4xxx_get_vol(ak, chip, addr);\r\nreturn 0;\r\n}\r\nstatic int put_ak_reg(struct snd_kcontrol *kcontrol, int addr,\r\nunsigned char nval)\r\n{\r\nstruct snd_akm4xxx *ak = snd_kcontrol_chip(kcontrol);\r\nunsigned int mask = AK_GET_MASK(kcontrol->private_value);\r\nint chip = AK_GET_CHIP(kcontrol->private_value);\r\nif (snd_akm4xxx_get_vol(ak, chip, addr) == nval)\r\nreturn 0;\r\nsnd_akm4xxx_set_vol(ak, chip, addr, nval);\r\nif (AK_GET_VOL_CVT(kcontrol->private_value) && nval < 128)\r\nnval = vol_cvt_datt[nval];\r\nif (AK_GET_IPGA(kcontrol->private_value) && nval >= 128)\r\nnval++;\r\nif (AK_GET_INVERT(kcontrol->private_value))\r\nnval = mask - nval;\r\nif (AK_GET_NEEDSMSB(kcontrol->private_value))\r\nnval |= 0x80;\r\nsnd_akm4xxx_write(ak, chip, addr, nval);\r\nreturn 1;\r\n}\r\nstatic int snd_akm4xxx_volume_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nunsigned int mask = AK_GET_MASK(kcontrol->private_value);\r\nunsigned int val = ucontrol->value.integer.value[0];\r\nif (val > mask)\r\nreturn -EINVAL;\r\nreturn put_ak_reg(kcontrol, AK_GET_ADDR(kcontrol->private_value), val);\r\n}\r\nstatic int snd_akm4xxx_stereo_volume_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nunsigned int mask = AK_GET_MASK(kcontrol->private_value);\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = mask;\r\nreturn 0;\r\n}\r\nstatic int snd_akm4xxx_stereo_volume_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_akm4xxx *ak = snd_kcontrol_chip(kcontrol);\r\nint chip = AK_GET_CHIP(kcontrol->private_value);\r\nint addr = AK_GET_ADDR(kcontrol->private_value);\r\nucontrol->value.integer.value[0] = snd_akm4xxx_get_vol(ak, chip, addr);\r\nucontrol->value.integer.value[1] = snd_akm4xxx_get_vol(ak, chip, addr+1);\r\nreturn 0;\r\n}\r\nstatic int snd_akm4xxx_stereo_volume_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nint addr = AK_GET_ADDR(kcontrol->private_value);\r\nunsigned int mask = AK_GET_MASK(kcontrol->private_value);\r\nunsigned int val[2];\r\nint change;\r\nval[0] = ucontrol->value.integer.value[0];\r\nval[1] = ucontrol->value.integer.value[1];\r\nif (val[0] > mask || val[1] > mask)\r\nreturn -EINVAL;\r\nchange = put_ak_reg(kcontrol, addr, val[0]);\r\nchange |= put_ak_reg(kcontrol, addr + 1, val[1]);\r\nreturn change;\r\n}\r\nstatic int snd_akm4xxx_deemphasis_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic const char * const texts[4] = {\r\n"44.1kHz", "Off", "48kHz", "32kHz",\r\n};\r\nreturn snd_ctl_enum_info(uinfo, 1, 4, texts);\r\n}\r\nstatic int snd_akm4xxx_deemphasis_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_akm4xxx *ak = snd_kcontrol_chip(kcontrol);\r\nint chip = AK_GET_CHIP(kcontrol->private_value);\r\nint addr = AK_GET_ADDR(kcontrol->private_value);\r\nint shift = AK_GET_SHIFT(kcontrol->private_value);\r\nucontrol->value.enumerated.item[0] =\r\n(snd_akm4xxx_get(ak, chip, addr) >> shift) & 3;\r\nreturn 0;\r\n}\r\nstatic int snd_akm4xxx_deemphasis_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_akm4xxx *ak = snd_kcontrol_chip(kcontrol);\r\nint chip = AK_GET_CHIP(kcontrol->private_value);\r\nint addr = AK_GET_ADDR(kcontrol->private_value);\r\nint shift = AK_GET_SHIFT(kcontrol->private_value);\r\nunsigned char nval = ucontrol->value.enumerated.item[0] & 3;\r\nint change;\r\nnval = (nval << shift) |\r\n(snd_akm4xxx_get(ak, chip, addr) & ~(3 << shift));\r\nchange = snd_akm4xxx_get(ak, chip, addr) != nval;\r\nif (change)\r\nsnd_akm4xxx_write(ak, chip, addr, nval);\r\nreturn change;\r\n}\r\nstatic int ak4xxx_switch_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_akm4xxx *ak = snd_kcontrol_chip(kcontrol);\r\nint chip = AK_GET_CHIP(kcontrol->private_value);\r\nint addr = AK_GET_ADDR(kcontrol->private_value);\r\nint shift = AK_GET_SHIFT(kcontrol->private_value);\r\nint invert = AK_GET_INVERT(kcontrol->private_value);\r\nunsigned char val = snd_akm4xxx_get(ak, chip, addr) & (1<<shift);\r\nif (invert)\r\nval = ! val;\r\nucontrol->value.integer.value[0] = (val & (1<<shift)) != 0;\r\nreturn 0;\r\n}\r\nstatic int ak4xxx_switch_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_akm4xxx *ak = snd_kcontrol_chip(kcontrol);\r\nint chip = AK_GET_CHIP(kcontrol->private_value);\r\nint addr = AK_GET_ADDR(kcontrol->private_value);\r\nint shift = AK_GET_SHIFT(kcontrol->private_value);\r\nint invert = AK_GET_INVERT(kcontrol->private_value);\r\nlong flag = ucontrol->value.integer.value[0];\r\nunsigned char val, oval;\r\nint change;\r\nif (invert)\r\nflag = ! flag;\r\noval = snd_akm4xxx_get(ak, chip, addr);\r\nif (flag)\r\nval = oval | (1<<shift);\r\nelse\r\nval = oval & ~(1<<shift);\r\nchange = (oval != val);\r\nif (change)\r\nsnd_akm4xxx_write(ak, chip, addr, val);\r\nreturn change;\r\n}\r\nstatic int ak4xxx_capture_num_inputs(struct snd_akm4xxx *ak, int mixer_ch)\r\n{\r\nint num_names;\r\nconst char **input_names;\r\ninput_names = ak->adc_info[mixer_ch].input_names;\r\nnum_names = 0;\r\nwhile (num_names < AK5365_NUM_INPUTS && input_names[num_names])\r\n++num_names;\r\nreturn num_names;\r\n}\r\nstatic int ak4xxx_capture_source_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct snd_akm4xxx *ak = snd_kcontrol_chip(kcontrol);\r\nint mixer_ch = AK_GET_SHIFT(kcontrol->private_value);\r\nunsigned int num_names;\r\nnum_names = ak4xxx_capture_num_inputs(ak, mixer_ch);\r\nif (!num_names)\r\nreturn -EINVAL;\r\nreturn snd_ctl_enum_info(uinfo, 1, num_names,\r\nak->adc_info[mixer_ch].input_names);\r\n}\r\nstatic int ak4xxx_capture_source_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_akm4xxx *ak = snd_kcontrol_chip(kcontrol);\r\nint chip = AK_GET_CHIP(kcontrol->private_value);\r\nint addr = AK_GET_ADDR(kcontrol->private_value);\r\nint mask = AK_GET_MASK(kcontrol->private_value);\r\nunsigned char val;\r\nval = snd_akm4xxx_get(ak, chip, addr) & mask;\r\nucontrol->value.enumerated.item[0] = val;\r\nreturn 0;\r\n}\r\nstatic int ak4xxx_capture_source_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_akm4xxx *ak = snd_kcontrol_chip(kcontrol);\r\nint mixer_ch = AK_GET_SHIFT(kcontrol->private_value);\r\nint chip = AK_GET_CHIP(kcontrol->private_value);\r\nint addr = AK_GET_ADDR(kcontrol->private_value);\r\nint mask = AK_GET_MASK(kcontrol->private_value);\r\nunsigned char oval, val;\r\nint num_names = ak4xxx_capture_num_inputs(ak, mixer_ch);\r\nif (ucontrol->value.enumerated.item[0] >= num_names)\r\nreturn -EINVAL;\r\noval = snd_akm4xxx_get(ak, chip, addr);\r\nval = oval & ~mask;\r\nval |= ucontrol->value.enumerated.item[0] & mask;\r\nif (val != oval) {\r\nsnd_akm4xxx_write(ak, chip, addr, val);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int build_dac_controls(struct snd_akm4xxx *ak)\r\n{\r\nint idx, err, mixer_ch, num_stereo;\r\nstruct snd_kcontrol_new knew;\r\nmixer_ch = 0;\r\nfor (idx = 0; idx < ak->num_dacs; ) {\r\nif (ak->type == SND_AK4381\r\n&& ak->dac_info[mixer_ch].switch_name) {\r\nmemset(&knew, 0, sizeof(knew));\r\nknew.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nknew.count = 1;\r\nknew.access = SNDRV_CTL_ELEM_ACCESS_READWRITE;\r\nknew.name = ak->dac_info[mixer_ch].switch_name;\r\nknew.info = ak4xxx_switch_info;\r\nknew.get = ak4xxx_switch_get;\r\nknew.put = ak4xxx_switch_put;\r\nknew.access = 0;\r\nknew.private_value =\r\nAK_COMPOSE(idx/2, 1, 0, 0) | AK_INVERT;\r\nerr = snd_ctl_add(ak->card, snd_ctl_new1(&knew, ak));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nmemset(&knew, 0, sizeof(knew));\r\nif (! ak->dac_info || ! ak->dac_info[mixer_ch].name) {\r\nknew.name = "DAC Volume";\r\nknew.index = mixer_ch + ak->idx_offset * 2;\r\nnum_stereo = 1;\r\n} else {\r\nknew.name = ak->dac_info[mixer_ch].name;\r\nnum_stereo = ak->dac_info[mixer_ch].num_channels;\r\n}\r\nknew.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nknew.count = 1;\r\nknew.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\r\nSNDRV_CTL_ELEM_ACCESS_TLV_READ;\r\nif (num_stereo == 2) {\r\nknew.info = snd_akm4xxx_stereo_volume_info;\r\nknew.get = snd_akm4xxx_stereo_volume_get;\r\nknew.put = snd_akm4xxx_stereo_volume_put;\r\n} else {\r\nknew.info = snd_akm4xxx_volume_info;\r\nknew.get = snd_akm4xxx_volume_get;\r\nknew.put = snd_akm4xxx_volume_put;\r\n}\r\nswitch (ak->type) {\r\ncase SND_AK4524:\r\nknew.private_value =\r\nAK_COMPOSE(idx/2, (idx%2) + 6, 0, 127) |\r\nAK_VOL_CVT;\r\nknew.tlv.p = db_scale_vol_datt;\r\nbreak;\r\ncase SND_AK4528:\r\nknew.private_value =\r\nAK_COMPOSE(idx/2, (idx%2) + 4, 0, 127) |\r\nAK_VOL_CVT;\r\nknew.tlv.p = db_scale_vol_datt;\r\nbreak;\r\ncase SND_AK4529: {\r\nint val = idx < 6 ? idx + 2 : (idx - 6) + 0xb;\r\nknew.private_value =\r\nAK_COMPOSE(0, val, 0, 255) | AK_INVERT;\r\nknew.tlv.p = db_scale_8bit;\r\nbreak;\r\n}\r\ncase SND_AK4355:\r\nknew.private_value = AK_COMPOSE(0, idx + 4, 0, 255);\r\nknew.tlv.p = db_scale_8bit;\r\nbreak;\r\ncase SND_AK4358: {\r\nint addr = idx < 6 ? idx + 4 : idx + 5;\r\nknew.private_value =\r\nAK_COMPOSE(0, addr, 0, 127) | AK_NEEDSMSB;\r\nknew.tlv.p = db_scale_7bit;\r\nbreak;\r\n}\r\ncase SND_AK4381:\r\nknew.private_value =\r\nAK_COMPOSE(idx/2, (idx%2) + 3, 0, 255);\r\nknew.tlv.p = db_scale_linear;\r\nbreak;\r\ncase SND_AK4620:\r\nknew.private_value =\r\nAK_COMPOSE(idx/2, (idx%2) + 6, 0, 255);\r\nknew.tlv.p = db_scale_linear;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nerr = snd_ctl_add(ak->card, snd_ctl_new1(&knew, ak));\r\nif (err < 0)\r\nreturn err;\r\nidx += num_stereo;\r\nmixer_ch++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int build_adc_controls(struct snd_akm4xxx *ak)\r\n{\r\nint idx, err, mixer_ch, num_stereo, max_steps;\r\nstruct snd_kcontrol_new knew;\r\nmixer_ch = 0;\r\nif (ak->type == SND_AK4528)\r\nreturn 0;\r\nfor (idx = 0; idx < ak->num_adcs;) {\r\nmemset(&knew, 0, sizeof(knew));\r\nif (! ak->adc_info || ! ak->adc_info[mixer_ch].name) {\r\nknew.name = "ADC Volume";\r\nknew.index = mixer_ch + ak->idx_offset * 2;\r\nnum_stereo = 1;\r\n} else {\r\nknew.name = ak->adc_info[mixer_ch].name;\r\nnum_stereo = ak->adc_info[mixer_ch].num_channels;\r\n}\r\nknew.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nknew.count = 1;\r\nknew.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\r\nSNDRV_CTL_ELEM_ACCESS_TLV_READ;\r\nif (num_stereo == 2) {\r\nknew.info = snd_akm4xxx_stereo_volume_info;\r\nknew.get = snd_akm4xxx_stereo_volume_get;\r\nknew.put = snd_akm4xxx_stereo_volume_put;\r\n} else {\r\nknew.info = snd_akm4xxx_volume_info;\r\nknew.get = snd_akm4xxx_volume_get;\r\nknew.put = snd_akm4xxx_volume_put;\r\n}\r\nif (ak->type == SND_AK5365)\r\nmax_steps = 152;\r\nelse\r\nmax_steps = 164;\r\nknew.private_value =\r\nAK_COMPOSE(idx/2, (idx%2) + 4, 0, max_steps) |\r\nAK_VOL_CVT | AK_IPGA;\r\nknew.tlv.p = db_scale_vol_datt;\r\nerr = snd_ctl_add(ak->card, snd_ctl_new1(&knew, ak));\r\nif (err < 0)\r\nreturn err;\r\nif (ak->type == SND_AK5365 && (idx % 2) == 0) {\r\nif (! ak->adc_info ||\r\n! ak->adc_info[mixer_ch].switch_name) {\r\nknew.name = "Capture Switch";\r\nknew.index = mixer_ch + ak->idx_offset * 2;\r\n} else\r\nknew.name = ak->adc_info[mixer_ch].switch_name;\r\nknew.info = ak4xxx_switch_info;\r\nknew.get = ak4xxx_switch_get;\r\nknew.put = ak4xxx_switch_put;\r\nknew.access = 0;\r\nknew.private_value =\r\nAK_COMPOSE(idx/2, 2, 0, 0) | AK_INVERT;\r\nerr = snd_ctl_add(ak->card, snd_ctl_new1(&knew, ak));\r\nif (err < 0)\r\nreturn err;\r\nmemset(&knew, 0, sizeof(knew));\r\nknew.name = ak->adc_info[mixer_ch].selector_name;\r\nif (!knew.name) {\r\nknew.name = "Capture Channel";\r\nknew.index = mixer_ch + ak->idx_offset * 2;\r\n}\r\nknew.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nknew.info = ak4xxx_capture_source_info;\r\nknew.get = ak4xxx_capture_source_get;\r\nknew.put = ak4xxx_capture_source_put;\r\nknew.access = 0;\r\nknew.private_value\r\n= AK_COMPOSE(idx/2, 1, mixer_ch, 0x07);\r\nerr = snd_ctl_add(ak->card, snd_ctl_new1(&knew, ak));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nidx += num_stereo;\r\nmixer_ch++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int build_deemphasis(struct snd_akm4xxx *ak, int num_emphs)\r\n{\r\nint idx, err;\r\nstruct snd_kcontrol_new knew;\r\nfor (idx = 0; idx < num_emphs; idx++) {\r\nmemset(&knew, 0, sizeof(knew));\r\nknew.name = "Deemphasis";\r\nknew.index = idx + ak->idx_offset;\r\nknew.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nknew.count = 1;\r\nknew.info = snd_akm4xxx_deemphasis_info;\r\nknew.get = snd_akm4xxx_deemphasis_get;\r\nknew.put = snd_akm4xxx_deemphasis_put;\r\nswitch (ak->type) {\r\ncase SND_AK4524:\r\ncase SND_AK4528:\r\ncase SND_AK4620:\r\nknew.private_value = AK_COMPOSE(idx, 3, 0, 0);\r\nbreak;\r\ncase SND_AK4529: {\r\nint shift = idx == 3 ? 6 : (2 - idx) * 2;\r\nknew.private_value = AK_COMPOSE(0, 8, shift, 0);\r\nbreak;\r\n}\r\ncase SND_AK4355:\r\ncase SND_AK4358:\r\nknew.private_value = AK_COMPOSE(idx, 3, 0, 0);\r\nbreak;\r\ncase SND_AK4381:\r\nknew.private_value = AK_COMPOSE(idx, 1, 1, 0);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nerr = snd_ctl_add(ak->card, snd_ctl_new1(&knew, ak));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void proc_regs_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct snd_akm4xxx *ak = entry->private_data;\r\nint reg, val, chip;\r\nfor (chip = 0; chip < ak->num_chips; chip++) {\r\nfor (reg = 0; reg < ak->total_regs; reg++) {\r\nval = snd_akm4xxx_get(ak, chip, reg);\r\nsnd_iprintf(buffer, "chip %d: 0x%02x = 0x%02x\n", chip,\r\nreg, val);\r\n}\r\n}\r\n}\r\nstatic int proc_init(struct snd_akm4xxx *ak)\r\n{\r\nstruct snd_info_entry *entry;\r\nint err;\r\nerr = snd_card_proc_new(ak->card, ak->name, &entry);\r\nif (err < 0)\r\nreturn err;\r\nsnd_info_set_text_ops(entry, ak, proc_regs_read);\r\nreturn 0;\r\n}\r\nstatic int proc_init(struct snd_akm4xxx *ak) { return 0; }\r\nint snd_akm4xxx_build_controls(struct snd_akm4xxx *ak)\r\n{\r\nint err, num_emphs;\r\nerr = build_dac_controls(ak);\r\nif (err < 0)\r\nreturn err;\r\nerr = build_adc_controls(ak);\r\nif (err < 0)\r\nreturn err;\r\nif (ak->type == SND_AK4355 || ak->type == SND_AK4358)\r\nnum_emphs = 1;\r\nelse if (ak->type == SND_AK4620)\r\nnum_emphs = 0;\r\nelse\r\nnum_emphs = ak->num_dacs / 2;\r\nerr = build_deemphasis(ak, num_emphs);\r\nif (err < 0)\r\nreturn err;\r\nerr = proc_init(ak);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int __init alsa_akm4xxx_module_init(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __exit alsa_akm4xxx_module_exit(void)\r\n{\r\n}
