static int rtc_dev_open(struct inode *inode, struct file *file)\r\n{\r\nint err;\r\nstruct rtc_device *rtc = container_of(inode->i_cdev,\r\nstruct rtc_device, char_dev);\r\nconst struct rtc_class_ops *ops = rtc->ops;\r\nif (test_and_set_bit_lock(RTC_DEV_BUSY, &rtc->flags))\r\nreturn -EBUSY;\r\nfile->private_data = rtc;\r\nerr = ops->open ? ops->open(rtc->dev.parent) : 0;\r\nif (err == 0) {\r\nspin_lock_irq(&rtc->irq_lock);\r\nrtc->irq_data = 0;\r\nspin_unlock_irq(&rtc->irq_lock);\r\nreturn 0;\r\n}\r\nclear_bit_unlock(RTC_DEV_BUSY, &rtc->flags);\r\nreturn err;\r\n}\r\nstatic void rtc_uie_task(struct work_struct *work)\r\n{\r\nstruct rtc_device *rtc =\r\ncontainer_of(work, struct rtc_device, uie_task);\r\nstruct rtc_time tm;\r\nint num = 0;\r\nint err;\r\nerr = rtc_read_time(rtc, &tm);\r\nspin_lock_irq(&rtc->irq_lock);\r\nif (rtc->stop_uie_polling || err) {\r\nrtc->uie_task_active = 0;\r\n} else if (rtc->oldsecs != tm.tm_sec) {\r\nnum = (tm.tm_sec + 60 - rtc->oldsecs) % 60;\r\nrtc->oldsecs = tm.tm_sec;\r\nrtc->uie_timer.expires = jiffies + HZ - (HZ/10);\r\nrtc->uie_timer_active = 1;\r\nrtc->uie_task_active = 0;\r\nadd_timer(&rtc->uie_timer);\r\n} else if (schedule_work(&rtc->uie_task) == 0) {\r\nrtc->uie_task_active = 0;\r\n}\r\nspin_unlock_irq(&rtc->irq_lock);\r\nif (num)\r\nrtc_handle_legacy_irq(rtc, num, RTC_UF);\r\n}\r\nstatic void rtc_uie_timer(unsigned long data)\r\n{\r\nstruct rtc_device *rtc = (struct rtc_device *)data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&rtc->irq_lock, flags);\r\nrtc->uie_timer_active = 0;\r\nrtc->uie_task_active = 1;\r\nif ((schedule_work(&rtc->uie_task) == 0))\r\nrtc->uie_task_active = 0;\r\nspin_unlock_irqrestore(&rtc->irq_lock, flags);\r\n}\r\nstatic int clear_uie(struct rtc_device *rtc)\r\n{\r\nspin_lock_irq(&rtc->irq_lock);\r\nif (rtc->uie_irq_active) {\r\nrtc->stop_uie_polling = 1;\r\nif (rtc->uie_timer_active) {\r\nspin_unlock_irq(&rtc->irq_lock);\r\ndel_timer_sync(&rtc->uie_timer);\r\nspin_lock_irq(&rtc->irq_lock);\r\nrtc->uie_timer_active = 0;\r\n}\r\nif (rtc->uie_task_active) {\r\nspin_unlock_irq(&rtc->irq_lock);\r\nflush_scheduled_work();\r\nspin_lock_irq(&rtc->irq_lock);\r\n}\r\nrtc->uie_irq_active = 0;\r\n}\r\nspin_unlock_irq(&rtc->irq_lock);\r\nreturn 0;\r\n}\r\nstatic int set_uie(struct rtc_device *rtc)\r\n{\r\nstruct rtc_time tm;\r\nint err;\r\nerr = rtc_read_time(rtc, &tm);\r\nif (err)\r\nreturn err;\r\nspin_lock_irq(&rtc->irq_lock);\r\nif (!rtc->uie_irq_active) {\r\nrtc->uie_irq_active = 1;\r\nrtc->stop_uie_polling = 0;\r\nrtc->oldsecs = tm.tm_sec;\r\nrtc->uie_task_active = 1;\r\nif (schedule_work(&rtc->uie_task) == 0)\r\nrtc->uie_task_active = 0;\r\n}\r\nrtc->irq_data = 0;\r\nspin_unlock_irq(&rtc->irq_lock);\r\nreturn 0;\r\n}\r\nint rtc_dev_update_irq_enable_emul(struct rtc_device *rtc, unsigned int enabled)\r\n{\r\nif (enabled)\r\nreturn set_uie(rtc);\r\nelse\r\nreturn clear_uie(rtc);\r\n}\r\nstatic ssize_t\r\nrtc_dev_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)\r\n{\r\nstruct rtc_device *rtc = file->private_data;\r\nDECLARE_WAITQUEUE(wait, current);\r\nunsigned long data;\r\nssize_t ret;\r\nif (count != sizeof(unsigned int) && count < sizeof(unsigned long))\r\nreturn -EINVAL;\r\nadd_wait_queue(&rtc->irq_queue, &wait);\r\ndo {\r\n__set_current_state(TASK_INTERRUPTIBLE);\r\nspin_lock_irq(&rtc->irq_lock);\r\ndata = rtc->irq_data;\r\nrtc->irq_data = 0;\r\nspin_unlock_irq(&rtc->irq_lock);\r\nif (data != 0) {\r\nret = 0;\r\nbreak;\r\n}\r\nif (file->f_flags & O_NONBLOCK) {\r\nret = -EAGAIN;\r\nbreak;\r\n}\r\nif (signal_pending(current)) {\r\nret = -ERESTARTSYS;\r\nbreak;\r\n}\r\nschedule();\r\n} while (1);\r\nset_current_state(TASK_RUNNING);\r\nremove_wait_queue(&rtc->irq_queue, &wait);\r\nif (ret == 0) {\r\nif (rtc->ops->read_callback)\r\ndata = rtc->ops->read_callback(rtc->dev.parent,\r\ndata);\r\nif (sizeof(int) != sizeof(long) &&\r\ncount == sizeof(unsigned int))\r\nret = put_user(data, (unsigned int __user *)buf) ?:\r\nsizeof(unsigned int);\r\nelse\r\nret = put_user(data, (unsigned long __user *)buf) ?:\r\nsizeof(unsigned long);\r\n}\r\nreturn ret;\r\n}\r\nstatic unsigned int rtc_dev_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct rtc_device *rtc = file->private_data;\r\nunsigned long data;\r\npoll_wait(file, &rtc->irq_queue, wait);\r\ndata = rtc->irq_data;\r\nreturn (data != 0) ? (POLLIN | POLLRDNORM) : 0;\r\n}\r\nstatic long rtc_dev_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nint err = 0;\r\nstruct rtc_device *rtc = file->private_data;\r\nconst struct rtc_class_ops *ops = rtc->ops;\r\nstruct rtc_time tm;\r\nstruct rtc_wkalrm alarm;\r\nvoid __user *uarg = (void __user *) arg;\r\nerr = mutex_lock_interruptible(&rtc->ops_lock);\r\nif (err)\r\nreturn err;\r\nswitch (cmd) {\r\ncase RTC_EPOCH_SET:\r\ncase RTC_SET_TIME:\r\nif (!capable(CAP_SYS_TIME))\r\nerr = -EACCES;\r\nbreak;\r\ncase RTC_IRQP_SET:\r\nif (arg > rtc->max_user_freq && !capable(CAP_SYS_RESOURCE))\r\nerr = -EACCES;\r\nbreak;\r\ncase RTC_PIE_ON:\r\nif (rtc->irq_freq > rtc->max_user_freq &&\r\n!capable(CAP_SYS_RESOURCE))\r\nerr = -EACCES;\r\nbreak;\r\n}\r\nif (err)\r\ngoto done;\r\nswitch (cmd) {\r\ncase RTC_ALM_READ:\r\nmutex_unlock(&rtc->ops_lock);\r\nerr = rtc_read_alarm(rtc, &alarm);\r\nif (err < 0)\r\nreturn err;\r\nif (copy_to_user(uarg, &alarm.time, sizeof(tm)))\r\nerr = -EFAULT;\r\nreturn err;\r\ncase RTC_ALM_SET:\r\nmutex_unlock(&rtc->ops_lock);\r\nif (copy_from_user(&alarm.time, uarg, sizeof(tm)))\r\nreturn -EFAULT;\r\nalarm.enabled = 0;\r\nalarm.pending = 0;\r\nalarm.time.tm_wday = -1;\r\nalarm.time.tm_yday = -1;\r\nalarm.time.tm_isdst = -1;\r\n{\r\ntime64_t now, then;\r\nerr = rtc_read_time(rtc, &tm);\r\nif (err < 0)\r\nreturn err;\r\nnow = rtc_tm_to_time64(&tm);\r\nalarm.time.tm_mday = tm.tm_mday;\r\nalarm.time.tm_mon = tm.tm_mon;\r\nalarm.time.tm_year = tm.tm_year;\r\nerr = rtc_valid_tm(&alarm.time);\r\nif (err < 0)\r\nreturn err;\r\nthen = rtc_tm_to_time64(&alarm.time);\r\nif (then < now) {\r\nrtc_time64_to_tm(now + 24 * 60 * 60, &tm);\r\nalarm.time.tm_mday = tm.tm_mday;\r\nalarm.time.tm_mon = tm.tm_mon;\r\nalarm.time.tm_year = tm.tm_year;\r\n}\r\n}\r\nreturn rtc_set_alarm(rtc, &alarm);\r\ncase RTC_RD_TIME:\r\nmutex_unlock(&rtc->ops_lock);\r\nerr = rtc_read_time(rtc, &tm);\r\nif (err < 0)\r\nreturn err;\r\nif (copy_to_user(uarg, &tm, sizeof(tm)))\r\nerr = -EFAULT;\r\nreturn err;\r\ncase RTC_SET_TIME:\r\nmutex_unlock(&rtc->ops_lock);\r\nif (copy_from_user(&tm, uarg, sizeof(tm)))\r\nreturn -EFAULT;\r\nreturn rtc_set_time(rtc, &tm);\r\ncase RTC_PIE_ON:\r\nerr = rtc_irq_set_state(rtc, NULL, 1);\r\nbreak;\r\ncase RTC_PIE_OFF:\r\nerr = rtc_irq_set_state(rtc, NULL, 0);\r\nbreak;\r\ncase RTC_AIE_ON:\r\nmutex_unlock(&rtc->ops_lock);\r\nreturn rtc_alarm_irq_enable(rtc, 1);\r\ncase RTC_AIE_OFF:\r\nmutex_unlock(&rtc->ops_lock);\r\nreturn rtc_alarm_irq_enable(rtc, 0);\r\ncase RTC_UIE_ON:\r\nmutex_unlock(&rtc->ops_lock);\r\nreturn rtc_update_irq_enable(rtc, 1);\r\ncase RTC_UIE_OFF:\r\nmutex_unlock(&rtc->ops_lock);\r\nreturn rtc_update_irq_enable(rtc, 0);\r\ncase RTC_IRQP_SET:\r\nerr = rtc_irq_set_freq(rtc, NULL, arg);\r\nbreak;\r\ncase RTC_IRQP_READ:\r\nerr = put_user(rtc->irq_freq, (unsigned long __user *)uarg);\r\nbreak;\r\ncase RTC_WKALM_SET:\r\nmutex_unlock(&rtc->ops_lock);\r\nif (copy_from_user(&alarm, uarg, sizeof(alarm)))\r\nreturn -EFAULT;\r\nreturn rtc_set_alarm(rtc, &alarm);\r\ncase RTC_WKALM_RD:\r\nmutex_unlock(&rtc->ops_lock);\r\nerr = rtc_read_alarm(rtc, &alarm);\r\nif (err < 0)\r\nreturn err;\r\nif (copy_to_user(uarg, &alarm, sizeof(alarm)))\r\nerr = -EFAULT;\r\nreturn err;\r\ndefault:\r\nif (ops->ioctl) {\r\nerr = ops->ioctl(rtc->dev.parent, cmd, arg);\r\nif (err == -ENOIOCTLCMD)\r\nerr = -ENOTTY;\r\n} else\r\nerr = -ENOTTY;\r\nbreak;\r\n}\r\ndone:\r\nmutex_unlock(&rtc->ops_lock);\r\nreturn err;\r\n}\r\nstatic int rtc_dev_fasync(int fd, struct file *file, int on)\r\n{\r\nstruct rtc_device *rtc = file->private_data;\r\nreturn fasync_helper(fd, file, on, &rtc->async_queue);\r\n}\r\nstatic int rtc_dev_release(struct inode *inode, struct file *file)\r\n{\r\nstruct rtc_device *rtc = file->private_data;\r\nrtc_dev_ioctl(file, RTC_UIE_OFF, 0);\r\nrtc_update_irq_enable(rtc, 0);\r\nrtc_irq_set_state(rtc, NULL, 0);\r\nif (rtc->ops->release)\r\nrtc->ops->release(rtc->dev.parent);\r\nclear_bit_unlock(RTC_DEV_BUSY, &rtc->flags);\r\nreturn 0;\r\n}\r\nvoid rtc_dev_prepare(struct rtc_device *rtc)\r\n{\r\nif (!rtc_devt)\r\nreturn;\r\nif (rtc->id >= RTC_DEV_MAX) {\r\ndev_dbg(&rtc->dev, "%s: too many RTC devices\n", rtc->name);\r\nreturn;\r\n}\r\nrtc->dev.devt = MKDEV(MAJOR(rtc_devt), rtc->id);\r\n#ifdef CONFIG_RTC_INTF_DEV_UIE_EMUL\r\nINIT_WORK(&rtc->uie_task, rtc_uie_task);\r\nsetup_timer(&rtc->uie_timer, rtc_uie_timer, (unsigned long)rtc);\r\n#endif\r\ncdev_init(&rtc->char_dev, &rtc_dev_fops);\r\nrtc->char_dev.owner = rtc->owner;\r\n}\r\nvoid rtc_dev_add_device(struct rtc_device *rtc)\r\n{\r\nif (cdev_add(&rtc->char_dev, rtc->dev.devt, 1))\r\ndev_warn(&rtc->dev, "%s: failed to add char device %d:%d\n",\r\nrtc->name, MAJOR(rtc_devt), rtc->id);\r\nelse\r\ndev_dbg(&rtc->dev, "%s: dev (%d:%d)\n", rtc->name,\r\nMAJOR(rtc_devt), rtc->id);\r\n}\r\nvoid rtc_dev_del_device(struct rtc_device *rtc)\r\n{\r\nif (rtc->dev.devt)\r\ncdev_del(&rtc->char_dev);\r\n}\r\nvoid __init rtc_dev_init(void)\r\n{\r\nint err;\r\nerr = alloc_chrdev_region(&rtc_devt, 0, RTC_DEV_MAX, "rtc");\r\nif (err < 0)\r\npr_err("failed to allocate char dev region\n");\r\n}\r\nvoid __exit rtc_dev_exit(void)\r\n{\r\nif (rtc_devt)\r\nunregister_chrdev_region(rtc_devt, RTC_DEV_MAX);\r\n}
