int av7110_record_cb(struct dvb_filter_pes2ts *p2t, u8 *buf, size_t len)\r\n{\r\nstruct dvb_demux_feed *dvbdmxfeed = (struct dvb_demux_feed *) p2t->priv;\r\nif (!(dvbdmxfeed->ts_type & TS_PACKET))\r\nreturn 0;\r\nif (buf[3] == 0xe0)\r\nbuf[4] = buf[5] = 0;\r\nif (dvbdmxfeed->ts_type & TS_PAYLOAD_ONLY)\r\nreturn dvbdmxfeed->cb.ts(buf, len, NULL, 0,\r\n&dvbdmxfeed->feed.ts, DMX_OK);\r\nelse\r\nreturn dvb_filter_pes2ts(p2t, buf, len, 1);\r\n}\r\nstatic int dvb_filter_pes2ts_cb(void *priv, unsigned char *data)\r\n{\r\nstruct dvb_demux_feed *dvbdmxfeed = (struct dvb_demux_feed *) priv;\r\ndvbdmxfeed->cb.ts(data, 188, NULL, 0,\r\n&dvbdmxfeed->feed.ts, DMX_OK);\r\nreturn 0;\r\n}\r\nint av7110_av_start_record(struct av7110 *av7110, int av,\r\nstruct dvb_demux_feed *dvbdmxfeed)\r\n{\r\nint ret = 0;\r\nstruct dvb_demux *dvbdmx = dvbdmxfeed->demux;\r\ndprintk(2, "av7110:%p, , dvb_demux_feed:%p\n", av7110, dvbdmxfeed);\r\nif (av7110->playing || (av7110->rec_mode & av))\r\nreturn -EBUSY;\r\nav7110_fw_cmd(av7110, COMTYPE_REC_PLAY, __Stop, 0);\r\ndvbdmx->recording = 1;\r\nav7110->rec_mode |= av;\r\nswitch (av7110->rec_mode) {\r\ncase RP_AUDIO:\r\ndvb_filter_pes2ts_init(&av7110->p2t[0],\r\ndvbdmx->pesfilter[0]->pid,\r\ndvb_filter_pes2ts_cb,\r\n(void *) dvbdmx->pesfilter[0]);\r\nret = av7110_fw_cmd(av7110, COMTYPE_REC_PLAY, __Record, 2, AudioPES, 0);\r\nbreak;\r\ncase RP_VIDEO:\r\ndvb_filter_pes2ts_init(&av7110->p2t[1],\r\ndvbdmx->pesfilter[1]->pid,\r\ndvb_filter_pes2ts_cb,\r\n(void *) dvbdmx->pesfilter[1]);\r\nret = av7110_fw_cmd(av7110, COMTYPE_REC_PLAY, __Record, 2, VideoPES, 0);\r\nbreak;\r\ncase RP_AV:\r\ndvb_filter_pes2ts_init(&av7110->p2t[0],\r\ndvbdmx->pesfilter[0]->pid,\r\ndvb_filter_pes2ts_cb,\r\n(void *) dvbdmx->pesfilter[0]);\r\ndvb_filter_pes2ts_init(&av7110->p2t[1],\r\ndvbdmx->pesfilter[1]->pid,\r\ndvb_filter_pes2ts_cb,\r\n(void *) dvbdmx->pesfilter[1]);\r\nret = av7110_fw_cmd(av7110, COMTYPE_REC_PLAY, __Record, 2, AV_PES, 0);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nint av7110_av_start_play(struct av7110 *av7110, int av)\r\n{\r\nint ret = 0;\r\ndprintk(2, "av7110:%p, \n", av7110);\r\nif (av7110->rec_mode)\r\nreturn -EBUSY;\r\nif (av7110->playing & av)\r\nreturn -EBUSY;\r\nav7110_fw_cmd(av7110, COMTYPE_REC_PLAY, __Stop, 0);\r\nif (av7110->playing == RP_NONE) {\r\nav7110_ipack_reset(&av7110->ipack[0]);\r\nav7110_ipack_reset(&av7110->ipack[1]);\r\n}\r\nav7110->playing |= av;\r\nswitch (av7110->playing) {\r\ncase RP_AUDIO:\r\nret = av7110_fw_cmd(av7110, COMTYPE_REC_PLAY, __Play, 2, AudioPES, 0);\r\nbreak;\r\ncase RP_VIDEO:\r\nret = av7110_fw_cmd(av7110, COMTYPE_REC_PLAY, __Play, 2, VideoPES, 0);\r\nav7110->sinfo = 0;\r\nbreak;\r\ncase RP_AV:\r\nav7110->sinfo = 0;\r\nret = av7110_fw_cmd(av7110, COMTYPE_REC_PLAY, __Play, 2, AV_PES, 0);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nint av7110_av_stop(struct av7110 *av7110, int av)\r\n{\r\nint ret = 0;\r\ndprintk(2, "av7110:%p, \n", av7110);\r\nif (!(av7110->playing & av) && !(av7110->rec_mode & av))\r\nreturn 0;\r\nav7110_fw_cmd(av7110, COMTYPE_REC_PLAY, __Stop, 0);\r\nif (av7110->playing) {\r\nav7110->playing &= ~av;\r\nswitch (av7110->playing) {\r\ncase RP_AUDIO:\r\nret = av7110_fw_cmd(av7110, COMTYPE_REC_PLAY, __Play, 2, AudioPES, 0);\r\nbreak;\r\ncase RP_VIDEO:\r\nret = av7110_fw_cmd(av7110, COMTYPE_REC_PLAY, __Play, 2, VideoPES, 0);\r\nbreak;\r\ncase RP_NONE:\r\nret = av7110_set_vidmode(av7110, av7110->vidmode);\r\nbreak;\r\n}\r\n} else {\r\nav7110->rec_mode &= ~av;\r\nswitch (av7110->rec_mode) {\r\ncase RP_AUDIO:\r\nret = av7110_fw_cmd(av7110, COMTYPE_REC_PLAY, __Record, 2, AudioPES, 0);\r\nbreak;\r\ncase RP_VIDEO:\r\nret = av7110_fw_cmd(av7110, COMTYPE_REC_PLAY, __Record, 2, VideoPES, 0);\r\nbreak;\r\ncase RP_NONE:\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint av7110_pes_play(void *dest, struct dvb_ringbuffer *buf, int dlen)\r\n{\r\nint len;\r\nu32 sync;\r\nu16 blen;\r\nif (!dlen) {\r\nwake_up(&buf->queue);\r\nreturn -1;\r\n}\r\nwhile (1) {\r\nlen = dvb_ringbuffer_avail(buf);\r\nif (len < 6) {\r\nwake_up(&buf->queue);\r\nreturn -1;\r\n}\r\nsync = DVB_RINGBUFFER_PEEK(buf, 0) << 24;\r\nsync |= DVB_RINGBUFFER_PEEK(buf, 1) << 16;\r\nsync |= DVB_RINGBUFFER_PEEK(buf, 2) << 8;\r\nsync |= DVB_RINGBUFFER_PEEK(buf, 3);\r\nif (((sync &~ 0x0f) == 0x000001e0) ||\r\n((sync &~ 0x1f) == 0x000001c0) ||\r\n(sync == 0x000001bd))\r\nbreak;\r\nprintk("resync\n");\r\nDVB_RINGBUFFER_SKIP(buf, 1);\r\n}\r\nblen = DVB_RINGBUFFER_PEEK(buf, 4) << 8;\r\nblen |= DVB_RINGBUFFER_PEEK(buf, 5);\r\nblen += 6;\r\nif (len < blen || blen > dlen) {\r\nwake_up(&buf->queue);\r\nreturn -1;\r\n}\r\ndvb_ringbuffer_read(buf, dest, (size_t) blen);\r\ndprintk(2, "pread=0x%08lx, pwrite=0x%08lx\n",\r\n(unsigned long) buf->pread, (unsigned long) buf->pwrite);\r\nwake_up(&buf->queue);\r\nreturn blen;\r\n}\r\nint av7110_set_volume(struct av7110 *av7110, int volleft, int volright)\r\n{\r\nint err, vol, val, balance = 0;\r\ndprintk(2, "av7110:%p, \n", av7110);\r\nav7110->mixer.volume_left = volleft;\r\nav7110->mixer.volume_right = volright;\r\nswitch (av7110->adac_type) {\r\ncase DVB_ADAC_TI:\r\nvolleft = (volleft * 256) / 1036;\r\nvolright = (volright * 256) / 1036;\r\nif (volleft > 0x3f)\r\nvolleft = 0x3f;\r\nif (volright > 0x3f)\r\nvolright = 0x3f;\r\nif ((err = SendDAC(av7110, 3, 0x80 + volleft)))\r\nreturn err;\r\nreturn SendDAC(av7110, 4, volright);\r\ncase DVB_ADAC_CRYSTAL:\r\nvolleft = 127 - volleft / 2;\r\nvolright = 127 - volright / 2;\r\ni2c_writereg(av7110, 0x20, 0x03, volleft);\r\ni2c_writereg(av7110, 0x20, 0x04, volright);\r\nreturn 0;\r\ncase DVB_ADAC_MSP34x0:\r\nvol = (volleft > volright) ? volleft : volright;\r\nval = (vol * 0x73 / 255) << 8;\r\nif (vol > 0)\r\nbalance = ((volright - volleft) * 127) / vol;\r\nmsp_writereg(av7110, MSP_WR_DSP, 0x0001, balance << 8);\r\nmsp_writereg(av7110, MSP_WR_DSP, 0x0000, val);\r\nmsp_writereg(av7110, MSP_WR_DSP, 0x0006, val);\r\nreturn 0;\r\ncase DVB_ADAC_MSP34x5:\r\nvol = (volleft > volright) ? volleft : volright;\r\nval = (vol * 0x73 / 255) << 8;\r\nif (vol > 0)\r\nbalance = ((volright - volleft) * 127) / vol;\r\nmsp_writereg(av7110, MSP_WR_DSP, 0x0001, balance << 8);\r\nmsp_writereg(av7110, MSP_WR_DSP, 0x0000, val);\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nint av7110_set_vidmode(struct av7110 *av7110, enum av7110_video_mode mode)\r\n{\r\nint ret;\r\ndprintk(2, "av7110:%p, \n", av7110);\r\nret = av7110_fw_cmd(av7110, COMTYPE_ENCODER, LoadVidCode, 1, mode);\r\nif (!ret && !av7110->playing) {\r\nret = ChangePIDs(av7110, av7110->pids[DMX_PES_VIDEO],\r\nav7110->pids[DMX_PES_AUDIO],\r\nav7110->pids[DMX_PES_TELETEXT],\r\n0, av7110->pids[DMX_PES_PCR]);\r\nif (!ret)\r\nret = av7110_fw_cmd(av7110, COMTYPE_PIDFILTER, Scan, 0);\r\n}\r\nreturn ret;\r\n}\r\nstatic int get_video_format(struct av7110 *av7110, u8 *buf, int count)\r\n{\r\nint i;\r\nint hsize, vsize;\r\nint sw;\r\nu8 *p;\r\nint ret = 0;\r\ndprintk(2, "av7110:%p, \n", av7110);\r\nif (av7110->sinfo)\r\nreturn 0;\r\nfor (i = 7; i < count - 10; i++) {\r\np = buf + i;\r\nif (p[0] || p[1] || p[2] != 0x01 || p[3] != 0xb3)\r\ncontinue;\r\np += 4;\r\nhsize = ((p[1] &0xF0) >> 4) | (p[0] << 4);\r\nvsize = ((p[1] &0x0F) << 8) | (p[2]);\r\nsw = (p[3] & 0x0F);\r\nret = av7110_set_vidmode(av7110, sw2mode[sw]);\r\nif (!ret) {\r\ndprintk(2, "playback %dx%d fr=%d\n", hsize, vsize, sw);\r\nav7110->sinfo = 1;\r\n}\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic inline long aux_ring_buffer_write(struct dvb_ringbuffer *rbuf,\r\nconst u8 *buf, unsigned long count)\r\n{\r\nunsigned long todo = count;\r\nint free;\r\nwhile (todo > 0) {\r\nif (dvb_ringbuffer_free(rbuf) < 2048) {\r\nif (wait_event_interruptible(rbuf->queue,\r\n(dvb_ringbuffer_free(rbuf) >= 2048)))\r\nreturn count - todo;\r\n}\r\nfree = dvb_ringbuffer_free(rbuf);\r\nif (free > todo)\r\nfree = todo;\r\ndvb_ringbuffer_write(rbuf, buf, free);\r\ntodo -= free;\r\nbuf += free;\r\n}\r\nreturn count - todo;\r\n}\r\nstatic void play_video_cb(u8 *buf, int count, void *priv)\r\n{\r\nstruct av7110 *av7110 = (struct av7110 *) priv;\r\ndprintk(2, "av7110:%p, \n", av7110);\r\nif ((buf[3] & 0xe0) == 0xe0) {\r\nget_video_format(av7110, buf, count);\r\naux_ring_buffer_write(&av7110->avout, buf, count);\r\n} else\r\naux_ring_buffer_write(&av7110->aout, buf, count);\r\n}\r\nstatic void play_audio_cb(u8 *buf, int count, void *priv)\r\n{\r\nstruct av7110 *av7110 = (struct av7110 *) priv;\r\ndprintk(2, "av7110:%p, \n", av7110);\r\naux_ring_buffer_write(&av7110->aout, buf, count);\r\n}\r\nstatic ssize_t ts_play(struct av7110 *av7110, const char __user *buf,\r\nunsigned long count, int nonblock, int type)\r\n{\r\nstruct dvb_ringbuffer *rb;\r\nu8 *kb;\r\nunsigned long todo = count;\r\ndprintk(2, "%s: type %d cnt %lu\n", __func__, type, count);\r\nrb = (type) ? &av7110->avout : &av7110->aout;\r\nkb = av7110->kbuf[type];\r\nif (!kb)\r\nreturn -ENOBUFS;\r\nif (nonblock && !FREE_COND_TS)\r\nreturn -EWOULDBLOCK;\r\nwhile (todo >= TS_SIZE) {\r\nif (!FREE_COND_TS) {\r\nif (nonblock)\r\nreturn count - todo;\r\nif (wait_event_interruptible(rb->queue, FREE_COND_TS))\r\nreturn count - todo;\r\n}\r\nif (copy_from_user(kb, buf, TS_SIZE))\r\nreturn -EFAULT;\r\nwrite_ts_to_decoder(av7110, type, kb, TS_SIZE);\r\ntodo -= TS_SIZE;\r\nbuf += TS_SIZE;\r\n}\r\nreturn count - todo;\r\n}\r\nstatic ssize_t dvb_play(struct av7110 *av7110, const char __user *buf,\r\nunsigned long count, int nonblock, int type)\r\n{\r\nunsigned long todo = count, n;\r\ndprintk(2, "av7110:%p, \n", av7110);\r\nif (!av7110->kbuf[type])\r\nreturn -ENOBUFS;\r\nif (nonblock && !FREE_COND)\r\nreturn -EWOULDBLOCK;\r\nwhile (todo > 0) {\r\nif (!FREE_COND) {\r\nif (nonblock)\r\nreturn count - todo;\r\nif (wait_event_interruptible(av7110->avout.queue,\r\nFREE_COND))\r\nreturn count - todo;\r\n}\r\nn = todo;\r\nif (n > IPACKS * 2)\r\nn = IPACKS * 2;\r\nif (copy_from_user(av7110->kbuf[type], buf, n))\r\nreturn -EFAULT;\r\nav7110_ipack_instant_repack(av7110->kbuf[type], n,\r\n&av7110->ipack[type]);\r\ntodo -= n;\r\nbuf += n;\r\n}\r\nreturn count - todo;\r\n}\r\nstatic ssize_t dvb_play_kernel(struct av7110 *av7110, const u8 *buf,\r\nunsigned long count, int nonblock, int type)\r\n{\r\nunsigned long todo = count, n;\r\ndprintk(2, "av7110:%p, \n", av7110);\r\nif (!av7110->kbuf[type])\r\nreturn -ENOBUFS;\r\nif (nonblock && !FREE_COND)\r\nreturn -EWOULDBLOCK;\r\nwhile (todo > 0) {\r\nif (!FREE_COND) {\r\nif (nonblock)\r\nreturn count - todo;\r\nif (wait_event_interruptible(av7110->avout.queue,\r\nFREE_COND))\r\nreturn count - todo;\r\n}\r\nn = todo;\r\nif (n > IPACKS * 2)\r\nn = IPACKS * 2;\r\nav7110_ipack_instant_repack(buf, n, &av7110->ipack[type]);\r\ntodo -= n;\r\nbuf += n;\r\n}\r\nreturn count - todo;\r\n}\r\nstatic ssize_t dvb_aplay(struct av7110 *av7110, const char __user *buf,\r\nunsigned long count, int nonblock, int type)\r\n{\r\nunsigned long todo = count, n;\r\ndprintk(2, "av7110:%p, \n", av7110);\r\nif (!av7110->kbuf[type])\r\nreturn -ENOBUFS;\r\nif (nonblock && dvb_ringbuffer_free(&av7110->aout) < 20 * 1024)\r\nreturn -EWOULDBLOCK;\r\nwhile (todo > 0) {\r\nif (dvb_ringbuffer_free(&av7110->aout) < 20 * 1024) {\r\nif (nonblock)\r\nreturn count - todo;\r\nif (wait_event_interruptible(av7110->aout.queue,\r\n(dvb_ringbuffer_free(&av7110->aout) >= 20 * 1024)))\r\nreturn count-todo;\r\n}\r\nn = todo;\r\nif (n > IPACKS * 2)\r\nn = IPACKS * 2;\r\nif (copy_from_user(av7110->kbuf[type], buf, n))\r\nreturn -EFAULT;\r\nav7110_ipack_instant_repack(av7110->kbuf[type], n,\r\n&av7110->ipack[type]);\r\ntodo -= n;\r\nbuf += n;\r\n}\r\nreturn count - todo;\r\n}\r\nvoid av7110_p2t_init(struct av7110_p2t *p, struct dvb_demux_feed *feed)\r\n{\r\nmemset(p->pes, 0, TS_SIZE);\r\np->counter = 0;\r\np->pos = 0;\r\np->frags = 0;\r\nif (feed)\r\np->feed = feed;\r\n}\r\nstatic void clear_p2t(struct av7110_p2t *p)\r\n{\r\nmemset(p->pes, 0, TS_SIZE);\r\np->pos = 0;\r\np->frags = 0;\r\n}\r\nstatic int find_pes_header(u8 const *buf, long int length, int *frags)\r\n{\r\nint c = 0;\r\nint found = 0;\r\n*frags = 0;\r\nwhile (c < length - 3 && !found) {\r\nif (buf[c] == 0x00 && buf[c + 1] == 0x00 &&\r\nbuf[c + 2] == 0x01) {\r\nswitch ( buf[c + 3] ) {\r\ncase PROG_STREAM_MAP:\r\ncase PRIVATE_STREAM2:\r\ncase PROG_STREAM_DIR:\r\ncase ECM_STREAM :\r\ncase EMM_STREAM :\r\ncase PADDING_STREAM :\r\ncase DSM_CC_STREAM :\r\ncase ISO13522_STREAM:\r\ncase PRIVATE_STREAM1:\r\ncase AUDIO_STREAM_S ... AUDIO_STREAM_E:\r\ncase VIDEO_STREAM_S ... VIDEO_STREAM_E:\r\nfound = 1;\r\nbreak;\r\ndefault:\r\nc++;\r\nbreak;\r\n}\r\n} else\r\nc++;\r\n}\r\nif (c == length - 3 && !found) {\r\nif (buf[length - 1] == 0x00)\r\n*frags = 1;\r\nif (buf[length - 2] == 0x00 &&\r\nbuf[length - 1] == 0x00)\r\n*frags = 2;\r\nif (buf[length - 3] == 0x00 &&\r\nbuf[length - 2] == 0x00 &&\r\nbuf[length - 1] == 0x01)\r\n*frags = 3;\r\nreturn -1;\r\n}\r\nreturn c;\r\n}\r\nvoid av7110_p2t_write(u8 const *buf, long int length, u16 pid, struct av7110_p2t *p)\r\n{\r\nint c, c2, l, add;\r\nint check, rest;\r\nc = 0;\r\nc2 = 0;\r\nif (p->frags){\r\ncheck = 0;\r\nswitch(p->frags) {\r\ncase 1:\r\nif (buf[c] == 0x00 && buf[c + 1] == 0x01) {\r\ncheck = 1;\r\nc += 2;\r\n}\r\nbreak;\r\ncase 2:\r\nif (buf[c] == 0x01) {\r\ncheck = 1;\r\nc++;\r\n}\r\nbreak;\r\ncase 3:\r\ncheck = 1;\r\n}\r\nif (check) {\r\nswitch (buf[c]) {\r\ncase PROG_STREAM_MAP:\r\ncase PRIVATE_STREAM2:\r\ncase PROG_STREAM_DIR:\r\ncase ECM_STREAM :\r\ncase EMM_STREAM :\r\ncase PADDING_STREAM :\r\ncase DSM_CC_STREAM :\r\ncase ISO13522_STREAM:\r\ncase PRIVATE_STREAM1:\r\ncase AUDIO_STREAM_S ... AUDIO_STREAM_E:\r\ncase VIDEO_STREAM_S ... VIDEO_STREAM_E:\r\np->pes[0] = 0x00;\r\np->pes[1] = 0x00;\r\np->pes[2] = 0x01;\r\np->pes[3] = buf[c];\r\np->pos = 4;\r\nmemcpy(p->pes + p->pos, buf + c, (TS_SIZE - 4) - p->pos);\r\nc += (TS_SIZE - 4) - p->pos;\r\np_to_t(p->pes, (TS_SIZE - 4), pid, &p->counter, p->feed);\r\nclear_p2t(p);\r\nbreak;\r\ndefault:\r\nc = 0;\r\nbreak;\r\n}\r\n}\r\np->frags = 0;\r\n}\r\nif (p->pos) {\r\nc2 = find_pes_header(buf + c, length - c, &p->frags);\r\nif (c2 >= 0 && c2 < (TS_SIZE - 4) - p->pos)\r\nl = c2+c;\r\nelse\r\nl = (TS_SIZE - 4) - p->pos;\r\nmemcpy(p->pes + p->pos, buf, l);\r\nc += l;\r\np->pos += l;\r\np_to_t(p->pes, p->pos, pid, &p->counter, p->feed);\r\nclear_p2t(p);\r\n}\r\nadd = 0;\r\nwhile (c < length) {\r\nc2 = find_pes_header(buf + c + add, length - c - add, &p->frags);\r\nif (c2 >= 0) {\r\nc2 += c + add;\r\nif (c2 > c){\r\np_to_t(buf + c, c2 - c, pid, &p->counter, p->feed);\r\nc = c2;\r\nclear_p2t(p);\r\nadd = 0;\r\n} else\r\nadd = 1;\r\n} else {\r\nl = length - c;\r\nrest = l % (TS_SIZE - 4);\r\nl -= rest;\r\np_to_t(buf + c, l, pid, &p->counter, p->feed);\r\nmemcpy(p->pes, buf + c + l, rest);\r\np->pos = rest;\r\nc = length;\r\n}\r\n}\r\n}\r\nstatic int write_ts_header2(u16 pid, u8 *counter, int pes_start, u8 *buf, u8 length)\r\n{\r\nint i;\r\nint c = 0;\r\nint fill;\r\nu8 tshead[4] = { 0x47, 0x00, 0x00, 0x10 };\r\nfill = (TS_SIZE - 4) - length;\r\nif (pes_start)\r\ntshead[1] = 0x40;\r\nif (fill)\r\ntshead[3] = 0x30;\r\ntshead[1] |= (u8)((pid & 0x1F00) >> 8);\r\ntshead[2] |= (u8)(pid & 0x00FF);\r\ntshead[3] |= ((*counter)++ & 0x0F);\r\nmemcpy(buf, tshead, 4);\r\nc += 4;\r\nif (fill) {\r\nbuf[4] = fill - 1;\r\nc++;\r\nif (fill > 1) {\r\nbuf[5] = 0x00;\r\nc++;\r\n}\r\nfor (i = 6; i < fill + 4; i++) {\r\nbuf[i] = 0xFF;\r\nc++;\r\n}\r\n}\r\nreturn c;\r\n}\r\nstatic void p_to_t(u8 const *buf, long int length, u16 pid, u8 *counter,\r\nstruct dvb_demux_feed *feed)\r\n{\r\nint l, pes_start;\r\nu8 obuf[TS_SIZE];\r\nlong c = 0;\r\npes_start = 0;\r\nif (length > 3 &&\r\nbuf[0] == 0x00 && buf[1] == 0x00 && buf[2] == 0x01)\r\nswitch (buf[3]) {\r\ncase PROG_STREAM_MAP:\r\ncase PRIVATE_STREAM2:\r\ncase PROG_STREAM_DIR:\r\ncase ECM_STREAM :\r\ncase EMM_STREAM :\r\ncase PADDING_STREAM :\r\ncase DSM_CC_STREAM :\r\ncase ISO13522_STREAM:\r\ncase PRIVATE_STREAM1:\r\ncase AUDIO_STREAM_S ... AUDIO_STREAM_E:\r\ncase VIDEO_STREAM_S ... VIDEO_STREAM_E:\r\npes_start = 1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nwhile (c < length) {\r\nmemset(obuf, 0, TS_SIZE);\r\nif (length - c >= (TS_SIZE - 4)){\r\nl = write_ts_header2(pid, counter, pes_start,\r\nobuf, (TS_SIZE - 4));\r\nmemcpy(obuf + l, buf + c, TS_SIZE - l);\r\nc += TS_SIZE - l;\r\n} else {\r\nl = write_ts_header2(pid, counter, pes_start,\r\nobuf, length - c);\r\nmemcpy(obuf + l, buf + c, TS_SIZE - l);\r\nc = length;\r\n}\r\nfeed->cb.ts(obuf, 188, NULL, 0, &feed->feed.ts, DMX_OK);\r\npes_start = 0;\r\n}\r\n}\r\nstatic int write_ts_to_decoder(struct av7110 *av7110, int type, const u8 *buf, size_t len)\r\n{\r\nstruct ipack *ipack = &av7110->ipack[type];\r\nif (buf[1] & TRANS_ERROR) {\r\nav7110_ipack_reset(ipack);\r\nreturn -1;\r\n}\r\nif (!(buf[3] & PAYLOAD))\r\nreturn -1;\r\nif (buf[1] & PAY_START)\r\nav7110_ipack_flush(ipack);\r\nif (buf[3] & ADAPT_FIELD) {\r\nlen -= buf[4] + 1;\r\nbuf += buf[4] + 1;\r\nif (!len)\r\nreturn 0;\r\n}\r\nav7110_ipack_instant_repack(buf + 4, len - 4, ipack);\r\nreturn 0;\r\n}\r\nint av7110_write_to_decoder(struct dvb_demux_feed *feed, const u8 *buf, size_t len)\r\n{\r\nstruct dvb_demux *demux = feed->demux;\r\nstruct av7110 *av7110 = (struct av7110 *) demux->priv;\r\ndprintk(2, "av7110:%p, \n", av7110);\r\nif (av7110->full_ts && demux->dmx.frontend->source != DMX_MEMORY_FE)\r\nreturn 0;\r\nswitch (feed->pes_type) {\r\ncase 0:\r\nif (av7110->audiostate.stream_source == AUDIO_SOURCE_MEMORY)\r\nreturn -EINVAL;\r\nbreak;\r\ncase 1:\r\nif (av7110->videostate.stream_source == VIDEO_SOURCE_MEMORY)\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nreturn write_ts_to_decoder(av7110, feed->pes_type, buf, len);\r\n}\r\nvoid dvb_video_add_event(struct av7110 *av7110, struct video_event *event)\r\n{\r\nstruct dvb_video_events *events = &av7110->video_events;\r\nint wp;\r\nspin_lock_bh(&events->lock);\r\nwp = (events->eventw + 1) % MAX_VIDEO_EVENT;\r\nif (wp == events->eventr) {\r\nevents->overflow = 1;\r\nevents->eventr = (events->eventr + 1) % MAX_VIDEO_EVENT;\r\n}\r\nmemcpy(&events->events[events->eventw], event, sizeof(struct video_event));\r\nevents->eventw = wp;\r\nspin_unlock_bh(&events->lock);\r\nwake_up_interruptible(&events->wait_queue);\r\n}\r\nstatic int dvb_video_get_event (struct av7110 *av7110, struct video_event *event, int flags)\r\n{\r\nstruct dvb_video_events *events = &av7110->video_events;\r\nif (events->overflow) {\r\nevents->overflow = 0;\r\nreturn -EOVERFLOW;\r\n}\r\nif (events->eventw == events->eventr) {\r\nint ret;\r\nif (flags & O_NONBLOCK)\r\nreturn -EWOULDBLOCK;\r\nret = wait_event_interruptible(events->wait_queue,\r\nevents->eventw != events->eventr);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nspin_lock_bh(&events->lock);\r\nmemcpy(event, &events->events[events->eventr],\r\nsizeof(struct video_event));\r\nevents->eventr = (events->eventr + 1) % MAX_VIDEO_EVENT;\r\nspin_unlock_bh(&events->lock);\r\nreturn 0;\r\n}\r\nstatic unsigned int dvb_video_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct dvb_device *dvbdev = file->private_data;\r\nstruct av7110 *av7110 = dvbdev->priv;\r\nunsigned int mask = 0;\r\ndprintk(2, "av7110:%p, \n", av7110);\r\nif ((file->f_flags & O_ACCMODE) != O_RDONLY)\r\npoll_wait(file, &av7110->avout.queue, wait);\r\npoll_wait(file, &av7110->video_events.wait_queue, wait);\r\nif (av7110->video_events.eventw != av7110->video_events.eventr)\r\nmask = POLLPRI;\r\nif ((file->f_flags & O_ACCMODE) != O_RDONLY) {\r\nif (av7110->playing) {\r\nif (FREE_COND)\r\nmask |= (POLLOUT | POLLWRNORM);\r\n} else {\r\nmask |= (POLLOUT | POLLWRNORM);\r\n}\r\n}\r\nreturn mask;\r\n}\r\nstatic ssize_t dvb_video_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct dvb_device *dvbdev = file->private_data;\r\nstruct av7110 *av7110 = dvbdev->priv;\r\nunsigned char c;\r\ndprintk(2, "av7110:%p, \n", av7110);\r\nif ((file->f_flags & O_ACCMODE) == O_RDONLY)\r\nreturn -EPERM;\r\nif (av7110->videostate.stream_source != VIDEO_SOURCE_MEMORY)\r\nreturn -EPERM;\r\nif (get_user(c, buf))\r\nreturn -EFAULT;\r\nif (c == 0x47 && count % TS_SIZE == 0)\r\nreturn ts_play(av7110, buf, count, file->f_flags & O_NONBLOCK, 1);\r\nelse\r\nreturn dvb_play(av7110, buf, count, file->f_flags & O_NONBLOCK, 1);\r\n}\r\nstatic unsigned int dvb_audio_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct dvb_device *dvbdev = file->private_data;\r\nstruct av7110 *av7110 = dvbdev->priv;\r\nunsigned int mask = 0;\r\ndprintk(2, "av7110:%p, \n", av7110);\r\npoll_wait(file, &av7110->aout.queue, wait);\r\nif (av7110->playing) {\r\nif (dvb_ringbuffer_free(&av7110->aout) >= 20 * 1024)\r\nmask |= (POLLOUT | POLLWRNORM);\r\n} else\r\nmask = (POLLOUT | POLLWRNORM);\r\nreturn mask;\r\n}\r\nstatic ssize_t dvb_audio_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct dvb_device *dvbdev = file->private_data;\r\nstruct av7110 *av7110 = dvbdev->priv;\r\nunsigned char c;\r\ndprintk(2, "av7110:%p, \n", av7110);\r\nif (av7110->audiostate.stream_source != AUDIO_SOURCE_MEMORY) {\r\nprintk(KERN_ERR "not audio source memory\n");\r\nreturn -EPERM;\r\n}\r\nif (get_user(c, buf))\r\nreturn -EFAULT;\r\nif (c == 0x47 && count % TS_SIZE == 0)\r\nreturn ts_play(av7110, buf, count, file->f_flags & O_NONBLOCK, 0);\r\nelse\r\nreturn dvb_aplay(av7110, buf, count, file->f_flags & O_NONBLOCK, 0);\r\n}\r\nstatic int play_iframe(struct av7110 *av7110, char __user *buf, unsigned int len, int nonblock)\r\n{\r\nunsigned i, n;\r\nint progressive = 0;\r\nint match = 0;\r\ndprintk(2, "av7110:%p, \n", av7110);\r\nif (!(av7110->playing & RP_VIDEO)) {\r\nif (av7110_av_start_play(av7110, RP_VIDEO) < 0)\r\nreturn -EBUSY;\r\n}\r\nfor (i = 0; i < len; i++) {\r\nunsigned char c;\r\nif (get_user(c, buf + i))\r\nreturn -EFAULT;\r\nif (match == 5) {\r\nprogressive = c & 0x08;\r\nmatch = 0;\r\n}\r\nif (c == 0x00) {\r\nmatch = (match == 1 || match == 2) ? 2 : 1;\r\ncontinue;\r\n}\r\nswitch (match++) {\r\ncase 2: if (c == 0x01)\r\ncontinue;\r\nbreak;\r\ncase 3: if (c == 0xb5)\r\ncontinue;\r\nbreak;\r\ncase 4: if ((c & 0xf0) == 0x10)\r\ncontinue;\r\nbreak;\r\n}\r\nmatch = 0;\r\n}\r\nn = MIN_IFRAME / len + 1;\r\ndvb_play_kernel(av7110, iframe_header, sizeof(iframe_header), 0, 1);\r\nfor (i = 0; i < n; i++)\r\ndvb_play(av7110, buf, len, 0, 1);\r\nav7110_ipack_flush(&av7110->ipack[1]);\r\nif (progressive)\r\nreturn vidcom(av7110, AV_VIDEO_CMD_FREEZE, 1);\r\nelse\r\nreturn 0;\r\n}\r\nstatic int dvb_video_ioctl(struct file *file,\r\nunsigned int cmd, void *parg)\r\n{\r\nstruct dvb_device *dvbdev = file->private_data;\r\nstruct av7110 *av7110 = dvbdev->priv;\r\nunsigned long arg = (unsigned long) parg;\r\nint ret = 0;\r\ndprintk(1, "av7110:%p, cmd=%04x\n", av7110,cmd);\r\nif ((file->f_flags & O_ACCMODE) == O_RDONLY) {\r\nif ( cmd != VIDEO_GET_STATUS && cmd != VIDEO_GET_EVENT &&\r\ncmd != VIDEO_GET_SIZE ) {\r\nreturn -EPERM;\r\n}\r\n}\r\nif (mutex_lock_interruptible(&av7110->ioctl_mutex))\r\nreturn -ERESTARTSYS;\r\nswitch (cmd) {\r\ncase VIDEO_STOP:\r\nav7110->videostate.play_state = VIDEO_STOPPED;\r\nif (av7110->videostate.stream_source == VIDEO_SOURCE_MEMORY)\r\nret = av7110_av_stop(av7110, RP_VIDEO);\r\nelse\r\nret = vidcom(av7110, AV_VIDEO_CMD_STOP,\r\nav7110->videostate.video_blank ? 0 : 1);\r\nif (!ret)\r\nav7110->trickmode = TRICK_NONE;\r\nbreak;\r\ncase VIDEO_PLAY:\r\nav7110->trickmode = TRICK_NONE;\r\nif (av7110->videostate.play_state == VIDEO_FREEZED) {\r\nav7110->videostate.play_state = VIDEO_PLAYING;\r\nret = vidcom(av7110, AV_VIDEO_CMD_PLAY, 0);\r\nif (ret)\r\nbreak;\r\n}\r\nif (av7110->videostate.stream_source == VIDEO_SOURCE_MEMORY) {\r\nif (av7110->playing == RP_AV) {\r\nret = av7110_fw_cmd(av7110, COMTYPE_REC_PLAY, __Stop, 0);\r\nif (ret)\r\nbreak;\r\nav7110->playing &= ~RP_VIDEO;\r\n}\r\nret = av7110_av_start_play(av7110, RP_VIDEO);\r\n}\r\nif (!ret)\r\nret = vidcom(av7110, AV_VIDEO_CMD_PLAY, 0);\r\nif (!ret)\r\nav7110->videostate.play_state = VIDEO_PLAYING;\r\nbreak;\r\ncase VIDEO_FREEZE:\r\nav7110->videostate.play_state = VIDEO_FREEZED;\r\nif (av7110->playing & RP_VIDEO)\r\nret = av7110_fw_cmd(av7110, COMTYPE_REC_PLAY, __Pause, 0);\r\nelse\r\nret = vidcom(av7110, AV_VIDEO_CMD_FREEZE, 1);\r\nif (!ret)\r\nav7110->trickmode = TRICK_FREEZE;\r\nbreak;\r\ncase VIDEO_CONTINUE:\r\nif (av7110->playing & RP_VIDEO)\r\nret = av7110_fw_cmd(av7110, COMTYPE_REC_PLAY, __Continue, 0);\r\nif (!ret)\r\nret = vidcom(av7110, AV_VIDEO_CMD_PLAY, 0);\r\nif (!ret) {\r\nav7110->videostate.play_state = VIDEO_PLAYING;\r\nav7110->trickmode = TRICK_NONE;\r\n}\r\nbreak;\r\ncase VIDEO_SELECT_SOURCE:\r\nav7110->videostate.stream_source = (video_stream_source_t) arg;\r\nbreak;\r\ncase VIDEO_SET_BLANK:\r\nav7110->videostate.video_blank = (int) arg;\r\nbreak;\r\ncase VIDEO_GET_STATUS:\r\nmemcpy(parg, &av7110->videostate, sizeof(struct video_status));\r\nbreak;\r\ncase VIDEO_GET_EVENT:\r\nret = dvb_video_get_event(av7110, parg, file->f_flags);\r\nbreak;\r\ncase VIDEO_GET_SIZE:\r\nmemcpy(parg, &av7110->video_size, sizeof(video_size_t));\r\nbreak;\r\ncase VIDEO_SET_DISPLAY_FORMAT:\r\n{\r\nvideo_displayformat_t format = (video_displayformat_t) arg;\r\nswitch (format) {\r\ncase VIDEO_PAN_SCAN:\r\nav7110->display_panscan = VID_PAN_SCAN_PREF;\r\nbreak;\r\ncase VIDEO_LETTER_BOX:\r\nav7110->display_panscan = VID_VC_AND_PS_PREF;\r\nbreak;\r\ncase VIDEO_CENTER_CUT_OUT:\r\nav7110->display_panscan = VID_CENTRE_CUT_PREF;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nif (ret < 0)\r\nbreak;\r\nav7110->videostate.display_format = format;\r\nret = av7110_fw_cmd(av7110, COMTYPE_ENCODER, SetPanScanType,\r\n1, av7110->display_panscan);\r\nbreak;\r\n}\r\ncase VIDEO_SET_FORMAT:\r\nif (arg > 1) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nav7110->display_ar = arg;\r\nret = av7110_fw_cmd(av7110, COMTYPE_ENCODER, SetMonitorType,\r\n1, (u16) arg);\r\nbreak;\r\ncase VIDEO_STILLPICTURE:\r\n{\r\nstruct video_still_picture *pic =\r\n(struct video_still_picture *) parg;\r\nav7110->videostate.stream_source = VIDEO_SOURCE_MEMORY;\r\ndvb_ringbuffer_flush_spinlock_wakeup(&av7110->avout);\r\nret = play_iframe(av7110, pic->iFrame, pic->size,\r\nfile->f_flags & O_NONBLOCK);\r\nbreak;\r\n}\r\ncase VIDEO_FAST_FORWARD:\r\nif (av7110->playing & RP_VIDEO)\r\nret = av7110_fw_cmd(av7110, COMTYPE_REC_PLAY,\r\n__Scan_I, 2, AV_PES, 0);\r\nelse\r\nret = vidcom(av7110, AV_VIDEO_CMD_FFWD, arg);\r\nif (!ret) {\r\nav7110->trickmode = TRICK_FAST;\r\nav7110->videostate.play_state = VIDEO_PLAYING;\r\n}\r\nbreak;\r\ncase VIDEO_SLOWMOTION:\r\nif (av7110->playing&RP_VIDEO) {\r\nif (av7110->trickmode != TRICK_SLOW)\r\nret = av7110_fw_cmd(av7110, COMTYPE_REC_PLAY, __Slow, 2, 0, 0);\r\nif (!ret)\r\nret = vidcom(av7110, AV_VIDEO_CMD_SLOW, arg);\r\n} else {\r\nret = vidcom(av7110, AV_VIDEO_CMD_PLAY, 0);\r\nif (!ret)\r\nret = vidcom(av7110, AV_VIDEO_CMD_STOP, 0);\r\nif (!ret)\r\nret = vidcom(av7110, AV_VIDEO_CMD_SLOW, arg);\r\n}\r\nif (!ret) {\r\nav7110->trickmode = TRICK_SLOW;\r\nav7110->videostate.play_state = VIDEO_PLAYING;\r\n}\r\nbreak;\r\ncase VIDEO_GET_CAPABILITIES:\r\n*(int *)parg = VIDEO_CAP_MPEG1 | VIDEO_CAP_MPEG2 |\r\nVIDEO_CAP_SYS | VIDEO_CAP_PROG;\r\nbreak;\r\ncase VIDEO_CLEAR_BUFFER:\r\ndvb_ringbuffer_flush_spinlock_wakeup(&av7110->avout);\r\nav7110_ipack_reset(&av7110->ipack[1]);\r\nif (av7110->playing == RP_AV) {\r\nret = av7110_fw_cmd(av7110, COMTYPE_REC_PLAY,\r\n__Play, 2, AV_PES, 0);\r\nif (ret)\r\nbreak;\r\nif (av7110->trickmode == TRICK_FAST)\r\nret = av7110_fw_cmd(av7110, COMTYPE_REC_PLAY,\r\n__Scan_I, 2, AV_PES, 0);\r\nif (av7110->trickmode == TRICK_SLOW) {\r\nret = av7110_fw_cmd(av7110, COMTYPE_REC_PLAY,\r\n__Slow, 2, 0, 0);\r\nif (!ret)\r\nret = vidcom(av7110, AV_VIDEO_CMD_SLOW, arg);\r\n}\r\nif (av7110->trickmode == TRICK_FREEZE)\r\nret = vidcom(av7110, AV_VIDEO_CMD_STOP, 1);\r\n}\r\nbreak;\r\ncase VIDEO_SET_STREAMTYPE:\r\nbreak;\r\ndefault:\r\nret = -ENOIOCTLCMD;\r\nbreak;\r\n}\r\nmutex_unlock(&av7110->ioctl_mutex);\r\nreturn ret;\r\n}\r\nstatic int dvb_audio_ioctl(struct file *file,\r\nunsigned int cmd, void *parg)\r\n{\r\nstruct dvb_device *dvbdev = file->private_data;\r\nstruct av7110 *av7110 = dvbdev->priv;\r\nunsigned long arg = (unsigned long) parg;\r\nint ret = 0;\r\ndprintk(1, "av7110:%p, cmd=%04x\n", av7110,cmd);\r\nif (((file->f_flags & O_ACCMODE) == O_RDONLY) &&\r\n(cmd != AUDIO_GET_STATUS))\r\nreturn -EPERM;\r\nif (mutex_lock_interruptible(&av7110->ioctl_mutex))\r\nreturn -ERESTARTSYS;\r\nswitch (cmd) {\r\ncase AUDIO_STOP:\r\nif (av7110->audiostate.stream_source == AUDIO_SOURCE_MEMORY)\r\nret = av7110_av_stop(av7110, RP_AUDIO);\r\nelse\r\nret = audcom(av7110, AUDIO_CMD_MUTE);\r\nif (!ret)\r\nav7110->audiostate.play_state = AUDIO_STOPPED;\r\nbreak;\r\ncase AUDIO_PLAY:\r\nif (av7110->audiostate.stream_source == AUDIO_SOURCE_MEMORY)\r\nret = av7110_av_start_play(av7110, RP_AUDIO);\r\nif (!ret)\r\nret = audcom(av7110, AUDIO_CMD_UNMUTE);\r\nif (!ret)\r\nav7110->audiostate.play_state = AUDIO_PLAYING;\r\nbreak;\r\ncase AUDIO_PAUSE:\r\nret = audcom(av7110, AUDIO_CMD_MUTE);\r\nif (!ret)\r\nav7110->audiostate.play_state = AUDIO_PAUSED;\r\nbreak;\r\ncase AUDIO_CONTINUE:\r\nif (av7110->audiostate.play_state == AUDIO_PAUSED) {\r\nav7110->audiostate.play_state = AUDIO_PLAYING;\r\nret = audcom(av7110, AUDIO_CMD_UNMUTE | AUDIO_CMD_PCM16);\r\n}\r\nbreak;\r\ncase AUDIO_SELECT_SOURCE:\r\nav7110->audiostate.stream_source = (audio_stream_source_t) arg;\r\nbreak;\r\ncase AUDIO_SET_MUTE:\r\n{\r\nret = audcom(av7110, arg ? AUDIO_CMD_MUTE : AUDIO_CMD_UNMUTE);\r\nif (!ret)\r\nav7110->audiostate.mute_state = (int) arg;\r\nbreak;\r\n}\r\ncase AUDIO_SET_AV_SYNC:\r\nav7110->audiostate.AV_sync_state = (int) arg;\r\nret = audcom(av7110, arg ? AUDIO_CMD_SYNC_ON : AUDIO_CMD_SYNC_OFF);\r\nbreak;\r\ncase AUDIO_SET_BYPASS_MODE:\r\nif (FW_VERSION(av7110->arm_app) < 0x2621)\r\nret = -EINVAL;\r\nav7110->audiostate.bypass_mode = (int)arg;\r\nbreak;\r\ncase AUDIO_CHANNEL_SELECT:\r\nav7110->audiostate.channel_select = (audio_channel_select_t) arg;\r\nswitch(av7110->audiostate.channel_select) {\r\ncase AUDIO_STEREO:\r\nret = audcom(av7110, AUDIO_CMD_STEREO);\r\nif (!ret) {\r\nif (av7110->adac_type == DVB_ADAC_CRYSTAL)\r\ni2c_writereg(av7110, 0x20, 0x02, 0x49);\r\nelse if (av7110->adac_type == DVB_ADAC_MSP34x5)\r\nmsp_writereg(av7110, MSP_WR_DSP, 0x0008, 0x0220);\r\n}\r\nbreak;\r\ncase AUDIO_MONO_LEFT:\r\nret = audcom(av7110, AUDIO_CMD_MONO_L);\r\nif (!ret) {\r\nif (av7110->adac_type == DVB_ADAC_CRYSTAL)\r\ni2c_writereg(av7110, 0x20, 0x02, 0x4a);\r\nelse if (av7110->adac_type == DVB_ADAC_MSP34x5)\r\nmsp_writereg(av7110, MSP_WR_DSP, 0x0008, 0x0200);\r\n}\r\nbreak;\r\ncase AUDIO_MONO_RIGHT:\r\nret = audcom(av7110, AUDIO_CMD_MONO_R);\r\nif (!ret) {\r\nif (av7110->adac_type == DVB_ADAC_CRYSTAL)\r\ni2c_writereg(av7110, 0x20, 0x02, 0x45);\r\nelse if (av7110->adac_type == DVB_ADAC_MSP34x5)\r\nmsp_writereg(av7110, MSP_WR_DSP, 0x0008, 0x0210);\r\n}\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nbreak;\r\ncase AUDIO_GET_STATUS:\r\nmemcpy(parg, &av7110->audiostate, sizeof(struct audio_status));\r\nbreak;\r\ncase AUDIO_GET_CAPABILITIES:\r\nif (FW_VERSION(av7110->arm_app) < 0x2621)\r\n*(unsigned int *)parg = AUDIO_CAP_LPCM | AUDIO_CAP_MP1 | AUDIO_CAP_MP2;\r\nelse\r\n*(unsigned int *)parg = AUDIO_CAP_LPCM | AUDIO_CAP_DTS | AUDIO_CAP_AC3 |\r\nAUDIO_CAP_MP1 | AUDIO_CAP_MP2;\r\nbreak;\r\ncase AUDIO_CLEAR_BUFFER:\r\ndvb_ringbuffer_flush_spinlock_wakeup(&av7110->aout);\r\nav7110_ipack_reset(&av7110->ipack[0]);\r\nif (av7110->playing == RP_AV)\r\nret = av7110_fw_cmd(av7110, COMTYPE_REC_PLAY,\r\n__Play, 2, AV_PES, 0);\r\nbreak;\r\ncase AUDIO_SET_ID:\r\nbreak;\r\ncase AUDIO_SET_MIXER:\r\n{\r\nstruct audio_mixer *amix = (struct audio_mixer *)parg;\r\nret = av7110_set_volume(av7110, amix->volume_left, amix->volume_right);\r\nbreak;\r\n}\r\ncase AUDIO_SET_STREAMTYPE:\r\nbreak;\r\ndefault:\r\nret = -ENOIOCTLCMD;\r\n}\r\nmutex_unlock(&av7110->ioctl_mutex);\r\nreturn ret;\r\n}\r\nstatic int dvb_video_open(struct inode *inode, struct file *file)\r\n{\r\nstruct dvb_device *dvbdev = file->private_data;\r\nstruct av7110 *av7110 = dvbdev->priv;\r\nint err;\r\ndprintk(2, "av7110:%p, \n", av7110);\r\nif ((err = dvb_generic_open(inode, file)) < 0)\r\nreturn err;\r\nif ((file->f_flags & O_ACCMODE) != O_RDONLY) {\r\ndvb_ringbuffer_flush_spinlock_wakeup(&av7110->aout);\r\ndvb_ringbuffer_flush_spinlock_wakeup(&av7110->avout);\r\nav7110->video_blank = 1;\r\nav7110->audiostate.AV_sync_state = 1;\r\nav7110->videostate.stream_source = VIDEO_SOURCE_DEMUX;\r\nav7110->video_events.eventr = av7110->video_events.eventw = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dvb_video_release(struct inode *inode, struct file *file)\r\n{\r\nstruct dvb_device *dvbdev = file->private_data;\r\nstruct av7110 *av7110 = dvbdev->priv;\r\ndprintk(2, "av7110:%p, \n", av7110);\r\nif ((file->f_flags & O_ACCMODE) != O_RDONLY) {\r\nav7110_av_stop(av7110, RP_VIDEO);\r\n}\r\nreturn dvb_generic_release(inode, file);\r\n}\r\nstatic int dvb_audio_open(struct inode *inode, struct file *file)\r\n{\r\nstruct dvb_device *dvbdev = file->private_data;\r\nstruct av7110 *av7110 = dvbdev->priv;\r\nint err = dvb_generic_open(inode, file);\r\ndprintk(2, "av7110:%p, \n", av7110);\r\nif (err < 0)\r\nreturn err;\r\ndvb_ringbuffer_flush_spinlock_wakeup(&av7110->aout);\r\nav7110->audiostate.stream_source = AUDIO_SOURCE_DEMUX;\r\nreturn 0;\r\n}\r\nstatic int dvb_audio_release(struct inode *inode, struct file *file)\r\n{\r\nstruct dvb_device *dvbdev = file->private_data;\r\nstruct av7110 *av7110 = dvbdev->priv;\r\ndprintk(2, "av7110:%p, \n", av7110);\r\nav7110_av_stop(av7110, RP_AUDIO);\r\nreturn dvb_generic_release(inode, file);\r\n}\r\nint av7110_av_register(struct av7110 *av7110)\r\n{\r\nav7110->audiostate.AV_sync_state = 0;\r\nav7110->audiostate.mute_state = 0;\r\nav7110->audiostate.play_state = AUDIO_STOPPED;\r\nav7110->audiostate.stream_source = AUDIO_SOURCE_DEMUX;\r\nav7110->audiostate.channel_select = AUDIO_STEREO;\r\nav7110->audiostate.bypass_mode = 0;\r\nav7110->videostate.video_blank = 0;\r\nav7110->videostate.play_state = VIDEO_STOPPED;\r\nav7110->videostate.stream_source = VIDEO_SOURCE_DEMUX;\r\nav7110->videostate.video_format = VIDEO_FORMAT_4_3;\r\nav7110->videostate.display_format = VIDEO_LETTER_BOX;\r\nav7110->display_ar = VIDEO_FORMAT_4_3;\r\nav7110->display_panscan = VID_VC_AND_PS_PREF;\r\ninit_waitqueue_head(&av7110->video_events.wait_queue);\r\nspin_lock_init(&av7110->video_events.lock);\r\nav7110->video_events.eventw = av7110->video_events.eventr = 0;\r\nav7110->video_events.overflow = 0;\r\nmemset(&av7110->video_size, 0, sizeof (video_size_t));\r\ndvb_register_device(&av7110->dvb_adapter, &av7110->video_dev,\r\n&dvbdev_video, av7110, DVB_DEVICE_VIDEO);\r\ndvb_register_device(&av7110->dvb_adapter, &av7110->audio_dev,\r\n&dvbdev_audio, av7110, DVB_DEVICE_AUDIO);\r\nreturn 0;\r\n}\r\nvoid av7110_av_unregister(struct av7110 *av7110)\r\n{\r\ndvb_unregister_device(av7110->audio_dev);\r\ndvb_unregister_device(av7110->video_dev);\r\n}\r\nint av7110_av_init(struct av7110 *av7110)\r\n{\r\nvoid (*play[])(u8 *, int, void *) = { play_audio_cb, play_video_cb }
