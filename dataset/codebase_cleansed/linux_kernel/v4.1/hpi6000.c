static void subsys_message(struct hpi_message *phm, struct hpi_response *phr)\r\n{\r\nswitch (phm->function) {\r\ncase HPI_SUBSYS_CREATE_ADAPTER:\r\nsubsys_create_adapter(phm, phr);\r\nbreak;\r\ndefault:\r\nphr->error = HPI_ERROR_INVALID_FUNC;\r\nbreak;\r\n}\r\n}\r\nstatic void control_message(struct hpi_adapter_obj *pao,\r\nstruct hpi_message *phm, struct hpi_response *phr)\r\n{\r\nstruct hpi_hw_obj *phw = pao->priv;\r\nswitch (phm->function) {\r\ncase HPI_CONTROL_GET_STATE:\r\nif (pao->has_control_cache) {\r\nu16 err;\r\nerr = hpi6000_update_control_cache(pao, phm);\r\nif (err) {\r\nif (err >= HPI_ERROR_BACKEND_BASE) {\r\nphr->error =\r\nHPI_ERROR_CONTROL_CACHING;\r\nphr->specific_error = err;\r\n} else {\r\nphr->error = err;\r\n}\r\nbreak;\r\n}\r\nif (hpi_check_control_cache(phw->p_cache, phm, phr))\r\nbreak;\r\n}\r\nhw_message(pao, phm, phr);\r\nbreak;\r\ncase HPI_CONTROL_SET_STATE:\r\nhw_message(pao, phm, phr);\r\nhpi_cmn_control_cache_sync_to_msg(phw->p_cache, phm, phr);\r\nbreak;\r\ncase HPI_CONTROL_GET_INFO:\r\ndefault:\r\nhw_message(pao, phm, phr);\r\nbreak;\r\n}\r\n}\r\nstatic void adapter_message(struct hpi_adapter_obj *pao,\r\nstruct hpi_message *phm, struct hpi_response *phr)\r\n{\r\nswitch (phm->function) {\r\ncase HPI_ADAPTER_GET_ASSERT:\r\nadapter_get_asserts(pao, phm, phr);\r\nbreak;\r\ncase HPI_ADAPTER_DELETE:\r\nadapter_delete(pao, phm, phr);\r\nbreak;\r\ndefault:\r\nhw_message(pao, phm, phr);\r\nbreak;\r\n}\r\n}\r\nstatic void outstream_message(struct hpi_adapter_obj *pao,\r\nstruct hpi_message *phm, struct hpi_response *phr)\r\n{\r\nswitch (phm->function) {\r\ncase HPI_OSTREAM_HOSTBUFFER_ALLOC:\r\ncase HPI_OSTREAM_HOSTBUFFER_FREE:\r\nphr->error = HPI_ERROR_INVALID_FUNC;\r\nbreak;\r\ndefault:\r\nhw_message(pao, phm, phr);\r\nreturn;\r\n}\r\n}\r\nstatic void instream_message(struct hpi_adapter_obj *pao,\r\nstruct hpi_message *phm, struct hpi_response *phr)\r\n{\r\nswitch (phm->function) {\r\ncase HPI_ISTREAM_HOSTBUFFER_ALLOC:\r\ncase HPI_ISTREAM_HOSTBUFFER_FREE:\r\nphr->error = HPI_ERROR_INVALID_FUNC;\r\nbreak;\r\ndefault:\r\nhw_message(pao, phm, phr);\r\nreturn;\r\n}\r\n}\r\nvoid HPI_6000(struct hpi_message *phm, struct hpi_response *phr)\r\n{\r\nstruct hpi_adapter_obj *pao = NULL;\r\nif (phm->object != HPI_OBJ_SUBSYSTEM) {\r\npao = hpi_find_adapter(phm->adapter_index);\r\nif (!pao) {\r\nhpi_init_response(phr, phm->object, phm->function,\r\nHPI_ERROR_BAD_ADAPTER_NUMBER);\r\nHPI_DEBUG_LOG(DEBUG, "invalid adapter index: %d \n",\r\nphm->adapter_index);\r\nreturn;\r\n}\r\nif (pao->dsp_crashed >= 10) {\r\nhpi_init_response(phr, phm->object, phm->function,\r\nHPI_ERROR_DSP_HARDWARE);\r\nHPI_DEBUG_LOG(DEBUG, "adapter %d dsp crashed\n",\r\nphm->adapter_index);\r\nreturn;\r\n}\r\n}\r\nif (phm->function != HPI_SUBSYS_CREATE_ADAPTER)\r\nhpi_init_response(phr, phm->object, phm->function,\r\nHPI_ERROR_PROCESSING_MESSAGE);\r\nswitch (phm->type) {\r\ncase HPI_TYPE_REQUEST:\r\nswitch (phm->object) {\r\ncase HPI_OBJ_SUBSYSTEM:\r\nsubsys_message(phm, phr);\r\nbreak;\r\ncase HPI_OBJ_ADAPTER:\r\nphr->size =\r\nsizeof(struct hpi_response_header) +\r\nsizeof(struct hpi_adapter_res);\r\nadapter_message(pao, phm, phr);\r\nbreak;\r\ncase HPI_OBJ_CONTROL:\r\ncontrol_message(pao, phm, phr);\r\nbreak;\r\ncase HPI_OBJ_OSTREAM:\r\noutstream_message(pao, phm, phr);\r\nbreak;\r\ncase HPI_OBJ_ISTREAM:\r\ninstream_message(pao, phm, phr);\r\nbreak;\r\ndefault:\r\nhw_message(pao, phm, phr);\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nphr->error = HPI_ERROR_INVALID_TYPE;\r\nbreak;\r\n}\r\n}\r\nstatic void subsys_create_adapter(struct hpi_message *phm,\r\nstruct hpi_response *phr)\r\n{\r\nstruct hpi_adapter_obj ao;\r\nstruct hpi_adapter_obj *pao;\r\nu32 os_error_code;\r\nu16 err = 0;\r\nu32 dsp_index = 0;\r\nHPI_DEBUG_LOG(VERBOSE, "subsys_create_adapter\n");\r\nmemset(&ao, 0, sizeof(ao));\r\nao.priv = kzalloc(sizeof(struct hpi_hw_obj), GFP_KERNEL);\r\nif (!ao.priv) {\r\nHPI_DEBUG_LOG(ERROR, "can't get mem for adapter object\n");\r\nphr->error = HPI_ERROR_MEMORY_ALLOC;\r\nreturn;\r\n}\r\nao.pci = *phm->u.s.resource.r.pci;\r\nerr = create_adapter_obj(&ao, &os_error_code);\r\nif (err) {\r\ndelete_adapter_obj(&ao);\r\nif (err >= HPI_ERROR_BACKEND_BASE) {\r\nphr->error = HPI_ERROR_DSP_BOOTLOAD;\r\nphr->specific_error = err;\r\n} else {\r\nphr->error = err;\r\n}\r\nphr->u.s.data = os_error_code;\r\nreturn;\r\n}\r\npao = hpi_find_adapter(ao.index);\r\nif (!pao) {\r\nHPI_DEBUG_LOG(ERROR, "lost adapter after boot\n");\r\nphr->error = HPI_ERROR_BAD_ADAPTER;\r\nreturn;\r\n}\r\nfor (dsp_index = 0; dsp_index < MAX_DSPS; dsp_index++) {\r\nstruct hpi_hw_obj *phw = pao->priv;\r\nphw->ado[dsp_index].pa_parent_adapter = pao;\r\n}\r\nphr->u.s.adapter_type = ao.type;\r\nphr->u.s.adapter_index = ao.index;\r\nphr->error = 0;\r\n}\r\nstatic void adapter_delete(struct hpi_adapter_obj *pao,\r\nstruct hpi_message *phm, struct hpi_response *phr)\r\n{\r\ndelete_adapter_obj(pao);\r\nhpi_delete_adapter(pao);\r\nphr->error = 0;\r\n}\r\nstatic short create_adapter_obj(struct hpi_adapter_obj *pao,\r\nu32 *pos_error_code)\r\n{\r\nshort boot_error = 0;\r\nu32 dsp_index = 0;\r\nu32 control_cache_size = 0;\r\nu32 control_cache_count = 0;\r\nstruct hpi_hw_obj *phw = pao->priv;\r\nphw->dw2040_HPICSR = pao->pci.ap_mem_base[0];\r\nphw->dw2040_HPIDSP = pao->pci.ap_mem_base[1];\r\nHPI_DEBUG_LOG(VERBOSE, "csr %p, dsp %p\n", phw->dw2040_HPICSR,\r\nphw->dw2040_HPIDSP);\r\nfor (dsp_index = 0; dsp_index < MAX_DSPS; dsp_index++) {\r\nphw->ado[dsp_index].prHPI_control =\r\nphw->dw2040_HPIDSP + (CONTROL +\r\nDSP_SPACING * dsp_index);\r\nphw->ado[dsp_index].prHPI_address =\r\nphw->dw2040_HPIDSP + (ADDRESS +\r\nDSP_SPACING * dsp_index);\r\nphw->ado[dsp_index].prHPI_data =\r\nphw->dw2040_HPIDSP + (DATA + DSP_SPACING * dsp_index);\r\nphw->ado[dsp_index].prHPI_data_auto_inc =\r\nphw->dw2040_HPIDSP + (DATA_AUTOINC +\r\nDSP_SPACING * dsp_index);\r\nHPI_DEBUG_LOG(VERBOSE, "ctl %p, adr %p, dat %p, dat++ %p\n",\r\nphw->ado[dsp_index].prHPI_control,\r\nphw->ado[dsp_index].prHPI_address,\r\nphw->ado[dsp_index].prHPI_data,\r\nphw->ado[dsp_index].prHPI_data_auto_inc);\r\nphw->ado[dsp_index].pa_parent_adapter = pao;\r\n}\r\nphw->pCI2040HPI_error_count = 0;\r\npao->has_control_cache = 0;\r\nphw->num_dsp = 1;\r\nboot_error = hpi6000_adapter_boot_load_dsp(pao, pos_error_code);\r\nif (boot_error)\r\nreturn boot_error;\r\nHPI_DEBUG_LOG(INFO, "bootload DSP OK\n");\r\nphw->message_buffer_address_on_dsp = 0L;\r\nphw->response_buffer_address_on_dsp = 0L;\r\n{\r\nstruct hpi_message hm;\r\nstruct hpi_response hr0;\r\nstruct hpi_response hr1;\r\nu16 error = 0;\r\nHPI_DEBUG_LOG(VERBOSE, "send ADAPTER_GET_INFO\n");\r\nmemset(&hm, 0, sizeof(hm));\r\nhm.type = HPI_TYPE_REQUEST;\r\nhm.size = sizeof(struct hpi_message);\r\nhm.object = HPI_OBJ_ADAPTER;\r\nhm.function = HPI_ADAPTER_GET_INFO;\r\nhm.adapter_index = 0;\r\nmemset(&hr0, 0, sizeof(hr0));\r\nmemset(&hr1, 0, sizeof(hr1));\r\nhr0.size = sizeof(hr0);\r\nhr1.size = sizeof(hr1);\r\nerror = hpi6000_message_response_sequence(pao, 0, &hm, &hr0);\r\nif (hr0.error) {\r\nHPI_DEBUG_LOG(DEBUG, "message error %d\n", hr0.error);\r\nreturn hr0.error;\r\n}\r\nif (phw->num_dsp == 2) {\r\nerror = hpi6000_message_response_sequence(pao, 1, &hm,\r\n&hr1);\r\nif (error)\r\nreturn error;\r\n}\r\npao->type = hr0.u.ax.info.adapter_type;\r\npao->index = hr0.u.ax.info.adapter_index;\r\n}\r\nmemset(&phw->control_cache[0], 0,\r\nsizeof(struct hpi_control_cache_single) *\r\nHPI_NMIXER_CONTROLS);\r\ncontrol_cache_size =\r\nhpi_read_word(&phw->ado[0],\r\nHPI_HIF_ADDR(control_cache_size_in_bytes));\r\nif (control_cache_size) {\r\ncontrol_cache_count =\r\nhpi_read_word(&phw->ado[0],\r\nHPI_HIF_ADDR(control_cache_count));\r\nphw->p_cache =\r\nhpi_alloc_control_cache(control_cache_count,\r\ncontrol_cache_size, (unsigned char *)\r\n&phw->control_cache[0]\r\n);\r\nif (phw->p_cache)\r\npao->has_control_cache = 1;\r\n}\r\nHPI_DEBUG_LOG(DEBUG, "get adapter info ASI%04X index %d\n", pao->type,\r\npao->index);\r\nif (phw->p_cache)\r\nphw->p_cache->adap_idx = pao->index;\r\nreturn hpi_add_adapter(pao);\r\n}\r\nstatic void delete_adapter_obj(struct hpi_adapter_obj *pao)\r\n{\r\nstruct hpi_hw_obj *phw = pao->priv;\r\nif (pao->has_control_cache)\r\nhpi_free_control_cache(phw->p_cache);\r\niowrite32(0x0003000F, phw->dw2040_HPICSR + HPI_RESET);\r\nkfree(phw);\r\n}\r\nstatic void adapter_get_asserts(struct hpi_adapter_obj *pao,\r\nstruct hpi_message *phm, struct hpi_response *phr)\r\n{\r\n#ifndef HIDE_PCI_ASSERTS\r\nif ((gw_pci_read_asserts > 0) || (gw_pci_write_asserts > 0)) {\r\nphr->u.ax.assert.p1 =\r\ngw_pci_read_asserts * 100 + gw_pci_write_asserts;\r\nphr->u.ax.assert.p2 = 0;\r\nphr->u.ax.assert.count = 1;\r\nphr->u.ax.assert.dsp_index = -1;\r\nstrcpy(phr->u.ax.assert.sz_message, "PCI2040 error");\r\nphr->u.ax.assert.dsp_msg_addr = 0;\r\ngw_pci_read_asserts = 0;\r\ngw_pci_write_asserts = 0;\r\nphr->error = 0;\r\n} else\r\n#endif\r\nhw_message(pao, phm, phr);\r\nreturn;\r\n}\r\nstatic short hpi6000_adapter_boot_load_dsp(struct hpi_adapter_obj *pao,\r\nu32 *pos_error_code)\r\n{\r\nstruct hpi_hw_obj *phw = pao->priv;\r\nshort error;\r\nu32 timeout;\r\nu32 read = 0;\r\nu32 i = 0;\r\nu32 data = 0;\r\nu32 j = 0;\r\nu32 test_addr = 0x80000000;\r\nu32 test_data = 0x00000001;\r\nu32 dw2040_reset = 0;\r\nu32 dsp_index = 0;\r\nu32 endian = 0;\r\nu32 adapter_info = 0;\r\nu32 delay = 0;\r\nstruct dsp_code dsp_code;\r\nu16 boot_load_family = 0;\r\nswitch (pao->pci.pci_dev->subsystem_device) {\r\ncase 0x5100:\r\ncase 0x5110:\r\ncase 0x5200:\r\ncase 0x6100:\r\ncase 0x6200:\r\nboot_load_family = HPI_ADAPTER_FAMILY_ASI(0x6200);\r\nbreak;\r\ndefault:\r\nreturn HPI6000_ERROR_UNHANDLED_SUBSYS_ID;\r\n}\r\nendian = 0;\r\ndw2040_reset = 0x0003000F;\r\niowrite32(dw2040_reset, phw->dw2040_HPICSR + HPI_RESET);\r\nhpios_delay_micro_seconds(1000);\r\ndelay = ioread32(phw->dw2040_HPICSR + HPI_RESET);\r\nif (delay != dw2040_reset) {\r\nHPI_DEBUG_LOG(ERROR, "INIT_PCI2040 %x %x\n", dw2040_reset,\r\ndelay);\r\nreturn HPI6000_ERROR_INIT_PCI2040;\r\n}\r\niowrite32(0x00000003, phw->dw2040_HPICSR + HPI_DATA_WIDTH);\r\niowrite32(0x60000000, phw->dw2040_HPICSR + INTERRUPT_MASK_SET);\r\ndw2040_reset = dw2040_reset & (~(endian << 3));\r\niowrite32(dw2040_reset, phw->dw2040_HPICSR + HPI_RESET);\r\nphw->ado[0].c_dsp_rev = 'B';\r\nphw->ado[1].c_dsp_rev = 'B';\r\ndw2040_reset = dw2040_reset & (~0x00000001);\r\niowrite32(dw2040_reset, phw->dw2040_HPICSR + HPI_RESET);\r\ndw2040_reset = dw2040_reset & (~0x00000002);\r\niowrite32(dw2040_reset, phw->dw2040_HPICSR + HPI_RESET);\r\ndw2040_reset = dw2040_reset & (~0x00000008);\r\niowrite32(dw2040_reset, phw->dw2040_HPICSR + HPI_RESET);\r\nhpios_delay_micro_seconds(100);\r\nfor (dsp_index = 0; dsp_index < phw->num_dsp; dsp_index++) {\r\nstruct dsp_obj *pdo = &phw->ado[dsp_index];\r\niowrite32(0x00010001, pdo->prHPI_control);\r\ntest_data = 0x00000001;\r\nfor (j = 0; j < 32; j++) {\r\niowrite32(test_data, pdo->prHPI_address);\r\ndata = ioread32(pdo->prHPI_address);\r\nif (data != test_data) {\r\nHPI_DEBUG_LOG(ERROR, "INIT_DSPHPI %x %x %x\n",\r\ntest_data, data, dsp_index);\r\nreturn HPI6000_ERROR_INIT_DSPHPI;\r\n}\r\ntest_data = test_data << 1;\r\n}\r\n{\r\nhpi_write_word(pdo, 0x01B7C100, 0x0000);\r\nhpios_delay_micro_seconds(100);\r\nhpi_write_word(pdo, 0x01B7C120, 0x8002);\r\nhpios_delay_micro_seconds(100);\r\nhpi_write_word(pdo, 0x01B7C11C, 0x8001);\r\nhpios_delay_micro_seconds(100);\r\nhpi_write_word(pdo, 0x01B7C118, 0x8000);\r\nhpios_delay_micro_seconds(2000);\r\nhpi_write_word(pdo, 0x01B7C100, 0x0001);\r\nhpios_delay_micro_seconds(2000);\r\n}\r\nfor (i = 0; i < 100; i++) {\r\ntest_addr = 0x00000000;\r\ntest_data = 0x00000001;\r\nfor (j = 0; j < 32; j++) {\r\nhpi_write_word(pdo, test_addr + i, test_data);\r\ndata = hpi_read_word(pdo, test_addr + i);\r\nif (data != test_data) {\r\nHPI_DEBUG_LOG(ERROR,\r\n"DSP mem %x %x %x %x\n",\r\ntest_addr + i, test_data,\r\ndata, dsp_index);\r\nreturn HPI6000_ERROR_INIT_DSPINTMEM;\r\n}\r\ntest_data = test_data << 1;\r\n}\r\n}\r\nhpi_write_word(pdo, 0x01800000, 0x34A8);\r\nhpi_write_word(pdo, 0x01800008, 0x00000030);\r\nhpi_write_word(pdo, 0x01800020, 0x001BDF29);\r\nhpi_write_word(pdo, 0x01800018, 0x47117000);\r\nhpi_write_word(pdo, 0x0180001C, 0x00000410);\r\n{\r\nu32 cE1 =\r\n(1L << 28) | (3L << 22) | (1L << 20) | (1L <<\r\n16) | (2L << 14) | (3L << 8) | (2L << 4) | 1L;\r\nhpi_write_word(pdo, 0x01800004, cE1);\r\n}\r\nhpios_delay_micro_seconds(1000);\r\n{\r\ntest_addr = 0x80000000;\r\ntest_data = 0x00000001;\r\nfor (j = 0; j < 32; j++) {\r\nhpi_write_word(pdo, test_addr, test_data);\r\ndata = hpi_read_word(pdo, test_addr);\r\nif (data != test_data) {\r\nHPI_DEBUG_LOG(ERROR,\r\n"DSP dram %x %x %x %x\n",\r\ntest_addr, test_data, data,\r\ndsp_index);\r\nreturn HPI6000_ERROR_INIT_SDRAM1;\r\n}\r\ntest_data = test_data << 1;\r\n}\r\n#define DRAM_SIZE_WORDS 0x200000\r\n#define DRAM_INC 1024\r\ntest_addr = 0x80000000;\r\ntest_data = 0x0;\r\nfor (i = 0; i < DRAM_SIZE_WORDS; i = i + DRAM_INC) {\r\nhpi_write_word(pdo, test_addr + i, test_data);\r\ntest_data++;\r\n}\r\ntest_addr = 0x80000000;\r\ntest_data = 0x0;\r\nfor (i = 0; i < DRAM_SIZE_WORDS; i = i + DRAM_INC) {\r\ndata = hpi_read_word(pdo, test_addr + i);\r\nif (data != test_data) {\r\nHPI_DEBUG_LOG(ERROR,\r\n"DSP dram %x %x %x %x\n",\r\ntest_addr + i, test_data,\r\ndata, dsp_index);\r\nreturn HPI6000_ERROR_INIT_SDRAM2;\r\n}\r\ntest_data++;\r\n}\r\n}\r\nerror = hpi_dsp_code_open(boot_load_family, pao->pci.pci_dev,\r\n&dsp_code, pos_error_code);\r\nif (error)\r\nreturn error;\r\nwhile (1) {\r\nu32 length;\r\nu32 address;\r\nu32 type;\r\nu32 *pcode;\r\nerror = hpi_dsp_code_read_word(&dsp_code, &length);\r\nif (error)\r\nbreak;\r\nif (length == 0xFFFFFFFF)\r\nbreak;\r\nerror = hpi_dsp_code_read_word(&dsp_code, &address);\r\nif (error)\r\nbreak;\r\nerror = hpi_dsp_code_read_word(&dsp_code, &type);\r\nif (error)\r\nbreak;\r\nerror = hpi_dsp_code_read_block(length, &dsp_code,\r\n&pcode);\r\nif (error)\r\nbreak;\r\nerror = hpi6000_dsp_block_write32(pao, (u16)dsp_index,\r\naddress, pcode, length);\r\nif (error)\r\nbreak;\r\n}\r\nif (error) {\r\nhpi_dsp_code_close(&dsp_code);\r\nreturn error;\r\n}\r\nhpi_dsp_code_rewind(&dsp_code);\r\nwhile (1) {\r\nu32 length;\r\nu32 address;\r\nu32 type;\r\nu32 *pcode;\r\nhpi_dsp_code_read_word(&dsp_code, &length);\r\nif (length == 0xFFFFFFFF)\r\nbreak;\r\nhpi_dsp_code_read_word(&dsp_code, &address);\r\nhpi_dsp_code_read_word(&dsp_code, &type);\r\nhpi_dsp_code_read_block(length, &dsp_code, &pcode);\r\nfor (i = 0; i < length; i++) {\r\ndata = hpi_read_word(pdo, address);\r\nif (data != *pcode) {\r\nerror = HPI6000_ERROR_INIT_VERIFY;\r\nHPI_DEBUG_LOG(ERROR,\r\n"DSP verify %x %x %x %x\n",\r\naddress, *pcode, data,\r\ndsp_index);\r\nbreak;\r\n}\r\npcode++;\r\naddress += 4;\r\n}\r\nif (error)\r\nbreak;\r\n}\r\nhpi_dsp_code_close(&dsp_code);\r\nif (error)\r\nreturn error;\r\n{\r\nu32 address = HPI_HIF_ADDR(host_cmd);\r\nfor (i = 0; i < 4; i++) {\r\nhpi_write_word(pdo, address, 0);\r\naddress += 4;\r\n}\r\n}\r\nhpi_write_word(pdo, HPI_HIF_ADDR(dsp_number), dsp_index);\r\nif (dsp_index > 0)\r\nhpi_write_word(pdo, HPI_HIF_ADDR(adapter_info),\r\nadapter_info);\r\niowrite32(0x00030003, pdo->prHPI_control);\r\nhpios_delay_micro_seconds(10000);\r\ntimeout = 2000000;\r\nwhile (timeout) {\r\ndo {\r\nread = hpi_read_word(pdo,\r\nHPI_HIF_ADDR(host_cmd));\r\n} while (--timeout\r\n&& hpi6000_check_PCI2040_error_flag(pao,\r\nH6READ));\r\nif (read)\r\nbreak;\r\nelse\r\nhpios_delay_micro_seconds(10000);\r\n}\r\nif (timeout == 0)\r\nreturn HPI6000_ERROR_INIT_NOACK;\r\nif (dsp_index == 0) {\r\nu32 mask = 0;\r\nadapter_info =\r\nhpi_read_word(pdo,\r\nHPI_HIF_ADDR(adapter_info));\r\nif (HPI_ADAPTER_FAMILY_ASI\r\n(HPI_HIF_ADAPTER_INFO_EXTRACT_ADAPTER\r\n(adapter_info)) ==\r\nHPI_ADAPTER_FAMILY_ASI(0x6200))\r\nphw->num_dsp = 2;\r\n#define PLD_BASE_ADDRESS 0x90000000L\r\nswitch (boot_load_family) {\r\ncase HPI_ADAPTER_FAMILY_ASI(0x6200):\r\nmask = 0xFFFFFF00L;\r\nif (HPI_ADAPTER_FAMILY_ASI(pao->pci.pci_dev->\r\nsubsystem_device) ==\r\nHPI_ADAPTER_FAMILY_ASI(0x5100))\r\nmask = 0x00000000L;\r\nif (HPI_ADAPTER_FAMILY_ASI(pao->pci.pci_dev->\r\nsubsystem_device) ==\r\nHPI_ADAPTER_FAMILY_ASI(0x5200))\r\nmask = 0x00000000L;\r\nbreak;\r\ncase HPI_ADAPTER_FAMILY_ASI(0x8800):\r\nmask = 0xFFFF0000L;\r\nbreak;\r\n}\r\ntest_data = 0xAAAAAA00L & mask;\r\nhpi_write_word(pdo, PLD_BASE_ADDRESS + 4L, test_data);\r\nread = hpi_read_word(pdo,\r\nPLD_BASE_ADDRESS + 4L) & mask;\r\nif (read != test_data) {\r\nHPI_DEBUG_LOG(ERROR, "PLD %x %x\n", test_data,\r\nread);\r\nreturn HPI6000_ERROR_INIT_PLDTEST1;\r\n}\r\ntest_data = 0x55555500L & mask;\r\nhpi_write_word(pdo, PLD_BASE_ADDRESS + 4L, test_data);\r\nread = hpi_read_word(pdo,\r\nPLD_BASE_ADDRESS + 4L) & mask;\r\nif (read != test_data) {\r\nHPI_DEBUG_LOG(ERROR, "PLD %x %x\n", test_data,\r\nread);\r\nreturn HPI6000_ERROR_INIT_PLDTEST2;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int hpi_set_address(struct dsp_obj *pdo, u32 address)\r\n{\r\nu32 timeout = PCI_TIMEOUT;\r\ndo {\r\niowrite32(address, pdo->prHPI_address);\r\n} while (hpi6000_check_PCI2040_error_flag(pdo->pa_parent_adapter,\r\nH6WRITE)\r\n&& --timeout);\r\nif (timeout)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void hpi_write_word(struct dsp_obj *pdo, u32 address, u32 data)\r\n{\r\nif (hpi_set_address(pdo, address))\r\nreturn;\r\niowrite32(data, pdo->prHPI_data);\r\n}\r\nstatic u32 hpi_read_word(struct dsp_obj *pdo, u32 address)\r\n{\r\nu32 data = 0;\r\nif (hpi_set_address(pdo, address))\r\nreturn 0;\r\ndata = ioread32(pdo->prHPI_data);\r\nreturn data;\r\n}\r\nstatic void hpi_write_block(struct dsp_obj *pdo, u32 address, u32 *pdata,\r\nu32 length)\r\n{\r\nu16 length16 = length - 1;\r\nif (length == 0)\r\nreturn;\r\nif (hpi_set_address(pdo, address))\r\nreturn;\r\niowrite32_rep(pdo->prHPI_data_auto_inc, pdata, length16);\r\niowrite32(*(pdata + length - 1), pdo->prHPI_data);\r\n}\r\nstatic void hpi_read_block(struct dsp_obj *pdo, u32 address, u32 *pdata,\r\nu32 length)\r\n{\r\nu16 length16 = length - 1;\r\nif (length == 0)\r\nreturn;\r\nif (hpi_set_address(pdo, address))\r\nreturn;\r\nioread32_rep(pdo->prHPI_data_auto_inc, pdata, length16);\r\n*(pdata + length - 1) = ioread32(pdo->prHPI_data);\r\n}\r\nstatic u16 hpi6000_dsp_block_write32(struct hpi_adapter_obj *pao,\r\nu16 dsp_index, u32 hpi_address, u32 *source, u32 count)\r\n{\r\nstruct hpi_hw_obj *phw = pao->priv;\r\nstruct dsp_obj *pdo = &phw->ado[dsp_index];\r\nu32 time_out = PCI_TIMEOUT;\r\nint c6711_burst_size = 128;\r\nu32 local_hpi_address = hpi_address;\r\nint local_count = count;\r\nint xfer_size;\r\nu32 *pdata = source;\r\nwhile (local_count) {\r\nif (local_count > c6711_burst_size)\r\nxfer_size = c6711_burst_size;\r\nelse\r\nxfer_size = local_count;\r\ntime_out = PCI_TIMEOUT;\r\ndo {\r\nhpi_write_block(pdo, local_hpi_address, pdata,\r\nxfer_size);\r\n} while (hpi6000_check_PCI2040_error_flag(pao, H6WRITE)\r\n&& --time_out);\r\nif (!time_out)\r\nbreak;\r\npdata += xfer_size;\r\nlocal_hpi_address += sizeof(u32) * xfer_size;\r\nlocal_count -= xfer_size;\r\n}\r\nif (time_out)\r\nreturn 0;\r\nelse\r\nreturn 1;\r\n}\r\nstatic u16 hpi6000_dsp_block_read32(struct hpi_adapter_obj *pao,\r\nu16 dsp_index, u32 hpi_address, u32 *dest, u32 count)\r\n{\r\nstruct hpi_hw_obj *phw = pao->priv;\r\nstruct dsp_obj *pdo = &phw->ado[dsp_index];\r\nu32 time_out = PCI_TIMEOUT;\r\nint c6711_burst_size = 16;\r\nu32 local_hpi_address = hpi_address;\r\nint local_count = count;\r\nint xfer_size;\r\nu32 *pdata = dest;\r\nu32 loop_count = 0;\r\nwhile (local_count) {\r\nif (local_count > c6711_burst_size)\r\nxfer_size = c6711_burst_size;\r\nelse\r\nxfer_size = local_count;\r\ntime_out = PCI_TIMEOUT;\r\ndo {\r\nhpi_read_block(pdo, local_hpi_address, pdata,\r\nxfer_size);\r\n} while (hpi6000_check_PCI2040_error_flag(pao, H6READ)\r\n&& --time_out);\r\nif (!time_out)\r\nbreak;\r\npdata += xfer_size;\r\nlocal_hpi_address += sizeof(u32) * xfer_size;\r\nlocal_count -= xfer_size;\r\nloop_count++;\r\n}\r\nif (time_out)\r\nreturn 0;\r\nelse\r\nreturn 1;\r\n}\r\nstatic short hpi6000_message_response_sequence(struct hpi_adapter_obj *pao,\r\nu16 dsp_index, struct hpi_message *phm, struct hpi_response *phr)\r\n{\r\nstruct hpi_hw_obj *phw = pao->priv;\r\nstruct dsp_obj *pdo = &phw->ado[dsp_index];\r\nu32 timeout;\r\nu16 ack;\r\nu32 address;\r\nu32 length;\r\nu32 *p_data;\r\nu16 error = 0;\r\nack = hpi6000_wait_dsp_ack(pao, dsp_index, HPI_HIF_IDLE);\r\nif (ack & HPI_HIF_ERROR_MASK) {\r\npao->dsp_crashed++;\r\nreturn HPI6000_ERROR_MSG_RESP_IDLE_TIMEOUT;\r\n}\r\npao->dsp_crashed = 0;\r\nif (phw->message_buffer_address_on_dsp == 0) {\r\ntimeout = TIMEOUT;\r\ndo {\r\naddress =\r\nhpi_read_word(pdo,\r\nHPI_HIF_ADDR(message_buffer_address));\r\nphw->message_buffer_address_on_dsp = address;\r\n} while (hpi6000_check_PCI2040_error_flag(pao, H6READ)\r\n&& --timeout);\r\nif (!timeout)\r\nreturn HPI6000_ERROR_MSG_GET_ADR;\r\n} else\r\naddress = phw->message_buffer_address_on_dsp;\r\nlength = phm->size;\r\np_data = (u32 *)phm;\r\nif (hpi6000_dsp_block_write32(pao, dsp_index, address, p_data,\r\n(u16)length / 4))\r\nreturn HPI6000_ERROR_MSG_RESP_BLOCKWRITE32;\r\nif (hpi6000_send_host_command(pao, dsp_index, HPI_HIF_GET_RESP))\r\nreturn HPI6000_ERROR_MSG_RESP_GETRESPCMD;\r\nhpi6000_send_dsp_interrupt(pdo);\r\nack = hpi6000_wait_dsp_ack(pao, dsp_index, HPI_HIF_GET_RESP);\r\nif (ack & HPI_HIF_ERROR_MASK)\r\nreturn HPI6000_ERROR_MSG_RESP_GET_RESP_ACK;\r\nif (phw->response_buffer_address_on_dsp == 0) {\r\ntimeout = TIMEOUT;\r\ndo {\r\naddress =\r\nhpi_read_word(pdo,\r\nHPI_HIF_ADDR(response_buffer_address));\r\n} while (hpi6000_check_PCI2040_error_flag(pao, H6READ)\r\n&& --timeout);\r\nphw->response_buffer_address_on_dsp = address;\r\nif (!timeout)\r\nreturn HPI6000_ERROR_RESP_GET_ADR;\r\n} else\r\naddress = phw->response_buffer_address_on_dsp;\r\ntimeout = TIMEOUT;\r\ndo {\r\nlength = hpi_read_word(pdo, HPI_HIF_ADDR(length));\r\n} while (hpi6000_check_PCI2040_error_flag(pao, H6READ) && --timeout);\r\nif (!timeout)\r\nreturn HPI6000_ERROR_RESP_GET_LEN;\r\nif (length > phr->size)\r\nreturn HPI_ERROR_RESPONSE_BUFFER_TOO_SMALL;\r\np_data = (u32 *)phr;\r\nif (hpi6000_dsp_block_read32(pao, dsp_index, address, p_data,\r\n(u16)length / 4))\r\nreturn HPI6000_ERROR_MSG_RESP_BLOCKREAD32;\r\nif (hpi6000_send_host_command(pao, dsp_index, HPI_HIF_IDLE))\r\nreturn HPI6000_ERROR_MSG_RESP_IDLECMD;\r\nhpi6000_send_dsp_interrupt(pdo);\r\nerror = hpi_validate_response(phm, phr);\r\nreturn error;\r\n}\r\nstatic short hpi6000_send_data_check_adr(u32 address, u32 length_in_dwords)\r\n{\r\n#ifdef CHECKING\r\nif (address < (u32)MSG_ADDRESS)\r\nreturn 0;\r\nif (address > (u32)(QUEUE_START + QUEUE_SIZE))\r\nreturn 0;\r\nif ((address + (length_in_dwords << 2)) >\r\n(u32)(QUEUE_START + QUEUE_SIZE))\r\nreturn 0;\r\n#else\r\n(void)address;\r\n(void)length_in_dwords;\r\nreturn 1;\r\n#endif\r\n}\r\nstatic short hpi6000_send_data(struct hpi_adapter_obj *pao, u16 dsp_index,\r\nstruct hpi_message *phm, struct hpi_response *phr)\r\n{\r\nstruct hpi_hw_obj *phw = pao->priv;\r\nstruct dsp_obj *pdo = &phw->ado[dsp_index];\r\nu32 data_sent = 0;\r\nu16 ack;\r\nu32 length, address;\r\nu32 *p_data = (u32 *)phm->u.d.u.data.pb_data;\r\nu16 time_out = 8;\r\n(void)phr;\r\nwhile ((data_sent < (phm->u.d.u.data.data_size & ~3L))\r\n&& --time_out) {\r\nack = hpi6000_wait_dsp_ack(pao, dsp_index, HPI_HIF_IDLE);\r\nif (ack & HPI_HIF_ERROR_MASK)\r\nreturn HPI6000_ERROR_SEND_DATA_IDLE_TIMEOUT;\r\nif (hpi6000_send_host_command(pao, dsp_index,\r\nHPI_HIF_SEND_DATA))\r\nreturn HPI6000_ERROR_SEND_DATA_CMD;\r\nhpi6000_send_dsp_interrupt(pdo);\r\nack = hpi6000_wait_dsp_ack(pao, dsp_index, HPI_HIF_SEND_DATA);\r\nif (ack & HPI_HIF_ERROR_MASK)\r\nreturn HPI6000_ERROR_SEND_DATA_ACK;\r\ndo {\r\naddress = hpi_read_word(pdo, HPI_HIF_ADDR(address));\r\nlength = hpi_read_word(pdo, HPI_HIF_ADDR(length));\r\n} while (hpi6000_check_PCI2040_error_flag(pao, H6READ));\r\nif (!hpi6000_send_data_check_adr(address, length))\r\nreturn HPI6000_ERROR_SEND_DATA_ADR;\r\n{\r\nu32 len = length;\r\nu32 blk_len = 512;\r\nwhile (len) {\r\nif (len < blk_len)\r\nblk_len = len;\r\nif (hpi6000_dsp_block_write32(pao, dsp_index,\r\naddress, p_data, blk_len))\r\nreturn HPI6000_ERROR_SEND_DATA_WRITE;\r\naddress += blk_len * 4;\r\np_data += blk_len;\r\nlen -= blk_len;\r\n}\r\n}\r\nif (hpi6000_send_host_command(pao, dsp_index, HPI_HIF_IDLE))\r\nreturn HPI6000_ERROR_SEND_DATA_IDLECMD;\r\nhpi6000_send_dsp_interrupt(pdo);\r\ndata_sent += length * 4;\r\n}\r\nif (!time_out)\r\nreturn HPI6000_ERROR_SEND_DATA_TIMEOUT;\r\nreturn 0;\r\n}\r\nstatic short hpi6000_get_data(struct hpi_adapter_obj *pao, u16 dsp_index,\r\nstruct hpi_message *phm, struct hpi_response *phr)\r\n{\r\nstruct hpi_hw_obj *phw = pao->priv;\r\nstruct dsp_obj *pdo = &phw->ado[dsp_index];\r\nu32 data_got = 0;\r\nu16 ack;\r\nu32 length, address;\r\nu32 *p_data = (u32 *)phm->u.d.u.data.pb_data;\r\n(void)phr;\r\nwhile (data_got < (phm->u.d.u.data.data_size & ~3L)) {\r\nack = hpi6000_wait_dsp_ack(pao, dsp_index, HPI_HIF_IDLE);\r\nif (ack & HPI_HIF_ERROR_MASK)\r\nreturn HPI6000_ERROR_GET_DATA_IDLE_TIMEOUT;\r\nif (hpi6000_send_host_command(pao, dsp_index,\r\nHPI_HIF_GET_DATA))\r\nreturn HPI6000_ERROR_GET_DATA_CMD;\r\nhpi6000_send_dsp_interrupt(pdo);\r\nack = hpi6000_wait_dsp_ack(pao, dsp_index, HPI_HIF_GET_DATA);\r\nif (ack & HPI_HIF_ERROR_MASK)\r\nreturn HPI6000_ERROR_GET_DATA_ACK;\r\ndo {\r\naddress = hpi_read_word(pdo, HPI_HIF_ADDR(address));\r\nlength = hpi_read_word(pdo, HPI_HIF_ADDR(length));\r\n} while (hpi6000_check_PCI2040_error_flag(pao, H6READ));\r\n{\r\nu32 len = length;\r\nu32 blk_len = 512;\r\nwhile (len) {\r\nif (len < blk_len)\r\nblk_len = len;\r\nif (hpi6000_dsp_block_read32(pao, dsp_index,\r\naddress, p_data, blk_len))\r\nreturn HPI6000_ERROR_GET_DATA_READ;\r\naddress += blk_len * 4;\r\np_data += blk_len;\r\nlen -= blk_len;\r\n}\r\n}\r\nif (hpi6000_send_host_command(pao, dsp_index, HPI_HIF_IDLE))\r\nreturn HPI6000_ERROR_GET_DATA_IDLECMD;\r\nhpi6000_send_dsp_interrupt(pdo);\r\ndata_got += length * 4;\r\n}\r\nreturn 0;\r\n}\r\nstatic void hpi6000_send_dsp_interrupt(struct dsp_obj *pdo)\r\n{\r\niowrite32(0x00030003, pdo->prHPI_control);\r\n}\r\nstatic short hpi6000_send_host_command(struct hpi_adapter_obj *pao,\r\nu16 dsp_index, u32 host_cmd)\r\n{\r\nstruct hpi_hw_obj *phw = pao->priv;\r\nstruct dsp_obj *pdo = &phw->ado[dsp_index];\r\nu32 timeout = TIMEOUT;\r\ndo {\r\nhpi_write_word(pdo, HPI_HIF_ADDR(host_cmd), host_cmd);\r\nhpi_set_address(pdo, HPI_HIF_ADDR(host_cmd));\r\n} while (hpi6000_check_PCI2040_error_flag(pao, H6WRITE) && --timeout);\r\niowrite32(0x00040004, pdo->prHPI_control);\r\nif (timeout)\r\nreturn 0;\r\nelse\r\nreturn 1;\r\n}\r\nstatic short hpi6000_check_PCI2040_error_flag(struct hpi_adapter_obj *pao,\r\nu16 read_or_write)\r\n{\r\nu32 hPI_error;\r\nstruct hpi_hw_obj *phw = pao->priv;\r\nhPI_error = ioread32(phw->dw2040_HPICSR + HPI_ERROR_REPORT);\r\nif (hPI_error) {\r\niowrite32(0L, phw->dw2040_HPICSR + HPI_ERROR_REPORT);\r\nphw->pCI2040HPI_error_count++;\r\nif (read_or_write == 1)\r\ngw_pci_read_asserts++;\r\nelse\r\ngw_pci_write_asserts++;\r\nreturn 1;\r\n} else\r\nreturn 0;\r\n}\r\nstatic short hpi6000_wait_dsp_ack(struct hpi_adapter_obj *pao, u16 dsp_index,\r\nu32 ack_value)\r\n{\r\nstruct hpi_hw_obj *phw = pao->priv;\r\nstruct dsp_obj *pdo = &phw->ado[dsp_index];\r\nu32 ack = 0L;\r\nu32 timeout;\r\nu32 hPIC = 0L;\r\ntimeout = TIMEOUT;\r\nwhile (--timeout) {\r\nhPIC = ioread32(pdo->prHPI_control);\r\nif (hPIC & 0x04)\r\nbreak;\r\n}\r\nif (timeout == 0)\r\nreturn HPI_HIF_ERROR_MASK;\r\ntimeout = TIMEOUT;\r\nwhile (--timeout) {\r\nack = hpi_read_word(pdo, HPI_HIF_ADDR(dsp_ack));\r\nif (ack == ack_value)\r\nbreak;\r\nif ((ack & HPI_HIF_ERROR_MASK)\r\n&& !hpi6000_check_PCI2040_error_flag(pao, H6READ))\r\nbreak;\r\n}\r\nif (ack & HPI_HIF_ERROR_MASK)\r\nack = HPI_HIF_ERROR_MASK;\r\nif (timeout == 0)\r\nack = HPI_HIF_ERROR_MASK;\r\nreturn (short)ack;\r\n}\r\nstatic short hpi6000_update_control_cache(struct hpi_adapter_obj *pao,\r\nstruct hpi_message *phm)\r\n{\r\nconst u16 dsp_index = 0;\r\nstruct hpi_hw_obj *phw = pao->priv;\r\nstruct dsp_obj *pdo = &phw->ado[dsp_index];\r\nu32 timeout;\r\nu32 cache_dirty_flag;\r\nu16 err;\r\nhpios_dsplock_lock(pao);\r\ntimeout = TIMEOUT;\r\ndo {\r\ncache_dirty_flag =\r\nhpi_read_word((struct dsp_obj *)pdo,\r\nHPI_HIF_ADDR(control_cache_is_dirty));\r\n} while (hpi6000_check_PCI2040_error_flag(pao, H6READ) && --timeout);\r\nif (!timeout) {\r\nerr = HPI6000_ERROR_CONTROL_CACHE_PARAMS;\r\ngoto unlock;\r\n}\r\nif (cache_dirty_flag) {\r\nu32 address;\r\nu32 length;\r\ntimeout = TIMEOUT;\r\nif (pdo->control_cache_address_on_dsp == 0) {\r\ndo {\r\naddress =\r\nhpi_read_word((struct dsp_obj *)pdo,\r\nHPI_HIF_ADDR(control_cache_address));\r\nlength = hpi_read_word((struct dsp_obj *)pdo,\r\nHPI_HIF_ADDR\r\n(control_cache_size_in_bytes));\r\n} while (hpi6000_check_PCI2040_error_flag(pao, H6READ)\r\n&& --timeout);\r\nif (!timeout) {\r\nerr = HPI6000_ERROR_CONTROL_CACHE_ADDRLEN;\r\ngoto unlock;\r\n}\r\npdo->control_cache_address_on_dsp = address;\r\npdo->control_cache_length_on_dsp = length;\r\n} else {\r\naddress = pdo->control_cache_address_on_dsp;\r\nlength = pdo->control_cache_length_on_dsp;\r\n}\r\nif (hpi6000_dsp_block_read32(pao, dsp_index, address,\r\n(u32 *)&phw->control_cache[0],\r\nlength / sizeof(u32))) {\r\nerr = HPI6000_ERROR_CONTROL_CACHE_READ;\r\ngoto unlock;\r\n}\r\ndo {\r\nhpi_write_word((struct dsp_obj *)pdo,\r\nHPI_HIF_ADDR(control_cache_is_dirty), 0);\r\nhpi_set_address(pdo, HPI_HIF_ADDR(host_cmd));\r\n} while (hpi6000_check_PCI2040_error_flag(pao, H6WRITE)\r\n&& --timeout);\r\nif (!timeout) {\r\nerr = HPI6000_ERROR_CONTROL_CACHE_FLUSH;\r\ngoto unlock;\r\n}\r\n}\r\nerr = 0;\r\nunlock:\r\nhpios_dsplock_unlock(pao);\r\nreturn err;\r\n}\r\nstatic u16 get_dsp_index(struct hpi_adapter_obj *pao, struct hpi_message *phm)\r\n{\r\nu16 ret = 0;\r\nswitch (phm->object) {\r\ncase HPI_OBJ_ISTREAM:\r\nif (phm->obj_index < 2)\r\nret = 1;\r\nbreak;\r\ncase HPI_OBJ_PROFILE:\r\nret = phm->obj_index;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void hw_message(struct hpi_adapter_obj *pao, struct hpi_message *phm,\r\nstruct hpi_response *phr)\r\n{\r\nu16 error = 0;\r\nu16 dsp_index = 0;\r\nstruct hpi_hw_obj *phw = pao->priv;\r\nu16 num_dsp = phw->num_dsp;\r\nif (num_dsp < 2)\r\ndsp_index = 0;\r\nelse {\r\ndsp_index = get_dsp_index(pao, phm);\r\nif ((phm->function == HPI_ISTREAM_GROUP_ADD)\r\n|| (phm->function == HPI_OSTREAM_GROUP_ADD)) {\r\nstruct hpi_message hm;\r\nu16 add_index;\r\nhm.obj_index = phm->u.d.u.stream.stream_index;\r\nhm.object = phm->u.d.u.stream.object_type;\r\nadd_index = get_dsp_index(pao, &hm);\r\nif (add_index != dsp_index) {\r\nphr->error = HPI_ERROR_NO_INTERDSP_GROUPS;\r\nreturn;\r\n}\r\n}\r\n}\r\nhpios_dsplock_lock(pao);\r\nerror = hpi6000_message_response_sequence(pao, dsp_index, phm, phr);\r\nif (error)\r\ngoto err;\r\nif (phr->error)\r\ngoto out;\r\nswitch (phm->function) {\r\ncase HPI_OSTREAM_WRITE:\r\ncase HPI_ISTREAM_ANC_WRITE:\r\nerror = hpi6000_send_data(pao, dsp_index, phm, phr);\r\nbreak;\r\ncase HPI_ISTREAM_READ:\r\ncase HPI_OSTREAM_ANC_READ:\r\nerror = hpi6000_get_data(pao, dsp_index, phm, phr);\r\nbreak;\r\ncase HPI_ADAPTER_GET_ASSERT:\r\nphr->u.ax.assert.dsp_index = 0;\r\nif (num_dsp == 2) {\r\nif (!phr->u.ax.assert.count) {\r\nerror = hpi6000_message_response_sequence(pao,\r\n1, phm, phr);\r\nphr->u.ax.assert.dsp_index = 1;\r\n}\r\n}\r\n}\r\nerr:\r\nif (error) {\r\nif (error >= HPI_ERROR_BACKEND_BASE) {\r\nphr->error = HPI_ERROR_DSP_COMMUNICATION;\r\nphr->specific_error = error;\r\n} else {\r\nphr->error = error;\r\n}\r\nphr->size = sizeof(struct hpi_response_header);\r\n}\r\nout:\r\nhpios_dsplock_unlock(pao);\r\nreturn;\r\n}
