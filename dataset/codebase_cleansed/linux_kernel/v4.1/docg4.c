static inline void write_nop(void __iomem *docptr)\r\n{\r\nwritew(0, docptr + DOC_NOP);\r\n}\r\nstatic void docg4_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)\r\n{\r\nint i;\r\nstruct nand_chip *nand = mtd->priv;\r\nuint16_t *p = (uint16_t *) buf;\r\nlen >>= 1;\r\nfor (i = 0; i < len; i++)\r\np[i] = readw(nand->IO_ADDR_R);\r\n}\r\nstatic void docg4_write_buf16(struct mtd_info *mtd, const uint8_t *buf, int len)\r\n{\r\nint i;\r\nstruct nand_chip *nand = mtd->priv;\r\nuint16_t *p = (uint16_t *) buf;\r\nlen >>= 1;\r\nfor (i = 0; i < len; i++)\r\nwritew(p[i], nand->IO_ADDR_W);\r\n}\r\nstatic int poll_status(struct docg4_priv *doc)\r\n{\r\nuint16_t flash_status;\r\nunsigned long timeo;\r\nvoid __iomem *docptr = doc->virtadr;\r\ndev_dbg(doc->dev, "%s...\n", __func__);\r\nflash_status = readw(docptr + DOC_FLASHCONTROL);\r\ntimeo = jiffies + msecs_to_jiffies(200);\r\ndo {\r\ncpu_relax();\r\nflash_status = readb(docptr + DOC_FLASHCONTROL);\r\n} while (!(flash_status & DOC_CTRL_FLASHREADY) &&\r\ntime_before(jiffies, timeo));\r\nif (unlikely(!(flash_status & DOC_CTRL_FLASHREADY))) {\r\ndev_err(doc->dev, "%s: timed out!\n", __func__);\r\nreturn NAND_STATUS_FAIL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int docg4_wait(struct mtd_info *mtd, struct nand_chip *nand)\r\n{\r\nstruct docg4_priv *doc = nand->priv;\r\nint status = NAND_STATUS_WP;\r\ndev_dbg(doc->dev, "%s...\n", __func__);\r\nif (doc->status) {\r\nstatus |= doc->status;\r\ndoc->status = 0;\r\nreturn status;\r\n}\r\nstatus |= poll_status(doc);\r\nreturn status;\r\n}\r\nstatic void docg4_select_chip(struct mtd_info *mtd, int chip)\r\n{\r\nstruct nand_chip *nand = mtd->priv;\r\nstruct docg4_priv *doc = nand->priv;\r\nvoid __iomem *docptr = doc->virtadr;\r\ndev_dbg(doc->dev, "%s: chip %d\n", __func__, chip);\r\nif (chip < 0)\r\nreturn;\r\nif (chip > 0)\r\ndev_warn(doc->dev, "multiple floors currently unsupported\n");\r\nwritew(0, docptr + DOC_DEVICESELECT);\r\n}\r\nstatic void reset(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *nand = mtd->priv;\r\nstruct docg4_priv *doc = nand->priv;\r\nvoid __iomem *docptr = doc->virtadr;\r\nwritew(DOC_ASICMODE_RESET | DOC_ASICMODE_MDWREN,\r\ndocptr + DOC_ASICMODE);\r\nwritew(~(DOC_ASICMODE_RESET | DOC_ASICMODE_MDWREN),\r\ndocptr + DOC_ASICMODECONFIRM);\r\nwrite_nop(docptr);\r\nwritew(DOC_ASICMODE_NORMAL | DOC_ASICMODE_MDWREN,\r\ndocptr + DOC_ASICMODE);\r\nwritew(~(DOC_ASICMODE_NORMAL | DOC_ASICMODE_MDWREN),\r\ndocptr + DOC_ASICMODECONFIRM);\r\nwritew(DOC_ECCCONF1_ECC_ENABLE, docptr + DOC_ECCCONF1);\r\npoll_status(doc);\r\n}\r\nstatic void read_hw_ecc(void __iomem *docptr, uint8_t *ecc_buf)\r\n{\r\nint i;\r\nfor (i = 0; i < 7; i++) {\r\necc_buf[i] = readb(docptr + DOC_BCH_SYNDROM(i));\r\necc_buf[i] = readb(docptr + DOC_BCH_SYNDROM(i));\r\n}\r\n}\r\nstatic int correct_data(struct mtd_info *mtd, uint8_t *buf, int page)\r\n{\r\nstruct nand_chip *nand = mtd->priv;\r\nstruct docg4_priv *doc = nand->priv;\r\nvoid __iomem *docptr = doc->virtadr;\r\nint i, numerrs, errpos[4];\r\nconst uint8_t blank_read_hwecc[8] = {\r\n0xcf, 0x72, 0xfc, 0x1b, 0xa9, 0xc7, 0xb9, 0 };\r\nread_hw_ecc(docptr, doc->ecc_buf);\r\nif (!memcmp(doc->ecc_buf, blank_read_hwecc, 7))\r\nreturn 0;\r\nif (ignore_badblocks == false) {\r\nif (nand->oob_poi[15]) {\r\nint bit, numsetbits = 0;\r\nunsigned long written_flag = nand->oob_poi[15];\r\nfor_each_set_bit(bit, &written_flag, 8)\r\nnumsetbits++;\r\nif (numsetbits > 4) {\r\ndev_warn(doc->dev,\r\n"error(s) in blank page "\r\n"at offset %08x\n",\r\npage * DOCG4_PAGE_SIZE);\r\nreturn 0;\r\n}\r\n}\r\n}\r\nfor (i = 0; i < 7; i++)\r\ndoc->ecc_buf[i] = bitrev8(doc->ecc_buf[i]);\r\nnumerrs = decode_bch(doc->bch, NULL, DOCG4_USERDATA_LEN, NULL,\r\ndoc->ecc_buf, NULL, errpos);\r\nif (numerrs == -EBADMSG) {\r\ndev_warn(doc->dev, "uncorrectable errors at offset %08x\n",\r\npage * DOCG4_PAGE_SIZE);\r\nreturn -EBADMSG;\r\n}\r\nBUG_ON(numerrs < 0);\r\nfor (i = 0; i < numerrs; i++)\r\nerrpos[i] = (errpos[i] & ~7)|(7-(errpos[i] & 7));\r\nfor (i = 0; i < numerrs; i++) {\r\nif (errpos[i] > DOCG4_USERDATA_LEN * 8)\r\ncontinue;\r\nif (errpos[i] > DOCG4_PAGE_SIZE * 8)\r\nchange_bit(errpos[i] - DOCG4_PAGE_SIZE * 8,\r\n(unsigned long *)nand->oob_poi);\r\nelse\r\nchange_bit(errpos[i], (unsigned long *)buf);\r\n}\r\ndev_notice(doc->dev, "%d error(s) corrected at offset %08x\n",\r\nnumerrs, page * DOCG4_PAGE_SIZE);\r\nreturn numerrs;\r\n}\r\nstatic uint8_t docg4_read_byte(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *nand = mtd->priv;\r\nstruct docg4_priv *doc = nand->priv;\r\ndev_dbg(doc->dev, "%s\n", __func__);\r\nif (doc->last_command.command == NAND_CMD_STATUS) {\r\nint status;\r\ndoc->last_command.command = 0;\r\nif (doc->status) {\r\nstatus = doc->status;\r\ndoc->status = 0;\r\n}\r\nelse\r\nstatus = NAND_STATUS_WP | NAND_STATUS_READY;\r\nreturn status;\r\n}\r\ndev_warn(doc->dev, "unexpected call to read_byte()\n");\r\nreturn 0;\r\n}\r\nstatic void write_addr(struct docg4_priv *doc, uint32_t docg4_addr)\r\n{\r\nvoid __iomem *docptr = doc->virtadr;\r\nwriteb(docg4_addr & 0xff, docptr + DOC_FLASHADDRESS);\r\ndocg4_addr >>= 8;\r\nwriteb(docg4_addr & 0xff, docptr + DOC_FLASHADDRESS);\r\ndocg4_addr >>= 8;\r\nwriteb(docg4_addr & 0xff, docptr + DOC_FLASHADDRESS);\r\ndocg4_addr >>= 8;\r\nwriteb(docg4_addr & 0xff, docptr + DOC_FLASHADDRESS);\r\n}\r\nstatic int read_progstatus(struct docg4_priv *doc)\r\n{\r\nvoid __iomem *docptr = doc->virtadr;\r\nuint16_t status1 = readw(docptr + DOC_IOSPACE_DATA);\r\nuint16_t status2 = readw(docptr + DOC_IOSPACE_DATA);\r\nuint16_t status3 = readw(docptr + DOCG4_MYSTERY_REG);\r\ndev_dbg(doc->dev, "docg4: %s: %02x %02x %02x\n",\r\n__func__, status1, status2, status3);\r\nif (status1 != DOCG4_PROGSTATUS_GOOD\r\n|| status2 != DOCG4_PROGSTATUS_GOOD_2\r\n|| status3 != DOCG4_PROGSTATUS_GOOD_2) {\r\ndoc->status = NAND_STATUS_FAIL;\r\ndev_warn(doc->dev, "read_progstatus failed: "\r\n"%02x, %02x, %02x\n", status1, status2, status3);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pageprog(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *nand = mtd->priv;\r\nstruct docg4_priv *doc = nand->priv;\r\nvoid __iomem *docptr = doc->virtadr;\r\nint retval = 0;\r\ndev_dbg(doc->dev, "docg4: %s\n", __func__);\r\nwritew(DOCG4_SEQ_PAGEPROG, docptr + DOC_FLASHSEQUENCE);\r\nwritew(DOC_CMD_PROG_CYCLE2, docptr + DOC_FLASHCOMMAND);\r\nwrite_nop(docptr);\r\nwrite_nop(docptr);\r\npoll_status(doc);\r\nwritew(DOCG4_SEQ_FLUSH, docptr + DOC_FLASHSEQUENCE);\r\nwritew(DOCG4_CMD_FLUSH, docptr + DOC_FLASHCOMMAND);\r\nwritew(DOC_ECCCONF0_READ_MODE | 4, docptr + DOC_ECCCONF0);\r\nwrite_nop(docptr);\r\nwrite_nop(docptr);\r\nwrite_nop(docptr);\r\nwrite_nop(docptr);\r\nwrite_nop(docptr);\r\nretval = read_progstatus(doc);\r\nwritew(0, docptr + DOC_DATAEND);\r\nwrite_nop(docptr);\r\npoll_status(doc);\r\nwrite_nop(docptr);\r\nreturn retval;\r\n}\r\nstatic void sequence_reset(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *nand = mtd->priv;\r\nstruct docg4_priv *doc = nand->priv;\r\nvoid __iomem *docptr = doc->virtadr;\r\nwritew(DOC_CTRL_UNKNOWN | DOC_CTRL_CE, docptr + DOC_FLASHCONTROL);\r\nwritew(DOC_SEQ_RESET, docptr + DOC_FLASHSEQUENCE);\r\nwritew(DOC_CMD_RESET, docptr + DOC_FLASHCOMMAND);\r\nwrite_nop(docptr);\r\nwrite_nop(docptr);\r\npoll_status(doc);\r\nwrite_nop(docptr);\r\n}\r\nstatic void read_page_prologue(struct mtd_info *mtd, uint32_t docg4_addr)\r\n{\r\nstruct nand_chip *nand = mtd->priv;\r\nstruct docg4_priv *doc = nand->priv;\r\nvoid __iomem *docptr = doc->virtadr;\r\ndev_dbg(doc->dev,\r\n"docg4: %s: g4 page %08x\n", __func__, docg4_addr);\r\nsequence_reset(mtd);\r\nwritew(DOCG4_SEQ_PAGE_READ, docptr + DOC_FLASHSEQUENCE);\r\nwritew(DOCG4_CMD_PAGE_READ, docptr + DOC_FLASHCOMMAND);\r\nwrite_nop(docptr);\r\nwrite_addr(doc, docg4_addr);\r\nwrite_nop(docptr);\r\nwritew(DOCG4_CMD_READ2, docptr + DOC_FLASHCOMMAND);\r\nwrite_nop(docptr);\r\nwrite_nop(docptr);\r\npoll_status(doc);\r\n}\r\nstatic void write_page_prologue(struct mtd_info *mtd, uint32_t docg4_addr)\r\n{\r\nstruct nand_chip *nand = mtd->priv;\r\nstruct docg4_priv *doc = nand->priv;\r\nvoid __iomem *docptr = doc->virtadr;\r\ndev_dbg(doc->dev,\r\n"docg4: %s: g4 addr: %x\n", __func__, docg4_addr);\r\nsequence_reset(mtd);\r\nif (unlikely(reliable_mode)) {\r\nwritew(DOCG4_SEQ_SETMODE, docptr + DOC_FLASHSEQUENCE);\r\nwritew(DOCG4_CMD_FAST_MODE, docptr + DOC_FLASHCOMMAND);\r\nwritew(DOC_CMD_RELIABLE_MODE, docptr + DOC_FLASHCOMMAND);\r\nwrite_nop(docptr);\r\n}\r\nwritew(DOCG4_SEQ_PAGEWRITE, docptr + DOC_FLASHSEQUENCE);\r\nwritew(DOCG4_CMD_PAGEWRITE, docptr + DOC_FLASHCOMMAND);\r\nwrite_nop(docptr);\r\nwrite_addr(doc, docg4_addr);\r\nwrite_nop(docptr);\r\nwrite_nop(docptr);\r\npoll_status(doc);\r\n}\r\nstatic uint32_t mtd_to_docg4_address(int page, int column)\r\n{\r\nint g4_page = page / 4;\r\nint g4_index = (page % 4) * 0x108 + column/2;\r\nreturn (g4_page << 16) | g4_index;\r\n}\r\nstatic void docg4_command(struct mtd_info *mtd, unsigned command, int column,\r\nint page_addr)\r\n{\r\nstruct nand_chip *nand = mtd->priv;\r\nstruct docg4_priv *doc = nand->priv;\r\nuint32_t g4_addr = mtd_to_docg4_address(page_addr, column);\r\ndev_dbg(doc->dev, "%s %x, page_addr=%x, column=%x\n",\r\n__func__, command, page_addr, column);\r\ndoc->last_command.command = command;\r\ndoc->last_command.column = column;\r\ndoc->last_command.page = page_addr;\r\nswitch (command) {\r\ncase NAND_CMD_RESET:\r\nreset(mtd);\r\nbreak;\r\ncase NAND_CMD_READ0:\r\nread_page_prologue(mtd, g4_addr);\r\nbreak;\r\ncase NAND_CMD_STATUS:\r\nbreak;\r\ncase NAND_CMD_SEQIN:\r\nif (unlikely(reliable_mode)) {\r\nuint16_t g4_page = g4_addr >> 16;\r\nif (g4_page & 0x01)\r\ndev_warn(doc->dev,\r\n"invalid reliable mode address\n");\r\n}\r\nwrite_page_prologue(mtd, g4_addr);\r\nif (doc->oob_page == page_addr)\r\nmemcpy(nand->oob_poi, doc->oob_buf, 16);\r\nbreak;\r\ncase NAND_CMD_PAGEPROG:\r\npageprog(mtd);\r\nbreak;\r\ncase NAND_CMD_READOOB:\r\ncase NAND_CMD_READID:\r\ncase NAND_CMD_ERASE1:\r\ncase NAND_CMD_ERASE2:\r\ndev_warn(doc->dev, "docg4_command: "\r\n"unexpected nand command 0x%x\n", command);\r\nbreak;\r\n}\r\n}\r\nstatic int read_page(struct mtd_info *mtd, struct nand_chip *nand,\r\nuint8_t *buf, int page, bool use_ecc)\r\n{\r\nstruct docg4_priv *doc = nand->priv;\r\nvoid __iomem *docptr = doc->virtadr;\r\nuint16_t status, edc_err, *buf16;\r\nint bits_corrected = 0;\r\ndev_dbg(doc->dev, "%s: page %08x\n", __func__, page);\r\nwritew(DOC_ECCCONF0_READ_MODE |\r\nDOC_ECCCONF0_ECC_ENABLE |\r\nDOC_ECCCONF0_UNKNOWN |\r\nDOCG4_BCH_SIZE,\r\ndocptr + DOC_ECCCONF0);\r\nwrite_nop(docptr);\r\nwrite_nop(docptr);\r\nwrite_nop(docptr);\r\nwrite_nop(docptr);\r\nwrite_nop(docptr);\r\nstatus = readw(docptr + DOC_IOSPACE_DATA);\r\nif (status & DOCG4_READ_ERROR) {\r\ndev_err(doc->dev,\r\n"docg4_read_page: bad status: 0x%02x\n", status);\r\nwritew(0, docptr + DOC_DATAEND);\r\nreturn -EIO;\r\n}\r\ndev_dbg(doc->dev, "%s: status = 0x%x\n", __func__, status);\r\ndocg4_read_buf(mtd, buf, DOCG4_PAGE_SIZE);\r\ndocg4_read_buf(mtd, nand->oob_poi, 14);\r\nbuf16 = (uint16_t *)(nand->oob_poi + 14);\r\n*buf16 = readw(docptr + DOCG4_MYSTERY_REG);\r\nwrite_nop(docptr);\r\nif (likely(use_ecc == true)) {\r\nedc_err = readw(docptr + DOC_ECCCONF1);\r\nedc_err = readw(docptr + DOC_ECCCONF1);\r\ndev_dbg(doc->dev, "%s: edc_err = 0x%02x\n", __func__, edc_err);\r\nif (edc_err & DOC_ECCCONF1_BCH_SYNDROM_ERR) {\r\nbits_corrected = correct_data(mtd, buf, page);\r\nif (bits_corrected == -EBADMSG)\r\nmtd->ecc_stats.failed++;\r\nelse\r\nmtd->ecc_stats.corrected += bits_corrected;\r\n}\r\n}\r\nwritew(0, docptr + DOC_DATAEND);\r\nif (bits_corrected == -EBADMSG)\r\nreturn 0;\r\nreturn bits_corrected;\r\n}\r\nstatic int docg4_read_page_raw(struct mtd_info *mtd, struct nand_chip *nand,\r\nuint8_t *buf, int oob_required, int page)\r\n{\r\nreturn read_page(mtd, nand, buf, page, false);\r\n}\r\nstatic int docg4_read_page(struct mtd_info *mtd, struct nand_chip *nand,\r\nuint8_t *buf, int oob_required, int page)\r\n{\r\nreturn read_page(mtd, nand, buf, page, true);\r\n}\r\nstatic int docg4_read_oob(struct mtd_info *mtd, struct nand_chip *nand,\r\nint page)\r\n{\r\nstruct docg4_priv *doc = nand->priv;\r\nvoid __iomem *docptr = doc->virtadr;\r\nuint16_t status;\r\ndev_dbg(doc->dev, "%s: page %x\n", __func__, page);\r\ndocg4_command(mtd, NAND_CMD_READ0, nand->ecc.size, page);\r\nwritew(DOC_ECCCONF0_READ_MODE | DOCG4_OOB_SIZE, docptr + DOC_ECCCONF0);\r\nwrite_nop(docptr);\r\nwrite_nop(docptr);\r\nwrite_nop(docptr);\r\nwrite_nop(docptr);\r\nwrite_nop(docptr);\r\nstatus = readw(docptr + DOC_IOSPACE_DATA);\r\nif (status & DOCG4_READ_ERROR) {\r\ndev_warn(doc->dev,\r\n"docg4_read_oob failed: status = 0x%02x\n", status);\r\nreturn -EIO;\r\n}\r\ndev_dbg(doc->dev, "%s: status = 0x%x\n", __func__, status);\r\ndocg4_read_buf(mtd, nand->oob_poi, 16);\r\nwrite_nop(docptr);\r\nwrite_nop(docptr);\r\nwrite_nop(docptr);\r\nwritew(0, docptr + DOC_DATAEND);\r\nwrite_nop(docptr);\r\nreturn 0;\r\n}\r\nstatic int docg4_erase_block(struct mtd_info *mtd, int page)\r\n{\r\nstruct nand_chip *nand = mtd->priv;\r\nstruct docg4_priv *doc = nand->priv;\r\nvoid __iomem *docptr = doc->virtadr;\r\nuint16_t g4_page;\r\ndev_dbg(doc->dev, "%s: page %04x\n", __func__, page);\r\nsequence_reset(mtd);\r\nwritew(DOCG4_SEQ_BLOCKERASE, docptr + DOC_FLASHSEQUENCE);\r\nwritew(DOC_CMD_PROG_BLOCK_ADDR, docptr + DOC_FLASHCOMMAND);\r\nwrite_nop(docptr);\r\ng4_page = (uint16_t)(page / 4);\r\nwriteb(g4_page & 0xff, docptr + DOC_FLASHADDRESS);\r\ng4_page >>= 8;\r\nwriteb(g4_page & 0xff, docptr + DOC_FLASHADDRESS);\r\nwrite_nop(docptr);\r\nwritew(DOC_CMD_ERASECYCLE2, docptr + DOC_FLASHCOMMAND);\r\nwrite_nop(docptr);\r\nwrite_nop(docptr);\r\nusleep_range(500, 1000);\r\npoll_status(doc);\r\nwritew(DOCG4_SEQ_FLUSH, docptr + DOC_FLASHSEQUENCE);\r\nwritew(DOCG4_CMD_FLUSH, docptr + DOC_FLASHCOMMAND);\r\nwritew(DOC_ECCCONF0_READ_MODE | 4, docptr + DOC_ECCCONF0);\r\nwrite_nop(docptr);\r\nwrite_nop(docptr);\r\nwrite_nop(docptr);\r\nwrite_nop(docptr);\r\nwrite_nop(docptr);\r\nread_progstatus(doc);\r\nwritew(0, docptr + DOC_DATAEND);\r\nwrite_nop(docptr);\r\npoll_status(doc);\r\nwrite_nop(docptr);\r\nreturn nand->waitfunc(mtd, nand);\r\n}\r\nstatic int write_page(struct mtd_info *mtd, struct nand_chip *nand,\r\nconst uint8_t *buf, bool use_ecc)\r\n{\r\nstruct docg4_priv *doc = nand->priv;\r\nvoid __iomem *docptr = doc->virtadr;\r\nuint8_t ecc_buf[8];\r\ndev_dbg(doc->dev, "%s...\n", __func__);\r\nwritew(DOC_ECCCONF0_ECC_ENABLE |\r\nDOC_ECCCONF0_UNKNOWN |\r\nDOCG4_BCH_SIZE,\r\ndocptr + DOC_ECCCONF0);\r\nwrite_nop(docptr);\r\ndocg4_write_buf16(mtd, buf, DOCG4_PAGE_SIZE);\r\ndocg4_write_buf16(mtd, nand->oob_poi, 6);\r\nwritew(nand->oob_poi[6], docptr + DOCG4_OOB_6_7);\r\nwrite_nop(docptr);\r\nwrite_nop(docptr);\r\nif (likely(use_ecc == true)) {\r\nuint8_t hamming = readb(docptr + DOC_HAMMINGPARITY);\r\nhamming = readb(docptr + DOC_HAMMINGPARITY);\r\nwritew(hamming, docptr + DOCG4_OOB_6_7);\r\nwrite_nop(docptr);\r\nread_hw_ecc(docptr, ecc_buf);\r\necc_buf[7] = 0;\r\n}\r\nelse {\r\nwritew(nand->oob_poi[7], docptr + DOCG4_OOB_6_7);\r\nwrite_nop(docptr);\r\nmemcpy(ecc_buf, &nand->oob_poi[8], 8);\r\n}\r\ndocg4_write_buf16(mtd, ecc_buf, 8);\r\nwrite_nop(docptr);\r\nwrite_nop(docptr);\r\nwritew(0, docptr + DOC_DATAEND);\r\nwrite_nop(docptr);\r\nreturn 0;\r\n}\r\nstatic int docg4_write_page_raw(struct mtd_info *mtd, struct nand_chip *nand,\r\nconst uint8_t *buf, int oob_required)\r\n{\r\nreturn write_page(mtd, nand, buf, false);\r\n}\r\nstatic int docg4_write_page(struct mtd_info *mtd, struct nand_chip *nand,\r\nconst uint8_t *buf, int oob_required)\r\n{\r\nreturn write_page(mtd, nand, buf, true);\r\n}\r\nstatic int docg4_write_oob(struct mtd_info *mtd, struct nand_chip *nand,\r\nint page)\r\n{\r\nstruct docg4_priv *doc = nand->priv;\r\ndoc->oob_page = page;\r\nmemcpy(doc->oob_buf, nand->oob_poi, 16);\r\nreturn 0;\r\n}\r\nstatic int __init read_factory_bbt(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *nand = mtd->priv;\r\nstruct docg4_priv *doc = nand->priv;\r\nuint32_t g4_addr = mtd_to_docg4_address(DOCG4_FACTORY_BBT_PAGE, 0);\r\nuint8_t *buf;\r\nint i, block;\r\n__u32 eccfailed_stats = mtd->ecc_stats.failed;\r\nbuf = kzalloc(DOCG4_PAGE_SIZE, GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\nread_page_prologue(mtd, g4_addr);\r\ndocg4_read_page(mtd, nand, buf, 0, DOCG4_FACTORY_BBT_PAGE);\r\nif (nand->bbt == NULL)\r\ngoto exit;\r\nif (mtd->ecc_stats.failed > eccfailed_stats) {\r\neccfailed_stats = mtd->ecc_stats.failed;\r\ndocg4_read_page(mtd, nand, buf, 0, DOCG4_REDUNDANT_BBT_PAGE);\r\nif (mtd->ecc_stats.failed > eccfailed_stats) {\r\ndev_warn(doc->dev,\r\n"The factory bbt could not be read!\n");\r\ngoto exit;\r\n}\r\n}\r\nfor (i = block = 0; block < DOCG4_NUMBLOCKS; block += 8, i++) {\r\nint bitnum;\r\nunsigned long bits = ~buf[i];\r\nfor_each_set_bit(bitnum, &bits, 8) {\r\nint badblock = block + 7 - bitnum;\r\nnand->bbt[badblock / 4] |=\r\n0x03 << ((badblock % 4) * 2);\r\nmtd->ecc_stats.badblocks++;\r\ndev_notice(doc->dev, "factory-marked bad block: %d\n",\r\nbadblock);\r\n}\r\n}\r\nexit:\r\nkfree(buf);\r\nreturn 0;\r\n}\r\nstatic int docg4_block_markbad(struct mtd_info *mtd, loff_t ofs)\r\n{\r\nint ret, i;\r\nuint8_t *buf;\r\nstruct nand_chip *nand = mtd->priv;\r\nstruct docg4_priv *doc = nand->priv;\r\nstruct nand_bbt_descr *bbtd = nand->badblock_pattern;\r\nint page = (int)(ofs >> nand->page_shift);\r\nuint32_t g4_addr = mtd_to_docg4_address(page, 0);\r\ndev_dbg(doc->dev, "%s: %08llx\n", __func__, ofs);\r\nif (unlikely(ofs & (DOCG4_BLOCK_SIZE - 1)))\r\ndev_warn(doc->dev, "%s: ofs %llx not start of block!\n",\r\n__func__, ofs);\r\nbuf = kzalloc(DOCG4_PAGE_SIZE, GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\nmemset(nand->oob_poi, 0xff, mtd->oobsize);\r\nfor (i = 0; i < bbtd->len; i++)\r\nnand->oob_poi[bbtd->offs + i] = ~bbtd->pattern[i];\r\nwrite_page_prologue(mtd, g4_addr);\r\ndocg4_write_page(mtd, nand, buf, 1);\r\nret = pageprog(mtd);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int docg4_block_neverbad(struct mtd_info *mtd, loff_t ofs, int getchip)\r\n{\r\nreturn 0;\r\n}\r\nstatic int docg4_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nint i;\r\nuint8_t pwr_down;\r\nstruct docg4_priv *doc = platform_get_drvdata(pdev);\r\nvoid __iomem *docptr = doc->virtadr;\r\ndev_dbg(doc->dev, "%s...\n", __func__);\r\nfor (i = 0; i < 10; i++) {\r\npwr_down = readb(docptr + DOC_POWERMODE);\r\nif (pwr_down & DOC_POWERDOWN_READY)\r\nbreak;\r\nusleep_range(1000, 4000);\r\n}\r\nif (pwr_down & DOC_POWERDOWN_READY) {\r\ndev_err(doc->dev, "suspend failed; "\r\n"timeout polling DOC_POWERDOWN_READY\n");\r\nreturn -EIO;\r\n}\r\nwritew(DOC_ASICMODE_POWERDOWN | DOC_ASICMODE_MDWREN,\r\ndocptr + DOC_ASICMODE);\r\nwritew(~(DOC_ASICMODE_POWERDOWN | DOC_ASICMODE_MDWREN),\r\ndocptr + DOC_ASICMODECONFIRM);\r\nwrite_nop(docptr);\r\nreturn 0;\r\n}\r\nstatic int docg4_resume(struct platform_device *pdev)\r\n{\r\nstruct docg4_priv *doc = platform_get_drvdata(pdev);\r\nvoid __iomem *docptr = doc->virtadr;\r\nint i;\r\ndev_dbg(doc->dev, "%s...\n", __func__);\r\nfor (i = 0; i < 12; i++)\r\nreadb(docptr + 0x1fff);\r\nreturn 0;\r\n}\r\nstatic void __init init_mtd_structs(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *nand = mtd->priv;\r\nstruct docg4_priv *doc = nand->priv;\r\nmtd->size = DOCG4_CHIP_SIZE;\r\nmtd->name = "Msys_Diskonchip_G4";\r\nmtd->writesize = DOCG4_PAGE_SIZE;\r\nmtd->erasesize = DOCG4_BLOCK_SIZE;\r\nmtd->oobsize = DOCG4_OOB_SIZE;\r\nnand->chipsize = DOCG4_CHIP_SIZE;\r\nnand->chip_shift = DOCG4_CHIP_SHIFT;\r\nnand->bbt_erase_shift = nand->phys_erase_shift = DOCG4_ERASE_SHIFT;\r\nnand->chip_delay = 20;\r\nnand->page_shift = DOCG4_PAGE_SHIFT;\r\nnand->pagemask = 0x3ffff;\r\nnand->badblockpos = NAND_LARGE_BADBLOCK_POS;\r\nnand->badblockbits = 8;\r\nnand->ecc.layout = &docg4_oobinfo;\r\nnand->ecc.mode = NAND_ECC_HW_SYNDROME;\r\nnand->ecc.size = DOCG4_PAGE_SIZE;\r\nnand->ecc.prepad = 8;\r\nnand->ecc.bytes = 8;\r\nnand->ecc.strength = DOCG4_T;\r\nnand->options = NAND_BUSWIDTH_16 | NAND_NO_SUBPAGE_WRITE;\r\nnand->IO_ADDR_R = nand->IO_ADDR_W = doc->virtadr + DOC_IOSPACE_DATA;\r\nnand->controller = &nand->hwcontrol;\r\nspin_lock_init(&nand->controller->lock);\r\ninit_waitqueue_head(&nand->controller->wq);\r\nnand->cmdfunc = docg4_command;\r\nnand->waitfunc = docg4_wait;\r\nnand->select_chip = docg4_select_chip;\r\nnand->read_byte = docg4_read_byte;\r\nnand->block_markbad = docg4_block_markbad;\r\nnand->read_buf = docg4_read_buf;\r\nnand->write_buf = docg4_write_buf16;\r\nnand->erase = docg4_erase_block;\r\nnand->ecc.read_page = docg4_read_page;\r\nnand->ecc.write_page = docg4_write_page;\r\nnand->ecc.read_page_raw = docg4_read_page_raw;\r\nnand->ecc.write_page_raw = docg4_write_page_raw;\r\nnand->ecc.read_oob = docg4_read_oob;\r\nnand->ecc.write_oob = docg4_write_oob;\r\nif (ignore_badblocks) {\r\nnand->options |= NAND_SKIP_BBTSCAN;\r\nnand->block_bad = docg4_block_neverbad;\r\n}\r\n}\r\nstatic int __init read_id_reg(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *nand = mtd->priv;\r\nstruct docg4_priv *doc = nand->priv;\r\nvoid __iomem *docptr = doc->virtadr;\r\nuint16_t id1, id2;\r\nid1 = readw(docptr + DOC_CHIPID);\r\nid1 = readw(docptr + DOCG4_MYSTERY_REG);\r\nid2 = readw(docptr + DOC_CHIPID_INV);\r\nid2 = readw(docptr + DOCG4_MYSTERY_REG);\r\nif (id1 == DOCG4_IDREG1_VALUE && id2 == DOCG4_IDREG2_VALUE) {\r\ndev_info(doc->dev,\r\n"NAND device: 128MiB Diskonchip G4 detected\n");\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int __init probe_docg4(struct platform_device *pdev)\r\n{\r\nstruct mtd_info *mtd;\r\nstruct nand_chip *nand;\r\nvoid __iomem *virtadr;\r\nstruct docg4_priv *doc;\r\nint len, retval;\r\nstruct resource *r;\r\nstruct device *dev = &pdev->dev;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (r == NULL) {\r\ndev_err(dev, "no io memory resource defined!\n");\r\nreturn -ENODEV;\r\n}\r\nvirtadr = ioremap(r->start, resource_size(r));\r\nif (!virtadr) {\r\ndev_err(dev, "Diskonchip ioremap failed: %pR\n", r);\r\nreturn -EIO;\r\n}\r\nlen = sizeof(struct mtd_info) + sizeof(struct nand_chip) +\r\nsizeof(struct docg4_priv);\r\nmtd = kzalloc(len, GFP_KERNEL);\r\nif (mtd == NULL) {\r\nretval = -ENOMEM;\r\ngoto fail;\r\n}\r\nnand = (struct nand_chip *) (mtd + 1);\r\ndoc = (struct docg4_priv *) (nand + 1);\r\nmtd->priv = nand;\r\nnand->priv = doc;\r\nmtd->owner = THIS_MODULE;\r\ndoc->virtadr = virtadr;\r\ndoc->dev = dev;\r\ninit_mtd_structs(mtd);\r\ndoc->bch = init_bch(DOCG4_M, DOCG4_T, DOCG4_PRIMITIVE_POLY);\r\nif (doc->bch == NULL) {\r\nretval = -EINVAL;\r\ngoto fail;\r\n}\r\nplatform_set_drvdata(pdev, doc);\r\nreset(mtd);\r\nretval = read_id_reg(mtd);\r\nif (retval == -ENODEV) {\r\ndev_warn(dev, "No diskonchip G4 device found.\n");\r\ngoto fail;\r\n}\r\nretval = nand_scan_tail(mtd);\r\nif (retval)\r\ngoto fail;\r\nretval = read_factory_bbt(mtd);\r\nif (retval)\r\ngoto fail;\r\nretval = mtd_device_parse_register(mtd, part_probes, NULL, NULL, 0);\r\nif (retval)\r\ngoto fail;\r\ndoc->mtd = mtd;\r\nreturn 0;\r\nfail:\r\niounmap(virtadr);\r\nif (mtd) {\r\nstruct nand_chip *nand = mtd->priv;\r\nstruct docg4_priv *doc = nand->priv;\r\nnand_release(mtd);\r\nfree_bch(doc->bch);\r\nkfree(mtd);\r\n}\r\nreturn retval;\r\n}\r\nstatic int __exit cleanup_docg4(struct platform_device *pdev)\r\n{\r\nstruct docg4_priv *doc = platform_get_drvdata(pdev);\r\nnand_release(doc->mtd);\r\nfree_bch(doc->bch);\r\nkfree(doc->mtd);\r\niounmap(doc->virtadr);\r\nreturn 0;\r\n}
