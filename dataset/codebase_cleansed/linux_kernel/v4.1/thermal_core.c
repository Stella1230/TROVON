static struct thermal_governor *__find_governor(const char *name)\r\n{\r\nstruct thermal_governor *pos;\r\nif (!name || !name[0])\r\nreturn def_governor;\r\nlist_for_each_entry(pos, &thermal_governor_list, governor_list)\r\nif (!strncasecmp(name, pos->name, THERMAL_NAME_LENGTH))\r\nreturn pos;\r\nreturn NULL;\r\n}\r\nint thermal_register_governor(struct thermal_governor *governor)\r\n{\r\nint err;\r\nconst char *name;\r\nstruct thermal_zone_device *pos;\r\nif (!governor)\r\nreturn -EINVAL;\r\nmutex_lock(&thermal_governor_lock);\r\nerr = -EBUSY;\r\nif (__find_governor(governor->name) == NULL) {\r\nerr = 0;\r\nlist_add(&governor->governor_list, &thermal_governor_list);\r\nif (!def_governor && !strncmp(governor->name,\r\nDEFAULT_THERMAL_GOVERNOR, THERMAL_NAME_LENGTH))\r\ndef_governor = governor;\r\n}\r\nmutex_lock(&thermal_list_lock);\r\nlist_for_each_entry(pos, &thermal_tz_list, node) {\r\nif (pos->governor)\r\ncontinue;\r\nname = pos->tzp->governor_name;\r\nif (!strncasecmp(name, governor->name, THERMAL_NAME_LENGTH))\r\npos->governor = governor;\r\n}\r\nmutex_unlock(&thermal_list_lock);\r\nmutex_unlock(&thermal_governor_lock);\r\nreturn err;\r\n}\r\nvoid thermal_unregister_governor(struct thermal_governor *governor)\r\n{\r\nstruct thermal_zone_device *pos;\r\nif (!governor)\r\nreturn;\r\nmutex_lock(&thermal_governor_lock);\r\nif (__find_governor(governor->name) == NULL)\r\ngoto exit;\r\nmutex_lock(&thermal_list_lock);\r\nlist_for_each_entry(pos, &thermal_tz_list, node) {\r\nif (!strncasecmp(pos->governor->name, governor->name,\r\nTHERMAL_NAME_LENGTH))\r\npos->governor = NULL;\r\n}\r\nmutex_unlock(&thermal_list_lock);\r\nlist_del(&governor->governor_list);\r\nexit:\r\nmutex_unlock(&thermal_governor_lock);\r\nreturn;\r\n}\r\nstatic int get_idr(struct idr *idr, struct mutex *lock, int *id)\r\n{\r\nint ret;\r\nif (lock)\r\nmutex_lock(lock);\r\nret = idr_alloc(idr, NULL, 0, 0, GFP_KERNEL);\r\nif (lock)\r\nmutex_unlock(lock);\r\nif (unlikely(ret < 0))\r\nreturn ret;\r\n*id = ret;\r\nreturn 0;\r\n}\r\nstatic void release_idr(struct idr *idr, struct mutex *lock, int id)\r\n{\r\nif (lock)\r\nmutex_lock(lock);\r\nidr_remove(idr, id);\r\nif (lock)\r\nmutex_unlock(lock);\r\n}\r\nint get_tz_trend(struct thermal_zone_device *tz, int trip)\r\n{\r\nenum thermal_trend trend;\r\nif (tz->emul_temperature || !tz->ops->get_trend ||\r\ntz->ops->get_trend(tz, trip, &trend)) {\r\nif (tz->temperature > tz->last_temperature)\r\ntrend = THERMAL_TREND_RAISING;\r\nelse if (tz->temperature < tz->last_temperature)\r\ntrend = THERMAL_TREND_DROPPING;\r\nelse\r\ntrend = THERMAL_TREND_STABLE;\r\n}\r\nreturn trend;\r\n}\r\nstruct thermal_instance *get_thermal_instance(struct thermal_zone_device *tz,\r\nstruct thermal_cooling_device *cdev, int trip)\r\n{\r\nstruct thermal_instance *pos = NULL;\r\nstruct thermal_instance *target_instance = NULL;\r\nmutex_lock(&tz->lock);\r\nmutex_lock(&cdev->lock);\r\nlist_for_each_entry(pos, &tz->thermal_instances, tz_node) {\r\nif (pos->tz == tz && pos->trip == trip && pos->cdev == cdev) {\r\ntarget_instance = pos;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&cdev->lock);\r\nmutex_unlock(&tz->lock);\r\nreturn target_instance;\r\n}\r\nstatic void print_bind_err_msg(struct thermal_zone_device *tz,\r\nstruct thermal_cooling_device *cdev, int ret)\r\n{\r\ndev_err(&tz->device, "binding zone %s with cdev %s failed:%d\n",\r\ntz->type, cdev->type, ret);\r\n}\r\nstatic void __bind(struct thermal_zone_device *tz, int mask,\r\nstruct thermal_cooling_device *cdev,\r\nunsigned long *limits)\r\n{\r\nint i, ret;\r\nfor (i = 0; i < tz->trips; i++) {\r\nif (mask & (1 << i)) {\r\nunsigned long upper, lower;\r\nupper = THERMAL_NO_LIMIT;\r\nlower = THERMAL_NO_LIMIT;\r\nif (limits) {\r\nlower = limits[i * 2];\r\nupper = limits[i * 2 + 1];\r\n}\r\nret = thermal_zone_bind_cooling_device(tz, i, cdev,\r\nupper, lower);\r\nif (ret)\r\nprint_bind_err_msg(tz, cdev, ret);\r\n}\r\n}\r\n}\r\nstatic void __unbind(struct thermal_zone_device *tz, int mask,\r\nstruct thermal_cooling_device *cdev)\r\n{\r\nint i;\r\nfor (i = 0; i < tz->trips; i++)\r\nif (mask & (1 << i))\r\nthermal_zone_unbind_cooling_device(tz, i, cdev);\r\n}\r\nstatic void bind_cdev(struct thermal_cooling_device *cdev)\r\n{\r\nint i, ret;\r\nconst struct thermal_zone_params *tzp;\r\nstruct thermal_zone_device *pos = NULL;\r\nmutex_lock(&thermal_list_lock);\r\nlist_for_each_entry(pos, &thermal_tz_list, node) {\r\nif (!pos->tzp && !pos->ops->bind)\r\ncontinue;\r\nif (pos->ops->bind) {\r\nret = pos->ops->bind(pos, cdev);\r\nif (ret)\r\nprint_bind_err_msg(pos, cdev, ret);\r\ncontinue;\r\n}\r\ntzp = pos->tzp;\r\nif (!tzp || !tzp->tbp)\r\ncontinue;\r\nfor (i = 0; i < tzp->num_tbps; i++) {\r\nif (tzp->tbp[i].cdev || !tzp->tbp[i].match)\r\ncontinue;\r\nif (tzp->tbp[i].match(pos, cdev))\r\ncontinue;\r\ntzp->tbp[i].cdev = cdev;\r\n__bind(pos, tzp->tbp[i].trip_mask, cdev,\r\ntzp->tbp[i].binding_limits);\r\n}\r\n}\r\nmutex_unlock(&thermal_list_lock);\r\n}\r\nstatic void bind_tz(struct thermal_zone_device *tz)\r\n{\r\nint i, ret;\r\nstruct thermal_cooling_device *pos = NULL;\r\nconst struct thermal_zone_params *tzp = tz->tzp;\r\nif (!tzp && !tz->ops->bind)\r\nreturn;\r\nmutex_lock(&thermal_list_lock);\r\nif (tz->ops->bind) {\r\nlist_for_each_entry(pos, &thermal_cdev_list, node) {\r\nret = tz->ops->bind(tz, pos);\r\nif (ret)\r\nprint_bind_err_msg(tz, pos, ret);\r\n}\r\ngoto exit;\r\n}\r\nif (!tzp || !tzp->tbp)\r\ngoto exit;\r\nlist_for_each_entry(pos, &thermal_cdev_list, node) {\r\nfor (i = 0; i < tzp->num_tbps; i++) {\r\nif (tzp->tbp[i].cdev || !tzp->tbp[i].match)\r\ncontinue;\r\nif (tzp->tbp[i].match(tz, pos))\r\ncontinue;\r\ntzp->tbp[i].cdev = pos;\r\n__bind(tz, tzp->tbp[i].trip_mask, pos,\r\ntzp->tbp[i].binding_limits);\r\n}\r\n}\r\nexit:\r\nmutex_unlock(&thermal_list_lock);\r\n}\r\nstatic void thermal_zone_device_set_polling(struct thermal_zone_device *tz,\r\nint delay)\r\n{\r\nif (delay > 1000)\r\nmod_delayed_work(system_freezable_wq, &tz->poll_queue,\r\nround_jiffies(msecs_to_jiffies(delay)));\r\nelse if (delay)\r\nmod_delayed_work(system_freezable_wq, &tz->poll_queue,\r\nmsecs_to_jiffies(delay));\r\nelse\r\ncancel_delayed_work(&tz->poll_queue);\r\n}\r\nstatic void monitor_thermal_zone(struct thermal_zone_device *tz)\r\n{\r\nmutex_lock(&tz->lock);\r\nif (tz->passive)\r\nthermal_zone_device_set_polling(tz, tz->passive_delay);\r\nelse if (tz->polling_delay)\r\nthermal_zone_device_set_polling(tz, tz->polling_delay);\r\nelse\r\nthermal_zone_device_set_polling(tz, 0);\r\nmutex_unlock(&tz->lock);\r\n}\r\nstatic void handle_non_critical_trips(struct thermal_zone_device *tz,\r\nint trip, enum thermal_trip_type trip_type)\r\n{\r\ntz->governor ? tz->governor->throttle(tz, trip) :\r\ndef_governor->throttle(tz, trip);\r\n}\r\nstatic void handle_critical_trips(struct thermal_zone_device *tz,\r\nint trip, enum thermal_trip_type trip_type)\r\n{\r\nlong trip_temp;\r\ntz->ops->get_trip_temp(tz, trip, &trip_temp);\r\nif (trip_temp <= 0 || tz->temperature < trip_temp)\r\nreturn;\r\ntrace_thermal_zone_trip(tz, trip, trip_type);\r\nif (tz->ops->notify)\r\ntz->ops->notify(tz, trip, trip_type);\r\nif (trip_type == THERMAL_TRIP_CRITICAL) {\r\ndev_emerg(&tz->device,\r\n"critical temperature reached(%d C),shutting down\n",\r\ntz->temperature / 1000);\r\norderly_poweroff(true);\r\n}\r\n}\r\nstatic void handle_thermal_trip(struct thermal_zone_device *tz, int trip)\r\n{\r\nenum thermal_trip_type type;\r\ntz->ops->get_trip_type(tz, trip, &type);\r\nif (type == THERMAL_TRIP_CRITICAL || type == THERMAL_TRIP_HOT)\r\nhandle_critical_trips(tz, trip, type);\r\nelse\r\nhandle_non_critical_trips(tz, trip, type);\r\nmonitor_thermal_zone(tz);\r\n}\r\nint thermal_zone_get_temp(struct thermal_zone_device *tz, unsigned long *temp)\r\n{\r\nint ret = -EINVAL;\r\n#ifdef CONFIG_THERMAL_EMULATION\r\nint count;\r\nunsigned long crit_temp = -1UL;\r\nenum thermal_trip_type type;\r\n#endif\r\nif (!tz || IS_ERR(tz) || !tz->ops->get_temp)\r\ngoto exit;\r\nmutex_lock(&tz->lock);\r\nret = tz->ops->get_temp(tz, temp);\r\n#ifdef CONFIG_THERMAL_EMULATION\r\nif (!tz->emul_temperature)\r\ngoto skip_emul;\r\nfor (count = 0; count < tz->trips; count++) {\r\nret = tz->ops->get_trip_type(tz, count, &type);\r\nif (!ret && type == THERMAL_TRIP_CRITICAL) {\r\nret = tz->ops->get_trip_temp(tz, count, &crit_temp);\r\nbreak;\r\n}\r\n}\r\nif (ret)\r\ngoto skip_emul;\r\nif (*temp < crit_temp)\r\n*temp = tz->emul_temperature;\r\nskip_emul:\r\n#endif\r\nmutex_unlock(&tz->lock);\r\nexit:\r\nreturn ret;\r\n}\r\nstatic void update_temperature(struct thermal_zone_device *tz)\r\n{\r\nlong temp;\r\nint ret;\r\nret = thermal_zone_get_temp(tz, &temp);\r\nif (ret) {\r\nif (ret != -EAGAIN)\r\ndev_warn(&tz->device,\r\n"failed to read out thermal zone (%d)\n",\r\nret);\r\nreturn;\r\n}\r\nmutex_lock(&tz->lock);\r\ntz->last_temperature = tz->temperature;\r\ntz->temperature = temp;\r\nmutex_unlock(&tz->lock);\r\ntrace_thermal_temperature(tz);\r\ndev_dbg(&tz->device, "last_temperature=%d, current_temperature=%d\n",\r\ntz->last_temperature, tz->temperature);\r\n}\r\nvoid thermal_zone_device_update(struct thermal_zone_device *tz)\r\n{\r\nint count;\r\nif (!tz->ops->get_temp)\r\nreturn;\r\nupdate_temperature(tz);\r\nfor (count = 0; count < tz->trips; count++)\r\nhandle_thermal_trip(tz, count);\r\n}\r\nstatic void thermal_zone_device_check(struct work_struct *work)\r\n{\r\nstruct thermal_zone_device *tz = container_of(work, struct\r\nthermal_zone_device,\r\npoll_queue.work);\r\nthermal_zone_device_update(tz);\r\n}\r\nstatic ssize_t\r\ntype_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct thermal_zone_device *tz = to_thermal_zone(dev);\r\nreturn sprintf(buf, "%s\n", tz->type);\r\n}\r\nstatic ssize_t\r\ntemp_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct thermal_zone_device *tz = to_thermal_zone(dev);\r\nlong temperature;\r\nint ret;\r\nret = thermal_zone_get_temp(tz, &temperature);\r\nif (ret)\r\nreturn ret;\r\nreturn sprintf(buf, "%ld\n", temperature);\r\n}\r\nstatic ssize_t\r\nmode_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct thermal_zone_device *tz = to_thermal_zone(dev);\r\nenum thermal_device_mode mode;\r\nint result;\r\nif (!tz->ops->get_mode)\r\nreturn -EPERM;\r\nresult = tz->ops->get_mode(tz, &mode);\r\nif (result)\r\nreturn result;\r\nreturn sprintf(buf, "%s\n", mode == THERMAL_DEVICE_ENABLED ? "enabled"\r\n: "disabled");\r\n}\r\nstatic ssize_t\r\nmode_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct thermal_zone_device *tz = to_thermal_zone(dev);\r\nint result;\r\nif (!tz->ops->set_mode)\r\nreturn -EPERM;\r\nif (!strncmp(buf, "enabled", sizeof("enabled") - 1))\r\nresult = tz->ops->set_mode(tz, THERMAL_DEVICE_ENABLED);\r\nelse if (!strncmp(buf, "disabled", sizeof("disabled") - 1))\r\nresult = tz->ops->set_mode(tz, THERMAL_DEVICE_DISABLED);\r\nelse\r\nresult = -EINVAL;\r\nif (result)\r\nreturn result;\r\nreturn count;\r\n}\r\nstatic ssize_t\r\ntrip_point_type_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct thermal_zone_device *tz = to_thermal_zone(dev);\r\nenum thermal_trip_type type;\r\nint trip, result;\r\nif (!tz->ops->get_trip_type)\r\nreturn -EPERM;\r\nif (!sscanf(attr->attr.name, "trip_point_%d_type", &trip))\r\nreturn -EINVAL;\r\nresult = tz->ops->get_trip_type(tz, trip, &type);\r\nif (result)\r\nreturn result;\r\nswitch (type) {\r\ncase THERMAL_TRIP_CRITICAL:\r\nreturn sprintf(buf, "critical\n");\r\ncase THERMAL_TRIP_HOT:\r\nreturn sprintf(buf, "hot\n");\r\ncase THERMAL_TRIP_PASSIVE:\r\nreturn sprintf(buf, "passive\n");\r\ncase THERMAL_TRIP_ACTIVE:\r\nreturn sprintf(buf, "active\n");\r\ndefault:\r\nreturn sprintf(buf, "unknown\n");\r\n}\r\n}\r\nstatic ssize_t\r\ntrip_point_temp_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct thermal_zone_device *tz = to_thermal_zone(dev);\r\nint trip, ret;\r\nunsigned long temperature;\r\nif (!tz->ops->set_trip_temp)\r\nreturn -EPERM;\r\nif (!sscanf(attr->attr.name, "trip_point_%d_temp", &trip))\r\nreturn -EINVAL;\r\nif (kstrtoul(buf, 10, &temperature))\r\nreturn -EINVAL;\r\nret = tz->ops->set_trip_temp(tz, trip, temperature);\r\nreturn ret ? ret : count;\r\n}\r\nstatic ssize_t\r\ntrip_point_temp_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct thermal_zone_device *tz = to_thermal_zone(dev);\r\nint trip, ret;\r\nlong temperature;\r\nif (!tz->ops->get_trip_temp)\r\nreturn -EPERM;\r\nif (!sscanf(attr->attr.name, "trip_point_%d_temp", &trip))\r\nreturn -EINVAL;\r\nret = tz->ops->get_trip_temp(tz, trip, &temperature);\r\nif (ret)\r\nreturn ret;\r\nreturn sprintf(buf, "%ld\n", temperature);\r\n}\r\nstatic ssize_t\r\ntrip_point_hyst_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct thermal_zone_device *tz = to_thermal_zone(dev);\r\nint trip, ret;\r\nunsigned long temperature;\r\nif (!tz->ops->set_trip_hyst)\r\nreturn -EPERM;\r\nif (!sscanf(attr->attr.name, "trip_point_%d_hyst", &trip))\r\nreturn -EINVAL;\r\nif (kstrtoul(buf, 10, &temperature))\r\nreturn -EINVAL;\r\nret = tz->ops->set_trip_hyst(tz, trip, temperature);\r\nreturn ret ? ret : count;\r\n}\r\nstatic ssize_t\r\ntrip_point_hyst_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct thermal_zone_device *tz = to_thermal_zone(dev);\r\nint trip, ret;\r\nunsigned long temperature;\r\nif (!tz->ops->get_trip_hyst)\r\nreturn -EPERM;\r\nif (!sscanf(attr->attr.name, "trip_point_%d_hyst", &trip))\r\nreturn -EINVAL;\r\nret = tz->ops->get_trip_hyst(tz, trip, &temperature);\r\nreturn ret ? ret : sprintf(buf, "%ld\n", temperature);\r\n}\r\nstatic ssize_t\r\npassive_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct thermal_zone_device *tz = to_thermal_zone(dev);\r\nstruct thermal_cooling_device *cdev = NULL;\r\nint state;\r\nif (!sscanf(buf, "%d\n", &state))\r\nreturn -EINVAL;\r\nif (state && state < 1000)\r\nreturn -EINVAL;\r\nif (state && !tz->forced_passive) {\r\nmutex_lock(&thermal_list_lock);\r\nlist_for_each_entry(cdev, &thermal_cdev_list, node) {\r\nif (!strncmp("Processor", cdev->type,\r\nsizeof("Processor")))\r\nthermal_zone_bind_cooling_device(tz,\r\nTHERMAL_TRIPS_NONE, cdev,\r\nTHERMAL_NO_LIMIT,\r\nTHERMAL_NO_LIMIT);\r\n}\r\nmutex_unlock(&thermal_list_lock);\r\nif (!tz->passive_delay)\r\ntz->passive_delay = 1000;\r\n} else if (!state && tz->forced_passive) {\r\nmutex_lock(&thermal_list_lock);\r\nlist_for_each_entry(cdev, &thermal_cdev_list, node) {\r\nif (!strncmp("Processor", cdev->type,\r\nsizeof("Processor")))\r\nthermal_zone_unbind_cooling_device(tz,\r\nTHERMAL_TRIPS_NONE,\r\ncdev);\r\n}\r\nmutex_unlock(&thermal_list_lock);\r\ntz->passive_delay = 0;\r\n}\r\ntz->forced_passive = state;\r\nthermal_zone_device_update(tz);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\npassive_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct thermal_zone_device *tz = to_thermal_zone(dev);\r\nreturn sprintf(buf, "%d\n", tz->forced_passive);\r\n}\r\nstatic ssize_t\r\npolicy_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint ret = -EINVAL;\r\nstruct thermal_zone_device *tz = to_thermal_zone(dev);\r\nstruct thermal_governor *gov;\r\nchar name[THERMAL_NAME_LENGTH];\r\nsnprintf(name, sizeof(name), "%s", buf);\r\nmutex_lock(&thermal_governor_lock);\r\nmutex_lock(&tz->lock);\r\ngov = __find_governor(strim(name));\r\nif (!gov)\r\ngoto exit;\r\ntz->governor = gov;\r\nret = count;\r\nexit:\r\nmutex_unlock(&tz->lock);\r\nmutex_unlock(&thermal_governor_lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t\r\npolicy_show(struct device *dev, struct device_attribute *devattr, char *buf)\r\n{\r\nstruct thermal_zone_device *tz = to_thermal_zone(dev);\r\nreturn sprintf(buf, "%s\n", tz->governor->name);\r\n}\r\nstatic ssize_t\r\nemul_temp_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct thermal_zone_device *tz = to_thermal_zone(dev);\r\nint ret = 0;\r\nunsigned long temperature;\r\nif (kstrtoul(buf, 10, &temperature))\r\nreturn -EINVAL;\r\nif (!tz->ops->set_emul_temp) {\r\nmutex_lock(&tz->lock);\r\ntz->emul_temperature = temperature;\r\nmutex_unlock(&tz->lock);\r\n} else {\r\nret = tz->ops->set_emul_temp(tz, temperature);\r\n}\r\nif (!ret)\r\nthermal_zone_device_update(tz);\r\nreturn ret ? ret : count;\r\n}\r\nstatic ssize_t\r\nthermal_cooling_device_type_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct thermal_cooling_device *cdev = to_cooling_device(dev);\r\nreturn sprintf(buf, "%s\n", cdev->type);\r\n}\r\nstatic ssize_t\r\nthermal_cooling_device_max_state_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct thermal_cooling_device *cdev = to_cooling_device(dev);\r\nunsigned long state;\r\nint ret;\r\nret = cdev->ops->get_max_state(cdev, &state);\r\nif (ret)\r\nreturn ret;\r\nreturn sprintf(buf, "%ld\n", state);\r\n}\r\nstatic ssize_t\r\nthermal_cooling_device_cur_state_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct thermal_cooling_device *cdev = to_cooling_device(dev);\r\nunsigned long state;\r\nint ret;\r\nret = cdev->ops->get_cur_state(cdev, &state);\r\nif (ret)\r\nreturn ret;\r\nreturn sprintf(buf, "%ld\n", state);\r\n}\r\nstatic ssize_t\r\nthermal_cooling_device_cur_state_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct thermal_cooling_device *cdev = to_cooling_device(dev);\r\nunsigned long state;\r\nint result;\r\nif (!sscanf(buf, "%ld\n", &state))\r\nreturn -EINVAL;\r\nif ((long)state < 0)\r\nreturn -EINVAL;\r\nresult = cdev->ops->set_cur_state(cdev, state);\r\nif (result)\r\nreturn result;\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nthermal_cooling_device_trip_point_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct thermal_instance *instance;\r\ninstance =\r\ncontainer_of(attr, struct thermal_instance, attr);\r\nif (instance->trip == THERMAL_TRIPS_NONE)\r\nreturn sprintf(buf, "-1\n");\r\nelse\r\nreturn sprintf(buf, "%d\n", instance->trip);\r\n}\r\nint thermal_zone_bind_cooling_device(struct thermal_zone_device *tz,\r\nint trip,\r\nstruct thermal_cooling_device *cdev,\r\nunsigned long upper, unsigned long lower)\r\n{\r\nstruct thermal_instance *dev;\r\nstruct thermal_instance *pos;\r\nstruct thermal_zone_device *pos1;\r\nstruct thermal_cooling_device *pos2;\r\nunsigned long max_state;\r\nint result, ret;\r\nif (trip >= tz->trips || (trip < 0 && trip != THERMAL_TRIPS_NONE))\r\nreturn -EINVAL;\r\nlist_for_each_entry(pos1, &thermal_tz_list, node) {\r\nif (pos1 == tz)\r\nbreak;\r\n}\r\nlist_for_each_entry(pos2, &thermal_cdev_list, node) {\r\nif (pos2 == cdev)\r\nbreak;\r\n}\r\nif (tz != pos1 || cdev != pos2)\r\nreturn -EINVAL;\r\nret = cdev->ops->get_max_state(cdev, &max_state);\r\nif (ret)\r\nreturn ret;\r\nlower = lower == THERMAL_NO_LIMIT ? 0 : lower;\r\nupper = upper == THERMAL_NO_LIMIT ? max_state : upper;\r\nif (lower > upper || upper > max_state)\r\nreturn -EINVAL;\r\ndev =\r\nkzalloc(sizeof(struct thermal_instance), GFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\ndev->tz = tz;\r\ndev->cdev = cdev;\r\ndev->trip = trip;\r\ndev->upper = upper;\r\ndev->lower = lower;\r\ndev->target = THERMAL_NO_TARGET;\r\nresult = get_idr(&tz->idr, &tz->lock, &dev->id);\r\nif (result)\r\ngoto free_mem;\r\nsprintf(dev->name, "cdev%d", dev->id);\r\nresult =\r\nsysfs_create_link(&tz->device.kobj, &cdev->device.kobj, dev->name);\r\nif (result)\r\ngoto release_idr;\r\nsprintf(dev->attr_name, "cdev%d_trip_point", dev->id);\r\nsysfs_attr_init(&dev->attr.attr);\r\ndev->attr.attr.name = dev->attr_name;\r\ndev->attr.attr.mode = 0444;\r\ndev->attr.show = thermal_cooling_device_trip_point_show;\r\nresult = device_create_file(&tz->device, &dev->attr);\r\nif (result)\r\ngoto remove_symbol_link;\r\nmutex_lock(&tz->lock);\r\nmutex_lock(&cdev->lock);\r\nlist_for_each_entry(pos, &tz->thermal_instances, tz_node)\r\nif (pos->tz == tz && pos->trip == trip && pos->cdev == cdev) {\r\nresult = -EEXIST;\r\nbreak;\r\n}\r\nif (!result) {\r\nlist_add_tail(&dev->tz_node, &tz->thermal_instances);\r\nlist_add_tail(&dev->cdev_node, &cdev->thermal_instances);\r\n}\r\nmutex_unlock(&cdev->lock);\r\nmutex_unlock(&tz->lock);\r\nif (!result)\r\nreturn 0;\r\ndevice_remove_file(&tz->device, &dev->attr);\r\nremove_symbol_link:\r\nsysfs_remove_link(&tz->device.kobj, dev->name);\r\nrelease_idr:\r\nrelease_idr(&tz->idr, &tz->lock, dev->id);\r\nfree_mem:\r\nkfree(dev);\r\nreturn result;\r\n}\r\nint thermal_zone_unbind_cooling_device(struct thermal_zone_device *tz,\r\nint trip,\r\nstruct thermal_cooling_device *cdev)\r\n{\r\nstruct thermal_instance *pos, *next;\r\nmutex_lock(&tz->lock);\r\nmutex_lock(&cdev->lock);\r\nlist_for_each_entry_safe(pos, next, &tz->thermal_instances, tz_node) {\r\nif (pos->tz == tz && pos->trip == trip && pos->cdev == cdev) {\r\nlist_del(&pos->tz_node);\r\nlist_del(&pos->cdev_node);\r\nmutex_unlock(&cdev->lock);\r\nmutex_unlock(&tz->lock);\r\ngoto unbind;\r\n}\r\n}\r\nmutex_unlock(&cdev->lock);\r\nmutex_unlock(&tz->lock);\r\nreturn -ENODEV;\r\nunbind:\r\ndevice_remove_file(&tz->device, &pos->attr);\r\nsysfs_remove_link(&tz->device.kobj, pos->name);\r\nrelease_idr(&tz->idr, &tz->lock, pos->id);\r\nkfree(pos);\r\nreturn 0;\r\n}\r\nstatic void thermal_release(struct device *dev)\r\n{\r\nstruct thermal_zone_device *tz;\r\nstruct thermal_cooling_device *cdev;\r\nif (!strncmp(dev_name(dev), "thermal_zone",\r\nsizeof("thermal_zone") - 1)) {\r\ntz = to_thermal_zone(dev);\r\nkfree(tz);\r\n} else if(!strncmp(dev_name(dev), "cooling_device",\r\nsizeof("cooling_device") - 1)){\r\ncdev = to_cooling_device(dev);\r\nkfree(cdev);\r\n}\r\n}\r\nstatic struct thermal_cooling_device *\r\n__thermal_cooling_device_register(struct device_node *np,\r\nchar *type, void *devdata,\r\nconst struct thermal_cooling_device_ops *ops)\r\n{\r\nstruct thermal_cooling_device *cdev;\r\nint result;\r\nif (type && strlen(type) >= THERMAL_NAME_LENGTH)\r\nreturn ERR_PTR(-EINVAL);\r\nif (!ops || !ops->get_max_state || !ops->get_cur_state ||\r\n!ops->set_cur_state)\r\nreturn ERR_PTR(-EINVAL);\r\ncdev = kzalloc(sizeof(struct thermal_cooling_device), GFP_KERNEL);\r\nif (!cdev)\r\nreturn ERR_PTR(-ENOMEM);\r\nresult = get_idr(&thermal_cdev_idr, &thermal_idr_lock, &cdev->id);\r\nif (result) {\r\nkfree(cdev);\r\nreturn ERR_PTR(result);\r\n}\r\nstrlcpy(cdev->type, type ? : "", sizeof(cdev->type));\r\nmutex_init(&cdev->lock);\r\nINIT_LIST_HEAD(&cdev->thermal_instances);\r\ncdev->np = np;\r\ncdev->ops = ops;\r\ncdev->updated = false;\r\ncdev->device.class = &thermal_class;\r\ncdev->device.groups = cooling_device_attr_groups;\r\ncdev->devdata = devdata;\r\ndev_set_name(&cdev->device, "cooling_device%d", cdev->id);\r\nresult = device_register(&cdev->device);\r\nif (result) {\r\nrelease_idr(&thermal_cdev_idr, &thermal_idr_lock, cdev->id);\r\nkfree(cdev);\r\nreturn ERR_PTR(result);\r\n}\r\nmutex_lock(&thermal_list_lock);\r\nlist_add(&cdev->node, &thermal_cdev_list);\r\nmutex_unlock(&thermal_list_lock);\r\nbind_cdev(cdev);\r\nreturn cdev;\r\n}\r\nstruct thermal_cooling_device *\r\nthermal_cooling_device_register(char *type, void *devdata,\r\nconst struct thermal_cooling_device_ops *ops)\r\n{\r\nreturn __thermal_cooling_device_register(NULL, type, devdata, ops);\r\n}\r\nstruct thermal_cooling_device *\r\nthermal_of_cooling_device_register(struct device_node *np,\r\nchar *type, void *devdata,\r\nconst struct thermal_cooling_device_ops *ops)\r\n{\r\nreturn __thermal_cooling_device_register(np, type, devdata, ops);\r\n}\r\nvoid thermal_cooling_device_unregister(struct thermal_cooling_device *cdev)\r\n{\r\nint i;\r\nconst struct thermal_zone_params *tzp;\r\nstruct thermal_zone_device *tz;\r\nstruct thermal_cooling_device *pos = NULL;\r\nif (!cdev)\r\nreturn;\r\nmutex_lock(&thermal_list_lock);\r\nlist_for_each_entry(pos, &thermal_cdev_list, node)\r\nif (pos == cdev)\r\nbreak;\r\nif (pos != cdev) {\r\nmutex_unlock(&thermal_list_lock);\r\nreturn;\r\n}\r\nlist_del(&cdev->node);\r\nlist_for_each_entry(tz, &thermal_tz_list, node) {\r\nif (tz->ops->unbind) {\r\ntz->ops->unbind(tz, cdev);\r\ncontinue;\r\n}\r\nif (!tz->tzp || !tz->tzp->tbp)\r\ncontinue;\r\ntzp = tz->tzp;\r\nfor (i = 0; i < tzp->num_tbps; i++) {\r\nif (tzp->tbp[i].cdev == cdev) {\r\n__unbind(tz, tzp->tbp[i].trip_mask, cdev);\r\ntzp->tbp[i].cdev = NULL;\r\n}\r\n}\r\n}\r\nmutex_unlock(&thermal_list_lock);\r\nif (cdev->type[0])\r\ndevice_remove_file(&cdev->device, &dev_attr_cdev_type);\r\ndevice_remove_file(&cdev->device, &dev_attr_max_state);\r\ndevice_remove_file(&cdev->device, &dev_attr_cur_state);\r\nrelease_idr(&thermal_cdev_idr, &thermal_idr_lock, cdev->id);\r\ndevice_unregister(&cdev->device);\r\nreturn;\r\n}\r\nvoid thermal_cdev_update(struct thermal_cooling_device *cdev)\r\n{\r\nstruct thermal_instance *instance;\r\nunsigned long target = 0;\r\nif (cdev->updated)\r\nreturn;\r\nmutex_lock(&cdev->lock);\r\nlist_for_each_entry(instance, &cdev->thermal_instances, cdev_node) {\r\ndev_dbg(&cdev->device, "zone%d->target=%lu\n",\r\ninstance->tz->id, instance->target);\r\nif (instance->target == THERMAL_NO_TARGET)\r\ncontinue;\r\nif (instance->target > target)\r\ntarget = instance->target;\r\n}\r\nmutex_unlock(&cdev->lock);\r\ncdev->ops->set_cur_state(cdev, target);\r\ncdev->updated = true;\r\ntrace_cdev_update(cdev, target);\r\ndev_dbg(&cdev->device, "set to state %lu\n", target);\r\n}\r\nvoid thermal_notify_framework(struct thermal_zone_device *tz, int trip)\r\n{\r\nhandle_thermal_trip(tz, trip);\r\n}\r\nstatic int create_trip_attrs(struct thermal_zone_device *tz, int mask)\r\n{\r\nint indx;\r\nint size = sizeof(struct thermal_attr) * tz->trips;\r\ntz->trip_type_attrs = kzalloc(size, GFP_KERNEL);\r\nif (!tz->trip_type_attrs)\r\nreturn -ENOMEM;\r\ntz->trip_temp_attrs = kzalloc(size, GFP_KERNEL);\r\nif (!tz->trip_temp_attrs) {\r\nkfree(tz->trip_type_attrs);\r\nreturn -ENOMEM;\r\n}\r\nif (tz->ops->get_trip_hyst) {\r\ntz->trip_hyst_attrs = kzalloc(size, GFP_KERNEL);\r\nif (!tz->trip_hyst_attrs) {\r\nkfree(tz->trip_type_attrs);\r\nkfree(tz->trip_temp_attrs);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nfor (indx = 0; indx < tz->trips; indx++) {\r\nsnprintf(tz->trip_type_attrs[indx].name, THERMAL_NAME_LENGTH,\r\n"trip_point_%d_type", indx);\r\nsysfs_attr_init(&tz->trip_type_attrs[indx].attr.attr);\r\ntz->trip_type_attrs[indx].attr.attr.name =\r\ntz->trip_type_attrs[indx].name;\r\ntz->trip_type_attrs[indx].attr.attr.mode = S_IRUGO;\r\ntz->trip_type_attrs[indx].attr.show = trip_point_type_show;\r\ndevice_create_file(&tz->device,\r\n&tz->trip_type_attrs[indx].attr);\r\nsnprintf(tz->trip_temp_attrs[indx].name, THERMAL_NAME_LENGTH,\r\n"trip_point_%d_temp", indx);\r\nsysfs_attr_init(&tz->trip_temp_attrs[indx].attr.attr);\r\ntz->trip_temp_attrs[indx].attr.attr.name =\r\ntz->trip_temp_attrs[indx].name;\r\ntz->trip_temp_attrs[indx].attr.attr.mode = S_IRUGO;\r\ntz->trip_temp_attrs[indx].attr.show = trip_point_temp_show;\r\nif (mask & (1 << indx)) {\r\ntz->trip_temp_attrs[indx].attr.attr.mode |= S_IWUSR;\r\ntz->trip_temp_attrs[indx].attr.store =\r\ntrip_point_temp_store;\r\n}\r\ndevice_create_file(&tz->device,\r\n&tz->trip_temp_attrs[indx].attr);\r\nif (!tz->ops->get_trip_hyst)\r\ncontinue;\r\nsnprintf(tz->trip_hyst_attrs[indx].name, THERMAL_NAME_LENGTH,\r\n"trip_point_%d_hyst", indx);\r\nsysfs_attr_init(&tz->trip_hyst_attrs[indx].attr.attr);\r\ntz->trip_hyst_attrs[indx].attr.attr.name =\r\ntz->trip_hyst_attrs[indx].name;\r\ntz->trip_hyst_attrs[indx].attr.attr.mode = S_IRUGO;\r\ntz->trip_hyst_attrs[indx].attr.show = trip_point_hyst_show;\r\nif (tz->ops->set_trip_hyst) {\r\ntz->trip_hyst_attrs[indx].attr.attr.mode |= S_IWUSR;\r\ntz->trip_hyst_attrs[indx].attr.store =\r\ntrip_point_hyst_store;\r\n}\r\ndevice_create_file(&tz->device,\r\n&tz->trip_hyst_attrs[indx].attr);\r\n}\r\nreturn 0;\r\n}\r\nstatic void remove_trip_attrs(struct thermal_zone_device *tz)\r\n{\r\nint indx;\r\nfor (indx = 0; indx < tz->trips; indx++) {\r\ndevice_remove_file(&tz->device,\r\n&tz->trip_type_attrs[indx].attr);\r\ndevice_remove_file(&tz->device,\r\n&tz->trip_temp_attrs[indx].attr);\r\nif (tz->ops->get_trip_hyst)\r\ndevice_remove_file(&tz->device,\r\n&tz->trip_hyst_attrs[indx].attr);\r\n}\r\nkfree(tz->trip_type_attrs);\r\nkfree(tz->trip_temp_attrs);\r\nkfree(tz->trip_hyst_attrs);\r\n}\r\nstruct thermal_zone_device *thermal_zone_device_register(const char *type,\r\nint trips, int mask, void *devdata,\r\nstruct thermal_zone_device_ops *ops,\r\nconst struct thermal_zone_params *tzp,\r\nint passive_delay, int polling_delay)\r\n{\r\nstruct thermal_zone_device *tz;\r\nenum thermal_trip_type trip_type;\r\nint result;\r\nint count;\r\nint passive = 0;\r\nif (type && strlen(type) >= THERMAL_NAME_LENGTH)\r\nreturn ERR_PTR(-EINVAL);\r\nif (trips > THERMAL_MAX_TRIPS || trips < 0 || mask >> trips)\r\nreturn ERR_PTR(-EINVAL);\r\nif (!ops)\r\nreturn ERR_PTR(-EINVAL);\r\nif (trips > 0 && (!ops->get_trip_type || !ops->get_trip_temp))\r\nreturn ERR_PTR(-EINVAL);\r\ntz = kzalloc(sizeof(struct thermal_zone_device), GFP_KERNEL);\r\nif (!tz)\r\nreturn ERR_PTR(-ENOMEM);\r\nINIT_LIST_HEAD(&tz->thermal_instances);\r\nidr_init(&tz->idr);\r\nmutex_init(&tz->lock);\r\nresult = get_idr(&thermal_tz_idr, &thermal_idr_lock, &tz->id);\r\nif (result) {\r\nkfree(tz);\r\nreturn ERR_PTR(result);\r\n}\r\nstrlcpy(tz->type, type ? : "", sizeof(tz->type));\r\ntz->ops = ops;\r\ntz->tzp = tzp;\r\ntz->device.class = &thermal_class;\r\ntz->devdata = devdata;\r\ntz->trips = trips;\r\ntz->passive_delay = passive_delay;\r\ntz->polling_delay = polling_delay;\r\ndev_set_name(&tz->device, "thermal_zone%d", tz->id);\r\nresult = device_register(&tz->device);\r\nif (result) {\r\nrelease_idr(&thermal_tz_idr, &thermal_idr_lock, tz->id);\r\nkfree(tz);\r\nreturn ERR_PTR(result);\r\n}\r\nif (type) {\r\nresult = device_create_file(&tz->device, &dev_attr_type);\r\nif (result)\r\ngoto unregister;\r\n}\r\nresult = device_create_file(&tz->device, &dev_attr_temp);\r\nif (result)\r\ngoto unregister;\r\nif (ops->get_mode) {\r\nresult = device_create_file(&tz->device, &dev_attr_mode);\r\nif (result)\r\ngoto unregister;\r\n}\r\nresult = create_trip_attrs(tz, mask);\r\nif (result)\r\ngoto unregister;\r\nfor (count = 0; count < trips; count++) {\r\ntz->ops->get_trip_type(tz, count, &trip_type);\r\nif (trip_type == THERMAL_TRIP_PASSIVE)\r\npassive = 1;\r\n}\r\nif (!passive) {\r\nresult = device_create_file(&tz->device, &dev_attr_passive);\r\nif (result)\r\ngoto unregister;\r\n}\r\n#ifdef CONFIG_THERMAL_EMULATION\r\nresult = device_create_file(&tz->device, &dev_attr_emul_temp);\r\nif (result)\r\ngoto unregister;\r\n#endif\r\nresult = device_create_file(&tz->device, &dev_attr_policy);\r\nif (result)\r\ngoto unregister;\r\nmutex_lock(&thermal_governor_lock);\r\nif (tz->tzp)\r\ntz->governor = __find_governor(tz->tzp->governor_name);\r\nelse\r\ntz->governor = def_governor;\r\nmutex_unlock(&thermal_governor_lock);\r\nif (!tz->tzp || !tz->tzp->no_hwmon) {\r\nresult = thermal_add_hwmon_sysfs(tz);\r\nif (result)\r\ngoto unregister;\r\n}\r\nmutex_lock(&thermal_list_lock);\r\nlist_add_tail(&tz->node, &thermal_tz_list);\r\nmutex_unlock(&thermal_list_lock);\r\nbind_tz(tz);\r\nINIT_DELAYED_WORK(&(tz->poll_queue), thermal_zone_device_check);\r\nif (!tz->ops->get_temp)\r\nthermal_zone_device_set_polling(tz, 0);\r\nthermal_zone_device_update(tz);\r\nreturn tz;\r\nunregister:\r\nrelease_idr(&thermal_tz_idr, &thermal_idr_lock, tz->id);\r\ndevice_unregister(&tz->device);\r\nreturn ERR_PTR(result);\r\n}\r\nvoid thermal_zone_device_unregister(struct thermal_zone_device *tz)\r\n{\r\nint i;\r\nconst struct thermal_zone_params *tzp;\r\nstruct thermal_cooling_device *cdev;\r\nstruct thermal_zone_device *pos = NULL;\r\nif (!tz)\r\nreturn;\r\ntzp = tz->tzp;\r\nmutex_lock(&thermal_list_lock);\r\nlist_for_each_entry(pos, &thermal_tz_list, node)\r\nif (pos == tz)\r\nbreak;\r\nif (pos != tz) {\r\nmutex_unlock(&thermal_list_lock);\r\nreturn;\r\n}\r\nlist_del(&tz->node);\r\nlist_for_each_entry(cdev, &thermal_cdev_list, node) {\r\nif (tz->ops->unbind) {\r\ntz->ops->unbind(tz, cdev);\r\ncontinue;\r\n}\r\nif (!tzp || !tzp->tbp)\r\nbreak;\r\nfor (i = 0; i < tzp->num_tbps; i++) {\r\nif (tzp->tbp[i].cdev == cdev) {\r\n__unbind(tz, tzp->tbp[i].trip_mask, cdev);\r\ntzp->tbp[i].cdev = NULL;\r\n}\r\n}\r\n}\r\nmutex_unlock(&thermal_list_lock);\r\nthermal_zone_device_set_polling(tz, 0);\r\nif (tz->type[0])\r\ndevice_remove_file(&tz->device, &dev_attr_type);\r\ndevice_remove_file(&tz->device, &dev_attr_temp);\r\nif (tz->ops->get_mode)\r\ndevice_remove_file(&tz->device, &dev_attr_mode);\r\ndevice_remove_file(&tz->device, &dev_attr_policy);\r\nremove_trip_attrs(tz);\r\ntz->governor = NULL;\r\nthermal_remove_hwmon_sysfs(tz);\r\nrelease_idr(&thermal_tz_idr, &thermal_idr_lock, tz->id);\r\nidr_destroy(&tz->idr);\r\nmutex_destroy(&tz->lock);\r\ndevice_unregister(&tz->device);\r\nreturn;\r\n}\r\nstruct thermal_zone_device *thermal_zone_get_zone_by_name(const char *name)\r\n{\r\nstruct thermal_zone_device *pos = NULL, *ref = ERR_PTR(-EINVAL);\r\nunsigned int found = 0;\r\nif (!name)\r\ngoto exit;\r\nmutex_lock(&thermal_list_lock);\r\nlist_for_each_entry(pos, &thermal_tz_list, node)\r\nif (!strncasecmp(name, pos->type, THERMAL_NAME_LENGTH)) {\r\nfound++;\r\nref = pos;\r\n}\r\nmutex_unlock(&thermal_list_lock);\r\nif (found == 0)\r\nref = ERR_PTR(-ENODEV);\r\nelse if (found > 1)\r\nref = ERR_PTR(-EEXIST);\r\nexit:\r\nreturn ref;\r\n}\r\nint thermal_generate_netlink_event(struct thermal_zone_device *tz,\r\nenum events event)\r\n{\r\nstruct sk_buff *skb;\r\nstruct nlattr *attr;\r\nstruct thermal_genl_event *thermal_event;\r\nvoid *msg_header;\r\nint size;\r\nint result;\r\nstatic unsigned int thermal_event_seqnum;\r\nif (!tz)\r\nreturn -EINVAL;\r\nsize = nla_total_size(sizeof(struct thermal_genl_event)) +\r\nnla_total_size(0);\r\nskb = genlmsg_new(size, GFP_ATOMIC);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nmsg_header = genlmsg_put(skb, 0, thermal_event_seqnum++,\r\n&thermal_event_genl_family, 0,\r\nTHERMAL_GENL_CMD_EVENT);\r\nif (!msg_header) {\r\nnlmsg_free(skb);\r\nreturn -ENOMEM;\r\n}\r\nattr = nla_reserve(skb, THERMAL_GENL_ATTR_EVENT,\r\nsizeof(struct thermal_genl_event));\r\nif (!attr) {\r\nnlmsg_free(skb);\r\nreturn -EINVAL;\r\n}\r\nthermal_event = nla_data(attr);\r\nif (!thermal_event) {\r\nnlmsg_free(skb);\r\nreturn -EINVAL;\r\n}\r\nmemset(thermal_event, 0, sizeof(struct thermal_genl_event));\r\nthermal_event->orig = tz->id;\r\nthermal_event->event = event;\r\ngenlmsg_end(skb, msg_header);\r\nresult = genlmsg_multicast(&thermal_event_genl_family, skb, 0,\r\n0, GFP_ATOMIC);\r\nif (result)\r\ndev_err(&tz->device, "Failed to send netlink event:%d", result);\r\nreturn result;\r\n}\r\nstatic int genetlink_init(void)\r\n{\r\nreturn genl_register_family(&thermal_event_genl_family);\r\n}\r\nstatic void genetlink_exit(void)\r\n{\r\ngenl_unregister_family(&thermal_event_genl_family);\r\n}\r\nstatic inline int genetlink_init(void) { return 0; }\r\nstatic inline void genetlink_exit(void) {}\r\nstatic int __init thermal_register_governors(void)\r\n{\r\nint result;\r\nresult = thermal_gov_step_wise_register();\r\nif (result)\r\nreturn result;\r\nresult = thermal_gov_fair_share_register();\r\nif (result)\r\nreturn result;\r\nresult = thermal_gov_bang_bang_register();\r\nif (result)\r\nreturn result;\r\nreturn thermal_gov_user_space_register();\r\n}\r\nstatic void thermal_unregister_governors(void)\r\n{\r\nthermal_gov_step_wise_unregister();\r\nthermal_gov_fair_share_unregister();\r\nthermal_gov_bang_bang_unregister();\r\nthermal_gov_user_space_unregister();\r\n}\r\nstatic int __init thermal_init(void)\r\n{\r\nint result;\r\nresult = thermal_register_governors();\r\nif (result)\r\ngoto error;\r\nresult = class_register(&thermal_class);\r\nif (result)\r\ngoto unregister_governors;\r\nresult = genetlink_init();\r\nif (result)\r\ngoto unregister_class;\r\nresult = of_parse_thermal_zones();\r\nif (result)\r\ngoto exit_netlink;\r\nreturn 0;\r\nexit_netlink:\r\ngenetlink_exit();\r\nunregister_class:\r\nclass_unregister(&thermal_class);\r\nunregister_governors:\r\nthermal_unregister_governors();\r\nerror:\r\nidr_destroy(&thermal_tz_idr);\r\nidr_destroy(&thermal_cdev_idr);\r\nmutex_destroy(&thermal_idr_lock);\r\nmutex_destroy(&thermal_list_lock);\r\nmutex_destroy(&thermal_governor_lock);\r\nreturn result;\r\n}\r\nstatic void __exit thermal_exit(void)\r\n{\r\nof_thermal_destroy_zones();\r\ngenetlink_exit();\r\nclass_unregister(&thermal_class);\r\nthermal_unregister_governors();\r\nidr_destroy(&thermal_tz_idr);\r\nidr_destroy(&thermal_cdev_idr);\r\nmutex_destroy(&thermal_idr_lock);\r\nmutex_destroy(&thermal_list_lock);\r\nmutex_destroy(&thermal_governor_lock);\r\n}
