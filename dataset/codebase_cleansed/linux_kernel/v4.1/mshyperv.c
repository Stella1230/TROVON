void hyperv_vector_handler(struct pt_regs *regs)\r\n{\r\nstruct pt_regs *old_regs = set_irq_regs(regs);\r\nirq_enter();\r\nexit_idle();\r\ninc_irq_stat(irq_hv_callback_count);\r\nif (vmbus_handler)\r\nvmbus_handler();\r\nirq_exit();\r\nset_irq_regs(old_regs);\r\n}\r\nvoid hv_setup_vmbus_irq(void (*handler)(void))\r\n{\r\nvmbus_handler = handler;\r\nif (!test_bit(HYPERVISOR_CALLBACK_VECTOR, used_vectors))\r\nalloc_intr_gate(HYPERVISOR_CALLBACK_VECTOR,\r\nhyperv_callback_vector);\r\n}\r\nvoid hv_remove_vmbus_irq(void)\r\n{\r\nvmbus_handler = NULL;\r\n}\r\nstatic uint32_t __init ms_hyperv_platform(void)\r\n{\r\nu32 eax;\r\nu32 hyp_signature[3];\r\nif (!boot_cpu_has(X86_FEATURE_HYPERVISOR))\r\nreturn 0;\r\ncpuid(HYPERV_CPUID_VENDOR_AND_MAX_FUNCTIONS,\r\n&eax, &hyp_signature[0], &hyp_signature[1], &hyp_signature[2]);\r\nif (eax >= HYPERV_CPUID_MIN &&\r\neax <= HYPERV_CPUID_MAX &&\r\n!memcmp("Microsoft Hv", hyp_signature, 12))\r\nreturn HYPERV_CPUID_VENDOR_AND_MAX_FUNCTIONS;\r\nreturn 0;\r\n}\r\nstatic cycle_t read_hv_clock(struct clocksource *arg)\r\n{\r\ncycle_t current_tick;\r\nrdmsrl(HV_X64_MSR_TIME_REF_COUNT, current_tick);\r\nreturn current_tick;\r\n}\r\nstatic void __init ms_hyperv_init_platform(void)\r\n{\r\nms_hyperv.features = cpuid_eax(HYPERV_CPUID_FEATURES);\r\nms_hyperv.hints = cpuid_eax(HYPERV_CPUID_ENLIGHTMENT_INFO);\r\nprintk(KERN_INFO "HyperV: features 0x%x, hints 0x%x\n",\r\nms_hyperv.features, ms_hyperv.hints);\r\n#ifdef CONFIG_X86_LOCAL_APIC\r\nif (ms_hyperv.features & HV_X64_MSR_APIC_FREQUENCY_AVAILABLE) {\r\nu64 hv_lapic_frequency;\r\nrdmsrl(HV_X64_MSR_APIC_FREQUENCY, hv_lapic_frequency);\r\nhv_lapic_frequency = div_u64(hv_lapic_frequency, HZ);\r\nlapic_timer_frequency = hv_lapic_frequency;\r\nprintk(KERN_INFO "HyperV: LAPIC Timer Frequency: %#x\n",\r\nlapic_timer_frequency);\r\n}\r\n#endif\r\nif (ms_hyperv.features & HV_X64_MSR_TIME_REF_COUNT_AVAILABLE)\r\nclocksource_register_hz(&hyperv_cs, NSEC_PER_SEC/100);\r\n#ifdef CONFIG_X86_IO_APIC\r\nno_timer_check = 1;\r\n#endif\r\n}
