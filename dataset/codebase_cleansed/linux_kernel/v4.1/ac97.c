static void s3c_ac97_activate(struct snd_ac97 *ac97)\r\n{\r\nu32 ac_glbctrl, stat;\r\nstat = readl(s3c_ac97.regs + S3C_AC97_GLBSTAT) & 0x7;\r\nif (stat == S3C_AC97_GLBSTAT_MAINSTATE_ACTIVE)\r\nreturn;\r\nreinit_completion(&s3c_ac97.done);\r\nac_glbctrl = readl(s3c_ac97.regs + S3C_AC97_GLBCTRL);\r\nac_glbctrl = S3C_AC97_GLBCTRL_ACLINKON;\r\nwritel(ac_glbctrl, s3c_ac97.regs + S3C_AC97_GLBCTRL);\r\nmsleep(1);\r\nac_glbctrl |= S3C_AC97_GLBCTRL_TRANSFERDATAENABLE;\r\nwritel(ac_glbctrl, s3c_ac97.regs + S3C_AC97_GLBCTRL);\r\nmsleep(1);\r\nac_glbctrl = readl(s3c_ac97.regs + S3C_AC97_GLBCTRL);\r\nac_glbctrl |= S3C_AC97_GLBCTRL_CODECREADYIE;\r\nwritel(ac_glbctrl, s3c_ac97.regs + S3C_AC97_GLBCTRL);\r\nif (!wait_for_completion_timeout(&s3c_ac97.done, HZ))\r\npr_err("AC97: Unable to activate!");\r\n}\r\nstatic unsigned short s3c_ac97_read(struct snd_ac97 *ac97,\r\nunsigned short reg)\r\n{\r\nu32 ac_glbctrl, ac_codec_cmd;\r\nu32 stat, addr, data;\r\nmutex_lock(&s3c_ac97.lock);\r\ns3c_ac97_activate(ac97);\r\nreinit_completion(&s3c_ac97.done);\r\nac_codec_cmd = readl(s3c_ac97.regs + S3C_AC97_CODEC_CMD);\r\nac_codec_cmd = S3C_AC97_CODEC_CMD_READ | AC_CMD_ADDR(reg);\r\nwritel(ac_codec_cmd, s3c_ac97.regs + S3C_AC97_CODEC_CMD);\r\nudelay(50);\r\nac_glbctrl = readl(s3c_ac97.regs + S3C_AC97_GLBCTRL);\r\nac_glbctrl |= S3C_AC97_GLBCTRL_CODECREADYIE;\r\nwritel(ac_glbctrl, s3c_ac97.regs + S3C_AC97_GLBCTRL);\r\nif (!wait_for_completion_timeout(&s3c_ac97.done, HZ))\r\npr_err("AC97: Unable to read!");\r\nstat = readl(s3c_ac97.regs + S3C_AC97_STAT);\r\naddr = (stat >> 16) & 0x7f;\r\ndata = (stat & 0xffff);\r\nif (addr != reg)\r\npr_err("ac97: req addr = %02x, rep addr = %02x\n",\r\nreg, addr);\r\nmutex_unlock(&s3c_ac97.lock);\r\nreturn (unsigned short)data;\r\n}\r\nstatic void s3c_ac97_write(struct snd_ac97 *ac97, unsigned short reg,\r\nunsigned short val)\r\n{\r\nu32 ac_glbctrl, ac_codec_cmd;\r\nmutex_lock(&s3c_ac97.lock);\r\ns3c_ac97_activate(ac97);\r\nreinit_completion(&s3c_ac97.done);\r\nac_codec_cmd = readl(s3c_ac97.regs + S3C_AC97_CODEC_CMD);\r\nac_codec_cmd = AC_CMD_ADDR(reg) | AC_CMD_DATA(val);\r\nwritel(ac_codec_cmd, s3c_ac97.regs + S3C_AC97_CODEC_CMD);\r\nudelay(50);\r\nac_glbctrl = readl(s3c_ac97.regs + S3C_AC97_GLBCTRL);\r\nac_glbctrl |= S3C_AC97_GLBCTRL_CODECREADYIE;\r\nwritel(ac_glbctrl, s3c_ac97.regs + S3C_AC97_GLBCTRL);\r\nif (!wait_for_completion_timeout(&s3c_ac97.done, HZ))\r\npr_err("AC97: Unable to write!");\r\nac_codec_cmd = readl(s3c_ac97.regs + S3C_AC97_CODEC_CMD);\r\nac_codec_cmd |= S3C_AC97_CODEC_CMD_READ;\r\nwritel(ac_codec_cmd, s3c_ac97.regs + S3C_AC97_CODEC_CMD);\r\nmutex_unlock(&s3c_ac97.lock);\r\n}\r\nstatic void s3c_ac97_cold_reset(struct snd_ac97 *ac97)\r\n{\r\npr_debug("AC97: Cold reset\n");\r\nwritel(S3C_AC97_GLBCTRL_COLDRESET,\r\ns3c_ac97.regs + S3C_AC97_GLBCTRL);\r\nmsleep(1);\r\nwritel(0, s3c_ac97.regs + S3C_AC97_GLBCTRL);\r\nmsleep(1);\r\n}\r\nstatic void s3c_ac97_warm_reset(struct snd_ac97 *ac97)\r\n{\r\nu32 stat;\r\nstat = readl(s3c_ac97.regs + S3C_AC97_GLBSTAT) & 0x7;\r\nif (stat == S3C_AC97_GLBSTAT_MAINSTATE_ACTIVE)\r\nreturn;\r\npr_debug("AC97: Warm reset\n");\r\nwritel(S3C_AC97_GLBCTRL_WARMRESET, s3c_ac97.regs + S3C_AC97_GLBCTRL);\r\nmsleep(1);\r\nwritel(0, s3c_ac97.regs + S3C_AC97_GLBCTRL);\r\nmsleep(1);\r\ns3c_ac97_activate(ac97);\r\n}\r\nstatic irqreturn_t s3c_ac97_irq(int irq, void *dev_id)\r\n{\r\nu32 ac_glbctrl, ac_glbstat;\r\nac_glbstat = readl(s3c_ac97.regs + S3C_AC97_GLBSTAT);\r\nif (ac_glbstat & S3C_AC97_GLBSTAT_CODECREADY) {\r\nac_glbctrl = readl(s3c_ac97.regs + S3C_AC97_GLBCTRL);\r\nac_glbctrl &= ~S3C_AC97_GLBCTRL_CODECREADYIE;\r\nwritel(ac_glbctrl, s3c_ac97.regs + S3C_AC97_GLBCTRL);\r\ncomplete(&s3c_ac97.done);\r\n}\r\nac_glbctrl = readl(s3c_ac97.regs + S3C_AC97_GLBCTRL);\r\nac_glbctrl |= (1<<30);\r\nwritel(ac_glbctrl, s3c_ac97.regs + S3C_AC97_GLBCTRL);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int s3c_ac97_trigger(struct snd_pcm_substream *substream, int cmd,\r\nstruct snd_soc_dai *dai)\r\n{\r\nu32 ac_glbctrl;\r\nac_glbctrl = readl(s3c_ac97.regs + S3C_AC97_GLBCTRL);\r\nif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\r\nac_glbctrl &= ~S3C_AC97_GLBCTRL_PCMINTM_MASK;\r\nelse\r\nac_glbctrl &= ~S3C_AC97_GLBCTRL_PCMOUTTM_MASK;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\r\nac_glbctrl |= S3C_AC97_GLBCTRL_PCMINTM_DMA;\r\nelse\r\nac_glbctrl |= S3C_AC97_GLBCTRL_PCMOUTTM_DMA;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nbreak;\r\n}\r\nwritel(ac_glbctrl, s3c_ac97.regs + S3C_AC97_GLBCTRL);\r\nreturn 0;\r\n}\r\nstatic int s3c_ac97_mic_trigger(struct snd_pcm_substream *substream,\r\nint cmd, struct snd_soc_dai *dai)\r\n{\r\nu32 ac_glbctrl;\r\nac_glbctrl = readl(s3c_ac97.regs + S3C_AC97_GLBCTRL);\r\nac_glbctrl &= ~S3C_AC97_GLBCTRL_MICINTM_MASK;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nac_glbctrl |= S3C_AC97_GLBCTRL_MICINTM_DMA;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nbreak;\r\n}\r\nwritel(ac_glbctrl, s3c_ac97.regs + S3C_AC97_GLBCTRL);\r\nreturn 0;\r\n}\r\nstatic int s3c_ac97_dai_probe(struct snd_soc_dai *dai)\r\n{\r\nsamsung_asoc_init_dma_data(dai, &s3c_ac97_pcm_out, &s3c_ac97_pcm_in);\r\nreturn 0;\r\n}\r\nstatic int s3c_ac97_mic_dai_probe(struct snd_soc_dai *dai)\r\n{\r\nsamsung_asoc_init_dma_data(dai, NULL, &s3c_ac97_mic_in);\r\nreturn 0;\r\n}\r\nstatic int s3c_ac97_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *mem_res, *dmatx_res, *dmarx_res, *dmamic_res, *irq_res;\r\nstruct s3c_audio_pdata *ac97_pdata;\r\nint ret;\r\nac97_pdata = pdev->dev.platform_data;\r\nif (!ac97_pdata || !ac97_pdata->cfg_gpio) {\r\ndev_err(&pdev->dev, "cfg_gpio callback not provided!\n");\r\nreturn -EINVAL;\r\n}\r\ndmatx_res = platform_get_resource(pdev, IORESOURCE_DMA, 0);\r\nif (!dmatx_res) {\r\ndev_err(&pdev->dev, "Unable to get AC97-TX dma resource\n");\r\nreturn -ENXIO;\r\n}\r\ndmarx_res = platform_get_resource(pdev, IORESOURCE_DMA, 1);\r\nif (!dmarx_res) {\r\ndev_err(&pdev->dev, "Unable to get AC97-RX dma resource\n");\r\nreturn -ENXIO;\r\n}\r\ndmamic_res = platform_get_resource(pdev, IORESOURCE_DMA, 2);\r\nif (!dmamic_res) {\r\ndev_err(&pdev->dev, "Unable to get AC97-MIC dma resource\n");\r\nreturn -ENXIO;\r\n}\r\nirq_res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!irq_res) {\r\ndev_err(&pdev->dev, "AC97 IRQ not provided!\n");\r\nreturn -ENXIO;\r\n}\r\nmem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ns3c_ac97.regs = devm_ioremap_resource(&pdev->dev, mem_res);\r\nif (IS_ERR(s3c_ac97.regs))\r\nreturn PTR_ERR(s3c_ac97.regs);\r\ns3c_ac97_pcm_out.channel = dmatx_res->start;\r\ns3c_ac97_pcm_out.dma_addr = mem_res->start + S3C_AC97_PCM_DATA;\r\ns3c_ac97_pcm_in.channel = dmarx_res->start;\r\ns3c_ac97_pcm_in.dma_addr = mem_res->start + S3C_AC97_PCM_DATA;\r\ns3c_ac97_mic_in.channel = dmamic_res->start;\r\ns3c_ac97_mic_in.dma_addr = mem_res->start + S3C_AC97_MIC_DATA;\r\ninit_completion(&s3c_ac97.done);\r\nmutex_init(&s3c_ac97.lock);\r\ns3c_ac97.ac97_clk = devm_clk_get(&pdev->dev, "ac97");\r\nif (IS_ERR(s3c_ac97.ac97_clk)) {\r\ndev_err(&pdev->dev, "ac97 failed to get ac97_clock\n");\r\nret = -ENODEV;\r\ngoto err2;\r\n}\r\nclk_prepare_enable(s3c_ac97.ac97_clk);\r\nif (ac97_pdata->cfg_gpio(pdev)) {\r\ndev_err(&pdev->dev, "Unable to configure gpio\n");\r\nret = -EINVAL;\r\ngoto err3;\r\n}\r\nret = request_irq(irq_res->start, s3c_ac97_irq,\r\n0, "AC97", NULL);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "ac97: interrupt request failed.\n");\r\ngoto err4;\r\n}\r\nret = snd_soc_set_ac97_ops(&s3c_ac97_ops);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev, "Failed to set AC'97 ops: %d\n", ret);\r\ngoto err4;\r\n}\r\nret = devm_snd_soc_register_component(&pdev->dev, &s3c_ac97_component,\r\ns3c_ac97_dai, ARRAY_SIZE(s3c_ac97_dai));\r\nif (ret)\r\ngoto err5;\r\nret = samsung_asoc_dma_platform_register(&pdev->dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to get register DMA: %d\n", ret);\r\ngoto err5;\r\n}\r\nreturn 0;\r\nerr5:\r\nfree_irq(irq_res->start, NULL);\r\nerr4:\r\nerr3:\r\nclk_disable_unprepare(s3c_ac97.ac97_clk);\r\nerr2:\r\nsnd_soc_set_ac97_ops(NULL);\r\nreturn ret;\r\n}\r\nstatic int s3c_ac97_remove(struct platform_device *pdev)\r\n{\r\nstruct resource *irq_res;\r\nirq_res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (irq_res)\r\nfree_irq(irq_res->start, NULL);\r\nclk_disable_unprepare(s3c_ac97.ac97_clk);\r\nsnd_soc_set_ac97_ops(NULL);\r\nreturn 0;\r\n}
