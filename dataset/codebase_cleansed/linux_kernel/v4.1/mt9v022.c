static const struct mt9v022_datafmt *mt9v022_find_datafmt(\r\nu32 code, const struct mt9v022_datafmt *fmt,\r\nint n)\r\n{\r\nint i;\r\nfor (i = 0; i < n; i++)\r\nif (fmt[i].code == code)\r\nreturn fmt + i;\r\nreturn NULL;\r\n}\r\nstatic struct mt9v022 *to_mt9v022(const struct i2c_client *client)\r\n{\r\nreturn container_of(i2c_get_clientdata(client), struct mt9v022, subdev);\r\n}\r\nstatic int reg_read(struct i2c_client *client, const u8 reg)\r\n{\r\nreturn i2c_smbus_read_word_swapped(client, reg);\r\n}\r\nstatic int reg_write(struct i2c_client *client, const u8 reg,\r\nconst u16 data)\r\n{\r\nreturn i2c_smbus_write_word_swapped(client, reg, data);\r\n}\r\nstatic int reg_set(struct i2c_client *client, const u8 reg,\r\nconst u16 data)\r\n{\r\nint ret;\r\nret = reg_read(client, reg);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn reg_write(client, reg, ret | data);\r\n}\r\nstatic int reg_clear(struct i2c_client *client, const u8 reg,\r\nconst u16 data)\r\n{\r\nint ret;\r\nret = reg_read(client, reg);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn reg_write(client, reg, ret & ~data);\r\n}\r\nstatic int mt9v022_init(struct i2c_client *client)\r\n{\r\nstruct mt9v022 *mt9v022 = to_mt9v022(client);\r\nint ret;\r\nmt9v022->chip_control |= 0x10;\r\nret = reg_write(client, MT9V022_CHIP_CONTROL, mt9v022->chip_control);\r\nif (!ret)\r\nret = reg_write(client, MT9V022_READ_MODE, 0x300);\r\nif (!ret)\r\nret = reg_set(client, MT9V022_AEC_AGC_ENABLE, 0x3);\r\nif (!ret)\r\nret = reg_write(client, MT9V022_ANALOG_GAIN, 16);\r\nif (!ret)\r\nret = reg_write(client, MT9V022_TOTAL_SHUTTER_WIDTH, 480);\r\nif (!ret)\r\nret = reg_write(client, mt9v022->reg->max_total_shutter_width, 480);\r\nif (!ret)\r\nret = reg_clear(client, MT9V022_BLACK_LEVEL_CALIB_CTRL, 1);\r\nif (!ret)\r\nret = reg_write(client, MT9V022_DIGITAL_TEST_PATTERN, 0);\r\nif (!ret)\r\nreturn v4l2_ctrl_handler_setup(&mt9v022->hdl);\r\nreturn ret;\r\n}\r\nstatic int mt9v022_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct mt9v022 *mt9v022 = to_mt9v022(client);\r\nif (enable) {\r\nmt9v022->chip_control &= ~0x10;\r\nif (is_mt9v022_rev3(mt9v022->chip_version) ||\r\nis_mt9v024(mt9v022->chip_version)) {\r\nif (reg_clear(client, MT9V022_REG32, 0x204))\r\nreturn -EIO;\r\n}\r\n} else {\r\nmt9v022->chip_control |= 0x10;\r\nif (is_mt9v022_rev3(mt9v022->chip_version) ||\r\nis_mt9v024(mt9v022->chip_version)) {\r\nif (reg_set(client, MT9V022_REG32, 0x204))\r\nreturn -EIO;\r\n}\r\n}\r\nif (reg_write(client, MT9V022_CHIP_CONTROL, mt9v022->chip_control) < 0)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int mt9v022_s_crop(struct v4l2_subdev *sd, const struct v4l2_crop *a)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct mt9v022 *mt9v022 = to_mt9v022(client);\r\nstruct v4l2_rect rect = a->c;\r\nint min_row, min_blank;\r\nint ret;\r\nif (mt9v022->fmts == mt9v022_colour_fmts) {\r\nrect.width = ALIGN(rect.width, 2);\r\nrect.height = ALIGN(rect.height, 2);\r\n}\r\nsoc_camera_limit_side(&rect.left, &rect.width,\r\nMT9V022_COLUMN_SKIP, MT9V022_MIN_WIDTH, MT9V022_MAX_WIDTH);\r\nsoc_camera_limit_side(&rect.top, &rect.height,\r\nMT9V022_ROW_SKIP, MT9V022_MIN_HEIGHT, MT9V022_MAX_HEIGHT);\r\nret = reg_read(client, MT9V022_AEC_AGC_ENABLE);\r\nif (ret >= 0) {\r\nif (ret & 1)\r\nret = reg_write(client, mt9v022->reg->max_total_shutter_width,\r\nrect.height + mt9v022->y_skip_top + 43);\r\n}\r\nif (!ret)\r\nret = reg_write(client, MT9V022_COLUMN_START, rect.left);\r\nif (!ret)\r\nret = reg_write(client, MT9V022_ROW_START, rect.top);\r\nif (is_mt9v024(mt9v022->chip_version)) {\r\nmin_row = 690;\r\nmin_blank = 61;\r\n} else {\r\nmin_row = 660;\r\nmin_blank = 43;\r\n}\r\nif (!ret)\r\nret = v4l2_ctrl_s_ctrl(mt9v022->hblank,\r\nrect.width > min_row - min_blank ?\r\nmin_blank : min_row - rect.width);\r\nif (!ret)\r\nret = v4l2_ctrl_s_ctrl(mt9v022->vblank, 45);\r\nif (!ret)\r\nret = reg_write(client, MT9V022_WINDOW_WIDTH, rect.width);\r\nif (!ret)\r\nret = reg_write(client, MT9V022_WINDOW_HEIGHT,\r\nrect.height + mt9v022->y_skip_top);\r\nif (ret < 0)\r\nreturn ret;\r\ndev_dbg(&client->dev, "Frame %dx%d pixel\n", rect.width, rect.height);\r\nmt9v022->rect = rect;\r\nreturn 0;\r\n}\r\nstatic int mt9v022_g_crop(struct v4l2_subdev *sd, struct v4l2_crop *a)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct mt9v022 *mt9v022 = to_mt9v022(client);\r\na->c = mt9v022->rect;\r\na->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nreturn 0;\r\n}\r\nstatic int mt9v022_cropcap(struct v4l2_subdev *sd, struct v4l2_cropcap *a)\r\n{\r\na->bounds.left = MT9V022_COLUMN_SKIP;\r\na->bounds.top = MT9V022_ROW_SKIP;\r\na->bounds.width = MT9V022_MAX_WIDTH;\r\na->bounds.height = MT9V022_MAX_HEIGHT;\r\na->defrect = a->bounds;\r\na->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\na->pixelaspect.numerator = 1;\r\na->pixelaspect.denominator = 1;\r\nreturn 0;\r\n}\r\nstatic int mt9v022_g_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct mt9v022 *mt9v022 = to_mt9v022(client);\r\nmf->width = mt9v022->rect.width;\r\nmf->height = mt9v022->rect.height;\r\nmf->code = mt9v022->fmt->code;\r\nmf->colorspace = mt9v022->fmt->colorspace;\r\nmf->field = V4L2_FIELD_NONE;\r\nreturn 0;\r\n}\r\nstatic int mt9v022_s_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct mt9v022 *mt9v022 = to_mt9v022(client);\r\nstruct v4l2_crop a = {\r\n.c = {\r\n.left = mt9v022->rect.left,\r\n.top = mt9v022->rect.top,\r\n.width = mf->width,\r\n.height = mf->height,\r\n},\r\n};\r\nint ret;\r\nswitch (mf->code) {\r\ncase MEDIA_BUS_FMT_Y8_1X8:\r\ncase MEDIA_BUS_FMT_Y10_1X10:\r\nif (mt9v022->model != MT9V022IX7ATM)\r\nreturn -EINVAL;\r\nbreak;\r\ncase MEDIA_BUS_FMT_SBGGR8_1X8:\r\ncase MEDIA_BUS_FMT_SBGGR10_1X10:\r\nif (mt9v022->model != MT9V022IX7ATC)\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = mt9v022_s_crop(sd, &a);\r\nif (!ret) {\r\nmf->width = mt9v022->rect.width;\r\nmf->height = mt9v022->rect.height;\r\nmt9v022->fmt = mt9v022_find_datafmt(mf->code,\r\nmt9v022->fmts, mt9v022->num_fmts);\r\nmf->colorspace = mt9v022->fmt->colorspace;\r\n}\r\nreturn ret;\r\n}\r\nstatic int mt9v022_try_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct mt9v022 *mt9v022 = to_mt9v022(client);\r\nconst struct mt9v022_datafmt *fmt;\r\nint align = mf->code == MEDIA_BUS_FMT_SBGGR8_1X8 ||\r\nmf->code == MEDIA_BUS_FMT_SBGGR10_1X10;\r\nv4l_bound_align_image(&mf->width, MT9V022_MIN_WIDTH,\r\nMT9V022_MAX_WIDTH, align,\r\n&mf->height, MT9V022_MIN_HEIGHT + mt9v022->y_skip_top,\r\nMT9V022_MAX_HEIGHT + mt9v022->y_skip_top, align, 0);\r\nfmt = mt9v022_find_datafmt(mf->code, mt9v022->fmts,\r\nmt9v022->num_fmts);\r\nif (!fmt) {\r\nfmt = mt9v022->fmt;\r\nmf->code = fmt->code;\r\n}\r\nmf->colorspace = fmt->colorspace;\r\nreturn 0;\r\n}\r\nstatic int mt9v022_g_register(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (reg->reg > 0xff)\r\nreturn -EINVAL;\r\nreg->size = 2;\r\nreg->val = reg_read(client, reg->reg);\r\nif (reg->val > 0xffff)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int mt9v022_s_register(struct v4l2_subdev *sd,\r\nconst struct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (reg->reg > 0xff)\r\nreturn -EINVAL;\r\nif (reg_write(client, reg->reg, reg->val) < 0)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int mt9v022_s_power(struct v4l2_subdev *sd, int on)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);\r\nstruct mt9v022 *mt9v022 = to_mt9v022(client);\r\nreturn soc_camera_set_power(&client->dev, ssdd, mt9v022->clk, on);\r\n}\r\nstatic int mt9v022_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct mt9v022 *mt9v022 = container_of(ctrl->handler,\r\nstruct mt9v022, hdl);\r\nstruct v4l2_subdev *sd = &mt9v022->subdev;\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct v4l2_ctrl *gain = mt9v022->gain;\r\nstruct v4l2_ctrl *exp = mt9v022->exposure;\r\nunsigned long range;\r\nint data;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUTOGAIN:\r\ndata = reg_read(client, MT9V022_ANALOG_GAIN);\r\nif (data < 0)\r\nreturn -EIO;\r\nrange = gain->maximum - gain->minimum;\r\ngain->val = ((data - 16) * range + 24) / 48 + gain->minimum;\r\nreturn 0;\r\ncase V4L2_CID_EXPOSURE_AUTO:\r\ndata = reg_read(client, MT9V022_TOTAL_SHUTTER_WIDTH);\r\nif (data < 0)\r\nreturn -EIO;\r\nrange = exp->maximum - exp->minimum;\r\nexp->val = ((data - 1) * range + 239) / 479 + exp->minimum;\r\nreturn 0;\r\ncase V4L2_CID_HBLANK:\r\ndata = reg_read(client, MT9V022_HORIZONTAL_BLANKING);\r\nif (data < 0)\r\nreturn -EIO;\r\nctrl->val = data;\r\nreturn 0;\r\ncase V4L2_CID_VBLANK:\r\ndata = reg_read(client, MT9V022_VERTICAL_BLANKING);\r\nif (data < 0)\r\nreturn -EIO;\r\nctrl->val = data;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int mt9v022_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct mt9v022 *mt9v022 = container_of(ctrl->handler,\r\nstruct mt9v022, hdl);\r\nstruct v4l2_subdev *sd = &mt9v022->subdev;\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint data;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_VFLIP:\r\nif (ctrl->val)\r\ndata = reg_set(client, MT9V022_READ_MODE, 0x10);\r\nelse\r\ndata = reg_clear(client, MT9V022_READ_MODE, 0x10);\r\nif (data < 0)\r\nreturn -EIO;\r\nreturn 0;\r\ncase V4L2_CID_HFLIP:\r\nif (ctrl->val)\r\ndata = reg_set(client, MT9V022_READ_MODE, 0x20);\r\nelse\r\ndata = reg_clear(client, MT9V022_READ_MODE, 0x20);\r\nif (data < 0)\r\nreturn -EIO;\r\nreturn 0;\r\ncase V4L2_CID_AUTOGAIN:\r\nif (ctrl->val) {\r\nif (reg_set(client, MT9V022_AEC_AGC_ENABLE, 0x2) < 0)\r\nreturn -EIO;\r\n} else {\r\nstruct v4l2_ctrl *gain = mt9v022->gain;\r\nunsigned long range = gain->maximum - gain->minimum;\r\nunsigned long gain_val = ((gain->val - (s32)gain->minimum) *\r\n48 + range / 2) / range + 16;\r\nif (gain_val >= 32)\r\ngain_val &= ~1;\r\nif (reg_clear(client, MT9V022_AEC_AGC_ENABLE, 0x2) < 0)\r\nreturn -EIO;\r\ndev_dbg(&client->dev, "Setting gain from %d to %lu\n",\r\nreg_read(client, MT9V022_ANALOG_GAIN), gain_val);\r\nif (reg_write(client, MT9V022_ANALOG_GAIN, gain_val) < 0)\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\ncase V4L2_CID_EXPOSURE_AUTO:\r\nif (ctrl->val == V4L2_EXPOSURE_AUTO) {\r\ndata = reg_set(client, MT9V022_AEC_AGC_ENABLE, 0x1);\r\n} else {\r\nstruct v4l2_ctrl *exp = mt9v022->exposure;\r\nunsigned long range = exp->maximum - exp->minimum;\r\nunsigned long shutter = ((exp->val - (s32)exp->minimum) *\r\n479 + range / 2) / range + 1;\r\ndata = reg_clear(client, MT9V022_AEC_AGC_ENABLE, 0x1);\r\nif (data < 0)\r\nreturn -EIO;\r\ndev_dbg(&client->dev, "Shutter width from %d to %lu\n",\r\nreg_read(client, MT9V022_TOTAL_SHUTTER_WIDTH),\r\nshutter);\r\nif (reg_write(client, MT9V022_TOTAL_SHUTTER_WIDTH,\r\nshutter) < 0)\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\ncase V4L2_CID_HBLANK:\r\nif (reg_write(client, MT9V022_HORIZONTAL_BLANKING,\r\nctrl->val) < 0)\r\nreturn -EIO;\r\nreturn 0;\r\ncase V4L2_CID_VBLANK:\r\nif (reg_write(client, MT9V022_VERTICAL_BLANKING,\r\nctrl->val) < 0)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int mt9v022_video_probe(struct i2c_client *client)\r\n{\r\nstruct mt9v022 *mt9v022 = to_mt9v022(client);\r\nstruct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);\r\ns32 data;\r\nint ret;\r\nunsigned long flags;\r\nret = mt9v022_s_power(&mt9v022->subdev, 1);\r\nif (ret < 0)\r\nreturn ret;\r\ndata = reg_read(client, MT9V022_CHIP_VERSION);\r\nif (data != 0x1311 && data != 0x1313 && data != 0x1324) {\r\nret = -ENODEV;\r\ndev_info(&client->dev, "No MT9V022 found, ID register 0x%x\n",\r\ndata);\r\ngoto ei2c;\r\n}\r\nmt9v022->chip_version = data;\r\nmt9v022->reg = is_mt9v024(data) ? &mt9v024_register :\r\n&mt9v022_register;\r\nret = reg_write(client, MT9V022_RESET, 1);\r\nif (ret < 0)\r\ngoto ei2c;\r\nudelay(200);\r\nif (reg_read(client, MT9V022_RESET)) {\r\ndev_err(&client->dev, "Resetting MT9V022 failed!\n");\r\nif (ret > 0)\r\nret = -EIO;\r\ngoto ei2c;\r\n}\r\nif (sensor_type && (!strcmp("colour", sensor_type) ||\r\n!strcmp("color", sensor_type))) {\r\nret = reg_write(client, MT9V022_PIXEL_OPERATION_MODE, 4 | 0x11);\r\nmt9v022->model = MT9V022IX7ATC;\r\nmt9v022->fmts = mt9v022_colour_fmts;\r\n} else {\r\nret = reg_write(client, MT9V022_PIXEL_OPERATION_MODE, 0x11);\r\nmt9v022->model = MT9V022IX7ATM;\r\nmt9v022->fmts = mt9v022_monochrome_fmts;\r\n}\r\nif (ret < 0)\r\ngoto ei2c;\r\nmt9v022->num_fmts = 0;\r\nif (ssdd->query_bus_param)\r\nflags = ssdd->query_bus_param(ssdd);\r\nelse\r\nflags = SOCAM_DATAWIDTH_10;\r\nif (flags & SOCAM_DATAWIDTH_10)\r\nmt9v022->num_fmts++;\r\nelse\r\nmt9v022->fmts++;\r\nif (flags & SOCAM_DATAWIDTH_8)\r\nmt9v022->num_fmts++;\r\nmt9v022->fmt = &mt9v022->fmts[0];\r\ndev_info(&client->dev, "Detected a MT9V022 chip ID %x, %s sensor\n",\r\ndata, mt9v022->model == MT9V022IX7ATM ?\r\n"monochrome" : "colour");\r\nret = mt9v022_init(client);\r\nif (ret < 0)\r\ndev_err(&client->dev, "Failed to initialise the camera\n");\r\nei2c:\r\nmt9v022_s_power(&mt9v022->subdev, 0);\r\nreturn ret;\r\n}\r\nstatic int mt9v022_g_skip_top_lines(struct v4l2_subdev *sd, u32 *lines)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct mt9v022 *mt9v022 = to_mt9v022(client);\r\n*lines = mt9v022->y_skip_top;\r\nreturn 0;\r\n}\r\nstatic int mt9v022_enum_fmt(struct v4l2_subdev *sd, unsigned int index,\r\nu32 *code)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct mt9v022 *mt9v022 = to_mt9v022(client);\r\nif (index >= mt9v022->num_fmts)\r\nreturn -EINVAL;\r\n*code = mt9v022->fmts[index].code;\r\nreturn 0;\r\n}\r\nstatic int mt9v022_g_mbus_config(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_config *cfg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);\r\ncfg->flags = V4L2_MBUS_MASTER | V4L2_MBUS_SLAVE |\r\nV4L2_MBUS_PCLK_SAMPLE_RISING | V4L2_MBUS_PCLK_SAMPLE_FALLING |\r\nV4L2_MBUS_HSYNC_ACTIVE_HIGH | V4L2_MBUS_HSYNC_ACTIVE_LOW |\r\nV4L2_MBUS_VSYNC_ACTIVE_HIGH | V4L2_MBUS_VSYNC_ACTIVE_LOW |\r\nV4L2_MBUS_DATA_ACTIVE_HIGH;\r\ncfg->type = V4L2_MBUS_PARALLEL;\r\ncfg->flags = soc_camera_apply_board_flags(ssdd, cfg);\r\nreturn 0;\r\n}\r\nstatic int mt9v022_s_mbus_config(struct v4l2_subdev *sd,\r\nconst struct v4l2_mbus_config *cfg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);\r\nstruct mt9v022 *mt9v022 = to_mt9v022(client);\r\nunsigned long flags = soc_camera_apply_board_flags(ssdd, cfg);\r\nunsigned int bps = soc_mbus_get_fmtdesc(mt9v022->fmt->code)->bits_per_sample;\r\nint ret;\r\nu16 pixclk = 0;\r\nif (ssdd->set_bus_param) {\r\nret = ssdd->set_bus_param(ssdd, 1 << (bps - 1));\r\nif (ret)\r\nreturn ret;\r\n} else if (bps != 10) {\r\nreturn -EINVAL;\r\n}\r\nif (flags & V4L2_MBUS_PCLK_SAMPLE_FALLING)\r\npixclk |= 0x10;\r\nif (!(flags & V4L2_MBUS_HSYNC_ACTIVE_HIGH))\r\npixclk |= 0x1;\r\nif (!(flags & V4L2_MBUS_VSYNC_ACTIVE_HIGH))\r\npixclk |= 0x2;\r\nret = reg_write(client, mt9v022->reg->pixclk_fv_lv, pixclk);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!(flags & V4L2_MBUS_MASTER))\r\nmt9v022->chip_control &= ~0x8;\r\nret = reg_write(client, MT9V022_CHIP_CONTROL, mt9v022->chip_control);\r\nif (ret < 0)\r\nreturn ret;\r\ndev_dbg(&client->dev, "Calculated pixclk 0x%x, chip control 0x%x\n",\r\npixclk, mt9v022->chip_control);\r\nreturn 0;\r\n}\r\nstatic int mt9v022_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *did)\r\n{\r\nstruct mt9v022 *mt9v022;\r\nstruct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);\r\nstruct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);\r\nstruct mt9v022_platform_data *pdata;\r\nint ret;\r\nif (!ssdd) {\r\ndev_err(&client->dev, "MT9V022 driver needs platform data\n");\r\nreturn -EINVAL;\r\n}\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_WORD_DATA)) {\r\ndev_warn(&adapter->dev,\r\n"I2C-Adapter doesn't support I2C_FUNC_SMBUS_WORD\n");\r\nreturn -EIO;\r\n}\r\nmt9v022 = devm_kzalloc(&client->dev, sizeof(struct mt9v022), GFP_KERNEL);\r\nif (!mt9v022)\r\nreturn -ENOMEM;\r\npdata = ssdd->drv_priv;\r\nv4l2_i2c_subdev_init(&mt9v022->subdev, client, &mt9v022_subdev_ops);\r\nv4l2_ctrl_handler_init(&mt9v022->hdl, 6);\r\nv4l2_ctrl_new_std(&mt9v022->hdl, &mt9v022_ctrl_ops,\r\nV4L2_CID_VFLIP, 0, 1, 1, 0);\r\nv4l2_ctrl_new_std(&mt9v022->hdl, &mt9v022_ctrl_ops,\r\nV4L2_CID_HFLIP, 0, 1, 1, 0);\r\nmt9v022->autogain = v4l2_ctrl_new_std(&mt9v022->hdl, &mt9v022_ctrl_ops,\r\nV4L2_CID_AUTOGAIN, 0, 1, 1, 1);\r\nmt9v022->gain = v4l2_ctrl_new_std(&mt9v022->hdl, &mt9v022_ctrl_ops,\r\nV4L2_CID_GAIN, 0, 127, 1, 64);\r\nmt9v022->autoexposure = v4l2_ctrl_new_std_menu(&mt9v022->hdl,\r\n&mt9v022_ctrl_ops, V4L2_CID_EXPOSURE_AUTO, 1, 0,\r\nV4L2_EXPOSURE_AUTO);\r\nmt9v022->exposure = v4l2_ctrl_new_std(&mt9v022->hdl, &mt9v022_ctrl_ops,\r\nV4L2_CID_EXPOSURE, 1, 255, 1, 255);\r\nmt9v022->hblank = v4l2_ctrl_new_std(&mt9v022->hdl, &mt9v022_ctrl_ops,\r\nV4L2_CID_HBLANK, MT9V022_HORIZONTAL_BLANKING_MIN,\r\nMT9V022_HORIZONTAL_BLANKING_MAX, 1,\r\nMT9V022_HORIZONTAL_BLANKING_DEF);\r\nmt9v022->vblank = v4l2_ctrl_new_std(&mt9v022->hdl, &mt9v022_ctrl_ops,\r\nV4L2_CID_VBLANK, MT9V022_VERTICAL_BLANKING_MIN,\r\nMT9V022_VERTICAL_BLANKING_MAX, 1,\r\nMT9V022_VERTICAL_BLANKING_DEF);\r\nmt9v022->subdev.ctrl_handler = &mt9v022->hdl;\r\nif (mt9v022->hdl.error) {\r\nint err = mt9v022->hdl.error;\r\ndev_err(&client->dev, "control initialisation err %d\n", err);\r\nreturn err;\r\n}\r\nv4l2_ctrl_auto_cluster(2, &mt9v022->autoexposure,\r\nV4L2_EXPOSURE_MANUAL, true);\r\nv4l2_ctrl_auto_cluster(2, &mt9v022->autogain, 0, true);\r\nmt9v022->chip_control = MT9V022_CHIP_CONTROL_DEFAULT;\r\nmt9v022->y_skip_top = pdata ? pdata->y_skip_top : 0;\r\nmt9v022->rect.left = MT9V022_COLUMN_SKIP;\r\nmt9v022->rect.top = MT9V022_ROW_SKIP;\r\nmt9v022->rect.width = MT9V022_MAX_WIDTH;\r\nmt9v022->rect.height = MT9V022_MAX_HEIGHT;\r\nmt9v022->clk = v4l2_clk_get(&client->dev, "mclk");\r\nif (IS_ERR(mt9v022->clk)) {\r\nret = PTR_ERR(mt9v022->clk);\r\ngoto eclkget;\r\n}\r\nret = mt9v022_video_probe(client);\r\nif (ret) {\r\nv4l2_clk_put(mt9v022->clk);\r\neclkget:\r\nv4l2_ctrl_handler_free(&mt9v022->hdl);\r\n}\r\nreturn ret;\r\n}\r\nstatic int mt9v022_remove(struct i2c_client *client)\r\n{\r\nstruct mt9v022 *mt9v022 = to_mt9v022(client);\r\nstruct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);\r\nv4l2_clk_put(mt9v022->clk);\r\nv4l2_device_unregister_subdev(&mt9v022->subdev);\r\nif (ssdd->free_bus)\r\nssdd->free_bus(ssdd);\r\nv4l2_ctrl_handler_free(&mt9v022->hdl);\r\nreturn 0;\r\n}
