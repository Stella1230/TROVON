static int soc_compr_open(struct snd_compr_stream *cstream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\r\nstruct snd_soc_platform *platform = rtd->platform;\r\nint ret = 0;\r\nmutex_lock_nested(&rtd->pcm_mutex, rtd->pcm_subclass);\r\nif (platform->driver->compr_ops && platform->driver->compr_ops->open) {\r\nret = platform->driver->compr_ops->open(cstream);\r\nif (ret < 0) {\r\npr_err("compress asoc: can't open platform %s\n",\r\nplatform->component.name);\r\ngoto out;\r\n}\r\n}\r\nif (rtd->dai_link->compr_ops && rtd->dai_link->compr_ops->startup) {\r\nret = rtd->dai_link->compr_ops->startup(cstream);\r\nif (ret < 0) {\r\npr_err("compress asoc: %s startup failed\n", rtd->dai_link->name);\r\ngoto machine_err;\r\n}\r\n}\r\nsnd_soc_runtime_activate(rtd, cstream->direction);\r\nmutex_unlock(&rtd->pcm_mutex);\r\nreturn 0;\r\nmachine_err:\r\nif (platform->driver->compr_ops && platform->driver->compr_ops->free)\r\nplatform->driver->compr_ops->free(cstream);\r\nout:\r\nmutex_unlock(&rtd->pcm_mutex);\r\nreturn ret;\r\n}\r\nstatic int soc_compr_open_fe(struct snd_compr_stream *cstream)\r\n{\r\nstruct snd_soc_pcm_runtime *fe = cstream->private_data;\r\nstruct snd_pcm_substream *fe_substream = fe->pcm->streams[0].substream;\r\nstruct snd_soc_platform *platform = fe->platform;\r\nstruct snd_soc_dpcm *dpcm;\r\nstruct snd_soc_dapm_widget_list *list;\r\nint stream;\r\nint ret = 0;\r\nif (cstream->direction == SND_COMPRESS_PLAYBACK)\r\nstream = SNDRV_PCM_STREAM_PLAYBACK;\r\nelse\r\nstream = SNDRV_PCM_STREAM_CAPTURE;\r\nmutex_lock_nested(&fe->card->mutex, SND_SOC_CARD_CLASS_RUNTIME);\r\nif (platform->driver->compr_ops && platform->driver->compr_ops->open) {\r\nret = platform->driver->compr_ops->open(cstream);\r\nif (ret < 0) {\r\npr_err("compress asoc: can't open platform %s\n",\r\nplatform->component.name);\r\ngoto out;\r\n}\r\n}\r\nif (fe->dai_link->compr_ops && fe->dai_link->compr_ops->startup) {\r\nret = fe->dai_link->compr_ops->startup(cstream);\r\nif (ret < 0) {\r\npr_err("compress asoc: %s startup failed\n", fe->dai_link->name);\r\ngoto machine_err;\r\n}\r\n}\r\nfe->dpcm[stream].runtime = fe_substream->runtime;\r\nret = dpcm_path_get(fe, stream, &list);\r\nif (ret < 0)\r\ngoto fe_err;\r\nelse if (ret == 0)\r\ndev_dbg(fe->dev, "ASoC: %s no valid %s route\n",\r\nfe->dai_link->name, stream ? "capture" : "playback");\r\ndpcm_process_paths(fe, stream, &list, 1);\r\nfe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_FE;\r\nret = dpcm_be_dai_startup(fe, stream);\r\nif (ret < 0) {\r\nlist_for_each_entry(dpcm, &fe->dpcm[stream].be_clients, list_be)\r\ndpcm->state = SND_SOC_DPCM_LINK_STATE_FREE;\r\ndpcm_be_disconnect(fe, stream);\r\nfe->dpcm[stream].runtime = NULL;\r\ngoto fe_err;\r\n}\r\ndpcm_clear_pending_state(fe, stream);\r\ndpcm_path_put(&list);\r\nfe->dpcm[stream].state = SND_SOC_DPCM_STATE_OPEN;\r\nfe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_NO;\r\nsnd_soc_runtime_activate(fe, stream);\r\nmutex_unlock(&fe->card->mutex);\r\nreturn 0;\r\nfe_err:\r\nif (fe->dai_link->compr_ops && fe->dai_link->compr_ops->shutdown)\r\nfe->dai_link->compr_ops->shutdown(cstream);\r\nmachine_err:\r\nif (platform->driver->compr_ops && platform->driver->compr_ops->free)\r\nplatform->driver->compr_ops->free(cstream);\r\nout:\r\nfe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_NO;\r\nmutex_unlock(&fe->card->mutex);\r\nreturn ret;\r\n}\r\nstatic void close_delayed_work(struct work_struct *work)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd =\r\ncontainer_of(work, struct snd_soc_pcm_runtime, delayed_work.work);\r\nstruct snd_soc_dai *codec_dai = rtd->codec_dai;\r\nmutex_lock_nested(&rtd->pcm_mutex, rtd->pcm_subclass);\r\ndev_dbg(rtd->dev, "ASoC: pop wq checking: %s status: %s waiting: %s\n",\r\ncodec_dai->driver->playback.stream_name,\r\ncodec_dai->playback_active ? "active" : "inactive",\r\nrtd->pop_wait ? "yes" : "no");\r\nif (rtd->pop_wait == 1) {\r\nrtd->pop_wait = 0;\r\nsnd_soc_dapm_stream_event(rtd, SNDRV_PCM_STREAM_PLAYBACK,\r\nSND_SOC_DAPM_STREAM_STOP);\r\n}\r\nmutex_unlock(&rtd->pcm_mutex);\r\n}\r\nstatic int soc_compr_free(struct snd_compr_stream *cstream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\r\nstruct snd_soc_platform *platform = rtd->platform;\r\nstruct snd_soc_dai *cpu_dai = rtd->cpu_dai;\r\nstruct snd_soc_dai *codec_dai = rtd->codec_dai;\r\nint stream;\r\nmutex_lock_nested(&rtd->pcm_mutex, rtd->pcm_subclass);\r\nif (cstream->direction == SND_COMPRESS_PLAYBACK)\r\nstream = SNDRV_PCM_STREAM_PLAYBACK;\r\nelse\r\nstream = SNDRV_PCM_STREAM_CAPTURE;\r\nsnd_soc_runtime_deactivate(rtd, stream);\r\nsnd_soc_dai_digital_mute(codec_dai, 1, cstream->direction);\r\nif (!cpu_dai->active)\r\ncpu_dai->rate = 0;\r\nif (!codec_dai->active)\r\ncodec_dai->rate = 0;\r\nif (rtd->dai_link->compr_ops && rtd->dai_link->compr_ops->shutdown)\r\nrtd->dai_link->compr_ops->shutdown(cstream);\r\nif (platform->driver->compr_ops && platform->driver->compr_ops->free)\r\nplatform->driver->compr_ops->free(cstream);\r\nif (cstream->direction == SND_COMPRESS_PLAYBACK) {\r\nif (snd_soc_runtime_ignore_pmdown_time(rtd)) {\r\nsnd_soc_dapm_stream_event(rtd,\r\nSNDRV_PCM_STREAM_PLAYBACK,\r\nSND_SOC_DAPM_STREAM_STOP);\r\n} else {\r\nrtd->pop_wait = 1;\r\nqueue_delayed_work(system_power_efficient_wq,\r\n&rtd->delayed_work,\r\nmsecs_to_jiffies(rtd->pmdown_time));\r\n}\r\n} else {\r\nsnd_soc_dapm_stream_event(rtd,\r\nSNDRV_PCM_STREAM_CAPTURE,\r\nSND_SOC_DAPM_STREAM_STOP);\r\n}\r\nmutex_unlock(&rtd->pcm_mutex);\r\nreturn 0;\r\n}\r\nstatic int soc_compr_free_fe(struct snd_compr_stream *cstream)\r\n{\r\nstruct snd_soc_pcm_runtime *fe = cstream->private_data;\r\nstruct snd_soc_platform *platform = fe->platform;\r\nstruct snd_soc_dpcm *dpcm;\r\nint stream, ret;\r\nmutex_lock_nested(&fe->card->mutex, SND_SOC_CARD_CLASS_RUNTIME);\r\nif (cstream->direction == SND_COMPRESS_PLAYBACK)\r\nstream = SNDRV_PCM_STREAM_PLAYBACK;\r\nelse\r\nstream = SNDRV_PCM_STREAM_CAPTURE;\r\nsnd_soc_runtime_deactivate(fe, stream);\r\nfe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_FE;\r\nret = dpcm_be_dai_hw_free(fe, stream);\r\nif (ret < 0)\r\ndev_err(fe->dev, "compressed hw_free failed %d\n", ret);\r\nret = dpcm_be_dai_shutdown(fe, stream);\r\nlist_for_each_entry(dpcm, &fe->dpcm[stream].be_clients, list_be)\r\ndpcm->state = SND_SOC_DPCM_LINK_STATE_FREE;\r\ndpcm_dapm_stream_event(fe, stream, SND_SOC_DAPM_STREAM_STOP);\r\nfe->dpcm[stream].state = SND_SOC_DPCM_STATE_CLOSE;\r\nfe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_NO;\r\ndpcm_be_disconnect(fe, stream);\r\nfe->dpcm[stream].runtime = NULL;\r\nif (fe->dai_link->compr_ops && fe->dai_link->compr_ops->shutdown)\r\nfe->dai_link->compr_ops->shutdown(cstream);\r\nif (platform->driver->compr_ops && platform->driver->compr_ops->free)\r\nplatform->driver->compr_ops->free(cstream);\r\nmutex_unlock(&fe->card->mutex);\r\nreturn 0;\r\n}\r\nstatic int soc_compr_trigger(struct snd_compr_stream *cstream, int cmd)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\r\nstruct snd_soc_platform *platform = rtd->platform;\r\nstruct snd_soc_dai *codec_dai = rtd->codec_dai;\r\nint ret = 0;\r\nmutex_lock_nested(&rtd->pcm_mutex, rtd->pcm_subclass);\r\nif (platform->driver->compr_ops && platform->driver->compr_ops->trigger) {\r\nret = platform->driver->compr_ops->trigger(cstream, cmd);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nsnd_soc_dai_digital_mute(codec_dai, 0, cstream->direction);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nsnd_soc_dai_digital_mute(codec_dai, 1, cstream->direction);\r\nbreak;\r\n}\r\nout:\r\nmutex_unlock(&rtd->pcm_mutex);\r\nreturn ret;\r\n}\r\nstatic int soc_compr_trigger_fe(struct snd_compr_stream *cstream, int cmd)\r\n{\r\nstruct snd_soc_pcm_runtime *fe = cstream->private_data;\r\nstruct snd_soc_platform *platform = fe->platform;\r\nint ret = 0, stream;\r\nif (cmd == SND_COMPR_TRIGGER_PARTIAL_DRAIN ||\r\ncmd == SND_COMPR_TRIGGER_DRAIN) {\r\nif (platform->driver->compr_ops &&\r\nplatform->driver->compr_ops->trigger)\r\nreturn platform->driver->compr_ops->trigger(cstream,\r\ncmd);\r\n}\r\nif (cstream->direction == SND_COMPRESS_PLAYBACK)\r\nstream = SNDRV_PCM_STREAM_PLAYBACK;\r\nelse\r\nstream = SNDRV_PCM_STREAM_CAPTURE;\r\nmutex_lock_nested(&fe->card->mutex, SND_SOC_CARD_CLASS_RUNTIME);\r\nif (platform->driver->compr_ops && platform->driver->compr_ops->trigger) {\r\nret = platform->driver->compr_ops->trigger(cstream, cmd);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\nfe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_FE;\r\nret = dpcm_be_dai_trigger(fe, stream, cmd);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nfe->dpcm[stream].state = SND_SOC_DPCM_STATE_START;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nfe->dpcm[stream].state = SND_SOC_DPCM_STATE_STOP;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nfe->dpcm[stream].state = SND_SOC_DPCM_STATE_PAUSED;\r\nbreak;\r\n}\r\nout:\r\nfe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_NO;\r\nmutex_unlock(&fe->card->mutex);\r\nreturn ret;\r\n}\r\nstatic int soc_compr_set_params(struct snd_compr_stream *cstream,\r\nstruct snd_compr_params *params)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\r\nstruct snd_soc_platform *platform = rtd->platform;\r\nint ret = 0;\r\nmutex_lock_nested(&rtd->pcm_mutex, rtd->pcm_subclass);\r\nif (platform->driver->compr_ops && platform->driver->compr_ops->set_params) {\r\nret = platform->driver->compr_ops->set_params(cstream, params);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nif (rtd->dai_link->compr_ops && rtd->dai_link->compr_ops->set_params) {\r\nret = rtd->dai_link->compr_ops->set_params(cstream);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nif (cstream->direction == SND_COMPRESS_PLAYBACK)\r\nsnd_soc_dapm_stream_event(rtd, SNDRV_PCM_STREAM_PLAYBACK,\r\nSND_SOC_DAPM_STREAM_START);\r\nelse\r\nsnd_soc_dapm_stream_event(rtd, SNDRV_PCM_STREAM_CAPTURE,\r\nSND_SOC_DAPM_STREAM_START);\r\nrtd->pop_wait = 0;\r\nmutex_unlock(&rtd->pcm_mutex);\r\ncancel_delayed_work_sync(&rtd->delayed_work);\r\nreturn ret;\r\nerr:\r\nmutex_unlock(&rtd->pcm_mutex);\r\nreturn ret;\r\n}\r\nstatic int soc_compr_set_params_fe(struct snd_compr_stream *cstream,\r\nstruct snd_compr_params *params)\r\n{\r\nstruct snd_soc_pcm_runtime *fe = cstream->private_data;\r\nstruct snd_pcm_substream *fe_substream = fe->pcm->streams[0].substream;\r\nstruct snd_soc_platform *platform = fe->platform;\r\nint ret = 0, stream;\r\nif (cstream->direction == SND_COMPRESS_PLAYBACK)\r\nstream = SNDRV_PCM_STREAM_PLAYBACK;\r\nelse\r\nstream = SNDRV_PCM_STREAM_CAPTURE;\r\nmutex_lock_nested(&fe->card->mutex, SND_SOC_CARD_CLASS_RUNTIME);\r\nif (platform->driver->compr_ops && platform->driver->compr_ops->set_params) {\r\nret = platform->driver->compr_ops->set_params(cstream, params);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\nif (fe->dai_link->compr_ops && fe->dai_link->compr_ops->set_params) {\r\nret = fe->dai_link->compr_ops->set_params(cstream);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\nmemset(&fe->dpcm[fe_substream->stream].hw_params, 0,\r\nsizeof(struct snd_pcm_hw_params));\r\nfe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_FE;\r\nret = dpcm_be_dai_hw_params(fe, stream);\r\nif (ret < 0)\r\ngoto out;\r\nret = dpcm_be_dai_prepare(fe, stream);\r\nif (ret < 0)\r\ngoto out;\r\ndpcm_dapm_stream_event(fe, stream, SND_SOC_DAPM_STREAM_START);\r\nfe->dpcm[stream].state = SND_SOC_DPCM_STATE_PREPARE;\r\nout:\r\nfe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_NO;\r\nmutex_unlock(&fe->card->mutex);\r\nreturn ret;\r\n}\r\nstatic int soc_compr_get_params(struct snd_compr_stream *cstream,\r\nstruct snd_codec *params)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\r\nstruct snd_soc_platform *platform = rtd->platform;\r\nint ret = 0;\r\nmutex_lock_nested(&rtd->pcm_mutex, rtd->pcm_subclass);\r\nif (platform->driver->compr_ops && platform->driver->compr_ops->get_params)\r\nret = platform->driver->compr_ops->get_params(cstream, params);\r\nmutex_unlock(&rtd->pcm_mutex);\r\nreturn ret;\r\n}\r\nstatic int soc_compr_get_caps(struct snd_compr_stream *cstream,\r\nstruct snd_compr_caps *caps)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\r\nstruct snd_soc_platform *platform = rtd->platform;\r\nint ret = 0;\r\nmutex_lock_nested(&rtd->pcm_mutex, rtd->pcm_subclass);\r\nif (platform->driver->compr_ops && platform->driver->compr_ops->get_caps)\r\nret = platform->driver->compr_ops->get_caps(cstream, caps);\r\nmutex_unlock(&rtd->pcm_mutex);\r\nreturn ret;\r\n}\r\nstatic int soc_compr_get_codec_caps(struct snd_compr_stream *cstream,\r\nstruct snd_compr_codec_caps *codec)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\r\nstruct snd_soc_platform *platform = rtd->platform;\r\nint ret = 0;\r\nmutex_lock_nested(&rtd->pcm_mutex, rtd->pcm_subclass);\r\nif (platform->driver->compr_ops && platform->driver->compr_ops->get_codec_caps)\r\nret = platform->driver->compr_ops->get_codec_caps(cstream, codec);\r\nmutex_unlock(&rtd->pcm_mutex);\r\nreturn ret;\r\n}\r\nstatic int soc_compr_ack(struct snd_compr_stream *cstream, size_t bytes)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\r\nstruct snd_soc_platform *platform = rtd->platform;\r\nint ret = 0;\r\nmutex_lock_nested(&rtd->pcm_mutex, rtd->pcm_subclass);\r\nif (platform->driver->compr_ops && platform->driver->compr_ops->ack)\r\nret = platform->driver->compr_ops->ack(cstream, bytes);\r\nmutex_unlock(&rtd->pcm_mutex);\r\nreturn ret;\r\n}\r\nstatic int soc_compr_pointer(struct snd_compr_stream *cstream,\r\nstruct snd_compr_tstamp *tstamp)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\r\nstruct snd_soc_platform *platform = rtd->platform;\r\nmutex_lock_nested(&rtd->pcm_mutex, rtd->pcm_subclass);\r\nif (platform->driver->compr_ops && platform->driver->compr_ops->pointer)\r\nplatform->driver->compr_ops->pointer(cstream, tstamp);\r\nmutex_unlock(&rtd->pcm_mutex);\r\nreturn 0;\r\n}\r\nstatic int soc_compr_copy(struct snd_compr_stream *cstream,\r\nchar __user *buf, size_t count)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\r\nstruct snd_soc_platform *platform = rtd->platform;\r\nint ret = 0;\r\nmutex_lock_nested(&rtd->pcm_mutex, rtd->pcm_subclass);\r\nif (platform->driver->compr_ops && platform->driver->compr_ops->copy)\r\nret = platform->driver->compr_ops->copy(cstream, buf, count);\r\nmutex_unlock(&rtd->pcm_mutex);\r\nreturn ret;\r\n}\r\nstatic int soc_compr_set_metadata(struct snd_compr_stream *cstream,\r\nstruct snd_compr_metadata *metadata)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\r\nstruct snd_soc_platform *platform = rtd->platform;\r\nint ret = 0;\r\nif (platform->driver->compr_ops && platform->driver->compr_ops->set_metadata)\r\nret = platform->driver->compr_ops->set_metadata(cstream, metadata);\r\nreturn ret;\r\n}\r\nstatic int soc_compr_get_metadata(struct snd_compr_stream *cstream,\r\nstruct snd_compr_metadata *metadata)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\r\nstruct snd_soc_platform *platform = rtd->platform;\r\nint ret = 0;\r\nif (platform->driver->compr_ops && platform->driver->compr_ops->get_metadata)\r\nret = platform->driver->compr_ops->get_metadata(cstream, metadata);\r\nreturn ret;\r\n}\r\nint soc_new_compress(struct snd_soc_pcm_runtime *rtd, int num)\r\n{\r\nstruct snd_soc_codec *codec = rtd->codec;\r\nstruct snd_soc_platform *platform = rtd->platform;\r\nstruct snd_soc_dai *codec_dai = rtd->codec_dai;\r\nstruct snd_soc_dai *cpu_dai = rtd->cpu_dai;\r\nstruct snd_compr *compr;\r\nstruct snd_pcm *be_pcm;\r\nchar new_name[64];\r\nint ret = 0, direction = 0;\r\nif (rtd->num_codecs > 1) {\r\ndev_err(rtd->card->dev, "Multicodec not supported for compressed stream\n");\r\nreturn -EINVAL;\r\n}\r\nsnprintf(new_name, sizeof(new_name), "%s %s-%d",\r\nrtd->dai_link->stream_name, codec_dai->name, num);\r\nif (codec_dai->driver->playback.channels_min)\r\ndirection = SND_COMPRESS_PLAYBACK;\r\nelse if (codec_dai->driver->capture.channels_min)\r\ndirection = SND_COMPRESS_CAPTURE;\r\nelse\r\nreturn -EINVAL;\r\ncompr = kzalloc(sizeof(*compr), GFP_KERNEL);\r\nif (compr == NULL) {\r\nsnd_printk(KERN_ERR "Cannot allocate compr\n");\r\nreturn -ENOMEM;\r\n}\r\ncompr->ops = devm_kzalloc(rtd->card->dev, sizeof(soc_compr_ops),\r\nGFP_KERNEL);\r\nif (compr->ops == NULL) {\r\ndev_err(rtd->card->dev, "Cannot allocate compressed ops\n");\r\nret = -ENOMEM;\r\ngoto compr_err;\r\n}\r\nif (rtd->dai_link->dynamic) {\r\nsnprintf(new_name, sizeof(new_name), "(%s)",\r\nrtd->dai_link->stream_name);\r\nret = snd_pcm_new_internal(rtd->card->snd_card, new_name, num,\r\nrtd->dai_link->dpcm_playback,\r\nrtd->dai_link->dpcm_capture, &be_pcm);\r\nif (ret < 0) {\r\ndev_err(rtd->card->dev, "ASoC: can't create compressed for %s\n",\r\nrtd->dai_link->name);\r\ngoto compr_err;\r\n}\r\nrtd->pcm = be_pcm;\r\nrtd->fe_compr = 1;\r\nif (rtd->dai_link->dpcm_playback)\r\nbe_pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream->private_data = rtd;\r\nelse if (rtd->dai_link->dpcm_capture)\r\nbe_pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream->private_data = rtd;\r\nmemcpy(compr->ops, &soc_compr_dyn_ops, sizeof(soc_compr_dyn_ops));\r\n} else\r\nmemcpy(compr->ops, &soc_compr_ops, sizeof(soc_compr_ops));\r\nif (platform->driver->compr_ops && platform->driver->compr_ops->copy)\r\ncompr->ops->copy = soc_compr_copy;\r\nmutex_init(&compr->lock);\r\nret = snd_compress_new(rtd->card->snd_card, num, direction, compr);\r\nif (ret < 0) {\r\npr_err("compress asoc: can't create compress for codec %s\n",\r\ncodec->component.name);\r\ngoto compr_err;\r\n}\r\nINIT_DELAYED_WORK(&rtd->delayed_work, close_delayed_work);\r\nrtd->compr = compr;\r\ncompr->private_data = rtd;\r\nprintk(KERN_INFO "compress asoc: %s <-> %s mapping ok\n", codec_dai->name,\r\ncpu_dai->name);\r\nreturn ret;\r\ncompr_err:\r\nkfree(compr);\r\nreturn ret;\r\n}
