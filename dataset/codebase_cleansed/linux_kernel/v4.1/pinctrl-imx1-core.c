static void __iomem *imx1_mem(struct imx1_pinctrl *ipctl, unsigned int pin_id)\r\n{\r\nunsigned int port = pin_id / 32;\r\nreturn ipctl->base + port * MX1_PORT_STRIDE;\r\n}\r\nstatic void imx1_write_2bit(struct imx1_pinctrl *ipctl, unsigned int pin_id,\r\nu32 value, u32 reg_offset)\r\n{\r\nvoid __iomem *reg = imx1_mem(ipctl, pin_id) + reg_offset;\r\nint offset = (pin_id % 16) * 2;\r\nint mask = ~(0x3 << offset);\r\nu32 old_val;\r\nu32 new_val;\r\nif (pin_id % 32 >= 16)\r\nreg += 0x04;\r\ndev_dbg(ipctl->dev, "write: register 0x%p offset %d value 0x%x\n",\r\nreg, offset, value);\r\nold_val = readl(reg);\r\nold_val &= mask;\r\nnew_val = value & 0x3;\r\nnew_val <<= offset;\r\nnew_val |= old_val;\r\nwritel(new_val, reg);\r\n}\r\nstatic void imx1_write_bit(struct imx1_pinctrl *ipctl, unsigned int pin_id,\r\nu32 value, u32 reg_offset)\r\n{\r\nvoid __iomem *reg = imx1_mem(ipctl, pin_id) + reg_offset;\r\nint offset = pin_id % 32;\r\nint mask = ~BIT_MASK(offset);\r\nu32 old_val;\r\nu32 new_val;\r\nold_val = readl(reg);\r\nold_val &= mask;\r\nnew_val = value & 0x1;\r\nnew_val <<= offset;\r\nnew_val |= old_val;\r\nwritel(new_val, reg);\r\n}\r\nstatic int imx1_read_2bit(struct imx1_pinctrl *ipctl, unsigned int pin_id,\r\nu32 reg_offset)\r\n{\r\nvoid __iomem *reg = imx1_mem(ipctl, pin_id) + reg_offset;\r\nint offset = (pin_id % 16) * 2;\r\nif (pin_id % 32 >= 16)\r\nreg += 0x04;\r\nreturn (readl(reg) & (BIT(offset) | BIT(offset+1))) >> offset;\r\n}\r\nstatic int imx1_read_bit(struct imx1_pinctrl *ipctl, unsigned int pin_id,\r\nu32 reg_offset)\r\n{\r\nvoid __iomem *reg = imx1_mem(ipctl, pin_id) + reg_offset;\r\nint offset = pin_id % 32;\r\nreturn !!(readl(reg) & BIT(offset));\r\n}\r\nstatic const inline struct imx1_pin_group *imx1_pinctrl_find_group_by_name(\r\nconst struct imx1_pinctrl_soc_info *info,\r\nconst char *name)\r\n{\r\nconst struct imx1_pin_group *grp = NULL;\r\nint i;\r\nfor (i = 0; i < info->ngroups; i++) {\r\nif (!strcmp(info->groups[i].name, name)) {\r\ngrp = &info->groups[i];\r\nbreak;\r\n}\r\n}\r\nreturn grp;\r\n}\r\nstatic int imx1_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct imx1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct imx1_pinctrl_soc_info *info = ipctl->info;\r\nreturn info->ngroups;\r\n}\r\nstatic const char *imx1_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned selector)\r\n{\r\nstruct imx1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct imx1_pinctrl_soc_info *info = ipctl->info;\r\nreturn info->groups[selector].name;\r\n}\r\nstatic int imx1_get_group_pins(struct pinctrl_dev *pctldev, unsigned selector,\r\nconst unsigned int **pins,\r\nunsigned *npins)\r\n{\r\nstruct imx1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct imx1_pinctrl_soc_info *info = ipctl->info;\r\nif (selector >= info->ngroups)\r\nreturn -EINVAL;\r\n*pins = info->groups[selector].pin_ids;\r\n*npins = info->groups[selector].npins;\r\nreturn 0;\r\n}\r\nstatic void imx1_pin_dbg_show(struct pinctrl_dev *pctldev, struct seq_file *s,\r\nunsigned offset)\r\n{\r\nstruct imx1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\r\nseq_printf(s, "GPIO %d, function %d, direction %d, oconf %d, iconfa %d, iconfb %d",\r\nimx1_read_bit(ipctl, offset, MX1_GIUS),\r\nimx1_read_bit(ipctl, offset, MX1_GPR),\r\nimx1_read_bit(ipctl, offset, MX1_DDIR),\r\nimx1_read_2bit(ipctl, offset, MX1_OCR),\r\nimx1_read_2bit(ipctl, offset, MX1_ICONFA),\r\nimx1_read_2bit(ipctl, offset, MX1_ICONFB));\r\n}\r\nstatic int imx1_dt_node_to_map(struct pinctrl_dev *pctldev,\r\nstruct device_node *np,\r\nstruct pinctrl_map **map, unsigned *num_maps)\r\n{\r\nstruct imx1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct imx1_pinctrl_soc_info *info = ipctl->info;\r\nconst struct imx1_pin_group *grp;\r\nstruct pinctrl_map *new_map;\r\nstruct device_node *parent;\r\nint map_num = 1;\r\nint i, j;\r\ngrp = imx1_pinctrl_find_group_by_name(info, np->name);\r\nif (!grp) {\r\ndev_err(info->dev, "unable to find group for node %s\n",\r\nnp->name);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < grp->npins; i++)\r\nmap_num++;\r\nnew_map = kmalloc(sizeof(struct pinctrl_map) * map_num, GFP_KERNEL);\r\nif (!new_map)\r\nreturn -ENOMEM;\r\n*map = new_map;\r\n*num_maps = map_num;\r\nparent = of_get_parent(np);\r\nif (!parent) {\r\nkfree(new_map);\r\nreturn -EINVAL;\r\n}\r\nnew_map[0].type = PIN_MAP_TYPE_MUX_GROUP;\r\nnew_map[0].data.mux.function = parent->name;\r\nnew_map[0].data.mux.group = np->name;\r\nof_node_put(parent);\r\nnew_map++;\r\nfor (i = j = 0; i < grp->npins; i++) {\r\nnew_map[j].type = PIN_MAP_TYPE_CONFIGS_PIN;\r\nnew_map[j].data.configs.group_or_pin =\r\npin_get_name(pctldev, grp->pins[i].pin_id);\r\nnew_map[j].data.configs.configs = &grp->pins[i].config;\r\nnew_map[j].data.configs.num_configs = 1;\r\nj++;\r\n}\r\ndev_dbg(pctldev->dev, "maps: function %s group %s num %d\n",\r\n(*map)->data.mux.function, (*map)->data.mux.group, map_num);\r\nreturn 0;\r\n}\r\nstatic void imx1_dt_free_map(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_map *map, unsigned num_maps)\r\n{\r\nkfree(map);\r\n}\r\nstatic int imx1_pmx_set(struct pinctrl_dev *pctldev, unsigned selector,\r\nunsigned group)\r\n{\r\nstruct imx1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct imx1_pinctrl_soc_info *info = ipctl->info;\r\nconst struct imx1_pin *pins;\r\nunsigned int npins;\r\nint i;\r\npins = info->groups[group].pins;\r\nnpins = info->groups[group].npins;\r\nWARN_ON(!pins || !npins);\r\ndev_dbg(ipctl->dev, "enable function %s group %s\n",\r\ninfo->functions[selector].name, info->groups[group].name);\r\nfor (i = 0; i < npins; i++) {\r\nunsigned int mux = pins[i].mux_id;\r\nunsigned int pin_id = pins[i].pin_id;\r\nunsigned int afunction = MX1_MUX_FUNCTION(mux);\r\nunsigned int gpio_in_use = MX1_MUX_GPIO(mux);\r\nunsigned int direction = MX1_MUX_DIR(mux);\r\nunsigned int gpio_oconf = MX1_MUX_OCONF(mux);\r\nunsigned int gpio_iconfa = MX1_MUX_ICONFA(mux);\r\nunsigned int gpio_iconfb = MX1_MUX_ICONFB(mux);\r\ndev_dbg(pctldev->dev, "%s, pin 0x%x, function %d, gpio %d, direction %d, oconf %d, iconfa %d, iconfb %d\n",\r\n__func__, pin_id, afunction, gpio_in_use,\r\ndirection, gpio_oconf, gpio_iconfa,\r\ngpio_iconfb);\r\nimx1_write_bit(ipctl, pin_id, gpio_in_use, MX1_GIUS);\r\nimx1_write_bit(ipctl, pin_id, direction, MX1_DDIR);\r\nif (gpio_in_use) {\r\nimx1_write_2bit(ipctl, pin_id, gpio_oconf, MX1_OCR);\r\nimx1_write_2bit(ipctl, pin_id, gpio_iconfa,\r\nMX1_ICONFA);\r\nimx1_write_2bit(ipctl, pin_id, gpio_iconfb,\r\nMX1_ICONFB);\r\n} else {\r\nimx1_write_bit(ipctl, pin_id, afunction, MX1_GPR);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int imx1_pmx_get_funcs_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct imx1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct imx1_pinctrl_soc_info *info = ipctl->info;\r\nreturn info->nfunctions;\r\n}\r\nstatic const char *imx1_pmx_get_func_name(struct pinctrl_dev *pctldev,\r\nunsigned selector)\r\n{\r\nstruct imx1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct imx1_pinctrl_soc_info *info = ipctl->info;\r\nreturn info->functions[selector].name;\r\n}\r\nstatic int imx1_pmx_get_groups(struct pinctrl_dev *pctldev, unsigned selector,\r\nconst char * const **groups,\r\nunsigned * const num_groups)\r\n{\r\nstruct imx1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct imx1_pinctrl_soc_info *info = ipctl->info;\r\n*groups = info->functions[selector].groups;\r\n*num_groups = info->functions[selector].num_groups;\r\nreturn 0;\r\n}\r\nstatic int imx1_pinconf_get(struct pinctrl_dev *pctldev,\r\nunsigned pin_id, unsigned long *config)\r\n{\r\nstruct imx1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\r\n*config = imx1_read_bit(ipctl, pin_id, MX1_PUEN);\r\nreturn 0;\r\n}\r\nstatic int imx1_pinconf_set(struct pinctrl_dev *pctldev,\r\nunsigned pin_id, unsigned long *configs,\r\nunsigned num_configs)\r\n{\r\nstruct imx1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct imx1_pinctrl_soc_info *info = ipctl->info;\r\nint i;\r\nfor (i = 0; i != num_configs; ++i) {\r\nimx1_write_bit(ipctl, pin_id, configs[i] & 0x01, MX1_PUEN);\r\ndev_dbg(ipctl->dev, "pinconf set pullup pin %s\n",\r\ninfo->pins[pin_id].name);\r\n}\r\nreturn 0;\r\n}\r\nstatic void imx1_pinconf_dbg_show(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s, unsigned pin_id)\r\n{\r\nunsigned long config;\r\nimx1_pinconf_get(pctldev, pin_id, &config);\r\nseq_printf(s, "0x%lx", config);\r\n}\r\nstatic void imx1_pinconf_group_dbg_show(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s, unsigned group)\r\n{\r\nstruct imx1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct imx1_pinctrl_soc_info *info = ipctl->info;\r\nstruct imx1_pin_group *grp;\r\nunsigned long config;\r\nconst char *name;\r\nint i, ret;\r\nif (group > info->ngroups)\r\nreturn;\r\nseq_puts(s, "\n");\r\ngrp = &info->groups[group];\r\nfor (i = 0; i < grp->npins; i++) {\r\nname = pin_get_name(pctldev, grp->pins[i].pin_id);\r\nret = imx1_pinconf_get(pctldev, grp->pins[i].pin_id, &config);\r\nif (ret)\r\nreturn;\r\nseq_printf(s, "%s: 0x%lx", name, config);\r\n}\r\n}\r\nstatic int imx1_pinctrl_parse_groups(struct device_node *np,\r\nstruct imx1_pin_group *grp,\r\nstruct imx1_pinctrl_soc_info *info,\r\nu32 index)\r\n{\r\nint size;\r\nconst __be32 *list;\r\nint i;\r\ndev_dbg(info->dev, "group(%d): %s\n", index, np->name);\r\ngrp->name = np->name;\r\nlist = of_get_property(np, "fsl,pins", &size);\r\nif (!size || size % 12) {\r\ndev_notice(info->dev, "Not a valid fsl,pins property (%s)\n",\r\nnp->name);\r\nreturn -EINVAL;\r\n}\r\ngrp->npins = size / 12;\r\ngrp->pins = devm_kzalloc(info->dev,\r\ngrp->npins * sizeof(struct imx1_pin), GFP_KERNEL);\r\ngrp->pin_ids = devm_kzalloc(info->dev,\r\ngrp->npins * sizeof(unsigned int), GFP_KERNEL);\r\nif (!grp->pins || !grp->pin_ids)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < grp->npins; i++) {\r\ngrp->pins[i].pin_id = be32_to_cpu(*list++);\r\ngrp->pins[i].mux_id = be32_to_cpu(*list++);\r\ngrp->pins[i].config = be32_to_cpu(*list++);\r\ngrp->pin_ids[i] = grp->pins[i].pin_id;\r\n}\r\nreturn 0;\r\n}\r\nstatic int imx1_pinctrl_parse_functions(struct device_node *np,\r\nstruct imx1_pinctrl_soc_info *info,\r\nu32 index)\r\n{\r\nstruct device_node *child;\r\nstruct imx1_pmx_func *func;\r\nstruct imx1_pin_group *grp;\r\nint ret;\r\nstatic u32 grp_index;\r\nu32 i = 0;\r\ndev_dbg(info->dev, "parse function(%d): %s\n", index, np->name);\r\nfunc = &info->functions[index];\r\nfunc->name = np->name;\r\nfunc->num_groups = of_get_child_count(np);\r\nif (func->num_groups == 0)\r\nreturn -EINVAL;\r\nfunc->groups = devm_kzalloc(info->dev,\r\nfunc->num_groups * sizeof(char *), GFP_KERNEL);\r\nif (!func->groups)\r\nreturn -ENOMEM;\r\nfor_each_child_of_node(np, child) {\r\nfunc->groups[i] = child->name;\r\ngrp = &info->groups[grp_index++];\r\nret = imx1_pinctrl_parse_groups(child, grp, info, i++);\r\nif (ret == -ENOMEM)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int imx1_pinctrl_parse_dt(struct platform_device *pdev,\r\nstruct imx1_pinctrl *pctl, struct imx1_pinctrl_soc_info *info)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct device_node *child;\r\nint ret;\r\nu32 nfuncs = 0;\r\nu32 ngroups = 0;\r\nu32 ifunc = 0;\r\nif (!np)\r\nreturn -ENODEV;\r\nfor_each_child_of_node(np, child) {\r\n++nfuncs;\r\nngroups += of_get_child_count(child);\r\n}\r\nif (!nfuncs) {\r\ndev_err(&pdev->dev, "No pin functions defined\n");\r\nreturn -EINVAL;\r\n}\r\ninfo->nfunctions = nfuncs;\r\ninfo->functions = devm_kzalloc(&pdev->dev,\r\nnfuncs * sizeof(struct imx1_pmx_func), GFP_KERNEL);\r\ninfo->ngroups = ngroups;\r\ninfo->groups = devm_kzalloc(&pdev->dev,\r\nngroups * sizeof(struct imx1_pin_group), GFP_KERNEL);\r\nif (!info->functions || !info->groups)\r\nreturn -ENOMEM;\r\nfor_each_child_of_node(np, child) {\r\nret = imx1_pinctrl_parse_functions(child, info, ifunc++);\r\nif (ret == -ENOMEM)\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nint imx1_pinctrl_core_probe(struct platform_device *pdev,\r\nstruct imx1_pinctrl_soc_info *info)\r\n{\r\nstruct imx1_pinctrl *ipctl;\r\nstruct resource *res;\r\nstruct pinctrl_desc *pctl_desc;\r\nint ret;\r\nif (!info || !info->pins || !info->npins) {\r\ndev_err(&pdev->dev, "wrong pinctrl info\n");\r\nreturn -EINVAL;\r\n}\r\ninfo->dev = &pdev->dev;\r\nipctl = devm_kzalloc(&pdev->dev, sizeof(*ipctl), GFP_KERNEL);\r\nif (!ipctl)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENOENT;\r\nipctl->base = devm_ioremap_nocache(&pdev->dev, res->start,\r\nresource_size(res));\r\nif (!ipctl->base)\r\nreturn -ENOMEM;\r\npctl_desc = &imx1_pinctrl_desc;\r\npctl_desc->name = dev_name(&pdev->dev);\r\npctl_desc->pins = info->pins;\r\npctl_desc->npins = info->npins;\r\nret = imx1_pinctrl_parse_dt(pdev, ipctl, info);\r\nif (ret) {\r\ndev_err(&pdev->dev, "fail to probe dt properties\n");\r\nreturn ret;\r\n}\r\nipctl->info = info;\r\nipctl->dev = info->dev;\r\nplatform_set_drvdata(pdev, ipctl);\r\nipctl->pctl = pinctrl_register(pctl_desc, &pdev->dev, ipctl);\r\nif (!ipctl->pctl) {\r\ndev_err(&pdev->dev, "could not register IMX pinctrl driver\n");\r\nreturn -EINVAL;\r\n}\r\nret = of_platform_populate(pdev->dev.of_node, NULL, NULL, &pdev->dev);\r\nif (ret) {\r\npinctrl_unregister(ipctl->pctl);\r\ndev_err(&pdev->dev, "Failed to populate subdevices\n");\r\nreturn ret;\r\n}\r\ndev_info(&pdev->dev, "initialized IMX pinctrl driver\n");\r\nreturn 0;\r\n}\r\nint imx1_pinctrl_core_remove(struct platform_device *pdev)\r\n{\r\nstruct imx1_pinctrl *ipctl = platform_get_drvdata(pdev);\r\npinctrl_unregister(ipctl->pctl);\r\nreturn 0;\r\n}
