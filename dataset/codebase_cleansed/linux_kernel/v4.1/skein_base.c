int skein_256_init(struct skein_256_ctx *ctx, size_t hash_bit_len)\r\n{\r\nunion {\r\nu8 b[SKEIN_256_STATE_BYTES];\r\nu64 w[SKEIN_256_STATE_WORDS];\r\n} cfg;\r\nskein_assert_ret(hash_bit_len > 0, SKEIN_BAD_HASHLEN);\r\nctx->h.hash_bit_len = hash_bit_len;\r\nswitch (hash_bit_len) {\r\ncase 256:\r\nmemcpy(ctx->x, SKEIN_256_IV_256, sizeof(ctx->x));\r\nbreak;\r\ncase 224:\r\nmemcpy(ctx->x, SKEIN_256_IV_224, sizeof(ctx->x));\r\nbreak;\r\ncase 160:\r\nmemcpy(ctx->x, SKEIN_256_IV_160, sizeof(ctx->x));\r\nbreak;\r\ncase 128:\r\nmemcpy(ctx->x, SKEIN_256_IV_128, sizeof(ctx->x));\r\nbreak;\r\ndefault:\r\nskein_start_new_type(ctx, CFG_FINAL);\r\ncfg.w[0] = skein_swap64(SKEIN_SCHEMA_VER);\r\ncfg.w[1] = skein_swap64(hash_bit_len);\r\ncfg.w[2] = skein_swap64(SKEIN_CFG_TREE_INFO_SEQUENTIAL);\r\nmemset(&cfg.w[3], 0, sizeof(cfg) - 3*sizeof(cfg.w[0]));\r\nmemset(ctx->x, 0, sizeof(ctx->x));\r\nskein_256_process_block(ctx, cfg.b, 1, SKEIN_CFG_STR_LEN);\r\nbreak;\r\n}\r\nskein_start_new_type(ctx, MSG);\r\nreturn SKEIN_SUCCESS;\r\n}\r\nint skein_256_init_ext(struct skein_256_ctx *ctx, size_t hash_bit_len,\r\nu64 tree_info, const u8 *key, size_t key_bytes)\r\n{\r\nunion {\r\nu8 b[SKEIN_256_STATE_BYTES];\r\nu64 w[SKEIN_256_STATE_WORDS];\r\n} cfg;\r\nskein_assert_ret(hash_bit_len > 0, SKEIN_BAD_HASHLEN);\r\nskein_assert_ret(key_bytes == 0 || key != NULL, SKEIN_FAIL);\r\nif (key_bytes == 0) {\r\nmemset(ctx->x, 0, sizeof(ctx->x));\r\n} else {\r\nskein_assert(sizeof(cfg.b) >= sizeof(ctx->x));\r\nctx->h.hash_bit_len = 8*sizeof(ctx->x);\r\nskein_start_new_type(ctx, KEY);\r\nmemset(ctx->x, 0, sizeof(ctx->x));\r\nskein_256_update(ctx, key, key_bytes);\r\nskein_256_final_pad(ctx, cfg.b);\r\nmemcpy(ctx->x, cfg.b, sizeof(cfg.b));\r\n}\r\nctx->h.hash_bit_len = hash_bit_len;\r\nskein_start_new_type(ctx, CFG_FINAL);\r\nmemset(&cfg.w, 0, sizeof(cfg.w));\r\ncfg.w[0] = skein_swap64(SKEIN_SCHEMA_VER);\r\ncfg.w[1] = skein_swap64(hash_bit_len);\r\ncfg.w[2] = skein_swap64(tree_info);\r\nskein_256_process_block(ctx, cfg.b, 1, SKEIN_CFG_STR_LEN);\r\nskein_start_new_type(ctx, MSG);\r\nreturn SKEIN_SUCCESS;\r\n}\r\nint skein_256_update(struct skein_256_ctx *ctx, const u8 *msg,\r\nsize_t msg_byte_cnt)\r\n{\r\nsize_t n;\r\nskein_assert_ret(ctx->h.b_cnt <= SKEIN_256_BLOCK_BYTES, SKEIN_FAIL);\r\nif (msg_byte_cnt + ctx->h.b_cnt > SKEIN_256_BLOCK_BYTES) {\r\nif (ctx->h.b_cnt) {\r\nn = SKEIN_256_BLOCK_BYTES - ctx->h.b_cnt;\r\nif (n) {\r\nskein_assert(n < msg_byte_cnt);\r\nmemcpy(&ctx->b[ctx->h.b_cnt], msg, n);\r\nmsg_byte_cnt -= n;\r\nmsg += n;\r\nctx->h.b_cnt += n;\r\n}\r\nskein_assert(ctx->h.b_cnt == SKEIN_256_BLOCK_BYTES);\r\nskein_256_process_block(ctx, ctx->b, 1,\r\nSKEIN_256_BLOCK_BYTES);\r\nctx->h.b_cnt = 0;\r\n}\r\nif (msg_byte_cnt > SKEIN_256_BLOCK_BYTES) {\r\nn = (msg_byte_cnt-1) / SKEIN_256_BLOCK_BYTES;\r\nskein_256_process_block(ctx, msg, n,\r\nSKEIN_256_BLOCK_BYTES);\r\nmsg_byte_cnt -= n * SKEIN_256_BLOCK_BYTES;\r\nmsg += n * SKEIN_256_BLOCK_BYTES;\r\n}\r\nskein_assert(ctx->h.b_cnt == 0);\r\n}\r\nif (msg_byte_cnt) {\r\nskein_assert(msg_byte_cnt + ctx->h.b_cnt <=\r\nSKEIN_256_BLOCK_BYTES);\r\nmemcpy(&ctx->b[ctx->h.b_cnt], msg, msg_byte_cnt);\r\nctx->h.b_cnt += msg_byte_cnt;\r\n}\r\nreturn SKEIN_SUCCESS;\r\n}\r\nint skein_256_final(struct skein_256_ctx *ctx, u8 *hash_val)\r\n{\r\nsize_t i, n, byte_cnt;\r\nu64 x[SKEIN_256_STATE_WORDS];\r\nskein_assert_ret(ctx->h.b_cnt <= SKEIN_256_BLOCK_BYTES, SKEIN_FAIL);\r\nctx->h.tweak[1] |= SKEIN_T1_FLAG_FINAL;\r\nif (ctx->h.b_cnt < SKEIN_256_BLOCK_BYTES)\r\nmemset(&ctx->b[ctx->h.b_cnt], 0,\r\nSKEIN_256_BLOCK_BYTES - ctx->h.b_cnt);\r\nskein_256_process_block(ctx, ctx->b, 1, ctx->h.b_cnt);\r\nbyte_cnt = (ctx->h.hash_bit_len + 7) >> 3;\r\nmemset(ctx->b, 0, sizeof(ctx->b));\r\nmemcpy(x, ctx->x, sizeof(x));\r\nfor (i = 0; i*SKEIN_256_BLOCK_BYTES < byte_cnt; i++) {\r\n((u64 *)ctx->b)[0] = skein_swap64((u64) i);\r\nskein_start_new_type(ctx, OUT_FINAL);\r\nskein_256_process_block(ctx, ctx->b, 1, sizeof(u64));\r\nn = byte_cnt - i*SKEIN_256_BLOCK_BYTES;\r\nif (n >= SKEIN_256_BLOCK_BYTES)\r\nn = SKEIN_256_BLOCK_BYTES;\r\nskein_put64_lsb_first(hash_val+i*SKEIN_256_BLOCK_BYTES, ctx->x,\r\nn);\r\nmemcpy(ctx->x, x, sizeof(x));\r\n}\r\nreturn SKEIN_SUCCESS;\r\n}\r\nint skein_512_init(struct skein_512_ctx *ctx, size_t hash_bit_len)\r\n{\r\nunion {\r\nu8 b[SKEIN_512_STATE_BYTES];\r\nu64 w[SKEIN_512_STATE_WORDS];\r\n} cfg;\r\nskein_assert_ret(hash_bit_len > 0, SKEIN_BAD_HASHLEN);\r\nctx->h.hash_bit_len = hash_bit_len;\r\nswitch (hash_bit_len) {\r\ncase 512:\r\nmemcpy(ctx->x, SKEIN_512_IV_512, sizeof(ctx->x));\r\nbreak;\r\ncase 384:\r\nmemcpy(ctx->x, SKEIN_512_IV_384, sizeof(ctx->x));\r\nbreak;\r\ncase 256:\r\nmemcpy(ctx->x, SKEIN_512_IV_256, sizeof(ctx->x));\r\nbreak;\r\ncase 224:\r\nmemcpy(ctx->x, SKEIN_512_IV_224, sizeof(ctx->x));\r\nbreak;\r\ndefault:\r\nskein_start_new_type(ctx, CFG_FINAL);\r\ncfg.w[0] = skein_swap64(SKEIN_SCHEMA_VER);\r\ncfg.w[1] = skein_swap64(hash_bit_len);\r\ncfg.w[2] = skein_swap64(SKEIN_CFG_TREE_INFO_SEQUENTIAL);\r\nmemset(&cfg.w[3], 0, sizeof(cfg) - 3*sizeof(cfg.w[0]));\r\nmemset(ctx->x, 0, sizeof(ctx->x));\r\nskein_512_process_block(ctx, cfg.b, 1, SKEIN_CFG_STR_LEN);\r\nbreak;\r\n}\r\nskein_start_new_type(ctx, MSG);\r\nreturn SKEIN_SUCCESS;\r\n}\r\nint skein_512_init_ext(struct skein_512_ctx *ctx, size_t hash_bit_len,\r\nu64 tree_info, const u8 *key, size_t key_bytes)\r\n{\r\nunion {\r\nu8 b[SKEIN_512_STATE_BYTES];\r\nu64 w[SKEIN_512_STATE_WORDS];\r\n} cfg;\r\nskein_assert_ret(hash_bit_len > 0, SKEIN_BAD_HASHLEN);\r\nskein_assert_ret(key_bytes == 0 || key != NULL, SKEIN_FAIL);\r\nif (key_bytes == 0) {\r\nmemset(ctx->x, 0, sizeof(ctx->x));\r\n} else {\r\nskein_assert(sizeof(cfg.b) >= sizeof(ctx->x));\r\nctx->h.hash_bit_len = 8*sizeof(ctx->x);\r\nskein_start_new_type(ctx, KEY);\r\nmemset(ctx->x, 0, sizeof(ctx->x));\r\nskein_512_update(ctx, key, key_bytes);\r\nskein_512_final_pad(ctx, cfg.b);\r\nmemcpy(ctx->x, cfg.b, sizeof(cfg.b));\r\n}\r\nctx->h.hash_bit_len = hash_bit_len;\r\nskein_start_new_type(ctx, CFG_FINAL);\r\nmemset(&cfg.w, 0, sizeof(cfg.w));\r\ncfg.w[0] = skein_swap64(SKEIN_SCHEMA_VER);\r\ncfg.w[1] = skein_swap64(hash_bit_len);\r\ncfg.w[2] = skein_swap64(tree_info);\r\nskein_512_process_block(ctx, cfg.b, 1, SKEIN_CFG_STR_LEN);\r\nskein_start_new_type(ctx, MSG);\r\nreturn SKEIN_SUCCESS;\r\n}\r\nint skein_512_update(struct skein_512_ctx *ctx, const u8 *msg,\r\nsize_t msg_byte_cnt)\r\n{\r\nsize_t n;\r\nskein_assert_ret(ctx->h.b_cnt <= SKEIN_512_BLOCK_BYTES, SKEIN_FAIL);\r\nif (msg_byte_cnt + ctx->h.b_cnt > SKEIN_512_BLOCK_BYTES) {\r\nif (ctx->h.b_cnt) {\r\nn = SKEIN_512_BLOCK_BYTES - ctx->h.b_cnt;\r\nif (n) {\r\nskein_assert(n < msg_byte_cnt);\r\nmemcpy(&ctx->b[ctx->h.b_cnt], msg, n);\r\nmsg_byte_cnt -= n;\r\nmsg += n;\r\nctx->h.b_cnt += n;\r\n}\r\nskein_assert(ctx->h.b_cnt == SKEIN_512_BLOCK_BYTES);\r\nskein_512_process_block(ctx, ctx->b, 1,\r\nSKEIN_512_BLOCK_BYTES);\r\nctx->h.b_cnt = 0;\r\n}\r\nif (msg_byte_cnt > SKEIN_512_BLOCK_BYTES) {\r\nn = (msg_byte_cnt-1) / SKEIN_512_BLOCK_BYTES;\r\nskein_512_process_block(ctx, msg, n,\r\nSKEIN_512_BLOCK_BYTES);\r\nmsg_byte_cnt -= n * SKEIN_512_BLOCK_BYTES;\r\nmsg += n * SKEIN_512_BLOCK_BYTES;\r\n}\r\nskein_assert(ctx->h.b_cnt == 0);\r\n}\r\nif (msg_byte_cnt) {\r\nskein_assert(msg_byte_cnt + ctx->h.b_cnt <=\r\nSKEIN_512_BLOCK_BYTES);\r\nmemcpy(&ctx->b[ctx->h.b_cnt], msg, msg_byte_cnt);\r\nctx->h.b_cnt += msg_byte_cnt;\r\n}\r\nreturn SKEIN_SUCCESS;\r\n}\r\nint skein_512_final(struct skein_512_ctx *ctx, u8 *hash_val)\r\n{\r\nsize_t i, n, byte_cnt;\r\nu64 x[SKEIN_512_STATE_WORDS];\r\nskein_assert_ret(ctx->h.b_cnt <= SKEIN_512_BLOCK_BYTES, SKEIN_FAIL);\r\nctx->h.tweak[1] |= SKEIN_T1_FLAG_FINAL;\r\nif (ctx->h.b_cnt < SKEIN_512_BLOCK_BYTES)\r\nmemset(&ctx->b[ctx->h.b_cnt], 0,\r\nSKEIN_512_BLOCK_BYTES - ctx->h.b_cnt);\r\nskein_512_process_block(ctx, ctx->b, 1, ctx->h.b_cnt);\r\nbyte_cnt = (ctx->h.hash_bit_len + 7) >> 3;\r\nmemset(ctx->b, 0, sizeof(ctx->b));\r\nmemcpy(x, ctx->x, sizeof(x));\r\nfor (i = 0; i*SKEIN_512_BLOCK_BYTES < byte_cnt; i++) {\r\n((u64 *)ctx->b)[0] = skein_swap64((u64) i);\r\nskein_start_new_type(ctx, OUT_FINAL);\r\nskein_512_process_block(ctx, ctx->b, 1, sizeof(u64));\r\nn = byte_cnt - i*SKEIN_512_BLOCK_BYTES;\r\nif (n >= SKEIN_512_BLOCK_BYTES)\r\nn = SKEIN_512_BLOCK_BYTES;\r\nskein_put64_lsb_first(hash_val+i*SKEIN_512_BLOCK_BYTES, ctx->x,\r\nn);\r\nmemcpy(ctx->x, x, sizeof(x));\r\n}\r\nreturn SKEIN_SUCCESS;\r\n}\r\nint skein_1024_init(struct skein_1024_ctx *ctx, size_t hash_bit_len)\r\n{\r\nunion {\r\nu8 b[SKEIN_1024_STATE_BYTES];\r\nu64 w[SKEIN_1024_STATE_WORDS];\r\n} cfg;\r\nskein_assert_ret(hash_bit_len > 0, SKEIN_BAD_HASHLEN);\r\nctx->h.hash_bit_len = hash_bit_len;\r\nswitch (hash_bit_len) {\r\ncase 512:\r\nmemcpy(ctx->x, SKEIN_1024_IV_512, sizeof(ctx->x));\r\nbreak;\r\ncase 384:\r\nmemcpy(ctx->x, SKEIN_1024_IV_384, sizeof(ctx->x));\r\nbreak;\r\ncase 1024:\r\nmemcpy(ctx->x, SKEIN_1024_IV_1024, sizeof(ctx->x));\r\nbreak;\r\ndefault:\r\nskein_start_new_type(ctx, CFG_FINAL);\r\ncfg.w[0] = skein_swap64(SKEIN_SCHEMA_VER);\r\ncfg.w[1] = skein_swap64(hash_bit_len);\r\ncfg.w[2] = skein_swap64(SKEIN_CFG_TREE_INFO_SEQUENTIAL);\r\nmemset(&cfg.w[3], 0, sizeof(cfg) - 3*sizeof(cfg.w[0]));\r\nmemset(ctx->x, 0, sizeof(ctx->x));\r\nskein_1024_process_block(ctx, cfg.b, 1, SKEIN_CFG_STR_LEN);\r\nbreak;\r\n}\r\nskein_start_new_type(ctx, MSG);\r\nreturn SKEIN_SUCCESS;\r\n}\r\nint skein_1024_init_ext(struct skein_1024_ctx *ctx, size_t hash_bit_len,\r\nu64 tree_info, const u8 *key, size_t key_bytes)\r\n{\r\nunion {\r\nu8 b[SKEIN_1024_STATE_BYTES];\r\nu64 w[SKEIN_1024_STATE_WORDS];\r\n} cfg;\r\nskein_assert_ret(hash_bit_len > 0, SKEIN_BAD_HASHLEN);\r\nskein_assert_ret(key_bytes == 0 || key != NULL, SKEIN_FAIL);\r\nif (key_bytes == 0) {\r\nmemset(ctx->x, 0, sizeof(ctx->x));\r\n} else {\r\nskein_assert(sizeof(cfg.b) >= sizeof(ctx->x));\r\nctx->h.hash_bit_len = 8*sizeof(ctx->x);\r\nskein_start_new_type(ctx, KEY);\r\nmemset(ctx->x, 0, sizeof(ctx->x));\r\nskein_1024_update(ctx, key, key_bytes);\r\nskein_1024_final_pad(ctx, cfg.b);\r\nmemcpy(ctx->x, cfg.b, sizeof(cfg.b));\r\n}\r\nctx->h.hash_bit_len = hash_bit_len;\r\nskein_start_new_type(ctx, CFG_FINAL);\r\nmemset(&cfg.w, 0, sizeof(cfg.w));\r\ncfg.w[0] = skein_swap64(SKEIN_SCHEMA_VER);\r\ncfg.w[1] = skein_swap64(hash_bit_len);\r\ncfg.w[2] = skein_swap64(tree_info);\r\nskein_1024_process_block(ctx, cfg.b, 1, SKEIN_CFG_STR_LEN);\r\nskein_start_new_type(ctx, MSG);\r\nreturn SKEIN_SUCCESS;\r\n}\r\nint skein_1024_update(struct skein_1024_ctx *ctx, const u8 *msg,\r\nsize_t msg_byte_cnt)\r\n{\r\nsize_t n;\r\nskein_assert_ret(ctx->h.b_cnt <= SKEIN_1024_BLOCK_BYTES, SKEIN_FAIL);\r\nif (msg_byte_cnt + ctx->h.b_cnt > SKEIN_1024_BLOCK_BYTES) {\r\nif (ctx->h.b_cnt) {\r\nn = SKEIN_1024_BLOCK_BYTES - ctx->h.b_cnt;\r\nif (n) {\r\nskein_assert(n < msg_byte_cnt);\r\nmemcpy(&ctx->b[ctx->h.b_cnt], msg, n);\r\nmsg_byte_cnt -= n;\r\nmsg += n;\r\nctx->h.b_cnt += n;\r\n}\r\nskein_assert(ctx->h.b_cnt == SKEIN_1024_BLOCK_BYTES);\r\nskein_1024_process_block(ctx, ctx->b, 1,\r\nSKEIN_1024_BLOCK_BYTES);\r\nctx->h.b_cnt = 0;\r\n}\r\nif (msg_byte_cnt > SKEIN_1024_BLOCK_BYTES) {\r\nn = (msg_byte_cnt-1) / SKEIN_1024_BLOCK_BYTES;\r\nskein_1024_process_block(ctx, msg, n,\r\nSKEIN_1024_BLOCK_BYTES);\r\nmsg_byte_cnt -= n * SKEIN_1024_BLOCK_BYTES;\r\nmsg += n * SKEIN_1024_BLOCK_BYTES;\r\n}\r\nskein_assert(ctx->h.b_cnt == 0);\r\n}\r\nif (msg_byte_cnt) {\r\nskein_assert(msg_byte_cnt + ctx->h.b_cnt <=\r\nSKEIN_1024_BLOCK_BYTES);\r\nmemcpy(&ctx->b[ctx->h.b_cnt], msg, msg_byte_cnt);\r\nctx->h.b_cnt += msg_byte_cnt;\r\n}\r\nreturn SKEIN_SUCCESS;\r\n}\r\nint skein_1024_final(struct skein_1024_ctx *ctx, u8 *hash_val)\r\n{\r\nsize_t i, n, byte_cnt;\r\nu64 x[SKEIN_1024_STATE_WORDS];\r\nskein_assert_ret(ctx->h.b_cnt <= SKEIN_1024_BLOCK_BYTES, SKEIN_FAIL);\r\nctx->h.tweak[1] |= SKEIN_T1_FLAG_FINAL;\r\nif (ctx->h.b_cnt < SKEIN_1024_BLOCK_BYTES)\r\nmemset(&ctx->b[ctx->h.b_cnt], 0,\r\nSKEIN_1024_BLOCK_BYTES - ctx->h.b_cnt);\r\nskein_1024_process_block(ctx, ctx->b, 1, ctx->h.b_cnt);\r\nbyte_cnt = (ctx->h.hash_bit_len + 7) >> 3;\r\nmemset(ctx->b, 0, sizeof(ctx->b));\r\nmemcpy(x, ctx->x, sizeof(x));\r\nfor (i = 0; i*SKEIN_1024_BLOCK_BYTES < byte_cnt; i++) {\r\n((u64 *)ctx->b)[0] = skein_swap64((u64) i);\r\nskein_start_new_type(ctx, OUT_FINAL);\r\nskein_1024_process_block(ctx, ctx->b, 1, sizeof(u64));\r\nn = byte_cnt - i*SKEIN_1024_BLOCK_BYTES;\r\nif (n >= SKEIN_1024_BLOCK_BYTES)\r\nn = SKEIN_1024_BLOCK_BYTES;\r\nskein_put64_lsb_first(hash_val+i*SKEIN_1024_BLOCK_BYTES, ctx->x,\r\nn);\r\nmemcpy(ctx->x, x, sizeof(x));\r\n}\r\nreturn SKEIN_SUCCESS;\r\n}\r\nint skein_256_final_pad(struct skein_256_ctx *ctx, u8 *hash_val)\r\n{\r\nskein_assert_ret(ctx->h.b_cnt <= SKEIN_256_BLOCK_BYTES, SKEIN_FAIL);\r\nctx->h.tweak[1] |= SKEIN_T1_FLAG_FINAL;\r\nif (ctx->h.b_cnt < SKEIN_256_BLOCK_BYTES)\r\nmemset(&ctx->b[ctx->h.b_cnt], 0,\r\nSKEIN_256_BLOCK_BYTES - ctx->h.b_cnt);\r\nskein_256_process_block(ctx, ctx->b, 1, ctx->h.b_cnt);\r\nskein_put64_lsb_first(hash_val, ctx->x, SKEIN_256_BLOCK_BYTES);\r\nreturn SKEIN_SUCCESS;\r\n}\r\nint skein_512_final_pad(struct skein_512_ctx *ctx, u8 *hash_val)\r\n{\r\nskein_assert_ret(ctx->h.b_cnt <= SKEIN_512_BLOCK_BYTES, SKEIN_FAIL);\r\nctx->h.tweak[1] |= SKEIN_T1_FLAG_FINAL;\r\nif (ctx->h.b_cnt < SKEIN_512_BLOCK_BYTES)\r\nmemset(&ctx->b[ctx->h.b_cnt], 0,\r\nSKEIN_512_BLOCK_BYTES - ctx->h.b_cnt);\r\nskein_512_process_block(ctx, ctx->b, 1, ctx->h.b_cnt);\r\nskein_put64_lsb_first(hash_val, ctx->x, SKEIN_512_BLOCK_BYTES);\r\nreturn SKEIN_SUCCESS;\r\n}\r\nint skein_1024_final_pad(struct skein_1024_ctx *ctx, u8 *hash_val)\r\n{\r\nskein_assert_ret(ctx->h.b_cnt <= SKEIN_1024_BLOCK_BYTES, SKEIN_FAIL);\r\nctx->h.tweak[1] |= SKEIN_T1_FLAG_FINAL;\r\nif (ctx->h.b_cnt < SKEIN_1024_BLOCK_BYTES)\r\nmemset(&ctx->b[ctx->h.b_cnt], 0,\r\nSKEIN_1024_BLOCK_BYTES - ctx->h.b_cnt);\r\nskein_1024_process_block(ctx, ctx->b, 1, ctx->h.b_cnt);\r\nskein_put64_lsb_first(hash_val, ctx->x, SKEIN_1024_BLOCK_BYTES);\r\nreturn SKEIN_SUCCESS;\r\n}\r\nint skein_256_output(struct skein_256_ctx *ctx, u8 *hash_val)\r\n{\r\nsize_t i, n, byte_cnt;\r\nu64 x[SKEIN_256_STATE_WORDS];\r\nskein_assert_ret(ctx->h.b_cnt <= SKEIN_256_BLOCK_BYTES, SKEIN_FAIL);\r\nbyte_cnt = (ctx->h.hash_bit_len + 7) >> 3;\r\nmemset(ctx->b, 0, sizeof(ctx->b));\r\nmemcpy(x, ctx->x, sizeof(x));\r\nfor (i = 0; i*SKEIN_256_BLOCK_BYTES < byte_cnt; i++) {\r\n((u64 *)ctx->b)[0] = skein_swap64((u64) i);\r\nskein_start_new_type(ctx, OUT_FINAL);\r\nskein_256_process_block(ctx, ctx->b, 1, sizeof(u64));\r\nn = byte_cnt - i*SKEIN_256_BLOCK_BYTES;\r\nif (n >= SKEIN_256_BLOCK_BYTES)\r\nn = SKEIN_256_BLOCK_BYTES;\r\nskein_put64_lsb_first(hash_val+i*SKEIN_256_BLOCK_BYTES, ctx->x,\r\nn);\r\nmemcpy(ctx->x, x, sizeof(x));\r\n}\r\nreturn SKEIN_SUCCESS;\r\n}\r\nint skein_512_output(struct skein_512_ctx *ctx, u8 *hash_val)\r\n{\r\nsize_t i, n, byte_cnt;\r\nu64 x[SKEIN_512_STATE_WORDS];\r\nskein_assert_ret(ctx->h.b_cnt <= SKEIN_512_BLOCK_BYTES, SKEIN_FAIL);\r\nbyte_cnt = (ctx->h.hash_bit_len + 7) >> 3;\r\nmemset(ctx->b, 0, sizeof(ctx->b));\r\nmemcpy(x, ctx->x, sizeof(x));\r\nfor (i = 0; i*SKEIN_512_BLOCK_BYTES < byte_cnt; i++) {\r\n((u64 *)ctx->b)[0] = skein_swap64((u64) i);\r\nskein_start_new_type(ctx, OUT_FINAL);\r\nskein_512_process_block(ctx, ctx->b, 1, sizeof(u64));\r\nn = byte_cnt - i*SKEIN_512_BLOCK_BYTES;\r\nif (n >= SKEIN_512_BLOCK_BYTES)\r\nn = SKEIN_512_BLOCK_BYTES;\r\nskein_put64_lsb_first(hash_val+i*SKEIN_512_BLOCK_BYTES, ctx->x,\r\nn);\r\nmemcpy(ctx->x, x, sizeof(x));\r\n}\r\nreturn SKEIN_SUCCESS;\r\n}\r\nint skein_1024_output(struct skein_1024_ctx *ctx, u8 *hash_val)\r\n{\r\nsize_t i, n, byte_cnt;\r\nu64 x[SKEIN_1024_STATE_WORDS];\r\nskein_assert_ret(ctx->h.b_cnt <= SKEIN_1024_BLOCK_BYTES, SKEIN_FAIL);\r\nbyte_cnt = (ctx->h.hash_bit_len + 7) >> 3;\r\nmemset(ctx->b, 0, sizeof(ctx->b));\r\nmemcpy(x, ctx->x, sizeof(x));\r\nfor (i = 0; i*SKEIN_1024_BLOCK_BYTES < byte_cnt; i++) {\r\n((u64 *)ctx->b)[0] = skein_swap64((u64) i);\r\nskein_start_new_type(ctx, OUT_FINAL);\r\nskein_1024_process_block(ctx, ctx->b, 1, sizeof(u64));\r\nn = byte_cnt - i*SKEIN_1024_BLOCK_BYTES;\r\nif (n >= SKEIN_1024_BLOCK_BYTES)\r\nn = SKEIN_1024_BLOCK_BYTES;\r\nskein_put64_lsb_first(hash_val+i*SKEIN_1024_BLOCK_BYTES, ctx->x,\r\nn);\r\nmemcpy(ctx->x, x, sizeof(x));\r\n}\r\nreturn SKEIN_SUCCESS;\r\n}
