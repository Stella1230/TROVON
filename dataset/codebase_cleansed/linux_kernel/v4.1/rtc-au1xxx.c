static int au1xtoy_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nunsigned long t;\r\nt = alchemy_rdsys(AU1000_SYS_TOYREAD);\r\nrtc_time_to_tm(t, tm);\r\nreturn rtc_valid_tm(tm);\r\n}\r\nstatic int au1xtoy_rtc_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nunsigned long t;\r\nrtc_tm_to_time(tm, &t);\r\nalchemy_wrsys(t, AU1000_SYS_TOYWRITE);\r\nwhile (alchemy_rdsys(AU1000_SYS_CNTRCTRL) & SYS_CNTRL_C0S)\r\nmsleep(1);\r\nreturn 0;\r\n}\r\nstatic int au1xtoy_rtc_probe(struct platform_device *pdev)\r\n{\r\nstruct rtc_device *rtcdev;\r\nunsigned long t;\r\nint ret;\r\nt = alchemy_rdsys(AU1000_SYS_CNTRCTRL);\r\nif (!(t & CNTR_OK)) {\r\ndev_err(&pdev->dev, "counters not working; aborting.\n");\r\nret = -ENODEV;\r\ngoto out_err;\r\n}\r\nret = -ETIMEDOUT;\r\nif (alchemy_rdsys(AU1000_SYS_TOYTRIM) != 32767) {\r\nt = 0x00100000;\r\nwhile ((alchemy_rdsys(AU1000_SYS_CNTRCTRL) & SYS_CNTRL_T0S) && --t)\r\nmsleep(1);\r\nif (!t) {\r\ndev_err(&pdev->dev, "timeout waiting for access\n");\r\ngoto out_err;\r\n}\r\nalchemy_wrsys(32767, AU1000_SYS_TOYTRIM);\r\n}\r\nwhile (alchemy_rdsys(AU1000_SYS_CNTRCTRL) & SYS_CNTRL_C0S)\r\nmsleep(1);\r\nrtcdev = devm_rtc_device_register(&pdev->dev, "rtc-au1xxx",\r\n&au1xtoy_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(rtcdev)) {\r\nret = PTR_ERR(rtcdev);\r\ngoto out_err;\r\n}\r\nplatform_set_drvdata(pdev, rtcdev);\r\nreturn 0;\r\nout_err:\r\nreturn ret;\r\n}
