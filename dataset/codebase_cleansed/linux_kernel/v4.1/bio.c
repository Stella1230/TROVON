static struct kmem_cache *bio_find_or_create_slab(unsigned int extra_size)\r\n{\r\nunsigned int sz = sizeof(struct bio) + extra_size;\r\nstruct kmem_cache *slab = NULL;\r\nstruct bio_slab *bslab, *new_bio_slabs;\r\nunsigned int new_bio_slab_max;\r\nunsigned int i, entry = -1;\r\nmutex_lock(&bio_slab_lock);\r\ni = 0;\r\nwhile (i < bio_slab_nr) {\r\nbslab = &bio_slabs[i];\r\nif (!bslab->slab && entry == -1)\r\nentry = i;\r\nelse if (bslab->slab_size == sz) {\r\nslab = bslab->slab;\r\nbslab->slab_ref++;\r\nbreak;\r\n}\r\ni++;\r\n}\r\nif (slab)\r\ngoto out_unlock;\r\nif (bio_slab_nr == bio_slab_max && entry == -1) {\r\nnew_bio_slab_max = bio_slab_max << 1;\r\nnew_bio_slabs = krealloc(bio_slabs,\r\nnew_bio_slab_max * sizeof(struct bio_slab),\r\nGFP_KERNEL);\r\nif (!new_bio_slabs)\r\ngoto out_unlock;\r\nbio_slab_max = new_bio_slab_max;\r\nbio_slabs = new_bio_slabs;\r\n}\r\nif (entry == -1)\r\nentry = bio_slab_nr++;\r\nbslab = &bio_slabs[entry];\r\nsnprintf(bslab->name, sizeof(bslab->name), "bio-%d", entry);\r\nslab = kmem_cache_create(bslab->name, sz, ARCH_KMALLOC_MINALIGN,\r\nSLAB_HWCACHE_ALIGN, NULL);\r\nif (!slab)\r\ngoto out_unlock;\r\nbslab->slab = slab;\r\nbslab->slab_ref = 1;\r\nbslab->slab_size = sz;\r\nout_unlock:\r\nmutex_unlock(&bio_slab_lock);\r\nreturn slab;\r\n}\r\nstatic void bio_put_slab(struct bio_set *bs)\r\n{\r\nstruct bio_slab *bslab = NULL;\r\nunsigned int i;\r\nmutex_lock(&bio_slab_lock);\r\nfor (i = 0; i < bio_slab_nr; i++) {\r\nif (bs->bio_slab == bio_slabs[i].slab) {\r\nbslab = &bio_slabs[i];\r\nbreak;\r\n}\r\n}\r\nif (WARN(!bslab, KERN_ERR "bio: unable to find slab!\n"))\r\ngoto out;\r\nWARN_ON(!bslab->slab_ref);\r\nif (--bslab->slab_ref)\r\ngoto out;\r\nkmem_cache_destroy(bslab->slab);\r\nbslab->slab = NULL;\r\nout:\r\nmutex_unlock(&bio_slab_lock);\r\n}\r\nunsigned int bvec_nr_vecs(unsigned short idx)\r\n{\r\nreturn bvec_slabs[idx].nr_vecs;\r\n}\r\nvoid bvec_free(mempool_t *pool, struct bio_vec *bv, unsigned int idx)\r\n{\r\nBIO_BUG_ON(idx >= BIOVEC_NR_POOLS);\r\nif (idx == BIOVEC_MAX_IDX)\r\nmempool_free(bv, pool);\r\nelse {\r\nstruct biovec_slab *bvs = bvec_slabs + idx;\r\nkmem_cache_free(bvs->slab, bv);\r\n}\r\n}\r\nstruct bio_vec *bvec_alloc(gfp_t gfp_mask, int nr, unsigned long *idx,\r\nmempool_t *pool)\r\n{\r\nstruct bio_vec *bvl;\r\nswitch (nr) {\r\ncase 1:\r\n*idx = 0;\r\nbreak;\r\ncase 2 ... 4:\r\n*idx = 1;\r\nbreak;\r\ncase 5 ... 16:\r\n*idx = 2;\r\nbreak;\r\ncase 17 ... 64:\r\n*idx = 3;\r\nbreak;\r\ncase 65 ... 128:\r\n*idx = 4;\r\nbreak;\r\ncase 129 ... BIO_MAX_PAGES:\r\n*idx = 5;\r\nbreak;\r\ndefault:\r\nreturn NULL;\r\n}\r\nif (*idx == BIOVEC_MAX_IDX) {\r\nfallback:\r\nbvl = mempool_alloc(pool, gfp_mask);\r\n} else {\r\nstruct biovec_slab *bvs = bvec_slabs + *idx;\r\ngfp_t __gfp_mask = gfp_mask & ~(__GFP_WAIT | __GFP_IO);\r\n__gfp_mask |= __GFP_NOMEMALLOC | __GFP_NORETRY | __GFP_NOWARN;\r\nbvl = kmem_cache_alloc(bvs->slab, __gfp_mask);\r\nif (unlikely(!bvl && (gfp_mask & __GFP_WAIT))) {\r\n*idx = BIOVEC_MAX_IDX;\r\ngoto fallback;\r\n}\r\n}\r\nreturn bvl;\r\n}\r\nstatic void __bio_free(struct bio *bio)\r\n{\r\nbio_disassociate_task(bio);\r\nif (bio_integrity(bio))\r\nbio_integrity_free(bio);\r\n}\r\nstatic void bio_free(struct bio *bio)\r\n{\r\nstruct bio_set *bs = bio->bi_pool;\r\nvoid *p;\r\n__bio_free(bio);\r\nif (bs) {\r\nif (bio_flagged(bio, BIO_OWNS_VEC))\r\nbvec_free(bs->bvec_pool, bio->bi_io_vec, BIO_POOL_IDX(bio));\r\np = bio;\r\np -= bs->front_pad;\r\nmempool_free(p, bs->bio_pool);\r\n} else {\r\nkfree(bio);\r\n}\r\n}\r\nvoid bio_init(struct bio *bio)\r\n{\r\nmemset(bio, 0, sizeof(*bio));\r\nbio->bi_flags = 1 << BIO_UPTODATE;\r\natomic_set(&bio->bi_remaining, 1);\r\natomic_set(&bio->bi_cnt, 1);\r\n}\r\nvoid bio_reset(struct bio *bio)\r\n{\r\nunsigned long flags = bio->bi_flags & (~0UL << BIO_RESET_BITS);\r\n__bio_free(bio);\r\nmemset(bio, 0, BIO_RESET_BYTES);\r\nbio->bi_flags = flags|(1 << BIO_UPTODATE);\r\natomic_set(&bio->bi_remaining, 1);\r\n}\r\nstatic void bio_chain_endio(struct bio *bio, int error)\r\n{\r\nbio_endio(bio->bi_private, error);\r\nbio_put(bio);\r\n}\r\nvoid bio_chain(struct bio *bio, struct bio *parent)\r\n{\r\nBUG_ON(bio->bi_private || bio->bi_end_io);\r\nbio->bi_private = parent;\r\nbio->bi_end_io = bio_chain_endio;\r\natomic_inc(&parent->bi_remaining);\r\n}\r\nstatic void bio_alloc_rescue(struct work_struct *work)\r\n{\r\nstruct bio_set *bs = container_of(work, struct bio_set, rescue_work);\r\nstruct bio *bio;\r\nwhile (1) {\r\nspin_lock(&bs->rescue_lock);\r\nbio = bio_list_pop(&bs->rescue_list);\r\nspin_unlock(&bs->rescue_lock);\r\nif (!bio)\r\nbreak;\r\ngeneric_make_request(bio);\r\n}\r\n}\r\nstatic void punt_bios_to_rescuer(struct bio_set *bs)\r\n{\r\nstruct bio_list punt, nopunt;\r\nstruct bio *bio;\r\nbio_list_init(&punt);\r\nbio_list_init(&nopunt);\r\nwhile ((bio = bio_list_pop(current->bio_list)))\r\nbio_list_add(bio->bi_pool == bs ? &punt : &nopunt, bio);\r\n*current->bio_list = nopunt;\r\nspin_lock(&bs->rescue_lock);\r\nbio_list_merge(&bs->rescue_list, &punt);\r\nspin_unlock(&bs->rescue_lock);\r\nqueue_work(bs->rescue_workqueue, &bs->rescue_work);\r\n}\r\nstruct bio *bio_alloc_bioset(gfp_t gfp_mask, int nr_iovecs, struct bio_set *bs)\r\n{\r\ngfp_t saved_gfp = gfp_mask;\r\nunsigned front_pad;\r\nunsigned inline_vecs;\r\nunsigned long idx = BIO_POOL_NONE;\r\nstruct bio_vec *bvl = NULL;\r\nstruct bio *bio;\r\nvoid *p;\r\nif (!bs) {\r\nif (nr_iovecs > UIO_MAXIOV)\r\nreturn NULL;\r\np = kmalloc(sizeof(struct bio) +\r\nnr_iovecs * sizeof(struct bio_vec),\r\ngfp_mask);\r\nfront_pad = 0;\r\ninline_vecs = nr_iovecs;\r\n} else {\r\nif (WARN_ON_ONCE(!bs->bvec_pool && nr_iovecs > 0))\r\nreturn NULL;\r\nif (current->bio_list && !bio_list_empty(current->bio_list))\r\ngfp_mask &= ~__GFP_WAIT;\r\np = mempool_alloc(bs->bio_pool, gfp_mask);\r\nif (!p && gfp_mask != saved_gfp) {\r\npunt_bios_to_rescuer(bs);\r\ngfp_mask = saved_gfp;\r\np = mempool_alloc(bs->bio_pool, gfp_mask);\r\n}\r\nfront_pad = bs->front_pad;\r\ninline_vecs = BIO_INLINE_VECS;\r\n}\r\nif (unlikely(!p))\r\nreturn NULL;\r\nbio = p + front_pad;\r\nbio_init(bio);\r\nif (nr_iovecs > inline_vecs) {\r\nbvl = bvec_alloc(gfp_mask, nr_iovecs, &idx, bs->bvec_pool);\r\nif (!bvl && gfp_mask != saved_gfp) {\r\npunt_bios_to_rescuer(bs);\r\ngfp_mask = saved_gfp;\r\nbvl = bvec_alloc(gfp_mask, nr_iovecs, &idx, bs->bvec_pool);\r\n}\r\nif (unlikely(!bvl))\r\ngoto err_free;\r\nbio->bi_flags |= 1 << BIO_OWNS_VEC;\r\n} else if (nr_iovecs) {\r\nbvl = bio->bi_inline_vecs;\r\n}\r\nbio->bi_pool = bs;\r\nbio->bi_flags |= idx << BIO_POOL_OFFSET;\r\nbio->bi_max_vecs = nr_iovecs;\r\nbio->bi_io_vec = bvl;\r\nreturn bio;\r\nerr_free:\r\nmempool_free(p, bs->bio_pool);\r\nreturn NULL;\r\n}\r\nvoid zero_fill_bio(struct bio *bio)\r\n{\r\nunsigned long flags;\r\nstruct bio_vec bv;\r\nstruct bvec_iter iter;\r\nbio_for_each_segment(bv, bio, iter) {\r\nchar *data = bvec_kmap_irq(&bv, &flags);\r\nmemset(data, 0, bv.bv_len);\r\nflush_dcache_page(bv.bv_page);\r\nbvec_kunmap_irq(data, &flags);\r\n}\r\n}\r\nvoid bio_put(struct bio *bio)\r\n{\r\nBIO_BUG_ON(!atomic_read(&bio->bi_cnt));\r\nif (atomic_dec_and_test(&bio->bi_cnt))\r\nbio_free(bio);\r\n}\r\ninline int bio_phys_segments(struct request_queue *q, struct bio *bio)\r\n{\r\nif (unlikely(!bio_flagged(bio, BIO_SEG_VALID)))\r\nblk_recount_segments(q, bio);\r\nreturn bio->bi_phys_segments;\r\n}\r\nvoid __bio_clone_fast(struct bio *bio, struct bio *bio_src)\r\n{\r\nBUG_ON(bio->bi_pool && BIO_POOL_IDX(bio) != BIO_POOL_NONE);\r\nbio->bi_bdev = bio_src->bi_bdev;\r\nbio->bi_flags |= 1 << BIO_CLONED;\r\nbio->bi_rw = bio_src->bi_rw;\r\nbio->bi_iter = bio_src->bi_iter;\r\nbio->bi_io_vec = bio_src->bi_io_vec;\r\n}\r\nstruct bio *bio_clone_fast(struct bio *bio, gfp_t gfp_mask, struct bio_set *bs)\r\n{\r\nstruct bio *b;\r\nb = bio_alloc_bioset(gfp_mask, 0, bs);\r\nif (!b)\r\nreturn NULL;\r\n__bio_clone_fast(b, bio);\r\nif (bio_integrity(bio)) {\r\nint ret;\r\nret = bio_integrity_clone(b, bio, gfp_mask);\r\nif (ret < 0) {\r\nbio_put(b);\r\nreturn NULL;\r\n}\r\n}\r\nreturn b;\r\n}\r\nstruct bio *bio_clone_bioset(struct bio *bio_src, gfp_t gfp_mask,\r\nstruct bio_set *bs)\r\n{\r\nstruct bvec_iter iter;\r\nstruct bio_vec bv;\r\nstruct bio *bio;\r\nbio = bio_alloc_bioset(gfp_mask, bio_segments(bio_src), bs);\r\nif (!bio)\r\nreturn NULL;\r\nbio->bi_bdev = bio_src->bi_bdev;\r\nbio->bi_rw = bio_src->bi_rw;\r\nbio->bi_iter.bi_sector = bio_src->bi_iter.bi_sector;\r\nbio->bi_iter.bi_size = bio_src->bi_iter.bi_size;\r\nif (bio->bi_rw & REQ_DISCARD)\r\ngoto integrity_clone;\r\nif (bio->bi_rw & REQ_WRITE_SAME) {\r\nbio->bi_io_vec[bio->bi_vcnt++] = bio_src->bi_io_vec[0];\r\ngoto integrity_clone;\r\n}\r\nbio_for_each_segment(bv, bio_src, iter)\r\nbio->bi_io_vec[bio->bi_vcnt++] = bv;\r\nintegrity_clone:\r\nif (bio_integrity(bio_src)) {\r\nint ret;\r\nret = bio_integrity_clone(bio, bio_src, gfp_mask);\r\nif (ret < 0) {\r\nbio_put(bio);\r\nreturn NULL;\r\n}\r\n}\r\nreturn bio;\r\n}\r\nint bio_get_nr_vecs(struct block_device *bdev)\r\n{\r\nstruct request_queue *q = bdev_get_queue(bdev);\r\nint nr_pages;\r\nnr_pages = min_t(unsigned,\r\nqueue_max_segments(q),\r\nqueue_max_sectors(q) / (PAGE_SIZE >> 9) + 1);\r\nreturn min_t(unsigned, nr_pages, BIO_MAX_PAGES);\r\n}\r\nstatic int __bio_add_page(struct request_queue *q, struct bio *bio, struct page\r\n*page, unsigned int len, unsigned int offset,\r\nunsigned int max_sectors)\r\n{\r\nint retried_segments = 0;\r\nstruct bio_vec *bvec;\r\nif (unlikely(bio_flagged(bio, BIO_CLONED)))\r\nreturn 0;\r\nif (((bio->bi_iter.bi_size + len) >> 9) > max_sectors)\r\nreturn 0;\r\nif (bio->bi_vcnt > 0) {\r\nstruct bio_vec *prev = &bio->bi_io_vec[bio->bi_vcnt - 1];\r\nif (page == prev->bv_page &&\r\noffset == prev->bv_offset + prev->bv_len) {\r\nunsigned int prev_bv_len = prev->bv_len;\r\nprev->bv_len += len;\r\nif (q->merge_bvec_fn) {\r\nstruct bvec_merge_data bvm = {\r\n.bi_bdev = bio->bi_bdev,\r\n.bi_sector = bio->bi_iter.bi_sector,\r\n.bi_size = bio->bi_iter.bi_size -\r\nprev_bv_len,\r\n.bi_rw = bio->bi_rw,\r\n};\r\nif (q->merge_bvec_fn(q, &bvm, prev) < prev->bv_len) {\r\nprev->bv_len -= len;\r\nreturn 0;\r\n}\r\n}\r\nbio->bi_iter.bi_size += len;\r\ngoto done;\r\n}\r\nif (q->queue_flags & (1 << QUEUE_FLAG_SG_GAPS) &&\r\nbvec_gap_to_prev(prev, offset))\r\nreturn 0;\r\n}\r\nif (bio->bi_vcnt >= bio->bi_max_vecs)\r\nreturn 0;\r\nbvec = &bio->bi_io_vec[bio->bi_vcnt];\r\nbvec->bv_page = page;\r\nbvec->bv_len = len;\r\nbvec->bv_offset = offset;\r\nbio->bi_vcnt++;\r\nbio->bi_phys_segments++;\r\nbio->bi_iter.bi_size += len;\r\nwhile (bio->bi_phys_segments > queue_max_segments(q)) {\r\nif (retried_segments)\r\ngoto failed;\r\nretried_segments = 1;\r\nblk_recount_segments(q, bio);\r\n}\r\nif (q->merge_bvec_fn) {\r\nstruct bvec_merge_data bvm = {\r\n.bi_bdev = bio->bi_bdev,\r\n.bi_sector = bio->bi_iter.bi_sector,\r\n.bi_size = bio->bi_iter.bi_size - len,\r\n.bi_rw = bio->bi_rw,\r\n};\r\nif (q->merge_bvec_fn(q, &bvm, bvec) < bvec->bv_len)\r\ngoto failed;\r\n}\r\nif (bio->bi_vcnt > 1 && (BIOVEC_PHYS_MERGEABLE(bvec-1, bvec)))\r\nbio->bi_flags &= ~(1 << BIO_SEG_VALID);\r\ndone:\r\nreturn len;\r\nfailed:\r\nbvec->bv_page = NULL;\r\nbvec->bv_len = 0;\r\nbvec->bv_offset = 0;\r\nbio->bi_vcnt--;\r\nbio->bi_iter.bi_size -= len;\r\nblk_recount_segments(q, bio);\r\nreturn 0;\r\n}\r\nint bio_add_pc_page(struct request_queue *q, struct bio *bio, struct page *page,\r\nunsigned int len, unsigned int offset)\r\n{\r\nreturn __bio_add_page(q, bio, page, len, offset,\r\nqueue_max_hw_sectors(q));\r\n}\r\nint bio_add_page(struct bio *bio, struct page *page, unsigned int len,\r\nunsigned int offset)\r\n{\r\nstruct request_queue *q = bdev_get_queue(bio->bi_bdev);\r\nunsigned int max_sectors;\r\nmax_sectors = blk_max_size_offset(q, bio->bi_iter.bi_sector);\r\nif ((max_sectors < (len >> 9)) && !bio->bi_iter.bi_size)\r\nmax_sectors = len >> 9;\r\nreturn __bio_add_page(q, bio, page, len, offset, max_sectors);\r\n}\r\nstatic void submit_bio_wait_endio(struct bio *bio, int error)\r\n{\r\nstruct submit_bio_ret *ret = bio->bi_private;\r\nret->error = error;\r\ncomplete(&ret->event);\r\n}\r\nint submit_bio_wait(int rw, struct bio *bio)\r\n{\r\nstruct submit_bio_ret ret;\r\nrw |= REQ_SYNC;\r\ninit_completion(&ret.event);\r\nbio->bi_private = &ret;\r\nbio->bi_end_io = submit_bio_wait_endio;\r\nsubmit_bio(rw, bio);\r\nwait_for_completion(&ret.event);\r\nreturn ret.error;\r\n}\r\nvoid bio_advance(struct bio *bio, unsigned bytes)\r\n{\r\nif (bio_integrity(bio))\r\nbio_integrity_advance(bio, bytes);\r\nbio_advance_iter(bio, &bio->bi_iter, bytes);\r\n}\r\nint bio_alloc_pages(struct bio *bio, gfp_t gfp_mask)\r\n{\r\nint i;\r\nstruct bio_vec *bv;\r\nbio_for_each_segment_all(bv, bio, i) {\r\nbv->bv_page = alloc_page(gfp_mask);\r\nif (!bv->bv_page) {\r\nwhile (--bv >= bio->bi_io_vec)\r\n__free_page(bv->bv_page);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid bio_copy_data(struct bio *dst, struct bio *src)\r\n{\r\nstruct bvec_iter src_iter, dst_iter;\r\nstruct bio_vec src_bv, dst_bv;\r\nvoid *src_p, *dst_p;\r\nunsigned bytes;\r\nsrc_iter = src->bi_iter;\r\ndst_iter = dst->bi_iter;\r\nwhile (1) {\r\nif (!src_iter.bi_size) {\r\nsrc = src->bi_next;\r\nif (!src)\r\nbreak;\r\nsrc_iter = src->bi_iter;\r\n}\r\nif (!dst_iter.bi_size) {\r\ndst = dst->bi_next;\r\nif (!dst)\r\nbreak;\r\ndst_iter = dst->bi_iter;\r\n}\r\nsrc_bv = bio_iter_iovec(src, src_iter);\r\ndst_bv = bio_iter_iovec(dst, dst_iter);\r\nbytes = min(src_bv.bv_len, dst_bv.bv_len);\r\nsrc_p = kmap_atomic(src_bv.bv_page);\r\ndst_p = kmap_atomic(dst_bv.bv_page);\r\nmemcpy(dst_p + dst_bv.bv_offset,\r\nsrc_p + src_bv.bv_offset,\r\nbytes);\r\nkunmap_atomic(dst_p);\r\nkunmap_atomic(src_p);\r\nbio_advance_iter(src, &src_iter, bytes);\r\nbio_advance_iter(dst, &dst_iter, bytes);\r\n}\r\n}\r\nstatic struct bio_map_data *bio_alloc_map_data(unsigned int iov_count,\r\ngfp_t gfp_mask)\r\n{\r\nif (iov_count > UIO_MAXIOV)\r\nreturn NULL;\r\nreturn kmalloc(sizeof(struct bio_map_data) +\r\nsizeof(struct iovec) * iov_count, gfp_mask);\r\n}\r\nstatic int bio_copy_from_iter(struct bio *bio, struct iov_iter iter)\r\n{\r\nint i;\r\nstruct bio_vec *bvec;\r\nbio_for_each_segment_all(bvec, bio, i) {\r\nssize_t ret;\r\nret = copy_page_from_iter(bvec->bv_page,\r\nbvec->bv_offset,\r\nbvec->bv_len,\r\n&iter);\r\nif (!iov_iter_count(&iter))\r\nbreak;\r\nif (ret < bvec->bv_len)\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bio_copy_to_iter(struct bio *bio, struct iov_iter iter)\r\n{\r\nint i;\r\nstruct bio_vec *bvec;\r\nbio_for_each_segment_all(bvec, bio, i) {\r\nssize_t ret;\r\nret = copy_page_to_iter(bvec->bv_page,\r\nbvec->bv_offset,\r\nbvec->bv_len,\r\n&iter);\r\nif (!iov_iter_count(&iter))\r\nbreak;\r\nif (ret < bvec->bv_len)\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic void bio_free_pages(struct bio *bio)\r\n{\r\nstruct bio_vec *bvec;\r\nint i;\r\nbio_for_each_segment_all(bvec, bio, i)\r\n__free_page(bvec->bv_page);\r\n}\r\nint bio_uncopy_user(struct bio *bio)\r\n{\r\nstruct bio_map_data *bmd = bio->bi_private;\r\nint ret = 0;\r\nif (!bio_flagged(bio, BIO_NULL_MAPPED)) {\r\nif (current->mm && bio_data_dir(bio) == READ)\r\nret = bio_copy_to_iter(bio, bmd->iter);\r\nif (bmd->is_our_pages)\r\nbio_free_pages(bio);\r\n}\r\nkfree(bmd);\r\nbio_put(bio);\r\nreturn ret;\r\n}\r\nstruct bio *bio_copy_user_iov(struct request_queue *q,\r\nstruct rq_map_data *map_data,\r\nconst struct iov_iter *iter,\r\ngfp_t gfp_mask)\r\n{\r\nstruct bio_map_data *bmd;\r\nstruct page *page;\r\nstruct bio *bio;\r\nint i, ret;\r\nint nr_pages = 0;\r\nunsigned int len = iter->count;\r\nunsigned int offset = map_data ? map_data->offset & ~PAGE_MASK : 0;\r\nfor (i = 0; i < iter->nr_segs; i++) {\r\nunsigned long uaddr;\r\nunsigned long end;\r\nunsigned long start;\r\nuaddr = (unsigned long) iter->iov[i].iov_base;\r\nend = (uaddr + iter->iov[i].iov_len + PAGE_SIZE - 1)\r\n>> PAGE_SHIFT;\r\nstart = uaddr >> PAGE_SHIFT;\r\nif (end < start)\r\nreturn ERR_PTR(-EINVAL);\r\nnr_pages += end - start;\r\n}\r\nif (offset)\r\nnr_pages++;\r\nbmd = bio_alloc_map_data(iter->nr_segs, gfp_mask);\r\nif (!bmd)\r\nreturn ERR_PTR(-ENOMEM);\r\nbmd->is_our_pages = map_data ? 0 : 1;\r\nmemcpy(bmd->iov, iter->iov, sizeof(struct iovec) * iter->nr_segs);\r\niov_iter_init(&bmd->iter, iter->type, bmd->iov,\r\niter->nr_segs, iter->count);\r\nret = -ENOMEM;\r\nbio = bio_kmalloc(gfp_mask, nr_pages);\r\nif (!bio)\r\ngoto out_bmd;\r\nif (iter->type & WRITE)\r\nbio->bi_rw |= REQ_WRITE;\r\nret = 0;\r\nif (map_data) {\r\nnr_pages = 1 << map_data->page_order;\r\ni = map_data->offset / PAGE_SIZE;\r\n}\r\nwhile (len) {\r\nunsigned int bytes = PAGE_SIZE;\r\nbytes -= offset;\r\nif (bytes > len)\r\nbytes = len;\r\nif (map_data) {\r\nif (i == map_data->nr_entries * nr_pages) {\r\nret = -ENOMEM;\r\nbreak;\r\n}\r\npage = map_data->pages[i / nr_pages];\r\npage += (i % nr_pages);\r\ni++;\r\n} else {\r\npage = alloc_page(q->bounce_gfp | gfp_mask);\r\nif (!page) {\r\nret = -ENOMEM;\r\nbreak;\r\n}\r\n}\r\nif (bio_add_pc_page(q, bio, page, bytes, offset) < bytes)\r\nbreak;\r\nlen -= bytes;\r\noffset = 0;\r\n}\r\nif (ret)\r\ngoto cleanup;\r\nif (((iter->type & WRITE) && (!map_data || !map_data->null_mapped)) ||\r\n(map_data && map_data->from_user)) {\r\nret = bio_copy_from_iter(bio, *iter);\r\nif (ret)\r\ngoto cleanup;\r\n}\r\nbio->bi_private = bmd;\r\nreturn bio;\r\ncleanup:\r\nif (!map_data)\r\nbio_free_pages(bio);\r\nbio_put(bio);\r\nout_bmd:\r\nkfree(bmd);\r\nreturn ERR_PTR(ret);\r\n}\r\nstruct bio *bio_map_user_iov(struct request_queue *q,\r\nconst struct iov_iter *iter,\r\ngfp_t gfp_mask)\r\n{\r\nint j;\r\nint nr_pages = 0;\r\nstruct page **pages;\r\nstruct bio *bio;\r\nint cur_page = 0;\r\nint ret, offset;\r\nstruct iov_iter i;\r\nstruct iovec iov;\r\niov_for_each(iov, i, *iter) {\r\nunsigned long uaddr = (unsigned long) iov.iov_base;\r\nunsigned long len = iov.iov_len;\r\nunsigned long end = (uaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\r\nunsigned long start = uaddr >> PAGE_SHIFT;\r\nif (end < start)\r\nreturn ERR_PTR(-EINVAL);\r\nnr_pages += end - start;\r\nif (uaddr & queue_dma_alignment(q))\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (!nr_pages)\r\nreturn ERR_PTR(-EINVAL);\r\nbio = bio_kmalloc(gfp_mask, nr_pages);\r\nif (!bio)\r\nreturn ERR_PTR(-ENOMEM);\r\nret = -ENOMEM;\r\npages = kcalloc(nr_pages, sizeof(struct page *), gfp_mask);\r\nif (!pages)\r\ngoto out;\r\niov_for_each(iov, i, *iter) {\r\nunsigned long uaddr = (unsigned long) iov.iov_base;\r\nunsigned long len = iov.iov_len;\r\nunsigned long end = (uaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\r\nunsigned long start = uaddr >> PAGE_SHIFT;\r\nconst int local_nr_pages = end - start;\r\nconst int page_limit = cur_page + local_nr_pages;\r\nret = get_user_pages_fast(uaddr, local_nr_pages,\r\n(iter->type & WRITE) != WRITE,\r\n&pages[cur_page]);\r\nif (ret < local_nr_pages) {\r\nret = -EFAULT;\r\ngoto out_unmap;\r\n}\r\noffset = uaddr & ~PAGE_MASK;\r\nfor (j = cur_page; j < page_limit; j++) {\r\nunsigned int bytes = PAGE_SIZE - offset;\r\nif (len <= 0)\r\nbreak;\r\nif (bytes > len)\r\nbytes = len;\r\nif (bio_add_pc_page(q, bio, pages[j], bytes, offset) <\r\nbytes)\r\nbreak;\r\nlen -= bytes;\r\noffset = 0;\r\n}\r\ncur_page = j;\r\nwhile (j < page_limit)\r\npage_cache_release(pages[j++]);\r\n}\r\nkfree(pages);\r\nif (iter->type & WRITE)\r\nbio->bi_rw |= REQ_WRITE;\r\nbio->bi_flags |= (1 << BIO_USER_MAPPED);\r\nbio_get(bio);\r\nreturn bio;\r\nout_unmap:\r\nfor (j = 0; j < nr_pages; j++) {\r\nif (!pages[j])\r\nbreak;\r\npage_cache_release(pages[j]);\r\n}\r\nout:\r\nkfree(pages);\r\nbio_put(bio);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic void __bio_unmap_user(struct bio *bio)\r\n{\r\nstruct bio_vec *bvec;\r\nint i;\r\nbio_for_each_segment_all(bvec, bio, i) {\r\nif (bio_data_dir(bio) == READ)\r\nset_page_dirty_lock(bvec->bv_page);\r\npage_cache_release(bvec->bv_page);\r\n}\r\nbio_put(bio);\r\n}\r\nvoid bio_unmap_user(struct bio *bio)\r\n{\r\n__bio_unmap_user(bio);\r\nbio_put(bio);\r\n}\r\nstatic void bio_map_kern_endio(struct bio *bio, int err)\r\n{\r\nbio_put(bio);\r\n}\r\nstruct bio *bio_map_kern(struct request_queue *q, void *data, unsigned int len,\r\ngfp_t gfp_mask)\r\n{\r\nunsigned long kaddr = (unsigned long)data;\r\nunsigned long end = (kaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\r\nunsigned long start = kaddr >> PAGE_SHIFT;\r\nconst int nr_pages = end - start;\r\nint offset, i;\r\nstruct bio *bio;\r\nbio = bio_kmalloc(gfp_mask, nr_pages);\r\nif (!bio)\r\nreturn ERR_PTR(-ENOMEM);\r\noffset = offset_in_page(kaddr);\r\nfor (i = 0; i < nr_pages; i++) {\r\nunsigned int bytes = PAGE_SIZE - offset;\r\nif (len <= 0)\r\nbreak;\r\nif (bytes > len)\r\nbytes = len;\r\nif (bio_add_pc_page(q, bio, virt_to_page(data), bytes,\r\noffset) < bytes) {\r\nbio_put(bio);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\ndata += bytes;\r\nlen -= bytes;\r\noffset = 0;\r\n}\r\nbio->bi_end_io = bio_map_kern_endio;\r\nreturn bio;\r\n}\r\nstatic void bio_copy_kern_endio(struct bio *bio, int err)\r\n{\r\nbio_free_pages(bio);\r\nbio_put(bio);\r\n}\r\nstatic void bio_copy_kern_endio_read(struct bio *bio, int err)\r\n{\r\nchar *p = bio->bi_private;\r\nstruct bio_vec *bvec;\r\nint i;\r\nbio_for_each_segment_all(bvec, bio, i) {\r\nmemcpy(p, page_address(bvec->bv_page), bvec->bv_len);\r\np += bvec->bv_len;\r\n}\r\nbio_copy_kern_endio(bio, err);\r\n}\r\nstruct bio *bio_copy_kern(struct request_queue *q, void *data, unsigned int len,\r\ngfp_t gfp_mask, int reading)\r\n{\r\nunsigned long kaddr = (unsigned long)data;\r\nunsigned long end = (kaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\r\nunsigned long start = kaddr >> PAGE_SHIFT;\r\nstruct bio *bio;\r\nvoid *p = data;\r\nint nr_pages = 0;\r\nif (end < start)\r\nreturn ERR_PTR(-EINVAL);\r\nnr_pages = end - start;\r\nbio = bio_kmalloc(gfp_mask, nr_pages);\r\nif (!bio)\r\nreturn ERR_PTR(-ENOMEM);\r\nwhile (len) {\r\nstruct page *page;\r\nunsigned int bytes = PAGE_SIZE;\r\nif (bytes > len)\r\nbytes = len;\r\npage = alloc_page(q->bounce_gfp | gfp_mask);\r\nif (!page)\r\ngoto cleanup;\r\nif (!reading)\r\nmemcpy(page_address(page), p, bytes);\r\nif (bio_add_pc_page(q, bio, page, bytes, 0) < bytes)\r\nbreak;\r\nlen -= bytes;\r\np += bytes;\r\n}\r\nif (reading) {\r\nbio->bi_end_io = bio_copy_kern_endio_read;\r\nbio->bi_private = data;\r\n} else {\r\nbio->bi_end_io = bio_copy_kern_endio;\r\nbio->bi_rw |= REQ_WRITE;\r\n}\r\nreturn bio;\r\ncleanup:\r\nbio_free_pages(bio);\r\nbio_put(bio);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nvoid bio_set_pages_dirty(struct bio *bio)\r\n{\r\nstruct bio_vec *bvec;\r\nint i;\r\nbio_for_each_segment_all(bvec, bio, i) {\r\nstruct page *page = bvec->bv_page;\r\nif (page && !PageCompound(page))\r\nset_page_dirty_lock(page);\r\n}\r\n}\r\nstatic void bio_release_pages(struct bio *bio)\r\n{\r\nstruct bio_vec *bvec;\r\nint i;\r\nbio_for_each_segment_all(bvec, bio, i) {\r\nstruct page *page = bvec->bv_page;\r\nif (page)\r\nput_page(page);\r\n}\r\n}\r\nstatic void bio_dirty_fn(struct work_struct *work)\r\n{\r\nunsigned long flags;\r\nstruct bio *bio;\r\nspin_lock_irqsave(&bio_dirty_lock, flags);\r\nbio = bio_dirty_list;\r\nbio_dirty_list = NULL;\r\nspin_unlock_irqrestore(&bio_dirty_lock, flags);\r\nwhile (bio) {\r\nstruct bio *next = bio->bi_private;\r\nbio_set_pages_dirty(bio);\r\nbio_release_pages(bio);\r\nbio_put(bio);\r\nbio = next;\r\n}\r\n}\r\nvoid bio_check_pages_dirty(struct bio *bio)\r\n{\r\nstruct bio_vec *bvec;\r\nint nr_clean_pages = 0;\r\nint i;\r\nbio_for_each_segment_all(bvec, bio, i) {\r\nstruct page *page = bvec->bv_page;\r\nif (PageDirty(page) || PageCompound(page)) {\r\npage_cache_release(page);\r\nbvec->bv_page = NULL;\r\n} else {\r\nnr_clean_pages++;\r\n}\r\n}\r\nif (nr_clean_pages) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&bio_dirty_lock, flags);\r\nbio->bi_private = bio_dirty_list;\r\nbio_dirty_list = bio;\r\nspin_unlock_irqrestore(&bio_dirty_lock, flags);\r\nschedule_work(&bio_dirty_work);\r\n} else {\r\nbio_put(bio);\r\n}\r\n}\r\nvoid generic_start_io_acct(int rw, unsigned long sectors,\r\nstruct hd_struct *part)\r\n{\r\nint cpu = part_stat_lock();\r\npart_round_stats(cpu, part);\r\npart_stat_inc(cpu, part, ios[rw]);\r\npart_stat_add(cpu, part, sectors[rw], sectors);\r\npart_inc_in_flight(part, rw);\r\npart_stat_unlock();\r\n}\r\nvoid generic_end_io_acct(int rw, struct hd_struct *part,\r\nunsigned long start_time)\r\n{\r\nunsigned long duration = jiffies - start_time;\r\nint cpu = part_stat_lock();\r\npart_stat_add(cpu, part, ticks[rw], duration);\r\npart_round_stats(cpu, part);\r\npart_dec_in_flight(part, rw);\r\npart_stat_unlock();\r\n}\r\nvoid bio_flush_dcache_pages(struct bio *bi)\r\n{\r\nstruct bio_vec bvec;\r\nstruct bvec_iter iter;\r\nbio_for_each_segment(bvec, bi, iter)\r\nflush_dcache_page(bvec.bv_page);\r\n}\r\nvoid bio_endio(struct bio *bio, int error)\r\n{\r\nwhile (bio) {\r\nBUG_ON(atomic_read(&bio->bi_remaining) <= 0);\r\nif (error)\r\nclear_bit(BIO_UPTODATE, &bio->bi_flags);\r\nelse if (!test_bit(BIO_UPTODATE, &bio->bi_flags))\r\nerror = -EIO;\r\nif (!atomic_dec_and_test(&bio->bi_remaining))\r\nreturn;\r\nif (bio->bi_end_io == bio_chain_endio) {\r\nstruct bio *parent = bio->bi_private;\r\nbio_put(bio);\r\nbio = parent;\r\n} else {\r\nif (bio->bi_end_io)\r\nbio->bi_end_io(bio, error);\r\nbio = NULL;\r\n}\r\n}\r\n}\r\nvoid bio_endio_nodec(struct bio *bio, int error)\r\n{\r\natomic_inc(&bio->bi_remaining);\r\nbio_endio(bio, error);\r\n}\r\nstruct bio *bio_split(struct bio *bio, int sectors,\r\ngfp_t gfp, struct bio_set *bs)\r\n{\r\nstruct bio *split = NULL;\r\nBUG_ON(sectors <= 0);\r\nBUG_ON(sectors >= bio_sectors(bio));\r\nsplit = bio_clone_fast(bio, gfp, bs);\r\nif (!split)\r\nreturn NULL;\r\nsplit->bi_iter.bi_size = sectors << 9;\r\nif (bio_integrity(split))\r\nbio_integrity_trim(split, 0, sectors);\r\nbio_advance(bio, split->bi_iter.bi_size);\r\nreturn split;\r\n}\r\nvoid bio_trim(struct bio *bio, int offset, int size)\r\n{\r\nsize <<= 9;\r\nif (offset == 0 && size == bio->bi_iter.bi_size)\r\nreturn;\r\nclear_bit(BIO_SEG_VALID, &bio->bi_flags);\r\nbio_advance(bio, offset << 9);\r\nbio->bi_iter.bi_size = size;\r\n}\r\nmempool_t *biovec_create_pool(int pool_entries)\r\n{\r\nstruct biovec_slab *bp = bvec_slabs + BIOVEC_MAX_IDX;\r\nreturn mempool_create_slab_pool(pool_entries, bp->slab);\r\n}\r\nvoid bioset_free(struct bio_set *bs)\r\n{\r\nif (bs->rescue_workqueue)\r\ndestroy_workqueue(bs->rescue_workqueue);\r\nif (bs->bio_pool)\r\nmempool_destroy(bs->bio_pool);\r\nif (bs->bvec_pool)\r\nmempool_destroy(bs->bvec_pool);\r\nbioset_integrity_free(bs);\r\nbio_put_slab(bs);\r\nkfree(bs);\r\n}\r\nstatic struct bio_set *__bioset_create(unsigned int pool_size,\r\nunsigned int front_pad,\r\nbool create_bvec_pool)\r\n{\r\nunsigned int back_pad = BIO_INLINE_VECS * sizeof(struct bio_vec);\r\nstruct bio_set *bs;\r\nbs = kzalloc(sizeof(*bs), GFP_KERNEL);\r\nif (!bs)\r\nreturn NULL;\r\nbs->front_pad = front_pad;\r\nspin_lock_init(&bs->rescue_lock);\r\nbio_list_init(&bs->rescue_list);\r\nINIT_WORK(&bs->rescue_work, bio_alloc_rescue);\r\nbs->bio_slab = bio_find_or_create_slab(front_pad + back_pad);\r\nif (!bs->bio_slab) {\r\nkfree(bs);\r\nreturn NULL;\r\n}\r\nbs->bio_pool = mempool_create_slab_pool(pool_size, bs->bio_slab);\r\nif (!bs->bio_pool)\r\ngoto bad;\r\nif (create_bvec_pool) {\r\nbs->bvec_pool = biovec_create_pool(pool_size);\r\nif (!bs->bvec_pool)\r\ngoto bad;\r\n}\r\nbs->rescue_workqueue = alloc_workqueue("bioset", WQ_MEM_RECLAIM, 0);\r\nif (!bs->rescue_workqueue)\r\ngoto bad;\r\nreturn bs;\r\nbad:\r\nbioset_free(bs);\r\nreturn NULL;\r\n}\r\nstruct bio_set *bioset_create(unsigned int pool_size, unsigned int front_pad)\r\n{\r\nreturn __bioset_create(pool_size, front_pad, true);\r\n}\r\nstruct bio_set *bioset_create_nobvec(unsigned int pool_size, unsigned int front_pad)\r\n{\r\nreturn __bioset_create(pool_size, front_pad, false);\r\n}\r\nint bio_associate_current(struct bio *bio)\r\n{\r\nstruct io_context *ioc;\r\nstruct cgroup_subsys_state *css;\r\nif (bio->bi_ioc)\r\nreturn -EBUSY;\r\nioc = current->io_context;\r\nif (!ioc)\r\nreturn -ENOENT;\r\nget_io_context_active(ioc);\r\nbio->bi_ioc = ioc;\r\nrcu_read_lock();\r\ncss = task_css(current, blkio_cgrp_id);\r\nif (css && css_tryget_online(css))\r\nbio->bi_css = css;\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nvoid bio_disassociate_task(struct bio *bio)\r\n{\r\nif (bio->bi_ioc) {\r\nput_io_context(bio->bi_ioc);\r\nbio->bi_ioc = NULL;\r\n}\r\nif (bio->bi_css) {\r\ncss_put(bio->bi_css);\r\nbio->bi_css = NULL;\r\n}\r\n}\r\nstatic void __init biovec_init_slabs(void)\r\n{\r\nint i;\r\nfor (i = 0; i < BIOVEC_NR_POOLS; i++) {\r\nint size;\r\nstruct biovec_slab *bvs = bvec_slabs + i;\r\nif (bvs->nr_vecs <= BIO_INLINE_VECS) {\r\nbvs->slab = NULL;\r\ncontinue;\r\n}\r\nsize = bvs->nr_vecs * sizeof(struct bio_vec);\r\nbvs->slab = kmem_cache_create(bvs->name, size, 0,\r\nSLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);\r\n}\r\n}\r\nstatic int __init init_bio(void)\r\n{\r\nbio_slab_max = 2;\r\nbio_slab_nr = 0;\r\nbio_slabs = kzalloc(bio_slab_max * sizeof(struct bio_slab), GFP_KERNEL);\r\nif (!bio_slabs)\r\npanic("bio: can't allocate bios\n");\r\nbio_integrity_init();\r\nbiovec_init_slabs();\r\nfs_bio_set = bioset_create(BIO_POOL_SIZE, 0);\r\nif (!fs_bio_set)\r\npanic("bio: can't allocate bios\n");\r\nif (bioset_integrity_create(fs_bio_set, BIO_POOL_SIZE))\r\npanic("bio: can't create integrity pool\n");\r\nreturn 0;\r\n}
