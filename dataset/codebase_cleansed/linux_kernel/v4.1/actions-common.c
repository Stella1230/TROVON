static void __kprobes simulate_ldm1stm1(probes_opcode_t insn,\r\nstruct arch_probes_insn *asi,\r\nstruct pt_regs *regs)\r\n{\r\nint rn = (insn >> 16) & 0xf;\r\nint lbit = insn & (1 << 20);\r\nint wbit = insn & (1 << 21);\r\nint ubit = insn & (1 << 23);\r\nint pbit = insn & (1 << 24);\r\nlong *addr = (long *)regs->uregs[rn];\r\nint reg_bit_vector;\r\nint reg_count;\r\nreg_count = 0;\r\nreg_bit_vector = insn & 0xffff;\r\nwhile (reg_bit_vector) {\r\nreg_bit_vector &= (reg_bit_vector - 1);\r\n++reg_count;\r\n}\r\nif (!ubit)\r\naddr -= reg_count;\r\naddr += (!pbit == !ubit);\r\nreg_bit_vector = insn & 0xffff;\r\nwhile (reg_bit_vector) {\r\nint reg = __ffs(reg_bit_vector);\r\nreg_bit_vector &= (reg_bit_vector - 1);\r\nif (lbit)\r\nregs->uregs[reg] = *addr++;\r\nelse\r\n*addr++ = regs->uregs[reg];\r\n}\r\nif (wbit) {\r\nif (!ubit)\r\naddr -= reg_count;\r\naddr -= (!pbit == !ubit);\r\nregs->uregs[rn] = (long)addr;\r\n}\r\n}\r\nstatic void __kprobes simulate_stm1_pc(probes_opcode_t insn,\r\nstruct arch_probes_insn *asi,\r\nstruct pt_regs *regs)\r\n{\r\nunsigned long addr = regs->ARM_pc - 4;\r\nregs->ARM_pc = (long)addr + str_pc_offset;\r\nsimulate_ldm1stm1(insn, asi, regs);\r\nregs->ARM_pc = (long)addr + 4;\r\n}\r\nstatic void __kprobes simulate_ldm1_pc(probes_opcode_t insn,\r\nstruct arch_probes_insn *asi,\r\nstruct pt_regs *regs)\r\n{\r\nsimulate_ldm1stm1(insn, asi, regs);\r\nload_write_pc(regs->ARM_pc, regs);\r\n}\r\nstatic void __kprobes\r\nemulate_generic_r0_12_noflags(probes_opcode_t insn,\r\nstruct arch_probes_insn *asi, struct pt_regs *regs)\r\n{\r\nregister void *rregs asm("r1") = regs;\r\nregister void *rfn asm("lr") = asi->insn_fn;\r\n__asm__ __volatile__ (\r\n"stmdb sp!, {%[regs], r11} \n\t"\r\n"ldmia %[regs], {r0-r12} \n\t"\r\n#if __LINUX_ARM_ARCH__ >= 6\r\n"blx %[fn] \n\t"\r\n#else\r\n"str %[fn], [sp, #-4]! \n\t"\r\n"adr lr, 1f \n\t"\r\n"ldr pc, [sp], #4 \n\t"\r\n"1: \n\t"\r\n#endif\r\n"ldr lr, [sp], #4 \n\t"\r\n"stmia lr, {r0-r12} \n\t"\r\n"ldr r11, [sp], #4 \n\t"\r\n: [regs] "=r" (rregs), [fn] "=r" (rfn)\r\n: "0" (rregs), "1" (rfn)\r\n: "r0", "r2", "r3", "r4", "r5", "r6", "r7",\r\n"r8", "r9", "r10", "r12", "memory", "cc"\r\n);\r\n}\r\nstatic void __kprobes\r\nemulate_generic_r2_14_noflags(probes_opcode_t insn,\r\nstruct arch_probes_insn *asi, struct pt_regs *regs)\r\n{\r\nemulate_generic_r0_12_noflags(insn, asi,\r\n(struct pt_regs *)(regs->uregs+2));\r\n}\r\nstatic void __kprobes\r\nemulate_ldm_r3_15(probes_opcode_t insn,\r\nstruct arch_probes_insn *asi, struct pt_regs *regs)\r\n{\r\nemulate_generic_r0_12_noflags(insn, asi,\r\n(struct pt_regs *)(regs->uregs+3));\r\nload_write_pc(regs->ARM_pc, regs);\r\n}\r\nenum probes_insn __kprobes\r\nkprobe_decode_ldmstm(probes_opcode_t insn, struct arch_probes_insn *asi,\r\nconst struct decode_header *h)\r\n{\r\nprobes_insn_handler_t *handler = 0;\r\nunsigned reglist = insn & 0xffff;\r\nint is_ldm = insn & 0x100000;\r\nint rn = (insn >> 16) & 0xf;\r\nif (rn <= 12 && (reglist & 0xe000) == 0) {\r\nhandler = emulate_generic_r0_12_noflags;\r\n} else if (rn >= 2 && (reglist & 0x8003) == 0) {\r\nrn -= 2;\r\nreglist >>= 2;\r\nhandler = emulate_generic_r2_14_noflags;\r\n} else if (rn >= 3 && (reglist & 0x0007) == 0) {\r\nif (is_ldm && (reglist & 0x8000)) {\r\nrn -= 3;\r\nreglist >>= 3;\r\nhandler = emulate_ldm_r3_15;\r\n}\r\n}\r\nif (handler) {\r\nasi->insn[0] = __opcode_to_mem_arm((insn & 0xfff00000) |\r\n(rn << 16) | reglist);\r\nasi->insn_handler = handler;\r\nreturn INSN_GOOD;\r\n}\r\nif (reglist & 0x8000)\r\nhandler = is_ldm ? simulate_ldm1_pc : simulate_stm1_pc;\r\nelse\r\nhandler = simulate_ldm1stm1;\r\nasi->insn_handler = handler;\r\nreturn INSN_GOOD_NO_SLOT;\r\n}
