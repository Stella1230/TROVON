static void unref_worker(struct drm_flip_work *work, void *val)\r\n{\r\nstruct tilcdc_crtc *tilcdc_crtc =\r\ncontainer_of(work, struct tilcdc_crtc, unref_work);\r\nstruct drm_device *dev = tilcdc_crtc->base.dev;\r\nmutex_lock(&dev->mode_config.mutex);\r\ndrm_framebuffer_unreference(val);\r\nmutex_unlock(&dev->mode_config.mutex);\r\n}\r\nstatic void set_scanout(struct drm_crtc *crtc, int n)\r\n{\r\nstatic const uint32_t base_reg[] = {\r\nLCDC_DMA_FB_BASE_ADDR_0_REG,\r\nLCDC_DMA_FB_BASE_ADDR_1_REG,\r\n};\r\nstatic const uint32_t ceil_reg[] = {\r\nLCDC_DMA_FB_CEILING_ADDR_0_REG,\r\nLCDC_DMA_FB_CEILING_ADDR_1_REG,\r\n};\r\nstatic const uint32_t stat[] = {\r\nLCDC_END_OF_FRAME0, LCDC_END_OF_FRAME1,\r\n};\r\nstruct tilcdc_crtc *tilcdc_crtc = to_tilcdc_crtc(crtc);\r\nstruct drm_device *dev = crtc->dev;\r\nstruct tilcdc_drm_private *priv = dev->dev_private;\r\npm_runtime_get_sync(dev->dev);\r\ntilcdc_write(dev, base_reg[n], tilcdc_crtc->start);\r\ntilcdc_write(dev, ceil_reg[n], tilcdc_crtc->end);\r\nif (tilcdc_crtc->scanout[n]) {\r\ndrm_flip_work_queue(&tilcdc_crtc->unref_work, tilcdc_crtc->scanout[n]);\r\ndrm_flip_work_commit(&tilcdc_crtc->unref_work, priv->wq);\r\n}\r\ntilcdc_crtc->scanout[n] = crtc->primary->fb;\r\ndrm_framebuffer_reference(tilcdc_crtc->scanout[n]);\r\ntilcdc_crtc->dirty &= ~stat[n];\r\npm_runtime_put_sync(dev->dev);\r\n}\r\nstatic void update_scanout(struct drm_crtc *crtc)\r\n{\r\nstruct tilcdc_crtc *tilcdc_crtc = to_tilcdc_crtc(crtc);\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_framebuffer *fb = crtc->primary->fb;\r\nstruct drm_gem_cma_object *gem;\r\nunsigned int depth, bpp;\r\ndrm_fb_get_bpp_depth(fb->pixel_format, &depth, &bpp);\r\ngem = drm_fb_cma_get_gem_obj(fb, 0);\r\ntilcdc_crtc->start = gem->paddr + fb->offsets[0] +\r\n(crtc->y * fb->pitches[0]) + (crtc->x * bpp/8);\r\ntilcdc_crtc->end = tilcdc_crtc->start +\r\n(crtc->mode.vdisplay * fb->pitches[0]);\r\nif (tilcdc_crtc->dpms == DRM_MODE_DPMS_ON) {\r\ntilcdc_crtc->dirty |= LCDC_END_OF_FRAME0 | LCDC_END_OF_FRAME1;\r\ndrm_vblank_get(dev, 0);\r\n} else {\r\nset_scanout(crtc, 0);\r\nset_scanout(crtc, 1);\r\n}\r\n}\r\nstatic void start(struct drm_crtc *crtc)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct tilcdc_drm_private *priv = dev->dev_private;\r\nif (priv->rev == 2) {\r\ntilcdc_set(dev, LCDC_CLK_RESET_REG, LCDC_CLK_MAIN_RESET);\r\nmsleep(1);\r\ntilcdc_clear(dev, LCDC_CLK_RESET_REG, LCDC_CLK_MAIN_RESET);\r\nmsleep(1);\r\n}\r\ntilcdc_set(dev, LCDC_DMA_CTRL_REG, LCDC_DUAL_FRAME_BUFFER_ENABLE);\r\ntilcdc_set(dev, LCDC_RASTER_CTRL_REG, LCDC_PALETTE_LOAD_MODE(DATA_ONLY));\r\ntilcdc_set(dev, LCDC_RASTER_CTRL_REG, LCDC_RASTER_ENABLE);\r\n}\r\nstatic void stop(struct drm_crtc *crtc)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\ntilcdc_clear(dev, LCDC_RASTER_CTRL_REG, LCDC_RASTER_ENABLE);\r\n}\r\nstatic void tilcdc_crtc_destroy(struct drm_crtc *crtc)\r\n{\r\nstruct tilcdc_crtc *tilcdc_crtc = to_tilcdc_crtc(crtc);\r\nWARN_ON(tilcdc_crtc->dpms == DRM_MODE_DPMS_ON);\r\ndrm_crtc_cleanup(crtc);\r\ndrm_flip_work_cleanup(&tilcdc_crtc->unref_work);\r\nkfree(tilcdc_crtc);\r\n}\r\nstatic int tilcdc_crtc_page_flip(struct drm_crtc *crtc,\r\nstruct drm_framebuffer *fb,\r\nstruct drm_pending_vblank_event *event,\r\nuint32_t page_flip_flags)\r\n{\r\nstruct tilcdc_crtc *tilcdc_crtc = to_tilcdc_crtc(crtc);\r\nstruct drm_device *dev = crtc->dev;\r\nif (tilcdc_crtc->event) {\r\ndev_err(dev->dev, "already pending page flip!\n");\r\nreturn -EBUSY;\r\n}\r\ncrtc->primary->fb = fb;\r\ntilcdc_crtc->event = event;\r\nupdate_scanout(crtc);\r\nreturn 0;\r\n}\r\nstatic void tilcdc_crtc_dpms(struct drm_crtc *crtc, int mode)\r\n{\r\nstruct tilcdc_crtc *tilcdc_crtc = to_tilcdc_crtc(crtc);\r\nstruct drm_device *dev = crtc->dev;\r\nstruct tilcdc_drm_private *priv = dev->dev_private;\r\nif (mode != DRM_MODE_DPMS_ON)\r\nmode = DRM_MODE_DPMS_OFF;\r\nif (tilcdc_crtc->dpms == mode)\r\nreturn;\r\ntilcdc_crtc->dpms = mode;\r\npm_runtime_get_sync(dev->dev);\r\nif (mode == DRM_MODE_DPMS_ON) {\r\npm_runtime_forbid(dev->dev);\r\nstart(crtc);\r\n} else {\r\ntilcdc_crtc->frame_done = false;\r\nstop(crtc);\r\nif (priv->rev == 2) {\r\nint ret = wait_event_timeout(\r\ntilcdc_crtc->frame_done_wq,\r\ntilcdc_crtc->frame_done,\r\nmsecs_to_jiffies(50));\r\nif (ret == 0)\r\ndev_err(dev->dev, "timeout waiting for framedone\n");\r\n}\r\npm_runtime_allow(dev->dev);\r\n}\r\npm_runtime_put_sync(dev->dev);\r\n}\r\nstatic bool tilcdc_crtc_mode_fixup(struct drm_crtc *crtc,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nreturn true;\r\n}\r\nstatic void tilcdc_crtc_prepare(struct drm_crtc *crtc)\r\n{\r\ntilcdc_crtc_dpms(crtc, DRM_MODE_DPMS_OFF);\r\n}\r\nstatic void tilcdc_crtc_commit(struct drm_crtc *crtc)\r\n{\r\ntilcdc_crtc_dpms(crtc, DRM_MODE_DPMS_ON);\r\n}\r\nstatic int tilcdc_crtc_mode_set(struct drm_crtc *crtc,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode,\r\nint x, int y,\r\nstruct drm_framebuffer *old_fb)\r\n{\r\nstruct tilcdc_crtc *tilcdc_crtc = to_tilcdc_crtc(crtc);\r\nstruct drm_device *dev = crtc->dev;\r\nstruct tilcdc_drm_private *priv = dev->dev_private;\r\nconst struct tilcdc_panel_info *info = tilcdc_crtc->info;\r\nuint32_t reg, hbp, hfp, hsw, vbp, vfp, vsw;\r\nint ret;\r\nret = tilcdc_crtc_mode_valid(crtc, mode);\r\nif (WARN_ON(ret))\r\nreturn ret;\r\nif (WARN_ON(!info))\r\nreturn -EINVAL;\r\npm_runtime_get_sync(dev->dev);\r\nreg = tilcdc_read(dev, LCDC_DMA_CTRL_REG) & ~0x00000770;\r\nswitch (info->dma_burst_sz) {\r\ncase 1:\r\nreg |= LCDC_DMA_BURST_SIZE(LCDC_DMA_BURST_1);\r\nbreak;\r\ncase 2:\r\nreg |= LCDC_DMA_BURST_SIZE(LCDC_DMA_BURST_2);\r\nbreak;\r\ncase 4:\r\nreg |= LCDC_DMA_BURST_SIZE(LCDC_DMA_BURST_4);\r\nbreak;\r\ncase 8:\r\nreg |= LCDC_DMA_BURST_SIZE(LCDC_DMA_BURST_8);\r\nbreak;\r\ncase 16:\r\nreg |= LCDC_DMA_BURST_SIZE(LCDC_DMA_BURST_16);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreg |= (info->fifo_th << 8);\r\ntilcdc_write(dev, LCDC_DMA_CTRL_REG, reg);\r\nhbp = mode->htotal - mode->hsync_end;\r\nhfp = mode->hsync_start - mode->hdisplay;\r\nhsw = mode->hsync_end - mode->hsync_start;\r\nvbp = mode->vtotal - mode->vsync_end;\r\nvfp = mode->vsync_start - mode->vdisplay;\r\nvsw = mode->vsync_end - mode->vsync_start;\r\nDBG("%dx%d, hbp=%u, hfp=%u, hsw=%u, vbp=%u, vfp=%u, vsw=%u",\r\nmode->hdisplay, mode->vdisplay, hbp, hfp, hsw, vbp, vfp, vsw);\r\nreg = tilcdc_read(dev, LCDC_RASTER_TIMING_2_REG) & ~0x000fff00;\r\nreg |= LCDC_AC_BIAS_FREQUENCY(info->ac_bias) |\r\nLCDC_AC_BIAS_TRANSITIONS_PER_INT(info->ac_bias_intrpt);\r\nif (priv->rev == 2) {\r\nreg &= ~0x78000033;\r\nreg |= ((hfp-1) & 0x300) >> 8;\r\nreg |= ((hbp-1) & 0x300) >> 4;\r\nreg |= ((hsw-1) & 0x3c0) << 21;\r\n}\r\ntilcdc_write(dev, LCDC_RASTER_TIMING_2_REG, reg);\r\nreg = (((mode->hdisplay >> 4) - 1) << 4) |\r\n(((hbp-1) & 0xff) << 24) |\r\n(((hfp-1) & 0xff) << 16) |\r\n(((hsw-1) & 0x3f) << 10);\r\nif (priv->rev == 2)\r\nreg |= (((mode->hdisplay >> 4) - 1) & 0x40) >> 3;\r\ntilcdc_write(dev, LCDC_RASTER_TIMING_0_REG, reg);\r\nreg = ((mode->vdisplay - 1) & 0x3ff) |\r\n((vbp & 0xff) << 24) |\r\n((vfp & 0xff) << 16) |\r\n(((vsw-1) & 0x3f) << 10);\r\ntilcdc_write(dev, LCDC_RASTER_TIMING_1_REG, reg);\r\nif (priv->rev == 2) {\r\nif ((mode->vdisplay - 1) & 0x400) {\r\ntilcdc_set(dev, LCDC_RASTER_TIMING_2_REG,\r\nLCDC_LPP_B10);\r\n} else {\r\ntilcdc_clear(dev, LCDC_RASTER_TIMING_2_REG,\r\nLCDC_LPP_B10);\r\n}\r\n}\r\nreg = tilcdc_read(dev, LCDC_RASTER_CTRL_REG) &\r\n~(LCDC_TFT_MODE | LCDC_MONO_8BIT_MODE | LCDC_MONOCHROME_MODE |\r\nLCDC_V2_TFT_24BPP_MODE | LCDC_V2_TFT_24BPP_UNPACK | 0x000ff000);\r\nreg |= LCDC_TFT_MODE;\r\nif (info->tft_alt_mode)\r\nreg |= LCDC_TFT_ALT_ENABLE;\r\nif (priv->rev == 2) {\r\nunsigned int depth, bpp;\r\ndrm_fb_get_bpp_depth(crtc->primary->fb->pixel_format, &depth, &bpp);\r\nswitch (bpp) {\r\ncase 16:\r\nbreak;\r\ncase 32:\r\nreg |= LCDC_V2_TFT_24BPP_UNPACK;\r\ncase 24:\r\nreg |= LCDC_V2_TFT_24BPP_MODE;\r\nbreak;\r\ndefault:\r\ndev_err(dev->dev, "invalid pixel format\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreg |= info->fdd < 12;\r\ntilcdc_write(dev, LCDC_RASTER_CTRL_REG, reg);\r\nif (info->invert_pxl_clk)\r\ntilcdc_set(dev, LCDC_RASTER_TIMING_2_REG, LCDC_INVERT_PIXEL_CLOCK);\r\nelse\r\ntilcdc_clear(dev, LCDC_RASTER_TIMING_2_REG, LCDC_INVERT_PIXEL_CLOCK);\r\nif (info->sync_ctrl)\r\ntilcdc_set(dev, LCDC_RASTER_TIMING_2_REG, LCDC_SYNC_CTRL);\r\nelse\r\ntilcdc_clear(dev, LCDC_RASTER_TIMING_2_REG, LCDC_SYNC_CTRL);\r\nif (info->sync_edge)\r\ntilcdc_set(dev, LCDC_RASTER_TIMING_2_REG, LCDC_SYNC_EDGE);\r\nelse\r\ntilcdc_clear(dev, LCDC_RASTER_TIMING_2_REG, LCDC_SYNC_EDGE);\r\nif (adjusted_mode->flags & DRM_MODE_FLAG_NHSYNC)\r\ntilcdc_set(dev, LCDC_RASTER_TIMING_2_REG, LCDC_INVERT_HSYNC);\r\nelse\r\ntilcdc_clear(dev, LCDC_RASTER_TIMING_2_REG, LCDC_INVERT_HSYNC);\r\nif (mode->flags & DRM_MODE_FLAG_NVSYNC)\r\ntilcdc_set(dev, LCDC_RASTER_TIMING_2_REG, LCDC_INVERT_VSYNC);\r\nelse\r\ntilcdc_clear(dev, LCDC_RASTER_TIMING_2_REG, LCDC_INVERT_VSYNC);\r\nif (info->raster_order)\r\ntilcdc_set(dev, LCDC_RASTER_CTRL_REG, LCDC_RASTER_ORDER);\r\nelse\r\ntilcdc_clear(dev, LCDC_RASTER_CTRL_REG, LCDC_RASTER_ORDER);\r\nupdate_scanout(crtc);\r\ntilcdc_crtc_update_clk(crtc);\r\npm_runtime_put_sync(dev->dev);\r\nreturn 0;\r\n}\r\nstatic int tilcdc_crtc_mode_set_base(struct drm_crtc *crtc, int x, int y,\r\nstruct drm_framebuffer *old_fb)\r\n{\r\nupdate_scanout(crtc);\r\nreturn 0;\r\n}\r\nint tilcdc_crtc_max_width(struct drm_crtc *crtc)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct tilcdc_drm_private *priv = dev->dev_private;\r\nint max_width = 0;\r\nif (priv->rev == 1)\r\nmax_width = 1024;\r\nelse if (priv->rev == 2)\r\nmax_width = 2048;\r\nreturn max_width;\r\n}\r\nint tilcdc_crtc_mode_valid(struct drm_crtc *crtc, struct drm_display_mode *mode)\r\n{\r\nstruct tilcdc_drm_private *priv = crtc->dev->dev_private;\r\nunsigned int bandwidth;\r\nuint32_t hbp, hfp, hsw, vbp, vfp, vsw;\r\nif (mode->hdisplay > tilcdc_crtc_max_width(crtc))\r\nreturn MODE_VIRTUAL_X;\r\nif (mode->hdisplay & 0xf)\r\nreturn MODE_VIRTUAL_X;\r\nif (mode->vdisplay > 2048)\r\nreturn MODE_VIRTUAL_Y;\r\nDBG("Processing mode %dx%d@%d with pixel clock %d",\r\nmode->hdisplay, mode->vdisplay,\r\ndrm_mode_vrefresh(mode), mode->clock);\r\nhbp = mode->htotal - mode->hsync_end;\r\nhfp = mode->hsync_start - mode->hdisplay;\r\nhsw = mode->hsync_end - mode->hsync_start;\r\nvbp = mode->vtotal - mode->vsync_end;\r\nvfp = mode->vsync_start - mode->vdisplay;\r\nvsw = mode->vsync_end - mode->vsync_start;\r\nif ((hbp-1) & ~0x3ff) {\r\nDBG("Pruning mode: Horizontal Back Porch out of range");\r\nreturn MODE_HBLANK_WIDE;\r\n}\r\nif ((hfp-1) & ~0x3ff) {\r\nDBG("Pruning mode: Horizontal Front Porch out of range");\r\nreturn MODE_HBLANK_WIDE;\r\n}\r\nif ((hsw-1) & ~0x3ff) {\r\nDBG("Pruning mode: Horizontal Sync Width out of range");\r\nreturn MODE_HSYNC_WIDE;\r\n}\r\nif (vbp & ~0xff) {\r\nDBG("Pruning mode: Vertical Back Porch out of range");\r\nreturn MODE_VBLANK_WIDE;\r\n}\r\nif (vfp & ~0xff) {\r\nDBG("Pruning mode: Vertical Front Porch out of range");\r\nreturn MODE_VBLANK_WIDE;\r\n}\r\nif ((vsw-1) & ~0x3f) {\r\nDBG("Pruning mode: Vertical Sync Width out of range");\r\nreturn MODE_VSYNC_WIDE;\r\n}\r\nif (mode->clock > priv->max_pixelclock) {\r\nDBG("Pruning mode: pixel clock too high");\r\nreturn MODE_CLOCK_HIGH;\r\n}\r\nif (mode->hdisplay > priv->max_width)\r\nreturn MODE_BAD_WIDTH;\r\nbandwidth = mode->hdisplay * mode->vdisplay *\r\ndrm_mode_vrefresh(mode);\r\nif (bandwidth > priv->max_bandwidth) {\r\nDBG("Pruning mode: exceeds defined bandwidth limit");\r\nreturn MODE_BAD;\r\n}\r\nreturn MODE_OK;\r\n}\r\nvoid tilcdc_crtc_set_panel_info(struct drm_crtc *crtc,\r\nconst struct tilcdc_panel_info *info)\r\n{\r\nstruct tilcdc_crtc *tilcdc_crtc = to_tilcdc_crtc(crtc);\r\ntilcdc_crtc->info = info;\r\n}\r\nvoid tilcdc_crtc_update_clk(struct drm_crtc *crtc)\r\n{\r\nstruct tilcdc_crtc *tilcdc_crtc = to_tilcdc_crtc(crtc);\r\nstruct drm_device *dev = crtc->dev;\r\nstruct tilcdc_drm_private *priv = dev->dev_private;\r\nint dpms = tilcdc_crtc->dpms;\r\nunsigned int lcd_clk, div;\r\nint ret;\r\npm_runtime_get_sync(dev->dev);\r\nif (dpms == DRM_MODE_DPMS_ON)\r\ntilcdc_crtc_dpms(crtc, DRM_MODE_DPMS_OFF);\r\nret = clk_set_rate(priv->disp_clk, crtc->mode.clock * 1000 * 2);\r\nif (ret) {\r\ndev_err(dev->dev, "failed to set display clock rate to: %d\n",\r\ncrtc->mode.clock);\r\ngoto out;\r\n}\r\nlcd_clk = clk_get_rate(priv->clk);\r\ndiv = lcd_clk / (crtc->mode.clock * 1000);\r\nDBG("lcd_clk=%u, mode clock=%d, div=%u", lcd_clk, crtc->mode.clock, div);\r\nDBG("fck=%lu, dpll_disp_ck=%lu", clk_get_rate(priv->clk), clk_get_rate(priv->disp_clk));\r\ntilcdc_write(dev, LCDC_CTRL_REG, LCDC_CLK_DIVISOR(div) |\r\nLCDC_RASTER_MODE);\r\nif (priv->rev == 2)\r\ntilcdc_set(dev, LCDC_CLK_ENABLE_REG,\r\nLCDC_V2_DMA_CLK_EN | LCDC_V2_LIDD_CLK_EN |\r\nLCDC_V2_CORE_CLK_EN);\r\nif (dpms == DRM_MODE_DPMS_ON)\r\ntilcdc_crtc_dpms(crtc, DRM_MODE_DPMS_ON);\r\nout:\r\npm_runtime_put_sync(dev->dev);\r\n}\r\nirqreturn_t tilcdc_crtc_irq(struct drm_crtc *crtc)\r\n{\r\nstruct tilcdc_crtc *tilcdc_crtc = to_tilcdc_crtc(crtc);\r\nstruct drm_device *dev = crtc->dev;\r\nstruct tilcdc_drm_private *priv = dev->dev_private;\r\nuint32_t stat = tilcdc_read_irqstatus(dev);\r\nif ((stat & LCDC_SYNC_LOST) && (stat & LCDC_FIFO_UNDERFLOW)) {\r\nstop(crtc);\r\ndev_err(dev->dev, "error: %08x\n", stat);\r\ntilcdc_clear_irqstatus(dev, stat);\r\nstart(crtc);\r\n} else if (stat & LCDC_PL_LOAD_DONE) {\r\ntilcdc_clear_irqstatus(dev, stat);\r\n} else {\r\nstruct drm_pending_vblank_event *event;\r\nunsigned long flags;\r\nuint32_t dirty = tilcdc_crtc->dirty & stat;\r\ntilcdc_clear_irqstatus(dev, stat);\r\nif (dirty & LCDC_END_OF_FRAME0)\r\nset_scanout(crtc, 0);\r\nif (dirty & LCDC_END_OF_FRAME1)\r\nset_scanout(crtc, 1);\r\ndrm_handle_vblank(dev, 0);\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\nevent = tilcdc_crtc->event;\r\ntilcdc_crtc->event = NULL;\r\nif (event)\r\ndrm_send_vblank_event(dev, 0, event);\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\nif (dirty && !tilcdc_crtc->dirty)\r\ndrm_vblank_put(dev, 0);\r\n}\r\nif (priv->rev == 2) {\r\nif (stat & LCDC_FRAME_DONE) {\r\ntilcdc_crtc->frame_done = true;\r\nwake_up(&tilcdc_crtc->frame_done_wq);\r\n}\r\ntilcdc_write(dev, LCDC_END_OF_INT_IND_REG, 0);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid tilcdc_crtc_cancel_page_flip(struct drm_crtc *crtc, struct drm_file *file)\r\n{\r\nstruct tilcdc_crtc *tilcdc_crtc = to_tilcdc_crtc(crtc);\r\nstruct drm_pending_vblank_event *event;\r\nstruct drm_device *dev = crtc->dev;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\nevent = tilcdc_crtc->event;\r\nif (event && event->base.file_priv == file) {\r\ntilcdc_crtc->event = NULL;\r\nevent->base.destroy(&event->base);\r\ndrm_vblank_put(dev, 0);\r\n}\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\n}\r\nstruct drm_crtc *tilcdc_crtc_create(struct drm_device *dev)\r\n{\r\nstruct tilcdc_crtc *tilcdc_crtc;\r\nstruct drm_crtc *crtc;\r\nint ret;\r\ntilcdc_crtc = kzalloc(sizeof(*tilcdc_crtc), GFP_KERNEL);\r\nif (!tilcdc_crtc) {\r\ndev_err(dev->dev, "allocation failed\n");\r\nreturn NULL;\r\n}\r\ncrtc = &tilcdc_crtc->base;\r\ntilcdc_crtc->dpms = DRM_MODE_DPMS_OFF;\r\ninit_waitqueue_head(&tilcdc_crtc->frame_done_wq);\r\ndrm_flip_work_init(&tilcdc_crtc->unref_work,\r\n"unref", unref_worker);\r\nret = drm_crtc_init(dev, crtc, &tilcdc_crtc_funcs);\r\nif (ret < 0)\r\ngoto fail;\r\ndrm_crtc_helper_add(crtc, &tilcdc_crtc_helper_funcs);\r\nreturn crtc;\r\nfail:\r\ntilcdc_crtc_destroy(crtc);\r\nreturn NULL;\r\n}
