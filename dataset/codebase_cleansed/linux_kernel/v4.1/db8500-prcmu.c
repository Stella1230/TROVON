int db8500_prcmu_enable_dsipll(void)\r\n{\r\nint i;\r\nwritel(PRCMU_RESET_DSIPLL, PRCM_APE_RESETN_CLR);\r\nwritel(PRCMU_UNCLAMP_DSIPLL, PRCM_MMIP_LS_CLAMP_CLR);\r\nwritel(PRCMU_PLLDSI_FREQ_SETTING, PRCM_PLLDSI_FREQ);\r\nwritel(PRCMU_DSI_PLLOUT_SEL_SETTING, PRCM_DSI_PLLOUT_SEL);\r\nwritel(PRCMU_ENABLE_ESCAPE_CLOCK_DIV, PRCM_DSITVCLK_DIV);\r\nwritel(PRCMU_ENABLE_PLLDSI, PRCM_PLLDSI_ENABLE);\r\nwritel(PRCMU_DSI_RESET_SW, PRCM_DSI_SW_RESET);\r\nfor (i = 0; i < 10; i++) {\r\nif ((readl(PRCM_PLLDSI_LOCKP) & PRCMU_PLLDSI_LOCKP_LOCKED)\r\n== PRCMU_PLLDSI_LOCKP_LOCKED)\r\nbreak;\r\nudelay(100);\r\n}\r\nwritel(PRCMU_RESET_DSIPLL, PRCM_APE_RESETN_SET);\r\nreturn 0;\r\n}\r\nint db8500_prcmu_disable_dsipll(void)\r\n{\r\nwritel(PRCMU_DISABLE_PLLDSI, PRCM_PLLDSI_ENABLE);\r\nwritel(PRCMU_DISABLE_ESCAPE_CLOCK_DIV, PRCM_DSITVCLK_DIV);\r\nreturn 0;\r\n}\r\nint db8500_prcmu_set_display_clocks(void)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&clk_mgt_lock, flags);\r\nwhile ((readl(PRCM_SEM) & PRCM_SEM_PRCM_SEM) != 0)\r\ncpu_relax();\r\nwritel(PRCMU_DSI_CLOCK_SETTING, prcmu_base + PRCM_HDMICLK_MGT);\r\nwritel(PRCMU_DSI_LP_CLOCK_SETTING, prcmu_base + PRCM_TVCLK_MGT);\r\nwritel(PRCMU_DPI_CLOCK_SETTING, prcmu_base + PRCM_LCDCLK_MGT);\r\nwritel(0, PRCM_SEM);\r\nspin_unlock_irqrestore(&clk_mgt_lock, flags);\r\nreturn 0;\r\n}\r\nu32 db8500_prcmu_read(unsigned int reg)\r\n{\r\nreturn readl(prcmu_base + reg);\r\n}\r\nvoid db8500_prcmu_write(unsigned int reg, u32 value)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&prcmu_lock, flags);\r\nwritel(value, (prcmu_base + reg));\r\nspin_unlock_irqrestore(&prcmu_lock, flags);\r\n}\r\nvoid db8500_prcmu_write_masked(unsigned int reg, u32 mask, u32 value)\r\n{\r\nu32 val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&prcmu_lock, flags);\r\nval = readl(prcmu_base + reg);\r\nval = ((val & ~mask) | (value & mask));\r\nwritel(val, (prcmu_base + reg));\r\nspin_unlock_irqrestore(&prcmu_lock, flags);\r\n}\r\nstruct prcmu_fw_version *prcmu_get_fw_version(void)\r\n{\r\nreturn fw_info.valid ? &fw_info.version : NULL;\r\n}\r\nbool prcmu_has_arm_maxopp(void)\r\n{\r\nreturn (readb(tcdm_base + PRCM_AVS_VARM_MAX_OPP) &\r\nPRCM_AVS_ISMODEENABLE_MASK) == PRCM_AVS_ISMODEENABLE_MASK;\r\n}\r\nint prcmu_set_rc_a2p(enum romcode_write val)\r\n{\r\nif (val < RDY_2_DS || val > RDY_2_XP70_RST)\r\nreturn -EINVAL;\r\nwriteb(val, (tcdm_base + PRCM_ROMCODE_A2P));\r\nreturn 0;\r\n}\r\nenum romcode_read prcmu_get_rc_p2a(void)\r\n{\r\nreturn readb(tcdm_base + PRCM_ROMCODE_P2A);\r\n}\r\nenum ap_pwrst prcmu_get_xp70_current_state(void)\r\n{\r\nreturn readb(tcdm_base + PRCM_XP70_CUR_PWR_STATE);\r\n}\r\nint prcmu_config_clkout(u8 clkout, u8 source, u8 div)\r\n{\r\nstatic int requests[2];\r\nint r = 0;\r\nunsigned long flags;\r\nu32 val;\r\nu32 bits;\r\nu32 mask;\r\nu32 div_mask;\r\nBUG_ON(clkout > 1);\r\nBUG_ON(div > 63);\r\nBUG_ON((clkout == 0) && (source > PRCMU_CLKSRC_CLK009));\r\nif (!div && !requests[clkout])\r\nreturn -EINVAL;\r\nswitch (clkout) {\r\ncase 0:\r\ndiv_mask = PRCM_CLKOCR_CLKODIV0_MASK;\r\nmask = (PRCM_CLKOCR_CLKODIV0_MASK | PRCM_CLKOCR_CLKOSEL0_MASK);\r\nbits = ((source << PRCM_CLKOCR_CLKOSEL0_SHIFT) |\r\n(div << PRCM_CLKOCR_CLKODIV0_SHIFT));\r\nbreak;\r\ncase 1:\r\ndiv_mask = PRCM_CLKOCR_CLKODIV1_MASK;\r\nmask = (PRCM_CLKOCR_CLKODIV1_MASK | PRCM_CLKOCR_CLKOSEL1_MASK |\r\nPRCM_CLKOCR_CLK1TYPE);\r\nbits = ((source << PRCM_CLKOCR_CLKOSEL1_SHIFT) |\r\n(div << PRCM_CLKOCR_CLKODIV1_SHIFT));\r\nbreak;\r\n}\r\nbits &= mask;\r\nspin_lock_irqsave(&clkout_lock, flags);\r\nval = readl(PRCM_CLKOCR);\r\nif (val & div_mask) {\r\nif (div) {\r\nif ((val & mask) != bits) {\r\nr = -EBUSY;\r\ngoto unlock_and_return;\r\n}\r\n} else {\r\nif ((val & mask & ~div_mask) != bits) {\r\nr = -EINVAL;\r\ngoto unlock_and_return;\r\n}\r\n}\r\n}\r\nwritel((bits | (val & ~mask)), PRCM_CLKOCR);\r\nrequests[clkout] += (div ? 1 : -1);\r\nunlock_and_return:\r\nspin_unlock_irqrestore(&clkout_lock, flags);\r\nreturn r;\r\n}\r\nint db8500_prcmu_set_power_state(u8 state, bool keep_ulp_clk, bool keep_ap_pll)\r\n{\r\nunsigned long flags;\r\nBUG_ON((state < PRCMU_AP_SLEEP) || (PRCMU_AP_DEEP_IDLE < state));\r\nspin_lock_irqsave(&mb0_transfer.lock, flags);\r\nwhile (readl(PRCM_MBOX_CPU_VAL) & MBOX_BIT(0))\r\ncpu_relax();\r\nwriteb(MB0H_POWER_STATE_TRANS, (tcdm_base + PRCM_MBOX_HEADER_REQ_MB0));\r\nwriteb(state, (tcdm_base + PRCM_REQ_MB0_AP_POWER_STATE));\r\nwriteb((keep_ap_pll ? 1 : 0), (tcdm_base + PRCM_REQ_MB0_AP_PLL_STATE));\r\nwriteb((keep_ulp_clk ? 1 : 0),\r\n(tcdm_base + PRCM_REQ_MB0_ULP_CLOCK_STATE));\r\nwriteb(0, (tcdm_base + PRCM_REQ_MB0_DO_NOT_WFI));\r\nwritel(MBOX_BIT(0), PRCM_MBOX_CPU_SET);\r\nspin_unlock_irqrestore(&mb0_transfer.lock, flags);\r\nreturn 0;\r\n}\r\nu8 db8500_prcmu_get_power_state_result(void)\r\n{\r\nreturn readb(tcdm_base + PRCM_ACK_MB0_AP_PWRSTTR_STATUS);\r\n}\r\nstatic void config_wakeups(void)\r\n{\r\nconst u8 header[2] = {\r\nMB0H_CONFIG_WAKEUPS_EXE,\r\nMB0H_CONFIG_WAKEUPS_SLEEP\r\n};\r\nstatic u32 last_dbb_events;\r\nstatic u32 last_abb_events;\r\nu32 dbb_events;\r\nu32 abb_events;\r\nunsigned int i;\r\ndbb_events = mb0_transfer.req.dbb_irqs | mb0_transfer.req.dbb_wakeups;\r\ndbb_events |= (WAKEUP_BIT_AC_WAKE_ACK | WAKEUP_BIT_AC_SLEEP_ACK);\r\nabb_events = mb0_transfer.req.abb_events;\r\nif ((dbb_events == last_dbb_events) && (abb_events == last_abb_events))\r\nreturn;\r\nfor (i = 0; i < 2; i++) {\r\nwhile (readl(PRCM_MBOX_CPU_VAL) & MBOX_BIT(0))\r\ncpu_relax();\r\nwritel(dbb_events, (tcdm_base + PRCM_REQ_MB0_WAKEUP_8500));\r\nwritel(abb_events, (tcdm_base + PRCM_REQ_MB0_WAKEUP_4500));\r\nwriteb(header[i], (tcdm_base + PRCM_MBOX_HEADER_REQ_MB0));\r\nwritel(MBOX_BIT(0), PRCM_MBOX_CPU_SET);\r\n}\r\nlast_dbb_events = dbb_events;\r\nlast_abb_events = abb_events;\r\n}\r\nvoid db8500_prcmu_enable_wakeups(u32 wakeups)\r\n{\r\nunsigned long flags;\r\nu32 bits;\r\nint i;\r\nBUG_ON(wakeups != (wakeups & VALID_WAKEUPS));\r\nfor (i = 0, bits = 0; i < NUM_PRCMU_WAKEUP_INDICES; i++) {\r\nif (wakeups & BIT(i))\r\nbits |= prcmu_wakeup_bit[i];\r\n}\r\nspin_lock_irqsave(&mb0_transfer.lock, flags);\r\nmb0_transfer.req.dbb_wakeups = bits;\r\nconfig_wakeups();\r\nspin_unlock_irqrestore(&mb0_transfer.lock, flags);\r\n}\r\nvoid db8500_prcmu_config_abb_event_readout(u32 abb_events)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&mb0_transfer.lock, flags);\r\nmb0_transfer.req.abb_events = abb_events;\r\nconfig_wakeups();\r\nspin_unlock_irqrestore(&mb0_transfer.lock, flags);\r\n}\r\nvoid db8500_prcmu_get_abb_event_buffer(void __iomem **buf)\r\n{\r\nif (readb(tcdm_base + PRCM_ACK_MB0_READ_POINTER) & 1)\r\n*buf = (tcdm_base + PRCM_ACK_MB0_WAKEUP_1_4500);\r\nelse\r\n*buf = (tcdm_base + PRCM_ACK_MB0_WAKEUP_0_4500);\r\n}\r\nint db8500_prcmu_set_arm_opp(u8 opp)\r\n{\r\nint r;\r\nif (opp < ARM_NO_CHANGE || opp > ARM_EXTCLK)\r\nreturn -EINVAL;\r\nr = 0;\r\nmutex_lock(&mb1_transfer.lock);\r\nwhile (readl(PRCM_MBOX_CPU_VAL) & MBOX_BIT(1))\r\ncpu_relax();\r\nwriteb(MB1H_ARM_APE_OPP, (tcdm_base + PRCM_MBOX_HEADER_REQ_MB1));\r\nwriteb(opp, (tcdm_base + PRCM_REQ_MB1_ARM_OPP));\r\nwriteb(APE_NO_CHANGE, (tcdm_base + PRCM_REQ_MB1_APE_OPP));\r\nwritel(MBOX_BIT(1), PRCM_MBOX_CPU_SET);\r\nwait_for_completion(&mb1_transfer.work);\r\nif ((mb1_transfer.ack.header != MB1H_ARM_APE_OPP) ||\r\n(mb1_transfer.ack.arm_opp != opp))\r\nr = -EIO;\r\nmutex_unlock(&mb1_transfer.lock);\r\nreturn r;\r\n}\r\nint db8500_prcmu_get_arm_opp(void)\r\n{\r\nreturn readb(tcdm_base + PRCM_ACK_MB1_CURRENT_ARM_OPP);\r\n}\r\nint db8500_prcmu_get_ddr_opp(void)\r\n{\r\nreturn readb(PRCM_DDR_SUBSYS_APE_MINBW);\r\n}\r\nint db8500_prcmu_set_ddr_opp(u8 opp)\r\n{\r\nif (opp < DDR_100_OPP || opp > DDR_25_OPP)\r\nreturn -EINVAL;\r\nif (enable_set_ddr_opp)\r\nwriteb(opp, PRCM_DDR_SUBSYS_APE_MINBW);\r\nreturn 0;\r\n}\r\nstatic void request_even_slower_clocks(bool enable)\r\n{\r\nu32 clock_reg[] = {\r\nPRCM_ACLK_MGT,\r\nPRCM_DMACLK_MGT\r\n};\r\nunsigned long flags;\r\nunsigned int i;\r\nspin_lock_irqsave(&clk_mgt_lock, flags);\r\nwhile ((readl(PRCM_SEM) & PRCM_SEM_PRCM_SEM) != 0)\r\ncpu_relax();\r\nfor (i = 0; i < ARRAY_SIZE(clock_reg); i++) {\r\nu32 val;\r\nu32 div;\r\nval = readl(prcmu_base + clock_reg[i]);\r\ndiv = (val & PRCM_CLK_MGT_CLKPLLDIV_MASK);\r\nif (enable) {\r\nif ((div <= 1) || (div > 15)) {\r\npr_err("prcmu: Bad clock divider %d in %s\n",\r\ndiv, __func__);\r\ngoto unlock_and_return;\r\n}\r\ndiv <<= 1;\r\n} else {\r\nif (div <= 2)\r\ngoto unlock_and_return;\r\ndiv >>= 1;\r\n}\r\nval = ((val & ~PRCM_CLK_MGT_CLKPLLDIV_MASK) |\r\n(div & PRCM_CLK_MGT_CLKPLLDIV_MASK));\r\nwritel(val, prcmu_base + clock_reg[i]);\r\n}\r\nunlock_and_return:\r\nwritel(0, PRCM_SEM);\r\nspin_unlock_irqrestore(&clk_mgt_lock, flags);\r\n}\r\nint db8500_prcmu_set_ape_opp(u8 opp)\r\n{\r\nint r = 0;\r\nif (opp == mb1_transfer.ape_opp)\r\nreturn 0;\r\nmutex_lock(&mb1_transfer.lock);\r\nif (mb1_transfer.ape_opp == APE_50_PARTLY_25_OPP)\r\nrequest_even_slower_clocks(false);\r\nif ((opp != APE_100_OPP) && (mb1_transfer.ape_opp != APE_100_OPP))\r\ngoto skip_message;\r\nwhile (readl(PRCM_MBOX_CPU_VAL) & MBOX_BIT(1))\r\ncpu_relax();\r\nwriteb(MB1H_ARM_APE_OPP, (tcdm_base + PRCM_MBOX_HEADER_REQ_MB1));\r\nwriteb(ARM_NO_CHANGE, (tcdm_base + PRCM_REQ_MB1_ARM_OPP));\r\nwriteb(((opp == APE_50_PARTLY_25_OPP) ? APE_50_OPP : opp),\r\n(tcdm_base + PRCM_REQ_MB1_APE_OPP));\r\nwritel(MBOX_BIT(1), PRCM_MBOX_CPU_SET);\r\nwait_for_completion(&mb1_transfer.work);\r\nif ((mb1_transfer.ack.header != MB1H_ARM_APE_OPP) ||\r\n(mb1_transfer.ack.ape_opp != opp))\r\nr = -EIO;\r\nskip_message:\r\nif ((!r && (opp == APE_50_PARTLY_25_OPP)) ||\r\n(r && (mb1_transfer.ape_opp == APE_50_PARTLY_25_OPP)))\r\nrequest_even_slower_clocks(true);\r\nif (!r)\r\nmb1_transfer.ape_opp = opp;\r\nmutex_unlock(&mb1_transfer.lock);\r\nreturn r;\r\n}\r\nint db8500_prcmu_get_ape_opp(void)\r\n{\r\nreturn readb(tcdm_base + PRCM_ACK_MB1_CURRENT_APE_OPP);\r\n}\r\nint db8500_prcmu_request_ape_opp_100_voltage(bool enable)\r\n{\r\nint r = 0;\r\nu8 header;\r\nstatic unsigned int requests;\r\nmutex_lock(&mb1_transfer.lock);\r\nif (enable) {\r\nif (0 != requests++)\r\ngoto unlock_and_return;\r\nheader = MB1H_REQUEST_APE_OPP_100_VOLT;\r\n} else {\r\nif (requests == 0) {\r\nr = -EIO;\r\ngoto unlock_and_return;\r\n} else if (1 != requests--) {\r\ngoto unlock_and_return;\r\n}\r\nheader = MB1H_RELEASE_APE_OPP_100_VOLT;\r\n}\r\nwhile (readl(PRCM_MBOX_CPU_VAL) & MBOX_BIT(1))\r\ncpu_relax();\r\nwriteb(header, (tcdm_base + PRCM_MBOX_HEADER_REQ_MB1));\r\nwritel(MBOX_BIT(1), PRCM_MBOX_CPU_SET);\r\nwait_for_completion(&mb1_transfer.work);\r\nif ((mb1_transfer.ack.header != header) ||\r\n((mb1_transfer.ack.ape_voltage_status & BIT(0)) != 0))\r\nr = -EIO;\r\nunlock_and_return:\r\nmutex_unlock(&mb1_transfer.lock);\r\nreturn r;\r\n}\r\nint prcmu_release_usb_wakeup_state(void)\r\n{\r\nint r = 0;\r\nmutex_lock(&mb1_transfer.lock);\r\nwhile (readl(PRCM_MBOX_CPU_VAL) & MBOX_BIT(1))\r\ncpu_relax();\r\nwriteb(MB1H_RELEASE_USB_WAKEUP,\r\n(tcdm_base + PRCM_MBOX_HEADER_REQ_MB1));\r\nwritel(MBOX_BIT(1), PRCM_MBOX_CPU_SET);\r\nwait_for_completion(&mb1_transfer.work);\r\nif ((mb1_transfer.ack.header != MB1H_RELEASE_USB_WAKEUP) ||\r\n((mb1_transfer.ack.ape_voltage_status & BIT(0)) != 0))\r\nr = -EIO;\r\nmutex_unlock(&mb1_transfer.lock);\r\nreturn r;\r\n}\r\nstatic int request_pll(u8 clock, bool enable)\r\n{\r\nint r = 0;\r\nif (clock == PRCMU_PLLSOC0)\r\nclock = (enable ? PLL_SOC0_ON : PLL_SOC0_OFF);\r\nelse if (clock == PRCMU_PLLSOC1)\r\nclock = (enable ? PLL_SOC1_ON : PLL_SOC1_OFF);\r\nelse\r\nreturn -EINVAL;\r\nmutex_lock(&mb1_transfer.lock);\r\nwhile (readl(PRCM_MBOX_CPU_VAL) & MBOX_BIT(1))\r\ncpu_relax();\r\nwriteb(MB1H_PLL_ON_OFF, (tcdm_base + PRCM_MBOX_HEADER_REQ_MB1));\r\nwriteb(clock, (tcdm_base + PRCM_REQ_MB1_PLL_ON_OFF));\r\nwritel(MBOX_BIT(1), PRCM_MBOX_CPU_SET);\r\nwait_for_completion(&mb1_transfer.work);\r\nif (mb1_transfer.ack.header != MB1H_PLL_ON_OFF)\r\nr = -EIO;\r\nmutex_unlock(&mb1_transfer.lock);\r\nreturn r;\r\n}\r\nint db8500_prcmu_set_epod(u16 epod_id, u8 epod_state)\r\n{\r\nint r = 0;\r\nbool ram_retention = false;\r\nint i;\r\nBUG_ON(epod_id >= NUM_EPOD_ID);\r\nswitch (epod_id) {\r\ncase EPOD_ID_SVAMMDSP:\r\ncase EPOD_ID_SIAMMDSP:\r\ncase EPOD_ID_ESRAM12:\r\ncase EPOD_ID_ESRAM34:\r\nram_retention = true;\r\nbreak;\r\n}\r\nBUG_ON(epod_state > EPOD_STATE_ON);\r\nBUG_ON(epod_state == EPOD_STATE_RAMRET && !ram_retention);\r\nmutex_lock(&mb2_transfer.lock);\r\nwhile (readl(PRCM_MBOX_CPU_VAL) & MBOX_BIT(2))\r\ncpu_relax();\r\nfor (i = 0; i < NUM_EPOD_ID; i++)\r\nwriteb(EPOD_STATE_NO_CHANGE, (tcdm_base + PRCM_REQ_MB2 + i));\r\nwriteb(epod_state, (tcdm_base + PRCM_REQ_MB2 + epod_id));\r\nwriteb(MB2H_DPS, (tcdm_base + PRCM_MBOX_HEADER_REQ_MB2));\r\nwritel(MBOX_BIT(2), PRCM_MBOX_CPU_SET);\r\nif (!wait_for_completion_timeout(&mb2_transfer.work,\r\nmsecs_to_jiffies(20000))) {\r\npr_err("prcmu: %s timed out (20 s) waiting for a reply.\n",\r\n__func__);\r\nr = -EIO;\r\ngoto unlock_and_return;\r\n}\r\nif (mb2_transfer.ack.status != HWACC_PWR_ST_OK)\r\nr = -EIO;\r\nunlock_and_return:\r\nmutex_unlock(&mb2_transfer.lock);\r\nreturn r;\r\n}\r\nvoid prcmu_configure_auto_pm(struct prcmu_auto_pm_config *sleep,\r\nstruct prcmu_auto_pm_config *idle)\r\n{\r\nu32 sleep_cfg;\r\nu32 idle_cfg;\r\nunsigned long flags;\r\nBUG_ON((sleep == NULL) || (idle == NULL));\r\nsleep_cfg = (sleep->sva_auto_pm_enable & 0xF);\r\nsleep_cfg = ((sleep_cfg << 4) | (sleep->sia_auto_pm_enable & 0xF));\r\nsleep_cfg = ((sleep_cfg << 8) | (sleep->sva_power_on & 0xFF));\r\nsleep_cfg = ((sleep_cfg << 8) | (sleep->sia_power_on & 0xFF));\r\nsleep_cfg = ((sleep_cfg << 4) | (sleep->sva_policy & 0xF));\r\nsleep_cfg = ((sleep_cfg << 4) | (sleep->sia_policy & 0xF));\r\nidle_cfg = (idle->sva_auto_pm_enable & 0xF);\r\nidle_cfg = ((idle_cfg << 4) | (idle->sia_auto_pm_enable & 0xF));\r\nidle_cfg = ((idle_cfg << 8) | (idle->sva_power_on & 0xFF));\r\nidle_cfg = ((idle_cfg << 8) | (idle->sia_power_on & 0xFF));\r\nidle_cfg = ((idle_cfg << 4) | (idle->sva_policy & 0xF));\r\nidle_cfg = ((idle_cfg << 4) | (idle->sia_policy & 0xF));\r\nspin_lock_irqsave(&mb2_transfer.auto_pm_lock, flags);\r\nwritel(sleep_cfg, (tcdm_base + PRCM_REQ_MB2_AUTO_PM_SLEEP));\r\nwritel(idle_cfg, (tcdm_base + PRCM_REQ_MB2_AUTO_PM_IDLE));\r\nmb2_transfer.auto_pm_enabled =\r\n((sleep->sva_auto_pm_enable == PRCMU_AUTO_PM_ON) ||\r\n(sleep->sia_auto_pm_enable == PRCMU_AUTO_PM_ON) ||\r\n(idle->sva_auto_pm_enable == PRCMU_AUTO_PM_ON) ||\r\n(idle->sia_auto_pm_enable == PRCMU_AUTO_PM_ON));\r\nspin_unlock_irqrestore(&mb2_transfer.auto_pm_lock, flags);\r\n}\r\nbool prcmu_is_auto_pm_enabled(void)\r\n{\r\nreturn mb2_transfer.auto_pm_enabled;\r\n}\r\nstatic int request_sysclk(bool enable)\r\n{\r\nint r;\r\nunsigned long flags;\r\nr = 0;\r\nmutex_lock(&mb3_transfer.sysclk_lock);\r\nspin_lock_irqsave(&mb3_transfer.lock, flags);\r\nwhile (readl(PRCM_MBOX_CPU_VAL) & MBOX_BIT(3))\r\ncpu_relax();\r\nwriteb((enable ? ON : OFF), (tcdm_base + PRCM_REQ_MB3_SYSCLK_MGT));\r\nwriteb(MB3H_SYSCLK, (tcdm_base + PRCM_MBOX_HEADER_REQ_MB3));\r\nwritel(MBOX_BIT(3), PRCM_MBOX_CPU_SET);\r\nspin_unlock_irqrestore(&mb3_transfer.lock, flags);\r\nif (enable && !wait_for_completion_timeout(&mb3_transfer.sysclk_work,\r\nmsecs_to_jiffies(20000))) {\r\npr_err("prcmu: %s timed out (20 s) waiting for a reply.\n",\r\n__func__);\r\nr = -EIO;\r\n}\r\nmutex_unlock(&mb3_transfer.sysclk_lock);\r\nreturn r;\r\n}\r\nstatic int request_timclk(bool enable)\r\n{\r\nu32 val = (PRCM_TCR_DOZE_MODE | PRCM_TCR_TENSEL_MASK);\r\nif (!enable)\r\nval |= PRCM_TCR_STOP_TIMERS;\r\nwritel(val, PRCM_TCR);\r\nreturn 0;\r\n}\r\nstatic int request_clock(u8 clock, bool enable)\r\n{\r\nu32 val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&clk_mgt_lock, flags);\r\nwhile ((readl(PRCM_SEM) & PRCM_SEM_PRCM_SEM) != 0)\r\ncpu_relax();\r\nval = readl(prcmu_base + clk_mgt[clock].offset);\r\nif (enable) {\r\nval |= (PRCM_CLK_MGT_CLKEN | clk_mgt[clock].pllsw);\r\n} else {\r\nclk_mgt[clock].pllsw = (val & PRCM_CLK_MGT_CLKPLLSW_MASK);\r\nval &= ~(PRCM_CLK_MGT_CLKEN | PRCM_CLK_MGT_CLKPLLSW_MASK);\r\n}\r\nwritel(val, prcmu_base + clk_mgt[clock].offset);\r\nwritel(0, PRCM_SEM);\r\nspin_unlock_irqrestore(&clk_mgt_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int request_sga_clock(u8 clock, bool enable)\r\n{\r\nu32 val;\r\nint ret;\r\nif (enable) {\r\nval = readl(PRCM_CGATING_BYPASS);\r\nwritel(val | PRCM_CGATING_BYPASS_ICN2, PRCM_CGATING_BYPASS);\r\n}\r\nret = request_clock(clock, enable);\r\nif (!ret && !enable) {\r\nval = readl(PRCM_CGATING_BYPASS);\r\nwritel(val & ~PRCM_CGATING_BYPASS_ICN2, PRCM_CGATING_BYPASS);\r\n}\r\nreturn ret;\r\n}\r\nstatic inline bool plldsi_locked(void)\r\n{\r\nreturn (readl(PRCM_PLLDSI_LOCKP) &\r\n(PRCM_PLLDSI_LOCKP_PRCM_PLLDSI_LOCKP10 |\r\nPRCM_PLLDSI_LOCKP_PRCM_PLLDSI_LOCKP3)) ==\r\n(PRCM_PLLDSI_LOCKP_PRCM_PLLDSI_LOCKP10 |\r\nPRCM_PLLDSI_LOCKP_PRCM_PLLDSI_LOCKP3);\r\n}\r\nstatic int request_plldsi(bool enable)\r\n{\r\nint r = 0;\r\nu32 val;\r\nwritel((PRCM_MMIP_LS_CLAMP_DSIPLL_CLAMP |\r\nPRCM_MMIP_LS_CLAMP_DSIPLL_CLAMPI), (enable ?\r\nPRCM_MMIP_LS_CLAMP_CLR : PRCM_MMIP_LS_CLAMP_SET));\r\nval = readl(PRCM_PLLDSI_ENABLE);\r\nif (enable)\r\nval |= PRCM_PLLDSI_ENABLE_PRCM_PLLDSI_ENABLE;\r\nelse\r\nval &= ~PRCM_PLLDSI_ENABLE_PRCM_PLLDSI_ENABLE;\r\nwritel(val, PRCM_PLLDSI_ENABLE);\r\nif (enable) {\r\nunsigned int i;\r\nbool locked = plldsi_locked();\r\nfor (i = 10; !locked && (i > 0); --i) {\r\nudelay(100);\r\nlocked = plldsi_locked();\r\n}\r\nif (locked) {\r\nwritel(PRCM_APE_RESETN_DSIPLL_RESETN,\r\nPRCM_APE_RESETN_SET);\r\n} else {\r\nwritel((PRCM_MMIP_LS_CLAMP_DSIPLL_CLAMP |\r\nPRCM_MMIP_LS_CLAMP_DSIPLL_CLAMPI),\r\nPRCM_MMIP_LS_CLAMP_SET);\r\nval &= ~PRCM_PLLDSI_ENABLE_PRCM_PLLDSI_ENABLE;\r\nwritel(val, PRCM_PLLDSI_ENABLE);\r\nr = -EAGAIN;\r\n}\r\n} else {\r\nwritel(PRCM_APE_RESETN_DSIPLL_RESETN, PRCM_APE_RESETN_CLR);\r\n}\r\nreturn r;\r\n}\r\nstatic int request_dsiclk(u8 n, bool enable)\r\n{\r\nu32 val;\r\nval = readl(PRCM_DSI_PLLOUT_SEL);\r\nval &= ~dsiclk[n].divsel_mask;\r\nval |= ((enable ? dsiclk[n].divsel : PRCM_DSI_PLLOUT_SEL_OFF) <<\r\ndsiclk[n].divsel_shift);\r\nwritel(val, PRCM_DSI_PLLOUT_SEL);\r\nreturn 0;\r\n}\r\nstatic int request_dsiescclk(u8 n, bool enable)\r\n{\r\nu32 val;\r\nval = readl(PRCM_DSITVCLK_DIV);\r\nenable ? (val |= dsiescclk[n].en) : (val &= ~dsiescclk[n].en);\r\nwritel(val, PRCM_DSITVCLK_DIV);\r\nreturn 0;\r\n}\r\nint db8500_prcmu_request_clock(u8 clock, bool enable)\r\n{\r\nif (clock == PRCMU_SGACLK)\r\nreturn request_sga_clock(clock, enable);\r\nelse if (clock < PRCMU_NUM_REG_CLOCKS)\r\nreturn request_clock(clock, enable);\r\nelse if (clock == PRCMU_TIMCLK)\r\nreturn request_timclk(enable);\r\nelse if ((clock == PRCMU_DSI0CLK) || (clock == PRCMU_DSI1CLK))\r\nreturn request_dsiclk((clock - PRCMU_DSI0CLK), enable);\r\nelse if ((PRCMU_DSI0ESCCLK <= clock) && (clock <= PRCMU_DSI2ESCCLK))\r\nreturn request_dsiescclk((clock - PRCMU_DSI0ESCCLK), enable);\r\nelse if (clock == PRCMU_PLLDSI)\r\nreturn request_plldsi(enable);\r\nelse if (clock == PRCMU_SYSCLK)\r\nreturn request_sysclk(enable);\r\nelse if ((clock == PRCMU_PLLSOC0) || (clock == PRCMU_PLLSOC1))\r\nreturn request_pll(clock, enable);\r\nelse\r\nreturn -EINVAL;\r\n}\r\nstatic unsigned long pll_rate(void __iomem *reg, unsigned long src_rate,\r\nint branch)\r\n{\r\nu64 rate;\r\nu32 val;\r\nu32 d;\r\nu32 div = 1;\r\nval = readl(reg);\r\nrate = src_rate;\r\nrate *= ((val & PRCM_PLL_FREQ_D_MASK) >> PRCM_PLL_FREQ_D_SHIFT);\r\nd = ((val & PRCM_PLL_FREQ_N_MASK) >> PRCM_PLL_FREQ_N_SHIFT);\r\nif (d > 1)\r\ndiv *= d;\r\nd = ((val & PRCM_PLL_FREQ_R_MASK) >> PRCM_PLL_FREQ_R_SHIFT);\r\nif (d > 1)\r\ndiv *= d;\r\nif (val & PRCM_PLL_FREQ_SELDIV2)\r\ndiv *= 2;\r\nif ((branch == PLL_FIX) || ((branch == PLL_DIV) &&\r\n(val & PRCM_PLL_FREQ_DIV2EN) &&\r\n((reg == PRCM_PLLSOC0_FREQ) ||\r\n(reg == PRCM_PLLARM_FREQ) ||\r\n(reg == PRCM_PLLDDR_FREQ))))\r\ndiv *= 2;\r\n(void)do_div(rate, div);\r\nreturn (unsigned long)rate;\r\n}\r\nstatic unsigned long clock_rate(u8 clock)\r\n{\r\nu32 val;\r\nu32 pllsw;\r\nunsigned long rate = ROOT_CLOCK_RATE;\r\nval = readl(prcmu_base + clk_mgt[clock].offset);\r\nif (val & PRCM_CLK_MGT_CLK38) {\r\nif (clk_mgt[clock].clk38div && (val & PRCM_CLK_MGT_CLK38DIV))\r\nrate /= 2;\r\nreturn rate;\r\n}\r\nval |= clk_mgt[clock].pllsw;\r\npllsw = (val & PRCM_CLK_MGT_CLKPLLSW_MASK);\r\nif (pllsw == PRCM_CLK_MGT_CLKPLLSW_SOC0)\r\nrate = pll_rate(PRCM_PLLSOC0_FREQ, rate, clk_mgt[clock].branch);\r\nelse if (pllsw == PRCM_CLK_MGT_CLKPLLSW_SOC1)\r\nrate = pll_rate(PRCM_PLLSOC1_FREQ, rate, clk_mgt[clock].branch);\r\nelse if (pllsw == PRCM_CLK_MGT_CLKPLLSW_DDR)\r\nrate = pll_rate(PRCM_PLLDDR_FREQ, rate, clk_mgt[clock].branch);\r\nelse\r\nreturn 0;\r\nif ((clock == PRCMU_SGACLK) &&\r\n(val & PRCM_SGACLK_MGT_SGACLKDIV_BY_2_5_EN)) {\r\nu64 r = (rate * 10);\r\n(void)do_div(r, 25);\r\nreturn (unsigned long)r;\r\n}\r\nval &= PRCM_CLK_MGT_CLKPLLDIV_MASK;\r\nif (val)\r\nreturn rate / val;\r\nelse\r\nreturn 0;\r\n}\r\nstatic unsigned long armss_rate(void)\r\n{\r\nu32 r;\r\nunsigned long rate;\r\nr = readl(PRCM_ARM_CHGCLKREQ);\r\nif (r & PRCM_ARM_CHGCLKREQ_PRCM_ARM_CHGCLKREQ) {\r\nrate = pll_rate(PRCM_PLLDDR_FREQ, ROOT_CLOCK_RATE, PLL_FIX);\r\nif (!(r & PRCM_ARM_CHGCLKREQ_PRCM_ARM_DIVSEL))\r\nrate /= 2;\r\nr = readl(PRCM_ARMCLKFIX_MGT);\r\nr &= PRCM_CLK_MGT_CLKPLLDIV_MASK;\r\nrate /= r;\r\n} else {\r\nrate = pll_rate(PRCM_PLLARM_FREQ, ROOT_CLOCK_RATE, PLL_DIV);\r\n}\r\nreturn rate;\r\n}\r\nstatic unsigned long dsiclk_rate(u8 n)\r\n{\r\nu32 divsel;\r\nu32 div = 1;\r\ndivsel = readl(PRCM_DSI_PLLOUT_SEL);\r\ndivsel = ((divsel & dsiclk[n].divsel_mask) >> dsiclk[n].divsel_shift);\r\nif (divsel == PRCM_DSI_PLLOUT_SEL_OFF)\r\ndivsel = dsiclk[n].divsel;\r\nelse\r\ndsiclk[n].divsel = divsel;\r\nswitch (divsel) {\r\ncase PRCM_DSI_PLLOUT_SEL_PHI_4:\r\ndiv *= 2;\r\ncase PRCM_DSI_PLLOUT_SEL_PHI_2:\r\ndiv *= 2;\r\ncase PRCM_DSI_PLLOUT_SEL_PHI:\r\nreturn pll_rate(PRCM_PLLDSI_FREQ, clock_rate(PRCMU_HDMICLK),\r\nPLL_RAW) / div;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic unsigned long dsiescclk_rate(u8 n)\r\n{\r\nu32 div;\r\ndiv = readl(PRCM_DSITVCLK_DIV);\r\ndiv = ((div & dsiescclk[n].div_mask) >> (dsiescclk[n].div_shift));\r\nreturn clock_rate(PRCMU_TVCLK) / max((u32)1, div);\r\n}\r\nunsigned long prcmu_clock_rate(u8 clock)\r\n{\r\nif (clock < PRCMU_NUM_REG_CLOCKS)\r\nreturn clock_rate(clock);\r\nelse if (clock == PRCMU_TIMCLK)\r\nreturn ROOT_CLOCK_RATE / 16;\r\nelse if (clock == PRCMU_SYSCLK)\r\nreturn ROOT_CLOCK_RATE;\r\nelse if (clock == PRCMU_PLLSOC0)\r\nreturn pll_rate(PRCM_PLLSOC0_FREQ, ROOT_CLOCK_RATE, PLL_RAW);\r\nelse if (clock == PRCMU_PLLSOC1)\r\nreturn pll_rate(PRCM_PLLSOC1_FREQ, ROOT_CLOCK_RATE, PLL_RAW);\r\nelse if (clock == PRCMU_ARMSS)\r\nreturn armss_rate();\r\nelse if (clock == PRCMU_PLLDDR)\r\nreturn pll_rate(PRCM_PLLDDR_FREQ, ROOT_CLOCK_RATE, PLL_RAW);\r\nelse if (clock == PRCMU_PLLDSI)\r\nreturn pll_rate(PRCM_PLLDSI_FREQ, clock_rate(PRCMU_HDMICLK),\r\nPLL_RAW);\r\nelse if ((clock == PRCMU_DSI0CLK) || (clock == PRCMU_DSI1CLK))\r\nreturn dsiclk_rate(clock - PRCMU_DSI0CLK);\r\nelse if ((PRCMU_DSI0ESCCLK <= clock) && (clock <= PRCMU_DSI2ESCCLK))\r\nreturn dsiescclk_rate(clock - PRCMU_DSI0ESCCLK);\r\nelse\r\nreturn 0;\r\n}\r\nstatic unsigned long clock_source_rate(u32 clk_mgt_val, int branch)\r\n{\r\nif (clk_mgt_val & PRCM_CLK_MGT_CLK38)\r\nreturn ROOT_CLOCK_RATE;\r\nclk_mgt_val &= PRCM_CLK_MGT_CLKPLLSW_MASK;\r\nif (clk_mgt_val == PRCM_CLK_MGT_CLKPLLSW_SOC0)\r\nreturn pll_rate(PRCM_PLLSOC0_FREQ, ROOT_CLOCK_RATE, branch);\r\nelse if (clk_mgt_val == PRCM_CLK_MGT_CLKPLLSW_SOC1)\r\nreturn pll_rate(PRCM_PLLSOC1_FREQ, ROOT_CLOCK_RATE, branch);\r\nelse if (clk_mgt_val == PRCM_CLK_MGT_CLKPLLSW_DDR)\r\nreturn pll_rate(PRCM_PLLDDR_FREQ, ROOT_CLOCK_RATE, branch);\r\nelse\r\nreturn 0;\r\n}\r\nstatic u32 clock_divider(unsigned long src_rate, unsigned long rate)\r\n{\r\nu32 div;\r\ndiv = (src_rate / rate);\r\nif (div == 0)\r\nreturn 1;\r\nif (rate < (src_rate / div))\r\ndiv++;\r\nreturn div;\r\n}\r\nstatic long round_clock_rate(u8 clock, unsigned long rate)\r\n{\r\nu32 val;\r\nu32 div;\r\nunsigned long src_rate;\r\nlong rounded_rate;\r\nval = readl(prcmu_base + clk_mgt[clock].offset);\r\nsrc_rate = clock_source_rate((val | clk_mgt[clock].pllsw),\r\nclk_mgt[clock].branch);\r\ndiv = clock_divider(src_rate, rate);\r\nif (val & PRCM_CLK_MGT_CLK38) {\r\nif (clk_mgt[clock].clk38div) {\r\nif (div > 2)\r\ndiv = 2;\r\n} else {\r\ndiv = 1;\r\n}\r\n} else if ((clock == PRCMU_SGACLK) && (div == 3)) {\r\nu64 r = (src_rate * 10);\r\n(void)do_div(r, 25);\r\nif (r <= rate)\r\nreturn (unsigned long)r;\r\n}\r\nrounded_rate = (src_rate / min(div, (u32)31));\r\nreturn rounded_rate;\r\n}\r\nstatic long round_armss_rate(unsigned long rate)\r\n{\r\nstruct cpufreq_frequency_table *pos;\r\nlong freq = 0;\r\nrate = rate / 1000;\r\ncpufreq_for_each_entry(pos, db8500_cpufreq_table) {\r\nfreq = pos->frequency;\r\nif (freq == rate)\r\nbreak;\r\n}\r\nreturn freq * 1000;\r\n}\r\nstatic long round_plldsi_rate(unsigned long rate)\r\n{\r\nlong rounded_rate = 0;\r\nunsigned long src_rate;\r\nunsigned long rem;\r\nu32 r;\r\nsrc_rate = clock_rate(PRCMU_HDMICLK);\r\nrem = rate;\r\nfor (r = 7; (rem > 0) && (r > 0); r--) {\r\nu64 d;\r\nd = (r * rate);\r\n(void)do_div(d, src_rate);\r\nif (d < 6)\r\nd = 6;\r\nelse if (d > 255)\r\nd = 255;\r\nd *= src_rate;\r\nif (((2 * d) < (r * MIN_PLL_VCO_RATE)) ||\r\n((r * MAX_PLL_VCO_RATE) < (2 * d)))\r\ncontinue;\r\n(void)do_div(d, r);\r\nif (rate < d) {\r\nif (rounded_rate == 0)\r\nrounded_rate = (long)d;\r\nbreak;\r\n}\r\nif ((rate - d) < rem) {\r\nrem = (rate - d);\r\nrounded_rate = (long)d;\r\n}\r\n}\r\nreturn rounded_rate;\r\n}\r\nstatic long round_dsiclk_rate(unsigned long rate)\r\n{\r\nu32 div;\r\nunsigned long src_rate;\r\nlong rounded_rate;\r\nsrc_rate = pll_rate(PRCM_PLLDSI_FREQ, clock_rate(PRCMU_HDMICLK),\r\nPLL_RAW);\r\ndiv = clock_divider(src_rate, rate);\r\nrounded_rate = (src_rate / ((div > 2) ? 4 : div));\r\nreturn rounded_rate;\r\n}\r\nstatic long round_dsiescclk_rate(unsigned long rate)\r\n{\r\nu32 div;\r\nunsigned long src_rate;\r\nlong rounded_rate;\r\nsrc_rate = clock_rate(PRCMU_TVCLK);\r\ndiv = clock_divider(src_rate, rate);\r\nrounded_rate = (src_rate / min(div, (u32)255));\r\nreturn rounded_rate;\r\n}\r\nlong prcmu_round_clock_rate(u8 clock, unsigned long rate)\r\n{\r\nif (clock < PRCMU_NUM_REG_CLOCKS)\r\nreturn round_clock_rate(clock, rate);\r\nelse if (clock == PRCMU_ARMSS)\r\nreturn round_armss_rate(rate);\r\nelse if (clock == PRCMU_PLLDSI)\r\nreturn round_plldsi_rate(rate);\r\nelse if ((clock == PRCMU_DSI0CLK) || (clock == PRCMU_DSI1CLK))\r\nreturn round_dsiclk_rate(rate);\r\nelse if ((PRCMU_DSI0ESCCLK <= clock) && (clock <= PRCMU_DSI2ESCCLK))\r\nreturn round_dsiescclk_rate(rate);\r\nelse\r\nreturn (long)prcmu_clock_rate(clock);\r\n}\r\nstatic void set_clock_rate(u8 clock, unsigned long rate)\r\n{\r\nu32 val;\r\nu32 div;\r\nunsigned long src_rate;\r\nunsigned long flags;\r\nspin_lock_irqsave(&clk_mgt_lock, flags);\r\nwhile ((readl(PRCM_SEM) & PRCM_SEM_PRCM_SEM) != 0)\r\ncpu_relax();\r\nval = readl(prcmu_base + clk_mgt[clock].offset);\r\nsrc_rate = clock_source_rate((val | clk_mgt[clock].pllsw),\r\nclk_mgt[clock].branch);\r\ndiv = clock_divider(src_rate, rate);\r\nif (val & PRCM_CLK_MGT_CLK38) {\r\nif (clk_mgt[clock].clk38div) {\r\nif (div > 1)\r\nval |= PRCM_CLK_MGT_CLK38DIV;\r\nelse\r\nval &= ~PRCM_CLK_MGT_CLK38DIV;\r\n}\r\n} else if (clock == PRCMU_SGACLK) {\r\nval &= ~(PRCM_CLK_MGT_CLKPLLDIV_MASK |\r\nPRCM_SGACLK_MGT_SGACLKDIV_BY_2_5_EN);\r\nif (div == 3) {\r\nu64 r = (src_rate * 10);\r\n(void)do_div(r, 25);\r\nif (r <= rate) {\r\nval |= PRCM_SGACLK_MGT_SGACLKDIV_BY_2_5_EN;\r\ndiv = 0;\r\n}\r\n}\r\nval |= min(div, (u32)31);\r\n} else {\r\nval &= ~PRCM_CLK_MGT_CLKPLLDIV_MASK;\r\nval |= min(div, (u32)31);\r\n}\r\nwritel(val, prcmu_base + clk_mgt[clock].offset);\r\nwritel(0, PRCM_SEM);\r\nspin_unlock_irqrestore(&clk_mgt_lock, flags);\r\n}\r\nstatic int set_armss_rate(unsigned long rate)\r\n{\r\nstruct cpufreq_frequency_table *pos;\r\nrate = rate / 1000;\r\ncpufreq_for_each_entry(pos, db8500_cpufreq_table)\r\nif (pos->frequency == rate)\r\nbreak;\r\nif (pos->frequency != rate)\r\nreturn -EINVAL;\r\nreturn db8500_prcmu_set_arm_opp(pos->driver_data);\r\n}\r\nstatic int set_plldsi_rate(unsigned long rate)\r\n{\r\nunsigned long src_rate;\r\nunsigned long rem;\r\nu32 pll_freq = 0;\r\nu32 r;\r\nsrc_rate = clock_rate(PRCMU_HDMICLK);\r\nrem = rate;\r\nfor (r = 7; (rem > 0) && (r > 0); r--) {\r\nu64 d;\r\nu64 hwrate;\r\nd = (r * rate);\r\n(void)do_div(d, src_rate);\r\nif (d < 6)\r\nd = 6;\r\nelse if (d > 255)\r\nd = 255;\r\nhwrate = (d * src_rate);\r\nif (((2 * hwrate) < (r * MIN_PLL_VCO_RATE)) ||\r\n((r * MAX_PLL_VCO_RATE) < (2 * hwrate)))\r\ncontinue;\r\n(void)do_div(hwrate, r);\r\nif (rate < hwrate) {\r\nif (pll_freq == 0)\r\npll_freq = (((u32)d << PRCM_PLL_FREQ_D_SHIFT) |\r\n(r << PRCM_PLL_FREQ_R_SHIFT));\r\nbreak;\r\n}\r\nif ((rate - hwrate) < rem) {\r\nrem = (rate - hwrate);\r\npll_freq = (((u32)d << PRCM_PLL_FREQ_D_SHIFT) |\r\n(r << PRCM_PLL_FREQ_R_SHIFT));\r\n}\r\n}\r\nif (pll_freq == 0)\r\nreturn -EINVAL;\r\npll_freq |= (1 << PRCM_PLL_FREQ_N_SHIFT);\r\nwritel(pll_freq, PRCM_PLLDSI_FREQ);\r\nreturn 0;\r\n}\r\nstatic void set_dsiclk_rate(u8 n, unsigned long rate)\r\n{\r\nu32 val;\r\nu32 div;\r\ndiv = clock_divider(pll_rate(PRCM_PLLDSI_FREQ,\r\nclock_rate(PRCMU_HDMICLK), PLL_RAW), rate);\r\ndsiclk[n].divsel = (div == 1) ? PRCM_DSI_PLLOUT_SEL_PHI :\r\n(div == 2) ? PRCM_DSI_PLLOUT_SEL_PHI_2 :\r\nPRCM_DSI_PLLOUT_SEL_PHI_4;\r\nval = readl(PRCM_DSI_PLLOUT_SEL);\r\nval &= ~dsiclk[n].divsel_mask;\r\nval |= (dsiclk[n].divsel << dsiclk[n].divsel_shift);\r\nwritel(val, PRCM_DSI_PLLOUT_SEL);\r\n}\r\nstatic void set_dsiescclk_rate(u8 n, unsigned long rate)\r\n{\r\nu32 val;\r\nu32 div;\r\ndiv = clock_divider(clock_rate(PRCMU_TVCLK), rate);\r\nval = readl(PRCM_DSITVCLK_DIV);\r\nval &= ~dsiescclk[n].div_mask;\r\nval |= (min(div, (u32)255) << dsiescclk[n].div_shift);\r\nwritel(val, PRCM_DSITVCLK_DIV);\r\n}\r\nint prcmu_set_clock_rate(u8 clock, unsigned long rate)\r\n{\r\nif (clock < PRCMU_NUM_REG_CLOCKS)\r\nset_clock_rate(clock, rate);\r\nelse if (clock == PRCMU_ARMSS)\r\nreturn set_armss_rate(rate);\r\nelse if (clock == PRCMU_PLLDSI)\r\nreturn set_plldsi_rate(rate);\r\nelse if ((clock == PRCMU_DSI0CLK) || (clock == PRCMU_DSI1CLK))\r\nset_dsiclk_rate((clock - PRCMU_DSI0CLK), rate);\r\nelse if ((PRCMU_DSI0ESCCLK <= clock) && (clock <= PRCMU_DSI2ESCCLK))\r\nset_dsiescclk_rate((clock - PRCMU_DSI0ESCCLK), rate);\r\nreturn 0;\r\n}\r\nint db8500_prcmu_config_esram0_deep_sleep(u8 state)\r\n{\r\nif ((state > ESRAM0_DEEP_SLEEP_STATE_RET) ||\r\n(state < ESRAM0_DEEP_SLEEP_STATE_OFF))\r\nreturn -EINVAL;\r\nmutex_lock(&mb4_transfer.lock);\r\nwhile (readl(PRCM_MBOX_CPU_VAL) & MBOX_BIT(4))\r\ncpu_relax();\r\nwriteb(MB4H_MEM_ST, (tcdm_base + PRCM_MBOX_HEADER_REQ_MB4));\r\nwriteb(((DDR_PWR_STATE_OFFHIGHLAT << 4) | DDR_PWR_STATE_ON),\r\n(tcdm_base + PRCM_REQ_MB4_DDR_ST_AP_SLEEP_IDLE));\r\nwriteb(DDR_PWR_STATE_ON,\r\n(tcdm_base + PRCM_REQ_MB4_DDR_ST_AP_DEEP_IDLE));\r\nwriteb(state, (tcdm_base + PRCM_REQ_MB4_ESRAM0_ST));\r\nwritel(MBOX_BIT(4), PRCM_MBOX_CPU_SET);\r\nwait_for_completion(&mb4_transfer.work);\r\nmutex_unlock(&mb4_transfer.lock);\r\nreturn 0;\r\n}\r\nint db8500_prcmu_config_hotdog(u8 threshold)\r\n{\r\nmutex_lock(&mb4_transfer.lock);\r\nwhile (readl(PRCM_MBOX_CPU_VAL) & MBOX_BIT(4))\r\ncpu_relax();\r\nwriteb(threshold, (tcdm_base + PRCM_REQ_MB4_HOTDOG_THRESHOLD));\r\nwriteb(MB4H_HOTDOG, (tcdm_base + PRCM_MBOX_HEADER_REQ_MB4));\r\nwritel(MBOX_BIT(4), PRCM_MBOX_CPU_SET);\r\nwait_for_completion(&mb4_transfer.work);\r\nmutex_unlock(&mb4_transfer.lock);\r\nreturn 0;\r\n}\r\nint db8500_prcmu_config_hotmon(u8 low, u8 high)\r\n{\r\nmutex_lock(&mb4_transfer.lock);\r\nwhile (readl(PRCM_MBOX_CPU_VAL) & MBOX_BIT(4))\r\ncpu_relax();\r\nwriteb(low, (tcdm_base + PRCM_REQ_MB4_HOTMON_LOW));\r\nwriteb(high, (tcdm_base + PRCM_REQ_MB4_HOTMON_HIGH));\r\nwriteb((HOTMON_CONFIG_LOW | HOTMON_CONFIG_HIGH),\r\n(tcdm_base + PRCM_REQ_MB4_HOTMON_CONFIG));\r\nwriteb(MB4H_HOTMON, (tcdm_base + PRCM_MBOX_HEADER_REQ_MB4));\r\nwritel(MBOX_BIT(4), PRCM_MBOX_CPU_SET);\r\nwait_for_completion(&mb4_transfer.work);\r\nmutex_unlock(&mb4_transfer.lock);\r\nreturn 0;\r\n}\r\nstatic int config_hot_period(u16 val)\r\n{\r\nmutex_lock(&mb4_transfer.lock);\r\nwhile (readl(PRCM_MBOX_CPU_VAL) & MBOX_BIT(4))\r\ncpu_relax();\r\nwritew(val, (tcdm_base + PRCM_REQ_MB4_HOT_PERIOD));\r\nwriteb(MB4H_HOT_PERIOD, (tcdm_base + PRCM_MBOX_HEADER_REQ_MB4));\r\nwritel(MBOX_BIT(4), PRCM_MBOX_CPU_SET);\r\nwait_for_completion(&mb4_transfer.work);\r\nmutex_unlock(&mb4_transfer.lock);\r\nreturn 0;\r\n}\r\nint db8500_prcmu_start_temp_sense(u16 cycles32k)\r\n{\r\nif (cycles32k == 0xFFFF)\r\nreturn -EINVAL;\r\nreturn config_hot_period(cycles32k);\r\n}\r\nint db8500_prcmu_stop_temp_sense(void)\r\n{\r\nreturn config_hot_period(0xFFFF);\r\n}\r\nstatic int prcmu_a9wdog(u8 cmd, u8 d0, u8 d1, u8 d2, u8 d3)\r\n{\r\nmutex_lock(&mb4_transfer.lock);\r\nwhile (readl(PRCM_MBOX_CPU_VAL) & MBOX_BIT(4))\r\ncpu_relax();\r\nwriteb(d0, (tcdm_base + PRCM_REQ_MB4_A9WDOG_0));\r\nwriteb(d1, (tcdm_base + PRCM_REQ_MB4_A9WDOG_1));\r\nwriteb(d2, (tcdm_base + PRCM_REQ_MB4_A9WDOG_2));\r\nwriteb(d3, (tcdm_base + PRCM_REQ_MB4_A9WDOG_3));\r\nwriteb(cmd, (tcdm_base + PRCM_MBOX_HEADER_REQ_MB4));\r\nwritel(MBOX_BIT(4), PRCM_MBOX_CPU_SET);\r\nwait_for_completion(&mb4_transfer.work);\r\nmutex_unlock(&mb4_transfer.lock);\r\nreturn 0;\r\n}\r\nint db8500_prcmu_config_a9wdog(u8 num, bool sleep_auto_off)\r\n{\r\nBUG_ON(num == 0 || num > 0xf);\r\nreturn prcmu_a9wdog(MB4H_A9WDOG_CONF, num, 0, 0,\r\nsleep_auto_off ? A9WDOG_AUTO_OFF_EN :\r\nA9WDOG_AUTO_OFF_DIS);\r\n}\r\nint db8500_prcmu_enable_a9wdog(u8 id)\r\n{\r\nreturn prcmu_a9wdog(MB4H_A9WDOG_EN, id, 0, 0, 0);\r\n}\r\nint db8500_prcmu_disable_a9wdog(u8 id)\r\n{\r\nreturn prcmu_a9wdog(MB4H_A9WDOG_DIS, id, 0, 0, 0);\r\n}\r\nint db8500_prcmu_kick_a9wdog(u8 id)\r\n{\r\nreturn prcmu_a9wdog(MB4H_A9WDOG_KICK, id, 0, 0, 0);\r\n}\r\nint db8500_prcmu_load_a9wdog(u8 id, u32 timeout)\r\n{\r\nreturn prcmu_a9wdog(MB4H_A9WDOG_LOAD,\r\n(id & A9WDOG_ID_MASK) |\r\n(u8)((timeout << 4) & 0xf0),\r\n(u8)((timeout >> 4) & 0xff),\r\n(u8)((timeout >> 12) & 0xff),\r\n(u8)((timeout >> 20) & 0xff));\r\n}\r\nint prcmu_abb_read(u8 slave, u8 reg, u8 *value, u8 size)\r\n{\r\nint r;\r\nif (size != 1)\r\nreturn -EINVAL;\r\nmutex_lock(&mb5_transfer.lock);\r\nwhile (readl(PRCM_MBOX_CPU_VAL) & MBOX_BIT(5))\r\ncpu_relax();\r\nwriteb(0, (tcdm_base + PRCM_MBOX_HEADER_REQ_MB5));\r\nwriteb(PRCMU_I2C_READ(slave), (tcdm_base + PRCM_REQ_MB5_I2C_SLAVE_OP));\r\nwriteb(PRCMU_I2C_STOP_EN, (tcdm_base + PRCM_REQ_MB5_I2C_HW_BITS));\r\nwriteb(reg, (tcdm_base + PRCM_REQ_MB5_I2C_REG));\r\nwriteb(0, (tcdm_base + PRCM_REQ_MB5_I2C_VAL));\r\nwritel(MBOX_BIT(5), PRCM_MBOX_CPU_SET);\r\nif (!wait_for_completion_timeout(&mb5_transfer.work,\r\nmsecs_to_jiffies(20000))) {\r\npr_err("prcmu: %s timed out (20 s) waiting for a reply.\n",\r\n__func__);\r\nr = -EIO;\r\n} else {\r\nr = ((mb5_transfer.ack.status == I2C_RD_OK) ? 0 : -EIO);\r\n}\r\nif (!r)\r\n*value = mb5_transfer.ack.value;\r\nmutex_unlock(&mb5_transfer.lock);\r\nreturn r;\r\n}\r\nint prcmu_abb_write_masked(u8 slave, u8 reg, u8 *value, u8 *mask, u8 size)\r\n{\r\nint r;\r\nif (size != 1)\r\nreturn -EINVAL;\r\nmutex_lock(&mb5_transfer.lock);\r\nwhile (readl(PRCM_MBOX_CPU_VAL) & MBOX_BIT(5))\r\ncpu_relax();\r\nwriteb(~*mask, (tcdm_base + PRCM_MBOX_HEADER_REQ_MB5));\r\nwriteb(PRCMU_I2C_WRITE(slave), (tcdm_base + PRCM_REQ_MB5_I2C_SLAVE_OP));\r\nwriteb(PRCMU_I2C_STOP_EN, (tcdm_base + PRCM_REQ_MB5_I2C_HW_BITS));\r\nwriteb(reg, (tcdm_base + PRCM_REQ_MB5_I2C_REG));\r\nwriteb(*value, (tcdm_base + PRCM_REQ_MB5_I2C_VAL));\r\nwritel(MBOX_BIT(5), PRCM_MBOX_CPU_SET);\r\nif (!wait_for_completion_timeout(&mb5_transfer.work,\r\nmsecs_to_jiffies(20000))) {\r\npr_err("prcmu: %s timed out (20 s) waiting for a reply.\n",\r\n__func__);\r\nr = -EIO;\r\n} else {\r\nr = ((mb5_transfer.ack.status == I2C_WR_OK) ? 0 : -EIO);\r\n}\r\nmutex_unlock(&mb5_transfer.lock);\r\nreturn r;\r\n}\r\nint prcmu_abb_write(u8 slave, u8 reg, u8 *value, u8 size)\r\n{\r\nu8 mask = ~0;\r\nreturn prcmu_abb_write_masked(slave, reg, value, &mask, size);\r\n}\r\nint prcmu_ac_wake_req(void)\r\n{\r\nu32 val;\r\nint ret = 0;\r\nmutex_lock(&mb0_transfer.ac_wake_lock);\r\nval = readl(PRCM_HOSTACCESS_REQ);\r\nif (val & PRCM_HOSTACCESS_REQ_HOSTACCESS_REQ)\r\ngoto unlock_and_return;\r\natomic_set(&ac_wake_req_state, 1);\r\nval |= PRCM_HOSTACCESS_REQ_WAKE_REQ;\r\nwritel(val, PRCM_HOSTACCESS_REQ);\r\nudelay(31);\r\nval |= PRCM_HOSTACCESS_REQ_HOSTACCESS_REQ;\r\nwritel(val, PRCM_HOSTACCESS_REQ);\r\nif (!wait_for_completion_timeout(&mb0_transfer.ac_wake_work,\r\nmsecs_to_jiffies(5000))) {\r\npr_crit("prcmu: %s timed out (5 s) waiting for a reply.\n",\r\n__func__);\r\nret = -EFAULT;\r\n}\r\nunlock_and_return:\r\nmutex_unlock(&mb0_transfer.ac_wake_lock);\r\nreturn ret;\r\n}\r\nvoid prcmu_ac_sleep_req(void)\r\n{\r\nu32 val;\r\nmutex_lock(&mb0_transfer.ac_wake_lock);\r\nval = readl(PRCM_HOSTACCESS_REQ);\r\nif (!(val & PRCM_HOSTACCESS_REQ_HOSTACCESS_REQ))\r\ngoto unlock_and_return;\r\nwritel((val & ~PRCM_HOSTACCESS_REQ_HOSTACCESS_REQ),\r\nPRCM_HOSTACCESS_REQ);\r\nif (!wait_for_completion_timeout(&mb0_transfer.ac_wake_work,\r\nmsecs_to_jiffies(5000))) {\r\npr_crit("prcmu: %s timed out (5 s) waiting for a reply.\n",\r\n__func__);\r\n}\r\natomic_set(&ac_wake_req_state, 0);\r\nunlock_and_return:\r\nmutex_unlock(&mb0_transfer.ac_wake_lock);\r\n}\r\nbool db8500_prcmu_is_ac_wake_requested(void)\r\n{\r\nreturn (atomic_read(&ac_wake_req_state) != 0);\r\n}\r\nvoid db8500_prcmu_system_reset(u16 reset_code)\r\n{\r\nwritew(reset_code, (tcdm_base + PRCM_SW_RST_REASON));\r\nwritel(1, PRCM_APE_SOFTRST);\r\n}\r\nu16 db8500_prcmu_get_reset_code(void)\r\n{\r\nreturn readw(tcdm_base + PRCM_SW_RST_REASON);\r\n}\r\nvoid db8500_prcmu_modem_reset(void)\r\n{\r\nmutex_lock(&mb1_transfer.lock);\r\nwhile (readl(PRCM_MBOX_CPU_VAL) & MBOX_BIT(1))\r\ncpu_relax();\r\nwriteb(MB1H_RESET_MODEM, (tcdm_base + PRCM_MBOX_HEADER_REQ_MB1));\r\nwritel(MBOX_BIT(1), PRCM_MBOX_CPU_SET);\r\nwait_for_completion(&mb1_transfer.work);\r\nmutex_unlock(&mb1_transfer.lock);\r\n}\r\nstatic void ack_dbb_wakeup(void)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&mb0_transfer.lock, flags);\r\nwhile (readl(PRCM_MBOX_CPU_VAL) & MBOX_BIT(0))\r\ncpu_relax();\r\nwriteb(MB0H_READ_WAKEUP_ACK, (tcdm_base + PRCM_MBOX_HEADER_REQ_MB0));\r\nwritel(MBOX_BIT(0), PRCM_MBOX_CPU_SET);\r\nspin_unlock_irqrestore(&mb0_transfer.lock, flags);\r\n}\r\nstatic inline void print_unknown_header_warning(u8 n, u8 header)\r\n{\r\npr_warning("prcmu: Unknown message header (%d) in mailbox %d.\n",\r\nheader, n);\r\n}\r\nstatic bool read_mailbox_0(void)\r\n{\r\nbool r;\r\nu32 ev;\r\nunsigned int n;\r\nu8 header;\r\nheader = readb(tcdm_base + PRCM_MBOX_HEADER_ACK_MB0);\r\nswitch (header) {\r\ncase MB0H_WAKEUP_EXE:\r\ncase MB0H_WAKEUP_SLEEP:\r\nif (readb(tcdm_base + PRCM_ACK_MB0_READ_POINTER) & 1)\r\nev = readl(tcdm_base + PRCM_ACK_MB0_WAKEUP_1_8500);\r\nelse\r\nev = readl(tcdm_base + PRCM_ACK_MB0_WAKEUP_0_8500);\r\nif (ev & (WAKEUP_BIT_AC_WAKE_ACK | WAKEUP_BIT_AC_SLEEP_ACK))\r\ncomplete(&mb0_transfer.ac_wake_work);\r\nif (ev & WAKEUP_BIT_SYSCLK_OK)\r\ncomplete(&mb3_transfer.sysclk_work);\r\nev &= mb0_transfer.req.dbb_irqs;\r\nfor (n = 0; n < NUM_PRCMU_WAKEUPS; n++) {\r\nif (ev & prcmu_irq_bit[n])\r\ngeneric_handle_irq(irq_find_mapping(db8500_irq_domain, n));\r\n}\r\nr = true;\r\nbreak;\r\ndefault:\r\nprint_unknown_header_warning(0, header);\r\nr = false;\r\nbreak;\r\n}\r\nwritel(MBOX_BIT(0), PRCM_ARM_IT1_CLR);\r\nreturn r;\r\n}\r\nstatic bool read_mailbox_1(void)\r\n{\r\nmb1_transfer.ack.header = readb(tcdm_base + PRCM_MBOX_HEADER_REQ_MB1);\r\nmb1_transfer.ack.arm_opp = readb(tcdm_base +\r\nPRCM_ACK_MB1_CURRENT_ARM_OPP);\r\nmb1_transfer.ack.ape_opp = readb(tcdm_base +\r\nPRCM_ACK_MB1_CURRENT_APE_OPP);\r\nmb1_transfer.ack.ape_voltage_status = readb(tcdm_base +\r\nPRCM_ACK_MB1_APE_VOLTAGE_STATUS);\r\nwritel(MBOX_BIT(1), PRCM_ARM_IT1_CLR);\r\ncomplete(&mb1_transfer.work);\r\nreturn false;\r\n}\r\nstatic bool read_mailbox_2(void)\r\n{\r\nmb2_transfer.ack.status = readb(tcdm_base + PRCM_ACK_MB2_DPS_STATUS);\r\nwritel(MBOX_BIT(2), PRCM_ARM_IT1_CLR);\r\ncomplete(&mb2_transfer.work);\r\nreturn false;\r\n}\r\nstatic bool read_mailbox_3(void)\r\n{\r\nwritel(MBOX_BIT(3), PRCM_ARM_IT1_CLR);\r\nreturn false;\r\n}\r\nstatic bool read_mailbox_4(void)\r\n{\r\nu8 header;\r\nbool do_complete = true;\r\nheader = readb(tcdm_base + PRCM_MBOX_HEADER_REQ_MB4);\r\nswitch (header) {\r\ncase MB4H_MEM_ST:\r\ncase MB4H_HOTDOG:\r\ncase MB4H_HOTMON:\r\ncase MB4H_HOT_PERIOD:\r\ncase MB4H_A9WDOG_CONF:\r\ncase MB4H_A9WDOG_EN:\r\ncase MB4H_A9WDOG_DIS:\r\ncase MB4H_A9WDOG_LOAD:\r\ncase MB4H_A9WDOG_KICK:\r\nbreak;\r\ndefault:\r\nprint_unknown_header_warning(4, header);\r\ndo_complete = false;\r\nbreak;\r\n}\r\nwritel(MBOX_BIT(4), PRCM_ARM_IT1_CLR);\r\nif (do_complete)\r\ncomplete(&mb4_transfer.work);\r\nreturn false;\r\n}\r\nstatic bool read_mailbox_5(void)\r\n{\r\nmb5_transfer.ack.status = readb(tcdm_base + PRCM_ACK_MB5_I2C_STATUS);\r\nmb5_transfer.ack.value = readb(tcdm_base + PRCM_ACK_MB5_I2C_VAL);\r\nwritel(MBOX_BIT(5), PRCM_ARM_IT1_CLR);\r\ncomplete(&mb5_transfer.work);\r\nreturn false;\r\n}\r\nstatic bool read_mailbox_6(void)\r\n{\r\nwritel(MBOX_BIT(6), PRCM_ARM_IT1_CLR);\r\nreturn false;\r\n}\r\nstatic bool read_mailbox_7(void)\r\n{\r\nwritel(MBOX_BIT(7), PRCM_ARM_IT1_CLR);\r\nreturn false;\r\n}\r\nstatic irqreturn_t prcmu_irq_handler(int irq, void *data)\r\n{\r\nu32 bits;\r\nu8 n;\r\nirqreturn_t r;\r\nbits = (readl(PRCM_ARM_IT1_VAL) & ALL_MBOX_BITS);\r\nif (unlikely(!bits))\r\nreturn IRQ_NONE;\r\nr = IRQ_HANDLED;\r\nfor (n = 0; bits; n++) {\r\nif (bits & MBOX_BIT(n)) {\r\nbits -= MBOX_BIT(n);\r\nif (read_mailbox[n]())\r\nr = IRQ_WAKE_THREAD;\r\n}\r\n}\r\nreturn r;\r\n}\r\nstatic irqreturn_t prcmu_irq_thread_fn(int irq, void *data)\r\n{\r\nack_dbb_wakeup();\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void prcmu_mask_work(struct work_struct *work)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&mb0_transfer.lock, flags);\r\nconfig_wakeups();\r\nspin_unlock_irqrestore(&mb0_transfer.lock, flags);\r\n}\r\nstatic void prcmu_irq_mask(struct irq_data *d)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&mb0_transfer.dbb_irqs_lock, flags);\r\nmb0_transfer.req.dbb_irqs &= ~prcmu_irq_bit[d->hwirq];\r\nspin_unlock_irqrestore(&mb0_transfer.dbb_irqs_lock, flags);\r\nif (d->irq != IRQ_PRCMU_CA_SLEEP)\r\nschedule_work(&mb0_transfer.mask_work);\r\n}\r\nstatic void prcmu_irq_unmask(struct irq_data *d)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&mb0_transfer.dbb_irqs_lock, flags);\r\nmb0_transfer.req.dbb_irqs |= prcmu_irq_bit[d->hwirq];\r\nspin_unlock_irqrestore(&mb0_transfer.dbb_irqs_lock, flags);\r\nif (d->irq != IRQ_PRCMU_CA_SLEEP)\r\nschedule_work(&mb0_transfer.mask_work);\r\n}\r\nstatic void noop(struct irq_data *d)\r\n{\r\n}\r\nstatic __init char *fw_project_name(u32 project)\r\n{\r\nswitch (project) {\r\ncase PRCMU_FW_PROJECT_U8500:\r\nreturn "U8500";\r\ncase PRCMU_FW_PROJECT_U8400:\r\nreturn "U8400";\r\ncase PRCMU_FW_PROJECT_U9500:\r\nreturn "U9500";\r\ncase PRCMU_FW_PROJECT_U8500_MBB:\r\nreturn "U8500 MBB";\r\ncase PRCMU_FW_PROJECT_U8500_C1:\r\nreturn "U8500 C1";\r\ncase PRCMU_FW_PROJECT_U8500_C2:\r\nreturn "U8500 C2";\r\ncase PRCMU_FW_PROJECT_U8500_C3:\r\nreturn "U8500 C3";\r\ncase PRCMU_FW_PROJECT_U8500_C4:\r\nreturn "U8500 C4";\r\ncase PRCMU_FW_PROJECT_U9500_MBL:\r\nreturn "U9500 MBL";\r\ncase PRCMU_FW_PROJECT_U8500_MBL:\r\nreturn "U8500 MBL";\r\ncase PRCMU_FW_PROJECT_U8500_MBL2:\r\nreturn "U8500 MBL2";\r\ncase PRCMU_FW_PROJECT_U8520:\r\nreturn "U8520 MBL";\r\ncase PRCMU_FW_PROJECT_U8420:\r\nreturn "U8420";\r\ncase PRCMU_FW_PROJECT_U9540:\r\nreturn "U9540";\r\ncase PRCMU_FW_PROJECT_A9420:\r\nreturn "A9420";\r\ncase PRCMU_FW_PROJECT_L8540:\r\nreturn "L8540";\r\ncase PRCMU_FW_PROJECT_L8580:\r\nreturn "L8580";\r\ndefault:\r\nreturn "Unknown";\r\n}\r\n}\r\nstatic int db8500_irq_map(struct irq_domain *d, unsigned int virq,\r\nirq_hw_number_t hwirq)\r\n{\r\nirq_set_chip_and_handler(virq, &prcmu_irq_chip,\r\nhandle_simple_irq);\r\nset_irq_flags(virq, IRQF_VALID);\r\nreturn 0;\r\n}\r\nstatic int db8500_irq_init(struct device_node *np)\r\n{\r\nint i;\r\ndb8500_irq_domain = irq_domain_add_simple(\r\nnp, NUM_PRCMU_WAKEUPS, 0,\r\n&db8500_irq_ops, NULL);\r\nif (!db8500_irq_domain) {\r\npr_err("Failed to create irqdomain\n");\r\nreturn -ENOSYS;\r\n}\r\nfor (i = 0; i < NUM_PRCMU_WAKEUPS; i++)\r\nirq_create_mapping(db8500_irq_domain, i);\r\nreturn 0;\r\n}\r\nstatic void dbx500_fw_version_init(struct platform_device *pdev,\r\nu32 version_offset)\r\n{\r\nstruct resource *res;\r\nvoid __iomem *tcpm_base;\r\nu32 version;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\r\n"prcmu-tcpm");\r\nif (!res) {\r\ndev_err(&pdev->dev,\r\n"Error: no prcmu tcpm memory region provided\n");\r\nreturn;\r\n}\r\ntcpm_base = ioremap(res->start, resource_size(res));\r\nif (!tcpm_base) {\r\ndev_err(&pdev->dev, "no prcmu tcpm mem region provided\n");\r\nreturn;\r\n}\r\nversion = readl(tcpm_base + version_offset);\r\nfw_info.version.project = (version & 0xFF);\r\nfw_info.version.api_version = (version >> 8) & 0xFF;\r\nfw_info.version.func_version = (version >> 16) & 0xFF;\r\nfw_info.version.errata = (version >> 24) & 0xFF;\r\nstrncpy(fw_info.version.project_name,\r\nfw_project_name(fw_info.version.project),\r\nPRCMU_FW_PROJECT_NAME_LEN);\r\nfw_info.valid = true;\r\npr_info("PRCMU firmware: %s(%d), version %d.%d.%d\n",\r\nfw_info.version.project_name,\r\nfw_info.version.project,\r\nfw_info.version.api_version,\r\nfw_info.version.func_version,\r\nfw_info.version.errata);\r\niounmap(tcpm_base);\r\n}\r\nvoid __init db8500_prcmu_early_init(u32 phy_base, u32 size)\r\n{\r\nprcmu_base = ioremap(phy_base, size);\r\nif (!prcmu_base)\r\npr_err("%s: ioremap() of prcmu registers failed!\n", __func__);\r\nspin_lock_init(&mb0_transfer.lock);\r\nspin_lock_init(&mb0_transfer.dbb_irqs_lock);\r\nmutex_init(&mb0_transfer.ac_wake_lock);\r\ninit_completion(&mb0_transfer.ac_wake_work);\r\nmutex_init(&mb1_transfer.lock);\r\ninit_completion(&mb1_transfer.work);\r\nmb1_transfer.ape_opp = APE_NO_CHANGE;\r\nmutex_init(&mb2_transfer.lock);\r\ninit_completion(&mb2_transfer.work);\r\nspin_lock_init(&mb2_transfer.auto_pm_lock);\r\nspin_lock_init(&mb3_transfer.lock);\r\nmutex_init(&mb3_transfer.sysclk_lock);\r\ninit_completion(&mb3_transfer.sysclk_work);\r\nmutex_init(&mb4_transfer.lock);\r\ninit_completion(&mb4_transfer.work);\r\nmutex_init(&mb5_transfer.lock);\r\ninit_completion(&mb5_transfer.work);\r\nINIT_WORK(&mb0_transfer.mask_work, prcmu_mask_work);\r\n}\r\nstatic void __init init_prcm_registers(void)\r\n{\r\nu32 val;\r\nval = readl(PRCM_A9PL_FORCE_CLKEN);\r\nval &= ~(PRCM_A9PL_FORCE_CLKEN_PRCM_A9PL_FORCE_CLKEN |\r\nPRCM_A9PL_FORCE_CLKEN_PRCM_A9AXI_FORCE_CLKEN);\r\nwritel(val, (PRCM_A9PL_FORCE_CLKEN));\r\n}\r\nstatic void db8500_prcmu_update_cpufreq(void)\r\n{\r\nif (prcmu_has_arm_maxopp()) {\r\ndb8500_cpufreq_table[3].frequency = 1000000;\r\ndb8500_cpufreq_table[3].driver_data = ARM_MAX_OPP;\r\n}\r\n}\r\nstatic int db8500_prcmu_register_ab8500(struct device *parent,\r\nstruct ab8500_platform_data *pdata)\r\n{\r\nstruct device_node *np;\r\nstruct resource ab8500_resource;\r\nconst struct mfd_cell ab8500_cell = {\r\n.name = "ab8500-core",\r\n.of_compatible = "stericsson,ab8500",\r\n.id = AB8500_VERSION_AB8500,\r\n.platform_data = pdata,\r\n.pdata_size = sizeof(struct ab8500_platform_data),\r\n.resources = &ab8500_resource,\r\n.num_resources = 1,\r\n};\r\nif (!parent->of_node)\r\nreturn -ENODEV;\r\nfor_each_child_of_node(parent->of_node, np) {\r\nif (of_device_is_compatible(np, ab8500_cell.of_compatible))\r\nbreak;\r\n}\r\nif (!np) {\r\ndev_info(parent, "could not find AB8500 node in the device tree\n");\r\nreturn -ENODEV;\r\n}\r\nof_irq_to_resource_table(np, &ab8500_resource, 1);\r\nreturn mfd_add_devices(parent, 0, &ab8500_cell, 1, NULL, 0, NULL);\r\n}\r\nstatic int db8500_prcmu_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct prcmu_pdata *pdata = dev_get_platdata(&pdev->dev);\r\nint irq = 0, err = 0;\r\nstruct resource *res;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "prcmu");\r\nif (!res) {\r\ndev_err(&pdev->dev, "no prcmu memory region provided\n");\r\nreturn -EINVAL;\r\n}\r\nprcmu_base = devm_ioremap(&pdev->dev, res->start, resource_size(res));\r\nif (!prcmu_base) {\r\ndev_err(&pdev->dev,\r\n"failed to ioremap prcmu register memory\n");\r\nreturn -ENOMEM;\r\n}\r\ninit_prcm_registers();\r\ndbx500_fw_version_init(pdev, pdata->version_offset);\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "prcmu-tcdm");\r\nif (!res) {\r\ndev_err(&pdev->dev, "no prcmu tcdm region provided\n");\r\nreturn -EINVAL;\r\n}\r\ntcdm_base = devm_ioremap(&pdev->dev, res->start,\r\nresource_size(res));\r\nif (!tcdm_base) {\r\ndev_err(&pdev->dev,\r\n"failed to ioremap prcmu-tcdm register memory\n");\r\nreturn -ENOMEM;\r\n}\r\nwritel(ALL_MBOX_BITS, PRCM_ARM_IT1_CLR);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq <= 0) {\r\ndev_err(&pdev->dev, "no prcmu irq provided\n");\r\nreturn irq;\r\n}\r\nerr = request_threaded_irq(irq, prcmu_irq_handler,\r\nprcmu_irq_thread_fn, IRQF_NO_SUSPEND, "prcmu", NULL);\r\nif (err < 0) {\r\npr_err("prcmu: Failed to allocate IRQ_DB8500_PRCMU1.\n");\r\nreturn err;\r\n}\r\ndb8500_irq_init(np);\r\nprcmu_config_esram0_deep_sleep(ESRAM0_DEEP_SLEEP_STATE_RET);\r\ndb8500_prcmu_update_cpufreq();\r\nerr = mfd_add_devices(&pdev->dev, 0, common_prcmu_devs,\r\nARRAY_SIZE(common_prcmu_devs), NULL, 0, db8500_irq_domain);\r\nif (err) {\r\npr_err("prcmu: Failed to add subdevices\n");\r\nreturn err;\r\n}\r\nif (!of_machine_is_compatible("st-ericsson,u8540")) {\r\nerr = mfd_add_devices(&pdev->dev, 0, db8500_prcmu_devs,\r\nARRAY_SIZE(db8500_prcmu_devs), NULL, 0,\r\ndb8500_irq_domain);\r\nif (err) {\r\nmfd_remove_devices(&pdev->dev);\r\npr_err("prcmu: Failed to add subdevices\n");\r\nreturn err;\r\n}\r\n}\r\nerr = db8500_prcmu_register_ab8500(&pdev->dev, pdata->ab_platdata);\r\nif (err) {\r\nmfd_remove_devices(&pdev->dev);\r\npr_err("prcmu: Failed to add ab8500 subdevice\n");\r\nreturn err;\r\n}\r\npr_info("DB8500 PRCMU initialized\n");\r\nreturn err;\r\n}\r\nstatic int __init db8500_prcmu_init(void)\r\n{\r\nreturn platform_driver_register(&db8500_prcmu_driver);\r\n}
