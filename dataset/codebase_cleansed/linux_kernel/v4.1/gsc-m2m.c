static int gsc_m2m_ctx_stop_req(struct gsc_ctx *ctx)\r\n{\r\nstruct gsc_ctx *curr_ctx;\r\nstruct gsc_dev *gsc = ctx->gsc_dev;\r\nint ret;\r\ncurr_ctx = v4l2_m2m_get_curr_priv(gsc->m2m.m2m_dev);\r\nif (!gsc_m2m_pending(gsc) || (curr_ctx != ctx))\r\nreturn 0;\r\ngsc_ctx_state_lock_set(GSC_CTX_STOP_REQ, ctx);\r\nret = wait_event_timeout(gsc->irq_queue,\r\n!gsc_ctx_state_is_set(GSC_CTX_STOP_REQ, ctx),\r\nGSC_SHUTDOWN_TIMEOUT);\r\nreturn ret == 0 ? -ETIMEDOUT : ret;\r\n}\r\nstatic void __gsc_m2m_job_abort(struct gsc_ctx *ctx)\r\n{\r\nint ret;\r\nret = gsc_m2m_ctx_stop_req(ctx);\r\nif ((ret == -ETIMEDOUT) || (ctx->state & GSC_CTX_ABORT)) {\r\ngsc_ctx_state_lock_clear(GSC_CTX_STOP_REQ | GSC_CTX_ABORT, ctx);\r\ngsc_m2m_job_finish(ctx, VB2_BUF_STATE_ERROR);\r\n}\r\n}\r\nstatic int gsc_m2m_start_streaming(struct vb2_queue *q, unsigned int count)\r\n{\r\nstruct gsc_ctx *ctx = q->drv_priv;\r\nint ret;\r\nret = pm_runtime_get_sync(&ctx->gsc_dev->pdev->dev);\r\nreturn ret > 0 ? 0 : ret;\r\n}\r\nstatic void gsc_m2m_stop_streaming(struct vb2_queue *q)\r\n{\r\nstruct gsc_ctx *ctx = q->drv_priv;\r\n__gsc_m2m_job_abort(ctx);\r\npm_runtime_put(&ctx->gsc_dev->pdev->dev);\r\n}\r\nvoid gsc_m2m_job_finish(struct gsc_ctx *ctx, int vb_state)\r\n{\r\nstruct vb2_buffer *src_vb, *dst_vb;\r\nif (!ctx || !ctx->m2m_ctx)\r\nreturn;\r\nsrc_vb = v4l2_m2m_src_buf_remove(ctx->m2m_ctx);\r\ndst_vb = v4l2_m2m_dst_buf_remove(ctx->m2m_ctx);\r\nif (src_vb && dst_vb) {\r\ndst_vb->v4l2_buf.timestamp = src_vb->v4l2_buf.timestamp;\r\ndst_vb->v4l2_buf.timecode = src_vb->v4l2_buf.timecode;\r\ndst_vb->v4l2_buf.flags &= ~V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\r\ndst_vb->v4l2_buf.flags |=\r\nsrc_vb->v4l2_buf.flags\r\n& V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\r\nv4l2_m2m_buf_done(src_vb, vb_state);\r\nv4l2_m2m_buf_done(dst_vb, vb_state);\r\nv4l2_m2m_job_finish(ctx->gsc_dev->m2m.m2m_dev,\r\nctx->m2m_ctx);\r\n}\r\n}\r\nstatic void gsc_m2m_job_abort(void *priv)\r\n{\r\n__gsc_m2m_job_abort((struct gsc_ctx *)priv);\r\n}\r\nstatic int gsc_get_bufs(struct gsc_ctx *ctx)\r\n{\r\nstruct gsc_frame *s_frame, *d_frame;\r\nstruct vb2_buffer *src_vb, *dst_vb;\r\nint ret;\r\ns_frame = &ctx->s_frame;\r\nd_frame = &ctx->d_frame;\r\nsrc_vb = v4l2_m2m_next_src_buf(ctx->m2m_ctx);\r\nret = gsc_prepare_addr(ctx, src_vb, s_frame, &s_frame->addr);\r\nif (ret)\r\nreturn ret;\r\ndst_vb = v4l2_m2m_next_dst_buf(ctx->m2m_ctx);\r\nret = gsc_prepare_addr(ctx, dst_vb, d_frame, &d_frame->addr);\r\nif (ret)\r\nreturn ret;\r\ndst_vb->v4l2_buf.timestamp = src_vb->v4l2_buf.timestamp;\r\nreturn 0;\r\n}\r\nstatic void gsc_m2m_device_run(void *priv)\r\n{\r\nstruct gsc_ctx *ctx = priv;\r\nstruct gsc_dev *gsc;\r\nunsigned long flags;\r\nint ret;\r\nbool is_set = false;\r\nif (WARN(!ctx, "null hardware context\n"))\r\nreturn;\r\ngsc = ctx->gsc_dev;\r\nspin_lock_irqsave(&gsc->slock, flags);\r\nset_bit(ST_M2M_PEND, &gsc->state);\r\nif (gsc->m2m.ctx != ctx) {\r\npr_debug("gsc->m2m.ctx = 0x%p, current_ctx = 0x%p",\r\ngsc->m2m.ctx, ctx);\r\nctx->state |= GSC_PARAMS;\r\ngsc->m2m.ctx = ctx;\r\n}\r\nis_set = ctx->state & GSC_CTX_STOP_REQ;\r\nif (is_set) {\r\nctx->state &= ~GSC_CTX_STOP_REQ;\r\nctx->state |= GSC_CTX_ABORT;\r\nwake_up(&gsc->irq_queue);\r\ngoto put_device;\r\n}\r\nret = gsc_get_bufs(ctx);\r\nif (ret) {\r\npr_err("Wrong address");\r\ngoto put_device;\r\n}\r\ngsc_set_prefbuf(gsc, &ctx->s_frame);\r\ngsc_hw_set_input_addr(gsc, &ctx->s_frame.addr, GSC_M2M_BUF_NUM);\r\ngsc_hw_set_output_addr(gsc, &ctx->d_frame.addr, GSC_M2M_BUF_NUM);\r\nif (ctx->state & GSC_PARAMS) {\r\ngsc_hw_set_input_buf_masking(gsc, GSC_M2M_BUF_NUM, false);\r\ngsc_hw_set_output_buf_masking(gsc, GSC_M2M_BUF_NUM, false);\r\ngsc_hw_set_frm_done_irq_mask(gsc, false);\r\ngsc_hw_set_gsc_irq_enable(gsc, true);\r\nif (gsc_set_scaler_info(ctx)) {\r\npr_err("Scaler setup error");\r\ngoto put_device;\r\n}\r\ngsc_hw_set_input_path(ctx);\r\ngsc_hw_set_in_size(ctx);\r\ngsc_hw_set_in_image_format(ctx);\r\ngsc_hw_set_output_path(ctx);\r\ngsc_hw_set_out_size(ctx);\r\ngsc_hw_set_out_image_format(ctx);\r\ngsc_hw_set_prescaler(ctx);\r\ngsc_hw_set_mainscaler(ctx);\r\ngsc_hw_set_rotation(ctx);\r\ngsc_hw_set_global_alpha(ctx);\r\n}\r\ngsc_hw_set_sfr_update(ctx);\r\nctx->state &= ~GSC_PARAMS;\r\ngsc_hw_enable_control(gsc, true);\r\nspin_unlock_irqrestore(&gsc->slock, flags);\r\nreturn;\r\nput_device:\r\nctx->state &= ~GSC_PARAMS;\r\nspin_unlock_irqrestore(&gsc->slock, flags);\r\n}\r\nstatic int gsc_m2m_queue_setup(struct vb2_queue *vq,\r\nconst struct v4l2_format *fmt,\r\nunsigned int *num_buffers, unsigned int *num_planes,\r\nunsigned int sizes[], void *allocators[])\r\n{\r\nstruct gsc_ctx *ctx = vb2_get_drv_priv(vq);\r\nstruct gsc_frame *frame;\r\nint i;\r\nframe = ctx_get_frame(ctx, vq->type);\r\nif (IS_ERR(frame))\r\nreturn PTR_ERR(frame);\r\nif (!frame->fmt)\r\nreturn -EINVAL;\r\n*num_planes = frame->fmt->num_planes;\r\nfor (i = 0; i < frame->fmt->num_planes; i++) {\r\nsizes[i] = frame->payload[i];\r\nallocators[i] = ctx->gsc_dev->alloc_ctx;\r\n}\r\nreturn 0;\r\n}\r\nstatic int gsc_m2m_buf_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct gsc_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct gsc_frame *frame;\r\nint i;\r\nframe = ctx_get_frame(ctx, vb->vb2_queue->type);\r\nif (IS_ERR(frame))\r\nreturn PTR_ERR(frame);\r\nif (!V4L2_TYPE_IS_OUTPUT(vb->vb2_queue->type)) {\r\nfor (i = 0; i < frame->fmt->num_planes; i++)\r\nvb2_set_plane_payload(vb, i, frame->payload[i]);\r\n}\r\nreturn 0;\r\n}\r\nstatic void gsc_m2m_buf_queue(struct vb2_buffer *vb)\r\n{\r\nstruct gsc_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\r\npr_debug("ctx: %p, ctx->state: 0x%x", ctx, ctx->state);\r\nif (ctx->m2m_ctx)\r\nv4l2_m2m_buf_queue(ctx->m2m_ctx, vb);\r\n}\r\nstatic int gsc_m2m_querycap(struct file *file, void *fh,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct gsc_ctx *ctx = fh_to_ctx(fh);\r\nstruct gsc_dev *gsc = ctx->gsc_dev;\r\nstrlcpy(cap->driver, gsc->pdev->name, sizeof(cap->driver));\r\nstrlcpy(cap->card, gsc->pdev->name, sizeof(cap->card));\r\nstrlcpy(cap->bus_info, "platform", sizeof(cap->bus_info));\r\ncap->device_caps = V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_M2M_MPLANE |\r\nV4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_VIDEO_OUTPUT_MPLANE;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int gsc_m2m_enum_fmt_mplane(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nreturn gsc_enum_fmt_mplane(f);\r\n}\r\nstatic int gsc_m2m_g_fmt_mplane(struct file *file, void *fh,\r\nstruct v4l2_format *f)\r\n{\r\nstruct gsc_ctx *ctx = fh_to_ctx(fh);\r\nreturn gsc_g_fmt_mplane(ctx, f);\r\n}\r\nstatic int gsc_m2m_try_fmt_mplane(struct file *file, void *fh,\r\nstruct v4l2_format *f)\r\n{\r\nstruct gsc_ctx *ctx = fh_to_ctx(fh);\r\nreturn gsc_try_fmt_mplane(ctx, f);\r\n}\r\nstatic int gsc_m2m_s_fmt_mplane(struct file *file, void *fh,\r\nstruct v4l2_format *f)\r\n{\r\nstruct gsc_ctx *ctx = fh_to_ctx(fh);\r\nstruct vb2_queue *vq;\r\nstruct gsc_frame *frame;\r\nstruct v4l2_pix_format_mplane *pix;\r\nint i, ret = 0;\r\nret = gsc_m2m_try_fmt_mplane(file, fh, f);\r\nif (ret)\r\nreturn ret;\r\nvq = v4l2_m2m_get_vq(ctx->m2m_ctx, f->type);\r\nif (vb2_is_streaming(vq)) {\r\npr_err("queue (%d) busy", f->type);\r\nreturn -EBUSY;\r\n}\r\nif (V4L2_TYPE_IS_OUTPUT(f->type))\r\nframe = &ctx->s_frame;\r\nelse\r\nframe = &ctx->d_frame;\r\npix = &f->fmt.pix_mp;\r\nframe->fmt = find_fmt(&pix->pixelformat, NULL, 0);\r\nframe->colorspace = pix->colorspace;\r\nif (!frame->fmt)\r\nreturn -EINVAL;\r\nfor (i = 0; i < frame->fmt->num_planes; i++)\r\nframe->payload[i] = pix->plane_fmt[i].sizeimage;\r\ngsc_set_frame_size(frame, pix->width, pix->height);\r\nif (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\r\ngsc_ctx_state_lock_set(GSC_PARAMS | GSC_DST_FMT, ctx);\r\nelse\r\ngsc_ctx_state_lock_set(GSC_PARAMS | GSC_SRC_FMT, ctx);\r\npr_debug("f_w: %d, f_h: %d", frame->f_width, frame->f_height);\r\nreturn 0;\r\n}\r\nstatic int gsc_m2m_reqbufs(struct file *file, void *fh,\r\nstruct v4l2_requestbuffers *reqbufs)\r\n{\r\nstruct gsc_ctx *ctx = fh_to_ctx(fh);\r\nstruct gsc_dev *gsc = ctx->gsc_dev;\r\nu32 max_cnt;\r\nmax_cnt = (reqbufs->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) ?\r\ngsc->variant->in_buf_cnt : gsc->variant->out_buf_cnt;\r\nif (reqbufs->count > max_cnt) {\r\nreturn -EINVAL;\r\n} else if (reqbufs->count == 0) {\r\nif (reqbufs->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\r\ngsc_ctx_state_lock_clear(GSC_SRC_FMT, ctx);\r\nelse\r\ngsc_ctx_state_lock_clear(GSC_DST_FMT, ctx);\r\n}\r\nreturn v4l2_m2m_reqbufs(file, ctx->m2m_ctx, reqbufs);\r\n}\r\nstatic int gsc_m2m_expbuf(struct file *file, void *fh,\r\nstruct v4l2_exportbuffer *eb)\r\n{\r\nstruct gsc_ctx *ctx = fh_to_ctx(fh);\r\nreturn v4l2_m2m_expbuf(file, ctx->m2m_ctx, eb);\r\n}\r\nstatic int gsc_m2m_querybuf(struct file *file, void *fh,\r\nstruct v4l2_buffer *buf)\r\n{\r\nstruct gsc_ctx *ctx = fh_to_ctx(fh);\r\nreturn v4l2_m2m_querybuf(file, ctx->m2m_ctx, buf);\r\n}\r\nstatic int gsc_m2m_qbuf(struct file *file, void *fh,\r\nstruct v4l2_buffer *buf)\r\n{\r\nstruct gsc_ctx *ctx = fh_to_ctx(fh);\r\nreturn v4l2_m2m_qbuf(file, ctx->m2m_ctx, buf);\r\n}\r\nstatic int gsc_m2m_dqbuf(struct file *file, void *fh,\r\nstruct v4l2_buffer *buf)\r\n{\r\nstruct gsc_ctx *ctx = fh_to_ctx(fh);\r\nreturn v4l2_m2m_dqbuf(file, ctx->m2m_ctx, buf);\r\n}\r\nstatic int gsc_m2m_streamon(struct file *file, void *fh,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct gsc_ctx *ctx = fh_to_ctx(fh);\r\nif (V4L2_TYPE_IS_OUTPUT(type)) {\r\nif (!gsc_ctx_state_is_set(GSC_SRC_FMT, ctx))\r\nreturn -EINVAL;\r\n} else if (!gsc_ctx_state_is_set(GSC_DST_FMT, ctx)) {\r\nreturn -EINVAL;\r\n}\r\nreturn v4l2_m2m_streamon(file, ctx->m2m_ctx, type);\r\n}\r\nstatic int gsc_m2m_streamoff(struct file *file, void *fh,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct gsc_ctx *ctx = fh_to_ctx(fh);\r\nreturn v4l2_m2m_streamoff(file, ctx->m2m_ctx, type);\r\n}\r\nstatic int is_rectangle_enclosed(struct v4l2_rect *a, struct v4l2_rect *b)\r\n{\r\nif (a->left < b->left || a->top < b->top)\r\nreturn 0;\r\nif (a->left + a->width > b->left + b->width)\r\nreturn 0;\r\nif (a->top + a->height > b->top + b->height)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int gsc_m2m_g_selection(struct file *file, void *fh,\r\nstruct v4l2_selection *s)\r\n{\r\nstruct gsc_frame *frame;\r\nstruct gsc_ctx *ctx = fh_to_ctx(fh);\r\nif ((s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) &&\r\n(s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE))\r\nreturn -EINVAL;\r\nframe = ctx_get_frame(ctx, s->type);\r\nif (IS_ERR(frame))\r\nreturn PTR_ERR(frame);\r\nswitch (s->target) {\r\ncase V4L2_SEL_TGT_COMPOSE_DEFAULT:\r\ncase V4L2_SEL_TGT_COMPOSE_BOUNDS:\r\ncase V4L2_SEL_TGT_CROP_BOUNDS:\r\ncase V4L2_SEL_TGT_CROP_DEFAULT:\r\ns->r.left = 0;\r\ns->r.top = 0;\r\ns->r.width = frame->f_width;\r\ns->r.height = frame->f_height;\r\nreturn 0;\r\ncase V4L2_SEL_TGT_COMPOSE:\r\ncase V4L2_SEL_TGT_CROP:\r\ns->r.left = frame->crop.left;\r\ns->r.top = frame->crop.top;\r\ns->r.width = frame->crop.width;\r\ns->r.height = frame->crop.height;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int gsc_m2m_s_selection(struct file *file, void *fh,\r\nstruct v4l2_selection *s)\r\n{\r\nstruct gsc_frame *frame;\r\nstruct gsc_ctx *ctx = fh_to_ctx(fh);\r\nstruct v4l2_crop cr;\r\nstruct gsc_variant *variant = ctx->gsc_dev->variant;\r\nint ret;\r\ncr.type = s->type;\r\ncr.c = s->r;\r\nif ((s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) &&\r\n(s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE))\r\nreturn -EINVAL;\r\nret = gsc_try_crop(ctx, &cr);\r\nif (ret)\r\nreturn ret;\r\nif (s->flags & V4L2_SEL_FLAG_LE &&\r\n!is_rectangle_enclosed(&cr.c, &s->r))\r\nreturn -ERANGE;\r\nif (s->flags & V4L2_SEL_FLAG_GE &&\r\n!is_rectangle_enclosed(&s->r, &cr.c))\r\nreturn -ERANGE;\r\ns->r = cr.c;\r\nswitch (s->target) {\r\ncase V4L2_SEL_TGT_COMPOSE_BOUNDS:\r\ncase V4L2_SEL_TGT_COMPOSE_DEFAULT:\r\ncase V4L2_SEL_TGT_COMPOSE:\r\nframe = &ctx->s_frame;\r\nbreak;\r\ncase V4L2_SEL_TGT_CROP_BOUNDS:\r\ncase V4L2_SEL_TGT_CROP:\r\ncase V4L2_SEL_TGT_CROP_DEFAULT:\r\nframe = &ctx->d_frame;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (gsc_ctx_state_is_set(GSC_DST_FMT | GSC_SRC_FMT, ctx)) {\r\nif (s->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\r\nret = gsc_check_scaler_ratio(variant, cr.c.width,\r\ncr.c.height, ctx->d_frame.crop.width,\r\nctx->d_frame.crop.height,\r\nctx->gsc_ctrls.rotate->val, ctx->out_path);\r\n} else {\r\nret = gsc_check_scaler_ratio(variant,\r\nctx->s_frame.crop.width,\r\nctx->s_frame.crop.height, cr.c.width,\r\ncr.c.height, ctx->gsc_ctrls.rotate->val,\r\nctx->out_path);\r\n}\r\nif (ret) {\r\npr_err("Out of scaler range");\r\nreturn -EINVAL;\r\n}\r\n}\r\nframe->crop = cr.c;\r\ngsc_ctx_state_lock_set(GSC_PARAMS, ctx);\r\nreturn 0;\r\n}\r\nstatic int queue_init(void *priv, struct vb2_queue *src_vq,\r\nstruct vb2_queue *dst_vq)\r\n{\r\nstruct gsc_ctx *ctx = priv;\r\nint ret;\r\nmemset(src_vq, 0, sizeof(*src_vq));\r\nsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\r\nsrc_vq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\r\nsrc_vq->drv_priv = ctx;\r\nsrc_vq->ops = &gsc_m2m_qops;\r\nsrc_vq->mem_ops = &vb2_dma_contig_memops;\r\nsrc_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\r\nsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\r\nsrc_vq->lock = &ctx->gsc_dev->lock;\r\nret = vb2_queue_init(src_vq);\r\nif (ret)\r\nreturn ret;\r\nmemset(dst_vq, 0, sizeof(*dst_vq));\r\ndst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\r\ndst_vq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\r\ndst_vq->drv_priv = ctx;\r\ndst_vq->ops = &gsc_m2m_qops;\r\ndst_vq->mem_ops = &vb2_dma_contig_memops;\r\ndst_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\r\ndst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\r\ndst_vq->lock = &ctx->gsc_dev->lock;\r\nreturn vb2_queue_init(dst_vq);\r\n}\r\nstatic int gsc_m2m_open(struct file *file)\r\n{\r\nstruct gsc_dev *gsc = video_drvdata(file);\r\nstruct gsc_ctx *ctx = NULL;\r\nint ret;\r\npr_debug("pid: %d, state: 0x%lx", task_pid_nr(current), gsc->state);\r\nif (mutex_lock_interruptible(&gsc->lock))\r\nreturn -ERESTARTSYS;\r\nctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx) {\r\nret = -ENOMEM;\r\ngoto unlock;\r\n}\r\nv4l2_fh_init(&ctx->fh, gsc->m2m.vfd);\r\nret = gsc_ctrls_create(ctx);\r\nif (ret)\r\ngoto error_fh;\r\nctx->fh.ctrl_handler = &ctx->ctrl_handler;\r\nfile->private_data = &ctx->fh;\r\nv4l2_fh_add(&ctx->fh);\r\nctx->gsc_dev = gsc;\r\nctx->s_frame.fmt = get_format(0);\r\nctx->d_frame.fmt = get_format(0);\r\nctx->state = GSC_CTX_M2M;\r\nctx->flags = 0;\r\nctx->in_path = GSC_DMA;\r\nctx->out_path = GSC_DMA;\r\nctx->m2m_ctx = v4l2_m2m_ctx_init(gsc->m2m.m2m_dev, ctx, queue_init);\r\nif (IS_ERR(ctx->m2m_ctx)) {\r\npr_err("Failed to initialize m2m context");\r\nret = PTR_ERR(ctx->m2m_ctx);\r\ngoto error_ctrls;\r\n}\r\nif (gsc->m2m.refcnt++ == 0)\r\nset_bit(ST_M2M_OPEN, &gsc->state);\r\npr_debug("gsc m2m driver is opened, ctx(0x%p)", ctx);\r\nmutex_unlock(&gsc->lock);\r\nreturn 0;\r\nerror_ctrls:\r\ngsc_ctrls_delete(ctx);\r\nerror_fh:\r\nv4l2_fh_del(&ctx->fh);\r\nv4l2_fh_exit(&ctx->fh);\r\nkfree(ctx);\r\nunlock:\r\nmutex_unlock(&gsc->lock);\r\nreturn ret;\r\n}\r\nstatic int gsc_m2m_release(struct file *file)\r\n{\r\nstruct gsc_ctx *ctx = fh_to_ctx(file->private_data);\r\nstruct gsc_dev *gsc = ctx->gsc_dev;\r\npr_debug("pid: %d, state: 0x%lx, refcnt= %d",\r\ntask_pid_nr(current), gsc->state, gsc->m2m.refcnt);\r\nmutex_lock(&gsc->lock);\r\nv4l2_m2m_ctx_release(ctx->m2m_ctx);\r\ngsc_ctrls_delete(ctx);\r\nv4l2_fh_del(&ctx->fh);\r\nv4l2_fh_exit(&ctx->fh);\r\nif (--gsc->m2m.refcnt <= 0)\r\nclear_bit(ST_M2M_OPEN, &gsc->state);\r\nkfree(ctx);\r\nmutex_unlock(&gsc->lock);\r\nreturn 0;\r\n}\r\nstatic unsigned int gsc_m2m_poll(struct file *file,\r\nstruct poll_table_struct *wait)\r\n{\r\nstruct gsc_ctx *ctx = fh_to_ctx(file->private_data);\r\nstruct gsc_dev *gsc = ctx->gsc_dev;\r\nint ret;\r\nif (mutex_lock_interruptible(&gsc->lock))\r\nreturn -ERESTARTSYS;\r\nret = v4l2_m2m_poll(file, ctx->m2m_ctx, wait);\r\nmutex_unlock(&gsc->lock);\r\nreturn ret;\r\n}\r\nstatic int gsc_m2m_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct gsc_ctx *ctx = fh_to_ctx(file->private_data);\r\nstruct gsc_dev *gsc = ctx->gsc_dev;\r\nint ret;\r\nif (mutex_lock_interruptible(&gsc->lock))\r\nreturn -ERESTARTSYS;\r\nret = v4l2_m2m_mmap(file, ctx->m2m_ctx, vma);\r\nmutex_unlock(&gsc->lock);\r\nreturn ret;\r\n}\r\nint gsc_register_m2m_device(struct gsc_dev *gsc)\r\n{\r\nstruct platform_device *pdev;\r\nint ret;\r\nif (!gsc)\r\nreturn -ENODEV;\r\npdev = gsc->pdev;\r\ngsc->vdev.fops = &gsc_m2m_fops;\r\ngsc->vdev.ioctl_ops = &gsc_m2m_ioctl_ops;\r\ngsc->vdev.release = video_device_release_empty;\r\ngsc->vdev.lock = &gsc->lock;\r\ngsc->vdev.vfl_dir = VFL_DIR_M2M;\r\ngsc->vdev.v4l2_dev = &gsc->v4l2_dev;\r\nsnprintf(gsc->vdev.name, sizeof(gsc->vdev.name), "%s.%d:m2m",\r\nGSC_MODULE_NAME, gsc->id);\r\nvideo_set_drvdata(&gsc->vdev, gsc);\r\ngsc->m2m.vfd = &gsc->vdev;\r\ngsc->m2m.m2m_dev = v4l2_m2m_init(&gsc_m2m_ops);\r\nif (IS_ERR(gsc->m2m.m2m_dev)) {\r\ndev_err(&pdev->dev, "failed to initialize v4l2-m2m device\n");\r\nret = PTR_ERR(gsc->m2m.m2m_dev);\r\ngoto err_m2m_r1;\r\n}\r\nret = video_register_device(&gsc->vdev, VFL_TYPE_GRABBER, -1);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"%s(): failed to register video device\n", __func__);\r\ngoto err_m2m_r2;\r\n}\r\npr_debug("gsc m2m driver registered as /dev/video%d", gsc->vdev.num);\r\nreturn 0;\r\nerr_m2m_r2:\r\nv4l2_m2m_release(gsc->m2m.m2m_dev);\r\nerr_m2m_r1:\r\nvideo_device_release(gsc->m2m.vfd);\r\nreturn ret;\r\n}\r\nvoid gsc_unregister_m2m_device(struct gsc_dev *gsc)\r\n{\r\nif (gsc)\r\nv4l2_m2m_release(gsc->m2m.m2m_dev);\r\n}
