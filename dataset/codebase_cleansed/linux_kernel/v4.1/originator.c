int batadv_compare_orig(const struct hlist_node *node, const void *data2)\r\n{\r\nconst void *data1 = container_of(node, struct batadv_orig_node,\r\nhash_entry);\r\nreturn batadv_compare_eth(data1, data2);\r\n}\r\nstruct batadv_orig_node_vlan *\r\nbatadv_orig_node_vlan_get(struct batadv_orig_node *orig_node,\r\nunsigned short vid)\r\n{\r\nstruct batadv_orig_node_vlan *vlan = NULL, *tmp;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(tmp, &orig_node->vlan_list, list) {\r\nif (tmp->vid != vid)\r\ncontinue;\r\nif (!atomic_inc_not_zero(&tmp->refcount))\r\ncontinue;\r\nvlan = tmp;\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nreturn vlan;\r\n}\r\nstruct batadv_orig_node_vlan *\r\nbatadv_orig_node_vlan_new(struct batadv_orig_node *orig_node,\r\nunsigned short vid)\r\n{\r\nstruct batadv_orig_node_vlan *vlan;\r\nspin_lock_bh(&orig_node->vlan_list_lock);\r\nvlan = batadv_orig_node_vlan_get(orig_node, vid);\r\nif (vlan)\r\ngoto out;\r\nvlan = kzalloc(sizeof(*vlan), GFP_ATOMIC);\r\nif (!vlan)\r\ngoto out;\r\natomic_set(&vlan->refcount, 2);\r\nvlan->vid = vid;\r\nlist_add_rcu(&vlan->list, &orig_node->vlan_list);\r\nout:\r\nspin_unlock_bh(&orig_node->vlan_list_lock);\r\nreturn vlan;\r\n}\r\nvoid batadv_orig_node_vlan_free_ref(struct batadv_orig_node_vlan *orig_vlan)\r\n{\r\nif (atomic_dec_and_test(&orig_vlan->refcount))\r\nkfree_rcu(orig_vlan, rcu);\r\n}\r\nint batadv_originator_init(struct batadv_priv *bat_priv)\r\n{\r\nif (bat_priv->orig_hash)\r\nreturn 0;\r\nbat_priv->orig_hash = batadv_hash_new(1024);\r\nif (!bat_priv->orig_hash)\r\ngoto err;\r\nbatadv_hash_set_lock_class(bat_priv->orig_hash,\r\n&batadv_orig_hash_lock_class_key);\r\nINIT_DELAYED_WORK(&bat_priv->orig_work, batadv_purge_orig);\r\nqueue_delayed_work(batadv_event_workqueue,\r\n&bat_priv->orig_work,\r\nmsecs_to_jiffies(BATADV_ORIG_WORK_PERIOD));\r\nreturn 0;\r\nerr:\r\nreturn -ENOMEM;\r\n}\r\nstatic void batadv_neigh_ifinfo_free_rcu(struct rcu_head *rcu)\r\n{\r\nstruct batadv_neigh_ifinfo *neigh_ifinfo;\r\nneigh_ifinfo = container_of(rcu, struct batadv_neigh_ifinfo, rcu);\r\nif (neigh_ifinfo->if_outgoing != BATADV_IF_DEFAULT)\r\nbatadv_hardif_free_ref_now(neigh_ifinfo->if_outgoing);\r\nkfree(neigh_ifinfo);\r\n}\r\nstatic void\r\nbatadv_neigh_ifinfo_free_ref_now(struct batadv_neigh_ifinfo *neigh_ifinfo)\r\n{\r\nif (atomic_dec_and_test(&neigh_ifinfo->refcount))\r\nbatadv_neigh_ifinfo_free_rcu(&neigh_ifinfo->rcu);\r\n}\r\nvoid batadv_neigh_ifinfo_free_ref(struct batadv_neigh_ifinfo *neigh_ifinfo)\r\n{\r\nif (atomic_dec_and_test(&neigh_ifinfo->refcount))\r\ncall_rcu(&neigh_ifinfo->rcu, batadv_neigh_ifinfo_free_rcu);\r\n}\r\nstatic void batadv_neigh_node_free_rcu(struct rcu_head *rcu)\r\n{\r\nstruct hlist_node *node_tmp;\r\nstruct batadv_neigh_node *neigh_node;\r\nstruct batadv_neigh_ifinfo *neigh_ifinfo;\r\nneigh_node = container_of(rcu, struct batadv_neigh_node, rcu);\r\nhlist_for_each_entry_safe(neigh_ifinfo, node_tmp,\r\n&neigh_node->ifinfo_list, list) {\r\nbatadv_neigh_ifinfo_free_ref_now(neigh_ifinfo);\r\n}\r\nbatadv_hardif_free_ref_now(neigh_node->if_incoming);\r\nkfree(neigh_node);\r\n}\r\nstatic void\r\nbatadv_neigh_node_free_ref_now(struct batadv_neigh_node *neigh_node)\r\n{\r\nif (atomic_dec_and_test(&neigh_node->refcount))\r\nbatadv_neigh_node_free_rcu(&neigh_node->rcu);\r\n}\r\nvoid batadv_neigh_node_free_ref(struct batadv_neigh_node *neigh_node)\r\n{\r\nif (atomic_dec_and_test(&neigh_node->refcount))\r\ncall_rcu(&neigh_node->rcu, batadv_neigh_node_free_rcu);\r\n}\r\nstruct batadv_neigh_node *\r\nbatadv_orig_router_get(struct batadv_orig_node *orig_node,\r\nconst struct batadv_hard_iface *if_outgoing)\r\n{\r\nstruct batadv_orig_ifinfo *orig_ifinfo;\r\nstruct batadv_neigh_node *router = NULL;\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(orig_ifinfo, &orig_node->ifinfo_list, list) {\r\nif (orig_ifinfo->if_outgoing != if_outgoing)\r\ncontinue;\r\nrouter = rcu_dereference(orig_ifinfo->router);\r\nbreak;\r\n}\r\nif (router && !atomic_inc_not_zero(&router->refcount))\r\nrouter = NULL;\r\nrcu_read_unlock();\r\nreturn router;\r\n}\r\nstruct batadv_orig_ifinfo *\r\nbatadv_orig_ifinfo_get(struct batadv_orig_node *orig_node,\r\nstruct batadv_hard_iface *if_outgoing)\r\n{\r\nstruct batadv_orig_ifinfo *tmp, *orig_ifinfo = NULL;\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(tmp, &orig_node->ifinfo_list,\r\nlist) {\r\nif (tmp->if_outgoing != if_outgoing)\r\ncontinue;\r\nif (!atomic_inc_not_zero(&tmp->refcount))\r\ncontinue;\r\norig_ifinfo = tmp;\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nreturn orig_ifinfo;\r\n}\r\nstruct batadv_orig_ifinfo *\r\nbatadv_orig_ifinfo_new(struct batadv_orig_node *orig_node,\r\nstruct batadv_hard_iface *if_outgoing)\r\n{\r\nstruct batadv_orig_ifinfo *orig_ifinfo = NULL;\r\nunsigned long reset_time;\r\nspin_lock_bh(&orig_node->neigh_list_lock);\r\norig_ifinfo = batadv_orig_ifinfo_get(orig_node, if_outgoing);\r\nif (orig_ifinfo)\r\ngoto out;\r\norig_ifinfo = kzalloc(sizeof(*orig_ifinfo), GFP_ATOMIC);\r\nif (!orig_ifinfo)\r\ngoto out;\r\nif (if_outgoing != BATADV_IF_DEFAULT &&\r\n!atomic_inc_not_zero(&if_outgoing->refcount)) {\r\nkfree(orig_ifinfo);\r\norig_ifinfo = NULL;\r\ngoto out;\r\n}\r\nreset_time = jiffies - 1;\r\nreset_time -= msecs_to_jiffies(BATADV_RESET_PROTECTION_MS);\r\norig_ifinfo->batman_seqno_reset = reset_time;\r\norig_ifinfo->if_outgoing = if_outgoing;\r\nINIT_HLIST_NODE(&orig_ifinfo->list);\r\natomic_set(&orig_ifinfo->refcount, 2);\r\nhlist_add_head_rcu(&orig_ifinfo->list,\r\n&orig_node->ifinfo_list);\r\nout:\r\nspin_unlock_bh(&orig_node->neigh_list_lock);\r\nreturn orig_ifinfo;\r\n}\r\nstruct batadv_neigh_ifinfo *\r\nbatadv_neigh_ifinfo_get(struct batadv_neigh_node *neigh,\r\nstruct batadv_hard_iface *if_outgoing)\r\n{\r\nstruct batadv_neigh_ifinfo *neigh_ifinfo = NULL,\r\n*tmp_neigh_ifinfo;\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(tmp_neigh_ifinfo, &neigh->ifinfo_list,\r\nlist) {\r\nif (tmp_neigh_ifinfo->if_outgoing != if_outgoing)\r\ncontinue;\r\nif (!atomic_inc_not_zero(&tmp_neigh_ifinfo->refcount))\r\ncontinue;\r\nneigh_ifinfo = tmp_neigh_ifinfo;\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nreturn neigh_ifinfo;\r\n}\r\nstruct batadv_neigh_ifinfo *\r\nbatadv_neigh_ifinfo_new(struct batadv_neigh_node *neigh,\r\nstruct batadv_hard_iface *if_outgoing)\r\n{\r\nstruct batadv_neigh_ifinfo *neigh_ifinfo;\r\nspin_lock_bh(&neigh->ifinfo_lock);\r\nneigh_ifinfo = batadv_neigh_ifinfo_get(neigh, if_outgoing);\r\nif (neigh_ifinfo)\r\ngoto out;\r\nneigh_ifinfo = kzalloc(sizeof(*neigh_ifinfo), GFP_ATOMIC);\r\nif (!neigh_ifinfo)\r\ngoto out;\r\nif (if_outgoing && !atomic_inc_not_zero(&if_outgoing->refcount)) {\r\nkfree(neigh_ifinfo);\r\nneigh_ifinfo = NULL;\r\ngoto out;\r\n}\r\nINIT_HLIST_NODE(&neigh_ifinfo->list);\r\natomic_set(&neigh_ifinfo->refcount, 2);\r\nneigh_ifinfo->if_outgoing = if_outgoing;\r\nhlist_add_head_rcu(&neigh_ifinfo->list, &neigh->ifinfo_list);\r\nout:\r\nspin_unlock_bh(&neigh->ifinfo_lock);\r\nreturn neigh_ifinfo;\r\n}\r\nstruct batadv_neigh_node *\r\nbatadv_neigh_node_new(struct batadv_hard_iface *hard_iface,\r\nconst uint8_t *neigh_addr,\r\nstruct batadv_orig_node *orig_node)\r\n{\r\nstruct batadv_neigh_node *neigh_node;\r\nneigh_node = kzalloc(sizeof(*neigh_node), GFP_ATOMIC);\r\nif (!neigh_node)\r\ngoto out;\r\nINIT_HLIST_NODE(&neigh_node->list);\r\nINIT_HLIST_HEAD(&neigh_node->ifinfo_list);\r\nspin_lock_init(&neigh_node->ifinfo_lock);\r\nether_addr_copy(neigh_node->addr, neigh_addr);\r\nneigh_node->if_incoming = hard_iface;\r\nneigh_node->orig_node = orig_node;\r\natomic_set(&neigh_node->refcount, 2);\r\nout:\r\nreturn neigh_node;\r\n}\r\nstruct batadv_neigh_node *\r\nbatadv_neigh_node_get(const struct batadv_orig_node *orig_node,\r\nconst struct batadv_hard_iface *hard_iface,\r\nconst uint8_t *addr)\r\n{\r\nstruct batadv_neigh_node *tmp_neigh_node, *res = NULL;\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(tmp_neigh_node, &orig_node->neigh_list, list) {\r\nif (!batadv_compare_eth(tmp_neigh_node->addr, addr))\r\ncontinue;\r\nif (tmp_neigh_node->if_incoming != hard_iface)\r\ncontinue;\r\nif (!atomic_inc_not_zero(&tmp_neigh_node->refcount))\r\ncontinue;\r\nres = tmp_neigh_node;\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nreturn res;\r\n}\r\nstatic void batadv_orig_ifinfo_free_rcu(struct rcu_head *rcu)\r\n{\r\nstruct batadv_orig_ifinfo *orig_ifinfo;\r\nstruct batadv_neigh_node *router;\r\norig_ifinfo = container_of(rcu, struct batadv_orig_ifinfo, rcu);\r\nif (orig_ifinfo->if_outgoing != BATADV_IF_DEFAULT)\r\nbatadv_hardif_free_ref_now(orig_ifinfo->if_outgoing);\r\nrouter = rcu_dereference_protected(orig_ifinfo->router, true);\r\nif (router)\r\nbatadv_neigh_node_free_ref_now(router);\r\nkfree(orig_ifinfo);\r\n}\r\nstatic void\r\nbatadv_orig_ifinfo_free_ref_now(struct batadv_orig_ifinfo *orig_ifinfo)\r\n{\r\nif (atomic_dec_and_test(&orig_ifinfo->refcount))\r\nbatadv_orig_ifinfo_free_rcu(&orig_ifinfo->rcu);\r\n}\r\nvoid batadv_orig_ifinfo_free_ref(struct batadv_orig_ifinfo *orig_ifinfo)\r\n{\r\nif (atomic_dec_and_test(&orig_ifinfo->refcount))\r\ncall_rcu(&orig_ifinfo->rcu, batadv_orig_ifinfo_free_rcu);\r\n}\r\nstatic void batadv_orig_node_free_rcu(struct rcu_head *rcu)\r\n{\r\nstruct hlist_node *node_tmp;\r\nstruct batadv_neigh_node *neigh_node;\r\nstruct batadv_orig_node *orig_node;\r\nstruct batadv_orig_ifinfo *orig_ifinfo;\r\norig_node = container_of(rcu, struct batadv_orig_node, rcu);\r\nspin_lock_bh(&orig_node->neigh_list_lock);\r\nhlist_for_each_entry_safe(neigh_node, node_tmp,\r\n&orig_node->neigh_list, list) {\r\nhlist_del_rcu(&neigh_node->list);\r\nbatadv_neigh_node_free_ref_now(neigh_node);\r\n}\r\nhlist_for_each_entry_safe(orig_ifinfo, node_tmp,\r\n&orig_node->ifinfo_list, list) {\r\nhlist_del_rcu(&orig_ifinfo->list);\r\nbatadv_orig_ifinfo_free_ref_now(orig_ifinfo);\r\n}\r\nspin_unlock_bh(&orig_node->neigh_list_lock);\r\nbatadv_mcast_purge_orig(orig_node);\r\nbatadv_nc_purge_orig(orig_node->bat_priv, orig_node, NULL);\r\nbatadv_frag_purge_orig(orig_node, NULL);\r\nif (orig_node->bat_priv->bat_algo_ops->bat_orig_free)\r\norig_node->bat_priv->bat_algo_ops->bat_orig_free(orig_node);\r\nkfree(orig_node->tt_buff);\r\nkfree(orig_node);\r\n}\r\nvoid batadv_orig_node_free_ref(struct batadv_orig_node *orig_node)\r\n{\r\nif (atomic_dec_and_test(&orig_node->refcount))\r\ncall_rcu(&orig_node->rcu, batadv_orig_node_free_rcu);\r\n}\r\nvoid batadv_orig_node_free_ref_now(struct batadv_orig_node *orig_node)\r\n{\r\nif (atomic_dec_and_test(&orig_node->refcount))\r\nbatadv_orig_node_free_rcu(&orig_node->rcu);\r\n}\r\nvoid batadv_originator_free(struct batadv_priv *bat_priv)\r\n{\r\nstruct batadv_hashtable *hash = bat_priv->orig_hash;\r\nstruct hlist_node *node_tmp;\r\nstruct hlist_head *head;\r\nspinlock_t *list_lock;\r\nstruct batadv_orig_node *orig_node;\r\nuint32_t i;\r\nif (!hash)\r\nreturn;\r\ncancel_delayed_work_sync(&bat_priv->orig_work);\r\nbat_priv->orig_hash = NULL;\r\nfor (i = 0; i < hash->size; i++) {\r\nhead = &hash->table[i];\r\nlist_lock = &hash->list_locks[i];\r\nspin_lock_bh(list_lock);\r\nhlist_for_each_entry_safe(orig_node, node_tmp,\r\nhead, hash_entry) {\r\nhlist_del_rcu(&orig_node->hash_entry);\r\nbatadv_orig_node_free_ref(orig_node);\r\n}\r\nspin_unlock_bh(list_lock);\r\n}\r\nbatadv_hash_destroy(hash);\r\n}\r\nstruct batadv_orig_node *batadv_orig_node_new(struct batadv_priv *bat_priv,\r\nconst uint8_t *addr)\r\n{\r\nstruct batadv_orig_node *orig_node;\r\nstruct batadv_orig_node_vlan *vlan;\r\nunsigned long reset_time;\r\nint i;\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Creating new originator: %pM\n", addr);\r\norig_node = kzalloc(sizeof(*orig_node), GFP_ATOMIC);\r\nif (!orig_node)\r\nreturn NULL;\r\nINIT_HLIST_HEAD(&orig_node->neigh_list);\r\nINIT_LIST_HEAD(&orig_node->vlan_list);\r\nINIT_HLIST_HEAD(&orig_node->ifinfo_list);\r\nspin_lock_init(&orig_node->bcast_seqno_lock);\r\nspin_lock_init(&orig_node->neigh_list_lock);\r\nspin_lock_init(&orig_node->tt_buff_lock);\r\nspin_lock_init(&orig_node->tt_lock);\r\nspin_lock_init(&orig_node->vlan_list_lock);\r\nbatadv_nc_init_orig(orig_node);\r\natomic_set(&orig_node->refcount, 2);\r\norig_node->bat_priv = bat_priv;\r\nether_addr_copy(orig_node->orig, addr);\r\nbatadv_dat_init_orig_node_addr(orig_node);\r\natomic_set(&orig_node->last_ttvn, 0);\r\norig_node->tt_buff = NULL;\r\norig_node->tt_buff_len = 0;\r\norig_node->last_seen = jiffies;\r\nreset_time = jiffies - 1 - msecs_to_jiffies(BATADV_RESET_PROTECTION_MS);\r\norig_node->bcast_seqno_reset = reset_time;\r\n#ifdef CONFIG_BATMAN_ADV_MCAST\r\norig_node->mcast_flags = BATADV_NO_FLAGS;\r\n#endif\r\nvlan = batadv_orig_node_vlan_new(orig_node, BATADV_NO_FLAGS);\r\nif (!vlan)\r\ngoto free_orig_node;\r\nbatadv_orig_node_vlan_free_ref(vlan);\r\nfor (i = 0; i < BATADV_FRAG_BUFFER_COUNT; i++) {\r\nINIT_HLIST_HEAD(&orig_node->fragments[i].head);\r\nspin_lock_init(&orig_node->fragments[i].lock);\r\norig_node->fragments[i].size = 0;\r\n}\r\nreturn orig_node;\r\nfree_orig_node:\r\nkfree(orig_node);\r\nreturn NULL;\r\n}\r\nstatic void\r\nbatadv_purge_neigh_ifinfo(struct batadv_priv *bat_priv,\r\nstruct batadv_neigh_node *neigh)\r\n{\r\nstruct batadv_neigh_ifinfo *neigh_ifinfo;\r\nstruct batadv_hard_iface *if_outgoing;\r\nstruct hlist_node *node_tmp;\r\nspin_lock_bh(&neigh->ifinfo_lock);\r\nhlist_for_each_entry_safe(neigh_ifinfo, node_tmp,\r\n&neigh->ifinfo_list, list) {\r\nif_outgoing = neigh_ifinfo->if_outgoing;\r\nif (if_outgoing == BATADV_IF_DEFAULT)\r\ncontinue;\r\nif ((if_outgoing->if_status != BATADV_IF_INACTIVE) &&\r\n(if_outgoing->if_status != BATADV_IF_NOT_IN_USE) &&\r\n(if_outgoing->if_status != BATADV_IF_TO_BE_REMOVED))\r\ncontinue;\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"neighbor/ifinfo purge: neighbor %pM, iface: %s\n",\r\nneigh->addr, if_outgoing->net_dev->name);\r\nhlist_del_rcu(&neigh_ifinfo->list);\r\nbatadv_neigh_ifinfo_free_ref(neigh_ifinfo);\r\n}\r\nspin_unlock_bh(&neigh->ifinfo_lock);\r\n}\r\nstatic bool\r\nbatadv_purge_orig_ifinfo(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig_node)\r\n{\r\nstruct batadv_orig_ifinfo *orig_ifinfo;\r\nstruct batadv_hard_iface *if_outgoing;\r\nstruct hlist_node *node_tmp;\r\nbool ifinfo_purged = false;\r\nspin_lock_bh(&orig_node->neigh_list_lock);\r\nhlist_for_each_entry_safe(orig_ifinfo, node_tmp,\r\n&orig_node->ifinfo_list, list) {\r\nif_outgoing = orig_ifinfo->if_outgoing;\r\nif (if_outgoing == BATADV_IF_DEFAULT)\r\ncontinue;\r\nif ((if_outgoing->if_status != BATADV_IF_INACTIVE) &&\r\n(if_outgoing->if_status != BATADV_IF_NOT_IN_USE) &&\r\n(if_outgoing->if_status != BATADV_IF_TO_BE_REMOVED))\r\ncontinue;\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"router/ifinfo purge: originator %pM, iface: %s\n",\r\norig_node->orig, if_outgoing->net_dev->name);\r\nifinfo_purged = true;\r\nhlist_del_rcu(&orig_ifinfo->list);\r\nbatadv_orig_ifinfo_free_ref(orig_ifinfo);\r\nif (orig_node->last_bonding_candidate == orig_ifinfo) {\r\norig_node->last_bonding_candidate = NULL;\r\nbatadv_orig_ifinfo_free_ref(orig_ifinfo);\r\n}\r\n}\r\nspin_unlock_bh(&orig_node->neigh_list_lock);\r\nreturn ifinfo_purged;\r\n}\r\nstatic bool\r\nbatadv_purge_orig_neighbors(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig_node)\r\n{\r\nstruct hlist_node *node_tmp;\r\nstruct batadv_neigh_node *neigh_node;\r\nbool neigh_purged = false;\r\nunsigned long last_seen;\r\nstruct batadv_hard_iface *if_incoming;\r\nspin_lock_bh(&orig_node->neigh_list_lock);\r\nhlist_for_each_entry_safe(neigh_node, node_tmp,\r\n&orig_node->neigh_list, list) {\r\nlast_seen = neigh_node->last_seen;\r\nif_incoming = neigh_node->if_incoming;\r\nif ((batadv_has_timed_out(last_seen, BATADV_PURGE_TIMEOUT)) ||\r\n(if_incoming->if_status == BATADV_IF_INACTIVE) ||\r\n(if_incoming->if_status == BATADV_IF_NOT_IN_USE) ||\r\n(if_incoming->if_status == BATADV_IF_TO_BE_REMOVED)) {\r\nif ((if_incoming->if_status == BATADV_IF_INACTIVE) ||\r\n(if_incoming->if_status == BATADV_IF_NOT_IN_USE) ||\r\n(if_incoming->if_status == BATADV_IF_TO_BE_REMOVED))\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"neighbor purge: originator %pM, neighbor: %pM, iface: %s\n",\r\norig_node->orig, neigh_node->addr,\r\nif_incoming->net_dev->name);\r\nelse\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"neighbor timeout: originator %pM, neighbor: %pM, last_seen: %u\n",\r\norig_node->orig, neigh_node->addr,\r\njiffies_to_msecs(last_seen));\r\nneigh_purged = true;\r\nhlist_del_rcu(&neigh_node->list);\r\nbatadv_neigh_node_free_ref(neigh_node);\r\n} else {\r\nbatadv_purge_neigh_ifinfo(bat_priv, neigh_node);\r\n}\r\n}\r\nspin_unlock_bh(&orig_node->neigh_list_lock);\r\nreturn neigh_purged;\r\n}\r\nstatic struct batadv_neigh_node *\r\nbatadv_find_best_neighbor(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig_node,\r\nstruct batadv_hard_iface *if_outgoing)\r\n{\r\nstruct batadv_neigh_node *best = NULL, *neigh;\r\nstruct batadv_algo_ops *bao = bat_priv->bat_algo_ops;\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(neigh, &orig_node->neigh_list, list) {\r\nif (best && (bao->bat_neigh_cmp(neigh, if_outgoing,\r\nbest, if_outgoing) <= 0))\r\ncontinue;\r\nif (!atomic_inc_not_zero(&neigh->refcount))\r\ncontinue;\r\nif (best)\r\nbatadv_neigh_node_free_ref(best);\r\nbest = neigh;\r\n}\r\nrcu_read_unlock();\r\nreturn best;\r\n}\r\nstatic bool batadv_purge_orig_node(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig_node)\r\n{\r\nstruct batadv_neigh_node *best_neigh_node;\r\nstruct batadv_hard_iface *hard_iface;\r\nbool changed_ifinfo, changed_neigh;\r\nif (batadv_has_timed_out(orig_node->last_seen,\r\n2 * BATADV_PURGE_TIMEOUT)) {\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Originator timeout: originator %pM, last_seen %u\n",\r\norig_node->orig,\r\njiffies_to_msecs(orig_node->last_seen));\r\nreturn true;\r\n}\r\nchanged_ifinfo = batadv_purge_orig_ifinfo(bat_priv, orig_node);\r\nchanged_neigh = batadv_purge_orig_neighbors(bat_priv, orig_node);\r\nif (!changed_ifinfo && !changed_neigh)\r\nreturn false;\r\nbest_neigh_node = batadv_find_best_neighbor(bat_priv, orig_node,\r\nBATADV_IF_DEFAULT);\r\nbatadv_update_route(bat_priv, orig_node, BATADV_IF_DEFAULT,\r\nbest_neigh_node);\r\nif (best_neigh_node)\r\nbatadv_neigh_node_free_ref(best_neigh_node);\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(hard_iface, &batadv_hardif_list, list) {\r\nif (hard_iface->if_status != BATADV_IF_ACTIVE)\r\ncontinue;\r\nif (hard_iface->soft_iface != bat_priv->soft_iface)\r\ncontinue;\r\nbest_neigh_node = batadv_find_best_neighbor(bat_priv,\r\norig_node,\r\nhard_iface);\r\nbatadv_update_route(bat_priv, orig_node, hard_iface,\r\nbest_neigh_node);\r\nif (best_neigh_node)\r\nbatadv_neigh_node_free_ref(best_neigh_node);\r\n}\r\nrcu_read_unlock();\r\nreturn false;\r\n}\r\nstatic void _batadv_purge_orig(struct batadv_priv *bat_priv)\r\n{\r\nstruct batadv_hashtable *hash = bat_priv->orig_hash;\r\nstruct hlist_node *node_tmp;\r\nstruct hlist_head *head;\r\nspinlock_t *list_lock;\r\nstruct batadv_orig_node *orig_node;\r\nuint32_t i;\r\nif (!hash)\r\nreturn;\r\nfor (i = 0; i < hash->size; i++) {\r\nhead = &hash->table[i];\r\nlist_lock = &hash->list_locks[i];\r\nspin_lock_bh(list_lock);\r\nhlist_for_each_entry_safe(orig_node, node_tmp,\r\nhead, hash_entry) {\r\nif (batadv_purge_orig_node(bat_priv, orig_node)) {\r\nbatadv_gw_node_delete(bat_priv, orig_node);\r\nhlist_del_rcu(&orig_node->hash_entry);\r\nbatadv_tt_global_del_orig(orig_node->bat_priv,\r\norig_node, -1,\r\n"originator timed out");\r\nbatadv_orig_node_free_ref(orig_node);\r\ncontinue;\r\n}\r\nbatadv_frag_purge_orig(orig_node,\r\nbatadv_frag_check_entry);\r\n}\r\nspin_unlock_bh(list_lock);\r\n}\r\nbatadv_gw_node_purge(bat_priv);\r\nbatadv_gw_election(bat_priv);\r\n}\r\nstatic void batadv_purge_orig(struct work_struct *work)\r\n{\r\nstruct delayed_work *delayed_work;\r\nstruct batadv_priv *bat_priv;\r\ndelayed_work = container_of(work, struct delayed_work, work);\r\nbat_priv = container_of(delayed_work, struct batadv_priv, orig_work);\r\n_batadv_purge_orig(bat_priv);\r\nqueue_delayed_work(batadv_event_workqueue,\r\n&bat_priv->orig_work,\r\nmsecs_to_jiffies(BATADV_ORIG_WORK_PERIOD));\r\n}\r\nvoid batadv_purge_orig_ref(struct batadv_priv *bat_priv)\r\n{\r\n_batadv_purge_orig(bat_priv);\r\n}\r\nint batadv_orig_seq_print_text(struct seq_file *seq, void *offset)\r\n{\r\nstruct net_device *net_dev = (struct net_device *)seq->private;\r\nstruct batadv_priv *bat_priv = netdev_priv(net_dev);\r\nstruct batadv_hard_iface *primary_if;\r\nprimary_if = batadv_seq_print_text_primary_if_get(seq);\r\nif (!primary_if)\r\nreturn 0;\r\nseq_printf(seq, "[B.A.T.M.A.N. adv %s, MainIF/MAC: %s/%pM (%s %s)]\n",\r\nBATADV_SOURCE_VERSION, primary_if->net_dev->name,\r\nprimary_if->net_dev->dev_addr, net_dev->name,\r\nbat_priv->bat_algo_ops->name);\r\nbatadv_hardif_free_ref(primary_if);\r\nif (!bat_priv->bat_algo_ops->bat_orig_print) {\r\nseq_puts(seq,\r\n"No printing function for this routing protocol\n");\r\nreturn 0;\r\n}\r\nbat_priv->bat_algo_ops->bat_orig_print(bat_priv, seq,\r\nBATADV_IF_DEFAULT);\r\nreturn 0;\r\n}\r\nint batadv_orig_hardif_seq_print_text(struct seq_file *seq, void *offset)\r\n{\r\nstruct net_device *net_dev = (struct net_device *)seq->private;\r\nstruct batadv_hard_iface *hard_iface;\r\nstruct batadv_priv *bat_priv;\r\nhard_iface = batadv_hardif_get_by_netdev(net_dev);\r\nif (!hard_iface || !hard_iface->soft_iface) {\r\nseq_puts(seq, "Interface not known to B.A.T.M.A.N.\n");\r\ngoto out;\r\n}\r\nbat_priv = netdev_priv(hard_iface->soft_iface);\r\nif (!bat_priv->bat_algo_ops->bat_orig_print) {\r\nseq_puts(seq,\r\n"No printing function for this routing protocol\n");\r\ngoto out;\r\n}\r\nif (hard_iface->if_status != BATADV_IF_ACTIVE) {\r\nseq_puts(seq, "Interface not active\n");\r\ngoto out;\r\n}\r\nseq_printf(seq, "[B.A.T.M.A.N. adv %s, IF/MAC: %s/%pM (%s %s)]\n",\r\nBATADV_SOURCE_VERSION, hard_iface->net_dev->name,\r\nhard_iface->net_dev->dev_addr,\r\nhard_iface->soft_iface->name, bat_priv->bat_algo_ops->name);\r\nbat_priv->bat_algo_ops->bat_orig_print(bat_priv, seq, hard_iface);\r\nout:\r\nif (hard_iface)\r\nbatadv_hardif_free_ref(hard_iface);\r\nreturn 0;\r\n}\r\nint batadv_orig_hash_add_if(struct batadv_hard_iface *hard_iface,\r\nint max_if_num)\r\n{\r\nstruct batadv_priv *bat_priv = netdev_priv(hard_iface->soft_iface);\r\nstruct batadv_algo_ops *bao = bat_priv->bat_algo_ops;\r\nstruct batadv_hashtable *hash = bat_priv->orig_hash;\r\nstruct hlist_head *head;\r\nstruct batadv_orig_node *orig_node;\r\nuint32_t i;\r\nint ret;\r\nfor (i = 0; i < hash->size; i++) {\r\nhead = &hash->table[i];\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(orig_node, head, hash_entry) {\r\nret = 0;\r\nif (bao->bat_orig_add_if)\r\nret = bao->bat_orig_add_if(orig_node,\r\nmax_if_num);\r\nif (ret == -ENOMEM)\r\ngoto err;\r\n}\r\nrcu_read_unlock();\r\n}\r\nreturn 0;\r\nerr:\r\nrcu_read_unlock();\r\nreturn -ENOMEM;\r\n}\r\nint batadv_orig_hash_del_if(struct batadv_hard_iface *hard_iface,\r\nint max_if_num)\r\n{\r\nstruct batadv_priv *bat_priv = netdev_priv(hard_iface->soft_iface);\r\nstruct batadv_hashtable *hash = bat_priv->orig_hash;\r\nstruct hlist_head *head;\r\nstruct batadv_hard_iface *hard_iface_tmp;\r\nstruct batadv_orig_node *orig_node;\r\nstruct batadv_algo_ops *bao = bat_priv->bat_algo_ops;\r\nuint32_t i;\r\nint ret;\r\nfor (i = 0; i < hash->size; i++) {\r\nhead = &hash->table[i];\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(orig_node, head, hash_entry) {\r\nret = 0;\r\nif (bao->bat_orig_del_if)\r\nret = bao->bat_orig_del_if(orig_node,\r\nmax_if_num,\r\nhard_iface->if_num);\r\nif (ret == -ENOMEM)\r\ngoto err;\r\n}\r\nrcu_read_unlock();\r\n}\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(hard_iface_tmp, &batadv_hardif_list, list) {\r\nif (hard_iface_tmp->if_status == BATADV_IF_NOT_IN_USE)\r\ncontinue;\r\nif (hard_iface == hard_iface_tmp)\r\ncontinue;\r\nif (hard_iface->soft_iface != hard_iface_tmp->soft_iface)\r\ncontinue;\r\nif (hard_iface_tmp->if_num > hard_iface->if_num)\r\nhard_iface_tmp->if_num--;\r\n}\r\nrcu_read_unlock();\r\nhard_iface->if_num = -1;\r\nreturn 0;\r\nerr:\r\nrcu_read_unlock();\r\nreturn -ENOMEM;\r\n}
