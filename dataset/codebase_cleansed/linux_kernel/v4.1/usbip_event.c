static int event_handler(struct usbip_device *ud)\r\n{\r\nusbip_dbg_eh("enter\n");\r\nwhile (usbip_event_happened(ud)) {\r\nusbip_dbg_eh("pending event %lx\n", ud->event);\r\nif (ud->event & USBIP_EH_SHUTDOWN) {\r\nud->eh_ops.shutdown(ud);\r\nud->event &= ~USBIP_EH_SHUTDOWN;\r\n}\r\nif (ud->event & USBIP_EH_RESET) {\r\nud->eh_ops.reset(ud);\r\nud->event &= ~USBIP_EH_RESET;\r\n}\r\nif (ud->event & USBIP_EH_UNUSABLE) {\r\nud->eh_ops.unusable(ud);\r\nud->event &= ~USBIP_EH_UNUSABLE;\r\n}\r\nif (ud->event & USBIP_EH_BYE)\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int event_handler_loop(void *data)\r\n{\r\nstruct usbip_device *ud = data;\r\nwhile (!kthread_should_stop()) {\r\nwait_event_interruptible(ud->eh_waitq,\r\nusbip_event_happened(ud) ||\r\nkthread_should_stop());\r\nusbip_dbg_eh("wakeup\n");\r\nif (event_handler(ud) < 0)\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint usbip_start_eh(struct usbip_device *ud)\r\n{\r\ninit_waitqueue_head(&ud->eh_waitq);\r\nud->event = 0;\r\nud->eh = kthread_run(event_handler_loop, ud, "usbip_eh");\r\nif (IS_ERR(ud->eh)) {\r\npr_warn("Unable to start control thread\n");\r\nreturn PTR_ERR(ud->eh);\r\n}\r\nreturn 0;\r\n}\r\nvoid usbip_stop_eh(struct usbip_device *ud)\r\n{\r\nif (ud->eh == current)\r\nreturn;\r\nkthread_stop(ud->eh);\r\nusbip_dbg_eh("usbip_eh has finished\n");\r\n}\r\nvoid usbip_event_add(struct usbip_device *ud, unsigned long event)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ud->lock, flags);\r\nud->event |= event;\r\nwake_up(&ud->eh_waitq);\r\nspin_unlock_irqrestore(&ud->lock, flags);\r\n}\r\nint usbip_event_happened(struct usbip_device *ud)\r\n{\r\nint happened = 0;\r\nspin_lock(&ud->lock);\r\nif (ud->event != 0)\r\nhappened = 1;\r\nspin_unlock(&ud->lock);\r\nreturn happened;\r\n}
