static int get_total_cpus(void)\r\n{\r\nint nr_cpus = (int)sysconf(_SC_NPROCESSORS_CONF);\r\nif (nr_cpus <= 0) {\r\npr_err("Could not read cpus\n");\r\ngoto error;\r\n} else if (nr_cpus > MAX_CPUS) {\r\npr_err("Exceed max cpus(%d)\n", (int)MAX_CPUS);\r\ngoto error;\r\n}\r\nreturn nr_cpus;\r\nerror:\r\nexit(EXIT_FAILURE);\r\n}\r\nstatic void *agent_info_new(void)\r\n{\r\nstruct agent_info *s;\r\nint i;\r\ns = zalloc(sizeof(struct agent_info));\r\nif (s == NULL) {\r\npr_err("agent_info zalloc error\n");\r\nexit(EXIT_FAILURE);\r\n}\r\ns->pipe_size = PIPE_INIT;\r\ns->use_stdout = false;\r\ns->cpus = get_total_cpus();\r\ns->ctl_fd = -1;\r\nfor (i = 0; i < s->cpus; i++)\r\ns->rw_ti[i] = rw_thread_info_new();\r\nreturn s;\r\n}\r\nstatic unsigned long parse_size(const char *arg)\r\n{\r\nunsigned long value, round;\r\nchar *ptr;\r\nvalue = strtoul(arg, &ptr, 10);\r\nswitch (*ptr) {\r\ncase 'K': case 'k':\r\nvalue <<= 10;\r\nbreak;\r\ncase 'M': case 'm':\r\nvalue <<= 20;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (value > PIPE_MAX_SIZE) {\r\npr_err("Pipe size must be less than 1MB\n");\r\ngoto error;\r\n} else if (value < PIPE_MIN_SIZE) {\r\npr_err("Pipe size must be over 64KB\n");\r\ngoto error;\r\n}\r\nround = value & (PAGE_SIZE - 1);\r\nvalue = value - round;\r\nreturn value;\r\nerror:\r\nreturn 0;\r\n}\r\nstatic void usage(char const *prg)\r\n{\r\npr_err("usage: %s [-h] [-o] [-s <size of pipe>]\n", prg);\r\n}\r\nstatic const char *make_path(int cpu_num, bool this_is_write_path)\r\n{\r\nint ret;\r\nchar *buf;\r\nbuf = zalloc(PATH_MAX);\r\nif (buf == NULL) {\r\npr_err("Could not allocate buffer\n");\r\ngoto error;\r\n}\r\nif (this_is_write_path)\r\nret = snprintf(buf, PATH_MAX, WRITE_PATH_FMT, cpu_num);\r\nelse\r\nret = snprintf(buf, PATH_MAX, READ_PATH_FMT, cpu_num);\r\nif (ret <= 0) {\r\npr_err("Failed to generate %s path(CPU#%d):%d\n",\r\nthis_is_write_path ? "read" : "write", cpu_num, ret);\r\ngoto error;\r\n}\r\nreturn buf;\r\nerror:\r\nfree(buf);\r\nreturn NULL;\r\n}\r\nstatic const char *make_input_path(int cpu_num)\r\n{\r\nreturn make_path(cpu_num, false);\r\n}\r\nstatic const char *make_output_path(int cpu_num)\r\n{\r\nreturn make_path(cpu_num, true);\r\n}\r\nstatic void *agent_info_init(struct agent_info *s)\r\n{\r\nint cpu;\r\nconst char *in_path = NULL;\r\nconst char *out_path = NULL;\r\nfor (cpu = 0; cpu < s->cpus; cpu++) {\r\nin_path = make_input_path(cpu);\r\nif (in_path == NULL)\r\ngoto error;\r\nif (!s->use_stdout) {\r\nout_path = make_output_path(cpu);\r\nif (out_path == NULL)\r\ngoto error;\r\n} else\r\npr_debug("stdout mode\n");\r\nrw_thread_init(cpu, in_path, out_path, s->use_stdout,\r\ns->pipe_size, s->rw_ti[cpu]);\r\n}\r\ns->ctl_fd = rw_ctl_init((const char *)CTL_PATH);\r\nreturn NULL;\r\nerror:\r\nexit(EXIT_FAILURE);\r\n}\r\nstatic void *parse_args(int argc, char *argv[], struct agent_info *s)\r\n{\r\nint cmd;\r\nunsigned long size;\r\nwhile ((cmd = getopt(argc, argv, "hos:")) != -1) {\r\nswitch (cmd) {\r\ncase 'o':\r\ns->use_stdout = true;\r\nbreak;\r\ncase 's':\r\nsize = parse_size(optarg);\r\nif (size == 0)\r\ngoto error;\r\ns->pipe_size = size;\r\nbreak;\r\ncase 'h':\r\ndefault:\r\nusage(argv[0]);\r\ngoto error;\r\n}\r\n}\r\nagent_info_init(s);\r\nreturn NULL;\r\nerror:\r\nexit(EXIT_FAILURE);\r\n}\r\nstatic void agent_main_loop(struct agent_info *s)\r\n{\r\nint cpu;\r\npthread_t rw_thread_per_cpu[MAX_CPUS];\r\nfor (cpu = 0; cpu < s->cpus; cpu++)\r\nrw_thread_per_cpu[cpu] = rw_thread_run(s->rw_ti[cpu]);\r\nrw_ctl_loop(s->ctl_fd);\r\nfor (cpu = 0; cpu < s->cpus; cpu++) {\r\nint ret;\r\nret = pthread_join(rw_thread_per_cpu[cpu], NULL);\r\nif (ret != 0) {\r\npr_err("pthread_join() error:%d (cpu %d)\n", ret, cpu);\r\nexit(EXIT_FAILURE);\r\n}\r\n}\r\n}\r\nstatic void agent_info_free(struct agent_info *s)\r\n{\r\nint i;\r\nclose(s->ctl_fd);\r\nfor (i = 0; i < s->cpus; i++) {\r\nclose(s->rw_ti[i]->in_fd);\r\nclose(s->rw_ti[i]->out_fd);\r\nclose(s->rw_ti[i]->read_pipe);\r\nclose(s->rw_ti[i]->write_pipe);\r\nfree(s->rw_ti[i]);\r\n}\r\nfree(s);\r\n}\r\nint main(int argc, char *argv[])\r\n{\r\nstruct agent_info *s = NULL;\r\ns = agent_info_new();\r\nparse_args(argc, argv, s);\r\nagent_main_loop(s);\r\nagent_info_free(s);\r\nreturn 0;\r\n}
