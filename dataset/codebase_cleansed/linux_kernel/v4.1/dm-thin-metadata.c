static void sb_prepare_for_write(struct dm_block_validator *v,\r\nstruct dm_block *b,\r\nsize_t block_size)\r\n{\r\nstruct thin_disk_superblock *disk_super = dm_block_data(b);\r\ndisk_super->blocknr = cpu_to_le64(dm_block_location(b));\r\ndisk_super->csum = cpu_to_le32(dm_bm_checksum(&disk_super->flags,\r\nblock_size - sizeof(__le32),\r\nSUPERBLOCK_CSUM_XOR));\r\n}\r\nstatic int sb_check(struct dm_block_validator *v,\r\nstruct dm_block *b,\r\nsize_t block_size)\r\n{\r\nstruct thin_disk_superblock *disk_super = dm_block_data(b);\r\n__le32 csum_le;\r\nif (dm_block_location(b) != le64_to_cpu(disk_super->blocknr)) {\r\nDMERR("sb_check failed: blocknr %llu: "\r\n"wanted %llu", le64_to_cpu(disk_super->blocknr),\r\n(unsigned long long)dm_block_location(b));\r\nreturn -ENOTBLK;\r\n}\r\nif (le64_to_cpu(disk_super->magic) != THIN_SUPERBLOCK_MAGIC) {\r\nDMERR("sb_check failed: magic %llu: "\r\n"wanted %llu", le64_to_cpu(disk_super->magic),\r\n(unsigned long long)THIN_SUPERBLOCK_MAGIC);\r\nreturn -EILSEQ;\r\n}\r\ncsum_le = cpu_to_le32(dm_bm_checksum(&disk_super->flags,\r\nblock_size - sizeof(__le32),\r\nSUPERBLOCK_CSUM_XOR));\r\nif (csum_le != disk_super->csum) {\r\nDMERR("sb_check failed: csum %u: wanted %u",\r\nle32_to_cpu(csum_le), le32_to_cpu(disk_super->csum));\r\nreturn -EILSEQ;\r\n}\r\nreturn 0;\r\n}\r\nstatic uint64_t pack_block_time(dm_block_t b, uint32_t t)\r\n{\r\nreturn (b << 24) | t;\r\n}\r\nstatic void unpack_block_time(uint64_t v, dm_block_t *b, uint32_t *t)\r\n{\r\n*b = v >> 24;\r\n*t = v & ((1 << 24) - 1);\r\n}\r\nstatic void data_block_inc(void *context, const void *value_le)\r\n{\r\nstruct dm_space_map *sm = context;\r\n__le64 v_le;\r\nuint64_t b;\r\nuint32_t t;\r\nmemcpy(&v_le, value_le, sizeof(v_le));\r\nunpack_block_time(le64_to_cpu(v_le), &b, &t);\r\ndm_sm_inc_block(sm, b);\r\n}\r\nstatic void data_block_dec(void *context, const void *value_le)\r\n{\r\nstruct dm_space_map *sm = context;\r\n__le64 v_le;\r\nuint64_t b;\r\nuint32_t t;\r\nmemcpy(&v_le, value_le, sizeof(v_le));\r\nunpack_block_time(le64_to_cpu(v_le), &b, &t);\r\ndm_sm_dec_block(sm, b);\r\n}\r\nstatic int data_block_equal(void *context, const void *value1_le, const void *value2_le)\r\n{\r\n__le64 v1_le, v2_le;\r\nuint64_t b1, b2;\r\nuint32_t t;\r\nmemcpy(&v1_le, value1_le, sizeof(v1_le));\r\nmemcpy(&v2_le, value2_le, sizeof(v2_le));\r\nunpack_block_time(le64_to_cpu(v1_le), &b1, &t);\r\nunpack_block_time(le64_to_cpu(v2_le), &b2, &t);\r\nreturn b1 == b2;\r\n}\r\nstatic void subtree_inc(void *context, const void *value)\r\n{\r\nstruct dm_btree_info *info = context;\r\n__le64 root_le;\r\nuint64_t root;\r\nmemcpy(&root_le, value, sizeof(root_le));\r\nroot = le64_to_cpu(root_le);\r\ndm_tm_inc(info->tm, root);\r\n}\r\nstatic void subtree_dec(void *context, const void *value)\r\n{\r\nstruct dm_btree_info *info = context;\r\n__le64 root_le;\r\nuint64_t root;\r\nmemcpy(&root_le, value, sizeof(root_le));\r\nroot = le64_to_cpu(root_le);\r\nif (dm_btree_del(info, root))\r\nDMERR("btree delete failed\n");\r\n}\r\nstatic int subtree_equal(void *context, const void *value1_le, const void *value2_le)\r\n{\r\n__le64 v1_le, v2_le;\r\nmemcpy(&v1_le, value1_le, sizeof(v1_le));\r\nmemcpy(&v2_le, value2_le, sizeof(v2_le));\r\nreturn v1_le == v2_le;\r\n}\r\nstatic int superblock_lock_zero(struct dm_pool_metadata *pmd,\r\nstruct dm_block **sblock)\r\n{\r\nreturn dm_bm_write_lock_zero(pmd->bm, THIN_SUPERBLOCK_LOCATION,\r\n&sb_validator, sblock);\r\n}\r\nstatic int superblock_lock(struct dm_pool_metadata *pmd,\r\nstruct dm_block **sblock)\r\n{\r\nreturn dm_bm_write_lock(pmd->bm, THIN_SUPERBLOCK_LOCATION,\r\n&sb_validator, sblock);\r\n}\r\nstatic int __superblock_all_zeroes(struct dm_block_manager *bm, int *result)\r\n{\r\nint r;\r\nunsigned i;\r\nstruct dm_block *b;\r\n__le64 *data_le, zero = cpu_to_le64(0);\r\nunsigned block_size = dm_bm_block_size(bm) / sizeof(__le64);\r\nr = dm_bm_read_lock(bm, THIN_SUPERBLOCK_LOCATION, NULL, &b);\r\nif (r)\r\nreturn r;\r\ndata_le = dm_block_data(b);\r\n*result = 1;\r\nfor (i = 0; i < block_size; i++) {\r\nif (data_le[i] != zero) {\r\n*result = 0;\r\nbreak;\r\n}\r\n}\r\nreturn dm_bm_unlock(b);\r\n}\r\nstatic void __setup_btree_details(struct dm_pool_metadata *pmd)\r\n{\r\npmd->info.tm = pmd->tm;\r\npmd->info.levels = 2;\r\npmd->info.value_type.context = pmd->data_sm;\r\npmd->info.value_type.size = sizeof(__le64);\r\npmd->info.value_type.inc = data_block_inc;\r\npmd->info.value_type.dec = data_block_dec;\r\npmd->info.value_type.equal = data_block_equal;\r\nmemcpy(&pmd->nb_info, &pmd->info, sizeof(pmd->nb_info));\r\npmd->nb_info.tm = pmd->nb_tm;\r\npmd->tl_info.tm = pmd->tm;\r\npmd->tl_info.levels = 1;\r\npmd->tl_info.value_type.context = &pmd->bl_info;\r\npmd->tl_info.value_type.size = sizeof(__le64);\r\npmd->tl_info.value_type.inc = subtree_inc;\r\npmd->tl_info.value_type.dec = subtree_dec;\r\npmd->tl_info.value_type.equal = subtree_equal;\r\npmd->bl_info.tm = pmd->tm;\r\npmd->bl_info.levels = 1;\r\npmd->bl_info.value_type.context = pmd->data_sm;\r\npmd->bl_info.value_type.size = sizeof(__le64);\r\npmd->bl_info.value_type.inc = data_block_inc;\r\npmd->bl_info.value_type.dec = data_block_dec;\r\npmd->bl_info.value_type.equal = data_block_equal;\r\npmd->details_info.tm = pmd->tm;\r\npmd->details_info.levels = 1;\r\npmd->details_info.value_type.context = NULL;\r\npmd->details_info.value_type.size = sizeof(struct disk_device_details);\r\npmd->details_info.value_type.inc = NULL;\r\npmd->details_info.value_type.dec = NULL;\r\npmd->details_info.value_type.equal = NULL;\r\n}\r\nstatic int save_sm_roots(struct dm_pool_metadata *pmd)\r\n{\r\nint r;\r\nsize_t len;\r\nr = dm_sm_root_size(pmd->metadata_sm, &len);\r\nif (r < 0)\r\nreturn r;\r\nr = dm_sm_copy_root(pmd->metadata_sm, &pmd->metadata_space_map_root, len);\r\nif (r < 0)\r\nreturn r;\r\nr = dm_sm_root_size(pmd->data_sm, &len);\r\nif (r < 0)\r\nreturn r;\r\nreturn dm_sm_copy_root(pmd->data_sm, &pmd->data_space_map_root, len);\r\n}\r\nstatic void copy_sm_roots(struct dm_pool_metadata *pmd,\r\nstruct thin_disk_superblock *disk)\r\n{\r\nmemcpy(&disk->metadata_space_map_root,\r\n&pmd->metadata_space_map_root,\r\nsizeof(pmd->metadata_space_map_root));\r\nmemcpy(&disk->data_space_map_root,\r\n&pmd->data_space_map_root,\r\nsizeof(pmd->data_space_map_root));\r\n}\r\nstatic int __write_initial_superblock(struct dm_pool_metadata *pmd)\r\n{\r\nint r;\r\nstruct dm_block *sblock;\r\nstruct thin_disk_superblock *disk_super;\r\nsector_t bdev_size = i_size_read(pmd->bdev->bd_inode) >> SECTOR_SHIFT;\r\nif (bdev_size > THIN_METADATA_MAX_SECTORS)\r\nbdev_size = THIN_METADATA_MAX_SECTORS;\r\nr = dm_sm_commit(pmd->data_sm);\r\nif (r < 0)\r\nreturn r;\r\nr = save_sm_roots(pmd);\r\nif (r < 0)\r\nreturn r;\r\nr = dm_tm_pre_commit(pmd->tm);\r\nif (r < 0)\r\nreturn r;\r\nr = superblock_lock_zero(pmd, &sblock);\r\nif (r)\r\nreturn r;\r\ndisk_super = dm_block_data(sblock);\r\ndisk_super->flags = 0;\r\nmemset(disk_super->uuid, 0, sizeof(disk_super->uuid));\r\ndisk_super->magic = cpu_to_le64(THIN_SUPERBLOCK_MAGIC);\r\ndisk_super->version = cpu_to_le32(THIN_VERSION);\r\ndisk_super->time = 0;\r\ndisk_super->trans_id = 0;\r\ndisk_super->held_root = 0;\r\ncopy_sm_roots(pmd, disk_super);\r\ndisk_super->data_mapping_root = cpu_to_le64(pmd->root);\r\ndisk_super->device_details_root = cpu_to_le64(pmd->details_root);\r\ndisk_super->metadata_block_size = cpu_to_le32(THIN_METADATA_BLOCK_SIZE);\r\ndisk_super->metadata_nr_blocks = cpu_to_le64(bdev_size >> SECTOR_TO_BLOCK_SHIFT);\r\ndisk_super->data_block_size = cpu_to_le32(pmd->data_block_size);\r\nreturn dm_tm_commit(pmd->tm, sblock);\r\n}\r\nstatic int __format_metadata(struct dm_pool_metadata *pmd)\r\n{\r\nint r;\r\nr = dm_tm_create_with_sm(pmd->bm, THIN_SUPERBLOCK_LOCATION,\r\n&pmd->tm, &pmd->metadata_sm);\r\nif (r < 0) {\r\nDMERR("tm_create_with_sm failed");\r\nreturn r;\r\n}\r\npmd->data_sm = dm_sm_disk_create(pmd->tm, 0);\r\nif (IS_ERR(pmd->data_sm)) {\r\nDMERR("sm_disk_create failed");\r\nr = PTR_ERR(pmd->data_sm);\r\ngoto bad_cleanup_tm;\r\n}\r\npmd->nb_tm = dm_tm_create_non_blocking_clone(pmd->tm);\r\nif (!pmd->nb_tm) {\r\nDMERR("could not create non-blocking clone tm");\r\nr = -ENOMEM;\r\ngoto bad_cleanup_data_sm;\r\n}\r\n__setup_btree_details(pmd);\r\nr = dm_btree_empty(&pmd->info, &pmd->root);\r\nif (r < 0)\r\ngoto bad_cleanup_nb_tm;\r\nr = dm_btree_empty(&pmd->details_info, &pmd->details_root);\r\nif (r < 0) {\r\nDMERR("couldn't create devices root");\r\ngoto bad_cleanup_nb_tm;\r\n}\r\nr = __write_initial_superblock(pmd);\r\nif (r)\r\ngoto bad_cleanup_nb_tm;\r\nreturn 0;\r\nbad_cleanup_nb_tm:\r\ndm_tm_destroy(pmd->nb_tm);\r\nbad_cleanup_data_sm:\r\ndm_sm_destroy(pmd->data_sm);\r\nbad_cleanup_tm:\r\ndm_tm_destroy(pmd->tm);\r\ndm_sm_destroy(pmd->metadata_sm);\r\nreturn r;\r\n}\r\nstatic int __check_incompat_features(struct thin_disk_superblock *disk_super,\r\nstruct dm_pool_metadata *pmd)\r\n{\r\nuint32_t features;\r\nfeatures = le32_to_cpu(disk_super->incompat_flags) & ~THIN_FEATURE_INCOMPAT_SUPP;\r\nif (features) {\r\nDMERR("could not access metadata due to unsupported optional features (%lx).",\r\n(unsigned long)features);\r\nreturn -EINVAL;\r\n}\r\nif (get_disk_ro(pmd->bdev->bd_disk))\r\nreturn 0;\r\nfeatures = le32_to_cpu(disk_super->compat_ro_flags) & ~THIN_FEATURE_COMPAT_RO_SUPP;\r\nif (features) {\r\nDMERR("could not access metadata RDWR due to unsupported optional features (%lx).",\r\n(unsigned long)features);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __open_metadata(struct dm_pool_metadata *pmd)\r\n{\r\nint r;\r\nstruct dm_block *sblock;\r\nstruct thin_disk_superblock *disk_super;\r\nr = dm_bm_read_lock(pmd->bm, THIN_SUPERBLOCK_LOCATION,\r\n&sb_validator, &sblock);\r\nif (r < 0) {\r\nDMERR("couldn't read superblock");\r\nreturn r;\r\n}\r\ndisk_super = dm_block_data(sblock);\r\nif (le32_to_cpu(disk_super->data_block_size) != pmd->data_block_size) {\r\nDMERR("changing the data block size (from %u to %llu) is not supported",\r\nle32_to_cpu(disk_super->data_block_size),\r\n(unsigned long long)pmd->data_block_size);\r\nr = -EINVAL;\r\ngoto bad_unlock_sblock;\r\n}\r\nr = __check_incompat_features(disk_super, pmd);\r\nif (r < 0)\r\ngoto bad_unlock_sblock;\r\nr = dm_tm_open_with_sm(pmd->bm, THIN_SUPERBLOCK_LOCATION,\r\ndisk_super->metadata_space_map_root,\r\nsizeof(disk_super->metadata_space_map_root),\r\n&pmd->tm, &pmd->metadata_sm);\r\nif (r < 0) {\r\nDMERR("tm_open_with_sm failed");\r\ngoto bad_unlock_sblock;\r\n}\r\npmd->data_sm = dm_sm_disk_open(pmd->tm, disk_super->data_space_map_root,\r\nsizeof(disk_super->data_space_map_root));\r\nif (IS_ERR(pmd->data_sm)) {\r\nDMERR("sm_disk_open failed");\r\nr = PTR_ERR(pmd->data_sm);\r\ngoto bad_cleanup_tm;\r\n}\r\npmd->nb_tm = dm_tm_create_non_blocking_clone(pmd->tm);\r\nif (!pmd->nb_tm) {\r\nDMERR("could not create non-blocking clone tm");\r\nr = -ENOMEM;\r\ngoto bad_cleanup_data_sm;\r\n}\r\n__setup_btree_details(pmd);\r\nreturn dm_bm_unlock(sblock);\r\nbad_cleanup_data_sm:\r\ndm_sm_destroy(pmd->data_sm);\r\nbad_cleanup_tm:\r\ndm_tm_destroy(pmd->tm);\r\ndm_sm_destroy(pmd->metadata_sm);\r\nbad_unlock_sblock:\r\ndm_bm_unlock(sblock);\r\nreturn r;\r\n}\r\nstatic int __open_or_format_metadata(struct dm_pool_metadata *pmd, bool format_device)\r\n{\r\nint r, unformatted;\r\nr = __superblock_all_zeroes(pmd->bm, &unformatted);\r\nif (r)\r\nreturn r;\r\nif (unformatted)\r\nreturn format_device ? __format_metadata(pmd) : -EPERM;\r\nreturn __open_metadata(pmd);\r\n}\r\nstatic int __create_persistent_data_objects(struct dm_pool_metadata *pmd, bool format_device)\r\n{\r\nint r;\r\npmd->bm = dm_block_manager_create(pmd->bdev, THIN_METADATA_BLOCK_SIZE << SECTOR_SHIFT,\r\nTHIN_METADATA_CACHE_SIZE,\r\nTHIN_MAX_CONCURRENT_LOCKS);\r\nif (IS_ERR(pmd->bm)) {\r\nDMERR("could not create block manager");\r\nreturn PTR_ERR(pmd->bm);\r\n}\r\nr = __open_or_format_metadata(pmd, format_device);\r\nif (r)\r\ndm_block_manager_destroy(pmd->bm);\r\nreturn r;\r\n}\r\nstatic void __destroy_persistent_data_objects(struct dm_pool_metadata *pmd)\r\n{\r\ndm_sm_destroy(pmd->data_sm);\r\ndm_sm_destroy(pmd->metadata_sm);\r\ndm_tm_destroy(pmd->nb_tm);\r\ndm_tm_destroy(pmd->tm);\r\ndm_block_manager_destroy(pmd->bm);\r\n}\r\nstatic int __begin_transaction(struct dm_pool_metadata *pmd)\r\n{\r\nint r;\r\nstruct thin_disk_superblock *disk_super;\r\nstruct dm_block *sblock;\r\nr = dm_bm_read_lock(pmd->bm, THIN_SUPERBLOCK_LOCATION,\r\n&sb_validator, &sblock);\r\nif (r)\r\nreturn r;\r\ndisk_super = dm_block_data(sblock);\r\npmd->time = le32_to_cpu(disk_super->time);\r\npmd->root = le64_to_cpu(disk_super->data_mapping_root);\r\npmd->details_root = le64_to_cpu(disk_super->device_details_root);\r\npmd->trans_id = le64_to_cpu(disk_super->trans_id);\r\npmd->flags = le32_to_cpu(disk_super->flags);\r\npmd->data_block_size = le32_to_cpu(disk_super->data_block_size);\r\ndm_bm_unlock(sblock);\r\nreturn 0;\r\n}\r\nstatic int __write_changed_details(struct dm_pool_metadata *pmd)\r\n{\r\nint r;\r\nstruct dm_thin_device *td, *tmp;\r\nstruct disk_device_details details;\r\nuint64_t key;\r\nlist_for_each_entry_safe(td, tmp, &pmd->thin_devices, list) {\r\nif (!td->changed)\r\ncontinue;\r\nkey = td->id;\r\ndetails.mapped_blocks = cpu_to_le64(td->mapped_blocks);\r\ndetails.transaction_id = cpu_to_le64(td->transaction_id);\r\ndetails.creation_time = cpu_to_le32(td->creation_time);\r\ndetails.snapshotted_time = cpu_to_le32(td->snapshotted_time);\r\n__dm_bless_for_disk(&details);\r\nr = dm_btree_insert(&pmd->details_info, pmd->details_root,\r\n&key, &details, &pmd->details_root);\r\nif (r)\r\nreturn r;\r\nif (td->open_count)\r\ntd->changed = 0;\r\nelse {\r\nlist_del(&td->list);\r\nkfree(td);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __commit_transaction(struct dm_pool_metadata *pmd)\r\n{\r\nint r;\r\nsize_t metadata_len, data_len;\r\nstruct thin_disk_superblock *disk_super;\r\nstruct dm_block *sblock;\r\nBUILD_BUG_ON(sizeof(struct thin_disk_superblock) > 512);\r\nr = __write_changed_details(pmd);\r\nif (r < 0)\r\nreturn r;\r\nr = dm_sm_commit(pmd->data_sm);\r\nif (r < 0)\r\nreturn r;\r\nr = dm_tm_pre_commit(pmd->tm);\r\nif (r < 0)\r\nreturn r;\r\nr = dm_sm_root_size(pmd->metadata_sm, &metadata_len);\r\nif (r < 0)\r\nreturn r;\r\nr = dm_sm_root_size(pmd->data_sm, &data_len);\r\nif (r < 0)\r\nreturn r;\r\nr = save_sm_roots(pmd);\r\nif (r < 0)\r\nreturn r;\r\nr = superblock_lock(pmd, &sblock);\r\nif (r)\r\nreturn r;\r\ndisk_super = dm_block_data(sblock);\r\ndisk_super->time = cpu_to_le32(pmd->time);\r\ndisk_super->data_mapping_root = cpu_to_le64(pmd->root);\r\ndisk_super->device_details_root = cpu_to_le64(pmd->details_root);\r\ndisk_super->trans_id = cpu_to_le64(pmd->trans_id);\r\ndisk_super->flags = cpu_to_le32(pmd->flags);\r\ncopy_sm_roots(pmd, disk_super);\r\nreturn dm_tm_commit(pmd->tm, sblock);\r\n}\r\nstruct dm_pool_metadata *dm_pool_metadata_open(struct block_device *bdev,\r\nsector_t data_block_size,\r\nbool format_device)\r\n{\r\nint r;\r\nstruct dm_pool_metadata *pmd;\r\npmd = kmalloc(sizeof(*pmd), GFP_KERNEL);\r\nif (!pmd) {\r\nDMERR("could not allocate metadata struct");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ninit_rwsem(&pmd->root_lock);\r\npmd->time = 0;\r\nINIT_LIST_HEAD(&pmd->thin_devices);\r\npmd->read_only = false;\r\npmd->fail_io = false;\r\npmd->bdev = bdev;\r\npmd->data_block_size = data_block_size;\r\nr = __create_persistent_data_objects(pmd, format_device);\r\nif (r) {\r\nkfree(pmd);\r\nreturn ERR_PTR(r);\r\n}\r\nr = __begin_transaction(pmd);\r\nif (r < 0) {\r\nif (dm_pool_metadata_close(pmd) < 0)\r\nDMWARN("%s: dm_pool_metadata_close() failed.", __func__);\r\nreturn ERR_PTR(r);\r\n}\r\nreturn pmd;\r\n}\r\nint dm_pool_metadata_close(struct dm_pool_metadata *pmd)\r\n{\r\nint r;\r\nunsigned open_devices = 0;\r\nstruct dm_thin_device *td, *tmp;\r\ndown_read(&pmd->root_lock);\r\nlist_for_each_entry_safe(td, tmp, &pmd->thin_devices, list) {\r\nif (td->open_count)\r\nopen_devices++;\r\nelse {\r\nlist_del(&td->list);\r\nkfree(td);\r\n}\r\n}\r\nup_read(&pmd->root_lock);\r\nif (open_devices) {\r\nDMERR("attempt to close pmd when %u device(s) are still open",\r\nopen_devices);\r\nreturn -EBUSY;\r\n}\r\nif (!pmd->read_only && !pmd->fail_io) {\r\nr = __commit_transaction(pmd);\r\nif (r < 0)\r\nDMWARN("%s: __commit_transaction() failed, error = %d",\r\n__func__, r);\r\n}\r\nif (!pmd->fail_io)\r\n__destroy_persistent_data_objects(pmd);\r\nkfree(pmd);\r\nreturn 0;\r\n}\r\nstatic int __open_device(struct dm_pool_metadata *pmd,\r\ndm_thin_id dev, int create,\r\nstruct dm_thin_device **td)\r\n{\r\nint r, changed = 0;\r\nstruct dm_thin_device *td2;\r\nuint64_t key = dev;\r\nstruct disk_device_details details_le;\r\nlist_for_each_entry(td2, &pmd->thin_devices, list)\r\nif (td2->id == dev) {\r\nif (create)\r\nreturn -EEXIST;\r\ntd2->open_count++;\r\n*td = td2;\r\nreturn 0;\r\n}\r\nr = dm_btree_lookup(&pmd->details_info, pmd->details_root,\r\n&key, &details_le);\r\nif (r) {\r\nif (r != -ENODATA || !create)\r\nreturn r;\r\nchanged = 1;\r\ndetails_le.mapped_blocks = 0;\r\ndetails_le.transaction_id = cpu_to_le64(pmd->trans_id);\r\ndetails_le.creation_time = cpu_to_le32(pmd->time);\r\ndetails_le.snapshotted_time = cpu_to_le32(pmd->time);\r\n}\r\n*td = kmalloc(sizeof(**td), GFP_NOIO);\r\nif (!*td)\r\nreturn -ENOMEM;\r\n(*td)->pmd = pmd;\r\n(*td)->id = dev;\r\n(*td)->open_count = 1;\r\n(*td)->changed = changed;\r\n(*td)->aborted_with_changes = false;\r\n(*td)->mapped_blocks = le64_to_cpu(details_le.mapped_blocks);\r\n(*td)->transaction_id = le64_to_cpu(details_le.transaction_id);\r\n(*td)->creation_time = le32_to_cpu(details_le.creation_time);\r\n(*td)->snapshotted_time = le32_to_cpu(details_le.snapshotted_time);\r\nlist_add(&(*td)->list, &pmd->thin_devices);\r\nreturn 0;\r\n}\r\nstatic void __close_device(struct dm_thin_device *td)\r\n{\r\n--td->open_count;\r\n}\r\nstatic int __create_thin(struct dm_pool_metadata *pmd,\r\ndm_thin_id dev)\r\n{\r\nint r;\r\ndm_block_t dev_root;\r\nuint64_t key = dev;\r\nstruct disk_device_details details_le;\r\nstruct dm_thin_device *td;\r\n__le64 value;\r\nr = dm_btree_lookup(&pmd->details_info, pmd->details_root,\r\n&key, &details_le);\r\nif (!r)\r\nreturn -EEXIST;\r\nr = dm_btree_empty(&pmd->bl_info, &dev_root);\r\nif (r)\r\nreturn r;\r\nvalue = cpu_to_le64(dev_root);\r\n__dm_bless_for_disk(&value);\r\nr = dm_btree_insert(&pmd->tl_info, pmd->root, &key, &value, &pmd->root);\r\nif (r) {\r\ndm_btree_del(&pmd->bl_info, dev_root);\r\nreturn r;\r\n}\r\nr = __open_device(pmd, dev, 1, &td);\r\nif (r) {\r\ndm_btree_remove(&pmd->tl_info, pmd->root, &key, &pmd->root);\r\ndm_btree_del(&pmd->bl_info, dev_root);\r\nreturn r;\r\n}\r\n__close_device(td);\r\nreturn r;\r\n}\r\nint dm_pool_create_thin(struct dm_pool_metadata *pmd, dm_thin_id dev)\r\n{\r\nint r = -EINVAL;\r\ndown_write(&pmd->root_lock);\r\nif (!pmd->fail_io)\r\nr = __create_thin(pmd, dev);\r\nup_write(&pmd->root_lock);\r\nreturn r;\r\n}\r\nstatic int __set_snapshot_details(struct dm_pool_metadata *pmd,\r\nstruct dm_thin_device *snap,\r\ndm_thin_id origin, uint32_t time)\r\n{\r\nint r;\r\nstruct dm_thin_device *td;\r\nr = __open_device(pmd, origin, 0, &td);\r\nif (r)\r\nreturn r;\r\ntd->changed = 1;\r\ntd->snapshotted_time = time;\r\nsnap->mapped_blocks = td->mapped_blocks;\r\nsnap->snapshotted_time = time;\r\n__close_device(td);\r\nreturn 0;\r\n}\r\nstatic int __create_snap(struct dm_pool_metadata *pmd,\r\ndm_thin_id dev, dm_thin_id origin)\r\n{\r\nint r;\r\ndm_block_t origin_root;\r\nuint64_t key = origin, dev_key = dev;\r\nstruct dm_thin_device *td;\r\nstruct disk_device_details details_le;\r\n__le64 value;\r\nr = dm_btree_lookup(&pmd->details_info, pmd->details_root,\r\n&dev_key, &details_le);\r\nif (!r)\r\nreturn -EEXIST;\r\nr = dm_btree_lookup(&pmd->tl_info, pmd->root, &key, &value);\r\nif (r)\r\nreturn r;\r\norigin_root = le64_to_cpu(value);\r\ndm_tm_inc(pmd->tm, origin_root);\r\nvalue = cpu_to_le64(origin_root);\r\n__dm_bless_for_disk(&value);\r\nkey = dev;\r\nr = dm_btree_insert(&pmd->tl_info, pmd->root, &key, &value, &pmd->root);\r\nif (r) {\r\ndm_tm_dec(pmd->tm, origin_root);\r\nreturn r;\r\n}\r\npmd->time++;\r\nr = __open_device(pmd, dev, 1, &td);\r\nif (r)\r\ngoto bad;\r\nr = __set_snapshot_details(pmd, td, origin, pmd->time);\r\n__close_device(td);\r\nif (r)\r\ngoto bad;\r\nreturn 0;\r\nbad:\r\ndm_btree_remove(&pmd->tl_info, pmd->root, &key, &pmd->root);\r\ndm_btree_remove(&pmd->details_info, pmd->details_root,\r\n&key, &pmd->details_root);\r\nreturn r;\r\n}\r\nint dm_pool_create_snap(struct dm_pool_metadata *pmd,\r\ndm_thin_id dev,\r\ndm_thin_id origin)\r\n{\r\nint r = -EINVAL;\r\ndown_write(&pmd->root_lock);\r\nif (!pmd->fail_io)\r\nr = __create_snap(pmd, dev, origin);\r\nup_write(&pmd->root_lock);\r\nreturn r;\r\n}\r\nstatic int __delete_device(struct dm_pool_metadata *pmd, dm_thin_id dev)\r\n{\r\nint r;\r\nuint64_t key = dev;\r\nstruct dm_thin_device *td;\r\nr = __open_device(pmd, dev, 0, &td);\r\nif (r)\r\nreturn r;\r\nif (td->open_count > 1) {\r\n__close_device(td);\r\nreturn -EBUSY;\r\n}\r\nlist_del(&td->list);\r\nkfree(td);\r\nr = dm_btree_remove(&pmd->details_info, pmd->details_root,\r\n&key, &pmd->details_root);\r\nif (r)\r\nreturn r;\r\nr = dm_btree_remove(&pmd->tl_info, pmd->root, &key, &pmd->root);\r\nif (r)\r\nreturn r;\r\nreturn 0;\r\n}\r\nint dm_pool_delete_thin_device(struct dm_pool_metadata *pmd,\r\ndm_thin_id dev)\r\n{\r\nint r = -EINVAL;\r\ndown_write(&pmd->root_lock);\r\nif (!pmd->fail_io)\r\nr = __delete_device(pmd, dev);\r\nup_write(&pmd->root_lock);\r\nreturn r;\r\n}\r\nint dm_pool_set_metadata_transaction_id(struct dm_pool_metadata *pmd,\r\nuint64_t current_id,\r\nuint64_t new_id)\r\n{\r\nint r = -EINVAL;\r\ndown_write(&pmd->root_lock);\r\nif (pmd->fail_io)\r\ngoto out;\r\nif (pmd->trans_id != current_id) {\r\nDMERR("mismatched transaction id");\r\ngoto out;\r\n}\r\npmd->trans_id = new_id;\r\nr = 0;\r\nout:\r\nup_write(&pmd->root_lock);\r\nreturn r;\r\n}\r\nint dm_pool_get_metadata_transaction_id(struct dm_pool_metadata *pmd,\r\nuint64_t *result)\r\n{\r\nint r = -EINVAL;\r\ndown_read(&pmd->root_lock);\r\nif (!pmd->fail_io) {\r\n*result = pmd->trans_id;\r\nr = 0;\r\n}\r\nup_read(&pmd->root_lock);\r\nreturn r;\r\n}\r\nstatic int __reserve_metadata_snap(struct dm_pool_metadata *pmd)\r\n{\r\nint r, inc;\r\nstruct thin_disk_superblock *disk_super;\r\nstruct dm_block *copy, *sblock;\r\ndm_block_t held_root;\r\ndm_sm_inc_block(pmd->metadata_sm, THIN_SUPERBLOCK_LOCATION);\r\nr = dm_tm_shadow_block(pmd->tm, THIN_SUPERBLOCK_LOCATION,\r\n&sb_validator, &copy, &inc);\r\nif (r)\r\nreturn r;\r\nBUG_ON(!inc);\r\nheld_root = dm_block_location(copy);\r\ndisk_super = dm_block_data(copy);\r\nif (le64_to_cpu(disk_super->held_root)) {\r\nDMWARN("Pool metadata snapshot already exists: release this before taking another.");\r\ndm_tm_dec(pmd->tm, held_root);\r\ndm_tm_unlock(pmd->tm, copy);\r\nreturn -EBUSY;\r\n}\r\nmemset(&disk_super->data_space_map_root, 0,\r\nsizeof(disk_super->data_space_map_root));\r\nmemset(&disk_super->metadata_space_map_root, 0,\r\nsizeof(disk_super->metadata_space_map_root));\r\ndm_tm_inc(pmd->tm, le64_to_cpu(disk_super->data_mapping_root));\r\ndm_tm_inc(pmd->tm, le64_to_cpu(disk_super->device_details_root));\r\ndm_tm_unlock(pmd->tm, copy);\r\nr = superblock_lock(pmd, &sblock);\r\nif (r) {\r\ndm_tm_dec(pmd->tm, held_root);\r\nreturn r;\r\n}\r\ndisk_super = dm_block_data(sblock);\r\ndisk_super->held_root = cpu_to_le64(held_root);\r\ndm_bm_unlock(sblock);\r\nreturn 0;\r\n}\r\nint dm_pool_reserve_metadata_snap(struct dm_pool_metadata *pmd)\r\n{\r\nint r = -EINVAL;\r\ndown_write(&pmd->root_lock);\r\nif (!pmd->fail_io)\r\nr = __reserve_metadata_snap(pmd);\r\nup_write(&pmd->root_lock);\r\nreturn r;\r\n}\r\nstatic int __release_metadata_snap(struct dm_pool_metadata *pmd)\r\n{\r\nint r;\r\nstruct thin_disk_superblock *disk_super;\r\nstruct dm_block *sblock, *copy;\r\ndm_block_t held_root;\r\nr = superblock_lock(pmd, &sblock);\r\nif (r)\r\nreturn r;\r\ndisk_super = dm_block_data(sblock);\r\nheld_root = le64_to_cpu(disk_super->held_root);\r\ndisk_super->held_root = cpu_to_le64(0);\r\ndm_bm_unlock(sblock);\r\nif (!held_root) {\r\nDMWARN("No pool metadata snapshot found: nothing to release.");\r\nreturn -EINVAL;\r\n}\r\nr = dm_tm_read_lock(pmd->tm, held_root, &sb_validator, &copy);\r\nif (r)\r\nreturn r;\r\ndisk_super = dm_block_data(copy);\r\ndm_sm_dec_block(pmd->metadata_sm, le64_to_cpu(disk_super->data_mapping_root));\r\ndm_sm_dec_block(pmd->metadata_sm, le64_to_cpu(disk_super->device_details_root));\r\ndm_sm_dec_block(pmd->metadata_sm, held_root);\r\nreturn dm_tm_unlock(pmd->tm, copy);\r\n}\r\nint dm_pool_release_metadata_snap(struct dm_pool_metadata *pmd)\r\n{\r\nint r = -EINVAL;\r\ndown_write(&pmd->root_lock);\r\nif (!pmd->fail_io)\r\nr = __release_metadata_snap(pmd);\r\nup_write(&pmd->root_lock);\r\nreturn r;\r\n}\r\nstatic int __get_metadata_snap(struct dm_pool_metadata *pmd,\r\ndm_block_t *result)\r\n{\r\nint r;\r\nstruct thin_disk_superblock *disk_super;\r\nstruct dm_block *sblock;\r\nr = dm_bm_read_lock(pmd->bm, THIN_SUPERBLOCK_LOCATION,\r\n&sb_validator, &sblock);\r\nif (r)\r\nreturn r;\r\ndisk_super = dm_block_data(sblock);\r\n*result = le64_to_cpu(disk_super->held_root);\r\nreturn dm_bm_unlock(sblock);\r\n}\r\nint dm_pool_get_metadata_snap(struct dm_pool_metadata *pmd,\r\ndm_block_t *result)\r\n{\r\nint r = -EINVAL;\r\ndown_read(&pmd->root_lock);\r\nif (!pmd->fail_io)\r\nr = __get_metadata_snap(pmd, result);\r\nup_read(&pmd->root_lock);\r\nreturn r;\r\n}\r\nint dm_pool_open_thin_device(struct dm_pool_metadata *pmd, dm_thin_id dev,\r\nstruct dm_thin_device **td)\r\n{\r\nint r = -EINVAL;\r\ndown_write(&pmd->root_lock);\r\nif (!pmd->fail_io)\r\nr = __open_device(pmd, dev, 0, td);\r\nup_write(&pmd->root_lock);\r\nreturn r;\r\n}\r\nint dm_pool_close_thin_device(struct dm_thin_device *td)\r\n{\r\ndown_write(&td->pmd->root_lock);\r\n__close_device(td);\r\nup_write(&td->pmd->root_lock);\r\nreturn 0;\r\n}\r\ndm_thin_id dm_thin_dev_id(struct dm_thin_device *td)\r\n{\r\nreturn td->id;\r\n}\r\nstatic bool __snapshotted_since(struct dm_thin_device *td, uint32_t time)\r\n{\r\nreturn td->snapshotted_time > time;\r\n}\r\nint dm_thin_find_block(struct dm_thin_device *td, dm_block_t block,\r\nint can_issue_io, struct dm_thin_lookup_result *result)\r\n{\r\nint r;\r\n__le64 value;\r\nstruct dm_pool_metadata *pmd = td->pmd;\r\ndm_block_t keys[2] = { td->id, block };\r\nstruct dm_btree_info *info;\r\nif (pmd->fail_io)\r\nreturn -EINVAL;\r\ndown_read(&pmd->root_lock);\r\nif (can_issue_io) {\r\ninfo = &pmd->info;\r\n} else\r\ninfo = &pmd->nb_info;\r\nr = dm_btree_lookup(info, pmd->root, keys, &value);\r\nif (!r) {\r\nuint64_t block_time = 0;\r\ndm_block_t exception_block;\r\nuint32_t exception_time;\r\nblock_time = le64_to_cpu(value);\r\nunpack_block_time(block_time, &exception_block,\r\n&exception_time);\r\nresult->block = exception_block;\r\nresult->shared = __snapshotted_since(td, exception_time);\r\n}\r\nup_read(&pmd->root_lock);\r\nreturn r;\r\n}\r\nstatic int __insert(struct dm_thin_device *td, dm_block_t block,\r\ndm_block_t data_block)\r\n{\r\nint r, inserted;\r\n__le64 value;\r\nstruct dm_pool_metadata *pmd = td->pmd;\r\ndm_block_t keys[2] = { td->id, block };\r\nvalue = cpu_to_le64(pack_block_time(data_block, pmd->time));\r\n__dm_bless_for_disk(&value);\r\nr = dm_btree_insert_notify(&pmd->info, pmd->root, keys, &value,\r\n&pmd->root, &inserted);\r\nif (r)\r\nreturn r;\r\ntd->changed = 1;\r\nif (inserted)\r\ntd->mapped_blocks++;\r\nreturn 0;\r\n}\r\nint dm_thin_insert_block(struct dm_thin_device *td, dm_block_t block,\r\ndm_block_t data_block)\r\n{\r\nint r = -EINVAL;\r\ndown_write(&td->pmd->root_lock);\r\nif (!td->pmd->fail_io)\r\nr = __insert(td, block, data_block);\r\nup_write(&td->pmd->root_lock);\r\nreturn r;\r\n}\r\nstatic int __remove(struct dm_thin_device *td, dm_block_t block)\r\n{\r\nint r;\r\nstruct dm_pool_metadata *pmd = td->pmd;\r\ndm_block_t keys[2] = { td->id, block };\r\nr = dm_btree_remove(&pmd->info, pmd->root, keys, &pmd->root);\r\nif (r)\r\nreturn r;\r\ntd->mapped_blocks--;\r\ntd->changed = 1;\r\nreturn 0;\r\n}\r\nint dm_thin_remove_block(struct dm_thin_device *td, dm_block_t block)\r\n{\r\nint r = -EINVAL;\r\ndown_write(&td->pmd->root_lock);\r\nif (!td->pmd->fail_io)\r\nr = __remove(td, block);\r\nup_write(&td->pmd->root_lock);\r\nreturn r;\r\n}\r\nint dm_pool_block_is_used(struct dm_pool_metadata *pmd, dm_block_t b, bool *result)\r\n{\r\nint r;\r\nuint32_t ref_count;\r\ndown_read(&pmd->root_lock);\r\nr = dm_sm_get_count(pmd->data_sm, b, &ref_count);\r\nif (!r)\r\n*result = (ref_count != 0);\r\nup_read(&pmd->root_lock);\r\nreturn r;\r\n}\r\nbool dm_thin_changed_this_transaction(struct dm_thin_device *td)\r\n{\r\nint r;\r\ndown_read(&td->pmd->root_lock);\r\nr = td->changed;\r\nup_read(&td->pmd->root_lock);\r\nreturn r;\r\n}\r\nbool dm_pool_changed_this_transaction(struct dm_pool_metadata *pmd)\r\n{\r\nbool r = false;\r\nstruct dm_thin_device *td, *tmp;\r\ndown_read(&pmd->root_lock);\r\nlist_for_each_entry_safe(td, tmp, &pmd->thin_devices, list) {\r\nif (td->changed) {\r\nr = td->changed;\r\nbreak;\r\n}\r\n}\r\nup_read(&pmd->root_lock);\r\nreturn r;\r\n}\r\nbool dm_thin_aborted_changes(struct dm_thin_device *td)\r\n{\r\nbool r;\r\ndown_read(&td->pmd->root_lock);\r\nr = td->aborted_with_changes;\r\nup_read(&td->pmd->root_lock);\r\nreturn r;\r\n}\r\nint dm_pool_alloc_data_block(struct dm_pool_metadata *pmd, dm_block_t *result)\r\n{\r\nint r = -EINVAL;\r\ndown_write(&pmd->root_lock);\r\nif (!pmd->fail_io)\r\nr = dm_sm_new_block(pmd->data_sm, result);\r\nup_write(&pmd->root_lock);\r\nreturn r;\r\n}\r\nint dm_pool_commit_metadata(struct dm_pool_metadata *pmd)\r\n{\r\nint r = -EINVAL;\r\ndown_write(&pmd->root_lock);\r\nif (pmd->fail_io)\r\ngoto out;\r\nr = __commit_transaction(pmd);\r\nif (r <= 0)\r\ngoto out;\r\nr = __begin_transaction(pmd);\r\nout:\r\nup_write(&pmd->root_lock);\r\nreturn r;\r\n}\r\nstatic void __set_abort_with_changes_flags(struct dm_pool_metadata *pmd)\r\n{\r\nstruct dm_thin_device *td;\r\nlist_for_each_entry(td, &pmd->thin_devices, list)\r\ntd->aborted_with_changes = td->changed;\r\n}\r\nint dm_pool_abort_metadata(struct dm_pool_metadata *pmd)\r\n{\r\nint r = -EINVAL;\r\ndown_write(&pmd->root_lock);\r\nif (pmd->fail_io)\r\ngoto out;\r\n__set_abort_with_changes_flags(pmd);\r\n__destroy_persistent_data_objects(pmd);\r\nr = __create_persistent_data_objects(pmd, false);\r\nif (r)\r\npmd->fail_io = true;\r\nout:\r\nup_write(&pmd->root_lock);\r\nreturn r;\r\n}\r\nint dm_pool_get_free_block_count(struct dm_pool_metadata *pmd, dm_block_t *result)\r\n{\r\nint r = -EINVAL;\r\ndown_read(&pmd->root_lock);\r\nif (!pmd->fail_io)\r\nr = dm_sm_get_nr_free(pmd->data_sm, result);\r\nup_read(&pmd->root_lock);\r\nreturn r;\r\n}\r\nint dm_pool_get_free_metadata_block_count(struct dm_pool_metadata *pmd,\r\ndm_block_t *result)\r\n{\r\nint r = -EINVAL;\r\ndown_read(&pmd->root_lock);\r\nif (!pmd->fail_io)\r\nr = dm_sm_get_nr_free(pmd->metadata_sm, result);\r\nup_read(&pmd->root_lock);\r\nreturn r;\r\n}\r\nint dm_pool_get_metadata_dev_size(struct dm_pool_metadata *pmd,\r\ndm_block_t *result)\r\n{\r\nint r = -EINVAL;\r\ndown_read(&pmd->root_lock);\r\nif (!pmd->fail_io)\r\nr = dm_sm_get_nr_blocks(pmd->metadata_sm, result);\r\nup_read(&pmd->root_lock);\r\nreturn r;\r\n}\r\nint dm_pool_get_data_dev_size(struct dm_pool_metadata *pmd, dm_block_t *result)\r\n{\r\nint r = -EINVAL;\r\ndown_read(&pmd->root_lock);\r\nif (!pmd->fail_io)\r\nr = dm_sm_get_nr_blocks(pmd->data_sm, result);\r\nup_read(&pmd->root_lock);\r\nreturn r;\r\n}\r\nint dm_thin_get_mapped_count(struct dm_thin_device *td, dm_block_t *result)\r\n{\r\nint r = -EINVAL;\r\nstruct dm_pool_metadata *pmd = td->pmd;\r\ndown_read(&pmd->root_lock);\r\nif (!pmd->fail_io) {\r\n*result = td->mapped_blocks;\r\nr = 0;\r\n}\r\nup_read(&pmd->root_lock);\r\nreturn r;\r\n}\r\nstatic int __highest_block(struct dm_thin_device *td, dm_block_t *result)\r\n{\r\nint r;\r\n__le64 value_le;\r\ndm_block_t thin_root;\r\nstruct dm_pool_metadata *pmd = td->pmd;\r\nr = dm_btree_lookup(&pmd->tl_info, pmd->root, &td->id, &value_le);\r\nif (r)\r\nreturn r;\r\nthin_root = le64_to_cpu(value_le);\r\nreturn dm_btree_find_highest_key(&pmd->bl_info, thin_root, result);\r\n}\r\nint dm_thin_get_highest_mapped_block(struct dm_thin_device *td,\r\ndm_block_t *result)\r\n{\r\nint r = -EINVAL;\r\nstruct dm_pool_metadata *pmd = td->pmd;\r\ndown_read(&pmd->root_lock);\r\nif (!pmd->fail_io)\r\nr = __highest_block(td, result);\r\nup_read(&pmd->root_lock);\r\nreturn r;\r\n}\r\nstatic int __resize_space_map(struct dm_space_map *sm, dm_block_t new_count)\r\n{\r\nint r;\r\ndm_block_t old_count;\r\nr = dm_sm_get_nr_blocks(sm, &old_count);\r\nif (r)\r\nreturn r;\r\nif (new_count == old_count)\r\nreturn 0;\r\nif (new_count < old_count) {\r\nDMERR("cannot reduce size of space map");\r\nreturn -EINVAL;\r\n}\r\nreturn dm_sm_extend(sm, new_count - old_count);\r\n}\r\nint dm_pool_resize_data_dev(struct dm_pool_metadata *pmd, dm_block_t new_count)\r\n{\r\nint r = -EINVAL;\r\ndown_write(&pmd->root_lock);\r\nif (!pmd->fail_io)\r\nr = __resize_space_map(pmd->data_sm, new_count);\r\nup_write(&pmd->root_lock);\r\nreturn r;\r\n}\r\nint dm_pool_resize_metadata_dev(struct dm_pool_metadata *pmd, dm_block_t new_count)\r\n{\r\nint r = -EINVAL;\r\ndown_write(&pmd->root_lock);\r\nif (!pmd->fail_io)\r\nr = __resize_space_map(pmd->metadata_sm, new_count);\r\nup_write(&pmd->root_lock);\r\nreturn r;\r\n}\r\nvoid dm_pool_metadata_read_only(struct dm_pool_metadata *pmd)\r\n{\r\ndown_write(&pmd->root_lock);\r\npmd->read_only = true;\r\ndm_bm_set_read_only(pmd->bm);\r\nup_write(&pmd->root_lock);\r\n}\r\nvoid dm_pool_metadata_read_write(struct dm_pool_metadata *pmd)\r\n{\r\ndown_write(&pmd->root_lock);\r\npmd->read_only = false;\r\ndm_bm_set_read_write(pmd->bm);\r\nup_write(&pmd->root_lock);\r\n}\r\nint dm_pool_register_metadata_threshold(struct dm_pool_metadata *pmd,\r\ndm_block_t threshold,\r\ndm_sm_threshold_fn fn,\r\nvoid *context)\r\n{\r\nint r;\r\ndown_write(&pmd->root_lock);\r\nr = dm_sm_register_threshold_callback(pmd->metadata_sm, threshold, fn, context);\r\nup_write(&pmd->root_lock);\r\nreturn r;\r\n}\r\nint dm_pool_metadata_set_needs_check(struct dm_pool_metadata *pmd)\r\n{\r\nint r;\r\nstruct dm_block *sblock;\r\nstruct thin_disk_superblock *disk_super;\r\ndown_write(&pmd->root_lock);\r\npmd->flags |= THIN_METADATA_NEEDS_CHECK_FLAG;\r\nr = superblock_lock(pmd, &sblock);\r\nif (r) {\r\nDMERR("couldn't read superblock");\r\ngoto out;\r\n}\r\ndisk_super = dm_block_data(sblock);\r\ndisk_super->flags = cpu_to_le32(pmd->flags);\r\ndm_bm_unlock(sblock);\r\nout:\r\nup_write(&pmd->root_lock);\r\nreturn r;\r\n}\r\nbool dm_pool_metadata_needs_check(struct dm_pool_metadata *pmd)\r\n{\r\nbool needs_check;\r\ndown_read(&pmd->root_lock);\r\nneeds_check = pmd->flags & THIN_METADATA_NEEDS_CHECK_FLAG;\r\nup_read(&pmd->root_lock);\r\nreturn needs_check;\r\n}\r\nvoid dm_pool_issue_prefetches(struct dm_pool_metadata *pmd)\r\n{\r\ndm_tm_issue_prefetches(pmd->tm);\r\n}
