unsigned long tpm_calc_ordinal_duration(struct tpm_chip *chip,\r\nu32 ordinal)\r\n{\r\nint duration_idx = TPM_UNDEFINED;\r\nint duration = 0;\r\nu8 category = (ordinal >> 24) & 0xFF;\r\nif ((category == TPM_PROTECTED_COMMAND && ordinal < TPM_MAX_ORDINAL) ||\r\n(category == TPM_CONNECTION_COMMAND && ordinal < TSC_MAX_ORDINAL))\r\nduration_idx = tpm_ordinal_duration[ordinal];\r\nif (duration_idx != TPM_UNDEFINED)\r\nduration = chip->vendor.duration[duration_idx];\r\nif (duration <= 0)\r\nreturn 2 * 60 * HZ;\r\nelse\r\nreturn duration;\r\n}\r\nssize_t tpm_transmit(struct tpm_chip *chip, const char *buf,\r\nsize_t bufsiz)\r\n{\r\nssize_t rc;\r\nu32 count, ordinal;\r\nunsigned long stop;\r\nif (bufsiz > TPM_BUFSIZE)\r\nbufsiz = TPM_BUFSIZE;\r\ncount = be32_to_cpu(*((__be32 *) (buf + 2)));\r\nordinal = be32_to_cpu(*((__be32 *) (buf + 6)));\r\nif (count == 0)\r\nreturn -ENODATA;\r\nif (count > bufsiz) {\r\ndev_err(chip->pdev,\r\n"invalid count value %x %zx\n", count, bufsiz);\r\nreturn -E2BIG;\r\n}\r\nmutex_lock(&chip->tpm_mutex);\r\nrc = chip->ops->send(chip, (u8 *) buf, count);\r\nif (rc < 0) {\r\ndev_err(chip->pdev,\r\n"tpm_transmit: tpm_send: error %zd\n", rc);\r\ngoto out;\r\n}\r\nif (chip->vendor.irq)\r\ngoto out_recv;\r\nif (chip->flags & TPM_CHIP_FLAG_TPM2)\r\nstop = jiffies + tpm2_calc_ordinal_duration(chip, ordinal);\r\nelse\r\nstop = jiffies + tpm_calc_ordinal_duration(chip, ordinal);\r\ndo {\r\nu8 status = chip->ops->status(chip);\r\nif ((status & chip->ops->req_complete_mask) ==\r\nchip->ops->req_complete_val)\r\ngoto out_recv;\r\nif (chip->ops->req_canceled(chip, status)) {\r\ndev_err(chip->pdev, "Operation Canceled\n");\r\nrc = -ECANCELED;\r\ngoto out;\r\n}\r\nmsleep(TPM_TIMEOUT);\r\nrmb();\r\n} while (time_before(jiffies, stop));\r\nchip->ops->cancel(chip);\r\ndev_err(chip->pdev, "Operation Timed out\n");\r\nrc = -ETIME;\r\ngoto out;\r\nout_recv:\r\nrc = chip->ops->recv(chip, (u8 *) buf, bufsiz);\r\nif (rc < 0)\r\ndev_err(chip->pdev,\r\n"tpm_transmit: tpm_recv: error %zd\n", rc);\r\nout:\r\nmutex_unlock(&chip->tpm_mutex);\r\nreturn rc;\r\n}\r\nssize_t tpm_transmit_cmd(struct tpm_chip *chip, void *cmd,\r\nint len, const char *desc)\r\n{\r\nstruct tpm_output_header *header;\r\nint err;\r\nlen = tpm_transmit(chip, (u8 *) cmd, len);\r\nif (len < 0)\r\nreturn len;\r\nelse if (len < TPM_HEADER_SIZE)\r\nreturn -EFAULT;\r\nheader = cmd;\r\nerr = be32_to_cpu(header->return_code);\r\nif (err != 0 && desc)\r\ndev_err(chip->pdev, "A TPM error (%d) occurred %s\n", err,\r\ndesc);\r\nreturn err;\r\n}\r\nssize_t tpm_getcap(struct device *dev, __be32 subcap_id, cap_t *cap,\r\nconst char *desc)\r\n{\r\nstruct tpm_cmd_t tpm_cmd;\r\nint rc;\r\nstruct tpm_chip *chip = dev_get_drvdata(dev);\r\ntpm_cmd.header.in = tpm_getcap_header;\r\nif (subcap_id == CAP_VERSION_1_1 || subcap_id == CAP_VERSION_1_2) {\r\ntpm_cmd.params.getcap_in.cap = subcap_id;\r\ntpm_cmd.params.getcap_in.subcap_size = cpu_to_be32(0);\r\ntpm_cmd.header.in.length -= cpu_to_be32(sizeof(__be32));\r\n} else {\r\nif (subcap_id == TPM_CAP_FLAG_PERM ||\r\nsubcap_id == TPM_CAP_FLAG_VOL)\r\ntpm_cmd.params.getcap_in.cap = TPM_CAP_FLAG;\r\nelse\r\ntpm_cmd.params.getcap_in.cap = TPM_CAP_PROP;\r\ntpm_cmd.params.getcap_in.subcap_size = cpu_to_be32(4);\r\ntpm_cmd.params.getcap_in.subcap = subcap_id;\r\n}\r\nrc = tpm_transmit_cmd(chip, &tpm_cmd, TPM_INTERNAL_RESULT_SIZE, desc);\r\nif (!rc)\r\n*cap = tpm_cmd.params.getcap_out.cap;\r\nreturn rc;\r\n}\r\nvoid tpm_gen_interrupt(struct tpm_chip *chip)\r\n{\r\nstruct tpm_cmd_t tpm_cmd;\r\nssize_t rc;\r\ntpm_cmd.header.in = tpm_getcap_header;\r\ntpm_cmd.params.getcap_in.cap = TPM_CAP_PROP;\r\ntpm_cmd.params.getcap_in.subcap_size = cpu_to_be32(4);\r\ntpm_cmd.params.getcap_in.subcap = TPM_CAP_PROP_TIS_TIMEOUT;\r\nrc = tpm_transmit_cmd(chip, &tpm_cmd, TPM_INTERNAL_RESULT_SIZE,\r\n"attempting to determine the timeouts");\r\n}\r\nstatic int tpm_startup(struct tpm_chip *chip, __be16 startup_type)\r\n{\r\nstruct tpm_cmd_t start_cmd;\r\nstart_cmd.header.in = tpm_startup_header;\r\nstart_cmd.params.startup_in.startup_type = startup_type;\r\nreturn tpm_transmit_cmd(chip, &start_cmd, TPM_INTERNAL_RESULT_SIZE,\r\n"attempting to start the TPM");\r\n}\r\nint tpm_get_timeouts(struct tpm_chip *chip)\r\n{\r\nstruct tpm_cmd_t tpm_cmd;\r\nunsigned long new_timeout[4];\r\nunsigned long old_timeout[4];\r\nstruct duration_t *duration_cap;\r\nssize_t rc;\r\ntpm_cmd.header.in = tpm_getcap_header;\r\ntpm_cmd.params.getcap_in.cap = TPM_CAP_PROP;\r\ntpm_cmd.params.getcap_in.subcap_size = cpu_to_be32(4);\r\ntpm_cmd.params.getcap_in.subcap = TPM_CAP_PROP_TIS_TIMEOUT;\r\nrc = tpm_transmit_cmd(chip, &tpm_cmd, TPM_INTERNAL_RESULT_SIZE, NULL);\r\nif (rc == TPM_ERR_INVALID_POSTINIT) {\r\ndev_info(chip->pdev, "Issuing TPM_STARTUP");\r\nif (tpm_startup(chip, TPM_ST_CLEAR))\r\nreturn rc;\r\ntpm_cmd.header.in = tpm_getcap_header;\r\ntpm_cmd.params.getcap_in.cap = TPM_CAP_PROP;\r\ntpm_cmd.params.getcap_in.subcap_size = cpu_to_be32(4);\r\ntpm_cmd.params.getcap_in.subcap = TPM_CAP_PROP_TIS_TIMEOUT;\r\nrc = tpm_transmit_cmd(chip, &tpm_cmd, TPM_INTERNAL_RESULT_SIZE,\r\nNULL);\r\n}\r\nif (rc) {\r\ndev_err(chip->pdev,\r\n"A TPM error (%zd) occurred attempting to determine the timeouts\n",\r\nrc);\r\ngoto duration;\r\n}\r\nif (be32_to_cpu(tpm_cmd.header.out.return_code) != 0 ||\r\nbe32_to_cpu(tpm_cmd.header.out.length)\r\n!= sizeof(tpm_cmd.header.out) + sizeof(u32) + 4 * sizeof(u32))\r\nreturn -EINVAL;\r\nold_timeout[0] = be32_to_cpu(tpm_cmd.params.getcap_out.cap.timeout.a);\r\nold_timeout[1] = be32_to_cpu(tpm_cmd.params.getcap_out.cap.timeout.b);\r\nold_timeout[2] = be32_to_cpu(tpm_cmd.params.getcap_out.cap.timeout.c);\r\nold_timeout[3] = be32_to_cpu(tpm_cmd.params.getcap_out.cap.timeout.d);\r\nmemcpy(new_timeout, old_timeout, sizeof(new_timeout));\r\nif (chip->ops->update_timeouts != NULL)\r\nchip->vendor.timeout_adjusted =\r\nchip->ops->update_timeouts(chip, new_timeout);\r\nif (!chip->vendor.timeout_adjusted) {\r\nif (new_timeout[0] != 0 && new_timeout[0] < 1000) {\r\nint i;\r\nfor (i = 0; i != ARRAY_SIZE(new_timeout); i++)\r\nnew_timeout[i] *= 1000;\r\nchip->vendor.timeout_adjusted = true;\r\n}\r\n}\r\nif (chip->vendor.timeout_adjusted) {\r\ndev_info(chip->pdev,\r\nHW_ERR "Adjusting reported timeouts: A %lu->%luus B %lu->%luus C %lu->%luus D %lu->%luus\n",\r\nold_timeout[0], new_timeout[0],\r\nold_timeout[1], new_timeout[1],\r\nold_timeout[2], new_timeout[2],\r\nold_timeout[3], new_timeout[3]);\r\n}\r\nchip->vendor.timeout_a = usecs_to_jiffies(new_timeout[0]);\r\nchip->vendor.timeout_b = usecs_to_jiffies(new_timeout[1]);\r\nchip->vendor.timeout_c = usecs_to_jiffies(new_timeout[2]);\r\nchip->vendor.timeout_d = usecs_to_jiffies(new_timeout[3]);\r\nduration:\r\ntpm_cmd.header.in = tpm_getcap_header;\r\ntpm_cmd.params.getcap_in.cap = TPM_CAP_PROP;\r\ntpm_cmd.params.getcap_in.subcap_size = cpu_to_be32(4);\r\ntpm_cmd.params.getcap_in.subcap = TPM_CAP_PROP_TIS_DURATION;\r\nrc = tpm_transmit_cmd(chip, &tpm_cmd, TPM_INTERNAL_RESULT_SIZE,\r\n"attempting to determine the durations");\r\nif (rc)\r\nreturn rc;\r\nif (be32_to_cpu(tpm_cmd.header.out.return_code) != 0 ||\r\nbe32_to_cpu(tpm_cmd.header.out.length)\r\n!= sizeof(tpm_cmd.header.out) + sizeof(u32) + 3 * sizeof(u32))\r\nreturn -EINVAL;\r\nduration_cap = &tpm_cmd.params.getcap_out.cap.duration;\r\nchip->vendor.duration[TPM_SHORT] =\r\nusecs_to_jiffies(be32_to_cpu(duration_cap->tpm_short));\r\nchip->vendor.duration[TPM_MEDIUM] =\r\nusecs_to_jiffies(be32_to_cpu(duration_cap->tpm_medium));\r\nchip->vendor.duration[TPM_LONG] =\r\nusecs_to_jiffies(be32_to_cpu(duration_cap->tpm_long));\r\nif (chip->vendor.duration[TPM_SHORT] < (HZ / 100)) {\r\nchip->vendor.duration[TPM_SHORT] = HZ;\r\nchip->vendor.duration[TPM_MEDIUM] *= 1000;\r\nchip->vendor.duration[TPM_LONG] *= 1000;\r\nchip->vendor.duration_adjusted = true;\r\ndev_info(chip->pdev, "Adjusting TPM timeout parameters.");\r\n}\r\nreturn 0;\r\n}\r\nstatic int tpm_continue_selftest(struct tpm_chip *chip)\r\n{\r\nint rc;\r\nstruct tpm_cmd_t cmd;\r\ncmd.header.in = continue_selftest_header;\r\nrc = tpm_transmit_cmd(chip, &cmd, CONTINUE_SELFTEST_RESULT_SIZE,\r\n"continue selftest");\r\nreturn rc;\r\n}\r\nint tpm_pcr_read_dev(struct tpm_chip *chip, int pcr_idx, u8 *res_buf)\r\n{\r\nint rc;\r\nstruct tpm_cmd_t cmd;\r\ncmd.header.in = pcrread_header;\r\ncmd.params.pcrread_in.pcr_idx = cpu_to_be32(pcr_idx);\r\nrc = tpm_transmit_cmd(chip, &cmd, READ_PCR_RESULT_SIZE,\r\n"attempting to read a pcr value");\r\nif (rc == 0)\r\nmemcpy(res_buf, cmd.params.pcrread_out.pcr_result,\r\nTPM_DIGEST_SIZE);\r\nreturn rc;\r\n}\r\nint tpm_pcr_read(u32 chip_num, int pcr_idx, u8 *res_buf)\r\n{\r\nstruct tpm_chip *chip;\r\nint rc;\r\nchip = tpm_chip_find_get(chip_num);\r\nif (chip == NULL)\r\nreturn -ENODEV;\r\nif (chip->flags & TPM_CHIP_FLAG_TPM2)\r\nrc = tpm2_pcr_read(chip, pcr_idx, res_buf);\r\nelse\r\nrc = tpm_pcr_read_dev(chip, pcr_idx, res_buf);\r\ntpm_chip_put(chip);\r\nreturn rc;\r\n}\r\nint tpm_pcr_extend(u32 chip_num, int pcr_idx, const u8 *hash)\r\n{\r\nstruct tpm_cmd_t cmd;\r\nint rc;\r\nstruct tpm_chip *chip;\r\nchip = tpm_chip_find_get(chip_num);\r\nif (chip == NULL)\r\nreturn -ENODEV;\r\nif (chip->flags & TPM_CHIP_FLAG_TPM2) {\r\nrc = tpm2_pcr_extend(chip, pcr_idx, hash);\r\ntpm_chip_put(chip);\r\nreturn rc;\r\n}\r\ncmd.header.in = pcrextend_header;\r\ncmd.params.pcrextend_in.pcr_idx = cpu_to_be32(pcr_idx);\r\nmemcpy(cmd.params.pcrextend_in.hash, hash, TPM_DIGEST_SIZE);\r\nrc = tpm_transmit_cmd(chip, &cmd, EXTEND_PCR_RESULT_SIZE,\r\n"attempting extend a PCR value");\r\ntpm_chip_put(chip);\r\nreturn rc;\r\n}\r\nint tpm_do_selftest(struct tpm_chip *chip)\r\n{\r\nint rc;\r\nunsigned int loops;\r\nunsigned int delay_msec = 100;\r\nunsigned long duration;\r\nstruct tpm_cmd_t cmd;\r\nduration = tpm_calc_ordinal_duration(chip, TPM_ORD_CONTINUE_SELFTEST);\r\nloops = jiffies_to_msecs(duration) / delay_msec;\r\nrc = tpm_continue_selftest(chip);\r\nif (rc)\r\nreturn rc;\r\ndo {\r\ncmd.header.in = pcrread_header;\r\ncmd.params.pcrread_in.pcr_idx = cpu_to_be32(0);\r\nrc = tpm_transmit(chip, (u8 *) &cmd, READ_PCR_RESULT_SIZE);\r\nif (rc == -ETIME) {\r\ndev_info(chip->pdev, HW_ERR "TPM command timed out during continue self test");\r\nmsleep(delay_msec);\r\ncontinue;\r\n}\r\nif (rc < TPM_HEADER_SIZE)\r\nreturn -EFAULT;\r\nrc = be32_to_cpu(cmd.header.out.return_code);\r\nif (rc == TPM_ERR_DISABLED || rc == TPM_ERR_DEACTIVATED) {\r\ndev_info(chip->pdev,\r\n"TPM is disabled/deactivated (0x%X)\n", rc);\r\nreturn 0;\r\n}\r\nif (rc != TPM_WARN_DOING_SELFTEST)\r\nreturn rc;\r\nmsleep(delay_msec);\r\n} while (--loops > 0);\r\nreturn rc;\r\n}\r\nint tpm_send(u32 chip_num, void *cmd, size_t buflen)\r\n{\r\nstruct tpm_chip *chip;\r\nint rc;\r\nchip = tpm_chip_find_get(chip_num);\r\nif (chip == NULL)\r\nreturn -ENODEV;\r\nrc = tpm_transmit_cmd(chip, cmd, buflen, "attempting tpm_cmd");\r\ntpm_chip_put(chip);\r\nreturn rc;\r\n}\r\nstatic bool wait_for_tpm_stat_cond(struct tpm_chip *chip, u8 mask,\r\nbool check_cancel, bool *canceled)\r\n{\r\nu8 status = chip->ops->status(chip);\r\n*canceled = false;\r\nif ((status & mask) == mask)\r\nreturn true;\r\nif (check_cancel && chip->ops->req_canceled(chip, status)) {\r\n*canceled = true;\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nint wait_for_tpm_stat(struct tpm_chip *chip, u8 mask, unsigned long timeout,\r\nwait_queue_head_t *queue, bool check_cancel)\r\n{\r\nunsigned long stop;\r\nlong rc;\r\nu8 status;\r\nbool canceled = false;\r\nstatus = chip->ops->status(chip);\r\nif ((status & mask) == mask)\r\nreturn 0;\r\nstop = jiffies + timeout;\r\nif (chip->vendor.irq) {\r\nagain:\r\ntimeout = stop - jiffies;\r\nif ((long)timeout <= 0)\r\nreturn -ETIME;\r\nrc = wait_event_interruptible_timeout(*queue,\r\nwait_for_tpm_stat_cond(chip, mask, check_cancel,\r\n&canceled),\r\ntimeout);\r\nif (rc > 0) {\r\nif (canceled)\r\nreturn -ECANCELED;\r\nreturn 0;\r\n}\r\nif (rc == -ERESTARTSYS && freezing(current)) {\r\nclear_thread_flag(TIF_SIGPENDING);\r\ngoto again;\r\n}\r\n} else {\r\ndo {\r\nmsleep(TPM_TIMEOUT);\r\nstatus = chip->ops->status(chip);\r\nif ((status & mask) == mask)\r\nreturn 0;\r\n} while (time_before(jiffies, stop));\r\n}\r\nreturn -ETIME;\r\n}\r\nint tpm_pm_suspend(struct device *dev)\r\n{\r\nstruct tpm_chip *chip = dev_get_drvdata(dev);\r\nstruct tpm_cmd_t cmd;\r\nint rc, try;\r\nu8 dummy_hash[TPM_DIGEST_SIZE] = { 0 };\r\nif (chip == NULL)\r\nreturn -ENODEV;\r\nif (chip->flags & TPM_CHIP_FLAG_TPM2) {\r\ntpm2_shutdown(chip, TPM2_SU_STATE);\r\nreturn 0;\r\n}\r\nif (tpm_suspend_pcr) {\r\ncmd.header.in = pcrextend_header;\r\ncmd.params.pcrextend_in.pcr_idx = cpu_to_be32(tpm_suspend_pcr);\r\nmemcpy(cmd.params.pcrextend_in.hash, dummy_hash,\r\nTPM_DIGEST_SIZE);\r\nrc = tpm_transmit_cmd(chip, &cmd, EXTEND_PCR_RESULT_SIZE,\r\n"extending dummy pcr before suspend");\r\n}\r\nfor (try = 0; try < TPM_RETRY; try++) {\r\ncmd.header.in = savestate_header;\r\nrc = tpm_transmit_cmd(chip, &cmd, SAVESTATE_RESULT_SIZE, NULL);\r\nif (rc != TPM_WARN_RETRY)\r\nbreak;\r\nmsleep(TPM_TIMEOUT_RETRY);\r\n}\r\nif (rc)\r\ndev_err(chip->pdev,\r\n"Error (%d) sending savestate before suspend\n", rc);\r\nelse if (try > 0)\r\ndev_warn(chip->pdev, "TPM savestate took %dms\n",\r\ntry * TPM_TIMEOUT_RETRY);\r\nreturn rc;\r\n}\r\nint tpm_pm_resume(struct device *dev)\r\n{\r\nstruct tpm_chip *chip = dev_get_drvdata(dev);\r\nif (chip == NULL)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nint tpm_get_random(u32 chip_num, u8 *out, size_t max)\r\n{\r\nstruct tpm_chip *chip;\r\nstruct tpm_cmd_t tpm_cmd;\r\nu32 recd, num_bytes = min_t(u32, max, TPM_MAX_RNG_DATA);\r\nint err, total = 0, retries = 5;\r\nu8 *dest = out;\r\nif (!out || !num_bytes || max > TPM_MAX_RNG_DATA)\r\nreturn -EINVAL;\r\nchip = tpm_chip_find_get(chip_num);\r\nif (chip == NULL)\r\nreturn -ENODEV;\r\nif (chip->flags & TPM_CHIP_FLAG_TPM2) {\r\nerr = tpm2_get_random(chip, out, max);\r\ntpm_chip_put(chip);\r\nreturn err;\r\n}\r\ndo {\r\ntpm_cmd.header.in = tpm_getrandom_header;\r\ntpm_cmd.params.getrandom_in.num_bytes = cpu_to_be32(num_bytes);\r\nerr = tpm_transmit_cmd(chip, &tpm_cmd,\r\nTPM_GETRANDOM_RESULT_SIZE + num_bytes,\r\n"attempting get random");\r\nif (err)\r\nbreak;\r\nrecd = be32_to_cpu(tpm_cmd.params.getrandom_out.rng_data_len);\r\nmemcpy(dest, tpm_cmd.params.getrandom_out.rng_data, recd);\r\ndest += recd;\r\ntotal += recd;\r\nnum_bytes -= recd;\r\n} while (retries-- && total < max);\r\ntpm_chip_put(chip);\r\nreturn total ? total : -EIO;\r\n}\r\nstatic int __init tpm_init(void)\r\n{\r\nint rc;\r\ntpm_class = class_create(THIS_MODULE, "tpm");\r\nif (IS_ERR(tpm_class)) {\r\npr_err("couldn't create tpm class\n");\r\nreturn PTR_ERR(tpm_class);\r\n}\r\nrc = alloc_chrdev_region(&tpm_devt, 0, TPM_NUM_DEVICES, "tpm");\r\nif (rc < 0) {\r\npr_err("tpm: failed to allocate char dev region\n");\r\nclass_destroy(tpm_class);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit tpm_exit(void)\r\n{\r\nclass_destroy(tpm_class);\r\nunregister_chrdev_region(tpm_devt, TPM_NUM_DEVICES);\r\n}
