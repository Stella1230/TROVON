static int adp8870_read(struct i2c_client *client, int reg, uint8_t *val)\r\n{\r\nint ret;\r\nret = i2c_smbus_read_byte_data(client, reg);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "failed reading at 0x%02x\n", reg);\r\nreturn ret;\r\n}\r\n*val = ret;\r\nreturn 0;\r\n}\r\nstatic int adp8870_write(struct i2c_client *client, u8 reg, u8 val)\r\n{\r\nint ret = i2c_smbus_write_byte_data(client, reg, val);\r\nif (ret)\r\ndev_err(&client->dev, "failed to write\n");\r\nreturn ret;\r\n}\r\nstatic int adp8870_set_bits(struct i2c_client *client, int reg, uint8_t bit_mask)\r\n{\r\nstruct adp8870_bl *data = i2c_get_clientdata(client);\r\nuint8_t reg_val;\r\nint ret;\r\nmutex_lock(&data->lock);\r\nret = adp8870_read(client, reg, &reg_val);\r\nif (!ret && ((reg_val & bit_mask) != bit_mask)) {\r\nreg_val |= bit_mask;\r\nret = adp8870_write(client, reg, reg_val);\r\n}\r\nmutex_unlock(&data->lock);\r\nreturn ret;\r\n}\r\nstatic int adp8870_clr_bits(struct i2c_client *client, int reg, uint8_t bit_mask)\r\n{\r\nstruct adp8870_bl *data = i2c_get_clientdata(client);\r\nuint8_t reg_val;\r\nint ret;\r\nmutex_lock(&data->lock);\r\nret = adp8870_read(client, reg, &reg_val);\r\nif (!ret && (reg_val & bit_mask)) {\r\nreg_val &= ~bit_mask;\r\nret = adp8870_write(client, reg, reg_val);\r\n}\r\nmutex_unlock(&data->lock);\r\nreturn ret;\r\n}\r\nstatic void adp8870_led_work(struct work_struct *work)\r\n{\r\nstruct adp8870_led *led = container_of(work, struct adp8870_led, work);\r\nadp8870_write(led->client, ADP8870_ISC1 + led->id - 1,\r\nled->new_brightness >> 1);\r\n}\r\nstatic void adp8870_led_set(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct adp8870_led *led;\r\nled = container_of(led_cdev, struct adp8870_led, cdev);\r\nled->new_brightness = value;\r\nschedule_work(&led->work);\r\n}\r\nstatic int adp8870_led_setup(struct adp8870_led *led)\r\n{\r\nstruct i2c_client *client = led->client;\r\nint ret = 0;\r\nret = adp8870_write(client, ADP8870_ISC1 + led->id - 1, 0);\r\nif (ret)\r\nreturn ret;\r\nret = adp8870_set_bits(client, ADP8870_ISCC, 1 << (led->id - 1));\r\nif (ret)\r\nreturn ret;\r\nif (led->id > 4)\r\nret = adp8870_set_bits(client, ADP8870_ISCT1,\r\n(led->flags & 0x3) << ((led->id - 5) * 2));\r\nelse\r\nret = adp8870_set_bits(client, ADP8870_ISCT2,\r\n(led->flags & 0x3) << ((led->id - 1) * 2));\r\nreturn ret;\r\n}\r\nstatic int adp8870_led_probe(struct i2c_client *client)\r\n{\r\nstruct adp8870_backlight_platform_data *pdata =\r\ndev_get_platdata(&client->dev);\r\nstruct adp8870_bl *data = i2c_get_clientdata(client);\r\nstruct adp8870_led *led, *led_dat;\r\nstruct led_info *cur_led;\r\nint ret, i;\r\nled = devm_kzalloc(&client->dev, pdata->num_leds * sizeof(*led),\r\nGFP_KERNEL);\r\nif (led == NULL)\r\nreturn -ENOMEM;\r\nret = adp8870_write(client, ADP8870_ISCLAW, pdata->led_fade_law);\r\nif (ret)\r\nreturn ret;\r\nret = adp8870_write(client, ADP8870_ISCT1,\r\n(pdata->led_on_time & 0x3) << 6);\r\nif (ret)\r\nreturn ret;\r\nret = adp8870_write(client, ADP8870_ISCF,\r\nFADE_VAL(pdata->led_fade_in, pdata->led_fade_out));\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < pdata->num_leds; ++i) {\r\ncur_led = &pdata->leds[i];\r\nled_dat = &led[i];\r\nled_dat->id = cur_led->flags & ADP8870_FLAG_LED_MASK;\r\nif (led_dat->id > 7 || led_dat->id < 1) {\r\ndev_err(&client->dev, "Invalid LED ID %d\n",\r\nled_dat->id);\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nif (pdata->bl_led_assign & (1 << (led_dat->id - 1))) {\r\ndev_err(&client->dev, "LED %d used by Backlight\n",\r\nled_dat->id);\r\nret = -EBUSY;\r\ngoto err;\r\n}\r\nled_dat->cdev.name = cur_led->name;\r\nled_dat->cdev.default_trigger = cur_led->default_trigger;\r\nled_dat->cdev.brightness_set = adp8870_led_set;\r\nled_dat->cdev.brightness = LED_OFF;\r\nled_dat->flags = cur_led->flags >> FLAG_OFFT_SHIFT;\r\nled_dat->client = client;\r\nled_dat->new_brightness = LED_OFF;\r\nINIT_WORK(&led_dat->work, adp8870_led_work);\r\nret = led_classdev_register(&client->dev, &led_dat->cdev);\r\nif (ret) {\r\ndev_err(&client->dev, "failed to register LED %d\n",\r\nled_dat->id);\r\ngoto err;\r\n}\r\nret = adp8870_led_setup(led_dat);\r\nif (ret) {\r\ndev_err(&client->dev, "failed to write\n");\r\ni++;\r\ngoto err;\r\n}\r\n}\r\ndata->led = led;\r\nreturn 0;\r\nerr:\r\nfor (i = i - 1; i >= 0; --i) {\r\nled_classdev_unregister(&led[i].cdev);\r\ncancel_work_sync(&led[i].work);\r\n}\r\nreturn ret;\r\n}\r\nstatic int adp8870_led_remove(struct i2c_client *client)\r\n{\r\nstruct adp8870_backlight_platform_data *pdata =\r\ndev_get_platdata(&client->dev);\r\nstruct adp8870_bl *data = i2c_get_clientdata(client);\r\nint i;\r\nfor (i = 0; i < pdata->num_leds; i++) {\r\nled_classdev_unregister(&data->led[i].cdev);\r\ncancel_work_sync(&data->led[i].work);\r\n}\r\nreturn 0;\r\n}\r\nstatic int adp8870_led_probe(struct i2c_client *client)\r\n{\r\nreturn 0;\r\n}\r\nstatic int adp8870_led_remove(struct i2c_client *client)\r\n{\r\nreturn 0;\r\n}\r\nstatic int adp8870_bl_set(struct backlight_device *bl, int brightness)\r\n{\r\nstruct adp8870_bl *data = bl_get_data(bl);\r\nstruct i2c_client *client = data->client;\r\nint ret = 0;\r\nif (data->pdata->en_ambl_sens) {\r\nif ((brightness > 0) && (brightness < ADP8870_MAX_BRIGHTNESS)) {\r\nret = adp8870_clr_bits(client, ADP8870_MDCR,\r\nCMP_AUTOEN);\r\nif (ret)\r\nreturn ret;\r\nret = adp8870_write(client, ADP8870_BLMX1, brightness);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\nret = adp8870_write(client, ADP8870_BLMX1,\r\ndata->cached_daylight_max);\r\nif (ret)\r\nreturn ret;\r\nret = adp8870_set_bits(client, ADP8870_MDCR,\r\nCMP_AUTOEN);\r\nif (ret)\r\nreturn ret;\r\n}\r\n} else {\r\nret = adp8870_write(client, ADP8870_BLMX1, brightness);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (data->current_brightness && brightness == 0)\r\nret = adp8870_set_bits(client,\r\nADP8870_MDCR, DIM_EN);\r\nelse if (data->current_brightness == 0 && brightness)\r\nret = adp8870_clr_bits(client,\r\nADP8870_MDCR, DIM_EN);\r\nif (!ret)\r\ndata->current_brightness = brightness;\r\nreturn ret;\r\n}\r\nstatic int adp8870_bl_update_status(struct backlight_device *bl)\r\n{\r\nint brightness = bl->props.brightness;\r\nif (bl->props.power != FB_BLANK_UNBLANK)\r\nbrightness = 0;\r\nif (bl->props.fb_blank != FB_BLANK_UNBLANK)\r\nbrightness = 0;\r\nreturn adp8870_bl_set(bl, brightness);\r\n}\r\nstatic int adp8870_bl_get_brightness(struct backlight_device *bl)\r\n{\r\nstruct adp8870_bl *data = bl_get_data(bl);\r\nreturn data->current_brightness;\r\n}\r\nstatic int adp8870_bl_setup(struct backlight_device *bl)\r\n{\r\nstruct adp8870_bl *data = bl_get_data(bl);\r\nstruct i2c_client *client = data->client;\r\nstruct adp8870_backlight_platform_data *pdata = data->pdata;\r\nint ret = 0;\r\nret = adp8870_write(client, ADP8870_BLSEL, ~pdata->bl_led_assign);\r\nif (ret)\r\nreturn ret;\r\nret = adp8870_write(client, ADP8870_PWMLED, pdata->pwm_assign);\r\nif (ret)\r\nreturn ret;\r\nret = adp8870_write(client, ADP8870_BLMX1, pdata->l1_daylight_max);\r\nif (ret)\r\nreturn ret;\r\nret = adp8870_write(client, ADP8870_BLDM1, pdata->l1_daylight_dim);\r\nif (ret)\r\nreturn ret;\r\nif (pdata->en_ambl_sens) {\r\ndata->cached_daylight_max = pdata->l1_daylight_max;\r\nret = adp8870_write(client, ADP8870_BLMX2,\r\npdata->l2_bright_max);\r\nif (ret)\r\nreturn ret;\r\nret = adp8870_write(client, ADP8870_BLDM2,\r\npdata->l2_bright_dim);\r\nif (ret)\r\nreturn ret;\r\nret = adp8870_write(client, ADP8870_BLMX3,\r\npdata->l3_office_max);\r\nif (ret)\r\nreturn ret;\r\nret = adp8870_write(client, ADP8870_BLDM3,\r\npdata->l3_office_dim);\r\nif (ret)\r\nreturn ret;\r\nret = adp8870_write(client, ADP8870_BLMX4,\r\npdata->l4_indoor_max);\r\nif (ret)\r\nreturn ret;\r\nret = adp8870_write(client, ADP8870_BLDM4,\r\npdata->l4_indor_dim);\r\nif (ret)\r\nreturn ret;\r\nret = adp8870_write(client, ADP8870_BLMX5,\r\npdata->l5_dark_max);\r\nif (ret)\r\nreturn ret;\r\nret = adp8870_write(client, ADP8870_BLDM5,\r\npdata->l5_dark_dim);\r\nif (ret)\r\nreturn ret;\r\nret = adp8870_write(client, ADP8870_L2TRP, pdata->l2_trip);\r\nif (ret)\r\nreturn ret;\r\nret = adp8870_write(client, ADP8870_L2HYS, pdata->l2_hyst);\r\nif (ret)\r\nreturn ret;\r\nret = adp8870_write(client, ADP8870_L3TRP, pdata->l3_trip);\r\nif (ret)\r\nreturn ret;\r\nret = adp8870_write(client, ADP8870_L3HYS, pdata->l3_hyst);\r\nif (ret)\r\nreturn ret;\r\nret = adp8870_write(client, ADP8870_L4TRP, pdata->l4_trip);\r\nif (ret)\r\nreturn ret;\r\nret = adp8870_write(client, ADP8870_L4HYS, pdata->l4_hyst);\r\nif (ret)\r\nreturn ret;\r\nret = adp8870_write(client, ADP8870_L5TRP, pdata->l5_trip);\r\nif (ret)\r\nreturn ret;\r\nret = adp8870_write(client, ADP8870_L5HYS, pdata->l5_hyst);\r\nif (ret)\r\nreturn ret;\r\nret = adp8870_write(client, ADP8870_ALS1_EN, L5_EN | L4_EN |\r\nL3_EN | L2_EN);\r\nif (ret)\r\nreturn ret;\r\nret = adp8870_write(client, ADP8870_CMP_CTL,\r\nALS_CMPR_CFG_VAL(pdata->abml_filt));\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = adp8870_write(client, ADP8870_CFGR,\r\nBL_CFGR_VAL(pdata->bl_fade_law, 0));\r\nif (ret)\r\nreturn ret;\r\nret = adp8870_write(client, ADP8870_BLFR, FADE_VAL(pdata->bl_fade_in,\r\npdata->bl_fade_out));\r\nif (ret)\r\nreturn ret;\r\nret = adp8870_set_bits(client, ADP8870_MDCR, BLEN | DIM_EN | NSTBY |\r\n(data->revid == 0 ? GDWN_DIS : 0));\r\nreturn ret;\r\n}\r\nstatic ssize_t adp8870_show(struct device *dev, char *buf, int reg)\r\n{\r\nstruct adp8870_bl *data = dev_get_drvdata(dev);\r\nint error;\r\nuint8_t reg_val;\r\nmutex_lock(&data->lock);\r\nerror = adp8870_read(data->client, reg, &reg_val);\r\nmutex_unlock(&data->lock);\r\nif (error < 0)\r\nreturn error;\r\nreturn sprintf(buf, "%u\n", reg_val);\r\n}\r\nstatic ssize_t adp8870_store(struct device *dev, const char *buf,\r\nsize_t count, int reg)\r\n{\r\nstruct adp8870_bl *data = dev_get_drvdata(dev);\r\nunsigned long val;\r\nint ret;\r\nret = kstrtoul(buf, 10, &val);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&data->lock);\r\nadp8870_write(data->client, reg, val);\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t adp8870_bl_l5_dark_max_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn adp8870_show(dev, buf, ADP8870_BLMX5);\r\n}\r\nstatic ssize_t adp8870_bl_l5_dark_max_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nreturn adp8870_store(dev, buf, count, ADP8870_BLMX5);\r\n}\r\nstatic ssize_t adp8870_bl_l4_indoor_max_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn adp8870_show(dev, buf, ADP8870_BLMX4);\r\n}\r\nstatic ssize_t adp8870_bl_l4_indoor_max_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nreturn adp8870_store(dev, buf, count, ADP8870_BLMX4);\r\n}\r\nstatic ssize_t adp8870_bl_l3_office_max_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn adp8870_show(dev, buf, ADP8870_BLMX3);\r\n}\r\nstatic ssize_t adp8870_bl_l3_office_max_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nreturn adp8870_store(dev, buf, count, ADP8870_BLMX3);\r\n}\r\nstatic ssize_t adp8870_bl_l2_bright_max_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn adp8870_show(dev, buf, ADP8870_BLMX2);\r\n}\r\nstatic ssize_t adp8870_bl_l2_bright_max_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nreturn adp8870_store(dev, buf, count, ADP8870_BLMX2);\r\n}\r\nstatic ssize_t adp8870_bl_l1_daylight_max_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn adp8870_show(dev, buf, ADP8870_BLMX1);\r\n}\r\nstatic ssize_t adp8870_bl_l1_daylight_max_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct adp8870_bl *data = dev_get_drvdata(dev);\r\nint ret = kstrtoul(buf, 10, &data->cached_daylight_max);\r\nif (ret)\r\nreturn ret;\r\nreturn adp8870_store(dev, buf, count, ADP8870_BLMX1);\r\n}\r\nstatic ssize_t adp8870_bl_l5_dark_dim_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn adp8870_show(dev, buf, ADP8870_BLDM5);\r\n}\r\nstatic ssize_t adp8870_bl_l5_dark_dim_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nreturn adp8870_store(dev, buf, count, ADP8870_BLDM5);\r\n}\r\nstatic ssize_t adp8870_bl_l4_indoor_dim_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn adp8870_show(dev, buf, ADP8870_BLDM4);\r\n}\r\nstatic ssize_t adp8870_bl_l4_indoor_dim_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nreturn adp8870_store(dev, buf, count, ADP8870_BLDM4);\r\n}\r\nstatic ssize_t adp8870_bl_l3_office_dim_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn adp8870_show(dev, buf, ADP8870_BLDM3);\r\n}\r\nstatic ssize_t adp8870_bl_l3_office_dim_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nreturn adp8870_store(dev, buf, count, ADP8870_BLDM3);\r\n}\r\nstatic ssize_t adp8870_bl_l2_bright_dim_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn adp8870_show(dev, buf, ADP8870_BLDM2);\r\n}\r\nstatic ssize_t adp8870_bl_l2_bright_dim_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nreturn adp8870_store(dev, buf, count, ADP8870_BLDM2);\r\n}\r\nstatic ssize_t adp8870_bl_l1_daylight_dim_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn adp8870_show(dev, buf, ADP8870_BLDM1);\r\n}\r\nstatic ssize_t adp8870_bl_l1_daylight_dim_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nreturn adp8870_store(dev, buf, count, ADP8870_BLDM1);\r\n}\r\nstatic ssize_t adp8870_bl_ambient_light_level_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct adp8870_bl *data = dev_get_drvdata(dev);\r\nint error;\r\nuint8_t reg_val;\r\nuint16_t ret_val;\r\nmutex_lock(&data->lock);\r\nerror = adp8870_read(data->client, ADP8870_PH1LEVL, &reg_val);\r\nif (error < 0) {\r\nmutex_unlock(&data->lock);\r\nreturn error;\r\n}\r\nret_val = reg_val;\r\nerror = adp8870_read(data->client, ADP8870_PH1LEVH, &reg_val);\r\nmutex_unlock(&data->lock);\r\nif (error < 0)\r\nreturn error;\r\nret_val += (reg_val & 0x1F) << 8;\r\nreturn sprintf(buf, "%u\n", ret_val);\r\n}\r\nstatic ssize_t adp8870_bl_ambient_light_zone_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct adp8870_bl *data = dev_get_drvdata(dev);\r\nint error;\r\nuint8_t reg_val;\r\nmutex_lock(&data->lock);\r\nerror = adp8870_read(data->client, ADP8870_CFGR, &reg_val);\r\nmutex_unlock(&data->lock);\r\nif (error < 0)\r\nreturn error;\r\nreturn sprintf(buf, "%u\n",\r\n((reg_val >> CFGR_BLV_SHIFT) & CFGR_BLV_MASK) + 1);\r\n}\r\nstatic ssize_t adp8870_bl_ambient_light_zone_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct adp8870_bl *data = dev_get_drvdata(dev);\r\nunsigned long val;\r\nuint8_t reg_val;\r\nint ret;\r\nret = kstrtoul(buf, 10, &val);\r\nif (ret)\r\nreturn ret;\r\nif (val == 0) {\r\nadp8870_set_bits(data->client, ADP8870_MDCR, CMP_AUTOEN);\r\n} else if ((val > 0) && (val < 6)) {\r\nadp8870_clr_bits(data->client, ADP8870_MDCR, CMP_AUTOEN);\r\nmutex_lock(&data->lock);\r\nadp8870_read(data->client, ADP8870_CFGR, &reg_val);\r\nreg_val &= ~(CFGR_BLV_MASK << CFGR_BLV_SHIFT);\r\nreg_val |= (val - 1) << CFGR_BLV_SHIFT;\r\nadp8870_write(data->client, ADP8870_CFGR, reg_val);\r\nmutex_unlock(&data->lock);\r\n}\r\nreturn count;\r\n}\r\nstatic int adp8870_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct backlight_properties props;\r\nstruct backlight_device *bl;\r\nstruct adp8870_bl *data;\r\nstruct adp8870_backlight_platform_data *pdata =\r\ndev_get_platdata(&client->dev);\r\nuint8_t reg_val;\r\nint ret;\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_BYTE_DATA)) {\r\ndev_err(&client->dev, "SMBUS Byte Data not Supported\n");\r\nreturn -EIO;\r\n}\r\nif (!pdata) {\r\ndev_err(&client->dev, "no platform data?\n");\r\nreturn -EINVAL;\r\n}\r\nret = adp8870_read(client, ADP8870_MFDVID, &reg_val);\r\nif (ret < 0)\r\nreturn -EIO;\r\nif (ADP8870_MANID(reg_val) != ADP8870_MANUFID) {\r\ndev_err(&client->dev, "failed to probe\n");\r\nreturn -ENODEV;\r\n}\r\ndata = devm_kzalloc(&client->dev, sizeof(*data), GFP_KERNEL);\r\nif (data == NULL)\r\nreturn -ENOMEM;\r\ndata->revid = ADP8870_DEVID(reg_val);\r\ndata->client = client;\r\ndata->pdata = pdata;\r\ndata->id = id->driver_data;\r\ndata->current_brightness = 0;\r\ni2c_set_clientdata(client, data);\r\nmutex_init(&data->lock);\r\nmemset(&props, 0, sizeof(props));\r\nprops.type = BACKLIGHT_RAW;\r\nprops.max_brightness = props.brightness = ADP8870_MAX_BRIGHTNESS;\r\nbl = devm_backlight_device_register(&client->dev,\r\ndev_driver_string(&client->dev),\r\n&client->dev, data, &adp8870_bl_ops, &props);\r\nif (IS_ERR(bl)) {\r\ndev_err(&client->dev, "failed to register backlight\n");\r\nreturn PTR_ERR(bl);\r\n}\r\ndata->bl = bl;\r\nif (pdata->en_ambl_sens) {\r\nret = sysfs_create_group(&bl->dev.kobj,\r\n&adp8870_bl_attr_group);\r\nif (ret) {\r\ndev_err(&client->dev, "failed to register sysfs\n");\r\nreturn ret;\r\n}\r\n}\r\nret = adp8870_bl_setup(bl);\r\nif (ret) {\r\nret = -EIO;\r\ngoto out;\r\n}\r\nbacklight_update_status(bl);\r\ndev_info(&client->dev, "Rev.%d Backlight\n", data->revid);\r\nif (pdata->num_leds)\r\nadp8870_led_probe(client);\r\nreturn 0;\r\nout:\r\nif (data->pdata->en_ambl_sens)\r\nsysfs_remove_group(&data->bl->dev.kobj,\r\n&adp8870_bl_attr_group);\r\nreturn ret;\r\n}\r\nstatic int adp8870_remove(struct i2c_client *client)\r\n{\r\nstruct adp8870_bl *data = i2c_get_clientdata(client);\r\nadp8870_clr_bits(client, ADP8870_MDCR, NSTBY);\r\nif (data->led)\r\nadp8870_led_remove(client);\r\nif (data->pdata->en_ambl_sens)\r\nsysfs_remove_group(&data->bl->dev.kobj,\r\n&adp8870_bl_attr_group);\r\nreturn 0;\r\n}\r\nstatic int adp8870_i2c_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nadp8870_clr_bits(client, ADP8870_MDCR, NSTBY);\r\nreturn 0;\r\n}\r\nstatic int adp8870_i2c_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nadp8870_set_bits(client, ADP8870_MDCR, NSTBY | BLEN);\r\nreturn 0;\r\n}
