static inline struct gss_cl_ctx *\r\ngss_get_ctx(struct gss_cl_ctx *ctx)\r\n{\r\natomic_inc(&ctx->count);\r\nreturn ctx;\r\n}\r\nstatic inline void\r\ngss_put_ctx(struct gss_cl_ctx *ctx)\r\n{\r\nif (atomic_dec_and_test(&ctx->count))\r\ngss_free_ctx(ctx);\r\n}\r\nstatic void\r\ngss_cred_set_ctx(struct rpc_cred *cred, struct gss_cl_ctx *ctx)\r\n{\r\nstruct gss_cred *gss_cred = container_of(cred, struct gss_cred, gc_base);\r\nif (!test_bit(RPCAUTH_CRED_NEW, &cred->cr_flags))\r\nreturn;\r\ngss_get_ctx(ctx);\r\nrcu_assign_pointer(gss_cred->gc_ctx, ctx);\r\nset_bit(RPCAUTH_CRED_UPTODATE, &cred->cr_flags);\r\nsmp_mb__before_atomic();\r\nclear_bit(RPCAUTH_CRED_NEW, &cred->cr_flags);\r\n}\r\nstatic const void *\r\nsimple_get_bytes(const void *p, const void *end, void *res, size_t len)\r\n{\r\nconst void *q = (const void *)((const char *)p + len);\r\nif (unlikely(q > end || q < p))\r\nreturn ERR_PTR(-EFAULT);\r\nmemcpy(res, p, len);\r\nreturn q;\r\n}\r\nstatic inline const void *\r\nsimple_get_netobj(const void *p, const void *end, struct xdr_netobj *dest)\r\n{\r\nconst void *q;\r\nunsigned int len;\r\np = simple_get_bytes(p, end, &len, sizeof(len));\r\nif (IS_ERR(p))\r\nreturn p;\r\nq = (const void *)((const char *)p + len);\r\nif (unlikely(q > end || q < p))\r\nreturn ERR_PTR(-EFAULT);\r\ndest->data = kmemdup(p, len, GFP_NOFS);\r\nif (unlikely(dest->data == NULL))\r\nreturn ERR_PTR(-ENOMEM);\r\ndest->len = len;\r\nreturn q;\r\n}\r\nstatic struct gss_cl_ctx *\r\ngss_cred_get_ctx(struct rpc_cred *cred)\r\n{\r\nstruct gss_cred *gss_cred = container_of(cred, struct gss_cred, gc_base);\r\nstruct gss_cl_ctx *ctx = NULL;\r\nrcu_read_lock();\r\nctx = rcu_dereference(gss_cred->gc_ctx);\r\nif (ctx)\r\ngss_get_ctx(ctx);\r\nrcu_read_unlock();\r\nreturn ctx;\r\n}\r\nstatic struct gss_cl_ctx *\r\ngss_alloc_context(void)\r\n{\r\nstruct gss_cl_ctx *ctx;\r\nctx = kzalloc(sizeof(*ctx), GFP_NOFS);\r\nif (ctx != NULL) {\r\nctx->gc_proc = RPC_GSS_PROC_DATA;\r\nctx->gc_seq = 1;\r\nspin_lock_init(&ctx->gc_seq_lock);\r\natomic_set(&ctx->count,1);\r\n}\r\nreturn ctx;\r\n}\r\nstatic const void *\r\ngss_fill_context(const void *p, const void *end, struct gss_cl_ctx *ctx, struct gss_api_mech *gm)\r\n{\r\nconst void *q;\r\nunsigned int seclen;\r\nunsigned int timeout;\r\nunsigned long now = jiffies;\r\nu32 window_size;\r\nint ret;\r\np = simple_get_bytes(p, end, &timeout, sizeof(timeout));\r\nif (IS_ERR(p))\r\ngoto err;\r\nif (timeout == 0)\r\ntimeout = GSSD_MIN_TIMEOUT;\r\nctx->gc_expiry = now + ((unsigned long)timeout * HZ);\r\np = simple_get_bytes(p, end, &window_size, sizeof(window_size));\r\nif (IS_ERR(p))\r\ngoto err;\r\nctx->gc_win = window_size;\r\nif (ctx->gc_win == 0) {\r\np = simple_get_bytes(p, end, &ret, sizeof(ret));\r\nif (!IS_ERR(p))\r\np = (ret == -EKEYEXPIRED) ? ERR_PTR(-EKEYEXPIRED) :\r\nERR_PTR(-EACCES);\r\ngoto err;\r\n}\r\np = simple_get_netobj(p, end, &ctx->gc_wire_ctx);\r\nif (IS_ERR(p))\r\ngoto err;\r\np = simple_get_bytes(p, end, &seclen, sizeof(seclen));\r\nif (IS_ERR(p))\r\ngoto err;\r\nq = (const void *)((const char *)p + seclen);\r\nif (unlikely(q > end || q < p)) {\r\np = ERR_PTR(-EFAULT);\r\ngoto err;\r\n}\r\nret = gss_import_sec_context(p, seclen, gm, &ctx->gc_gss_ctx, NULL, GFP_NOFS);\r\nif (ret < 0) {\r\np = ERR_PTR(ret);\r\ngoto err;\r\n}\r\nif (q == end) {\r\np = q;\r\ngoto done;\r\n}\r\np = simple_get_netobj(q, end, &ctx->gc_acceptor);\r\nif (IS_ERR(p))\r\ngoto err;\r\ndone:\r\ndprintk("RPC: %s Success. gc_expiry %lu now %lu timeout %u acceptor %.*s\n",\r\n__func__, ctx->gc_expiry, now, timeout, ctx->gc_acceptor.len,\r\nctx->gc_acceptor.data);\r\nreturn p;\r\nerr:\r\ndprintk("RPC: %s returns error %ld\n", __func__, -PTR_ERR(p));\r\nreturn p;\r\n}\r\nstatic int get_pipe_version(struct net *net)\r\n{\r\nstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\r\nint ret;\r\nspin_lock(&pipe_version_lock);\r\nif (sn->pipe_version >= 0) {\r\natomic_inc(&sn->pipe_users);\r\nret = sn->pipe_version;\r\n} else\r\nret = -EAGAIN;\r\nspin_unlock(&pipe_version_lock);\r\nreturn ret;\r\n}\r\nstatic void put_pipe_version(struct net *net)\r\n{\r\nstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\r\nif (atomic_dec_and_lock(&sn->pipe_users, &pipe_version_lock)) {\r\nsn->pipe_version = -1;\r\nspin_unlock(&pipe_version_lock);\r\n}\r\n}\r\nstatic void\r\ngss_release_msg(struct gss_upcall_msg *gss_msg)\r\n{\r\nstruct net *net = gss_msg->auth->net;\r\nif (!atomic_dec_and_test(&gss_msg->count))\r\nreturn;\r\nput_pipe_version(net);\r\nBUG_ON(!list_empty(&gss_msg->list));\r\nif (gss_msg->ctx != NULL)\r\ngss_put_ctx(gss_msg->ctx);\r\nrpc_destroy_wait_queue(&gss_msg->rpc_waitqueue);\r\ngss_put_auth(gss_msg->auth);\r\nkfree(gss_msg);\r\n}\r\nstatic struct gss_upcall_msg *\r\n__gss_find_upcall(struct rpc_pipe *pipe, kuid_t uid)\r\n{\r\nstruct gss_upcall_msg *pos;\r\nlist_for_each_entry(pos, &pipe->in_downcall, list) {\r\nif (!uid_eq(pos->uid, uid))\r\ncontinue;\r\natomic_inc(&pos->count);\r\ndprintk("RPC: %s found msg %p\n", __func__, pos);\r\nreturn pos;\r\n}\r\ndprintk("RPC: %s found nothing\n", __func__);\r\nreturn NULL;\r\n}\r\nstatic inline struct gss_upcall_msg *\r\ngss_add_msg(struct gss_upcall_msg *gss_msg)\r\n{\r\nstruct rpc_pipe *pipe = gss_msg->pipe;\r\nstruct gss_upcall_msg *old;\r\nspin_lock(&pipe->lock);\r\nold = __gss_find_upcall(pipe, gss_msg->uid);\r\nif (old == NULL) {\r\natomic_inc(&gss_msg->count);\r\nlist_add(&gss_msg->list, &pipe->in_downcall);\r\n} else\r\ngss_msg = old;\r\nspin_unlock(&pipe->lock);\r\nreturn gss_msg;\r\n}\r\nstatic void\r\n__gss_unhash_msg(struct gss_upcall_msg *gss_msg)\r\n{\r\nlist_del_init(&gss_msg->list);\r\nrpc_wake_up_status(&gss_msg->rpc_waitqueue, gss_msg->msg.errno);\r\nwake_up_all(&gss_msg->waitqueue);\r\natomic_dec(&gss_msg->count);\r\n}\r\nstatic void\r\ngss_unhash_msg(struct gss_upcall_msg *gss_msg)\r\n{\r\nstruct rpc_pipe *pipe = gss_msg->pipe;\r\nif (list_empty(&gss_msg->list))\r\nreturn;\r\nspin_lock(&pipe->lock);\r\nif (!list_empty(&gss_msg->list))\r\n__gss_unhash_msg(gss_msg);\r\nspin_unlock(&pipe->lock);\r\n}\r\nstatic void\r\ngss_handle_downcall_result(struct gss_cred *gss_cred, struct gss_upcall_msg *gss_msg)\r\n{\r\nswitch (gss_msg->msg.errno) {\r\ncase 0:\r\nif (gss_msg->ctx == NULL)\r\nbreak;\r\nclear_bit(RPCAUTH_CRED_NEGATIVE, &gss_cred->gc_base.cr_flags);\r\ngss_cred_set_ctx(&gss_cred->gc_base, gss_msg->ctx);\r\nbreak;\r\ncase -EKEYEXPIRED:\r\nset_bit(RPCAUTH_CRED_NEGATIVE, &gss_cred->gc_base.cr_flags);\r\n}\r\ngss_cred->gc_upcall_timestamp = jiffies;\r\ngss_cred->gc_upcall = NULL;\r\nrpc_wake_up_status(&gss_msg->rpc_waitqueue, gss_msg->msg.errno);\r\n}\r\nstatic void\r\ngss_upcall_callback(struct rpc_task *task)\r\n{\r\nstruct gss_cred *gss_cred = container_of(task->tk_rqstp->rq_cred,\r\nstruct gss_cred, gc_base);\r\nstruct gss_upcall_msg *gss_msg = gss_cred->gc_upcall;\r\nstruct rpc_pipe *pipe = gss_msg->pipe;\r\nspin_lock(&pipe->lock);\r\ngss_handle_downcall_result(gss_cred, gss_msg);\r\nspin_unlock(&pipe->lock);\r\ntask->tk_status = gss_msg->msg.errno;\r\ngss_release_msg(gss_msg);\r\n}\r\nstatic void gss_encode_v0_msg(struct gss_upcall_msg *gss_msg)\r\n{\r\nuid_t uid = from_kuid(&init_user_ns, gss_msg->uid);\r\nmemcpy(gss_msg->databuf, &uid, sizeof(uid));\r\ngss_msg->msg.data = gss_msg->databuf;\r\ngss_msg->msg.len = sizeof(uid);\r\nBUILD_BUG_ON(sizeof(uid) > sizeof(gss_msg->databuf));\r\n}\r\nstatic int gss_encode_v1_msg(struct gss_upcall_msg *gss_msg,\r\nconst char *service_name,\r\nconst char *target_name)\r\n{\r\nstruct gss_api_mech *mech = gss_msg->auth->mech;\r\nchar *p = gss_msg->databuf;\r\nsize_t buflen = sizeof(gss_msg->databuf);\r\nint len;\r\nlen = scnprintf(p, buflen, "mech=%s uid=%d ", mech->gm_name,\r\nfrom_kuid(&init_user_ns, gss_msg->uid));\r\nbuflen -= len;\r\np += len;\r\ngss_msg->msg.len = len;\r\nif (target_name) {\r\nlen = scnprintf(p, buflen, "target=%s ", target_name);\r\nbuflen -= len;\r\np += len;\r\ngss_msg->msg.len += len;\r\n}\r\nif (service_name != NULL) {\r\nlen = scnprintf(p, buflen, "service=%s ", service_name);\r\nbuflen -= len;\r\np += len;\r\ngss_msg->msg.len += len;\r\n}\r\nif (mech->gm_upcall_enctypes) {\r\nlen = scnprintf(p, buflen, "enctypes=%s ",\r\nmech->gm_upcall_enctypes);\r\nbuflen -= len;\r\np += len;\r\ngss_msg->msg.len += len;\r\n}\r\nlen = scnprintf(p, buflen, "\n");\r\nif (len == 0)\r\ngoto out_overflow;\r\ngss_msg->msg.len += len;\r\ngss_msg->msg.data = gss_msg->databuf;\r\nreturn 0;\r\nout_overflow:\r\nWARN_ON_ONCE(1);\r\nreturn -ENOMEM;\r\n}\r\nstatic struct gss_upcall_msg *\r\ngss_alloc_msg(struct gss_auth *gss_auth,\r\nkuid_t uid, const char *service_name)\r\n{\r\nstruct gss_upcall_msg *gss_msg;\r\nint vers;\r\nint err = -ENOMEM;\r\ngss_msg = kzalloc(sizeof(*gss_msg), GFP_NOFS);\r\nif (gss_msg == NULL)\r\ngoto err;\r\nvers = get_pipe_version(gss_auth->net);\r\nerr = vers;\r\nif (err < 0)\r\ngoto err_free_msg;\r\ngss_msg->pipe = gss_auth->gss_pipe[vers]->pipe;\r\nINIT_LIST_HEAD(&gss_msg->list);\r\nrpc_init_wait_queue(&gss_msg->rpc_waitqueue, "RPCSEC_GSS upcall waitq");\r\ninit_waitqueue_head(&gss_msg->waitqueue);\r\natomic_set(&gss_msg->count, 1);\r\ngss_msg->uid = uid;\r\ngss_msg->auth = gss_auth;\r\nswitch (vers) {\r\ncase 0:\r\ngss_encode_v0_msg(gss_msg);\r\nbreak;\r\ndefault:\r\nerr = gss_encode_v1_msg(gss_msg, service_name, gss_auth->target_name);\r\nif (err)\r\ngoto err_put_pipe_version;\r\n};\r\nkref_get(&gss_auth->kref);\r\nreturn gss_msg;\r\nerr_put_pipe_version:\r\nput_pipe_version(gss_auth->net);\r\nerr_free_msg:\r\nkfree(gss_msg);\r\nerr:\r\nreturn ERR_PTR(err);\r\n}\r\nstatic struct gss_upcall_msg *\r\ngss_setup_upcall(struct gss_auth *gss_auth, struct rpc_cred *cred)\r\n{\r\nstruct gss_cred *gss_cred = container_of(cred,\r\nstruct gss_cred, gc_base);\r\nstruct gss_upcall_msg *gss_new, *gss_msg;\r\nkuid_t uid = cred->cr_uid;\r\ngss_new = gss_alloc_msg(gss_auth, uid, gss_cred->gc_principal);\r\nif (IS_ERR(gss_new))\r\nreturn gss_new;\r\ngss_msg = gss_add_msg(gss_new);\r\nif (gss_msg == gss_new) {\r\nint res = rpc_queue_upcall(gss_new->pipe, &gss_new->msg);\r\nif (res) {\r\ngss_unhash_msg(gss_new);\r\ngss_msg = ERR_PTR(res);\r\n}\r\n} else\r\ngss_release_msg(gss_new);\r\nreturn gss_msg;\r\n}\r\nstatic void warn_gssd(void)\r\n{\r\ndprintk("AUTH_GSS upcall failed. Please check user daemon is running.\n");\r\n}\r\nstatic inline int\r\ngss_refresh_upcall(struct rpc_task *task)\r\n{\r\nstruct rpc_cred *cred = task->tk_rqstp->rq_cred;\r\nstruct gss_auth *gss_auth = container_of(cred->cr_auth,\r\nstruct gss_auth, rpc_auth);\r\nstruct gss_cred *gss_cred = container_of(cred,\r\nstruct gss_cred, gc_base);\r\nstruct gss_upcall_msg *gss_msg;\r\nstruct rpc_pipe *pipe;\r\nint err = 0;\r\ndprintk("RPC: %5u %s for uid %u\n",\r\ntask->tk_pid, __func__, from_kuid(&init_user_ns, cred->cr_uid));\r\ngss_msg = gss_setup_upcall(gss_auth, cred);\r\nif (PTR_ERR(gss_msg) == -EAGAIN) {\r\nwarn_gssd();\r\ntask->tk_timeout = 15*HZ;\r\nrpc_sleep_on(&pipe_version_rpc_waitqueue, task, NULL);\r\nreturn -EAGAIN;\r\n}\r\nif (IS_ERR(gss_msg)) {\r\nerr = PTR_ERR(gss_msg);\r\ngoto out;\r\n}\r\npipe = gss_msg->pipe;\r\nspin_lock(&pipe->lock);\r\nif (gss_cred->gc_upcall != NULL)\r\nrpc_sleep_on(&gss_cred->gc_upcall->rpc_waitqueue, task, NULL);\r\nelse if (gss_msg->ctx == NULL && gss_msg->msg.errno >= 0) {\r\ntask->tk_timeout = 0;\r\ngss_cred->gc_upcall = gss_msg;\r\natomic_inc(&gss_msg->count);\r\nrpc_sleep_on(&gss_msg->rpc_waitqueue, task, gss_upcall_callback);\r\n} else {\r\ngss_handle_downcall_result(gss_cred, gss_msg);\r\nerr = gss_msg->msg.errno;\r\n}\r\nspin_unlock(&pipe->lock);\r\ngss_release_msg(gss_msg);\r\nout:\r\ndprintk("RPC: %5u %s for uid %u result %d\n",\r\ntask->tk_pid, __func__,\r\nfrom_kuid(&init_user_ns, cred->cr_uid), err);\r\nreturn err;\r\n}\r\nstatic inline int\r\ngss_create_upcall(struct gss_auth *gss_auth, struct gss_cred *gss_cred)\r\n{\r\nstruct net *net = gss_auth->net;\r\nstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\r\nstruct rpc_pipe *pipe;\r\nstruct rpc_cred *cred = &gss_cred->gc_base;\r\nstruct gss_upcall_msg *gss_msg;\r\nDEFINE_WAIT(wait);\r\nint err;\r\ndprintk("RPC: %s for uid %u\n",\r\n__func__, from_kuid(&init_user_ns, cred->cr_uid));\r\nretry:\r\nerr = 0;\r\nif (!gssd_running(net)) {\r\nwarn_gssd();\r\nreturn -EACCES;\r\n}\r\ngss_msg = gss_setup_upcall(gss_auth, cred);\r\nif (PTR_ERR(gss_msg) == -EAGAIN) {\r\nerr = wait_event_interruptible_timeout(pipe_version_waitqueue,\r\nsn->pipe_version >= 0, 15 * HZ);\r\nif (sn->pipe_version < 0) {\r\nwarn_gssd();\r\nerr = -EACCES;\r\n}\r\nif (err < 0)\r\ngoto out;\r\ngoto retry;\r\n}\r\nif (IS_ERR(gss_msg)) {\r\nerr = PTR_ERR(gss_msg);\r\ngoto out;\r\n}\r\npipe = gss_msg->pipe;\r\nfor (;;) {\r\nprepare_to_wait(&gss_msg->waitqueue, &wait, TASK_KILLABLE);\r\nspin_lock(&pipe->lock);\r\nif (gss_msg->ctx != NULL || gss_msg->msg.errno < 0) {\r\nbreak;\r\n}\r\nspin_unlock(&pipe->lock);\r\nif (fatal_signal_pending(current)) {\r\nerr = -ERESTARTSYS;\r\ngoto out_intr;\r\n}\r\nschedule();\r\n}\r\nif (gss_msg->ctx)\r\ngss_cred_set_ctx(cred, gss_msg->ctx);\r\nelse\r\nerr = gss_msg->msg.errno;\r\nspin_unlock(&pipe->lock);\r\nout_intr:\r\nfinish_wait(&gss_msg->waitqueue, &wait);\r\ngss_release_msg(gss_msg);\r\nout:\r\ndprintk("RPC: %s for uid %u result %d\n",\r\n__func__, from_kuid(&init_user_ns, cred->cr_uid), err);\r\nreturn err;\r\n}\r\nstatic ssize_t\r\ngss_pipe_downcall(struct file *filp, const char __user *src, size_t mlen)\r\n{\r\nconst void *p, *end;\r\nvoid *buf;\r\nstruct gss_upcall_msg *gss_msg;\r\nstruct rpc_pipe *pipe = RPC_I(file_inode(filp))->pipe;\r\nstruct gss_cl_ctx *ctx;\r\nuid_t id;\r\nkuid_t uid;\r\nssize_t err = -EFBIG;\r\nif (mlen > MSG_BUF_MAXSIZE)\r\ngoto out;\r\nerr = -ENOMEM;\r\nbuf = kmalloc(mlen, GFP_NOFS);\r\nif (!buf)\r\ngoto out;\r\nerr = -EFAULT;\r\nif (copy_from_user(buf, src, mlen))\r\ngoto err;\r\nend = (const void *)((char *)buf + mlen);\r\np = simple_get_bytes(buf, end, &id, sizeof(id));\r\nif (IS_ERR(p)) {\r\nerr = PTR_ERR(p);\r\ngoto err;\r\n}\r\nuid = make_kuid(&init_user_ns, id);\r\nif (!uid_valid(uid)) {\r\nerr = -EINVAL;\r\ngoto err;\r\n}\r\nerr = -ENOMEM;\r\nctx = gss_alloc_context();\r\nif (ctx == NULL)\r\ngoto err;\r\nerr = -ENOENT;\r\nspin_lock(&pipe->lock);\r\ngss_msg = __gss_find_upcall(pipe, uid);\r\nif (gss_msg == NULL) {\r\nspin_unlock(&pipe->lock);\r\ngoto err_put_ctx;\r\n}\r\nlist_del_init(&gss_msg->list);\r\nspin_unlock(&pipe->lock);\r\np = gss_fill_context(p, end, ctx, gss_msg->auth->mech);\r\nif (IS_ERR(p)) {\r\nerr = PTR_ERR(p);\r\nswitch (err) {\r\ncase -EACCES:\r\ncase -EKEYEXPIRED:\r\ngss_msg->msg.errno = err;\r\nerr = mlen;\r\nbreak;\r\ncase -EFAULT:\r\ncase -ENOMEM:\r\ncase -EINVAL:\r\ncase -ENOSYS:\r\ngss_msg->msg.errno = -EAGAIN;\r\nbreak;\r\ndefault:\r\nprintk(KERN_CRIT "%s: bad return from "\r\n"gss_fill_context: %zd\n", __func__, err);\r\nBUG();\r\n}\r\ngoto err_release_msg;\r\n}\r\ngss_msg->ctx = gss_get_ctx(ctx);\r\nerr = mlen;\r\nerr_release_msg:\r\nspin_lock(&pipe->lock);\r\n__gss_unhash_msg(gss_msg);\r\nspin_unlock(&pipe->lock);\r\ngss_release_msg(gss_msg);\r\nerr_put_ctx:\r\ngss_put_ctx(ctx);\r\nerr:\r\nkfree(buf);\r\nout:\r\ndprintk("RPC: %s returning %Zd\n", __func__, err);\r\nreturn err;\r\n}\r\nstatic int gss_pipe_open(struct inode *inode, int new_version)\r\n{\r\nstruct net *net = inode->i_sb->s_fs_info;\r\nstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\r\nint ret = 0;\r\nspin_lock(&pipe_version_lock);\r\nif (sn->pipe_version < 0) {\r\nsn->pipe_version = new_version;\r\nrpc_wake_up(&pipe_version_rpc_waitqueue);\r\nwake_up(&pipe_version_waitqueue);\r\n} else if (sn->pipe_version != new_version) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\natomic_inc(&sn->pipe_users);\r\nout:\r\nspin_unlock(&pipe_version_lock);\r\nreturn ret;\r\n}\r\nstatic int gss_pipe_open_v0(struct inode *inode)\r\n{\r\nreturn gss_pipe_open(inode, 0);\r\n}\r\nstatic int gss_pipe_open_v1(struct inode *inode)\r\n{\r\nreturn gss_pipe_open(inode, 1);\r\n}\r\nstatic void\r\ngss_pipe_release(struct inode *inode)\r\n{\r\nstruct net *net = inode->i_sb->s_fs_info;\r\nstruct rpc_pipe *pipe = RPC_I(inode)->pipe;\r\nstruct gss_upcall_msg *gss_msg;\r\nrestart:\r\nspin_lock(&pipe->lock);\r\nlist_for_each_entry(gss_msg, &pipe->in_downcall, list) {\r\nif (!list_empty(&gss_msg->msg.list))\r\ncontinue;\r\ngss_msg->msg.errno = -EPIPE;\r\natomic_inc(&gss_msg->count);\r\n__gss_unhash_msg(gss_msg);\r\nspin_unlock(&pipe->lock);\r\ngss_release_msg(gss_msg);\r\ngoto restart;\r\n}\r\nspin_unlock(&pipe->lock);\r\nput_pipe_version(net);\r\n}\r\nstatic void\r\ngss_pipe_destroy_msg(struct rpc_pipe_msg *msg)\r\n{\r\nstruct gss_upcall_msg *gss_msg = container_of(msg, struct gss_upcall_msg, msg);\r\nif (msg->errno < 0) {\r\ndprintk("RPC: %s releasing msg %p\n",\r\n__func__, gss_msg);\r\natomic_inc(&gss_msg->count);\r\ngss_unhash_msg(gss_msg);\r\nif (msg->errno == -ETIMEDOUT)\r\nwarn_gssd();\r\ngss_release_msg(gss_msg);\r\n}\r\n}\r\nstatic void gss_pipe_dentry_destroy(struct dentry *dir,\r\nstruct rpc_pipe_dir_object *pdo)\r\n{\r\nstruct gss_pipe *gss_pipe = pdo->pdo_data;\r\nstruct rpc_pipe *pipe = gss_pipe->pipe;\r\nif (pipe->dentry != NULL) {\r\nrpc_unlink(pipe->dentry);\r\npipe->dentry = NULL;\r\n}\r\n}\r\nstatic int gss_pipe_dentry_create(struct dentry *dir,\r\nstruct rpc_pipe_dir_object *pdo)\r\n{\r\nstruct gss_pipe *p = pdo->pdo_data;\r\nstruct dentry *dentry;\r\ndentry = rpc_mkpipe_dentry(dir, p->name, p->clnt, p->pipe);\r\nif (IS_ERR(dentry))\r\nreturn PTR_ERR(dentry);\r\np->pipe->dentry = dentry;\r\nreturn 0;\r\n}\r\nstatic struct gss_pipe *gss_pipe_alloc(struct rpc_clnt *clnt,\r\nconst char *name,\r\nconst struct rpc_pipe_ops *upcall_ops)\r\n{\r\nstruct gss_pipe *p;\r\nint err = -ENOMEM;\r\np = kmalloc(sizeof(*p), GFP_KERNEL);\r\nif (p == NULL)\r\ngoto err;\r\np->pipe = rpc_mkpipe_data(upcall_ops, RPC_PIPE_WAIT_FOR_OPEN);\r\nif (IS_ERR(p->pipe)) {\r\nerr = PTR_ERR(p->pipe);\r\ngoto err_free_gss_pipe;\r\n}\r\np->name = name;\r\np->clnt = clnt;\r\nkref_init(&p->kref);\r\nrpc_init_pipe_dir_object(&p->pdo,\r\n&gss_pipe_dir_object_ops,\r\np);\r\nreturn p;\r\nerr_free_gss_pipe:\r\nkfree(p);\r\nerr:\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int gss_pipe_match_pdo(struct rpc_pipe_dir_object *pdo, void *data)\r\n{\r\nstruct gss_pipe *gss_pipe;\r\nstruct gss_alloc_pdo *args = data;\r\nif (pdo->pdo_ops != &gss_pipe_dir_object_ops)\r\nreturn 0;\r\ngss_pipe = container_of(pdo, struct gss_pipe, pdo);\r\nif (strcmp(gss_pipe->name, args->name) != 0)\r\nreturn 0;\r\nif (!kref_get_unless_zero(&gss_pipe->kref))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic struct rpc_pipe_dir_object *gss_pipe_alloc_pdo(void *data)\r\n{\r\nstruct gss_pipe *gss_pipe;\r\nstruct gss_alloc_pdo *args = data;\r\ngss_pipe = gss_pipe_alloc(args->clnt, args->name, args->upcall_ops);\r\nif (!IS_ERR(gss_pipe))\r\nreturn &gss_pipe->pdo;\r\nreturn NULL;\r\n}\r\nstatic struct gss_pipe *gss_pipe_get(struct rpc_clnt *clnt,\r\nconst char *name,\r\nconst struct rpc_pipe_ops *upcall_ops)\r\n{\r\nstruct net *net = rpc_net_ns(clnt);\r\nstruct rpc_pipe_dir_object *pdo;\r\nstruct gss_alloc_pdo args = {\r\n.clnt = clnt,\r\n.name = name,\r\n.upcall_ops = upcall_ops,\r\n};\r\npdo = rpc_find_or_alloc_pipe_dir_object(net,\r\n&clnt->cl_pipedir_objects,\r\ngss_pipe_match_pdo,\r\ngss_pipe_alloc_pdo,\r\n&args);\r\nif (pdo != NULL)\r\nreturn container_of(pdo, struct gss_pipe, pdo);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nstatic void __gss_pipe_free(struct gss_pipe *p)\r\n{\r\nstruct rpc_clnt *clnt = p->clnt;\r\nstruct net *net = rpc_net_ns(clnt);\r\nrpc_remove_pipe_dir_object(net,\r\n&clnt->cl_pipedir_objects,\r\n&p->pdo);\r\nrpc_destroy_pipe_data(p->pipe);\r\nkfree(p);\r\n}\r\nstatic void __gss_pipe_release(struct kref *kref)\r\n{\r\nstruct gss_pipe *p = container_of(kref, struct gss_pipe, kref);\r\n__gss_pipe_free(p);\r\n}\r\nstatic void gss_pipe_free(struct gss_pipe *p)\r\n{\r\nif (p != NULL)\r\nkref_put(&p->kref, __gss_pipe_release);\r\n}\r\nstatic struct gss_auth *\r\ngss_create_new(struct rpc_auth_create_args *args, struct rpc_clnt *clnt)\r\n{\r\nrpc_authflavor_t flavor = args->pseudoflavor;\r\nstruct gss_auth *gss_auth;\r\nstruct gss_pipe *gss_pipe;\r\nstruct rpc_auth * auth;\r\nint err = -ENOMEM;\r\ndprintk("RPC: creating GSS authenticator for client %p\n", clnt);\r\nif (!try_module_get(THIS_MODULE))\r\nreturn ERR_PTR(err);\r\nif (!(gss_auth = kmalloc(sizeof(*gss_auth), GFP_KERNEL)))\r\ngoto out_dec;\r\nINIT_HLIST_NODE(&gss_auth->hash);\r\ngss_auth->target_name = NULL;\r\nif (args->target_name) {\r\ngss_auth->target_name = kstrdup(args->target_name, GFP_KERNEL);\r\nif (gss_auth->target_name == NULL)\r\ngoto err_free;\r\n}\r\ngss_auth->client = clnt;\r\ngss_auth->net = get_net(rpc_net_ns(clnt));\r\nerr = -EINVAL;\r\ngss_auth->mech = gss_mech_get_by_pseudoflavor(flavor);\r\nif (!gss_auth->mech) {\r\ndprintk("RPC: Pseudoflavor %d not found!\n", flavor);\r\ngoto err_put_net;\r\n}\r\ngss_auth->service = gss_pseudoflavor_to_service(gss_auth->mech, flavor);\r\nif (gss_auth->service == 0)\r\ngoto err_put_mech;\r\nif (!gssd_running(gss_auth->net))\r\ngoto err_put_mech;\r\nauth = &gss_auth->rpc_auth;\r\nauth->au_cslack = GSS_CRED_SLACK >> 2;\r\nauth->au_rslack = GSS_VERF_SLACK >> 2;\r\nauth->au_ops = &authgss_ops;\r\nauth->au_flavor = flavor;\r\natomic_set(&auth->au_count, 1);\r\nkref_init(&gss_auth->kref);\r\nerr = rpcauth_init_credcache(auth);\r\nif (err)\r\ngoto err_put_mech;\r\ngss_pipe = gss_pipe_get(clnt, "gssd", &gss_upcall_ops_v1);\r\nif (IS_ERR(gss_pipe)) {\r\nerr = PTR_ERR(gss_pipe);\r\ngoto err_destroy_credcache;\r\n}\r\ngss_auth->gss_pipe[1] = gss_pipe;\r\ngss_pipe = gss_pipe_get(clnt, gss_auth->mech->gm_name,\r\n&gss_upcall_ops_v0);\r\nif (IS_ERR(gss_pipe)) {\r\nerr = PTR_ERR(gss_pipe);\r\ngoto err_destroy_pipe_1;\r\n}\r\ngss_auth->gss_pipe[0] = gss_pipe;\r\nreturn gss_auth;\r\nerr_destroy_pipe_1:\r\ngss_pipe_free(gss_auth->gss_pipe[1]);\r\nerr_destroy_credcache:\r\nrpcauth_destroy_credcache(auth);\r\nerr_put_mech:\r\ngss_mech_put(gss_auth->mech);\r\nerr_put_net:\r\nput_net(gss_auth->net);\r\nerr_free:\r\nkfree(gss_auth->target_name);\r\nkfree(gss_auth);\r\nout_dec:\r\nmodule_put(THIS_MODULE);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void\r\ngss_free(struct gss_auth *gss_auth)\r\n{\r\ngss_pipe_free(gss_auth->gss_pipe[0]);\r\ngss_pipe_free(gss_auth->gss_pipe[1]);\r\ngss_mech_put(gss_auth->mech);\r\nput_net(gss_auth->net);\r\nkfree(gss_auth->target_name);\r\nkfree(gss_auth);\r\nmodule_put(THIS_MODULE);\r\n}\r\nstatic void\r\ngss_free_callback(struct kref *kref)\r\n{\r\nstruct gss_auth *gss_auth = container_of(kref, struct gss_auth, kref);\r\ngss_free(gss_auth);\r\n}\r\nstatic void\r\ngss_put_auth(struct gss_auth *gss_auth)\r\n{\r\nkref_put(&gss_auth->kref, gss_free_callback);\r\n}\r\nstatic void\r\ngss_destroy(struct rpc_auth *auth)\r\n{\r\nstruct gss_auth *gss_auth = container_of(auth,\r\nstruct gss_auth, rpc_auth);\r\ndprintk("RPC: destroying GSS authenticator %p flavor %d\n",\r\nauth, auth->au_flavor);\r\nif (hash_hashed(&gss_auth->hash)) {\r\nspin_lock(&gss_auth_hash_lock);\r\nhash_del(&gss_auth->hash);\r\nspin_unlock(&gss_auth_hash_lock);\r\n}\r\ngss_pipe_free(gss_auth->gss_pipe[0]);\r\ngss_auth->gss_pipe[0] = NULL;\r\ngss_pipe_free(gss_auth->gss_pipe[1]);\r\ngss_auth->gss_pipe[1] = NULL;\r\nrpcauth_destroy_credcache(auth);\r\ngss_put_auth(gss_auth);\r\n}\r\nstatic struct gss_auth *\r\ngss_auth_find_or_add_hashed(struct rpc_auth_create_args *args,\r\nstruct rpc_clnt *clnt,\r\nstruct gss_auth *new)\r\n{\r\nstruct gss_auth *gss_auth;\r\nunsigned long hashval = (unsigned long)clnt;\r\nspin_lock(&gss_auth_hash_lock);\r\nhash_for_each_possible(gss_auth_hash_table,\r\ngss_auth,\r\nhash,\r\nhashval) {\r\nif (gss_auth->client != clnt)\r\ncontinue;\r\nif (gss_auth->rpc_auth.au_flavor != args->pseudoflavor)\r\ncontinue;\r\nif (gss_auth->target_name != args->target_name) {\r\nif (gss_auth->target_name == NULL)\r\ncontinue;\r\nif (args->target_name == NULL)\r\ncontinue;\r\nif (strcmp(gss_auth->target_name, args->target_name))\r\ncontinue;\r\n}\r\nif (!atomic_inc_not_zero(&gss_auth->rpc_auth.au_count))\r\ncontinue;\r\ngoto out;\r\n}\r\nif (new)\r\nhash_add(gss_auth_hash_table, &new->hash, hashval);\r\ngss_auth = new;\r\nout:\r\nspin_unlock(&gss_auth_hash_lock);\r\nreturn gss_auth;\r\n}\r\nstatic struct gss_auth *\r\ngss_create_hashed(struct rpc_auth_create_args *args, struct rpc_clnt *clnt)\r\n{\r\nstruct gss_auth *gss_auth;\r\nstruct gss_auth *new;\r\ngss_auth = gss_auth_find_or_add_hashed(args, clnt, NULL);\r\nif (gss_auth != NULL)\r\ngoto out;\r\nnew = gss_create_new(args, clnt);\r\nif (IS_ERR(new))\r\nreturn new;\r\ngss_auth = gss_auth_find_or_add_hashed(args, clnt, new);\r\nif (gss_auth != new)\r\ngss_destroy(&new->rpc_auth);\r\nout:\r\nreturn gss_auth;\r\n}\r\nstatic struct rpc_auth *\r\ngss_create(struct rpc_auth_create_args *args, struct rpc_clnt *clnt)\r\n{\r\nstruct gss_auth *gss_auth;\r\nstruct rpc_xprt *xprt = rcu_access_pointer(clnt->cl_xprt);\r\nwhile (clnt != clnt->cl_parent) {\r\nstruct rpc_clnt *parent = clnt->cl_parent;\r\nif (rcu_access_pointer(parent->cl_xprt) != xprt)\r\nbreak;\r\nclnt = parent;\r\n}\r\ngss_auth = gss_create_hashed(args, clnt);\r\nif (IS_ERR(gss_auth))\r\nreturn ERR_CAST(gss_auth);\r\nreturn &gss_auth->rpc_auth;\r\n}\r\nstatic int\r\ngss_destroying_context(struct rpc_cred *cred)\r\n{\r\nstruct gss_cred *gss_cred = container_of(cred, struct gss_cred, gc_base);\r\nstruct gss_auth *gss_auth = container_of(cred->cr_auth, struct gss_auth, rpc_auth);\r\nstruct gss_cl_ctx *ctx = rcu_dereference_protected(gss_cred->gc_ctx, 1);\r\nstruct rpc_task *task;\r\nif (test_bit(RPCAUTH_CRED_UPTODATE, &cred->cr_flags) == 0)\r\nreturn 0;\r\nctx->gc_proc = RPC_GSS_PROC_DESTROY;\r\ncred->cr_ops = &gss_nullops;\r\nget_rpccred(cred);\r\ntask = rpc_call_null(gss_auth->client, cred, RPC_TASK_ASYNC|RPC_TASK_SOFT);\r\nif (!IS_ERR(task))\r\nrpc_put_task(task);\r\nput_rpccred(cred);\r\nreturn 1;\r\n}\r\nstatic void\r\ngss_do_free_ctx(struct gss_cl_ctx *ctx)\r\n{\r\ndprintk("RPC: %s\n", __func__);\r\ngss_delete_sec_context(&ctx->gc_gss_ctx);\r\nkfree(ctx->gc_wire_ctx.data);\r\nkfree(ctx->gc_acceptor.data);\r\nkfree(ctx);\r\n}\r\nstatic void\r\ngss_free_ctx_callback(struct rcu_head *head)\r\n{\r\nstruct gss_cl_ctx *ctx = container_of(head, struct gss_cl_ctx, gc_rcu);\r\ngss_do_free_ctx(ctx);\r\n}\r\nstatic void\r\ngss_free_ctx(struct gss_cl_ctx *ctx)\r\n{\r\ncall_rcu(&ctx->gc_rcu, gss_free_ctx_callback);\r\n}\r\nstatic void\r\ngss_free_cred(struct gss_cred *gss_cred)\r\n{\r\ndprintk("RPC: %s cred=%p\n", __func__, gss_cred);\r\nkfree(gss_cred);\r\n}\r\nstatic void\r\ngss_free_cred_callback(struct rcu_head *head)\r\n{\r\nstruct gss_cred *gss_cred = container_of(head, struct gss_cred, gc_base.cr_rcu);\r\ngss_free_cred(gss_cred);\r\n}\r\nstatic void\r\ngss_destroy_nullcred(struct rpc_cred *cred)\r\n{\r\nstruct gss_cred *gss_cred = container_of(cred, struct gss_cred, gc_base);\r\nstruct gss_auth *gss_auth = container_of(cred->cr_auth, struct gss_auth, rpc_auth);\r\nstruct gss_cl_ctx *ctx = rcu_dereference_protected(gss_cred->gc_ctx, 1);\r\nRCU_INIT_POINTER(gss_cred->gc_ctx, NULL);\r\ncall_rcu(&cred->cr_rcu, gss_free_cred_callback);\r\nif (ctx)\r\ngss_put_ctx(ctx);\r\ngss_put_auth(gss_auth);\r\n}\r\nstatic void\r\ngss_destroy_cred(struct rpc_cred *cred)\r\n{\r\nif (gss_destroying_context(cred))\r\nreturn;\r\ngss_destroy_nullcred(cred);\r\n}\r\nstatic struct rpc_cred *\r\ngss_lookup_cred(struct rpc_auth *auth, struct auth_cred *acred, int flags)\r\n{\r\nreturn rpcauth_lookup_credcache(auth, acred, flags);\r\n}\r\nstatic struct rpc_cred *\r\ngss_create_cred(struct rpc_auth *auth, struct auth_cred *acred, int flags)\r\n{\r\nstruct gss_auth *gss_auth = container_of(auth, struct gss_auth, rpc_auth);\r\nstruct gss_cred *cred = NULL;\r\nint err = -ENOMEM;\r\ndprintk("RPC: %s for uid %d, flavor %d\n",\r\n__func__, from_kuid(&init_user_ns, acred->uid),\r\nauth->au_flavor);\r\nif (!(cred = kzalloc(sizeof(*cred), GFP_NOFS)))\r\ngoto out_err;\r\nrpcauth_init_cred(&cred->gc_base, acred, auth, &gss_credops);\r\ncred->gc_base.cr_flags = 1UL << RPCAUTH_CRED_NEW;\r\ncred->gc_service = gss_auth->service;\r\ncred->gc_principal = NULL;\r\nif (acred->machine_cred)\r\ncred->gc_principal = acred->principal;\r\nkref_get(&gss_auth->kref);\r\nreturn &cred->gc_base;\r\nout_err:\r\ndprintk("RPC: %s failed with error %d\n", __func__, err);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int\r\ngss_cred_init(struct rpc_auth *auth, struct rpc_cred *cred)\r\n{\r\nstruct gss_auth *gss_auth = container_of(auth, struct gss_auth, rpc_auth);\r\nstruct gss_cred *gss_cred = container_of(cred,struct gss_cred, gc_base);\r\nint err;\r\ndo {\r\nerr = gss_create_upcall(gss_auth, gss_cred);\r\n} while (err == -EAGAIN);\r\nreturn err;\r\n}\r\nstatic char *\r\ngss_stringify_acceptor(struct rpc_cred *cred)\r\n{\r\nchar *string = NULL;\r\nstruct gss_cred *gss_cred = container_of(cred, struct gss_cred, gc_base);\r\nstruct gss_cl_ctx *ctx;\r\nunsigned int len;\r\nstruct xdr_netobj *acceptor;\r\nrcu_read_lock();\r\nctx = rcu_dereference(gss_cred->gc_ctx);\r\nif (!ctx)\r\ngoto out;\r\nlen = ctx->gc_acceptor.len;\r\nrcu_read_unlock();\r\nif (!len)\r\nreturn NULL;\r\nrealloc:\r\nstring = kmalloc(len + 1, GFP_KERNEL);\r\nif (!string)\r\nreturn NULL;\r\nrcu_read_lock();\r\nctx = rcu_dereference(gss_cred->gc_ctx);\r\nif (!ctx || !ctx->gc_acceptor.len) {\r\nkfree(string);\r\nstring = NULL;\r\ngoto out;\r\n}\r\nacceptor = &ctx->gc_acceptor;\r\nif (len < acceptor->len) {\r\nlen = acceptor->len;\r\nrcu_read_unlock();\r\nkfree(string);\r\ngoto realloc;\r\n}\r\nmemcpy(string, acceptor->data, acceptor->len);\r\nstring[acceptor->len] = '\0';\r\nout:\r\nrcu_read_unlock();\r\nreturn string;\r\n}\r\nstatic int\r\ngss_key_timeout(struct rpc_cred *rc)\r\n{\r\nstruct gss_cred *gss_cred = container_of(rc, struct gss_cred, gc_base);\r\nstruct gss_cl_ctx *ctx;\r\nunsigned long now = jiffies;\r\nunsigned long expire;\r\nrcu_read_lock();\r\nctx = rcu_dereference(gss_cred->gc_ctx);\r\nif (ctx)\r\nexpire = ctx->gc_expiry - (gss_key_expire_timeo * HZ);\r\nrcu_read_unlock();\r\nif (!ctx || time_after(now, expire))\r\nreturn -EACCES;\r\nreturn 0;\r\n}\r\nstatic int\r\ngss_match(struct auth_cred *acred, struct rpc_cred *rc, int flags)\r\n{\r\nstruct gss_cred *gss_cred = container_of(rc, struct gss_cred, gc_base);\r\nstruct gss_cl_ctx *ctx;\r\nint ret;\r\nif (test_bit(RPCAUTH_CRED_NEW, &rc->cr_flags))\r\ngoto out;\r\nrcu_read_lock();\r\nctx = rcu_dereference(gss_cred->gc_ctx);\r\nif (!ctx || time_after(jiffies, ctx->gc_expiry)) {\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nrcu_read_unlock();\r\nif (!test_bit(RPCAUTH_CRED_UPTODATE, &rc->cr_flags))\r\nreturn 0;\r\nout:\r\nif (acred->principal != NULL) {\r\nif (gss_cred->gc_principal == NULL)\r\nreturn 0;\r\nret = strcmp(acred->principal, gss_cred->gc_principal) == 0;\r\ngoto check_expire;\r\n}\r\nif (gss_cred->gc_principal != NULL)\r\nreturn 0;\r\nret = uid_eq(rc->cr_uid, acred->uid);\r\ncheck_expire:\r\nif (ret == 0)\r\nreturn ret;\r\nif (test_bit(RPC_CRED_NOTIFY_TIMEOUT, &acred->ac_flags) &&\r\n(gss_key_timeout(rc) != 0)) {\r\ntest_and_clear_bit(RPC_CRED_NOTIFY_TIMEOUT, &acred->ac_flags);\r\nset_bit(RPC_CRED_KEY_EXPIRE_SOON, &acred->ac_flags);\r\n}\r\nreturn ret;\r\n}\r\nstatic __be32 *\r\ngss_marshal(struct rpc_task *task, __be32 *p)\r\n{\r\nstruct rpc_rqst *req = task->tk_rqstp;\r\nstruct rpc_cred *cred = req->rq_cred;\r\nstruct gss_cred *gss_cred = container_of(cred, struct gss_cred,\r\ngc_base);\r\nstruct gss_cl_ctx *ctx = gss_cred_get_ctx(cred);\r\n__be32 *cred_len;\r\nu32 maj_stat = 0;\r\nstruct xdr_netobj mic;\r\nstruct kvec iov;\r\nstruct xdr_buf verf_buf;\r\ndprintk("RPC: %5u %s\n", task->tk_pid, __func__);\r\n*p++ = htonl(RPC_AUTH_GSS);\r\ncred_len = p++;\r\nspin_lock(&ctx->gc_seq_lock);\r\nreq->rq_seqno = ctx->gc_seq++;\r\nspin_unlock(&ctx->gc_seq_lock);\r\n*p++ = htonl((u32) RPC_GSS_VERSION);\r\n*p++ = htonl((u32) ctx->gc_proc);\r\n*p++ = htonl((u32) req->rq_seqno);\r\n*p++ = htonl((u32) gss_cred->gc_service);\r\np = xdr_encode_netobj(p, &ctx->gc_wire_ctx);\r\n*cred_len = htonl((p - (cred_len + 1)) << 2);\r\niov.iov_base = xprt_skip_transport_header(req->rq_xprt,\r\nreq->rq_snd_buf.head[0].iov_base);\r\niov.iov_len = (u8 *)p - (u8 *)iov.iov_base;\r\nxdr_buf_from_iov(&iov, &verf_buf);\r\n*p++ = htonl(RPC_AUTH_GSS);\r\nmic.data = (u8 *)(p + 1);\r\nmaj_stat = gss_get_mic(ctx->gc_gss_ctx, &verf_buf, &mic);\r\nif (maj_stat == GSS_S_CONTEXT_EXPIRED) {\r\nclear_bit(RPCAUTH_CRED_UPTODATE, &cred->cr_flags);\r\n} else if (maj_stat != 0) {\r\nprintk("gss_marshal: gss_get_mic FAILED (%d)\n", maj_stat);\r\ngoto out_put_ctx;\r\n}\r\np = xdr_encode_opaque(p, NULL, mic.len);\r\ngss_put_ctx(ctx);\r\nreturn p;\r\nout_put_ctx:\r\ngss_put_ctx(ctx);\r\nreturn NULL;\r\n}\r\nstatic int gss_renew_cred(struct rpc_task *task)\r\n{\r\nstruct rpc_cred *oldcred = task->tk_rqstp->rq_cred;\r\nstruct gss_cred *gss_cred = container_of(oldcred,\r\nstruct gss_cred,\r\ngc_base);\r\nstruct rpc_auth *auth = oldcred->cr_auth;\r\nstruct auth_cred acred = {\r\n.uid = oldcred->cr_uid,\r\n.principal = gss_cred->gc_principal,\r\n.machine_cred = (gss_cred->gc_principal != NULL ? 1 : 0),\r\n};\r\nstruct rpc_cred *new;\r\nnew = gss_lookup_cred(auth, &acred, RPCAUTH_LOOKUP_NEW);\r\nif (IS_ERR(new))\r\nreturn PTR_ERR(new);\r\ntask->tk_rqstp->rq_cred = new;\r\nput_rpccred(oldcred);\r\nreturn 0;\r\n}\r\nstatic int gss_cred_is_negative_entry(struct rpc_cred *cred)\r\n{\r\nif (test_bit(RPCAUTH_CRED_NEGATIVE, &cred->cr_flags)) {\r\nunsigned long now = jiffies;\r\nunsigned long begin, expire;\r\nstruct gss_cred *gss_cred;\r\ngss_cred = container_of(cred, struct gss_cred, gc_base);\r\nbegin = gss_cred->gc_upcall_timestamp;\r\nexpire = begin + gss_expired_cred_retry_delay * HZ;\r\nif (time_in_range_open(now, begin, expire))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ngss_refresh(struct rpc_task *task)\r\n{\r\nstruct rpc_cred *cred = task->tk_rqstp->rq_cred;\r\nint ret = 0;\r\nif (gss_cred_is_negative_entry(cred))\r\nreturn -EKEYEXPIRED;\r\nif (!test_bit(RPCAUTH_CRED_NEW, &cred->cr_flags) &&\r\n!test_bit(RPCAUTH_CRED_UPTODATE, &cred->cr_flags)) {\r\nret = gss_renew_cred(task);\r\nif (ret < 0)\r\ngoto out;\r\ncred = task->tk_rqstp->rq_cred;\r\n}\r\nif (test_bit(RPCAUTH_CRED_NEW, &cred->cr_flags))\r\nret = gss_refresh_upcall(task);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int\r\ngss_refresh_null(struct rpc_task *task)\r\n{\r\nreturn 0;\r\n}\r\nstatic __be32 *\r\ngss_validate(struct rpc_task *task, __be32 *p)\r\n{\r\nstruct rpc_cred *cred = task->tk_rqstp->rq_cred;\r\nstruct gss_cl_ctx *ctx = gss_cred_get_ctx(cred);\r\n__be32 seq;\r\nstruct kvec iov;\r\nstruct xdr_buf verf_buf;\r\nstruct xdr_netobj mic;\r\nu32 flav,len;\r\nu32 maj_stat;\r\n__be32 *ret = ERR_PTR(-EIO);\r\ndprintk("RPC: %5u %s\n", task->tk_pid, __func__);\r\nflav = ntohl(*p++);\r\nif ((len = ntohl(*p++)) > RPC_MAX_AUTH_SIZE)\r\ngoto out_bad;\r\nif (flav != RPC_AUTH_GSS)\r\ngoto out_bad;\r\nseq = htonl(task->tk_rqstp->rq_seqno);\r\niov.iov_base = &seq;\r\niov.iov_len = sizeof(seq);\r\nxdr_buf_from_iov(&iov, &verf_buf);\r\nmic.data = (u8 *)p;\r\nmic.len = len;\r\nret = ERR_PTR(-EACCES);\r\nmaj_stat = gss_verify_mic(ctx->gc_gss_ctx, &verf_buf, &mic);\r\nif (maj_stat == GSS_S_CONTEXT_EXPIRED)\r\nclear_bit(RPCAUTH_CRED_UPTODATE, &cred->cr_flags);\r\nif (maj_stat) {\r\ndprintk("RPC: %5u %s: gss_verify_mic returned error 0x%08x\n",\r\ntask->tk_pid, __func__, maj_stat);\r\ngoto out_bad;\r\n}\r\ncred->cr_auth->au_verfsize = XDR_QUADLEN(len) + 2;\r\ngss_put_ctx(ctx);\r\ndprintk("RPC: %5u %s: gss_verify_mic succeeded.\n",\r\ntask->tk_pid, __func__);\r\nreturn p + XDR_QUADLEN(len);\r\nout_bad:\r\ngss_put_ctx(ctx);\r\ndprintk("RPC: %5u %s failed ret %ld.\n", task->tk_pid, __func__,\r\nPTR_ERR(ret));\r\nreturn ret;\r\n}\r\nstatic void gss_wrap_req_encode(kxdreproc_t encode, struct rpc_rqst *rqstp,\r\n__be32 *p, void *obj)\r\n{\r\nstruct xdr_stream xdr;\r\nxdr_init_encode(&xdr, &rqstp->rq_snd_buf, p);\r\nencode(rqstp, &xdr, obj);\r\n}\r\nstatic inline int\r\ngss_wrap_req_integ(struct rpc_cred *cred, struct gss_cl_ctx *ctx,\r\nkxdreproc_t encode, struct rpc_rqst *rqstp,\r\n__be32 *p, void *obj)\r\n{\r\nstruct xdr_buf *snd_buf = &rqstp->rq_snd_buf;\r\nstruct xdr_buf integ_buf;\r\n__be32 *integ_len = NULL;\r\nstruct xdr_netobj mic;\r\nu32 offset;\r\n__be32 *q;\r\nstruct kvec *iov;\r\nu32 maj_stat = 0;\r\nint status = -EIO;\r\ninteg_len = p++;\r\noffset = (u8 *)p - (u8 *)snd_buf->head[0].iov_base;\r\n*p++ = htonl(rqstp->rq_seqno);\r\ngss_wrap_req_encode(encode, rqstp, p, obj);\r\nif (xdr_buf_subsegment(snd_buf, &integ_buf,\r\noffset, snd_buf->len - offset))\r\nreturn status;\r\n*integ_len = htonl(integ_buf.len);\r\nif (snd_buf->page_len || snd_buf->tail[0].iov_len)\r\niov = snd_buf->tail;\r\nelse\r\niov = snd_buf->head;\r\np = iov->iov_base + iov->iov_len;\r\nmic.data = (u8 *)(p + 1);\r\nmaj_stat = gss_get_mic(ctx->gc_gss_ctx, &integ_buf, &mic);\r\nstatus = -EIO;\r\nif (maj_stat == GSS_S_CONTEXT_EXPIRED)\r\nclear_bit(RPCAUTH_CRED_UPTODATE, &cred->cr_flags);\r\nelse if (maj_stat)\r\nreturn status;\r\nq = xdr_encode_opaque(p, NULL, mic.len);\r\noffset = (u8 *)q - (u8 *)p;\r\niov->iov_len += offset;\r\nsnd_buf->len += offset;\r\nreturn 0;\r\n}\r\nstatic void\r\npriv_release_snd_buf(struct rpc_rqst *rqstp)\r\n{\r\nint i;\r\nfor (i=0; i < rqstp->rq_enc_pages_num; i++)\r\n__free_page(rqstp->rq_enc_pages[i]);\r\nkfree(rqstp->rq_enc_pages);\r\n}\r\nstatic int\r\nalloc_enc_pages(struct rpc_rqst *rqstp)\r\n{\r\nstruct xdr_buf *snd_buf = &rqstp->rq_snd_buf;\r\nint first, last, i;\r\nif (snd_buf->page_len == 0) {\r\nrqstp->rq_enc_pages_num = 0;\r\nreturn 0;\r\n}\r\nfirst = snd_buf->page_base >> PAGE_CACHE_SHIFT;\r\nlast = (snd_buf->page_base + snd_buf->page_len - 1) >> PAGE_CACHE_SHIFT;\r\nrqstp->rq_enc_pages_num = last - first + 1 + 1;\r\nrqstp->rq_enc_pages\r\n= kmalloc(rqstp->rq_enc_pages_num * sizeof(struct page *),\r\nGFP_NOFS);\r\nif (!rqstp->rq_enc_pages)\r\ngoto out;\r\nfor (i=0; i < rqstp->rq_enc_pages_num; i++) {\r\nrqstp->rq_enc_pages[i] = alloc_page(GFP_NOFS);\r\nif (rqstp->rq_enc_pages[i] == NULL)\r\ngoto out_free;\r\n}\r\nrqstp->rq_release_snd_buf = priv_release_snd_buf;\r\nreturn 0;\r\nout_free:\r\nrqstp->rq_enc_pages_num = i;\r\npriv_release_snd_buf(rqstp);\r\nout:\r\nreturn -EAGAIN;\r\n}\r\nstatic inline int\r\ngss_wrap_req_priv(struct rpc_cred *cred, struct gss_cl_ctx *ctx,\r\nkxdreproc_t encode, struct rpc_rqst *rqstp,\r\n__be32 *p, void *obj)\r\n{\r\nstruct xdr_buf *snd_buf = &rqstp->rq_snd_buf;\r\nu32 offset;\r\nu32 maj_stat;\r\nint status;\r\n__be32 *opaque_len;\r\nstruct page **inpages;\r\nint first;\r\nint pad;\r\nstruct kvec *iov;\r\nchar *tmp;\r\nopaque_len = p++;\r\noffset = (u8 *)p - (u8 *)snd_buf->head[0].iov_base;\r\n*p++ = htonl(rqstp->rq_seqno);\r\ngss_wrap_req_encode(encode, rqstp, p, obj);\r\nstatus = alloc_enc_pages(rqstp);\r\nif (status)\r\nreturn status;\r\nfirst = snd_buf->page_base >> PAGE_CACHE_SHIFT;\r\ninpages = snd_buf->pages + first;\r\nsnd_buf->pages = rqstp->rq_enc_pages;\r\nsnd_buf->page_base -= first << PAGE_CACHE_SHIFT;\r\nif (snd_buf->page_len || snd_buf->tail[0].iov_len) {\r\ntmp = page_address(rqstp->rq_enc_pages[rqstp->rq_enc_pages_num - 1]);\r\nmemcpy(tmp, snd_buf->tail[0].iov_base, snd_buf->tail[0].iov_len);\r\nsnd_buf->tail[0].iov_base = tmp;\r\n}\r\nmaj_stat = gss_wrap(ctx->gc_gss_ctx, offset, snd_buf, inpages);\r\nBUG_ON(snd_buf->len > snd_buf->buflen);\r\nstatus = -EIO;\r\nif (maj_stat == GSS_S_CONTEXT_EXPIRED)\r\nclear_bit(RPCAUTH_CRED_UPTODATE, &cred->cr_flags);\r\nelse if (maj_stat)\r\nreturn status;\r\n*opaque_len = htonl(snd_buf->len - offset);\r\nif (snd_buf->page_len || snd_buf->tail[0].iov_len)\r\niov = snd_buf->tail;\r\nelse\r\niov = snd_buf->head;\r\np = iov->iov_base + iov->iov_len;\r\npad = 3 - ((snd_buf->len - offset - 1) & 3);\r\nmemset(p, 0, pad);\r\niov->iov_len += pad;\r\nsnd_buf->len += pad;\r\nreturn 0;\r\n}\r\nstatic int\r\ngss_wrap_req(struct rpc_task *task,\r\nkxdreproc_t encode, void *rqstp, __be32 *p, void *obj)\r\n{\r\nstruct rpc_cred *cred = task->tk_rqstp->rq_cred;\r\nstruct gss_cred *gss_cred = container_of(cred, struct gss_cred,\r\ngc_base);\r\nstruct gss_cl_ctx *ctx = gss_cred_get_ctx(cred);\r\nint status = -EIO;\r\ndprintk("RPC: %5u %s\n", task->tk_pid, __func__);\r\nif (ctx->gc_proc != RPC_GSS_PROC_DATA) {\r\ngss_wrap_req_encode(encode, rqstp, p, obj);\r\nstatus = 0;\r\ngoto out;\r\n}\r\nswitch (gss_cred->gc_service) {\r\ncase RPC_GSS_SVC_NONE:\r\ngss_wrap_req_encode(encode, rqstp, p, obj);\r\nstatus = 0;\r\nbreak;\r\ncase RPC_GSS_SVC_INTEGRITY:\r\nstatus = gss_wrap_req_integ(cred, ctx, encode, rqstp, p, obj);\r\nbreak;\r\ncase RPC_GSS_SVC_PRIVACY:\r\nstatus = gss_wrap_req_priv(cred, ctx, encode, rqstp, p, obj);\r\nbreak;\r\n}\r\nout:\r\ngss_put_ctx(ctx);\r\ndprintk("RPC: %5u %s returning %d\n", task->tk_pid, __func__, status);\r\nreturn status;\r\n}\r\nstatic inline int\r\ngss_unwrap_resp_integ(struct rpc_cred *cred, struct gss_cl_ctx *ctx,\r\nstruct rpc_rqst *rqstp, __be32 **p)\r\n{\r\nstruct xdr_buf *rcv_buf = &rqstp->rq_rcv_buf;\r\nstruct xdr_buf integ_buf;\r\nstruct xdr_netobj mic;\r\nu32 data_offset, mic_offset;\r\nu32 integ_len;\r\nu32 maj_stat;\r\nint status = -EIO;\r\ninteg_len = ntohl(*(*p)++);\r\nif (integ_len & 3)\r\nreturn status;\r\ndata_offset = (u8 *)(*p) - (u8 *)rcv_buf->head[0].iov_base;\r\nmic_offset = integ_len + data_offset;\r\nif (mic_offset > rcv_buf->len)\r\nreturn status;\r\nif (ntohl(*(*p)++) != rqstp->rq_seqno)\r\nreturn status;\r\nif (xdr_buf_subsegment(rcv_buf, &integ_buf, data_offset,\r\nmic_offset - data_offset))\r\nreturn status;\r\nif (xdr_buf_read_netobj(rcv_buf, &mic, mic_offset))\r\nreturn status;\r\nmaj_stat = gss_verify_mic(ctx->gc_gss_ctx, &integ_buf, &mic);\r\nif (maj_stat == GSS_S_CONTEXT_EXPIRED)\r\nclear_bit(RPCAUTH_CRED_UPTODATE, &cred->cr_flags);\r\nif (maj_stat != GSS_S_COMPLETE)\r\nreturn status;\r\nreturn 0;\r\n}\r\nstatic inline int\r\ngss_unwrap_resp_priv(struct rpc_cred *cred, struct gss_cl_ctx *ctx,\r\nstruct rpc_rqst *rqstp, __be32 **p)\r\n{\r\nstruct xdr_buf *rcv_buf = &rqstp->rq_rcv_buf;\r\nu32 offset;\r\nu32 opaque_len;\r\nu32 maj_stat;\r\nint status = -EIO;\r\nopaque_len = ntohl(*(*p)++);\r\noffset = (u8 *)(*p) - (u8 *)rcv_buf->head[0].iov_base;\r\nif (offset + opaque_len > rcv_buf->len)\r\nreturn status;\r\nrcv_buf->len = offset + opaque_len;\r\nmaj_stat = gss_unwrap(ctx->gc_gss_ctx, offset, rcv_buf);\r\nif (maj_stat == GSS_S_CONTEXT_EXPIRED)\r\nclear_bit(RPCAUTH_CRED_UPTODATE, &cred->cr_flags);\r\nif (maj_stat != GSS_S_COMPLETE)\r\nreturn status;\r\nif (ntohl(*(*p)++) != rqstp->rq_seqno)\r\nreturn status;\r\nreturn 0;\r\n}\r\nstatic int\r\ngss_unwrap_req_decode(kxdrdproc_t decode, struct rpc_rqst *rqstp,\r\n__be32 *p, void *obj)\r\n{\r\nstruct xdr_stream xdr;\r\nxdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\r\nreturn decode(rqstp, &xdr, obj);\r\n}\r\nstatic int\r\ngss_unwrap_resp(struct rpc_task *task,\r\nkxdrdproc_t decode, void *rqstp, __be32 *p, void *obj)\r\n{\r\nstruct rpc_cred *cred = task->tk_rqstp->rq_cred;\r\nstruct gss_cred *gss_cred = container_of(cred, struct gss_cred,\r\ngc_base);\r\nstruct gss_cl_ctx *ctx = gss_cred_get_ctx(cred);\r\n__be32 *savedp = p;\r\nstruct kvec *head = ((struct rpc_rqst *)rqstp)->rq_rcv_buf.head;\r\nint savedlen = head->iov_len;\r\nint status = -EIO;\r\nif (ctx->gc_proc != RPC_GSS_PROC_DATA)\r\ngoto out_decode;\r\nswitch (gss_cred->gc_service) {\r\ncase RPC_GSS_SVC_NONE:\r\nbreak;\r\ncase RPC_GSS_SVC_INTEGRITY:\r\nstatus = gss_unwrap_resp_integ(cred, ctx, rqstp, &p);\r\nif (status)\r\ngoto out;\r\nbreak;\r\ncase RPC_GSS_SVC_PRIVACY:\r\nstatus = gss_unwrap_resp_priv(cred, ctx, rqstp, &p);\r\nif (status)\r\ngoto out;\r\nbreak;\r\n}\r\ncred->cr_auth->au_rslack = cred->cr_auth->au_verfsize + (p - savedp)\r\n+ (savedlen - head->iov_len);\r\nout_decode:\r\nstatus = gss_unwrap_req_decode(decode, rqstp, p, obj);\r\nout:\r\ngss_put_ctx(ctx);\r\ndprintk("RPC: %5u %s returning %d\n",\r\ntask->tk_pid, __func__, status);\r\nreturn status;\r\n}\r\nstatic __net_init int rpcsec_gss_init_net(struct net *net)\r\n{\r\nreturn gss_svc_init_net(net);\r\n}\r\nstatic __net_exit void rpcsec_gss_exit_net(struct net *net)\r\n{\r\ngss_svc_shutdown_net(net);\r\n}\r\nstatic int __init init_rpcsec_gss(void)\r\n{\r\nint err = 0;\r\nerr = rpcauth_register(&authgss_ops);\r\nif (err)\r\ngoto out;\r\nerr = gss_svc_init();\r\nif (err)\r\ngoto out_unregister;\r\nerr = register_pernet_subsys(&rpcsec_gss_net_ops);\r\nif (err)\r\ngoto out_svc_exit;\r\nrpc_init_wait_queue(&pipe_version_rpc_waitqueue, "gss pipe version");\r\nreturn 0;\r\nout_svc_exit:\r\ngss_svc_shutdown();\r\nout_unregister:\r\nrpcauth_unregister(&authgss_ops);\r\nout:\r\nreturn err;\r\n}\r\nstatic void __exit exit_rpcsec_gss(void)\r\n{\r\nunregister_pernet_subsys(&rpcsec_gss_net_ops);\r\ngss_svc_shutdown();\r\nrpcauth_unregister(&authgss_ops);\r\nrcu_barrier();\r\n}
