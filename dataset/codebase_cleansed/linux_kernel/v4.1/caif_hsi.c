static void cfhsi_inactivity_tout(unsigned long arg)\r\n{\r\nstruct cfhsi *cfhsi = (struct cfhsi *)arg;\r\nnetdev_dbg(cfhsi->ndev, "%s.\n",\r\n__func__);\r\nif (!test_bit(CFHSI_SHUTDOWN, &cfhsi->bits))\r\nqueue_work(cfhsi->wq, &cfhsi->wake_down_work);\r\n}\r\nstatic void cfhsi_update_aggregation_stats(struct cfhsi *cfhsi,\r\nconst struct sk_buff *skb,\r\nint direction)\r\n{\r\nstruct caif_payload_info *info;\r\nint hpad, tpad, len;\r\ninfo = (struct caif_payload_info *)&skb->cb;\r\nhpad = 1 + PAD_POW2((info->hdr_len + 1), cfhsi->cfg.head_align);\r\ntpad = PAD_POW2((skb->len + hpad), cfhsi->cfg.tail_align);\r\nlen = skb->len + hpad + tpad;\r\nif (direction > 0)\r\ncfhsi->aggregation_len += len;\r\nelse if (direction < 0)\r\ncfhsi->aggregation_len -= len;\r\n}\r\nstatic bool cfhsi_can_send_aggregate(struct cfhsi *cfhsi)\r\n{\r\nint i;\r\nif (cfhsi->cfg.aggregation_timeout == 0)\r\nreturn true;\r\nfor (i = 0; i < CFHSI_PRIO_BEBK; ++i) {\r\nif (cfhsi->qhead[i].qlen)\r\nreturn true;\r\n}\r\nif (cfhsi->qhead[CFHSI_PRIO_BEBK].qlen >= CFHSI_MAX_PKTS)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic struct sk_buff *cfhsi_dequeue(struct cfhsi *cfhsi)\r\n{\r\nstruct sk_buff *skb;\r\nint i;\r\nfor (i = 0; i < CFHSI_PRIO_LAST; ++i) {\r\nskb = skb_dequeue(&cfhsi->qhead[i]);\r\nif (skb)\r\nbreak;\r\n}\r\nreturn skb;\r\n}\r\nstatic int cfhsi_tx_queue_len(struct cfhsi *cfhsi)\r\n{\r\nint i, len = 0;\r\nfor (i = 0; i < CFHSI_PRIO_LAST; ++i)\r\nlen += skb_queue_len(&cfhsi->qhead[i]);\r\nreturn len;\r\n}\r\nstatic void cfhsi_abort_tx(struct cfhsi *cfhsi)\r\n{\r\nstruct sk_buff *skb;\r\nfor (;;) {\r\nspin_lock_bh(&cfhsi->lock);\r\nskb = cfhsi_dequeue(cfhsi);\r\nif (!skb)\r\nbreak;\r\ncfhsi->ndev->stats.tx_errors++;\r\ncfhsi->ndev->stats.tx_dropped++;\r\ncfhsi_update_aggregation_stats(cfhsi, skb, -1);\r\nspin_unlock_bh(&cfhsi->lock);\r\nkfree_skb(skb);\r\n}\r\ncfhsi->tx_state = CFHSI_TX_STATE_IDLE;\r\nif (!test_bit(CFHSI_SHUTDOWN, &cfhsi->bits))\r\nmod_timer(&cfhsi->inactivity_timer,\r\njiffies + cfhsi->cfg.inactivity_timeout);\r\nspin_unlock_bh(&cfhsi->lock);\r\n}\r\nstatic int cfhsi_flush_fifo(struct cfhsi *cfhsi)\r\n{\r\nchar buffer[32];\r\nsize_t fifo_occupancy;\r\nint ret;\r\nnetdev_dbg(cfhsi->ndev, "%s.\n",\r\n__func__);\r\ndo {\r\nret = cfhsi->ops->cfhsi_fifo_occupancy(cfhsi->ops,\r\n&fifo_occupancy);\r\nif (ret) {\r\nnetdev_warn(cfhsi->ndev,\r\n"%s: can't get FIFO occupancy: %d.\n",\r\n__func__, ret);\r\nbreak;\r\n} else if (!fifo_occupancy)\r\nbreak;\r\nfifo_occupancy = min(sizeof(buffer), fifo_occupancy);\r\nset_bit(CFHSI_FLUSH_FIFO, &cfhsi->bits);\r\nret = cfhsi->ops->cfhsi_rx(buffer, fifo_occupancy,\r\ncfhsi->ops);\r\nif (ret) {\r\nclear_bit(CFHSI_FLUSH_FIFO, &cfhsi->bits);\r\nnetdev_warn(cfhsi->ndev,\r\n"%s: can't read data: %d.\n",\r\n__func__, ret);\r\nbreak;\r\n}\r\nret = 5 * HZ;\r\nret = wait_event_interruptible_timeout(cfhsi->flush_fifo_wait,\r\n!test_bit(CFHSI_FLUSH_FIFO, &cfhsi->bits), ret);\r\nif (ret < 0) {\r\nnetdev_warn(cfhsi->ndev,\r\n"%s: can't wait for flush complete: %d.\n",\r\n__func__, ret);\r\nbreak;\r\n} else if (!ret) {\r\nret = -ETIMEDOUT;\r\nnetdev_warn(cfhsi->ndev,\r\n"%s: timeout waiting for flush complete.\n",\r\n__func__);\r\nbreak;\r\n}\r\n} while (1);\r\nreturn ret;\r\n}\r\nstatic int cfhsi_tx_frm(struct cfhsi_desc *desc, struct cfhsi *cfhsi)\r\n{\r\nint nfrms = 0;\r\nint pld_len = 0;\r\nstruct sk_buff *skb;\r\nu8 *pfrm = desc->emb_frm + CFHSI_MAX_EMB_FRM_SZ;\r\nskb = cfhsi_dequeue(cfhsi);\r\nif (!skb)\r\nreturn 0;\r\ndesc->offset = 0;\r\nif (skb->len < CFHSI_MAX_EMB_FRM_SZ) {\r\nstruct caif_payload_info *info;\r\nint hpad;\r\nint tpad;\r\ninfo = (struct caif_payload_info *)&skb->cb;\r\nhpad = 1 + PAD_POW2((info->hdr_len + 1), cfhsi->cfg.head_align);\r\ntpad = PAD_POW2((skb->len + hpad), cfhsi->cfg.tail_align);\r\nif ((skb->len + hpad + tpad) <= CFHSI_MAX_EMB_FRM_SZ) {\r\nu8 *pemb = desc->emb_frm;\r\ndesc->offset = CFHSI_DESC_SHORT_SZ;\r\n*pemb = (u8)(hpad - 1);\r\npemb += hpad;\r\nspin_lock_bh(&cfhsi->lock);\r\ncfhsi->ndev->stats.tx_packets++;\r\ncfhsi->ndev->stats.tx_bytes += skb->len;\r\ncfhsi_update_aggregation_stats(cfhsi, skb, -1);\r\nspin_unlock_bh(&cfhsi->lock);\r\nskb_copy_bits(skb, 0, pemb, skb->len);\r\nconsume_skb(skb);\r\nskb = NULL;\r\n}\r\n}\r\npfrm = desc->emb_frm + CFHSI_MAX_EMB_FRM_SZ;\r\nwhile (nfrms < CFHSI_MAX_PKTS) {\r\nstruct caif_payload_info *info;\r\nint hpad;\r\nint tpad;\r\nif (!skb)\r\nskb = cfhsi_dequeue(cfhsi);\r\nif (!skb)\r\nbreak;\r\ninfo = (struct caif_payload_info *)&skb->cb;\r\nhpad = 1 + PAD_POW2((info->hdr_len + 1), cfhsi->cfg.head_align);\r\ntpad = PAD_POW2((skb->len + hpad), cfhsi->cfg.tail_align);\r\ndesc->cffrm_len[nfrms] = hpad + skb->len + tpad;\r\n*pfrm = (u8)(hpad - 1);\r\npfrm += hpad;\r\nspin_lock_bh(&cfhsi->lock);\r\ncfhsi->ndev->stats.tx_packets++;\r\ncfhsi->ndev->stats.tx_bytes += skb->len;\r\ncfhsi_update_aggregation_stats(cfhsi, skb, -1);\r\nspin_unlock_bh(&cfhsi->lock);\r\nskb_copy_bits(skb, 0, pfrm, skb->len);\r\npld_len += desc->cffrm_len[nfrms];\r\npfrm += skb->len + tpad;\r\nconsume_skb(skb);\r\nskb = NULL;\r\nnfrms++;\r\n}\r\nwhile (nfrms < CFHSI_MAX_PKTS) {\r\ndesc->cffrm_len[nfrms] = 0x0000;\r\nnfrms++;\r\n}\r\nif (cfhsi_can_send_aggregate(cfhsi))\r\ndesc->header |= CFHSI_PIGGY_DESC;\r\nelse\r\ndesc->header &= ~CFHSI_PIGGY_DESC;\r\nreturn CFHSI_DESC_SZ + pld_len;\r\n}\r\nstatic void cfhsi_start_tx(struct cfhsi *cfhsi)\r\n{\r\nstruct cfhsi_desc *desc = (struct cfhsi_desc *)cfhsi->tx_buf;\r\nint len, res;\r\nnetdev_dbg(cfhsi->ndev, "%s.\n", __func__);\r\nif (test_bit(CFHSI_SHUTDOWN, &cfhsi->bits))\r\nreturn;\r\ndo {\r\nlen = cfhsi_tx_frm(desc, cfhsi);\r\nif (!len) {\r\nspin_lock_bh(&cfhsi->lock);\r\nif (unlikely(cfhsi_tx_queue_len(cfhsi))) {\r\nspin_unlock_bh(&cfhsi->lock);\r\nres = -EAGAIN;\r\ncontinue;\r\n}\r\ncfhsi->tx_state = CFHSI_TX_STATE_IDLE;\r\nmod_timer(&cfhsi->inactivity_timer,\r\njiffies + cfhsi->cfg.inactivity_timeout);\r\nspin_unlock_bh(&cfhsi->lock);\r\nbreak;\r\n}\r\nres = cfhsi->ops->cfhsi_tx(cfhsi->tx_buf, len, cfhsi->ops);\r\nif (WARN_ON(res < 0))\r\nnetdev_err(cfhsi->ndev, "%s: TX error %d.\n",\r\n__func__, res);\r\n} while (res < 0);\r\n}\r\nstatic void cfhsi_tx_done(struct cfhsi *cfhsi)\r\n{\r\nnetdev_dbg(cfhsi->ndev, "%s.\n", __func__);\r\nif (test_bit(CFHSI_SHUTDOWN, &cfhsi->bits))\r\nreturn;\r\nspin_lock_bh(&cfhsi->lock);\r\nif (cfhsi->flow_off_sent &&\r\ncfhsi_tx_queue_len(cfhsi) <= cfhsi->cfg.q_low_mark &&\r\ncfhsi->cfdev.flowctrl) {\r\ncfhsi->flow_off_sent = 0;\r\ncfhsi->cfdev.flowctrl(cfhsi->ndev, ON);\r\n}\r\nif (cfhsi_can_send_aggregate(cfhsi)) {\r\nspin_unlock_bh(&cfhsi->lock);\r\ncfhsi_start_tx(cfhsi);\r\n} else {\r\nmod_timer(&cfhsi->aggregation_timer,\r\njiffies + cfhsi->cfg.aggregation_timeout);\r\nspin_unlock_bh(&cfhsi->lock);\r\n}\r\nreturn;\r\n}\r\nstatic void cfhsi_tx_done_cb(struct cfhsi_cb_ops *cb_ops)\r\n{\r\nstruct cfhsi *cfhsi;\r\ncfhsi = container_of(cb_ops, struct cfhsi, cb_ops);\r\nnetdev_dbg(cfhsi->ndev, "%s.\n",\r\n__func__);\r\nif (test_bit(CFHSI_SHUTDOWN, &cfhsi->bits))\r\nreturn;\r\ncfhsi_tx_done(cfhsi);\r\n}\r\nstatic int cfhsi_rx_desc(struct cfhsi_desc *desc, struct cfhsi *cfhsi)\r\n{\r\nint xfer_sz = 0;\r\nint nfrms = 0;\r\nu16 *plen = NULL;\r\nu8 *pfrm = NULL;\r\nif ((desc->header & ~CFHSI_PIGGY_DESC) ||\r\n(desc->offset > CFHSI_MAX_EMB_FRM_SZ)) {\r\nnetdev_err(cfhsi->ndev, "%s: Invalid descriptor.\n",\r\n__func__);\r\nreturn -EPROTO;\r\n}\r\nif (desc->offset) {\r\nstruct sk_buff *skb;\r\nu8 *dst = NULL;\r\nint len = 0;\r\npfrm = ((u8 *)desc) + desc->offset;\r\npfrm += *pfrm + 1;\r\nlen = *pfrm;\r\nlen |= ((*(pfrm+1)) << 8) & 0xFF00;\r\nlen += 2;\r\nif (unlikely(len > CFHSI_MAX_CAIF_FRAME_SZ)) {\r\nnetdev_err(cfhsi->ndev, "%s: Invalid length.\n",\r\n__func__);\r\nreturn -EPROTO;\r\n}\r\nskb = alloc_skb(len + 1, GFP_ATOMIC);\r\nif (!skb) {\r\nnetdev_err(cfhsi->ndev, "%s: Out of memory !\n",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\ncaif_assert(skb != NULL);\r\ndst = skb_put(skb, len);\r\nmemcpy(dst, pfrm, len);\r\nskb->protocol = htons(ETH_P_CAIF);\r\nskb_reset_mac_header(skb);\r\nskb->dev = cfhsi->ndev;\r\nif (in_interrupt())\r\nnetif_rx(skb);\r\nelse\r\nnetif_rx_ni(skb);\r\ncfhsi->ndev->stats.rx_packets++;\r\ncfhsi->ndev->stats.rx_bytes += len;\r\n}\r\nplen = desc->cffrm_len;\r\nwhile (nfrms < CFHSI_MAX_PKTS && *plen) {\r\nxfer_sz += *plen;\r\nplen++;\r\nnfrms++;\r\n}\r\nif (desc->header & CFHSI_PIGGY_DESC)\r\nxfer_sz += CFHSI_DESC_SZ;\r\nif ((xfer_sz % 4) || (xfer_sz > (CFHSI_BUF_SZ_RX - CFHSI_DESC_SZ))) {\r\nnetdev_err(cfhsi->ndev,\r\n"%s: Invalid payload len: %d, ignored.\n",\r\n__func__, xfer_sz);\r\nreturn -EPROTO;\r\n}\r\nreturn xfer_sz;\r\n}\r\nstatic int cfhsi_rx_desc_len(struct cfhsi_desc *desc)\r\n{\r\nint xfer_sz = 0;\r\nint nfrms = 0;\r\nu16 *plen;\r\nif ((desc->header & ~CFHSI_PIGGY_DESC) ||\r\n(desc->offset > CFHSI_MAX_EMB_FRM_SZ)) {\r\npr_err("Invalid descriptor. %x %x\n", desc->header,\r\ndesc->offset);\r\nreturn -EPROTO;\r\n}\r\nplen = desc->cffrm_len;\r\nwhile (nfrms < CFHSI_MAX_PKTS && *plen) {\r\nxfer_sz += *plen;\r\nplen++;\r\nnfrms++;\r\n}\r\nif (xfer_sz % 4) {\r\npr_err("Invalid payload len: %d, ignored.\n", xfer_sz);\r\nreturn -EPROTO;\r\n}\r\nreturn xfer_sz;\r\n}\r\nstatic int cfhsi_rx_pld(struct cfhsi_desc *desc, struct cfhsi *cfhsi)\r\n{\r\nint rx_sz = 0;\r\nint nfrms = 0;\r\nu16 *plen = NULL;\r\nu8 *pfrm = NULL;\r\nif (WARN_ON((desc->header & ~CFHSI_PIGGY_DESC) ||\r\n(desc->offset > CFHSI_MAX_EMB_FRM_SZ))) {\r\nnetdev_err(cfhsi->ndev, "%s: Invalid descriptor.\n",\r\n__func__);\r\nreturn -EPROTO;\r\n}\r\npfrm = desc->emb_frm + CFHSI_MAX_EMB_FRM_SZ;\r\nplen = desc->cffrm_len;\r\nwhile (nfrms < cfhsi->rx_state.nfrms) {\r\npfrm += *plen;\r\nrx_sz += *plen;\r\nplen++;\r\nnfrms++;\r\n}\r\nwhile (nfrms < CFHSI_MAX_PKTS && *plen) {\r\nstruct sk_buff *skb;\r\nu8 *dst = NULL;\r\nu8 *pcffrm = NULL;\r\nint len;\r\npcffrm = pfrm + *pfrm + 1;\r\nlen = *pcffrm;\r\nlen |= ((*(pcffrm + 1)) << 8) & 0xFF00;\r\nlen += 2;\r\nif (unlikely(len > CFHSI_MAX_CAIF_FRAME_SZ)) {\r\nnetdev_err(cfhsi->ndev, "%s: Invalid length.\n",\r\n__func__);\r\nreturn -EPROTO;\r\n}\r\nskb = alloc_skb(len + 1, GFP_ATOMIC);\r\nif (!skb) {\r\nnetdev_err(cfhsi->ndev, "%s: Out of memory !\n",\r\n__func__);\r\ncfhsi->rx_state.nfrms = nfrms;\r\nreturn -ENOMEM;\r\n}\r\ncaif_assert(skb != NULL);\r\ndst = skb_put(skb, len);\r\nmemcpy(dst, pcffrm, len);\r\nskb->protocol = htons(ETH_P_CAIF);\r\nskb_reset_mac_header(skb);\r\nskb->dev = cfhsi->ndev;\r\nif (in_interrupt())\r\nnetif_rx(skb);\r\nelse\r\nnetif_rx_ni(skb);\r\ncfhsi->ndev->stats.rx_packets++;\r\ncfhsi->ndev->stats.rx_bytes += len;\r\npfrm += *plen;\r\nrx_sz += *plen;\r\nplen++;\r\nnfrms++;\r\n}\r\nreturn rx_sz;\r\n}\r\nstatic void cfhsi_rx_done(struct cfhsi *cfhsi)\r\n{\r\nint res;\r\nint desc_pld_len = 0, rx_len, rx_state;\r\nstruct cfhsi_desc *desc = NULL;\r\nu8 *rx_ptr, *rx_buf;\r\nstruct cfhsi_desc *piggy_desc = NULL;\r\ndesc = (struct cfhsi_desc *)cfhsi->rx_buf;\r\nnetdev_dbg(cfhsi->ndev, "%s\n", __func__);\r\nif (test_bit(CFHSI_SHUTDOWN, &cfhsi->bits))\r\nreturn;\r\nspin_lock_bh(&cfhsi->lock);\r\nmod_timer_pending(&cfhsi->inactivity_timer,\r\njiffies + cfhsi->cfg.inactivity_timeout);\r\nspin_unlock_bh(&cfhsi->lock);\r\nif (cfhsi->rx_state.state == CFHSI_RX_STATE_DESC) {\r\ndesc_pld_len = cfhsi_rx_desc_len(desc);\r\nif (desc_pld_len < 0)\r\ngoto out_of_sync;\r\nrx_buf = cfhsi->rx_buf;\r\nrx_len = desc_pld_len;\r\nif (desc_pld_len > 0 && (desc->header & CFHSI_PIGGY_DESC))\r\nrx_len += CFHSI_DESC_SZ;\r\nif (desc_pld_len == 0)\r\nrx_buf = cfhsi->rx_flip_buf;\r\n} else {\r\nrx_buf = cfhsi->rx_flip_buf;\r\nrx_len = CFHSI_DESC_SZ;\r\nif (cfhsi->rx_state.pld_len > 0 &&\r\n(desc->header & CFHSI_PIGGY_DESC)) {\r\npiggy_desc = (struct cfhsi_desc *)\r\n(desc->emb_frm + CFHSI_MAX_EMB_FRM_SZ +\r\ncfhsi->rx_state.pld_len);\r\ncfhsi->rx_state.piggy_desc = true;\r\ndesc_pld_len = cfhsi_rx_desc_len(piggy_desc);\r\nif (desc_pld_len < 0)\r\ngoto out_of_sync;\r\nif (desc_pld_len > 0) {\r\nrx_len = desc_pld_len;\r\nif (piggy_desc->header & CFHSI_PIGGY_DESC)\r\nrx_len += CFHSI_DESC_SZ;\r\n}\r\nmemcpy(rx_buf, (u8 *)piggy_desc,\r\nCFHSI_DESC_SHORT_SZ);\r\n}\r\n}\r\nif (desc_pld_len) {\r\nrx_state = CFHSI_RX_STATE_PAYLOAD;\r\nrx_ptr = rx_buf + CFHSI_DESC_SZ;\r\n} else {\r\nrx_state = CFHSI_RX_STATE_DESC;\r\nrx_ptr = rx_buf;\r\nrx_len = CFHSI_DESC_SZ;\r\n}\r\nif (test_bit(CFHSI_AWAKE, &cfhsi->bits)) {\r\nnetdev_dbg(cfhsi->ndev, "%s: Start RX.\n",\r\n__func__);\r\nres = cfhsi->ops->cfhsi_rx(rx_ptr, rx_len,\r\ncfhsi->ops);\r\nif (WARN_ON(res < 0)) {\r\nnetdev_err(cfhsi->ndev, "%s: RX error %d.\n",\r\n__func__, res);\r\ncfhsi->ndev->stats.rx_errors++;\r\ncfhsi->ndev->stats.rx_dropped++;\r\n}\r\n}\r\nif (cfhsi->rx_state.state == CFHSI_RX_STATE_DESC) {\r\nif (cfhsi_rx_desc(desc, cfhsi) < 0)\r\ngoto out_of_sync;\r\n} else {\r\nif (cfhsi_rx_pld(desc, cfhsi) < 0)\r\ngoto out_of_sync;\r\nif (piggy_desc) {\r\nif (cfhsi_rx_desc(piggy_desc, cfhsi) < 0)\r\ngoto out_of_sync;\r\npiggy_desc->offset = 0;\r\n}\r\n}\r\nmemset(&cfhsi->rx_state, 0, sizeof(cfhsi->rx_state));\r\ncfhsi->rx_state.state = rx_state;\r\ncfhsi->rx_ptr = rx_ptr;\r\ncfhsi->rx_len = rx_len;\r\ncfhsi->rx_state.pld_len = desc_pld_len;\r\ncfhsi->rx_state.piggy_desc = desc->header & CFHSI_PIGGY_DESC;\r\nif (rx_buf != cfhsi->rx_buf)\r\nswap(cfhsi->rx_buf, cfhsi->rx_flip_buf);\r\nreturn;\r\nout_of_sync:\r\nnetdev_err(cfhsi->ndev, "%s: Out of sync.\n", __func__);\r\nprint_hex_dump_bytes("--> ", DUMP_PREFIX_NONE,\r\ncfhsi->rx_buf, CFHSI_DESC_SZ);\r\nschedule_work(&cfhsi->out_of_sync_work);\r\n}\r\nstatic void cfhsi_rx_slowpath(unsigned long arg)\r\n{\r\nstruct cfhsi *cfhsi = (struct cfhsi *)arg;\r\nnetdev_dbg(cfhsi->ndev, "%s.\n",\r\n__func__);\r\ncfhsi_rx_done(cfhsi);\r\n}\r\nstatic void cfhsi_rx_done_cb(struct cfhsi_cb_ops *cb_ops)\r\n{\r\nstruct cfhsi *cfhsi;\r\ncfhsi = container_of(cb_ops, struct cfhsi, cb_ops);\r\nnetdev_dbg(cfhsi->ndev, "%s.\n",\r\n__func__);\r\nif (test_bit(CFHSI_SHUTDOWN, &cfhsi->bits))\r\nreturn;\r\nif (test_and_clear_bit(CFHSI_FLUSH_FIFO, &cfhsi->bits))\r\nwake_up_interruptible(&cfhsi->flush_fifo_wait);\r\nelse\r\ncfhsi_rx_done(cfhsi);\r\n}\r\nstatic void cfhsi_wake_up(struct work_struct *work)\r\n{\r\nstruct cfhsi *cfhsi = NULL;\r\nint res;\r\nint len;\r\nlong ret;\r\ncfhsi = container_of(work, struct cfhsi, wake_up_work);\r\nif (test_bit(CFHSI_SHUTDOWN, &cfhsi->bits))\r\nreturn;\r\nif (unlikely(test_bit(CFHSI_AWAKE, &cfhsi->bits))) {\r\nclear_bit(CFHSI_WAKE_UP, &cfhsi->bits);\r\nclear_bit(CFHSI_WAKE_UP_ACK, &cfhsi->bits);\r\nreturn;\r\n}\r\ncfhsi->ops->cfhsi_wake_up(cfhsi->ops);\r\nnetdev_dbg(cfhsi->ndev, "%s: Start waiting.\n",\r\n__func__);\r\nret = CFHSI_WAKE_TOUT;\r\nret = wait_event_interruptible_timeout(cfhsi->wake_up_wait,\r\ntest_and_clear_bit(CFHSI_WAKE_UP_ACK,\r\n&cfhsi->bits), ret);\r\nif (unlikely(ret < 0)) {\r\nnetdev_err(cfhsi->ndev, "%s: Signalled: %ld.\n",\r\n__func__, ret);\r\nclear_bit(CFHSI_WAKE_UP, &cfhsi->bits);\r\ncfhsi->ops->cfhsi_wake_down(cfhsi->ops);\r\nreturn;\r\n} else if (!ret) {\r\nbool ca_wake = false;\r\nsize_t fifo_occupancy = 0;\r\nnetdev_dbg(cfhsi->ndev, "%s: Timeout.\n",\r\n__func__);\r\nWARN_ON(cfhsi->ops->cfhsi_fifo_occupancy(cfhsi->ops,\r\n&fifo_occupancy));\r\nnetdev_dbg(cfhsi->ndev, "%s: Bytes in FIFO: %u.\n",\r\n__func__, (unsigned) fifo_occupancy);\r\nWARN_ON(cfhsi->ops->cfhsi_get_peer_wake(cfhsi->ops,\r\n&ca_wake));\r\nif (ca_wake) {\r\nnetdev_err(cfhsi->ndev, "%s: CA Wake missed !.\n",\r\n__func__);\r\nclear_bit(CFHSI_WAKE_UP_ACK, &cfhsi->bits);\r\ngoto wake_ack;\r\n}\r\nclear_bit(CFHSI_WAKE_UP, &cfhsi->bits);\r\ncfhsi->ops->cfhsi_wake_down(cfhsi->ops);\r\nreturn;\r\n}\r\nwake_ack:\r\nnetdev_dbg(cfhsi->ndev, "%s: Woken.\n",\r\n__func__);\r\nset_bit(CFHSI_AWAKE, &cfhsi->bits);\r\nclear_bit(CFHSI_WAKE_UP, &cfhsi->bits);\r\nnetdev_dbg(cfhsi->ndev, "%s: Start RX.\n", __func__);\r\nres = cfhsi->ops->cfhsi_rx(cfhsi->rx_ptr, cfhsi->rx_len, cfhsi->ops);\r\nif (WARN_ON(res < 0))\r\nnetdev_err(cfhsi->ndev, "%s: RX err %d.\n", __func__, res);\r\nclear_bit(CFHSI_WAKE_UP_ACK, &cfhsi->bits);\r\nspin_lock_bh(&cfhsi->lock);\r\nif (!cfhsi_tx_queue_len(cfhsi)) {\r\nnetdev_dbg(cfhsi->ndev, "%s: Peer wake, start timer.\n",\r\n__func__);\r\nmod_timer(&cfhsi->inactivity_timer,\r\njiffies + cfhsi->cfg.inactivity_timeout);\r\nspin_unlock_bh(&cfhsi->lock);\r\nreturn;\r\n}\r\nnetdev_dbg(cfhsi->ndev, "%s: Host wake.\n",\r\n__func__);\r\nspin_unlock_bh(&cfhsi->lock);\r\nlen = cfhsi_tx_frm((struct cfhsi_desc *)cfhsi->tx_buf, cfhsi);\r\nif (likely(len > 0)) {\r\nres = cfhsi->ops->cfhsi_tx(cfhsi->tx_buf, len, cfhsi->ops);\r\nif (WARN_ON(res < 0)) {\r\nnetdev_err(cfhsi->ndev, "%s: TX error %d.\n",\r\n__func__, res);\r\ncfhsi_abort_tx(cfhsi);\r\n}\r\n} else {\r\nnetdev_err(cfhsi->ndev,\r\n"%s: Failed to create HSI frame: %d.\n",\r\n__func__, len);\r\n}\r\n}\r\nstatic void cfhsi_wake_down(struct work_struct *work)\r\n{\r\nlong ret;\r\nstruct cfhsi *cfhsi = NULL;\r\nsize_t fifo_occupancy = 0;\r\nint retry = CFHSI_WAKE_TOUT;\r\ncfhsi = container_of(work, struct cfhsi, wake_down_work);\r\nnetdev_dbg(cfhsi->ndev, "%s.\n", __func__);\r\nif (test_bit(CFHSI_SHUTDOWN, &cfhsi->bits))\r\nreturn;\r\ncfhsi->ops->cfhsi_wake_down(cfhsi->ops);\r\nret = CFHSI_WAKE_TOUT;\r\nret = wait_event_interruptible_timeout(cfhsi->wake_down_wait,\r\ntest_and_clear_bit(CFHSI_WAKE_DOWN_ACK,\r\n&cfhsi->bits), ret);\r\nif (ret < 0) {\r\nnetdev_err(cfhsi->ndev, "%s: Signalled: %ld.\n",\r\n__func__, ret);\r\nreturn;\r\n} else if (!ret) {\r\nbool ca_wake = true;\r\nnetdev_err(cfhsi->ndev, "%s: Timeout.\n", __func__);\r\nWARN_ON(cfhsi->ops->cfhsi_get_peer_wake(cfhsi->ops,\r\n&ca_wake));\r\nif (!ca_wake)\r\nnetdev_err(cfhsi->ndev, "%s: CA Wake missed !.\n",\r\n__func__);\r\n}\r\nwhile (retry) {\r\nWARN_ON(cfhsi->ops->cfhsi_fifo_occupancy(cfhsi->ops,\r\n&fifo_occupancy));\r\nif (!fifo_occupancy)\r\nbreak;\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nschedule_timeout(1);\r\nretry--;\r\n}\r\nif (!retry)\r\nnetdev_err(cfhsi->ndev, "%s: FIFO Timeout.\n", __func__);\r\nclear_bit(CFHSI_AWAKE, &cfhsi->bits);\r\ncfhsi->ops->cfhsi_rx_cancel(cfhsi->ops);\r\n}\r\nstatic void cfhsi_out_of_sync(struct work_struct *work)\r\n{\r\nstruct cfhsi *cfhsi = NULL;\r\ncfhsi = container_of(work, struct cfhsi, out_of_sync_work);\r\nrtnl_lock();\r\ndev_close(cfhsi->ndev);\r\nrtnl_unlock();\r\n}\r\nstatic void cfhsi_wake_up_cb(struct cfhsi_cb_ops *cb_ops)\r\n{\r\nstruct cfhsi *cfhsi = NULL;\r\ncfhsi = container_of(cb_ops, struct cfhsi, cb_ops);\r\nnetdev_dbg(cfhsi->ndev, "%s.\n",\r\n__func__);\r\nset_bit(CFHSI_WAKE_UP_ACK, &cfhsi->bits);\r\nwake_up_interruptible(&cfhsi->wake_up_wait);\r\nif (test_bit(CFHSI_SHUTDOWN, &cfhsi->bits))\r\nreturn;\r\nif (!test_and_set_bit(CFHSI_WAKE_UP, &cfhsi->bits))\r\nqueue_work(cfhsi->wq, &cfhsi->wake_up_work);\r\n}\r\nstatic void cfhsi_wake_down_cb(struct cfhsi_cb_ops *cb_ops)\r\n{\r\nstruct cfhsi *cfhsi = NULL;\r\ncfhsi = container_of(cb_ops, struct cfhsi, cb_ops);\r\nnetdev_dbg(cfhsi->ndev, "%s.\n",\r\n__func__);\r\nset_bit(CFHSI_WAKE_DOWN_ACK, &cfhsi->bits);\r\nwake_up_interruptible(&cfhsi->wake_down_wait);\r\n}\r\nstatic void cfhsi_aggregation_tout(unsigned long arg)\r\n{\r\nstruct cfhsi *cfhsi = (struct cfhsi *)arg;\r\nnetdev_dbg(cfhsi->ndev, "%s.\n",\r\n__func__);\r\ncfhsi_start_tx(cfhsi);\r\n}\r\nstatic int cfhsi_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct cfhsi *cfhsi = NULL;\r\nint start_xfer = 0;\r\nint timer_active;\r\nint prio;\r\nif (!dev)\r\nreturn -EINVAL;\r\ncfhsi = netdev_priv(dev);\r\nswitch (skb->priority) {\r\ncase TC_PRIO_BESTEFFORT:\r\ncase TC_PRIO_FILLER:\r\ncase TC_PRIO_BULK:\r\nprio = CFHSI_PRIO_BEBK;\r\nbreak;\r\ncase TC_PRIO_INTERACTIVE_BULK:\r\nprio = CFHSI_PRIO_VI;\r\nbreak;\r\ncase TC_PRIO_INTERACTIVE:\r\nprio = CFHSI_PRIO_VO;\r\nbreak;\r\ncase TC_PRIO_CONTROL:\r\ndefault:\r\nprio = CFHSI_PRIO_CTL;\r\nbreak;\r\n}\r\nspin_lock_bh(&cfhsi->lock);\r\ncfhsi_update_aggregation_stats(cfhsi, skb, 1);\r\nskb_queue_tail(&cfhsi->qhead[prio], skb);\r\nif (WARN_ON(test_bit(CFHSI_SHUTDOWN, &cfhsi->bits))) {\r\nspin_unlock_bh(&cfhsi->lock);\r\ncfhsi_abort_tx(cfhsi);\r\nreturn -EINVAL;\r\n}\r\nif (!cfhsi->flow_off_sent &&\r\ncfhsi_tx_queue_len(cfhsi) > cfhsi->cfg.q_high_mark &&\r\ncfhsi->cfdev.flowctrl) {\r\ncfhsi->flow_off_sent = 1;\r\ncfhsi->cfdev.flowctrl(cfhsi->ndev, OFF);\r\n}\r\nif (cfhsi->tx_state == CFHSI_TX_STATE_IDLE) {\r\ncfhsi->tx_state = CFHSI_TX_STATE_XFER;\r\nstart_xfer = 1;\r\n}\r\nif (!start_xfer) {\r\nbool aggregate_ready =\r\ncfhsi_can_send_aggregate(cfhsi) &&\r\ndel_timer(&cfhsi->aggregation_timer) > 0;\r\nspin_unlock_bh(&cfhsi->lock);\r\nif (aggregate_ready)\r\ncfhsi_start_tx(cfhsi);\r\nreturn 0;\r\n}\r\ntimer_active = del_timer_sync(&cfhsi->inactivity_timer);\r\nspin_unlock_bh(&cfhsi->lock);\r\nif (timer_active) {\r\nstruct cfhsi_desc *desc = (struct cfhsi_desc *)cfhsi->tx_buf;\r\nint len;\r\nint res;\r\nlen = cfhsi_tx_frm(desc, cfhsi);\r\nWARN_ON(!len);\r\nres = cfhsi->ops->cfhsi_tx(cfhsi->tx_buf, len, cfhsi->ops);\r\nif (WARN_ON(res < 0)) {\r\nnetdev_err(cfhsi->ndev, "%s: TX error %d.\n",\r\n__func__, res);\r\ncfhsi_abort_tx(cfhsi);\r\n}\r\n} else {\r\nif (!test_and_set_bit(CFHSI_WAKE_UP, &cfhsi->bits))\r\nqueue_work(cfhsi->wq, &cfhsi->wake_up_work);\r\n}\r\nreturn 0;\r\n}\r\nstatic void cfhsi_setup(struct net_device *dev)\r\n{\r\nint i;\r\nstruct cfhsi *cfhsi = netdev_priv(dev);\r\ndev->features = 0;\r\ndev->type = ARPHRD_CAIF;\r\ndev->flags = IFF_POINTOPOINT | IFF_NOARP;\r\ndev->mtu = CFHSI_MAX_CAIF_FRAME_SZ;\r\ndev->tx_queue_len = 0;\r\ndev->destructor = free_netdev;\r\ndev->netdev_ops = &cfhsi_netdevops;\r\nfor (i = 0; i < CFHSI_PRIO_LAST; ++i)\r\nskb_queue_head_init(&cfhsi->qhead[i]);\r\ncfhsi->cfdev.link_select = CAIF_LINK_HIGH_BANDW;\r\ncfhsi->cfdev.use_frag = false;\r\ncfhsi->cfdev.use_stx = false;\r\ncfhsi->cfdev.use_fcs = false;\r\ncfhsi->ndev = dev;\r\ncfhsi->cfg = hsi_default_config;\r\n}\r\nstatic int cfhsi_open(struct net_device *ndev)\r\n{\r\nstruct cfhsi *cfhsi = netdev_priv(ndev);\r\nint res;\r\nclear_bit(CFHSI_SHUTDOWN, &cfhsi->bits);\r\ncfhsi->tx_state = CFHSI_TX_STATE_IDLE;\r\ncfhsi->rx_state.state = CFHSI_RX_STATE_DESC;\r\ncfhsi->flow_off_sent = 0;\r\ncfhsi->tx_buf = kzalloc(CFHSI_BUF_SZ_TX, GFP_KERNEL);\r\nif (!cfhsi->tx_buf) {\r\nres = -ENODEV;\r\ngoto err_alloc_tx;\r\n}\r\ncfhsi->rx_buf = kzalloc(CFHSI_BUF_SZ_RX, GFP_KERNEL);\r\nif (!cfhsi->rx_buf) {\r\nres = -ENODEV;\r\ngoto err_alloc_rx;\r\n}\r\ncfhsi->rx_flip_buf = kzalloc(CFHSI_BUF_SZ_RX, GFP_KERNEL);\r\nif (!cfhsi->rx_flip_buf) {\r\nres = -ENODEV;\r\ngoto err_alloc_rx_flip;\r\n}\r\ncfhsi->cfg.aggregation_timeout = hsi_default_config.aggregation_timeout;\r\ncfhsi->rx_ptr = cfhsi->rx_buf;\r\ncfhsi->rx_len = CFHSI_DESC_SZ;\r\nspin_lock_init(&cfhsi->lock);\r\ncfhsi->cb_ops.tx_done_cb = cfhsi_tx_done_cb;\r\ncfhsi->cb_ops.rx_done_cb = cfhsi_rx_done_cb;\r\ncfhsi->cb_ops.wake_up_cb = cfhsi_wake_up_cb;\r\ncfhsi->cb_ops.wake_down_cb = cfhsi_wake_down_cb;\r\nINIT_WORK(&cfhsi->wake_up_work, cfhsi_wake_up);\r\nINIT_WORK(&cfhsi->wake_down_work, cfhsi_wake_down);\r\nINIT_WORK(&cfhsi->out_of_sync_work, cfhsi_out_of_sync);\r\nclear_bit(CFHSI_WAKE_UP_ACK, &cfhsi->bits);\r\nclear_bit(CFHSI_WAKE_DOWN_ACK, &cfhsi->bits);\r\nclear_bit(CFHSI_WAKE_UP, &cfhsi->bits);\r\nclear_bit(CFHSI_AWAKE, &cfhsi->bits);\r\ncfhsi->wq = create_singlethread_workqueue(cfhsi->ndev->name);\r\nif (!cfhsi->wq) {\r\nnetdev_err(cfhsi->ndev, "%s: Failed to create work queue.\n",\r\n__func__);\r\nres = -ENODEV;\r\ngoto err_create_wq;\r\n}\r\ninit_waitqueue_head(&cfhsi->wake_up_wait);\r\ninit_waitqueue_head(&cfhsi->wake_down_wait);\r\ninit_waitqueue_head(&cfhsi->flush_fifo_wait);\r\ninit_timer(&cfhsi->inactivity_timer);\r\ncfhsi->inactivity_timer.data = (unsigned long)cfhsi;\r\ncfhsi->inactivity_timer.function = cfhsi_inactivity_tout;\r\ninit_timer(&cfhsi->rx_slowpath_timer);\r\ncfhsi->rx_slowpath_timer.data = (unsigned long)cfhsi;\r\ncfhsi->rx_slowpath_timer.function = cfhsi_rx_slowpath;\r\ninit_timer(&cfhsi->aggregation_timer);\r\ncfhsi->aggregation_timer.data = (unsigned long)cfhsi;\r\ncfhsi->aggregation_timer.function = cfhsi_aggregation_tout;\r\nres = cfhsi->ops->cfhsi_up(cfhsi->ops);\r\nif (res) {\r\nnetdev_err(cfhsi->ndev,\r\n"%s: can't activate HSI interface: %d.\n",\r\n__func__, res);\r\ngoto err_activate;\r\n}\r\nres = cfhsi_flush_fifo(cfhsi);\r\nif (res) {\r\nnetdev_err(cfhsi->ndev, "%s: Can't flush FIFO: %d.\n",\r\n__func__, res);\r\ngoto err_net_reg;\r\n}\r\nreturn res;\r\nerr_net_reg:\r\ncfhsi->ops->cfhsi_down(cfhsi->ops);\r\nerr_activate:\r\ndestroy_workqueue(cfhsi->wq);\r\nerr_create_wq:\r\nkfree(cfhsi->rx_flip_buf);\r\nerr_alloc_rx_flip:\r\nkfree(cfhsi->rx_buf);\r\nerr_alloc_rx:\r\nkfree(cfhsi->tx_buf);\r\nerr_alloc_tx:\r\nreturn res;\r\n}\r\nstatic int cfhsi_close(struct net_device *ndev)\r\n{\r\nstruct cfhsi *cfhsi = netdev_priv(ndev);\r\nu8 *tx_buf, *rx_buf, *flip_buf;\r\nset_bit(CFHSI_SHUTDOWN, &cfhsi->bits);\r\nflush_workqueue(cfhsi->wq);\r\ndel_timer_sync(&cfhsi->inactivity_timer);\r\ndel_timer_sync(&cfhsi->rx_slowpath_timer);\r\ndel_timer_sync(&cfhsi->aggregation_timer);\r\ncfhsi->ops->cfhsi_rx_cancel(cfhsi->ops);\r\ndestroy_workqueue(cfhsi->wq);\r\ntx_buf = cfhsi->tx_buf;\r\nrx_buf = cfhsi->rx_buf;\r\nflip_buf = cfhsi->rx_flip_buf;\r\ncfhsi_abort_tx(cfhsi);\r\ncfhsi->ops->cfhsi_down(cfhsi->ops);\r\nkfree(tx_buf);\r\nkfree(rx_buf);\r\nkfree(flip_buf);\r\nreturn 0;\r\n}\r\nstatic void cfhsi_uninit(struct net_device *dev)\r\n{\r\nstruct cfhsi *cfhsi = netdev_priv(dev);\r\nASSERT_RTNL();\r\nsymbol_put(cfhsi_get_device);\r\nlist_del(&cfhsi->list);\r\n}\r\nstatic void cfhsi_netlink_parms(struct nlattr *data[], struct cfhsi *cfhsi)\r\n{\r\nint i;\r\nif (!data) {\r\npr_debug("no params data found\n");\r\nreturn;\r\n}\r\ni = __IFLA_CAIF_HSI_INACTIVITY_TOUT;\r\nif (data[i]) {\r\nu32 inactivity_timeout = nla_get_u32(data[i]);\r\ncfhsi->cfg.inactivity_timeout = inactivity_timeout * HZ / 1000;\r\nif (cfhsi->cfg.inactivity_timeout == 0)\r\ncfhsi->cfg.inactivity_timeout = 1;\r\nelse if (cfhsi->cfg.inactivity_timeout > NEXT_TIMER_MAX_DELTA)\r\ncfhsi->cfg.inactivity_timeout = NEXT_TIMER_MAX_DELTA;\r\n}\r\ni = __IFLA_CAIF_HSI_AGGREGATION_TOUT;\r\nif (data[i])\r\ncfhsi->cfg.aggregation_timeout = nla_get_u32(data[i]);\r\ni = __IFLA_CAIF_HSI_HEAD_ALIGN;\r\nif (data[i])\r\ncfhsi->cfg.head_align = nla_get_u32(data[i]);\r\ni = __IFLA_CAIF_HSI_TAIL_ALIGN;\r\nif (data[i])\r\ncfhsi->cfg.tail_align = nla_get_u32(data[i]);\r\ni = __IFLA_CAIF_HSI_QHIGH_WATERMARK;\r\nif (data[i])\r\ncfhsi->cfg.q_high_mark = nla_get_u32(data[i]);\r\ni = __IFLA_CAIF_HSI_QLOW_WATERMARK;\r\nif (data[i])\r\ncfhsi->cfg.q_low_mark = nla_get_u32(data[i]);\r\n}\r\nstatic int caif_hsi_changelink(struct net_device *dev, struct nlattr *tb[],\r\nstruct nlattr *data[])\r\n{\r\ncfhsi_netlink_parms(data, netdev_priv(dev));\r\nnetdev_state_change(dev);\r\nreturn 0;\r\n}\r\nstatic size_t caif_hsi_get_size(const struct net_device *dev)\r\n{\r\nint i;\r\nsize_t s = 0;\r\nfor (i = __IFLA_CAIF_HSI_UNSPEC + 1; i < __IFLA_CAIF_HSI_MAX; i++)\r\ns += nla_total_size(caif_hsi_policy[i].len);\r\nreturn s;\r\n}\r\nstatic int caif_hsi_fill_info(struct sk_buff *skb, const struct net_device *dev)\r\n{\r\nstruct cfhsi *cfhsi = netdev_priv(dev);\r\nif (nla_put_u32(skb, __IFLA_CAIF_HSI_INACTIVITY_TOUT,\r\ncfhsi->cfg.inactivity_timeout) ||\r\nnla_put_u32(skb, __IFLA_CAIF_HSI_AGGREGATION_TOUT,\r\ncfhsi->cfg.aggregation_timeout) ||\r\nnla_put_u32(skb, __IFLA_CAIF_HSI_HEAD_ALIGN,\r\ncfhsi->cfg.head_align) ||\r\nnla_put_u32(skb, __IFLA_CAIF_HSI_TAIL_ALIGN,\r\ncfhsi->cfg.tail_align) ||\r\nnla_put_u32(skb, __IFLA_CAIF_HSI_QHIGH_WATERMARK,\r\ncfhsi->cfg.q_high_mark) ||\r\nnla_put_u32(skb, __IFLA_CAIF_HSI_QLOW_WATERMARK,\r\ncfhsi->cfg.q_low_mark))\r\nreturn -EMSGSIZE;\r\nreturn 0;\r\n}\r\nstatic int caif_hsi_newlink(struct net *src_net, struct net_device *dev,\r\nstruct nlattr *tb[], struct nlattr *data[])\r\n{\r\nstruct cfhsi *cfhsi = NULL;\r\nstruct cfhsi_ops *(*get_ops)(void);\r\nASSERT_RTNL();\r\ncfhsi = netdev_priv(dev);\r\ncfhsi_netlink_parms(data, cfhsi);\r\nget_ops = symbol_get(cfhsi_get_ops);\r\nif (!get_ops) {\r\npr_err("%s: failed to get the cfhsi_ops\n", __func__);\r\nreturn -ENODEV;\r\n}\r\ncfhsi->ops = (*get_ops)();\r\nif (!cfhsi->ops) {\r\npr_err("%s: failed to get the cfhsi_ops\n", __func__);\r\ngoto err;\r\n}\r\ncfhsi->ops->cb_ops = &cfhsi->cb_ops;\r\nif (register_netdevice(dev)) {\r\npr_warn("%s: caif_hsi device registration failed\n", __func__);\r\ngoto err;\r\n}\r\nlist_add_tail(&cfhsi->list, &cfhsi_list);\r\nreturn 0;\r\nerr:\r\nsymbol_put(cfhsi_get_ops);\r\nreturn -ENODEV;\r\n}\r\nstatic void __exit cfhsi_exit_module(void)\r\n{\r\nstruct list_head *list_node;\r\nstruct list_head *n;\r\nstruct cfhsi *cfhsi;\r\nrtnl_link_unregister(&caif_hsi_link_ops);\r\nrtnl_lock();\r\nlist_for_each_safe(list_node, n, &cfhsi_list) {\r\ncfhsi = list_entry(list_node, struct cfhsi, list);\r\nunregister_netdev(cfhsi->ndev);\r\n}\r\nrtnl_unlock();\r\n}\r\nstatic int __init cfhsi_init_module(void)\r\n{\r\nreturn rtnl_link_register(&caif_hsi_link_ops);\r\n}
