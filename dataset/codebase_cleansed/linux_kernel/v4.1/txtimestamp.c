static void __print_timestamp(const char *name, struct timespec *cur,\r\nuint32_t key, int payload_len)\r\n{\r\nif (!(cur->tv_sec | cur->tv_nsec))\r\nreturn;\r\nfprintf(stderr, " %s: %lu s %lu us (seq=%u, len=%u)",\r\nname, cur->tv_sec, cur->tv_nsec / 1000,\r\nkey, payload_len);\r\nif ((ts_prev.tv_sec | ts_prev.tv_nsec)) {\r\nint64_t cur_ms, prev_ms;\r\ncur_ms = (long) cur->tv_sec * 1000 * 1000;\r\ncur_ms += cur->tv_nsec / 1000;\r\nprev_ms = (long) ts_prev.tv_sec * 1000 * 1000;\r\nprev_ms += ts_prev.tv_nsec / 1000;\r\nfprintf(stderr, " (%+ld us)", cur_ms - prev_ms);\r\n}\r\nts_prev = *cur;\r\nfprintf(stderr, "\n");\r\n}\r\nstatic void print_timestamp_usr(void)\r\n{\r\nstruct timespec ts;\r\nstruct timeval tv;\r\ngettimeofday(&tv, NULL);\r\nts.tv_sec = tv.tv_sec;\r\nts.tv_nsec = tv.tv_usec * 1000;\r\n__print_timestamp(" USR", &ts, 0, 0);\r\n}\r\nstatic void print_timestamp(struct scm_timestamping *tss, int tstype,\r\nint tskey, int payload_len)\r\n{\r\nconst char *tsname;\r\nswitch (tstype) {\r\ncase SCM_TSTAMP_SCHED:\r\ntsname = " ENQ";\r\nbreak;\r\ncase SCM_TSTAMP_SND:\r\ntsname = " SND";\r\nbreak;\r\ncase SCM_TSTAMP_ACK:\r\ntsname = " ACK";\r\nbreak;\r\ndefault:\r\nerror(1, 0, "unknown timestamp type: %u",\r\ntstype);\r\n}\r\n__print_timestamp(tsname, &tss->ts[0], tskey, payload_len);\r\n}\r\nstatic void print_payload(char *data, int len)\r\n{\r\nint i;\r\nif (!len)\r\nreturn;\r\nif (len > 70)\r\nlen = 70;\r\nfprintf(stderr, "payload: ");\r\nfor (i = 0; i < len; i++)\r\nfprintf(stderr, "%02hhx ", data[i]);\r\nfprintf(stderr, "\n");\r\n}\r\nstatic void print_pktinfo(int family, int ifindex, void *saddr, void *daddr)\r\n{\r\nchar sa[INET6_ADDRSTRLEN], da[INET6_ADDRSTRLEN];\r\nfprintf(stderr, " pktinfo: ifindex=%u src=%s dst=%s\n",\r\nifindex,\r\nsaddr ? inet_ntop(family, saddr, sa, sizeof(sa)) : "unknown",\r\ndaddr ? inet_ntop(family, daddr, da, sizeof(da)) : "unknown");\r\n}\r\nstatic void __poll(int fd)\r\n{\r\nstruct pollfd pollfd;\r\nint ret;\r\nmemset(&pollfd, 0, sizeof(pollfd));\r\npollfd.fd = fd;\r\nret = poll(&pollfd, 1, 100);\r\nif (ret != 1)\r\nerror(1, errno, "poll");\r\n}\r\nstatic void __recv_errmsg_cmsg(struct msghdr *msg, int payload_len)\r\n{\r\nstruct sock_extended_err *serr = NULL;\r\nstruct scm_timestamping *tss = NULL;\r\nstruct cmsghdr *cm;\r\nint batch = 0;\r\nfor (cm = CMSG_FIRSTHDR(msg);\r\ncm && cm->cmsg_len;\r\ncm = CMSG_NXTHDR(msg, cm)) {\r\nif (cm->cmsg_level == SOL_SOCKET &&\r\ncm->cmsg_type == SCM_TIMESTAMPING) {\r\ntss = (void *) CMSG_DATA(cm);\r\n} else if ((cm->cmsg_level == SOL_IP &&\r\ncm->cmsg_type == IP_RECVERR) ||\r\n(cm->cmsg_level == SOL_IPV6 &&\r\ncm->cmsg_type == IPV6_RECVERR)) {\r\nserr = (void *) CMSG_DATA(cm);\r\nif (serr->ee_errno != ENOMSG ||\r\nserr->ee_origin != SO_EE_ORIGIN_TIMESTAMPING) {\r\nfprintf(stderr, "unknown ip error %d %d\n",\r\nserr->ee_errno,\r\nserr->ee_origin);\r\nserr = NULL;\r\n}\r\n} else if (cm->cmsg_level == SOL_IP &&\r\ncm->cmsg_type == IP_PKTINFO) {\r\nstruct in_pktinfo *info = (void *) CMSG_DATA(cm);\r\nprint_pktinfo(AF_INET, info->ipi_ifindex,\r\n&info->ipi_spec_dst, &info->ipi_addr);\r\n} else if (cm->cmsg_level == SOL_IPV6 &&\r\ncm->cmsg_type == IPV6_PKTINFO) {\r\nstruct in6_pktinfo *info6 = (void *) CMSG_DATA(cm);\r\nprint_pktinfo(AF_INET6, info6->ipi6_ifindex,\r\nNULL, &info6->ipi6_addr);\r\n} else\r\nfprintf(stderr, "unknown cmsg %d,%d\n",\r\ncm->cmsg_level, cm->cmsg_type);\r\nif (serr && tss) {\r\nprint_timestamp(tss, serr->ee_info, serr->ee_data,\r\npayload_len);\r\nserr = NULL;\r\ntss = NULL;\r\nbatch++;\r\n}\r\n}\r\nif (batch > 1)\r\nfprintf(stderr, "batched %d timestamps\n", batch);\r\n}\r\nstatic int recv_errmsg(int fd)\r\n{\r\nstatic char ctrl[1024 ];\r\nstatic struct msghdr msg;\r\nstruct iovec entry;\r\nstatic char *data;\r\nint ret = 0;\r\ndata = malloc(cfg_payload_len);\r\nif (!data)\r\nerror(1, 0, "malloc");\r\nmemset(&msg, 0, sizeof(msg));\r\nmemset(&entry, 0, sizeof(entry));\r\nmemset(ctrl, 0, sizeof(ctrl));\r\nentry.iov_base = data;\r\nentry.iov_len = cfg_payload_len;\r\nmsg.msg_iov = &entry;\r\nmsg.msg_iovlen = 1;\r\nmsg.msg_name = NULL;\r\nmsg.msg_namelen = 0;\r\nmsg.msg_control = ctrl;\r\nmsg.msg_controllen = sizeof(ctrl);\r\nret = recvmsg(fd, &msg, MSG_ERRQUEUE);\r\nif (ret == -1 && errno != EAGAIN)\r\nerror(1, errno, "recvmsg");\r\nif (ret >= 0) {\r\n__recv_errmsg_cmsg(&msg, ret);\r\nif (cfg_show_payload)\r\nprint_payload(data, cfg_payload_len);\r\n}\r\nfree(data);\r\nreturn ret == -1;\r\n}\r\nstatic void do_test(int family, unsigned int opt)\r\n{\r\nchar *buf;\r\nint fd, i, val = 1, total_len;\r\nif (family == AF_INET6 && cfg_proto != SOCK_STREAM) {\r\nfprintf(stderr, "test: skipping datagram over IPv6\n");\r\nreturn;\r\n}\r\ntotal_len = cfg_payload_len;\r\nif (cfg_proto == SOCK_RAW) {\r\ntotal_len += sizeof(struct udphdr);\r\nif (cfg_ipproto == IPPROTO_RAW)\r\ntotal_len += sizeof(struct iphdr);\r\n}\r\nbuf = malloc(total_len);\r\nif (!buf)\r\nerror(1, 0, "malloc");\r\nfd = socket(family, cfg_proto, cfg_ipproto);\r\nif (fd < 0)\r\nerror(1, errno, "socket");\r\nif (cfg_proto == SOCK_STREAM) {\r\nif (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY,\r\n(char*) &val, sizeof(val)))\r\nerror(1, 0, "setsockopt no nagle");\r\nif (family == PF_INET) {\r\nif (connect(fd, (void *) &daddr, sizeof(daddr)))\r\nerror(1, errno, "connect ipv4");\r\n} else {\r\nif (connect(fd, (void *) &daddr6, sizeof(daddr6)))\r\nerror(1, errno, "connect ipv6");\r\n}\r\n}\r\nif (cfg_do_pktinfo) {\r\nif (family == AF_INET6) {\r\nif (setsockopt(fd, SOL_IPV6, IPV6_RECVPKTINFO,\r\n&val, sizeof(val)))\r\nerror(1, errno, "setsockopt pktinfo ipv6");\r\n} else {\r\nif (setsockopt(fd, SOL_IP, IP_PKTINFO,\r\n&val, sizeof(val)))\r\nerror(1, errno, "setsockopt pktinfo ipv4");\r\n}\r\n}\r\nopt |= SOF_TIMESTAMPING_SOFTWARE |\r\nSOF_TIMESTAMPING_OPT_CMSG |\r\nSOF_TIMESTAMPING_OPT_ID;\r\nif (cfg_loop_nodata)\r\nopt |= SOF_TIMESTAMPING_OPT_TSONLY;\r\nif (setsockopt(fd, SOL_SOCKET, SO_TIMESTAMPING,\r\n(char *) &opt, sizeof(opt)))\r\nerror(1, 0, "setsockopt timestamping");\r\nfor (i = 0; i < cfg_num_pkts; i++) {\r\nmemset(&ts_prev, 0, sizeof(ts_prev));\r\nmemset(buf, 'a' + i, total_len);\r\nif (cfg_proto == SOCK_RAW) {\r\nstruct udphdr *udph;\r\nint off = 0;\r\nif (cfg_ipproto == IPPROTO_RAW) {\r\nstruct iphdr *iph = (void *) buf;\r\nmemset(iph, 0, sizeof(*iph));\r\niph->ihl = 5;\r\niph->version = 4;\r\niph->ttl = 2;\r\niph->daddr = daddr.sin_addr.s_addr;\r\niph->protocol = IPPROTO_UDP;\r\noff = sizeof(*iph);\r\n}\r\nudph = (void *) buf + off;\r\nudph->source = ntohs(9000);\r\nudph->dest = ntohs(dest_port);\r\nudph->len = ntohs(sizeof(*udph) + cfg_payload_len);\r\nudph->check = 0;\r\n}\r\nprint_timestamp_usr();\r\nif (cfg_proto != SOCK_STREAM) {\r\nif (family == PF_INET)\r\nval = sendto(fd, buf, total_len, 0, (void *) &daddr, sizeof(daddr));\r\nelse\r\nval = sendto(fd, buf, total_len, 0, (void *) &daddr6, sizeof(daddr6));\r\n} else {\r\nval = send(fd, buf, cfg_payload_len, 0);\r\n}\r\nif (val != total_len)\r\nerror(1, errno, "send");\r\nusleep(50 * 1000);\r\n__poll(fd);\r\nwhile (!recv_errmsg(fd)) {}\r\n}\r\nif (close(fd))\r\nerror(1, errno, "close");\r\nfree(buf);\r\nusleep(400 * 1000);\r\n}\r\nstatic void parse_opt(int argc, char **argv)\r\n{\r\nint proto_count = 0;\r\nchar c;\r\nwhile ((c = getopt(argc, argv, "46hIl:np:rRux")) != -1) {\r\nswitch (c) {\r\ncase '4':\r\ndo_ipv6 = 0;\r\nbreak;\r\ncase '6':\r\ndo_ipv4 = 0;\r\nbreak;\r\ncase 'I':\r\ncfg_do_pktinfo = true;\r\nbreak;\r\ncase 'n':\r\ncfg_loop_nodata = true;\r\nbreak;\r\ncase 'r':\r\nproto_count++;\r\ncfg_proto = SOCK_RAW;\r\ncfg_ipproto = IPPROTO_UDP;\r\nbreak;\r\ncase 'R':\r\nproto_count++;\r\ncfg_proto = SOCK_RAW;\r\ncfg_ipproto = IPPROTO_RAW;\r\nbreak;\r\ncase 'u':\r\nproto_count++;\r\ncfg_proto = SOCK_DGRAM;\r\ncfg_ipproto = IPPROTO_UDP;\r\nbreak;\r\ncase 'l':\r\ncfg_payload_len = strtoul(optarg, NULL, 10);\r\nbreak;\r\ncase 'p':\r\ndest_port = strtoul(optarg, NULL, 10);\r\nbreak;\r\ncase 'x':\r\ncfg_show_payload = true;\r\nbreak;\r\ncase 'h':\r\ndefault:\r\nusage(argv[0]);\r\n}\r\n}\r\nif (!cfg_payload_len)\r\nerror(1, 0, "payload may not be nonzero");\r\nif (cfg_proto != SOCK_STREAM && cfg_payload_len > 1472)\r\nerror(1, 0, "udp packet might exceed expected MTU");\r\nif (!do_ipv4 && !do_ipv6)\r\nerror(1, 0, "pass -4 or -6, not both");\r\nif (proto_count > 1)\r\nerror(1, 0, "pass -r, -R or -u, not multiple");\r\nif (optind != argc - 1)\r\nerror(1, 0, "missing required hostname argument");\r\n}\r\nstatic void resolve_hostname(const char *hostname)\r\n{\r\nstruct addrinfo *addrs, *cur;\r\nint have_ipv4 = 0, have_ipv6 = 0;\r\nif (getaddrinfo(hostname, NULL, NULL, &addrs))\r\nerror(1, errno, "getaddrinfo");\r\ncur = addrs;\r\nwhile (cur && !have_ipv4 && !have_ipv6) {\r\nif (!have_ipv4 && cur->ai_family == AF_INET) {\r\nmemcpy(&daddr, cur->ai_addr, sizeof(daddr));\r\ndaddr.sin_port = htons(dest_port);\r\nhave_ipv4 = 1;\r\n}\r\nelse if (!have_ipv6 && cur->ai_family == AF_INET6) {\r\nmemcpy(&daddr6, cur->ai_addr, sizeof(daddr6));\r\ndaddr6.sin6_port = htons(dest_port);\r\nhave_ipv6 = 1;\r\n}\r\ncur = cur->ai_next;\r\n}\r\nif (addrs)\r\nfreeaddrinfo(addrs);\r\ndo_ipv4 &= have_ipv4;\r\ndo_ipv6 &= have_ipv6;\r\n}\r\nstatic void do_main(int family)\r\n{\r\nfprintf(stderr, "family: %s\n",\r\nfamily == PF_INET ? "INET" : "INET6");\r\nfprintf(stderr, "test SND\n");\r\ndo_test(family, SOF_TIMESTAMPING_TX_SOFTWARE);\r\nfprintf(stderr, "test ENQ\n");\r\ndo_test(family, SOF_TIMESTAMPING_TX_SCHED);\r\nfprintf(stderr, "test ENQ + SND\n");\r\ndo_test(family, SOF_TIMESTAMPING_TX_SCHED |\r\nSOF_TIMESTAMPING_TX_SOFTWARE);\r\nif (cfg_proto == SOCK_STREAM) {\r\nfprintf(stderr, "\ntest ACK\n");\r\ndo_test(family, SOF_TIMESTAMPING_TX_ACK);\r\nfprintf(stderr, "\ntest SND + ACK\n");\r\ndo_test(family, SOF_TIMESTAMPING_TX_SOFTWARE |\r\nSOF_TIMESTAMPING_TX_ACK);\r\nfprintf(stderr, "\ntest ENQ + SND + ACK\n");\r\ndo_test(family, SOF_TIMESTAMPING_TX_SCHED |\r\nSOF_TIMESTAMPING_TX_SOFTWARE |\r\nSOF_TIMESTAMPING_TX_ACK);\r\n}\r\n}\r\nint main(int argc, char **argv)\r\n{\r\nif (argc == 1)\r\nusage(argv[0]);\r\nparse_opt(argc, argv);\r\nresolve_hostname(argv[argc - 1]);\r\nfprintf(stderr, "protocol: %s\n", sock_names[cfg_proto]);\r\nfprintf(stderr, "payload: %u\n", cfg_payload_len);\r\nfprintf(stderr, "server port: %u\n", dest_port);\r\nfprintf(stderr, "\n");\r\nif (do_ipv4)\r\ndo_main(PF_INET);\r\nif (do_ipv6)\r\ndo_main(PF_INET6);\r\nreturn 0;\r\n}
