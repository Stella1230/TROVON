static inline void pch_setbit(void __iomem *addr, u32 offset, u32 bitmask)\r\n{\r\nu32 val;\r\nval = ioread32(addr + offset);\r\nval |= bitmask;\r\niowrite32(val, addr + offset);\r\n}\r\nstatic inline void pch_clrbit(void __iomem *addr, u32 offset, u32 bitmask)\r\n{\r\nu32 val;\r\nval = ioread32(addr + offset);\r\nval &= (~bitmask);\r\niowrite32(val, addr + offset);\r\n}\r\nstatic void pch_i2c_init(struct i2c_algo_pch_data *adap)\r\n{\r\nvoid __iomem *p = adap->pch_base_address;\r\nu32 pch_i2cbc;\r\nu32 pch_i2ctmr;\r\nu32 reg_value;\r\niowrite32(0x01, p + PCH_I2CSRST);\r\nmsleep(20);\r\niowrite32(0x0, p + PCH_I2CSRST);\r\niowrite32(0x21, p + PCH_I2CNF);\r\npch_setbit(adap->pch_base_address, PCH_I2CCTL, PCH_I2CCTL_I2CMEN);\r\nif (pch_i2c_speed != 400)\r\npch_i2c_speed = 100;\r\nreg_value = PCH_I2CCTL_I2CMEN;\r\nif (pch_i2c_speed == FAST_MODE_CLK) {\r\nreg_value |= FAST_MODE_EN;\r\npch_dbg(adap, "Fast mode enabled\n");\r\n}\r\nif (pch_clk > PCH_MAX_CLK)\r\npch_clk = 62500;\r\npch_i2cbc = (pch_clk + (pch_i2c_speed * 4)) / (pch_i2c_speed * 8);\r\niowrite32(pch_i2cbc, p + PCH_I2CBC);\r\npch_i2ctmr = (pch_clk) / 8;\r\niowrite32(pch_i2ctmr, p + PCH_I2CTMR);\r\nreg_value |= NORMAL_INTR_ENBL;\r\niowrite32(reg_value, p + PCH_I2CCTL);\r\npch_dbg(adap,\r\n"I2CCTL=%x pch_i2cbc=%x pch_i2ctmr=%x Enable interrupts\n",\r\nioread32(p + PCH_I2CCTL), pch_i2cbc, pch_i2ctmr);\r\ninit_waitqueue_head(&pch_event);\r\n}\r\nstatic s32 pch_i2c_wait_for_bus_idle(struct i2c_algo_pch_data *adap,\r\ns32 timeout)\r\n{\r\nvoid __iomem *p = adap->pch_base_address;\r\nint schedule = 0;\r\nunsigned long end = jiffies + msecs_to_jiffies(timeout);\r\nwhile (ioread32(p + PCH_I2CSR) & I2CMBB_BIT) {\r\nif (time_after(jiffies, end)) {\r\npch_dbg(adap, "I2CSR = %x\n", ioread32(p + PCH_I2CSR));\r\npch_err(adap, "%s: Timeout Error.return%d\n",\r\n__func__, -ETIME);\r\npch_i2c_init(adap);\r\nreturn -ETIME;\r\n}\r\nif (!schedule)\r\nudelay(5);\r\nelse\r\nusleep_range(20, 1000);\r\nschedule = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void pch_i2c_start(struct i2c_algo_pch_data *adap)\r\n{\r\nvoid __iomem *p = adap->pch_base_address;\r\npch_dbg(adap, "I2CCTL = %x\n", ioread32(p + PCH_I2CCTL));\r\npch_setbit(adap->pch_base_address, PCH_I2CCTL, PCH_START);\r\n}\r\nstatic void pch_i2c_stop(struct i2c_algo_pch_data *adap)\r\n{\r\nvoid __iomem *p = adap->pch_base_address;\r\npch_dbg(adap, "I2CCTL = %x\n", ioread32(p + PCH_I2CCTL));\r\npch_clrbit(adap->pch_base_address, PCH_I2CCTL, PCH_START);\r\n}\r\nstatic int pch_i2c_wait_for_check_xfer(struct i2c_algo_pch_data *adap)\r\n{\r\nlong ret;\r\nvoid __iomem *p = adap->pch_base_address;\r\nret = wait_event_timeout(pch_event,\r\n(adap->pch_event_flag != 0), msecs_to_jiffies(1000));\r\nif (!ret) {\r\npch_err(adap, "%s:wait-event timeout\n", __func__);\r\nadap->pch_event_flag = 0;\r\npch_i2c_stop(adap);\r\npch_i2c_init(adap);\r\nreturn -ETIMEDOUT;\r\n}\r\nif (adap->pch_event_flag & I2C_ERROR_MASK) {\r\npch_err(adap, "Lost Arbitration\n");\r\nadap->pch_event_flag = 0;\r\npch_clrbit(adap->pch_base_address, PCH_I2CSR, I2CMAL_BIT);\r\npch_clrbit(adap->pch_base_address, PCH_I2CSR, I2CMIF_BIT);\r\npch_i2c_init(adap);\r\nreturn -EAGAIN;\r\n}\r\nadap->pch_event_flag = 0;\r\nif (ioread32(p + PCH_I2CSR) & PCH_GETACK) {\r\npch_dbg(adap, "Receive NACK for slave address setting\n");\r\nreturn -ENXIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void pch_i2c_repstart(struct i2c_algo_pch_data *adap)\r\n{\r\nvoid __iomem *p = adap->pch_base_address;\r\npch_dbg(adap, "I2CCTL = %x\n", ioread32(p + PCH_I2CCTL));\r\npch_setbit(adap->pch_base_address, PCH_I2CCTL, PCH_REPSTART);\r\n}\r\nstatic s32 pch_i2c_writebytes(struct i2c_adapter *i2c_adap,\r\nstruct i2c_msg *msgs, u32 last, u32 first)\r\n{\r\nstruct i2c_algo_pch_data *adap = i2c_adap->algo_data;\r\nu8 *buf;\r\nu32 length;\r\nu32 addr;\r\nu32 addr_2_msb;\r\nu32 addr_8_lsb;\r\ns32 wrcount;\r\ns32 rtn;\r\nvoid __iomem *p = adap->pch_base_address;\r\nlength = msgs->len;\r\nbuf = msgs->buf;\r\naddr = msgs->addr;\r\npch_setbit(adap->pch_base_address, PCH_I2CCTL, I2C_TX_MODE);\r\npch_dbg(adap, "I2CCTL = %x msgs->len = %d\n", ioread32(p + PCH_I2CCTL),\r\nlength);\r\nif (first) {\r\nif (pch_i2c_wait_for_bus_idle(adap, BUS_IDLE_TIMEOUT) == -ETIME)\r\nreturn -ETIME;\r\n}\r\nif (msgs->flags & I2C_M_TEN) {\r\naddr_2_msb = ((addr & I2C_MSB_2B_MSK) >> 7) & 0x06;\r\niowrite32(addr_2_msb | TEN_BIT_ADDR_MASK, p + PCH_I2CDR);\r\nif (first)\r\npch_i2c_start(adap);\r\nrtn = pch_i2c_wait_for_check_xfer(adap);\r\nif (rtn)\r\nreturn rtn;\r\naddr_8_lsb = (addr & I2C_ADDR_MSK);\r\niowrite32(addr_8_lsb, p + PCH_I2CDR);\r\n} else {\r\niowrite32(addr << 1, p + PCH_I2CDR);\r\nif (first)\r\npch_i2c_start(adap);\r\n}\r\nrtn = pch_i2c_wait_for_check_xfer(adap);\r\nif (rtn)\r\nreturn rtn;\r\nfor (wrcount = 0; wrcount < length; ++wrcount) {\r\niowrite32(buf[wrcount], p + PCH_I2CDR);\r\npch_dbg(adap, "writing %x to Data register\n", buf[wrcount]);\r\nrtn = pch_i2c_wait_for_check_xfer(adap);\r\nif (rtn)\r\nreturn rtn;\r\npch_clrbit(adap->pch_base_address, PCH_I2CSR, I2CMCF_BIT);\r\npch_clrbit(adap->pch_base_address, PCH_I2CSR, I2CMIF_BIT);\r\n}\r\nif (last)\r\npch_i2c_stop(adap);\r\nelse\r\npch_i2c_repstart(adap);\r\npch_dbg(adap, "return=%d\n", wrcount);\r\nreturn wrcount;\r\n}\r\nstatic void pch_i2c_sendack(struct i2c_algo_pch_data *adap)\r\n{\r\nvoid __iomem *p = adap->pch_base_address;\r\npch_dbg(adap, "I2CCTL = %x\n", ioread32(p + PCH_I2CCTL));\r\npch_clrbit(adap->pch_base_address, PCH_I2CCTL, PCH_ACK);\r\n}\r\nstatic void pch_i2c_sendnack(struct i2c_algo_pch_data *adap)\r\n{\r\nvoid __iomem *p = adap->pch_base_address;\r\npch_dbg(adap, "I2CCTL = %x\n", ioread32(p + PCH_I2CCTL));\r\npch_setbit(adap->pch_base_address, PCH_I2CCTL, PCH_ACK);\r\n}\r\nstatic void pch_i2c_restart(struct i2c_algo_pch_data *adap)\r\n{\r\nvoid __iomem *p = adap->pch_base_address;\r\npch_dbg(adap, "I2CCTL = %x\n", ioread32(p + PCH_I2CCTL));\r\npch_setbit(adap->pch_base_address, PCH_I2CCTL, PCH_RESTART);\r\n}\r\nstatic s32 pch_i2c_readbytes(struct i2c_adapter *i2c_adap, struct i2c_msg *msgs,\r\nu32 last, u32 first)\r\n{\r\nstruct i2c_algo_pch_data *adap = i2c_adap->algo_data;\r\nu8 *buf;\r\nu32 count;\r\nu32 length;\r\nu32 addr;\r\nu32 addr_2_msb;\r\nu32 addr_8_lsb;\r\nvoid __iomem *p = adap->pch_base_address;\r\ns32 rtn;\r\nlength = msgs->len;\r\nbuf = msgs->buf;\r\naddr = msgs->addr;\r\npch_clrbit(adap->pch_base_address, PCH_I2CCTL, I2C_TX_MODE);\r\nif (first) {\r\nif (pch_i2c_wait_for_bus_idle(adap, BUS_IDLE_TIMEOUT) == -ETIME)\r\nreturn -ETIME;\r\n}\r\nif (msgs->flags & I2C_M_TEN) {\r\naddr_2_msb = ((addr & I2C_MSB_2B_MSK) >> 7);\r\niowrite32(addr_2_msb | TEN_BIT_ADDR_MASK, p + PCH_I2CDR);\r\nif (first)\r\npch_i2c_start(adap);\r\nrtn = pch_i2c_wait_for_check_xfer(adap);\r\nif (rtn)\r\nreturn rtn;\r\naddr_8_lsb = (addr & I2C_ADDR_MSK);\r\niowrite32(addr_8_lsb, p + PCH_I2CDR);\r\npch_i2c_restart(adap);\r\nrtn = pch_i2c_wait_for_check_xfer(adap);\r\nif (rtn)\r\nreturn rtn;\r\naddr_2_msb |= I2C_RD;\r\niowrite32(addr_2_msb | TEN_BIT_ADDR_MASK, p + PCH_I2CDR);\r\n} else {\r\naddr = (((addr) << 1) | (I2C_RD));\r\niowrite32(addr, p + PCH_I2CDR);\r\n}\r\nif (first)\r\npch_i2c_start(adap);\r\nrtn = pch_i2c_wait_for_check_xfer(adap);\r\nif (rtn)\r\nreturn rtn;\r\nif (length == 0) {\r\npch_i2c_stop(adap);\r\nioread32(p + PCH_I2CDR);\r\ncount = length;\r\n} else {\r\nint read_index;\r\nint loop;\r\npch_i2c_sendack(adap);\r\nfor (loop = 1, read_index = 0; loop < length; loop++) {\r\nbuf[read_index] = ioread32(p + PCH_I2CDR);\r\nif (loop != 1)\r\nread_index++;\r\nrtn = pch_i2c_wait_for_check_xfer(adap);\r\nif (rtn)\r\nreturn rtn;\r\n}\r\npch_i2c_sendnack(adap);\r\nbuf[read_index] = ioread32(p + PCH_I2CDR);\r\nif (length != 1)\r\nread_index++;\r\nrtn = pch_i2c_wait_for_check_xfer(adap);\r\nif (rtn)\r\nreturn rtn;\r\nif (last)\r\npch_i2c_stop(adap);\r\nelse\r\npch_i2c_repstart(adap);\r\nbuf[read_index++] = ioread32(p + PCH_I2CDR);\r\ncount = read_index;\r\n}\r\nreturn count;\r\n}\r\nstatic void pch_i2c_cb(struct i2c_algo_pch_data *adap)\r\n{\r\nu32 sts;\r\nvoid __iomem *p = adap->pch_base_address;\r\nsts = ioread32(p + PCH_I2CSR);\r\nsts &= (I2CMAL_BIT | I2CMCF_BIT | I2CMIF_BIT);\r\nif (sts & I2CMAL_BIT)\r\nadap->pch_event_flag |= I2CMAL_EVENT;\r\nif (sts & I2CMCF_BIT)\r\nadap->pch_event_flag |= I2CMCF_EVENT;\r\npch_clrbit(adap->pch_base_address, PCH_I2CSR, sts);\r\npch_dbg(adap, "PCH_I2CSR = %x\n", ioread32(p + PCH_I2CSR));\r\nwake_up(&pch_event);\r\n}\r\nstatic irqreturn_t pch_i2c_handler(int irq, void *pData)\r\n{\r\nu32 reg_val;\r\nint flag;\r\nint i;\r\nstruct adapter_info *adap_info = pData;\r\nvoid __iomem *p;\r\nu32 mode;\r\nfor (i = 0, flag = 0; i < adap_info->ch_num; i++) {\r\np = adap_info->pch_data[i].pch_base_address;\r\nmode = ioread32(p + PCH_I2CMOD);\r\nmode &= BUFFER_MODE | EEPROM_SR_MODE;\r\nif (mode != NORMAL_MODE) {\r\npch_err(adap_info->pch_data,\r\n"I2C-%d mode(%d) is not supported\n", mode, i);\r\ncontinue;\r\n}\r\nreg_val = ioread32(p + PCH_I2CSR);\r\nif (reg_val & (I2CMAL_BIT | I2CMCF_BIT | I2CMIF_BIT)) {\r\npch_i2c_cb(&adap_info->pch_data[i]);\r\nflag = 1;\r\n}\r\n}\r\nreturn flag ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic s32 pch_i2c_xfer(struct i2c_adapter *i2c_adap,\r\nstruct i2c_msg *msgs, s32 num)\r\n{\r\nstruct i2c_msg *pmsg;\r\nu32 i = 0;\r\nu32 status;\r\ns32 ret;\r\nstruct i2c_algo_pch_data *adap = i2c_adap->algo_data;\r\nret = mutex_lock_interruptible(&pch_mutex);\r\nif (ret)\r\nreturn ret;\r\nif (adap->p_adapter_info->pch_i2c_suspended) {\r\nmutex_unlock(&pch_mutex);\r\nreturn -EBUSY;\r\n}\r\npch_dbg(adap, "adap->p_adapter_info->pch_i2c_suspended is %d\n",\r\nadap->p_adapter_info->pch_i2c_suspended);\r\nadap->pch_i2c_xfer_in_progress = true;\r\nfor (i = 0; i < num && ret >= 0; i++) {\r\npmsg = &msgs[i];\r\npmsg->flags |= adap->pch_buff_mode_en;\r\nstatus = pmsg->flags;\r\npch_dbg(adap,\r\n"After invoking I2C_MODE_SEL :flag= 0x%x\n", status);\r\nif ((status & (I2C_M_RD)) != false) {\r\nret = pch_i2c_readbytes(i2c_adap, pmsg, (i + 1 == num),\r\n(i == 0));\r\n} else {\r\nret = pch_i2c_writebytes(i2c_adap, pmsg, (i + 1 == num),\r\n(i == 0));\r\n}\r\n}\r\nadap->pch_i2c_xfer_in_progress = false;\r\nmutex_unlock(&pch_mutex);\r\nreturn (ret < 0) ? ret : num;\r\n}\r\nstatic u32 pch_i2c_func(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_10BIT_ADDR;\r\n}\r\nstatic void pch_i2c_disbl_int(struct i2c_algo_pch_data *adap)\r\n{\r\nvoid __iomem *p = adap->pch_base_address;\r\npch_clrbit(adap->pch_base_address, PCH_I2CCTL, NORMAL_INTR_ENBL);\r\niowrite32(EEPROM_RST_INTR_DISBL, p + PCH_I2CESRMSK);\r\niowrite32(BUFFER_MODE_INTR_DISBL, p + PCH_I2CBUFMSK);\r\n}\r\nstatic int pch_i2c_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nvoid __iomem *base_addr;\r\nint ret;\r\nint i, j;\r\nstruct adapter_info *adap_info;\r\nstruct i2c_adapter *pch_adap;\r\npch_pci_dbg(pdev, "Entered.\n");\r\nadap_info = kzalloc((sizeof(struct adapter_info)), GFP_KERNEL);\r\nif (adap_info == NULL)\r\nreturn -ENOMEM;\r\nret = pci_enable_device(pdev);\r\nif (ret) {\r\npch_pci_err(pdev, "pci_enable_device FAILED\n");\r\ngoto err_pci_enable;\r\n}\r\nret = pci_request_regions(pdev, KBUILD_MODNAME);\r\nif (ret) {\r\npch_pci_err(pdev, "pci_request_regions FAILED\n");\r\ngoto err_pci_req;\r\n}\r\nbase_addr = pci_iomap(pdev, 1, 0);\r\nif (base_addr == NULL) {\r\npch_pci_err(pdev, "pci_iomap FAILED\n");\r\nret = -ENOMEM;\r\ngoto err_pci_iomap;\r\n}\r\nadap_info->ch_num = id->driver_data;\r\nret = request_irq(pdev->irq, pch_i2c_handler, IRQF_SHARED,\r\nKBUILD_MODNAME, adap_info);\r\nif (ret) {\r\npch_pci_err(pdev, "request_irq FAILED\n");\r\ngoto err_request_irq;\r\n}\r\nfor (i = 0; i < adap_info->ch_num; i++) {\r\npch_adap = &adap_info->pch_data[i].pch_adapter;\r\nadap_info->pch_i2c_suspended = false;\r\nadap_info->pch_data[i].p_adapter_info = adap_info;\r\npch_adap->owner = THIS_MODULE;\r\npch_adap->class = I2C_CLASS_HWMON;\r\nstrlcpy(pch_adap->name, KBUILD_MODNAME, sizeof(pch_adap->name));\r\npch_adap->algo = &pch_algorithm;\r\npch_adap->algo_data = &adap_info->pch_data[i];\r\nadap_info->pch_data[i].pch_base_address = base_addr + 0x100 * i;\r\npch_adap->dev.parent = &pdev->dev;\r\npch_i2c_init(&adap_info->pch_data[i]);\r\npch_adap->nr = i;\r\nret = i2c_add_numbered_adapter(pch_adap);\r\nif (ret) {\r\npch_pci_err(pdev, "i2c_add_adapter[ch:%d] FAILED\n", i);\r\ngoto err_add_adapter;\r\n}\r\n}\r\npci_set_drvdata(pdev, adap_info);\r\npch_pci_dbg(pdev, "returns %d.\n", ret);\r\nreturn 0;\r\nerr_add_adapter:\r\nfor (j = 0; j < i; j++)\r\ni2c_del_adapter(&adap_info->pch_data[j].pch_adapter);\r\nfree_irq(pdev->irq, adap_info);\r\nerr_request_irq:\r\npci_iounmap(pdev, base_addr);\r\nerr_pci_iomap:\r\npci_release_regions(pdev);\r\nerr_pci_req:\r\npci_disable_device(pdev);\r\nerr_pci_enable:\r\nkfree(adap_info);\r\nreturn ret;\r\n}\r\nstatic void pch_i2c_remove(struct pci_dev *pdev)\r\n{\r\nint i;\r\nstruct adapter_info *adap_info = pci_get_drvdata(pdev);\r\nfree_irq(pdev->irq, adap_info);\r\nfor (i = 0; i < adap_info->ch_num; i++) {\r\npch_i2c_disbl_int(&adap_info->pch_data[i]);\r\ni2c_del_adapter(&adap_info->pch_data[i].pch_adapter);\r\n}\r\nif (adap_info->pch_data[0].pch_base_address)\r\npci_iounmap(pdev, adap_info->pch_data[0].pch_base_address);\r\nfor (i = 0; i < adap_info->ch_num; i++)\r\nadap_info->pch_data[i].pch_base_address = NULL;\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\nkfree(adap_info);\r\n}\r\nstatic int pch_i2c_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nint ret;\r\nint i;\r\nstruct adapter_info *adap_info = pci_get_drvdata(pdev);\r\nvoid __iomem *p = adap_info->pch_data[0].pch_base_address;\r\nadap_info->pch_i2c_suspended = true;\r\nfor (i = 0; i < adap_info->ch_num; i++) {\r\nwhile ((adap_info->pch_data[i].pch_i2c_xfer_in_progress)) {\r\nmsleep(20);\r\n}\r\n}\r\nfor (i = 0; i < adap_info->ch_num; i++)\r\npch_i2c_disbl_int(&adap_info->pch_data[i]);\r\npch_pci_dbg(pdev, "I2CSR = %x I2CBUFSTA = %x I2CESRSTA = %x "\r\n"invoked function pch_i2c_disbl_int successfully\n",\r\nioread32(p + PCH_I2CSR), ioread32(p + PCH_I2CBUFSTA),\r\nioread32(p + PCH_I2CESRSTA));\r\nret = pci_save_state(pdev);\r\nif (ret) {\r\npch_pci_err(pdev, "pci_save_state\n");\r\nreturn ret;\r\n}\r\npci_enable_wake(pdev, PCI_D3hot, 0);\r\npci_disable_device(pdev);\r\npci_set_power_state(pdev, pci_choose_state(pdev, state));\r\nreturn 0;\r\n}\r\nstatic int pch_i2c_resume(struct pci_dev *pdev)\r\n{\r\nint i;\r\nstruct adapter_info *adap_info = pci_get_drvdata(pdev);\r\npci_set_power_state(pdev, PCI_D0);\r\npci_restore_state(pdev);\r\nif (pci_enable_device(pdev) < 0) {\r\npch_pci_err(pdev, "pch_i2c_resume:pci_enable_device FAILED\n");\r\nreturn -EIO;\r\n}\r\npci_enable_wake(pdev, PCI_D3hot, 0);\r\nfor (i = 0; i < adap_info->ch_num; i++)\r\npch_i2c_init(&adap_info->pch_data[i]);\r\nadap_info->pch_i2c_suspended = false;\r\nreturn 0;\r\n}
