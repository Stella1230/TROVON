static irqreturn_t clk_master_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct clk_master *master = (struct clk_master *)dev_id;\r\nwake_up(&master->wait);\r\ndisable_irq_nosync(master->irq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int clk_master_prepare(struct clk_hw *hw)\r\n{\r\nstruct clk_master *master = to_clk_master(hw);\r\nstruct at91_pmc *pmc = master->pmc;\r\nwhile (!(pmc_read(pmc, AT91_PMC_SR) & AT91_PMC_MCKRDY)) {\r\nenable_irq(master->irq);\r\nwait_event(master->wait,\r\npmc_read(pmc, AT91_PMC_SR) & AT91_PMC_MCKRDY);\r\n}\r\nreturn 0;\r\n}\r\nstatic int clk_master_is_prepared(struct clk_hw *hw)\r\n{\r\nstruct clk_master *master = to_clk_master(hw);\r\nreturn !!(pmc_read(master->pmc, AT91_PMC_SR) & AT91_PMC_MCKRDY);\r\n}\r\nstatic unsigned long clk_master_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nu8 pres;\r\nu8 div;\r\nunsigned long rate = parent_rate;\r\nstruct clk_master *master = to_clk_master(hw);\r\nstruct at91_pmc *pmc = master->pmc;\r\nconst struct clk_master_layout *layout = master->layout;\r\nconst struct clk_master_characteristics *characteristics =\r\nmaster->characteristics;\r\nu32 tmp;\r\npmc_lock(pmc);\r\ntmp = pmc_read(pmc, AT91_PMC_MCKR) & layout->mask;\r\npmc_unlock(pmc);\r\npres = (tmp >> layout->pres_shift) & MASTER_PRES_MASK;\r\ndiv = (tmp >> MASTER_DIV_SHIFT) & MASTER_DIV_MASK;\r\nif (characteristics->have_div3_pres && pres == MASTER_PRES_MAX)\r\nrate /= 3;\r\nelse\r\nrate >>= pres;\r\nrate /= characteristics->divisors[div];\r\nif (rate < characteristics->output.min)\r\npr_warn("master clk is underclocked");\r\nelse if (rate > characteristics->output.max)\r\npr_warn("master clk is overclocked");\r\nreturn rate;\r\n}\r\nstatic u8 clk_master_get_parent(struct clk_hw *hw)\r\n{\r\nstruct clk_master *master = to_clk_master(hw);\r\nstruct at91_pmc *pmc = master->pmc;\r\nreturn pmc_read(pmc, AT91_PMC_MCKR) & AT91_PMC_CSS;\r\n}\r\nstatic struct clk * __init\r\nat91_clk_register_master(struct at91_pmc *pmc, unsigned int irq,\r\nconst char *name, int num_parents,\r\nconst char **parent_names,\r\nconst struct clk_master_layout *layout,\r\nconst struct clk_master_characteristics *characteristics)\r\n{\r\nint ret;\r\nstruct clk_master *master;\r\nstruct clk *clk = NULL;\r\nstruct clk_init_data init;\r\nif (!pmc || !irq || !name || !num_parents || !parent_names)\r\nreturn ERR_PTR(-EINVAL);\r\nmaster = kzalloc(sizeof(*master), GFP_KERNEL);\r\nif (!master)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = name;\r\ninit.ops = &master_ops;\r\ninit.parent_names = parent_names;\r\ninit.num_parents = num_parents;\r\ninit.flags = 0;\r\nmaster->hw.init = &init;\r\nmaster->layout = layout;\r\nmaster->characteristics = characteristics;\r\nmaster->pmc = pmc;\r\nmaster->irq = irq;\r\ninit_waitqueue_head(&master->wait);\r\nirq_set_status_flags(master->irq, IRQ_NOAUTOEN);\r\nret = request_irq(master->irq, clk_master_irq_handler,\r\nIRQF_TRIGGER_HIGH, "clk-master", master);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\nclk = clk_register(NULL, &master->hw);\r\nif (IS_ERR(clk))\r\nkfree(master);\r\nreturn clk;\r\n}\r\nstatic struct clk_master_characteristics * __init\r\nof_at91_clk_master_get_characteristics(struct device_node *np)\r\n{\r\nstruct clk_master_characteristics *characteristics;\r\ncharacteristics = kzalloc(sizeof(*characteristics), GFP_KERNEL);\r\nif (!characteristics)\r\nreturn NULL;\r\nif (of_at91_get_clk_range(np, "atmel,clk-output-range", &characteristics->output))\r\ngoto out_free_characteristics;\r\nof_property_read_u32_array(np, "atmel,clk-divisors",\r\ncharacteristics->divisors, 4);\r\ncharacteristics->have_div3_pres =\r\nof_property_read_bool(np, "atmel,master-clk-have-div3-pres");\r\nreturn characteristics;\r\nout_free_characteristics:\r\nkfree(characteristics);\r\nreturn NULL;\r\n}\r\nstatic void __init\r\nof_at91_clk_master_setup(struct device_node *np, struct at91_pmc *pmc,\r\nconst struct clk_master_layout *layout)\r\n{\r\nstruct clk *clk;\r\nint num_parents;\r\nint i;\r\nunsigned int irq;\r\nconst char *parent_names[MASTER_SOURCE_MAX];\r\nconst char *name = np->name;\r\nstruct clk_master_characteristics *characteristics;\r\nnum_parents = of_count_phandle_with_args(np, "clocks", "#clock-cells");\r\nif (num_parents <= 0 || num_parents > MASTER_SOURCE_MAX)\r\nreturn;\r\nfor (i = 0; i < num_parents; ++i) {\r\nparent_names[i] = of_clk_get_parent_name(np, i);\r\nif (!parent_names[i])\r\nreturn;\r\n}\r\nof_property_read_string(np, "clock-output-names", &name);\r\ncharacteristics = of_at91_clk_master_get_characteristics(np);\r\nif (!characteristics)\r\nreturn;\r\nirq = irq_of_parse_and_map(np, 0);\r\nif (!irq)\r\ngoto out_free_characteristics;\r\nclk = at91_clk_register_master(pmc, irq, name, num_parents,\r\nparent_names, layout,\r\ncharacteristics);\r\nif (IS_ERR(clk))\r\ngoto out_free_characteristics;\r\nof_clk_add_provider(np, of_clk_src_simple_get, clk);\r\nreturn;\r\nout_free_characteristics:\r\nkfree(characteristics);\r\n}\r\nvoid __init of_at91rm9200_clk_master_setup(struct device_node *np,\r\nstruct at91_pmc *pmc)\r\n{\r\nof_at91_clk_master_setup(np, pmc, &at91rm9200_master_layout);\r\n}\r\nvoid __init of_at91sam9x5_clk_master_setup(struct device_node *np,\r\nstruct at91_pmc *pmc)\r\n{\r\nof_at91_clk_master_setup(np, pmc, &at91sam9x5_master_layout);\r\n}
