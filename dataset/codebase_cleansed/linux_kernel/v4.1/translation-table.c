static int batadv_compare_tt(const struct hlist_node *node, const void *data2)\r\n{\r\nconst void *data1 = container_of(node, struct batadv_tt_common_entry,\r\nhash_entry);\r\nreturn batadv_compare_eth(data1, data2);\r\n}\r\nstatic inline uint32_t batadv_choose_tt(const void *data, uint32_t size)\r\n{\r\nstruct batadv_tt_common_entry *tt;\r\nuint32_t hash = 0;\r\ntt = (struct batadv_tt_common_entry *)data;\r\nhash = batadv_hash_bytes(hash, &tt->addr, ETH_ALEN);\r\nhash = batadv_hash_bytes(hash, &tt->vid, sizeof(tt->vid));\r\nhash += (hash << 3);\r\nhash ^= (hash >> 11);\r\nhash += (hash << 15);\r\nreturn hash % size;\r\n}\r\nstatic struct batadv_tt_common_entry *\r\nbatadv_tt_hash_find(struct batadv_hashtable *hash, const uint8_t *addr,\r\nunsigned short vid)\r\n{\r\nstruct hlist_head *head;\r\nstruct batadv_tt_common_entry to_search, *tt, *tt_tmp = NULL;\r\nuint32_t index;\r\nif (!hash)\r\nreturn NULL;\r\nether_addr_copy(to_search.addr, addr);\r\nto_search.vid = vid;\r\nindex = batadv_choose_tt(&to_search, hash->size);\r\nhead = &hash->table[index];\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(tt, head, hash_entry) {\r\nif (!batadv_compare_eth(tt, addr))\r\ncontinue;\r\nif (tt->vid != vid)\r\ncontinue;\r\nif (!atomic_inc_not_zero(&tt->refcount))\r\ncontinue;\r\ntt_tmp = tt;\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nreturn tt_tmp;\r\n}\r\nstatic struct batadv_tt_local_entry *\r\nbatadv_tt_local_hash_find(struct batadv_priv *bat_priv, const uint8_t *addr,\r\nunsigned short vid)\r\n{\r\nstruct batadv_tt_common_entry *tt_common_entry;\r\nstruct batadv_tt_local_entry *tt_local_entry = NULL;\r\ntt_common_entry = batadv_tt_hash_find(bat_priv->tt.local_hash, addr,\r\nvid);\r\nif (tt_common_entry)\r\ntt_local_entry = container_of(tt_common_entry,\r\nstruct batadv_tt_local_entry,\r\ncommon);\r\nreturn tt_local_entry;\r\n}\r\nstatic struct batadv_tt_global_entry *\r\nbatadv_tt_global_hash_find(struct batadv_priv *bat_priv, const uint8_t *addr,\r\nunsigned short vid)\r\n{\r\nstruct batadv_tt_common_entry *tt_common_entry;\r\nstruct batadv_tt_global_entry *tt_global_entry = NULL;\r\ntt_common_entry = batadv_tt_hash_find(bat_priv->tt.global_hash, addr,\r\nvid);\r\nif (tt_common_entry)\r\ntt_global_entry = container_of(tt_common_entry,\r\nstruct batadv_tt_global_entry,\r\ncommon);\r\nreturn tt_global_entry;\r\n}\r\nstatic void\r\nbatadv_tt_local_entry_free_ref(struct batadv_tt_local_entry *tt_local_entry)\r\n{\r\nif (atomic_dec_and_test(&tt_local_entry->common.refcount))\r\nkfree_rcu(tt_local_entry, common.rcu);\r\n}\r\nstatic void\r\nbatadv_tt_global_entry_free_ref(struct batadv_tt_global_entry *tt_global_entry)\r\n{\r\nif (atomic_dec_and_test(&tt_global_entry->common.refcount)) {\r\nbatadv_tt_global_del_orig_list(tt_global_entry);\r\nkfree_rcu(tt_global_entry, common.rcu);\r\n}\r\n}\r\nint batadv_tt_global_hash_count(struct batadv_priv *bat_priv,\r\nconst uint8_t *addr, unsigned short vid)\r\n{\r\nstruct batadv_tt_global_entry *tt_global_entry;\r\nint count;\r\ntt_global_entry = batadv_tt_global_hash_find(bat_priv, addr, vid);\r\nif (!tt_global_entry)\r\nreturn 0;\r\ncount = atomic_read(&tt_global_entry->orig_list_count);\r\nbatadv_tt_global_entry_free_ref(tt_global_entry);\r\nreturn count;\r\n}\r\nstatic void batadv_tt_orig_list_entry_free_rcu(struct rcu_head *rcu)\r\n{\r\nstruct batadv_tt_orig_list_entry *orig_entry;\r\norig_entry = container_of(rcu, struct batadv_tt_orig_list_entry, rcu);\r\nbatadv_orig_node_free_ref_now(orig_entry->orig_node);\r\nkfree(orig_entry);\r\n}\r\nstatic void batadv_tt_local_size_mod(struct batadv_priv *bat_priv,\r\nunsigned short vid, int v)\r\n{\r\nstruct batadv_softif_vlan *vlan;\r\nvlan = batadv_softif_vlan_get(bat_priv, vid);\r\nif (!vlan)\r\nreturn;\r\natomic_add(v, &vlan->tt.num_entries);\r\nbatadv_softif_vlan_free_ref(vlan);\r\n}\r\nstatic void batadv_tt_local_size_inc(struct batadv_priv *bat_priv,\r\nunsigned short vid)\r\n{\r\nbatadv_tt_local_size_mod(bat_priv, vid, 1);\r\n}\r\nstatic void batadv_tt_local_size_dec(struct batadv_priv *bat_priv,\r\nunsigned short vid)\r\n{\r\nbatadv_tt_local_size_mod(bat_priv, vid, -1);\r\n}\r\nstatic void batadv_tt_global_size_mod(struct batadv_orig_node *orig_node,\r\nunsigned short vid, int v)\r\n{\r\nstruct batadv_orig_node_vlan *vlan;\r\nvlan = batadv_orig_node_vlan_new(orig_node, vid);\r\nif (!vlan)\r\nreturn;\r\nif (atomic_add_return(v, &vlan->tt.num_entries) == 0) {\r\nspin_lock_bh(&orig_node->vlan_list_lock);\r\nlist_del_rcu(&vlan->list);\r\nspin_unlock_bh(&orig_node->vlan_list_lock);\r\nbatadv_orig_node_vlan_free_ref(vlan);\r\n}\r\nbatadv_orig_node_vlan_free_ref(vlan);\r\n}\r\nstatic void batadv_tt_global_size_inc(struct batadv_orig_node *orig_node,\r\nunsigned short vid)\r\n{\r\nbatadv_tt_global_size_mod(orig_node, vid, 1);\r\n}\r\nstatic void batadv_tt_global_size_dec(struct batadv_orig_node *orig_node,\r\nunsigned short vid)\r\n{\r\nbatadv_tt_global_size_mod(orig_node, vid, -1);\r\n}\r\nstatic void\r\nbatadv_tt_orig_list_entry_free_ref(struct batadv_tt_orig_list_entry *orig_entry)\r\n{\r\nif (!atomic_dec_and_test(&orig_entry->refcount))\r\nreturn;\r\ncall_rcu(&orig_entry->rcu, batadv_tt_orig_list_entry_free_rcu);\r\n}\r\nstatic void batadv_tt_local_event(struct batadv_priv *bat_priv,\r\nstruct batadv_tt_local_entry *tt_local_entry,\r\nuint8_t event_flags)\r\n{\r\nstruct batadv_tt_change_node *tt_change_node, *entry, *safe;\r\nstruct batadv_tt_common_entry *common = &tt_local_entry->common;\r\nuint8_t flags = common->flags | event_flags;\r\nbool event_removed = false;\r\nbool del_op_requested, del_op_entry;\r\ntt_change_node = kmalloc(sizeof(*tt_change_node), GFP_ATOMIC);\r\nif (!tt_change_node)\r\nreturn;\r\ntt_change_node->change.flags = flags;\r\nmemset(tt_change_node->change.reserved, 0,\r\nsizeof(tt_change_node->change.reserved));\r\nether_addr_copy(tt_change_node->change.addr, common->addr);\r\ntt_change_node->change.vid = htons(common->vid);\r\ndel_op_requested = flags & BATADV_TT_CLIENT_DEL;\r\nspin_lock_bh(&bat_priv->tt.changes_list_lock);\r\nlist_for_each_entry_safe(entry, safe, &bat_priv->tt.changes_list,\r\nlist) {\r\nif (!batadv_compare_eth(entry->change.addr, common->addr))\r\ncontinue;\r\ndel_op_entry = entry->change.flags & BATADV_TT_CLIENT_DEL;\r\nif (!del_op_requested && del_op_entry)\r\ngoto del;\r\nif (del_op_requested && !del_op_entry)\r\ngoto del;\r\nif (!del_op_requested && !del_op_entry)\r\nentry->change.flags = flags;\r\ncontinue;\r\ndel:\r\nlist_del(&entry->list);\r\nkfree(entry);\r\nkfree(tt_change_node);\r\nevent_removed = true;\r\ngoto unlock;\r\n}\r\nlist_add_tail(&tt_change_node->list, &bat_priv->tt.changes_list);\r\nunlock:\r\nspin_unlock_bh(&bat_priv->tt.changes_list_lock);\r\nif (event_removed)\r\natomic_dec(&bat_priv->tt.local_changes);\r\nelse\r\natomic_inc(&bat_priv->tt.local_changes);\r\n}\r\nstatic int batadv_tt_len(int changes_num)\r\n{\r\nreturn changes_num * sizeof(struct batadv_tvlv_tt_change);\r\n}\r\nstatic uint16_t batadv_tt_entries(uint16_t tt_len)\r\n{\r\nreturn tt_len / batadv_tt_len(1);\r\n}\r\nstatic int batadv_tt_local_table_transmit_size(struct batadv_priv *bat_priv)\r\n{\r\nuint16_t num_vlan = 0, tt_local_entries = 0;\r\nstruct batadv_softif_vlan *vlan;\r\nint hdr_size;\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(vlan, &bat_priv->softif_vlan_list, list) {\r\nnum_vlan++;\r\ntt_local_entries += atomic_read(&vlan->tt.num_entries);\r\n}\r\nrcu_read_unlock();\r\nhdr_size = sizeof(struct batadv_unicast_tvlv_packet);\r\nhdr_size += sizeof(struct batadv_tvlv_hdr);\r\nhdr_size += sizeof(struct batadv_tvlv_tt_data);\r\nhdr_size += num_vlan * sizeof(struct batadv_tvlv_tt_vlan_data);\r\nreturn hdr_size + batadv_tt_len(tt_local_entries);\r\n}\r\nstatic int batadv_tt_local_init(struct batadv_priv *bat_priv)\r\n{\r\nif (bat_priv->tt.local_hash)\r\nreturn 0;\r\nbat_priv->tt.local_hash = batadv_hash_new(1024);\r\nif (!bat_priv->tt.local_hash)\r\nreturn -ENOMEM;\r\nbatadv_hash_set_lock_class(bat_priv->tt.local_hash,\r\n&batadv_tt_local_hash_lock_class_key);\r\nreturn 0;\r\n}\r\nstatic void batadv_tt_global_free(struct batadv_priv *bat_priv,\r\nstruct batadv_tt_global_entry *tt_global,\r\nconst char *message)\r\n{\r\nbatadv_dbg(BATADV_DBG_TT, bat_priv,\r\n"Deleting global tt entry %pM (vid: %d): %s\n",\r\ntt_global->common.addr,\r\nBATADV_PRINT_VID(tt_global->common.vid), message);\r\nbatadv_hash_remove(bat_priv->tt.global_hash, batadv_compare_tt,\r\nbatadv_choose_tt, &tt_global->common);\r\nbatadv_tt_global_entry_free_ref(tt_global);\r\n}\r\nbool batadv_tt_local_add(struct net_device *soft_iface, const uint8_t *addr,\r\nunsigned short vid, int ifindex, uint32_t mark)\r\n{\r\nstruct batadv_priv *bat_priv = netdev_priv(soft_iface);\r\nstruct batadv_tt_local_entry *tt_local;\r\nstruct batadv_tt_global_entry *tt_global = NULL;\r\nstruct batadv_softif_vlan *vlan;\r\nstruct net_device *in_dev = NULL;\r\nstruct hlist_head *head;\r\nstruct batadv_tt_orig_list_entry *orig_entry;\r\nint hash_added, table_size, packet_size_max;\r\nbool ret = false, roamed_back = false;\r\nuint8_t remote_flags;\r\nuint32_t match_mark;\r\nif (ifindex != BATADV_NULL_IFINDEX)\r\nin_dev = dev_get_by_index(&init_net, ifindex);\r\ntt_local = batadv_tt_local_hash_find(bat_priv, addr, vid);\r\nif (!is_multicast_ether_addr(addr))\r\ntt_global = batadv_tt_global_hash_find(bat_priv, addr, vid);\r\nif (tt_local) {\r\ntt_local->last_seen = jiffies;\r\nif (tt_local->common.flags & BATADV_TT_CLIENT_PENDING) {\r\nbatadv_dbg(BATADV_DBG_TT, bat_priv,\r\n"Re-adding pending client %pM (vid: %d)\n",\r\naddr, BATADV_PRINT_VID(vid));\r\ntt_local->common.flags &= ~BATADV_TT_CLIENT_PENDING;\r\ngoto add_event;\r\n}\r\nif (tt_local->common.flags & BATADV_TT_CLIENT_ROAM) {\r\nbatadv_dbg(BATADV_DBG_TT, bat_priv,\r\n"Roaming client %pM (vid: %d) came back to its original location\n",\r\naddr, BATADV_PRINT_VID(vid));\r\ntt_local->common.flags &= ~BATADV_TT_CLIENT_ROAM;\r\nroamed_back = true;\r\n}\r\ngoto check_roaming;\r\n}\r\ntable_size = batadv_tt_local_table_transmit_size(bat_priv);\r\ntable_size += batadv_tt_len(1);\r\npacket_size_max = atomic_read(&bat_priv->packet_size_max);\r\nif (table_size > packet_size_max) {\r\nnet_ratelimited_function(batadv_info, soft_iface,\r\n"Local translation table size (%i) exceeds maximum packet size (%i); Ignoring new local tt entry: %pM\n",\r\ntable_size, packet_size_max, addr);\r\ngoto out;\r\n}\r\ntt_local = kmalloc(sizeof(*tt_local), GFP_ATOMIC);\r\nif (!tt_local)\r\ngoto out;\r\nvlan = batadv_softif_vlan_get(bat_priv, vid);\r\nbatadv_dbg(BATADV_DBG_TT, bat_priv,\r\n"Creating new local tt entry: %pM (vid: %d, ttvn: %d)\n",\r\naddr, BATADV_PRINT_VID(vid),\r\n(uint8_t)atomic_read(&bat_priv->tt.vn));\r\nether_addr_copy(tt_local->common.addr, addr);\r\ntt_local->common.flags = BATADV_TT_CLIENT_NEW;\r\ntt_local->common.vid = vid;\r\nif (batadv_is_wifi_netdev(in_dev))\r\ntt_local->common.flags |= BATADV_TT_CLIENT_WIFI;\r\natomic_set(&tt_local->common.refcount, 2);\r\ntt_local->last_seen = jiffies;\r\ntt_local->common.added_at = tt_local->last_seen;\r\nif (batadv_compare_eth(addr, soft_iface->dev_addr) ||\r\nis_multicast_ether_addr(addr))\r\ntt_local->common.flags |= BATADV_TT_CLIENT_NOPURGE;\r\nhash_added = batadv_hash_add(bat_priv->tt.local_hash, batadv_compare_tt,\r\nbatadv_choose_tt, &tt_local->common,\r\n&tt_local->common.hash_entry);\r\nif (unlikely(hash_added != 0)) {\r\nbatadv_tt_local_entry_free_ref(tt_local);\r\nbatadv_softif_vlan_free_ref(vlan);\r\ngoto out;\r\n}\r\nadd_event:\r\nbatadv_tt_local_event(bat_priv, tt_local, BATADV_NO_FLAGS);\r\ncheck_roaming:\r\nif (tt_global && !(tt_global->common.flags & BATADV_TT_CLIENT_ROAM)) {\r\nhead = &tt_global->orig_list;\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(orig_entry, head, list) {\r\nbatadv_send_roam_adv(bat_priv, tt_global->common.addr,\r\ntt_global->common.vid,\r\norig_entry->orig_node);\r\n}\r\nrcu_read_unlock();\r\nif (roamed_back) {\r\nbatadv_tt_global_free(bat_priv, tt_global,\r\n"Roaming canceled");\r\ntt_global = NULL;\r\n} else {\r\ntt_global->common.flags |= BATADV_TT_CLIENT_ROAM;\r\ntt_global->roam_at = jiffies;\r\n}\r\n}\r\nremote_flags = tt_local->common.flags & BATADV_TT_REMOTE_MASK;\r\nif (batadv_is_wifi_netdev(in_dev))\r\ntt_local->common.flags |= BATADV_TT_CLIENT_WIFI;\r\nelse\r\ntt_local->common.flags &= ~BATADV_TT_CLIENT_WIFI;\r\nmatch_mark = (mark & bat_priv->isolation_mark_mask);\r\nif (bat_priv->isolation_mark_mask &&\r\nmatch_mark == bat_priv->isolation_mark)\r\ntt_local->common.flags |= BATADV_TT_CLIENT_ISOLA;\r\nelse\r\ntt_local->common.flags &= ~BATADV_TT_CLIENT_ISOLA;\r\nif (remote_flags ^ (tt_local->common.flags & BATADV_TT_REMOTE_MASK))\r\nbatadv_tt_local_event(bat_priv, tt_local, BATADV_NO_FLAGS);\r\nret = true;\r\nout:\r\nif (in_dev)\r\ndev_put(in_dev);\r\nif (tt_local)\r\nbatadv_tt_local_entry_free_ref(tt_local);\r\nif (tt_global)\r\nbatadv_tt_global_entry_free_ref(tt_global);\r\nreturn ret;\r\n}\r\nstatic uint16_t\r\nbatadv_tt_prepare_tvlv_global_data(struct batadv_orig_node *orig_node,\r\nstruct batadv_tvlv_tt_data **tt_data,\r\nstruct batadv_tvlv_tt_change **tt_change,\r\nint32_t *tt_len)\r\n{\r\nuint16_t num_vlan = 0, num_entries = 0, change_offset, tvlv_len;\r\nstruct batadv_tvlv_tt_vlan_data *tt_vlan;\r\nstruct batadv_orig_node_vlan *vlan;\r\nuint8_t *tt_change_ptr;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(vlan, &orig_node->vlan_list, list) {\r\nnum_vlan++;\r\nnum_entries += atomic_read(&vlan->tt.num_entries);\r\n}\r\nchange_offset = sizeof(**tt_data);\r\nchange_offset += num_vlan * sizeof(*tt_vlan);\r\nif (*tt_len < 0)\r\n*tt_len = batadv_tt_len(num_entries);\r\ntvlv_len = *tt_len;\r\ntvlv_len += change_offset;\r\n*tt_data = kmalloc(tvlv_len, GFP_ATOMIC);\r\nif (!*tt_data) {\r\n*tt_len = 0;\r\ngoto out;\r\n}\r\n(*tt_data)->flags = BATADV_NO_FLAGS;\r\n(*tt_data)->ttvn = atomic_read(&orig_node->last_ttvn);\r\n(*tt_data)->num_vlan = htons(num_vlan);\r\ntt_vlan = (struct batadv_tvlv_tt_vlan_data *)(*tt_data + 1);\r\nlist_for_each_entry_rcu(vlan, &orig_node->vlan_list, list) {\r\ntt_vlan->vid = htons(vlan->vid);\r\ntt_vlan->crc = htonl(vlan->tt.crc);\r\ntt_vlan++;\r\n}\r\ntt_change_ptr = (uint8_t *)*tt_data + change_offset;\r\n*tt_change = (struct batadv_tvlv_tt_change *)tt_change_ptr;\r\nout:\r\nrcu_read_unlock();\r\nreturn tvlv_len;\r\n}\r\nstatic uint16_t\r\nbatadv_tt_prepare_tvlv_local_data(struct batadv_priv *bat_priv,\r\nstruct batadv_tvlv_tt_data **tt_data,\r\nstruct batadv_tvlv_tt_change **tt_change,\r\nint32_t *tt_len)\r\n{\r\nstruct batadv_tvlv_tt_vlan_data *tt_vlan;\r\nstruct batadv_softif_vlan *vlan;\r\nuint16_t num_vlan = 0, num_entries = 0, tvlv_len;\r\nuint8_t *tt_change_ptr;\r\nint change_offset;\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(vlan, &bat_priv->softif_vlan_list, list) {\r\nnum_vlan++;\r\nnum_entries += atomic_read(&vlan->tt.num_entries);\r\n}\r\nchange_offset = sizeof(**tt_data);\r\nchange_offset += num_vlan * sizeof(*tt_vlan);\r\nif (*tt_len < 0)\r\n*tt_len = batadv_tt_len(num_entries);\r\ntvlv_len = *tt_len;\r\ntvlv_len += change_offset;\r\n*tt_data = kmalloc(tvlv_len, GFP_ATOMIC);\r\nif (!*tt_data) {\r\ntvlv_len = 0;\r\ngoto out;\r\n}\r\n(*tt_data)->flags = BATADV_NO_FLAGS;\r\n(*tt_data)->ttvn = atomic_read(&bat_priv->tt.vn);\r\n(*tt_data)->num_vlan = htons(num_vlan);\r\ntt_vlan = (struct batadv_tvlv_tt_vlan_data *)(*tt_data + 1);\r\nhlist_for_each_entry_rcu(vlan, &bat_priv->softif_vlan_list, list) {\r\ntt_vlan->vid = htons(vlan->vid);\r\ntt_vlan->crc = htonl(vlan->tt.crc);\r\ntt_vlan++;\r\n}\r\ntt_change_ptr = (uint8_t *)*tt_data + change_offset;\r\n*tt_change = (struct batadv_tvlv_tt_change *)tt_change_ptr;\r\nout:\r\nrcu_read_unlock();\r\nreturn tvlv_len;\r\n}\r\nstatic void batadv_tt_tvlv_container_update(struct batadv_priv *bat_priv)\r\n{\r\nstruct batadv_tt_change_node *entry, *safe;\r\nstruct batadv_tvlv_tt_data *tt_data;\r\nstruct batadv_tvlv_tt_change *tt_change;\r\nint tt_diff_len, tt_change_len = 0;\r\nint tt_diff_entries_num = 0, tt_diff_entries_count = 0;\r\nuint16_t tvlv_len;\r\ntt_diff_entries_num = atomic_read(&bat_priv->tt.local_changes);\r\ntt_diff_len = batadv_tt_len(tt_diff_entries_num);\r\nif (tt_diff_len > bat_priv->soft_iface->mtu)\r\ntt_diff_len = 0;\r\ntvlv_len = batadv_tt_prepare_tvlv_local_data(bat_priv, &tt_data,\r\n&tt_change, &tt_diff_len);\r\nif (!tvlv_len)\r\nreturn;\r\ntt_data->flags = BATADV_TT_OGM_DIFF;\r\nif (tt_diff_len == 0)\r\ngoto container_register;\r\nspin_lock_bh(&bat_priv->tt.changes_list_lock);\r\natomic_set(&bat_priv->tt.local_changes, 0);\r\nlist_for_each_entry_safe(entry, safe, &bat_priv->tt.changes_list,\r\nlist) {\r\nif (tt_diff_entries_count < tt_diff_entries_num) {\r\nmemcpy(tt_change + tt_diff_entries_count,\r\n&entry->change,\r\nsizeof(struct batadv_tvlv_tt_change));\r\ntt_diff_entries_count++;\r\n}\r\nlist_del(&entry->list);\r\nkfree(entry);\r\n}\r\nspin_unlock_bh(&bat_priv->tt.changes_list_lock);\r\nspin_lock_bh(&bat_priv->tt.last_changeset_lock);\r\nkfree(bat_priv->tt.last_changeset);\r\nbat_priv->tt.last_changeset_len = 0;\r\nbat_priv->tt.last_changeset = NULL;\r\ntt_change_len = batadv_tt_len(tt_diff_entries_count);\r\nif (tt_diff_entries_count > 0) {\r\nbat_priv->tt.last_changeset = kzalloc(tt_diff_len, GFP_ATOMIC);\r\nif (bat_priv->tt.last_changeset) {\r\nmemcpy(bat_priv->tt.last_changeset,\r\ntt_change, tt_change_len);\r\nbat_priv->tt.last_changeset_len = tt_diff_len;\r\n}\r\n}\r\nspin_unlock_bh(&bat_priv->tt.last_changeset_lock);\r\ncontainer_register:\r\nbatadv_tvlv_container_register(bat_priv, BATADV_TVLV_TT, 1, tt_data,\r\ntvlv_len);\r\nkfree(tt_data);\r\n}\r\nint batadv_tt_local_seq_print_text(struct seq_file *seq, void *offset)\r\n{\r\nstruct net_device *net_dev = (struct net_device *)seq->private;\r\nstruct batadv_priv *bat_priv = netdev_priv(net_dev);\r\nstruct batadv_hashtable *hash = bat_priv->tt.local_hash;\r\nstruct batadv_tt_common_entry *tt_common_entry;\r\nstruct batadv_tt_local_entry *tt_local;\r\nstruct batadv_hard_iface *primary_if;\r\nstruct batadv_softif_vlan *vlan;\r\nstruct hlist_head *head;\r\nunsigned short vid;\r\nuint32_t i;\r\nint last_seen_secs;\r\nint last_seen_msecs;\r\nunsigned long last_seen_jiffies;\r\nbool no_purge;\r\nuint16_t np_flag = BATADV_TT_CLIENT_NOPURGE;\r\nprimary_if = batadv_seq_print_text_primary_if_get(seq);\r\nif (!primary_if)\r\ngoto out;\r\nseq_printf(seq,\r\n"Locally retrieved addresses (from %s) announced via TT (TTVN: %u):\n",\r\nnet_dev->name, (uint8_t)atomic_read(&bat_priv->tt.vn));\r\nseq_printf(seq, " %-13s %s %-8s %-9s (%-10s)\n", "Client", "VID",\r\n"Flags", "Last seen", "CRC");\r\nfor (i = 0; i < hash->size; i++) {\r\nhead = &hash->table[i];\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(tt_common_entry,\r\nhead, hash_entry) {\r\ntt_local = container_of(tt_common_entry,\r\nstruct batadv_tt_local_entry,\r\ncommon);\r\nvid = tt_common_entry->vid;\r\nlast_seen_jiffies = jiffies - tt_local->last_seen;\r\nlast_seen_msecs = jiffies_to_msecs(last_seen_jiffies);\r\nlast_seen_secs = last_seen_msecs / 1000;\r\nlast_seen_msecs = last_seen_msecs % 1000;\r\nno_purge = tt_common_entry->flags & np_flag;\r\nvlan = batadv_softif_vlan_get(bat_priv, vid);\r\nif (!vlan) {\r\nseq_printf(seq, "Cannot retrieve VLAN %d\n",\r\nBATADV_PRINT_VID(vid));\r\ncontinue;\r\n}\r\nseq_printf(seq,\r\n" * %pM %4i [%c%c%c%c%c%c] %3u.%03u (%#.8x)\n",\r\ntt_common_entry->addr,\r\nBATADV_PRINT_VID(tt_common_entry->vid),\r\n(tt_common_entry->flags &\r\nBATADV_TT_CLIENT_ROAM ? 'R' : '.'),\r\nno_purge ? 'P' : '.',\r\n(tt_common_entry->flags &\r\nBATADV_TT_CLIENT_NEW ? 'N' : '.'),\r\n(tt_common_entry->flags &\r\nBATADV_TT_CLIENT_PENDING ? 'X' : '.'),\r\n(tt_common_entry->flags &\r\nBATADV_TT_CLIENT_WIFI ? 'W' : '.'),\r\n(tt_common_entry->flags &\r\nBATADV_TT_CLIENT_ISOLA ? 'I' : '.'),\r\nno_purge ? 0 : last_seen_secs,\r\nno_purge ? 0 : last_seen_msecs,\r\nvlan->tt.crc);\r\nbatadv_softif_vlan_free_ref(vlan);\r\n}\r\nrcu_read_unlock();\r\n}\r\nout:\r\nif (primary_if)\r\nbatadv_hardif_free_ref(primary_if);\r\nreturn 0;\r\n}\r\nstatic void\r\nbatadv_tt_local_set_pending(struct batadv_priv *bat_priv,\r\nstruct batadv_tt_local_entry *tt_local_entry,\r\nuint16_t flags, const char *message)\r\n{\r\nbatadv_tt_local_event(bat_priv, tt_local_entry, flags);\r\ntt_local_entry->common.flags |= BATADV_TT_CLIENT_PENDING;\r\nbatadv_dbg(BATADV_DBG_TT, bat_priv,\r\n"Local tt entry (%pM, vid: %d) pending to be removed: %s\n",\r\ntt_local_entry->common.addr,\r\nBATADV_PRINT_VID(tt_local_entry->common.vid), message);\r\n}\r\nuint16_t batadv_tt_local_remove(struct batadv_priv *bat_priv,\r\nconst uint8_t *addr, unsigned short vid,\r\nconst char *message, bool roaming)\r\n{\r\nstruct batadv_tt_local_entry *tt_local_entry;\r\nuint16_t flags, curr_flags = BATADV_NO_FLAGS;\r\nstruct batadv_softif_vlan *vlan;\r\ntt_local_entry = batadv_tt_local_hash_find(bat_priv, addr, vid);\r\nif (!tt_local_entry)\r\ngoto out;\r\ncurr_flags = tt_local_entry->common.flags;\r\nflags = BATADV_TT_CLIENT_DEL;\r\nif (roaming) {\r\nflags |= BATADV_TT_CLIENT_ROAM;\r\ntt_local_entry->common.flags |= BATADV_TT_CLIENT_ROAM;\r\n}\r\nif (!(tt_local_entry->common.flags & BATADV_TT_CLIENT_NEW)) {\r\nbatadv_tt_local_set_pending(bat_priv, tt_local_entry, flags,\r\nmessage);\r\ngoto out;\r\n}\r\nbatadv_tt_local_event(bat_priv, tt_local_entry, BATADV_TT_CLIENT_DEL);\r\nhlist_del_rcu(&tt_local_entry->common.hash_entry);\r\nbatadv_tt_local_entry_free_ref(tt_local_entry);\r\nvlan = batadv_softif_vlan_get(bat_priv, vid);\r\nbatadv_softif_vlan_free_ref(vlan);\r\nbatadv_softif_vlan_free_ref(vlan);\r\nout:\r\nif (tt_local_entry)\r\nbatadv_tt_local_entry_free_ref(tt_local_entry);\r\nreturn curr_flags;\r\n}\r\nstatic void batadv_tt_local_purge_list(struct batadv_priv *bat_priv,\r\nstruct hlist_head *head,\r\nint timeout)\r\n{\r\nstruct batadv_tt_local_entry *tt_local_entry;\r\nstruct batadv_tt_common_entry *tt_common_entry;\r\nstruct hlist_node *node_tmp;\r\nhlist_for_each_entry_safe(tt_common_entry, node_tmp, head,\r\nhash_entry) {\r\ntt_local_entry = container_of(tt_common_entry,\r\nstruct batadv_tt_local_entry,\r\ncommon);\r\nif (tt_local_entry->common.flags & BATADV_TT_CLIENT_NOPURGE)\r\ncontinue;\r\nif (tt_local_entry->common.flags & BATADV_TT_CLIENT_PENDING)\r\ncontinue;\r\nif (!batadv_has_timed_out(tt_local_entry->last_seen, timeout))\r\ncontinue;\r\nbatadv_tt_local_set_pending(bat_priv, tt_local_entry,\r\nBATADV_TT_CLIENT_DEL, "timed out");\r\n}\r\n}\r\nstatic void batadv_tt_local_purge(struct batadv_priv *bat_priv,\r\nint timeout)\r\n{\r\nstruct batadv_hashtable *hash = bat_priv->tt.local_hash;\r\nstruct hlist_head *head;\r\nspinlock_t *list_lock;\r\nuint32_t i;\r\nfor (i = 0; i < hash->size; i++) {\r\nhead = &hash->table[i];\r\nlist_lock = &hash->list_locks[i];\r\nspin_lock_bh(list_lock);\r\nbatadv_tt_local_purge_list(bat_priv, head, timeout);\r\nspin_unlock_bh(list_lock);\r\n}\r\n}\r\nstatic void batadv_tt_local_table_free(struct batadv_priv *bat_priv)\r\n{\r\nstruct batadv_hashtable *hash;\r\nspinlock_t *list_lock;\r\nstruct batadv_tt_common_entry *tt_common_entry;\r\nstruct batadv_tt_local_entry *tt_local;\r\nstruct batadv_softif_vlan *vlan;\r\nstruct hlist_node *node_tmp;\r\nstruct hlist_head *head;\r\nuint32_t i;\r\nif (!bat_priv->tt.local_hash)\r\nreturn;\r\nhash = bat_priv->tt.local_hash;\r\nfor (i = 0; i < hash->size; i++) {\r\nhead = &hash->table[i];\r\nlist_lock = &hash->list_locks[i];\r\nspin_lock_bh(list_lock);\r\nhlist_for_each_entry_safe(tt_common_entry, node_tmp,\r\nhead, hash_entry) {\r\nhlist_del_rcu(&tt_common_entry->hash_entry);\r\ntt_local = container_of(tt_common_entry,\r\nstruct batadv_tt_local_entry,\r\ncommon);\r\nvlan = batadv_softif_vlan_get(bat_priv,\r\ntt_common_entry->vid);\r\nbatadv_softif_vlan_free_ref(vlan);\r\nbatadv_softif_vlan_free_ref(vlan);\r\nbatadv_tt_local_entry_free_ref(tt_local);\r\n}\r\nspin_unlock_bh(list_lock);\r\n}\r\nbatadv_hash_destroy(hash);\r\nbat_priv->tt.local_hash = NULL;\r\n}\r\nstatic int batadv_tt_global_init(struct batadv_priv *bat_priv)\r\n{\r\nif (bat_priv->tt.global_hash)\r\nreturn 0;\r\nbat_priv->tt.global_hash = batadv_hash_new(1024);\r\nif (!bat_priv->tt.global_hash)\r\nreturn -ENOMEM;\r\nbatadv_hash_set_lock_class(bat_priv->tt.global_hash,\r\n&batadv_tt_global_hash_lock_class_key);\r\nreturn 0;\r\n}\r\nstatic void batadv_tt_changes_list_free(struct batadv_priv *bat_priv)\r\n{\r\nstruct batadv_tt_change_node *entry, *safe;\r\nspin_lock_bh(&bat_priv->tt.changes_list_lock);\r\nlist_for_each_entry_safe(entry, safe, &bat_priv->tt.changes_list,\r\nlist) {\r\nlist_del(&entry->list);\r\nkfree(entry);\r\n}\r\natomic_set(&bat_priv->tt.local_changes, 0);\r\nspin_unlock_bh(&bat_priv->tt.changes_list_lock);\r\n}\r\nstatic struct batadv_tt_orig_list_entry *\r\nbatadv_tt_global_orig_entry_find(const struct batadv_tt_global_entry *entry,\r\nconst struct batadv_orig_node *orig_node)\r\n{\r\nstruct batadv_tt_orig_list_entry *tmp_orig_entry, *orig_entry = NULL;\r\nconst struct hlist_head *head;\r\nrcu_read_lock();\r\nhead = &entry->orig_list;\r\nhlist_for_each_entry_rcu(tmp_orig_entry, head, list) {\r\nif (tmp_orig_entry->orig_node != orig_node)\r\ncontinue;\r\nif (!atomic_inc_not_zero(&tmp_orig_entry->refcount))\r\ncontinue;\r\norig_entry = tmp_orig_entry;\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nreturn orig_entry;\r\n}\r\nstatic bool\r\nbatadv_tt_global_entry_has_orig(const struct batadv_tt_global_entry *entry,\r\nconst struct batadv_orig_node *orig_node)\r\n{\r\nstruct batadv_tt_orig_list_entry *orig_entry;\r\nbool found = false;\r\norig_entry = batadv_tt_global_orig_entry_find(entry, orig_node);\r\nif (orig_entry) {\r\nfound = true;\r\nbatadv_tt_orig_list_entry_free_ref(orig_entry);\r\n}\r\nreturn found;\r\n}\r\nstatic void\r\nbatadv_tt_global_orig_entry_add(struct batadv_tt_global_entry *tt_global,\r\nstruct batadv_orig_node *orig_node, int ttvn)\r\n{\r\nstruct batadv_tt_orig_list_entry *orig_entry;\r\norig_entry = batadv_tt_global_orig_entry_find(tt_global, orig_node);\r\nif (orig_entry) {\r\norig_entry->ttvn = ttvn;\r\ngoto out;\r\n}\r\norig_entry = kzalloc(sizeof(*orig_entry), GFP_ATOMIC);\r\nif (!orig_entry)\r\ngoto out;\r\nINIT_HLIST_NODE(&orig_entry->list);\r\natomic_inc(&orig_node->refcount);\r\nbatadv_tt_global_size_inc(orig_node, tt_global->common.vid);\r\norig_entry->orig_node = orig_node;\r\norig_entry->ttvn = ttvn;\r\natomic_set(&orig_entry->refcount, 2);\r\nspin_lock_bh(&tt_global->list_lock);\r\nhlist_add_head_rcu(&orig_entry->list,\r\n&tt_global->orig_list);\r\nspin_unlock_bh(&tt_global->list_lock);\r\natomic_inc(&tt_global->orig_list_count);\r\nout:\r\nif (orig_entry)\r\nbatadv_tt_orig_list_entry_free_ref(orig_entry);\r\n}\r\nstatic bool batadv_tt_global_add(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig_node,\r\nconst unsigned char *tt_addr,\r\nunsigned short vid, uint16_t flags,\r\nuint8_t ttvn)\r\n{\r\nstruct batadv_tt_global_entry *tt_global_entry;\r\nstruct batadv_tt_local_entry *tt_local_entry;\r\nbool ret = false;\r\nint hash_added;\r\nstruct batadv_tt_common_entry *common;\r\nuint16_t local_flags;\r\nif (batadv_bla_is_backbone_gw_orig(bat_priv, orig_node->orig, vid))\r\nreturn true;\r\ntt_global_entry = batadv_tt_global_hash_find(bat_priv, tt_addr, vid);\r\ntt_local_entry = batadv_tt_local_hash_find(bat_priv, tt_addr, vid);\r\nif ((flags & BATADV_TT_CLIENT_TEMP) && tt_local_entry &&\r\n!(tt_local_entry->common.flags & BATADV_TT_CLIENT_NEW))\r\ngoto out;\r\nif (!tt_global_entry) {\r\ntt_global_entry = kzalloc(sizeof(*tt_global_entry), GFP_ATOMIC);\r\nif (!tt_global_entry)\r\ngoto out;\r\ncommon = &tt_global_entry->common;\r\nether_addr_copy(common->addr, tt_addr);\r\ncommon->vid = vid;\r\ncommon->flags = flags;\r\ntt_global_entry->roam_at = 0;\r\nif (flags & BATADV_TT_CLIENT_ROAM)\r\ntt_global_entry->roam_at = jiffies;\r\natomic_set(&common->refcount, 2);\r\ncommon->added_at = jiffies;\r\nINIT_HLIST_HEAD(&tt_global_entry->orig_list);\r\natomic_set(&tt_global_entry->orig_list_count, 0);\r\nspin_lock_init(&tt_global_entry->list_lock);\r\nhash_added = batadv_hash_add(bat_priv->tt.global_hash,\r\nbatadv_compare_tt,\r\nbatadv_choose_tt, common,\r\n&common->hash_entry);\r\nif (unlikely(hash_added != 0)) {\r\nbatadv_tt_global_entry_free_ref(tt_global_entry);\r\ngoto out_remove;\r\n}\r\n} else {\r\ncommon = &tt_global_entry->common;\r\nif (flags & BATADV_TT_CLIENT_TEMP) {\r\nif (!(common->flags & BATADV_TT_CLIENT_TEMP))\r\ngoto out;\r\nif (batadv_tt_global_entry_has_orig(tt_global_entry,\r\norig_node))\r\ngoto out_remove;\r\nbatadv_tt_global_del_orig_list(tt_global_entry);\r\ngoto add_orig_entry;\r\n}\r\ncommon->flags &= ~BATADV_TT_CLIENT_TEMP;\r\ntt_global_entry->common.flags |= flags;\r\nif (common->flags & BATADV_TT_CLIENT_ROAM) {\r\nbatadv_tt_global_del_orig_list(tt_global_entry);\r\ncommon->flags &= ~BATADV_TT_CLIENT_ROAM;\r\ntt_global_entry->roam_at = 0;\r\n}\r\n}\r\nadd_orig_entry:\r\nbatadv_tt_global_orig_entry_add(tt_global_entry, orig_node, ttvn);\r\nbatadv_dbg(BATADV_DBG_TT, bat_priv,\r\n"Creating new global tt entry: %pM (vid: %d, via %pM)\n",\r\ncommon->addr, BATADV_PRINT_VID(common->vid),\r\norig_node->orig);\r\nret = true;\r\nout_remove:\r\nif (is_multicast_ether_addr(tt_addr))\r\ngoto out;\r\nlocal_flags = batadv_tt_local_remove(bat_priv, tt_addr, vid,\r\n"global tt received",\r\nflags & BATADV_TT_CLIENT_ROAM);\r\ntt_global_entry->common.flags |= local_flags & BATADV_TT_CLIENT_WIFI;\r\nif (!(flags & BATADV_TT_CLIENT_ROAM))\r\ntt_global_entry->common.flags &= ~BATADV_TT_CLIENT_ROAM;\r\nout:\r\nif (tt_global_entry)\r\nbatadv_tt_global_entry_free_ref(tt_global_entry);\r\nif (tt_local_entry)\r\nbatadv_tt_local_entry_free_ref(tt_local_entry);\r\nreturn ret;\r\n}\r\nstatic struct batadv_tt_orig_list_entry *\r\nbatadv_transtable_best_orig(struct batadv_priv *bat_priv,\r\nstruct batadv_tt_global_entry *tt_global_entry)\r\n{\r\nstruct batadv_neigh_node *router, *best_router = NULL;\r\nstruct batadv_algo_ops *bao = bat_priv->bat_algo_ops;\r\nstruct hlist_head *head;\r\nstruct batadv_tt_orig_list_entry *orig_entry, *best_entry = NULL;\r\nhead = &tt_global_entry->orig_list;\r\nhlist_for_each_entry_rcu(orig_entry, head, list) {\r\nrouter = batadv_orig_router_get(orig_entry->orig_node,\r\nBATADV_IF_DEFAULT);\r\nif (!router)\r\ncontinue;\r\nif (best_router &&\r\nbao->bat_neigh_cmp(router, BATADV_IF_DEFAULT,\r\nbest_router, BATADV_IF_DEFAULT) <= 0) {\r\nbatadv_neigh_node_free_ref(router);\r\ncontinue;\r\n}\r\nif (best_router)\r\nbatadv_neigh_node_free_ref(best_router);\r\nbest_entry = orig_entry;\r\nbest_router = router;\r\n}\r\nif (best_router)\r\nbatadv_neigh_node_free_ref(best_router);\r\nreturn best_entry;\r\n}\r\nstatic void\r\nbatadv_tt_global_print_entry(struct batadv_priv *bat_priv,\r\nstruct batadv_tt_global_entry *tt_global_entry,\r\nstruct seq_file *seq)\r\n{\r\nstruct batadv_tt_orig_list_entry *orig_entry, *best_entry;\r\nstruct batadv_tt_common_entry *tt_common_entry;\r\nstruct batadv_orig_node_vlan *vlan;\r\nstruct hlist_head *head;\r\nuint8_t last_ttvn;\r\nuint16_t flags;\r\ntt_common_entry = &tt_global_entry->common;\r\nflags = tt_common_entry->flags;\r\nbest_entry = batadv_transtable_best_orig(bat_priv, tt_global_entry);\r\nif (best_entry) {\r\nvlan = batadv_orig_node_vlan_get(best_entry->orig_node,\r\ntt_common_entry->vid);\r\nif (!vlan) {\r\nseq_printf(seq,\r\n" * Cannot retrieve VLAN %d for originator %pM\n",\r\nBATADV_PRINT_VID(tt_common_entry->vid),\r\nbest_entry->orig_node->orig);\r\ngoto print_list;\r\n}\r\nlast_ttvn = atomic_read(&best_entry->orig_node->last_ttvn);\r\nseq_printf(seq,\r\n" %c %pM %4i (%3u) via %pM (%3u) (%#.8x) [%c%c%c%c]\n",\r\n'*', tt_global_entry->common.addr,\r\nBATADV_PRINT_VID(tt_global_entry->common.vid),\r\nbest_entry->ttvn, best_entry->orig_node->orig,\r\nlast_ttvn, vlan->tt.crc,\r\n(flags & BATADV_TT_CLIENT_ROAM ? 'R' : '.'),\r\n(flags & BATADV_TT_CLIENT_WIFI ? 'W' : '.'),\r\n(flags & BATADV_TT_CLIENT_ISOLA ? 'I' : '.'),\r\n(flags & BATADV_TT_CLIENT_TEMP ? 'T' : '.'));\r\nbatadv_orig_node_vlan_free_ref(vlan);\r\n}\r\nprint_list:\r\nhead = &tt_global_entry->orig_list;\r\nhlist_for_each_entry_rcu(orig_entry, head, list) {\r\nif (best_entry == orig_entry)\r\ncontinue;\r\nvlan = batadv_orig_node_vlan_get(orig_entry->orig_node,\r\ntt_common_entry->vid);\r\nif (!vlan) {\r\nseq_printf(seq,\r\n" + Cannot retrieve VLAN %d for originator %pM\n",\r\nBATADV_PRINT_VID(tt_common_entry->vid),\r\norig_entry->orig_node->orig);\r\ncontinue;\r\n}\r\nlast_ttvn = atomic_read(&orig_entry->orig_node->last_ttvn);\r\nseq_printf(seq,\r\n" %c %pM %4d (%3u) via %pM (%3u) (%#.8x) [%c%c%c%c]\n",\r\n'+', tt_global_entry->common.addr,\r\nBATADV_PRINT_VID(tt_global_entry->common.vid),\r\norig_entry->ttvn, orig_entry->orig_node->orig,\r\nlast_ttvn, vlan->tt.crc,\r\n(flags & BATADV_TT_CLIENT_ROAM ? 'R' : '.'),\r\n(flags & BATADV_TT_CLIENT_WIFI ? 'W' : '.'),\r\n(flags & BATADV_TT_CLIENT_ISOLA ? 'I' : '.'),\r\n(flags & BATADV_TT_CLIENT_TEMP ? 'T' : '.'));\r\nbatadv_orig_node_vlan_free_ref(vlan);\r\n}\r\n}\r\nint batadv_tt_global_seq_print_text(struct seq_file *seq, void *offset)\r\n{\r\nstruct net_device *net_dev = (struct net_device *)seq->private;\r\nstruct batadv_priv *bat_priv = netdev_priv(net_dev);\r\nstruct batadv_hashtable *hash = bat_priv->tt.global_hash;\r\nstruct batadv_tt_common_entry *tt_common_entry;\r\nstruct batadv_tt_global_entry *tt_global;\r\nstruct batadv_hard_iface *primary_if;\r\nstruct hlist_head *head;\r\nuint32_t i;\r\nprimary_if = batadv_seq_print_text_primary_if_get(seq);\r\nif (!primary_if)\r\ngoto out;\r\nseq_printf(seq,\r\n"Globally announced TT entries received via the mesh %s\n",\r\nnet_dev->name);\r\nseq_printf(seq, " %-13s %s %s %-15s %s (%-10s) %s\n",\r\n"Client", "VID", "(TTVN)", "Originator", "(Curr TTVN)",\r\n"CRC", "Flags");\r\nfor (i = 0; i < hash->size; i++) {\r\nhead = &hash->table[i];\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(tt_common_entry,\r\nhead, hash_entry) {\r\ntt_global = container_of(tt_common_entry,\r\nstruct batadv_tt_global_entry,\r\ncommon);\r\nbatadv_tt_global_print_entry(bat_priv, tt_global, seq);\r\n}\r\nrcu_read_unlock();\r\n}\r\nout:\r\nif (primary_if)\r\nbatadv_hardif_free_ref(primary_if);\r\nreturn 0;\r\n}\r\nstatic void\r\nbatadv_tt_global_del_orig_entry(struct batadv_tt_global_entry *tt_global_entry,\r\nstruct batadv_tt_orig_list_entry *orig_entry)\r\n{\r\nbatadv_tt_global_size_dec(orig_entry->orig_node,\r\ntt_global_entry->common.vid);\r\natomic_dec(&tt_global_entry->orig_list_count);\r\nhlist_del_rcu(&orig_entry->list);\r\nbatadv_tt_orig_list_entry_free_ref(orig_entry);\r\n}\r\nstatic void\r\nbatadv_tt_global_del_orig_list(struct batadv_tt_global_entry *tt_global_entry)\r\n{\r\nstruct hlist_head *head;\r\nstruct hlist_node *safe;\r\nstruct batadv_tt_orig_list_entry *orig_entry;\r\nspin_lock_bh(&tt_global_entry->list_lock);\r\nhead = &tt_global_entry->orig_list;\r\nhlist_for_each_entry_safe(orig_entry, safe, head, list)\r\nbatadv_tt_global_del_orig_entry(tt_global_entry, orig_entry);\r\nspin_unlock_bh(&tt_global_entry->list_lock);\r\n}\r\nstatic void\r\nbatadv_tt_global_del_orig_node(struct batadv_priv *bat_priv,\r\nstruct batadv_tt_global_entry *tt_global_entry,\r\nstruct batadv_orig_node *orig_node,\r\nconst char *message)\r\n{\r\nstruct hlist_head *head;\r\nstruct hlist_node *safe;\r\nstruct batadv_tt_orig_list_entry *orig_entry;\r\nunsigned short vid;\r\nspin_lock_bh(&tt_global_entry->list_lock);\r\nhead = &tt_global_entry->orig_list;\r\nhlist_for_each_entry_safe(orig_entry, safe, head, list) {\r\nif (orig_entry->orig_node == orig_node) {\r\nvid = tt_global_entry->common.vid;\r\nbatadv_dbg(BATADV_DBG_TT, bat_priv,\r\n"Deleting %pM from global tt entry %pM (vid: %d): %s\n",\r\norig_node->orig,\r\ntt_global_entry->common.addr,\r\nBATADV_PRINT_VID(vid), message);\r\nbatadv_tt_global_del_orig_entry(tt_global_entry,\r\norig_entry);\r\n}\r\n}\r\nspin_unlock_bh(&tt_global_entry->list_lock);\r\n}\r\nstatic void\r\nbatadv_tt_global_del_roaming(struct batadv_priv *bat_priv,\r\nstruct batadv_tt_global_entry *tt_global_entry,\r\nstruct batadv_orig_node *orig_node,\r\nconst char *message)\r\n{\r\nbool last_entry = true;\r\nstruct hlist_head *head;\r\nstruct batadv_tt_orig_list_entry *orig_entry;\r\nrcu_read_lock();\r\nhead = &tt_global_entry->orig_list;\r\nhlist_for_each_entry_rcu(orig_entry, head, list) {\r\nif (orig_entry->orig_node != orig_node) {\r\nlast_entry = false;\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\nif (last_entry) {\r\ntt_global_entry->common.flags |= BATADV_TT_CLIENT_ROAM;\r\ntt_global_entry->roam_at = jiffies;\r\n} else\r\nbatadv_tt_global_del_orig_node(bat_priv, tt_global_entry,\r\norig_node, message);\r\n}\r\nstatic void batadv_tt_global_del(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig_node,\r\nconst unsigned char *addr, unsigned short vid,\r\nconst char *message, bool roaming)\r\n{\r\nstruct batadv_tt_global_entry *tt_global_entry;\r\nstruct batadv_tt_local_entry *local_entry = NULL;\r\ntt_global_entry = batadv_tt_global_hash_find(bat_priv, addr, vid);\r\nif (!tt_global_entry)\r\ngoto out;\r\nif (!roaming) {\r\nbatadv_tt_global_del_orig_node(bat_priv, tt_global_entry,\r\norig_node, message);\r\nif (hlist_empty(&tt_global_entry->orig_list))\r\nbatadv_tt_global_free(bat_priv, tt_global_entry,\r\nmessage);\r\ngoto out;\r\n}\r\nlocal_entry = batadv_tt_local_hash_find(bat_priv,\r\ntt_global_entry->common.addr,\r\nvid);\r\nif (local_entry) {\r\nbatadv_tt_global_del_orig_list(tt_global_entry);\r\nbatadv_tt_global_free(bat_priv, tt_global_entry, message);\r\n} else\r\nbatadv_tt_global_del_roaming(bat_priv, tt_global_entry,\r\norig_node, message);\r\nout:\r\nif (tt_global_entry)\r\nbatadv_tt_global_entry_free_ref(tt_global_entry);\r\nif (local_entry)\r\nbatadv_tt_local_entry_free_ref(local_entry);\r\n}\r\nvoid batadv_tt_global_del_orig(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig_node,\r\nint32_t match_vid,\r\nconst char *message)\r\n{\r\nstruct batadv_tt_global_entry *tt_global;\r\nstruct batadv_tt_common_entry *tt_common_entry;\r\nuint32_t i;\r\nstruct batadv_hashtable *hash = bat_priv->tt.global_hash;\r\nstruct hlist_node *safe;\r\nstruct hlist_head *head;\r\nspinlock_t *list_lock;\r\nunsigned short vid;\r\nif (!hash)\r\nreturn;\r\nfor (i = 0; i < hash->size; i++) {\r\nhead = &hash->table[i];\r\nlist_lock = &hash->list_locks[i];\r\nspin_lock_bh(list_lock);\r\nhlist_for_each_entry_safe(tt_common_entry, safe,\r\nhead, hash_entry) {\r\nif (match_vid >= 0 && tt_common_entry->vid != match_vid)\r\ncontinue;\r\ntt_global = container_of(tt_common_entry,\r\nstruct batadv_tt_global_entry,\r\ncommon);\r\nbatadv_tt_global_del_orig_node(bat_priv, tt_global,\r\norig_node, message);\r\nif (hlist_empty(&tt_global->orig_list)) {\r\nvid = tt_global->common.vid;\r\nbatadv_dbg(BATADV_DBG_TT, bat_priv,\r\n"Deleting global tt entry %pM (vid: %d): %s\n",\r\ntt_global->common.addr,\r\nBATADV_PRINT_VID(vid), message);\r\nhlist_del_rcu(&tt_common_entry->hash_entry);\r\nbatadv_tt_global_entry_free_ref(tt_global);\r\n}\r\n}\r\nspin_unlock_bh(list_lock);\r\n}\r\norig_node->capa_initialized &= ~BATADV_ORIG_CAPA_HAS_TT;\r\n}\r\nstatic bool batadv_tt_global_to_purge(struct batadv_tt_global_entry *tt_global,\r\nchar **msg)\r\n{\r\nbool purge = false;\r\nunsigned long roam_timeout = BATADV_TT_CLIENT_ROAM_TIMEOUT;\r\nunsigned long temp_timeout = BATADV_TT_CLIENT_TEMP_TIMEOUT;\r\nif ((tt_global->common.flags & BATADV_TT_CLIENT_ROAM) &&\r\nbatadv_has_timed_out(tt_global->roam_at, roam_timeout)) {\r\npurge = true;\r\n*msg = "Roaming timeout\n";\r\n}\r\nif ((tt_global->common.flags & BATADV_TT_CLIENT_TEMP) &&\r\nbatadv_has_timed_out(tt_global->common.added_at, temp_timeout)) {\r\npurge = true;\r\n*msg = "Temporary client timeout\n";\r\n}\r\nreturn purge;\r\n}\r\nstatic void batadv_tt_global_purge(struct batadv_priv *bat_priv)\r\n{\r\nstruct batadv_hashtable *hash = bat_priv->tt.global_hash;\r\nstruct hlist_head *head;\r\nstruct hlist_node *node_tmp;\r\nspinlock_t *list_lock;\r\nuint32_t i;\r\nchar *msg = NULL;\r\nstruct batadv_tt_common_entry *tt_common;\r\nstruct batadv_tt_global_entry *tt_global;\r\nfor (i = 0; i < hash->size; i++) {\r\nhead = &hash->table[i];\r\nlist_lock = &hash->list_locks[i];\r\nspin_lock_bh(list_lock);\r\nhlist_for_each_entry_safe(tt_common, node_tmp, head,\r\nhash_entry) {\r\ntt_global = container_of(tt_common,\r\nstruct batadv_tt_global_entry,\r\ncommon);\r\nif (!batadv_tt_global_to_purge(tt_global, &msg))\r\ncontinue;\r\nbatadv_dbg(BATADV_DBG_TT, bat_priv,\r\n"Deleting global tt entry %pM (vid: %d): %s\n",\r\ntt_global->common.addr,\r\nBATADV_PRINT_VID(tt_global->common.vid),\r\nmsg);\r\nhlist_del_rcu(&tt_common->hash_entry);\r\nbatadv_tt_global_entry_free_ref(tt_global);\r\n}\r\nspin_unlock_bh(list_lock);\r\n}\r\n}\r\nstatic void batadv_tt_global_table_free(struct batadv_priv *bat_priv)\r\n{\r\nstruct batadv_hashtable *hash;\r\nspinlock_t *list_lock;\r\nstruct batadv_tt_common_entry *tt_common_entry;\r\nstruct batadv_tt_global_entry *tt_global;\r\nstruct hlist_node *node_tmp;\r\nstruct hlist_head *head;\r\nuint32_t i;\r\nif (!bat_priv->tt.global_hash)\r\nreturn;\r\nhash = bat_priv->tt.global_hash;\r\nfor (i = 0; i < hash->size; i++) {\r\nhead = &hash->table[i];\r\nlist_lock = &hash->list_locks[i];\r\nspin_lock_bh(list_lock);\r\nhlist_for_each_entry_safe(tt_common_entry, node_tmp,\r\nhead, hash_entry) {\r\nhlist_del_rcu(&tt_common_entry->hash_entry);\r\ntt_global = container_of(tt_common_entry,\r\nstruct batadv_tt_global_entry,\r\ncommon);\r\nbatadv_tt_global_entry_free_ref(tt_global);\r\n}\r\nspin_unlock_bh(list_lock);\r\n}\r\nbatadv_hash_destroy(hash);\r\nbat_priv->tt.global_hash = NULL;\r\n}\r\nstatic bool\r\n_batadv_is_ap_isolated(struct batadv_tt_local_entry *tt_local_entry,\r\nstruct batadv_tt_global_entry *tt_global_entry)\r\n{\r\nbool ret = false;\r\nif (tt_local_entry->common.flags & BATADV_TT_CLIENT_WIFI &&\r\ntt_global_entry->common.flags & BATADV_TT_CLIENT_WIFI)\r\nret = true;\r\nif (tt_local_entry->common.flags & BATADV_TT_CLIENT_ISOLA &&\r\ntt_global_entry->common.flags & BATADV_TT_CLIENT_ISOLA)\r\nret = true;\r\nreturn ret;\r\n}\r\nstruct batadv_orig_node *batadv_transtable_search(struct batadv_priv *bat_priv,\r\nconst uint8_t *src,\r\nconst uint8_t *addr,\r\nunsigned short vid)\r\n{\r\nstruct batadv_tt_local_entry *tt_local_entry = NULL;\r\nstruct batadv_tt_global_entry *tt_global_entry = NULL;\r\nstruct batadv_orig_node *orig_node = NULL;\r\nstruct batadv_tt_orig_list_entry *best_entry;\r\nif (src && batadv_vlan_ap_isola_get(bat_priv, vid)) {\r\ntt_local_entry = batadv_tt_local_hash_find(bat_priv, src, vid);\r\nif (!tt_local_entry ||\r\n(tt_local_entry->common.flags & BATADV_TT_CLIENT_PENDING))\r\ngoto out;\r\n}\r\ntt_global_entry = batadv_tt_global_hash_find(bat_priv, addr, vid);\r\nif (!tt_global_entry)\r\ngoto out;\r\nif (tt_local_entry &&\r\n_batadv_is_ap_isolated(tt_local_entry, tt_global_entry))\r\ngoto out;\r\nrcu_read_lock();\r\nbest_entry = batadv_transtable_best_orig(bat_priv, tt_global_entry);\r\nif (best_entry)\r\norig_node = best_entry->orig_node;\r\nif (orig_node && !atomic_inc_not_zero(&orig_node->refcount))\r\norig_node = NULL;\r\nrcu_read_unlock();\r\nout:\r\nif (tt_global_entry)\r\nbatadv_tt_global_entry_free_ref(tt_global_entry);\r\nif (tt_local_entry)\r\nbatadv_tt_local_entry_free_ref(tt_local_entry);\r\nreturn orig_node;\r\n}\r\nstatic uint32_t batadv_tt_global_crc(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig_node,\r\nunsigned short vid)\r\n{\r\nstruct batadv_hashtable *hash = bat_priv->tt.global_hash;\r\nstruct batadv_tt_common_entry *tt_common;\r\nstruct batadv_tt_global_entry *tt_global;\r\nstruct hlist_head *head;\r\nuint32_t i, crc_tmp, crc = 0;\r\nuint8_t flags;\r\n__be16 tmp_vid;\r\nfor (i = 0; i < hash->size; i++) {\r\nhead = &hash->table[i];\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(tt_common, head, hash_entry) {\r\ntt_global = container_of(tt_common,\r\nstruct batadv_tt_global_entry,\r\ncommon);\r\nif (tt_common->vid != vid)\r\ncontinue;\r\nif (tt_common->flags & BATADV_TT_CLIENT_ROAM)\r\ncontinue;\r\nif (tt_common->flags & BATADV_TT_CLIENT_TEMP)\r\ncontinue;\r\nif (!batadv_tt_global_entry_has_orig(tt_global,\r\norig_node))\r\ncontinue;\r\ntmp_vid = htons(tt_common->vid);\r\ncrc_tmp = crc32c(0, &tmp_vid, sizeof(tmp_vid));\r\nflags = tt_common->flags & BATADV_TT_SYNC_MASK;\r\ncrc_tmp = crc32c(crc_tmp, &flags, sizeof(flags));\r\ncrc ^= crc32c(crc_tmp, tt_common->addr, ETH_ALEN);\r\n}\r\nrcu_read_unlock();\r\n}\r\nreturn crc;\r\n}\r\nstatic uint32_t batadv_tt_local_crc(struct batadv_priv *bat_priv,\r\nunsigned short vid)\r\n{\r\nstruct batadv_hashtable *hash = bat_priv->tt.local_hash;\r\nstruct batadv_tt_common_entry *tt_common;\r\nstruct hlist_head *head;\r\nuint32_t i, crc_tmp, crc = 0;\r\nuint8_t flags;\r\n__be16 tmp_vid;\r\nfor (i = 0; i < hash->size; i++) {\r\nhead = &hash->table[i];\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(tt_common, head, hash_entry) {\r\nif (tt_common->vid != vid)\r\ncontinue;\r\nif (tt_common->flags & BATADV_TT_CLIENT_NEW)\r\ncontinue;\r\ntmp_vid = htons(tt_common->vid);\r\ncrc_tmp = crc32c(0, &tmp_vid, sizeof(tmp_vid));\r\nflags = tt_common->flags & BATADV_TT_SYNC_MASK;\r\ncrc_tmp = crc32c(crc_tmp, &flags, sizeof(flags));\r\ncrc ^= crc32c(crc_tmp, tt_common->addr, ETH_ALEN);\r\n}\r\nrcu_read_unlock();\r\n}\r\nreturn crc;\r\n}\r\nstatic void batadv_tt_req_list_free(struct batadv_priv *bat_priv)\r\n{\r\nstruct batadv_tt_req_node *node, *safe;\r\nspin_lock_bh(&bat_priv->tt.req_list_lock);\r\nlist_for_each_entry_safe(node, safe, &bat_priv->tt.req_list, list) {\r\nlist_del(&node->list);\r\nkfree(node);\r\n}\r\nspin_unlock_bh(&bat_priv->tt.req_list_lock);\r\n}\r\nstatic void batadv_tt_save_orig_buffer(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig_node,\r\nconst void *tt_buff,\r\nuint16_t tt_buff_len)\r\n{\r\nspin_lock_bh(&orig_node->tt_buff_lock);\r\nif (tt_buff_len > 0) {\r\nkfree(orig_node->tt_buff);\r\norig_node->tt_buff_len = 0;\r\norig_node->tt_buff = kmalloc(tt_buff_len, GFP_ATOMIC);\r\nif (orig_node->tt_buff) {\r\nmemcpy(orig_node->tt_buff, tt_buff, tt_buff_len);\r\norig_node->tt_buff_len = tt_buff_len;\r\n}\r\n}\r\nspin_unlock_bh(&orig_node->tt_buff_lock);\r\n}\r\nstatic void batadv_tt_req_purge(struct batadv_priv *bat_priv)\r\n{\r\nstruct batadv_tt_req_node *node, *safe;\r\nspin_lock_bh(&bat_priv->tt.req_list_lock);\r\nlist_for_each_entry_safe(node, safe, &bat_priv->tt.req_list, list) {\r\nif (batadv_has_timed_out(node->issued_at,\r\nBATADV_TT_REQUEST_TIMEOUT)) {\r\nlist_del(&node->list);\r\nkfree(node);\r\n}\r\n}\r\nspin_unlock_bh(&bat_priv->tt.req_list_lock);\r\n}\r\nstatic struct batadv_tt_req_node *\r\nbatadv_new_tt_req_node(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig_node)\r\n{\r\nstruct batadv_tt_req_node *tt_req_node_tmp, *tt_req_node = NULL;\r\nspin_lock_bh(&bat_priv->tt.req_list_lock);\r\nlist_for_each_entry(tt_req_node_tmp, &bat_priv->tt.req_list, list) {\r\nif (batadv_compare_eth(tt_req_node_tmp, orig_node) &&\r\n!batadv_has_timed_out(tt_req_node_tmp->issued_at,\r\nBATADV_TT_REQUEST_TIMEOUT))\r\ngoto unlock;\r\n}\r\ntt_req_node = kmalloc(sizeof(*tt_req_node), GFP_ATOMIC);\r\nif (!tt_req_node)\r\ngoto unlock;\r\nether_addr_copy(tt_req_node->addr, orig_node->orig);\r\ntt_req_node->issued_at = jiffies;\r\nlist_add(&tt_req_node->list, &bat_priv->tt.req_list);\r\nunlock:\r\nspin_unlock_bh(&bat_priv->tt.req_list_lock);\r\nreturn tt_req_node;\r\n}\r\nstatic int batadv_tt_local_valid(const void *entry_ptr, const void *data_ptr)\r\n{\r\nconst struct batadv_tt_common_entry *tt_common_entry = entry_ptr;\r\nif (tt_common_entry->flags & BATADV_TT_CLIENT_NEW)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int batadv_tt_global_valid(const void *entry_ptr,\r\nconst void *data_ptr)\r\n{\r\nconst struct batadv_tt_common_entry *tt_common_entry = entry_ptr;\r\nconst struct batadv_tt_global_entry *tt_global_entry;\r\nconst struct batadv_orig_node *orig_node = data_ptr;\r\nif (tt_common_entry->flags & BATADV_TT_CLIENT_ROAM ||\r\ntt_common_entry->flags & BATADV_TT_CLIENT_TEMP)\r\nreturn 0;\r\ntt_global_entry = container_of(tt_common_entry,\r\nstruct batadv_tt_global_entry,\r\ncommon);\r\nreturn batadv_tt_global_entry_has_orig(tt_global_entry, orig_node);\r\n}\r\nstatic void batadv_tt_tvlv_generate(struct batadv_priv *bat_priv,\r\nstruct batadv_hashtable *hash,\r\nvoid *tvlv_buff, uint16_t tt_len,\r\nint (*valid_cb)(const void *, const void *),\r\nvoid *cb_data)\r\n{\r\nstruct batadv_tt_common_entry *tt_common_entry;\r\nstruct batadv_tvlv_tt_change *tt_change;\r\nstruct hlist_head *head;\r\nuint16_t tt_tot, tt_num_entries = 0;\r\nuint32_t i;\r\ntt_tot = batadv_tt_entries(tt_len);\r\ntt_change = (struct batadv_tvlv_tt_change *)tvlv_buff;\r\nrcu_read_lock();\r\nfor (i = 0; i < hash->size; i++) {\r\nhead = &hash->table[i];\r\nhlist_for_each_entry_rcu(tt_common_entry,\r\nhead, hash_entry) {\r\nif (tt_tot == tt_num_entries)\r\nbreak;\r\nif ((valid_cb) && (!valid_cb(tt_common_entry, cb_data)))\r\ncontinue;\r\nether_addr_copy(tt_change->addr, tt_common_entry->addr);\r\ntt_change->flags = tt_common_entry->flags;\r\ntt_change->vid = htons(tt_common_entry->vid);\r\nmemset(tt_change->reserved, 0,\r\nsizeof(tt_change->reserved));\r\ntt_num_entries++;\r\ntt_change++;\r\n}\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic bool batadv_tt_global_check_crc(struct batadv_orig_node *orig_node,\r\nstruct batadv_tvlv_tt_vlan_data *tt_vlan,\r\nuint16_t num_vlan)\r\n{\r\nstruct batadv_tvlv_tt_vlan_data *tt_vlan_tmp;\r\nstruct batadv_orig_node_vlan *vlan;\r\nuint32_t crc;\r\nint i;\r\nfor (i = 0; i < num_vlan; i++) {\r\ntt_vlan_tmp = tt_vlan + i;\r\nif (batadv_bla_is_backbone_gw_orig(orig_node->bat_priv,\r\norig_node->orig,\r\nntohs(tt_vlan_tmp->vid)))\r\ncontinue;\r\nvlan = batadv_orig_node_vlan_get(orig_node,\r\nntohs(tt_vlan_tmp->vid));\r\nif (!vlan)\r\nreturn false;\r\ncrc = vlan->tt.crc;\r\nbatadv_orig_node_vlan_free_ref(vlan);\r\nif (crc != ntohl(tt_vlan_tmp->crc))\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void batadv_tt_local_update_crc(struct batadv_priv *bat_priv)\r\n{\r\nstruct batadv_softif_vlan *vlan;\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(vlan, &bat_priv->softif_vlan_list, list) {\r\nvlan->tt.crc = batadv_tt_local_crc(bat_priv, vlan->vid);\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic void batadv_tt_global_update_crc(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig_node)\r\n{\r\nstruct batadv_orig_node_vlan *vlan;\r\nuint32_t crc;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(vlan, &orig_node->vlan_list, list) {\r\nif (batadv_bla_is_backbone_gw_orig(bat_priv, orig_node->orig,\r\nvlan->vid))\r\ncontinue;\r\ncrc = batadv_tt_global_crc(bat_priv, orig_node, vlan->vid);\r\nvlan->tt.crc = crc;\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic int batadv_send_tt_request(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *dst_orig_node,\r\nuint8_t ttvn,\r\nstruct batadv_tvlv_tt_vlan_data *tt_vlan,\r\nuint16_t num_vlan, bool full_table)\r\n{\r\nstruct batadv_tvlv_tt_data *tvlv_tt_data = NULL;\r\nstruct batadv_tt_req_node *tt_req_node = NULL;\r\nstruct batadv_tvlv_tt_vlan_data *tt_vlan_req;\r\nstruct batadv_hard_iface *primary_if;\r\nbool ret = false;\r\nint i, size;\r\nprimary_if = batadv_primary_if_get_selected(bat_priv);\r\nif (!primary_if)\r\ngoto out;\r\ntt_req_node = batadv_new_tt_req_node(bat_priv, dst_orig_node);\r\nif (!tt_req_node)\r\ngoto out;\r\nsize = sizeof(*tvlv_tt_data) + sizeof(*tt_vlan_req) * num_vlan;\r\ntvlv_tt_data = kzalloc(size, GFP_ATOMIC);\r\nif (!tvlv_tt_data)\r\ngoto out;\r\ntvlv_tt_data->flags = BATADV_TT_REQUEST;\r\ntvlv_tt_data->ttvn = ttvn;\r\ntvlv_tt_data->num_vlan = htons(num_vlan);\r\ntt_vlan_req = (struct batadv_tvlv_tt_vlan_data *)(tvlv_tt_data + 1);\r\nfor (i = 0; i < num_vlan; i++) {\r\ntt_vlan_req->vid = tt_vlan->vid;\r\ntt_vlan_req->crc = tt_vlan->crc;\r\ntt_vlan_req++;\r\ntt_vlan++;\r\n}\r\nif (full_table)\r\ntvlv_tt_data->flags |= BATADV_TT_FULL_TABLE;\r\nbatadv_dbg(BATADV_DBG_TT, bat_priv, "Sending TT_REQUEST to %pM [%c]\n",\r\ndst_orig_node->orig, full_table ? 'F' : '.');\r\nbatadv_inc_counter(bat_priv, BATADV_CNT_TT_REQUEST_TX);\r\nbatadv_tvlv_unicast_send(bat_priv, primary_if->net_dev->dev_addr,\r\ndst_orig_node->orig, BATADV_TVLV_TT, 1,\r\ntvlv_tt_data, size);\r\nret = true;\r\nout:\r\nif (primary_if)\r\nbatadv_hardif_free_ref(primary_if);\r\nif (ret && tt_req_node) {\r\nspin_lock_bh(&bat_priv->tt.req_list_lock);\r\nlist_del(&tt_req_node->list);\r\nspin_unlock_bh(&bat_priv->tt.req_list_lock);\r\nkfree(tt_req_node);\r\n}\r\nkfree(tvlv_tt_data);\r\nreturn ret;\r\n}\r\nstatic bool batadv_send_other_tt_response(struct batadv_priv *bat_priv,\r\nstruct batadv_tvlv_tt_data *tt_data,\r\nuint8_t *req_src, uint8_t *req_dst)\r\n{\r\nstruct batadv_orig_node *req_dst_orig_node;\r\nstruct batadv_orig_node *res_dst_orig_node = NULL;\r\nstruct batadv_tvlv_tt_change *tt_change;\r\nstruct batadv_tvlv_tt_data *tvlv_tt_data = NULL;\r\nstruct batadv_tvlv_tt_vlan_data *tt_vlan;\r\nbool ret = false, full_table;\r\nuint8_t orig_ttvn, req_ttvn;\r\nuint16_t tvlv_len;\r\nint32_t tt_len;\r\nbatadv_dbg(BATADV_DBG_TT, bat_priv,\r\n"Received TT_REQUEST from %pM for ttvn: %u (%pM) [%c]\n",\r\nreq_src, tt_data->ttvn, req_dst,\r\n(tt_data->flags & BATADV_TT_FULL_TABLE ? 'F' : '.'));\r\nreq_dst_orig_node = batadv_orig_hash_find(bat_priv, req_dst);\r\nif (!req_dst_orig_node)\r\ngoto out;\r\nres_dst_orig_node = batadv_orig_hash_find(bat_priv, req_src);\r\nif (!res_dst_orig_node)\r\ngoto out;\r\norig_ttvn = (uint8_t)atomic_read(&req_dst_orig_node->last_ttvn);\r\nreq_ttvn = tt_data->ttvn;\r\ntt_vlan = (struct batadv_tvlv_tt_vlan_data *)(tt_data + 1);\r\nif (orig_ttvn != req_ttvn ||\r\n!batadv_tt_global_check_crc(req_dst_orig_node, tt_vlan,\r\nntohs(tt_data->num_vlan)))\r\ngoto out;\r\nif (tt_data->flags & BATADV_TT_FULL_TABLE ||\r\n!req_dst_orig_node->tt_buff)\r\nfull_table = true;\r\nelse\r\nfull_table = false;\r\nif (!full_table) {\r\nspin_lock_bh(&req_dst_orig_node->tt_buff_lock);\r\ntt_len = req_dst_orig_node->tt_buff_len;\r\ntvlv_len = batadv_tt_prepare_tvlv_global_data(req_dst_orig_node,\r\n&tvlv_tt_data,\r\n&tt_change,\r\n&tt_len);\r\nif (!tt_len)\r\ngoto unlock;\r\nmemcpy(tt_change, req_dst_orig_node->tt_buff,\r\nreq_dst_orig_node->tt_buff_len);\r\nspin_unlock_bh(&req_dst_orig_node->tt_buff_lock);\r\n} else {\r\ntt_len = -1;\r\ntvlv_len = batadv_tt_prepare_tvlv_global_data(req_dst_orig_node,\r\n&tvlv_tt_data,\r\n&tt_change,\r\n&tt_len);\r\nif (!tt_len)\r\ngoto out;\r\nbatadv_tt_tvlv_generate(bat_priv, bat_priv->tt.global_hash,\r\ntt_change, tt_len,\r\nbatadv_tt_global_valid,\r\nreq_dst_orig_node);\r\n}\r\ntt_len = sizeof(struct batadv_unicast_tvlv_packet) + tvlv_len;\r\nif (tt_len > atomic_read(&bat_priv->packet_size_max)) {\r\nnet_ratelimited_function(batadv_info, bat_priv->soft_iface,\r\n"Ignoring TT_REQUEST from %pM; Response size exceeds max packet size.\n",\r\nres_dst_orig_node->orig);\r\ngoto out;\r\n}\r\ntvlv_tt_data->flags = BATADV_TT_RESPONSE;\r\ntvlv_tt_data->ttvn = req_ttvn;\r\nif (full_table)\r\ntvlv_tt_data->flags |= BATADV_TT_FULL_TABLE;\r\nbatadv_dbg(BATADV_DBG_TT, bat_priv,\r\n"Sending TT_RESPONSE %pM for %pM [%c] (ttvn: %u)\n",\r\nres_dst_orig_node->orig, req_dst_orig_node->orig,\r\nfull_table ? 'F' : '.', req_ttvn);\r\nbatadv_inc_counter(bat_priv, BATADV_CNT_TT_RESPONSE_TX);\r\nbatadv_tvlv_unicast_send(bat_priv, req_dst_orig_node->orig,\r\nreq_src, BATADV_TVLV_TT, 1, tvlv_tt_data,\r\ntvlv_len);\r\nret = true;\r\ngoto out;\r\nunlock:\r\nspin_unlock_bh(&req_dst_orig_node->tt_buff_lock);\r\nout:\r\nif (res_dst_orig_node)\r\nbatadv_orig_node_free_ref(res_dst_orig_node);\r\nif (req_dst_orig_node)\r\nbatadv_orig_node_free_ref(req_dst_orig_node);\r\nkfree(tvlv_tt_data);\r\nreturn ret;\r\n}\r\nstatic bool batadv_send_my_tt_response(struct batadv_priv *bat_priv,\r\nstruct batadv_tvlv_tt_data *tt_data,\r\nuint8_t *req_src)\r\n{\r\nstruct batadv_tvlv_tt_data *tvlv_tt_data = NULL;\r\nstruct batadv_hard_iface *primary_if = NULL;\r\nstruct batadv_tvlv_tt_change *tt_change;\r\nstruct batadv_orig_node *orig_node;\r\nuint8_t my_ttvn, req_ttvn;\r\nuint16_t tvlv_len;\r\nbool full_table;\r\nint32_t tt_len;\r\nbatadv_dbg(BATADV_DBG_TT, bat_priv,\r\n"Received TT_REQUEST from %pM for ttvn: %u (me) [%c]\n",\r\nreq_src, tt_data->ttvn,\r\n(tt_data->flags & BATADV_TT_FULL_TABLE ? 'F' : '.'));\r\nspin_lock_bh(&bat_priv->tt.commit_lock);\r\nmy_ttvn = (uint8_t)atomic_read(&bat_priv->tt.vn);\r\nreq_ttvn = tt_data->ttvn;\r\norig_node = batadv_orig_hash_find(bat_priv, req_src);\r\nif (!orig_node)\r\ngoto out;\r\nprimary_if = batadv_primary_if_get_selected(bat_priv);\r\nif (!primary_if)\r\ngoto out;\r\nif (tt_data->flags & BATADV_TT_FULL_TABLE || my_ttvn != req_ttvn ||\r\n!bat_priv->tt.last_changeset)\r\nfull_table = true;\r\nelse\r\nfull_table = false;\r\nif (!full_table) {\r\nspin_lock_bh(&bat_priv->tt.last_changeset_lock);\r\ntt_len = bat_priv->tt.last_changeset_len;\r\ntvlv_len = batadv_tt_prepare_tvlv_local_data(bat_priv,\r\n&tvlv_tt_data,\r\n&tt_change,\r\n&tt_len);\r\nif (!tt_len)\r\ngoto unlock;\r\nmemcpy(tt_change, bat_priv->tt.last_changeset,\r\nbat_priv->tt.last_changeset_len);\r\nspin_unlock_bh(&bat_priv->tt.last_changeset_lock);\r\n} else {\r\nreq_ttvn = (uint8_t)atomic_read(&bat_priv->tt.vn);\r\ntt_len = -1;\r\ntvlv_len = batadv_tt_prepare_tvlv_local_data(bat_priv,\r\n&tvlv_tt_data,\r\n&tt_change,\r\n&tt_len);\r\nif (!tt_len)\r\ngoto out;\r\nbatadv_tt_tvlv_generate(bat_priv, bat_priv->tt.local_hash,\r\ntt_change, tt_len,\r\nbatadv_tt_local_valid, NULL);\r\n}\r\ntvlv_tt_data->flags = BATADV_TT_RESPONSE;\r\ntvlv_tt_data->ttvn = req_ttvn;\r\nif (full_table)\r\ntvlv_tt_data->flags |= BATADV_TT_FULL_TABLE;\r\nbatadv_dbg(BATADV_DBG_TT, bat_priv,\r\n"Sending TT_RESPONSE to %pM [%c] (ttvn: %u)\n",\r\norig_node->orig, full_table ? 'F' : '.', req_ttvn);\r\nbatadv_inc_counter(bat_priv, BATADV_CNT_TT_RESPONSE_TX);\r\nbatadv_tvlv_unicast_send(bat_priv, primary_if->net_dev->dev_addr,\r\nreq_src, BATADV_TVLV_TT, 1, tvlv_tt_data,\r\ntvlv_len);\r\ngoto out;\r\nunlock:\r\nspin_unlock_bh(&bat_priv->tt.last_changeset_lock);\r\nout:\r\nspin_unlock_bh(&bat_priv->tt.commit_lock);\r\nif (orig_node)\r\nbatadv_orig_node_free_ref(orig_node);\r\nif (primary_if)\r\nbatadv_hardif_free_ref(primary_if);\r\nkfree(tvlv_tt_data);\r\nreturn true;\r\n}\r\nstatic bool batadv_send_tt_response(struct batadv_priv *bat_priv,\r\nstruct batadv_tvlv_tt_data *tt_data,\r\nuint8_t *req_src, uint8_t *req_dst)\r\n{\r\nif (batadv_is_my_mac(bat_priv, req_dst))\r\nreturn batadv_send_my_tt_response(bat_priv, tt_data, req_src);\r\nreturn batadv_send_other_tt_response(bat_priv, tt_data, req_src,\r\nreq_dst);\r\n}\r\nstatic void _batadv_tt_update_changes(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig_node,\r\nstruct batadv_tvlv_tt_change *tt_change,\r\nuint16_t tt_num_changes, uint8_t ttvn)\r\n{\r\nint i;\r\nint roams;\r\nfor (i = 0; i < tt_num_changes; i++) {\r\nif ((tt_change + i)->flags & BATADV_TT_CLIENT_DEL) {\r\nroams = (tt_change + i)->flags & BATADV_TT_CLIENT_ROAM;\r\nbatadv_tt_global_del(bat_priv, orig_node,\r\n(tt_change + i)->addr,\r\nntohs((tt_change + i)->vid),\r\n"tt removed by changes",\r\nroams);\r\n} else {\r\nif (!batadv_tt_global_add(bat_priv, orig_node,\r\n(tt_change + i)->addr,\r\nntohs((tt_change + i)->vid),\r\n(tt_change + i)->flags, ttvn))\r\nreturn;\r\n}\r\n}\r\norig_node->capa_initialized |= BATADV_ORIG_CAPA_HAS_TT;\r\n}\r\nstatic void batadv_tt_fill_gtable(struct batadv_priv *bat_priv,\r\nstruct batadv_tvlv_tt_change *tt_change,\r\nuint8_t ttvn, uint8_t *resp_src,\r\nuint16_t num_entries)\r\n{\r\nstruct batadv_orig_node *orig_node;\r\norig_node = batadv_orig_hash_find(bat_priv, resp_src);\r\nif (!orig_node)\r\ngoto out;\r\nbatadv_tt_global_del_orig(bat_priv, orig_node, -1,\r\n"Received full table");\r\n_batadv_tt_update_changes(bat_priv, orig_node, tt_change, num_entries,\r\nttvn);\r\nspin_lock_bh(&orig_node->tt_buff_lock);\r\nkfree(orig_node->tt_buff);\r\norig_node->tt_buff_len = 0;\r\norig_node->tt_buff = NULL;\r\nspin_unlock_bh(&orig_node->tt_buff_lock);\r\natomic_set(&orig_node->last_ttvn, ttvn);\r\nout:\r\nif (orig_node)\r\nbatadv_orig_node_free_ref(orig_node);\r\n}\r\nstatic void batadv_tt_update_changes(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig_node,\r\nuint16_t tt_num_changes, uint8_t ttvn,\r\nstruct batadv_tvlv_tt_change *tt_change)\r\n{\r\n_batadv_tt_update_changes(bat_priv, orig_node, tt_change,\r\ntt_num_changes, ttvn);\r\nbatadv_tt_save_orig_buffer(bat_priv, orig_node, tt_change,\r\nbatadv_tt_len(tt_num_changes));\r\natomic_set(&orig_node->last_ttvn, ttvn);\r\n}\r\nbool batadv_is_my_client(struct batadv_priv *bat_priv, const uint8_t *addr,\r\nunsigned short vid)\r\n{\r\nstruct batadv_tt_local_entry *tt_local_entry;\r\nbool ret = false;\r\ntt_local_entry = batadv_tt_local_hash_find(bat_priv, addr, vid);\r\nif (!tt_local_entry)\r\ngoto out;\r\nif ((tt_local_entry->common.flags & BATADV_TT_CLIENT_PENDING) ||\r\n(tt_local_entry->common.flags & BATADV_TT_CLIENT_ROAM))\r\ngoto out;\r\nret = true;\r\nout:\r\nif (tt_local_entry)\r\nbatadv_tt_local_entry_free_ref(tt_local_entry);\r\nreturn ret;\r\n}\r\nstatic void batadv_handle_tt_response(struct batadv_priv *bat_priv,\r\nstruct batadv_tvlv_tt_data *tt_data,\r\nuint8_t *resp_src, uint16_t num_entries)\r\n{\r\nstruct batadv_tt_req_node *node, *safe;\r\nstruct batadv_orig_node *orig_node = NULL;\r\nstruct batadv_tvlv_tt_change *tt_change;\r\nuint8_t *tvlv_ptr = (uint8_t *)tt_data;\r\nuint16_t change_offset;\r\nbatadv_dbg(BATADV_DBG_TT, bat_priv,\r\n"Received TT_RESPONSE from %pM for ttvn %d t_size: %d [%c]\n",\r\nresp_src, tt_data->ttvn, num_entries,\r\n(tt_data->flags & BATADV_TT_FULL_TABLE ? 'F' : '.'));\r\norig_node = batadv_orig_hash_find(bat_priv, resp_src);\r\nif (!orig_node)\r\ngoto out;\r\nspin_lock_bh(&orig_node->tt_lock);\r\nchange_offset = sizeof(struct batadv_tvlv_tt_vlan_data);\r\nchange_offset *= ntohs(tt_data->num_vlan);\r\nchange_offset += sizeof(*tt_data);\r\ntvlv_ptr += change_offset;\r\ntt_change = (struct batadv_tvlv_tt_change *)tvlv_ptr;\r\nif (tt_data->flags & BATADV_TT_FULL_TABLE) {\r\nbatadv_tt_fill_gtable(bat_priv, tt_change, tt_data->ttvn,\r\nresp_src, num_entries);\r\n} else {\r\nbatadv_tt_update_changes(bat_priv, orig_node, num_entries,\r\ntt_data->ttvn, tt_change);\r\n}\r\nbatadv_tt_global_update_crc(bat_priv, orig_node);\r\nspin_unlock_bh(&orig_node->tt_lock);\r\nspin_lock_bh(&bat_priv->tt.req_list_lock);\r\nlist_for_each_entry_safe(node, safe, &bat_priv->tt.req_list, list) {\r\nif (!batadv_compare_eth(node->addr, resp_src))\r\ncontinue;\r\nlist_del(&node->list);\r\nkfree(node);\r\n}\r\nspin_unlock_bh(&bat_priv->tt.req_list_lock);\r\nout:\r\nif (orig_node)\r\nbatadv_orig_node_free_ref(orig_node);\r\n}\r\nstatic void batadv_tt_roam_list_free(struct batadv_priv *bat_priv)\r\n{\r\nstruct batadv_tt_roam_node *node, *safe;\r\nspin_lock_bh(&bat_priv->tt.roam_list_lock);\r\nlist_for_each_entry_safe(node, safe, &bat_priv->tt.roam_list, list) {\r\nlist_del(&node->list);\r\nkfree(node);\r\n}\r\nspin_unlock_bh(&bat_priv->tt.roam_list_lock);\r\n}\r\nstatic void batadv_tt_roam_purge(struct batadv_priv *bat_priv)\r\n{\r\nstruct batadv_tt_roam_node *node, *safe;\r\nspin_lock_bh(&bat_priv->tt.roam_list_lock);\r\nlist_for_each_entry_safe(node, safe, &bat_priv->tt.roam_list, list) {\r\nif (!batadv_has_timed_out(node->first_time,\r\nBATADV_ROAMING_MAX_TIME))\r\ncontinue;\r\nlist_del(&node->list);\r\nkfree(node);\r\n}\r\nspin_unlock_bh(&bat_priv->tt.roam_list_lock);\r\n}\r\nstatic bool batadv_tt_check_roam_count(struct batadv_priv *bat_priv,\r\nuint8_t *client)\r\n{\r\nstruct batadv_tt_roam_node *tt_roam_node;\r\nbool ret = false;\r\nspin_lock_bh(&bat_priv->tt.roam_list_lock);\r\nlist_for_each_entry(tt_roam_node, &bat_priv->tt.roam_list, list) {\r\nif (!batadv_compare_eth(tt_roam_node->addr, client))\r\ncontinue;\r\nif (batadv_has_timed_out(tt_roam_node->first_time,\r\nBATADV_ROAMING_MAX_TIME))\r\ncontinue;\r\nif (!batadv_atomic_dec_not_zero(&tt_roam_node->counter))\r\ngoto unlock;\r\nret = true;\r\nbreak;\r\n}\r\nif (!ret) {\r\ntt_roam_node = kmalloc(sizeof(*tt_roam_node), GFP_ATOMIC);\r\nif (!tt_roam_node)\r\ngoto unlock;\r\ntt_roam_node->first_time = jiffies;\r\natomic_set(&tt_roam_node->counter,\r\nBATADV_ROAMING_MAX_COUNT - 1);\r\nether_addr_copy(tt_roam_node->addr, client);\r\nlist_add(&tt_roam_node->list, &bat_priv->tt.roam_list);\r\nret = true;\r\n}\r\nunlock:\r\nspin_unlock_bh(&bat_priv->tt.roam_list_lock);\r\nreturn ret;\r\n}\r\nstatic void batadv_send_roam_adv(struct batadv_priv *bat_priv, uint8_t *client,\r\nunsigned short vid,\r\nstruct batadv_orig_node *orig_node)\r\n{\r\nstruct batadv_hard_iface *primary_if;\r\nstruct batadv_tvlv_roam_adv tvlv_roam;\r\nprimary_if = batadv_primary_if_get_selected(bat_priv);\r\nif (!primary_if)\r\ngoto out;\r\nif (!batadv_tt_check_roam_count(bat_priv, client))\r\ngoto out;\r\nbatadv_dbg(BATADV_DBG_TT, bat_priv,\r\n"Sending ROAMING_ADV to %pM (client %pM, vid: %d)\n",\r\norig_node->orig, client, BATADV_PRINT_VID(vid));\r\nbatadv_inc_counter(bat_priv, BATADV_CNT_TT_ROAM_ADV_TX);\r\nmemcpy(tvlv_roam.client, client, sizeof(tvlv_roam.client));\r\ntvlv_roam.vid = htons(vid);\r\nbatadv_tvlv_unicast_send(bat_priv, primary_if->net_dev->dev_addr,\r\norig_node->orig, BATADV_TVLV_ROAM, 1,\r\n&tvlv_roam, sizeof(tvlv_roam));\r\nout:\r\nif (primary_if)\r\nbatadv_hardif_free_ref(primary_if);\r\n}\r\nstatic void batadv_tt_purge(struct work_struct *work)\r\n{\r\nstruct delayed_work *delayed_work;\r\nstruct batadv_priv_tt *priv_tt;\r\nstruct batadv_priv *bat_priv;\r\ndelayed_work = container_of(work, struct delayed_work, work);\r\npriv_tt = container_of(delayed_work, struct batadv_priv_tt, work);\r\nbat_priv = container_of(priv_tt, struct batadv_priv, tt);\r\nbatadv_tt_local_purge(bat_priv, BATADV_TT_LOCAL_TIMEOUT);\r\nbatadv_tt_global_purge(bat_priv);\r\nbatadv_tt_req_purge(bat_priv);\r\nbatadv_tt_roam_purge(bat_priv);\r\nqueue_delayed_work(batadv_event_workqueue, &bat_priv->tt.work,\r\nmsecs_to_jiffies(BATADV_TT_WORK_PERIOD));\r\n}\r\nvoid batadv_tt_free(struct batadv_priv *bat_priv)\r\n{\r\nbatadv_tvlv_container_unregister(bat_priv, BATADV_TVLV_TT, 1);\r\nbatadv_tvlv_handler_unregister(bat_priv, BATADV_TVLV_TT, 1);\r\ncancel_delayed_work_sync(&bat_priv->tt.work);\r\nbatadv_tt_local_table_free(bat_priv);\r\nbatadv_tt_global_table_free(bat_priv);\r\nbatadv_tt_req_list_free(bat_priv);\r\nbatadv_tt_changes_list_free(bat_priv);\r\nbatadv_tt_roam_list_free(bat_priv);\r\nkfree(bat_priv->tt.last_changeset);\r\n}\r\nstatic void batadv_tt_local_set_flags(struct batadv_priv *bat_priv,\r\nuint16_t flags, bool enable, bool count)\r\n{\r\nstruct batadv_hashtable *hash = bat_priv->tt.local_hash;\r\nstruct batadv_tt_common_entry *tt_common_entry;\r\nuint16_t changed_num = 0;\r\nstruct hlist_head *head;\r\nuint32_t i;\r\nif (!hash)\r\nreturn;\r\nfor (i = 0; i < hash->size; i++) {\r\nhead = &hash->table[i];\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(tt_common_entry,\r\nhead, hash_entry) {\r\nif (enable) {\r\nif ((tt_common_entry->flags & flags) == flags)\r\ncontinue;\r\ntt_common_entry->flags |= flags;\r\n} else {\r\nif (!(tt_common_entry->flags & flags))\r\ncontinue;\r\ntt_common_entry->flags &= ~flags;\r\n}\r\nchanged_num++;\r\nif (!count)\r\ncontinue;\r\nbatadv_tt_local_size_inc(bat_priv,\r\ntt_common_entry->vid);\r\n}\r\nrcu_read_unlock();\r\n}\r\n}\r\nstatic void batadv_tt_local_purge_pending_clients(struct batadv_priv *bat_priv)\r\n{\r\nstruct batadv_hashtable *hash = bat_priv->tt.local_hash;\r\nstruct batadv_tt_common_entry *tt_common;\r\nstruct batadv_tt_local_entry *tt_local;\r\nstruct batadv_softif_vlan *vlan;\r\nstruct hlist_node *node_tmp;\r\nstruct hlist_head *head;\r\nspinlock_t *list_lock;\r\nuint32_t i;\r\nif (!hash)\r\nreturn;\r\nfor (i = 0; i < hash->size; i++) {\r\nhead = &hash->table[i];\r\nlist_lock = &hash->list_locks[i];\r\nspin_lock_bh(list_lock);\r\nhlist_for_each_entry_safe(tt_common, node_tmp, head,\r\nhash_entry) {\r\nif (!(tt_common->flags & BATADV_TT_CLIENT_PENDING))\r\ncontinue;\r\nbatadv_dbg(BATADV_DBG_TT, bat_priv,\r\n"Deleting local tt entry (%pM, vid: %d): pending\n",\r\ntt_common->addr,\r\nBATADV_PRINT_VID(tt_common->vid));\r\nbatadv_tt_local_size_dec(bat_priv, tt_common->vid);\r\nhlist_del_rcu(&tt_common->hash_entry);\r\ntt_local = container_of(tt_common,\r\nstruct batadv_tt_local_entry,\r\ncommon);\r\nvlan = batadv_softif_vlan_get(bat_priv, tt_common->vid);\r\nbatadv_softif_vlan_free_ref(vlan);\r\nbatadv_softif_vlan_free_ref(vlan);\r\nbatadv_tt_local_entry_free_ref(tt_local);\r\n}\r\nspin_unlock_bh(list_lock);\r\n}\r\n}\r\nstatic void batadv_tt_local_commit_changes_nolock(struct batadv_priv *bat_priv)\r\n{\r\nbatadv_mcast_mla_update(bat_priv);\r\nif (atomic_read(&bat_priv->tt.local_changes) < 1) {\r\nif (!batadv_atomic_dec_not_zero(&bat_priv->tt.ogm_append_cnt))\r\nbatadv_tt_tvlv_container_update(bat_priv);\r\nreturn;\r\n}\r\nbatadv_tt_local_set_flags(bat_priv, BATADV_TT_CLIENT_NEW, false, true);\r\nbatadv_tt_local_purge_pending_clients(bat_priv);\r\nbatadv_tt_local_update_crc(bat_priv);\r\natomic_inc(&bat_priv->tt.vn);\r\nbatadv_dbg(BATADV_DBG_TT, bat_priv,\r\n"Local changes committed, updating to ttvn %u\n",\r\n(uint8_t)atomic_read(&bat_priv->tt.vn));\r\natomic_set(&bat_priv->tt.ogm_append_cnt, BATADV_TT_OGM_APPEND_MAX);\r\nbatadv_tt_tvlv_container_update(bat_priv);\r\n}\r\nvoid batadv_tt_local_commit_changes(struct batadv_priv *bat_priv)\r\n{\r\nspin_lock_bh(&bat_priv->tt.commit_lock);\r\nbatadv_tt_local_commit_changes_nolock(bat_priv);\r\nspin_unlock_bh(&bat_priv->tt.commit_lock);\r\n}\r\nbool batadv_is_ap_isolated(struct batadv_priv *bat_priv, uint8_t *src,\r\nuint8_t *dst, unsigned short vid)\r\n{\r\nstruct batadv_tt_local_entry *tt_local_entry = NULL;\r\nstruct batadv_tt_global_entry *tt_global_entry = NULL;\r\nstruct batadv_softif_vlan *vlan;\r\nbool ret = false;\r\nvlan = batadv_softif_vlan_get(bat_priv, vid);\r\nif (!vlan || !atomic_read(&vlan->ap_isolation))\r\ngoto out;\r\ntt_local_entry = batadv_tt_local_hash_find(bat_priv, dst, vid);\r\nif (!tt_local_entry)\r\ngoto out;\r\ntt_global_entry = batadv_tt_global_hash_find(bat_priv, src, vid);\r\nif (!tt_global_entry)\r\ngoto out;\r\nif (!_batadv_is_ap_isolated(tt_local_entry, tt_global_entry))\r\ngoto out;\r\nret = true;\r\nout:\r\nif (vlan)\r\nbatadv_softif_vlan_free_ref(vlan);\r\nif (tt_global_entry)\r\nbatadv_tt_global_entry_free_ref(tt_global_entry);\r\nif (tt_local_entry)\r\nbatadv_tt_local_entry_free_ref(tt_local_entry);\r\nreturn ret;\r\n}\r\nstatic void batadv_tt_update_orig(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig_node,\r\nconst void *tt_buff, uint16_t tt_num_vlan,\r\nstruct batadv_tvlv_tt_change *tt_change,\r\nuint16_t tt_num_changes, uint8_t ttvn)\r\n{\r\nuint8_t orig_ttvn = (uint8_t)atomic_read(&orig_node->last_ttvn);\r\nstruct batadv_tvlv_tt_vlan_data *tt_vlan;\r\nbool full_table = true;\r\nbool has_tt_init;\r\ntt_vlan = (struct batadv_tvlv_tt_vlan_data *)tt_buff;\r\nhas_tt_init = orig_node->capa_initialized & BATADV_ORIG_CAPA_HAS_TT;\r\nif ((!has_tt_init && ttvn == 1) || ttvn - orig_ttvn == 1) {\r\nif (!tt_num_changes) {\r\nfull_table = false;\r\ngoto request_table;\r\n}\r\nspin_lock_bh(&orig_node->tt_lock);\r\nbatadv_tt_update_changes(bat_priv, orig_node, tt_num_changes,\r\nttvn, tt_change);\r\nbatadv_tt_global_update_crc(bat_priv, orig_node);\r\nspin_unlock_bh(&orig_node->tt_lock);\r\nif (!batadv_tt_global_check_crc(orig_node, tt_vlan,\r\ntt_num_vlan))\r\ngoto request_table;\r\n} else {\r\nif (!has_tt_init || ttvn != orig_ttvn ||\r\n!batadv_tt_global_check_crc(orig_node, tt_vlan,\r\ntt_num_vlan)) {\r\nrequest_table:\r\nbatadv_dbg(BATADV_DBG_TT, bat_priv,\r\n"TT inconsistency for %pM. Need to retrieve the correct information (ttvn: %u last_ttvn: %u num_changes: %u)\n",\r\norig_node->orig, ttvn, orig_ttvn,\r\ntt_num_changes);\r\nbatadv_send_tt_request(bat_priv, orig_node, ttvn,\r\ntt_vlan, tt_num_vlan,\r\nfull_table);\r\nreturn;\r\n}\r\n}\r\n}\r\nbool batadv_tt_global_client_is_roaming(struct batadv_priv *bat_priv,\r\nuint8_t *addr, unsigned short vid)\r\n{\r\nstruct batadv_tt_global_entry *tt_global_entry;\r\nbool ret = false;\r\ntt_global_entry = batadv_tt_global_hash_find(bat_priv, addr, vid);\r\nif (!tt_global_entry)\r\ngoto out;\r\nret = tt_global_entry->common.flags & BATADV_TT_CLIENT_ROAM;\r\nbatadv_tt_global_entry_free_ref(tt_global_entry);\r\nout:\r\nreturn ret;\r\n}\r\nbool batadv_tt_local_client_is_roaming(struct batadv_priv *bat_priv,\r\nuint8_t *addr, unsigned short vid)\r\n{\r\nstruct batadv_tt_local_entry *tt_local_entry;\r\nbool ret = false;\r\ntt_local_entry = batadv_tt_local_hash_find(bat_priv, addr, vid);\r\nif (!tt_local_entry)\r\ngoto out;\r\nret = tt_local_entry->common.flags & BATADV_TT_CLIENT_ROAM;\r\nbatadv_tt_local_entry_free_ref(tt_local_entry);\r\nout:\r\nreturn ret;\r\n}\r\nbool batadv_tt_add_temporary_global_entry(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig_node,\r\nconst unsigned char *addr,\r\nunsigned short vid)\r\n{\r\nbool ret = false;\r\nif (!batadv_tt_global_add(bat_priv, orig_node, addr, vid,\r\nBATADV_TT_CLIENT_TEMP,\r\natomic_read(&orig_node->last_ttvn)))\r\ngoto out;\r\nbatadv_dbg(BATADV_DBG_TT, bat_priv,\r\n"Added temporary global client (addr: %pM, vid: %d, orig: %pM)\n",\r\naddr, BATADV_PRINT_VID(vid), orig_node->orig);\r\nret = true;\r\nout:\r\nreturn ret;\r\n}\r\nvoid batadv_tt_local_resize_to_mtu(struct net_device *soft_iface)\r\n{\r\nstruct batadv_priv *bat_priv = netdev_priv(soft_iface);\r\nint packet_size_max = atomic_read(&bat_priv->packet_size_max);\r\nint table_size, timeout = BATADV_TT_LOCAL_TIMEOUT / 2;\r\nbool reduced = false;\r\nspin_lock_bh(&bat_priv->tt.commit_lock);\r\nwhile (true) {\r\ntable_size = batadv_tt_local_table_transmit_size(bat_priv);\r\nif (packet_size_max >= table_size)\r\nbreak;\r\nbatadv_tt_local_purge(bat_priv, timeout);\r\nbatadv_tt_local_purge_pending_clients(bat_priv);\r\ntimeout /= 2;\r\nreduced = true;\r\nnet_ratelimited_function(batadv_info, soft_iface,\r\n"Forced to purge local tt entries to fit new maximum fragment MTU (%i)\n",\r\npacket_size_max);\r\n}\r\nif (reduced)\r\nbatadv_tt_local_commit_changes_nolock(bat_priv);\r\nspin_unlock_bh(&bat_priv->tt.commit_lock);\r\n}\r\nstatic void batadv_tt_tvlv_ogm_handler_v1(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig,\r\nuint8_t flags, void *tvlv_value,\r\nuint16_t tvlv_value_len)\r\n{\r\nstruct batadv_tvlv_tt_vlan_data *tt_vlan;\r\nstruct batadv_tvlv_tt_change *tt_change;\r\nstruct batadv_tvlv_tt_data *tt_data;\r\nuint16_t num_entries, num_vlan;\r\nif (tvlv_value_len < sizeof(*tt_data))\r\nreturn;\r\ntt_data = (struct batadv_tvlv_tt_data *)tvlv_value;\r\ntvlv_value_len -= sizeof(*tt_data);\r\nnum_vlan = ntohs(tt_data->num_vlan);\r\nif (tvlv_value_len < sizeof(*tt_vlan) * num_vlan)\r\nreturn;\r\ntt_vlan = (struct batadv_tvlv_tt_vlan_data *)(tt_data + 1);\r\ntt_change = (struct batadv_tvlv_tt_change *)(tt_vlan + num_vlan);\r\ntvlv_value_len -= sizeof(*tt_vlan) * num_vlan;\r\nnum_entries = batadv_tt_entries(tvlv_value_len);\r\nbatadv_tt_update_orig(bat_priv, orig, tt_vlan, num_vlan, tt_change,\r\nnum_entries, tt_data->ttvn);\r\n}\r\nstatic int batadv_tt_tvlv_unicast_handler_v1(struct batadv_priv *bat_priv,\r\nuint8_t *src, uint8_t *dst,\r\nvoid *tvlv_value,\r\nuint16_t tvlv_value_len)\r\n{\r\nstruct batadv_tvlv_tt_data *tt_data;\r\nuint16_t tt_vlan_len, tt_num_entries;\r\nchar tt_flag;\r\nbool ret;\r\nif (tvlv_value_len < sizeof(*tt_data))\r\nreturn NET_RX_SUCCESS;\r\ntt_data = (struct batadv_tvlv_tt_data *)tvlv_value;\r\ntvlv_value_len -= sizeof(*tt_data);\r\ntt_vlan_len = sizeof(struct batadv_tvlv_tt_vlan_data);\r\ntt_vlan_len *= ntohs(tt_data->num_vlan);\r\nif (tvlv_value_len < tt_vlan_len)\r\nreturn NET_RX_SUCCESS;\r\ntvlv_value_len -= tt_vlan_len;\r\ntt_num_entries = batadv_tt_entries(tvlv_value_len);\r\nswitch (tt_data->flags & BATADV_TT_DATA_TYPE_MASK) {\r\ncase BATADV_TT_REQUEST:\r\nbatadv_inc_counter(bat_priv, BATADV_CNT_TT_REQUEST_RX);\r\nret = batadv_send_tt_response(bat_priv, tt_data, src, dst);\r\nif (!ret) {\r\nif (tt_data->flags & BATADV_TT_FULL_TABLE)\r\ntt_flag = 'F';\r\nelse\r\ntt_flag = '.';\r\nbatadv_dbg(BATADV_DBG_TT, bat_priv,\r\n"Routing TT_REQUEST to %pM [%c]\n",\r\ndst, tt_flag);\r\nreturn NET_RX_DROP;\r\n}\r\nbreak;\r\ncase BATADV_TT_RESPONSE:\r\nbatadv_inc_counter(bat_priv, BATADV_CNT_TT_RESPONSE_RX);\r\nif (batadv_is_my_mac(bat_priv, dst)) {\r\nbatadv_handle_tt_response(bat_priv, tt_data,\r\nsrc, tt_num_entries);\r\nreturn NET_RX_SUCCESS;\r\n}\r\nif (tt_data->flags & BATADV_TT_FULL_TABLE)\r\ntt_flag = 'F';\r\nelse\r\ntt_flag = '.';\r\nbatadv_dbg(BATADV_DBG_TT, bat_priv,\r\n"Routing TT_RESPONSE to %pM [%c]\n", dst, tt_flag);\r\nreturn NET_RX_DROP;\r\n}\r\nreturn NET_RX_SUCCESS;\r\n}\r\nstatic int batadv_roam_tvlv_unicast_handler_v1(struct batadv_priv *bat_priv,\r\nuint8_t *src, uint8_t *dst,\r\nvoid *tvlv_value,\r\nuint16_t tvlv_value_len)\r\n{\r\nstruct batadv_tvlv_roam_adv *roaming_adv;\r\nstruct batadv_orig_node *orig_node = NULL;\r\nif (!batadv_is_my_mac(bat_priv, dst))\r\nreturn NET_RX_DROP;\r\nif (tvlv_value_len < sizeof(*roaming_adv))\r\ngoto out;\r\norig_node = batadv_orig_hash_find(bat_priv, src);\r\nif (!orig_node)\r\ngoto out;\r\nbatadv_inc_counter(bat_priv, BATADV_CNT_TT_ROAM_ADV_RX);\r\nroaming_adv = (struct batadv_tvlv_roam_adv *)tvlv_value;\r\nbatadv_dbg(BATADV_DBG_TT, bat_priv,\r\n"Received ROAMING_ADV from %pM (client %pM)\n",\r\nsrc, roaming_adv->client);\r\nbatadv_tt_global_add(bat_priv, orig_node, roaming_adv->client,\r\nntohs(roaming_adv->vid), BATADV_TT_CLIENT_ROAM,\r\natomic_read(&orig_node->last_ttvn) + 1);\r\nout:\r\nif (orig_node)\r\nbatadv_orig_node_free_ref(orig_node);\r\nreturn NET_RX_SUCCESS;\r\n}\r\nint batadv_tt_init(struct batadv_priv *bat_priv)\r\n{\r\nint ret;\r\nBUILD_BUG_ON(!(BATADV_TT_SYNC_MASK & BATADV_TT_REMOTE_MASK));\r\nret = batadv_tt_local_init(bat_priv);\r\nif (ret < 0)\r\nreturn ret;\r\nret = batadv_tt_global_init(bat_priv);\r\nif (ret < 0)\r\nreturn ret;\r\nbatadv_tvlv_handler_register(bat_priv, batadv_tt_tvlv_ogm_handler_v1,\r\nbatadv_tt_tvlv_unicast_handler_v1,\r\nBATADV_TVLV_TT, 1, BATADV_NO_FLAGS);\r\nbatadv_tvlv_handler_register(bat_priv, NULL,\r\nbatadv_roam_tvlv_unicast_handler_v1,\r\nBATADV_TVLV_ROAM, 1, BATADV_NO_FLAGS);\r\nINIT_DELAYED_WORK(&bat_priv->tt.work, batadv_tt_purge);\r\nqueue_delayed_work(batadv_event_workqueue, &bat_priv->tt.work,\r\nmsecs_to_jiffies(BATADV_TT_WORK_PERIOD));\r\nreturn 1;\r\n}\r\nbool batadv_tt_global_is_isolated(struct batadv_priv *bat_priv,\r\nconst uint8_t *addr, unsigned short vid)\r\n{\r\nstruct batadv_tt_global_entry *tt;\r\nbool ret;\r\ntt = batadv_tt_global_hash_find(bat_priv, addr, vid);\r\nif (!tt)\r\nreturn false;\r\nret = tt->common.flags & BATADV_TT_CLIENT_ISOLA;\r\nbatadv_tt_global_entry_free_ref(tt);\r\nreturn ret;\r\n}
