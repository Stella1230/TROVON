static void spi_sirfsoc_rx_word_u8(struct sirfsoc_spi *sspi)\r\n{\r\nu32 data;\r\nu8 *rx = sspi->rx;\r\ndata = readl(sspi->base + SIRFSOC_SPI_RXFIFO_DATA);\r\nif (rx) {\r\n*rx++ = (u8) data;\r\nsspi->rx = rx;\r\n}\r\nsspi->left_rx_word--;\r\n}\r\nstatic void spi_sirfsoc_tx_word_u8(struct sirfsoc_spi *sspi)\r\n{\r\nu32 data = 0;\r\nconst u8 *tx = sspi->tx;\r\nif (tx) {\r\ndata = *tx++;\r\nsspi->tx = tx;\r\n}\r\nwritel(data, sspi->base + SIRFSOC_SPI_TXFIFO_DATA);\r\nsspi->left_tx_word--;\r\n}\r\nstatic void spi_sirfsoc_rx_word_u16(struct sirfsoc_spi *sspi)\r\n{\r\nu32 data;\r\nu16 *rx = sspi->rx;\r\ndata = readl(sspi->base + SIRFSOC_SPI_RXFIFO_DATA);\r\nif (rx) {\r\n*rx++ = (u16) data;\r\nsspi->rx = rx;\r\n}\r\nsspi->left_rx_word--;\r\n}\r\nstatic void spi_sirfsoc_tx_word_u16(struct sirfsoc_spi *sspi)\r\n{\r\nu32 data = 0;\r\nconst u16 *tx = sspi->tx;\r\nif (tx) {\r\ndata = *tx++;\r\nsspi->tx = tx;\r\n}\r\nwritel(data, sspi->base + SIRFSOC_SPI_TXFIFO_DATA);\r\nsspi->left_tx_word--;\r\n}\r\nstatic void spi_sirfsoc_rx_word_u32(struct sirfsoc_spi *sspi)\r\n{\r\nu32 data;\r\nu32 *rx = sspi->rx;\r\ndata = readl(sspi->base + SIRFSOC_SPI_RXFIFO_DATA);\r\nif (rx) {\r\n*rx++ = (u32) data;\r\nsspi->rx = rx;\r\n}\r\nsspi->left_rx_word--;\r\n}\r\nstatic void spi_sirfsoc_tx_word_u32(struct sirfsoc_spi *sspi)\r\n{\r\nu32 data = 0;\r\nconst u32 *tx = sspi->tx;\r\nif (tx) {\r\ndata = *tx++;\r\nsspi->tx = tx;\r\n}\r\nwritel(data, sspi->base + SIRFSOC_SPI_TXFIFO_DATA);\r\nsspi->left_tx_word--;\r\n}\r\nstatic irqreturn_t spi_sirfsoc_irq(int irq, void *dev_id)\r\n{\r\nstruct sirfsoc_spi *sspi = dev_id;\r\nu32 spi_stat = readl(sspi->base + SIRFSOC_SPI_INT_STATUS);\r\nif (sspi->tx_by_cmd && (spi_stat & SIRFSOC_SPI_FRM_END)) {\r\ncomplete(&sspi->tx_done);\r\nwritel(0x0, sspi->base + SIRFSOC_SPI_INT_EN);\r\nwritel(SIRFSOC_SPI_INT_MASK_ALL,\r\nsspi->base + SIRFSOC_SPI_INT_STATUS);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (spi_stat & SIRFSOC_SPI_RX_OFLOW ||\r\nspi_stat & SIRFSOC_SPI_TX_UFLOW) {\r\ncomplete(&sspi->tx_done);\r\ncomplete(&sspi->rx_done);\r\nwritel(0x0, sspi->base + SIRFSOC_SPI_INT_EN);\r\nwritel(SIRFSOC_SPI_INT_MASK_ALL,\r\nsspi->base + SIRFSOC_SPI_INT_STATUS);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (spi_stat & SIRFSOC_SPI_TXFIFO_EMPTY)\r\ncomplete(&sspi->tx_done);\r\nwhile (!(readl(sspi->base + SIRFSOC_SPI_INT_STATUS) &\r\nSIRFSOC_SPI_RX_IO_DMA))\r\ncpu_relax();\r\ncomplete(&sspi->rx_done);\r\nwritel(0x0, sspi->base + SIRFSOC_SPI_INT_EN);\r\nwritel(SIRFSOC_SPI_INT_MASK_ALL,\r\nsspi->base + SIRFSOC_SPI_INT_STATUS);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void spi_sirfsoc_dma_fini_callback(void *data)\r\n{\r\nstruct completion *dma_complete = data;\r\ncomplete(dma_complete);\r\n}\r\nstatic void spi_sirfsoc_cmd_transfer(struct spi_device *spi,\r\nstruct spi_transfer *t)\r\n{\r\nstruct sirfsoc_spi *sspi;\r\nint timeout = t->len * 10;\r\nu32 cmd;\r\nsspi = spi_master_get_devdata(spi->master);\r\nwritel(SIRFSOC_SPI_FIFO_RESET, sspi->base + SIRFSOC_SPI_TXFIFO_OP);\r\nwritel(SIRFSOC_SPI_FIFO_START, sspi->base + SIRFSOC_SPI_TXFIFO_OP);\r\nmemcpy(&cmd, sspi->tx, t->len);\r\nif (sspi->word_width == 1 && !(spi->mode & SPI_LSB_FIRST))\r\ncmd = cpu_to_be32(cmd) >>\r\n((SIRFSOC_MAX_CMD_BYTES - t->len) * 8);\r\nif (sspi->word_width == 2 && t->len == 4 &&\r\n(!(spi->mode & SPI_LSB_FIRST)))\r\ncmd = ((cmd & 0xffff) << 16) | (cmd >> 16);\r\nwritel(cmd, sspi->base + SIRFSOC_SPI_CMD);\r\nwritel(SIRFSOC_SPI_FRM_END_INT_EN,\r\nsspi->base + SIRFSOC_SPI_INT_EN);\r\nwritel(SIRFSOC_SPI_CMD_TX_EN,\r\nsspi->base + SIRFSOC_SPI_TX_RX_EN);\r\nif (wait_for_completion_timeout(&sspi->tx_done, timeout) == 0) {\r\ndev_err(&spi->dev, "cmd transfer timeout\n");\r\nreturn;\r\n}\r\nsspi->left_rx_word -= t->len;\r\n}\r\nstatic void spi_sirfsoc_dma_transfer(struct spi_device *spi,\r\nstruct spi_transfer *t)\r\n{\r\nstruct sirfsoc_spi *sspi;\r\nstruct dma_async_tx_descriptor *rx_desc, *tx_desc;\r\nint timeout = t->len * 10;\r\nsspi = spi_master_get_devdata(spi->master);\r\nwritel(SIRFSOC_SPI_FIFO_RESET, sspi->base + SIRFSOC_SPI_RXFIFO_OP);\r\nwritel(SIRFSOC_SPI_FIFO_RESET, sspi->base + SIRFSOC_SPI_TXFIFO_OP);\r\nwritel(SIRFSOC_SPI_FIFO_START, sspi->base + SIRFSOC_SPI_RXFIFO_OP);\r\nwritel(SIRFSOC_SPI_FIFO_START, sspi->base + SIRFSOC_SPI_TXFIFO_OP);\r\nwritel(0, sspi->base + SIRFSOC_SPI_INT_EN);\r\nwritel(SIRFSOC_SPI_INT_MASK_ALL, sspi->base + SIRFSOC_SPI_INT_STATUS);\r\nif (sspi->left_tx_word < SIRFSOC_SPI_DAT_FRM_LEN_MAX) {\r\nwritel(readl(sspi->base + SIRFSOC_SPI_CTRL) |\r\nSIRFSOC_SPI_ENA_AUTO_CLR | SIRFSOC_SPI_MUL_DAT_MODE,\r\nsspi->base + SIRFSOC_SPI_CTRL);\r\nwritel(sspi->left_tx_word - 1,\r\nsspi->base + SIRFSOC_SPI_TX_DMA_IO_LEN);\r\nwritel(sspi->left_tx_word - 1,\r\nsspi->base + SIRFSOC_SPI_RX_DMA_IO_LEN);\r\n} else {\r\nwritel(readl(sspi->base + SIRFSOC_SPI_CTRL),\r\nsspi->base + SIRFSOC_SPI_CTRL);\r\nwritel(0, sspi->base + SIRFSOC_SPI_TX_DMA_IO_LEN);\r\nwritel(0, sspi->base + SIRFSOC_SPI_RX_DMA_IO_LEN);\r\n}\r\nsspi->dst_start = dma_map_single(&spi->dev, sspi->rx, t->len,\r\n(t->tx_buf != t->rx_buf) ?\r\nDMA_FROM_DEVICE : DMA_BIDIRECTIONAL);\r\nrx_desc = dmaengine_prep_slave_single(sspi->rx_chan,\r\nsspi->dst_start, t->len, DMA_DEV_TO_MEM,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nrx_desc->callback = spi_sirfsoc_dma_fini_callback;\r\nrx_desc->callback_param = &sspi->rx_done;\r\nsspi->src_start = dma_map_single(&spi->dev, (void *)sspi->tx, t->len,\r\n(t->tx_buf != t->rx_buf) ?\r\nDMA_TO_DEVICE : DMA_BIDIRECTIONAL);\r\ntx_desc = dmaengine_prep_slave_single(sspi->tx_chan,\r\nsspi->src_start, t->len, DMA_MEM_TO_DEV,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\ntx_desc->callback = spi_sirfsoc_dma_fini_callback;\r\ntx_desc->callback_param = &sspi->tx_done;\r\ndmaengine_submit(tx_desc);\r\ndmaengine_submit(rx_desc);\r\ndma_async_issue_pending(sspi->tx_chan);\r\ndma_async_issue_pending(sspi->rx_chan);\r\nwritel(SIRFSOC_SPI_RX_EN | SIRFSOC_SPI_TX_EN,\r\nsspi->base + SIRFSOC_SPI_TX_RX_EN);\r\nif (wait_for_completion_timeout(&sspi->rx_done, timeout) == 0) {\r\ndev_err(&spi->dev, "transfer timeout\n");\r\ndmaengine_terminate_all(sspi->rx_chan);\r\n} else\r\nsspi->left_rx_word = 0;\r\nif (wait_for_completion_timeout(&sspi->tx_done, timeout) == 0) {\r\ndev_err(&spi->dev, "transfer timeout\n");\r\ndmaengine_terminate_all(sspi->tx_chan);\r\n}\r\ndma_unmap_single(&spi->dev, sspi->src_start, t->len, DMA_TO_DEVICE);\r\ndma_unmap_single(&spi->dev, sspi->dst_start, t->len, DMA_FROM_DEVICE);\r\nwritel(0, sspi->base + SIRFSOC_SPI_RXFIFO_OP);\r\nwritel(0, sspi->base + SIRFSOC_SPI_TXFIFO_OP);\r\nif (sspi->left_tx_word >= SIRFSOC_SPI_DAT_FRM_LEN_MAX)\r\nwritel(0, sspi->base + SIRFSOC_SPI_TX_RX_EN);\r\n}\r\nstatic void spi_sirfsoc_pio_transfer(struct spi_device *spi,\r\nstruct spi_transfer *t)\r\n{\r\nstruct sirfsoc_spi *sspi;\r\nint timeout = t->len * 10;\r\nsspi = spi_master_get_devdata(spi->master);\r\ndo {\r\nwritel(SIRFSOC_SPI_FIFO_RESET,\r\nsspi->base + SIRFSOC_SPI_RXFIFO_OP);\r\nwritel(SIRFSOC_SPI_FIFO_RESET,\r\nsspi->base + SIRFSOC_SPI_TXFIFO_OP);\r\nwritel(SIRFSOC_SPI_FIFO_START,\r\nsspi->base + SIRFSOC_SPI_RXFIFO_OP);\r\nwritel(SIRFSOC_SPI_FIFO_START,\r\nsspi->base + SIRFSOC_SPI_TXFIFO_OP);\r\nwritel(0, sspi->base + SIRFSOC_SPI_INT_EN);\r\nwritel(SIRFSOC_SPI_INT_MASK_ALL,\r\nsspi->base + SIRFSOC_SPI_INT_STATUS);\r\nwritel(readl(sspi->base + SIRFSOC_SPI_CTRL) |\r\nSIRFSOC_SPI_MUL_DAT_MODE | SIRFSOC_SPI_ENA_AUTO_CLR,\r\nsspi->base + SIRFSOC_SPI_CTRL);\r\nwritel(min(sspi->left_tx_word, (u32)(256 / sspi->word_width))\r\n- 1, sspi->base + SIRFSOC_SPI_TX_DMA_IO_LEN);\r\nwritel(min(sspi->left_rx_word, (u32)(256 / sspi->word_width))\r\n- 1, sspi->base + SIRFSOC_SPI_RX_DMA_IO_LEN);\r\nwhile (!((readl(sspi->base + SIRFSOC_SPI_TXFIFO_STATUS)\r\n& SIRFSOC_SPI_FIFO_FULL)) && sspi->left_tx_word)\r\nsspi->tx_word(sspi);\r\nwritel(SIRFSOC_SPI_TXFIFO_EMPTY_INT_EN |\r\nSIRFSOC_SPI_TX_UFLOW_INT_EN |\r\nSIRFSOC_SPI_RX_OFLOW_INT_EN |\r\nSIRFSOC_SPI_RX_IO_DMA_INT_EN,\r\nsspi->base + SIRFSOC_SPI_INT_EN);\r\nwritel(SIRFSOC_SPI_RX_EN | SIRFSOC_SPI_TX_EN,\r\nsspi->base + SIRFSOC_SPI_TX_RX_EN);\r\nif (!wait_for_completion_timeout(&sspi->tx_done, timeout) ||\r\n!wait_for_completion_timeout(&sspi->rx_done, timeout)) {\r\ndev_err(&spi->dev, "transfer timeout\n");\r\nbreak;\r\n}\r\nwhile (!((readl(sspi->base + SIRFSOC_SPI_RXFIFO_STATUS)\r\n& SIRFSOC_SPI_FIFO_EMPTY)) && sspi->left_rx_word)\r\nsspi->rx_word(sspi);\r\nwritel(0, sspi->base + SIRFSOC_SPI_RXFIFO_OP);\r\nwritel(0, sspi->base + SIRFSOC_SPI_TXFIFO_OP);\r\n} while (sspi->left_tx_word != 0 || sspi->left_rx_word != 0);\r\n}\r\nstatic int spi_sirfsoc_transfer(struct spi_device *spi, struct spi_transfer *t)\r\n{\r\nstruct sirfsoc_spi *sspi;\r\nsspi = spi_master_get_devdata(spi->master);\r\nsspi->tx = t->tx_buf ? t->tx_buf : sspi->dummypage;\r\nsspi->rx = t->rx_buf ? t->rx_buf : sspi->dummypage;\r\nsspi->left_tx_word = sspi->left_rx_word = t->len / sspi->word_width;\r\nreinit_completion(&sspi->rx_done);\r\nreinit_completion(&sspi->tx_done);\r\nif (sspi->tx_by_cmd)\r\nspi_sirfsoc_cmd_transfer(spi, t);\r\nelse if (IS_DMA_VALID(t))\r\nspi_sirfsoc_dma_transfer(spi, t);\r\nelse\r\nspi_sirfsoc_pio_transfer(spi, t);\r\nreturn t->len - sspi->left_rx_word * sspi->word_width;\r\n}\r\nstatic void spi_sirfsoc_chipselect(struct spi_device *spi, int value)\r\n{\r\nstruct sirfsoc_spi *sspi = spi_master_get_devdata(spi->master);\r\nif (sspi->hw_cs) {\r\nu32 regval = readl(sspi->base + SIRFSOC_SPI_CTRL);\r\nswitch (value) {\r\ncase BITBANG_CS_ACTIVE:\r\nif (spi->mode & SPI_CS_HIGH)\r\nregval |= SIRFSOC_SPI_CS_IO_OUT;\r\nelse\r\nregval &= ~SIRFSOC_SPI_CS_IO_OUT;\r\nbreak;\r\ncase BITBANG_CS_INACTIVE:\r\nif (spi->mode & SPI_CS_HIGH)\r\nregval &= ~SIRFSOC_SPI_CS_IO_OUT;\r\nelse\r\nregval |= SIRFSOC_SPI_CS_IO_OUT;\r\nbreak;\r\n}\r\nwritel(regval, sspi->base + SIRFSOC_SPI_CTRL);\r\n} else {\r\nswitch (value) {\r\ncase BITBANG_CS_ACTIVE:\r\ngpio_direction_output(spi->cs_gpio,\r\nspi->mode & SPI_CS_HIGH ? 1 : 0);\r\nbreak;\r\ncase BITBANG_CS_INACTIVE:\r\ngpio_direction_output(spi->cs_gpio,\r\nspi->mode & SPI_CS_HIGH ? 0 : 1);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int\r\nspi_sirfsoc_setup_transfer(struct spi_device *spi, struct spi_transfer *t)\r\n{\r\nstruct sirfsoc_spi *sspi;\r\nu8 bits_per_word = 0;\r\nint hz = 0;\r\nu32 regval;\r\nu32 txfifo_ctrl, rxfifo_ctrl;\r\nu32 fifo_size = SIRFSOC_SPI_FIFO_SIZE / 4;\r\nsspi = spi_master_get_devdata(spi->master);\r\nbits_per_word = (t) ? t->bits_per_word : spi->bits_per_word;\r\nhz = t && t->speed_hz ? t->speed_hz : spi->max_speed_hz;\r\nregval = (sspi->ctrl_freq / (2 * hz)) - 1;\r\nif (regval > 0xFFFF || regval < 0) {\r\ndev_err(&spi->dev, "Speed %d not supported\n", hz);\r\nreturn -EINVAL;\r\n}\r\nswitch (bits_per_word) {\r\ncase 8:\r\nregval |= SIRFSOC_SPI_TRAN_DAT_FORMAT_8;\r\nsspi->rx_word = spi_sirfsoc_rx_word_u8;\r\nsspi->tx_word = spi_sirfsoc_tx_word_u8;\r\nbreak;\r\ncase 12:\r\ncase 16:\r\nregval |= (bits_per_word == 12) ?\r\nSIRFSOC_SPI_TRAN_DAT_FORMAT_12 :\r\nSIRFSOC_SPI_TRAN_DAT_FORMAT_16;\r\nsspi->rx_word = spi_sirfsoc_rx_word_u16;\r\nsspi->tx_word = spi_sirfsoc_tx_word_u16;\r\nbreak;\r\ncase 32:\r\nregval |= SIRFSOC_SPI_TRAN_DAT_FORMAT_32;\r\nsspi->rx_word = spi_sirfsoc_rx_word_u32;\r\nsspi->tx_word = spi_sirfsoc_tx_word_u32;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nsspi->word_width = DIV_ROUND_UP(bits_per_word, 8);\r\ntxfifo_ctrl = SIRFSOC_SPI_FIFO_THD(SIRFSOC_SPI_FIFO_SIZE / 2) |\r\n(sspi->word_width >> 1);\r\nrxfifo_ctrl = SIRFSOC_SPI_FIFO_THD(SIRFSOC_SPI_FIFO_SIZE / 2) |\r\n(sspi->word_width >> 1);\r\nif (!(spi->mode & SPI_CS_HIGH))\r\nregval |= SIRFSOC_SPI_CS_IDLE_STAT;\r\nif (!(spi->mode & SPI_LSB_FIRST))\r\nregval |= SIRFSOC_SPI_TRAN_MSB;\r\nif (spi->mode & SPI_CPOL)\r\nregval |= SIRFSOC_SPI_CLK_IDLE_STAT;\r\nif (((spi->mode & SPI_CPOL) && (spi->mode & SPI_CPHA)) ||\r\n(!(spi->mode & SPI_CPOL) && !(spi->mode & SPI_CPHA)))\r\nregval &= ~SIRFSOC_SPI_DRV_POS_EDGE;\r\nelse\r\nregval |= SIRFSOC_SPI_DRV_POS_EDGE;\r\nwritel(SIRFSOC_SPI_FIFO_SC(fifo_size - 2) |\r\nSIRFSOC_SPI_FIFO_LC(fifo_size / 2) |\r\nSIRFSOC_SPI_FIFO_HC(2),\r\nsspi->base + SIRFSOC_SPI_TXFIFO_LEVEL_CHK);\r\nwritel(SIRFSOC_SPI_FIFO_SC(2) |\r\nSIRFSOC_SPI_FIFO_LC(fifo_size / 2) |\r\nSIRFSOC_SPI_FIFO_HC(fifo_size - 2),\r\nsspi->base + SIRFSOC_SPI_RXFIFO_LEVEL_CHK);\r\nwritel(txfifo_ctrl, sspi->base + SIRFSOC_SPI_TXFIFO_CTRL);\r\nwritel(rxfifo_ctrl, sspi->base + SIRFSOC_SPI_RXFIFO_CTRL);\r\nif (t && t->tx_buf && !t->rx_buf && (t->len <= SIRFSOC_MAX_CMD_BYTES)) {\r\nregval |= (SIRFSOC_SPI_CMD_BYTE_NUM((t->len - 1)) |\r\nSIRFSOC_SPI_CMD_MODE);\r\nsspi->tx_by_cmd = true;\r\n} else {\r\nregval &= ~SIRFSOC_SPI_CMD_MODE;\r\nsspi->tx_by_cmd = false;\r\n}\r\nregval |= SIRFSOC_SPI_CS_IO_MODE;\r\nwritel(regval, sspi->base + SIRFSOC_SPI_CTRL);\r\nif (IS_DMA_VALID(t)) {\r\nwritel(0, sspi->base + SIRFSOC_SPI_TX_DMA_IO_CTRL);\r\nwritel(SIRFSOC_SPI_RX_DMA_FLUSH,\r\nsspi->base + SIRFSOC_SPI_RX_DMA_IO_CTRL);\r\n} else {\r\nwritel(SIRFSOC_SPI_IO_MODE_SEL,\r\nsspi->base + SIRFSOC_SPI_TX_DMA_IO_CTRL);\r\nwritel(SIRFSOC_SPI_IO_MODE_SEL,\r\nsspi->base + SIRFSOC_SPI_RX_DMA_IO_CTRL);\r\n}\r\nreturn 0;\r\n}\r\nstatic int spi_sirfsoc_setup(struct spi_device *spi)\r\n{\r\nstruct sirfsoc_spi *sspi;\r\nsspi = spi_master_get_devdata(spi->master);\r\nif (spi->cs_gpio == -ENOENT)\r\nsspi->hw_cs = true;\r\nelse\r\nsspi->hw_cs = false;\r\nreturn spi_sirfsoc_setup_transfer(spi, NULL);\r\n}\r\nstatic int spi_sirfsoc_probe(struct platform_device *pdev)\r\n{\r\nstruct sirfsoc_spi *sspi;\r\nstruct spi_master *master;\r\nstruct resource *mem_res;\r\nint irq;\r\nint i, ret;\r\nret = device_reset(&pdev->dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "SPI reset failed!\n");\r\nreturn ret;\r\n}\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(*sspi));\r\nif (!master) {\r\ndev_err(&pdev->dev, "Unable to allocate SPI master\n");\r\nreturn -ENOMEM;\r\n}\r\nplatform_set_drvdata(pdev, master);\r\nsspi = spi_master_get_devdata(master);\r\nmem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nsspi->base = devm_ioremap_resource(&pdev->dev, mem_res);\r\nif (IS_ERR(sspi->base)) {\r\nret = PTR_ERR(sspi->base);\r\ngoto free_master;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\nret = -ENXIO;\r\ngoto free_master;\r\n}\r\nret = devm_request_irq(&pdev->dev, irq, spi_sirfsoc_irq, 0,\r\nDRIVER_NAME, sspi);\r\nif (ret)\r\ngoto free_master;\r\nsspi->bitbang.master = master;\r\nsspi->bitbang.chipselect = spi_sirfsoc_chipselect;\r\nsspi->bitbang.setup_transfer = spi_sirfsoc_setup_transfer;\r\nsspi->bitbang.txrx_bufs = spi_sirfsoc_transfer;\r\nsspi->bitbang.master->setup = spi_sirfsoc_setup;\r\nmaster->bus_num = pdev->id;\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_LSB_FIRST | SPI_CS_HIGH;\r\nmaster->bits_per_word_mask = SPI_BPW_MASK(8) | SPI_BPW_MASK(12) |\r\nSPI_BPW_MASK(16) | SPI_BPW_MASK(32);\r\nmaster->max_speed_hz = SIRFSOC_SPI_DEFAULT_FRQ;\r\nsspi->bitbang.master->dev.of_node = pdev->dev.of_node;\r\nsspi->rx_chan = dma_request_slave_channel(&pdev->dev, "rx");\r\nif (!sspi->rx_chan) {\r\ndev_err(&pdev->dev, "can not allocate rx dma channel\n");\r\nret = -ENODEV;\r\ngoto free_master;\r\n}\r\nsspi->tx_chan = dma_request_slave_channel(&pdev->dev, "tx");\r\nif (!sspi->tx_chan) {\r\ndev_err(&pdev->dev, "can not allocate tx dma channel\n");\r\nret = -ENODEV;\r\ngoto free_rx_dma;\r\n}\r\nsspi->clk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(sspi->clk)) {\r\nret = PTR_ERR(sspi->clk);\r\ngoto free_tx_dma;\r\n}\r\nclk_prepare_enable(sspi->clk);\r\nsspi->ctrl_freq = clk_get_rate(sspi->clk);\r\ninit_completion(&sspi->rx_done);\r\ninit_completion(&sspi->tx_done);\r\nwritel(SIRFSOC_SPI_FIFO_RESET, sspi->base + SIRFSOC_SPI_RXFIFO_OP);\r\nwritel(SIRFSOC_SPI_FIFO_RESET, sspi->base + SIRFSOC_SPI_TXFIFO_OP);\r\nwritel(SIRFSOC_SPI_FIFO_START, sspi->base + SIRFSOC_SPI_RXFIFO_OP);\r\nwritel(SIRFSOC_SPI_FIFO_START, sspi->base + SIRFSOC_SPI_TXFIFO_OP);\r\nwritel(0, sspi->base + SIRFSOC_SPI_DUMMY_DELAY_CTL);\r\nsspi->dummypage = kmalloc(2 * PAGE_SIZE, GFP_KERNEL);\r\nif (!sspi->dummypage) {\r\nret = -ENOMEM;\r\ngoto free_clk;\r\n}\r\nret = spi_bitbang_start(&sspi->bitbang);\r\nif (ret)\r\ngoto free_dummypage;\r\nfor (i = 0; master->cs_gpios && i < master->num_chipselect; i++) {\r\nif (master->cs_gpios[i] == -ENOENT)\r\ncontinue;\r\nif (!gpio_is_valid(master->cs_gpios[i])) {\r\ndev_err(&pdev->dev, "no valid gpio\n");\r\nret = -EINVAL;\r\ngoto free_dummypage;\r\n}\r\nret = devm_gpio_request(&pdev->dev,\r\nmaster->cs_gpios[i], DRIVER_NAME);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to request gpio\n");\r\ngoto free_dummypage;\r\n}\r\n}\r\ndev_info(&pdev->dev, "registerred, bus number = %d\n", master->bus_num);\r\nreturn 0;\r\nfree_dummypage:\r\nkfree(sspi->dummypage);\r\nfree_clk:\r\nclk_disable_unprepare(sspi->clk);\r\nclk_put(sspi->clk);\r\nfree_tx_dma:\r\ndma_release_channel(sspi->tx_chan);\r\nfree_rx_dma:\r\ndma_release_channel(sspi->rx_chan);\r\nfree_master:\r\nspi_master_put(master);\r\nreturn ret;\r\n}\r\nstatic int spi_sirfsoc_remove(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master;\r\nstruct sirfsoc_spi *sspi;\r\nmaster = platform_get_drvdata(pdev);\r\nsspi = spi_master_get_devdata(master);\r\nspi_bitbang_stop(&sspi->bitbang);\r\nkfree(sspi->dummypage);\r\nclk_disable_unprepare(sspi->clk);\r\nclk_put(sspi->clk);\r\ndma_release_channel(sspi->rx_chan);\r\ndma_release_channel(sspi->tx_chan);\r\nspi_master_put(master);\r\nreturn 0;\r\n}\r\nstatic int spi_sirfsoc_suspend(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct sirfsoc_spi *sspi = spi_master_get_devdata(master);\r\nint ret;\r\nret = spi_master_suspend(master);\r\nif (ret)\r\nreturn ret;\r\nclk_disable(sspi->clk);\r\nreturn 0;\r\n}\r\nstatic int spi_sirfsoc_resume(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct sirfsoc_spi *sspi = spi_master_get_devdata(master);\r\nclk_enable(sspi->clk);\r\nwritel(SIRFSOC_SPI_FIFO_RESET, sspi->base + SIRFSOC_SPI_RXFIFO_OP);\r\nwritel(SIRFSOC_SPI_FIFO_RESET, sspi->base + SIRFSOC_SPI_TXFIFO_OP);\r\nwritel(SIRFSOC_SPI_FIFO_START, sspi->base + SIRFSOC_SPI_RXFIFO_OP);\r\nwritel(SIRFSOC_SPI_FIFO_START, sspi->base + SIRFSOC_SPI_TXFIFO_OP);\r\nreturn spi_master_resume(master);\r\n}
