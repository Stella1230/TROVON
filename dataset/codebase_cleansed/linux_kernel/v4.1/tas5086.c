static int tas5086_register_size(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase TAS5086_CLOCK_CONTROL ... TAS5086_BKNDERR:\r\nreturn 1;\r\ncase TAS5086_INPUT_MUX:\r\ncase TAS5086_PWM_OUTPUT_MUX:\r\nreturn 4;\r\n}\r\ndev_err(dev, "Unsupported register address: %d\n", reg);\r\nreturn 0;\r\n}\r\nstatic bool tas5086_accessible_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase 0x0f:\r\ncase 0x11 ... 0x17:\r\ncase 0x1d ... 0x1f:\r\nreturn false;\r\ndefault:\r\nreturn true;\r\n}\r\n}\r\nstatic bool tas5086_volatile_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase TAS5086_DEV_ID:\r\ncase TAS5086_ERROR_STATUS:\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool tas5086_writeable_reg(struct device *dev, unsigned int reg)\r\n{\r\nreturn tas5086_accessible_reg(dev, reg) && (reg != TAS5086_DEV_ID);\r\n}\r\nstatic int tas5086_reg_write(void *context, unsigned int reg,\r\nunsigned int value)\r\n{\r\nstruct i2c_client *client = context;\r\nunsigned int i, size;\r\nuint8_t buf[5];\r\nint ret;\r\nsize = tas5086_register_size(&client->dev, reg);\r\nif (size == 0)\r\nreturn -EINVAL;\r\nbuf[0] = reg;\r\nfor (i = size; i >= 1; --i) {\r\nbuf[i] = value;\r\nvalue >>= 8;\r\n}\r\nret = i2c_master_send(client, buf, size + 1);\r\nif (ret == size + 1)\r\nreturn 0;\r\nelse if (ret < 0)\r\nreturn ret;\r\nelse\r\nreturn -EIO;\r\n}\r\nstatic int tas5086_reg_read(void *context, unsigned int reg,\r\nunsigned int *value)\r\n{\r\nstruct i2c_client *client = context;\r\nuint8_t send_buf, recv_buf[4];\r\nstruct i2c_msg msgs[2];\r\nunsigned int size;\r\nunsigned int i;\r\nint ret;\r\nsize = tas5086_register_size(&client->dev, reg);\r\nif (size == 0)\r\nreturn -EINVAL;\r\nsend_buf = reg;\r\nmsgs[0].addr = client->addr;\r\nmsgs[0].len = sizeof(send_buf);\r\nmsgs[0].buf = &send_buf;\r\nmsgs[0].flags = 0;\r\nmsgs[1].addr = client->addr;\r\nmsgs[1].len = size;\r\nmsgs[1].buf = recv_buf;\r\nmsgs[1].flags = I2C_M_RD;\r\nret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\r\nif (ret < 0)\r\nreturn ret;\r\nelse if (ret != ARRAY_SIZE(msgs))\r\nreturn -EIO;\r\n*value = 0;\r\nfor (i = 0; i < size; i++) {\r\n*value <<= 8;\r\n*value |= recv_buf[i];\r\n}\r\nreturn 0;\r\n}\r\nstatic int tas5086_set_deemph(struct snd_soc_codec *codec)\r\n{\r\nstruct tas5086_private *priv = snd_soc_codec_get_drvdata(codec);\r\nint i, val = 0;\r\nif (priv->deemph)\r\nfor (i = 0; i < ARRAY_SIZE(tas5086_deemph); i++)\r\nif (tas5086_deemph[i] == priv->rate)\r\nval = i;\r\nreturn regmap_update_bits(priv->regmap, TAS5086_SYS_CONTROL_1,\r\nTAS5086_DEEMPH_MASK, val);\r\n}\r\nstatic int tas5086_get_deemph(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct tas5086_private *priv = snd_soc_codec_get_drvdata(codec);\r\nucontrol->value.integer.value[0] = priv->deemph;\r\nreturn 0;\r\n}\r\nstatic int tas5086_put_deemph(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct tas5086_private *priv = snd_soc_codec_get_drvdata(codec);\r\npriv->deemph = ucontrol->value.integer.value[0];\r\nreturn tas5086_set_deemph(codec);\r\n}\r\nstatic int tas5086_set_dai_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct tas5086_private *priv = snd_soc_codec_get_drvdata(codec);\r\nswitch (clk_id) {\r\ncase TAS5086_CLK_IDX_MCLK:\r\npriv->mclk = freq;\r\nbreak;\r\ncase TAS5086_CLK_IDX_SCLK:\r\npriv->sclk = freq;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tas5086_set_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int format)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct tas5086_private *priv = snd_soc_codec_get_drvdata(codec);\r\nif ((format & SND_SOC_DAIFMT_MASTER_MASK) != SND_SOC_DAIFMT_CBS_CFS) {\r\ndev_err(codec->dev, "Invalid clocking mode\n");\r\nreturn -EINVAL;\r\n}\r\npriv->format = format;\r\nreturn 0;\r\n}\r\nstatic int index_in_array(const int *array, int len, int needle)\r\n{\r\nint i;\r\nfor (i = 0; i < len; i++)\r\nif (array[i] == needle)\r\nreturn i;\r\nreturn -ENOENT;\r\n}\r\nstatic int tas5086_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct tas5086_private *priv = snd_soc_codec_get_drvdata(codec);\r\nint val;\r\nint ret;\r\npriv->rate = params_rate(params);\r\nval = index_in_array(tas5086_sample_rates,\r\nARRAY_SIZE(tas5086_sample_rates), priv->rate);\r\nif (val < 0) {\r\ndev_err(codec->dev, "Invalid sample rate\n");\r\nreturn -EINVAL;\r\n}\r\nret = regmap_update_bits(priv->regmap, TAS5086_CLOCK_CONTROL,\r\nTAS5086_CLOCK_RATE_MASK,\r\nTAS5086_CLOCK_RATE(val));\r\nif (ret < 0)\r\nreturn ret;\r\nval = index_in_array(tas5086_ratios, ARRAY_SIZE(tas5086_ratios),\r\npriv->mclk / priv->rate);\r\nif (val < 0) {\r\ndev_err(codec->dev, "Inavlid MCLK / Fs ratio\n");\r\nreturn -EINVAL;\r\n}\r\nret = regmap_update_bits(priv->regmap, TAS5086_CLOCK_CONTROL,\r\nTAS5086_CLOCK_RATIO_MASK,\r\nTAS5086_CLOCK_RATIO(val));\r\nif (ret < 0)\r\nreturn ret;\r\nret = regmap_update_bits(priv->regmap, TAS5086_CLOCK_CONTROL,\r\nTAS5086_CLOCK_SCLK_RATIO_48,\r\n(priv->sclk == 48 * priv->rate) ?\r\nTAS5086_CLOCK_SCLK_RATIO_48 : 0);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (priv->format & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nval = 0x00;\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\nval = 0x03;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nval = 0x06;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Invalid DAI format\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (params_width(params)) {\r\ncase 16:\r\nval += 0;\r\nbreak;\r\ncase 20:\r\nval += 1;\r\nbreak;\r\ncase 24:\r\nval += 2;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Invalid bit width\n");\r\nreturn -EINVAL;\r\n}\r\nret = regmap_write(priv->regmap, TAS5086_SERIAL_DATA_IF, val);\r\nif (ret < 0)\r\nreturn ret;\r\nret = regmap_update_bits(priv->regmap, TAS5086_CLOCK_CONTROL,\r\nTAS5086_CLOCK_VALID, TAS5086_CLOCK_VALID);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn tas5086_set_deemph(codec);\r\n}\r\nstatic int tas5086_mute_stream(struct snd_soc_dai *dai, int mute, int stream)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct tas5086_private *priv = snd_soc_codec_get_drvdata(codec);\r\nunsigned int val = 0;\r\nif (mute)\r\nval = TAS5086_SOFT_MUTE_ALL;\r\nreturn regmap_write(priv->regmap, TAS5086_SOFT_MUTE, val);\r\n}\r\nstatic void tas5086_reset(struct tas5086_private *priv)\r\n{\r\nif (gpio_is_valid(priv->gpio_nreset)) {\r\ngpio_direction_output(priv->gpio_nreset, 0);\r\nudelay(1);\r\ngpio_set_value(priv->gpio_nreset, 1);\r\nmsleep(15);\r\n}\r\n}\r\nstatic int tas5086_init(struct device *dev, struct tas5086_private *priv)\r\n{\r\nint ret, i;\r\nif (priv->pwm_start_mid_z)\r\nregmap_write(priv->regmap, TAS5086_PWM_START,\r\nTAS5086_PWM_START_MIDZ_FOR_START_1 |\r\npriv->pwm_start_mid_z);\r\nif (priv->charge_period == 0) {\r\nregmap_write(priv->regmap, TAS5086_SPLIT_CAP_CHARGE, 0);\r\n} else {\r\ni = index_in_array(tas5086_charge_period,\r\nARRAY_SIZE(tas5086_charge_period),\r\npriv->charge_period);\r\nif (i >= 0)\r\nregmap_write(priv->regmap, TAS5086_SPLIT_CAP_CHARGE,\r\ni + 0x08);\r\nelse\r\ndev_warn(dev,\r\n"Invalid split-cap charge period of %d ns.\n",\r\npriv->charge_period);\r\n}\r\nret = regmap_write(priv->regmap, TAS5086_OSC_TRIM, 0x00);\r\nif (ret < 0)\r\nreturn ret;\r\nret = regmap_write(priv->regmap, TAS5086_SYS_CONTROL_2, 0x20);\r\nif (ret < 0)\r\nreturn ret;\r\nret = regmap_write(priv->regmap, TAS5086_SOFT_MUTE,\r\nTAS5086_SOFT_MUTE_ALL);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int tas5086_soc_suspend(struct snd_soc_codec *codec)\r\n{\r\nstruct tas5086_private *priv = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nret = regmap_write(priv->regmap, TAS5086_SYS_CONTROL_2, 0x60);\r\nif (ret < 0)\r\nreturn ret;\r\nregulator_bulk_disable(ARRAY_SIZE(priv->supplies), priv->supplies);\r\nreturn 0;\r\n}\r\nstatic int tas5086_soc_resume(struct snd_soc_codec *codec)\r\n{\r\nstruct tas5086_private *priv = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nret = regulator_bulk_enable(ARRAY_SIZE(priv->supplies), priv->supplies);\r\nif (ret < 0)\r\nreturn ret;\r\ntas5086_reset(priv);\r\nregcache_mark_dirty(priv->regmap);\r\nret = tas5086_init(codec->dev, priv);\r\nif (ret < 0)\r\nreturn ret;\r\nret = regcache_sync(priv->regmap);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int tas5086_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct tas5086_private *priv = snd_soc_codec_get_drvdata(codec);\r\nint i, ret;\r\nret = regulator_bulk_enable(ARRAY_SIZE(priv->supplies), priv->supplies);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to enable regulators: %d\n", ret);\r\nreturn ret;\r\n}\r\npriv->pwm_start_mid_z = 0;\r\npriv->charge_period = 1300000;\r\nif (of_match_device(of_match_ptr(tas5086_dt_ids), codec->dev)) {\r\nstruct device_node *of_node = codec->dev->of_node;\r\nof_property_read_u32(of_node, "ti,charge-period",\r\n&priv->charge_period);\r\nfor (i = 0; i < 6; i++) {\r\nchar name[25];\r\nsnprintf(name, sizeof(name),\r\n"ti,mid-z-channel-%d", i + 1);\r\nif (of_get_property(of_node, name, NULL) != NULL)\r\npriv->pwm_start_mid_z |= 1 << i;\r\n}\r\n}\r\ntas5086_reset(priv);\r\nret = tas5086_init(codec->dev, priv);\r\nif (ret < 0)\r\ngoto exit_disable_regulators;\r\nret = regmap_write(priv->regmap, TAS5086_MASTER_VOL, 0x30);\r\nif (ret < 0)\r\ngoto exit_disable_regulators;\r\nreturn 0;\r\nexit_disable_regulators:\r\nregulator_bulk_disable(ARRAY_SIZE(priv->supplies), priv->supplies);\r\nreturn ret;\r\n}\r\nstatic int tas5086_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct tas5086_private *priv = snd_soc_codec_get_drvdata(codec);\r\nif (gpio_is_valid(priv->gpio_nreset))\r\ngpio_set_value(priv->gpio_nreset, 0);\r\nregulator_bulk_disable(ARRAY_SIZE(priv->supplies), priv->supplies);\r\nreturn 0;\r\n}\r\nstatic int tas5086_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct tas5086_private *priv;\r\nstruct device *dev = &i2c->dev;\r\nint gpio_nreset = -EINVAL;\r\nint i, ret;\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < ARRAY_SIZE(supply_names); i++)\r\npriv->supplies[i].supply = supply_names[i];\r\nret = devm_regulator_bulk_get(dev, ARRAY_SIZE(priv->supplies),\r\npriv->supplies);\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to get regulators: %d\n", ret);\r\nreturn ret;\r\n}\r\npriv->regmap = devm_regmap_init(dev, NULL, i2c, &tas5086_regmap);\r\nif (IS_ERR(priv->regmap)) {\r\nret = PTR_ERR(priv->regmap);\r\ndev_err(&i2c->dev, "Failed to create regmap: %d\n", ret);\r\nreturn ret;\r\n}\r\ni2c_set_clientdata(i2c, priv);\r\nif (of_match_device(of_match_ptr(tas5086_dt_ids), dev)) {\r\nstruct device_node *of_node = dev->of_node;\r\ngpio_nreset = of_get_named_gpio(of_node, "reset-gpio", 0);\r\n}\r\nif (gpio_is_valid(gpio_nreset))\r\nif (devm_gpio_request(dev, gpio_nreset, "TAS5086 Reset"))\r\ngpio_nreset = -EINVAL;\r\npriv->gpio_nreset = gpio_nreset;\r\nret = regulator_bulk_enable(ARRAY_SIZE(priv->supplies), priv->supplies);\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to enable regulators: %d\n", ret);\r\nreturn ret;\r\n}\r\ntas5086_reset(priv);\r\nret = regmap_read(priv->regmap, TAS5086_DEV_ID, &i);\r\nif (ret == 0 && i != 0x3) {\r\ndev_err(dev,\r\n"Failed to identify TAS5086 codec (got %02x)\n", i);\r\nret = -ENODEV;\r\n}\r\nregulator_bulk_disable(ARRAY_SIZE(priv->supplies), priv->supplies);\r\nif (ret == 0)\r\nret = snd_soc_register_codec(&i2c->dev, &soc_codec_dev_tas5086,\r\n&tas5086_dai, 1);\r\nreturn ret;\r\n}\r\nstatic int tas5086_i2c_remove(struct i2c_client *i2c)\r\n{\r\nsnd_soc_unregister_codec(&i2c->dev);\r\nreturn 0;\r\n}
