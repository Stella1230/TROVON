static inline int require_table_link(const void *sdbt)\r\n{\r\nreturn ((unsigned long) sdbt & ~PAGE_MASK) == CPUM_SF_SDBT_TL_OFFSET;\r\n}\r\nstatic int sf_disable(void)\r\n{\r\nstruct hws_lsctl_request_block sreq;\r\nmemset(&sreq, 0, sizeof(sreq));\r\nreturn lsctl(&sreq);\r\n}\r\nstatic int sf_buffer_available(struct cpu_hw_sf *cpuhw)\r\n{\r\nreturn !!cpuhw->sfb.sdbt;\r\n}\r\nstatic void free_sampling_buffer(struct sf_buffer *sfb)\r\n{\r\nunsigned long *sdbt, *curr;\r\nif (!sfb->sdbt)\r\nreturn;\r\nsdbt = sfb->sdbt;\r\ncurr = sdbt;\r\nwhile (1) {\r\nif (!*curr || !sdbt)\r\nbreak;\r\nif (is_link_entry(curr)) {\r\ncurr = get_next_sdbt(curr);\r\nif (sdbt)\r\nfree_page((unsigned long) sdbt);\r\nif (curr == sfb->sdbt)\r\nbreak;\r\nelse\r\nsdbt = curr;\r\n} else {\r\nif (*curr) {\r\nfree_page(*curr);\r\ncurr++;\r\n}\r\n}\r\n}\r\ndebug_sprintf_event(sfdbg, 5,\r\n"free_sampling_buffer: freed sdbt=%p\n", sfb->sdbt);\r\nmemset(sfb, 0, sizeof(*sfb));\r\n}\r\nstatic int alloc_sample_data_block(unsigned long *sdbt, gfp_t gfp_flags)\r\n{\r\nunsigned long sdb, *trailer;\r\nsdb = get_zeroed_page(gfp_flags);\r\nif (!sdb)\r\nreturn -ENOMEM;\r\ntrailer = trailer_entry_ptr(sdb);\r\n*trailer = SDB_TE_ALERT_REQ_MASK;\r\n*sdbt = sdb;\r\nreturn 0;\r\n}\r\nstatic int realloc_sampling_buffer(struct sf_buffer *sfb,\r\nunsigned long num_sdb, gfp_t gfp_flags)\r\n{\r\nint i, rc;\r\nunsigned long *new, *tail;\r\nif (!sfb->sdbt || !sfb->tail)\r\nreturn -EINVAL;\r\nif (!is_link_entry(sfb->tail))\r\nreturn -EINVAL;\r\ntail = sfb->tail;\r\nif (sfb->sdbt != get_next_sdbt(tail)) {\r\ndebug_sprintf_event(sfdbg, 3, "realloc_sampling_buffer: "\r\n"sampling buffer is not linked: origin=%p"\r\n"tail=%p\n",\r\n(void *) sfb->sdbt, (void *) tail);\r\nreturn -EINVAL;\r\n}\r\nrc = 0;\r\nfor (i = 0; i < num_sdb; i++) {\r\nif (require_table_link(tail)) {\r\nnew = (unsigned long *) get_zeroed_page(gfp_flags);\r\nif (!new) {\r\nrc = -ENOMEM;\r\nbreak;\r\n}\r\nsfb->num_sdbt++;\r\n*tail = (unsigned long)(void *) new + 1;\r\ntail = new;\r\n}\r\nrc = alloc_sample_data_block(tail, gfp_flags);\r\nif (rc)\r\nbreak;\r\nsfb->num_sdb++;\r\ntail++;\r\n}\r\n*tail = (unsigned long) sfb->sdbt + 1;\r\nsfb->tail = tail;\r\ndebug_sprintf_event(sfdbg, 4, "realloc_sampling_buffer: new buffer"\r\n" settings: sdbt=%lu sdb=%lu\n",\r\nsfb->num_sdbt, sfb->num_sdb);\r\nreturn rc;\r\n}\r\nstatic int alloc_sampling_buffer(struct sf_buffer *sfb, unsigned long num_sdb)\r\n{\r\nint rc;\r\nif (sfb->sdbt)\r\nreturn -EINVAL;\r\nsfb->sdbt = (unsigned long *) get_zeroed_page(GFP_KERNEL);\r\nif (!sfb->sdbt)\r\nreturn -ENOMEM;\r\nsfb->num_sdb = 0;\r\nsfb->num_sdbt = 1;\r\nsfb->tail = sfb->sdbt;\r\n*sfb->tail = (unsigned long)(void *) sfb->sdbt + 1;\r\nrc = realloc_sampling_buffer(sfb, num_sdb, GFP_KERNEL);\r\nif (rc) {\r\nfree_sampling_buffer(sfb);\r\ndebug_sprintf_event(sfdbg, 4, "alloc_sampling_buffer: "\r\n"realloc_sampling_buffer failed with rc=%i\n", rc);\r\n} else\r\ndebug_sprintf_event(sfdbg, 4,\r\n"alloc_sampling_buffer: tear=%p dear=%p\n",\r\nsfb->sdbt, (void *) *sfb->sdbt);\r\nreturn rc;\r\n}\r\nstatic void sfb_set_limits(unsigned long min, unsigned long max)\r\n{\r\nstruct hws_qsi_info_block si;\r\nCPUM_SF_MIN_SDB = min;\r\nCPUM_SF_MAX_SDB = max;\r\nmemset(&si, 0, sizeof(si));\r\nif (!qsi(&si))\r\nCPUM_SF_SDB_DIAG_FACTOR = DIV_ROUND_UP(si.dsdes, si.bsdes);\r\n}\r\nstatic unsigned long sfb_max_limit(struct hw_perf_event *hwc)\r\n{\r\nreturn SAMPL_DIAG_MODE(hwc) ? CPUM_SF_MAX_SDB * CPUM_SF_SDB_DIAG_FACTOR\r\n: CPUM_SF_MAX_SDB;\r\n}\r\nstatic unsigned long sfb_pending_allocs(struct sf_buffer *sfb,\r\nstruct hw_perf_event *hwc)\r\n{\r\nif (!sfb->sdbt)\r\nreturn SFB_ALLOC_REG(hwc);\r\nif (SFB_ALLOC_REG(hwc) > sfb->num_sdb)\r\nreturn SFB_ALLOC_REG(hwc) - sfb->num_sdb;\r\nreturn 0;\r\n}\r\nstatic int sfb_has_pending_allocs(struct sf_buffer *sfb,\r\nstruct hw_perf_event *hwc)\r\n{\r\nreturn sfb_pending_allocs(sfb, hwc) > 0;\r\n}\r\nstatic void sfb_account_allocs(unsigned long num, struct hw_perf_event *hwc)\r\n{\r\nnum = min_t(unsigned long, num, sfb_max_limit(hwc) - SFB_ALLOC_REG(hwc));\r\nif (num)\r\nSFB_ALLOC_REG(hwc) += num;\r\n}\r\nstatic void sfb_init_allocs(unsigned long num, struct hw_perf_event *hwc)\r\n{\r\nSFB_ALLOC_REG(hwc) = 0;\r\nsfb_account_allocs(num, hwc);\r\n}\r\nstatic size_t event_sample_size(struct hw_perf_event *hwc)\r\n{\r\nstruct sf_raw_sample *sfr = (struct sf_raw_sample *) RAWSAMPLE_REG(hwc);\r\nsize_t sample_size;\r\nsample_size = sfr->bsdes;\r\nif (SAMPL_DIAG_MODE(hwc))\r\nsample_size += sfr->dsdes;\r\nreturn sample_size;\r\n}\r\nstatic void deallocate_buffers(struct cpu_hw_sf *cpuhw)\r\n{\r\nif (cpuhw->sfb.sdbt)\r\nfree_sampling_buffer(&cpuhw->sfb);\r\n}\r\nstatic int allocate_buffers(struct cpu_hw_sf *cpuhw, struct hw_perf_event *hwc)\r\n{\r\nunsigned long n_sdb, freq, factor;\r\nsize_t sfr_size, sample_size;\r\nstruct sf_raw_sample *sfr;\r\nsfr_size = ALIGN((sizeof(*sfr) - sizeof(sfr->diag) + cpuhw->qsi.dsdes) +\r\nsizeof(u32), sizeof(u64));\r\nsfr_size -= sizeof(u32);\r\nsfr = kzalloc(sfr_size, GFP_KERNEL);\r\nif (!sfr)\r\nreturn -ENOMEM;\r\nsfr->size = sfr_size;\r\nsfr->bsdes = cpuhw->qsi.bsdes;\r\nsfr->dsdes = cpuhw->qsi.dsdes;\r\nRAWSAMPLE_REG(hwc) = (unsigned long) sfr;\r\nsample_size = event_sample_size(hwc);\r\nfreq = sample_rate_to_freq(&cpuhw->qsi, SAMPL_RATE(hwc));\r\nfactor = 1;\r\nn_sdb = DIV_ROUND_UP(freq, factor * ((PAGE_SIZE-64) / sample_size));\r\nif (n_sdb < CPUM_SF_MIN_SDB)\r\nn_sdb = CPUM_SF_MIN_SDB;\r\nsfb_init_allocs(n_sdb, hwc);\r\nif (sf_buffer_available(cpuhw))\r\nreturn 0;\r\ndebug_sprintf_event(sfdbg, 3,\r\n"allocate_buffers: rate=%lu f=%lu sdb=%lu/%lu"\r\n" sample_size=%lu cpuhw=%p\n",\r\nSAMPL_RATE(hwc), freq, n_sdb, sfb_max_limit(hwc),\r\nsample_size, cpuhw);\r\nreturn alloc_sampling_buffer(&cpuhw->sfb,\r\nsfb_pending_allocs(&cpuhw->sfb, hwc));\r\n}\r\nstatic unsigned long min_percent(unsigned int percent, unsigned long base,\r\nunsigned long min)\r\n{\r\nreturn min_t(unsigned long, min, DIV_ROUND_UP(percent * base, 100));\r\n}\r\nstatic unsigned long compute_sfb_extent(unsigned long ratio, unsigned long base)\r\n{\r\nif (ratio <= 5)\r\nreturn 0;\r\nif (ratio <= 25)\r\nreturn min_percent(1, base, 1);\r\nif (ratio <= 50)\r\nreturn min_percent(1, base, 1);\r\nif (ratio <= 75)\r\nreturn min_percent(2, base, 2);\r\nif (ratio <= 100)\r\nreturn min_percent(3, base, 3);\r\nif (ratio <= 250)\r\nreturn min_percent(4, base, 4);\r\nreturn min_percent(5, base, 8);\r\n}\r\nstatic void sfb_account_overflows(struct cpu_hw_sf *cpuhw,\r\nstruct hw_perf_event *hwc)\r\n{\r\nunsigned long ratio, num;\r\nif (!OVERFLOW_REG(hwc))\r\nreturn;\r\nratio = DIV_ROUND_UP(100 * OVERFLOW_REG(hwc) * cpuhw->sfb.num_sdb,\r\nsample_rate_to_freq(&cpuhw->qsi, SAMPL_RATE(hwc)));\r\nnum = compute_sfb_extent(ratio, cpuhw->sfb.num_sdb);\r\nif (num)\r\nsfb_account_allocs(num, hwc);\r\ndebug_sprintf_event(sfdbg, 5, "sfb: overflow: overflow=%llu ratio=%lu"\r\n" num=%lu\n", OVERFLOW_REG(hwc), ratio, num);\r\nOVERFLOW_REG(hwc) = 0;\r\n}\r\nstatic void extend_sampling_buffer(struct sf_buffer *sfb,\r\nstruct hw_perf_event *hwc)\r\n{\r\nunsigned long num, num_old;\r\nint rc;\r\nnum = sfb_pending_allocs(sfb, hwc);\r\nif (!num)\r\nreturn;\r\nnum_old = sfb->num_sdb;\r\nsf_disable();\r\nrc = realloc_sampling_buffer(sfb, num, GFP_ATOMIC);\r\nif (rc)\r\ndebug_sprintf_event(sfdbg, 5, "sfb: extend: realloc "\r\n"failed with rc=%i\n", rc);\r\nif (sfb_has_pending_allocs(sfb, hwc))\r\ndebug_sprintf_event(sfdbg, 5, "sfb: extend: "\r\n"req=%lu alloc=%lu remaining=%lu\n",\r\nnum, sfb->num_sdb - num_old,\r\nsfb_pending_allocs(sfb, hwc));\r\n}\r\nstatic void setup_pmc_cpu(void *flags)\r\n{\r\nint err;\r\nstruct cpu_hw_sf *cpusf = this_cpu_ptr(&cpu_hw_sf);\r\nerr = 0;\r\nswitch (*((int *) flags)) {\r\ncase PMC_INIT:\r\nmemset(cpusf, 0, sizeof(*cpusf));\r\nerr = qsi(&cpusf->qsi);\r\nif (err)\r\nbreak;\r\ncpusf->flags |= PMU_F_RESERVED;\r\nerr = sf_disable();\r\nif (err)\r\npr_err("Switching off the sampling facility failed "\r\n"with rc=%i\n", err);\r\ndebug_sprintf_event(sfdbg, 5,\r\n"setup_pmc_cpu: initialized: cpuhw=%p\n", cpusf);\r\nbreak;\r\ncase PMC_RELEASE:\r\ncpusf->flags &= ~PMU_F_RESERVED;\r\nerr = sf_disable();\r\nif (err) {\r\npr_err("Switching off the sampling facility failed "\r\n"with rc=%i\n", err);\r\n} else\r\ndeallocate_buffers(cpusf);\r\ndebug_sprintf_event(sfdbg, 5,\r\n"setup_pmc_cpu: released: cpuhw=%p\n", cpusf);\r\nbreak;\r\n}\r\nif (err)\r\n*((int *) flags) |= PMC_FAILURE;\r\n}\r\nstatic void release_pmc_hardware(void)\r\n{\r\nint flags = PMC_RELEASE;\r\nirq_subclass_unregister(IRQ_SUBCLASS_MEASUREMENT_ALERT);\r\non_each_cpu(setup_pmc_cpu, &flags, 1);\r\nperf_release_sampling();\r\n}\r\nstatic int reserve_pmc_hardware(void)\r\n{\r\nint flags = PMC_INIT;\r\nint err;\r\nerr = perf_reserve_sampling();\r\nif (err)\r\nreturn err;\r\non_each_cpu(setup_pmc_cpu, &flags, 1);\r\nif (flags & PMC_FAILURE) {\r\nrelease_pmc_hardware();\r\nreturn -ENODEV;\r\n}\r\nirq_subclass_register(IRQ_SUBCLASS_MEASUREMENT_ALERT);\r\nreturn 0;\r\n}\r\nstatic void hw_perf_event_destroy(struct perf_event *event)\r\n{\r\nif (RAWSAMPLE_REG(&event->hw))\r\nkfree((void *) RAWSAMPLE_REG(&event->hw));\r\nif (!atomic_add_unless(&num_events, -1, 1)) {\r\nmutex_lock(&pmc_reserve_mutex);\r\nif (atomic_dec_return(&num_events) == 0)\r\nrelease_pmc_hardware();\r\nmutex_unlock(&pmc_reserve_mutex);\r\n}\r\n}\r\nstatic void hw_init_period(struct hw_perf_event *hwc, u64 period)\r\n{\r\nhwc->sample_period = period;\r\nhwc->last_period = hwc->sample_period;\r\nlocal64_set(&hwc->period_left, hwc->sample_period);\r\n}\r\nstatic void hw_reset_registers(struct hw_perf_event *hwc,\r\nunsigned long *sdbt_origin)\r\n{\r\nstruct sf_raw_sample *sfr;\r\nTEAR_REG(hwc) = (unsigned long) sdbt_origin;\r\nsfr = (struct sf_raw_sample *) RAWSAMPLE_REG(hwc);\r\nmemset(&sfr->basic, 0, sizeof(sfr->basic));\r\nmemset(&sfr->diag, 0, sfr->dsdes);\r\n}\r\nstatic unsigned long hw_limit_rate(const struct hws_qsi_info_block *si,\r\nunsigned long rate)\r\n{\r\nreturn clamp_t(unsigned long, rate,\r\nsi->min_sampl_rate, si->max_sampl_rate);\r\n}\r\nstatic int __hw_perf_event_init(struct perf_event *event)\r\n{\r\nstruct cpu_hw_sf *cpuhw;\r\nstruct hws_qsi_info_block si;\r\nstruct perf_event_attr *attr = &event->attr;\r\nstruct hw_perf_event *hwc = &event->hw;\r\nunsigned long rate;\r\nint cpu, err;\r\nerr = 0;\r\nif (!atomic_inc_not_zero(&num_events)) {\r\nmutex_lock(&pmc_reserve_mutex);\r\nif (atomic_read(&num_events) == 0 && reserve_pmc_hardware())\r\nerr = -EBUSY;\r\nelse\r\natomic_inc(&num_events);\r\nmutex_unlock(&pmc_reserve_mutex);\r\n}\r\nevent->destroy = hw_perf_event_destroy;\r\nif (err)\r\ngoto out;\r\nmemset(&si, 0, sizeof(si));\r\ncpuhw = NULL;\r\nif (event->cpu == -1)\r\nqsi(&si);\r\nelse {\r\ncpuhw = &per_cpu(cpu_hw_sf, event->cpu);\r\nsi = cpuhw->qsi;\r\n}\r\nif (!si.as) {\r\nerr = -ENOENT;\r\ngoto out;\r\n}\r\nSAMPL_FLAGS(hwc) = PERF_CPUM_SF_BASIC_MODE;\r\nif (attr->config == PERF_EVENT_CPUM_SF_DIAG) {\r\nif (!si.ad) {\r\nerr = -EPERM;\r\ngoto out;\r\n}\r\nSAMPL_FLAGS(hwc) |= PERF_CPUM_SF_DIAG_MODE;\r\n}\r\nif (attr->config1 & PERF_CPUM_SF_FULL_BLOCKS)\r\nSAMPL_FLAGS(hwc) |= PERF_CPUM_SF_FULL_BLOCKS;\r\nrate = 0;\r\nif (attr->freq) {\r\nrate = freq_to_sample_rate(&si, attr->sample_freq);\r\nrate = hw_limit_rate(&si, rate);\r\nattr->freq = 0;\r\nattr->sample_period = rate;\r\n} else {\r\nrate = hw_limit_rate(&si, hwc->sample_period);\r\nif (sample_rate_to_freq(&si, rate) >\r\nsysctl_perf_event_sample_rate) {\r\nerr = -EINVAL;\r\ndebug_sprintf_event(sfdbg, 1, "Sampling rate exceeds maximum perf sample rate\n");\r\ngoto out;\r\n}\r\n}\r\nSAMPL_RATE(hwc) = rate;\r\nhw_init_period(hwc, SAMPL_RATE(hwc));\r\nhwc->extra_reg.reg = REG_OVERFLOW;\r\nOVERFLOW_REG(hwc) = 0;\r\nif (cpuhw)\r\nerr = allocate_buffers(cpuhw, hwc);\r\nelse {\r\nfor_each_online_cpu(cpu) {\r\ncpuhw = &per_cpu(cpu_hw_sf, cpu);\r\nerr = allocate_buffers(cpuhw, hwc);\r\nif (err)\r\nbreak;\r\n}\r\n}\r\nout:\r\nreturn err;\r\n}\r\nstatic int cpumsf_pmu_event_init(struct perf_event *event)\r\n{\r\nint err;\r\nif (has_branch_stack(event))\r\nreturn -EOPNOTSUPP;\r\nswitch (event->attr.type) {\r\ncase PERF_TYPE_RAW:\r\nif ((event->attr.config != PERF_EVENT_CPUM_SF) &&\r\n(event->attr.config != PERF_EVENT_CPUM_SF_DIAG))\r\nreturn -ENOENT;\r\nbreak;\r\ncase PERF_TYPE_HARDWARE:\r\nif (event->attr.config != PERF_COUNT_HW_CPU_CYCLES)\r\nreturn -ENOENT;\r\nif (!is_sampling_event(event))\r\nreturn -ENOENT;\r\nbreak;\r\ndefault:\r\nreturn -ENOENT;\r\n}\r\nif (event->cpu >= nr_cpumask_bits ||\r\n(event->cpu >= 0 && !cpu_online(event->cpu)))\r\nreturn -ENODEV;\r\nif (event->attr.exclude_hv)\r\nevent->attr.exclude_hv = 0;\r\nif (event->attr.exclude_idle)\r\nevent->attr.exclude_idle = 0;\r\nerr = __hw_perf_event_init(event);\r\nif (unlikely(err))\r\nif (event->destroy)\r\nevent->destroy(event);\r\nreturn err;\r\n}\r\nstatic void cpumsf_pmu_enable(struct pmu *pmu)\r\n{\r\nstruct cpu_hw_sf *cpuhw = this_cpu_ptr(&cpu_hw_sf);\r\nstruct hw_perf_event *hwc;\r\nint err;\r\nif (cpuhw->flags & PMU_F_ENABLED)\r\nreturn;\r\nif (cpuhw->flags & PMU_F_ERR_MASK)\r\nreturn;\r\nif (cpuhw->event) {\r\nhwc = &cpuhw->event->hw;\r\nsfb_account_overflows(cpuhw, hwc);\r\nif (sfb_has_pending_allocs(&cpuhw->sfb, hwc))\r\nextend_sampling_buffer(&cpuhw->sfb, hwc);\r\n}\r\ncpuhw->flags |= PMU_F_ENABLED;\r\nbarrier();\r\nerr = lsctl(&cpuhw->lsctl);\r\nif (err) {\r\ncpuhw->flags &= ~PMU_F_ENABLED;\r\npr_err("Loading sampling controls failed: op=%i err=%i\n",\r\n1, err);\r\nreturn;\r\n}\r\ndebug_sprintf_event(sfdbg, 6, "pmu_enable: es=%i cs=%i ed=%i cd=%i "\r\n"tear=%p dear=%p\n", cpuhw->lsctl.es, cpuhw->lsctl.cs,\r\ncpuhw->lsctl.ed, cpuhw->lsctl.cd,\r\n(void *) cpuhw->lsctl.tear, (void *) cpuhw->lsctl.dear);\r\n}\r\nstatic void cpumsf_pmu_disable(struct pmu *pmu)\r\n{\r\nstruct cpu_hw_sf *cpuhw = this_cpu_ptr(&cpu_hw_sf);\r\nstruct hws_lsctl_request_block inactive;\r\nstruct hws_qsi_info_block si;\r\nint err;\r\nif (!(cpuhw->flags & PMU_F_ENABLED))\r\nreturn;\r\nif (cpuhw->flags & PMU_F_ERR_MASK)\r\nreturn;\r\ninactive = cpuhw->lsctl;\r\ninactive.cs = 0;\r\ninactive.cd = 0;\r\nerr = lsctl(&inactive);\r\nif (err) {\r\npr_err("Loading sampling controls failed: op=%i err=%i\n",\r\n2, err);\r\nreturn;\r\n}\r\nif (!qsi(&si)) {\r\nif (si.es) {\r\ncpuhw->lsctl.tear = si.tear;\r\ncpuhw->lsctl.dear = si.dear;\r\n}\r\n} else\r\ndebug_sprintf_event(sfdbg, 3, "cpumsf_pmu_disable: "\r\n"qsi() failed with err=%i\n", err);\r\ncpuhw->flags &= ~PMU_F_ENABLED;\r\n}\r\nstatic int perf_exclude_event(struct perf_event *event, struct pt_regs *regs,\r\nstruct perf_sf_sde_regs *sde_regs)\r\n{\r\nif (event->attr.exclude_user && user_mode(regs))\r\nreturn 1;\r\nif (event->attr.exclude_kernel && !user_mode(regs))\r\nreturn 1;\r\nif (event->attr.exclude_guest && sde_regs->in_guest)\r\nreturn 1;\r\nif (event->attr.exclude_host && !sde_regs->in_guest)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int perf_push_sample(struct perf_event *event, struct sf_raw_sample *sfr)\r\n{\r\nint overflow;\r\nstruct pt_regs regs;\r\nstruct perf_sf_sde_regs *sde_regs;\r\nstruct perf_sample_data data;\r\nstruct perf_raw_record raw;\r\nperf_sample_data_init(&data, 0, event->hw.last_period);\r\nraw.size = sfr->size;\r\nraw.data = sfr;\r\ndata.raw = &raw;\r\nmemset(&regs, 0, sizeof(regs));\r\nregs.int_code = 0x1407;\r\nregs.int_parm = CPU_MF_INT_SF_PRA;\r\nsde_regs = (struct perf_sf_sde_regs *) &regs.int_parm_long;\r\nregs.psw.addr = sfr->basic.ia;\r\nif (sfr->basic.T)\r\nregs.psw.mask |= PSW_MASK_DAT;\r\nif (sfr->basic.W)\r\nregs.psw.mask |= PSW_MASK_WAIT;\r\nif (sfr->basic.P)\r\nregs.psw.mask |= PSW_MASK_PSTATE;\r\nswitch (sfr->basic.AS) {\r\ncase 0x0:\r\nregs.psw.mask |= PSW_ASC_PRIMARY;\r\nbreak;\r\ncase 0x1:\r\nregs.psw.mask |= PSW_ASC_ACCREG;\r\nbreak;\r\ncase 0x2:\r\nregs.psw.mask |= PSW_ASC_SECONDARY;\r\nbreak;\r\ncase 0x3:\r\nregs.psw.mask |= PSW_ASC_HOME;\r\nbreak;\r\n}\r\nif (sfr->basic.hpp)\r\nsde_regs->in_guest = 1;\r\noverflow = 0;\r\nif (perf_exclude_event(event, &regs, sde_regs))\r\ngoto out;\r\nif (perf_event_overflow(event, &data, &regs)) {\r\noverflow = 1;\r\nevent->pmu->stop(event, 0);\r\n}\r\nperf_event_update_userpage(event);\r\nout:\r\nreturn overflow;\r\n}\r\nstatic void perf_event_count_update(struct perf_event *event, u64 count)\r\n{\r\nlocal64_add(count, &event->count);\r\n}\r\nstatic int sample_format_is_valid(struct hws_combined_entry *sample,\r\nunsigned int flags)\r\n{\r\nif (likely(flags & PERF_CPUM_SF_BASIC_MODE))\r\nif (sample->basic.def != 0x0001)\r\nreturn 0;\r\nif (flags & PERF_CPUM_SF_DIAG_MODE)\r\nif (sample->diag.def < 0x8001)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int sample_is_consistent(struct hws_combined_entry *sample,\r\nunsigned long flags)\r\n{\r\nif (unlikely(!(flags & PERF_CPUM_SF_BASIC_MODE)))\r\nreturn 0;\r\nif (sample->basic.I || sample->basic.W)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void reset_sample_slot(struct hws_combined_entry *sample,\r\nunsigned long flags)\r\n{\r\nif (likely(flags & PERF_CPUM_SF_BASIC_MODE))\r\nsample->basic.def = 0;\r\nif (flags & PERF_CPUM_SF_DIAG_MODE)\r\nsample->diag.def = 0;\r\n}\r\nstatic void sfr_store_sample(struct sf_raw_sample *sfr,\r\nstruct hws_combined_entry *sample)\r\n{\r\nif (likely(sfr->format & PERF_CPUM_SF_BASIC_MODE))\r\nsfr->basic = sample->basic;\r\nif (sfr->format & PERF_CPUM_SF_DIAG_MODE)\r\nmemcpy(&sfr->diag, &sample->diag, sfr->dsdes);\r\n}\r\nstatic void debug_sample_entry(struct hws_combined_entry *sample,\r\nstruct hws_trailer_entry *te,\r\nunsigned long flags)\r\n{\r\ndebug_sprintf_event(sfdbg, 4, "hw_collect_samples: Found unknown "\r\n"sampling data entry: te->f=%i basic.def=%04x (%p)"\r\n" diag.def=%04x (%p)\n", te->f,\r\nsample->basic.def, &sample->basic,\r\n(flags & PERF_CPUM_SF_DIAG_MODE)\r\n? sample->diag.def : 0xFFFF,\r\n(flags & PERF_CPUM_SF_DIAG_MODE)\r\n? &sample->diag : NULL);\r\n}\r\nstatic void hw_collect_samples(struct perf_event *event, unsigned long *sdbt,\r\nunsigned long long *overflow)\r\n{\r\nunsigned long flags = SAMPL_FLAGS(&event->hw);\r\nstruct hws_combined_entry *sample;\r\nstruct hws_trailer_entry *te;\r\nstruct sf_raw_sample *sfr;\r\nsize_t sample_size;\r\nsfr = (struct sf_raw_sample *) RAWSAMPLE_REG(&event->hw);\r\nsfr->format = flags & PERF_CPUM_SF_MODE_MASK;\r\nsample_size = event_sample_size(&event->hw);\r\nte = (struct hws_trailer_entry *) trailer_entry_ptr(*sdbt);\r\nsample = (struct hws_combined_entry *) *sdbt;\r\nwhile ((unsigned long *) sample < (unsigned long *) te) {\r\nif (!sample->basic.def)\r\nbreak;\r\nperf_event_count_update(event, SAMPL_RATE(&event->hw));\r\nif (sample_format_is_valid(sample, flags)) {\r\nif (!*overflow) {\r\nif (sample_is_consistent(sample, flags)) {\r\nsfr_store_sample(sfr, sample);\r\n*overflow = perf_push_sample(event, sfr);\r\n}\r\n} else\r\n*overflow += 1;\r\n} else {\r\ndebug_sample_entry(sample, te, flags);\r\nif (!te->f)\r\nbreak;\r\n}\r\nreset_sample_slot(sample, flags);\r\nsample += sample_size;\r\n}\r\n}\r\nstatic void hw_perf_event_update(struct perf_event *event, int flush_all)\r\n{\r\nstruct hw_perf_event *hwc = &event->hw;\r\nstruct hws_trailer_entry *te;\r\nunsigned long *sdbt;\r\nunsigned long long event_overflow, sampl_overflow, num_sdb, te_flags;\r\nint done;\r\nif (flush_all && SDB_FULL_BLOCKS(hwc))\r\nflush_all = 0;\r\nsdbt = (unsigned long *) TEAR_REG(hwc);\r\ndone = event_overflow = sampl_overflow = num_sdb = 0;\r\nwhile (!done) {\r\nte = (struct hws_trailer_entry *) trailer_entry_ptr(*sdbt);\r\nif (!te->f) {\r\ndone = 1;\r\nif (!flush_all)\r\nbreak;\r\n}\r\nif (te->overflow)\r\nsampl_overflow += te->overflow;\r\ndebug_sprintf_event(sfdbg, 6, "hw_perf_event_update: sdbt=%p "\r\n"overflow=%llu timestamp=0x%llx\n",\r\nsdbt, te->overflow,\r\n(te->f) ? trailer_timestamp(te) : 0ULL);\r\nhw_collect_samples(event, sdbt, &event_overflow);\r\nnum_sdb++;\r\ndo {\r\nte_flags = te->flags & ~SDB_TE_BUFFER_FULL_MASK;\r\nte_flags |= SDB_TE_ALERT_REQ_MASK;\r\n} while (!cmpxchg_double(&te->flags, &te->overflow,\r\nte->flags, te->overflow,\r\nte_flags, 0ULL));\r\nsdbt++;\r\nif (is_link_entry(sdbt))\r\nsdbt = get_next_sdbt(sdbt);\r\nTEAR_REG(hwc) = (unsigned long) sdbt;\r\nif (flush_all && done)\r\nbreak;\r\nif (event_overflow)\r\nflush_all = 1;\r\n}\r\nif (sampl_overflow)\r\nOVERFLOW_REG(hwc) = DIV_ROUND_UP(OVERFLOW_REG(hwc) +\r\nsampl_overflow, 1 + num_sdb);\r\nif (sampl_overflow || event_overflow)\r\ndebug_sprintf_event(sfdbg, 4, "hw_perf_event_update: "\r\n"overflow stats: sample=%llu event=%llu\n",\r\nsampl_overflow, event_overflow);\r\n}\r\nstatic void cpumsf_pmu_read(struct perf_event *event)\r\n{\r\n}\r\nstatic void cpumsf_pmu_start(struct perf_event *event, int flags)\r\n{\r\nstruct cpu_hw_sf *cpuhw = this_cpu_ptr(&cpu_hw_sf);\r\nif (WARN_ON_ONCE(!(event->hw.state & PERF_HES_STOPPED)))\r\nreturn;\r\nif (flags & PERF_EF_RELOAD)\r\nWARN_ON_ONCE(!(event->hw.state & PERF_HES_UPTODATE));\r\nperf_pmu_disable(event->pmu);\r\nevent->hw.state = 0;\r\ncpuhw->lsctl.cs = 1;\r\nif (SAMPL_DIAG_MODE(&event->hw))\r\ncpuhw->lsctl.cd = 1;\r\nperf_pmu_enable(event->pmu);\r\n}\r\nstatic void cpumsf_pmu_stop(struct perf_event *event, int flags)\r\n{\r\nstruct cpu_hw_sf *cpuhw = this_cpu_ptr(&cpu_hw_sf);\r\nif (event->hw.state & PERF_HES_STOPPED)\r\nreturn;\r\nperf_pmu_disable(event->pmu);\r\ncpuhw->lsctl.cs = 0;\r\ncpuhw->lsctl.cd = 0;\r\nevent->hw.state |= PERF_HES_STOPPED;\r\nif ((flags & PERF_EF_UPDATE) && !(event->hw.state & PERF_HES_UPTODATE)) {\r\nhw_perf_event_update(event, 1);\r\nevent->hw.state |= PERF_HES_UPTODATE;\r\n}\r\nperf_pmu_enable(event->pmu);\r\n}\r\nstatic int cpumsf_pmu_add(struct perf_event *event, int flags)\r\n{\r\nstruct cpu_hw_sf *cpuhw = this_cpu_ptr(&cpu_hw_sf);\r\nint err;\r\nif (cpuhw->flags & PMU_F_IN_USE)\r\nreturn -EAGAIN;\r\nif (!cpuhw->sfb.sdbt)\r\nreturn -EINVAL;\r\nerr = 0;\r\nperf_pmu_disable(event->pmu);\r\nevent->hw.state = PERF_HES_UPTODATE | PERF_HES_STOPPED;\r\ncpuhw->lsctl.s = 0;\r\ncpuhw->lsctl.h = 1;\r\ncpuhw->lsctl.tear = (unsigned long) cpuhw->sfb.sdbt;\r\ncpuhw->lsctl.dear = *(unsigned long *) cpuhw->sfb.sdbt;\r\ncpuhw->lsctl.interval = SAMPL_RATE(&event->hw);\r\nhw_reset_registers(&event->hw, cpuhw->sfb.sdbt);\r\nif (WARN_ON_ONCE(cpuhw->lsctl.es == 1 || cpuhw->lsctl.ed == 1)) {\r\nerr = -EAGAIN;\r\ngoto out;\r\n}\r\ncpuhw->lsctl.es = 1;\r\nif (SAMPL_DIAG_MODE(&event->hw))\r\ncpuhw->lsctl.ed = 1;\r\ncpuhw->event = event;\r\ncpuhw->flags |= PMU_F_IN_USE;\r\nif (flags & PERF_EF_START)\r\ncpumsf_pmu_start(event, PERF_EF_RELOAD);\r\nout:\r\nperf_event_update_userpage(event);\r\nperf_pmu_enable(event->pmu);\r\nreturn err;\r\n}\r\nstatic void cpumsf_pmu_del(struct perf_event *event, int flags)\r\n{\r\nstruct cpu_hw_sf *cpuhw = this_cpu_ptr(&cpu_hw_sf);\r\nperf_pmu_disable(event->pmu);\r\ncpumsf_pmu_stop(event, PERF_EF_UPDATE);\r\ncpuhw->lsctl.es = 0;\r\ncpuhw->lsctl.ed = 0;\r\ncpuhw->flags &= ~PMU_F_IN_USE;\r\ncpuhw->event = NULL;\r\nperf_event_update_userpage(event);\r\nperf_pmu_enable(event->pmu);\r\n}\r\nstatic void cpumf_measurement_alert(struct ext_code ext_code,\r\nunsigned int alert, unsigned long unused)\r\n{\r\nstruct cpu_hw_sf *cpuhw;\r\nif (!(alert & CPU_MF_INT_SF_MASK))\r\nreturn;\r\ninc_irq_stat(IRQEXT_CMS);\r\ncpuhw = this_cpu_ptr(&cpu_hw_sf);\r\nif (!(cpuhw->flags & PMU_F_RESERVED))\r\nreturn;\r\nif (alert & CPU_MF_INT_SF_PRA) {\r\nif (cpuhw->flags & PMU_F_IN_USE)\r\nhw_perf_event_update(cpuhw->event, 0);\r\nelse\r\nWARN_ON_ONCE(!(cpuhw->flags & PMU_F_IN_USE));\r\n}\r\nif (alert != CPU_MF_INT_SF_PRA)\r\ndebug_sprintf_event(sfdbg, 6, "measurement alert: 0x%x\n", alert);\r\nif (alert & CPU_MF_INT_SF_SACA)\r\nqsi(&cpuhw->qsi);\r\nif (alert & CPU_MF_INT_SF_LSDA) {\r\npr_err("Sample data was lost\n");\r\ncpuhw->flags |= PMU_F_ERR_LSDA;\r\nsf_disable();\r\n}\r\nif (alert & (CPU_MF_INT_SF_IAE|CPU_MF_INT_SF_ISE)) {\r\npr_err("A sampling buffer entry is incorrect (alert=0x%x)\n",\r\nalert);\r\ncpuhw->flags |= PMU_F_ERR_IBE;\r\nsf_disable();\r\n}\r\n}\r\nstatic int cpumf_pmu_notifier(struct notifier_block *self,\r\nunsigned long action, void *hcpu)\r\n{\r\nunsigned int cpu = (long) hcpu;\r\nint flags;\r\nif (!atomic_read(&num_events))\r\nreturn NOTIFY_OK;\r\nswitch (action & ~CPU_TASKS_FROZEN) {\r\ncase CPU_ONLINE:\r\ncase CPU_ONLINE_FROZEN:\r\nflags = PMC_INIT;\r\nsmp_call_function_single(cpu, setup_pmc_cpu, &flags, 1);\r\nbreak;\r\ncase CPU_DOWN_PREPARE:\r\nflags = PMC_RELEASE;\r\nsmp_call_function_single(cpu, setup_pmc_cpu, &flags, 1);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int param_get_sfb_size(char *buffer, const struct kernel_param *kp)\r\n{\r\nif (!cpum_sf_avail())\r\nreturn -ENODEV;\r\nreturn sprintf(buffer, "%lu,%lu", CPUM_SF_MIN_SDB, CPUM_SF_MAX_SDB);\r\n}\r\nstatic int param_set_sfb_size(const char *val, const struct kernel_param *kp)\r\n{\r\nint rc;\r\nunsigned long min, max;\r\nif (!cpum_sf_avail())\r\nreturn -ENODEV;\r\nif (!val || !strlen(val))\r\nreturn -EINVAL;\r\nmin = CPUM_SF_MIN_SDB;\r\nmax = CPUM_SF_MAX_SDB;\r\nif (strchr(val, ','))\r\nrc = (sscanf(val, "%lu,%lu", &min, &max) == 2) ? 0 : -EINVAL;\r\nelse\r\nrc = kstrtoul(val, 10, &max);\r\nif (min < 2 || min >= max || max > get_num_physpages())\r\nrc = -EINVAL;\r\nif (rc)\r\nreturn rc;\r\nsfb_set_limits(min, max);\r\npr_info("The sampling buffer limits have changed to: "\r\n"min=%lu max=%lu (diag=x%lu)\n",\r\nCPUM_SF_MIN_SDB, CPUM_SF_MAX_SDB, CPUM_SF_SDB_DIAG_FACTOR);\r\nreturn 0;\r\n}\r\nstatic void __init pr_cpumsf_err(unsigned int reason)\r\n{\r\npr_err("Sampling facility support for perf is not available: "\r\n"reason=%04x\n", reason);\r\n}\r\nstatic int __init init_cpum_sampling_pmu(void)\r\n{\r\nstruct hws_qsi_info_block si;\r\nint err;\r\nif (!cpum_sf_avail())\r\nreturn -ENODEV;\r\nmemset(&si, 0, sizeof(si));\r\nif (qsi(&si)) {\r\npr_cpumsf_err(RS_INIT_FAILURE_QSI);\r\nreturn -ENODEV;\r\n}\r\nif (si.bsdes != sizeof(struct hws_basic_entry)) {\r\npr_cpumsf_err(RS_INIT_FAILURE_BSDES);\r\nreturn -EINVAL;\r\n}\r\nif (si.ad) {\r\nsfb_set_limits(CPUM_SF_MIN_SDB, CPUM_SF_MAX_SDB);\r\ncpumsf_pmu_events_attr[1] =\r\nCPUMF_EVENT_PTR(SF, SF_CYCLES_BASIC_DIAG);\r\n}\r\nsfdbg = debug_register(KMSG_COMPONENT, 2, 1, 80);\r\nif (!sfdbg)\r\npr_err("Registering for s390dbf failed\n");\r\ndebug_register_view(sfdbg, &debug_sprintf_view);\r\nerr = register_external_irq(EXT_IRQ_MEASURE_ALERT,\r\ncpumf_measurement_alert);\r\nif (err) {\r\npr_cpumsf_err(RS_INIT_FAILURE_ALRT);\r\ngoto out;\r\n}\r\nerr = perf_pmu_register(&cpumf_sampling, "cpum_sf", PERF_TYPE_RAW);\r\nif (err) {\r\npr_cpumsf_err(RS_INIT_FAILURE_PERF);\r\nunregister_external_irq(EXT_IRQ_MEASURE_ALERT,\r\ncpumf_measurement_alert);\r\ngoto out;\r\n}\r\nperf_cpu_notifier(cpumf_pmu_notifier);\r\nout:\r\nreturn err;\r\n}
