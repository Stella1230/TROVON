void __init init_vdso_image(const struct vdso_image *image)\r\n{\r\nint i;\r\nint npages = (image->size) / PAGE_SIZE;\r\nBUG_ON(image->size % PAGE_SIZE != 0);\r\nfor (i = 0; i < npages; i++)\r\nimage->text_mapping.pages[i] =\r\nvirt_to_page(image->data + i*PAGE_SIZE);\r\napply_alternatives((struct alt_instr *)(image->data + image->alt),\r\n(struct alt_instr *)(image->data + image->alt +\r\nimage->alt_len));\r\n}\r\nstatic unsigned long vdso_addr(unsigned long start, unsigned len)\r\n{\r\n#ifdef CONFIG_X86_32\r\nreturn 0;\r\n#else\r\nunsigned long addr, end;\r\nunsigned offset;\r\nstart = PAGE_ALIGN(start);\r\nend = (start + len + PMD_SIZE - 1) & PMD_MASK;\r\nif (end >= TASK_SIZE_MAX)\r\nend = TASK_SIZE_MAX;\r\nend -= len;\r\nif (end > start) {\r\noffset = get_random_int() % (((end - start) >> PAGE_SHIFT) + 1);\r\naddr = start + (offset << PAGE_SHIFT);\r\n} else {\r\naddr = start;\r\n}\r\naddr = align_vdso_addr(addr);\r\nreturn addr;\r\n#endif\r\n}\r\nstatic int map_vdso(const struct vdso_image *image, bool calculate_addr)\r\n{\r\nstruct mm_struct *mm = current->mm;\r\nstruct vm_area_struct *vma;\r\nunsigned long addr, text_start;\r\nint ret = 0;\r\nstatic struct page *no_pages[] = {NULL};\r\nstatic struct vm_special_mapping vvar_mapping = {\r\n.name = "[vvar]",\r\n.pages = no_pages,\r\n};\r\nif (calculate_addr) {\r\naddr = vdso_addr(current->mm->start_stack,\r\nimage->size - image->sym_vvar_start);\r\n} else {\r\naddr = 0;\r\n}\r\ndown_write(&mm->mmap_sem);\r\naddr = get_unmapped_area(NULL, addr,\r\nimage->size - image->sym_vvar_start, 0, 0);\r\nif (IS_ERR_VALUE(addr)) {\r\nret = addr;\r\ngoto up_fail;\r\n}\r\ntext_start = addr - image->sym_vvar_start;\r\ncurrent->mm->context.vdso = (void __user *)text_start;\r\nvma = _install_special_mapping(mm,\r\ntext_start,\r\nimage->size,\r\nVM_READ|VM_EXEC|\r\nVM_MAYREAD|VM_MAYWRITE|VM_MAYEXEC,\r\n&image->text_mapping);\r\nif (IS_ERR(vma)) {\r\nret = PTR_ERR(vma);\r\ngoto up_fail;\r\n}\r\nvma = _install_special_mapping(mm,\r\naddr,\r\n-image->sym_vvar_start,\r\nVM_READ|VM_MAYREAD,\r\n&vvar_mapping);\r\nif (IS_ERR(vma)) {\r\nret = PTR_ERR(vma);\r\ngoto up_fail;\r\n}\r\nif (image->sym_vvar_page)\r\nret = remap_pfn_range(vma,\r\ntext_start + image->sym_vvar_page,\r\n__pa_symbol(&__vvar_page) >> PAGE_SHIFT,\r\nPAGE_SIZE,\r\nPAGE_READONLY);\r\nif (ret)\r\ngoto up_fail;\r\n#ifdef CONFIG_HPET_TIMER\r\nif (hpet_address && image->sym_hpet_page) {\r\nret = io_remap_pfn_range(vma,\r\ntext_start + image->sym_hpet_page,\r\nhpet_address >> PAGE_SHIFT,\r\nPAGE_SIZE,\r\npgprot_noncached(PAGE_READONLY));\r\nif (ret)\r\ngoto up_fail;\r\n}\r\n#endif\r\nup_fail:\r\nif (ret)\r\ncurrent->mm->context.vdso = NULL;\r\nup_write(&mm->mmap_sem);\r\nreturn ret;\r\n}\r\nstatic int load_vdso32(void)\r\n{\r\nint ret;\r\nif (vdso32_enabled != 1)\r\nreturn 0;\r\nret = map_vdso(selected_vdso32, false);\r\nif (ret)\r\nreturn ret;\r\nif (selected_vdso32->sym_VDSO32_SYSENTER_RETURN)\r\ncurrent_thread_info()->sysenter_return =\r\ncurrent->mm->context.vdso +\r\nselected_vdso32->sym_VDSO32_SYSENTER_RETURN;\r\nreturn 0;\r\n}\r\nint arch_setup_additional_pages(struct linux_binprm *bprm, int uses_interp)\r\n{\r\nif (!vdso64_enabled)\r\nreturn 0;\r\nreturn map_vdso(&vdso_image_64, true);\r\n}\r\nint compat_arch_setup_additional_pages(struct linux_binprm *bprm,\r\nint uses_interp)\r\n{\r\n#ifdef CONFIG_X86_X32_ABI\r\nif (test_thread_flag(TIF_X32)) {\r\nif (!vdso64_enabled)\r\nreturn 0;\r\nreturn map_vdso(&vdso_image_x32, true);\r\n}\r\n#endif\r\nreturn load_vdso32();\r\n}\r\nint arch_setup_additional_pages(struct linux_binprm *bprm, int uses_interp)\r\n{\r\nreturn load_vdso32();\r\n}\r\nstatic __init int vdso_setup(char *s)\r\n{\r\nvdso64_enabled = simple_strtoul(s, NULL, 0);\r\nreturn 0;\r\n}\r\nstatic void vgetcpu_cpu_init(void *arg)\r\n{\r\nint cpu = smp_processor_id();\r\nstruct desc_struct d = { };\r\nunsigned long node = 0;\r\n#ifdef CONFIG_NUMA\r\nnode = cpu_to_node(cpu);\r\n#endif\r\nif (cpu_has(&cpu_data(cpu), X86_FEATURE_RDTSCP))\r\nwrite_rdtscp_aux((node << 12) | cpu);\r\nd.limit0 = cpu | ((node & 0xf) << 12);\r\nd.limit = node >> 4;\r\nd.type = 5;\r\nd.dpl = 3;\r\nd.s = 1;\r\nd.p = 1;\r\nd.d = 1;\r\nwrite_gdt_entry(get_cpu_gdt_table(cpu), GDT_ENTRY_PER_CPU, &d, DESCTYPE_S);\r\n}\r\nstatic int\r\nvgetcpu_cpu_notifier(struct notifier_block *n, unsigned long action, void *arg)\r\n{\r\nlong cpu = (long)arg;\r\nif (action == CPU_ONLINE || action == CPU_ONLINE_FROZEN)\r\nsmp_call_function_single(cpu, vgetcpu_cpu_init, NULL, 1);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int __init init_vdso(void)\r\n{\r\ninit_vdso_image(&vdso_image_64);\r\n#ifdef CONFIG_X86_X32_ABI\r\ninit_vdso_image(&vdso_image_x32);\r\n#endif\r\ncpu_notifier_register_begin();\r\non_each_cpu(vgetcpu_cpu_init, NULL, 1);\r\n__hotcpu_notifier(vgetcpu_cpu_notifier, 30);\r\ncpu_notifier_register_done();\r\nreturn 0;\r\n}
