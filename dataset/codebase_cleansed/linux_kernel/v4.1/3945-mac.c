__le32\r\nil3945_get_antenna_flags(const struct il_priv *il)\r\n{\r\nstruct il3945_eeprom *eeprom = (struct il3945_eeprom *)il->eeprom;\r\nswitch (il3945_mod_params.antenna) {\r\ncase IL_ANTENNA_DIVERSITY:\r\nreturn 0;\r\ncase IL_ANTENNA_MAIN:\r\nif (eeprom->antenna_switch_type)\r\nreturn RXON_FLG_DIS_DIV_MSK | RXON_FLG_ANT_B_MSK;\r\nreturn RXON_FLG_DIS_DIV_MSK | RXON_FLG_ANT_A_MSK;\r\ncase IL_ANTENNA_AUX:\r\nif (eeprom->antenna_switch_type)\r\nreturn RXON_FLG_DIS_DIV_MSK | RXON_FLG_ANT_A_MSK;\r\nreturn RXON_FLG_DIS_DIV_MSK | RXON_FLG_ANT_B_MSK;\r\n}\r\nIL_ERR("Bad antenna selector value (0x%x)\n",\r\nil3945_mod_params.antenna);\r\nreturn 0;\r\n}\r\nstatic int\r\nil3945_set_ccmp_dynamic_key_info(struct il_priv *il,\r\nstruct ieee80211_key_conf *keyconf, u8 sta_id)\r\n{\r\nunsigned long flags;\r\n__le16 key_flags = 0;\r\nint ret;\r\nkey_flags |= (STA_KEY_FLG_CCMP | STA_KEY_FLG_MAP_KEY_MSK);\r\nkey_flags |= cpu_to_le16(keyconf->keyidx << STA_KEY_FLG_KEYID_POS);\r\nif (sta_id == il->hw_params.bcast_id)\r\nkey_flags |= STA_KEY_MULTICAST_MSK;\r\nkeyconf->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;\r\nkeyconf->hw_key_idx = keyconf->keyidx;\r\nkey_flags &= ~STA_KEY_FLG_INVALID;\r\nspin_lock_irqsave(&il->sta_lock, flags);\r\nil->stations[sta_id].keyinfo.cipher = keyconf->cipher;\r\nil->stations[sta_id].keyinfo.keylen = keyconf->keylen;\r\nmemcpy(il->stations[sta_id].keyinfo.key, keyconf->key, keyconf->keylen);\r\nmemcpy(il->stations[sta_id].sta.key.key, keyconf->key, keyconf->keylen);\r\nif ((il->stations[sta_id].sta.key.\r\nkey_flags & STA_KEY_FLG_ENCRYPT_MSK) == STA_KEY_FLG_NO_ENC)\r\nil->stations[sta_id].sta.key.key_offset =\r\nil_get_free_ucode_key_idx(il);\r\nWARN(il->stations[sta_id].sta.key.key_offset == WEP_INVALID_OFFSET,\r\n"no space for a new key");\r\nil->stations[sta_id].sta.key.key_flags = key_flags;\r\nil->stations[sta_id].sta.sta.modify_mask = STA_MODIFY_KEY_MASK;\r\nil->stations[sta_id].sta.mode = STA_CONTROL_MODIFY_MSK;\r\nD_INFO("hwcrypto: modify ucode station key info\n");\r\nret = il_send_add_sta(il, &il->stations[sta_id].sta, CMD_ASYNC);\r\nspin_unlock_irqrestore(&il->sta_lock, flags);\r\nreturn ret;\r\n}\r\nstatic int\r\nil3945_set_tkip_dynamic_key_info(struct il_priv *il,\r\nstruct ieee80211_key_conf *keyconf, u8 sta_id)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int\r\nil3945_set_wep_dynamic_key_info(struct il_priv *il,\r\nstruct ieee80211_key_conf *keyconf, u8 sta_id)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int\r\nil3945_clear_sta_key_info(struct il_priv *il, u8 sta_id)\r\n{\r\nunsigned long flags;\r\nstruct il_addsta_cmd sta_cmd;\r\nspin_lock_irqsave(&il->sta_lock, flags);\r\nmemset(&il->stations[sta_id].keyinfo, 0, sizeof(struct il_hw_key));\r\nmemset(&il->stations[sta_id].sta.key, 0, sizeof(struct il4965_keyinfo));\r\nil->stations[sta_id].sta.key.key_flags = STA_KEY_FLG_NO_ENC;\r\nil->stations[sta_id].sta.sta.modify_mask = STA_MODIFY_KEY_MASK;\r\nil->stations[sta_id].sta.mode = STA_CONTROL_MODIFY_MSK;\r\nmemcpy(&sta_cmd, &il->stations[sta_id].sta,\r\nsizeof(struct il_addsta_cmd));\r\nspin_unlock_irqrestore(&il->sta_lock, flags);\r\nD_INFO("hwcrypto: clear ucode station key info\n");\r\nreturn il_send_add_sta(il, &sta_cmd, CMD_SYNC);\r\n}\r\nstatic int\r\nil3945_set_dynamic_key(struct il_priv *il, struct ieee80211_key_conf *keyconf,\r\nu8 sta_id)\r\n{\r\nint ret = 0;\r\nkeyconf->hw_key_idx = HW_KEY_DYNAMIC;\r\nswitch (keyconf->cipher) {\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\nret = il3945_set_ccmp_dynamic_key_info(il, keyconf, sta_id);\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\nret = il3945_set_tkip_dynamic_key_info(il, keyconf, sta_id);\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\nret = il3945_set_wep_dynamic_key_info(il, keyconf, sta_id);\r\nbreak;\r\ndefault:\r\nIL_ERR("Unknown alg: %s alg=%x\n", __func__, keyconf->cipher);\r\nret = -EINVAL;\r\n}\r\nD_WEP("Set dynamic key: alg=%x len=%d idx=%d sta=%d ret=%d\n",\r\nkeyconf->cipher, keyconf->keylen, keyconf->keyidx, sta_id, ret);\r\nreturn ret;\r\n}\r\nstatic int\r\nil3945_remove_static_key(struct il_priv *il)\r\n{\r\nint ret = -EOPNOTSUPP;\r\nreturn ret;\r\n}\r\nstatic int\r\nil3945_set_static_key(struct il_priv *il, struct ieee80211_key_conf *key)\r\n{\r\nif (key->cipher == WLAN_CIPHER_SUITE_WEP40 ||\r\nkey->cipher == WLAN_CIPHER_SUITE_WEP104)\r\nreturn -EOPNOTSUPP;\r\nIL_ERR("Static key invalid: cipher %x\n", key->cipher);\r\nreturn -EINVAL;\r\n}\r\nstatic void\r\nil3945_clear_free_frames(struct il_priv *il)\r\n{\r\nstruct list_head *element;\r\nD_INFO("%d frames on pre-allocated heap on clear.\n", il->frames_count);\r\nwhile (!list_empty(&il->free_frames)) {\r\nelement = il->free_frames.next;\r\nlist_del(element);\r\nkfree(list_entry(element, struct il3945_frame, list));\r\nil->frames_count--;\r\n}\r\nif (il->frames_count) {\r\nIL_WARN("%d frames still in use. Did we lose one?\n",\r\nil->frames_count);\r\nil->frames_count = 0;\r\n}\r\n}\r\nstatic struct il3945_frame *\r\nil3945_get_free_frame(struct il_priv *il)\r\n{\r\nstruct il3945_frame *frame;\r\nstruct list_head *element;\r\nif (list_empty(&il->free_frames)) {\r\nframe = kzalloc(sizeof(*frame), GFP_KERNEL);\r\nif (!frame) {\r\nIL_ERR("Could not allocate frame!\n");\r\nreturn NULL;\r\n}\r\nil->frames_count++;\r\nreturn frame;\r\n}\r\nelement = il->free_frames.next;\r\nlist_del(element);\r\nreturn list_entry(element, struct il3945_frame, list);\r\n}\r\nstatic void\r\nil3945_free_frame(struct il_priv *il, struct il3945_frame *frame)\r\n{\r\nmemset(frame, 0, sizeof(*frame));\r\nlist_add(&frame->list, &il->free_frames);\r\n}\r\nunsigned int\r\nil3945_fill_beacon_frame(struct il_priv *il, struct ieee80211_hdr *hdr,\r\nint left)\r\n{\r\nif (!il_is_associated(il) || !il->beacon_skb)\r\nreturn 0;\r\nif (il->beacon_skb->len > left)\r\nreturn 0;\r\nmemcpy(hdr, il->beacon_skb->data, il->beacon_skb->len);\r\nreturn il->beacon_skb->len;\r\n}\r\nstatic int\r\nil3945_send_beacon_cmd(struct il_priv *il)\r\n{\r\nstruct il3945_frame *frame;\r\nunsigned int frame_size;\r\nint rc;\r\nu8 rate;\r\nframe = il3945_get_free_frame(il);\r\nif (!frame) {\r\nIL_ERR("Could not obtain free frame buffer for beacon "\r\n"command.\n");\r\nreturn -ENOMEM;\r\n}\r\nrate = il_get_lowest_plcp(il);\r\nframe_size = il3945_hw_get_beacon_cmd(il, frame, rate);\r\nrc = il_send_cmd_pdu(il, C_TX_BEACON, frame_size, &frame->u.cmd[0]);\r\nil3945_free_frame(il, frame);\r\nreturn rc;\r\n}\r\nstatic void\r\nil3945_unset_hw_params(struct il_priv *il)\r\n{\r\nif (il->_3945.shared_virt)\r\ndma_free_coherent(&il->pci_dev->dev,\r\nsizeof(struct il3945_shared),\r\nil->_3945.shared_virt, il->_3945.shared_phys);\r\n}\r\nstatic void\r\nil3945_build_tx_cmd_hwcrypto(struct il_priv *il, struct ieee80211_tx_info *info,\r\nstruct il_device_cmd *cmd,\r\nstruct sk_buff *skb_frag, int sta_id)\r\n{\r\nstruct il3945_tx_cmd *tx_cmd = (struct il3945_tx_cmd *)cmd->cmd.payload;\r\nstruct il_hw_key *keyinfo = &il->stations[sta_id].keyinfo;\r\ntx_cmd->sec_ctl = 0;\r\nswitch (keyinfo->cipher) {\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\ntx_cmd->sec_ctl = TX_CMD_SEC_CCM;\r\nmemcpy(tx_cmd->key, keyinfo->key, keyinfo->keylen);\r\nD_TX("tx_cmd with AES hwcrypto\n");\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\ntx_cmd->sec_ctl |= TX_CMD_SEC_KEY128;\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\ntx_cmd->sec_ctl |=\r\nTX_CMD_SEC_WEP | (info->control.hw_key->\r\nhw_key_idx & TX_CMD_SEC_MSK) <<\r\nTX_CMD_SEC_SHIFT;\r\nmemcpy(&tx_cmd->key[3], keyinfo->key, keyinfo->keylen);\r\nD_TX("Configuring packet for WEP encryption " "with key %d\n",\r\ninfo->control.hw_key->hw_key_idx);\r\nbreak;\r\ndefault:\r\nIL_ERR("Unknown encode cipher %x\n", keyinfo->cipher);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nil3945_build_tx_cmd_basic(struct il_priv *il, struct il_device_cmd *cmd,\r\nstruct ieee80211_tx_info *info,\r\nstruct ieee80211_hdr *hdr, u8 std_id)\r\n{\r\nstruct il3945_tx_cmd *tx_cmd = (struct il3945_tx_cmd *)cmd->cmd.payload;\r\n__le32 tx_flags = tx_cmd->tx_flags;\r\n__le16 fc = hdr->frame_control;\r\ntx_cmd->stop_time.life_time = TX_CMD_LIFE_TIME_INFINITE;\r\nif (!(info->flags & IEEE80211_TX_CTL_NO_ACK)) {\r\ntx_flags |= TX_CMD_FLG_ACK_MSK;\r\nif (ieee80211_is_mgmt(fc))\r\ntx_flags |= TX_CMD_FLG_SEQ_CTL_MSK;\r\nif (ieee80211_is_probe_resp(fc) &&\r\n!(le16_to_cpu(hdr->seq_ctrl) & 0xf))\r\ntx_flags |= TX_CMD_FLG_TSF_MSK;\r\n} else {\r\ntx_flags &= (~TX_CMD_FLG_ACK_MSK);\r\ntx_flags |= TX_CMD_FLG_SEQ_CTL_MSK;\r\n}\r\ntx_cmd->sta_id = std_id;\r\nif (ieee80211_has_morefrags(fc))\r\ntx_flags |= TX_CMD_FLG_MORE_FRAG_MSK;\r\nif (ieee80211_is_data_qos(fc)) {\r\nu8 *qc = ieee80211_get_qos_ctl(hdr);\r\ntx_cmd->tid_tspec = qc[0] & 0xf;\r\ntx_flags &= ~TX_CMD_FLG_SEQ_CTL_MSK;\r\n} else {\r\ntx_flags |= TX_CMD_FLG_SEQ_CTL_MSK;\r\n}\r\nil_tx_cmd_protection(il, info, fc, &tx_flags);\r\ntx_flags &= ~(TX_CMD_FLG_ANT_SEL_MSK);\r\nif (ieee80211_is_mgmt(fc)) {\r\nif (ieee80211_is_assoc_req(fc) || ieee80211_is_reassoc_req(fc))\r\ntx_cmd->timeout.pm_frame_timeout = cpu_to_le16(3);\r\nelse\r\ntx_cmd->timeout.pm_frame_timeout = cpu_to_le16(2);\r\n} else {\r\ntx_cmd->timeout.pm_frame_timeout = 0;\r\n}\r\ntx_cmd->driver_txop = 0;\r\ntx_cmd->tx_flags = tx_flags;\r\ntx_cmd->next_frame_len = 0;\r\n}\r\nstatic int\r\nil3945_tx_skb(struct il_priv *il,\r\nstruct ieee80211_sta *sta,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nstruct il3945_tx_cmd *tx_cmd;\r\nstruct il_tx_queue *txq = NULL;\r\nstruct il_queue *q = NULL;\r\nstruct il_device_cmd *out_cmd;\r\nstruct il_cmd_meta *out_meta;\r\ndma_addr_t phys_addr;\r\ndma_addr_t txcmd_phys;\r\nint txq_id = skb_get_queue_mapping(skb);\r\nu16 len, idx, hdr_len;\r\nu16 firstlen, secondlen;\r\nu8 id;\r\nu8 unicast;\r\nu8 sta_id;\r\nu8 tid = 0;\r\n__le16 fc;\r\nu8 wait_write_ptr = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&il->lock, flags);\r\nif (il_is_rfkill(il)) {\r\nD_DROP("Dropping - RF KILL\n");\r\ngoto drop_unlock;\r\n}\r\nif ((ieee80211_get_tx_rate(il->hw, info)->hw_value & 0xFF) ==\r\nIL_INVALID_RATE) {\r\nIL_ERR("ERROR: No TX rate available.\n");\r\ngoto drop_unlock;\r\n}\r\nunicast = !is_multicast_ether_addr(hdr->addr1);\r\nid = 0;\r\nfc = hdr->frame_control;\r\n#ifdef CONFIG_IWLEGACY_DEBUG\r\nif (ieee80211_is_auth(fc))\r\nD_TX("Sending AUTH frame\n");\r\nelse if (ieee80211_is_assoc_req(fc))\r\nD_TX("Sending ASSOC frame\n");\r\nelse if (ieee80211_is_reassoc_req(fc))\r\nD_TX("Sending REASSOC frame\n");\r\n#endif\r\nspin_unlock_irqrestore(&il->lock, flags);\r\nhdr_len = ieee80211_hdrlen(fc);\r\nsta_id = il_sta_id_or_broadcast(il, sta);\r\nif (sta_id == IL_INVALID_STATION) {\r\nD_DROP("Dropping - INVALID STATION: %pM\n", hdr->addr1);\r\ngoto drop;\r\n}\r\nD_RATE("station Id %d\n", sta_id);\r\nif (ieee80211_is_data_qos(fc)) {\r\nu8 *qc = ieee80211_get_qos_ctl(hdr);\r\ntid = qc[0] & IEEE80211_QOS_CTL_TID_MASK;\r\nif (unlikely(tid >= MAX_TID_COUNT))\r\ngoto drop;\r\n}\r\ntxq = &il->txq[txq_id];\r\nq = &txq->q;\r\nif ((il_queue_space(q) < q->high_mark))\r\ngoto drop;\r\nspin_lock_irqsave(&il->lock, flags);\r\nidx = il_get_cmd_idx(q, q->write_ptr, 0);\r\ntxq->skbs[q->write_ptr] = skb;\r\nout_cmd = txq->cmd[idx];\r\nout_meta = &txq->meta[idx];\r\ntx_cmd = (struct il3945_tx_cmd *)out_cmd->cmd.payload;\r\nmemset(&out_cmd->hdr, 0, sizeof(out_cmd->hdr));\r\nmemset(tx_cmd, 0, sizeof(*tx_cmd));\r\nout_cmd->hdr.cmd = C_TX;\r\nout_cmd->hdr.sequence =\r\ncpu_to_le16((u16)\r\n(QUEUE_TO_SEQ(txq_id) | IDX_TO_SEQ(q->write_ptr)));\r\nmemcpy(tx_cmd->hdr, hdr, hdr_len);\r\nif (info->control.hw_key)\r\nil3945_build_tx_cmd_hwcrypto(il, info, out_cmd, skb, sta_id);\r\nil3945_build_tx_cmd_basic(il, out_cmd, info, hdr, sta_id);\r\nil3945_hw_build_tx_cmd_rate(il, out_cmd, info, hdr, sta_id);\r\ntx_cmd->len = cpu_to_le16((u16) skb->len);\r\ntx_cmd->tx_flags &= ~TX_CMD_FLG_ANT_A_MSK;\r\ntx_cmd->tx_flags &= ~TX_CMD_FLG_ANT_B_MSK;\r\nlen =\r\nsizeof(struct il3945_tx_cmd) + sizeof(struct il_cmd_header) +\r\nhdr_len;\r\nfirstlen = (len + 3) & ~3;\r\ntxcmd_phys =\r\npci_map_single(il->pci_dev, &out_cmd->hdr, firstlen,\r\nPCI_DMA_TODEVICE);\r\nif (unlikely(pci_dma_mapping_error(il->pci_dev, txcmd_phys)))\r\ngoto drop_unlock;\r\nsecondlen = skb->len - hdr_len;\r\nif (secondlen > 0) {\r\nphys_addr =\r\npci_map_single(il->pci_dev, skb->data + hdr_len, secondlen,\r\nPCI_DMA_TODEVICE);\r\nif (unlikely(pci_dma_mapping_error(il->pci_dev, phys_addr)))\r\ngoto drop_unlock;\r\n}\r\nil->ops->txq_attach_buf_to_tfd(il, txq, txcmd_phys, firstlen, 1, 0);\r\ndma_unmap_addr_set(out_meta, mapping, txcmd_phys);\r\ndma_unmap_len_set(out_meta, len, firstlen);\r\nif (secondlen > 0)\r\nil->ops->txq_attach_buf_to_tfd(il, txq, phys_addr, secondlen, 0,\r\nU32_PAD(secondlen));\r\nif (!ieee80211_has_morefrags(hdr->frame_control)) {\r\ntxq->need_update = 1;\r\n} else {\r\nwait_write_ptr = 1;\r\ntxq->need_update = 0;\r\n}\r\nil_update_stats(il, true, fc, skb->len);\r\nD_TX("sequence nr = 0X%x\n", le16_to_cpu(out_cmd->hdr.sequence));\r\nD_TX("tx_flags = 0X%x\n", le32_to_cpu(tx_cmd->tx_flags));\r\nil_print_hex_dump(il, IL_DL_TX, tx_cmd, sizeof(*tx_cmd));\r\nil_print_hex_dump(il, IL_DL_TX, (u8 *) tx_cmd->hdr,\r\nieee80211_hdrlen(fc));\r\nq->write_ptr = il_queue_inc_wrap(q->write_ptr, q->n_bd);\r\nil_txq_update_write_ptr(il, txq);\r\nspin_unlock_irqrestore(&il->lock, flags);\r\nif (il_queue_space(q) < q->high_mark && il->mac80211_registered) {\r\nif (wait_write_ptr) {\r\nspin_lock_irqsave(&il->lock, flags);\r\ntxq->need_update = 1;\r\nil_txq_update_write_ptr(il, txq);\r\nspin_unlock_irqrestore(&il->lock, flags);\r\n}\r\nil_stop_queue(il, txq);\r\n}\r\nreturn 0;\r\ndrop_unlock:\r\nspin_unlock_irqrestore(&il->lock, flags);\r\ndrop:\r\nreturn -1;\r\n}\r\nstatic int\r\nil3945_get_measurement(struct il_priv *il,\r\nstruct ieee80211_measurement_params *params, u8 type)\r\n{\r\nstruct il_spectrum_cmd spectrum;\r\nstruct il_rx_pkt *pkt;\r\nstruct il_host_cmd cmd = {\r\n.id = C_SPECTRUM_MEASUREMENT,\r\n.data = (void *)&spectrum,\r\n.flags = CMD_WANT_SKB,\r\n};\r\nu32 add_time = le64_to_cpu(params->start_time);\r\nint rc;\r\nint spectrum_resp_status;\r\nint duration = le16_to_cpu(params->duration);\r\nif (il_is_associated(il))\r\nadd_time =\r\nil_usecs_to_beacons(il,\r\nle64_to_cpu(params->start_time) -\r\nil->_3945.last_tsf,\r\nle16_to_cpu(il->timing.beacon_interval));\r\nmemset(&spectrum, 0, sizeof(spectrum));\r\nspectrum.channel_count = cpu_to_le16(1);\r\nspectrum.flags =\r\nRXON_FLG_TSF2HOST_MSK | RXON_FLG_ANT_A_MSK | RXON_FLG_DIS_DIV_MSK;\r\nspectrum.filter_flags = MEASUREMENT_FILTER_FLAG;\r\ncmd.len = sizeof(spectrum);\r\nspectrum.len = cpu_to_le16(cmd.len - sizeof(spectrum.len));\r\nif (il_is_associated(il))\r\nspectrum.start_time =\r\nil_add_beacon_time(il, il->_3945.last_beacon_time, add_time,\r\nle16_to_cpu(il->timing.beacon_interval));\r\nelse\r\nspectrum.start_time = 0;\r\nspectrum.channels[0].duration = cpu_to_le32(duration * TIME_UNIT);\r\nspectrum.channels[0].channel = params->channel;\r\nspectrum.channels[0].type = type;\r\nif (il->active.flags & RXON_FLG_BAND_24G_MSK)\r\nspectrum.flags |=\r\nRXON_FLG_BAND_24G_MSK | RXON_FLG_AUTO_DETECT_MSK |\r\nRXON_FLG_TGG_PROTECT_MSK;\r\nrc = il_send_cmd_sync(il, &cmd);\r\nif (rc)\r\nreturn rc;\r\npkt = (struct il_rx_pkt *)cmd.reply_page;\r\nif (pkt->hdr.flags & IL_CMD_FAILED_MSK) {\r\nIL_ERR("Bad return from N_RX_ON_ASSOC command\n");\r\nrc = -EIO;\r\n}\r\nspectrum_resp_status = le16_to_cpu(pkt->u.spectrum.status);\r\nswitch (spectrum_resp_status) {\r\ncase 0:\r\nif (pkt->u.spectrum.id != 0xff) {\r\nD_INFO("Replaced existing measurement: %d\n",\r\npkt->u.spectrum.id);\r\nil->measurement_status &= ~MEASUREMENT_READY;\r\n}\r\nil->measurement_status |= MEASUREMENT_ACTIVE;\r\nrc = 0;\r\nbreak;\r\ncase 1:\r\nrc = -EAGAIN;\r\nbreak;\r\n}\r\nil_free_pages(il, cmd.reply_page);\r\nreturn rc;\r\n}\r\nstatic void\r\nil3945_hdl_alive(struct il_priv *il, struct il_rx_buf *rxb)\r\n{\r\nstruct il_rx_pkt *pkt = rxb_addr(rxb);\r\nstruct il_alive_resp *palive;\r\nstruct delayed_work *pwork;\r\npalive = &pkt->u.alive_frame;\r\nD_INFO("Alive ucode status 0x%08X revision " "0x%01X 0x%01X\n",\r\npalive->is_valid, palive->ver_type, palive->ver_subtype);\r\nif (palive->ver_subtype == INITIALIZE_SUBTYPE) {\r\nD_INFO("Initialization Alive received.\n");\r\nmemcpy(&il->card_alive_init, &pkt->u.alive_frame,\r\nsizeof(struct il_alive_resp));\r\npwork = &il->init_alive_start;\r\n} else {\r\nD_INFO("Runtime Alive received.\n");\r\nmemcpy(&il->card_alive, &pkt->u.alive_frame,\r\nsizeof(struct il_alive_resp));\r\npwork = &il->alive_start;\r\nil3945_disable_events(il);\r\n}\r\nif (palive->is_valid == UCODE_VALID_OK)\r\nqueue_delayed_work(il->workqueue, pwork, msecs_to_jiffies(5));\r\nelse\r\nIL_WARN("uCode did not respond OK.\n");\r\n}\r\nstatic void\r\nil3945_hdl_add_sta(struct il_priv *il, struct il_rx_buf *rxb)\r\n{\r\n#ifdef CONFIG_IWLEGACY_DEBUG\r\nstruct il_rx_pkt *pkt = rxb_addr(rxb);\r\n#endif\r\nD_RX("Received C_ADD_STA: 0x%02X\n", pkt->u.status);\r\n}\r\nstatic void\r\nil3945_hdl_beacon(struct il_priv *il, struct il_rx_buf *rxb)\r\n{\r\nstruct il_rx_pkt *pkt = rxb_addr(rxb);\r\nstruct il3945_beacon_notif *beacon = &(pkt->u.beacon_status);\r\n#ifdef CONFIG_IWLEGACY_DEBUG\r\nu8 rate = beacon->beacon_notify_hdr.rate;\r\nD_RX("beacon status %x retries %d iss %d " "tsf %d %d rate %d\n",\r\nle32_to_cpu(beacon->beacon_notify_hdr.status) & TX_STATUS_MSK,\r\nbeacon->beacon_notify_hdr.failure_frame,\r\nle32_to_cpu(beacon->ibss_mgr_status),\r\nle32_to_cpu(beacon->high_tsf), le32_to_cpu(beacon->low_tsf), rate);\r\n#endif\r\nil->ibss_manager = le32_to_cpu(beacon->ibss_mgr_status);\r\n}\r\nstatic void\r\nil3945_hdl_card_state(struct il_priv *il, struct il_rx_buf *rxb)\r\n{\r\nstruct il_rx_pkt *pkt = rxb_addr(rxb);\r\nu32 flags = le32_to_cpu(pkt->u.card_state_notif.flags);\r\nunsigned long status = il->status;\r\nIL_WARN("Card state received: HW:%s SW:%s\n",\r\n(flags & HW_CARD_DISABLED) ? "Kill" : "On",\r\n(flags & SW_CARD_DISABLED) ? "Kill" : "On");\r\n_il_wr(il, CSR_UCODE_DRV_GP1_SET, CSR_UCODE_DRV_GP1_BIT_CMD_BLOCKED);\r\nif (flags & HW_CARD_DISABLED)\r\nset_bit(S_RFKILL, &il->status);\r\nelse\r\nclear_bit(S_RFKILL, &il->status);\r\nil_scan_cancel(il);\r\nif ((test_bit(S_RFKILL, &status) !=\r\ntest_bit(S_RFKILL, &il->status)))\r\nwiphy_rfkill_set_hw_state(il->hw->wiphy,\r\ntest_bit(S_RFKILL, &il->status));\r\nelse\r\nwake_up(&il->wait_command_queue);\r\n}\r\nstatic void\r\nil3945_setup_handlers(struct il_priv *il)\r\n{\r\nil->handlers[N_ALIVE] = il3945_hdl_alive;\r\nil->handlers[C_ADD_STA] = il3945_hdl_add_sta;\r\nil->handlers[N_ERROR] = il_hdl_error;\r\nil->handlers[N_CHANNEL_SWITCH] = il_hdl_csa;\r\nil->handlers[N_SPECTRUM_MEASUREMENT] = il_hdl_spectrum_measurement;\r\nil->handlers[N_PM_SLEEP] = il_hdl_pm_sleep;\r\nil->handlers[N_PM_DEBUG_STATS] = il_hdl_pm_debug_stats;\r\nil->handlers[N_BEACON] = il3945_hdl_beacon;\r\nil->handlers[C_STATS] = il3945_hdl_c_stats;\r\nil->handlers[N_STATS] = il3945_hdl_stats;\r\nil_setup_rx_scan_handlers(il);\r\nil->handlers[N_CARD_STATE] = il3945_hdl_card_state;\r\nil3945_hw_handler_setup(il);\r\n}\r\nstatic inline __le32\r\nil3945_dma_addr2rbd_ptr(struct il_priv *il, dma_addr_t dma_addr)\r\n{\r\nreturn cpu_to_le32((u32) dma_addr);\r\n}\r\nstatic void\r\nil3945_rx_queue_restock(struct il_priv *il)\r\n{\r\nstruct il_rx_queue *rxq = &il->rxq;\r\nstruct list_head *element;\r\nstruct il_rx_buf *rxb;\r\nunsigned long flags;\r\nint write;\r\nspin_lock_irqsave(&rxq->lock, flags);\r\nwrite = rxq->write & ~0x7;\r\nwhile (il_rx_queue_space(rxq) > 0 && rxq->free_count) {\r\nelement = rxq->rx_free.next;\r\nrxb = list_entry(element, struct il_rx_buf, list);\r\nlist_del(element);\r\nrxq->bd[rxq->write] =\r\nil3945_dma_addr2rbd_ptr(il, rxb->page_dma);\r\nrxq->queue[rxq->write] = rxb;\r\nrxq->write = (rxq->write + 1) & RX_QUEUE_MASK;\r\nrxq->free_count--;\r\n}\r\nspin_unlock_irqrestore(&rxq->lock, flags);\r\nif (rxq->free_count <= RX_LOW_WATERMARK)\r\nqueue_work(il->workqueue, &il->rx_replenish);\r\nif (rxq->write_actual != (rxq->write & ~0x7) ||\r\nabs(rxq->write - rxq->read) > 7) {\r\nspin_lock_irqsave(&rxq->lock, flags);\r\nrxq->need_update = 1;\r\nspin_unlock_irqrestore(&rxq->lock, flags);\r\nil_rx_queue_update_write_ptr(il, rxq);\r\n}\r\n}\r\nstatic void\r\nil3945_rx_allocate(struct il_priv *il, gfp_t priority)\r\n{\r\nstruct il_rx_queue *rxq = &il->rxq;\r\nstruct list_head *element;\r\nstruct il_rx_buf *rxb;\r\nstruct page *page;\r\ndma_addr_t page_dma;\r\nunsigned long flags;\r\ngfp_t gfp_mask = priority;\r\nwhile (1) {\r\nspin_lock_irqsave(&rxq->lock, flags);\r\nif (list_empty(&rxq->rx_used)) {\r\nspin_unlock_irqrestore(&rxq->lock, flags);\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(&rxq->lock, flags);\r\nif (rxq->free_count > RX_LOW_WATERMARK)\r\ngfp_mask |= __GFP_NOWARN;\r\nif (il->hw_params.rx_page_order > 0)\r\ngfp_mask |= __GFP_COMP;\r\npage = alloc_pages(gfp_mask, il->hw_params.rx_page_order);\r\nif (!page) {\r\nif (net_ratelimit())\r\nD_INFO("Failed to allocate SKB buffer.\n");\r\nif (rxq->free_count <= RX_LOW_WATERMARK &&\r\nnet_ratelimit())\r\nIL_ERR("Failed to allocate SKB buffer with %0x."\r\n"Only %u free buffers remaining.\n",\r\npriority, rxq->free_count);\r\nbreak;\r\n}\r\npage_dma =\r\npci_map_page(il->pci_dev, page, 0,\r\nPAGE_SIZE << il->hw_params.rx_page_order,\r\nPCI_DMA_FROMDEVICE);\r\nif (unlikely(pci_dma_mapping_error(il->pci_dev, page_dma))) {\r\n__free_pages(page, il->hw_params.rx_page_order);\r\nbreak;\r\n}\r\nspin_lock_irqsave(&rxq->lock, flags);\r\nif (list_empty(&rxq->rx_used)) {\r\nspin_unlock_irqrestore(&rxq->lock, flags);\r\npci_unmap_page(il->pci_dev, page_dma,\r\nPAGE_SIZE << il->hw_params.rx_page_order,\r\nPCI_DMA_FROMDEVICE);\r\n__free_pages(page, il->hw_params.rx_page_order);\r\nreturn;\r\n}\r\nelement = rxq->rx_used.next;\r\nrxb = list_entry(element, struct il_rx_buf, list);\r\nlist_del(element);\r\nrxb->page = page;\r\nrxb->page_dma = page_dma;\r\nlist_add_tail(&rxb->list, &rxq->rx_free);\r\nrxq->free_count++;\r\nil->alloc_rxb_page++;\r\nspin_unlock_irqrestore(&rxq->lock, flags);\r\n}\r\n}\r\nvoid\r\nil3945_rx_queue_reset(struct il_priv *il, struct il_rx_queue *rxq)\r\n{\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&rxq->lock, flags);\r\nINIT_LIST_HEAD(&rxq->rx_free);\r\nINIT_LIST_HEAD(&rxq->rx_used);\r\nfor (i = 0; i < RX_FREE_BUFFERS + RX_QUEUE_SIZE; i++) {\r\nif (rxq->pool[i].page != NULL) {\r\npci_unmap_page(il->pci_dev, rxq->pool[i].page_dma,\r\nPAGE_SIZE << il->hw_params.rx_page_order,\r\nPCI_DMA_FROMDEVICE);\r\n__il_free_pages(il, rxq->pool[i].page);\r\nrxq->pool[i].page = NULL;\r\n}\r\nlist_add_tail(&rxq->pool[i].list, &rxq->rx_used);\r\n}\r\nrxq->read = rxq->write = 0;\r\nrxq->write_actual = 0;\r\nrxq->free_count = 0;\r\nspin_unlock_irqrestore(&rxq->lock, flags);\r\n}\r\nvoid\r\nil3945_rx_replenish(void *data)\r\n{\r\nstruct il_priv *il = data;\r\nunsigned long flags;\r\nil3945_rx_allocate(il, GFP_KERNEL);\r\nspin_lock_irqsave(&il->lock, flags);\r\nil3945_rx_queue_restock(il);\r\nspin_unlock_irqrestore(&il->lock, flags);\r\n}\r\nstatic void\r\nil3945_rx_replenish_now(struct il_priv *il)\r\n{\r\nil3945_rx_allocate(il, GFP_ATOMIC);\r\nil3945_rx_queue_restock(il);\r\n}\r\nstatic void\r\nil3945_rx_queue_free(struct il_priv *il, struct il_rx_queue *rxq)\r\n{\r\nint i;\r\nfor (i = 0; i < RX_QUEUE_SIZE + RX_FREE_BUFFERS; i++) {\r\nif (rxq->pool[i].page != NULL) {\r\npci_unmap_page(il->pci_dev, rxq->pool[i].page_dma,\r\nPAGE_SIZE << il->hw_params.rx_page_order,\r\nPCI_DMA_FROMDEVICE);\r\n__il_free_pages(il, rxq->pool[i].page);\r\nrxq->pool[i].page = NULL;\r\n}\r\n}\r\ndma_free_coherent(&il->pci_dev->dev, 4 * RX_QUEUE_SIZE, rxq->bd,\r\nrxq->bd_dma);\r\ndma_free_coherent(&il->pci_dev->dev, sizeof(struct il_rb_status),\r\nrxq->rb_stts, rxq->rb_stts_dma);\r\nrxq->bd = NULL;\r\nrxq->rb_stts = NULL;\r\n}\r\nint\r\nil3945_calc_db_from_ratio(int sig_ratio)\r\n{\r\nif (sig_ratio >= 1000)\r\nreturn 60;\r\nif (sig_ratio >= 100)\r\nreturn 20 + (int)ratio2dB[sig_ratio / 10];\r\nif (sig_ratio < 1)\r\nreturn 0;\r\nreturn (int)ratio2dB[sig_ratio];\r\n}\r\nstatic void\r\nil3945_rx_handle(struct il_priv *il)\r\n{\r\nstruct il_rx_buf *rxb;\r\nstruct il_rx_pkt *pkt;\r\nstruct il_rx_queue *rxq = &il->rxq;\r\nu32 r, i;\r\nint reclaim;\r\nunsigned long flags;\r\nu8 fill_rx = 0;\r\nu32 count = 8;\r\nint total_empty = 0;\r\nr = le16_to_cpu(rxq->rb_stts->closed_rb_num) & 0x0FFF;\r\ni = rxq->read;\r\ntotal_empty = r - rxq->write_actual;\r\nif (total_empty < 0)\r\ntotal_empty += RX_QUEUE_SIZE;\r\nif (total_empty > (RX_QUEUE_SIZE / 2))\r\nfill_rx = 1;\r\nif (i == r)\r\nD_RX("r = %d, i = %d\n", r, i);\r\nwhile (i != r) {\r\nint len;\r\nrxb = rxq->queue[i];\r\nBUG_ON(rxb == NULL);\r\nrxq->queue[i] = NULL;\r\npci_unmap_page(il->pci_dev, rxb->page_dma,\r\nPAGE_SIZE << il->hw_params.rx_page_order,\r\nPCI_DMA_FROMDEVICE);\r\npkt = rxb_addr(rxb);\r\nlen = le32_to_cpu(pkt->len_n_flags) & IL_RX_FRAME_SIZE_MSK;\r\nlen += sizeof(u32);\r\nreclaim = il_need_reclaim(il, pkt);\r\nif (il->handlers[pkt->hdr.cmd]) {\r\nD_RX("r = %d, i = %d, %s, 0x%02x\n", r, i,\r\nil_get_cmd_string(pkt->hdr.cmd), pkt->hdr.cmd);\r\nil->isr_stats.handlers[pkt->hdr.cmd]++;\r\nil->handlers[pkt->hdr.cmd] (il, rxb);\r\n} else {\r\nD_RX("r %d i %d No handler needed for %s, 0x%02x\n", r,\r\ni, il_get_cmd_string(pkt->hdr.cmd), pkt->hdr.cmd);\r\n}\r\nif (reclaim) {\r\nif (rxb->page)\r\nil_tx_cmd_complete(il, rxb);\r\nelse\r\nIL_WARN("Claim null rxb?\n");\r\n}\r\nspin_lock_irqsave(&rxq->lock, flags);\r\nif (rxb->page != NULL) {\r\nrxb->page_dma =\r\npci_map_page(il->pci_dev, rxb->page, 0,\r\nPAGE_SIZE << il->hw_params.\r\nrx_page_order, PCI_DMA_FROMDEVICE);\r\nif (unlikely(pci_dma_mapping_error(il->pci_dev,\r\nrxb->page_dma))) {\r\n__il_free_pages(il, rxb->page);\r\nrxb->page = NULL;\r\nlist_add_tail(&rxb->list, &rxq->rx_used);\r\n} else {\r\nlist_add_tail(&rxb->list, &rxq->rx_free);\r\nrxq->free_count++;\r\n}\r\n} else\r\nlist_add_tail(&rxb->list, &rxq->rx_used);\r\nspin_unlock_irqrestore(&rxq->lock, flags);\r\ni = (i + 1) & RX_QUEUE_MASK;\r\nif (fill_rx) {\r\ncount++;\r\nif (count >= 8) {\r\nrxq->read = i;\r\nil3945_rx_replenish_now(il);\r\ncount = 0;\r\n}\r\n}\r\n}\r\nrxq->read = i;\r\nif (fill_rx)\r\nil3945_rx_replenish_now(il);\r\nelse\r\nil3945_rx_queue_restock(il);\r\n}\r\nstatic inline void\r\nil3945_synchronize_irq(struct il_priv *il)\r\n{\r\nsynchronize_irq(il->pci_dev->irq);\r\ntasklet_kill(&il->irq_tasklet);\r\n}\r\nstatic const char *\r\nil3945_desc_lookup(int i)\r\n{\r\nswitch (i) {\r\ncase 1:\r\nreturn "FAIL";\r\ncase 2:\r\nreturn "BAD_PARAM";\r\ncase 3:\r\nreturn "BAD_CHECKSUM";\r\ncase 4:\r\nreturn "NMI_INTERRUPT";\r\ncase 5:\r\nreturn "SYSASSERT";\r\ncase 6:\r\nreturn "FATAL_ERROR";\r\n}\r\nreturn "UNKNOWN";\r\n}\r\nvoid\r\nil3945_dump_nic_error_log(struct il_priv *il)\r\n{\r\nu32 i;\r\nu32 desc, time, count, base, data1;\r\nu32 blink1, blink2, ilink1, ilink2;\r\nbase = le32_to_cpu(il->card_alive.error_event_table_ptr);\r\nif (!il3945_hw_valid_rtc_data_addr(base)) {\r\nIL_ERR("Not valid error log pointer 0x%08X\n", base);\r\nreturn;\r\n}\r\ncount = il_read_targ_mem(il, base);\r\nif (ERROR_START_OFFSET <= count * ERROR_ELEM_SIZE) {\r\nIL_ERR("Start IWL Error Log Dump:\n");\r\nIL_ERR("Status: 0x%08lX, count: %d\n", il->status, count);\r\n}\r\nIL_ERR("Desc Time asrtPC blink2 "\r\n"ilink1 nmiPC Line\n");\r\nfor (i = ERROR_START_OFFSET;\r\ni < (count * ERROR_ELEM_SIZE) + ERROR_START_OFFSET;\r\ni += ERROR_ELEM_SIZE) {\r\ndesc = il_read_targ_mem(il, base + i);\r\ntime = il_read_targ_mem(il, base + i + 1 * sizeof(u32));\r\nblink1 = il_read_targ_mem(il, base + i + 2 * sizeof(u32));\r\nblink2 = il_read_targ_mem(il, base + i + 3 * sizeof(u32));\r\nilink1 = il_read_targ_mem(il, base + i + 4 * sizeof(u32));\r\nilink2 = il_read_targ_mem(il, base + i + 5 * sizeof(u32));\r\ndata1 = il_read_targ_mem(il, base + i + 6 * sizeof(u32));\r\nIL_ERR("%-13s (0x%X) %010u 0x%05X 0x%05X 0x%05X 0x%05X %u\n\n",\r\nil3945_desc_lookup(desc), desc, time, blink1, blink2,\r\nilink1, ilink2, data1);\r\n}\r\n}\r\nstatic void\r\nil3945_irq_tasklet(struct il_priv *il)\r\n{\r\nu32 inta, handled = 0;\r\nu32 inta_fh;\r\nunsigned long flags;\r\n#ifdef CONFIG_IWLEGACY_DEBUG\r\nu32 inta_mask;\r\n#endif\r\nspin_lock_irqsave(&il->lock, flags);\r\ninta = _il_rd(il, CSR_INT);\r\n_il_wr(il, CSR_INT, inta);\r\ninta_fh = _il_rd(il, CSR_FH_INT_STATUS);\r\n_il_wr(il, CSR_FH_INT_STATUS, inta_fh);\r\n#ifdef CONFIG_IWLEGACY_DEBUG\r\nif (il_get_debug_level(il) & IL_DL_ISR) {\r\ninta_mask = _il_rd(il, CSR_INT_MASK);\r\nD_ISR("inta 0x%08x, enabled 0x%08x, fh 0x%08x\n", inta,\r\ninta_mask, inta_fh);\r\n}\r\n#endif\r\nspin_unlock_irqrestore(&il->lock, flags);\r\nif (inta_fh & CSR39_FH_INT_RX_MASK)\r\ninta |= CSR_INT_BIT_FH_RX;\r\nif (inta_fh & CSR39_FH_INT_TX_MASK)\r\ninta |= CSR_INT_BIT_FH_TX;\r\nif (inta & CSR_INT_BIT_HW_ERR) {\r\nIL_ERR("Hardware error detected. Restarting.\n");\r\nil_disable_interrupts(il);\r\nil->isr_stats.hw++;\r\nil_irq_handle_error(il);\r\nhandled |= CSR_INT_BIT_HW_ERR;\r\nreturn;\r\n}\r\n#ifdef CONFIG_IWLEGACY_DEBUG\r\nif (il_get_debug_level(il) & (IL_DL_ISR)) {\r\nif (inta & CSR_INT_BIT_SCD) {\r\nD_ISR("Scheduler finished to transmit "\r\n"the frame/frames.\n");\r\nil->isr_stats.sch++;\r\n}\r\nif (inta & CSR_INT_BIT_ALIVE) {\r\nD_ISR("Alive interrupt\n");\r\nil->isr_stats.alive++;\r\n}\r\n}\r\n#endif\r\ninta &= ~(CSR_INT_BIT_SCD | CSR_INT_BIT_ALIVE);\r\nif (inta & CSR_INT_BIT_SW_ERR) {\r\nIL_ERR("Microcode SW error detected. " "Restarting 0x%X.\n",\r\ninta);\r\nil->isr_stats.sw++;\r\nil_irq_handle_error(il);\r\nhandled |= CSR_INT_BIT_SW_ERR;\r\n}\r\nif (inta & CSR_INT_BIT_WAKEUP) {\r\nD_ISR("Wakeup interrupt\n");\r\nil_rx_queue_update_write_ptr(il, &il->rxq);\r\nspin_lock_irqsave(&il->lock, flags);\r\nil_txq_update_write_ptr(il, &il->txq[0]);\r\nil_txq_update_write_ptr(il, &il->txq[1]);\r\nil_txq_update_write_ptr(il, &il->txq[2]);\r\nil_txq_update_write_ptr(il, &il->txq[3]);\r\nil_txq_update_write_ptr(il, &il->txq[4]);\r\nspin_unlock_irqrestore(&il->lock, flags);\r\nil->isr_stats.wakeup++;\r\nhandled |= CSR_INT_BIT_WAKEUP;\r\n}\r\nif (inta & (CSR_INT_BIT_FH_RX | CSR_INT_BIT_SW_RX)) {\r\nil3945_rx_handle(il);\r\nil->isr_stats.rx++;\r\nhandled |= (CSR_INT_BIT_FH_RX | CSR_INT_BIT_SW_RX);\r\n}\r\nif (inta & CSR_INT_BIT_FH_TX) {\r\nD_ISR("Tx interrupt\n");\r\nil->isr_stats.tx++;\r\n_il_wr(il, CSR_FH_INT_STATUS, (1 << 6));\r\nil_wr(il, FH39_TCSR_CREDIT(FH39_SRVC_CHNL), 0x0);\r\nhandled |= CSR_INT_BIT_FH_TX;\r\n}\r\nif (inta & ~handled) {\r\nIL_ERR("Unhandled INTA bits 0x%08x\n", inta & ~handled);\r\nil->isr_stats.unhandled++;\r\n}\r\nif (inta & ~il->inta_mask) {\r\nIL_WARN("Disabled INTA bits 0x%08x were pending\n",\r\ninta & ~il->inta_mask);\r\nIL_WARN(" with inta_fh = 0x%08x\n", inta_fh);\r\n}\r\nif (test_bit(S_INT_ENABLED, &il->status))\r\nil_enable_interrupts(il);\r\n#ifdef CONFIG_IWLEGACY_DEBUG\r\nif (il_get_debug_level(il) & (IL_DL_ISR)) {\r\ninta = _il_rd(il, CSR_INT);\r\ninta_mask = _il_rd(il, CSR_INT_MASK);\r\ninta_fh = _il_rd(il, CSR_FH_INT_STATUS);\r\nD_ISR("End inta 0x%08x, enabled 0x%08x, fh 0x%08x, "\r\n"flags 0x%08lx\n", inta, inta_mask, inta_fh, flags);\r\n}\r\n#endif\r\n}\r\nstatic int\r\nil3945_get_channels_for_scan(struct il_priv *il, enum ieee80211_band band,\r\nu8 is_active, u8 n_probes,\r\nstruct il3945_scan_channel *scan_ch,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct ieee80211_channel *chan;\r\nconst struct ieee80211_supported_band *sband;\r\nconst struct il_channel_info *ch_info;\r\nu16 passive_dwell = 0;\r\nu16 active_dwell = 0;\r\nint added, i;\r\nsband = il_get_hw_mode(il, band);\r\nif (!sband)\r\nreturn 0;\r\nactive_dwell = il_get_active_dwell_time(il, band, n_probes);\r\npassive_dwell = il_get_passive_dwell_time(il, band, vif);\r\nif (passive_dwell <= active_dwell)\r\npassive_dwell = active_dwell + 1;\r\nfor (i = 0, added = 0; i < il->scan_request->n_channels; i++) {\r\nchan = il->scan_request->channels[i];\r\nif (chan->band != band)\r\ncontinue;\r\nscan_ch->channel = chan->hw_value;\r\nch_info = il_get_channel_info(il, band, scan_ch->channel);\r\nif (!il_is_channel_valid(ch_info)) {\r\nD_SCAN("Channel %d is INVALID for this band.\n",\r\nscan_ch->channel);\r\ncontinue;\r\n}\r\nscan_ch->active_dwell = cpu_to_le16(active_dwell);\r\nscan_ch->passive_dwell = cpu_to_le16(passive_dwell);\r\nif (!is_active || il_is_channel_passive(ch_info) ||\r\n(chan->flags & IEEE80211_CHAN_NO_IR)) {\r\nscan_ch->type = 0;\r\nif (IL_UCODE_API(il->ucode_ver) == 1)\r\nscan_ch->active_dwell =\r\ncpu_to_le16(passive_dwell - 1);\r\n} else {\r\nscan_ch->type = 1;\r\n}\r\nif (IL_UCODE_API(il->ucode_ver) >= 2) {\r\nif (n_probes)\r\nscan_ch->type |= IL39_SCAN_PROBE_MASK(n_probes);\r\n} else {\r\nif ((scan_ch->type & 1) && n_probes)\r\nscan_ch->type |= IL39_SCAN_PROBE_MASK(n_probes);\r\n}\r\nscan_ch->tpc.dsp_atten = 110;\r\nif (band == IEEE80211_BAND_5GHZ)\r\nscan_ch->tpc.tx_gain = ((1 << 5) | (3 << 3)) | 3;\r\nelse {\r\nscan_ch->tpc.tx_gain = ((1 << 5) | (5 << 3));\r\n}\r\nD_SCAN("Scanning %d [%s %d]\n", scan_ch->channel,\r\n(scan_ch->type & 1) ? "ACTIVE" : "PASSIVE",\r\n(scan_ch->type & 1) ? active_dwell : passive_dwell);\r\nscan_ch++;\r\nadded++;\r\n}\r\nD_SCAN("total channels to scan %d\n", added);\r\nreturn added;\r\n}\r\nstatic void\r\nil3945_init_hw_rates(struct il_priv *il, struct ieee80211_rate *rates)\r\n{\r\nint i;\r\nfor (i = 0; i < RATE_COUNT_LEGACY; i++) {\r\nrates[i].bitrate = il3945_rates[i].ieee * 5;\r\nrates[i].hw_value = i;\r\nrates[i].hw_value_short = i;\r\nrates[i].flags = 0;\r\nif (i > IL39_LAST_OFDM_RATE || i < IL_FIRST_OFDM_RATE) {\r\nrates[i].flags |=\r\n(il3945_rates[i].plcp ==\r\n10) ? 0 : IEEE80211_RATE_SHORT_PREAMBLE;\r\n}\r\n}\r\n}\r\nstatic void\r\nil3945_dealloc_ucode_pci(struct il_priv *il)\r\n{\r\nil_free_fw_desc(il->pci_dev, &il->ucode_code);\r\nil_free_fw_desc(il->pci_dev, &il->ucode_data);\r\nil_free_fw_desc(il->pci_dev, &il->ucode_data_backup);\r\nil_free_fw_desc(il->pci_dev, &il->ucode_init);\r\nil_free_fw_desc(il->pci_dev, &il->ucode_init_data);\r\nil_free_fw_desc(il->pci_dev, &il->ucode_boot);\r\n}\r\nstatic int\r\nil3945_verify_inst_full(struct il_priv *il, __le32 * image, u32 len)\r\n{\r\nu32 val;\r\nu32 save_len = len;\r\nint rc = 0;\r\nu32 errcnt;\r\nD_INFO("ucode inst image size is %u\n", len);\r\nil_wr(il, HBUS_TARG_MEM_RADDR, IL39_RTC_INST_LOWER_BOUND);\r\nerrcnt = 0;\r\nfor (; len > 0; len -= sizeof(u32), image++) {\r\nval = _il_rd(il, HBUS_TARG_MEM_RDAT);\r\nif (val != le32_to_cpu(*image)) {\r\nIL_ERR("uCode INST section is invalid at "\r\n"offset 0x%x, is 0x%x, s/b 0x%x\n",\r\nsave_len - len, val, le32_to_cpu(*image));\r\nrc = -EIO;\r\nerrcnt++;\r\nif (errcnt >= 20)\r\nbreak;\r\n}\r\n}\r\nif (!errcnt)\r\nD_INFO("ucode image in INSTRUCTION memory is good\n");\r\nreturn rc;\r\n}\r\nstatic int\r\nil3945_verify_inst_sparse(struct il_priv *il, __le32 * image, u32 len)\r\n{\r\nu32 val;\r\nint rc = 0;\r\nu32 errcnt = 0;\r\nu32 i;\r\nD_INFO("ucode inst image size is %u\n", len);\r\nfor (i = 0; i < len; i += 100, image += 100 / sizeof(u32)) {\r\nil_wr(il, HBUS_TARG_MEM_RADDR, i + IL39_RTC_INST_LOWER_BOUND);\r\nval = _il_rd(il, HBUS_TARG_MEM_RDAT);\r\nif (val != le32_to_cpu(*image)) {\r\n#if 0\r\nIL_ERR("uCode INST section is invalid at "\r\n"offset 0x%x, is 0x%x, s/b 0x%x\n", i, val,\r\n*image);\r\n#endif\r\nrc = -EIO;\r\nerrcnt++;\r\nif (errcnt >= 3)\r\nbreak;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int\r\nil3945_verify_ucode(struct il_priv *il)\r\n{\r\n__le32 *image;\r\nu32 len;\r\nint rc = 0;\r\nimage = (__le32 *) il->ucode_boot.v_addr;\r\nlen = il->ucode_boot.len;\r\nrc = il3945_verify_inst_sparse(il, image, len);\r\nif (rc == 0) {\r\nD_INFO("Bootstrap uCode is good in inst SRAM\n");\r\nreturn 0;\r\n}\r\nimage = (__le32 *) il->ucode_init.v_addr;\r\nlen = il->ucode_init.len;\r\nrc = il3945_verify_inst_sparse(il, image, len);\r\nif (rc == 0) {\r\nD_INFO("Initialize uCode is good in inst SRAM\n");\r\nreturn 0;\r\n}\r\nimage = (__le32 *) il->ucode_code.v_addr;\r\nlen = il->ucode_code.len;\r\nrc = il3945_verify_inst_sparse(il, image, len);\r\nif (rc == 0) {\r\nD_INFO("Runtime uCode is good in inst SRAM\n");\r\nreturn 0;\r\n}\r\nIL_ERR("NO VALID UCODE IMAGE IN INSTRUCTION SRAM!!\n");\r\nimage = (__le32 *) il->ucode_boot.v_addr;\r\nlen = il->ucode_boot.len;\r\nrc = il3945_verify_inst_full(il, image, len);\r\nreturn rc;\r\n}\r\nstatic void\r\nil3945_nic_start(struct il_priv *il)\r\n{\r\n_il_wr(il, CSR_RESET, 0);\r\n}\r\nstatic u32\r\nil3945_ucode_get_header_size(u32 api_ver)\r\n{\r\nreturn 24;\r\n}\r\nstatic u8 *\r\nil3945_ucode_get_data(const struct il_ucode_header *ucode)\r\n{\r\nreturn (u8 *) ucode->v1.data;\r\n}\r\nstatic int\r\nil3945_read_ucode(struct il_priv *il)\r\n{\r\nconst struct il_ucode_header *ucode;\r\nint ret = -EINVAL, idx;\r\nconst struct firmware *ucode_raw;\r\nconst char *name_pre = il->cfg->fw_name_pre;\r\nconst unsigned int api_max = il->cfg->ucode_api_max;\r\nconst unsigned int api_min = il->cfg->ucode_api_min;\r\nchar buf[25];\r\nu8 *src;\r\nsize_t len;\r\nu32 api_ver, inst_size, data_size, init_size, init_data_size, boot_size;\r\nfor (idx = api_max; idx >= api_min; idx--) {\r\nsprintf(buf, "%s%u%s", name_pre, idx, ".ucode");\r\nret = request_firmware(&ucode_raw, buf, &il->pci_dev->dev);\r\nif (ret < 0) {\r\nIL_ERR("%s firmware file req failed: %d\n", buf, ret);\r\nif (ret == -ENOENT)\r\ncontinue;\r\nelse\r\ngoto error;\r\n} else {\r\nif (idx < api_max)\r\nIL_ERR("Loaded firmware %s, "\r\n"which is deprecated. "\r\n" Please use API v%u instead.\n", buf,\r\napi_max);\r\nD_INFO("Got firmware '%s' file "\r\n"(%zd bytes) from disk\n", buf, ucode_raw->size);\r\nbreak;\r\n}\r\n}\r\nif (ret < 0)\r\ngoto error;\r\nif (ucode_raw->size < il3945_ucode_get_header_size(1)) {\r\nIL_ERR("File size way too small!\n");\r\nret = -EINVAL;\r\ngoto err_release;\r\n}\r\nucode = (struct il_ucode_header *)ucode_raw->data;\r\nil->ucode_ver = le32_to_cpu(ucode->ver);\r\napi_ver = IL_UCODE_API(il->ucode_ver);\r\ninst_size = il3945_ucode_get_inst_size(ucode);\r\ndata_size = il3945_ucode_get_data_size(ucode);\r\ninit_size = il3945_ucode_get_init_size(ucode);\r\ninit_data_size = il3945_ucode_get_init_data_size(ucode);\r\nboot_size = il3945_ucode_get_boot_size(ucode);\r\nsrc = il3945_ucode_get_data(ucode);\r\nif (api_ver < api_min || api_ver > api_max) {\r\nIL_ERR("Driver unable to support your firmware API. "\r\n"Driver supports v%u, firmware is v%u.\n", api_max,\r\napi_ver);\r\nil->ucode_ver = 0;\r\nret = -EINVAL;\r\ngoto err_release;\r\n}\r\nif (api_ver != api_max)\r\nIL_ERR("Firmware has old API version. Expected %u, "\r\n"got %u. New firmware can be obtained "\r\n"from http://www.intellinuxwireless.org.\n", api_max,\r\napi_ver);\r\nIL_INFO("loaded firmware version %u.%u.%u.%u\n",\r\nIL_UCODE_MAJOR(il->ucode_ver), IL_UCODE_MINOR(il->ucode_ver),\r\nIL_UCODE_API(il->ucode_ver), IL_UCODE_SERIAL(il->ucode_ver));\r\nsnprintf(il->hw->wiphy->fw_version, sizeof(il->hw->wiphy->fw_version),\r\n"%u.%u.%u.%u", IL_UCODE_MAJOR(il->ucode_ver),\r\nIL_UCODE_MINOR(il->ucode_ver), IL_UCODE_API(il->ucode_ver),\r\nIL_UCODE_SERIAL(il->ucode_ver));\r\nD_INFO("f/w package hdr ucode version raw = 0x%x\n", il->ucode_ver);\r\nD_INFO("f/w package hdr runtime inst size = %u\n", inst_size);\r\nD_INFO("f/w package hdr runtime data size = %u\n", data_size);\r\nD_INFO("f/w package hdr init inst size = %u\n", init_size);\r\nD_INFO("f/w package hdr init data size = %u\n", init_data_size);\r\nD_INFO("f/w package hdr boot inst size = %u\n", boot_size);\r\nif (ucode_raw->size !=\r\nil3945_ucode_get_header_size(api_ver) + inst_size + data_size +\r\ninit_size + init_data_size + boot_size) {\r\nD_INFO("uCode file size %zd does not match expected size\n",\r\nucode_raw->size);\r\nret = -EINVAL;\r\ngoto err_release;\r\n}\r\nif (inst_size > IL39_MAX_INST_SIZE) {\r\nD_INFO("uCode instr len %d too large to fit in\n", inst_size);\r\nret = -EINVAL;\r\ngoto err_release;\r\n}\r\nif (data_size > IL39_MAX_DATA_SIZE) {\r\nD_INFO("uCode data len %d too large to fit in\n", data_size);\r\nret = -EINVAL;\r\ngoto err_release;\r\n}\r\nif (init_size > IL39_MAX_INST_SIZE) {\r\nD_INFO("uCode init instr len %d too large to fit in\n",\r\ninit_size);\r\nret = -EINVAL;\r\ngoto err_release;\r\n}\r\nif (init_data_size > IL39_MAX_DATA_SIZE) {\r\nD_INFO("uCode init data len %d too large to fit in\n",\r\ninit_data_size);\r\nret = -EINVAL;\r\ngoto err_release;\r\n}\r\nif (boot_size > IL39_MAX_BSM_SIZE) {\r\nD_INFO("uCode boot instr len %d too large to fit in\n",\r\nboot_size);\r\nret = -EINVAL;\r\ngoto err_release;\r\n}\r\nil->ucode_code.len = inst_size;\r\nil_alloc_fw_desc(il->pci_dev, &il->ucode_code);\r\nil->ucode_data.len = data_size;\r\nil_alloc_fw_desc(il->pci_dev, &il->ucode_data);\r\nil->ucode_data_backup.len = data_size;\r\nil_alloc_fw_desc(il->pci_dev, &il->ucode_data_backup);\r\nif (!il->ucode_code.v_addr || !il->ucode_data.v_addr ||\r\n!il->ucode_data_backup.v_addr)\r\ngoto err_pci_alloc;\r\nif (init_size && init_data_size) {\r\nil->ucode_init.len = init_size;\r\nil_alloc_fw_desc(il->pci_dev, &il->ucode_init);\r\nil->ucode_init_data.len = init_data_size;\r\nil_alloc_fw_desc(il->pci_dev, &il->ucode_init_data);\r\nif (!il->ucode_init.v_addr || !il->ucode_init_data.v_addr)\r\ngoto err_pci_alloc;\r\n}\r\nif (boot_size) {\r\nil->ucode_boot.len = boot_size;\r\nil_alloc_fw_desc(il->pci_dev, &il->ucode_boot);\r\nif (!il->ucode_boot.v_addr)\r\ngoto err_pci_alloc;\r\n}\r\nlen = inst_size;\r\nD_INFO("Copying (but not loading) uCode instr len %zd\n", len);\r\nmemcpy(il->ucode_code.v_addr, src, len);\r\nsrc += len;\r\nD_INFO("uCode instr buf vaddr = 0x%p, paddr = 0x%08x\n",\r\nil->ucode_code.v_addr, (u32) il->ucode_code.p_addr);\r\nlen = data_size;\r\nD_INFO("Copying (but not loading) uCode data len %zd\n", len);\r\nmemcpy(il->ucode_data.v_addr, src, len);\r\nmemcpy(il->ucode_data_backup.v_addr, src, len);\r\nsrc += len;\r\nif (init_size) {\r\nlen = init_size;\r\nD_INFO("Copying (but not loading) init instr len %zd\n", len);\r\nmemcpy(il->ucode_init.v_addr, src, len);\r\nsrc += len;\r\n}\r\nif (init_data_size) {\r\nlen = init_data_size;\r\nD_INFO("Copying (but not loading) init data len %zd\n", len);\r\nmemcpy(il->ucode_init_data.v_addr, src, len);\r\nsrc += len;\r\n}\r\nlen = boot_size;\r\nD_INFO("Copying (but not loading) boot instr len %zd\n", len);\r\nmemcpy(il->ucode_boot.v_addr, src, len);\r\nrelease_firmware(ucode_raw);\r\nreturn 0;\r\nerr_pci_alloc:\r\nIL_ERR("failed to allocate pci memory\n");\r\nret = -ENOMEM;\r\nil3945_dealloc_ucode_pci(il);\r\nerr_release:\r\nrelease_firmware(ucode_raw);\r\nerror:\r\nreturn ret;\r\n}\r\nstatic int\r\nil3945_set_ucode_ptrs(struct il_priv *il)\r\n{\r\ndma_addr_t pinst;\r\ndma_addr_t pdata;\r\npinst = il->ucode_code.p_addr;\r\npdata = il->ucode_data_backup.p_addr;\r\nil_wr_prph(il, BSM_DRAM_INST_PTR_REG, pinst);\r\nil_wr_prph(il, BSM_DRAM_DATA_PTR_REG, pdata);\r\nil_wr_prph(il, BSM_DRAM_DATA_BYTECOUNT_REG, il->ucode_data.len);\r\nil_wr_prph(il, BSM_DRAM_INST_BYTECOUNT_REG,\r\nil->ucode_code.len | BSM_DRAM_INST_LOAD);\r\nD_INFO("Runtime uCode pointers are set.\n");\r\nreturn 0;\r\n}\r\nstatic void\r\nil3945_init_alive_start(struct il_priv *il)\r\n{\r\nif (il->card_alive_init.is_valid != UCODE_VALID_OK) {\r\nD_INFO("Initialize Alive failed.\n");\r\ngoto restart;\r\n}\r\nif (il3945_verify_ucode(il)) {\r\nD_INFO("Bad \"initialize\" uCode load.\n");\r\ngoto restart;\r\n}\r\nD_INFO("Initialization Alive received.\n");\r\nif (il3945_set_ucode_ptrs(il)) {\r\nD_INFO("Couldn't set up uCode pointers.\n");\r\ngoto restart;\r\n}\r\nreturn;\r\nrestart:\r\nqueue_work(il->workqueue, &il->restart);\r\n}\r\nstatic void\r\nil3945_alive_start(struct il_priv *il)\r\n{\r\nint thermal_spin = 0;\r\nu32 rfkill;\r\nD_INFO("Runtime Alive received.\n");\r\nif (il->card_alive.is_valid != UCODE_VALID_OK) {\r\nD_INFO("Alive failed.\n");\r\ngoto restart;\r\n}\r\nif (il3945_verify_ucode(il)) {\r\nD_INFO("Bad runtime uCode load.\n");\r\ngoto restart;\r\n}\r\nrfkill = il_rd_prph(il, APMG_RFKILL_REG);\r\nD_INFO("RFKILL status: 0x%x\n", rfkill);\r\nif (rfkill & 0x1) {\r\nclear_bit(S_RFKILL, &il->status);\r\nwhile (il3945_hw_get_temperature(il) == 0) {\r\nthermal_spin++;\r\nudelay(10);\r\n}\r\nif (thermal_spin)\r\nD_INFO("Thermal calibration took %dus\n",\r\nthermal_spin * 10);\r\n} else\r\nset_bit(S_RFKILL, &il->status);\r\nset_bit(S_ALIVE, &il->status);\r\nil_setup_watchdog(il);\r\nif (il_is_rfkill(il))\r\nreturn;\r\nieee80211_wake_queues(il->hw);\r\nil->active_rate = RATES_MASK_3945;\r\nil_power_update_mode(il, true);\r\nif (il_is_associated(il)) {\r\nstruct il3945_rxon_cmd *active_rxon =\r\n(struct il3945_rxon_cmd *)(&il->active);\r\nil->staging.filter_flags |= RXON_FILTER_ASSOC_MSK;\r\nactive_rxon->filter_flags &= ~RXON_FILTER_ASSOC_MSK;\r\n} else {\r\nil_connection_init_rx_config(il);\r\n}\r\nil_send_bt_config(il);\r\nset_bit(S_READY, &il->status);\r\nil3945_commit_rxon(il);\r\nil3945_reg_txpower_periodic(il);\r\nD_INFO("ALIVE processing complete.\n");\r\nwake_up(&il->wait_command_queue);\r\nreturn;\r\nrestart:\r\nqueue_work(il->workqueue, &il->restart);\r\n}\r\nstatic void\r\n__il3945_down(struct il_priv *il)\r\n{\r\nunsigned long flags;\r\nint exit_pending;\r\nD_INFO(DRV_NAME " is going down\n");\r\nil_scan_cancel_timeout(il, 200);\r\nexit_pending = test_and_set_bit(S_EXIT_PENDING, &il->status);\r\ndel_timer_sync(&il->watchdog);\r\nil_clear_ucode_stations(il);\r\nil_dealloc_bcast_stations(il);\r\nil_clear_driver_stations(il);\r\nwake_up_all(&il->wait_command_queue);\r\nif (!exit_pending)\r\nclear_bit(S_EXIT_PENDING, &il->status);\r\n_il_wr(il, CSR_RESET, CSR_RESET_REG_FLAG_NEVO_RESET);\r\nspin_lock_irqsave(&il->lock, flags);\r\nil_disable_interrupts(il);\r\nspin_unlock_irqrestore(&il->lock, flags);\r\nil3945_synchronize_irq(il);\r\nif (il->mac80211_registered)\r\nieee80211_stop_queues(il->hw);\r\nif (!il_is_init(il)) {\r\nil->status =\r\ntest_bit(S_RFKILL, &il->status) << S_RFKILL |\r\ntest_bit(S_GEO_CONFIGURED, &il->status) << S_GEO_CONFIGURED |\r\ntest_bit(S_EXIT_PENDING, &il->status) << S_EXIT_PENDING;\r\ngoto exit;\r\n}\r\nil->status &=\r\ntest_bit(S_RFKILL, &il->status) << S_RFKILL |\r\ntest_bit(S_GEO_CONFIGURED, &il->status) << S_GEO_CONFIGURED |\r\ntest_bit(S_FW_ERROR, &il->status) << S_FW_ERROR |\r\ntest_bit(S_EXIT_PENDING, &il->status) << S_EXIT_PENDING;\r\nspin_lock_irq(&il->reg_lock);\r\nil3945_hw_txq_ctx_stop(il);\r\nil3945_hw_rxq_stop(il);\r\n_il_wr_prph(il, APMG_CLK_DIS_REG, APMG_CLK_VAL_DMA_CLK_RQT);\r\nudelay(5);\r\n_il_apm_stop(il);\r\nspin_unlock_irq(&il->reg_lock);\r\nil3945_hw_txq_ctx_free(il);\r\nexit:\r\nmemset(&il->card_alive, 0, sizeof(struct il_alive_resp));\r\nif (il->beacon_skb)\r\ndev_kfree_skb(il->beacon_skb);\r\nil->beacon_skb = NULL;\r\nil3945_clear_free_frames(il);\r\n}\r\nstatic void\r\nil3945_down(struct il_priv *il)\r\n{\r\nmutex_lock(&il->mutex);\r\n__il3945_down(il);\r\nmutex_unlock(&il->mutex);\r\nil3945_cancel_deferred_work(il);\r\n}\r\nstatic int\r\nil3945_alloc_bcast_station(struct il_priv *il)\r\n{\r\nunsigned long flags;\r\nu8 sta_id;\r\nspin_lock_irqsave(&il->sta_lock, flags);\r\nsta_id = il_prep_station(il, il_bcast_addr, false, NULL);\r\nif (sta_id == IL_INVALID_STATION) {\r\nIL_ERR("Unable to prepare broadcast station\n");\r\nspin_unlock_irqrestore(&il->sta_lock, flags);\r\nreturn -EINVAL;\r\n}\r\nil->stations[sta_id].used |= IL_STA_DRIVER_ACTIVE;\r\nil->stations[sta_id].used |= IL_STA_BCAST;\r\nspin_unlock_irqrestore(&il->sta_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int\r\n__il3945_up(struct il_priv *il)\r\n{\r\nint rc, i;\r\nrc = il3945_alloc_bcast_station(il);\r\nif (rc)\r\nreturn rc;\r\nif (test_bit(S_EXIT_PENDING, &il->status)) {\r\nIL_WARN("Exit pending; will not bring the NIC up\n");\r\nreturn -EIO;\r\n}\r\nif (!il->ucode_data_backup.v_addr || !il->ucode_data.v_addr) {\r\nIL_ERR("ucode not available for device bring up\n");\r\nreturn -EIO;\r\n}\r\nif (_il_rd(il, CSR_GP_CNTRL) & CSR_GP_CNTRL_REG_FLAG_HW_RF_KILL_SW)\r\nclear_bit(S_RFKILL, &il->status);\r\nelse {\r\nset_bit(S_RFKILL, &il->status);\r\nreturn -ERFKILL;\r\n}\r\n_il_wr(il, CSR_INT, 0xFFFFFFFF);\r\nrc = il3945_hw_nic_init(il);\r\nif (rc) {\r\nIL_ERR("Unable to int nic\n");\r\nreturn rc;\r\n}\r\n_il_wr(il, CSR_UCODE_DRV_GP1_CLR, CSR_UCODE_SW_BIT_RFKILL);\r\n_il_wr(il, CSR_UCODE_DRV_GP1_CLR, CSR_UCODE_DRV_GP1_BIT_CMD_BLOCKED);\r\n_il_wr(il, CSR_INT, 0xFFFFFFFF);\r\nil_enable_interrupts(il);\r\n_il_wr(il, CSR_UCODE_DRV_GP1_CLR, CSR_UCODE_SW_BIT_RFKILL);\r\n_il_wr(il, CSR_UCODE_DRV_GP1_CLR, CSR_UCODE_SW_BIT_RFKILL);\r\nmemcpy(il->ucode_data_backup.v_addr, il->ucode_data.v_addr,\r\nil->ucode_data.len);\r\nif (test_bit(S_RFKILL, &il->status))\r\nreturn 0;\r\nfor (i = 0; i < MAX_HW_RESTARTS; i++) {\r\nrc = il->ops->load_ucode(il);\r\nif (rc) {\r\nIL_ERR("Unable to set up bootstrap uCode: %d\n", rc);\r\ncontinue;\r\n}\r\nil3945_nic_start(il);\r\nD_INFO(DRV_NAME " is coming up\n");\r\nreturn 0;\r\n}\r\nset_bit(S_EXIT_PENDING, &il->status);\r\n__il3945_down(il);\r\nclear_bit(S_EXIT_PENDING, &il->status);\r\nIL_ERR("Unable to initialize device after %d attempts.\n", i);\r\nreturn -EIO;\r\n}\r\nstatic void\r\nil3945_bg_init_alive_start(struct work_struct *data)\r\n{\r\nstruct il_priv *il =\r\ncontainer_of(data, struct il_priv, init_alive_start.work);\r\nmutex_lock(&il->mutex);\r\nif (test_bit(S_EXIT_PENDING, &il->status))\r\ngoto out;\r\nil3945_init_alive_start(il);\r\nout:\r\nmutex_unlock(&il->mutex);\r\n}\r\nstatic void\r\nil3945_bg_alive_start(struct work_struct *data)\r\n{\r\nstruct il_priv *il =\r\ncontainer_of(data, struct il_priv, alive_start.work);\r\nmutex_lock(&il->mutex);\r\nif (test_bit(S_EXIT_PENDING, &il->status) || il->txq == NULL)\r\ngoto out;\r\nil3945_alive_start(il);\r\nout:\r\nmutex_unlock(&il->mutex);\r\n}\r\nstatic void\r\nil3945_rfkill_poll(struct work_struct *data)\r\n{\r\nstruct il_priv *il =\r\ncontainer_of(data, struct il_priv, _3945.rfkill_poll.work);\r\nbool old_rfkill = test_bit(S_RFKILL, &il->status);\r\nbool new_rfkill =\r\n!(_il_rd(il, CSR_GP_CNTRL) & CSR_GP_CNTRL_REG_FLAG_HW_RF_KILL_SW);\r\nif (new_rfkill != old_rfkill) {\r\nif (new_rfkill)\r\nset_bit(S_RFKILL, &il->status);\r\nelse\r\nclear_bit(S_RFKILL, &il->status);\r\nwiphy_rfkill_set_hw_state(il->hw->wiphy, new_rfkill);\r\nD_RF_KILL("RF_KILL bit toggled to %s.\n",\r\nnew_rfkill ? "disable radio" : "enable radio");\r\n}\r\nqueue_delayed_work(il->workqueue, &il->_3945.rfkill_poll,\r\nround_jiffies_relative(2 * HZ));\r\n}\r\nint\r\nil3945_request_scan(struct il_priv *il, struct ieee80211_vif *vif)\r\n{\r\nstruct il_host_cmd cmd = {\r\n.id = C_SCAN,\r\n.len = sizeof(struct il3945_scan_cmd),\r\n.flags = CMD_SIZE_HUGE,\r\n};\r\nstruct il3945_scan_cmd *scan;\r\nu8 n_probes = 0;\r\nenum ieee80211_band band;\r\nbool is_active = false;\r\nint ret;\r\nu16 len;\r\nlockdep_assert_held(&il->mutex);\r\nif (!il->scan_cmd) {\r\nil->scan_cmd =\r\nkmalloc(sizeof(struct il3945_scan_cmd) + IL_MAX_SCAN_SIZE,\r\nGFP_KERNEL);\r\nif (!il->scan_cmd) {\r\nD_SCAN("Fail to allocate scan memory\n");\r\nreturn -ENOMEM;\r\n}\r\n}\r\nscan = il->scan_cmd;\r\nmemset(scan, 0, sizeof(struct il3945_scan_cmd) + IL_MAX_SCAN_SIZE);\r\nscan->quiet_plcp_th = IL_PLCP_QUIET_THRESH;\r\nscan->quiet_time = IL_ACTIVE_QUIET_TIME;\r\nif (il_is_associated(il)) {\r\nu16 interval;\r\nu32 extra;\r\nu32 suspend_time = 100;\r\nu32 scan_suspend_time = 100;\r\nD_INFO("Scanning while associated...\n");\r\ninterval = vif->bss_conf.beacon_int;\r\nscan->suspend_time = 0;\r\nscan->max_out_time = cpu_to_le32(200 * 1024);\r\nif (!interval)\r\ninterval = suspend_time;\r\nextra = (suspend_time / interval) << 24;\r\nscan_suspend_time =\r\n0xFF0FFFFF & (extra | ((suspend_time % interval) * 1024));\r\nscan->suspend_time = cpu_to_le32(scan_suspend_time);\r\nD_SCAN("suspend_time 0x%X beacon interval %d\n",\r\nscan_suspend_time, interval);\r\n}\r\nif (il->scan_request->n_ssids) {\r\nint i, p = 0;\r\nD_SCAN("Kicking off active scan\n");\r\nfor (i = 0; i < il->scan_request->n_ssids; i++) {\r\nif (!il->scan_request->ssids[i].ssid_len)\r\ncontinue;\r\nscan->direct_scan[p].id = WLAN_EID_SSID;\r\nscan->direct_scan[p].len =\r\nil->scan_request->ssids[i].ssid_len;\r\nmemcpy(scan->direct_scan[p].ssid,\r\nil->scan_request->ssids[i].ssid,\r\nil->scan_request->ssids[i].ssid_len);\r\nn_probes++;\r\np++;\r\n}\r\nis_active = true;\r\n} else\r\nD_SCAN("Kicking off passive scan.\n");\r\nscan->tx_cmd.tx_flags = TX_CMD_FLG_SEQ_CTL_MSK;\r\nscan->tx_cmd.sta_id = il->hw_params.bcast_id;\r\nscan->tx_cmd.stop_time.life_time = TX_CMD_LIFE_TIME_INFINITE;\r\nswitch (il->scan_band) {\r\ncase IEEE80211_BAND_2GHZ:\r\nscan->flags = RXON_FLG_BAND_24G_MSK | RXON_FLG_AUTO_DETECT_MSK;\r\nscan->tx_cmd.rate = RATE_1M_PLCP;\r\nband = IEEE80211_BAND_2GHZ;\r\nbreak;\r\ncase IEEE80211_BAND_5GHZ:\r\nscan->tx_cmd.rate = RATE_6M_PLCP;\r\nband = IEEE80211_BAND_5GHZ;\r\nbreak;\r\ndefault:\r\nIL_WARN("Invalid scan band\n");\r\nreturn -EIO;\r\n}\r\nscan->good_CRC_th =\r\nis_active ? IL_GOOD_CRC_TH_DEFAULT : IL_GOOD_CRC_TH_NEVER;\r\nlen =\r\nil_fill_probe_req(il, (struct ieee80211_mgmt *)scan->data,\r\nvif->addr, il->scan_request->ie,\r\nil->scan_request->ie_len,\r\nIL_MAX_SCAN_SIZE - sizeof(*scan));\r\nscan->tx_cmd.len = cpu_to_le16(len);\r\nscan->flags |= il3945_get_antenna_flags(il);\r\nscan->channel_count =\r\nil3945_get_channels_for_scan(il, band, is_active, n_probes,\r\n(void *)&scan->data[len], vif);\r\nif (scan->channel_count == 0) {\r\nD_SCAN("channel count %d\n", scan->channel_count);\r\nreturn -EIO;\r\n}\r\ncmd.len +=\r\nle16_to_cpu(scan->tx_cmd.len) +\r\nscan->channel_count * sizeof(struct il3945_scan_channel);\r\ncmd.data = scan;\r\nscan->len = cpu_to_le16(cmd.len);\r\nset_bit(S_SCAN_HW, &il->status);\r\nret = il_send_cmd_sync(il, &cmd);\r\nif (ret)\r\nclear_bit(S_SCAN_HW, &il->status);\r\nreturn ret;\r\n}\r\nvoid\r\nil3945_post_scan(struct il_priv *il)\r\n{\r\nif (memcmp(&il->staging, &il->active, sizeof(il->staging)))\r\nil3945_commit_rxon(il);\r\n}\r\nstatic void\r\nil3945_bg_restart(struct work_struct *data)\r\n{\r\nstruct il_priv *il = container_of(data, struct il_priv, restart);\r\nif (test_bit(S_EXIT_PENDING, &il->status))\r\nreturn;\r\nif (test_and_clear_bit(S_FW_ERROR, &il->status)) {\r\nmutex_lock(&il->mutex);\r\nil->is_open = 0;\r\nmutex_unlock(&il->mutex);\r\nil3945_down(il);\r\nieee80211_restart_hw(il->hw);\r\n} else {\r\nil3945_down(il);\r\nmutex_lock(&il->mutex);\r\nif (test_bit(S_EXIT_PENDING, &il->status)) {\r\nmutex_unlock(&il->mutex);\r\nreturn;\r\n}\r\n__il3945_up(il);\r\nmutex_unlock(&il->mutex);\r\n}\r\n}\r\nstatic void\r\nil3945_bg_rx_replenish(struct work_struct *data)\r\n{\r\nstruct il_priv *il = container_of(data, struct il_priv, rx_replenish);\r\nmutex_lock(&il->mutex);\r\nif (test_bit(S_EXIT_PENDING, &il->status))\r\ngoto out;\r\nil3945_rx_replenish(il);\r\nout:\r\nmutex_unlock(&il->mutex);\r\n}\r\nvoid\r\nil3945_post_associate(struct il_priv *il)\r\n{\r\nint rc = 0;\r\nstruct ieee80211_conf *conf = NULL;\r\nif (!il->vif || !il->is_open)\r\nreturn;\r\nD_ASSOC("Associated as %d to: %pM\n", il->vif->bss_conf.aid,\r\nil->active.bssid_addr);\r\nif (test_bit(S_EXIT_PENDING, &il->status))\r\nreturn;\r\nil_scan_cancel_timeout(il, 200);\r\nconf = &il->hw->conf;\r\nil->staging.filter_flags &= ~RXON_FILTER_ASSOC_MSK;\r\nil3945_commit_rxon(il);\r\nrc = il_send_rxon_timing(il);\r\nif (rc)\r\nIL_WARN("C_RXON_TIMING failed - " "Attempting to continue.\n");\r\nil->staging.filter_flags |= RXON_FILTER_ASSOC_MSK;\r\nil->staging.assoc_id = cpu_to_le16(il->vif->bss_conf.aid);\r\nD_ASSOC("assoc id %d beacon interval %d\n", il->vif->bss_conf.aid,\r\nil->vif->bss_conf.beacon_int);\r\nif (il->vif->bss_conf.use_short_preamble)\r\nil->staging.flags |= RXON_FLG_SHORT_PREAMBLE_MSK;\r\nelse\r\nil->staging.flags &= ~RXON_FLG_SHORT_PREAMBLE_MSK;\r\nif (il->staging.flags & RXON_FLG_BAND_24G_MSK) {\r\nif (il->vif->bss_conf.use_short_slot)\r\nil->staging.flags |= RXON_FLG_SHORT_SLOT_MSK;\r\nelse\r\nil->staging.flags &= ~RXON_FLG_SHORT_SLOT_MSK;\r\n}\r\nil3945_commit_rxon(il);\r\nswitch (il->vif->type) {\r\ncase NL80211_IFTYPE_STATION:\r\nil3945_rate_scale_init(il->hw, IL_AP_ID);\r\nbreak;\r\ncase NL80211_IFTYPE_ADHOC:\r\nil3945_send_beacon_cmd(il);\r\nbreak;\r\ndefault:\r\nIL_ERR("%s Should not be called in %d mode\n", __func__,\r\nil->vif->type);\r\nbreak;\r\n}\r\n}\r\nstatic int\r\nil3945_mac_start(struct ieee80211_hw *hw)\r\n{\r\nstruct il_priv *il = hw->priv;\r\nint ret;\r\nmutex_lock(&il->mutex);\r\nD_MAC80211("enter\n");\r\nif (!il->ucode_code.len) {\r\nret = il3945_read_ucode(il);\r\nif (ret) {\r\nIL_ERR("Could not read microcode: %d\n", ret);\r\nmutex_unlock(&il->mutex);\r\ngoto out_release_irq;\r\n}\r\n}\r\nret = __il3945_up(il);\r\nmutex_unlock(&il->mutex);\r\nif (ret)\r\ngoto out_release_irq;\r\nD_INFO("Start UP work.\n");\r\nret = wait_event_timeout(il->wait_command_queue,\r\ntest_bit(S_READY, &il->status),\r\nUCODE_READY_TIMEOUT);\r\nif (!ret) {\r\nif (!test_bit(S_READY, &il->status)) {\r\nIL_ERR("Wait for START_ALIVE timeout after %dms.\n",\r\njiffies_to_msecs(UCODE_READY_TIMEOUT));\r\nret = -ETIMEDOUT;\r\ngoto out_release_irq;\r\n}\r\n}\r\ncancel_delayed_work(&il->_3945.rfkill_poll);\r\nil->is_open = 1;\r\nD_MAC80211("leave\n");\r\nreturn 0;\r\nout_release_irq:\r\nil->is_open = 0;\r\nD_MAC80211("leave - failed\n");\r\nreturn ret;\r\n}\r\nstatic void\r\nil3945_mac_stop(struct ieee80211_hw *hw)\r\n{\r\nstruct il_priv *il = hw->priv;\r\nD_MAC80211("enter\n");\r\nif (!il->is_open) {\r\nD_MAC80211("leave - skip\n");\r\nreturn;\r\n}\r\nil->is_open = 0;\r\nil3945_down(il);\r\nflush_workqueue(il->workqueue);\r\nqueue_delayed_work(il->workqueue, &il->_3945.rfkill_poll,\r\nround_jiffies_relative(2 * HZ));\r\nD_MAC80211("leave\n");\r\n}\r\nstatic void\r\nil3945_mac_tx(struct ieee80211_hw *hw,\r\nstruct ieee80211_tx_control *control,\r\nstruct sk_buff *skb)\r\n{\r\nstruct il_priv *il = hw->priv;\r\nD_MAC80211("enter\n");\r\nD_TX("dev->xmit(%d bytes) at rate 0x%02x\n", skb->len,\r\nieee80211_get_tx_rate(hw, IEEE80211_SKB_CB(skb))->bitrate);\r\nif (il3945_tx_skb(il, control->sta, skb))\r\ndev_kfree_skb_any(skb);\r\nD_MAC80211("leave\n");\r\n}\r\nvoid\r\nil3945_config_ap(struct il_priv *il)\r\n{\r\nstruct ieee80211_vif *vif = il->vif;\r\nint rc = 0;\r\nif (test_bit(S_EXIT_PENDING, &il->status))\r\nreturn;\r\nif (!(il_is_associated(il))) {\r\nil->staging.filter_flags &= ~RXON_FILTER_ASSOC_MSK;\r\nil3945_commit_rxon(il);\r\nrc = il_send_rxon_timing(il);\r\nif (rc)\r\nIL_WARN("C_RXON_TIMING failed - "\r\n"Attempting to continue.\n");\r\nil->staging.assoc_id = 0;\r\nif (vif->bss_conf.use_short_preamble)\r\nil->staging.flags |= RXON_FLG_SHORT_PREAMBLE_MSK;\r\nelse\r\nil->staging.flags &= ~RXON_FLG_SHORT_PREAMBLE_MSK;\r\nif (il->staging.flags & RXON_FLG_BAND_24G_MSK) {\r\nif (vif->bss_conf.use_short_slot)\r\nil->staging.flags |= RXON_FLG_SHORT_SLOT_MSK;\r\nelse\r\nil->staging.flags &= ~RXON_FLG_SHORT_SLOT_MSK;\r\n}\r\nil->staging.filter_flags |= RXON_FILTER_ASSOC_MSK;\r\nil3945_commit_rxon(il);\r\n}\r\nil3945_send_beacon_cmd(il);\r\n}\r\nstatic int\r\nil3945_mac_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,\r\nstruct ieee80211_vif *vif, struct ieee80211_sta *sta,\r\nstruct ieee80211_key_conf *key)\r\n{\r\nstruct il_priv *il = hw->priv;\r\nint ret = 0;\r\nu8 sta_id = IL_INVALID_STATION;\r\nu8 static_key;\r\nD_MAC80211("enter\n");\r\nif (il3945_mod_params.sw_crypto) {\r\nD_MAC80211("leave - hwcrypto disabled\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (vif->type == NL80211_IFTYPE_ADHOC &&\r\n!(key->flags & IEEE80211_KEY_FLAG_PAIRWISE)) {\r\nD_MAC80211("leave - IBSS RSN\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic_key = !il_is_associated(il);\r\nif (!static_key) {\r\nsta_id = il_sta_id_or_broadcast(il, sta);\r\nif (sta_id == IL_INVALID_STATION) {\r\nD_MAC80211("leave - station not found\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nmutex_lock(&il->mutex);\r\nil_scan_cancel_timeout(il, 100);\r\nswitch (cmd) {\r\ncase SET_KEY:\r\nif (static_key)\r\nret = il3945_set_static_key(il, key);\r\nelse\r\nret = il3945_set_dynamic_key(il, key, sta_id);\r\nD_MAC80211("enable hwcrypto key\n");\r\nbreak;\r\ncase DISABLE_KEY:\r\nif (static_key)\r\nret = il3945_remove_static_key(il);\r\nelse\r\nret = il3945_clear_sta_key_info(il, sta_id);\r\nD_MAC80211("disable hwcrypto key\n");\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nD_MAC80211("leave ret %d\n", ret);\r\nmutex_unlock(&il->mutex);\r\nreturn ret;\r\n}\r\nstatic int\r\nil3945_mac_sta_add(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\r\nstruct ieee80211_sta *sta)\r\n{\r\nstruct il_priv *il = hw->priv;\r\nstruct il3945_sta_priv *sta_priv = (void *)sta->drv_priv;\r\nint ret;\r\nbool is_ap = vif->type == NL80211_IFTYPE_STATION;\r\nu8 sta_id;\r\nmutex_lock(&il->mutex);\r\nD_INFO("station %pM\n", sta->addr);\r\nsta_priv->common.sta_id = IL_INVALID_STATION;\r\nret = il_add_station_common(il, sta->addr, is_ap, sta, &sta_id);\r\nif (ret) {\r\nIL_ERR("Unable to add station %pM (%d)\n", sta->addr, ret);\r\nmutex_unlock(&il->mutex);\r\nreturn ret;\r\n}\r\nsta_priv->common.sta_id = sta_id;\r\nD_INFO("Initializing rate scaling for station %pM\n", sta->addr);\r\nil3945_rs_rate_init(il, sta, sta_id);\r\nmutex_unlock(&il->mutex);\r\nreturn 0;\r\n}\r\nstatic void\r\nil3945_configure_filter(struct ieee80211_hw *hw, unsigned int changed_flags,\r\nunsigned int *total_flags, u64 multicast)\r\n{\r\nstruct il_priv *il = hw->priv;\r\n__le32 filter_or = 0, filter_nand = 0;\r\n#define CHK(test, flag) do { \\r\nif (*total_flags & (test)) \\r\nfilter_or |= (flag); \\r\nelse \\r\nfilter_nand |= (flag); \\r\n} while (0)\r\nD_MAC80211("Enter: changed: 0x%x, total: 0x%x\n", changed_flags,\r\n*total_flags);\r\nCHK(FIF_OTHER_BSS | FIF_PROMISC_IN_BSS, RXON_FILTER_PROMISC_MSK);\r\nCHK(FIF_CONTROL, RXON_FILTER_CTL2HOST_MSK);\r\nCHK(FIF_BCN_PRBRESP_PROMISC, RXON_FILTER_BCON_AWARE_MSK);\r\n#undef CHK\r\nmutex_lock(&il->mutex);\r\nil->staging.filter_flags &= ~filter_nand;\r\nil->staging.filter_flags |= filter_or;\r\nmutex_unlock(&il->mutex);\r\n*total_flags &=\r\nFIF_OTHER_BSS | FIF_ALLMULTI | FIF_PROMISC_IN_BSS |\r\nFIF_BCN_PRBRESP_PROMISC | FIF_CONTROL;\r\n}\r\nstatic ssize_t\r\nil3945_show_debug_level(struct device *d, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct il_priv *il = dev_get_drvdata(d);\r\nreturn sprintf(buf, "0x%08X\n", il_get_debug_level(il));\r\n}\r\nstatic ssize_t\r\nil3945_store_debug_level(struct device *d, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct il_priv *il = dev_get_drvdata(d);\r\nunsigned long val;\r\nint ret;\r\nret = kstrtoul(buf, 0, &val);\r\nif (ret)\r\nIL_INFO("%s is not in hex or decimal form.\n", buf);\r\nelse\r\nil->debug_level = val;\r\nreturn strnlen(buf, count);\r\n}\r\nstatic ssize_t\r\nil3945_show_temperature(struct device *d, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct il_priv *il = dev_get_drvdata(d);\r\nif (!il_is_alive(il))\r\nreturn -EAGAIN;\r\nreturn sprintf(buf, "%d\n", il3945_hw_get_temperature(il));\r\n}\r\nstatic ssize_t\r\nil3945_show_tx_power(struct device *d, struct device_attribute *attr, char *buf)\r\n{\r\nstruct il_priv *il = dev_get_drvdata(d);\r\nreturn sprintf(buf, "%d\n", il->tx_power_user_lmt);\r\n}\r\nstatic ssize_t\r\nil3945_store_tx_power(struct device *d, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct il_priv *il = dev_get_drvdata(d);\r\nchar *p = (char *)buf;\r\nu32 val;\r\nval = simple_strtoul(p, &p, 10);\r\nif (p == buf)\r\nIL_INFO(": %s is not in decimal form.\n", buf);\r\nelse\r\nil3945_hw_reg_set_txpower(il, val);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nil3945_show_flags(struct device *d, struct device_attribute *attr, char *buf)\r\n{\r\nstruct il_priv *il = dev_get_drvdata(d);\r\nreturn sprintf(buf, "0x%04X\n", il->active.flags);\r\n}\r\nstatic ssize_t\r\nil3945_store_flags(struct device *d, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct il_priv *il = dev_get_drvdata(d);\r\nu32 flags = simple_strtoul(buf, NULL, 0);\r\nmutex_lock(&il->mutex);\r\nif (le32_to_cpu(il->staging.flags) != flags) {\r\nif (il_scan_cancel_timeout(il, 100))\r\nIL_WARN("Could not cancel scan.\n");\r\nelse {\r\nD_INFO("Committing rxon.flags = 0x%04X\n", flags);\r\nil->staging.flags = cpu_to_le32(flags);\r\nil3945_commit_rxon(il);\r\n}\r\n}\r\nmutex_unlock(&il->mutex);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nil3945_show_filter_flags(struct device *d, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct il_priv *il = dev_get_drvdata(d);\r\nreturn sprintf(buf, "0x%04X\n", le32_to_cpu(il->active.filter_flags));\r\n}\r\nstatic ssize_t\r\nil3945_store_filter_flags(struct device *d, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct il_priv *il = dev_get_drvdata(d);\r\nu32 filter_flags = simple_strtoul(buf, NULL, 0);\r\nmutex_lock(&il->mutex);\r\nif (le32_to_cpu(il->staging.filter_flags) != filter_flags) {\r\nif (il_scan_cancel_timeout(il, 100))\r\nIL_WARN("Could not cancel scan.\n");\r\nelse {\r\nD_INFO("Committing rxon.filter_flags = " "0x%04X\n",\r\nfilter_flags);\r\nil->staging.filter_flags = cpu_to_le32(filter_flags);\r\nil3945_commit_rxon(il);\r\n}\r\n}\r\nmutex_unlock(&il->mutex);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nil3945_show_measurement(struct device *d, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct il_priv *il = dev_get_drvdata(d);\r\nstruct il_spectrum_notification measure_report;\r\nu32 size = sizeof(measure_report), len = 0, ofs = 0;\r\nu8 *data = (u8 *) &measure_report;\r\nunsigned long flags;\r\nspin_lock_irqsave(&il->lock, flags);\r\nif (!(il->measurement_status & MEASUREMENT_READY)) {\r\nspin_unlock_irqrestore(&il->lock, flags);\r\nreturn 0;\r\n}\r\nmemcpy(&measure_report, &il->measure_report, size);\r\nil->measurement_status = 0;\r\nspin_unlock_irqrestore(&il->lock, flags);\r\nwhile (size && PAGE_SIZE - len) {\r\nhex_dump_to_buffer(data + ofs, size, 16, 1, buf + len,\r\nPAGE_SIZE - len, 1);\r\nlen = strlen(buf);\r\nif (PAGE_SIZE - len)\r\nbuf[len++] = '\n';\r\nofs += 16;\r\nsize -= min(size, 16U);\r\n}\r\nreturn len;\r\n}\r\nstatic ssize_t\r\nil3945_store_measurement(struct device *d, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct il_priv *il = dev_get_drvdata(d);\r\nstruct ieee80211_measurement_params params = {\r\n.channel = le16_to_cpu(il->active.channel),\r\n.start_time = cpu_to_le64(il->_3945.last_tsf),\r\n.duration = cpu_to_le16(1),\r\n};\r\nu8 type = IL_MEASURE_BASIC;\r\nu8 buffer[32];\r\nu8 channel;\r\nif (count) {\r\nchar *p = buffer;\r\nstrlcpy(buffer, buf, sizeof(buffer));\r\nchannel = simple_strtoul(p, NULL, 0);\r\nif (channel)\r\nparams.channel = channel;\r\np = buffer;\r\nwhile (*p && *p != ' ')\r\np++;\r\nif (*p)\r\ntype = simple_strtoul(p + 1, NULL, 0);\r\n}\r\nD_INFO("Invoking measurement of type %d on " "channel %d (for '%s')\n",\r\ntype, params.channel, buf);\r\nil3945_get_measurement(il, &params, type);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nil3945_store_retry_rate(struct device *d, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct il_priv *il = dev_get_drvdata(d);\r\nil->retry_rate = simple_strtoul(buf, NULL, 0);\r\nif (il->retry_rate <= 0)\r\nil->retry_rate = 1;\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nil3945_show_retry_rate(struct device *d, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct il_priv *il = dev_get_drvdata(d);\r\nreturn sprintf(buf, "%d", il->retry_rate);\r\n}\r\nstatic ssize_t\r\nil3945_show_channels(struct device *d, struct device_attribute *attr, char *buf)\r\n{\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nil3945_show_antenna(struct device *d, struct device_attribute *attr, char *buf)\r\n{\r\nstruct il_priv *il = dev_get_drvdata(d);\r\nif (!il_is_alive(il))\r\nreturn -EAGAIN;\r\nreturn sprintf(buf, "%d\n", il3945_mod_params.antenna);\r\n}\r\nstatic ssize_t\r\nil3945_store_antenna(struct device *d, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct il_priv *il __maybe_unused = dev_get_drvdata(d);\r\nint ant;\r\nif (count == 0)\r\nreturn 0;\r\nif (sscanf(buf, "%1i", &ant) != 1) {\r\nD_INFO("not in hex or decimal form.\n");\r\nreturn count;\r\n}\r\nif (ant >= 0 && ant <= 2) {\r\nD_INFO("Setting antenna select to %d.\n", ant);\r\nil3945_mod_params.antenna = (enum il3945_antenna)ant;\r\n} else\r\nD_INFO("Bad antenna select value %d.\n", ant);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nil3945_show_status(struct device *d, struct device_attribute *attr, char *buf)\r\n{\r\nstruct il_priv *il = dev_get_drvdata(d);\r\nif (!il_is_alive(il))\r\nreturn -EAGAIN;\r\nreturn sprintf(buf, "0x%08x\n", (int)il->status);\r\n}\r\nstatic ssize_t\r\nil3945_dump_error_log(struct device *d, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct il_priv *il = dev_get_drvdata(d);\r\nchar *p = (char *)buf;\r\nif (p[0] == '1')\r\nil3945_dump_nic_error_log(il);\r\nreturn strnlen(buf, count);\r\n}\r\nstatic void\r\nil3945_setup_deferred_work(struct il_priv *il)\r\n{\r\nil->workqueue = create_singlethread_workqueue(DRV_NAME);\r\ninit_waitqueue_head(&il->wait_command_queue);\r\nINIT_WORK(&il->restart, il3945_bg_restart);\r\nINIT_WORK(&il->rx_replenish, il3945_bg_rx_replenish);\r\nINIT_DELAYED_WORK(&il->init_alive_start, il3945_bg_init_alive_start);\r\nINIT_DELAYED_WORK(&il->alive_start, il3945_bg_alive_start);\r\nINIT_DELAYED_WORK(&il->_3945.rfkill_poll, il3945_rfkill_poll);\r\nil_setup_scan_deferred_work(il);\r\nil3945_hw_setup_deferred_work(il);\r\nsetup_timer(&il->watchdog, il_bg_watchdog, (unsigned long)il);\r\ntasklet_init(&il->irq_tasklet,\r\n(void (*)(unsigned long))il3945_irq_tasklet,\r\n(unsigned long)il);\r\n}\r\nstatic void\r\nil3945_cancel_deferred_work(struct il_priv *il)\r\n{\r\nil3945_hw_cancel_deferred_work(il);\r\ncancel_delayed_work_sync(&il->init_alive_start);\r\ncancel_delayed_work(&il->alive_start);\r\nil_cancel_scan_deferred_work(il);\r\n}\r\nstatic int\r\nil3945_init_drv(struct il_priv *il)\r\n{\r\nint ret;\r\nstruct il3945_eeprom *eeprom = (struct il3945_eeprom *)il->eeprom;\r\nil->retry_rate = 1;\r\nil->beacon_skb = NULL;\r\nspin_lock_init(&il->sta_lock);\r\nspin_lock_init(&il->hcmd_lock);\r\nINIT_LIST_HEAD(&il->free_frames);\r\nmutex_init(&il->mutex);\r\nil->ieee_channels = NULL;\r\nil->ieee_rates = NULL;\r\nil->band = IEEE80211_BAND_2GHZ;\r\nil->iw_mode = NL80211_IFTYPE_STATION;\r\nil->missed_beacon_threshold = IL_MISSED_BEACON_THRESHOLD_DEF;\r\nil->force_reset.reset_duration = IL_DELAY_NEXT_FORCE_FW_RELOAD;\r\nif (eeprom->version < EEPROM_3945_EEPROM_VERSION) {\r\nIL_WARN("Unsupported EEPROM version: 0x%04X\n",\r\neeprom->version);\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nret = il_init_channel_map(il);\r\nif (ret) {\r\nIL_ERR("initializing regulatory failed: %d\n", ret);\r\ngoto err;\r\n}\r\nif (il3945_txpower_set_from_eeprom(il)) {\r\nret = -EIO;\r\ngoto err_free_channel_map;\r\n}\r\nret = il_init_geos(il);\r\nif (ret) {\r\nIL_ERR("initializing geos failed: %d\n", ret);\r\ngoto err_free_channel_map;\r\n}\r\nil3945_init_hw_rates(il, il->ieee_rates);\r\nreturn 0;\r\nerr_free_channel_map:\r\nil_free_channel_map(il);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int\r\nil3945_setup_mac(struct il_priv *il)\r\n{\r\nint ret;\r\nstruct ieee80211_hw *hw = il->hw;\r\nhw->rate_control_algorithm = "iwl-3945-rs";\r\nhw->sta_data_size = sizeof(struct il3945_sta_priv);\r\nhw->vif_data_size = sizeof(struct il_vif_priv);\r\nhw->flags = IEEE80211_HW_SIGNAL_DBM | IEEE80211_HW_SPECTRUM_MGMT |\r\nIEEE80211_HW_SUPPORTS_PS | IEEE80211_HW_SUPPORTS_DYNAMIC_PS;\r\nhw->wiphy->interface_modes =\r\nBIT(NL80211_IFTYPE_STATION) | BIT(NL80211_IFTYPE_ADHOC);\r\nhw->wiphy->flags |= WIPHY_FLAG_IBSS_RSN;\r\nhw->wiphy->regulatory_flags |= REGULATORY_CUSTOM_REG |\r\nREGULATORY_DISABLE_BEACON_HINTS;\r\nhw->wiphy->flags &= ~WIPHY_FLAG_PS_ON_BY_DEFAULT;\r\nhw->wiphy->max_scan_ssids = PROBE_OPTION_MAX_3945;\r\nhw->wiphy->max_scan_ie_len = IL3945_MAX_PROBE_REQUEST - 24 - 2;\r\nhw->queues = 4;\r\nif (il->bands[IEEE80211_BAND_2GHZ].n_channels)\r\nil->hw->wiphy->bands[IEEE80211_BAND_2GHZ] =\r\n&il->bands[IEEE80211_BAND_2GHZ];\r\nif (il->bands[IEEE80211_BAND_5GHZ].n_channels)\r\nil->hw->wiphy->bands[IEEE80211_BAND_5GHZ] =\r\n&il->bands[IEEE80211_BAND_5GHZ];\r\nil_leds_init(il);\r\nret = ieee80211_register_hw(il->hw);\r\nif (ret) {\r\nIL_ERR("Failed to register hw (error %d)\n", ret);\r\nreturn ret;\r\n}\r\nil->mac80211_registered = 1;\r\nreturn 0;\r\n}\r\nstatic int\r\nil3945_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nint err = 0;\r\nstruct il_priv *il;\r\nstruct ieee80211_hw *hw;\r\nstruct il_cfg *cfg = (struct il_cfg *)(ent->driver_data);\r\nstruct il3945_eeprom *eeprom;\r\nunsigned long flags;\r\nhw = ieee80211_alloc_hw(sizeof(struct il_priv), &il3945_mac_ops);\r\nif (!hw) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nil = hw->priv;\r\nil->hw = hw;\r\nSET_IEEE80211_DEV(hw, &pdev->dev);\r\nil->cmd_queue = IL39_CMD_QUEUE_NUM;\r\nif (il3945_mod_params.disable_hw_scan) {\r\nD_INFO("Disabling hw_scan\n");\r\nil3945_mac_ops.hw_scan = NULL;\r\n}\r\nD_INFO("*** LOAD DRIVER ***\n");\r\nil->cfg = cfg;\r\nil->ops = &il3945_ops;\r\n#ifdef CONFIG_IWLEGACY_DEBUGFS\r\nil->debugfs_ops = &il3945_debugfs_ops;\r\n#endif\r\nil->pci_dev = pdev;\r\nil->inta_mask = CSR_INI_SET_MASK;\r\npci_disable_link_state(pdev,\r\nPCIE_LINK_STATE_L0S | PCIE_LINK_STATE_L1 |\r\nPCIE_LINK_STATE_CLKPM);\r\nif (pci_enable_device(pdev)) {\r\nerr = -ENODEV;\r\ngoto out_ieee80211_free_hw;\r\n}\r\npci_set_master(pdev);\r\nerr = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (!err)\r\nerr = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (err) {\r\nIL_WARN("No suitable DMA available.\n");\r\ngoto out_pci_disable_device;\r\n}\r\npci_set_drvdata(pdev, il);\r\nerr = pci_request_regions(pdev, DRV_NAME);\r\nif (err)\r\ngoto out_pci_disable_device;\r\nil->hw_base = pci_ioremap_bar(pdev, 0);\r\nif (!il->hw_base) {\r\nerr = -ENODEV;\r\ngoto out_pci_release_regions;\r\n}\r\nD_INFO("pci_resource_len = 0x%08llx\n",\r\n(unsigned long long)pci_resource_len(pdev, 0));\r\nD_INFO("pci_resource_base = %p\n", il->hw_base);\r\npci_write_config_byte(pdev, 0x41, 0x00);\r\nspin_lock_init(&il->reg_lock);\r\nspin_lock_init(&il->lock);\r\n_il_wr(il, CSR_RESET, CSR_RESET_REG_FLAG_NEVO_RESET);\r\nerr = il_eeprom_init(il);\r\nif (err) {\r\nIL_ERR("Unable to init EEPROM\n");\r\ngoto out_iounmap;\r\n}\r\neeprom = (struct il3945_eeprom *)il->eeprom;\r\nD_INFO("MAC address: %pM\n", eeprom->mac_address);\r\nSET_IEEE80211_PERM_ADDR(il->hw, eeprom->mac_address);\r\nerr = il3945_hw_set_hw_params(il);\r\nif (err) {\r\nIL_ERR("failed to set hw settings\n");\r\ngoto out_eeprom_free;\r\n}\r\nerr = il3945_init_drv(il);\r\nif (err) {\r\nIL_ERR("initializing driver failed\n");\r\ngoto out_unset_hw_params;\r\n}\r\nIL_INFO("Detected Intel Wireless WiFi Link %s\n", il->cfg->name);\r\nspin_lock_irqsave(&il->lock, flags);\r\nil_disable_interrupts(il);\r\nspin_unlock_irqrestore(&il->lock, flags);\r\npci_enable_msi(il->pci_dev);\r\nerr = request_irq(il->pci_dev->irq, il_isr, IRQF_SHARED, DRV_NAME, il);\r\nif (err) {\r\nIL_ERR("Error allocating IRQ %d\n", il->pci_dev->irq);\r\ngoto out_disable_msi;\r\n}\r\nerr = sysfs_create_group(&pdev->dev.kobj, &il3945_attribute_group);\r\nif (err) {\r\nIL_ERR("failed to create sysfs device attributes\n");\r\ngoto out_release_irq;\r\n}\r\nil_set_rxon_channel(il, &il->bands[IEEE80211_BAND_2GHZ].channels[5]);\r\nil3945_setup_deferred_work(il);\r\nil3945_setup_handlers(il);\r\nil_power_initialize(il);\r\nil_enable_interrupts(il);\r\nerr = il3945_setup_mac(il);\r\nif (err)\r\ngoto out_remove_sysfs;\r\nerr = il_dbgfs_register(il, DRV_NAME);\r\nif (err)\r\nIL_ERR("failed to create debugfs files. Ignoring error: %d\n",\r\nerr);\r\nqueue_delayed_work(il->workqueue, &il->_3945.rfkill_poll, 2 * HZ);\r\nreturn 0;\r\nout_remove_sysfs:\r\ndestroy_workqueue(il->workqueue);\r\nil->workqueue = NULL;\r\nsysfs_remove_group(&pdev->dev.kobj, &il3945_attribute_group);\r\nout_release_irq:\r\nfree_irq(il->pci_dev->irq, il);\r\nout_disable_msi:\r\npci_disable_msi(il->pci_dev);\r\nil_free_geos(il);\r\nil_free_channel_map(il);\r\nout_unset_hw_params:\r\nil3945_unset_hw_params(il);\r\nout_eeprom_free:\r\nil_eeprom_free(il);\r\nout_iounmap:\r\niounmap(il->hw_base);\r\nout_pci_release_regions:\r\npci_release_regions(pdev);\r\nout_pci_disable_device:\r\npci_disable_device(pdev);\r\nout_ieee80211_free_hw:\r\nieee80211_free_hw(il->hw);\r\nout:\r\nreturn err;\r\n}\r\nstatic void\r\nil3945_pci_remove(struct pci_dev *pdev)\r\n{\r\nstruct il_priv *il = pci_get_drvdata(pdev);\r\nunsigned long flags;\r\nif (!il)\r\nreturn;\r\nD_INFO("*** UNLOAD DRIVER ***\n");\r\nil_dbgfs_unregister(il);\r\nset_bit(S_EXIT_PENDING, &il->status);\r\nil_leds_exit(il);\r\nif (il->mac80211_registered) {\r\nieee80211_unregister_hw(il->hw);\r\nil->mac80211_registered = 0;\r\n} else {\r\nil3945_down(il);\r\n}\r\nil_apm_stop(il);\r\nspin_lock_irqsave(&il->lock, flags);\r\nil_disable_interrupts(il);\r\nspin_unlock_irqrestore(&il->lock, flags);\r\nil3945_synchronize_irq(il);\r\nsysfs_remove_group(&pdev->dev.kobj, &il3945_attribute_group);\r\ncancel_delayed_work_sync(&il->_3945.rfkill_poll);\r\nil3945_dealloc_ucode_pci(il);\r\nif (il->rxq.bd)\r\nil3945_rx_queue_free(il, &il->rxq);\r\nil3945_hw_txq_ctx_free(il);\r\nil3945_unset_hw_params(il);\r\nflush_workqueue(il->workqueue);\r\ndestroy_workqueue(il->workqueue);\r\nil->workqueue = NULL;\r\nfree_irq(pdev->irq, il);\r\npci_disable_msi(pdev);\r\niounmap(il->hw_base);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\nil_free_channel_map(il);\r\nil_free_geos(il);\r\nkfree(il->scan_cmd);\r\nif (il->beacon_skb)\r\ndev_kfree_skb(il->beacon_skb);\r\nieee80211_free_hw(il->hw);\r\n}\r\nstatic int __init\r\nil3945_init(void)\r\n{\r\nint ret;\r\npr_info(DRV_DESCRIPTION ", " DRV_VERSION "\n");\r\npr_info(DRV_COPYRIGHT "\n");\r\nret = il3945_rate_control_register();\r\nif (ret) {\r\npr_err("Unable to register rate control algorithm: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = pci_register_driver(&il3945_driver);\r\nif (ret) {\r\npr_err("Unable to initialize PCI module\n");\r\ngoto error_register;\r\n}\r\nreturn ret;\r\nerror_register:\r\nil3945_rate_control_unregister();\r\nreturn ret;\r\n}\r\nstatic void __exit\r\nil3945_exit(void)\r\n{\r\npci_unregister_driver(&il3945_driver);\r\nil3945_rate_control_unregister();\r\n}
