int iio_push_event(struct iio_dev *indio_dev, u64 ev_code, s64 timestamp)\r\n{\r\nstruct iio_event_interface *ev_int = indio_dev->event_interface;\r\nstruct iio_event_data ev;\r\nint copied;\r\nif (test_bit(IIO_BUSY_BIT_POS, &ev_int->flags)) {\r\nev.id = ev_code;\r\nev.timestamp = timestamp;\r\ncopied = kfifo_put(&ev_int->det_events, ev);\r\nif (copied != 0)\r\nwake_up_poll(&ev_int->wait, POLLIN);\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int iio_event_poll(struct file *filep,\r\nstruct poll_table_struct *wait)\r\n{\r\nstruct iio_dev *indio_dev = filep->private_data;\r\nstruct iio_event_interface *ev_int = indio_dev->event_interface;\r\nunsigned int events = 0;\r\nif (!indio_dev->info)\r\nreturn -ENODEV;\r\npoll_wait(filep, &ev_int->wait, wait);\r\nif (!kfifo_is_empty(&ev_int->det_events))\r\nevents = POLLIN | POLLRDNORM;\r\nreturn events;\r\n}\r\nstatic ssize_t iio_event_chrdev_read(struct file *filep,\r\nchar __user *buf,\r\nsize_t count,\r\nloff_t *f_ps)\r\n{\r\nstruct iio_dev *indio_dev = filep->private_data;\r\nstruct iio_event_interface *ev_int = indio_dev->event_interface;\r\nunsigned int copied;\r\nint ret;\r\nif (!indio_dev->info)\r\nreturn -ENODEV;\r\nif (count < sizeof(struct iio_event_data))\r\nreturn -EINVAL;\r\ndo {\r\nif (kfifo_is_empty(&ev_int->det_events)) {\r\nif (filep->f_flags & O_NONBLOCK)\r\nreturn -EAGAIN;\r\nret = wait_event_interruptible(ev_int->wait,\r\n!kfifo_is_empty(&ev_int->det_events) ||\r\nindio_dev->info == NULL);\r\nif (ret)\r\nreturn ret;\r\nif (indio_dev->info == NULL)\r\nreturn -ENODEV;\r\n}\r\nif (mutex_lock_interruptible(&ev_int->read_lock))\r\nreturn -ERESTARTSYS;\r\nret = kfifo_to_user(&ev_int->det_events, buf, count, &copied);\r\nmutex_unlock(&ev_int->read_lock);\r\nif (ret)\r\nreturn ret;\r\nif (copied == 0 && (filep->f_flags & O_NONBLOCK))\r\nreturn -EAGAIN;\r\n} while (copied == 0);\r\nreturn copied;\r\n}\r\nstatic int iio_event_chrdev_release(struct inode *inode, struct file *filep)\r\n{\r\nstruct iio_dev *indio_dev = filep->private_data;\r\nstruct iio_event_interface *ev_int = indio_dev->event_interface;\r\nclear_bit(IIO_BUSY_BIT_POS, &ev_int->flags);\r\niio_device_put(indio_dev);\r\nreturn 0;\r\n}\r\nint iio_event_getfd(struct iio_dev *indio_dev)\r\n{\r\nstruct iio_event_interface *ev_int = indio_dev->event_interface;\r\nint fd;\r\nif (ev_int == NULL)\r\nreturn -ENODEV;\r\nif (test_and_set_bit(IIO_BUSY_BIT_POS, &ev_int->flags))\r\nreturn -EBUSY;\r\niio_device_get(indio_dev);\r\nfd = anon_inode_getfd("iio:event", &iio_event_chrdev_fileops,\r\nindio_dev, O_RDONLY | O_CLOEXEC);\r\nif (fd < 0) {\r\nclear_bit(IIO_BUSY_BIT_POS, &ev_int->flags);\r\niio_device_put(indio_dev);\r\n} else {\r\nkfifo_reset_out(&ev_int->det_events);\r\n}\r\nreturn fd;\r\n}\r\nstatic enum iio_event_direction iio_ev_attr_dir(struct iio_dev_attr *attr)\r\n{\r\nreturn attr->c->event_spec[attr->address & 0xffff].dir;\r\n}\r\nstatic enum iio_event_type iio_ev_attr_type(struct iio_dev_attr *attr)\r\n{\r\nreturn attr->c->event_spec[attr->address & 0xffff].type;\r\n}\r\nstatic enum iio_event_info iio_ev_attr_info(struct iio_dev_attr *attr)\r\n{\r\nreturn (attr->address >> 16) & 0xffff;\r\n}\r\nstatic ssize_t iio_ev_state_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\r\nint ret;\r\nbool val;\r\nret = strtobool(buf, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nret = indio_dev->info->write_event_config(indio_dev,\r\nthis_attr->c, iio_ev_attr_type(this_attr),\r\niio_ev_attr_dir(this_attr), val);\r\nreturn (ret < 0) ? ret : len;\r\n}\r\nstatic ssize_t iio_ev_state_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\r\nint val;\r\nval = indio_dev->info->read_event_config(indio_dev,\r\nthis_attr->c, iio_ev_attr_type(this_attr),\r\niio_ev_attr_dir(this_attr));\r\nif (val < 0)\r\nreturn val;\r\nelse\r\nreturn sprintf(buf, "%d\n", val);\r\n}\r\nstatic ssize_t iio_ev_value_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\r\nint val, val2, val_arr[2];\r\nint ret;\r\nret = indio_dev->info->read_event_value(indio_dev,\r\nthis_attr->c, iio_ev_attr_type(this_attr),\r\niio_ev_attr_dir(this_attr), iio_ev_attr_info(this_attr),\r\n&val, &val2);\r\nif (ret < 0)\r\nreturn ret;\r\nval_arr[0] = val;\r\nval_arr[1] = val2;\r\nreturn iio_format_value(buf, ret, 2, val_arr);\r\n}\r\nstatic ssize_t iio_ev_value_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\r\nint val, val2;\r\nint ret;\r\nif (!indio_dev->info->write_event_value)\r\nreturn -EINVAL;\r\nret = iio_str_to_fixpoint(buf, 100000, &val, &val2);\r\nif (ret)\r\nreturn ret;\r\nret = indio_dev->info->write_event_value(indio_dev,\r\nthis_attr->c, iio_ev_attr_type(this_attr),\r\niio_ev_attr_dir(this_attr), iio_ev_attr_info(this_attr),\r\nval, val2);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn len;\r\n}\r\nstatic int iio_device_add_event(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan, unsigned int spec_index,\r\nenum iio_event_type type, enum iio_event_direction dir,\r\nenum iio_shared_by shared_by, const unsigned long *mask)\r\n{\r\nssize_t (*show)(struct device *, struct device_attribute *, char *);\r\nssize_t (*store)(struct device *, struct device_attribute *,\r\nconst char *, size_t);\r\nunsigned int attrcount = 0;\r\nunsigned int i;\r\nchar *postfix;\r\nint ret;\r\nfor_each_set_bit(i, mask, sizeof(*mask)*8) {\r\nif (i >= ARRAY_SIZE(iio_ev_info_text))\r\nreturn -EINVAL;\r\nif (dir != IIO_EV_DIR_NONE)\r\npostfix = kasprintf(GFP_KERNEL, "%s_%s_%s",\r\niio_ev_type_text[type],\r\niio_ev_dir_text[dir],\r\niio_ev_info_text[i]);\r\nelse\r\npostfix = kasprintf(GFP_KERNEL, "%s_%s",\r\niio_ev_type_text[type],\r\niio_ev_info_text[i]);\r\nif (postfix == NULL)\r\nreturn -ENOMEM;\r\nif (i == IIO_EV_INFO_ENABLE) {\r\nshow = iio_ev_state_show;\r\nstore = iio_ev_state_store;\r\n} else {\r\nshow = iio_ev_value_show;\r\nstore = iio_ev_value_store;\r\n}\r\nret = __iio_add_chan_devattr(postfix, chan, show, store,\r\n(i << 16) | spec_index, shared_by, &indio_dev->dev,\r\n&indio_dev->event_interface->dev_attr_list);\r\nkfree(postfix);\r\nif ((ret == -EBUSY) && (shared_by != IIO_SEPARATE))\r\ncontinue;\r\nif (ret)\r\nreturn ret;\r\nattrcount++;\r\n}\r\nreturn attrcount;\r\n}\r\nstatic int iio_device_add_event_sysfs(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan)\r\n{\r\nint ret = 0, i, attrcount = 0;\r\nenum iio_event_direction dir;\r\nenum iio_event_type type;\r\nfor (i = 0; i < chan->num_event_specs; i++) {\r\ntype = chan->event_spec[i].type;\r\ndir = chan->event_spec[i].dir;\r\nret = iio_device_add_event(indio_dev, chan, i, type, dir,\r\nIIO_SEPARATE, &chan->event_spec[i].mask_separate);\r\nif (ret < 0)\r\nreturn ret;\r\nattrcount += ret;\r\nret = iio_device_add_event(indio_dev, chan, i, type, dir,\r\nIIO_SHARED_BY_TYPE,\r\n&chan->event_spec[i].mask_shared_by_type);\r\nif (ret < 0)\r\nreturn ret;\r\nattrcount += ret;\r\nret = iio_device_add_event(indio_dev, chan, i, type, dir,\r\nIIO_SHARED_BY_DIR,\r\n&chan->event_spec[i].mask_shared_by_dir);\r\nif (ret < 0)\r\nreturn ret;\r\nattrcount += ret;\r\nret = iio_device_add_event(indio_dev, chan, i, type, dir,\r\nIIO_SHARED_BY_ALL,\r\n&chan->event_spec[i].mask_shared_by_all);\r\nif (ret < 0)\r\nreturn ret;\r\nattrcount += ret;\r\n}\r\nret = attrcount;\r\nreturn ret;\r\n}\r\nstatic inline int __iio_add_event_config_attrs(struct iio_dev *indio_dev)\r\n{\r\nint j, ret, attrcount = 0;\r\nfor (j = 0; j < indio_dev->num_channels; j++) {\r\nret = iio_device_add_event_sysfs(indio_dev,\r\n&indio_dev->channels[j]);\r\nif (ret < 0)\r\nreturn ret;\r\nattrcount += ret;\r\n}\r\nreturn attrcount;\r\n}\r\nstatic bool iio_check_for_dynamic_events(struct iio_dev *indio_dev)\r\n{\r\nint j;\r\nfor (j = 0; j < indio_dev->num_channels; j++) {\r\nif (indio_dev->channels[j].num_event_specs != 0)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void iio_setup_ev_int(struct iio_event_interface *ev_int)\r\n{\r\nINIT_KFIFO(ev_int->det_events);\r\ninit_waitqueue_head(&ev_int->wait);\r\nmutex_init(&ev_int->read_lock);\r\n}\r\nint iio_device_register_eventset(struct iio_dev *indio_dev)\r\n{\r\nstruct iio_dev_attr *p;\r\nint ret = 0, attrcount_orig = 0, attrcount, attrn;\r\nstruct attribute **attr;\r\nif (!(indio_dev->info->event_attrs ||\r\niio_check_for_dynamic_events(indio_dev)))\r\nreturn 0;\r\nindio_dev->event_interface =\r\nkzalloc(sizeof(struct iio_event_interface), GFP_KERNEL);\r\nif (indio_dev->event_interface == NULL)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&indio_dev->event_interface->dev_attr_list);\r\niio_setup_ev_int(indio_dev->event_interface);\r\nif (indio_dev->info->event_attrs != NULL) {\r\nattr = indio_dev->info->event_attrs->attrs;\r\nwhile (*attr++ != NULL)\r\nattrcount_orig++;\r\n}\r\nattrcount = attrcount_orig;\r\nif (indio_dev->channels) {\r\nret = __iio_add_event_config_attrs(indio_dev);\r\nif (ret < 0)\r\ngoto error_free_setup_event_lines;\r\nattrcount += ret;\r\n}\r\nindio_dev->event_interface->group.name = iio_event_group_name;\r\nindio_dev->event_interface->group.attrs = kcalloc(attrcount + 1,\r\nsizeof(indio_dev->event_interface->group.attrs[0]),\r\nGFP_KERNEL);\r\nif (indio_dev->event_interface->group.attrs == NULL) {\r\nret = -ENOMEM;\r\ngoto error_free_setup_event_lines;\r\n}\r\nif (indio_dev->info->event_attrs)\r\nmemcpy(indio_dev->event_interface->group.attrs,\r\nindio_dev->info->event_attrs->attrs,\r\nsizeof(indio_dev->event_interface->group.attrs[0])\r\n*attrcount_orig);\r\nattrn = attrcount_orig;\r\nlist_for_each_entry(p,\r\n&indio_dev->event_interface->dev_attr_list,\r\nl)\r\nindio_dev->event_interface->group.attrs[attrn++] =\r\n&p->dev_attr.attr;\r\nindio_dev->groups[indio_dev->groupcounter++] =\r\n&indio_dev->event_interface->group;\r\nreturn 0;\r\nerror_free_setup_event_lines:\r\niio_free_chan_devattr_list(&indio_dev->event_interface->dev_attr_list);\r\nkfree(indio_dev->event_interface);\r\nindio_dev->event_interface = NULL;\r\nreturn ret;\r\n}\r\nvoid iio_device_wakeup_eventset(struct iio_dev *indio_dev)\r\n{\r\nif (indio_dev->event_interface == NULL)\r\nreturn;\r\nwake_up(&indio_dev->event_interface->wait);\r\n}\r\nvoid iio_device_unregister_eventset(struct iio_dev *indio_dev)\r\n{\r\nif (indio_dev->event_interface == NULL)\r\nreturn;\r\niio_free_chan_devattr_list(&indio_dev->event_interface->dev_attr_list);\r\nkfree(indio_dev->event_interface->group.attrs);\r\nkfree(indio_dev->event_interface);\r\n}
