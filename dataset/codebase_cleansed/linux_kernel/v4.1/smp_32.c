void smp_store_cpu_info(int id)\r\n{\r\nint cpu_node;\r\nint mid;\r\ncpu_data(id).udelay_val = loops_per_jiffy;\r\ncpu_find_by_mid(id, &cpu_node);\r\ncpu_data(id).clock_tick = prom_getintdefault(cpu_node,\r\n"clock-frequency", 0);\r\ncpu_data(id).prom_node = cpu_node;\r\nmid = cpu_get_hwmid(cpu_node);\r\nif (mid < 0) {\r\nprintk(KERN_NOTICE "No MID found for CPU%d at node 0x%08x", id, cpu_node);\r\nmid = 0;\r\n}\r\ncpu_data(id).mid = mid;\r\n}\r\nvoid __init smp_cpus_done(unsigned int max_cpus)\r\n{\r\nunsigned long bogosum = 0;\r\nint cpu, num = 0;\r\nfor_each_online_cpu(cpu) {\r\nnum++;\r\nbogosum += cpu_data(cpu).udelay_val;\r\n}\r\nprintk("Total of %d processors activated (%lu.%02lu BogoMIPS).\n",\r\nnum, bogosum/(500000/HZ),\r\n(bogosum/(5000/HZ))%100);\r\nswitch(sparc_cpu_model) {\r\ncase sun4m:\r\nsmp4m_smp_done();\r\nbreak;\r\ncase sun4d:\r\nsmp4d_smp_done();\r\nbreak;\r\ncase sparc_leon:\r\nleon_smp_done();\r\nbreak;\r\ncase sun4e:\r\nprintk("SUN4E\n");\r\nBUG();\r\nbreak;\r\ncase sun4u:\r\nprintk("SUN4U\n");\r\nBUG();\r\nbreak;\r\ndefault:\r\nprintk("UNKNOWN!\n");\r\nBUG();\r\nbreak;\r\n}\r\n}\r\nvoid cpu_panic(void)\r\n{\r\nprintk("CPU[%d]: Returns from cpu_idle!\n", smp_processor_id());\r\npanic("SMP bolixed\n");\r\n}\r\nvoid smp_send_reschedule(int cpu)\r\n{\r\nsparc32_ipi_ops->resched(cpu);\r\n}\r\nvoid smp_send_stop(void)\r\n{\r\n}\r\nvoid arch_send_call_function_single_ipi(int cpu)\r\n{\r\nsparc32_ipi_ops->single(cpu);\r\n}\r\nvoid arch_send_call_function_ipi_mask(const struct cpumask *mask)\r\n{\r\nint cpu;\r\nfor_each_cpu(cpu, mask)\r\nsparc32_ipi_ops->mask_one(cpu);\r\n}\r\nvoid smp_resched_interrupt(void)\r\n{\r\nirq_enter();\r\nscheduler_ipi();\r\nlocal_cpu_data().irq_resched_count++;\r\nirq_exit();\r\n}\r\nvoid smp_call_function_single_interrupt(void)\r\n{\r\nirq_enter();\r\ngeneric_smp_call_function_single_interrupt();\r\nlocal_cpu_data().irq_call_count++;\r\nirq_exit();\r\n}\r\nvoid smp_call_function_interrupt(void)\r\n{\r\nirq_enter();\r\ngeneric_smp_call_function_interrupt();\r\nlocal_cpu_data().irq_call_count++;\r\nirq_exit();\r\n}\r\nint setup_profiling_timer(unsigned int multiplier)\r\n{\r\nreturn -EINVAL;\r\n}\r\nvoid __init smp_prepare_cpus(unsigned int max_cpus)\r\n{\r\nint i, cpuid, extra;\r\nprintk("Entering SMP Mode...\n");\r\nextra = 0;\r\nfor (i = 0; !cpu_find_by_instance(i, NULL, &cpuid); i++) {\r\nif (cpuid >= NR_CPUS)\r\nextra++;\r\n}\r\nif (extra && max_cpus > i - extra)\r\nprintk("Warning: NR_CPUS is too low to start all cpus\n");\r\nsmp_store_cpu_info(boot_cpu_id);\r\nswitch(sparc_cpu_model) {\r\ncase sun4m:\r\nsmp4m_boot_cpus();\r\nbreak;\r\ncase sun4d:\r\nsmp4d_boot_cpus();\r\nbreak;\r\ncase sparc_leon:\r\nleon_boot_cpus();\r\nbreak;\r\ncase sun4e:\r\nprintk("SUN4E\n");\r\nBUG();\r\nbreak;\r\ncase sun4u:\r\nprintk("SUN4U\n");\r\nBUG();\r\nbreak;\r\ndefault:\r\nprintk("UNKNOWN!\n");\r\nBUG();\r\nbreak;\r\n}\r\n}\r\nvoid __init smp_setup_cpu_possible_map(void)\r\n{\r\nint instance, mid;\r\ninstance = 0;\r\nwhile (!cpu_find_by_instance(instance, NULL, &mid)) {\r\nif (mid < NR_CPUS) {\r\nset_cpu_possible(mid, true);\r\nset_cpu_present(mid, true);\r\n}\r\ninstance++;\r\n}\r\n}\r\nvoid __init smp_prepare_boot_cpu(void)\r\n{\r\nint cpuid = hard_smp_processor_id();\r\nif (cpuid >= NR_CPUS) {\r\nprom_printf("Serious problem, boot cpu id >= NR_CPUS\n");\r\nprom_halt();\r\n}\r\nif (cpuid != 0)\r\nprintk("boot cpu id != 0, this could work but is untested\n");\r\ncurrent_thread_info()->cpu = cpuid;\r\nset_cpu_online(cpuid, true);\r\nset_cpu_possible(cpuid, true);\r\n}\r\nint __cpu_up(unsigned int cpu, struct task_struct *tidle)\r\n{\r\nint ret=0;\r\nswitch(sparc_cpu_model) {\r\ncase sun4m:\r\nret = smp4m_boot_one_cpu(cpu, tidle);\r\nbreak;\r\ncase sun4d:\r\nret = smp4d_boot_one_cpu(cpu, tidle);\r\nbreak;\r\ncase sparc_leon:\r\nret = leon_boot_one_cpu(cpu, tidle);\r\nbreak;\r\ncase sun4e:\r\nprintk("SUN4E\n");\r\nBUG();\r\nbreak;\r\ncase sun4u:\r\nprintk("SUN4U\n");\r\nBUG();\r\nbreak;\r\ndefault:\r\nprintk("UNKNOWN!\n");\r\nBUG();\r\nbreak;\r\n}\r\nif (!ret) {\r\ncpumask_set_cpu(cpu, &smp_commenced_mask);\r\nwhile (!cpu_online(cpu))\r\nmb();\r\n}\r\nreturn ret;\r\n}\r\nstatic void arch_cpu_pre_starting(void *arg)\r\n{\r\nlocal_ops->cache_all();\r\nlocal_ops->tlb_all();\r\nswitch(sparc_cpu_model) {\r\ncase sun4m:\r\nsun4m_cpu_pre_starting(arg);\r\nbreak;\r\ncase sun4d:\r\nsun4d_cpu_pre_starting(arg);\r\nbreak;\r\ncase sparc_leon:\r\nleon_cpu_pre_starting(arg);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic void arch_cpu_pre_online(void *arg)\r\n{\r\nunsigned int cpuid = hard_smp_processor_id();\r\nregister_percpu_ce(cpuid);\r\ncalibrate_delay();\r\nsmp_store_cpu_info(cpuid);\r\nlocal_ops->cache_all();\r\nlocal_ops->tlb_all();\r\nswitch(sparc_cpu_model) {\r\ncase sun4m:\r\nsun4m_cpu_pre_online(arg);\r\nbreak;\r\ncase sun4d:\r\nsun4d_cpu_pre_online(arg);\r\nbreak;\r\ncase sparc_leon:\r\nleon_cpu_pre_online(arg);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic void sparc_start_secondary(void *arg)\r\n{\r\nunsigned int cpu;\r\narch_cpu_pre_starting(arg);\r\npreempt_disable();\r\ncpu = smp_processor_id();\r\nnotify_cpu_starting(cpu);\r\narch_cpu_pre_online(arg);\r\nset_cpu_online(cpu, true);\r\nlocal_irq_enable();\r\nwmb();\r\ncpu_startup_entry(CPUHP_ONLINE);\r\nBUG();\r\n}\r\nvoid smp_callin(void)\r\n{\r\nsparc_start_secondary(NULL);\r\n}\r\nvoid smp_bogo(struct seq_file *m)\r\n{\r\nint i;\r\nfor_each_online_cpu(i) {\r\nseq_printf(m,\r\n"Cpu%dBogo\t: %lu.%02lu\n",\r\ni,\r\ncpu_data(i).udelay_val/(500000/HZ),\r\n(cpu_data(i).udelay_val/(5000/HZ))%100);\r\n}\r\n}\r\nvoid smp_info(struct seq_file *m)\r\n{\r\nint i;\r\nseq_printf(m, "State:\n");\r\nfor_each_online_cpu(i)\r\nseq_printf(m, "CPU%d\t\t: online\n", i);\r\n}
