static u32 tvout_read(struct sti_tvout *tvout, int offset)\r\n{\r\nreturn readl(tvout->regs + offset);\r\n}\r\nstatic void tvout_write(struct sti_tvout *tvout, u32 val, int offset)\r\n{\r\nwritel(val, tvout->regs + offset);\r\n}\r\nstatic void tvout_vip_set_color_order(struct sti_tvout *tvout, int reg,\r\nu32 cr_r, u32 y_g, u32 cb_b)\r\n{\r\nu32 val = tvout_read(tvout, reg);\r\nval &= ~(TVO_VIP_REORDER_MASK << TVO_VIP_REORDER_R_SHIFT);\r\nval &= ~(TVO_VIP_REORDER_MASK << TVO_VIP_REORDER_G_SHIFT);\r\nval &= ~(TVO_VIP_REORDER_MASK << TVO_VIP_REORDER_B_SHIFT);\r\nval |= cr_r << TVO_VIP_REORDER_R_SHIFT;\r\nval |= y_g << TVO_VIP_REORDER_G_SHIFT;\r\nval |= cb_b << TVO_VIP_REORDER_B_SHIFT;\r\ntvout_write(tvout, val, reg);\r\n}\r\nstatic void tvout_vip_set_clip_mode(struct sti_tvout *tvout, int reg, u32 range)\r\n{\r\nu32 val = tvout_read(tvout, reg);\r\nval &= ~(TVO_VIP_CLIP_MASK << TVO_VIP_CLIP_SHIFT);\r\nval |= range << TVO_VIP_CLIP_SHIFT;\r\ntvout_write(tvout, val, reg);\r\n}\r\nstatic void tvout_vip_set_rnd(struct sti_tvout *tvout, int reg, u32 rnd)\r\n{\r\nu32 val = tvout_read(tvout, reg);\r\nval &= ~(TVO_VIP_RND_MASK << TVO_VIP_RND_SHIFT);\r\nval |= rnd << TVO_VIP_RND_SHIFT;\r\ntvout_write(tvout, val, reg);\r\n}\r\nstatic void tvout_vip_set_sel_input(struct sti_tvout *tvout,\r\nint reg,\r\nbool main_path,\r\nbool sel_input_logic_inverted,\r\nenum sti_tvout_video_out_type video_out)\r\n{\r\nu32 sel_input;\r\nu32 val = tvout_read(tvout, reg);\r\nif (main_path)\r\nsel_input = TVO_VIP_SEL_INPUT_MAIN;\r\nelse\r\nsel_input = TVO_VIP_SEL_INPUT_AUX;\r\nswitch (video_out) {\r\ncase STI_TVOUT_VIDEO_OUT_RGB:\r\nsel_input |= TVO_VIP_SEL_INPUT_BYPASSED;\r\nbreak;\r\ncase STI_TVOUT_VIDEO_OUT_YUV:\r\nsel_input &= ~TVO_VIP_SEL_INPUT_BYPASSED;\r\nbreak;\r\n}\r\nif (sel_input_logic_inverted)\r\nsel_input = sel_input ^ TVO_VIP_SEL_INPUT_BYPASS_MASK;\r\nval &= ~TVO_VIP_SEL_INPUT_MASK;\r\nval |= sel_input;\r\ntvout_write(tvout, val, reg);\r\n}\r\nstatic void tvout_vip_set_in_vid_fmt(struct sti_tvout *tvout,\r\nint reg, u32 in_vid_fmt)\r\n{\r\nu32 val = tvout_read(tvout, reg);\r\nval &= ~TVO_IN_FMT_SIGNED;\r\nval |= in_vid_fmt;\r\ntvout_write(tvout, val, reg);\r\n}\r\nstatic void tvout_dvo_start(struct sti_tvout *tvout, bool main_path)\r\n{\r\nstruct device_node *node = tvout->dev->of_node;\r\nbool sel_input_logic_inverted = false;\r\nu32 tvo_in_vid_format;\r\nint val;\r\ndev_dbg(tvout->dev, "%s\n", __func__);\r\nif (main_path) {\r\nDRM_DEBUG_DRIVER("main vip for DVO\n");\r\nval = TVO_SYNC_MAIN_VTG_SET_4 << TVO_SYNC_DVO_PAD_VSYNC_SHIFT;\r\nval |= TVO_SYNC_MAIN_VTG_SET_4 << TVO_SYNC_DVO_PAD_HSYNC_SHIFT;\r\nval |= TVO_SYNC_MAIN_VTG_SET_4;\r\ntvout_write(tvout, val, TVO_DVO_SYNC_SEL);\r\ntvo_in_vid_format = TVO_MAIN_IN_VID_FORMAT;\r\n} else {\r\nDRM_DEBUG_DRIVER("aux vip for DVO\n");\r\nval = TVO_SYNC_AUX_VTG_SET_4 << TVO_SYNC_DVO_PAD_VSYNC_SHIFT;\r\nval |= TVO_SYNC_AUX_VTG_SET_4 << TVO_SYNC_DVO_PAD_HSYNC_SHIFT;\r\nval |= TVO_SYNC_AUX_VTG_SET_4;\r\ntvout_write(tvout, val, TVO_DVO_SYNC_SEL);\r\ntvo_in_vid_format = TVO_AUX_IN_VID_FORMAT;\r\n}\r\ntvout_vip_set_color_order(tvout, TVO_VIP_DVO,\r\nTVO_VIP_REORDER_CR_R_SEL,\r\nTVO_VIP_REORDER_Y_G_SEL,\r\nTVO_VIP_REORDER_CB_B_SEL);\r\ntvout_vip_set_clip_mode(tvout, TVO_VIP_DVO,\r\nTVO_VIP_CLIP_LIMITED_RANGE_RGB_Y);\r\ntvout_vip_set_rnd(tvout, TVO_VIP_DVO, TVO_VIP_RND_8BIT_ROUNDED);\r\nif (of_device_is_compatible(node, "st,stih407-tvout")) {\r\ntvout_vip_set_in_vid_fmt(tvout, tvo_in_vid_format,\r\nTVO_IN_FMT_SIGNED);\r\nsel_input_logic_inverted = true;\r\n}\r\ntvout_vip_set_sel_input(tvout, TVO_VIP_DVO, main_path,\r\nsel_input_logic_inverted,\r\nSTI_TVOUT_VIDEO_OUT_RGB);\r\n}\r\nstatic void tvout_hdmi_start(struct sti_tvout *tvout, bool main_path)\r\n{\r\nstruct device_node *node = tvout->dev->of_node;\r\nbool sel_input_logic_inverted = false;\r\nu32 tvo_in_vid_format;\r\ndev_dbg(tvout->dev, "%s\n", __func__);\r\nif (main_path) {\r\nDRM_DEBUG_DRIVER("main vip for hdmi\n");\r\ntvout_write(tvout, TVO_SYNC_MAIN_VTG_SET_1, TVO_HDMI_SYNC_SEL);\r\ntvo_in_vid_format = TVO_MAIN_IN_VID_FORMAT;\r\n} else {\r\nDRM_DEBUG_DRIVER("aux vip for hdmi\n");\r\ntvout_write(tvout, TVO_SYNC_AUX_VTG_SET_1, TVO_HDMI_SYNC_SEL);\r\ntvo_in_vid_format = TVO_AUX_IN_VID_FORMAT;\r\n}\r\ntvout_vip_set_color_order(tvout, TVO_VIP_HDMI,\r\nTVO_VIP_REORDER_CR_R_SEL,\r\nTVO_VIP_REORDER_Y_G_SEL,\r\nTVO_VIP_REORDER_CB_B_SEL);\r\ntvout_vip_set_clip_mode(tvout, TVO_VIP_HDMI,\r\nTVO_VIP_CLIP_LIMITED_RANGE_RGB_Y);\r\ntvout_vip_set_rnd(tvout, TVO_VIP_HDMI, TVO_VIP_RND_8BIT_ROUNDED);\r\nif (of_device_is_compatible(node, "st,stih407-tvout")) {\r\ntvout_vip_set_in_vid_fmt(tvout, tvo_in_vid_format,\r\nTVO_IN_FMT_SIGNED);\r\nsel_input_logic_inverted = true;\r\n}\r\ntvout_vip_set_sel_input(tvout, TVO_VIP_HDMI, main_path,\r\nsel_input_logic_inverted, STI_TVOUT_VIDEO_OUT_RGB);\r\n}\r\nstatic void tvout_hda_start(struct sti_tvout *tvout, bool main_path)\r\n{\r\nstruct device_node *node = tvout->dev->of_node;\r\nbool sel_input_logic_inverted = false;\r\nu32 tvo_in_vid_format;\r\nint val;\r\ndev_dbg(tvout->dev, "%s\n", __func__);\r\nif (main_path) {\r\nval = TVO_SYNC_MAIN_VTG_SET_2 << TVO_SYNC_HD_DCS_SHIFT;\r\nval |= TVO_SYNC_MAIN_VTG_SET_3;\r\ntvout_write(tvout, val, TVO_HD_SYNC_SEL);\r\ntvo_in_vid_format = TVO_MAIN_IN_VID_FORMAT;\r\n} else {\r\nval = TVO_SYNC_AUX_VTG_SET_2 << TVO_SYNC_HD_DCS_SHIFT;\r\nval |= TVO_SYNC_AUX_VTG_SET_3;\r\ntvout_write(tvout, val, TVO_HD_SYNC_SEL);\r\ntvo_in_vid_format = TVO_AUX_IN_VID_FORMAT;\r\n}\r\ntvout_vip_set_color_order(tvout, TVO_VIP_HDF,\r\nTVO_VIP_REORDER_CR_R_SEL,\r\nTVO_VIP_REORDER_Y_G_SEL,\r\nTVO_VIP_REORDER_CB_B_SEL);\r\ntvout_vip_set_clip_mode(tvout, TVO_VIP_HDF, TVO_VIP_CLIP_EAV_SAV);\r\ntvout_vip_set_rnd(tvout, TVO_VIP_HDF, TVO_VIP_RND_10BIT_ROUNDED);\r\nif (of_device_is_compatible(node, "st,stih407-tvout")) {\r\ntvout_vip_set_in_vid_fmt(tvout,\r\ntvo_in_vid_format, TVO_IN_FMT_SIGNED);\r\nsel_input_logic_inverted = true;\r\n}\r\ntvout_vip_set_sel_input(tvout, TVO_VIP_HDF, main_path,\r\nsel_input_logic_inverted,\r\nSTI_TVOUT_VIDEO_OUT_YUV);\r\ntvout_write(tvout, 0, TVO_HD_DAC_CFG_OFF);\r\n}\r\nstatic void sti_tvout_encoder_dpms(struct drm_encoder *encoder, int mode)\r\n{\r\n}\r\nstatic bool sti_tvout_encoder_mode_fixup(struct drm_encoder *encoder,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nreturn true;\r\n}\r\nstatic void sti_tvout_encoder_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\n}\r\nstatic void sti_tvout_encoder_prepare(struct drm_encoder *encoder)\r\n{\r\n}\r\nstatic void sti_tvout_encoder_destroy(struct drm_encoder *encoder)\r\n{\r\nstruct sti_tvout_encoder *sti_encoder = to_sti_tvout_encoder(encoder);\r\ndrm_encoder_cleanup(encoder);\r\nkfree(sti_encoder);\r\n}\r\nstatic void sti_dvo_encoder_commit(struct drm_encoder *encoder)\r\n{\r\nstruct sti_tvout *tvout = to_sti_tvout(encoder);\r\ntvout_dvo_start(tvout, sti_drm_crtc_is_main(encoder->crtc));\r\n}\r\nstatic void sti_dvo_encoder_disable(struct drm_encoder *encoder)\r\n{\r\nstruct sti_tvout *tvout = to_sti_tvout(encoder);\r\ntvout_write(tvout, 0x0, TVO_VIP_DVO);\r\n}\r\nstatic struct drm_encoder *\r\nsti_tvout_create_dvo_encoder(struct drm_device *dev,\r\nstruct sti_tvout *tvout)\r\n{\r\nstruct sti_tvout_encoder *encoder;\r\nstruct drm_encoder *drm_encoder;\r\nencoder = devm_kzalloc(tvout->dev, sizeof(*encoder), GFP_KERNEL);\r\nif (!encoder)\r\nreturn NULL;\r\nencoder->tvout = tvout;\r\ndrm_encoder = (struct drm_encoder *)encoder;\r\ndrm_encoder->possible_crtcs = ENCODER_CRTC_MASK;\r\ndrm_encoder->possible_clones = 1 << 0;\r\ndrm_encoder_init(dev, drm_encoder,\r\n&sti_tvout_encoder_funcs, DRM_MODE_ENCODER_LVDS);\r\ndrm_encoder_helper_add(drm_encoder, &sti_dvo_encoder_helper_funcs);\r\nreturn drm_encoder;\r\n}\r\nstatic void sti_hda_encoder_commit(struct drm_encoder *encoder)\r\n{\r\nstruct sti_tvout *tvout = to_sti_tvout(encoder);\r\ntvout_hda_start(tvout, sti_drm_crtc_is_main(encoder->crtc));\r\n}\r\nstatic void sti_hda_encoder_disable(struct drm_encoder *encoder)\r\n{\r\nstruct sti_tvout *tvout = to_sti_tvout(encoder);\r\ntvout_write(tvout, 0x0, TVO_VIP_HDF);\r\ntvout_write(tvout, 1, TVO_HD_DAC_CFG_OFF);\r\n}\r\nstatic struct drm_encoder *sti_tvout_create_hda_encoder(struct drm_device *dev,\r\nstruct sti_tvout *tvout)\r\n{\r\nstruct sti_tvout_encoder *encoder;\r\nstruct drm_encoder *drm_encoder;\r\nencoder = devm_kzalloc(tvout->dev, sizeof(*encoder), GFP_KERNEL);\r\nif (!encoder)\r\nreturn NULL;\r\nencoder->tvout = tvout;\r\ndrm_encoder = (struct drm_encoder *) encoder;\r\ndrm_encoder->possible_crtcs = ENCODER_CRTC_MASK;\r\ndrm_encoder->possible_clones = 1 << 0;\r\ndrm_encoder_init(dev, drm_encoder,\r\n&sti_tvout_encoder_funcs, DRM_MODE_ENCODER_DAC);\r\ndrm_encoder_helper_add(drm_encoder, &sti_hda_encoder_helper_funcs);\r\nreturn drm_encoder;\r\n}\r\nstatic void sti_hdmi_encoder_commit(struct drm_encoder *encoder)\r\n{\r\nstruct sti_tvout *tvout = to_sti_tvout(encoder);\r\ntvout_hdmi_start(tvout, sti_drm_crtc_is_main(encoder->crtc));\r\n}\r\nstatic void sti_hdmi_encoder_disable(struct drm_encoder *encoder)\r\n{\r\nstruct sti_tvout *tvout = to_sti_tvout(encoder);\r\ntvout_write(tvout, 0x0, TVO_VIP_HDMI);\r\n}\r\nstatic struct drm_encoder *sti_tvout_create_hdmi_encoder(struct drm_device *dev,\r\nstruct sti_tvout *tvout)\r\n{\r\nstruct sti_tvout_encoder *encoder;\r\nstruct drm_encoder *drm_encoder;\r\nencoder = devm_kzalloc(tvout->dev, sizeof(*encoder), GFP_KERNEL);\r\nif (!encoder)\r\nreturn NULL;\r\nencoder->tvout = tvout;\r\ndrm_encoder = (struct drm_encoder *) encoder;\r\ndrm_encoder->possible_crtcs = ENCODER_CRTC_MASK;\r\ndrm_encoder->possible_clones = 1 << 1;\r\ndrm_encoder_init(dev, drm_encoder,\r\n&sti_tvout_encoder_funcs, DRM_MODE_ENCODER_TMDS);\r\ndrm_encoder_helper_add(drm_encoder, &sti_hdmi_encoder_helper_funcs);\r\nreturn drm_encoder;\r\n}\r\nstatic void sti_tvout_create_encoders(struct drm_device *dev,\r\nstruct sti_tvout *tvout)\r\n{\r\ntvout->hdmi = sti_tvout_create_hdmi_encoder(dev, tvout);\r\ntvout->hda = sti_tvout_create_hda_encoder(dev, tvout);\r\ntvout->dvo = sti_tvout_create_dvo_encoder(dev, tvout);\r\n}\r\nstatic void sti_tvout_destroy_encoders(struct sti_tvout *tvout)\r\n{\r\nif (tvout->hdmi)\r\ndrm_encoder_cleanup(tvout->hdmi);\r\ntvout->hdmi = NULL;\r\nif (tvout->hda)\r\ndrm_encoder_cleanup(tvout->hda);\r\ntvout->hda = NULL;\r\n}\r\nstatic int sti_tvout_bind(struct device *dev, struct device *master, void *data)\r\n{\r\nstruct sti_tvout *tvout = dev_get_drvdata(dev);\r\nstruct drm_device *drm_dev = data;\r\nunsigned int i;\r\nint ret;\r\ntvout->drm_dev = drm_dev;\r\nfor (i = 0; i < 8; i++) {\r\ntvout_write(tvout, rgb_to_ycbcr_601[i],\r\nTVO_CSC_MAIN_M0 + (i * 4));\r\ntvout_write(tvout, rgb_to_ycbcr_601[i],\r\nTVO_CSC_AUX_M0 + (i * 4));\r\n}\r\nsti_tvout_create_encoders(drm_dev, tvout);\r\nret = component_bind_all(dev, drm_dev);\r\nif (ret)\r\nsti_tvout_destroy_encoders(tvout);\r\nreturn ret;\r\n}\r\nstatic void sti_tvout_unbind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\n}\r\nstatic int compare_of(struct device *dev, void *data)\r\n{\r\nreturn dev->of_node == data;\r\n}\r\nstatic int sti_tvout_master_bind(struct device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic void sti_tvout_master_unbind(struct device *dev)\r\n{\r\n}\r\nstatic int sti_tvout_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *node = dev->of_node;\r\nstruct sti_tvout *tvout;\r\nstruct resource *res;\r\nstruct device_node *child_np;\r\nstruct component_match *match = NULL;\r\nDRM_INFO("%s\n", __func__);\r\nif (!node)\r\nreturn -ENODEV;\r\ntvout = devm_kzalloc(dev, sizeof(*tvout), GFP_KERNEL);\r\nif (!tvout)\r\nreturn -ENOMEM;\r\ntvout->dev = dev;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "tvout-reg");\r\nif (!res) {\r\nDRM_ERROR("Invalid glue resource\n");\r\nreturn -ENOMEM;\r\n}\r\ntvout->regs = devm_ioremap_nocache(dev, res->start, resource_size(res));\r\nif (!tvout->regs)\r\nreturn -ENOMEM;\r\ntvout->reset = devm_reset_control_get(dev, "tvout");\r\nif (!IS_ERR(tvout->reset))\r\nreset_control_deassert(tvout->reset);\r\nplatform_set_drvdata(pdev, tvout);\r\nof_platform_populate(node, NULL, NULL, dev);\r\nchild_np = of_get_next_available_child(node, NULL);\r\nwhile (child_np) {\r\ncomponent_match_add(dev, &match, compare_of, child_np);\r\nof_node_put(child_np);\r\nchild_np = of_get_next_available_child(node, child_np);\r\n}\r\ncomponent_master_add_with_match(dev, &sti_tvout_master_ops, match);\r\nreturn component_add(dev, &sti_tvout_ops);\r\n}\r\nstatic int sti_tvout_remove(struct platform_device *pdev)\r\n{\r\ncomponent_master_del(&pdev->dev, &sti_tvout_master_ops);\r\ncomponent_del(&pdev->dev, &sti_tvout_ops);\r\nreturn 0;\r\n}
