static void check_and_wakeup_reader(struct smd_pkt_dev *smd_pkt_devp)\r\n{\r\nint sz;\r\nif (!smd_pkt_devp || !smd_pkt_devp->ch)\r\nreturn;\r\nsz = smd_cur_packet_size(smd_pkt_devp->ch);\r\nif (sz == 0) {\r\nDBG("no packet\n");\r\nreturn;\r\n}\r\nif (sz > smd_read_avail(smd_pkt_devp->ch)) {\r\nDBG("incomplete packet\n");\r\nreturn;\r\n}\r\nDBG("waking up reader\n");\r\nwake_up_interruptible(&smd_pkt_devp->ch_read_wait_queue);\r\n}\r\nstatic int smd_pkt_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nint r, bytes_read;\r\nstruct smd_pkt_dev *smd_pkt_devp;\r\nstruct smd_channel *chl;\r\nDBG("read %d bytes\n", count);\r\nif (count > MAX_BUF_SIZE)\r\nreturn -EINVAL;\r\nsmd_pkt_devp = file->private_data;\r\nif (!smd_pkt_devp || !smd_pkt_devp->ch)\r\nreturn -EINVAL;\r\nchl = smd_pkt_devp->ch;\r\nwait_for_packet:\r\nr = wait_event_interruptible(smd_pkt_devp->ch_read_wait_queue,\r\n(smd_cur_packet_size(chl) > 0 &&\r\nsmd_read_avail(chl) >=\r\nsmd_cur_packet_size(chl)));\r\nif (r < 0) {\r\nif (r != -ERESTARTSYS)\r\npr_err("wait returned %d\n", r);\r\nreturn r;\r\n}\r\nmutex_lock(&smd_pkt_devp->rx_lock);\r\nbytes_read = smd_cur_packet_size(smd_pkt_devp->ch);\r\nif (bytes_read == 0 ||\r\nbytes_read < smd_read_avail(smd_pkt_devp->ch)) {\r\nmutex_unlock(&smd_pkt_devp->rx_lock);\r\nDBG("Nothing to read\n");\r\ngoto wait_for_packet;\r\n}\r\nif (bytes_read > count) {\r\nmutex_unlock(&smd_pkt_devp->rx_lock);\r\npr_info("packet size %d > buffer size %d", bytes_read, count);\r\nreturn -EINVAL;\r\n}\r\nr = smd_read(smd_pkt_devp->ch, smd_pkt_devp->rx_buf, bytes_read);\r\nif (r != bytes_read) {\r\nmutex_unlock(&smd_pkt_devp->rx_lock);\r\npr_err("smd_read failed to read %d bytes: %d\n", bytes_read, r);\r\nreturn -EIO;\r\n}\r\nD_DUMP_BUFFER("read: ", bytes_read, smd_pkt_devp->rx_buf);\r\nr = copy_to_user(buf, smd_pkt_devp->rx_buf, bytes_read);\r\nmutex_unlock(&smd_pkt_devp->rx_lock);\r\nif (r) {\r\npr_err("copy_to_user failed %d\n", r);\r\nreturn -EFAULT;\r\n}\r\nDBG("read complete %d bytes\n", bytes_read);\r\ncheck_and_wakeup_reader(smd_pkt_devp);\r\nreturn bytes_read;\r\n}\r\nstatic int smd_pkt_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nint r;\r\nstruct smd_pkt_dev *smd_pkt_devp;\r\nif (count > MAX_BUF_SIZE)\r\nreturn -EINVAL;\r\nDBG("writing %d bytes\n", count);\r\nsmd_pkt_devp = file->private_data;\r\nif (!smd_pkt_devp || !smd_pkt_devp->ch)\r\nreturn -EINVAL;\r\nmutex_lock(&smd_pkt_devp->tx_lock);\r\nif (smd_write_avail(smd_pkt_devp->ch) < count) {\r\nmutex_unlock(&smd_pkt_devp->tx_lock);\r\nDBG("Not enough space to write\n");\r\nreturn -ENOMEM;\r\n}\r\nD_DUMP_BUFFER("write: ", count, buf);\r\nr = copy_from_user(smd_pkt_devp->tx_buf, buf, count);\r\nif (r) {\r\nmutex_unlock(&smd_pkt_devp->tx_lock);\r\npr_err("copy_from_user failed %d\n", r);\r\nreturn -EFAULT;\r\n}\r\nr = smd_write(smd_pkt_devp->ch, smd_pkt_devp->tx_buf, count);\r\nif (r != count) {\r\nmutex_unlock(&smd_pkt_devp->tx_lock);\r\npr_err("smd_write failed to write %d bytes: %d.\n", count, r);\r\nreturn -EIO;\r\n}\r\nmutex_unlock(&smd_pkt_devp->tx_lock);\r\nDBG("wrote %d bytes\n", count);\r\nreturn count;\r\n}\r\nstatic unsigned int smd_pkt_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct smd_pkt_dev *smd_pkt_devp;\r\nunsigned int mask = 0;\r\nsmd_pkt_devp = file->private_data;\r\nif (!smd_pkt_devp)\r\nreturn POLLERR;\r\nDBG("poll waiting\n");\r\npoll_wait(file, &smd_pkt_devp->ch_read_wait_queue, wait);\r\nif (smd_read_avail(smd_pkt_devp->ch))\r\nmask |= POLLIN | POLLRDNORM;\r\nDBG("poll return\n");\r\nreturn mask;\r\n}\r\nstatic void smd_pkt_ch_notify(void *priv, unsigned event)\r\n{\r\nstruct smd_pkt_dev *smd_pkt_devp = priv;\r\nif (smd_pkt_devp->ch == 0)\r\nreturn;\r\nswitch (event) {\r\ncase SMD_EVENT_DATA:\r\nDBG("data\n");\r\ncheck_and_wakeup_reader(smd_pkt_devp);\r\nbreak;\r\ncase SMD_EVENT_OPEN:\r\nDBG("remote open\n");\r\nsmd_pkt_devp->remote_open = 1;\r\nwake_up_interruptible(&smd_pkt_devp->ch_opened_wait_queue);\r\nbreak;\r\ncase SMD_EVENT_CLOSE:\r\nsmd_pkt_devp->remote_open = 0;\r\npr_info("remote closed\n");\r\nbreak;\r\ndefault:\r\npr_err("unknown event %d\n", event);\r\nbreak;\r\n}\r\n}\r\nstatic int smd_pkt_open(struct inode *inode, struct file *file)\r\n{\r\nint r = 0;\r\nstruct smd_pkt_dev *smd_pkt_devp;\r\nsmd_pkt_devp = container_of(inode->i_cdev, struct smd_pkt_dev, cdev);\r\nif (!smd_pkt_devp)\r\nreturn -EINVAL;\r\nfile->private_data = smd_pkt_devp;\r\nmutex_lock(&smd_pkt_devp->ch_lock);\r\nif (smd_pkt_devp->open_count == 0) {\r\nr = smd_open(smd_ch_name[smd_pkt_devp->i],\r\n&smd_pkt_devp->ch, smd_pkt_devp,\r\nsmd_pkt_ch_notify);\r\nif (r < 0) {\r\npr_err("smd_open failed for %s, %d\n",\r\nsmd_ch_name[smd_pkt_devp->i], r);\r\ngoto out;\r\n}\r\nr = wait_event_interruptible_timeout(\r\nsmd_pkt_devp->ch_opened_wait_queue,\r\nsmd_pkt_devp->remote_open,\r\nmsecs_to_jiffies(2 * HZ));\r\nif (r == 0)\r\nr = -ETIMEDOUT;\r\nif (r < 0) {\r\npr_err("wait returned %d\n", r);\r\nsmd_close(smd_pkt_devp->ch);\r\nsmd_pkt_devp->ch = 0;\r\n} else {\r\nsmd_pkt_devp->open_count++;\r\nr = 0;\r\n}\r\n}\r\nout:\r\nmutex_unlock(&smd_pkt_devp->ch_lock);\r\nreturn r;\r\n}\r\nstatic int smd_pkt_release(struct inode *inode, struct file *file)\r\n{\r\nint r = 0;\r\nstruct smd_pkt_dev *smd_pkt_devp = file->private_data;\r\nif (!smd_pkt_devp)\r\nreturn -EINVAL;\r\nmutex_lock(&smd_pkt_devp->ch_lock);\r\nif (--smd_pkt_devp->open_count == 0) {\r\nr = smd_close(smd_pkt_devp->ch);\r\nsmd_pkt_devp->ch = 0;\r\n}\r\nmutex_unlock(&smd_pkt_devp->ch_lock);\r\nreturn r;\r\n}\r\nstatic int __init smd_pkt_init(void)\r\n{\r\nint i;\r\nint r;\r\nr = alloc_chrdev_region(&smd_pkt_number, 0,\r\nNUM_SMD_PKT_PORTS, DEVICE_NAME);\r\nif (r) {\r\npr_err("alloc_chrdev_region() failed %d\n", r);\r\nreturn r;\r\n}\r\nsmd_pkt_classp = class_create(THIS_MODULE, DEVICE_NAME);\r\nif (IS_ERR(smd_pkt_classp)) {\r\nr = PTR_ERR(smd_pkt_classp);\r\npr_err("class_create() failed %d\n", r);\r\ngoto unreg_chardev;\r\n}\r\nfor (i = 0; i < NUM_SMD_PKT_PORTS; ++i) {\r\nsmd_pkt_devp[i] = kzalloc(sizeof(struct smd_pkt_dev),\r\nGFP_KERNEL);\r\nif (!smd_pkt_devp[i]) {\r\npr_err("kmalloc() failed\n");\r\ngoto clean_cdevs;\r\n}\r\nsmd_pkt_devp[i]->i = i;\r\ninit_waitqueue_head(&smd_pkt_devp[i]->ch_read_wait_queue);\r\nsmd_pkt_devp[i]->remote_open = 0;\r\ninit_waitqueue_head(&smd_pkt_devp[i]->ch_opened_wait_queue);\r\nmutex_init(&smd_pkt_devp[i]->ch_lock);\r\nmutex_init(&smd_pkt_devp[i]->rx_lock);\r\nmutex_init(&smd_pkt_devp[i]->tx_lock);\r\ncdev_init(&smd_pkt_devp[i]->cdev, &smd_pkt_fops);\r\nsmd_pkt_devp[i]->cdev.owner = THIS_MODULE;\r\nr = cdev_add(&smd_pkt_devp[i]->cdev,\r\n(smd_pkt_number + i), 1);\r\nif (r) {\r\npr_err("cdev_add() failed %d\n", r);\r\nkfree(smd_pkt_devp[i]);\r\ngoto clean_cdevs;\r\n}\r\nsmd_pkt_devp[i]->devicep =\r\ndevice_create(smd_pkt_classp, NULL,\r\n(smd_pkt_number + i), NULL,\r\nsmd_pkt_dev_name[i]);\r\nif (IS_ERR(smd_pkt_devp[i]->devicep)) {\r\nr = PTR_ERR(smd_pkt_devp[i]->devicep);\r\npr_err("device_create() failed %d\n", r);\r\ncdev_del(&smd_pkt_devp[i]->cdev);\r\nkfree(smd_pkt_devp[i]);\r\ngoto clean_cdevs;\r\n}\r\n}\r\npr_info("SMD Packet Port Driver Initialized.\n");\r\nreturn 0;\r\nclean_cdevs:\r\nif (i > 0) {\r\nwhile (--i >= 0) {\r\nmutex_destroy(&smd_pkt_devp[i]->ch_lock);\r\nmutex_destroy(&smd_pkt_devp[i]->rx_lock);\r\nmutex_destroy(&smd_pkt_devp[i]->tx_lock);\r\ncdev_del(&smd_pkt_devp[i]->cdev);\r\nkfree(smd_pkt_devp[i]);\r\ndevice_destroy(smd_pkt_classp,\r\nMKDEV(MAJOR(smd_pkt_number), i));\r\n}\r\n}\r\nclass_destroy(smd_pkt_classp);\r\nunreg_chardev:\r\nunregister_chrdev_region(MAJOR(smd_pkt_number), NUM_SMD_PKT_PORTS);\r\nreturn r;\r\n}\r\nstatic void __exit smd_pkt_cleanup(void)\r\n{\r\nint i;\r\nfor (i = 0; i < NUM_SMD_PKT_PORTS; ++i) {\r\nmutex_destroy(&smd_pkt_devp[i]->ch_lock);\r\nmutex_destroy(&smd_pkt_devp[i]->rx_lock);\r\nmutex_destroy(&smd_pkt_devp[i]->tx_lock);\r\ncdev_del(&smd_pkt_devp[i]->cdev);\r\nkfree(smd_pkt_devp[i]);\r\ndevice_destroy(smd_pkt_classp,\r\nMKDEV(MAJOR(smd_pkt_number), i));\r\n}\r\nclass_destroy(smd_pkt_classp);\r\nunregister_chrdev_region(MAJOR(smd_pkt_number), NUM_SMD_PKT_PORTS);\r\n}
