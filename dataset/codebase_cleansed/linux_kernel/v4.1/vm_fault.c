void do_page_fault(unsigned long address, long cause, struct pt_regs *regs)\r\n{\r\nstruct vm_area_struct *vma;\r\nstruct mm_struct *mm = current->mm;\r\nsiginfo_t info;\r\nint si_code = SEGV_MAPERR;\r\nint fault;\r\nconst struct exception_table_entry *fixup;\r\nunsigned int flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE;\r\nif (unlikely(in_interrupt() || !mm))\r\ngoto no_context;\r\nlocal_irq_enable();\r\nif (user_mode(regs))\r\nflags |= FAULT_FLAG_USER;\r\nretry:\r\ndown_read(&mm->mmap_sem);\r\nvma = find_vma(mm, address);\r\nif (!vma)\r\ngoto bad_area;\r\nif (vma->vm_start <= address)\r\ngoto good_area;\r\nif (!(vma->vm_flags & VM_GROWSDOWN))\r\ngoto bad_area;\r\nif (expand_stack(vma, address))\r\ngoto bad_area;\r\ngood_area:\r\nsi_code = SEGV_ACCERR;\r\nswitch (cause) {\r\ncase FLT_IFETCH:\r\nif (!(vma->vm_flags & VM_EXEC))\r\ngoto bad_area;\r\nbreak;\r\ncase FLT_LOAD:\r\nif (!(vma->vm_flags & VM_READ))\r\ngoto bad_area;\r\nbreak;\r\ncase FLT_STORE:\r\nif (!(vma->vm_flags & VM_WRITE))\r\ngoto bad_area;\r\nflags |= FAULT_FLAG_WRITE;\r\nbreak;\r\n}\r\nfault = handle_mm_fault(mm, vma, address, flags);\r\nif ((fault & VM_FAULT_RETRY) && fatal_signal_pending(current))\r\nreturn;\r\nif (likely(!(fault & VM_FAULT_ERROR))) {\r\nif (flags & FAULT_FLAG_ALLOW_RETRY) {\r\nif (fault & VM_FAULT_MAJOR)\r\ncurrent->maj_flt++;\r\nelse\r\ncurrent->min_flt++;\r\nif (fault & VM_FAULT_RETRY) {\r\nflags &= ~FAULT_FLAG_ALLOW_RETRY;\r\nflags |= FAULT_FLAG_TRIED;\r\ngoto retry;\r\n}\r\n}\r\nup_read(&mm->mmap_sem);\r\nreturn;\r\n}\r\nup_read(&mm->mmap_sem);\r\nif (!user_mode(regs))\r\ngoto no_context;\r\nif (fault & VM_FAULT_OOM) {\r\npagefault_out_of_memory();\r\nreturn;\r\n}\r\nif (fault & VM_FAULT_SIGBUS) {\r\ninfo.si_signo = SIGBUS;\r\ninfo.si_code = BUS_ADRERR;\r\n}\r\nelse {\r\ninfo.si_signo = SIGSEGV;\r\ninfo.si_code = SEGV_ACCERR;\r\n}\r\ninfo.si_errno = 0;\r\ninfo.si_addr = (void __user *)address;\r\nforce_sig_info(info.si_signo, &info, current);\r\nreturn;\r\nbad_area:\r\nup_read(&mm->mmap_sem);\r\nif (user_mode(regs)) {\r\ninfo.si_signo = SIGSEGV;\r\ninfo.si_errno = 0;\r\ninfo.si_code = si_code;\r\ninfo.si_addr = (void *)address;\r\nforce_sig_info(info.si_signo, &info, current);\r\nreturn;\r\n}\r\nno_context:\r\nfixup = search_exception_tables(pt_elr(regs));\r\nif (fixup) {\r\npt_set_elr(regs, fixup->fixup);\r\nreturn;\r\n}\r\nbust_spinlocks(1);\r\nprintk(KERN_EMERG "Unable to handle kernel paging request at "\r\n"virtual address 0x%08lx, regs %p\n", address, regs);\r\ndie("Bad Kernel VA", regs, SIGKILL);\r\n}\r\nvoid read_protection_fault(struct pt_regs *regs)\r\n{\r\nunsigned long badvadr = pt_badva(regs);\r\ndo_page_fault(badvadr, FLT_LOAD, regs);\r\n}\r\nvoid write_protection_fault(struct pt_regs *regs)\r\n{\r\nunsigned long badvadr = pt_badva(regs);\r\ndo_page_fault(badvadr, FLT_STORE, regs);\r\n}\r\nvoid execute_protection_fault(struct pt_regs *regs)\r\n{\r\nunsigned long badvadr = pt_badva(regs);\r\ndo_page_fault(badvadr, FLT_IFETCH, regs);\r\n}
