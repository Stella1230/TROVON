static void iwl_mvm_enter_ctkill(struct iwl_mvm *mvm)\r\n{\r\nstruct iwl_mvm_tt_mgmt *tt = &mvm->thermal_throttle;\r\nu32 duration = mvm->thermal_throttle.params->ct_kill_duration;\r\nif (test_bit(IWL_MVM_STATUS_HW_CTKILL, &mvm->status))\r\nreturn;\r\nIWL_ERR(mvm, "Enter CT Kill\n");\r\niwl_mvm_set_hw_ctkill_state(mvm, true);\r\ntt->throttle = false;\r\ntt->dynamic_smps = false;\r\nif (!mvm->temperature_test)\r\nschedule_delayed_work(&tt->ct_kill_exit,\r\nround_jiffies_relative(duration * HZ));\r\n}\r\nstatic void iwl_mvm_exit_ctkill(struct iwl_mvm *mvm)\r\n{\r\nif (!test_bit(IWL_MVM_STATUS_HW_CTKILL, &mvm->status))\r\nreturn;\r\nIWL_ERR(mvm, "Exit CT Kill\n");\r\niwl_mvm_set_hw_ctkill_state(mvm, false);\r\n}\r\nvoid iwl_mvm_tt_temp_changed(struct iwl_mvm *mvm, u32 temp)\r\n{\r\nif (mvm->temperature_test)\r\nreturn;\r\nif (mvm->temperature == temp)\r\nreturn;\r\nmvm->temperature = temp;\r\niwl_mvm_tt_handler(mvm);\r\n}\r\nstatic int iwl_mvm_temp_notif_parse(struct iwl_mvm *mvm,\r\nstruct iwl_rx_packet *pkt)\r\n{\r\nstruct iwl_dts_measurement_notif *notif;\r\nint len = iwl_rx_packet_payload_len(pkt);\r\nint temp;\r\nif (WARN_ON_ONCE(len != sizeof(*notif))) {\r\nIWL_ERR(mvm, "Invalid DTS_MEASUREMENT_NOTIFICATION\n");\r\nreturn -EINVAL;\r\n}\r\nnotif = (void *)pkt->data;\r\ntemp = le32_to_cpu(notif->temp);\r\nif (WARN_ON_ONCE(temp < 0))\r\ntemp = 0;\r\nIWL_DEBUG_TEMP(mvm, "DTS_MEASUREMENT_NOTIFICATION - %d\n", temp);\r\nreturn temp;\r\n}\r\nstatic bool iwl_mvm_temp_notif_wait(struct iwl_notif_wait_data *notif_wait,\r\nstruct iwl_rx_packet *pkt, void *data)\r\n{\r\nstruct iwl_mvm *mvm =\r\ncontainer_of(notif_wait, struct iwl_mvm, notif_wait);\r\nint *temp = data;\r\nint ret;\r\nret = iwl_mvm_temp_notif_parse(mvm, pkt);\r\nif (ret < 0)\r\nreturn true;\r\n*temp = ret;\r\nreturn true;\r\n}\r\nint iwl_mvm_temp_notif(struct iwl_mvm *mvm,\r\nstruct iwl_rx_cmd_buffer *rxb,\r\nstruct iwl_device_cmd *cmd)\r\n{\r\nstruct iwl_rx_packet *pkt = rxb_addr(rxb);\r\nint temp;\r\nif (test_bit(IWL_MVM_STATUS_HW_CTKILL, &mvm->status))\r\nreturn 0;\r\ntemp = iwl_mvm_temp_notif_parse(mvm, pkt);\r\nif (temp < 0)\r\nreturn 0;\r\niwl_mvm_tt_temp_changed(mvm, temp);\r\nreturn 0;\r\n}\r\nstatic int iwl_mvm_get_temp_cmd(struct iwl_mvm *mvm)\r\n{\r\nstruct iwl_dts_measurement_cmd cmd = {\r\n.flags = cpu_to_le32(DTS_TRIGGER_CMD_FLAGS_TEMP),\r\n};\r\nreturn iwl_mvm_send_cmd_pdu(mvm, CMD_DTS_MEASUREMENT_TRIGGER, 0,\r\nsizeof(cmd), &cmd);\r\n}\r\nint iwl_mvm_get_temp(struct iwl_mvm *mvm)\r\n{\r\nstruct iwl_notification_wait wait_temp_notif;\r\nstatic const u8 temp_notif[] = { DTS_MEASUREMENT_NOTIFICATION };\r\nint ret, temp;\r\nlockdep_assert_held(&mvm->mutex);\r\niwl_init_notification_wait(&mvm->notif_wait, &wait_temp_notif,\r\ntemp_notif, ARRAY_SIZE(temp_notif),\r\niwl_mvm_temp_notif_wait, &temp);\r\nret = iwl_mvm_get_temp_cmd(mvm);\r\nif (ret) {\r\nIWL_ERR(mvm, "Failed to get the temperature (err=%d)\n", ret);\r\niwl_remove_notification(&mvm->notif_wait, &wait_temp_notif);\r\nreturn ret;\r\n}\r\nret = iwl_wait_notification(&mvm->notif_wait, &wait_temp_notif,\r\nIWL_MVM_TEMP_NOTIF_WAIT_TIMEOUT);\r\nif (ret) {\r\nIWL_ERR(mvm, "Getting the temperature timed out\n");\r\nreturn ret;\r\n}\r\nreturn temp;\r\n}\r\nstatic void check_exit_ctkill(struct work_struct *work)\r\n{\r\nstruct iwl_mvm_tt_mgmt *tt;\r\nstruct iwl_mvm *mvm;\r\nu32 duration;\r\ns32 temp;\r\ntt = container_of(work, struct iwl_mvm_tt_mgmt, ct_kill_exit.work);\r\nmvm = container_of(tt, struct iwl_mvm, thermal_throttle);\r\nduration = tt->params->ct_kill_duration;\r\nmutex_lock(&mvm->mutex);\r\nif (__iwl_mvm_mac_start(mvm))\r\ngoto reschedule;\r\nif (iwl_mvm_ref_sync(mvm, IWL_MVM_REF_CHECK_CTKILL)) {\r\n__iwl_mvm_mac_stop(mvm);\r\ngoto reschedule;\r\n}\r\ntemp = iwl_mvm_get_temp(mvm);\r\niwl_mvm_unref(mvm, IWL_MVM_REF_CHECK_CTKILL);\r\n__iwl_mvm_mac_stop(mvm);\r\nif (temp < 0)\r\ngoto reschedule;\r\nIWL_DEBUG_TEMP(mvm, "NIC temperature: %d\n", temp);\r\nif (temp <= tt->params->ct_kill_exit) {\r\nmutex_unlock(&mvm->mutex);\r\niwl_mvm_exit_ctkill(mvm);\r\nreturn;\r\n}\r\nreschedule:\r\nmutex_unlock(&mvm->mutex);\r\nschedule_delayed_work(&mvm->thermal_throttle.ct_kill_exit,\r\nround_jiffies(duration * HZ));\r\n}\r\nstatic void iwl_mvm_tt_smps_iterator(void *_data, u8 *mac,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct iwl_mvm *mvm = _data;\r\nenum ieee80211_smps_mode smps_mode;\r\nlockdep_assert_held(&mvm->mutex);\r\nif (mvm->thermal_throttle.dynamic_smps)\r\nsmps_mode = IEEE80211_SMPS_DYNAMIC;\r\nelse\r\nsmps_mode = IEEE80211_SMPS_AUTOMATIC;\r\nif (vif->type != NL80211_IFTYPE_STATION)\r\nreturn;\r\niwl_mvm_update_smps(mvm, vif, IWL_MVM_SMPS_REQ_TT, smps_mode);\r\n}\r\nstatic void iwl_mvm_tt_tx_protection(struct iwl_mvm *mvm, bool enable)\r\n{\r\nstruct ieee80211_sta *sta;\r\nstruct iwl_mvm_sta *mvmsta;\r\nint i, err;\r\nfor (i = 0; i < IWL_MVM_STATION_COUNT; i++) {\r\nsta = rcu_dereference_protected(mvm->fw_id_to_mac_id[i],\r\nlockdep_is_held(&mvm->mutex));\r\nif (IS_ERR_OR_NULL(sta))\r\ncontinue;\r\nmvmsta = iwl_mvm_sta_from_mac80211(sta);\r\nif (enable == mvmsta->tt_tx_protection)\r\ncontinue;\r\nerr = iwl_mvm_tx_protection(mvm, mvmsta, enable);\r\nif (err) {\r\nIWL_ERR(mvm, "Failed to %s Tx protection\n",\r\nenable ? "enable" : "disable");\r\n} else {\r\nIWL_DEBUG_TEMP(mvm, "%s Tx protection\n",\r\nenable ? "Enable" : "Disable");\r\nmvmsta->tt_tx_protection = enable;\r\n}\r\n}\r\n}\r\nvoid iwl_mvm_tt_tx_backoff(struct iwl_mvm *mvm, u32 backoff)\r\n{\r\nstruct iwl_host_cmd cmd = {\r\n.id = REPLY_THERMAL_MNG_BACKOFF,\r\n.len = { sizeof(u32), },\r\n.data = { &backoff, },\r\n};\r\nbackoff = max(backoff, mvm->thermal_throttle.min_backoff);\r\nif (iwl_mvm_send_cmd(mvm, &cmd) == 0) {\r\nIWL_DEBUG_TEMP(mvm, "Set Thermal Tx backoff to: %u\n",\r\nbackoff);\r\nmvm->thermal_throttle.tx_backoff = backoff;\r\n} else {\r\nIWL_ERR(mvm, "Failed to change Thermal Tx backoff\n");\r\n}\r\n}\r\nvoid iwl_mvm_tt_handler(struct iwl_mvm *mvm)\r\n{\r\nconst struct iwl_tt_params *params = mvm->thermal_throttle.params;\r\nstruct iwl_mvm_tt_mgmt *tt = &mvm->thermal_throttle;\r\ns32 temperature = mvm->temperature;\r\nbool throttle_enable = false;\r\nint i;\r\nu32 tx_backoff;\r\nIWL_DEBUG_TEMP(mvm, "NIC temperature: %d\n", mvm->temperature);\r\nif (params->support_ct_kill && temperature >= params->ct_kill_entry) {\r\niwl_mvm_enter_ctkill(mvm);\r\nreturn;\r\n}\r\nif (params->support_ct_kill &&\r\ntemperature <= tt->params->ct_kill_exit) {\r\niwl_mvm_exit_ctkill(mvm);\r\nreturn;\r\n}\r\nif (params->support_dynamic_smps) {\r\nif (!tt->dynamic_smps &&\r\ntemperature >= params->dynamic_smps_entry) {\r\nIWL_DEBUG_TEMP(mvm, "Enable dynamic SMPS\n");\r\ntt->dynamic_smps = true;\r\nieee80211_iterate_active_interfaces_atomic(\r\nmvm->hw, IEEE80211_IFACE_ITER_NORMAL,\r\niwl_mvm_tt_smps_iterator, mvm);\r\nthrottle_enable = true;\r\n} else if (tt->dynamic_smps &&\r\ntemperature <= params->dynamic_smps_exit) {\r\nIWL_DEBUG_TEMP(mvm, "Disable dynamic SMPS\n");\r\ntt->dynamic_smps = false;\r\nieee80211_iterate_active_interfaces_atomic(\r\nmvm->hw, IEEE80211_IFACE_ITER_NORMAL,\r\niwl_mvm_tt_smps_iterator, mvm);\r\n}\r\n}\r\nif (params->support_tx_protection) {\r\nif (temperature >= params->tx_protection_entry) {\r\niwl_mvm_tt_tx_protection(mvm, true);\r\nthrottle_enable = true;\r\n} else if (temperature <= params->tx_protection_exit) {\r\niwl_mvm_tt_tx_protection(mvm, false);\r\n}\r\n}\r\nif (params->support_tx_backoff) {\r\ntx_backoff = tt->min_backoff;\r\nfor (i = 0; i < TT_TX_BACKOFF_SIZE; i++) {\r\nif (temperature < params->tx_backoff[i].temperature)\r\nbreak;\r\ntx_backoff = max(tt->min_backoff,\r\nparams->tx_backoff[i].backoff);\r\n}\r\nif (tx_backoff != tt->min_backoff)\r\nthrottle_enable = true;\r\nif (tt->tx_backoff != tx_backoff)\r\niwl_mvm_tt_tx_backoff(mvm, tx_backoff);\r\n}\r\nif (!tt->throttle && throttle_enable) {\r\nIWL_WARN(mvm,\r\n"Due to high temperature thermal throttling initiated\n");\r\ntt->throttle = true;\r\n} else if (tt->throttle && !tt->dynamic_smps &&\r\ntt->tx_backoff == tt->min_backoff &&\r\ntemperature <= params->tx_protection_exit) {\r\nIWL_WARN(mvm,\r\n"Temperature is back to normal thermal throttling stopped\n");\r\ntt->throttle = false;\r\n}\r\n}\r\nvoid iwl_mvm_tt_initialize(struct iwl_mvm *mvm, u32 min_backoff)\r\n{\r\nstruct iwl_mvm_tt_mgmt *tt = &mvm->thermal_throttle;\r\nIWL_DEBUG_TEMP(mvm, "Initialize Thermal Throttling\n");\r\nif (mvm->cfg->high_temp)\r\ntt->params = &iwl7000_high_temp_tt_params;\r\nelse\r\ntt->params = &iwl7000_tt_params;\r\ntt->throttle = false;\r\ntt->dynamic_smps = false;\r\ntt->min_backoff = min_backoff;\r\nINIT_DELAYED_WORK(&tt->ct_kill_exit, check_exit_ctkill);\r\n}\r\nvoid iwl_mvm_tt_exit(struct iwl_mvm *mvm)\r\n{\r\ncancel_delayed_work_sync(&mvm->thermal_throttle.ct_kill_exit);\r\nIWL_DEBUG_TEMP(mvm, "Exit Thermal Throttling\n");\r\n}
