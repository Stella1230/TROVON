static int omap_hwspinlock_trylock(struct hwspinlock *lock)\r\n{\r\nvoid __iomem *lock_addr = lock->priv;\r\nreturn (SPINLOCK_NOTTAKEN == readl(lock_addr));\r\n}\r\nstatic void omap_hwspinlock_unlock(struct hwspinlock *lock)\r\n{\r\nvoid __iomem *lock_addr = lock->priv;\r\nwritel(SPINLOCK_NOTTAKEN, lock_addr);\r\n}\r\nstatic void omap_hwspinlock_relax(struct hwspinlock *lock)\r\n{\r\nndelay(50);\r\n}\r\nstatic int omap_hwspinlock_probe(struct platform_device *pdev)\r\n{\r\nstruct hwspinlock_pdata *pdata = pdev->dev.platform_data;\r\nstruct hwspinlock_device *bank;\r\nstruct hwspinlock *hwlock;\r\nstruct resource *res;\r\nvoid __iomem *io_base;\r\nint num_locks, i, ret;\r\nif (!pdata)\r\nreturn -ENODEV;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENODEV;\r\nio_base = ioremap(res->start, resource_size(res));\r\nif (!io_base)\r\nreturn -ENOMEM;\r\npm_runtime_enable(&pdev->dev);\r\nret = pm_runtime_get_sync(&pdev->dev);\r\nif (ret < 0) {\r\npm_runtime_put_noidle(&pdev->dev);\r\ngoto iounmap_base;\r\n}\r\ni = readl(io_base + SYSSTATUS_OFFSET);\r\ni >>= SPINLOCK_NUMLOCKS_BIT_OFFSET;\r\nret = pm_runtime_put(&pdev->dev);\r\nif (ret < 0)\r\ngoto iounmap_base;\r\nif (hweight_long(i & 0xf) != 1 || i > 8) {\r\nret = -EINVAL;\r\ngoto iounmap_base;\r\n}\r\nnum_locks = i * 32;\r\nbank = kzalloc(sizeof(*bank) + num_locks * sizeof(*hwlock), GFP_KERNEL);\r\nif (!bank) {\r\nret = -ENOMEM;\r\ngoto iounmap_base;\r\n}\r\nplatform_set_drvdata(pdev, bank);\r\nfor (i = 0, hwlock = &bank->lock[0]; i < num_locks; i++, hwlock++)\r\nhwlock->priv = io_base + LOCK_BASE_OFFSET + sizeof(u32) * i;\r\nret = hwspin_lock_register(bank, &pdev->dev, &omap_hwspinlock_ops,\r\npdata->base_id, num_locks);\r\nif (ret)\r\ngoto reg_fail;\r\nreturn 0;\r\nreg_fail:\r\nkfree(bank);\r\niounmap_base:\r\npm_runtime_disable(&pdev->dev);\r\niounmap(io_base);\r\nreturn ret;\r\n}\r\nstatic int omap_hwspinlock_remove(struct platform_device *pdev)\r\n{\r\nstruct hwspinlock_device *bank = platform_get_drvdata(pdev);\r\nvoid __iomem *io_base = bank->lock[0].priv - LOCK_BASE_OFFSET;\r\nint ret;\r\nret = hwspin_lock_unregister(bank);\r\nif (ret) {\r\ndev_err(&pdev->dev, "%s failed: %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\npm_runtime_disable(&pdev->dev);\r\niounmap(io_base);\r\nkfree(bank);\r\nreturn 0;\r\n}\r\nstatic int __init omap_hwspinlock_init(void)\r\n{\r\nreturn platform_driver_register(&omap_hwspinlock_driver);\r\n}\r\nstatic void __exit omap_hwspinlock_exit(void)\r\n{\r\nplatform_driver_unregister(&omap_hwspinlock_driver);\r\n}
