static u8 s5h1420_readreg(struct s5h1420_state *state, u8 reg)\r\n{\r\nint ret;\r\nu8 b[2];\r\nstruct i2c_msg msg[] = {\r\n{ .addr = state->config->demod_address, .flags = 0, .buf = b, .len = 2 },\r\n{ .addr = state->config->demod_address, .flags = 0, .buf = &reg, .len = 1 },\r\n{ .addr = state->config->demod_address, .flags = I2C_M_RD, .buf = b, .len = 1 },\r\n};\r\nb[0] = (reg - 1) & 0xff;\r\nb[1] = state->shadow[(reg - 1) & 0xff];\r\nif (state->config->repeated_start_workaround) {\r\nret = i2c_transfer(state->i2c, msg, 3);\r\nif (ret != 3)\r\nreturn ret;\r\n} else {\r\nret = i2c_transfer(state->i2c, &msg[1], 1);\r\nif (ret != 1)\r\nreturn ret;\r\nret = i2c_transfer(state->i2c, &msg[2], 1);\r\nif (ret != 1)\r\nreturn ret;\r\n}\r\nreturn b[0];\r\n}\r\nstatic int s5h1420_writereg (struct s5h1420_state* state, u8 reg, u8 data)\r\n{\r\nu8 buf[] = { reg, data };\r\nstruct i2c_msg msg = { .addr = state->config->demod_address, .flags = 0, .buf = buf, .len = 2 };\r\nint err;\r\nerr = i2c_transfer(state->i2c, &msg, 1);\r\nif (err != 1) {\r\ndprintk("%s: writereg error (err == %i, reg == 0x%02x, data == 0x%02x)\n", __func__, err, reg, data);\r\nreturn -EREMOTEIO;\r\n}\r\nstate->shadow[reg] = data;\r\nreturn 0;\r\n}\r\nstatic int s5h1420_set_voltage (struct dvb_frontend* fe, fe_sec_voltage_t voltage)\r\n{\r\nstruct s5h1420_state* state = fe->demodulator_priv;\r\ndprintk("enter %s\n", __func__);\r\nswitch(voltage) {\r\ncase SEC_VOLTAGE_13:\r\ns5h1420_writereg(state, 0x3c,\r\n(s5h1420_readreg(state, 0x3c) & 0xfe) | 0x02);\r\nbreak;\r\ncase SEC_VOLTAGE_18:\r\ns5h1420_writereg(state, 0x3c, s5h1420_readreg(state, 0x3c) | 0x03);\r\nbreak;\r\ncase SEC_VOLTAGE_OFF:\r\ns5h1420_writereg(state, 0x3c, s5h1420_readreg(state, 0x3c) & 0xfd);\r\nbreak;\r\n}\r\ndprintk("leave %s\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int s5h1420_set_tone (struct dvb_frontend* fe, fe_sec_tone_mode_t tone)\r\n{\r\nstruct s5h1420_state* state = fe->demodulator_priv;\r\ndprintk("enter %s\n", __func__);\r\nswitch(tone) {\r\ncase SEC_TONE_ON:\r\ns5h1420_writereg(state, 0x3b,\r\n(s5h1420_readreg(state, 0x3b) & 0x74) | 0x08);\r\nbreak;\r\ncase SEC_TONE_OFF:\r\ns5h1420_writereg(state, 0x3b,\r\n(s5h1420_readreg(state, 0x3b) & 0x74) | 0x01);\r\nbreak;\r\n}\r\ndprintk("leave %s\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int s5h1420_send_master_cmd (struct dvb_frontend* fe,\r\nstruct dvb_diseqc_master_cmd* cmd)\r\n{\r\nstruct s5h1420_state* state = fe->demodulator_priv;\r\nu8 val;\r\nint i;\r\nunsigned long timeout;\r\nint result = 0;\r\ndprintk("enter %s\n", __func__);\r\nif (cmd->msg_len > 8)\r\nreturn -EINVAL;\r\nval = s5h1420_readreg(state, 0x3b);\r\ns5h1420_writereg(state, 0x3b, 0x02);\r\nmsleep(15);\r\nfor(i=0; i< cmd->msg_len; i++) {\r\ns5h1420_writereg(state, 0x3d + i, cmd->msg[i]);\r\n}\r\ns5h1420_writereg(state, 0x3b, s5h1420_readreg(state, 0x3b) |\r\n((cmd->msg_len-1) << 4) | 0x08);\r\ntimeout = jiffies + ((100*HZ) / 1000);\r\nwhile(time_before(jiffies, timeout)) {\r\nif (!(s5h1420_readreg(state, 0x3b) & 0x08))\r\nbreak;\r\nmsleep(5);\r\n}\r\nif (time_after(jiffies, timeout))\r\nresult = -ETIMEDOUT;\r\ns5h1420_writereg(state, 0x3b, val);\r\nmsleep(15);\r\ndprintk("leave %s\n", __func__);\r\nreturn result;\r\n}\r\nstatic int s5h1420_recv_slave_reply (struct dvb_frontend* fe,\r\nstruct dvb_diseqc_slave_reply* reply)\r\n{\r\nstruct s5h1420_state* state = fe->demodulator_priv;\r\nu8 val;\r\nint i;\r\nint length;\r\nunsigned long timeout;\r\nint result = 0;\r\nval = s5h1420_readreg(state, 0x3b);\r\ns5h1420_writereg(state, 0x3b, 0x82);\r\nmsleep(15);\r\ntimeout = jiffies + ((reply->timeout*HZ) / 1000);\r\nwhile(time_before(jiffies, timeout)) {\r\nif (!(s5h1420_readreg(state, 0x3b) & 0x80))\r\nbreak;\r\nmsleep(5);\r\n}\r\nif (time_after(jiffies, timeout)) {\r\nresult = -ETIMEDOUT;\r\ngoto exit;\r\n}\r\nif (s5h1420_readreg(state, 0x49)) {\r\nresult = -EIO;\r\ngoto exit;\r\n}\r\nlength = (s5h1420_readreg(state, 0x3b) & 0x70) >> 4;\r\nif (length > sizeof(reply->msg)) {\r\nresult = -EOVERFLOW;\r\ngoto exit;\r\n}\r\nreply->msg_len = length;\r\nfor(i=0; i< length; i++) {\r\nreply->msg[i] = s5h1420_readreg(state, 0x3d + i);\r\n}\r\nexit:\r\ns5h1420_writereg(state, 0x3b, val);\r\nmsleep(15);\r\nreturn result;\r\n}\r\nstatic int s5h1420_send_burst (struct dvb_frontend* fe, fe_sec_mini_cmd_t minicmd)\r\n{\r\nstruct s5h1420_state* state = fe->demodulator_priv;\r\nu8 val;\r\nint result = 0;\r\nunsigned long timeout;\r\nval = s5h1420_readreg(state, 0x3b);\r\ns5h1420_writereg(state, 0x3b, (s5h1420_readreg(state, 0x3b) & 0x70) | 0x01);\r\nif (minicmd == SEC_MINI_B) {\r\ns5h1420_writereg(state, 0x3b, s5h1420_readreg(state, 0x3b) | 0x04);\r\n}\r\nmsleep(15);\r\ns5h1420_writereg(state, 0x3b, s5h1420_readreg(state, 0x3b) | 0x08);\r\ntimeout = jiffies + ((100*HZ) / 1000);\r\nwhile(time_before(jiffies, timeout)) {\r\nif (!(s5h1420_readreg(state, 0x3b) & 0x08))\r\nbreak;\r\nmsleep(5);\r\n}\r\nif (time_after(jiffies, timeout))\r\nresult = -ETIMEDOUT;\r\ns5h1420_writereg(state, 0x3b, val);\r\nmsleep(15);\r\nreturn result;\r\n}\r\nstatic fe_status_t s5h1420_get_status_bits(struct s5h1420_state* state)\r\n{\r\nu8 val;\r\nfe_status_t status = 0;\r\nval = s5h1420_readreg(state, 0x14);\r\nif (val & 0x02)\r\nstatus |= FE_HAS_SIGNAL;\r\nif (val & 0x01)\r\nstatus |= FE_HAS_CARRIER;\r\nval = s5h1420_readreg(state, 0x36);\r\nif (val & 0x01)\r\nstatus |= FE_HAS_VITERBI;\r\nif (val & 0x20)\r\nstatus |= FE_HAS_SYNC;\r\nif (status == (FE_HAS_SIGNAL|FE_HAS_CARRIER|FE_HAS_VITERBI|FE_HAS_SYNC))\r\nstatus |= FE_HAS_LOCK;\r\nreturn status;\r\n}\r\nstatic int s5h1420_read_status(struct dvb_frontend* fe, fe_status_t* status)\r\n{\r\nstruct s5h1420_state* state = fe->demodulator_priv;\r\nu8 val;\r\ndprintk("enter %s\n", __func__);\r\nif (status == NULL)\r\nreturn -EINVAL;\r\n*status = s5h1420_get_status_bits(state);\r\nif (*status == (FE_HAS_SIGNAL | FE_HAS_CARRIER | FE_HAS_VITERBI)) {\r\nval = s5h1420_readreg(state, Vit10);\r\nif ((val & 0x07) == 0x03) {\r\nif (val & 0x08)\r\ns5h1420_writereg(state, Vit09, 0x13);\r\nelse\r\ns5h1420_writereg(state, Vit09, 0x1b);\r\nmdelay(200);\r\n*status = s5h1420_get_status_bits(state);\r\n}\r\n}\r\nif ((*status & FE_HAS_LOCK) && !state->postlocked) {\r\nu32 tmp = s5h1420_getsymbolrate(state);\r\nswitch (s5h1420_readreg(state, Vit10) & 0x07) {\r\ncase 0: tmp = (tmp * 2 * 1) / 2; break;\r\ncase 1: tmp = (tmp * 2 * 2) / 3; break;\r\ncase 2: tmp = (tmp * 2 * 3) / 4; break;\r\ncase 3: tmp = (tmp * 2 * 5) / 6; break;\r\ncase 4: tmp = (tmp * 2 * 6) / 7; break;\r\ncase 5: tmp = (tmp * 2 * 7) / 8; break;\r\n}\r\nif (tmp == 0) {\r\nprintk(KERN_ERR "s5h1420: avoided division by 0\n");\r\ntmp = 1;\r\n}\r\ntmp = state->fclk / tmp;\r\nif (tmp < 2)\r\nval = 0x00;\r\nelse if (tmp < 5)\r\nval = 0x01;\r\nelse if (tmp < 9)\r\nval = 0x02;\r\nelse if (tmp < 13)\r\nval = 0x03;\r\nelse if (tmp < 17)\r\nval = 0x04;\r\nelse if (tmp < 25)\r\nval = 0x05;\r\nelse if (tmp < 33)\r\nval = 0x06;\r\nelse\r\nval = 0x07;\r\ndprintk("for MPEG_CLK_INTL %d %x\n", tmp, val);\r\ns5h1420_writereg(state, FEC01, 0x18);\r\ns5h1420_writereg(state, FEC01, 0x10);\r\ns5h1420_writereg(state, FEC01, val);\r\nval = s5h1420_readreg(state, Mpeg02);\r\ns5h1420_writereg(state, Mpeg02, val | (1 << 6));\r\nval = s5h1420_readreg(state, QPSK01) & 0x7f;\r\ns5h1420_writereg(state, QPSK01, val);\r\nif (s5h1420_getsymbolrate(state) >= 20000000) {\r\ns5h1420_writereg(state, Loop04, 0x8a);\r\ns5h1420_writereg(state, Loop05, 0x6a);\r\n} else {\r\ns5h1420_writereg(state, Loop04, 0x58);\r\ns5h1420_writereg(state, Loop05, 0x27);\r\n}\r\nstate->postlocked = 1;\r\n}\r\ndprintk("leave %s\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int s5h1420_read_ber(struct dvb_frontend* fe, u32* ber)\r\n{\r\nstruct s5h1420_state* state = fe->demodulator_priv;\r\ns5h1420_writereg(state, 0x46, 0x1d);\r\nmdelay(25);\r\n*ber = (s5h1420_readreg(state, 0x48) << 8) | s5h1420_readreg(state, 0x47);\r\nreturn 0;\r\n}\r\nstatic int s5h1420_read_signal_strength(struct dvb_frontend* fe, u16* strength)\r\n{\r\nstruct s5h1420_state* state = fe->demodulator_priv;\r\nu8 val = s5h1420_readreg(state, 0x15);\r\n*strength = (u16) ((val << 8) | val);\r\nreturn 0;\r\n}\r\nstatic int s5h1420_read_ucblocks(struct dvb_frontend* fe, u32* ucblocks)\r\n{\r\nstruct s5h1420_state* state = fe->demodulator_priv;\r\ns5h1420_writereg(state, 0x46, 0x1f);\r\nmdelay(25);\r\n*ucblocks = (s5h1420_readreg(state, 0x48) << 8) | s5h1420_readreg(state, 0x47);\r\nreturn 0;\r\n}\r\nstatic void s5h1420_reset(struct s5h1420_state* state)\r\n{\r\ndprintk("%s\n", __func__);\r\ns5h1420_writereg (state, 0x01, 0x08);\r\ns5h1420_writereg (state, 0x01, 0x00);\r\nudelay(10);\r\n}\r\nstatic void s5h1420_setsymbolrate(struct s5h1420_state* state,\r\nstruct dtv_frontend_properties *p)\r\n{\r\nu8 v;\r\nu64 val;\r\ndprintk("enter %s\n", __func__);\r\nval = ((u64) p->symbol_rate / 1000ULL) * (1ULL<<24);\r\nif (p->symbol_rate < 29000000)\r\nval *= 2;\r\ndo_div(val, (state->fclk / 1000));\r\ndprintk("symbol rate register: %06llx\n", (unsigned long long)val);\r\nv = s5h1420_readreg(state, Loop01);\r\ns5h1420_writereg(state, Loop01, v & 0x7f);\r\ns5h1420_writereg(state, Tnco01, val >> 16);\r\ns5h1420_writereg(state, Tnco02, val >> 8);\r\ns5h1420_writereg(state, Tnco03, val & 0xff);\r\ns5h1420_writereg(state, Loop01, v | 0x80);\r\ndprintk("leave %s\n", __func__);\r\n}\r\nstatic u32 s5h1420_getsymbolrate(struct s5h1420_state* state)\r\n{\r\nreturn state->symbol_rate;\r\n}\r\nstatic void s5h1420_setfreqoffset(struct s5h1420_state* state, int freqoffset)\r\n{\r\nint val;\r\nu8 v;\r\ndprintk("enter %s\n", __func__);\r\nval = -(int) ((freqoffset * (1<<24)) / (state->fclk / 1000000));\r\ndprintk("phase rotator/freqoffset: %d %06x\n", freqoffset, val);\r\nv = s5h1420_readreg(state, Loop01);\r\ns5h1420_writereg(state, Loop01, v & 0xbf);\r\ns5h1420_writereg(state, Pnco01, val >> 16);\r\ns5h1420_writereg(state, Pnco02, val >> 8);\r\ns5h1420_writereg(state, Pnco03, val & 0xff);\r\ns5h1420_writereg(state, Loop01, v | 0x40);\r\ndprintk("leave %s\n", __func__);\r\n}\r\nstatic int s5h1420_getfreqoffset(struct s5h1420_state* state)\r\n{\r\nint val;\r\ns5h1420_writereg(state, 0x06, s5h1420_readreg(state, 0x06) | 0x08);\r\nval = s5h1420_readreg(state, 0x0e) << 16;\r\nval |= s5h1420_readreg(state, 0x0f) << 8;\r\nval |= s5h1420_readreg(state, 0x10);\r\ns5h1420_writereg(state, 0x06, s5h1420_readreg(state, 0x06) & 0xf7);\r\nif (val & 0x800000)\r\nval |= 0xff000000;\r\nval = (((-val) * (state->fclk/1000000)) / (1<<24));\r\nreturn val;\r\n}\r\nstatic void s5h1420_setfec_inversion(struct s5h1420_state* state,\r\nstruct dtv_frontend_properties *p)\r\n{\r\nu8 inversion = 0;\r\nu8 vit08, vit09;\r\ndprintk("enter %s\n", __func__);\r\nif (p->inversion == INVERSION_OFF)\r\ninversion = state->config->invert ? 0x08 : 0;\r\nelse if (p->inversion == INVERSION_ON)\r\ninversion = state->config->invert ? 0 : 0x08;\r\nif ((p->fec_inner == FEC_AUTO) || (p->inversion == INVERSION_AUTO)) {\r\nvit08 = 0x3f;\r\nvit09 = 0;\r\n} else {\r\nswitch (p->fec_inner) {\r\ncase FEC_1_2:\r\nvit08 = 0x01; vit09 = 0x10;\r\nbreak;\r\ncase FEC_2_3:\r\nvit08 = 0x02; vit09 = 0x11;\r\nbreak;\r\ncase FEC_3_4:\r\nvit08 = 0x04; vit09 = 0x12;\r\nbreak;\r\ncase FEC_5_6:\r\nvit08 = 0x08; vit09 = 0x13;\r\nbreak;\r\ncase FEC_6_7:\r\nvit08 = 0x10; vit09 = 0x14;\r\nbreak;\r\ncase FEC_7_8:\r\nvit08 = 0x20; vit09 = 0x15;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\n}\r\nvit09 |= inversion;\r\ndprintk("fec: %02x %02x\n", vit08, vit09);\r\ns5h1420_writereg(state, Vit08, vit08);\r\ns5h1420_writereg(state, Vit09, vit09);\r\ndprintk("leave %s\n", __func__);\r\n}\r\nstatic fe_code_rate_t s5h1420_getfec(struct s5h1420_state* state)\r\n{\r\nswitch(s5h1420_readreg(state, 0x32) & 0x07) {\r\ncase 0:\r\nreturn FEC_1_2;\r\ncase 1:\r\nreturn FEC_2_3;\r\ncase 2:\r\nreturn FEC_3_4;\r\ncase 3:\r\nreturn FEC_5_6;\r\ncase 4:\r\nreturn FEC_6_7;\r\ncase 5:\r\nreturn FEC_7_8;\r\n}\r\nreturn FEC_NONE;\r\n}\r\nstatic fe_spectral_inversion_t s5h1420_getinversion(struct s5h1420_state* state)\r\n{\r\nif (s5h1420_readreg(state, 0x32) & 0x08)\r\nreturn INVERSION_ON;\r\nreturn INVERSION_OFF;\r\n}\r\nstatic int s5h1420_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct s5h1420_state* state = fe->demodulator_priv;\r\nint frequency_delta;\r\nstruct dvb_frontend_tune_settings fesettings;\r\ndprintk("enter %s\n", __func__);\r\ns5h1420_get_tune_settings(fe, &fesettings);\r\nfrequency_delta = p->frequency - state->tunedfreq;\r\nif ((frequency_delta > -fesettings.max_drift) &&\r\n(frequency_delta < fesettings.max_drift) &&\r\n(frequency_delta != 0) &&\r\n(state->fec_inner == p->fec_inner) &&\r\n(state->symbol_rate == p->symbol_rate)) {\r\nif (fe->ops.tuner_ops.set_params) {\r\nfe->ops.tuner_ops.set_params(fe);\r\nif (fe->ops.i2c_gate_ctrl) fe->ops.i2c_gate_ctrl(fe, 0);\r\n}\r\nif (fe->ops.tuner_ops.get_frequency) {\r\nu32 tmp;\r\nfe->ops.tuner_ops.get_frequency(fe, &tmp);\r\nif (fe->ops.i2c_gate_ctrl) fe->ops.i2c_gate_ctrl(fe, 0);\r\ns5h1420_setfreqoffset(state, p->frequency - tmp);\r\n} else {\r\ns5h1420_setfreqoffset(state, 0);\r\n}\r\ndprintk("simple tune\n");\r\nreturn 0;\r\n}\r\ndprintk("tuning demod\n");\r\ns5h1420_reset(state);\r\nif (p->symbol_rate > 33000000)\r\nstate->fclk = 80000000;\r\nelse if (p->symbol_rate > 28500000)\r\nstate->fclk = 59000000;\r\nelse if (p->symbol_rate > 25000000)\r\nstate->fclk = 86000000;\r\nelse if (p->symbol_rate > 1900000)\r\nstate->fclk = 88000000;\r\nelse\r\nstate->fclk = 44000000;\r\ndprintk("pll01: %d, ToneFreq: %d\n", state->fclk/1000000 - 8, (state->fclk + (TONE_FREQ * 32) - 1) / (TONE_FREQ * 32));\r\ns5h1420_writereg(state, PLL01, state->fclk/1000000 - 8);\r\ns5h1420_writereg(state, PLL02, 0x40);\r\ns5h1420_writereg(state, DiS01, (state->fclk + (TONE_FREQ * 32) - 1) / (TONE_FREQ * 32));\r\nif (p->symbol_rate > 29000000)\r\ns5h1420_writereg(state, QPSK01, 0xae | 0x10);\r\nelse\r\ns5h1420_writereg(state, QPSK01, 0xac | 0x10);\r\ns5h1420_writereg(state, CON_1, 0x00);\r\ns5h1420_writereg(state, QPSK02, 0x00);\r\ns5h1420_writereg(state, Pre01, 0xb0);\r\ns5h1420_writereg(state, Loop01, 0xF0);\r\ns5h1420_writereg(state, Loop02, 0x2a);\r\ns5h1420_writereg(state, Loop03, 0x79);\r\nif (p->symbol_rate > 20000000)\r\ns5h1420_writereg(state, Loop04, 0x79);\r\nelse\r\ns5h1420_writereg(state, Loop04, 0x58);\r\ns5h1420_writereg(state, Loop05, 0x6b);\r\nif (p->symbol_rate >= 8000000)\r\ns5h1420_writereg(state, Post01, (0 << 6) | 0x10);\r\nelse if (p->symbol_rate >= 4000000)\r\ns5h1420_writereg(state, Post01, (1 << 6) | 0x10);\r\nelse\r\ns5h1420_writereg(state, Post01, (3 << 6) | 0x10);\r\ns5h1420_writereg(state, Monitor12, 0x00);\r\ns5h1420_writereg(state, Sync01, 0x33);\r\ns5h1420_writereg(state, Mpeg01, state->config->cdclk_polarity);\r\ns5h1420_writereg(state, Mpeg02, 0x3d);\r\ns5h1420_writereg(state, Err01, 0x03);\r\ns5h1420_writereg(state, Vit06, 0x6e);\r\ns5h1420_writereg(state, DiS03, 0x00);\r\ns5h1420_writereg(state, Rf01, 0x61);\r\nif (fe->ops.tuner_ops.set_params) {\r\nfe->ops.tuner_ops.set_params(fe);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\ns5h1420_setfreqoffset(state, 0);\r\n}\r\ns5h1420_setsymbolrate(state, p);\r\ns5h1420_setfec_inversion(state, p);\r\ns5h1420_writereg(state, QPSK01, s5h1420_readreg(state, QPSK01) | 1);\r\nstate->fec_inner = p->fec_inner;\r\nstate->symbol_rate = p->symbol_rate;\r\nstate->postlocked = 0;\r\nstate->tunedfreq = p->frequency;\r\ndprintk("leave %s\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int s5h1420_get_frontend(struct dvb_frontend* fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct s5h1420_state* state = fe->demodulator_priv;\r\np->frequency = state->tunedfreq + s5h1420_getfreqoffset(state);\r\np->inversion = s5h1420_getinversion(state);\r\np->symbol_rate = s5h1420_getsymbolrate(state);\r\np->fec_inner = s5h1420_getfec(state);\r\nreturn 0;\r\n}\r\nstatic int s5h1420_get_tune_settings(struct dvb_frontend* fe,\r\nstruct dvb_frontend_tune_settings* fesettings)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nif (p->symbol_rate > 20000000) {\r\nfesettings->min_delay_ms = 50;\r\nfesettings->step_size = 2000;\r\nfesettings->max_drift = 8000;\r\n} else if (p->symbol_rate > 12000000) {\r\nfesettings->min_delay_ms = 100;\r\nfesettings->step_size = 1500;\r\nfesettings->max_drift = 9000;\r\n} else if (p->symbol_rate > 8000000) {\r\nfesettings->min_delay_ms = 100;\r\nfesettings->step_size = 1000;\r\nfesettings->max_drift = 8000;\r\n} else if (p->symbol_rate > 4000000) {\r\nfesettings->min_delay_ms = 100;\r\nfesettings->step_size = 500;\r\nfesettings->max_drift = 7000;\r\n} else if (p->symbol_rate > 2000000) {\r\nfesettings->min_delay_ms = 200;\r\nfesettings->step_size = (p->symbol_rate / 8000);\r\nfesettings->max_drift = 14 * fesettings->step_size;\r\n} else {\r\nfesettings->min_delay_ms = 200;\r\nfesettings->step_size = (p->symbol_rate / 8000);\r\nfesettings->max_drift = 18 * fesettings->step_size;\r\n}\r\nreturn 0;\r\n}\r\nstatic int s5h1420_i2c_gate_ctrl(struct dvb_frontend* fe, int enable)\r\n{\r\nstruct s5h1420_state* state = fe->demodulator_priv;\r\nif (enable)\r\nreturn s5h1420_writereg(state, 0x02, state->CON_1_val | 1);\r\nelse\r\nreturn s5h1420_writereg(state, 0x02, state->CON_1_val & 0xfe);\r\n}\r\nstatic int s5h1420_init (struct dvb_frontend* fe)\r\n{\r\nstruct s5h1420_state* state = fe->demodulator_priv;\r\nstate->CON_1_val = state->config->serial_mpeg << 4;\r\ns5h1420_writereg(state, 0x02, state->CON_1_val);\r\nmsleep(10);\r\ns5h1420_reset(state);\r\nreturn 0;\r\n}\r\nstatic int s5h1420_sleep(struct dvb_frontend* fe)\r\n{\r\nstruct s5h1420_state* state = fe->demodulator_priv;\r\nstate->CON_1_val = 0x12;\r\nreturn s5h1420_writereg(state, 0x02, state->CON_1_val);\r\n}\r\nstatic void s5h1420_release(struct dvb_frontend* fe)\r\n{\r\nstruct s5h1420_state* state = fe->demodulator_priv;\r\ni2c_del_adapter(&state->tuner_i2c_adapter);\r\nkfree(state);\r\n}\r\nstatic u32 s5h1420_tuner_i2c_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nstatic int s5h1420_tuner_i2c_tuner_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg msg[], int num)\r\n{\r\nstruct s5h1420_state *state = i2c_get_adapdata(i2c_adap);\r\nstruct i2c_msg m[3];\r\nu8 tx_open[2] = { CON_1, state->CON_1_val | 1 };\r\nif (1 + num > ARRAY_SIZE(m)) {\r\nprintk(KERN_WARNING\r\n"%s: i2c xfer: num=%d is too big!\n",\r\nKBUILD_MODNAME, num);\r\nreturn -EOPNOTSUPP;\r\n}\r\nmemset(m, 0, sizeof(struct i2c_msg) * (1 + num));\r\nm[0].addr = state->config->demod_address;\r\nm[0].buf = tx_open;\r\nm[0].len = 2;\r\nmemcpy(&m[1], msg, sizeof(struct i2c_msg) * num);\r\nreturn i2c_transfer(state->i2c, m, 1 + num) == 1 + num ? num : -EIO;\r\n}\r\nstruct i2c_adapter *s5h1420_get_tuner_i2c_adapter(struct dvb_frontend *fe)\r\n{\r\nstruct s5h1420_state *state = fe->demodulator_priv;\r\nreturn &state->tuner_i2c_adapter;\r\n}\r\nstruct dvb_frontend *s5h1420_attach(const struct s5h1420_config *config,\r\nstruct i2c_adapter *i2c)\r\n{\r\nstruct s5h1420_state *state = kzalloc(sizeof(struct s5h1420_state), GFP_KERNEL);\r\nu8 i;\r\nif (state == NULL)\r\ngoto error;\r\nstate->config = config;\r\nstate->i2c = i2c;\r\nstate->postlocked = 0;\r\nstate->fclk = 88000000;\r\nstate->tunedfreq = 0;\r\nstate->fec_inner = FEC_NONE;\r\nstate->symbol_rate = 0;\r\ni = s5h1420_readreg(state, ID01);\r\nif (i != 0x03)\r\ngoto error;\r\nmemset(state->shadow, 0xff, sizeof(state->shadow));\r\nfor (i = 0; i < 0x50; i++)\r\nstate->shadow[i] = s5h1420_readreg(state, i);\r\nmemcpy(&state->frontend.ops, &s5h1420_ops, sizeof(struct dvb_frontend_ops));\r\nstate->frontend.demodulator_priv = state;\r\nstrlcpy(state->tuner_i2c_adapter.name, "S5H1420-PN1010 tuner I2C bus",\r\nsizeof(state->tuner_i2c_adapter.name));\r\nstate->tuner_i2c_adapter.algo = &s5h1420_tuner_i2c_algo;\r\nstate->tuner_i2c_adapter.algo_data = NULL;\r\ni2c_set_adapdata(&state->tuner_i2c_adapter, state);\r\nif (i2c_add_adapter(&state->tuner_i2c_adapter) < 0) {\r\nprintk(KERN_ERR "S5H1420/PN1010: tuner i2c bus could not be initialized\n");\r\ngoto error;\r\n}\r\nreturn &state->frontend;\r\nerror:\r\nkfree(state);\r\nreturn NULL;\r\n}
