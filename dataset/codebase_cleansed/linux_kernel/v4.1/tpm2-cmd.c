int tpm2_pcr_read(struct tpm_chip *chip, int pcr_idx, u8 *res_buf)\r\n{\r\nint rc;\r\nstruct tpm2_cmd cmd;\r\nu8 *buf;\r\nif (pcr_idx >= TPM2_PLATFORM_PCR)\r\nreturn -EINVAL;\r\ncmd.header.in = tpm2_pcrread_header;\r\ncmd.params.pcrread_in.pcr_selects_cnt = cpu_to_be32(1);\r\ncmd.params.pcrread_in.hash_alg = cpu_to_be16(TPM2_ALG_SHA1);\r\ncmd.params.pcrread_in.pcr_select_size = TPM2_PCR_SELECT_MIN;\r\nmemset(cmd.params.pcrread_in.pcr_select, 0,\r\nsizeof(cmd.params.pcrread_in.pcr_select));\r\ncmd.params.pcrread_in.pcr_select[pcr_idx >> 3] = 1 << (pcr_idx & 0x7);\r\nrc = tpm_transmit_cmd(chip, &cmd, sizeof(cmd),\r\n"attempting to read a pcr value");\r\nif (rc == 0) {\r\nbuf = cmd.params.pcrread_out.digest;\r\nmemcpy(res_buf, buf, TPM_DIGEST_SIZE);\r\n}\r\nreturn rc;\r\n}\r\nint tpm2_pcr_extend(struct tpm_chip *chip, int pcr_idx, const u8 *hash)\r\n{\r\nstruct tpm2_cmd cmd;\r\nint rc;\r\ncmd.header.in = tpm2_pcrextend_header;\r\ncmd.params.pcrextend_in.pcr_idx = cpu_to_be32(pcr_idx);\r\ncmd.params.pcrextend_in.auth_area_size =\r\ncpu_to_be32(sizeof(struct tpm2_null_auth_area));\r\ncmd.params.pcrextend_in.auth_area.handle =\r\ncpu_to_be32(TPM2_RS_PW);\r\ncmd.params.pcrextend_in.auth_area.nonce_size = 0;\r\ncmd.params.pcrextend_in.auth_area.attributes = 0;\r\ncmd.params.pcrextend_in.auth_area.auth_size = 0;\r\ncmd.params.pcrextend_in.digest_cnt = cpu_to_be32(1);\r\ncmd.params.pcrextend_in.hash_alg = cpu_to_be16(TPM2_ALG_SHA1);\r\nmemcpy(cmd.params.pcrextend_in.digest, hash, TPM_DIGEST_SIZE);\r\nrc = tpm_transmit_cmd(chip, &cmd, sizeof(cmd),\r\n"attempting extend a PCR value");\r\nreturn rc;\r\n}\r\nint tpm2_get_random(struct tpm_chip *chip, u8 *out, size_t max)\r\n{\r\nstruct tpm2_cmd cmd;\r\nu32 recd;\r\nu32 num_bytes;\r\nint err;\r\nint total = 0;\r\nint retries = 5;\r\nu8 *dest = out;\r\nnum_bytes = min_t(u32, max, sizeof(cmd.params.getrandom_out.buffer));\r\nif (!out || !num_bytes ||\r\nmax > sizeof(cmd.params.getrandom_out.buffer))\r\nreturn -EINVAL;\r\ndo {\r\ncmd.header.in = tpm2_getrandom_header;\r\ncmd.params.getrandom_in.size = cpu_to_be16(num_bytes);\r\nerr = tpm_transmit_cmd(chip, &cmd, sizeof(cmd),\r\n"attempting get random");\r\nif (err)\r\nbreak;\r\nrecd = min_t(u32, be16_to_cpu(cmd.params.getrandom_out.size),\r\nnum_bytes);\r\nmemcpy(dest, cmd.params.getrandom_out.buffer, recd);\r\ndest += recd;\r\ntotal += recd;\r\nnum_bytes -= recd;\r\n} while (retries-- && total < max);\r\nreturn total ? total : -EIO;\r\n}\r\nssize_t tpm2_get_tpm_pt(struct tpm_chip *chip, u32 property_id, u32 *value,\r\nconst char *desc)\r\n{\r\nstruct tpm2_cmd cmd;\r\nint rc;\r\ncmd.header.in = tpm2_get_tpm_pt_header;\r\ncmd.params.get_tpm_pt_in.cap_id = cpu_to_be32(TPM2_CAP_TPM_PROPERTIES);\r\ncmd.params.get_tpm_pt_in.property_id = cpu_to_be32(property_id);\r\ncmd.params.get_tpm_pt_in.property_cnt = cpu_to_be32(1);\r\nrc = tpm_transmit_cmd(chip, &cmd, sizeof(cmd), desc);\r\nif (!rc)\r\n*value = cmd.params.get_tpm_pt_out.value;\r\nreturn rc;\r\n}\r\nint tpm2_startup(struct tpm_chip *chip, u16 startup_type)\r\n{\r\nstruct tpm2_cmd cmd;\r\ncmd.header.in = tpm2_startup_header;\r\ncmd.params.startup_in.startup_type = cpu_to_be16(startup_type);\r\nreturn tpm_transmit_cmd(chip, &cmd, sizeof(cmd),\r\n"attempting to start the TPM");\r\n}\r\nvoid tpm2_shutdown(struct tpm_chip *chip, u16 shutdown_type)\r\n{\r\nstruct tpm2_cmd cmd;\r\nint rc;\r\ncmd.header.in = tpm2_shutdown_header;\r\ncmd.params.startup_in.startup_type = cpu_to_be16(shutdown_type);\r\nrc = tpm_transmit_cmd(chip, &cmd, sizeof(cmd), "stopping the TPM");\r\nif (rc < 0)\r\ndev_warn(chip->pdev, "transmit returned %d while stopping the TPM",\r\nrc);\r\n}\r\nunsigned long tpm2_calc_ordinal_duration(struct tpm_chip *chip, u32 ordinal)\r\n{\r\nint index = TPM_UNDEFINED;\r\nint duration = 0;\r\nif (ordinal >= TPM2_CC_FIRST && ordinal <= TPM2_CC_LAST)\r\nindex = tpm2_ordinal_duration[ordinal - TPM2_CC_FIRST];\r\nif (index != TPM_UNDEFINED)\r\nduration = chip->vendor.duration[index];\r\nif (duration <= 0)\r\nduration = 2 * 60 * HZ;\r\nreturn duration;\r\n}\r\nstatic int tpm2_start_selftest(struct tpm_chip *chip, bool full)\r\n{\r\nint rc;\r\nstruct tpm2_cmd cmd;\r\ncmd.header.in = tpm2_selftest_header;\r\ncmd.params.selftest_in.full_test = full;\r\nrc = tpm_transmit_cmd(chip, &cmd, TPM2_SELF_TEST_IN_SIZE,\r\n"continue selftest");\r\nif (rc == TPM2_RC_TESTING) {\r\ndev_warn(chip->pdev, "Got RC_TESTING, ignoring\n");\r\nrc = 0;\r\n}\r\nreturn rc;\r\n}\r\nint tpm2_do_selftest(struct tpm_chip *chip)\r\n{\r\nint rc;\r\nunsigned int loops;\r\nunsigned int delay_msec = 100;\r\nunsigned long duration;\r\nstruct tpm2_cmd cmd;\r\nint i;\r\nduration = tpm2_calc_ordinal_duration(chip, TPM2_CC_SELF_TEST);\r\nloops = jiffies_to_msecs(duration) / delay_msec;\r\nrc = tpm2_start_selftest(chip, true);\r\nif (rc)\r\nreturn rc;\r\nfor (i = 0; i < loops; i++) {\r\ncmd.header.in = tpm2_pcrread_header;\r\ncmd.params.pcrread_in.pcr_selects_cnt = cpu_to_be32(1);\r\ncmd.params.pcrread_in.hash_alg = cpu_to_be16(TPM2_ALG_SHA1);\r\ncmd.params.pcrread_in.pcr_select_size = TPM2_PCR_SELECT_MIN;\r\ncmd.params.pcrread_in.pcr_select[0] = 0x01;\r\ncmd.params.pcrread_in.pcr_select[1] = 0x00;\r\ncmd.params.pcrread_in.pcr_select[2] = 0x00;\r\nrc = tpm_transmit_cmd(chip, (u8 *) &cmd, sizeof(cmd), NULL);\r\nif (rc < 0)\r\nbreak;\r\nrc = be32_to_cpu(cmd.header.out.return_code);\r\nif (rc != TPM2_RC_TESTING)\r\nbreak;\r\nmsleep(delay_msec);\r\n}\r\nreturn rc;\r\n}\r\nint tpm2_gen_interrupt(struct tpm_chip *chip)\r\n{\r\nu32 dummy;\r\nreturn tpm2_get_tpm_pt(chip, 0x100, &dummy,\r\n"attempting to generate an interrupt");\r\n}\r\nint tpm2_probe(struct tpm_chip *chip)\r\n{\r\nstruct tpm2_cmd cmd;\r\nint rc;\r\ncmd.header.in = tpm2_get_tpm_pt_header;\r\ncmd.params.get_tpm_pt_in.cap_id = cpu_to_be32(TPM2_CAP_TPM_PROPERTIES);\r\ncmd.params.get_tpm_pt_in.property_id = cpu_to_be32(0x100);\r\ncmd.params.get_tpm_pt_in.property_cnt = cpu_to_be32(1);\r\nrc = tpm_transmit(chip, (const char *) &cmd, sizeof(cmd));\r\nif (rc < 0)\r\nreturn rc;\r\nelse if (rc < TPM_HEADER_SIZE)\r\nreturn -EFAULT;\r\nif (be16_to_cpu(cmd.header.out.tag) == TPM2_ST_NO_SESSIONS)\r\nchip->flags |= TPM_CHIP_FLAG_TPM2;\r\nreturn 0;\r\n}
