static irqreturn_t vsp1_irq_handler(int irq, void *data)\r\n{\r\nu32 mask = VI6_WFP_IRQ_STA_DFE | VI6_WFP_IRQ_STA_FRE;\r\nstruct vsp1_device *vsp1 = data;\r\nirqreturn_t ret = IRQ_NONE;\r\nunsigned int i;\r\nfor (i = 0; i < vsp1->pdata.wpf_count; ++i) {\r\nstruct vsp1_rwpf *wpf = vsp1->wpf[i];\r\nstruct vsp1_pipeline *pipe;\r\nu32 status;\r\nif (wpf == NULL)\r\ncontinue;\r\npipe = to_vsp1_pipeline(&wpf->entity.subdev.entity);\r\nstatus = vsp1_read(vsp1, VI6_WPF_IRQ_STA(i));\r\nvsp1_write(vsp1, VI6_WPF_IRQ_STA(i), ~status & mask);\r\nif (status & VI6_WFP_IRQ_STA_FRE) {\r\nvsp1_pipeline_frame_end(pipe);\r\nret = IRQ_HANDLED;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int vsp1_create_links(struct vsp1_device *vsp1, struct vsp1_entity *sink)\r\n{\r\nstruct media_entity *entity = &sink->subdev.entity;\r\nstruct vsp1_entity *source;\r\nunsigned int pad;\r\nint ret;\r\nlist_for_each_entry(source, &vsp1->entities, list_dev) {\r\nu32 flags;\r\nif (source->type == sink->type)\r\ncontinue;\r\nif (source->type == VSP1_ENTITY_LIF ||\r\nsource->type == VSP1_ENTITY_WPF)\r\ncontinue;\r\nflags = source->type == VSP1_ENTITY_RPF &&\r\nsink->type == VSP1_ENTITY_WPF &&\r\nsource->index == sink->index\r\n? MEDIA_LNK_FL_ENABLED : 0;\r\nfor (pad = 0; pad < entity->num_pads; ++pad) {\r\nif (!(entity->pads[pad].flags & MEDIA_PAD_FL_SINK))\r\ncontinue;\r\nret = media_entity_create_link(&source->subdev.entity,\r\nsource->source_pad,\r\nentity, pad, flags);\r\nif (ret < 0)\r\nreturn ret;\r\nif (flags & MEDIA_LNK_FL_ENABLED)\r\nsource->sink = entity;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void vsp1_destroy_entities(struct vsp1_device *vsp1)\r\n{\r\nstruct vsp1_entity *entity;\r\nstruct vsp1_entity *next;\r\nlist_for_each_entry_safe(entity, next, &vsp1->entities, list_dev) {\r\nlist_del(&entity->list_dev);\r\nvsp1_entity_destroy(entity);\r\n}\r\nv4l2_device_unregister(&vsp1->v4l2_dev);\r\nmedia_device_unregister(&vsp1->media_dev);\r\n}\r\nstatic int vsp1_create_entities(struct vsp1_device *vsp1)\r\n{\r\nstruct media_device *mdev = &vsp1->media_dev;\r\nstruct v4l2_device *vdev = &vsp1->v4l2_dev;\r\nstruct vsp1_entity *entity;\r\nunsigned int i;\r\nint ret;\r\nmdev->dev = vsp1->dev;\r\nstrlcpy(mdev->model, "VSP1", sizeof(mdev->model));\r\nsnprintf(mdev->bus_info, sizeof(mdev->bus_info), "platform:%s",\r\ndev_name(mdev->dev));\r\nret = media_device_register(mdev);\r\nif (ret < 0) {\r\ndev_err(vsp1->dev, "media device registration failed (%d)\n",\r\nret);\r\nreturn ret;\r\n}\r\nvdev->mdev = mdev;\r\nret = v4l2_device_register(vsp1->dev, vdev);\r\nif (ret < 0) {\r\ndev_err(vsp1->dev, "V4L2 device registration failed (%d)\n",\r\nret);\r\ngoto done;\r\n}\r\nvsp1->bru = vsp1_bru_create(vsp1);\r\nif (IS_ERR(vsp1->bru)) {\r\nret = PTR_ERR(vsp1->bru);\r\ngoto done;\r\n}\r\nlist_add_tail(&vsp1->bru->entity.list_dev, &vsp1->entities);\r\nvsp1->hsi = vsp1_hsit_create(vsp1, true);\r\nif (IS_ERR(vsp1->hsi)) {\r\nret = PTR_ERR(vsp1->hsi);\r\ngoto done;\r\n}\r\nlist_add_tail(&vsp1->hsi->entity.list_dev, &vsp1->entities);\r\nvsp1->hst = vsp1_hsit_create(vsp1, false);\r\nif (IS_ERR(vsp1->hst)) {\r\nret = PTR_ERR(vsp1->hst);\r\ngoto done;\r\n}\r\nlist_add_tail(&vsp1->hst->entity.list_dev, &vsp1->entities);\r\nif (vsp1->pdata.features & VSP1_HAS_LIF) {\r\nvsp1->lif = vsp1_lif_create(vsp1);\r\nif (IS_ERR(vsp1->lif)) {\r\nret = PTR_ERR(vsp1->lif);\r\ngoto done;\r\n}\r\nlist_add_tail(&vsp1->lif->entity.list_dev, &vsp1->entities);\r\n}\r\nif (vsp1->pdata.features & VSP1_HAS_LUT) {\r\nvsp1->lut = vsp1_lut_create(vsp1);\r\nif (IS_ERR(vsp1->lut)) {\r\nret = PTR_ERR(vsp1->lut);\r\ngoto done;\r\n}\r\nlist_add_tail(&vsp1->lut->entity.list_dev, &vsp1->entities);\r\n}\r\nfor (i = 0; i < vsp1->pdata.rpf_count; ++i) {\r\nstruct vsp1_rwpf *rpf;\r\nrpf = vsp1_rpf_create(vsp1, i);\r\nif (IS_ERR(rpf)) {\r\nret = PTR_ERR(rpf);\r\ngoto done;\r\n}\r\nvsp1->rpf[i] = rpf;\r\nlist_add_tail(&rpf->entity.list_dev, &vsp1->entities);\r\n}\r\nif (vsp1->pdata.features & VSP1_HAS_SRU) {\r\nvsp1->sru = vsp1_sru_create(vsp1);\r\nif (IS_ERR(vsp1->sru)) {\r\nret = PTR_ERR(vsp1->sru);\r\ngoto done;\r\n}\r\nlist_add_tail(&vsp1->sru->entity.list_dev, &vsp1->entities);\r\n}\r\nfor (i = 0; i < vsp1->pdata.uds_count; ++i) {\r\nstruct vsp1_uds *uds;\r\nuds = vsp1_uds_create(vsp1, i);\r\nif (IS_ERR(uds)) {\r\nret = PTR_ERR(uds);\r\ngoto done;\r\n}\r\nvsp1->uds[i] = uds;\r\nlist_add_tail(&uds->entity.list_dev, &vsp1->entities);\r\n}\r\nfor (i = 0; i < vsp1->pdata.wpf_count; ++i) {\r\nstruct vsp1_rwpf *wpf;\r\nwpf = vsp1_wpf_create(vsp1, i);\r\nif (IS_ERR(wpf)) {\r\nret = PTR_ERR(wpf);\r\ngoto done;\r\n}\r\nvsp1->wpf[i] = wpf;\r\nlist_add_tail(&wpf->entity.list_dev, &vsp1->entities);\r\n}\r\nlist_for_each_entry(entity, &vsp1->entities, list_dev) {\r\nif (entity->type == VSP1_ENTITY_LIF ||\r\nentity->type == VSP1_ENTITY_RPF)\r\ncontinue;\r\nret = vsp1_create_links(vsp1, entity);\r\nif (ret < 0)\r\ngoto done;\r\n}\r\nif (vsp1->pdata.features & VSP1_HAS_LIF) {\r\nret = media_entity_create_link(\r\n&vsp1->wpf[0]->entity.subdev.entity, RWPF_PAD_SOURCE,\r\n&vsp1->lif->entity.subdev.entity, LIF_PAD_SINK, 0);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nlist_for_each_entry(entity, &vsp1->entities, list_dev) {\r\nret = v4l2_device_register_subdev(&vsp1->v4l2_dev,\r\n&entity->subdev);\r\nif (ret < 0)\r\ngoto done;\r\n}\r\nret = v4l2_device_register_subdev_nodes(&vsp1->v4l2_dev);\r\ndone:\r\nif (ret < 0)\r\nvsp1_destroy_entities(vsp1);\r\nreturn ret;\r\n}\r\nstatic int vsp1_device_init(struct vsp1_device *vsp1)\r\n{\r\nunsigned int i;\r\nu32 status;\r\nstatus = vsp1_read(vsp1, VI6_STATUS);\r\nfor (i = 0; i < vsp1->pdata.wpf_count; ++i) {\r\nunsigned int timeout;\r\nif (!(status & VI6_STATUS_SYS_ACT(i)))\r\ncontinue;\r\nvsp1_write(vsp1, VI6_SRESET, VI6_SRESET_SRTS(i));\r\nfor (timeout = 10; timeout > 0; --timeout) {\r\nstatus = vsp1_read(vsp1, VI6_STATUS);\r\nif (!(status & VI6_STATUS_SYS_ACT(i)))\r\nbreak;\r\nusleep_range(1000, 2000);\r\n}\r\nif (!timeout) {\r\ndev_err(vsp1->dev, "failed to reset wpf.%u\n", i);\r\nreturn -ETIMEDOUT;\r\n}\r\n}\r\nvsp1_write(vsp1, VI6_CLK_DCSWT, (8 << VI6_CLK_DCSWT_CSTPW_SHIFT) |\r\n(8 << VI6_CLK_DCSWT_CSTRW_SHIFT));\r\nfor (i = 0; i < vsp1->pdata.rpf_count; ++i)\r\nvsp1_write(vsp1, VI6_DPR_RPF_ROUTE(i), VI6_DPR_NODE_UNUSED);\r\nfor (i = 0; i < vsp1->pdata.uds_count; ++i)\r\nvsp1_write(vsp1, VI6_DPR_UDS_ROUTE(i), VI6_DPR_NODE_UNUSED);\r\nvsp1_write(vsp1, VI6_DPR_SRU_ROUTE, VI6_DPR_NODE_UNUSED);\r\nvsp1_write(vsp1, VI6_DPR_LUT_ROUTE, VI6_DPR_NODE_UNUSED);\r\nvsp1_write(vsp1, VI6_DPR_CLU_ROUTE, VI6_DPR_NODE_UNUSED);\r\nvsp1_write(vsp1, VI6_DPR_HST_ROUTE, VI6_DPR_NODE_UNUSED);\r\nvsp1_write(vsp1, VI6_DPR_HSI_ROUTE, VI6_DPR_NODE_UNUSED);\r\nvsp1_write(vsp1, VI6_DPR_BRU_ROUTE, VI6_DPR_NODE_UNUSED);\r\nvsp1_write(vsp1, VI6_DPR_HGO_SMPPT, (7 << VI6_DPR_SMPPT_TGW_SHIFT) |\r\n(VI6_DPR_NODE_UNUSED << VI6_DPR_SMPPT_PT_SHIFT));\r\nvsp1_write(vsp1, VI6_DPR_HGT_SMPPT, (7 << VI6_DPR_SMPPT_TGW_SHIFT) |\r\n(VI6_DPR_NODE_UNUSED << VI6_DPR_SMPPT_PT_SHIFT));\r\nreturn 0;\r\n}\r\nint vsp1_device_get(struct vsp1_device *vsp1)\r\n{\r\nint ret = 0;\r\nmutex_lock(&vsp1->lock);\r\nif (vsp1->ref_count > 0)\r\ngoto done;\r\nret = clk_prepare_enable(vsp1->clock);\r\nif (ret < 0)\r\ngoto done;\r\nret = vsp1_device_init(vsp1);\r\nif (ret < 0) {\r\nclk_disable_unprepare(vsp1->clock);\r\ngoto done;\r\n}\r\ndone:\r\nif (!ret)\r\nvsp1->ref_count++;\r\nmutex_unlock(&vsp1->lock);\r\nreturn ret;\r\n}\r\nvoid vsp1_device_put(struct vsp1_device *vsp1)\r\n{\r\nmutex_lock(&vsp1->lock);\r\nif (--vsp1->ref_count == 0)\r\nclk_disable_unprepare(vsp1->clock);\r\nmutex_unlock(&vsp1->lock);\r\n}\r\nstatic int vsp1_pm_suspend(struct device *dev)\r\n{\r\nstruct vsp1_device *vsp1 = dev_get_drvdata(dev);\r\nWARN_ON(mutex_is_locked(&vsp1->lock));\r\nif (vsp1->ref_count == 0)\r\nreturn 0;\r\nclk_disable_unprepare(vsp1->clock);\r\nreturn 0;\r\n}\r\nstatic int vsp1_pm_resume(struct device *dev)\r\n{\r\nstruct vsp1_device *vsp1 = dev_get_drvdata(dev);\r\nWARN_ON(mutex_is_locked(&vsp1->lock));\r\nif (vsp1->ref_count)\r\nreturn 0;\r\nreturn clk_prepare_enable(vsp1->clock);\r\n}\r\nstatic int vsp1_parse_dt(struct vsp1_device *vsp1)\r\n{\r\nstruct device_node *np = vsp1->dev->of_node;\r\nstruct vsp1_platform_data *pdata = &vsp1->pdata;\r\nif (of_property_read_bool(np, "renesas,has-lif"))\r\npdata->features |= VSP1_HAS_LIF;\r\nif (of_property_read_bool(np, "renesas,has-lut"))\r\npdata->features |= VSP1_HAS_LUT;\r\nif (of_property_read_bool(np, "renesas,has-sru"))\r\npdata->features |= VSP1_HAS_SRU;\r\nof_property_read_u32(np, "renesas,#rpf", &pdata->rpf_count);\r\nof_property_read_u32(np, "renesas,#uds", &pdata->uds_count);\r\nof_property_read_u32(np, "renesas,#wpf", &pdata->wpf_count);\r\nif (pdata->rpf_count <= 0 || pdata->rpf_count > VSP1_MAX_RPF) {\r\ndev_err(vsp1->dev, "invalid number of RPF (%u)\n",\r\npdata->rpf_count);\r\nreturn -EINVAL;\r\n}\r\nif (pdata->uds_count <= 0 || pdata->uds_count > VSP1_MAX_UDS) {\r\ndev_err(vsp1->dev, "invalid number of UDS (%u)\n",\r\npdata->uds_count);\r\nreturn -EINVAL;\r\n}\r\nif (pdata->wpf_count <= 0 || pdata->wpf_count > VSP1_MAX_WPF) {\r\ndev_err(vsp1->dev, "invalid number of WPF (%u)\n",\r\npdata->wpf_count);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vsp1_probe(struct platform_device *pdev)\r\n{\r\nstruct vsp1_device *vsp1;\r\nstruct resource *irq;\r\nstruct resource *io;\r\nint ret;\r\nvsp1 = devm_kzalloc(&pdev->dev, sizeof(*vsp1), GFP_KERNEL);\r\nif (vsp1 == NULL)\r\nreturn -ENOMEM;\r\nvsp1->dev = &pdev->dev;\r\nmutex_init(&vsp1->lock);\r\nINIT_LIST_HEAD(&vsp1->entities);\r\nret = vsp1_parse_dt(vsp1);\r\nif (ret < 0)\r\nreturn ret;\r\nio = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nvsp1->mmio = devm_ioremap_resource(&pdev->dev, io);\r\nif (IS_ERR(vsp1->mmio))\r\nreturn PTR_ERR(vsp1->mmio);\r\nvsp1->clock = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(vsp1->clock)) {\r\ndev_err(&pdev->dev, "failed to get clock\n");\r\nreturn PTR_ERR(vsp1->clock);\r\n}\r\nirq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!irq) {\r\ndev_err(&pdev->dev, "missing IRQ\n");\r\nreturn -EINVAL;\r\n}\r\nret = devm_request_irq(&pdev->dev, irq->start, vsp1_irq_handler,\r\nIRQF_SHARED, dev_name(&pdev->dev), vsp1);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to request IRQ\n");\r\nreturn ret;\r\n}\r\nret = vsp1_create_entities(vsp1);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to create entities\n");\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, vsp1);\r\nreturn 0;\r\n}\r\nstatic int vsp1_remove(struct platform_device *pdev)\r\n{\r\nstruct vsp1_device *vsp1 = platform_get_drvdata(pdev);\r\nvsp1_destroy_entities(vsp1);\r\nreturn 0;\r\n}
