static void kdb_show_stack(struct task_struct *p, void *addr)\r\n{\r\nint old_lvl = console_loglevel;\r\nconsole_loglevel = CONSOLE_LOGLEVEL_MOTORMOUTH;\r\nkdb_trap_printk++;\r\nkdb_set_current_task(p);\r\nif (addr) {\r\nshow_stack((struct task_struct *)p, addr);\r\n} else if (kdb_current_regs) {\r\n#ifdef CONFIG_X86\r\nshow_stack(p, &kdb_current_regs->sp);\r\n#else\r\nshow_stack(p, NULL);\r\n#endif\r\n} else {\r\nshow_stack(p, NULL);\r\n}\r\nconsole_loglevel = old_lvl;\r\nkdb_trap_printk--;\r\n}\r\nstatic int\r\nkdb_bt1(struct task_struct *p, unsigned long mask,\r\nint argcount, int btaprompt)\r\n{\r\nchar buffer[2];\r\nif (kdb_getarea(buffer[0], (unsigned long)p) ||\r\nkdb_getarea(buffer[0], (unsigned long)(p+1)-1))\r\nreturn KDB_BADADDR;\r\nif (!kdb_task_state(p, mask))\r\nreturn 0;\r\nkdb_printf("Stack traceback for pid %d\n", p->pid);\r\nkdb_ps1(p);\r\nkdb_show_stack(p, NULL);\r\nif (btaprompt) {\r\nkdb_getstr(buffer, sizeof(buffer),\r\n"Enter <q> to end, <cr> to continue:");\r\nif (buffer[0] == 'q') {\r\nkdb_printf("\n");\r\nreturn 1;\r\n}\r\n}\r\ntouch_nmi_watchdog();\r\nreturn 0;\r\n}\r\nint\r\nkdb_bt(int argc, const char **argv)\r\n{\r\nint diag;\r\nint argcount = 5;\r\nint btaprompt = 1;\r\nint nextarg;\r\nunsigned long addr;\r\nlong offset;\r\nkdbgetintenv("BTAPROMPT", &btaprompt);\r\nif (strcmp(argv[0], "bta") == 0) {\r\nstruct task_struct *g, *p;\r\nunsigned long cpu;\r\nunsigned long mask = kdb_task_state_string(argc ? argv[1] :\r\nNULL);\r\nif (argc == 0)\r\nkdb_ps_suppressed();\r\nfor_each_online_cpu(cpu) {\r\np = kdb_curr_task(cpu);\r\nif (kdb_bt1(p, mask, argcount, btaprompt))\r\nreturn 0;\r\n}\r\nkdb_do_each_thread(g, p) {\r\nif (KDB_FLAG(CMD_INTERRUPT))\r\nreturn 0;\r\nif (task_curr(p))\r\ncontinue;\r\nif (kdb_bt1(p, mask, argcount, btaprompt))\r\nreturn 0;\r\n} kdb_while_each_thread(g, p);\r\n} else if (strcmp(argv[0], "btp") == 0) {\r\nstruct task_struct *p;\r\nunsigned long pid;\r\nif (argc != 1)\r\nreturn KDB_ARGCOUNT;\r\ndiag = kdbgetularg((char *)argv[1], &pid);\r\nif (diag)\r\nreturn diag;\r\np = find_task_by_pid_ns(pid, &init_pid_ns);\r\nif (p) {\r\nkdb_set_current_task(p);\r\nreturn kdb_bt1(p, ~0UL, argcount, 0);\r\n}\r\nkdb_printf("No process with pid == %ld found\n", pid);\r\nreturn 0;\r\n} else if (strcmp(argv[0], "btt") == 0) {\r\nif (argc != 1)\r\nreturn KDB_ARGCOUNT;\r\ndiag = kdbgetularg((char *)argv[1], &addr);\r\nif (diag)\r\nreturn diag;\r\nkdb_set_current_task((struct task_struct *)addr);\r\nreturn kdb_bt1((struct task_struct *)addr, ~0UL, argcount, 0);\r\n} else if (strcmp(argv[0], "btc") == 0) {\r\nunsigned long cpu = ~0;\r\nstruct task_struct *save_current_task = kdb_current_task;\r\nchar buf[80];\r\nif (argc > 1)\r\nreturn KDB_ARGCOUNT;\r\nif (argc == 1) {\r\ndiag = kdbgetularg((char *)argv[1], &cpu);\r\nif (diag)\r\nreturn diag;\r\n}\r\nargv = NULL;\r\nif (cpu != ~0) {\r\nif (cpu >= num_possible_cpus() || !cpu_online(cpu)) {\r\nkdb_printf("no process for cpu %ld\n", cpu);\r\nreturn 0;\r\n}\r\nsprintf(buf, "btt 0x%p\n", KDB_TSK(cpu));\r\nkdb_parse(buf);\r\nreturn 0;\r\n}\r\nkdb_printf("btc: cpu status: ");\r\nkdb_parse("cpu\n");\r\nfor_each_online_cpu(cpu) {\r\nsprintf(buf, "btt 0x%p\n", KDB_TSK(cpu));\r\nkdb_parse(buf);\r\ntouch_nmi_watchdog();\r\n}\r\nkdb_set_current_task(save_current_task);\r\nreturn 0;\r\n} else {\r\nif (argc) {\r\nnextarg = 1;\r\ndiag = kdbgetaddrarg(argc, argv, &nextarg, &addr,\r\n&offset, NULL);\r\nif (diag)\r\nreturn diag;\r\nkdb_show_stack(kdb_current_task, (void *)addr);\r\nreturn 0;\r\n} else {\r\nreturn kdb_bt1(kdb_current_task, ~0UL, argcount, 0);\r\n}\r\n}\r\nreturn 0;\r\n}
