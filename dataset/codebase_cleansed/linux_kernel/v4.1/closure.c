static inline void closure_put_after_sub(struct closure *cl, int flags)\r\n{\r\nint r = flags & CLOSURE_REMAINING_MASK;\r\nBUG_ON(flags & CLOSURE_GUARD_MASK);\r\nBUG_ON(!r && (flags & ~CLOSURE_DESTRUCTOR));\r\nif (r == 1 && (flags & CLOSURE_SLEEPING))\r\nwake_up_process(cl->task);\r\nif (!r) {\r\nif (cl->fn && !(flags & CLOSURE_DESTRUCTOR)) {\r\natomic_set(&cl->remaining,\r\nCLOSURE_REMAINING_INITIALIZER);\r\nclosure_queue(cl);\r\n} else {\r\nstruct closure *parent = cl->parent;\r\nclosure_fn *destructor = cl->fn;\r\nclosure_debug_destroy(cl);\r\nif (destructor)\r\ndestructor(cl);\r\nif (parent)\r\nclosure_put(parent);\r\n}\r\n}\r\n}\r\nvoid closure_sub(struct closure *cl, int v)\r\n{\r\nclosure_put_after_sub(cl, atomic_sub_return(v, &cl->remaining));\r\n}\r\nvoid closure_put(struct closure *cl)\r\n{\r\nclosure_put_after_sub(cl, atomic_dec_return(&cl->remaining));\r\n}\r\nvoid __closure_wake_up(struct closure_waitlist *wait_list)\r\n{\r\nstruct llist_node *list;\r\nstruct closure *cl;\r\nstruct llist_node *reverse = NULL;\r\nlist = llist_del_all(&wait_list->list);\r\nwhile (list) {\r\nstruct llist_node *t = list;\r\nlist = llist_next(list);\r\nt->next = reverse;\r\nreverse = t;\r\n}\r\nwhile (reverse) {\r\ncl = container_of(reverse, struct closure, list);\r\nreverse = llist_next(reverse);\r\nclosure_set_waiting(cl, 0);\r\nclosure_sub(cl, CLOSURE_WAITING + 1);\r\n}\r\n}\r\nbool closure_wait(struct closure_waitlist *waitlist, struct closure *cl)\r\n{\r\nif (atomic_read(&cl->remaining) & CLOSURE_WAITING)\r\nreturn false;\r\nclosure_set_waiting(cl, _RET_IP_);\r\natomic_add(CLOSURE_WAITING + 1, &cl->remaining);\r\nllist_add(&cl->list, &waitlist->list);\r\nreturn true;\r\n}\r\nvoid closure_sync(struct closure *cl)\r\n{\r\nwhile (1) {\r\n__closure_start_sleep(cl);\r\nclosure_set_ret_ip(cl);\r\nif ((atomic_read(&cl->remaining) &\r\nCLOSURE_REMAINING_MASK) == 1)\r\nbreak;\r\nschedule();\r\n}\r\n__closure_end_sleep(cl);\r\n}\r\nvoid closure_debug_create(struct closure *cl)\r\n{\r\nunsigned long flags;\r\nBUG_ON(cl->magic == CLOSURE_MAGIC_ALIVE);\r\ncl->magic = CLOSURE_MAGIC_ALIVE;\r\nspin_lock_irqsave(&closure_list_lock, flags);\r\nlist_add(&cl->all, &closure_list);\r\nspin_unlock_irqrestore(&closure_list_lock, flags);\r\n}\r\nvoid closure_debug_destroy(struct closure *cl)\r\n{\r\nunsigned long flags;\r\nBUG_ON(cl->magic != CLOSURE_MAGIC_ALIVE);\r\ncl->magic = CLOSURE_MAGIC_DEAD;\r\nspin_lock_irqsave(&closure_list_lock, flags);\r\nlist_del(&cl->all);\r\nspin_unlock_irqrestore(&closure_list_lock, flags);\r\n}\r\nstatic int debug_seq_show(struct seq_file *f, void *data)\r\n{\r\nstruct closure *cl;\r\nspin_lock_irq(&closure_list_lock);\r\nlist_for_each_entry(cl, &closure_list, all) {\r\nint r = atomic_read(&cl->remaining);\r\nseq_printf(f, "%p: %pF -> %pf p %p r %i ",\r\ncl, (void *) cl->ip, cl->fn, cl->parent,\r\nr & CLOSURE_REMAINING_MASK);\r\nseq_printf(f, "%s%s%s%s\n",\r\ntest_bit(WORK_STRUCT_PENDING,\r\nwork_data_bits(&cl->work)) ? "Q" : "",\r\nr & CLOSURE_RUNNING ? "R" : "",\r\nr & CLOSURE_STACK ? "S" : "",\r\nr & CLOSURE_SLEEPING ? "Sl" : "");\r\nif (r & CLOSURE_WAITING)\r\nseq_printf(f, " W %pF\n",\r\n(void *) cl->waiting_on);\r\nseq_printf(f, "\n");\r\n}\r\nspin_unlock_irq(&closure_list_lock);\r\nreturn 0;\r\n}\r\nstatic int debug_seq_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, debug_seq_show, NULL);\r\n}\r\nvoid __init closure_debug_init(void)\r\n{\r\ndebug = debugfs_create_file("closures", 0400, NULL, NULL, &debug_ops);\r\n}
