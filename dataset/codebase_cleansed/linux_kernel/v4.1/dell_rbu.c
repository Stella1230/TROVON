static void init_packet_head(void)\r\n{\r\nINIT_LIST_HEAD(&packet_data_head.list);\r\nrbu_data.packet_read_count = 0;\r\nrbu_data.num_packets = 0;\r\nrbu_data.packetsize = 0;\r\nrbu_data.imagesize = 0;\r\n}\r\nstatic int create_packet(void *data, size_t length)\r\n{\r\nstruct packet_data *newpacket;\r\nint ordernum = 0;\r\nint retval = 0;\r\nunsigned int packet_array_size = 0;\r\nvoid **invalid_addr_packet_array = NULL;\r\nvoid *packet_data_temp_buf = NULL;\r\nunsigned int idx = 0;\r\npr_debug("create_packet: entry \n");\r\nif (!rbu_data.packetsize) {\r\npr_debug("create_packet: packetsize not specified\n");\r\nretval = -EINVAL;\r\ngoto out_noalloc;\r\n}\r\nspin_unlock(&rbu_data.lock);\r\nnewpacket = kzalloc(sizeof (struct packet_data), GFP_KERNEL);\r\nif (!newpacket) {\r\nprintk(KERN_WARNING\r\n"dell_rbu:%s: failed to allocate new "\r\n"packet\n", __func__);\r\nretval = -ENOMEM;\r\nspin_lock(&rbu_data.lock);\r\ngoto out_noalloc;\r\n}\r\nordernum = get_order(length);\r\npacket_array_size = max(\r\n(unsigned int)(allocation_floor / rbu_data.packetsize),\r\n(unsigned int)1);\r\ninvalid_addr_packet_array = kzalloc(packet_array_size * sizeof(void*),\r\nGFP_KERNEL);\r\nif (!invalid_addr_packet_array) {\r\nprintk(KERN_WARNING\r\n"dell_rbu:%s: failed to allocate "\r\n"invalid_addr_packet_array \n",\r\n__func__);\r\nretval = -ENOMEM;\r\nspin_lock(&rbu_data.lock);\r\ngoto out_alloc_packet;\r\n}\r\nwhile (!packet_data_temp_buf) {\r\npacket_data_temp_buf = (unsigned char *)\r\n__get_free_pages(GFP_KERNEL, ordernum);\r\nif (!packet_data_temp_buf) {\r\nprintk(KERN_WARNING\r\n"dell_rbu:%s: failed to allocate new "\r\n"packet\n", __func__);\r\nretval = -ENOMEM;\r\nspin_lock(&rbu_data.lock);\r\ngoto out_alloc_packet_array;\r\n}\r\nif ((unsigned long)virt_to_phys(packet_data_temp_buf)\r\n< allocation_floor) {\r\npr_debug("packet 0x%lx below floor at 0x%lx.\n",\r\n(unsigned long)virt_to_phys(\r\npacket_data_temp_buf),\r\nallocation_floor);\r\ninvalid_addr_packet_array[idx++] = packet_data_temp_buf;\r\npacket_data_temp_buf = NULL;\r\n}\r\n}\r\nspin_lock(&rbu_data.lock);\r\nnewpacket->data = packet_data_temp_buf;\r\npr_debug("create_packet: newpacket at physical addr %lx\n",\r\n(unsigned long)virt_to_phys(newpacket->data));\r\nnewpacket->length = length;\r\nnewpacket->ordernum = ordernum;\r\n++rbu_data.num_packets;\r\nINIT_LIST_HEAD(&newpacket->list);\r\nlist_add_tail(&newpacket->list, &packet_data_head.list);\r\nmemcpy(newpacket->data, data, length);\r\npr_debug("create_packet: exit \n");\r\nout_alloc_packet_array:\r\nfor (;idx>0;idx--) {\r\npr_debug("freeing unused packet below floor 0x%lx.\n",\r\n(unsigned long)virt_to_phys(\r\ninvalid_addr_packet_array[idx-1]));\r\nfree_pages((unsigned long)invalid_addr_packet_array[idx-1],\r\nordernum);\r\n}\r\nkfree(invalid_addr_packet_array);\r\nout_alloc_packet:\r\nif (retval)\r\nkfree(newpacket);\r\nout_noalloc:\r\nreturn retval;\r\n}\r\nstatic int packetize_data(const u8 *data, size_t length)\r\n{\r\nint rc = 0;\r\nint done = 0;\r\nint packet_length;\r\nu8 *temp;\r\nu8 *end = (u8 *) data + length;\r\npr_debug("packetize_data: data length %zd\n", length);\r\nif (!rbu_data.packetsize) {\r\nprintk(KERN_WARNING\r\n"dell_rbu: packetsize not specified\n");\r\nreturn -EIO;\r\n}\r\ntemp = (u8 *) data;\r\nwhile (!done) {\r\nif ((temp + rbu_data.packetsize) < end)\r\npacket_length = rbu_data.packetsize;\r\nelse {\r\npacket_length = end - temp;\r\ndone = 1;\r\n}\r\nif ((rc = create_packet(temp, packet_length)))\r\nreturn rc;\r\npr_debug("%p:%td\n", temp, (end - temp));\r\ntemp += packet_length;\r\n}\r\nrbu_data.imagesize = length;\r\nreturn rc;\r\n}\r\nstatic int do_packet_read(char *data, struct list_head *ptemp_list,\r\nint length, int bytes_read, int *list_read_count)\r\n{\r\nvoid *ptemp_buf;\r\nstruct packet_data *newpacket = NULL;\r\nint bytes_copied = 0;\r\nint j = 0;\r\nnewpacket = list_entry(ptemp_list, struct packet_data, list);\r\n*list_read_count += newpacket->length;\r\nif (*list_read_count > bytes_read) {\r\nj = newpacket->length - (*list_read_count - bytes_read);\r\nptemp_buf = (u8 *) newpacket->data + j;\r\nif (length > (*list_read_count - bytes_read))\r\nbytes_copied = (*list_read_count - bytes_read);\r\nelse\r\nbytes_copied = length;\r\nmemcpy(data, ptemp_buf, bytes_copied);\r\n}\r\nreturn bytes_copied;\r\n}\r\nstatic int packet_read_list(char *data, size_t * pread_length)\r\n{\r\nstruct list_head *ptemp_list;\r\nint temp_count = 0;\r\nint bytes_copied = 0;\r\nint bytes_read = 0;\r\nint remaining_bytes = 0;\r\nchar *pdest = data;\r\nif (0 == rbu_data.num_packets)\r\nreturn -ENOMEM;\r\nremaining_bytes = *pread_length;\r\nbytes_read = rbu_data.packet_read_count;\r\nptemp_list = (&packet_data_head.list)->next;\r\nwhile (!list_empty(ptemp_list)) {\r\nbytes_copied = do_packet_read(pdest, ptemp_list,\r\nremaining_bytes, bytes_read, &temp_count);\r\nremaining_bytes -= bytes_copied;\r\nbytes_read += bytes_copied;\r\npdest += bytes_copied;\r\nif (remaining_bytes == 0)\r\nbreak;\r\nptemp_list = ptemp_list->next;\r\n}\r\n*pread_length = bytes_read - rbu_data.packet_read_count;\r\nrbu_data.packet_read_count = bytes_read;\r\nreturn 0;\r\n}\r\nstatic void packet_empty_list(void)\r\n{\r\nstruct list_head *ptemp_list;\r\nstruct list_head *pnext_list;\r\nstruct packet_data *newpacket;\r\nptemp_list = (&packet_data_head.list)->next;\r\nwhile (!list_empty(ptemp_list)) {\r\nnewpacket =\r\nlist_entry(ptemp_list, struct packet_data, list);\r\npnext_list = ptemp_list->next;\r\nlist_del(ptemp_list);\r\nptemp_list = pnext_list;\r\nmemset(newpacket->data, 0, rbu_data.packetsize);\r\nfree_pages((unsigned long) newpacket->data,\r\nnewpacket->ordernum);\r\nkfree(newpacket);\r\n}\r\nrbu_data.packet_read_count = 0;\r\nrbu_data.num_packets = 0;\r\nrbu_data.imagesize = 0;\r\n}\r\nstatic void img_update_free(void)\r\n{\r\nif (!rbu_data.image_update_buffer)\r\nreturn;\r\nmemset(rbu_data.image_update_buffer, 0,\r\nrbu_data.image_update_buffer_size);\r\nif (rbu_data.dma_alloc == 1)\r\ndma_free_coherent(NULL, rbu_data.bios_image_size,\r\nrbu_data.image_update_buffer, dell_rbu_dmaaddr);\r\nelse\r\nfree_pages((unsigned long) rbu_data.image_update_buffer,\r\nrbu_data.image_update_ordernum);\r\nrbu_data.image_update_ordernum = -1;\r\nrbu_data.image_update_buffer = NULL;\r\nrbu_data.image_update_buffer_size = 0;\r\nrbu_data.bios_image_size = 0;\r\nrbu_data.dma_alloc = 0;\r\n}\r\nstatic int img_update_realloc(unsigned long size)\r\n{\r\nunsigned char *image_update_buffer = NULL;\r\nunsigned long rc;\r\nunsigned long img_buf_phys_addr;\r\nint ordernum;\r\nint dma_alloc = 0;\r\nif (rbu_data.image_update_buffer_size >= size) {\r\nif ((size != 0) && (rbu_data.image_update_buffer == NULL)) {\r\nprintk(KERN_ERR "dell_rbu:%s: corruption "\r\n"check failed\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nimg_update_free();\r\nspin_unlock(&rbu_data.lock);\r\nordernum = get_order(size);\r\nimage_update_buffer =\r\n(unsigned char *) __get_free_pages(GFP_KERNEL, ordernum);\r\nimg_buf_phys_addr =\r\n(unsigned long) virt_to_phys(image_update_buffer);\r\nif (img_buf_phys_addr > BIOS_SCAN_LIMIT) {\r\nfree_pages((unsigned long) image_update_buffer, ordernum);\r\nordernum = -1;\r\nimage_update_buffer = dma_alloc_coherent(NULL, size,\r\n&dell_rbu_dmaaddr, GFP_KERNEL);\r\ndma_alloc = 1;\r\n}\r\nspin_lock(&rbu_data.lock);\r\nif (image_update_buffer != NULL) {\r\nrbu_data.image_update_buffer = image_update_buffer;\r\nrbu_data.image_update_buffer_size = size;\r\nrbu_data.bios_image_size =\r\nrbu_data.image_update_buffer_size;\r\nrbu_data.image_update_ordernum = ordernum;\r\nrbu_data.dma_alloc = dma_alloc;\r\nrc = 0;\r\n} else {\r\npr_debug("Not enough memory for image update:"\r\n"size = %ld\n", size);\r\nrc = -ENOMEM;\r\n}\r\nreturn rc;\r\n}\r\nstatic ssize_t read_packet_data(char *buffer, loff_t pos, size_t count)\r\n{\r\nint retval;\r\nsize_t bytes_left;\r\nsize_t data_length;\r\nchar *ptempBuf = buffer;\r\nif (rbu_data.num_packets == 0) {\r\npr_debug("read_packet_data: no packets written\n");\r\nretval = -ENOMEM;\r\ngoto read_rbu_data_exit;\r\n}\r\nif (pos > rbu_data.imagesize) {\r\nretval = 0;\r\nprintk(KERN_WARNING "dell_rbu:read_packet_data: "\r\n"data underrun\n");\r\ngoto read_rbu_data_exit;\r\n}\r\nbytes_left = rbu_data.imagesize - pos;\r\ndata_length = min(bytes_left, count);\r\nif ((retval = packet_read_list(ptempBuf, &data_length)) < 0)\r\ngoto read_rbu_data_exit;\r\nif ((pos + count) > rbu_data.imagesize) {\r\nrbu_data.packet_read_count = 0;\r\nretval = bytes_left;\r\n} else\r\nretval = count;\r\nread_rbu_data_exit:\r\nreturn retval;\r\n}\r\nstatic ssize_t read_rbu_mono_data(char *buffer, loff_t pos, size_t count)\r\n{\r\nif ((rbu_data.image_update_buffer == NULL) ||\r\n(rbu_data.bios_image_size == 0)) {\r\npr_debug("read_rbu_data_mono: image_update_buffer %p ,"\r\n"bios_image_size %lu\n",\r\nrbu_data.image_update_buffer,\r\nrbu_data.bios_image_size);\r\nreturn -ENOMEM;\r\n}\r\nreturn memory_read_from_buffer(buffer, count, &pos,\r\nrbu_data.image_update_buffer, rbu_data.bios_image_size);\r\n}\r\nstatic ssize_t read_rbu_data(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buffer, loff_t pos, size_t count)\r\n{\r\nssize_t ret_count = 0;\r\nspin_lock(&rbu_data.lock);\r\nif (!strcmp(image_type, "mono"))\r\nret_count = read_rbu_mono_data(buffer, pos, count);\r\nelse if (!strcmp(image_type, "packet"))\r\nret_count = read_packet_data(buffer, pos, count);\r\nelse\r\npr_debug("read_rbu_data: invalid image type specified\n");\r\nspin_unlock(&rbu_data.lock);\r\nreturn ret_count;\r\n}\r\nstatic void callbackfn_rbu(const struct firmware *fw, void *context)\r\n{\r\nrbu_data.entry_created = 0;\r\nif (!fw)\r\nreturn;\r\nif (!fw->size)\r\ngoto out;\r\nspin_lock(&rbu_data.lock);\r\nif (!strcmp(image_type, "mono")) {\r\nif (!img_update_realloc(fw->size))\r\nmemcpy(rbu_data.image_update_buffer,\r\nfw->data, fw->size);\r\n} else if (!strcmp(image_type, "packet")) {\r\npacket_empty_list();\r\nif (packetize_data(fw->data, fw->size))\r\npacket_empty_list();\r\n} else\r\npr_debug("invalid image type specified.\n");\r\nspin_unlock(&rbu_data.lock);\r\nout:\r\nrelease_firmware(fw);\r\n}\r\nstatic ssize_t read_rbu_image_type(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buffer, loff_t pos, size_t count)\r\n{\r\nint size = 0;\r\nif (!pos)\r\nsize = scnprintf(buffer, count, "%s\n", image_type);\r\nreturn size;\r\n}\r\nstatic ssize_t write_rbu_image_type(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buffer, loff_t pos, size_t count)\r\n{\r\nint rc = count;\r\nint req_firm_rc = 0;\r\nint i;\r\nspin_lock(&rbu_data.lock);\r\nfor (i = 0; i < count; ++i)\r\nif (buffer[i] == '\n' || buffer[i] == ' ') {\r\nbuffer[i] = '\0';\r\nbreak;\r\n}\r\nif (i == count)\r\nbuffer[count] = '\0';\r\nif (strstr(buffer, "mono"))\r\nstrcpy(image_type, "mono");\r\nelse if (strstr(buffer, "packet"))\r\nstrcpy(image_type, "packet");\r\nelse if (strstr(buffer, "init")) {\r\nif (!rbu_data.entry_created) {\r\nspin_unlock(&rbu_data.lock);\r\nreq_firm_rc = request_firmware_nowait(THIS_MODULE,\r\nFW_ACTION_NOHOTPLUG, "dell_rbu",\r\n&rbu_device->dev, GFP_KERNEL, &context,\r\ncallbackfn_rbu);\r\nif (req_firm_rc) {\r\nprintk(KERN_ERR\r\n"dell_rbu:%s request_firmware_nowait"\r\n" failed %d\n", __func__, rc);\r\nrc = -EIO;\r\n} else\r\nrbu_data.entry_created = 1;\r\nspin_lock(&rbu_data.lock);\r\n}\r\n} else {\r\nprintk(KERN_WARNING "dell_rbu: image_type is invalid\n");\r\nspin_unlock(&rbu_data.lock);\r\nreturn -EINVAL;\r\n}\r\npacket_empty_list();\r\nimg_update_free();\r\nspin_unlock(&rbu_data.lock);\r\nreturn rc;\r\n}\r\nstatic ssize_t read_rbu_packet_size(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buffer, loff_t pos, size_t count)\r\n{\r\nint size = 0;\r\nif (!pos) {\r\nspin_lock(&rbu_data.lock);\r\nsize = scnprintf(buffer, count, "%lu\n", rbu_data.packetsize);\r\nspin_unlock(&rbu_data.lock);\r\n}\r\nreturn size;\r\n}\r\nstatic ssize_t write_rbu_packet_size(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buffer, loff_t pos, size_t count)\r\n{\r\nunsigned long temp;\r\nspin_lock(&rbu_data.lock);\r\npacket_empty_list();\r\nsscanf(buffer, "%lu", &temp);\r\nif (temp < 0xffffffff)\r\nrbu_data.packetsize = temp;\r\nspin_unlock(&rbu_data.lock);\r\nreturn count;\r\n}\r\nstatic int __init dcdrbu_init(void)\r\n{\r\nint rc;\r\nspin_lock_init(&rbu_data.lock);\r\ninit_packet_head();\r\nrbu_device = platform_device_register_simple("dell_rbu", -1, NULL, 0);\r\nif (IS_ERR(rbu_device)) {\r\nprintk(KERN_ERR\r\n"dell_rbu:%s:platform_device_register_simple "\r\n"failed\n", __func__);\r\nreturn PTR_ERR(rbu_device);\r\n}\r\nrc = sysfs_create_bin_file(&rbu_device->dev.kobj, &rbu_data_attr);\r\nif (rc)\r\ngoto out_devreg;\r\nrc = sysfs_create_bin_file(&rbu_device->dev.kobj, &rbu_image_type_attr);\r\nif (rc)\r\ngoto out_data;\r\nrc = sysfs_create_bin_file(&rbu_device->dev.kobj,\r\n&rbu_packet_size_attr);\r\nif (rc)\r\ngoto out_imtype;\r\nrbu_data.entry_created = 0;\r\nreturn 0;\r\nout_imtype:\r\nsysfs_remove_bin_file(&rbu_device->dev.kobj, &rbu_image_type_attr);\r\nout_data:\r\nsysfs_remove_bin_file(&rbu_device->dev.kobj, &rbu_data_attr);\r\nout_devreg:\r\nplatform_device_unregister(rbu_device);\r\nreturn rc;\r\n}\r\nstatic __exit void dcdrbu_exit(void)\r\n{\r\nspin_lock(&rbu_data.lock);\r\npacket_empty_list();\r\nimg_update_free();\r\nspin_unlock(&rbu_data.lock);\r\nplatform_device_unregister(rbu_device);\r\n}
