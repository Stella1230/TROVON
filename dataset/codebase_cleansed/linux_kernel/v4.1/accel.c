static int viafb_set_bpp(void __iomem *engine, u8 bpp)\r\n{\r\nu32 gemode;\r\ngemode = readl(engine + VIA_REG_GEMODE) & 0xfffffcfc;\r\nswitch (bpp) {\r\ncase 8:\r\ngemode |= VIA_GEM_8bpp;\r\nbreak;\r\ncase 16:\r\ngemode |= VIA_GEM_16bpp;\r\nbreak;\r\ncase 32:\r\ngemode |= VIA_GEM_32bpp;\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "viafb_set_bpp: Unsupported bpp %d\n", bpp);\r\nreturn -EINVAL;\r\n}\r\nwritel(gemode, engine + VIA_REG_GEMODE);\r\nreturn 0;\r\n}\r\nstatic int hw_bitblt_1(void __iomem *engine, u8 op, u32 width, u32 height,\r\nu8 dst_bpp, u32 dst_addr, u32 dst_pitch, u32 dst_x, u32 dst_y,\r\nu32 *src_mem, u32 src_addr, u32 src_pitch, u32 src_x, u32 src_y,\r\nu32 fg_color, u32 bg_color, u8 fill_rop)\r\n{\r\nu32 ge_cmd = 0, tmp, i;\r\nint ret;\r\nif (!op || op > 3) {\r\nprintk(KERN_WARNING "hw_bitblt_1: Invalid operation: %d\n", op);\r\nreturn -EINVAL;\r\n}\r\nif (op != VIA_BITBLT_FILL && !src_mem && src_addr == dst_addr) {\r\nif (src_x < dst_x) {\r\nge_cmd |= 0x00008000;\r\nsrc_x += width - 1;\r\ndst_x += width - 1;\r\n}\r\nif (src_y < dst_y) {\r\nge_cmd |= 0x00004000;\r\nsrc_y += height - 1;\r\ndst_y += height - 1;\r\n}\r\n}\r\nif (op == VIA_BITBLT_FILL) {\r\nswitch (fill_rop) {\r\ncase 0x00:\r\ncase 0x5A:\r\ncase 0xF0:\r\ncase 0xFF:\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "hw_bitblt_1: Invalid fill rop: "\r\n"%u\n", fill_rop);\r\nreturn -EINVAL;\r\n}\r\n}\r\nret = viafb_set_bpp(engine, dst_bpp);\r\nif (ret)\r\nreturn ret;\r\nif (op != VIA_BITBLT_FILL) {\r\nif (src_x & (op == VIA_BITBLT_MONO ? 0xFFFF8000 : 0xFFFFF000)\r\n|| src_y & 0xFFFFF000) {\r\nprintk(KERN_WARNING "hw_bitblt_1: Unsupported source "\r\n"x/y %d %d\n", src_x, src_y);\r\nreturn -EINVAL;\r\n}\r\ntmp = src_x | (src_y << 16);\r\nwritel(tmp, engine + 0x08);\r\n}\r\nif (dst_x & 0xFFFFF000 || dst_y & 0xFFFFF000) {\r\nprintk(KERN_WARNING "hw_bitblt_1: Unsupported destination x/y "\r\n"%d %d\n", dst_x, dst_y);\r\nreturn -EINVAL;\r\n}\r\ntmp = dst_x | (dst_y << 16);\r\nwritel(tmp, engine + 0x0C);\r\nif ((width - 1) & 0xFFFFF000 || (height - 1) & 0xFFFFF000) {\r\nprintk(KERN_WARNING "hw_bitblt_1: Unsupported width/height "\r\n"%d %d\n", width, height);\r\nreturn -EINVAL;\r\n}\r\ntmp = (width - 1) | ((height - 1) << 16);\r\nwritel(tmp, engine + 0x10);\r\nif (op != VIA_BITBLT_COLOR)\r\nwritel(fg_color, engine + 0x18);\r\nif (op == VIA_BITBLT_MONO)\r\nwritel(bg_color, engine + 0x1C);\r\nif (op != VIA_BITBLT_FILL) {\r\ntmp = src_mem ? 0 : src_addr;\r\nif (dst_addr & 0xE0000007) {\r\nprintk(KERN_WARNING "hw_bitblt_1: Unsupported source "\r\n"address %X\n", tmp);\r\nreturn -EINVAL;\r\n}\r\ntmp >>= 3;\r\nwritel(tmp, engine + 0x30);\r\n}\r\nif (dst_addr & 0xE0000007) {\r\nprintk(KERN_WARNING "hw_bitblt_1: Unsupported destination "\r\n"address %X\n", dst_addr);\r\nreturn -EINVAL;\r\n}\r\ntmp = dst_addr >> 3;\r\nwritel(tmp, engine + 0x34);\r\nif (op == VIA_BITBLT_FILL)\r\ntmp = 0;\r\nelse\r\ntmp = src_pitch;\r\nif (tmp & 0xFFFFC007 || dst_pitch & 0xFFFFC007) {\r\nprintk(KERN_WARNING "hw_bitblt_1: Unsupported pitch %X %X\n",\r\ntmp, dst_pitch);\r\nreturn -EINVAL;\r\n}\r\ntmp = VIA_PITCH_ENABLE | (tmp >> 3) | (dst_pitch << (16 - 3));\r\nwritel(tmp, engine + 0x38);\r\nif (op == VIA_BITBLT_FILL)\r\nge_cmd |= fill_rop << 24 | 0x00002000 | 0x00000001;\r\nelse {\r\nge_cmd |= 0xCC000000;\r\nif (src_mem)\r\nge_cmd |= 0x00000040;\r\nif (op == VIA_BITBLT_MONO)\r\nge_cmd |= 0x00000002 | 0x00000100 | 0x00020000;\r\nelse\r\nge_cmd |= 0x00000001;\r\n}\r\nwritel(ge_cmd, engine);\r\nif (op == VIA_BITBLT_FILL || !src_mem)\r\nreturn 0;\r\ntmp = (width * height * (op == VIA_BITBLT_MONO ? 1 : (dst_bpp >> 3)) +\r\n3) >> 2;\r\nfor (i = 0; i < tmp; i++)\r\nwritel(src_mem[i], engine + VIA_MMIO_BLTBASE);\r\nreturn 0;\r\n}\r\nstatic int hw_bitblt_2(void __iomem *engine, u8 op, u32 width, u32 height,\r\nu8 dst_bpp, u32 dst_addr, u32 dst_pitch, u32 dst_x, u32 dst_y,\r\nu32 *src_mem, u32 src_addr, u32 src_pitch, u32 src_x, u32 src_y,\r\nu32 fg_color, u32 bg_color, u8 fill_rop)\r\n{\r\nu32 ge_cmd = 0, tmp, i;\r\nint ret;\r\nif (!op || op > 3) {\r\nprintk(KERN_WARNING "hw_bitblt_2: Invalid operation: %d\n", op);\r\nreturn -EINVAL;\r\n}\r\nif (op != VIA_BITBLT_FILL && !src_mem && src_addr == dst_addr) {\r\nif (src_x < dst_x) {\r\nge_cmd |= 0x00008000;\r\nsrc_x += width - 1;\r\ndst_x += width - 1;\r\n}\r\nif (src_y < dst_y) {\r\nge_cmd |= 0x00004000;\r\nsrc_y += height - 1;\r\ndst_y += height - 1;\r\n}\r\n}\r\nif (op == VIA_BITBLT_FILL) {\r\nswitch (fill_rop) {\r\ncase 0x00:\r\ncase 0x5A:\r\ncase 0xF0:\r\ncase 0xFF:\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "hw_bitblt_2: Invalid fill rop: "\r\n"%u\n", fill_rop);\r\nreturn -EINVAL;\r\n}\r\n}\r\nret = viafb_set_bpp(engine, dst_bpp);\r\nif (ret)\r\nreturn ret;\r\nif (op == VIA_BITBLT_FILL)\r\ntmp = 0;\r\nelse\r\ntmp = src_pitch;\r\nif (tmp & 0xFFFFC007 || dst_pitch & 0xFFFFC007) {\r\nprintk(KERN_WARNING "hw_bitblt_2: Unsupported pitch %X %X\n",\r\ntmp, dst_pitch);\r\nreturn -EINVAL;\r\n}\r\ntmp = (tmp >> 3) | (dst_pitch << (16 - 3));\r\nwritel(tmp, engine + 0x08);\r\nif ((width - 1) & 0xFFFFF000 || (height - 1) & 0xFFFFF000) {\r\nprintk(KERN_WARNING "hw_bitblt_2: Unsupported width/height "\r\n"%d %d\n", width, height);\r\nreturn -EINVAL;\r\n}\r\ntmp = (width - 1) | ((height - 1) << 16);\r\nwritel(tmp, engine + 0x0C);\r\nif (dst_x & 0xFFFFF000 || dst_y & 0xFFFFF000) {\r\nprintk(KERN_WARNING "hw_bitblt_2: Unsupported destination x/y "\r\n"%d %d\n", dst_x, dst_y);\r\nreturn -EINVAL;\r\n}\r\ntmp = dst_x | (dst_y << 16);\r\nwritel(tmp, engine + 0x10);\r\nif (dst_addr & 0xE0000007) {\r\nprintk(KERN_WARNING "hw_bitblt_2: Unsupported destination "\r\n"address %X\n", dst_addr);\r\nreturn -EINVAL;\r\n}\r\ntmp = dst_addr >> 3;\r\nwritel(tmp, engine + 0x14);\r\nif (op != VIA_BITBLT_FILL) {\r\nif (src_x & (op == VIA_BITBLT_MONO ? 0xFFFF8000 : 0xFFFFF000)\r\n|| src_y & 0xFFFFF000) {\r\nprintk(KERN_WARNING "hw_bitblt_2: Unsupported source "\r\n"x/y %d %d\n", src_x, src_y);\r\nreturn -EINVAL;\r\n}\r\ntmp = src_x | (src_y << 16);\r\nwritel(tmp, engine + 0x18);\r\ntmp = src_mem ? 0 : src_addr;\r\nif (dst_addr & 0xE0000007) {\r\nprintk(KERN_WARNING "hw_bitblt_2: Unsupported source "\r\n"address %X\n", tmp);\r\nreturn -EINVAL;\r\n}\r\ntmp >>= 3;\r\nwritel(tmp, engine + 0x1C);\r\n}\r\nif (op == VIA_BITBLT_FILL) {\r\nwritel(fg_color, engine + 0x58);\r\n} else if (op == VIA_BITBLT_MONO) {\r\nwritel(fg_color, engine + 0x4C);\r\nwritel(bg_color, engine + 0x50);\r\n}\r\nif (op == VIA_BITBLT_FILL)\r\nge_cmd |= fill_rop << 24 | 0x00002000 | 0x00000001;\r\nelse {\r\nge_cmd |= 0xCC000000;\r\nif (src_mem)\r\nge_cmd |= 0x00000040;\r\nif (op == VIA_BITBLT_MONO)\r\nge_cmd |= 0x00000002 | 0x00000100 | 0x00020000;\r\nelse\r\nge_cmd |= 0x00000001;\r\n}\r\nwritel(ge_cmd, engine);\r\nif (op == VIA_BITBLT_FILL || !src_mem)\r\nreturn 0;\r\ntmp = (width * height * (op == VIA_BITBLT_MONO ? 1 : (dst_bpp >> 3)) +\r\n3) >> 2;\r\nfor (i = 0; i < tmp; i++)\r\nwritel(src_mem[i], engine + VIA_MMIO_BLTBASE);\r\nreturn 0;\r\n}\r\nint viafb_setup_engine(struct fb_info *info)\r\n{\r\nstruct viafb_par *viapar = info->par;\r\nvoid __iomem *engine;\r\nu32 chip_name = viapar->shared->chip_info.gfx_chip_name;\r\nengine = viapar->shared->vdev->engine_mmio;\r\nif (!engine) {\r\nprintk(KERN_WARNING "viafb_init_accel: ioremap failed, "\r\n"hardware acceleration disabled\n");\r\nreturn -ENOMEM;\r\n}\r\nswitch (chip_name) {\r\ncase UNICHROME_CLE266:\r\ncase UNICHROME_K400:\r\ncase UNICHROME_K800:\r\ncase UNICHROME_PM800:\r\ncase UNICHROME_CN700:\r\ncase UNICHROME_CX700:\r\ncase UNICHROME_CN750:\r\ncase UNICHROME_K8M890:\r\ncase UNICHROME_P4M890:\r\ncase UNICHROME_P4M900:\r\nviapar->shared->hw_bitblt = hw_bitblt_1;\r\nbreak;\r\ncase UNICHROME_VX800:\r\ncase UNICHROME_VX855:\r\ncase UNICHROME_VX900:\r\nviapar->shared->hw_bitblt = hw_bitblt_2;\r\nbreak;\r\ndefault:\r\nviapar->shared->hw_bitblt = NULL;\r\n}\r\nviapar->fbmem_free -= CURSOR_SIZE;\r\nviapar->shared->cursor_vram_addr = viapar->fbmem_free;\r\nviapar->fbmem_used += CURSOR_SIZE;\r\nviapar->fbmem_free -= VQ_SIZE;\r\nviapar->shared->vq_vram_addr = viapar->fbmem_free;\r\nviapar->fbmem_used += VQ_SIZE;\r\n#if defined(CONFIG_VIDEO_VIA_CAMERA) || defined(CONFIG_VIDEO_VIA_CAMERA_MODULE)\r\nviapar->shared->vdev->camera_fbmem_size = 3*VGA_HEIGHT*VGA_WIDTH*2;\r\nviapar->fbmem_free -= viapar->shared->vdev->camera_fbmem_size;\r\nviapar->fbmem_used += viapar->shared->vdev->camera_fbmem_size;\r\nviapar->shared->vdev->camera_fbmem_offset = viapar->fbmem_free;\r\n#endif\r\nviafb_reset_engine(viapar);\r\nreturn 0;\r\n}\r\nvoid viafb_reset_engine(struct viafb_par *viapar)\r\n{\r\nvoid __iomem *engine = viapar->shared->vdev->engine_mmio;\r\nint highest_reg, i;\r\nu32 vq_start_addr, vq_end_addr, vq_start_low, vq_end_low, vq_high,\r\nvq_len, chip_name = viapar->shared->chip_info.gfx_chip_name;\r\nswitch (viapar->shared->chip_info.twod_engine) {\r\ncase VIA_2D_ENG_M1:\r\nhighest_reg = 0x5c;\r\nbreak;\r\ndefault:\r\nhighest_reg = 0x40;\r\nbreak;\r\n}\r\nfor (i = 0; i <= highest_reg; i += 4)\r\nwritel(0x0, engine + i);\r\nswitch (chip_name) {\r\ncase UNICHROME_K8M890:\r\ncase UNICHROME_P4M900:\r\ncase UNICHROME_VX800:\r\ncase UNICHROME_VX855:\r\ncase UNICHROME_VX900:\r\nwritel(0x00100000, engine + VIA_REG_CR_TRANSET);\r\nwritel(0x680A0000, engine + VIA_REG_CR_TRANSPACE);\r\nwritel(0x02000000, engine + VIA_REG_CR_TRANSPACE);\r\nbreak;\r\ndefault:\r\nwritel(0x00100000, engine + VIA_REG_TRANSET);\r\nwritel(0x00000000, engine + VIA_REG_TRANSPACE);\r\nwritel(0x00333004, engine + VIA_REG_TRANSPACE);\r\nwritel(0x60000000, engine + VIA_REG_TRANSPACE);\r\nwritel(0x61000000, engine + VIA_REG_TRANSPACE);\r\nwritel(0x62000000, engine + VIA_REG_TRANSPACE);\r\nwritel(0x63000000, engine + VIA_REG_TRANSPACE);\r\nwritel(0x64000000, engine + VIA_REG_TRANSPACE);\r\nwritel(0x7D000000, engine + VIA_REG_TRANSPACE);\r\nwritel(0xFE020000, engine + VIA_REG_TRANSET);\r\nwritel(0x00000000, engine + VIA_REG_TRANSPACE);\r\nbreak;\r\n}\r\nvq_start_addr = viapar->shared->vq_vram_addr;\r\nvq_end_addr = viapar->shared->vq_vram_addr + VQ_SIZE - 1;\r\nvq_start_low = 0x50000000 | (vq_start_addr & 0xFFFFFF);\r\nvq_end_low = 0x51000000 | (vq_end_addr & 0xFFFFFF);\r\nvq_high = 0x52000000 | ((vq_start_addr & 0xFF000000) >> 24) |\r\n((vq_end_addr & 0xFF000000) >> 16);\r\nvq_len = 0x53000000 | (VQ_SIZE >> 3);\r\nswitch (chip_name) {\r\ncase UNICHROME_K8M890:\r\ncase UNICHROME_P4M900:\r\ncase UNICHROME_VX800:\r\ncase UNICHROME_VX855:\r\ncase UNICHROME_VX900:\r\nvq_start_low |= 0x20000000;\r\nvq_end_low |= 0x20000000;\r\nvq_high |= 0x20000000;\r\nvq_len |= 0x20000000;\r\nwritel(0x00100000, engine + VIA_REG_CR_TRANSET);\r\nwritel(vq_high, engine + VIA_REG_CR_TRANSPACE);\r\nwritel(vq_start_low, engine + VIA_REG_CR_TRANSPACE);\r\nwritel(vq_end_low, engine + VIA_REG_CR_TRANSPACE);\r\nwritel(vq_len, engine + VIA_REG_CR_TRANSPACE);\r\nwritel(0x74301001, engine + VIA_REG_CR_TRANSPACE);\r\nwritel(0x00000000, engine + VIA_REG_CR_TRANSPACE);\r\nbreak;\r\ndefault:\r\nwritel(0x00FE0000, engine + VIA_REG_TRANSET);\r\nwritel(0x080003FE, engine + VIA_REG_TRANSPACE);\r\nwritel(0x0A00027C, engine + VIA_REG_TRANSPACE);\r\nwritel(0x0B000260, engine + VIA_REG_TRANSPACE);\r\nwritel(0x0C000274, engine + VIA_REG_TRANSPACE);\r\nwritel(0x0D000264, engine + VIA_REG_TRANSPACE);\r\nwritel(0x0E000000, engine + VIA_REG_TRANSPACE);\r\nwritel(0x0F000020, engine + VIA_REG_TRANSPACE);\r\nwritel(0x1000027E, engine + VIA_REG_TRANSPACE);\r\nwritel(0x110002FE, engine + VIA_REG_TRANSPACE);\r\nwritel(0x200F0060, engine + VIA_REG_TRANSPACE);\r\nwritel(0x00000006, engine + VIA_REG_TRANSPACE);\r\nwritel(0x40008C0F, engine + VIA_REG_TRANSPACE);\r\nwritel(0x44000000, engine + VIA_REG_TRANSPACE);\r\nwritel(0x45080C04, engine + VIA_REG_TRANSPACE);\r\nwritel(0x46800408, engine + VIA_REG_TRANSPACE);\r\nwritel(vq_high, engine + VIA_REG_TRANSPACE);\r\nwritel(vq_start_low, engine + VIA_REG_TRANSPACE);\r\nwritel(vq_end_low, engine + VIA_REG_TRANSPACE);\r\nwritel(vq_len, engine + VIA_REG_TRANSPACE);\r\nbreak;\r\n}\r\nwritel(viapar->shared->cursor_vram_addr, engine + VIA_REG_CURSOR_MODE);\r\nwritel(0x0, engine + VIA_REG_CURSOR_POS);\r\nwritel(0x0, engine + VIA_REG_CURSOR_ORG);\r\nwritel(0x0, engine + VIA_REG_CURSOR_BG);\r\nwritel(0x0, engine + VIA_REG_CURSOR_FG);\r\nreturn;\r\n}\r\nvoid viafb_show_hw_cursor(struct fb_info *info, int Status)\r\n{\r\nstruct viafb_par *viapar = info->par;\r\nu32 temp, iga_path = viapar->iga_path;\r\ntemp = readl(viapar->shared->vdev->engine_mmio + VIA_REG_CURSOR_MODE);\r\nswitch (Status) {\r\ncase HW_Cursor_ON:\r\ntemp |= 0x1;\r\nbreak;\r\ncase HW_Cursor_OFF:\r\ntemp &= 0xFFFFFFFE;\r\nbreak;\r\n}\r\nswitch (iga_path) {\r\ncase IGA2:\r\ntemp |= 0x80000000;\r\nbreak;\r\ncase IGA1:\r\ndefault:\r\ntemp &= 0x7FFFFFFF;\r\n}\r\nwritel(temp, viapar->shared->vdev->engine_mmio + VIA_REG_CURSOR_MODE);\r\n}\r\nvoid viafb_wait_engine_idle(struct fb_info *info)\r\n{\r\nstruct viafb_par *viapar = info->par;\r\nint loop = 0;\r\nu32 mask;\r\nvoid __iomem *engine = viapar->shared->vdev->engine_mmio;\r\nswitch (viapar->shared->chip_info.twod_engine) {\r\ncase VIA_2D_ENG_H5:\r\ncase VIA_2D_ENG_M1:\r\nmask = VIA_CMD_RGTR_BUSY_M1 | VIA_2D_ENG_BUSY_M1 |\r\nVIA_3D_ENG_BUSY_M1;\r\nbreak;\r\ndefault:\r\nwhile (!(readl(engine + VIA_REG_STATUS) &\r\nVIA_VR_QUEUE_BUSY) && (loop < MAXLOOP)) {\r\nloop++;\r\ncpu_relax();\r\n}\r\nmask = VIA_CMD_RGTR_BUSY | VIA_2D_ENG_BUSY | VIA_3D_ENG_BUSY;\r\nbreak;\r\n}\r\nwhile ((readl(engine + VIA_REG_STATUS) & mask) && (loop < MAXLOOP)) {\r\nloop++;\r\ncpu_relax();\r\n}\r\nif (loop >= MAXLOOP)\r\nprintk(KERN_ERR "viafb_wait_engine_idle: not syncing\n");\r\n}
