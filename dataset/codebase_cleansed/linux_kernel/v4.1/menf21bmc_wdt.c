static int menf21bmc_wdt_set_bootstatus(struct menf21bmc_wdt *data)\r\n{\r\nint rst_rsn;\r\nrst_rsn = i2c_smbus_read_byte_data(data->i2c_client, BMC_CMD_RST_RSN);\r\nif (rst_rsn < 0)\r\nreturn rst_rsn;\r\nif (rst_rsn == 0x02)\r\ndata->wdt.bootstatus |= WDIOF_CARDRESET;\r\nelse if (rst_rsn == 0x05)\r\ndata->wdt.bootstatus |= WDIOF_EXTERN1;\r\nelse if (rst_rsn == 0x06)\r\ndata->wdt.bootstatus |= WDIOF_EXTERN2;\r\nelse if (rst_rsn == 0x0A)\r\ndata->wdt.bootstatus |= WDIOF_POWERUNDER;\r\nreturn 0;\r\n}\r\nstatic int menf21bmc_wdt_start(struct watchdog_device *wdt)\r\n{\r\nstruct menf21bmc_wdt *drv_data = watchdog_get_drvdata(wdt);\r\nreturn i2c_smbus_write_byte(drv_data->i2c_client, BMC_CMD_WD_ON);\r\n}\r\nstatic int menf21bmc_wdt_stop(struct watchdog_device *wdt)\r\n{\r\nstruct menf21bmc_wdt *drv_data = watchdog_get_drvdata(wdt);\r\nreturn i2c_smbus_write_byte_data(drv_data->i2c_client,\r\nBMC_CMD_WD_OFF, BMC_WD_OFF_VAL);\r\n}\r\nstatic int\r\nmenf21bmc_wdt_settimeout(struct watchdog_device *wdt, unsigned int timeout)\r\n{\r\nint ret;\r\nstruct menf21bmc_wdt *drv_data = watchdog_get_drvdata(wdt);\r\nret = i2c_smbus_write_word_data(drv_data->i2c_client,\r\nBMC_CMD_WD_TIME, timeout * 10);\r\nif (ret < 0)\r\nreturn ret;\r\nwdt->timeout = timeout;\r\nreturn 0;\r\n}\r\nstatic int menf21bmc_wdt_ping(struct watchdog_device *wdt)\r\n{\r\nstruct menf21bmc_wdt *drv_data = watchdog_get_drvdata(wdt);\r\nreturn i2c_smbus_write_byte(drv_data->i2c_client, BMC_CMD_WD_TRIG);\r\n}\r\nstatic int menf21bmc_wdt_probe(struct platform_device *pdev)\r\n{\r\nint ret, bmc_timeout;\r\nstruct menf21bmc_wdt *drv_data;\r\nstruct i2c_client *i2c_client = to_i2c_client(pdev->dev.parent);\r\ndrv_data = devm_kzalloc(&pdev->dev,\r\nsizeof(struct menf21bmc_wdt), GFP_KERNEL);\r\nif (!drv_data)\r\nreturn -ENOMEM;\r\ndrv_data->wdt.ops = &menf21bmc_wdt_ops;\r\ndrv_data->wdt.info = &menf21bmc_wdt_info;\r\ndrv_data->wdt.min_timeout = BMC_WD_TIMEOUT_MIN;\r\ndrv_data->wdt.max_timeout = BMC_WD_TIMEOUT_MAX;\r\ndrv_data->i2c_client = i2c_client;\r\nbmc_timeout = i2c_smbus_read_word_data(drv_data->i2c_client,\r\nBMC_CMD_WD_TIME);\r\nif (bmc_timeout < 0) {\r\ndev_err(&pdev->dev, "failed to get current WDT timeout\n");\r\nreturn bmc_timeout;\r\n}\r\nwatchdog_init_timeout(&drv_data->wdt, bmc_timeout / 10, &pdev->dev);\r\nwatchdog_set_nowayout(&drv_data->wdt, nowayout);\r\nwatchdog_set_drvdata(&drv_data->wdt, drv_data);\r\nplatform_set_drvdata(pdev, drv_data);\r\nret = menf21bmc_wdt_set_bootstatus(drv_data);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to set Watchdog bootstatus\n");\r\nreturn ret;\r\n}\r\nret = watchdog_register_device(&drv_data->wdt);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register Watchdog device\n");\r\nreturn ret;\r\n}\r\ndev_info(&pdev->dev, "MEN 14F021P00 BMC Watchdog device enabled\n");\r\nreturn 0;\r\n}\r\nstatic int menf21bmc_wdt_remove(struct platform_device *pdev)\r\n{\r\nstruct menf21bmc_wdt *drv_data = platform_get_drvdata(pdev);\r\ndev_warn(&pdev->dev,\r\n"Unregister MEN 14F021P00 BMC Watchdog device, board may reset\n");\r\nwatchdog_unregister_device(&drv_data->wdt);\r\nreturn 0;\r\n}\r\nstatic void menf21bmc_wdt_shutdown(struct platform_device *pdev)\r\n{\r\nstruct menf21bmc_wdt *drv_data = platform_get_drvdata(pdev);\r\ni2c_smbus_write_word_data(drv_data->i2c_client,\r\nBMC_CMD_WD_OFF, BMC_WD_OFF_VAL);\r\n}
