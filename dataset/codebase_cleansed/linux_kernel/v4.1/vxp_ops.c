static inline unsigned long vxp_reg_addr(struct vx_core *_chip, int reg)\r\n{\r\nstruct snd_vxpocket *chip = (struct snd_vxpocket *)_chip;\r\nreturn chip->port + vxp_reg_offset[reg];\r\n}\r\nstatic unsigned char vxp_inb(struct vx_core *chip, int offset)\r\n{\r\nreturn inb(vxp_reg_addr(chip, offset));\r\n}\r\nstatic void vxp_outb(struct vx_core *chip, int offset, unsigned char val)\r\n{\r\noutb(val, vxp_reg_addr(chip, offset));\r\n}\r\nstatic int vx_check_magic(struct vx_core *chip)\r\n{\r\nunsigned long end_time = jiffies + HZ / 5;\r\nint c;\r\ndo {\r\nc = vx_inb(chip, CDSP);\r\nif (c == CDSP_MAGIC)\r\nreturn 0;\r\nmsleep(10);\r\n} while (time_after_eq(end_time, jiffies));\r\nsnd_printk(KERN_ERR "cannot find xilinx magic word (%x)\n", c);\r\nreturn -EIO;\r\n}\r\nstatic void vxp_reset_dsp(struct vx_core *_chip)\r\n{\r\nstruct snd_vxpocket *chip = (struct snd_vxpocket *)_chip;\r\nvx_outb(chip, CDSP, chip->regCDSP | VXP_CDSP_DSP_RESET_MASK);\r\nvx_inb(chip, CDSP);\r\nmdelay(XX_DSP_RESET_WAIT_TIME);\r\nchip->regCDSP &= ~VXP_CDSP_DSP_RESET_MASK;\r\nvx_outb(chip, CDSP, chip->regCDSP);\r\nvx_inb(chip, CDSP);\r\nmdelay(XX_DSP_RESET_WAIT_TIME);\r\n}\r\nstatic void vxp_reset_codec(struct vx_core *_chip)\r\n{\r\nstruct snd_vxpocket *chip = (struct snd_vxpocket *)_chip;\r\nvx_outb(chip, CDSP, chip->regCDSP | VXP_CDSP_CODEC_RESET_MASK);\r\nvx_inb(chip, CDSP);\r\nmsleep(10);\r\nchip->regCDSP &= ~VXP_CDSP_CODEC_RESET_MASK;\r\nvx_outb(chip, CDSP, chip->regCDSP);\r\nvx_inb(chip, CDSP);\r\nmsleep(1);\r\n}\r\nstatic int vxp_load_xilinx_binary(struct vx_core *_chip, const struct firmware *fw)\r\n{\r\nstruct snd_vxpocket *chip = (struct snd_vxpocket *)_chip;\r\nunsigned int i;\r\nint c;\r\nint regCSUER, regRUER;\r\nconst unsigned char *image;\r\nunsigned char data;\r\nchip->regDIALOG |= VXP_DLG_XILINX_REPROG_MASK;\r\nvx_outb(chip, DIALOG, chip->regDIALOG);\r\nregCSUER = vx_inb(chip, CSUER);\r\nregRUER = vx_inb(chip, RUER);\r\nvx_outb(chip, ICR, 0);\r\nsnd_printdd(KERN_DEBUG "check ISR_HF2\n");\r\nif (vx_check_isr(_chip, ISR_HF2, ISR_HF2, 20) < 0)\r\ngoto _error;\r\nvx_outb(chip, ICR, ICR_HF1);\r\nimage = fw->data;\r\nfor (i = 0; i < fw->size; i++, image++) {\r\ndata = *image;\r\nif (vx_wait_isr_bit(_chip, ISR_TX_EMPTY) < 0)\r\ngoto _error;\r\nvx_outb(chip, TXL, data);\r\nif (vx_wait_for_rx_full(_chip) < 0)\r\ngoto _error;\r\nc = vx_inb(chip, RXL);\r\nif (c != (int)data)\r\nsnd_printk(KERN_ERR "vxpocket: load xilinx mismatch at %d: 0x%x != 0x%x\n", i, c, (int)data);\r\n}\r\nvx_outb(chip, ICR, 0);\r\nif (vx_check_isr(_chip, ISR_HF3, ISR_HF3, 20) < 0)\r\ngoto _error;\r\nif (vx_wait_for_rx_full(_chip) < 0)\r\ngoto _error;\r\nc = (int)vx_inb(chip, RXH) << 16;\r\nc |= (int)vx_inb(chip, RXM) << 8;\r\nc |= vx_inb(chip, RXL);\r\nsnd_printdd(KERN_DEBUG "xilinx: dsp size received 0x%x, orig 0x%Zx\n", c, fw->size);\r\nvx_outb(chip, ICR, ICR_HF0);\r\nmsleep(300);\r\nif (vx_check_magic(_chip) < 0)\r\ngoto _error;\r\nvx_outb(chip, CSUER, regCSUER);\r\nvx_outb(chip, RUER, regRUER);\r\nchip->regDIALOG |= VXP_DLG_XILINX_REPROG_MASK;\r\nvx_outb(chip, DIALOG, chip->regDIALOG);\r\nvx_inb(chip, DIALOG);\r\nmsleep(10);\r\nchip->regDIALOG &= ~VXP_DLG_XILINX_REPROG_MASK;\r\nvx_outb(chip, DIALOG, chip->regDIALOG);\r\nvx_inb(chip, DIALOG);\r\nvxp_reset_codec(_chip);\r\nvx_reset_dsp(_chip);\r\nreturn 0;\r\n_error:\r\nvx_outb(chip, CSUER, regCSUER);\r\nvx_outb(chip, RUER, regRUER);\r\nchip->regDIALOG &= ~VXP_DLG_XILINX_REPROG_MASK;\r\nvx_outb(chip, DIALOG, chip->regDIALOG);\r\nreturn -EIO;\r\n}\r\nstatic int vxp_load_dsp(struct vx_core *vx, int index, const struct firmware *fw)\r\n{\r\nint err;\r\nswitch (index) {\r\ncase 0:\r\nif ((err = vx_check_magic(vx)) < 0)\r\nreturn err;\r\nif ((err = snd_vx_load_boot_image(vx, fw)) < 0)\r\nreturn err;\r\nreturn 0;\r\ncase 1:\r\nreturn vxp_load_xilinx_binary(vx, fw);\r\ncase 2:\r\nreturn snd_vx_dsp_boot(vx, fw);\r\ncase 3:\r\nreturn snd_vx_dsp_load(vx, fw);\r\ndefault:\r\nsnd_BUG();\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int vxp_test_and_ack(struct vx_core *_chip)\r\n{\r\nstruct snd_vxpocket *chip = (struct snd_vxpocket *)_chip;\r\nif (! (_chip->chip_status & VX_STAT_XILINX_LOADED))\r\nreturn -ENXIO;\r\nif (! (vx_inb(chip, DIALOG) & VXP_DLG_MEMIRQ_MASK))\r\nreturn -EIO;\r\nvx_outb(chip, DIALOG, chip->regDIALOG | VXP_DLG_ACK_MEMIRQ_MASK);\r\nvx_inb(chip, DIALOG);\r\nvx_outb(chip, DIALOG, chip->regDIALOG & ~VXP_DLG_ACK_MEMIRQ_MASK);\r\nreturn 0;\r\n}\r\nstatic void vxp_validate_irq(struct vx_core *_chip, int enable)\r\n{\r\nstruct snd_vxpocket *chip = (struct snd_vxpocket *)_chip;\r\nif (enable)\r\nchip->regCDSP |= VXP_CDSP_VALID_IRQ_MASK;\r\nelse\r\nchip->regCDSP &= ~VXP_CDSP_VALID_IRQ_MASK;\r\nvx_outb(chip, CDSP, chip->regCDSP);\r\n}\r\nstatic void vx_setup_pseudo_dma(struct vx_core *_chip, int do_write)\r\n{\r\nstruct snd_vxpocket *chip = (struct snd_vxpocket *)_chip;\r\nvx_outb(chip, ICR, do_write ? ICR_TREQ : ICR_RREQ);\r\nvx_inb(chip, ISR);\r\nvx_outb(chip, ISR, 0);\r\nchip->regDIALOG |= VXP_DLG_DMA16_SEL_MASK;\r\nchip->regDIALOG |= do_write ? VXP_DLG_DMAWRITE_SEL_MASK : VXP_DLG_DMAREAD_SEL_MASK;\r\nvx_outb(chip, DIALOG, chip->regDIALOG);\r\n}\r\nstatic void vx_release_pseudo_dma(struct vx_core *_chip)\r\n{\r\nstruct snd_vxpocket *chip = (struct snd_vxpocket *)_chip;\r\nchip->regDIALOG &= ~(VXP_DLG_DMAWRITE_SEL_MASK|\r\nVXP_DLG_DMAREAD_SEL_MASK|\r\nVXP_DLG_DMA16_SEL_MASK);\r\nvx_outb(chip, DIALOG, chip->regDIALOG);\r\nvx_outb(chip, ICR, 0);\r\n}\r\nstatic void vxp_dma_write(struct vx_core *chip, struct snd_pcm_runtime *runtime,\r\nstruct vx_pipe *pipe, int count)\r\n{\r\nlong port = vxp_reg_addr(chip, VX_DMA);\r\nint offset = pipe->hw_ptr;\r\nunsigned short *addr = (unsigned short *)(runtime->dma_area + offset);\r\nvx_setup_pseudo_dma(chip, 1);\r\nif (offset + count > pipe->buffer_bytes) {\r\nint length = pipe->buffer_bytes - offset;\r\ncount -= length;\r\nlength >>= 1;\r\nwhile (length-- > 0) {\r\noutw(cpu_to_le16(*addr), port);\r\naddr++;\r\n}\r\naddr = (unsigned short *)runtime->dma_area;\r\npipe->hw_ptr = 0;\r\n}\r\npipe->hw_ptr += count;\r\ncount >>= 1;\r\nwhile (count-- > 0) {\r\noutw(cpu_to_le16(*addr), port);\r\naddr++;\r\n}\r\nvx_release_pseudo_dma(chip);\r\n}\r\nstatic void vxp_dma_read(struct vx_core *chip, struct snd_pcm_runtime *runtime,\r\nstruct vx_pipe *pipe, int count)\r\n{\r\nstruct snd_vxpocket *pchip = (struct snd_vxpocket *)chip;\r\nlong port = vxp_reg_addr(chip, VX_DMA);\r\nint offset = pipe->hw_ptr;\r\nunsigned short *addr = (unsigned short *)(runtime->dma_area + offset);\r\nif (snd_BUG_ON(count % 2))\r\nreturn;\r\nvx_setup_pseudo_dma(chip, 0);\r\nif (offset + count > pipe->buffer_bytes) {\r\nint length = pipe->buffer_bytes - offset;\r\ncount -= length;\r\nlength >>= 1;\r\nwhile (length-- > 0)\r\n*addr++ = le16_to_cpu(inw(port));\r\naddr = (unsigned short *)runtime->dma_area;\r\npipe->hw_ptr = 0;\r\n}\r\npipe->hw_ptr += count;\r\ncount >>= 1;\r\nwhile (count-- > 1)\r\n*addr++ = le16_to_cpu(inw(port));\r\npchip->regDIALOG &= ~VXP_DLG_DMAREAD_SEL_MASK;\r\nvx_outb(chip, DIALOG, pchip->regDIALOG);\r\n*addr = le16_to_cpu(inw(port));\r\npchip->regDIALOG &= ~VXP_DLG_DMA16_SEL_MASK;\r\nvx_outb(chip, DIALOG, pchip->regDIALOG);\r\nvx_outb(chip, ICR, 0);\r\n}\r\nstatic void vxp_write_codec_reg(struct vx_core *chip, int codec, unsigned int data)\r\n{\r\nint i;\r\nif (! codec)\r\nvx_inb(chip, LOFREQ);\r\nelse\r\nvx_inb(chip, CODEC2);\r\nfor (i = 0; i < 24; i++, data <<= 1)\r\nvx_outb(chip, DATA, ((data & 0x800000) ? VX_DATA_CODEC_MASK : 0));\r\nvx_inb(chip, HIFREQ);\r\n}\r\nvoid vx_set_mic_boost(struct vx_core *chip, int boost)\r\n{\r\nstruct snd_vxpocket *pchip = (struct snd_vxpocket *)chip;\r\nif (chip->chip_status & VX_STAT_IS_STALE)\r\nreturn;\r\nmutex_lock(&chip->lock);\r\nif (pchip->regCDSP & P24_CDSP_MICS_SEL_MASK) {\r\nif (boost) {\r\npchip->regCDSP &= ~P24_CDSP_MIC20_SEL_MASK;\r\npchip->regCDSP |= P24_CDSP_MIC38_SEL_MASK;\r\n} else {\r\npchip->regCDSP |= P24_CDSP_MIC20_SEL_MASK;\r\npchip->regCDSP &= ~P24_CDSP_MIC38_SEL_MASK;\r\n}\r\nvx_outb(chip, CDSP, pchip->regCDSP);\r\n}\r\nmutex_unlock(&chip->lock);\r\n}\r\nstatic int vx_compute_mic_level(int level)\r\n{\r\nswitch (level) {\r\ncase 5: level = 6 ; break;\r\ncase 6: level = 8 ; break;\r\ncase 7: level = 11; break;\r\ncase 8: level = 15; break;\r\ndefault: break ;\r\n}\r\nreturn level;\r\n}\r\nvoid vx_set_mic_level(struct vx_core *chip, int level)\r\n{\r\nstruct snd_vxpocket *pchip = (struct snd_vxpocket *)chip;\r\nif (chip->chip_status & VX_STAT_IS_STALE)\r\nreturn;\r\nmutex_lock(&chip->lock);\r\nif (pchip->regCDSP & VXP_CDSP_MIC_SEL_MASK) {\r\nlevel = vx_compute_mic_level(level);\r\nvx_outb(chip, MICRO, level);\r\n}\r\nmutex_unlock(&chip->lock);\r\n}\r\nstatic void vxp_change_audio_source(struct vx_core *_chip, int src)\r\n{\r\nstruct snd_vxpocket *chip = (struct snd_vxpocket *)_chip;\r\nswitch (src) {\r\ncase VX_AUDIO_SRC_DIGITAL:\r\nchip->regCDSP |= VXP_CDSP_DATAIN_SEL_MASK;\r\nvx_outb(chip, CDSP, chip->regCDSP);\r\nbreak;\r\ncase VX_AUDIO_SRC_LINE:\r\nchip->regCDSP &= ~VXP_CDSP_DATAIN_SEL_MASK;\r\nif (_chip->type == VX_TYPE_VXP440)\r\nchip->regCDSP &= ~P24_CDSP_MICS_SEL_MASK;\r\nelse\r\nchip->regCDSP &= ~VXP_CDSP_MIC_SEL_MASK;\r\nvx_outb(chip, CDSP, chip->regCDSP);\r\nbreak;\r\ncase VX_AUDIO_SRC_MIC:\r\nchip->regCDSP &= ~VXP_CDSP_DATAIN_SEL_MASK;\r\nif (_chip->type == VX_TYPE_VXP440) {\r\nchip->regCDSP &= ~P24_CDSP_MICS_SEL_MASK;\r\nif (chip->mic_level)\r\nchip->regCDSP |= P24_CDSP_MIC38_SEL_MASK;\r\nelse\r\nchip->regCDSP |= P24_CDSP_MIC20_SEL_MASK;\r\nvx_outb(chip, CDSP, chip->regCDSP);\r\n} else {\r\nchip->regCDSP |= VXP_CDSP_MIC_SEL_MASK;\r\nvx_outb(chip, CDSP, chip->regCDSP);\r\nvx_outb(chip, MICRO, vx_compute_mic_level(chip->mic_level));\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void vxp_set_clock_source(struct vx_core *_chip, int source)\r\n{\r\nstruct snd_vxpocket *chip = (struct snd_vxpocket *)_chip;\r\nif (source == INTERNAL_QUARTZ)\r\nchip->regCDSP &= ~VXP_CDSP_CLOCKIN_SEL_MASK;\r\nelse\r\nchip->regCDSP |= VXP_CDSP_CLOCKIN_SEL_MASK;\r\nvx_outb(chip, CDSP, chip->regCDSP);\r\n}\r\nstatic void vxp_reset_board(struct vx_core *_chip, int cold_reset)\r\n{\r\nstruct snd_vxpocket *chip = (struct snd_vxpocket *)_chip;\r\nchip->regCDSP = 0;\r\nchip->regDIALOG = 0;\r\n}
