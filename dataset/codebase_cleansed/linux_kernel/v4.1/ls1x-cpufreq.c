static int ls1x_cpufreq_notifier(struct notifier_block *nb,\r\nunsigned long val, void *data)\r\n{\r\nif (val == CPUFREQ_POSTCHANGE)\r\ncurrent_cpu_data.udelay_val = loops_per_jiffy;\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int ls1x_cpufreq_target(struct cpufreq_policy *policy,\r\nunsigned int index)\r\n{\r\nunsigned int old_freq, new_freq;\r\nold_freq = policy->cur;\r\nnew_freq = policy->freq_table[index].frequency;\r\ndev_dbg(ls1x_cpufreq.dev, "%u KHz --> %u KHz\n", old_freq, new_freq);\r\nclk_set_parent(policy->clk, ls1x_cpufreq.osc_clk);\r\n__raw_writel(__raw_readl(LS1X_CLK_PLL_DIV) | RST_CPU_EN | RST_CPU,\r\nLS1X_CLK_PLL_DIV);\r\n__raw_writel(__raw_readl(LS1X_CLK_PLL_DIV) & ~(RST_CPU_EN | RST_CPU),\r\nLS1X_CLK_PLL_DIV);\r\nclk_set_rate(ls1x_cpufreq.mux_clk, new_freq * 1000);\r\nclk_set_parent(policy->clk, ls1x_cpufreq.mux_clk);\r\nreturn 0;\r\n}\r\nstatic int ls1x_cpufreq_init(struct cpufreq_policy *policy)\r\n{\r\nstruct cpufreq_frequency_table *freq_tbl;\r\nunsigned int pll_freq, freq;\r\nint steps, i, ret;\r\npll_freq = clk_get_rate(ls1x_cpufreq.pll_clk) / 1000;\r\nsteps = 1 << DIV_CPU_WIDTH;\r\nfreq_tbl = kzalloc(sizeof(*freq_tbl) * steps, GFP_KERNEL);\r\nif (!freq_tbl) {\r\ndev_err(ls1x_cpufreq.dev,\r\n"failed to alloc cpufreq_frequency_table\n");\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nfor (i = 0; i < (steps - 1); i++) {\r\nfreq = pll_freq / (i + 1);\r\nif ((freq < ls1x_cpufreq.min_freq) ||\r\n(freq > ls1x_cpufreq.max_freq))\r\nfreq_tbl[i].frequency = CPUFREQ_ENTRY_INVALID;\r\nelse\r\nfreq_tbl[i].frequency = freq;\r\ndev_dbg(ls1x_cpufreq.dev,\r\n"cpufreq table: index %d: frequency %d\n", i,\r\nfreq_tbl[i].frequency);\r\n}\r\nfreq_tbl[i].frequency = CPUFREQ_TABLE_END;\r\npolicy->clk = ls1x_cpufreq.clk;\r\nret = cpufreq_generic_init(policy, freq_tbl, 0);\r\nif (ret)\r\nkfree(freq_tbl);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int ls1x_cpufreq_exit(struct cpufreq_policy *policy)\r\n{\r\nkfree(policy->freq_table);\r\nreturn 0;\r\n}\r\nstatic int ls1x_cpufreq_remove(struct platform_device *pdev)\r\n{\r\ncpufreq_unregister_notifier(&ls1x_cpufreq_notifier_block,\r\nCPUFREQ_TRANSITION_NOTIFIER);\r\ncpufreq_unregister_driver(&ls1x_cpufreq_driver);\r\nreturn 0;\r\n}\r\nstatic int ls1x_cpufreq_probe(struct platform_device *pdev)\r\n{\r\nstruct plat_ls1x_cpufreq *pdata = pdev->dev.platform_data;\r\nstruct clk *clk;\r\nint ret;\r\nif (!pdata || !pdata->clk_name || !pdata->osc_clk_name)\r\nreturn -EINVAL;\r\nls1x_cpufreq.dev = &pdev->dev;\r\nclk = devm_clk_get(&pdev->dev, pdata->clk_name);\r\nif (IS_ERR(clk)) {\r\ndev_err(ls1x_cpufreq.dev, "unable to get %s clock\n",\r\npdata->clk_name);\r\nret = PTR_ERR(clk);\r\ngoto out;\r\n}\r\nls1x_cpufreq.clk = clk;\r\nclk = clk_get_parent(clk);\r\nif (IS_ERR(clk)) {\r\ndev_err(ls1x_cpufreq.dev, "unable to get parent of %s clock\n",\r\n__clk_get_name(ls1x_cpufreq.clk));\r\nret = PTR_ERR(clk);\r\ngoto out;\r\n}\r\nls1x_cpufreq.mux_clk = clk;\r\nclk = clk_get_parent(clk);\r\nif (IS_ERR(clk)) {\r\ndev_err(ls1x_cpufreq.dev, "unable to get parent of %s clock\n",\r\n__clk_get_name(ls1x_cpufreq.mux_clk));\r\nret = PTR_ERR(clk);\r\ngoto out;\r\n}\r\nls1x_cpufreq.pll_clk = clk;\r\nclk = devm_clk_get(&pdev->dev, pdata->osc_clk_name);\r\nif (IS_ERR(clk)) {\r\ndev_err(ls1x_cpufreq.dev, "unable to get %s clock\n",\r\npdata->osc_clk_name);\r\nret = PTR_ERR(clk);\r\ngoto out;\r\n}\r\nls1x_cpufreq.osc_clk = clk;\r\nls1x_cpufreq.max_freq = pdata->max_freq;\r\nls1x_cpufreq.min_freq = pdata->min_freq;\r\nret = cpufreq_register_driver(&ls1x_cpufreq_driver);\r\nif (ret) {\r\ndev_err(ls1x_cpufreq.dev,\r\n"failed to register cpufreq driver: %d\n", ret);\r\ngoto out;\r\n}\r\nret = cpufreq_register_notifier(&ls1x_cpufreq_notifier_block,\r\nCPUFREQ_TRANSITION_NOTIFIER);\r\nif (!ret)\r\ngoto out;\r\ndev_err(ls1x_cpufreq.dev, "failed to register cpufreq notifier: %d\n",\r\nret);\r\ncpufreq_unregister_driver(&ls1x_cpufreq_driver);\r\nout:\r\nreturn ret;\r\n}
