static char *print_speed(int speed)\r\n{\r\nif (speed < 1000) {\r\nsnprintf(speedbuffer, sizeof(speedbuffer), "%dMHz", speed);\r\nreturn speedbuffer;\r\n}\r\nif (speed%1000 == 0)\r\nsnprintf(speedbuffer, sizeof(speedbuffer),\r\n"%dGHz", speed/1000);\r\nelse\r\nsnprintf(speedbuffer, sizeof(speedbuffer),\r\n"%d.%dGHz", speed/1000, (speed%1000)/100);\r\nreturn speedbuffer;\r\n}\r\nstatic unsigned int calc_speed(int mult)\r\n{\r\nint khz;\r\nkhz = (mult/10)*fsb;\r\nif (mult%10)\r\nkhz += fsb/2;\r\nkhz *= 1000;\r\nreturn khz;\r\n}\r\nstatic int longhaul_get_cpu_mult(void)\r\n{\r\nunsigned long invalue = 0, lo, hi;\r\nrdmsr(MSR_IA32_EBL_CR_POWERON, lo, hi);\r\ninvalue = (lo & (1<<22|1<<23|1<<24|1<<25))>>22;\r\nif (longhaul_version == TYPE_LONGHAUL_V2 ||\r\nlonghaul_version == TYPE_POWERSAVER) {\r\nif (lo & (1<<27))\r\ninvalue += 16;\r\n}\r\nreturn eblcr[invalue];\r\n}\r\nstatic void do_longhaul1(unsigned int mults_index)\r\n{\r\nunion msr_bcr2 bcr2;\r\nrdmsrl(MSR_VIA_BCR2, bcr2.val);\r\nbcr2.bits.ESOFTBF = 1;\r\nbcr2.bits.CLOCKMUL = mults_index & 0xff;\r\nsafe_halt();\r\nwrmsrl(MSR_VIA_BCR2, bcr2.val);\r\nACPI_FLUSH_CPU_CACHE();\r\nhalt();\r\nlocal_irq_disable();\r\nrdmsrl(MSR_VIA_BCR2, bcr2.val);\r\nbcr2.bits.ESOFTBF = 0;\r\nwrmsrl(MSR_VIA_BCR2, bcr2.val);\r\n}\r\nstatic void do_powersaver(int cx_address, unsigned int mults_index,\r\nunsigned int dir)\r\n{\r\nunion msr_longhaul longhaul;\r\nu32 t;\r\nrdmsrl(MSR_VIA_LONGHAUL, longhaul.val);\r\nif (!revid_errata)\r\nlonghaul.bits.RevisionKey = longhaul.bits.RevisionID;\r\nelse\r\nlonghaul.bits.RevisionKey = 0;\r\nlonghaul.bits.SoftBusRatio = mults_index & 0xf;\r\nlonghaul.bits.SoftBusRatio4 = (mults_index & 0x10) >> 4;\r\nif (can_scale_voltage)\r\nlonghaul.bits.SoftVID = (mults_index >> 8) & 0x1f;\r\nsafe_halt();\r\nif (can_scale_voltage && dir) {\r\nlonghaul.bits.EnableSoftVID = 1;\r\nwrmsrl(MSR_VIA_LONGHAUL, longhaul.val);\r\nif (!cx_address) {\r\nACPI_FLUSH_CPU_CACHE();\r\nhalt();\r\n} else {\r\nACPI_FLUSH_CPU_CACHE();\r\ninb(cx_address);\r\nt = inl(acpi_gbl_FADT.xpm_timer_block.address);\r\n}\r\nlonghaul.bits.EnableSoftVID = 0;\r\nwrmsrl(MSR_VIA_LONGHAUL, longhaul.val);\r\n}\r\nlonghaul.bits.EnableSoftBusRatio = 1;\r\nwrmsrl(MSR_VIA_LONGHAUL, longhaul.val);\r\nif (!cx_address) {\r\nACPI_FLUSH_CPU_CACHE();\r\nhalt();\r\n} else {\r\nACPI_FLUSH_CPU_CACHE();\r\ninb(cx_address);\r\nt = inl(acpi_gbl_FADT.xpm_timer_block.address);\r\n}\r\nlonghaul.bits.EnableSoftBusRatio = 0;\r\nwrmsrl(MSR_VIA_LONGHAUL, longhaul.val);\r\nif (can_scale_voltage && !dir) {\r\nlonghaul.bits.EnableSoftVID = 1;\r\nwrmsrl(MSR_VIA_LONGHAUL, longhaul.val);\r\nif (!cx_address) {\r\nACPI_FLUSH_CPU_CACHE();\r\nhalt();\r\n} else {\r\nACPI_FLUSH_CPU_CACHE();\r\ninb(cx_address);\r\nt = inl(acpi_gbl_FADT.xpm_timer_block.address);\r\n}\r\nlonghaul.bits.EnableSoftVID = 0;\r\nwrmsrl(MSR_VIA_LONGHAUL, longhaul.val);\r\n}\r\n}\r\nstatic int longhaul_setstate(struct cpufreq_policy *policy,\r\nunsigned int table_index)\r\n{\r\nunsigned int mults_index;\r\nint speed, mult;\r\nstruct cpufreq_freqs freqs;\r\nunsigned long flags;\r\nunsigned int pic1_mask, pic2_mask;\r\nu16 bm_status = 0;\r\nu32 bm_timeout = 1000;\r\nunsigned int dir = 0;\r\nmults_index = longhaul_table[table_index].driver_data;\r\nmult = mults[mults_index & 0x1f];\r\nif (mult == -1)\r\nreturn -EINVAL;\r\nspeed = calc_speed(mult);\r\nif ((speed > highest_speed) || (speed < lowest_speed))\r\nreturn -EINVAL;\r\nif (can_scale_voltage && longhaul_index < table_index)\r\ndir = 1;\r\nfreqs.old = calc_speed(longhaul_get_cpu_mult());\r\nfreqs.new = speed;\r\npr_debug("Setting to FSB:%dMHz Mult:%d.%dx (%s)\n",\r\nfsb, mult/10, mult%10, print_speed(speed/1000));\r\nretry_loop:\r\npreempt_disable();\r\nlocal_irq_save(flags);\r\npic2_mask = inb(0xA1);\r\npic1_mask = inb(0x21);\r\noutb(0xFF, 0xA1);\r\noutb(0xFE, 0x21);\r\nif (acpi_regs_addr && (longhaul_flags & USE_NORTHBRIDGE\r\n|| ((pr != NULL) && pr->flags.bm_control))) {\r\nbm_status = inw(acpi_regs_addr);\r\nbm_status &= 1 << 4;\r\nwhile (bm_status && bm_timeout) {\r\noutw(1 << 4, acpi_regs_addr);\r\nbm_timeout--;\r\nbm_status = inw(acpi_regs_addr);\r\nbm_status &= 1 << 4;\r\n}\r\n}\r\nif (longhaul_flags & USE_NORTHBRIDGE) {\r\noutb(3, 0x22);\r\n} else if ((pr != NULL) && pr->flags.bm_control) {\r\nacpi_write_bit_register(ACPI_BITREG_ARB_DISABLE, 1);\r\n}\r\nswitch (longhaul_version) {\r\ncase TYPE_LONGHAUL_V1:\r\ndo_longhaul1(mults_index);\r\nbreak;\r\ncase TYPE_LONGHAUL_V2:\r\ncase TYPE_POWERSAVER:\r\nif (longhaul_flags & USE_ACPI_C3) {\r\nacpi_write_bit_register(ACPI_BITREG_BUS_MASTER_RLD, 0);\r\ndo_powersaver(cx->address, mults_index, dir);\r\n} else {\r\ndo_powersaver(0, mults_index, dir);\r\n}\r\nbreak;\r\n}\r\nif (longhaul_flags & USE_NORTHBRIDGE) {\r\noutb(0, 0x22);\r\n} else if ((pr != NULL) && pr->flags.bm_control) {\r\nacpi_write_bit_register(ACPI_BITREG_ARB_DISABLE, 0);\r\n}\r\noutb(pic2_mask, 0xA1);\r\noutb(pic1_mask, 0x21);\r\nlocal_irq_restore(flags);\r\npreempt_enable();\r\nfreqs.new = calc_speed(longhaul_get_cpu_mult());\r\nif (unlikely(freqs.new != speed)) {\r\nprintk(KERN_INFO PFX "Failed to set requested frequency!\n");\r\nif (!revid_errata) {\r\nprintk(KERN_INFO PFX "Enabling \"Ignore Revision ID\" "\r\n"option.\n");\r\nrevid_errata = 1;\r\nmsleep(200);\r\ngoto retry_loop;\r\n}\r\nif (longhaul_flags & USE_ACPI_C3) {\r\nprintk(KERN_INFO PFX "Disabling ACPI C3 support.\n");\r\nlonghaul_flags &= ~USE_ACPI_C3;\r\nif (revid_errata) {\r\nprintk(KERN_INFO PFX "Disabling \"Ignore "\r\n"Revision ID\" option.\n");\r\nrevid_errata = 0;\r\n}\r\nmsleep(200);\r\ngoto retry_loop;\r\n}\r\nif (longhaul_version == TYPE_LONGHAUL_V2) {\r\nprintk(KERN_INFO PFX "Switching to Longhaul ver. 1\n");\r\nlonghaul_version = TYPE_LONGHAUL_V1;\r\nmsleep(200);\r\ngoto retry_loop;\r\n}\r\n}\r\nif (!bm_timeout) {\r\nprintk(KERN_INFO PFX "Warning: Timeout while waiting for "\r\n"idle PCI bus.\n");\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int guess_fsb(int mult)\r\n{\r\nint speed = cpu_khz / 1000;\r\nint i;\r\nint speeds[] = { 666, 1000, 1333, 2000 };\r\nint f_max, f_min;\r\nfor (i = 0; i < 4; i++) {\r\nf_max = ((speeds[i] * mult) + 50) / 100;\r\nf_max += (ROUNDING / 2);\r\nf_min = f_max - ROUNDING;\r\nif ((speed <= f_max) && (speed >= f_min))\r\nreturn speeds[i] / 10;\r\n}\r\nreturn 0;\r\n}\r\nstatic int longhaul_get_ranges(void)\r\n{\r\nunsigned int i, j, k = 0;\r\nunsigned int ratio;\r\nint mult;\r\nmult = longhaul_get_cpu_mult();\r\nif (mult == -1) {\r\nprintk(KERN_INFO PFX "Invalid (reserved) multiplier!\n");\r\nreturn -EINVAL;\r\n}\r\nfsb = guess_fsb(mult);\r\nif (fsb == 0) {\r\nprintk(KERN_INFO PFX "Invalid (reserved) FSB!\n");\r\nreturn -EINVAL;\r\n}\r\nmaxmult = mult;\r\nswitch (cpu_model) {\r\ncase CPU_NEHEMIAH:\r\nminmult = 50;\r\nbreak;\r\ncase CPU_NEHEMIAH_C:\r\nminmult = 40;\r\nbreak;\r\ndefault:\r\nminmult = 30;\r\nbreak;\r\n}\r\npr_debug("MinMult:%d.%dx MaxMult:%d.%dx\n",\r\nminmult/10, minmult%10, maxmult/10, maxmult%10);\r\nhighest_speed = calc_speed(maxmult);\r\nlowest_speed = calc_speed(minmult);\r\npr_debug("FSB:%dMHz Lowest speed: %s Highest speed:%s\n", fsb,\r\nprint_speed(lowest_speed/1000),\r\nprint_speed(highest_speed/1000));\r\nif (lowest_speed == highest_speed) {\r\nprintk(KERN_INFO PFX "highestspeed == lowest, aborting.\n");\r\nreturn -EINVAL;\r\n}\r\nif (lowest_speed > highest_speed) {\r\nprintk(KERN_INFO PFX "nonsense! lowest (%d > %d) !\n",\r\nlowest_speed, highest_speed);\r\nreturn -EINVAL;\r\n}\r\nlonghaul_table = kzalloc((numscales + 1) * sizeof(*longhaul_table),\r\nGFP_KERNEL);\r\nif (!longhaul_table)\r\nreturn -ENOMEM;\r\nfor (j = 0; j < numscales; j++) {\r\nratio = mults[j];\r\nif (ratio == -1)\r\ncontinue;\r\nif (ratio > maxmult || ratio < minmult)\r\ncontinue;\r\nlonghaul_table[k].frequency = calc_speed(ratio);\r\nlonghaul_table[k].driver_data = j;\r\nk++;\r\n}\r\nif (k <= 1) {\r\nkfree(longhaul_table);\r\nreturn -ENODEV;\r\n}\r\nfor (j = 0; j < k - 1; j++) {\r\nunsigned int min_f, min_i;\r\nmin_f = longhaul_table[j].frequency;\r\nmin_i = j;\r\nfor (i = j + 1; i < k; i++) {\r\nif (longhaul_table[i].frequency < min_f) {\r\nmin_f = longhaul_table[i].frequency;\r\nmin_i = i;\r\n}\r\n}\r\nif (min_i != j) {\r\nswap(longhaul_table[j].frequency,\r\nlonghaul_table[min_i].frequency);\r\nswap(longhaul_table[j].driver_data,\r\nlonghaul_table[min_i].driver_data);\r\n}\r\n}\r\nlonghaul_table[k].frequency = CPUFREQ_TABLE_END;\r\nfor (j = 0; j < k; j++) {\r\nif (mults[longhaul_table[j].driver_data & 0x1f] == mult) {\r\nlonghaul_index = j;\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void longhaul_setup_voltagescaling(void)\r\n{\r\nstruct cpufreq_frequency_table *freq_pos;\r\nunion msr_longhaul longhaul;\r\nstruct mV_pos minvid, maxvid, vid;\r\nunsigned int j, speed, pos, kHz_step, numvscales;\r\nint min_vid_speed;\r\nrdmsrl(MSR_VIA_LONGHAUL, longhaul.val);\r\nif (!(longhaul.bits.RevisionID & 1)) {\r\nprintk(KERN_INFO PFX "Voltage scaling not supported by CPU.\n");\r\nreturn;\r\n}\r\nif (!longhaul.bits.VRMRev) {\r\nprintk(KERN_INFO PFX "VRM 8.5\n");\r\nvrm_mV_table = &vrm85_mV[0];\r\nmV_vrm_table = &mV_vrm85[0];\r\n} else {\r\nprintk(KERN_INFO PFX "Mobile VRM\n");\r\nif (cpu_model < CPU_NEHEMIAH)\r\nreturn;\r\nvrm_mV_table = &mobilevrm_mV[0];\r\nmV_vrm_table = &mV_mobilevrm[0];\r\n}\r\nminvid = vrm_mV_table[longhaul.bits.MinimumVID];\r\nmaxvid = vrm_mV_table[longhaul.bits.MaximumVID];\r\nif (minvid.mV == 0 || maxvid.mV == 0 || minvid.mV > maxvid.mV) {\r\nprintk(KERN_INFO PFX "Bogus values Min:%d.%03d Max:%d.%03d. "\r\n"Voltage scaling disabled.\n",\r\nminvid.mV/1000, minvid.mV%1000,\r\nmaxvid.mV/1000, maxvid.mV%1000);\r\nreturn;\r\n}\r\nif (minvid.mV == maxvid.mV) {\r\nprintk(KERN_INFO PFX "Claims to support voltage scaling but "\r\n"min & max are both %d.%03d. "\r\n"Voltage scaling disabled\n",\r\nmaxvid.mV/1000, maxvid.mV%1000);\r\nreturn;\r\n}\r\nnumvscales = maxvid.pos - minvid.pos + 1;\r\nprintk(KERN_INFO PFX\r\n"Max VID=%d.%03d "\r\n"Min VID=%d.%03d, "\r\n"%d possible voltage scales\n",\r\nmaxvid.mV/1000, maxvid.mV%1000,\r\nminvid.mV/1000, minvid.mV%1000,\r\nnumvscales);\r\nj = longhaul.bits.MinMHzBR;\r\nif (longhaul.bits.MinMHzBR4)\r\nj += 16;\r\nmin_vid_speed = eblcr[j];\r\nif (min_vid_speed == -1)\r\nreturn;\r\nswitch (longhaul.bits.MinMHzFSB) {\r\ncase 0:\r\nmin_vid_speed *= 13333;\r\nbreak;\r\ncase 1:\r\nmin_vid_speed *= 10000;\r\nbreak;\r\ncase 3:\r\nmin_vid_speed *= 6666;\r\nbreak;\r\ndefault:\r\nreturn;\r\nbreak;\r\n}\r\nif (min_vid_speed >= highest_speed)\r\nreturn;\r\nkHz_step = (highest_speed - min_vid_speed) / numvscales;\r\ncpufreq_for_each_entry(freq_pos, longhaul_table) {\r\nspeed = freq_pos->frequency;\r\nif (speed > min_vid_speed)\r\npos = (speed - min_vid_speed) / kHz_step + minvid.pos;\r\nelse\r\npos = minvid.pos;\r\nfreq_pos->driver_data |= mV_vrm_table[pos] << 8;\r\nvid = vrm_mV_table[mV_vrm_table[pos]];\r\nprintk(KERN_INFO PFX "f: %d kHz, index: %d, vid: %d mV\n",\r\nspeed, (int)(freq_pos - longhaul_table), vid.mV);\r\n}\r\ncan_scale_voltage = 1;\r\nprintk(KERN_INFO PFX "Voltage scaling enabled.\n");\r\n}\r\nstatic int longhaul_target(struct cpufreq_policy *policy,\r\nunsigned int table_index)\r\n{\r\nunsigned int i;\r\nunsigned int dir = 0;\r\nu8 vid, current_vid;\r\nint retval = 0;\r\nif (!can_scale_voltage)\r\nretval = longhaul_setstate(policy, table_index);\r\nelse {\r\ni = longhaul_index;\r\ncurrent_vid = (longhaul_table[longhaul_index].driver_data >> 8);\r\ncurrent_vid &= 0x1f;\r\nif (table_index > longhaul_index)\r\ndir = 1;\r\nwhile (i != table_index) {\r\nvid = (longhaul_table[i].driver_data >> 8) & 0x1f;\r\nif (vid != current_vid) {\r\nretval = longhaul_setstate(policy, i);\r\ncurrent_vid = vid;\r\nmsleep(200);\r\n}\r\nif (dir)\r\ni++;\r\nelse\r\ni--;\r\n}\r\nretval = longhaul_setstate(policy, table_index);\r\n}\r\nlonghaul_index = table_index;\r\nreturn retval;\r\n}\r\nstatic unsigned int longhaul_get(unsigned int cpu)\r\n{\r\nif (cpu)\r\nreturn 0;\r\nreturn calc_speed(longhaul_get_cpu_mult());\r\n}\r\nstatic acpi_status longhaul_walk_callback(acpi_handle obj_handle,\r\nu32 nesting_level,\r\nvoid *context, void **return_value)\r\n{\r\nstruct acpi_device *d;\r\nif (acpi_bus_get_device(obj_handle, &d))\r\nreturn 0;\r\n*return_value = acpi_driver_data(d);\r\nreturn 1;\r\n}\r\nstatic int enable_arbiter_disable(void)\r\n{\r\nstruct pci_dev *dev;\r\nint status = 1;\r\nint reg;\r\nu8 pci_cmd;\r\nreg = 0x78;\r\ndev = pci_get_device(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_8601_0,\r\nNULL);\r\nif (dev == NULL)\r\ndev = pci_get_device(PCI_VENDOR_ID_VIA,\r\nPCI_DEVICE_ID_VIA_8605_0, NULL);\r\nif (dev == NULL) {\r\nreg = 0x76;\r\ndev = pci_get_device(PCI_VENDOR_ID_VIA,\r\nPCI_DEVICE_ID_VIA_862X_0, NULL);\r\nif (dev == NULL)\r\ndev = pci_get_device(PCI_VENDOR_ID_VIA, 0x7259, NULL);\r\n}\r\nif (dev != NULL) {\r\npci_read_config_byte(dev, reg, &pci_cmd);\r\nif (!(pci_cmd & 1<<7)) {\r\npci_cmd |= 1<<7;\r\npci_write_config_byte(dev, reg, pci_cmd);\r\npci_read_config_byte(dev, reg, &pci_cmd);\r\nif (!(pci_cmd & 1<<7)) {\r\nprintk(KERN_ERR PFX\r\n"Can't enable access to port 0x22.\n");\r\nstatus = 0;\r\n}\r\n}\r\npci_dev_put(dev);\r\nreturn status;\r\n}\r\nreturn 0;\r\n}\r\nstatic int longhaul_setup_southbridge(void)\r\n{\r\nstruct pci_dev *dev;\r\nu8 pci_cmd;\r\ndev = pci_get_device(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_8235, NULL);\r\nif (dev == NULL)\r\ndev = pci_get_device(PCI_VENDOR_ID_VIA,\r\nPCI_DEVICE_ID_VIA_8237, NULL);\r\nif (dev != NULL) {\r\npci_read_config_byte(dev, 0xec, &pci_cmd);\r\npci_cmd &= ~(1 << 2);\r\npci_write_config_byte(dev, 0xec, pci_cmd);\r\npci_read_config_byte(dev, 0xe4, &pci_cmd);\r\npci_cmd &= ~(1 << 7);\r\npci_write_config_byte(dev, 0xe4, pci_cmd);\r\npci_read_config_byte(dev, 0xe5, &pci_cmd);\r\npci_cmd |= 1 << 7;\r\npci_write_config_byte(dev, 0xe5, pci_cmd);\r\npci_read_config_byte(dev, 0x81, &pci_cmd);\r\nif (pci_cmd & 1 << 7) {\r\npci_read_config_dword(dev, 0x88, &acpi_regs_addr);\r\nacpi_regs_addr &= 0xff00;\r\nprintk(KERN_INFO PFX "ACPI I/O at 0x%x\n",\r\nacpi_regs_addr);\r\n}\r\npci_dev_put(dev);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int longhaul_cpu_init(struct cpufreq_policy *policy)\r\n{\r\nstruct cpuinfo_x86 *c = &cpu_data(0);\r\nchar *cpuname = NULL;\r\nint ret;\r\nu32 lo, hi;\r\nswitch (c->x86_model) {\r\ncase 6:\r\ncpu_model = CPU_SAMUEL;\r\ncpuname = "C3 'Samuel' [C5A]";\r\nlonghaul_version = TYPE_LONGHAUL_V1;\r\nmemcpy(mults, samuel1_mults, sizeof(samuel1_mults));\r\nmemcpy(eblcr, samuel1_eblcr, sizeof(samuel1_eblcr));\r\nbreak;\r\ncase 7:\r\nswitch (c->x86_mask) {\r\ncase 0:\r\nlonghaul_version = TYPE_LONGHAUL_V1;\r\ncpu_model = CPU_SAMUEL2;\r\ncpuname = "C3 'Samuel 2' [C5B]";\r\nmemcpy(mults, samuel1_mults, sizeof(samuel1_mults));\r\nmemcpy(eblcr, samuel2_eblcr, sizeof(samuel2_eblcr));\r\nbreak;\r\ncase 1 ... 15:\r\nlonghaul_version = TYPE_LONGHAUL_V2;\r\nif (c->x86_mask < 8) {\r\ncpu_model = CPU_SAMUEL2;\r\ncpuname = "C3 'Samuel 2' [C5B]";\r\n} else {\r\ncpu_model = CPU_EZRA;\r\ncpuname = "C3 'Ezra' [C5C]";\r\n}\r\nmemcpy(mults, ezra_mults, sizeof(ezra_mults));\r\nmemcpy(eblcr, ezra_eblcr, sizeof(ezra_eblcr));\r\nbreak;\r\n}\r\nbreak;\r\ncase 8:\r\ncpu_model = CPU_EZRA_T;\r\ncpuname = "C3 'Ezra-T' [C5M]";\r\nlonghaul_version = TYPE_POWERSAVER;\r\nnumscales = 32;\r\nmemcpy(mults, ezrat_mults, sizeof(ezrat_mults));\r\nmemcpy(eblcr, ezrat_eblcr, sizeof(ezrat_eblcr));\r\nbreak;\r\ncase 9:\r\nlonghaul_version = TYPE_POWERSAVER;\r\nnumscales = 32;\r\nmemcpy(mults, nehemiah_mults, sizeof(nehemiah_mults));\r\nmemcpy(eblcr, nehemiah_eblcr, sizeof(nehemiah_eblcr));\r\nswitch (c->x86_mask) {\r\ncase 0 ... 1:\r\ncpu_model = CPU_NEHEMIAH;\r\ncpuname = "C3 'Nehemiah A' [C5XLOE]";\r\nbreak;\r\ncase 2 ... 4:\r\ncpu_model = CPU_NEHEMIAH;\r\ncpuname = "C3 'Nehemiah B' [C5XLOH]";\r\nbreak;\r\ncase 5 ... 15:\r\ncpu_model = CPU_NEHEMIAH_C;\r\ncpuname = "C3 'Nehemiah C' [C5P]";\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\ncpuname = "Unknown";\r\nbreak;\r\n}\r\nif (longhaul_version == TYPE_LONGHAUL_V2) {\r\nrdmsr(MSR_VIA_LONGHAUL, lo, hi);\r\nif (lo == 0 && hi == 0)\r\nlonghaul_version = TYPE_LONGHAUL_V1;\r\n}\r\nprintk(KERN_INFO PFX "VIA %s CPU detected. ", cpuname);\r\nswitch (longhaul_version) {\r\ncase TYPE_LONGHAUL_V1:\r\ncase TYPE_LONGHAUL_V2:\r\nprintk(KERN_CONT "Longhaul v%d supported.\n", longhaul_version);\r\nbreak;\r\ncase TYPE_POWERSAVER:\r\nprintk(KERN_CONT "Powersaver supported.\n");\r\nbreak;\r\n};\r\nlonghaul_setup_southbridge();\r\nacpi_walk_namespace(ACPI_TYPE_PROCESSOR, ACPI_ROOT_OBJECT,\r\nACPI_UINT32_MAX, &longhaul_walk_callback, NULL,\r\nNULL, (void *)&pr);\r\nif (pr != NULL && longhaul_version == TYPE_POWERSAVER) {\r\ncx = &pr->power.states[ACPI_STATE_C3];\r\nif (cx->address > 0 && cx->latency <= 1000)\r\nlonghaul_flags |= USE_ACPI_C3;\r\n}\r\nif (disable_acpi_c3)\r\nlonghaul_flags &= ~USE_ACPI_C3;\r\nif (enable_arbiter_disable())\r\nlonghaul_flags |= USE_NORTHBRIDGE;\r\nif (!(longhaul_flags & USE_ACPI_C3\r\n|| longhaul_flags & USE_NORTHBRIDGE)\r\n&& ((pr == NULL) || !(pr->flags.bm_control))) {\r\nprintk(KERN_ERR PFX\r\n"No ACPI support. Unsupported northbridge.\n");\r\nreturn -ENODEV;\r\n}\r\nif (longhaul_flags & USE_NORTHBRIDGE)\r\nprintk(KERN_INFO PFX "Using northbridge support.\n");\r\nif (longhaul_flags & USE_ACPI_C3)\r\nprintk(KERN_INFO PFX "Using ACPI support.\n");\r\nret = longhaul_get_ranges();\r\nif (ret != 0)\r\nreturn ret;\r\nif ((longhaul_version != TYPE_LONGHAUL_V1) && (scale_voltage != 0))\r\nlonghaul_setup_voltagescaling();\r\npolicy->cpuinfo.transition_latency = 200000;\r\nreturn cpufreq_table_validate_and_show(policy, longhaul_table);\r\n}\r\nstatic int __init longhaul_init(void)\r\n{\r\nstruct cpuinfo_x86 *c = &cpu_data(0);\r\nif (!x86_match_cpu(longhaul_id))\r\nreturn -ENODEV;\r\nif (!enable) {\r\nprintk(KERN_ERR PFX "Option \"enable\" not set. Aborting.\n");\r\nreturn -ENODEV;\r\n}\r\n#ifdef CONFIG_SMP\r\nif (num_online_cpus() > 1) {\r\nprintk(KERN_ERR PFX "More than 1 CPU detected, "\r\n"longhaul disabled.\n");\r\nreturn -ENODEV;\r\n}\r\n#endif\r\n#ifdef CONFIG_X86_IO_APIC\r\nif (cpu_has_apic) {\r\nprintk(KERN_ERR PFX "APIC detected. Longhaul is currently "\r\n"broken in this configuration.\n");\r\nreturn -ENODEV;\r\n}\r\n#endif\r\nswitch (c->x86_model) {\r\ncase 6 ... 9:\r\nreturn cpufreq_register_driver(&longhaul_driver);\r\ncase 10:\r\nprintk(KERN_ERR PFX "Use acpi-cpufreq driver for VIA C7\n");\r\ndefault:\r\n;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic void __exit longhaul_exit(void)\r\n{\r\nstruct cpufreq_policy *policy = cpufreq_cpu_get(0);\r\nint i;\r\nfor (i = 0; i < numscales; i++) {\r\nif (mults[i] == maxmult) {\r\nstruct cpufreq_freqs freqs;\r\nfreqs.old = policy->cur;\r\nfreqs.new = longhaul_table[i].frequency;\r\nfreqs.flags = 0;\r\ncpufreq_freq_transition_begin(policy, &freqs);\r\nlonghaul_setstate(policy, i);\r\ncpufreq_freq_transition_end(policy, &freqs, 0);\r\nbreak;\r\n}\r\n}\r\ncpufreq_cpu_put(policy);\r\ncpufreq_unregister_driver(&longhaul_driver);\r\nkfree(longhaul_table);\r\n}
