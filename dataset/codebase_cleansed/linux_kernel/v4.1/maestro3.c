static inline void snd_m3_outw(struct snd_m3 *chip, u16 value, unsigned long reg)\r\n{\r\noutw(value, chip->iobase + reg);\r\n}\r\nstatic inline u16 snd_m3_inw(struct snd_m3 *chip, unsigned long reg)\r\n{\r\nreturn inw(chip->iobase + reg);\r\n}\r\nstatic inline void snd_m3_outb(struct snd_m3 *chip, u8 value, unsigned long reg)\r\n{\r\noutb(value, chip->iobase + reg);\r\n}\r\nstatic inline u8 snd_m3_inb(struct snd_m3 *chip, unsigned long reg)\r\n{\r\nreturn inb(chip->iobase + reg);\r\n}\r\nstatic u16 snd_m3_assp_read(struct snd_m3 *chip, u16 region, u16 index)\r\n{\r\nsnd_m3_outw(chip, region & MEMTYPE_MASK, DSP_PORT_MEMORY_TYPE);\r\nsnd_m3_outw(chip, index, DSP_PORT_MEMORY_INDEX);\r\nreturn snd_m3_inw(chip, DSP_PORT_MEMORY_DATA);\r\n}\r\nstatic void snd_m3_assp_write(struct snd_m3 *chip, u16 region, u16 index, u16 data)\r\n{\r\nsnd_m3_outw(chip, region & MEMTYPE_MASK, DSP_PORT_MEMORY_TYPE);\r\nsnd_m3_outw(chip, index, DSP_PORT_MEMORY_INDEX);\r\nsnd_m3_outw(chip, data, DSP_PORT_MEMORY_DATA);\r\n}\r\nstatic void snd_m3_assp_halt(struct snd_m3 *chip)\r\n{\r\nchip->reset_state = snd_m3_inb(chip, DSP_PORT_CONTROL_REG_B) & ~REGB_STOP_CLOCK;\r\nmsleep(10);\r\nsnd_m3_outb(chip, chip->reset_state & ~REGB_ENABLE_RESET, DSP_PORT_CONTROL_REG_B);\r\n}\r\nstatic void snd_m3_assp_continue(struct snd_m3 *chip)\r\n{\r\nsnd_m3_outb(chip, chip->reset_state | REGB_ENABLE_RESET, DSP_PORT_CONTROL_REG_B);\r\n}\r\nstatic int snd_m3_add_list(struct snd_m3 *chip, struct m3_list *list, u16 val)\r\n{\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\r\nlist->mem_addr + list->curlen,\r\nval);\r\nreturn list->curlen++;\r\n}\r\nstatic void snd_m3_remove_list(struct snd_m3 *chip, struct m3_list *list, int index)\r\n{\r\nu16 val;\r\nint lastindex = list->curlen - 1;\r\nif (index != lastindex) {\r\nval = snd_m3_assp_read(chip, MEMTYPE_INTERNAL_DATA,\r\nlist->mem_addr + lastindex);\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\r\nlist->mem_addr + index,\r\nval);\r\n}\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\r\nlist->mem_addr + lastindex,\r\n0);\r\nlist->curlen--;\r\n}\r\nstatic void snd_m3_inc_timer_users(struct snd_m3 *chip)\r\n{\r\nchip->timer_users++;\r\nif (chip->timer_users != 1)\r\nreturn;\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\r\nKDATA_TIMER_COUNT_RELOAD,\r\n240);\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\r\nKDATA_TIMER_COUNT_CURRENT,\r\n240);\r\nsnd_m3_outw(chip,\r\nsnd_m3_inw(chip, HOST_INT_CTRL) | CLKRUN_GEN_ENABLE,\r\nHOST_INT_CTRL);\r\n}\r\nstatic void snd_m3_dec_timer_users(struct snd_m3 *chip)\r\n{\r\nchip->timer_users--;\r\nif (chip->timer_users > 0)\r\nreturn;\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\r\nKDATA_TIMER_COUNT_RELOAD,\r\n0);\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\r\nKDATA_TIMER_COUNT_CURRENT,\r\n0);\r\nsnd_m3_outw(chip,\r\nsnd_m3_inw(chip, HOST_INT_CTRL) & ~CLKRUN_GEN_ENABLE,\r\nHOST_INT_CTRL);\r\n}\r\nstatic int snd_m3_pcm_start(struct snd_m3 *chip, struct m3_dma *s,\r\nstruct snd_pcm_substream *subs)\r\n{\r\nif (! s || ! subs)\r\nreturn -EINVAL;\r\nsnd_m3_inc_timer_users(chip);\r\nswitch (subs->stream) {\r\ncase SNDRV_PCM_STREAM_PLAYBACK:\r\nchip->dacs_active++;\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\r\ns->inst.data + CDATA_INSTANCE_READY, 1);\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\r\nKDATA_MIXER_TASK_NUMBER,\r\nchip->dacs_active);\r\nbreak;\r\ncase SNDRV_PCM_STREAM_CAPTURE:\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\r\nKDATA_ADC1_REQUEST, 1);\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\r\ns->inst.data + CDATA_INSTANCE_READY, 1);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_m3_pcm_stop(struct snd_m3 *chip, struct m3_dma *s,\r\nstruct snd_pcm_substream *subs)\r\n{\r\nif (! s || ! subs)\r\nreturn -EINVAL;\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\r\ns->inst.data + CDATA_INSTANCE_READY, 0);\r\nsnd_m3_dec_timer_users(chip);\r\nswitch (subs->stream) {\r\ncase SNDRV_PCM_STREAM_PLAYBACK:\r\nchip->dacs_active--;\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\r\nKDATA_MIXER_TASK_NUMBER,\r\nchip->dacs_active);\r\nbreak;\r\ncase SNDRV_PCM_STREAM_CAPTURE:\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\r\nKDATA_ADC1_REQUEST, 0);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_m3_pcm_trigger(struct snd_pcm_substream *subs, int cmd)\r\n{\r\nstruct snd_m3 *chip = snd_pcm_substream_chip(subs);\r\nstruct m3_dma *s = subs->runtime->private_data;\r\nint err = -EINVAL;\r\nif (snd_BUG_ON(!s))\r\nreturn -ENXIO;\r\nspin_lock(&chip->reg_lock);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nif (s->running)\r\nerr = -EBUSY;\r\nelse {\r\ns->running = 1;\r\nerr = snd_m3_pcm_start(chip, s, subs);\r\n}\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nif (! s->running)\r\nerr = 0;\r\nelse {\r\ns->running = 0;\r\nerr = snd_m3_pcm_stop(chip, s, subs);\r\n}\r\nbreak;\r\n}\r\nspin_unlock(&chip->reg_lock);\r\nreturn err;\r\n}\r\nstatic void\r\nsnd_m3_pcm_setup1(struct snd_m3 *chip, struct m3_dma *s, struct snd_pcm_substream *subs)\r\n{\r\nint dsp_in_size, dsp_out_size, dsp_in_buffer, dsp_out_buffer;\r\nstruct snd_pcm_runtime *runtime = subs->runtime;\r\nif (subs->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\ndsp_in_size = MINISRC_IN_BUFFER_SIZE - (0x20 * 2);\r\ndsp_out_size = MINISRC_OUT_BUFFER_SIZE - (0x20 * 2);\r\n} else {\r\ndsp_in_size = MINISRC_IN_BUFFER_SIZE - (0x10 * 2);\r\ndsp_out_size = MINISRC_OUT_BUFFER_SIZE - (0x10 * 2);\r\n}\r\ndsp_in_buffer = s->inst.data + (MINISRC_TMP_BUFFER_SIZE / 2);\r\ndsp_out_buffer = dsp_in_buffer + (dsp_in_size / 2) + 1;\r\ns->dma_size = frames_to_bytes(runtime, runtime->buffer_size);\r\ns->period_size = frames_to_bytes(runtime, runtime->period_size);\r\ns->hwptr = 0;\r\ns->count = 0;\r\n#define LO(x) ((x) & 0xffff)\r\n#define HI(x) LO((x) >> 16)\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\r\ns->inst.data + CDATA_HOST_SRC_ADDRL,\r\nLO(s->buffer_addr));\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\r\ns->inst.data + CDATA_HOST_SRC_ADDRH,\r\nHI(s->buffer_addr));\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\r\ns->inst.data + CDATA_HOST_SRC_END_PLUS_1L,\r\nLO(s->buffer_addr + s->dma_size));\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\r\ns->inst.data + CDATA_HOST_SRC_END_PLUS_1H,\r\nHI(s->buffer_addr + s->dma_size));\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\r\ns->inst.data + CDATA_HOST_SRC_CURRENTL,\r\nLO(s->buffer_addr));\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\r\ns->inst.data + CDATA_HOST_SRC_CURRENTH,\r\nHI(s->buffer_addr));\r\n#undef LO\r\n#undef HI\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\r\ns->inst.data + CDATA_IN_BUF_BEGIN,\r\ndsp_in_buffer);\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\r\ns->inst.data + CDATA_IN_BUF_END_PLUS_1,\r\ndsp_in_buffer + (dsp_in_size / 2));\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\r\ns->inst.data + CDATA_IN_BUF_HEAD,\r\ndsp_in_buffer);\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\r\ns->inst.data + CDATA_IN_BUF_TAIL,\r\ndsp_in_buffer);\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\r\ns->inst.data + CDATA_OUT_BUF_BEGIN,\r\ndsp_out_buffer);\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\r\ns->inst.data + CDATA_OUT_BUF_END_PLUS_1,\r\ndsp_out_buffer + (dsp_out_size / 2));\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\r\ns->inst.data + CDATA_OUT_BUF_HEAD,\r\ndsp_out_buffer);\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\r\ns->inst.data + CDATA_OUT_BUF_TAIL,\r\ndsp_out_buffer);\r\n}\r\nstatic void snd_m3_pcm_setup2(struct snd_m3 *chip, struct m3_dma *s,\r\nstruct snd_pcm_runtime *runtime)\r\n{\r\nu32 freq;\r\nif (! s->in_lists) {\r\ns->index[0] = snd_m3_add_list(chip, s->index_list[0],\r\ns->inst.data >> DP_SHIFT_COUNT);\r\ns->index[1] = snd_m3_add_list(chip, s->index_list[1],\r\ns->inst.data >> DP_SHIFT_COUNT);\r\ns->index[2] = snd_m3_add_list(chip, s->index_list[2],\r\ns->inst.data >> DP_SHIFT_COUNT);\r\ns->in_lists = 1;\r\n}\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\r\ns->inst.data + SRC3_DIRECTION_OFFSET + 1,\r\nruntime->channels == 2 ? 0 : 1);\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\r\ns->inst.data + SRC3_DIRECTION_OFFSET + 2,\r\nsnd_pcm_format_width(runtime->format) == 16 ? 0 : 1);\r\nfreq = ((runtime->rate << 15) + 24000 ) / 48000;\r\nif (freq)\r\nfreq--;\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\r\ns->inst.data + CDATA_FREQUENCY,\r\nfreq);\r\n}\r\nstatic void\r\nsnd_m3_playback_setup(struct snd_m3 *chip, struct m3_dma *s,\r\nstruct snd_pcm_substream *subs)\r\n{\r\nunsigned int i;\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\r\ns->inst.data + SRC3_DIRECTION_OFFSET + 12,\r\ns->inst.data + 40 + 8);\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\r\ns->inst.data + SRC3_DIRECTION_OFFSET + 19,\r\ns->inst.code + MINISRC_COEF_LOC);\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\r\ns->inst.data + SRC3_DIRECTION_OFFSET + 22,\r\nsubs->runtime->rate > 45000 ? 0xff : 0);\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\r\ns->inst.data + CDATA_DMA_CONTROL,\r\nDMACONTROL_AUTOREPEAT + DMAC_PAGE3_SELECTOR + DMAC_BLOCKF_SELECTOR);\r\nfor (i = 0; i < ARRAY_SIZE(pv); i++)\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\r\ns->inst.data + pv[i].addr, pv[i].val);\r\n}\r\nstatic void\r\nsnd_m3_capture_setup(struct snd_m3 *chip, struct m3_dma *s, struct snd_pcm_substream *subs)\r\n{\r\nunsigned int i;\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\r\ns->inst.data + SRC3_DIRECTION_OFFSET + 12,\r\ns->inst.data + 40 + 8);\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\r\ns->inst.data + CDATA_DMA_CONTROL,\r\nDMACONTROL_DIRECTION + DMACONTROL_AUTOREPEAT +\r\nDMAC_PAGE3_SELECTOR + DMAC_BLOCKF_SELECTOR);\r\nfor (i = 0; i < ARRAY_SIZE(rv); i++)\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\r\ns->inst.data + rv[i].addr, rv[i].val);\r\n}\r\nstatic int snd_m3_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct m3_dma *s = substream->runtime->private_data;\r\nint err;\r\nif ((err = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params))) < 0)\r\nreturn err;\r\ns->buffer_addr = substream->runtime->dma_addr;\r\nif (s->buffer_addr & 0x3) {\r\ndev_err(substream->pcm->card->dev, "oh my, not aligned\n");\r\ns->buffer_addr = s->buffer_addr & ~0x3;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_m3_pcm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct m3_dma *s;\r\nif (substream->runtime->private_data == NULL)\r\nreturn 0;\r\ns = substream->runtime->private_data;\r\nsnd_pcm_lib_free_pages(substream);\r\ns->buffer_addr = 0;\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_m3_pcm_prepare(struct snd_pcm_substream *subs)\r\n{\r\nstruct snd_m3 *chip = snd_pcm_substream_chip(subs);\r\nstruct snd_pcm_runtime *runtime = subs->runtime;\r\nstruct m3_dma *s = runtime->private_data;\r\nif (snd_BUG_ON(!s))\r\nreturn -ENXIO;\r\nif (runtime->format != SNDRV_PCM_FORMAT_U8 &&\r\nruntime->format != SNDRV_PCM_FORMAT_S16_LE)\r\nreturn -EINVAL;\r\nif (runtime->rate > 48000 ||\r\nruntime->rate < 8000)\r\nreturn -EINVAL;\r\nspin_lock_irq(&chip->reg_lock);\r\nsnd_m3_pcm_setup1(chip, s, subs);\r\nif (subs->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nsnd_m3_playback_setup(chip, s, subs);\r\nelse\r\nsnd_m3_capture_setup(chip, s, subs);\r\nsnd_m3_pcm_setup2(chip, s, runtime);\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn 0;\r\n}\r\nstatic unsigned int\r\nsnd_m3_get_pointer(struct snd_m3 *chip, struct m3_dma *s, struct snd_pcm_substream *subs)\r\n{\r\nu16 hi = 0, lo = 0;\r\nint retry = 10;\r\nu32 addr;\r\nwhile (retry--) {\r\nhi = snd_m3_assp_read(chip, MEMTYPE_INTERNAL_DATA,\r\ns->inst.data + CDATA_HOST_SRC_CURRENTH);\r\nlo = snd_m3_assp_read(chip, MEMTYPE_INTERNAL_DATA,\r\ns->inst.data + CDATA_HOST_SRC_CURRENTL);\r\nif (hi == snd_m3_assp_read(chip, MEMTYPE_INTERNAL_DATA,\r\ns->inst.data + CDATA_HOST_SRC_CURRENTH))\r\nbreak;\r\n}\r\naddr = lo | ((u32)hi<<16);\r\nreturn (unsigned int)(addr - s->buffer_addr);\r\n}\r\nstatic snd_pcm_uframes_t\r\nsnd_m3_pcm_pointer(struct snd_pcm_substream *subs)\r\n{\r\nstruct snd_m3 *chip = snd_pcm_substream_chip(subs);\r\nunsigned int ptr;\r\nstruct m3_dma *s = subs->runtime->private_data;\r\nif (snd_BUG_ON(!s))\r\nreturn 0;\r\nspin_lock(&chip->reg_lock);\r\nptr = snd_m3_get_pointer(chip, s, subs);\r\nspin_unlock(&chip->reg_lock);\r\nreturn bytes_to_frames(subs->runtime, ptr);\r\n}\r\nstatic void snd_m3_update_ptr(struct snd_m3 *chip, struct m3_dma *s)\r\n{\r\nstruct snd_pcm_substream *subs = s->substream;\r\nunsigned int hwptr;\r\nint diff;\r\nif (! s->running)\r\nreturn;\r\nhwptr = snd_m3_get_pointer(chip, s, subs);\r\nif (hwptr >= s->dma_size)\r\nhwptr %= s->dma_size;\r\ndiff = s->dma_size + hwptr - s->hwptr;\r\nif (diff >= s->dma_size)\r\ndiff %= s->dma_size;\r\ns->hwptr = hwptr;\r\ns->count += diff;\r\nif (s->count >= (signed)s->period_size) {\r\nif (s->count < 2 * (signed)s->period_size)\r\ns->count -= (signed)s->period_size;\r\nelse\r\ns->count %= s->period_size;\r\nspin_unlock(&chip->reg_lock);\r\nsnd_pcm_period_elapsed(subs);\r\nspin_lock(&chip->reg_lock);\r\n}\r\n}\r\nstatic void snd_m3_update_hw_volume(struct work_struct *work)\r\n{\r\nstruct snd_m3 *chip = container_of(work, struct snd_m3, hwvol_work);\r\nint x, val;\r\nx = inb(chip->iobase + SHADOW_MIX_REG_VOICE) & 0xee;\r\noutb(0x88, chip->iobase + SHADOW_MIX_REG_VOICE);\r\noutb(0x88, chip->iobase + HW_VOL_COUNTER_VOICE);\r\noutb(0x88, chip->iobase + SHADOW_MIX_REG_MASTER);\r\noutb(0x88, chip->iobase + HW_VOL_COUNTER_MASTER);\r\nif (chip->in_suspend)\r\nreturn;\r\n#ifndef CONFIG_SND_MAESTRO3_INPUT\r\nif (!chip->master_switch || !chip->master_volume)\r\nreturn;\r\nval = snd_ac97_read(chip->ac97, AC97_MASTER);\r\nswitch (x) {\r\ncase 0x88:\r\nval ^= 0x8000;\r\nbreak;\r\ncase 0xaa:\r\nif ((val & 0x7f) > 0)\r\nval--;\r\nif ((val & 0x7f00) > 0)\r\nval -= 0x0100;\r\nbreak;\r\ncase 0x66:\r\nif ((val & 0x7f) < 0x1f)\r\nval++;\r\nif ((val & 0x7f00) < 0x1f00)\r\nval += 0x0100;\r\nbreak;\r\n}\r\nif (snd_ac97_update(chip->ac97, AC97_MASTER, val))\r\nsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&chip->master_switch->id);\r\n#else\r\nif (!chip->input_dev)\r\nreturn;\r\nval = 0;\r\nswitch (x) {\r\ncase 0x88:\r\nval = KEY_MUTE;\r\nbreak;\r\ncase 0xaa:\r\nval = KEY_VOLUMEUP;\r\nbreak;\r\ncase 0x66:\r\nval = KEY_VOLUMEDOWN;\r\nbreak;\r\n}\r\nif (val) {\r\ninput_report_key(chip->input_dev, val, 1);\r\ninput_sync(chip->input_dev);\r\ninput_report_key(chip->input_dev, val, 0);\r\ninput_sync(chip->input_dev);\r\n}\r\n#endif\r\n}\r\nstatic irqreturn_t snd_m3_interrupt(int irq, void *dev_id)\r\n{\r\nstruct snd_m3 *chip = dev_id;\r\nu8 status;\r\nint i;\r\nstatus = inb(chip->iobase + HOST_INT_STATUS);\r\nif (status == 0xff)\r\nreturn IRQ_NONE;\r\nif (status & HV_INT_PENDING)\r\nschedule_work(&chip->hwvol_work);\r\nif (status & ASSP_INT_PENDING) {\r\nu8 ctl = inb(chip->iobase + ASSP_CONTROL_B);\r\nif (!(ctl & STOP_ASSP_CLOCK)) {\r\nctl = inb(chip->iobase + ASSP_HOST_INT_STATUS);\r\nif (ctl & DSP2HOST_REQ_TIMER) {\r\noutb(DSP2HOST_REQ_TIMER, chip->iobase + ASSP_HOST_INT_STATUS);\r\nspin_lock(&chip->reg_lock);\r\nfor (i = 0; i < chip->num_substreams; i++) {\r\nstruct m3_dma *s = &chip->substreams[i];\r\nif (s->running)\r\nsnd_m3_update_ptr(chip, s);\r\n}\r\nspin_unlock(&chip->reg_lock);\r\n}\r\n}\r\n}\r\n#if 0\r\nif ((status & MPU401_INT_PENDING) && chip->rmidi)\r\nsnd_mpu401_uart_interrupt(irq, chip->rmidi->private_data, regs);\r\n#endif\r\noutb(status, chip->iobase + HOST_INT_STATUS);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int\r\nsnd_m3_substream_open(struct snd_m3 *chip, struct snd_pcm_substream *subs)\r\n{\r\nint i;\r\nstruct m3_dma *s;\r\nspin_lock_irq(&chip->reg_lock);\r\nfor (i = 0; i < chip->num_substreams; i++) {\r\ns = &chip->substreams[i];\r\nif (! s->opened)\r\ngoto __found;\r\n}\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn -ENOMEM;\r\n__found:\r\ns->opened = 1;\r\ns->running = 0;\r\nspin_unlock_irq(&chip->reg_lock);\r\nsubs->runtime->private_data = s;\r\ns->substream = subs;\r\nif (subs->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\ns->index_list[0] = &chip->mixer_list;\r\n} else\r\ns->index_list[0] = &chip->adc1_list;\r\ns->index_list[1] = &chip->msrc_list;\r\ns->index_list[2] = &chip->dma_list;\r\nreturn 0;\r\n}\r\nstatic void\r\nsnd_m3_substream_close(struct snd_m3 *chip, struct snd_pcm_substream *subs)\r\n{\r\nstruct m3_dma *s = subs->runtime->private_data;\r\nif (s == NULL)\r\nreturn;\r\nspin_lock_irq(&chip->reg_lock);\r\nif (s->substream && s->running)\r\nsnd_m3_pcm_stop(chip, s, s->substream);\r\nif (s->in_lists) {\r\nsnd_m3_remove_list(chip, s->index_list[0], s->index[0]);\r\nsnd_m3_remove_list(chip, s->index_list[1], s->index[1]);\r\nsnd_m3_remove_list(chip, s->index_list[2], s->index[2]);\r\ns->in_lists = 0;\r\n}\r\ns->running = 0;\r\ns->opened = 0;\r\nspin_unlock_irq(&chip->reg_lock);\r\n}\r\nstatic int\r\nsnd_m3_playback_open(struct snd_pcm_substream *subs)\r\n{\r\nstruct snd_m3 *chip = snd_pcm_substream_chip(subs);\r\nstruct snd_pcm_runtime *runtime = subs->runtime;\r\nint err;\r\nif ((err = snd_m3_substream_open(chip, subs)) < 0)\r\nreturn err;\r\nruntime->hw = snd_m3_playback;\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_m3_playback_close(struct snd_pcm_substream *subs)\r\n{\r\nstruct snd_m3 *chip = snd_pcm_substream_chip(subs);\r\nsnd_m3_substream_close(chip, subs);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_m3_capture_open(struct snd_pcm_substream *subs)\r\n{\r\nstruct snd_m3 *chip = snd_pcm_substream_chip(subs);\r\nstruct snd_pcm_runtime *runtime = subs->runtime;\r\nint err;\r\nif ((err = snd_m3_substream_open(chip, subs)) < 0)\r\nreturn err;\r\nruntime->hw = snd_m3_capture;\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_m3_capture_close(struct snd_pcm_substream *subs)\r\n{\r\nstruct snd_m3 *chip = snd_pcm_substream_chip(subs);\r\nsnd_m3_substream_close(chip, subs);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_m3_pcm(struct snd_m3 * chip, int device)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nerr = snd_pcm_new(chip->card, chip->card->driver, device,\r\nMAX_PLAYBACKS, MAX_CAPTURES, &pcm);\r\nif (err < 0)\r\nreturn err;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_m3_playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_m3_capture_ops);\r\npcm->private_data = chip;\r\npcm->info_flags = 0;\r\nstrcpy(pcm->name, chip->card->driver);\r\nchip->pcm = pcm;\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(chip->pci), 64*1024, 64*1024);\r\nreturn 0;\r\n}\r\nstatic int snd_m3_ac97_wait(struct snd_m3 *chip)\r\n{\r\nint i = 10000;\r\ndo {\r\nif (! (snd_m3_inb(chip, 0x30) & 1))\r\nreturn 0;\r\ncpu_relax();\r\n} while (i-- > 0);\r\ndev_err(chip->card->dev, "ac97 serial bus busy\n");\r\nreturn 1;\r\n}\r\nstatic unsigned short\r\nsnd_m3_ac97_read(struct snd_ac97 *ac97, unsigned short reg)\r\n{\r\nstruct snd_m3 *chip = ac97->private_data;\r\nunsigned short data = 0xffff;\r\nif (snd_m3_ac97_wait(chip))\r\ngoto fail;\r\nsnd_m3_outb(chip, 0x80 | (reg & 0x7f), CODEC_COMMAND);\r\nif (snd_m3_ac97_wait(chip))\r\ngoto fail;\r\ndata = snd_m3_inw(chip, CODEC_DATA);\r\nfail:\r\nreturn data;\r\n}\r\nstatic void\r\nsnd_m3_ac97_write(struct snd_ac97 *ac97, unsigned short reg, unsigned short val)\r\n{\r\nstruct snd_m3 *chip = ac97->private_data;\r\nif (snd_m3_ac97_wait(chip))\r\nreturn;\r\nsnd_m3_outw(chip, val, CODEC_DATA);\r\nsnd_m3_outb(chip, reg & 0x7f, CODEC_COMMAND);\r\n}\r\nstatic void snd_m3_remote_codec_config(int io, int isremote)\r\n{\r\nisremote = isremote ? 1 : 0;\r\noutw((inw(io + RING_BUS_CTRL_B) & ~SECOND_CODEC_ID_MASK) | isremote,\r\nio + RING_BUS_CTRL_B);\r\noutw((inw(io + SDO_OUT_DEST_CTRL) & ~COMMAND_ADDR_OUT) | isremote,\r\nio + SDO_OUT_DEST_CTRL);\r\noutw((inw(io + SDO_IN_DEST_CTRL) & ~STATUS_ADDR_IN) | isremote,\r\nio + SDO_IN_DEST_CTRL);\r\n}\r\nstatic int snd_m3_try_read_vendor(struct snd_m3 *chip)\r\n{\r\nu16 ret;\r\nif (snd_m3_ac97_wait(chip))\r\nreturn 1;\r\nsnd_m3_outb(chip, 0x80 | (AC97_VENDOR_ID1 & 0x7f), 0x30);\r\nif (snd_m3_ac97_wait(chip))\r\nreturn 1;\r\nret = snd_m3_inw(chip, 0x32);\r\nreturn (ret == 0) || (ret == 0xffff);\r\n}\r\nstatic void snd_m3_ac97_reset(struct snd_m3 *chip)\r\n{\r\nu16 dir;\r\nint delay1 = 0, delay2 = 0, i;\r\nint io = chip->iobase;\r\nif (chip->allegro_flag) {\r\ndelay1 = 50;\r\ndelay2 = 800;\r\n} else {\r\ndelay1 = 20;\r\ndelay2 = 500;\r\n}\r\nfor (i = 0; i < 5; i++) {\r\ndir = inw(io + GPIO_DIRECTION);\r\nif (!chip->irda_workaround)\r\ndir |= 0x10;\r\nsnd_m3_remote_codec_config(io, 0);\r\noutw(IO_SRAM_ENABLE, io + RING_BUS_CTRL_A);\r\nudelay(20);\r\noutw(dir & ~GPO_PRIMARY_AC97 , io + GPIO_DIRECTION);\r\noutw(~GPO_PRIMARY_AC97 , io + GPIO_MASK);\r\noutw(0, io + GPIO_DATA);\r\noutw(dir | GPO_PRIMARY_AC97, io + GPIO_DIRECTION);\r\nschedule_timeout_uninterruptible(msecs_to_jiffies(delay1));\r\noutw(GPO_PRIMARY_AC97, io + GPIO_DATA);\r\nudelay(5);\r\noutw(IO_SRAM_ENABLE | SERIAL_AC_LINK_ENABLE, io + RING_BUS_CTRL_A);\r\noutw(~0, io + GPIO_MASK);\r\nschedule_timeout_uninterruptible(msecs_to_jiffies(delay2));\r\nif (! snd_m3_try_read_vendor(chip))\r\nbreak;\r\ndelay1 += 10;\r\ndelay2 += 100;\r\ndev_dbg(chip->card->dev,\r\n"retrying codec reset with delays of %d and %d ms\n",\r\ndelay1, delay2);\r\n}\r\n#if 0\r\ntmp = inw(io + RING_BUS_CTRL_A);\r\noutw(RAC_SDFS_ENABLE|LAC_SDFS_ENABLE, io + RING_BUS_CTRL_A);\r\nmsleep(20);\r\noutw(tmp, io + RING_BUS_CTRL_A);\r\nmsleep(50);\r\n#endif\r\n}\r\nstatic int snd_m3_mixer(struct snd_m3 *chip)\r\n{\r\nstruct snd_ac97_bus *pbus;\r\nstruct snd_ac97_template ac97;\r\n#ifndef CONFIG_SND_MAESTRO3_INPUT\r\nstruct snd_ctl_elem_id elem_id;\r\n#endif\r\nint err;\r\nstatic struct snd_ac97_bus_ops ops = {\r\n.write = snd_m3_ac97_write,\r\n.read = snd_m3_ac97_read,\r\n};\r\nif ((err = snd_ac97_bus(chip->card, 0, &ops, NULL, &pbus)) < 0)\r\nreturn err;\r\nmemset(&ac97, 0, sizeof(ac97));\r\nac97.private_data = chip;\r\nif ((err = snd_ac97_mixer(pbus, &ac97, &chip->ac97)) < 0)\r\nreturn err;\r\nsnd_ac97_write(chip->ac97, AC97_PCM, 0x8000 | (15 << 8) | 15);\r\nschedule_timeout_uninterruptible(msecs_to_jiffies(100));\r\nsnd_ac97_write(chip->ac97, AC97_PCM, 0);\r\n#ifndef CONFIG_SND_MAESTRO3_INPUT\r\nmemset(&elem_id, 0, sizeof(elem_id));\r\nelem_id.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nstrcpy(elem_id.name, "Master Playback Switch");\r\nchip->master_switch = snd_ctl_find_id(chip->card, &elem_id);\r\nmemset(&elem_id, 0, sizeof(elem_id));\r\nelem_id.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nstrcpy(elem_id.name, "Master Playback Volume");\r\nchip->master_volume = snd_ctl_find_id(chip->card, &elem_id);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void snd_m3_assp_init(struct snd_m3 *chip)\r\n{\r\nunsigned int i;\r\nconst u16 *data;\r\nfor (i = 0; i < (REV_B_DATA_MEMORY_UNIT_LENGTH * NUM_UNITS_KERNEL_DATA) / 2; i++)\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\r\nKDATA_BASE_ADDR + i, 0);\r\nfor (i = 0; i < (REV_B_DATA_MEMORY_UNIT_LENGTH * NUM_UNITS_KERNEL_DATA) / 2; i++)\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\r\nKDATA_BASE_ADDR2 + i, 0);\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\r\nKDATA_CURRENT_DMA,\r\nKDATA_DMA_XFER0);\r\ndata = (const u16 *)chip->assp_kernel_image->data;\r\nfor (i = 0 ; i * 2 < chip->assp_kernel_image->size; i++) {\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_CODE,\r\nREV_B_CODE_MEMORY_BEGIN + i,\r\nle16_to_cpu(data[i]));\r\n}\r\ndata = (const u16 *)chip->assp_minisrc_image->data;\r\nfor (i = 0; i * 2 < chip->assp_minisrc_image->size; i++) {\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_CODE,\r\n0x400 + i, le16_to_cpu(data[i]));\r\n}\r\nfor (i = 0; i < MINISRC_LPF_LEN ; i++) {\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_CODE,\r\n0x400 + MINISRC_COEF_LOC + i,\r\nminisrc_lpf[i]);\r\n}\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_CODE,\r\n0x400 + MINISRC_COEF_LOC + MINISRC_LPF_LEN,\r\n0x8000);\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\r\nKDATA_TASK0,\r\n0x400);\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\r\nKDATA_MIXER_TASK_NUMBER,0);\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\r\nKDATA_DAC_LEFT_VOLUME, ARB_VOLUME);\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\r\nKDATA_DAC_RIGHT_VOLUME, ARB_VOLUME);\r\nchip->mixer_list.curlen = 0;\r\nchip->mixer_list.mem_addr = KDATA_MIXER_XFER0;\r\nchip->mixer_list.max = MAX_VIRTUAL_MIXER_CHANNELS;\r\nchip->adc1_list.curlen = 0;\r\nchip->adc1_list.mem_addr = KDATA_ADC1_XFER0;\r\nchip->adc1_list.max = MAX_VIRTUAL_ADC1_CHANNELS;\r\nchip->dma_list.curlen = 0;\r\nchip->dma_list.mem_addr = KDATA_DMA_XFER0;\r\nchip->dma_list.max = MAX_VIRTUAL_DMA_CHANNELS;\r\nchip->msrc_list.curlen = 0;\r\nchip->msrc_list.mem_addr = KDATA_INSTANCE0_MINISRC;\r\nchip->msrc_list.max = MAX_INSTANCE_MINISRC;\r\n}\r\nstatic int snd_m3_assp_client_init(struct snd_m3 *chip, struct m3_dma *s, int index)\r\n{\r\nint data_bytes = 2 * ( MINISRC_TMP_BUFFER_SIZE / 2 +\r\nMINISRC_IN_BUFFER_SIZE / 2 +\r\n1 + MINISRC_OUT_BUFFER_SIZE / 2 + 1 );\r\nint address, i;\r\ndata_bytes = ALIGN(data_bytes, 256);\r\naddress = 0x1100 + ((data_bytes/2) * index);\r\nif ((address + (data_bytes/2)) >= 0x1c00) {\r\ndev_err(chip->card->dev,\r\n"no memory for %d bytes at ind %d (addr 0x%x)\n",\r\ndata_bytes, index, address);\r\nreturn -ENOMEM;\r\n}\r\ns->number = index;\r\ns->inst.code = 0x400;\r\ns->inst.data = address;\r\nfor (i = data_bytes / 2; i > 0; address++, i--) {\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\r\naddress, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nsnd_m3_amp_enable(struct snd_m3 *chip, int enable)\r\n{\r\nint io = chip->iobase;\r\nu16 gpo, polarity;\r\nif (! chip->external_amp)\r\nreturn;\r\npolarity = enable ? 0 : 1;\r\npolarity = polarity << chip->amp_gpio;\r\ngpo = 1 << chip->amp_gpio;\r\noutw(~gpo, io + GPIO_MASK);\r\noutw(inw(io + GPIO_DIRECTION) | gpo,\r\nio + GPIO_DIRECTION);\r\noutw((GPO_SECONDARY_AC97 | GPO_PRIMARY_AC97 | polarity),\r\nio + GPIO_DATA);\r\noutw(0xffff, io + GPIO_MASK);\r\n}\r\nstatic void\r\nsnd_m3_hv_init(struct snd_m3 *chip)\r\n{\r\nunsigned long io = chip->iobase;\r\nu16 val = GPI_VOL_DOWN | GPI_VOL_UP;\r\nif (!chip->is_omnibook)\r\nreturn;\r\noutw(0xffff, io + GPIO_MASK);\r\noutw(0x0000, io + GPIO_DATA);\r\noutw(~val, io + GPIO_MASK);\r\noutw(inw(io + GPIO_DIRECTION) & ~val, io + GPIO_DIRECTION);\r\noutw(val, io + GPIO_MASK);\r\noutw(0xffff, io + GPIO_MASK);\r\n}\r\nstatic int\r\nsnd_m3_chip_init(struct snd_m3 *chip)\r\n{\r\nstruct pci_dev *pcidev = chip->pci;\r\nunsigned long io = chip->iobase;\r\nu32 n;\r\nu16 w;\r\nu8 t;\r\npci_read_config_word(pcidev, PCI_LEGACY_AUDIO_CTRL, &w);\r\nw &= ~(SOUND_BLASTER_ENABLE|FM_SYNTHESIS_ENABLE|\r\nMPU401_IO_ENABLE|MPU401_IRQ_ENABLE|ALIAS_10BIT_IO|\r\nDISABLE_LEGACY);\r\npci_write_config_word(pcidev, PCI_LEGACY_AUDIO_CTRL, w);\r\npci_read_config_dword(pcidev, PCI_ALLEGRO_CONFIG, &n);\r\nn &= ~(HV_CTRL_ENABLE | REDUCED_DEBOUNCE | HV_BUTTON_FROM_GD);\r\nn |= chip->hv_config;\r\nn |= REDUCED_DEBOUNCE;\r\nn |= PM_CTRL_ENABLE | CLK_DIV_BY_49 | USE_PCI_TIMING;\r\npci_write_config_dword(pcidev, PCI_ALLEGRO_CONFIG, n);\r\noutb(RESET_ASSP, chip->iobase + ASSP_CONTROL_B);\r\npci_read_config_dword(pcidev, PCI_ALLEGRO_CONFIG, &n);\r\nn &= ~INT_CLK_SELECT;\r\nif (!chip->allegro_flag) {\r\nn &= ~INT_CLK_MULT_ENABLE;\r\nn |= INT_CLK_SRC_NOT_PCI;\r\n}\r\nn &= ~( CLK_MULT_MODE_SELECT | CLK_MULT_MODE_SELECT_2 );\r\npci_write_config_dword(pcidev, PCI_ALLEGRO_CONFIG, n);\r\nif (chip->allegro_flag) {\r\npci_read_config_dword(pcidev, PCI_USER_CONFIG, &n);\r\nn |= IN_CLK_12MHZ_SELECT;\r\npci_write_config_dword(pcidev, PCI_USER_CONFIG, n);\r\n}\r\nt = inb(chip->iobase + ASSP_CONTROL_A);\r\nt &= ~( DSP_CLK_36MHZ_SELECT | ASSP_CLK_49MHZ_SELECT);\r\nt |= ASSP_CLK_49MHZ_SELECT;\r\nt |= ASSP_0_WS_ENABLE;\r\noutb(t, chip->iobase + ASSP_CONTROL_A);\r\nsnd_m3_assp_init(chip);\r\noutb(RUN_ASSP, chip->iobase + ASSP_CONTROL_B);\r\noutb(0x00, io + HARDWARE_VOL_CTRL);\r\noutb(0x88, io + SHADOW_MIX_REG_VOICE);\r\noutb(0x88, io + HW_VOL_COUNTER_VOICE);\r\noutb(0x88, io + SHADOW_MIX_REG_MASTER);\r\noutb(0x88, io + HW_VOL_COUNTER_MASTER);\r\nreturn 0;\r\n}\r\nstatic void\r\nsnd_m3_enable_ints(struct snd_m3 *chip)\r\n{\r\nunsigned long io = chip->iobase;\r\nunsigned short val;\r\nval = ASSP_INT_ENABLE ;\r\nif (chip->hv_config & HV_CTRL_ENABLE)\r\nval |= HV_INT_ENABLE;\r\noutb(val, chip->iobase + HOST_INT_STATUS);\r\noutw(val, io + HOST_INT_CTRL);\r\noutb(inb(io + ASSP_CONTROL_C) | ASSP_HOST_INT_ENABLE,\r\nio + ASSP_CONTROL_C);\r\n}\r\nstatic int snd_m3_free(struct snd_m3 *chip)\r\n{\r\nstruct m3_dma *s;\r\nint i;\r\ncancel_work_sync(&chip->hwvol_work);\r\n#ifdef CONFIG_SND_MAESTRO3_INPUT\r\nif (chip->input_dev)\r\ninput_unregister_device(chip->input_dev);\r\n#endif\r\nif (chip->substreams) {\r\nspin_lock_irq(&chip->reg_lock);\r\nfor (i = 0; i < chip->num_substreams; i++) {\r\ns = &chip->substreams[i];\r\nif (s->substream && s->running)\r\nsnd_m3_pcm_stop(chip, s, s->substream);\r\n}\r\nspin_unlock_irq(&chip->reg_lock);\r\nkfree(chip->substreams);\r\n}\r\nif (chip->iobase) {\r\noutw(0, chip->iobase + HOST_INT_CTRL);\r\n}\r\n#ifdef CONFIG_PM_SLEEP\r\nvfree(chip->suspend_mem);\r\n#endif\r\nif (chip->irq >= 0)\r\nfree_irq(chip->irq, chip);\r\nif (chip->iobase)\r\npci_release_regions(chip->pci);\r\nrelease_firmware(chip->assp_kernel_image);\r\nrelease_firmware(chip->assp_minisrc_image);\r\npci_disable_device(chip->pci);\r\nkfree(chip);\r\nreturn 0;\r\n}\r\nstatic int m3_suspend(struct device *dev)\r\n{\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct snd_m3 *chip = card->private_data;\r\nint i, dsp_index;\r\nif (chip->suspend_mem == NULL)\r\nreturn 0;\r\nchip->in_suspend = 1;\r\ncancel_work_sync(&chip->hwvol_work);\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\r\nsnd_pcm_suspend_all(chip->pcm);\r\nsnd_ac97_suspend(chip->ac97);\r\nmsleep(10);\r\nsnd_m3_assp_halt(chip);\r\ndsp_index = 0;\r\nfor (i = REV_B_CODE_MEMORY_BEGIN; i <= REV_B_CODE_MEMORY_END; i++)\r\nchip->suspend_mem[dsp_index++] =\r\nsnd_m3_assp_read(chip, MEMTYPE_INTERNAL_CODE, i);\r\nfor (i = REV_B_DATA_MEMORY_BEGIN ; i <= REV_B_DATA_MEMORY_END; i++)\r\nchip->suspend_mem[dsp_index++] =\r\nsnd_m3_assp_read(chip, MEMTYPE_INTERNAL_DATA, i);\r\nreturn 0;\r\n}\r\nstatic int m3_resume(struct device *dev)\r\n{\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct snd_m3 *chip = card->private_data;\r\nint i, dsp_index;\r\nif (chip->suspend_mem == NULL)\r\nreturn 0;\r\nsnd_m3_outw(chip, 0, 0x54);\r\nsnd_m3_outw(chip, 0, 0x56);\r\nsnd_m3_chip_init(chip);\r\nsnd_m3_assp_halt(chip);\r\nsnd_m3_ac97_reset(chip);\r\ndsp_index = 0;\r\nfor (i = REV_B_CODE_MEMORY_BEGIN; i <= REV_B_CODE_MEMORY_END; i++)\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_CODE, i,\r\nchip->suspend_mem[dsp_index++]);\r\nfor (i = REV_B_DATA_MEMORY_BEGIN ; i <= REV_B_DATA_MEMORY_END; i++)\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA, i,\r\nchip->suspend_mem[dsp_index++]);\r\nsnd_m3_assp_write(chip, MEMTYPE_INTERNAL_DATA,\r\nKDATA_DMA_ACTIVE, 0);\r\nsnd_ac97_resume(chip->ac97);\r\nsnd_m3_assp_continue(chip);\r\nsnd_m3_enable_ints(chip);\r\nsnd_m3_amp_enable(chip, 1);\r\nsnd_m3_hv_init(chip);\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\r\nchip->in_suspend = 0;\r\nreturn 0;\r\n}\r\nstatic int snd_m3_input_register(struct snd_m3 *chip)\r\n{\r\nstruct input_dev *input_dev;\r\nint err;\r\ninput_dev = input_allocate_device();\r\nif (!input_dev)\r\nreturn -ENOMEM;\r\nsnprintf(chip->phys, sizeof(chip->phys), "pci-%s/input0",\r\npci_name(chip->pci));\r\ninput_dev->name = chip->card->driver;\r\ninput_dev->phys = chip->phys;\r\ninput_dev->id.bustype = BUS_PCI;\r\ninput_dev->id.vendor = chip->pci->vendor;\r\ninput_dev->id.product = chip->pci->device;\r\ninput_dev->dev.parent = &chip->pci->dev;\r\n__set_bit(EV_KEY, input_dev->evbit);\r\n__set_bit(KEY_MUTE, input_dev->keybit);\r\n__set_bit(KEY_VOLUMEDOWN, input_dev->keybit);\r\n__set_bit(KEY_VOLUMEUP, input_dev->keybit);\r\nerr = input_register_device(input_dev);\r\nif (err) {\r\ninput_free_device(input_dev);\r\nreturn err;\r\n}\r\nchip->input_dev = input_dev;\r\nreturn 0;\r\n}\r\nstatic int snd_m3_dev_free(struct snd_device *device)\r\n{\r\nstruct snd_m3 *chip = device->device_data;\r\nreturn snd_m3_free(chip);\r\n}\r\nstatic int\r\nsnd_m3_create(struct snd_card *card, struct pci_dev *pci,\r\nint enable_amp,\r\nint amp_gpio,\r\nstruct snd_m3 **chip_ret)\r\n{\r\nstruct snd_m3 *chip;\r\nint i, err;\r\nconst struct snd_pci_quirk *quirk;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_m3_dev_free,\r\n};\r\n*chip_ret = NULL;\r\nif (pci_enable_device(pci))\r\nreturn -EIO;\r\nif (pci_set_dma_mask(pci, DMA_BIT_MASK(28)) < 0 ||\r\npci_set_consistent_dma_mask(pci, DMA_BIT_MASK(28)) < 0) {\r\ndev_err(card->dev,\r\n"architecture does not support 28bit PCI busmaster DMA\n");\r\npci_disable_device(pci);\r\nreturn -ENXIO;\r\n}\r\nchip = kzalloc(sizeof(*chip), GFP_KERNEL);\r\nif (chip == NULL) {\r\npci_disable_device(pci);\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&chip->reg_lock);\r\nswitch (pci->device) {\r\ncase PCI_DEVICE_ID_ESS_ALLEGRO:\r\ncase PCI_DEVICE_ID_ESS_ALLEGRO_1:\r\ncase PCI_DEVICE_ID_ESS_CANYON3D_2LE:\r\ncase PCI_DEVICE_ID_ESS_CANYON3D_2:\r\nchip->allegro_flag = 1;\r\nbreak;\r\n}\r\nchip->card = card;\r\nchip->pci = pci;\r\nchip->irq = -1;\r\nINIT_WORK(&chip->hwvol_work, snd_m3_update_hw_volume);\r\nchip->external_amp = enable_amp;\r\nif (amp_gpio >= 0 && amp_gpio <= 0x0f)\r\nchip->amp_gpio = amp_gpio;\r\nelse {\r\nquirk = snd_pci_quirk_lookup(pci, m3_amp_quirk_list);\r\nif (quirk) {\r\ndev_info(card->dev, "set amp-gpio for '%s'\n",\r\nsnd_pci_quirk_name(quirk));\r\nchip->amp_gpio = quirk->value;\r\n} else if (chip->allegro_flag)\r\nchip->amp_gpio = GPO_EXT_AMP_ALLEGRO;\r\nelse\r\nchip->amp_gpio = GPO_EXT_AMP_M3;\r\n}\r\nquirk = snd_pci_quirk_lookup(pci, m3_irda_quirk_list);\r\nif (quirk) {\r\ndev_info(card->dev, "enabled irda workaround for '%s'\n",\r\nsnd_pci_quirk_name(quirk));\r\nchip->irda_workaround = 1;\r\n}\r\nquirk = snd_pci_quirk_lookup(pci, m3_hv_quirk_list);\r\nif (quirk)\r\nchip->hv_config = quirk->value;\r\nif (snd_pci_quirk_lookup(pci, m3_omnibook_quirk_list))\r\nchip->is_omnibook = 1;\r\nchip->num_substreams = NR_DSPS;\r\nchip->substreams = kcalloc(chip->num_substreams, sizeof(struct m3_dma),\r\nGFP_KERNEL);\r\nif (chip->substreams == NULL) {\r\nkfree(chip);\r\npci_disable_device(pci);\r\nreturn -ENOMEM;\r\n}\r\nerr = request_firmware(&chip->assp_kernel_image,\r\n"ess/maestro3_assp_kernel.fw", &pci->dev);\r\nif (err < 0) {\r\nsnd_m3_free(chip);\r\nreturn err;\r\n}\r\nerr = request_firmware(&chip->assp_minisrc_image,\r\n"ess/maestro3_assp_minisrc.fw", &pci->dev);\r\nif (err < 0) {\r\nsnd_m3_free(chip);\r\nreturn err;\r\n}\r\nif ((err = pci_request_regions(pci, card->driver)) < 0) {\r\nsnd_m3_free(chip);\r\nreturn err;\r\n}\r\nchip->iobase = pci_resource_start(pci, 0);\r\npci_set_master(pci);\r\nsnd_m3_chip_init(chip);\r\nsnd_m3_assp_halt(chip);\r\nsnd_m3_ac97_reset(chip);\r\nsnd_m3_amp_enable(chip, 1);\r\nsnd_m3_hv_init(chip);\r\nif (request_irq(pci->irq, snd_m3_interrupt, IRQF_SHARED,\r\nKBUILD_MODNAME, chip)) {\r\ndev_err(card->dev, "unable to grab IRQ %d\n", pci->irq);\r\nsnd_m3_free(chip);\r\nreturn -ENOMEM;\r\n}\r\nchip->irq = pci->irq;\r\n#ifdef CONFIG_PM_SLEEP\r\nchip->suspend_mem = vmalloc(sizeof(u16) * (REV_B_CODE_MEMORY_LENGTH + REV_B_DATA_MEMORY_LENGTH));\r\nif (chip->suspend_mem == NULL)\r\ndev_warn(card->dev, "can't allocate apm buffer\n");\r\n#endif\r\nif ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0) {\r\nsnd_m3_free(chip);\r\nreturn err;\r\n}\r\nif ((err = snd_m3_mixer(chip)) < 0)\r\nreturn err;\r\nfor (i = 0; i < chip->num_substreams; i++) {\r\nstruct m3_dma *s = &chip->substreams[i];\r\nif ((err = snd_m3_assp_client_init(chip, s, i)) < 0)\r\nreturn err;\r\n}\r\nif ((err = snd_m3_pcm(chip, 0)) < 0)\r\nreturn err;\r\n#ifdef CONFIG_SND_MAESTRO3_INPUT\r\nif (chip->hv_config & HV_CTRL_ENABLE) {\r\nerr = snd_m3_input_register(chip);\r\nif (err)\r\ndev_warn(card->dev,\r\n"Input device registration failed with error %i",\r\nerr);\r\n}\r\n#endif\r\nsnd_m3_enable_ints(chip);\r\nsnd_m3_assp_continue(chip);\r\n*chip_ret = chip;\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_m3_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)\r\n{\r\nstatic int dev;\r\nstruct snd_card *card;\r\nstruct snd_m3 *chip;\r\nint err;\r\nif (((pci->class >> 8) & 0xffff) != PCI_CLASS_MULTIMEDIA_AUDIO)\r\nreturn -ENODEV;\r\nif (dev >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\nif (!enable[dev]) {\r\ndev++;\r\nreturn -ENOENT;\r\n}\r\nerr = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\r\n0, &card);\r\nif (err < 0)\r\nreturn err;\r\nswitch (pci->device) {\r\ncase PCI_DEVICE_ID_ESS_ALLEGRO:\r\ncase PCI_DEVICE_ID_ESS_ALLEGRO_1:\r\nstrcpy(card->driver, "Allegro");\r\nbreak;\r\ncase PCI_DEVICE_ID_ESS_CANYON3D_2LE:\r\ncase PCI_DEVICE_ID_ESS_CANYON3D_2:\r\nstrcpy(card->driver, "Canyon3D-2");\r\nbreak;\r\ndefault:\r\nstrcpy(card->driver, "Maestro3");\r\nbreak;\r\n}\r\nif ((err = snd_m3_create(card, pci,\r\nexternal_amp[dev],\r\namp_gpio[dev],\r\n&chip)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\ncard->private_data = chip;\r\nsprintf(card->shortname, "ESS %s PCI", card->driver);\r\nsprintf(card->longname, "%s at 0x%lx, irq %d",\r\ncard->shortname, chip->iobase, chip->irq);\r\nif ((err = snd_card_register(card)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\n#if 0\r\nerr = snd_mpu401_uart_new(chip->card, 0, MPU401_HW_MPU401,\r\nchip->iobase + MPU401_DATA_PORT,\r\nMPU401_INFO_INTEGRATED | MPU401_INFO_IRQ_HOOK,\r\n-1, &chip->rmidi);\r\nif (err < 0)\r\ndev_warn(card->dev, "no MIDI support.\n");\r\n#endif\r\npci_set_drvdata(pci, card);\r\ndev++;\r\nreturn 0;\r\n}\r\nstatic void snd_m3_remove(struct pci_dev *pci)\r\n{\r\nsnd_card_free(pci_get_drvdata(pci));\r\n}
