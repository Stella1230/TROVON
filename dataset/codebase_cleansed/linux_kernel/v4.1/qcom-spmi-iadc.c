static int iadc_read(struct iadc_chip *iadc, u16 offset, u8 *data)\r\n{\r\nunsigned int val;\r\nint ret;\r\nret = regmap_read(iadc->regmap, iadc->base + offset, &val);\r\nif (ret < 0)\r\nreturn ret;\r\n*data = val;\r\nreturn 0;\r\n}\r\nstatic int iadc_write(struct iadc_chip *iadc, u16 offset, u8 data)\r\n{\r\nreturn regmap_write(iadc->regmap, iadc->base + offset, data);\r\n}\r\nstatic int iadc_reset(struct iadc_chip *iadc)\r\n{\r\nu8 data;\r\nint ret;\r\nret = iadc_write(iadc, IADC_SEC_ACCESS, IADC_SEC_ACCESS_DATA);\r\nif (ret < 0)\r\nreturn ret;\r\nret = iadc_read(iadc, IADC_PERH_RESET_CTL3, &data);\r\nif (ret < 0)\r\nreturn ret;\r\nret = iadc_write(iadc, IADC_SEC_ACCESS, IADC_SEC_ACCESS_DATA);\r\nif (ret < 0)\r\nreturn ret;\r\ndata |= IADC_FOLLOW_WARM_RB;\r\nreturn iadc_write(iadc, IADC_PERH_RESET_CTL3, data);\r\n}\r\nstatic int iadc_set_state(struct iadc_chip *iadc, bool state)\r\n{\r\nreturn iadc_write(iadc, IADC_EN_CTL1, state ? IADC_EN_CTL1_SET : 0);\r\n}\r\nstatic void iadc_status_show(struct iadc_chip *iadc)\r\n{\r\nu8 mode, sta1, chan, dig, en, req;\r\nint ret;\r\nret = iadc_read(iadc, IADC_MODE_CTL, &mode);\r\nif (ret < 0)\r\nreturn;\r\nret = iadc_read(iadc, IADC_DIG_PARAM, &dig);\r\nif (ret < 0)\r\nreturn;\r\nret = iadc_read(iadc, IADC_CH_SEL_CTL, &chan);\r\nif (ret < 0)\r\nreturn;\r\nret = iadc_read(iadc, IADC_CONV_REQ, &req);\r\nif (ret < 0)\r\nreturn;\r\nret = iadc_read(iadc, IADC_STATUS1, &sta1);\r\nif (ret < 0)\r\nreturn;\r\nret = iadc_read(iadc, IADC_EN_CTL1, &en);\r\nif (ret < 0)\r\nreturn;\r\ndev_err(iadc->dev,\r\n"mode:%02x en:%02x chan:%02x dig:%02x req:%02x sta1:%02x\n",\r\nmode, en, chan, dig, req, sta1);\r\n}\r\nstatic int iadc_configure(struct iadc_chip *iadc, int channel)\r\n{\r\nu8 decim, mode;\r\nint ret;\r\nmode = (IADC_OP_MODE_NORMAL << IADC_OP_MODE_SHIFT) | IADC_TRIM_EN;\r\nret = iadc_write(iadc, IADC_MODE_CTL, mode);\r\nif (ret < 0)\r\nreturn ret;\r\nret = iadc_write(iadc, IADC_CH_SEL_CTL, channel);\r\nif (ret < 0)\r\nreturn ret;\r\ndecim = IADC_DEF_DECIMATION << IADC_DIG_DEC_RATIO_SEL_SHIFT;\r\nret = iadc_write(iadc, IADC_DIG_PARAM, decim);\r\nif (ret < 0)\r\nreturn ret;\r\nret = iadc_write(iadc, IADC_HW_SETTLE_DELAY, IADC_DEF_HW_SETTLE_TIME);\r\nif (ret < 0)\r\nreturn ret;\r\nret = iadc_write(iadc, IADC_FAST_AVG_CTL, IADC_DEF_AVG_SAMPLES);\r\nif (ret < 0)\r\nreturn ret;\r\nif (IADC_DEF_AVG_SAMPLES)\r\nret = iadc_write(iadc, IADC_FAST_AVG_EN, IADC_FAST_AVG_EN_SET);\r\nelse\r\nret = iadc_write(iadc, IADC_FAST_AVG_EN, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!iadc->poll_eoc)\r\nreinit_completion(&iadc->complete);\r\nret = iadc_set_state(iadc, true);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn iadc_write(iadc, IADC_CONV_REQ, IADC_CONV_REQ_SET);\r\n}\r\nstatic int iadc_poll_wait_eoc(struct iadc_chip *iadc, unsigned int interval_us)\r\n{\r\nunsigned int count, retry;\r\nint ret;\r\nu8 sta1;\r\nretry = interval_us / IADC_CONV_TIME_MIN_US;\r\nfor (count = 0; count < retry; count++) {\r\nret = iadc_read(iadc, IADC_STATUS1, &sta1);\r\nif (ret < 0)\r\nreturn ret;\r\nsta1 &= IADC_STATUS1_REQ_STS_EOC_MASK;\r\nif (sta1 == IADC_STATUS1_EOC)\r\nreturn 0;\r\nusleep_range(IADC_CONV_TIME_MIN_US, IADC_CONV_TIME_MAX_US);\r\n}\r\niadc_status_show(iadc);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int iadc_read_result(struct iadc_chip *iadc, u16 *data)\r\n{\r\nreturn regmap_bulk_read(iadc->regmap, iadc->base + IADC_DATA, data, 2);\r\n}\r\nstatic int iadc_do_conversion(struct iadc_chip *iadc, int chan, u16 *data)\r\n{\r\nunsigned int wait;\r\nint ret;\r\nret = iadc_configure(iadc, chan);\r\nif (ret < 0)\r\ngoto exit;\r\nwait = BIT(IADC_DEF_AVG_SAMPLES) * IADC_CONV_TIME_MIN_US * 2;\r\nif (iadc->poll_eoc) {\r\nret = iadc_poll_wait_eoc(iadc, wait);\r\n} else {\r\nret = wait_for_completion_timeout(&iadc->complete,\r\nusecs_to_jiffies(wait));\r\nif (!ret)\r\nret = -ETIMEDOUT;\r\nelse\r\nret = iadc_poll_wait_eoc(iadc, IADC_CONV_TIME_MIN_US);\r\n}\r\nif (!ret)\r\nret = iadc_read_result(iadc, data);\r\nexit:\r\niadc_set_state(iadc, false);\r\nif (ret < 0)\r\ndev_err(iadc->dev, "conversion failed\n");\r\nreturn ret;\r\n}\r\nstatic int iadc_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2, long mask)\r\n{\r\nstruct iadc_chip *iadc = iio_priv(indio_dev);\r\ns32 isense_ua, vsense_uv;\r\nu16 adc_raw, vsense_raw;\r\nint ret;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nmutex_lock(&iadc->lock);\r\nret = iadc_do_conversion(iadc, chan->channel, &adc_raw);\r\nmutex_unlock(&iadc->lock);\r\nif (ret < 0)\r\nreturn ret;\r\nvsense_raw = adc_raw - iadc->offset[chan->channel];\r\nvsense_uv = vsense_raw * IADC_REF_GAIN_MICRO_VOLTS;\r\nvsense_uv /= (s32)iadc->gain - iadc->offset[chan->channel];\r\nisense_ua = vsense_uv / iadc->rsense[chan->channel];\r\ndev_dbg(iadc->dev, "off %d gain %d adc %d %duV I %duA\n",\r\niadc->offset[chan->channel], iadc->gain,\r\nadc_raw, vsense_uv, isense_ua);\r\n*val = isense_ua;\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_SCALE:\r\n*val = 0;\r\n*val2 = 1000;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic irqreturn_t iadc_isr(int irq, void *dev_id)\r\n{\r\nstruct iadc_chip *iadc = dev_id;\r\ncomplete(&iadc->complete);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int iadc_update_offset(struct iadc_chip *iadc)\r\n{\r\nint ret;\r\nret = iadc_do_conversion(iadc, IADC_GAIN_17P857MV, &iadc->gain);\r\nif (ret < 0)\r\nreturn ret;\r\nret = iadc_do_conversion(iadc, IADC_INT_OFFSET_CSP2_CSN2,\r\n&iadc->offset[IADC_INT_RSENSE]);\r\nif (ret < 0)\r\nreturn ret;\r\nif (iadc->gain == iadc->offset[IADC_INT_RSENSE]) {\r\ndev_err(iadc->dev, "error: internal offset == gain %d\n",\r\niadc->gain);\r\nreturn -EINVAL;\r\n}\r\nret = iadc_do_conversion(iadc, IADC_EXT_OFFSET_CSP_CSN,\r\n&iadc->offset[IADC_EXT_RSENSE]);\r\nif (ret < 0)\r\nreturn ret;\r\nif (iadc->gain == iadc->offset[IADC_EXT_RSENSE]) {\r\ndev_err(iadc->dev, "error: external offset == gain %d\n",\r\niadc->gain);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int iadc_version_check(struct iadc_chip *iadc)\r\n{\r\nu8 val;\r\nint ret;\r\nret = iadc_read(iadc, IADC_PERPH_TYPE, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nif (val < IADC_PERPH_TYPE_ADC) {\r\ndev_err(iadc->dev, "%d is not ADC\n", val);\r\nreturn -EINVAL;\r\n}\r\nret = iadc_read(iadc, IADC_PERPH_SUBTYPE, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nif (val < IADC_PERPH_SUBTYPE_IADC) {\r\ndev_err(iadc->dev, "%d is not IADC\n", val);\r\nreturn -EINVAL;\r\n}\r\nret = iadc_read(iadc, IADC_REVISION2, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nif (val < IADC_REVISION2_SUPPORTED_IADC) {\r\ndev_err(iadc->dev, "revision %d not supported\n", val);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int iadc_rsense_read(struct iadc_chip *iadc, struct device_node *node)\r\n{\r\nint ret, sign, int_sense;\r\nu8 deviation;\r\nret = of_property_read_u32(node, "qcom,external-resistor-micro-ohms",\r\n&iadc->rsense[IADC_EXT_RSENSE]);\r\nif (ret < 0)\r\niadc->rsense[IADC_EXT_RSENSE] = IADC_INT_RSENSE_IDEAL_VALUE;\r\nif (!iadc->rsense[IADC_EXT_RSENSE]) {\r\ndev_err(iadc->dev, "external resistor can't be zero Ohms");\r\nreturn -EINVAL;\r\n}\r\nret = iadc_read(iadc, IADC_NOMINAL_RSENSE, &deviation);\r\nif (ret < 0)\r\nreturn ret;\r\nsign = (deviation & IADC_NOMINAL_RSENSE_SIGN_MASK) ? -1 : 1;\r\ndeviation &= ~IADC_NOMINAL_RSENSE_SIGN_MASK;\r\nint_sense = IADC_INT_RSENSE_IDEAL_VALUE * 1000;\r\nint_sense += sign * deviation * IADC_INT_RSENSE_DEVIATION;\r\nint_sense /= 1000;\r\niadc->rsense[IADC_INT_RSENSE] = int_sense;\r\nreturn 0;\r\n}\r\nstatic int iadc_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct device *dev = &pdev->dev;\r\nstruct iio_dev *indio_dev;\r\nstruct iadc_chip *iadc;\r\nint ret, irq_eoc;\r\nu32 res;\r\nindio_dev = devm_iio_device_alloc(dev, sizeof(*iadc));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\niadc = iio_priv(indio_dev);\r\niadc->dev = dev;\r\niadc->regmap = dev_get_regmap(dev->parent, NULL);\r\nif (!iadc->regmap)\r\nreturn -ENODEV;\r\ninit_completion(&iadc->complete);\r\nmutex_init(&iadc->lock);\r\nret = of_property_read_u32(node, "reg", &res);\r\nif (ret < 0)\r\nreturn -ENODEV;\r\niadc->base = res;\r\nret = iadc_version_check(iadc);\r\nif (ret < 0)\r\nreturn -ENODEV;\r\nret = iadc_rsense_read(iadc, node);\r\nif (ret < 0)\r\nreturn -ENODEV;\r\ndev_dbg(iadc->dev, "sense resistors %d and %d micro Ohm\n",\r\niadc->rsense[IADC_INT_RSENSE],\r\niadc->rsense[IADC_EXT_RSENSE]);\r\nirq_eoc = platform_get_irq(pdev, 0);\r\nif (irq_eoc == -EPROBE_DEFER)\r\nreturn irq_eoc;\r\nif (irq_eoc < 0)\r\niadc->poll_eoc = true;\r\nret = iadc_reset(iadc);\r\nif (ret < 0) {\r\ndev_err(dev, "reset failed\n");\r\nreturn ret;\r\n}\r\nif (!iadc->poll_eoc) {\r\nret = devm_request_irq(dev, irq_eoc, iadc_isr, 0,\r\n"spmi-iadc", iadc);\r\nif (!ret)\r\nenable_irq_wake(irq_eoc);\r\nelse\r\nreturn ret;\r\n} else {\r\ndevice_init_wakeup(iadc->dev, 1);\r\n}\r\nret = iadc_update_offset(iadc);\r\nif (ret < 0) {\r\ndev_err(dev, "failed offset calibration\n");\r\nreturn ret;\r\n}\r\nindio_dev->dev.parent = dev;\r\nindio_dev->dev.of_node = node;\r\nindio_dev->name = pdev->name;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->info = &iadc_info;\r\nindio_dev->channels = iadc_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(iadc_channels);\r\nreturn devm_iio_device_register(dev, indio_dev);\r\n}
