int snd_midi_event_new(int bufsize, struct snd_midi_event **rdev)\r\n{\r\nstruct snd_midi_event *dev;\r\n*rdev = NULL;\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (dev == NULL)\r\nreturn -ENOMEM;\r\nif (bufsize > 0) {\r\ndev->buf = kmalloc(bufsize, GFP_KERNEL);\r\nif (dev->buf == NULL) {\r\nkfree(dev);\r\nreturn -ENOMEM;\r\n}\r\n}\r\ndev->bufsize = bufsize;\r\ndev->lastcmd = 0xff;\r\ndev->type = ST_INVALID;\r\nspin_lock_init(&dev->lock);\r\n*rdev = dev;\r\nreturn 0;\r\n}\r\nvoid snd_midi_event_free(struct snd_midi_event *dev)\r\n{\r\nif (dev != NULL) {\r\nkfree(dev->buf);\r\nkfree(dev);\r\n}\r\n}\r\nstatic inline void reset_encode(struct snd_midi_event *dev)\r\n{\r\ndev->read = 0;\r\ndev->qlen = 0;\r\ndev->type = ST_INVALID;\r\n}\r\nvoid snd_midi_event_reset_encode(struct snd_midi_event *dev)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->lock, flags);\r\nreset_encode(dev);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\n}\r\nvoid snd_midi_event_reset_decode(struct snd_midi_event *dev)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->lock, flags);\r\ndev->lastcmd = 0xff;\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\n}\r\nvoid snd_midi_event_no_status(struct snd_midi_event *dev, int on)\r\n{\r\ndev->nostat = on ? 1 : 0;\r\n}\r\nlong snd_midi_event_encode(struct snd_midi_event *dev, unsigned char *buf, long count,\r\nstruct snd_seq_event *ev)\r\n{\r\nlong result = 0;\r\nint rc;\r\nev->type = SNDRV_SEQ_EVENT_NONE;\r\nwhile (count-- > 0) {\r\nrc = snd_midi_event_encode_byte(dev, *buf++, ev);\r\nresult++;\r\nif (rc < 0)\r\nreturn rc;\r\nelse if (rc > 0)\r\nreturn result;\r\n}\r\nreturn result;\r\n}\r\nint snd_midi_event_encode_byte(struct snd_midi_event *dev, int c,\r\nstruct snd_seq_event *ev)\r\n{\r\nint rc = 0;\r\nunsigned long flags;\r\nc &= 0xff;\r\nif (c >= MIDI_CMD_COMMON_CLOCK) {\r\nev->type = status_event[ST_SPECIAL + c - 0xf0].event;\r\nev->flags &= ~SNDRV_SEQ_EVENT_LENGTH_MASK;\r\nev->flags |= SNDRV_SEQ_EVENT_LENGTH_FIXED;\r\nreturn ev->type != SNDRV_SEQ_EVENT_NONE;\r\n}\r\nspin_lock_irqsave(&dev->lock, flags);\r\nif ((c & 0x80) &&\r\n(c != MIDI_CMD_COMMON_SYSEX_END || dev->type != ST_SYSEX)) {\r\ndev->buf[0] = c;\r\nif ((c & 0xf0) == 0xf0)\r\ndev->type = (c & 0x0f) + ST_SPECIAL;\r\nelse\r\ndev->type = (c >> 4) & 0x07;\r\ndev->read = 1;\r\ndev->qlen = status_event[dev->type].qlen;\r\n} else {\r\nif (dev->qlen > 0) {\r\ndev->buf[dev->read++] = c;\r\nif (dev->type != ST_SYSEX)\r\ndev->qlen--;\r\n} else {\r\ndev->buf[1] = c;\r\ndev->qlen = status_event[dev->type].qlen - 1;\r\ndev->read = 2;\r\n}\r\n}\r\nif (dev->qlen == 0) {\r\nev->type = status_event[dev->type].event;\r\nev->flags &= ~SNDRV_SEQ_EVENT_LENGTH_MASK;\r\nev->flags |= SNDRV_SEQ_EVENT_LENGTH_FIXED;\r\nif (status_event[dev->type].encode)\r\nstatus_event[dev->type].encode(dev, ev);\r\nif (dev->type >= ST_SPECIAL)\r\ndev->type = ST_INVALID;\r\nrc = 1;\r\n} else if (dev->type == ST_SYSEX) {\r\nif (c == MIDI_CMD_COMMON_SYSEX_END ||\r\ndev->read >= dev->bufsize) {\r\nev->flags &= ~SNDRV_SEQ_EVENT_LENGTH_MASK;\r\nev->flags |= SNDRV_SEQ_EVENT_LENGTH_VARIABLE;\r\nev->type = SNDRV_SEQ_EVENT_SYSEX;\r\nev->data.ext.len = dev->read;\r\nev->data.ext.ptr = dev->buf;\r\nif (c != MIDI_CMD_COMMON_SYSEX_END)\r\ndev->read = 0;\r\nelse\r\nreset_encode(dev);\r\nrc = 1;\r\n}\r\n}\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn rc;\r\n}\r\nstatic void note_event(struct snd_midi_event *dev, struct snd_seq_event *ev)\r\n{\r\nev->data.note.channel = dev->buf[0] & 0x0f;\r\nev->data.note.note = dev->buf[1];\r\nev->data.note.velocity = dev->buf[2];\r\n}\r\nstatic void one_param_ctrl_event(struct snd_midi_event *dev, struct snd_seq_event *ev)\r\n{\r\nev->data.control.channel = dev->buf[0] & 0x0f;\r\nev->data.control.value = dev->buf[1];\r\n}\r\nstatic void pitchbend_ctrl_event(struct snd_midi_event *dev, struct snd_seq_event *ev)\r\n{\r\nev->data.control.channel = dev->buf[0] & 0x0f;\r\nev->data.control.value = (int)dev->buf[2] * 128 + (int)dev->buf[1] - 8192;\r\n}\r\nstatic void two_param_ctrl_event(struct snd_midi_event *dev, struct snd_seq_event *ev)\r\n{\r\nev->data.control.channel = dev->buf[0] & 0x0f;\r\nev->data.control.param = dev->buf[1];\r\nev->data.control.value = dev->buf[2];\r\n}\r\nstatic void one_param_event(struct snd_midi_event *dev, struct snd_seq_event *ev)\r\n{\r\nev->data.control.value = dev->buf[1];\r\n}\r\nstatic void songpos_event(struct snd_midi_event *dev, struct snd_seq_event *ev)\r\n{\r\nev->data.control.value = (int)dev->buf[2] * 128 + (int)dev->buf[1];\r\n}\r\nlong snd_midi_event_decode(struct snd_midi_event *dev, unsigned char *buf, long count,\r\nstruct snd_seq_event *ev)\r\n{\r\nunsigned int cmd, type;\r\nif (ev->type == SNDRV_SEQ_EVENT_NONE)\r\nreturn -ENOENT;\r\nfor (type = 0; type < ARRAY_SIZE(status_event); type++) {\r\nif (ev->type == status_event[type].event)\r\ngoto __found;\r\n}\r\nfor (type = 0; type < ARRAY_SIZE(extra_event); type++) {\r\nif (ev->type == extra_event[type].event)\r\nreturn extra_event[type].decode(dev, buf, count, ev);\r\n}\r\nreturn -ENOENT;\r\n__found:\r\nif (type >= ST_SPECIAL)\r\ncmd = 0xf0 + (type - ST_SPECIAL);\r\nelse\r\ncmd = 0x80 | (type << 4) | (ev->data.note.channel & 0x0f);\r\nif (cmd == MIDI_CMD_COMMON_SYSEX) {\r\nsnd_midi_event_reset_decode(dev);\r\nreturn snd_seq_expand_var_event(ev, count, buf, 1, 0);\r\n} else {\r\nint qlen;\r\nunsigned char xbuf[4];\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->lock, flags);\r\nif ((cmd & 0xf0) == 0xf0 || dev->lastcmd != cmd || dev->nostat) {\r\ndev->lastcmd = cmd;\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nxbuf[0] = cmd;\r\nif (status_event[type].decode)\r\nstatus_event[type].decode(ev, xbuf + 1);\r\nqlen = status_event[type].qlen + 1;\r\n} else {\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nif (status_event[type].decode)\r\nstatus_event[type].decode(ev, xbuf + 0);\r\nqlen = status_event[type].qlen;\r\n}\r\nif (count < qlen)\r\nreturn -ENOMEM;\r\nmemcpy(buf, xbuf, qlen);\r\nreturn qlen;\r\n}\r\n}\r\nstatic void note_decode(struct snd_seq_event *ev, unsigned char *buf)\r\n{\r\nbuf[0] = ev->data.note.note & 0x7f;\r\nbuf[1] = ev->data.note.velocity & 0x7f;\r\n}\r\nstatic void one_param_decode(struct snd_seq_event *ev, unsigned char *buf)\r\n{\r\nbuf[0] = ev->data.control.value & 0x7f;\r\n}\r\nstatic void pitchbend_decode(struct snd_seq_event *ev, unsigned char *buf)\r\n{\r\nint value = ev->data.control.value + 8192;\r\nbuf[0] = value & 0x7f;\r\nbuf[1] = (value >> 7) & 0x7f;\r\n}\r\nstatic void two_param_decode(struct snd_seq_event *ev, unsigned char *buf)\r\n{\r\nbuf[0] = ev->data.control.param & 0x7f;\r\nbuf[1] = ev->data.control.value & 0x7f;\r\n}\r\nstatic void songpos_decode(struct snd_seq_event *ev, unsigned char *buf)\r\n{\r\nbuf[0] = ev->data.control.value & 0x7f;\r\nbuf[1] = (ev->data.control.value >> 7) & 0x7f;\r\n}\r\nstatic int extra_decode_ctrl14(struct snd_midi_event *dev, unsigned char *buf,\r\nint count, struct snd_seq_event *ev)\r\n{\r\nunsigned char cmd;\r\nint idx = 0;\r\ncmd = MIDI_CMD_CONTROL|(ev->data.control.channel & 0x0f);\r\nif (ev->data.control.param < 0x20) {\r\nif (count < 4)\r\nreturn -ENOMEM;\r\nif (dev->nostat && count < 6)\r\nreturn -ENOMEM;\r\nif (cmd != dev->lastcmd || dev->nostat) {\r\nif (count < 5)\r\nreturn -ENOMEM;\r\nbuf[idx++] = dev->lastcmd = cmd;\r\n}\r\nbuf[idx++] = ev->data.control.param;\r\nbuf[idx++] = (ev->data.control.value >> 7) & 0x7f;\r\nif (dev->nostat)\r\nbuf[idx++] = cmd;\r\nbuf[idx++] = ev->data.control.param + 0x20;\r\nbuf[idx++] = ev->data.control.value & 0x7f;\r\n} else {\r\nif (count < 2)\r\nreturn -ENOMEM;\r\nif (cmd != dev->lastcmd || dev->nostat) {\r\nif (count < 3)\r\nreturn -ENOMEM;\r\nbuf[idx++] = dev->lastcmd = cmd;\r\n}\r\nbuf[idx++] = ev->data.control.param & 0x7f;\r\nbuf[idx++] = ev->data.control.value & 0x7f;\r\n}\r\nreturn idx;\r\n}\r\nstatic int extra_decode_xrpn(struct snd_midi_event *dev, unsigned char *buf,\r\nint count, struct snd_seq_event *ev)\r\n{\r\nunsigned char cmd;\r\nchar *cbytes;\r\nstatic char cbytes_nrpn[4] = { MIDI_CTL_NONREG_PARM_NUM_MSB,\r\nMIDI_CTL_NONREG_PARM_NUM_LSB,\r\nMIDI_CTL_MSB_DATA_ENTRY,\r\nMIDI_CTL_LSB_DATA_ENTRY };\r\nstatic char cbytes_rpn[4] = { MIDI_CTL_REGIST_PARM_NUM_MSB,\r\nMIDI_CTL_REGIST_PARM_NUM_LSB,\r\nMIDI_CTL_MSB_DATA_ENTRY,\r\nMIDI_CTL_LSB_DATA_ENTRY };\r\nunsigned char bytes[4];\r\nint idx = 0, i;\r\nif (count < 8)\r\nreturn -ENOMEM;\r\nif (dev->nostat && count < 12)\r\nreturn -ENOMEM;\r\ncmd = MIDI_CMD_CONTROL|(ev->data.control.channel & 0x0f);\r\nbytes[0] = (ev->data.control.param & 0x3f80) >> 7;\r\nbytes[1] = ev->data.control.param & 0x007f;\r\nbytes[2] = (ev->data.control.value & 0x3f80) >> 7;\r\nbytes[3] = ev->data.control.value & 0x007f;\r\nif (cmd != dev->lastcmd && !dev->nostat) {\r\nif (count < 9)\r\nreturn -ENOMEM;\r\nbuf[idx++] = dev->lastcmd = cmd;\r\n}\r\ncbytes = ev->type == SNDRV_SEQ_EVENT_NONREGPARAM ? cbytes_nrpn : cbytes_rpn;\r\nfor (i = 0; i < 4; i++) {\r\nif (dev->nostat)\r\nbuf[idx++] = dev->lastcmd = cmd;\r\nbuf[idx++] = cbytes[i];\r\nbuf[idx++] = bytes[i];\r\n}\r\nreturn idx;\r\n}\r\nstatic int __init alsa_seq_midi_event_init(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __exit alsa_seq_midi_event_exit(void)\r\n{\r\n}
