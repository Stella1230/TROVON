static enum mac8390_type __init mac8390_ident(struct nubus_dev *dev)\r\n{\r\nswitch (dev->dr_sw) {\r\ncase NUBUS_DRSW_3COM:\r\nswitch (dev->dr_hw) {\r\ncase NUBUS_DRHW_APPLE_SONIC_NB:\r\ncase NUBUS_DRHW_APPLE_SONIC_LC:\r\ncase NUBUS_DRHW_SONNET:\r\nreturn MAC8390_NONE;\r\ndefault:\r\nreturn MAC8390_APPLE;\r\n}\r\nbreak;\r\ncase NUBUS_DRSW_APPLE:\r\nswitch (dev->dr_hw) {\r\ncase NUBUS_DRHW_ASANTE_LC:\r\nreturn MAC8390_NONE;\r\ncase NUBUS_DRHW_CABLETRON:\r\nreturn MAC8390_CABLETRON;\r\ndefault:\r\nreturn MAC8390_APPLE;\r\n}\r\nbreak;\r\ncase NUBUS_DRSW_ASANTE:\r\nreturn MAC8390_ASANTE;\r\nbreak;\r\ncase NUBUS_DRSW_TECHWORKS:\r\ncase NUBUS_DRSW_DAYNA2:\r\ncase NUBUS_DRSW_DAYNA_LC:\r\nif (dev->dr_hw == NUBUS_DRHW_CABLETRON)\r\nreturn MAC8390_CABLETRON;\r\nelse\r\nreturn MAC8390_APPLE;\r\nbreak;\r\ncase NUBUS_DRSW_FARALLON:\r\nreturn MAC8390_FARALLON;\r\nbreak;\r\ncase NUBUS_DRSW_KINETICS:\r\nswitch (dev->dr_hw) {\r\ncase NUBUS_DRHW_INTERLAN:\r\nreturn MAC8390_INTERLAN;\r\ndefault:\r\nreturn MAC8390_KINETICS;\r\n}\r\nbreak;\r\ncase NUBUS_DRSW_DAYNA:\r\nif (dev->dr_hw == NUBUS_DRHW_SMC9194 ||\r\ndev->dr_hw == NUBUS_DRHW_INTERLAN)\r\nreturn MAC8390_NONE;\r\nelse\r\nreturn MAC8390_DAYNA;\r\nbreak;\r\n}\r\nreturn MAC8390_NONE;\r\n}\r\nstatic enum mac8390_access __init mac8390_testio(volatile unsigned long membase)\r\n{\r\nunsigned long outdata = 0xA5A0B5B0;\r\nunsigned long indata = 0x00000000;\r\nmemcpy_toio(membase, &outdata, 4);\r\nif (memcmp_withio(&outdata, membase, 4) == 0)\r\nreturn ACCESS_32;\r\nword_memcpy_tocard(membase, &outdata, 4);\r\nword_memcpy_fromcard(&indata, membase, 4);\r\nif (outdata == indata)\r\nreturn ACCESS_16;\r\nreturn ACCESS_UNKNOWN;\r\n}\r\nstatic int __init mac8390_memsize(unsigned long membase)\r\n{\r\nunsigned long flags;\r\nint i, j;\r\nlocal_irq_save(flags);\r\nfor (i = 0; i < 8; i++) {\r\nvolatile unsigned short *m = (unsigned short *)(membase + (i * 0x1000));\r\nif (hwreg_present(m) == 0)\r\nbreak;\r\n*m = 0xA5A0 | i;\r\nif (*m != (0xA5A0 | i))\r\nbreak;\r\nfor (j = 0; j < i; j++) {\r\nvolatile unsigned short *p = (unsigned short *)(membase + (j * 0x1000));\r\nif (*p != (0xA5A0 | j))\r\nbreak;\r\n}\r\n}\r\nlocal_irq_restore(flags);\r\nreturn i * 0x1000;\r\n}\r\nstatic bool __init mac8390_init(struct net_device *dev, struct nubus_dev *ndev,\r\nenum mac8390_type cardtype)\r\n{\r\nstruct nubus_dir dir;\r\nstruct nubus_dirent ent;\r\nint offset;\r\nvolatile unsigned short *i;\r\nprintk_once(KERN_INFO pr_fmt("%s"), version);\r\ndev->irq = SLOT2IRQ(ndev->board->slot);\r\ndev->base_addr = (ndev->board->slot_addr |\r\n((ndev->board->slot & 0xf) << 20));\r\nif (nubus_get_func_dir(ndev, &dir) == -1) {\r\npr_err("%s: Unable to get Nubus functional directory for slot %X!\n",\r\ndev->name, ndev->board->slot);\r\nreturn false;\r\n}\r\nif (nubus_find_rsrc(&dir, NUBUS_RESID_MAC_ADDRESS, &ent) == -1) {\r\npr_info("%s: Couldn't get MAC address!\n", dev->name);\r\nreturn false;\r\n}\r\nnubus_get_rsrc_mem(dev->dev_addr, &ent, 6);\r\nif (useresources[cardtype] == 1) {\r\nnubus_rewinddir(&dir);\r\nif (nubus_find_rsrc(&dir, NUBUS_RESID_MINOR_BASEOS,\r\n&ent) == -1) {\r\npr_err("%s: Memory offset resource for slot %X not found!\n",\r\ndev->name, ndev->board->slot);\r\nreturn false;\r\n}\r\nnubus_get_rsrc_mem(&offset, &ent, 4);\r\ndev->mem_start = dev->base_addr + offset;\r\ndev->base_addr = dev->mem_start + 0x10000;\r\nnubus_rewinddir(&dir);\r\nif (nubus_find_rsrc(&dir, NUBUS_RESID_MINOR_LENGTH,\r\n&ent) == -1) {\r\npr_info("%s: Memory length resource for slot %X not found, probing\n",\r\ndev->name, ndev->board->slot);\r\noffset = mac8390_memsize(dev->mem_start);\r\n} else {\r\nnubus_get_rsrc_mem(&offset, &ent, 4);\r\n}\r\ndev->mem_end = dev->mem_start + offset;\r\n} else {\r\nswitch (cardtype) {\r\ncase MAC8390_KINETICS:\r\ncase MAC8390_DAYNA:\r\ndev->base_addr = (int)(ndev->board->slot_addr +\r\nDAYNA_8390_BASE);\r\ndev->mem_start = (int)(ndev->board->slot_addr +\r\nDAYNA_8390_MEM);\r\ndev->mem_end = dev->mem_start +\r\nmac8390_memsize(dev->mem_start);\r\nbreak;\r\ncase MAC8390_INTERLAN:\r\ndev->base_addr = (int)(ndev->board->slot_addr +\r\nINTERLAN_8390_BASE);\r\ndev->mem_start = (int)(ndev->board->slot_addr +\r\nINTERLAN_8390_MEM);\r\ndev->mem_end = dev->mem_start +\r\nmac8390_memsize(dev->mem_start);\r\nbreak;\r\ncase MAC8390_CABLETRON:\r\ndev->base_addr = (int)(ndev->board->slot_addr +\r\nCABLETRON_8390_BASE);\r\ndev->mem_start = (int)(ndev->board->slot_addr +\r\nCABLETRON_8390_MEM);\r\ni = (void *)dev->base_addr;\r\n*i = 0x21;\r\ndev->mem_end = dev->mem_start +\r\nmac8390_memsize(dev->mem_start);\r\nbreak;\r\ndefault:\r\npr_err("Card type %s is unsupported, sorry\n",\r\nndev->board->name);\r\nreturn false;\r\n}\r\n}\r\nreturn true;\r\n}\r\nstruct net_device * __init mac8390_probe(int unit)\r\n{\r\nstruct net_device *dev;\r\nstruct nubus_dev *ndev = NULL;\r\nint err = -ENODEV;\r\nstruct ei_device *ei_local;\r\nstatic unsigned int slots;\r\nenum mac8390_type cardtype;\r\nif (!MACH_IS_MAC)\r\nreturn ERR_PTR(-ENODEV);\r\ndev = ____alloc_ei_netdev(0);\r\nif (!dev)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (unit >= 0)\r\nsprintf(dev->name, "eth%d", unit);\r\nwhile ((ndev = nubus_find_type(NUBUS_CAT_NETWORK, NUBUS_TYPE_ETHERNET,\r\nndev))) {\r\nif (slots & (1 << ndev->board->slot))\r\ncontinue;\r\nslots |= 1 << ndev->board->slot;\r\ncardtype = mac8390_ident(ndev);\r\nif (cardtype == MAC8390_NONE)\r\ncontinue;\r\nif (!mac8390_init(dev, ndev, cardtype))\r\ncontinue;\r\nif (!mac8390_initdev(dev, ndev, cardtype))\r\nbreak;\r\n}\r\nif (!ndev)\r\ngoto out;\r\nei_local = netdev_priv(dev);\r\nei_local->msg_enable = mac8390_msg_enable;\r\nerr = register_netdev(dev);\r\nif (err)\r\ngoto out;\r\nreturn dev;\r\nout:\r\nfree_netdev(dev);\r\nreturn ERR_PTR(err);\r\n}\r\nint init_module(void)\r\n{\r\nint i;\r\nfor (i = 0; i < 15; i++) {\r\nstruct net_device *dev = mac8390_probe(-1);\r\nif (IS_ERR(dev))\r\nbreak;\r\ndev_mac890[i] = dev;\r\n}\r\nif (!i) {\r\npr_notice("No useable cards found, driver NOT installed.\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nvoid cleanup_module(void)\r\n{\r\nint i;\r\nfor (i = 0; i < 15; i++) {\r\nstruct net_device *dev = dev_mac890[i];\r\nif (dev) {\r\nunregister_netdev(dev);\r\nfree_netdev(dev);\r\n}\r\n}\r\n}\r\nstatic int __init mac8390_initdev(struct net_device *dev,\r\nstruct nubus_dev *ndev,\r\nenum mac8390_type type)\r\n{\r\nstatic u32 fwrd4_offsets[16] = {\r\n0, 4, 8, 12,\r\n16, 20, 24, 28,\r\n32, 36, 40, 44,\r\n48, 52, 56, 60\r\n};\r\nstatic u32 back4_offsets[16] = {\r\n60, 56, 52, 48,\r\n44, 40, 36, 32,\r\n28, 24, 20, 16,\r\n12, 8, 4, 0\r\n};\r\nstatic u32 fwrd2_offsets[16] = {\r\n0, 2, 4, 6,\r\n8, 10, 12, 14,\r\n16, 18, 20, 22,\r\n24, 26, 28, 30\r\n};\r\nint access_bitmode = 0;\r\ndev->netdev_ops = &mac8390_netdev_ops;\r\nei_status.name = cardname[type];\r\nei_status.word16 = word16[type];\r\nif (type == MAC8390_CABLETRON) {\r\nei_status.tx_start_page = CABLETRON_TX_START_PG;\r\nei_status.rx_start_page = CABLETRON_RX_START_PG;\r\nei_status.stop_page = CABLETRON_RX_STOP_PG;\r\nei_status.rmem_start = dev->mem_start;\r\nei_status.rmem_end = dev->mem_start + CABLETRON_RX_STOP_PG*256;\r\n} else {\r\nei_status.tx_start_page = WD_START_PG;\r\nei_status.rx_start_page = WD_START_PG + TX_PAGES;\r\nei_status.stop_page = (dev->mem_end - dev->mem_start)/256;\r\nei_status.rmem_start = dev->mem_start + TX_PAGES*256;\r\nei_status.rmem_end = dev->mem_end;\r\n}\r\nswitch (type) {\r\ncase MAC8390_FARALLON:\r\ncase MAC8390_APPLE:\r\nswitch (mac8390_testio(dev->mem_start)) {\r\ncase ACCESS_UNKNOWN:\r\npr_err("Don't know how to access card memory!\n");\r\nreturn -ENODEV;\r\ncase ACCESS_16:\r\nei_status.reset_8390 = mac8390_no_reset;\r\nei_status.block_input = slow_sane_block_input;\r\nei_status.block_output = slow_sane_block_output;\r\nei_status.get_8390_hdr = slow_sane_get_8390_hdr;\r\nei_status.reg_offset = back4_offsets;\r\nbreak;\r\ncase ACCESS_32:\r\nei_status.reset_8390 = mac8390_no_reset;\r\nei_status.block_input = sane_block_input;\r\nei_status.block_output = sane_block_output;\r\nei_status.get_8390_hdr = sane_get_8390_hdr;\r\nei_status.reg_offset = back4_offsets;\r\naccess_bitmode = 1;\r\nbreak;\r\n}\r\nbreak;\r\ncase MAC8390_ASANTE:\r\nei_status.reset_8390 = mac8390_no_reset;\r\nei_status.block_input = slow_sane_block_input;\r\nei_status.block_output = slow_sane_block_output;\r\nei_status.get_8390_hdr = slow_sane_get_8390_hdr;\r\nei_status.reg_offset = back4_offsets;\r\nbreak;\r\ncase MAC8390_CABLETRON:\r\nei_status.reset_8390 = mac8390_no_reset;\r\nei_status.block_input = slow_sane_block_input;\r\nei_status.block_output = slow_sane_block_output;\r\nei_status.get_8390_hdr = slow_sane_get_8390_hdr;\r\nei_status.reg_offset = fwrd2_offsets;\r\nbreak;\r\ncase MAC8390_DAYNA:\r\ncase MAC8390_KINETICS:\r\nei_status.reset_8390 = mac8390_no_reset;\r\nei_status.block_input = dayna_block_input;\r\nei_status.block_output = dayna_block_output;\r\nei_status.get_8390_hdr = dayna_get_8390_hdr;\r\nei_status.reg_offset = fwrd4_offsets;\r\nbreak;\r\ncase MAC8390_INTERLAN:\r\nei_status.reset_8390 = interlan_reset;\r\nei_status.block_input = slow_sane_block_input;\r\nei_status.block_output = slow_sane_block_output;\r\nei_status.get_8390_hdr = slow_sane_get_8390_hdr;\r\nei_status.reg_offset = fwrd4_offsets;\r\nbreak;\r\ndefault:\r\npr_err("Card type %s is unsupported, sorry\n",\r\nndev->board->name);\r\nreturn -ENODEV;\r\n}\r\n__NS8390_init(dev, 0);\r\npr_info("%s: %s in slot %X (type %s)\n",\r\ndev->name, ndev->board->name, ndev->board->slot,\r\ncardname[type]);\r\npr_info("MAC %pM IRQ %d, %d KB shared memory at %#lx, %d-bit access.\n",\r\ndev->dev_addr, dev->irq,\r\n(unsigned int)(dev->mem_end - dev->mem_start) >> 10,\r\ndev->mem_start, access_bitmode ? 32 : 16);\r\nreturn 0;\r\n}\r\nstatic int mac8390_open(struct net_device *dev)\r\n{\r\nint err;\r\n__ei_open(dev);\r\nerr = request_irq(dev->irq, __ei_interrupt, 0, "8390 Ethernet", dev);\r\nif (err)\r\npr_err("%s: unable to get IRQ %d\n", dev->name, dev->irq);\r\nreturn err;\r\n}\r\nstatic int mac8390_close(struct net_device *dev)\r\n{\r\nfree_irq(dev->irq, dev);\r\n__ei_close(dev);\r\nreturn 0;\r\n}\r\nstatic void mac8390_no_reset(struct net_device *dev)\r\n{\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nei_status.txing = 0;\r\nnetif_info(ei_local, hw, dev, "reset not supported\n");\r\n}\r\nstatic void interlan_reset(struct net_device *dev)\r\n{\r\nunsigned char *target = nubus_slot_addr(IRQ2SLOT(dev->irq));\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nnetif_info(ei_local, hw, dev, "Need to reset the NS8390 t=%lu...",\r\njiffies);\r\nei_status.txing = 0;\r\ntarget[0xC0000] = 0;\r\nif (netif_msg_hw(ei_local))\r\npr_cont("reset complete\n");\r\n}\r\nstatic void dayna_memcpy_fromcard(struct net_device *dev, void *to, int from,\r\nint count)\r\n{\r\nvolatile unsigned char *ptr;\r\nunsigned char *target = to;\r\nfrom <<= 1;\r\nptr = (unsigned char *)(dev->mem_start+from);\r\nif (from & 2) {\r\n*target++ = ptr[-1];\r\nptr += 2;\r\ncount--;\r\n}\r\nwhile (count >= 2) {\r\n*(unsigned short *)target = *(unsigned short volatile *)ptr;\r\nptr += 4;\r\ntarget += 2;\r\ncount -= 2;\r\n}\r\nif (count)\r\n*target = *ptr;\r\n}\r\nstatic void dayna_memcpy_tocard(struct net_device *dev, int to,\r\nconst void *from, int count)\r\n{\r\nvolatile unsigned short *ptr;\r\nconst unsigned char *src = from;\r\nto <<= 1;\r\nptr = (unsigned short *)(dev->mem_start+to);\r\nif (to & 2) {\r\nptr[-1] = (ptr[-1]&0xFF00)|*src++;\r\nptr++;\r\ncount--;\r\n}\r\nwhile (count >= 2) {\r\n*ptr++ = *(unsigned short *)src;\r\nptr++;\r\nsrc += 2;\r\ncount -= 2;\r\n}\r\nif (count) {\r\n*ptr = (*ptr & 0x00FF) | (*src << 8);\r\n}\r\n}\r\nstatic void sane_get_8390_hdr(struct net_device *dev,\r\nstruct e8390_pkt_hdr *hdr, int ring_page)\r\n{\r\nunsigned long hdr_start = (ring_page - WD_START_PG)<<8;\r\nmemcpy_fromio(hdr, dev->mem_start + hdr_start, 4);\r\nhdr->count = swab16(hdr->count);\r\n}\r\nstatic void sane_block_input(struct net_device *dev, int count,\r\nstruct sk_buff *skb, int ring_offset)\r\n{\r\nunsigned long xfer_base = ring_offset - (WD_START_PG<<8);\r\nunsigned long xfer_start = xfer_base + dev->mem_start;\r\nif (xfer_start + count > ei_status.rmem_end) {\r\nint semi_count = ei_status.rmem_end - xfer_start;\r\nmemcpy_fromio(skb->data, dev->mem_start + xfer_base,\r\nsemi_count);\r\ncount -= semi_count;\r\nmemcpy_fromio(skb->data + semi_count, ei_status.rmem_start,\r\ncount);\r\n} else {\r\nmemcpy_fromio(skb->data, dev->mem_start + xfer_base, count);\r\n}\r\n}\r\nstatic void sane_block_output(struct net_device *dev, int count,\r\nconst unsigned char *buf, int start_page)\r\n{\r\nlong shmem = (start_page - WD_START_PG)<<8;\r\nmemcpy_toio(dev->mem_start + shmem, buf, count);\r\n}\r\nstatic void dayna_get_8390_hdr(struct net_device *dev,\r\nstruct e8390_pkt_hdr *hdr, int ring_page)\r\n{\r\nunsigned long hdr_start = (ring_page - WD_START_PG)<<8;\r\ndayna_memcpy_fromcard(dev, hdr, hdr_start, 4);\r\nhdr->count = (hdr->count & 0xFF) << 8 | (hdr->count >> 8);\r\n}\r\nstatic void dayna_block_input(struct net_device *dev, int count,\r\nstruct sk_buff *skb, int ring_offset)\r\n{\r\nunsigned long xfer_base = ring_offset - (WD_START_PG<<8);\r\nunsigned long xfer_start = xfer_base+dev->mem_start;\r\nif (xfer_start + count > ei_status.rmem_end) {\r\nint semi_count = ei_status.rmem_end - xfer_start;\r\ndayna_memcpy_fromcard(dev, skb->data, xfer_base, semi_count);\r\ncount -= semi_count;\r\ndayna_memcpy_fromcard(dev, skb->data + semi_count,\r\nei_status.rmem_start - dev->mem_start,\r\ncount);\r\n} else {\r\ndayna_memcpy_fromcard(dev, skb->data, xfer_base, count);\r\n}\r\n}\r\nstatic void dayna_block_output(struct net_device *dev, int count,\r\nconst unsigned char *buf,\r\nint start_page)\r\n{\r\nlong shmem = (start_page - WD_START_PG)<<8;\r\ndayna_memcpy_tocard(dev, shmem, buf, count);\r\n}\r\nstatic void slow_sane_get_8390_hdr(struct net_device *dev,\r\nstruct e8390_pkt_hdr *hdr,\r\nint ring_page)\r\n{\r\nunsigned long hdr_start = (ring_page - WD_START_PG)<<8;\r\nword_memcpy_fromcard(hdr, dev->mem_start + hdr_start, 4);\r\nhdr->count = (hdr->count&0xFF)<<8|(hdr->count>>8);\r\n}\r\nstatic void slow_sane_block_input(struct net_device *dev, int count,\r\nstruct sk_buff *skb, int ring_offset)\r\n{\r\nunsigned long xfer_base = ring_offset - (WD_START_PG<<8);\r\nunsigned long xfer_start = xfer_base+dev->mem_start;\r\nif (xfer_start + count > ei_status.rmem_end) {\r\nint semi_count = ei_status.rmem_end - xfer_start;\r\nword_memcpy_fromcard(skb->data, dev->mem_start + xfer_base,\r\nsemi_count);\r\ncount -= semi_count;\r\nword_memcpy_fromcard(skb->data + semi_count,\r\nei_status.rmem_start, count);\r\n} else {\r\nword_memcpy_fromcard(skb->data, dev->mem_start + xfer_base,\r\ncount);\r\n}\r\n}\r\nstatic void slow_sane_block_output(struct net_device *dev, int count,\r\nconst unsigned char *buf, int start_page)\r\n{\r\nlong shmem = (start_page - WD_START_PG)<<8;\r\nword_memcpy_tocard(dev->mem_start + shmem, buf, count);\r\n}\r\nstatic void word_memcpy_tocard(unsigned long tp, const void *fp, int count)\r\n{\r\nvolatile unsigned short *to = (void *)tp;\r\nconst unsigned short *from = fp;\r\ncount++;\r\ncount /= 2;\r\nwhile (count--)\r\n*to++ = *from++;\r\n}\r\nstatic void word_memcpy_fromcard(void *tp, unsigned long fp, int count)\r\n{\r\nunsigned short *to = tp;\r\nconst volatile unsigned short *from = (const void *)fp;\r\ncount++;\r\ncount /= 2;\r\nwhile (count--)\r\n*to++ = *from++;\r\n}
