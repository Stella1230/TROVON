static unsigned int\r\nget_formation_index(unsigned int rate)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(snd_bebob_rate_table); i++) {\r\nif (snd_bebob_rate_table[i] == rate)\r\nreturn i;\r\n}\r\nreturn -EINVAL;\r\n}\r\nint\r\nsnd_bebob_stream_get_rate(struct snd_bebob *bebob, unsigned int *curr_rate)\r\n{\r\nunsigned int tx_rate, rx_rate, trials;\r\nint err;\r\ntrials = 0;\r\ndo {\r\nerr = avc_general_get_sig_fmt(bebob->unit, &tx_rate,\r\nAVC_GENERAL_PLUG_DIR_OUT, 0);\r\n} while (err == -EAGAIN && ++trials < 3);\r\nif (err < 0)\r\ngoto end;\r\ntrials = 0;\r\ndo {\r\nerr = avc_general_get_sig_fmt(bebob->unit, &rx_rate,\r\nAVC_GENERAL_PLUG_DIR_IN, 0);\r\n} while (err == -EAGAIN && ++trials < 3);\r\nif (err < 0)\r\ngoto end;\r\n*curr_rate = rx_rate;\r\nif (rx_rate == tx_rate)\r\ngoto end;\r\nerr = avc_general_set_sig_fmt(bebob->unit, rx_rate,\r\nAVC_GENERAL_PLUG_DIR_IN, 0);\r\nend:\r\nreturn err;\r\n}\r\nint\r\nsnd_bebob_stream_set_rate(struct snd_bebob *bebob, unsigned int rate)\r\n{\r\nint err;\r\nerr = avc_general_set_sig_fmt(bebob->unit, rate,\r\nAVC_GENERAL_PLUG_DIR_OUT, 0);\r\nif (err < 0)\r\ngoto end;\r\nerr = avc_general_set_sig_fmt(bebob->unit, rate,\r\nAVC_GENERAL_PLUG_DIR_IN, 0);\r\nif (err < 0)\r\ngoto end;\r\nmsleep(300);\r\nend:\r\nreturn err;\r\n}\r\nint\r\nsnd_bebob_stream_check_internal_clock(struct snd_bebob *bebob, bool *internal)\r\n{\r\nstruct snd_bebob_clock_spec *clk_spec = bebob->spec->clock;\r\nu8 addr[AVC_BRIDGECO_ADDR_BYTES], input[7];\r\nunsigned int id;\r\nint err = 0;\r\n*internal = false;\r\nif (clk_spec) {\r\nerr = clk_spec->get(bebob, &id);\r\nif (err < 0) {\r\ndev_err(&bebob->unit->device,\r\n"fail to get clock source: %d\n", err);\r\ngoto end;\r\n}\r\nif (id >= clk_spec->num) {\r\ndev_err(&bebob->unit->device,\r\n"clock source %d out of range 0..%d\n",\r\nid, clk_spec->num - 1);\r\nerr = -EIO;\r\ngoto end;\r\n}\r\nif (strncmp(clk_spec->labels[id], SND_BEBOB_CLOCK_INTERNAL,\r\nstrlen(SND_BEBOB_CLOCK_INTERNAL)) == 0)\r\n*internal = true;\r\ngoto end;\r\n}\r\nif (bebob->sync_input_plug < 0) {\r\n*internal = true;\r\ngoto end;\r\n}\r\navc_bridgeco_fill_msu_addr(addr, AVC_BRIDGECO_PLUG_DIR_IN,\r\nbebob->sync_input_plug);\r\nerr = avc_bridgeco_get_plug_input(bebob->unit, addr, input);\r\nif (err < 0) {\r\ndev_err(&bebob->unit->device,\r\n"fail to get an input for MSU in plug %d: %d\n",\r\nbebob->sync_input_plug, err);\r\ngoto end;\r\n}\r\nif (input[0] == 0xff) {\r\n*internal = true;\r\ngoto end;\r\n}\r\n*internal = ((input[0] == AVC_BRIDGECO_PLUG_DIR_OUT) &&\r\n(input[1] == AVC_BRIDGECO_PLUG_MODE_SUBUNIT) &&\r\n(input[2] == 0x0c) &&\r\n(input[3] == 0x00));\r\nend:\r\nreturn err;\r\n}\r\nstatic unsigned int\r\nmap_data_channels(struct snd_bebob *bebob, struct amdtp_stream *s)\r\n{\r\nunsigned int sec, sections, ch, channels;\r\nunsigned int pcm, midi, location;\r\nunsigned int stm_pos, sec_loc, pos;\r\nu8 *buf, addr[AVC_BRIDGECO_ADDR_BYTES], type;\r\nenum avc_bridgeco_plug_dir dir;\r\nint err;\r\nbuf = kzalloc(256, GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\nif (s == &bebob->tx_stream)\r\ndir = AVC_BRIDGECO_PLUG_DIR_OUT;\r\nelse\r\ndir = AVC_BRIDGECO_PLUG_DIR_IN;\r\navc_bridgeco_fill_unit_addr(addr, dir, AVC_BRIDGECO_PLUG_UNIT_ISOC, 0);\r\nerr = avc_bridgeco_get_plug_ch_pos(bebob->unit, addr, buf, 256);\r\nif (err < 0) {\r\ndev_err(&bebob->unit->device,\r\n"fail to get channel position for isoc %s plug 0: %d\n",\r\n(dir == AVC_BRIDGECO_PLUG_DIR_IN) ? "in" : "out",\r\nerr);\r\ngoto end;\r\n}\r\npos = 0;\r\npcm = 0;\r\nmidi = 0;\r\nsections = buf[pos++];\r\nfor (sec = 0; sec < sections; sec++) {\r\navc_bridgeco_fill_unit_addr(addr, dir,\r\nAVC_BRIDGECO_PLUG_UNIT_ISOC, 0);\r\nerr = avc_bridgeco_get_plug_section_type(bebob->unit, addr,\r\nsec, &type);\r\nif (err < 0) {\r\ndev_err(&bebob->unit->device,\r\n"fail to get section type for isoc %s plug 0: %d\n",\r\n(dir == AVC_BRIDGECO_PLUG_DIR_IN) ? "in" :\r\n"out",\r\nerr);\r\ngoto end;\r\n}\r\nif (type == 0xff) {\r\nerr = -ENOSYS;\r\ngoto end;\r\n}\r\nchannels = buf[pos++];\r\nfor (ch = 0; ch < channels; ch++) {\r\nstm_pos = buf[pos++] - 1;\r\nsec_loc = buf[pos++] - 1;\r\nif (sec_loc >= channels)\r\nsec_loc = ch;\r\nswitch (type) {\r\ncase 0x0a:\r\nif ((midi > 0) && (stm_pos != midi)) {\r\nerr = -ENOSYS;\r\ngoto end;\r\n}\r\ns->midi_position = stm_pos;\r\nmidi = stm_pos;\r\nbreak;\r\ncase 0x01:\r\ncase 0x02:\r\ncase 0x03:\r\ncase 0x04:\r\ncase 0x05:\r\ncase 0x06:\r\ncase 0x07:\r\ncase 0x08:\r\ncase 0x09:\r\ndefault:\r\nlocation = pcm + sec_loc;\r\nif (location >= AMDTP_MAX_CHANNELS_FOR_PCM) {\r\nerr = -ENOSYS;\r\ngoto end;\r\n}\r\ns->pcm_positions[location] = stm_pos;\r\nbreak;\r\n}\r\n}\r\nif (type != 0x0a)\r\npcm += channels;\r\nelse\r\nmidi += channels;\r\n}\r\nend:\r\nkfree(buf);\r\nreturn err;\r\n}\r\nstatic int\r\ninit_both_connections(struct snd_bebob *bebob)\r\n{\r\nint err;\r\nerr = cmp_connection_init(&bebob->in_conn,\r\nbebob->unit, CMP_INPUT, 0);\r\nif (err < 0)\r\ngoto end;\r\nerr = cmp_connection_init(&bebob->out_conn,\r\nbebob->unit, CMP_OUTPUT, 0);\r\nif (err < 0)\r\ncmp_connection_destroy(&bebob->in_conn);\r\nend:\r\nreturn err;\r\n}\r\nstatic int\r\ncheck_connection_used_by_others(struct snd_bebob *bebob, struct amdtp_stream *s)\r\n{\r\nstruct cmp_connection *conn;\r\nbool used;\r\nint err;\r\nif (s == &bebob->tx_stream)\r\nconn = &bebob->out_conn;\r\nelse\r\nconn = &bebob->in_conn;\r\nerr = cmp_connection_check_used(conn, &used);\r\nif ((err >= 0) && used && !amdtp_stream_running(s)) {\r\ndev_err(&bebob->unit->device,\r\n"Connection established by others: %cPCR[%d]\n",\r\n(conn->direction == CMP_OUTPUT) ? 'o' : 'i',\r\nconn->pcr_index);\r\nerr = -EBUSY;\r\n}\r\nreturn err;\r\n}\r\nstatic int\r\nmake_both_connections(struct snd_bebob *bebob, unsigned int rate)\r\n{\r\nint index, pcm_channels, midi_channels, err = 0;\r\nif (bebob->connected)\r\ngoto end;\r\nindex = get_formation_index(rate);\r\npcm_channels = bebob->tx_stream_formations[index].pcm;\r\nmidi_channels = bebob->tx_stream_formations[index].midi;\r\namdtp_stream_set_parameters(&bebob->tx_stream,\r\nrate, pcm_channels, midi_channels * 8);\r\npcm_channels = bebob->rx_stream_formations[index].pcm;\r\nmidi_channels = bebob->rx_stream_formations[index].midi;\r\namdtp_stream_set_parameters(&bebob->rx_stream,\r\nrate, pcm_channels, midi_channels * 8);\r\nerr = cmp_connection_establish(&bebob->out_conn,\r\namdtp_stream_get_max_payload(&bebob->tx_stream));\r\nif (err < 0)\r\ngoto end;\r\nerr = cmp_connection_establish(&bebob->in_conn,\r\namdtp_stream_get_max_payload(&bebob->rx_stream));\r\nif (err < 0) {\r\ncmp_connection_break(&bebob->out_conn);\r\ngoto end;\r\n}\r\nbebob->connected = true;\r\nend:\r\nreturn err;\r\n}\r\nstatic void\r\nbreak_both_connections(struct snd_bebob *bebob)\r\n{\r\ncmp_connection_break(&bebob->in_conn);\r\ncmp_connection_break(&bebob->out_conn);\r\nbebob->connected = false;\r\nif (bebob->maudio_special_quirk != NULL)\r\nmsleep(200);\r\n}\r\nstatic void\r\ndestroy_both_connections(struct snd_bebob *bebob)\r\n{\r\ncmp_connection_destroy(&bebob->in_conn);\r\ncmp_connection_destroy(&bebob->out_conn);\r\n}\r\nstatic int\r\nget_sync_mode(struct snd_bebob *bebob, enum cip_flags *sync_mode)\r\n{\r\n*sync_mode = CIP_SYNC_TO_DEVICE;\r\nreturn 0;\r\n}\r\nstatic int\r\nstart_stream(struct snd_bebob *bebob, struct amdtp_stream *stream,\r\nunsigned int rate)\r\n{\r\nstruct cmp_connection *conn;\r\nint err = 0;\r\nif (stream == &bebob->rx_stream)\r\nconn = &bebob->in_conn;\r\nelse\r\nconn = &bebob->out_conn;\r\nif (bebob->maudio_special_quirk == NULL) {\r\nerr = map_data_channels(bebob, stream);\r\nif (err < 0)\r\ngoto end;\r\n}\r\nerr = amdtp_stream_start(stream,\r\nconn->resources.channel,\r\nconn->speed);\r\nend:\r\nreturn err;\r\n}\r\nint snd_bebob_stream_init_duplex(struct snd_bebob *bebob)\r\n{\r\nint err;\r\nerr = init_both_connections(bebob);\r\nif (err < 0)\r\ngoto end;\r\nerr = amdtp_stream_init(&bebob->tx_stream, bebob->unit,\r\nAMDTP_IN_STREAM, CIP_BLOCKING);\r\nif (err < 0) {\r\namdtp_stream_destroy(&bebob->tx_stream);\r\ndestroy_both_connections(bebob);\r\ngoto end;\r\n}\r\ninit_completion(&bebob->bus_reset);\r\nbebob->tx_stream.flags |= CIP_SKIP_INIT_DBC_CHECK;\r\nif (bebob->maudio_special_quirk)\r\nbebob->tx_stream.flags |= CIP_EMPTY_HAS_WRONG_DBC;\r\nerr = amdtp_stream_init(&bebob->rx_stream, bebob->unit,\r\nAMDTP_OUT_STREAM, CIP_BLOCKING);\r\nif (err < 0) {\r\namdtp_stream_destroy(&bebob->tx_stream);\r\namdtp_stream_destroy(&bebob->rx_stream);\r\ndestroy_both_connections(bebob);\r\n}\r\nend:\r\nreturn err;\r\n}\r\nint snd_bebob_stream_start_duplex(struct snd_bebob *bebob, unsigned int rate)\r\n{\r\nstruct snd_bebob_rate_spec *rate_spec = bebob->spec->rate;\r\nstruct amdtp_stream *master, *slave;\r\natomic_t *slave_substreams;\r\nenum cip_flags sync_mode;\r\nunsigned int curr_rate;\r\nbool updated = false;\r\nint err = 0;\r\nif (amdtp_streaming_error(&bebob->tx_stream)) {\r\nif (completion_done(&bebob->bus_reset))\r\nreinit_completion(&bebob->bus_reset);\r\nupdated = (wait_for_completion_interruptible_timeout(\r\n&bebob->bus_reset,\r\nmsecs_to_jiffies(FW_ISO_RESOURCE_DELAY)) > 0);\r\n}\r\nmutex_lock(&bebob->mutex);\r\nif (atomic_read(&bebob->playback_substreams) == 0 &&\r\natomic_read(&bebob->capture_substreams) == 0)\r\ngoto end;\r\nerr = get_sync_mode(bebob, &sync_mode);\r\nif (err < 0)\r\ngoto end;\r\nif (sync_mode == CIP_SYNC_TO_DEVICE) {\r\nmaster = &bebob->tx_stream;\r\nslave = &bebob->rx_stream;\r\nslave_substreams = &bebob->playback_substreams;\r\n} else {\r\nmaster = &bebob->rx_stream;\r\nslave = &bebob->tx_stream;\r\nslave_substreams = &bebob->capture_substreams;\r\n}\r\nerr = check_connection_used_by_others(bebob, master);\r\nif (err < 0)\r\ngoto end;\r\nif (amdtp_streaming_error(master))\r\namdtp_stream_stop(master);\r\nif (amdtp_streaming_error(slave))\r\namdtp_stream_stop(slave);\r\nif (!updated &&\r\n!amdtp_stream_running(master) && !amdtp_stream_running(slave))\r\nbreak_both_connections(bebob);\r\nerr = rate_spec->get(bebob, &curr_rate);\r\nif (err < 0) {\r\ndev_err(&bebob->unit->device,\r\n"fail to get sampling rate: %d\n", err);\r\ngoto end;\r\n}\r\nif (rate == 0)\r\nrate = curr_rate;\r\nif (rate != curr_rate) {\r\namdtp_stream_stop(master);\r\namdtp_stream_stop(slave);\r\nbreak_both_connections(bebob);\r\n}\r\nif (!amdtp_stream_running(master)) {\r\namdtp_stream_set_sync(sync_mode, master, slave);\r\nbebob->master = master;\r\nif (bebob->maudio_special_quirk == NULL) {\r\nerr = rate_spec->set(bebob, rate);\r\nif (err < 0) {\r\ndev_err(&bebob->unit->device,\r\n"fail to set sampling rate: %d\n",\r\nerr);\r\ngoto end;\r\n}\r\n}\r\nerr = make_both_connections(bebob, rate);\r\nif (err < 0)\r\ngoto end;\r\nerr = start_stream(bebob, master, rate);\r\nif (err < 0) {\r\ndev_err(&bebob->unit->device,\r\n"fail to run AMDTP master stream:%d\n", err);\r\nbreak_both_connections(bebob);\r\ngoto end;\r\n}\r\nif (bebob->maudio_special_quirk != NULL) {\r\nerr = rate_spec->set(bebob, rate);\r\nif (err < 0) {\r\ndev_err(&bebob->unit->device,\r\n"fail to ensure sampling rate: %d\n",\r\nerr);\r\namdtp_stream_stop(master);\r\nbreak_both_connections(bebob);\r\ngoto end;\r\n}\r\n}\r\nif (!amdtp_stream_wait_callback(master, CALLBACK_TIMEOUT)) {\r\namdtp_stream_stop(master);\r\nbreak_both_connections(bebob);\r\nerr = -ETIMEDOUT;\r\ngoto end;\r\n}\r\n}\r\nif (atomic_read(slave_substreams) > 0 && !amdtp_stream_running(slave)) {\r\nerr = start_stream(bebob, slave, rate);\r\nif (err < 0) {\r\ndev_err(&bebob->unit->device,\r\n"fail to run AMDTP slave stream:%d\n", err);\r\namdtp_stream_stop(master);\r\nbreak_both_connections(bebob);\r\ngoto end;\r\n}\r\nif (!amdtp_stream_wait_callback(slave, CALLBACK_TIMEOUT)) {\r\namdtp_stream_stop(slave);\r\namdtp_stream_stop(master);\r\nbreak_both_connections(bebob);\r\nerr = -ETIMEDOUT;\r\n}\r\n}\r\nend:\r\nmutex_unlock(&bebob->mutex);\r\nreturn err;\r\n}\r\nvoid snd_bebob_stream_stop_duplex(struct snd_bebob *bebob)\r\n{\r\nstruct amdtp_stream *master, *slave;\r\natomic_t *master_substreams, *slave_substreams;\r\nif (bebob->master == &bebob->rx_stream) {\r\nslave = &bebob->tx_stream;\r\nmaster = &bebob->rx_stream;\r\nslave_substreams = &bebob->capture_substreams;\r\nmaster_substreams = &bebob->playback_substreams;\r\n} else {\r\nslave = &bebob->rx_stream;\r\nmaster = &bebob->tx_stream;\r\nslave_substreams = &bebob->playback_substreams;\r\nmaster_substreams = &bebob->capture_substreams;\r\n}\r\nmutex_lock(&bebob->mutex);\r\nif (atomic_read(slave_substreams) == 0) {\r\namdtp_stream_pcm_abort(slave);\r\namdtp_stream_stop(slave);\r\nif (atomic_read(master_substreams) == 0) {\r\namdtp_stream_pcm_abort(master);\r\namdtp_stream_stop(master);\r\nbreak_both_connections(bebob);\r\n}\r\n}\r\nmutex_unlock(&bebob->mutex);\r\n}\r\nvoid snd_bebob_stream_update_duplex(struct snd_bebob *bebob)\r\n{\r\nmutex_lock(&bebob->mutex);\r\nif ((cmp_connection_update(&bebob->in_conn) < 0) ||\r\n(cmp_connection_update(&bebob->out_conn) < 0)) {\r\namdtp_stream_pcm_abort(&bebob->rx_stream);\r\namdtp_stream_pcm_abort(&bebob->tx_stream);\r\namdtp_stream_stop(&bebob->rx_stream);\r\namdtp_stream_stop(&bebob->tx_stream);\r\nbreak_both_connections(bebob);\r\n} else {\r\namdtp_stream_update(&bebob->rx_stream);\r\namdtp_stream_update(&bebob->tx_stream);\r\n}\r\nif (!completion_done(&bebob->bus_reset))\r\ncomplete_all(&bebob->bus_reset);\r\nmutex_unlock(&bebob->mutex);\r\n}\r\nvoid snd_bebob_stream_destroy_duplex(struct snd_bebob *bebob)\r\n{\r\namdtp_stream_destroy(&bebob->rx_stream);\r\namdtp_stream_destroy(&bebob->tx_stream);\r\ndestroy_both_connections(bebob);\r\n}\r\nstatic int\r\nparse_stream_formation(u8 *buf, unsigned int len,\r\nstruct snd_bebob_stream_formation *formation)\r\n{\r\nunsigned int i, e, channels, format;\r\nif ((buf[0] != 0x90) || (buf[1] != 0x40))\r\nreturn -ENOSYS;\r\nfor (i = 0; i < ARRAY_SIZE(bridgeco_freq_table); i++) {\r\nif (buf[2] == bridgeco_freq_table[i])\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(bridgeco_freq_table))\r\nreturn -ENOSYS;\r\nmemset(&formation[i], 0, sizeof(struct snd_bebob_stream_formation));\r\nfor (e = 0; e < buf[4]; e++) {\r\nchannels = buf[5 + e * 2];\r\nformat = buf[6 + e * 2];\r\nswitch (format) {\r\ncase 0x00:\r\ncase 0x06:\r\nformation[i].pcm += channels;\r\nbreak;\r\ncase 0x0d:\r\nformation[i].midi += channels;\r\nbreak;\r\ncase 0x01:\r\ncase 0x02:\r\ncase 0x03:\r\ncase 0x04:\r\ncase 0x05:\r\ncase 0x07:\r\ncase 0x0c:\r\ncase 0x08:\r\ncase 0x09:\r\ncase 0x0a:\r\ncase 0x0b:\r\ncase 0x40:\r\ncase 0xff:\r\ndefault:\r\nreturn -ENOSYS;\r\n}\r\n}\r\nif (formation[i].pcm > AMDTP_MAX_CHANNELS_FOR_PCM ||\r\nformation[i].midi > AMDTP_MAX_CHANNELS_FOR_MIDI)\r\nreturn -ENOSYS;\r\nreturn 0;\r\n}\r\nstatic int\r\nfill_stream_formations(struct snd_bebob *bebob, enum avc_bridgeco_plug_dir dir,\r\nunsigned short pid)\r\n{\r\nu8 *buf;\r\nstruct snd_bebob_stream_formation *formations;\r\nunsigned int len, eid;\r\nu8 addr[AVC_BRIDGECO_ADDR_BYTES];\r\nint err;\r\nbuf = kmalloc(FORMAT_MAXIMUM_LENGTH, GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\nif (dir == AVC_BRIDGECO_PLUG_DIR_IN)\r\nformations = bebob->rx_stream_formations;\r\nelse\r\nformations = bebob->tx_stream_formations;\r\nfor (eid = 0; eid < SND_BEBOB_STRM_FMT_ENTRIES; eid++) {\r\nlen = FORMAT_MAXIMUM_LENGTH;\r\navc_bridgeco_fill_unit_addr(addr, dir,\r\nAVC_BRIDGECO_PLUG_UNIT_ISOC, pid);\r\nerr = avc_bridgeco_get_plug_strm_fmt(bebob->unit, addr, buf,\r\n&len, eid);\r\nif (err == -EINVAL && eid > 0) {\r\nerr = 0;\r\nbreak;\r\n} else if (err < 0) {\r\ndev_err(&bebob->unit->device,\r\n"fail to get stream format %d for isoc %s plug %d:%d\n",\r\neid,\r\n(dir == AVC_BRIDGECO_PLUG_DIR_IN) ? "in" :\r\n"out",\r\npid, err);\r\nbreak;\r\n}\r\nerr = parse_stream_formation(buf, len, formations);\r\nif (err < 0)\r\nbreak;\r\n}\r\nkfree(buf);\r\nreturn err;\r\n}\r\nstatic int\r\nseek_msu_sync_input_plug(struct snd_bebob *bebob)\r\n{\r\nu8 plugs[AVC_PLUG_INFO_BUF_BYTES], addr[AVC_BRIDGECO_ADDR_BYTES];\r\nunsigned int i;\r\nenum avc_bridgeco_plug_type type;\r\nint err;\r\nerr = avc_general_get_plug_info(bebob->unit, 0x0c, 0x00, 0x00, plugs);\r\nif (err < 0) {\r\ndev_err(&bebob->unit->device,\r\n"fail to get info for MSU in/out plugs: %d\n",\r\nerr);\r\ngoto end;\r\n}\r\nbebob->sync_input_plug = -1;\r\nfor (i = 0; i < plugs[0]; i++) {\r\navc_bridgeco_fill_msu_addr(addr, AVC_BRIDGECO_PLUG_DIR_IN, i);\r\nerr = avc_bridgeco_get_plug_type(bebob->unit, addr, &type);\r\nif (err < 0) {\r\ndev_err(&bebob->unit->device,\r\n"fail to get type for MSU in plug %d: %d\n",\r\ni, err);\r\ngoto end;\r\n}\r\nif (type == AVC_BRIDGECO_PLUG_TYPE_SYNC) {\r\nbebob->sync_input_plug = i;\r\nbreak;\r\n}\r\n}\r\nend:\r\nreturn err;\r\n}\r\nint snd_bebob_stream_discover(struct snd_bebob *bebob)\r\n{\r\nstruct snd_bebob_clock_spec *clk_spec = bebob->spec->clock;\r\nu8 plugs[AVC_PLUG_INFO_BUF_BYTES], addr[AVC_BRIDGECO_ADDR_BYTES];\r\nenum avc_bridgeco_plug_type type;\r\nunsigned int i;\r\nint err;\r\nerr = avc_general_get_plug_info(bebob->unit, 0x1f, 0x07, 0x00, plugs);\r\nif (err < 0) {\r\ndev_err(&bebob->unit->device,\r\n"fail to get info for isoc/external in/out plugs: %d\n",\r\nerr);\r\ngoto end;\r\n}\r\nif ((plugs[0] == 0) || (plugs[1] == 0)) {\r\nerr = -ENOSYS;\r\ngoto end;\r\n}\r\navc_bridgeco_fill_unit_addr(addr, AVC_BRIDGECO_PLUG_DIR_IN,\r\nAVC_BRIDGECO_PLUG_UNIT_ISOC, 0);\r\nerr = avc_bridgeco_get_plug_type(bebob->unit, addr, &type);\r\nif (err < 0) {\r\ndev_err(&bebob->unit->device,\r\n"fail to get type for isoc in plug 0: %d\n", err);\r\ngoto end;\r\n} else if (type != AVC_BRIDGECO_PLUG_TYPE_ISOC) {\r\nerr = -ENOSYS;\r\ngoto end;\r\n}\r\nerr = fill_stream_formations(bebob, AVC_BRIDGECO_PLUG_DIR_IN, 0);\r\nif (err < 0)\r\ngoto end;\r\navc_bridgeco_fill_unit_addr(addr, AVC_BRIDGECO_PLUG_DIR_OUT,\r\nAVC_BRIDGECO_PLUG_UNIT_ISOC, 0);\r\nerr = avc_bridgeco_get_plug_type(bebob->unit, addr, &type);\r\nif (err < 0) {\r\ndev_err(&bebob->unit->device,\r\n"fail to get type for isoc out plug 0: %d\n", err);\r\ngoto end;\r\n} else if (type != AVC_BRIDGECO_PLUG_TYPE_ISOC) {\r\nerr = -ENOSYS;\r\ngoto end;\r\n}\r\nerr = fill_stream_formations(bebob, AVC_BRIDGECO_PLUG_DIR_OUT, 0);\r\nif (err < 0)\r\ngoto end;\r\nbebob->midi_input_ports = 0;\r\nfor (i = 0; i < plugs[2]; i++) {\r\navc_bridgeco_fill_unit_addr(addr, AVC_BRIDGECO_PLUG_DIR_IN,\r\nAVC_BRIDGECO_PLUG_UNIT_EXT, i);\r\nerr = avc_bridgeco_get_plug_type(bebob->unit, addr, &type);\r\nif (err < 0) {\r\ndev_err(&bebob->unit->device,\r\n"fail to get type for external in plug %d: %d\n",\r\ni, err);\r\ngoto end;\r\n} else if (type == AVC_BRIDGECO_PLUG_TYPE_MIDI) {\r\nbebob->midi_input_ports++;\r\n}\r\n}\r\nbebob->midi_output_ports = 0;\r\nfor (i = 0; i < plugs[3]; i++) {\r\navc_bridgeco_fill_unit_addr(addr, AVC_BRIDGECO_PLUG_DIR_OUT,\r\nAVC_BRIDGECO_PLUG_UNIT_EXT, i);\r\nerr = avc_bridgeco_get_plug_type(bebob->unit, addr, &type);\r\nif (err < 0) {\r\ndev_err(&bebob->unit->device,\r\n"fail to get type for external out plug %d: %d\n",\r\ni, err);\r\ngoto end;\r\n} else if (type == AVC_BRIDGECO_PLUG_TYPE_MIDI) {\r\nbebob->midi_output_ports++;\r\n}\r\n}\r\nif (!clk_spec)\r\nerr = seek_msu_sync_input_plug(bebob);\r\nend:\r\nreturn err;\r\n}\r\nvoid snd_bebob_stream_lock_changed(struct snd_bebob *bebob)\r\n{\r\nbebob->dev_lock_changed = true;\r\nwake_up(&bebob->hwdep_wait);\r\n}\r\nint snd_bebob_stream_lock_try(struct snd_bebob *bebob)\r\n{\r\nint err;\r\nspin_lock_irq(&bebob->lock);\r\nif (bebob->dev_lock_count < 0) {\r\nerr = -EBUSY;\r\ngoto end;\r\n}\r\nif (bebob->dev_lock_count++ == 0)\r\nsnd_bebob_stream_lock_changed(bebob);\r\nerr = 0;\r\nend:\r\nspin_unlock_irq(&bebob->lock);\r\nreturn err;\r\n}\r\nvoid snd_bebob_stream_lock_release(struct snd_bebob *bebob)\r\n{\r\nspin_lock_irq(&bebob->lock);\r\nif (WARN_ON(bebob->dev_lock_count <= 0))\r\ngoto end;\r\nif (--bebob->dev_lock_count == 0)\r\nsnd_bebob_stream_lock_changed(bebob);\r\nend:\r\nspin_unlock_irq(&bebob->lock);\r\n}
