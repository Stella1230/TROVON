static void srr_dqp_index_advc(struct bdc *bdc, u32 srr_num)\r\n{\r\nstruct srr *srr;\r\nsrr = &bdc->srr;\r\ndev_dbg_ratelimited(bdc->dev, "srr->dqp_index:%d\n", srr->dqp_index);\r\nsrr->dqp_index++;\r\nif (srr->dqp_index == NUM_SR_ENTRIES)\r\nsrr->dqp_index = 0;\r\n}\r\nstatic void bdc_uspc_connected(struct bdc *bdc)\r\n{\r\nu32 speed, temp;\r\nu32 usppms;\r\nint ret;\r\ntemp = bdc_readl(bdc->regs, BDC_USPC);\r\nspeed = BDC_PSP(temp);\r\ndev_dbg(bdc->dev, "%s speed=%x\n", __func__, speed);\r\nswitch (speed) {\r\ncase BDC_SPEED_SS:\r\nbdc_gadget_ep0_desc.wMaxPacketSize =\r\ncpu_to_le16(EP0_MAX_PKT_SIZE);\r\nbdc->gadget.ep0->maxpacket = EP0_MAX_PKT_SIZE;\r\nbdc->gadget.speed = USB_SPEED_SUPER;\r\nusppms = bdc_readl(bdc->regs, BDC_USPPMS);\r\nusppms &= ~BDC_U1T(0xff);\r\nusppms |= BDC_U1T(U1_TIMEOUT);\r\nusppms |= BDC_PORT_W1S;\r\nbdc_writel(bdc->regs, BDC_USPPMS, usppms);\r\nbreak;\r\ncase BDC_SPEED_HS:\r\nbdc_gadget_ep0_desc.wMaxPacketSize = cpu_to_le16(64);\r\nbdc->gadget.ep0->maxpacket = 64;\r\nbdc->gadget.speed = USB_SPEED_HIGH;\r\nbreak;\r\ncase BDC_SPEED_FS:\r\nbdc_gadget_ep0_desc.wMaxPacketSize = cpu_to_le16(64);\r\nbdc->gadget.ep0->maxpacket = 64;\r\nbdc->gadget.speed = USB_SPEED_FULL;\r\nbreak;\r\ncase BDC_SPEED_LS:\r\nbdc_gadget_ep0_desc.wMaxPacketSize = cpu_to_le16(8);\r\nbdc->gadget.ep0->maxpacket = 8;\r\nbdc->gadget.speed = USB_SPEED_LOW;\r\nbreak;\r\ndefault:\r\ndev_err(bdc->dev, "UNDEFINED SPEED\n");\r\nreturn;\r\n}\r\ndev_dbg(bdc->dev, "connected at %s\n", conn_speed_str[speed]);\r\nbdc->bdc_ep_array[1]->desc = &bdc_gadget_ep0_desc;\r\nret = bdc_config_ep(bdc, bdc->bdc_ep_array[1]);\r\nif (ret)\r\ndev_err(bdc->dev, "EP0 config failed\n");\r\nbdc->bdc_ep_array[1]->usb_ep.desc = &bdc_gadget_ep0_desc;\r\nbdc->bdc_ep_array[1]->flags |= BDC_EP_ENABLED;\r\nusb_gadget_set_state(&bdc->gadget, USB_STATE_DEFAULT);\r\n}\r\nstatic void bdc_uspc_disconnected(struct bdc *bdc, bool reinit)\r\n{\r\nstruct bdc_ep *ep;\r\ndev_dbg(bdc->dev, "%s\n", __func__);\r\nep = bdc->bdc_ep_array[1];\r\nif (ep && (ep->flags & BDC_EP_ENABLED))\r\nbdc_ep_disable(ep);\r\nif (bdc->gadget_driver && bdc->gadget_driver->disconnect) {\r\nspin_unlock(&bdc->lock);\r\nbdc->gadget_driver->disconnect(&bdc->gadget);\r\nspin_lock(&bdc->lock);\r\n}\r\nbdc->gadget.speed = USB_SPEED_UNKNOWN;\r\nbdc->devstatus &= DEVSTATUS_CLEAR;\r\nbdc->delayed_status = false;\r\nbdc->reinit = reinit;\r\nbdc->test_mode = false;\r\n}\r\nstatic void bdc_func_wake_timer(struct work_struct *work)\r\n{\r\nstruct bdc *bdc = container_of(work, struct bdc, func_wake_notify.work);\r\nunsigned long flags;\r\ndev_dbg(bdc->dev, "%s\n", __func__);\r\nspin_lock_irqsave(&bdc->lock, flags);\r\nif (bdc->devstatus & FUNC_WAKE_ISSUED) {\r\ndev_dbg(bdc->dev, "FUNC_WAKE_ISSUED FLAG IS STILL SET\n");\r\nbdc_function_wake_fh(bdc, 0);\r\nschedule_delayed_work(&bdc->func_wake_notify,\r\nmsecs_to_jiffies(BDC_TNOTIFY));\r\n}\r\nspin_unlock_irqrestore(&bdc->lock, flags);\r\n}\r\nstatic void handle_link_state_change(struct bdc *bdc, u32 uspc)\r\n{\r\nu32 link_state;\r\ndev_dbg(bdc->dev, "Link state change");\r\nlink_state = BDC_PST(uspc);\r\nswitch (link_state) {\r\ncase BDC_LINK_STATE_U3:\r\nif ((bdc->gadget.speed != USB_SPEED_UNKNOWN) &&\r\nbdc->gadget_driver->suspend) {\r\ndev_dbg(bdc->dev, "Entered Suspend mode\n");\r\nspin_unlock(&bdc->lock);\r\nbdc->devstatus |= DEVICE_SUSPENDED;\r\nbdc->gadget_driver->suspend(&bdc->gadget);\r\nspin_lock(&bdc->lock);\r\n}\r\nbreak;\r\ncase BDC_LINK_STATE_U0:\r\nif (bdc->devstatus & REMOTE_WAKEUP_ISSUED) {\r\nbdc->devstatus &= ~REMOTE_WAKEUP_ISSUED;\r\nif (bdc->gadget.speed == USB_SPEED_SUPER) {\r\nbdc_function_wake_fh(bdc, 0);\r\nbdc->devstatus |= FUNC_WAKE_ISSUED;\r\nschedule_delayed_work(\r\n&bdc->func_wake_notify,\r\nmsecs_to_jiffies(BDC_TNOTIFY));\r\ndev_dbg(bdc->dev, "sched func_wake_notify\n");\r\n}\r\n}\r\nbreak;\r\ncase BDC_LINK_STATE_RESUME:\r\ndev_dbg(bdc->dev, "Resumed from Suspend\n");\r\nif (bdc->devstatus & DEVICE_SUSPENDED) {\r\nbdc->gadget_driver->resume(&bdc->gadget);\r\nbdc->devstatus &= ~DEVICE_SUSPENDED;\r\n}\r\nbreak;\r\ndefault:\r\ndev_dbg(bdc->dev, "link state:%d\n", link_state);\r\n}\r\n}\r\nvoid bdc_sr_uspc(struct bdc *bdc, struct bdc_sr *sreport)\r\n{\r\nu32 clear_flags = 0;\r\nu32 uspc;\r\nbool connected = false;\r\nbool disconn = false;\r\nuspc = bdc_readl(bdc->regs, BDC_USPC);\r\ndev_dbg(bdc->dev, "%s uspc=0x%08x\n", __func__, uspc);\r\nif (uspc & BDC_PCC) {\r\nif ((uspc & BDC_VBC) && !(uspc & BDC_VBS) && !(uspc & BDC_PCS))\r\ndisconn = true;\r\nelse if ((uspc & BDC_PCS) && !BDC_PST(uspc))\r\nconnected = true;\r\n}\r\nif ((uspc & BDC_VBC) && (uspc & BDC_VBS)) {\r\nif (bdc->pullup) {\r\ndev_dbg(bdc->dev, "Do a softconnect\n");\r\nbdc_softconn(bdc);\r\nusb_gadget_set_state(&bdc->gadget, USB_STATE_POWERED);\r\n}\r\nclear_flags = BDC_VBC;\r\n} else if ((uspc & BDC_PRS) || (uspc & BDC_PRC) || disconn) {\r\ndev_dbg(bdc->dev, "Port reset or disconn\n");\r\nbdc_uspc_disconnected(bdc, disconn);\r\nclear_flags = BDC_PCC|BDC_PCS|BDC_PRS|BDC_PRC;\r\n} else if ((uspc & BDC_PSC) && (uspc & BDC_PCS)) {\r\nhandle_link_state_change(bdc, uspc);\r\nclear_flags = BDC_PSC|BDC_PCS;\r\n}\r\nif (connected) {\r\ndev_dbg(bdc->dev, "Connected\n");\r\nbdc_uspc_connected(bdc);\r\nbdc->devstatus &= ~(DEVICE_SUSPENDED);\r\n}\r\nuspc = bdc_readl(bdc->regs, BDC_USPC);\r\nuspc &= (~BDC_USPSC_RW);\r\ndev_dbg(bdc->dev, "uspc=%x\n", uspc);\r\nbdc_writel(bdc->regs, BDC_USPC, clear_flags);\r\n}\r\nstatic irqreturn_t bdc_udc_interrupt(int irq, void *_bdc)\r\n{\r\nu32 eqp_index, dqp_index, sr_type, srr_int;\r\nstruct bdc_sr *sreport;\r\nstruct bdc *bdc = _bdc;\r\nu32 status;\r\nint ret;\r\nspin_lock(&bdc->lock);\r\nstatus = bdc_readl(bdc->regs, BDC_BDCSC);\r\nif (!(status & BDC_GIP)) {\r\nspin_unlock(&bdc->lock);\r\nreturn IRQ_NONE;\r\n}\r\nsrr_int = bdc_readl(bdc->regs, BDC_SRRINT(0));\r\nif (!(srr_int & BDC_SRR_IP)) {\r\ndev_warn(bdc->dev, "Global irq pending but SRR IP is 0\n");\r\nspin_unlock(&bdc->lock);\r\nreturn IRQ_NONE;\r\n}\r\neqp_index = BDC_SRR_EPI(srr_int);\r\ndqp_index = BDC_SRR_DPI(srr_int);\r\ndev_dbg(bdc->dev,\r\n"%s eqp_index=%d dqp_index=%d srr.dqp_index=%d\n\n",\r\n__func__, eqp_index, dqp_index, bdc->srr.dqp_index);\r\nif (eqp_index == dqp_index) {\r\ndev_dbg(bdc->dev, "SRR empty?\n");\r\nspin_unlock(&bdc->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nwhile (bdc->srr.dqp_index != eqp_index) {\r\nsreport = &bdc->srr.sr_bds[bdc->srr.dqp_index];\r\nrmb();\r\nsr_type = le32_to_cpu(sreport->offset[3]) & BD_TYPE_BITMASK;\r\ndev_dbg_ratelimited(bdc->dev, "sr_type=%d\n", sr_type);\r\nswitch (sr_type) {\r\ncase SR_XSF:\r\nbdc->sr_handler[0](bdc, sreport);\r\nbreak;\r\ncase SR_USPC:\r\nbdc->sr_handler[1](bdc, sreport);\r\nbreak;\r\ndefault:\r\ndev_warn(bdc->dev, "SR:%d not handled\n", sr_type);\r\n}\r\nsrr_dqp_index_advc(bdc, 0);\r\n}\r\nsrr_int = bdc_readl(bdc->regs, BDC_SRRINT(0));\r\nsrr_int &= ~BDC_SRR_DPI_MASK;\r\nsrr_int &= ~(BDC_SRR_RWS|BDC_SRR_RST|BDC_SRR_ISR);\r\nsrr_int |= ((bdc->srr.dqp_index) << 16);\r\nsrr_int |= BDC_SRR_IP;\r\nbdc_writel(bdc->regs, BDC_SRRINT(0), srr_int);\r\nsrr_int = bdc_readl(bdc->regs, BDC_SRRINT(0));\r\nif (bdc->reinit) {\r\nret = bdc_reinit(bdc);\r\nif (ret)\r\ndev_err(bdc->dev, "err in bdc reinit\n");\r\n}\r\nspin_unlock(&bdc->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int bdc_udc_start(struct usb_gadget *gadget,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct bdc *bdc = gadget_to_bdc(gadget);\r\nunsigned long flags;\r\nint ret = 0;\r\ndev_dbg(bdc->dev, "%s()\n", __func__);\r\nspin_lock_irqsave(&bdc->lock, flags);\r\nif (bdc->gadget_driver) {\r\ndev_err(bdc->dev, "%s is already bound to %s\n",\r\nbdc->gadget.name,\r\nbdc->gadget_driver->driver.name);\r\nret = -EBUSY;\r\ngoto err;\r\n}\r\nret = bdc_run(bdc);\r\nif (ret) {\r\ndev_err(bdc->dev, "%s bdc run fail\n", __func__);\r\ngoto err;\r\n}\r\nbdc->gadget_driver = driver;\r\nbdc->gadget.dev.driver = &driver->driver;\r\nerr:\r\nspin_unlock_irqrestore(&bdc->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int bdc_udc_stop(struct usb_gadget *gadget)\r\n{\r\nstruct bdc *bdc = gadget_to_bdc(gadget);\r\nunsigned long flags;\r\ndev_dbg(bdc->dev, "%s()\n", __func__);\r\nspin_lock_irqsave(&bdc->lock, flags);\r\nbdc_stop(bdc);\r\nbdc->gadget_driver = NULL;\r\nbdc->gadget.dev.driver = NULL;\r\nspin_unlock_irqrestore(&bdc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int bdc_udc_pullup(struct usb_gadget *gadget, int is_on)\r\n{\r\nstruct bdc *bdc = gadget_to_bdc(gadget);\r\nunsigned long flags;\r\nu32 uspc;\r\ndev_dbg(bdc->dev, "%s() is_on:%d\n", __func__, is_on);\r\nif (!gadget)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&bdc->lock, flags);\r\nif (!is_on) {\r\nbdc_softdisconn(bdc);\r\nbdc->pullup = false;\r\n} else {\r\nbdc->pullup = true;\r\nuspc = bdc_readl(bdc->regs, BDC_USPC);\r\nif (uspc & BDC_VBS)\r\nbdc_softconn(bdc);\r\n}\r\nspin_unlock_irqrestore(&bdc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int bdc_udc_set_selfpowered(struct usb_gadget *gadget,\r\nint is_self)\r\n{\r\nstruct bdc *bdc = gadget_to_bdc(gadget);\r\nunsigned long flags;\r\ndev_dbg(bdc->dev, "%s()\n", __func__);\r\ngadget->is_selfpowered = (is_self != 0);\r\nspin_lock_irqsave(&bdc->lock, flags);\r\nif (!is_self)\r\nbdc->devstatus |= 1 << USB_DEVICE_SELF_POWERED;\r\nelse\r\nbdc->devstatus &= ~(1 << USB_DEVICE_SELF_POWERED);\r\nspin_unlock_irqrestore(&bdc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int bdc_udc_wakeup(struct usb_gadget *gadget)\r\n{\r\nstruct bdc *bdc = gadget_to_bdc(gadget);\r\nunsigned long flags;\r\nu8 link_state;\r\nu32 uspc;\r\nint ret = 0;\r\ndev_dbg(bdc->dev,\r\n"%s() bdc->devstatus=%08x\n",\r\n__func__, bdc->devstatus);\r\nif (!(bdc->devstatus & REMOTE_WAKE_ENABLE))\r\nreturn -EOPNOTSUPP;\r\nspin_lock_irqsave(&bdc->lock, flags);\r\nuspc = bdc_readl(bdc->regs, BDC_USPC);\r\nlink_state = BDC_PST(uspc);\r\ndev_dbg(bdc->dev, "link_state =%d portsc=%x", link_state, uspc);\r\nif (link_state != BDC_LINK_STATE_U3) {\r\ndev_warn(bdc->dev,\r\n"can't wakeup from link state %d\n",\r\nlink_state);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (bdc->gadget.speed == USB_SPEED_SUPER)\r\nbdc->devstatus |= REMOTE_WAKEUP_ISSUED;\r\nuspc &= ~BDC_PST_MASK;\r\nuspc &= (~BDC_USPSC_RW);\r\nuspc |= BDC_PST(BDC_LINK_STATE_U0);\r\nuspc |= BDC_SWS;\r\nbdc_writel(bdc->regs, BDC_USPC, uspc);\r\nuspc = bdc_readl(bdc->regs, BDC_USPC);\r\nlink_state = BDC_PST(uspc);\r\ndev_dbg(bdc->dev, "link_state =%d portsc=%x", link_state, uspc);\r\nout:\r\nspin_unlock_irqrestore(&bdc->lock, flags);\r\nreturn ret;\r\n}\r\nint bdc_udc_init(struct bdc *bdc)\r\n{\r\nu32 temp;\r\nint ret;\r\ndev_dbg(bdc->dev, "%s()\n", __func__);\r\nbdc->gadget.ops = &bdc_gadget_ops;\r\nbdc->gadget.max_speed = USB_SPEED_SUPER;\r\nbdc->gadget.speed = USB_SPEED_UNKNOWN;\r\nbdc->gadget.dev.parent = bdc->dev;\r\nbdc->gadget.sg_supported = false;\r\nbdc->gadget.name = BRCM_BDC_NAME;\r\nret = devm_request_irq(bdc->dev, bdc->irq, bdc_udc_interrupt,\r\nIRQF_SHARED , BRCM_BDC_NAME, bdc);\r\nif (ret) {\r\ndev_err(bdc->dev,\r\n"failed to request irq #%d %d\n",\r\nbdc->irq, ret);\r\nreturn ret;\r\n}\r\nret = bdc_init_ep(bdc);\r\nif (ret) {\r\ndev_err(bdc->dev, "bdc init ep fail: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = usb_add_gadget_udc(bdc->dev, &bdc->gadget);\r\nif (ret) {\r\ndev_err(bdc->dev, "failed to register udc\n");\r\ngoto err0;\r\n}\r\nusb_gadget_set_state(&bdc->gadget, USB_STATE_NOTATTACHED);\r\nbdc->bdc_ep_array[1]->desc = &bdc_gadget_ep0_desc;\r\nret = bdc_ep_enable(bdc->bdc_ep_array[1]);\r\nif (ret) {\r\ndev_err(bdc->dev, "fail to enable %s\n",\r\nbdc->bdc_ep_array[1]->name);\r\ngoto err1;\r\n}\r\nINIT_DELAYED_WORK(&bdc->func_wake_notify, bdc_func_wake_timer);\r\ntemp = bdc_readl(bdc->regs, BDC_BDCSC);\r\ntemp |= BDC_GIE;\r\nbdc_writel(bdc->regs, BDC_BDCSC, temp);\r\nreturn 0;\r\nerr1:\r\nusb_del_gadget_udc(&bdc->gadget);\r\nerr0:\r\nbdc_free_ep(bdc);\r\nreturn ret;\r\n}\r\nvoid bdc_udc_exit(struct bdc *bdc)\r\n{\r\ndev_dbg(bdc->dev, "%s()\n", __func__);\r\nbdc_ep_disable(bdc->bdc_ep_array[1]);\r\nusb_del_gadget_udc(&bdc->gadget);\r\nbdc_free_ep(bdc);\r\n}
