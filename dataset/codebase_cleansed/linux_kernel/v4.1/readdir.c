static struct ovl_cache_entry *ovl_cache_entry_from_node(struct rb_node *n)\r\n{\r\nreturn container_of(n, struct ovl_cache_entry, node);\r\n}\r\nstatic struct ovl_cache_entry *ovl_cache_entry_find(struct rb_root *root,\r\nconst char *name, int len)\r\n{\r\nstruct rb_node *node = root->rb_node;\r\nint cmp;\r\nwhile (node) {\r\nstruct ovl_cache_entry *p = ovl_cache_entry_from_node(node);\r\ncmp = strncmp(name, p->name, len);\r\nif (cmp > 0)\r\nnode = p->node.rb_right;\r\nelse if (cmp < 0 || len < p->len)\r\nnode = p->node.rb_left;\r\nelse\r\nreturn p;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct ovl_cache_entry *ovl_cache_entry_new(struct dentry *dir,\r\nconst char *name, int len,\r\nu64 ino, unsigned int d_type)\r\n{\r\nstruct ovl_cache_entry *p;\r\nsize_t size = offsetof(struct ovl_cache_entry, name[len + 1]);\r\np = kmalloc(size, GFP_KERNEL);\r\nif (!p)\r\nreturn NULL;\r\nmemcpy(p->name, name, len);\r\np->name[len] = '\0';\r\np->len = len;\r\np->type = d_type;\r\np->ino = ino;\r\np->is_whiteout = false;\r\nif (d_type == DT_CHR) {\r\nstruct dentry *dentry;\r\nconst struct cred *old_cred;\r\nstruct cred *override_cred;\r\noverride_cred = prepare_creds();\r\nif (!override_cred) {\r\nkfree(p);\r\nreturn NULL;\r\n}\r\ncap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE);\r\nold_cred = override_creds(override_cred);\r\ndentry = lookup_one_len(name, dir, len);\r\nif (!IS_ERR(dentry)) {\r\np->is_whiteout = ovl_is_whiteout(dentry);\r\ndput(dentry);\r\n}\r\nrevert_creds(old_cred);\r\nput_cred(override_cred);\r\n}\r\nreturn p;\r\n}\r\nstatic int ovl_cache_entry_add_rb(struct ovl_readdir_data *rdd,\r\nconst char *name, int len, u64 ino,\r\nunsigned int d_type)\r\n{\r\nstruct rb_node **newp = &rdd->root.rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct ovl_cache_entry *p;\r\nwhile (*newp) {\r\nint cmp;\r\nstruct ovl_cache_entry *tmp;\r\nparent = *newp;\r\ntmp = ovl_cache_entry_from_node(*newp);\r\ncmp = strncmp(name, tmp->name, len);\r\nif (cmp > 0)\r\nnewp = &tmp->node.rb_right;\r\nelse if (cmp < 0 || len < tmp->len)\r\nnewp = &tmp->node.rb_left;\r\nelse\r\nreturn 0;\r\n}\r\np = ovl_cache_entry_new(rdd->dir, name, len, ino, d_type);\r\nif (p == NULL)\r\nreturn -ENOMEM;\r\nlist_add_tail(&p->l_node, rdd->list);\r\nrb_link_node(&p->node, parent, newp);\r\nrb_insert_color(&p->node, &rdd->root);\r\nreturn 0;\r\n}\r\nstatic int ovl_fill_lower(struct ovl_readdir_data *rdd,\r\nconst char *name, int namelen,\r\nloff_t offset, u64 ino, unsigned int d_type)\r\n{\r\nstruct ovl_cache_entry *p;\r\np = ovl_cache_entry_find(&rdd->root, name, namelen);\r\nif (p) {\r\nlist_move_tail(&p->l_node, &rdd->middle);\r\n} else {\r\np = ovl_cache_entry_new(rdd->dir, name, namelen, ino, d_type);\r\nif (p == NULL)\r\nrdd->err = -ENOMEM;\r\nelse\r\nlist_add_tail(&p->l_node, &rdd->middle);\r\n}\r\nreturn rdd->err;\r\n}\r\nvoid ovl_cache_free(struct list_head *list)\r\n{\r\nstruct ovl_cache_entry *p;\r\nstruct ovl_cache_entry *n;\r\nlist_for_each_entry_safe(p, n, list, l_node)\r\nkfree(p);\r\nINIT_LIST_HEAD(list);\r\n}\r\nstatic void ovl_cache_put(struct ovl_dir_file *od, struct dentry *dentry)\r\n{\r\nstruct ovl_dir_cache *cache = od->cache;\r\nWARN_ON(cache->refcount <= 0);\r\ncache->refcount--;\r\nif (!cache->refcount) {\r\nif (ovl_dir_cache(dentry) == cache)\r\novl_set_dir_cache(dentry, NULL);\r\novl_cache_free(&cache->entries);\r\nkfree(cache);\r\n}\r\n}\r\nstatic int ovl_fill_merge(struct dir_context *ctx, const char *name,\r\nint namelen, loff_t offset, u64 ino,\r\nunsigned int d_type)\r\n{\r\nstruct ovl_readdir_data *rdd =\r\ncontainer_of(ctx, struct ovl_readdir_data, ctx);\r\nrdd->count++;\r\nif (!rdd->is_merge)\r\nreturn ovl_cache_entry_add_rb(rdd, name, namelen, ino, d_type);\r\nelse\r\nreturn ovl_fill_lower(rdd, name, namelen, offset, ino, d_type);\r\n}\r\nstatic inline int ovl_dir_read(struct path *realpath,\r\nstruct ovl_readdir_data *rdd)\r\n{\r\nstruct file *realfile;\r\nint err;\r\nrealfile = ovl_path_open(realpath, O_RDONLY | O_DIRECTORY);\r\nif (IS_ERR(realfile))\r\nreturn PTR_ERR(realfile);\r\nrdd->dir = realpath->dentry;\r\nrdd->ctx.pos = 0;\r\ndo {\r\nrdd->count = 0;\r\nrdd->err = 0;\r\nerr = iterate_dir(realfile, &rdd->ctx);\r\nif (err >= 0)\r\nerr = rdd->err;\r\n} while (!err && rdd->count);\r\nfput(realfile);\r\nreturn err;\r\n}\r\nstatic void ovl_dir_reset(struct file *file)\r\n{\r\nstruct ovl_dir_file *od = file->private_data;\r\nstruct ovl_dir_cache *cache = od->cache;\r\nstruct dentry *dentry = file->f_path.dentry;\r\nenum ovl_path_type type = ovl_path_type(dentry);\r\nif (cache && ovl_dentry_version_get(dentry) != cache->version) {\r\novl_cache_put(od, dentry);\r\nod->cache = NULL;\r\nod->cursor = NULL;\r\n}\r\nWARN_ON(!od->is_real && !OVL_TYPE_MERGE(type));\r\nif (od->is_real && OVL_TYPE_MERGE(type))\r\nod->is_real = false;\r\n}\r\nstatic int ovl_dir_read_merged(struct dentry *dentry, struct list_head *list)\r\n{\r\nint err;\r\nstruct path realpath;\r\nstruct ovl_readdir_data rdd = {\r\n.ctx.actor = ovl_fill_merge,\r\n.list = list,\r\n.root = RB_ROOT,\r\n.is_merge = false,\r\n};\r\nint idx, next;\r\nfor (idx = 0; idx != -1; idx = next) {\r\nnext = ovl_path_next(idx, dentry, &realpath);\r\nif (next != -1) {\r\nerr = ovl_dir_read(&realpath, &rdd);\r\nif (err)\r\nbreak;\r\n} else {\r\nlist_add(&rdd.middle, rdd.list);\r\nrdd.is_merge = true;\r\nerr = ovl_dir_read(&realpath, &rdd);\r\nlist_del(&rdd.middle);\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic void ovl_seek_cursor(struct ovl_dir_file *od, loff_t pos)\r\n{\r\nstruct list_head *p;\r\nloff_t off = 0;\r\nlist_for_each(p, &od->cache->entries) {\r\nif (off >= pos)\r\nbreak;\r\noff++;\r\n}\r\nod->cursor = p;\r\n}\r\nstatic struct ovl_dir_cache *ovl_cache_get(struct dentry *dentry)\r\n{\r\nint res;\r\nstruct ovl_dir_cache *cache;\r\ncache = ovl_dir_cache(dentry);\r\nif (cache && ovl_dentry_version_get(dentry) == cache->version) {\r\ncache->refcount++;\r\nreturn cache;\r\n}\r\novl_set_dir_cache(dentry, NULL);\r\ncache = kzalloc(sizeof(struct ovl_dir_cache), GFP_KERNEL);\r\nif (!cache)\r\nreturn ERR_PTR(-ENOMEM);\r\ncache->refcount = 1;\r\nINIT_LIST_HEAD(&cache->entries);\r\nres = ovl_dir_read_merged(dentry, &cache->entries);\r\nif (res) {\r\novl_cache_free(&cache->entries);\r\nkfree(cache);\r\nreturn ERR_PTR(res);\r\n}\r\ncache->version = ovl_dentry_version_get(dentry);\r\novl_set_dir_cache(dentry, cache);\r\nreturn cache;\r\n}\r\nstatic int ovl_iterate(struct file *file, struct dir_context *ctx)\r\n{\r\nstruct ovl_dir_file *od = file->private_data;\r\nstruct dentry *dentry = file->f_path.dentry;\r\nstruct ovl_cache_entry *p;\r\nif (!ctx->pos)\r\novl_dir_reset(file);\r\nif (od->is_real)\r\nreturn iterate_dir(od->realfile, ctx);\r\nif (!od->cache) {\r\nstruct ovl_dir_cache *cache;\r\ncache = ovl_cache_get(dentry);\r\nif (IS_ERR(cache))\r\nreturn PTR_ERR(cache);\r\nod->cache = cache;\r\novl_seek_cursor(od, ctx->pos);\r\n}\r\nwhile (od->cursor != &od->cache->entries) {\r\np = list_entry(od->cursor, struct ovl_cache_entry, l_node);\r\nif (!p->is_whiteout)\r\nif (!dir_emit(ctx, p->name, p->len, p->ino, p->type))\r\nbreak;\r\nod->cursor = p->l_node.next;\r\nctx->pos++;\r\n}\r\nreturn 0;\r\n}\r\nstatic loff_t ovl_dir_llseek(struct file *file, loff_t offset, int origin)\r\n{\r\nloff_t res;\r\nstruct ovl_dir_file *od = file->private_data;\r\nmutex_lock(&file_inode(file)->i_mutex);\r\nif (!file->f_pos)\r\novl_dir_reset(file);\r\nif (od->is_real) {\r\nres = vfs_llseek(od->realfile, offset, origin);\r\nfile->f_pos = od->realfile->f_pos;\r\n} else {\r\nres = -EINVAL;\r\nswitch (origin) {\r\ncase SEEK_CUR:\r\noffset += file->f_pos;\r\nbreak;\r\ncase SEEK_SET:\r\nbreak;\r\ndefault:\r\ngoto out_unlock;\r\n}\r\nif (offset < 0)\r\ngoto out_unlock;\r\nif (offset != file->f_pos) {\r\nfile->f_pos = offset;\r\nif (od->cache)\r\novl_seek_cursor(od, offset);\r\n}\r\nres = offset;\r\n}\r\nout_unlock:\r\nmutex_unlock(&file_inode(file)->i_mutex);\r\nreturn res;\r\n}\r\nstatic int ovl_dir_fsync(struct file *file, loff_t start, loff_t end,\r\nint datasync)\r\n{\r\nstruct ovl_dir_file *od = file->private_data;\r\nstruct dentry *dentry = file->f_path.dentry;\r\nstruct file *realfile = od->realfile;\r\nif (!od->is_upper && OVL_TYPE_UPPER(ovl_path_type(dentry))) {\r\nstruct inode *inode = file_inode(file);\r\nrealfile = lockless_dereference(od->upperfile);\r\nif (!realfile) {\r\nstruct path upperpath;\r\novl_path_upper(dentry, &upperpath);\r\nrealfile = ovl_path_open(&upperpath, O_RDONLY);\r\nsmp_mb__before_spinlock();\r\nmutex_lock(&inode->i_mutex);\r\nif (!od->upperfile) {\r\nif (IS_ERR(realfile)) {\r\nmutex_unlock(&inode->i_mutex);\r\nreturn PTR_ERR(realfile);\r\n}\r\nod->upperfile = realfile;\r\n} else {\r\nif (!IS_ERR(realfile))\r\nfput(realfile);\r\nrealfile = od->upperfile;\r\n}\r\nmutex_unlock(&inode->i_mutex);\r\n}\r\n}\r\nreturn vfs_fsync_range(realfile, start, end, datasync);\r\n}\r\nstatic int ovl_dir_release(struct inode *inode, struct file *file)\r\n{\r\nstruct ovl_dir_file *od = file->private_data;\r\nif (od->cache) {\r\nmutex_lock(&inode->i_mutex);\r\novl_cache_put(od, file->f_path.dentry);\r\nmutex_unlock(&inode->i_mutex);\r\n}\r\nfput(od->realfile);\r\nif (od->upperfile)\r\nfput(od->upperfile);\r\nkfree(od);\r\nreturn 0;\r\n}\r\nstatic int ovl_dir_open(struct inode *inode, struct file *file)\r\n{\r\nstruct path realpath;\r\nstruct file *realfile;\r\nstruct ovl_dir_file *od;\r\nenum ovl_path_type type;\r\nod = kzalloc(sizeof(struct ovl_dir_file), GFP_KERNEL);\r\nif (!od)\r\nreturn -ENOMEM;\r\ntype = ovl_path_real(file->f_path.dentry, &realpath);\r\nrealfile = ovl_path_open(&realpath, file->f_flags);\r\nif (IS_ERR(realfile)) {\r\nkfree(od);\r\nreturn PTR_ERR(realfile);\r\n}\r\nod->realfile = realfile;\r\nod->is_real = !OVL_TYPE_MERGE(type);\r\nod->is_upper = OVL_TYPE_UPPER(type);\r\nfile->private_data = od;\r\nreturn 0;\r\n}\r\nint ovl_check_empty_dir(struct dentry *dentry, struct list_head *list)\r\n{\r\nint err;\r\nstruct ovl_cache_entry *p;\r\nerr = ovl_dir_read_merged(dentry, list);\r\nif (err)\r\nreturn err;\r\nerr = 0;\r\nlist_for_each_entry(p, list, l_node) {\r\nif (p->is_whiteout)\r\ncontinue;\r\nif (p->name[0] == '.') {\r\nif (p->len == 1)\r\ncontinue;\r\nif (p->len == 2 && p->name[1] == '.')\r\ncontinue;\r\n}\r\nerr = -ENOTEMPTY;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nvoid ovl_cleanup_whiteouts(struct dentry *upper, struct list_head *list)\r\n{\r\nstruct ovl_cache_entry *p;\r\nmutex_lock_nested(&upper->d_inode->i_mutex, I_MUTEX_CHILD);\r\nlist_for_each_entry(p, list, l_node) {\r\nstruct dentry *dentry;\r\nif (!p->is_whiteout)\r\ncontinue;\r\ndentry = lookup_one_len(p->name, upper, p->len);\r\nif (IS_ERR(dentry)) {\r\npr_err("overlayfs: lookup '%s/%.*s' failed (%i)\n",\r\nupper->d_name.name, p->len, p->name,\r\n(int) PTR_ERR(dentry));\r\ncontinue;\r\n}\r\novl_cleanup(upper->d_inode, dentry);\r\ndput(dentry);\r\n}\r\nmutex_unlock(&upper->d_inode->i_mutex);\r\n}
