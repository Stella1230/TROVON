static int\r\nips_setup(char *ips_str)\r\n{\r\nint i;\r\nchar *key;\r\nchar *value;\r\nIPS_OPTION options[] = {\r\n{"noi2o", &ips_force_i2o, 0},\r\n{"nommap", &ips_force_memio, 0},\r\n{"ioctlsize", &ips_ioctlsize, IPS_IOCTL_SIZE},\r\n{"cdboot", &ips_cd_boot, 0},\r\n{"maxcmds", &MaxLiteCmds, 32},\r\n};\r\nwhile ((key = strsep(&ips_str, ",."))) {\r\nif (!*key)\r\ncontinue;\r\nvalue = strchr(key, ':');\r\nif (value)\r\n*value++ = '\0';\r\nfor (i = 0; i < ARRAY_SIZE(options); i++) {\r\nif (strncasecmp\r\n(key, options[i].option_name,\r\nstrlen(options[i].option_name)) == 0) {\r\nif (value)\r\n*options[i].option_flag =\r\nsimple_strtoul(value, NULL, 0);\r\nelse\r\n*options[i].option_flag =\r\noptions[i].option_value;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn (1);\r\n}\r\nstatic int\r\nips_detect(struct scsi_host_template * SHT)\r\n{\r\nint i;\r\nMETHOD_TRACE("ips_detect", 1);\r\n#ifdef MODULE\r\nif (ips)\r\nips_setup(ips);\r\n#endif\r\nfor (i = 0; i < ips_num_controllers; i++) {\r\nif (ips_register_scsi(i))\r\nips_free(ips_ha[i]);\r\nips_released_controllers++;\r\n}\r\nips_hotplug = 1;\r\nreturn (ips_num_controllers);\r\n}\r\nstatic void\r\nips_setup_funclist(ips_ha_t * ha)\r\n{\r\nif (IPS_IS_MORPHEUS(ha) || IPS_IS_MARCO(ha)) {\r\nha->func.isintr = ips_isintr_morpheus;\r\nha->func.isinit = ips_isinit_morpheus;\r\nha->func.issue = ips_issue_i2o_memio;\r\nha->func.init = ips_init_morpheus;\r\nha->func.statupd = ips_statupd_morpheus;\r\nha->func.reset = ips_reset_morpheus;\r\nha->func.intr = ips_intr_morpheus;\r\nha->func.enableint = ips_enable_int_morpheus;\r\n} else if (IPS_USE_MEMIO(ha)) {\r\nha->func.isintr = ips_isintr_copperhead_memio;\r\nha->func.isinit = ips_isinit_copperhead_memio;\r\nha->func.init = ips_init_copperhead_memio;\r\nha->func.statupd = ips_statupd_copperhead_memio;\r\nha->func.statinit = ips_statinit_memio;\r\nha->func.reset = ips_reset_copperhead_memio;\r\nha->func.intr = ips_intr_copperhead;\r\nha->func.erasebios = ips_erase_bios_memio;\r\nha->func.programbios = ips_program_bios_memio;\r\nha->func.verifybios = ips_verify_bios_memio;\r\nha->func.enableint = ips_enable_int_copperhead_memio;\r\nif (IPS_USE_I2O_DELIVER(ha))\r\nha->func.issue = ips_issue_i2o_memio;\r\nelse\r\nha->func.issue = ips_issue_copperhead_memio;\r\n} else {\r\nha->func.isintr = ips_isintr_copperhead;\r\nha->func.isinit = ips_isinit_copperhead;\r\nha->func.init = ips_init_copperhead;\r\nha->func.statupd = ips_statupd_copperhead;\r\nha->func.statinit = ips_statinit;\r\nha->func.reset = ips_reset_copperhead;\r\nha->func.intr = ips_intr_copperhead;\r\nha->func.erasebios = ips_erase_bios;\r\nha->func.programbios = ips_program_bios;\r\nha->func.verifybios = ips_verify_bios;\r\nha->func.enableint = ips_enable_int_copperhead;\r\nif (IPS_USE_I2O_DELIVER(ha))\r\nha->func.issue = ips_issue_i2o;\r\nelse\r\nha->func.issue = ips_issue_copperhead;\r\n}\r\n}\r\nstatic int\r\nips_release(struct Scsi_Host *sh)\r\n{\r\nips_scb_t *scb;\r\nips_ha_t *ha;\r\nint i;\r\nMETHOD_TRACE("ips_release", 1);\r\nscsi_remove_host(sh);\r\nfor (i = 0; i < IPS_MAX_ADAPTERS && ips_sh[i] != sh; i++) ;\r\nif (i == IPS_MAX_ADAPTERS) {\r\nprintk(KERN_WARNING\r\n"(%s) release, invalid Scsi_Host pointer.\n", ips_name);\r\nBUG();\r\nreturn (FALSE);\r\n}\r\nha = IPS_HA(sh);\r\nif (!ha)\r\nreturn (FALSE);\r\nscb = &ha->scbs[ha->max_cmds - 1];\r\nips_init_scb(ha, scb);\r\nscb->timeout = ips_cmd_timeout;\r\nscb->cdb[0] = IPS_CMD_FLUSH;\r\nscb->cmd.flush_cache.op_code = IPS_CMD_FLUSH;\r\nscb->cmd.flush_cache.command_id = IPS_COMMAND_ID(ha, scb);\r\nscb->cmd.flush_cache.state = IPS_NORM_STATE;\r\nscb->cmd.flush_cache.reserved = 0;\r\nscb->cmd.flush_cache.reserved2 = 0;\r\nscb->cmd.flush_cache.reserved3 = 0;\r\nscb->cmd.flush_cache.reserved4 = 0;\r\nIPS_PRINTK(KERN_WARNING, ha->pcidev, "Flushing Cache.\n");\r\nif (ips_send_wait(ha, scb, ips_cmd_timeout, IPS_INTR_ON) == IPS_FAILURE)\r\nIPS_PRINTK(KERN_WARNING, ha->pcidev, "Incomplete Flush.\n");\r\nIPS_PRINTK(KERN_WARNING, ha->pcidev, "Flushing Complete.\n");\r\nips_sh[i] = NULL;\r\nips_ha[i] = NULL;\r\nips_free(ha);\r\nfree_irq(ha->pcidev->irq, ha);\r\nscsi_host_put(sh);\r\nips_released_controllers++;\r\nreturn (FALSE);\r\n}\r\nstatic int\r\nips_halt(struct notifier_block *nb, ulong event, void *buf)\r\n{\r\nips_scb_t *scb;\r\nips_ha_t *ha;\r\nint i;\r\nif ((event != SYS_RESTART) && (event != SYS_HALT) &&\r\n(event != SYS_POWER_OFF))\r\nreturn (NOTIFY_DONE);\r\nfor (i = 0; i < ips_next_controller; i++) {\r\nha = (ips_ha_t *) ips_ha[i];\r\nif (!ha)\r\ncontinue;\r\nif (!ha->active)\r\ncontinue;\r\nscb = &ha->scbs[ha->max_cmds - 1];\r\nips_init_scb(ha, scb);\r\nscb->timeout = ips_cmd_timeout;\r\nscb->cdb[0] = IPS_CMD_FLUSH;\r\nscb->cmd.flush_cache.op_code = IPS_CMD_FLUSH;\r\nscb->cmd.flush_cache.command_id = IPS_COMMAND_ID(ha, scb);\r\nscb->cmd.flush_cache.state = IPS_NORM_STATE;\r\nscb->cmd.flush_cache.reserved = 0;\r\nscb->cmd.flush_cache.reserved2 = 0;\r\nscb->cmd.flush_cache.reserved3 = 0;\r\nscb->cmd.flush_cache.reserved4 = 0;\r\nIPS_PRINTK(KERN_WARNING, ha->pcidev, "Flushing Cache.\n");\r\nif (ips_send_wait(ha, scb, ips_cmd_timeout, IPS_INTR_ON) ==\r\nIPS_FAILURE)\r\nIPS_PRINTK(KERN_WARNING, ha->pcidev,\r\n"Incomplete Flush.\n");\r\nelse\r\nIPS_PRINTK(KERN_WARNING, ha->pcidev,\r\n"Flushing Complete.\n");\r\n}\r\nreturn (NOTIFY_OK);\r\n}\r\nint ips_eh_abort(struct scsi_cmnd *SC)\r\n{\r\nips_ha_t *ha;\r\nips_copp_wait_item_t *item;\r\nint ret;\r\nstruct Scsi_Host *host;\r\nMETHOD_TRACE("ips_eh_abort", 1);\r\nif (!SC)\r\nreturn (FAILED);\r\nhost = SC->device->host;\r\nha = (ips_ha_t *) SC->device->host->hostdata;\r\nif (!ha)\r\nreturn (FAILED);\r\nif (!ha->active)\r\nreturn (FAILED);\r\nspin_lock(host->host_lock);\r\nitem = ha->copp_waitlist.head;\r\nwhile ((item) && (item->scsi_cmd != SC))\r\nitem = item->next;\r\nif (item) {\r\nips_removeq_copp(&ha->copp_waitlist, item);\r\nret = (SUCCESS);\r\n} else if (ips_removeq_wait(&ha->scb_waitlist, SC)) {\r\nret = (SUCCESS);\r\n} else {\r\nret = (FAILED);\r\n}\r\nspin_unlock(host->host_lock);\r\nreturn ret;\r\n}\r\nstatic int __ips_eh_reset(struct scsi_cmnd *SC)\r\n{\r\nint ret;\r\nint i;\r\nips_ha_t *ha;\r\nips_scb_t *scb;\r\nips_copp_wait_item_t *item;\r\nMETHOD_TRACE("ips_eh_reset", 1);\r\n#ifdef NO_IPS_RESET\r\nreturn (FAILED);\r\n#else\r\nif (!SC) {\r\nDEBUG(1, "Reset called with NULL scsi command");\r\nreturn (FAILED);\r\n}\r\nha = (ips_ha_t *) SC->device->host->hostdata;\r\nif (!ha) {\r\nDEBUG(1, "Reset called with NULL ha struct");\r\nreturn (FAILED);\r\n}\r\nif (!ha->active)\r\nreturn (FAILED);\r\nitem = ha->copp_waitlist.head;\r\nwhile ((item) && (item->scsi_cmd != SC))\r\nitem = item->next;\r\nif (item) {\r\nips_removeq_copp(&ha->copp_waitlist, item);\r\nreturn (SUCCESS);\r\n}\r\nif (ips_removeq_wait(&ha->scb_waitlist, SC)) {\r\nreturn (SUCCESS);\r\n}\r\nif (ha->ioctl_reset == 0) {\r\nscb = &ha->scbs[ha->max_cmds - 1];\r\nips_init_scb(ha, scb);\r\nscb->timeout = ips_cmd_timeout;\r\nscb->cdb[0] = IPS_CMD_FLUSH;\r\nscb->cmd.flush_cache.op_code = IPS_CMD_FLUSH;\r\nscb->cmd.flush_cache.command_id = IPS_COMMAND_ID(ha, scb);\r\nscb->cmd.flush_cache.state = IPS_NORM_STATE;\r\nscb->cmd.flush_cache.reserved = 0;\r\nscb->cmd.flush_cache.reserved2 = 0;\r\nscb->cmd.flush_cache.reserved3 = 0;\r\nscb->cmd.flush_cache.reserved4 = 0;\r\nret = ips_send_wait(ha, scb, ips_cmd_timeout, IPS_INTR_IORL);\r\nif (ret == IPS_SUCCESS) {\r\nIPS_PRINTK(KERN_NOTICE, ha->pcidev,\r\n"Reset Request - Flushed Cache\n");\r\nreturn (SUCCESS);\r\n}\r\n}\r\nha->ioctl_reset = 0;\r\nIPS_PRINTK(KERN_NOTICE, ha->pcidev, "Resetting controller.\n");\r\nret = (*ha->func.reset) (ha);\r\nif (!ret) {\r\nstruct scsi_cmnd *scsi_cmd;\r\nIPS_PRINTK(KERN_NOTICE, ha->pcidev,\r\n"Controller reset failed - controller now offline.\n");\r\nDEBUG_VAR(1, "(%s%d) Failing active commands",\r\nips_name, ha->host_num);\r\nwhile ((scb = ips_removeq_scb_head(&ha->scb_activelist))) {\r\nscb->scsi_cmd->result = DID_ERROR << 16;\r\nscb->scsi_cmd->scsi_done(scb->scsi_cmd);\r\nips_freescb(ha, scb);\r\n}\r\nDEBUG_VAR(1, "(%s%d) Failing pending commands",\r\nips_name, ha->host_num);\r\nwhile ((scsi_cmd = ips_removeq_wait_head(&ha->scb_waitlist))) {\r\nscsi_cmd->result = DID_ERROR;\r\nscsi_cmd->scsi_done(scsi_cmd);\r\n}\r\nha->active = FALSE;\r\nreturn (FAILED);\r\n}\r\nif (!ips_clear_adapter(ha, IPS_INTR_IORL)) {\r\nstruct scsi_cmnd *scsi_cmd;\r\nIPS_PRINTK(KERN_NOTICE, ha->pcidev,\r\n"Controller reset failed - controller now offline.\n");\r\nDEBUG_VAR(1, "(%s%d) Failing active commands",\r\nips_name, ha->host_num);\r\nwhile ((scb = ips_removeq_scb_head(&ha->scb_activelist))) {\r\nscb->scsi_cmd->result = DID_ERROR << 16;\r\nscb->scsi_cmd->scsi_done(scb->scsi_cmd);\r\nips_freescb(ha, scb);\r\n}\r\nDEBUG_VAR(1, "(%s%d) Failing pending commands",\r\nips_name, ha->host_num);\r\nwhile ((scsi_cmd = ips_removeq_wait_head(&ha->scb_waitlist))) {\r\nscsi_cmd->result = DID_ERROR << 16;\r\nscsi_cmd->scsi_done(scsi_cmd);\r\n}\r\nha->active = FALSE;\r\nreturn (FAILED);\r\n}\r\nif (le32_to_cpu(ha->subsys->param[3]) & 0x300000) {\r\nstruct timeval tv;\r\ndo_gettimeofday(&tv);\r\nha->last_ffdc = tv.tv_sec;\r\nha->reset_count++;\r\nips_ffdc_reset(ha, IPS_INTR_IORL);\r\n}\r\nDEBUG_VAR(1, "(%s%d) Failing active commands", ips_name, ha->host_num);\r\nwhile ((scb = ips_removeq_scb_head(&ha->scb_activelist))) {\r\nscb->scsi_cmd->result = DID_RESET << 16;\r\nscb->scsi_cmd->scsi_done(scb->scsi_cmd);\r\nips_freescb(ha, scb);\r\n}\r\nfor (i = 1; i < ha->nbus; i++)\r\nha->dcdb_active[i - 1] = 0;\r\nha->num_ioctl = 0;\r\nips_next(ha, IPS_INTR_IORL);\r\nreturn (SUCCESS);\r\n#endif\r\n}\r\nstatic int ips_eh_reset(struct scsi_cmnd *SC)\r\n{\r\nint rc;\r\nspin_lock_irq(SC->device->host->host_lock);\r\nrc = __ips_eh_reset(SC);\r\nspin_unlock_irq(SC->device->host->host_lock);\r\nreturn rc;\r\n}\r\nstatic int ips_queue_lck(struct scsi_cmnd *SC, void (*done) (struct scsi_cmnd *))\r\n{\r\nips_ha_t *ha;\r\nips_passthru_t *pt;\r\nMETHOD_TRACE("ips_queue", 1);\r\nha = (ips_ha_t *) SC->device->host->hostdata;\r\nif (!ha)\r\nreturn (1);\r\nif (!ha->active)\r\nreturn (DID_ERROR);\r\nif (ips_is_passthru(SC)) {\r\nif (ha->copp_waitlist.count == IPS_MAX_IOCTL_QUEUE) {\r\nSC->result = DID_BUS_BUSY << 16;\r\ndone(SC);\r\nreturn (0);\r\n}\r\n} else if (ha->scb_waitlist.count == IPS_MAX_QUEUE) {\r\nSC->result = DID_BUS_BUSY << 16;\r\ndone(SC);\r\nreturn (0);\r\n}\r\nSC->scsi_done = done;\r\nDEBUG_VAR(2, "(%s%d): ips_queue: cmd 0x%X (%d %d %d)",\r\nips_name,\r\nha->host_num,\r\nSC->cmnd[0],\r\nSC->device->channel, SC->device->id, SC->device->lun);\r\nif ((scmd_channel(SC) > 0)\r\n&& (scmd_id(SC) == ha->ha_id[scmd_channel(SC)])) {\r\nSC->result = DID_NO_CONNECT << 16;\r\ndone(SC);\r\nreturn (0);\r\n}\r\nif (ips_is_passthru(SC)) {\r\nips_copp_wait_item_t *scratch;\r\npt = (ips_passthru_t *) scsi_sglist(SC);\r\nif ((pt->CoppCP.cmd.reset.op_code == IPS_CMD_RESET_CHANNEL) &&\r\n(pt->CoppCP.cmd.reset.adapter_flag == 1)) {\r\nif (ha->scb_activelist.count != 0) {\r\nSC->result = DID_BUS_BUSY << 16;\r\ndone(SC);\r\nreturn (0);\r\n}\r\nha->ioctl_reset = 1;\r\n__ips_eh_reset(SC);\r\nSC->result = DID_OK << 16;\r\nSC->scsi_done(SC);\r\nreturn (0);\r\n}\r\nscratch = kmalloc(sizeof (ips_copp_wait_item_t), GFP_ATOMIC);\r\nif (!scratch) {\r\nSC->result = DID_ERROR << 16;\r\ndone(SC);\r\nreturn (0);\r\n}\r\nscratch->scsi_cmd = SC;\r\nscratch->next = NULL;\r\nips_putq_copp_tail(&ha->copp_waitlist, scratch);\r\n} else {\r\nips_putq_wait_tail(&ha->scb_waitlist, SC);\r\n}\r\nips_next(ha, IPS_INTR_IORL);\r\nreturn (0);\r\n}\r\nint\r\nips_slave_configure(struct scsi_device * SDptr)\r\n{\r\nips_ha_t *ha;\r\nint min;\r\nha = IPS_HA(SDptr->host);\r\nif (SDptr->tagged_supported && SDptr->type == TYPE_DISK) {\r\nmin = ha->max_cmds / 2;\r\nif (ha->enq->ucLogDriveCount <= 2)\r\nmin = ha->max_cmds - 1;\r\nscsi_change_queue_depth(SDptr, min);\r\n}\r\nSDptr->skip_ms_page_8 = 1;\r\nSDptr->skip_ms_page_3f = 1;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t\r\ndo_ipsintr(int irq, void *dev_id)\r\n{\r\nips_ha_t *ha;\r\nstruct Scsi_Host *host;\r\nint irqstatus;\r\nMETHOD_TRACE("do_ipsintr", 2);\r\nha = (ips_ha_t *) dev_id;\r\nif (!ha)\r\nreturn IRQ_NONE;\r\nhost = ips_sh[ha->host_num];\r\nif (!host) {\r\n(*ha->func.intr) (ha);\r\nreturn IRQ_HANDLED;\r\n}\r\nspin_lock(host->host_lock);\r\nif (!ha->active) {\r\nspin_unlock(host->host_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nirqstatus = (*ha->func.intr) (ha);\r\nspin_unlock(host->host_lock);\r\nips_next(ha, IPS_INTR_ON);\r\nreturn IRQ_RETVAL(irqstatus);\r\n}\r\nint\r\nips_intr_copperhead(ips_ha_t * ha)\r\n{\r\nips_stat_t *sp;\r\nips_scb_t *scb;\r\nIPS_STATUS cstatus;\r\nint intrstatus;\r\nMETHOD_TRACE("ips_intr", 2);\r\nif (!ha)\r\nreturn 0;\r\nif (!ha->active)\r\nreturn 0;\r\nintrstatus = (*ha->func.isintr) (ha);\r\nif (!intrstatus) {\r\nreturn 0;\r\n}\r\nwhile (TRUE) {\r\nsp = &ha->sp;\r\nintrstatus = (*ha->func.isintr) (ha);\r\nif (!intrstatus)\r\nbreak;\r\nelse\r\ncstatus.value = (*ha->func.statupd) (ha);\r\nif (cstatus.fields.command_id > (IPS_MAX_CMDS - 1)) {\r\ncontinue;\r\n}\r\nips_chkstatus(ha, &cstatus);\r\nscb = (ips_scb_t *) sp->scb_addr;\r\n(*scb->callback) (ha, scb);\r\n}\r\nreturn 1;\r\n}\r\nint\r\nips_intr_morpheus(ips_ha_t * ha)\r\n{\r\nips_stat_t *sp;\r\nips_scb_t *scb;\r\nIPS_STATUS cstatus;\r\nint intrstatus;\r\nMETHOD_TRACE("ips_intr_morpheus", 2);\r\nif (!ha)\r\nreturn 0;\r\nif (!ha->active)\r\nreturn 0;\r\nintrstatus = (*ha->func.isintr) (ha);\r\nif (!intrstatus) {\r\nreturn 0;\r\n}\r\nwhile (TRUE) {\r\nsp = &ha->sp;\r\nintrstatus = (*ha->func.isintr) (ha);\r\nif (!intrstatus)\r\nbreak;\r\nelse\r\ncstatus.value = (*ha->func.statupd) (ha);\r\nif (cstatus.value == 0xffffffff)\r\nbreak;\r\nif (cstatus.fields.command_id > (IPS_MAX_CMDS - 1)) {\r\nIPS_PRINTK(KERN_WARNING, ha->pcidev,\r\n"Spurious interrupt; no ccb.\n");\r\ncontinue;\r\n}\r\nips_chkstatus(ha, &cstatus);\r\nscb = (ips_scb_t *) sp->scb_addr;\r\n(*scb->callback) (ha, scb);\r\n}\r\nreturn 1;\r\n}\r\nstatic const char *\r\nips_info(struct Scsi_Host *SH)\r\n{\r\nstatic char buffer[256];\r\nchar *bp;\r\nips_ha_t *ha;\r\nMETHOD_TRACE("ips_info", 1);\r\nha = IPS_HA(SH);\r\nif (!ha)\r\nreturn (NULL);\r\nbp = &buffer[0];\r\nmemset(bp, 0, sizeof (buffer));\r\nsprintf(bp, "%s%s%s Build %d", "IBM PCI ServeRAID ",\r\nIPS_VERSION_HIGH, IPS_VERSION_LOW, IPS_BUILD_IDENT);\r\nif (ha->ad_type > 0 && ha->ad_type <= MAX_ADAPTER_NAME) {\r\nstrcat(bp, " <");\r\nstrcat(bp, ips_adapter_name[ha->ad_type - 1]);\r\nstrcat(bp, ">");\r\n}\r\nreturn (bp);\r\n}\r\nstatic int\r\nips_write_info(struct Scsi_Host *host, char *buffer, int length)\r\n{\r\nint i;\r\nips_ha_t *ha = NULL;\r\nfor (i = 0; i < ips_next_controller; i++) {\r\nif (ips_sh[i]) {\r\nif (ips_sh[i] == host) {\r\nha = (ips_ha_t *) ips_sh[i]->hostdata;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!ha)\r\nreturn (-EINVAL);\r\nreturn 0;\r\n}\r\nstatic int\r\nips_show_info(struct seq_file *m, struct Scsi_Host *host)\r\n{\r\nint i;\r\nips_ha_t *ha = NULL;\r\nfor (i = 0; i < ips_next_controller; i++) {\r\nif (ips_sh[i]) {\r\nif (ips_sh[i] == host) {\r\nha = (ips_ha_t *) ips_sh[i]->hostdata;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!ha)\r\nreturn (-EINVAL);\r\nreturn ips_host_info(ha, m);\r\n}\r\nstatic int ips_is_passthru(struct scsi_cmnd *SC)\r\n{\r\nunsigned long flags;\r\nMETHOD_TRACE("ips_is_passthru", 1);\r\nif (!SC)\r\nreturn (0);\r\nif ((SC->cmnd[0] == IPS_IOCTL_COMMAND) &&\r\n(SC->device->channel == 0) &&\r\n(SC->device->id == IPS_ADAPTER_ID) &&\r\n(SC->device->lun == 0) && scsi_sglist(SC)) {\r\nstruct scatterlist *sg = scsi_sglist(SC);\r\nchar *buffer;\r\nlocal_irq_save(flags);\r\nbuffer = kmap_atomic(sg_page(sg)) + sg->offset;\r\nif (buffer && buffer[0] == 'C' && buffer[1] == 'O' &&\r\nbuffer[2] == 'P' && buffer[3] == 'P') {\r\nkunmap_atomic(buffer - sg->offset);\r\nlocal_irq_restore(flags);\r\nreturn 1;\r\n}\r\nkunmap_atomic(buffer - sg->offset);\r\nlocal_irq_restore(flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nips_alloc_passthru_buffer(ips_ha_t * ha, int length)\r\n{\r\nvoid *bigger_buf;\r\ndma_addr_t dma_busaddr;\r\nif (ha->ioctl_data && length <= ha->ioctl_len)\r\nreturn 0;\r\nbigger_buf = pci_alloc_consistent(ha->pcidev, length, &dma_busaddr);\r\nif (bigger_buf) {\r\npci_free_consistent(ha->pcidev, ha->ioctl_len, ha->ioctl_data,\r\nha->ioctl_busaddr);\r\nha->ioctl_data = (char *) bigger_buf;\r\nha->ioctl_len = length;\r\nha->ioctl_busaddr = dma_busaddr;\r\n} else {\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nips_make_passthru(ips_ha_t *ha, struct scsi_cmnd *SC, ips_scb_t *scb, int intr)\r\n{\r\nips_passthru_t *pt;\r\nint length = 0;\r\nint i, ret;\r\nstruct scatterlist *sg = scsi_sglist(SC);\r\nMETHOD_TRACE("ips_make_passthru", 1);\r\nscsi_for_each_sg(SC, sg, scsi_sg_count(SC), i)\r\nlength += sg->length;\r\nif (length < sizeof (ips_passthru_t)) {\r\nDEBUG_VAR(1, "(%s%d) Passthru structure wrong size",\r\nips_name, ha->host_num);\r\nreturn (IPS_FAILURE);\r\n}\r\nif (ips_alloc_passthru_buffer(ha, length)) {\r\nif (ha->ioctl_data) {\r\npt = (ips_passthru_t *) ha->ioctl_data;\r\nips_scmd_buf_read(SC, pt, sizeof (ips_passthru_t));\r\npt->BasicStatus = 0x0B;\r\npt->ExtendedStatus = 0x00;\r\nips_scmd_buf_write(SC, pt, sizeof (ips_passthru_t));\r\n}\r\nreturn IPS_FAILURE;\r\n}\r\nha->ioctl_datasize = length;\r\nips_scmd_buf_read(SC, ha->ioctl_data, ha->ioctl_datasize);\r\npt = (ips_passthru_t *) ha->ioctl_data;\r\nswitch (pt->CoppCmd) {\r\ncase IPS_NUMCTRLS:\r\nmemcpy(ha->ioctl_data + sizeof (ips_passthru_t),\r\n&ips_num_controllers, sizeof (int));\r\nips_scmd_buf_write(SC, ha->ioctl_data,\r\nsizeof (ips_passthru_t) + sizeof (int));\r\nSC->result = DID_OK << 16;\r\nreturn (IPS_SUCCESS_IMM);\r\ncase IPS_COPPUSRCMD:\r\ncase IPS_COPPIOCCMD:\r\nif (SC->cmnd[0] == IPS_IOCTL_COMMAND) {\r\nif (length < (sizeof (ips_passthru_t) + pt->CmdBSize)) {\r\nDEBUG_VAR(1,\r\n"(%s%d) Passthru structure wrong size",\r\nips_name, ha->host_num);\r\nreturn (IPS_FAILURE);\r\n}\r\nif (ha->pcidev->device == IPS_DEVICEID_COPPERHEAD &&\r\npt->CoppCP.cmd.flashfw.op_code ==\r\nIPS_CMD_RW_BIOSFW) {\r\nret = ips_flash_copperhead(ha, pt, scb);\r\nips_scmd_buf_write(SC, ha->ioctl_data,\r\nsizeof (ips_passthru_t));\r\nreturn ret;\r\n}\r\nif (ips_usrcmd(ha, pt, scb))\r\nreturn (IPS_SUCCESS);\r\nelse\r\nreturn (IPS_FAILURE);\r\n}\r\nbreak;\r\n}\r\nreturn (IPS_FAILURE);\r\n}\r\nstatic int\r\nips_flash_copperhead(ips_ha_t * ha, ips_passthru_t * pt, ips_scb_t * scb)\r\n{\r\nint datasize;\r\nif (IPS_IS_TROMBONE(ha) && pt->CoppCP.cmd.flashfw.type == IPS_FW_IMAGE) {\r\nif (ips_usrcmd(ha, pt, scb))\r\nreturn IPS_SUCCESS;\r\nelse\r\nreturn IPS_FAILURE;\r\n}\r\npt->BasicStatus = 0x0B;\r\npt->ExtendedStatus = 0;\r\nscb->scsi_cmd->result = DID_OK << 16;\r\nif (pt->CoppCP.cmd.flashfw.type == IPS_BIOS_IMAGE &&\r\npt->CoppCP.cmd.flashfw.direction == IPS_ERASE_BIOS) {\r\npt->BasicStatus = 0;\r\nreturn ips_flash_bios(ha, pt, scb);\r\n} else if (pt->CoppCP.cmd.flashfw.packet_num == 0) {\r\nif (ips_FlashData && !test_and_set_bit(0, &ips_FlashDataInUse)){\r\nha->flash_data = ips_FlashData;\r\nha->flash_busaddr = ips_flashbusaddr;\r\nha->flash_len = PAGE_SIZE << 7;\r\nha->flash_datasize = 0;\r\n} else if (!ha->flash_data) {\r\ndatasize = pt->CoppCP.cmd.flashfw.total_packets *\r\npt->CoppCP.cmd.flashfw.count;\r\nha->flash_data = pci_alloc_consistent(ha->pcidev,\r\ndatasize,\r\n&ha->flash_busaddr);\r\nif (!ha->flash_data){\r\nprintk(KERN_WARNING "Unable to allocate a flash buffer\n");\r\nreturn IPS_FAILURE;\r\n}\r\nha->flash_datasize = 0;\r\nha->flash_len = datasize;\r\n} else\r\nreturn IPS_FAILURE;\r\n} else {\r\nif (pt->CoppCP.cmd.flashfw.count + ha->flash_datasize >\r\nha->flash_len) {\r\nips_free_flash_copperhead(ha);\r\nIPS_PRINTK(KERN_WARNING, ha->pcidev,\r\n"failed size sanity check\n");\r\nreturn IPS_FAILURE;\r\n}\r\n}\r\nif (!ha->flash_data)\r\nreturn IPS_FAILURE;\r\npt->BasicStatus = 0;\r\nmemcpy(&ha->flash_data[ha->flash_datasize], pt + 1,\r\npt->CoppCP.cmd.flashfw.count);\r\nha->flash_datasize += pt->CoppCP.cmd.flashfw.count;\r\nif (pt->CoppCP.cmd.flashfw.packet_num ==\r\npt->CoppCP.cmd.flashfw.total_packets - 1) {\r\nif (pt->CoppCP.cmd.flashfw.type == IPS_BIOS_IMAGE)\r\nreturn ips_flash_bios(ha, pt, scb);\r\nelse if (pt->CoppCP.cmd.flashfw.type == IPS_FW_IMAGE)\r\nreturn ips_flash_firmware(ha, pt, scb);\r\n}\r\nreturn IPS_SUCCESS_IMM;\r\n}\r\nstatic int\r\nips_flash_bios(ips_ha_t * ha, ips_passthru_t * pt, ips_scb_t * scb)\r\n{\r\nif (pt->CoppCP.cmd.flashfw.type == IPS_BIOS_IMAGE &&\r\npt->CoppCP.cmd.flashfw.direction == IPS_WRITE_BIOS) {\r\nif ((!ha->func.programbios) || (!ha->func.erasebios) ||\r\n(!ha->func.verifybios))\r\ngoto error;\r\nif ((*ha->func.erasebios) (ha)) {\r\nDEBUG_VAR(1,\r\n"(%s%d) flash bios failed - unable to erase flash",\r\nips_name, ha->host_num);\r\ngoto error;\r\n} else\r\nif ((*ha->func.programbios) (ha,\r\nha->flash_data +\r\nIPS_BIOS_HEADER,\r\nha->flash_datasize -\r\nIPS_BIOS_HEADER, 0)) {\r\nDEBUG_VAR(1,\r\n"(%s%d) flash bios failed - unable to flash",\r\nips_name, ha->host_num);\r\ngoto error;\r\n} else\r\nif ((*ha->func.verifybios) (ha,\r\nha->flash_data +\r\nIPS_BIOS_HEADER,\r\nha->flash_datasize -\r\nIPS_BIOS_HEADER, 0)) {\r\nDEBUG_VAR(1,\r\n"(%s%d) flash bios failed - unable to verify flash",\r\nips_name, ha->host_num);\r\ngoto error;\r\n}\r\nips_free_flash_copperhead(ha);\r\nreturn IPS_SUCCESS_IMM;\r\n} else if (pt->CoppCP.cmd.flashfw.type == IPS_BIOS_IMAGE &&\r\npt->CoppCP.cmd.flashfw.direction == IPS_ERASE_BIOS) {\r\nif (!ha->func.erasebios)\r\ngoto error;\r\nif ((*ha->func.erasebios) (ha)) {\r\nDEBUG_VAR(1,\r\n"(%s%d) flash bios failed - unable to erase flash",\r\nips_name, ha->host_num);\r\ngoto error;\r\n}\r\nreturn IPS_SUCCESS_IMM;\r\n}\r\nerror:\r\npt->BasicStatus = 0x0B;\r\npt->ExtendedStatus = 0x00;\r\nips_free_flash_copperhead(ha);\r\nreturn IPS_FAILURE;\r\n}\r\nstatic int\r\nips_fill_scb_sg_single(ips_ha_t * ha, dma_addr_t busaddr,\r\nips_scb_t * scb, int indx, unsigned int e_len)\r\n{\r\nint ret_val = 0;\r\nif ((scb->data_len + e_len) > ha->max_xfer) {\r\ne_len = ha->max_xfer - scb->data_len;\r\nscb->breakup = indx;\r\n++scb->sg_break;\r\nret_val = -1;\r\n} else {\r\nscb->breakup = 0;\r\nscb->sg_break = 0;\r\n}\r\nif (IPS_USE_ENH_SGLIST(ha)) {\r\nscb->sg_list.enh_list[indx].address_lo =\r\ncpu_to_le32(pci_dma_lo32(busaddr));\r\nscb->sg_list.enh_list[indx].address_hi =\r\ncpu_to_le32(pci_dma_hi32(busaddr));\r\nscb->sg_list.enh_list[indx].length = cpu_to_le32(e_len);\r\n} else {\r\nscb->sg_list.std_list[indx].address =\r\ncpu_to_le32(pci_dma_lo32(busaddr));\r\nscb->sg_list.std_list[indx].length = cpu_to_le32(e_len);\r\n}\r\n++scb->sg_len;\r\nscb->data_len += e_len;\r\nreturn ret_val;\r\n}\r\nstatic int\r\nips_flash_firmware(ips_ha_t * ha, ips_passthru_t * pt, ips_scb_t * scb)\r\n{\r\nIPS_SG_LIST sg_list;\r\nuint32_t cmd_busaddr;\r\nif (pt->CoppCP.cmd.flashfw.type == IPS_FW_IMAGE &&\r\npt->CoppCP.cmd.flashfw.direction == IPS_WRITE_FW) {\r\nmemset(&pt->CoppCP.cmd, 0, sizeof (IPS_HOST_COMMAND));\r\npt->CoppCP.cmd.flashfw.op_code = IPS_CMD_DOWNLOAD;\r\npt->CoppCP.cmd.flashfw.count = cpu_to_le32(ha->flash_datasize);\r\n} else {\r\npt->BasicStatus = 0x0B;\r\npt->ExtendedStatus = 0x00;\r\nips_free_flash_copperhead(ha);\r\nreturn IPS_FAILURE;\r\n}\r\nsg_list.list = scb->sg_list.list;\r\ncmd_busaddr = scb->scb_busaddr;\r\nmemcpy(&scb->cmd, &pt->CoppCP.cmd, sizeof (IPS_IOCTL_CMD));\r\nscb->sg_list.list = sg_list.list;\r\nscb->scb_busaddr = cmd_busaddr;\r\nscb->bus = scb->scsi_cmd->device->channel;\r\nscb->target_id = scb->scsi_cmd->device->id;\r\nscb->lun = scb->scsi_cmd->device->lun;\r\nscb->sg_len = 0;\r\nscb->data_len = 0;\r\nscb->flags = 0;\r\nscb->op_code = 0;\r\nscb->callback = ipsintr_done;\r\nscb->timeout = ips_cmd_timeout;\r\nscb->data_len = ha->flash_datasize;\r\nscb->data_busaddr =\r\npci_map_single(ha->pcidev, ha->flash_data, scb->data_len,\r\nIPS_DMA_DIR(scb));\r\nscb->flags |= IPS_SCB_MAP_SINGLE;\r\nscb->cmd.flashfw.command_id = IPS_COMMAND_ID(ha, scb);\r\nscb->cmd.flashfw.buffer_addr = cpu_to_le32(scb->data_busaddr);\r\nif (pt->TimeOut)\r\nscb->timeout = pt->TimeOut;\r\nscb->scsi_cmd->result = DID_OK << 16;\r\nreturn IPS_SUCCESS;\r\n}\r\nstatic void\r\nips_free_flash_copperhead(ips_ha_t * ha)\r\n{\r\nif (ha->flash_data == ips_FlashData)\r\ntest_and_clear_bit(0, &ips_FlashDataInUse);\r\nelse if (ha->flash_data)\r\npci_free_consistent(ha->pcidev, ha->flash_len, ha->flash_data,\r\nha->flash_busaddr);\r\nha->flash_data = NULL;\r\n}\r\nstatic int\r\nips_usrcmd(ips_ha_t * ha, ips_passthru_t * pt, ips_scb_t * scb)\r\n{\r\nIPS_SG_LIST sg_list;\r\nuint32_t cmd_busaddr;\r\nMETHOD_TRACE("ips_usrcmd", 1);\r\nif ((!scb) || (!pt) || (!ha))\r\nreturn (0);\r\nsg_list.list = scb->sg_list.list;\r\ncmd_busaddr = scb->scb_busaddr;\r\nmemcpy(&scb->cmd, &pt->CoppCP.cmd, sizeof (IPS_IOCTL_CMD));\r\nmemcpy(&scb->dcdb, &pt->CoppCP.dcdb, sizeof (IPS_DCDB_TABLE));\r\nscb->sg_list.list = sg_list.list;\r\nscb->scb_busaddr = cmd_busaddr;\r\nscb->bus = scb->scsi_cmd->device->channel;\r\nscb->target_id = scb->scsi_cmd->device->id;\r\nscb->lun = scb->scsi_cmd->device->lun;\r\nscb->sg_len = 0;\r\nscb->data_len = 0;\r\nscb->flags = 0;\r\nscb->op_code = 0;\r\nscb->callback = ipsintr_done;\r\nscb->timeout = ips_cmd_timeout;\r\nscb->cmd.basic_io.command_id = IPS_COMMAND_ID(ha, scb);\r\nif ((scb->cmd.basic_io.op_code == IPS_CMD_READ_SG) ||\r\n(scb->cmd.basic_io.op_code == IPS_CMD_WRITE_SG) ||\r\n(scb->cmd.basic_io.op_code == IPS_CMD_DCDB_SG))\r\nreturn (0);\r\nif (pt->CmdBSize) {\r\nscb->data_len = pt->CmdBSize;\r\nscb->data_busaddr = ha->ioctl_busaddr + sizeof (ips_passthru_t);\r\n} else {\r\nscb->data_busaddr = 0L;\r\n}\r\nif (scb->cmd.dcdb.op_code == IPS_CMD_DCDB)\r\nscb->cmd.dcdb.dcdb_address = cpu_to_le32(scb->scb_busaddr +\r\n(unsigned long) &scb->\r\ndcdb -\r\n(unsigned long) scb);\r\nif (pt->CmdBSize) {\r\nif (scb->cmd.dcdb.op_code == IPS_CMD_DCDB)\r\nscb->dcdb.buffer_pointer =\r\ncpu_to_le32(scb->data_busaddr);\r\nelse\r\nscb->cmd.basic_io.sg_addr =\r\ncpu_to_le32(scb->data_busaddr);\r\n}\r\nif (pt->TimeOut) {\r\nscb->timeout = pt->TimeOut;\r\nif (pt->TimeOut <= 10)\r\nscb->dcdb.cmd_attribute |= IPS_TIMEOUT10;\r\nelse if (pt->TimeOut <= 60)\r\nscb->dcdb.cmd_attribute |= IPS_TIMEOUT60;\r\nelse\r\nscb->dcdb.cmd_attribute |= IPS_TIMEOUT20M;\r\n}\r\nscb->scsi_cmd->result = DID_OK << 16;\r\nreturn (1);\r\n}\r\nstatic void\r\nips_cleanup_passthru(ips_ha_t * ha, ips_scb_t * scb)\r\n{\r\nips_passthru_t *pt;\r\nMETHOD_TRACE("ips_cleanup_passthru", 1);\r\nif ((!scb) || (!scb->scsi_cmd) || (!scsi_sglist(scb->scsi_cmd))) {\r\nDEBUG_VAR(1, "(%s%d) couldn't cleanup after passthru",\r\nips_name, ha->host_num);\r\nreturn;\r\n}\r\npt = (ips_passthru_t *) ha->ioctl_data;\r\nif (scb->cmd.dcdb.op_code == IPS_CMD_DCDB)\r\nmemcpy(&pt->CoppCP.dcdb, &scb->dcdb, sizeof (IPS_DCDB_TABLE));\r\npt->BasicStatus = scb->basic_status;\r\npt->ExtendedStatus = scb->extended_status;\r\npt->AdapterType = ha->ad_type;\r\nif (ha->pcidev->device == IPS_DEVICEID_COPPERHEAD &&\r\n(scb->cmd.flashfw.op_code == IPS_CMD_DOWNLOAD ||\r\nscb->cmd.flashfw.op_code == IPS_CMD_RW_BIOSFW))\r\nips_free_flash_copperhead(ha);\r\nips_scmd_buf_write(scb->scsi_cmd, ha->ioctl_data, ha->ioctl_datasize);\r\n}\r\nstatic int\r\nips_host_info(ips_ha_t *ha, struct seq_file *m)\r\n{\r\nMETHOD_TRACE("ips_host_info", 1);\r\nseq_puts(m, "\nIBM ServeRAID General Information:\n\n");\r\nif ((le32_to_cpu(ha->nvram->signature) == IPS_NVRAM_P5_SIG) &&\r\n(le16_to_cpu(ha->nvram->adapter_type) != 0))\r\nseq_printf(m, "\tController Type : %s\n",\r\nips_adapter_name[ha->ad_type - 1]);\r\nelse\r\nseq_puts(m, "\tController Type : Unknown\n");\r\nif (ha->io_addr)\r\nseq_printf(m,\r\n"\tIO region : 0x%x (%d bytes)\n",\r\nha->io_addr, ha->io_len);\r\nif (ha->mem_addr) {\r\nseq_printf(m,\r\n"\tMemory region : 0x%x (%d bytes)\n",\r\nha->mem_addr, ha->mem_len);\r\nseq_printf(m,\r\n"\tShared memory address : 0x%lx\n",\r\n(unsigned long)ha->mem_ptr);\r\n}\r\nseq_printf(m, "\tIRQ number : %d\n", ha->pcidev->irq);\r\nif (le32_to_cpu(ha->nvram->signature) == IPS_NVRAM_P5_SIG) {\r\nif (ha->nvram->bios_low[3] == 0) {\r\nseq_printf(m,\r\n"\tBIOS Version : %c%c%c%c%c%c%c\n",\r\nha->nvram->bios_high[0], ha->nvram->bios_high[1],\r\nha->nvram->bios_high[2], ha->nvram->bios_high[3],\r\nha->nvram->bios_low[0], ha->nvram->bios_low[1],\r\nha->nvram->bios_low[2]);\r\n} else {\r\nseq_printf(m,\r\n"\tBIOS Version : %c%c%c%c%c%c%c%c\n",\r\nha->nvram->bios_high[0], ha->nvram->bios_high[1],\r\nha->nvram->bios_high[2], ha->nvram->bios_high[3],\r\nha->nvram->bios_low[0], ha->nvram->bios_low[1],\r\nha->nvram->bios_low[2], ha->nvram->bios_low[3]);\r\n}\r\n}\r\nif (ha->enq->CodeBlkVersion[7] == 0) {\r\nseq_printf(m,\r\n"\tFirmware Version : %c%c%c%c%c%c%c\n",\r\nha->enq->CodeBlkVersion[0], ha->enq->CodeBlkVersion[1],\r\nha->enq->CodeBlkVersion[2], ha->enq->CodeBlkVersion[3],\r\nha->enq->CodeBlkVersion[4], ha->enq->CodeBlkVersion[5],\r\nha->enq->CodeBlkVersion[6]);\r\n} else {\r\nseq_printf(m,\r\n"\tFirmware Version : %c%c%c%c%c%c%c%c\n",\r\nha->enq->CodeBlkVersion[0], ha->enq->CodeBlkVersion[1],\r\nha->enq->CodeBlkVersion[2], ha->enq->CodeBlkVersion[3],\r\nha->enq->CodeBlkVersion[4], ha->enq->CodeBlkVersion[5],\r\nha->enq->CodeBlkVersion[6], ha->enq->CodeBlkVersion[7]);\r\n}\r\nif (ha->enq->BootBlkVersion[7] == 0) {\r\nseq_printf(m,\r\n"\tBoot Block Version : %c%c%c%c%c%c%c\n",\r\nha->enq->BootBlkVersion[0], ha->enq->BootBlkVersion[1],\r\nha->enq->BootBlkVersion[2], ha->enq->BootBlkVersion[3],\r\nha->enq->BootBlkVersion[4], ha->enq->BootBlkVersion[5],\r\nha->enq->BootBlkVersion[6]);\r\n} else {\r\nseq_printf(m,\r\n"\tBoot Block Version : %c%c%c%c%c%c%c%c\n",\r\nha->enq->BootBlkVersion[0], ha->enq->BootBlkVersion[1],\r\nha->enq->BootBlkVersion[2], ha->enq->BootBlkVersion[3],\r\nha->enq->BootBlkVersion[4], ha->enq->BootBlkVersion[5],\r\nha->enq->BootBlkVersion[6], ha->enq->BootBlkVersion[7]);\r\n}\r\nseq_printf(m, "\tDriver Version : %s%s\n",\r\nIPS_VERSION_HIGH, IPS_VERSION_LOW);\r\nseq_printf(m, "\tDriver Build : %d\n",\r\nIPS_BUILD_IDENT);\r\nseq_printf(m, "\tMax Physical Devices : %d\n",\r\nha->enq->ucMaxPhysicalDevices);\r\nseq_printf(m, "\tMax Active Commands : %d\n",\r\nha->max_cmds);\r\nseq_printf(m, "\tCurrent Queued Commands : %d\n",\r\nha->scb_waitlist.count);\r\nseq_printf(m, "\tCurrent Active Commands : %d\n",\r\nha->scb_activelist.count - ha->num_ioctl);\r\nseq_printf(m, "\tCurrent Queued PT Commands : %d\n",\r\nha->copp_waitlist.count);\r\nseq_printf(m, "\tCurrent Active PT Commands : %d\n",\r\nha->num_ioctl);\r\nseq_putc(m, '\n');\r\nreturn 0;\r\n}\r\nstatic void\r\nips_identify_controller(ips_ha_t * ha)\r\n{\r\nMETHOD_TRACE("ips_identify_controller", 1);\r\nswitch (ha->pcidev->device) {\r\ncase IPS_DEVICEID_COPPERHEAD:\r\nif (ha->pcidev->revision <= IPS_REVID_SERVERAID) {\r\nha->ad_type = IPS_ADTYPE_SERVERAID;\r\n} else if (ha->pcidev->revision == IPS_REVID_SERVERAID2) {\r\nha->ad_type = IPS_ADTYPE_SERVERAID2;\r\n} else if (ha->pcidev->revision == IPS_REVID_NAVAJO) {\r\nha->ad_type = IPS_ADTYPE_NAVAJO;\r\n} else if ((ha->pcidev->revision == IPS_REVID_SERVERAID2)\r\n&& (ha->slot_num == 0)) {\r\nha->ad_type = IPS_ADTYPE_KIOWA;\r\n} else if ((ha->pcidev->revision >= IPS_REVID_CLARINETP1) &&\r\n(ha->pcidev->revision <= IPS_REVID_CLARINETP3)) {\r\nif (ha->enq->ucMaxPhysicalDevices == 15)\r\nha->ad_type = IPS_ADTYPE_SERVERAID3L;\r\nelse\r\nha->ad_type = IPS_ADTYPE_SERVERAID3;\r\n} else if ((ha->pcidev->revision >= IPS_REVID_TROMBONE32) &&\r\n(ha->pcidev->revision <= IPS_REVID_TROMBONE64)) {\r\nha->ad_type = IPS_ADTYPE_SERVERAID4H;\r\n}\r\nbreak;\r\ncase IPS_DEVICEID_MORPHEUS:\r\nswitch (ha->pcidev->subsystem_device) {\r\ncase IPS_SUBDEVICEID_4L:\r\nha->ad_type = IPS_ADTYPE_SERVERAID4L;\r\nbreak;\r\ncase IPS_SUBDEVICEID_4M:\r\nha->ad_type = IPS_ADTYPE_SERVERAID4M;\r\nbreak;\r\ncase IPS_SUBDEVICEID_4MX:\r\nha->ad_type = IPS_ADTYPE_SERVERAID4MX;\r\nbreak;\r\ncase IPS_SUBDEVICEID_4LX:\r\nha->ad_type = IPS_ADTYPE_SERVERAID4LX;\r\nbreak;\r\ncase IPS_SUBDEVICEID_5I2:\r\nha->ad_type = IPS_ADTYPE_SERVERAID5I2;\r\nbreak;\r\ncase IPS_SUBDEVICEID_5I1:\r\nha->ad_type = IPS_ADTYPE_SERVERAID5I1;\r\nbreak;\r\n}\r\nbreak;\r\ncase IPS_DEVICEID_MARCO:\r\nswitch (ha->pcidev->subsystem_device) {\r\ncase IPS_SUBDEVICEID_6M:\r\nha->ad_type = IPS_ADTYPE_SERVERAID6M;\r\nbreak;\r\ncase IPS_SUBDEVICEID_6I:\r\nha->ad_type = IPS_ADTYPE_SERVERAID6I;\r\nbreak;\r\ncase IPS_SUBDEVICEID_7k:\r\nha->ad_type = IPS_ADTYPE_SERVERAID7k;\r\nbreak;\r\ncase IPS_SUBDEVICEID_7M:\r\nha->ad_type = IPS_ADTYPE_SERVERAID7M;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nips_get_bios_version(ips_ha_t * ha, int intr)\r\n{\r\nips_scb_t *scb;\r\nint ret;\r\nuint8_t major;\r\nuint8_t minor;\r\nuint8_t subminor;\r\nuint8_t *buffer;\r\nchar hexDigits[] =\r\n{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C',\r\n'D', 'E', 'F' };\r\nMETHOD_TRACE("ips_get_bios_version", 1);\r\nmajor = 0;\r\nminor = 0;\r\nstrncpy(ha->bios_version, " ?", 8);\r\nif (ha->pcidev->device == IPS_DEVICEID_COPPERHEAD) {\r\nif (IPS_USE_MEMIO(ha)) {\r\nwritel(0, ha->mem_ptr + IPS_REG_FLAP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\nif (readb(ha->mem_ptr + IPS_REG_FLDP) != 0x55)\r\nreturn;\r\nwritel(1, ha->mem_ptr + IPS_REG_FLAP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\nif (readb(ha->mem_ptr + IPS_REG_FLDP) != 0xAA)\r\nreturn;\r\nwritel(0x1FF, ha->mem_ptr + IPS_REG_FLAP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\nmajor = readb(ha->mem_ptr + IPS_REG_FLDP);\r\nwritel(0x1FE, ha->mem_ptr + IPS_REG_FLAP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\nminor = readb(ha->mem_ptr + IPS_REG_FLDP);\r\nwritel(0x1FD, ha->mem_ptr + IPS_REG_FLAP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\nsubminor = readb(ha->mem_ptr + IPS_REG_FLDP);\r\n} else {\r\noutl(0, ha->io_addr + IPS_REG_FLAP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\nif (inb(ha->io_addr + IPS_REG_FLDP) != 0x55)\r\nreturn;\r\noutl(1, ha->io_addr + IPS_REG_FLAP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\nif (inb(ha->io_addr + IPS_REG_FLDP) != 0xAA)\r\nreturn;\r\noutl(0x1FF, ha->io_addr + IPS_REG_FLAP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\nmajor = inb(ha->io_addr + IPS_REG_FLDP);\r\noutl(0x1FE, ha->io_addr + IPS_REG_FLAP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\nminor = inb(ha->io_addr + IPS_REG_FLDP);\r\noutl(0x1FD, ha->io_addr + IPS_REG_FLAP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\nsubminor = inb(ha->io_addr + IPS_REG_FLDP);\r\n}\r\n} else {\r\nbuffer = ha->ioctl_data;\r\nmemset(buffer, 0, 0x1000);\r\nscb = &ha->scbs[ha->max_cmds - 1];\r\nips_init_scb(ha, scb);\r\nscb->timeout = ips_cmd_timeout;\r\nscb->cdb[0] = IPS_CMD_RW_BIOSFW;\r\nscb->cmd.flashfw.op_code = IPS_CMD_RW_BIOSFW;\r\nscb->cmd.flashfw.command_id = IPS_COMMAND_ID(ha, scb);\r\nscb->cmd.flashfw.type = 1;\r\nscb->cmd.flashfw.direction = 0;\r\nscb->cmd.flashfw.count = cpu_to_le32(0x800);\r\nscb->cmd.flashfw.total_packets = 1;\r\nscb->cmd.flashfw.packet_num = 0;\r\nscb->data_len = 0x1000;\r\nscb->cmd.flashfw.buffer_addr = ha->ioctl_busaddr;\r\nif (((ret =\r\nips_send_wait(ha, scb, ips_cmd_timeout,\r\nintr)) == IPS_FAILURE)\r\n|| (ret == IPS_SUCCESS_IMM)\r\n|| ((scb->basic_status & IPS_GSC_STATUS_MASK) > 1)) {\r\nreturn;\r\n}\r\nif ((buffer[0xC0] == 0x55) && (buffer[0xC1] == 0xAA)) {\r\nmajor = buffer[0x1ff + 0xC0];\r\nminor = buffer[0x1fe + 0xC0];\r\nsubminor = buffer[0x1fd + 0xC0];\r\n} else {\r\nreturn;\r\n}\r\n}\r\nha->bios_version[0] = hexDigits[(major & 0xF0) >> 4];\r\nha->bios_version[1] = '.';\r\nha->bios_version[2] = hexDigits[major & 0x0F];\r\nha->bios_version[3] = hexDigits[subminor];\r\nha->bios_version[4] = '.';\r\nha->bios_version[5] = hexDigits[(minor & 0xF0) >> 4];\r\nha->bios_version[6] = hexDigits[minor & 0x0F];\r\nha->bios_version[7] = 0;\r\n}\r\nstatic int\r\nips_hainit(ips_ha_t * ha)\r\n{\r\nint i;\r\nstruct timeval tv;\r\nMETHOD_TRACE("ips_hainit", 1);\r\nif (!ha)\r\nreturn (0);\r\nif (ha->func.statinit)\r\n(*ha->func.statinit) (ha);\r\nif (ha->func.enableint)\r\n(*ha->func.enableint) (ha);\r\nha->reset_count = 1;\r\ndo_gettimeofday(&tv);\r\nha->last_ffdc = tv.tv_sec;\r\nips_ffdc_reset(ha, IPS_INTR_IORL);\r\nif (!ips_read_config(ha, IPS_INTR_IORL)) {\r\nIPS_PRINTK(KERN_WARNING, ha->pcidev,\r\n"unable to read config from controller.\n");\r\nreturn (0);\r\n}\r\nif (!ips_read_adapter_status(ha, IPS_INTR_IORL)) {\r\nIPS_PRINTK(KERN_WARNING, ha->pcidev,\r\n"unable to read controller status.\n");\r\nreturn (0);\r\n}\r\nips_identify_controller(ha);\r\nif (!ips_read_subsystem_parameters(ha, IPS_INTR_IORL)) {\r\nIPS_PRINTK(KERN_WARNING, ha->pcidev,\r\n"unable to read subsystem parameters.\n");\r\nreturn (0);\r\n}\r\nif (!ips_write_driver_status(ha, IPS_INTR_IORL)) {\r\nIPS_PRINTK(KERN_WARNING, ha->pcidev,\r\n"unable to write driver info to controller.\n");\r\nreturn (0);\r\n}\r\nif ((ha->conf->ucLogDriveCount > 0) && (ha->requires_esl == 1))\r\nips_clear_adapter(ha, IPS_INTR_IORL);\r\nha->ntargets = IPS_MAX_TARGETS + 1;\r\nha->nlun = 1;\r\nha->nbus = (ha->enq->ucMaxPhysicalDevices / IPS_MAX_TARGETS) + 1;\r\nswitch (ha->conf->logical_drive[0].ucStripeSize) {\r\ncase 4:\r\nha->max_xfer = 0x10000;\r\nbreak;\r\ncase 5:\r\nha->max_xfer = 0x20000;\r\nbreak;\r\ncase 6:\r\nha->max_xfer = 0x40000;\r\nbreak;\r\ncase 7:\r\ndefault:\r\nha->max_xfer = 0x80000;\r\nbreak;\r\n}\r\nif (le32_to_cpu(ha->subsys->param[4]) & 0x1) {\r\nha->max_cmds = ha->enq->ucConcurrentCmdCount;\r\n} else {\r\nswitch (ha->conf->logical_drive[0].ucStripeSize) {\r\ncase 4:\r\nha->max_cmds = 32;\r\nbreak;\r\ncase 5:\r\nha->max_cmds = 16;\r\nbreak;\r\ncase 6:\r\nha->max_cmds = 8;\r\nbreak;\r\ncase 7:\r\ndefault:\r\nha->max_cmds = 4;\r\nbreak;\r\n}\r\n}\r\nif ((ha->ad_type == IPS_ADTYPE_SERVERAID3L) ||\r\n(ha->ad_type == IPS_ADTYPE_SERVERAID4L) ||\r\n(ha->ad_type == IPS_ADTYPE_SERVERAID4LX)) {\r\nif ((ha->max_cmds > MaxLiteCmds) && (MaxLiteCmds))\r\nha->max_cmds = MaxLiteCmds;\r\n}\r\nha->ha_id[0] = IPS_ADAPTER_ID;\r\nfor (i = 1; i < ha->nbus; i++) {\r\nha->ha_id[i] = ha->conf->init_id[i - 1] & 0x1f;\r\nha->dcdb_active[i - 1] = 0;\r\n}\r\nreturn (1);\r\n}\r\nstatic void\r\nips_next(ips_ha_t * ha, int intr)\r\n{\r\nips_scb_t *scb;\r\nstruct scsi_cmnd *SC;\r\nstruct scsi_cmnd *p;\r\nstruct scsi_cmnd *q;\r\nips_copp_wait_item_t *item;\r\nint ret;\r\nstruct Scsi_Host *host;\r\nMETHOD_TRACE("ips_next", 1);\r\nif (!ha)\r\nreturn;\r\nhost = ips_sh[ha->host_num];\r\nif (intr == IPS_INTR_ON)\r\nspin_lock(host->host_lock);\r\nif ((ha->subsys->param[3] & 0x300000)\r\n&& (ha->scb_activelist.count == 0)) {\r\nstruct timeval tv;\r\ndo_gettimeofday(&tv);\r\nif (tv.tv_sec - ha->last_ffdc > IPS_SECS_8HOURS) {\r\nha->last_ffdc = tv.tv_sec;\r\nips_ffdc_time(ha);\r\n}\r\n}\r\nwhile ((ha->num_ioctl < IPS_MAX_IOCTL) &&\r\n(ha->copp_waitlist.head) && (scb = ips_getscb(ha))) {\r\nitem = ips_removeq_copp_head(&ha->copp_waitlist);\r\nha->num_ioctl++;\r\nif (intr == IPS_INTR_ON)\r\nspin_unlock(host->host_lock);\r\nscb->scsi_cmd = item->scsi_cmd;\r\nkfree(item);\r\nret = ips_make_passthru(ha, scb->scsi_cmd, scb, intr);\r\nif (intr == IPS_INTR_ON)\r\nspin_lock(host->host_lock);\r\nswitch (ret) {\r\ncase IPS_FAILURE:\r\nif (scb->scsi_cmd) {\r\nscb->scsi_cmd->result = DID_ERROR << 16;\r\nscb->scsi_cmd->scsi_done(scb->scsi_cmd);\r\n}\r\nips_freescb(ha, scb);\r\nbreak;\r\ncase IPS_SUCCESS_IMM:\r\nif (scb->scsi_cmd) {\r\nscb->scsi_cmd->result = DID_OK << 16;\r\nscb->scsi_cmd->scsi_done(scb->scsi_cmd);\r\n}\r\nips_freescb(ha, scb);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (ret != IPS_SUCCESS) {\r\nha->num_ioctl--;\r\ncontinue;\r\n}\r\nret = ips_send_cmd(ha, scb);\r\nif (ret == IPS_SUCCESS)\r\nips_putq_scb_head(&ha->scb_activelist, scb);\r\nelse\r\nha->num_ioctl--;\r\nswitch (ret) {\r\ncase IPS_FAILURE:\r\nif (scb->scsi_cmd) {\r\nscb->scsi_cmd->result = DID_ERROR << 16;\r\n}\r\nips_freescb(ha, scb);\r\nbreak;\r\ncase IPS_SUCCESS_IMM:\r\nips_freescb(ha, scb);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\np = ha->scb_waitlist.head;\r\nwhile ((p) && (scb = ips_getscb(ha))) {\r\nif ((scmd_channel(p) > 0)\r\n&& (ha->\r\ndcdb_active[scmd_channel(p) -\r\n1] & (1 << scmd_id(p)))) {\r\nips_freescb(ha, scb);\r\np = (struct scsi_cmnd *) p->host_scribble;\r\ncontinue;\r\n}\r\nq = p;\r\nSC = ips_removeq_wait(&ha->scb_waitlist, q);\r\nif (intr == IPS_INTR_ON)\r\nspin_unlock(host->host_lock);\r\nSC->result = DID_OK;\r\nSC->host_scribble = NULL;\r\nscb->target_id = SC->device->id;\r\nscb->lun = SC->device->lun;\r\nscb->bus = SC->device->channel;\r\nscb->scsi_cmd = SC;\r\nscb->breakup = 0;\r\nscb->data_len = 0;\r\nscb->callback = ipsintr_done;\r\nscb->timeout = ips_cmd_timeout;\r\nmemset(&scb->cmd, 0, 16);\r\nmemcpy(scb->cdb, SC->cmnd, SC->cmd_len);\r\nscb->sg_count = scsi_dma_map(SC);\r\nBUG_ON(scb->sg_count < 0);\r\nif (scb->sg_count) {\r\nstruct scatterlist *sg;\r\nint i;\r\nscb->flags |= IPS_SCB_MAP_SG;\r\nscsi_for_each_sg(SC, sg, scb->sg_count, i) {\r\nif (ips_fill_scb_sg_single\r\n(ha, sg_dma_address(sg), scb, i,\r\nsg_dma_len(sg)) < 0)\r\nbreak;\r\n}\r\nscb->dcdb.transfer_length = scb->data_len;\r\n} else {\r\nscb->data_busaddr = 0L;\r\nscb->sg_len = 0;\r\nscb->data_len = 0;\r\nscb->dcdb.transfer_length = 0;\r\n}\r\nscb->dcdb.cmd_attribute =\r\nips_command_direction[scb->scsi_cmd->cmnd[0]];\r\nif ((scb->scsi_cmd->cmnd[0] == WRITE_BUFFER) &&\r\n(scb->data_len == 0))\r\nscb->dcdb.cmd_attribute = 0;\r\nif (!(scb->dcdb.cmd_attribute & 0x3))\r\nscb->dcdb.transfer_length = 0;\r\nif (scb->data_len >= IPS_MAX_XFER) {\r\nscb->dcdb.cmd_attribute |= IPS_TRANSFER64K;\r\nscb->dcdb.transfer_length = 0;\r\n}\r\nif (intr == IPS_INTR_ON)\r\nspin_lock(host->host_lock);\r\nret = ips_send_cmd(ha, scb);\r\nswitch (ret) {\r\ncase IPS_SUCCESS:\r\nips_putq_scb_head(&ha->scb_activelist, scb);\r\nbreak;\r\ncase IPS_FAILURE:\r\nif (scb->scsi_cmd) {\r\nscb->scsi_cmd->result = DID_ERROR << 16;\r\nscb->scsi_cmd->scsi_done(scb->scsi_cmd);\r\n}\r\nif (scb->bus)\r\nha->dcdb_active[scb->bus - 1] &=\r\n~(1 << scb->target_id);\r\nips_freescb(ha, scb);\r\nbreak;\r\ncase IPS_SUCCESS_IMM:\r\nif (scb->scsi_cmd)\r\nscb->scsi_cmd->scsi_done(scb->scsi_cmd);\r\nif (scb->bus)\r\nha->dcdb_active[scb->bus - 1] &=\r\n~(1 << scb->target_id);\r\nips_freescb(ha, scb);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\np = (struct scsi_cmnd *) p->host_scribble;\r\n}\r\nif (intr == IPS_INTR_ON)\r\nspin_unlock(host->host_lock);\r\n}\r\nstatic void\r\nips_putq_scb_head(ips_scb_queue_t * queue, ips_scb_t * item)\r\n{\r\nMETHOD_TRACE("ips_putq_scb_head", 1);\r\nif (!item)\r\nreturn;\r\nitem->q_next = queue->head;\r\nqueue->head = item;\r\nif (!queue->tail)\r\nqueue->tail = item;\r\nqueue->count++;\r\n}\r\nstatic ips_scb_t *\r\nips_removeq_scb_head(ips_scb_queue_t * queue)\r\n{\r\nips_scb_t *item;\r\nMETHOD_TRACE("ips_removeq_scb_head", 1);\r\nitem = queue->head;\r\nif (!item) {\r\nreturn (NULL);\r\n}\r\nqueue->head = item->q_next;\r\nitem->q_next = NULL;\r\nif (queue->tail == item)\r\nqueue->tail = NULL;\r\nqueue->count--;\r\nreturn (item);\r\n}\r\nstatic ips_scb_t *\r\nips_removeq_scb(ips_scb_queue_t * queue, ips_scb_t * item)\r\n{\r\nips_scb_t *p;\r\nMETHOD_TRACE("ips_removeq_scb", 1);\r\nif (!item)\r\nreturn (NULL);\r\nif (item == queue->head) {\r\nreturn (ips_removeq_scb_head(queue));\r\n}\r\np = queue->head;\r\nwhile ((p) && (item != p->q_next))\r\np = p->q_next;\r\nif (p) {\r\np->q_next = item->q_next;\r\nif (!item->q_next)\r\nqueue->tail = p;\r\nitem->q_next = NULL;\r\nqueue->count--;\r\nreturn (item);\r\n}\r\nreturn (NULL);\r\n}\r\nstatic void ips_putq_wait_tail(ips_wait_queue_t *queue, struct scsi_cmnd *item)\r\n{\r\nMETHOD_TRACE("ips_putq_wait_tail", 1);\r\nif (!item)\r\nreturn;\r\nitem->host_scribble = NULL;\r\nif (queue->tail)\r\nqueue->tail->host_scribble = (char *) item;\r\nqueue->tail = item;\r\nif (!queue->head)\r\nqueue->head = item;\r\nqueue->count++;\r\n}\r\nstatic struct scsi_cmnd *ips_removeq_wait_head(ips_wait_queue_t *queue)\r\n{\r\nstruct scsi_cmnd *item;\r\nMETHOD_TRACE("ips_removeq_wait_head", 1);\r\nitem = queue->head;\r\nif (!item) {\r\nreturn (NULL);\r\n}\r\nqueue->head = (struct scsi_cmnd *) item->host_scribble;\r\nitem->host_scribble = NULL;\r\nif (queue->tail == item)\r\nqueue->tail = NULL;\r\nqueue->count--;\r\nreturn (item);\r\n}\r\nstatic struct scsi_cmnd *ips_removeq_wait(ips_wait_queue_t *queue,\r\nstruct scsi_cmnd *item)\r\n{\r\nstruct scsi_cmnd *p;\r\nMETHOD_TRACE("ips_removeq_wait", 1);\r\nif (!item)\r\nreturn (NULL);\r\nif (item == queue->head) {\r\nreturn (ips_removeq_wait_head(queue));\r\n}\r\np = queue->head;\r\nwhile ((p) && (item != (struct scsi_cmnd *) p->host_scribble))\r\np = (struct scsi_cmnd *) p->host_scribble;\r\nif (p) {\r\np->host_scribble = item->host_scribble;\r\nif (!item->host_scribble)\r\nqueue->tail = p;\r\nitem->host_scribble = NULL;\r\nqueue->count--;\r\nreturn (item);\r\n}\r\nreturn (NULL);\r\n}\r\nstatic void\r\nips_putq_copp_tail(ips_copp_queue_t * queue, ips_copp_wait_item_t * item)\r\n{\r\nMETHOD_TRACE("ips_putq_copp_tail", 1);\r\nif (!item)\r\nreturn;\r\nitem->next = NULL;\r\nif (queue->tail)\r\nqueue->tail->next = item;\r\nqueue->tail = item;\r\nif (!queue->head)\r\nqueue->head = item;\r\nqueue->count++;\r\n}\r\nstatic ips_copp_wait_item_t *\r\nips_removeq_copp_head(ips_copp_queue_t * queue)\r\n{\r\nips_copp_wait_item_t *item;\r\nMETHOD_TRACE("ips_removeq_copp_head", 1);\r\nitem = queue->head;\r\nif (!item) {\r\nreturn (NULL);\r\n}\r\nqueue->head = item->next;\r\nitem->next = NULL;\r\nif (queue->tail == item)\r\nqueue->tail = NULL;\r\nqueue->count--;\r\nreturn (item);\r\n}\r\nstatic ips_copp_wait_item_t *\r\nips_removeq_copp(ips_copp_queue_t * queue, ips_copp_wait_item_t * item)\r\n{\r\nips_copp_wait_item_t *p;\r\nMETHOD_TRACE("ips_removeq_copp", 1);\r\nif (!item)\r\nreturn (NULL);\r\nif (item == queue->head) {\r\nreturn (ips_removeq_copp_head(queue));\r\n}\r\np = queue->head;\r\nwhile ((p) && (item != p->next))\r\np = p->next;\r\nif (p) {\r\np->next = item->next;\r\nif (!item->next)\r\nqueue->tail = p;\r\nitem->next = NULL;\r\nqueue->count--;\r\nreturn (item);\r\n}\r\nreturn (NULL);\r\n}\r\nstatic void\r\nipsintr_blocking(ips_ha_t * ha, ips_scb_t * scb)\r\n{\r\nMETHOD_TRACE("ipsintr_blocking", 2);\r\nips_freescb(ha, scb);\r\nif ((ha->waitflag == TRUE) && (ha->cmd_in_progress == scb->cdb[0])) {\r\nha->waitflag = FALSE;\r\nreturn;\r\n}\r\n}\r\nstatic void\r\nipsintr_done(ips_ha_t * ha, ips_scb_t * scb)\r\n{\r\nMETHOD_TRACE("ipsintr_done", 2);\r\nif (!scb) {\r\nIPS_PRINTK(KERN_WARNING, ha->pcidev,\r\n"Spurious interrupt; scb NULL.\n");\r\nreturn;\r\n}\r\nif (scb->scsi_cmd == NULL) {\r\nIPS_PRINTK(KERN_WARNING, ha->pcidev,\r\n"Spurious interrupt; scsi_cmd not set.\n");\r\nreturn;\r\n}\r\nips_done(ha, scb);\r\n}\r\nstatic void\r\nips_done(ips_ha_t * ha, ips_scb_t * scb)\r\n{\r\nint ret;\r\nMETHOD_TRACE("ips_done", 1);\r\nif (!scb)\r\nreturn;\r\nif ((scb->scsi_cmd) && (ips_is_passthru(scb->scsi_cmd))) {\r\nips_cleanup_passthru(ha, scb);\r\nha->num_ioctl--;\r\n} else {\r\nif ((scb->breakup) || (scb->sg_break)) {\r\nstruct scatterlist *sg;\r\nint i, sg_dma_index, ips_sg_index = 0;\r\nscb->data_len = 0;\r\nsg = scsi_sglist(scb->scsi_cmd);\r\nsg_dma_index = scb->breakup;\r\nfor (i = 0; i < scb->breakup; i++)\r\nsg = sg_next(sg);\r\nips_fill_scb_sg_single(ha,\r\nsg_dma_address(sg),\r\nscb, ips_sg_index++,\r\nsg_dma_len(sg));\r\nfor (; sg_dma_index < scsi_sg_count(scb->scsi_cmd);\r\nsg_dma_index++, sg = sg_next(sg)) {\r\nif (ips_fill_scb_sg_single\r\n(ha,\r\nsg_dma_address(sg),\r\nscb, ips_sg_index++,\r\nsg_dma_len(sg)) < 0)\r\nbreak;\r\n}\r\nscb->dcdb.transfer_length = scb->data_len;\r\nscb->dcdb.cmd_attribute |=\r\nips_command_direction[scb->scsi_cmd->cmnd[0]];\r\nif (!(scb->dcdb.cmd_attribute & 0x3))\r\nscb->dcdb.transfer_length = 0;\r\nif (scb->data_len >= IPS_MAX_XFER) {\r\nscb->dcdb.cmd_attribute |= IPS_TRANSFER64K;\r\nscb->dcdb.transfer_length = 0;\r\n}\r\nret = ips_send_cmd(ha, scb);\r\nswitch (ret) {\r\ncase IPS_FAILURE:\r\nif (scb->scsi_cmd) {\r\nscb->scsi_cmd->result = DID_ERROR << 16;\r\nscb->scsi_cmd->scsi_done(scb->scsi_cmd);\r\n}\r\nips_freescb(ha, scb);\r\nbreak;\r\ncase IPS_SUCCESS_IMM:\r\nif (scb->scsi_cmd) {\r\nscb->scsi_cmd->result = DID_ERROR << 16;\r\nscb->scsi_cmd->scsi_done(scb->scsi_cmd);\r\n}\r\nips_freescb(ha, scb);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn;\r\n}\r\n}\r\nif (scb->bus) {\r\nha->dcdb_active[scb->bus - 1] &= ~(1 << scb->target_id);\r\n}\r\nscb->scsi_cmd->scsi_done(scb->scsi_cmd);\r\nips_freescb(ha, scb);\r\n}\r\nstatic int\r\nips_map_status(ips_ha_t * ha, ips_scb_t * scb, ips_stat_t * sp)\r\n{\r\nint errcode;\r\nint device_error;\r\nuint32_t transfer_len;\r\nIPS_DCDB_TABLE_TAPE *tapeDCDB;\r\nIPS_SCSI_INQ_DATA inquiryData;\r\nMETHOD_TRACE("ips_map_status", 1);\r\nif (scb->bus) {\r\nDEBUG_VAR(2,\r\n"(%s%d) Physical device error (%d %d %d): %x %x, Sense Key: %x, ASC: %x, ASCQ: %x",\r\nips_name, ha->host_num,\r\nscb->scsi_cmd->device->channel,\r\nscb->scsi_cmd->device->id, scb->scsi_cmd->device->lun,\r\nscb->basic_status, scb->extended_status,\r\nscb->extended_status ==\r\nIPS_ERR_CKCOND ? scb->dcdb.sense_info[2] & 0xf : 0,\r\nscb->extended_status ==\r\nIPS_ERR_CKCOND ? scb->dcdb.sense_info[12] : 0,\r\nscb->extended_status ==\r\nIPS_ERR_CKCOND ? scb->dcdb.sense_info[13] : 0);\r\n}\r\nerrcode = DID_ERROR;\r\ndevice_error = 0;\r\nswitch (scb->basic_status & IPS_GSC_STATUS_MASK) {\r\ncase IPS_CMD_TIMEOUT:\r\nerrcode = DID_TIME_OUT;\r\nbreak;\r\ncase IPS_INVAL_OPCO:\r\ncase IPS_INVAL_CMD_BLK:\r\ncase IPS_INVAL_PARM_BLK:\r\ncase IPS_LD_ERROR:\r\ncase IPS_CMD_CMPLT_WERROR:\r\nbreak;\r\ncase IPS_PHYS_DRV_ERROR:\r\nswitch (scb->extended_status) {\r\ncase IPS_ERR_SEL_TO:\r\nif (scb->bus)\r\nerrcode = DID_NO_CONNECT;\r\nbreak;\r\ncase IPS_ERR_OU_RUN:\r\nif ((scb->cmd.dcdb.op_code == IPS_CMD_EXTENDED_DCDB) ||\r\n(scb->cmd.dcdb.op_code ==\r\nIPS_CMD_EXTENDED_DCDB_SG)) {\r\ntapeDCDB = (IPS_DCDB_TABLE_TAPE *) & scb->dcdb;\r\ntransfer_len = tapeDCDB->transfer_length;\r\n} else {\r\ntransfer_len =\r\n(uint32_t) scb->dcdb.transfer_length;\r\n}\r\nif ((scb->bus) && (transfer_len < scb->data_len)) {\r\nerrcode = DID_OK;\r\nif (scb->scsi_cmd->cmnd[0] == INQUIRY) {\r\nips_scmd_buf_read(scb->scsi_cmd,\r\n&inquiryData, sizeof (inquiryData));\r\nif ((inquiryData.DeviceType & 0x1f) == TYPE_DISK) {\r\nerrcode = DID_TIME_OUT;\r\nbreak;\r\n}\r\n}\r\n} else\r\nerrcode = DID_ERROR;\r\nbreak;\r\ncase IPS_ERR_RECOVERY:\r\nif (scb->bus)\r\nerrcode = DID_OK;\r\nbreak;\r\ncase IPS_ERR_HOST_RESET:\r\ncase IPS_ERR_DEV_RESET:\r\nerrcode = DID_RESET;\r\nbreak;\r\ncase IPS_ERR_CKCOND:\r\nif (scb->bus) {\r\nif ((scb->cmd.dcdb.op_code ==\r\nIPS_CMD_EXTENDED_DCDB)\r\n|| (scb->cmd.dcdb.op_code ==\r\nIPS_CMD_EXTENDED_DCDB_SG)) {\r\ntapeDCDB =\r\n(IPS_DCDB_TABLE_TAPE *) & scb->dcdb;\r\nmemcpy(scb->scsi_cmd->sense_buffer,\r\ntapeDCDB->sense_info,\r\nSCSI_SENSE_BUFFERSIZE);\r\n} else {\r\nmemcpy(scb->scsi_cmd->sense_buffer,\r\nscb->dcdb.sense_info,\r\nSCSI_SENSE_BUFFERSIZE);\r\n}\r\ndevice_error = 2;\r\n}\r\nerrcode = DID_OK;\r\nbreak;\r\ndefault:\r\nerrcode = DID_ERROR;\r\nbreak;\r\n}\r\n}\r\nscb->scsi_cmd->result = device_error | (errcode << 16);\r\nreturn (1);\r\n}\r\nstatic int\r\nips_send_wait(ips_ha_t * ha, ips_scb_t * scb, int timeout, int intr)\r\n{\r\nint ret;\r\nMETHOD_TRACE("ips_send_wait", 1);\r\nif (intr != IPS_FFDC) {\r\nha->waitflag = TRUE;\r\nha->cmd_in_progress = scb->cdb[0];\r\n}\r\nscb->callback = ipsintr_blocking;\r\nret = ips_send_cmd(ha, scb);\r\nif ((ret == IPS_FAILURE) || (ret == IPS_SUCCESS_IMM))\r\nreturn (ret);\r\nif (intr != IPS_FFDC)\r\nret = ips_wait(ha, timeout, intr);\r\nreturn (ret);\r\n}\r\nstatic void\r\nips_scmd_buf_write(struct scsi_cmnd *scmd, void *data, unsigned int count)\r\n{\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nscsi_sg_copy_from_buffer(scmd, data, count);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void\r\nips_scmd_buf_read(struct scsi_cmnd *scmd, void *data, unsigned int count)\r\n{\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nscsi_sg_copy_to_buffer(scmd, data, count);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int\r\nips_send_cmd(ips_ha_t * ha, ips_scb_t * scb)\r\n{\r\nint ret;\r\nchar *sp;\r\nint device_error;\r\nIPS_DCDB_TABLE_TAPE *tapeDCDB;\r\nint TimeOut;\r\nMETHOD_TRACE("ips_send_cmd", 1);\r\nret = IPS_SUCCESS;\r\nif (!scb->scsi_cmd) {\r\nif (scb->bus > 0) {\r\nif ((ha->waitflag == TRUE) &&\r\n(ha->cmd_in_progress == scb->cdb[0])) {\r\nha->waitflag = FALSE;\r\n}\r\nreturn (1);\r\n}\r\n} else if ((scb->bus == 0) && (!ips_is_passthru(scb->scsi_cmd))) {\r\nret = IPS_SUCCESS_IMM;\r\nswitch (scb->scsi_cmd->cmnd[0]) {\r\ncase ALLOW_MEDIUM_REMOVAL:\r\ncase REZERO_UNIT:\r\ncase ERASE:\r\ncase WRITE_FILEMARKS:\r\ncase SPACE:\r\nscb->scsi_cmd->result = DID_ERROR << 16;\r\nbreak;\r\ncase START_STOP:\r\nscb->scsi_cmd->result = DID_OK << 16;\r\ncase TEST_UNIT_READY:\r\ncase INQUIRY:\r\nif (scb->target_id == IPS_ADAPTER_ID) {\r\nif (scb->scsi_cmd->cmnd[0] == TEST_UNIT_READY)\r\nscb->scsi_cmd->result = DID_OK << 16;\r\nif (scb->scsi_cmd->cmnd[0] == INQUIRY) {\r\nIPS_SCSI_INQ_DATA inquiry;\r\nmemset(&inquiry, 0,\r\nsizeof (IPS_SCSI_INQ_DATA));\r\ninquiry.DeviceType =\r\nIPS_SCSI_INQ_TYPE_PROCESSOR;\r\ninquiry.DeviceTypeQualifier =\r\nIPS_SCSI_INQ_LU_CONNECTED;\r\ninquiry.Version = IPS_SCSI_INQ_REV2;\r\ninquiry.ResponseDataFormat =\r\nIPS_SCSI_INQ_RD_REV2;\r\ninquiry.AdditionalLength = 31;\r\ninquiry.Flags[0] =\r\nIPS_SCSI_INQ_Address16;\r\ninquiry.Flags[1] =\r\nIPS_SCSI_INQ_WBus16 |\r\nIPS_SCSI_INQ_Sync;\r\nstrncpy(inquiry.VendorId, "IBM ",\r\n8);\r\nstrncpy(inquiry.ProductId,\r\n"SERVERAID ", 16);\r\nstrncpy(inquiry.ProductRevisionLevel,\r\n"1.00", 4);\r\nips_scmd_buf_write(scb->scsi_cmd,\r\n&inquiry,\r\nsizeof (inquiry));\r\nscb->scsi_cmd->result = DID_OK << 16;\r\n}\r\n} else {\r\nscb->cmd.logical_info.op_code = IPS_CMD_GET_LD_INFO;\r\nscb->cmd.logical_info.command_id = IPS_COMMAND_ID(ha, scb);\r\nscb->cmd.logical_info.reserved = 0;\r\nscb->cmd.logical_info.reserved2 = 0;\r\nscb->data_len = sizeof (IPS_LD_INFO);\r\nscb->data_busaddr = ha->logical_drive_info_dma_addr;\r\nscb->flags = 0;\r\nscb->cmd.logical_info.buffer_addr = scb->data_busaddr;\r\nret = IPS_SUCCESS;\r\n}\r\nbreak;\r\ncase REQUEST_SENSE:\r\nips_reqsen(ha, scb);\r\nscb->scsi_cmd->result = DID_OK << 16;\r\nbreak;\r\ncase READ_6:\r\ncase WRITE_6:\r\nif (!scb->sg_len) {\r\nscb->cmd.basic_io.op_code =\r\n(scb->scsi_cmd->cmnd[0] ==\r\nREAD_6) ? IPS_CMD_READ : IPS_CMD_WRITE;\r\nscb->cmd.basic_io.enhanced_sg = 0;\r\nscb->cmd.basic_io.sg_addr =\r\ncpu_to_le32(scb->data_busaddr);\r\n} else {\r\nscb->cmd.basic_io.op_code =\r\n(scb->scsi_cmd->cmnd[0] ==\r\nREAD_6) ? IPS_CMD_READ_SG :\r\nIPS_CMD_WRITE_SG;\r\nscb->cmd.basic_io.enhanced_sg =\r\nIPS_USE_ENH_SGLIST(ha) ? 0xFF : 0;\r\nscb->cmd.basic_io.sg_addr =\r\ncpu_to_le32(scb->sg_busaddr);\r\n}\r\nscb->cmd.basic_io.segment_4G = 0;\r\nscb->cmd.basic_io.command_id = IPS_COMMAND_ID(ha, scb);\r\nscb->cmd.basic_io.log_drv = scb->target_id;\r\nscb->cmd.basic_io.sg_count = scb->sg_len;\r\nif (scb->cmd.basic_io.lba)\r\nle32_add_cpu(&scb->cmd.basic_io.lba,\r\nle16_to_cpu(scb->cmd.basic_io.\r\nsector_count));\r\nelse\r\nscb->cmd.basic_io.lba =\r\n(((scb->scsi_cmd->\r\ncmnd[1] & 0x1f) << 16) | (scb->scsi_cmd->\r\ncmnd[2] << 8) |\r\n(scb->scsi_cmd->cmnd[3]));\r\nscb->cmd.basic_io.sector_count =\r\ncpu_to_le16(scb->data_len / IPS_BLKSIZE);\r\nif (le16_to_cpu(scb->cmd.basic_io.sector_count) == 0)\r\nscb->cmd.basic_io.sector_count =\r\ncpu_to_le16(256);\r\nret = IPS_SUCCESS;\r\nbreak;\r\ncase READ_10:\r\ncase WRITE_10:\r\nif (!scb->sg_len) {\r\nscb->cmd.basic_io.op_code =\r\n(scb->scsi_cmd->cmnd[0] ==\r\nREAD_10) ? IPS_CMD_READ : IPS_CMD_WRITE;\r\nscb->cmd.basic_io.enhanced_sg = 0;\r\nscb->cmd.basic_io.sg_addr =\r\ncpu_to_le32(scb->data_busaddr);\r\n} else {\r\nscb->cmd.basic_io.op_code =\r\n(scb->scsi_cmd->cmnd[0] ==\r\nREAD_10) ? IPS_CMD_READ_SG :\r\nIPS_CMD_WRITE_SG;\r\nscb->cmd.basic_io.enhanced_sg =\r\nIPS_USE_ENH_SGLIST(ha) ? 0xFF : 0;\r\nscb->cmd.basic_io.sg_addr =\r\ncpu_to_le32(scb->sg_busaddr);\r\n}\r\nscb->cmd.basic_io.segment_4G = 0;\r\nscb->cmd.basic_io.command_id = IPS_COMMAND_ID(ha, scb);\r\nscb->cmd.basic_io.log_drv = scb->target_id;\r\nscb->cmd.basic_io.sg_count = scb->sg_len;\r\nif (scb->cmd.basic_io.lba)\r\nle32_add_cpu(&scb->cmd.basic_io.lba,\r\nle16_to_cpu(scb->cmd.basic_io.\r\nsector_count));\r\nelse\r\nscb->cmd.basic_io.lba =\r\n((scb->scsi_cmd->cmnd[2] << 24) | (scb->\r\nscsi_cmd->\r\ncmnd[3]\r\n<< 16) |\r\n(scb->scsi_cmd->cmnd[4] << 8) | scb->\r\nscsi_cmd->cmnd[5]);\r\nscb->cmd.basic_io.sector_count =\r\ncpu_to_le16(scb->data_len / IPS_BLKSIZE);\r\nif (cpu_to_le16(scb->cmd.basic_io.sector_count) == 0) {\r\nscb->scsi_cmd->result = DID_OK << 16;\r\n} else\r\nret = IPS_SUCCESS;\r\nbreak;\r\ncase RESERVE:\r\ncase RELEASE:\r\nscb->scsi_cmd->result = DID_OK << 16;\r\nbreak;\r\ncase MODE_SENSE:\r\nscb->cmd.basic_io.op_code = IPS_CMD_ENQUIRY;\r\nscb->cmd.basic_io.command_id = IPS_COMMAND_ID(ha, scb);\r\nscb->cmd.basic_io.segment_4G = 0;\r\nscb->cmd.basic_io.enhanced_sg = 0;\r\nscb->data_len = sizeof (*ha->enq);\r\nscb->cmd.basic_io.sg_addr = ha->enq_busaddr;\r\nret = IPS_SUCCESS;\r\nbreak;\r\ncase READ_CAPACITY:\r\nscb->cmd.logical_info.op_code = IPS_CMD_GET_LD_INFO;\r\nscb->cmd.logical_info.command_id = IPS_COMMAND_ID(ha, scb);\r\nscb->cmd.logical_info.reserved = 0;\r\nscb->cmd.logical_info.reserved2 = 0;\r\nscb->cmd.logical_info.reserved3 = 0;\r\nscb->data_len = sizeof (IPS_LD_INFO);\r\nscb->data_busaddr = ha->logical_drive_info_dma_addr;\r\nscb->flags = 0;\r\nscb->cmd.logical_info.buffer_addr = scb->data_busaddr;\r\nret = IPS_SUCCESS;\r\nbreak;\r\ncase SEND_DIAGNOSTIC:\r\ncase REASSIGN_BLOCKS:\r\ncase FORMAT_UNIT:\r\ncase SEEK_10:\r\ncase VERIFY:\r\ncase READ_DEFECT_DATA:\r\ncase READ_BUFFER:\r\ncase WRITE_BUFFER:\r\nscb->scsi_cmd->result = DID_OK << 16;\r\nbreak;\r\ndefault:\r\nsp = (char *) scb->scsi_cmd->sense_buffer;\r\nsp[0] = 0x70;\r\nsp[2] = ILLEGAL_REQUEST;\r\nsp[7] = 0x0A;\r\nsp[12] = 0x20;\r\nsp[13] = 0x00;\r\ndevice_error = 2;\r\nscb->scsi_cmd->result = device_error | (DID_OK << 16);\r\nbreak;\r\n}\r\n}\r\nif (ret == IPS_SUCCESS_IMM)\r\nreturn (ret);\r\nif (scb->bus > 0) {\r\nif (ha->conf->dev[scb->bus - 1][scb->target_id].ucState == 0) {\r\nscb->scsi_cmd->result = DID_NO_CONNECT << 16;\r\nreturn (IPS_SUCCESS_IMM);\r\n}\r\nha->dcdb_active[scb->bus - 1] |= (1 << scb->target_id);\r\nscb->cmd.dcdb.command_id = IPS_COMMAND_ID(ha, scb);\r\nscb->cmd.dcdb.dcdb_address = cpu_to_le32(scb->scb_busaddr +\r\n(unsigned long) &scb->\r\ndcdb -\r\n(unsigned long) scb);\r\nscb->cmd.dcdb.reserved = 0;\r\nscb->cmd.dcdb.reserved2 = 0;\r\nscb->cmd.dcdb.reserved3 = 0;\r\nscb->cmd.dcdb.segment_4G = 0;\r\nscb->cmd.dcdb.enhanced_sg = 0;\r\nTimeOut = scb->scsi_cmd->request->timeout;\r\nif (ha->subsys->param[4] & 0x00100000) {\r\nif (!scb->sg_len) {\r\nscb->cmd.dcdb.op_code = IPS_CMD_EXTENDED_DCDB;\r\n} else {\r\nscb->cmd.dcdb.op_code =\r\nIPS_CMD_EXTENDED_DCDB_SG;\r\nscb->cmd.dcdb.enhanced_sg =\r\nIPS_USE_ENH_SGLIST(ha) ? 0xFF : 0;\r\n}\r\ntapeDCDB = (IPS_DCDB_TABLE_TAPE *) & scb->dcdb;\r\ntapeDCDB->device_address =\r\n((scb->bus - 1) << 4) | scb->target_id;\r\ntapeDCDB->cmd_attribute |= IPS_DISCONNECT_ALLOWED;\r\ntapeDCDB->cmd_attribute &= ~IPS_TRANSFER64K;\r\nif (TimeOut) {\r\nif (TimeOut < (10 * HZ))\r\ntapeDCDB->cmd_attribute |= IPS_TIMEOUT10;\r\nelse if (TimeOut < (60 * HZ))\r\ntapeDCDB->cmd_attribute |= IPS_TIMEOUT60;\r\nelse if (TimeOut < (1200 * HZ))\r\ntapeDCDB->cmd_attribute |= IPS_TIMEOUT20M;\r\n}\r\ntapeDCDB->cdb_length = scb->scsi_cmd->cmd_len;\r\ntapeDCDB->reserved_for_LUN = 0;\r\ntapeDCDB->transfer_length = scb->data_len;\r\nif (scb->cmd.dcdb.op_code == IPS_CMD_EXTENDED_DCDB_SG)\r\ntapeDCDB->buffer_pointer =\r\ncpu_to_le32(scb->sg_busaddr);\r\nelse\r\ntapeDCDB->buffer_pointer =\r\ncpu_to_le32(scb->data_busaddr);\r\ntapeDCDB->sg_count = scb->sg_len;\r\ntapeDCDB->sense_length = sizeof (tapeDCDB->sense_info);\r\ntapeDCDB->scsi_status = 0;\r\ntapeDCDB->reserved = 0;\r\nmemcpy(tapeDCDB->scsi_cdb, scb->scsi_cmd->cmnd,\r\nscb->scsi_cmd->cmd_len);\r\n} else {\r\nif (!scb->sg_len) {\r\nscb->cmd.dcdb.op_code = IPS_CMD_DCDB;\r\n} else {\r\nscb->cmd.dcdb.op_code = IPS_CMD_DCDB_SG;\r\nscb->cmd.dcdb.enhanced_sg =\r\nIPS_USE_ENH_SGLIST(ha) ? 0xFF : 0;\r\n}\r\nscb->dcdb.device_address =\r\n((scb->bus - 1) << 4) | scb->target_id;\r\nscb->dcdb.cmd_attribute |= IPS_DISCONNECT_ALLOWED;\r\nif (TimeOut) {\r\nif (TimeOut < (10 * HZ))\r\nscb->dcdb.cmd_attribute |= IPS_TIMEOUT10;\r\nelse if (TimeOut < (60 * HZ))\r\nscb->dcdb.cmd_attribute |= IPS_TIMEOUT60;\r\nelse if (TimeOut < (1200 * HZ))\r\nscb->dcdb.cmd_attribute |= IPS_TIMEOUT20M;\r\n}\r\nscb->dcdb.transfer_length = scb->data_len;\r\nif (scb->dcdb.cmd_attribute & IPS_TRANSFER64K)\r\nscb->dcdb.transfer_length = 0;\r\nif (scb->cmd.dcdb.op_code == IPS_CMD_DCDB_SG)\r\nscb->dcdb.buffer_pointer =\r\ncpu_to_le32(scb->sg_busaddr);\r\nelse\r\nscb->dcdb.buffer_pointer =\r\ncpu_to_le32(scb->data_busaddr);\r\nscb->dcdb.cdb_length = scb->scsi_cmd->cmd_len;\r\nscb->dcdb.sense_length = sizeof (scb->dcdb.sense_info);\r\nscb->dcdb.sg_count = scb->sg_len;\r\nscb->dcdb.reserved = 0;\r\nmemcpy(scb->dcdb.scsi_cdb, scb->scsi_cmd->cmnd,\r\nscb->scsi_cmd->cmd_len);\r\nscb->dcdb.scsi_status = 0;\r\nscb->dcdb.reserved2[0] = 0;\r\nscb->dcdb.reserved2[1] = 0;\r\nscb->dcdb.reserved2[2] = 0;\r\n}\r\n}\r\nreturn ((*ha->func.issue) (ha, scb));\r\n}\r\nstatic void\r\nips_chkstatus(ips_ha_t * ha, IPS_STATUS * pstatus)\r\n{\r\nips_scb_t *scb;\r\nips_stat_t *sp;\r\nuint8_t basic_status;\r\nuint8_t ext_status;\r\nint errcode;\r\nIPS_SCSI_INQ_DATA inquiryData;\r\nMETHOD_TRACE("ips_chkstatus", 1);\r\nscb = &ha->scbs[pstatus->fields.command_id];\r\nscb->basic_status = basic_status =\r\npstatus->fields.basic_status & IPS_BASIC_STATUS_MASK;\r\nscb->extended_status = ext_status = pstatus->fields.extended_status;\r\nsp = &ha->sp;\r\nsp->residue_len = 0;\r\nsp->scb_addr = (void *) scb;\r\nips_removeq_scb(&ha->scb_activelist, scb);\r\nif (!scb->scsi_cmd)\r\nreturn;\r\nDEBUG_VAR(2, "(%s%d) ips_chkstatus: cmd 0x%X id %d (%d %d %d)",\r\nips_name,\r\nha->host_num,\r\nscb->cdb[0],\r\nscb->cmd.basic_io.command_id,\r\nscb->bus, scb->target_id, scb->lun);\r\nif ((scb->scsi_cmd) && (ips_is_passthru(scb->scsi_cmd)))\r\nreturn;\r\nerrcode = DID_OK;\r\nif (((basic_status & IPS_GSC_STATUS_MASK) == IPS_CMD_SUCCESS) ||\r\n((basic_status & IPS_GSC_STATUS_MASK) == IPS_CMD_RECOVERED_ERROR)) {\r\nif (scb->bus == 0) {\r\nif ((basic_status & IPS_GSC_STATUS_MASK) ==\r\nIPS_CMD_RECOVERED_ERROR) {\r\nDEBUG_VAR(1,\r\n"(%s%d) Recovered Logical Drive Error OpCode: %x, BSB: %x, ESB: %x",\r\nips_name, ha->host_num,\r\nscb->cmd.basic_io.op_code,\r\nbasic_status, ext_status);\r\n}\r\nswitch (scb->scsi_cmd->cmnd[0]) {\r\ncase ALLOW_MEDIUM_REMOVAL:\r\ncase REZERO_UNIT:\r\ncase ERASE:\r\ncase WRITE_FILEMARKS:\r\ncase SPACE:\r\nerrcode = DID_ERROR;\r\nbreak;\r\ncase START_STOP:\r\nbreak;\r\ncase TEST_UNIT_READY:\r\nif (!ips_online(ha, scb)) {\r\nerrcode = DID_TIME_OUT;\r\n}\r\nbreak;\r\ncase INQUIRY:\r\nif (ips_online(ha, scb)) {\r\nips_inquiry(ha, scb);\r\n} else {\r\nerrcode = DID_TIME_OUT;\r\n}\r\nbreak;\r\ncase REQUEST_SENSE:\r\nips_reqsen(ha, scb);\r\nbreak;\r\ncase READ_6:\r\ncase WRITE_6:\r\ncase READ_10:\r\ncase WRITE_10:\r\ncase RESERVE:\r\ncase RELEASE:\r\nbreak;\r\ncase MODE_SENSE:\r\nif (!ips_online(ha, scb)\r\n|| !ips_msense(ha, scb)) {\r\nerrcode = DID_ERROR;\r\n}\r\nbreak;\r\ncase READ_CAPACITY:\r\nif (ips_online(ha, scb))\r\nips_rdcap(ha, scb);\r\nelse {\r\nerrcode = DID_TIME_OUT;\r\n}\r\nbreak;\r\ncase SEND_DIAGNOSTIC:\r\ncase REASSIGN_BLOCKS:\r\nbreak;\r\ncase FORMAT_UNIT:\r\nerrcode = DID_ERROR;\r\nbreak;\r\ncase SEEK_10:\r\ncase VERIFY:\r\ncase READ_DEFECT_DATA:\r\ncase READ_BUFFER:\r\ncase WRITE_BUFFER:\r\nbreak;\r\ndefault:\r\nerrcode = DID_ERROR;\r\n}\r\nscb->scsi_cmd->result = errcode << 16;\r\n} else {\r\nif (scb->scsi_cmd->cmnd[0] == INQUIRY) {\r\nips_scmd_buf_read(scb->scsi_cmd,\r\n&inquiryData, sizeof (inquiryData));\r\nif ((inquiryData.DeviceType & 0x1f) == TYPE_DISK)\r\nscb->scsi_cmd->result = DID_TIME_OUT << 16;\r\n}\r\n}\r\n} else {\r\nif (scb->bus == 0) {\r\nDEBUG_VAR(1,\r\n"(%s%d) Unrecovered Logical Drive Error OpCode: %x, BSB: %x, ESB: %x",\r\nips_name, ha->host_num,\r\nscb->cmd.basic_io.op_code, basic_status,\r\next_status);\r\n}\r\nips_map_status(ha, scb, sp);\r\n}\r\n}\r\nstatic int\r\nips_online(ips_ha_t * ha, ips_scb_t * scb)\r\n{\r\nMETHOD_TRACE("ips_online", 1);\r\nif (scb->target_id >= IPS_MAX_LD)\r\nreturn (0);\r\nif ((scb->basic_status & IPS_GSC_STATUS_MASK) > 1) {\r\nmemset(ha->logical_drive_info, 0, sizeof (IPS_LD_INFO));\r\nreturn (0);\r\n}\r\nif (ha->logical_drive_info->drive_info[scb->target_id].state !=\r\nIPS_LD_OFFLINE\r\n&& ha->logical_drive_info->drive_info[scb->target_id].state !=\r\nIPS_LD_FREE\r\n&& ha->logical_drive_info->drive_info[scb->target_id].state !=\r\nIPS_LD_CRS\r\n&& ha->logical_drive_info->drive_info[scb->target_id].state !=\r\nIPS_LD_SYS)\r\nreturn (1);\r\nelse\r\nreturn (0);\r\n}\r\nstatic int\r\nips_inquiry(ips_ha_t * ha, ips_scb_t * scb)\r\n{\r\nIPS_SCSI_INQ_DATA inquiry;\r\nMETHOD_TRACE("ips_inquiry", 1);\r\nmemset(&inquiry, 0, sizeof (IPS_SCSI_INQ_DATA));\r\ninquiry.DeviceType = IPS_SCSI_INQ_TYPE_DASD;\r\ninquiry.DeviceTypeQualifier = IPS_SCSI_INQ_LU_CONNECTED;\r\ninquiry.Version = IPS_SCSI_INQ_REV2;\r\ninquiry.ResponseDataFormat = IPS_SCSI_INQ_RD_REV2;\r\ninquiry.AdditionalLength = 31;\r\ninquiry.Flags[0] = IPS_SCSI_INQ_Address16;\r\ninquiry.Flags[1] =\r\nIPS_SCSI_INQ_WBus16 | IPS_SCSI_INQ_Sync | IPS_SCSI_INQ_CmdQue;\r\nstrncpy(inquiry.VendorId, "IBM ", 8);\r\nstrncpy(inquiry.ProductId, "SERVERAID ", 16);\r\nstrncpy(inquiry.ProductRevisionLevel, "1.00", 4);\r\nips_scmd_buf_write(scb->scsi_cmd, &inquiry, sizeof (inquiry));\r\nreturn (1);\r\n}\r\nstatic int\r\nips_rdcap(ips_ha_t * ha, ips_scb_t * scb)\r\n{\r\nIPS_SCSI_CAPACITY cap;\r\nMETHOD_TRACE("ips_rdcap", 1);\r\nif (scsi_bufflen(scb->scsi_cmd) < 8)\r\nreturn (0);\r\ncap.lba =\r\ncpu_to_be32(le32_to_cpu\r\n(ha->logical_drive_info->\r\ndrive_info[scb->target_id].sector_count) - 1);\r\ncap.len = cpu_to_be32((uint32_t) IPS_BLKSIZE);\r\nips_scmd_buf_write(scb->scsi_cmd, &cap, sizeof (cap));\r\nreturn (1);\r\n}\r\nstatic int\r\nips_msense(ips_ha_t * ha, ips_scb_t * scb)\r\n{\r\nuint16_t heads;\r\nuint16_t sectors;\r\nuint32_t cylinders;\r\nIPS_SCSI_MODE_PAGE_DATA mdata;\r\nMETHOD_TRACE("ips_msense", 1);\r\nif (le32_to_cpu(ha->enq->ulDriveSize[scb->target_id]) > 0x400000 &&\r\n(ha->enq->ucMiscFlag & 0x8) == 0) {\r\nheads = IPS_NORM_HEADS;\r\nsectors = IPS_NORM_SECTORS;\r\n} else {\r\nheads = IPS_COMP_HEADS;\r\nsectors = IPS_COMP_SECTORS;\r\n}\r\ncylinders =\r\n(le32_to_cpu(ha->enq->ulDriveSize[scb->target_id]) -\r\n1) / (heads * sectors);\r\nmemset(&mdata, 0, sizeof (IPS_SCSI_MODE_PAGE_DATA));\r\nmdata.hdr.BlockDescLength = 8;\r\nswitch (scb->scsi_cmd->cmnd[2] & 0x3f) {\r\ncase 0x03:\r\nmdata.pdata.pg3.PageCode = 3;\r\nmdata.pdata.pg3.PageLength = sizeof (IPS_SCSI_MODE_PAGE3);\r\nmdata.hdr.DataLength =\r\n3 + mdata.hdr.BlockDescLength + mdata.pdata.pg3.PageLength;\r\nmdata.pdata.pg3.TracksPerZone = 0;\r\nmdata.pdata.pg3.AltSectorsPerZone = 0;\r\nmdata.pdata.pg3.AltTracksPerZone = 0;\r\nmdata.pdata.pg3.AltTracksPerVolume = 0;\r\nmdata.pdata.pg3.SectorsPerTrack = cpu_to_be16(sectors);\r\nmdata.pdata.pg3.BytesPerSector = cpu_to_be16(IPS_BLKSIZE);\r\nmdata.pdata.pg3.Interleave = cpu_to_be16(1);\r\nmdata.pdata.pg3.TrackSkew = 0;\r\nmdata.pdata.pg3.CylinderSkew = 0;\r\nmdata.pdata.pg3.flags = IPS_SCSI_MP3_SoftSector;\r\nbreak;\r\ncase 0x4:\r\nmdata.pdata.pg4.PageCode = 4;\r\nmdata.pdata.pg4.PageLength = sizeof (IPS_SCSI_MODE_PAGE4);\r\nmdata.hdr.DataLength =\r\n3 + mdata.hdr.BlockDescLength + mdata.pdata.pg4.PageLength;\r\nmdata.pdata.pg4.CylindersHigh =\r\ncpu_to_be16((cylinders >> 8) & 0xFFFF);\r\nmdata.pdata.pg4.CylindersLow = (cylinders & 0xFF);\r\nmdata.pdata.pg4.Heads = heads;\r\nmdata.pdata.pg4.WritePrecompHigh = 0;\r\nmdata.pdata.pg4.WritePrecompLow = 0;\r\nmdata.pdata.pg4.ReducedWriteCurrentHigh = 0;\r\nmdata.pdata.pg4.ReducedWriteCurrentLow = 0;\r\nmdata.pdata.pg4.StepRate = cpu_to_be16(1);\r\nmdata.pdata.pg4.LandingZoneHigh = 0;\r\nmdata.pdata.pg4.LandingZoneLow = 0;\r\nmdata.pdata.pg4.flags = 0;\r\nmdata.pdata.pg4.RotationalOffset = 0;\r\nmdata.pdata.pg4.MediumRotationRate = 0;\r\nbreak;\r\ncase 0x8:\r\nmdata.pdata.pg8.PageCode = 8;\r\nmdata.pdata.pg8.PageLength = sizeof (IPS_SCSI_MODE_PAGE8);\r\nmdata.hdr.DataLength =\r\n3 + mdata.hdr.BlockDescLength + mdata.pdata.pg8.PageLength;\r\nbreak;\r\ndefault:\r\nreturn (0);\r\n}\r\nips_scmd_buf_write(scb->scsi_cmd, &mdata, sizeof (mdata));\r\nreturn (1);\r\n}\r\nstatic int\r\nips_reqsen(ips_ha_t * ha, ips_scb_t * scb)\r\n{\r\nIPS_SCSI_REQSEN reqsen;\r\nMETHOD_TRACE("ips_reqsen", 1);\r\nmemset(&reqsen, 0, sizeof (IPS_SCSI_REQSEN));\r\nreqsen.ResponseCode =\r\nIPS_SCSI_REQSEN_VALID | IPS_SCSI_REQSEN_CURRENT_ERR;\r\nreqsen.AdditionalLength = 10;\r\nreqsen.AdditionalSenseCode = IPS_SCSI_REQSEN_NO_SENSE;\r\nreqsen.AdditionalSenseCodeQual = IPS_SCSI_REQSEN_NO_SENSE;\r\nips_scmd_buf_write(scb->scsi_cmd, &reqsen, sizeof (reqsen));\r\nreturn (1);\r\n}\r\nstatic void\r\nips_free(ips_ha_t * ha)\r\n{\r\nMETHOD_TRACE("ips_free", 1);\r\nif (ha) {\r\nif (ha->enq) {\r\npci_free_consistent(ha->pcidev, sizeof(IPS_ENQ),\r\nha->enq, ha->enq_busaddr);\r\nha->enq = NULL;\r\n}\r\nkfree(ha->conf);\r\nha->conf = NULL;\r\nif (ha->adapt) {\r\npci_free_consistent(ha->pcidev,\r\nsizeof (IPS_ADAPTER) +\r\nsizeof (IPS_IO_CMD), ha->adapt,\r\nha->adapt->hw_status_start);\r\nha->adapt = NULL;\r\n}\r\nif (ha->logical_drive_info) {\r\npci_free_consistent(ha->pcidev,\r\nsizeof (IPS_LD_INFO),\r\nha->logical_drive_info,\r\nha->logical_drive_info_dma_addr);\r\nha->logical_drive_info = NULL;\r\n}\r\nkfree(ha->nvram);\r\nha->nvram = NULL;\r\nkfree(ha->subsys);\r\nha->subsys = NULL;\r\nif (ha->ioctl_data) {\r\npci_free_consistent(ha->pcidev, ha->ioctl_len,\r\nha->ioctl_data, ha->ioctl_busaddr);\r\nha->ioctl_data = NULL;\r\nha->ioctl_datasize = 0;\r\nha->ioctl_len = 0;\r\n}\r\nips_deallocatescbs(ha, ha->max_cmds);\r\nif (ha->mem_ptr) {\r\niounmap(ha->ioremap_ptr);\r\nha->ioremap_ptr = NULL;\r\nha->mem_ptr = NULL;\r\n}\r\nha->mem_addr = 0;\r\n}\r\n}\r\nstatic int\r\nips_deallocatescbs(ips_ha_t * ha, int cmds)\r\n{\r\nif (ha->scbs) {\r\npci_free_consistent(ha->pcidev,\r\nIPS_SGLIST_SIZE(ha) * IPS_MAX_SG * cmds,\r\nha->scbs->sg_list.list,\r\nha->scbs->sg_busaddr);\r\npci_free_consistent(ha->pcidev, sizeof (ips_scb_t) * cmds,\r\nha->scbs, ha->scbs->scb_busaddr);\r\nha->scbs = NULL;\r\n}\r\nreturn 1;\r\n}\r\nstatic int\r\nips_allocatescbs(ips_ha_t * ha)\r\n{\r\nips_scb_t *scb_p;\r\nIPS_SG_LIST ips_sg;\r\nint i;\r\ndma_addr_t command_dma, sg_dma;\r\nMETHOD_TRACE("ips_allocatescbs", 1);\r\nha->scbs =\r\npci_alloc_consistent(ha->pcidev, ha->max_cmds * sizeof (ips_scb_t),\r\n&command_dma);\r\nif (ha->scbs == NULL)\r\nreturn 0;\r\nips_sg.list =\r\npci_alloc_consistent(ha->pcidev,\r\nIPS_SGLIST_SIZE(ha) * IPS_MAX_SG *\r\nha->max_cmds, &sg_dma);\r\nif (ips_sg.list == NULL) {\r\npci_free_consistent(ha->pcidev,\r\nha->max_cmds * sizeof (ips_scb_t), ha->scbs,\r\ncommand_dma);\r\nreturn 0;\r\n}\r\nmemset(ha->scbs, 0, ha->max_cmds * sizeof (ips_scb_t));\r\nfor (i = 0; i < ha->max_cmds; i++) {\r\nscb_p = &ha->scbs[i];\r\nscb_p->scb_busaddr = command_dma + sizeof (ips_scb_t) * i;\r\nif (IPS_USE_ENH_SGLIST(ha)) {\r\nscb_p->sg_list.enh_list =\r\nips_sg.enh_list + i * IPS_MAX_SG;\r\nscb_p->sg_busaddr =\r\nsg_dma + IPS_SGLIST_SIZE(ha) * IPS_MAX_SG * i;\r\n} else {\r\nscb_p->sg_list.std_list =\r\nips_sg.std_list + i * IPS_MAX_SG;\r\nscb_p->sg_busaddr =\r\nsg_dma + IPS_SGLIST_SIZE(ha) * IPS_MAX_SG * i;\r\n}\r\nif (i < ha->max_cmds - 1) {\r\nscb_p->q_next = ha->scb_freelist;\r\nha->scb_freelist = scb_p;\r\n}\r\n}\r\nreturn (1);\r\n}\r\nstatic void\r\nips_init_scb(ips_ha_t * ha, ips_scb_t * scb)\r\n{\r\nIPS_SG_LIST sg_list;\r\nuint32_t cmd_busaddr, sg_busaddr;\r\nMETHOD_TRACE("ips_init_scb", 1);\r\nif (scb == NULL)\r\nreturn;\r\nsg_list.list = scb->sg_list.list;\r\ncmd_busaddr = scb->scb_busaddr;\r\nsg_busaddr = scb->sg_busaddr;\r\nmemset(scb, 0, sizeof (ips_scb_t));\r\nmemset(ha->dummy, 0, sizeof (IPS_IO_CMD));\r\nha->dummy->op_code = 0xFF;\r\nha->dummy->ccsar = cpu_to_le32(ha->adapt->hw_status_start\r\n+ sizeof (IPS_ADAPTER));\r\nha->dummy->command_id = IPS_MAX_CMDS;\r\nscb->scb_busaddr = cmd_busaddr;\r\nscb->sg_busaddr = sg_busaddr;\r\nscb->sg_list.list = sg_list.list;\r\nscb->cmd.basic_io.cccr = cpu_to_le32((uint32_t) IPS_BIT_ILE);\r\nscb->cmd.basic_io.ccsar = cpu_to_le32(ha->adapt->hw_status_start\r\n+ sizeof (IPS_ADAPTER));\r\n}\r\nstatic ips_scb_t *\r\nips_getscb(ips_ha_t * ha)\r\n{\r\nips_scb_t *scb;\r\nMETHOD_TRACE("ips_getscb", 1);\r\nif ((scb = ha->scb_freelist) == NULL) {\r\nreturn (NULL);\r\n}\r\nha->scb_freelist = scb->q_next;\r\nscb->flags = 0;\r\nscb->q_next = NULL;\r\nips_init_scb(ha, scb);\r\nreturn (scb);\r\n}\r\nstatic void\r\nips_freescb(ips_ha_t * ha, ips_scb_t * scb)\r\n{\r\nMETHOD_TRACE("ips_freescb", 1);\r\nif (scb->flags & IPS_SCB_MAP_SG)\r\nscsi_dma_unmap(scb->scsi_cmd);\r\nelse if (scb->flags & IPS_SCB_MAP_SINGLE)\r\npci_unmap_single(ha->pcidev, scb->data_busaddr, scb->data_len,\r\nIPS_DMA_DIR(scb));\r\nif (IPS_COMMAND_ID(ha, scb) < (ha->max_cmds - 1)) {\r\nscb->q_next = ha->scb_freelist;\r\nha->scb_freelist = scb;\r\n}\r\n}\r\nstatic int\r\nips_isinit_copperhead(ips_ha_t * ha)\r\n{\r\nuint8_t scpr;\r\nuint8_t isr;\r\nMETHOD_TRACE("ips_isinit_copperhead", 1);\r\nisr = inb(ha->io_addr + IPS_REG_HISR);\r\nscpr = inb(ha->io_addr + IPS_REG_SCPR);\r\nif (((isr & IPS_BIT_EI) == 0) && ((scpr & IPS_BIT_EBM) == 0))\r\nreturn (0);\r\nelse\r\nreturn (1);\r\n}\r\nstatic int\r\nips_isinit_copperhead_memio(ips_ha_t * ha)\r\n{\r\nuint8_t isr = 0;\r\nuint8_t scpr;\r\nMETHOD_TRACE("ips_is_init_copperhead_memio", 1);\r\nisr = readb(ha->mem_ptr + IPS_REG_HISR);\r\nscpr = readb(ha->mem_ptr + IPS_REG_SCPR);\r\nif (((isr & IPS_BIT_EI) == 0) && ((scpr & IPS_BIT_EBM) == 0))\r\nreturn (0);\r\nelse\r\nreturn (1);\r\n}\r\nstatic int\r\nips_isinit_morpheus(ips_ha_t * ha)\r\n{\r\nuint32_t post;\r\nuint32_t bits;\r\nMETHOD_TRACE("ips_is_init_morpheus", 1);\r\nif (ips_isintr_morpheus(ha))\r\nips_flush_and_reset(ha);\r\npost = readl(ha->mem_ptr + IPS_REG_I960_MSG0);\r\nbits = readl(ha->mem_ptr + IPS_REG_I2O_HIR);\r\nif (post == 0)\r\nreturn (0);\r\nelse if (bits & 0x3)\r\nreturn (0);\r\nelse\r\nreturn (1);\r\n}\r\nstatic void\r\nips_flush_and_reset(ips_ha_t *ha)\r\n{\r\nips_scb_t *scb;\r\nint ret;\r\nint time;\r\nint done;\r\ndma_addr_t command_dma;\r\nscb = pci_alloc_consistent(ha->pcidev, sizeof(ips_scb_t), &command_dma);\r\nif (scb) {\r\nmemset(scb, 0, sizeof(ips_scb_t));\r\nips_init_scb(ha, scb);\r\nscb->scb_busaddr = command_dma;\r\nscb->timeout = ips_cmd_timeout;\r\nscb->cdb[0] = IPS_CMD_FLUSH;\r\nscb->cmd.flush_cache.op_code = IPS_CMD_FLUSH;\r\nscb->cmd.flush_cache.command_id = IPS_MAX_CMDS;\r\nscb->cmd.flush_cache.state = IPS_NORM_STATE;\r\nscb->cmd.flush_cache.reserved = 0;\r\nscb->cmd.flush_cache.reserved2 = 0;\r\nscb->cmd.flush_cache.reserved3 = 0;\r\nscb->cmd.flush_cache.reserved4 = 0;\r\nret = ips_send_cmd(ha, scb);\r\nif (ret == IPS_SUCCESS) {\r\ntime = 60 * IPS_ONE_SEC;\r\ndone = 0;\r\nwhile ((time > 0) && (!done)) {\r\ndone = ips_poll_for_flush_complete(ha);\r\nudelay(1000);\r\ntime--;\r\n}\r\n}\r\n}\r\n(*ha->func.reset) (ha);\r\npci_free_consistent(ha->pcidev, sizeof(ips_scb_t), scb, command_dma);\r\nreturn;\r\n}\r\nstatic int\r\nips_poll_for_flush_complete(ips_ha_t * ha)\r\n{\r\nIPS_STATUS cstatus;\r\nwhile (TRUE) {\r\ncstatus.value = (*ha->func.statupd) (ha);\r\nif (cstatus.value == 0xffffffff)\r\nbreak;\r\nif (cstatus.fields.command_id == IPS_MAX_CMDS)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nips_enable_int_copperhead(ips_ha_t * ha)\r\n{\r\nMETHOD_TRACE("ips_enable_int_copperhead", 1);\r\noutb(ha->io_addr + IPS_REG_HISR, IPS_BIT_EI);\r\ninb(ha->io_addr + IPS_REG_HISR);\r\n}\r\nstatic void\r\nips_enable_int_copperhead_memio(ips_ha_t * ha)\r\n{\r\nMETHOD_TRACE("ips_enable_int_copperhead_memio", 1);\r\nwriteb(IPS_BIT_EI, ha->mem_ptr + IPS_REG_HISR);\r\nreadb(ha->mem_ptr + IPS_REG_HISR);\r\n}\r\nstatic void\r\nips_enable_int_morpheus(ips_ha_t * ha)\r\n{\r\nuint32_t Oimr;\r\nMETHOD_TRACE("ips_enable_int_morpheus", 1);\r\nOimr = readl(ha->mem_ptr + IPS_REG_I960_OIMR);\r\nOimr &= ~0x08;\r\nwritel(Oimr, ha->mem_ptr + IPS_REG_I960_OIMR);\r\nreadl(ha->mem_ptr + IPS_REG_I960_OIMR);\r\n}\r\nstatic int\r\nips_init_copperhead(ips_ha_t * ha)\r\n{\r\nuint8_t Isr;\r\nuint8_t Cbsp;\r\nuint8_t PostByte[IPS_MAX_POST_BYTES];\r\nuint8_t ConfigByte[IPS_MAX_CONFIG_BYTES];\r\nint i, j;\r\nMETHOD_TRACE("ips_init_copperhead", 1);\r\nfor (i = 0; i < IPS_MAX_POST_BYTES; i++) {\r\nfor (j = 0; j < 45; j++) {\r\nIsr = inb(ha->io_addr + IPS_REG_HISR);\r\nif (Isr & IPS_BIT_GHI)\r\nbreak;\r\nMDELAY(IPS_ONE_SEC);\r\n}\r\nif (j >= 45)\r\nreturn (0);\r\nPostByte[i] = inb(ha->io_addr + IPS_REG_ISPR);\r\noutb(Isr, ha->io_addr + IPS_REG_HISR);\r\n}\r\nif (PostByte[0] < IPS_GOOD_POST_STATUS) {\r\nIPS_PRINTK(KERN_WARNING, ha->pcidev,\r\n"reset controller fails (post status %x %x).\n",\r\nPostByte[0], PostByte[1]);\r\nreturn (0);\r\n}\r\nfor (i = 0; i < IPS_MAX_CONFIG_BYTES; i++) {\r\nfor (j = 0; j < 240; j++) {\r\nIsr = inb(ha->io_addr + IPS_REG_HISR);\r\nif (Isr & IPS_BIT_GHI)\r\nbreak;\r\nMDELAY(IPS_ONE_SEC);\r\n}\r\nif (j >= 240)\r\nreturn (0);\r\nConfigByte[i] = inb(ha->io_addr + IPS_REG_ISPR);\r\noutb(Isr, ha->io_addr + IPS_REG_HISR);\r\n}\r\nfor (i = 0; i < 240; i++) {\r\nCbsp = inb(ha->io_addr + IPS_REG_CBSP);\r\nif ((Cbsp & IPS_BIT_OP) == 0)\r\nbreak;\r\nMDELAY(IPS_ONE_SEC);\r\n}\r\nif (i >= 240)\r\nreturn (0);\r\noutl(0x1010, ha->io_addr + IPS_REG_CCCR);\r\noutb(IPS_BIT_EBM, ha->io_addr + IPS_REG_SCPR);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\noutl(0, ha->io_addr + IPS_REG_NDAE);\r\noutb(IPS_BIT_EI, ha->io_addr + IPS_REG_HISR);\r\nreturn (1);\r\n}\r\nstatic int\r\nips_init_copperhead_memio(ips_ha_t * ha)\r\n{\r\nuint8_t Isr = 0;\r\nuint8_t Cbsp;\r\nuint8_t PostByte[IPS_MAX_POST_BYTES];\r\nuint8_t ConfigByte[IPS_MAX_CONFIG_BYTES];\r\nint i, j;\r\nMETHOD_TRACE("ips_init_copperhead_memio", 1);\r\nfor (i = 0; i < IPS_MAX_POST_BYTES; i++) {\r\nfor (j = 0; j < 45; j++) {\r\nIsr = readb(ha->mem_ptr + IPS_REG_HISR);\r\nif (Isr & IPS_BIT_GHI)\r\nbreak;\r\nMDELAY(IPS_ONE_SEC);\r\n}\r\nif (j >= 45)\r\nreturn (0);\r\nPostByte[i] = readb(ha->mem_ptr + IPS_REG_ISPR);\r\nwriteb(Isr, ha->mem_ptr + IPS_REG_HISR);\r\n}\r\nif (PostByte[0] < IPS_GOOD_POST_STATUS) {\r\nIPS_PRINTK(KERN_WARNING, ha->pcidev,\r\n"reset controller fails (post status %x %x).\n",\r\nPostByte[0], PostByte[1]);\r\nreturn (0);\r\n}\r\nfor (i = 0; i < IPS_MAX_CONFIG_BYTES; i++) {\r\nfor (j = 0; j < 240; j++) {\r\nIsr = readb(ha->mem_ptr + IPS_REG_HISR);\r\nif (Isr & IPS_BIT_GHI)\r\nbreak;\r\nMDELAY(IPS_ONE_SEC);\r\n}\r\nif (j >= 240)\r\nreturn (0);\r\nConfigByte[i] = readb(ha->mem_ptr + IPS_REG_ISPR);\r\nwriteb(Isr, ha->mem_ptr + IPS_REG_HISR);\r\n}\r\nfor (i = 0; i < 240; i++) {\r\nCbsp = readb(ha->mem_ptr + IPS_REG_CBSP);\r\nif ((Cbsp & IPS_BIT_OP) == 0)\r\nbreak;\r\nMDELAY(IPS_ONE_SEC);\r\n}\r\nif (i >= 240)\r\nreturn (0);\r\nwritel(0x1010, ha->mem_ptr + IPS_REG_CCCR);\r\nwriteb(IPS_BIT_EBM, ha->mem_ptr + IPS_REG_SCPR);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nwritel(0, ha->mem_ptr + IPS_REG_NDAE);\r\nwriteb(IPS_BIT_EI, ha->mem_ptr + IPS_REG_HISR);\r\nreturn (1);\r\n}\r\nstatic int\r\nips_init_morpheus(ips_ha_t * ha)\r\n{\r\nuint32_t Post;\r\nuint32_t Config;\r\nuint32_t Isr;\r\nuint32_t Oimr;\r\nint i;\r\nMETHOD_TRACE("ips_init_morpheus", 1);\r\nfor (i = 0; i < 45; i++) {\r\nIsr = readl(ha->mem_ptr + IPS_REG_I2O_HIR);\r\nif (Isr & IPS_BIT_I960_MSG0I)\r\nbreak;\r\nMDELAY(IPS_ONE_SEC);\r\n}\r\nif (i >= 45) {\r\nIPS_PRINTK(KERN_WARNING, ha->pcidev,\r\n"timeout waiting for post.\n");\r\nreturn (0);\r\n}\r\nPost = readl(ha->mem_ptr + IPS_REG_I960_MSG0);\r\nif (Post == 0x4F00) {\r\nIPS_PRINTK(KERN_WARNING, ha->pcidev,\r\n"Flashing Battery PIC, Please wait ...\n");\r\nIsr = (uint32_t) IPS_BIT_I960_MSG0I;\r\nwritel(Isr, ha->mem_ptr + IPS_REG_I2O_HIR);\r\nfor (i = 0; i < 120; i++) {\r\nPost = readl(ha->mem_ptr + IPS_REG_I960_MSG0);\r\nif (Post != 0x4F00)\r\nbreak;\r\nMDELAY(IPS_ONE_SEC);\r\n}\r\nif (i >= 120) {\r\nIPS_PRINTK(KERN_WARNING, ha->pcidev,\r\n"timeout waiting for Battery PIC Flash\n");\r\nreturn (0);\r\n}\r\n}\r\nIsr = (uint32_t) IPS_BIT_I960_MSG0I;\r\nwritel(Isr, ha->mem_ptr + IPS_REG_I2O_HIR);\r\nif (Post < (IPS_GOOD_POST_STATUS << 8)) {\r\nIPS_PRINTK(KERN_WARNING, ha->pcidev,\r\n"reset controller fails (post status %x).\n", Post);\r\nreturn (0);\r\n}\r\nfor (i = 0; i < 240; i++) {\r\nIsr = readl(ha->mem_ptr + IPS_REG_I2O_HIR);\r\nif (Isr & IPS_BIT_I960_MSG1I)\r\nbreak;\r\nMDELAY(IPS_ONE_SEC);\r\n}\r\nif (i >= 240) {\r\nIPS_PRINTK(KERN_WARNING, ha->pcidev,\r\n"timeout waiting for config.\n");\r\nreturn (0);\r\n}\r\nConfig = readl(ha->mem_ptr + IPS_REG_I960_MSG1);\r\nIsr = (uint32_t) IPS_BIT_I960_MSG1I;\r\nwritel(Isr, ha->mem_ptr + IPS_REG_I2O_HIR);\r\nOimr = readl(ha->mem_ptr + IPS_REG_I960_OIMR);\r\nOimr &= ~0x8;\r\nwritel(Oimr, ha->mem_ptr + IPS_REG_I960_OIMR);\r\nif (Post == 0xEF10) {\r\nif ((Config == 0x000F) || (Config == 0x0009))\r\nha->requires_esl = 1;\r\n}\r\nreturn (1);\r\n}\r\nstatic int\r\nips_reset_copperhead(ips_ha_t * ha)\r\n{\r\nint reset_counter;\r\nMETHOD_TRACE("ips_reset_copperhead", 1);\r\nDEBUG_VAR(1, "(%s%d) ips_reset_copperhead: io addr: %x, irq: %d",\r\nips_name, ha->host_num, ha->io_addr, ha->pcidev->irq);\r\nreset_counter = 0;\r\nwhile (reset_counter < 2) {\r\nreset_counter++;\r\noutb(IPS_BIT_RST, ha->io_addr + IPS_REG_SCPR);\r\nMDELAY(IPS_ONE_SEC);\r\noutb(0, ha->io_addr + IPS_REG_SCPR);\r\nMDELAY(IPS_ONE_SEC);\r\nif ((*ha->func.init) (ha))\r\nbreak;\r\nelse if (reset_counter >= 2) {\r\nreturn (0);\r\n}\r\n}\r\nreturn (1);\r\n}\r\nstatic int\r\nips_reset_copperhead_memio(ips_ha_t * ha)\r\n{\r\nint reset_counter;\r\nMETHOD_TRACE("ips_reset_copperhead_memio", 1);\r\nDEBUG_VAR(1, "(%s%d) ips_reset_copperhead_memio: mem addr: %x, irq: %d",\r\nips_name, ha->host_num, ha->mem_addr, ha->pcidev->irq);\r\nreset_counter = 0;\r\nwhile (reset_counter < 2) {\r\nreset_counter++;\r\nwriteb(IPS_BIT_RST, ha->mem_ptr + IPS_REG_SCPR);\r\nMDELAY(IPS_ONE_SEC);\r\nwriteb(0, ha->mem_ptr + IPS_REG_SCPR);\r\nMDELAY(IPS_ONE_SEC);\r\nif ((*ha->func.init) (ha))\r\nbreak;\r\nelse if (reset_counter >= 2) {\r\nreturn (0);\r\n}\r\n}\r\nreturn (1);\r\n}\r\nstatic int\r\nips_reset_morpheus(ips_ha_t * ha)\r\n{\r\nint reset_counter;\r\nuint8_t junk;\r\nMETHOD_TRACE("ips_reset_morpheus", 1);\r\nDEBUG_VAR(1, "(%s%d) ips_reset_morpheus: mem addr: %x, irq: %d",\r\nips_name, ha->host_num, ha->mem_addr, ha->pcidev->irq);\r\nreset_counter = 0;\r\nwhile (reset_counter < 2) {\r\nreset_counter++;\r\nwritel(0x80000000, ha->mem_ptr + IPS_REG_I960_IDR);\r\nMDELAY(5 * IPS_ONE_SEC);\r\npci_read_config_byte(ha->pcidev, 4, &junk);\r\nif ((*ha->func.init) (ha))\r\nbreak;\r\nelse if (reset_counter >= 2) {\r\nreturn (0);\r\n}\r\n}\r\nreturn (1);\r\n}\r\nstatic void\r\nips_statinit(ips_ha_t * ha)\r\n{\r\nuint32_t phys_status_start;\r\nMETHOD_TRACE("ips_statinit", 1);\r\nha->adapt->p_status_start = ha->adapt->status;\r\nha->adapt->p_status_end = ha->adapt->status + IPS_MAX_CMDS;\r\nha->adapt->p_status_tail = ha->adapt->status;\r\nphys_status_start = ha->adapt->hw_status_start;\r\noutl(phys_status_start, ha->io_addr + IPS_REG_SQSR);\r\noutl(phys_status_start + IPS_STATUS_Q_SIZE,\r\nha->io_addr + IPS_REG_SQER);\r\noutl(phys_status_start + IPS_STATUS_SIZE,\r\nha->io_addr + IPS_REG_SQHR);\r\noutl(phys_status_start, ha->io_addr + IPS_REG_SQTR);\r\nha->adapt->hw_status_tail = phys_status_start;\r\n}\r\nstatic void\r\nips_statinit_memio(ips_ha_t * ha)\r\n{\r\nuint32_t phys_status_start;\r\nMETHOD_TRACE("ips_statinit_memio", 1);\r\nha->adapt->p_status_start = ha->adapt->status;\r\nha->adapt->p_status_end = ha->adapt->status + IPS_MAX_CMDS;\r\nha->adapt->p_status_tail = ha->adapt->status;\r\nphys_status_start = ha->adapt->hw_status_start;\r\nwritel(phys_status_start, ha->mem_ptr + IPS_REG_SQSR);\r\nwritel(phys_status_start + IPS_STATUS_Q_SIZE,\r\nha->mem_ptr + IPS_REG_SQER);\r\nwritel(phys_status_start + IPS_STATUS_SIZE, ha->mem_ptr + IPS_REG_SQHR);\r\nwritel(phys_status_start, ha->mem_ptr + IPS_REG_SQTR);\r\nha->adapt->hw_status_tail = phys_status_start;\r\n}\r\nstatic uint32_t\r\nips_statupd_copperhead(ips_ha_t * ha)\r\n{\r\nMETHOD_TRACE("ips_statupd_copperhead", 1);\r\nif (ha->adapt->p_status_tail != ha->adapt->p_status_end) {\r\nha->adapt->p_status_tail++;\r\nha->adapt->hw_status_tail += sizeof (IPS_STATUS);\r\n} else {\r\nha->adapt->p_status_tail = ha->adapt->p_status_start;\r\nha->adapt->hw_status_tail = ha->adapt->hw_status_start;\r\n}\r\noutl(ha->adapt->hw_status_tail,\r\nha->io_addr + IPS_REG_SQTR);\r\nreturn (ha->adapt->p_status_tail->value);\r\n}\r\nstatic uint32_t\r\nips_statupd_copperhead_memio(ips_ha_t * ha)\r\n{\r\nMETHOD_TRACE("ips_statupd_copperhead_memio", 1);\r\nif (ha->adapt->p_status_tail != ha->adapt->p_status_end) {\r\nha->adapt->p_status_tail++;\r\nha->adapt->hw_status_tail += sizeof (IPS_STATUS);\r\n} else {\r\nha->adapt->p_status_tail = ha->adapt->p_status_start;\r\nha->adapt->hw_status_tail = ha->adapt->hw_status_start;\r\n}\r\nwritel(ha->adapt->hw_status_tail, ha->mem_ptr + IPS_REG_SQTR);\r\nreturn (ha->adapt->p_status_tail->value);\r\n}\r\nstatic uint32_t\r\nips_statupd_morpheus(ips_ha_t * ha)\r\n{\r\nuint32_t val;\r\nMETHOD_TRACE("ips_statupd_morpheus", 1);\r\nval = readl(ha->mem_ptr + IPS_REG_I2O_OUTMSGQ);\r\nreturn (val);\r\n}\r\nstatic int\r\nips_issue_copperhead(ips_ha_t * ha, ips_scb_t * scb)\r\n{\r\nuint32_t TimeOut;\r\nuint32_t val;\r\nMETHOD_TRACE("ips_issue_copperhead", 1);\r\nif (scb->scsi_cmd) {\r\nDEBUG_VAR(2, "(%s%d) ips_issue: cmd 0x%X id %d (%d %d %d)",\r\nips_name,\r\nha->host_num,\r\nscb->cdb[0],\r\nscb->cmd.basic_io.command_id,\r\nscb->bus, scb->target_id, scb->lun);\r\n} else {\r\nDEBUG_VAR(2, KERN_NOTICE "(%s%d) ips_issue: logical cmd id %d",\r\nips_name, ha->host_num, scb->cmd.basic_io.command_id);\r\n}\r\nTimeOut = 0;\r\nwhile ((val =\r\nle32_to_cpu(inl(ha->io_addr + IPS_REG_CCCR))) & IPS_BIT_SEM) {\r\nudelay(1000);\r\nif (++TimeOut >= IPS_SEM_TIMEOUT) {\r\nif (!(val & IPS_BIT_START_STOP))\r\nbreak;\r\nIPS_PRINTK(KERN_WARNING, ha->pcidev,\r\n"ips_issue val [0x%x].\n", val);\r\nIPS_PRINTK(KERN_WARNING, ha->pcidev,\r\n"ips_issue semaphore chk timeout.\n");\r\nreturn (IPS_FAILURE);\r\n}\r\n}\r\noutl(scb->scb_busaddr, ha->io_addr + IPS_REG_CCSAR);\r\noutw(IPS_BIT_START_CMD, ha->io_addr + IPS_REG_CCCR);\r\nreturn (IPS_SUCCESS);\r\n}\r\nstatic int\r\nips_issue_copperhead_memio(ips_ha_t * ha, ips_scb_t * scb)\r\n{\r\nuint32_t TimeOut;\r\nuint32_t val;\r\nMETHOD_TRACE("ips_issue_copperhead_memio", 1);\r\nif (scb->scsi_cmd) {\r\nDEBUG_VAR(2, "(%s%d) ips_issue: cmd 0x%X id %d (%d %d %d)",\r\nips_name,\r\nha->host_num,\r\nscb->cdb[0],\r\nscb->cmd.basic_io.command_id,\r\nscb->bus, scb->target_id, scb->lun);\r\n} else {\r\nDEBUG_VAR(2, "(%s%d) ips_issue: logical cmd id %d",\r\nips_name, ha->host_num, scb->cmd.basic_io.command_id);\r\n}\r\nTimeOut = 0;\r\nwhile ((val = readl(ha->mem_ptr + IPS_REG_CCCR)) & IPS_BIT_SEM) {\r\nudelay(1000);\r\nif (++TimeOut >= IPS_SEM_TIMEOUT) {\r\nif (!(val & IPS_BIT_START_STOP))\r\nbreak;\r\nIPS_PRINTK(KERN_WARNING, ha->pcidev,\r\n"ips_issue val [0x%x].\n", val);\r\nIPS_PRINTK(KERN_WARNING, ha->pcidev,\r\n"ips_issue semaphore chk timeout.\n");\r\nreturn (IPS_FAILURE);\r\n}\r\n}\r\nwritel(scb->scb_busaddr, ha->mem_ptr + IPS_REG_CCSAR);\r\nwritel(IPS_BIT_START_CMD, ha->mem_ptr + IPS_REG_CCCR);\r\nreturn (IPS_SUCCESS);\r\n}\r\nstatic int\r\nips_issue_i2o(ips_ha_t * ha, ips_scb_t * scb)\r\n{\r\nMETHOD_TRACE("ips_issue_i2o", 1);\r\nif (scb->scsi_cmd) {\r\nDEBUG_VAR(2, "(%s%d) ips_issue: cmd 0x%X id %d (%d %d %d)",\r\nips_name,\r\nha->host_num,\r\nscb->cdb[0],\r\nscb->cmd.basic_io.command_id,\r\nscb->bus, scb->target_id, scb->lun);\r\n} else {\r\nDEBUG_VAR(2, "(%s%d) ips_issue: logical cmd id %d",\r\nips_name, ha->host_num, scb->cmd.basic_io.command_id);\r\n}\r\noutl(scb->scb_busaddr, ha->io_addr + IPS_REG_I2O_INMSGQ);\r\nreturn (IPS_SUCCESS);\r\n}\r\nstatic int\r\nips_issue_i2o_memio(ips_ha_t * ha, ips_scb_t * scb)\r\n{\r\nMETHOD_TRACE("ips_issue_i2o_memio", 1);\r\nif (scb->scsi_cmd) {\r\nDEBUG_VAR(2, "(%s%d) ips_issue: cmd 0x%X id %d (%d %d %d)",\r\nips_name,\r\nha->host_num,\r\nscb->cdb[0],\r\nscb->cmd.basic_io.command_id,\r\nscb->bus, scb->target_id, scb->lun);\r\n} else {\r\nDEBUG_VAR(2, "(%s%d) ips_issue: logical cmd id %d",\r\nips_name, ha->host_num, scb->cmd.basic_io.command_id);\r\n}\r\nwritel(scb->scb_busaddr, ha->mem_ptr + IPS_REG_I2O_INMSGQ);\r\nreturn (IPS_SUCCESS);\r\n}\r\nstatic int\r\nips_isintr_copperhead(ips_ha_t * ha)\r\n{\r\nuint8_t Isr;\r\nMETHOD_TRACE("ips_isintr_copperhead", 2);\r\nIsr = inb(ha->io_addr + IPS_REG_HISR);\r\nif (Isr == 0xFF)\r\nreturn (0);\r\nif (Isr & IPS_BIT_SCE)\r\nreturn (1);\r\nelse if (Isr & (IPS_BIT_SQO | IPS_BIT_GHI)) {\r\noutb(Isr, ha->io_addr + IPS_REG_HISR);\r\n}\r\nreturn (0);\r\n}\r\nstatic int\r\nips_isintr_copperhead_memio(ips_ha_t * ha)\r\n{\r\nuint8_t Isr;\r\nMETHOD_TRACE("ips_isintr_memio", 2);\r\nIsr = readb(ha->mem_ptr + IPS_REG_HISR);\r\nif (Isr == 0xFF)\r\nreturn (0);\r\nif (Isr & IPS_BIT_SCE)\r\nreturn (1);\r\nelse if (Isr & (IPS_BIT_SQO | IPS_BIT_GHI)) {\r\nwriteb(Isr, ha->mem_ptr + IPS_REG_HISR);\r\n}\r\nreturn (0);\r\n}\r\nstatic int\r\nips_isintr_morpheus(ips_ha_t * ha)\r\n{\r\nuint32_t Isr;\r\nMETHOD_TRACE("ips_isintr_morpheus", 2);\r\nIsr = readl(ha->mem_ptr + IPS_REG_I2O_HIR);\r\nif (Isr & IPS_BIT_I2O_OPQI)\r\nreturn (1);\r\nelse\r\nreturn (0);\r\n}\r\nstatic int\r\nips_wait(ips_ha_t * ha, int time, int intr)\r\n{\r\nint ret;\r\nint done;\r\nMETHOD_TRACE("ips_wait", 1);\r\nret = IPS_FAILURE;\r\ndone = FALSE;\r\ntime *= IPS_ONE_SEC;\r\nwhile ((time > 0) && (!done)) {\r\nif (intr == IPS_INTR_ON) {\r\nif (ha->waitflag == FALSE) {\r\nret = IPS_SUCCESS;\r\ndone = TRUE;\r\nbreak;\r\n}\r\n} else if (intr == IPS_INTR_IORL) {\r\nif (ha->waitflag == FALSE) {\r\nret = IPS_SUCCESS;\r\ndone = TRUE;\r\nbreak;\r\n}\r\n(*ha->func.intr) (ha);\r\n}\r\nudelay(1000);\r\ntime--;\r\n}\r\nreturn (ret);\r\n}\r\nstatic int\r\nips_write_driver_status(ips_ha_t * ha, int intr)\r\n{\r\nMETHOD_TRACE("ips_write_driver_status", 1);\r\nif (!ips_readwrite_page5(ha, FALSE, intr)) {\r\nIPS_PRINTK(KERN_WARNING, ha->pcidev,\r\n"unable to read NVRAM page 5.\n");\r\nreturn (0);\r\n}\r\nif (le32_to_cpu(ha->nvram->signature) != IPS_NVRAM_P5_SIG) {\r\nDEBUG_VAR(1,\r\n"(%s%d) NVRAM page 5 has an invalid signature: %X.",\r\nips_name, ha->host_num, ha->nvram->signature);\r\nha->nvram->signature = IPS_NVRAM_P5_SIG;\r\n}\r\nDEBUG_VAR(2,\r\n"(%s%d) Ad Type: %d, Ad Slot: %d, BIOS: %c%c%c%c %c%c%c%c.",\r\nips_name, ha->host_num, le16_to_cpu(ha->nvram->adapter_type),\r\nha->nvram->adapter_slot, ha->nvram->bios_high[0],\r\nha->nvram->bios_high[1], ha->nvram->bios_high[2],\r\nha->nvram->bios_high[3], ha->nvram->bios_low[0],\r\nha->nvram->bios_low[1], ha->nvram->bios_low[2],\r\nha->nvram->bios_low[3]);\r\nips_get_bios_version(ha, intr);\r\nha->nvram->operating_system = IPS_OS_LINUX;\r\nha->nvram->adapter_type = ha->ad_type;\r\nstrncpy((char *) ha->nvram->driver_high, IPS_VERSION_HIGH, 4);\r\nstrncpy((char *) ha->nvram->driver_low, IPS_VERSION_LOW, 4);\r\nstrncpy((char *) ha->nvram->bios_high, ha->bios_version, 4);\r\nstrncpy((char *) ha->nvram->bios_low, ha->bios_version + 4, 4);\r\nha->nvram->versioning = 0;\r\nif (!ips_readwrite_page5(ha, TRUE, intr)) {\r\nIPS_PRINTK(KERN_WARNING, ha->pcidev,\r\n"unable to write NVRAM page 5.\n");\r\nreturn (0);\r\n}\r\nha->slot_num = ha->nvram->adapter_slot;\r\nreturn (1);\r\n}\r\nstatic int\r\nips_read_adapter_status(ips_ha_t * ha, int intr)\r\n{\r\nips_scb_t *scb;\r\nint ret;\r\nMETHOD_TRACE("ips_read_adapter_status", 1);\r\nscb = &ha->scbs[ha->max_cmds - 1];\r\nips_init_scb(ha, scb);\r\nscb->timeout = ips_cmd_timeout;\r\nscb->cdb[0] = IPS_CMD_ENQUIRY;\r\nscb->cmd.basic_io.op_code = IPS_CMD_ENQUIRY;\r\nscb->cmd.basic_io.command_id = IPS_COMMAND_ID(ha, scb);\r\nscb->cmd.basic_io.sg_count = 0;\r\nscb->cmd.basic_io.lba = 0;\r\nscb->cmd.basic_io.sector_count = 0;\r\nscb->cmd.basic_io.log_drv = 0;\r\nscb->data_len = sizeof (*ha->enq);\r\nscb->cmd.basic_io.sg_addr = ha->enq_busaddr;\r\nif (((ret =\r\nips_send_wait(ha, scb, ips_cmd_timeout, intr)) == IPS_FAILURE)\r\n|| (ret == IPS_SUCCESS_IMM)\r\n|| ((scb->basic_status & IPS_GSC_STATUS_MASK) > 1))\r\nreturn (0);\r\nreturn (1);\r\n}\r\nstatic int\r\nips_read_subsystem_parameters(ips_ha_t * ha, int intr)\r\n{\r\nips_scb_t *scb;\r\nint ret;\r\nMETHOD_TRACE("ips_read_subsystem_parameters", 1);\r\nscb = &ha->scbs[ha->max_cmds - 1];\r\nips_init_scb(ha, scb);\r\nscb->timeout = ips_cmd_timeout;\r\nscb->cdb[0] = IPS_CMD_GET_SUBSYS;\r\nscb->cmd.basic_io.op_code = IPS_CMD_GET_SUBSYS;\r\nscb->cmd.basic_io.command_id = IPS_COMMAND_ID(ha, scb);\r\nscb->cmd.basic_io.sg_count = 0;\r\nscb->cmd.basic_io.lba = 0;\r\nscb->cmd.basic_io.sector_count = 0;\r\nscb->cmd.basic_io.log_drv = 0;\r\nscb->data_len = sizeof (*ha->subsys);\r\nscb->cmd.basic_io.sg_addr = ha->ioctl_busaddr;\r\nif (((ret =\r\nips_send_wait(ha, scb, ips_cmd_timeout, intr)) == IPS_FAILURE)\r\n|| (ret == IPS_SUCCESS_IMM)\r\n|| ((scb->basic_status & IPS_GSC_STATUS_MASK) > 1))\r\nreturn (0);\r\nmemcpy(ha->subsys, ha->ioctl_data, sizeof(*ha->subsys));\r\nreturn (1);\r\n}\r\nstatic int\r\nips_read_config(ips_ha_t * ha, int intr)\r\n{\r\nips_scb_t *scb;\r\nint i;\r\nint ret;\r\nMETHOD_TRACE("ips_read_config", 1);\r\nfor (i = 0; i < 4; i++)\r\nha->conf->init_id[i] = 7;\r\nscb = &ha->scbs[ha->max_cmds - 1];\r\nips_init_scb(ha, scb);\r\nscb->timeout = ips_cmd_timeout;\r\nscb->cdb[0] = IPS_CMD_READ_CONF;\r\nscb->cmd.basic_io.op_code = IPS_CMD_READ_CONF;\r\nscb->cmd.basic_io.command_id = IPS_COMMAND_ID(ha, scb);\r\nscb->data_len = sizeof (*ha->conf);\r\nscb->cmd.basic_io.sg_addr = ha->ioctl_busaddr;\r\nif (((ret =\r\nips_send_wait(ha, scb, ips_cmd_timeout, intr)) == IPS_FAILURE)\r\n|| (ret == IPS_SUCCESS_IMM)\r\n|| ((scb->basic_status & IPS_GSC_STATUS_MASK) > 1)) {\r\nmemset(ha->conf, 0, sizeof (IPS_CONF));\r\nfor (i = 0; i < 4; i++)\r\nha->conf->init_id[i] = 7;\r\nif ((scb->basic_status & IPS_GSC_STATUS_MASK) ==\r\nIPS_CMD_CMPLT_WERROR)\r\nreturn (1);\r\nreturn (0);\r\n}\r\nmemcpy(ha->conf, ha->ioctl_data, sizeof(*ha->conf));\r\nreturn (1);\r\n}\r\nstatic int\r\nips_readwrite_page5(ips_ha_t * ha, int write, int intr)\r\n{\r\nips_scb_t *scb;\r\nint ret;\r\nMETHOD_TRACE("ips_readwrite_page5", 1);\r\nscb = &ha->scbs[ha->max_cmds - 1];\r\nips_init_scb(ha, scb);\r\nscb->timeout = ips_cmd_timeout;\r\nscb->cdb[0] = IPS_CMD_RW_NVRAM_PAGE;\r\nscb->cmd.nvram.op_code = IPS_CMD_RW_NVRAM_PAGE;\r\nscb->cmd.nvram.command_id = IPS_COMMAND_ID(ha, scb);\r\nscb->cmd.nvram.page = 5;\r\nscb->cmd.nvram.write = write;\r\nscb->cmd.nvram.reserved = 0;\r\nscb->cmd.nvram.reserved2 = 0;\r\nscb->data_len = sizeof (*ha->nvram);\r\nscb->cmd.nvram.buffer_addr = ha->ioctl_busaddr;\r\nif (write)\r\nmemcpy(ha->ioctl_data, ha->nvram, sizeof(*ha->nvram));\r\nif (((ret =\r\nips_send_wait(ha, scb, ips_cmd_timeout, intr)) == IPS_FAILURE)\r\n|| (ret == IPS_SUCCESS_IMM)\r\n|| ((scb->basic_status & IPS_GSC_STATUS_MASK) > 1)) {\r\nmemset(ha->nvram, 0, sizeof (IPS_NVRAM_P5));\r\nreturn (0);\r\n}\r\nif (!write)\r\nmemcpy(ha->nvram, ha->ioctl_data, sizeof(*ha->nvram));\r\nreturn (1);\r\n}\r\nstatic int\r\nips_clear_adapter(ips_ha_t * ha, int intr)\r\n{\r\nips_scb_t *scb;\r\nint ret;\r\nMETHOD_TRACE("ips_clear_adapter", 1);\r\nscb = &ha->scbs[ha->max_cmds - 1];\r\nips_init_scb(ha, scb);\r\nscb->timeout = ips_reset_timeout;\r\nscb->cdb[0] = IPS_CMD_CONFIG_SYNC;\r\nscb->cmd.config_sync.op_code = IPS_CMD_CONFIG_SYNC;\r\nscb->cmd.config_sync.command_id = IPS_COMMAND_ID(ha, scb);\r\nscb->cmd.config_sync.channel = 0;\r\nscb->cmd.config_sync.source_target = IPS_POCL;\r\nscb->cmd.config_sync.reserved = 0;\r\nscb->cmd.config_sync.reserved2 = 0;\r\nscb->cmd.config_sync.reserved3 = 0;\r\nif (((ret =\r\nips_send_wait(ha, scb, ips_reset_timeout, intr)) == IPS_FAILURE)\r\n|| (ret == IPS_SUCCESS_IMM)\r\n|| ((scb->basic_status & IPS_GSC_STATUS_MASK) > 1))\r\nreturn (0);\r\nips_init_scb(ha, scb);\r\nscb->cdb[0] = IPS_CMD_ERROR_TABLE;\r\nscb->timeout = ips_reset_timeout;\r\nscb->cmd.unlock_stripe.op_code = IPS_CMD_ERROR_TABLE;\r\nscb->cmd.unlock_stripe.command_id = IPS_COMMAND_ID(ha, scb);\r\nscb->cmd.unlock_stripe.log_drv = 0;\r\nscb->cmd.unlock_stripe.control = IPS_CSL;\r\nscb->cmd.unlock_stripe.reserved = 0;\r\nscb->cmd.unlock_stripe.reserved2 = 0;\r\nscb->cmd.unlock_stripe.reserved3 = 0;\r\nif (((ret =\r\nips_send_wait(ha, scb, ips_cmd_timeout, intr)) == IPS_FAILURE)\r\n|| (ret == IPS_SUCCESS_IMM)\r\n|| ((scb->basic_status & IPS_GSC_STATUS_MASK) > 1))\r\nreturn (0);\r\nreturn (1);\r\n}\r\nstatic void\r\nips_ffdc_reset(ips_ha_t * ha, int intr)\r\n{\r\nips_scb_t *scb;\r\nMETHOD_TRACE("ips_ffdc_reset", 1);\r\nscb = &ha->scbs[ha->max_cmds - 1];\r\nips_init_scb(ha, scb);\r\nscb->timeout = ips_cmd_timeout;\r\nscb->cdb[0] = IPS_CMD_FFDC;\r\nscb->cmd.ffdc.op_code = IPS_CMD_FFDC;\r\nscb->cmd.ffdc.command_id = IPS_COMMAND_ID(ha, scb);\r\nscb->cmd.ffdc.reset_count = ha->reset_count;\r\nscb->cmd.ffdc.reset_type = 0x80;\r\nips_fix_ffdc_time(ha, scb, ha->last_ffdc);\r\nips_send_wait(ha, scb, ips_cmd_timeout, intr);\r\n}\r\nstatic void\r\nips_ffdc_time(ips_ha_t * ha)\r\n{\r\nips_scb_t *scb;\r\nMETHOD_TRACE("ips_ffdc_time", 1);\r\nDEBUG_VAR(1, "(%s%d) Sending time update.", ips_name, ha->host_num);\r\nscb = &ha->scbs[ha->max_cmds - 1];\r\nips_init_scb(ha, scb);\r\nscb->timeout = ips_cmd_timeout;\r\nscb->cdb[0] = IPS_CMD_FFDC;\r\nscb->cmd.ffdc.op_code = IPS_CMD_FFDC;\r\nscb->cmd.ffdc.command_id = IPS_COMMAND_ID(ha, scb);\r\nscb->cmd.ffdc.reset_count = 0;\r\nscb->cmd.ffdc.reset_type = 0;\r\nips_fix_ffdc_time(ha, scb, ha->last_ffdc);\r\nips_send_wait(ha, scb, ips_cmd_timeout, IPS_FFDC);\r\n}\r\nstatic void\r\nips_fix_ffdc_time(ips_ha_t * ha, ips_scb_t * scb, time_t current_time)\r\n{\r\nlong days;\r\nlong rem;\r\nint i;\r\nint year;\r\nint yleap;\r\nint year_lengths[2] = { IPS_DAYS_NORMAL_YEAR, IPS_DAYS_LEAP_YEAR };\r\nint month_lengths[12][2] = { {31, 31},\r\n{28, 29},\r\n{31, 31},\r\n{30, 30},\r\n{31, 31},\r\n{30, 30},\r\n{31, 31},\r\n{31, 31},\r\n{30, 30},\r\n{31, 31},\r\n{30, 30},\r\n{31, 31}\r\n};\r\nMETHOD_TRACE("ips_fix_ffdc_time", 1);\r\ndays = current_time / IPS_SECS_DAY;\r\nrem = current_time % IPS_SECS_DAY;\r\nscb->cmd.ffdc.hour = (rem / IPS_SECS_HOUR);\r\nrem = rem % IPS_SECS_HOUR;\r\nscb->cmd.ffdc.minute = (rem / IPS_SECS_MIN);\r\nscb->cmd.ffdc.second = (rem % IPS_SECS_MIN);\r\nyear = IPS_EPOCH_YEAR;\r\nwhile (days < 0 || days >= year_lengths[yleap = IPS_IS_LEAP_YEAR(year)]) {\r\nint newy;\r\nnewy = year + (days / IPS_DAYS_NORMAL_YEAR);\r\nif (days < 0)\r\n--newy;\r\ndays -= (newy - year) * IPS_DAYS_NORMAL_YEAR +\r\nIPS_NUM_LEAP_YEARS_THROUGH(newy - 1) -\r\nIPS_NUM_LEAP_YEARS_THROUGH(year - 1);\r\nyear = newy;\r\n}\r\nscb->cmd.ffdc.yearH = year / 100;\r\nscb->cmd.ffdc.yearL = year % 100;\r\nfor (i = 0; days >= month_lengths[i][yleap]; ++i)\r\ndays -= month_lengths[i][yleap];\r\nscb->cmd.ffdc.month = i + 1;\r\nscb->cmd.ffdc.day = days + 1;\r\n}\r\nstatic int\r\nips_erase_bios(ips_ha_t * ha)\r\n{\r\nint timeout;\r\nuint8_t status = 0;\r\nMETHOD_TRACE("ips_erase_bios", 1);\r\nstatus = 0;\r\noutl(0, ha->io_addr + IPS_REG_FLAP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\noutb(0x50, ha->io_addr + IPS_REG_FLDP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\noutb(0x20, ha->io_addr + IPS_REG_FLDP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\noutb(0xD0, ha->io_addr + IPS_REG_FLDP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\noutb(0x70, ha->io_addr + IPS_REG_FLDP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\ntimeout = 80000;\r\nwhile (timeout > 0) {\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64) {\r\noutl(0, ha->io_addr + IPS_REG_FLAP);\r\nudelay(25);\r\n}\r\nstatus = inb(ha->io_addr + IPS_REG_FLDP);\r\nif (status & 0x80)\r\nbreak;\r\nMDELAY(1);\r\ntimeout--;\r\n}\r\nif (timeout <= 0) {\r\noutb(0xB0, ha->io_addr + IPS_REG_FLDP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\ntimeout = 10000;\r\nwhile (timeout > 0) {\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64) {\r\noutl(0, ha->io_addr + IPS_REG_FLAP);\r\nudelay(25);\r\n}\r\nstatus = inb(ha->io_addr + IPS_REG_FLDP);\r\nif (status & 0xC0)\r\nbreak;\r\nMDELAY(1);\r\ntimeout--;\r\n}\r\nreturn (1);\r\n}\r\nif (status & 0x08)\r\nreturn (1);\r\nif (status & 0x30)\r\nreturn (1);\r\noutb(0x50, ha->io_addr + IPS_REG_FLDP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\noutb(0xFF, ha->io_addr + IPS_REG_FLDP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\nreturn (0);\r\n}\r\nstatic int\r\nips_erase_bios_memio(ips_ha_t * ha)\r\n{\r\nint timeout;\r\nuint8_t status;\r\nMETHOD_TRACE("ips_erase_bios_memio", 1);\r\nstatus = 0;\r\nwritel(0, ha->mem_ptr + IPS_REG_FLAP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\nwriteb(0x50, ha->mem_ptr + IPS_REG_FLDP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\nwriteb(0x20, ha->mem_ptr + IPS_REG_FLDP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\nwriteb(0xD0, ha->mem_ptr + IPS_REG_FLDP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\nwriteb(0x70, ha->mem_ptr + IPS_REG_FLDP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\ntimeout = 80000;\r\nwhile (timeout > 0) {\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64) {\r\nwritel(0, ha->mem_ptr + IPS_REG_FLAP);\r\nudelay(25);\r\n}\r\nstatus = readb(ha->mem_ptr + IPS_REG_FLDP);\r\nif (status & 0x80)\r\nbreak;\r\nMDELAY(1);\r\ntimeout--;\r\n}\r\nif (timeout <= 0) {\r\nwriteb(0xB0, ha->mem_ptr + IPS_REG_FLDP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\ntimeout = 10000;\r\nwhile (timeout > 0) {\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64) {\r\nwritel(0, ha->mem_ptr + IPS_REG_FLAP);\r\nudelay(25);\r\n}\r\nstatus = readb(ha->mem_ptr + IPS_REG_FLDP);\r\nif (status & 0xC0)\r\nbreak;\r\nMDELAY(1);\r\ntimeout--;\r\n}\r\nreturn (1);\r\n}\r\nif (status & 0x08)\r\nreturn (1);\r\nif (status & 0x30)\r\nreturn (1);\r\nwriteb(0x50, ha->mem_ptr + IPS_REG_FLDP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\nwriteb(0xFF, ha->mem_ptr + IPS_REG_FLDP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\nreturn (0);\r\n}\r\nstatic int\r\nips_program_bios(ips_ha_t * ha, char *buffer, uint32_t buffersize,\r\nuint32_t offset)\r\n{\r\nint i;\r\nint timeout;\r\nuint8_t status = 0;\r\nMETHOD_TRACE("ips_program_bios", 1);\r\nstatus = 0;\r\nfor (i = 0; i < buffersize; i++) {\r\noutl(i + offset, ha->io_addr + IPS_REG_FLAP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\noutb(0x40, ha->io_addr + IPS_REG_FLDP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\noutb(buffer[i], ha->io_addr + IPS_REG_FLDP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\ntimeout = 1000;\r\nwhile (timeout > 0) {\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64) {\r\noutl(0, ha->io_addr + IPS_REG_FLAP);\r\nudelay(25);\r\n}\r\nstatus = inb(ha->io_addr + IPS_REG_FLDP);\r\nif (status & 0x80)\r\nbreak;\r\nMDELAY(1);\r\ntimeout--;\r\n}\r\nif (timeout == 0) {\r\noutl(0, ha->io_addr + IPS_REG_FLAP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\noutb(0xFF, ha->io_addr + IPS_REG_FLDP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\nreturn (1);\r\n}\r\nif (status & 0x18) {\r\noutl(0, ha->io_addr + IPS_REG_FLAP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\noutb(0xFF, ha->io_addr + IPS_REG_FLDP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\nreturn (1);\r\n}\r\n}\r\noutl(0, ha->io_addr + IPS_REG_FLAP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\noutb(0xFF, ha->io_addr + IPS_REG_FLDP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\nreturn (0);\r\n}\r\nstatic int\r\nips_program_bios_memio(ips_ha_t * ha, char *buffer, uint32_t buffersize,\r\nuint32_t offset)\r\n{\r\nint i;\r\nint timeout;\r\nuint8_t status = 0;\r\nMETHOD_TRACE("ips_program_bios_memio", 1);\r\nstatus = 0;\r\nfor (i = 0; i < buffersize; i++) {\r\nwritel(i + offset, ha->mem_ptr + IPS_REG_FLAP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\nwriteb(0x40, ha->mem_ptr + IPS_REG_FLDP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\nwriteb(buffer[i], ha->mem_ptr + IPS_REG_FLDP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\ntimeout = 1000;\r\nwhile (timeout > 0) {\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64) {\r\nwritel(0, ha->mem_ptr + IPS_REG_FLAP);\r\nudelay(25);\r\n}\r\nstatus = readb(ha->mem_ptr + IPS_REG_FLDP);\r\nif (status & 0x80)\r\nbreak;\r\nMDELAY(1);\r\ntimeout--;\r\n}\r\nif (timeout == 0) {\r\nwritel(0, ha->mem_ptr + IPS_REG_FLAP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\nwriteb(0xFF, ha->mem_ptr + IPS_REG_FLDP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\nreturn (1);\r\n}\r\nif (status & 0x18) {\r\nwritel(0, ha->mem_ptr + IPS_REG_FLAP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\nwriteb(0xFF, ha->mem_ptr + IPS_REG_FLDP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\nreturn (1);\r\n}\r\n}\r\nwritel(0, ha->mem_ptr + IPS_REG_FLAP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\nwriteb(0xFF, ha->mem_ptr + IPS_REG_FLDP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\nreturn (0);\r\n}\r\nstatic int\r\nips_verify_bios(ips_ha_t * ha, char *buffer, uint32_t buffersize,\r\nuint32_t offset)\r\n{\r\nuint8_t checksum;\r\nint i;\r\nMETHOD_TRACE("ips_verify_bios", 1);\r\noutl(0, ha->io_addr + IPS_REG_FLAP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\nif (inb(ha->io_addr + IPS_REG_FLDP) != 0x55)\r\nreturn (1);\r\noutl(1, ha->io_addr + IPS_REG_FLAP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\nif (inb(ha->io_addr + IPS_REG_FLDP) != 0xAA)\r\nreturn (1);\r\nchecksum = 0xff;\r\nfor (i = 2; i < buffersize; i++) {\r\noutl(i + offset, ha->io_addr + IPS_REG_FLAP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\nchecksum = (uint8_t) checksum + inb(ha->io_addr + IPS_REG_FLDP);\r\n}\r\nif (checksum != 0)\r\nreturn (1);\r\nelse\r\nreturn (0);\r\n}\r\nstatic int\r\nips_verify_bios_memio(ips_ha_t * ha, char *buffer, uint32_t buffersize,\r\nuint32_t offset)\r\n{\r\nuint8_t checksum;\r\nint i;\r\nMETHOD_TRACE("ips_verify_bios_memio", 1);\r\nwritel(0, ha->mem_ptr + IPS_REG_FLAP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\nif (readb(ha->mem_ptr + IPS_REG_FLDP) != 0x55)\r\nreturn (1);\r\nwritel(1, ha->mem_ptr + IPS_REG_FLAP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\nif (readb(ha->mem_ptr + IPS_REG_FLDP) != 0xAA)\r\nreturn (1);\r\nchecksum = 0xff;\r\nfor (i = 2; i < buffersize; i++) {\r\nwritel(i + offset, ha->mem_ptr + IPS_REG_FLAP);\r\nif (ha->pcidev->revision == IPS_REVID_TROMBONE64)\r\nudelay(25);\r\nchecksum =\r\n(uint8_t) checksum + readb(ha->mem_ptr + IPS_REG_FLDP);\r\n}\r\nif (checksum != 0)\r\nreturn (1);\r\nelse\r\nreturn (0);\r\n}\r\nstatic int\r\nips_abort_init(ips_ha_t * ha, int index)\r\n{\r\nha->active = 0;\r\nips_free(ha);\r\nips_ha[index] = NULL;\r\nips_sh[index] = NULL;\r\nreturn -1;\r\n}\r\nstatic void\r\nips_shift_controllers(int lowindex, int highindex)\r\n{\r\nips_ha_t *ha_sav = ips_ha[highindex];\r\nstruct Scsi_Host *sh_sav = ips_sh[highindex];\r\nint i;\r\nfor (i = highindex; i > lowindex; i--) {\r\nips_ha[i] = ips_ha[i - 1];\r\nips_sh[i] = ips_sh[i - 1];\r\nips_ha[i]->host_num = i;\r\n}\r\nha_sav->host_num = lowindex;\r\nips_ha[lowindex] = ha_sav;\r\nips_sh[lowindex] = sh_sav;\r\n}\r\nstatic void\r\nips_order_controllers(void)\r\n{\r\nint i, j, tmp, position = 0;\r\nIPS_NVRAM_P5 *nvram;\r\nif (!ips_ha[0])\r\nreturn;\r\nnvram = ips_ha[0]->nvram;\r\nif (nvram->adapter_order[0]) {\r\nfor (i = 1; i <= nvram->adapter_order[0]; i++) {\r\nfor (j = position; j < ips_num_controllers; j++) {\r\nswitch (ips_ha[j]->ad_type) {\r\ncase IPS_ADTYPE_SERVERAID6M:\r\ncase IPS_ADTYPE_SERVERAID7M:\r\nif (nvram->adapter_order[i] == 'M') {\r\nips_shift_controllers(position,\r\nj);\r\nposition++;\r\n}\r\nbreak;\r\ncase IPS_ADTYPE_SERVERAID4L:\r\ncase IPS_ADTYPE_SERVERAID4M:\r\ncase IPS_ADTYPE_SERVERAID4MX:\r\ncase IPS_ADTYPE_SERVERAID4LX:\r\nif (nvram->adapter_order[i] == 'N') {\r\nips_shift_controllers(position,\r\nj);\r\nposition++;\r\n}\r\nbreak;\r\ncase IPS_ADTYPE_SERVERAID6I:\r\ncase IPS_ADTYPE_SERVERAID5I2:\r\ncase IPS_ADTYPE_SERVERAID5I1:\r\ncase IPS_ADTYPE_SERVERAID7k:\r\nif (nvram->adapter_order[i] == 'S') {\r\nips_shift_controllers(position,\r\nj);\r\nposition++;\r\n}\r\nbreak;\r\ncase IPS_ADTYPE_SERVERAID:\r\ncase IPS_ADTYPE_SERVERAID2:\r\ncase IPS_ADTYPE_NAVAJO:\r\ncase IPS_ADTYPE_KIOWA:\r\ncase IPS_ADTYPE_SERVERAID3L:\r\ncase IPS_ADTYPE_SERVERAID3:\r\ncase IPS_ADTYPE_SERVERAID4H:\r\nif (nvram->adapter_order[i] == 'A') {\r\nips_shift_controllers(position,\r\nj);\r\nposition++;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn;\r\n}\r\ntmp = 0;\r\nfor (i = position; i < ips_num_controllers; i++) {\r\nif (ips_ha[i]->ad_type == IPS_ADTYPE_SERVERAID5I2 ||\r\nips_ha[i]->ad_type == IPS_ADTYPE_SERVERAID5I1) {\r\nips_shift_controllers(position, i);\r\nposition++;\r\ntmp = 1;\r\n}\r\n}\r\nif (!tmp)\r\nreturn;\r\nfor (i = position; i < ips_num_controllers; i++) {\r\nif (ips_ha[i]->ad_type == IPS_ADTYPE_SERVERAID4L ||\r\nips_ha[i]->ad_type == IPS_ADTYPE_SERVERAID4M ||\r\nips_ha[i]->ad_type == IPS_ADTYPE_SERVERAID4LX ||\r\nips_ha[i]->ad_type == IPS_ADTYPE_SERVERAID4MX) {\r\nips_shift_controllers(position, i);\r\nposition++;\r\n}\r\n}\r\nreturn;\r\n}\r\nstatic int\r\nips_register_scsi(int index)\r\n{\r\nstruct Scsi_Host *sh;\r\nips_ha_t *ha, *oldha = ips_ha[index];\r\nsh = scsi_host_alloc(&ips_driver_template, sizeof (ips_ha_t));\r\nif (!sh) {\r\nIPS_PRINTK(KERN_WARNING, oldha->pcidev,\r\n"Unable to register controller with SCSI subsystem\n");\r\nreturn -1;\r\n}\r\nha = IPS_HA(sh);\r\nmemcpy(ha, oldha, sizeof (ips_ha_t));\r\nfree_irq(oldha->pcidev->irq, oldha);\r\nif (request_irq(ha->pcidev->irq, do_ipsintr, IRQF_SHARED, ips_name, ha)) {\r\nIPS_PRINTK(KERN_WARNING, ha->pcidev,\r\n"Unable to install interrupt handler\n");\r\ngoto err_out_sh;\r\n}\r\nkfree(oldha);\r\nsh->unique_id = (ha->io_addr) ? ha->io_addr : ha->mem_addr;\r\nsh->sg_tablesize = sh->hostt->sg_tablesize;\r\nsh->can_queue = sh->hostt->can_queue;\r\nsh->cmd_per_lun = sh->hostt->cmd_per_lun;\r\nsh->use_clustering = sh->hostt->use_clustering;\r\nsh->max_sectors = 128;\r\nsh->max_id = ha->ntargets;\r\nsh->max_lun = ha->nlun;\r\nsh->max_channel = ha->nbus - 1;\r\nsh->can_queue = ha->max_cmds - 1;\r\nif (scsi_add_host(sh, &ha->pcidev->dev))\r\ngoto err_out;\r\nips_sh[index] = sh;\r\nips_ha[index] = ha;\r\nscsi_scan_host(sh);\r\nreturn 0;\r\nerr_out:\r\nfree_irq(ha->pcidev->irq, ha);\r\nerr_out_sh:\r\nscsi_host_put(sh);\r\nreturn -1;\r\n}\r\nstatic void\r\nips_remove_device(struct pci_dev *pci_dev)\r\n{\r\nstruct Scsi_Host *sh = pci_get_drvdata(pci_dev);\r\npci_set_drvdata(pci_dev, NULL);\r\nips_release(sh);\r\npci_release_regions(pci_dev);\r\npci_disable_device(pci_dev);\r\n}\r\nstatic int __init\r\nips_module_init(void)\r\n{\r\nif (pci_register_driver(&ips_pci_driver) < 0)\r\nreturn -ENODEV;\r\nips_driver_template.module = THIS_MODULE;\r\nips_order_controllers();\r\nif (!ips_detect(&ips_driver_template)) {\r\npci_unregister_driver(&ips_pci_driver);\r\nreturn -ENODEV;\r\n}\r\nregister_reboot_notifier(&ips_notifier);\r\nreturn 0;\r\n}\r\nstatic void __exit\r\nips_module_exit(void)\r\n{\r\npci_unregister_driver(&ips_pci_driver);\r\nunregister_reboot_notifier(&ips_notifier);\r\n}\r\nstatic int\r\nips_insert_device(struct pci_dev *pci_dev, const struct pci_device_id *ent)\r\n{\r\nint index = -1;\r\nint rc;\r\nMETHOD_TRACE("ips_insert_device", 1);\r\nrc = pci_enable_device(pci_dev);\r\nif (rc)\r\nreturn rc;\r\nrc = pci_request_regions(pci_dev, "ips");\r\nif (rc)\r\ngoto err_out;\r\nrc = ips_init_phase1(pci_dev, &index);\r\nif (rc == SUCCESS)\r\nrc = ips_init_phase2(index);\r\nif (ips_hotplug)\r\nif (ips_register_scsi(index)) {\r\nips_free(ips_ha[index]);\r\nrc = -1;\r\n}\r\nif (rc == SUCCESS)\r\nips_num_controllers++;\r\nips_next_controller = ips_num_controllers;\r\nif (rc < 0) {\r\nrc = -ENODEV;\r\ngoto err_out_regions;\r\n}\r\npci_set_drvdata(pci_dev, ips_sh[index]);\r\nreturn 0;\r\nerr_out_regions:\r\npci_release_regions(pci_dev);\r\nerr_out:\r\npci_disable_device(pci_dev);\r\nreturn rc;\r\n}\r\nstatic int\r\nips_init_phase1(struct pci_dev *pci_dev, int *indexPtr)\r\n{\r\nips_ha_t *ha;\r\nuint32_t io_addr;\r\nuint32_t mem_addr;\r\nuint32_t io_len;\r\nuint32_t mem_len;\r\nuint8_t bus;\r\nuint8_t func;\r\nint j;\r\nint index;\r\ndma_addr_t dma_address;\r\nchar __iomem *ioremap_ptr;\r\nchar __iomem *mem_ptr;\r\nuint32_t IsDead;\r\nMETHOD_TRACE("ips_init_phase1", 1);\r\nindex = IPS_MAX_ADAPTERS;\r\nfor (j = 0; j < IPS_MAX_ADAPTERS; j++) {\r\nif (ips_ha[j] == NULL) {\r\nindex = j;\r\nbreak;\r\n}\r\n}\r\nif (index >= IPS_MAX_ADAPTERS)\r\nreturn -1;\r\nbus = pci_dev->bus->number;\r\nfunc = pci_dev->devfn;\r\nmem_addr = 0;\r\nio_addr = 0;\r\nmem_len = 0;\r\nio_len = 0;\r\nfor (j = 0; j < 2; j++) {\r\nif (!pci_resource_start(pci_dev, j))\r\nbreak;\r\nif (pci_resource_flags(pci_dev, j) & IORESOURCE_IO) {\r\nio_addr = pci_resource_start(pci_dev, j);\r\nio_len = pci_resource_len(pci_dev, j);\r\n} else {\r\nmem_addr = pci_resource_start(pci_dev, j);\r\nmem_len = pci_resource_len(pci_dev, j);\r\n}\r\n}\r\nif (mem_addr) {\r\nuint32_t base;\r\nuint32_t offs;\r\nbase = mem_addr & PAGE_MASK;\r\noffs = mem_addr - base;\r\nioremap_ptr = ioremap(base, PAGE_SIZE);\r\nif (!ioremap_ptr)\r\nreturn -1;\r\nmem_ptr = ioremap_ptr + offs;\r\n} else {\r\nioremap_ptr = NULL;\r\nmem_ptr = NULL;\r\n}\r\nha = kzalloc(sizeof (ips_ha_t), GFP_KERNEL);\r\nif (ha == NULL) {\r\nIPS_PRINTK(KERN_WARNING, pci_dev,\r\n"Unable to allocate temporary ha struct\n");\r\nreturn -1;\r\n}\r\nips_sh[index] = NULL;\r\nips_ha[index] = ha;\r\nha->active = 1;\r\nha->io_addr = io_addr;\r\nha->io_len = io_len;\r\nha->mem_addr = mem_addr;\r\nha->mem_len = mem_len;\r\nha->mem_ptr = mem_ptr;\r\nha->ioremap_ptr = ioremap_ptr;\r\nha->host_num = (uint32_t) index;\r\nha->slot_num = PCI_SLOT(pci_dev->devfn);\r\nha->pcidev = pci_dev;\r\nif (IPS_ENABLE_DMA64 && IPS_HAS_ENH_SGLIST(ha) &&\r\n!pci_set_dma_mask(ha->pcidev, DMA_BIT_MASK(64))) {\r\n(ha)->flags |= IPS_HA_ENH_SG;\r\n} else {\r\nif (pci_set_dma_mask(ha->pcidev, DMA_BIT_MASK(32)) != 0) {\r\nprintk(KERN_WARNING "Unable to set DMA Mask\n");\r\nreturn ips_abort_init(ha, index);\r\n}\r\n}\r\nif(ips_cd_boot && !ips_FlashData){\r\nips_FlashData = pci_alloc_consistent(pci_dev, PAGE_SIZE << 7,\r\n&ips_flashbusaddr);\r\n}\r\nha->enq = pci_alloc_consistent(pci_dev, sizeof (IPS_ENQ),\r\n&ha->enq_busaddr);\r\nif (!ha->enq) {\r\nIPS_PRINTK(KERN_WARNING, pci_dev,\r\n"Unable to allocate host inquiry structure\n");\r\nreturn ips_abort_init(ha, index);\r\n}\r\nha->adapt = pci_alloc_consistent(pci_dev, sizeof (IPS_ADAPTER) +\r\nsizeof (IPS_IO_CMD), &dma_address);\r\nif (!ha->adapt) {\r\nIPS_PRINTK(KERN_WARNING, pci_dev,\r\n"Unable to allocate host adapt & dummy structures\n");\r\nreturn ips_abort_init(ha, index);\r\n}\r\nha->adapt->hw_status_start = dma_address;\r\nha->dummy = (void *) (ha->adapt + 1);\r\nha->logical_drive_info = pci_alloc_consistent(pci_dev, sizeof (IPS_LD_INFO), &dma_address);\r\nif (!ha->logical_drive_info) {\r\nIPS_PRINTK(KERN_WARNING, pci_dev,\r\n"Unable to allocate logical drive info structure\n");\r\nreturn ips_abort_init(ha, index);\r\n}\r\nha->logical_drive_info_dma_addr = dma_address;\r\nha->conf = kmalloc(sizeof (IPS_CONF), GFP_KERNEL);\r\nif (!ha->conf) {\r\nIPS_PRINTK(KERN_WARNING, pci_dev,\r\n"Unable to allocate host conf structure\n");\r\nreturn ips_abort_init(ha, index);\r\n}\r\nha->nvram = kmalloc(sizeof (IPS_NVRAM_P5), GFP_KERNEL);\r\nif (!ha->nvram) {\r\nIPS_PRINTK(KERN_WARNING, pci_dev,\r\n"Unable to allocate host NVRAM structure\n");\r\nreturn ips_abort_init(ha, index);\r\n}\r\nha->subsys = kmalloc(sizeof (IPS_SUBSYS), GFP_KERNEL);\r\nif (!ha->subsys) {\r\nIPS_PRINTK(KERN_WARNING, pci_dev,\r\n"Unable to allocate host subsystem structure\n");\r\nreturn ips_abort_init(ha, index);\r\n}\r\nif (ips_ioctlsize < PAGE_SIZE)\r\nips_ioctlsize = PAGE_SIZE;\r\nha->ioctl_data = pci_alloc_consistent(pci_dev, ips_ioctlsize,\r\n&ha->ioctl_busaddr);\r\nha->ioctl_len = ips_ioctlsize;\r\nif (!ha->ioctl_data) {\r\nIPS_PRINTK(KERN_WARNING, pci_dev,\r\n"Unable to allocate IOCTL data\n");\r\nreturn ips_abort_init(ha, index);\r\n}\r\nips_setup_funclist(ha);\r\nif ((IPS_IS_MORPHEUS(ha)) || (IPS_IS_MARCO(ha))) {\r\nIsDead = readl(ha->mem_ptr + IPS_REG_I960_MSG1);\r\nif (IsDead == 0xDEADBEEF) {\r\nips_reset_morpheus(ha);\r\n}\r\n}\r\nif (!(*ha->func.isinit) (ha)) {\r\nif (!(*ha->func.init) (ha)) {\r\nIPS_PRINTK(KERN_WARNING, pci_dev,\r\n"Unable to initialize controller\n");\r\nreturn ips_abort_init(ha, index);\r\n}\r\n}\r\n*indexPtr = index;\r\nreturn SUCCESS;\r\n}\r\nstatic int\r\nips_init_phase2(int index)\r\n{\r\nips_ha_t *ha;\r\nha = ips_ha[index];\r\nMETHOD_TRACE("ips_init_phase2", 1);\r\nif (!ha->active) {\r\nips_ha[index] = NULL;\r\nreturn -1;\r\n}\r\nif (request_irq(ha->pcidev->irq, do_ipsintr, IRQF_SHARED, ips_name, ha)) {\r\nIPS_PRINTK(KERN_WARNING, ha->pcidev,\r\n"Unable to install interrupt handler\n");\r\nreturn ips_abort_init(ha, index);\r\n}\r\nha->max_cmds = 1;\r\nif (!ips_allocatescbs(ha)) {\r\nIPS_PRINTK(KERN_WARNING, ha->pcidev,\r\n"Unable to allocate a CCB\n");\r\nfree_irq(ha->pcidev->irq, ha);\r\nreturn ips_abort_init(ha, index);\r\n}\r\nif (!ips_hainit(ha)) {\r\nIPS_PRINTK(KERN_WARNING, ha->pcidev,\r\n"Unable to initialize controller\n");\r\nfree_irq(ha->pcidev->irq, ha);\r\nreturn ips_abort_init(ha, index);\r\n}\r\nips_deallocatescbs(ha, 1);\r\nif (!ips_allocatescbs(ha)) {\r\nIPS_PRINTK(KERN_WARNING, ha->pcidev,\r\n"Unable to allocate CCBs\n");\r\nfree_irq(ha->pcidev->irq, ha);\r\nreturn ips_abort_init(ha, index);\r\n}\r\nreturn SUCCESS;\r\n}
