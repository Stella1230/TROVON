static int shtc1_update_values(struct i2c_client *client,\r\nstruct shtc1_data *data,\r\nchar *buf, int bufsize)\r\n{\r\nint ret = i2c_master_send(client, data->command, SHTC1_CMD_LENGTH);\r\nif (ret != SHTC1_CMD_LENGTH) {\r\ndev_err(&client->dev, "failed to send command: %d\n", ret);\r\nreturn ret < 0 ? ret : -EIO;\r\n}\r\nif (!data->setup.blocking_io)\r\nusleep_range(data->nonblocking_wait_time,\r\ndata->nonblocking_wait_time + 1000);\r\nret = i2c_master_recv(client, buf, bufsize);\r\nif (ret != bufsize) {\r\ndev_err(&client->dev, "failed to read values: %d\n", ret);\r\nreturn ret < 0 ? ret : -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct shtc1_data *shtc1_update_client(struct device *dev)\r\n{\r\nstruct shtc1_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nunsigned char buf[SHTC1_RESPONSE_LENGTH];\r\nint val;\r\nint ret = 0;\r\nmutex_lock(&data->update_lock);\r\nif (time_after(jiffies, data->last_updated + HZ / 10) || !data->valid) {\r\nret = shtc1_update_values(client, data, buf, sizeof(buf));\r\nif (ret)\r\ngoto out;\r\nval = be16_to_cpup((__be16 *)buf);\r\ndata->temperature = ((21875 * val) >> 13) - 45000;\r\nval = be16_to_cpup((__be16 *)(buf + 3));\r\ndata->humidity = ((12500 * val) >> 13);\r\ndata->last_updated = jiffies;\r\ndata->valid = true;\r\n}\r\nout:\r\nmutex_unlock(&data->update_lock);\r\nreturn ret == 0 ? data : ERR_PTR(ret);\r\n}\r\nstatic ssize_t temp1_input_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct shtc1_data *data = shtc1_update_client(dev);\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nreturn sprintf(buf, "%d\n", data->temperature);\r\n}\r\nstatic ssize_t humidity1_input_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct shtc1_data *data = shtc1_update_client(dev);\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nreturn sprintf(buf, "%d\n", data->humidity);\r\n}\r\nstatic void shtc1_select_command(struct shtc1_data *data)\r\n{\r\nif (data->setup.high_precision) {\r\ndata->command = data->setup.blocking_io ?\r\nshtc1_cmd_measure_blocking_hpm :\r\nshtc1_cmd_measure_nonblocking_hpm;\r\ndata->nonblocking_wait_time = SHTC1_NONBLOCKING_WAIT_TIME_HPM;\r\n} else {\r\ndata->command = data->setup.blocking_io ?\r\nshtc1_cmd_measure_blocking_lpm :\r\nshtc1_cmd_measure_nonblocking_lpm;\r\ndata->nonblocking_wait_time = SHTC1_NONBLOCKING_WAIT_TIME_LPM;\r\n}\r\n}\r\nstatic int shtc1_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint ret;\r\nchar id_reg[2];\r\nstruct shtc1_data *data;\r\nstruct device *hwmon_dev;\r\nstruct i2c_adapter *adap = client->adapter;\r\nstruct device *dev = &client->dev;\r\nif (!i2c_check_functionality(adap, I2C_FUNC_I2C)) {\r\ndev_err(dev, "plain i2c transactions not supported\n");\r\nreturn -ENODEV;\r\n}\r\nret = i2c_master_send(client, shtc1_cmd_read_id_reg, SHTC1_CMD_LENGTH);\r\nif (ret != SHTC1_CMD_LENGTH) {\r\ndev_err(dev, "could not send read_id_reg command: %d\n", ret);\r\nreturn ret < 0 ? ret : -ENODEV;\r\n}\r\nret = i2c_master_recv(client, id_reg, sizeof(id_reg));\r\nif (ret != sizeof(id_reg)) {\r\ndev_err(dev, "could not read ID register: %d\n", ret);\r\nreturn -ENODEV;\r\n}\r\nif ((id_reg[1] & SHTC1_ID_REG_MASK) != SHTC1_ID) {\r\ndev_err(dev, "ID register doesn't match\n");\r\nreturn -ENODEV;\r\n}\r\ndata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->setup.blocking_io = false;\r\ndata->setup.high_precision = true;\r\ndata->client = client;\r\nif (client->dev.platform_data)\r\ndata->setup = *(struct shtc1_platform_data *)dev->platform_data;\r\nshtc1_select_command(data);\r\nmutex_init(&data->update_lock);\r\nhwmon_dev = devm_hwmon_device_register_with_groups(dev,\r\nclient->name,\r\ndata,\r\nshtc1_groups);\r\nif (IS_ERR(hwmon_dev))\r\ndev_dbg(dev, "unable to register hwmon device\n");\r\nreturn PTR_ERR_OR_ZERO(hwmon_dev);\r\n}
