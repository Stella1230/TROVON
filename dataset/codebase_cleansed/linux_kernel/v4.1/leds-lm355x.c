static int lm355x_chip_init(struct lm355x_chip_data *chip)\r\n{\r\nint ret;\r\nunsigned int reg_val;\r\nstruct lm355x_platform_data *pdata = chip->pdata;\r\nswitch (chip->type) {\r\ncase CHIP_LM3554:\r\nreg_val = pdata->pin_tx2 | pdata->ntc_pin;\r\nret = regmap_update_bits(chip->regmap, 0xE0, 0x28, reg_val);\r\nif (ret < 0)\r\ngoto out;\r\nreg_val = pdata->pass_mode;\r\nret = regmap_update_bits(chip->regmap, 0xA0, 0x04, reg_val);\r\nif (ret < 0)\r\ngoto out;\r\nbreak;\r\ncase CHIP_LM3556:\r\nreg_val = pdata->pin_tx2 | pdata->ntc_pin | pdata->pass_mode;\r\nret = regmap_update_bits(chip->regmap, 0x0A, 0xC4, reg_val);\r\nif (ret < 0)\r\ngoto out;\r\nbreak;\r\ndefault:\r\nreturn -ENODATA;\r\n}\r\nreturn ret;\r\nout:\r\ndev_err(chip->dev, "%s:i2c access fail to register\n", __func__);\r\nreturn ret;\r\n}\r\nstatic void lm355x_control(struct lm355x_chip_data *chip,\r\nu8 brightness, enum lm355x_mode opmode)\r\n{\r\nint ret;\r\nunsigned int reg_val;\r\nstruct lm355x_platform_data *pdata = chip->pdata;\r\nstruct lm355x_reg_data *preg = chip->regs;\r\nret = regmap_read(chip->regmap, preg[REG_FLAG].regno, &chip->last_flag);\r\nif (ret < 0)\r\ngoto out;\r\nif (chip->last_flag & preg[REG_FLAG].mask)\r\ndev_info(chip->dev, "%s Last FLAG is 0x%x\n",\r\nlm355x_name[chip->type],\r\nchip->last_flag & preg[REG_FLAG].mask);\r\nif (!brightness)\r\nopmode = MODE_SHDN;\r\nswitch (opmode) {\r\ncase MODE_TORCH:\r\nret =\r\nregmap_update_bits(chip->regmap, preg[REG_TORCH_CTRL].regno,\r\npreg[REG_TORCH_CTRL].mask,\r\n(brightness - 1)\r\n<< preg[REG_TORCH_CTRL].shift);\r\nif (ret < 0)\r\ngoto out;\r\nif (pdata->pin_tx1 != LM355x_PIN_TORCH_DISABLE) {\r\nret =\r\nregmap_update_bits(chip->regmap,\r\npreg[REG_TORCH_CFG].regno,\r\npreg[REG_TORCH_CFG].mask,\r\n0x01 <<\r\npreg[REG_TORCH_CFG].shift);\r\nif (ret < 0)\r\ngoto out;\r\nopmode = MODE_SHDN;\r\ndev_info(chip->dev,\r\n"torch brt is set - ext. torch pin mode\n");\r\n}\r\nbreak;\r\ncase MODE_FLASH:\r\nret =\r\nregmap_update_bits(chip->regmap, preg[REG_FLASH_CTRL].regno,\r\npreg[REG_FLASH_CTRL].mask,\r\n(brightness - 1)\r\n<< preg[REG_FLASH_CTRL].shift);\r\nif (ret < 0)\r\ngoto out;\r\nif (pdata->pin_strobe != LM355x_PIN_STROBE_DISABLE) {\r\nif (chip->type == CHIP_LM3554)\r\nreg_val = 0x00;\r\nelse\r\nreg_val = 0x01;\r\nret =\r\nregmap_update_bits(chip->regmap,\r\npreg[REG_STROBE_CFG].regno,\r\npreg[REG_STROBE_CFG].mask,\r\nreg_val <<\r\npreg[REG_STROBE_CFG].shift);\r\nif (ret < 0)\r\ngoto out;\r\nopmode = MODE_SHDN;\r\ndev_info(chip->dev,\r\n"flash brt is set - ext. strobe pin mode\n");\r\n}\r\nbreak;\r\ncase MODE_INDIC:\r\nret =\r\nregmap_update_bits(chip->regmap, preg[REG_INDI_CTRL].regno,\r\npreg[REG_INDI_CTRL].mask,\r\n(brightness - 1)\r\n<< preg[REG_INDI_CTRL].shift);\r\nif (ret < 0)\r\ngoto out;\r\nif (pdata->pin_tx2 != LM355x_PIN_TX_DISABLE) {\r\nret =\r\nregmap_update_bits(chip->regmap,\r\npreg[REG_INDI_CFG].regno,\r\npreg[REG_INDI_CFG].mask,\r\n0x01 <<\r\npreg[REG_INDI_CFG].shift);\r\nif (ret < 0)\r\ngoto out;\r\nopmode = MODE_SHDN;\r\n}\r\nbreak;\r\ncase MODE_SHDN:\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nret = regmap_update_bits(chip->regmap, preg[REG_OPMODE].regno,\r\npreg[REG_OPMODE].mask,\r\nopmode << preg[REG_OPMODE].shift);\r\nif (ret < 0)\r\ngoto out;\r\nreturn;\r\nout:\r\ndev_err(chip->dev, "%s:i2c access fail to register\n", __func__);\r\nreturn;\r\n}\r\nstatic void lm355x_deferred_torch_brightness_set(struct work_struct *work)\r\n{\r\nstruct lm355x_chip_data *chip =\r\ncontainer_of(work, struct lm355x_chip_data, work_torch);\r\nmutex_lock(&chip->lock);\r\nlm355x_control(chip, chip->br_torch, MODE_TORCH);\r\nmutex_unlock(&chip->lock);\r\n}\r\nstatic void lm355x_torch_brightness_set(struct led_classdev *cdev,\r\nenum led_brightness brightness)\r\n{\r\nstruct lm355x_chip_data *chip =\r\ncontainer_of(cdev, struct lm355x_chip_data, cdev_torch);\r\nchip->br_torch = brightness;\r\nschedule_work(&chip->work_torch);\r\n}\r\nstatic void lm355x_deferred_strobe_brightness_set(struct work_struct *work)\r\n{\r\nstruct lm355x_chip_data *chip =\r\ncontainer_of(work, struct lm355x_chip_data, work_flash);\r\nmutex_lock(&chip->lock);\r\nlm355x_control(chip, chip->br_flash, MODE_FLASH);\r\nmutex_unlock(&chip->lock);\r\n}\r\nstatic void lm355x_strobe_brightness_set(struct led_classdev *cdev,\r\nenum led_brightness brightness)\r\n{\r\nstruct lm355x_chip_data *chip =\r\ncontainer_of(cdev, struct lm355x_chip_data, cdev_flash);\r\nchip->br_flash = brightness;\r\nschedule_work(&chip->work_flash);\r\n}\r\nstatic void lm355x_deferred_indicator_brightness_set(struct work_struct *work)\r\n{\r\nstruct lm355x_chip_data *chip =\r\ncontainer_of(work, struct lm355x_chip_data, work_indicator);\r\nmutex_lock(&chip->lock);\r\nlm355x_control(chip, chip->br_indicator, MODE_INDIC);\r\nmutex_unlock(&chip->lock);\r\n}\r\nstatic void lm355x_indicator_brightness_set(struct led_classdev *cdev,\r\nenum led_brightness brightness)\r\n{\r\nstruct lm355x_chip_data *chip =\r\ncontainer_of(cdev, struct lm355x_chip_data, cdev_indicator);\r\nchip->br_indicator = brightness;\r\nschedule_work(&chip->work_indicator);\r\n}\r\nstatic ssize_t lm3556_indicator_pattern_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nssize_t ret;\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nstruct lm355x_chip_data *chip =\r\ncontainer_of(led_cdev, struct lm355x_chip_data, cdev_indicator);\r\nunsigned int state;\r\nret = kstrtouint(buf, 10, &state);\r\nif (ret)\r\ngoto out;\r\nif (state > INDIC_PATTERN_SIZE - 1)\r\nstate = INDIC_PATTERN_SIZE - 1;\r\nret = regmap_write(chip->regmap, 0x04,\r\nindicator_pattern[state].blinking);\r\nif (ret < 0)\r\ngoto out;\r\nret = regmap_write(chip->regmap, 0x05,\r\nindicator_pattern[state].period_cnt);\r\nif (ret < 0)\r\ngoto out;\r\nreturn size;\r\nout:\r\ndev_err(chip->dev, "%s:i2c access fail to register\n", __func__);\r\nreturn ret;\r\n}\r\nstatic int lm355x_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct lm355x_platform_data *pdata = dev_get_platdata(&client->dev);\r\nstruct lm355x_chip_data *chip;\r\nint err;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\r\ndev_err(&client->dev, "i2c functionality check fail.\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (pdata == NULL) {\r\ndev_err(&client->dev, "needs Platform Data.\n");\r\nreturn -ENODATA;\r\n}\r\nchip = devm_kzalloc(&client->dev,\r\nsizeof(struct lm355x_chip_data), GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\nchip->dev = &client->dev;\r\nchip->type = id->driver_data;\r\nswitch (id->driver_data) {\r\ncase CHIP_LM3554:\r\nchip->regs = lm3554_regs;\r\nbreak;\r\ncase CHIP_LM3556:\r\nchip->regs = lm3556_regs;\r\nbreak;\r\ndefault:\r\nreturn -ENOSYS;\r\n}\r\nchip->pdata = pdata;\r\nchip->regmap = devm_regmap_init_i2c(client, &lm355x_regmap);\r\nif (IS_ERR(chip->regmap)) {\r\nerr = PTR_ERR(chip->regmap);\r\ndev_err(&client->dev,\r\n"Failed to allocate register map: %d\n", err);\r\nreturn err;\r\n}\r\nmutex_init(&chip->lock);\r\ni2c_set_clientdata(client, chip);\r\nerr = lm355x_chip_init(chip);\r\nif (err < 0)\r\ngoto err_out;\r\nINIT_WORK(&chip->work_flash, lm355x_deferred_strobe_brightness_set);\r\nchip->cdev_flash.name = "flash";\r\nchip->cdev_flash.max_brightness = 16;\r\nchip->cdev_flash.brightness_set = lm355x_strobe_brightness_set;\r\nchip->cdev_flash.default_trigger = "flash";\r\nerr = led_classdev_register((struct device *)\r\n&client->dev, &chip->cdev_flash);\r\nif (err < 0)\r\ngoto err_out;\r\nINIT_WORK(&chip->work_torch, lm355x_deferred_torch_brightness_set);\r\nchip->cdev_torch.name = "torch";\r\nchip->cdev_torch.max_brightness = 8;\r\nchip->cdev_torch.brightness_set = lm355x_torch_brightness_set;\r\nchip->cdev_torch.default_trigger = "torch";\r\nerr = led_classdev_register((struct device *)\r\n&client->dev, &chip->cdev_torch);\r\nif (err < 0)\r\ngoto err_create_torch_file;\r\nINIT_WORK(&chip->work_indicator,\r\nlm355x_deferred_indicator_brightness_set);\r\nchip->cdev_indicator.name = "indicator";\r\nif (id->driver_data == CHIP_LM3554)\r\nchip->cdev_indicator.max_brightness = 4;\r\nelse\r\nchip->cdev_indicator.max_brightness = 8;\r\nchip->cdev_indicator.brightness_set = lm355x_indicator_brightness_set;\r\nif (id->driver_data == CHIP_LM3556)\r\nchip->cdev_indicator.groups = lm355x_indicator_groups;\r\nerr = led_classdev_register((struct device *)\r\n&client->dev, &chip->cdev_indicator);\r\nif (err < 0)\r\ngoto err_create_indicator_file;\r\ndev_info(&client->dev, "%s is initialized\n",\r\nlm355x_name[id->driver_data]);\r\nreturn 0;\r\nerr_create_indicator_file:\r\nled_classdev_unregister(&chip->cdev_torch);\r\nerr_create_torch_file:\r\nled_classdev_unregister(&chip->cdev_flash);\r\nerr_out:\r\nreturn err;\r\n}\r\nstatic int lm355x_remove(struct i2c_client *client)\r\n{\r\nstruct lm355x_chip_data *chip = i2c_get_clientdata(client);\r\nstruct lm355x_reg_data *preg = chip->regs;\r\nregmap_write(chip->regmap, preg[REG_OPMODE].regno, 0);\r\nled_classdev_unregister(&chip->cdev_indicator);\r\nflush_work(&chip->work_indicator);\r\nled_classdev_unregister(&chip->cdev_torch);\r\nflush_work(&chip->work_torch);\r\nled_classdev_unregister(&chip->cdev_flash);\r\nflush_work(&chip->work_flash);\r\ndev_info(&client->dev, "%s is removed\n", lm355x_name[chip->type]);\r\nreturn 0;\r\n}
