static unsigned int\r\nconf_read(unsigned long addr, unsigned char type1,\r\nstruct pci_controller *hose)\r\n{\r\nunsigned long flags;\r\nunsigned long mid = MCPCIA_HOSE2MID(hose->index);\r\nunsigned int stat0, value, cpu;\r\ncpu = smp_processor_id();\r\nlocal_irq_save(flags);\r\nDBG_CFG(("conf_read(addr=0x%lx, type1=%d, hose=%d)\n",\r\naddr, type1, mid));\r\nstat0 = *(vuip)MCPCIA_CAP_ERR(mid);\r\n*(vuip)MCPCIA_CAP_ERR(mid) = stat0;\r\nmb();\r\n*(vuip)MCPCIA_CAP_ERR(mid);\r\nDBG_CFG(("conf_read: MCPCIA_CAP_ERR(%d) was 0x%x\n", mid, stat0));\r\nmb();\r\ndraina();\r\nmcheck_expected(cpu) = 1;\r\nmcheck_taken(cpu) = 0;\r\nmcheck_extra(cpu) = mid;\r\nmb();\r\nvalue = *((vuip)addr);\r\nmb();\r\nmb();\r\nif (mcheck_taken(cpu)) {\r\nmcheck_taken(cpu) = 0;\r\nvalue = 0xffffffffU;\r\nmb();\r\n}\r\nmcheck_expected(cpu) = 0;\r\nmb();\r\nDBG_CFG(("conf_read(): finished\n"));\r\nlocal_irq_restore(flags);\r\nreturn value;\r\n}\r\nstatic void\r\nconf_write(unsigned long addr, unsigned int value, unsigned char type1,\r\nstruct pci_controller *hose)\r\n{\r\nunsigned long flags;\r\nunsigned long mid = MCPCIA_HOSE2MID(hose->index);\r\nunsigned int stat0, cpu;\r\ncpu = smp_processor_id();\r\nlocal_irq_save(flags);\r\nstat0 = *(vuip)MCPCIA_CAP_ERR(mid);\r\n*(vuip)MCPCIA_CAP_ERR(mid) = stat0; mb();\r\n*(vuip)MCPCIA_CAP_ERR(mid);\r\nDBG_CFG(("conf_write: MCPCIA CAP_ERR(%d) was 0x%x\n", mid, stat0));\r\ndraina();\r\nmcheck_expected(cpu) = 1;\r\nmcheck_extra(cpu) = mid;\r\nmb();\r\n*((vuip)addr) = value;\r\nmb();\r\nmb();\r\n*(vuip)MCPCIA_CAP_ERR(mid);\r\nmcheck_expected(cpu) = 0;\r\nmb();\r\nDBG_CFG(("conf_write(): finished\n"));\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int\r\nmk_conf_addr(struct pci_bus *pbus, unsigned int devfn, int where,\r\nstruct pci_controller *hose, unsigned long *pci_addr,\r\nunsigned char *type1)\r\n{\r\nu8 bus = pbus->number;\r\nunsigned long addr;\r\nDBG_CFG(("mk_conf_addr(bus=%d,devfn=0x%x,hose=%d,where=0x%x,"\r\n" pci_addr=0x%p, type1=0x%p)\n",\r\nbus, devfn, hose->index, where, pci_addr, type1));\r\n*type1 = 1;\r\nif (!pbus->parent)\r\nbus = 0;\r\naddr = (bus << 16) | (devfn << 8) | (where);\r\naddr <<= 5;\r\naddr |= hose->config_space_base;\r\n*pci_addr = addr;\r\nDBG_CFG(("mk_conf_addr: returning pci_addr 0x%lx\n", addr));\r\nreturn 0;\r\n}\r\nstatic int\r\nmcpcia_read_config(struct pci_bus *bus, unsigned int devfn, int where,\r\nint size, u32 *value)\r\n{\r\nstruct pci_controller *hose = bus->sysdata;\r\nunsigned long addr, w;\r\nunsigned char type1;\r\nif (mk_conf_addr(bus, devfn, where, hose, &addr, &type1))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\naddr |= (size - 1) * 8;\r\nw = conf_read(addr, type1, hose);\r\nswitch (size) {\r\ncase 1:\r\n*value = __kernel_extbl(w, where & 3);\r\nbreak;\r\ncase 2:\r\n*value = __kernel_extwl(w, where & 3);\r\nbreak;\r\ncase 4:\r\n*value = w;\r\nbreak;\r\n}\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int\r\nmcpcia_write_config(struct pci_bus *bus, unsigned int devfn, int where,\r\nint size, u32 value)\r\n{\r\nstruct pci_controller *hose = bus->sysdata;\r\nunsigned long addr;\r\nunsigned char type1;\r\nif (mk_conf_addr(bus, devfn, where, hose, &addr, &type1))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\naddr |= (size - 1) * 8;\r\nvalue = __kernel_insql(value, where & 3);\r\nconf_write(addr, value, type1, hose);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nvoid\r\nmcpcia_pci_tbi(struct pci_controller *hose, dma_addr_t start, dma_addr_t end)\r\n{\r\nwmb();\r\n*(vuip)MCPCIA_SG_TBIA(MCPCIA_HOSE2MID(hose->index)) = 0;\r\nmb();\r\n}\r\nstatic int __init\r\nmcpcia_probe_hose(int h)\r\n{\r\nint cpu = smp_processor_id();\r\nint mid = MCPCIA_HOSE2MID(h);\r\nunsigned int pci_rev;\r\nmb();\r\nmb();\r\ndraina();\r\nwrmces(7);\r\nmcheck_expected(cpu) = 2;\r\nmcheck_taken(cpu) = 0;\r\nmcheck_extra(cpu) = mid;\r\nmb();\r\npci_rev = *(vuip)MCPCIA_REV(mid);\r\nmb();\r\nmb();\r\nif (mcheck_taken(cpu)) {\r\nmcheck_taken(cpu) = 0;\r\npci_rev = 0xffffffff;\r\nmb();\r\n}\r\nmcheck_expected(cpu) = 0;\r\nmb();\r\nreturn (pci_rev >> 16) == PCI_CLASS_BRIDGE_HOST;\r\n}\r\nstatic void __init\r\nmcpcia_new_hose(int h)\r\n{\r\nstruct pci_controller *hose;\r\nstruct resource *io, *mem, *hae_mem;\r\nint mid = MCPCIA_HOSE2MID(h);\r\nhose = alloc_pci_controller();\r\nif (h == 0)\r\npci_isa_hose = hose;\r\nio = alloc_resource();\r\nmem = alloc_resource();\r\nhae_mem = alloc_resource();\r\nhose->io_space = io;\r\nhose->mem_space = hae_mem;\r\nhose->sparse_mem_base = MCPCIA_SPARSE(mid) - IDENT_ADDR;\r\nhose->dense_mem_base = MCPCIA_DENSE(mid) - IDENT_ADDR;\r\nhose->sparse_io_base = MCPCIA_IO(mid) - IDENT_ADDR;\r\nhose->dense_io_base = 0;\r\nhose->config_space_base = MCPCIA_CONF(mid);\r\nhose->index = h;\r\nio->start = MCPCIA_IO(mid) - MCPCIA_IO_BIAS;\r\nio->end = io->start + 0xffff;\r\nio->name = pci_io_names[h];\r\nio->flags = IORESOURCE_IO;\r\nmem->start = MCPCIA_DENSE(mid) - MCPCIA_MEM_BIAS;\r\nmem->end = mem->start + 0xffffffff;\r\nmem->name = pci_mem_names[h];\r\nmem->flags = IORESOURCE_MEM;\r\nhae_mem->start = mem->start;\r\nhae_mem->end = mem->start + MCPCIA_MEM_MASK;\r\nhae_mem->name = pci_hae0_name;\r\nhae_mem->flags = IORESOURCE_MEM;\r\nif (request_resource(&ioport_resource, io) < 0)\r\nprintk(KERN_ERR "Failed to request IO on hose %d\n", h);\r\nif (request_resource(&iomem_resource, mem) < 0)\r\nprintk(KERN_ERR "Failed to request MEM on hose %d\n", h);\r\nif (request_resource(mem, hae_mem) < 0)\r\nprintk(KERN_ERR "Failed to request HAE_MEM on hose %d\n", h);\r\n}\r\nstatic void\r\nmcpcia_pci_clr_err(int mid)\r\n{\r\n*(vuip)MCPCIA_CAP_ERR(mid);\r\n*(vuip)MCPCIA_CAP_ERR(mid) = 0xffffffff;\r\nmb();\r\n*(vuip)MCPCIA_CAP_ERR(mid);\r\n}\r\nstatic void __init\r\nmcpcia_startup_hose(struct pci_controller *hose)\r\n{\r\nint mid = MCPCIA_HOSE2MID(hose->index);\r\nunsigned int tmp;\r\nmcpcia_pci_clr_err(mid);\r\ntmp = *(vuip)MCPCIA_CAP_ERR(mid);\r\ntmp |= 0x0006;\r\n*(vuip)MCPCIA_CAP_ERR(mid) = tmp;\r\nmb();\r\ntmp = *(vuip)MCPCIA_CAP_ERR(mid);\r\nhose->sg_isa = iommu_arena_new(hose, 0x00800000, 0x00800000, 0);\r\nhose->sg_pci = iommu_arena_new(hose, 0x40000000,\r\nsize_for_memory(0x40000000), 0);\r\n__direct_map_base = 0x80000000;\r\n__direct_map_size = 0x80000000;\r\n*(vuip)MCPCIA_W0_BASE(mid) = hose->sg_isa->dma_base | 3;\r\n*(vuip)MCPCIA_W0_MASK(mid) = (hose->sg_isa->size - 1) & 0xfff00000;\r\n*(vuip)MCPCIA_T0_BASE(mid) = virt_to_phys(hose->sg_isa->ptes) >> 8;\r\n*(vuip)MCPCIA_W1_BASE(mid) = hose->sg_pci->dma_base | 3;\r\n*(vuip)MCPCIA_W1_MASK(mid) = (hose->sg_pci->size - 1) & 0xfff00000;\r\n*(vuip)MCPCIA_T1_BASE(mid) = virt_to_phys(hose->sg_pci->ptes) >> 8;\r\n*(vuip)MCPCIA_W2_BASE(mid) = __direct_map_base | 1;\r\n*(vuip)MCPCIA_W2_MASK(mid) = (__direct_map_size - 1) & 0xfff00000;\r\n*(vuip)MCPCIA_T2_BASE(mid) = 0;\r\n*(vuip)MCPCIA_W3_BASE(mid) = 0x0;\r\nmcpcia_pci_tbi(hose, 0, -1);\r\n*(vuip)MCPCIA_HBASE(mid) = 0x0;\r\nmb();\r\n*(vuip)MCPCIA_HAE_MEM(mid) = 0U;\r\nmb();\r\n*(vuip)MCPCIA_HAE_MEM(mid);\r\n*(vuip)MCPCIA_HAE_IO(mid) = 0;\r\nmb();\r\n*(vuip)MCPCIA_HAE_IO(mid);\r\n}\r\nvoid __init\r\nmcpcia_init_arch(void)\r\n{\r\nioport_resource.end = ~0UL;\r\nmcpcia_new_hose(0);\r\n}\r\nvoid __init\r\nmcpcia_init_hoses(void)\r\n{\r\nstruct pci_controller *hose;\r\nint hose_count;\r\nint h;\r\nhose_count = 0;\r\nfor (h = 0; h < MCPCIA_MAX_HOSES; ++h) {\r\nif (mcpcia_probe_hose(h)) {\r\nif (h != 0)\r\nmcpcia_new_hose(h);\r\nhose_count++;\r\n}\r\n}\r\nprintk("mcpcia_init_hoses: found %d hoses\n", hose_count);\r\nfor (hose = hose_head; hose; hose = hose->next)\r\nmcpcia_startup_hose(hose);\r\n}\r\nstatic void\r\nmcpcia_print_uncorrectable(struct el_MCPCIA_uncorrected_frame_mcheck *logout)\r\n{\r\nstruct el_common_EV5_uncorrectable_mcheck *frame;\r\nint i;\r\nframe = &logout->procdata;\r\nfor (i = 0; i < 24; i += 2) {\r\nprintk(" paltmp[%d-%d] = %16lx %16lx\n",\r\ni, i+1, frame->paltemp[i], frame->paltemp[i+1]);\r\n}\r\nfor (i = 0; i < 8; i += 2) {\r\nprintk(" shadow[%d-%d] = %16lx %16lx\n",\r\ni, i+1, frame->shadow[i],\r\nframe->shadow[i+1]);\r\n}\r\nprintk(" Addr of excepting instruction = %16lx\n",\r\nframe->exc_addr);\r\nprintk(" Summary of arithmetic traps = %16lx\n",\r\nframe->exc_sum);\r\nprintk(" Exception mask = %16lx\n",\r\nframe->exc_mask);\r\nprintk(" Base address for PALcode = %16lx\n",\r\nframe->pal_base);\r\nprintk(" Interrupt Status Reg = %16lx\n",\r\nframe->isr);\r\nprintk(" CURRENT SETUP OF EV5 IBOX = %16lx\n",\r\nframe->icsr);\r\nprintk(" I-CACHE Reg %s parity error = %16lx\n",\r\n(frame->ic_perr_stat & 0x800L) ?\r\n"Data" : "Tag",\r\nframe->ic_perr_stat);\r\nprintk(" D-CACHE error Reg = %16lx\n",\r\nframe->dc_perr_stat);\r\nif (frame->dc_perr_stat & 0x2) {\r\nswitch (frame->dc_perr_stat & 0x03c) {\r\ncase 8:\r\nprintk(" Data error in bank 1\n");\r\nbreak;\r\ncase 4:\r\nprintk(" Data error in bank 0\n");\r\nbreak;\r\ncase 20:\r\nprintk(" Tag error in bank 1\n");\r\nbreak;\r\ncase 10:\r\nprintk(" Tag error in bank 0\n");\r\nbreak;\r\n}\r\n}\r\nprintk(" Effective VA = %16lx\n",\r\nframe->va);\r\nprintk(" Reason for D-stream = %16lx\n",\r\nframe->mm_stat);\r\nprintk(" EV5 SCache address = %16lx\n",\r\nframe->sc_addr);\r\nprintk(" EV5 SCache TAG/Data parity = %16lx\n",\r\nframe->sc_stat);\r\nprintk(" EV5 BC_TAG_ADDR = %16lx\n",\r\nframe->bc_tag_addr);\r\nprintk(" EV5 EI_ADDR: Phys addr of Xfer = %16lx\n",\r\nframe->ei_addr);\r\nprintk(" Fill Syndrome = %16lx\n",\r\nframe->fill_syndrome);\r\nprintk(" EI_STAT reg = %16lx\n",\r\nframe->ei_stat);\r\nprintk(" LD_LOCK = %16lx\n",\r\nframe->ld_lock);\r\n}\r\nstatic void\r\nmcpcia_print_system_area(unsigned long la_ptr)\r\n{\r\nstruct el_common *frame;\r\nstruct pci_controller *hose;\r\nstruct IOD_subpacket {\r\nunsigned long base;\r\nunsigned int whoami;\r\nunsigned int rsvd1;\r\nunsigned int pci_rev;\r\nunsigned int cap_ctrl;\r\nunsigned int hae_mem;\r\nunsigned int hae_io;\r\nunsigned int int_ctl;\r\nunsigned int int_reg;\r\nunsigned int int_mask0;\r\nunsigned int int_mask1;\r\nunsigned int mc_err0;\r\nunsigned int mc_err1;\r\nunsigned int cap_err;\r\nunsigned int rsvd2;\r\nunsigned int pci_err1;\r\nunsigned int mdpa_stat;\r\nunsigned int mdpa_syn;\r\nunsigned int mdpb_stat;\r\nunsigned int mdpb_syn;\r\nunsigned int rsvd3;\r\nunsigned int rsvd4;\r\nunsigned int rsvd5;\r\n} *iodpp;\r\nframe = (struct el_common *)la_ptr;\r\niodpp = (struct IOD_subpacket *) (la_ptr + frame->sys_offset);\r\nfor (hose = hose_head; hose; hose = hose->next, iodpp++) {\r\nprintk("IOD %d Register Subpacket - Bridge Base Address %16lx\n",\r\nhose->index, iodpp->base);\r\nprintk(" WHOAMI = %8x\n", iodpp->whoami);\r\nprintk(" PCI_REV = %8x\n", iodpp->pci_rev);\r\nprintk(" CAP_CTRL = %8x\n", iodpp->cap_ctrl);\r\nprintk(" HAE_MEM = %8x\n", iodpp->hae_mem);\r\nprintk(" HAE_IO = %8x\n", iodpp->hae_io);\r\nprintk(" INT_CTL = %8x\n", iodpp->int_ctl);\r\nprintk(" INT_REG = %8x\n", iodpp->int_reg);\r\nprintk(" INT_MASK0 = %8x\n", iodpp->int_mask0);\r\nprintk(" INT_MASK1 = %8x\n", iodpp->int_mask1);\r\nprintk(" MC_ERR0 = %8x\n", iodpp->mc_err0);\r\nprintk(" MC_ERR1 = %8x\n", iodpp->mc_err1);\r\nprintk(" CAP_ERR = %8x\n", iodpp->cap_err);\r\nprintk(" PCI_ERR1 = %8x\n", iodpp->pci_err1);\r\nprintk(" MDPA_STAT = %8x\n", iodpp->mdpa_stat);\r\nprintk(" MDPA_SYN = %8x\n", iodpp->mdpa_syn);\r\nprintk(" MDPB_STAT = %8x\n", iodpp->mdpb_stat);\r\nprintk(" MDPB_SYN = %8x\n", iodpp->mdpb_syn);\r\n}\r\n}\r\nvoid\r\nmcpcia_machine_check(unsigned long vector, unsigned long la_ptr)\r\n{\r\nstruct el_MCPCIA_uncorrected_frame_mcheck *mchk_logout;\r\nunsigned int cpu = smp_processor_id();\r\nint expected;\r\nmchk_logout = (struct el_MCPCIA_uncorrected_frame_mcheck *)la_ptr;\r\nexpected = mcheck_expected(cpu);\r\nmb();\r\nmb();\r\ndraina();\r\nswitch (expected) {\r\ncase 0:\r\n{\r\nstruct pci_controller *hose;\r\nfor (hose = hose_head; hose; hose = hose->next)\r\nmcpcia_pci_clr_err(MCPCIA_HOSE2MID(hose->index));\r\nbreak;\r\n}\r\ncase 1:\r\nmcpcia_pci_clr_err(mcheck_extra(cpu));\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nwrmces(0x7);\r\nmb();\r\nprocess_mcheck_info(vector, la_ptr, "MCPCIA", expected != 0);\r\nif (!expected && vector != 0x620 && vector != 0x630) {\r\nmcpcia_print_uncorrectable(mchk_logout);\r\nmcpcia_print_system_area(la_ptr);\r\n}\r\n}
