static int ttusb_cmd(struct ttusb *ttusb,\r\nconst u8 * data, int len, int needresult)\r\n{\r\nint actual_len;\r\nint err;\r\nint i;\r\nif (debug >= 3) {\r\nprintk(KERN_DEBUG ">");\r\nfor (i = 0; i < len; ++i)\r\nprintk(KERN_CONT " %02x", data[i]);\r\nprintk(KERN_CONT "\n");\r\n}\r\nif (mutex_lock_interruptible(&ttusb->semusb) < 0)\r\nreturn -EAGAIN;\r\nerr = usb_bulk_msg(ttusb->dev, ttusb->bulk_out_pipe,\r\n(u8 *) data, len, &actual_len, 1000);\r\nif (err != 0) {\r\ndprintk("%s: usb_bulk_msg(send) failed, err == %i!\n",\r\n__func__, err);\r\nmutex_unlock(&ttusb->semusb);\r\nreturn err;\r\n}\r\nif (actual_len != len) {\r\ndprintk("%s: only wrote %d of %d bytes\n", __func__,\r\nactual_len, len);\r\nmutex_unlock(&ttusb->semusb);\r\nreturn -1;\r\n}\r\nerr = usb_bulk_msg(ttusb->dev, ttusb->bulk_in_pipe,\r\nttusb->last_result, 32, &actual_len, 1000);\r\nif (err != 0) {\r\nprintk("%s: failed, receive error %d\n", __func__,\r\nerr);\r\nmutex_unlock(&ttusb->semusb);\r\nreturn err;\r\n}\r\nif (debug >= 3) {\r\nactual_len = ttusb->last_result[3] + 4;\r\nprintk(KERN_DEBUG "<");\r\nfor (i = 0; i < actual_len; ++i)\r\nprintk(KERN_CONT " %02x", ttusb->last_result[i]);\r\nprintk(KERN_CONT "\n");\r\n}\r\nif (!needresult)\r\nmutex_unlock(&ttusb->semusb);\r\nreturn 0;\r\n}\r\nstatic int ttusb_result(struct ttusb *ttusb, u8 * data, int len)\r\n{\r\nmemcpy(data, ttusb->last_result, len);\r\nmutex_unlock(&ttusb->semusb);\r\nreturn 0;\r\n}\r\nstatic int ttusb_i2c_msg(struct ttusb *ttusb,\r\nu8 addr, u8 * snd_buf, u8 snd_len, u8 * rcv_buf,\r\nu8 rcv_len)\r\n{\r\nu8 b[0x28];\r\nu8 id = ++ttusb->c;\r\nint i, err;\r\nif (snd_len > 0x28 - 7 || rcv_len > 0x20 - 7)\r\nreturn -EINVAL;\r\nb[0] = 0xaa;\r\nb[1] = id;\r\nb[2] = 0x31;\r\nb[3] = snd_len + 3;\r\nb[4] = addr << 1;\r\nb[5] = snd_len;\r\nb[6] = rcv_len;\r\nfor (i = 0; i < snd_len; i++)\r\nb[7 + i] = snd_buf[i];\r\nerr = ttusb_cmd(ttusb, b, snd_len + 7, 1);\r\nif (err)\r\nreturn -EREMOTEIO;\r\nerr = ttusb_result(ttusb, b, 0x20);\r\nif ((snd_len != b[5]) || (rcv_len != b[6])) return -EREMOTEIO;\r\nif (rcv_len > 0) {\r\nif (err || b[0] != 0x55 || b[1] != id) {\r\ndprintk\r\n("%s: usb_bulk_msg(recv) failed, err == %i, id == %02x, b == ",\r\n__func__, err, id);\r\nreturn -EREMOTEIO;\r\n}\r\nfor (i = 0; i < rcv_len; i++)\r\nrcv_buf[i] = b[7 + i];\r\n}\r\nreturn rcv_len;\r\n}\r\nstatic int master_xfer(struct i2c_adapter* adapter, struct i2c_msg *msg, int num)\r\n{\r\nstruct ttusb *ttusb = i2c_get_adapdata(adapter);\r\nint i = 0;\r\nint inc;\r\nif (mutex_lock_interruptible(&ttusb->semi2c) < 0)\r\nreturn -EAGAIN;\r\nwhile (i < num) {\r\nu8 addr, snd_len, rcv_len, *snd_buf, *rcv_buf;\r\nint err;\r\nif (num > i + 1 && (msg[i + 1].flags & I2C_M_RD)) {\r\naddr = msg[i].addr;\r\nsnd_buf = msg[i].buf;\r\nsnd_len = msg[i].len;\r\nrcv_buf = msg[i + 1].buf;\r\nrcv_len = msg[i + 1].len;\r\ninc = 2;\r\n} else {\r\naddr = msg[i].addr;\r\nsnd_buf = msg[i].buf;\r\nsnd_len = msg[i].len;\r\nrcv_buf = NULL;\r\nrcv_len = 0;\r\ninc = 1;\r\n}\r\nerr = ttusb_i2c_msg(ttusb, addr,\r\nsnd_buf, snd_len, rcv_buf, rcv_len);\r\nif (err < rcv_len) {\r\ndprintk("%s: i == %i\n", __func__, i);\r\nbreak;\r\n}\r\ni += inc;\r\n}\r\nmutex_unlock(&ttusb->semi2c);\r\nreturn i;\r\n}\r\nstatic int ttusb_boot_dsp(struct ttusb *ttusb)\r\n{\r\nconst struct firmware *fw;\r\nint i, err;\r\nu8 b[40];\r\nerr = request_firmware(&fw, "ttusb-budget/dspbootcode.bin",\r\n&ttusb->dev->dev);\r\nif (err) {\r\nprintk(KERN_ERR "ttusb-budget: failed to request firmware\n");\r\nreturn err;\r\n}\r\nb[0] = 0xaa;\r\nb[2] = 0x13;\r\nb[3] = 28;\r\nfor (i = 0; i < fw->size; i += 28) {\r\nmemcpy(&b[4], &fw->data[i], 28);\r\nb[1] = ++ttusb->c;\r\nerr = ttusb_cmd(ttusb, b, 32, 0);\r\nif (err)\r\ngoto done;\r\n}\r\nb[1] = ++ttusb->c;\r\nb[2] = 0x13;\r\nb[3] = 0;\r\nerr = ttusb_cmd(ttusb, b, 4, 0);\r\nif (err)\r\ngoto done;\r\nb[1] = ++ttusb->c;\r\nb[2] = 0x14;\r\nb[3] = 0;\r\nerr = ttusb_cmd(ttusb, b, 4, 0);\r\ndone:\r\nrelease_firmware(fw);\r\nif (err) {\r\ndprintk("%s: usb_bulk_msg() failed, return value %i!\n",\r\n__func__, err);\r\n}\r\nreturn err;\r\n}\r\nstatic int ttusb_set_channel(struct ttusb *ttusb, int chan_id, int filter_type,\r\nint pid)\r\n{\r\nint err;\r\nu8 b[] = { 0xaa, ++ttusb->c, 0x22, 4, chan_id, filter_type,\r\n(pid >> 8) & 0xff, pid & 0xff\r\n};\r\nerr = ttusb_cmd(ttusb, b, sizeof(b), 0);\r\nreturn err;\r\n}\r\nstatic int ttusb_del_channel(struct ttusb *ttusb, int channel_id)\r\n{\r\nint err;\r\nu8 b[] = { 0xaa, ++ttusb->c, 0x23, 1, channel_id };\r\nerr = ttusb_cmd(ttusb, b, sizeof(b), 0);\r\nreturn err;\r\n}\r\nstatic int ttusb_set_filter(struct ttusb *ttusb, int filter_id,\r\nint associated_chan, u8 filter[8], u8 mask[8])\r\n{\r\nint err;\r\nu8 b[] = { 0xaa, 0, 0x24, 0x1a, filter_id, associated_chan,\r\nfilter[0], filter[1], filter[2], filter[3],\r\nfilter[4], filter[5], filter[6], filter[7],\r\nfilter[8], filter[9], filter[10], filter[11],\r\nmask[0], mask[1], mask[2], mask[3],\r\nmask[4], mask[5], mask[6], mask[7],\r\nmask[8], mask[9], mask[10], mask[11]\r\n};\r\nerr = ttusb_cmd(ttusb, b, sizeof(b), 0);\r\nreturn err;\r\n}\r\nstatic int ttusb_del_filter(struct ttusb *ttusb, int filter_id)\r\n{\r\nint err;\r\nu8 b[] = { 0xaa, ++ttusb->c, 0x25, 1, filter_id };\r\nerr = ttusb_cmd(ttusb, b, sizeof(b), 0);\r\nreturn err;\r\n}\r\nstatic int ttusb_init_controller(struct ttusb *ttusb)\r\n{\r\nu8 b0[] = { 0xaa, ++ttusb->c, 0x15, 1, 0 };\r\nu8 b1[] = { 0xaa, ++ttusb->c, 0x15, 1, 1 };\r\nu8 b2[] = { 0xaa, ++ttusb->c, 0x32, 1, 0 };\r\nu8 b3[] =\r\n{ 0xaa, ++ttusb->c, 0x31, 5, 0x10, 0x02, 0x01, 0x00, 0x1e };\r\nu8 b4[] =\r\n{ 0x55, ttusb->c, 0x31, 4, 0x10, 0x02, 0x01, 0x00, 0x1e };\r\nu8 get_version[] = { 0xaa, ++ttusb->c, 0x17, 5, 0, 0, 0, 0, 0 };\r\nu8 get_dsp_version[0x20] =\r\n{ 0xaa, ++ttusb->c, 0x26, 28, 0, 0, 0, 0, 0 };\r\nint err;\r\nif ((err = ttusb_cmd(ttusb, b0, sizeof(b0), 0)))\r\nreturn err;\r\nif ((err = ttusb_cmd(ttusb, b1, sizeof(b1), 0)))\r\nreturn err;\r\nttusb_boot_dsp(ttusb);\r\nif ((err = ttusb_cmd(ttusb, b2, sizeof(b2), 0)))\r\nreturn err;\r\nif ((err = ttusb_cmd(ttusb, b3, sizeof(b3), 1)))\r\nreturn err;\r\nerr = ttusb_result(ttusb, b4, sizeof(b4));\r\nif ((err = ttusb_cmd(ttusb, get_version, sizeof(get_version), 1)))\r\nreturn err;\r\nif ((err = ttusb_result(ttusb, get_version, sizeof(get_version))))\r\nreturn err;\r\ndprintk("%s: stc-version: %c%c%c%c%c\n", __func__,\r\nget_version[4], get_version[5], get_version[6],\r\nget_version[7], get_version[8]);\r\nif (memcmp(get_version + 4, "V 0.0", 5) &&\r\nmemcmp(get_version + 4, "V 1.1", 5) &&\r\nmemcmp(get_version + 4, "V 2.1", 5) &&\r\nmemcmp(get_version + 4, "V 2.2", 5)) {\r\nprintk\r\n("%s: unknown STC version %c%c%c%c%c, please report!\n",\r\n__func__, get_version[4], get_version[5],\r\nget_version[6], get_version[7], get_version[8]);\r\n}\r\nttusb->revision = ((get_version[6] - '0') << 4) |\r\n(get_version[8] - '0');\r\nerr =\r\nttusb_cmd(ttusb, get_dsp_version, sizeof(get_dsp_version), 1);\r\nif (err)\r\nreturn err;\r\nerr =\r\nttusb_result(ttusb, get_dsp_version, sizeof(get_dsp_version));\r\nif (err)\r\nreturn err;\r\nprintk("%s: dsp-version: %c%c%c\n", __func__,\r\nget_dsp_version[4], get_dsp_version[5], get_dsp_version[6]);\r\nreturn 0;\r\n}\r\nstatic int ttusb_send_diseqc(struct dvb_frontend* fe,\r\nconst struct dvb_diseqc_master_cmd *cmd)\r\n{\r\nstruct ttusb* ttusb = (struct ttusb*) fe->dvb->priv;\r\nu8 b[12] = { 0xaa, ++ttusb->c, 0x18 };\r\nint err;\r\nb[3] = 4 + 2 + cmd->msg_len;\r\nb[4] = 0xFF;\r\nb[5] = cmd->msg_len;\r\nmemcpy(b + 5, cmd->msg, cmd->msg_len);\r\nif ((err = ttusb_cmd(ttusb, b, 4 + b[3], 0))) {\r\ndprintk("%s: usb_bulk_msg() failed, return value %i!\n",\r\n__func__, err);\r\n}\r\nreturn err;\r\n}\r\nstatic int ttusb_update_lnb(struct ttusb *ttusb)\r\n{\r\nu8 b[] = { 0xaa, ++ttusb->c, 0x16, 5, 1,\r\nttusb->voltage == SEC_VOLTAGE_18 ? 0 : 1,\r\nttusb->tone == SEC_TONE_ON ? 1 : 0, 1, 1\r\n};\r\nint err;\r\nif ((err = ttusb_cmd(ttusb, b, sizeof(b), 0))) {\r\ndprintk("%s: usb_bulk_msg() failed, return value %i!\n",\r\n__func__, err);\r\n}\r\nreturn err;\r\n}\r\nstatic int ttusb_set_voltage(struct dvb_frontend* fe, fe_sec_voltage_t voltage)\r\n{\r\nstruct ttusb* ttusb = (struct ttusb*) fe->dvb->priv;\r\nttusb->voltage = voltage;\r\nreturn ttusb_update_lnb(ttusb);\r\n}\r\nstatic int ttusb_set_tone(struct dvb_frontend* fe, fe_sec_tone_mode_t tone)\r\n{\r\nstruct ttusb* ttusb = (struct ttusb*) fe->dvb->priv;\r\nttusb->tone = tone;\r\nreturn ttusb_update_lnb(ttusb);\r\n}\r\nstatic void ttusb_process_muxpack(struct ttusb *ttusb, const u8 * muxpack,\r\nint len)\r\n{\r\nu16 csum = 0, cc;\r\nint i;\r\nif (len < 4 || len & 0x1) {\r\npr_warn("%s: muxpack has invalid len %d\n", __func__, len);\r\nnuminvalid++;\r\nreturn;\r\n}\r\nfor (i = 0; i < len; i += 2)\r\ncsum ^= le16_to_cpup((__le16 *) (muxpack + i));\r\nif (csum) {\r\nprintk("%s: muxpack with incorrect checksum, ignoring\n",\r\n__func__);\r\nnuminvalid++;\r\nreturn;\r\n}\r\ncc = (muxpack[len - 4] << 8) | muxpack[len - 3];\r\ncc &= 0x7FFF;\r\nif ((cc != ttusb->cc) && (ttusb->cc != -1))\r\nprintk("%s: cc discontinuity (%d frames missing)\n",\r\n__func__, (cc - ttusb->cc) & 0x7FFF);\r\nttusb->cc = (cc + 1) & 0x7FFF;\r\nif (muxpack[0] & 0x80) {\r\n#ifdef TTUSB_HWSECTIONS\r\nint pusi = muxpack[0] & 0x40;\r\nint channel = muxpack[0] & 0x1F;\r\nint payload = muxpack[1];\r\nconst u8 *data = muxpack + 2;\r\nif (muxpack[0] & 0x20)\r\ndata++;\r\nttusb_handle_sec_data(ttusb->channel + channel, data,\r\npayload);\r\ndata += payload;\r\nif ((!!(ttusb->muxpack[0] & 0x20)) ^\r\n!!(ttusb->muxpack[1] & 1))\r\ndata++;\r\n#warning TODO: pusi\r\nprintk("cc: %04x\n", (data[0] << 8) | data[1]);\r\n#endif\r\nnumsec++;\r\n} else if (muxpack[0] == 0x47) {\r\n#ifdef TTUSB_HWSECTIONS\r\nint pid = ((muxpack[1] & 0x0F) << 8) | muxpack[2];\r\nint channel;\r\nfor (channel = 0; channel < TTUSB_MAXCHANNEL; ++channel)\r\nif (ttusb->channel[channel].active\r\n&& (pid == ttusb->channel[channel].pid))\r\nttusb_handle_ts_data(ttusb->channel +\r\nchannel, muxpack,\r\n188);\r\n#endif\r\nnumts++;\r\ndvb_dmx_swfilter_packets(&ttusb->dvb_demux, muxpack, 1);\r\n} else if (muxpack[0] != 0) {\r\nnuminvalid++;\r\nprintk("illegal muxpack type %02x\n", muxpack[0]);\r\n} else\r\nnumstuff++;\r\n}\r\nstatic void ttusb_process_frame(struct ttusb *ttusb, u8 * data, int len)\r\n{\r\nint maxwork = 1024;\r\nwhile (len) {\r\nif (!(maxwork--)) {\r\nprintk("%s: too much work\n", __func__);\r\nbreak;\r\n}\r\nswitch (ttusb->mux_state) {\r\ncase 0:\r\ncase 1:\r\ncase 2:\r\nlen--;\r\nif (*data++ == 0xAA)\r\n++ttusb->mux_state;\r\nelse {\r\nttusb->mux_state = 0;\r\nif (ttusb->insync) {\r\ndprintk("%s: %02x\n",\r\n__func__, data[-1]);\r\nprintk(KERN_INFO "%s: lost sync.\n",\r\n__func__);\r\nttusb->insync = 0;\r\n}\r\n}\r\nbreak;\r\ncase 3:\r\nttusb->insync = 1;\r\nlen--;\r\nttusb->mux_npacks = *data++;\r\n++ttusb->mux_state;\r\nttusb->muxpack_ptr = 0;\r\nttusb->muxpack_len = 2;\r\nbreak;\r\ncase 4:\r\n{\r\nint avail;\r\navail = len;\r\nif (avail >\r\n(ttusb->muxpack_len -\r\nttusb->muxpack_ptr))\r\navail =\r\nttusb->muxpack_len -\r\nttusb->muxpack_ptr;\r\nmemcpy(ttusb->muxpack + ttusb->muxpack_ptr,\r\ndata, avail);\r\nttusb->muxpack_ptr += avail;\r\nBUG_ON(ttusb->muxpack_ptr > 264);\r\ndata += avail;\r\nlen -= avail;\r\nif (ttusb->muxpack_ptr == 2) {\r\nif (ttusb->muxpack[0] & 0x80) {\r\nttusb->muxpack_len =\r\nttusb->muxpack[1] + 2;\r\nif (ttusb->\r\nmuxpack[0] & 0x20)\r\nttusb->\r\nmuxpack_len++;\r\nif ((!!\r\n(ttusb->\r\nmuxpack[0] & 0x20)) ^\r\n!!(ttusb->\r\nmuxpack[1] & 1))\r\nttusb->\r\nmuxpack_len++;\r\nttusb->muxpack_len += 4;\r\n} else if (ttusb->muxpack[0] ==\r\n0x47)\r\nttusb->muxpack_len =\r\n188 + 4;\r\nelse if (ttusb->muxpack[0] == 0x00)\r\nttusb->muxpack_len =\r\nttusb->muxpack[1] + 2 +\r\n4;\r\nelse {\r\ndprintk\r\n("%s: invalid state: first byte is %x\n",\r\n__func__,\r\nttusb->muxpack[0]);\r\nttusb->mux_state = 0;\r\n}\r\n}\r\nif ((ttusb->muxpack_ptr >= 2) &&\r\n(ttusb->muxpack_ptr ==\r\nttusb->muxpack_len)) {\r\nttusb_process_muxpack(ttusb,\r\nttusb->\r\nmuxpack,\r\nttusb->\r\nmuxpack_ptr);\r\nttusb->muxpack_ptr = 0;\r\nttusb->muxpack_len = 2;\r\nif (!ttusb->mux_npacks--) {\r\nttusb->mux_state = 0;\r\nbreak;\r\n}\r\n}\r\nbreak;\r\n}\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void ttusb_iso_irq(struct urb *urb)\r\n{\r\nstruct ttusb *ttusb = urb->context;\r\nstruct usb_iso_packet_descriptor *d;\r\nu8 *data;\r\nint len, i;\r\nif (!ttusb->iso_streaming)\r\nreturn;\r\n#if 0\r\nprintk("%s: status %d, errcount == %d, length == %i\n",\r\n__func__,\r\nurb->status, urb->error_count, urb->actual_length);\r\n#endif\r\nif (!urb->status) {\r\nfor (i = 0; i < urb->number_of_packets; ++i) {\r\nnumpkt++;\r\nif (time_after_eq(jiffies, lastj + HZ)) {\r\ndprintk("frames/s: %lu (ts: %d, stuff %d, "\r\n"sec: %d, invalid: %d, all: %d)\n",\r\nnumpkt * HZ / (jiffies - lastj),\r\nnumts, numstuff, numsec, numinvalid,\r\nnumts + numstuff + numsec + numinvalid);\r\nnumts = numstuff = numsec = numinvalid = 0;\r\nlastj = jiffies;\r\nnumpkt = 0;\r\n}\r\nd = &urb->iso_frame_desc[i];\r\ndata = urb->transfer_buffer + d->offset;\r\nlen = d->actual_length;\r\nd->actual_length = 0;\r\nd->status = 0;\r\nttusb_process_frame(ttusb, data, len);\r\n}\r\n}\r\nusb_submit_urb(urb, GFP_ATOMIC);\r\n}\r\nstatic void ttusb_free_iso_urbs(struct ttusb *ttusb)\r\n{\r\nint i;\r\nfor (i = 0; i < ISO_BUF_COUNT; i++)\r\nusb_free_urb(ttusb->iso_urb[i]);\r\npci_free_consistent(NULL,\r\nISO_FRAME_SIZE * FRAMES_PER_ISO_BUF *\r\nISO_BUF_COUNT, ttusb->iso_buffer,\r\nttusb->iso_dma_handle);\r\n}\r\nstatic int ttusb_alloc_iso_urbs(struct ttusb *ttusb)\r\n{\r\nint i;\r\nttusb->iso_buffer = pci_zalloc_consistent(NULL,\r\nISO_FRAME_SIZE * FRAMES_PER_ISO_BUF * ISO_BUF_COUNT,\r\n&ttusb->iso_dma_handle);\r\nif (!ttusb->iso_buffer) {\r\ndprintk("%s: pci_alloc_consistent - not enough memory\n",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < ISO_BUF_COUNT; i++) {\r\nstruct urb *urb;\r\nif (!\r\n(urb =\r\nusb_alloc_urb(FRAMES_PER_ISO_BUF, GFP_ATOMIC))) {\r\nttusb_free_iso_urbs(ttusb);\r\nreturn -ENOMEM;\r\n}\r\nttusb->iso_urb[i] = urb;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ttusb_stop_iso_xfer(struct ttusb *ttusb)\r\n{\r\nint i;\r\nfor (i = 0; i < ISO_BUF_COUNT; i++)\r\nusb_kill_urb(ttusb->iso_urb[i]);\r\nttusb->iso_streaming = 0;\r\n}\r\nstatic int ttusb_start_iso_xfer(struct ttusb *ttusb)\r\n{\r\nint i, j, err, buffer_offset = 0;\r\nif (ttusb->iso_streaming) {\r\nprintk("%s: iso xfer already running!\n", __func__);\r\nreturn 0;\r\n}\r\nttusb->cc = -1;\r\nttusb->insync = 0;\r\nttusb->mux_state = 0;\r\nfor (i = 0; i < ISO_BUF_COUNT; i++) {\r\nint frame_offset = 0;\r\nstruct urb *urb = ttusb->iso_urb[i];\r\nurb->dev = ttusb->dev;\r\nurb->context = ttusb;\r\nurb->complete = ttusb_iso_irq;\r\nurb->pipe = ttusb->isoc_in_pipe;\r\nurb->transfer_flags = URB_ISO_ASAP;\r\nurb->interval = 1;\r\nurb->number_of_packets = FRAMES_PER_ISO_BUF;\r\nurb->transfer_buffer_length =\r\nISO_FRAME_SIZE * FRAMES_PER_ISO_BUF;\r\nurb->transfer_buffer = ttusb->iso_buffer + buffer_offset;\r\nbuffer_offset += ISO_FRAME_SIZE * FRAMES_PER_ISO_BUF;\r\nfor (j = 0; j < FRAMES_PER_ISO_BUF; j++) {\r\nurb->iso_frame_desc[j].offset = frame_offset;\r\nurb->iso_frame_desc[j].length = ISO_FRAME_SIZE;\r\nframe_offset += ISO_FRAME_SIZE;\r\n}\r\n}\r\nfor (i = 0; i < ISO_BUF_COUNT; i++) {\r\nif ((err = usb_submit_urb(ttusb->iso_urb[i], GFP_ATOMIC))) {\r\nttusb_stop_iso_xfer(ttusb);\r\nprintk\r\n("%s: failed urb submission (%i: err = %i)!\n",\r\n__func__, i, err);\r\nreturn err;\r\n}\r\n}\r\nttusb->iso_streaming = 1;\r\nreturn 0;\r\n}\r\nstatic void ttusb_handle_ts_data(struct dvb_demux_feed *dvbdmxfeed, const u8 * data,\r\nint len)\r\n{\r\ndvbdmxfeed->cb.ts(data, len, 0, 0, &dvbdmxfeed->feed.ts, 0);\r\n}\r\nstatic void ttusb_handle_sec_data(struct dvb_demux_feed *dvbdmxfeed, const u8 * data,\r\nint len)\r\n{\r\n#error TODO: handle ugly stuff\r\n}\r\nstatic int ttusb_start_feed(struct dvb_demux_feed *dvbdmxfeed)\r\n{\r\nstruct ttusb *ttusb = (struct ttusb *) dvbdmxfeed->demux;\r\nint feed_type = 1;\r\ndprintk("ttusb_start_feed\n");\r\nswitch (dvbdmxfeed->type) {\r\ncase DMX_TYPE_TS:\r\nbreak;\r\ncase DMX_TYPE_SEC:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (dvbdmxfeed->type == DMX_TYPE_TS) {\r\nswitch (dvbdmxfeed->pes_type) {\r\ncase DMX_PES_VIDEO:\r\ncase DMX_PES_AUDIO:\r\ncase DMX_PES_TELETEXT:\r\ncase DMX_PES_PCR:\r\ncase DMX_PES_OTHER:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\n#ifdef TTUSB_HWSECTIONS\r\n#error TODO: allocate filters\r\nif (dvbdmxfeed->type == DMX_TYPE_TS) {\r\nfeed_type = 1;\r\n} else if (dvbdmxfeed->type == DMX_TYPE_SEC) {\r\nfeed_type = 2;\r\n}\r\n#endif\r\nttusb_set_channel(ttusb, dvbdmxfeed->index, feed_type, dvbdmxfeed->pid);\r\nif (0 == ttusb->running_feed_count++)\r\nttusb_start_iso_xfer(ttusb);\r\nreturn 0;\r\n}\r\nstatic int ttusb_stop_feed(struct dvb_demux_feed *dvbdmxfeed)\r\n{\r\nstruct ttusb *ttusb = (struct ttusb *) dvbdmxfeed->demux;\r\nttusb_del_channel(ttusb, dvbdmxfeed->index);\r\nif (--ttusb->running_feed_count == 0)\r\nttusb_stop_iso_xfer(ttusb);\r\nreturn 0;\r\n}\r\nstatic int ttusb_setup_interfaces(struct ttusb *ttusb)\r\n{\r\nusb_set_interface(ttusb->dev, 1, 1);\r\nttusb->bulk_out_pipe = usb_sndbulkpipe(ttusb->dev, 1);\r\nttusb->bulk_in_pipe = usb_rcvbulkpipe(ttusb->dev, 1);\r\nttusb->isoc_in_pipe = usb_rcvisocpipe(ttusb->dev, 2);\r\nreturn 0;\r\n}\r\nstatic u32 functionality(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nstatic int alps_tdmb7_tuner_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct ttusb* ttusb = (struct ttusb*) fe->dvb->priv;\r\nu8 data[4];\r\nstruct i2c_msg msg = {.addr=0x61, .flags=0, .buf=data, .len=sizeof(data) };\r\nu32 div;\r\ndiv = (p->frequency + 36166667) / 166667;\r\ndata[0] = (div >> 8) & 0x7f;\r\ndata[1] = div & 0xff;\r\ndata[2] = ((div >> 10) & 0x60) | 0x85;\r\ndata[3] = p->frequency < 592000000 ? 0x40 : 0x80;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (i2c_transfer(&ttusb->i2c_adap, &msg, 1) != 1) return -EIO;\r\nreturn 0;\r\n}\r\nstatic int philips_tdm1316l_tuner_init(struct dvb_frontend* fe)\r\n{\r\nstruct ttusb* ttusb = (struct ttusb*) fe->dvb->priv;\r\nstatic u8 td1316_init[] = { 0x0b, 0xf5, 0x85, 0xab };\r\nstatic u8 disable_mc44BC374c[] = { 0x1d, 0x74, 0xa0, 0x68 };\r\nstruct i2c_msg tuner_msg = { .addr=0x60, .flags=0, .buf=td1316_init, .len=sizeof(td1316_init) };\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (i2c_transfer(&ttusb->i2c_adap, &tuner_msg, 1) != 1) return -EIO;\r\nmsleep(1);\r\ntuner_msg.addr = 0x65;\r\ntuner_msg.buf = disable_mc44BC374c;\r\ntuner_msg.len = sizeof(disable_mc44BC374c);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (i2c_transfer(&ttusb->i2c_adap, &tuner_msg, 1) != 1) {\r\ni2c_transfer(&ttusb->i2c_adap, &tuner_msg, 1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int philips_tdm1316l_tuner_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct ttusb* ttusb = (struct ttusb*) fe->dvb->priv;\r\nu8 tuner_buf[4];\r\nstruct i2c_msg tuner_msg = {.addr=0x60, .flags=0, .buf=tuner_buf, .len=sizeof(tuner_buf) };\r\nint tuner_frequency = 0;\r\nu8 band, cp, filter;\r\ntuner_frequency = p->frequency + 36130000;\r\nif (tuner_frequency < 87000000) return -EINVAL;\r\nelse if (tuner_frequency < 130000000) cp = 3;\r\nelse if (tuner_frequency < 160000000) cp = 5;\r\nelse if (tuner_frequency < 200000000) cp = 6;\r\nelse if (tuner_frequency < 290000000) cp = 3;\r\nelse if (tuner_frequency < 420000000) cp = 5;\r\nelse if (tuner_frequency < 480000000) cp = 6;\r\nelse if (tuner_frequency < 620000000) cp = 3;\r\nelse if (tuner_frequency < 830000000) cp = 5;\r\nelse if (tuner_frequency < 895000000) cp = 7;\r\nelse return -EINVAL;\r\nif (p->frequency < 49000000)\r\nreturn -EINVAL;\r\nelse if (p->frequency < 159000000)\r\nband = 1;\r\nelse if (p->frequency < 444000000)\r\nband = 2;\r\nelse if (p->frequency < 861000000)\r\nband = 4;\r\nelse return -EINVAL;\r\nswitch (p->bandwidth_hz) {\r\ncase 6000000:\r\ntda1004x_writereg(fe, 0x0C, 0);\r\nfilter = 0;\r\nbreak;\r\ncase 7000000:\r\ntda1004x_writereg(fe, 0x0C, 0);\r\nfilter = 0;\r\nbreak;\r\ncase 8000000:\r\ntda1004x_writereg(fe, 0x0C, 0xFF);\r\nfilter = 1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ntuner_frequency = (((p->frequency / 1000) * 6) + 217280) / 1000;\r\ntuner_buf[0] = tuner_frequency >> 8;\r\ntuner_buf[1] = tuner_frequency & 0xff;\r\ntuner_buf[2] = 0xca;\r\ntuner_buf[3] = (cp << 5) | (filter << 3) | band;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (i2c_transfer(&ttusb->i2c_adap, &tuner_msg, 1) != 1)\r\nreturn -EIO;\r\nmsleep(1);\r\nreturn 0;\r\n}\r\nstatic int philips_tdm1316l_request_firmware(struct dvb_frontend* fe, const struct firmware **fw, char* name)\r\n{\r\nstruct ttusb* ttusb = (struct ttusb*) fe->dvb->priv;\r\nreturn request_firmware(fw, name, &ttusb->dev->dev);\r\n}\r\nstatic int alps_stv0299_set_symbol_rate(struct dvb_frontend *fe, u32 srate, u32 ratio)\r\n{\r\nu8 aclk = 0;\r\nu8 bclk = 0;\r\nif (srate < 1500000) {\r\naclk = 0xb7;\r\nbclk = 0x47;\r\n} else if (srate < 3000000) {\r\naclk = 0xb7;\r\nbclk = 0x4b;\r\n} else if (srate < 7000000) {\r\naclk = 0xb7;\r\nbclk = 0x4f;\r\n} else if (srate < 14000000) {\r\naclk = 0xb7;\r\nbclk = 0x53;\r\n} else if (srate < 30000000) {\r\naclk = 0xb6;\r\nbclk = 0x53;\r\n} else if (srate < 45000000) {\r\naclk = 0xb4;\r\nbclk = 0x51;\r\n}\r\nstv0299_writereg(fe, 0x13, aclk);\r\nstv0299_writereg(fe, 0x14, bclk);\r\nstv0299_writereg(fe, 0x1f, (ratio >> 16) & 0xff);\r\nstv0299_writereg(fe, 0x20, (ratio >> 8) & 0xff);\r\nstv0299_writereg(fe, 0x21, (ratio) & 0xf0);\r\nreturn 0;\r\n}\r\nstatic int philips_tsa5059_tuner_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct ttusb* ttusb = (struct ttusb*) fe->dvb->priv;\r\nu8 buf[4];\r\nu32 div;\r\nstruct i2c_msg msg = {.addr = 0x61,.flags = 0,.buf = buf,.len = sizeof(buf) };\r\nif ((p->frequency < 950000) || (p->frequency > 2150000))\r\nreturn -EINVAL;\r\ndiv = (p->frequency + (125 - 1)) / 125;\r\nbuf[0] = (div >> 8) & 0x7f;\r\nbuf[1] = div & 0xff;\r\nbuf[2] = 0x80 | ((div & 0x18000) >> 10) | 4;\r\nbuf[3] = 0xC4;\r\nif (p->frequency > 1530000)\r\nbuf[3] = 0xC0;\r\nif (ttusb->revision == TTUSB_REV_2_2)\r\nbuf[3] |= 0x20;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (i2c_transfer(&ttusb->i2c_adap, &msg, 1) != 1)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int ttusb_novas_grundig_29504_491_tuner_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct ttusb* ttusb = (struct ttusb*) fe->dvb->priv;\r\nu8 buf[4];\r\nu32 div;\r\nstruct i2c_msg msg = {.addr = 0x61,.flags = 0,.buf = buf,.len = sizeof(buf) };\r\ndiv = p->frequency / 125;\r\nbuf[0] = (div >> 8) & 0x7f;\r\nbuf[1] = div & 0xff;\r\nbuf[2] = 0x8e;\r\nbuf[3] = 0x00;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (i2c_transfer(&ttusb->i2c_adap, &msg, 1) != 1)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int alps_tdbe2_tuner_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct ttusb* ttusb = fe->dvb->priv;\r\nu32 div;\r\nu8 data[4];\r\nstruct i2c_msg msg = { .addr = 0x62, .flags = 0, .buf = data, .len = sizeof(data) };\r\ndiv = (p->frequency + 35937500 + 31250) / 62500;\r\ndata[0] = (div >> 8) & 0x7f;\r\ndata[1] = div & 0xff;\r\ndata[2] = 0x85 | ((div >> 10) & 0x60);\r\ndata[3] = (p->frequency < 174000000 ? 0x88 : p->frequency < 470000000 ? 0x84 : 0x81);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (i2c_transfer (&ttusb->i2c_adap, &msg, 1) != 1)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic u8 read_pwm(struct ttusb* ttusb)\r\n{\r\nu8 b = 0xff;\r\nu8 pwm;\r\nstruct i2c_msg msg[] = { { .addr = 0x50,.flags = 0,.buf = &b,.len = 1 },\r\n{ .addr = 0x50,.flags = I2C_M_RD,.buf = &pwm,.len = 1} };\r\nif ((i2c_transfer(&ttusb->i2c_adap, msg, 2) != 2) || (pwm == 0xff))\r\npwm = 0x48;\r\nreturn pwm;\r\n}\r\nstatic int dvbc_philips_tdm1316l_tuner_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct ttusb *ttusb = (struct ttusb *) fe->dvb->priv;\r\nu8 tuner_buf[5];\r\nstruct i2c_msg tuner_msg = {.addr = 0x60,\r\n.flags = 0,\r\n.buf = tuner_buf,\r\n.len = sizeof(tuner_buf) };\r\nint tuner_frequency = 0;\r\nu8 band, cp, filter;\r\ntuner_frequency = p->frequency;\r\nif (tuner_frequency < 87000000) {return -EINVAL;}\r\nelse if (tuner_frequency < 130000000) {cp = 3; band = 1;}\r\nelse if (tuner_frequency < 160000000) {cp = 5; band = 1;}\r\nelse if (tuner_frequency < 200000000) {cp = 6; band = 1;}\r\nelse if (tuner_frequency < 290000000) {cp = 3; band = 2;}\r\nelse if (tuner_frequency < 420000000) {cp = 5; band = 2;}\r\nelse if (tuner_frequency < 480000000) {cp = 6; band = 2;}\r\nelse if (tuner_frequency < 620000000) {cp = 3; band = 4;}\r\nelse if (tuner_frequency < 830000000) {cp = 5; band = 4;}\r\nelse if (tuner_frequency < 895000000) {cp = 7; band = 4;}\r\nelse {return -EINVAL;}\r\nfilter = 1;\r\ntuner_frequency = ((p->frequency + 36125000) / 62500);\r\ntuner_buf[0] = tuner_frequency >> 8;\r\ntuner_buf[1] = tuner_frequency & 0xff;\r\ntuner_buf[2] = 0xc8;\r\ntuner_buf[3] = (cp << 5) | (filter << 3) | band;\r\ntuner_buf[4] = 0x80;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (i2c_transfer(&ttusb->i2c_adap, &tuner_msg, 1) != 1) {\r\nprintk("dvb-ttusb-budget: dvbc_philips_tdm1316l_pll_set Error 1\n");\r\nreturn -EIO;\r\n}\r\nmsleep(50);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (i2c_transfer(&ttusb->i2c_adap, &tuner_msg, 1) != 1) {\r\nprintk("dvb-ttusb-budget: dvbc_philips_tdm1316l_pll_set Error 2\n");\r\nreturn -EIO;\r\n}\r\nmsleep(1);\r\nreturn 0;\r\n}\r\nstatic void frontend_init(struct ttusb* ttusb)\r\n{\r\nswitch(le16_to_cpu(ttusb->dev->descriptor.idProduct)) {\r\ncase 0x1003:\r\nttusb->fe = dvb_attach(stv0299_attach, &alps_stv0299_config, &ttusb->i2c_adap);\r\nif (ttusb->fe != NULL) {\r\nttusb->fe->ops.tuner_ops.set_params = philips_tsa5059_tuner_set_params;\r\nif(ttusb->revision == TTUSB_REV_2_2) {\r\nalps_stv0299_config.inittab = alps_bsbe1_inittab;\r\ndvb_attach(lnbp21_attach, ttusb->fe, &ttusb->i2c_adap, 0, 0);\r\n} else {\r\nttusb->fe->ops.set_voltage = ttusb_set_voltage;\r\n}\r\nbreak;\r\n}\r\nttusb->fe = dvb_attach(tda8083_attach, &ttusb_novas_grundig_29504_491_config, &ttusb->i2c_adap);\r\nif (ttusb->fe != NULL) {\r\nttusb->fe->ops.tuner_ops.set_params = ttusb_novas_grundig_29504_491_tuner_set_params;\r\nttusb->fe->ops.set_voltage = ttusb_set_voltage;\r\nbreak;\r\n}\r\nbreak;\r\ncase 0x1004:\r\nttusb->fe = dvb_attach(ves1820_attach, &alps_tdbe2_config, &ttusb->i2c_adap, read_pwm(ttusb));\r\nif (ttusb->fe != NULL) {\r\nttusb->fe->ops.tuner_ops.set_params = alps_tdbe2_tuner_set_params;\r\nbreak;\r\n}\r\nttusb->fe = dvb_attach(stv0297_attach, &dvbc_philips_tdm1316l_config, &ttusb->i2c_adap);\r\nif (ttusb->fe != NULL) {\r\nttusb->fe->ops.tuner_ops.set_params = dvbc_philips_tdm1316l_tuner_set_params;\r\nbreak;\r\n}\r\nbreak;\r\ncase 0x1005:\r\nttusb->fe = dvb_attach(cx22700_attach, &alps_tdmb7_config, &ttusb->i2c_adap);\r\nif (ttusb->fe != NULL) {\r\nttusb->fe->ops.tuner_ops.set_params = alps_tdmb7_tuner_set_params;\r\nbreak;\r\n}\r\nttusb->fe = dvb_attach(tda10046_attach, &philips_tdm1316l_config, &ttusb->i2c_adap);\r\nif (ttusb->fe != NULL) {\r\nttusb->fe->ops.tuner_ops.init = philips_tdm1316l_tuner_init;\r\nttusb->fe->ops.tuner_ops.set_params = philips_tdm1316l_tuner_set_params;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nif (ttusb->fe == NULL) {\r\nprintk("dvb-ttusb-budget: A frontend driver was not found for device [%04x:%04x]\n",\r\nle16_to_cpu(ttusb->dev->descriptor.idVendor),\r\nle16_to_cpu(ttusb->dev->descriptor.idProduct));\r\n} else {\r\nif (dvb_register_frontend(&ttusb->adapter, ttusb->fe)) {\r\nprintk("dvb-ttusb-budget: Frontend registration failed!\n");\r\ndvb_frontend_detach(ttusb->fe);\r\nttusb->fe = NULL;\r\n}\r\n}\r\n}\r\nstatic int ttusb_probe(struct usb_interface *intf, const struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev;\r\nstruct ttusb *ttusb;\r\nint result;\r\ndprintk("%s: TTUSB DVB connected\n", __func__);\r\nudev = interface_to_usbdev(intf);\r\nif (intf->altsetting->desc.bInterfaceNumber != 1) return -ENODEV;\r\nif (!(ttusb = kzalloc(sizeof(struct ttusb), GFP_KERNEL)))\r\nreturn -ENOMEM;\r\nttusb->dev = udev;\r\nttusb->c = 0;\r\nttusb->mux_state = 0;\r\nmutex_init(&ttusb->semi2c);\r\nmutex_lock(&ttusb->semi2c);\r\nmutex_init(&ttusb->semusb);\r\nttusb_setup_interfaces(ttusb);\r\nresult = ttusb_alloc_iso_urbs(ttusb);\r\nif (result < 0) {\r\ndprintk("%s: ttusb_alloc_iso_urbs - failed\n", __func__);\r\nmutex_unlock(&ttusb->semi2c);\r\nkfree(ttusb);\r\nreturn result;\r\n}\r\nif (ttusb_init_controller(ttusb))\r\nprintk("ttusb_init_controller: error\n");\r\nmutex_unlock(&ttusb->semi2c);\r\nresult = dvb_register_adapter(&ttusb->adapter,\r\n"Technotrend/Hauppauge Nova-USB",\r\nTHIS_MODULE, &udev->dev, adapter_nr);\r\nif (result < 0) {\r\nttusb_free_iso_urbs(ttusb);\r\nkfree(ttusb);\r\nreturn result;\r\n}\r\nttusb->adapter.priv = ttusb;\r\nmemset(&ttusb->i2c_adap, 0, sizeof(struct i2c_adapter));\r\nstrcpy(ttusb->i2c_adap.name, "TTUSB DEC");\r\ni2c_set_adapdata(&ttusb->i2c_adap, ttusb);\r\nttusb->i2c_adap.algo = &ttusb_dec_algo;\r\nttusb->i2c_adap.algo_data = NULL;\r\nttusb->i2c_adap.dev.parent = &udev->dev;\r\nresult = i2c_add_adapter(&ttusb->i2c_adap);\r\nif (result)\r\ngoto err_unregister_adapter;\r\nmemset(&ttusb->dvb_demux, 0, sizeof(ttusb->dvb_demux));\r\nttusb->dvb_demux.dmx.capabilities =\r\nDMX_TS_FILTERING | DMX_SECTION_FILTERING;\r\nttusb->dvb_demux.priv = NULL;\r\n#ifdef TTUSB_HWSECTIONS\r\nttusb->dvb_demux.filternum = TTUSB_MAXFILTER;\r\n#else\r\nttusb->dvb_demux.filternum = 32;\r\n#endif\r\nttusb->dvb_demux.feednum = TTUSB_MAXCHANNEL;\r\nttusb->dvb_demux.start_feed = ttusb_start_feed;\r\nttusb->dvb_demux.stop_feed = ttusb_stop_feed;\r\nttusb->dvb_demux.write_to_decoder = NULL;\r\nresult = dvb_dmx_init(&ttusb->dvb_demux);\r\nif (result < 0) {\r\nprintk("ttusb_dvb: dvb_dmx_init failed (errno = %d)\n", result);\r\nresult = -ENODEV;\r\ngoto err_i2c_del_adapter;\r\n}\r\nttusb->dmxdev.filternum = ttusb->dvb_demux.filternum;\r\nttusb->dmxdev.demux = &ttusb->dvb_demux.dmx;\r\nttusb->dmxdev.capabilities = 0;\r\nresult = dvb_dmxdev_init(&ttusb->dmxdev, &ttusb->adapter);\r\nif (result < 0) {\r\nprintk("ttusb_dvb: dvb_dmxdev_init failed (errno = %d)\n",\r\nresult);\r\nresult = -ENODEV;\r\ngoto err_release_dmx;\r\n}\r\nif (dvb_net_init(&ttusb->adapter, &ttusb->dvbnet, &ttusb->dvb_demux.dmx)) {\r\nprintk("ttusb_dvb: dvb_net_init failed!\n");\r\nresult = -ENODEV;\r\ngoto err_release_dmxdev;\r\n}\r\nusb_set_intfdata(intf, (void *) ttusb);\r\nfrontend_init(ttusb);\r\nreturn 0;\r\nerr_release_dmxdev:\r\ndvb_dmxdev_release(&ttusb->dmxdev);\r\nerr_release_dmx:\r\ndvb_dmx_release(&ttusb->dvb_demux);\r\nerr_i2c_del_adapter:\r\ni2c_del_adapter(&ttusb->i2c_adap);\r\nerr_unregister_adapter:\r\ndvb_unregister_adapter (&ttusb->adapter);\r\nttusb_free_iso_urbs(ttusb);\r\nkfree(ttusb);\r\nreturn result;\r\n}\r\nstatic void ttusb_disconnect(struct usb_interface *intf)\r\n{\r\nstruct ttusb *ttusb = usb_get_intfdata(intf);\r\nusb_set_intfdata(intf, NULL);\r\nttusb->disconnecting = 1;\r\nttusb_stop_iso_xfer(ttusb);\r\nttusb->dvb_demux.dmx.close(&ttusb->dvb_demux.dmx);\r\ndvb_net_release(&ttusb->dvbnet);\r\ndvb_dmxdev_release(&ttusb->dmxdev);\r\ndvb_dmx_release(&ttusb->dvb_demux);\r\nif (ttusb->fe != NULL) {\r\ndvb_unregister_frontend(ttusb->fe);\r\ndvb_frontend_detach(ttusb->fe);\r\n}\r\ni2c_del_adapter(&ttusb->i2c_adap);\r\ndvb_unregister_adapter(&ttusb->adapter);\r\nttusb_free_iso_urbs(ttusb);\r\nkfree(ttusb);\r\ndprintk("%s: TTUSB DVB disconnected\n", __func__);\r\n}
