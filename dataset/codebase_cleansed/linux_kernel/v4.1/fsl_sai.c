static irqreturn_t fsl_sai_isr(int irq, void *devid)\r\n{\r\nstruct fsl_sai *sai = (struct fsl_sai *)devid;\r\nstruct device *dev = &sai->pdev->dev;\r\nu32 flags, xcsr, mask;\r\nbool irq_none = true;\r\nmask = (FSL_SAI_FLAGS >> FSL_SAI_CSR_xIE_SHIFT) << FSL_SAI_CSR_xF_SHIFT;\r\nregmap_read(sai->regmap, FSL_SAI_TCSR, &xcsr);\r\nflags = xcsr & mask;\r\nif (flags)\r\nirq_none = false;\r\nelse\r\ngoto irq_rx;\r\nif (flags & FSL_SAI_CSR_WSF)\r\ndev_dbg(dev, "isr: Start of Tx word detected\n");\r\nif (flags & FSL_SAI_CSR_SEF)\r\ndev_warn(dev, "isr: Tx Frame sync error detected\n");\r\nif (flags & FSL_SAI_CSR_FEF) {\r\ndev_warn(dev, "isr: Transmit underrun detected\n");\r\nxcsr |= FSL_SAI_CSR_FR;\r\n}\r\nif (flags & FSL_SAI_CSR_FWF)\r\ndev_dbg(dev, "isr: Enabled transmit FIFO is empty\n");\r\nif (flags & FSL_SAI_CSR_FRF)\r\ndev_dbg(dev, "isr: Transmit FIFO watermark has been reached\n");\r\nflags &= FSL_SAI_CSR_xF_W_MASK;\r\nxcsr &= ~FSL_SAI_CSR_xF_MASK;\r\nif (flags)\r\nregmap_write(sai->regmap, FSL_SAI_TCSR, flags | xcsr);\r\nirq_rx:\r\nregmap_read(sai->regmap, FSL_SAI_RCSR, &xcsr);\r\nflags = xcsr & mask;\r\nif (flags)\r\nirq_none = false;\r\nelse\r\ngoto out;\r\nif (flags & FSL_SAI_CSR_WSF)\r\ndev_dbg(dev, "isr: Start of Rx word detected\n");\r\nif (flags & FSL_SAI_CSR_SEF)\r\ndev_warn(dev, "isr: Rx Frame sync error detected\n");\r\nif (flags & FSL_SAI_CSR_FEF) {\r\ndev_warn(dev, "isr: Receive overflow detected\n");\r\nxcsr |= FSL_SAI_CSR_FR;\r\n}\r\nif (flags & FSL_SAI_CSR_FWF)\r\ndev_dbg(dev, "isr: Enabled receive FIFO is full\n");\r\nif (flags & FSL_SAI_CSR_FRF)\r\ndev_dbg(dev, "isr: Receive FIFO watermark has been reached\n");\r\nflags &= FSL_SAI_CSR_xF_W_MASK;\r\nxcsr &= ~FSL_SAI_CSR_xF_MASK;\r\nif (flags)\r\nregmap_write(sai->regmap, FSL_SAI_RCSR, flags | xcsr);\r\nout:\r\nif (irq_none)\r\nreturn IRQ_NONE;\r\nelse\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int fsl_sai_set_dai_sysclk_tr(struct snd_soc_dai *cpu_dai,\r\nint clk_id, unsigned int freq, int fsl_dir)\r\n{\r\nstruct fsl_sai *sai = snd_soc_dai_get_drvdata(cpu_dai);\r\nbool tx = fsl_dir == FSL_FMT_TRANSMITTER;\r\nu32 val_cr2 = 0;\r\nswitch (clk_id) {\r\ncase FSL_SAI_CLK_BUS:\r\nval_cr2 |= FSL_SAI_CR2_MSEL_BUS;\r\nbreak;\r\ncase FSL_SAI_CLK_MAST1:\r\nval_cr2 |= FSL_SAI_CR2_MSEL_MCLK1;\r\nbreak;\r\ncase FSL_SAI_CLK_MAST2:\r\nval_cr2 |= FSL_SAI_CR2_MSEL_MCLK2;\r\nbreak;\r\ncase FSL_SAI_CLK_MAST3:\r\nval_cr2 |= FSL_SAI_CR2_MSEL_MCLK3;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nregmap_update_bits(sai->regmap, FSL_SAI_xCR2(tx),\r\nFSL_SAI_CR2_MSEL_MASK, val_cr2);\r\nreturn 0;\r\n}\r\nstatic int fsl_sai_set_dai_sysclk(struct snd_soc_dai *cpu_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nint ret;\r\nif (dir == SND_SOC_CLOCK_IN)\r\nreturn 0;\r\nret = fsl_sai_set_dai_sysclk_tr(cpu_dai, clk_id, freq,\r\nFSL_FMT_TRANSMITTER);\r\nif (ret) {\r\ndev_err(cpu_dai->dev, "Cannot set tx sysclk: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = fsl_sai_set_dai_sysclk_tr(cpu_dai, clk_id, freq,\r\nFSL_FMT_RECEIVER);\r\nif (ret)\r\ndev_err(cpu_dai->dev, "Cannot set rx sysclk: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int fsl_sai_set_dai_fmt_tr(struct snd_soc_dai *cpu_dai,\r\nunsigned int fmt, int fsl_dir)\r\n{\r\nstruct fsl_sai *sai = snd_soc_dai_get_drvdata(cpu_dai);\r\nbool tx = fsl_dir == FSL_FMT_TRANSMITTER;\r\nu32 val_cr2 = 0, val_cr4 = 0;\r\nif (!sai->is_lsb_first)\r\nval_cr4 |= FSL_SAI_CR4_MF;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nval_cr2 |= FSL_SAI_CR2_BCP;\r\nval_cr4 |= FSL_SAI_CR4_FSE | FSL_SAI_CR4_FSP;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nval_cr2 |= FSL_SAI_CR2_BCP;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\nval_cr2 |= FSL_SAI_CR2_BCP;\r\nval_cr4 |= FSL_SAI_CR4_FSE;\r\nsai->is_dsp_mode = true;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nval_cr2 |= FSL_SAI_CR2_BCP;\r\nsai->is_dsp_mode = true;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nval_cr2 ^= FSL_SAI_CR2_BCP;\r\nval_cr4 ^= FSL_SAI_CR4_FSP;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nval_cr2 ^= FSL_SAI_CR2_BCP;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nval_cr4 ^= FSL_SAI_CR4_FSP;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nval_cr2 |= FSL_SAI_CR2_BCD_MSTR;\r\nval_cr4 |= FSL_SAI_CR4_FSD_MSTR;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFM:\r\nval_cr2 |= FSL_SAI_CR2_BCD_MSTR;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFS:\r\nval_cr4 |= FSL_SAI_CR4_FSD_MSTR;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nregmap_update_bits(sai->regmap, FSL_SAI_xCR2(tx),\r\nFSL_SAI_CR2_BCP | FSL_SAI_CR2_BCD_MSTR, val_cr2);\r\nregmap_update_bits(sai->regmap, FSL_SAI_xCR4(tx),\r\nFSL_SAI_CR4_MF | FSL_SAI_CR4_FSE |\r\nFSL_SAI_CR4_FSP | FSL_SAI_CR4_FSD_MSTR, val_cr4);\r\nreturn 0;\r\n}\r\nstatic int fsl_sai_set_dai_fmt(struct snd_soc_dai *cpu_dai, unsigned int fmt)\r\n{\r\nint ret;\r\nret = fsl_sai_set_dai_fmt_tr(cpu_dai, fmt, FSL_FMT_TRANSMITTER);\r\nif (ret) {\r\ndev_err(cpu_dai->dev, "Cannot set tx format: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = fsl_sai_set_dai_fmt_tr(cpu_dai, fmt, FSL_FMT_RECEIVER);\r\nif (ret)\r\ndev_err(cpu_dai->dev, "Cannot set rx format: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int fsl_sai_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *cpu_dai)\r\n{\r\nstruct fsl_sai *sai = snd_soc_dai_get_drvdata(cpu_dai);\r\nbool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\r\nunsigned int channels = params_channels(params);\r\nu32 word_width = snd_pcm_format_width(params_format(params));\r\nu32 val_cr4 = 0, val_cr5 = 0;\r\nif (!sai->is_dsp_mode)\r\nval_cr4 |= FSL_SAI_CR4_SYWD(word_width);\r\nval_cr5 |= FSL_SAI_CR5_WNW(word_width);\r\nval_cr5 |= FSL_SAI_CR5_W0W(word_width);\r\nif (sai->is_lsb_first)\r\nval_cr5 |= FSL_SAI_CR5_FBT(0);\r\nelse\r\nval_cr5 |= FSL_SAI_CR5_FBT(word_width - 1);\r\nval_cr4 |= FSL_SAI_CR4_FRSZ(channels);\r\nregmap_update_bits(sai->regmap, FSL_SAI_xCR4(tx),\r\nFSL_SAI_CR4_SYWD_MASK | FSL_SAI_CR4_FRSZ_MASK,\r\nval_cr4);\r\nregmap_update_bits(sai->regmap, FSL_SAI_xCR5(tx),\r\nFSL_SAI_CR5_WNW_MASK | FSL_SAI_CR5_W0W_MASK |\r\nFSL_SAI_CR5_FBT_MASK, val_cr5);\r\nregmap_write(sai->regmap, FSL_SAI_xMR(tx), ~0UL - ((1 << channels) - 1));\r\nreturn 0;\r\n}\r\nstatic int fsl_sai_trigger(struct snd_pcm_substream *substream, int cmd,\r\nstruct snd_soc_dai *cpu_dai)\r\n{\r\nstruct fsl_sai *sai = snd_soc_dai_get_drvdata(cpu_dai);\r\nbool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\r\nu32 xcsr, count = 100;\r\nregmap_update_bits(sai->regmap, FSL_SAI_TCR2, FSL_SAI_CR2_SYNC, 0);\r\nregmap_update_bits(sai->regmap, FSL_SAI_RCR2, FSL_SAI_CR2_SYNC,\r\nsai->synchronous[RX] ? FSL_SAI_CR2_SYNC : 0);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nregmap_update_bits(sai->regmap, FSL_SAI_xCSR(tx),\r\nFSL_SAI_CSR_FRDE, FSL_SAI_CSR_FRDE);\r\nregmap_update_bits(sai->regmap, FSL_SAI_RCSR,\r\nFSL_SAI_CSR_TERE, FSL_SAI_CSR_TERE);\r\nregmap_update_bits(sai->regmap, FSL_SAI_TCSR,\r\nFSL_SAI_CSR_TERE, FSL_SAI_CSR_TERE);\r\nregmap_update_bits(sai->regmap, FSL_SAI_xCSR(tx),\r\nFSL_SAI_CSR_xIE_MASK, FSL_SAI_FLAGS);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nregmap_update_bits(sai->regmap, FSL_SAI_xCSR(tx),\r\nFSL_SAI_CSR_FRDE, 0);\r\nregmap_update_bits(sai->regmap, FSL_SAI_xCSR(tx),\r\nFSL_SAI_CSR_xIE_MASK, 0);\r\nregmap_read(sai->regmap, FSL_SAI_xCSR(!tx), &xcsr);\r\nif (!(xcsr & FSL_SAI_CSR_FRDE)) {\r\nregmap_update_bits(sai->regmap, FSL_SAI_TCSR,\r\nFSL_SAI_CSR_TERE, 0);\r\nregmap_update_bits(sai->regmap, FSL_SAI_RCSR,\r\nFSL_SAI_CSR_TERE, 0);\r\ndo {\r\nudelay(10);\r\nregmap_read(sai->regmap, FSL_SAI_xCSR(tx), &xcsr);\r\n} while (--count && xcsr & FSL_SAI_CSR_TERE);\r\nregmap_update_bits(sai->regmap, FSL_SAI_TCSR,\r\nFSL_SAI_CSR_FR, FSL_SAI_CSR_FR);\r\nregmap_update_bits(sai->regmap, FSL_SAI_RCSR,\r\nFSL_SAI_CSR_FR, FSL_SAI_CSR_FR);\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fsl_sai_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *cpu_dai)\r\n{\r\nstruct fsl_sai *sai = snd_soc_dai_get_drvdata(cpu_dai);\r\nbool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\r\nstruct device *dev = &sai->pdev->dev;\r\nint ret;\r\nret = clk_prepare_enable(sai->bus_clk);\r\nif (ret) {\r\ndev_err(dev, "failed to enable bus clock: %d\n", ret);\r\nreturn ret;\r\n}\r\nregmap_update_bits(sai->regmap, FSL_SAI_xCR3(tx), FSL_SAI_CR3_TRCE,\r\nFSL_SAI_CR3_TRCE);\r\nreturn 0;\r\n}\r\nstatic void fsl_sai_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *cpu_dai)\r\n{\r\nstruct fsl_sai *sai = snd_soc_dai_get_drvdata(cpu_dai);\r\nbool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\r\nregmap_update_bits(sai->regmap, FSL_SAI_xCR3(tx), FSL_SAI_CR3_TRCE, 0);\r\nclk_disable_unprepare(sai->bus_clk);\r\n}\r\nstatic int fsl_sai_dai_probe(struct snd_soc_dai *cpu_dai)\r\n{\r\nstruct fsl_sai *sai = dev_get_drvdata(cpu_dai->dev);\r\nregmap_write(sai->regmap, FSL_SAI_TCSR, FSL_SAI_CSR_SR);\r\nregmap_write(sai->regmap, FSL_SAI_RCSR, FSL_SAI_CSR_SR);\r\nregmap_write(sai->regmap, FSL_SAI_TCSR, 0);\r\nregmap_write(sai->regmap, FSL_SAI_RCSR, 0);\r\nregmap_update_bits(sai->regmap, FSL_SAI_TCR1, FSL_SAI_CR1_RFW_MASK,\r\nFSL_SAI_MAXBURST_TX * 2);\r\nregmap_update_bits(sai->regmap, FSL_SAI_RCR1, FSL_SAI_CR1_RFW_MASK,\r\nFSL_SAI_MAXBURST_RX - 1);\r\nsnd_soc_dai_init_dma_data(cpu_dai, &sai->dma_params_tx,\r\n&sai->dma_params_rx);\r\nsnd_soc_dai_set_drvdata(cpu_dai, sai);\r\nreturn 0;\r\n}\r\nstatic bool fsl_sai_readable_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase FSL_SAI_TCSR:\r\ncase FSL_SAI_TCR1:\r\ncase FSL_SAI_TCR2:\r\ncase FSL_SAI_TCR3:\r\ncase FSL_SAI_TCR4:\r\ncase FSL_SAI_TCR5:\r\ncase FSL_SAI_TFR:\r\ncase FSL_SAI_TMR:\r\ncase FSL_SAI_RCSR:\r\ncase FSL_SAI_RCR1:\r\ncase FSL_SAI_RCR2:\r\ncase FSL_SAI_RCR3:\r\ncase FSL_SAI_RCR4:\r\ncase FSL_SAI_RCR5:\r\ncase FSL_SAI_RDR:\r\ncase FSL_SAI_RFR:\r\ncase FSL_SAI_RMR:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool fsl_sai_volatile_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase FSL_SAI_TFR:\r\ncase FSL_SAI_RFR:\r\ncase FSL_SAI_TDR:\r\ncase FSL_SAI_RDR:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool fsl_sai_writeable_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase FSL_SAI_TCSR:\r\ncase FSL_SAI_TCR1:\r\ncase FSL_SAI_TCR2:\r\ncase FSL_SAI_TCR3:\r\ncase FSL_SAI_TCR4:\r\ncase FSL_SAI_TCR5:\r\ncase FSL_SAI_TDR:\r\ncase FSL_SAI_TMR:\r\ncase FSL_SAI_RCSR:\r\ncase FSL_SAI_RCR1:\r\ncase FSL_SAI_RCR2:\r\ncase FSL_SAI_RCR3:\r\ncase FSL_SAI_RCR4:\r\ncase FSL_SAI_RCR5:\r\ncase FSL_SAI_RMR:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int fsl_sai_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct fsl_sai *sai;\r\nstruct resource *res;\r\nvoid __iomem *base;\r\nchar tmp[8];\r\nint irq, ret, i;\r\nsai = devm_kzalloc(&pdev->dev, sizeof(*sai), GFP_KERNEL);\r\nif (!sai)\r\nreturn -ENOMEM;\r\nsai->pdev = pdev;\r\nif (of_device_is_compatible(pdev->dev.of_node, "fsl,imx6sx-sai"))\r\nsai->sai_on_imx = true;\r\nsai->is_lsb_first = of_property_read_bool(np, "lsb-first");\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\nsai->regmap = devm_regmap_init_mmio_clk(&pdev->dev,\r\n"bus", base, &fsl_sai_regmap_config);\r\nif (IS_ERR(sai->regmap))\r\nsai->regmap = devm_regmap_init_mmio_clk(&pdev->dev,\r\n"sai", base, &fsl_sai_regmap_config);\r\nif (IS_ERR(sai->regmap)) {\r\ndev_err(&pdev->dev, "regmap init failed\n");\r\nreturn PTR_ERR(sai->regmap);\r\n}\r\nsai->bus_clk = devm_clk_get(&pdev->dev, "bus");\r\nif (IS_ERR(sai->bus_clk)) {\r\ndev_err(&pdev->dev, "failed to get bus clock: %ld\n",\r\nPTR_ERR(sai->bus_clk));\r\nsai->bus_clk = NULL;\r\n}\r\nfor (i = 0; i < FSL_SAI_MCLK_MAX; i++) {\r\nsprintf(tmp, "mclk%d", i + 1);\r\nsai->mclk_clk[i] = devm_clk_get(&pdev->dev, tmp);\r\nif (IS_ERR(sai->mclk_clk[i])) {\r\ndev_err(&pdev->dev, "failed to get mclk%d clock: %ld\n",\r\ni + 1, PTR_ERR(sai->mclk_clk[i]));\r\nsai->mclk_clk[i] = NULL;\r\n}\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "no irq for node %s\n", pdev->name);\r\nreturn irq;\r\n}\r\nret = devm_request_irq(&pdev->dev, irq, fsl_sai_isr, 0, np->name, sai);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to claim irq %u\n", irq);\r\nreturn ret;\r\n}\r\nsai->synchronous[RX] = true;\r\nsai->synchronous[TX] = false;\r\nfsl_sai_dai.symmetric_rates = 1;\r\nfsl_sai_dai.symmetric_channels = 1;\r\nfsl_sai_dai.symmetric_samplebits = 1;\r\nif (of_find_property(np, "fsl,sai-synchronous-rx", NULL) &&\r\nof_find_property(np, "fsl,sai-asynchronous", NULL)) {\r\ndev_err(&pdev->dev, "invalid binding for synchronous mode\n");\r\nreturn -EINVAL;\r\n}\r\nif (of_find_property(np, "fsl,sai-synchronous-rx", NULL)) {\r\nsai->synchronous[RX] = false;\r\nsai->synchronous[TX] = true;\r\n} else if (of_find_property(np, "fsl,sai-asynchronous", NULL)) {\r\nsai->synchronous[RX] = false;\r\nsai->synchronous[TX] = false;\r\nfsl_sai_dai.symmetric_rates = 0;\r\nfsl_sai_dai.symmetric_channels = 0;\r\nfsl_sai_dai.symmetric_samplebits = 0;\r\n}\r\nsai->dma_params_rx.addr = res->start + FSL_SAI_RDR;\r\nsai->dma_params_tx.addr = res->start + FSL_SAI_TDR;\r\nsai->dma_params_rx.maxburst = FSL_SAI_MAXBURST_RX;\r\nsai->dma_params_tx.maxburst = FSL_SAI_MAXBURST_TX;\r\nplatform_set_drvdata(pdev, sai);\r\nret = devm_snd_soc_register_component(&pdev->dev, &fsl_component,\r\n&fsl_sai_dai, 1);\r\nif (ret)\r\nreturn ret;\r\nif (sai->sai_on_imx)\r\nreturn imx_pcm_dma_init(pdev);\r\nelse\r\nreturn devm_snd_dmaengine_pcm_register(&pdev->dev, NULL,\r\nSND_DMAENGINE_PCM_FLAG_NO_RESIDUE);\r\n}
