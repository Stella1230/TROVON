static int read_vendor_id(struct mlx4_dev *dev)\r\n{\r\nu16 vendor_id = 0;\r\nint ret;\r\nret = pci_read_config_word(dev->persist->pdev, 0, &vendor_id);\r\nif (ret) {\r\nmlx4_err(dev, "Failed to read vendor ID, ret=%d\n", ret);\r\nreturn ret;\r\n}\r\nif (vendor_id == 0xffff) {\r\nmlx4_err(dev, "PCI can't be accessed to read vendor id\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mlx4_reset_master(struct mlx4_dev *dev)\r\n{\r\nint err = 0;\r\nif (mlx4_is_master(dev))\r\nmlx4_report_internal_err_comm_event(dev);\r\nif (!pci_channel_offline(dev->persist->pdev)) {\r\nerr = read_vendor_id(dev);\r\nif (err)\r\nreturn 0;\r\nerr = mlx4_reset(dev);\r\nif (err)\r\nmlx4_err(dev, "Fail to reset HCA\n");\r\n}\r\nreturn err;\r\n}\r\nstatic int mlx4_reset_slave(struct mlx4_dev *dev)\r\n{\r\n#define COM_CHAN_RST_REQ_OFFSET 0x10\r\n#define COM_CHAN_RST_ACK_OFFSET 0x08\r\nu32 comm_flags;\r\nu32 rst_req;\r\nu32 rst_ack;\r\nunsigned long end;\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nif (pci_channel_offline(dev->persist->pdev))\r\nreturn 0;\r\ncomm_flags = swab32(readl((__iomem char *)priv->mfunc.comm +\r\nMLX4_COMM_CHAN_FLAGS));\r\nif (comm_flags == 0xffffffff) {\r\nmlx4_err(dev, "VF reset is not needed\n");\r\nreturn 0;\r\n}\r\nif (!(dev->caps.vf_caps & MLX4_VF_CAP_FLAG_RESET)) {\r\nmlx4_err(dev, "VF reset is not supported\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nrst_req = (comm_flags & (u32)(1 << COM_CHAN_RST_REQ_OFFSET)) >>\r\nCOM_CHAN_RST_REQ_OFFSET;\r\nrst_ack = (comm_flags & (u32)(1 << COM_CHAN_RST_ACK_OFFSET)) >>\r\nCOM_CHAN_RST_ACK_OFFSET;\r\nif (rst_req != rst_ack) {\r\nmlx4_err(dev, "Communication channel isn't sync, fail to send reset\n");\r\nreturn -EIO;\r\n}\r\nrst_req ^= 1;\r\nmlx4_warn(dev, "VF is sending reset request to Firmware\n");\r\ncomm_flags = rst_req << COM_CHAN_RST_REQ_OFFSET;\r\n__raw_writel((__force u32)cpu_to_be32(comm_flags),\r\n(__iomem char *)priv->mfunc.comm + MLX4_COMM_CHAN_FLAGS);\r\nmmiowb();\r\nend = msecs_to_jiffies(MLX4_COMM_TIME) + jiffies;\r\nwhile (time_before(jiffies, end)) {\r\ncomm_flags = swab32(readl((__iomem char *)priv->mfunc.comm +\r\nMLX4_COMM_CHAN_FLAGS));\r\nrst_ack = (comm_flags & (u32)(1 << COM_CHAN_RST_ACK_OFFSET)) >>\r\nCOM_CHAN_RST_ACK_OFFSET;\r\nrst_req = (comm_flags & (u32)(1 << COM_CHAN_RST_REQ_OFFSET)) >>\r\nCOM_CHAN_RST_REQ_OFFSET;\r\nif (rst_ack == rst_req) {\r\nmlx4_warn(dev, "VF Reset succeed\n");\r\nreturn 0;\r\n}\r\ncond_resched();\r\n}\r\nmlx4_err(dev, "Fail to send reset over the communication channel\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int mlx4_comm_internal_err(u32 slave_read)\r\n{\r\nreturn (u32)COMM_CHAN_EVENT_INTERNAL_ERR ==\r\n(slave_read & (u32)COMM_CHAN_EVENT_INTERNAL_ERR) ? 1 : 0;\r\n}\r\nvoid mlx4_enter_error_state(struct mlx4_dev_persistent *persist)\r\n{\r\nint err;\r\nstruct mlx4_dev *dev;\r\nif (!mlx4_internal_err_reset)\r\nreturn;\r\nmutex_lock(&persist->device_state_mutex);\r\nif (persist->state & MLX4_DEVICE_STATE_INTERNAL_ERROR)\r\ngoto out;\r\ndev = persist->dev;\r\nmlx4_err(dev, "device is going to be reset\n");\r\nif (mlx4_is_slave(dev))\r\nerr = mlx4_reset_slave(dev);\r\nelse\r\nerr = mlx4_reset_master(dev);\r\nBUG_ON(err != 0);\r\ndev->persist->state |= MLX4_DEVICE_STATE_INTERNAL_ERROR;\r\nmlx4_err(dev, "device was reset successfully\n");\r\nmutex_unlock(&persist->device_state_mutex);\r\nmlx4_dispatch_event(dev, MLX4_DEV_EVENT_CATASTROPHIC_ERROR, 0);\r\nmlx4_cmd_wake_completions(dev);\r\nreturn;\r\nout:\r\nmutex_unlock(&persist->device_state_mutex);\r\n}\r\nstatic void mlx4_handle_error_state(struct mlx4_dev_persistent *persist)\r\n{\r\nint err = 0;\r\nmlx4_enter_error_state(persist);\r\nmutex_lock(&persist->interface_state_mutex);\r\nif (persist->interface_state & MLX4_INTERFACE_STATE_UP &&\r\n!(persist->interface_state & MLX4_INTERFACE_STATE_DELETION)) {\r\nerr = mlx4_restart_one(persist->pdev);\r\nmlx4_info(persist->dev, "mlx4_restart_one was ended, ret=%d\n",\r\nerr);\r\n}\r\nmutex_unlock(&persist->interface_state_mutex);\r\n}\r\nstatic void dump_err_buf(struct mlx4_dev *dev)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nint i;\r\nmlx4_err(dev, "Internal error detected:\n");\r\nfor (i = 0; i < priv->fw.catas_size; ++i)\r\nmlx4_err(dev, " buf[%02x]: %08x\n",\r\ni, swab32(readl(priv->catas_err.map + i)));\r\n}\r\nstatic void poll_catas(unsigned long dev_ptr)\r\n{\r\nstruct mlx4_dev *dev = (struct mlx4_dev *) dev_ptr;\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nu32 slave_read;\r\nif (mlx4_is_slave(dev)) {\r\nslave_read = swab32(readl(&priv->mfunc.comm->slave_read));\r\nif (mlx4_comm_internal_err(slave_read)) {\r\nmlx4_warn(dev, "Internal error detected on the communication channel\n");\r\ngoto internal_err;\r\n}\r\n} else if (readl(priv->catas_err.map)) {\r\ndump_err_buf(dev);\r\ngoto internal_err;\r\n}\r\nif (dev->persist->state & MLX4_DEVICE_STATE_INTERNAL_ERROR) {\r\nmlx4_warn(dev, "Internal error mark was detected on device\n");\r\ngoto internal_err;\r\n}\r\nmod_timer(&priv->catas_err.timer,\r\nround_jiffies(jiffies + MLX4_CATAS_POLL_INTERVAL));\r\nreturn;\r\ninternal_err:\r\nif (mlx4_internal_err_reset)\r\nqueue_work(dev->persist->catas_wq, &dev->persist->catas_work);\r\n}\r\nstatic void catas_reset(struct work_struct *work)\r\n{\r\nstruct mlx4_dev_persistent *persist =\r\ncontainer_of(work, struct mlx4_dev_persistent,\r\ncatas_work);\r\nmlx4_handle_error_state(persist);\r\n}\r\nvoid mlx4_start_catas_poll(struct mlx4_dev *dev)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nphys_addr_t addr;\r\nINIT_LIST_HEAD(&priv->catas_err.list);\r\ninit_timer(&priv->catas_err.timer);\r\npriv->catas_err.map = NULL;\r\nif (!mlx4_is_slave(dev)) {\r\naddr = pci_resource_start(dev->persist->pdev,\r\npriv->fw.catas_bar) +\r\npriv->fw.catas_offset;\r\npriv->catas_err.map = ioremap(addr, priv->fw.catas_size * 4);\r\nif (!priv->catas_err.map) {\r\nmlx4_warn(dev, "Failed to map internal error buffer at 0x%llx\n",\r\n(unsigned long long)addr);\r\nreturn;\r\n}\r\n}\r\npriv->catas_err.timer.data = (unsigned long) dev;\r\npriv->catas_err.timer.function = poll_catas;\r\npriv->catas_err.timer.expires =\r\nround_jiffies(jiffies + MLX4_CATAS_POLL_INTERVAL);\r\nadd_timer(&priv->catas_err.timer);\r\n}\r\nvoid mlx4_stop_catas_poll(struct mlx4_dev *dev)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\ndel_timer_sync(&priv->catas_err.timer);\r\nif (priv->catas_err.map) {\r\niounmap(priv->catas_err.map);\r\npriv->catas_err.map = NULL;\r\n}\r\nif (dev->persist->interface_state & MLX4_INTERFACE_STATE_DELETION)\r\nflush_workqueue(dev->persist->catas_wq);\r\n}\r\nint mlx4_catas_init(struct mlx4_dev *dev)\r\n{\r\nINIT_WORK(&dev->persist->catas_work, catas_reset);\r\ndev->persist->catas_wq = create_singlethread_workqueue("mlx4_health");\r\nif (!dev->persist->catas_wq)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid mlx4_catas_end(struct mlx4_dev *dev)\r\n{\r\nif (dev->persist->catas_wq) {\r\ndestroy_workqueue(dev->persist->catas_wq);\r\ndev->persist->catas_wq = NULL;\r\n}\r\n}
