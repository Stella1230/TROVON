static long\r\ndefault_handler (void)\r\n{\r\nreturn -1;\r\n}\r\nconst char *\r\nia64_sal_strerror (long status)\r\n{\r\nconst char *str;\r\nswitch (status) {\r\ncase 0: str = "Call completed without error"; break;\r\ncase 1: str = "Effect a warm boot of the system to complete "\r\n"the update"; break;\r\ncase -1: str = "Not implemented"; break;\r\ncase -2: str = "Invalid argument"; break;\r\ncase -3: str = "Call completed with error"; break;\r\ncase -4: str = "Virtual address not registered"; break;\r\ncase -5: str = "No information available"; break;\r\ncase -6: str = "Insufficient space to add the entry"; break;\r\ncase -7: str = "Invalid entry_addr value"; break;\r\ncase -8: str = "Invalid interrupt vector"; break;\r\ncase -9: str = "Requested memory not available"; break;\r\ncase -10: str = "Unable to write to the NVM device"; break;\r\ncase -11: str = "Invalid partition type specified"; break;\r\ncase -12: str = "Invalid NVM_Object id specified"; break;\r\ncase -13: str = "NVM_Object already has the maximum number "\r\n"of partitions"; break;\r\ncase -14: str = "Insufficient space in partition for the "\r\n"requested write sub-function"; break;\r\ncase -15: str = "Insufficient data buffer space for the "\r\n"requested read record sub-function"; break;\r\ncase -16: str = "Scratch buffer required for the write/delete "\r\n"sub-function"; break;\r\ncase -17: str = "Insufficient space in the NVM_Object for the "\r\n"requested create sub-function"; break;\r\ncase -18: str = "Invalid value specified in the partition_rec "\r\n"argument"; break;\r\ncase -19: str = "Record oriented I/O not supported for this "\r\n"partition"; break;\r\ncase -20: str = "Bad format of record to be written or "\r\n"required keyword variable not "\r\n"specified"; break;\r\ndefault: str = "Unknown SAL status code"; break;\r\n}\r\nreturn str;\r\n}\r\nvoid __init\r\nia64_sal_handler_init (void *entry_point, void *gpval)\r\n{\r\npdesc.addr = entry_point;\r\npdesc.gpval = gpval;\r\nia64_sal = (ia64_sal_handler) &pdesc;\r\n}\r\nstatic void __init\r\ncheck_versions (struct ia64_sal_systab *systab)\r\n{\r\nsal_revision = (systab->sal_rev_major << 8) | systab->sal_rev_minor;\r\nsal_version = (systab->sal_b_rev_major << 8) | systab->sal_b_rev_minor;\r\nif ((sal_revision == SAL_VERSION_CODE(49, 29))\r\n&& (sal_version == SAL_VERSION_CODE(49, 29)))\r\n{\r\nsal_revision = SAL_VERSION_CODE(2, 8);\r\nsal_version = SAL_VERSION_CODE(0, 0);\r\n}\r\nif (ia64_platform_is("sn2") && (sal_revision == SAL_VERSION_CODE(2, 9)))\r\nsal_revision = SAL_VERSION_CODE(3, 2);\r\n}\r\nstatic void __init\r\nsal_desc_entry_point (void *p)\r\n{\r\nstruct ia64_sal_desc_entry_point *ep = p;\r\nia64_pal_handler_init(__va(ep->pal_proc));\r\nia64_sal_handler_init(__va(ep->sal_proc), __va(ep->gp));\r\n}\r\nstatic void __init\r\nset_smp_redirect (int flag)\r\n{\r\n#ifndef CONFIG_HOTPLUG_CPU\r\nif (no_int_routing)\r\nsmp_int_redirect &= ~flag;\r\nelse\r\nsmp_int_redirect |= flag;\r\n#else\r\nno_int_routing=1;\r\nsmp_int_redirect &= ~flag;\r\n#endif\r\n}\r\nstatic void __init\r\nsal_desc_platform_feature (void *p)\r\n{\r\nstruct ia64_sal_desc_platform_feature *pf = p;\r\nsal_platform_features = pf->feature_mask;\r\nprintk(KERN_INFO "SAL Platform features:");\r\nif (!sal_platform_features) {\r\nprintk(" None\n");\r\nreturn;\r\n}\r\nif (sal_platform_features & IA64_SAL_PLATFORM_FEATURE_BUS_LOCK)\r\nprintk(" BusLock");\r\nif (sal_platform_features & IA64_SAL_PLATFORM_FEATURE_IRQ_REDIR_HINT) {\r\nprintk(" IRQ_Redirection");\r\nset_smp_redirect(SMP_IRQ_REDIRECTION);\r\n}\r\nif (sal_platform_features & IA64_SAL_PLATFORM_FEATURE_IPI_REDIR_HINT) {\r\nprintk(" IPI_Redirection");\r\nset_smp_redirect(SMP_IPI_REDIRECTION);\r\n}\r\nif (sal_platform_features & IA64_SAL_PLATFORM_FEATURE_ITC_DRIFT)\r\nprintk(" ITC_Drift");\r\nprintk("\n");\r\n}\r\nstatic void __init\r\nsal_desc_ap_wakeup (void *p)\r\n{\r\nstruct ia64_sal_desc_ap_wakeup *ap = p;\r\nswitch (ap->mechanism) {\r\ncase IA64_SAL_AP_EXTERNAL_INT:\r\nap_wakeup_vector = ap->vector;\r\nprintk(KERN_INFO "SAL: AP wakeup using external interrupt "\r\n"vector 0x%lx\n", ap_wakeup_vector);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "SAL: AP wakeup mechanism unsupported!\n");\r\nbreak;\r\n}\r\n}\r\nstatic void __init\r\nchk_nointroute_opt(void)\r\n{\r\nchar *cp;\r\nfor (cp = boot_command_line; *cp; ) {\r\nif (memcmp(cp, "nointroute", 10) == 0) {\r\nno_int_routing = 1;\r\nprintk ("no_int_routing on\n");\r\nbreak;\r\n} else {\r\nwhile (*cp != ' ' && *cp)\r\n++cp;\r\nwhile (*cp == ' ')\r\n++cp;\r\n}\r\n}\r\n}\r\nstatic void __init sal_desc_ap_wakeup(void *p) { }\r\nstatic int __init\r\nforce_pal_cache_flush(char *str)\r\n{\r\nsal_cache_flush_drops_interrupts = 1;\r\nreturn 0;\r\n}\r\nvoid __init\r\ncheck_sal_cache_flush (void)\r\n{\r\nunsigned long flags;\r\nint cpu;\r\nu64 vector, cache_type = 3;\r\nstruct ia64_sal_retval isrv;\r\nif (sal_cache_flush_drops_interrupts)\r\nreturn;\r\ncpu = get_cpu();\r\nlocal_irq_save(flags);\r\nplatform_send_ipi(cpu, IA64_TIMER_VECTOR, IA64_IPI_DM_INT, 0);\r\nwhile (!ia64_get_irr(IA64_TIMER_VECTOR))\r\ncpu_relax();\r\nSAL_CALL(isrv, SAL_CACHE_FLUSH, cache_type, 0, 0, 0, 0, 0, 0);\r\nif (isrv.status)\r\nprintk(KERN_ERR "SAL_CAL_FLUSH failed with %ld\n", isrv.status);\r\nif (ia64_get_irr(IA64_TIMER_VECTOR)) {\r\nvector = ia64_get_ivr();\r\nia64_eoi();\r\nWARN_ON(vector != IA64_TIMER_VECTOR);\r\n} else {\r\nsal_cache_flush_drops_interrupts = 1;\r\nprintk(KERN_ERR "SAL: SAL_CACHE_FLUSH drops interrupts; "\r\n"PAL_CACHE_FLUSH will be used instead\n");\r\nia64_eoi();\r\n}\r\nlocal_irq_restore(flags);\r\nput_cpu();\r\n}\r\ns64\r\nia64_sal_cache_flush (u64 cache_type)\r\n{\r\nstruct ia64_sal_retval isrv;\r\nif (sal_cache_flush_drops_interrupts) {\r\nunsigned long flags;\r\nu64 progress;\r\ns64 rc;\r\nprogress = 0;\r\nlocal_irq_save(flags);\r\nrc = ia64_pal_cache_flush(cache_type,\r\nPAL_CACHE_FLUSH_INVALIDATE, &progress, NULL);\r\nlocal_irq_restore(flags);\r\nreturn rc;\r\n}\r\nSAL_CALL(isrv, SAL_CACHE_FLUSH, cache_type, 0, 0, 0, 0, 0, 0);\r\nreturn isrv.status;\r\n}\r\nvoid __init\r\nia64_sal_init (struct ia64_sal_systab *systab)\r\n{\r\nchar *p;\r\nint i;\r\nif (!systab) {\r\nprintk(KERN_WARNING "Hmm, no SAL System Table.\n");\r\nreturn;\r\n}\r\nif (strncmp(systab->signature, "SST_", 4) != 0)\r\nprintk(KERN_ERR "bad signature in system table!");\r\ncheck_versions(systab);\r\n#ifdef CONFIG_SMP\r\nchk_nointroute_opt();\r\n#endif\r\nprintk(KERN_INFO "SAL %x.%x: %.32s %.32s%sversion %x.%x\n",\r\nSAL_MAJOR(sal_revision), SAL_MINOR(sal_revision),\r\nsystab->oem_id, systab->product_id,\r\nsystab->product_id[0] ? " " : "",\r\nSAL_MAJOR(sal_version), SAL_MINOR(sal_version));\r\np = (char *) (systab + 1);\r\nfor (i = 0; i < systab->entry_count; i++) {\r\nswitch (*p) {\r\ncase SAL_DESC_ENTRY_POINT:\r\nsal_desc_entry_point(p);\r\nbreak;\r\ncase SAL_DESC_PLATFORM_FEATURE:\r\nsal_desc_platform_feature(p);\r\nbreak;\r\ncase SAL_DESC_PTC:\r\nia64_ptc_domain_info = (ia64_sal_desc_ptc_t *)p;\r\nbreak;\r\ncase SAL_DESC_AP_WAKEUP:\r\nsal_desc_ap_wakeup(p);\r\nbreak;\r\n}\r\np += SAL_DESC_SIZE(*p);\r\n}\r\n}\r\nint\r\nia64_sal_oemcall(struct ia64_sal_retval *isrvp, u64 oemfunc, u64 arg1,\r\nu64 arg2, u64 arg3, u64 arg4, u64 arg5, u64 arg6, u64 arg7)\r\n{\r\nif (oemfunc < IA64_SAL_OEMFUNC_MIN || oemfunc > IA64_SAL_OEMFUNC_MAX)\r\nreturn -1;\r\nSAL_CALL(*isrvp, oemfunc, arg1, arg2, arg3, arg4, arg5, arg6, arg7);\r\nreturn 0;\r\n}\r\nint\r\nia64_sal_oemcall_nolock(struct ia64_sal_retval *isrvp, u64 oemfunc, u64 arg1,\r\nu64 arg2, u64 arg3, u64 arg4, u64 arg5, u64 arg6,\r\nu64 arg7)\r\n{\r\nif (oemfunc < IA64_SAL_OEMFUNC_MIN || oemfunc > IA64_SAL_OEMFUNC_MAX)\r\nreturn -1;\r\nSAL_CALL_NOLOCK(*isrvp, oemfunc, arg1, arg2, arg3, arg4, arg5, arg6,\r\narg7);\r\nreturn 0;\r\n}\r\nint\r\nia64_sal_oemcall_reentrant(struct ia64_sal_retval *isrvp, u64 oemfunc,\r\nu64 arg1, u64 arg2, u64 arg3, u64 arg4, u64 arg5,\r\nu64 arg6, u64 arg7)\r\n{\r\nif (oemfunc < IA64_SAL_OEMFUNC_MIN || oemfunc > IA64_SAL_OEMFUNC_MAX)\r\nreturn -1;\r\nSAL_CALL_REENTRANT(*isrvp, oemfunc, arg1, arg2, arg3, arg4, arg5, arg6,\r\narg7);\r\nreturn 0;\r\n}\r\nlong\r\nia64_sal_freq_base (unsigned long which, unsigned long *ticks_per_second,\r\nunsigned long *drift_info)\r\n{\r\nstruct ia64_sal_retval isrv;\r\nSAL_CALL(isrv, SAL_FREQ_BASE, which, 0, 0, 0, 0, 0, 0);\r\n*ticks_per_second = isrv.v0;\r\n*drift_info = isrv.v1;\r\nreturn isrv.status;\r\n}
