void switch_cop(struct mm_struct *next)\r\n{\r\n#ifdef CONFIG_PPC_ICSWX_PID\r\nmtspr(SPRN_PID, next->context.cop_pid);\r\n#endif\r\nmtspr(SPRN_ACOP, next->context.acop);\r\n}\r\nint use_cop(unsigned long acop, struct mm_struct *mm)\r\n{\r\nint ret;\r\nif (!cpu_has_feature(CPU_FTR_ICSWX))\r\nreturn -ENODEV;\r\nif (!mm || !acop)\r\nreturn -EINVAL;\r\nspin_lock(&mm->page_table_lock);\r\nspin_lock(mm->context.cop_lockp);\r\nret = get_cop_pid(mm);\r\nif (ret < 0)\r\ngoto out;\r\nmm->context.acop |= acop;\r\nsync_cop(mm);\r\nif (atomic_read(&mm->mm_users) > 1)\r\nsmp_call_function(sync_cop, mm, 1);\r\nout:\r\nspin_unlock(mm->context.cop_lockp);\r\nspin_unlock(&mm->page_table_lock);\r\nreturn ret;\r\n}\r\nvoid drop_cop(unsigned long acop, struct mm_struct *mm)\r\n{\r\nint free_pid;\r\nif (!cpu_has_feature(CPU_FTR_ICSWX))\r\nreturn;\r\nif (WARN_ON_ONCE(!mm))\r\nreturn;\r\nspin_lock(&mm->page_table_lock);\r\nspin_lock(mm->context.cop_lockp);\r\nmm->context.acop &= ~acop;\r\nfree_pid = disable_cop_pid(mm);\r\nsync_cop(mm);\r\nif (atomic_read(&mm->mm_users) > 1)\r\nsmp_call_function(sync_cop, mm, 1);\r\nif (free_pid != COP_PID_NONE)\r\nfree_cop_pid(free_pid);\r\nspin_unlock(mm->context.cop_lockp);\r\nspin_unlock(&mm->page_table_lock);\r\n}\r\nstatic int acop_use_cop(int ct)\r\n{\r\nreturn -1;\r\n}\r\nstatic u32 acop_get_inst(struct pt_regs *regs)\r\n{\r\nu32 inst;\r\nu32 __user *p;\r\np = (u32 __user *)regs->nip;\r\nif (!access_ok(VERIFY_READ, p, sizeof(*p)))\r\nreturn 0;\r\nif (__get_user(inst, p))\r\nreturn 0;\r\nreturn inst;\r\n}\r\nint acop_handle_fault(struct pt_regs *regs, unsigned long address,\r\nunsigned long error_code)\r\n{\r\nint ct;\r\nu32 inst = 0;\r\nif (!cpu_has_feature(CPU_FTR_ICSWX)) {\r\npr_info("No coprocessors available");\r\n_exception(SIGILL, regs, ILL_ILLOPN, address);\r\n}\r\nif (!user_mode(regs)) {\r\ndie("ICSWX from kernel failed", regs, SIGSEGV);\r\n}\r\nct = ICSWX_GET_CT_HINT(error_code);\r\nif (ct < 0) {\r\nu32 ccw;\r\nu32 rs;\r\ninst = acop_get_inst(regs);\r\nif (inst == 0)\r\nreturn -1;\r\nrs = (inst >> (31 - 10)) & 0x1f;\r\nccw = regs->gpr[rs];\r\nct = (ccw >> 16) & 0x3f;\r\n}\r\nif ((acop_copro_type_bit(ct) & current->active_mm->context.acop) != 0) {\r\nsync_cop(current->active_mm);\r\nreturn 0;\r\n}\r\nif (!acop_use_cop(ct))\r\nreturn 0;\r\npr_warn("%s[%d]: Coprocessor %d is unavailable\n",\r\ncurrent->comm, current->pid, ct);\r\nif (inst == 0) {\r\ninst = acop_get_inst(regs);\r\nif (inst == 0)\r\nreturn -1;\r\n}\r\nif (inst & 1) {\r\nregs->ccr &= ~(0xful << 28);\r\nregs->ccr |= ICSWX_RC_NOT_FOUND << 28;\r\nregs->nip += 4;\r\n} else {\r\n#ifdef CONFIG_PPC_ICSWX_USE_SIGILL\r\n_exception(SIGILL, regs, ILL_ILLOPN, address);\r\n#else\r\nregs->nip += 4;\r\n#endif\r\n}\r\nreturn 0;\r\n}
