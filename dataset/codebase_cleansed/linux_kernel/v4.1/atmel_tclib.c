struct atmel_tc *atmel_tc_alloc(unsigned block)\r\n{\r\nstruct atmel_tc *tc;\r\nstruct platform_device *pdev = NULL;\r\nspin_lock(&tc_list_lock);\r\nlist_for_each_entry(tc, &tc_list, node) {\r\nif (tc->allocated)\r\ncontinue;\r\nif ((tc->pdev->dev.of_node && tc->id == block) ||\r\n(tc->pdev->id == block)) {\r\npdev = tc->pdev;\r\ntc->allocated = true;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&tc_list_lock);\r\nreturn pdev ? tc : NULL;\r\n}\r\nvoid atmel_tc_free(struct atmel_tc *tc)\r\n{\r\nspin_lock(&tc_list_lock);\r\nif (tc->allocated)\r\ntc->allocated = false;\r\nspin_unlock(&tc_list_lock);\r\n}\r\nstatic int __init tc_probe(struct platform_device *pdev)\r\n{\r\nstruct atmel_tc *tc;\r\nstruct clk *clk;\r\nint irq;\r\nstruct resource *r;\r\nunsigned int i;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn -EINVAL;\r\ntc = devm_kzalloc(&pdev->dev, sizeof(struct atmel_tc), GFP_KERNEL);\r\nif (!tc)\r\nreturn -ENOMEM;\r\ntc->pdev = pdev;\r\nclk = devm_clk_get(&pdev->dev, "t0_clk");\r\nif (IS_ERR(clk))\r\nreturn PTR_ERR(clk);\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ntc->regs = devm_ioremap_resource(&pdev->dev, r);\r\nif (IS_ERR(tc->regs))\r\nreturn PTR_ERR(tc->regs);\r\nif (pdev->dev.of_node) {\r\nconst struct of_device_id *match;\r\nmatch = of_match_node(atmel_tcb_dt_ids, pdev->dev.of_node);\r\nif (match)\r\ntc->tcb_config = match->data;\r\ntc->id = of_alias_get_id(tc->pdev->dev.of_node, "tcb");\r\n} else {\r\ntc->id = pdev->id;\r\n}\r\ntc->clk[0] = clk;\r\ntc->clk[1] = devm_clk_get(&pdev->dev, "t1_clk");\r\nif (IS_ERR(tc->clk[1]))\r\ntc->clk[1] = clk;\r\ntc->clk[2] = devm_clk_get(&pdev->dev, "t2_clk");\r\nif (IS_ERR(tc->clk[2]))\r\ntc->clk[2] = clk;\r\ntc->irq[0] = irq;\r\ntc->irq[1] = platform_get_irq(pdev, 1);\r\nif (tc->irq[1] < 0)\r\ntc->irq[1] = irq;\r\ntc->irq[2] = platform_get_irq(pdev, 2);\r\nif (tc->irq[2] < 0)\r\ntc->irq[2] = irq;\r\nfor (i = 0; i < 3; i++)\r\nwritel(ATMEL_TC_ALL_IRQ, tc->regs + ATMEL_TC_REG(i, IDR));\r\nspin_lock(&tc_list_lock);\r\nlist_add_tail(&tc->node, &tc_list);\r\nspin_unlock(&tc_list_lock);\r\nplatform_set_drvdata(pdev, tc);\r\nreturn 0;\r\n}\r\nstatic void tc_shutdown(struct platform_device *pdev)\r\n{\r\nint i;\r\nstruct atmel_tc *tc = platform_get_drvdata(pdev);\r\nfor (i = 0; i < 3; i++)\r\nwritel(ATMEL_TC_ALL_IRQ, tc->regs + ATMEL_TC_REG(i, IDR));\r\n}\r\nstatic int __init tc_init(void)\r\n{\r\nreturn platform_driver_probe(&tc_driver, tc_probe);\r\n}
