static void sun4i_usb_phy_write(struct sun4i_usb_phy *phy, u32 addr, u32 data,\r\nint len)\r\n{\r\nstruct sun4i_usb_phy_data *phy_data = to_sun4i_usb_phy_data(phy);\r\nu32 temp, usbc_bit = BIT(phy->index * 2);\r\nint i;\r\nmutex_lock(&phy_data->mutex);\r\nfor (i = 0; i < len; i++) {\r\ntemp = readl(phy_data->base + REG_PHYCTL);\r\ntemp &= ~(0xff << 8);\r\ntemp |= ((addr + i) << 8);\r\nwritel(temp, phy_data->base + REG_PHYCTL);\r\ntemp = readb(phy_data->base + REG_PHYCTL);\r\nif (data & 0x1)\r\ntemp |= PHYCTL_DATA;\r\nelse\r\ntemp &= ~PHYCTL_DATA;\r\ntemp &= ~usbc_bit;\r\nwriteb(temp, phy_data->base + REG_PHYCTL);\r\ntemp = readb(phy_data->base + REG_PHYCTL);\r\ntemp |= usbc_bit;\r\nwriteb(temp, phy_data->base + REG_PHYCTL);\r\ntemp = readb(phy_data->base + REG_PHYCTL);\r\ntemp &= ~usbc_bit;\r\nwriteb(temp, phy_data->base + REG_PHYCTL);\r\ndata >>= 1;\r\n}\r\nmutex_unlock(&phy_data->mutex);\r\n}\r\nstatic void sun4i_usb_phy_passby(struct sun4i_usb_phy *phy, int enable)\r\n{\r\nu32 bits, reg_value;\r\nif (!phy->pmu)\r\nreturn;\r\nbits = SUNXI_AHB_ICHR8_EN | SUNXI_AHB_INCR4_BURST_EN |\r\nSUNXI_AHB_INCRX_ALIGN_EN | SUNXI_ULPI_BYPASS_EN;\r\nreg_value = readl(phy->pmu);\r\nif (enable)\r\nreg_value |= bits;\r\nelse\r\nreg_value &= ~bits;\r\nwritel(reg_value, phy->pmu);\r\n}\r\nstatic int sun4i_usb_phy_init(struct phy *_phy)\r\n{\r\nstruct sun4i_usb_phy *phy = phy_get_drvdata(_phy);\r\nstruct sun4i_usb_phy_data *data = to_sun4i_usb_phy_data(phy);\r\nint ret;\r\nret = clk_prepare_enable(phy->clk);\r\nif (ret)\r\nreturn ret;\r\nret = reset_control_deassert(phy->reset);\r\nif (ret) {\r\nclk_disable_unprepare(phy->clk);\r\nreturn ret;\r\n}\r\nif (phy->index == 0)\r\nsun4i_usb_phy_write(phy, PHY_RES45_CAL_EN, 0x01, 1);\r\nsun4i_usb_phy_write(phy, PHY_TX_AMPLITUDE_TUNE, 0x14, 5);\r\nsun4i_usb_phy_write(phy, PHY_DISCON_TH_SEL, data->disc_thresh, 2);\r\nsun4i_usb_phy_passby(phy, 1);\r\nreturn 0;\r\n}\r\nstatic int sun4i_usb_phy_exit(struct phy *_phy)\r\n{\r\nstruct sun4i_usb_phy *phy = phy_get_drvdata(_phy);\r\nsun4i_usb_phy_passby(phy, 0);\r\nreset_control_assert(phy->reset);\r\nclk_disable_unprepare(phy->clk);\r\nreturn 0;\r\n}\r\nstatic int sun4i_usb_phy_power_on(struct phy *_phy)\r\n{\r\nstruct sun4i_usb_phy *phy = phy_get_drvdata(_phy);\r\nint ret = 0;\r\nif (phy->vbus)\r\nret = regulator_enable(phy->vbus);\r\nreturn ret;\r\n}\r\nstatic int sun4i_usb_phy_power_off(struct phy *_phy)\r\n{\r\nstruct sun4i_usb_phy *phy = phy_get_drvdata(_phy);\r\nif (phy->vbus)\r\nregulator_disable(phy->vbus);\r\nreturn 0;\r\n}\r\nstatic struct phy *sun4i_usb_phy_xlate(struct device *dev,\r\nstruct of_phandle_args *args)\r\n{\r\nstruct sun4i_usb_phy_data *data = dev_get_drvdata(dev);\r\nif (args->args[0] >= data->num_phys)\r\nreturn ERR_PTR(-ENODEV);\r\nreturn data->phys[args->args[0]].phy;\r\n}\r\nstatic int sun4i_usb_phy_probe(struct platform_device *pdev)\r\n{\r\nstruct sun4i_usb_phy_data *data;\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np = dev->of_node;\r\nstruct phy_provider *phy_provider;\r\nbool dedicated_clocks;\r\nstruct resource *res;\r\nint i;\r\ndata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nmutex_init(&data->mutex);\r\nif (of_device_is_compatible(np, "allwinner,sun5i-a13-usb-phy"))\r\ndata->num_phys = 2;\r\nelse\r\ndata->num_phys = 3;\r\nif (of_device_is_compatible(np, "allwinner,sun4i-a10-usb-phy") ||\r\nof_device_is_compatible(np, "allwinner,sun6i-a31-usb-phy"))\r\ndata->disc_thresh = 3;\r\nelse\r\ndata->disc_thresh = 2;\r\nif (of_device_is_compatible(np, "allwinner,sun6i-a31-usb-phy"))\r\ndedicated_clocks = true;\r\nelse\r\ndedicated_clocks = false;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "phy_ctrl");\r\ndata->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(data->base))\r\nreturn PTR_ERR(data->base);\r\nfor (i = 0; i < data->num_phys; i++) {\r\nstruct sun4i_usb_phy *phy = data->phys + i;\r\nchar name[16];\r\nsnprintf(name, sizeof(name), "usb%d_vbus", i);\r\nphy->vbus = devm_regulator_get_optional(dev, name);\r\nif (IS_ERR(phy->vbus)) {\r\nif (PTR_ERR(phy->vbus) == -EPROBE_DEFER)\r\nreturn -EPROBE_DEFER;\r\nphy->vbus = NULL;\r\n}\r\nif (dedicated_clocks)\r\nsnprintf(name, sizeof(name), "usb%d_phy", i);\r\nelse\r\nstrlcpy(name, "usb_phy", sizeof(name));\r\nphy->clk = devm_clk_get(dev, name);\r\nif (IS_ERR(phy->clk)) {\r\ndev_err(dev, "failed to get clock %s\n", name);\r\nreturn PTR_ERR(phy->clk);\r\n}\r\nsnprintf(name, sizeof(name), "usb%d_reset", i);\r\nphy->reset = devm_reset_control_get(dev, name);\r\nif (IS_ERR(phy->reset)) {\r\ndev_err(dev, "failed to get reset %s\n", name);\r\nreturn PTR_ERR(phy->reset);\r\n}\r\nif (i) {\r\nsnprintf(name, sizeof(name), "pmu%d", i);\r\nres = platform_get_resource_byname(pdev,\r\nIORESOURCE_MEM, name);\r\nphy->pmu = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(phy->pmu))\r\nreturn PTR_ERR(phy->pmu);\r\n}\r\nphy->phy = devm_phy_create(dev, NULL, &sun4i_usb_phy_ops);\r\nif (IS_ERR(phy->phy)) {\r\ndev_err(dev, "failed to create PHY %d\n", i);\r\nreturn PTR_ERR(phy->phy);\r\n}\r\nphy->index = i;\r\nphy_set_drvdata(phy->phy, &data->phys[i]);\r\n}\r\ndev_set_drvdata(dev, data);\r\nphy_provider = devm_of_phy_provider_register(dev, sun4i_usb_phy_xlate);\r\nreturn PTR_ERR_OR_ZERO(phy_provider);\r\n}
