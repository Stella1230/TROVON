static int get_video_mode(char *vname)\r\n{\r\nchar ***name_list;\r\nchar **name;\r\nint i;\r\nname_list = fb_var_names;\r\nfor (i = 0; i < num_atafb_predefined; i++) {\r\nname = *name_list++;\r\nif (!name || !*name)\r\nbreak;\r\nwhile (*name) {\r\nif (!strcmp(vname, *name))\r\nreturn i + 1;\r\nname++;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int tt_encode_fix(struct fb_fix_screeninfo *fix, struct atafb_par *par)\r\n{\r\nint mode;\r\nstrcpy(fix->id, "Atari Builtin");\r\nfix->smem_start = phys_screen_base;\r\nfix->smem_len = screen_len;\r\nfix->type = FB_TYPE_INTERLEAVED_PLANES;\r\nfix->type_aux = 2;\r\nfix->visual = FB_VISUAL_PSEUDOCOLOR;\r\nmode = par->hw.tt.mode & TT_SHIFTER_MODEMASK;\r\nif (mode == TT_SHIFTER_TTHIGH || mode == TT_SHIFTER_STHIGH) {\r\nfix->type = FB_TYPE_PACKED_PIXELS;\r\nfix->type_aux = 0;\r\nif (mode == TT_SHIFTER_TTHIGH)\r\nfix->visual = FB_VISUAL_MONO01;\r\n}\r\nfix->xpanstep = 0;\r\nfix->ypanstep = 1;\r\nfix->ywrapstep = 0;\r\nfix->line_length = par->next_line;\r\nfix->accel = FB_ACCEL_ATARIBLITT;\r\nreturn 0;\r\n}\r\nstatic int tt_decode_var(struct fb_var_screeninfo *var, struct atafb_par *par)\r\n{\r\nint xres = var->xres;\r\nint yres = var->yres;\r\nint bpp = var->bits_per_pixel;\r\nint linelen;\r\nint yres_virtual = var->yres_virtual;\r\nif (mono_moni) {\r\nif (bpp > 1 || xres > sttt_xres * 2 || yres > tt_yres * 2)\r\nreturn -EINVAL;\r\npar->hw.tt.mode = TT_SHIFTER_TTHIGH;\r\nxres = sttt_xres * 2;\r\nyres = tt_yres * 2;\r\nbpp = 1;\r\n} else {\r\nif (bpp > 8 || xres > sttt_xres || yres > tt_yres)\r\nreturn -EINVAL;\r\nif (bpp > 4) {\r\nif (xres > sttt_xres / 2 || yres > tt_yres)\r\nreturn -EINVAL;\r\npar->hw.tt.mode = TT_SHIFTER_TTLOW;\r\nxres = sttt_xres / 2;\r\nyres = tt_yres;\r\nbpp = 8;\r\n} else if (bpp > 2) {\r\nif (xres > sttt_xres || yres > tt_yres)\r\nreturn -EINVAL;\r\nif (xres > sttt_xres / 2 || yres > st_yres / 2) {\r\npar->hw.tt.mode = TT_SHIFTER_TTMID;\r\nxres = sttt_xres;\r\nyres = tt_yres;\r\nbpp = 4;\r\n} else {\r\npar->hw.tt.mode = TT_SHIFTER_STLOW;\r\nxres = sttt_xres / 2;\r\nyres = st_yres / 2;\r\nbpp = 4;\r\n}\r\n} else if (bpp > 1) {\r\nif (xres > sttt_xres || yres > st_yres / 2)\r\nreturn -EINVAL;\r\npar->hw.tt.mode = TT_SHIFTER_STMID;\r\nxres = sttt_xres;\r\nyres = st_yres / 2;\r\nbpp = 2;\r\n} else if (var->xres > sttt_xres || var->yres > st_yres) {\r\nreturn -EINVAL;\r\n} else {\r\npar->hw.tt.mode = TT_SHIFTER_STHIGH;\r\nxres = sttt_xres;\r\nyres = st_yres;\r\nbpp = 1;\r\n}\r\n}\r\nif (yres_virtual <= 0)\r\nyres_virtual = 0;\r\nelse if (yres_virtual < yres)\r\nyres_virtual = yres;\r\nif (var->sync & FB_SYNC_EXT)\r\npar->hw.tt.sync = 0;\r\nelse\r\npar->hw.tt.sync = 1;\r\nlinelen = xres * bpp / 8;\r\nif (yres_virtual * linelen > screen_len && screen_len)\r\nreturn -EINVAL;\r\nif (yres * linelen > screen_len && screen_len)\r\nreturn -EINVAL;\r\nif (var->yoffset + yres > yres_virtual && yres_virtual)\r\nreturn -EINVAL;\r\npar->yres_virtual = yres_virtual;\r\npar->screen_base = screen_base + var->yoffset * linelen;\r\npar->next_line = linelen;\r\nreturn 0;\r\n}\r\nstatic int tt_encode_var(struct fb_var_screeninfo *var, struct atafb_par *par)\r\n{\r\nint linelen;\r\nmemset(var, 0, sizeof(struct fb_var_screeninfo));\r\nvar->red.offset = 0;\r\nvar->red.length = 4;\r\nvar->red.msb_right = 0;\r\nvar->grayscale = 0;\r\nvar->pixclock = 31041;\r\nvar->left_margin = 120;\r\nvar->right_margin = 100;\r\nvar->upper_margin = 8;\r\nvar->lower_margin = 16;\r\nvar->hsync_len = 140;\r\nvar->vsync_len = 30;\r\nvar->height = -1;\r\nvar->width = -1;\r\nif (par->hw.tt.sync & 1)\r\nvar->sync = 0;\r\nelse\r\nvar->sync = FB_SYNC_EXT;\r\nswitch (par->hw.tt.mode & TT_SHIFTER_MODEMASK) {\r\ncase TT_SHIFTER_STLOW:\r\nvar->xres = sttt_xres / 2;\r\nvar->xres_virtual = sttt_xres_virtual / 2;\r\nvar->yres = st_yres / 2;\r\nvar->bits_per_pixel = 4;\r\nbreak;\r\ncase TT_SHIFTER_STMID:\r\nvar->xres = sttt_xres;\r\nvar->xres_virtual = sttt_xres_virtual;\r\nvar->yres = st_yres / 2;\r\nvar->bits_per_pixel = 2;\r\nbreak;\r\ncase TT_SHIFTER_STHIGH:\r\nvar->xres = sttt_xres;\r\nvar->xres_virtual = sttt_xres_virtual;\r\nvar->yres = st_yres;\r\nvar->bits_per_pixel = 1;\r\nbreak;\r\ncase TT_SHIFTER_TTLOW:\r\nvar->xres = sttt_xres / 2;\r\nvar->xres_virtual = sttt_xres_virtual / 2;\r\nvar->yres = tt_yres;\r\nvar->bits_per_pixel = 8;\r\nbreak;\r\ncase TT_SHIFTER_TTMID:\r\nvar->xres = sttt_xres;\r\nvar->xres_virtual = sttt_xres_virtual;\r\nvar->yres = tt_yres;\r\nvar->bits_per_pixel = 4;\r\nbreak;\r\ncase TT_SHIFTER_TTHIGH:\r\nvar->red.length = 0;\r\nvar->xres = sttt_xres * 2;\r\nvar->xres_virtual = sttt_xres_virtual * 2;\r\nvar->yres = tt_yres * 2;\r\nvar->bits_per_pixel = 1;\r\nbreak;\r\n}\r\nvar->blue = var->green = var->red;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nvar->transp.msb_right = 0;\r\nlinelen = var->xres_virtual * var->bits_per_pixel / 8;\r\nif (!use_hwscroll)\r\nvar->yres_virtual = var->yres;\r\nelse if (screen_len) {\r\nif (par->yres_virtual)\r\nvar->yres_virtual = par->yres_virtual;\r\nelse\r\nvar->yres_virtual = screen_len / linelen;\r\n} else {\r\nif (hwscroll < 0)\r\nvar->yres_virtual = 2 * var->yres;\r\nelse\r\nvar->yres_virtual = var->yres + hwscroll * 16;\r\n}\r\nvar->xoffset = 0;\r\nif (screen_base)\r\nvar->yoffset = (par->screen_base - screen_base) / linelen;\r\nelse\r\nvar->yoffset = 0;\r\nvar->nonstd = 0;\r\nvar->activate = 0;\r\nvar->vmode = FB_VMODE_NONINTERLACED;\r\nreturn 0;\r\n}\r\nstatic void tt_get_par(struct atafb_par *par)\r\n{\r\nunsigned long addr;\r\npar->hw.tt.mode = shifter_tt.tt_shiftmode;\r\npar->hw.tt.sync = shifter.syncmode;\r\naddr = ((shifter.bas_hi & 0xff) << 16) |\r\n((shifter.bas_md & 0xff) << 8) |\r\n((shifter.bas_lo & 0xff));\r\npar->screen_base = atari_stram_to_virt(addr);\r\n}\r\nstatic void tt_set_par(struct atafb_par *par)\r\n{\r\nshifter_tt.tt_shiftmode = par->hw.tt.mode;\r\nshifter.syncmode = par->hw.tt.sync;\r\nif (current_par.screen_base != par->screen_base)\r\nfbhw->set_screen_base(par->screen_base);\r\n}\r\nstatic int tt_setcolreg(unsigned int regno, unsigned int red,\r\nunsigned int green, unsigned int blue,\r\nunsigned int transp, struct fb_info *info)\r\n{\r\nif ((shifter_tt.tt_shiftmode & TT_SHIFTER_MODEMASK) == TT_SHIFTER_STHIGH)\r\nregno += 254;\r\nif (regno > 255)\r\nreturn 1;\r\ntt_palette[regno] = (((red >> 12) << 8) | ((green >> 12) << 4) |\r\n(blue >> 12));\r\nif ((shifter_tt.tt_shiftmode & TT_SHIFTER_MODEMASK) ==\r\nTT_SHIFTER_STHIGH && regno == 254)\r\ntt_palette[0] = 0;\r\nreturn 0;\r\n}\r\nstatic int tt_detect(void)\r\n{\r\nstruct atafb_par par;\r\nif (ATARIHW_PRESENT(PCM_8BIT)) {\r\ntt_dmasnd.ctrl = DMASND_CTRL_OFF;\r\nudelay(20);\r\n}\r\nmono_moni = (st_mfp.par_dt_reg & 0x80) == 0;\r\ntt_get_par(&par);\r\ntt_encode_var(&atafb_predefined[0], &par);\r\nreturn 1;\r\n}\r\nstatic inline int hxx_prescale(struct falcon_hw *hw)\r\n{\r\nreturn hw->ste_mode ? 16\r\n: vdl_prescale[mon_type][hw->vid_mode >> 2 & 0x3];\r\n}\r\nstatic int falcon_encode_fix(struct fb_fix_screeninfo *fix,\r\nstruct atafb_par *par)\r\n{\r\nstrcpy(fix->id, "Atari Builtin");\r\nfix->smem_start = phys_screen_base;\r\nfix->smem_len = screen_len;\r\nfix->type = FB_TYPE_INTERLEAVED_PLANES;\r\nfix->type_aux = 2;\r\nfix->visual = FB_VISUAL_PSEUDOCOLOR;\r\nfix->xpanstep = 1;\r\nfix->ypanstep = 1;\r\nfix->ywrapstep = 0;\r\nif (par->hw.falcon.mono) {\r\nfix->type = FB_TYPE_PACKED_PIXELS;\r\nfix->type_aux = 0;\r\nfix->xpanstep = 32;\r\n} else if (par->hw.falcon.f_shift & 0x100) {\r\nfix->type = FB_TYPE_PACKED_PIXELS;\r\nfix->type_aux = 0;\r\nfix->visual = FB_VISUAL_TRUECOLOR;\r\nfix->xpanstep = 2;\r\n}\r\nfix->line_length = par->next_line;\r\nfix->accel = FB_ACCEL_ATARIBLITT;\r\nreturn 0;\r\n}\r\nstatic int falcon_decode_var(struct fb_var_screeninfo *var,\r\nstruct atafb_par *par)\r\n{\r\nint bpp = var->bits_per_pixel;\r\nint xres = var->xres;\r\nint yres = var->yres;\r\nint xres_virtual = var->xres_virtual;\r\nint yres_virtual = var->yres_virtual;\r\nint left_margin, right_margin, hsync_len;\r\nint upper_margin, lower_margin, vsync_len;\r\nint linelen;\r\nint interlace = 0, doubleline = 0;\r\nstruct pixel_clock *pclock;\r\nint plen;\r\nint xstretch;\r\nint prescale;\r\nint longoffset = 0;\r\nint hfreq, vfreq;\r\nint hdb_off, hde_off, base_off;\r\nint gstart, gend1, gend2, align;\r\nif (!xres || !yres || !bpp)\r\nreturn -EINVAL;\r\nif (mon_type == F_MON_SM && bpp != 1)\r\nreturn -EINVAL;\r\nif (bpp <= 1) {\r\nbpp = 1;\r\npar->hw.falcon.f_shift = 0x400;\r\npar->hw.falcon.st_shift = 0x200;\r\n} else if (bpp <= 2) {\r\nbpp = 2;\r\npar->hw.falcon.f_shift = 0x000;\r\npar->hw.falcon.st_shift = 0x100;\r\n} else if (bpp <= 4) {\r\nbpp = 4;\r\npar->hw.falcon.f_shift = 0x000;\r\npar->hw.falcon.st_shift = 0x000;\r\n} else if (bpp <= 8) {\r\nbpp = 8;\r\npar->hw.falcon.f_shift = 0x010;\r\n} else if (bpp <= 16) {\r\nbpp = 16;\r\npar->hw.falcon.f_shift = 0x100;\r\n} else\r\nreturn -EINVAL;\r\npar->hw.falcon.bpp = bpp;\r\nif (mon_type == F_MON_SM || DontCalcRes) {\r\nstruct fb_var_screeninfo *myvar = &atafb_predefined[0];\r\nif (bpp > myvar->bits_per_pixel ||\r\nvar->xres > myvar->xres ||\r\nvar->yres > myvar->yres)\r\nreturn -EINVAL;\r\nfbhw->get_par(par);\r\ngoto set_screen_base;\r\n}\r\nif (xres <= 320)\r\nxres = 320;\r\nelse if (xres <= 640 && bpp != 16)\r\nxres = 640;\r\nif (yres <= 200)\r\nyres = 200;\r\nelse if (yres <= 240)\r\nyres = 240;\r\nelse if (yres <= 400)\r\nyres = 400;\r\npar->hw.falcon.ste_mode = bpp == 2;\r\npar->hw.falcon.mono = bpp == 1;\r\nif (par->hw.falcon.ste_mode)\r\nxres = (xres + 63) & ~63;\r\nelse if (bpp == 1)\r\nxres = (xres + 31) & ~31;\r\nelse\r\nxres = (xres + 15) & ~15;\r\nif (yres >= 400)\r\nyres = (yres + 15) & ~15;\r\nelse\r\nyres = (yres + 7) & ~7;\r\nif (xres_virtual < xres)\r\nxres_virtual = xres;\r\nelse if (bpp == 1)\r\nxres_virtual = (xres_virtual + 31) & ~31;\r\nelse\r\nxres_virtual = (xres_virtual + 15) & ~15;\r\nif (yres_virtual <= 0)\r\nyres_virtual = 0;\r\nelse if (yres_virtual < yres)\r\nyres_virtual = yres;\r\nif (var->pixclock > 1)\r\nvar->pixclock -= 1;\r\npar->hw.falcon.line_width = bpp * xres / 16;\r\npar->hw.falcon.line_offset = bpp * (xres_virtual - xres) / 16;\r\nxstretch = (xres < 640) ? 2 : 1;\r\n#if 0\r\nif (mon_type == F_MON_SM) {\r\nif (xres != 640 && yres != 400)\r\nreturn -EINVAL;\r\nplen = 1;\r\npclock = &f32;\r\npar->hw.falcon.ste_mode = 1;\r\npar->hw.falcon.f_shift = 0x000;\r\npar->hw.falcon.st_shift = 0x200;\r\nleft_margin = hsync_len = 128 / plen;\r\nright_margin = 0;\r\n} else\r\n#endif\r\nif (mon_type == F_MON_SC || mon_type == F_MON_TV) {\r\nplen = 2 * xstretch;\r\nif (var->pixclock > f32.t * plen)\r\nreturn -EINVAL;\r\npclock = &f32;\r\nif (yres > 240)\r\ninterlace = 1;\r\nif (var->pixclock == 0) {\r\nleft_margin = 32;\r\nright_margin = 18;\r\nhsync_len = pclock->hsync / plen;\r\nupper_margin = 31;\r\nlower_margin = 14;\r\nvsync_len = interlace ? 3 : 4;\r\n} else {\r\nleft_margin = var->left_margin;\r\nright_margin = var->right_margin;\r\nhsync_len = var->hsync_len;\r\nupper_margin = var->upper_margin;\r\nlower_margin = var->lower_margin;\r\nvsync_len = var->vsync_len;\r\nif (var->vmode & FB_VMODE_INTERLACED) {\r\nupper_margin = (upper_margin + 1) / 2;\r\nlower_margin = (lower_margin + 1) / 2;\r\nvsync_len = (vsync_len + 1) / 2;\r\n} else if (var->vmode & FB_VMODE_DOUBLE) {\r\nupper_margin *= 2;\r\nlower_margin *= 2;\r\nvsync_len *= 2;\r\n}\r\n}\r\n} else {\r\nif (bpp == 16)\r\nxstretch = 2;\r\nif (var->pixclock == 0) {\r\nint linesize;\r\nplen = 1 * xstretch;\r\nif ((plen * xres + f25.right + f25.hsync + f25.left) *\r\nfb_info.monspecs.hfmin < f25.f)\r\npclock = &f25;\r\nelse if ((plen * xres + f32.right + f32.hsync +\r\nf32.left) * fb_info.monspecs.hfmin < f32.f)\r\npclock = &f32;\r\nelse if ((plen * xres + fext.right + fext.hsync +\r\nfext.left) * fb_info.monspecs.hfmin < fext.f &&\r\nfext.f)\r\npclock = &fext;\r\nelse\r\nreturn -EINVAL;\r\nleft_margin = pclock->left / plen;\r\nright_margin = pclock->right / plen;\r\nhsync_len = pclock->hsync / plen;\r\nlinesize = left_margin + xres + right_margin + hsync_len;\r\nupper_margin = 31;\r\nlower_margin = 11;\r\nvsync_len = 3;\r\n} else {\r\nint i;\r\nunsigned long pcl = ULONG_MAX;\r\npclock = 0;\r\nfor (i = 1; i <= 4; i *= 2) {\r\nif (f25.t * i >= var->pixclock &&\r\nf25.t * i < pcl) {\r\npcl = f25.t * i;\r\npclock = &f25;\r\n}\r\nif (f32.t * i >= var->pixclock &&\r\nf32.t * i < pcl) {\r\npcl = f32.t * i;\r\npclock = &f32;\r\n}\r\nif (fext.t && fext.t * i >= var->pixclock &&\r\nfext.t * i < pcl) {\r\npcl = fext.t * i;\r\npclock = &fext;\r\n}\r\n}\r\nif (!pclock)\r\nreturn -EINVAL;\r\nplen = pcl / pclock->t;\r\nleft_margin = var->left_margin;\r\nright_margin = var->right_margin;\r\nhsync_len = var->hsync_len;\r\nupper_margin = var->upper_margin;\r\nlower_margin = var->lower_margin;\r\nvsync_len = var->vsync_len;\r\nif (var->vmode & FB_VMODE_INTERLACED) {\r\nupper_margin = (upper_margin + 1) / 2;\r\nlower_margin = (lower_margin + 1) / 2;\r\nvsync_len = (vsync_len + 1) / 2;\r\n} else if (var->vmode & FB_VMODE_DOUBLE) {\r\nupper_margin *= 2;\r\nlower_margin *= 2;\r\nvsync_len *= 2;\r\n}\r\n}\r\nif (pclock == &fext)\r\nlongoffset = 1;\r\n}\r\nif (pclock->f / plen / 8 * bpp > 32000000L)\r\nreturn -EINVAL;\r\nif (vsync_len < 1)\r\nvsync_len = 1;\r\nright_margin += hsync_len;\r\nlower_margin += vsync_len;\r\nagain:\r\npar->hw.falcon.vid_control = mon_type | f030_bus_width;\r\nif (!longoffset)\r\npar->hw.falcon.vid_control |= VCO_SHORTOFFS;\r\nif (var->sync & FB_SYNC_HOR_HIGH_ACT)\r\npar->hw.falcon.vid_control |= VCO_HSYPOS;\r\nif (var->sync & FB_SYNC_VERT_HIGH_ACT)\r\npar->hw.falcon.vid_control |= VCO_VSYPOS;\r\npar->hw.falcon.vid_control |= pclock->control_mask;\r\npar->hw.falcon.sync = pclock->sync_mask | 0x2;\r\npar->hw.falcon.vid_mode = (2 / plen) << 2;\r\nif (doubleline)\r\npar->hw.falcon.vid_mode |= VMO_DOUBLE;\r\nif (interlace)\r\npar->hw.falcon.vid_mode |= VMO_INTER;\r\n{\r\nprescale = hxx_prescale(&par->hw.falcon);\r\nbase_off = par->hw.falcon.vid_control & VCO_SHORTOFFS ? 64 : 128;\r\nif (par->hw.falcon.f_shift & 0x100) {\r\nalign = 1;\r\nhde_off = 0;\r\nhdb_off = (base_off + 16 * plen) + prescale;\r\n} else {\r\nalign = 128 / bpp;\r\nhde_off = ((128 / bpp + 2) * plen);\r\nif (par->hw.falcon.ste_mode)\r\nhdb_off = (64 + base_off + (128 / bpp + 2) * plen) + prescale;\r\nelse\r\nhdb_off = (base_off + (128 / bpp + 18) * plen) + prescale;\r\n}\r\ngstart = (prescale / 2 + plen * left_margin) / prescale;\r\ngend1 = gstart + roundup(xres, align) * plen / prescale;\r\ngend2 = gstart + xres * plen / prescale;\r\npar->HHT = plen * (left_margin + xres + right_margin) /\r\n(2 * prescale) - 2;\r\npar->HDB = gstart - hdb_off / prescale;\r\npar->HBE = gstart;\r\nif (par->HDB < 0)\r\npar->HDB += par->HHT + 2 + 0x200;\r\npar->HDE = gend1 - par->HHT - 2 - hde_off / prescale;\r\npar->HBB = gend2 - par->HHT - 2;\r\n#if 0\r\nif ((par->HDB & 0x200) && (par->HDB & ~0x200) - par->HDE <= 5) {\r\n}\r\n#endif\r\nif (hde_off % prescale)\r\npar->HBB++;\r\npar->HSS = par->HHT + 2 - plen * hsync_len / prescale;\r\nif (par->HSS < par->HBB)\r\npar->HSS = par->HBB;\r\n}\r\nhfreq = pclock->f / ((par->HHT + 2) * prescale * 2);\r\nif (hfreq > fb_info.monspecs.hfmax && mon_type != F_MON_VGA) {\r\nleft_margin += 1;\r\nright_margin += 1;\r\ngoto again;\r\n}\r\nif (hfreq > fb_info.monspecs.hfmax || hfreq < fb_info.monspecs.hfmin)\r\nreturn -EINVAL;\r\npar->VBE = (upper_margin * 2 + 1);\r\npar->VDB = par->VBE;\r\npar->VDE = yres;\r\nif (!interlace)\r\npar->VDE <<= 1;\r\nif (doubleline)\r\npar->VDE <<= 1;\r\npar->VDE += par->VDB;\r\npar->VBB = par->VDE;\r\npar->VFT = par->VBB + (lower_margin * 2 - 1) - 1;\r\npar->VSS = par->VFT + 1 - (vsync_len * 2 - 1);\r\nif (interlace) {\r\npar->VBB++;\r\npar->VSS++;\r\npar->VFT++;\r\n}\r\nvfreq = (hfreq * 2) / (par->VFT + 1);\r\nif (vfreq > fb_info.monspecs.vfmax && !doubleline && !interlace) {\r\ndoubleline = 1;\r\ngoto again;\r\n} else if (vfreq < fb_info.monspecs.vfmin && !interlace && !doubleline) {\r\ninterlace = 1;\r\ngoto again;\r\n} else if (vfreq < fb_info.monspecs.vfmin && doubleline) {\r\nint lines;\r\ndoubleline = 0;\r\nfor (lines = 0;\r\n(hfreq * 2) / (par->VFT + 1 + 4 * lines - 2 * yres) >\r\nfb_info.monspecs.vfmax;\r\nlines++)\r\n;\r\nupper_margin += lines;\r\nlower_margin += lines;\r\ngoto again;\r\n} else if (vfreq > fb_info.monspecs.vfmax && doubleline) {\r\nint lines;\r\nfor (lines = 0;\r\n(hfreq * 2) / (par->VFT + 1 + 4 * lines) >\r\nfb_info.monspecs.vfmax;\r\nlines += 2)\r\n;\r\nupper_margin += lines;\r\nlower_margin += lines;\r\ngoto again;\r\n} else if (vfreq > fb_info.monspecs.vfmax && interlace) {\r\nint lines;\r\nfor (lines = 0;\r\n(hfreq * 2) / (par->VFT + 1 + 4 * lines) >\r\nfb_info.monspecs.vfmax;\r\nlines++)\r\n;\r\nupper_margin += lines;\r\nlower_margin += lines;\r\ngoto again;\r\n} else if (vfreq < fb_info.monspecs.vfmin ||\r\nvfreq > fb_info.monspecs.vfmax)\r\nreturn -EINVAL;\r\nset_screen_base:\r\nlinelen = xres_virtual * bpp / 8;\r\nif (yres_virtual * linelen > screen_len && screen_len)\r\nreturn -EINVAL;\r\nif (yres * linelen > screen_len && screen_len)\r\nreturn -EINVAL;\r\nif (var->yoffset + yres > yres_virtual && yres_virtual)\r\nreturn -EINVAL;\r\npar->yres_virtual = yres_virtual;\r\npar->screen_base = screen_base + var->yoffset * linelen;\r\npar->hw.falcon.xoffset = 0;\r\npar->next_line = linelen;\r\nreturn 0;\r\n}\r\nstatic int falcon_encode_var(struct fb_var_screeninfo *var,\r\nstruct atafb_par *par)\r\n{\r\nint linelen;\r\nint prescale, plen;\r\nint hdb_off, hde_off, base_off;\r\nstruct falcon_hw *hw = &par->hw.falcon;\r\nmemset(var, 0, sizeof(struct fb_var_screeninfo));\r\nvar->pixclock = hw->sync & 0x1 ? fext.t :\r\nhw->vid_control & VCO_CLOCK25 ? f25.t : f32.t;\r\nvar->height = -1;\r\nvar->width = -1;\r\nvar->sync = 0;\r\nif (hw->vid_control & VCO_HSYPOS)\r\nvar->sync |= FB_SYNC_HOR_HIGH_ACT;\r\nif (hw->vid_control & VCO_VSYPOS)\r\nvar->sync |= FB_SYNC_VERT_HIGH_ACT;\r\nvar->vmode = FB_VMODE_NONINTERLACED;\r\nif (hw->vid_mode & VMO_INTER)\r\nvar->vmode |= FB_VMODE_INTERLACED;\r\nif (hw->vid_mode & VMO_DOUBLE)\r\nvar->vmode |= FB_VMODE_DOUBLE;\r\nvar->yres = hw->vde - hw->vdb;\r\nif (!(var->vmode & FB_VMODE_INTERLACED))\r\nvar->yres >>= 1;\r\nif (var->vmode & FB_VMODE_DOUBLE)\r\nvar->yres >>= 1;\r\nif (hw->f_shift & 0x400)\r\nvar->bits_per_pixel = 1;\r\nelse if (hw->f_shift & 0x100)\r\nvar->bits_per_pixel = 16;\r\nelse if (hw->f_shift & 0x010)\r\nvar->bits_per_pixel = 8;\r\nelse if (hw->st_shift == 0)\r\nvar->bits_per_pixel = 4;\r\nelse if (hw->st_shift == 0x100)\r\nvar->bits_per_pixel = 2;\r\nelse\r\nvar->bits_per_pixel = 1;\r\nvar->xres = hw->line_width * 16 / var->bits_per_pixel;\r\nvar->xres_virtual = var->xres + hw->line_offset * 16 / var->bits_per_pixel;\r\nif (hw->xoffset)\r\nvar->xres_virtual += 16;\r\nif (var->bits_per_pixel == 16) {\r\nvar->red.offset = 11;\r\nvar->red.length = 5;\r\nvar->red.msb_right = 0;\r\nvar->green.offset = 5;\r\nvar->green.length = 6;\r\nvar->green.msb_right = 0;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 5;\r\nvar->blue.msb_right = 0;\r\n} else {\r\nvar->red.offset = 0;\r\nvar->red.length = hw->ste_mode ? 4 : 6;\r\nif (var->red.length > var->bits_per_pixel)\r\nvar->red.length = var->bits_per_pixel;\r\nvar->red.msb_right = 0;\r\nvar->grayscale = 0;\r\nvar->blue = var->green = var->red;\r\n}\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nvar->transp.msb_right = 0;\r\nlinelen = var->xres_virtual * var->bits_per_pixel / 8;\r\nif (screen_len) {\r\nif (par->yres_virtual)\r\nvar->yres_virtual = par->yres_virtual;\r\nelse\r\nvar->yres_virtual = screen_len / linelen;\r\n} else {\r\nif (hwscroll < 0)\r\nvar->yres_virtual = 2 * var->yres;\r\nelse\r\nvar->yres_virtual = var->yres + hwscroll * 16;\r\n}\r\nvar->xoffset = 0;\r\nprescale = hxx_prescale(hw);\r\nplen = 4 >> (hw->vid_mode >> 2 & 0x3);\r\nbase_off = hw->vid_control & VCO_SHORTOFFS ? 64 : 128;\r\nif (hw->f_shift & 0x100) {\r\nhde_off = 0;\r\nhdb_off = (base_off + 16 * plen) + prescale;\r\n} else {\r\nhde_off = ((128 / var->bits_per_pixel + 2) * plen);\r\nif (hw->ste_mode)\r\nhdb_off = (64 + base_off + (128 / var->bits_per_pixel + 2) * plen)\r\n+ prescale;\r\nelse\r\nhdb_off = (base_off + (128 / var->bits_per_pixel + 18) * plen)\r\n+ prescale;\r\n}\r\nvar->left_margin = hdb_off + prescale * ((hw->hdb & 0x1ff) -\r\n(hw->hdb & 0x200 ? 2 + hw->hht : 0));\r\nif (hw->ste_mode || mon_type != F_MON_VGA)\r\nvar->right_margin = prescale * (hw->hht + 2 - hw->hde) - hde_off;\r\nelse\r\nvar->right_margin = prescale * (hw->hht + 2 - hw->hbb);\r\nvar->hsync_len = prescale * (hw->hht + 2 - hw->hss);\r\nvar->upper_margin = hw->vdb / 2;\r\nvar->lower_margin = (hw->vft + 1 - hw->vde + 1) / 2;\r\nvar->vsync_len = (hw->vft + 1 - hw->vss + 1) / 2;\r\nif (var->vmode & FB_VMODE_INTERLACED) {\r\nvar->upper_margin *= 2;\r\nvar->lower_margin *= 2;\r\nvar->vsync_len *= 2;\r\n} else if (var->vmode & FB_VMODE_DOUBLE) {\r\nvar->upper_margin = (var->upper_margin + 1) / 2;\r\nvar->lower_margin = (var->lower_margin + 1) / 2;\r\nvar->vsync_len = (var->vsync_len + 1) / 2;\r\n}\r\nvar->pixclock *= plen;\r\nvar->left_margin /= plen;\r\nvar->right_margin /= plen;\r\nvar->hsync_len /= plen;\r\nvar->right_margin -= var->hsync_len;\r\nvar->lower_margin -= var->vsync_len;\r\nif (screen_base)\r\nvar->yoffset = (par->screen_base - screen_base) / linelen;\r\nelse\r\nvar->yoffset = 0;\r\nvar->nonstd = 0;\r\nvar->activate = 0;\r\nreturn 0;\r\n}\r\nstatic void falcon_get_par(struct atafb_par *par)\r\n{\r\nunsigned long addr;\r\nstruct falcon_hw *hw = &par->hw.falcon;\r\nhw->line_width = shifter_f030.scn_width;\r\nhw->line_offset = shifter_f030.off_next;\r\nhw->st_shift = videl.st_shift & 0x300;\r\nhw->f_shift = videl.f_shift;\r\nhw->vid_control = videl.control;\r\nhw->vid_mode = videl.mode;\r\nhw->sync = shifter.syncmode & 0x1;\r\nhw->xoffset = videl.xoffset & 0xf;\r\nhw->hht = videl.hht;\r\nhw->hbb = videl.hbb;\r\nhw->hbe = videl.hbe;\r\nhw->hdb = videl.hdb;\r\nhw->hde = videl.hde;\r\nhw->hss = videl.hss;\r\nhw->vft = videl.vft;\r\nhw->vbb = videl.vbb;\r\nhw->vbe = videl.vbe;\r\nhw->vdb = videl.vdb;\r\nhw->vde = videl.vde;\r\nhw->vss = videl.vss;\r\naddr = (shifter.bas_hi & 0xff) << 16 |\r\n(shifter.bas_md & 0xff) << 8 |\r\n(shifter.bas_lo & 0xff);\r\npar->screen_base = atari_stram_to_virt(addr);\r\nhw->ste_mode = (hw->f_shift & 0x510) == 0 && hw->st_shift == 0x100;\r\nhw->mono = (hw->f_shift & 0x400) ||\r\n((hw->f_shift & 0x510) == 0 && hw->st_shift == 0x200);\r\n}\r\nstatic void falcon_set_par(struct atafb_par *par)\r\n{\r\nf_change_mode = 0;\r\nif (current_par.screen_base != par->screen_base)\r\nfbhw->set_screen_base(par->screen_base);\r\nif (DontCalcRes)\r\nreturn;\r\nf_new_mode = par->hw.falcon;\r\nf_change_mode = 1;\r\n}\r\nstatic irqreturn_t falcon_vbl_switcher(int irq, void *dummy)\r\n{\r\nstruct falcon_hw *hw = &f_new_mode;\r\nif (f_change_mode) {\r\nf_change_mode = 0;\r\nif (hw->sync & 0x1) {\r\n*(volatile unsigned short *)0xffff9202 = 0xffbf;\r\n} else {\r\n*(volatile unsigned short *)0xffff9202;\r\n}\r\nshifter.syncmode = hw->sync;\r\nvidel.hht = hw->hht;\r\nvidel.hbb = hw->hbb;\r\nvidel.hbe = hw->hbe;\r\nvidel.hdb = hw->hdb;\r\nvidel.hde = hw->hde;\r\nvidel.hss = hw->hss;\r\nvidel.vft = hw->vft;\r\nvidel.vbb = hw->vbb;\r\nvidel.vbe = hw->vbe;\r\nvidel.vdb = hw->vdb;\r\nvidel.vde = hw->vde;\r\nvidel.vss = hw->vss;\r\nvidel.f_shift = 0;\r\nif (hw->ste_mode) {\r\nvidel.st_shift = hw->st_shift;\r\n} else {\r\nvidel.st_shift = 0;\r\nvidel.f_shift = hw->f_shift;\r\n}\r\nvidel.xoffset = hw->xoffset;\r\nshifter_f030.scn_width = hw->line_width;\r\nshifter_f030.off_next = hw->line_offset;\r\nvidel.control = hw->vid_control;\r\nvidel.mode = hw->vid_mode;\r\n}\r\nif (f_pan_display) {\r\nf_pan_display = 0;\r\nvidel.xoffset = current_par.hw.falcon.xoffset;\r\nshifter_f030.off_next = current_par.hw.falcon.line_offset;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int falcon_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct atafb_par *par = (struct atafb_par *)info->par;\r\nint xoffset;\r\nint bpp = info->var.bits_per_pixel;\r\nif (bpp == 1)\r\nvar->xoffset = up(var->xoffset, 32);\r\nif (bpp != 16)\r\npar->hw.falcon.xoffset = var->xoffset & 15;\r\nelse {\r\npar->hw.falcon.xoffset = 0;\r\nvar->xoffset = up(var->xoffset, 2);\r\n}\r\npar->hw.falcon.line_offset = bpp *\r\n(info->var.xres_virtual - info->var.xres) / 16;\r\nif (par->hw.falcon.xoffset)\r\npar->hw.falcon.line_offset -= bpp;\r\nxoffset = var->xoffset - par->hw.falcon.xoffset;\r\npar->screen_base = screen_base +\r\n(var->yoffset * info->var.xres_virtual + xoffset) * bpp / 8;\r\nif (fbhw->set_screen_base)\r\nfbhw->set_screen_base(par->screen_base);\r\nelse\r\nreturn -EINVAL;\r\nf_pan_display = 1;\r\nreturn 0;\r\n}\r\nstatic int falcon_setcolreg(unsigned int regno, unsigned int red,\r\nunsigned int green, unsigned int blue,\r\nunsigned int transp, struct fb_info *info)\r\n{\r\nif (regno > 255)\r\nreturn 1;\r\nf030_col[regno] = (((red & 0xfc00) << 16) |\r\n((green & 0xfc00) << 8) |\r\n((blue & 0xfc00) >> 8));\r\nif (regno < 16) {\r\nshifter_tt.color_reg[regno] =\r\n(((red & 0xe000) >> 13) | ((red & 0x1000) >> 12) << 8) |\r\n(((green & 0xe000) >> 13) | ((green & 0x1000) >> 12) << 4) |\r\n((blue & 0xe000) >> 13) | ((blue & 0x1000) >> 12);\r\n((u32 *)info->pseudo_palette)[regno] = ((red & 0xf800) |\r\n((green & 0xfc00) >> 5) |\r\n((blue & 0xf800) >> 11));\r\n}\r\nreturn 0;\r\n}\r\nstatic int falcon_blank(int blank_mode)\r\n{\r\nint vdb, vss, hbe, hss;\r\nif (mon_type == F_MON_SM)\r\nreturn 1;\r\nvdb = current_par.VDB;\r\nvss = current_par.VSS;\r\nhbe = current_par.HBE;\r\nhss = current_par.HSS;\r\nif (blank_mode >= 1) {\r\nvdb = current_par.VFT + 1;\r\nhbe = current_par.HHT + 2;\r\n}\r\nif (mon_type == F_MON_VGA) {\r\nif (blank_mode == 2 || blank_mode == 4)\r\nvss = current_par.VFT + 1;\r\nif (blank_mode == 3 || blank_mode == 4)\r\nhss = current_par.HHT + 2;\r\n}\r\nvidel.vdb = vdb;\r\nvidel.vss = vss;\r\nvidel.hbe = hbe;\r\nvidel.hss = hss;\r\nreturn 0;\r\n}\r\nstatic int falcon_detect(void)\r\n{\r\nstruct atafb_par par;\r\nunsigned char fhw;\r\nfhw = *(unsigned char *)0xffff8006;\r\nmon_type = fhw >> 6 & 0x3;\r\nf030_bus_width = fhw << 6 & 0x80;\r\nswitch (mon_type) {\r\ncase F_MON_SM:\r\nfb_info.monspecs.vfmin = 70;\r\nfb_info.monspecs.vfmax = 72;\r\nfb_info.monspecs.hfmin = 35713;\r\nfb_info.monspecs.hfmax = 35715;\r\nbreak;\r\ncase F_MON_SC:\r\ncase F_MON_TV:\r\nfb_info.monspecs.vfmin = 49;\r\nfb_info.monspecs.vfmax = 60;\r\nfb_info.monspecs.hfmin = 15620;\r\nfb_info.monspecs.hfmax = 15755;\r\nbreak;\r\n}\r\nf25.hsync = h_syncs[mon_type] / f25.t;\r\nf32.hsync = h_syncs[mon_type] / f32.t;\r\nif (fext.t)\r\nfext.hsync = h_syncs[mon_type] / fext.t;\r\nfalcon_get_par(&par);\r\nfalcon_encode_var(&atafb_predefined[0], &par);\r\nreturn 1;\r\n}\r\nstatic int stste_encode_fix(struct fb_fix_screeninfo *fix,\r\nstruct atafb_par *par)\r\n{\r\nint mode;\r\nstrcpy(fix->id, "Atari Builtin");\r\nfix->smem_start = phys_screen_base;\r\nfix->smem_len = screen_len;\r\nfix->type = FB_TYPE_INTERLEAVED_PLANES;\r\nfix->type_aux = 2;\r\nfix->visual = FB_VISUAL_PSEUDOCOLOR;\r\nmode = par->hw.st.mode & 3;\r\nif (mode == ST_HIGH) {\r\nfix->type = FB_TYPE_PACKED_PIXELS;\r\nfix->type_aux = 0;\r\nfix->visual = FB_VISUAL_MONO10;\r\n}\r\nif (ATARIHW_PRESENT(EXTD_SHIFTER)) {\r\nfix->xpanstep = 16;\r\nfix->ypanstep = 1;\r\n} else {\r\nfix->xpanstep = 0;\r\nfix->ypanstep = 0;\r\n}\r\nfix->ywrapstep = 0;\r\nfix->line_length = par->next_line;\r\nfix->accel = FB_ACCEL_ATARIBLITT;\r\nreturn 0;\r\n}\r\nstatic int stste_decode_var(struct fb_var_screeninfo *var,\r\nstruct atafb_par *par)\r\n{\r\nint xres = var->xres;\r\nint yres = var->yres;\r\nint bpp = var->bits_per_pixel;\r\nint linelen;\r\nint yres_virtual = var->yres_virtual;\r\nif (mono_moni) {\r\nif (bpp > 1 || xres > sttt_xres || yres > st_yres)\r\nreturn -EINVAL;\r\npar->hw.st.mode = ST_HIGH;\r\nxres = sttt_xres;\r\nyres = st_yres;\r\nbpp = 1;\r\n} else {\r\nif (bpp > 4 || xres > sttt_xres || yres > st_yres)\r\nreturn -EINVAL;\r\nif (bpp > 2) {\r\nif (xres > sttt_xres / 2 || yres > st_yres / 2)\r\nreturn -EINVAL;\r\npar->hw.st.mode = ST_LOW;\r\nxres = sttt_xres / 2;\r\nyres = st_yres / 2;\r\nbpp = 4;\r\n} else if (bpp > 1) {\r\nif (xres > sttt_xres || yres > st_yres / 2)\r\nreturn -EINVAL;\r\npar->hw.st.mode = ST_MID;\r\nxres = sttt_xres;\r\nyres = st_yres / 2;\r\nbpp = 2;\r\n} else\r\nreturn -EINVAL;\r\n}\r\nif (yres_virtual <= 0)\r\nyres_virtual = 0;\r\nelse if (yres_virtual < yres)\r\nyres_virtual = yres;\r\nif (var->sync & FB_SYNC_EXT)\r\npar->hw.st.sync = (par->hw.st.sync & ~1) | 1;\r\nelse\r\npar->hw.st.sync = (par->hw.st.sync & ~1);\r\nlinelen = xres * bpp / 8;\r\nif (yres_virtual * linelen > screen_len && screen_len)\r\nreturn -EINVAL;\r\nif (yres * linelen > screen_len && screen_len)\r\nreturn -EINVAL;\r\nif (var->yoffset + yres > yres_virtual && yres_virtual)\r\nreturn -EINVAL;\r\npar->yres_virtual = yres_virtual;\r\npar->screen_base = screen_base + var->yoffset * linelen;\r\npar->next_line = linelen;\r\nreturn 0;\r\n}\r\nstatic int stste_encode_var(struct fb_var_screeninfo *var,\r\nstruct atafb_par *par)\r\n{\r\nint linelen;\r\nmemset(var, 0, sizeof(struct fb_var_screeninfo));\r\nvar->red.offset = 0;\r\nvar->red.length = ATARIHW_PRESENT(EXTD_SHIFTER) ? 4 : 3;\r\nvar->red.msb_right = 0;\r\nvar->grayscale = 0;\r\nvar->pixclock = 31041;\r\nvar->left_margin = 120;\r\nvar->right_margin = 100;\r\nvar->upper_margin = 8;\r\nvar->lower_margin = 16;\r\nvar->hsync_len = 140;\r\nvar->vsync_len = 30;\r\nvar->height = -1;\r\nvar->width = -1;\r\nif (!(par->hw.st.sync & 1))\r\nvar->sync = 0;\r\nelse\r\nvar->sync = FB_SYNC_EXT;\r\nswitch (par->hw.st.mode & 3) {\r\ncase ST_LOW:\r\nvar->xres = sttt_xres / 2;\r\nvar->yres = st_yres / 2;\r\nvar->bits_per_pixel = 4;\r\nbreak;\r\ncase ST_MID:\r\nvar->xres = sttt_xres;\r\nvar->yres = st_yres / 2;\r\nvar->bits_per_pixel = 2;\r\nbreak;\r\ncase ST_HIGH:\r\nvar->xres = sttt_xres;\r\nvar->yres = st_yres;\r\nvar->bits_per_pixel = 1;\r\nbreak;\r\n}\r\nvar->blue = var->green = var->red;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nvar->transp.msb_right = 0;\r\nvar->xres_virtual = sttt_xres_virtual;\r\nlinelen = var->xres_virtual * var->bits_per_pixel / 8;\r\novsc_addlen = linelen * (sttt_yres_virtual - st_yres);\r\nif (!use_hwscroll)\r\nvar->yres_virtual = var->yres;\r\nelse if (screen_len) {\r\nif (par->yres_virtual)\r\nvar->yres_virtual = par->yres_virtual;\r\nelse\r\nvar->yres_virtual = screen_len / linelen;\r\n} else {\r\nif (hwscroll < 0)\r\nvar->yres_virtual = 2 * var->yres;\r\nelse\r\nvar->yres_virtual = var->yres + hwscroll * 16;\r\n}\r\nvar->xoffset = 0;\r\nif (screen_base)\r\nvar->yoffset = (par->screen_base - screen_base) / linelen;\r\nelse\r\nvar->yoffset = 0;\r\nvar->nonstd = 0;\r\nvar->activate = 0;\r\nvar->vmode = FB_VMODE_NONINTERLACED;\r\nreturn 0;\r\n}\r\nstatic void stste_get_par(struct atafb_par *par)\r\n{\r\nunsigned long addr;\r\npar->hw.st.mode = shifter_tt.st_shiftmode;\r\npar->hw.st.sync = shifter.syncmode;\r\naddr = ((shifter.bas_hi & 0xff) << 16) |\r\n((shifter.bas_md & 0xff) << 8);\r\nif (ATARIHW_PRESENT(EXTD_SHIFTER))\r\naddr |= (shifter.bas_lo & 0xff);\r\npar->screen_base = atari_stram_to_virt(addr);\r\n}\r\nstatic void stste_set_par(struct atafb_par *par)\r\n{\r\nshifter_tt.st_shiftmode = par->hw.st.mode;\r\nshifter.syncmode = par->hw.st.sync;\r\nif (current_par.screen_base != par->screen_base)\r\nfbhw->set_screen_base(par->screen_base);\r\n}\r\nstatic int stste_setcolreg(unsigned int regno, unsigned int red,\r\nunsigned int green, unsigned int blue,\r\nunsigned int transp, struct fb_info *info)\r\n{\r\nif (regno > 15)\r\nreturn 1;\r\nred >>= 12;\r\nblue >>= 12;\r\ngreen >>= 12;\r\nif (ATARIHW_PRESENT(EXTD_SHIFTER))\r\nshifter_tt.color_reg[regno] =\r\n(((red & 0xe) >> 1) | ((red & 1) << 3) << 8) |\r\n(((green & 0xe) >> 1) | ((green & 1) << 3) << 4) |\r\n((blue & 0xe) >> 1) | ((blue & 1) << 3);\r\nelse\r\nshifter_tt.color_reg[regno] =\r\n((red & 0xe) << 7) |\r\n((green & 0xe) << 3) |\r\n((blue & 0xe) >> 1);\r\nreturn 0;\r\n}\r\nstatic int stste_detect(void)\r\n{\r\nstruct atafb_par par;\r\nif (ATARIHW_PRESENT(PCM_8BIT)) {\r\ntt_dmasnd.ctrl = DMASND_CTRL_OFF;\r\nudelay(20);\r\n}\r\nmono_moni = (st_mfp.par_dt_reg & 0x80) == 0;\r\nstste_get_par(&par);\r\nstste_encode_var(&atafb_predefined[0], &par);\r\nif (!ATARIHW_PRESENT(EXTD_SHIFTER))\r\nuse_hwscroll = 0;\r\nreturn 1;\r\n}\r\nstatic void stste_set_screen_base(void *s_base)\r\n{\r\nunsigned long addr;\r\naddr = atari_stram_to_phys(s_base);\r\nshifter.bas_hi = (unsigned char)((addr & 0xff0000) >> 16);\r\nshifter.bas_md = (unsigned char)((addr & 0x00ff00) >> 8);\r\nif (ATARIHW_PRESENT(EXTD_SHIFTER))\r\nshifter.bas_lo = (unsigned char)(addr & 0x0000ff);\r\n}\r\nstatic void st_ovsc_switch(void)\r\n{\r\nunsigned long flags;\r\nregister unsigned char old, new;\r\nif (!(atari_switches & ATARI_SWITCH_OVSC_MASK))\r\nreturn;\r\nlocal_irq_save(flags);\r\nst_mfp.tim_ct_b = 0x10;\r\nst_mfp.active_edge |= 8;\r\nst_mfp.tim_ct_b = 0;\r\nst_mfp.tim_dt_b = 0xf0;\r\nst_mfp.tim_ct_b = 8;\r\nwhile (st_mfp.tim_dt_b > 1)\r\n;\r\nnew = st_mfp.tim_dt_b;\r\ndo {\r\nudelay(LINE_DELAY);\r\nold = new;\r\nnew = st_mfp.tim_dt_b;\r\n} while (old != new);\r\nst_mfp.tim_ct_b = 0x10;\r\nudelay(SYNC_DELAY);\r\nif (atari_switches & ATARI_SWITCH_OVSC_IKBD)\r\nacia.key_ctrl = ACIA_DIV64 | ACIA_D8N1S | ACIA_RHTID | ACIA_RIE;\r\nif (atari_switches & ATARI_SWITCH_OVSC_MIDI)\r\nacia.mid_ctrl = ACIA_DIV16 | ACIA_D8N1S | ACIA_RHTID;\r\nif (atari_switches & (ATARI_SWITCH_OVSC_SND6|ATARI_SWITCH_OVSC_SND7)) {\r\nsound_ym.rd_data_reg_sel = 14;\r\nsound_ym.wd_data = sound_ym.rd_data_reg_sel |\r\n((atari_switches & ATARI_SWITCH_OVSC_SND6) ? 0x40:0) |\r\n((atari_switches & ATARI_SWITCH_OVSC_SND7) ? 0x80:0);\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int ext_encode_fix(struct fb_fix_screeninfo *fix, struct atafb_par *par)\r\n{\r\nstrcpy(fix->id, "Unknown Extern");\r\nfix->smem_start = external_addr;\r\nfix->smem_len = PAGE_ALIGN(external_len);\r\nif (external_depth == 1) {\r\nfix->type = FB_TYPE_PACKED_PIXELS;\r\nfix->visual =\r\n(external_pmode == FB_TYPE_INTERLEAVED_PLANES ||\r\nexternal_pmode == FB_TYPE_PACKED_PIXELS) ?\r\nFB_VISUAL_MONO10 : FB_VISUAL_MONO01;\r\n} else {\r\nint visual = external_vgaiobase ?\r\nFB_VISUAL_PSEUDOCOLOR :\r\nFB_VISUAL_STATIC_PSEUDOCOLOR;\r\nswitch (external_pmode) {\r\ncase -1:\r\nfix->type = FB_TYPE_PACKED_PIXELS;\r\nfix->visual = FB_VISUAL_TRUECOLOR;\r\nbreak;\r\ncase FB_TYPE_PACKED_PIXELS:\r\nfix->type = FB_TYPE_PACKED_PIXELS;\r\nfix->visual = visual;\r\nbreak;\r\ncase FB_TYPE_PLANES:\r\nfix->type = FB_TYPE_PLANES;\r\nfix->visual = visual;\r\nbreak;\r\ncase FB_TYPE_INTERLEAVED_PLANES:\r\nfix->type = FB_TYPE_INTERLEAVED_PLANES;\r\nfix->type_aux = 2;\r\nfix->visual = visual;\r\nbreak;\r\n}\r\n}\r\nfix->xpanstep = 0;\r\nfix->ypanstep = 0;\r\nfix->ywrapstep = 0;\r\nfix->line_length = par->next_line;\r\nreturn 0;\r\n}\r\nstatic int ext_decode_var(struct fb_var_screeninfo *var, struct atafb_par *par)\r\n{\r\nstruct fb_var_screeninfo *myvar = &atafb_predefined[0];\r\nif (var->bits_per_pixel > myvar->bits_per_pixel ||\r\nvar->xres > myvar->xres ||\r\nvar->xres_virtual > myvar->xres_virtual ||\r\nvar->yres > myvar->yres ||\r\nvar->xoffset > 0 ||\r\nvar->yoffset > 0)\r\nreturn -EINVAL;\r\npar->next_line = external_xres_virtual * external_depth / 8;\r\nreturn 0;\r\n}\r\nstatic int ext_encode_var(struct fb_var_screeninfo *var, struct atafb_par *par)\r\n{\r\nmemset(var, 0, sizeof(struct fb_var_screeninfo));\r\nvar->red.offset = 0;\r\nvar->red.length = (external_pmode == -1) ? external_depth / 3 :\r\n(external_vgaiobase ? external_bitspercol : 0);\r\nvar->red.msb_right = 0;\r\nvar->grayscale = 0;\r\nvar->pixclock = 31041;\r\nvar->left_margin = 120;\r\nvar->right_margin = 100;\r\nvar->upper_margin = 8;\r\nvar->lower_margin = 16;\r\nvar->hsync_len = 140;\r\nvar->vsync_len = 30;\r\nvar->height = -1;\r\nvar->width = -1;\r\nvar->sync = 0;\r\nvar->xres = external_xres;\r\nvar->yres = external_yres;\r\nvar->xres_virtual = external_xres_virtual;\r\nvar->bits_per_pixel = external_depth;\r\nvar->blue = var->green = var->red;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nvar->transp.msb_right = 0;\r\nvar->yres_virtual = var->yres;\r\nvar->xoffset = 0;\r\nvar->yoffset = 0;\r\nvar->nonstd = 0;\r\nvar->activate = 0;\r\nvar->vmode = FB_VMODE_NONINTERLACED;\r\nreturn 0;\r\n}\r\nstatic void ext_get_par(struct atafb_par *par)\r\n{\r\npar->screen_base = external_screen_base;\r\n}\r\nstatic void ext_set_par(struct atafb_par *par)\r\n{\r\n}\r\nstatic int ext_setcolreg(unsigned int regno, unsigned int red,\r\nunsigned int green, unsigned int blue,\r\nunsigned int transp, struct fb_info *info)\r\n{\r\nunsigned char colmask = (1 << external_bitspercol) - 1;\r\nif (!external_vgaiobase)\r\nreturn 1;\r\nif (regno > 255)\r\nreturn 1;\r\nswitch (external_card_type) {\r\ncase IS_VGA:\r\nOUTB(0x3c8, regno);\r\nDACDelay;\r\nOUTB(0x3c9, red & colmask);\r\nDACDelay;\r\nOUTB(0x3c9, green & colmask);\r\nDACDelay;\r\nOUTB(0x3c9, blue & colmask);\r\nDACDelay;\r\nreturn 0;\r\ncase IS_MV300:\r\nOUTB((MV300_reg[regno] << 2) + 1, red);\r\nOUTB((MV300_reg[regno] << 2) + 1, green);\r\nOUTB((MV300_reg[regno] << 2) + 1, blue);\r\nreturn 0;\r\ndefault:\r\nreturn 1;\r\n}\r\n}\r\nstatic int ext_detect(void)\r\n{\r\nstruct fb_var_screeninfo *myvar = &atafb_predefined[0];\r\nstruct atafb_par dummy_par;\r\nmyvar->xres = external_xres;\r\nmyvar->xres_virtual = external_xres_virtual;\r\nmyvar->yres = external_yres;\r\nmyvar->bits_per_pixel = external_depth;\r\next_encode_var(myvar, &dummy_par);\r\nreturn 1;\r\n}\r\nstatic void set_screen_base(void *s_base)\r\n{\r\nunsigned long addr;\r\naddr = atari_stram_to_phys(s_base);\r\nshifter.bas_hi = (unsigned char)((addr & 0xff0000) >> 16);\r\nshifter.bas_md = (unsigned char)((addr & 0x00ff00) >> 8);\r\nshifter.bas_lo = (unsigned char)(addr & 0x0000ff);\r\n}\r\nstatic int pan_display(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nstruct atafb_par *par = (struct atafb_par *)info->par;\r\nif (!fbhw->set_screen_base ||\r\n(!ATARIHW_PRESENT(EXTD_SHIFTER) && var->xoffset))\r\nreturn -EINVAL;\r\nvar->xoffset = up(var->xoffset, 16);\r\npar->screen_base = screen_base +\r\n(var->yoffset * info->var.xres_virtual + var->xoffset)\r\n* info->var.bits_per_pixel / 8;\r\nfbhw->set_screen_base(par->screen_base);\r\nreturn 0;\r\n}\r\nstatic void ata_get_par(struct atafb_par *par)\r\n{\r\nif (current_par_valid)\r\n*par = current_par;\r\nelse\r\nfbhw->get_par(par);\r\n}\r\nstatic void ata_set_par(struct atafb_par *par)\r\n{\r\nfbhw->set_par(par);\r\ncurrent_par = *par;\r\ncurrent_par_valid = 1;\r\n}\r\nstatic int do_fb_set_var(struct fb_var_screeninfo *var, int isactive)\r\n{\r\nint err, activate;\r\nstruct atafb_par par;\r\nerr = fbhw->decode_var(var, &par);\r\nif (err)\r\nreturn err;\r\nactivate = var->activate;\r\nif (((var->activate & FB_ACTIVATE_MASK) == FB_ACTIVATE_NOW) && isactive)\r\nata_set_par(&par);\r\nfbhw->encode_var(var, &par);\r\nvar->activate = activate;\r\nreturn 0;\r\n}\r\nstatic int atafb_get_fix(struct fb_fix_screeninfo *fix, struct fb_info *info)\r\n{\r\nstruct atafb_par par;\r\nint err;\r\nerr = fbhw->decode_var(&info->var, &par);\r\nif (err)\r\nreturn err;\r\nmemset(fix, 0, sizeof(struct fb_fix_screeninfo));\r\nerr = fbhw->encode_fix(fix, &par);\r\nreturn err;\r\n}\r\nstatic int atafb_get_var(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nstruct atafb_par par;\r\nata_get_par(&par);\r\nfbhw->encode_var(var, &par);\r\nreturn 0;\r\n}\r\nstatic void atafb_set_disp(struct fb_info *info)\r\n{\r\natafb_get_var(&info->var, info);\r\natafb_get_fix(&info->fix, info);\r\ninfo->screen_base = (external_addr ? external_screen_base :\r\natari_stram_to_virt(info->fix.smem_start));\r\n}\r\nstatic int atafb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\r\nu_int transp, struct fb_info *info)\r\n{\r\nred >>= 8;\r\ngreen >>= 8;\r\nblue >>= 8;\r\nreturn info->fbops->fb_setcolreg(regno, red, green, blue, transp, info);\r\n}\r\nstatic int\r\natafb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nint xoffset = var->xoffset;\r\nint yoffset = var->yoffset;\r\nint err;\r\nif (var->vmode & FB_VMODE_YWRAP) {\r\nif (yoffset < 0 || yoffset >= info->var.yres_virtual || xoffset)\r\nreturn -EINVAL;\r\n} else {\r\nif (xoffset + info->var.xres > info->var.xres_virtual ||\r\nyoffset + info->var.yres > info->var.yres_virtual)\r\nreturn -EINVAL;\r\n}\r\nif (fbhw->pan_display) {\r\nerr = fbhw->pan_display(var, info);\r\nif (err)\r\nreturn err;\r\n} else\r\nreturn -EINVAL;\r\ninfo->var.xoffset = xoffset;\r\ninfo->var.yoffset = yoffset;\r\nif (var->vmode & FB_VMODE_YWRAP)\r\ninfo->var.vmode |= FB_VMODE_YWRAP;\r\nelse\r\ninfo->var.vmode &= ~FB_VMODE_YWRAP;\r\nreturn 0;\r\n}\r\nstatic void atafb_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\r\n{\r\nstruct atafb_par *par = (struct atafb_par *)info->par;\r\nint x2, y2;\r\nu32 width, height;\r\nif (!rect->width || !rect->height)\r\nreturn;\r\n#ifdef ATAFB_FALCON\r\nif (info->var.bits_per_pixel == 16) {\r\ncfb_fillrect(info, rect);\r\nreturn;\r\n}\r\n#endif\r\nx2 = rect->dx + rect->width;\r\ny2 = rect->dy + rect->height;\r\nx2 = x2 < info->var.xres_virtual ? x2 : info->var.xres_virtual;\r\ny2 = y2 < info->var.yres_virtual ? y2 : info->var.yres_virtual;\r\nwidth = x2 - rect->dx;\r\nheight = y2 - rect->dy;\r\nif (info->var.bits_per_pixel == 1)\r\natafb_mfb_fillrect(info, par->next_line, rect->color,\r\nrect->dy, rect->dx, height, width);\r\nelse if (info->var.bits_per_pixel == 2)\r\natafb_iplan2p2_fillrect(info, par->next_line, rect->color,\r\nrect->dy, rect->dx, height, width);\r\nelse if (info->var.bits_per_pixel == 4)\r\natafb_iplan2p4_fillrect(info, par->next_line, rect->color,\r\nrect->dy, rect->dx, height, width);\r\nelse\r\natafb_iplan2p8_fillrect(info, par->next_line, rect->color,\r\nrect->dy, rect->dx, height, width);\r\nreturn;\r\n}\r\nstatic void atafb_copyarea(struct fb_info *info, const struct fb_copyarea *area)\r\n{\r\nstruct atafb_par *par = (struct atafb_par *)info->par;\r\nint x2, y2;\r\nu32 dx, dy, sx, sy, width, height;\r\nint rev_copy = 0;\r\n#ifdef ATAFB_FALCON\r\nif (info->var.bits_per_pixel == 16) {\r\ncfb_copyarea(info, area);\r\nreturn;\r\n}\r\n#endif\r\nx2 = area->dx + area->width;\r\ny2 = area->dy + area->height;\r\ndx = area->dx > 0 ? area->dx : 0;\r\ndy = area->dy > 0 ? area->dy : 0;\r\nx2 = x2 < info->var.xres_virtual ? x2 : info->var.xres_virtual;\r\ny2 = y2 < info->var.yres_virtual ? y2 : info->var.yres_virtual;\r\nwidth = x2 - dx;\r\nheight = y2 - dy;\r\nif (area->sx + dx < area->dx || area->sy + dy < area->dy)\r\nreturn;\r\nsx = area->sx + (dx - area->dx);\r\nsy = area->sy + (dy - area->dy);\r\nif (sx + width > info->var.xres_virtual ||\r\nsy + height > info->var.yres_virtual)\r\nreturn;\r\nif (dy > sy || (dy == sy && dx > sx)) {\r\ndy += height;\r\nsy += height;\r\nrev_copy = 1;\r\n}\r\nif (info->var.bits_per_pixel == 1)\r\natafb_mfb_copyarea(info, par->next_line, sy, sx, dy, dx, height, width);\r\nelse if (info->var.bits_per_pixel == 2)\r\natafb_iplan2p2_copyarea(info, par->next_line, sy, sx, dy, dx, height, width);\r\nelse if (info->var.bits_per_pixel == 4)\r\natafb_iplan2p4_copyarea(info, par->next_line, sy, sx, dy, dx, height, width);\r\nelse\r\natafb_iplan2p8_copyarea(info, par->next_line, sy, sx, dy, dx, height, width);\r\nreturn;\r\n}\r\nstatic void atafb_imageblit(struct fb_info *info, const struct fb_image *image)\r\n{\r\nstruct atafb_par *par = (struct atafb_par *)info->par;\r\nint x2, y2;\r\nunsigned long *dst;\r\nint dst_idx;\r\nconst char *src;\r\nu32 dx, dy, width, height, pitch;\r\n#ifdef ATAFB_FALCON\r\nif (info->var.bits_per_pixel == 16) {\r\ncfb_imageblit(info, image);\r\nreturn;\r\n}\r\n#endif\r\nx2 = image->dx + image->width;\r\ny2 = image->dy + image->height;\r\ndx = image->dx;\r\ndy = image->dy;\r\nx2 = x2 < info->var.xres_virtual ? x2 : info->var.xres_virtual;\r\ny2 = y2 < info->var.yres_virtual ? y2 : info->var.yres_virtual;\r\nwidth = x2 - dx;\r\nheight = y2 - dy;\r\nif (image->depth == 1) {\r\ndst = (unsigned long *)\r\n((unsigned long)info->screen_base & ~(BYTES_PER_LONG - 1));\r\ndst_idx = ((unsigned long)info->screen_base & (BYTES_PER_LONG - 1)) * 8;\r\ndst_idx += dy * par->next_line * 8 + dx;\r\nsrc = image->data;\r\npitch = (image->width + 7) / 8;\r\nwhile (height--) {\r\nif (info->var.bits_per_pixel == 1)\r\natafb_mfb_linefill(info, par->next_line,\r\ndy, dx, width, src,\r\nimage->bg_color, image->fg_color);\r\nelse if (info->var.bits_per_pixel == 2)\r\natafb_iplan2p2_linefill(info, par->next_line,\r\ndy, dx, width, src,\r\nimage->bg_color, image->fg_color);\r\nelse if (info->var.bits_per_pixel == 4)\r\natafb_iplan2p4_linefill(info, par->next_line,\r\ndy, dx, width, src,\r\nimage->bg_color, image->fg_color);\r\nelse\r\natafb_iplan2p8_linefill(info, par->next_line,\r\ndy, dx, width, src,\r\nimage->bg_color, image->fg_color);\r\ndy++;\r\nsrc += pitch;\r\n}\r\n} else {\r\nc2p_iplan2(info->screen_base, image->data, dx, dy, width,\r\nheight, par->next_line, image->width,\r\ninfo->var.bits_per_pixel);\r\n}\r\n}\r\nstatic int\r\natafb_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)\r\n{\r\nswitch (cmd) {\r\n#ifdef FBCMD_GET_CURRENTPAR\r\ncase FBCMD_GET_CURRENTPAR:\r\nif (copy_to_user((void *)arg, (void *)&current_par,\r\nsizeof(struct atafb_par)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n#endif\r\n#ifdef FBCMD_SET_CURRENTPAR\r\ncase FBCMD_SET_CURRENTPAR:\r\nif (copy_from_user((void *)&current_par, (void *)arg,\r\nsizeof(struct atafb_par)))\r\nreturn -EFAULT;\r\nata_set_par(&current_par);\r\nreturn 0;\r\n#endif\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int atafb_blank(int blank, struct fb_info *info)\r\n{\r\nunsigned short black[16];\r\nstruct fb_cmap cmap;\r\nif (fbhw->blank && !fbhw->blank(blank))\r\nreturn 1;\r\nif (blank) {\r\nmemset(black, 0, 16 * sizeof(unsigned short));\r\ncmap.red = black;\r\ncmap.green = black;\r\ncmap.blue = black;\r\ncmap.transp = NULL;\r\ncmap.start = 0;\r\ncmap.len = 16;\r\nfb_set_cmap(&cmap, info);\r\n}\r\n#if 0\r\nelse\r\ndo_install_cmap(info);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int atafb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nint err;\r\nstruct atafb_par par;\r\nerr = fbhw->decode_var(var, &par);\r\nif (err)\r\nreturn err;\r\nfbhw->encode_var(var, &par);\r\nreturn 0;\r\n}\r\nstatic int atafb_set_par(struct fb_info *info)\r\n{\r\nstruct atafb_par *par = (struct atafb_par *)info->par;\r\nfbhw->decode_var(&info->var, par);\r\nmutex_lock(&info->mm_lock);\r\nfbhw->encode_fix(&info->fix, par);\r\nmutex_unlock(&info->mm_lock);\r\nata_set_par(par);\r\nreturn 0;\r\n}\r\nstatic void check_default_par(int detected_mode)\r\n{\r\nchar default_name[10];\r\nint i;\r\nstruct fb_var_screeninfo var;\r\nunsigned long min_mem;\r\nif (default_par) {\r\nvar = atafb_predefined[default_par - 1];\r\nvar.activate = FB_ACTIVATE_TEST;\r\nif (do_fb_set_var(&var, 1))\r\ndefault_par = 0;\r\n}\r\nif (!default_par) {\r\nvar = atafb_predefined[detected_mode - 1];\r\nvar.activate = FB_ACTIVATE_TEST;\r\nif (!do_fb_set_var(&var, 1))\r\ndefault_par = detected_mode;\r\n}\r\nif (!default_par) {\r\nfor (i = 1; i < 10; i++) {\r\nsprintf(default_name,"default%d", i);\r\ndefault_par = get_video_mode(default_name);\r\nif (!default_par)\r\npanic("can't set default video mode");\r\nvar = atafb_predefined[default_par - 1];\r\nvar.activate = FB_ACTIVATE_TEST;\r\nif (!do_fb_set_var(&var,1))\r\nbreak;\r\n}\r\n}\r\nmin_mem = var.xres_virtual * var.yres_virtual * var.bits_per_pixel / 8;\r\nif (default_mem_req < min_mem)\r\ndefault_mem_req = min_mem;\r\n}\r\nstatic void __init atafb_setup_ext(char *spec)\r\n{\r\nint xres, xres_virtual, yres, depth, planes;\r\nunsigned long addr, len;\r\nchar *p;\r\np = strsep(&spec, ";");\r\nif (!p || !*p)\r\nreturn;\r\nxres_virtual = xres = simple_strtoul(p, NULL, 10);\r\nif (xres <= 0)\r\nreturn;\r\np = strsep(&spec, ";");\r\nif (!p || !*p)\r\nreturn;\r\nyres = simple_strtoul(p, NULL, 10);\r\nif (yres <= 0)\r\nreturn;\r\np = strsep(&spec, ";");\r\nif (!p || !*p)\r\nreturn;\r\ndepth = simple_strtoul(p, NULL, 10);\r\nif (depth != 1 && depth != 2 && depth != 4 && depth != 8 &&\r\ndepth != 16 && depth != 24)\r\nreturn;\r\np = strsep(&spec, ";");\r\nif (!p || !*p)\r\nreturn;\r\nif (*p == 'i')\r\nplanes = FB_TYPE_INTERLEAVED_PLANES;\r\nelse if (*p == 'p')\r\nplanes = FB_TYPE_PACKED_PIXELS;\r\nelse if (*p == 'n')\r\nplanes = FB_TYPE_PLANES;\r\nelse if (*p == 't')\r\nplanes = -1;\r\nelse\r\nreturn;\r\np = strsep(&spec, ";");\r\nif (!p || !*p)\r\nreturn;\r\naddr = simple_strtoul(p, NULL, 0);\r\np = strsep(&spec, ";");\r\nif (!p || !*p)\r\nlen = xres * yres * depth / 8;\r\nelse\r\nlen = simple_strtoul(p, NULL, 0);\r\np = strsep(&spec, ";");\r\nif (p && *p)\r\nexternal_vgaiobase = simple_strtoul(p, NULL, 0);\r\np = strsep(&spec, ";");\r\nif (p && *p) {\r\nexternal_bitspercol = simple_strtoul(p, NULL, 0);\r\nif (external_bitspercol > 8)\r\nexternal_bitspercol = 8;\r\nelse if (external_bitspercol < 1)\r\nexternal_bitspercol = 1;\r\n}\r\np = strsep(&spec, ";");\r\nif (p && *p) {\r\nif (!strcmp(p, "vga"))\r\nexternal_card_type = IS_VGA;\r\nif (!strcmp(p, "mv300"))\r\nexternal_card_type = IS_MV300;\r\n}\r\np = strsep(&spec, ";");\r\nif (p && *p) {\r\nxres_virtual = simple_strtoul(p, NULL, 10);\r\nif (xres_virtual < xres)\r\nxres_virtual = xres;\r\nif (xres_virtual * yres * depth / 8 > len)\r\nlen = xres_virtual * yres * depth / 8;\r\n}\r\nexternal_xres = xres;\r\nexternal_xres_virtual = xres_virtual;\r\nexternal_yres = yres;\r\nexternal_depth = depth;\r\nexternal_pmode = planes;\r\nexternal_addr = addr;\r\nexternal_len = len;\r\nif (external_card_type == IS_MV300) {\r\nswitch (external_depth) {\r\ncase 1:\r\nMV300_reg = MV300_reg_1bit;\r\nbreak;\r\ncase 4:\r\nMV300_reg = MV300_reg_4bit;\r\nbreak;\r\ncase 8:\r\nMV300_reg = MV300_reg_8bit;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void __init atafb_setup_int(char *spec)\r\n{\r\nint xres;\r\nchar *p;\r\nif (!(p = strsep(&spec, ";")) || !*p)\r\nreturn;\r\nxres = simple_strtoul(p, NULL, 10);\r\nif (!(p = strsep(&spec, ";")) || !*p)\r\nreturn;\r\nsttt_xres = xres;\r\ntt_yres = st_yres = simple_strtoul(p, NULL, 10);\r\nif ((p = strsep(&spec, ";")) && *p)\r\nsttt_xres_virtual = simple_strtoul(p, NULL, 10);\r\nif ((p = strsep(&spec, ";")) && *p)\r\nsttt_yres_virtual = simple_strtoul(p, NULL, 0);\r\nif ((p = strsep(&spec, ";")) && *p)\r\novsc_offset = simple_strtoul(p, NULL, 0);\r\nif (ovsc_offset || (sttt_yres_virtual != st_yres))\r\nuse_hwscroll = 0;\r\n}\r\nstatic void __init atafb_setup_mcap(char *spec)\r\n{\r\nchar *p;\r\nint vmin, vmax, hmin, hmax;\r\nif (!(p = strsep(&spec, ";")) || !*p)\r\nreturn;\r\nvmin = simple_strtoul(p, NULL, 10);\r\nif (vmin <= 0)\r\nreturn;\r\nif (!(p = strsep(&spec, ";")) || !*p)\r\nreturn;\r\nvmax = simple_strtoul(p, NULL, 10);\r\nif (vmax <= 0 || vmax <= vmin)\r\nreturn;\r\nif (!(p = strsep(&spec, ";")) || !*p)\r\nreturn;\r\nhmin = 1000 * simple_strtoul(p, NULL, 10);\r\nif (hmin <= 0)\r\nreturn;\r\nif (!(p = strsep(&spec, "")) || !*p)\r\nreturn;\r\nhmax = 1000 * simple_strtoul(p, NULL, 10);\r\nif (hmax <= 0 || hmax <= hmin)\r\nreturn;\r\nfb_info.monspecs.vfmin = vmin;\r\nfb_info.monspecs.vfmax = vmax;\r\nfb_info.monspecs.hfmin = hmin;\r\nfb_info.monspecs.hfmax = hmax;\r\n}\r\nstatic void __init atafb_setup_user(char *spec)\r\n{\r\nchar *p;\r\nint xres, yres, depth, temp;\r\np = strsep(&spec, ";");\r\nif (!p || !*p)\r\nreturn;\r\nxres = simple_strtoul(p, NULL, 10);\r\np = strsep(&spec, ";");\r\nif (!p || !*p)\r\nreturn;\r\nyres = simple_strtoul(p, NULL, 10);\r\np = strsep(&spec, "");\r\nif (!p || !*p)\r\nreturn;\r\ndepth = simple_strtoul(p, NULL, 10);\r\ntemp = get_video_mode("user0");\r\nif (temp) {\r\ndefault_par = temp;\r\natafb_predefined[default_par - 1].xres = xres;\r\natafb_predefined[default_par - 1].yres = yres;\r\natafb_predefined[default_par - 1].bits_per_pixel = depth;\r\n}\r\n}\r\nint __init atafb_setup(char *options)\r\n{\r\nchar *this_opt;\r\nint temp;\r\nif (!options || !*options)\r\nreturn 0;\r\nwhile ((this_opt = strsep(&options, ",")) != NULL) {\r\nif (!*this_opt)\r\ncontinue;\r\nif ((temp = get_video_mode(this_opt))) {\r\ndefault_par = temp;\r\nmode_option = this_opt;\r\n} else if (!strcmp(this_opt, "inverse"))\r\ninverse = 1;\r\nelse if (!strncmp(this_opt, "hwscroll_", 9)) {\r\nhwscroll = simple_strtoul(this_opt + 9, NULL, 10);\r\nif (hwscroll < 0)\r\nhwscroll = 0;\r\nif (hwscroll > 200)\r\nhwscroll = 200;\r\n}\r\n#ifdef ATAFB_EXT\r\nelse if (!strcmp(this_opt, "mv300")) {\r\nexternal_bitspercol = 8;\r\nexternal_card_type = IS_MV300;\r\n} else if (!strncmp(this_opt, "external:", 9))\r\natafb_setup_ext(this_opt + 9);\r\n#endif\r\nelse if (!strncmp(this_opt, "internal:", 9))\r\natafb_setup_int(this_opt + 9);\r\n#ifdef ATAFB_FALCON\r\nelse if (!strncmp(this_opt, "eclock:", 7)) {\r\nfext.f = simple_strtoul(this_opt + 7, NULL, 10);\r\nfext.t = 1000000000 / fext.f;\r\nfext.f *= 1000;\r\n} else if (!strncmp(this_opt, "monitorcap:", 11))\r\natafb_setup_mcap(this_opt + 11);\r\n#endif\r\nelse if (!strcmp(this_opt, "keep"))\r\nDontCalcRes = 1;\r\nelse if (!strncmp(this_opt, "R", 1))\r\natafb_setup_user(this_opt + 1);\r\n}\r\nreturn 0;\r\n}\r\nint __init atafb_init(void)\r\n{\r\nint pad, detected_mode, error;\r\nunsigned int defmode = 0;\r\nunsigned long mem_req;\r\n#ifndef MODULE\r\nchar *option = NULL;\r\nif (fb_get_options("atafb", &option))\r\nreturn -ENODEV;\r\natafb_setup(option);\r\n#endif\r\nprintk("atafb_init: start\n");\r\nif (!MACH_IS_ATARI)\r\nreturn -ENODEV;\r\ndo {\r\n#ifdef ATAFB_EXT\r\nif (external_addr) {\r\nprintk("atafb_init: initializing external hw\n");\r\nfbhw = &ext_switch;\r\natafb_ops.fb_setcolreg = &ext_setcolreg;\r\ndefmode = DEFMODE_EXT;\r\nbreak;\r\n}\r\n#endif\r\n#ifdef ATAFB_TT\r\nif (ATARIHW_PRESENT(TT_SHIFTER)) {\r\nprintk("atafb_init: initializing TT hw\n");\r\nfbhw = &tt_switch;\r\natafb_ops.fb_setcolreg = &tt_setcolreg;\r\ndefmode = DEFMODE_TT;\r\nbreak;\r\n}\r\n#endif\r\n#ifdef ATAFB_FALCON\r\nif (ATARIHW_PRESENT(VIDEL_SHIFTER)) {\r\nprintk("atafb_init: initializing Falcon hw\n");\r\nfbhw = &falcon_switch;\r\natafb_ops.fb_setcolreg = &falcon_setcolreg;\r\nerror = request_irq(IRQ_AUTO_4, falcon_vbl_switcher, 0,\r\n"framebuffer:modeswitch",\r\nfalcon_vbl_switcher);\r\nif (error)\r\nreturn error;\r\ndefmode = DEFMODE_F30;\r\nbreak;\r\n}\r\n#endif\r\n#ifdef ATAFB_STE\r\nif (ATARIHW_PRESENT(STND_SHIFTER) ||\r\nATARIHW_PRESENT(EXTD_SHIFTER)) {\r\nprintk("atafb_init: initializing ST/E hw\n");\r\nfbhw = &st_switch;\r\natafb_ops.fb_setcolreg = &stste_setcolreg;\r\ndefmode = DEFMODE_STE;\r\nbreak;\r\n}\r\nfbhw = &st_switch;\r\natafb_ops.fb_setcolreg = &stste_setcolreg;\r\nprintk("Cannot determine video hardware; defaulting to ST(e)\n");\r\n#else\r\npanic("Cannot initialize video hardware");\r\n#endif\r\n} while (0);\r\nif (fb_info.monspecs.hfmin == 0) {\r\nfb_info.monspecs.hfmin = 31000;\r\nfb_info.monspecs.hfmax = 32000;\r\nfb_info.monspecs.vfmin = 58;\r\nfb_info.monspecs.vfmax = 62;\r\n}\r\ndetected_mode = fbhw->detect();\r\ncheck_default_par(detected_mode);\r\n#ifdef ATAFB_EXT\r\nif (!external_addr) {\r\n#endif\r\nmem_req = default_mem_req + ovsc_offset + ovsc_addlen;\r\nmem_req = PAGE_ALIGN(mem_req) + PAGE_SIZE;\r\nscreen_base = atari_stram_alloc(mem_req, "atafb");\r\nif (!screen_base)\r\npanic("Cannot allocate screen memory");\r\nmemset(screen_base, 0, mem_req);\r\npad = -(unsigned long)screen_base & (PAGE_SIZE - 1);\r\nscreen_base += pad;\r\nphys_screen_base = atari_stram_to_phys(screen_base + ovsc_offset);\r\nscreen_len = (mem_req - pad - ovsc_offset) & PAGE_MASK;\r\nst_ovsc_switch();\r\nif (CPU_IS_040_OR_060) {\r\ncache_push(atari_stram_to_phys(screen_base), screen_len);\r\nkernel_set_cachemode(screen_base, screen_len,\r\nIOMAP_WRITETHROUGH);\r\n}\r\nprintk("atafb: screen_base %p phys_screen_base %lx screen_len %d\n",\r\nscreen_base, phys_screen_base, screen_len);\r\n#ifdef ATAFB_EXT\r\n} else {\r\nexternal_screen_base = ioremap_writethrough(external_addr,\r\nexternal_len);\r\nif (external_vgaiobase)\r\nexternal_vgaiobase =\r\n(unsigned long)ioremap(external_vgaiobase, 0x10000);\r\nscreen_base = external_screen_base;\r\nphys_screen_base = external_addr;\r\nscreen_len = external_len & PAGE_MASK;\r\nmemset (screen_base, 0, external_len);\r\n}\r\n#endif\r\nfb_info.fbops = &atafb_ops;\r\ndo_fb_set_var(&atafb_predefined[default_par - 1], 1);\r\nata_get_par(&current_par);\r\nfb_info.par = &current_par;\r\natafb_get_var(&fb_info.var, &fb_info);\r\n#ifdef ATAFB_FALCON\r\nfb_info.pseudo_palette = current_par.hw.falcon.pseudo_palette;\r\n#endif\r\nfb_info.flags = FBINFO_FLAG_DEFAULT;\r\nif (!fb_find_mode(&fb_info.var, &fb_info, mode_option, atafb_modedb,\r\nNUM_TOTAL_MODES, &atafb_modedb[defmode],\r\nfb_info.var.bits_per_pixel)) {\r\nreturn -EINVAL;\r\n}\r\nfb_videomode_to_modelist(atafb_modedb, NUM_TOTAL_MODES,\r\n&fb_info.modelist);\r\natafb_set_disp(&fb_info);\r\nfb_alloc_cmap(&(fb_info.cmap), 1 << fb_info.var.bits_per_pixel, 0);\r\nprintk("Determined %dx%d, depth %d\n",\r\nfb_info.var.xres, fb_info.var.yres, fb_info.var.bits_per_pixel);\r\nif ((fb_info.var.xres != fb_info.var.xres_virtual) ||\r\n(fb_info.var.yres != fb_info.var.yres_virtual))\r\nprintk(" virtual %dx%d\n", fb_info.var.xres_virtual,\r\nfb_info.var.yres_virtual);\r\nif (register_framebuffer(&fb_info) < 0) {\r\n#ifdef ATAFB_EXT\r\nif (external_addr) {\r\niounmap(external_screen_base);\r\nexternal_addr = 0;\r\n}\r\nif (external_vgaiobase) {\r\niounmap((void*)external_vgaiobase);\r\nexternal_vgaiobase = 0;\r\n}\r\n#endif\r\nreturn -EINVAL;\r\n}\r\nfb_info(&fb_info, "frame buffer device, using %dK of video memory\n",\r\nscreen_len >> 10);\r\nreturn 0;\r\n}\r\nint cleanup_module(void)\r\n{\r\nunregister_framebuffer(&fb_info);\r\nreturn atafb_deinit();\r\n}
