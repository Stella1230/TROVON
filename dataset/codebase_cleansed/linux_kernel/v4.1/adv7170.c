static inline struct adv7170 *to_adv7170(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct adv7170, sd);\r\n}\r\nstatic inline int adv7170_write(struct v4l2_subdev *sd, u8 reg, u8 value)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct adv7170 *encoder = to_adv7170(sd);\r\nencoder->reg[reg] = value;\r\nreturn i2c_smbus_write_byte_data(client, reg, value);\r\n}\r\nstatic inline int adv7170_read(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nreturn i2c_smbus_read_byte_data(client, reg);\r\n}\r\nstatic int adv7170_write_block(struct v4l2_subdev *sd,\r\nconst u8 *data, unsigned int len)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct adv7170 *encoder = to_adv7170(sd);\r\nint ret = -1;\r\nu8 reg;\r\nif (i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\r\nu8 block_data[32];\r\nint block_len;\r\nwhile (len >= 2) {\r\nblock_len = 0;\r\nblock_data[block_len++] = reg = data[0];\r\ndo {\r\nblock_data[block_len++] =\r\nencoder->reg[reg++] = data[1];\r\nlen -= 2;\r\ndata += 2;\r\n} while (len >= 2 && data[0] == reg && block_len < 32);\r\nret = i2c_master_send(client, block_data, block_len);\r\nif (ret < 0)\r\nbreak;\r\n}\r\n} else {\r\nwhile (len >= 2) {\r\nreg = *data++;\r\nret = adv7170_write(sd, reg, *data++);\r\nif (ret < 0)\r\nbreak;\r\nlen -= 2;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int adv7170_s_std_output(struct v4l2_subdev *sd, v4l2_std_id std)\r\n{\r\nstruct adv7170 *encoder = to_adv7170(sd);\r\nv4l2_dbg(1, debug, sd, "set norm %llx\n", (unsigned long long)std);\r\nif (std & V4L2_STD_NTSC) {\r\nadv7170_write_block(sd, init_NTSC, sizeof(init_NTSC));\r\nif (encoder->input == 0)\r\nadv7170_write(sd, 0x02, 0x0e);\r\nadv7170_write(sd, 0x07, TR0MODE | TR0RST);\r\nadv7170_write(sd, 0x07, TR0MODE);\r\n} else if (std & V4L2_STD_PAL) {\r\nadv7170_write_block(sd, init_PAL, sizeof(init_PAL));\r\nif (encoder->input == 0)\r\nadv7170_write(sd, 0x02, 0x0e);\r\nadv7170_write(sd, 0x07, TR0MODE | TR0RST);\r\nadv7170_write(sd, 0x07, TR0MODE);\r\n} else {\r\nv4l2_dbg(1, debug, sd, "illegal norm: %llx\n",\r\n(unsigned long long)std);\r\nreturn -EINVAL;\r\n}\r\nv4l2_dbg(1, debug, sd, "switched to %llx\n", (unsigned long long)std);\r\nencoder->norm = std;\r\nreturn 0;\r\n}\r\nstatic int adv7170_s_routing(struct v4l2_subdev *sd,\r\nu32 input, u32 output, u32 config)\r\n{\r\nstruct adv7170 *encoder = to_adv7170(sd);\r\nv4l2_dbg(1, debug, sd, "set input from %s\n",\r\ninput == 0 ? "decoder" : "ZR36060");\r\nswitch (input) {\r\ncase 0:\r\nadv7170_write(sd, 0x01, 0x20);\r\nadv7170_write(sd, 0x08, TR1CAPT);\r\nadv7170_write(sd, 0x02, 0x0e);\r\nadv7170_write(sd, 0x07, TR0MODE | TR0RST);\r\nadv7170_write(sd, 0x07, TR0MODE);\r\nbreak;\r\ncase 1:\r\nadv7170_write(sd, 0x01, 0x00);\r\nadv7170_write(sd, 0x08, TR1PLAY);\r\nadv7170_write(sd, 0x02, 0x08);\r\nadv7170_write(sd, 0x07, TR0MODE | TR0RST);\r\nadv7170_write(sd, 0x07, TR0MODE);\r\nbreak;\r\ndefault:\r\nv4l2_dbg(1, debug, sd, "illegal input: %d\n", input);\r\nreturn -EINVAL;\r\n}\r\nv4l2_dbg(1, debug, sd, "switched to %s\n", inputs[input]);\r\nencoder->input = input;\r\nreturn 0;\r\n}\r\nstatic int adv7170_enum_fmt(struct v4l2_subdev *sd, unsigned int index,\r\nu32 *code)\r\n{\r\nif (index >= ARRAY_SIZE(adv7170_codes))\r\nreturn -EINVAL;\r\n*code = adv7170_codes[index];\r\nreturn 0;\r\n}\r\nstatic int adv7170_g_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nu8 val = adv7170_read(sd, 0x7);\r\nif ((val & 0x40) == (1 << 6))\r\nmf->code = MEDIA_BUS_FMT_UYVY8_1X16;\r\nelse\r\nmf->code = MEDIA_BUS_FMT_UYVY8_2X8;\r\nmf->colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nmf->width = 0;\r\nmf->height = 0;\r\nmf->field = V4L2_FIELD_ANY;\r\nreturn 0;\r\n}\r\nstatic int adv7170_s_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nu8 val = adv7170_read(sd, 0x7);\r\nint ret;\r\nswitch (mf->code) {\r\ncase MEDIA_BUS_FMT_UYVY8_2X8:\r\nval &= ~0x40;\r\nbreak;\r\ncase MEDIA_BUS_FMT_UYVY8_1X16:\r\nval |= 0x40;\r\nbreak;\r\ndefault:\r\nv4l2_dbg(1, debug, sd,\r\n"illegal v4l2_mbus_framefmt code: %d\n", mf->code);\r\nreturn -EINVAL;\r\n}\r\nret = adv7170_write(sd, 0x7, val);\r\nreturn ret;\r\n}\r\nstatic int adv7170_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct adv7170 *encoder;\r\nstruct v4l2_subdev *sd;\r\nint i;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -ENODEV;\r\nv4l_info(client, "chip found @ 0x%x (%s)\n",\r\nclient->addr << 1, client->adapter->name);\r\nencoder = devm_kzalloc(&client->dev, sizeof(*encoder), GFP_KERNEL);\r\nif (encoder == NULL)\r\nreturn -ENOMEM;\r\nsd = &encoder->sd;\r\nv4l2_i2c_subdev_init(sd, client, &adv7170_ops);\r\nencoder->norm = V4L2_STD_NTSC;\r\nencoder->input = 0;\r\ni = adv7170_write_block(sd, init_NTSC, sizeof(init_NTSC));\r\nif (i >= 0) {\r\ni = adv7170_write(sd, 0x07, TR0MODE | TR0RST);\r\ni = adv7170_write(sd, 0x07, TR0MODE);\r\ni = adv7170_read(sd, 0x12);\r\nv4l2_dbg(1, debug, sd, "revision %d\n", i & 1);\r\n}\r\nif (i < 0)\r\nv4l2_dbg(1, debug, sd, "init error 0x%x\n", i);\r\nreturn 0;\r\n}\r\nstatic int adv7170_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nv4l2_device_unregister_subdev(sd);\r\nreturn 0;\r\n}
