static unsigned short snd_cs46xx_codec_read(struct snd_cs46xx *chip,\r\nunsigned short reg,\r\nint codec_index)\r\n{\r\nint count;\r\nunsigned short result,tmp;\r\nu32 offset = 0;\r\nif (snd_BUG_ON(codec_index != CS46XX_PRIMARY_CODEC_INDEX &&\r\ncodec_index != CS46XX_SECONDARY_CODEC_INDEX))\r\nreturn 0xffff;\r\nchip->active_ctrl(chip, 1);\r\nif (codec_index == CS46XX_SECONDARY_CODEC_INDEX)\r\noffset = CS46XX_SECONDARY_CODEC_OFFSET;\r\nsnd_cs46xx_peekBA0(chip, BA0_ACSDA + offset);\r\ntmp = snd_cs46xx_peekBA0(chip, BA0_ACCTL);\r\nif ((tmp & ACCTL_VFRM) == 0) {\r\ndev_warn(chip->card->dev, "ACCTL_VFRM not set 0x%x\n", tmp);\r\nsnd_cs46xx_pokeBA0(chip, BA0_ACCTL, (tmp & (~ACCTL_ESYN)) | ACCTL_VFRM );\r\nmsleep(50);\r\ntmp = snd_cs46xx_peekBA0(chip, BA0_ACCTL + offset);\r\nsnd_cs46xx_pokeBA0(chip, BA0_ACCTL, tmp | ACCTL_ESYN | ACCTL_VFRM );\r\n}\r\nsnd_cs46xx_pokeBA0(chip, BA0_ACCAD, reg);\r\nsnd_cs46xx_pokeBA0(chip, BA0_ACCDA, 0);\r\nif (codec_index == CS46XX_PRIMARY_CODEC_INDEX) {\r\nsnd_cs46xx_pokeBA0(chip, BA0_ACCTL, ACCTL_CRW |\r\nACCTL_VFRM | ACCTL_ESYN |\r\nACCTL_RSTN);\r\nsnd_cs46xx_pokeBA0(chip, BA0_ACCTL, ACCTL_DCV | ACCTL_CRW |\r\nACCTL_VFRM | ACCTL_ESYN |\r\nACCTL_RSTN);\r\n} else {\r\nsnd_cs46xx_pokeBA0(chip, BA0_ACCTL, ACCTL_DCV | ACCTL_TC |\r\nACCTL_CRW | ACCTL_VFRM | ACCTL_ESYN |\r\nACCTL_RSTN);\r\n}\r\nfor (count = 0; count < 1000; count++) {\r\nudelay(10);\r\nif (!(snd_cs46xx_peekBA0(chip, BA0_ACCTL) & ACCTL_DCV))\r\ngoto ok1;\r\n}\r\ndev_err(chip->card->dev,\r\n"AC'97 read problem (ACCTL_DCV), reg = 0x%x\n", reg);\r\nresult = 0xffff;\r\ngoto end;\r\nok1:\r\nfor (count = 0; count < 100; count++) {\r\nif (snd_cs46xx_peekBA0(chip, BA0_ACSTS + offset) & ACSTS_VSTS)\r\ngoto ok2;\r\nudelay(10);\r\n}\r\ndev_err(chip->card->dev,\r\n"AC'97 read problem (ACSTS_VSTS), codec_index %d, reg = 0x%x\n",\r\ncodec_index, reg);\r\nresult = 0xffff;\r\ngoto end;\r\nok2:\r\n#if 0\r\ndev_dbg(chip->card->dev,\r\n"e) reg = 0x%x, val = 0x%x, BA0_ACCAD = 0x%x\n", reg,\r\nsnd_cs46xx_peekBA0(chip, BA0_ACSDA),\r\nsnd_cs46xx_peekBA0(chip, BA0_ACCAD));\r\n#endif\r\nresult = snd_cs46xx_peekBA0(chip, BA0_ACSDA + offset);\r\nend:\r\nchip->active_ctrl(chip, -1);\r\nreturn result;\r\n}\r\nstatic unsigned short snd_cs46xx_ac97_read(struct snd_ac97 * ac97,\r\nunsigned short reg)\r\n{\r\nstruct snd_cs46xx *chip = ac97->private_data;\r\nunsigned short val;\r\nint codec_index = ac97->num;\r\nif (snd_BUG_ON(codec_index != CS46XX_PRIMARY_CODEC_INDEX &&\r\ncodec_index != CS46XX_SECONDARY_CODEC_INDEX))\r\nreturn 0xffff;\r\nval = snd_cs46xx_codec_read(chip, reg, codec_index);\r\nreturn val;\r\n}\r\nstatic void snd_cs46xx_codec_write(struct snd_cs46xx *chip,\r\nunsigned short reg,\r\nunsigned short val,\r\nint codec_index)\r\n{\r\nint count;\r\nif (snd_BUG_ON(codec_index != CS46XX_PRIMARY_CODEC_INDEX &&\r\ncodec_index != CS46XX_SECONDARY_CODEC_INDEX))\r\nreturn;\r\nchip->active_ctrl(chip, 1);\r\nsnd_cs46xx_pokeBA0(chip, BA0_ACCAD , reg);\r\nsnd_cs46xx_pokeBA0(chip, BA0_ACCDA , val);\r\nsnd_cs46xx_peekBA0(chip, BA0_ACCTL);\r\nif (codec_index == CS46XX_PRIMARY_CODEC_INDEX) {\r\nsnd_cs46xx_pokeBA0(chip, BA0_ACCTL, ACCTL_VFRM |\r\nACCTL_ESYN | ACCTL_RSTN);\r\nsnd_cs46xx_pokeBA0(chip, BA0_ACCTL, ACCTL_DCV | ACCTL_VFRM |\r\nACCTL_ESYN | ACCTL_RSTN);\r\n} else {\r\nsnd_cs46xx_pokeBA0(chip, BA0_ACCTL, ACCTL_DCV | ACCTL_TC |\r\nACCTL_VFRM | ACCTL_ESYN | ACCTL_RSTN);\r\n}\r\nfor (count = 0; count < 4000; count++) {\r\nudelay(10);\r\nif (!(snd_cs46xx_peekBA0(chip, BA0_ACCTL) & ACCTL_DCV)) {\r\ngoto end;\r\n}\r\n}\r\ndev_err(chip->card->dev,\r\n"AC'97 write problem, codec_index = %d, reg = 0x%x, val = 0x%x\n",\r\ncodec_index, reg, val);\r\nend:\r\nchip->active_ctrl(chip, -1);\r\n}\r\nstatic void snd_cs46xx_ac97_write(struct snd_ac97 *ac97,\r\nunsigned short reg,\r\nunsigned short val)\r\n{\r\nstruct snd_cs46xx *chip = ac97->private_data;\r\nint codec_index = ac97->num;\r\nif (snd_BUG_ON(codec_index != CS46XX_PRIMARY_CODEC_INDEX &&\r\ncodec_index != CS46XX_SECONDARY_CODEC_INDEX))\r\nreturn;\r\nsnd_cs46xx_codec_write(chip, reg, val, codec_index);\r\n}\r\nint snd_cs46xx_download(struct snd_cs46xx *chip,\r\nu32 *src,\r\nunsigned long offset,\r\nunsigned long len)\r\n{\r\nvoid __iomem *dst;\r\nunsigned int bank = offset >> 16;\r\noffset = offset & 0xffff;\r\nif (snd_BUG_ON((offset & 3) || (len & 3)))\r\nreturn -EINVAL;\r\ndst = chip->region.idx[bank+1].remap_addr + offset;\r\nlen /= sizeof(u32);\r\nwhile (len-- > 0) {\r\nwritel(*src++, dst);\r\ndst += sizeof(u32);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void memcpy_le32(void *dst, const void *src, unsigned int len)\r\n{\r\n#ifdef __LITTLE_ENDIAN\r\nmemcpy(dst, src, len);\r\n#else\r\nu32 *_dst = dst;\r\nconst __le32 *_src = src;\r\nlen /= 4;\r\nwhile (len-- > 0)\r\n*_dst++ = le32_to_cpu(*_src++);\r\n#endif\r\n}\r\nstatic void free_module_desc(struct dsp_module_desc *module)\r\n{\r\nif (!module)\r\nreturn;\r\nkfree(module->module_name);\r\nkfree(module->symbol_table.symbols);\r\nif (module->segments) {\r\nint i;\r\nfor (i = 0; i < module->nsegments; i++)\r\nkfree(module->segments[i].data);\r\nkfree(module->segments);\r\n}\r\nkfree(module);\r\n}\r\nstatic int load_firmware(struct snd_cs46xx *chip,\r\nstruct dsp_module_desc **module_ret,\r\nconst char *fw_name)\r\n{\r\nint i, err;\r\nunsigned int nums, fwlen, fwsize;\r\nconst __le32 *fwdat;\r\nstruct dsp_module_desc *module = NULL;\r\nconst struct firmware *fw;\r\nchar fw_path[32];\r\nsprintf(fw_path, "cs46xx/%s", fw_name);\r\nerr = request_firmware(&fw, fw_path, &chip->pci->dev);\r\nif (err < 0)\r\nreturn err;\r\nfwsize = fw->size / 4;\r\nif (fwsize < 2) {\r\nerr = -EINVAL;\r\ngoto error;\r\n}\r\nerr = -ENOMEM;\r\nmodule = kzalloc(sizeof(*module), GFP_KERNEL);\r\nif (!module)\r\ngoto error;\r\nmodule->module_name = kstrdup(fw_name, GFP_KERNEL);\r\nif (!module->module_name)\r\ngoto error;\r\nfwlen = 0;\r\nfwdat = (const __le32 *)fw->data;\r\nnums = module->symbol_table.nsymbols = le32_to_cpu(fwdat[fwlen++]);\r\nif (nums >= 40)\r\ngoto error_inval;\r\nmodule->symbol_table.symbols =\r\nkcalloc(nums, sizeof(struct dsp_symbol_entry), GFP_KERNEL);\r\nif (!module->symbol_table.symbols)\r\ngoto error;\r\nfor (i = 0; i < nums; i++) {\r\nstruct dsp_symbol_entry *entry =\r\n&module->symbol_table.symbols[i];\r\nif (fwlen + 2 + DSP_MAX_SYMBOL_NAME / 4 > fwsize)\r\ngoto error_inval;\r\nentry->address = le32_to_cpu(fwdat[fwlen++]);\r\nmemcpy(entry->symbol_name, &fwdat[fwlen], DSP_MAX_SYMBOL_NAME - 1);\r\nfwlen += DSP_MAX_SYMBOL_NAME / 4;\r\nentry->symbol_type = le32_to_cpu(fwdat[fwlen++]);\r\n}\r\nif (fwlen >= fwsize)\r\ngoto error_inval;\r\nnums = module->nsegments = le32_to_cpu(fwdat[fwlen++]);\r\nif (nums > 10)\r\ngoto error_inval;\r\nmodule->segments =\r\nkcalloc(nums, sizeof(struct dsp_segment_desc), GFP_KERNEL);\r\nif (!module->segments)\r\ngoto error;\r\nfor (i = 0; i < nums; i++) {\r\nstruct dsp_segment_desc *entry = &module->segments[i];\r\nif (fwlen + 3 > fwsize)\r\ngoto error_inval;\r\nentry->segment_type = le32_to_cpu(fwdat[fwlen++]);\r\nentry->offset = le32_to_cpu(fwdat[fwlen++]);\r\nentry->size = le32_to_cpu(fwdat[fwlen++]);\r\nif (fwlen + entry->size > fwsize)\r\ngoto error_inval;\r\nentry->data = kmalloc(entry->size * 4, GFP_KERNEL);\r\nif (!entry->data)\r\ngoto error;\r\nmemcpy_le32(entry->data, &fwdat[fwlen], entry->size * 4);\r\nfwlen += entry->size;\r\n}\r\n*module_ret = module;\r\nrelease_firmware(fw);\r\nreturn 0;\r\nerror_inval:\r\nerr = -EINVAL;\r\nerror:\r\nfree_module_desc(module);\r\nrelease_firmware(fw);\r\nreturn err;\r\n}\r\nint snd_cs46xx_clear_BA1(struct snd_cs46xx *chip,\r\nunsigned long offset,\r\nunsigned long len)\r\n{\r\nvoid __iomem *dst;\r\nunsigned int bank = offset >> 16;\r\noffset = offset & 0xffff;\r\nif (snd_BUG_ON((offset & 3) || (len & 3)))\r\nreturn -EINVAL;\r\ndst = chip->region.idx[bank+1].remap_addr + offset;\r\nlen /= sizeof(u32);\r\nwhile (len-- > 0) {\r\nwritel(0, dst);\r\ndst += sizeof(u32);\r\n}\r\nreturn 0;\r\n}\r\nstatic int load_firmware(struct snd_cs46xx *chip)\r\n{\r\nconst struct firmware *fw;\r\nint i, size, err;\r\nerr = request_firmware(&fw, "cs46xx/ba1", &chip->pci->dev);\r\nif (err < 0)\r\nreturn err;\r\nif (fw->size != sizeof(*chip->ba1)) {\r\nerr = -EINVAL;\r\ngoto error;\r\n}\r\nchip->ba1 = vmalloc(sizeof(*chip->ba1));\r\nif (!chip->ba1) {\r\nerr = -ENOMEM;\r\ngoto error;\r\n}\r\nmemcpy_le32(chip->ba1, fw->data, sizeof(*chip->ba1));\r\nsize = 0;\r\nfor (i = 0; i < BA1_MEMORY_COUNT; i++)\r\nsize += chip->ba1->memory[i].size;\r\nif (size > BA1_DWORD_SIZE * 4)\r\nerr = -EINVAL;\r\nerror:\r\nrelease_firmware(fw);\r\nreturn err;\r\n}\r\nint snd_cs46xx_download_image(struct snd_cs46xx *chip)\r\n{\r\nint idx, err;\r\nunsigned int offset = 0;\r\nstruct ba1_struct *ba1 = chip->ba1;\r\nfor (idx = 0; idx < BA1_MEMORY_COUNT; idx++) {\r\nerr = snd_cs46xx_download(chip,\r\n&ba1->map[offset],\r\nba1->memory[idx].offset,\r\nba1->memory[idx].size);\r\nif (err < 0)\r\nreturn err;\r\noffset += ba1->memory[idx].size >> 2;\r\n}\r\nreturn 0;\r\n}\r\nstatic void snd_cs46xx_reset(struct snd_cs46xx *chip)\r\n{\r\nint idx;\r\nsnd_cs46xx_poke(chip, BA1_SPCR, SPCR_RSTSP);\r\nsnd_cs46xx_poke(chip, BA1_SPCR, SPCR_DRQEN);\r\nfor (idx = 0; idx < 8; idx++) {\r\nsnd_cs46xx_poke(chip, BA1_DREG, DREG_REGID_TRAP_SELECT + idx);\r\nsnd_cs46xx_poke(chip, BA1_TWPR, 0xFFFF);\r\n}\r\nsnd_cs46xx_poke(chip, BA1_DREG, 0);\r\nsnd_cs46xx_poke(chip, BA1_FRMT, 0xadf);\r\n}\r\nstatic int cs46xx_wait_for_fifo(struct snd_cs46xx * chip,int retry_timeout)\r\n{\r\nu32 i, status = 0;\r\nfor(i = 0; i < 50; i++){\r\nstatus = snd_cs46xx_peekBA0(chip, BA0_SERBST);\r\nif( !(status & SERBST_WBSY) )\r\nbreak;\r\nmdelay(retry_timeout);\r\n}\r\nif(status & SERBST_WBSY) {\r\ndev_err(chip->card->dev,\r\n"failure waiting for FIFO command to complete\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void snd_cs46xx_clear_serial_FIFOs(struct snd_cs46xx *chip)\r\n{\r\nint idx, powerdown = 0;\r\nunsigned int tmp;\r\ntmp = snd_cs46xx_peekBA0(chip, BA0_CLKCR1);\r\nif (!(tmp & CLKCR1_SWCE)) {\r\nsnd_cs46xx_pokeBA0(chip, BA0_CLKCR1, tmp | CLKCR1_SWCE);\r\npowerdown = 1;\r\n}\r\nsnd_cs46xx_pokeBA0(chip, BA0_SERBWP, 0);\r\nfor (idx = 0; idx < 0xFF; idx++) {\r\nif (cs46xx_wait_for_fifo(chip,1)) {\r\ndev_dbg(chip->card->dev,\r\n"failed waiting for FIFO at addr (%02X)\n",\r\nidx);\r\nif (powerdown)\r\nsnd_cs46xx_pokeBA0(chip, BA0_CLKCR1, tmp);\r\nbreak;\r\n}\r\nsnd_cs46xx_pokeBA0(chip, BA0_SERBAD, idx);\r\nsnd_cs46xx_pokeBA0(chip, BA0_SERBCM, SERBCM_WRC);\r\n}\r\nif (powerdown)\r\nsnd_cs46xx_pokeBA0(chip, BA0_CLKCR1, tmp);\r\n}\r\nstatic void snd_cs46xx_proc_start(struct snd_cs46xx *chip)\r\n{\r\nint cnt;\r\nsnd_cs46xx_poke(chip, BA1_FRMT, 0xadf);\r\nsnd_cs46xx_poke(chip, BA1_SPCR, SPCR_RUN | SPCR_RUNFR | SPCR_DRQEN);\r\nfor (cnt = 0; cnt < 25; cnt++) {\r\nudelay(50);\r\nif (!(snd_cs46xx_peek(chip, BA1_SPCR) & SPCR_RUNFR))\r\nbreak;\r\n}\r\nif (snd_cs46xx_peek(chip, BA1_SPCR) & SPCR_RUNFR)\r\ndev_err(chip->card->dev, "SPCR_RUNFR never reset\n");\r\n}\r\nstatic void snd_cs46xx_proc_stop(struct snd_cs46xx *chip)\r\n{\r\nsnd_cs46xx_poke(chip, BA1_SPCR, 0);\r\n}\r\nstatic void snd_cs46xx_set_play_sample_rate(struct snd_cs46xx *chip, unsigned int rate)\r\n{\r\nunsigned long flags;\r\nunsigned int tmp1, tmp2;\r\nunsigned int phiIncr;\r\nunsigned int correctionPerGOF, correctionPerSec;\r\ntmp1 = rate << 16;\r\nphiIncr = tmp1 / 48000;\r\ntmp1 -= phiIncr * 48000;\r\ntmp1 <<= 10;\r\nphiIncr <<= 10;\r\ntmp2 = tmp1 / 48000;\r\nphiIncr += tmp2;\r\ntmp1 -= tmp2 * 48000;\r\ncorrectionPerGOF = tmp1 / GOF_PER_SEC;\r\ntmp1 -= correctionPerGOF * GOF_PER_SEC;\r\ncorrectionPerSec = tmp1;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nsnd_cs46xx_poke(chip, BA1_PSRC,\r\n((correctionPerSec << 16) & 0xFFFF0000) | (correctionPerGOF & 0xFFFF));\r\nsnd_cs46xx_poke(chip, BA1_PPI, phiIncr);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\n}\r\nstatic void snd_cs46xx_set_capture_sample_rate(struct snd_cs46xx *chip, unsigned int rate)\r\n{\r\nunsigned long flags;\r\nunsigned int phiIncr, coeffIncr, tmp1, tmp2;\r\nunsigned int correctionPerGOF, correctionPerSec, initialDelay;\r\nunsigned int frameGroupLength, cnt;\r\nif ((rate * 9) < 48000)\r\nrate = 48000 / 9;\r\nif (rate > 48000)\r\nrate = 48000;\r\ntmp1 = rate << 16;\r\ncoeffIncr = tmp1 / 48000;\r\ntmp1 -= coeffIncr * 48000;\r\ntmp1 <<= 7;\r\ncoeffIncr <<= 7;\r\ncoeffIncr += tmp1 / 48000;\r\ncoeffIncr ^= 0xFFFFFFFF;\r\ncoeffIncr++;\r\ntmp1 = 48000 << 16;\r\nphiIncr = tmp1 / rate;\r\ntmp1 -= phiIncr * rate;\r\ntmp1 <<= 10;\r\nphiIncr <<= 10;\r\ntmp2 = tmp1 / rate;\r\nphiIncr += tmp2;\r\ntmp1 -= tmp2 * rate;\r\ncorrectionPerGOF = tmp1 / GOF_PER_SEC;\r\ntmp1 -= correctionPerGOF * GOF_PER_SEC;\r\ncorrectionPerSec = tmp1;\r\ninitialDelay = ((48000 * 24) + rate - 1) / rate;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nsnd_cs46xx_poke(chip, BA1_CSRC,\r\n((correctionPerSec << 16) & 0xFFFF0000) | (correctionPerGOF & 0xFFFF));\r\nsnd_cs46xx_poke(chip, BA1_CCI, coeffIncr);\r\nsnd_cs46xx_poke(chip, BA1_CD,\r\n(((BA1_VARIDEC_BUF_1 + (initialDelay << 2)) << 16) & 0xFFFF0000) | 0x80);\r\nsnd_cs46xx_poke(chip, BA1_CPI, phiIncr);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nframeGroupLength = 1;\r\nfor (cnt = 2; cnt <= 64; cnt *= 2) {\r\nif (((rate / cnt) * cnt) != rate)\r\nframeGroupLength *= 2;\r\n}\r\nif (((rate / 3) * 3) != rate) {\r\nframeGroupLength *= 3;\r\n}\r\nfor (cnt = 5; cnt <= 125; cnt *= 5) {\r\nif (((rate / cnt) * cnt) != rate)\r\nframeGroupLength *= 5;\r\n}\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nsnd_cs46xx_poke(chip, BA1_CFG1, frameGroupLength);\r\nsnd_cs46xx_poke(chip, BA1_CFG2, (0x00800000 | frameGroupLength));\r\nsnd_cs46xx_poke(chip, BA1_CCST, 0x0000FFFF);\r\nsnd_cs46xx_poke(chip, BA1_CSPB, ((65536 * rate) / 24000));\r\nsnd_cs46xx_poke(chip, (BA1_CSPB + 4), 0x0000FFFF);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\n}\r\nstatic void snd_cs46xx_pb_trans_copy(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_indirect *rec, size_t bytes)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_cs46xx_pcm * cpcm = runtime->private_data;\r\nmemcpy(cpcm->hw_buf.area + rec->hw_data, runtime->dma_area + rec->sw_data, bytes);\r\n}\r\nstatic int snd_cs46xx_playback_transfer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_cs46xx_pcm * cpcm = runtime->private_data;\r\nsnd_pcm_indirect_playback_transfer(substream, &cpcm->pcm_rec, snd_cs46xx_pb_trans_copy);\r\nreturn 0;\r\n}\r\nstatic void snd_cs46xx_cp_trans_copy(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_indirect *rec, size_t bytes)\r\n{\r\nstruct snd_cs46xx *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nmemcpy(runtime->dma_area + rec->sw_data,\r\nchip->capt.hw_buf.area + rec->hw_data, bytes);\r\n}\r\nstatic int snd_cs46xx_capture_transfer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_cs46xx *chip = snd_pcm_substream_chip(substream);\r\nsnd_pcm_indirect_capture_transfer(substream, &chip->capt.pcm_rec, snd_cs46xx_cp_trans_copy);\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t snd_cs46xx_playback_direct_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_cs46xx *chip = snd_pcm_substream_chip(substream);\r\nsize_t ptr;\r\nstruct snd_cs46xx_pcm *cpcm = substream->runtime->private_data;\r\nif (snd_BUG_ON(!cpcm->pcm_channel))\r\nreturn -ENXIO;\r\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\r\nptr = snd_cs46xx_peek(chip, (cpcm->pcm_channel->pcm_reader_scb->address + 2) << 2);\r\n#else\r\nptr = snd_cs46xx_peek(chip, BA1_PBA);\r\n#endif\r\nptr -= cpcm->hw_buf.addr;\r\nreturn ptr >> cpcm->shift;\r\n}\r\nstatic snd_pcm_uframes_t snd_cs46xx_playback_indirect_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_cs46xx *chip = snd_pcm_substream_chip(substream);\r\nsize_t ptr;\r\nstruct snd_cs46xx_pcm *cpcm = substream->runtime->private_data;\r\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\r\nif (snd_BUG_ON(!cpcm->pcm_channel))\r\nreturn -ENXIO;\r\nptr = snd_cs46xx_peek(chip, (cpcm->pcm_channel->pcm_reader_scb->address + 2) << 2);\r\n#else\r\nptr = snd_cs46xx_peek(chip, BA1_PBA);\r\n#endif\r\nptr -= cpcm->hw_buf.addr;\r\nreturn snd_pcm_indirect_playback_pointer(substream, &cpcm->pcm_rec, ptr);\r\n}\r\nstatic snd_pcm_uframes_t snd_cs46xx_capture_direct_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_cs46xx *chip = snd_pcm_substream_chip(substream);\r\nsize_t ptr = snd_cs46xx_peek(chip, BA1_CBA) - chip->capt.hw_buf.addr;\r\nreturn ptr >> chip->capt.shift;\r\n}\r\nstatic snd_pcm_uframes_t snd_cs46xx_capture_indirect_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_cs46xx *chip = snd_pcm_substream_chip(substream);\r\nsize_t ptr = snd_cs46xx_peek(chip, BA1_CBA) - chip->capt.hw_buf.addr;\r\nreturn snd_pcm_indirect_capture_pointer(substream, &chip->capt.pcm_rec, ptr);\r\n}\r\nstatic int snd_cs46xx_playback_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct snd_cs46xx *chip = snd_pcm_substream_chip(substream);\r\nint result = 0;\r\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\r\nstruct snd_cs46xx_pcm *cpcm = substream->runtime->private_data;\r\nif (! cpcm->pcm_channel) {\r\nreturn -ENXIO;\r\n}\r\n#endif\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\r\nsnd_cs46xx_poke(chip, (cpcm->pcm_channel->pcm_reader_scb->address +\r\nSCBVolumeCtrl) << 2, 0x80008000);\r\nif (cpcm->pcm_channel->unlinked)\r\ncs46xx_dsp_pcm_link(chip,cpcm->pcm_channel);\r\nif (substream->runtime->periods != CS46XX_FRAGS)\r\nsnd_cs46xx_playback_transfer(substream);\r\n#else\r\nspin_lock(&chip->reg_lock);\r\nif (substream->runtime->periods != CS46XX_FRAGS)\r\nsnd_cs46xx_playback_transfer(substream);\r\n{ unsigned int tmp;\r\ntmp = snd_cs46xx_peek(chip, BA1_PCTL);\r\ntmp &= 0x0000ffff;\r\nsnd_cs46xx_poke(chip, BA1_PCTL, chip->play_ctl | tmp);\r\n}\r\nspin_unlock(&chip->reg_lock);\r\n#endif\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\r\nsnd_cs46xx_poke(chip, (cpcm->pcm_channel->pcm_reader_scb->address +\r\nSCBVolumeCtrl) << 2, 0xffffffff);\r\nif (!cpcm->pcm_channel->unlinked)\r\ncs46xx_dsp_pcm_unlink(chip,cpcm->pcm_channel);\r\n#else\r\nspin_lock(&chip->reg_lock);\r\n{ unsigned int tmp;\r\ntmp = snd_cs46xx_peek(chip, BA1_PCTL);\r\ntmp &= 0x0000ffff;\r\nsnd_cs46xx_poke(chip, BA1_PCTL, tmp);\r\n}\r\nspin_unlock(&chip->reg_lock);\r\n#endif\r\nbreak;\r\ndefault:\r\nresult = -EINVAL;\r\nbreak;\r\n}\r\nreturn result;\r\n}\r\nstatic int snd_cs46xx_capture_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct snd_cs46xx *chip = snd_pcm_substream_chip(substream);\r\nunsigned int tmp;\r\nint result = 0;\r\nspin_lock(&chip->reg_lock);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ntmp = snd_cs46xx_peek(chip, BA1_CCTL);\r\ntmp &= 0xffff0000;\r\nsnd_cs46xx_poke(chip, BA1_CCTL, chip->capt.ctl | tmp);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ntmp = snd_cs46xx_peek(chip, BA1_CCTL);\r\ntmp &= 0xffff0000;\r\nsnd_cs46xx_poke(chip, BA1_CCTL, tmp);\r\nbreak;\r\ndefault:\r\nresult = -EINVAL;\r\nbreak;\r\n}\r\nspin_unlock(&chip->reg_lock);\r\nreturn result;\r\n}\r\nstatic int _cs46xx_adjust_sample_rate (struct snd_cs46xx *chip, struct snd_cs46xx_pcm *cpcm,\r\nint sample_rate)\r\n{\r\nif ( cpcm->pcm_channel == NULL) {\r\ncpcm->pcm_channel = cs46xx_dsp_create_pcm_channel (chip, sample_rate,\r\ncpcm, cpcm->hw_buf.addr,cpcm->pcm_channel_id);\r\nif (cpcm->pcm_channel == NULL) {\r\ndev_err(chip->card->dev,\r\n"failed to create virtual PCM channel\n");\r\nreturn -ENOMEM;\r\n}\r\ncpcm->pcm_channel->sample_rate = sample_rate;\r\n} else\r\nif ((int)cpcm->pcm_channel->sample_rate != sample_rate) {\r\nint unlinked = cpcm->pcm_channel->unlinked;\r\ncs46xx_dsp_destroy_pcm_channel (chip,cpcm->pcm_channel);\r\nif ( (cpcm->pcm_channel = cs46xx_dsp_create_pcm_channel (chip, sample_rate, cpcm,\r\ncpcm->hw_buf.addr,\r\ncpcm->pcm_channel_id)) == NULL) {\r\ndev_err(chip->card->dev,\r\n"failed to re-create virtual PCM channel\n");\r\nreturn -ENOMEM;\r\n}\r\nif (!unlinked) cs46xx_dsp_pcm_link (chip,cpcm->pcm_channel);\r\ncpcm->pcm_channel->sample_rate = sample_rate;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_cs46xx_playback_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_cs46xx_pcm *cpcm;\r\nint err;\r\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\r\nstruct snd_cs46xx *chip = snd_pcm_substream_chip(substream);\r\nint sample_rate = params_rate(hw_params);\r\nint period_size = params_period_bytes(hw_params);\r\n#endif\r\ncpcm = runtime->private_data;\r\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\r\nif (snd_BUG_ON(!sample_rate))\r\nreturn -ENXIO;\r\nmutex_lock(&chip->spos_mutex);\r\nif (_cs46xx_adjust_sample_rate (chip,cpcm,sample_rate)) {\r\nmutex_unlock(&chip->spos_mutex);\r\nreturn -ENXIO;\r\n}\r\nsnd_BUG_ON(!cpcm->pcm_channel);\r\nif (!cpcm->pcm_channel) {\r\nmutex_unlock(&chip->spos_mutex);\r\nreturn -ENXIO;\r\n}\r\nif (cs46xx_dsp_pcm_channel_set_period (chip,cpcm->pcm_channel,period_size)) {\r\nmutex_unlock(&chip->spos_mutex);\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(chip->card->dev,\r\n"period_size (%d), periods (%d) buffer_size(%d)\n",\r\nperiod_size, params_periods(hw_params),\r\nparams_buffer_bytes(hw_params));\r\n#endif\r\nif (params_periods(hw_params) == CS46XX_FRAGS) {\r\nif (runtime->dma_area != cpcm->hw_buf.area)\r\nsnd_pcm_lib_free_pages(substream);\r\nruntime->dma_area = cpcm->hw_buf.area;\r\nruntime->dma_addr = cpcm->hw_buf.addr;\r\nruntime->dma_bytes = cpcm->hw_buf.bytes;\r\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\r\nif (cpcm->pcm_channel_id == DSP_PCM_MAIN_CHANNEL) {\r\nsubstream->ops = &snd_cs46xx_playback_ops;\r\n} else if (cpcm->pcm_channel_id == DSP_PCM_REAR_CHANNEL) {\r\nsubstream->ops = &snd_cs46xx_playback_rear_ops;\r\n} else if (cpcm->pcm_channel_id == DSP_PCM_CENTER_LFE_CHANNEL) {\r\nsubstream->ops = &snd_cs46xx_playback_clfe_ops;\r\n} else if (cpcm->pcm_channel_id == DSP_IEC958_CHANNEL) {\r\nsubstream->ops = &snd_cs46xx_playback_iec958_ops;\r\n} else {\r\nsnd_BUG();\r\n}\r\n#else\r\nsubstream->ops = &snd_cs46xx_playback_ops;\r\n#endif\r\n} else {\r\nif (runtime->dma_area == cpcm->hw_buf.area) {\r\nruntime->dma_area = NULL;\r\nruntime->dma_addr = 0;\r\nruntime->dma_bytes = 0;\r\n}\r\nif ((err = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params))) < 0) {\r\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\r\nmutex_unlock(&chip->spos_mutex);\r\n#endif\r\nreturn err;\r\n}\r\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\r\nif (cpcm->pcm_channel_id == DSP_PCM_MAIN_CHANNEL) {\r\nsubstream->ops = &snd_cs46xx_playback_indirect_ops;\r\n} else if (cpcm->pcm_channel_id == DSP_PCM_REAR_CHANNEL) {\r\nsubstream->ops = &snd_cs46xx_playback_indirect_rear_ops;\r\n} else if (cpcm->pcm_channel_id == DSP_PCM_CENTER_LFE_CHANNEL) {\r\nsubstream->ops = &snd_cs46xx_playback_indirect_clfe_ops;\r\n} else if (cpcm->pcm_channel_id == DSP_IEC958_CHANNEL) {\r\nsubstream->ops = &snd_cs46xx_playback_indirect_iec958_ops;\r\n} else {\r\nsnd_BUG();\r\n}\r\n#else\r\nsubstream->ops = &snd_cs46xx_playback_indirect_ops;\r\n#endif\r\n}\r\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\r\nmutex_unlock(&chip->spos_mutex);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int snd_cs46xx_playback_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_cs46xx_pcm *cpcm;\r\ncpcm = runtime->private_data;\r\nif (!cpcm) return -ENXIO;\r\nif (runtime->dma_area != cpcm->hw_buf.area)\r\nsnd_pcm_lib_free_pages(substream);\r\nruntime->dma_area = NULL;\r\nruntime->dma_addr = 0;\r\nruntime->dma_bytes = 0;\r\nreturn 0;\r\n}\r\nstatic int snd_cs46xx_playback_prepare(struct snd_pcm_substream *substream)\r\n{\r\nunsigned int tmp;\r\nunsigned int pfie;\r\nstruct snd_cs46xx *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_cs46xx_pcm *cpcm;\r\ncpcm = runtime->private_data;\r\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\r\nif (snd_BUG_ON(!cpcm->pcm_channel))\r\nreturn -ENXIO;\r\npfie = snd_cs46xx_peek(chip, (cpcm->pcm_channel->pcm_reader_scb->address + 1) << 2 );\r\npfie &= ~0x0000f03f;\r\n#else\r\npfie = snd_cs46xx_peek(chip, BA1_PFIE);\r\npfie &= ~0x0000f03f;\r\n#endif\r\ncpcm->shift = 2;\r\nif (runtime->channels == 1) {\r\ncpcm->shift--;\r\npfie |= 0x00002000;\r\n}\r\nif (snd_pcm_format_width(runtime->format) == 8) {\r\ncpcm->shift--;\r\npfie |= 0x00001000;\r\n}\r\nif (snd_pcm_format_unsigned(runtime->format))\r\npfie |= 0x00008000;\r\nif (snd_pcm_format_width(runtime->format) != 8) {\r\nif (snd_pcm_format_big_endian(runtime->format))\r\npfie |= 0x00004000;\r\n}\r\nmemset(&cpcm->pcm_rec, 0, sizeof(cpcm->pcm_rec));\r\ncpcm->pcm_rec.sw_buffer_size = snd_pcm_lib_buffer_bytes(substream);\r\ncpcm->pcm_rec.hw_buffer_size = runtime->period_size * CS46XX_FRAGS << cpcm->shift;\r\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\r\ntmp = snd_cs46xx_peek(chip, (cpcm->pcm_channel->pcm_reader_scb->address) << 2);\r\ntmp &= ~0x000003ff;\r\ntmp |= (4 << cpcm->shift) - 1;\r\nsnd_cs46xx_poke(chip, (cpcm->pcm_channel->pcm_reader_scb->address) << 2, tmp);\r\nsnd_cs46xx_poke(chip, (cpcm->pcm_channel->pcm_reader_scb->address + 1) << 2, pfie | cpcm->pcm_channel->pcm_slot);\r\n#else\r\nsnd_cs46xx_poke(chip, BA1_PBA, cpcm->hw_buf.addr);\r\ntmp = snd_cs46xx_peek(chip, BA1_PDTC);\r\ntmp &= ~0x000003ff;\r\ntmp |= (4 << cpcm->shift) - 1;\r\nsnd_cs46xx_poke(chip, BA1_PDTC, tmp);\r\nsnd_cs46xx_poke(chip, BA1_PFIE, pfie);\r\nsnd_cs46xx_set_play_sample_rate(chip, runtime->rate);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int snd_cs46xx_capture_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct snd_cs46xx *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err;\r\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\r\ncs46xx_dsp_pcm_ostream_set_period (chip, params_period_bytes(hw_params));\r\n#endif\r\nif (runtime->periods == CS46XX_FRAGS) {\r\nif (runtime->dma_area != chip->capt.hw_buf.area)\r\nsnd_pcm_lib_free_pages(substream);\r\nruntime->dma_area = chip->capt.hw_buf.area;\r\nruntime->dma_addr = chip->capt.hw_buf.addr;\r\nruntime->dma_bytes = chip->capt.hw_buf.bytes;\r\nsubstream->ops = &snd_cs46xx_capture_ops;\r\n} else {\r\nif (runtime->dma_area == chip->capt.hw_buf.area) {\r\nruntime->dma_area = NULL;\r\nruntime->dma_addr = 0;\r\nruntime->dma_bytes = 0;\r\n}\r\nif ((err = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params))) < 0)\r\nreturn err;\r\nsubstream->ops = &snd_cs46xx_capture_indirect_ops;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_cs46xx_capture_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_cs46xx *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nif (runtime->dma_area != chip->capt.hw_buf.area)\r\nsnd_pcm_lib_free_pages(substream);\r\nruntime->dma_area = NULL;\r\nruntime->dma_addr = 0;\r\nruntime->dma_bytes = 0;\r\nreturn 0;\r\n}\r\nstatic int snd_cs46xx_capture_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_cs46xx *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nsnd_cs46xx_poke(chip, BA1_CBA, chip->capt.hw_buf.addr);\r\nchip->capt.shift = 2;\r\nmemset(&chip->capt.pcm_rec, 0, sizeof(chip->capt.pcm_rec));\r\nchip->capt.pcm_rec.sw_buffer_size = snd_pcm_lib_buffer_bytes(substream);\r\nchip->capt.pcm_rec.hw_buffer_size = runtime->period_size * CS46XX_FRAGS << 2;\r\nsnd_cs46xx_set_capture_sample_rate(chip, runtime->rate);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t snd_cs46xx_interrupt(int irq, void *dev_id)\r\n{\r\nstruct snd_cs46xx *chip = dev_id;\r\nu32 status1;\r\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nu32 status2;\r\nint i;\r\nstruct snd_cs46xx_pcm *cpcm = NULL;\r\n#endif\r\nstatus1 = snd_cs46xx_peekBA0(chip, BA0_HISR);\r\nif ((status1 & 0x7fffffff) == 0) {\r\nsnd_cs46xx_pokeBA0(chip, BA0_HICR, HICR_CHGM | HICR_IEV);\r\nreturn IRQ_NONE;\r\n}\r\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\r\nstatus2 = snd_cs46xx_peekBA0(chip, BA0_HSR0);\r\nfor (i = 0; i < DSP_MAX_PCM_CHANNELS; ++i) {\r\nif (i <= 15) {\r\nif ( status1 & (1 << i) ) {\r\nif (i == CS46XX_DSP_CAPTURE_CHANNEL) {\r\nif (chip->capt.substream)\r\nsnd_pcm_period_elapsed(chip->capt.substream);\r\n} else {\r\nif (ins->pcm_channels[i].active &&\r\nins->pcm_channels[i].private_data &&\r\n!ins->pcm_channels[i].unlinked) {\r\ncpcm = ins->pcm_channels[i].private_data;\r\nsnd_pcm_period_elapsed(cpcm->substream);\r\n}\r\n}\r\n}\r\n} else {\r\nif ( status2 & (1 << (i - 16))) {\r\nif (ins->pcm_channels[i].active &&\r\nins->pcm_channels[i].private_data &&\r\n!ins->pcm_channels[i].unlinked) {\r\ncpcm = ins->pcm_channels[i].private_data;\r\nsnd_pcm_period_elapsed(cpcm->substream);\r\n}\r\n}\r\n}\r\n}\r\n#else\r\nif ((status1 & HISR_VC0) && chip->playback_pcm) {\r\nif (chip->playback_pcm->substream)\r\nsnd_pcm_period_elapsed(chip->playback_pcm->substream);\r\n}\r\nif ((status1 & HISR_VC1) && chip->pcm) {\r\nif (chip->capt.substream)\r\nsnd_pcm_period_elapsed(chip->capt.substream);\r\n}\r\n#endif\r\nif ((status1 & HISR_MIDI) && chip->rmidi) {\r\nunsigned char c;\r\nspin_lock(&chip->reg_lock);\r\nwhile ((snd_cs46xx_peekBA0(chip, BA0_MIDSR) & MIDSR_RBE) == 0) {\r\nc = snd_cs46xx_peekBA0(chip, BA0_MIDRP);\r\nif ((chip->midcr & MIDCR_RIE) == 0)\r\ncontinue;\r\nsnd_rawmidi_receive(chip->midi_input, &c, 1);\r\n}\r\nwhile ((snd_cs46xx_peekBA0(chip, BA0_MIDSR) & MIDSR_TBF) == 0) {\r\nif ((chip->midcr & MIDCR_TIE) == 0)\r\nbreak;\r\nif (snd_rawmidi_transmit(chip->midi_output, &c, 1) != 1) {\r\nchip->midcr &= ~MIDCR_TIE;\r\nsnd_cs46xx_pokeBA0(chip, BA0_MIDCR, chip->midcr);\r\nbreak;\r\n}\r\nsnd_cs46xx_pokeBA0(chip, BA0_MIDWP, c);\r\n}\r\nspin_unlock(&chip->reg_lock);\r\n}\r\nsnd_cs46xx_pokeBA0(chip, BA0_HICR, HICR_CHGM | HICR_IEV);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void snd_cs46xx_pcm_free_substream(struct snd_pcm_runtime *runtime)\r\n{\r\nkfree(runtime->private_data);\r\n}\r\nstatic int _cs46xx_playback_open_channel (struct snd_pcm_substream *substream,int pcm_channel_id)\r\n{\r\nstruct snd_cs46xx *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_cs46xx_pcm * cpcm;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\ncpcm = kzalloc(sizeof(*cpcm), GFP_KERNEL);\r\nif (cpcm == NULL)\r\nreturn -ENOMEM;\r\nif (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(chip->pci),\r\nPAGE_SIZE, &cpcm->hw_buf) < 0) {\r\nkfree(cpcm);\r\nreturn -ENOMEM;\r\n}\r\nruntime->hw = snd_cs46xx_playback;\r\nruntime->private_data = cpcm;\r\nruntime->private_free = snd_cs46xx_pcm_free_substream;\r\ncpcm->substream = substream;\r\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\r\nmutex_lock(&chip->spos_mutex);\r\ncpcm->pcm_channel = NULL;\r\ncpcm->pcm_channel_id = pcm_channel_id;\r\nsnd_pcm_hw_constraint_list(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_PERIOD_BYTES,\r\n&hw_constraints_period_sizes);\r\nmutex_unlock(&chip->spos_mutex);\r\n#else\r\nchip->playback_pcm = cpcm;\r\n#endif\r\nif (chip->accept_valid)\r\nsubstream->runtime->hw.info |= SNDRV_PCM_INFO_MMAP_VALID;\r\nchip->active_ctrl(chip, 1);\r\nreturn 0;\r\n}\r\nstatic int snd_cs46xx_playback_open(struct snd_pcm_substream *substream)\r\n{\r\ndev_dbg(substream->pcm->card->dev, "open front channel\n");\r\nreturn _cs46xx_playback_open_channel(substream,DSP_PCM_MAIN_CHANNEL);\r\n}\r\nstatic int snd_cs46xx_playback_open_rear(struct snd_pcm_substream *substream)\r\n{\r\ndev_dbg(substream->pcm->card->dev, "open rear channel\n");\r\nreturn _cs46xx_playback_open_channel(substream,DSP_PCM_REAR_CHANNEL);\r\n}\r\nstatic int snd_cs46xx_playback_open_clfe(struct snd_pcm_substream *substream)\r\n{\r\ndev_dbg(substream->pcm->card->dev, "open center - LFE channel\n");\r\nreturn _cs46xx_playback_open_channel(substream,DSP_PCM_CENTER_LFE_CHANNEL);\r\n}\r\nstatic int snd_cs46xx_playback_open_iec958(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_cs46xx *chip = snd_pcm_substream_chip(substream);\r\ndev_dbg(chip->card->dev, "open raw iec958 channel\n");\r\nmutex_lock(&chip->spos_mutex);\r\ncs46xx_iec958_pre_open (chip);\r\nmutex_unlock(&chip->spos_mutex);\r\nreturn _cs46xx_playback_open_channel(substream,DSP_IEC958_CHANNEL);\r\n}\r\nstatic int snd_cs46xx_playback_close_iec958(struct snd_pcm_substream *substream)\r\n{\r\nint err;\r\nstruct snd_cs46xx *chip = snd_pcm_substream_chip(substream);\r\ndev_dbg(chip->card->dev, "close raw iec958 channel\n");\r\nerr = snd_cs46xx_playback_close(substream);\r\nmutex_lock(&chip->spos_mutex);\r\ncs46xx_iec958_post_close (chip);\r\nmutex_unlock(&chip->spos_mutex);\r\nreturn err;\r\n}\r\nstatic int snd_cs46xx_capture_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_cs46xx *chip = snd_pcm_substream_chip(substream);\r\nif (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(chip->pci),\r\nPAGE_SIZE, &chip->capt.hw_buf) < 0)\r\nreturn -ENOMEM;\r\nchip->capt.substream = substream;\r\nsubstream->runtime->hw = snd_cs46xx_capture;\r\nif (chip->accept_valid)\r\nsubstream->runtime->hw.info |= SNDRV_PCM_INFO_MMAP_VALID;\r\nchip->active_ctrl(chip, 1);\r\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\r\nsnd_pcm_hw_constraint_list(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_PERIOD_BYTES,\r\n&hw_constraints_period_sizes);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int snd_cs46xx_playback_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_cs46xx *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_cs46xx_pcm * cpcm;\r\ncpcm = runtime->private_data;\r\nif (!cpcm) return -ENXIO;\r\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\r\nmutex_lock(&chip->spos_mutex);\r\nif (cpcm->pcm_channel) {\r\ncs46xx_dsp_destroy_pcm_channel(chip,cpcm->pcm_channel);\r\ncpcm->pcm_channel = NULL;\r\n}\r\nmutex_unlock(&chip->spos_mutex);\r\n#else\r\nchip->playback_pcm = NULL;\r\n#endif\r\ncpcm->substream = NULL;\r\nsnd_dma_free_pages(&cpcm->hw_buf);\r\nchip->active_ctrl(chip, -1);\r\nreturn 0;\r\n}\r\nstatic int snd_cs46xx_capture_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_cs46xx *chip = snd_pcm_substream_chip(substream);\r\nchip->capt.substream = NULL;\r\nsnd_dma_free_pages(&chip->capt.hw_buf);\r\nchip->active_ctrl(chip, -1);\r\nreturn 0;\r\n}\r\nint snd_cs46xx_pcm(struct snd_cs46xx *chip, int device)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nif ((err = snd_pcm_new(chip->card, "CS46xx", device, MAX_PLAYBACK_CHANNELS, 1, &pcm)) < 0)\r\nreturn err;\r\npcm->private_data = chip;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_cs46xx_playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_cs46xx_capture_ops);\r\npcm->info_flags = 0;\r\nstrcpy(pcm->name, "CS46xx");\r\nchip->pcm = pcm;\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(chip->pci), 64*1024, 256*1024);\r\nreturn 0;\r\n}\r\nint snd_cs46xx_pcm_rear(struct snd_cs46xx *chip, int device)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nif ((err = snd_pcm_new(chip->card, "CS46xx - Rear", device, MAX_PLAYBACK_CHANNELS, 0, &pcm)) < 0)\r\nreturn err;\r\npcm->private_data = chip;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_cs46xx_playback_rear_ops);\r\npcm->info_flags = 0;\r\nstrcpy(pcm->name, "CS46xx - Rear");\r\nchip->pcm_rear = pcm;\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(chip->pci), 64*1024, 256*1024);\r\nreturn 0;\r\n}\r\nint snd_cs46xx_pcm_center_lfe(struct snd_cs46xx *chip, int device)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nif ((err = snd_pcm_new(chip->card, "CS46xx - Center LFE", device, MAX_PLAYBACK_CHANNELS, 0, &pcm)) < 0)\r\nreturn err;\r\npcm->private_data = chip;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_cs46xx_playback_clfe_ops);\r\npcm->info_flags = 0;\r\nstrcpy(pcm->name, "CS46xx - Center LFE");\r\nchip->pcm_center_lfe = pcm;\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(chip->pci), 64*1024, 256*1024);\r\nreturn 0;\r\n}\r\nint snd_cs46xx_pcm_iec958(struct snd_cs46xx *chip, int device)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nif ((err = snd_pcm_new(chip->card, "CS46xx - IEC958", device, 1, 0, &pcm)) < 0)\r\nreturn err;\r\npcm->private_data = chip;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_cs46xx_playback_iec958_ops);\r\npcm->info_flags = 0;\r\nstrcpy(pcm->name, "CS46xx - IEC958");\r\nchip->pcm_rear = pcm;\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(chip->pci), 64*1024, 256*1024);\r\nreturn 0;\r\n}\r\nstatic void snd_cs46xx_mixer_free_ac97_bus(struct snd_ac97_bus *bus)\r\n{\r\nstruct snd_cs46xx *chip = bus->private_data;\r\nchip->ac97_bus = NULL;\r\n}\r\nstatic void snd_cs46xx_mixer_free_ac97(struct snd_ac97 *ac97)\r\n{\r\nstruct snd_cs46xx *chip = ac97->private_data;\r\nif (snd_BUG_ON(ac97 != chip->ac97[CS46XX_PRIMARY_CODEC_INDEX] &&\r\nac97 != chip->ac97[CS46XX_SECONDARY_CODEC_INDEX]))\r\nreturn;\r\nif (ac97 == chip->ac97[CS46XX_PRIMARY_CODEC_INDEX]) {\r\nchip->ac97[CS46XX_PRIMARY_CODEC_INDEX] = NULL;\r\nchip->eapd_switch = NULL;\r\n}\r\nelse\r\nchip->ac97[CS46XX_SECONDARY_CODEC_INDEX] = NULL;\r\n}\r\nstatic int snd_cs46xx_vol_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 0x7fff;\r\nreturn 0;\r\n}\r\nstatic int snd_cs46xx_vol_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_cs46xx *chip = snd_kcontrol_chip(kcontrol);\r\nint reg = kcontrol->private_value;\r\nunsigned int val = snd_cs46xx_peek(chip, reg);\r\nucontrol->value.integer.value[0] = 0xffff - (val >> 16);\r\nucontrol->value.integer.value[1] = 0xffff - (val & 0xffff);\r\nreturn 0;\r\n}\r\nstatic int snd_cs46xx_vol_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_cs46xx *chip = snd_kcontrol_chip(kcontrol);\r\nint reg = kcontrol->private_value;\r\nunsigned int val = ((0xffff - ucontrol->value.integer.value[0]) << 16 |\r\n(0xffff - ucontrol->value.integer.value[1]));\r\nunsigned int old = snd_cs46xx_peek(chip, reg);\r\nint change = (old != val);\r\nif (change) {\r\nsnd_cs46xx_poke(chip, reg, val);\r\n}\r\nreturn change;\r\n}\r\nstatic int snd_cs46xx_vol_dac_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_cs46xx *chip = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] = chip->dsp_spos_instance->dac_volume_left;\r\nucontrol->value.integer.value[1] = chip->dsp_spos_instance->dac_volume_right;\r\nreturn 0;\r\n}\r\nstatic int snd_cs46xx_vol_dac_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_cs46xx *chip = snd_kcontrol_chip(kcontrol);\r\nint change = 0;\r\nif (chip->dsp_spos_instance->dac_volume_right != ucontrol->value.integer.value[0] ||\r\nchip->dsp_spos_instance->dac_volume_left != ucontrol->value.integer.value[1]) {\r\ncs46xx_dsp_set_dac_volume(chip,\r\nucontrol->value.integer.value[0],\r\nucontrol->value.integer.value[1]);\r\nchange = 1;\r\n}\r\nreturn change;\r\n}\r\nstatic int snd_cs46xx_iec958_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_cs46xx *chip = snd_kcontrol_chip(kcontrol);\r\nint reg = kcontrol->private_value;\r\nif (reg == CS46XX_MIXER_SPDIF_OUTPUT_ELEMENT)\r\nucontrol->value.integer.value[0] = (chip->dsp_spos_instance->spdif_status_out & DSP_SPDIF_STATUS_OUTPUT_ENABLED);\r\nelse\r\nucontrol->value.integer.value[0] = chip->dsp_spos_instance->spdif_status_in;\r\nreturn 0;\r\n}\r\nstatic int snd_cs46xx_iec958_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_cs46xx *chip = snd_kcontrol_chip(kcontrol);\r\nint change, res;\r\nswitch (kcontrol->private_value) {\r\ncase CS46XX_MIXER_SPDIF_OUTPUT_ELEMENT:\r\nmutex_lock(&chip->spos_mutex);\r\nchange = (chip->dsp_spos_instance->spdif_status_out & DSP_SPDIF_STATUS_OUTPUT_ENABLED);\r\nif (ucontrol->value.integer.value[0] && !change)\r\ncs46xx_dsp_enable_spdif_out(chip);\r\nelse if (change && !ucontrol->value.integer.value[0])\r\ncs46xx_dsp_disable_spdif_out(chip);\r\nres = (change != (chip->dsp_spos_instance->spdif_status_out & DSP_SPDIF_STATUS_OUTPUT_ENABLED));\r\nmutex_unlock(&chip->spos_mutex);\r\nbreak;\r\ncase CS46XX_MIXER_SPDIF_INPUT_ELEMENT:\r\nchange = chip->dsp_spos_instance->spdif_status_in;\r\nif (ucontrol->value.integer.value[0] && !change) {\r\ncs46xx_dsp_enable_spdif_in(chip);\r\n}\r\nelse if (change && !ucontrol->value.integer.value[0])\r\ncs46xx_dsp_disable_spdif_in(chip);\r\nres = (change != chip->dsp_spos_instance->spdif_status_in);\r\nbreak;\r\ndefault:\r\nres = -EINVAL;\r\nsnd_BUG();\r\n}\r\nreturn res;\r\n}\r\nstatic int snd_cs46xx_adc_capture_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_cs46xx *chip = snd_kcontrol_chip(kcontrol);\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nif (ins->adc_input != NULL)\r\nucontrol->value.integer.value[0] = 1;\r\nelse\r\nucontrol->value.integer.value[0] = 0;\r\nreturn 0;\r\n}\r\nstatic int snd_cs46xx_adc_capture_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_cs46xx *chip = snd_kcontrol_chip(kcontrol);\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nint change = 0;\r\nif (ucontrol->value.integer.value[0] && !ins->adc_input) {\r\ncs46xx_dsp_enable_adc_capture(chip);\r\nchange = 1;\r\n} else if (!ucontrol->value.integer.value[0] && ins->adc_input) {\r\ncs46xx_dsp_disable_adc_capture(chip);\r\nchange = 1;\r\n}\r\nreturn change;\r\n}\r\nstatic int snd_cs46xx_pcm_capture_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_cs46xx *chip = snd_kcontrol_chip(kcontrol);\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nif (ins->pcm_input != NULL)\r\nucontrol->value.integer.value[0] = 1;\r\nelse\r\nucontrol->value.integer.value[0] = 0;\r\nreturn 0;\r\n}\r\nstatic int snd_cs46xx_pcm_capture_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_cs46xx *chip = snd_kcontrol_chip(kcontrol);\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nint change = 0;\r\nif (ucontrol->value.integer.value[0] && !ins->pcm_input) {\r\ncs46xx_dsp_enable_pcm_capture(chip);\r\nchange = 1;\r\n} else if (!ucontrol->value.integer.value[0] && ins->pcm_input) {\r\ncs46xx_dsp_disable_pcm_capture(chip);\r\nchange = 1;\r\n}\r\nreturn change;\r\n}\r\nstatic int snd_herc_spdif_select_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_cs46xx *chip = snd_kcontrol_chip(kcontrol);\r\nint val1 = snd_cs46xx_peekBA0(chip, BA0_EGPIODR);\r\nif (val1 & EGPIODR_GPOE0)\r\nucontrol->value.integer.value[0] = 1;\r\nelse\r\nucontrol->value.integer.value[0] = 0;\r\nreturn 0;\r\n}\r\nstatic int snd_herc_spdif_select_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_cs46xx *chip = snd_kcontrol_chip(kcontrol);\r\nint val1 = snd_cs46xx_peekBA0(chip, BA0_EGPIODR);\r\nint val2 = snd_cs46xx_peekBA0(chip, BA0_EGPIOPTR);\r\nif (ucontrol->value.integer.value[0]) {\r\nsnd_cs46xx_pokeBA0(chip, BA0_EGPIODR,\r\nEGPIODR_GPOE0 | val1);\r\nsnd_cs46xx_pokeBA0(chip, BA0_EGPIOPTR,\r\nEGPIOPTR_GPPT0 | val2);\r\n} else {\r\nsnd_cs46xx_pokeBA0(chip, BA0_EGPIODR, val1 & ~EGPIODR_GPOE0);\r\nsnd_cs46xx_pokeBA0(chip, BA0_EGPIOPTR, val2 & ~EGPIOPTR_GPPT0);\r\n}\r\nreturn (val1 != (int)snd_cs46xx_peekBA0(chip, BA0_EGPIODR));\r\n}\r\nstatic int snd_cs46xx_spdif_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_cs46xx_spdif_default_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_cs46xx *chip = snd_kcontrol_chip(kcontrol);\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nmutex_lock(&chip->spos_mutex);\r\nucontrol->value.iec958.status[0] = _wrap_all_bits((ins->spdif_csuv_default >> 24) & 0xff);\r\nucontrol->value.iec958.status[1] = _wrap_all_bits((ins->spdif_csuv_default >> 16) & 0xff);\r\nucontrol->value.iec958.status[2] = 0;\r\nucontrol->value.iec958.status[3] = _wrap_all_bits((ins->spdif_csuv_default) & 0xff);\r\nmutex_unlock(&chip->spos_mutex);\r\nreturn 0;\r\n}\r\nstatic int snd_cs46xx_spdif_default_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_cs46xx * chip = snd_kcontrol_chip(kcontrol);\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nunsigned int val;\r\nint change;\r\nmutex_lock(&chip->spos_mutex);\r\nval = ((unsigned int)_wrap_all_bits(ucontrol->value.iec958.status[0]) << 24) |\r\n((unsigned int)_wrap_all_bits(ucontrol->value.iec958.status[2]) << 16) |\r\n((unsigned int)_wrap_all_bits(ucontrol->value.iec958.status[3])) |\r\n(1 << 13) | (1 << 12);\r\nchange = (unsigned int)ins->spdif_csuv_default != val;\r\nins->spdif_csuv_default = val;\r\nif ( !(ins->spdif_status_out & DSP_SPDIF_STATUS_PLAYBACK_OPEN) )\r\ncs46xx_poke_via_dsp (chip,SP_SPDOUT_CSUV,val);\r\nmutex_unlock(&chip->spos_mutex);\r\nreturn change;\r\n}\r\nstatic int snd_cs46xx_spdif_mask_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nucontrol->value.iec958.status[0] = 0xff;\r\nucontrol->value.iec958.status[1] = 0xff;\r\nucontrol->value.iec958.status[2] = 0x00;\r\nucontrol->value.iec958.status[3] = 0xff;\r\nreturn 0;\r\n}\r\nstatic int snd_cs46xx_spdif_stream_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_cs46xx *chip = snd_kcontrol_chip(kcontrol);\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nmutex_lock(&chip->spos_mutex);\r\nucontrol->value.iec958.status[0] = _wrap_all_bits((ins->spdif_csuv_stream >> 24) & 0xff);\r\nucontrol->value.iec958.status[1] = _wrap_all_bits((ins->spdif_csuv_stream >> 16) & 0xff);\r\nucontrol->value.iec958.status[2] = 0;\r\nucontrol->value.iec958.status[3] = _wrap_all_bits((ins->spdif_csuv_stream) & 0xff);\r\nmutex_unlock(&chip->spos_mutex);\r\nreturn 0;\r\n}\r\nstatic int snd_cs46xx_spdif_stream_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_cs46xx * chip = snd_kcontrol_chip(kcontrol);\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nunsigned int val;\r\nint change;\r\nmutex_lock(&chip->spos_mutex);\r\nval = ((unsigned int)_wrap_all_bits(ucontrol->value.iec958.status[0]) << 24) |\r\n((unsigned int)_wrap_all_bits(ucontrol->value.iec958.status[1]) << 16) |\r\n((unsigned int)_wrap_all_bits(ucontrol->value.iec958.status[3])) |\r\n(1 << 13) | (1 << 12);\r\nchange = ins->spdif_csuv_stream != val;\r\nins->spdif_csuv_stream = val;\r\nif ( ins->spdif_status_out & DSP_SPDIF_STATUS_PLAYBACK_OPEN )\r\ncs46xx_poke_via_dsp (chip,SP_SPDOUT_CSUV,val);\r\nmutex_unlock(&chip->spos_mutex);\r\nreturn change;\r\n}\r\nstatic int snd_cs46xx_front_dup_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_cs46xx *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned short val;\r\nval = snd_ac97_read(chip->ac97[CS46XX_PRIMARY_CODEC_INDEX], AC97_CSR_ACMODE);\r\nucontrol->value.integer.value[0] = (val & 0x200) ? 0 : 1;\r\nreturn 0;\r\n}\r\nstatic int snd_cs46xx_front_dup_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_cs46xx *chip = snd_kcontrol_chip(kcontrol);\r\nreturn snd_ac97_update_bits(chip->ac97[CS46XX_PRIMARY_CODEC_INDEX],\r\nAC97_CSR_ACMODE, 0x200,\r\nucontrol->value.integer.value[0] ? 0 : 0x200);\r\n}\r\nstatic void snd_cs46xx_codec_reset (struct snd_ac97 * ac97)\r\n{\r\nunsigned long end_time;\r\nint err;\r\nsnd_ac97_write(ac97, AC97_RESET, 0);\r\nif (ac97->num == CS46XX_PRIMARY_CODEC_INDEX) {\r\ndev_dbg(ac97->bus->card->dev, "CODEC1 mode %04x\n", 0x0);\r\nsnd_cs46xx_ac97_write(ac97, AC97_CSR_ACMODE, 0x0);\r\n} else if (ac97->num == CS46XX_SECONDARY_CODEC_INDEX) {\r\ndev_dbg(ac97->bus->card->dev, "CODEC2 mode %04x\n", 0x3);\r\nsnd_cs46xx_ac97_write(ac97, AC97_CSR_ACMODE, 0x3);\r\n} else {\r\nsnd_BUG();\r\n}\r\nudelay(50);\r\nend_time = jiffies + HZ;\r\ndo {\r\nunsigned short ext_mid;\r\nsnd_ac97_read(ac97, AC97_RESET);\r\nsnd_ac97_read(ac97, AC97_VENDOR_ID1);\r\nsnd_ac97_read(ac97, AC97_VENDOR_ID2);\r\next_mid = snd_ac97_read(ac97, AC97_EXTENDED_MID);\r\nif (ext_mid != 0xffff && (ext_mid & 1) != 0)\r\nreturn;\r\nsnd_ac97_write(ac97, AC97_REC_GAIN, 0x8a05);\r\nif ((err = snd_ac97_read(ac97, AC97_REC_GAIN)) == 0x8a05)\r\nreturn;\r\nmsleep(10);\r\n} while (time_after_eq(end_time, jiffies));\r\ndev_err(ac97->bus->card->dev,\r\n"CS46xx secondary codec doesn't respond!\n");\r\n}\r\nstatic int cs46xx_detect_codec(struct snd_cs46xx *chip, int codec)\r\n{\r\nint idx, err;\r\nstruct snd_ac97_template ac97;\r\nmemset(&ac97, 0, sizeof(ac97));\r\nac97.private_data = chip;\r\nac97.private_free = snd_cs46xx_mixer_free_ac97;\r\nac97.num = codec;\r\nif (chip->amplifier_ctrl == amp_voyetra)\r\nac97.scaps = AC97_SCAP_INV_EAPD;\r\nif (codec == CS46XX_SECONDARY_CODEC_INDEX) {\r\nsnd_cs46xx_codec_write(chip, AC97_RESET, 0, codec);\r\nudelay(10);\r\nif (snd_cs46xx_codec_read(chip, AC97_RESET, codec) & 0x8000) {\r\ndev_dbg(chip->card->dev,\r\n"seconadry codec not present\n");\r\nreturn -ENXIO;\r\n}\r\n}\r\nsnd_cs46xx_codec_write(chip, AC97_MASTER, 0x8000, codec);\r\nfor (idx = 0; idx < 100; ++idx) {\r\nif (snd_cs46xx_codec_read(chip, AC97_MASTER, codec) == 0x8000) {\r\nerr = snd_ac97_mixer(chip->ac97_bus, &ac97, &chip->ac97[codec]);\r\nreturn err;\r\n}\r\nmsleep(10);\r\n}\r\ndev_dbg(chip->card->dev, "codec %d detection timeout\n", codec);\r\nreturn -ENXIO;\r\n}\r\nint snd_cs46xx_mixer(struct snd_cs46xx *chip, int spdif_device)\r\n{\r\nstruct snd_card *card = chip->card;\r\nstruct snd_ctl_elem_id id;\r\nint err;\r\nunsigned int idx;\r\nstatic struct snd_ac97_bus_ops ops = {\r\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\r\n.reset = snd_cs46xx_codec_reset,\r\n#endif\r\n.write = snd_cs46xx_ac97_write,\r\n.read = snd_cs46xx_ac97_read,\r\n};\r\nchip->nr_ac97_codecs = 0;\r\ndev_dbg(chip->card->dev, "detecting primary codec\n");\r\nif ((err = snd_ac97_bus(card, 0, &ops, chip, &chip->ac97_bus)) < 0)\r\nreturn err;\r\nchip->ac97_bus->private_free = snd_cs46xx_mixer_free_ac97_bus;\r\nif (cs46xx_detect_codec(chip, CS46XX_PRIMARY_CODEC_INDEX) < 0)\r\nreturn -ENXIO;\r\nchip->nr_ac97_codecs = 1;\r\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\r\ndev_dbg(chip->card->dev, "detecting seconadry codec\n");\r\nif (! cs46xx_detect_codec(chip, CS46XX_SECONDARY_CODEC_INDEX))\r\nchip->nr_ac97_codecs = 2;\r\n#endif\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_cs46xx_controls); idx++) {\r\nstruct snd_kcontrol *kctl;\r\nkctl = snd_ctl_new1(&snd_cs46xx_controls[idx], chip);\r\nif (kctl && kctl->id.iface == SNDRV_CTL_ELEM_IFACE_PCM)\r\nkctl->id.device = spdif_device;\r\nif ((err = snd_ctl_add(card, kctl)) < 0)\r\nreturn err;\r\n}\r\nmemset(&id, 0, sizeof(id));\r\nid.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nstrcpy(id.name, "External Amplifier");\r\nchip->eapd_switch = snd_ctl_find_id(chip->card, &id);\r\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\r\nif (chip->nr_ac97_codecs == 1) {\r\nunsigned int id2 = chip->ac97[CS46XX_PRIMARY_CODEC_INDEX]->id & 0xffff;\r\nif (id2 == 0x592b || id2 == 0x592d) {\r\nerr = snd_ctl_add(card, snd_ctl_new1(&snd_cs46xx_front_dup_ctl, chip));\r\nif (err < 0)\r\nreturn err;\r\nsnd_ac97_write_cache(chip->ac97[CS46XX_PRIMARY_CODEC_INDEX],\r\nAC97_CSR_ACMODE, 0x200);\r\n}\r\n}\r\nif (chip->mixer_init) {\r\ndev_dbg(chip->card->dev, "calling chip->mixer_init(chip);\n");\r\nchip->mixer_init(chip);\r\n}\r\n#endif\r\nchip->amplifier_ctrl(chip, 1);\r\nreturn 0;\r\n}\r\nstatic void snd_cs46xx_midi_reset(struct snd_cs46xx *chip)\r\n{\r\nsnd_cs46xx_pokeBA0(chip, BA0_MIDCR, MIDCR_MRST);\r\nudelay(100);\r\nsnd_cs46xx_pokeBA0(chip, BA0_MIDCR, chip->midcr);\r\n}\r\nstatic int snd_cs46xx_midi_input_open(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct snd_cs46xx *chip = substream->rmidi->private_data;\r\nchip->active_ctrl(chip, 1);\r\nspin_lock_irq(&chip->reg_lock);\r\nchip->uartm |= CS46XX_MODE_INPUT;\r\nchip->midcr |= MIDCR_RXE;\r\nchip->midi_input = substream;\r\nif (!(chip->uartm & CS46XX_MODE_OUTPUT)) {\r\nsnd_cs46xx_midi_reset(chip);\r\n} else {\r\nsnd_cs46xx_pokeBA0(chip, BA0_MIDCR, chip->midcr);\r\n}\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_cs46xx_midi_input_close(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct snd_cs46xx *chip = substream->rmidi->private_data;\r\nspin_lock_irq(&chip->reg_lock);\r\nchip->midcr &= ~(MIDCR_RXE | MIDCR_RIE);\r\nchip->midi_input = NULL;\r\nif (!(chip->uartm & CS46XX_MODE_OUTPUT)) {\r\nsnd_cs46xx_midi_reset(chip);\r\n} else {\r\nsnd_cs46xx_pokeBA0(chip, BA0_MIDCR, chip->midcr);\r\n}\r\nchip->uartm &= ~CS46XX_MODE_INPUT;\r\nspin_unlock_irq(&chip->reg_lock);\r\nchip->active_ctrl(chip, -1);\r\nreturn 0;\r\n}\r\nstatic int snd_cs46xx_midi_output_open(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct snd_cs46xx *chip = substream->rmidi->private_data;\r\nchip->active_ctrl(chip, 1);\r\nspin_lock_irq(&chip->reg_lock);\r\nchip->uartm |= CS46XX_MODE_OUTPUT;\r\nchip->midcr |= MIDCR_TXE;\r\nchip->midi_output = substream;\r\nif (!(chip->uartm & CS46XX_MODE_INPUT)) {\r\nsnd_cs46xx_midi_reset(chip);\r\n} else {\r\nsnd_cs46xx_pokeBA0(chip, BA0_MIDCR, chip->midcr);\r\n}\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_cs46xx_midi_output_close(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct snd_cs46xx *chip = substream->rmidi->private_data;\r\nspin_lock_irq(&chip->reg_lock);\r\nchip->midcr &= ~(MIDCR_TXE | MIDCR_TIE);\r\nchip->midi_output = NULL;\r\nif (!(chip->uartm & CS46XX_MODE_INPUT)) {\r\nsnd_cs46xx_midi_reset(chip);\r\n} else {\r\nsnd_cs46xx_pokeBA0(chip, BA0_MIDCR, chip->midcr);\r\n}\r\nchip->uartm &= ~CS46XX_MODE_OUTPUT;\r\nspin_unlock_irq(&chip->reg_lock);\r\nchip->active_ctrl(chip, -1);\r\nreturn 0;\r\n}\r\nstatic void snd_cs46xx_midi_input_trigger(struct snd_rawmidi_substream *substream, int up)\r\n{\r\nunsigned long flags;\r\nstruct snd_cs46xx *chip = substream->rmidi->private_data;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nif (up) {\r\nif ((chip->midcr & MIDCR_RIE) == 0) {\r\nchip->midcr |= MIDCR_RIE;\r\nsnd_cs46xx_pokeBA0(chip, BA0_MIDCR, chip->midcr);\r\n}\r\n} else {\r\nif (chip->midcr & MIDCR_RIE) {\r\nchip->midcr &= ~MIDCR_RIE;\r\nsnd_cs46xx_pokeBA0(chip, BA0_MIDCR, chip->midcr);\r\n}\r\n}\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\n}\r\nstatic void snd_cs46xx_midi_output_trigger(struct snd_rawmidi_substream *substream, int up)\r\n{\r\nunsigned long flags;\r\nstruct snd_cs46xx *chip = substream->rmidi->private_data;\r\nunsigned char byte;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nif (up) {\r\nif ((chip->midcr & MIDCR_TIE) == 0) {\r\nchip->midcr |= MIDCR_TIE;\r\nwhile ((chip->midcr & MIDCR_TIE) &&\r\n(snd_cs46xx_peekBA0(chip, BA0_MIDSR) & MIDSR_TBF) == 0) {\r\nif (snd_rawmidi_transmit(substream, &byte, 1) != 1) {\r\nchip->midcr &= ~MIDCR_TIE;\r\n} else {\r\nsnd_cs46xx_pokeBA0(chip, BA0_MIDWP, byte);\r\n}\r\n}\r\nsnd_cs46xx_pokeBA0(chip, BA0_MIDCR, chip->midcr);\r\n}\r\n} else {\r\nif (chip->midcr & MIDCR_TIE) {\r\nchip->midcr &= ~MIDCR_TIE;\r\nsnd_cs46xx_pokeBA0(chip, BA0_MIDCR, chip->midcr);\r\n}\r\n}\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\n}\r\nint snd_cs46xx_midi(struct snd_cs46xx *chip, int device)\r\n{\r\nstruct snd_rawmidi *rmidi;\r\nint err;\r\nif ((err = snd_rawmidi_new(chip->card, "CS46XX", device, 1, 1, &rmidi)) < 0)\r\nreturn err;\r\nstrcpy(rmidi->name, "CS46XX");\r\nsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &snd_cs46xx_midi_output);\r\nsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &snd_cs46xx_midi_input);\r\nrmidi->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT | SNDRV_RAWMIDI_INFO_INPUT | SNDRV_RAWMIDI_INFO_DUPLEX;\r\nrmidi->private_data = chip;\r\nchip->rmidi = rmidi;\r\nreturn 0;\r\n}\r\nstatic void snd_cs46xx_gameport_trigger(struct gameport *gameport)\r\n{\r\nstruct snd_cs46xx *chip = gameport_get_port_data(gameport);\r\nif (snd_BUG_ON(!chip))\r\nreturn;\r\nsnd_cs46xx_pokeBA0(chip, BA0_JSPT, 0xFF);\r\n}\r\nstatic unsigned char snd_cs46xx_gameport_read(struct gameport *gameport)\r\n{\r\nstruct snd_cs46xx *chip = gameport_get_port_data(gameport);\r\nif (snd_BUG_ON(!chip))\r\nreturn 0;\r\nreturn snd_cs46xx_peekBA0(chip, BA0_JSPT);\r\n}\r\nstatic int snd_cs46xx_gameport_cooked_read(struct gameport *gameport, int *axes, int *buttons)\r\n{\r\nstruct snd_cs46xx *chip = gameport_get_port_data(gameport);\r\nunsigned js1, js2, jst;\r\nif (snd_BUG_ON(!chip))\r\nreturn 0;\r\njs1 = snd_cs46xx_peekBA0(chip, BA0_JSC1);\r\njs2 = snd_cs46xx_peekBA0(chip, BA0_JSC2);\r\njst = snd_cs46xx_peekBA0(chip, BA0_JSPT);\r\n*buttons = (~jst >> 4) & 0x0F;\r\naxes[0] = ((js1 & JSC1_Y1V_MASK) >> JSC1_Y1V_SHIFT) & 0xFFFF;\r\naxes[1] = ((js1 & JSC1_X1V_MASK) >> JSC1_X1V_SHIFT) & 0xFFFF;\r\naxes[2] = ((js2 & JSC2_Y2V_MASK) >> JSC2_Y2V_SHIFT) & 0xFFFF;\r\naxes[3] = ((js2 & JSC2_X2V_MASK) >> JSC2_X2V_SHIFT) & 0xFFFF;\r\nfor(jst=0;jst<4;++jst)\r\nif(axes[jst]==0xFFFF) axes[jst] = -1;\r\nreturn 0;\r\n}\r\nstatic int snd_cs46xx_gameport_open(struct gameport *gameport, int mode)\r\n{\r\nswitch (mode) {\r\ncase GAMEPORT_MODE_COOKED:\r\nreturn 0;\r\ncase GAMEPORT_MODE_RAW:\r\nreturn 0;\r\ndefault:\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nint snd_cs46xx_gameport(struct snd_cs46xx *chip)\r\n{\r\nstruct gameport *gp;\r\nchip->gameport = gp = gameport_allocate_port();\r\nif (!gp) {\r\ndev_err(chip->card->dev,\r\n"cannot allocate memory for gameport\n");\r\nreturn -ENOMEM;\r\n}\r\ngameport_set_name(gp, "CS46xx Gameport");\r\ngameport_set_phys(gp, "pci%s/gameport0", pci_name(chip->pci));\r\ngameport_set_dev_parent(gp, &chip->pci->dev);\r\ngameport_set_port_data(gp, chip);\r\ngp->open = snd_cs46xx_gameport_open;\r\ngp->read = snd_cs46xx_gameport_read;\r\ngp->trigger = snd_cs46xx_gameport_trigger;\r\ngp->cooked_read = snd_cs46xx_gameport_cooked_read;\r\nsnd_cs46xx_pokeBA0(chip, BA0_JSIO, 0xFF);\r\nsnd_cs46xx_pokeBA0(chip, BA0_JSCTL, JSCTL_SP_MEDIUM_SLOW);\r\ngameport_register_port(gp);\r\nreturn 0;\r\n}\r\nstatic inline void snd_cs46xx_remove_gameport(struct snd_cs46xx *chip)\r\n{\r\nif (chip->gameport) {\r\ngameport_unregister_port(chip->gameport);\r\nchip->gameport = NULL;\r\n}\r\n}\r\nint snd_cs46xx_gameport(struct snd_cs46xx *chip) { return -ENOSYS; }\r\nstatic inline void snd_cs46xx_remove_gameport(struct snd_cs46xx *chip) { }\r\nstatic ssize_t snd_cs46xx_io_read(struct snd_info_entry *entry,\r\nvoid *file_private_data,\r\nstruct file *file, char __user *buf,\r\nsize_t count, loff_t pos)\r\n{\r\nstruct snd_cs46xx_region *region = entry->private_data;\r\nif (copy_to_user_fromio(buf, region->remap_addr + pos, count))\r\nreturn -EFAULT;\r\nreturn count;\r\n}\r\nstatic int snd_cs46xx_proc_init(struct snd_card *card, struct snd_cs46xx *chip)\r\n{\r\nstruct snd_info_entry *entry;\r\nint idx;\r\nfor (idx = 0; idx < 5; idx++) {\r\nstruct snd_cs46xx_region *region = &chip->region.idx[idx];\r\nif (! snd_card_proc_new(card, region->name, &entry)) {\r\nentry->content = SNDRV_INFO_CONTENT_DATA;\r\nentry->private_data = chip;\r\nentry->c.ops = &snd_cs46xx_proc_io_ops;\r\nentry->size = region->size;\r\nentry->mode = S_IFREG | S_IRUSR;\r\n}\r\n}\r\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\r\ncs46xx_dsp_proc_init(card, chip);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int snd_cs46xx_proc_done(struct snd_cs46xx *chip)\r\n{\r\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\r\ncs46xx_dsp_proc_done(chip);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void snd_cs46xx_hw_stop(struct snd_cs46xx *chip)\r\n{\r\nunsigned int tmp;\r\ntmp = snd_cs46xx_peek(chip, BA1_PFIE);\r\ntmp &= ~0x0000f03f;\r\ntmp |= 0x00000010;\r\nsnd_cs46xx_poke(chip, BA1_PFIE, tmp);\r\ntmp = snd_cs46xx_peek(chip, BA1_CIE);\r\ntmp &= ~0x0000003f;\r\ntmp |= 0x00000011;\r\nsnd_cs46xx_poke(chip, BA1_CIE, tmp);\r\ntmp = snd_cs46xx_peek(chip, BA1_PCTL);\r\nsnd_cs46xx_poke(chip, BA1_PCTL, tmp & 0x0000ffff);\r\ntmp = snd_cs46xx_peek(chip, BA1_CCTL);\r\nsnd_cs46xx_poke(chip, BA1_CCTL, tmp & 0xffff0000);\r\nsnd_cs46xx_reset(chip);\r\nsnd_cs46xx_proc_stop(chip);\r\nsnd_cs46xx_pokeBA0(chip, BA0_CLKCR1, 0);\r\ntmp = snd_cs46xx_peekBA0(chip, BA0_CLKCR1) & ~CLKCR1_SWCE;\r\nsnd_cs46xx_pokeBA0(chip, BA0_CLKCR1, tmp);\r\n}\r\nstatic int snd_cs46xx_free(struct snd_cs46xx *chip)\r\n{\r\nint idx;\r\nif (snd_BUG_ON(!chip))\r\nreturn -EINVAL;\r\nif (chip->active_ctrl)\r\nchip->active_ctrl(chip, 1);\r\nsnd_cs46xx_remove_gameport(chip);\r\nif (chip->amplifier_ctrl)\r\nchip->amplifier_ctrl(chip, -chip->amplifier);\r\nsnd_cs46xx_proc_done(chip);\r\nif (chip->region.idx[0].resource)\r\nsnd_cs46xx_hw_stop(chip);\r\nif (chip->irq >= 0)\r\nfree_irq(chip->irq, chip);\r\nif (chip->active_ctrl)\r\nchip->active_ctrl(chip, -chip->amplifier);\r\nfor (idx = 0; idx < 5; idx++) {\r\nstruct snd_cs46xx_region *region = &chip->region.idx[idx];\r\niounmap(region->remap_addr);\r\nrelease_and_free_resource(region->resource);\r\n}\r\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\r\nif (chip->dsp_spos_instance) {\r\ncs46xx_dsp_spos_destroy(chip);\r\nchip->dsp_spos_instance = NULL;\r\n}\r\nfor (idx = 0; idx < CS46XX_DSP_MODULES; idx++)\r\nfree_module_desc(chip->modules[idx]);\r\n#else\r\nvfree(chip->ba1);\r\n#endif\r\n#ifdef CONFIG_PM_SLEEP\r\nkfree(chip->saved_regs);\r\n#endif\r\npci_disable_device(chip->pci);\r\nkfree(chip);\r\nreturn 0;\r\n}\r\nstatic int snd_cs46xx_dev_free(struct snd_device *device)\r\n{\r\nstruct snd_cs46xx *chip = device->device_data;\r\nreturn snd_cs46xx_free(chip);\r\n}\r\nstatic int snd_cs46xx_chip_init(struct snd_cs46xx *chip)\r\n{\r\nint timeout;\r\nsnd_cs46xx_pokeBA0(chip, BA0_CLKCR1, 0);\r\nsnd_cs46xx_pokeBA0(chip, BA0_SERMC1, 0);\r\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\r\nsnd_cs46xx_pokeBA0(chip, BA0_SERACC, SERACC_HSP | SERACC_CHIP_TYPE_2_0 |\r\nSERACC_TWO_CODECS);\r\n#else\r\nsnd_cs46xx_pokeBA0(chip, BA0_SERACC, SERACC_HSP | SERACC_CHIP_TYPE_1_03);\r\n#endif\r\nsnd_cs46xx_pokeBA0(chip, BA0_ACCTL, 0);\r\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\r\nsnd_cs46xx_pokeBA0(chip, BA0_ACCTL2, 0);\r\n#endif\r\nudelay(50);\r\nsnd_cs46xx_pokeBA0(chip, BA0_ACCTL, ACCTL_RSTN);\r\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\r\nsnd_cs46xx_pokeBA0(chip, BA0_ACCTL2, ACCTL_RSTN);\r\n#endif\r\nsnd_cs46xx_pokeBA0(chip, BA0_ACCTL, ACCTL_ESYN | ACCTL_RSTN);\r\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\r\nsnd_cs46xx_pokeBA0(chip, BA0_ACCTL2, ACCTL_ESYN | ACCTL_RSTN);\r\n#endif\r\nmdelay(10);\r\nsnd_cs46xx_pokeBA0(chip, BA0_SERMC1, SERMC1_PTC_AC97);\r\nsnd_cs46xx_pokeBA0(chip, BA0_PLLCC, PLLCC_LPF_1050_2780_KHZ | PLLCC_CDR_73_104_MHZ);\r\nsnd_cs46xx_pokeBA0(chip, BA0_PLLM, 0x3a);\r\nsnd_cs46xx_pokeBA0(chip, BA0_CLKCR2, CLKCR2_PDIVS_8);\r\nsnd_cs46xx_pokeBA0(chip, BA0_CLKCR1, CLKCR1_PLLP);\r\nmsleep(100);\r\nsnd_cs46xx_pokeBA0(chip, BA0_CLKCR1, CLKCR1_PLLP | CLKCR1_SWCE);\r\nsnd_cs46xx_pokeBA0(chip, BA0_SERBCF, SERBCF_HBP);\r\nsnd_cs46xx_clear_serial_FIFOs(chip);\r\nsnd_cs46xx_pokeBA0(chip, BA0_SERC1, SERC1_SO1F_AC97 | SERC1_SO1EN);\r\nsnd_cs46xx_pokeBA0(chip, BA0_SERC2, SERC2_SI1F_AC97 | SERC1_SO1EN);\r\nsnd_cs46xx_pokeBA0(chip, BA0_SERMC1, SERMC1_PTC_AC97 | SERMC1_MSPE);\r\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\r\nsnd_cs46xx_pokeBA0(chip, BA0_SERC7, SERC7_ASDI2EN);\r\nsnd_cs46xx_pokeBA0(chip, BA0_SERC3, 0);\r\nsnd_cs46xx_pokeBA0(chip, BA0_SERC4, 0);\r\nsnd_cs46xx_pokeBA0(chip, BA0_SERC5, 0);\r\nsnd_cs46xx_pokeBA0(chip, BA0_SERC6, 1);\r\n#endif\r\nmdelay(5);\r\ntimeout = 150;\r\nwhile (timeout-- > 0) {\r\nif (snd_cs46xx_peekBA0(chip, BA0_ACSTS) & ACSTS_CRDY)\r\ngoto ok1;\r\nmsleep(10);\r\n}\r\ndev_err(chip->card->dev,\r\n"create - never read codec ready from AC'97\n");\r\ndev_err(chip->card->dev,\r\n"it is not probably bug, try to use CS4236 driver\n");\r\nreturn -EIO;\r\nok1:\r\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\r\n{\r\nint count;\r\nfor (count = 0; count < 150; count++) {\r\nudelay(25);\r\nif (snd_cs46xx_peekBA0(chip, BA0_ACSTS2) & ACSTS_CRDY)\r\nbreak;\r\n}\r\nif (!(snd_cs46xx_peekBA0(chip, BA0_ACSTS2) & ACSTS_CRDY))\r\ndev_dbg(chip->card->dev,\r\n"never read card ready from secondary AC'97\n");\r\n}\r\n#endif\r\nsnd_cs46xx_pokeBA0(chip, BA0_ACCTL, ACCTL_VFRM | ACCTL_ESYN | ACCTL_RSTN);\r\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\r\nsnd_cs46xx_pokeBA0(chip, BA0_ACCTL2, ACCTL_VFRM | ACCTL_ESYN | ACCTL_RSTN);\r\n#endif\r\ntimeout = 150;\r\nwhile (timeout-- > 0) {\r\nif ((snd_cs46xx_peekBA0(chip, BA0_ACISV) & (ACISV_ISV3 | ACISV_ISV4)) == (ACISV_ISV3 | ACISV_ISV4))\r\ngoto ok2;\r\nmsleep(10);\r\n}\r\n#ifndef CONFIG_SND_CS46XX_NEW_DSP\r\ndev_err(chip->card->dev,\r\n"create - never read ISV3 & ISV4 from AC'97\n");\r\nreturn -EIO;\r\n#else\r\ndev_err(chip->card->dev, "never read ISV3 & ISV4 from AC'97\n");\r\ndev_err(chip->card->dev,\r\n"Try reloading the ALSA driver, if you find something\n");\r\ndev_err(chip->card->dev,\r\n"broken or not working on your soundcard upon\n");\r\ndev_err(chip->card->dev,\r\n"this message please report to alsa-devel@alsa-project.org\n");\r\nreturn -EIO;\r\n#endif\r\nok2:\r\nsnd_cs46xx_pokeBA0(chip, BA0_ACOSV, ACOSV_SLV3 | ACOSV_SLV4);\r\nreturn 0;\r\n}\r\nstatic void cs46xx_enable_stream_irqs(struct snd_cs46xx *chip)\r\n{\r\nunsigned int tmp;\r\nsnd_cs46xx_pokeBA0(chip, BA0_HICR, HICR_IEV | HICR_CHGM);\r\ntmp = snd_cs46xx_peek(chip, BA1_PFIE);\r\ntmp &= ~0x0000f03f;\r\nsnd_cs46xx_poke(chip, BA1_PFIE, tmp);\r\ntmp = snd_cs46xx_peek(chip, BA1_CIE);\r\ntmp &= ~0x0000003f;\r\ntmp |= 0x00000001;\r\nsnd_cs46xx_poke(chip, BA1_CIE, tmp);\r\n}\r\nint snd_cs46xx_start_dsp(struct snd_cs46xx *chip)\r\n{\r\nunsigned int tmp;\r\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\r\nint i;\r\n#endif\r\nint err;\r\nsnd_cs46xx_reset(chip);\r\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\r\nfor (i = 0; i < CS46XX_DSP_MODULES; i++) {\r\nerr = load_firmware(chip, &chip->modules[i], module_names[i]);\r\nif (err < 0) {\r\ndev_err(chip->card->dev, "firmware load error [%s]\n",\r\nmodule_names[i]);\r\nreturn err;\r\n}\r\nerr = cs46xx_dsp_load_module(chip, chip->modules[i]);\r\nif (err < 0) {\r\ndev_err(chip->card->dev, "image download error [%s]\n",\r\nmodule_names[i]);\r\nreturn err;\r\n}\r\n}\r\nif (cs46xx_dsp_scb_and_task_init(chip) < 0)\r\nreturn -EIO;\r\n#else\r\nerr = load_firmware(chip);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_cs46xx_download_image(chip);\r\nif (err < 0) {\r\ndev_err(chip->card->dev, "image download error\n");\r\nreturn err;\r\n}\r\ntmp = snd_cs46xx_peek(chip, BA1_PCTL);\r\nchip->play_ctl = tmp & 0xffff0000;\r\nsnd_cs46xx_poke(chip, BA1_PCTL, tmp & 0x0000ffff);\r\n#endif\r\ntmp = snd_cs46xx_peek(chip, BA1_CCTL);\r\nchip->capt.ctl = tmp & 0x0000ffff;\r\nsnd_cs46xx_poke(chip, BA1_CCTL, tmp & 0xffff0000);\r\nmdelay(5);\r\nsnd_cs46xx_set_play_sample_rate(chip, 8000);\r\nsnd_cs46xx_set_capture_sample_rate(chip, 8000);\r\nsnd_cs46xx_proc_start(chip);\r\ncs46xx_enable_stream_irqs(chip);\r\n#ifndef CONFIG_SND_CS46XX_NEW_DSP\r\nsnd_cs46xx_poke(chip, BA1_PVOL, 0x80008000);\r\nsnd_cs46xx_poke(chip, BA1_CVOL, 0x80008000);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void amp_none(struct snd_cs46xx *chip, int change)\r\n{\r\n}\r\nstatic int voyetra_setup_eapd_slot(struct snd_cs46xx *chip)\r\n{\r\nu32 idx, valid_slots,tmp,powerdown = 0;\r\nu16 modem_power,pin_config,logic_type;\r\ndev_dbg(chip->card->dev, "cs46xx_setup_eapd_slot()+\n");\r\ntmp = snd_cs46xx_peekBA0(chip, BA0_CLKCR1);\r\nif (!(tmp & CLKCR1_SWCE)) {\r\nsnd_cs46xx_pokeBA0(chip, BA0_CLKCR1, tmp | CLKCR1_SWCE);\r\npowerdown = 1;\r\n}\r\nif(chip->nr_ac97_codecs != 2) {\r\ndev_err(chip->card->dev,\r\n"cs46xx_setup_eapd_slot() - no secondary codec configured\n");\r\nreturn -EINVAL;\r\n}\r\nmodem_power = snd_cs46xx_codec_read (chip,\r\nAC97_EXTENDED_MSTATUS,\r\nCS46XX_SECONDARY_CODEC_INDEX);\r\nmodem_power &=0xFEFF;\r\nsnd_cs46xx_codec_write(chip,\r\nAC97_EXTENDED_MSTATUS, modem_power,\r\nCS46XX_SECONDARY_CODEC_INDEX);\r\npin_config = snd_cs46xx_codec_read (chip,\r\nAC97_GPIO_CFG,\r\nCS46XX_SECONDARY_CODEC_INDEX);\r\npin_config &=0x27F;\r\nsnd_cs46xx_codec_write(chip,\r\nAC97_GPIO_CFG, pin_config,\r\nCS46XX_SECONDARY_CODEC_INDEX);\r\nlogic_type = snd_cs46xx_codec_read(chip, AC97_GPIO_POLARITY,\r\nCS46XX_SECONDARY_CODEC_INDEX);\r\nlogic_type &=0x27F;\r\nsnd_cs46xx_codec_write (chip, AC97_GPIO_POLARITY, logic_type,\r\nCS46XX_SECONDARY_CODEC_INDEX);\r\nvalid_slots = snd_cs46xx_peekBA0(chip, BA0_ACOSV);\r\nvalid_slots |= 0x200;\r\nsnd_cs46xx_pokeBA0(chip, BA0_ACOSV, valid_slots);\r\nif ( cs46xx_wait_for_fifo(chip,1) ) {\r\ndev_dbg(chip->card->dev, "FIFO is busy\n");\r\nreturn -EINVAL;\r\n}\r\nfor(idx = 0x90; idx <= 0x9F; idx++) {\r\nsnd_cs46xx_pokeBA0(chip, BA0_SERBWP, 0x1800);\r\nif ( cs46xx_wait_for_fifo(chip,200) ) {\r\ndev_dbg(chip->card->dev,\r\n"failed waiting for FIFO at addr (%02X)\n",\r\nidx);\r\nreturn -EINVAL;\r\n}\r\nsnd_cs46xx_pokeBA0(chip, BA0_SERBAD, idx);\r\nsnd_cs46xx_pokeBA0(chip, BA0_SERBCM, SERBCM_WRC);\r\n}\r\ncs46xx_wait_for_fifo(chip,200);\r\nif (powerdown)\r\nsnd_cs46xx_pokeBA0(chip, BA0_CLKCR1, tmp);\r\nreturn 0;\r\n}\r\nstatic void amp_voyetra(struct snd_cs46xx *chip, int change)\r\n{\r\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\r\nint old = chip->amplifier;\r\n#endif\r\nint oval, val;\r\nchip->amplifier += change;\r\noval = snd_cs46xx_codec_read(chip, AC97_POWERDOWN,\r\nCS46XX_PRIMARY_CODEC_INDEX);\r\nval = oval;\r\nif (chip->amplifier) {\r\nval |= 0x8000;\r\n} else {\r\nval &= ~0x8000;\r\n}\r\nif (val != oval) {\r\nsnd_cs46xx_codec_write(chip, AC97_POWERDOWN, val,\r\nCS46XX_PRIMARY_CODEC_INDEX);\r\nif (chip->eapd_switch)\r\nsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&chip->eapd_switch->id);\r\n}\r\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\r\nif (chip->amplifier && !old) {\r\nvoyetra_setup_eapd_slot(chip);\r\n}\r\n#endif\r\n}\r\nstatic void hercules_init(struct snd_cs46xx *chip)\r\n{\r\nsnd_cs46xx_pokeBA0(chip, BA0_EGPIODR, EGPIODR_GPOE0);\r\nsnd_cs46xx_pokeBA0(chip, BA0_EGPIOPTR, EGPIODR_GPOE0);\r\n}\r\nstatic void amp_hercules(struct snd_cs46xx *chip, int change)\r\n{\r\nint old = chip->amplifier;\r\nint val1 = snd_cs46xx_peekBA0(chip, BA0_EGPIODR);\r\nint val2 = snd_cs46xx_peekBA0(chip, BA0_EGPIOPTR);\r\nchip->amplifier += change;\r\nif (chip->amplifier && !old) {\r\ndev_dbg(chip->card->dev, "Hercules amplifier ON\n");\r\nsnd_cs46xx_pokeBA0(chip, BA0_EGPIODR,\r\nEGPIODR_GPOE2 | val1);\r\nsnd_cs46xx_pokeBA0(chip, BA0_EGPIOPTR,\r\nEGPIOPTR_GPPT2 | val2);\r\n} else if (old && !chip->amplifier) {\r\ndev_dbg(chip->card->dev, "Hercules amplifier OFF\n");\r\nsnd_cs46xx_pokeBA0(chip, BA0_EGPIODR, val1 & ~EGPIODR_GPOE2);\r\nsnd_cs46xx_pokeBA0(chip, BA0_EGPIOPTR, val2 & ~EGPIOPTR_GPPT2);\r\n}\r\n}\r\nstatic void voyetra_mixer_init (struct snd_cs46xx *chip)\r\n{\r\ndev_dbg(chip->card->dev, "initializing Voyetra mixer\n");\r\nsnd_cs46xx_pokeBA0(chip, BA0_EGPIODR, EGPIODR_GPOE0);\r\nsnd_cs46xx_pokeBA0(chip, BA0_EGPIOPTR, EGPIODR_GPOE0);\r\n}\r\nstatic void hercules_mixer_init (struct snd_cs46xx *chip)\r\n{\r\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\r\nunsigned int idx;\r\nint err;\r\nstruct snd_card *card = chip->card;\r\n#endif\r\nhercules_init(chip);\r\ndev_dbg(chip->card->dev, "initializing Hercules mixer\n");\r\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\r\nif (chip->in_suspend)\r\nreturn;\r\nfor (idx = 0 ; idx < ARRAY_SIZE(snd_hercules_controls); idx++) {\r\nstruct snd_kcontrol *kctl;\r\nkctl = snd_ctl_new1(&snd_hercules_controls[idx], chip);\r\nif ((err = snd_ctl_add(card, kctl)) < 0) {\r\ndev_err(card->dev,\r\n"failed to initialize Hercules mixer (%d)\n",\r\nerr);\r\nbreak;\r\n}\r\n}\r\n#endif\r\n}\r\nstatic void clkrun_hack(struct snd_cs46xx *chip, int change)\r\n{\r\nu16 control, nval;\r\nif (!chip->acpi_port)\r\nreturn;\r\nchip->amplifier += change;\r\nnval = control = inw(chip->acpi_port + 0x10);\r\nif (! chip->amplifier)\r\nnval |= 0x2000;\r\nelse\r\nnval &= ~0x2000;\r\nif (nval != control)\r\noutw(nval, chip->acpi_port + 0x10);\r\n}\r\nstatic void clkrun_init(struct snd_cs46xx *chip)\r\n{\r\nstruct pci_dev *pdev;\r\nu8 pp;\r\nchip->acpi_port = 0;\r\npdev = pci_get_device(PCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_82371AB_3, NULL);\r\nif (pdev == NULL)\r\nreturn;\r\npci_read_config_byte(pdev, 0x41, &pp);\r\nchip->acpi_port = pp << 8;\r\npci_dev_put(pdev);\r\n}\r\nstatic int snd_cs46xx_suspend(struct device *dev)\r\n{\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct snd_cs46xx *chip = card->private_data;\r\nint i, amp_saved;\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\r\nchip->in_suspend = 1;\r\nsnd_pcm_suspend_all(chip->pcm);\r\nsnd_ac97_suspend(chip->ac97[CS46XX_PRIMARY_CODEC_INDEX]);\r\nsnd_ac97_suspend(chip->ac97[CS46XX_SECONDARY_CODEC_INDEX]);\r\nfor (i = 0; i < ARRAY_SIZE(saved_regs); i++)\r\nchip->saved_regs[i] = snd_cs46xx_peekBA0(chip, saved_regs[i]);\r\namp_saved = chip->amplifier;\r\nchip->amplifier_ctrl(chip, -chip->amplifier);\r\nsnd_cs46xx_hw_stop(chip);\r\nchip->active_ctrl(chip, -chip->amplifier);\r\nchip->amplifier = amp_saved;\r\nreturn 0;\r\n}\r\nstatic int snd_cs46xx_resume(struct device *dev)\r\n{\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct snd_cs46xx *chip = card->private_data;\r\nint amp_saved;\r\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\r\nint i;\r\n#endif\r\nunsigned int tmp;\r\namp_saved = chip->amplifier;\r\nchip->amplifier = 0;\r\nchip->active_ctrl(chip, 1);\r\nsnd_cs46xx_chip_init(chip);\r\nsnd_cs46xx_reset(chip);\r\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\r\ncs46xx_dsp_resume(chip);\r\nfor (i = 0; i < ARRAY_SIZE(saved_regs); i++)\r\nsnd_cs46xx_pokeBA0(chip, saved_regs[i], chip->saved_regs[i]);\r\n#else\r\nsnd_cs46xx_download_image(chip);\r\n#endif\r\n#if 0\r\nsnd_cs46xx_codec_write(chip, BA0_AC97_GENERAL_PURPOSE,\r\nchip->ac97_general_purpose);\r\nsnd_cs46xx_codec_write(chip, AC97_POWER_CONTROL,\r\nchip->ac97_powerdown);\r\nmdelay(10);\r\nsnd_cs46xx_codec_write(chip, BA0_AC97_POWERDOWN,\r\nchip->ac97_powerdown);\r\nmdelay(5);\r\n#endif\r\nsnd_ac97_resume(chip->ac97[CS46XX_PRIMARY_CODEC_INDEX]);\r\nsnd_ac97_resume(chip->ac97[CS46XX_SECONDARY_CODEC_INDEX]);\r\ntmp = snd_cs46xx_peek(chip, BA1_CCTL);\r\nchip->capt.ctl = tmp & 0x0000ffff;\r\nsnd_cs46xx_poke(chip, BA1_CCTL, tmp & 0xffff0000);\r\nmdelay(5);\r\nsnd_cs46xx_set_play_sample_rate(chip, 8000);\r\nsnd_cs46xx_set_capture_sample_rate(chip, 8000);\r\nsnd_cs46xx_proc_start(chip);\r\ncs46xx_enable_stream_irqs(chip);\r\nif (amp_saved)\r\nchip->amplifier_ctrl(chip, 1);\r\nelse\r\nchip->active_ctrl(chip, -1);\r\nchip->amplifier = amp_saved;\r\nchip->in_suspend = 0;\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\r\nreturn 0;\r\n}\r\nint snd_cs46xx_create(struct snd_card *card,\r\nstruct pci_dev *pci,\r\nint external_amp, int thinkpad,\r\nstruct snd_cs46xx **rchip)\r\n{\r\nstruct snd_cs46xx *chip;\r\nint err, idx;\r\nstruct snd_cs46xx_region *region;\r\nstruct cs_card_type *cp;\r\nu16 ss_card, ss_vendor;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_cs46xx_dev_free,\r\n};\r\n*rchip = NULL;\r\nif ((err = pci_enable_device(pci)) < 0)\r\nreturn err;\r\nchip = kzalloc(sizeof(*chip), GFP_KERNEL);\r\nif (chip == NULL) {\r\npci_disable_device(pci);\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&chip->reg_lock);\r\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\r\nmutex_init(&chip->spos_mutex);\r\n#endif\r\nchip->card = card;\r\nchip->pci = pci;\r\nchip->irq = -1;\r\nchip->ba0_addr = pci_resource_start(pci, 0);\r\nchip->ba1_addr = pci_resource_start(pci, 1);\r\nif (chip->ba0_addr == 0 || chip->ba0_addr == (unsigned long)~0 ||\r\nchip->ba1_addr == 0 || chip->ba1_addr == (unsigned long)~0) {\r\ndev_err(chip->card->dev,\r\n"wrong address(es) - ba0 = 0x%lx, ba1 = 0x%lx\n",\r\nchip->ba0_addr, chip->ba1_addr);\r\nsnd_cs46xx_free(chip);\r\nreturn -ENOMEM;\r\n}\r\nregion = &chip->region.name.ba0;\r\nstrcpy(region->name, "CS46xx_BA0");\r\nregion->base = chip->ba0_addr;\r\nregion->size = CS46XX_BA0_SIZE;\r\nregion = &chip->region.name.data0;\r\nstrcpy(region->name, "CS46xx_BA1_data0");\r\nregion->base = chip->ba1_addr + BA1_SP_DMEM0;\r\nregion->size = CS46XX_BA1_DATA0_SIZE;\r\nregion = &chip->region.name.data1;\r\nstrcpy(region->name, "CS46xx_BA1_data1");\r\nregion->base = chip->ba1_addr + BA1_SP_DMEM1;\r\nregion->size = CS46XX_BA1_DATA1_SIZE;\r\nregion = &chip->region.name.pmem;\r\nstrcpy(region->name, "CS46xx_BA1_pmem");\r\nregion->base = chip->ba1_addr + BA1_SP_PMEM;\r\nregion->size = CS46XX_BA1_PRG_SIZE;\r\nregion = &chip->region.name.reg;\r\nstrcpy(region->name, "CS46xx_BA1_reg");\r\nregion->base = chip->ba1_addr + BA1_SP_REG;\r\nregion->size = CS46XX_BA1_REG_SIZE;\r\npci_read_config_word(pci, PCI_SUBSYSTEM_VENDOR_ID, &ss_vendor);\r\npci_read_config_word(pci, PCI_SUBSYSTEM_ID, &ss_card);\r\nfor (cp = &cards[0]; cp->name; cp++) {\r\nif (cp->vendor == ss_vendor && cp->id == ss_card) {\r\ndev_dbg(chip->card->dev, "hack for %s enabled\n",\r\ncp->name);\r\nchip->amplifier_ctrl = cp->amp;\r\nchip->active_ctrl = cp->active;\r\nchip->mixer_init = cp->mixer_init;\r\nif (cp->init)\r\ncp->init(chip);\r\nbreak;\r\n}\r\n}\r\nif (external_amp) {\r\ndev_info(chip->card->dev,\r\n"Crystal EAPD support forced on.\n");\r\nchip->amplifier_ctrl = amp_voyetra;\r\n}\r\nif (thinkpad) {\r\ndev_info(chip->card->dev,\r\n"Activating CLKRUN hack for Thinkpad.\n");\r\nchip->active_ctrl = clkrun_hack;\r\nclkrun_init(chip);\r\n}\r\nif (chip->amplifier_ctrl == NULL)\r\nchip->amplifier_ctrl = amp_none;\r\nif (chip->active_ctrl == NULL)\r\nchip->active_ctrl = amp_none;\r\nchip->active_ctrl(chip, 1);\r\npci_set_master(pci);\r\nfor (idx = 0; idx < 5; idx++) {\r\nregion = &chip->region.idx[idx];\r\nif ((region->resource = request_mem_region(region->base, region->size,\r\nregion->name)) == NULL) {\r\ndev_err(chip->card->dev,\r\n"unable to request memory region 0x%lx-0x%lx\n",\r\nregion->base, region->base + region->size - 1);\r\nsnd_cs46xx_free(chip);\r\nreturn -EBUSY;\r\n}\r\nregion->remap_addr = ioremap_nocache(region->base, region->size);\r\nif (region->remap_addr == NULL) {\r\ndev_err(chip->card->dev,\r\n"%s ioremap problem\n", region->name);\r\nsnd_cs46xx_free(chip);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nif (request_irq(pci->irq, snd_cs46xx_interrupt, IRQF_SHARED,\r\nKBUILD_MODNAME, chip)) {\r\ndev_err(chip->card->dev, "unable to grab IRQ %d\n", pci->irq);\r\nsnd_cs46xx_free(chip);\r\nreturn -EBUSY;\r\n}\r\nchip->irq = pci->irq;\r\n#ifdef CONFIG_SND_CS46XX_NEW_DSP\r\nchip->dsp_spos_instance = cs46xx_dsp_spos_create(chip);\r\nif (chip->dsp_spos_instance == NULL) {\r\nsnd_cs46xx_free(chip);\r\nreturn -ENOMEM;\r\n}\r\n#endif\r\nerr = snd_cs46xx_chip_init(chip);\r\nif (err < 0) {\r\nsnd_cs46xx_free(chip);\r\nreturn err;\r\n}\r\nif ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0) {\r\nsnd_cs46xx_free(chip);\r\nreturn err;\r\n}\r\nsnd_cs46xx_proc_init(card, chip);\r\n#ifdef CONFIG_PM_SLEEP\r\nchip->saved_regs = kmalloc(sizeof(*chip->saved_regs) *\r\nARRAY_SIZE(saved_regs), GFP_KERNEL);\r\nif (!chip->saved_regs) {\r\nsnd_cs46xx_free(chip);\r\nreturn -ENOMEM;\r\n}\r\n#endif\r\nchip->active_ctrl(chip, -1);\r\n*rchip = chip;\r\nreturn 0;\r\n}
