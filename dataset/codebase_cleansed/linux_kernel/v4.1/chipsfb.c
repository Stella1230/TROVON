static int chipsfb_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nif (var->xres > 800 || var->yres > 600\r\n|| var->xres_virtual > 800 || var->yres_virtual > 600\r\n|| (var->bits_per_pixel != 8 && var->bits_per_pixel != 16)\r\n|| var->nonstd\r\n|| (var->vmode & FB_VMODE_MASK) != FB_VMODE_NONINTERLACED)\r\nreturn -EINVAL;\r\nvar->xres = var->xres_virtual = 800;\r\nvar->yres = var->yres_virtual = 600;\r\nreturn 0;\r\n}\r\nstatic int chipsfb_set_par(struct fb_info *info)\r\n{\r\nif (info->var.bits_per_pixel == 16) {\r\nwrite_cr(0x13, 200);\r\nwrite_xr(0x81, 0x14);\r\nwrite_xr(0x82, 0x00);\r\nwrite_xr(0x20, 0x10);\r\ninfo->fix.line_length = 800*2;\r\ninfo->fix.visual = FB_VISUAL_TRUECOLOR;\r\ninfo->var.red.offset = 10;\r\ninfo->var.green.offset = 5;\r\ninfo->var.blue.offset = 0;\r\ninfo->var.red.length = info->var.green.length =\r\ninfo->var.blue.length = 5;\r\n} else {\r\nwrite_cr(0x13, 100);\r\nwrite_xr(0x81, 0x12);\r\nwrite_xr(0x82, 0x08);\r\nwrite_xr(0x20, 0x00);\r\ninfo->fix.line_length = 800;\r\ninfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\r\ninfo->var.red.offset = info->var.green.offset =\r\ninfo->var.blue.offset = 0;\r\ninfo->var.red.length = info->var.green.length =\r\ninfo->var.blue.length = 8;\r\n}\r\nreturn 0;\r\n}\r\nstatic int chipsfb_blank(int blank, struct fb_info *info)\r\n{\r\nreturn 1;\r\n}\r\nstatic int chipsfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\r\nu_int transp, struct fb_info *info)\r\n{\r\nif (regno > 255)\r\nreturn 1;\r\nred >>= 8;\r\ngreen >>= 8;\r\nblue >>= 8;\r\noutb(regno, 0x3c8);\r\nudelay(1);\r\noutb(red, 0x3c9);\r\noutb(green, 0x3c9);\r\noutb(blue, 0x3c9);\r\nreturn 0;\r\n}\r\nstatic void chips_hw_init(void)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(chips_init_xr); ++i)\r\nwrite_xr(chips_init_xr[i].addr, chips_init_xr[i].data);\r\noutb(0x29, 0x3c2);\r\nfor (i = 0; i < ARRAY_SIZE(chips_init_sr); ++i)\r\nwrite_sr(chips_init_sr[i].addr, chips_init_sr[i].data);\r\nfor (i = 0; i < ARRAY_SIZE(chips_init_gr); ++i)\r\nwrite_gr(chips_init_gr[i].addr, chips_init_gr[i].data);\r\nfor (i = 0; i < ARRAY_SIZE(chips_init_ar); ++i)\r\nwrite_ar(chips_init_ar[i].addr, chips_init_ar[i].data);\r\nfor (i = 0; i < ARRAY_SIZE(chips_init_cr); ++i)\r\nwrite_cr(chips_init_cr[i].addr, chips_init_cr[i].data);\r\nfor (i = 0; i < ARRAY_SIZE(chips_init_fr); ++i)\r\nwrite_fr(chips_init_fr[i].addr, chips_init_fr[i].data);\r\n}\r\nstatic void init_chips(struct fb_info *p, unsigned long addr)\r\n{\r\nmemset(p->screen_base, 0, 0x100000);\r\np->fix = chipsfb_fix;\r\np->fix.smem_start = addr;\r\np->var = chipsfb_var;\r\np->fbops = &chipsfb_ops;\r\np->flags = FBINFO_DEFAULT;\r\nfb_alloc_cmap(&p->cmap, 256, 0);\r\nchips_hw_init();\r\n}\r\nstatic int chipsfb_pci_init(struct pci_dev *dp, const struct pci_device_id *ent)\r\n{\r\nstruct fb_info *p;\r\nunsigned long addr, size;\r\nunsigned short cmd;\r\nint rc = -ENODEV;\r\nif (pci_enable_device(dp) < 0) {\r\ndev_err(&dp->dev, "Cannot enable PCI device\n");\r\ngoto err_out;\r\n}\r\nif ((dp->resource[0].flags & IORESOURCE_MEM) == 0)\r\ngoto err_disable;\r\naddr = pci_resource_start(dp, 0);\r\nsize = pci_resource_len(dp, 0);\r\nif (addr == 0)\r\ngoto err_disable;\r\np = framebuffer_alloc(0, &dp->dev);\r\nif (p == NULL) {\r\ndev_err(&dp->dev, "Cannot allocate framebuffer structure\n");\r\nrc = -ENOMEM;\r\ngoto err_disable;\r\n}\r\nif (pci_request_region(dp, 0, "chipsfb") != 0) {\r\ndev_err(&dp->dev, "Cannot request framebuffer\n");\r\nrc = -EBUSY;\r\ngoto err_release_fb;\r\n}\r\n#ifdef __BIG_ENDIAN\r\naddr += 0x800000;\r\n#endif\r\npci_read_config_word(dp, PCI_COMMAND, &cmd);\r\ncmd |= 3;\r\npci_write_config_word(dp, PCI_COMMAND, cmd);\r\n#ifdef CONFIG_PMAC_BACKLIGHT\r\nmutex_lock(&pmac_backlight_mutex);\r\nif (pmac_backlight) {\r\npmac_backlight->props.power = FB_BLANK_UNBLANK;\r\nbacklight_update_status(pmac_backlight);\r\n}\r\nmutex_unlock(&pmac_backlight_mutex);\r\n#endif\r\n#ifdef CONFIG_PPC\r\np->screen_base = __ioremap(addr, 0x200000, _PAGE_NO_CACHE);\r\n#else\r\np->screen_base = ioremap(addr, 0x200000);\r\n#endif\r\nif (p->screen_base == NULL) {\r\ndev_err(&dp->dev, "Cannot map framebuffer\n");\r\nrc = -ENOMEM;\r\ngoto err_release_pci;\r\n}\r\npci_set_drvdata(dp, p);\r\ninit_chips(p, addr);\r\nif (register_framebuffer(p) < 0) {\r\ndev_err(&dp->dev,"C&T 65550 framebuffer failed to register\n");\r\ngoto err_unmap;\r\n}\r\ndev_info(&dp->dev,"fb%d: Chips 65550 frame buffer"\r\n" (%dK RAM detected)\n",\r\np->node, p->fix.smem_len / 1024);\r\nreturn 0;\r\nerr_unmap:\r\niounmap(p->screen_base);\r\nerr_release_pci:\r\npci_release_region(dp, 0);\r\nerr_release_fb:\r\nframebuffer_release(p);\r\nerr_disable:\r\nerr_out:\r\nreturn rc;\r\n}\r\nstatic void chipsfb_remove(struct pci_dev *dp)\r\n{\r\nstruct fb_info *p = pci_get_drvdata(dp);\r\nif (p->screen_base == NULL)\r\nreturn;\r\nunregister_framebuffer(p);\r\niounmap(p->screen_base);\r\np->screen_base = NULL;\r\npci_release_region(dp, 0);\r\n}\r\nstatic int chipsfb_pci_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct fb_info *p = pci_get_drvdata(pdev);\r\nif (state.event == pdev->dev.power.power_state.event)\r\nreturn 0;\r\nif (!(state.event & PM_EVENT_SLEEP))\r\ngoto done;\r\nconsole_lock();\r\nchipsfb_blank(1, p);\r\nfb_set_suspend(p, 1);\r\nconsole_unlock();\r\ndone:\r\npdev->dev.power.power_state = state;\r\nreturn 0;\r\n}\r\nstatic int chipsfb_pci_resume(struct pci_dev *pdev)\r\n{\r\nstruct fb_info *p = pci_get_drvdata(pdev);\r\nconsole_lock();\r\nfb_set_suspend(p, 0);\r\nchipsfb_blank(0, p);\r\nconsole_unlock();\r\npdev->dev.power.power_state = PMSG_ON;\r\nreturn 0;\r\n}\r\nint __init chips_init(void)\r\n{\r\nif (fb_get_options("chipsfb", NULL))\r\nreturn -ENODEV;\r\nreturn pci_register_driver(&chipsfb_driver);\r\n}\r\nstatic void __exit chipsfb_exit(void)\r\n{\r\npci_unregister_driver(&chipsfb_driver);\r\n}
