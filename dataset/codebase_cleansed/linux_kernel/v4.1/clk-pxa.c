static unsigned long cken_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct pxa_clk *pclk = to_pxa_clk(hw);\r\nstruct clk_fixed_factor *fix;\r\nif (!pclk->is_in_low_power || pclk->is_in_low_power())\r\nfix = &pclk->lp;\r\nelse\r\nfix = &pclk->hp;\r\n__clk_hw_set_clk(&fix->hw, hw);\r\nreturn clk_fixed_factor_ops.recalc_rate(&fix->hw, parent_rate);\r\n}\r\nstatic u8 cken_get_parent(struct clk_hw *hw)\r\n{\r\nstruct pxa_clk *pclk = to_pxa_clk(hw);\r\nif (!pclk->is_in_low_power)\r\nreturn 0;\r\nreturn pclk->is_in_low_power() ? 0 : 1;\r\n}\r\nvoid __init clkdev_pxa_register(int ckid, const char *con_id,\r\nconst char *dev_id, struct clk *clk)\r\n{\r\nif (!IS_ERR(clk) && (ckid != CLK_NONE))\r\npxa_clocks[ckid] = clk;\r\nif (!IS_ERR(clk))\r\nclk_register_clkdev(clk, con_id, dev_id);\r\n}\r\nint __init clk_pxa_cken_init(const struct desc_clk_cken *clks, int nb_clks)\r\n{\r\nint i;\r\nstruct pxa_clk *pxa_clk;\r\nstruct clk *clk;\r\nfor (i = 0; i < nb_clks; i++) {\r\npxa_clk = kzalloc(sizeof(*pxa_clk), GFP_KERNEL);\r\npxa_clk->is_in_low_power = clks[i].is_in_low_power;\r\npxa_clk->lp = clks[i].lp;\r\npxa_clk->hp = clks[i].hp;\r\npxa_clk->gate = clks[i].gate;\r\npxa_clk->gate.lock = &lock;\r\nclk = clk_register_composite(NULL, clks[i].name,\r\nclks[i].parent_names, 2,\r\n&pxa_clk->hw, &cken_mux_ops,\r\n&pxa_clk->hw, &cken_rate_ops,\r\n&pxa_clk->gate.hw, &clk_gate_ops,\r\nclks[i].flags);\r\nclkdev_pxa_register(clks[i].ckid, clks[i].con_id,\r\nclks[i].dev_id, clk);\r\n}\r\nreturn 0;\r\n}\r\nvoid __init clk_pxa_dt_common_init(struct device_node *np)\r\n{\r\nof_clk_add_provider(np, of_clk_src_onecell_get, &onecell_data);\r\n}
