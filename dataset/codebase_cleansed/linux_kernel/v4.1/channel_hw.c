static void trace_write_gather(struct host1x_cdma *cdma, struct host1x_bo *bo,\r\nu32 offset, u32 words)\r\n{\r\nstruct device *dev = cdma_to_channel(cdma)->dev;\r\nvoid *mem = NULL;\r\nif (host1x_debug_trace_cmdbuf)\r\nmem = host1x_bo_mmap(bo);\r\nif (mem) {\r\nu32 i;\r\nfor (i = 0; i < words; i += TRACE_MAX_LENGTH) {\r\nu32 num_words = min(words - i, TRACE_MAX_LENGTH);\r\noffset += i * sizeof(u32);\r\ntrace_host1x_cdma_push_gather(dev_name(dev), bo,\r\nnum_words, offset,\r\nmem);\r\n}\r\nhost1x_bo_munmap(bo, mem);\r\n}\r\n}\r\nstatic void submit_gathers(struct host1x_job *job)\r\n{\r\nstruct host1x_cdma *cdma = &job->channel->cdma;\r\nunsigned int i;\r\nfor (i = 0; i < job->num_gathers; i++) {\r\nstruct host1x_job_gather *g = &job->gathers[i];\r\nu32 op1 = host1x_opcode_gather(g->words);\r\nu32 op2 = g->base + g->offset;\r\ntrace_write_gather(cdma, g->bo, g->offset, op1 & 0xffff);\r\nhost1x_cdma_push(cdma, op1, op2);\r\n}\r\n}\r\nstatic inline void synchronize_syncpt_base(struct host1x_job *job)\r\n{\r\nstruct host1x *host = dev_get_drvdata(job->channel->dev->parent);\r\nstruct host1x_syncpt *sp = host->syncpt + job->syncpt_id;\r\nu32 id, value;\r\nvalue = host1x_syncpt_read_max(sp);\r\nid = sp->base->id;\r\nhost1x_cdma_push(&job->channel->cdma,\r\nhost1x_opcode_setclass(HOST1X_CLASS_HOST1X,\r\nHOST1X_UCLASS_LOAD_SYNCPT_BASE, 1),\r\nHOST1X_UCLASS_LOAD_SYNCPT_BASE_BASE_INDX_F(id) |\r\nHOST1X_UCLASS_LOAD_SYNCPT_BASE_VALUE_F(value));\r\n}\r\nstatic int channel_submit(struct host1x_job *job)\r\n{\r\nstruct host1x_channel *ch = job->channel;\r\nstruct host1x_syncpt *sp;\r\nu32 user_syncpt_incrs = job->syncpt_incrs;\r\nu32 prev_max = 0;\r\nu32 syncval;\r\nint err;\r\nstruct host1x_waitlist *completed_waiter = NULL;\r\nstruct host1x *host = dev_get_drvdata(ch->dev->parent);\r\nsp = host->syncpt + job->syncpt_id;\r\ntrace_host1x_channel_submit(dev_name(ch->dev),\r\njob->num_gathers, job->num_relocs,\r\njob->num_waitchk, job->syncpt_id,\r\njob->syncpt_incrs);\r\nprev_max = job->syncpt_end = host1x_syncpt_read_max(sp);\r\nerr = mutex_lock_interruptible(&ch->submitlock);\r\nif (err)\r\ngoto error;\r\ncompleted_waiter = kzalloc(sizeof(*completed_waiter), GFP_KERNEL);\r\nif (!completed_waiter) {\r\nmutex_unlock(&ch->submitlock);\r\nerr = -ENOMEM;\r\ngoto error;\r\n}\r\nerr = host1x_cdma_begin(&ch->cdma, job);\r\nif (err) {\r\nmutex_unlock(&ch->submitlock);\r\ngoto error;\r\n}\r\nif (job->serialize) {\r\nhost1x_cdma_push(&ch->cdma,\r\nhost1x_opcode_setclass(HOST1X_CLASS_HOST1X,\r\nhost1x_uclass_wait_syncpt_r(), 1),\r\nhost1x_class_host_wait_syncpt(job->syncpt_id,\r\nhost1x_syncpt_read_max(sp)));\r\n}\r\nif (sp->base)\r\nsynchronize_syncpt_base(job);\r\nsyncval = host1x_syncpt_incr_max(sp, user_syncpt_incrs);\r\njob->syncpt_end = syncval;\r\nif (job->class)\r\nhost1x_cdma_push(&ch->cdma,\r\nhost1x_opcode_setclass(job->class, 0, 0),\r\nHOST1X_OPCODE_NOP);\r\nsubmit_gathers(job);\r\nhost1x_cdma_end(&ch->cdma, job);\r\ntrace_host1x_channel_submitted(dev_name(ch->dev), prev_max, syncval);\r\nerr = host1x_intr_add_action(host, job->syncpt_id, syncval,\r\nHOST1X_INTR_ACTION_SUBMIT_COMPLETE, ch,\r\ncompleted_waiter, NULL);\r\ncompleted_waiter = NULL;\r\nWARN(err, "Failed to set submit complete interrupt");\r\nmutex_unlock(&ch->submitlock);\r\nreturn 0;\r\nerror:\r\nkfree(completed_waiter);\r\nreturn err;\r\n}\r\nstatic int host1x_channel_init(struct host1x_channel *ch, struct host1x *dev,\r\nunsigned int index)\r\n{\r\nch->id = index;\r\nmutex_init(&ch->reflock);\r\nmutex_init(&ch->submitlock);\r\nch->regs = dev->regs + index * HOST1X_CHANNEL_SIZE;\r\nreturn 0;\r\n}
