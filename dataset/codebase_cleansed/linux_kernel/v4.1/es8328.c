static int es8328_set_deemph(struct snd_soc_codec *codec)\r\n{\r\nstruct es8328_priv *es8328 = snd_soc_codec_get_drvdata(codec);\r\nint val, i, best;\r\nif (es8328->deemph) {\r\nbest = 1;\r\nfor (i = 2; i < ARRAY_SIZE(deemph_settings); i++) {\r\nif (abs(deemph_settings[i] - es8328->playback_fs) <\r\nabs(deemph_settings[best] - es8328->playback_fs))\r\nbest = i;\r\n}\r\nval = best << 1;\r\n} else {\r\nval = 0;\r\n}\r\ndev_dbg(codec->dev, "Set deemphasis %d\n", val);\r\nreturn snd_soc_update_bits(codec, ES8328_DACCONTROL6, 0x6, val);\r\n}\r\nstatic int es8328_get_deemph(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct es8328_priv *es8328 = snd_soc_codec_get_drvdata(codec);\r\nucontrol->value.integer.value[0] = es8328->deemph;\r\nreturn 0;\r\n}\r\nstatic int es8328_put_deemph(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct es8328_priv *es8328 = snd_soc_codec_get_drvdata(codec);\r\nint deemph = ucontrol->value.integer.value[0];\r\nint ret;\r\nif (deemph > 1)\r\nreturn -EINVAL;\r\nret = es8328_set_deemph(codec);\r\nif (ret < 0)\r\nreturn ret;\r\nes8328->deemph = deemph;\r\nreturn 0;\r\n}\r\nstatic int es8328_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nreturn snd_soc_update_bits(dai->codec, ES8328_DACCONTROL3,\r\nES8328_DACCONTROL3_DACMUTE,\r\nmute ? ES8328_DACCONTROL3_DACMUTE : 0);\r\n}\r\nstatic int es8328_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct es8328_priv *es8328 = snd_soc_codec_get_drvdata(codec);\r\nint clk_rate;\r\nint i;\r\nint reg;\r\nu8 ratio;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nreg = ES8328_DACCONTROL2;\r\nelse\r\nreg = ES8328_ADCCONTROL5;\r\nclk_rate = clk_get_rate(es8328->clk);\r\nif ((clk_rate != ES8328_SYSCLK_RATE_1X) &&\r\n(clk_rate != ES8328_SYSCLK_RATE_2X)) {\r\ndev_err(codec->dev,\r\n"%s: clock is running at %d Hz, not %d or %d Hz\n",\r\n__func__, clk_rate,\r\nES8328_SYSCLK_RATE_1X, ES8328_SYSCLK_RATE_2X);\r\nreturn -EINVAL;\r\n}\r\nratio = mclk_ratios[0].rate;\r\nfor (i = 1; i < ARRAY_SIZE(mclk_ratios); i++)\r\nif (params_rate(params) <= mclk_ratios[i].rate)\r\nratio = mclk_ratios[i].ratio;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nes8328->playback_fs = params_rate(params);\r\nes8328_set_deemph(codec);\r\n}\r\nreturn snd_soc_update_bits(codec, reg, ES8328_RATEMASK, ratio);\r\n}\r\nstatic int es8328_set_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct es8328_priv *es8328 = snd_soc_codec_get_drvdata(codec);\r\nint clk_rate;\r\nu8 mode = ES8328_DACCONTROL1_DACWL_16;\r\nif ((fmt & SND_SOC_DAIFMT_MASTER_MASK) != SND_SOC_DAIFMT_CBM_CFM)\r\nreturn -EINVAL;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nmode |= ES8328_DACCONTROL1_DACFORMAT_I2S;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nmode |= ES8328_DACCONTROL1_DACFORMAT_RJUST;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nmode |= ES8328_DACCONTROL1_DACFORMAT_LJUST;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif ((fmt & SND_SOC_DAIFMT_INV_MASK) != SND_SOC_DAIFMT_NB_NF)\r\nreturn -EINVAL;\r\nsnd_soc_write(codec, ES8328_DACCONTROL1, mode);\r\nsnd_soc_write(codec, ES8328_ADCCONTROL4, mode);\r\nclk_rate = clk_get_rate(es8328->clk);\r\nif (clk_rate == ES8328_SYSCLK_RATE_1X)\r\nsnd_soc_write(codec, ES8328_MASTERMODE,\r\nES8328_MASTERMODE_MSC);\r\nelse\r\nsnd_soc_write(codec, ES8328_MASTERMODE,\r\nES8328_MASTERMODE_MCLKDIV2 |\r\nES8328_MASTERMODE_MSC);\r\nreturn 0;\r\n}\r\nstatic int es8328_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nsnd_soc_write(codec, ES8328_CHIPPOWER, 0);\r\nsnd_soc_update_bits(codec, ES8328_CONTROL1,\r\nES8328_CONTROL1_VMIDSEL_MASK |\r\nES8328_CONTROL1_ENREF,\r\nES8328_CONTROL1_VMIDSEL_50k |\r\nES8328_CONTROL1_ENREF);\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {\r\nsnd_soc_update_bits(codec, ES8328_CONTROL1,\r\nES8328_CONTROL1_VMIDSEL_MASK |\r\nES8328_CONTROL1_ENREF,\r\nES8328_CONTROL1_VMIDSEL_5k |\r\nES8328_CONTROL1_ENREF);\r\nmsleep(100);\r\n}\r\nsnd_soc_write(codec, ES8328_CONTROL2,\r\nES8328_CONTROL2_OVERCURRENT_ON |\r\nES8328_CONTROL2_THERMAL_SHUTDOWN_ON);\r\nsnd_soc_update_bits(codec, ES8328_CONTROL1,\r\nES8328_CONTROL1_VMIDSEL_MASK |\r\nES8328_CONTROL1_ENREF,\r\nES8328_CONTROL1_VMIDSEL_500k |\r\nES8328_CONTROL1_ENREF);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nsnd_soc_update_bits(codec, ES8328_CONTROL1,\r\nES8328_CONTROL1_VMIDSEL_MASK |\r\nES8328_CONTROL1_ENREF,\r\n0);\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int es8328_suspend(struct snd_soc_codec *codec)\r\n{\r\nstruct es8328_priv *es8328;\r\nint ret;\r\nes8328 = snd_soc_codec_get_drvdata(codec);\r\nclk_disable_unprepare(es8328->clk);\r\nret = regulator_bulk_disable(ARRAY_SIZE(es8328->supplies),\r\nes8328->supplies);\r\nif (ret) {\r\ndev_err(codec->dev, "unable to disable regulators\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int es8328_resume(struct snd_soc_codec *codec)\r\n{\r\nstruct regmap *regmap = dev_get_regmap(codec->dev, NULL);\r\nstruct es8328_priv *es8328;\r\nint ret;\r\nes8328 = snd_soc_codec_get_drvdata(codec);\r\nret = clk_prepare_enable(es8328->clk);\r\nif (ret) {\r\ndev_err(codec->dev, "unable to enable clock\n");\r\nreturn ret;\r\n}\r\nret = regulator_bulk_enable(ARRAY_SIZE(es8328->supplies),\r\nes8328->supplies);\r\nif (ret) {\r\ndev_err(codec->dev, "unable to enable regulators\n");\r\nreturn ret;\r\n}\r\nregcache_mark_dirty(regmap);\r\nret = regcache_sync(regmap);\r\nif (ret) {\r\ndev_err(codec->dev, "unable to sync regcache\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int es8328_codec_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct es8328_priv *es8328;\r\nint ret;\r\nes8328 = snd_soc_codec_get_drvdata(codec);\r\nret = regulator_bulk_enable(ARRAY_SIZE(es8328->supplies),\r\nes8328->supplies);\r\nif (ret) {\r\ndev_err(codec->dev, "unable to enable regulators\n");\r\nreturn ret;\r\n}\r\nes8328->clk = devm_clk_get(codec->dev, NULL);\r\nif (IS_ERR(es8328->clk)) {\r\ndev_err(codec->dev, "codec clock missing or invalid\n");\r\nret = PTR_ERR(es8328->clk);\r\ngoto clk_fail;\r\n}\r\nret = clk_prepare_enable(es8328->clk);\r\nif (ret) {\r\ndev_err(codec->dev, "unable to prepare codec clk\n");\r\ngoto clk_fail;\r\n}\r\nreturn 0;\r\nclk_fail:\r\nregulator_bulk_disable(ARRAY_SIZE(es8328->supplies),\r\nes8328->supplies);\r\nreturn ret;\r\n}\r\nstatic int es8328_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct es8328_priv *es8328;\r\nes8328 = snd_soc_codec_get_drvdata(codec);\r\nif (es8328->clk)\r\nclk_disable_unprepare(es8328->clk);\r\nregulator_bulk_disable(ARRAY_SIZE(es8328->supplies),\r\nes8328->supplies);\r\nreturn 0;\r\n}\r\nint es8328_probe(struct device *dev, struct regmap *regmap)\r\n{\r\nstruct es8328_priv *es8328;\r\nint ret;\r\nint i;\r\nif (IS_ERR(regmap))\r\nreturn PTR_ERR(regmap);\r\nes8328 = devm_kzalloc(dev, sizeof(*es8328), GFP_KERNEL);\r\nif (es8328 == NULL)\r\nreturn -ENOMEM;\r\nes8328->regmap = regmap;\r\nfor (i = 0; i < ARRAY_SIZE(es8328->supplies); i++)\r\nes8328->supplies[i].supply = supply_names[i];\r\nret = devm_regulator_bulk_get(dev, ARRAY_SIZE(es8328->supplies),\r\nes8328->supplies);\r\nif (ret) {\r\ndev_err(dev, "unable to get regulators\n");\r\nreturn ret;\r\n}\r\ndev_set_drvdata(dev, es8328);\r\nreturn snd_soc_register_codec(dev,\r\n&es8328_codec_driver, &es8328_dai, 1);\r\n}
