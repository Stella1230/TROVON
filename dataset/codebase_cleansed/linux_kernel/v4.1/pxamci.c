static inline void pxamci_init_ocr(struct pxamci_host *host)\r\n{\r\n#ifdef CONFIG_REGULATOR\r\nhost->vcc = regulator_get_optional(mmc_dev(host->mmc), "vmmc");\r\nif (IS_ERR(host->vcc))\r\nhost->vcc = NULL;\r\nelse {\r\nhost->mmc->ocr_avail = mmc_regulator_get_ocrmask(host->vcc);\r\nif (host->pdata && host->pdata->ocr_mask)\r\ndev_warn(mmc_dev(host->mmc),\r\n"ocr_mask/setpower will not be used\n");\r\n}\r\n#endif\r\nif (host->vcc == NULL) {\r\nhost->mmc->ocr_avail = host->pdata ?\r\nhost->pdata->ocr_mask :\r\nMMC_VDD_32_33 | MMC_VDD_33_34;\r\n}\r\n}\r\nstatic inline int pxamci_set_power(struct pxamci_host *host,\r\nunsigned char power_mode,\r\nunsigned int vdd)\r\n{\r\nint on;\r\nif (host->vcc) {\r\nint ret;\r\nif (power_mode == MMC_POWER_UP) {\r\nret = mmc_regulator_set_ocr(host->mmc, host->vcc, vdd);\r\nif (ret)\r\nreturn ret;\r\n} else if (power_mode == MMC_POWER_OFF) {\r\nret = mmc_regulator_set_ocr(host->mmc, host->vcc, 0);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\nif (!host->vcc && host->pdata &&\r\ngpio_is_valid(host->pdata->gpio_power)) {\r\non = ((1 << vdd) & host->pdata->ocr_mask);\r\ngpio_set_value(host->pdata->gpio_power,\r\n!!on ^ host->pdata->gpio_power_invert);\r\n}\r\nif (!host->vcc && host->pdata && host->pdata->setpower)\r\nreturn host->pdata->setpower(mmc_dev(host->mmc), vdd);\r\nreturn 0;\r\n}\r\nstatic void pxamci_stop_clock(struct pxamci_host *host)\r\n{\r\nif (readl(host->base + MMC_STAT) & STAT_CLK_EN) {\r\nunsigned long timeout = 10000;\r\nunsigned int v;\r\nwritel(STOP_CLOCK, host->base + MMC_STRPCL);\r\ndo {\r\nv = readl(host->base + MMC_STAT);\r\nif (!(v & STAT_CLK_EN))\r\nbreak;\r\nudelay(1);\r\n} while (timeout--);\r\nif (v & STAT_CLK_EN)\r\ndev_err(mmc_dev(host->mmc), "unable to stop clock\n");\r\n}\r\n}\r\nstatic void pxamci_enable_irq(struct pxamci_host *host, unsigned int mask)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&host->lock, flags);\r\nhost->imask &= ~mask;\r\nwritel(host->imask, host->base + MMC_I_MASK);\r\nspin_unlock_irqrestore(&host->lock, flags);\r\n}\r\nstatic void pxamci_disable_irq(struct pxamci_host *host, unsigned int mask)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&host->lock, flags);\r\nhost->imask |= mask;\r\nwritel(host->imask, host->base + MMC_I_MASK);\r\nspin_unlock_irqrestore(&host->lock, flags);\r\n}\r\nstatic void pxamci_setup_data(struct pxamci_host *host, struct mmc_data *data)\r\n{\r\nunsigned int nob = data->blocks;\r\nunsigned long long clks;\r\nunsigned int timeout;\r\nbool dalgn = 0;\r\nu32 dcmd;\r\nint i;\r\nhost->data = data;\r\nif (data->flags & MMC_DATA_STREAM)\r\nnob = 0xffff;\r\nwritel(nob, host->base + MMC_NOB);\r\nwritel(data->blksz, host->base + MMC_BLKLEN);\r\nclks = (unsigned long long)data->timeout_ns * host->clkrate;\r\ndo_div(clks, 1000000000UL);\r\ntimeout = (unsigned int)clks + (data->timeout_clks << host->clkrt);\r\nwritel((timeout + 255) / 256, host->base + MMC_RDTO);\r\nif (data->flags & MMC_DATA_READ) {\r\nhost->dma_dir = DMA_FROM_DEVICE;\r\ndcmd = DCMD_INCTRGADDR | DCMD_FLOWSRC;\r\nDRCMR(host->dma_drcmrtx) = 0;\r\nDRCMR(host->dma_drcmrrx) = host->dma | DRCMR_MAPVLD;\r\n} else {\r\nhost->dma_dir = DMA_TO_DEVICE;\r\ndcmd = DCMD_INCSRCADDR | DCMD_FLOWTRG;\r\nDRCMR(host->dma_drcmrrx) = 0;\r\nDRCMR(host->dma_drcmrtx) = host->dma | DRCMR_MAPVLD;\r\n}\r\ndcmd |= DCMD_BURST32 | DCMD_WIDTH1;\r\nhost->dma_len = dma_map_sg(mmc_dev(host->mmc), data->sg, data->sg_len,\r\nhost->dma_dir);\r\nfor (i = 0; i < host->dma_len; i++) {\r\nunsigned int length = sg_dma_len(&data->sg[i]);\r\nhost->sg_cpu[i].dcmd = dcmd | length;\r\nif (length & 31 && !(data->flags & MMC_DATA_READ))\r\nhost->sg_cpu[i].dcmd |= DCMD_ENDIRQEN;\r\nif (sg_dma_address(&data->sg[i]) & 0x7)\r\ndalgn = 1;\r\nif (data->flags & MMC_DATA_READ) {\r\nhost->sg_cpu[i].dsadr = host->res->start + MMC_RXFIFO;\r\nhost->sg_cpu[i].dtadr = sg_dma_address(&data->sg[i]);\r\n} else {\r\nhost->sg_cpu[i].dsadr = sg_dma_address(&data->sg[i]);\r\nhost->sg_cpu[i].dtadr = host->res->start + MMC_TXFIFO;\r\n}\r\nhost->sg_cpu[i].ddadr = host->sg_dma + (i + 1) *\r\nsizeof(struct pxa_dma_desc);\r\n}\r\nhost->sg_cpu[host->dma_len - 1].ddadr = DDADR_STOP;\r\nwmb();\r\nif (dalgn)\r\nDALGN |= (1 << host->dma);\r\nelse\r\nDALGN &= ~(1 << host->dma);\r\nDDADR(host->dma) = host->sg_dma;\r\nif (!cpu_is_pxa27x() || data->flags & MMC_DATA_READ)\r\nDCSR(host->dma) = DCSR_RUN;\r\n}\r\nstatic void pxamci_start_cmd(struct pxamci_host *host, struct mmc_command *cmd, unsigned int cmdat)\r\n{\r\nWARN_ON(host->cmd != NULL);\r\nhost->cmd = cmd;\r\nif (cmd->flags & MMC_RSP_BUSY)\r\ncmdat |= CMDAT_BUSY;\r\n#define RSP_TYPE(x) ((x) & ~(MMC_RSP_BUSY|MMC_RSP_OPCODE))\r\nswitch (RSP_TYPE(mmc_resp_type(cmd))) {\r\ncase RSP_TYPE(MMC_RSP_R1):\r\ncmdat |= CMDAT_RESP_SHORT;\r\nbreak;\r\ncase RSP_TYPE(MMC_RSP_R3):\r\ncmdat |= CMDAT_RESP_R3;\r\nbreak;\r\ncase RSP_TYPE(MMC_RSP_R2):\r\ncmdat |= CMDAT_RESP_R2;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nwritel(cmd->opcode, host->base + MMC_CMD);\r\nwritel(cmd->arg >> 16, host->base + MMC_ARGH);\r\nwritel(cmd->arg & 0xffff, host->base + MMC_ARGL);\r\nwritel(cmdat, host->base + MMC_CMDAT);\r\nwritel(host->clkrt, host->base + MMC_CLKRT);\r\nwritel(START_CLOCK, host->base + MMC_STRPCL);\r\npxamci_enable_irq(host, END_CMD_RES);\r\n}\r\nstatic void pxamci_finish_request(struct pxamci_host *host, struct mmc_request *mrq)\r\n{\r\nhost->mrq = NULL;\r\nhost->cmd = NULL;\r\nhost->data = NULL;\r\nmmc_request_done(host->mmc, mrq);\r\n}\r\nstatic int pxamci_cmd_done(struct pxamci_host *host, unsigned int stat)\r\n{\r\nstruct mmc_command *cmd = host->cmd;\r\nint i;\r\nu32 v;\r\nif (!cmd)\r\nreturn 0;\r\nhost->cmd = NULL;\r\nv = readl(host->base + MMC_RES) & 0xffff;\r\nfor (i = 0; i < 4; i++) {\r\nu32 w1 = readl(host->base + MMC_RES) & 0xffff;\r\nu32 w2 = readl(host->base + MMC_RES) & 0xffff;\r\ncmd->resp[i] = v << 24 | w1 << 8 | w2 >> 8;\r\nv = w2;\r\n}\r\nif (stat & STAT_TIME_OUT_RESPONSE) {\r\ncmd->error = -ETIMEDOUT;\r\n} else if (stat & STAT_RES_CRC_ERR && cmd->flags & MMC_RSP_CRC) {\r\nif (cpu_is_pxa27x() &&\r\n(cmd->flags & MMC_RSP_136 && cmd->resp[0] & 0x80000000))\r\npr_debug("ignoring CRC from command %d - *risky*\n", cmd->opcode);\r\nelse\r\ncmd->error = -EILSEQ;\r\n}\r\npxamci_disable_irq(host, END_CMD_RES);\r\nif (host->data && !cmd->error) {\r\npxamci_enable_irq(host, DATA_TRAN_DONE);\r\nif (cpu_is_pxa27x() && host->data->flags & MMC_DATA_WRITE)\r\nDCSR(host->dma) = DCSR_RUN;\r\n} else {\r\npxamci_finish_request(host, host->mrq);\r\n}\r\nreturn 1;\r\n}\r\nstatic int pxamci_data_done(struct pxamci_host *host, unsigned int stat)\r\n{\r\nstruct mmc_data *data = host->data;\r\nif (!data)\r\nreturn 0;\r\nDCSR(host->dma) = 0;\r\ndma_unmap_sg(mmc_dev(host->mmc), data->sg, data->sg_len,\r\nhost->dma_dir);\r\nif (stat & STAT_READ_TIME_OUT)\r\ndata->error = -ETIMEDOUT;\r\nelse if (stat & (STAT_CRC_READ_ERROR|STAT_CRC_WRITE_ERROR))\r\ndata->error = -EILSEQ;\r\nif (!data->error)\r\ndata->bytes_xfered = data->blocks * data->blksz;\r\nelse\r\ndata->bytes_xfered = 0;\r\npxamci_disable_irq(host, DATA_TRAN_DONE);\r\nhost->data = NULL;\r\nif (host->mrq->stop) {\r\npxamci_stop_clock(host);\r\npxamci_start_cmd(host, host->mrq->stop, host->cmdat);\r\n} else {\r\npxamci_finish_request(host, host->mrq);\r\n}\r\nreturn 1;\r\n}\r\nstatic irqreturn_t pxamci_irq(int irq, void *devid)\r\n{\r\nstruct pxamci_host *host = devid;\r\nunsigned int ireg;\r\nint handled = 0;\r\nireg = readl(host->base + MMC_I_REG) & ~readl(host->base + MMC_I_MASK);\r\nif (ireg) {\r\nunsigned stat = readl(host->base + MMC_STAT);\r\npr_debug("PXAMCI: irq %08x stat %08x\n", ireg, stat);\r\nif (ireg & END_CMD_RES)\r\nhandled |= pxamci_cmd_done(host, stat);\r\nif (ireg & DATA_TRAN_DONE)\r\nhandled |= pxamci_data_done(host, stat);\r\nif (ireg & SDIO_INT) {\r\nmmc_signal_sdio_irq(host->mmc);\r\nhandled = 1;\r\n}\r\n}\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void pxamci_request(struct mmc_host *mmc, struct mmc_request *mrq)\r\n{\r\nstruct pxamci_host *host = mmc_priv(mmc);\r\nunsigned int cmdat;\r\nWARN_ON(host->mrq != NULL);\r\nhost->mrq = mrq;\r\npxamci_stop_clock(host);\r\ncmdat = host->cmdat;\r\nhost->cmdat &= ~CMDAT_INIT;\r\nif (mrq->data) {\r\npxamci_setup_data(host, mrq->data);\r\ncmdat &= ~CMDAT_BUSY;\r\ncmdat |= CMDAT_DATAEN | CMDAT_DMAEN;\r\nif (mrq->data->flags & MMC_DATA_WRITE)\r\ncmdat |= CMDAT_WRITE;\r\nif (mrq->data->flags & MMC_DATA_STREAM)\r\ncmdat |= CMDAT_STREAM;\r\n}\r\npxamci_start_cmd(host, mrq->cmd, cmdat);\r\n}\r\nstatic int pxamci_get_ro(struct mmc_host *mmc)\r\n{\r\nstruct pxamci_host *host = mmc_priv(mmc);\r\nif (host->pdata && gpio_is_valid(host->pdata->gpio_card_ro)) {\r\nif (host->pdata->gpio_card_ro_invert)\r\nreturn !gpio_get_value(host->pdata->gpio_card_ro);\r\nelse\r\nreturn gpio_get_value(host->pdata->gpio_card_ro);\r\n}\r\nif (host->pdata && host->pdata->get_ro)\r\nreturn !!host->pdata->get_ro(mmc_dev(mmc));\r\nreturn -ENOSYS;\r\n}\r\nstatic void pxamci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\r\n{\r\nstruct pxamci_host *host = mmc_priv(mmc);\r\nif (ios->clock) {\r\nunsigned long rate = host->clkrate;\r\nunsigned int clk = rate / ios->clock;\r\nif (host->clkrt == CLKRT_OFF)\r\nclk_prepare_enable(host->clk);\r\nif (ios->clock == 26000000) {\r\nhost->clkrt = 7;\r\n} else {\r\nif (!clk)\r\nclk = 1;\r\nif (rate / clk > ios->clock)\r\nclk <<= 1;\r\nhost->clkrt = fls(clk) - 1;\r\n}\r\n} else {\r\npxamci_stop_clock(host);\r\nif (host->clkrt != CLKRT_OFF) {\r\nhost->clkrt = CLKRT_OFF;\r\nclk_disable_unprepare(host->clk);\r\n}\r\n}\r\nif (host->power_mode != ios->power_mode) {\r\nint ret;\r\nhost->power_mode = ios->power_mode;\r\nret = pxamci_set_power(host, ios->power_mode, ios->vdd);\r\nif (ret) {\r\ndev_err(mmc_dev(mmc), "unable to set power\n");\r\nreturn;\r\n}\r\nif (ios->power_mode == MMC_POWER_ON)\r\nhost->cmdat |= CMDAT_INIT;\r\n}\r\nif (ios->bus_width == MMC_BUS_WIDTH_4)\r\nhost->cmdat |= CMDAT_SD_4DAT;\r\nelse\r\nhost->cmdat &= ~CMDAT_SD_4DAT;\r\ndev_dbg(mmc_dev(mmc), "PXAMCI: clkrt = %x cmdat = %x\n",\r\nhost->clkrt, host->cmdat);\r\n}\r\nstatic void pxamci_enable_sdio_irq(struct mmc_host *host, int enable)\r\n{\r\nstruct pxamci_host *pxa_host = mmc_priv(host);\r\nif (enable)\r\npxamci_enable_irq(pxa_host, SDIO_INT);\r\nelse\r\npxamci_disable_irq(pxa_host, SDIO_INT);\r\n}\r\nstatic void pxamci_dma_irq(int dma, void *devid)\r\n{\r\nstruct pxamci_host *host = devid;\r\nint dcsr = DCSR(dma);\r\nDCSR(dma) = dcsr & ~DCSR_STOPIRQEN;\r\nif (dcsr & DCSR_ENDINTR) {\r\nwritel(BUF_PART_FULL, host->base + MMC_PRTBUF);\r\n} else {\r\npr_err("%s: DMA error on channel %d (DCSR=%#x)\n",\r\nmmc_hostname(host->mmc), dma, dcsr);\r\nhost->data->error = -EIO;\r\npxamci_data_done(host, 0);\r\n}\r\n}\r\nstatic irqreturn_t pxamci_detect_irq(int irq, void *devid)\r\n{\r\nstruct pxamci_host *host = mmc_priv(devid);\r\nmmc_detect_change(devid, msecs_to_jiffies(host->pdata->detect_delay_ms));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int pxamci_of_init(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct pxamci_platform_data *pdata;\r\nu32 tmp;\r\nif (!np)\r\nreturn 0;\r\npdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\npdata->gpio_card_detect =\r\nof_get_named_gpio(np, "cd-gpios", 0);\r\npdata->gpio_card_ro =\r\nof_get_named_gpio(np, "wp-gpios", 0);\r\npdata->gpio_power =\r\nof_get_named_gpio(np, "pxa-mmc,gpio-power", 0);\r\nif (of_property_read_u32(np, "pxa-mmc,detect-delay-ms", &tmp) == 0)\r\npdata->detect_delay_ms = tmp;\r\npdev->dev.platform_data = pdata;\r\nreturn 0;\r\n}\r\nstatic int pxamci_of_init(struct platform_device *pdev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int pxamci_probe(struct platform_device *pdev)\r\n{\r\nstruct mmc_host *mmc;\r\nstruct pxamci_host *host = NULL;\r\nstruct resource *r, *dmarx, *dmatx;\r\nint ret, irq, gpio_cd = -1, gpio_ro = -1, gpio_power = -1;\r\nret = pxamci_of_init(pdev);\r\nif (ret)\r\nreturn ret;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nirq = platform_get_irq(pdev, 0);\r\nif (!r || irq < 0)\r\nreturn -ENXIO;\r\nr = request_mem_region(r->start, SZ_4K, DRIVER_NAME);\r\nif (!r)\r\nreturn -EBUSY;\r\nmmc = mmc_alloc_host(sizeof(struct pxamci_host), &pdev->dev);\r\nif (!mmc) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nmmc->ops = &pxamci_ops;\r\nmmc->max_segs = NR_SG;\r\nmmc->max_seg_size = PAGE_SIZE;\r\nmmc->max_blk_size = cpu_is_pxa25x() ? 1023 : 2048;\r\nmmc->max_blk_count = 65535;\r\nhost = mmc_priv(mmc);\r\nhost->mmc = mmc;\r\nhost->dma = -1;\r\nhost->pdata = pdev->dev.platform_data;\r\nhost->clkrt = CLKRT_OFF;\r\nhost->clk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(host->clk)) {\r\nret = PTR_ERR(host->clk);\r\nhost->clk = NULL;\r\ngoto out;\r\n}\r\nhost->clkrate = clk_get_rate(host->clk);\r\nmmc->f_min = (host->clkrate + 63) / 64;\r\nmmc->f_max = (mmc_has_26MHz()) ? 26000000 : host->clkrate;\r\npxamci_init_ocr(host);\r\nmmc->caps = 0;\r\nhost->cmdat = 0;\r\nif (!cpu_is_pxa25x()) {\r\nmmc->caps |= MMC_CAP_4_BIT_DATA | MMC_CAP_SDIO_IRQ;\r\nhost->cmdat |= CMDAT_SDIO_INT_EN;\r\nif (mmc_has_26MHz())\r\nmmc->caps |= MMC_CAP_MMC_HIGHSPEED |\r\nMMC_CAP_SD_HIGHSPEED;\r\n}\r\nhost->sg_cpu = dma_alloc_coherent(&pdev->dev, PAGE_SIZE, &host->sg_dma, GFP_KERNEL);\r\nif (!host->sg_cpu) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nspin_lock_init(&host->lock);\r\nhost->res = r;\r\nhost->irq = irq;\r\nhost->imask = MMC_I_MASK_ALL;\r\nhost->base = ioremap(r->start, SZ_4K);\r\nif (!host->base) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\npxamci_stop_clock(host);\r\nwritel(0, host->base + MMC_SPI);\r\nwritel(64, host->base + MMC_RESTO);\r\nwritel(host->imask, host->base + MMC_I_MASK);\r\nhost->dma = pxa_request_dma(DRIVER_NAME, DMA_PRIO_LOW,\r\npxamci_dma_irq, host);\r\nif (host->dma < 0) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nret = request_irq(host->irq, pxamci_irq, 0, DRIVER_NAME, host);\r\nif (ret)\r\ngoto out;\r\nplatform_set_drvdata(pdev, mmc);\r\ndmarx = platform_get_resource(pdev, IORESOURCE_DMA, 0);\r\nif (!dmarx) {\r\nret = -ENXIO;\r\ngoto out;\r\n}\r\nhost->dma_drcmrrx = dmarx->start;\r\ndmatx = platform_get_resource(pdev, IORESOURCE_DMA, 1);\r\nif (!dmatx) {\r\nret = -ENXIO;\r\ngoto out;\r\n}\r\nhost->dma_drcmrtx = dmatx->start;\r\nif (host->pdata) {\r\ngpio_cd = host->pdata->gpio_card_detect;\r\ngpio_ro = host->pdata->gpio_card_ro;\r\ngpio_power = host->pdata->gpio_power;\r\n}\r\nif (gpio_is_valid(gpio_power)) {\r\nret = gpio_request(gpio_power, "mmc card power");\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed requesting gpio_power %d\n", gpio_power);\r\ngoto out;\r\n}\r\ngpio_direction_output(gpio_power,\r\nhost->pdata->gpio_power_invert);\r\n}\r\nif (gpio_is_valid(gpio_ro)) {\r\nret = gpio_request(gpio_ro, "mmc card read only");\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed requesting gpio_ro %d\n", gpio_ro);\r\ngoto err_gpio_ro;\r\n}\r\ngpio_direction_input(gpio_ro);\r\n}\r\nif (gpio_is_valid(gpio_cd)) {\r\nret = gpio_request(gpio_cd, "mmc card detect");\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed requesting gpio_cd %d\n", gpio_cd);\r\ngoto err_gpio_cd;\r\n}\r\ngpio_direction_input(gpio_cd);\r\nret = request_irq(gpio_to_irq(gpio_cd), pxamci_detect_irq,\r\nIRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,\r\n"mmc card detect", mmc);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to request card detect IRQ\n");\r\ngoto err_request_irq;\r\n}\r\n}\r\nif (host->pdata && host->pdata->init)\r\nhost->pdata->init(&pdev->dev, pxamci_detect_irq, mmc);\r\nif (gpio_is_valid(gpio_power) && host->pdata->setpower)\r\ndev_warn(&pdev->dev, "gpio_power and setpower() both defined\n");\r\nif (gpio_is_valid(gpio_ro) && host->pdata->get_ro)\r\ndev_warn(&pdev->dev, "gpio_ro and get_ro() both defined\n");\r\nmmc_add_host(mmc);\r\nreturn 0;\r\nerr_request_irq:\r\ngpio_free(gpio_cd);\r\nerr_gpio_cd:\r\ngpio_free(gpio_ro);\r\nerr_gpio_ro:\r\ngpio_free(gpio_power);\r\nout:\r\nif (host) {\r\nif (host->dma >= 0)\r\npxa_free_dma(host->dma);\r\nif (host->base)\r\niounmap(host->base);\r\nif (host->sg_cpu)\r\ndma_free_coherent(&pdev->dev, PAGE_SIZE, host->sg_cpu, host->sg_dma);\r\nif (host->clk)\r\nclk_put(host->clk);\r\n}\r\nif (mmc)\r\nmmc_free_host(mmc);\r\nrelease_resource(r);\r\nreturn ret;\r\n}\r\nstatic int pxamci_remove(struct platform_device *pdev)\r\n{\r\nstruct mmc_host *mmc = platform_get_drvdata(pdev);\r\nint gpio_cd = -1, gpio_ro = -1, gpio_power = -1;\r\nif (mmc) {\r\nstruct pxamci_host *host = mmc_priv(mmc);\r\nmmc_remove_host(mmc);\r\nif (host->pdata) {\r\ngpio_cd = host->pdata->gpio_card_detect;\r\ngpio_ro = host->pdata->gpio_card_ro;\r\ngpio_power = host->pdata->gpio_power;\r\n}\r\nif (gpio_is_valid(gpio_cd)) {\r\nfree_irq(gpio_to_irq(gpio_cd), mmc);\r\ngpio_free(gpio_cd);\r\n}\r\nif (gpio_is_valid(gpio_ro))\r\ngpio_free(gpio_ro);\r\nif (gpio_is_valid(gpio_power))\r\ngpio_free(gpio_power);\r\nif (host->vcc)\r\nregulator_put(host->vcc);\r\nif (host->pdata && host->pdata->exit)\r\nhost->pdata->exit(&pdev->dev, mmc);\r\npxamci_stop_clock(host);\r\nwritel(TXFIFO_WR_REQ|RXFIFO_RD_REQ|CLK_IS_OFF|STOP_CMD|\r\nEND_CMD_RES|PRG_DONE|DATA_TRAN_DONE,\r\nhost->base + MMC_I_MASK);\r\nDRCMR(host->dma_drcmrrx) = 0;\r\nDRCMR(host->dma_drcmrtx) = 0;\r\nfree_irq(host->irq, host);\r\npxa_free_dma(host->dma);\r\niounmap(host->base);\r\ndma_free_coherent(&pdev->dev, PAGE_SIZE, host->sg_cpu, host->sg_dma);\r\nclk_put(host->clk);\r\nrelease_resource(host->res);\r\nmmc_free_host(mmc);\r\n}\r\nreturn 0;\r\n}
