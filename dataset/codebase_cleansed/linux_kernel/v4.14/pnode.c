static inline struct mount *next_peer(struct mount *p)\r\n{\r\nreturn list_entry(p->mnt_share.next, struct mount, mnt_share);\r\n}\r\nstatic inline struct mount *first_slave(struct mount *p)\r\n{\r\nreturn list_entry(p->mnt_slave_list.next, struct mount, mnt_slave);\r\n}\r\nstatic inline struct mount *last_slave(struct mount *p)\r\n{\r\nreturn list_entry(p->mnt_slave_list.prev, struct mount, mnt_slave);\r\n}\r\nstatic inline struct mount *next_slave(struct mount *p)\r\n{\r\nreturn list_entry(p->mnt_slave.next, struct mount, mnt_slave);\r\n}\r\nstatic struct mount *get_peer_under_root(struct mount *mnt,\r\nstruct mnt_namespace *ns,\r\nconst struct path *root)\r\n{\r\nstruct mount *m = mnt;\r\ndo {\r\nif (m->mnt_ns == ns && is_path_reachable(m, m->mnt.mnt_root, root))\r\nreturn m;\r\nm = next_peer(m);\r\n} while (m != mnt);\r\nreturn NULL;\r\n}\r\nint get_dominating_id(struct mount *mnt, const struct path *root)\r\n{\r\nstruct mount *m;\r\nfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\r\nstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\r\nif (d)\r\nreturn d->mnt_group_id;\r\n}\r\nreturn 0;\r\n}\r\nstatic int do_make_slave(struct mount *mnt)\r\n{\r\nstruct mount *master, *slave_mnt;\r\nif (list_empty(&mnt->mnt_share)) {\r\nif (IS_MNT_SHARED(mnt)) {\r\nmnt_release_group_id(mnt);\r\nCLEAR_MNT_SHARED(mnt);\r\n}\r\nmaster = mnt->mnt_master;\r\nif (!master) {\r\nstruct list_head *p = &mnt->mnt_slave_list;\r\nwhile (!list_empty(p)) {\r\nslave_mnt = list_first_entry(p,\r\nstruct mount, mnt_slave);\r\nlist_del_init(&slave_mnt->mnt_slave);\r\nslave_mnt->mnt_master = NULL;\r\n}\r\nreturn 0;\r\n}\r\n} else {\r\nstruct mount *m;\r\nfor (m = master = next_peer(mnt); m != mnt; m = next_peer(m)) {\r\nif (m->mnt.mnt_root == mnt->mnt.mnt_root) {\r\nmaster = m;\r\nbreak;\r\n}\r\n}\r\nlist_del_init(&mnt->mnt_share);\r\nmnt->mnt_group_id = 0;\r\nCLEAR_MNT_SHARED(mnt);\r\n}\r\nlist_for_each_entry(slave_mnt, &mnt->mnt_slave_list, mnt_slave)\r\nslave_mnt->mnt_master = master;\r\nlist_move(&mnt->mnt_slave, &master->mnt_slave_list);\r\nlist_splice(&mnt->mnt_slave_list, master->mnt_slave_list.prev);\r\nINIT_LIST_HEAD(&mnt->mnt_slave_list);\r\nmnt->mnt_master = master;\r\nreturn 0;\r\n}\r\nvoid change_mnt_propagation(struct mount *mnt, int type)\r\n{\r\nif (type == MS_SHARED) {\r\nset_mnt_shared(mnt);\r\nreturn;\r\n}\r\ndo_make_slave(mnt);\r\nif (type != MS_SLAVE) {\r\nlist_del_init(&mnt->mnt_slave);\r\nmnt->mnt_master = NULL;\r\nif (type == MS_UNBINDABLE)\r\nmnt->mnt.mnt_flags |= MNT_UNBINDABLE;\r\nelse\r\nmnt->mnt.mnt_flags &= ~MNT_UNBINDABLE;\r\n}\r\n}\r\nstatic struct mount *propagation_next(struct mount *m,\r\nstruct mount *origin)\r\n{\r\nif (!IS_MNT_NEW(m) && !list_empty(&m->mnt_slave_list))\r\nreturn first_slave(m);\r\nwhile (1) {\r\nstruct mount *master = m->mnt_master;\r\nif (master == origin->mnt_master) {\r\nstruct mount *next = next_peer(m);\r\nreturn (next == origin) ? NULL : next;\r\n} else if (m->mnt_slave.next != &master->mnt_slave_list)\r\nreturn next_slave(m);\r\nm = master;\r\n}\r\n}\r\nstatic struct mount *skip_propagation_subtree(struct mount *m,\r\nstruct mount *origin)\r\n{\r\nif (!IS_MNT_NEW(m) && !list_empty(&m->mnt_slave_list))\r\nm = last_slave(m);\r\nreturn m;\r\n}\r\nstatic struct mount *next_group(struct mount *m, struct mount *origin)\r\n{\r\nwhile (1) {\r\nwhile (1) {\r\nstruct mount *next;\r\nif (!IS_MNT_NEW(m) && !list_empty(&m->mnt_slave_list))\r\nreturn first_slave(m);\r\nnext = next_peer(m);\r\nif (m->mnt_group_id == origin->mnt_group_id) {\r\nif (next == origin)\r\nreturn NULL;\r\n} else if (m->mnt_slave.next != &next->mnt_slave)\r\nbreak;\r\nm = next;\r\n}\r\nwhile (1) {\r\nstruct mount *master = m->mnt_master;\r\nif (m->mnt_slave.next != &master->mnt_slave_list)\r\nreturn next_slave(m);\r\nm = next_peer(master);\r\nif (master->mnt_group_id == origin->mnt_group_id)\r\nbreak;\r\nif (master->mnt_slave.next == &m->mnt_slave)\r\nbreak;\r\nm = master;\r\n}\r\nif (m == origin)\r\nreturn NULL;\r\n}\r\n}\r\nstatic inline bool peers(struct mount *m1, struct mount *m2)\r\n{\r\nreturn m1->mnt_group_id == m2->mnt_group_id && m1->mnt_group_id;\r\n}\r\nstatic int propagate_one(struct mount *m)\r\n{\r\nstruct mount *child;\r\nint type;\r\nif (IS_MNT_NEW(m))\r\nreturn 0;\r\nif (!is_subdir(mp->m_dentry, m->mnt.mnt_root))\r\nreturn 0;\r\nif (peers(m, last_dest)) {\r\ntype = CL_MAKE_SHARED;\r\n} else {\r\nstruct mount *n, *p;\r\nbool done;\r\nfor (n = m; ; n = p) {\r\np = n->mnt_master;\r\nif (p == dest_master || IS_MNT_MARKED(p))\r\nbreak;\r\n}\r\ndo {\r\nstruct mount *parent = last_source->mnt_parent;\r\nif (last_source == first_source)\r\nbreak;\r\ndone = parent->mnt_master == p;\r\nif (done && peers(n, parent))\r\nbreak;\r\nlast_source = last_source->mnt_master;\r\n} while (!done);\r\ntype = CL_SLAVE;\r\nif (IS_MNT_SHARED(m))\r\ntype |= CL_MAKE_SHARED;\r\n}\r\nif (m->mnt_ns->user_ns != user_ns)\r\ntype |= CL_UNPRIVILEGED;\r\nchild = copy_tree(last_source, last_source->mnt.mnt_root, type);\r\nif (IS_ERR(child))\r\nreturn PTR_ERR(child);\r\nchild->mnt.mnt_flags &= ~MNT_LOCKED;\r\nmnt_set_mountpoint(m, mp, child);\r\nlast_dest = m;\r\nlast_source = child;\r\nif (m->mnt_master != dest_master) {\r\nread_seqlock_excl(&mount_lock);\r\nSET_MNT_MARK(m->mnt_master);\r\nread_sequnlock_excl(&mount_lock);\r\n}\r\nhlist_add_head(&child->mnt_hash, list);\r\nreturn count_mounts(m->mnt_ns, child);\r\n}\r\nint propagate_mnt(struct mount *dest_mnt, struct mountpoint *dest_mp,\r\nstruct mount *source_mnt, struct hlist_head *tree_list)\r\n{\r\nstruct mount *m, *n;\r\nint ret = 0;\r\nuser_ns = current->nsproxy->mnt_ns->user_ns;\r\nlast_dest = dest_mnt;\r\nfirst_source = source_mnt;\r\nlast_source = source_mnt;\r\nmp = dest_mp;\r\nlist = tree_list;\r\ndest_master = dest_mnt->mnt_master;\r\nfor (n = next_peer(dest_mnt); n != dest_mnt; n = next_peer(n)) {\r\nret = propagate_one(n);\r\nif (ret)\r\ngoto out;\r\n}\r\nfor (m = next_group(dest_mnt, dest_mnt); m;\r\nm = next_group(m, dest_mnt)) {\r\nn = m;\r\ndo {\r\nret = propagate_one(n);\r\nif (ret)\r\ngoto out;\r\nn = next_peer(n);\r\n} while (n != m);\r\n}\r\nout:\r\nread_seqlock_excl(&mount_lock);\r\nhlist_for_each_entry(n, tree_list, mnt_hash) {\r\nm = n->mnt_parent;\r\nif (m->mnt_master != dest_mnt->mnt_master)\r\nCLEAR_MNT_MARK(m->mnt_master);\r\n}\r\nread_sequnlock_excl(&mount_lock);\r\nreturn ret;\r\n}\r\nstatic struct mount *find_topper(struct mount *mnt)\r\n{\r\nstruct mount *child;\r\nif (!list_is_singular(&mnt->mnt_mounts))\r\nreturn NULL;\r\nchild = list_first_entry(&mnt->mnt_mounts, struct mount, mnt_child);\r\nif (child->mnt_mountpoint != mnt->mnt.mnt_root)\r\nreturn NULL;\r\nreturn child;\r\n}\r\nstatic inline int do_refcount_check(struct mount *mnt, int count)\r\n{\r\nreturn mnt_get_count(mnt) > count;\r\n}\r\nint propagate_mount_busy(struct mount *mnt, int refcnt)\r\n{\r\nstruct mount *m, *child, *topper;\r\nstruct mount *parent = mnt->mnt_parent;\r\nif (mnt == parent)\r\nreturn do_refcount_check(mnt, refcnt);\r\nif (!list_empty(&mnt->mnt_mounts) || do_refcount_check(mnt, refcnt))\r\nreturn 1;\r\nfor (m = propagation_next(parent, parent); m;\r\nm = propagation_next(m, parent)) {\r\nint count = 1;\r\nchild = __lookup_mnt(&m->mnt, mnt->mnt_mountpoint);\r\nif (!child)\r\ncontinue;\r\ntopper = find_topper(child);\r\nif (topper)\r\ncount += 1;\r\nelse if (!list_empty(&child->mnt_mounts))\r\ncontinue;\r\nif (do_refcount_check(child, count))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nvoid propagate_mount_unlock(struct mount *mnt)\r\n{\r\nstruct mount *parent = mnt->mnt_parent;\r\nstruct mount *m, *child;\r\nBUG_ON(parent == mnt);\r\nfor (m = propagation_next(parent, parent); m;\r\nm = propagation_next(m, parent)) {\r\nchild = __lookup_mnt(&m->mnt, mnt->mnt_mountpoint);\r\nif (child)\r\nchild->mnt.mnt_flags &= ~MNT_LOCKED;\r\n}\r\n}\r\nstatic void umount_one(struct mount *mnt, struct list_head *to_umount)\r\n{\r\nCLEAR_MNT_MARK(mnt);\r\nmnt->mnt.mnt_flags |= MNT_UMOUNT;\r\nlist_del_init(&mnt->mnt_child);\r\nlist_del_init(&mnt->mnt_umounting);\r\nlist_move_tail(&mnt->mnt_list, to_umount);\r\n}\r\nstatic bool __propagate_umount(struct mount *mnt,\r\nstruct list_head *to_umount,\r\nstruct list_head *to_restore)\r\n{\r\nbool progress = false;\r\nstruct mount *child;\r\nif (mnt->mnt.mnt_flags & (MNT_UMOUNT | MNT_MARKED))\r\ngoto out;\r\nlist_for_each_entry(child, &mnt->mnt_mounts, mnt_child) {\r\nif (child->mnt_mountpoint == mnt->mnt.mnt_root)\r\ncontinue;\r\nif (!list_empty(&child->mnt_umounting) && IS_MNT_MARKED(child))\r\ncontinue;\r\ngoto children;\r\n}\r\nSET_MNT_MARK(mnt);\r\nprogress = true;\r\nif (!IS_MNT_LOCKED(mnt)) {\r\numount_one(mnt, to_umount);\r\n} else {\r\nchildren:\r\nlist_move_tail(&mnt->mnt_umounting, to_restore);\r\n}\r\nout:\r\nreturn progress;\r\n}\r\nstatic void umount_list(struct list_head *to_umount,\r\nstruct list_head *to_restore)\r\n{\r\nstruct mount *mnt, *child, *tmp;\r\nlist_for_each_entry(mnt, to_umount, mnt_list) {\r\nlist_for_each_entry_safe(child, tmp, &mnt->mnt_mounts, mnt_child) {\r\nif (child->mnt_mountpoint == mnt->mnt.mnt_root)\r\nlist_move_tail(&child->mnt_umounting, to_restore);\r\nelse\r\numount_one(child, to_umount);\r\n}\r\n}\r\n}\r\nstatic void restore_mounts(struct list_head *to_restore)\r\n{\r\nwhile (!list_empty(to_restore)) {\r\nstruct mount *mnt, *parent;\r\nstruct mountpoint *mp;\r\nmnt = list_first_entry(to_restore, struct mount, mnt_umounting);\r\nCLEAR_MNT_MARK(mnt);\r\nlist_del_init(&mnt->mnt_umounting);\r\nmp = mnt->mnt_mp;\r\nparent = mnt->mnt_parent;\r\nwhile (parent->mnt.mnt_flags & MNT_UMOUNT) {\r\nmp = parent->mnt_mp;\r\nparent = parent->mnt_parent;\r\n}\r\nif (parent != mnt->mnt_parent)\r\nmnt_change_mountpoint(parent, mp, mnt);\r\n}\r\n}\r\nstatic void cleanup_umount_visitations(struct list_head *visited)\r\n{\r\nwhile (!list_empty(visited)) {\r\nstruct mount *mnt =\r\nlist_first_entry(visited, struct mount, mnt_umounting);\r\nlist_del_init(&mnt->mnt_umounting);\r\n}\r\n}\r\nint propagate_umount(struct list_head *list)\r\n{\r\nstruct mount *mnt;\r\nLIST_HEAD(to_restore);\r\nLIST_HEAD(to_umount);\r\nLIST_HEAD(visited);\r\nlist_for_each_entry_reverse(mnt, list, mnt_list) {\r\nstruct mount *parent = mnt->mnt_parent;\r\nstruct mount *m;\r\nif (!list_empty(&mnt->mnt_umounting))\r\ncontinue;\r\nlist_add_tail(&mnt->mnt_umounting, &visited);\r\nfor (m = propagation_next(parent, parent); m;\r\nm = propagation_next(m, parent)) {\r\nstruct mount *child = __lookup_mnt(&m->mnt,\r\nmnt->mnt_mountpoint);\r\nif (!child)\r\ncontinue;\r\nif (!list_empty(&child->mnt_umounting)) {\r\nm = skip_propagation_subtree(m, parent);\r\ncontinue;\r\n} else if (child->mnt.mnt_flags & MNT_UMOUNT) {\r\nlist_add_tail(&child->mnt_umounting, &visited);\r\ncontinue;\r\n}\r\nwhile (__propagate_umount(child,\r\n&to_umount, &to_restore)) {\r\nchild = child->mnt_parent;\r\nif (list_empty(&child->mnt_umounting))\r\nbreak;\r\n}\r\n}\r\n}\r\numount_list(&to_umount, &to_restore);\r\nrestore_mounts(&to_restore);\r\ncleanup_umount_visitations(&visited);\r\nlist_splice_tail(&to_umount, list);\r\nreturn 0;\r\n}
