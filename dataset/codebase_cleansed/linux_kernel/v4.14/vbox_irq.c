static void vbox_clear_irq(void)\r\n{\r\noutl((u32)~0, VGA_PORT_HGSMI_HOST);\r\n}\r\nstatic u32 vbox_get_flags(struct vbox_private *vbox)\r\n{\r\nreturn readl(vbox->guest_heap + HOST_FLAGS_OFFSET);\r\n}\r\nvoid vbox_report_hotplug(struct vbox_private *vbox)\r\n{\r\nschedule_work(&vbox->hotplug_work);\r\n}\r\nirqreturn_t vbox_irq_handler(int irq, void *arg)\r\n{\r\nstruct drm_device *dev = (struct drm_device *)arg;\r\nstruct vbox_private *vbox = (struct vbox_private *)dev->dev_private;\r\nu32 host_flags = vbox_get_flags(vbox);\r\nif (!(host_flags & HGSMIHOSTFLAGS_IRQ))\r\nreturn IRQ_NONE;\r\nif (host_flags &\r\n(HGSMIHOSTFLAGS_HOTPLUG | HGSMIHOSTFLAGS_CURSOR_CAPABILITIES) &&\r\n!(host_flags & HGSMIHOSTFLAGS_VSYNC))\r\nvbox_report_hotplug(vbox);\r\nvbox_clear_irq();\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void validate_or_set_position_hints(struct vbox_private *vbox)\r\n{\r\nstruct vbva_modehint *hintsi, *hintsj;\r\nbool valid = true;\r\nu16 currentx = 0;\r\nint i, j;\r\nfor (i = 0; i < vbox->num_crtcs; ++i) {\r\nfor (j = 0; j < i; ++j) {\r\nhintsi = &vbox->last_mode_hints[i];\r\nhintsj = &vbox->last_mode_hints[j];\r\nif (hintsi->enabled && hintsj->enabled) {\r\nif (hintsi->dx >= 0xffff ||\r\nhintsi->dy >= 0xffff ||\r\nhintsj->dx >= 0xffff ||\r\nhintsj->dy >= 0xffff ||\r\n(hintsi->dx <\r\nhintsj->dx + (hintsj->cx & 0x8fff) &&\r\nhintsi->dx + (hintsi->cx & 0x8fff) >\r\nhintsj->dx) ||\r\n(hintsi->dy <\r\nhintsj->dy + (hintsj->cy & 0x8fff) &&\r\nhintsi->dy + (hintsi->cy & 0x8fff) >\r\nhintsj->dy))\r\nvalid = false;\r\n}\r\n}\r\n}\r\nif (!valid)\r\nfor (i = 0; i < vbox->num_crtcs; ++i) {\r\nif (vbox->last_mode_hints[i].enabled) {\r\nvbox->last_mode_hints[i].dx = currentx;\r\nvbox->last_mode_hints[i].dy = 0;\r\ncurrentx +=\r\nvbox->last_mode_hints[i].cx & 0x8fff;\r\n}\r\n}\r\n}\r\nstatic void vbox_update_mode_hints(struct vbox_private *vbox)\r\n{\r\nstruct drm_device *dev = vbox->dev;\r\nstruct drm_connector *connector;\r\nstruct vbox_connector *vbox_conn;\r\nstruct vbva_modehint *hints;\r\nu16 flags;\r\nbool disconnected;\r\nunsigned int crtc_id;\r\nint ret;\r\nret = hgsmi_get_mode_hints(vbox->guest_pool, vbox->num_crtcs,\r\nvbox->last_mode_hints);\r\nif (ret) {\r\nDRM_ERROR("vboxvideo: hgsmi_get_mode_hints failed: %d\n", ret);\r\nreturn;\r\n}\r\nvalidate_or_set_position_hints(vbox);\r\ndrm_modeset_lock_all(dev);\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\r\nvbox_conn = to_vbox_connector(connector);\r\nhints = &vbox->last_mode_hints[vbox_conn->vbox_crtc->crtc_id];\r\nif (hints->magic != VBVAMODEHINT_MAGIC)\r\ncontinue;\r\ndisconnected = !(hints->enabled);\r\ncrtc_id = vbox_conn->vbox_crtc->crtc_id;\r\nvbox_conn->mode_hint.width = hints->cx & 0x8fff;\r\nvbox_conn->mode_hint.height = hints->cy & 0x8fff;\r\nvbox_conn->vbox_crtc->x_hint = hints->dx;\r\nvbox_conn->vbox_crtc->y_hint = hints->dy;\r\nvbox_conn->mode_hint.disconnected = disconnected;\r\nif (vbox_conn->vbox_crtc->disconnected == disconnected)\r\ncontinue;\r\nif (disconnected)\r\nflags = VBVA_SCREEN_F_ACTIVE | VBVA_SCREEN_F_DISABLED;\r\nelse\r\nflags = VBVA_SCREEN_F_ACTIVE | VBVA_SCREEN_F_BLANK;\r\nhgsmi_process_display_info(vbox->guest_pool, crtc_id, 0, 0, 0,\r\nhints->cx * 4, hints->cx,\r\nhints->cy, 0, flags);\r\nvbox_conn->vbox_crtc->disconnected = disconnected;\r\n}\r\ndrm_modeset_unlock_all(dev);\r\n}\r\nstatic void vbox_hotplug_worker(struct work_struct *work)\r\n{\r\nstruct vbox_private *vbox = container_of(work, struct vbox_private,\r\nhotplug_work);\r\nvbox_update_mode_hints(vbox);\r\ndrm_kms_helper_hotplug_event(vbox->dev);\r\n}\r\nint vbox_irq_init(struct vbox_private *vbox)\r\n{\r\nINIT_WORK(&vbox->hotplug_work, vbox_hotplug_worker);\r\nvbox_update_mode_hints(vbox);\r\nreturn drm_irq_install(vbox->dev, vbox->dev->pdev->irq);\r\n}\r\nvoid vbox_irq_fini(struct vbox_private *vbox)\r\n{\r\ndrm_irq_uninstall(vbox->dev);\r\nflush_work(&vbox->hotplug_work);\r\n}
