struct nfp_cpp *nfp_nsp_cpp(struct nfp_nsp *state)\r\n{\r\nreturn state->cpp;\r\n}\r\nbool nfp_nsp_config_modified(struct nfp_nsp *state)\r\n{\r\nreturn state->modified;\r\n}\r\nvoid nfp_nsp_config_set_modified(struct nfp_nsp *state, bool modified)\r\n{\r\nstate->modified = modified;\r\n}\r\nvoid *nfp_nsp_config_entries(struct nfp_nsp *state)\r\n{\r\nreturn state->entries;\r\n}\r\nunsigned int nfp_nsp_config_idx(struct nfp_nsp *state)\r\n{\r\nreturn state->idx;\r\n}\r\nvoid\r\nnfp_nsp_config_set_state(struct nfp_nsp *state, void *entries, unsigned int idx)\r\n{\r\nstate->entries = entries;\r\nstate->idx = idx;\r\n}\r\nvoid nfp_nsp_config_clear_state(struct nfp_nsp *state)\r\n{\r\nstate->entries = NULL;\r\nstate->idx = 0;\r\n}\r\nstatic void nfp_nsp_print_extended_error(struct nfp_nsp *state, u32 ret_val)\r\n{\r\nint i;\r\nif (!ret_val)\r\nreturn;\r\nfor (i = 0; i < ARRAY_SIZE(nsp_errors); i++)\r\nif (ret_val == nsp_errors[i].code)\r\nnfp_err(state->cpp, "err msg: %s\n", nsp_errors[i].msg);\r\n}\r\nstatic int nfp_nsp_check(struct nfp_nsp *state)\r\n{\r\nstruct nfp_cpp *cpp = state->cpp;\r\nu64 nsp_status, reg;\r\nu32 nsp_cpp;\r\nint err;\r\nnsp_cpp = nfp_resource_cpp_id(state->res);\r\nnsp_status = nfp_resource_address(state->res) + NSP_STATUS;\r\nerr = nfp_cpp_readq(cpp, nsp_cpp, nsp_status, &reg);\r\nif (err < 0)\r\nreturn err;\r\nif (FIELD_GET(NSP_STATUS_MAGIC, reg) != NSP_MAGIC) {\r\nnfp_err(cpp, "Cannot detect NFP Service Processor\n");\r\nreturn -ENODEV;\r\n}\r\nstate->ver.major = FIELD_GET(NSP_STATUS_MAJOR, reg);\r\nstate->ver.minor = FIELD_GET(NSP_STATUS_MINOR, reg);\r\nif (state->ver.major != NSP_MAJOR || state->ver.minor < NSP_MINOR) {\r\nnfp_err(cpp, "Unsupported ABI %hu.%hu\n",\r\nstate->ver.major, state->ver.minor);\r\nreturn -EINVAL;\r\n}\r\nif (reg & NSP_STATUS_BUSY) {\r\nnfp_err(cpp, "Service processor busy!\n");\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstruct nfp_nsp *nfp_nsp_open(struct nfp_cpp *cpp)\r\n{\r\nstruct nfp_resource *res;\r\nstruct nfp_nsp *state;\r\nint err;\r\nres = nfp_resource_acquire(cpp, NFP_RESOURCE_NSP);\r\nif (IS_ERR(res))\r\nreturn (void *)res;\r\nstate = kzalloc(sizeof(*state), GFP_KERNEL);\r\nif (!state) {\r\nnfp_resource_release(res);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nstate->cpp = cpp;\r\nstate->res = res;\r\nerr = nfp_nsp_check(state);\r\nif (err) {\r\nnfp_nsp_close(state);\r\nreturn ERR_PTR(err);\r\n}\r\nreturn state;\r\n}\r\nvoid nfp_nsp_close(struct nfp_nsp *state)\r\n{\r\nnfp_resource_release(state->res);\r\nkfree(state);\r\n}\r\nu16 nfp_nsp_get_abi_ver_major(struct nfp_nsp *state)\r\n{\r\nreturn state->ver.major;\r\n}\r\nu16 nfp_nsp_get_abi_ver_minor(struct nfp_nsp *state)\r\n{\r\nreturn state->ver.minor;\r\n}\r\nstatic int\r\nnfp_nsp_wait_reg(struct nfp_cpp *cpp, u64 *reg,\r\nu32 nsp_cpp, u64 addr, u64 mask, u64 val)\r\n{\r\nconst unsigned long wait_until = jiffies + 30 * HZ;\r\nint err;\r\nfor (;;) {\r\nconst unsigned long start_time = jiffies;\r\nerr = nfp_cpp_readq(cpp, nsp_cpp, addr, reg);\r\nif (err < 0)\r\nreturn err;\r\nif ((*reg & mask) == val)\r\nreturn 0;\r\nif (msleep_interruptible(25))\r\nreturn -ERESTARTSYS;\r\nif (time_after(start_time, wait_until))\r\nreturn -ETIMEDOUT;\r\n}\r\n}\r\nstatic int nfp_nsp_command(struct nfp_nsp *state, u16 code, u32 option,\r\nu32 buff_cpp, u64 buff_addr)\r\n{\r\nu64 reg, ret_val, nsp_base, nsp_buffer, nsp_status, nsp_command;\r\nstruct nfp_cpp *cpp = state->cpp;\r\nu32 nsp_cpp;\r\nint err;\r\nnsp_cpp = nfp_resource_cpp_id(state->res);\r\nnsp_base = nfp_resource_address(state->res);\r\nnsp_status = nsp_base + NSP_STATUS;\r\nnsp_command = nsp_base + NSP_COMMAND;\r\nnsp_buffer = nsp_base + NSP_BUFFER;\r\nerr = nfp_nsp_check(state);\r\nif (err)\r\nreturn err;\r\nif (!FIELD_FIT(NSP_BUFFER_CPP, buff_cpp >> 8) ||\r\n!FIELD_FIT(NSP_BUFFER_ADDRESS, buff_addr)) {\r\nnfp_err(cpp, "Host buffer out of reach %08x %016llx\n",\r\nbuff_cpp, buff_addr);\r\nreturn -EINVAL;\r\n}\r\nerr = nfp_cpp_writeq(cpp, nsp_cpp, nsp_buffer,\r\nFIELD_PREP(NSP_BUFFER_CPP, buff_cpp >> 8) |\r\nFIELD_PREP(NSP_BUFFER_ADDRESS, buff_addr));\r\nif (err < 0)\r\nreturn err;\r\nerr = nfp_cpp_writeq(cpp, nsp_cpp, nsp_command,\r\nFIELD_PREP(NSP_COMMAND_OPTION, option) |\r\nFIELD_PREP(NSP_COMMAND_CODE, code) |\r\nFIELD_PREP(NSP_COMMAND_START, 1));\r\nif (err < 0)\r\nreturn err;\r\nerr = nfp_nsp_wait_reg(cpp, &reg,\r\nnsp_cpp, nsp_command, NSP_COMMAND_START, 0);\r\nif (err) {\r\nnfp_err(cpp, "Error %d waiting for code 0x%04x to start\n",\r\nerr, code);\r\nreturn err;\r\n}\r\nerr = nfp_nsp_wait_reg(cpp, &reg,\r\nnsp_cpp, nsp_status, NSP_STATUS_BUSY, 0);\r\nif (err) {\r\nnfp_err(cpp, "Error %d waiting for code 0x%04x to complete\n",\r\nerr, code);\r\nreturn err;\r\n}\r\nerr = nfp_cpp_readq(cpp, nsp_cpp, nsp_command, &ret_val);\r\nif (err < 0)\r\nreturn err;\r\nret_val = FIELD_GET(NSP_COMMAND_OPTION, ret_val);\r\nerr = FIELD_GET(NSP_STATUS_RESULT, reg);\r\nif (err) {\r\nnfp_warn(cpp, "Result (error) code set: %d (%d) command: %d\n",\r\n-err, (int)ret_val, code);\r\nnfp_nsp_print_extended_error(state, ret_val);\r\nreturn -err;\r\n}\r\nreturn ret_val;\r\n}\r\nstatic int nfp_nsp_command_buf(struct nfp_nsp *nsp, u16 code, u32 option,\r\nconst void *in_buf, unsigned int in_size,\r\nvoid *out_buf, unsigned int out_size)\r\n{\r\nstruct nfp_cpp *cpp = nsp->cpp;\r\nunsigned int max_size;\r\nu64 reg, cpp_buf;\r\nint ret, err;\r\nu32 cpp_id;\r\nif (nsp->ver.minor < 13) {\r\nnfp_err(cpp, "NSP: Code 0x%04x with buffer not supported (ABI %hu.%hu)\n",\r\ncode, nsp->ver.major, nsp->ver.minor);\r\nreturn -EOPNOTSUPP;\r\n}\r\nerr = nfp_cpp_readq(cpp, nfp_resource_cpp_id(nsp->res),\r\nnfp_resource_address(nsp->res) +\r\nNSP_DFLT_BUFFER_CONFIG,\r\n&reg);\r\nif (err < 0)\r\nreturn err;\r\nmax_size = max(in_size, out_size);\r\nif (FIELD_GET(NSP_DFLT_BUFFER_SIZE_MB, reg) * SZ_1M < max_size) {\r\nnfp_err(cpp, "NSP: default buffer too small for command 0x%04x (%llu < %u)\n",\r\ncode, FIELD_GET(NSP_DFLT_BUFFER_SIZE_MB, reg) * SZ_1M,\r\nmax_size);\r\nreturn -EINVAL;\r\n}\r\nerr = nfp_cpp_readq(cpp, nfp_resource_cpp_id(nsp->res),\r\nnfp_resource_address(nsp->res) +\r\nNSP_DFLT_BUFFER,\r\n&reg);\r\nif (err < 0)\r\nreturn err;\r\ncpp_id = FIELD_GET(NSP_BUFFER_CPP, reg) << 8;\r\ncpp_buf = FIELD_GET(NSP_BUFFER_ADDRESS, reg);\r\nif (in_buf && in_size) {\r\nerr = nfp_cpp_write(cpp, cpp_id, cpp_buf, in_buf, in_size);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (out_buf && out_size && out_size > in_size) {\r\nmemset(out_buf, 0, out_size - in_size);\r\nerr = nfp_cpp_write(cpp, cpp_id, cpp_buf + in_size,\r\nout_buf, out_size - in_size);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nret = nfp_nsp_command(nsp, code, option, cpp_id, cpp_buf);\r\nif (ret < 0)\r\nreturn ret;\r\nif (out_buf && out_size) {\r\nerr = nfp_cpp_read(cpp, cpp_id, cpp_buf, out_buf, out_size);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn ret;\r\n}\r\nint nfp_nsp_wait(struct nfp_nsp *state)\r\n{\r\nconst unsigned long wait_until = jiffies + 30 * HZ;\r\nint err;\r\nnfp_dbg(state->cpp, "Waiting for NSP to respond (30 sec max).\n");\r\nfor (;;) {\r\nconst unsigned long start_time = jiffies;\r\nerr = nfp_nsp_command(state, SPCODE_NOOP, 0, 0, 0);\r\nif (err != -EAGAIN)\r\nbreak;\r\nif (msleep_interruptible(25)) {\r\nerr = -ERESTARTSYS;\r\nbreak;\r\n}\r\nif (time_after(start_time, wait_until)) {\r\nerr = -ETIMEDOUT;\r\nbreak;\r\n}\r\n}\r\nif (err)\r\nnfp_err(state->cpp, "NSP failed to respond %d\n", err);\r\nreturn err;\r\n}\r\nint nfp_nsp_device_soft_reset(struct nfp_nsp *state)\r\n{\r\nreturn nfp_nsp_command(state, SPCODE_SOFT_RESET, 0, 0, 0);\r\n}\r\nint nfp_nsp_load_fw(struct nfp_nsp *state, const struct firmware *fw)\r\n{\r\nreturn nfp_nsp_command_buf(state, SPCODE_FW_LOAD, fw->size, fw->data,\r\nfw->size, NULL, 0);\r\n}\r\nint nfp_nsp_read_eth_table(struct nfp_nsp *state, void *buf, unsigned int size)\r\n{\r\nreturn nfp_nsp_command_buf(state, SPCODE_ETH_RESCAN, size, NULL, 0,\r\nbuf, size);\r\n}\r\nint nfp_nsp_write_eth_table(struct nfp_nsp *state,\r\nconst void *buf, unsigned int size)\r\n{\r\nreturn nfp_nsp_command_buf(state, SPCODE_ETH_CONTROL, size, buf, size,\r\nNULL, 0);\r\n}\r\nint nfp_nsp_read_identify(struct nfp_nsp *state, void *buf, unsigned int size)\r\n{\r\nreturn nfp_nsp_command_buf(state, SPCODE_NSP_IDENTIFY, size, NULL, 0,\r\nbuf, size);\r\n}\r\nint nfp_nsp_read_sensors(struct nfp_nsp *state, unsigned int sensor_mask,\r\nvoid *buf, unsigned int size)\r\n{\r\nreturn nfp_nsp_command_buf(state, SPCODE_NSP_SENSORS, sensor_mask,\r\nNULL, 0, buf, size);\r\n}
