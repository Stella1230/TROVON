static void ep93xx_pata_clear_regs(void __iomem *base)\r\n{\r\nwritel(IDECTRL_CS0N | IDECTRL_CS1N | IDECTRL_DIORN |\r\nIDECTRL_DIOWN, base + IDECTRL);\r\nwritel(0, base + IDECFG);\r\nwritel(0, base + IDEMDMAOP);\r\nwritel(0, base + IDEUDMAOP);\r\nwritel(0, base + IDEDATAOUT);\r\nwritel(0, base + IDEDATAIN);\r\nwritel(0, base + IDEMDMADATAOUT);\r\nwritel(0, base + IDEMDMADATAIN);\r\nwritel(0, base + IDEUDMADATAOUT);\r\nwritel(0, base + IDEUDMADATAIN);\r\nwritel(0, base + IDEUDMADEBUG);\r\n}\r\nstatic bool ep93xx_pata_check_iordy(void __iomem *base)\r\n{\r\nreturn !!(readl(base + IDECTRL) & IDECTRL_IORDY);\r\n}\r\nstatic int ep93xx_pata_get_wst(int pio_mode)\r\n{\r\nint val;\r\nif (pio_mode == 0)\r\nval = 3;\r\nelse if (pio_mode < 3)\r\nval = 2;\r\nelse\r\nval = 1;\r\nreturn val << IDECFG_WST_SHIFT;\r\n}\r\nstatic void ep93xx_pata_enable_pio(void __iomem *base, int pio_mode)\r\n{\r\nwritel(IDECFG_IDEEN | IDECFG_PIO |\r\nep93xx_pata_get_wst(pio_mode) |\r\n(pio_mode << IDECFG_MODE_SHIFT), base + IDECFG);\r\n}\r\nstatic void ep93xx_pata_delay(unsigned long count)\r\n{\r\n__asm__ volatile (\r\n"0:\n"\r\n"mov r0, r0\n"\r\n"subs %0, %1, #1\n"\r\n"bge 0b\n"\r\n: "=r" (count)\r\n: "0" (count)\r\n);\r\n}\r\nstatic unsigned long ep93xx_pata_wait_for_iordy(void __iomem *base,\r\nunsigned long t2)\r\n{\r\nunsigned long start = (1250 + 35) / 25 - t2;\r\nunsigned long counter = start;\r\nwhile (!ep93xx_pata_check_iordy(base) && counter--)\r\nep93xx_pata_delay(1);\r\nreturn start - counter;\r\n}\r\nstatic void ep93xx_pata_rw_begin(void __iomem *base, unsigned long addr,\r\nunsigned long t1)\r\n{\r\nwritel(IDECTRL_DIOWN | IDECTRL_DIORN | addr, base + IDECTRL);\r\nep93xx_pata_delay(t1);\r\n}\r\nstatic void ep93xx_pata_rw_end(void __iomem *base, unsigned long addr,\r\nbool iordy, unsigned long t0, unsigned long t2,\r\nunsigned long t2i)\r\n{\r\nep93xx_pata_delay(t2);\r\nif (iordy)\r\nt2 += ep93xx_pata_wait_for_iordy(base, t2);\r\nwritel(IDECTRL_DIOWN | IDECTRL_DIORN | addr, base + IDECTRL);\r\nif (t0 > t2 && t0 - t2 > t2i)\r\nep93xx_pata_delay(t0 - t2);\r\nelse\r\nep93xx_pata_delay(t2i);\r\n}\r\nstatic u16 ep93xx_pata_read(struct ep93xx_pata_data *drv_data,\r\nunsigned long addr,\r\nbool reg)\r\n{\r\nvoid __iomem *base = drv_data->ide_base;\r\nconst struct ata_timing *t = &drv_data->t;\r\nunsigned long t0 = reg ? t->cyc8b : t->cycle;\r\nunsigned long t2 = reg ? t->act8b : t->active;\r\nunsigned long t2i = reg ? t->rec8b : t->recover;\r\nep93xx_pata_rw_begin(base, addr, t->setup);\r\nwritel(IDECTRL_DIOWN | addr, base + IDECTRL);\r\nep93xx_pata_rw_end(base, addr, drv_data->iordy, t0, t2, t2i);\r\nreturn readl(base + IDEDATAIN);\r\n}\r\nstatic u16 ep93xx_pata_read_reg(struct ep93xx_pata_data *drv_data,\r\nunsigned long addr)\r\n{\r\nreturn ep93xx_pata_read(drv_data, addr, true);\r\n}\r\nstatic u16 ep93xx_pata_read_data(struct ep93xx_pata_data *drv_data,\r\nunsigned long addr)\r\n{\r\nreturn ep93xx_pata_read(drv_data, addr, false);\r\n}\r\nstatic void ep93xx_pata_write(struct ep93xx_pata_data *drv_data,\r\nu16 value, unsigned long addr,\r\nbool reg)\r\n{\r\nvoid __iomem *base = drv_data->ide_base;\r\nconst struct ata_timing *t = &drv_data->t;\r\nunsigned long t0 = reg ? t->cyc8b : t->cycle;\r\nunsigned long t2 = reg ? t->act8b : t->active;\r\nunsigned long t2i = reg ? t->rec8b : t->recover;\r\nep93xx_pata_rw_begin(base, addr, t->setup);\r\nwritel(value, base + IDEDATAOUT);\r\nwritel(IDECTRL_DIORN | addr, base + IDECTRL);\r\nep93xx_pata_rw_end(base, addr, drv_data->iordy, t0, t2, t2i);\r\n}\r\nstatic void ep93xx_pata_write_reg(struct ep93xx_pata_data *drv_data,\r\nu16 value, unsigned long addr)\r\n{\r\nep93xx_pata_write(drv_data, value, addr, true);\r\n}\r\nstatic void ep93xx_pata_write_data(struct ep93xx_pata_data *drv_data,\r\nu16 value, unsigned long addr)\r\n{\r\nep93xx_pata_write(drv_data, value, addr, false);\r\n}\r\nstatic void ep93xx_pata_set_piomode(struct ata_port *ap,\r\nstruct ata_device *adev)\r\n{\r\nstruct ep93xx_pata_data *drv_data = ap->host->private_data;\r\nstruct ata_device *pair = ata_dev_pair(adev);\r\nunsigned long T = 1000000 / (200 / 5);\r\nata_timing_compute(adev, adev->pio_mode, &drv_data->t, T, 0);\r\nif (pair && pair->pio_mode) {\r\nstruct ata_timing t;\r\nata_timing_compute(pair, pair->pio_mode, &t, T, 0);\r\nata_timing_merge(&t, &drv_data->t, &drv_data->t,\r\nATA_TIMING_SETUP | ATA_TIMING_8BIT);\r\n}\r\ndrv_data->iordy = ata_pio_need_iordy(adev);\r\nep93xx_pata_enable_pio(drv_data->ide_base,\r\nadev->pio_mode - XFER_PIO_0);\r\n}\r\nstatic u8 ep93xx_pata_check_status(struct ata_port *ap)\r\n{\r\nstruct ep93xx_pata_data *drv_data = ap->host->private_data;\r\nreturn ep93xx_pata_read_reg(drv_data, IDECTRL_ADDR_STATUS);\r\n}\r\nstatic u8 ep93xx_pata_check_altstatus(struct ata_port *ap)\r\n{\r\nstruct ep93xx_pata_data *drv_data = ap->host->private_data;\r\nreturn ep93xx_pata_read_reg(drv_data, IDECTRL_ADDR_ALTSTATUS);\r\n}\r\nstatic void ep93xx_pata_tf_load(struct ata_port *ap,\r\nconst struct ata_taskfile *tf)\r\n{\r\nstruct ep93xx_pata_data *drv_data = ap->host->private_data;\r\nunsigned int is_addr = tf->flags & ATA_TFLAG_ISADDR;\r\nif (tf->ctl != ap->last_ctl) {\r\nep93xx_pata_write_reg(drv_data, tf->ctl, IDECTRL_ADDR_CTL);\r\nap->last_ctl = tf->ctl;\r\nata_wait_idle(ap);\r\n}\r\nif (is_addr && (tf->flags & ATA_TFLAG_LBA48)) {\r\nep93xx_pata_write_reg(drv_data, tf->hob_feature,\r\nIDECTRL_ADDR_FEATURE);\r\nep93xx_pata_write_reg(drv_data, tf->hob_nsect,\r\nIDECTRL_ADDR_NSECT);\r\nep93xx_pata_write_reg(drv_data, tf->hob_lbal,\r\nIDECTRL_ADDR_LBAL);\r\nep93xx_pata_write_reg(drv_data, tf->hob_lbam,\r\nIDECTRL_ADDR_LBAM);\r\nep93xx_pata_write_reg(drv_data, tf->hob_lbah,\r\nIDECTRL_ADDR_LBAH);\r\n}\r\nif (is_addr) {\r\nep93xx_pata_write_reg(drv_data, tf->feature,\r\nIDECTRL_ADDR_FEATURE);\r\nep93xx_pata_write_reg(drv_data, tf->nsect, IDECTRL_ADDR_NSECT);\r\nep93xx_pata_write_reg(drv_data, tf->lbal, IDECTRL_ADDR_LBAL);\r\nep93xx_pata_write_reg(drv_data, tf->lbam, IDECTRL_ADDR_LBAM);\r\nep93xx_pata_write_reg(drv_data, tf->lbah, IDECTRL_ADDR_LBAH);\r\n}\r\nif (tf->flags & ATA_TFLAG_DEVICE)\r\nep93xx_pata_write_reg(drv_data, tf->device,\r\nIDECTRL_ADDR_DEVICE);\r\nata_wait_idle(ap);\r\n}\r\nstatic void ep93xx_pata_tf_read(struct ata_port *ap, struct ata_taskfile *tf)\r\n{\r\nstruct ep93xx_pata_data *drv_data = ap->host->private_data;\r\ntf->command = ep93xx_pata_check_status(ap);\r\ntf->feature = ep93xx_pata_read_reg(drv_data, IDECTRL_ADDR_FEATURE);\r\ntf->nsect = ep93xx_pata_read_reg(drv_data, IDECTRL_ADDR_NSECT);\r\ntf->lbal = ep93xx_pata_read_reg(drv_data, IDECTRL_ADDR_LBAL);\r\ntf->lbam = ep93xx_pata_read_reg(drv_data, IDECTRL_ADDR_LBAM);\r\ntf->lbah = ep93xx_pata_read_reg(drv_data, IDECTRL_ADDR_LBAH);\r\ntf->device = ep93xx_pata_read_reg(drv_data, IDECTRL_ADDR_DEVICE);\r\nif (tf->flags & ATA_TFLAG_LBA48) {\r\nep93xx_pata_write_reg(drv_data, tf->ctl | ATA_HOB,\r\nIDECTRL_ADDR_CTL);\r\ntf->hob_feature = ep93xx_pata_read_reg(drv_data,\r\nIDECTRL_ADDR_FEATURE);\r\ntf->hob_nsect = ep93xx_pata_read_reg(drv_data,\r\nIDECTRL_ADDR_NSECT);\r\ntf->hob_lbal = ep93xx_pata_read_reg(drv_data,\r\nIDECTRL_ADDR_LBAL);\r\ntf->hob_lbam = ep93xx_pata_read_reg(drv_data,\r\nIDECTRL_ADDR_LBAM);\r\ntf->hob_lbah = ep93xx_pata_read_reg(drv_data,\r\nIDECTRL_ADDR_LBAH);\r\nep93xx_pata_write_reg(drv_data, tf->ctl, IDECTRL_ADDR_CTL);\r\nap->last_ctl = tf->ctl;\r\n}\r\n}\r\nstatic void ep93xx_pata_exec_command(struct ata_port *ap,\r\nconst struct ata_taskfile *tf)\r\n{\r\nstruct ep93xx_pata_data *drv_data = ap->host->private_data;\r\nep93xx_pata_write_reg(drv_data, tf->command,\r\nIDECTRL_ADDR_COMMAND);\r\nata_sff_pause(ap);\r\n}\r\nstatic void ep93xx_pata_dev_select(struct ata_port *ap, unsigned int device)\r\n{\r\nstruct ep93xx_pata_data *drv_data = ap->host->private_data;\r\nu8 tmp = ATA_DEVICE_OBS;\r\nif (device != 0)\r\ntmp |= ATA_DEV1;\r\nep93xx_pata_write_reg(drv_data, tmp, IDECTRL_ADDR_DEVICE);\r\nata_sff_pause(ap);\r\n}\r\nstatic void ep93xx_pata_set_devctl(struct ata_port *ap, u8 ctl)\r\n{\r\nstruct ep93xx_pata_data *drv_data = ap->host->private_data;\r\nep93xx_pata_write_reg(drv_data, ctl, IDECTRL_ADDR_CTL);\r\n}\r\nstatic unsigned int ep93xx_pata_data_xfer(struct ata_queued_cmd *qc,\r\nunsigned char *buf,\r\nunsigned int buflen, int rw)\r\n{\r\nstruct ata_port *ap = qc->dev->link->ap;\r\nstruct ep93xx_pata_data *drv_data = ap->host->private_data;\r\nu16 *data = (u16 *)buf;\r\nunsigned int words = buflen >> 1;\r\nwhile (words--)\r\nif (rw == READ)\r\n*data++ = cpu_to_le16(\r\nep93xx_pata_read_data(\r\ndrv_data, IDECTRL_ADDR_DATA));\r\nelse\r\nep93xx_pata_write_data(drv_data, le16_to_cpu(*data++),\r\nIDECTRL_ADDR_DATA);\r\nif (unlikely(buflen & 0x01)) {\r\nunsigned char pad[2] = { };\r\nbuf += buflen - 1;\r\nif (rw == READ) {\r\n*pad = cpu_to_le16(\r\nep93xx_pata_read_data(\r\ndrv_data, IDECTRL_ADDR_DATA));\r\n*buf = pad[0];\r\n} else {\r\npad[0] = *buf;\r\nep93xx_pata_write_data(drv_data, le16_to_cpu(*pad),\r\nIDECTRL_ADDR_DATA);\r\n}\r\nwords++;\r\n}\r\nreturn words << 1;\r\n}\r\nstatic bool ep93xx_pata_device_is_present(struct ata_port *ap,\r\nunsigned int device)\r\n{\r\nstruct ep93xx_pata_data *drv_data = ap->host->private_data;\r\nu8 nsect, lbal;\r\nap->ops->sff_dev_select(ap, device);\r\nep93xx_pata_write_reg(drv_data, 0x55, IDECTRL_ADDR_NSECT);\r\nep93xx_pata_write_reg(drv_data, 0xaa, IDECTRL_ADDR_LBAL);\r\nep93xx_pata_write_reg(drv_data, 0xaa, IDECTRL_ADDR_NSECT);\r\nep93xx_pata_write_reg(drv_data, 0x55, IDECTRL_ADDR_LBAL);\r\nep93xx_pata_write_reg(drv_data, 0x55, IDECTRL_ADDR_NSECT);\r\nep93xx_pata_write_reg(drv_data, 0xaa, IDECTRL_ADDR_LBAL);\r\nnsect = ep93xx_pata_read_reg(drv_data, IDECTRL_ADDR_NSECT);\r\nlbal = ep93xx_pata_read_reg(drv_data, IDECTRL_ADDR_LBAL);\r\nif ((nsect == 0x55) && (lbal == 0xaa))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int ep93xx_pata_wait_after_reset(struct ata_link *link,\r\nunsigned int devmask,\r\nunsigned long deadline)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nstruct ep93xx_pata_data *drv_data = ap->host->private_data;\r\nunsigned int dev0 = devmask & (1 << 0);\r\nunsigned int dev1 = devmask & (1 << 1);\r\nint rc, ret = 0;\r\nata_msleep(ap, ATA_WAIT_AFTER_RESET);\r\nrc = ata_sff_wait_ready(link, deadline);\r\nif (rc)\r\nreturn rc;\r\nif (dev1) {\r\nint i;\r\nap->ops->sff_dev_select(ap, 1);\r\nfor (i = 0; i < 2; i++) {\r\nu8 nsect, lbal;\r\nnsect = ep93xx_pata_read_reg(drv_data,\r\nIDECTRL_ADDR_NSECT);\r\nlbal = ep93xx_pata_read_reg(drv_data,\r\nIDECTRL_ADDR_LBAL);\r\nif (nsect == 1 && lbal == 1)\r\nbreak;\r\nmsleep(50);\r\n}\r\nrc = ata_sff_wait_ready(link, deadline);\r\nif (rc) {\r\nif (rc != -ENODEV)\r\nreturn rc;\r\nret = rc;\r\n}\r\n}\r\nap->ops->sff_dev_select(ap, 0);\r\nif (dev1)\r\nap->ops->sff_dev_select(ap, 1);\r\nif (dev0)\r\nap->ops->sff_dev_select(ap, 0);\r\nreturn ret;\r\n}\r\nstatic int ep93xx_pata_bus_softreset(struct ata_port *ap, unsigned int devmask,\r\nunsigned long deadline)\r\n{\r\nstruct ep93xx_pata_data *drv_data = ap->host->private_data;\r\nep93xx_pata_write_reg(drv_data, ap->ctl, IDECTRL_ADDR_CTL);\r\nudelay(20);\r\nep93xx_pata_write_reg(drv_data, ap->ctl | ATA_SRST, IDECTRL_ADDR_CTL);\r\nudelay(20);\r\nep93xx_pata_write_reg(drv_data, ap->ctl, IDECTRL_ADDR_CTL);\r\nap->last_ctl = ap->ctl;\r\nreturn ep93xx_pata_wait_after_reset(&ap->link, devmask, deadline);\r\n}\r\nstatic void ep93xx_pata_release_dma(struct ep93xx_pata_data *drv_data)\r\n{\r\nif (drv_data->dma_rx_channel) {\r\ndma_release_channel(drv_data->dma_rx_channel);\r\ndrv_data->dma_rx_channel = NULL;\r\n}\r\nif (drv_data->dma_tx_channel) {\r\ndma_release_channel(drv_data->dma_tx_channel);\r\ndrv_data->dma_tx_channel = NULL;\r\n}\r\n}\r\nstatic bool ep93xx_pata_dma_filter(struct dma_chan *chan, void *filter_param)\r\n{\r\nif (ep93xx_dma_chan_is_m2p(chan))\r\nreturn false;\r\nchan->private = filter_param;\r\nreturn true;\r\n}\r\nstatic void ep93xx_pata_dma_init(struct ep93xx_pata_data *drv_data)\r\n{\r\nconst struct platform_device *pdev = drv_data->pdev;\r\ndma_cap_mask_t mask;\r\nstruct dma_slave_config conf;\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\ndrv_data->dma_rx_data.port = EP93XX_DMA_IDE;\r\ndrv_data->dma_rx_data.direction = DMA_FROM_DEVICE;\r\ndrv_data->dma_rx_data.name = "ep93xx-pata-rx";\r\ndrv_data->dma_rx_channel = dma_request_channel(mask,\r\nep93xx_pata_dma_filter, &drv_data->dma_rx_data);\r\nif (!drv_data->dma_rx_channel)\r\nreturn;\r\ndrv_data->dma_tx_data.port = EP93XX_DMA_IDE;\r\ndrv_data->dma_tx_data.direction = DMA_TO_DEVICE;\r\ndrv_data->dma_tx_data.name = "ep93xx-pata-tx";\r\ndrv_data->dma_tx_channel = dma_request_channel(mask,\r\nep93xx_pata_dma_filter, &drv_data->dma_tx_data);\r\nif (!drv_data->dma_tx_channel) {\r\ndma_release_channel(drv_data->dma_rx_channel);\r\nreturn;\r\n}\r\nmemset(&conf, 0, sizeof(conf));\r\nconf.direction = DMA_FROM_DEVICE;\r\nconf.src_addr = drv_data->udma_in_phys;\r\nconf.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\nif (dmaengine_slave_config(drv_data->dma_rx_channel, &conf)) {\r\ndev_err(&pdev->dev, "failed to configure rx dma channel\n");\r\nep93xx_pata_release_dma(drv_data);\r\nreturn;\r\n}\r\nmemset(&conf, 0, sizeof(conf));\r\nconf.direction = DMA_TO_DEVICE;\r\nconf.dst_addr = drv_data->udma_out_phys;\r\nconf.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\nif (dmaengine_slave_config(drv_data->dma_tx_channel, &conf)) {\r\ndev_err(&pdev->dev, "failed to configure tx dma channel\n");\r\nep93xx_pata_release_dma(drv_data);\r\n}\r\n}\r\nstatic void ep93xx_pata_dma_start(struct ata_queued_cmd *qc)\r\n{\r\nstruct dma_async_tx_descriptor *txd;\r\nstruct ep93xx_pata_data *drv_data = qc->ap->host->private_data;\r\nvoid __iomem *base = drv_data->ide_base;\r\nstruct ata_device *adev = qc->dev;\r\nu32 v = qc->dma_dir == DMA_TO_DEVICE ? IDEUDMAOP_RWOP : 0;\r\nstruct dma_chan *channel = qc->dma_dir == DMA_TO_DEVICE\r\n? drv_data->dma_tx_channel : drv_data->dma_rx_channel;\r\ntxd = dmaengine_prep_slave_sg(channel, qc->sg, qc->n_elem, qc->dma_dir,\r\nDMA_CTRL_ACK);\r\nif (!txd) {\r\ndev_err(qc->ap->dev, "failed to prepare slave for sg dma\n");\r\nreturn;\r\n}\r\ntxd->callback = NULL;\r\ntxd->callback_param = NULL;\r\nif (dmaengine_submit(txd) < 0) {\r\ndev_err(qc->ap->dev, "failed to submit dma transfer\n");\r\nreturn;\r\n}\r\ndma_async_issue_pending(channel);\r\nwritel(v, base + IDEUDMAOP);\r\nreadl(base + IDEUDMAOP);\r\nwritel(v | IDEUDMAOP_UEN, base + IDEUDMAOP);\r\nwritel(IDECFG_IDEEN | IDECFG_UDMA |\r\n((adev->xfer_mode - XFER_UDMA_0) << IDECFG_MODE_SHIFT),\r\nbase + IDECFG);\r\n}\r\nstatic void ep93xx_pata_dma_stop(struct ata_queued_cmd *qc)\r\n{\r\nstruct ep93xx_pata_data *drv_data = qc->ap->host->private_data;\r\nvoid __iomem *base = drv_data->ide_base;\r\ndmaengine_terminate_all(drv_data->dma_rx_channel);\r\ndmaengine_terminate_all(drv_data->dma_tx_channel);\r\nwritel(0, base + IDEUDMAOP);\r\nwritel(readl(base + IDECTRL) | IDECTRL_DIOWN | IDECTRL_DIORN |\r\nIDECTRL_CS0N | IDECTRL_CS1N, base + IDECTRL);\r\nep93xx_pata_enable_pio(drv_data->ide_base,\r\nqc->dev->pio_mode - XFER_PIO_0);\r\nata_sff_dma_pause(qc->ap);\r\n}\r\nstatic void ep93xx_pata_dma_setup(struct ata_queued_cmd *qc)\r\n{\r\nqc->ap->ops->sff_exec_command(qc->ap, &qc->tf);\r\n}\r\nstatic u8 ep93xx_pata_dma_status(struct ata_port *ap)\r\n{\r\nstruct ep93xx_pata_data *drv_data = ap->host->private_data;\r\nu32 val = readl(drv_data->ide_base + IDEUDMASTS);\r\nif (val & IDEUDMASTS_NDO || val & IDEUDMASTS_NDI ||\r\nval & IDEUDMASTS_N4X || val & IDEUDMASTS_INTIDE)\r\nreturn ATA_DMA_ERR;\r\nif (readl(drv_data->ide_base + IDECTRL) & IDECTRL_INTRQ)\r\nreturn ATA_DMA_INTR;\r\nif (val & IDEUDMASTS_SBUSY || val & IDEUDMASTS_DMAIDE)\r\nreturn ATA_DMA_ACTIVE;\r\nreturn 0;\r\n}\r\nstatic int ep93xx_pata_softreset(struct ata_link *al, unsigned int *classes,\r\nunsigned long deadline)\r\n{\r\nstruct ata_port *ap = al->ap;\r\nunsigned int slave_possible = ap->flags & ATA_FLAG_SLAVE_POSS;\r\nunsigned int devmask = 0;\r\nint rc;\r\nu8 err;\r\nif (ep93xx_pata_device_is_present(ap, 0))\r\ndevmask |= (1 << 0);\r\nif (slave_possible && ep93xx_pata_device_is_present(ap, 1))\r\ndevmask |= (1 << 1);\r\nap->ops->sff_dev_select(al->ap, 0);\r\nrc = ep93xx_pata_bus_softreset(ap, devmask, deadline);\r\nif (rc && (rc != -ENODEV || sata_scr_valid(al))) {\r\nata_link_err(al, "SRST failed (errno=%d)\n", rc);\r\nreturn rc;\r\n}\r\nclasses[0] = ata_sff_dev_classify(&al->device[0], devmask & (1 << 0),\r\n&err);\r\nif (slave_possible && err != 0x81)\r\nclasses[1] = ata_sff_dev_classify(&al->device[1],\r\ndevmask & (1 << 1), &err);\r\nreturn 0;\r\n}\r\nstatic void ep93xx_pata_drain_fifo(struct ata_queued_cmd *qc)\r\n{\r\nint count;\r\nstruct ata_port *ap;\r\nstruct ep93xx_pata_data *drv_data;\r\nif (qc == NULL || qc->dma_dir == DMA_TO_DEVICE)\r\nreturn;\r\nap = qc->ap;\r\ndrv_data = ap->host->private_data;\r\nfor (count = 0; (ap->ops->sff_check_status(ap) & ATA_DRQ)\r\n&& count < 65536; count += 2)\r\nep93xx_pata_read_reg(drv_data, IDECTRL_ADDR_DATA);\r\nif (count)\r\nata_port_dbg(ap, "drained %d bytes to clear DRQ.\n", count);\r\n}\r\nstatic int ep93xx_pata_port_start(struct ata_port *ap)\r\n{\r\nstruct ep93xx_pata_data *drv_data = ap->host->private_data;\r\ndrv_data->t = *ata_timing_find_mode(XFER_PIO_0);\r\nreturn 0;\r\n}\r\nstatic int ep93xx_pata_probe(struct platform_device *pdev)\r\n{\r\nstruct ep93xx_pata_data *drv_data;\r\nstruct ata_host *host;\r\nstruct ata_port *ap;\r\nint irq;\r\nstruct resource *mem_res;\r\nvoid __iomem *ide_base;\r\nint err;\r\nerr = ep93xx_ide_acquire_gpio(pdev);\r\nif (err)\r\nreturn err;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\nerr = -ENXIO;\r\ngoto err_rel_gpio;\r\n}\r\nmem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nide_base = devm_ioremap_resource(&pdev->dev, mem_res);\r\nif (IS_ERR(ide_base)) {\r\nerr = PTR_ERR(ide_base);\r\ngoto err_rel_gpio;\r\n}\r\ndrv_data = devm_kzalloc(&pdev->dev, sizeof(*drv_data), GFP_KERNEL);\r\nif (!drv_data) {\r\nerr = -ENXIO;\r\ngoto err_rel_gpio;\r\n}\r\ndrv_data->pdev = pdev;\r\ndrv_data->ide_base = ide_base;\r\ndrv_data->udma_in_phys = mem_res->start + IDEUDMADATAIN;\r\ndrv_data->udma_out_phys = mem_res->start + IDEUDMADATAOUT;\r\nep93xx_pata_dma_init(drv_data);\r\nhost = ata_host_alloc(&pdev->dev, 1);\r\nif (!host) {\r\nerr = -ENXIO;\r\ngoto err_rel_dma;\r\n}\r\nep93xx_pata_clear_regs(ide_base);\r\nhost->private_data = drv_data;\r\nap = host->ports[0];\r\nap->dev = &pdev->dev;\r\nap->ops = &ep93xx_pata_port_ops;\r\nap->flags |= ATA_FLAG_SLAVE_POSS;\r\nap->pio_mask = ATA_PIO4;\r\nif (drv_data->dma_rx_channel && drv_data->dma_tx_channel) {\r\nint chip_rev = ep93xx_chip_revision();\r\nif (chip_rev == EP93XX_CHIP_REV_E1)\r\nap->udma_mask = ATA_UDMA3;\r\nelse if (chip_rev == EP93XX_CHIP_REV_E2)\r\nap->udma_mask = ATA_UDMA4;\r\nelse\r\nap->udma_mask = ATA_UDMA2;\r\n}\r\nep93xx_pata_enable_pio(ide_base, 0);\r\ndev_info(&pdev->dev, "version " DRV_VERSION "\n");\r\nerr = ata_host_activate(host, irq, ata_bmdma_interrupt, 0,\r\n&ep93xx_pata_sht);\r\nif (err == 0)\r\nreturn 0;\r\nerr_rel_dma:\r\nep93xx_pata_release_dma(drv_data);\r\nerr_rel_gpio:\r\nep93xx_ide_release_gpio(pdev);\r\nreturn err;\r\n}\r\nstatic int ep93xx_pata_remove(struct platform_device *pdev)\r\n{\r\nstruct ata_host *host = platform_get_drvdata(pdev);\r\nstruct ep93xx_pata_data *drv_data = host->private_data;\r\nata_host_detach(host);\r\nep93xx_pata_release_dma(drv_data);\r\nep93xx_pata_clear_regs(drv_data->ide_base);\r\nep93xx_ide_release_gpio(pdev);\r\nreturn 0;\r\n}
