static void\r\nvxfs_put_super(struct super_block *sbp)\r\n{\r\nstruct vxfs_sb_info *infp = VXFS_SBI(sbp);\r\niput(infp->vsi_fship);\r\niput(infp->vsi_ilist);\r\niput(infp->vsi_stilist);\r\nbrelse(infp->vsi_bp);\r\nkfree(infp);\r\n}\r\nstatic int\r\nvxfs_statfs(struct dentry *dentry, struct kstatfs *bufp)\r\n{\r\nstruct vxfs_sb_info *infp = VXFS_SBI(dentry->d_sb);\r\nstruct vxfs_sb *raw_sb = infp->vsi_raw;\r\nbufp->f_type = VXFS_SUPER_MAGIC;\r\nbufp->f_bsize = dentry->d_sb->s_blocksize;\r\nbufp->f_blocks = fs32_to_cpu(infp, raw_sb->vs_dsize);\r\nbufp->f_bfree = fs32_to_cpu(infp, raw_sb->vs_free);\r\nbufp->f_bavail = 0;\r\nbufp->f_files = 0;\r\nbufp->f_ffree = fs32_to_cpu(infp, raw_sb->vs_ifree);\r\nbufp->f_namelen = VXFS_NAMELEN;\r\nreturn 0;\r\n}\r\nstatic int vxfs_remount(struct super_block *sb, int *flags, char *data)\r\n{\r\nsync_filesystem(sb);\r\n*flags |= MS_RDONLY;\r\nreturn 0;\r\n}\r\nstatic struct inode *vxfs_alloc_inode(struct super_block *sb)\r\n{\r\nstruct vxfs_inode_info *vi;\r\nvi = kmem_cache_alloc(vxfs_inode_cachep, GFP_KERNEL);\r\nif (!vi)\r\nreturn NULL;\r\ninode_init_once(&vi->vfs_inode);\r\nreturn &vi->vfs_inode;\r\n}\r\nstatic void vxfs_i_callback(struct rcu_head *head)\r\n{\r\nstruct inode *inode = container_of(head, struct inode, i_rcu);\r\nkmem_cache_free(vxfs_inode_cachep, VXFS_INO(inode));\r\n}\r\nstatic void vxfs_destroy_inode(struct inode *inode)\r\n{\r\ncall_rcu(&inode->i_rcu, vxfs_i_callback);\r\n}\r\nstatic int vxfs_try_sb_magic(struct super_block *sbp, int silent,\r\nunsigned blk, __fs32 magic)\r\n{\r\nstruct buffer_head *bp;\r\nstruct vxfs_sb *rsbp;\r\nstruct vxfs_sb_info *infp = VXFS_SBI(sbp);\r\nint rc = -ENOMEM;\r\nbp = sb_bread(sbp, blk);\r\ndo {\r\nif (!bp || !buffer_mapped(bp)) {\r\nif (!silent) {\r\nprintk(KERN_WARNING\r\n"vxfs: unable to read disk superblock at %u\n",\r\nblk);\r\n}\r\nbreak;\r\n}\r\nrc = -EINVAL;\r\nrsbp = (struct vxfs_sb *)bp->b_data;\r\nif (rsbp->vs_magic != magic) {\r\nif (!silent)\r\nprintk(KERN_NOTICE\r\n"vxfs: WRONG superblock magic %08x at %u\n",\r\nrsbp->vs_magic, blk);\r\nbreak;\r\n}\r\nrc = 0;\r\ninfp->vsi_raw = rsbp;\r\ninfp->vsi_bp = bp;\r\n} while (0);\r\nif (rc) {\r\ninfp->vsi_raw = NULL;\r\ninfp->vsi_bp = NULL;\r\nbrelse(bp);\r\n}\r\nreturn rc;\r\n}\r\nstatic int vxfs_fill_super(struct super_block *sbp, void *dp, int silent)\r\n{\r\nstruct vxfs_sb_info *infp;\r\nstruct vxfs_sb *rsbp;\r\nu_long bsize;\r\nstruct inode *root;\r\nint ret = -EINVAL;\r\nu32 j;\r\nsbp->s_flags |= MS_RDONLY;\r\ninfp = kzalloc(sizeof(*infp), GFP_KERNEL);\r\nif (!infp) {\r\nprintk(KERN_WARNING "vxfs: unable to allocate incore superblock\n");\r\nreturn -ENOMEM;\r\n}\r\nbsize = sb_min_blocksize(sbp, BLOCK_SIZE);\r\nif (!bsize) {\r\nprintk(KERN_WARNING "vxfs: unable to set blocksize\n");\r\ngoto out;\r\n}\r\nsbp->s_op = &vxfs_super_ops;\r\nsbp->s_fs_info = infp;\r\nif (!vxfs_try_sb_magic(sbp, silent, 1,\r\n(__force __fs32)cpu_to_le32(VXFS_SUPER_MAGIC))) {\r\ninfp->byte_order = VXFS_BO_LE;\r\n} else if (!vxfs_try_sb_magic(sbp, silent, 8,\r\n(__force __fs32)cpu_to_be32(VXFS_SUPER_MAGIC))) {\r\ninfp->byte_order = VXFS_BO_BE;\r\n} else {\r\nif (!silent)\r\nprintk(KERN_NOTICE "vxfs: can't find superblock.\n");\r\ngoto out;\r\n}\r\nrsbp = infp->vsi_raw;\r\nj = fs32_to_cpu(infp, rsbp->vs_version);\r\nif ((j < 2 || j > 4) && !silent) {\r\nprintk(KERN_NOTICE "vxfs: unsupported VxFS version (%d)\n", j);\r\ngoto out;\r\n}\r\n#ifdef DIAGNOSTIC\r\nprintk(KERN_DEBUG "vxfs: supported VxFS version (%d)\n", j);\r\nprintk(KERN_DEBUG "vxfs: blocksize: %d\n",\r\nfs32_to_cpu(infp, rsbp->vs_bsize));\r\n#endif\r\nsbp->s_magic = fs32_to_cpu(infp, rsbp->vs_magic);\r\ninfp->vsi_oltext = fs32_to_cpu(infp, rsbp->vs_oltext[0]);\r\ninfp->vsi_oltsize = fs32_to_cpu(infp, rsbp->vs_oltsize);\r\nj = fs32_to_cpu(infp, rsbp->vs_bsize);\r\nif (!sb_set_blocksize(sbp, j)) {\r\nprintk(KERN_WARNING "vxfs: unable to set final block size\n");\r\ngoto out;\r\n}\r\nif (vxfs_read_olt(sbp, bsize)) {\r\nprintk(KERN_WARNING "vxfs: unable to read olt\n");\r\ngoto out;\r\n}\r\nif (vxfs_read_fshead(sbp)) {\r\nprintk(KERN_WARNING "vxfs: unable to read fshead\n");\r\ngoto out;\r\n}\r\nroot = vxfs_iget(sbp, VXFS_ROOT_INO);\r\nif (IS_ERR(root)) {\r\nret = PTR_ERR(root);\r\ngoto out;\r\n}\r\nsbp->s_root = d_make_root(root);\r\nif (!sbp->s_root) {\r\nprintk(KERN_WARNING "vxfs: unable to get root dentry.\n");\r\ngoto out_free_ilist;\r\n}\r\nreturn 0;\r\nout_free_ilist:\r\niput(infp->vsi_fship);\r\niput(infp->vsi_ilist);\r\niput(infp->vsi_stilist);\r\nout:\r\nbrelse(infp->vsi_bp);\r\nkfree(infp);\r\nreturn ret;\r\n}\r\nstatic struct dentry *vxfs_mount(struct file_system_type *fs_type,\r\nint flags, const char *dev_name, void *data)\r\n{\r\nreturn mount_bdev(fs_type, flags, dev_name, data, vxfs_fill_super);\r\n}\r\nstatic int __init\r\nvxfs_init(void)\r\n{\r\nint rv;\r\nvxfs_inode_cachep = kmem_cache_create("vxfs_inode",\r\nsizeof(struct vxfs_inode_info), 0,\r\nSLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD, NULL);\r\nif (!vxfs_inode_cachep)\r\nreturn -ENOMEM;\r\nrv = register_filesystem(&vxfs_fs_type);\r\nif (rv < 0)\r\nkmem_cache_destroy(vxfs_inode_cachep);\r\nreturn rv;\r\n}\r\nstatic void __exit\r\nvxfs_cleanup(void)\r\n{\r\nunregister_filesystem(&vxfs_fs_type);\r\nrcu_barrier();\r\nkmem_cache_destroy(vxfs_inode_cachep);\r\n}
