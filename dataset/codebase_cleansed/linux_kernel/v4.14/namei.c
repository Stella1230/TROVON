static noinline\r\nvoid __cachefiles_printk_object(struct cachefiles_object *object,\r\nconst char *prefix,\r\nu8 *keybuf)\r\n{\r\nstruct fscache_cookie *cookie;\r\nunsigned keylen, loop;\r\npr_err("%sobject: OBJ%x\n", prefix, object->fscache.debug_id);\r\npr_err("%sobjstate=%s fl=%lx wbusy=%x ev=%lx[%lx]\n",\r\nprefix, object->fscache.state->name,\r\nobject->fscache.flags, work_busy(&object->fscache.work),\r\nobject->fscache.events, object->fscache.event_mask);\r\npr_err("%sops=%u inp=%u exc=%u\n",\r\nprefix, object->fscache.n_ops, object->fscache.n_in_progress,\r\nobject->fscache.n_exclusive);\r\npr_err("%sparent=%p\n",\r\nprefix, object->fscache.parent);\r\nspin_lock(&object->fscache.lock);\r\ncookie = object->fscache.cookie;\r\nif (cookie) {\r\npr_err("%scookie=%p [pr=%p nd=%p fl=%lx]\n",\r\nprefix,\r\nobject->fscache.cookie,\r\nobject->fscache.cookie->parent,\r\nobject->fscache.cookie->netfs_data,\r\nobject->fscache.cookie->flags);\r\nif (keybuf && cookie->def)\r\nkeylen = cookie->def->get_key(cookie->netfs_data, keybuf,\r\nCACHEFILES_KEYBUF_SIZE);\r\nelse\r\nkeylen = 0;\r\n} else {\r\npr_err("%scookie=NULL\n", prefix);\r\nkeylen = 0;\r\n}\r\nspin_unlock(&object->fscache.lock);\r\nif (keylen) {\r\npr_err("%skey=[%u] '", prefix, keylen);\r\nfor (loop = 0; loop < keylen; loop++)\r\npr_cont("%02x", keybuf[loop]);\r\npr_cont("'\n");\r\n}\r\n}\r\nstatic noinline void cachefiles_printk_object(struct cachefiles_object *object,\r\nstruct cachefiles_object *xobject)\r\n{\r\nu8 *keybuf;\r\nkeybuf = kmalloc(CACHEFILES_KEYBUF_SIZE, GFP_NOIO);\r\nif (object)\r\n__cachefiles_printk_object(object, "", keybuf);\r\nif (xobject)\r\n__cachefiles_printk_object(xobject, "x", keybuf);\r\nkfree(keybuf);\r\n}\r\nstatic void cachefiles_mark_object_buried(struct cachefiles_cache *cache,\r\nstruct dentry *dentry,\r\nenum fscache_why_object_killed why)\r\n{\r\nstruct cachefiles_object *object;\r\nstruct rb_node *p;\r\n_enter(",'%pd'", dentry);\r\nwrite_lock(&cache->active_lock);\r\np = cache->active_nodes.rb_node;\r\nwhile (p) {\r\nobject = rb_entry(p, struct cachefiles_object, active_node);\r\nif (object->dentry > dentry)\r\np = p->rb_left;\r\nelse if (object->dentry < dentry)\r\np = p->rb_right;\r\nelse\r\ngoto found_dentry;\r\n}\r\nwrite_unlock(&cache->active_lock);\r\n_leave(" [no owner]");\r\nreturn;\r\nfound_dentry:\r\nkdebug("preemptive burial: OBJ%x [%s] %p",\r\nobject->fscache.debug_id,\r\nobject->fscache.state->name,\r\ndentry);\r\nif (fscache_object_is_live(&object->fscache)) {\r\npr_err("\n");\r\npr_err("Error: Can't preemptively bury live object\n");\r\ncachefiles_printk_object(object, NULL);\r\n} else {\r\nif (why != FSCACHE_OBJECT_IS_STALE)\r\nfscache_object_mark_killed(&object->fscache, why);\r\n}\r\nwrite_unlock(&cache->active_lock);\r\n_leave(" [owner marked]");\r\n}\r\nstatic int cachefiles_mark_object_active(struct cachefiles_cache *cache,\r\nstruct cachefiles_object *object)\r\n{\r\nstruct cachefiles_object *xobject;\r\nstruct rb_node **_p, *_parent = NULL;\r\nstruct dentry *dentry;\r\n_enter(",%p", object);\r\ntry_again:\r\nwrite_lock(&cache->active_lock);\r\nif (test_and_set_bit(CACHEFILES_OBJECT_ACTIVE, &object->flags)) {\r\npr_err("Error: Object already active\n");\r\ncachefiles_printk_object(object, NULL);\r\nBUG();\r\n}\r\ndentry = object->dentry;\r\n_p = &cache->active_nodes.rb_node;\r\nwhile (*_p) {\r\n_parent = *_p;\r\nxobject = rb_entry(_parent,\r\nstruct cachefiles_object, active_node);\r\nASSERT(xobject != object);\r\nif (xobject->dentry > dentry)\r\n_p = &(*_p)->rb_left;\r\nelse if (xobject->dentry < dentry)\r\n_p = &(*_p)->rb_right;\r\nelse\r\ngoto wait_for_old_object;\r\n}\r\nrb_link_node(&object->active_node, _parent, _p);\r\nrb_insert_color(&object->active_node, &cache->active_nodes);\r\nwrite_unlock(&cache->active_lock);\r\n_leave(" = 0");\r\nreturn 0;\r\nwait_for_old_object:\r\nif (fscache_object_is_live(&xobject->fscache)) {\r\npr_err("\n");\r\npr_err("Error: Unexpected object collision\n");\r\ncachefiles_printk_object(object, xobject);\r\nBUG();\r\n}\r\natomic_inc(&xobject->usage);\r\nwrite_unlock(&cache->active_lock);\r\nif (test_bit(CACHEFILES_OBJECT_ACTIVE, &xobject->flags)) {\r\nwait_queue_head_t *wq;\r\nsigned long timeout = 60 * HZ;\r\nwait_queue_entry_t wait;\r\nbool requeue;\r\nif (work_pending(&xobject->fscache.work)) {\r\n_debug("queue OBJ%x behind OBJ%x immediately",\r\nobject->fscache.debug_id,\r\nxobject->fscache.debug_id);\r\ngoto requeue;\r\n}\r\nwq = bit_waitqueue(&xobject->flags, CACHEFILES_OBJECT_ACTIVE);\r\ninit_wait(&wait);\r\nrequeue = false;\r\ndo {\r\nprepare_to_wait(wq, &wait, TASK_UNINTERRUPTIBLE);\r\nif (!test_bit(CACHEFILES_OBJECT_ACTIVE, &xobject->flags))\r\nbreak;\r\nrequeue = fscache_object_sleep_till_congested(&timeout);\r\n} while (timeout > 0 && !requeue);\r\nfinish_wait(wq, &wait);\r\nif (requeue &&\r\ntest_bit(CACHEFILES_OBJECT_ACTIVE, &xobject->flags)) {\r\n_debug("queue OBJ%x behind OBJ%x after wait",\r\nobject->fscache.debug_id,\r\nxobject->fscache.debug_id);\r\ngoto requeue;\r\n}\r\nif (timeout <= 0) {\r\npr_err("\n");\r\npr_err("Error: Overlong wait for old active object to go away\n");\r\ncachefiles_printk_object(object, xobject);\r\ngoto requeue;\r\n}\r\n}\r\nASSERT(!test_bit(CACHEFILES_OBJECT_ACTIVE, &xobject->flags));\r\ncache->cache.ops->put_object(&xobject->fscache);\r\ngoto try_again;\r\nrequeue:\r\nclear_bit(CACHEFILES_OBJECT_ACTIVE, &object->flags);\r\ncache->cache.ops->put_object(&xobject->fscache);\r\n_leave(" = -ETIMEDOUT");\r\nreturn -ETIMEDOUT;\r\n}\r\nvoid cachefiles_mark_object_inactive(struct cachefiles_cache *cache,\r\nstruct cachefiles_object *object,\r\nblkcnt_t i_blocks)\r\n{\r\nwrite_lock(&cache->active_lock);\r\nrb_erase(&object->active_node, &cache->active_nodes);\r\nclear_bit(CACHEFILES_OBJECT_ACTIVE, &object->flags);\r\nwrite_unlock(&cache->active_lock);\r\nwake_up_bit(&object->flags, CACHEFILES_OBJECT_ACTIVE);\r\natomic_long_add(i_blocks, &cache->b_released);\r\nif (atomic_inc_return(&cache->f_released))\r\ncachefiles_state_changed(cache);\r\n}\r\nstatic int cachefiles_bury_object(struct cachefiles_cache *cache,\r\nstruct dentry *dir,\r\nstruct dentry *rep,\r\nbool preemptive,\r\nenum fscache_why_object_killed why)\r\n{\r\nstruct dentry *grave, *trap;\r\nstruct path path, path_to_graveyard;\r\nchar nbuffer[8 + 8 + 1];\r\nint ret;\r\n_enter(",'%pd','%pd'", dir, rep);\r\n_debug("remove %p from %p", rep, dir);\r\nif (!d_is_dir(rep)) {\r\n_debug("unlink stale object");\r\npath.mnt = cache->mnt;\r\npath.dentry = dir;\r\nret = security_path_unlink(&path, rep);\r\nif (ret < 0) {\r\ncachefiles_io_error(cache, "Unlink security error");\r\n} else {\r\nret = vfs_unlink(d_inode(dir), rep, NULL);\r\nif (preemptive)\r\ncachefiles_mark_object_buried(cache, rep, why);\r\n}\r\ninode_unlock(d_inode(dir));\r\nif (ret == -EIO)\r\ncachefiles_io_error(cache, "Unlink failed");\r\n_leave(" = %d", ret);\r\nreturn ret;\r\n}\r\n_debug("move stale object to graveyard");\r\ninode_unlock(d_inode(dir));\r\ntry_again:\r\nsprintf(nbuffer, "%08x%08x",\r\n(uint32_t) get_seconds(),\r\n(uint32_t) atomic_inc_return(&cache->gravecounter));\r\ntrap = lock_rename(cache->graveyard, dir);\r\nif (rep->d_parent != dir) {\r\nunlock_rename(cache->graveyard, dir);\r\n_leave(" = 0 [culled?]");\r\nreturn 0;\r\n}\r\nif (!d_can_lookup(cache->graveyard)) {\r\nunlock_rename(cache->graveyard, dir);\r\ncachefiles_io_error(cache, "Graveyard no longer a directory");\r\nreturn -EIO;\r\n}\r\nif (trap == rep) {\r\nunlock_rename(cache->graveyard, dir);\r\ncachefiles_io_error(cache, "May not make directory loop");\r\nreturn -EIO;\r\n}\r\nif (d_mountpoint(rep)) {\r\nunlock_rename(cache->graveyard, dir);\r\ncachefiles_io_error(cache, "Mountpoint in cache");\r\nreturn -EIO;\r\n}\r\ngrave = lookup_one_len(nbuffer, cache->graveyard, strlen(nbuffer));\r\nif (IS_ERR(grave)) {\r\nunlock_rename(cache->graveyard, dir);\r\nif (PTR_ERR(grave) == -ENOMEM) {\r\n_leave(" = -ENOMEM");\r\nreturn -ENOMEM;\r\n}\r\ncachefiles_io_error(cache, "Lookup error %ld",\r\nPTR_ERR(grave));\r\nreturn -EIO;\r\n}\r\nif (d_is_positive(grave)) {\r\nunlock_rename(cache->graveyard, dir);\r\ndput(grave);\r\ngrave = NULL;\r\ncond_resched();\r\ngoto try_again;\r\n}\r\nif (d_mountpoint(grave)) {\r\nunlock_rename(cache->graveyard, dir);\r\ndput(grave);\r\ncachefiles_io_error(cache, "Mountpoint in graveyard");\r\nreturn -EIO;\r\n}\r\nif (trap == grave) {\r\nunlock_rename(cache->graveyard, dir);\r\ndput(grave);\r\ncachefiles_io_error(cache, "May not make directory loop");\r\nreturn -EIO;\r\n}\r\npath.mnt = cache->mnt;\r\npath.dentry = dir;\r\npath_to_graveyard.mnt = cache->mnt;\r\npath_to_graveyard.dentry = cache->graveyard;\r\nret = security_path_rename(&path, rep, &path_to_graveyard, grave, 0);\r\nif (ret < 0) {\r\ncachefiles_io_error(cache, "Rename security error %d", ret);\r\n} else {\r\nret = vfs_rename(d_inode(dir), rep,\r\nd_inode(cache->graveyard), grave, NULL, 0);\r\nif (ret != 0 && ret != -ENOMEM)\r\ncachefiles_io_error(cache,\r\n"Rename failed with error %d", ret);\r\nif (preemptive)\r\ncachefiles_mark_object_buried(cache, rep, why);\r\n}\r\nunlock_rename(cache->graveyard, dir);\r\ndput(grave);\r\n_leave(" = 0");\r\nreturn 0;\r\n}\r\nint cachefiles_delete_object(struct cachefiles_cache *cache,\r\nstruct cachefiles_object *object)\r\n{\r\nstruct dentry *dir;\r\nint ret;\r\n_enter(",OBJ%x{%p}", object->fscache.debug_id, object->dentry);\r\nASSERT(object->dentry);\r\nASSERT(d_backing_inode(object->dentry));\r\nASSERT(object->dentry->d_parent);\r\ndir = dget_parent(object->dentry);\r\ninode_lock_nested(d_inode(dir), I_MUTEX_PARENT);\r\nif (test_bit(FSCACHE_OBJECT_KILLED_BY_CACHE, &object->fscache.flags)) {\r\n_debug("object preemptively buried");\r\ninode_unlock(d_inode(dir));\r\nret = 0;\r\n} else {\r\nif (dir == object->dentry->d_parent) {\r\nret = cachefiles_bury_object(cache, dir,\r\nobject->dentry, false,\r\nFSCACHE_OBJECT_WAS_RETIRED);\r\n} else {\r\ninode_unlock(d_inode(dir));\r\nret = 0;\r\n}\r\n}\r\ndput(dir);\r\n_leave(" = %d", ret);\r\nreturn ret;\r\n}\r\nint cachefiles_walk_to_object(struct cachefiles_object *parent,\r\nstruct cachefiles_object *object,\r\nconst char *key,\r\nstruct cachefiles_xattr *auxdata)\r\n{\r\nstruct cachefiles_cache *cache;\r\nstruct dentry *dir, *next = NULL;\r\nstruct path path;\r\nunsigned long start;\r\nconst char *name;\r\nint ret, nlen;\r\n_enter("OBJ%x{%p},OBJ%x,%s,",\r\nparent->fscache.debug_id, parent->dentry,\r\nobject->fscache.debug_id, key);\r\ncache = container_of(parent->fscache.cache,\r\nstruct cachefiles_cache, cache);\r\npath.mnt = cache->mnt;\r\nASSERT(parent->dentry);\r\nASSERT(d_backing_inode(parent->dentry));\r\nif (!(d_is_dir(parent->dentry))) {\r\n_leave("looking up in none directory");\r\nreturn -ENOBUFS;\r\n}\r\ndir = dget(parent->dentry);\r\nadvance:\r\nname = key;\r\nnlen = strlen(key);\r\nkey = key + nlen + 1;\r\nif (!*key)\r\nkey = NULL;\r\nlookup_again:\r\n_debug("lookup '%s'", name);\r\ninode_lock_nested(d_inode(dir), I_MUTEX_PARENT);\r\nstart = jiffies;\r\nnext = lookup_one_len(name, dir, nlen);\r\ncachefiles_hist(cachefiles_lookup_histogram, start);\r\nif (IS_ERR(next))\r\ngoto lookup_error;\r\n_debug("next -> %p %s", next, d_backing_inode(next) ? "positive" : "negative");\r\nif (!key)\r\nobject->new = !d_backing_inode(next);\r\nif (d_is_negative(next))\r\nfscache_object_lookup_negative(&object->fscache);\r\nif (key || object->type == FSCACHE_COOKIE_TYPE_INDEX) {\r\nif (d_is_negative(next)) {\r\nret = cachefiles_has_space(cache, 1, 0);\r\nif (ret < 0)\r\ngoto no_space_error;\r\npath.dentry = dir;\r\nret = security_path_mkdir(&path, next, 0);\r\nif (ret < 0)\r\ngoto create_error;\r\nstart = jiffies;\r\nret = vfs_mkdir(d_inode(dir), next, 0);\r\ncachefiles_hist(cachefiles_mkdir_histogram, start);\r\nif (ret < 0)\r\ngoto create_error;\r\nASSERT(d_backing_inode(next));\r\n_debug("mkdir -> %p{%p{ino=%lu}}",\r\nnext, d_backing_inode(next), d_backing_inode(next)->i_ino);\r\n} else if (!d_can_lookup(next)) {\r\npr_err("inode %lu is not a directory\n",\r\nd_backing_inode(next)->i_ino);\r\nret = -ENOBUFS;\r\ngoto error;\r\n}\r\n} else {\r\nif (d_is_negative(next)) {\r\nret = cachefiles_has_space(cache, 1, 0);\r\nif (ret < 0)\r\ngoto no_space_error;\r\npath.dentry = dir;\r\nret = security_path_mknod(&path, next, S_IFREG, 0);\r\nif (ret < 0)\r\ngoto create_error;\r\nstart = jiffies;\r\nret = vfs_create(d_inode(dir), next, S_IFREG, true);\r\ncachefiles_hist(cachefiles_create_histogram, start);\r\nif (ret < 0)\r\ngoto create_error;\r\nASSERT(d_backing_inode(next));\r\n_debug("create -> %p{%p{ino=%lu}}",\r\nnext, d_backing_inode(next), d_backing_inode(next)->i_ino);\r\n} else if (!d_can_lookup(next) &&\r\n!d_is_reg(next)\r\n) {\r\npr_err("inode %lu is not a file or directory\n",\r\nd_backing_inode(next)->i_ino);\r\nret = -ENOBUFS;\r\ngoto error;\r\n}\r\n}\r\nif (key) {\r\n_debug("advance");\r\ninode_unlock(d_inode(dir));\r\ndput(dir);\r\ndir = next;\r\nnext = NULL;\r\ngoto advance;\r\n}\r\nobject->dentry = next;\r\nif (!object->new) {\r\n_debug("validate '%pd'", next);\r\nret = cachefiles_check_object_xattr(object, auxdata);\r\nif (ret == -ESTALE) {\r\nobject->dentry = NULL;\r\nret = cachefiles_bury_object(cache, dir, next, true,\r\nFSCACHE_OBJECT_IS_STALE);\r\ndput(next);\r\nnext = NULL;\r\nif (ret < 0)\r\ngoto delete_error;\r\n_debug("redo lookup");\r\nfscache_object_retrying_stale(&object->fscache);\r\ngoto lookup_again;\r\n}\r\n}\r\nret = cachefiles_mark_object_active(cache, object);\r\ninode_unlock(d_inode(dir));\r\ndput(dir);\r\ndir = NULL;\r\nif (ret == -ETIMEDOUT)\r\ngoto mark_active_timed_out;\r\n_debug("=== OBTAINED_OBJECT ===");\r\nif (object->new) {\r\nret = cachefiles_set_object_xattr(object, auxdata);\r\nif (ret < 0)\r\ngoto check_error;\r\n} else {\r\npath.dentry = next;\r\ntouch_atime(&path);\r\n}\r\nif (object->type != FSCACHE_COOKIE_TYPE_INDEX) {\r\nif (d_is_reg(object->dentry)) {\r\nconst struct address_space_operations *aops;\r\nret = -EPERM;\r\naops = d_backing_inode(object->dentry)->i_mapping->a_ops;\r\nif (!aops->bmap)\r\ngoto check_error;\r\nif (object->dentry->d_sb->s_blocksize > PAGE_SIZE)\r\ngoto check_error;\r\nobject->backer = object->dentry;\r\n} else {\r\nBUG();\r\n}\r\n}\r\nobject->new = 0;\r\nfscache_obtained_object(&object->fscache);\r\n_leave(" = 0 [%lu]", d_backing_inode(object->dentry)->i_ino);\r\nreturn 0;\r\nno_space_error:\r\nfscache_object_mark_killed(&object->fscache, FSCACHE_OBJECT_NO_SPACE);\r\ncreate_error:\r\n_debug("create error %d", ret);\r\nif (ret == -EIO)\r\ncachefiles_io_error(cache, "Create/mkdir failed");\r\ngoto error;\r\nmark_active_timed_out:\r\n_debug("mark active timed out");\r\ngoto release_dentry;\r\ncheck_error:\r\n_debug("check error %d", ret);\r\ncachefiles_mark_object_inactive(\r\ncache, object, d_backing_inode(object->dentry)->i_blocks);\r\nrelease_dentry:\r\ndput(object->dentry);\r\nobject->dentry = NULL;\r\ngoto error_out;\r\ndelete_error:\r\n_debug("delete error %d", ret);\r\ngoto error_out2;\r\nlookup_error:\r\n_debug("lookup error %ld", PTR_ERR(next));\r\nret = PTR_ERR(next);\r\nif (ret == -EIO)\r\ncachefiles_io_error(cache, "Lookup failed");\r\nnext = NULL;\r\nerror:\r\ninode_unlock(d_inode(dir));\r\ndput(next);\r\nerror_out2:\r\ndput(dir);\r\nerror_out:\r\n_leave(" = error %d", -ret);\r\nreturn ret;\r\n}\r\nstruct dentry *cachefiles_get_directory(struct cachefiles_cache *cache,\r\nstruct dentry *dir,\r\nconst char *dirname)\r\n{\r\nstruct dentry *subdir;\r\nunsigned long start;\r\nstruct path path;\r\nint ret;\r\n_enter(",,%s", dirname);\r\ninode_lock(d_inode(dir));\r\nstart = jiffies;\r\nsubdir = lookup_one_len(dirname, dir, strlen(dirname));\r\ncachefiles_hist(cachefiles_lookup_histogram, start);\r\nif (IS_ERR(subdir)) {\r\nif (PTR_ERR(subdir) == -ENOMEM)\r\ngoto nomem_d_alloc;\r\ngoto lookup_error;\r\n}\r\n_debug("subdir -> %p %s",\r\nsubdir, d_backing_inode(subdir) ? "positive" : "negative");\r\nif (d_is_negative(subdir)) {\r\nret = cachefiles_has_space(cache, 1, 0);\r\nif (ret < 0)\r\ngoto mkdir_error;\r\n_debug("attempt mkdir");\r\npath.mnt = cache->mnt;\r\npath.dentry = dir;\r\nret = security_path_mkdir(&path, subdir, 0700);\r\nif (ret < 0)\r\ngoto mkdir_error;\r\nret = vfs_mkdir(d_inode(dir), subdir, 0700);\r\nif (ret < 0)\r\ngoto mkdir_error;\r\nASSERT(d_backing_inode(subdir));\r\n_debug("mkdir -> %p{%p{ino=%lu}}",\r\nsubdir,\r\nd_backing_inode(subdir),\r\nd_backing_inode(subdir)->i_ino);\r\n}\r\ninode_unlock(d_inode(dir));\r\nASSERT(d_backing_inode(subdir));\r\nif (!d_can_lookup(subdir)) {\r\npr_err("%s is not a directory\n", dirname);\r\nret = -EIO;\r\ngoto check_error;\r\n}\r\nret = -EPERM;\r\nif (!(d_backing_inode(subdir)->i_opflags & IOP_XATTR) ||\r\n!d_backing_inode(subdir)->i_op->lookup ||\r\n!d_backing_inode(subdir)->i_op->mkdir ||\r\n!d_backing_inode(subdir)->i_op->create ||\r\n!d_backing_inode(subdir)->i_op->rename ||\r\n!d_backing_inode(subdir)->i_op->rmdir ||\r\n!d_backing_inode(subdir)->i_op->unlink)\r\ngoto check_error;\r\n_leave(" = [%lu]", d_backing_inode(subdir)->i_ino);\r\nreturn subdir;\r\ncheck_error:\r\ndput(subdir);\r\n_leave(" = %d [check]", ret);\r\nreturn ERR_PTR(ret);\r\nmkdir_error:\r\ninode_unlock(d_inode(dir));\r\ndput(subdir);\r\npr_err("mkdir %s failed with error %d\n", dirname, ret);\r\nreturn ERR_PTR(ret);\r\nlookup_error:\r\ninode_unlock(d_inode(dir));\r\nret = PTR_ERR(subdir);\r\npr_err("Lookup %s failed with error %d\n", dirname, ret);\r\nreturn ERR_PTR(ret);\r\nnomem_d_alloc:\r\ninode_unlock(d_inode(dir));\r\n_leave(" = -ENOMEM");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nstatic struct dentry *cachefiles_check_active(struct cachefiles_cache *cache,\r\nstruct dentry *dir,\r\nchar *filename)\r\n{\r\nstruct cachefiles_object *object;\r\nstruct rb_node *_n;\r\nstruct dentry *victim;\r\nunsigned long start;\r\nint ret;\r\ninode_lock_nested(d_inode(dir), I_MUTEX_PARENT);\r\nstart = jiffies;\r\nvictim = lookup_one_len(filename, dir, strlen(filename));\r\ncachefiles_hist(cachefiles_lookup_histogram, start);\r\nif (IS_ERR(victim))\r\ngoto lookup_error;\r\nif (d_is_negative(victim)) {\r\ninode_unlock(d_inode(dir));\r\ndput(victim);\r\n_leave(" = -ENOENT [absent]");\r\nreturn ERR_PTR(-ENOENT);\r\n}\r\nread_lock(&cache->active_lock);\r\n_n = cache->active_nodes.rb_node;\r\nwhile (_n) {\r\nobject = rb_entry(_n, struct cachefiles_object, active_node);\r\nif (object->dentry > victim)\r\n_n = _n->rb_left;\r\nelse if (object->dentry < victim)\r\n_n = _n->rb_right;\r\nelse\r\ngoto object_in_use;\r\n}\r\nread_unlock(&cache->active_lock);\r\nreturn victim;\r\nobject_in_use:\r\nread_unlock(&cache->active_lock);\r\ninode_unlock(d_inode(dir));\r\ndput(victim);\r\nreturn ERR_PTR(-EBUSY);\r\nlookup_error:\r\ninode_unlock(d_inode(dir));\r\nret = PTR_ERR(victim);\r\nif (ret == -ENOENT) {\r\n_leave(" = -ESTALE [absent]");\r\nreturn ERR_PTR(-ESTALE);\r\n}\r\nif (ret == -EIO) {\r\ncachefiles_io_error(cache, "Lookup failed");\r\n} else if (ret != -ENOMEM) {\r\npr_err("Internal error: %d\n", ret);\r\nret = -EIO;\r\n}\r\n_leave(" = %d", ret);\r\nreturn ERR_PTR(ret);\r\n}\r\nint cachefiles_cull(struct cachefiles_cache *cache, struct dentry *dir,\r\nchar *filename)\r\n{\r\nstruct dentry *victim;\r\nint ret;\r\n_enter(",%pd/,%s", dir, filename);\r\nvictim = cachefiles_check_active(cache, dir, filename);\r\nif (IS_ERR(victim))\r\nreturn PTR_ERR(victim);\r\n_debug("victim -> %p %s",\r\nvictim, d_backing_inode(victim) ? "positive" : "negative");\r\n_debug("victim is cullable");\r\nret = cachefiles_remove_object_xattr(cache, victim);\r\nif (ret < 0)\r\ngoto error_unlock;\r\n_debug("bury");\r\nret = cachefiles_bury_object(cache, dir, victim, false,\r\nFSCACHE_OBJECT_WAS_CULLED);\r\nif (ret < 0)\r\ngoto error;\r\ndput(victim);\r\n_leave(" = 0");\r\nreturn 0;\r\nerror_unlock:\r\ninode_unlock(d_inode(dir));\r\nerror:\r\ndput(victim);\r\nif (ret == -ENOENT) {\r\n_leave(" = -ESTALE [absent]");\r\nreturn -ESTALE;\r\n}\r\nif (ret != -ENOMEM) {\r\npr_err("Internal error: %d\n", ret);\r\nret = -EIO;\r\n}\r\n_leave(" = %d", ret);\r\nreturn ret;\r\n}\r\nint cachefiles_check_in_use(struct cachefiles_cache *cache, struct dentry *dir,\r\nchar *filename)\r\n{\r\nstruct dentry *victim;\r\nvictim = cachefiles_check_active(cache, dir, filename);\r\nif (IS_ERR(victim))\r\nreturn PTR_ERR(victim);\r\ninode_unlock(d_inode(dir));\r\ndput(victim);\r\nreturn 0;\r\n}
