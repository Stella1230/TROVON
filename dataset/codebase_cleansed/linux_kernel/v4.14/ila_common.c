static __wsum get_csum_diff(struct ipv6hdr *ip6h, struct ila_params *p)\r\n{\r\nstruct ila_addr *iaddr = ila_a2i(&ip6h->daddr);\r\nif (p->locator_match.v64)\r\nreturn p->csum_diff;\r\nelse\r\nreturn compute_csum_diff8((__be32 *)&iaddr->loc,\r\n(__be32 *)&p->locator);\r\n}\r\nstatic void ila_csum_do_neutral(struct ila_addr *iaddr,\r\nstruct ila_params *p)\r\n{\r\n__sum16 *adjust = (__force __sum16 *)&iaddr->ident.v16[3];\r\n__wsum diff, fval;\r\nif (p->locator_match.v64) {\r\ndiff = p->csum_diff;\r\n} else {\r\ndiff = compute_csum_diff8((__be32 *)&p->locator,\r\n(__be32 *)iaddr);\r\n}\r\nfval = (__force __wsum)(ila_csum_neutral_set(iaddr->ident) ?\r\nCSUM_NEUTRAL_FLAG : ~CSUM_NEUTRAL_FLAG);\r\ndiff = csum_add(diff, fval);\r\n*adjust = ~csum_fold(csum_add(diff, csum_unfold(*adjust)));\r\niaddr->ident.csum_neutral ^= 1;\r\n}\r\nstatic void ila_csum_adjust_transport(struct sk_buff *skb,\r\nstruct ila_params *p)\r\n{\r\n__wsum diff;\r\nstruct ipv6hdr *ip6h = ipv6_hdr(skb);\r\nstruct ila_addr *iaddr = ila_a2i(&ip6h->daddr);\r\nsize_t nhoff = sizeof(struct ipv6hdr);\r\nswitch (ip6h->nexthdr) {\r\ncase NEXTHDR_TCP:\r\nif (likely(pskb_may_pull(skb, nhoff + sizeof(struct tcphdr)))) {\r\nstruct tcphdr *th = (struct tcphdr *)\r\n(skb_network_header(skb) + nhoff);\r\ndiff = get_csum_diff(ip6h, p);\r\ninet_proto_csum_replace_by_diff(&th->check, skb,\r\ndiff, true);\r\n}\r\nbreak;\r\ncase NEXTHDR_UDP:\r\nif (likely(pskb_may_pull(skb, nhoff + sizeof(struct udphdr)))) {\r\nstruct udphdr *uh = (struct udphdr *)\r\n(skb_network_header(skb) + nhoff);\r\nif (uh->check || skb->ip_summed == CHECKSUM_PARTIAL) {\r\ndiff = get_csum_diff(ip6h, p);\r\ninet_proto_csum_replace_by_diff(&uh->check, skb,\r\ndiff, true);\r\nif (!uh->check)\r\nuh->check = CSUM_MANGLED_0;\r\n}\r\n}\r\nbreak;\r\ncase NEXTHDR_ICMP:\r\nif (likely(pskb_may_pull(skb,\r\nnhoff + sizeof(struct icmp6hdr)))) {\r\nstruct icmp6hdr *ih = (struct icmp6hdr *)\r\n(skb_network_header(skb) + nhoff);\r\ndiff = get_csum_diff(ip6h, p);\r\ninet_proto_csum_replace_by_diff(&ih->icmp6_cksum, skb,\r\ndiff, true);\r\n}\r\nbreak;\r\n}\r\niaddr->loc = p->locator;\r\n}\r\nvoid ila_update_ipv6_locator(struct sk_buff *skb, struct ila_params *p,\r\nbool set_csum_neutral)\r\n{\r\nstruct ipv6hdr *ip6h = ipv6_hdr(skb);\r\nstruct ila_addr *iaddr = ila_a2i(&ip6h->daddr);\r\nif (ila_csum_neutral_set(iaddr->ident)) {\r\nif (!set_csum_neutral)\r\nila_csum_do_neutral(iaddr, p);\r\n} else {\r\nswitch (p->csum_mode) {\r\ncase ILA_CSUM_ADJUST_TRANSPORT:\r\nila_csum_adjust_transport(skb, p);\r\nbreak;\r\ncase ILA_CSUM_NEUTRAL_MAP:\r\nila_csum_do_neutral(iaddr, p);\r\nbreak;\r\ncase ILA_CSUM_NO_ACTION:\r\nbreak;\r\n}\r\n}\r\niaddr->loc = p->locator;\r\n}\r\nvoid ila_init_saved_csum(struct ila_params *p)\r\n{\r\nif (!p->locator_match.v64)\r\nreturn;\r\np->csum_diff = compute_csum_diff8(\r\n(__be32 *)&p->locator,\r\n(__be32 *)&p->locator_match);\r\n}\r\nstatic int __init ila_init(void)\r\n{\r\nint ret;\r\nret = ila_lwt_init();\r\nif (ret)\r\ngoto fail_lwt;\r\nret = ila_xlat_init();\r\nif (ret)\r\ngoto fail_xlat;\r\nreturn 0;\r\nfail_xlat:\r\nila_lwt_fini();\r\nfail_lwt:\r\nreturn ret;\r\n}\r\nstatic void __exit ila_fini(void)\r\n{\r\nila_xlat_fini();\r\nila_lwt_fini();\r\n}
