static void pac207_write_regs(struct gspca_dev *gspca_dev, u16 index,\r\nconst u8 *buffer, u16 length)\r\n{\r\nstruct usb_device *udev = gspca_dev->dev;\r\nint err;\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nmemcpy(gspca_dev->usb_buf, buffer, length);\r\nerr = usb_control_msg(udev, usb_sndctrlpipe(udev, 0), 0x01,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\r\n0x00, index,\r\ngspca_dev->usb_buf, length, PAC207_CTRL_TIMEOUT);\r\nif (err < 0) {\r\npr_err("Failed to write registers to index 0x%04X, error %d\n",\r\nindex, err);\r\ngspca_dev->usb_err = err;\r\n}\r\n}\r\nstatic void pac207_write_reg(struct gspca_dev *gspca_dev, u16 index, u16 value)\r\n{\r\nstruct usb_device *udev = gspca_dev->dev;\r\nint err;\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nerr = usb_control_msg(udev, usb_sndctrlpipe(udev, 0), 0x00,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\r\nvalue, index, NULL, 0, PAC207_CTRL_TIMEOUT);\r\nif (err) {\r\npr_err("Failed to write a register (index 0x%04X, value 0x%02X, error %d)\n",\r\nindex, value, err);\r\ngspca_dev->usb_err = err;\r\n}\r\n}\r\nstatic int pac207_read_reg(struct gspca_dev *gspca_dev, u16 index)\r\n{\r\nstruct usb_device *udev = gspca_dev->dev;\r\nint res;\r\nif (gspca_dev->usb_err < 0)\r\nreturn 0;\r\nres = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0), 0x00,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\r\n0x00, index,\r\ngspca_dev->usb_buf, 1, PAC207_CTRL_TIMEOUT);\r\nif (res < 0) {\r\npr_err("Failed to read a register (index 0x%04X, error %d)\n",\r\nindex, res);\r\ngspca_dev->usb_err = res;\r\nreturn 0;\r\n}\r\nreturn gspca_dev->usb_buf[0];\r\n}\r\nstatic int sd_config(struct gspca_dev *gspca_dev,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct cam *cam;\r\nu8 idreg[2];\r\nidreg[0] = pac207_read_reg(gspca_dev, 0x0000);\r\nidreg[1] = pac207_read_reg(gspca_dev, 0x0001);\r\nidreg[0] = ((idreg[0] & 0x0f) << 4) | ((idreg[1] & 0xf0) >> 4);\r\nidreg[1] = idreg[1] & 0x0f;\r\nPDEBUG(D_PROBE, "Pixart Sensor ID 0x%02X Chips ID 0x%02X",\r\nidreg[0], idreg[1]);\r\nif (idreg[0] != 0x27) {\r\nPDEBUG(D_PROBE, "Error invalid sensor ID!");\r\nreturn -ENODEV;\r\n}\r\nPDEBUG(D_PROBE,\r\n"Pixart PAC207BCA Image Processor and Control Chip detected (vid/pid 0x%04X:0x%04X)",\r\nid->idVendor, id->idProduct);\r\ncam = &gspca_dev->cam;\r\ncam->cam_mode = sif_mode;\r\ncam->nmodes = ARRAY_SIZE(sif_mode);\r\nreturn 0;\r\n}\r\nstatic int sd_init(struct gspca_dev *gspca_dev)\r\n{\r\nu8 mode;\r\nif (led_invert)\r\nmode = 0x02;\r\nelse\r\nmode = 0x00;\r\npac207_write_reg(gspca_dev, 0x41, mode);\r\npac207_write_reg(gspca_dev, 0x0f, 0x00);\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic void setcontrol(struct gspca_dev *gspca_dev, u16 reg, u16 val)\r\n{\r\npac207_write_reg(gspca_dev, reg, val);\r\npac207_write_reg(gspca_dev, 0x13, 0x01);\r\npac207_write_reg(gspca_dev, 0x1c, 0x01);\r\n}\r\nstatic int sd_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct gspca_dev *gspca_dev =\r\ncontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\r\nstruct sd *sd = (struct sd *)gspca_dev;\r\ngspca_dev->usb_err = 0;\r\nif (ctrl->id == V4L2_CID_AUTOGAIN && ctrl->is_new && ctrl->val) {\r\ngspca_dev->exposure->val = PAC207_EXPOSURE_DEFAULT;\r\ngspca_dev->gain->val = PAC207_GAIN_DEFAULT;\r\nsd->autogain_ignore_frames = PAC_AUTOGAIN_IGNORE_FRAMES;\r\n}\r\nif (!gspca_dev->streaming)\r\nreturn 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nsetcontrol(gspca_dev, PAC207_BRIGHTNESS_REG, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_AUTOGAIN:\r\nif (gspca_dev->exposure->is_new || (ctrl->is_new && ctrl->val))\r\nsetcontrol(gspca_dev, PAC207_EXPOSURE_REG,\r\ngspca_dev->exposure->val);\r\nif (gspca_dev->gain->is_new || (ctrl->is_new && ctrl->val))\r\nsetcontrol(gspca_dev, PAC207_GAIN_REG,\r\ngspca_dev->gain->val);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_init_controls(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\r\ngspca_dev->vdev.ctrl_handler = hdl;\r\nv4l2_ctrl_handler_init(hdl, 4);\r\nsd->brightness = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS,\r\nPAC207_BRIGHTNESS_MIN, PAC207_BRIGHTNESS_MAX,\r\n1, PAC207_BRIGHTNESS_DEFAULT);\r\ngspca_dev->autogain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_AUTOGAIN, 0, 1, 1, 1);\r\ngspca_dev->exposure = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_EXPOSURE,\r\nPAC207_EXPOSURE_MIN, PAC207_EXPOSURE_MAX,\r\n1, PAC207_EXPOSURE_DEFAULT);\r\ngspca_dev->gain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_GAIN,\r\nPAC207_GAIN_MIN, PAC207_GAIN_MAX,\r\n1, PAC207_GAIN_DEFAULT);\r\nif (hdl->error) {\r\npr_err("Could not initialize controls\n");\r\nreturn hdl->error;\r\n}\r\nv4l2_ctrl_auto_cluster(3, &gspca_dev->autogain, 0, false);\r\nreturn 0;\r\n}\r\nstatic int sd_start(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n__u8 mode;\r\npac207_write_reg(gspca_dev, 0x0f, 0x10);\r\npac207_write_regs(gspca_dev, 0x0002, pac207_sensor_init[0], 8);\r\npac207_write_regs(gspca_dev, 0x000a, pac207_sensor_init[1], 8);\r\npac207_write_regs(gspca_dev, 0x0012, pac207_sensor_init[2], 8);\r\npac207_write_regs(gspca_dev, 0x0042, pac207_sensor_init[3], 8);\r\nif (gspca_dev->pixfmt.width == 176)\r\npac207_write_reg(gspca_dev, 0x4a, 0xff);\r\nelse\r\npac207_write_reg(gspca_dev, 0x4a, 0x30);\r\npac207_write_reg(gspca_dev, 0x4b, 0x00);\r\npac207_write_reg(gspca_dev, 0x08, v4l2_ctrl_g_ctrl(sd->brightness));\r\npac207_write_reg(gspca_dev, 0x0e,\r\nv4l2_ctrl_g_ctrl(gspca_dev->gain));\r\npac207_write_reg(gspca_dev, 0x02,\r\nv4l2_ctrl_g_ctrl(gspca_dev->exposure));\r\nif (led_invert)\r\nmode = 0x00;\r\nelse\r\nmode = 0x02;\r\nif (gspca_dev->pixfmt.width == 176) {\r\nmode |= 0x01;\r\nPDEBUG(D_STREAM, "pac207_start mode 176x144");\r\n} else {\r\nPDEBUG(D_STREAM, "pac207_start mode 352x288");\r\n}\r\npac207_write_reg(gspca_dev, 0x41, mode);\r\npac207_write_reg(gspca_dev, 0x13, 0x01);\r\npac207_write_reg(gspca_dev, 0x1c, 0x01);\r\nmsleep(10);\r\npac207_write_reg(gspca_dev, 0x40, 0x01);\r\nsd->sof_read = 0;\r\nsd->autogain_ignore_frames = 0;\r\natomic_set(&sd->avg_lum, -1);\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\r\n{\r\nu8 mode;\r\nif (led_invert)\r\nmode = 0x02;\r\nelse\r\nmode = 0x00;\r\npac207_write_reg(gspca_dev, 0x40, 0x00);\r\npac207_write_reg(gspca_dev, 0x41, mode);\r\npac207_write_reg(gspca_dev, 0x0f, 0x00);\r\n}\r\nstatic void pac207_do_auto_gain(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint avg_lum = atomic_read(&sd->avg_lum);\r\nif (avg_lum == -1)\r\nreturn;\r\nif (sd->autogain_ignore_frames > 0)\r\nsd->autogain_ignore_frames--;\r\nelse if (gspca_coarse_grained_expo_autogain(gspca_dev, avg_lum,\r\n90, PAC207_AUTOGAIN_DEADZONE))\r\nsd->autogain_ignore_frames = PAC_AUTOGAIN_IGNORE_FRAMES;\r\n}\r\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *data,\r\nint len)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nunsigned char *sof;\r\nsof = pac_find_sof(gspca_dev, &sd->sof_read, data, len);\r\nif (sof) {\r\nint n;\r\nn = sof - data;\r\nif (n > sizeof pac_sof_marker)\r\nn -= sizeof pac_sof_marker;\r\nelse\r\nn = 0;\r\ngspca_frame_add(gspca_dev, LAST_PACKET,\r\ndata, n);\r\nsd->header_read = 0;\r\ngspca_frame_add(gspca_dev, FIRST_PACKET, NULL, 0);\r\nlen -= sof - data;\r\ndata = sof;\r\n}\r\nif (sd->header_read < 11) {\r\nint needed;\r\nif (sd->header_read < 5) {\r\nneeded = 5 - sd->header_read;\r\nif (len >= needed)\r\natomic_set(&sd->avg_lum, data[needed - 1]);\r\n}\r\nneeded = 11 - sd->header_read;\r\nif (len <= needed) {\r\nsd->header_read += len;\r\nreturn;\r\n}\r\ndata += needed;\r\nlen -= needed;\r\nsd->header_read = 11;\r\n}\r\ngspca_frame_add(gspca_dev, INTER_PACKET, data, len);\r\n}\r\nstatic int sd_int_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *data,\r\nint len)\r\n{\r\nint ret = -EINVAL;\r\nif (len == 2 && data[0] == 0x5a && data[1] == 0x5a) {\r\ninput_report_key(gspca_dev->input_dev, KEY_CAMERA, 1);\r\ninput_sync(gspca_dev->input_dev);\r\ninput_report_key(gspca_dev->input_dev, KEY_CAMERA, 0);\r\ninput_sync(gspca_dev->input_dev);\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int sd_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\r\nTHIS_MODULE);\r\n}
