static int dmz_reclaim_align_wp(struct dmz_reclaim *zrc, struct dm_zone *zone,\r\nsector_t block)\r\n{\r\nstruct dmz_metadata *zmd = zrc->metadata;\r\nsector_t wp_block = zone->wp_block;\r\nunsigned int nr_blocks;\r\nint ret;\r\nif (wp_block == block)\r\nreturn 0;\r\nif (wp_block > block)\r\nreturn -EIO;\r\nnr_blocks = block - wp_block;\r\nret = blkdev_issue_zeroout(zrc->dev->bdev,\r\ndmz_start_sect(zmd, zone) + dmz_blk2sect(wp_block),\r\ndmz_blk2sect(nr_blocks), GFP_NOIO, 0);\r\nif (ret) {\r\ndmz_dev_err(zrc->dev,\r\n"Align zone %u wp %llu to %llu (wp+%u) blocks failed %d",\r\ndmz_id(zmd, zone), (unsigned long long)wp_block,\r\n(unsigned long long)block, nr_blocks, ret);\r\nreturn ret;\r\n}\r\nzone->wp_block = block;\r\nreturn 0;\r\n}\r\nstatic void dmz_reclaim_kcopy_end(int read_err, unsigned long write_err,\r\nvoid *context)\r\n{\r\nstruct dmz_reclaim *zrc = context;\r\nif (read_err || write_err)\r\nzrc->kc_err = -EIO;\r\nelse\r\nzrc->kc_err = 0;\r\nclear_bit_unlock(DMZ_RECLAIM_KCOPY, &zrc->flags);\r\nsmp_mb__after_atomic();\r\nwake_up_bit(&zrc->flags, DMZ_RECLAIM_KCOPY);\r\n}\r\nstatic int dmz_reclaim_copy(struct dmz_reclaim *zrc,\r\nstruct dm_zone *src_zone, struct dm_zone *dst_zone)\r\n{\r\nstruct dmz_metadata *zmd = zrc->metadata;\r\nstruct dmz_dev *dev = zrc->dev;\r\nstruct dm_io_region src, dst;\r\nsector_t block = 0, end_block;\r\nsector_t nr_blocks;\r\nsector_t src_zone_block;\r\nsector_t dst_zone_block;\r\nunsigned long flags = 0;\r\nint ret;\r\nif (dmz_is_seq(src_zone))\r\nend_block = src_zone->wp_block;\r\nelse\r\nend_block = dev->zone_nr_blocks;\r\nsrc_zone_block = dmz_start_block(zmd, src_zone);\r\ndst_zone_block = dmz_start_block(zmd, dst_zone);\r\nif (dmz_is_seq(dst_zone))\r\nset_bit(DM_KCOPYD_WRITE_SEQ, &flags);\r\nwhile (block < end_block) {\r\nret = dmz_first_valid_block(zmd, src_zone, &block);\r\nif (ret <= 0)\r\nreturn ret;\r\nnr_blocks = ret;\r\nif (dmz_is_seq(dst_zone)) {\r\nret = dmz_reclaim_align_wp(zrc, dst_zone, block);\r\nif (ret)\r\nreturn ret;\r\n}\r\nsrc.bdev = dev->bdev;\r\nsrc.sector = dmz_blk2sect(src_zone_block + block);\r\nsrc.count = dmz_blk2sect(nr_blocks);\r\ndst.bdev = dev->bdev;\r\ndst.sector = dmz_blk2sect(dst_zone_block + block);\r\ndst.count = src.count;\r\nset_bit(DMZ_RECLAIM_KCOPY, &zrc->flags);\r\nret = dm_kcopyd_copy(zrc->kc, &src, 1, &dst, flags,\r\ndmz_reclaim_kcopy_end, zrc);\r\nif (ret)\r\nreturn ret;\r\nwait_on_bit_io(&zrc->flags, DMZ_RECLAIM_KCOPY,\r\nTASK_UNINTERRUPTIBLE);\r\nif (zrc->kc_err)\r\nreturn zrc->kc_err;\r\nblock += nr_blocks;\r\nif (dmz_is_seq(dst_zone))\r\ndst_zone->wp_block = block;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dmz_reclaim_buf(struct dmz_reclaim *zrc, struct dm_zone *dzone)\r\n{\r\nstruct dm_zone *bzone = dzone->bzone;\r\nsector_t chunk_block = dzone->wp_block;\r\nstruct dmz_metadata *zmd = zrc->metadata;\r\nint ret;\r\ndmz_dev_debug(zrc->dev,\r\n"Chunk %u, move buf zone %u (weight %u) to data zone %u (weight %u)",\r\ndzone->chunk, dmz_id(zmd, bzone), dmz_weight(bzone),\r\ndmz_id(zmd, dzone), dmz_weight(dzone));\r\nret = dmz_reclaim_copy(zrc, bzone, dzone);\r\nif (ret < 0)\r\nreturn ret;\r\ndmz_lock_flush(zmd);\r\nret = dmz_merge_valid_blocks(zmd, bzone, dzone, chunk_block);\r\nif (ret == 0) {\r\ndmz_invalidate_blocks(zmd, bzone, 0, zrc->dev->zone_nr_blocks);\r\ndmz_lock_map(zmd);\r\ndmz_unmap_zone(zmd, bzone);\r\ndmz_unlock_zone_reclaim(dzone);\r\ndmz_free_zone(zmd, bzone);\r\ndmz_unlock_map(zmd);\r\n}\r\ndmz_unlock_flush(zmd);\r\nreturn 0;\r\n}\r\nstatic int dmz_reclaim_seq_data(struct dmz_reclaim *zrc, struct dm_zone *dzone)\r\n{\r\nunsigned int chunk = dzone->chunk;\r\nstruct dm_zone *bzone = dzone->bzone;\r\nstruct dmz_metadata *zmd = zrc->metadata;\r\nint ret = 0;\r\ndmz_dev_debug(zrc->dev,\r\n"Chunk %u, move data zone %u (weight %u) to buf zone %u (weight %u)",\r\nchunk, dmz_id(zmd, dzone), dmz_weight(dzone),\r\ndmz_id(zmd, bzone), dmz_weight(bzone));\r\nret = dmz_reclaim_copy(zrc, dzone, bzone);\r\nif (ret < 0)\r\nreturn ret;\r\ndmz_lock_flush(zmd);\r\nret = dmz_merge_valid_blocks(zmd, dzone, bzone, 0);\r\nif (ret == 0) {\r\ndmz_invalidate_blocks(zmd, dzone, 0, zrc->dev->zone_nr_blocks);\r\ndmz_lock_map(zmd);\r\ndmz_unmap_zone(zmd, bzone);\r\ndmz_unmap_zone(zmd, dzone);\r\ndmz_unlock_zone_reclaim(dzone);\r\ndmz_free_zone(zmd, dzone);\r\ndmz_map_zone(zmd, bzone, chunk);\r\ndmz_unlock_map(zmd);\r\n}\r\ndmz_unlock_flush(zmd);\r\nreturn 0;\r\n}\r\nstatic int dmz_reclaim_rnd_data(struct dmz_reclaim *zrc, struct dm_zone *dzone)\r\n{\r\nunsigned int chunk = dzone->chunk;\r\nstruct dm_zone *szone = NULL;\r\nstruct dmz_metadata *zmd = zrc->metadata;\r\nint ret;\r\ndmz_lock_map(zmd);\r\nszone = dmz_alloc_zone(zmd, DMZ_ALLOC_RECLAIM);\r\ndmz_unlock_map(zmd);\r\nif (!szone)\r\nreturn -ENOSPC;\r\ndmz_dev_debug(zrc->dev,\r\n"Chunk %u, move rnd zone %u (weight %u) to seq zone %u",\r\nchunk, dmz_id(zmd, dzone), dmz_weight(dzone),\r\ndmz_id(zmd, szone));\r\nret = dmz_reclaim_copy(zrc, dzone, szone);\r\ndmz_lock_flush(zmd);\r\nif (ret == 0) {\r\nret = dmz_copy_valid_blocks(zmd, dzone, szone);\r\n}\r\nif (ret) {\r\ndmz_lock_map(zmd);\r\ndmz_free_zone(zmd, szone);\r\ndmz_unlock_map(zmd);\r\n} else {\r\ndmz_invalidate_blocks(zmd, dzone, 0, zrc->dev->zone_nr_blocks);\r\ndmz_lock_map(zmd);\r\ndmz_unmap_zone(zmd, dzone);\r\ndmz_unlock_zone_reclaim(dzone);\r\ndmz_free_zone(zmd, dzone);\r\ndmz_map_zone(zmd, szone, chunk);\r\ndmz_unlock_map(zmd);\r\n}\r\ndmz_unlock_flush(zmd);\r\nreturn 0;\r\n}\r\nstatic void dmz_reclaim_empty(struct dmz_reclaim *zrc, struct dm_zone *dzone)\r\n{\r\nstruct dmz_metadata *zmd = zrc->metadata;\r\ndmz_lock_flush(zmd);\r\ndmz_lock_map(zmd);\r\ndmz_unmap_zone(zmd, dzone);\r\ndmz_unlock_zone_reclaim(dzone);\r\ndmz_free_zone(zmd, dzone);\r\ndmz_unlock_map(zmd);\r\ndmz_unlock_flush(zmd);\r\n}\r\nstatic void dmz_reclaim(struct dmz_reclaim *zrc)\r\n{\r\nstruct dmz_metadata *zmd = zrc->metadata;\r\nstruct dm_zone *dzone;\r\nstruct dm_zone *rzone;\r\nunsigned long start;\r\nint ret;\r\ndzone = dmz_get_zone_for_reclaim(zmd);\r\nif (!dzone)\r\nreturn;\r\nstart = jiffies;\r\nif (dmz_is_rnd(dzone)) {\r\nif (!dmz_weight(dzone)) {\r\ndmz_reclaim_empty(zrc, dzone);\r\nret = 0;\r\n} else {\r\nret = dmz_reclaim_rnd_data(zrc, dzone);\r\n}\r\nrzone = dzone;\r\n} else {\r\nstruct dm_zone *bzone = dzone->bzone;\r\nsector_t chunk_block = 0;\r\nret = dmz_first_valid_block(zmd, bzone, &chunk_block);\r\nif (ret < 0)\r\ngoto out;\r\nif (ret == 0 || chunk_block >= dzone->wp_block) {\r\nret = dmz_reclaim_buf(zrc, dzone);\r\nrzone = bzone;\r\n} else {\r\nret = dmz_reclaim_seq_data(zrc, dzone);\r\nrzone = dzone;\r\n}\r\n}\r\nout:\r\nif (ret) {\r\ndmz_unlock_zone_reclaim(dzone);\r\nreturn;\r\n}\r\n(void) dmz_flush_metadata(zrc->metadata);\r\ndmz_dev_debug(zrc->dev, "Reclaimed zone %u in %u ms",\r\ndmz_id(zmd, rzone), jiffies_to_msecs(jiffies - start));\r\n}\r\nstatic inline int dmz_target_idle(struct dmz_reclaim *zrc)\r\n{\r\nreturn time_is_before_jiffies(zrc->atime + DMZ_IDLE_PERIOD);\r\n}\r\nstatic bool dmz_should_reclaim(struct dmz_reclaim *zrc)\r\n{\r\nstruct dmz_metadata *zmd = zrc->metadata;\r\nunsigned int nr_rnd = dmz_nr_rnd_zones(zmd);\r\nunsigned int nr_unmap_rnd = dmz_nr_unmap_rnd_zones(zmd);\r\nunsigned int p_unmap_rnd = nr_unmap_rnd * 100 / nr_rnd;\r\nif (dmz_target_idle(zrc) && nr_unmap_rnd < nr_rnd)\r\nreturn true;\r\nif (p_unmap_rnd >= DMZ_RECLAIM_HIGH_UNMAP_RND)\r\nreturn false;\r\nreturn p_unmap_rnd <= DMZ_RECLAIM_LOW_UNMAP_RND;\r\n}\r\nstatic void dmz_reclaim_work(struct work_struct *work)\r\n{\r\nstruct dmz_reclaim *zrc = container_of(work, struct dmz_reclaim, work.work);\r\nstruct dmz_metadata *zmd = zrc->metadata;\r\nunsigned int nr_rnd, nr_unmap_rnd;\r\nunsigned int p_unmap_rnd;\r\nif (!dmz_should_reclaim(zrc)) {\r\nmod_delayed_work(zrc->wq, &zrc->work, DMZ_IDLE_PERIOD);\r\nreturn;\r\n}\r\nnr_rnd = dmz_nr_rnd_zones(zmd);\r\nnr_unmap_rnd = dmz_nr_unmap_rnd_zones(zmd);\r\np_unmap_rnd = nr_unmap_rnd * 100 / nr_rnd;\r\nif (dmz_target_idle(zrc) || p_unmap_rnd < DMZ_RECLAIM_LOW_UNMAP_RND / 2) {\r\nzrc->kc_throttle.throttle = 100;\r\n} else {\r\nzrc->kc_throttle.throttle = min(75U, 100U - p_unmap_rnd / 2);\r\n}\r\ndmz_dev_debug(zrc->dev,\r\n"Reclaim (%u): %s, %u%% free rnd zones (%u/%u)",\r\nzrc->kc_throttle.throttle,\r\n(dmz_target_idle(zrc) ? "Idle" : "Busy"),\r\np_unmap_rnd, nr_unmap_rnd, nr_rnd);\r\ndmz_reclaim(zrc);\r\ndmz_schedule_reclaim(zrc);\r\n}\r\nint dmz_ctr_reclaim(struct dmz_dev *dev, struct dmz_metadata *zmd,\r\nstruct dmz_reclaim **reclaim)\r\n{\r\nstruct dmz_reclaim *zrc;\r\nint ret;\r\nzrc = kzalloc(sizeof(struct dmz_reclaim), GFP_KERNEL);\r\nif (!zrc)\r\nreturn -ENOMEM;\r\nzrc->dev = dev;\r\nzrc->metadata = zmd;\r\nzrc->atime = jiffies;\r\nzrc->kc = dm_kcopyd_client_create(&zrc->kc_throttle);\r\nif (IS_ERR(zrc->kc)) {\r\nret = PTR_ERR(zrc->kc);\r\nzrc->kc = NULL;\r\ngoto err;\r\n}\r\nINIT_DELAYED_WORK(&zrc->work, dmz_reclaim_work);\r\nzrc->wq = alloc_ordered_workqueue("dmz_rwq_%s", WQ_MEM_RECLAIM,\r\ndev->name);\r\nif (!zrc->wq) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\n*reclaim = zrc;\r\nqueue_delayed_work(zrc->wq, &zrc->work, 0);\r\nreturn 0;\r\nerr:\r\nif (zrc->kc)\r\ndm_kcopyd_client_destroy(zrc->kc);\r\nkfree(zrc);\r\nreturn ret;\r\n}\r\nvoid dmz_dtr_reclaim(struct dmz_reclaim *zrc)\r\n{\r\ncancel_delayed_work_sync(&zrc->work);\r\ndestroy_workqueue(zrc->wq);\r\ndm_kcopyd_client_destroy(zrc->kc);\r\nkfree(zrc);\r\n}\r\nvoid dmz_suspend_reclaim(struct dmz_reclaim *zrc)\r\n{\r\ncancel_delayed_work_sync(&zrc->work);\r\n}\r\nvoid dmz_resume_reclaim(struct dmz_reclaim *zrc)\r\n{\r\nqueue_delayed_work(zrc->wq, &zrc->work, DMZ_IDLE_PERIOD);\r\n}\r\nvoid dmz_reclaim_bio_acc(struct dmz_reclaim *zrc)\r\n{\r\nzrc->atime = jiffies;\r\n}\r\nvoid dmz_schedule_reclaim(struct dmz_reclaim *zrc)\r\n{\r\nif (dmz_should_reclaim(zrc))\r\nmod_delayed_work(zrc->wq, &zrc->work, 0);\r\n}
