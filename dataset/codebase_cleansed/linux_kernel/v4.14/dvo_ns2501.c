static bool ns2501_readb(struct intel_dvo_device *dvo, int addr, uint8_t * ch)\r\n{\r\nstruct ns2501_priv *ns = dvo->dev_priv;\r\nstruct i2c_adapter *adapter = dvo->i2c_bus;\r\nu8 out_buf[2];\r\nu8 in_buf[2];\r\nstruct i2c_msg msgs[] = {\r\n{\r\n.addr = dvo->slave_addr,\r\n.flags = 0,\r\n.len = 1,\r\n.buf = out_buf,\r\n},\r\n{\r\n.addr = dvo->slave_addr,\r\n.flags = I2C_M_RD,\r\n.len = 1,\r\n.buf = in_buf,\r\n}\r\n};\r\nout_buf[0] = addr;\r\nout_buf[1] = 0;\r\nif (i2c_transfer(adapter, msgs, 2) == 2) {\r\n*ch = in_buf[0];\r\nreturn true;\r\n}\r\nif (!ns->quiet) {\r\nDRM_DEBUG_KMS\r\n("Unable to read register 0x%02x from %s:0x%02x.\n", addr,\r\nadapter->name, dvo->slave_addr);\r\n}\r\nreturn false;\r\n}\r\nstatic bool ns2501_writeb(struct intel_dvo_device *dvo, int addr, uint8_t ch)\r\n{\r\nstruct ns2501_priv *ns = dvo->dev_priv;\r\nstruct i2c_adapter *adapter = dvo->i2c_bus;\r\nuint8_t out_buf[2];\r\nstruct i2c_msg msg = {\r\n.addr = dvo->slave_addr,\r\n.flags = 0,\r\n.len = 2,\r\n.buf = out_buf,\r\n};\r\nout_buf[0] = addr;\r\nout_buf[1] = ch;\r\nif (i2c_transfer(adapter, &msg, 1) == 1) {\r\nreturn true;\r\n}\r\nif (!ns->quiet) {\r\nDRM_DEBUG_KMS("Unable to write register 0x%02x to %s:%d\n",\r\naddr, adapter->name, dvo->slave_addr);\r\n}\r\nreturn false;\r\n}\r\nstatic bool ns2501_init(struct intel_dvo_device *dvo,\r\nstruct i2c_adapter *adapter)\r\n{\r\nstruct ns2501_priv *ns;\r\nunsigned char ch;\r\nns = kzalloc(sizeof(struct ns2501_priv), GFP_KERNEL);\r\nif (ns == NULL)\r\nreturn false;\r\ndvo->i2c_bus = adapter;\r\ndvo->dev_priv = ns;\r\nns->quiet = true;\r\nif (!ns2501_readb(dvo, NS2501_VID_LO, &ch))\r\ngoto out;\r\nif (ch != (NS2501_VID & 0xff)) {\r\nDRM_DEBUG_KMS("ns2501 not detected got %d: from %s Slave %d.\n",\r\nch, adapter->name, dvo->slave_addr);\r\ngoto out;\r\n}\r\nif (!ns2501_readb(dvo, NS2501_DID_LO, &ch))\r\ngoto out;\r\nif (ch != (NS2501_DID & 0xff)) {\r\nDRM_DEBUG_KMS("ns2501 not detected got %d: from %s Slave %d.\n",\r\nch, adapter->name, dvo->slave_addr);\r\ngoto out;\r\n}\r\nns->quiet = false;\r\nDRM_DEBUG_KMS("init ns2501 dvo controller successfully!\n");\r\nreturn true;\r\nout:\r\nkfree(ns);\r\nreturn false;\r\n}\r\nstatic enum drm_connector_status ns2501_detect(struct intel_dvo_device *dvo)\r\n{\r\nreturn connector_status_connected;\r\n}\r\nstatic enum drm_mode_status ns2501_mode_valid(struct intel_dvo_device *dvo,\r\nstruct drm_display_mode *mode)\r\n{\r\nDRM_DEBUG_KMS\r\n("is mode valid (hdisplay=%d,htotal=%d,vdisplay=%d,vtotal=%d)\n",\r\nmode->hdisplay, mode->htotal, mode->vdisplay, mode->vtotal);\r\nif ((mode->hdisplay == 640 && mode->vdisplay == 480 && mode->clock == 25175) ||\r\n(mode->hdisplay == 800 && mode->vdisplay == 600 && mode->clock == 40000) ||\r\n(mode->hdisplay == 1024 && mode->vdisplay == 768 && mode->clock == 65000)) {\r\nreturn MODE_OK;\r\n} else {\r\nreturn MODE_ONE_SIZE;\r\n}\r\n}\r\nstatic void ns2501_mode_set(struct intel_dvo_device *dvo,\r\nconst struct drm_display_mode *mode,\r\nconst struct drm_display_mode *adjusted_mode)\r\n{\r\nconst struct ns2501_configuration *conf;\r\nstruct ns2501_priv *ns = (struct ns2501_priv *)(dvo->dev_priv);\r\nint mode_idx, i;\r\nDRM_DEBUG_KMS\r\n("set mode (hdisplay=%d,htotal=%d,vdisplay=%d,vtotal=%d).\n",\r\nmode->hdisplay, mode->htotal, mode->vdisplay, mode->vtotal);\r\nDRM_DEBUG_KMS("Detailed requested mode settings are:\n"\r\n"clock : %d kHz\n"\r\n"hdisplay : %d\n"\r\n"hblank start : %d\n"\r\n"hblank end : %d\n"\r\n"hsync start : %d\n"\r\n"hsync end : %d\n"\r\n"htotal : %d\n"\r\n"hskew : %d\n"\r\n"vdisplay : %d\n"\r\n"vblank start : %d\n"\r\n"hblank end : %d\n"\r\n"vsync start : %d\n"\r\n"vsync end : %d\n"\r\n"vtotal : %d\n",\r\nadjusted_mode->crtc_clock,\r\nadjusted_mode->crtc_hdisplay,\r\nadjusted_mode->crtc_hblank_start,\r\nadjusted_mode->crtc_hblank_end,\r\nadjusted_mode->crtc_hsync_start,\r\nadjusted_mode->crtc_hsync_end,\r\nadjusted_mode->crtc_htotal,\r\nadjusted_mode->crtc_hskew,\r\nadjusted_mode->crtc_vdisplay,\r\nadjusted_mode->crtc_vblank_start,\r\nadjusted_mode->crtc_vblank_end,\r\nadjusted_mode->crtc_vsync_start,\r\nadjusted_mode->crtc_vsync_end,\r\nadjusted_mode->crtc_vtotal);\r\nif (mode->hdisplay == 640 && mode->vdisplay == 480)\r\nmode_idx = MODE_640x480;\r\nelse if (mode->hdisplay == 800 && mode->vdisplay == 600)\r\nmode_idx = MODE_800x600;\r\nelse if (mode->hdisplay == 1024 && mode->vdisplay == 768)\r\nmode_idx = MODE_1024x768;\r\nelse\r\nreturn;\r\nfor (i = 0; i < ARRAY_SIZE(regs_init); i++)\r\nns2501_writeb(dvo, regs_init[i].offset, regs_init[i].value);\r\nfor (i = 0; i < ARRAY_SIZE(mode_agnostic_values); i++)\r\nns2501_writeb(dvo, mode_agnostic_values[i].offset,\r\nmode_agnostic_values[i].value);\r\nconf = ns2501_modes + mode_idx;\r\nns->conf = conf;\r\nns2501_writeb(dvo, NS2501_REG8, conf->conf);\r\nns2501_writeb(dvo, NS2501_REG1B, conf->pll_a);\r\nns2501_writeb(dvo, NS2501_REG1C, conf->pll_b & 0xff);\r\nns2501_writeb(dvo, NS2501_REG1D, conf->pll_b >> 8);\r\nns2501_writeb(dvo, NS2501_REGC1, conf->hstart & 0xff);\r\nns2501_writeb(dvo, NS2501_REGC2, conf->hstart >> 8);\r\nns2501_writeb(dvo, NS2501_REGC3, conf->hstop & 0xff);\r\nns2501_writeb(dvo, NS2501_REGC4, conf->hstop >> 8);\r\nns2501_writeb(dvo, NS2501_REGC5, conf->vstart & 0xff);\r\nns2501_writeb(dvo, NS2501_REGC6, conf->vstart >> 8);\r\nns2501_writeb(dvo, NS2501_REGC7, conf->vstop & 0xff);\r\nns2501_writeb(dvo, NS2501_REGC8, conf->vstop >> 8);\r\nns2501_writeb(dvo, NS2501_REG80, conf->vsync & 0xff);\r\nns2501_writeb(dvo, NS2501_REG81, conf->vsync >> 8);\r\nns2501_writeb(dvo, NS2501_REG82, conf->vtotal & 0xff);\r\nns2501_writeb(dvo, NS2501_REG83, conf->vtotal >> 8);\r\nns2501_writeb(dvo, NS2501_REG98, conf->hpos & 0xff);\r\nns2501_writeb(dvo, NS2501_REG99, conf->hpos >> 8);\r\nns2501_writeb(dvo, NS2501_REG8E, conf->vpos & 0xff);\r\nns2501_writeb(dvo, NS2501_REG8F, conf->vpos >> 8);\r\nns2501_writeb(dvo, NS2501_REG9C, conf->voffs & 0xff);\r\nns2501_writeb(dvo, NS2501_REG9D, conf->voffs >> 8);\r\nns2501_writeb(dvo, NS2501_REGB8, conf->hscale & 0xff);\r\nns2501_writeb(dvo, NS2501_REGB9, conf->hscale >> 8);\r\nns2501_writeb(dvo, NS2501_REG10, conf->vscale & 0xff);\r\nns2501_writeb(dvo, NS2501_REG11, conf->vscale >> 8);\r\nns2501_writeb(dvo, NS2501_REGF9, conf->dither);\r\nns2501_writeb(dvo, NS2501_REG41, conf->syncb);\r\nns2501_writeb(dvo, NS2501_REGC0, conf->sync);\r\n}\r\nstatic bool ns2501_get_hw_state(struct intel_dvo_device *dvo)\r\n{\r\nunsigned char ch;\r\nif (!ns2501_readb(dvo, NS2501_REG8, &ch))\r\nreturn false;\r\nreturn ch & NS2501_8_PD;\r\n}\r\nstatic void ns2501_dpms(struct intel_dvo_device *dvo, bool enable)\r\n{\r\nstruct ns2501_priv *ns = (struct ns2501_priv *)(dvo->dev_priv);\r\nDRM_DEBUG_KMS("Trying set the dpms of the DVO to %i\n", enable);\r\nif (enable) {\r\nns2501_writeb(dvo, NS2501_REGC0, ns->conf->sync | 0x08);\r\nns2501_writeb(dvo, NS2501_REG41, ns->conf->syncb);\r\nns2501_writeb(dvo, NS2501_REG34, NS2501_34_ENABLE_OUTPUT);\r\nmsleep(15);\r\nns2501_writeb(dvo, NS2501_REG8,\r\nns->conf->conf | NS2501_8_BPAS);\r\nif (!(ns->conf->conf & NS2501_8_BPAS))\r\nns2501_writeb(dvo, NS2501_REG8, ns->conf->conf);\r\nmsleep(200);\r\nns2501_writeb(dvo, NS2501_REG34,\r\nNS2501_34_ENABLE_OUTPUT | NS2501_34_ENABLE_BACKLIGHT);\r\nns2501_writeb(dvo, NS2501_REGC0, ns->conf->sync);\r\n} else {\r\nns2501_writeb(dvo, NS2501_REG34, NS2501_34_ENABLE_OUTPUT);\r\nmsleep(200);\r\nns2501_writeb(dvo, NS2501_REG8, NS2501_8_VEN | NS2501_8_HEN |\r\nNS2501_8_BPAS);\r\nmsleep(15);\r\nns2501_writeb(dvo, NS2501_REG34, 0x00);\r\n}\r\n}\r\nstatic void ns2501_destroy(struct intel_dvo_device *dvo)\r\n{\r\nstruct ns2501_priv *ns = dvo->dev_priv;\r\nif (ns) {\r\nkfree(ns);\r\ndvo->dev_priv = NULL;\r\n}\r\n}
