static int gpiomm_gpio_get_direction(struct gpio_chip *chip,\r\nunsigned int offset)\r\n{\r\nstruct gpiomm_gpio *const gpiommgpio = gpiochip_get_data(chip);\r\nconst unsigned int port = offset / 8;\r\nconst unsigned int mask = BIT(offset % 8);\r\nreturn !!(gpiommgpio->io_state[port] & mask);\r\n}\r\nstatic int gpiomm_gpio_direction_input(struct gpio_chip *chip,\r\nunsigned int offset)\r\n{\r\nstruct gpiomm_gpio *const gpiommgpio = gpiochip_get_data(chip);\r\nconst unsigned int io_port = offset / 8;\r\nconst unsigned int control_port = io_port / 3;\r\nconst unsigned int control_addr = gpiommgpio->base + 3 + control_port*4;\r\nunsigned long flags;\r\nunsigned int control;\r\nspin_lock_irqsave(&gpiommgpio->lock, flags);\r\nif (io_port == 2 || io_port == 5) {\r\nif (offset % 8 > 3) {\r\ngpiommgpio->io_state[io_port] |= 0xF0;\r\ngpiommgpio->control[control_port] |= BIT(3);\r\n} else {\r\ngpiommgpio->io_state[io_port] |= 0x0F;\r\ngpiommgpio->control[control_port] |= BIT(0);\r\n}\r\n} else {\r\ngpiommgpio->io_state[io_port] |= 0xFF;\r\nif (io_port == 0 || io_port == 3)\r\ngpiommgpio->control[control_port] |= BIT(4);\r\nelse\r\ngpiommgpio->control[control_port] |= BIT(1);\r\n}\r\ncontrol = BIT(7) | gpiommgpio->control[control_port];\r\noutb(control, control_addr);\r\nspin_unlock_irqrestore(&gpiommgpio->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int gpiomm_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned int offset, int value)\r\n{\r\nstruct gpiomm_gpio *const gpiommgpio = gpiochip_get_data(chip);\r\nconst unsigned int io_port = offset / 8;\r\nconst unsigned int control_port = io_port / 3;\r\nconst unsigned int mask = BIT(offset % 8);\r\nconst unsigned int control_addr = gpiommgpio->base + 3 + control_port*4;\r\nconst unsigned int out_port = (io_port > 2) ? io_port + 1 : io_port;\r\nunsigned long flags;\r\nunsigned int control;\r\nspin_lock_irqsave(&gpiommgpio->lock, flags);\r\nif (io_port == 2 || io_port == 5) {\r\nif (offset % 8 > 3) {\r\ngpiommgpio->io_state[io_port] &= 0x0F;\r\ngpiommgpio->control[control_port] &= ~BIT(3);\r\n} else {\r\ngpiommgpio->io_state[io_port] &= 0xF0;\r\ngpiommgpio->control[control_port] &= ~BIT(0);\r\n}\r\n} else {\r\ngpiommgpio->io_state[io_port] &= 0x00;\r\nif (io_port == 0 || io_port == 3)\r\ngpiommgpio->control[control_port] &= ~BIT(4);\r\nelse\r\ngpiommgpio->control[control_port] &= ~BIT(1);\r\n}\r\nif (value)\r\ngpiommgpio->out_state[io_port] |= mask;\r\nelse\r\ngpiommgpio->out_state[io_port] &= ~mask;\r\ncontrol = BIT(7) | gpiommgpio->control[control_port];\r\noutb(control, control_addr);\r\noutb(gpiommgpio->out_state[io_port], gpiommgpio->base + out_port);\r\nspin_unlock_irqrestore(&gpiommgpio->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int gpiomm_gpio_get(struct gpio_chip *chip, unsigned int offset)\r\n{\r\nstruct gpiomm_gpio *const gpiommgpio = gpiochip_get_data(chip);\r\nconst unsigned int port = offset / 8;\r\nconst unsigned int mask = BIT(offset % 8);\r\nconst unsigned int in_port = (port > 2) ? port + 1 : port;\r\nunsigned long flags;\r\nunsigned int port_state;\r\nspin_lock_irqsave(&gpiommgpio->lock, flags);\r\nif (!(gpiommgpio->io_state[port] & mask)) {\r\nspin_unlock_irqrestore(&gpiommgpio->lock, flags);\r\nreturn -EINVAL;\r\n}\r\nport_state = inb(gpiommgpio->base + in_port);\r\nspin_unlock_irqrestore(&gpiommgpio->lock, flags);\r\nreturn !!(port_state & mask);\r\n}\r\nstatic void gpiomm_gpio_set(struct gpio_chip *chip, unsigned int offset,\r\nint value)\r\n{\r\nstruct gpiomm_gpio *const gpiommgpio = gpiochip_get_data(chip);\r\nconst unsigned int port = offset / 8;\r\nconst unsigned int mask = BIT(offset % 8);\r\nconst unsigned int out_port = (port > 2) ? port + 1 : port;\r\nunsigned long flags;\r\nspin_lock_irqsave(&gpiommgpio->lock, flags);\r\nif (value)\r\ngpiommgpio->out_state[port] |= mask;\r\nelse\r\ngpiommgpio->out_state[port] &= ~mask;\r\noutb(gpiommgpio->out_state[port], gpiommgpio->base + out_port);\r\nspin_unlock_irqrestore(&gpiommgpio->lock, flags);\r\n}\r\nstatic void gpiomm_gpio_set_multiple(struct gpio_chip *chip,\r\nunsigned long *mask, unsigned long *bits)\r\n{\r\nstruct gpiomm_gpio *const gpiommgpio = gpiochip_get_data(chip);\r\nunsigned int i;\r\nconst unsigned int gpio_reg_size = 8;\r\nunsigned int port;\r\nunsigned int out_port;\r\nunsigned int bitmask;\r\nunsigned long flags;\r\nfor (i = 0; i < chip->ngpio; i += gpio_reg_size) {\r\nif (!mask[BIT_WORD(i)]) {\r\ni = (BIT_WORD(i) + 1) * BITS_PER_LONG - gpio_reg_size;\r\ncontinue;\r\n}\r\nport = i / gpio_reg_size;\r\nout_port = (port > 2) ? port + 1 : port;\r\nbitmask = mask[BIT_WORD(i)] & bits[BIT_WORD(i)];\r\nspin_lock_irqsave(&gpiommgpio->lock, flags);\r\ngpiommgpio->out_state[port] &= ~mask[BIT_WORD(i)];\r\ngpiommgpio->out_state[port] |= bitmask;\r\noutb(gpiommgpio->out_state[port], gpiommgpio->base + out_port);\r\nspin_unlock_irqrestore(&gpiommgpio->lock, flags);\r\nmask[BIT_WORD(i)] >>= gpio_reg_size;\r\nbits[BIT_WORD(i)] >>= gpio_reg_size;\r\n}\r\n}\r\nstatic int gpiomm_probe(struct device *dev, unsigned int id)\r\n{\r\nstruct gpiomm_gpio *gpiommgpio;\r\nconst char *const name = dev_name(dev);\r\nint err;\r\ngpiommgpio = devm_kzalloc(dev, sizeof(*gpiommgpio), GFP_KERNEL);\r\nif (!gpiommgpio)\r\nreturn -ENOMEM;\r\nif (!devm_request_region(dev, base[id], GPIOMM_EXTENT, name)) {\r\ndev_err(dev, "Unable to lock port addresses (0x%X-0x%X)\n",\r\nbase[id], base[id] + GPIOMM_EXTENT);\r\nreturn -EBUSY;\r\n}\r\ngpiommgpio->chip.label = name;\r\ngpiommgpio->chip.parent = dev;\r\ngpiommgpio->chip.owner = THIS_MODULE;\r\ngpiommgpio->chip.base = -1;\r\ngpiommgpio->chip.ngpio = GPIOMM_NGPIO;\r\ngpiommgpio->chip.names = gpiomm_names;\r\ngpiommgpio->chip.get_direction = gpiomm_gpio_get_direction;\r\ngpiommgpio->chip.direction_input = gpiomm_gpio_direction_input;\r\ngpiommgpio->chip.direction_output = gpiomm_gpio_direction_output;\r\ngpiommgpio->chip.get = gpiomm_gpio_get;\r\ngpiommgpio->chip.set = gpiomm_gpio_set;\r\ngpiommgpio->chip.set_multiple = gpiomm_gpio_set_multiple;\r\ngpiommgpio->base = base[id];\r\nspin_lock_init(&gpiommgpio->lock);\r\nerr = devm_gpiochip_add_data(dev, &gpiommgpio->chip, gpiommgpio);\r\nif (err) {\r\ndev_err(dev, "GPIO registering failed (%d)\n", err);\r\nreturn err;\r\n}\r\noutb(0x80, base[id] + 3);\r\noutb(0x00, base[id]);\r\noutb(0x00, base[id] + 1);\r\noutb(0x00, base[id] + 2);\r\noutb(0x80, base[id] + 7);\r\noutb(0x00, base[id] + 4);\r\noutb(0x00, base[id] + 5);\r\noutb(0x00, base[id] + 6);\r\nreturn 0;\r\n}
