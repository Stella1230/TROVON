static void call_bios(struct regs *regs)\r\n{\r\nunsigned long flags;\r\npreempt_disable();\r\nlocal_irq_save(flags);\r\nasm volatile ("pushl %%ebp;"\r\n"movl %7, %%ebp;"\r\n"call *%6;"\r\n"popl %%ebp"\r\n: "=a" (regs->eax), "=b" (regs->ebx), "=c" (regs->ecx)\r\n: "0" (regs->eax), "1" (regs->ebx), "2" (regs->ecx),\r\n"m" (bios_entry_point), "m" (bios_data_map_base)\r\n: "edx", "edi", "esi", "memory");\r\nlocal_irq_restore(flags);\r\npreempt_enable();\r\n}\r\nstatic ssize_t __init locate_wistron_bios(void __iomem *base)\r\n{\r\nstatic unsigned char __initdata signature[] =\r\n{ 0x42, 0x21, 0x55, 0x30 };\r\nssize_t offset;\r\nfor (offset = 0; offset < 0x10000; offset += 0x10) {\r\nif (check_signature(base + offset, signature,\r\nsizeof(signature)) != 0)\r\nreturn offset;\r\n}\r\nreturn -1;\r\n}\r\nstatic int __init map_bios(void)\r\n{\r\nvoid __iomem *base;\r\nssize_t offset;\r\nu32 entry_point;\r\nbase = ioremap(0xF0000, 0x10000);\r\noffset = locate_wistron_bios(base);\r\nif (offset < 0) {\r\nprintk(KERN_ERR "wistron_btns: BIOS entry point not found\n");\r\niounmap(base);\r\nreturn -ENODEV;\r\n}\r\nentry_point = readl(base + offset + 5);\r\nprintk(KERN_DEBUG\r\n"wistron_btns: BIOS signature found at %p, entry point %08X\n",\r\nbase + offset, entry_point);\r\nif (entry_point >= 0xF0000) {\r\nbios_code_map_base = base;\r\nbios_entry_point = bios_code_map_base + (entry_point & 0xFFFF);\r\n} else {\r\niounmap(base);\r\nbios_code_map_base = ioremap(entry_point & ~0x3FFF, 0x4000);\r\nif (bios_code_map_base == NULL) {\r\nprintk(KERN_ERR\r\n"wistron_btns: Can't map BIOS code at %08X\n",\r\nentry_point & ~0x3FFF);\r\ngoto err;\r\n}\r\nbios_entry_point = bios_code_map_base + (entry_point & 0x3FFF);\r\n}\r\nbios_data_map_base = ioremap(0x400, 0xc00);\r\nif (bios_data_map_base == NULL) {\r\nprintk(KERN_ERR "wistron_btns: Can't map BIOS data\n");\r\ngoto err_code;\r\n}\r\nreturn 0;\r\nerr_code:\r\niounmap(bios_code_map_base);\r\nerr:\r\nreturn -ENOMEM;\r\n}\r\nstatic inline void unmap_bios(void)\r\n{\r\niounmap(bios_code_map_base);\r\niounmap(bios_data_map_base);\r\n}\r\nstatic u16 bios_pop_queue(void)\r\n{\r\nstruct regs regs;\r\nmemset(&regs, 0, sizeof (regs));\r\nregs.eax = 0x9610;\r\nregs.ebx = 0x061C;\r\nregs.ecx = 0x0000;\r\ncall_bios(&regs);\r\nreturn regs.eax;\r\n}\r\nstatic void bios_attach(void)\r\n{\r\nstruct regs regs;\r\nmemset(&regs, 0, sizeof (regs));\r\nregs.eax = 0x9610;\r\nregs.ebx = 0x012E;\r\ncall_bios(&regs);\r\n}\r\nstatic void bios_detach(void)\r\n{\r\nstruct regs regs;\r\nmemset(&regs, 0, sizeof (regs));\r\nregs.eax = 0x9610;\r\nregs.ebx = 0x002E;\r\ncall_bios(&regs);\r\n}\r\nstatic u8 bios_get_cmos_address(void)\r\n{\r\nstruct regs regs;\r\nmemset(&regs, 0, sizeof (regs));\r\nregs.eax = 0x9610;\r\nregs.ebx = 0x051C;\r\ncall_bios(&regs);\r\nreturn regs.ecx;\r\n}\r\nstatic u16 bios_get_default_setting(u8 subsys)\r\n{\r\nstruct regs regs;\r\nmemset(&regs, 0, sizeof (regs));\r\nregs.eax = 0x9610;\r\nregs.ebx = 0x0200 | subsys;\r\ncall_bios(&regs);\r\nreturn regs.eax;\r\n}\r\nstatic void bios_set_state(u8 subsys, int enable)\r\n{\r\nstruct regs regs;\r\nmemset(&regs, 0, sizeof (regs));\r\nregs.eax = 0x9610;\r\nregs.ebx = (enable ? 0x0100 : 0x0000) | subsys;\r\ncall_bios(&regs);\r\n}\r\nstatic int __init dmi_matched(const struct dmi_system_id *dmi)\r\n{\r\nconst struct key_entry *key;\r\nkeymap = dmi->driver_data;\r\nfor (key = keymap; key->type != KE_END; key++) {\r\nif (key->type == KE_WIFI)\r\nhave_wifi = true;\r\nelse if (key->type == KE_BLUETOOTH)\r\nhave_bluetooth = true;\r\n}\r\nleds_present = key->code & (FE_MAIL_LED | FE_WIFI_LED);\r\nreturn 1;\r\n}\r\nstatic int __init copy_keymap(void)\r\n{\r\nconst struct key_entry *key;\r\nstruct key_entry *new_keymap;\r\nunsigned int length = 1;\r\nfor (key = keymap; key->type != KE_END; key++)\r\nlength++;\r\nnew_keymap = kmemdup(keymap, length * sizeof(struct key_entry),\r\nGFP_KERNEL);\r\nif (!new_keymap)\r\nreturn -ENOMEM;\r\nkeymap = new_keymap;\r\nreturn 0;\r\n}\r\nstatic int __init select_keymap(void)\r\n{\r\ndmi_check_system(dmi_ids);\r\nif (keymap_name != NULL) {\r\nif (strcmp (keymap_name, "1557/MS2141") == 0)\r\nkeymap = keymap_wistron_ms2141;\r\nelse if (strcmp (keymap_name, "aopen1557") == 0)\r\nkeymap = keymap_aopen_1557;\r\nelse if (strcmp (keymap_name, "prestigio") == 0)\r\nkeymap = keymap_prestigio;\r\nelse if (strcmp (keymap_name, "generic") == 0)\r\nkeymap = keymap_wistron_generic;\r\nelse {\r\nprintk(KERN_ERR "wistron_btns: Keymap unknown\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (keymap == NULL) {\r\nif (!force) {\r\nprintk(KERN_ERR "wistron_btns: System unknown\n");\r\nreturn -ENODEV;\r\n}\r\nkeymap = keymap_empty;\r\n}\r\nreturn copy_keymap();\r\n}\r\nstatic void wistron_mail_led_set(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nbios_set_state(MAIL_LED, (value != LED_OFF) ? 1 : 0);\r\n}\r\nstatic void wistron_wifi_led_set(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nbios_set_state(WIFI, (value != LED_OFF) ? 1 : 0);\r\n}\r\nstatic void wistron_led_init(struct device *parent)\r\n{\r\nif (leds_present & FE_WIFI_LED) {\r\nu16 wifi = bios_get_default_setting(WIFI);\r\nif (wifi & 1) {\r\nwistron_wifi_led.brightness = (wifi & 2) ? LED_FULL : LED_OFF;\r\nif (led_classdev_register(parent, &wistron_wifi_led))\r\nleds_present &= ~FE_WIFI_LED;\r\nelse\r\nbios_set_state(WIFI, wistron_wifi_led.brightness);\r\n} else\r\nleds_present &= ~FE_WIFI_LED;\r\n}\r\nif (leds_present & FE_MAIL_LED) {\r\nwistron_mail_led.brightness = LED_OFF;\r\nif (led_classdev_register(parent, &wistron_mail_led))\r\nleds_present &= ~FE_MAIL_LED;\r\nelse\r\nbios_set_state(MAIL_LED, wistron_mail_led.brightness);\r\n}\r\n}\r\nstatic void wistron_led_remove(void)\r\n{\r\nif (leds_present & FE_MAIL_LED)\r\nled_classdev_unregister(&wistron_mail_led);\r\nif (leds_present & FE_WIFI_LED)\r\nled_classdev_unregister(&wistron_wifi_led);\r\n}\r\nstatic inline void wistron_led_suspend(void)\r\n{\r\nif (leds_present & FE_MAIL_LED)\r\nled_classdev_suspend(&wistron_mail_led);\r\nif (leds_present & FE_WIFI_LED)\r\nled_classdev_suspend(&wistron_wifi_led);\r\n}\r\nstatic inline void wistron_led_resume(void)\r\n{\r\nif (leds_present & FE_MAIL_LED)\r\nled_classdev_resume(&wistron_mail_led);\r\nif (leds_present & FE_WIFI_LED)\r\nled_classdev_resume(&wistron_wifi_led);\r\n}\r\nstatic void handle_key(u8 code)\r\n{\r\nconst struct key_entry *key =\r\nsparse_keymap_entry_from_scancode(wistron_idev->input, code);\r\nif (key) {\r\nswitch (key->type) {\r\ncase KE_WIFI:\r\nif (have_wifi) {\r\nwifi_enabled = !wifi_enabled;\r\nbios_set_state(WIFI, wifi_enabled);\r\n}\r\nbreak;\r\ncase KE_BLUETOOTH:\r\nif (have_bluetooth) {\r\nbluetooth_enabled = !bluetooth_enabled;\r\nbios_set_state(BLUETOOTH, bluetooth_enabled);\r\n}\r\nbreak;\r\ndefault:\r\nsparse_keymap_report_entry(wistron_idev->input,\r\nkey, 1, true);\r\nbreak;\r\n}\r\njiffies_last_press = jiffies;\r\n} else\r\nprintk(KERN_NOTICE\r\n"wistron_btns: Unknown key code %02X\n", code);\r\n}\r\nstatic void poll_bios(bool discard)\r\n{\r\nu8 qlen;\r\nu16 val;\r\nfor (;;) {\r\nqlen = CMOS_READ(cmos_address);\r\nif (qlen == 0)\r\nbreak;\r\nval = bios_pop_queue();\r\nif (val != 0 && !discard)\r\nhandle_key((u8)val);\r\n}\r\n}\r\nstatic void wistron_flush(struct input_polled_dev *dev)\r\n{\r\npoll_bios(true);\r\n}\r\nstatic void wistron_poll(struct input_polled_dev *dev)\r\n{\r\npoll_bios(false);\r\nif (time_before(jiffies, jiffies_last_press + 2 * HZ))\r\ndev->poll_interval = POLL_INTERVAL_BURST;\r\nelse\r\ndev->poll_interval = POLL_INTERVAL_DEFAULT;\r\n}\r\nstatic int wistron_setup_keymap(struct input_dev *dev,\r\nstruct key_entry *entry)\r\n{\r\nswitch (entry->type) {\r\ncase KE_WIFI:\r\nif (!have_wifi) {\r\nentry->type = KE_KEY;\r\nentry->keycode = KEY_WLAN;\r\n}\r\nbreak;\r\ncase KE_BLUETOOTH:\r\nif (!have_bluetooth) {\r\nentry->type = KE_KEY;\r\nentry->keycode = KEY_BLUETOOTH;\r\n}\r\nbreak;\r\ncase KE_END:\r\nif (entry->code & FE_UNTESTED)\r\nprintk(KERN_WARNING "Untested laptop multimedia keys, "\r\n"please report success or failure to "\r\n"eric.piel@tremplin-utc.net\n");\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int setup_input_dev(void)\r\n{\r\nstruct input_dev *input_dev;\r\nint error;\r\nwistron_idev = input_allocate_polled_device();\r\nif (!wistron_idev)\r\nreturn -ENOMEM;\r\nwistron_idev->open = wistron_flush;\r\nwistron_idev->poll = wistron_poll;\r\nwistron_idev->poll_interval = POLL_INTERVAL_DEFAULT;\r\ninput_dev = wistron_idev->input;\r\ninput_dev->name = "Wistron laptop buttons";\r\ninput_dev->phys = "wistron/input0";\r\ninput_dev->id.bustype = BUS_HOST;\r\ninput_dev->dev.parent = &wistron_device->dev;\r\nerror = sparse_keymap_setup(input_dev, keymap, wistron_setup_keymap);\r\nif (error)\r\ngoto err_free_dev;\r\nerror = input_register_polled_device(wistron_idev);\r\nif (error)\r\ngoto err_free_dev;\r\nreturn 0;\r\nerr_free_dev:\r\ninput_free_polled_device(wistron_idev);\r\nreturn error;\r\n}\r\nstatic int wistron_probe(struct platform_device *dev)\r\n{\r\nint err;\r\nbios_attach();\r\ncmos_address = bios_get_cmos_address();\r\nif (have_wifi) {\r\nu16 wifi = bios_get_default_setting(WIFI);\r\nif (wifi & 1)\r\nwifi_enabled = wifi & 2;\r\nelse\r\nhave_wifi = 0;\r\nif (have_wifi)\r\nbios_set_state(WIFI, wifi_enabled);\r\n}\r\nif (have_bluetooth) {\r\nu16 bt = bios_get_default_setting(BLUETOOTH);\r\nif (bt & 1)\r\nbluetooth_enabled = bt & 2;\r\nelse\r\nhave_bluetooth = false;\r\nif (have_bluetooth)\r\nbios_set_state(BLUETOOTH, bluetooth_enabled);\r\n}\r\nwistron_led_init(&dev->dev);\r\nerr = setup_input_dev();\r\nif (err) {\r\nbios_detach();\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wistron_remove(struct platform_device *dev)\r\n{\r\nwistron_led_remove();\r\ninput_unregister_polled_device(wistron_idev);\r\ninput_free_polled_device(wistron_idev);\r\nbios_detach();\r\nreturn 0;\r\n}\r\nstatic int wistron_suspend(struct device *dev)\r\n{\r\nif (have_wifi)\r\nbios_set_state(WIFI, 0);\r\nif (have_bluetooth)\r\nbios_set_state(BLUETOOTH, 0);\r\nwistron_led_suspend();\r\nreturn 0;\r\n}\r\nstatic int wistron_resume(struct device *dev)\r\n{\r\nif (have_wifi)\r\nbios_set_state(WIFI, wifi_enabled);\r\nif (have_bluetooth)\r\nbios_set_state(BLUETOOTH, bluetooth_enabled);\r\nwistron_led_resume();\r\npoll_bios(true);\r\nreturn 0;\r\n}\r\nstatic int __init wb_module_init(void)\r\n{\r\nint err;\r\nerr = select_keymap();\r\nif (err)\r\nreturn err;\r\nerr = map_bios();\r\nif (err)\r\ngoto err_free_keymap;\r\nerr = platform_driver_register(&wistron_driver);\r\nif (err)\r\ngoto err_unmap_bios;\r\nwistron_device = platform_device_alloc("wistron-bios", -1);\r\nif (!wistron_device) {\r\nerr = -ENOMEM;\r\ngoto err_unregister_driver;\r\n}\r\nerr = platform_device_add(wistron_device);\r\nif (err)\r\ngoto err_free_device;\r\nreturn 0;\r\nerr_free_device:\r\nplatform_device_put(wistron_device);\r\nerr_unregister_driver:\r\nplatform_driver_unregister(&wistron_driver);\r\nerr_unmap_bios:\r\nunmap_bios();\r\nerr_free_keymap:\r\nkfree(keymap);\r\nreturn err;\r\n}\r\nstatic void __exit wb_module_exit(void)\r\n{\r\nplatform_device_unregister(wistron_device);\r\nplatform_driver_unregister(&wistron_driver);\r\nunmap_bios();\r\nkfree(keymap);\r\n}
