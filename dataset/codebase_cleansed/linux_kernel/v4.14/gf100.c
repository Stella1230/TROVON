static u32\r\nread_vco(struct gf100_clk *clk, u32 dsrc)\r\n{\r\nstruct nvkm_device *device = clk->base.subdev.device;\r\nu32 ssrc = nvkm_rd32(device, dsrc);\r\nif (!(ssrc & 0x00000100))\r\nreturn nvkm_clk_read(&clk->base, nv_clk_src_sppll0);\r\nreturn nvkm_clk_read(&clk->base, nv_clk_src_sppll1);\r\n}\r\nstatic u32\r\nread_pll(struct gf100_clk *clk, u32 pll)\r\n{\r\nstruct nvkm_device *device = clk->base.subdev.device;\r\nu32 ctrl = nvkm_rd32(device, pll + 0x00);\r\nu32 coef = nvkm_rd32(device, pll + 0x04);\r\nu32 P = (coef & 0x003f0000) >> 16;\r\nu32 N = (coef & 0x0000ff00) >> 8;\r\nu32 M = (coef & 0x000000ff) >> 0;\r\nu32 sclk;\r\nif (!(ctrl & 0x00000001))\r\nreturn 0;\r\nswitch (pll) {\r\ncase 0x00e800:\r\ncase 0x00e820:\r\nsclk = device->crystal;\r\nP = 1;\r\nbreak;\r\ncase 0x132000:\r\nsclk = nvkm_clk_read(&clk->base, nv_clk_src_mpllsrc);\r\nbreak;\r\ncase 0x132020:\r\nsclk = nvkm_clk_read(&clk->base, nv_clk_src_mpllsrcref);\r\nbreak;\r\ncase 0x137000:\r\ncase 0x137020:\r\ncase 0x137040:\r\ncase 0x1370e0:\r\nsclk = read_div(clk, (pll & 0xff) / 0x20, 0x137120, 0x137140);\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn sclk * N / M / P;\r\n}\r\nstatic u32\r\nread_div(struct gf100_clk *clk, int doff, u32 dsrc, u32 dctl)\r\n{\r\nstruct nvkm_device *device = clk->base.subdev.device;\r\nu32 ssrc = nvkm_rd32(device, dsrc + (doff * 4));\r\nu32 sclk, sctl, sdiv = 2;\r\nswitch (ssrc & 0x00000003) {\r\ncase 0:\r\nif ((ssrc & 0x00030000) != 0x00030000)\r\nreturn device->crystal;\r\nreturn 108000;\r\ncase 2:\r\nreturn 100000;\r\ncase 3:\r\nsclk = read_vco(clk, dsrc + (doff * 4));\r\nif (doff <= 2) {\r\nsctl = nvkm_rd32(device, dctl + (doff * 4));\r\nif (sctl & 0x80000000) {\r\nif (ssrc & 0x100)\r\nsctl >>= 8;\r\nsdiv = (sctl & 0x3f) + 2;\r\n}\r\n}\r\nreturn (sclk * 2) / sdiv;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic u32\r\nread_clk(struct gf100_clk *clk, int idx)\r\n{\r\nstruct nvkm_device *device = clk->base.subdev.device;\r\nu32 sctl = nvkm_rd32(device, 0x137250 + (idx * 4));\r\nu32 ssel = nvkm_rd32(device, 0x137100);\r\nu32 sclk, sdiv;\r\nif (ssel & (1 << idx)) {\r\nif (idx < 7)\r\nsclk = read_pll(clk, 0x137000 + (idx * 0x20));\r\nelse\r\nsclk = read_pll(clk, 0x1370e0);\r\nsdiv = ((sctl & 0x00003f00) >> 8) + 2;\r\n} else {\r\nsclk = read_div(clk, idx, 0x137160, 0x1371d0);\r\nsdiv = ((sctl & 0x0000003f) >> 0) + 2;\r\n}\r\nif (sctl & 0x80000000)\r\nreturn (sclk * 2) / sdiv;\r\nreturn sclk;\r\n}\r\nstatic int\r\ngf100_clk_read(struct nvkm_clk *base, enum nv_clk_src src)\r\n{\r\nstruct gf100_clk *clk = gf100_clk(base);\r\nstruct nvkm_subdev *subdev = &clk->base.subdev;\r\nstruct nvkm_device *device = subdev->device;\r\nswitch (src) {\r\ncase nv_clk_src_crystal:\r\nreturn device->crystal;\r\ncase nv_clk_src_href:\r\nreturn 100000;\r\ncase nv_clk_src_sppll0:\r\nreturn read_pll(clk, 0x00e800);\r\ncase nv_clk_src_sppll1:\r\nreturn read_pll(clk, 0x00e820);\r\ncase nv_clk_src_mpllsrcref:\r\nreturn read_div(clk, 0, 0x137320, 0x137330);\r\ncase nv_clk_src_mpllsrc:\r\nreturn read_pll(clk, 0x132020);\r\ncase nv_clk_src_mpll:\r\nreturn read_pll(clk, 0x132000);\r\ncase nv_clk_src_mdiv:\r\nreturn read_div(clk, 0, 0x137300, 0x137310);\r\ncase nv_clk_src_mem:\r\nif (nvkm_rd32(device, 0x1373f0) & 0x00000002)\r\nreturn nvkm_clk_read(&clk->base, nv_clk_src_mpll);\r\nreturn nvkm_clk_read(&clk->base, nv_clk_src_mdiv);\r\ncase nv_clk_src_gpc:\r\nreturn read_clk(clk, 0x00);\r\ncase nv_clk_src_rop:\r\nreturn read_clk(clk, 0x01);\r\ncase nv_clk_src_hubk07:\r\nreturn read_clk(clk, 0x02);\r\ncase nv_clk_src_hubk06:\r\nreturn read_clk(clk, 0x07);\r\ncase nv_clk_src_hubk01:\r\nreturn read_clk(clk, 0x08);\r\ncase nv_clk_src_copy:\r\nreturn read_clk(clk, 0x09);\r\ncase nv_clk_src_pmu:\r\nreturn read_clk(clk, 0x0c);\r\ncase nv_clk_src_vdec:\r\nreturn read_clk(clk, 0x0e);\r\ndefault:\r\nnvkm_error(subdev, "invalid clock source %d\n", src);\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic u32\r\ncalc_div(struct gf100_clk *clk, int idx, u32 ref, u32 freq, u32 *ddiv)\r\n{\r\nu32 div = min((ref * 2) / freq, (u32)65);\r\nif (div < 2)\r\ndiv = 2;\r\n*ddiv = div - 2;\r\nreturn (ref * 2) / div;\r\n}\r\nstatic u32\r\ncalc_src(struct gf100_clk *clk, int idx, u32 freq, u32 *dsrc, u32 *ddiv)\r\n{\r\nu32 sclk;\r\n*ddiv = 0x00000000;\r\nswitch (freq) {\r\ncase 27000:\r\ncase 108000:\r\n*dsrc = 0x00000000;\r\nif (freq == 108000)\r\n*dsrc |= 0x00030000;\r\nreturn freq;\r\ncase 100000:\r\n*dsrc = 0x00000002;\r\nreturn freq;\r\ndefault:\r\n*dsrc = 0x00000003;\r\nbreak;\r\n}\r\nsclk = read_vco(clk, 0x137160 + (idx * 4));\r\nif (idx < 7)\r\nsclk = calc_div(clk, idx, sclk, freq, ddiv);\r\nreturn sclk;\r\n}\r\nstatic u32\r\ncalc_pll(struct gf100_clk *clk, int idx, u32 freq, u32 *coef)\r\n{\r\nstruct nvkm_subdev *subdev = &clk->base.subdev;\r\nstruct nvkm_bios *bios = subdev->device->bios;\r\nstruct nvbios_pll limits;\r\nint N, M, P, ret;\r\nret = nvbios_pll_parse(bios, 0x137000 + (idx * 0x20), &limits);\r\nif (ret)\r\nreturn 0;\r\nlimits.refclk = read_div(clk, idx, 0x137120, 0x137140);\r\nif (!limits.refclk)\r\nreturn 0;\r\nret = gt215_pll_calc(subdev, &limits, freq, &N, NULL, &M, &P);\r\nif (ret <= 0)\r\nreturn 0;\r\n*coef = (P << 16) | (N << 8) | M;\r\nreturn ret;\r\n}\r\nstatic int\r\ncalc_clk(struct gf100_clk *clk, struct nvkm_cstate *cstate, int idx, int dom)\r\n{\r\nstruct gf100_clk_info *info = &clk->eng[idx];\r\nu32 freq = cstate->domain[dom];\r\nu32 src0, div0, div1D, div1P = 0;\r\nu32 clk0, clk1 = 0;\r\nif (!freq)\r\nreturn 0;\r\nclk0 = calc_src(clk, idx, freq, &src0, &div0);\r\nclk0 = calc_div(clk, idx, clk0, freq, &div1D);\r\nif (clk0 != freq && (0x00004387 & (1 << idx))) {\r\nif (idx <= 7)\r\nclk1 = calc_pll(clk, idx, freq, &info->coef);\r\nelse\r\nclk1 = cstate->domain[nv_clk_src_hubk06];\r\nclk1 = calc_div(clk, idx, clk1, freq, &div1P);\r\n}\r\nif (abs((int)freq - clk0) <= abs((int)freq - clk1)) {\r\ninfo->dsrc = src0;\r\nif (div0) {\r\ninfo->ddiv |= 0x80000000;\r\ninfo->ddiv |= div0 << 8;\r\ninfo->ddiv |= div0;\r\n}\r\nif (div1D) {\r\ninfo->mdiv |= 0x80000000;\r\ninfo->mdiv |= div1D;\r\n}\r\ninfo->ssel = info->coef = 0;\r\ninfo->freq = clk0;\r\n} else {\r\nif (div1P) {\r\ninfo->mdiv |= 0x80000000;\r\ninfo->mdiv |= div1P << 8;\r\n}\r\ninfo->ssel = (1 << idx);\r\ninfo->freq = clk1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ngf100_clk_calc(struct nvkm_clk *base, struct nvkm_cstate *cstate)\r\n{\r\nstruct gf100_clk *clk = gf100_clk(base);\r\nint ret;\r\nif ((ret = calc_clk(clk, cstate, 0x00, nv_clk_src_gpc)) ||\r\n(ret = calc_clk(clk, cstate, 0x01, nv_clk_src_rop)) ||\r\n(ret = calc_clk(clk, cstate, 0x02, nv_clk_src_hubk07)) ||\r\n(ret = calc_clk(clk, cstate, 0x07, nv_clk_src_hubk06)) ||\r\n(ret = calc_clk(clk, cstate, 0x08, nv_clk_src_hubk01)) ||\r\n(ret = calc_clk(clk, cstate, 0x09, nv_clk_src_copy)) ||\r\n(ret = calc_clk(clk, cstate, 0x0c, nv_clk_src_pmu)) ||\r\n(ret = calc_clk(clk, cstate, 0x0e, nv_clk_src_vdec)))\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic void\r\ngf100_clk_prog_0(struct gf100_clk *clk, int idx)\r\n{\r\nstruct gf100_clk_info *info = &clk->eng[idx];\r\nstruct nvkm_device *device = clk->base.subdev.device;\r\nif (idx < 7 && !info->ssel) {\r\nnvkm_mask(device, 0x1371d0 + (idx * 0x04), 0x80003f3f, info->ddiv);\r\nnvkm_wr32(device, 0x137160 + (idx * 0x04), info->dsrc);\r\n}\r\n}\r\nstatic void\r\ngf100_clk_prog_1(struct gf100_clk *clk, int idx)\r\n{\r\nstruct nvkm_device *device = clk->base.subdev.device;\r\nnvkm_mask(device, 0x137100, (1 << idx), 0x00000000);\r\nnvkm_msec(device, 2000,\r\nif (!(nvkm_rd32(device, 0x137100) & (1 << idx)))\r\nbreak;\r\n);\r\n}\r\nstatic void\r\ngf100_clk_prog_2(struct gf100_clk *clk, int idx)\r\n{\r\nstruct gf100_clk_info *info = &clk->eng[idx];\r\nstruct nvkm_device *device = clk->base.subdev.device;\r\nconst u32 addr = 0x137000 + (idx * 0x20);\r\nif (idx <= 7) {\r\nnvkm_mask(device, addr + 0x00, 0x00000004, 0x00000000);\r\nnvkm_mask(device, addr + 0x00, 0x00000001, 0x00000000);\r\nif (info->coef) {\r\nnvkm_wr32(device, addr + 0x04, info->coef);\r\nnvkm_mask(device, addr + 0x00, 0x00000001, 0x00000001);\r\nnvkm_mask(device, addr + 0x00, 0x00000010, 0x00000000);\r\nnvkm_msec(device, 2000,\r\nif (nvkm_rd32(device, addr + 0x00) & 0x00020000)\r\nbreak;\r\n);\r\nnvkm_mask(device, addr + 0x00, 0x00000010, 0x00000010);\r\nnvkm_mask(device, addr + 0x00, 0x00000004, 0x00000004);\r\n}\r\n}\r\n}\r\nstatic void\r\ngf100_clk_prog_3(struct gf100_clk *clk, int idx)\r\n{\r\nstruct gf100_clk_info *info = &clk->eng[idx];\r\nstruct nvkm_device *device = clk->base.subdev.device;\r\nif (info->ssel) {\r\nnvkm_mask(device, 0x137100, (1 << idx), info->ssel);\r\nnvkm_msec(device, 2000,\r\nu32 tmp = nvkm_rd32(device, 0x137100) & (1 << idx);\r\nif (tmp == info->ssel)\r\nbreak;\r\n);\r\n}\r\n}\r\nstatic void\r\ngf100_clk_prog_4(struct gf100_clk *clk, int idx)\r\n{\r\nstruct gf100_clk_info *info = &clk->eng[idx];\r\nstruct nvkm_device *device = clk->base.subdev.device;\r\nnvkm_mask(device, 0x137250 + (idx * 0x04), 0x00003f3f, info->mdiv);\r\n}\r\nstatic int\r\ngf100_clk_prog(struct nvkm_clk *base)\r\n{\r\nstruct gf100_clk *clk = gf100_clk(base);\r\nstruct {\r\nvoid (*exec)(struct gf100_clk *, int);\r\n} stage[] = {\r\n{ gf100_clk_prog_0 },\r\n{ gf100_clk_prog_1 },\r\n{ gf100_clk_prog_2 },\r\n{ gf100_clk_prog_3 },\r\n{ gf100_clk_prog_4 },\r\n};\r\nint i, j;\r\nfor (i = 0; i < ARRAY_SIZE(stage); i++) {\r\nfor (j = 0; j < ARRAY_SIZE(clk->eng); j++) {\r\nif (!clk->eng[j].freq)\r\ncontinue;\r\nstage[i].exec(clk, j);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\ngf100_clk_tidy(struct nvkm_clk *base)\r\n{\r\nstruct gf100_clk *clk = gf100_clk(base);\r\nmemset(clk->eng, 0x00, sizeof(clk->eng));\r\n}\r\nint\r\ngf100_clk_new(struct nvkm_device *device, int index, struct nvkm_clk **pclk)\r\n{\r\nstruct gf100_clk *clk;\r\nif (!(clk = kzalloc(sizeof(*clk), GFP_KERNEL)))\r\nreturn -ENOMEM;\r\n*pclk = &clk->base;\r\nreturn nvkm_clk_ctor(&gf100_clk, device, index, false, &clk->base);\r\n}
