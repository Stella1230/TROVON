static void psc_config(void __iomem *control_base, void __iomem *domain_base,\r\nu32 next_state, u32 domain_id)\r\n{\r\nu32 ptcmd, pdstat, pdctl, mdstat, mdctl, ptstat;\r\nu32 count = STATE_TRANS_MAX_COUNT;\r\nmdctl = readl(control_base + MDCTL);\r\nmdctl &= ~MDSTAT_STATE_MASK;\r\nmdctl |= next_state;\r\nif (next_state == PSC_STATE_DISABLE)\r\nmdctl &= ~MDCTL_LRESET;\r\nwritel(mdctl, control_base + MDCTL);\r\npdstat = readl(domain_base + PDSTAT);\r\nif (!(pdstat & PDSTAT_STATE_MASK)) {\r\npdctl = readl(domain_base + PDCTL);\r\npdctl |= PDCTL_NEXT;\r\nwritel(pdctl, domain_base + PDCTL);\r\n}\r\nptcmd = 1 << domain_id;\r\nwritel(ptcmd, domain_transition_base + PTCMD);\r\ndo {\r\nptstat = readl(domain_transition_base + PTSTAT);\r\n} while (((ptstat >> domain_id) & 1) && count--);\r\ncount = STATE_TRANS_MAX_COUNT;\r\ndo {\r\nmdstat = readl(control_base + MDSTAT);\r\n} while (!((mdstat & MDSTAT_STATE_MASK) == next_state) && count--);\r\n}\r\nstatic int keystone_clk_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct clk_psc *psc = to_clk_psc(hw);\r\nstruct clk_psc_data *data = psc->psc_data;\r\nu32 mdstat = readl(data->control_base + MDSTAT);\r\nreturn (mdstat & MDSTAT_MCKOUT) ? 1 : 0;\r\n}\r\nstatic int keystone_clk_enable(struct clk_hw *hw)\r\n{\r\nstruct clk_psc *psc = to_clk_psc(hw);\r\nstruct clk_psc_data *data = psc->psc_data;\r\nunsigned long flags = 0;\r\nif (psc->lock)\r\nspin_lock_irqsave(psc->lock, flags);\r\npsc_config(data->control_base, data->domain_base,\r\nPSC_STATE_ENABLE, data->domain_id);\r\nif (psc->lock)\r\nspin_unlock_irqrestore(psc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void keystone_clk_disable(struct clk_hw *hw)\r\n{\r\nstruct clk_psc *psc = to_clk_psc(hw);\r\nstruct clk_psc_data *data = psc->psc_data;\r\nunsigned long flags = 0;\r\nif (psc->lock)\r\nspin_lock_irqsave(psc->lock, flags);\r\npsc_config(data->control_base, data->domain_base,\r\nPSC_STATE_DISABLE, data->domain_id);\r\nif (psc->lock)\r\nspin_unlock_irqrestore(psc->lock, flags);\r\n}\r\nstatic struct clk *clk_register_psc(struct device *dev,\r\nconst char *name,\r\nconst char *parent_name,\r\nstruct clk_psc_data *psc_data,\r\nspinlock_t *lock)\r\n{\r\nstruct clk_init_data init;\r\nstruct clk_psc *psc;\r\nstruct clk *clk;\r\npsc = kzalloc(sizeof(*psc), GFP_KERNEL);\r\nif (!psc)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = name;\r\ninit.ops = &clk_psc_ops;\r\ninit.flags = 0;\r\ninit.parent_names = (parent_name ? &parent_name : NULL);\r\ninit.num_parents = (parent_name ? 1 : 0);\r\npsc->psc_data = psc_data;\r\npsc->lock = lock;\r\npsc->hw.init = &init;\r\nclk = clk_register(NULL, &psc->hw);\r\nif (IS_ERR(clk))\r\nkfree(psc);\r\nreturn clk;\r\n}\r\nstatic void __init of_psc_clk_init(struct device_node *node, spinlock_t *lock)\r\n{\r\nconst char *clk_name = node->name;\r\nconst char *parent_name;\r\nstruct clk_psc_data *data;\r\nstruct clk *clk;\r\nint i;\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (!data) {\r\npr_err("%s: Out of memory\n", __func__);\r\nreturn;\r\n}\r\ni = of_property_match_string(node, "reg-names", "control");\r\ndata->control_base = of_iomap(node, i);\r\nif (!data->control_base) {\r\npr_err("%s: control ioremap failed\n", __func__);\r\ngoto out;\r\n}\r\ni = of_property_match_string(node, "reg-names", "domain");\r\ndata->domain_base = of_iomap(node, i);\r\nif (!data->domain_base) {\r\npr_err("%s: domain ioremap failed\n", __func__);\r\ngoto unmap_ctrl;\r\n}\r\nof_property_read_u32(node, "domain-id", &data->domain_id);\r\nif (!domain_transition_base && !data->domain_id)\r\ndomain_transition_base = data->domain_base;\r\nof_property_read_string(node, "clock-output-names", &clk_name);\r\nparent_name = of_clk_get_parent_name(node, 0);\r\nif (!parent_name) {\r\npr_err("%s: Parent clock not found\n", __func__);\r\ngoto unmap_domain;\r\n}\r\nclk = clk_register_psc(NULL, clk_name, parent_name, data, lock);\r\nif (!IS_ERR(clk)) {\r\nof_clk_add_provider(node, of_clk_src_simple_get, clk);\r\nreturn;\r\n}\r\npr_err("%s: error registering clk %s\n", __func__, node->name);\r\nunmap_domain:\r\niounmap(data->domain_base);\r\nunmap_ctrl:\r\niounmap(data->control_base);\r\nout:\r\nkfree(data);\r\nreturn;\r\n}\r\nstatic void __init of_keystone_psc_clk_init(struct device_node *node)\r\n{\r\nof_psc_clk_init(node, &psc_lock);\r\n}
