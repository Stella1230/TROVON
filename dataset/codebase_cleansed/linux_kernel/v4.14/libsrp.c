static int srp_iu_pool_alloc(struct srp_queue *q, size_t max,\r\nstruct srp_buf **ring)\r\n{\r\nstruct iu_entry *iue;\r\nint i;\r\nq->pool = kcalloc(max, sizeof(struct iu_entry *), GFP_KERNEL);\r\nif (!q->pool)\r\nreturn -ENOMEM;\r\nq->items = kcalloc(max, sizeof(struct iu_entry), GFP_KERNEL);\r\nif (!q->items)\r\ngoto free_pool;\r\nspin_lock_init(&q->lock);\r\nkfifo_init(&q->queue, (void *)q->pool, max * sizeof(void *));\r\nfor (i = 0, iue = q->items; i < max; i++) {\r\nkfifo_in(&q->queue, (void *)&iue, sizeof(void *));\r\niue->sbuf = ring[i];\r\niue++;\r\n}\r\nreturn 0;\r\nfree_pool:\r\nkfree(q->pool);\r\nreturn -ENOMEM;\r\n}\r\nstatic void srp_iu_pool_free(struct srp_queue *q)\r\n{\r\nkfree(q->items);\r\nkfree(q->pool);\r\n}\r\nstatic struct srp_buf **srp_ring_alloc(struct device *dev,\r\nsize_t max, size_t size)\r\n{\r\nstruct srp_buf **ring;\r\nint i;\r\nring = kcalloc(max, sizeof(struct srp_buf *), GFP_KERNEL);\r\nif (!ring)\r\nreturn NULL;\r\nfor (i = 0; i < max; i++) {\r\nring[i] = kzalloc(sizeof(*ring[i]), GFP_KERNEL);\r\nif (!ring[i])\r\ngoto out;\r\nring[i]->buf = dma_alloc_coherent(dev, size, &ring[i]->dma,\r\nGFP_KERNEL);\r\nif (!ring[i]->buf)\r\ngoto out;\r\n}\r\nreturn ring;\r\nout:\r\nfor (i = 0; i < max && ring[i]; i++) {\r\nif (ring[i]->buf) {\r\ndma_free_coherent(dev, size, ring[i]->buf,\r\nring[i]->dma);\r\n}\r\nkfree(ring[i]);\r\n}\r\nkfree(ring);\r\nreturn NULL;\r\n}\r\nstatic void srp_ring_free(struct device *dev, struct srp_buf **ring,\r\nsize_t max, size_t size)\r\n{\r\nint i;\r\nfor (i = 0; i < max; i++) {\r\ndma_free_coherent(dev, size, ring[i]->buf, ring[i]->dma);\r\nkfree(ring[i]);\r\n}\r\nkfree(ring);\r\n}\r\nint srp_target_alloc(struct srp_target *target, struct device *dev,\r\nsize_t nr, size_t iu_size)\r\n{\r\nint err;\r\nspin_lock_init(&target->lock);\r\ntarget->dev = dev;\r\ntarget->srp_iu_size = iu_size;\r\ntarget->rx_ring_size = nr;\r\ntarget->rx_ring = srp_ring_alloc(target->dev, nr, iu_size);\r\nif (!target->rx_ring)\r\nreturn -ENOMEM;\r\nerr = srp_iu_pool_alloc(&target->iu_queue, nr, target->rx_ring);\r\nif (err)\r\ngoto free_ring;\r\ndev_set_drvdata(target->dev, target);\r\nreturn 0;\r\nfree_ring:\r\nsrp_ring_free(target->dev, target->rx_ring, nr, iu_size);\r\nreturn -ENOMEM;\r\n}\r\nvoid srp_target_free(struct srp_target *target)\r\n{\r\ndev_set_drvdata(target->dev, NULL);\r\nsrp_ring_free(target->dev, target->rx_ring, target->rx_ring_size,\r\ntarget->srp_iu_size);\r\nsrp_iu_pool_free(&target->iu_queue);\r\n}\r\nstruct iu_entry *srp_iu_get(struct srp_target *target)\r\n{\r\nstruct iu_entry *iue = NULL;\r\nif (kfifo_out_locked(&target->iu_queue.queue, (void *)&iue,\r\nsizeof(void *),\r\n&target->iu_queue.lock) != sizeof(void *)) {\r\nWARN_ONCE(1, "unexpected fifo state");\r\nreturn NULL;\r\n}\r\nif (!iue)\r\nreturn iue;\r\niue->target = target;\r\niue->flags = 0;\r\nreturn iue;\r\n}\r\nvoid srp_iu_put(struct iu_entry *iue)\r\n{\r\nkfifo_in_locked(&iue->target->iu_queue.queue, (void *)&iue,\r\nsizeof(void *), &iue->target->iu_queue.lock);\r\n}\r\nstatic int srp_direct_data(struct ibmvscsis_cmd *cmd, struct srp_direct_buf *md,\r\nenum dma_data_direction dir, srp_rdma_t rdma_io,\r\nint dma_map, int ext_desc)\r\n{\r\nstruct iu_entry *iue = NULL;\r\nstruct scatterlist *sg = NULL;\r\nint err, nsg = 0, len;\r\nif (dma_map) {\r\niue = cmd->iue;\r\nsg = cmd->se_cmd.t_data_sg;\r\nnsg = dma_map_sg(iue->target->dev, sg, cmd->se_cmd.t_data_nents,\r\nDMA_BIDIRECTIONAL);\r\nif (!nsg) {\r\npr_err("fail to map %p %d\n", iue,\r\ncmd->se_cmd.t_data_nents);\r\nreturn 0;\r\n}\r\nlen = min(cmd->se_cmd.data_length, be32_to_cpu(md->len));\r\n} else {\r\nlen = be32_to_cpu(md->len);\r\n}\r\nerr = rdma_io(cmd, sg, nsg, md, 1, dir, len);\r\nif (dma_map)\r\ndma_unmap_sg(iue->target->dev, sg, nsg, DMA_BIDIRECTIONAL);\r\nreturn err;\r\n}\r\nstatic int srp_indirect_data(struct ibmvscsis_cmd *cmd, struct srp_cmd *srp_cmd,\r\nstruct srp_indirect_buf *id,\r\nenum dma_data_direction dir, srp_rdma_t rdma_io,\r\nint dma_map, int ext_desc)\r\n{\r\nstruct iu_entry *iue = NULL;\r\nstruct srp_direct_buf *md = NULL;\r\nstruct scatterlist dummy, *sg = NULL;\r\ndma_addr_t token = 0;\r\nint err = 0;\r\nint nmd, nsg = 0, len;\r\nif (dma_map || ext_desc) {\r\niue = cmd->iue;\r\nsg = cmd->se_cmd.t_data_sg;\r\n}\r\nnmd = be32_to_cpu(id->table_desc.len) / sizeof(struct srp_direct_buf);\r\nif ((dir == DMA_FROM_DEVICE && nmd == srp_cmd->data_in_desc_cnt) ||\r\n(dir == DMA_TO_DEVICE && nmd == srp_cmd->data_out_desc_cnt)) {\r\nmd = &id->desc_list[0];\r\ngoto rdma;\r\n}\r\nif (ext_desc && dma_map) {\r\nmd = dma_alloc_coherent(iue->target->dev,\r\nbe32_to_cpu(id->table_desc.len),\r\n&token, GFP_KERNEL);\r\nif (!md) {\r\npr_err("Can't get dma memory %u\n",\r\nbe32_to_cpu(id->table_desc.len));\r\nreturn -ENOMEM;\r\n}\r\nsg_init_one(&dummy, md, be32_to_cpu(id->table_desc.len));\r\nsg_dma_address(&dummy) = token;\r\nsg_dma_len(&dummy) = be32_to_cpu(id->table_desc.len);\r\nerr = rdma_io(cmd, &dummy, 1, &id->table_desc, 1, DMA_TO_DEVICE,\r\nbe32_to_cpu(id->table_desc.len));\r\nif (err) {\r\npr_err("Error copying indirect table %d\n", err);\r\ngoto free_mem;\r\n}\r\n} else {\r\npr_err("This command uses external indirect buffer\n");\r\nreturn -EINVAL;\r\n}\r\nrdma:\r\nif (dma_map) {\r\nnsg = dma_map_sg(iue->target->dev, sg, cmd->se_cmd.t_data_nents,\r\nDMA_BIDIRECTIONAL);\r\nif (!nsg) {\r\npr_err("fail to map %p %d\n", iue,\r\ncmd->se_cmd.t_data_nents);\r\nerr = -EIO;\r\ngoto free_mem;\r\n}\r\nlen = min(cmd->se_cmd.data_length, be32_to_cpu(id->len));\r\n} else {\r\nlen = be32_to_cpu(id->len);\r\n}\r\nerr = rdma_io(cmd, sg, nsg, md, nmd, dir, len);\r\nif (dma_map)\r\ndma_unmap_sg(iue->target->dev, sg, nsg, DMA_BIDIRECTIONAL);\r\nfree_mem:\r\nif (token && dma_map) {\r\ndma_free_coherent(iue->target->dev,\r\nbe32_to_cpu(id->table_desc.len), md, token);\r\n}\r\nreturn err;\r\n}\r\nstatic int data_out_desc_size(struct srp_cmd *cmd)\r\n{\r\nint size = 0;\r\nu8 fmt = cmd->buf_fmt >> 4;\r\nswitch (fmt) {\r\ncase SRP_NO_DATA_DESC:\r\nbreak;\r\ncase SRP_DATA_DESC_DIRECT:\r\nsize = sizeof(struct srp_direct_buf);\r\nbreak;\r\ncase SRP_DATA_DESC_INDIRECT:\r\nsize = sizeof(struct srp_indirect_buf) +\r\nsizeof(struct srp_direct_buf) * cmd->data_out_desc_cnt;\r\nbreak;\r\ndefault:\r\npr_err("client error. Invalid data_out_format %x\n", fmt);\r\nbreak;\r\n}\r\nreturn size;\r\n}\r\nint srp_transfer_data(struct ibmvscsis_cmd *cmd, struct srp_cmd *srp_cmd,\r\nsrp_rdma_t rdma_io, int dma_map, int ext_desc)\r\n{\r\nstruct srp_direct_buf *md;\r\nstruct srp_indirect_buf *id;\r\nenum dma_data_direction dir;\r\nint offset, err = 0;\r\nu8 format;\r\nif (!cmd->se_cmd.t_data_nents)\r\nreturn 0;\r\noffset = srp_cmd->add_cdb_len & ~3;\r\ndir = srp_cmd_direction(srp_cmd);\r\nif (dir == DMA_FROM_DEVICE)\r\noffset += data_out_desc_size(srp_cmd);\r\nif (dir == DMA_TO_DEVICE)\r\nformat = srp_cmd->buf_fmt >> 4;\r\nelse\r\nformat = srp_cmd->buf_fmt & ((1U << 4) - 1);\r\nswitch (format) {\r\ncase SRP_NO_DATA_DESC:\r\nbreak;\r\ncase SRP_DATA_DESC_DIRECT:\r\nmd = (struct srp_direct_buf *)(srp_cmd->add_data + offset);\r\nerr = srp_direct_data(cmd, md, dir, rdma_io, dma_map, ext_desc);\r\nbreak;\r\ncase SRP_DATA_DESC_INDIRECT:\r\nid = (struct srp_indirect_buf *)(srp_cmd->add_data + offset);\r\nerr = srp_indirect_data(cmd, srp_cmd, id, dir, rdma_io, dma_map,\r\next_desc);\r\nbreak;\r\ndefault:\r\npr_err("Unknown format %d %x\n", dir, format);\r\nerr = -EINVAL;\r\n}\r\nreturn err;\r\n}\r\nu64 srp_data_length(struct srp_cmd *cmd, enum dma_data_direction dir)\r\n{\r\nstruct srp_direct_buf *md;\r\nstruct srp_indirect_buf *id;\r\nu64 len = 0;\r\nuint offset = cmd->add_cdb_len & ~3;\r\nu8 fmt;\r\nif (dir == DMA_TO_DEVICE) {\r\nfmt = cmd->buf_fmt >> 4;\r\n} else {\r\nfmt = cmd->buf_fmt & ((1U << 4) - 1);\r\noffset += data_out_desc_size(cmd);\r\n}\r\nswitch (fmt) {\r\ncase SRP_NO_DATA_DESC:\r\nbreak;\r\ncase SRP_DATA_DESC_DIRECT:\r\nmd = (struct srp_direct_buf *)(cmd->add_data + offset);\r\nlen = be32_to_cpu(md->len);\r\nbreak;\r\ncase SRP_DATA_DESC_INDIRECT:\r\nid = (struct srp_indirect_buf *)(cmd->add_data + offset);\r\nlen = be32_to_cpu(id->len);\r\nbreak;\r\ndefault:\r\npr_err("invalid data format %x\n", fmt);\r\nbreak;\r\n}\r\nreturn len;\r\n}\r\nint srp_get_desc_table(struct srp_cmd *srp_cmd, enum dma_data_direction *dir,\r\nu64 *data_len)\r\n{\r\nstruct srp_indirect_buf *idb;\r\nstruct srp_direct_buf *db;\r\nuint add_cdb_offset;\r\nint rc;\r\nBUILD_BUG_ON(!__same_type(srp_cmd->add_data[0], (s8)0)\r\n&& !__same_type(srp_cmd->add_data[0], (u8)0));\r\nBUG_ON(!dir);\r\nBUG_ON(!data_len);\r\nrc = 0;\r\n*data_len = 0;\r\n*dir = DMA_NONE;\r\nif (srp_cmd->buf_fmt & 0xf)\r\n*dir = DMA_FROM_DEVICE;\r\nelse if (srp_cmd->buf_fmt >> 4)\r\n*dir = DMA_TO_DEVICE;\r\nadd_cdb_offset = srp_cmd->add_cdb_len & ~3;\r\nif (((srp_cmd->buf_fmt & 0xf) == SRP_DATA_DESC_DIRECT) ||\r\n((srp_cmd->buf_fmt >> 4) == SRP_DATA_DESC_DIRECT)) {\r\ndb = (struct srp_direct_buf *)(srp_cmd->add_data\r\n+ add_cdb_offset);\r\n*data_len = be32_to_cpu(db->len);\r\n} else if (((srp_cmd->buf_fmt & 0xf) == SRP_DATA_DESC_INDIRECT) ||\r\n((srp_cmd->buf_fmt >> 4) == SRP_DATA_DESC_INDIRECT)) {\r\nidb = (struct srp_indirect_buf *)(srp_cmd->add_data\r\n+ add_cdb_offset);\r\n*data_len = be32_to_cpu(idb->len);\r\n}\r\nreturn rc;\r\n}
