static int pwm_beeper_on(struct pwm_beeper *beeper, unsigned long period)\r\n{\r\nstruct pwm_state state;\r\nint error;\r\npwm_get_state(beeper->pwm, &state);\r\nstate.enabled = true;\r\nstate.period = period;\r\npwm_set_relative_duty_cycle(&state, 50, 100);\r\nerror = pwm_apply_state(beeper->pwm, &state);\r\nif (error)\r\nreturn error;\r\nif (!beeper->amplifier_on) {\r\nerror = regulator_enable(beeper->amplifier);\r\nif (error) {\r\npwm_disable(beeper->pwm);\r\nreturn error;\r\n}\r\nbeeper->amplifier_on = true;\r\n}\r\nreturn 0;\r\n}\r\nstatic void pwm_beeper_off(struct pwm_beeper *beeper)\r\n{\r\nif (beeper->amplifier_on) {\r\nregulator_disable(beeper->amplifier);\r\nbeeper->amplifier_on = false;\r\n}\r\npwm_disable(beeper->pwm);\r\n}\r\nstatic void pwm_beeper_work(struct work_struct *work)\r\n{\r\nstruct pwm_beeper *beeper = container_of(work, struct pwm_beeper, work);\r\nunsigned long period = READ_ONCE(beeper->period);\r\nif (period)\r\npwm_beeper_on(beeper, period);\r\nelse\r\npwm_beeper_off(beeper);\r\n}\r\nstatic int pwm_beeper_event(struct input_dev *input,\r\nunsigned int type, unsigned int code, int value)\r\n{\r\nstruct pwm_beeper *beeper = input_get_drvdata(input);\r\nif (type != EV_SND || value < 0)\r\nreturn -EINVAL;\r\nswitch (code) {\r\ncase SND_BELL:\r\nvalue = value ? beeper->bell_frequency : 0;\r\nbreak;\r\ncase SND_TONE:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (value == 0)\r\nbeeper->period = 0;\r\nelse\r\nbeeper->period = HZ_TO_NANOSECONDS(value);\r\nif (!beeper->suspended)\r\nschedule_work(&beeper->work);\r\nreturn 0;\r\n}\r\nstatic void pwm_beeper_stop(struct pwm_beeper *beeper)\r\n{\r\ncancel_work_sync(&beeper->work);\r\npwm_beeper_off(beeper);\r\n}\r\nstatic void pwm_beeper_close(struct input_dev *input)\r\n{\r\nstruct pwm_beeper *beeper = input_get_drvdata(input);\r\npwm_beeper_stop(beeper);\r\n}\r\nstatic int pwm_beeper_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct pwm_beeper *beeper;\r\nstruct pwm_state state;\r\nu32 bell_frequency;\r\nint error;\r\nbeeper = devm_kzalloc(dev, sizeof(*beeper), GFP_KERNEL);\r\nif (!beeper)\r\nreturn -ENOMEM;\r\nbeeper->pwm = devm_pwm_get(dev, NULL);\r\nif (IS_ERR(beeper->pwm)) {\r\nerror = PTR_ERR(beeper->pwm);\r\nif (error != -EPROBE_DEFER)\r\ndev_err(dev, "Failed to request PWM device: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\npwm_init_state(beeper->pwm, &state);\r\nstate.enabled = false;\r\nerror = pwm_apply_state(beeper->pwm, &state);\r\nif (error) {\r\ndev_err(dev, "failed to apply initial PWM state: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nbeeper->amplifier = devm_regulator_get(dev, "amp");\r\nif (IS_ERR(beeper->amplifier)) {\r\nerror = PTR_ERR(beeper->amplifier);\r\nif (error != -EPROBE_DEFER)\r\ndev_err(dev, "Failed to get 'amp' regulator: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nINIT_WORK(&beeper->work, pwm_beeper_work);\r\nerror = device_property_read_u32(dev, "beeper-hz", &bell_frequency);\r\nif (error) {\r\nbell_frequency = 1000;\r\ndev_dbg(dev,\r\n"failed to parse 'beeper-hz' property, using default: %uHz\n",\r\nbell_frequency);\r\n}\r\nbeeper->bell_frequency = bell_frequency;\r\nbeeper->input = devm_input_allocate_device(dev);\r\nif (!beeper->input) {\r\ndev_err(dev, "Failed to allocate input device\n");\r\nreturn -ENOMEM;\r\n}\r\nbeeper->input->name = "pwm-beeper";\r\nbeeper->input->phys = "pwm/input0";\r\nbeeper->input->id.bustype = BUS_HOST;\r\nbeeper->input->id.vendor = 0x001f;\r\nbeeper->input->id.product = 0x0001;\r\nbeeper->input->id.version = 0x0100;\r\ninput_set_capability(beeper->input, EV_SND, SND_TONE);\r\ninput_set_capability(beeper->input, EV_SND, SND_BELL);\r\nbeeper->input->event = pwm_beeper_event;\r\nbeeper->input->close = pwm_beeper_close;\r\ninput_set_drvdata(beeper->input, beeper);\r\nerror = input_register_device(beeper->input);\r\nif (error) {\r\ndev_err(dev, "Failed to register input device: %d\n", error);\r\nreturn error;\r\n}\r\nplatform_set_drvdata(pdev, beeper);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused pwm_beeper_suspend(struct device *dev)\r\n{\r\nstruct pwm_beeper *beeper = dev_get_drvdata(dev);\r\nspin_lock_irq(&beeper->input->event_lock);\r\nbeeper->suspended = true;\r\nspin_unlock_irq(&beeper->input->event_lock);\r\npwm_beeper_stop(beeper);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused pwm_beeper_resume(struct device *dev)\r\n{\r\nstruct pwm_beeper *beeper = dev_get_drvdata(dev);\r\nspin_lock_irq(&beeper->input->event_lock);\r\nbeeper->suspended = false;\r\nspin_unlock_irq(&beeper->input->event_lock);\r\nschedule_work(&beeper->work);\r\nreturn 0;\r\n}
