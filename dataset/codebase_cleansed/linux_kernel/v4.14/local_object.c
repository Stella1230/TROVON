static long rxrpc_local_cmp_key(const struct rxrpc_local *local,\r\nconst struct sockaddr_rxrpc *srx)\r\n{\r\nlong diff;\r\ndiff = ((local->srx.transport_type - srx->transport_type) ?:\r\n(local->srx.transport_len - srx->transport_len) ?:\r\n(local->srx.transport.family - srx->transport.family));\r\nif (diff != 0)\r\nreturn diff;\r\nswitch (srx->transport.family) {\r\ncase AF_INET:\r\nreturn ((u16 __force)local->srx.transport.sin.sin_port -\r\n(u16 __force)srx->transport.sin.sin_port) ?:\r\nmemcmp(&local->srx.transport.sin.sin_addr,\r\n&srx->transport.sin.sin_addr,\r\nsizeof(struct in_addr));\r\n#ifdef CONFIG_AF_RXRPC_IPV6\r\ncase AF_INET6:\r\nreturn ((u16 __force)local->srx.transport.sin6.sin6_port -\r\n(u16 __force)srx->transport.sin6.sin6_port) ?:\r\nmemcmp(&local->srx.transport.sin6.sin6_addr,\r\n&srx->transport.sin6.sin6_addr,\r\nsizeof(struct in6_addr));\r\n#endif\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic struct rxrpc_local *rxrpc_alloc_local(struct rxrpc_net *rxnet,\r\nconst struct sockaddr_rxrpc *srx)\r\n{\r\nstruct rxrpc_local *local;\r\nlocal = kzalloc(sizeof(struct rxrpc_local), GFP_KERNEL);\r\nif (local) {\r\natomic_set(&local->usage, 1);\r\nlocal->rxnet = rxnet;\r\nINIT_LIST_HEAD(&local->link);\r\nINIT_WORK(&local->processor, rxrpc_local_processor);\r\ninit_rwsem(&local->defrag_sem);\r\nskb_queue_head_init(&local->reject_queue);\r\nskb_queue_head_init(&local->event_queue);\r\nlocal->client_conns = RB_ROOT;\r\nspin_lock_init(&local->client_conns_lock);\r\nspin_lock_init(&local->lock);\r\nrwlock_init(&local->services_lock);\r\nlocal->debug_id = atomic_inc_return(&rxrpc_debug_id);\r\nmemcpy(&local->srx, srx, sizeof(*srx));\r\nlocal->srx.srx_service = 0;\r\n}\r\n_leave(" = %p", local);\r\nreturn local;\r\n}\r\nstatic int rxrpc_open_socket(struct rxrpc_local *local, struct net *net)\r\n{\r\nstruct sock *sock;\r\nint ret, opt;\r\n_enter("%p{%d,%d}",\r\nlocal, local->srx.transport_type, local->srx.transport.family);\r\nret = sock_create_kern(net, local->srx.transport.family,\r\nlocal->srx.transport_type, 0, &local->socket);\r\nif (ret < 0) {\r\n_leave(" = %d [socket]", ret);\r\nreturn ret;\r\n}\r\nif (local->srx.transport_len > sizeof(sa_family_t)) {\r\n_debug("bind");\r\nret = kernel_bind(local->socket,\r\n(struct sockaddr *)&local->srx.transport,\r\nlocal->srx.transport_len);\r\nif (ret < 0) {\r\n_debug("bind failed %d", ret);\r\ngoto error;\r\n}\r\n}\r\nopt = 1;\r\nret = kernel_setsockopt(local->socket, SOL_IP, IP_RECVERR,\r\n(char *) &opt, sizeof(opt));\r\nif (ret < 0) {\r\n_debug("setsockopt failed");\r\ngoto error;\r\n}\r\nopt = IP_PMTUDISC_DO;\r\nret = kernel_setsockopt(local->socket, SOL_IP, IP_MTU_DISCOVER,\r\n(char *) &opt, sizeof(opt));\r\nif (ret < 0) {\r\n_debug("setsockopt failed");\r\ngoto error;\r\n}\r\nsock = local->socket->sk;\r\nsock->sk_user_data = local;\r\nsock->sk_data_ready = rxrpc_data_ready;\r\nsock->sk_error_report = rxrpc_error_report;\r\n_leave(" = 0");\r\nreturn 0;\r\nerror:\r\nkernel_sock_shutdown(local->socket, SHUT_RDWR);\r\nlocal->socket->sk->sk_user_data = NULL;\r\nsock_release(local->socket);\r\nlocal->socket = NULL;\r\n_leave(" = %d", ret);\r\nreturn ret;\r\n}\r\nstruct rxrpc_local *rxrpc_lookup_local(struct net *net,\r\nconst struct sockaddr_rxrpc *srx)\r\n{\r\nstruct rxrpc_local *local;\r\nstruct rxrpc_net *rxnet = rxrpc_net(net);\r\nstruct list_head *cursor;\r\nconst char *age;\r\nlong diff;\r\nint ret;\r\n_enter("{%d,%d,%pISp}",\r\nsrx->transport_type, srx->transport.family, &srx->transport);\r\nmutex_lock(&rxnet->local_mutex);\r\nfor (cursor = rxnet->local_endpoints.next;\r\ncursor != &rxnet->local_endpoints;\r\ncursor = cursor->next) {\r\nlocal = list_entry(cursor, struct rxrpc_local, link);\r\ndiff = rxrpc_local_cmp_key(local, srx);\r\nif (diff < 0)\r\ncontinue;\r\nif (diff > 0)\r\nbreak;\r\nif (srx->srx_service) {\r\nlocal = NULL;\r\ngoto addr_in_use;\r\n}\r\nif (!rxrpc_get_local_maybe(local)) {\r\ncursor = cursor->next;\r\nlist_del_init(&local->link);\r\nbreak;\r\n}\r\nage = "old";\r\ngoto found;\r\n}\r\nlocal = rxrpc_alloc_local(rxnet, srx);\r\nif (!local)\r\ngoto nomem;\r\nret = rxrpc_open_socket(local, net);\r\nif (ret < 0)\r\ngoto sock_error;\r\nlist_add_tail(&local->link, cursor);\r\nage = "new";\r\nfound:\r\nmutex_unlock(&rxnet->local_mutex);\r\n_net("LOCAL %s %d {%pISp}",\r\nage, local->debug_id, &local->srx.transport);\r\n_leave(" = %p", local);\r\nreturn local;\r\nnomem:\r\nret = -ENOMEM;\r\nsock_error:\r\nmutex_unlock(&rxnet->local_mutex);\r\nkfree(local);\r\n_leave(" = %d", ret);\r\nreturn ERR_PTR(ret);\r\naddr_in_use:\r\nmutex_unlock(&rxnet->local_mutex);\r\n_leave(" = -EADDRINUSE");\r\nreturn ERR_PTR(-EADDRINUSE);\r\n}\r\nvoid __rxrpc_put_local(struct rxrpc_local *local)\r\n{\r\n_enter("%d", local->debug_id);\r\nrxrpc_queue_work(&local->processor);\r\n}\r\nstatic void rxrpc_local_destroyer(struct rxrpc_local *local)\r\n{\r\nstruct socket *socket = local->socket;\r\nstruct rxrpc_net *rxnet = local->rxnet;\r\n_enter("%d", local->debug_id);\r\nif (local->dead) {\r\n_leave(" [already dead]");\r\nreturn;\r\n}\r\nlocal->dead = true;\r\nmutex_lock(&rxnet->local_mutex);\r\nlist_del_init(&local->link);\r\nmutex_unlock(&rxnet->local_mutex);\r\nASSERT(RB_EMPTY_ROOT(&local->client_conns));\r\nASSERT(!local->service);\r\nif (socket) {\r\nlocal->socket = NULL;\r\nkernel_sock_shutdown(socket, SHUT_RDWR);\r\nsocket->sk->sk_user_data = NULL;\r\nsock_release(socket);\r\n}\r\nrxrpc_purge_queue(&local->reject_queue);\r\nrxrpc_purge_queue(&local->event_queue);\r\n_debug("rcu local %d", local->debug_id);\r\ncall_rcu(&local->rcu, rxrpc_local_rcu);\r\n}\r\nstatic void rxrpc_local_processor(struct work_struct *work)\r\n{\r\nstruct rxrpc_local *local =\r\ncontainer_of(work, struct rxrpc_local, processor);\r\nbool again;\r\n_enter("%d", local->debug_id);\r\ndo {\r\nagain = false;\r\nif (atomic_read(&local->usage) == 0)\r\nreturn rxrpc_local_destroyer(local);\r\nif (!skb_queue_empty(&local->reject_queue)) {\r\nrxrpc_reject_packets(local);\r\nagain = true;\r\n}\r\nif (!skb_queue_empty(&local->event_queue)) {\r\nrxrpc_process_local_events(local);\r\nagain = true;\r\n}\r\n} while (again);\r\n}\r\nstatic void rxrpc_local_rcu(struct rcu_head *rcu)\r\n{\r\nstruct rxrpc_local *local = container_of(rcu, struct rxrpc_local, rcu);\r\n_enter("%d", local->debug_id);\r\nASSERT(!work_pending(&local->processor));\r\n_net("DESTROY LOCAL %d", local->debug_id);\r\nkfree(local);\r\n_leave("");\r\n}\r\nvoid rxrpc_destroy_all_locals(struct rxrpc_net *rxnet)\r\n{\r\nstruct rxrpc_local *local;\r\n_enter("");\r\nflush_workqueue(rxrpc_workqueue);\r\nif (!list_empty(&rxnet->local_endpoints)) {\r\nmutex_lock(&rxnet->local_mutex);\r\nlist_for_each_entry(local, &rxnet->local_endpoints, link) {\r\npr_err("AF_RXRPC: Leaked local %p {%d}\n",\r\nlocal, atomic_read(&local->usage));\r\n}\r\nmutex_unlock(&rxnet->local_mutex);\r\nBUG();\r\n}\r\n}
