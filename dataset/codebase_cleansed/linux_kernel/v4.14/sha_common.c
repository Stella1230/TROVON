int s390_sha_update(struct shash_desc *desc, const u8 *data, unsigned int len)\r\n{\r\nstruct s390_sha_ctx *ctx = shash_desc_ctx(desc);\r\nunsigned int bsize = crypto_shash_blocksize(desc->tfm);\r\nunsigned int index, n;\r\nindex = ctx->count & (bsize - 1);\r\nctx->count += len;\r\nif ((index + len) < bsize)\r\ngoto store;\r\nif (index) {\r\nmemcpy(ctx->buf + index, data, bsize - index);\r\ncpacf_kimd(ctx->func, ctx->state, ctx->buf, bsize);\r\ndata += bsize - index;\r\nlen -= bsize - index;\r\nindex = 0;\r\n}\r\nif (len >= bsize) {\r\nn = len & ~(bsize - 1);\r\ncpacf_kimd(ctx->func, ctx->state, data, n);\r\ndata += n;\r\nlen -= n;\r\n}\r\nstore:\r\nif (len)\r\nmemcpy(ctx->buf + index , data, len);\r\nreturn 0;\r\n}\r\nint s390_sha_final(struct shash_desc *desc, u8 *out)\r\n{\r\nstruct s390_sha_ctx *ctx = shash_desc_ctx(desc);\r\nunsigned int bsize = crypto_shash_blocksize(desc->tfm);\r\nu64 bits;\r\nunsigned int index, end, plen;\r\nplen = (bsize > SHA256_BLOCK_SIZE) ? 16 : 8;\r\nindex = ctx->count & (bsize - 1);\r\nend = (index < bsize - plen) ? bsize : (2 * bsize);\r\nctx->buf[index] = 0x80;\r\nindex++;\r\nmemset(ctx->buf + index, 0x00, end - index - 8);\r\nbits = ctx->count * 8;\r\nmemcpy(ctx->buf + end - 8, &bits, sizeof(bits));\r\ncpacf_kimd(ctx->func, ctx->state, ctx->buf, end);\r\nmemcpy(out, ctx->state, crypto_shash_digestsize(desc->tfm));\r\nmemset(ctx, 0, sizeof *ctx);\r\nreturn 0;\r\n}
