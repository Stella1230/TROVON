static inline bool is_high_priority(struct i915_guc_client* client)\r\n{\r\nreturn client->priority <= GUC_CLIENT_PRIORITY_HIGH;\r\n}\r\nstatic int __reserve_doorbell(struct i915_guc_client *client)\r\n{\r\nunsigned long offset;\r\nunsigned long end;\r\nu16 id;\r\nGEM_BUG_ON(client->doorbell_id != GUC_DOORBELL_INVALID);\r\noffset = 0;\r\nend = GUC_NUM_DOORBELLS/2;\r\nif (is_high_priority(client)) {\r\noffset = end;\r\nend += offset;\r\n}\r\nid = find_next_zero_bit(client->guc->doorbell_bitmap, end, offset);\r\nif (id == end)\r\nreturn -ENOSPC;\r\n__set_bit(id, client->guc->doorbell_bitmap);\r\nclient->doorbell_id = id;\r\nDRM_DEBUG_DRIVER("client %u (high prio=%s) reserved doorbell: %d\n",\r\nclient->stage_id, yesno(is_high_priority(client)),\r\nid);\r\nreturn 0;\r\n}\r\nstatic void __unreserve_doorbell(struct i915_guc_client *client)\r\n{\r\nGEM_BUG_ON(client->doorbell_id == GUC_DOORBELL_INVALID);\r\n__clear_bit(client->doorbell_id, client->guc->doorbell_bitmap);\r\nclient->doorbell_id = GUC_DOORBELL_INVALID;\r\n}\r\nstatic int __guc_allocate_doorbell(struct intel_guc *guc, u32 stage_id)\r\n{\r\nu32 action[] = {\r\nINTEL_GUC_ACTION_ALLOCATE_DOORBELL,\r\nstage_id\r\n};\r\nreturn intel_guc_send(guc, action, ARRAY_SIZE(action));\r\n}\r\nstatic int __guc_deallocate_doorbell(struct intel_guc *guc, u32 stage_id)\r\n{\r\nu32 action[] = {\r\nINTEL_GUC_ACTION_DEALLOCATE_DOORBELL,\r\nstage_id\r\n};\r\nreturn intel_guc_send(guc, action, ARRAY_SIZE(action));\r\n}\r\nstatic struct guc_stage_desc *__get_stage_desc(struct i915_guc_client *client)\r\n{\r\nstruct guc_stage_desc *base = client->guc->stage_desc_pool_vaddr;\r\nreturn &base[client->stage_id];\r\n}\r\nstatic void __update_doorbell_desc(struct i915_guc_client *client, u16 new_id)\r\n{\r\nstruct guc_stage_desc *desc;\r\ndesc = __get_stage_desc(client);\r\ndesc->db_id = new_id;\r\n}\r\nstatic struct guc_doorbell_info *__get_doorbell(struct i915_guc_client *client)\r\n{\r\nreturn client->vaddr + client->doorbell_offset;\r\n}\r\nstatic bool has_doorbell(struct i915_guc_client *client)\r\n{\r\nif (client->doorbell_id == GUC_DOORBELL_INVALID)\r\nreturn false;\r\nreturn test_bit(client->doorbell_id, client->guc->doorbell_bitmap);\r\n}\r\nstatic int __create_doorbell(struct i915_guc_client *client)\r\n{\r\nstruct guc_doorbell_info *doorbell;\r\nint err;\r\ndoorbell = __get_doorbell(client);\r\ndoorbell->db_status = GUC_DOORBELL_ENABLED;\r\ndoorbell->cookie = client->doorbell_cookie;\r\nerr = __guc_allocate_doorbell(client->guc, client->stage_id);\r\nif (err) {\r\ndoorbell->db_status = GUC_DOORBELL_DISABLED;\r\ndoorbell->cookie = 0;\r\n}\r\nreturn err;\r\n}\r\nstatic int __destroy_doorbell(struct i915_guc_client *client)\r\n{\r\nstruct drm_i915_private *dev_priv = guc_to_i915(client->guc);\r\nstruct guc_doorbell_info *doorbell;\r\nu16 db_id = client->doorbell_id;\r\nGEM_BUG_ON(db_id >= GUC_DOORBELL_INVALID);\r\ndoorbell = __get_doorbell(client);\r\ndoorbell->db_status = GUC_DOORBELL_DISABLED;\r\ndoorbell->cookie = 0;\r\nif (wait_for_us(!(I915_READ(GEN8_DRBREGL(db_id)) & GEN8_DRB_VALID), 10))\r\nWARN_ONCE(true, "Doorbell never became invalid after disable\n");\r\nreturn __guc_deallocate_doorbell(client->guc, client->stage_id);\r\n}\r\nstatic int create_doorbell(struct i915_guc_client *client)\r\n{\r\nint ret;\r\nret = __reserve_doorbell(client);\r\nif (ret)\r\nreturn ret;\r\n__update_doorbell_desc(client, client->doorbell_id);\r\nret = __create_doorbell(client);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\n__update_doorbell_desc(client, GUC_DOORBELL_INVALID);\r\n__unreserve_doorbell(client);\r\nreturn ret;\r\n}\r\nstatic int destroy_doorbell(struct i915_guc_client *client)\r\n{\r\nint err;\r\nGEM_BUG_ON(!has_doorbell(client));\r\nerr = __destroy_doorbell(client);\r\nif (err)\r\nreturn err;\r\n__update_doorbell_desc(client, GUC_DOORBELL_INVALID);\r\n__unreserve_doorbell(client);\r\nreturn 0;\r\n}\r\nstatic unsigned long __select_cacheline(struct intel_guc* guc)\r\n{\r\nunsigned long offset;\r\noffset = offset_in_page(guc->db_cacheline);\r\nguc->db_cacheline += cache_line_size();\r\nDRM_DEBUG_DRIVER("reserved cacheline 0x%lx, next 0x%x, linesize %u\n",\r\noffset, guc->db_cacheline, cache_line_size());\r\nreturn offset;\r\n}\r\nstatic inline struct guc_process_desc *\r\n__get_process_desc(struct i915_guc_client *client)\r\n{\r\nreturn client->vaddr + client->proc_desc_offset;\r\n}\r\nstatic void guc_proc_desc_init(struct intel_guc *guc,\r\nstruct i915_guc_client *client)\r\n{\r\nstruct guc_process_desc *desc;\r\ndesc = memset(__get_process_desc(client), 0, sizeof(*desc));\r\ndesc->wq_base_addr = 0;\r\ndesc->db_base_addr = 0;\r\ndesc->stage_id = client->stage_id;\r\ndesc->wq_size_bytes = client->wq_size;\r\ndesc->wq_status = WQ_STATUS_ACTIVE;\r\ndesc->priority = client->priority;\r\n}\r\nstatic void guc_stage_desc_init(struct intel_guc *guc,\r\nstruct i915_guc_client *client)\r\n{\r\nstruct drm_i915_private *dev_priv = guc_to_i915(guc);\r\nstruct intel_engine_cs *engine;\r\nstruct i915_gem_context *ctx = client->owner;\r\nstruct guc_stage_desc *desc;\r\nunsigned int tmp;\r\nu32 gfx_addr;\r\ndesc = __get_stage_desc(client);\r\nmemset(desc, 0, sizeof(*desc));\r\ndesc->attribute = GUC_STAGE_DESC_ATTR_ACTIVE | GUC_STAGE_DESC_ATTR_KERNEL;\r\ndesc->stage_id = client->stage_id;\r\ndesc->priority = client->priority;\r\ndesc->db_id = client->doorbell_id;\r\nfor_each_engine_masked(engine, dev_priv, client->engines, tmp) {\r\nstruct intel_context *ce = &ctx->engine[engine->id];\r\nuint32_t guc_engine_id = engine->guc_id;\r\nstruct guc_execlist_context *lrc = &desc->lrc[guc_engine_id];\r\nif (!ce->state)\r\nbreak;\r\nlrc->context_desc = lower_32_bits(ce->lrc_desc);\r\nlrc->ring_lrca =\r\nguc_ggtt_offset(ce->state) + LRC_STATE_PN * PAGE_SIZE;\r\nlrc->context_id = (client->stage_id << GUC_ELC_CTXID_OFFSET) |\r\n(guc_engine_id << GUC_ELC_ENGINE_OFFSET);\r\nlrc->ring_begin = guc_ggtt_offset(ce->ring->vma);\r\nlrc->ring_end = lrc->ring_begin + ce->ring->size - 1;\r\nlrc->ring_next_free_location = lrc->ring_begin;\r\nlrc->ring_current_tail_pointer_value = 0;\r\ndesc->engines_used |= (1 << guc_engine_id);\r\n}\r\nDRM_DEBUG_DRIVER("Host engines 0x%x => GuC engines used 0x%x\n",\r\nclient->engines, desc->engines_used);\r\nWARN_ON(desc->engines_used == 0);\r\ngfx_addr = guc_ggtt_offset(client->vma);\r\ndesc->db_trigger_phy = sg_dma_address(client->vma->pages->sgl) +\r\nclient->doorbell_offset;\r\ndesc->db_trigger_cpu = (uintptr_t)__get_doorbell(client);\r\ndesc->db_trigger_uk = gfx_addr + client->doorbell_offset;\r\ndesc->process_desc = gfx_addr + client->proc_desc_offset;\r\ndesc->wq_addr = gfx_addr + client->wq_offset;\r\ndesc->wq_size = client->wq_size;\r\ndesc->desc_private = (uintptr_t)client;\r\n}\r\nstatic void guc_stage_desc_fini(struct intel_guc *guc,\r\nstruct i915_guc_client *client)\r\n{\r\nstruct guc_stage_desc *desc;\r\ndesc = __get_stage_desc(client);\r\nmemset(desc, 0, sizeof(*desc));\r\n}\r\nint i915_guc_wq_reserve(struct drm_i915_gem_request *request)\r\n{\r\nconst size_t wqi_size = sizeof(struct guc_wq_item);\r\nstruct i915_guc_client *client = request->i915->guc.execbuf_client;\r\nstruct guc_process_desc *desc = __get_process_desc(client);\r\nu32 freespace;\r\nint ret;\r\nspin_lock_irq(&client->wq_lock);\r\nfreespace = CIRC_SPACE(client->wq_tail, desc->head, client->wq_size);\r\nfreespace -= client->wq_rsvd;\r\nif (likely(freespace >= wqi_size)) {\r\nclient->wq_rsvd += wqi_size;\r\nret = 0;\r\n} else {\r\nclient->no_wq_space++;\r\nret = -EAGAIN;\r\n}\r\nspin_unlock_irq(&client->wq_lock);\r\nreturn ret;\r\n}\r\nstatic void guc_client_update_wq_rsvd(struct i915_guc_client *client, int size)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&client->wq_lock, flags);\r\nclient->wq_rsvd += size;\r\nspin_unlock_irqrestore(&client->wq_lock, flags);\r\n}\r\nvoid i915_guc_wq_unreserve(struct drm_i915_gem_request *request)\r\n{\r\nconst int wqi_size = sizeof(struct guc_wq_item);\r\nstruct i915_guc_client *client = request->i915->guc.execbuf_client;\r\nGEM_BUG_ON(READ_ONCE(client->wq_rsvd) < wqi_size);\r\nguc_client_update_wq_rsvd(client, -wqi_size);\r\n}\r\nstatic void guc_wq_item_append(struct i915_guc_client *client,\r\nstruct drm_i915_gem_request *rq)\r\n{\r\nconst size_t wqi_size = sizeof(struct guc_wq_item);\r\nconst u32 wqi_len = wqi_size/sizeof(u32) - 1;\r\nstruct intel_engine_cs *engine = rq->engine;\r\nstruct guc_process_desc *desc = __get_process_desc(client);\r\nstruct guc_wq_item *wqi;\r\nu32 freespace, tail, wq_off;\r\nfreespace = CIRC_SPACE(client->wq_tail, desc->head, client->wq_size);\r\nGEM_BUG_ON(freespace < wqi_size);\r\ntail = intel_ring_set_tail(rq->ring, rq->tail) >> 3;\r\nGEM_BUG_ON(tail > WQ_RING_TAIL_MAX);\r\nBUILD_BUG_ON(wqi_size != 16);\r\nGEM_BUG_ON(client->wq_rsvd < wqi_size);\r\nwq_off = client->wq_tail;\r\nGEM_BUG_ON(wq_off & (wqi_size - 1));\r\nclient->wq_tail += wqi_size;\r\nclient->wq_tail &= client->wq_size - 1;\r\nclient->wq_rsvd -= wqi_size;\r\nwqi = client->vaddr + wq_off + GUC_DB_SIZE;\r\nwqi->header = WQ_TYPE_INORDER |\r\n(wqi_len << WQ_LEN_SHIFT) |\r\n(engine->guc_id << WQ_TARGET_SHIFT) |\r\nWQ_NO_WCFLUSH_WAIT;\r\nwqi->context_desc = (u32)intel_lr_context_descriptor(rq->ctx, engine);\r\nwqi->submit_element_info = tail << WQ_RING_TAIL_SHIFT;\r\nwqi->fence_id = rq->global_seqno;\r\n}\r\nstatic void guc_reset_wq(struct i915_guc_client *client)\r\n{\r\nstruct guc_process_desc *desc = __get_process_desc(client);\r\ndesc->head = 0;\r\ndesc->tail = 0;\r\nclient->wq_tail = 0;\r\n}\r\nstatic int guc_ring_doorbell(struct i915_guc_client *client)\r\n{\r\nstruct guc_process_desc *desc = __get_process_desc(client);\r\nunion guc_doorbell_qw db_cmp, db_exc, db_ret;\r\nunion guc_doorbell_qw *db;\r\nint attempt = 2, ret = -EAGAIN;\r\ndesc->tail = client->wq_tail;\r\ndb_cmp.db_status = GUC_DOORBELL_ENABLED;\r\ndb_cmp.cookie = client->doorbell_cookie;\r\ndb_exc.db_status = GUC_DOORBELL_ENABLED;\r\ndb_exc.cookie = client->doorbell_cookie + 1;\r\nif (db_exc.cookie == 0)\r\ndb_exc.cookie = 1;\r\ndb = (union guc_doorbell_qw *)__get_doorbell(client);\r\nwhile (attempt--) {\r\ndb_ret.value_qw = atomic64_cmpxchg((atomic64_t *)db,\r\ndb_cmp.value_qw, db_exc.value_qw);\r\nif (db_ret.value_qw == db_cmp.value_qw) {\r\nclient->doorbell_cookie = db_exc.cookie;\r\nret = 0;\r\nbreak;\r\n}\r\nif (db_ret.db_status == GUC_DOORBELL_DISABLED)\r\nbreak;\r\nDRM_WARN("Cookie mismatch. Expected %d, found %d\n",\r\ndb_cmp.cookie, db_ret.cookie);\r\ndb_cmp.cookie = db_ret.cookie;\r\ndb_exc.cookie = db_ret.cookie + 1;\r\nif (db_exc.cookie == 0)\r\ndb_exc.cookie = 1;\r\n}\r\nreturn ret;\r\n}\r\nstatic void __i915_guc_submit(struct drm_i915_gem_request *rq)\r\n{\r\nstruct drm_i915_private *dev_priv = rq->i915;\r\nstruct intel_engine_cs *engine = rq->engine;\r\nunsigned int engine_id = engine->id;\r\nstruct intel_guc *guc = &rq->i915->guc;\r\nstruct i915_guc_client *client = guc->execbuf_client;\r\nunsigned long flags;\r\nint b_ret;\r\nif (i915_vma_is_map_and_fenceable(rq->ring->vma))\r\nPOSTING_READ_FW(GUC_STATUS);\r\nspin_lock_irqsave(&client->wq_lock, flags);\r\nguc_wq_item_append(client, rq);\r\nb_ret = guc_ring_doorbell(client);\r\nclient->submissions[engine_id] += 1;\r\nspin_unlock_irqrestore(&client->wq_lock, flags);\r\n}\r\nstatic void i915_guc_submit(struct drm_i915_gem_request *rq)\r\n{\r\n__i915_gem_request_submit(rq);\r\n__i915_guc_submit(rq);\r\n}\r\nstatic void nested_enable_signaling(struct drm_i915_gem_request *rq)\r\n{\r\nif (test_and_set_bit(DMA_FENCE_FLAG_ENABLE_SIGNAL_BIT,\r\n&rq->fence.flags))\r\nreturn;\r\nGEM_BUG_ON(test_bit(DMA_FENCE_FLAG_SIGNALED_BIT, &rq->fence.flags));\r\ntrace_dma_fence_enable_signal(&rq->fence);\r\nspin_lock_nested(&rq->lock, SINGLE_DEPTH_NESTING);\r\nintel_engine_enable_signaling(rq, true);\r\nspin_unlock(&rq->lock);\r\n}\r\nstatic void port_assign(struct execlist_port *port,\r\nstruct drm_i915_gem_request *rq)\r\n{\r\nGEM_BUG_ON(rq == port_request(port));\r\nif (port_isset(port))\r\ni915_gem_request_put(port_request(port));\r\nport_set(port, i915_gem_request_get(rq));\r\nnested_enable_signaling(rq);\r\n}\r\nstatic bool i915_guc_dequeue(struct intel_engine_cs *engine)\r\n{\r\nstruct execlist_port *port = engine->execlist_port;\r\nstruct drm_i915_gem_request *last = port_request(port);\r\nstruct rb_node *rb;\r\nbool submit = false;\r\nspin_lock_irq(&engine->timeline->lock);\r\nrb = engine->execlist_first;\r\nGEM_BUG_ON(rb_first(&engine->execlist_queue) != rb);\r\nwhile (rb) {\r\nstruct i915_priolist *p = rb_entry(rb, typeof(*p), node);\r\nstruct drm_i915_gem_request *rq, *rn;\r\nlist_for_each_entry_safe(rq, rn, &p->requests, priotree.link) {\r\nif (last && rq->ctx != last->ctx) {\r\nif (port != engine->execlist_port) {\r\n__list_del_many(&p->requests,\r\n&rq->priotree.link);\r\ngoto done;\r\n}\r\nif (submit)\r\nport_assign(port, last);\r\nport++;\r\n}\r\nINIT_LIST_HEAD(&rq->priotree.link);\r\nrq->priotree.priority = INT_MAX;\r\ni915_guc_submit(rq);\r\ntrace_i915_gem_request_in(rq, port_index(port, engine));\r\nlast = rq;\r\nsubmit = true;\r\n}\r\nrb = rb_next(rb);\r\nrb_erase(&p->node, &engine->execlist_queue);\r\nINIT_LIST_HEAD(&p->requests);\r\nif (p->priority != I915_PRIORITY_NORMAL)\r\nkmem_cache_free(engine->i915->priorities, p);\r\n}\r\ndone:\r\nengine->execlist_first = rb;\r\nif (submit)\r\nport_assign(port, last);\r\nspin_unlock_irq(&engine->timeline->lock);\r\nreturn submit;\r\n}\r\nstatic void i915_guc_irq_handler(unsigned long data)\r\n{\r\nstruct intel_engine_cs *engine = (struct intel_engine_cs *)data;\r\nstruct execlist_port *port = engine->execlist_port;\r\nstruct drm_i915_gem_request *rq;\r\nbool submit;\r\ndo {\r\nrq = port_request(&port[0]);\r\nwhile (rq && i915_gem_request_completed(rq)) {\r\ntrace_i915_gem_request_out(rq);\r\ni915_gem_request_put(rq);\r\nport[0] = port[1];\r\nmemset(&port[1], 0, sizeof(port[1]));\r\nrq = port_request(&port[0]);\r\n}\r\nsubmit = false;\r\nif (!port_count(&port[1]))\r\nsubmit = i915_guc_dequeue(engine);\r\n} while (submit);\r\n}\r\nstruct i915_vma *intel_guc_allocate_vma(struct intel_guc *guc, u32 size)\r\n{\r\nstruct drm_i915_private *dev_priv = guc_to_i915(guc);\r\nstruct drm_i915_gem_object *obj;\r\nstruct i915_vma *vma;\r\nint ret;\r\nobj = i915_gem_object_create(dev_priv, size);\r\nif (IS_ERR(obj))\r\nreturn ERR_CAST(obj);\r\nvma = i915_vma_instance(obj, &dev_priv->ggtt.base, NULL);\r\nif (IS_ERR(vma))\r\ngoto err;\r\nret = i915_vma_pin(vma, 0, PAGE_SIZE,\r\nPIN_GLOBAL | PIN_OFFSET_BIAS | GUC_WOPCM_TOP);\r\nif (ret) {\r\nvma = ERR_PTR(ret);\r\ngoto err;\r\n}\r\nreturn vma;\r\nerr:\r\ni915_gem_object_put(obj);\r\nreturn vma;\r\n}\r\nstatic bool doorbell_ok(struct intel_guc *guc, u16 db_id)\r\n{\r\nstruct drm_i915_private *dev_priv = guc_to_i915(guc);\r\nu32 drbregl;\r\nbool valid;\r\nGEM_BUG_ON(db_id >= GUC_DOORBELL_INVALID);\r\ndrbregl = I915_READ(GEN8_DRBREGL(db_id));\r\nvalid = drbregl & GEN8_DRB_VALID;\r\nif (test_bit(db_id, guc->doorbell_bitmap) == valid)\r\nreturn true;\r\nDRM_DEBUG_DRIVER("Doorbell %d has unexpected state (0x%x): valid=%s\n",\r\ndb_id, drbregl, yesno(valid));\r\nreturn false;\r\n}\r\nstatic int __reset_doorbell(struct i915_guc_client* client, u16 db_id)\r\n{\r\nint err;\r\n__update_doorbell_desc(client, db_id);\r\nerr = __create_doorbell(client);\r\nif (!err)\r\nerr = __destroy_doorbell(client);\r\nreturn err;\r\n}\r\nstatic int guc_init_doorbell_hw(struct intel_guc *guc)\r\n{\r\nstruct i915_guc_client *client = guc->execbuf_client;\r\nbool recreate_first_client = false;\r\nu16 db_id;\r\nint ret;\r\nfor_each_clear_bit(db_id, guc->doorbell_bitmap, GUC_NUM_DOORBELLS) {\r\nif (doorbell_ok(guc, db_id))\r\ncontinue;\r\nif (has_doorbell(client)) {\r\ndestroy_doorbell(client);\r\nrecreate_first_client = true;\r\n}\r\nret = __reset_doorbell(client, db_id);\r\nWARN(ret, "Doorbell %u reset failed, err %d\n", db_id, ret);\r\n}\r\nif (recreate_first_client) {\r\nret = __reserve_doorbell(client);\r\nif (unlikely(ret)) {\r\nDRM_ERROR("Couldn't re-reserve first client db: %d\n", ret);\r\nreturn ret;\r\n}\r\n__update_doorbell_desc(client, client->doorbell_id);\r\n}\r\n{\r\nret = __create_doorbell(client);\r\nif (ret) {\r\nDRM_ERROR("Couldn't recreate client %u doorbell: %d\n",\r\nclient->stage_id, ret);\r\nreturn ret;\r\n}\r\n}\r\nfor (db_id = 0; db_id < GUC_NUM_DOORBELLS; ++db_id)\r\nWARN_ON(!doorbell_ok(guc, db_id));\r\nreturn 0;\r\n}\r\nstatic struct i915_guc_client *\r\nguc_client_alloc(struct drm_i915_private *dev_priv,\r\nuint32_t engines,\r\nuint32_t priority,\r\nstruct i915_gem_context *ctx)\r\n{\r\nstruct i915_guc_client *client;\r\nstruct intel_guc *guc = &dev_priv->guc;\r\nstruct i915_vma *vma;\r\nvoid *vaddr;\r\nint ret;\r\nclient = kzalloc(sizeof(*client), GFP_KERNEL);\r\nif (!client)\r\nreturn ERR_PTR(-ENOMEM);\r\nclient->guc = guc;\r\nclient->owner = ctx;\r\nclient->engines = engines;\r\nclient->priority = priority;\r\nclient->doorbell_id = GUC_DOORBELL_INVALID;\r\nclient->wq_offset = GUC_DB_SIZE;\r\nclient->wq_size = GUC_WQ_SIZE;\r\nspin_lock_init(&client->wq_lock);\r\nret = ida_simple_get(&guc->stage_ids, 0, GUC_MAX_STAGE_DESCRIPTORS,\r\nGFP_KERNEL);\r\nif (ret < 0)\r\ngoto err_client;\r\nclient->stage_id = ret;\r\nvma = intel_guc_allocate_vma(guc, GUC_DB_SIZE + GUC_WQ_SIZE);\r\nif (IS_ERR(vma)) {\r\nret = PTR_ERR(vma);\r\ngoto err_id;\r\n}\r\nclient->vma = vma;\r\nvaddr = i915_gem_object_pin_map(vma->obj, I915_MAP_WB);\r\nif (IS_ERR(vaddr)) {\r\nret = PTR_ERR(vaddr);\r\ngoto err_vma;\r\n}\r\nclient->vaddr = vaddr;\r\nclient->doorbell_offset = __select_cacheline(guc);\r\nif (client->doorbell_offset >= (GUC_DB_SIZE / 2))\r\nclient->proc_desc_offset = 0;\r\nelse\r\nclient->proc_desc_offset = (GUC_DB_SIZE / 2);\r\nguc_proc_desc_init(guc, client);\r\nguc_stage_desc_init(guc, client);\r\nret = create_doorbell(client);\r\nif (ret)\r\ngoto err_vaddr;\r\nDRM_DEBUG_DRIVER("new priority %u client %p for engine(s) 0x%x: stage_id %u\n",\r\npriority, client, client->engines, client->stage_id);\r\nDRM_DEBUG_DRIVER("doorbell id %u, cacheline offset 0x%lx\n",\r\nclient->doorbell_id, client->doorbell_offset);\r\nreturn client;\r\nerr_vaddr:\r\ni915_gem_object_unpin_map(client->vma->obj);\r\nerr_vma:\r\ni915_vma_unpin_and_release(&client->vma);\r\nerr_id:\r\nida_simple_remove(&guc->stage_ids, client->stage_id);\r\nerr_client:\r\nkfree(client);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic void guc_client_free(struct i915_guc_client *client)\r\n{\r\ndestroy_doorbell(client);\r\nguc_stage_desc_fini(client->guc, client);\r\ni915_gem_object_unpin_map(client->vma->obj);\r\ni915_vma_unpin_and_release(&client->vma);\r\nida_simple_remove(&client->guc->stage_ids, client->stage_id);\r\nkfree(client);\r\n}\r\nstatic void guc_policies_init(struct guc_policies *policies)\r\n{\r\nstruct guc_policy *policy;\r\nu32 p, i;\r\npolicies->dpc_promote_time = 500000;\r\npolicies->max_num_work_items = POLICY_MAX_NUM_WI;\r\nfor (p = 0; p < GUC_CLIENT_PRIORITY_NUM; p++) {\r\nfor (i = GUC_RENDER_ENGINE; i < GUC_MAX_ENGINES_NUM; i++) {\r\npolicy = &policies->policy[p][i];\r\npolicy->execution_quantum = 1000000;\r\npolicy->preemption_time = 500000;\r\npolicy->fault_time = 250000;\r\npolicy->policy_flags = 0;\r\n}\r\n}\r\npolicies->is_valid = 1;\r\n}\r\nstatic int guc_ads_create(struct intel_guc *guc)\r\n{\r\nstruct drm_i915_private *dev_priv = guc_to_i915(guc);\r\nstruct i915_vma *vma;\r\nstruct page *page;\r\nstruct {\r\nstruct guc_ads ads;\r\nstruct guc_policies policies;\r\nstruct guc_mmio_reg_state reg_state;\r\nu8 reg_state_buffer[GUC_S3_SAVE_SPACE_PAGES * PAGE_SIZE];\r\n} __packed *blob;\r\nstruct intel_engine_cs *engine;\r\nenum intel_engine_id id;\r\nu32 base;\r\nGEM_BUG_ON(guc->ads_vma);\r\nvma = intel_guc_allocate_vma(guc, PAGE_ALIGN(sizeof(*blob)));\r\nif (IS_ERR(vma))\r\nreturn PTR_ERR(vma);\r\nguc->ads_vma = vma;\r\npage = i915_vma_first_page(vma);\r\nblob = kmap(page);\r\nguc_policies_init(&blob->policies);\r\nfor_each_engine(engine, dev_priv, id) {\r\nblob->reg_state.white_list[engine->guc_id].mmio_start =\r\nengine->mmio_base + GUC_MMIO_WHITE_LIST_START;\r\nblob->reg_state.white_list[engine->guc_id].count = 0;\r\n}\r\nblob->ads.golden_context_lrca =\r\ndev_priv->engine[RCS]->status_page.ggtt_offset;\r\nfor_each_engine(engine, dev_priv, id)\r\nblob->ads.eng_state_size[engine->guc_id] = engine->context_size;\r\nbase = guc_ggtt_offset(vma);\r\nblob->ads.scheduler_policies = base + ptr_offset(blob, policies);\r\nblob->ads.reg_state_buffer = base + ptr_offset(blob, reg_state_buffer);\r\nblob->ads.reg_state_addr = base + ptr_offset(blob, reg_state);\r\nkunmap(page);\r\nreturn 0;\r\n}\r\nstatic void guc_ads_destroy(struct intel_guc *guc)\r\n{\r\ni915_vma_unpin_and_release(&guc->ads_vma);\r\n}\r\nint i915_guc_submission_init(struct drm_i915_private *dev_priv)\r\n{\r\nstruct intel_guc *guc = &dev_priv->guc;\r\nstruct i915_vma *vma;\r\nvoid *vaddr;\r\nint ret;\r\nif (guc->stage_desc_pool)\r\nreturn 0;\r\nvma = intel_guc_allocate_vma(guc,\r\nPAGE_ALIGN(sizeof(struct guc_stage_desc) *\r\nGUC_MAX_STAGE_DESCRIPTORS));\r\nif (IS_ERR(vma))\r\nreturn PTR_ERR(vma);\r\nguc->stage_desc_pool = vma;\r\nvaddr = i915_gem_object_pin_map(guc->stage_desc_pool->obj, I915_MAP_WB);\r\nif (IS_ERR(vaddr)) {\r\nret = PTR_ERR(vaddr);\r\ngoto err_vma;\r\n}\r\nguc->stage_desc_pool_vaddr = vaddr;\r\nret = intel_guc_log_create(guc);\r\nif (ret < 0)\r\ngoto err_vaddr;\r\nret = guc_ads_create(guc);\r\nif (ret < 0)\r\ngoto err_log;\r\nida_init(&guc->stage_ids);\r\nreturn 0;\r\nerr_log:\r\nintel_guc_log_destroy(guc);\r\nerr_vaddr:\r\ni915_gem_object_unpin_map(guc->stage_desc_pool->obj);\r\nerr_vma:\r\ni915_vma_unpin_and_release(&guc->stage_desc_pool);\r\nreturn ret;\r\n}\r\nvoid i915_guc_submission_fini(struct drm_i915_private *dev_priv)\r\n{\r\nstruct intel_guc *guc = &dev_priv->guc;\r\nida_destroy(&guc->stage_ids);\r\nguc_ads_destroy(guc);\r\nintel_guc_log_destroy(guc);\r\ni915_gem_object_unpin_map(guc->stage_desc_pool->obj);\r\ni915_vma_unpin_and_release(&guc->stage_desc_pool);\r\n}\r\nstatic void guc_interrupts_capture(struct drm_i915_private *dev_priv)\r\n{\r\nstruct intel_engine_cs *engine;\r\nenum intel_engine_id id;\r\nint irqs;\r\nirqs = _MASKED_BIT_ENABLE(GFX_INTERRUPT_STEERING);\r\nfor_each_engine(engine, dev_priv, id)\r\nI915_WRITE(RING_MODE_GEN7(engine), irqs);\r\nirqs = GT_RENDER_USER_INTERRUPT << GEN8_RCS_IRQ_SHIFT |\r\nGT_RENDER_USER_INTERRUPT << GEN8_BCS_IRQ_SHIFT;\r\nI915_WRITE(GUC_BCS_RCS_IER, ~irqs);\r\nI915_WRITE(GUC_VCS2_VCS1_IER, ~irqs);\r\nI915_WRITE(GUC_WD_VECS_IER, ~irqs);\r\ndev_priv->rps.pm_intrmsk_mbz |= ARAT_EXPIRED_INTRMSK;\r\ndev_priv->rps.pm_intrmsk_mbz &= ~GEN8_PMINTR_DISABLE_REDIRECT_TO_GUC;\r\n}\r\nstatic void guc_interrupts_release(struct drm_i915_private *dev_priv)\r\n{\r\nstruct intel_engine_cs *engine;\r\nenum intel_engine_id id;\r\nint irqs;\r\nirqs = _MASKED_FIELD(GFX_FORWARD_VBLANK_MASK, GFX_FORWARD_VBLANK_NEVER);\r\nirqs |= _MASKED_BIT_DISABLE(GFX_INTERRUPT_STEERING);\r\nfor_each_engine(engine, dev_priv, id)\r\nI915_WRITE(RING_MODE_GEN7(engine), irqs);\r\nI915_WRITE(GUC_BCS_RCS_IER, 0);\r\nI915_WRITE(GUC_VCS2_VCS1_IER, 0);\r\nI915_WRITE(GUC_WD_VECS_IER, 0);\r\ndev_priv->rps.pm_intrmsk_mbz |= GEN8_PMINTR_DISABLE_REDIRECT_TO_GUC;\r\ndev_priv->rps.pm_intrmsk_mbz &= ~ARAT_EXPIRED_INTRMSK;\r\n}\r\nint i915_guc_submission_enable(struct drm_i915_private *dev_priv)\r\n{\r\nstruct intel_guc *guc = &dev_priv->guc;\r\nstruct i915_guc_client *client = guc->execbuf_client;\r\nstruct intel_engine_cs *engine;\r\nenum intel_engine_id id;\r\nint err;\r\nif (!client) {\r\nclient = guc_client_alloc(dev_priv,\r\nINTEL_INFO(dev_priv)->ring_mask,\r\nGUC_CLIENT_PRIORITY_KMD_NORMAL,\r\ndev_priv->kernel_context);\r\nif (IS_ERR(client)) {\r\nDRM_ERROR("Failed to create GuC client for execbuf!\n");\r\nreturn PTR_ERR(client);\r\n}\r\nguc->execbuf_client = client;\r\n}\r\nerr = intel_guc_sample_forcewake(guc);\r\nif (err)\r\ngoto err_execbuf_client;\r\nguc_reset_wq(client);\r\nerr = guc_init_doorbell_hw(guc);\r\nif (err)\r\ngoto err_execbuf_client;\r\nguc_interrupts_capture(dev_priv);\r\nfor_each_engine(engine, dev_priv, id) {\r\nconst int wqi_size = sizeof(struct guc_wq_item);\r\nstruct drm_i915_gem_request *rq;\r\nengine->irq_tasklet.func = i915_guc_irq_handler;\r\nclear_bit(ENGINE_IRQ_EXECLIST, &engine->irq_posted);\r\nspin_lock_irq(&engine->timeline->lock);\r\nlist_for_each_entry(rq, &engine->timeline->requests, link) {\r\nguc_client_update_wq_rsvd(client, wqi_size);\r\n__i915_guc_submit(rq);\r\n}\r\nspin_unlock_irq(&engine->timeline->lock);\r\n}\r\nreturn 0;\r\nerr_execbuf_client:\r\nguc_client_free(guc->execbuf_client);\r\nguc->execbuf_client = NULL;\r\nreturn err;\r\n}\r\nvoid i915_guc_submission_disable(struct drm_i915_private *dev_priv)\r\n{\r\nstruct intel_guc *guc = &dev_priv->guc;\r\nguc_interrupts_release(dev_priv);\r\nintel_engines_reset_default_submission(dev_priv);\r\nguc_client_free(guc->execbuf_client);\r\nguc->execbuf_client = NULL;\r\n}\r\nint intel_guc_suspend(struct drm_i915_private *dev_priv)\r\n{\r\nstruct intel_guc *guc = &dev_priv->guc;\r\nstruct i915_gem_context *ctx;\r\nu32 data[3];\r\nif (guc->fw.load_status != INTEL_UC_FIRMWARE_SUCCESS)\r\nreturn 0;\r\ngen9_disable_guc_interrupts(dev_priv);\r\nctx = dev_priv->kernel_context;\r\ndata[0] = INTEL_GUC_ACTION_ENTER_S_STATE;\r\ndata[1] = GUC_POWER_D1;\r\ndata[2] = guc_ggtt_offset(ctx->engine[RCS].state);\r\nreturn intel_guc_send(guc, data, ARRAY_SIZE(data));\r\n}\r\nint intel_guc_resume(struct drm_i915_private *dev_priv)\r\n{\r\nstruct intel_guc *guc = &dev_priv->guc;\r\nstruct i915_gem_context *ctx;\r\nu32 data[3];\r\nif (guc->fw.load_status != INTEL_UC_FIRMWARE_SUCCESS)\r\nreturn 0;\r\nif (i915.guc_log_level >= 0)\r\ngen9_enable_guc_interrupts(dev_priv);\r\nctx = dev_priv->kernel_context;\r\ndata[0] = INTEL_GUC_ACTION_EXIT_S_STATE;\r\ndata[1] = GUC_POWER_D0;\r\ndata[2] = guc_ggtt_offset(ctx->engine[RCS].state);\r\nreturn intel_guc_send(guc, data, ARRAY_SIZE(data));\r\n}
