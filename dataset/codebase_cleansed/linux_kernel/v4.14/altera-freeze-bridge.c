static int altera_freeze_br_req_ack(struct altera_freeze_br_data *priv,\r\nu32 timeout, u32 req_ack)\r\n{\r\nstruct device *dev = priv->dev;\r\nvoid __iomem *csr_illegal_req_addr = priv->base_addr +\r\nFREEZE_CSR_ILLEGAL_REQ_OFFSET;\r\nu32 status, illegal, ctrl;\r\nint ret = -ETIMEDOUT;\r\ndo {\r\nillegal = readl(csr_illegal_req_addr);\r\nif (illegal) {\r\ndev_err(dev, "illegal request detected 0x%x", illegal);\r\nwritel(1, csr_illegal_req_addr);\r\nillegal = readl(csr_illegal_req_addr);\r\nif (illegal)\r\ndev_err(dev, "illegal request not cleared 0x%x",\r\nillegal);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nstatus = readl(priv->base_addr + FREEZE_CSR_STATUS_OFFSET);\r\ndev_dbg(dev, "%s %x %x\n", __func__, status, req_ack);\r\nstatus &= req_ack;\r\nif (status) {\r\nctrl = readl(priv->base_addr + FREEZE_CSR_CTRL_OFFSET);\r\ndev_dbg(dev, "%s request %x acknowledged %x %x\n",\r\n__func__, req_ack, status, ctrl);\r\nret = 0;\r\nbreak;\r\n}\r\nudelay(1);\r\n} while (timeout--);\r\nif (ret == -ETIMEDOUT)\r\ndev_err(dev, "%s timeout waiting for 0x%x\n",\r\n__func__, req_ack);\r\nreturn ret;\r\n}\r\nstatic int altera_freeze_br_do_freeze(struct altera_freeze_br_data *priv,\r\nu32 timeout)\r\n{\r\nstruct device *dev = priv->dev;\r\nvoid __iomem *csr_ctrl_addr = priv->base_addr +\r\nFREEZE_CSR_CTRL_OFFSET;\r\nu32 status;\r\nint ret;\r\nstatus = readl(priv->base_addr + FREEZE_CSR_STATUS_OFFSET);\r\ndev_dbg(dev, "%s %d %d\n", __func__, status, readl(csr_ctrl_addr));\r\nif (status & FREEZE_CSR_STATUS_FREEZE_REQ_DONE) {\r\ndev_dbg(dev, "%s bridge already disabled %d\n",\r\n__func__, status);\r\nreturn 0;\r\n} else if (!(status & FREEZE_CSR_STATUS_UNFREEZE_REQ_DONE)) {\r\ndev_err(dev, "%s bridge not enabled %d\n", __func__, status);\r\nreturn -EINVAL;\r\n}\r\nwritel(FREEZE_CSR_CTRL_FREEZE_REQ, csr_ctrl_addr);\r\nret = altera_freeze_br_req_ack(priv, timeout,\r\nFREEZE_CSR_STATUS_FREEZE_REQ_DONE);\r\nif (ret)\r\nwritel(0, csr_ctrl_addr);\r\nelse\r\nwritel(FREEZE_CSR_CTRL_RESET_REQ, csr_ctrl_addr);\r\nreturn ret;\r\n}\r\nstatic int altera_freeze_br_do_unfreeze(struct altera_freeze_br_data *priv,\r\nu32 timeout)\r\n{\r\nstruct device *dev = priv->dev;\r\nvoid __iomem *csr_ctrl_addr = priv->base_addr +\r\nFREEZE_CSR_CTRL_OFFSET;\r\nu32 status;\r\nint ret;\r\nwritel(0, csr_ctrl_addr);\r\nstatus = readl(priv->base_addr + FREEZE_CSR_STATUS_OFFSET);\r\ndev_dbg(dev, "%s %d %d\n", __func__, status, readl(csr_ctrl_addr));\r\nif (status & FREEZE_CSR_STATUS_UNFREEZE_REQ_DONE) {\r\ndev_dbg(dev, "%s bridge already enabled %d\n",\r\n__func__, status);\r\nreturn 0;\r\n} else if (!(status & FREEZE_CSR_STATUS_FREEZE_REQ_DONE)) {\r\ndev_err(dev, "%s bridge not frozen %d\n", __func__, status);\r\nreturn -EINVAL;\r\n}\r\nwritel(FREEZE_CSR_CTRL_UNFREEZE_REQ, csr_ctrl_addr);\r\nret = altera_freeze_br_req_ack(priv, timeout,\r\nFREEZE_CSR_STATUS_UNFREEZE_REQ_DONE);\r\nstatus = readl(priv->base_addr + FREEZE_CSR_STATUS_OFFSET);\r\ndev_dbg(dev, "%s %d %d\n", __func__, status, readl(csr_ctrl_addr));\r\nwritel(0, csr_ctrl_addr);\r\nreturn ret;\r\n}\r\nstatic int altera_freeze_br_enable_set(struct fpga_bridge *bridge,\r\nbool enable)\r\n{\r\nstruct altera_freeze_br_data *priv = bridge->priv;\r\nstruct fpga_image_info *info = bridge->info;\r\nu32 timeout = 0;\r\nint ret;\r\nif (enable) {\r\nif (info)\r\ntimeout = info->enable_timeout_us;\r\nret = altera_freeze_br_do_unfreeze(bridge->priv, timeout);\r\n} else {\r\nif (info)\r\ntimeout = info->disable_timeout_us;\r\nret = altera_freeze_br_do_freeze(bridge->priv, timeout);\r\n}\r\nif (!ret)\r\npriv->enable = enable;\r\nreturn ret;\r\n}\r\nstatic int altera_freeze_br_enable_show(struct fpga_bridge *bridge)\r\n{\r\nstruct altera_freeze_br_data *priv = bridge->priv;\r\nreturn priv->enable;\r\n}\r\nstatic int altera_freeze_br_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np = pdev->dev.of_node;\r\nvoid __iomem *base_addr;\r\nstruct altera_freeze_br_data *priv;\r\nstruct resource *res;\r\nu32 status, revision;\r\nif (!np)\r\nreturn -ENODEV;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase_addr = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(base_addr))\r\nreturn PTR_ERR(base_addr);\r\nrevision = readl(base_addr + FREEZE_CSR_REG_VERSION);\r\nif ((revision != FREEZE_CSR_SUPPORTED_VERSION) &&\r\n(revision != FREEZE_CSR_OFFICIAL_VERSION)) {\r\ndev_err(dev,\r\n"%s unexpected revision 0x%x != 0x%x != 0x%x\n",\r\n__func__, revision, FREEZE_CSR_SUPPORTED_VERSION,\r\nFREEZE_CSR_OFFICIAL_VERSION);\r\nreturn -EINVAL;\r\n}\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->dev = dev;\r\nstatus = readl(base_addr + FREEZE_CSR_STATUS_OFFSET);\r\nif (status & FREEZE_CSR_STATUS_UNFREEZE_REQ_DONE)\r\npriv->enable = 1;\r\npriv->base_addr = base_addr;\r\nreturn fpga_bridge_register(dev, FREEZE_BRIDGE_NAME,\r\n&altera_freeze_br_br_ops, priv);\r\n}\r\nstatic int altera_freeze_br_remove(struct platform_device *pdev)\r\n{\r\nfpga_bridge_unregister(&pdev->dev);\r\nreturn 0;\r\n}
