static void ctc_gradient(\r\nint *dydx, int *shift,\r\nint y1, int y0, int x1, int x0)\r\n{\r\nint frc_bits = max(IA_CSS_CTC_COEF_SHIFT, 16);\r\nint dy = y1 - y0;\r\nint dx = x1 - x0;\r\nint dydx_int;\r\nint dydx_frc;\r\nint sft;\r\nint max_dydx = (1 << IA_CSS_CTC_COEF_SHIFT) - 1;\r\nif (dx == 0) {\r\nia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ctc_gradient() error, illegal division operation\n");\r\nreturn;\r\n} else {\r\ndydx_int = dy / dx;\r\ndydx_frc = ((dy - dydx_int * dx) << frc_bits) / dx;\r\n}\r\nassert(y0 >= 0 && y0 <= max_dydx);\r\nassert(y1 >= 0 && y1 <= max_dydx);\r\nassert(x0 < x1);\r\nassert(dydx != NULL);\r\nassert(shift != NULL);\r\nia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ctc_gradient() enter:\n");\r\nfor (sft = 0; sft <= IA_CSS_CTC_COEF_SHIFT; sft++) {\r\nint tmp_dydx = (dydx_int << sft)\r\n+ (dydx_frc >> (frc_bits - sft));\r\nif (tmp_dydx <= max_dydx) {\r\n*dydx = tmp_dydx;\r\n*shift = sft;\r\n}\r\nif (tmp_dydx >= max_dydx)\r\nbreak;\r\n}\r\nia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ctc_gradient() leave:\n");\r\n}\r\nvoid\r\nia_css_ctc_encode(\r\nstruct sh_css_isp_ctc_params *to,\r\nconst struct ia_css_ctc_config *from,\r\nunsigned size)\r\n{\r\n(void)size;\r\nto->y0 = from->y0;\r\nto->y1 = from->y1;\r\nto->y2 = from->y2;\r\nto->y3 = from->y3;\r\nto->y4 = from->y4;\r\nto->y5 = from->y5;\r\nto->ce_gain_exp = from->ce_gain_exp;\r\nto->x1 = from->x1;\r\nto->x2 = from->x2;\r\nto->x3 = from->x3;\r\nto->x4 = from->x4;\r\nctc_gradient(&(to->dydx0),\r\n&(to->dydx0_shift),\r\nfrom->y1, from->y0,\r\nfrom->x1, 0);\r\nctc_gradient(&(to->dydx1),\r\n&(to->dydx1_shift),\r\nfrom->y2, from->y1,\r\nfrom->x2, from->x1);\r\nctc_gradient(&to->dydx2,\r\n&to->dydx2_shift,\r\nfrom->y3, from->y2,\r\nfrom->x3, from->x2);\r\nctc_gradient(&to->dydx3,\r\n&to->dydx3_shift,\r\nfrom->y4, from->y3,\r\nfrom->x4, from->x3);\r\nctc_gradient(&(to->dydx4),\r\n&(to->dydx4_shift),\r\nfrom->y5, from->y4,\r\nSH_CSS_BAYER_MAXVAL, from->x4);\r\n}
