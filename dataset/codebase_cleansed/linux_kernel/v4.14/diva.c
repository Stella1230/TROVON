static inline u_char\r\nreadreg(unsigned int ale, unsigned int adr, u_char off)\r\n{\r\nregister u_char ret;\r\nbyteout(ale, off);\r\nret = bytein(adr);\r\nreturn (ret);\r\n}\r\nstatic inline void\r\nreadfifo(unsigned int ale, unsigned int adr, u_char off, u_char *data, int size)\r\n{\r\nbyteout(ale, off);\r\ninsb(adr, data, size);\r\n}\r\nstatic inline void\r\nwritereg(unsigned int ale, unsigned int adr, u_char off, u_char data)\r\n{\r\nbyteout(ale, off);\r\nbyteout(adr, data);\r\n}\r\nstatic inline void\r\nwritefifo(unsigned int ale, unsigned int adr, u_char off, u_char *data, int size)\r\n{\r\nbyteout(ale, off);\r\noutsb(adr, data, size);\r\n}\r\nstatic inline u_char\r\nmemreadreg(unsigned long adr, u_char off)\r\n{\r\nreturn (*((unsigned char *)\r\n(((unsigned int *)adr) + off)));\r\n}\r\nstatic inline void\r\nmemwritereg(unsigned long adr, u_char off, u_char data)\r\n{\r\nregister u_char *p;\r\np = (unsigned char *)(((unsigned int *)adr) + off);\r\n*p = data;\r\n}\r\nstatic u_char\r\nReadISAC(struct IsdnCardState *cs, u_char offset)\r\n{\r\nreturn (readreg(cs->hw.diva.isac_adr, cs->hw.diva.isac, offset));\r\n}\r\nstatic void\r\nWriteISAC(struct IsdnCardState *cs, u_char offset, u_char value)\r\n{\r\nwritereg(cs->hw.diva.isac_adr, cs->hw.diva.isac, offset, value);\r\n}\r\nstatic void\r\nReadISACfifo(struct IsdnCardState *cs, u_char *data, int size)\r\n{\r\nreadfifo(cs->hw.diva.isac_adr, cs->hw.diva.isac, 0, data, size);\r\n}\r\nstatic void\r\nWriteISACfifo(struct IsdnCardState *cs, u_char *data, int size)\r\n{\r\nwritefifo(cs->hw.diva.isac_adr, cs->hw.diva.isac, 0, data, size);\r\n}\r\nstatic u_char\r\nReadISAC_IPAC(struct IsdnCardState *cs, u_char offset)\r\n{\r\nreturn (readreg(cs->hw.diva.isac_adr, cs->hw.diva.isac, offset + 0x80));\r\n}\r\nstatic void\r\nWriteISAC_IPAC(struct IsdnCardState *cs, u_char offset, u_char value)\r\n{\r\nwritereg(cs->hw.diva.isac_adr, cs->hw.diva.isac, offset | 0x80, value);\r\n}\r\nstatic void\r\nReadISACfifo_IPAC(struct IsdnCardState *cs, u_char *data, int size)\r\n{\r\nreadfifo(cs->hw.diva.isac_adr, cs->hw.diva.isac, 0x80, data, size);\r\n}\r\nstatic void\r\nWriteISACfifo_IPAC(struct IsdnCardState *cs, u_char *data, int size)\r\n{\r\nwritefifo(cs->hw.diva.isac_adr, cs->hw.diva.isac, 0x80, data, size);\r\n}\r\nstatic u_char\r\nReadHSCX(struct IsdnCardState *cs, int hscx, u_char offset)\r\n{\r\nreturn (readreg(cs->hw.diva.hscx_adr,\r\ncs->hw.diva.hscx, offset + (hscx ? 0x40 : 0)));\r\n}\r\nstatic void\r\nWriteHSCX(struct IsdnCardState *cs, int hscx, u_char offset, u_char value)\r\n{\r\nwritereg(cs->hw.diva.hscx_adr,\r\ncs->hw.diva.hscx, offset + (hscx ? 0x40 : 0), value);\r\n}\r\nstatic u_char\r\nMemReadISAC_IPAC(struct IsdnCardState *cs, u_char offset)\r\n{\r\nreturn (memreadreg(cs->hw.diva.cfg_reg, offset + 0x80));\r\n}\r\nstatic void\r\nMemWriteISAC_IPAC(struct IsdnCardState *cs, u_char offset, u_char value)\r\n{\r\nmemwritereg(cs->hw.diva.cfg_reg, offset | 0x80, value);\r\n}\r\nstatic void\r\nMemReadISACfifo_IPAC(struct IsdnCardState *cs, u_char *data, int size)\r\n{\r\nwhile (size--)\r\n*data++ = memreadreg(cs->hw.diva.cfg_reg, 0x80);\r\n}\r\nstatic void\r\nMemWriteISACfifo_IPAC(struct IsdnCardState *cs, u_char *data, int size)\r\n{\r\nwhile (size--)\r\nmemwritereg(cs->hw.diva.cfg_reg, 0x80, *data++);\r\n}\r\nstatic u_char\r\nMemReadHSCX(struct IsdnCardState *cs, int hscx, u_char offset)\r\n{\r\nreturn (memreadreg(cs->hw.diva.cfg_reg, offset + (hscx ? 0x40 : 0)));\r\n}\r\nstatic void\r\nMemWriteHSCX(struct IsdnCardState *cs, int hscx, u_char offset, u_char value)\r\n{\r\nmemwritereg(cs->hw.diva.cfg_reg, offset + (hscx ? 0x40 : 0), value);\r\n}\r\nstatic u_char\r\nMemReadISAC_IPACX(struct IsdnCardState *cs, u_char offset)\r\n{\r\nreturn (memreadreg(cs->hw.diva.cfg_reg, offset));\r\n}\r\nstatic void\r\nMemWriteISAC_IPACX(struct IsdnCardState *cs, u_char offset, u_char value)\r\n{\r\nmemwritereg(cs->hw.diva.cfg_reg, offset, value);\r\n}\r\nstatic void\r\nMemReadISACfifo_IPACX(struct IsdnCardState *cs, u_char *data, int size)\r\n{\r\nwhile (size--)\r\n*data++ = memreadreg(cs->hw.diva.cfg_reg, 0);\r\n}\r\nstatic void\r\nMemWriteISACfifo_IPACX(struct IsdnCardState *cs, u_char *data, int size)\r\n{\r\nwhile (size--)\r\nmemwritereg(cs->hw.diva.cfg_reg, 0, *data++);\r\n}\r\nstatic u_char\r\nMemReadHSCX_IPACX(struct IsdnCardState *cs, int hscx, u_char offset)\r\n{\r\nreturn (memreadreg(cs->hw.diva.cfg_reg, offset +\r\n(hscx ? IPACX_OFF_B2 : IPACX_OFF_B1)));\r\n}\r\nstatic void\r\nMemWriteHSCX_IPACX(struct IsdnCardState *cs, int hscx, u_char offset, u_char value)\r\n{\r\nmemwritereg(cs->hw.diva.cfg_reg, offset +\r\n(hscx ? IPACX_OFF_B2 : IPACX_OFF_B1), value);\r\n}\r\nstatic irqreturn_t\r\ndiva_interrupt(int intno, void *dev_id)\r\n{\r\nstruct IsdnCardState *cs = dev_id;\r\nu_char val, sval;\r\nu_long flags;\r\nint cnt = 5;\r\nspin_lock_irqsave(&cs->lock, flags);\r\nwhile (((sval = bytein(cs->hw.diva.ctrl)) & DIVA_IRQ_REQ) && cnt) {\r\nval = readreg(cs->hw.diva.hscx_adr, cs->hw.diva.hscx, HSCX_ISTA + 0x40);\r\nif (val)\r\nhscx_int_main(cs, val);\r\nval = readreg(cs->hw.diva.isac_adr, cs->hw.diva.isac, ISAC_ISTA);\r\nif (val)\r\nisac_interrupt(cs, val);\r\ncnt--;\r\n}\r\nif (!cnt)\r\nprintk(KERN_WARNING "Diva: IRQ LOOP\n");\r\nwritereg(cs->hw.diva.hscx_adr, cs->hw.diva.hscx, HSCX_MASK, 0xFF);\r\nwritereg(cs->hw.diva.hscx_adr, cs->hw.diva.hscx, HSCX_MASK + 0x40, 0xFF);\r\nwritereg(cs->hw.diva.isac_adr, cs->hw.diva.isac, ISAC_MASK, 0xFF);\r\nwritereg(cs->hw.diva.isac_adr, cs->hw.diva.isac, ISAC_MASK, 0x0);\r\nwritereg(cs->hw.diva.hscx_adr, cs->hw.diva.hscx, HSCX_MASK, 0x0);\r\nwritereg(cs->hw.diva.hscx_adr, cs->hw.diva.hscx, HSCX_MASK + 0x40, 0x0);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t\r\ndiva_irq_ipac_isa(int intno, void *dev_id)\r\n{\r\nstruct IsdnCardState *cs = dev_id;\r\nu_char ista, val;\r\nu_long flags;\r\nint icnt = 5;\r\nspin_lock_irqsave(&cs->lock, flags);\r\nista = readreg(cs->hw.diva.isac_adr, cs->hw.diva.isac, IPAC_ISTA);\r\nStart_IPACISA:\r\nif (cs->debug & L1_DEB_IPAC)\r\ndebugl1(cs, "IPAC ISTA %02X", ista);\r\nif (ista & 0x0f) {\r\nval = readreg(cs->hw.diva.isac_adr, cs->hw.diva.isac, HSCX_ISTA + 0x40);\r\nif (ista & 0x01)\r\nval |= 0x01;\r\nif (ista & 0x04)\r\nval |= 0x02;\r\nif (ista & 0x08)\r\nval |= 0x04;\r\nif (val)\r\nhscx_int_main(cs, val);\r\n}\r\nif (ista & 0x20) {\r\nval = 0xfe & readreg(cs->hw.diva.isac_adr, cs->hw.diva.isac, ISAC_ISTA + 0x80);\r\nif (val) {\r\nisac_interrupt(cs, val);\r\n}\r\n}\r\nif (ista & 0x10) {\r\nval = 0x01;\r\nisac_interrupt(cs, val);\r\n}\r\nista = readreg(cs->hw.diva.isac_adr, cs->hw.diva.isac, IPAC_ISTA);\r\nif ((ista & 0x3f) && icnt) {\r\nicnt--;\r\ngoto Start_IPACISA;\r\n}\r\nif (!icnt)\r\nprintk(KERN_WARNING "DIVA IPAC IRQ LOOP\n");\r\nwritereg(cs->hw.diva.isac_adr, cs->hw.diva.isac, IPAC_MASK, 0xFF);\r\nwritereg(cs->hw.diva.isac_adr, cs->hw.diva.isac, IPAC_MASK, 0xC0);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic inline void\r\nMemwaitforCEC(struct IsdnCardState *cs, int hscx)\r\n{\r\nint to = 50;\r\nwhile ((MemReadHSCX(cs, hscx, HSCX_STAR) & 0x04) && to) {\r\nudelay(1);\r\nto--;\r\n}\r\nif (!to)\r\nprintk(KERN_WARNING "HiSax: waitforCEC timeout\n");\r\n}\r\nstatic inline void\r\nMemwaitforXFW(struct IsdnCardState *cs, int hscx)\r\n{\r\nint to = 50;\r\nwhile (((MemReadHSCX(cs, hscx, HSCX_STAR) & 0x44) != 0x40) && to) {\r\nudelay(1);\r\nto--;\r\n}\r\nif (!to)\r\nprintk(KERN_WARNING "HiSax: waitforXFW timeout\n");\r\n}\r\nstatic inline void\r\nMemWriteHSCXCMDR(struct IsdnCardState *cs, int hscx, u_char data)\r\n{\r\nMemwaitforCEC(cs, hscx);\r\nMemWriteHSCX(cs, hscx, HSCX_CMDR, data);\r\n}\r\nstatic void\r\nMemhscx_empty_fifo(struct BCState *bcs, int count)\r\n{\r\nu_char *ptr;\r\nstruct IsdnCardState *cs = bcs->cs;\r\nint cnt;\r\nif ((cs->debug & L1_DEB_HSCX) && !(cs->debug & L1_DEB_HSCX_FIFO))\r\ndebugl1(cs, "hscx_empty_fifo");\r\nif (bcs->hw.hscx.rcvidx + count > HSCX_BUFMAX) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "hscx_empty_fifo: incoming packet too large");\r\nMemWriteHSCXCMDR(cs, bcs->hw.hscx.hscx, 0x80);\r\nbcs->hw.hscx.rcvidx = 0;\r\nreturn;\r\n}\r\nptr = bcs->hw.hscx.rcvbuf + bcs->hw.hscx.rcvidx;\r\ncnt = count;\r\nwhile (cnt--)\r\n*ptr++ = memreadreg(cs->hw.diva.cfg_reg, bcs->hw.hscx.hscx ? 0x40 : 0);\r\nMemWriteHSCXCMDR(cs, bcs->hw.hscx.hscx, 0x80);\r\nptr = bcs->hw.hscx.rcvbuf + bcs->hw.hscx.rcvidx;\r\nbcs->hw.hscx.rcvidx += count;\r\nif (cs->debug & L1_DEB_HSCX_FIFO) {\r\nchar *t = bcs->blog;\r\nt += sprintf(t, "hscx_empty_fifo %c cnt %d",\r\nbcs->hw.hscx.hscx ? 'B' : 'A', count);\r\nQuickHex(t, ptr, count);\r\ndebugl1(cs, "%s", bcs->blog);\r\n}\r\n}\r\nstatic void\r\nMemhscx_fill_fifo(struct BCState *bcs)\r\n{\r\nstruct IsdnCardState *cs = bcs->cs;\r\nint more, count, cnt;\r\nint fifo_size = test_bit(HW_IPAC, &cs->HW_Flags) ? 64 : 32;\r\nu_char *ptr, *p;\r\nif ((cs->debug & L1_DEB_HSCX) && !(cs->debug & L1_DEB_HSCX_FIFO))\r\ndebugl1(cs, "hscx_fill_fifo");\r\nif (!bcs->tx_skb)\r\nreturn;\r\nif (bcs->tx_skb->len <= 0)\r\nreturn;\r\nmore = (bcs->mode == L1_MODE_TRANS) ? 1 : 0;\r\nif (bcs->tx_skb->len > fifo_size) {\r\nmore = !0;\r\ncount = fifo_size;\r\n} else\r\ncount = bcs->tx_skb->len;\r\ncnt = count;\r\nMemwaitforXFW(cs, bcs->hw.hscx.hscx);\r\np = ptr = bcs->tx_skb->data;\r\nskb_pull(bcs->tx_skb, count);\r\nbcs->tx_cnt -= count;\r\nbcs->hw.hscx.count += count;\r\nwhile (cnt--)\r\nmemwritereg(cs->hw.diva.cfg_reg, bcs->hw.hscx.hscx ? 0x40 : 0,\r\n*p++);\r\nMemWriteHSCXCMDR(cs, bcs->hw.hscx.hscx, more ? 0x8 : 0xa);\r\nif (cs->debug & L1_DEB_HSCX_FIFO) {\r\nchar *t = bcs->blog;\r\nt += sprintf(t, "hscx_fill_fifo %c cnt %d",\r\nbcs->hw.hscx.hscx ? 'B' : 'A', count);\r\nQuickHex(t, ptr, count);\r\ndebugl1(cs, "%s", bcs->blog);\r\n}\r\n}\r\nstatic void\r\nMemhscx_interrupt(struct IsdnCardState *cs, u_char val, u_char hscx)\r\n{\r\nu_char r;\r\nstruct BCState *bcs = cs->bcs + hscx;\r\nstruct sk_buff *skb;\r\nint fifo_size = test_bit(HW_IPAC, &cs->HW_Flags) ? 64 : 32;\r\nint count;\r\nif (!test_bit(BC_FLG_INIT, &bcs->Flag))\r\nreturn;\r\nif (val & 0x80) {\r\nr = MemReadHSCX(cs, hscx, HSCX_RSTA);\r\nif ((r & 0xf0) != 0xa0) {\r\nif (!(r & 0x80))\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "HSCX invalid frame");\r\nif ((r & 0x40) && bcs->mode)\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "HSCX RDO mode=%d",\r\nbcs->mode);\r\nif (!(r & 0x20))\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "HSCX CRC error");\r\nMemWriteHSCXCMDR(cs, hscx, 0x80);\r\n} else {\r\ncount = MemReadHSCX(cs, hscx, HSCX_RBCL) & (\r\ntest_bit(HW_IPAC, &cs->HW_Flags) ? 0x3f : 0x1f);\r\nif (count == 0)\r\ncount = fifo_size;\r\nMemhscx_empty_fifo(bcs, count);\r\nif ((count = bcs->hw.hscx.rcvidx - 1) > 0) {\r\nif (cs->debug & L1_DEB_HSCX_FIFO)\r\ndebugl1(cs, "HX Frame %d", count);\r\nif (!(skb = dev_alloc_skb(count)))\r\nprintk(KERN_WARNING "HSCX: receive out of memory\n");\r\nelse {\r\nskb_put_data(skb, bcs->hw.hscx.rcvbuf,\r\ncount);\r\nskb_queue_tail(&bcs->rqueue, skb);\r\n}\r\n}\r\n}\r\nbcs->hw.hscx.rcvidx = 0;\r\nschedule_event(bcs, B_RCVBUFREADY);\r\n}\r\nif (val & 0x40) {\r\nMemhscx_empty_fifo(bcs, fifo_size);\r\nif (bcs->mode == L1_MODE_TRANS) {\r\nif (!(skb = dev_alloc_skb(fifo_size)))\r\nprintk(KERN_WARNING "HiSax: receive out of memory\n");\r\nelse {\r\nskb_put_data(skb, bcs->hw.hscx.rcvbuf,\r\nfifo_size);\r\nskb_queue_tail(&bcs->rqueue, skb);\r\n}\r\nbcs->hw.hscx.rcvidx = 0;\r\nschedule_event(bcs, B_RCVBUFREADY);\r\n}\r\n}\r\nif (val & 0x10) {\r\nif (bcs->tx_skb) {\r\nif (bcs->tx_skb->len) {\r\nMemhscx_fill_fifo(bcs);\r\nreturn;\r\n} else {\r\nif (test_bit(FLG_LLI_L1WAKEUP, &bcs->st->lli.flag) &&\r\n(PACKET_NOACK != bcs->tx_skb->pkt_type)) {\r\nu_long flags;\r\nspin_lock_irqsave(&bcs->aclock, flags);\r\nbcs->ackcnt += bcs->hw.hscx.count;\r\nspin_unlock_irqrestore(&bcs->aclock, flags);\r\nschedule_event(bcs, B_ACKPENDING);\r\n}\r\ndev_kfree_skb_irq(bcs->tx_skb);\r\nbcs->hw.hscx.count = 0;\r\nbcs->tx_skb = NULL;\r\n}\r\n}\r\nif ((bcs->tx_skb = skb_dequeue(&bcs->squeue))) {\r\nbcs->hw.hscx.count = 0;\r\ntest_and_set_bit(BC_FLG_BUSY, &bcs->Flag);\r\nMemhscx_fill_fifo(bcs);\r\n} else {\r\ntest_and_clear_bit(BC_FLG_BUSY, &bcs->Flag);\r\nschedule_event(bcs, B_XMTBUFREADY);\r\n}\r\n}\r\n}\r\nstatic inline void\r\nMemhscx_int_main(struct IsdnCardState *cs, u_char val)\r\n{\r\nu_char exval;\r\nstruct BCState *bcs;\r\nif (val & 0x01) {\r\nbcs = cs->bcs + 1;\r\nexval = MemReadHSCX(cs, 1, HSCX_EXIR);\r\nif (exval & 0x40) {\r\nif (bcs->mode == 1)\r\nMemhscx_fill_fifo(bcs);\r\nelse {\r\nif (bcs->tx_skb) {\r\nskb_push(bcs->tx_skb, bcs->hw.hscx.count);\r\nbcs->tx_cnt += bcs->hw.hscx.count;\r\nbcs->hw.hscx.count = 0;\r\n}\r\nMemWriteHSCXCMDR(cs, bcs->hw.hscx.hscx, 0x01);\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "HSCX B EXIR %x Lost TX", exval);\r\n}\r\n} else if (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "HSCX B EXIR %x", exval);\r\n}\r\nif (val & 0xf8) {\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "HSCX B interrupt %x", val);\r\nMemhscx_interrupt(cs, val, 1);\r\n}\r\nif (val & 0x02) {\r\nbcs = cs->bcs;\r\nexval = MemReadHSCX(cs, 0, HSCX_EXIR);\r\nif (exval & 0x40) {\r\nif (bcs->mode == L1_MODE_TRANS)\r\nMemhscx_fill_fifo(bcs);\r\nelse {\r\nif (bcs->tx_skb) {\r\nskb_push(bcs->tx_skb, bcs->hw.hscx.count);\r\nbcs->tx_cnt += bcs->hw.hscx.count;\r\nbcs->hw.hscx.count = 0;\r\n}\r\nMemWriteHSCXCMDR(cs, bcs->hw.hscx.hscx, 0x01);\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "HSCX A EXIR %x Lost TX", exval);\r\n}\r\n} else if (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "HSCX A EXIR %x", exval);\r\n}\r\nif (val & 0x04) {\r\nexval = MemReadHSCX(cs, 0, HSCX_ISTA);\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "HSCX A interrupt %x", exval);\r\nMemhscx_interrupt(cs, exval, 0);\r\n}\r\n}\r\nstatic irqreturn_t\r\ndiva_irq_ipac_pci(int intno, void *dev_id)\r\n{\r\nstruct IsdnCardState *cs = dev_id;\r\nu_char ista, val;\r\nint icnt = 5;\r\nu_char *cfg;\r\nu_long flags;\r\nspin_lock_irqsave(&cs->lock, flags);\r\ncfg = (u_char *) cs->hw.diva.pci_cfg;\r\nval = *cfg;\r\nif (!(val & PITA_INT0_STATUS)) {\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn IRQ_NONE;\r\n}\r\n*cfg = PITA_INT0_STATUS;\r\nista = memreadreg(cs->hw.diva.cfg_reg, IPAC_ISTA);\r\nStart_IPACPCI:\r\nif (cs->debug & L1_DEB_IPAC)\r\ndebugl1(cs, "IPAC ISTA %02X", ista);\r\nif (ista & 0x0f) {\r\nval = memreadreg(cs->hw.diva.cfg_reg, HSCX_ISTA + 0x40);\r\nif (ista & 0x01)\r\nval |= 0x01;\r\nif (ista & 0x04)\r\nval |= 0x02;\r\nif (ista & 0x08)\r\nval |= 0x04;\r\nif (val)\r\nMemhscx_int_main(cs, val);\r\n}\r\nif (ista & 0x20) {\r\nval = 0xfe & memreadreg(cs->hw.diva.cfg_reg, ISAC_ISTA + 0x80);\r\nif (val) {\r\nisac_interrupt(cs, val);\r\n}\r\n}\r\nif (ista & 0x10) {\r\nval = 0x01;\r\nisac_interrupt(cs, val);\r\n}\r\nista = memreadreg(cs->hw.diva.cfg_reg, IPAC_ISTA);\r\nif ((ista & 0x3f) && icnt) {\r\nicnt--;\r\ngoto Start_IPACPCI;\r\n}\r\nif (!icnt)\r\nprintk(KERN_WARNING "DIVA IPAC PCI IRQ LOOP\n");\r\nmemwritereg(cs->hw.diva.cfg_reg, IPAC_MASK, 0xFF);\r\nmemwritereg(cs->hw.diva.cfg_reg, IPAC_MASK, 0xC0);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t\r\ndiva_irq_ipacx_pci(int intno, void *dev_id)\r\n{\r\nstruct IsdnCardState *cs = dev_id;\r\nu_char val;\r\nu_char *cfg;\r\nu_long flags;\r\nspin_lock_irqsave(&cs->lock, flags);\r\ncfg = (u_char *) cs->hw.diva.pci_cfg;\r\nval = *cfg;\r\nif (!(val & PITA_INT0_STATUS)) {\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn IRQ_NONE;\r\n}\r\ninterrupt_ipacx(cs);\r\n*cfg = PITA_INT0_STATUS;\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\nrelease_io_diva(struct IsdnCardState *cs)\r\n{\r\nint bytecnt;\r\nif ((cs->subtyp == DIVA_IPAC_PCI) ||\r\n(cs->subtyp == DIVA_IPACX_PCI)) {\r\nu_int *cfg = (unsigned int *)cs->hw.diva.pci_cfg;\r\n*cfg = 0;\r\n*cfg = 2;\r\nif (cs->hw.diva.cfg_reg)\r\niounmap((void *)cs->hw.diva.cfg_reg);\r\nif (cs->hw.diva.pci_cfg)\r\niounmap((void *)cs->hw.diva.pci_cfg);\r\nreturn;\r\n} else if (cs->subtyp != DIVA_IPAC_ISA) {\r\ndel_timer(&cs->hw.diva.tl);\r\nif (cs->hw.diva.cfg_reg)\r\nbyteout(cs->hw.diva.ctrl, 0);\r\n}\r\nif ((cs->subtyp == DIVA_ISA) || (cs->subtyp == DIVA_IPAC_ISA))\r\nbytecnt = 8;\r\nelse\r\nbytecnt = 32;\r\nif (cs->hw.diva.cfg_reg) {\r\nrelease_region(cs->hw.diva.cfg_reg, bytecnt);\r\n}\r\n}\r\nstatic void\r\niounmap_diva(struct IsdnCardState *cs)\r\n{\r\nif ((cs->subtyp == DIVA_IPAC_PCI) || (cs->subtyp == DIVA_IPACX_PCI)) {\r\nif (cs->hw.diva.cfg_reg) {\r\niounmap((void *)cs->hw.diva.cfg_reg);\r\ncs->hw.diva.cfg_reg = 0;\r\n}\r\nif (cs->hw.diva.pci_cfg) {\r\niounmap((void *)cs->hw.diva.pci_cfg);\r\ncs->hw.diva.pci_cfg = 0;\r\n}\r\n}\r\nreturn;\r\n}\r\nstatic void\r\nreset_diva(struct IsdnCardState *cs)\r\n{\r\nif (cs->subtyp == DIVA_IPAC_ISA) {\r\nwritereg(cs->hw.diva.isac_adr, cs->hw.diva.isac, IPAC_POTA2, 0x20);\r\nmdelay(10);\r\nwritereg(cs->hw.diva.isac_adr, cs->hw.diva.isac, IPAC_POTA2, 0x00);\r\nmdelay(10);\r\nwritereg(cs->hw.diva.isac_adr, cs->hw.diva.isac, IPAC_MASK, 0xc0);\r\n} else if (cs->subtyp == DIVA_IPAC_PCI) {\r\nunsigned int *ireg = (unsigned int *)(cs->hw.diva.pci_cfg +\r\nPITA_MISC_REG);\r\n*ireg = PITA_PARA_SOFTRESET | PITA_PARA_MPX_MODE;\r\nmdelay(10);\r\n*ireg = PITA_PARA_MPX_MODE;\r\nmdelay(10);\r\nmemwritereg(cs->hw.diva.cfg_reg, IPAC_MASK, 0xc0);\r\n} else if (cs->subtyp == DIVA_IPACX_PCI) {\r\nunsigned int *ireg = (unsigned int *)(cs->hw.diva.pci_cfg +\r\nPITA_MISC_REG);\r\n*ireg = PITA_PARA_SOFTRESET | PITA_PARA_MPX_MODE;\r\nmdelay(10);\r\n*ireg = PITA_PARA_MPX_MODE | PITA_SER_SOFTRESET;\r\nmdelay(10);\r\nMemWriteISAC_IPACX(cs, IPACX_MASK, 0xff);\r\n} else {\r\ncs->hw.diva.ctrl_reg = 0;\r\nbyteout(cs->hw.diva.ctrl, cs->hw.diva.ctrl_reg);\r\nmdelay(10);\r\ncs->hw.diva.ctrl_reg |= DIVA_RESET;\r\nbyteout(cs->hw.diva.ctrl, cs->hw.diva.ctrl_reg);\r\nmdelay(10);\r\nif (cs->subtyp == DIVA_ISA)\r\ncs->hw.diva.ctrl_reg |= DIVA_ISA_LED_A;\r\nelse {\r\nbyteout(cs->hw.diva.pci_cfg + 0x69, 9);\r\ncs->hw.diva.ctrl_reg |= DIVA_PCI_LED_A;\r\n}\r\nbyteout(cs->hw.diva.ctrl, cs->hw.diva.ctrl_reg);\r\n}\r\n}\r\nstatic void\r\ndiva_led_handler(struct IsdnCardState *cs)\r\n{\r\nint blink = 0;\r\nif ((cs->subtyp == DIVA_IPAC_ISA) ||\r\n(cs->subtyp == DIVA_IPAC_PCI) ||\r\n(cs->subtyp == DIVA_IPACX_PCI))\r\nreturn;\r\ndel_timer(&cs->hw.diva.tl);\r\nif (cs->hw.diva.status & DIVA_ASSIGN)\r\ncs->hw.diva.ctrl_reg |= (DIVA_ISA == cs->subtyp) ?\r\nDIVA_ISA_LED_A : DIVA_PCI_LED_A;\r\nelse {\r\ncs->hw.diva.ctrl_reg ^= (DIVA_ISA == cs->subtyp) ?\r\nDIVA_ISA_LED_A : DIVA_PCI_LED_A;\r\nblink = 250;\r\n}\r\nif (cs->hw.diva.status & 0xf000)\r\ncs->hw.diva.ctrl_reg |= (DIVA_ISA == cs->subtyp) ?\r\nDIVA_ISA_LED_B : DIVA_PCI_LED_B;\r\nelse if (cs->hw.diva.status & 0x0f00) {\r\ncs->hw.diva.ctrl_reg ^= (DIVA_ISA == cs->subtyp) ?\r\nDIVA_ISA_LED_B : DIVA_PCI_LED_B;\r\nblink = 500;\r\n} else\r\ncs->hw.diva.ctrl_reg &= ~((DIVA_ISA == cs->subtyp) ?\r\nDIVA_ISA_LED_B : DIVA_PCI_LED_B);\r\nbyteout(cs->hw.diva.ctrl, cs->hw.diva.ctrl_reg);\r\nif (blink) {\r\ninit_timer(&cs->hw.diva.tl);\r\ncs->hw.diva.tl.expires = jiffies + ((blink * HZ) / 1000);\r\nadd_timer(&cs->hw.diva.tl);\r\n}\r\n}\r\nstatic int\r\nDiva_card_msg(struct IsdnCardState *cs, int mt, void *arg)\r\n{\r\nu_int *ireg;\r\nu_long flags;\r\nswitch (mt) {\r\ncase CARD_RESET:\r\nspin_lock_irqsave(&cs->lock, flags);\r\nreset_diva(cs);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn (0);\r\ncase CARD_RELEASE:\r\nrelease_io_diva(cs);\r\nreturn (0);\r\ncase CARD_INIT:\r\nspin_lock_irqsave(&cs->lock, flags);\r\nreset_diva(cs);\r\nif (cs->subtyp == DIVA_IPACX_PCI) {\r\nireg = (unsigned int *)cs->hw.diva.pci_cfg;\r\n*ireg = PITA_INT0_ENABLE;\r\ninit_ipacx(cs, 3);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn (0);\r\n}\r\nif (cs->subtyp == DIVA_IPAC_PCI) {\r\nireg = (unsigned int *)cs->hw.diva.pci_cfg;\r\n*ireg = PITA_INT0_ENABLE;\r\n}\r\ninithscxisac(cs, 3);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn (0);\r\ncase CARD_TEST:\r\nreturn (0);\r\ncase (MDL_REMOVE | REQUEST):\r\ncs->hw.diva.status = 0;\r\nbreak;\r\ncase (MDL_ASSIGN | REQUEST):\r\ncs->hw.diva.status |= DIVA_ASSIGN;\r\nbreak;\r\ncase MDL_INFO_SETUP:\r\nif ((long)arg)\r\ncs->hw.diva.status |= 0x0200;\r\nelse\r\ncs->hw.diva.status |= 0x0100;\r\nbreak;\r\ncase MDL_INFO_CONN:\r\nif ((long)arg)\r\ncs->hw.diva.status |= 0x2000;\r\nelse\r\ncs->hw.diva.status |= 0x1000;\r\nbreak;\r\ncase MDL_INFO_REL:\r\nif ((long)arg) {\r\ncs->hw.diva.status &= ~0x2000;\r\ncs->hw.diva.status &= ~0x0200;\r\n} else {\r\ncs->hw.diva.status &= ~0x1000;\r\ncs->hw.diva.status &= ~0x0100;\r\n}\r\nbreak;\r\n}\r\nif ((cs->subtyp != DIVA_IPAC_ISA) &&\r\n(cs->subtyp != DIVA_IPAC_PCI) &&\r\n(cs->subtyp != DIVA_IPACX_PCI)) {\r\nspin_lock_irqsave(&cs->lock, flags);\r\ndiva_led_handler(cs);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\n}\r\nreturn (0);\r\n}\r\nstatic int setup_diva_common(struct IsdnCardState *cs)\r\n{\r\nint bytecnt;\r\nu_char val;\r\nif ((cs->subtyp == DIVA_ISA) || (cs->subtyp == DIVA_IPAC_ISA))\r\nbytecnt = 8;\r\nelse\r\nbytecnt = 32;\r\nprintk(KERN_INFO\r\n"Diva: %s card configured at %#lx IRQ %d\n",\r\n(cs->subtyp == DIVA_PCI) ? "PCI" :\r\n(cs->subtyp == DIVA_ISA) ? "ISA" :\r\n(cs->subtyp == DIVA_IPAC_ISA) ? "IPAC ISA" :\r\n(cs->subtyp == DIVA_IPAC_PCI) ? "IPAC PCI" : "IPACX PCI",\r\ncs->hw.diva.cfg_reg, cs->irq);\r\nif ((cs->subtyp == DIVA_IPAC_PCI) ||\r\n(cs->subtyp == DIVA_IPACX_PCI) ||\r\n(cs->subtyp == DIVA_PCI))\r\nprintk(KERN_INFO "Diva: %s space at %#lx\n",\r\n(cs->subtyp == DIVA_PCI) ? "PCI" :\r\n(cs->subtyp == DIVA_IPAC_PCI) ? "IPAC PCI" : "IPACX PCI",\r\ncs->hw.diva.pci_cfg);\r\nif ((cs->subtyp != DIVA_IPAC_PCI) &&\r\n(cs->subtyp != DIVA_IPACX_PCI)) {\r\nif (!request_region(cs->hw.diva.cfg_reg, bytecnt, "diva isdn")) {\r\nprintk(KERN_WARNING\r\n"HiSax: %s config port %lx-%lx already in use\n",\r\n"diva",\r\ncs->hw.diva.cfg_reg,\r\ncs->hw.diva.cfg_reg + bytecnt);\r\niounmap_diva(cs);\r\nreturn (0);\r\n}\r\n}\r\ncs->BC_Read_Reg = &ReadHSCX;\r\ncs->BC_Write_Reg = &WriteHSCX;\r\ncs->BC_Send_Data = &hscx_fill_fifo;\r\ncs->cardmsg = &Diva_card_msg;\r\nsetup_isac(cs);\r\nif (cs->subtyp == DIVA_IPAC_ISA) {\r\ncs->readisac = &ReadISAC_IPAC;\r\ncs->writeisac = &WriteISAC_IPAC;\r\ncs->readisacfifo = &ReadISACfifo_IPAC;\r\ncs->writeisacfifo = &WriteISACfifo_IPAC;\r\ncs->irq_func = &diva_irq_ipac_isa;\r\nval = readreg(cs->hw.diva.isac_adr, cs->hw.diva.isac, IPAC_ID);\r\nprintk(KERN_INFO "Diva: IPAC version %x\n", val);\r\n} else if (cs->subtyp == DIVA_IPAC_PCI) {\r\ncs->readisac = &MemReadISAC_IPAC;\r\ncs->writeisac = &MemWriteISAC_IPAC;\r\ncs->readisacfifo = &MemReadISACfifo_IPAC;\r\ncs->writeisacfifo = &MemWriteISACfifo_IPAC;\r\ncs->BC_Read_Reg = &MemReadHSCX;\r\ncs->BC_Write_Reg = &MemWriteHSCX;\r\ncs->BC_Send_Data = &Memhscx_fill_fifo;\r\ncs->irq_func = &diva_irq_ipac_pci;\r\nval = memreadreg(cs->hw.diva.cfg_reg, IPAC_ID);\r\nprintk(KERN_INFO "Diva: IPAC version %x\n", val);\r\n} else if (cs->subtyp == DIVA_IPACX_PCI) {\r\ncs->readisac = &MemReadISAC_IPACX;\r\ncs->writeisac = &MemWriteISAC_IPACX;\r\ncs->readisacfifo = &MemReadISACfifo_IPACX;\r\ncs->writeisacfifo = &MemWriteISACfifo_IPACX;\r\ncs->BC_Read_Reg = &MemReadHSCX_IPACX;\r\ncs->BC_Write_Reg = &MemWriteHSCX_IPACX;\r\ncs->BC_Send_Data = NULL;\r\ncs->irq_func = &diva_irq_ipacx_pci;\r\nprintk(KERN_INFO "Diva: IPACX Design Id: %x\n",\r\nMemReadISAC_IPACX(cs, IPACX_ID) & 0x3F);\r\n} else {\r\nsetup_timer(&cs->hw.diva.tl, (void *)diva_led_handler,\r\n(long)cs);\r\ncs->readisac = &ReadISAC;\r\ncs->writeisac = &WriteISAC;\r\ncs->readisacfifo = &ReadISACfifo;\r\ncs->writeisacfifo = &WriteISACfifo;\r\ncs->irq_func = &diva_interrupt;\r\nISACVersion(cs, "Diva:");\r\nif (HscxVersion(cs, "Diva:")) {\r\nprintk(KERN_WARNING\r\n"Diva: wrong HSCX versions check IO address\n");\r\nrelease_io_diva(cs);\r\nreturn (0);\r\n}\r\n}\r\nreturn (1);\r\n}\r\nstatic int setup_diva_isa(struct IsdnCard *card)\r\n{\r\nstruct IsdnCardState *cs = card->cs;\r\nu_char val;\r\nif (!card->para[1])\r\nreturn (-1);\r\ncs->hw.diva.ctrl_reg = 0;\r\ncs->hw.diva.cfg_reg = card->para[1];\r\nval = readreg(cs->hw.diva.cfg_reg + DIVA_IPAC_ADR,\r\ncs->hw.diva.cfg_reg + DIVA_IPAC_DATA, IPAC_ID);\r\nprintk(KERN_INFO "Diva: IPAC version %x\n", val);\r\nif ((val == 1) || (val == 2)) {\r\ncs->subtyp = DIVA_IPAC_ISA;\r\ncs->hw.diva.ctrl = 0;\r\ncs->hw.diva.isac = card->para[1] + DIVA_IPAC_DATA;\r\ncs->hw.diva.hscx = card->para[1] + DIVA_IPAC_DATA;\r\ncs->hw.diva.isac_adr = card->para[1] + DIVA_IPAC_ADR;\r\ncs->hw.diva.hscx_adr = card->para[1] + DIVA_IPAC_ADR;\r\ntest_and_set_bit(HW_IPAC, &cs->HW_Flags);\r\n} else {\r\ncs->subtyp = DIVA_ISA;\r\ncs->hw.diva.ctrl = card->para[1] + DIVA_ISA_CTRL;\r\ncs->hw.diva.isac = card->para[1] + DIVA_ISA_ISAC_DATA;\r\ncs->hw.diva.hscx = card->para[1] + DIVA_HSCX_DATA;\r\ncs->hw.diva.isac_adr = card->para[1] + DIVA_ISA_ISAC_ADR;\r\ncs->hw.diva.hscx_adr = card->para[1] + DIVA_HSCX_ADR;\r\n}\r\ncs->irq = card->para[0];\r\nreturn (1);\r\n}\r\nstatic int setup_diva_isa(struct IsdnCard *card)\r\n{\r\nreturn (-1);\r\n}\r\nstatic int setup_diva_isapnp(struct IsdnCard *card)\r\n{\r\nstruct IsdnCardState *cs = card->cs;\r\nstruct pnp_dev *pnp_d;\r\nif (!isapnp_present())\r\nreturn (-1);\r\nwhile (ipid->card_vendor) {\r\nif ((pnp_c = pnp_find_card(ipid->card_vendor,\r\nipid->card_device, pnp_c))) {\r\npnp_d = NULL;\r\nif ((pnp_d = pnp_find_dev(pnp_c,\r\nipid->vendor, ipid->function, pnp_d))) {\r\nint err;\r\nprintk(KERN_INFO "HiSax: %s detected\n",\r\n(char *)ipid->driver_data);\r\npnp_disable_dev(pnp_d);\r\nerr = pnp_activate_dev(pnp_d);\r\nif (err < 0) {\r\nprintk(KERN_WARNING "%s: pnp_activate_dev ret(%d)\n",\r\n__func__, err);\r\nreturn (0);\r\n}\r\ncard->para[1] = pnp_port_start(pnp_d, 0);\r\ncard->para[0] = pnp_irq(pnp_d, 0);\r\nif (!card->para[0] || !card->para[1]) {\r\nprintk(KERN_ERR "Diva PnP:some resources are missing %ld/%lx\n",\r\ncard->para[0], card->para[1]);\r\npnp_disable_dev(pnp_d);\r\nreturn (0);\r\n}\r\ncs->hw.diva.cfg_reg = card->para[1];\r\ncs->irq = card->para[0];\r\nif (ipid->function == ISAPNP_FUNCTION(0xA1)) {\r\ncs->subtyp = DIVA_IPAC_ISA;\r\ncs->hw.diva.ctrl = 0;\r\ncs->hw.diva.isac =\r\ncard->para[1] + DIVA_IPAC_DATA;\r\ncs->hw.diva.hscx =\r\ncard->para[1] + DIVA_IPAC_DATA;\r\ncs->hw.diva.isac_adr =\r\ncard->para[1] + DIVA_IPAC_ADR;\r\ncs->hw.diva.hscx_adr =\r\ncard->para[1] + DIVA_IPAC_ADR;\r\ntest_and_set_bit(HW_IPAC, &cs->HW_Flags);\r\n} else {\r\ncs->subtyp = DIVA_ISA;\r\ncs->hw.diva.ctrl =\r\ncard->para[1] + DIVA_ISA_CTRL;\r\ncs->hw.diva.isac =\r\ncard->para[1] + DIVA_ISA_ISAC_DATA;\r\ncs->hw.diva.hscx =\r\ncard->para[1] + DIVA_HSCX_DATA;\r\ncs->hw.diva.isac_adr =\r\ncard->para[1] + DIVA_ISA_ISAC_ADR;\r\ncs->hw.diva.hscx_adr =\r\ncard->para[1] + DIVA_HSCX_ADR;\r\n}\r\nreturn (1);\r\n} else {\r\nprintk(KERN_ERR "Diva PnP: PnP error card found, no device\n");\r\nreturn (0);\r\n}\r\n}\r\nipid++;\r\npnp_c = NULL;\r\n}\r\nreturn (-1);\r\n}\r\nstatic int setup_diva_isapnp(struct IsdnCard *card)\r\n{\r\nreturn (-1);\r\n}\r\nstatic int setup_diva_pci(struct IsdnCard *card)\r\n{\r\nstruct IsdnCardState *cs = card->cs;\r\ncs->subtyp = 0;\r\nif ((dev_diva = hisax_find_pci_device(PCI_VENDOR_ID_EICON,\r\nPCI_DEVICE_ID_EICON_DIVA20, dev_diva))) {\r\nif (pci_enable_device(dev_diva))\r\nreturn (0);\r\ncs->subtyp = DIVA_PCI;\r\ncs->irq = dev_diva->irq;\r\ncs->hw.diva.cfg_reg = pci_resource_start(dev_diva, 2);\r\n} else if ((dev_diva_u = hisax_find_pci_device(PCI_VENDOR_ID_EICON,\r\nPCI_DEVICE_ID_EICON_DIVA20_U, dev_diva_u))) {\r\nif (pci_enable_device(dev_diva_u))\r\nreturn (0);\r\ncs->subtyp = DIVA_PCI;\r\ncs->irq = dev_diva_u->irq;\r\ncs->hw.diva.cfg_reg = pci_resource_start(dev_diva_u, 2);\r\n} else if ((dev_diva201 = hisax_find_pci_device(PCI_VENDOR_ID_EICON,\r\nPCI_DEVICE_ID_EICON_DIVA201, dev_diva201))) {\r\nif (pci_enable_device(dev_diva201))\r\nreturn (0);\r\ncs->subtyp = DIVA_IPAC_PCI;\r\ncs->irq = dev_diva201->irq;\r\ncs->hw.diva.pci_cfg =\r\n(ulong) ioremap(pci_resource_start(dev_diva201, 0), 4096);\r\ncs->hw.diva.cfg_reg =\r\n(ulong) ioremap(pci_resource_start(dev_diva201, 1), 4096);\r\n} else if ((dev_diva202 = hisax_find_pci_device(PCI_VENDOR_ID_EICON,\r\nPCI_DEVICE_ID_EICON_DIVA202, dev_diva202))) {\r\nif (pci_enable_device(dev_diva202))\r\nreturn (0);\r\ncs->subtyp = DIVA_IPACX_PCI;\r\ncs->irq = dev_diva202->irq;\r\ncs->hw.diva.pci_cfg =\r\n(ulong) ioremap(pci_resource_start(dev_diva202, 0), 4096);\r\ncs->hw.diva.cfg_reg =\r\n(ulong) ioremap(pci_resource_start(dev_diva202, 1), 4096);\r\n} else {\r\nreturn (-1);\r\n}\r\nif (!cs->irq) {\r\nprintk(KERN_WARNING "Diva: No IRQ for PCI card found\n");\r\niounmap_diva(cs);\r\nreturn (0);\r\n}\r\nif (!cs->hw.diva.cfg_reg) {\r\nprintk(KERN_WARNING "Diva: No IO-Adr for PCI card found\n");\r\niounmap_diva(cs);\r\nreturn (0);\r\n}\r\ncs->irq_flags |= IRQF_SHARED;\r\nif ((cs->subtyp == DIVA_IPAC_PCI) ||\r\n(cs->subtyp == DIVA_IPACX_PCI)) {\r\ncs->hw.diva.ctrl = 0;\r\ncs->hw.diva.isac = 0;\r\ncs->hw.diva.hscx = 0;\r\ncs->hw.diva.isac_adr = 0;\r\ncs->hw.diva.hscx_adr = 0;\r\ntest_and_set_bit(HW_IPAC, &cs->HW_Flags);\r\n} else {\r\ncs->hw.diva.ctrl = cs->hw.diva.cfg_reg + DIVA_PCI_CTRL;\r\ncs->hw.diva.isac = cs->hw.diva.cfg_reg + DIVA_PCI_ISAC_DATA;\r\ncs->hw.diva.hscx = cs->hw.diva.cfg_reg + DIVA_HSCX_DATA;\r\ncs->hw.diva.isac_adr = cs->hw.diva.cfg_reg + DIVA_PCI_ISAC_ADR;\r\ncs->hw.diva.hscx_adr = cs->hw.diva.cfg_reg + DIVA_HSCX_ADR;\r\n}\r\nreturn (1);\r\n}\r\nstatic int setup_diva_pci(struct IsdnCard *card)\r\n{\r\nreturn (-1);\r\n}\r\nint setup_diva(struct IsdnCard *card)\r\n{\r\nint rc, have_card = 0;\r\nstruct IsdnCardState *cs = card->cs;\r\nchar tmp[64];\r\nstrcpy(tmp, Diva_revision);\r\nprintk(KERN_INFO "HiSax: Eicon.Diehl Diva driver Rev. %s\n", HiSax_getrev(tmp));\r\nif (cs->typ != ISDN_CTYPE_DIEHLDIVA)\r\nreturn (0);\r\ncs->hw.diva.status = 0;\r\nrc = setup_diva_isa(card);\r\nif (!rc)\r\nreturn rc;\r\nif (rc > 0) {\r\nhave_card = 1;\r\ngoto ready;\r\n}\r\nrc = setup_diva_isapnp(card);\r\nif (!rc)\r\nreturn rc;\r\nif (rc > 0) {\r\nhave_card = 1;\r\ngoto ready;\r\n}\r\nrc = setup_diva_pci(card);\r\nif (!rc)\r\nreturn rc;\r\nif (rc > 0)\r\nhave_card = 1;\r\nready:\r\nif (!have_card) {\r\nprintk(KERN_WARNING "Diva: No ISA, ISAPNP or PCI card found\n");\r\nreturn (0);\r\n}\r\nreturn setup_diva_common(card->cs);\r\n}
