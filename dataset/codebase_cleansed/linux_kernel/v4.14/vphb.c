static int cxl_dma_set_mask(struct pci_dev *pdev, u64 dma_mask)\r\n{\r\nif (dma_mask < DMA_BIT_MASK(64)) {\r\npr_info("%s only 64bit DMA supported on CXL", __func__);\r\nreturn -EIO;\r\n}\r\n*(pdev->dev.dma_mask) = dma_mask;\r\nreturn 0;\r\n}\r\nstatic int cxl_pci_probe_mode(struct pci_bus *bus)\r\n{\r\nreturn PCI_PROBE_NORMAL;\r\n}\r\nstatic int cxl_setup_msi_irqs(struct pci_dev *pdev, int nvec, int type)\r\n{\r\nreturn -ENODEV;\r\n}\r\nstatic void cxl_teardown_msi_irqs(struct pci_dev *pdev)\r\n{\r\n}\r\nstatic bool cxl_pci_enable_device_hook(struct pci_dev *dev)\r\n{\r\nstruct pci_controller *phb;\r\nstruct cxl_afu *afu;\r\nphb = pci_bus_to_host(dev->bus);\r\nafu = (struct cxl_afu *)phb->private_data;\r\nif (!cxl_ops->link_ok(afu->adapter, afu)) {\r\ndev_warn(&dev->dev, "%s: Device link is down, refusing to enable AFU\n", __func__);\r\nreturn false;\r\n}\r\nset_dma_ops(&dev->dev, &dma_direct_ops);\r\nset_dma_offset(&dev->dev, PAGE_OFFSET);\r\nreturn _cxl_pci_associate_default_context(dev, afu);\r\n}\r\nstatic resource_size_t cxl_pci_window_alignment(struct pci_bus *bus,\r\nunsigned long type)\r\n{\r\nreturn 1;\r\n}\r\nstatic void cxl_pci_reset_secondary_bus(struct pci_dev *dev)\r\n{\r\n}\r\nstatic int cxl_pcie_cfg_record(u8 bus, u8 devfn)\r\n{\r\nreturn (bus << 8) + devfn;\r\n}\r\nstatic inline struct cxl_afu *pci_bus_to_afu(struct pci_bus *bus)\r\n{\r\nstruct pci_controller *phb = bus ? pci_bus_to_host(bus) : NULL;\r\nreturn phb ? phb->private_data : NULL;\r\n}\r\nstatic void cxl_afu_configured_put(struct cxl_afu *afu)\r\n{\r\natomic_dec_if_positive(&afu->configured_state);\r\n}\r\nstatic bool cxl_afu_configured_get(struct cxl_afu *afu)\r\n{\r\nreturn atomic_inc_unless_negative(&afu->configured_state);\r\n}\r\nstatic inline int cxl_pcie_config_info(struct pci_bus *bus, unsigned int devfn,\r\nstruct cxl_afu *afu, int *_record)\r\n{\r\nint record;\r\nrecord = cxl_pcie_cfg_record(bus->number, devfn);\r\nif (record > afu->crs_num)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\n*_record = record;\r\nreturn 0;\r\n}\r\nstatic int cxl_pcie_read_config(struct pci_bus *bus, unsigned int devfn,\r\nint offset, int len, u32 *val)\r\n{\r\nint rc, record;\r\nstruct cxl_afu *afu;\r\nu8 val8;\r\nu16 val16;\r\nu32 val32;\r\nafu = pci_bus_to_afu(bus);\r\nif (afu == NULL || !cxl_afu_configured_get(afu))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nrc = cxl_pcie_config_info(bus, devfn, afu, &record);\r\nif (rc)\r\ngoto out;\r\nswitch (len) {\r\ncase 1:\r\nrc = cxl_ops->afu_cr_read8(afu, record, offset, &val8);\r\n*val = val8;\r\nbreak;\r\ncase 2:\r\nrc = cxl_ops->afu_cr_read16(afu, record, offset, &val16);\r\n*val = val16;\r\nbreak;\r\ncase 4:\r\nrc = cxl_ops->afu_cr_read32(afu, record, offset, &val32);\r\n*val = val32;\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\n}\r\nout:\r\ncxl_afu_configured_put(afu);\r\nreturn rc ? PCIBIOS_DEVICE_NOT_FOUND : PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int cxl_pcie_write_config(struct pci_bus *bus, unsigned int devfn,\r\nint offset, int len, u32 val)\r\n{\r\nint rc, record;\r\nstruct cxl_afu *afu;\r\nafu = pci_bus_to_afu(bus);\r\nif (afu == NULL || !cxl_afu_configured_get(afu))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nrc = cxl_pcie_config_info(bus, devfn, afu, &record);\r\nif (rc)\r\ngoto out;\r\nswitch (len) {\r\ncase 1:\r\nrc = cxl_ops->afu_cr_write8(afu, record, offset, val & 0xff);\r\nbreak;\r\ncase 2:\r\nrc = cxl_ops->afu_cr_write16(afu, record, offset, val & 0xffff);\r\nbreak;\r\ncase 4:\r\nrc = cxl_ops->afu_cr_write32(afu, record, offset, val);\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\n}\r\nout:\r\ncxl_afu_configured_put(afu);\r\nreturn rc ? PCIBIOS_SET_FAILED : PCIBIOS_SUCCESSFUL;\r\n}\r\nint cxl_pci_vphb_add(struct cxl_afu *afu)\r\n{\r\nstruct pci_controller *phb;\r\nstruct device_node *vphb_dn;\r\nstruct device *parent;\r\nif (!afu->crs_num)\r\nreturn 0;\r\nparent = afu->adapter->dev.parent;\r\nvphb_dn = parent->of_node;\r\nphb = pcibios_alloc_controller(vphb_dn);\r\nif (!phb)\r\nreturn -ENODEV;\r\nphb->parent = parent;\r\nphb->ops = &cxl_pcie_pci_ops;\r\nphb->cfg_addr = NULL;\r\nphb->cfg_data = NULL;\r\nphb->private_data = afu;\r\nphb->controller_ops = cxl_pci_controller_ops;\r\npcibios_scan_phb(phb);\r\nif (phb->bus == NULL)\r\nreturn -ENXIO;\r\npci_set_host_bridge_release(to_pci_host_bridge(phb->bus->bridge),\r\npcibios_free_controller_deferred,\r\n(void *) phb);\r\npcibios_claim_one_bus(phb->bus);\r\npci_bus_add_devices(phb->bus);\r\nafu->phb = phb;\r\nreturn 0;\r\n}\r\nvoid cxl_pci_vphb_remove(struct cxl_afu *afu)\r\n{\r\nstruct pci_controller *phb;\r\nif (!afu || !afu->phb)\r\nreturn;\r\nphb = afu->phb;\r\nafu->phb = NULL;\r\npci_remove_root_bus(phb->bus);\r\n}\r\nstatic bool _cxl_pci_is_vphb_device(struct pci_controller *phb)\r\n{\r\nreturn (phb->ops == &cxl_pcie_pci_ops);\r\n}\r\nbool cxl_pci_is_vphb_device(struct pci_dev *dev)\r\n{\r\nstruct pci_controller *phb;\r\nphb = pci_bus_to_host(dev->bus);\r\nreturn _cxl_pci_is_vphb_device(phb);\r\n}\r\nstruct cxl_afu *cxl_pci_to_afu(struct pci_dev *dev)\r\n{\r\nstruct pci_controller *phb;\r\nphb = pci_bus_to_host(dev->bus);\r\nif (_cxl_pci_is_vphb_device(phb))\r\nreturn (struct cxl_afu *)phb->private_data;\r\nif (pnv_pci_on_cxl_phb(dev))\r\nreturn pnv_cxl_phb_to_afu(phb);\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nunsigned int cxl_pci_to_cfg_record(struct pci_dev *dev)\r\n{\r\nreturn cxl_pcie_cfg_record(dev->bus->number, dev->devfn);\r\n}
