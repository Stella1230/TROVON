static int gen_pci_parse_request_of_pci_ranges(struct device *dev,\r\nstruct list_head *resources, struct resource **bus_range)\r\n{\r\nint err, res_valid = 0;\r\nstruct device_node *np = dev->of_node;\r\nresource_size_t iobase;\r\nstruct resource_entry *win, *tmp;\r\nerr = of_pci_get_host_bridge_resources(np, 0, 0xff, resources, &iobase);\r\nif (err)\r\nreturn err;\r\nerr = devm_request_pci_bus_resources(dev, resources);\r\nif (err)\r\nreturn err;\r\nresource_list_for_each_entry_safe(win, tmp, resources) {\r\nstruct resource *res = win->res;\r\nswitch (resource_type(res)) {\r\ncase IORESOURCE_IO:\r\nerr = pci_remap_iospace(res, iobase);\r\nif (err) {\r\ndev_warn(dev, "error %d: failed to map resource %pR\n",\r\nerr, res);\r\nresource_list_destroy_entry(win);\r\n}\r\nbreak;\r\ncase IORESOURCE_MEM:\r\nres_valid |= !(res->flags & IORESOURCE_PREFETCH);\r\nbreak;\r\ncase IORESOURCE_BUS:\r\n*bus_range = res;\r\nbreak;\r\n}\r\n}\r\nif (res_valid)\r\nreturn 0;\r\ndev_err(dev, "non-prefetchable memory resource required\n");\r\nreturn -EINVAL;\r\n}\r\nstatic void gen_pci_unmap_cfg(void *ptr)\r\n{\r\npci_ecam_free((struct pci_config_window *)ptr);\r\n}\r\nstatic struct pci_config_window *gen_pci_init(struct device *dev,\r\nstruct list_head *resources, struct pci_ecam_ops *ops)\r\n{\r\nint err;\r\nstruct resource cfgres;\r\nstruct resource *bus_range = NULL;\r\nstruct pci_config_window *cfg;\r\nerr = gen_pci_parse_request_of_pci_ranges(dev, resources, &bus_range);\r\nif (err)\r\ngoto err_out;\r\nerr = of_address_to_resource(dev->of_node, 0, &cfgres);\r\nif (err) {\r\ndev_err(dev, "missing \"reg\" property\n");\r\ngoto err_out;\r\n}\r\ncfg = pci_ecam_create(dev, &cfgres, bus_range, ops);\r\nif (IS_ERR(cfg)) {\r\nerr = PTR_ERR(cfg);\r\ngoto err_out;\r\n}\r\nerr = devm_add_action(dev, gen_pci_unmap_cfg, cfg);\r\nif (err) {\r\ngen_pci_unmap_cfg(cfg);\r\ngoto err_out;\r\n}\r\nreturn cfg;\r\nerr_out:\r\npci_free_resource_list(resources);\r\nreturn ERR_PTR(err);\r\n}\r\nint pci_host_common_probe(struct platform_device *pdev,\r\nstruct pci_ecam_ops *ops)\r\n{\r\nconst char *type;\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np = dev->of_node;\r\nstruct pci_bus *bus, *child;\r\nstruct pci_host_bridge *bridge;\r\nstruct pci_config_window *cfg;\r\nstruct list_head resources;\r\nint ret;\r\nbridge = devm_pci_alloc_host_bridge(dev, 0);\r\nif (!bridge)\r\nreturn -ENOMEM;\r\ntype = of_get_property(np, "device_type", NULL);\r\nif (!type || strcmp(type, "pci")) {\r\ndev_err(dev, "invalid \"device_type\" %s\n", type);\r\nreturn -EINVAL;\r\n}\r\nof_pci_check_probe_only();\r\nINIT_LIST_HEAD(&resources);\r\ncfg = gen_pci_init(dev, &resources, ops);\r\nif (IS_ERR(cfg))\r\nreturn PTR_ERR(cfg);\r\nif (!pci_has_flag(PCI_PROBE_ONLY))\r\npci_add_flags(PCI_REASSIGN_ALL_RSRC | PCI_REASSIGN_ALL_BUS);\r\nlist_splice_init(&resources, &bridge->windows);\r\nbridge->dev.parent = dev;\r\nbridge->sysdata = cfg;\r\nbridge->busnr = cfg->busr.start;\r\nbridge->ops = &ops->pci_ops;\r\nbridge->map_irq = of_irq_parse_and_map_pci;\r\nbridge->swizzle_irq = pci_common_swizzle;\r\nret = pci_scan_root_bus_bridge(bridge);\r\nif (ret < 0) {\r\ndev_err(dev, "Scanning root bridge failed");\r\nreturn ret;\r\n}\r\nbus = bridge->bus;\r\nif (pci_has_flag(PCI_PROBE_ONLY)) {\r\npci_bus_claim_resources(bus);\r\n} else {\r\npci_bus_size_bridges(bus);\r\npci_bus_assign_resources(bus);\r\nlist_for_each_entry(child, &bus->children, node)\r\npcie_bus_configure_settings(child);\r\n}\r\npci_bus_add_devices(bus);\r\nreturn 0;\r\n}
