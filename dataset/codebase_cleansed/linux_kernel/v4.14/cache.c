void\r\nflush_data_cache(void)\r\n{\r\non_each_cpu(flush_data_cache_local, NULL, 1);\r\n}\r\nvoid\r\nflush_instruction_cache(void)\r\n{\r\non_each_cpu(flush_instruction_cache_local, NULL, 1);\r\n}\r\nvoid\r\nflush_cache_all_local(void)\r\n{\r\nflush_instruction_cache_local(NULL);\r\nflush_data_cache_local(NULL);\r\n}\r\nvoid\r\nupdate_mmu_cache(struct vm_area_struct *vma, unsigned long address, pte_t *ptep)\r\n{\r\nunsigned long pfn = pte_pfn(*ptep);\r\nstruct page *page;\r\nif (!pfn_valid(pfn))\r\nreturn;\r\npage = pfn_to_page(pfn);\r\nif (page_mapping(page) && test_bit(PG_dcache_dirty, &page->flags)) {\r\nflush_kernel_dcache_page_addr(pfn_va(pfn));\r\nclear_bit(PG_dcache_dirty, &page->flags);\r\n} else if (parisc_requires_coherency())\r\nflush_kernel_dcache_page_addr(pfn_va(pfn));\r\n}\r\nvoid\r\nshow_cache_info(struct seq_file *m)\r\n{\r\nchar buf[32];\r\nseq_printf(m, "I-cache\t\t: %ld KB\n",\r\ncache_info.ic_size/1024 );\r\nif (cache_info.dc_loop != 1)\r\nsnprintf(buf, 32, "%lu-way associative", cache_info.dc_loop);\r\nseq_printf(m, "D-cache\t\t: %ld KB (%s%s, %s)\n",\r\ncache_info.dc_size/1024,\r\n(cache_info.dc_conf.cc_wt ? "WT":"WB"),\r\n(cache_info.dc_conf.cc_sh ? ", shared I/D":""),\r\n((cache_info.dc_loop == 1) ? "direct mapped" : buf));\r\nseq_printf(m, "ITLB entries\t: %ld\n" "DTLB entries\t: %ld%s\n",\r\ncache_info.it_size,\r\ncache_info.dt_size,\r\ncache_info.dt_conf.tc_sh ? " - shared with ITLB":""\r\n);\r\n#ifndef CONFIG_PA20\r\nif (btlb_info.max_size==0) {\r\nseq_printf(m, "BTLB\t\t: not supported\n" );\r\n} else {\r\nseq_printf(m,\r\n"BTLB fixed\t: max. %d pages, pagesize=%d (%dMB)\n"\r\n"BTLB fix-entr.\t: %d instruction, %d data (%d combined)\n"\r\n"BTLB var-entr.\t: %d instruction, %d data (%d combined)\n",\r\nbtlb_info.max_size, (int)4096,\r\nbtlb_info.max_size>>8,\r\nbtlb_info.fixed_range_info.num_i,\r\nbtlb_info.fixed_range_info.num_d,\r\nbtlb_info.fixed_range_info.num_comb,\r\nbtlb_info.variable_range_info.num_i,\r\nbtlb_info.variable_range_info.num_d,\r\nbtlb_info.variable_range_info.num_comb\r\n);\r\n}\r\n#endif\r\n}\r\nvoid __init\r\nparisc_cache_init(void)\r\n{\r\nif (pdc_cache_info(&cache_info) < 0)\r\npanic("parisc_cache_init: pdc_cache_info failed");\r\n#if 0\r\nprintk("ic_size %lx dc_size %lx it_size %lx\n",\r\ncache_info.ic_size,\r\ncache_info.dc_size,\r\ncache_info.it_size);\r\nprintk("DC base 0x%lx stride 0x%lx count 0x%lx loop 0x%lx\n",\r\ncache_info.dc_base,\r\ncache_info.dc_stride,\r\ncache_info.dc_count,\r\ncache_info.dc_loop);\r\nprintk("dc_conf = 0x%lx alias %d blk %d line %d shift %d\n",\r\n*(unsigned long *) (&cache_info.dc_conf),\r\ncache_info.dc_conf.cc_alias,\r\ncache_info.dc_conf.cc_block,\r\ncache_info.dc_conf.cc_line,\r\ncache_info.dc_conf.cc_shift);\r\nprintk(" wt %d sh %d cst %d hv %d\n",\r\ncache_info.dc_conf.cc_wt,\r\ncache_info.dc_conf.cc_sh,\r\ncache_info.dc_conf.cc_cst,\r\ncache_info.dc_conf.cc_hv);\r\nprintk("IC base 0x%lx stride 0x%lx count 0x%lx loop 0x%lx\n",\r\ncache_info.ic_base,\r\ncache_info.ic_stride,\r\ncache_info.ic_count,\r\ncache_info.ic_loop);\r\nprintk("IT base 0x%lx stride 0x%lx count 0x%lx loop 0x%lx off_base 0x%lx off_stride 0x%lx off_count 0x%lx\n",\r\ncache_info.it_sp_base,\r\ncache_info.it_sp_stride,\r\ncache_info.it_sp_count,\r\ncache_info.it_loop,\r\ncache_info.it_off_base,\r\ncache_info.it_off_stride,\r\ncache_info.it_off_count);\r\nprintk("DT base 0x%lx stride 0x%lx count 0x%lx loop 0x%lx off_base 0x%lx off_stride 0x%lx off_count 0x%lx\n",\r\ncache_info.dt_sp_base,\r\ncache_info.dt_sp_stride,\r\ncache_info.dt_sp_count,\r\ncache_info.dt_loop,\r\ncache_info.dt_off_base,\r\ncache_info.dt_off_stride,\r\ncache_info.dt_off_count);\r\nprintk("ic_conf = 0x%lx alias %d blk %d line %d shift %d\n",\r\n*(unsigned long *) (&cache_info.ic_conf),\r\ncache_info.ic_conf.cc_alias,\r\ncache_info.ic_conf.cc_block,\r\ncache_info.ic_conf.cc_line,\r\ncache_info.ic_conf.cc_shift);\r\nprintk(" wt %d sh %d cst %d hv %d\n",\r\ncache_info.ic_conf.cc_wt,\r\ncache_info.ic_conf.cc_sh,\r\ncache_info.ic_conf.cc_cst,\r\ncache_info.ic_conf.cc_hv);\r\nprintk("D-TLB conf: sh %d page %d cst %d aid %d sr %d\n",\r\ncache_info.dt_conf.tc_sh,\r\ncache_info.dt_conf.tc_page,\r\ncache_info.dt_conf.tc_cst,\r\ncache_info.dt_conf.tc_aid,\r\ncache_info.dt_conf.tc_sr);\r\nprintk("I-TLB conf: sh %d page %d cst %d aid %d sr %d\n",\r\ncache_info.it_conf.tc_sh,\r\ncache_info.it_conf.tc_page,\r\ncache_info.it_conf.tc_cst,\r\ncache_info.it_conf.tc_aid,\r\ncache_info.it_conf.tc_sr);\r\n#endif\r\nsplit_tlb = 0;\r\nif (cache_info.dt_conf.tc_sh == 0 || cache_info.dt_conf.tc_sh == 2) {\r\nif (cache_info.dt_conf.tc_sh == 2)\r\nprintk(KERN_WARNING "Unexpected TLB configuration. "\r\n"Will flush I/D separately (could be optimized).\n");\r\nsplit_tlb = 1;\r\n}\r\n#define CAFL_STRIDE(cnf) (cnf.cc_line << (3 + cnf.cc_block + cnf.cc_shift))\r\ndcache_stride = CAFL_STRIDE(cache_info.dc_conf);\r\nicache_stride = CAFL_STRIDE(cache_info.ic_conf);\r\n#undef CAFL_STRIDE\r\n#ifndef CONFIG_PA20\r\nif (pdc_btlb_info(&btlb_info) < 0) {\r\nmemset(&btlb_info, 0, sizeof btlb_info);\r\n}\r\n#endif\r\nif ((boot_cpu_data.pdc.capabilities & PDC_MODEL_NVA_MASK) ==\r\nPDC_MODEL_NVA_UNSUPPORTED) {\r\nprintk(KERN_WARNING "parisc_cache_init: Only equivalent aliasing supported!\n");\r\n#if 0\r\npanic("SMP kernel required to avoid non-equivalent aliasing");\r\n#endif\r\n}\r\n}\r\nvoid disable_sr_hashing(void)\r\n{\r\nint srhash_type, retval;\r\nunsigned long space_bits;\r\nswitch (boot_cpu_data.cpu_type) {\r\ncase pcx:\r\nBUG();\r\nreturn;\r\ncase pcxs:\r\ncase pcxt:\r\ncase pcxt_:\r\nsrhash_type = SRHASH_PCXST;\r\nbreak;\r\ncase pcxl:\r\nsrhash_type = SRHASH_PCXL;\r\nbreak;\r\ncase pcxl2:\r\nreturn;\r\ndefault:\r\nsrhash_type = SRHASH_PA20;\r\nbreak;\r\n}\r\ndisable_sr_hashing_asm(srhash_type);\r\nretval = pdc_spaceid_bits(&space_bits);\r\nif (retval < 0 && retval != PDC_BAD_OPTION)\r\npanic("pdc_spaceid_bits call failed.\n");\r\nif (space_bits != 0)\r\npanic("SpaceID hashing is still on!\n");\r\n}\r\nstatic inline void\r\n__flush_cache_page(struct vm_area_struct *vma, unsigned long vmaddr,\r\nunsigned long physaddr)\r\n{\r\npreempt_disable();\r\nflush_dcache_page_asm(physaddr, vmaddr);\r\nif (vma->vm_flags & VM_EXEC)\r\nflush_icache_page_asm(physaddr, vmaddr);\r\npreempt_enable();\r\n}\r\nvoid flush_dcache_page(struct page *page)\r\n{\r\nstruct address_space *mapping = page_mapping(page);\r\nstruct vm_area_struct *mpnt;\r\nunsigned long offset;\r\nunsigned long addr, old_addr = 0;\r\npgoff_t pgoff;\r\nif (mapping && !mapping_mapped(mapping)) {\r\nset_bit(PG_dcache_dirty, &page->flags);\r\nreturn;\r\n}\r\nflush_kernel_dcache_page(page);\r\nif (!mapping)\r\nreturn;\r\npgoff = page->index;\r\nflush_dcache_mmap_lock(mapping);\r\nvma_interval_tree_foreach(mpnt, &mapping->i_mmap, pgoff, pgoff) {\r\noffset = (pgoff - mpnt->vm_pgoff) << PAGE_SHIFT;\r\naddr = mpnt->vm_start + offset;\r\nflush_tlb_page(mpnt, addr);\r\nif (old_addr == 0 || (old_addr & (SHM_COLOUR - 1))\r\n!= (addr & (SHM_COLOUR - 1))) {\r\n__flush_cache_page(mpnt, addr, page_to_phys(page));\r\nif (old_addr)\r\nprintk(KERN_ERR "INEQUIVALENT ALIASES 0x%lx and 0x%lx in file %pD\n", old_addr, addr, mpnt->vm_file);\r\nold_addr = addr;\r\n}\r\n}\r\nflush_dcache_mmap_unlock(mapping);\r\n}\r\nvoid __init parisc_setup_cache_timing(void)\r\n{\r\nunsigned long rangetime, alltime;\r\nunsigned long size, start;\r\nunsigned long threshold;\r\nalltime = mfctl(16);\r\nflush_data_cache();\r\nalltime = mfctl(16) - alltime;\r\nsize = (unsigned long)(_end - _text);\r\nrangetime = mfctl(16);\r\nflush_kernel_dcache_range((unsigned long)_text, size);\r\nrangetime = mfctl(16) - rangetime;\r\nprintk(KERN_DEBUG "Whole cache flush %lu cycles, flushing %lu bytes %lu cycles\n",\r\nalltime, size, rangetime);\r\nthreshold = L1_CACHE_ALIGN(size * alltime / rangetime);\r\nif (threshold > cache_info.dc_size)\r\nthreshold = cache_info.dc_size;\r\nif (threshold)\r\nparisc_cache_flush_threshold = threshold;\r\nprintk(KERN_INFO "Cache flush threshold set to %lu KiB\n",\r\nparisc_cache_flush_threshold/1024);\r\nif (num_online_cpus() > 1 && !parisc_requires_coherency()) {\r\nthreshold = max(cache_info.it_size, cache_info.dt_size);\r\nthreshold *= PAGE_SIZE;\r\nthreshold /= num_online_cpus();\r\ngoto set_tlb_threshold;\r\n}\r\nalltime = mfctl(16);\r\nflush_tlb_all();\r\nalltime = mfctl(16) - alltime;\r\nsize = 0;\r\nstart = (unsigned long) _text;\r\nrangetime = mfctl(16);\r\nwhile (start < (unsigned long) _end) {\r\nflush_tlb_kernel_range(start, start + PAGE_SIZE);\r\nstart += PAGE_SIZE;\r\nsize += PAGE_SIZE;\r\n}\r\nrangetime = mfctl(16) - rangetime;\r\nprintk(KERN_DEBUG "Whole TLB flush %lu cycles, flushing %lu bytes %lu cycles\n",\r\nalltime, size, rangetime);\r\nthreshold = PAGE_ALIGN(num_online_cpus() * size * alltime / rangetime);\r\nset_tlb_threshold:\r\nif (threshold)\r\nparisc_tlb_flush_threshold = threshold;\r\nprintk(KERN_INFO "TLB flush threshold set to %lu KiB\n",\r\nparisc_tlb_flush_threshold/1024);\r\n}\r\nvoid flush_kernel_dcache_page_addr(void *addr)\r\n{\r\nunsigned long flags;\r\nflush_kernel_dcache_page_asm(addr);\r\npurge_tlb_start(flags);\r\npdtlb_kernel(addr);\r\npurge_tlb_end(flags);\r\n}\r\nvoid copy_user_page(void *vto, void *vfrom, unsigned long vaddr,\r\nstruct page *pg)\r\n{\r\npreempt_disable();\r\nflush_dcache_page_asm(__pa(vfrom), vaddr);\r\ncopy_page_asm(vto, vfrom);\r\npreempt_enable();\r\n}\r\nint __flush_tlb_range(unsigned long sid, unsigned long start,\r\nunsigned long end)\r\n{\r\nunsigned long flags, size;\r\nsize = (end - start);\r\nif (size >= parisc_tlb_flush_threshold) {\r\nflush_tlb_all();\r\nreturn 1;\r\n}\r\nif (likely(!split_tlb)) {\r\nwhile (start < end) {\r\npurge_tlb_start(flags);\r\nmtsp(sid, 1);\r\npdtlb(start);\r\npurge_tlb_end(flags);\r\nstart += PAGE_SIZE;\r\n}\r\nreturn 0;\r\n}\r\nwhile (start < end) {\r\npurge_tlb_start(flags);\r\nmtsp(sid, 1);\r\npdtlb(start);\r\npitlb(start);\r\npurge_tlb_end(flags);\r\nstart += PAGE_SIZE;\r\n}\r\nreturn 0;\r\n}\r\nstatic void cacheflush_h_tmp_function(void *dummy)\r\n{\r\nflush_cache_all_local();\r\n}\r\nvoid flush_cache_all(void)\r\n{\r\non_each_cpu(cacheflush_h_tmp_function, NULL, 1);\r\n}\r\nstatic inline unsigned long mm_total_size(struct mm_struct *mm)\r\n{\r\nstruct vm_area_struct *vma;\r\nunsigned long usize = 0;\r\nfor (vma = mm->mmap; vma; vma = vma->vm_next)\r\nusize += vma->vm_end - vma->vm_start;\r\nreturn usize;\r\n}\r\nstatic inline pte_t *get_ptep(pgd_t *pgd, unsigned long addr)\r\n{\r\npte_t *ptep = NULL;\r\nif (!pgd_none(*pgd)) {\r\npud_t *pud = pud_offset(pgd, addr);\r\nif (!pud_none(*pud)) {\r\npmd_t *pmd = pmd_offset(pud, addr);\r\nif (!pmd_none(*pmd))\r\nptep = pte_offset_map(pmd, addr);\r\n}\r\n}\r\nreturn ptep;\r\n}\r\nvoid flush_cache_mm(struct mm_struct *mm)\r\n{\r\nstruct vm_area_struct *vma;\r\npgd_t *pgd;\r\nif (parisc_requires_coherency())\r\nflush_tlb_all();\r\nif (mm_total_size(mm) >= parisc_cache_flush_threshold) {\r\nflush_cache_all();\r\nreturn;\r\n}\r\nif (mm->context == mfsp(3)) {\r\nfor (vma = mm->mmap; vma; vma = vma->vm_next) {\r\nflush_user_dcache_range_asm(vma->vm_start, vma->vm_end);\r\nif ((vma->vm_flags & VM_EXEC) == 0)\r\ncontinue;\r\nflush_user_icache_range_asm(vma->vm_start, vma->vm_end);\r\n}\r\nreturn;\r\n}\r\npgd = mm->pgd;\r\nfor (vma = mm->mmap; vma; vma = vma->vm_next) {\r\nunsigned long addr;\r\nfor (addr = vma->vm_start; addr < vma->vm_end;\r\naddr += PAGE_SIZE) {\r\nunsigned long pfn;\r\npte_t *ptep = get_ptep(pgd, addr);\r\nif (!ptep)\r\ncontinue;\r\npfn = pte_pfn(*ptep);\r\nif (!pfn_valid(pfn))\r\ncontinue;\r\n__flush_cache_page(vma, addr, PFN_PHYS(pfn));\r\n}\r\n}\r\n}\r\nvoid flush_cache_range(struct vm_area_struct *vma,\r\nunsigned long start, unsigned long end)\r\n{\r\nBUG_ON(!vma->vm_mm->context);\r\nif (parisc_requires_coherency())\r\nflush_tlb_range(vma, start, end);\r\nif ((end - start) >= parisc_cache_flush_threshold\r\n|| vma->vm_mm->context != mfsp(3)) {\r\nflush_cache_all();\r\nreturn;\r\n}\r\nflush_user_dcache_range_asm(start, end);\r\nif (vma->vm_flags & VM_EXEC)\r\nflush_user_icache_range_asm(start, end);\r\n}\r\nvoid\r\nflush_cache_page(struct vm_area_struct *vma, unsigned long vmaddr, unsigned long pfn)\r\n{\r\nBUG_ON(!vma->vm_mm->context);\r\nif (pfn_valid(pfn)) {\r\nif (parisc_requires_coherency())\r\nflush_tlb_page(vma, vmaddr);\r\n__flush_cache_page(vma, vmaddr, PFN_PHYS(pfn));\r\n}\r\n}\r\nvoid flush_kernel_vmap_range(void *vaddr, int size)\r\n{\r\nunsigned long start = (unsigned long)vaddr;\r\nif ((unsigned long)size > parisc_cache_flush_threshold)\r\nflush_data_cache();\r\nelse\r\nflush_kernel_dcache_range_asm(start, start + size);\r\n}\r\nvoid invalidate_kernel_vmap_range(void *vaddr, int size)\r\n{\r\nunsigned long start = (unsigned long)vaddr;\r\nif ((unsigned long)size > parisc_cache_flush_threshold)\r\nflush_data_cache();\r\nelse\r\nflush_kernel_dcache_range_asm(start, start + size);\r\n}
