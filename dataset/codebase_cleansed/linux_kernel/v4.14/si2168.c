static int si2168_cmd_execute(struct i2c_client *client, struct si2168_cmd *cmd)\r\n{\r\nstruct si2168_dev *dev = i2c_get_clientdata(client);\r\nint ret;\r\nunsigned long timeout;\r\nmutex_lock(&dev->i2c_mutex);\r\nif (cmd->wlen) {\r\nret = i2c_master_send(client, cmd->args, cmd->wlen);\r\nif (ret < 0) {\r\ngoto err_mutex_unlock;\r\n} else if (ret != cmd->wlen) {\r\nret = -EREMOTEIO;\r\ngoto err_mutex_unlock;\r\n}\r\n}\r\nif (cmd->rlen) {\r\n#define TIMEOUT 70\r\ntimeout = jiffies + msecs_to_jiffies(TIMEOUT);\r\nwhile (!time_after(jiffies, timeout)) {\r\nret = i2c_master_recv(client, cmd->args, cmd->rlen);\r\nif (ret < 0) {\r\ngoto err_mutex_unlock;\r\n} else if (ret != cmd->rlen) {\r\nret = -EREMOTEIO;\r\ngoto err_mutex_unlock;\r\n}\r\nif ((cmd->args[0] >> 7) & 0x01)\r\nbreak;\r\n}\r\ndev_dbg(&client->dev, "cmd execution took %d ms\n",\r\njiffies_to_msecs(jiffies) -\r\n(jiffies_to_msecs(timeout) - TIMEOUT));\r\nif ((cmd->args[0] >> 6) & 0x01) {\r\nret = -EREMOTEIO;\r\ngoto err_mutex_unlock;\r\n}\r\nif (!((cmd->args[0] >> 7) & 0x01)) {\r\nret = -ETIMEDOUT;\r\ngoto err_mutex_unlock;\r\n}\r\n}\r\nmutex_unlock(&dev->i2c_mutex);\r\nreturn 0;\r\nerr_mutex_unlock:\r\nmutex_unlock(&dev->i2c_mutex);\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int si2168_read_status(struct dvb_frontend *fe, enum fe_status *status)\r\n{\r\nstruct i2c_client *client = fe->demodulator_priv;\r\nstruct si2168_dev *dev = i2c_get_clientdata(client);\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret, i;\r\nunsigned int utmp, utmp1, utmp2;\r\nstruct si2168_cmd cmd;\r\n*status = 0;\r\nif (!dev->active) {\r\nret = -EAGAIN;\r\ngoto err;\r\n}\r\nswitch (c->delivery_system) {\r\ncase SYS_DVBT:\r\nmemcpy(cmd.args, "\xa0\x01", 2);\r\ncmd.wlen = 2;\r\ncmd.rlen = 13;\r\nbreak;\r\ncase SYS_DVBC_ANNEX_A:\r\nmemcpy(cmd.args, "\x90\x01", 2);\r\ncmd.wlen = 2;\r\ncmd.rlen = 9;\r\nbreak;\r\ncase SYS_DVBT2:\r\nmemcpy(cmd.args, "\x50\x01", 2);\r\ncmd.wlen = 2;\r\ncmd.rlen = 14;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nret = si2168_cmd_execute(client, &cmd);\r\nif (ret)\r\ngoto err;\r\nswitch ((cmd.args[2] >> 1) & 0x03) {\r\ncase 0x01:\r\n*status = FE_HAS_SIGNAL | FE_HAS_CARRIER;\r\nbreak;\r\ncase 0x03:\r\n*status = FE_HAS_SIGNAL | FE_HAS_CARRIER | FE_HAS_VITERBI |\r\nFE_HAS_SYNC | FE_HAS_LOCK;\r\nbreak;\r\n}\r\ndev->fe_status = *status;\r\nif (*status & FE_HAS_LOCK) {\r\nc->cnr.len = 1;\r\nc->cnr.stat[0].scale = FE_SCALE_DECIBEL;\r\nc->cnr.stat[0].svalue = cmd.args[3] * 1000 / 4;\r\n} else {\r\nc->cnr.len = 1;\r\nc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\n}\r\ndev_dbg(&client->dev, "status=%02x args=%*ph\n",\r\n*status, cmd.rlen, cmd.args);\r\nif (*status & FE_HAS_VITERBI) {\r\nmemcpy(cmd.args, "\x82\x00", 2);\r\ncmd.wlen = 2;\r\ncmd.rlen = 3;\r\nret = si2168_cmd_execute(client, &cmd);\r\nif (ret)\r\ngoto err;\r\nutmp = clamp(8 - cmd.args[1], 0, 8);\r\nfor (i = 0, utmp1 = 1; i < utmp; i++)\r\nutmp1 = utmp1 * 10;\r\nutmp1 = cmd.args[2] * utmp1;\r\nutmp2 = 100000000;\r\ndev_dbg(&client->dev,\r\n"post_bit_error=%u post_bit_count=%u ber=%u*10^-%u\n",\r\nutmp1, utmp2, cmd.args[2], cmd.args[1]);\r\nc->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;\r\nc->post_bit_error.stat[0].uvalue += utmp1;\r\nc->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;\r\nc->post_bit_count.stat[0].uvalue += utmp2;\r\n} else {\r\nc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\n}\r\nif (*status & FE_HAS_SYNC) {\r\nmemcpy(cmd.args, "\x84\x01", 2);\r\ncmd.wlen = 2;\r\ncmd.rlen = 3;\r\nret = si2168_cmd_execute(client, &cmd);\r\nif (ret)\r\ngoto err;\r\nutmp1 = cmd.args[2] << 8 | cmd.args[1] << 0;\r\ndev_dbg(&client->dev, "block_error=%u\n", utmp1);\r\nif (utmp1 == 0xffff)\r\nutmp1 = 0;\r\nc->block_error.stat[0].scale = FE_SCALE_COUNTER;\r\nc->block_error.stat[0].uvalue += utmp1;\r\n} else {\r\nc->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int si2168_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct i2c_client *client = fe->demodulator_priv;\r\nstruct si2168_dev *dev = i2c_get_clientdata(client);\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret;\r\nstruct si2168_cmd cmd;\r\nu8 bandwidth, delivery_system;\r\ndev_dbg(&client->dev,\r\n"delivery_system=%u modulation=%u frequency=%u bandwidth_hz=%u symbol_rate=%u inversion=%u stream_id=%u\n",\r\nc->delivery_system, c->modulation, c->frequency,\r\nc->bandwidth_hz, c->symbol_rate, c->inversion,\r\nc->stream_id);\r\nif (!dev->active) {\r\nret = -EAGAIN;\r\ngoto err;\r\n}\r\nswitch (c->delivery_system) {\r\ncase SYS_DVBT:\r\ndelivery_system = 0x20;\r\nbreak;\r\ncase SYS_DVBC_ANNEX_A:\r\ndelivery_system = 0x30;\r\nbreak;\r\ncase SYS_DVBT2:\r\ndelivery_system = 0x70;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nif (c->bandwidth_hz == 0) {\r\nret = -EINVAL;\r\ngoto err;\r\n} else if (c->bandwidth_hz <= 2000000)\r\nbandwidth = 0x02;\r\nelse if (c->bandwidth_hz <= 5000000)\r\nbandwidth = 0x05;\r\nelse if (c->bandwidth_hz <= 6000000)\r\nbandwidth = 0x06;\r\nelse if (c->bandwidth_hz <= 7000000)\r\nbandwidth = 0x07;\r\nelse if (c->bandwidth_hz <= 8000000)\r\nbandwidth = 0x08;\r\nelse if (c->bandwidth_hz <= 9000000)\r\nbandwidth = 0x09;\r\nelse if (c->bandwidth_hz <= 10000000)\r\nbandwidth = 0x0a;\r\nelse\r\nbandwidth = 0x0f;\r\nif (fe->ops.tuner_ops.set_params) {\r\nret = fe->ops.tuner_ops.set_params(fe);\r\nif (ret)\r\ngoto err;\r\n}\r\nmemcpy(cmd.args, "\x88\x02\x02\x02\x02", 5);\r\ncmd.wlen = 5;\r\ncmd.rlen = 5;\r\nret = si2168_cmd_execute(client, &cmd);\r\nif (ret)\r\ngoto err;\r\nif (c->delivery_system == SYS_DVBT)\r\nmemcpy(cmd.args, "\x89\x21\x06\x11\xff\x98", 6);\r\nelse if (c->delivery_system == SYS_DVBC_ANNEX_A)\r\nmemcpy(cmd.args, "\x89\x21\x06\x11\x89\xf0", 6);\r\nelse if (c->delivery_system == SYS_DVBT2)\r\nmemcpy(cmd.args, "\x89\x21\x06\x11\x89\x20", 6);\r\ncmd.wlen = 6;\r\ncmd.rlen = 3;\r\nret = si2168_cmd_execute(client, &cmd);\r\nif (ret)\r\ngoto err;\r\nif (c->delivery_system == SYS_DVBT2) {\r\ncmd.args[0] = 0x52;\r\ncmd.args[1] = c->stream_id & 0xff;\r\ncmd.args[2] = c->stream_id == NO_STREAM_ID_FILTER ? 0 : 1;\r\ncmd.wlen = 3;\r\ncmd.rlen = 1;\r\nret = si2168_cmd_execute(client, &cmd);\r\nif (ret)\r\ngoto err;\r\n}\r\nmemcpy(cmd.args, "\x51\x03", 2);\r\ncmd.wlen = 2;\r\ncmd.rlen = 12;\r\nret = si2168_cmd_execute(client, &cmd);\r\nif (ret)\r\ngoto err;\r\nmemcpy(cmd.args, "\x12\x08\x04", 3);\r\ncmd.wlen = 3;\r\ncmd.rlen = 3;\r\nret = si2168_cmd_execute(client, &cmd);\r\nif (ret)\r\ngoto err;\r\nmemcpy(cmd.args, "\x14\x00\x0c\x10\x12\x00", 6);\r\ncmd.wlen = 6;\r\ncmd.rlen = 4;\r\nret = si2168_cmd_execute(client, &cmd);\r\nif (ret)\r\ngoto err;\r\nmemcpy(cmd.args, "\x14\x00\x06\x10\x24\x00", 6);\r\ncmd.wlen = 6;\r\ncmd.rlen = 4;\r\nret = si2168_cmd_execute(client, &cmd);\r\nif (ret)\r\ngoto err;\r\nmemcpy(cmd.args, "\x14\x00\x07\x10\x00\x24", 6);\r\ncmd.wlen = 6;\r\ncmd.rlen = 4;\r\nret = si2168_cmd_execute(client, &cmd);\r\nif (ret)\r\ngoto err;\r\nmemcpy(cmd.args, "\x14\x00\x0a\x10\x00\x00", 6);\r\ncmd.args[4] = delivery_system | bandwidth;\r\ncmd.wlen = 6;\r\ncmd.rlen = 4;\r\nret = si2168_cmd_execute(client, &cmd);\r\nif (ret)\r\ngoto err;\r\nif (c->delivery_system == SYS_DVBC_ANNEX_A) {\r\nmemcpy(cmd.args, "\x14\x00\x02\x11", 4);\r\ncmd.args[4] = ((c->symbol_rate / 1000) >> 0) & 0xff;\r\ncmd.args[5] = ((c->symbol_rate / 1000) >> 8) & 0xff;\r\ncmd.wlen = 6;\r\ncmd.rlen = 4;\r\nret = si2168_cmd_execute(client, &cmd);\r\nif (ret)\r\ngoto err;\r\n}\r\nmemcpy(cmd.args, "\x14\x00\x0f\x10\x10\x00", 6);\r\ncmd.wlen = 6;\r\ncmd.rlen = 4;\r\nret = si2168_cmd_execute(client, &cmd);\r\nif (ret)\r\ngoto err;\r\nmemcpy(cmd.args, "\x14\x00\x09\x10\xe3\x08", 6);\r\ncmd.args[5] |= dev->ts_clock_inv ? 0x00 : 0x10;\r\ncmd.wlen = 6;\r\ncmd.rlen = 4;\r\nret = si2168_cmd_execute(client, &cmd);\r\nif (ret)\r\ngoto err;\r\nmemcpy(cmd.args, "\x14\x00\x08\x10\xd7\x05", 6);\r\ncmd.args[5] |= dev->ts_clock_inv ? 0x00 : 0x10;\r\ncmd.wlen = 6;\r\ncmd.rlen = 4;\r\nret = si2168_cmd_execute(client, &cmd);\r\nif (ret)\r\ngoto err;\r\nmemcpy(cmd.args, "\x14\x00\x01\x12\x00\x00", 6);\r\ncmd.wlen = 6;\r\ncmd.rlen = 4;\r\nret = si2168_cmd_execute(client, &cmd);\r\nif (ret)\r\ngoto err;\r\nmemcpy(cmd.args, "\x14\x00\x01\x03\x0c\x00", 6);\r\ncmd.wlen = 6;\r\ncmd.rlen = 4;\r\nret = si2168_cmd_execute(client, &cmd);\r\nif (ret)\r\ngoto err;\r\nmemcpy(cmd.args, "\x85", 1);\r\ncmd.wlen = 1;\r\ncmd.rlen = 1;\r\nret = si2168_cmd_execute(client, &cmd);\r\nif (ret)\r\ngoto err;\r\ndev->delivery_system = c->delivery_system;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int si2168_init(struct dvb_frontend *fe)\r\n{\r\nstruct i2c_client *client = fe->demodulator_priv;\r\nstruct si2168_dev *dev = i2c_get_clientdata(client);\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret, len, remaining;\r\nconst struct firmware *fw;\r\nstruct si2168_cmd cmd;\r\ndev_dbg(&client->dev, "\n");\r\nmemcpy(cmd.args, "\xc0\x12\x00\x0c\x00\x0d\x16\x00\x00\x00\x00\x00\x00", 13);\r\ncmd.wlen = 13;\r\ncmd.rlen = 0;\r\nret = si2168_cmd_execute(client, &cmd);\r\nif (ret)\r\ngoto err;\r\nif (dev->warm) {\r\nmemcpy(cmd.args, "\xc0\x06\x08\x0f\x00\x20\x21\x01", 8);\r\ncmd.wlen = 8;\r\ncmd.rlen = 1;\r\nret = si2168_cmd_execute(client, &cmd);\r\nif (ret)\r\ngoto err;\r\nmemcpy(cmd.args, "\x85", 1);\r\ncmd.wlen = 1;\r\ncmd.rlen = 1;\r\nret = si2168_cmd_execute(client, &cmd);\r\nif (ret)\r\ngoto err;\r\ngoto warm;\r\n}\r\nmemcpy(cmd.args, "\xc0\x06\x01\x0f\x00\x20\x20\x01", 8);\r\ncmd.wlen = 8;\r\ncmd.rlen = 1;\r\nret = si2168_cmd_execute(client, &cmd);\r\nif (ret)\r\ngoto err;\r\nret = request_firmware(&fw, dev->firmware_name, &client->dev);\r\nif (ret) {\r\nif (dev->chip_id == SI2168_CHIP_ID_B40) {\r\ndev->firmware_name = SI2168_B40_FIRMWARE_FALLBACK;\r\nret = request_firmware(&fw, dev->firmware_name,\r\n&client->dev);\r\n}\r\nif (ret == 0) {\r\ndev_notice(&client->dev,\r\n"please install firmware file '%s'\n",\r\nSI2168_B40_FIRMWARE);\r\n} else {\r\ndev_err(&client->dev,\r\n"firmware file '%s' not found\n",\r\ndev->firmware_name);\r\ngoto err_release_firmware;\r\n}\r\n}\r\ndev_info(&client->dev, "downloading firmware from file '%s'\n",\r\ndev->firmware_name);\r\nif ((fw->size % 17 == 0) && (fw->data[0] > 5)) {\r\nfor (remaining = fw->size; remaining > 0; remaining -= 17) {\r\nlen = fw->data[fw->size - remaining];\r\nif (len > SI2168_ARGLEN) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nmemcpy(cmd.args, &fw->data[(fw->size - remaining) + 1], len);\r\ncmd.wlen = len;\r\ncmd.rlen = 1;\r\nret = si2168_cmd_execute(client, &cmd);\r\nif (ret)\r\nbreak;\r\n}\r\n} else if (fw->size % 8 == 0) {\r\nfor (remaining = fw->size; remaining > 0; remaining -= 8) {\r\nlen = 8;\r\nmemcpy(cmd.args, &fw->data[fw->size - remaining], len);\r\ncmd.wlen = len;\r\ncmd.rlen = 1;\r\nret = si2168_cmd_execute(client, &cmd);\r\nif (ret)\r\nbreak;\r\n}\r\n} else {\r\nret = -EINVAL;\r\n}\r\nif (ret) {\r\ndev_err(&client->dev, "firmware download failed %d\n", ret);\r\ngoto err_release_firmware;\r\n}\r\nrelease_firmware(fw);\r\nmemcpy(cmd.args, "\x01\x01", 2);\r\ncmd.wlen = 2;\r\ncmd.rlen = 1;\r\nret = si2168_cmd_execute(client, &cmd);\r\nif (ret)\r\ngoto err;\r\nmemcpy(cmd.args, "\x11", 1);\r\ncmd.wlen = 1;\r\ncmd.rlen = 10;\r\nret = si2168_cmd_execute(client, &cmd);\r\nif (ret)\r\ngoto err;\r\ndev->version = (cmd.args[9] + '@') << 24 | (cmd.args[6] - '0') << 16 |\r\n(cmd.args[7] - '0') << 8 | (cmd.args[8]) << 0;\r\ndev_info(&client->dev, "firmware version: %c %d.%d.%d\n",\r\ndev->version >> 24 & 0xff, dev->version >> 16 & 0xff,\r\ndev->version >> 8 & 0xff, dev->version >> 0 & 0xff);\r\nmemcpy(cmd.args, "\x14\x00\x01\x10\x10\x00", 6);\r\ncmd.args[4] |= dev->ts_mode;\r\nif (dev->ts_clock_gapped)\r\ncmd.args[4] |= 0x40;\r\ncmd.wlen = 6;\r\ncmd.rlen = 4;\r\nret = si2168_cmd_execute(client, &cmd);\r\nif (ret)\r\ngoto err;\r\ndev->warm = true;\r\nwarm:\r\nc->cnr.len = 1;\r\nc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->post_bit_error.len = 1;\r\nc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->post_bit_count.len = 1;\r\nc->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->block_error.len = 1;\r\nc->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\ndev->active = true;\r\nreturn 0;\r\nerr_release_firmware:\r\nrelease_firmware(fw);\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int si2168_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct i2c_client *client = fe->demodulator_priv;\r\nstruct si2168_dev *dev = i2c_get_clientdata(client);\r\nint ret;\r\nstruct si2168_cmd cmd;\r\ndev_dbg(&client->dev, "\n");\r\ndev->active = false;\r\nif (dev->version > ('B' << 24 | 4 << 16 | 0 << 8 | 11 << 0))\r\ndev->warm = false;\r\nmemcpy(cmd.args, "\x13", 1);\r\ncmd.wlen = 1;\r\ncmd.rlen = 0;\r\nret = si2168_cmd_execute(client, &cmd);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int si2168_get_tune_settings(struct dvb_frontend *fe,\r\nstruct dvb_frontend_tune_settings *s)\r\n{\r\ns->min_delay_ms = 900;\r\nreturn 0;\r\n}\r\nstatic int si2168_select(struct i2c_mux_core *muxc, u32 chan)\r\n{\r\nstruct i2c_client *client = i2c_mux_priv(muxc);\r\nint ret;\r\nstruct si2168_cmd cmd;\r\nmemcpy(cmd.args, "\xc0\x0d\x01", 3);\r\ncmd.wlen = 3;\r\ncmd.rlen = 0;\r\nret = si2168_cmd_execute(client, &cmd);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int si2168_deselect(struct i2c_mux_core *muxc, u32 chan)\r\n{\r\nstruct i2c_client *client = i2c_mux_priv(muxc);\r\nint ret;\r\nstruct si2168_cmd cmd;\r\nmemcpy(cmd.args, "\xc0\x0d\x00", 3);\r\ncmd.wlen = 3;\r\ncmd.rlen = 0;\r\nret = si2168_cmd_execute(client, &cmd);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int si2168_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct si2168_config *config = client->dev.platform_data;\r\nstruct si2168_dev *dev;\r\nint ret;\r\nstruct si2168_cmd cmd;\r\ndev_dbg(&client->dev, "\n");\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev) {\r\nret = -ENOMEM;\r\ndev_err(&client->dev, "kzalloc() failed\n");\r\ngoto err;\r\n}\r\ni2c_set_clientdata(client, dev);\r\nmutex_init(&dev->i2c_mutex);\r\nmemcpy(cmd.args, "\xc0\x12\x00\x0c\x00\x0d\x16\x00\x00\x00\x00\x00\x00", 13);\r\ncmd.wlen = 13;\r\ncmd.rlen = 0;\r\nret = si2168_cmd_execute(client, &cmd);\r\nif (ret)\r\ngoto err_kfree;\r\nmemcpy(cmd.args, "\xc0\x06\x01\x0f\x00\x20\x20\x01", 8);\r\ncmd.wlen = 8;\r\ncmd.rlen = 1;\r\nret = si2168_cmd_execute(client, &cmd);\r\nif (ret)\r\ngoto err_kfree;\r\nmemcpy(cmd.args, "\x02", 1);\r\ncmd.wlen = 1;\r\ncmd.rlen = 13;\r\nret = si2168_cmd_execute(client, &cmd);\r\nif (ret)\r\ngoto err_kfree;\r\ndev->chip_id = cmd.args[1] << 24 | cmd.args[2] << 16 |\r\ncmd.args[3] << 8 | cmd.args[4] << 0;\r\nswitch (dev->chip_id) {\r\ncase SI2168_CHIP_ID_A20:\r\ndev->firmware_name = SI2168_A20_FIRMWARE;\r\nbreak;\r\ncase SI2168_CHIP_ID_A30:\r\ndev->firmware_name = SI2168_A30_FIRMWARE;\r\nbreak;\r\ncase SI2168_CHIP_ID_B40:\r\ndev->firmware_name = SI2168_B40_FIRMWARE;\r\nbreak;\r\ncase SI2168_CHIP_ID_D60:\r\ndev->firmware_name = SI2168_D60_FIRMWARE;\r\nbreak;\r\ndefault:\r\ndev_dbg(&client->dev, "unknown chip version Si21%d-%c%c%c\n",\r\ncmd.args[2], cmd.args[1], cmd.args[3], cmd.args[4]);\r\nret = -ENODEV;\r\ngoto err_kfree;\r\n}\r\ndev->version = (cmd.args[1]) << 24 | (cmd.args[3] - '0') << 16 |\r\n(cmd.args[4] - '0') << 8 | (cmd.args[5]) << 0;\r\ndev->muxc = i2c_mux_alloc(client->adapter, &client->dev,\r\n1, 0, I2C_MUX_LOCKED,\r\nsi2168_select, si2168_deselect);\r\nif (!dev->muxc) {\r\nret = -ENOMEM;\r\ngoto err_kfree;\r\n}\r\ndev->muxc->priv = client;\r\nret = i2c_mux_add_adapter(dev->muxc, 0, 0, 0);\r\nif (ret)\r\ngoto err_kfree;\r\nmemcpy(&dev->fe.ops, &si2168_ops, sizeof(struct dvb_frontend_ops));\r\ndev->fe.demodulator_priv = client;\r\n*config->i2c_adapter = dev->muxc->adapter[0];\r\n*config->fe = &dev->fe;\r\ndev->ts_mode = config->ts_mode;\r\ndev->ts_clock_inv = config->ts_clock_inv;\r\ndev->ts_clock_gapped = config->ts_clock_gapped;\r\ndev_info(&client->dev, "Silicon Labs Si2168-%c%d%d successfully identified\n",\r\ndev->version >> 24 & 0xff, dev->version >> 16 & 0xff,\r\ndev->version >> 8 & 0xff);\r\ndev_info(&client->dev, "firmware version: %c %d.%d.%d\n",\r\ndev->version >> 24 & 0xff, dev->version >> 16 & 0xff,\r\ndev->version >> 8 & 0xff, dev->version >> 0 & 0xff);\r\nreturn 0;\r\nerr_kfree:\r\nkfree(dev);\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int si2168_remove(struct i2c_client *client)\r\n{\r\nstruct si2168_dev *dev = i2c_get_clientdata(client);\r\ndev_dbg(&client->dev, "\n");\r\ni2c_mux_del_adapters(dev->muxc);\r\ndev->fe.ops.release = NULL;\r\ndev->fe.demodulator_priv = NULL;\r\nkfree(dev);\r\nreturn 0;\r\n}
