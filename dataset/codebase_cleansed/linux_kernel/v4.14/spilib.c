static struct spi_master *get_master_from_spi(struct gb_spilib *spi)\r\n{\r\nreturn gb_connection_get_data(spi->connection);\r\n}\r\nstatic int tx_header_fit_operation(u32 tx_size, u32 count, size_t data_max)\r\n{\r\nsize_t headers_size;\r\ndata_max -= sizeof(struct gb_spi_transfer_request);\r\nheaders_size = (count + 1) * sizeof(struct gb_spi_transfer);\r\nreturn tx_size + headers_size > data_max ? 0 : 1;\r\n}\r\nstatic size_t calc_rx_xfer_size(u32 rx_size, u32 *tx_xfer_size, u32 len,\r\nsize_t data_max)\r\n{\r\nsize_t rx_xfer_size;\r\ndata_max -= sizeof(struct gb_spi_transfer_response);\r\nif (rx_size + len > data_max)\r\nrx_xfer_size = data_max - rx_size;\r\nelse\r\nrx_xfer_size = len;\r\nif (*tx_xfer_size && rx_xfer_size > *tx_xfer_size)\r\nrx_xfer_size = *tx_xfer_size;\r\nif (*tx_xfer_size && rx_xfer_size < *tx_xfer_size)\r\n*tx_xfer_size = rx_xfer_size;\r\nreturn rx_xfer_size;\r\n}\r\nstatic size_t calc_tx_xfer_size(u32 tx_size, u32 count, size_t len,\r\nsize_t data_max)\r\n{\r\nsize_t headers_size;\r\ndata_max -= sizeof(struct gb_spi_transfer_request);\r\nheaders_size = (count + 1) * sizeof(struct gb_spi_transfer);\r\nif (tx_size + headers_size + len > data_max)\r\nreturn data_max - (tx_size + sizeof(struct gb_spi_transfer));\r\nreturn len;\r\n}\r\nstatic void clean_xfer_state(struct gb_spilib *spi)\r\n{\r\nspi->first_xfer = NULL;\r\nspi->last_xfer = NULL;\r\nspi->rx_xfer_offset = 0;\r\nspi->tx_xfer_offset = 0;\r\nspi->last_xfer_size = 0;\r\nspi->op_timeout = 0;\r\n}\r\nstatic bool is_last_xfer_done(struct gb_spilib *spi)\r\n{\r\nstruct spi_transfer *last_xfer = spi->last_xfer;\r\nif ((spi->tx_xfer_offset + spi->last_xfer_size == last_xfer->len) ||\r\n(spi->rx_xfer_offset + spi->last_xfer_size == last_xfer->len))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int setup_next_xfer(struct gb_spilib *spi, struct spi_message *msg)\r\n{\r\nstruct spi_transfer *last_xfer = spi->last_xfer;\r\nif (msg->state != GB_SPI_STATE_OP_DONE)\r\nreturn 0;\r\nif (is_last_xfer_done(spi)) {\r\nspi->tx_xfer_offset = 0;\r\nspi->rx_xfer_offset = 0;\r\nspi->op_timeout = 0;\r\nif (last_xfer == list_last_entry(&msg->transfers,\r\nstruct spi_transfer,\r\ntransfer_list))\r\nmsg->state = GB_SPI_STATE_MSG_DONE;\r\nelse\r\nspi->first_xfer = list_next_entry(last_xfer,\r\ntransfer_list);\r\nreturn 0;\r\n}\r\nspi->first_xfer = last_xfer;\r\nif (last_xfer->tx_buf)\r\nspi->tx_xfer_offset += spi->last_xfer_size;\r\nif (last_xfer->rx_buf)\r\nspi->rx_xfer_offset += spi->last_xfer_size;\r\nreturn 0;\r\n}\r\nstatic struct spi_transfer *get_next_xfer(struct spi_transfer *xfer,\r\nstruct spi_message *msg)\r\n{\r\nif (xfer == list_last_entry(&msg->transfers, struct spi_transfer,\r\ntransfer_list))\r\nreturn NULL;\r\nreturn list_next_entry(xfer, transfer_list);\r\n}\r\nstatic struct gb_operation *gb_spi_operation_create(struct gb_spilib *spi,\r\nstruct gb_connection *connection, struct spi_message *msg)\r\n{\r\nstruct gb_spi_transfer_request *request;\r\nstruct spi_device *dev = msg->spi;\r\nstruct spi_transfer *xfer;\r\nstruct gb_spi_transfer *gb_xfer;\r\nstruct gb_operation *operation;\r\nu32 tx_size = 0, rx_size = 0, count = 0, xfer_len = 0, request_size;\r\nu32 tx_xfer_size = 0, rx_xfer_size = 0, len;\r\nu32 total_len = 0;\r\nunsigned int xfer_timeout;\r\nsize_t data_max;\r\nvoid *tx_data;\r\ndata_max = gb_operation_get_payload_size_max(connection);\r\nxfer = spi->first_xfer;\r\nwhile (msg->state != GB_SPI_STATE_OP_READY) {\r\nmsg->state = GB_SPI_STATE_MSG_RUNNING;\r\nspi->last_xfer = xfer;\r\nif (!xfer->tx_buf && !xfer->rx_buf) {\r\ndev_err(spi->parent,\r\n"bufferless transfer, length %u\n", xfer->len);\r\nmsg->state = GB_SPI_STATE_MSG_ERROR;\r\nreturn NULL;\r\n}\r\ntx_xfer_size = 0;\r\nrx_xfer_size = 0;\r\nif (xfer->tx_buf) {\r\nlen = xfer->len - spi->tx_xfer_offset;\r\nif (!tx_header_fit_operation(tx_size, count, data_max))\r\nbreak;\r\ntx_xfer_size = calc_tx_xfer_size(tx_size, count,\r\nlen, data_max);\r\nspi->last_xfer_size = tx_xfer_size;\r\n}\r\nif (xfer->rx_buf) {\r\nlen = xfer->len - spi->rx_xfer_offset;\r\nrx_xfer_size = calc_rx_xfer_size(rx_size, &tx_xfer_size,\r\nlen, data_max);\r\nspi->last_xfer_size = rx_xfer_size;\r\n}\r\ntx_size += tx_xfer_size;\r\nrx_size += rx_xfer_size;\r\ntotal_len += spi->last_xfer_size;\r\ncount++;\r\nxfer = get_next_xfer(xfer, msg);\r\nif (!xfer || total_len >= data_max)\r\nmsg->state = GB_SPI_STATE_OP_READY;\r\n}\r\nrequest_size = sizeof(*request);\r\nrequest_size += count * sizeof(*gb_xfer);\r\nrequest_size += tx_size;\r\noperation = gb_operation_create(connection, GB_SPI_TYPE_TRANSFER,\r\nrequest_size, rx_size, GFP_KERNEL);\r\nif (!operation)\r\nreturn NULL;\r\nrequest = operation->request->payload;\r\nrequest->count = cpu_to_le16(count);\r\nrequest->mode = dev->mode;\r\nrequest->chip_select = dev->chip_select;\r\ngb_xfer = &request->transfers[0];\r\ntx_data = gb_xfer + count;\r\nxfer = spi->first_xfer;\r\nwhile (msg->state != GB_SPI_STATE_OP_DONE) {\r\nif (xfer == spi->last_xfer)\r\nxfer_len = spi->last_xfer_size;\r\nelse\r\nxfer_len = xfer->len;\r\nxfer_timeout = xfer_len * 8 * MSEC_PER_SEC / xfer->speed_hz;\r\nxfer_timeout += GB_OPERATION_TIMEOUT_DEFAULT;\r\nif (xfer_timeout > spi->op_timeout)\r\nspi->op_timeout = xfer_timeout;\r\ngb_xfer->speed_hz = cpu_to_le32(xfer->speed_hz);\r\ngb_xfer->len = cpu_to_le32(xfer_len);\r\ngb_xfer->delay_usecs = cpu_to_le16(xfer->delay_usecs);\r\ngb_xfer->cs_change = xfer->cs_change;\r\ngb_xfer->bits_per_word = xfer->bits_per_word;\r\nif (xfer->tx_buf) {\r\ngb_xfer->xfer_flags |= GB_SPI_XFER_WRITE;\r\nmemcpy(tx_data, xfer->tx_buf + spi->tx_xfer_offset,\r\nxfer_len);\r\ntx_data += xfer_len;\r\n}\r\nif (xfer->rx_buf)\r\ngb_xfer->xfer_flags |= GB_SPI_XFER_READ;\r\nif (xfer == spi->last_xfer) {\r\nif (!is_last_xfer_done(spi))\r\ngb_xfer->xfer_flags |= GB_SPI_XFER_INPROGRESS;\r\nmsg->state = GB_SPI_STATE_OP_DONE;\r\ncontinue;\r\n}\r\ngb_xfer++;\r\nxfer = get_next_xfer(xfer, msg);\r\n}\r\nmsg->actual_length += total_len;\r\nreturn operation;\r\n}\r\nstatic void gb_spi_decode_response(struct gb_spilib *spi,\r\nstruct spi_message *msg,\r\nstruct gb_spi_transfer_response *response)\r\n{\r\nstruct spi_transfer *xfer = spi->first_xfer;\r\nvoid *rx_data = response->data;\r\nu32 xfer_len;\r\nwhile (xfer) {\r\nif (xfer->rx_buf) {\r\nif (xfer == spi->first_xfer)\r\nxfer_len = xfer->len - spi->rx_xfer_offset;\r\nelse if (xfer == spi->last_xfer)\r\nxfer_len = spi->last_xfer_size;\r\nelse\r\nxfer_len = xfer->len;\r\nmemcpy(xfer->rx_buf + spi->rx_xfer_offset, rx_data,\r\nxfer_len);\r\nrx_data += xfer_len;\r\n}\r\nif (xfer == spi->last_xfer)\r\nbreak;\r\nxfer = list_next_entry(xfer, transfer_list);\r\n}\r\n}\r\nstatic int gb_spi_transfer_one_message(struct spi_master *master,\r\nstruct spi_message *msg)\r\n{\r\nstruct gb_spilib *spi = spi_master_get_devdata(master);\r\nstruct gb_connection *connection = spi->connection;\r\nstruct gb_spi_transfer_response *response;\r\nstruct gb_operation *operation;\r\nint ret = 0;\r\nspi->first_xfer = list_first_entry_or_null(&msg->transfers,\r\nstruct spi_transfer,\r\ntransfer_list);\r\nif (!spi->first_xfer) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nmsg->state = GB_SPI_STATE_MSG_IDLE;\r\nwhile (msg->state != GB_SPI_STATE_MSG_DONE &&\r\nmsg->state != GB_SPI_STATE_MSG_ERROR) {\r\noperation = gb_spi_operation_create(spi, connection, msg);\r\nif (!operation) {\r\nmsg->state = GB_SPI_STATE_MSG_ERROR;\r\nret = -EINVAL;\r\ncontinue;\r\n}\r\nret = gb_operation_request_send_sync_timeout(operation,\r\nspi->op_timeout);\r\nif (!ret) {\r\nresponse = operation->response->payload;\r\nif (response)\r\ngb_spi_decode_response(spi, msg, response);\r\n} else {\r\ndev_err(spi->parent,\r\n"transfer operation failed: %d\n", ret);\r\nmsg->state = GB_SPI_STATE_MSG_ERROR;\r\n}\r\ngb_operation_put(operation);\r\nsetup_next_xfer(spi, msg);\r\n}\r\nout:\r\nmsg->status = ret;\r\nclean_xfer_state(spi);\r\nspi_finalize_current_message(master);\r\nreturn ret;\r\n}\r\nstatic int gb_spi_prepare_transfer_hardware(struct spi_master *master)\r\n{\r\nstruct gb_spilib *spi = spi_master_get_devdata(master);\r\nreturn spi->ops->prepare_transfer_hardware(spi->parent);\r\n}\r\nstatic int gb_spi_unprepare_transfer_hardware(struct spi_master *master)\r\n{\r\nstruct gb_spilib *spi = spi_master_get_devdata(master);\r\nspi->ops->unprepare_transfer_hardware(spi->parent);\r\nreturn 0;\r\n}\r\nstatic int gb_spi_setup(struct spi_device *spi)\r\n{\r\nreturn 0;\r\n}\r\nstatic void gb_spi_cleanup(struct spi_device *spi)\r\n{\r\n}\r\nstatic int gb_spi_get_master_config(struct gb_spilib *spi)\r\n{\r\nstruct gb_spi_master_config_response response;\r\nu16 mode, flags;\r\nint ret;\r\nret = gb_operation_sync(spi->connection, GB_SPI_TYPE_MASTER_CONFIG,\r\nNULL, 0, &response, sizeof(response));\r\nif (ret < 0)\r\nreturn ret;\r\nmode = le16_to_cpu(response.mode);\r\nspi->mode = gb_spi_mode_map(mode);\r\nflags = le16_to_cpu(response.flags);\r\nspi->flags = gb_spi_flags_map(flags);\r\nspi->bits_per_word_mask = le32_to_cpu(response.bits_per_word_mask);\r\nspi->num_chipselect = response.num_chipselect;\r\nspi->min_speed_hz = le32_to_cpu(response.min_speed_hz);\r\nspi->max_speed_hz = le32_to_cpu(response.max_speed_hz);\r\nreturn 0;\r\n}\r\nstatic int gb_spi_setup_device(struct gb_spilib *spi, u8 cs)\r\n{\r\nstruct spi_master *master = get_master_from_spi(spi);\r\nstruct gb_spi_device_config_request request;\r\nstruct gb_spi_device_config_response response;\r\nstruct spi_board_info spi_board = { {0} };\r\nstruct spi_device *spidev;\r\nint ret;\r\nu8 dev_type;\r\nrequest.chip_select = cs;\r\nret = gb_operation_sync(spi->connection, GB_SPI_TYPE_DEVICE_CONFIG,\r\n&request, sizeof(request),\r\n&response, sizeof(response));\r\nif (ret < 0)\r\nreturn ret;\r\ndev_type = response.device_type;\r\nif (dev_type == GB_SPI_SPI_DEV)\r\nstrlcpy(spi_board.modalias, "spidev",\r\nsizeof(spi_board.modalias));\r\nelse if (dev_type == GB_SPI_SPI_NOR)\r\nstrlcpy(spi_board.modalias, "spi-nor",\r\nsizeof(spi_board.modalias));\r\nelse if (dev_type == GB_SPI_SPI_MODALIAS)\r\nmemcpy(spi_board.modalias, response.name,\r\nsizeof(spi_board.modalias));\r\nelse\r\nreturn -EINVAL;\r\nspi_board.mode = le16_to_cpu(response.mode);\r\nspi_board.bus_num = master->bus_num;\r\nspi_board.chip_select = cs;\r\nspi_board.max_speed_hz = le32_to_cpu(response.max_speed_hz);\r\nspidev = spi_new_device(master, &spi_board);\r\nif (!spidev)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nint gb_spilib_master_init(struct gb_connection *connection, struct device *dev,\r\nstruct spilib_ops *ops)\r\n{\r\nstruct gb_spilib *spi;\r\nstruct spi_master *master;\r\nint ret;\r\nu8 i;\r\nmaster = spi_alloc_master(dev, sizeof(*spi));\r\nif (!master) {\r\ndev_err(dev, "cannot alloc SPI master\n");\r\nreturn -ENOMEM;\r\n}\r\nspi = spi_master_get_devdata(master);\r\nspi->connection = connection;\r\ngb_connection_set_data(connection, master);\r\nspi->parent = dev;\r\nspi->ops = ops;\r\nret = gb_spi_get_master_config(spi);\r\nif (ret)\r\ngoto exit_spi_put;\r\nmaster->bus_num = -1;\r\nmaster->num_chipselect = spi->num_chipselect;\r\nmaster->mode_bits = spi->mode;\r\nmaster->flags = spi->flags;\r\nmaster->bits_per_word_mask = spi->bits_per_word_mask;\r\nmaster->cleanup = gb_spi_cleanup;\r\nmaster->setup = gb_spi_setup;\r\nmaster->transfer_one_message = gb_spi_transfer_one_message;\r\nif (ops && ops->prepare_transfer_hardware) {\r\nmaster->prepare_transfer_hardware =\r\ngb_spi_prepare_transfer_hardware;\r\n}\r\nif (ops && ops->unprepare_transfer_hardware) {\r\nmaster->unprepare_transfer_hardware =\r\ngb_spi_unprepare_transfer_hardware;\r\n}\r\nmaster->auto_runtime_pm = true;\r\nret = spi_register_master(master);\r\nif (ret < 0)\r\ngoto exit_spi_put;\r\nfor (i = 0; i < spi->num_chipselect; i++) {\r\nret = gb_spi_setup_device(spi, i);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to allocate spi device %d: %d\n",\r\ni, ret);\r\ngoto exit_spi_unregister;\r\n}\r\n}\r\nreturn 0;\r\nexit_spi_unregister:\r\nspi_unregister_master(master);\r\nexit_spi_put:\r\nspi_master_put(master);\r\nreturn ret;\r\n}\r\nvoid gb_spilib_master_exit(struct gb_connection *connection)\r\n{\r\nstruct spi_master *master = gb_connection_get_data(connection);\r\nspi_unregister_master(master);\r\nspi_master_put(master);\r\n}
