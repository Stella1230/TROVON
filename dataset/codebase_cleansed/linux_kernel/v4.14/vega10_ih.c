static void vega10_ih_enable_interrupts(struct amdgpu_device *adev)\r\n{\r\nu32 ih_rb_cntl = RREG32(SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_CNTL));\r\nih_rb_cntl = REG_SET_FIELD(ih_rb_cntl, IH_RB_CNTL, RB_ENABLE, 1);\r\nih_rb_cntl = REG_SET_FIELD(ih_rb_cntl, IH_RB_CNTL, ENABLE_INTR, 1);\r\nWREG32(SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_CNTL), ih_rb_cntl);\r\nadev->irq.ih.enabled = true;\r\n}\r\nstatic void vega10_ih_disable_interrupts(struct amdgpu_device *adev)\r\n{\r\nu32 ih_rb_cntl = RREG32(SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_CNTL));\r\nih_rb_cntl = REG_SET_FIELD(ih_rb_cntl, IH_RB_CNTL, RB_ENABLE, 0);\r\nih_rb_cntl = REG_SET_FIELD(ih_rb_cntl, IH_RB_CNTL, ENABLE_INTR, 0);\r\nWREG32(SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_CNTL), ih_rb_cntl);\r\nWREG32(SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_RPTR), 0);\r\nWREG32(SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_WPTR), 0);\r\nadev->irq.ih.enabled = false;\r\nadev->irq.ih.rptr = 0;\r\n}\r\nstatic int vega10_ih_irq_init(struct amdgpu_device *adev)\r\n{\r\nint ret = 0;\r\nint rb_bufsz;\r\nu32 ih_rb_cntl, ih_doorbell_rtpr;\r\nu32 tmp;\r\nu64 wptr_off;\r\nvega10_ih_disable_interrupts(adev);\r\nif (adev->flags & AMD_IS_APU)\r\nnbio_v7_0_ih_control(adev);\r\nelse\r\nnbio_v6_1_ih_control(adev);\r\nih_rb_cntl = RREG32(SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_CNTL));\r\nif (adev->irq.ih.use_bus_addr) {\r\nWREG32(SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_BASE), adev->irq.ih.rb_dma_addr >> 8);\r\nWREG32(SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_BASE_HI), ((u64)adev->irq.ih.rb_dma_addr >> 40) & 0xff);\r\nih_rb_cntl = REG_SET_FIELD(ih_rb_cntl, IH_RB_CNTL, MC_SPACE, 1);\r\n} else {\r\nWREG32(SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_BASE), adev->irq.ih.gpu_addr >> 8);\r\nWREG32(SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_BASE_HI), (adev->irq.ih.gpu_addr >> 40) & 0xff);\r\nih_rb_cntl = REG_SET_FIELD(ih_rb_cntl, IH_RB_CNTL, MC_SPACE, 4);\r\n}\r\nrb_bufsz = order_base_2(adev->irq.ih.ring_size / 4);\r\nih_rb_cntl = REG_SET_FIELD(ih_rb_cntl, IH_RB_CNTL, WPTR_OVERFLOW_CLEAR, 1);\r\nih_rb_cntl = REG_SET_FIELD(ih_rb_cntl, IH_RB_CNTL, WPTR_OVERFLOW_ENABLE, 1);\r\nih_rb_cntl = REG_SET_FIELD(ih_rb_cntl, IH_RB_CNTL, RB_SIZE, rb_bufsz);\r\nih_rb_cntl = REG_SET_FIELD(ih_rb_cntl, IH_RB_CNTL, WPTR_WRITEBACK_ENABLE, 1);\r\nih_rb_cntl = REG_SET_FIELD(ih_rb_cntl, IH_RB_CNTL, MC_SNOOP, 1);\r\nih_rb_cntl = REG_SET_FIELD(ih_rb_cntl, IH_RB_CNTL, MC_RO, 0);\r\nih_rb_cntl = REG_SET_FIELD(ih_rb_cntl, IH_RB_CNTL, MC_VMID, 0);\r\nif (adev->irq.msi_enabled)\r\nih_rb_cntl = REG_SET_FIELD(ih_rb_cntl, IH_RB_CNTL, RPTR_REARM, 1);\r\nWREG32(SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_CNTL), ih_rb_cntl);\r\nif (adev->irq.ih.use_bus_addr)\r\nwptr_off = adev->irq.ih.rb_dma_addr + (adev->irq.ih.wptr_offs * 4);\r\nelse\r\nwptr_off = adev->wb.gpu_addr + (adev->irq.ih.wptr_offs * 4);\r\nWREG32(SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_WPTR_ADDR_LO), lower_32_bits(wptr_off));\r\nWREG32(SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_WPTR_ADDR_HI), upper_32_bits(wptr_off) & 0xFF);\r\nWREG32(SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_RPTR), 0);\r\nWREG32(SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_WPTR), 0);\r\nih_doorbell_rtpr = RREG32(SOC15_REG_OFFSET(OSSSYS, 0, mmIH_DOORBELL_RPTR));\r\nif (adev->irq.ih.use_doorbell) {\r\nih_doorbell_rtpr = REG_SET_FIELD(ih_doorbell_rtpr, IH_DOORBELL_RPTR,\r\nOFFSET, adev->irq.ih.doorbell_index);\r\nih_doorbell_rtpr = REG_SET_FIELD(ih_doorbell_rtpr, IH_DOORBELL_RPTR,\r\nENABLE, 1);\r\n} else {\r\nih_doorbell_rtpr = REG_SET_FIELD(ih_doorbell_rtpr, IH_DOORBELL_RPTR,\r\nENABLE, 0);\r\n}\r\nWREG32(SOC15_REG_OFFSET(OSSSYS, 0, mmIH_DOORBELL_RPTR), ih_doorbell_rtpr);\r\nif (adev->flags & AMD_IS_APU)\r\nnbio_v7_0_ih_doorbell_range(adev, adev->irq.ih.use_doorbell, adev->irq.ih.doorbell_index);\r\nelse\r\nnbio_v6_1_ih_doorbell_range(adev, adev->irq.ih.use_doorbell, adev->irq.ih.doorbell_index);\r\ntmp = RREG32(SOC15_REG_OFFSET(OSSSYS, 0, mmIH_STORM_CLIENT_LIST_CNTL));\r\ntmp = REG_SET_FIELD(tmp, IH_STORM_CLIENT_LIST_CNTL,\r\nCLIENT18_IS_STORM_CLIENT, 1);\r\nWREG32(SOC15_REG_OFFSET(OSSSYS, 0, mmIH_STORM_CLIENT_LIST_CNTL), tmp);\r\ntmp = RREG32(SOC15_REG_OFFSET(OSSSYS, 0, mmIH_INT_FLOOD_CNTL));\r\ntmp = REG_SET_FIELD(tmp, IH_INT_FLOOD_CNTL, FLOOD_CNTL_ENABLE, 1);\r\nWREG32(SOC15_REG_OFFSET(OSSSYS, 0, mmIH_INT_FLOOD_CNTL), tmp);\r\npci_set_master(adev->pdev);\r\nvega10_ih_enable_interrupts(adev);\r\nreturn ret;\r\n}\r\nstatic void vega10_ih_irq_disable(struct amdgpu_device *adev)\r\n{\r\nvega10_ih_disable_interrupts(adev);\r\nmdelay(1);\r\n}\r\nstatic u32 vega10_ih_get_wptr(struct amdgpu_device *adev)\r\n{\r\nu32 wptr, tmp;\r\nif (adev->irq.ih.use_bus_addr)\r\nwptr = le32_to_cpu(adev->irq.ih.ring[adev->irq.ih.wptr_offs]);\r\nelse\r\nwptr = le32_to_cpu(adev->wb.wb[adev->irq.ih.wptr_offs]);\r\nif (REG_GET_FIELD(wptr, IH_RB_WPTR, RB_OVERFLOW)) {\r\nwptr = REG_SET_FIELD(wptr, IH_RB_WPTR, RB_OVERFLOW, 0);\r\ntmp = (wptr + 32) & adev->irq.ih.ptr_mask;\r\ndev_warn(adev->dev, "IH ring buffer overflow (0x%08X, 0x%08X, 0x%08X)\n",\r\nwptr, adev->irq.ih.rptr, tmp);\r\nadev->irq.ih.rptr = tmp;\r\ntmp = RREG32(SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_CNTL));\r\ntmp = REG_SET_FIELD(tmp, IH_RB_CNTL, WPTR_OVERFLOW_CLEAR, 1);\r\nWREG32(SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_CNTL), tmp);\r\n}\r\nreturn (wptr & adev->irq.ih.ptr_mask);\r\n}\r\nstatic void vega10_ih_decode_iv(struct amdgpu_device *adev,\r\nstruct amdgpu_iv_entry *entry)\r\n{\r\nu32 ring_index = adev->irq.ih.rptr >> 2;\r\nuint32_t dw[8];\r\ndw[0] = le32_to_cpu(adev->irq.ih.ring[ring_index + 0]);\r\ndw[1] = le32_to_cpu(adev->irq.ih.ring[ring_index + 1]);\r\ndw[2] = le32_to_cpu(adev->irq.ih.ring[ring_index + 2]);\r\ndw[3] = le32_to_cpu(adev->irq.ih.ring[ring_index + 3]);\r\ndw[4] = le32_to_cpu(adev->irq.ih.ring[ring_index + 4]);\r\ndw[5] = le32_to_cpu(adev->irq.ih.ring[ring_index + 5]);\r\ndw[6] = le32_to_cpu(adev->irq.ih.ring[ring_index + 6]);\r\ndw[7] = le32_to_cpu(adev->irq.ih.ring[ring_index + 7]);\r\nentry->client_id = dw[0] & 0xff;\r\nentry->src_id = (dw[0] >> 8) & 0xff;\r\nentry->ring_id = (dw[0] >> 16) & 0xff;\r\nentry->vm_id = (dw[0] >> 24) & 0xf;\r\nentry->vm_id_src = (dw[0] >> 31);\r\nentry->timestamp = dw[1] | ((u64)(dw[2] & 0xffff) << 32);\r\nentry->timestamp_src = dw[2] >> 31;\r\nentry->pas_id = dw[3] & 0xffff;\r\nentry->pasid_src = dw[3] >> 31;\r\nentry->src_data[0] = dw[4];\r\nentry->src_data[1] = dw[5];\r\nentry->src_data[2] = dw[6];\r\nentry->src_data[3] = dw[7];\r\nadev->irq.ih.rptr += 32;\r\n}\r\nstatic void vega10_ih_set_rptr(struct amdgpu_device *adev)\r\n{\r\nif (adev->irq.ih.use_doorbell) {\r\nif (adev->irq.ih.use_bus_addr)\r\nadev->irq.ih.ring[adev->irq.ih.rptr_offs] = adev->irq.ih.rptr;\r\nelse\r\nadev->wb.wb[adev->irq.ih.rptr_offs] = adev->irq.ih.rptr;\r\nWDOORBELL32(adev->irq.ih.doorbell_index, adev->irq.ih.rptr);\r\n} else {\r\nWREG32(SOC15_REG_OFFSET(OSSSYS, 0, mmIH_RB_RPTR), adev->irq.ih.rptr);\r\n}\r\n}\r\nstatic int vega10_ih_early_init(void *handle)\r\n{\r\nstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\r\nvega10_ih_set_interrupt_funcs(adev);\r\nreturn 0;\r\n}\r\nstatic int vega10_ih_sw_init(void *handle)\r\n{\r\nint r;\r\nstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\r\nr = amdgpu_ih_ring_init(adev, 256 * 1024, true);\r\nif (r)\r\nreturn r;\r\nadev->irq.ih.use_doorbell = true;\r\nadev->irq.ih.doorbell_index = AMDGPU_DOORBELL64_IH << 1;\r\nr = amdgpu_irq_init(adev);\r\nreturn r;\r\n}\r\nstatic int vega10_ih_sw_fini(void *handle)\r\n{\r\nstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\r\namdgpu_irq_fini(adev);\r\namdgpu_ih_ring_fini(adev);\r\nreturn 0;\r\n}\r\nstatic int vega10_ih_hw_init(void *handle)\r\n{\r\nint r;\r\nstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\r\nr = vega10_ih_irq_init(adev);\r\nif (r)\r\nreturn r;\r\nreturn 0;\r\n}\r\nstatic int vega10_ih_hw_fini(void *handle)\r\n{\r\nstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\r\nvega10_ih_irq_disable(adev);\r\nreturn 0;\r\n}\r\nstatic int vega10_ih_suspend(void *handle)\r\n{\r\nstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\r\nreturn vega10_ih_hw_fini(adev);\r\n}\r\nstatic int vega10_ih_resume(void *handle)\r\n{\r\nstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\r\nreturn vega10_ih_hw_init(adev);\r\n}\r\nstatic bool vega10_ih_is_idle(void *handle)\r\n{\r\nreturn true;\r\n}\r\nstatic int vega10_ih_wait_for_idle(void *handle)\r\n{\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int vega10_ih_soft_reset(void *handle)\r\n{\r\nreturn 0;\r\n}\r\nstatic int vega10_ih_set_clockgating_state(void *handle,\r\nenum amd_clockgating_state state)\r\n{\r\nreturn 0;\r\n}\r\nstatic int vega10_ih_set_powergating_state(void *handle,\r\nenum amd_powergating_state state)\r\n{\r\nreturn 0;\r\n}\r\nstatic void vega10_ih_set_interrupt_funcs(struct amdgpu_device *adev)\r\n{\r\nif (adev->irq.ih_funcs == NULL)\r\nadev->irq.ih_funcs = &vega10_ih_funcs;\r\n}
