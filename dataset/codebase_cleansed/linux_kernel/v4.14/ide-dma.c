ide_startstop_t ide_dma_intr(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nstruct ide_cmd *cmd = &hwif->cmd;\r\nu8 stat = 0, dma_stat = 0;\r\ndrive->waiting_for_dma = 0;\r\ndma_stat = hwif->dma_ops->dma_end(drive);\r\nide_dma_unmap_sg(drive, cmd);\r\nstat = hwif->tp_ops->read_status(hwif);\r\nif (OK_STAT(stat, DRIVE_READY, drive->bad_wstat | ATA_DRQ)) {\r\nif (!dma_stat) {\r\nif ((cmd->tf_flags & IDE_TFLAG_FS) == 0)\r\nide_finish_cmd(drive, cmd, stat);\r\nelse\r\nide_complete_rq(drive, BLK_STS_OK,\r\nblk_rq_sectors(cmd->rq) << 9);\r\nreturn ide_stopped;\r\n}\r\nprintk(KERN_ERR "%s: %s: bad DMA status (0x%02x)\n",\r\ndrive->name, __func__, dma_stat);\r\n}\r\nreturn ide_error(drive, "dma_intr", stat);\r\n}\r\nint ide_dma_good_drive(ide_drive_t *drive)\r\n{\r\nreturn ide_in_drive_list(drive->id, drive_whitelist);\r\n}\r\nstatic int ide_dma_map_sg(ide_drive_t *drive, struct ide_cmd *cmd)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nstruct scatterlist *sg = hwif->sg_table;\r\nint i;\r\nif (cmd->tf_flags & IDE_TFLAG_WRITE)\r\ncmd->sg_dma_direction = DMA_TO_DEVICE;\r\nelse\r\ncmd->sg_dma_direction = DMA_FROM_DEVICE;\r\ni = dma_map_sg(hwif->dev, sg, cmd->sg_nents, cmd->sg_dma_direction);\r\nif (i) {\r\ncmd->orig_sg_nents = cmd->sg_nents;\r\ncmd->sg_nents = i;\r\n}\r\nreturn i;\r\n}\r\nvoid ide_dma_unmap_sg(ide_drive_t *drive, struct ide_cmd *cmd)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\ndma_unmap_sg(hwif->dev, hwif->sg_table, cmd->orig_sg_nents,\r\ncmd->sg_dma_direction);\r\n}\r\nvoid ide_dma_off_quietly(ide_drive_t *drive)\r\n{\r\ndrive->dev_flags &= ~IDE_DFLAG_USING_DMA;\r\nide_toggle_bounce(drive, 0);\r\ndrive->hwif->dma_ops->dma_host_set(drive, 0);\r\n}\r\nvoid ide_dma_off(ide_drive_t *drive)\r\n{\r\nprintk(KERN_INFO "%s: DMA disabled\n", drive->name);\r\nide_dma_off_quietly(drive);\r\n}\r\nvoid ide_dma_on(ide_drive_t *drive)\r\n{\r\ndrive->dev_flags |= IDE_DFLAG_USING_DMA;\r\nide_toggle_bounce(drive, 1);\r\ndrive->hwif->dma_ops->dma_host_set(drive, 1);\r\n}\r\nint __ide_dma_bad_drive(ide_drive_t *drive)\r\n{\r\nu16 *id = drive->id;\r\nint blacklist = ide_in_drive_list(id, drive_blacklist);\r\nif (blacklist) {\r\nprintk(KERN_WARNING "%s: Disabling (U)DMA for %s (blacklisted)\n",\r\ndrive->name, (char *)&id[ATA_ID_PROD]);\r\nreturn blacklist;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int ide_get_mode_mask(ide_drive_t *drive, u8 base, u8 req_mode)\r\n{\r\nu16 *id = drive->id;\r\nide_hwif_t *hwif = drive->hwif;\r\nconst struct ide_port_ops *port_ops = hwif->port_ops;\r\nunsigned int mask = 0;\r\nswitch (base) {\r\ncase XFER_UDMA_0:\r\nif ((id[ATA_ID_FIELD_VALID] & 4) == 0)\r\nbreak;\r\nmask = id[ATA_ID_UDMA_MODES];\r\nif (port_ops && port_ops->udma_filter)\r\nmask &= port_ops->udma_filter(drive);\r\nelse\r\nmask &= hwif->ultra_mask;\r\nif (req_mode > XFER_UDMA_2) {\r\nif ((mask & 0x78) && (eighty_ninty_three(drive) == 0))\r\nmask &= 0x07;\r\n}\r\nbreak;\r\ncase XFER_MW_DMA_0:\r\nmask = id[ATA_ID_MWDMA_MODES];\r\nif (ata_id_is_cfa(id) && (id[ATA_ID_CFA_MODES] & 0x38)) {\r\nu8 mode = ((id[ATA_ID_CFA_MODES] & 0x38) >> 3) - 1;\r\nmask |= ((2 << mode) - 1) << 3;\r\n}\r\nif (port_ops && port_ops->mdma_filter)\r\nmask &= port_ops->mdma_filter(drive);\r\nelse\r\nmask &= hwif->mwdma_mask;\r\nbreak;\r\ncase XFER_SW_DMA_0:\r\nmask = id[ATA_ID_SWDMA_MODES];\r\nif (!(mask & ATA_SWDMA2) && (id[ATA_ID_OLD_DMA_MODES] >> 8)) {\r\nu8 mode = id[ATA_ID_OLD_DMA_MODES] >> 8;\r\nif (mode <= 2)\r\nmask = (2 << mode) - 1;\r\n}\r\nmask &= hwif->swdma_mask;\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\nreturn mask;\r\n}\r\nu8 ide_find_dma_mode(ide_drive_t *drive, u8 req_mode)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nunsigned int mask;\r\nint x, i;\r\nu8 mode = 0;\r\nif (drive->media != ide_disk) {\r\nif (hwif->host_flags & IDE_HFLAG_NO_ATAPI_DMA)\r\nreturn 0;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(xfer_mode_bases); i++) {\r\nif (req_mode < xfer_mode_bases[i])\r\ncontinue;\r\nmask = ide_get_mode_mask(drive, xfer_mode_bases[i], req_mode);\r\nx = fls(mask) - 1;\r\nif (x >= 0) {\r\nmode = xfer_mode_bases[i] + x;\r\nbreak;\r\n}\r\n}\r\nif (hwif->chipset == ide_acorn && mode == 0) {\r\nif (ide_dma_good_drive(drive) &&\r\ndrive->id[ATA_ID_EIDE_DMA_TIME] < 150)\r\nmode = XFER_MW_DMA_1;\r\n}\r\nmode = min(mode, req_mode);\r\nprintk(KERN_INFO "%s: %s mode selected\n", drive->name,\r\nmode ? ide_xfer_verbose(mode) : "no DMA");\r\nreturn mode;\r\n}\r\nstatic int ide_tune_dma(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nu8 speed;\r\nif (ata_id_has_dma(drive->id) == 0 ||\r\n(drive->dev_flags & IDE_DFLAG_NODMA))\r\nreturn 0;\r\nif (__ide_dma_bad_drive(drive))\r\nreturn 0;\r\nif (hwif->host_flags & IDE_HFLAG_TRUST_BIOS_FOR_DMA)\r\nreturn config_drive_for_dma(drive);\r\nspeed = ide_max_dma_mode(drive);\r\nif (!speed)\r\nreturn 0;\r\nif (ide_set_dma_mode(drive, speed))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int ide_dma_check(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nif (ide_tune_dma(drive))\r\nreturn 0;\r\nif (hwif->host_flags & IDE_HFLAG_TRUST_BIOS_FOR_DMA)\r\nreturn -1;\r\nide_set_max_pio(drive);\r\nreturn -1;\r\n}\r\nint ide_set_dma(ide_drive_t *drive)\r\n{\r\nint rc;\r\nide_dma_off_quietly(drive);\r\nrc = ide_dma_check(drive);\r\nif (rc)\r\nreturn rc;\r\nide_dma_on(drive);\r\nreturn 0;\r\n}\r\nvoid ide_check_dma_crc(ide_drive_t *drive)\r\n{\r\nu8 mode;\r\nide_dma_off_quietly(drive);\r\ndrive->crc_count = 0;\r\nmode = drive->current_speed;\r\nif (mode > XFER_UDMA_0 && mode <= XFER_UDMA_7)\r\nmode--;\r\nelse\r\nmode = XFER_PIO_4;\r\nide_set_xfer_rate(drive, mode);\r\nif (drive->current_speed >= XFER_SW_DMA_0)\r\nide_dma_on(drive);\r\n}\r\nvoid ide_dma_lost_irq(ide_drive_t *drive)\r\n{\r\nprintk(KERN_ERR "%s: DMA interrupt recovery\n", drive->name);\r\n}\r\nide_startstop_t ide_dma_timeout_retry(ide_drive_t *drive, int error)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nconst struct ide_dma_ops *dma_ops = hwif->dma_ops;\r\nstruct ide_cmd *cmd = &hwif->cmd;\r\nide_startstop_t ret = ide_stopped;\r\nif (error < 0) {\r\nprintk(KERN_WARNING "%s: DMA timeout error\n", drive->name);\r\ndrive->waiting_for_dma = 0;\r\n(void)dma_ops->dma_end(drive);\r\nide_dma_unmap_sg(drive, cmd);\r\nret = ide_error(drive, "dma timeout error",\r\nhwif->tp_ops->read_status(hwif));\r\n} else {\r\nprintk(KERN_WARNING "%s: DMA timeout retry\n", drive->name);\r\nif (dma_ops->dma_clear)\r\ndma_ops->dma_clear(drive);\r\nprintk(KERN_ERR "%s: timeout waiting for DMA\n", drive->name);\r\nif (dma_ops->dma_test_irq(drive) == 0) {\r\nide_dump_status(drive, "DMA timeout",\r\nhwif->tp_ops->read_status(hwif));\r\ndrive->waiting_for_dma = 0;\r\n(void)dma_ops->dma_end(drive);\r\nide_dma_unmap_sg(drive, cmd);\r\n}\r\n}\r\ndrive->dev_flags |= IDE_DFLAG_DMA_PIO_RETRY;\r\ndrive->retry_pio++;\r\nide_dma_off_quietly(drive);\r\nif (hwif->rq)\r\nscsi_req(hwif->rq)->result = 0;\r\nreturn ret;\r\n}\r\nvoid ide_release_dma_engine(ide_hwif_t *hwif)\r\n{\r\nif (hwif->dmatable_cpu) {\r\nint prd_size = hwif->prd_max_nents * hwif->prd_ent_size;\r\ndma_free_coherent(hwif->dev, prd_size,\r\nhwif->dmatable_cpu, hwif->dmatable_dma);\r\nhwif->dmatable_cpu = NULL;\r\n}\r\n}\r\nint ide_allocate_dma_engine(ide_hwif_t *hwif)\r\n{\r\nint prd_size;\r\nif (hwif->prd_max_nents == 0)\r\nhwif->prd_max_nents = PRD_ENTRIES;\r\nif (hwif->prd_ent_size == 0)\r\nhwif->prd_ent_size = PRD_BYTES;\r\nprd_size = hwif->prd_max_nents * hwif->prd_ent_size;\r\nhwif->dmatable_cpu = dma_alloc_coherent(hwif->dev, prd_size,\r\n&hwif->dmatable_dma,\r\nGFP_ATOMIC);\r\nif (hwif->dmatable_cpu == NULL) {\r\nprintk(KERN_ERR "%s: unable to allocate PRD table\n",\r\nhwif->name);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nint ide_dma_prepare(ide_drive_t *drive, struct ide_cmd *cmd)\r\n{\r\nconst struct ide_dma_ops *dma_ops = drive->hwif->dma_ops;\r\nif ((drive->dev_flags & IDE_DFLAG_USING_DMA) == 0 ||\r\n(dma_ops->dma_check && dma_ops->dma_check(drive, cmd)))\r\ngoto out;\r\nide_map_sg(drive, cmd);\r\nif (ide_dma_map_sg(drive, cmd) == 0)\r\ngoto out_map;\r\nif (dma_ops->dma_setup(drive, cmd))\r\ngoto out_dma_unmap;\r\ndrive->waiting_for_dma = 1;\r\nreturn 0;\r\nout_dma_unmap:\r\nide_dma_unmap_sg(drive, cmd);\r\nout_map:\r\nide_map_sg(drive, cmd);\r\nout:\r\nreturn 1;\r\n}
