int cxd2820r_set_frontend_c(struct dvb_frontend *fe)\r\n{\r\nstruct cxd2820r_priv *priv = fe->demodulator_priv;\r\nstruct i2c_client *client = priv->client[0];\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret;\r\nunsigned int utmp;\r\nu8 buf[2];\r\nu32 if_frequency;\r\nstruct reg_val_mask tab[] = {\r\n{ 0x00080, 0x01, 0xff },\r\n{ 0x00081, 0x05, 0xff },\r\n{ 0x00085, 0x07, 0xff },\r\n{ 0x00088, 0x01, 0xff },\r\n{ 0x00082, 0x20, 0x60 },\r\n{ 0x1016a, 0x48, 0xff },\r\n{ 0x100a5, 0x00, 0x01 },\r\n{ 0x10020, 0x06, 0x07 },\r\n{ 0x10059, 0x50, 0xff },\r\n{ 0x10087, 0x0c, 0x3c },\r\n{ 0x1008b, 0x07, 0xff },\r\n{ 0x1001f, priv->if_agc_polarity << 7, 0x80 },\r\n{ 0x10070, priv->ts_mode, 0xff },\r\n{ 0x10071, !priv->ts_clk_inv << 4, 0x10 },\r\n};\r\ndev_dbg(&client->dev,\r\n"delivery_system=%d modulation=%d frequency=%u symbol_rate=%u inversion=%d\n",\r\nc->delivery_system, c->modulation, c->frequency,\r\nc->symbol_rate, c->inversion);\r\nif (fe->ops.tuner_ops.set_params)\r\nfe->ops.tuner_ops.set_params(fe);\r\nif (priv->delivery_system != SYS_DVBC_ANNEX_A) {\r\nret = cxd2820r_wr_reg_val_mask_tab(priv, tab, ARRAY_SIZE(tab));\r\nif (ret)\r\ngoto error;\r\n}\r\npriv->delivery_system = SYS_DVBC_ANNEX_A;\r\npriv->ber_running = false;\r\nif (fe->ops.tuner_ops.get_if_frequency) {\r\nret = fe->ops.tuner_ops.get_if_frequency(fe, &if_frequency);\r\nif (ret)\r\ngoto error;\r\ndev_dbg(&client->dev, "if_frequency=%u\n", if_frequency);\r\n} else {\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nutmp = 0x4000 - DIV_ROUND_CLOSEST_ULL((u64)if_frequency * 0x4000, CXD2820R_CLK);\r\nbuf[0] = (utmp >> 8) & 0xff;\r\nbuf[1] = (utmp >> 0) & 0xff;\r\nret = regmap_bulk_write(priv->regmap[1], 0x0042, buf, 2);\r\nif (ret)\r\ngoto error;\r\nret = regmap_write(priv->regmap[0], 0x00ff, 0x08);\r\nif (ret)\r\ngoto error;\r\nret = regmap_write(priv->regmap[0], 0x00fe, 0x01);\r\nif (ret)\r\ngoto error;\r\nreturn ret;\r\nerror:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nint cxd2820r_get_frontend_c(struct dvb_frontend *fe,\r\nstruct dtv_frontend_properties *c)\r\n{\r\nstruct cxd2820r_priv *priv = fe->demodulator_priv;\r\nstruct i2c_client *client = priv->client[0];\r\nint ret;\r\nunsigned int utmp;\r\nu8 buf[2];\r\ndev_dbg(&client->dev, "\n");\r\nret = regmap_bulk_read(priv->regmap[1], 0x001a, buf, 2);\r\nif (ret)\r\ngoto error;\r\nc->symbol_rate = 2500 * ((buf[0] & 0x0f) << 8 | buf[1]);\r\nret = regmap_read(priv->regmap[1], 0x0019, &utmp);\r\nif (ret)\r\ngoto error;\r\nswitch ((utmp >> 0) & 0x07) {\r\ncase 0:\r\nc->modulation = QAM_16;\r\nbreak;\r\ncase 1:\r\nc->modulation = QAM_32;\r\nbreak;\r\ncase 2:\r\nc->modulation = QAM_64;\r\nbreak;\r\ncase 3:\r\nc->modulation = QAM_128;\r\nbreak;\r\ncase 4:\r\nc->modulation = QAM_256;\r\nbreak;\r\n}\r\nswitch ((utmp >> 7) & 0x01) {\r\ncase 0:\r\nc->inversion = INVERSION_OFF;\r\nbreak;\r\ncase 1:\r\nc->inversion = INVERSION_ON;\r\nbreak;\r\n}\r\nreturn ret;\r\nerror:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nint cxd2820r_read_status_c(struct dvb_frontend *fe, enum fe_status *status)\r\n{\r\nstruct cxd2820r_priv *priv = fe->demodulator_priv;\r\nstruct i2c_client *client = priv->client[0];\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret;\r\nunsigned int utmp, utmp1, utmp2;\r\nu8 buf[3];\r\nret = regmap_bulk_read(priv->regmap[1], 0x0088, &buf[0], 1);\r\nif (ret)\r\ngoto error;\r\nret = regmap_bulk_read(priv->regmap[1], 0x0073, &buf[1], 1);\r\nif (ret)\r\ngoto error;\r\nutmp1 = (buf[0] >> 0) & 0x01;\r\nutmp2 = (buf[1] >> 3) & 0x01;\r\nif (utmp1 == 1 && utmp2 == 1) {\r\n*status = FE_HAS_SIGNAL | FE_HAS_CARRIER |\r\nFE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_LOCK;\r\n} else if (utmp1 == 1 || utmp2 == 1) {\r\n*status = FE_HAS_SIGNAL | FE_HAS_CARRIER |\r\nFE_HAS_VITERBI | FE_HAS_SYNC;\r\n} else {\r\n*status = 0;\r\n}\r\ndev_dbg(&client->dev, "status=%02x raw=%*ph sync=%u ts=%u\n",\r\n*status, 2, buf, utmp1, utmp2);\r\nif (*status & FE_HAS_SIGNAL) {\r\nunsigned int strength;\r\nret = regmap_bulk_read(priv->regmap[1], 0x0049, buf, 2);\r\nif (ret)\r\ngoto error;\r\nutmp = buf[0] << 8 | buf[1] << 0;\r\nutmp = 511 - sign_extend32(utmp, 9);\r\nstrength = utmp << 6 | utmp >> 4;\r\nc->strength.len = 1;\r\nc->strength.stat[0].scale = FE_SCALE_RELATIVE;\r\nc->strength.stat[0].uvalue = strength;\r\n} else {\r\nc->strength.len = 1;\r\nc->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\n}\r\nif (*status & FE_HAS_VITERBI) {\r\nunsigned int cnr, const_a, const_b;\r\nret = regmap_read(priv->regmap[1], 0x0019, &utmp);\r\nif (ret)\r\ngoto error;\r\nif (((utmp >> 0) & 0x03) % 2) {\r\nconst_a = 8750;\r\nconst_b = 650;\r\n} else {\r\nconst_a = 9500;\r\nconst_b = 760;\r\n}\r\nret = regmap_read(priv->regmap[1], 0x004d, &utmp);\r\nif (ret)\r\ngoto error;\r\n#define CXD2820R_LOG2_E_24 24204406\r\nif (utmp)\r\ncnr = div_u64((u64)(intlog2(const_b) - intlog2(utmp))\r\n* const_a, CXD2820R_LOG2_E_24);\r\nelse\r\ncnr = 0;\r\nc->cnr.len = 1;\r\nc->cnr.stat[0].scale = FE_SCALE_DECIBEL;\r\nc->cnr.stat[0].svalue = cnr;\r\n} else {\r\nc->cnr.len = 1;\r\nc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\n}\r\nif (*status & FE_HAS_SYNC) {\r\nunsigned int post_bit_error;\r\nbool start_ber;\r\nif (priv->ber_running) {\r\nret = regmap_bulk_read(priv->regmap[1], 0x0076, buf, 3);\r\nif (ret)\r\ngoto error;\r\nif ((buf[2] >> 7) & 0x01) {\r\npost_bit_error = buf[2] << 16 | buf[1] << 8 |\r\nbuf[0] << 0;\r\npost_bit_error &= 0x0fffff;\r\nstart_ber = true;\r\n} else {\r\npost_bit_error = 0;\r\nstart_ber = false;\r\n}\r\n} else {\r\npost_bit_error = 0;\r\nstart_ber = true;\r\n}\r\nif (start_ber) {\r\nret = regmap_write(priv->regmap[1], 0x0079, 0x01);\r\nif (ret)\r\ngoto error;\r\npriv->ber_running = true;\r\n}\r\npriv->post_bit_error += post_bit_error;\r\nc->post_bit_error.len = 1;\r\nc->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;\r\nc->post_bit_error.stat[0].uvalue = priv->post_bit_error;\r\n} else {\r\nc->post_bit_error.len = 1;\r\nc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\n}\r\nreturn ret;\r\nerror:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nint cxd2820r_init_c(struct dvb_frontend *fe)\r\n{\r\nstruct cxd2820r_priv *priv = fe->demodulator_priv;\r\nstruct i2c_client *client = priv->client[0];\r\nint ret;\r\ndev_dbg(&client->dev, "\n");\r\nret = regmap_write(priv->regmap[0], 0x0085, 0x07);\r\nif (ret)\r\ngoto error;\r\nreturn ret;\r\nerror:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nint cxd2820r_sleep_c(struct dvb_frontend *fe)\r\n{\r\nstruct cxd2820r_priv *priv = fe->demodulator_priv;\r\nstruct i2c_client *client = priv->client[0];\r\nint ret;\r\nstruct reg_val_mask tab[] = {\r\n{ 0x000ff, 0x1f, 0xff },\r\n{ 0x00085, 0x00, 0xff },\r\n{ 0x00088, 0x01, 0xff },\r\n{ 0x00081, 0x00, 0xff },\r\n{ 0x00080, 0x00, 0xff },\r\n};\r\ndev_dbg(&client->dev, "\n");\r\npriv->delivery_system = SYS_UNDEFINED;\r\nret = cxd2820r_wr_reg_val_mask_tab(priv, tab, ARRAY_SIZE(tab));\r\nif (ret)\r\ngoto error;\r\nreturn ret;\r\nerror:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nint cxd2820r_get_tune_settings_c(struct dvb_frontend *fe,\r\nstruct dvb_frontend_tune_settings *s)\r\n{\r\ns->min_delay_ms = 500;\r\ns->step_size = 0;\r\ns->max_drift = 0;\r\nreturn 0;\r\n}
