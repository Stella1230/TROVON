static inline u32 ath_dynack_ewma(u32 old, u32 new)\r\n{\r\nreturn (new * (EWMA_DIV - EWMA_LEVEL) + old * EWMA_LEVEL) / EWMA_DIV;\r\n}\r\nstatic inline u32 ath_dynack_get_sifs(struct ath_hw *ah, int phy)\r\n{\r\nu32 sifs = CCK_SIFS_TIME;\r\nif (phy == WLAN_RC_PHY_OFDM) {\r\nif (IS_CHAN_QUARTER_RATE(ah->curchan))\r\nsifs = OFDM_SIFS_TIME_QUARTER;\r\nelse if (IS_CHAN_HALF_RATE(ah->curchan))\r\nsifs = OFDM_SIFS_TIME_HALF;\r\nelse\r\nsifs = OFDM_SIFS_TIME;\r\n}\r\nreturn sifs;\r\n}\r\nstatic inline bool ath_dynack_bssidmask(struct ath_hw *ah, const u8 *mac)\r\n{\r\nint i;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nfor (i = 0; i < ETH_ALEN; i++) {\r\nif ((common->macaddr[i] & common->bssidmask[i]) !=\r\n(mac[i] & common->bssidmask[i]))\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void ath_dynack_compute_ackto(struct ath_hw *ah)\r\n{\r\nstruct ath_node *an;\r\nu32 to = 0;\r\nstruct ath_dynack *da = &ah->dynack;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nlist_for_each_entry(an, &da->nodes, list)\r\nif (an->ackto > to)\r\nto = an->ackto;\r\nif (to && da->ackto != to) {\r\nu32 slottime;\r\nslottime = (to - 3) / 2;\r\nda->ackto = to;\r\nath_dbg(common, DYNACK, "ACK timeout %u slottime %u\n",\r\nda->ackto, slottime);\r\nath9k_hw_setslottime(ah, slottime);\r\nath9k_hw_set_ack_timeout(ah, da->ackto);\r\nath9k_hw_set_cts_timeout(ah, da->ackto);\r\n}\r\n}\r\nstatic void ath_dynack_compute_to(struct ath_hw *ah)\r\n{\r\nu32 ackto, ack_ts;\r\nu8 *dst, *src;\r\nstruct ieee80211_sta *sta;\r\nstruct ath_node *an;\r\nstruct ts_info *st_ts;\r\nstruct ath_dynack *da = &ah->dynack;\r\nrcu_read_lock();\r\nwhile (da->st_rbf.h_rb != da->st_rbf.t_rb &&\r\nda->ack_rbf.h_rb != da->ack_rbf.t_rb) {\r\nack_ts = da->ack_rbf.tstamp[da->ack_rbf.h_rb];\r\nst_ts = &da->st_rbf.ts[da->st_rbf.h_rb];\r\ndst = da->st_rbf.addr[da->st_rbf.h_rb].h_dest;\r\nsrc = da->st_rbf.addr[da->st_rbf.h_rb].h_src;\r\nath_dbg(ath9k_hw_common(ah), DYNACK,\r\n"ack_ts %u st_ts %u st_dur %u [%u-%u]\n",\r\nack_ts, st_ts->tstamp, st_ts->dur,\r\nda->ack_rbf.h_rb, da->st_rbf.h_rb);\r\nif (ack_ts > st_ts->tstamp + st_ts->dur) {\r\nackto = ack_ts - st_ts->tstamp - st_ts->dur;\r\nif (ackto < MAX_DELAY) {\r\nsta = ieee80211_find_sta_by_ifaddr(ah->hw, dst,\r\nsrc);\r\nif (sta) {\r\nan = (struct ath_node *)sta->drv_priv;\r\nan->ackto = ath_dynack_ewma(an->ackto,\r\nackto);\r\nath_dbg(ath9k_hw_common(ah), DYNACK,\r\n"%pM to %u\n", dst, an->ackto);\r\nif (time_is_before_jiffies(da->lto)) {\r\nath_dynack_compute_ackto(ah);\r\nda->lto = jiffies + COMPUTE_TO;\r\n}\r\n}\r\nINCR(da->ack_rbf.h_rb, ATH_DYN_BUF);\r\n}\r\nINCR(da->st_rbf.h_rb, ATH_DYN_BUF);\r\n} else {\r\nINCR(da->ack_rbf.h_rb, ATH_DYN_BUF);\r\n}\r\n}\r\nrcu_read_unlock();\r\n}\r\nvoid ath_dynack_sample_tx_ts(struct ath_hw *ah, struct sk_buff *skb,\r\nstruct ath_tx_status *ts)\r\n{\r\nu8 ridx;\r\nstruct ieee80211_hdr *hdr;\r\nstruct ath_dynack *da = &ah->dynack;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nif ((info->flags & IEEE80211_TX_CTL_NO_ACK) || !da->enabled)\r\nreturn;\r\nspin_lock_bh(&da->qlock);\r\nhdr = (struct ieee80211_hdr *)skb->data;\r\nif (ts->ts_status & ATH9K_TXERR_XRETRY) {\r\nif (ieee80211_is_assoc_req(hdr->frame_control) ||\r\nieee80211_is_assoc_resp(hdr->frame_control)) {\r\nath_dbg(common, DYNACK, "late ack\n");\r\nath9k_hw_setslottime(ah, (LATEACK_TO - 3) / 2);\r\nath9k_hw_set_ack_timeout(ah, LATEACK_TO);\r\nath9k_hw_set_cts_timeout(ah, LATEACK_TO);\r\nda->lto = jiffies + LATEACK_DELAY;\r\n}\r\nspin_unlock_bh(&da->qlock);\r\nreturn;\r\n}\r\nridx = ts->ts_rateindex;\r\nda->st_rbf.ts[da->st_rbf.t_rb].tstamp = ts->ts_tstamp;\r\nda->st_rbf.ts[da->st_rbf.t_rb].dur = ts->duration;\r\nether_addr_copy(da->st_rbf.addr[da->st_rbf.t_rb].h_dest, hdr->addr1);\r\nether_addr_copy(da->st_rbf.addr[da->st_rbf.t_rb].h_src, hdr->addr2);\r\nif (!(info->status.rates[ridx].flags & IEEE80211_TX_RC_MCS)) {\r\nu32 phy, sifs;\r\nconst struct ieee80211_rate *rate;\r\nstruct ieee80211_tx_rate *rates = info->status.rates;\r\nrate = &common->sbands[info->band].bitrates[rates[ridx].idx];\r\nif (info->band == NL80211_BAND_2GHZ &&\r\n!(rate->flags & IEEE80211_RATE_ERP_G))\r\nphy = WLAN_RC_PHY_CCK;\r\nelse\r\nphy = WLAN_RC_PHY_OFDM;\r\nsifs = ath_dynack_get_sifs(ah, phy);\r\nda->st_rbf.ts[da->st_rbf.t_rb].dur -= sifs;\r\n}\r\nath_dbg(common, DYNACK, "{%pM} tx sample %u [dur %u][h %u-t %u]\n",\r\nhdr->addr1, da->st_rbf.ts[da->st_rbf.t_rb].tstamp,\r\nda->st_rbf.ts[da->st_rbf.t_rb].dur, da->st_rbf.h_rb,\r\n(da->st_rbf.t_rb + 1) % ATH_DYN_BUF);\r\nINCR(da->st_rbf.t_rb, ATH_DYN_BUF);\r\nif (da->st_rbf.t_rb == da->st_rbf.h_rb)\r\nINCR(da->st_rbf.h_rb, ATH_DYN_BUF);\r\nath_dynack_compute_to(ah);\r\nspin_unlock_bh(&da->qlock);\r\n}\r\nvoid ath_dynack_sample_ack_ts(struct ath_hw *ah, struct sk_buff *skb,\r\nu32 ts)\r\n{\r\nstruct ath_dynack *da = &ah->dynack;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\r\nif (!ath_dynack_bssidmask(ah, hdr->addr1) || !da->enabled)\r\nreturn;\r\nspin_lock_bh(&da->qlock);\r\nda->ack_rbf.tstamp[da->ack_rbf.t_rb] = ts;\r\nath_dbg(common, DYNACK, "rx sample %u [h %u-t %u]\n",\r\nda->ack_rbf.tstamp[da->ack_rbf.t_rb],\r\nda->ack_rbf.h_rb, (da->ack_rbf.t_rb + 1) % ATH_DYN_BUF);\r\nINCR(da->ack_rbf.t_rb, ATH_DYN_BUF);\r\nif (da->ack_rbf.t_rb == da->ack_rbf.h_rb)\r\nINCR(da->ack_rbf.h_rb, ATH_DYN_BUF);\r\nath_dynack_compute_to(ah);\r\nspin_unlock_bh(&da->qlock);\r\n}\r\nvoid ath_dynack_node_init(struct ath_hw *ah, struct ath_node *an)\r\n{\r\nu32 ackto = 9 + 16 + 64;\r\nstruct ath_dynack *da = &ah->dynack;\r\nan->ackto = ackto;\r\nspin_lock(&da->qlock);\r\nlist_add_tail(&an->list, &da->nodes);\r\nspin_unlock(&da->qlock);\r\n}\r\nvoid ath_dynack_node_deinit(struct ath_hw *ah, struct ath_node *an)\r\n{\r\nstruct ath_dynack *da = &ah->dynack;\r\nspin_lock(&da->qlock);\r\nlist_del(&an->list);\r\nspin_unlock(&da->qlock);\r\n}\r\nvoid ath_dynack_reset(struct ath_hw *ah)\r\n{\r\nu32 ackto = 9 + 16 + 64;\r\nstruct ath_dynack *da = &ah->dynack;\r\nda->lto = jiffies;\r\nda->ackto = ackto;\r\nda->st_rbf.t_rb = 0;\r\nda->st_rbf.h_rb = 0;\r\nda->ack_rbf.t_rb = 0;\r\nda->ack_rbf.h_rb = 0;\r\nath9k_hw_setslottime(ah, (ackto - 3) / 2);\r\nath9k_hw_set_ack_timeout(ah, ackto);\r\nath9k_hw_set_cts_timeout(ah, ackto);\r\n}\r\nvoid ath_dynack_init(struct ath_hw *ah)\r\n{\r\nstruct ath_dynack *da = &ah->dynack;\r\nmemset(da, 0, sizeof(struct ath_dynack));\r\nspin_lock_init(&da->qlock);\r\nINIT_LIST_HEAD(&da->nodes);\r\nah->hw->wiphy->features |= NL80211_FEATURE_ACKTO_ESTIMATION;\r\n}
