static inline void uwire_write_reg(int idx, u16 val)\r\n{\r\n__raw_writew(val, uwire_base + (idx << uwire_idx_shift));\r\n}\r\nstatic inline u16 uwire_read_reg(int idx)\r\n{\r\nreturn __raw_readw(uwire_base + (idx << uwire_idx_shift));\r\n}\r\nstatic inline void omap_uwire_configure_mode(u8 cs, unsigned long flags)\r\n{\r\nu16 w, val = 0;\r\nint shift, reg;\r\nif (flags & UWIRE_CLK_INVERTED)\r\nval ^= 0x03;\r\nval = flags & 0x3f;\r\nif (cs & 1)\r\nshift = 6;\r\nelse\r\nshift = 0;\r\nif (cs <= 1)\r\nreg = UWIRE_SR1;\r\nelse\r\nreg = UWIRE_SR2;\r\nw = uwire_read_reg(reg);\r\nw &= ~(0x3f << shift);\r\nw |= val << shift;\r\nuwire_write_reg(reg, w);\r\n}\r\nstatic int wait_uwire_csr_flag(u16 mask, u16 val, int might_not_catch)\r\n{\r\nu16 w;\r\nint c = 0;\r\nunsigned long max_jiffies = jiffies + HZ;\r\nfor (;;) {\r\nw = uwire_read_reg(UWIRE_CSR);\r\nif ((w & mask) == val)\r\nbreak;\r\nif (time_after(jiffies, max_jiffies)) {\r\nprintk(KERN_ERR "%s: timeout. reg=%#06x "\r\n"mask=%#06x val=%#06x\n",\r\n__func__, w, mask, val);\r\nreturn -1;\r\n}\r\nc++;\r\nif (might_not_catch && c > 64)\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void uwire_set_clk1_div(int div1_idx)\r\n{\r\nu16 w;\r\nw = uwire_read_reg(UWIRE_SR3);\r\nw &= ~(0x03 << 1);\r\nw |= div1_idx << 1;\r\nuwire_write_reg(UWIRE_SR3, w);\r\n}\r\nstatic void uwire_chipselect(struct spi_device *spi, int value)\r\n{\r\nstruct uwire_state *ust = spi->controller_state;\r\nu16 w;\r\nint old_cs;\r\nBUG_ON(wait_uwire_csr_flag(CSRB, 0, 0));\r\nw = uwire_read_reg(UWIRE_CSR);\r\nold_cs = (w >> 10) & 0x03;\r\nif (value == BITBANG_CS_INACTIVE || old_cs != spi->chip_select) {\r\nw &= ~CS_CMD;\r\nuwire_write_reg(UWIRE_CSR, w);\r\n}\r\nif (value == BITBANG_CS_ACTIVE) {\r\nuwire_set_clk1_div(ust->div1_idx);\r\nif (spi->mode & SPI_CPOL)\r\nuwire_write_reg(UWIRE_SR4, 1);\r\nelse\r\nuwire_write_reg(UWIRE_SR4, 0);\r\nw = spi->chip_select << 10;\r\nw |= CS_CMD;\r\nuwire_write_reg(UWIRE_CSR, w);\r\n}\r\n}\r\nstatic int uwire_txrx(struct spi_device *spi, struct spi_transfer *t)\r\n{\r\nunsigned len = t->len;\r\nunsigned bits = t->bits_per_word;\r\nunsigned bytes;\r\nu16 val, w;\r\nint status = 0;\r\nif (!t->tx_buf && !t->rx_buf)\r\nreturn 0;\r\nw = spi->chip_select << 10;\r\nw |= CS_CMD;\r\nif (t->tx_buf) {\r\nconst u8 *buf = t->tx_buf;\r\nwhile (len >= 1) {\r\nval = *buf++;\r\nif (bits > 8) {\r\nbytes = 2;\r\nval |= *buf++ << 8;\r\n} else\r\nbytes = 1;\r\nval <<= 16 - bits;\r\n#ifdef VERBOSE\r\npr_debug("%s: write-%d =%04x\n",\r\ndev_name(&spi->dev), bits, val);\r\n#endif\r\nif (wait_uwire_csr_flag(CSRB, 0, 0))\r\ngoto eio;\r\nuwire_write_reg(UWIRE_TDR, val);\r\nval = START | w | (bits << 5);\r\nuwire_write_reg(UWIRE_CSR, val);\r\nlen -= bytes;\r\nif (wait_uwire_csr_flag(CSRB, CSRB, 1))\r\ngoto eio;\r\nstatus += bytes;\r\n}\r\nif (wait_uwire_csr_flag(CSRB, 0, 0))\r\ngoto eio;\r\n} else if (t->rx_buf) {\r\nu8 *buf = t->rx_buf;\r\nwhile (len) {\r\nif (bits > 8) {\r\nbytes = 2;\r\n} else\r\nbytes = 1;\r\nval = START | w | (bits << 0);\r\nuwire_write_reg(UWIRE_CSR, val);\r\nlen -= bytes;\r\n(void) wait_uwire_csr_flag(CSRB, CSRB, 1);\r\nif (wait_uwire_csr_flag(RDRB | CSRB,\r\nRDRB, 0))\r\ngoto eio;\r\nval = uwire_read_reg(UWIRE_RDR);\r\nval &= (1 << bits) - 1;\r\n*buf++ = (u8) val;\r\nif (bytes == 2)\r\n*buf++ = val >> 8;\r\nstatus += bytes;\r\n#ifdef VERBOSE\r\npr_debug("%s: read-%d =%04x\n",\r\ndev_name(&spi->dev), bits, val);\r\n#endif\r\n}\r\n}\r\nreturn status;\r\neio:\r\nreturn -EIO;\r\n}\r\nstatic int uwire_setup_transfer(struct spi_device *spi, struct spi_transfer *t)\r\n{\r\nstruct uwire_state *ust = spi->controller_state;\r\nstruct uwire_spi *uwire;\r\nunsigned flags = 0;\r\nunsigned hz;\r\nunsigned long rate;\r\nint div1_idx;\r\nint div1;\r\nint div2;\r\nint status;\r\nuwire = spi_master_get_devdata(spi->master);\r\nif (spi->mode & SPI_CS_HIGH)\r\nflags |= UWIRE_CS_ACTIVE_HIGH;\r\nif (spi->mode & SPI_CPOL)\r\nflags |= UWIRE_CLK_INVERTED;\r\nswitch (spi->mode & (SPI_CPOL | SPI_CPHA)) {\r\ncase SPI_MODE_0:\r\ncase SPI_MODE_3:\r\nflags |= UWIRE_WRITE_FALLING_EDGE | UWIRE_READ_RISING_EDGE;\r\nbreak;\r\ncase SPI_MODE_1:\r\ncase SPI_MODE_2:\r\nflags |= UWIRE_WRITE_RISING_EDGE | UWIRE_READ_FALLING_EDGE;\r\nbreak;\r\n}\r\nrate = clk_get_rate(uwire->ck);\r\nif (t != NULL)\r\nhz = t->speed_hz;\r\nelse\r\nhz = spi->max_speed_hz;\r\nif (!hz) {\r\npr_debug("%s: zero speed?\n", dev_name(&spi->dev));\r\nstatus = -EINVAL;\r\ngoto done;\r\n}\r\nfor (div1_idx = 0; div1_idx < 4; div1_idx++) {\r\nswitch (div1_idx) {\r\ncase 0:\r\ndiv1 = 2;\r\nbreak;\r\ncase 1:\r\ndiv1 = 4;\r\nbreak;\r\ncase 2:\r\ndiv1 = 7;\r\nbreak;\r\ndefault:\r\ncase 3:\r\ndiv1 = 10;\r\nbreak;\r\n}\r\ndiv2 = (rate / div1 + hz - 1) / hz;\r\nif (div2 <= 8)\r\nbreak;\r\n}\r\nif (div1_idx == 4) {\r\npr_debug("%s: lowest clock %ld, need %d\n",\r\ndev_name(&spi->dev), rate / 10 / 8, hz);\r\nstatus = -EDOM;\r\ngoto done;\r\n}\r\nust->div1_idx = div1_idx;\r\nuwire_set_clk1_div(div1_idx);\r\nrate /= div1;\r\nswitch (div2) {\r\ncase 0:\r\ncase 1:\r\ncase 2:\r\nflags |= UWIRE_FREQ_DIV_2;\r\nrate /= 2;\r\nbreak;\r\ncase 3:\r\ncase 4:\r\nflags |= UWIRE_FREQ_DIV_4;\r\nrate /= 4;\r\nbreak;\r\ncase 5:\r\ncase 6:\r\ncase 7:\r\ncase 8:\r\nflags |= UWIRE_FREQ_DIV_8;\r\nrate /= 8;\r\nbreak;\r\n}\r\nomap_uwire_configure_mode(spi->chip_select, flags);\r\npr_debug("%s: uwire flags %02x, armxor %lu KHz, SCK %lu KHz\n",\r\n__func__, flags,\r\nclk_get_rate(uwire->ck) / 1000,\r\nrate / 1000);\r\nstatus = 0;\r\ndone:\r\nreturn status;\r\n}\r\nstatic int uwire_setup(struct spi_device *spi)\r\n{\r\nstruct uwire_state *ust = spi->controller_state;\r\nif (ust == NULL) {\r\nust = kzalloc(sizeof(*ust), GFP_KERNEL);\r\nif (ust == NULL)\r\nreturn -ENOMEM;\r\nspi->controller_state = ust;\r\n}\r\nreturn uwire_setup_transfer(spi, NULL);\r\n}\r\nstatic void uwire_cleanup(struct spi_device *spi)\r\n{\r\nkfree(spi->controller_state);\r\n}\r\nstatic void uwire_off(struct uwire_spi *uwire)\r\n{\r\nuwire_write_reg(UWIRE_SR3, 0);\r\nclk_disable(uwire->ck);\r\nspi_master_put(uwire->bitbang.master);\r\n}\r\nstatic int uwire_probe(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master;\r\nstruct uwire_spi *uwire;\r\nint status;\r\nmaster = spi_alloc_master(&pdev->dev, sizeof *uwire);\r\nif (!master)\r\nreturn -ENODEV;\r\nuwire = spi_master_get_devdata(master);\r\nuwire_base = devm_ioremap(&pdev->dev, UWIRE_BASE_PHYS, UWIRE_IO_SIZE);\r\nif (!uwire_base) {\r\ndev_dbg(&pdev->dev, "can't ioremap UWIRE\n");\r\nspi_master_put(master);\r\nreturn -ENOMEM;\r\n}\r\nplatform_set_drvdata(pdev, uwire);\r\nuwire->ck = devm_clk_get(&pdev->dev, "fck");\r\nif (IS_ERR(uwire->ck)) {\r\nstatus = PTR_ERR(uwire->ck);\r\ndev_dbg(&pdev->dev, "no functional clock?\n");\r\nspi_master_put(master);\r\nreturn status;\r\n}\r\nclk_enable(uwire->ck);\r\nif (cpu_is_omap7xx())\r\nuwire_idx_shift = 1;\r\nelse\r\nuwire_idx_shift = 2;\r\nuwire_write_reg(UWIRE_SR3, 1);\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;\r\nmaster->bits_per_word_mask = SPI_BPW_RANGE_MASK(1, 16);\r\nmaster->flags = SPI_MASTER_HALF_DUPLEX;\r\nmaster->bus_num = 2;\r\nmaster->num_chipselect = 4;\r\nmaster->setup = uwire_setup;\r\nmaster->cleanup = uwire_cleanup;\r\nuwire->bitbang.master = master;\r\nuwire->bitbang.chipselect = uwire_chipselect;\r\nuwire->bitbang.setup_transfer = uwire_setup_transfer;\r\nuwire->bitbang.txrx_bufs = uwire_txrx;\r\nstatus = spi_bitbang_start(&uwire->bitbang);\r\nif (status < 0) {\r\nuwire_off(uwire);\r\n}\r\nreturn status;\r\n}\r\nstatic int uwire_remove(struct platform_device *pdev)\r\n{\r\nstruct uwire_spi *uwire = platform_get_drvdata(pdev);\r\nspi_bitbang_stop(&uwire->bitbang);\r\nuwire_off(uwire);\r\nreturn 0;\r\n}\r\nstatic int __init omap_uwire_init(void)\r\n{\r\nif (machine_is_omap_h2()) {\r\nomap_cfg_reg(N14_1610_UWIRE_CS0);\r\nomap_cfg_reg(N15_1610_UWIRE_CS1);\r\n}\r\nif (machine_is_omap_perseus2()) {\r\nint val = omap_readl(OMAP7XX_IO_CONF_9) & ~0x00EEE000;\r\nomap_writel(val | 0x00AAA000, OMAP7XX_IO_CONF_9);\r\n}\r\nreturn platform_driver_register(&uwire_driver);\r\n}\r\nstatic void __exit omap_uwire_exit(void)\r\n{\r\nplatform_driver_unregister(&uwire_driver);\r\n}
