static inline void nft_bitmap_location(const struct nft_set *set,\r\nconst void *key,\r\nu32 *idx, u32 *off)\r\n{\r\nu32 k;\r\nif (set->klen == 2)\r\nk = *(u16 *)key;\r\nelse\r\nk = *(u8 *)key;\r\nk <<= 1;\r\n*idx = k / BITS_PER_BYTE;\r\n*off = k % BITS_PER_BYTE;\r\n}\r\nstatic inline bool\r\nnft_bitmap_active(const u8 *bitmap, u32 idx, u32 off, u8 genmask)\r\n{\r\nreturn (bitmap[idx] & (0x3 << off)) & (genmask << off);\r\n}\r\nstatic bool nft_bitmap_lookup(const struct net *net, const struct nft_set *set,\r\nconst u32 *key, const struct nft_set_ext **ext)\r\n{\r\nconst struct nft_bitmap *priv = nft_set_priv(set);\r\nu8 genmask = nft_genmask_cur(net);\r\nu32 idx, off;\r\nnft_bitmap_location(set, key, &idx, &off);\r\nreturn nft_bitmap_active(priv->bitmap, idx, off, genmask);\r\n}\r\nstatic struct nft_bitmap_elem *\r\nnft_bitmap_elem_find(const struct nft_set *set, struct nft_bitmap_elem *this,\r\nu8 genmask)\r\n{\r\nconst struct nft_bitmap *priv = nft_set_priv(set);\r\nstruct nft_bitmap_elem *be;\r\nlist_for_each_entry_rcu(be, &priv->list, head) {\r\nif (memcmp(nft_set_ext_key(&be->ext),\r\nnft_set_ext_key(&this->ext), set->klen) ||\r\n!nft_set_elem_active(&be->ext, genmask))\r\ncontinue;\r\nreturn be;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int nft_bitmap_insert(const struct net *net, const struct nft_set *set,\r\nconst struct nft_set_elem *elem,\r\nstruct nft_set_ext **ext)\r\n{\r\nstruct nft_bitmap *priv = nft_set_priv(set);\r\nstruct nft_bitmap_elem *new = elem->priv, *be;\r\nu8 genmask = nft_genmask_next(net);\r\nu32 idx, off;\r\nbe = nft_bitmap_elem_find(set, new, genmask);\r\nif (be) {\r\n*ext = &be->ext;\r\nreturn -EEXIST;\r\n}\r\nnft_bitmap_location(set, nft_set_ext_key(&new->ext), &idx, &off);\r\npriv->bitmap[idx] |= (genmask << off);\r\nlist_add_tail_rcu(&new->head, &priv->list);\r\nreturn 0;\r\n}\r\nstatic void nft_bitmap_remove(const struct net *net,\r\nconst struct nft_set *set,\r\nconst struct nft_set_elem *elem)\r\n{\r\nstruct nft_bitmap *priv = nft_set_priv(set);\r\nstruct nft_bitmap_elem *be = elem->priv;\r\nu8 genmask = nft_genmask_next(net);\r\nu32 idx, off;\r\nnft_bitmap_location(set, nft_set_ext_key(&be->ext), &idx, &off);\r\npriv->bitmap[idx] &= ~(genmask << off);\r\nlist_del_rcu(&be->head);\r\n}\r\nstatic void nft_bitmap_activate(const struct net *net,\r\nconst struct nft_set *set,\r\nconst struct nft_set_elem *elem)\r\n{\r\nstruct nft_bitmap *priv = nft_set_priv(set);\r\nstruct nft_bitmap_elem *be = elem->priv;\r\nu8 genmask = nft_genmask_next(net);\r\nu32 idx, off;\r\nnft_bitmap_location(set, nft_set_ext_key(&be->ext), &idx, &off);\r\npriv->bitmap[idx] |= (genmask << off);\r\nnft_set_elem_change_active(net, set, &be->ext);\r\n}\r\nstatic bool nft_bitmap_flush(const struct net *net,\r\nconst struct nft_set *set, void *_be)\r\n{\r\nstruct nft_bitmap *priv = nft_set_priv(set);\r\nu8 genmask = nft_genmask_next(net);\r\nstruct nft_bitmap_elem *be = _be;\r\nu32 idx, off;\r\nnft_bitmap_location(set, nft_set_ext_key(&be->ext), &idx, &off);\r\npriv->bitmap[idx] &= ~(genmask << off);\r\nnft_set_elem_change_active(net, set, &be->ext);\r\nreturn true;\r\n}\r\nstatic void *nft_bitmap_deactivate(const struct net *net,\r\nconst struct nft_set *set,\r\nconst struct nft_set_elem *elem)\r\n{\r\nstruct nft_bitmap *priv = nft_set_priv(set);\r\nstruct nft_bitmap_elem *this = elem->priv, *be;\r\nu8 genmask = nft_genmask_next(net);\r\nu32 idx, off;\r\nnft_bitmap_location(set, elem->key.val.data, &idx, &off);\r\nbe = nft_bitmap_elem_find(set, this, genmask);\r\nif (!be)\r\nreturn NULL;\r\npriv->bitmap[idx] &= ~(genmask << off);\r\nnft_set_elem_change_active(net, set, &be->ext);\r\nreturn be;\r\n}\r\nstatic void nft_bitmap_walk(const struct nft_ctx *ctx,\r\nstruct nft_set *set,\r\nstruct nft_set_iter *iter)\r\n{\r\nconst struct nft_bitmap *priv = nft_set_priv(set);\r\nstruct nft_bitmap_elem *be;\r\nstruct nft_set_elem elem;\r\nlist_for_each_entry_rcu(be, &priv->list, head) {\r\nif (iter->count < iter->skip)\r\ngoto cont;\r\nif (!nft_set_elem_active(&be->ext, iter->genmask))\r\ngoto cont;\r\nelem.priv = be;\r\niter->err = iter->fn(ctx, set, iter, &elem);\r\nif (iter->err < 0)\r\nreturn;\r\ncont:\r\niter->count++;\r\n}\r\n}\r\nstatic inline u32 nft_bitmap_size(u32 klen)\r\n{\r\nreturn ((2 << ((klen * BITS_PER_BYTE) - 1)) / BITS_PER_BYTE) << 1;\r\n}\r\nstatic inline u32 nft_bitmap_total_size(u32 klen)\r\n{\r\nreturn sizeof(struct nft_bitmap) + nft_bitmap_size(klen);\r\n}\r\nstatic unsigned int nft_bitmap_privsize(const struct nlattr * const nla[],\r\nconst struct nft_set_desc *desc)\r\n{\r\nu32 klen = ntohl(nla_get_be32(nla[NFTA_SET_KEY_LEN]));\r\nreturn nft_bitmap_total_size(klen);\r\n}\r\nstatic int nft_bitmap_init(const struct nft_set *set,\r\nconst struct nft_set_desc *desc,\r\nconst struct nlattr * const nla[])\r\n{\r\nstruct nft_bitmap *priv = nft_set_priv(set);\r\nINIT_LIST_HEAD(&priv->list);\r\npriv->bitmap_size = nft_bitmap_size(set->klen);\r\nreturn 0;\r\n}\r\nstatic void nft_bitmap_destroy(const struct nft_set *set)\r\n{\r\nstruct nft_bitmap *priv = nft_set_priv(set);\r\nstruct nft_bitmap_elem *be, *n;\r\nlist_for_each_entry_safe(be, n, &priv->list, head)\r\nnft_set_elem_destroy(set, be, true);\r\n}\r\nstatic bool nft_bitmap_estimate(const struct nft_set_desc *desc, u32 features,\r\nstruct nft_set_estimate *est)\r\n{\r\nif (desc->klen > 2)\r\nreturn false;\r\nest->size = nft_bitmap_total_size(desc->klen);\r\nest->lookup = NFT_SET_CLASS_O_1;\r\nest->space = NFT_SET_CLASS_O_1;\r\nreturn true;\r\n}\r\nstatic int __init nft_bitmap_module_init(void)\r\n{\r\nreturn nft_register_set(&nft_bitmap_type);\r\n}\r\nstatic void __exit nft_bitmap_module_exit(void)\r\n{\r\nnft_unregister_set(&nft_bitmap_type);\r\n}
