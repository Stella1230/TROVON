struct ls_ucode_img *\r\nacr_r367_ls_ucode_img_load(const struct acr_r352 *acr,\r\nconst struct nvkm_secboot *sb,\r\nenum nvkm_secboot_falcon falcon_id)\r\n{\r\nconst struct nvkm_subdev *subdev = acr->base.subdev;\r\nstruct ls_ucode_img_r367 *img;\r\nint ret;\r\nimg = kzalloc(sizeof(*img), GFP_KERNEL);\r\nif (!img)\r\nreturn ERR_PTR(-ENOMEM);\r\nimg->base.falcon_id = falcon_id;\r\nret = acr->func->ls_func[falcon_id]->load(sb, &img->base);\r\nif (ret) {\r\nkfree(img->base.ucode_data);\r\nkfree(img->base.sig);\r\nkfree(img);\r\nreturn ERR_PTR(ret);\r\n}\r\nif (img->base.sig_size != sizeof(img->lsb_header.signature)) {\r\nnvkm_error(subdev, "invalid signature size for %s falcon!\n",\r\nnvkm_secboot_falcon_name[falcon_id]);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nmemcpy(&img->lsb_header.signature, img->base.sig, img->base.sig_size);\r\nimg->lsb_header.signature.falcon_id = falcon_id;\r\nreturn &img->base;\r\n}\r\nstatic u32\r\nacr_r367_ls_img_fill_headers(struct acr_r352 *acr,\r\nstruct ls_ucode_img_r367 *img, u32 offset)\r\n{\r\nstruct ls_ucode_img *_img = &img->base;\r\nstruct acr_r367_lsf_wpr_header *whdr = &img->wpr_header;\r\nstruct acr_r367_lsf_lsb_header *lhdr = &img->lsb_header;\r\nstruct ls_ucode_img_desc *desc = &_img->ucode_desc;\r\nconst struct acr_r352_ls_func *func =\r\nacr->func->ls_func[_img->falcon_id];\r\nwhdr->falcon_id = _img->falcon_id;\r\nwhdr->bootstrap_owner = acr->base.boot_falcon;\r\nwhdr->bin_version = lhdr->signature.version;\r\nwhdr->status = LSF_IMAGE_STATUS_COPY;\r\nif (acr->lazy_bootstrap & BIT(_img->falcon_id))\r\nwhdr->lazy_bootstrap = 1;\r\noffset = ALIGN(offset, LSF_LSB_HEADER_ALIGN);\r\nwhdr->lsb_offset = offset;\r\noffset += sizeof(*lhdr);\r\noffset = ALIGN(offset, LSF_UCODE_DATA_ALIGN);\r\n_img->ucode_off = lhdr->ucode_off = offset;\r\noffset += _img->ucode_size;\r\nlhdr->bl_code_size = ALIGN(desc->bootloader_size,\r\nLSF_BL_CODE_SIZE_ALIGN);\r\nlhdr->ucode_size = ALIGN(desc->app_resident_data_offset,\r\nLSF_BL_CODE_SIZE_ALIGN) + lhdr->bl_code_size;\r\nlhdr->data_size = ALIGN(desc->app_size, LSF_BL_CODE_SIZE_ALIGN) +\r\nlhdr->bl_code_size - lhdr->ucode_size;\r\nlhdr->bl_imem_off = desc->bootloader_imem_offset;\r\nlhdr->app_code_off = desc->app_start_offset +\r\ndesc->app_resident_code_offset;\r\nlhdr->app_code_size = desc->app_resident_code_size;\r\nlhdr->app_data_off = desc->app_start_offset +\r\ndesc->app_resident_data_offset;\r\nlhdr->app_data_size = desc->app_resident_data_size;\r\nlhdr->flags = func->lhdr_flags;\r\nif (_img->falcon_id == acr->base.boot_falcon)\r\nlhdr->flags |= LSF_FLAG_DMACTL_REQ_CTX;\r\nlhdr->bl_data_size = ALIGN(func->bl_desc_size, LSF_BL_DATA_SIZE_ALIGN);\r\noffset = ALIGN(offset, LSF_BL_DATA_ALIGN);\r\nlhdr->bl_data_off = offset;\r\noffset += lhdr->bl_data_size;\r\nreturn offset;\r\n}\r\nint\r\nacr_r367_ls_fill_headers(struct acr_r352 *acr, struct list_head *imgs)\r\n{\r\nstruct ls_ucode_img_r367 *img;\r\nstruct list_head *l;\r\nu32 count = 0;\r\nu32 offset;\r\nlist_for_each(l, imgs)\r\ncount++;\r\noffset = sizeof(img->wpr_header) * (count + 1);\r\nlist_for_each_entry(img, imgs, base.node) {\r\noffset = acr_r367_ls_img_fill_headers(acr, img, offset);\r\n}\r\nreturn offset;\r\n}\r\nint\r\nacr_r367_ls_write_wpr(struct acr_r352 *acr, struct list_head *imgs,\r\nstruct nvkm_gpuobj *wpr_blob, u64 wpr_addr)\r\n{\r\nstruct ls_ucode_img *_img;\r\nu32 pos = 0;\r\nnvkm_kmap(wpr_blob);\r\nlist_for_each_entry(_img, imgs, node) {\r\nstruct ls_ucode_img_r367 *img = ls_ucode_img_r367(_img);\r\nconst struct acr_r352_ls_func *ls_func =\r\nacr->func->ls_func[_img->falcon_id];\r\nu8 gdesc[ls_func->bl_desc_size];\r\nnvkm_gpuobj_memcpy_to(wpr_blob, pos, &img->wpr_header,\r\nsizeof(img->wpr_header));\r\nnvkm_gpuobj_memcpy_to(wpr_blob, img->wpr_header.lsb_offset,\r\n&img->lsb_header, sizeof(img->lsb_header));\r\nmemset(gdesc, 0, ls_func->bl_desc_size);\r\nls_func->generate_bl_desc(&acr->base, _img, wpr_addr, gdesc);\r\nnvkm_gpuobj_memcpy_to(wpr_blob, img->lsb_header.bl_data_off,\r\ngdesc, ls_func->bl_desc_size);\r\nnvkm_gpuobj_memcpy_to(wpr_blob, img->lsb_header.ucode_off,\r\n_img->ucode_data, _img->ucode_size);\r\npos += sizeof(img->wpr_header);\r\n}\r\nnvkm_wo32(wpr_blob, pos, NVKM_SECBOOT_FALCON_INVALID);\r\nnvkm_done(wpr_blob);\r\nreturn 0;\r\n}\r\nvoid\r\nacr_r367_fixup_hs_desc(struct acr_r352 *acr, struct nvkm_secboot *sb,\r\nvoid *_desc)\r\n{\r\nstruct acr_r367_hsflcn_desc *desc = _desc;\r\nstruct nvkm_gpuobj *ls_blob = acr->ls_blob;\r\nif (sb->wpr_size == 0) {\r\nu64 wpr_start = ls_blob->addr;\r\nu64 wpr_end = ls_blob->addr + ls_blob->size;\r\nif (acr->func->shadow_blob)\r\nwpr_start += ls_blob->size / 2;\r\ndesc->wpr_region_id = 1;\r\ndesc->regions.no_regions = 2;\r\ndesc->regions.region_props[0].start_addr = wpr_start >> 8;\r\ndesc->regions.region_props[0].end_addr = wpr_end >> 8;\r\ndesc->regions.region_props[0].region_id = 1;\r\ndesc->regions.region_props[0].read_mask = 0xf;\r\ndesc->regions.region_props[0].write_mask = 0xc;\r\ndesc->regions.region_props[0].client_mask = 0x2;\r\nif (acr->func->shadow_blob)\r\ndesc->regions.region_props[0].shadow_mem_start_addr =\r\nls_blob->addr >> 8;\r\nelse\r\ndesc->regions.region_props[0].shadow_mem_start_addr = 0;\r\n} else {\r\ndesc->ucode_blob_base = ls_blob->addr;\r\ndesc->ucode_blob_size = ls_blob->size;\r\n}\r\n}\r\nstruct nvkm_acr *\r\nacr_r367_new(enum nvkm_secboot_falcon boot_falcon,\r\nunsigned long managed_falcons)\r\n{\r\nreturn acr_r352_new_(&acr_r367_func, boot_falcon, managed_falcons);\r\n}
