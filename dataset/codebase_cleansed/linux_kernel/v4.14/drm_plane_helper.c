static int get_connectors_for_crtc(struct drm_crtc *crtc,\r\nstruct drm_connector **connector_list,\r\nint num_connectors)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_connector *connector;\r\nstruct drm_connector_list_iter conn_iter;\r\nint count = 0;\r\nWARN_ON(!drm_modeset_is_locked(&dev->mode_config.connection_mutex));\r\ndrm_connector_list_iter_begin(dev, &conn_iter);\r\ndrm_for_each_connector_iter(connector, &conn_iter) {\r\nif (connector->encoder && connector->encoder->crtc == crtc) {\r\nif (connector_list != NULL && count < num_connectors)\r\n*(connector_list++) = connector;\r\ncount++;\r\n}\r\n}\r\ndrm_connector_list_iter_end(&conn_iter);\r\nreturn count;\r\n}\r\nint drm_plane_helper_check_state(struct drm_plane_state *state,\r\nconst struct drm_rect *clip,\r\nint min_scale,\r\nint max_scale,\r\nbool can_position,\r\nbool can_update_disabled)\r\n{\r\nstruct drm_crtc *crtc = state->crtc;\r\nstruct drm_framebuffer *fb = state->fb;\r\nstruct drm_rect *src = &state->src;\r\nstruct drm_rect *dst = &state->dst;\r\nunsigned int rotation = state->rotation;\r\nint hscale, vscale;\r\n*src = drm_plane_state_src(state);\r\n*dst = drm_plane_state_dest(state);\r\nif (!fb) {\r\nstate->visible = false;\r\nreturn 0;\r\n}\r\nif (WARN_ON(!crtc)) {\r\nstate->visible = false;\r\nreturn 0;\r\n}\r\nif (!crtc->enabled && !can_update_disabled) {\r\nDRM_DEBUG_KMS("Cannot update plane of a disabled CRTC.\n");\r\nreturn -EINVAL;\r\n}\r\ndrm_rect_rotate(src, fb->width << 16, fb->height << 16, rotation);\r\nhscale = drm_rect_calc_hscale(src, dst, min_scale, max_scale);\r\nvscale = drm_rect_calc_vscale(src, dst, min_scale, max_scale);\r\nif (hscale < 0 || vscale < 0) {\r\nDRM_DEBUG_KMS("Invalid scaling of plane\n");\r\ndrm_rect_debug_print("src: ", &state->src, true);\r\ndrm_rect_debug_print("dst: ", &state->dst, false);\r\nreturn -ERANGE;\r\n}\r\nstate->visible = drm_rect_clip_scaled(src, dst, clip, hscale, vscale);\r\ndrm_rect_rotate_inv(src, fb->width << 16, fb->height << 16, rotation);\r\nif (!state->visible)\r\nreturn 0;\r\nif (!can_position && !drm_rect_equals(dst, clip)) {\r\nDRM_DEBUG_KMS("Plane must cover entire CRTC\n");\r\ndrm_rect_debug_print("dst: ", dst, false);\r\ndrm_rect_debug_print("clip: ", clip, false);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint drm_plane_helper_check_update(struct drm_plane *plane,\r\nstruct drm_crtc *crtc,\r\nstruct drm_framebuffer *fb,\r\nstruct drm_rect *src,\r\nstruct drm_rect *dst,\r\nconst struct drm_rect *clip,\r\nunsigned int rotation,\r\nint min_scale,\r\nint max_scale,\r\nbool can_position,\r\nbool can_update_disabled,\r\nbool *visible)\r\n{\r\nstruct drm_plane_state state = {\r\n.plane = plane,\r\n.crtc = crtc,\r\n.fb = fb,\r\n.src_x = src->x1,\r\n.src_y = src->y1,\r\n.src_w = drm_rect_width(src),\r\n.src_h = drm_rect_height(src),\r\n.crtc_x = dst->x1,\r\n.crtc_y = dst->y1,\r\n.crtc_w = drm_rect_width(dst),\r\n.crtc_h = drm_rect_height(dst),\r\n.rotation = rotation,\r\n.visible = *visible,\r\n};\r\nint ret;\r\nret = drm_plane_helper_check_state(&state, clip,\r\nmin_scale, max_scale,\r\ncan_position,\r\ncan_update_disabled);\r\nif (ret)\r\nreturn ret;\r\n*src = state.src;\r\n*dst = state.dst;\r\n*visible = state.visible;\r\nreturn 0;\r\n}\r\nint drm_primary_helper_update(struct drm_plane *plane, struct drm_crtc *crtc,\r\nstruct drm_framebuffer *fb,\r\nint crtc_x, int crtc_y,\r\nunsigned int crtc_w, unsigned int crtc_h,\r\nuint32_t src_x, uint32_t src_y,\r\nuint32_t src_w, uint32_t src_h,\r\nstruct drm_modeset_acquire_ctx *ctx)\r\n{\r\nstruct drm_mode_set set = {\r\n.crtc = crtc,\r\n.fb = fb,\r\n.mode = &crtc->mode,\r\n.x = src_x >> 16,\r\n.y = src_y >> 16,\r\n};\r\nstruct drm_rect src = {\r\n.x1 = src_x,\r\n.y1 = src_y,\r\n.x2 = src_x + src_w,\r\n.y2 = src_y + src_h,\r\n};\r\nstruct drm_rect dest = {\r\n.x1 = crtc_x,\r\n.y1 = crtc_y,\r\n.x2 = crtc_x + crtc_w,\r\n.y2 = crtc_y + crtc_h,\r\n};\r\nconst struct drm_rect clip = {\r\n.x2 = crtc->mode.hdisplay,\r\n.y2 = crtc->mode.vdisplay,\r\n};\r\nstruct drm_connector **connector_list;\r\nint num_connectors, ret;\r\nbool visible;\r\nret = drm_plane_helper_check_update(plane, crtc, fb,\r\n&src, &dest, &clip,\r\nDRM_MODE_ROTATE_0,\r\nDRM_PLANE_HELPER_NO_SCALING,\r\nDRM_PLANE_HELPER_NO_SCALING,\r\nfalse, false, &visible);\r\nif (ret)\r\nreturn ret;\r\nif (!visible)\r\nreturn plane->funcs->disable_plane(plane, ctx);\r\nnum_connectors = get_connectors_for_crtc(crtc, NULL, 0);\r\nBUG_ON(num_connectors == 0);\r\nconnector_list = kzalloc(num_connectors * sizeof(*connector_list),\r\nGFP_KERNEL);\r\nif (!connector_list)\r\nreturn -ENOMEM;\r\nget_connectors_for_crtc(crtc, connector_list, num_connectors);\r\nset.connectors = connector_list;\r\nset.num_connectors = num_connectors;\r\nret = crtc->funcs->set_config(&set, ctx);\r\nkfree(connector_list);\r\nreturn ret;\r\n}\r\nint drm_primary_helper_disable(struct drm_plane *plane,\r\nstruct drm_modeset_acquire_ctx *ctx)\r\n{\r\nreturn -EINVAL;\r\n}\r\nvoid drm_primary_helper_destroy(struct drm_plane *plane)\r\n{\r\ndrm_plane_cleanup(plane);\r\nkfree(plane);\r\n}\r\nint drm_plane_helper_commit(struct drm_plane *plane,\r\nstruct drm_plane_state *plane_state,\r\nstruct drm_framebuffer *old_fb)\r\n{\r\nconst struct drm_plane_helper_funcs *plane_funcs;\r\nstruct drm_crtc *crtc[2];\r\nconst struct drm_crtc_helper_funcs *crtc_funcs[2];\r\nint i, ret = 0;\r\nplane_funcs = plane->helper_private;\r\ncrtc[0] = plane->crtc;\r\ncrtc[1] = crtc[0] != plane_state->crtc ? plane_state->crtc : NULL;\r\nfor (i = 0; i < 2; i++)\r\ncrtc_funcs[i] = crtc[i] ? crtc[i]->helper_private : NULL;\r\nif (plane_funcs->atomic_check) {\r\nret = plane_funcs->atomic_check(plane, plane_state);\r\nif (ret)\r\ngoto out;\r\n}\r\nif (plane_funcs->prepare_fb && plane_state->fb != old_fb) {\r\nret = plane_funcs->prepare_fb(plane,\r\nplane_state);\r\nif (ret)\r\ngoto out;\r\n}\r\nswap(plane->state, plane_state);\r\nfor (i = 0; i < 2; i++) {\r\nif (crtc_funcs[i] && crtc_funcs[i]->atomic_begin)\r\ncrtc_funcs[i]->atomic_begin(crtc[i], crtc[i]->state);\r\n}\r\nif (drm_atomic_plane_disabling(plane_state, plane->state) &&\r\nplane_funcs->atomic_disable)\r\nplane_funcs->atomic_disable(plane, plane_state);\r\nelse\r\nplane_funcs->atomic_update(plane, plane_state);\r\nfor (i = 0; i < 2; i++) {\r\nif (crtc_funcs[i] && crtc_funcs[i]->atomic_flush)\r\ncrtc_funcs[i]->atomic_flush(crtc[i], crtc[i]->state);\r\n}\r\nif (plane->state->fb == old_fb)\r\ngoto out;\r\nfor (i = 0; i < 2; i++) {\r\nif (!crtc[i])\r\ncontinue;\r\nif (crtc[i]->cursor == plane)\r\ncontinue;\r\nret = drm_crtc_vblank_get(crtc[i]);\r\nif (ret == 0) {\r\ndrm_crtc_wait_one_vblank(crtc[i]);\r\ndrm_crtc_vblank_put(crtc[i]);\r\n}\r\nret = 0;\r\n}\r\nif (plane_funcs->cleanup_fb)\r\nplane_funcs->cleanup_fb(plane, plane_state);\r\nout:\r\nif (plane->funcs->atomic_destroy_state)\r\nplane->funcs->atomic_destroy_state(plane, plane_state);\r\nelse\r\ndrm_atomic_helper_plane_destroy_state(plane, plane_state);\r\nreturn ret;\r\n}\r\nint drm_plane_helper_update(struct drm_plane *plane, struct drm_crtc *crtc,\r\nstruct drm_framebuffer *fb,\r\nint crtc_x, int crtc_y,\r\nunsigned int crtc_w, unsigned int crtc_h,\r\nuint32_t src_x, uint32_t src_y,\r\nuint32_t src_w, uint32_t src_h)\r\n{\r\nstruct drm_plane_state *plane_state;\r\nif (plane->funcs->atomic_duplicate_state)\r\nplane_state = plane->funcs->atomic_duplicate_state(plane);\r\nelse {\r\nif (!plane->state)\r\ndrm_atomic_helper_plane_reset(plane);\r\nplane_state = drm_atomic_helper_plane_duplicate_state(plane);\r\n}\r\nif (!plane_state)\r\nreturn -ENOMEM;\r\nplane_state->plane = plane;\r\nplane_state->crtc = crtc;\r\ndrm_atomic_set_fb_for_plane(plane_state, fb);\r\nplane_state->crtc_x = crtc_x;\r\nplane_state->crtc_y = crtc_y;\r\nplane_state->crtc_h = crtc_h;\r\nplane_state->crtc_w = crtc_w;\r\nplane_state->src_x = src_x;\r\nplane_state->src_y = src_y;\r\nplane_state->src_h = src_h;\r\nplane_state->src_w = src_w;\r\nreturn drm_plane_helper_commit(plane, plane_state, plane->fb);\r\n}\r\nint drm_plane_helper_disable(struct drm_plane *plane)\r\n{\r\nstruct drm_plane_state *plane_state;\r\nif (!plane->crtc)\r\nreturn 0;\r\nif (plane->funcs->atomic_duplicate_state)\r\nplane_state = plane->funcs->atomic_duplicate_state(plane);\r\nelse {\r\nif (!plane->state)\r\ndrm_atomic_helper_plane_reset(plane);\r\nplane_state = drm_atomic_helper_plane_duplicate_state(plane);\r\n}\r\nif (!plane_state)\r\nreturn -ENOMEM;\r\nplane_state->plane = plane;\r\nplane_state->crtc = NULL;\r\ndrm_atomic_set_fb_for_plane(plane_state, NULL);\r\nreturn drm_plane_helper_commit(plane, plane_state, plane->fb);\r\n}
