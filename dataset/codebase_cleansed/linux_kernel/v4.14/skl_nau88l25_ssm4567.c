static inline struct snd_soc_dai *skl_get_codec_dai(struct snd_soc_card *card)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd;\r\nlist_for_each_entry(rtd, &card->rtd_list, list) {\r\nif (!strncmp(rtd->codec_dai->name, SKL_NUVOTON_CODEC_DAI,\r\nstrlen(SKL_NUVOTON_CODEC_DAI)))\r\nreturn rtd->codec_dai;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int platform_clock_control(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *k, int event)\r\n{\r\nstruct snd_soc_dapm_context *dapm = w->dapm;\r\nstruct snd_soc_card *card = dapm->card;\r\nstruct snd_soc_dai *codec_dai;\r\nint ret;\r\ncodec_dai = skl_get_codec_dai(card);\r\nif (!codec_dai) {\r\ndev_err(card->dev, "Codec dai not found\n");\r\nreturn -EIO;\r\n}\r\nif (SND_SOC_DAPM_EVENT_ON(event)) {\r\nret = snd_soc_dai_set_sysclk(codec_dai,\r\nNAU8825_CLK_MCLK, 24000000, SND_SOC_CLOCK_IN);\r\nif (ret < 0) {\r\ndev_err(card->dev, "set sysclk err = %d\n", ret);\r\nreturn -EIO;\r\n}\r\n} else {\r\nret = snd_soc_dai_set_sysclk(codec_dai,\r\nNAU8825_CLK_INTERNAL, 0, SND_SOC_CLOCK_IN);\r\nif (ret < 0) {\r\ndev_err(card->dev, "set sysclk err = %d\n", ret);\r\nreturn -EIO;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int skylake_ssm4567_codec_init(struct snd_soc_pcm_runtime *rtd)\r\n{\r\nint ret;\r\nret = snd_soc_dai_set_tdm_slot(rtd->codec_dais[0], 0x01, 0x01, 2, 48);\r\nif (ret < 0)\r\nreturn ret;\r\nret = snd_soc_dai_set_tdm_slot(rtd->codec_dais[1], 0x02, 0x02, 2, 48);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn ret;\r\n}\r\nstatic int skylake_nau8825_codec_init(struct snd_soc_pcm_runtime *rtd)\r\n{\r\nint ret;\r\nstruct snd_soc_codec *codec = rtd->codec;\r\nret = snd_soc_card_jack_new(&skylake_audio_card, "Headset Jack",\r\nSND_JACK_HEADSET | SND_JACK_BTN_0 | SND_JACK_BTN_1 |\r\nSND_JACK_BTN_2 | SND_JACK_BTN_3, &skylake_headset,\r\nNULL, 0);\r\nif (ret) {\r\ndev_err(rtd->dev, "Headset Jack creation failed %d\n", ret);\r\nreturn ret;\r\n}\r\nnau8825_enable_jack_detect(codec, &skylake_headset);\r\nsnd_soc_dapm_ignore_suspend(&rtd->card->dapm, "SoC DMIC");\r\nreturn ret;\r\n}\r\nstatic int skylake_hdmi1_init(struct snd_soc_pcm_runtime *rtd)\r\n{\r\nstruct skl_nau88125_private *ctx = snd_soc_card_get_drvdata(rtd->card);\r\nstruct snd_soc_dai *dai = rtd->codec_dai;\r\nstruct skl_hdmi_pcm *pcm;\r\npcm = devm_kzalloc(rtd->card->dev, sizeof(*pcm), GFP_KERNEL);\r\nif (!pcm)\r\nreturn -ENOMEM;\r\npcm->device = SKL_DPCM_AUDIO_HDMI1_PB;\r\npcm->codec_dai = dai;\r\nlist_add_tail(&pcm->head, &ctx->hdmi_pcm_list);\r\nreturn 0;\r\n}\r\nstatic int skylake_hdmi2_init(struct snd_soc_pcm_runtime *rtd)\r\n{\r\nstruct skl_nau88125_private *ctx = snd_soc_card_get_drvdata(rtd->card);\r\nstruct snd_soc_dai *dai = rtd->codec_dai;\r\nstruct skl_hdmi_pcm *pcm;\r\npcm = devm_kzalloc(rtd->card->dev, sizeof(*pcm), GFP_KERNEL);\r\nif (!pcm)\r\nreturn -ENOMEM;\r\npcm->device = SKL_DPCM_AUDIO_HDMI2_PB;\r\npcm->codec_dai = dai;\r\nlist_add_tail(&pcm->head, &ctx->hdmi_pcm_list);\r\nreturn 0;\r\n}\r\nstatic int skylake_hdmi3_init(struct snd_soc_pcm_runtime *rtd)\r\n{\r\nstruct skl_nau88125_private *ctx = snd_soc_card_get_drvdata(rtd->card);\r\nstruct snd_soc_dai *dai = rtd->codec_dai;\r\nstruct skl_hdmi_pcm *pcm;\r\npcm = devm_kzalloc(rtd->card->dev, sizeof(*pcm), GFP_KERNEL);\r\nif (!pcm)\r\nreturn -ENOMEM;\r\npcm->device = SKL_DPCM_AUDIO_HDMI3_PB;\r\npcm->codec_dai = dai;\r\nlist_add_tail(&pcm->head, &ctx->hdmi_pcm_list);\r\nreturn 0;\r\n}\r\nstatic int skylake_nau8825_fe_init(struct snd_soc_pcm_runtime *rtd)\r\n{\r\nstruct snd_soc_dapm_context *dapm;\r\nstruct snd_soc_component *component = rtd->cpu_dai->component;\r\ndapm = snd_soc_component_get_dapm(component);\r\nsnd_soc_dapm_ignore_suspend(dapm, "Reference Capture");\r\nreturn 0;\r\n}\r\nstatic int skl_fe_startup(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nruntime->hw.channels_max = 2;\r\nsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\r\n&constraints_channels);\r\nruntime->hw.formats = SNDRV_PCM_FMTBIT_S16_LE;\r\nsnd_pcm_hw_constraint_msbits(runtime, 0, 16, 16);\r\nsnd_pcm_hw_constraint_list(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_RATE, &constraints_rates);\r\nreturn 0;\r\n}\r\nstatic int skylake_ssp_fixup(struct snd_soc_pcm_runtime *rtd,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct snd_interval *rate = hw_param_interval(params,\r\nSNDRV_PCM_HW_PARAM_RATE);\r\nstruct snd_interval *channels = hw_param_interval(params,\r\nSNDRV_PCM_HW_PARAM_CHANNELS);\r\nstruct snd_mask *fmt = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);\r\nrate->min = rate->max = 48000;\r\nchannels->min = channels->max = 2;\r\nsnd_mask_none(fmt);\r\nsnd_mask_set(fmt, SNDRV_PCM_FORMAT_S24_LE);\r\nreturn 0;\r\n}\r\nstatic int skylake_dmic_fixup(struct snd_soc_pcm_runtime *rtd,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct snd_interval *channels = hw_param_interval(params,\r\nSNDRV_PCM_HW_PARAM_CHANNELS);\r\nif (params_channels(params) == 2 || DMIC_CH(dmic_constraints) == 2)\r\nchannels->min = channels->max = 2;\r\nelse\r\nchannels->min = channels->max = 4;\r\nreturn 0;\r\n}\r\nstatic int skylake_nau8825_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_dai *codec_dai = rtd->codec_dai;\r\nint ret;\r\nret = snd_soc_dai_set_sysclk(codec_dai,\r\nNAU8825_CLK_MCLK, 24000000, SND_SOC_CLOCK_IN);\r\nif (ret < 0)\r\ndev_err(rtd->dev, "snd_soc_dai_set_sysclk err = %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int skylake_dmic_startup(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nruntime->hw.channels_max = DMIC_CH(dmic_constraints);\r\nsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\r\ndmic_constraints);\r\nreturn snd_pcm_hw_constraint_list(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_RATE, &constraints_rates);\r\n}\r\nstatic int skylake_refcap_startup(struct snd_pcm_substream *substream)\r\n{\r\nsubstream->runtime->hw.channels_max = 1;\r\nsnd_pcm_hw_constraint_list(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_CHANNELS,\r\n&constraints_refcap);\r\nreturn snd_pcm_hw_constraint_list(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_RATE,\r\n&constraints_16000);\r\n}\r\nstatic int skylake_card_late_probe(struct snd_soc_card *card)\r\n{\r\nstruct skl_nau88125_private *ctx = snd_soc_card_get_drvdata(card);\r\nstruct skl_hdmi_pcm *pcm;\r\nstruct snd_soc_codec *codec = NULL;\r\nint err, i = 0;\r\nchar jack_name[NAME_SIZE];\r\nlist_for_each_entry(pcm, &ctx->hdmi_pcm_list, head) {\r\ncodec = pcm->codec_dai->codec;\r\nsnprintf(jack_name, sizeof(jack_name),\r\n"HDMI/DP, pcm=%d Jack", pcm->device);\r\nerr = snd_soc_card_jack_new(card, jack_name,\r\nSND_JACK_AVOUT,\r\n&skylake_hdmi[i],\r\nNULL, 0);\r\nif (err)\r\nreturn err;\r\nerr = hdac_hdmi_jack_init(pcm->codec_dai, pcm->device,\r\n&skylake_hdmi[i]);\r\nif (err < 0)\r\nreturn err;\r\ni++;\r\n}\r\nif (!codec)\r\nreturn -EINVAL;\r\nreturn hdac_hdmi_jack_port_init(codec, &card->dapm);\r\n}\r\nstatic int skylake_audio_probe(struct platform_device *pdev)\r\n{\r\nstruct skl_nau88125_private *ctx;\r\nstruct skl_machine_pdata *pdata;\r\nctx = devm_kzalloc(&pdev->dev, sizeof(*ctx), GFP_ATOMIC);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&ctx->hdmi_pcm_list);\r\nskylake_audio_card.dev = &pdev->dev;\r\nsnd_soc_card_set_drvdata(&skylake_audio_card, ctx);\r\npdata = dev_get_drvdata(&pdev->dev);\r\nif (pdata)\r\ndmic_constraints = pdata->dmic_num == 2 ?\r\n&constraints_dmic_2ch : &constraints_dmic_channels;\r\nreturn devm_snd_soc_register_card(&pdev->dev, &skylake_audio_card);\r\n}
