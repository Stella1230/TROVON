int cxd2820r_wr_reg_val_mask_tab(struct cxd2820r_priv *priv,\r\nconst struct reg_val_mask *tab, int tab_len)\r\n{\r\nstruct i2c_client *client = priv->client[0];\r\nint ret;\r\nunsigned int i, reg, mask, val;\r\nstruct regmap *regmap;\r\ndev_dbg(&client->dev, "tab_len=%d\n", tab_len);\r\nfor (i = 0; i < tab_len; i++) {\r\nif ((tab[i].reg >> 16) & 0x1)\r\nregmap = priv->regmap[1];\r\nelse\r\nregmap = priv->regmap[0];\r\nreg = (tab[i].reg >> 0) & 0xffff;\r\nval = tab[i].val;\r\nmask = tab[i].mask;\r\nif (mask == 0xff)\r\nret = regmap_write(regmap, reg, val);\r\nelse\r\nret = regmap_write_bits(regmap, reg, mask, val);\r\nif (ret)\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nint cxd2820r_gpio(struct dvb_frontend *fe, u8 *gpio)\r\n{\r\nstruct cxd2820r_priv *priv = fe->demodulator_priv;\r\nstruct i2c_client *client = priv->client[0];\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret, i;\r\nu8 tmp0, tmp1;\r\ndev_dbg(&client->dev, "delivery_system=%d\n", c->delivery_system);\r\nif (!memcmp(gpio, priv->gpio, sizeof(priv->gpio)))\r\nreturn 0;\r\ntmp0 = 0x00;\r\ntmp1 = 0x00;\r\nfor (i = 0; i < sizeof(priv->gpio); i++) {\r\nif (gpio[i] & CXD2820R_GPIO_E)\r\ntmp0 |= (2 << 6) >> (2 * i);\r\nelse\r\ntmp0 |= (1 << 6) >> (2 * i);\r\nif (gpio[i] & CXD2820R_GPIO_I)\r\ntmp1 |= (1 << (3 + i));\r\nelse\r\ntmp1 |= (0 << (3 + i));\r\nif (gpio[i] & CXD2820R_GPIO_H)\r\ntmp1 |= (1 << (0 + i));\r\nelse\r\ntmp1 |= (0 << (0 + i));\r\ndev_dbg(&client->dev, "gpio i=%d %02x %02x\n", i, tmp0, tmp1);\r\n}\r\ndev_dbg(&client->dev, "wr gpio=%02x %02x\n", tmp0, tmp1);\r\nret = regmap_update_bits(priv->regmap[0], 0x0089, 0xfc, tmp0);\r\nif (ret)\r\ngoto error;\r\nret = regmap_update_bits(priv->regmap[0], 0x008e, 0x3f, tmp1);\r\nif (ret)\r\ngoto error;\r\nmemcpy(priv->gpio, gpio, sizeof(priv->gpio));\r\nreturn ret;\r\nerror:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int cxd2820r_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct cxd2820r_priv *priv = fe->demodulator_priv;\r\nstruct i2c_client *client = priv->client[0];\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret;\r\ndev_dbg(&client->dev, "delivery_system=%d\n", c->delivery_system);\r\nswitch (c->delivery_system) {\r\ncase SYS_DVBT:\r\nret = cxd2820r_init_t(fe);\r\nif (ret < 0)\r\ngoto err;\r\nret = cxd2820r_set_frontend_t(fe);\r\nif (ret < 0)\r\ngoto err;\r\nbreak;\r\ncase SYS_DVBT2:\r\nret = cxd2820r_init_t(fe);\r\nif (ret < 0)\r\ngoto err;\r\nret = cxd2820r_set_frontend_t2(fe);\r\nif (ret < 0)\r\ngoto err;\r\nbreak;\r\ncase SYS_DVBC_ANNEX_A:\r\nret = cxd2820r_init_c(fe);\r\nif (ret < 0)\r\ngoto err;\r\nret = cxd2820r_set_frontend_c(fe);\r\nif (ret < 0)\r\ngoto err;\r\nbreak;\r\ndefault:\r\ndev_dbg(&client->dev, "invalid delivery_system\n");\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int cxd2820r_read_status(struct dvb_frontend *fe, enum fe_status *status)\r\n{\r\nstruct cxd2820r_priv *priv = fe->demodulator_priv;\r\nstruct i2c_client *client = priv->client[0];\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret;\r\ndev_dbg(&client->dev, "delivery_system=%d\n", c->delivery_system);\r\nswitch (c->delivery_system) {\r\ncase SYS_DVBT:\r\nret = cxd2820r_read_status_t(fe, status);\r\nbreak;\r\ncase SYS_DVBT2:\r\nret = cxd2820r_read_status_t2(fe, status);\r\nbreak;\r\ncase SYS_DVBC_ANNEX_A:\r\nret = cxd2820r_read_status_c(fe, status);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int cxd2820r_get_frontend(struct dvb_frontend *fe,\r\nstruct dtv_frontend_properties *p)\r\n{\r\nstruct cxd2820r_priv *priv = fe->demodulator_priv;\r\nstruct i2c_client *client = priv->client[0];\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret;\r\ndev_dbg(&client->dev, "delivery_system=%d\n", c->delivery_system);\r\nif (priv->delivery_system == SYS_UNDEFINED)\r\nreturn 0;\r\nswitch (c->delivery_system) {\r\ncase SYS_DVBT:\r\nret = cxd2820r_get_frontend_t(fe, p);\r\nbreak;\r\ncase SYS_DVBT2:\r\nret = cxd2820r_get_frontend_t2(fe, p);\r\nbreak;\r\ncase SYS_DVBC_ANNEX_A:\r\nret = cxd2820r_get_frontend_c(fe, p);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int cxd2820r_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nstruct cxd2820r_priv *priv = fe->demodulator_priv;\r\nstruct i2c_client *client = priv->client[0];\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\ndev_dbg(&client->dev, "delivery_system=%d\n", c->delivery_system);\r\n*ber = (priv->post_bit_error - priv->post_bit_error_prev_dvbv3);\r\npriv->post_bit_error_prev_dvbv3 = priv->post_bit_error;\r\nreturn 0;\r\n}\r\nstatic int cxd2820r_read_signal_strength(struct dvb_frontend *fe, u16 *strength)\r\n{\r\nstruct cxd2820r_priv *priv = fe->demodulator_priv;\r\nstruct i2c_client *client = priv->client[0];\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\ndev_dbg(&client->dev, "delivery_system=%d\n", c->delivery_system);\r\nif (c->strength.stat[0].scale == FE_SCALE_RELATIVE)\r\n*strength = c->strength.stat[0].uvalue;\r\nelse\r\n*strength = 0;\r\nreturn 0;\r\n}\r\nstatic int cxd2820r_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nstruct cxd2820r_priv *priv = fe->demodulator_priv;\r\nstruct i2c_client *client = priv->client[0];\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\ndev_dbg(&client->dev, "delivery_system=%d\n", c->delivery_system);\r\nif (c->cnr.stat[0].scale == FE_SCALE_DECIBEL)\r\n*snr = div_s64(c->cnr.stat[0].svalue, 100);\r\nelse\r\n*snr = 0;\r\nreturn 0;\r\n}\r\nstatic int cxd2820r_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\r\n{\r\nstruct cxd2820r_priv *priv = fe->demodulator_priv;\r\nstruct i2c_client *client = priv->client[0];\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\ndev_dbg(&client->dev, "delivery_system=%d\n", c->delivery_system);\r\n*ucblocks = 0;\r\nreturn 0;\r\n}\r\nstatic int cxd2820r_init(struct dvb_frontend *fe)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cxd2820r_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct cxd2820r_priv *priv = fe->demodulator_priv;\r\nstruct i2c_client *client = priv->client[0];\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret;\r\ndev_dbg(&client->dev, "delivery_system=%d\n", c->delivery_system);\r\nswitch (c->delivery_system) {\r\ncase SYS_DVBT:\r\nret = cxd2820r_sleep_t(fe);\r\nbreak;\r\ncase SYS_DVBT2:\r\nret = cxd2820r_sleep_t2(fe);\r\nbreak;\r\ncase SYS_DVBC_ANNEX_A:\r\nret = cxd2820r_sleep_c(fe);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int cxd2820r_get_tune_settings(struct dvb_frontend *fe,\r\nstruct dvb_frontend_tune_settings *s)\r\n{\r\nstruct cxd2820r_priv *priv = fe->demodulator_priv;\r\nstruct i2c_client *client = priv->client[0];\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret;\r\ndev_dbg(&client->dev, "delivery_system=%d\n", c->delivery_system);\r\nswitch (c->delivery_system) {\r\ncase SYS_DVBT:\r\nret = cxd2820r_get_tune_settings_t(fe, s);\r\nbreak;\r\ncase SYS_DVBT2:\r\nret = cxd2820r_get_tune_settings_t2(fe, s);\r\nbreak;\r\ncase SYS_DVBC_ANNEX_A:\r\nret = cxd2820r_get_tune_settings_c(fe, s);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic enum dvbfe_search cxd2820r_search(struct dvb_frontend *fe)\r\n{\r\nstruct cxd2820r_priv *priv = fe->demodulator_priv;\r\nstruct i2c_client *client = priv->client[0];\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret, i;\r\nenum fe_status status = 0;\r\ndev_dbg(&client->dev, "delivery_system=%d\n", c->delivery_system);\r\nif (priv->last_tune_failed) {\r\nif (priv->delivery_system == SYS_DVBT) {\r\nret = cxd2820r_sleep_t(fe);\r\nif (ret)\r\ngoto error;\r\nc->delivery_system = SYS_DVBT2;\r\n} else if (priv->delivery_system == SYS_DVBT2) {\r\nret = cxd2820r_sleep_t2(fe);\r\nif (ret)\r\ngoto error;\r\nc->delivery_system = SYS_DVBT;\r\n}\r\n}\r\nret = cxd2820r_set_frontend(fe);\r\nif (ret)\r\ngoto error;\r\nswitch (priv->delivery_system) {\r\ncase SYS_DVBT:\r\ncase SYS_DVBC_ANNEX_A:\r\ni = 20;\r\nbreak;\r\ncase SYS_DVBT2:\r\ni = 40;\r\nbreak;\r\ncase SYS_UNDEFINED:\r\ndefault:\r\ni = 0;\r\nbreak;\r\n}\r\nfor (; i > 0; i--) {\r\ndev_dbg(&client->dev, "loop=%d\n", i);\r\nmsleep(50);\r\nret = cxd2820r_read_status(fe, &status);\r\nif (ret)\r\ngoto error;\r\nif (status & FE_HAS_LOCK)\r\nbreak;\r\n}\r\nif (status & FE_HAS_LOCK) {\r\npriv->last_tune_failed = false;\r\nreturn DVBFE_ALGO_SEARCH_SUCCESS;\r\n} else {\r\npriv->last_tune_failed = true;\r\nreturn DVBFE_ALGO_SEARCH_AGAIN;\r\n}\r\nerror:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn DVBFE_ALGO_SEARCH_ERROR;\r\n}\r\nstatic int cxd2820r_get_frontend_algo(struct dvb_frontend *fe)\r\n{\r\nreturn DVBFE_ALGO_CUSTOM;\r\n}\r\nstatic void cxd2820r_release(struct dvb_frontend *fe)\r\n{\r\nstruct cxd2820r_priv *priv = fe->demodulator_priv;\r\nstruct i2c_client *client = priv->client[0];\r\ndev_dbg(&client->dev, "\n");\r\ni2c_unregister_device(client);\r\nreturn;\r\n}\r\nstatic int cxd2820r_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\r\n{\r\nstruct cxd2820r_priv *priv = fe->demodulator_priv;\r\nstruct i2c_client *client = priv->client[0];\r\ndev_dbg_ratelimited(&client->dev, "enable=%d\n", enable);\r\nreturn regmap_update_bits(priv->regmap[0], 0x00db, 0x01, enable ? 1 : 0);\r\n}\r\nstatic int cxd2820r_gpio_direction_output(struct gpio_chip *chip, unsigned nr,\r\nint val)\r\n{\r\nstruct cxd2820r_priv *priv = gpiochip_get_data(chip);\r\nstruct i2c_client *client = priv->client[0];\r\nu8 gpio[GPIO_COUNT];\r\ndev_dbg(&client->dev, "nr=%u val=%d\n", nr, val);\r\nmemcpy(gpio, priv->gpio, sizeof(gpio));\r\ngpio[nr] = CXD2820R_GPIO_E | CXD2820R_GPIO_O | (val << 2);\r\nreturn cxd2820r_gpio(&priv->fe, gpio);\r\n}\r\nstatic void cxd2820r_gpio_set(struct gpio_chip *chip, unsigned nr, int val)\r\n{\r\nstruct cxd2820r_priv *priv = gpiochip_get_data(chip);\r\nstruct i2c_client *client = priv->client[0];\r\nu8 gpio[GPIO_COUNT];\r\ndev_dbg(&client->dev, "nr=%u val=%d\n", nr, val);\r\nmemcpy(gpio, priv->gpio, sizeof(gpio));\r\ngpio[nr] = CXD2820R_GPIO_E | CXD2820R_GPIO_O | (val << 2);\r\n(void) cxd2820r_gpio(&priv->fe, gpio);\r\nreturn;\r\n}\r\nstatic int cxd2820r_gpio_get(struct gpio_chip *chip, unsigned nr)\r\n{\r\nstruct cxd2820r_priv *priv = gpiochip_get_data(chip);\r\nstruct i2c_client *client = priv->client[0];\r\ndev_dbg(&client->dev, "nr=%u\n", nr);\r\nreturn (priv->gpio[nr] >> 2) & 0x01;\r\n}\r\nstruct dvb_frontend *cxd2820r_attach(const struct cxd2820r_config *config,\r\nstruct i2c_adapter *adapter,\r\nint *gpio_chip_base)\r\n{\r\nstruct i2c_client *client;\r\nstruct i2c_board_info board_info;\r\nstruct cxd2820r_platform_data pdata;\r\npdata.ts_mode = config->ts_mode;\r\npdata.ts_clk_inv = config->ts_clock_inv;\r\npdata.if_agc_polarity = config->if_agc_polarity;\r\npdata.spec_inv = config->spec_inv;\r\npdata.gpio_chip_base = &gpio_chip_base;\r\npdata.attach_in_use = true;\r\nmemset(&board_info, 0, sizeof(board_info));\r\nstrlcpy(board_info.type, "cxd2820r", I2C_NAME_SIZE);\r\nboard_info.addr = config->i2c_address;\r\nboard_info.platform_data = &pdata;\r\nclient = i2c_new_device(adapter, &board_info);\r\nif (!client || !client->dev.driver)\r\nreturn NULL;\r\nreturn pdata.get_dvb_frontend(client);\r\n}\r\nstatic struct dvb_frontend *cxd2820r_get_dvb_frontend(struct i2c_client *client)\r\n{\r\nstruct cxd2820r_priv *priv = i2c_get_clientdata(client);\r\ndev_dbg(&client->dev, "\n");\r\nreturn &priv->fe;\r\n}\r\nstatic int cxd2820r_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct cxd2820r_platform_data *pdata = client->dev.platform_data;\r\nstruct cxd2820r_priv *priv;\r\nint ret, *gpio_chip_base;\r\nunsigned int utmp;\r\nstatic const struct regmap_range_cfg regmap_range_cfg0[] = {\r\n{\r\n.range_min = 0x0000,\r\n.range_max = 0x3fff,\r\n.selector_reg = 0x00,\r\n.selector_mask = 0xff,\r\n.selector_shift = 0,\r\n.window_start = 0x00,\r\n.window_len = 0x100,\r\n},\r\n};\r\nstatic const struct regmap_range_cfg regmap_range_cfg1[] = {\r\n{\r\n.range_min = 0x0000,\r\n.range_max = 0x01ff,\r\n.selector_reg = 0x00,\r\n.selector_mask = 0xff,\r\n.selector_shift = 0,\r\n.window_start = 0x00,\r\n.window_len = 0x100,\r\n},\r\n};\r\nstatic const struct regmap_config regmap_config0 = {\r\n.reg_bits = 8,\r\n.val_bits = 8,\r\n.max_register = 0x3fff,\r\n.ranges = regmap_range_cfg0,\r\n.num_ranges = ARRAY_SIZE(regmap_range_cfg0),\r\n.cache_type = REGCACHE_NONE,\r\n};\r\nstatic const struct regmap_config regmap_config1 = {\r\n.reg_bits = 8,\r\n.val_bits = 8,\r\n.max_register = 0x01ff,\r\n.ranges = regmap_range_cfg1,\r\n.num_ranges = ARRAY_SIZE(regmap_range_cfg1),\r\n.cache_type = REGCACHE_NONE,\r\n};\r\ndev_dbg(&client->dev, "\n");\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\npriv->client[0] = client;\r\npriv->fe.demodulator_priv = priv;\r\npriv->i2c = client->adapter;\r\npriv->ts_mode = pdata->ts_mode;\r\npriv->ts_clk_inv = pdata->ts_clk_inv;\r\npriv->if_agc_polarity = pdata->if_agc_polarity;\r\npriv->spec_inv = pdata->spec_inv;\r\ngpio_chip_base = *pdata->gpio_chip_base;\r\npriv->regmap[0] = regmap_init_i2c(priv->client[0], &regmap_config0);\r\nif (IS_ERR(priv->regmap[0])) {\r\nret = PTR_ERR(priv->regmap[0]);\r\ngoto err_kfree;\r\n}\r\nret = regmap_read(priv->regmap[0], 0x00fd, &utmp);\r\nif (ret)\r\ngoto err_regmap_0_regmap_exit;\r\ndev_dbg(&client->dev, "chip_id=%02x\n", utmp);\r\nif (utmp != 0xe1) {\r\nret = -ENODEV;\r\ngoto err_regmap_0_regmap_exit;\r\n}\r\npriv->client[1] = i2c_new_dummy(client->adapter, client->addr | (1 << 1));\r\nif (!priv->client[1]) {\r\nret = -ENODEV;\r\ndev_err(&client->dev, "I2C registration failed\n");\r\nif (ret)\r\ngoto err_regmap_0_regmap_exit;\r\n}\r\npriv->regmap[1] = regmap_init_i2c(priv->client[1], &regmap_config1);\r\nif (IS_ERR(priv->regmap[1])) {\r\nret = PTR_ERR(priv->regmap[1]);\r\ngoto err_client_1_i2c_unregister_device;\r\n}\r\nif (gpio_chip_base) {\r\n#ifdef CONFIG_GPIOLIB\r\npriv->gpio_chip.label = KBUILD_MODNAME;\r\npriv->gpio_chip.parent = &client->dev;\r\npriv->gpio_chip.owner = THIS_MODULE;\r\npriv->gpio_chip.direction_output = cxd2820r_gpio_direction_output;\r\npriv->gpio_chip.set = cxd2820r_gpio_set;\r\npriv->gpio_chip.get = cxd2820r_gpio_get;\r\npriv->gpio_chip.base = -1;\r\npriv->gpio_chip.ngpio = GPIO_COUNT;\r\npriv->gpio_chip.can_sleep = 1;\r\nret = gpiochip_add_data(&priv->gpio_chip, priv);\r\nif (ret)\r\ngoto err_regmap_1_regmap_exit;\r\ndev_dbg(&client->dev, "gpio_chip.base=%d\n",\r\npriv->gpio_chip.base);\r\n*gpio_chip_base = priv->gpio_chip.base;\r\n#else\r\nu8 gpio[GPIO_COUNT];\r\ngpio[0] = (*gpio_chip_base >> 0) & 0x07;\r\ngpio[1] = (*gpio_chip_base >> 3) & 0x07;\r\ngpio[2] = 0;\r\nret = cxd2820r_gpio(&priv->fe, gpio);\r\nif (ret)\r\ngoto err_regmap_1_regmap_exit;\r\n#endif\r\n}\r\nmemcpy(&priv->fe.ops, &cxd2820r_ops, sizeof(priv->fe.ops));\r\nif (!pdata->attach_in_use)\r\npriv->fe.ops.release = NULL;\r\ni2c_set_clientdata(client, priv);\r\npdata->get_dvb_frontend = cxd2820r_get_dvb_frontend;\r\ndev_info(&client->dev, "Sony CXD2820R successfully identified\n");\r\nreturn 0;\r\nerr_regmap_1_regmap_exit:\r\nregmap_exit(priv->regmap[1]);\r\nerr_client_1_i2c_unregister_device:\r\ni2c_unregister_device(priv->client[1]);\r\nerr_regmap_0_regmap_exit:\r\nregmap_exit(priv->regmap[0]);\r\nerr_kfree:\r\nkfree(priv);\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int cxd2820r_remove(struct i2c_client *client)\r\n{\r\nstruct cxd2820r_priv *priv = i2c_get_clientdata(client);\r\ndev_dbg(&client->dev, "\n");\r\n#ifdef CONFIG_GPIOLIB\r\nif (priv->gpio_chip.label)\r\ngpiochip_remove(&priv->gpio_chip);\r\n#endif\r\nregmap_exit(priv->regmap[1]);\r\ni2c_unregister_device(priv->client[1]);\r\nregmap_exit(priv->regmap[0]);\r\nkfree(priv);\r\nreturn 0;\r\n}
