static bool is_extended_socket_device(struct acpi_device *device)\r\n{\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL};\r\nchar str_buf[sizeof(FJES_ACPI_SYMBOL) + 1];\r\nunion acpi_object *str;\r\nacpi_status status;\r\nint result;\r\nstatus = acpi_evaluate_object(device->handle, "_STR", NULL, &buffer);\r\nif (ACPI_FAILURE(status))\r\nreturn false;\r\nstr = buffer.pointer;\r\nresult = utf16s_to_utf8s((wchar_t *)str->string.pointer,\r\nstr->string.length, UTF16_LITTLE_ENDIAN,\r\nstr_buf, sizeof(str_buf) - 1);\r\nstr_buf[result] = 0;\r\nif (strncmp(FJES_ACPI_SYMBOL, str_buf, strlen(FJES_ACPI_SYMBOL)) != 0) {\r\nkfree(buffer.pointer);\r\nreturn false;\r\n}\r\nkfree(buffer.pointer);\r\nreturn true;\r\n}\r\nstatic int acpi_check_extended_socket_status(struct acpi_device *device)\r\n{\r\nunsigned long long sta;\r\nacpi_status status;\r\nstatus = acpi_evaluate_integer(device->handle, "_STA", NULL, &sta);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENODEV;\r\nif (!((sta & ACPI_STA_DEVICE_PRESENT) &&\r\n(sta & ACPI_STA_DEVICE_ENABLED) &&\r\n(sta & ACPI_STA_DEVICE_UI) &&\r\n(sta & ACPI_STA_DEVICE_FUNCTIONING)))\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int fjes_acpi_add(struct acpi_device *device)\r\n{\r\nstruct platform_device *plat_dev;\r\nacpi_status status;\r\nif (!is_extended_socket_device(device))\r\nreturn -ENODEV;\r\nif (acpi_check_extended_socket_status(device))\r\nreturn -ENODEV;\r\nstatus = acpi_walk_resources(device->handle, METHOD_NAME__CRS,\r\nfjes_get_acpi_resource, fjes_resource);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENODEV;\r\nplat_dev = platform_device_register_simple(DRV_NAME, 0, fjes_resource,\r\nARRAY_SIZE(fjes_resource));\r\ndevice->driver_data = plat_dev;\r\nreturn 0;\r\n}\r\nstatic int fjes_acpi_remove(struct acpi_device *device)\r\n{\r\nstruct platform_device *plat_dev;\r\nplat_dev = (struct platform_device *)acpi_driver_data(device);\r\nplatform_device_unregister(plat_dev);\r\nreturn 0;\r\n}\r\nstatic acpi_status\r\nfjes_get_acpi_resource(struct acpi_resource *acpi_res, void *data)\r\n{\r\nstruct acpi_resource_address32 *addr;\r\nstruct acpi_resource_irq *irq;\r\nstruct resource *res = data;\r\nswitch (acpi_res->type) {\r\ncase ACPI_RESOURCE_TYPE_ADDRESS32:\r\naddr = &acpi_res->data.address32;\r\nres[0].start = addr->address.minimum;\r\nres[0].end = addr->address.minimum +\r\naddr->address.address_length - 1;\r\nbreak;\r\ncase ACPI_RESOURCE_TYPE_IRQ:\r\nirq = &acpi_res->data.irq;\r\nif (irq->interrupt_count != 1)\r\nreturn AE_ERROR;\r\nres[1].start = irq->interrupts[0];\r\nres[1].end = irq->interrupts[0];\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn AE_OK;\r\n}\r\nstatic int fjes_request_irq(struct fjes_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nint result = -1;\r\nadapter->interrupt_watch_enable = true;\r\nif (!delayed_work_pending(&adapter->interrupt_watch_task)) {\r\nqueue_delayed_work(adapter->control_wq,\r\n&adapter->interrupt_watch_task,\r\nFJES_IRQ_WATCH_DELAY);\r\n}\r\nif (!adapter->irq_registered) {\r\nresult = request_irq(adapter->hw.hw_res.irq, fjes_intr,\r\nIRQF_SHARED, netdev->name, adapter);\r\nif (result)\r\nadapter->irq_registered = false;\r\nelse\r\nadapter->irq_registered = true;\r\n}\r\nreturn result;\r\n}\r\nstatic void fjes_free_irq(struct fjes_adapter *adapter)\r\n{\r\nstruct fjes_hw *hw = &adapter->hw;\r\nadapter->interrupt_watch_enable = false;\r\ncancel_delayed_work_sync(&adapter->interrupt_watch_task);\r\nfjes_hw_set_irqmask(hw, REG_ICTL_MASK_ALL, true);\r\nif (adapter->irq_registered) {\r\nfree_irq(adapter->hw.hw_res.irq, adapter);\r\nadapter->irq_registered = false;\r\n}\r\n}\r\nstatic int fjes_open(struct net_device *netdev)\r\n{\r\nstruct fjes_adapter *adapter = netdev_priv(netdev);\r\nstruct fjes_hw *hw = &adapter->hw;\r\nint result;\r\nif (adapter->open_guard)\r\nreturn -ENXIO;\r\nresult = fjes_setup_resources(adapter);\r\nif (result)\r\ngoto err_setup_res;\r\nhw->txrx_stop_req_bit = 0;\r\nhw->epstop_req_bit = 0;\r\nnapi_enable(&adapter->napi);\r\nfjes_hw_capture_interrupt_status(hw);\r\nresult = fjes_request_irq(adapter);\r\nif (result)\r\ngoto err_req_irq;\r\nfjes_hw_set_irqmask(hw, REG_ICTL_MASK_ALL, false);\r\nnetif_tx_start_all_queues(netdev);\r\nnetif_carrier_on(netdev);\r\nreturn 0;\r\nerr_req_irq:\r\nfjes_free_irq(adapter);\r\nnapi_disable(&adapter->napi);\r\nerr_setup_res:\r\nfjes_free_resources(adapter);\r\nreturn result;\r\n}\r\nstatic int fjes_close(struct net_device *netdev)\r\n{\r\nstruct fjes_adapter *adapter = netdev_priv(netdev);\r\nstruct fjes_hw *hw = &adapter->hw;\r\nunsigned long flags;\r\nint epidx;\r\nnetif_tx_stop_all_queues(netdev);\r\nnetif_carrier_off(netdev);\r\nfjes_hw_raise_epstop(hw);\r\nnapi_disable(&adapter->napi);\r\nspin_lock_irqsave(&hw->rx_status_lock, flags);\r\nfor (epidx = 0; epidx < hw->max_epid; epidx++) {\r\nif (epidx == hw->my_epid)\r\ncontinue;\r\nif (fjes_hw_get_partner_ep_status(hw, epidx) ==\r\nEP_PARTNER_SHARED)\r\nadapter->hw.ep_shm_info[epidx]\r\n.tx.info->v1i.rx_status &=\r\n~FJES_RX_POLL_WORK;\r\n}\r\nspin_unlock_irqrestore(&hw->rx_status_lock, flags);\r\nfjes_free_irq(adapter);\r\ncancel_delayed_work_sync(&adapter->interrupt_watch_task);\r\ncancel_work_sync(&adapter->unshare_watch_task);\r\nadapter->unshare_watch_bitmask = 0;\r\ncancel_work_sync(&adapter->raise_intr_rxdata_task);\r\ncancel_work_sync(&adapter->tx_stall_task);\r\ncancel_work_sync(&hw->update_zone_task);\r\ncancel_work_sync(&hw->epstop_task);\r\nfjes_hw_wait_epstop(hw);\r\nfjes_free_resources(adapter);\r\nreturn 0;\r\n}\r\nstatic int fjes_setup_resources(struct fjes_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nstruct ep_share_mem_info *buf_pair;\r\nstruct fjes_hw *hw = &adapter->hw;\r\nunsigned long flags;\r\nint result;\r\nint epidx;\r\nmutex_lock(&hw->hw_info.lock);\r\nresult = fjes_hw_request_info(hw);\r\nswitch (result) {\r\ncase 0:\r\nfor (epidx = 0; epidx < hw->max_epid; epidx++) {\r\nhw->ep_shm_info[epidx].es_status =\r\nhw->hw_info.res_buf->info.info[epidx].es_status;\r\nhw->ep_shm_info[epidx].zone =\r\nhw->hw_info.res_buf->info.info[epidx].zone;\r\n}\r\nbreak;\r\ndefault:\r\ncase -ENOMSG:\r\ncase -EBUSY:\r\nadapter->force_reset = true;\r\nmutex_unlock(&hw->hw_info.lock);\r\nreturn result;\r\n}\r\nmutex_unlock(&hw->hw_info.lock);\r\nfor (epidx = 0; epidx < (hw->max_epid); epidx++) {\r\nif ((epidx != hw->my_epid) &&\r\n(hw->ep_shm_info[epidx].es_status ==\r\nFJES_ZONING_STATUS_ENABLE)) {\r\nfjes_hw_raise_interrupt(hw, epidx,\r\nREG_ICTL_MASK_INFO_UPDATE);\r\nhw->ep_shm_info[epidx].ep_stats\r\n.send_intr_zoneupdate += 1;\r\n}\r\n}\r\nmsleep(FJES_OPEN_ZONE_UPDATE_WAIT * hw->max_epid);\r\nfor (epidx = 0; epidx < (hw->max_epid); epidx++) {\r\nif (epidx == hw->my_epid)\r\ncontinue;\r\nbuf_pair = &hw->ep_shm_info[epidx];\r\nspin_lock_irqsave(&hw->rx_status_lock, flags);\r\nfjes_hw_setup_epbuf(&buf_pair->tx, netdev->dev_addr,\r\nnetdev->mtu);\r\nspin_unlock_irqrestore(&hw->rx_status_lock, flags);\r\nif (fjes_hw_epid_is_same_zone(hw, epidx)) {\r\nmutex_lock(&hw->hw_info.lock);\r\nresult =\r\nfjes_hw_register_buff_addr(hw, epidx, buf_pair);\r\nmutex_unlock(&hw->hw_info.lock);\r\nswitch (result) {\r\ncase 0:\r\nbreak;\r\ncase -ENOMSG:\r\ncase -EBUSY:\r\ndefault:\r\nadapter->force_reset = true;\r\nreturn result;\r\n}\r\nhw->ep_shm_info[epidx].ep_stats\r\n.com_regist_buf_exec += 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void fjes_free_resources(struct fjes_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nstruct fjes_device_command_param param;\r\nstruct ep_share_mem_info *buf_pair;\r\nstruct fjes_hw *hw = &adapter->hw;\r\nbool reset_flag = false;\r\nunsigned long flags;\r\nint result;\r\nint epidx;\r\nfor (epidx = 0; epidx < hw->max_epid; epidx++) {\r\nif (epidx == hw->my_epid)\r\ncontinue;\r\nmutex_lock(&hw->hw_info.lock);\r\nresult = fjes_hw_unregister_buff_addr(hw, epidx);\r\nmutex_unlock(&hw->hw_info.lock);\r\nhw->ep_shm_info[epidx].ep_stats.com_unregist_buf_exec += 1;\r\nif (result)\r\nreset_flag = true;\r\nbuf_pair = &hw->ep_shm_info[epidx];\r\nspin_lock_irqsave(&hw->rx_status_lock, flags);\r\nfjes_hw_setup_epbuf(&buf_pair->tx,\r\nnetdev->dev_addr, netdev->mtu);\r\nspin_unlock_irqrestore(&hw->rx_status_lock, flags);\r\nclear_bit(epidx, &hw->txrx_stop_req_bit);\r\n}\r\nif (reset_flag || adapter->force_reset) {\r\nresult = fjes_hw_reset(hw);\r\nadapter->force_reset = false;\r\nif (result)\r\nadapter->open_guard = true;\r\nhw->hw_info.buffer_share_bit = 0;\r\nmemset((void *)&param, 0, sizeof(param));\r\nparam.req_len = hw->hw_info.req_buf_size;\r\nparam.req_start = __pa(hw->hw_info.req_buf);\r\nparam.res_len = hw->hw_info.res_buf_size;\r\nparam.res_start = __pa(hw->hw_info.res_buf);\r\nparam.share_start = __pa(hw->hw_info.share->ep_status);\r\nfjes_hw_init_command_registers(hw, &param);\r\n}\r\n}\r\nstatic void fjes_tx_stall_task(struct work_struct *work)\r\n{\r\nstruct fjes_adapter *adapter = container_of(work,\r\nstruct fjes_adapter, tx_stall_task);\r\nstruct net_device *netdev = adapter->netdev;\r\nstruct fjes_hw *hw = &adapter->hw;\r\nint all_queue_available, sendable;\r\nenum ep_partner_status pstatus;\r\nint max_epid, my_epid, epid;\r\nunion ep_buffer_info *info;\r\nint i;\r\nif (((long)jiffies -\r\ndev_trans_start(netdev)) > FJES_TX_TX_STALL_TIMEOUT) {\r\nnetif_wake_queue(netdev);\r\nreturn;\r\n}\r\nmy_epid = hw->my_epid;\r\nmax_epid = hw->max_epid;\r\nfor (i = 0; i < 5; i++) {\r\nall_queue_available = 1;\r\nfor (epid = 0; epid < max_epid; epid++) {\r\nif (my_epid == epid)\r\ncontinue;\r\npstatus = fjes_hw_get_partner_ep_status(hw, epid);\r\nsendable = (pstatus == EP_PARTNER_SHARED);\r\nif (!sendable)\r\ncontinue;\r\ninfo = adapter->hw.ep_shm_info[epid].tx.info;\r\nif (!(info->v1i.rx_status & FJES_RX_MTU_CHANGING_DONE))\r\nreturn;\r\nif (EP_RING_FULL(info->v1i.head, info->v1i.tail,\r\ninfo->v1i.count_max)) {\r\nall_queue_available = 0;\r\nbreak;\r\n}\r\n}\r\nif (all_queue_available) {\r\nnetif_wake_queue(netdev);\r\nreturn;\r\n}\r\n}\r\nusleep_range(50, 100);\r\nqueue_work(adapter->txrx_wq, &adapter->tx_stall_task);\r\n}\r\nstatic void fjes_force_close_task(struct work_struct *work)\r\n{\r\nstruct fjes_adapter *adapter = container_of(work,\r\nstruct fjes_adapter, force_close_task);\r\nstruct net_device *netdev = adapter->netdev;\r\nrtnl_lock();\r\ndev_close(netdev);\r\nrtnl_unlock();\r\n}\r\nstatic void fjes_raise_intr_rxdata_task(struct work_struct *work)\r\n{\r\nstruct fjes_adapter *adapter = container_of(work,\r\nstruct fjes_adapter, raise_intr_rxdata_task);\r\nstruct fjes_hw *hw = &adapter->hw;\r\nenum ep_partner_status pstatus;\r\nint max_epid, my_epid, epid;\r\nmy_epid = hw->my_epid;\r\nmax_epid = hw->max_epid;\r\nfor (epid = 0; epid < max_epid; epid++)\r\nhw->ep_shm_info[epid].tx_status_work = 0;\r\nfor (epid = 0; epid < max_epid; epid++) {\r\nif (epid == my_epid)\r\ncontinue;\r\npstatus = fjes_hw_get_partner_ep_status(hw, epid);\r\nif (pstatus == EP_PARTNER_SHARED) {\r\nhw->ep_shm_info[epid].tx_status_work =\r\nhw->ep_shm_info[epid].tx.info->v1i.tx_status;\r\nif (hw->ep_shm_info[epid].tx_status_work ==\r\nFJES_TX_DELAY_SEND_PENDING) {\r\nhw->ep_shm_info[epid].tx.info->v1i.tx_status =\r\nFJES_TX_DELAY_SEND_NONE;\r\n}\r\n}\r\n}\r\nfor (epid = 0; epid < max_epid; epid++) {\r\nif (epid == my_epid)\r\ncontinue;\r\npstatus = fjes_hw_get_partner_ep_status(hw, epid);\r\nif ((hw->ep_shm_info[epid].tx_status_work ==\r\nFJES_TX_DELAY_SEND_PENDING) &&\r\n(pstatus == EP_PARTNER_SHARED) &&\r\n!(hw->ep_shm_info[epid].rx.info->v1i.rx_status &\r\nFJES_RX_POLL_WORK)) {\r\nfjes_hw_raise_interrupt(hw, epid,\r\nREG_ICTL_MASK_RX_DATA);\r\nhw->ep_shm_info[epid].ep_stats.send_intr_rx += 1;\r\n}\r\n}\r\nusleep_range(500, 1000);\r\n}\r\nstatic int fjes_tx_send(struct fjes_adapter *adapter, int dest,\r\nvoid *data, size_t len)\r\n{\r\nint retval;\r\nretval = fjes_hw_epbuf_tx_pkt_send(&adapter->hw.ep_shm_info[dest].tx,\r\ndata, len);\r\nif (retval)\r\nreturn retval;\r\nadapter->hw.ep_shm_info[dest].tx.info->v1i.tx_status =\r\nFJES_TX_DELAY_SEND_PENDING;\r\nif (!work_pending(&adapter->raise_intr_rxdata_task))\r\nqueue_work(adapter->txrx_wq,\r\n&adapter->raise_intr_rxdata_task);\r\nretval = 0;\r\nreturn retval;\r\n}\r\nstatic netdev_tx_t\r\nfjes_xmit_frame(struct sk_buff *skb, struct net_device *netdev)\r\n{\r\nstruct fjes_adapter *adapter = netdev_priv(netdev);\r\nstruct fjes_hw *hw = &adapter->hw;\r\nint max_epid, my_epid, dest_epid;\r\nenum ep_partner_status pstatus;\r\nstruct netdev_queue *cur_queue;\r\nchar shortpkt[VLAN_ETH_HLEN];\r\nbool is_multi, vlan;\r\nstruct ethhdr *eth;\r\nu16 queue_no = 0;\r\nu16 vlan_id = 0;\r\nnetdev_tx_t ret;\r\nchar *data;\r\nint len;\r\nret = NETDEV_TX_OK;\r\nis_multi = false;\r\ncur_queue = netdev_get_tx_queue(netdev, queue_no);\r\neth = (struct ethhdr *)skb->data;\r\nmy_epid = hw->my_epid;\r\nvlan = (vlan_get_tag(skb, &vlan_id) == 0) ? true : false;\r\ndata = skb->data;\r\nlen = skb->len;\r\nif (is_multicast_ether_addr(eth->h_dest)) {\r\ndest_epid = 0;\r\nmax_epid = hw->max_epid;\r\nis_multi = true;\r\n} else if (is_local_ether_addr(eth->h_dest)) {\r\ndest_epid = eth->h_dest[ETH_ALEN - 1];\r\nmax_epid = dest_epid + 1;\r\nif ((eth->h_dest[0] == 0x02) &&\r\n(0x00 == (eth->h_dest[1] | eth->h_dest[2] |\r\neth->h_dest[3] | eth->h_dest[4])) &&\r\n(dest_epid < hw->max_epid)) {\r\n;\r\n} else {\r\ndest_epid = 0;\r\nmax_epid = 0;\r\nret = NETDEV_TX_OK;\r\nadapter->stats64.tx_packets += 1;\r\nhw->ep_shm_info[my_epid].net_stats.tx_packets += 1;\r\nadapter->stats64.tx_bytes += len;\r\nhw->ep_shm_info[my_epid].net_stats.tx_bytes += len;\r\n}\r\n} else {\r\ndest_epid = 0;\r\nmax_epid = 0;\r\nret = NETDEV_TX_OK;\r\nadapter->stats64.tx_packets += 1;\r\nhw->ep_shm_info[my_epid].net_stats.tx_packets += 1;\r\nadapter->stats64.tx_bytes += len;\r\nhw->ep_shm_info[my_epid].net_stats.tx_bytes += len;\r\n}\r\nfor (; dest_epid < max_epid; dest_epid++) {\r\nif (my_epid == dest_epid)\r\ncontinue;\r\npstatus = fjes_hw_get_partner_ep_status(hw, dest_epid);\r\nif (pstatus != EP_PARTNER_SHARED) {\r\nif (!is_multi)\r\nhw->ep_shm_info[dest_epid].ep_stats\r\n.tx_dropped_not_shared += 1;\r\nret = NETDEV_TX_OK;\r\n} else if (!fjes_hw_check_epbuf_version(\r\n&adapter->hw.ep_shm_info[dest_epid].rx, 0)) {\r\nadapter->stats64.tx_carrier_errors += 1;\r\nhw->ep_shm_info[dest_epid].net_stats\r\n.tx_carrier_errors += 1;\r\nhw->ep_shm_info[dest_epid].ep_stats\r\n.tx_dropped_ver_mismatch += 1;\r\nret = NETDEV_TX_OK;\r\n} else if (!fjes_hw_check_mtu(\r\n&adapter->hw.ep_shm_info[dest_epid].rx,\r\nnetdev->mtu)) {\r\nadapter->stats64.tx_dropped += 1;\r\nhw->ep_shm_info[dest_epid].net_stats.tx_dropped += 1;\r\nadapter->stats64.tx_errors += 1;\r\nhw->ep_shm_info[dest_epid].net_stats.tx_errors += 1;\r\nhw->ep_shm_info[dest_epid].ep_stats\r\n.tx_dropped_buf_size_mismatch += 1;\r\nret = NETDEV_TX_OK;\r\n} else if (vlan &&\r\n!fjes_hw_check_vlan_id(\r\n&adapter->hw.ep_shm_info[dest_epid].rx,\r\nvlan_id)) {\r\nhw->ep_shm_info[dest_epid].ep_stats\r\n.tx_dropped_vlanid_mismatch += 1;\r\nret = NETDEV_TX_OK;\r\n} else {\r\nif (len < VLAN_ETH_HLEN) {\r\nmemset(shortpkt, 0, VLAN_ETH_HLEN);\r\nmemcpy(shortpkt, skb->data, skb->len);\r\nlen = VLAN_ETH_HLEN;\r\ndata = shortpkt;\r\n}\r\nif (adapter->tx_retry_count == 0) {\r\nadapter->tx_start_jiffies = jiffies;\r\nadapter->tx_retry_count = 1;\r\n} else {\r\nadapter->tx_retry_count++;\r\n}\r\nif (fjes_tx_send(adapter, dest_epid, data, len)) {\r\nif (is_multi) {\r\nret = NETDEV_TX_OK;\r\n} else if (\r\n((long)jiffies -\r\n(long)adapter->tx_start_jiffies) >=\r\nFJES_TX_RETRY_TIMEOUT) {\r\nadapter->stats64.tx_fifo_errors += 1;\r\nhw->ep_shm_info[dest_epid].net_stats\r\n.tx_fifo_errors += 1;\r\nadapter->stats64.tx_errors += 1;\r\nhw->ep_shm_info[dest_epid].net_stats\r\n.tx_errors += 1;\r\nret = NETDEV_TX_OK;\r\n} else {\r\nnetif_trans_update(netdev);\r\nhw->ep_shm_info[dest_epid].ep_stats\r\n.tx_buffer_full += 1;\r\nnetif_tx_stop_queue(cur_queue);\r\nif (!work_pending(&adapter->tx_stall_task))\r\nqueue_work(adapter->txrx_wq,\r\n&adapter->tx_stall_task);\r\nret = NETDEV_TX_BUSY;\r\n}\r\n} else {\r\nif (!is_multi) {\r\nadapter->stats64.tx_packets += 1;\r\nhw->ep_shm_info[dest_epid].net_stats\r\n.tx_packets += 1;\r\nadapter->stats64.tx_bytes += len;\r\nhw->ep_shm_info[dest_epid].net_stats\r\n.tx_bytes += len;\r\n}\r\nadapter->tx_retry_count = 0;\r\nret = NETDEV_TX_OK;\r\n}\r\n}\r\n}\r\nif (ret == NETDEV_TX_OK) {\r\ndev_kfree_skb(skb);\r\nif (is_multi) {\r\nadapter->stats64.tx_packets += 1;\r\nhw->ep_shm_info[my_epid].net_stats.tx_packets += 1;\r\nadapter->stats64.tx_bytes += 1;\r\nhw->ep_shm_info[my_epid].net_stats.tx_bytes += len;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void fjes_tx_retry(struct net_device *netdev)\r\n{\r\nstruct netdev_queue *queue = netdev_get_tx_queue(netdev, 0);\r\nnetif_tx_wake_queue(queue);\r\n}\r\nstatic void\r\nfjes_get_stats64(struct net_device *netdev, struct rtnl_link_stats64 *stats)\r\n{\r\nstruct fjes_adapter *adapter = netdev_priv(netdev);\r\nmemcpy(stats, &adapter->stats64, sizeof(struct rtnl_link_stats64));\r\n}\r\nstatic int fjes_change_mtu(struct net_device *netdev, int new_mtu)\r\n{\r\nstruct fjes_adapter *adapter = netdev_priv(netdev);\r\nbool running = netif_running(netdev);\r\nstruct fjes_hw *hw = &adapter->hw;\r\nunsigned long flags;\r\nint ret = -EINVAL;\r\nint idx, epidx;\r\nfor (idx = 0; fjes_support_mtu[idx] != 0; idx++) {\r\nif (new_mtu <= fjes_support_mtu[idx]) {\r\nnew_mtu = fjes_support_mtu[idx];\r\nif (new_mtu == netdev->mtu)\r\nreturn 0;\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nif (ret)\r\nreturn ret;\r\nif (running) {\r\nspin_lock_irqsave(&hw->rx_status_lock, flags);\r\nfor (epidx = 0; epidx < hw->max_epid; epidx++) {\r\nif (epidx == hw->my_epid)\r\ncontinue;\r\nhw->ep_shm_info[epidx].tx.info->v1i.rx_status &=\r\n~FJES_RX_MTU_CHANGING_DONE;\r\n}\r\nspin_unlock_irqrestore(&hw->rx_status_lock, flags);\r\nnetif_tx_stop_all_queues(netdev);\r\nnetif_carrier_off(netdev);\r\ncancel_work_sync(&adapter->tx_stall_task);\r\nnapi_disable(&adapter->napi);\r\nmsleep(1000);\r\nnetif_tx_stop_all_queues(netdev);\r\n}\r\nnetdev->mtu = new_mtu;\r\nif (running) {\r\nfor (epidx = 0; epidx < hw->max_epid; epidx++) {\r\nif (epidx == hw->my_epid)\r\ncontinue;\r\nspin_lock_irqsave(&hw->rx_status_lock, flags);\r\nfjes_hw_setup_epbuf(&hw->ep_shm_info[epidx].tx,\r\nnetdev->dev_addr,\r\nnetdev->mtu);\r\nhw->ep_shm_info[epidx].tx.info->v1i.rx_status |=\r\nFJES_RX_MTU_CHANGING_DONE;\r\nspin_unlock_irqrestore(&hw->rx_status_lock, flags);\r\n}\r\nnetif_tx_wake_all_queues(netdev);\r\nnetif_carrier_on(netdev);\r\nnapi_enable(&adapter->napi);\r\nnapi_schedule(&adapter->napi);\r\n}\r\nreturn ret;\r\n}\r\nstatic int fjes_vlan_rx_add_vid(struct net_device *netdev,\r\n__be16 proto, u16 vid)\r\n{\r\nstruct fjes_adapter *adapter = netdev_priv(netdev);\r\nbool ret = true;\r\nint epid;\r\nfor (epid = 0; epid < adapter->hw.max_epid; epid++) {\r\nif (epid == adapter->hw.my_epid)\r\ncontinue;\r\nif (!fjes_hw_check_vlan_id(\r\n&adapter->hw.ep_shm_info[epid].tx, vid))\r\nret = fjes_hw_set_vlan_id(\r\n&adapter->hw.ep_shm_info[epid].tx, vid);\r\n}\r\nreturn ret ? 0 : -ENOSPC;\r\n}\r\nstatic int fjes_vlan_rx_kill_vid(struct net_device *netdev,\r\n__be16 proto, u16 vid)\r\n{\r\nstruct fjes_adapter *adapter = netdev_priv(netdev);\r\nint epid;\r\nfor (epid = 0; epid < adapter->hw.max_epid; epid++) {\r\nif (epid == adapter->hw.my_epid)\r\ncontinue;\r\nfjes_hw_del_vlan_id(&adapter->hw.ep_shm_info[epid].tx, vid);\r\n}\r\nreturn 0;\r\n}\r\nstatic void fjes_txrx_stop_req_irq(struct fjes_adapter *adapter,\r\nint src_epid)\r\n{\r\nstruct fjes_hw *hw = &adapter->hw;\r\nenum ep_partner_status status;\r\nunsigned long flags;\r\nstatus = fjes_hw_get_partner_ep_status(hw, src_epid);\r\ntrace_fjes_txrx_stop_req_irq_pre(hw, src_epid, status);\r\nswitch (status) {\r\ncase EP_PARTNER_UNSHARE:\r\ncase EP_PARTNER_COMPLETE:\r\ndefault:\r\nbreak;\r\ncase EP_PARTNER_WAITING:\r\nif (src_epid < hw->my_epid) {\r\nspin_lock_irqsave(&hw->rx_status_lock, flags);\r\nhw->ep_shm_info[src_epid].tx.info->v1i.rx_status |=\r\nFJES_RX_STOP_REQ_DONE;\r\nspin_unlock_irqrestore(&hw->rx_status_lock, flags);\r\nclear_bit(src_epid, &hw->txrx_stop_req_bit);\r\nset_bit(src_epid, &adapter->unshare_watch_bitmask);\r\nif (!work_pending(&adapter->unshare_watch_task))\r\nqueue_work(adapter->control_wq,\r\n&adapter->unshare_watch_task);\r\n}\r\nbreak;\r\ncase EP_PARTNER_SHARED:\r\nif (hw->ep_shm_info[src_epid].rx.info->v1i.rx_status &\r\nFJES_RX_STOP_REQ_REQUEST) {\r\nset_bit(src_epid, &hw->epstop_req_bit);\r\nif (!work_pending(&hw->epstop_task))\r\nqueue_work(adapter->control_wq,\r\n&hw->epstop_task);\r\n}\r\nbreak;\r\n}\r\ntrace_fjes_txrx_stop_req_irq_post(hw, src_epid);\r\n}\r\nstatic void fjes_stop_req_irq(struct fjes_adapter *adapter, int src_epid)\r\n{\r\nstruct fjes_hw *hw = &adapter->hw;\r\nenum ep_partner_status status;\r\nunsigned long flags;\r\nset_bit(src_epid, &hw->hw_info.buffer_unshare_reserve_bit);\r\nstatus = fjes_hw_get_partner_ep_status(hw, src_epid);\r\ntrace_fjes_stop_req_irq_pre(hw, src_epid, status);\r\nswitch (status) {\r\ncase EP_PARTNER_WAITING:\r\nspin_lock_irqsave(&hw->rx_status_lock, flags);\r\nhw->ep_shm_info[src_epid].tx.info->v1i.rx_status |=\r\nFJES_RX_STOP_REQ_DONE;\r\nspin_unlock_irqrestore(&hw->rx_status_lock, flags);\r\nclear_bit(src_epid, &hw->txrx_stop_req_bit);\r\ncase EP_PARTNER_UNSHARE:\r\ncase EP_PARTNER_COMPLETE:\r\ndefault:\r\nset_bit(src_epid, &adapter->unshare_watch_bitmask);\r\nif (!work_pending(&adapter->unshare_watch_task))\r\nqueue_work(adapter->control_wq,\r\n&adapter->unshare_watch_task);\r\nbreak;\r\ncase EP_PARTNER_SHARED:\r\nset_bit(src_epid, &hw->epstop_req_bit);\r\nif (!work_pending(&hw->epstop_task))\r\nqueue_work(adapter->control_wq, &hw->epstop_task);\r\nbreak;\r\n}\r\ntrace_fjes_stop_req_irq_post(hw, src_epid);\r\n}\r\nstatic void fjes_update_zone_irq(struct fjes_adapter *adapter,\r\nint src_epid)\r\n{\r\nstruct fjes_hw *hw = &adapter->hw;\r\nif (!work_pending(&hw->update_zone_task))\r\nqueue_work(adapter->control_wq, &hw->update_zone_task);\r\n}\r\nstatic irqreturn_t fjes_intr(int irq, void *data)\r\n{\r\nstruct fjes_adapter *adapter = data;\r\nstruct fjes_hw *hw = &adapter->hw;\r\nirqreturn_t ret;\r\nu32 icr;\r\nicr = fjes_hw_capture_interrupt_status(hw);\r\nif (icr & REG_IS_MASK_IS_ASSERT) {\r\nif (icr & REG_ICTL_MASK_RX_DATA) {\r\nfjes_rx_irq(adapter, icr & REG_IS_MASK_EPID);\r\nhw->ep_shm_info[icr & REG_IS_MASK_EPID].ep_stats\r\n.recv_intr_rx += 1;\r\n}\r\nif (icr & REG_ICTL_MASK_DEV_STOP_REQ) {\r\nfjes_stop_req_irq(adapter, icr & REG_IS_MASK_EPID);\r\nhw->ep_shm_info[icr & REG_IS_MASK_EPID].ep_stats\r\n.recv_intr_stop += 1;\r\n}\r\nif (icr & REG_ICTL_MASK_TXRX_STOP_REQ) {\r\nfjes_txrx_stop_req_irq(adapter, icr & REG_IS_MASK_EPID);\r\nhw->ep_shm_info[icr & REG_IS_MASK_EPID].ep_stats\r\n.recv_intr_unshare += 1;\r\n}\r\nif (icr & REG_ICTL_MASK_TXRX_STOP_DONE)\r\nfjes_hw_set_irqmask(hw,\r\nREG_ICTL_MASK_TXRX_STOP_DONE, true);\r\nif (icr & REG_ICTL_MASK_INFO_UPDATE) {\r\nfjes_update_zone_irq(adapter, icr & REG_IS_MASK_EPID);\r\nhw->ep_shm_info[icr & REG_IS_MASK_EPID].ep_stats\r\n.recv_intr_zoneupdate += 1;\r\n}\r\nret = IRQ_HANDLED;\r\n} else {\r\nret = IRQ_NONE;\r\n}\r\nreturn ret;\r\n}\r\nstatic int fjes_rxframe_search_exist(struct fjes_adapter *adapter,\r\nint start_epid)\r\n{\r\nstruct fjes_hw *hw = &adapter->hw;\r\nenum ep_partner_status pstatus;\r\nint max_epid, cur_epid;\r\nint i;\r\nmax_epid = hw->max_epid;\r\nstart_epid = (start_epid + 1 + max_epid) % max_epid;\r\nfor (i = 0; i < max_epid; i++) {\r\ncur_epid = (start_epid + i) % max_epid;\r\nif (cur_epid == hw->my_epid)\r\ncontinue;\r\npstatus = fjes_hw_get_partner_ep_status(hw, cur_epid);\r\nif (pstatus == EP_PARTNER_SHARED) {\r\nif (!fjes_hw_epbuf_rx_is_empty(\r\n&hw->ep_shm_info[cur_epid].rx))\r\nreturn cur_epid;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nstatic void *fjes_rxframe_get(struct fjes_adapter *adapter, size_t *psize,\r\nint *cur_epid)\r\n{\r\nvoid *frame;\r\n*cur_epid = fjes_rxframe_search_exist(adapter, *cur_epid);\r\nif (*cur_epid < 0)\r\nreturn NULL;\r\nframe =\r\nfjes_hw_epbuf_rx_curpkt_get_addr(\r\n&adapter->hw.ep_shm_info[*cur_epid].rx, psize);\r\nreturn frame;\r\n}\r\nstatic void fjes_rxframe_release(struct fjes_adapter *adapter, int cur_epid)\r\n{\r\nfjes_hw_epbuf_rx_curpkt_drop(&adapter->hw.ep_shm_info[cur_epid].rx);\r\n}\r\nstatic void fjes_rx_irq(struct fjes_adapter *adapter, int src_epid)\r\n{\r\nstruct fjes_hw *hw = &adapter->hw;\r\nfjes_hw_set_irqmask(hw, REG_ICTL_MASK_RX_DATA, true);\r\nadapter->unset_rx_last = true;\r\nnapi_schedule(&adapter->napi);\r\n}\r\nstatic int fjes_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct fjes_adapter *adapter =\r\ncontainer_of(napi, struct fjes_adapter, napi);\r\nstruct net_device *netdev = napi->dev;\r\nstruct fjes_hw *hw = &adapter->hw;\r\nstruct sk_buff *skb;\r\nint work_done = 0;\r\nint cur_epid = 0;\r\nint epidx;\r\nsize_t frame_len;\r\nvoid *frame;\r\nspin_lock(&hw->rx_status_lock);\r\nfor (epidx = 0; epidx < hw->max_epid; epidx++) {\r\nif (epidx == hw->my_epid)\r\ncontinue;\r\nif (fjes_hw_get_partner_ep_status(hw, epidx) ==\r\nEP_PARTNER_SHARED)\r\nadapter->hw.ep_shm_info[epidx]\r\n.tx.info->v1i.rx_status |= FJES_RX_POLL_WORK;\r\n}\r\nspin_unlock(&hw->rx_status_lock);\r\nwhile (work_done < budget) {\r\nprefetch(&adapter->hw);\r\nframe = fjes_rxframe_get(adapter, &frame_len, &cur_epid);\r\nif (frame) {\r\nskb = napi_alloc_skb(napi, frame_len);\r\nif (!skb) {\r\nadapter->stats64.rx_dropped += 1;\r\nhw->ep_shm_info[cur_epid].net_stats\r\n.rx_dropped += 1;\r\nadapter->stats64.rx_errors += 1;\r\nhw->ep_shm_info[cur_epid].net_stats\r\n.rx_errors += 1;\r\n} else {\r\nskb_put_data(skb, frame, frame_len);\r\nskb->protocol = eth_type_trans(skb, netdev);\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\nnetif_receive_skb(skb);\r\nwork_done++;\r\nadapter->stats64.rx_packets += 1;\r\nhw->ep_shm_info[cur_epid].net_stats\r\n.rx_packets += 1;\r\nadapter->stats64.rx_bytes += frame_len;\r\nhw->ep_shm_info[cur_epid].net_stats\r\n.rx_bytes += frame_len;\r\nif (is_multicast_ether_addr(\r\n((struct ethhdr *)frame)->h_dest)) {\r\nadapter->stats64.multicast += 1;\r\nhw->ep_shm_info[cur_epid].net_stats\r\n.multicast += 1;\r\n}\r\n}\r\nfjes_rxframe_release(adapter, cur_epid);\r\nadapter->unset_rx_last = true;\r\n} else {\r\nbreak;\r\n}\r\n}\r\nif (work_done < budget) {\r\nnapi_complete_done(napi, work_done);\r\nif (adapter->unset_rx_last) {\r\nadapter->rx_last_jiffies = jiffies;\r\nadapter->unset_rx_last = false;\r\n}\r\nif (((long)jiffies - (long)adapter->rx_last_jiffies) < 3) {\r\nnapi_reschedule(napi);\r\n} else {\r\nspin_lock(&hw->rx_status_lock);\r\nfor (epidx = 0; epidx < hw->max_epid; epidx++) {\r\nif (epidx == hw->my_epid)\r\ncontinue;\r\nif (fjes_hw_get_partner_ep_status(hw, epidx) ==\r\nEP_PARTNER_SHARED)\r\nadapter->hw.ep_shm_info[epidx].tx\r\n.info->v1i.rx_status &=\r\n~FJES_RX_POLL_WORK;\r\n}\r\nspin_unlock(&hw->rx_status_lock);\r\nfjes_hw_set_irqmask(hw, REG_ICTL_MASK_RX_DATA, false);\r\n}\r\n}\r\nreturn work_done;\r\n}\r\nstatic int fjes_probe(struct platform_device *plat_dev)\r\n{\r\nstruct fjes_adapter *adapter;\r\nstruct net_device *netdev;\r\nstruct resource *res;\r\nstruct fjes_hw *hw;\r\nint err;\r\nerr = -ENOMEM;\r\nnetdev = alloc_netdev_mq(sizeof(struct fjes_adapter), "es%d",\r\nNET_NAME_UNKNOWN, fjes_netdev_setup,\r\nFJES_MAX_QUEUES);\r\nif (!netdev)\r\ngoto err_out;\r\nSET_NETDEV_DEV(netdev, &plat_dev->dev);\r\ndev_set_drvdata(&plat_dev->dev, netdev);\r\nadapter = netdev_priv(netdev);\r\nadapter->netdev = netdev;\r\nadapter->plat_dev = plat_dev;\r\nhw = &adapter->hw;\r\nhw->back = adapter;\r\nerr = fjes_sw_init(adapter);\r\nif (err)\r\ngoto err_free_netdev;\r\nINIT_WORK(&adapter->force_close_task, fjes_force_close_task);\r\nadapter->force_reset = false;\r\nadapter->open_guard = false;\r\nadapter->txrx_wq = alloc_workqueue(DRV_NAME "/txrx", WQ_MEM_RECLAIM, 0);\r\nadapter->control_wq = alloc_workqueue(DRV_NAME "/control",\r\nWQ_MEM_RECLAIM, 0);\r\nINIT_WORK(&adapter->tx_stall_task, fjes_tx_stall_task);\r\nINIT_WORK(&adapter->raise_intr_rxdata_task,\r\nfjes_raise_intr_rxdata_task);\r\nINIT_WORK(&adapter->unshare_watch_task, fjes_watch_unshare_task);\r\nadapter->unshare_watch_bitmask = 0;\r\nINIT_DELAYED_WORK(&adapter->interrupt_watch_task, fjes_irq_watch_task);\r\nadapter->interrupt_watch_enable = false;\r\nres = platform_get_resource(plat_dev, IORESOURCE_MEM, 0);\r\nhw->hw_res.start = res->start;\r\nhw->hw_res.size = resource_size(res);\r\nhw->hw_res.irq = platform_get_irq(plat_dev, 0);\r\nerr = fjes_hw_init(&adapter->hw);\r\nif (err)\r\ngoto err_free_netdev;\r\nnetdev->dev_addr[0] = 2;\r\nnetdev->dev_addr[1] = 0;\r\nnetdev->dev_addr[2] = 0;\r\nnetdev->dev_addr[3] = 0;\r\nnetdev->dev_addr[4] = 0;\r\nnetdev->dev_addr[5] = hw->my_epid;\r\nerr = register_netdev(netdev);\r\nif (err)\r\ngoto err_hw_exit;\r\nnetif_carrier_off(netdev);\r\nfjes_dbg_adapter_init(adapter);\r\nreturn 0;\r\nerr_hw_exit:\r\nfjes_hw_exit(&adapter->hw);\r\nerr_free_netdev:\r\nfree_netdev(netdev);\r\nerr_out:\r\nreturn err;\r\n}\r\nstatic int fjes_remove(struct platform_device *plat_dev)\r\n{\r\nstruct net_device *netdev = dev_get_drvdata(&plat_dev->dev);\r\nstruct fjes_adapter *adapter = netdev_priv(netdev);\r\nstruct fjes_hw *hw = &adapter->hw;\r\nfjes_dbg_adapter_exit(adapter);\r\ncancel_delayed_work_sync(&adapter->interrupt_watch_task);\r\ncancel_work_sync(&adapter->unshare_watch_task);\r\ncancel_work_sync(&adapter->raise_intr_rxdata_task);\r\ncancel_work_sync(&adapter->tx_stall_task);\r\nif (adapter->control_wq)\r\ndestroy_workqueue(adapter->control_wq);\r\nif (adapter->txrx_wq)\r\ndestroy_workqueue(adapter->txrx_wq);\r\nunregister_netdev(netdev);\r\nfjes_hw_exit(hw);\r\nnetif_napi_del(&adapter->napi);\r\nfree_netdev(netdev);\r\nreturn 0;\r\n}\r\nstatic int fjes_sw_init(struct fjes_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nnetif_napi_add(netdev, &adapter->napi, fjes_poll, 64);\r\nreturn 0;\r\n}\r\nstatic void fjes_netdev_setup(struct net_device *netdev)\r\n{\r\nether_setup(netdev);\r\nnetdev->watchdog_timeo = FJES_TX_RETRY_INTERVAL;\r\nnetdev->netdev_ops = &fjes_netdev_ops;\r\nfjes_set_ethtool_ops(netdev);\r\nnetdev->mtu = fjes_support_mtu[3];\r\nnetdev->min_mtu = fjes_support_mtu[0];\r\nnetdev->max_mtu = fjes_support_mtu[3];\r\nnetdev->features |= NETIF_F_HW_VLAN_CTAG_FILTER;\r\n}\r\nstatic void fjes_irq_watch_task(struct work_struct *work)\r\n{\r\nstruct fjes_adapter *adapter = container_of(to_delayed_work(work),\r\nstruct fjes_adapter, interrupt_watch_task);\r\nlocal_irq_disable();\r\nfjes_intr(adapter->hw.hw_res.irq, adapter);\r\nlocal_irq_enable();\r\nif (fjes_rxframe_search_exist(adapter, 0) >= 0)\r\nnapi_schedule(&adapter->napi);\r\nif (adapter->interrupt_watch_enable) {\r\nif (!delayed_work_pending(&adapter->interrupt_watch_task))\r\nqueue_delayed_work(adapter->control_wq,\r\n&adapter->interrupt_watch_task,\r\nFJES_IRQ_WATCH_DELAY);\r\n}\r\n}\r\nstatic void fjes_watch_unshare_task(struct work_struct *work)\r\n{\r\nstruct fjes_adapter *adapter =\r\ncontainer_of(work, struct fjes_adapter, unshare_watch_task);\r\nstruct net_device *netdev = adapter->netdev;\r\nstruct fjes_hw *hw = &adapter->hw;\r\nint unshare_watch, unshare_reserve;\r\nint max_epid, my_epid, epidx;\r\nint stop_req, stop_req_done;\r\nulong unshare_watch_bitmask;\r\nunsigned long flags;\r\nint wait_time = 0;\r\nint is_shared;\r\nint ret;\r\nmy_epid = hw->my_epid;\r\nmax_epid = hw->max_epid;\r\nunshare_watch_bitmask = adapter->unshare_watch_bitmask;\r\nadapter->unshare_watch_bitmask = 0;\r\nwhile ((unshare_watch_bitmask || hw->txrx_stop_req_bit) &&\r\n(wait_time < 3000)) {\r\nfor (epidx = 0; epidx < hw->max_epid; epidx++) {\r\nif (epidx == hw->my_epid)\r\ncontinue;\r\nis_shared = fjes_hw_epid_is_shared(hw->hw_info.share,\r\nepidx);\r\nstop_req = test_bit(epidx, &hw->txrx_stop_req_bit);\r\nstop_req_done = hw->ep_shm_info[epidx].rx.info->v1i.rx_status &\r\nFJES_RX_STOP_REQ_DONE;\r\nunshare_watch = test_bit(epidx, &unshare_watch_bitmask);\r\nunshare_reserve = test_bit(epidx,\r\n&hw->hw_info.buffer_unshare_reserve_bit);\r\nif ((!stop_req ||\r\n(is_shared && (!is_shared || !stop_req_done))) &&\r\n(is_shared || !unshare_watch || !unshare_reserve))\r\ncontinue;\r\nmutex_lock(&hw->hw_info.lock);\r\nret = fjes_hw_unregister_buff_addr(hw, epidx);\r\nswitch (ret) {\r\ncase 0:\r\nbreak;\r\ncase -ENOMSG:\r\ncase -EBUSY:\r\ndefault:\r\nif (!work_pending(\r\n&adapter->force_close_task)) {\r\nadapter->force_reset = true;\r\nschedule_work(\r\n&adapter->force_close_task);\r\n}\r\nbreak;\r\n}\r\nmutex_unlock(&hw->hw_info.lock);\r\nhw->ep_shm_info[epidx].ep_stats\r\n.com_unregist_buf_exec += 1;\r\nspin_lock_irqsave(&hw->rx_status_lock, flags);\r\nfjes_hw_setup_epbuf(&hw->ep_shm_info[epidx].tx,\r\nnetdev->dev_addr, netdev->mtu);\r\nspin_unlock_irqrestore(&hw->rx_status_lock, flags);\r\nclear_bit(epidx, &hw->txrx_stop_req_bit);\r\nclear_bit(epidx, &unshare_watch_bitmask);\r\nclear_bit(epidx,\r\n&hw->hw_info.buffer_unshare_reserve_bit);\r\n}\r\nmsleep(100);\r\nwait_time += 100;\r\n}\r\nif (hw->hw_info.buffer_unshare_reserve_bit) {\r\nfor (epidx = 0; epidx < hw->max_epid; epidx++) {\r\nif (epidx == hw->my_epid)\r\ncontinue;\r\nif (test_bit(epidx,\r\n&hw->hw_info.buffer_unshare_reserve_bit)) {\r\nmutex_lock(&hw->hw_info.lock);\r\nret = fjes_hw_unregister_buff_addr(hw, epidx);\r\nswitch (ret) {\r\ncase 0:\r\nbreak;\r\ncase -ENOMSG:\r\ncase -EBUSY:\r\ndefault:\r\nif (!work_pending(\r\n&adapter->force_close_task)) {\r\nadapter->force_reset = true;\r\nschedule_work(\r\n&adapter->force_close_task);\r\n}\r\nbreak;\r\n}\r\nmutex_unlock(&hw->hw_info.lock);\r\nhw->ep_shm_info[epidx].ep_stats\r\n.com_unregist_buf_exec += 1;\r\nspin_lock_irqsave(&hw->rx_status_lock, flags);\r\nfjes_hw_setup_epbuf(\r\n&hw->ep_shm_info[epidx].tx,\r\nnetdev->dev_addr, netdev->mtu);\r\nspin_unlock_irqrestore(&hw->rx_status_lock,\r\nflags);\r\nclear_bit(epidx, &hw->txrx_stop_req_bit);\r\nclear_bit(epidx, &unshare_watch_bitmask);\r\nclear_bit(epidx, &hw->hw_info.buffer_unshare_reserve_bit);\r\n}\r\nif (test_bit(epidx, &unshare_watch_bitmask)) {\r\nspin_lock_irqsave(&hw->rx_status_lock, flags);\r\nhw->ep_shm_info[epidx].tx.info->v1i.rx_status &=\r\n~FJES_RX_STOP_REQ_DONE;\r\nspin_unlock_irqrestore(&hw->rx_status_lock,\r\nflags);\r\n}\r\n}\r\n}\r\n}\r\nstatic acpi_status\r\nacpi_find_extended_socket_device(acpi_handle obj_handle, u32 level,\r\nvoid *context, void **return_value)\r\n{\r\nstruct acpi_device *device;\r\nbool *found = context;\r\nint result;\r\nresult = acpi_bus_get_device(obj_handle, &device);\r\nif (result)\r\nreturn AE_OK;\r\nif (strcmp(acpi_device_hid(device), ACPI_MOTHERBOARD_RESOURCE_HID))\r\nreturn AE_OK;\r\nif (!is_extended_socket_device(device))\r\nreturn AE_OK;\r\nif (acpi_check_extended_socket_status(device))\r\nreturn AE_OK;\r\n*found = true;\r\nreturn AE_CTRL_TERMINATE;\r\n}\r\nstatic int __init fjes_init_module(void)\r\n{\r\nbool found = false;\r\nint result;\r\nacpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT, ACPI_UINT32_MAX,\r\nacpi_find_extended_socket_device, NULL, &found,\r\nNULL);\r\nif (!found)\r\nreturn -ENODEV;\r\npr_info("%s - version %s - %s\n",\r\nfjes_driver_string, fjes_driver_version, fjes_copyright);\r\nfjes_dbg_init();\r\nresult = platform_driver_register(&fjes_driver);\r\nif (result < 0) {\r\nfjes_dbg_exit();\r\nreturn result;\r\n}\r\nresult = acpi_bus_register_driver(&fjes_acpi_driver);\r\nif (result < 0)\r\ngoto fail_acpi_driver;\r\nreturn 0;\r\nfail_acpi_driver:\r\nplatform_driver_unregister(&fjes_driver);\r\nfjes_dbg_exit();\r\nreturn result;\r\n}\r\nstatic void __exit fjes_exit_module(void)\r\n{\r\nacpi_bus_unregister_driver(&fjes_acpi_driver);\r\nplatform_driver_unregister(&fjes_driver);\r\nfjes_dbg_exit();\r\n}
