void batadv_hardif_release(struct kref *ref)\r\n{\r\nstruct batadv_hard_iface *hard_iface;\r\nhard_iface = container_of(ref, struct batadv_hard_iface, refcount);\r\ndev_put(hard_iface->net_dev);\r\nkfree_rcu(hard_iface, rcu);\r\n}\r\nstruct batadv_hard_iface *\r\nbatadv_hardif_get_by_netdev(const struct net_device *net_dev)\r\n{\r\nstruct batadv_hard_iface *hard_iface;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(hard_iface, &batadv_hardif_list, list) {\r\nif (hard_iface->net_dev == net_dev &&\r\nkref_get_unless_zero(&hard_iface->refcount))\r\ngoto out;\r\n}\r\nhard_iface = NULL;\r\nout:\r\nrcu_read_unlock();\r\nreturn hard_iface;\r\n}\r\nstatic struct net *batadv_getlink_net(const struct net_device *netdev,\r\nstruct net *fallback_net)\r\n{\r\nif (!netdev->rtnl_link_ops)\r\nreturn fallback_net;\r\nif (!netdev->rtnl_link_ops->get_link_net)\r\nreturn fallback_net;\r\nreturn netdev->rtnl_link_ops->get_link_net(netdev);\r\n}\r\nstatic bool batadv_mutual_parents(const struct net_device *dev1,\r\nstruct net *net1,\r\nconst struct net_device *dev2,\r\nstruct net *net2)\r\n{\r\nint dev1_parent_iflink = dev_get_iflink(dev1);\r\nint dev2_parent_iflink = dev_get_iflink(dev2);\r\nconst struct net *dev1_parent_net;\r\nconst struct net *dev2_parent_net;\r\ndev1_parent_net = batadv_getlink_net(dev1, net1);\r\ndev2_parent_net = batadv_getlink_net(dev2, net2);\r\nif (!dev1_parent_iflink || !dev2_parent_iflink)\r\nreturn false;\r\nreturn (dev1_parent_iflink == dev2->ifindex) &&\r\n(dev2_parent_iflink == dev1->ifindex) &&\r\nnet_eq(dev1_parent_net, net2) &&\r\nnet_eq(dev2_parent_net, net1);\r\n}\r\nstatic bool batadv_is_on_batman_iface(const struct net_device *net_dev)\r\n{\r\nstruct net *net = dev_net(net_dev);\r\nstruct net_device *parent_dev;\r\nstruct net *parent_net;\r\nbool ret;\r\nif (batadv_softif_is_valid(net_dev))\r\nreturn true;\r\nif (dev_get_iflink(net_dev) == 0 ||\r\ndev_get_iflink(net_dev) == net_dev->ifindex)\r\nreturn false;\r\nparent_net = batadv_getlink_net(net_dev, net);\r\nparent_dev = __dev_get_by_index((struct net *)parent_net,\r\ndev_get_iflink(net_dev));\r\nif (WARN(!parent_dev, "Cannot find parent device"))\r\nreturn false;\r\nif (batadv_mutual_parents(net_dev, net, parent_dev, parent_net))\r\nreturn false;\r\nret = batadv_is_on_batman_iface(parent_dev);\r\nreturn ret;\r\n}\r\nstatic bool batadv_is_valid_iface(const struct net_device *net_dev)\r\n{\r\nif (net_dev->flags & IFF_LOOPBACK)\r\nreturn false;\r\nif (net_dev->type != ARPHRD_ETHER)\r\nreturn false;\r\nif (net_dev->addr_len != ETH_ALEN)\r\nreturn false;\r\nif (batadv_is_on_batman_iface(net_dev))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic struct net_device *batadv_get_real_netdevice(struct net_device *netdev)\r\n{\r\nstruct batadv_hard_iface *hard_iface = NULL;\r\nstruct net_device *real_netdev = NULL;\r\nstruct net *real_net;\r\nstruct net *net;\r\nint ifindex;\r\nASSERT_RTNL();\r\nif (!netdev)\r\nreturn NULL;\r\nif (netdev->ifindex == dev_get_iflink(netdev)) {\r\ndev_hold(netdev);\r\nreturn netdev;\r\n}\r\nhard_iface = batadv_hardif_get_by_netdev(netdev);\r\nif (!hard_iface || !hard_iface->soft_iface)\r\ngoto out;\r\nnet = dev_net(hard_iface->soft_iface);\r\nifindex = dev_get_iflink(netdev);\r\nreal_net = batadv_getlink_net(netdev, net);\r\nreal_netdev = dev_get_by_index(real_net, ifindex);\r\nout:\r\nif (hard_iface)\r\nbatadv_hardif_put(hard_iface);\r\nreturn real_netdev;\r\n}\r\nstruct net_device *batadv_get_real_netdev(struct net_device *net_device)\r\n{\r\nstruct net_device *real_netdev;\r\nrtnl_lock();\r\nreal_netdev = batadv_get_real_netdevice(net_device);\r\nrtnl_unlock();\r\nreturn real_netdev;\r\n}\r\nstatic bool batadv_is_wext_netdev(struct net_device *net_device)\r\n{\r\nif (!net_device)\r\nreturn false;\r\n#ifdef CONFIG_WIRELESS_EXT\r\nif (net_device->wireless_handlers)\r\nreturn true;\r\n#endif\r\nreturn false;\r\n}\r\nstatic bool batadv_is_cfg80211_netdev(struct net_device *net_device)\r\n{\r\nif (!net_device)\r\nreturn false;\r\nif (net_device->ieee80211_ptr)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic u32 batadv_wifi_flags_evaluate(struct net_device *net_device)\r\n{\r\nu32 wifi_flags = 0;\r\nstruct net_device *real_netdev;\r\nif (batadv_is_wext_netdev(net_device))\r\nwifi_flags |= BATADV_HARDIF_WIFI_WEXT_DIRECT;\r\nif (batadv_is_cfg80211_netdev(net_device))\r\nwifi_flags |= BATADV_HARDIF_WIFI_CFG80211_DIRECT;\r\nreal_netdev = batadv_get_real_netdevice(net_device);\r\nif (!real_netdev)\r\nreturn wifi_flags;\r\nif (real_netdev == net_device)\r\ngoto out;\r\nif (batadv_is_wext_netdev(real_netdev))\r\nwifi_flags |= BATADV_HARDIF_WIFI_WEXT_INDIRECT;\r\nif (batadv_is_cfg80211_netdev(real_netdev))\r\nwifi_flags |= BATADV_HARDIF_WIFI_CFG80211_INDIRECT;\r\nout:\r\ndev_put(real_netdev);\r\nreturn wifi_flags;\r\n}\r\nbool batadv_is_cfg80211_hardif(struct batadv_hard_iface *hard_iface)\r\n{\r\nu32 allowed_flags = 0;\r\nallowed_flags |= BATADV_HARDIF_WIFI_CFG80211_DIRECT;\r\nallowed_flags |= BATADV_HARDIF_WIFI_CFG80211_INDIRECT;\r\nreturn !!(hard_iface->wifi_flags & allowed_flags);\r\n}\r\nbool batadv_is_wifi_hardif(struct batadv_hard_iface *hard_iface)\r\n{\r\nif (!hard_iface)\r\nreturn false;\r\nreturn hard_iface->wifi_flags != 0;\r\n}\r\nint batadv_hardif_no_broadcast(struct batadv_hard_iface *if_outgoing,\r\nu8 *orig_addr, u8 *orig_neigh)\r\n{\r\nstruct batadv_hardif_neigh_node *hardif_neigh;\r\nstruct hlist_node *first;\r\nint ret = BATADV_HARDIF_BCAST_OK;\r\nrcu_read_lock();\r\nfirst = rcu_dereference(hlist_first_rcu(&if_outgoing->neigh_list));\r\nif (!first) {\r\nret = BATADV_HARDIF_BCAST_NORECIPIENT;\r\ngoto out;\r\n}\r\nif (rcu_dereference(hlist_next_rcu(first)))\r\ngoto out;\r\nhardif_neigh = hlist_entry(first, struct batadv_hardif_neigh_node,\r\nlist);\r\nif (orig_addr && batadv_compare_eth(hardif_neigh->orig, orig_addr)) {\r\nret = BATADV_HARDIF_BCAST_DUPORIG;\r\n} else if (orig_neigh &&\r\nbatadv_compare_eth(hardif_neigh->orig, orig_neigh)) {\r\nret = BATADV_HARDIF_BCAST_DUPFWD;\r\n}\r\nout:\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nstatic struct batadv_hard_iface *\r\nbatadv_hardif_get_active(const struct net_device *soft_iface)\r\n{\r\nstruct batadv_hard_iface *hard_iface;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(hard_iface, &batadv_hardif_list, list) {\r\nif (hard_iface->soft_iface != soft_iface)\r\ncontinue;\r\nif (hard_iface->if_status == BATADV_IF_ACTIVE &&\r\nkref_get_unless_zero(&hard_iface->refcount))\r\ngoto out;\r\n}\r\nhard_iface = NULL;\r\nout:\r\nrcu_read_unlock();\r\nreturn hard_iface;\r\n}\r\nstatic void batadv_primary_if_update_addr(struct batadv_priv *bat_priv,\r\nstruct batadv_hard_iface *oldif)\r\n{\r\nstruct batadv_hard_iface *primary_if;\r\nprimary_if = batadv_primary_if_get_selected(bat_priv);\r\nif (!primary_if)\r\ngoto out;\r\nbatadv_dat_init_own_addr(bat_priv, primary_if);\r\nbatadv_bla_update_orig_address(bat_priv, primary_if, oldif);\r\nout:\r\nif (primary_if)\r\nbatadv_hardif_put(primary_if);\r\n}\r\nstatic void batadv_primary_if_select(struct batadv_priv *bat_priv,\r\nstruct batadv_hard_iface *new_hard_iface)\r\n{\r\nstruct batadv_hard_iface *curr_hard_iface;\r\nASSERT_RTNL();\r\nif (new_hard_iface)\r\nkref_get(&new_hard_iface->refcount);\r\ncurr_hard_iface = rcu_dereference_protected(bat_priv->primary_if, 1);\r\nrcu_assign_pointer(bat_priv->primary_if, new_hard_iface);\r\nif (!new_hard_iface)\r\ngoto out;\r\nbat_priv->algo_ops->iface.primary_set(new_hard_iface);\r\nbatadv_primary_if_update_addr(bat_priv, curr_hard_iface);\r\nout:\r\nif (curr_hard_iface)\r\nbatadv_hardif_put(curr_hard_iface);\r\n}\r\nstatic bool\r\nbatadv_hardif_is_iface_up(const struct batadv_hard_iface *hard_iface)\r\n{\r\nif (hard_iface->net_dev->flags & IFF_UP)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void batadv_check_known_mac_addr(const struct net_device *net_dev)\r\n{\r\nconst struct batadv_hard_iface *hard_iface;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(hard_iface, &batadv_hardif_list, list) {\r\nif ((hard_iface->if_status != BATADV_IF_ACTIVE) &&\r\n(hard_iface->if_status != BATADV_IF_TO_BE_ACTIVATED))\r\ncontinue;\r\nif (hard_iface->net_dev == net_dev)\r\ncontinue;\r\nif (!batadv_compare_eth(hard_iface->net_dev->dev_addr,\r\nnet_dev->dev_addr))\r\ncontinue;\r\npr_warn("The newly added mac address (%pM) already exists on: %s\n",\r\nnet_dev->dev_addr, hard_iface->net_dev->name);\r\npr_warn("It is strongly recommended to keep mac addresses unique to avoid problems!\n");\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic void batadv_hardif_recalc_extra_skbroom(struct net_device *soft_iface)\r\n{\r\nconst struct batadv_hard_iface *hard_iface;\r\nunsigned short lower_header_len = ETH_HLEN;\r\nunsigned short lower_headroom = 0;\r\nunsigned short lower_tailroom = 0;\r\nunsigned short needed_headroom;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(hard_iface, &batadv_hardif_list, list) {\r\nif (hard_iface->if_status == BATADV_IF_NOT_IN_USE)\r\ncontinue;\r\nif (hard_iface->soft_iface != soft_iface)\r\ncontinue;\r\nlower_header_len = max_t(unsigned short, lower_header_len,\r\nhard_iface->net_dev->hard_header_len);\r\nlower_headroom = max_t(unsigned short, lower_headroom,\r\nhard_iface->net_dev->needed_headroom);\r\nlower_tailroom = max_t(unsigned short, lower_tailroom,\r\nhard_iface->net_dev->needed_tailroom);\r\n}\r\nrcu_read_unlock();\r\nneeded_headroom = lower_headroom + (lower_header_len - ETH_HLEN);\r\nneeded_headroom += batadv_max_header_len();\r\nsoft_iface->needed_headroom = needed_headroom;\r\nsoft_iface->needed_tailroom = lower_tailroom;\r\n}\r\nint batadv_hardif_min_mtu(struct net_device *soft_iface)\r\n{\r\nstruct batadv_priv *bat_priv = netdev_priv(soft_iface);\r\nconst struct batadv_hard_iface *hard_iface;\r\nint min_mtu = INT_MAX;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(hard_iface, &batadv_hardif_list, list) {\r\nif ((hard_iface->if_status != BATADV_IF_ACTIVE) &&\r\n(hard_iface->if_status != BATADV_IF_TO_BE_ACTIVATED))\r\ncontinue;\r\nif (hard_iface->soft_iface != soft_iface)\r\ncontinue;\r\nmin_mtu = min_t(int, hard_iface->net_dev->mtu, min_mtu);\r\n}\r\nrcu_read_unlock();\r\nif (atomic_read(&bat_priv->fragmentation) == 0)\r\ngoto out;\r\nmin_mtu = min_t(int, min_mtu, BATADV_FRAG_MAX_FRAG_SIZE);\r\nmin_mtu -= sizeof(struct batadv_frag_packet);\r\nmin_mtu *= BATADV_FRAG_MAX_FRAGMENTS;\r\nout:\r\natomic_set(&bat_priv->packet_size_max, min_mtu);\r\nreturn min_t(int, min_mtu - batadv_max_header_len(), ETH_DATA_LEN);\r\n}\r\nvoid batadv_update_min_mtu(struct net_device *soft_iface)\r\n{\r\nsoft_iface->mtu = batadv_hardif_min_mtu(soft_iface);\r\nbatadv_tt_local_resize_to_mtu(soft_iface);\r\n}\r\nstatic void\r\nbatadv_hardif_activate_interface(struct batadv_hard_iface *hard_iface)\r\n{\r\nstruct batadv_priv *bat_priv;\r\nstruct batadv_hard_iface *primary_if = NULL;\r\nif (hard_iface->if_status != BATADV_IF_INACTIVE)\r\ngoto out;\r\nbat_priv = netdev_priv(hard_iface->soft_iface);\r\nbat_priv->algo_ops->iface.update_mac(hard_iface);\r\nhard_iface->if_status = BATADV_IF_TO_BE_ACTIVATED;\r\nprimary_if = batadv_primary_if_get_selected(bat_priv);\r\nif (!primary_if)\r\nbatadv_primary_if_select(bat_priv, hard_iface);\r\nbatadv_info(hard_iface->soft_iface, "Interface activated: %s\n",\r\nhard_iface->net_dev->name);\r\nbatadv_update_min_mtu(hard_iface->soft_iface);\r\nif (bat_priv->algo_ops->iface.activate)\r\nbat_priv->algo_ops->iface.activate(hard_iface);\r\nout:\r\nif (primary_if)\r\nbatadv_hardif_put(primary_if);\r\n}\r\nstatic void\r\nbatadv_hardif_deactivate_interface(struct batadv_hard_iface *hard_iface)\r\n{\r\nif ((hard_iface->if_status != BATADV_IF_ACTIVE) &&\r\n(hard_iface->if_status != BATADV_IF_TO_BE_ACTIVATED))\r\nreturn;\r\nhard_iface->if_status = BATADV_IF_INACTIVE;\r\nbatadv_info(hard_iface->soft_iface, "Interface deactivated: %s\n",\r\nhard_iface->net_dev->name);\r\nbatadv_update_min_mtu(hard_iface->soft_iface);\r\n}\r\nstatic int batadv_master_del_slave(struct batadv_hard_iface *slave,\r\nstruct net_device *master)\r\n{\r\nint ret;\r\nif (!master)\r\nreturn 0;\r\nret = -EBUSY;\r\nif (master->netdev_ops->ndo_del_slave)\r\nret = master->netdev_ops->ndo_del_slave(master, slave->net_dev);\r\nreturn ret;\r\n}\r\nint batadv_hardif_enable_interface(struct batadv_hard_iface *hard_iface,\r\nstruct net *net, const char *iface_name)\r\n{\r\nstruct batadv_priv *bat_priv;\r\nstruct net_device *soft_iface, *master;\r\n__be16 ethertype = htons(ETH_P_BATMAN);\r\nint max_header_len = batadv_max_header_len();\r\nint ret;\r\nif (hard_iface->if_status != BATADV_IF_NOT_IN_USE)\r\ngoto out;\r\nkref_get(&hard_iface->refcount);\r\nsoft_iface = dev_get_by_name(net, iface_name);\r\nif (!soft_iface) {\r\nsoft_iface = batadv_softif_create(net, iface_name);\r\nif (!soft_iface) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\ndev_hold(soft_iface);\r\n}\r\nif (!batadv_softif_is_valid(soft_iface)) {\r\npr_err("Can't create batman mesh interface %s: already exists as regular interface\n",\r\nsoft_iface->name);\r\nret = -EINVAL;\r\ngoto err_dev;\r\n}\r\nmaster = netdev_master_upper_dev_get(hard_iface->net_dev);\r\nret = batadv_master_del_slave(hard_iface, master);\r\nif (ret)\r\ngoto err_dev;\r\nhard_iface->soft_iface = soft_iface;\r\nbat_priv = netdev_priv(hard_iface->soft_iface);\r\nret = netdev_master_upper_dev_link(hard_iface->net_dev,\r\nsoft_iface, NULL, NULL);\r\nif (ret)\r\ngoto err_dev;\r\nret = bat_priv->algo_ops->iface.enable(hard_iface);\r\nif (ret < 0)\r\ngoto err_upper;\r\nhard_iface->if_num = bat_priv->num_ifaces;\r\nbat_priv->num_ifaces++;\r\nhard_iface->if_status = BATADV_IF_INACTIVE;\r\nret = batadv_orig_hash_add_if(hard_iface, bat_priv->num_ifaces);\r\nif (ret < 0) {\r\nbat_priv->algo_ops->iface.disable(hard_iface);\r\nbat_priv->num_ifaces--;\r\nhard_iface->if_status = BATADV_IF_NOT_IN_USE;\r\ngoto err_upper;\r\n}\r\nkref_get(&hard_iface->refcount);\r\nhard_iface->batman_adv_ptype.type = ethertype;\r\nhard_iface->batman_adv_ptype.func = batadv_batman_skb_recv;\r\nhard_iface->batman_adv_ptype.dev = hard_iface->net_dev;\r\ndev_add_pack(&hard_iface->batman_adv_ptype);\r\nbatadv_info(hard_iface->soft_iface, "Adding interface: %s\n",\r\nhard_iface->net_dev->name);\r\nif (atomic_read(&bat_priv->fragmentation) &&\r\nhard_iface->net_dev->mtu < ETH_DATA_LEN + max_header_len)\r\nbatadv_info(hard_iface->soft_iface,\r\n"The MTU of interface %s is too small (%i) to handle the transport of batman-adv packets. Packets going over this interface will be fragmented on layer2 which could impact the performance. Setting the MTU to %i would solve the problem.\n",\r\nhard_iface->net_dev->name, hard_iface->net_dev->mtu,\r\nETH_DATA_LEN + max_header_len);\r\nif (!atomic_read(&bat_priv->fragmentation) &&\r\nhard_iface->net_dev->mtu < ETH_DATA_LEN + max_header_len)\r\nbatadv_info(hard_iface->soft_iface,\r\n"The MTU of interface %s is too small (%i) to handle the transport of batman-adv packets. If you experience problems getting traffic through try increasing the MTU to %i.\n",\r\nhard_iface->net_dev->name, hard_iface->net_dev->mtu,\r\nETH_DATA_LEN + max_header_len);\r\nif (batadv_hardif_is_iface_up(hard_iface))\r\nbatadv_hardif_activate_interface(hard_iface);\r\nelse\r\nbatadv_err(hard_iface->soft_iface,\r\n"Not using interface %s (retrying later): interface not active\n",\r\nhard_iface->net_dev->name);\r\nbatadv_hardif_recalc_extra_skbroom(soft_iface);\r\nout:\r\nreturn 0;\r\nerr_upper:\r\nnetdev_upper_dev_unlink(hard_iface->net_dev, soft_iface);\r\nerr_dev:\r\nhard_iface->soft_iface = NULL;\r\ndev_put(soft_iface);\r\nerr:\r\nbatadv_hardif_put(hard_iface);\r\nreturn ret;\r\n}\r\nvoid batadv_hardif_disable_interface(struct batadv_hard_iface *hard_iface,\r\nenum batadv_hard_if_cleanup autodel)\r\n{\r\nstruct batadv_priv *bat_priv = netdev_priv(hard_iface->soft_iface);\r\nstruct batadv_hard_iface *primary_if = NULL;\r\nbatadv_hardif_deactivate_interface(hard_iface);\r\nif (hard_iface->if_status != BATADV_IF_INACTIVE)\r\ngoto out;\r\nbatadv_info(hard_iface->soft_iface, "Removing interface: %s\n",\r\nhard_iface->net_dev->name);\r\ndev_remove_pack(&hard_iface->batman_adv_ptype);\r\nbatadv_hardif_put(hard_iface);\r\nbat_priv->num_ifaces--;\r\nbatadv_orig_hash_del_if(hard_iface, bat_priv->num_ifaces);\r\nprimary_if = batadv_primary_if_get_selected(bat_priv);\r\nif (hard_iface == primary_if) {\r\nstruct batadv_hard_iface *new_if;\r\nnew_if = batadv_hardif_get_active(hard_iface->soft_iface);\r\nbatadv_primary_if_select(bat_priv, new_if);\r\nif (new_if)\r\nbatadv_hardif_put(new_if);\r\n}\r\nbat_priv->algo_ops->iface.disable(hard_iface);\r\nhard_iface->if_status = BATADV_IF_NOT_IN_USE;\r\nbatadv_purge_orig_ref(bat_priv);\r\nbatadv_purge_outstanding_packets(bat_priv, hard_iface);\r\ndev_put(hard_iface->soft_iface);\r\nnetdev_upper_dev_unlink(hard_iface->net_dev, hard_iface->soft_iface);\r\nbatadv_hardif_recalc_extra_skbroom(hard_iface->soft_iface);\r\nif (!bat_priv->num_ifaces) {\r\nbatadv_gw_check_client_stop(bat_priv);\r\nif (autodel == BATADV_IF_CLEANUP_AUTO)\r\nbatadv_softif_destroy_sysfs(hard_iface->soft_iface);\r\n}\r\nhard_iface->soft_iface = NULL;\r\nbatadv_hardif_put(hard_iface);\r\nout:\r\nif (primary_if)\r\nbatadv_hardif_put(primary_if);\r\n}\r\nstatic struct batadv_hard_iface *\r\nbatadv_hardif_add_interface(struct net_device *net_dev)\r\n{\r\nstruct batadv_hard_iface *hard_iface;\r\nint ret;\r\nASSERT_RTNL();\r\nif (!batadv_is_valid_iface(net_dev))\r\ngoto out;\r\ndev_hold(net_dev);\r\nhard_iface = kzalloc(sizeof(*hard_iface), GFP_ATOMIC);\r\nif (!hard_iface)\r\ngoto release_dev;\r\nret = batadv_sysfs_add_hardif(&hard_iface->hardif_obj, net_dev);\r\nif (ret)\r\ngoto free_if;\r\nhard_iface->if_num = -1;\r\nhard_iface->net_dev = net_dev;\r\nhard_iface->soft_iface = NULL;\r\nhard_iface->if_status = BATADV_IF_NOT_IN_USE;\r\nret = batadv_debugfs_add_hardif(hard_iface);\r\nif (ret)\r\ngoto free_sysfs;\r\nINIT_LIST_HEAD(&hard_iface->list);\r\nINIT_HLIST_HEAD(&hard_iface->neigh_list);\r\nspin_lock_init(&hard_iface->neigh_list_lock);\r\nkref_init(&hard_iface->refcount);\r\nhard_iface->num_bcasts = BATADV_NUM_BCASTS_DEFAULT;\r\nhard_iface->wifi_flags = batadv_wifi_flags_evaluate(net_dev);\r\nif (batadv_is_wifi_hardif(hard_iface))\r\nhard_iface->num_bcasts = BATADV_NUM_BCASTS_WIRELESS;\r\nbatadv_v_hardif_init(hard_iface);\r\nbatadv_check_known_mac_addr(hard_iface->net_dev);\r\nkref_get(&hard_iface->refcount);\r\nlist_add_tail_rcu(&hard_iface->list, &batadv_hardif_list);\r\nreturn hard_iface;\r\nfree_sysfs:\r\nbatadv_sysfs_del_hardif(&hard_iface->hardif_obj);\r\nfree_if:\r\nkfree(hard_iface);\r\nrelease_dev:\r\ndev_put(net_dev);\r\nout:\r\nreturn NULL;\r\n}\r\nstatic void batadv_hardif_remove_interface(struct batadv_hard_iface *hard_iface)\r\n{\r\nASSERT_RTNL();\r\nif (hard_iface->if_status != BATADV_IF_NOT_IN_USE)\r\nbatadv_hardif_disable_interface(hard_iface,\r\nBATADV_IF_CLEANUP_KEEP);\r\nif (hard_iface->if_status != BATADV_IF_NOT_IN_USE)\r\nreturn;\r\nhard_iface->if_status = BATADV_IF_TO_BE_REMOVED;\r\nbatadv_debugfs_del_hardif(hard_iface);\r\nbatadv_sysfs_del_hardif(&hard_iface->hardif_obj);\r\nbatadv_hardif_put(hard_iface);\r\n}\r\nvoid batadv_hardif_remove_interfaces(void)\r\n{\r\nstruct batadv_hard_iface *hard_iface, *hard_iface_tmp;\r\nrtnl_lock();\r\nlist_for_each_entry_safe(hard_iface, hard_iface_tmp,\r\n&batadv_hardif_list, list) {\r\nlist_del_rcu(&hard_iface->list);\r\nbatadv_hardif_remove_interface(hard_iface);\r\n}\r\nrtnl_unlock();\r\n}\r\nstatic int batadv_hard_if_event(struct notifier_block *this,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct net_device *net_dev = netdev_notifier_info_to_dev(ptr);\r\nstruct batadv_hard_iface *hard_iface;\r\nstruct batadv_hard_iface *primary_if = NULL;\r\nstruct batadv_priv *bat_priv;\r\nif (batadv_softif_is_valid(net_dev) && event == NETDEV_REGISTER) {\r\nbatadv_sysfs_add_meshif(net_dev);\r\nbat_priv = netdev_priv(net_dev);\r\nbatadv_softif_create_vlan(bat_priv, BATADV_NO_FLAGS);\r\nreturn NOTIFY_DONE;\r\n}\r\nhard_iface = batadv_hardif_get_by_netdev(net_dev);\r\nif (!hard_iface && (event == NETDEV_REGISTER ||\r\nevent == NETDEV_POST_TYPE_CHANGE))\r\nhard_iface = batadv_hardif_add_interface(net_dev);\r\nif (!hard_iface)\r\ngoto out;\r\nswitch (event) {\r\ncase NETDEV_UP:\r\nbatadv_hardif_activate_interface(hard_iface);\r\nbreak;\r\ncase NETDEV_GOING_DOWN:\r\ncase NETDEV_DOWN:\r\nbatadv_hardif_deactivate_interface(hard_iface);\r\nbreak;\r\ncase NETDEV_UNREGISTER:\r\ncase NETDEV_PRE_TYPE_CHANGE:\r\nlist_del_rcu(&hard_iface->list);\r\nbatadv_hardif_remove_interface(hard_iface);\r\nbreak;\r\ncase NETDEV_CHANGEMTU:\r\nif (hard_iface->soft_iface)\r\nbatadv_update_min_mtu(hard_iface->soft_iface);\r\nbreak;\r\ncase NETDEV_CHANGEADDR:\r\nif (hard_iface->if_status == BATADV_IF_NOT_IN_USE)\r\ngoto hardif_put;\r\nbatadv_check_known_mac_addr(hard_iface->net_dev);\r\nbat_priv = netdev_priv(hard_iface->soft_iface);\r\nbat_priv->algo_ops->iface.update_mac(hard_iface);\r\nprimary_if = batadv_primary_if_get_selected(bat_priv);\r\nif (!primary_if)\r\ngoto hardif_put;\r\nif (hard_iface == primary_if)\r\nbatadv_primary_if_update_addr(bat_priv, NULL);\r\nbreak;\r\ncase NETDEV_CHANGEUPPER:\r\nhard_iface->wifi_flags = batadv_wifi_flags_evaluate(net_dev);\r\nif (batadv_is_wifi_hardif(hard_iface))\r\nhard_iface->num_bcasts = BATADV_NUM_BCASTS_WIRELESS;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nhardif_put:\r\nbatadv_hardif_put(hard_iface);\r\nout:\r\nif (primary_if)\r\nbatadv_hardif_put(primary_if);\r\nreturn NOTIFY_DONE;\r\n}
