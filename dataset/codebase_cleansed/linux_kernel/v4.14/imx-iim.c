static int imx_iim_read(void *context, unsigned int offset,\r\nvoid *buf, size_t bytes)\r\n{\r\nstruct iim_priv *iim = context;\r\nint i, ret;\r\nu8 *buf8 = buf;\r\nret = clk_prepare_enable(iim->clk);\r\nif (ret)\r\nreturn ret;\r\nfor (i = offset; i < offset + bytes; i++) {\r\nint bank = i >> 5;\r\nint reg = i & 0x1f;\r\n*buf8++ = readl(iim->base + IIM_BANK_BASE(bank) + reg * 4);\r\n}\r\nclk_disable_unprepare(iim->clk);\r\nreturn 0;\r\n}\r\nstatic int imx_iim_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *of_id;\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *res;\r\nstruct iim_priv *iim;\r\nstruct nvmem_device *nvmem;\r\nstruct nvmem_config *cfg;\r\nconst struct imx_iim_drvdata *drvdata = NULL;\r\niim = devm_kzalloc(dev, sizeof(*iim), GFP_KERNEL);\r\nif (!iim)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\niim->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(iim->base))\r\nreturn PTR_ERR(iim->base);\r\nof_id = of_match_device(imx_iim_dt_ids, dev);\r\nif (!of_id)\r\nreturn -ENODEV;\r\ndrvdata = of_id->data;\r\niim->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(iim->clk))\r\nreturn PTR_ERR(iim->clk);\r\ncfg = &iim->nvmem;\r\ncfg->name = "imx-iim",\r\ncfg->read_only = true,\r\ncfg->word_size = 1,\r\ncfg->stride = 1,\r\ncfg->owner = THIS_MODULE,\r\ncfg->reg_read = imx_iim_read,\r\ncfg->dev = dev;\r\ncfg->size = drvdata->nregs;\r\ncfg->priv = iim;\r\nnvmem = nvmem_register(cfg);\r\nif (IS_ERR(nvmem))\r\nreturn PTR_ERR(nvmem);\r\nplatform_set_drvdata(pdev, nvmem);\r\nreturn 0;\r\n}\r\nstatic int imx_iim_remove(struct platform_device *pdev)\r\n{\r\nstruct nvmem_device *nvmem = platform_get_drvdata(pdev);\r\nreturn nvmem_unregister(nvmem);\r\n}
