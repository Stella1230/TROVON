static void bcm6328_led_write(void __iomem *reg, unsigned long data)\r\n{\r\n#ifdef CONFIG_CPU_BIG_ENDIAN\r\niowrite32be(data, reg);\r\n#else\r\nwritel(data, reg);\r\n#endif\r\n}\r\nstatic unsigned long bcm6328_led_read(void __iomem *reg)\r\n{\r\n#ifdef CONFIG_CPU_BIG_ENDIAN\r\nreturn ioread32be(reg);\r\n#else\r\nreturn readl(reg);\r\n#endif\r\n}\r\nstatic unsigned long bcm6328_pin2shift(unsigned long pin)\r\n{\r\nif (pin < 8)\r\nreturn pin + 16;\r\nelse\r\nreturn pin - 8;\r\n}\r\nstatic void bcm6328_led_mode(struct bcm6328_led *led, unsigned long value)\r\n{\r\nvoid __iomem *mode;\r\nunsigned long val, shift;\r\nshift = bcm6328_pin2shift(led->pin);\r\nif (shift / 16)\r\nmode = led->mem + BCM6328_REG_MODE_HI;\r\nelse\r\nmode = led->mem + BCM6328_REG_MODE_LO;\r\nval = bcm6328_led_read(mode);\r\nval &= ~(BCM6328_LED_MODE_MASK << BCM6328_LED_SHIFT(shift % 16));\r\nval |= (value << BCM6328_LED_SHIFT(shift % 16));\r\nbcm6328_led_write(mode, val);\r\n}\r\nstatic void bcm6328_led_set(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct bcm6328_led *led =\r\ncontainer_of(led_cdev, struct bcm6328_led, cdev);\r\nunsigned long flags;\r\nspin_lock_irqsave(led->lock, flags);\r\n*(led->blink_leds) &= ~BIT(led->pin);\r\nif ((led->active_low && value == LED_OFF) ||\r\n(!led->active_low && value != LED_OFF))\r\nbcm6328_led_mode(led, BCM6328_LED_MODE_ON);\r\nelse\r\nbcm6328_led_mode(led, BCM6328_LED_MODE_OFF);\r\nspin_unlock_irqrestore(led->lock, flags);\r\n}\r\nstatic unsigned long bcm6328_blink_delay(unsigned long delay)\r\n{\r\nunsigned long bcm6328_delay;\r\nbcm6328_delay = delay + BCM6328_LED_INTERVAL_MS / 2;\r\nbcm6328_delay = bcm6328_delay / BCM6328_LED_INTERVAL_MS;\r\nif (bcm6328_delay == 0)\r\nbcm6328_delay = 1;\r\nreturn bcm6328_delay;\r\n}\r\nstatic int bcm6328_blink_set(struct led_classdev *led_cdev,\r\nunsigned long *delay_on, unsigned long *delay_off)\r\n{\r\nstruct bcm6328_led *led =\r\ncontainer_of(led_cdev, struct bcm6328_led, cdev);\r\nunsigned long delay, flags;\r\nint rc;\r\nif (!*delay_on)\r\n*delay_on = BCM6328_LED_DEF_DELAY;\r\nif (!*delay_off)\r\n*delay_off = BCM6328_LED_DEF_DELAY;\r\ndelay = bcm6328_blink_delay(*delay_on);\r\nif (delay != bcm6328_blink_delay(*delay_off)) {\r\ndev_dbg(led_cdev->dev,\r\n"fallback to soft blinking (delay_on != delay_off)\n");\r\nreturn -EINVAL;\r\n}\r\nif (delay > BCM6328_LED_INTV_MASK) {\r\ndev_dbg(led_cdev->dev,\r\n"fallback to soft blinking (delay > %ums)\n",\r\nBCM6328_LED_INTV_MASK * BCM6328_LED_INTERVAL_MS);\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(led->lock, flags);\r\nif (*(led->blink_leds) == 0 ||\r\n*(led->blink_leds) == BIT(led->pin) ||\r\n*(led->blink_delay) == delay) {\r\nunsigned long val;\r\n*(led->blink_leds) |= BIT(led->pin);\r\n*(led->blink_delay) = delay;\r\nval = bcm6328_led_read(led->mem + BCM6328_REG_INIT);\r\nval &= ~BCM6328_LED_FAST_INTV_MASK;\r\nval |= (delay << BCM6328_LED_FAST_INTV_SHIFT);\r\nbcm6328_led_write(led->mem + BCM6328_REG_INIT, val);\r\nbcm6328_led_mode(led, BCM6328_LED_MODE_BLINK);\r\nrc = 0;\r\n} else {\r\ndev_dbg(led_cdev->dev,\r\n"fallback to soft blinking (delay already set)\n");\r\nrc = -EINVAL;\r\n}\r\nspin_unlock_irqrestore(led->lock, flags);\r\nreturn rc;\r\n}\r\nstatic int bcm6328_hwled(struct device *dev, struct device_node *nc, u32 reg,\r\nvoid __iomem *mem, spinlock_t *lock)\r\n{\r\nint i, cnt;\r\nunsigned long flags, val;\r\nspin_lock_irqsave(lock, flags);\r\nval = bcm6328_led_read(mem + BCM6328_REG_HWDIS);\r\nval &= ~BIT(reg);\r\nbcm6328_led_write(mem + BCM6328_REG_HWDIS, val);\r\nspin_unlock_irqrestore(lock, flags);\r\nif (reg >= 8)\r\nreturn 0;\r\ncnt = of_property_count_elems_of_size(nc, "brcm,link-signal-sources",\r\nsizeof(u32));\r\nfor (i = 0; i < cnt; i++) {\r\nu32 sel;\r\nvoid __iomem *addr;\r\nif (reg < 4)\r\naddr = mem + BCM6328_REG_LNKACTSEL_LO;\r\nelse\r\naddr = mem + BCM6328_REG_LNKACTSEL_HI;\r\nof_property_read_u32_index(nc, "brcm,link-signal-sources", i,\r\n&sel);\r\nif (reg / 4 != sel / 4) {\r\ndev_warn(dev, "invalid link signal source\n");\r\ncontinue;\r\n}\r\nspin_lock_irqsave(lock, flags);\r\nval = bcm6328_led_read(addr);\r\nval |= (BIT(reg % 4) << (((sel % 4) * 4) + 16));\r\nbcm6328_led_write(addr, val);\r\nspin_unlock_irqrestore(lock, flags);\r\n}\r\ncnt = of_property_count_elems_of_size(nc,\r\n"brcm,activity-signal-sources",\r\nsizeof(u32));\r\nfor (i = 0; i < cnt; i++) {\r\nu32 sel;\r\nvoid __iomem *addr;\r\nif (reg < 4)\r\naddr = mem + BCM6328_REG_LNKACTSEL_LO;\r\nelse\r\naddr = mem + BCM6328_REG_LNKACTSEL_HI;\r\nof_property_read_u32_index(nc, "brcm,activity-signal-sources",\r\ni, &sel);\r\nif (reg / 4 != sel / 4) {\r\ndev_warn(dev, "invalid activity signal source\n");\r\ncontinue;\r\n}\r\nspin_lock_irqsave(lock, flags);\r\nval = bcm6328_led_read(addr);\r\nval |= (BIT(reg % 4) << ((sel % 4) * 4));\r\nbcm6328_led_write(addr, val);\r\nspin_unlock_irqrestore(lock, flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic int bcm6328_led(struct device *dev, struct device_node *nc, u32 reg,\r\nvoid __iomem *mem, spinlock_t *lock,\r\nunsigned long *blink_leds, unsigned long *blink_delay)\r\n{\r\nstruct bcm6328_led *led;\r\nconst char *state;\r\nint rc;\r\nled = devm_kzalloc(dev, sizeof(*led), GFP_KERNEL);\r\nif (!led)\r\nreturn -ENOMEM;\r\nled->pin = reg;\r\nled->mem = mem;\r\nled->lock = lock;\r\nled->blink_leds = blink_leds;\r\nled->blink_delay = blink_delay;\r\nif (of_property_read_bool(nc, "active-low"))\r\nled->active_low = true;\r\nled->cdev.name = of_get_property(nc, "label", NULL) ? : nc->name;\r\nled->cdev.default_trigger = of_get_property(nc,\r\n"linux,default-trigger",\r\nNULL);\r\nif (!of_property_read_string(nc, "default-state", &state)) {\r\nif (!strcmp(state, "on")) {\r\nled->cdev.brightness = LED_FULL;\r\n} else if (!strcmp(state, "keep")) {\r\nvoid __iomem *mode;\r\nunsigned long val, shift;\r\nshift = bcm6328_pin2shift(led->pin);\r\nif (shift / 16)\r\nmode = mem + BCM6328_REG_MODE_HI;\r\nelse\r\nmode = mem + BCM6328_REG_MODE_LO;\r\nval = bcm6328_led_read(mode) >>\r\nBCM6328_LED_SHIFT(shift % 16);\r\nval &= BCM6328_LED_MODE_MASK;\r\nif ((led->active_low && val == BCM6328_LED_MODE_OFF) ||\r\n(!led->active_low && val == BCM6328_LED_MODE_ON))\r\nled->cdev.brightness = LED_FULL;\r\nelse\r\nled->cdev.brightness = LED_OFF;\r\n} else {\r\nled->cdev.brightness = LED_OFF;\r\n}\r\n} else {\r\nled->cdev.brightness = LED_OFF;\r\n}\r\nbcm6328_led_set(&led->cdev, led->cdev.brightness);\r\nled->cdev.brightness_set = bcm6328_led_set;\r\nled->cdev.blink_set = bcm6328_blink_set;\r\nrc = led_classdev_register(dev, &led->cdev);\r\nif (rc < 0)\r\nreturn rc;\r\ndev_dbg(dev, "registered LED %s\n", led->cdev.name);\r\nreturn 0;\r\n}\r\nstatic int bcm6328_leds_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct device_node *child;\r\nstruct resource *mem_r;\r\nvoid __iomem *mem;\r\nspinlock_t *lock;\r\nunsigned long val, *blink_leds, *blink_delay;\r\nmem_r = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!mem_r)\r\nreturn -EINVAL;\r\nmem = devm_ioremap_resource(dev, mem_r);\r\nif (IS_ERR(mem))\r\nreturn PTR_ERR(mem);\r\nlock = devm_kzalloc(dev, sizeof(*lock), GFP_KERNEL);\r\nif (!lock)\r\nreturn -ENOMEM;\r\nblink_leds = devm_kzalloc(dev, sizeof(*blink_leds), GFP_KERNEL);\r\nif (!blink_leds)\r\nreturn -ENOMEM;\r\nblink_delay = devm_kzalloc(dev, sizeof(*blink_delay), GFP_KERNEL);\r\nif (!blink_delay)\r\nreturn -ENOMEM;\r\nspin_lock_init(lock);\r\nbcm6328_led_write(mem + BCM6328_REG_HWDIS, ~0);\r\nbcm6328_led_write(mem + BCM6328_REG_LNKACTSEL_HI, 0);\r\nbcm6328_led_write(mem + BCM6328_REG_LNKACTSEL_LO, 0);\r\nval = bcm6328_led_read(mem + BCM6328_REG_INIT);\r\nval &= ~(BCM6328_INIT_MASK);\r\nif (of_property_read_bool(np, "brcm,serial-leds"))\r\nval |= BCM6328_SERIAL_LED_EN;\r\nif (of_property_read_bool(np, "brcm,serial-mux"))\r\nval |= BCM6328_SERIAL_LED_MUX;\r\nif (of_property_read_bool(np, "brcm,serial-clk-low"))\r\nval |= BCM6328_SERIAL_LED_CLK_NPOL;\r\nif (!of_property_read_bool(np, "brcm,serial-dat-low"))\r\nval |= BCM6328_SERIAL_LED_DATA_PPOL;\r\nif (!of_property_read_bool(np, "brcm,serial-shift-inv"))\r\nval |= BCM6328_SERIAL_LED_SHIFT_DIR;\r\nbcm6328_led_write(mem + BCM6328_REG_INIT, val);\r\nfor_each_available_child_of_node(np, child) {\r\nint rc;\r\nu32 reg;\r\nif (of_property_read_u32(child, "reg", &reg))\r\ncontinue;\r\nif (reg >= BCM6328_LED_MAX_COUNT) {\r\ndev_err(dev, "invalid LED (%u >= %d)\n", reg,\r\nBCM6328_LED_MAX_COUNT);\r\ncontinue;\r\n}\r\nif (of_property_read_bool(child, "brcm,hardware-controlled"))\r\nrc = bcm6328_hwled(dev, child, reg, mem, lock);\r\nelse\r\nrc = bcm6328_led(dev, child, reg, mem, lock,\r\nblink_leds, blink_delay);\r\nif (rc < 0) {\r\nof_node_put(child);\r\nreturn rc;\r\n}\r\n}\r\nreturn 0;\r\n}
