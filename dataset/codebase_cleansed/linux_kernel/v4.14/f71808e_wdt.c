static inline int superio_inb(int base, int reg)\r\n{\r\noutb(reg, base);\r\nreturn inb(base + 1);\r\n}\r\nstatic int superio_inw(int base, int reg)\r\n{\r\nint val;\r\nval = superio_inb(base, reg) << 8;\r\nval |= superio_inb(base, reg + 1);\r\nreturn val;\r\n}\r\nstatic inline void superio_outb(int base, int reg, u8 val)\r\n{\r\noutb(reg, base);\r\noutb(val, base + 1);\r\n}\r\nstatic inline void superio_set_bit(int base, int reg, int bit)\r\n{\r\nunsigned long val = superio_inb(base, reg);\r\n__set_bit(bit, &val);\r\nsuperio_outb(base, reg, val);\r\n}\r\nstatic inline void superio_clear_bit(int base, int reg, int bit)\r\n{\r\nunsigned long val = superio_inb(base, reg);\r\n__clear_bit(bit, &val);\r\nsuperio_outb(base, reg, val);\r\n}\r\nstatic inline int superio_enter(int base)\r\n{\r\nif (!request_muxed_region(base, 2, DRVNAME)) {\r\npr_err("I/O address 0x%04x already in use\n", (int)base);\r\nreturn -EBUSY;\r\n}\r\noutb(SIO_UNLOCK_KEY, base);\r\noutb(SIO_UNLOCK_KEY, base);\r\nreturn 0;\r\n}\r\nstatic inline void superio_select(int base, int ld)\r\n{\r\noutb(SIO_REG_LDSEL, base);\r\noutb(ld, base + 1);\r\n}\r\nstatic inline void superio_exit(int base)\r\n{\r\noutb(SIO_LOCK_KEY, base);\r\nrelease_region(base, 2);\r\n}\r\nstatic int watchdog_set_timeout(int timeout)\r\n{\r\nif (timeout <= 0\r\n|| timeout > max_timeout) {\r\npr_err("watchdog timeout out of range\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&watchdog.lock);\r\nwatchdog.timeout = timeout;\r\nif (timeout > 0xff) {\r\nwatchdog.timer_val = DIV_ROUND_UP(timeout, 60);\r\nwatchdog.minutes_mode = true;\r\n} else {\r\nwatchdog.timer_val = timeout;\r\nwatchdog.minutes_mode = false;\r\n}\r\nmutex_unlock(&watchdog.lock);\r\nreturn 0;\r\n}\r\nstatic int watchdog_set_pulse_width(unsigned int pw)\r\n{\r\nint err = 0;\r\nunsigned int t1 = 25, t2 = 125, t3 = 5000;\r\nif (watchdog.type == f71868) {\r\nt1 = 30;\r\nt2 = 150;\r\nt3 = 6000;\r\n}\r\nmutex_lock(&watchdog.lock);\r\nif (pw <= 1) {\r\nwatchdog.pulse_val = 0;\r\n} else if (pw <= t1) {\r\nwatchdog.pulse_val = 1;\r\n} else if (pw <= t2) {\r\nwatchdog.pulse_val = 2;\r\n} else if (pw <= t3) {\r\nwatchdog.pulse_val = 3;\r\n} else {\r\npr_err("pulse width out of range\n");\r\nerr = -EINVAL;\r\ngoto exit_unlock;\r\n}\r\nwatchdog.pulse_mode = pw;\r\nexit_unlock:\r\nmutex_unlock(&watchdog.lock);\r\nreturn err;\r\n}\r\nstatic int watchdog_keepalive(void)\r\n{\r\nint err = 0;\r\nmutex_lock(&watchdog.lock);\r\nerr = superio_enter(watchdog.sioaddr);\r\nif (err)\r\ngoto exit_unlock;\r\nsuperio_select(watchdog.sioaddr, SIO_F71808FG_LD_WDT);\r\nif (watchdog.minutes_mode)\r\nsuperio_set_bit(watchdog.sioaddr, F71808FG_REG_WDT_CONF,\r\nF71808FG_FLAG_WD_UNIT);\r\nelse\r\nsuperio_clear_bit(watchdog.sioaddr, F71808FG_REG_WDT_CONF,\r\nF71808FG_FLAG_WD_UNIT);\r\nsuperio_outb(watchdog.sioaddr, F71808FG_REG_WD_TIME,\r\nwatchdog.timer_val);\r\nsuperio_exit(watchdog.sioaddr);\r\nexit_unlock:\r\nmutex_unlock(&watchdog.lock);\r\nreturn err;\r\n}\r\nstatic int f71862fg_pin_configure(unsigned short ioaddr)\r\n{\r\nif (f71862fg_pin == 63) {\r\nif (ioaddr) {\r\nsuperio_clear_bit(ioaddr, SIO_REG_ROM_ADDR_SEL, 6);\r\nsuperio_set_bit(ioaddr, SIO_REG_MFUNCT3, 4);\r\n}\r\n} else if (f71862fg_pin == 56) {\r\nif (ioaddr)\r\nsuperio_set_bit(ioaddr, SIO_REG_MFUNCT1, 1);\r\n} else {\r\npr_err("Invalid argument f71862fg_pin=%d\n", f71862fg_pin);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int watchdog_start(void)\r\n{\r\nint err = watchdog_keepalive();\r\nif (err)\r\nreturn err;\r\nmutex_lock(&watchdog.lock);\r\nerr = superio_enter(watchdog.sioaddr);\r\nif (err)\r\ngoto exit_unlock;\r\nsuperio_select(watchdog.sioaddr, SIO_F71808FG_LD_WDT);\r\nswitch (watchdog.type) {\r\ncase f71808fg:\r\nsuperio_clear_bit(watchdog.sioaddr, SIO_REG_MFUNCT2, 3);\r\nsuperio_clear_bit(watchdog.sioaddr, SIO_REG_MFUNCT3, 3);\r\nbreak;\r\ncase f71862fg:\r\nerr = f71862fg_pin_configure(watchdog.sioaddr);\r\nif (err)\r\ngoto exit_superio;\r\nbreak;\r\ncase f71868:\r\ncase f71869:\r\nsuperio_clear_bit(watchdog.sioaddr, SIO_REG_MFUNCT1, 4);\r\nbreak;\r\ncase f71882fg:\r\nsuperio_set_bit(watchdog.sioaddr, SIO_REG_MFUNCT1, 1);\r\nbreak;\r\ncase f71889fg:\r\nsuperio_outb(watchdog.sioaddr, SIO_REG_MFUNCT3,\r\nsuperio_inb(watchdog.sioaddr, SIO_REG_MFUNCT3) & 0xcf);\r\nbreak;\r\ncase f81865:\r\nsuperio_clear_bit(watchdog.sioaddr, SIO_REG_MFUNCT3, 5);\r\nbreak;\r\ncase f81866:\r\nsuperio_clear_bit(watchdog.sioaddr, SIO_F81866_REG_PORT_SEL,\r\nBIT(3) | BIT(0));\r\nsuperio_set_bit(watchdog.sioaddr, SIO_F81866_REG_PORT_SEL,\r\nBIT(2));\r\nsuperio_clear_bit(watchdog.sioaddr, SIO_F81866_REG_GPIO1,\r\nBIT(5));\r\nbreak;\r\ndefault:\r\nerr = -ENODEV;\r\ngoto exit_superio;\r\n}\r\nsuperio_select(watchdog.sioaddr, SIO_F71808FG_LD_WDT);\r\nsuperio_set_bit(watchdog.sioaddr, SIO_REG_ENABLE, 0);\r\nif (watchdog.type == f81865 || watchdog.type == f81866)\r\nsuperio_set_bit(watchdog.sioaddr, F81865_REG_WDO_CONF,\r\nF81865_FLAG_WDOUT_EN);\r\nelse\r\nsuperio_set_bit(watchdog.sioaddr, F71808FG_REG_WDO_CONF,\r\nF71808FG_FLAG_WDOUT_EN);\r\nsuperio_set_bit(watchdog.sioaddr, F71808FG_REG_WDT_CONF,\r\nF71808FG_FLAG_WD_EN);\r\nif (watchdog.pulse_mode) {\r\nu8 wdt_conf = superio_inb(watchdog.sioaddr,\r\nF71808FG_REG_WDT_CONF);\r\nwdt_conf = (wdt_conf & 0xfc) | (watchdog.pulse_val & 0x03);\r\nwdt_conf |= BIT(F71808FG_FLAG_WD_PULSE);\r\nsuperio_outb(watchdog.sioaddr, F71808FG_REG_WDT_CONF,\r\nwdt_conf);\r\n} else {\r\nsuperio_clear_bit(watchdog.sioaddr, F71808FG_REG_WDT_CONF,\r\nF71808FG_FLAG_WD_PULSE);\r\n}\r\nexit_superio:\r\nsuperio_exit(watchdog.sioaddr);\r\nexit_unlock:\r\nmutex_unlock(&watchdog.lock);\r\nreturn err;\r\n}\r\nstatic int watchdog_stop(void)\r\n{\r\nint err = 0;\r\nmutex_lock(&watchdog.lock);\r\nerr = superio_enter(watchdog.sioaddr);\r\nif (err)\r\ngoto exit_unlock;\r\nsuperio_select(watchdog.sioaddr, SIO_F71808FG_LD_WDT);\r\nsuperio_clear_bit(watchdog.sioaddr, F71808FG_REG_WDT_CONF,\r\nF71808FG_FLAG_WD_EN);\r\nsuperio_exit(watchdog.sioaddr);\r\nexit_unlock:\r\nmutex_unlock(&watchdog.lock);\r\nreturn err;\r\n}\r\nstatic int watchdog_get_status(void)\r\n{\r\nint status = 0;\r\nmutex_lock(&watchdog.lock);\r\nstatus = (watchdog.caused_reboot) ? WDIOF_CARDRESET : 0;\r\nmutex_unlock(&watchdog.lock);\r\nreturn status;\r\n}\r\nstatic bool watchdog_is_running(void)\r\n{\r\nbool is_running = true;\r\nmutex_lock(&watchdog.lock);\r\nif (superio_enter(watchdog.sioaddr))\r\ngoto exit_unlock;\r\nsuperio_select(watchdog.sioaddr, SIO_F71808FG_LD_WDT);\r\nis_running = (superio_inb(watchdog.sioaddr, SIO_REG_ENABLE) & BIT(0))\r\n&& (superio_inb(watchdog.sioaddr, F71808FG_REG_WDT_CONF)\r\n& F71808FG_FLAG_WD_EN);\r\nsuperio_exit(watchdog.sioaddr);\r\nexit_unlock:\r\nmutex_unlock(&watchdog.lock);\r\nreturn is_running;\r\n}\r\nstatic int watchdog_open(struct inode *inode, struct file *file)\r\n{\r\nint err;\r\nif (test_and_set_bit(0, &watchdog.opened))\r\nreturn -EBUSY;\r\nerr = watchdog_start();\r\nif (err) {\r\nclear_bit(0, &watchdog.opened);\r\nreturn err;\r\n}\r\nif (nowayout)\r\n__module_get(THIS_MODULE);\r\nwatchdog.expect_close = 0;\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int watchdog_release(struct inode *inode, struct file *file)\r\n{\r\nclear_bit(0, &watchdog.opened);\r\nif (!watchdog.expect_close) {\r\nwatchdog_keepalive();\r\npr_crit("Unexpected close, not stopping watchdog!\n");\r\n} else if (!nowayout) {\r\nwatchdog_stop();\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t watchdog_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nif (count) {\r\nif (!nowayout) {\r\nsize_t i;\r\nbool expect_close = false;\r\nfor (i = 0; i != count; i++) {\r\nchar c;\r\nif (get_user(c, buf + i))\r\nreturn -EFAULT;\r\nexpect_close = (c == 'V');\r\n}\r\nmutex_lock(&watchdog.lock);\r\nwatchdog.expect_close = expect_close;\r\nmutex_unlock(&watchdog.lock);\r\n}\r\nwatchdog_keepalive();\r\n}\r\nreturn count;\r\n}\r\nstatic long watchdog_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nint status;\r\nint new_options;\r\nint new_timeout;\r\nunion {\r\nstruct watchdog_info __user *ident;\r\nint __user *i;\r\n} uarg;\r\nuarg.i = (int __user *)arg;\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nreturn copy_to_user(uarg.ident, &watchdog.ident,\r\nsizeof(watchdog.ident)) ? -EFAULT : 0;\r\ncase WDIOC_GETSTATUS:\r\nstatus = watchdog_get_status();\r\nif (status < 0)\r\nreturn status;\r\nreturn put_user(status, uarg.i);\r\ncase WDIOC_GETBOOTSTATUS:\r\nreturn put_user(0, uarg.i);\r\ncase WDIOC_SETOPTIONS:\r\nif (get_user(new_options, uarg.i))\r\nreturn -EFAULT;\r\nif (new_options & WDIOS_DISABLECARD)\r\nwatchdog_stop();\r\nif (new_options & WDIOS_ENABLECARD)\r\nreturn watchdog_start();\r\ncase WDIOC_KEEPALIVE:\r\nwatchdog_keepalive();\r\nreturn 0;\r\ncase WDIOC_SETTIMEOUT:\r\nif (get_user(new_timeout, uarg.i))\r\nreturn -EFAULT;\r\nif (watchdog_set_timeout(new_timeout))\r\nreturn -EINVAL;\r\nwatchdog_keepalive();\r\ncase WDIOC_GETTIMEOUT:\r\nreturn put_user(watchdog.timeout, uarg.i);\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}\r\nstatic int watchdog_notify_sys(struct notifier_block *this, unsigned long code,\r\nvoid *unused)\r\n{\r\nif (code == SYS_DOWN || code == SYS_HALT)\r\nwatchdog_stop();\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int __init watchdog_init(int sioaddr)\r\n{\r\nint wdt_conf, err = 0;\r\nwatchdog.sioaddr = sioaddr;\r\nwatchdog.ident.options = WDIOC_SETTIMEOUT\r\n| WDIOF_MAGICCLOSE\r\n| WDIOF_KEEPALIVEPING;\r\nsnprintf(watchdog.ident.identity,\r\nsizeof(watchdog.ident.identity), "%s watchdog",\r\nf71808e_names[watchdog.type]);\r\nerr = superio_enter(sioaddr);\r\nif (err)\r\nreturn err;\r\nsuperio_select(watchdog.sioaddr, SIO_F71808FG_LD_WDT);\r\nwdt_conf = superio_inb(sioaddr, F71808FG_REG_WDT_CONF);\r\nwatchdog.caused_reboot = wdt_conf & BIT(F71808FG_FLAG_WDTMOUT_STS);\r\nsuperio_exit(sioaddr);\r\nerr = watchdog_set_timeout(timeout);\r\nif (err)\r\nreturn err;\r\nerr = watchdog_set_pulse_width(pulse_width);\r\nif (err)\r\nreturn err;\r\nerr = register_reboot_notifier(&watchdog_notifier);\r\nif (err)\r\nreturn err;\r\nerr = misc_register(&watchdog_miscdev);\r\nif (err) {\r\npr_err("cannot register miscdev on minor=%d\n",\r\nwatchdog_miscdev.minor);\r\ngoto exit_reboot;\r\n}\r\nif (start_withtimeout) {\r\nif (start_withtimeout <= 0\r\n|| start_withtimeout > max_timeout) {\r\npr_err("starting timeout out of range\n");\r\nerr = -EINVAL;\r\ngoto exit_miscdev;\r\n}\r\nerr = watchdog_start();\r\nif (err) {\r\npr_err("cannot start watchdog timer\n");\r\ngoto exit_miscdev;\r\n}\r\nmutex_lock(&watchdog.lock);\r\nerr = superio_enter(sioaddr);\r\nif (err)\r\ngoto exit_unlock;\r\nsuperio_select(watchdog.sioaddr, SIO_F71808FG_LD_WDT);\r\nif (start_withtimeout > 0xff) {\r\nsuperio_set_bit(sioaddr, F71808FG_REG_WDT_CONF,\r\nF71808FG_FLAG_WD_UNIT);\r\nsuperio_outb(sioaddr, F71808FG_REG_WD_TIME,\r\nDIV_ROUND_UP(start_withtimeout, 60));\r\n} else {\r\nsuperio_clear_bit(sioaddr, F71808FG_REG_WDT_CONF,\r\nF71808FG_FLAG_WD_UNIT);\r\nsuperio_outb(sioaddr, F71808FG_REG_WD_TIME,\r\nstart_withtimeout);\r\n}\r\nsuperio_exit(sioaddr);\r\nmutex_unlock(&watchdog.lock);\r\nif (nowayout)\r\n__module_get(THIS_MODULE);\r\npr_info("watchdog started with initial timeout of %u sec\n",\r\nstart_withtimeout);\r\n}\r\nreturn 0;\r\nexit_unlock:\r\nmutex_unlock(&watchdog.lock);\r\nexit_miscdev:\r\nmisc_deregister(&watchdog_miscdev);\r\nexit_reboot:\r\nunregister_reboot_notifier(&watchdog_notifier);\r\nreturn err;\r\n}\r\nstatic int __init f71808e_find(int sioaddr)\r\n{\r\nu16 devid;\r\nint err = superio_enter(sioaddr);\r\nif (err)\r\nreturn err;\r\ndevid = superio_inw(sioaddr, SIO_REG_MANID);\r\nif (devid != SIO_FINTEK_ID) {\r\npr_debug("Not a Fintek device\n");\r\nerr = -ENODEV;\r\ngoto exit;\r\n}\r\ndevid = force_id ? force_id : superio_inw(sioaddr, SIO_REG_DEVID);\r\nswitch (devid) {\r\ncase SIO_F71808_ID:\r\nwatchdog.type = f71808fg;\r\nbreak;\r\ncase SIO_F71862_ID:\r\nwatchdog.type = f71862fg;\r\nerr = f71862fg_pin_configure(0);\r\nbreak;\r\ncase SIO_F71868_ID:\r\nwatchdog.type = f71868;\r\nbreak;\r\ncase SIO_F71869_ID:\r\ncase SIO_F71869A_ID:\r\nwatchdog.type = f71869;\r\nbreak;\r\ncase SIO_F71882_ID:\r\nwatchdog.type = f71882fg;\r\nbreak;\r\ncase SIO_F71889_ID:\r\nwatchdog.type = f71889fg;\r\nbreak;\r\ncase SIO_F71858_ID:\r\nerr = -ENODEV;\r\ngoto exit;\r\ncase SIO_F81865_ID:\r\nwatchdog.type = f81865;\r\nbreak;\r\ncase SIO_F81866_ID:\r\nwatchdog.type = f81866;\r\nbreak;\r\ndefault:\r\npr_info("Unrecognized Fintek device: %04x\n",\r\n(unsigned int)devid);\r\nerr = -ENODEV;\r\ngoto exit;\r\n}\r\npr_info("Found %s watchdog chip, revision %d\n",\r\nf71808e_names[watchdog.type],\r\n(int)superio_inb(sioaddr, SIO_REG_DEVREV));\r\nexit:\r\nsuperio_exit(sioaddr);\r\nreturn err;\r\n}\r\nstatic int __init f71808e_init(void)\r\n{\r\nstatic const unsigned short addrs[] = { 0x2e, 0x4e };\r\nint err = -ENODEV;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(addrs); i++) {\r\nerr = f71808e_find(addrs[i]);\r\nif (err == 0)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(addrs))\r\nreturn err;\r\nreturn watchdog_init(addrs[i]);\r\n}\r\nstatic void __exit f71808e_exit(void)\r\n{\r\nif (watchdog_is_running()) {\r\npr_warn("Watchdog timer still running, stopping it\n");\r\nwatchdog_stop();\r\n}\r\nmisc_deregister(&watchdog_miscdev);\r\nunregister_reboot_notifier(&watchdog_notifier);\r\n}
