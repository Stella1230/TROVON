int __percpu_init_rwsem(struct percpu_rw_semaphore *sem,\r\nconst char *name, struct lock_class_key *rwsem_key)\r\n{\r\nsem->read_count = alloc_percpu(int);\r\nif (unlikely(!sem->read_count))\r\nreturn -ENOMEM;\r\nrcu_sync_init(&sem->rss, RCU_SCHED_SYNC);\r\n__init_rwsem(&sem->rw_sem, name, rwsem_key);\r\nrcuwait_init(&sem->writer);\r\nsem->readers_block = 0;\r\nreturn 0;\r\n}\r\nvoid percpu_free_rwsem(struct percpu_rw_semaphore *sem)\r\n{\r\nif (!sem->read_count)\r\nreturn;\r\nrcu_sync_dtor(&sem->rss);\r\nfree_percpu(sem->read_count);\r\nsem->read_count = NULL;\r\n}\r\nint __percpu_down_read(struct percpu_rw_semaphore *sem, int try)\r\n{\r\nsmp_mb();\r\nif (likely(!smp_load_acquire(&sem->readers_block)))\r\nreturn 1;\r\n__percpu_up_read(sem);\r\nif (try)\r\nreturn 0;\r\npreempt_enable_no_resched();\r\n__down_read(&sem->rw_sem);\r\nthis_cpu_inc(*sem->read_count);\r\n__up_read(&sem->rw_sem);\r\npreempt_disable();\r\nreturn 1;\r\n}\r\nvoid __percpu_up_read(struct percpu_rw_semaphore *sem)\r\n{\r\nsmp_mb();\r\n__this_cpu_dec(*sem->read_count);\r\nrcuwait_wake_up(&sem->writer);\r\n}\r\nstatic bool readers_active_check(struct percpu_rw_semaphore *sem)\r\n{\r\nif (per_cpu_sum(*sem->read_count) != 0)\r\nreturn false;\r\nsmp_mb();\r\nreturn true;\r\n}\r\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\r\n{\r\nrcu_sync_enter(&sem->rss);\r\ndown_write(&sem->rw_sem);\r\nWRITE_ONCE(sem->readers_block, 1);\r\nsmp_mb();\r\nrcuwait_wait_event(&sem->writer, readers_active_check(sem));\r\n}\r\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\r\n{\r\nsmp_store_release(&sem->readers_block, 0);\r\nup_write(&sem->rw_sem);\r\nrcu_sync_exit(&sem->rss);\r\n}
