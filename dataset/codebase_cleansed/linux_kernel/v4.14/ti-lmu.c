static int ti_lmu_enable_hw(struct ti_lmu *lmu, enum ti_lmu_id id)\r\n{\r\nint ret;\r\nif (gpio_is_valid(lmu->en_gpio)) {\r\nret = devm_gpio_request_one(lmu->dev, lmu->en_gpio,\r\nGPIOF_OUT_INIT_HIGH, "lmu_hwen");\r\nif (ret) {\r\ndev_err(lmu->dev, "Can not request enable GPIO: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\n}\r\nusleep_range(1000, 1500);\r\nif (id == LM3631) {\r\nreturn regmap_update_bits(lmu->regmap, LM3631_REG_DEVCTRL,\r\nLM3631_LCD_EN_MASK,\r\nLM3631_LCD_EN_MASK);\r\n}\r\nreturn 0;\r\n}\r\nstatic void ti_lmu_disable_hw(struct ti_lmu *lmu)\r\n{\r\nif (gpio_is_valid(lmu->en_gpio))\r\ngpio_set_value(lmu->en_gpio, 0);\r\n}\r\nstatic int ti_lmu_probe(struct i2c_client *cl, const struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &cl->dev;\r\nconst struct of_device_id *match;\r\nconst struct ti_lmu_data *data;\r\nstruct regmap_config regmap_cfg;\r\nstruct ti_lmu *lmu;\r\nint ret;\r\nmatch = of_match_device(ti_lmu_of_match, dev);\r\nif (!match)\r\nreturn -ENODEV;\r\ndata = (struct ti_lmu_data *)match->data;\r\nlmu = devm_kzalloc(dev, sizeof(*lmu), GFP_KERNEL);\r\nif (!lmu)\r\nreturn -ENOMEM;\r\nlmu->dev = &cl->dev;\r\nmemset(&regmap_cfg, 0, sizeof(struct regmap_config));\r\nregmap_cfg.reg_bits = 8;\r\nregmap_cfg.val_bits = 8;\r\nregmap_cfg.name = id->name;\r\nregmap_cfg.max_register = data->max_register;\r\nlmu->regmap = devm_regmap_init_i2c(cl, &regmap_cfg);\r\nif (IS_ERR(lmu->regmap))\r\nreturn PTR_ERR(lmu->regmap);\r\nlmu->en_gpio = of_get_named_gpio(dev->of_node, "enable-gpios", 0);\r\nret = ti_lmu_enable_hw(lmu, id->driver_data);\r\nif (ret)\r\nreturn ret;\r\nBLOCKING_INIT_NOTIFIER_HEAD(&lmu->notifier);\r\ni2c_set_clientdata(cl, lmu);\r\nreturn mfd_add_devices(lmu->dev, 0, data->cells,\r\ndata->num_cells, NULL, 0, NULL);\r\n}\r\nstatic int ti_lmu_remove(struct i2c_client *cl)\r\n{\r\nstruct ti_lmu *lmu = i2c_get_clientdata(cl);\r\nti_lmu_disable_hw(lmu);\r\nmfd_remove_devices(lmu->dev);\r\nreturn 0;\r\n}
