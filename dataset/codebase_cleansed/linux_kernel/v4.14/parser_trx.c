static const char *parser_trx_data_part_name(struct mtd_info *master,\r\nsize_t offset)\r\n{\r\nuint32_t buf;\r\nsize_t bytes_read;\r\nint err;\r\nerr = mtd_read(master, offset, sizeof(buf), &bytes_read,\r\n(uint8_t *)&buf);\r\nif (err && !mtd_is_bitflip(err)) {\r\npr_err("mtd_read error while parsing (offset: 0x%zX): %d\n",\r\noffset, err);\r\ngoto out_default;\r\n}\r\nif (buf == UBI_EC_MAGIC)\r\nreturn "ubi";\r\nout_default:\r\nreturn "rootfs";\r\n}\r\nstatic int parser_trx_parse(struct mtd_info *mtd,\r\nconst struct mtd_partition **pparts,\r\nstruct mtd_part_parser_data *data)\r\n{\r\nstruct mtd_partition *parts;\r\nstruct mtd_partition *part;\r\nstruct trx_header trx;\r\nsize_t bytes_read;\r\nuint8_t curr_part = 0, i = 0;\r\nint err;\r\nparts = kzalloc(sizeof(struct mtd_partition) * TRX_PARSER_MAX_PARTS,\r\nGFP_KERNEL);\r\nif (!parts)\r\nreturn -ENOMEM;\r\nerr = mtd_read(mtd, 0, sizeof(trx), &bytes_read, (uint8_t *)&trx);\r\nif (err) {\r\npr_err("MTD reading error: %d\n", err);\r\nkfree(parts);\r\nreturn err;\r\n}\r\nif (trx.magic != TRX_MAGIC) {\r\nkfree(parts);\r\nreturn -ENOENT;\r\n}\r\nif (trx.offset[2]) {\r\npart = &parts[curr_part++];\r\npart->name = "loader";\r\npart->offset = trx.offset[i];\r\ni++;\r\n}\r\nif (trx.offset[i]) {\r\npart = &parts[curr_part++];\r\npart->name = "linux";\r\npart->offset = trx.offset[i];\r\ni++;\r\n}\r\nif (trx.offset[i]) {\r\npart = &parts[curr_part++];\r\npart->name = parser_trx_data_part_name(mtd, trx.offset[i]);\r\npart->offset = trx.offset[i];\r\ni++;\r\n}\r\nfor (i = 0; i < curr_part; i++) {\r\nu64 next_part_offset = (i < curr_part - 1) ?\r\nparts[i + 1].offset : mtd->size;\r\nparts[i].size = next_part_offset - parts[i].offset;\r\n}\r\n*pparts = parts;\r\nreturn i;\r\n}
