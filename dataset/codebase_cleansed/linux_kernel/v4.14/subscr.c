static u32 htohl(u32 in, int swap)\r\n{\r\nreturn swap ? swab32(in) : in;\r\n}\r\nstatic void tipc_subscrp_send_event(struct tipc_subscription *sub,\r\nu32 found_lower, u32 found_upper,\r\nu32 event, u32 port_ref, u32 node)\r\n{\r\nstruct tipc_net *tn = net_generic(sub->net, tipc_net_id);\r\nstruct tipc_subscriber *subscriber = sub->subscriber;\r\nstruct kvec msg_sect;\r\nmsg_sect.iov_base = (void *)&sub->evt;\r\nmsg_sect.iov_len = sizeof(struct tipc_event);\r\nsub->evt.event = htohl(event, sub->swap);\r\nsub->evt.found_lower = htohl(found_lower, sub->swap);\r\nsub->evt.found_upper = htohl(found_upper, sub->swap);\r\nsub->evt.port.ref = htohl(port_ref, sub->swap);\r\nsub->evt.port.node = htohl(node, sub->swap);\r\ntipc_conn_sendmsg(tn->topsrv, subscriber->conid, NULL,\r\nmsg_sect.iov_base, msg_sect.iov_len);\r\n}\r\nint tipc_subscrp_check_overlap(struct tipc_name_seq *seq, u32 found_lower,\r\nu32 found_upper)\r\n{\r\nif (found_lower < seq->lower)\r\nfound_lower = seq->lower;\r\nif (found_upper > seq->upper)\r\nfound_upper = seq->upper;\r\nif (found_lower > found_upper)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nu32 tipc_subscrp_convert_seq_type(u32 type, int swap)\r\n{\r\nreturn htohl(type, swap);\r\n}\r\nvoid tipc_subscrp_convert_seq(struct tipc_name_seq *in, int swap,\r\nstruct tipc_name_seq *out)\r\n{\r\nout->type = htohl(in->type, swap);\r\nout->lower = htohl(in->lower, swap);\r\nout->upper = htohl(in->upper, swap);\r\n}\r\nvoid tipc_subscrp_report_overlap(struct tipc_subscription *sub, u32 found_lower,\r\nu32 found_upper, u32 event, u32 port_ref,\r\nu32 node, int must)\r\n{\r\nstruct tipc_name_seq seq;\r\ntipc_subscrp_convert_seq(&sub->evt.s.seq, sub->swap, &seq);\r\nif (!tipc_subscrp_check_overlap(&seq, found_lower, found_upper))\r\nreturn;\r\nif (!must &&\r\n!(htohl(sub->evt.s.filter, sub->swap) & TIPC_SUB_PORTS))\r\nreturn;\r\ntipc_subscrp_send_event(sub, found_lower, found_upper, event, port_ref,\r\nnode);\r\n}\r\nstatic void tipc_subscrp_timeout(unsigned long data)\r\n{\r\nstruct tipc_subscription *sub = (struct tipc_subscription *)data;\r\nstruct tipc_subscriber *subscriber = sub->subscriber;\r\nspin_lock_bh(&subscriber->lock);\r\ntipc_nametbl_unsubscribe(sub);\r\nlist_del(&sub->subscrp_list);\r\nspin_unlock_bh(&subscriber->lock);\r\ntipc_subscrp_send_event(sub, sub->evt.s.seq.lower, sub->evt.s.seq.upper,\r\nTIPC_SUBSCR_TIMEOUT, 0, 0);\r\ntipc_subscrp_put(sub);\r\n}\r\nstatic void tipc_subscrb_kref_release(struct kref *kref)\r\n{\r\nkfree(container_of(kref,struct tipc_subscriber, kref));\r\n}\r\nstatic void tipc_subscrb_put(struct tipc_subscriber *subscriber)\r\n{\r\nkref_put(&subscriber->kref, tipc_subscrb_kref_release);\r\n}\r\nstatic void tipc_subscrb_get(struct tipc_subscriber *subscriber)\r\n{\r\nkref_get(&subscriber->kref);\r\n}\r\nstatic void tipc_subscrp_kref_release(struct kref *kref)\r\n{\r\nstruct tipc_subscription *sub = container_of(kref,\r\nstruct tipc_subscription,\r\nkref);\r\nstruct tipc_net *tn = net_generic(sub->net, tipc_net_id);\r\nstruct tipc_subscriber *subscriber = sub->subscriber;\r\natomic_dec(&tn->subscription_count);\r\nkfree(sub);\r\ntipc_subscrb_put(subscriber);\r\n}\r\nvoid tipc_subscrp_put(struct tipc_subscription *subscription)\r\n{\r\nkref_put(&subscription->kref, tipc_subscrp_kref_release);\r\n}\r\nvoid tipc_subscrp_get(struct tipc_subscription *subscription)\r\n{\r\nkref_get(&subscription->kref);\r\n}\r\nstatic void tipc_subscrb_subscrp_delete(struct tipc_subscriber *subscriber,\r\nstruct tipc_subscr *s)\r\n{\r\nstruct list_head *subscription_list = &subscriber->subscrp_list;\r\nstruct tipc_subscription *sub, *temp;\r\nu32 timeout;\r\nspin_lock_bh(&subscriber->lock);\r\nlist_for_each_entry_safe(sub, temp, subscription_list, subscrp_list) {\r\nif (s && memcmp(s, &sub->evt.s, sizeof(struct tipc_subscr)))\r\ncontinue;\r\ntimeout = htohl(sub->evt.s.timeout, sub->swap);\r\nif (timeout == TIPC_WAIT_FOREVER || del_timer(&sub->timer)) {\r\ntipc_nametbl_unsubscribe(sub);\r\nlist_del(&sub->subscrp_list);\r\ntipc_subscrp_put(sub);\r\n}\r\nif (s)\r\nbreak;\r\n}\r\nspin_unlock_bh(&subscriber->lock);\r\n}\r\nstatic struct tipc_subscriber *tipc_subscrb_create(int conid)\r\n{\r\nstruct tipc_subscriber *subscriber;\r\nsubscriber = kzalloc(sizeof(*subscriber), GFP_ATOMIC);\r\nif (!subscriber) {\r\npr_warn("Subscriber rejected, no memory\n");\r\nreturn NULL;\r\n}\r\nINIT_LIST_HEAD(&subscriber->subscrp_list);\r\nkref_init(&subscriber->kref);\r\nsubscriber->conid = conid;\r\nspin_lock_init(&subscriber->lock);\r\nreturn subscriber;\r\n}\r\nstatic void tipc_subscrb_delete(struct tipc_subscriber *subscriber)\r\n{\r\ntipc_subscrb_subscrp_delete(subscriber, NULL);\r\ntipc_subscrb_put(subscriber);\r\n}\r\nstatic void tipc_subscrp_cancel(struct tipc_subscr *s,\r\nstruct tipc_subscriber *subscriber)\r\n{\r\ntipc_subscrb_get(subscriber);\r\ntipc_subscrb_subscrp_delete(subscriber, s);\r\ntipc_subscrb_put(subscriber);\r\n}\r\nstatic struct tipc_subscription *tipc_subscrp_create(struct net *net,\r\nstruct tipc_subscr *s,\r\nint swap)\r\n{\r\nstruct tipc_net *tn = net_generic(net, tipc_net_id);\r\nstruct tipc_subscription *sub;\r\nu32 filter = htohl(s->filter, swap);\r\nif (atomic_read(&tn->subscription_count) >= TIPC_MAX_SUBSCRIPTIONS) {\r\npr_warn("Subscription rejected, limit reached (%u)\n",\r\nTIPC_MAX_SUBSCRIPTIONS);\r\nreturn NULL;\r\n}\r\nsub = kmalloc(sizeof(*sub), GFP_ATOMIC);\r\nif (!sub) {\r\npr_warn("Subscription rejected, no memory\n");\r\nreturn NULL;\r\n}\r\nsub->net = net;\r\nif (((filter & TIPC_SUB_PORTS) && (filter & TIPC_SUB_SERVICE)) ||\r\n(htohl(s->seq.lower, swap) > htohl(s->seq.upper, swap))) {\r\npr_warn("Subscription rejected, illegal request\n");\r\nkfree(sub);\r\nreturn NULL;\r\n}\r\nsub->swap = swap;\r\nmemcpy(&sub->evt.s, s, sizeof(*s));\r\natomic_inc(&tn->subscription_count);\r\nkref_init(&sub->kref);\r\nreturn sub;\r\n}\r\nstatic void tipc_subscrp_subscribe(struct net *net, struct tipc_subscr *s,\r\nstruct tipc_subscriber *subscriber, int swap)\r\n{\r\nstruct tipc_net *tn = net_generic(net, tipc_net_id);\r\nstruct tipc_subscription *sub = NULL;\r\nu32 timeout;\r\nsub = tipc_subscrp_create(net, s, swap);\r\nif (!sub)\r\nreturn tipc_conn_terminate(tn->topsrv, subscriber->conid);\r\nspin_lock_bh(&subscriber->lock);\r\nlist_add(&sub->subscrp_list, &subscriber->subscrp_list);\r\nsub->subscriber = subscriber;\r\ntipc_nametbl_subscribe(sub);\r\ntipc_subscrb_get(subscriber);\r\nspin_unlock_bh(&subscriber->lock);\r\nsetup_timer(&sub->timer, tipc_subscrp_timeout, (unsigned long)sub);\r\ntimeout = htohl(sub->evt.s.timeout, swap);\r\nif (timeout != TIPC_WAIT_FOREVER)\r\nmod_timer(&sub->timer, jiffies + msecs_to_jiffies(timeout));\r\n}\r\nstatic void tipc_subscrb_release_cb(int conid, void *usr_data)\r\n{\r\ntipc_subscrb_delete((struct tipc_subscriber *)usr_data);\r\n}\r\nstatic void tipc_subscrb_rcv_cb(struct net *net, int conid,\r\nstruct sockaddr_tipc *addr, void *usr_data,\r\nvoid *buf, size_t len)\r\n{\r\nstruct tipc_subscriber *subscriber = usr_data;\r\nstruct tipc_subscr *s = (struct tipc_subscr *)buf;\r\nint swap;\r\nswap = !(s->filter & (TIPC_SUB_PORTS | TIPC_SUB_SERVICE |\r\nTIPC_SUB_CANCEL));\r\nif (s->filter & htohl(TIPC_SUB_CANCEL, swap)) {\r\ns->filter &= ~htohl(TIPC_SUB_CANCEL, swap);\r\nreturn tipc_subscrp_cancel(s, subscriber);\r\n}\r\ntipc_subscrp_subscribe(net, s, subscriber, swap);\r\n}\r\nstatic void *tipc_subscrb_connect_cb(int conid)\r\n{\r\nreturn (void *)tipc_subscrb_create(conid);\r\n}\r\nint tipc_topsrv_start(struct net *net)\r\n{\r\nstruct tipc_net *tn = net_generic(net, tipc_net_id);\r\nconst char name[] = "topology_server";\r\nstruct tipc_server *topsrv;\r\nstruct sockaddr_tipc *saddr;\r\nsaddr = kzalloc(sizeof(*saddr), GFP_ATOMIC);\r\nif (!saddr)\r\nreturn -ENOMEM;\r\nsaddr->family = AF_TIPC;\r\nsaddr->addrtype = TIPC_ADDR_NAMESEQ;\r\nsaddr->addr.nameseq.type = TIPC_TOP_SRV;\r\nsaddr->addr.nameseq.lower = TIPC_TOP_SRV;\r\nsaddr->addr.nameseq.upper = TIPC_TOP_SRV;\r\nsaddr->scope = TIPC_NODE_SCOPE;\r\ntopsrv = kzalloc(sizeof(*topsrv), GFP_ATOMIC);\r\nif (!topsrv) {\r\nkfree(saddr);\r\nreturn -ENOMEM;\r\n}\r\ntopsrv->net = net;\r\ntopsrv->saddr = saddr;\r\ntopsrv->imp = TIPC_CRITICAL_IMPORTANCE;\r\ntopsrv->type = SOCK_SEQPACKET;\r\ntopsrv->max_rcvbuf_size = sizeof(struct tipc_subscr);\r\ntopsrv->tipc_conn_recvmsg = tipc_subscrb_rcv_cb;\r\ntopsrv->tipc_conn_new = tipc_subscrb_connect_cb;\r\ntopsrv->tipc_conn_release = tipc_subscrb_release_cb;\r\nstrncpy(topsrv->name, name, strlen(name) + 1);\r\ntn->topsrv = topsrv;\r\natomic_set(&tn->subscription_count, 0);\r\nreturn tipc_server_start(topsrv);\r\n}\r\nvoid tipc_topsrv_stop(struct net *net)\r\n{\r\nstruct tipc_net *tn = net_generic(net, tipc_net_id);\r\nstruct tipc_server *topsrv = tn->topsrv;\r\ntipc_server_stop(topsrv);\r\nkfree(topsrv->saddr);\r\nkfree(topsrv);\r\n}
