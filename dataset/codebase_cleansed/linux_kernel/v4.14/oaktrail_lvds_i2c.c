static int get_clock(void *data)\r\n{\r\nstruct psb_intel_i2c_chan *chan = data;\r\nu32 val, tmp;\r\nval = LPC_READ_REG(chan, RGIO);\r\nval |= GPIO_CLOCK;\r\nLPC_WRITE_REG(chan, RGIO, val);\r\ntmp = LPC_READ_REG(chan, RGLVL);\r\nval = (LPC_READ_REG(chan, RGLVL) & GPIO_CLOCK) ? 1 : 0;\r\nreturn val;\r\n}\r\nstatic int get_data(void *data)\r\n{\r\nstruct psb_intel_i2c_chan *chan = data;\r\nu32 val, tmp;\r\nval = LPC_READ_REG(chan, RGIO);\r\nval |= GPIO_DATA;\r\nLPC_WRITE_REG(chan, RGIO, val);\r\ntmp = LPC_READ_REG(chan, RGLVL);\r\nval = (LPC_READ_REG(chan, RGLVL) & GPIO_DATA) ? 1 : 0;\r\nreturn val;\r\n}\r\nstatic void set_clock(void *data, int state_high)\r\n{\r\nstruct psb_intel_i2c_chan *chan = data;\r\nu32 val;\r\nif (state_high) {\r\nval = LPC_READ_REG(chan, RGIO);\r\nval |= GPIO_CLOCK;\r\nLPC_WRITE_REG(chan, RGIO, val);\r\n} else {\r\nval = LPC_READ_REG(chan, RGIO);\r\nval &= ~GPIO_CLOCK;\r\nLPC_WRITE_REG(chan, RGIO, val);\r\nval = LPC_READ_REG(chan, RGLVL);\r\nval &= ~GPIO_CLOCK;\r\nLPC_WRITE_REG(chan, RGLVL, val);\r\n}\r\n}\r\nstatic void set_data(void *data, int state_high)\r\n{\r\nstruct psb_intel_i2c_chan *chan = data;\r\nu32 val;\r\nif (state_high) {\r\nval = LPC_READ_REG(chan, RGIO);\r\nval |= GPIO_DATA;\r\nLPC_WRITE_REG(chan, RGIO, val);\r\n} else {\r\nval = LPC_READ_REG(chan, RGIO);\r\nval &= ~GPIO_DATA;\r\nLPC_WRITE_REG(chan, RGIO, val);\r\nval = LPC_READ_REG(chan, RGLVL);\r\nval &= ~GPIO_DATA;\r\nLPC_WRITE_REG(chan, RGLVL, val);\r\n}\r\n}\r\nvoid oaktrail_lvds_i2c_init(struct drm_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct gma_encoder *gma_encoder = to_gma_encoder(encoder);\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct psb_intel_i2c_chan *chan;\r\nchan = kzalloc(sizeof(struct psb_intel_i2c_chan), GFP_KERNEL);\r\nif (!chan)\r\nreturn;\r\nchan->drm_dev = dev;\r\nchan->reg = dev_priv->lpc_gpio_base;\r\nstrncpy(chan->adapter.name, "gma500 LPC", I2C_NAME_SIZE - 1);\r\nchan->adapter.owner = THIS_MODULE;\r\nchan->adapter.algo_data = &chan->algo;\r\nchan->adapter.dev.parent = &dev->pdev->dev;\r\nchan->algo.setsda = set_data;\r\nchan->algo.setscl = set_clock;\r\nchan->algo.getsda = get_data;\r\nchan->algo.getscl = get_clock;\r\nchan->algo.udelay = 100;\r\nchan->algo.timeout = usecs_to_jiffies(2200);\r\nchan->algo.data = chan;\r\ni2c_set_adapdata(&chan->adapter, chan);\r\nset_data(chan, 1);\r\nset_clock(chan, 1);\r\nudelay(50);\r\nif (i2c_bit_add_bus(&chan->adapter)) {\r\nkfree(chan);\r\nreturn;\r\n}\r\ngma_encoder->ddc_bus = chan;\r\n}
