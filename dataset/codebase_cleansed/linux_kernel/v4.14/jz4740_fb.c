static inline uint32_t jzfb_convert_color_to_hw(unsigned val,\r\nstruct fb_bitfield *bf)\r\n{\r\nreturn (((val << bf->length) + 0x7FFF - val) >> 16) << bf->offset;\r\n}\r\nstatic int jzfb_setcolreg(unsigned regno, unsigned red, unsigned green,\r\nunsigned blue, unsigned transp, struct fb_info *fb)\r\n{\r\nuint32_t color;\r\nif (regno >= 16)\r\nreturn -EINVAL;\r\ncolor = jzfb_convert_color_to_hw(red, &fb->var.red);\r\ncolor |= jzfb_convert_color_to_hw(green, &fb->var.green);\r\ncolor |= jzfb_convert_color_to_hw(blue, &fb->var.blue);\r\ncolor |= jzfb_convert_color_to_hw(transp, &fb->var.transp);\r\n((uint32_t *)(fb->pseudo_palette))[regno] = color;\r\nreturn 0;\r\n}\r\nstatic int jzfb_get_controller_bpp(struct jzfb *jzfb)\r\n{\r\nswitch (jzfb->pdata->bpp) {\r\ncase 18:\r\ncase 24:\r\nreturn 32;\r\ncase 15:\r\nreturn 16;\r\ndefault:\r\nreturn jzfb->pdata->bpp;\r\n}\r\n}\r\nstatic struct fb_videomode *jzfb_get_mode(struct jzfb *jzfb,\r\nstruct fb_var_screeninfo *var)\r\n{\r\nsize_t i;\r\nstruct fb_videomode *mode = jzfb->pdata->modes;\r\nfor (i = 0; i < jzfb->pdata->num_modes; ++i, ++mode) {\r\nif (mode->xres == var->xres && mode->yres == var->yres)\r\nreturn mode;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int jzfb_check_var(struct fb_var_screeninfo *var, struct fb_info *fb)\r\n{\r\nstruct jzfb *jzfb = fb->par;\r\nstruct fb_videomode *mode;\r\nif (var->bits_per_pixel != jzfb_get_controller_bpp(jzfb) &&\r\nvar->bits_per_pixel != jzfb->pdata->bpp)\r\nreturn -EINVAL;\r\nmode = jzfb_get_mode(jzfb, var);\r\nif (mode == NULL)\r\nreturn -EINVAL;\r\nfb_videomode_to_var(var, mode);\r\nswitch (jzfb->pdata->bpp) {\r\ncase 8:\r\nbreak;\r\ncase 15:\r\nvar->red.offset = 10;\r\nvar->red.length = 5;\r\nvar->green.offset = 6;\r\nvar->green.length = 5;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 5;\r\nbreak;\r\ncase 16:\r\nvar->red.offset = 11;\r\nvar->red.length = 5;\r\nvar->green.offset = 5;\r\nvar->green.length = 6;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 5;\r\nbreak;\r\ncase 18:\r\nvar->red.offset = 16;\r\nvar->red.length = 6;\r\nvar->green.offset = 8;\r\nvar->green.length = 6;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 6;\r\nvar->bits_per_pixel = 32;\r\nbreak;\r\ncase 32:\r\ncase 24:\r\nvar->transp.offset = 24;\r\nvar->transp.length = 8;\r\nvar->red.offset = 16;\r\nvar->red.length = 8;\r\nvar->green.offset = 8;\r\nvar->green.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 8;\r\nvar->bits_per_pixel = 32;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int jzfb_set_par(struct fb_info *info)\r\n{\r\nstruct jzfb *jzfb = info->par;\r\nstruct jz4740_fb_platform_data *pdata = jzfb->pdata;\r\nstruct fb_var_screeninfo *var = &info->var;\r\nstruct fb_videomode *mode;\r\nuint16_t hds, vds;\r\nuint16_t hde, vde;\r\nuint16_t ht, vt;\r\nuint32_t ctrl;\r\nuint32_t cfg;\r\nunsigned long rate;\r\nmode = jzfb_get_mode(jzfb, var);\r\nif (mode == NULL)\r\nreturn -EINVAL;\r\nif (mode == info->mode)\r\nreturn 0;\r\ninfo->mode = mode;\r\nhds = mode->hsync_len + mode->left_margin;\r\nhde = hds + mode->xres;\r\nht = hde + mode->right_margin;\r\nvds = mode->vsync_len + mode->upper_margin;\r\nvde = vds + mode->yres;\r\nvt = vde + mode->lower_margin;\r\nctrl = JZ_LCD_CTRL_OFUP | JZ_LCD_CTRL_BURST_16;\r\nswitch (pdata->bpp) {\r\ncase 1:\r\nctrl |= JZ_LCD_CTRL_BPP_1;\r\nbreak;\r\ncase 2:\r\nctrl |= JZ_LCD_CTRL_BPP_2;\r\nbreak;\r\ncase 4:\r\nctrl |= JZ_LCD_CTRL_BPP_4;\r\nbreak;\r\ncase 8:\r\nctrl |= JZ_LCD_CTRL_BPP_8;\r\nbreak;\r\ncase 15:\r\nctrl |= JZ_LCD_CTRL_RGB555;\r\ncase 16:\r\nctrl |= JZ_LCD_CTRL_BPP_15_16;\r\nbreak;\r\ncase 18:\r\ncase 24:\r\ncase 32:\r\nctrl |= JZ_LCD_CTRL_BPP_18_24;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ncfg = pdata->lcd_type & 0xf;\r\nif (!(mode->sync & FB_SYNC_HOR_HIGH_ACT))\r\ncfg |= JZ_LCD_CFG_HSYNC_ACTIVE_LOW;\r\nif (!(mode->sync & FB_SYNC_VERT_HIGH_ACT))\r\ncfg |= JZ_LCD_CFG_VSYNC_ACTIVE_LOW;\r\nif (pdata->pixclk_falling_edge)\r\ncfg |= JZ_LCD_CFG_PCLK_FALLING_EDGE;\r\nif (pdata->date_enable_active_low)\r\ncfg |= JZ_LCD_CFG_DE_ACTIVE_LOW;\r\nif (pdata->lcd_type == JZ_LCD_TYPE_GENERIC_18_BIT)\r\ncfg |= JZ_LCD_CFG_18_BIT;\r\nif (mode->pixclock) {\r\nrate = PICOS2KHZ(mode->pixclock) * 1000;\r\nmode->refresh = rate / vt / ht;\r\n} else {\r\nif (pdata->lcd_type == JZ_LCD_TYPE_8BIT_SERIAL)\r\nrate = mode->refresh * (vt + 2 * mode->xres) * ht;\r\nelse\r\nrate = mode->refresh * vt * ht;\r\nmode->pixclock = KHZ2PICOS(rate / 1000);\r\n}\r\nmutex_lock(&jzfb->lock);\r\nif (!jzfb->is_enabled)\r\nclk_enable(jzfb->ldclk);\r\nelse\r\nctrl |= JZ_LCD_CTRL_ENABLE;\r\nswitch (pdata->lcd_type) {\r\ncase JZ_LCD_TYPE_SPECIAL_TFT_1:\r\ncase JZ_LCD_TYPE_SPECIAL_TFT_2:\r\ncase JZ_LCD_TYPE_SPECIAL_TFT_3:\r\nwritel(pdata->special_tft_config.spl, jzfb->base + JZ_REG_LCD_SPL);\r\nwritel(pdata->special_tft_config.cls, jzfb->base + JZ_REG_LCD_CLS);\r\nwritel(pdata->special_tft_config.ps, jzfb->base + JZ_REG_LCD_PS);\r\nwritel(pdata->special_tft_config.ps, jzfb->base + JZ_REG_LCD_REV);\r\nbreak;\r\ndefault:\r\ncfg |= JZ_LCD_CFG_PS_DISABLE;\r\ncfg |= JZ_LCD_CFG_CLS_DISABLE;\r\ncfg |= JZ_LCD_CFG_SPL_DISABLE;\r\ncfg |= JZ_LCD_CFG_REV_DISABLE;\r\nbreak;\r\n}\r\nwritel(mode->hsync_len, jzfb->base + JZ_REG_LCD_HSYNC);\r\nwritel(mode->vsync_len, jzfb->base + JZ_REG_LCD_VSYNC);\r\nwritel((ht << 16) | vt, jzfb->base + JZ_REG_LCD_VAT);\r\nwritel((hds << 16) | hde, jzfb->base + JZ_REG_LCD_DAH);\r\nwritel((vds << 16) | vde, jzfb->base + JZ_REG_LCD_DAV);\r\nwritel(cfg, jzfb->base + JZ_REG_LCD_CFG);\r\nwritel(ctrl, jzfb->base + JZ_REG_LCD_CTRL);\r\nif (!jzfb->is_enabled)\r\nclk_disable_unprepare(jzfb->ldclk);\r\nmutex_unlock(&jzfb->lock);\r\nclk_set_rate(jzfb->lpclk, rate);\r\nclk_set_rate(jzfb->ldclk, rate * 3);\r\nreturn 0;\r\n}\r\nstatic void jzfb_enable(struct jzfb *jzfb)\r\n{\r\nuint32_t ctrl;\r\nclk_prepare_enable(jzfb->ldclk);\r\npinctrl_pm_select_default_state(&jzfb->pdev->dev);\r\nwritel(0, jzfb->base + JZ_REG_LCD_STATE);\r\nwritel(jzfb->framedesc->next, jzfb->base + JZ_REG_LCD_DA0);\r\nctrl = readl(jzfb->base + JZ_REG_LCD_CTRL);\r\nctrl |= JZ_LCD_CTRL_ENABLE;\r\nctrl &= ~JZ_LCD_CTRL_DISABLE;\r\nwritel(ctrl, jzfb->base + JZ_REG_LCD_CTRL);\r\n}\r\nstatic void jzfb_disable(struct jzfb *jzfb)\r\n{\r\nuint32_t ctrl;\r\nctrl = readl(jzfb->base + JZ_REG_LCD_CTRL);\r\nctrl |= JZ_LCD_CTRL_DISABLE;\r\nwritel(ctrl, jzfb->base + JZ_REG_LCD_CTRL);\r\ndo {\r\nctrl = readl(jzfb->base + JZ_REG_LCD_STATE);\r\n} while (!(ctrl & JZ_LCD_STATE_DISABLED));\r\npinctrl_pm_select_sleep_state(&jzfb->pdev->dev);\r\nclk_disable_unprepare(jzfb->ldclk);\r\n}\r\nstatic int jzfb_blank(int blank_mode, struct fb_info *info)\r\n{\r\nstruct jzfb *jzfb = info->par;\r\nswitch (blank_mode) {\r\ncase FB_BLANK_UNBLANK:\r\nmutex_lock(&jzfb->lock);\r\nif (jzfb->is_enabled) {\r\nmutex_unlock(&jzfb->lock);\r\nreturn 0;\r\n}\r\njzfb_enable(jzfb);\r\njzfb->is_enabled = 1;\r\nmutex_unlock(&jzfb->lock);\r\nbreak;\r\ndefault:\r\nmutex_lock(&jzfb->lock);\r\nif (!jzfb->is_enabled) {\r\nmutex_unlock(&jzfb->lock);\r\nreturn 0;\r\n}\r\njzfb_disable(jzfb);\r\njzfb->is_enabled = 0;\r\nmutex_unlock(&jzfb->lock);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int jzfb_alloc_devmem(struct jzfb *jzfb)\r\n{\r\nint max_videosize = 0;\r\nstruct fb_videomode *mode = jzfb->pdata->modes;\r\nvoid *page;\r\nint i;\r\nfor (i = 0; i < jzfb->pdata->num_modes; ++mode, ++i) {\r\nif (max_videosize < mode->xres * mode->yres)\r\nmax_videosize = mode->xres * mode->yres;\r\n}\r\nmax_videosize *= jzfb_get_controller_bpp(jzfb) >> 3;\r\njzfb->framedesc = dma_alloc_coherent(&jzfb->pdev->dev,\r\nsizeof(*jzfb->framedesc),\r\n&jzfb->framedesc_phys, GFP_KERNEL);\r\nif (!jzfb->framedesc)\r\nreturn -ENOMEM;\r\njzfb->vidmem_size = PAGE_ALIGN(max_videosize);\r\njzfb->vidmem = dma_alloc_coherent(&jzfb->pdev->dev,\r\njzfb->vidmem_size,\r\n&jzfb->vidmem_phys, GFP_KERNEL);\r\nif (!jzfb->vidmem)\r\ngoto err_free_framedesc;\r\nfor (page = jzfb->vidmem;\r\npage < jzfb->vidmem + PAGE_ALIGN(jzfb->vidmem_size);\r\npage += PAGE_SIZE) {\r\nSetPageReserved(virt_to_page(page));\r\n}\r\njzfb->framedesc->next = jzfb->framedesc_phys;\r\njzfb->framedesc->addr = jzfb->vidmem_phys;\r\njzfb->framedesc->id = 0xdeafbead;\r\njzfb->framedesc->cmd = 0;\r\njzfb->framedesc->cmd |= max_videosize / 4;\r\nreturn 0;\r\nerr_free_framedesc:\r\ndma_free_coherent(&jzfb->pdev->dev, sizeof(*jzfb->framedesc),\r\njzfb->framedesc, jzfb->framedesc_phys);\r\nreturn -ENOMEM;\r\n}\r\nstatic void jzfb_free_devmem(struct jzfb *jzfb)\r\n{\r\ndma_free_coherent(&jzfb->pdev->dev, jzfb->vidmem_size,\r\njzfb->vidmem, jzfb->vidmem_phys);\r\ndma_free_coherent(&jzfb->pdev->dev, sizeof(*jzfb->framedesc),\r\njzfb->framedesc, jzfb->framedesc_phys);\r\n}\r\nstatic int jzfb_probe(struct platform_device *pdev)\r\n{\r\nint ret;\r\nstruct jzfb *jzfb;\r\nstruct fb_info *fb;\r\nstruct jz4740_fb_platform_data *pdata = pdev->dev.platform_data;\r\nstruct resource *mem;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "Missing platform data\n");\r\nreturn -ENXIO;\r\n}\r\nfb = framebuffer_alloc(sizeof(struct jzfb), &pdev->dev);\r\nif (!fb) {\r\ndev_err(&pdev->dev, "Failed to allocate framebuffer device\n");\r\nreturn -ENOMEM;\r\n}\r\nfb->fbops = &jzfb_ops;\r\nfb->flags = FBINFO_DEFAULT;\r\njzfb = fb->par;\r\njzfb->pdev = pdev;\r\njzfb->pdata = pdata;\r\njzfb->ldclk = devm_clk_get(&pdev->dev, "lcd");\r\nif (IS_ERR(jzfb->ldclk)) {\r\nret = PTR_ERR(jzfb->ldclk);\r\ndev_err(&pdev->dev, "Failed to get lcd clock: %d\n", ret);\r\ngoto err_framebuffer_release;\r\n}\r\njzfb->lpclk = devm_clk_get(&pdev->dev, "lcd_pclk");\r\nif (IS_ERR(jzfb->lpclk)) {\r\nret = PTR_ERR(jzfb->lpclk);\r\ndev_err(&pdev->dev, "Failed to get lcd pixel clock: %d\n", ret);\r\ngoto err_framebuffer_release;\r\n}\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\njzfb->base = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(jzfb->base)) {\r\nret = PTR_ERR(jzfb->base);\r\ngoto err_framebuffer_release;\r\n}\r\nplatform_set_drvdata(pdev, jzfb);\r\nmutex_init(&jzfb->lock);\r\nfb_videomode_to_modelist(pdata->modes, pdata->num_modes,\r\n&fb->modelist);\r\nfb_videomode_to_var(&fb->var, pdata->modes);\r\nfb->var.bits_per_pixel = pdata->bpp;\r\njzfb_check_var(&fb->var, fb);\r\nret = jzfb_alloc_devmem(jzfb);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to allocate video memory\n");\r\ngoto err_framebuffer_release;\r\n}\r\nfb->fix = jzfb_fix;\r\nfb->fix.line_length = fb->var.bits_per_pixel * fb->var.xres / 8;\r\nfb->fix.mmio_start = mem->start;\r\nfb->fix.mmio_len = resource_size(mem);\r\nfb->fix.smem_start = jzfb->vidmem_phys;\r\nfb->fix.smem_len = fb->fix.line_length * fb->var.yres;\r\nfb->screen_base = jzfb->vidmem;\r\nfb->pseudo_palette = jzfb->pseudo_palette;\r\nfb_alloc_cmap(&fb->cmap, 256, 0);\r\nclk_prepare_enable(jzfb->ldclk);\r\njzfb->is_enabled = 1;\r\nwritel(jzfb->framedesc->next, jzfb->base + JZ_REG_LCD_DA0);\r\nfb->mode = NULL;\r\njzfb_set_par(fb);\r\nret = register_framebuffer(fb);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to register framebuffer: %d\n", ret);\r\ngoto err_free_devmem;\r\n}\r\njzfb->fb = fb;\r\nreturn 0;\r\nerr_free_devmem:\r\nfb_dealloc_cmap(&fb->cmap);\r\njzfb_free_devmem(jzfb);\r\nerr_framebuffer_release:\r\nframebuffer_release(fb);\r\nreturn ret;\r\n}\r\nstatic int jzfb_remove(struct platform_device *pdev)\r\n{\r\nstruct jzfb *jzfb = platform_get_drvdata(pdev);\r\njzfb_blank(FB_BLANK_POWERDOWN, jzfb->fb);\r\nfb_dealloc_cmap(&jzfb->fb->cmap);\r\njzfb_free_devmem(jzfb);\r\nframebuffer_release(jzfb->fb);\r\nreturn 0;\r\n}\r\nstatic int jzfb_suspend(struct device *dev)\r\n{\r\nstruct jzfb *jzfb = dev_get_drvdata(dev);\r\nconsole_lock();\r\nfb_set_suspend(jzfb->fb, 1);\r\nconsole_unlock();\r\nmutex_lock(&jzfb->lock);\r\nif (jzfb->is_enabled)\r\njzfb_disable(jzfb);\r\nmutex_unlock(&jzfb->lock);\r\nreturn 0;\r\n}\r\nstatic int jzfb_resume(struct device *dev)\r\n{\r\nstruct jzfb *jzfb = dev_get_drvdata(dev);\r\nclk_prepare_enable(jzfb->ldclk);\r\nmutex_lock(&jzfb->lock);\r\nif (jzfb->is_enabled)\r\njzfb_enable(jzfb);\r\nmutex_unlock(&jzfb->lock);\r\nconsole_lock();\r\nfb_set_suspend(jzfb->fb, 0);\r\nconsole_unlock();\r\nreturn 0;\r\n}
