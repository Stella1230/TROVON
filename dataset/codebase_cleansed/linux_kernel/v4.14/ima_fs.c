static int __init default_canonical_fmt_setup(char *str)\r\n{\r\n#ifdef __BIG_ENDIAN\r\nima_canonical_fmt = 1;\r\n#endif\r\nreturn 1;\r\n}\r\nstatic ssize_t ima_show_htable_value(char __user *buf, size_t count,\r\nloff_t *ppos, atomic_long_t *val)\r\n{\r\nchar tmpbuf[TMPBUFLEN];\r\nssize_t len;\r\nlen = scnprintf(tmpbuf, TMPBUFLEN, "%li\n", atomic_long_read(val));\r\nreturn simple_read_from_buffer(buf, count, ppos, tmpbuf, len);\r\n}\r\nstatic ssize_t ima_show_htable_violations(struct file *filp,\r\nchar __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nreturn ima_show_htable_value(buf, count, ppos, &ima_htable.violations);\r\n}\r\nstatic ssize_t ima_show_measurements_count(struct file *filp,\r\nchar __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nreturn ima_show_htable_value(buf, count, ppos, &ima_htable.len);\r\n}\r\nstatic void *ima_measurements_start(struct seq_file *m, loff_t *pos)\r\n{\r\nloff_t l = *pos;\r\nstruct ima_queue_entry *qe;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(qe, &ima_measurements, later) {\r\nif (!l--) {\r\nrcu_read_unlock();\r\nreturn qe;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn NULL;\r\n}\r\nstatic void *ima_measurements_next(struct seq_file *m, void *v, loff_t *pos)\r\n{\r\nstruct ima_queue_entry *qe = v;\r\nrcu_read_lock();\r\nqe = list_entry_rcu(qe->later.next, struct ima_queue_entry, later);\r\nrcu_read_unlock();\r\n(*pos)++;\r\nreturn (&qe->later == &ima_measurements) ? NULL : qe;\r\n}\r\nstatic void ima_measurements_stop(struct seq_file *m, void *v)\r\n{\r\n}\r\nvoid ima_putc(struct seq_file *m, void *data, int datalen)\r\n{\r\nwhile (datalen--)\r\nseq_putc(m, *(char *)data++);\r\n}\r\nint ima_measurements_show(struct seq_file *m, void *v)\r\n{\r\nstruct ima_queue_entry *qe = v;\r\nstruct ima_template_entry *e;\r\nchar *template_name;\r\nu32 pcr, namelen, template_data_len;\r\nbool is_ima_template = false;\r\nint i;\r\ne = qe->entry;\r\nif (e == NULL)\r\nreturn -1;\r\ntemplate_name = (e->template_desc->name[0] != '\0') ?\r\ne->template_desc->name : e->template_desc->fmt;\r\npcr = !ima_canonical_fmt ? e->pcr : cpu_to_le32(e->pcr);\r\nima_putc(m, &pcr, sizeof(e->pcr));\r\nima_putc(m, e->digest, TPM_DIGEST_SIZE);\r\nnamelen = !ima_canonical_fmt ? strlen(template_name) :\r\ncpu_to_le32(strlen(template_name));\r\nima_putc(m, &namelen, sizeof(namelen));\r\nima_putc(m, template_name, strlen(template_name));\r\nif (strcmp(template_name, IMA_TEMPLATE_IMA_NAME) == 0)\r\nis_ima_template = true;\r\nif (!is_ima_template) {\r\ntemplate_data_len = !ima_canonical_fmt ? e->template_data_len :\r\ncpu_to_le32(e->template_data_len);\r\nima_putc(m, &template_data_len, sizeof(e->template_data_len));\r\n}\r\nfor (i = 0; i < e->template_desc->num_fields; i++) {\r\nenum ima_show_type show = IMA_SHOW_BINARY;\r\nstruct ima_template_field *field = e->template_desc->fields[i];\r\nif (is_ima_template && strcmp(field->field_id, "d") == 0)\r\nshow = IMA_SHOW_BINARY_NO_FIELD_LEN;\r\nif (is_ima_template && strcmp(field->field_id, "n") == 0)\r\nshow = IMA_SHOW_BINARY_OLD_STRING_FMT;\r\nfield->field_show(m, show, &e->template_data[i]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ima_measurements_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &ima_measurments_seqops);\r\n}\r\nvoid ima_print_digest(struct seq_file *m, u8 *digest, u32 size)\r\n{\r\nu32 i;\r\nfor (i = 0; i < size; i++)\r\nseq_printf(m, "%02x", *(digest + i));\r\n}\r\nstatic int ima_ascii_measurements_show(struct seq_file *m, void *v)\r\n{\r\nstruct ima_queue_entry *qe = v;\r\nstruct ima_template_entry *e;\r\nchar *template_name;\r\nint i;\r\ne = qe->entry;\r\nif (e == NULL)\r\nreturn -1;\r\ntemplate_name = (e->template_desc->name[0] != '\0') ?\r\ne->template_desc->name : e->template_desc->fmt;\r\nseq_printf(m, "%2d ", e->pcr);\r\nima_print_digest(m, e->digest, TPM_DIGEST_SIZE);\r\nseq_printf(m, " %s", template_name);\r\nfor (i = 0; i < e->template_desc->num_fields; i++) {\r\nseq_puts(m, " ");\r\nif (e->template_data[i].len == 0)\r\ncontinue;\r\ne->template_desc->fields[i]->field_show(m, IMA_SHOW_ASCII,\r\n&e->template_data[i]);\r\n}\r\nseq_puts(m, "\n");\r\nreturn 0;\r\n}\r\nstatic int ima_ascii_measurements_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &ima_ascii_measurements_seqops);\r\n}\r\nstatic ssize_t ima_read_policy(char *path)\r\n{\r\nvoid *data;\r\nchar *datap;\r\nloff_t size;\r\nint rc, pathlen = strlen(path);\r\nchar *p;\r\ndatap = path;\r\nstrsep(&datap, "\n");\r\nrc = kernel_read_file_from_path(path, &data, &size, 0, READING_POLICY);\r\nif (rc < 0) {\r\npr_err("Unable to open file: %s (%d)", path, rc);\r\nreturn rc;\r\n}\r\ndatap = data;\r\nwhile (size > 0 && (p = strsep(&datap, "\n"))) {\r\npr_debug("rule: %s\n", p);\r\nrc = ima_parse_add_rule(p);\r\nif (rc < 0)\r\nbreak;\r\nsize -= rc;\r\n}\r\nvfree(data);\r\nif (rc < 0)\r\nreturn rc;\r\nelse if (size)\r\nreturn -EINVAL;\r\nelse\r\nreturn pathlen;\r\n}\r\nstatic ssize_t ima_write_policy(struct file *file, const char __user *buf,\r\nsize_t datalen, loff_t *ppos)\r\n{\r\nchar *data;\r\nssize_t result;\r\nif (datalen >= PAGE_SIZE)\r\ndatalen = PAGE_SIZE - 1;\r\nresult = -EINVAL;\r\nif (*ppos != 0)\r\ngoto out;\r\ndata = memdup_user_nul(buf, datalen);\r\nif (IS_ERR(data)) {\r\nresult = PTR_ERR(data);\r\ngoto out;\r\n}\r\nresult = mutex_lock_interruptible(&ima_write_mutex);\r\nif (result < 0)\r\ngoto out_free;\r\nif (data[0] == '/') {\r\nresult = ima_read_policy(data);\r\n} else if (ima_appraise & IMA_APPRAISE_POLICY) {\r\npr_err("IMA: signed policy file (specified as an absolute pathname) required\n");\r\nintegrity_audit_msg(AUDIT_INTEGRITY_STATUS, NULL, NULL,\r\n"policy_update", "signed policy required",\r\n1, 0);\r\nif (ima_appraise & IMA_APPRAISE_ENFORCE)\r\nresult = -EACCES;\r\n} else {\r\nresult = ima_parse_add_rule(data);\r\n}\r\nmutex_unlock(&ima_write_mutex);\r\nout_free:\r\nkfree(data);\r\nout:\r\nif (result < 0)\r\nvalid_policy = 0;\r\nreturn result;\r\n}\r\nstatic int ima_open_policy(struct inode *inode, struct file *filp)\r\n{\r\nif (!(filp->f_flags & O_WRONLY)) {\r\n#ifndef CONFIG_IMA_READ_POLICY\r\nreturn -EACCES;\r\n#else\r\nif ((filp->f_flags & O_ACCMODE) != O_RDONLY)\r\nreturn -EACCES;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nreturn seq_open(filp, &ima_policy_seqops);\r\n#endif\r\n}\r\nif (test_and_set_bit(IMA_FS_BUSY, &ima_fs_flags))\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic int ima_release_policy(struct inode *inode, struct file *file)\r\n{\r\nconst char *cause = valid_policy ? "completed" : "failed";\r\nif ((file->f_flags & O_ACCMODE) == O_RDONLY)\r\nreturn seq_release(inode, file);\r\nif (valid_policy && ima_check_policy() < 0) {\r\ncause = "failed";\r\nvalid_policy = 0;\r\n}\r\npr_info("IMA: policy update %s\n", cause);\r\nintegrity_audit_msg(AUDIT_INTEGRITY_STATUS, NULL, NULL,\r\n"policy_update", cause, !valid_policy, 0);\r\nif (!valid_policy) {\r\nima_delete_rules();\r\nvalid_policy = 1;\r\nclear_bit(IMA_FS_BUSY, &ima_fs_flags);\r\nreturn 0;\r\n}\r\nima_update_policy();\r\n#ifndef CONFIG_IMA_WRITE_POLICY\r\nsecurityfs_remove(ima_policy);\r\nima_policy = NULL;\r\n#else\r\nclear_bit(IMA_FS_BUSY, &ima_fs_flags);\r\n#endif\r\nreturn 0;\r\n}\r\nint __init ima_fs_init(void)\r\n{\r\nima_dir = securityfs_create_dir("ima", NULL);\r\nif (IS_ERR(ima_dir))\r\nreturn -1;\r\nbinary_runtime_measurements =\r\nsecurityfs_create_file("binary_runtime_measurements",\r\nS_IRUSR | S_IRGRP, ima_dir, NULL,\r\n&ima_measurements_ops);\r\nif (IS_ERR(binary_runtime_measurements))\r\ngoto out;\r\nascii_runtime_measurements =\r\nsecurityfs_create_file("ascii_runtime_measurements",\r\nS_IRUSR | S_IRGRP, ima_dir, NULL,\r\n&ima_ascii_measurements_ops);\r\nif (IS_ERR(ascii_runtime_measurements))\r\ngoto out;\r\nruntime_measurements_count =\r\nsecurityfs_create_file("runtime_measurements_count",\r\nS_IRUSR | S_IRGRP, ima_dir, NULL,\r\n&ima_measurements_count_ops);\r\nif (IS_ERR(runtime_measurements_count))\r\ngoto out;\r\nviolations =\r\nsecurityfs_create_file("violations", S_IRUSR | S_IRGRP,\r\nima_dir, NULL, &ima_htable_violations_ops);\r\nif (IS_ERR(violations))\r\ngoto out;\r\nima_policy = securityfs_create_file("policy", POLICY_FILE_FLAGS,\r\nima_dir, NULL,\r\n&ima_measure_policy_ops);\r\nif (IS_ERR(ima_policy))\r\ngoto out;\r\nreturn 0;\r\nout:\r\nsecurityfs_remove(violations);\r\nsecurityfs_remove(runtime_measurements_count);\r\nsecurityfs_remove(ascii_runtime_measurements);\r\nsecurityfs_remove(binary_runtime_measurements);\r\nsecurityfs_remove(ima_dir);\r\nsecurityfs_remove(ima_policy);\r\nreturn -1;\r\n}
