static int ec_get_version(struct cros_ec_dev *ec, char *str, int maxlen)\r\n{\r\nstruct ec_response_get_version *resp;\r\nstatic const char * const current_image_name[] = {\r\n"unknown", "read-only", "read-write", "invalid",\r\n};\r\nstruct cros_ec_command *msg;\r\nint ret;\r\nmsg = kmalloc(sizeof(*msg) + sizeof(*resp), GFP_KERNEL);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nmsg->version = 0;\r\nmsg->command = EC_CMD_GET_VERSION + ec->cmd_offset;\r\nmsg->insize = sizeof(*resp);\r\nmsg->outsize = 0;\r\nret = cros_ec_cmd_xfer(ec->ec_dev, msg);\r\nif (ret < 0)\r\ngoto exit;\r\nif (msg->result != EC_RES_SUCCESS) {\r\nsnprintf(str, maxlen,\r\n"%s\nUnknown EC version: EC returned %d\n",\r\nCROS_EC_DEV_VERSION, msg->result);\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nresp = (struct ec_response_get_version *)msg->data;\r\nif (resp->current_image >= ARRAY_SIZE(current_image_name))\r\nresp->current_image = 3;\r\nsnprintf(str, maxlen, "%s\n%s\n%s\n%s\n", CROS_EC_DEV_VERSION,\r\nresp->version_string_ro, resp->version_string_rw,\r\ncurrent_image_name[resp->current_image]);\r\nret = 0;\r\nexit:\r\nkfree(msg);\r\nreturn ret;\r\n}\r\nstatic int cros_ec_check_features(struct cros_ec_dev *ec, int feature)\r\n{\r\nstruct cros_ec_command *msg;\r\nint ret;\r\nif (ec->features[0] == -1U && ec->features[1] == -1U) {\r\nmsg = kmalloc(sizeof(*msg) + sizeof(ec->features), GFP_KERNEL);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nmsg->version = 0;\r\nmsg->command = EC_CMD_GET_FEATURES + ec->cmd_offset;\r\nmsg->insize = sizeof(ec->features);\r\nmsg->outsize = 0;\r\nret = cros_ec_cmd_xfer(ec->ec_dev, msg);\r\nif (ret < 0 || msg->result != EC_RES_SUCCESS) {\r\ndev_warn(ec->dev, "cannot get EC features: %d/%d\n",\r\nret, msg->result);\r\nmemset(ec->features, 0, sizeof(ec->features));\r\n}\r\nmemcpy(ec->features, msg->data, sizeof(ec->features));\r\ndev_dbg(ec->dev, "EC features %08x %08x\n",\r\nec->features[0], ec->features[1]);\r\nkfree(msg);\r\n}\r\nreturn ec->features[feature / 32] & EC_FEATURE_MASK_0(feature);\r\n}\r\nstatic int ec_device_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct cros_ec_dev *ec = container_of(inode->i_cdev,\r\nstruct cros_ec_dev, cdev);\r\nfilp->private_data = ec;\r\nnonseekable_open(inode, filp);\r\nreturn 0;\r\n}\r\nstatic int ec_device_release(struct inode *inode, struct file *filp)\r\n{\r\nreturn 0;\r\n}\r\nstatic ssize_t ec_device_read(struct file *filp, char __user *buffer,\r\nsize_t length, loff_t *offset)\r\n{\r\nstruct cros_ec_dev *ec = filp->private_data;\r\nchar msg[sizeof(struct ec_response_get_version) +\r\nsizeof(CROS_EC_DEV_VERSION)];\r\nsize_t count;\r\nint ret;\r\nif (*offset != 0)\r\nreturn 0;\r\nret = ec_get_version(ec, msg, sizeof(msg));\r\nif (ret)\r\nreturn ret;\r\ncount = min(length, strlen(msg));\r\nif (copy_to_user(buffer, msg, count))\r\nreturn -EFAULT;\r\n*offset = count;\r\nreturn count;\r\n}\r\nstatic long ec_device_ioctl_xcmd(struct cros_ec_dev *ec, void __user *arg)\r\n{\r\nlong ret;\r\nstruct cros_ec_command u_cmd;\r\nstruct cros_ec_command *s_cmd;\r\nif (copy_from_user(&u_cmd, arg, sizeof(u_cmd)))\r\nreturn -EFAULT;\r\nif ((u_cmd.outsize > EC_MAX_MSG_BYTES) ||\r\n(u_cmd.insize > EC_MAX_MSG_BYTES))\r\nreturn -EINVAL;\r\ns_cmd = kmalloc(sizeof(*s_cmd) + max(u_cmd.outsize, u_cmd.insize),\r\nGFP_KERNEL);\r\nif (!s_cmd)\r\nreturn -ENOMEM;\r\nif (copy_from_user(s_cmd, arg, sizeof(*s_cmd) + u_cmd.outsize)) {\r\nret = -EFAULT;\r\ngoto exit;\r\n}\r\nif (u_cmd.outsize != s_cmd->outsize ||\r\nu_cmd.insize != s_cmd->insize) {\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\ns_cmd->command += ec->cmd_offset;\r\nret = cros_ec_cmd_xfer(ec->ec_dev, s_cmd);\r\nif (ret < 0)\r\ngoto exit;\r\nif (copy_to_user(arg, s_cmd, sizeof(*s_cmd) + s_cmd->insize))\r\nret = -EFAULT;\r\nexit:\r\nkfree(s_cmd);\r\nreturn ret;\r\n}\r\nstatic long ec_device_ioctl_readmem(struct cros_ec_dev *ec, void __user *arg)\r\n{\r\nstruct cros_ec_device *ec_dev = ec->ec_dev;\r\nstruct cros_ec_readmem s_mem = { };\r\nlong num;\r\nif (!ec_dev->cmd_readmem)\r\nreturn -ENOTTY;\r\nif (copy_from_user(&s_mem, arg, sizeof(s_mem)))\r\nreturn -EFAULT;\r\nnum = ec_dev->cmd_readmem(ec_dev, s_mem.offset, s_mem.bytes,\r\ns_mem.buffer);\r\nif (num <= 0)\r\nreturn num;\r\nif (copy_to_user((void __user *)arg, &s_mem, sizeof(s_mem)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic long ec_device_ioctl(struct file *filp, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct cros_ec_dev *ec = filp->private_data;\r\nif (_IOC_TYPE(cmd) != CROS_EC_DEV_IOC)\r\nreturn -ENOTTY;\r\nswitch (cmd) {\r\ncase CROS_EC_DEV_IOCXCMD:\r\nreturn ec_device_ioctl_xcmd(ec, (void __user *)arg);\r\ncase CROS_EC_DEV_IOCRDMEM:\r\nreturn ec_device_ioctl_readmem(ec, (void __user *)arg);\r\n}\r\nreturn -ENOTTY;\r\n}\r\nstatic void __remove(struct device *dev)\r\n{\r\nstruct cros_ec_dev *ec = container_of(dev, struct cros_ec_dev,\r\nclass_dev);\r\nkfree(ec);\r\n}\r\nstatic void cros_ec_sensors_register(struct cros_ec_dev *ec)\r\n{\r\nint ret, i, id, sensor_num;\r\nstruct mfd_cell *sensor_cells;\r\nstruct cros_ec_sensor_platform *sensor_platforms;\r\nint sensor_type[MOTIONSENSE_TYPE_MAX];\r\nstruct ec_params_motion_sense *params;\r\nstruct ec_response_motion_sense *resp;\r\nstruct cros_ec_command *msg;\r\nmsg = kzalloc(sizeof(struct cros_ec_command) +\r\nmax(sizeof(*params), sizeof(*resp)), GFP_KERNEL);\r\nif (msg == NULL)\r\nreturn;\r\nmsg->version = 2;\r\nmsg->command = EC_CMD_MOTION_SENSE_CMD + ec->cmd_offset;\r\nmsg->outsize = sizeof(*params);\r\nmsg->insize = sizeof(*resp);\r\nparams = (struct ec_params_motion_sense *)msg->data;\r\nparams->cmd = MOTIONSENSE_CMD_DUMP;\r\nret = cros_ec_cmd_xfer(ec->ec_dev, msg);\r\nif (ret < 0 || msg->result != EC_RES_SUCCESS) {\r\ndev_warn(ec->dev, "cannot get EC sensor information: %d/%d\n",\r\nret, msg->result);\r\ngoto error;\r\n}\r\nresp = (struct ec_response_motion_sense *)msg->data;\r\nsensor_num = resp->dump.sensor_count;\r\nsensor_cells = kzalloc(sizeof(struct mfd_cell) * (sensor_num + 2),\r\nGFP_KERNEL);\r\nif (sensor_cells == NULL)\r\ngoto error;\r\nsensor_platforms = kzalloc(sizeof(struct cros_ec_sensor_platform) *\r\n(sensor_num + 1), GFP_KERNEL);\r\nif (sensor_platforms == NULL)\r\ngoto error_platforms;\r\nmemset(sensor_type, 0, sizeof(sensor_type));\r\nid = 0;\r\nfor (i = 0; i < sensor_num; i++) {\r\nparams->cmd = MOTIONSENSE_CMD_INFO;\r\nparams->info.sensor_num = i;\r\nret = cros_ec_cmd_xfer(ec->ec_dev, msg);\r\nif (ret < 0 || msg->result != EC_RES_SUCCESS) {\r\ndev_warn(ec->dev, "no info for EC sensor %d : %d/%d\n",\r\ni, ret, msg->result);\r\ncontinue;\r\n}\r\nswitch (resp->info.type) {\r\ncase MOTIONSENSE_TYPE_ACCEL:\r\nsensor_cells[id].name = "cros-ec-accel";\r\nbreak;\r\ncase MOTIONSENSE_TYPE_BARO:\r\nsensor_cells[id].name = "cros-ec-baro";\r\nbreak;\r\ncase MOTIONSENSE_TYPE_GYRO:\r\nsensor_cells[id].name = "cros-ec-gyro";\r\nbreak;\r\ncase MOTIONSENSE_TYPE_MAG:\r\nsensor_cells[id].name = "cros-ec-mag";\r\nbreak;\r\ncase MOTIONSENSE_TYPE_PROX:\r\nsensor_cells[id].name = "cros-ec-prox";\r\nbreak;\r\ncase MOTIONSENSE_TYPE_LIGHT:\r\nsensor_cells[id].name = "cros-ec-light";\r\nbreak;\r\ncase MOTIONSENSE_TYPE_ACTIVITY:\r\nsensor_cells[id].name = "cros-ec-activity";\r\nbreak;\r\ndefault:\r\ndev_warn(ec->dev, "unknown type %d\n", resp->info.type);\r\ncontinue;\r\n}\r\nsensor_platforms[id].sensor_num = i;\r\nsensor_cells[id].id = sensor_type[resp->info.type];\r\nsensor_cells[id].platform_data = &sensor_platforms[id];\r\nsensor_cells[id].pdata_size =\r\nsizeof(struct cros_ec_sensor_platform);\r\nsensor_type[resp->info.type]++;\r\nid++;\r\n}\r\nif (sensor_type[MOTIONSENSE_TYPE_ACCEL] >= 2) {\r\nsensor_platforms[id].sensor_num = sensor_num;\r\nsensor_cells[id].name = "cros-ec-angle";\r\nsensor_cells[id].id = 0;\r\nsensor_cells[id].platform_data = &sensor_platforms[id];\r\nsensor_cells[id].pdata_size =\r\nsizeof(struct cros_ec_sensor_platform);\r\nid++;\r\n}\r\nif (cros_ec_check_features(ec, EC_FEATURE_MOTION_SENSE_FIFO)) {\r\nsensor_cells[id].name = "cros-ec-ring";\r\nid++;\r\n}\r\nret = mfd_add_devices(ec->dev, 0, sensor_cells, id,\r\nNULL, 0, NULL);\r\nif (ret)\r\ndev_err(ec->dev, "failed to add EC sensors\n");\r\nkfree(sensor_platforms);\r\nerror_platforms:\r\nkfree(sensor_cells);\r\nerror:\r\nkfree(msg);\r\n}\r\nstatic int ec_device_probe(struct platform_device *pdev)\r\n{\r\nint retval = -ENOMEM;\r\nstruct device *dev = &pdev->dev;\r\nstruct cros_ec_platform *ec_platform = dev_get_platdata(dev);\r\nstruct cros_ec_dev *ec = kzalloc(sizeof(*ec), GFP_KERNEL);\r\nif (!ec)\r\nreturn retval;\r\ndev_set_drvdata(dev, ec);\r\nec->ec_dev = dev_get_drvdata(dev->parent);\r\nec->dev = dev;\r\nec->cmd_offset = ec_platform->cmd_offset;\r\nec->features[0] = -1U;\r\nec->features[1] = -1U;\r\ndevice_initialize(&ec->class_dev);\r\ncdev_init(&ec->cdev, &fops);\r\nec->class_dev.devt = MKDEV(ec_major, pdev->id);\r\nec->class_dev.class = &cros_class;\r\nec->class_dev.parent = dev;\r\nec->class_dev.release = __remove;\r\nretval = dev_set_name(&ec->class_dev, "%s", ec_platform->ec_name);\r\nif (retval) {\r\ndev_err(dev, "dev_set_name failed => %d\n", retval);\r\ngoto failed;\r\n}\r\nretval = cdev_device_add(&ec->cdev, &ec->class_dev);\r\nif (retval) {\r\ndev_err(dev, "cdev_device_add failed => %d\n", retval);\r\ngoto failed;\r\n}\r\nif (cros_ec_debugfs_init(ec))\r\ndev_warn(dev, "failed to create debugfs directory\n");\r\nif (cros_ec_check_features(ec, EC_FEATURE_MOTION_SENSE))\r\ncros_ec_sensors_register(ec);\r\nlb_manual_suspend_ctrl(ec, 1);\r\nreturn 0;\r\nfailed:\r\nput_device(&ec->class_dev);\r\nreturn retval;\r\n}\r\nstatic int ec_device_remove(struct platform_device *pdev)\r\n{\r\nstruct cros_ec_dev *ec = dev_get_drvdata(&pdev->dev);\r\nlb_manual_suspend_ctrl(ec, 0);\r\ncros_ec_debugfs_remove(ec);\r\ncdev_del(&ec->cdev);\r\ndevice_unregister(&ec->class_dev);\r\nreturn 0;\r\n}\r\nstatic __maybe_unused int ec_device_suspend(struct device *dev)\r\n{\r\nstruct cros_ec_dev *ec = dev_get_drvdata(dev);\r\nlb_suspend(ec);\r\nreturn 0;\r\n}\r\nstatic __maybe_unused int ec_device_resume(struct device *dev)\r\n{\r\nstruct cros_ec_dev *ec = dev_get_drvdata(dev);\r\nlb_resume(ec);\r\nreturn 0;\r\n}\r\nstatic int __init cros_ec_dev_init(void)\r\n{\r\nint ret;\r\ndev_t dev = 0;\r\nret = class_register(&cros_class);\r\nif (ret) {\r\npr_err(CROS_EC_DEV_NAME ": failed to register device class\n");\r\nreturn ret;\r\n}\r\nret = alloc_chrdev_region(&dev, 0, CROS_MAX_DEV, CROS_EC_DEV_NAME);\r\nif (ret < 0) {\r\npr_err(CROS_EC_DEV_NAME ": alloc_chrdev_region() failed\n");\r\ngoto failed_chrdevreg;\r\n}\r\nec_major = MAJOR(dev);\r\nret = platform_driver_register(&cros_ec_dev_driver);\r\nif (ret < 0) {\r\npr_warn(CROS_EC_DEV_NAME ": can't register driver: %d\n", ret);\r\ngoto failed_devreg;\r\n}\r\nreturn 0;\r\nfailed_devreg:\r\nunregister_chrdev_region(MKDEV(ec_major, 0), CROS_MAX_DEV);\r\nfailed_chrdevreg:\r\nclass_unregister(&cros_class);\r\nreturn ret;\r\n}\r\nstatic void __exit cros_ec_dev_exit(void)\r\n{\r\nplatform_driver_unregister(&cros_ec_dev_driver);\r\nunregister_chrdev(ec_major, CROS_EC_DEV_NAME);\r\nclass_unregister(&cros_class);\r\n}
