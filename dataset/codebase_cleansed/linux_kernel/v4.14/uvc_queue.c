static int uvc_queue_setup(struct vb2_queue *vq,\r\nunsigned int *nbuffers, unsigned int *nplanes,\r\nunsigned int sizes[], struct device *alloc_devs[])\r\n{\r\nstruct uvc_video_queue *queue = vb2_get_drv_priv(vq);\r\nstruct uvc_video *video = container_of(queue, struct uvc_video, queue);\r\nif (*nbuffers > UVC_MAX_VIDEO_BUFFERS)\r\n*nbuffers = UVC_MAX_VIDEO_BUFFERS;\r\n*nplanes = 1;\r\nsizes[0] = video->imagesize;\r\nreturn 0;\r\n}\r\nstatic int uvc_buffer_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct uvc_video_queue *queue = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct uvc_buffer *buf = container_of(vbuf, struct uvc_buffer, buf);\r\nif (vb->type == V4L2_BUF_TYPE_VIDEO_OUTPUT &&\r\nvb2_get_plane_payload(vb, 0) > vb2_plane_size(vb, 0)) {\r\nuvc_trace(UVC_TRACE_CAPTURE, "[E] Bytes used out of bounds.\n");\r\nreturn -EINVAL;\r\n}\r\nif (unlikely(queue->flags & UVC_QUEUE_DISCONNECTED))\r\nreturn -ENODEV;\r\nbuf->state = UVC_BUF_STATE_QUEUED;\r\nbuf->mem = vb2_plane_vaddr(vb, 0);\r\nbuf->length = vb2_plane_size(vb, 0);\r\nif (vb->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nbuf->bytesused = 0;\r\nelse\r\nbuf->bytesused = vb2_get_plane_payload(vb, 0);\r\nreturn 0;\r\n}\r\nstatic void uvc_buffer_queue(struct vb2_buffer *vb)\r\n{\r\nstruct uvc_video_queue *queue = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct uvc_buffer *buf = container_of(vbuf, struct uvc_buffer, buf);\r\nunsigned long flags;\r\nspin_lock_irqsave(&queue->irqlock, flags);\r\nif (likely(!(queue->flags & UVC_QUEUE_DISCONNECTED))) {\r\nlist_add_tail(&buf->queue, &queue->irqqueue);\r\n} else {\r\nbuf->state = UVC_BUF_STATE_ERROR;\r\nvb2_buffer_done(vb, VB2_BUF_STATE_ERROR);\r\n}\r\nspin_unlock_irqrestore(&queue->irqlock, flags);\r\n}\r\nint uvcg_queue_init(struct uvc_video_queue *queue, enum v4l2_buf_type type,\r\nstruct mutex *lock)\r\n{\r\nint ret;\r\nqueue->queue.type = type;\r\nqueue->queue.io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\r\nqueue->queue.drv_priv = queue;\r\nqueue->queue.buf_struct_size = sizeof(struct uvc_buffer);\r\nqueue->queue.ops = &uvc_queue_qops;\r\nqueue->queue.lock = lock;\r\nqueue->queue.mem_ops = &vb2_vmalloc_memops;\r\nqueue->queue.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC\r\n| V4L2_BUF_FLAG_TSTAMP_SRC_EOF;\r\nret = vb2_queue_init(&queue->queue);\r\nif (ret)\r\nreturn ret;\r\nspin_lock_init(&queue->irqlock);\r\nINIT_LIST_HEAD(&queue->irqqueue);\r\nqueue->flags = 0;\r\nreturn 0;\r\n}\r\nvoid uvcg_free_buffers(struct uvc_video_queue *queue)\r\n{\r\nvb2_queue_release(&queue->queue);\r\n}\r\nint uvcg_alloc_buffers(struct uvc_video_queue *queue,\r\nstruct v4l2_requestbuffers *rb)\r\n{\r\nint ret;\r\nret = vb2_reqbufs(&queue->queue, rb);\r\nreturn ret ? ret : rb->count;\r\n}\r\nint uvcg_query_buffer(struct uvc_video_queue *queue, struct v4l2_buffer *buf)\r\n{\r\nreturn vb2_querybuf(&queue->queue, buf);\r\n}\r\nint uvcg_queue_buffer(struct uvc_video_queue *queue, struct v4l2_buffer *buf)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nret = vb2_qbuf(&queue->queue, buf);\r\nif (ret < 0)\r\nreturn ret;\r\nspin_lock_irqsave(&queue->irqlock, flags);\r\nret = (queue->flags & UVC_QUEUE_PAUSED) != 0;\r\nqueue->flags &= ~UVC_QUEUE_PAUSED;\r\nspin_unlock_irqrestore(&queue->irqlock, flags);\r\nreturn ret;\r\n}\r\nint uvcg_dequeue_buffer(struct uvc_video_queue *queue, struct v4l2_buffer *buf,\r\nint nonblocking)\r\n{\r\nreturn vb2_dqbuf(&queue->queue, buf, nonblocking);\r\n}\r\nunsigned int uvcg_queue_poll(struct uvc_video_queue *queue, struct file *file,\r\npoll_table *wait)\r\n{\r\nreturn vb2_poll(&queue->queue, file, wait);\r\n}\r\nint uvcg_queue_mmap(struct uvc_video_queue *queue, struct vm_area_struct *vma)\r\n{\r\nreturn vb2_mmap(&queue->queue, vma);\r\n}\r\nunsigned long uvcg_queue_get_unmapped_area(struct uvc_video_queue *queue,\r\nunsigned long pgoff)\r\n{\r\nreturn vb2_get_unmapped_area(&queue->queue, 0, 0, pgoff, 0);\r\n}\r\nvoid uvcg_queue_cancel(struct uvc_video_queue *queue, int disconnect)\r\n{\r\nstruct uvc_buffer *buf;\r\nunsigned long flags;\r\nspin_lock_irqsave(&queue->irqlock, flags);\r\nwhile (!list_empty(&queue->irqqueue)) {\r\nbuf = list_first_entry(&queue->irqqueue, struct uvc_buffer,\r\nqueue);\r\nlist_del(&buf->queue);\r\nbuf->state = UVC_BUF_STATE_ERROR;\r\nvb2_buffer_done(&buf->buf.vb2_buf, VB2_BUF_STATE_ERROR);\r\n}\r\nif (disconnect)\r\nqueue->flags |= UVC_QUEUE_DISCONNECTED;\r\nspin_unlock_irqrestore(&queue->irqlock, flags);\r\n}\r\nint uvcg_queue_enable(struct uvc_video_queue *queue, int enable)\r\n{\r\nunsigned long flags;\r\nint ret = 0;\r\nif (enable) {\r\nret = vb2_streamon(&queue->queue, queue->queue.type);\r\nif (ret < 0)\r\nreturn ret;\r\nqueue->sequence = 0;\r\nqueue->buf_used = 0;\r\n} else {\r\nret = vb2_streamoff(&queue->queue, queue->queue.type);\r\nif (ret < 0)\r\nreturn ret;\r\nspin_lock_irqsave(&queue->irqlock, flags);\r\nINIT_LIST_HEAD(&queue->irqqueue);\r\nqueue->flags &= ~UVC_QUEUE_DISCONNECTED;\r\nspin_unlock_irqrestore(&queue->irqlock, flags);\r\n}\r\nreturn ret;\r\n}\r\nstruct uvc_buffer *uvcg_queue_next_buffer(struct uvc_video_queue *queue,\r\nstruct uvc_buffer *buf)\r\n{\r\nstruct uvc_buffer *nextbuf;\r\nif ((queue->flags & UVC_QUEUE_DROP_INCOMPLETE) &&\r\nbuf->length != buf->bytesused) {\r\nbuf->state = UVC_BUF_STATE_QUEUED;\r\nvb2_set_plane_payload(&buf->buf.vb2_buf, 0, 0);\r\nreturn buf;\r\n}\r\nlist_del(&buf->queue);\r\nif (!list_empty(&queue->irqqueue))\r\nnextbuf = list_first_entry(&queue->irqqueue, struct uvc_buffer,\r\nqueue);\r\nelse\r\nnextbuf = NULL;\r\nbuf->buf.field = V4L2_FIELD_NONE;\r\nbuf->buf.sequence = queue->sequence++;\r\nbuf->buf.vb2_buf.timestamp = ktime_get_ns();\r\nvb2_set_plane_payload(&buf->buf.vb2_buf, 0, buf->bytesused);\r\nvb2_buffer_done(&buf->buf.vb2_buf, VB2_BUF_STATE_DONE);\r\nreturn nextbuf;\r\n}\r\nstruct uvc_buffer *uvcg_queue_head(struct uvc_video_queue *queue)\r\n{\r\nstruct uvc_buffer *buf = NULL;\r\nif (!list_empty(&queue->irqqueue))\r\nbuf = list_first_entry(&queue->irqqueue, struct uvc_buffer,\r\nqueue);\r\nelse\r\nqueue->flags |= UVC_QUEUE_PAUSED;\r\nreturn buf;\r\n}
