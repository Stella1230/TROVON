static bool rt8973a_muic_volatile_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase RT8973A_REG_INTM1:\r\ncase RT8973A_REG_INTM2:\r\nreturn true;\r\ndefault:\r\nbreak;\r\n}\r\nreturn false;\r\n}\r\nstatic int rt8973a_muic_set_path(struct rt8973a_muic_info *info,\r\nunsigned int con_sw, bool attached)\r\n{\r\nint ret;\r\nif (info->auto_config)\r\nreturn 0;\r\nif (!attached)\r\ncon_sw = DM_DP_SWITCH_UART;\r\nswitch (con_sw) {\r\ncase DM_DP_SWITCH_OPEN:\r\ncase DM_DP_SWITCH_USB:\r\ncase DM_DP_SWITCH_UART:\r\nret = regmap_update_bits(info->regmap, RT8973A_REG_MANUAL_SW1,\r\nRT8973A_REG_MANUAL_SW1_DP_MASK |\r\nRT8973A_REG_MANUAL_SW1_DM_MASK,\r\ncon_sw);\r\nif (ret < 0) {\r\ndev_err(info->dev,\r\n"cannot update DM_CON/DP_CON switch\n");\r\nreturn ret;\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(info->dev, "Unknown DM_CON/DP_CON switch type (%d)\n",\r\ncon_sw);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rt8973a_muic_get_cable_type(struct rt8973a_muic_info *info)\r\n{\r\nunsigned int adc, dev1;\r\nint ret, cable_type;\r\nret = regmap_read(info->regmap, RT8973A_REG_ADC, &adc);\r\nif (ret) {\r\ndev_err(info->dev, "failed to read ADC register\n");\r\nreturn ret;\r\n}\r\ncable_type = adc & RT8973A_REG_ADC_MASK;\r\nret = regmap_read(info->regmap, RT8973A_REG_DEV1, &dev1);\r\nif (ret) {\r\ndev_err(info->dev, "failed to read DEV1 register\n");\r\nreturn ret;\r\n}\r\nswitch (adc) {\r\ncase RT8973A_MUIC_ADC_OPEN:\r\nif (dev1 & RT8973A_REG_DEV1_USB_MASK)\r\ncable_type = RT8973A_MUIC_ADC_USB;\r\nelse if (dev1 & RT8973A_REG_DEV1_DCPORT_MASK)\r\ncable_type = RT8973A_MUIC_ADC_TA;\r\nelse\r\ncable_type = RT8973A_MUIC_ADC_OPEN;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn cable_type;\r\n}\r\nstatic int rt8973a_muic_cable_handler(struct rt8973a_muic_info *info,\r\nenum rt8973a_event_type event)\r\n{\r\nstatic unsigned int prev_cable_type;\r\nunsigned int con_sw = DM_DP_SWITCH_UART;\r\nint ret, cable_type;\r\nunsigned int id;\r\nbool attached = false;\r\nswitch (event) {\r\ncase RT8973A_EVENT_ATTACH:\r\ncable_type = rt8973a_muic_get_cable_type(info);\r\nattached = true;\r\nbreak;\r\ncase RT8973A_EVENT_DETACH:\r\ncable_type = prev_cable_type;\r\nattached = false;\r\nbreak;\r\ncase RT8973A_EVENT_OVP:\r\ncase RT8973A_EVENT_OTP:\r\ndev_warn(info->dev,\r\n"happen Over %s issue. Need to disconnect all cables\n",\r\nevent == RT8973A_EVENT_OVP ? "Voltage" : "Temperature");\r\ncable_type = prev_cable_type;\r\nattached = false;\r\nbreak;\r\ndefault:\r\ndev_err(info->dev,\r\n"Cannot handle this event (event:%d)\n", event);\r\nreturn -EINVAL;\r\n}\r\nprev_cable_type = cable_type;\r\nswitch (cable_type) {\r\ncase RT8973A_MUIC_ADC_OTG:\r\nid = EXTCON_USB_HOST;\r\ncon_sw = DM_DP_SWITCH_USB;\r\nbreak;\r\ncase RT8973A_MUIC_ADC_TA:\r\nid = EXTCON_CHG_USB_DCP;\r\ncon_sw = DM_DP_SWITCH_OPEN;\r\nbreak;\r\ncase RT8973A_MUIC_ADC_FACTORY_MODE_BOOT_OFF_USB:\r\ncase RT8973A_MUIC_ADC_FACTORY_MODE_BOOT_ON_USB:\r\nid = EXTCON_JIG;\r\ncon_sw = DM_DP_SWITCH_USB;\r\nbreak;\r\ncase RT8973A_MUIC_ADC_FACTORY_MODE_BOOT_OFF_UART:\r\ncase RT8973A_MUIC_ADC_FACTORY_MODE_BOOT_ON_UART:\r\nid = EXTCON_JIG;\r\ncon_sw = DM_DP_SWITCH_UART;\r\nbreak;\r\ncase RT8973A_MUIC_ADC_USB:\r\nid = EXTCON_USB;\r\ncon_sw = DM_DP_SWITCH_USB;\r\nbreak;\r\ncase RT8973A_MUIC_ADC_OPEN:\r\nreturn 0;\r\ncase RT8973A_MUIC_ADC_UNKNOWN_ACC_1:\r\ncase RT8973A_MUIC_ADC_UNKNOWN_ACC_2:\r\ncase RT8973A_MUIC_ADC_UNKNOWN_ACC_3:\r\ncase RT8973A_MUIC_ADC_UNKNOWN_ACC_4:\r\ncase RT8973A_MUIC_ADC_UNKNOWN_ACC_5:\r\ndev_warn(info->dev,\r\n"Unknown accessory type (adc:0x%x)\n", cable_type);\r\nreturn 0;\r\ncase RT8973A_MUIC_ADC_AUDIO_SEND_END_BUTTON:\r\ncase RT8973A_MUIC_ADC_AUDIO_REMOTE_S1_BUTTON:\r\ncase RT8973A_MUIC_ADC_AUDIO_REMOTE_S2_BUTTON:\r\ncase RT8973A_MUIC_ADC_AUDIO_REMOTE_S3_BUTTON:\r\ncase RT8973A_MUIC_ADC_AUDIO_REMOTE_S4_BUTTON:\r\ncase RT8973A_MUIC_ADC_AUDIO_REMOTE_S5_BUTTON:\r\ncase RT8973A_MUIC_ADC_AUDIO_REMOTE_S6_BUTTON:\r\ncase RT8973A_MUIC_ADC_AUDIO_REMOTE_S7_BUTTON:\r\ncase RT8973A_MUIC_ADC_AUDIO_REMOTE_S8_BUTTON:\r\ncase RT8973A_MUIC_ADC_AUDIO_REMOTE_S9_BUTTON:\r\ncase RT8973A_MUIC_ADC_AUDIO_REMOTE_S10_BUTTON:\r\ncase RT8973A_MUIC_ADC_AUDIO_REMOTE_S11_BUTTON:\r\ncase RT8973A_MUIC_ADC_AUDIO_REMOTE_S12_BUTTON:\r\ncase RT8973A_MUIC_ADC_AUDIO_TYPE2:\r\ndev_warn(info->dev,\r\n"Audio device/button type (adc:0x%x)\n", cable_type);\r\nreturn 0;\r\ncase RT8973A_MUIC_ADC_RESERVED_ACC_1:\r\ncase RT8973A_MUIC_ADC_RESERVED_ACC_2:\r\ncase RT8973A_MUIC_ADC_RESERVED_ACC_3:\r\ncase RT8973A_MUIC_ADC_RESERVED_ACC_4:\r\ncase RT8973A_MUIC_ADC_RESERVED_ACC_5:\r\ncase RT8973A_MUIC_ADC_PHONE_POWERED_DEV:\r\nreturn 0;\r\ndefault:\r\ndev_err(info->dev,\r\n"Cannot handle this cable_type (adc:0x%x)\n",\r\ncable_type);\r\nreturn -EINVAL;\r\n}\r\nret = rt8973a_muic_set_path(info, con_sw, attached);\r\nif (ret < 0)\r\nreturn ret;\r\nextcon_set_state_sync(info->edev, id, attached);\r\nif (id == EXTCON_USB)\r\nextcon_set_state_sync(info->edev, EXTCON_CHG_USB_SDP,\r\nattached);\r\nreturn 0;\r\n}\r\nstatic void rt8973a_muic_irq_work(struct work_struct *work)\r\n{\r\nstruct rt8973a_muic_info *info = container_of(work,\r\nstruct rt8973a_muic_info, irq_work);\r\nint ret = 0;\r\nif (!info->edev)\r\nreturn;\r\nmutex_lock(&info->mutex);\r\nif (info->irq_attach) {\r\nret = rt8973a_muic_cable_handler(info, RT8973A_EVENT_ATTACH);\r\ninfo->irq_attach = false;\r\n}\r\nif (info->irq_detach) {\r\nret = rt8973a_muic_cable_handler(info, RT8973A_EVENT_DETACH);\r\ninfo->irq_detach = false;\r\n}\r\nif (info->irq_ovp) {\r\nret = rt8973a_muic_cable_handler(info, RT8973A_EVENT_OVP);\r\ninfo->irq_ovp = false;\r\n}\r\nif (info->irq_otp) {\r\nret = rt8973a_muic_cable_handler(info, RT8973A_EVENT_OTP);\r\ninfo->irq_otp = false;\r\n}\r\nif (ret < 0)\r\ndev_err(info->dev, "failed to handle MUIC interrupt\n");\r\nmutex_unlock(&info->mutex);\r\n}\r\nstatic irqreturn_t rt8973a_muic_irq_handler(int irq, void *data)\r\n{\r\nstruct rt8973a_muic_info *info = data;\r\nint i, irq_type = -1;\r\nfor (i = 0; i < info->num_muic_irqs; i++)\r\nif (irq == info->muic_irqs[i].virq)\r\nirq_type = info->muic_irqs[i].irq;\r\nswitch (irq_type) {\r\ncase RT8973A_INT1_ATTACH:\r\ninfo->irq_attach = true;\r\nbreak;\r\ncase RT8973A_INT1_DETACH:\r\ninfo->irq_detach = true;\r\nbreak;\r\ncase RT8973A_INT1_OVP:\r\ninfo->irq_ovp = true;\r\nbreak;\r\ncase RT8973A_INT1_OTP:\r\ninfo->irq_otp = true;\r\nbreak;\r\ncase RT8973A_INT1_CHGDET:\r\ncase RT8973A_INT1_DCD_T:\r\ncase RT8973A_INT1_CONNECT:\r\ncase RT8973A_INT1_ADC_CHG:\r\ncase RT8973A_INT2_UVLO:\r\ncase RT8973A_INT2_POR:\r\ncase RT8973A_INT2_OTP_FET:\r\ncase RT8973A_INT2_OVP_FET:\r\ncase RT8973A_INT2_OCP_LATCH:\r\ncase RT8973A_INT2_OCP:\r\ncase RT8973A_INT2_OVP_OCP:\r\ndefault:\r\ndev_dbg(info->dev,\r\n"Cannot handle this interrupt (%d)\n", irq_type);\r\nbreak;\r\n}\r\nschedule_work(&info->irq_work);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void rt8973a_muic_detect_cable_wq(struct work_struct *work)\r\n{\r\nstruct rt8973a_muic_info *info = container_of(to_delayed_work(work),\r\nstruct rt8973a_muic_info, wq_detcable);\r\nint ret;\r\nret = rt8973a_muic_cable_handler(info, RT8973A_EVENT_ATTACH);\r\nif (ret < 0)\r\ndev_warn(info->dev, "failed to detect cable state\n");\r\n}\r\nstatic void rt8973a_init_dev_type(struct rt8973a_muic_info *info)\r\n{\r\nunsigned int data, vendor_id, version_id;\r\nint i, ret;\r\nret = regmap_read(info->regmap, RT8973A_REG_DEVICE_ID, &data);\r\nif (ret) {\r\ndev_err(info->dev,\r\n"failed to read DEVICE_ID register: %d\n", ret);\r\nreturn;\r\n}\r\nvendor_id = ((data & RT8973A_REG_DEVICE_ID_VENDOR_MASK) >>\r\nRT8973A_REG_DEVICE_ID_VENDOR_SHIFT);\r\nversion_id = ((data & RT8973A_REG_DEVICE_ID_VERSION_MASK) >>\r\nRT8973A_REG_DEVICE_ID_VERSION_SHIFT);\r\ndev_info(info->dev, "Device type: version: 0x%x, vendor: 0x%x\n",\r\nversion_id, vendor_id);\r\nfor (i = 0; i < info->num_reg_data; i++) {\r\nu8 reg = info->reg_data[i].reg;\r\nu8 mask = info->reg_data[i].mask;\r\nu8 val = 0;\r\nif (info->reg_data[i].invert)\r\nval = ~info->reg_data[i].val;\r\nelse\r\nval = info->reg_data[i].val;\r\nregmap_update_bits(info->regmap, reg, mask, val);\r\n}\r\nret = regmap_read(info->regmap, RT8973A_REG_CONTROL1, &data);\r\nif (ret) {\r\ndev_err(info->dev,\r\n"failed to read CONTROL1 register: %d\n", ret);\r\nreturn;\r\n}\r\ndata &= RT8973A_REG_CONTROL1_AUTO_CONFIG_MASK;\r\nif (data) {\r\ninfo->auto_config = true;\r\ndev_info(info->dev,\r\n"Enable Auto-configuration for internal path\n");\r\n}\r\n}\r\nstatic int rt8973a_muic_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device_node *np = i2c->dev.of_node;\r\nstruct rt8973a_muic_info *info;\r\nint i, ret, irq_flags;\r\nif (!np)\r\nreturn -EINVAL;\r\ninfo = devm_kzalloc(&i2c->dev, sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(i2c, info);\r\ninfo->dev = &i2c->dev;\r\ninfo->i2c = i2c;\r\ninfo->irq = i2c->irq;\r\ninfo->muic_irqs = rt8973a_muic_irqs;\r\ninfo->num_muic_irqs = ARRAY_SIZE(rt8973a_muic_irqs);\r\ninfo->reg_data = rt8973a_reg_data;\r\ninfo->num_reg_data = ARRAY_SIZE(rt8973a_reg_data);\r\nmutex_init(&info->mutex);\r\nINIT_WORK(&info->irq_work, rt8973a_muic_irq_work);\r\ninfo->regmap = devm_regmap_init_i2c(i2c, &rt8973a_muic_regmap_config);\r\nif (IS_ERR(info->regmap)) {\r\nret = PTR_ERR(info->regmap);\r\ndev_err(info->dev, "failed to allocate register map: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nirq_flags = IRQF_TRIGGER_FALLING | IRQF_ONESHOT | IRQF_SHARED;\r\nret = regmap_add_irq_chip(info->regmap, info->irq, irq_flags, 0,\r\n&rt8973a_muic_irq_chip, &info->irq_data);\r\nif (ret != 0) {\r\ndev_err(info->dev, "failed to add irq_chip (irq:%d, err:%d)\n",\r\ninfo->irq, ret);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < info->num_muic_irqs; i++) {\r\nstruct muic_irq *muic_irq = &info->muic_irqs[i];\r\nint virq = 0;\r\nvirq = regmap_irq_get_virq(info->irq_data, muic_irq->irq);\r\nif (virq <= 0)\r\nreturn -EINVAL;\r\nmuic_irq->virq = virq;\r\nret = devm_request_threaded_irq(info->dev, virq, NULL,\r\nrt8973a_muic_irq_handler,\r\nIRQF_NO_SUSPEND | IRQF_ONESHOT,\r\nmuic_irq->name, info);\r\nif (ret) {\r\ndev_err(info->dev,\r\n"failed: irq request (IRQ: %d, error :%d)\n",\r\nmuic_irq->irq, ret);\r\nreturn ret;\r\n}\r\n}\r\ninfo->edev = devm_extcon_dev_allocate(info->dev, rt8973a_extcon_cable);\r\nif (IS_ERR(info->edev)) {\r\ndev_err(info->dev, "failed to allocate memory for extcon\n");\r\nreturn -ENOMEM;\r\n}\r\nret = devm_extcon_dev_register(info->dev, info->edev);\r\nif (ret) {\r\ndev_err(info->dev, "failed to register extcon device\n");\r\nreturn ret;\r\n}\r\nINIT_DELAYED_WORK(&info->wq_detcable, rt8973a_muic_detect_cable_wq);\r\nqueue_delayed_work(system_power_efficient_wq, &info->wq_detcable,\r\nmsecs_to_jiffies(DELAY_MS_DEFAULT));\r\nrt8973a_init_dev_type(info);\r\nreturn 0;\r\n}\r\nstatic int rt8973a_muic_i2c_remove(struct i2c_client *i2c)\r\n{\r\nstruct rt8973a_muic_info *info = i2c_get_clientdata(i2c);\r\nregmap_del_irq_chip(info->irq, info->irq_data);\r\nreturn 0;\r\n}\r\nstatic int rt8973a_muic_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *i2c = to_i2c_client(dev);\r\nstruct rt8973a_muic_info *info = i2c_get_clientdata(i2c);\r\nenable_irq_wake(info->irq);\r\nreturn 0;\r\n}\r\nstatic int rt8973a_muic_resume(struct device *dev)\r\n{\r\nstruct i2c_client *i2c = to_i2c_client(dev);\r\nstruct rt8973a_muic_info *info = i2c_get_clientdata(i2c);\r\ndisable_irq_wake(info->irq);\r\nreturn 0;\r\n}\r\nstatic int __init rt8973a_muic_i2c_init(void)\r\n{\r\nreturn i2c_add_driver(&rt8973a_muic_i2c_driver);\r\n}
