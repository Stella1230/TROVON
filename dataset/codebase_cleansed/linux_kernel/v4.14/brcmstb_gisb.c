static u32 gisb_read(struct brcmstb_gisb_arb_device *gdev, int reg)\r\n{\r\nint offset = gdev->gisb_offsets[reg];\r\nif (offset < 0) {\r\nif (reg == ARB_ERR_CAP_MASTER)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nif (gdev->big_endian)\r\nreturn ioread32be(gdev->base + offset);\r\nelse\r\nreturn ioread32(gdev->base + offset);\r\n}\r\nstatic u64 gisb_read_address(struct brcmstb_gisb_arb_device *gdev)\r\n{\r\nu64 value;\r\nvalue = gisb_read(gdev, ARB_ERR_CAP_ADDR);\r\nvalue |= (u64)gisb_read(gdev, ARB_ERR_CAP_HI_ADDR) << 32;\r\nreturn value;\r\n}\r\nstatic void gisb_write(struct brcmstb_gisb_arb_device *gdev, u32 val, int reg)\r\n{\r\nint offset = gdev->gisb_offsets[reg];\r\nif (offset == -1)\r\nreturn;\r\nif (gdev->big_endian)\r\niowrite32be(val, gdev->base + offset);\r\nelse\r\niowrite32(val, gdev->base + offset);\r\n}\r\nstatic ssize_t gisb_arb_get_timeout(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct brcmstb_gisb_arb_device *gdev = platform_get_drvdata(pdev);\r\nu32 timeout;\r\nmutex_lock(&gdev->lock);\r\ntimeout = gisb_read(gdev, ARB_TIMER);\r\nmutex_unlock(&gdev->lock);\r\nreturn sprintf(buf, "%d", timeout);\r\n}\r\nstatic ssize_t gisb_arb_set_timeout(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct brcmstb_gisb_arb_device *gdev = platform_get_drvdata(pdev);\r\nint val, ret;\r\nret = kstrtoint(buf, 10, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nif (val == 0 || val >= 0xffffffff)\r\nreturn -EINVAL;\r\nmutex_lock(&gdev->lock);\r\ngisb_write(gdev, val, ARB_TIMER);\r\nmutex_unlock(&gdev->lock);\r\nreturn count;\r\n}\r\nstatic const char *\r\nbrcmstb_gisb_master_to_str(struct brcmstb_gisb_arb_device *gdev,\r\nu32 masters)\r\n{\r\nu32 mask = gdev->valid_mask & masters;\r\nif (hweight_long(mask) != 1)\r\nreturn NULL;\r\nreturn gdev->master_names[ffs(mask) - 1];\r\n}\r\nstatic int brcmstb_gisb_arb_decode_addr(struct brcmstb_gisb_arb_device *gdev,\r\nconst char *reason)\r\n{\r\nu32 cap_status;\r\nu64 arb_addr;\r\nu32 master;\r\nconst char *m_name;\r\nchar m_fmt[11];\r\ncap_status = gisb_read(gdev, ARB_ERR_CAP_STATUS);\r\nif (!(cap_status & ARB_ERR_CAP_STATUS_VALID))\r\nreturn 1;\r\narb_addr = gisb_read_address(gdev);\r\nmaster = gisb_read(gdev, ARB_ERR_CAP_MASTER);\r\nm_name = brcmstb_gisb_master_to_str(gdev, master);\r\nif (!m_name) {\r\nsnprintf(m_fmt, sizeof(m_fmt), "0x%08x", master);\r\nm_name = m_fmt;\r\n}\r\npr_crit("%s: %s at 0x%llx [%c %s], core: %s\n",\r\n__func__, reason, arb_addr,\r\ncap_status & ARB_ERR_CAP_STATUS_WRITE ? 'W' : 'R',\r\ncap_status & ARB_ERR_CAP_STATUS_TIMEOUT ? "timeout" : "",\r\nm_name);\r\ngisb_write(gdev, ARB_ERR_CAP_CLEAR, ARB_ERR_CAP_CLR);\r\nreturn 0;\r\n}\r\nstatic int brcmstb_bus_error_handler(struct pt_regs *regs, int is_fixup)\r\n{\r\nint ret = 0;\r\nstruct brcmstb_gisb_arb_device *gdev;\r\nu32 cap_status;\r\nlist_for_each_entry(gdev, &brcmstb_gisb_arb_device_list, next) {\r\ncap_status = gisb_read(gdev, ARB_ERR_CAP_STATUS);\r\nif (!(cap_status & ARB_ERR_CAP_STATUS_VALID)) {\r\nis_fixup = 1;\r\ngoto out;\r\n}\r\nret |= brcmstb_gisb_arb_decode_addr(gdev, "bus error");\r\n}\r\nout:\r\nreturn is_fixup ? MIPS_BE_FIXUP : MIPS_BE_FATAL;\r\n}\r\nstatic irqreturn_t brcmstb_gisb_timeout_handler(int irq, void *dev_id)\r\n{\r\nbrcmstb_gisb_arb_decode_addr(dev_id, "timeout");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t brcmstb_gisb_tea_handler(int irq, void *dev_id)\r\n{\r\nbrcmstb_gisb_arb_decode_addr(dev_id, "target abort");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int dump_gisb_error(struct notifier_block *self, unsigned long v,\r\nvoid *p)\r\n{\r\nstruct brcmstb_gisb_arb_device *gdev;\r\nconst char *reason = "panic";\r\nif (self == &gisb_die_notifier)\r\nreason = "die";\r\nlist_for_each_entry(gdev, &brcmstb_gisb_arb_device_list, next)\r\nbrcmstb_gisb_arb_decode_addr(gdev, reason);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int __init brcmstb_gisb_arb_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *dn = pdev->dev.of_node;\r\nstruct brcmstb_gisb_arb_device *gdev;\r\nconst struct of_device_id *of_id;\r\nstruct resource *r;\r\nint err, timeout_irq, tea_irq;\r\nunsigned int num_masters, j = 0;\r\nint i, first, last;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ntimeout_irq = platform_get_irq(pdev, 0);\r\ntea_irq = platform_get_irq(pdev, 1);\r\ngdev = devm_kzalloc(&pdev->dev, sizeof(*gdev), GFP_KERNEL);\r\nif (!gdev)\r\nreturn -ENOMEM;\r\nmutex_init(&gdev->lock);\r\nINIT_LIST_HEAD(&gdev->next);\r\ngdev->base = devm_ioremap_resource(&pdev->dev, r);\r\nif (IS_ERR(gdev->base))\r\nreturn PTR_ERR(gdev->base);\r\nof_id = of_match_node(brcmstb_gisb_arb_of_match, dn);\r\nif (!of_id) {\r\npr_err("failed to look up compatible string\n");\r\nreturn -EINVAL;\r\n}\r\ngdev->gisb_offsets = of_id->data;\r\ngdev->big_endian = of_device_is_big_endian(dn);\r\nerr = devm_request_irq(&pdev->dev, timeout_irq,\r\nbrcmstb_gisb_timeout_handler, 0, pdev->name,\r\ngdev);\r\nif (err < 0)\r\nreturn err;\r\nerr = devm_request_irq(&pdev->dev, tea_irq,\r\nbrcmstb_gisb_tea_handler, 0, pdev->name,\r\ngdev);\r\nif (err < 0)\r\nreturn err;\r\nif (of_property_read_u32(dn, "brcm,gisb-arb-master-mask",\r\n&gdev->valid_mask))\r\ngdev->valid_mask = 0xffffffff;\r\nnum_masters = of_property_count_strings(dn,\r\n"brcm,gisb-arb-master-names");\r\nif (hweight_long(gdev->valid_mask) == num_masters) {\r\nfirst = ffs(gdev->valid_mask) - 1;\r\nlast = fls(gdev->valid_mask) - 1;\r\nfor (i = first; i < last; i++) {\r\nif (!(gdev->valid_mask & BIT(i)))\r\ncontinue;\r\nof_property_read_string_index(dn,\r\n"brcm,gisb-arb-master-names", j,\r\n&gdev->master_names[i]);\r\nj++;\r\n}\r\n}\r\nerr = sysfs_create_group(&pdev->dev.kobj, &gisb_arb_sysfs_attr_group);\r\nif (err)\r\nreturn err;\r\nplatform_set_drvdata(pdev, gdev);\r\nlist_add_tail(&gdev->next, &brcmstb_gisb_arb_device_list);\r\n#ifdef CONFIG_MIPS\r\nboard_be_handler = brcmstb_bus_error_handler;\r\n#endif\r\nif (list_is_singular(&brcmstb_gisb_arb_device_list)) {\r\nregister_die_notifier(&gisb_die_notifier);\r\natomic_notifier_chain_register(&panic_notifier_list,\r\n&gisb_panic_notifier);\r\n}\r\ndev_info(&pdev->dev, "registered mem: %p, irqs: %d, %d\n",\r\ngdev->base, timeout_irq, tea_irq);\r\nreturn 0;\r\n}\r\nstatic int brcmstb_gisb_arb_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct brcmstb_gisb_arb_device *gdev = platform_get_drvdata(pdev);\r\ngdev->saved_timeout = gisb_read(gdev, ARB_TIMER);\r\nreturn 0;\r\n}\r\nstatic int brcmstb_gisb_arb_resume_noirq(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct brcmstb_gisb_arb_device *gdev = platform_get_drvdata(pdev);\r\ngisb_write(gdev, gdev->saved_timeout, ARB_TIMER);\r\nreturn 0;\r\n}\r\nstatic int __init brcm_gisb_driver_init(void)\r\n{\r\nreturn platform_driver_probe(&brcmstb_gisb_arb_driver,\r\nbrcmstb_gisb_arb_probe);\r\n}
