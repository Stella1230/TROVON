static void rxrpc_conn_retransmit_call(struct rxrpc_connection *conn,\r\nstruct sk_buff *skb)\r\n{\r\nstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\r\nstruct rxrpc_channel *chan;\r\nstruct msghdr msg;\r\nstruct kvec iov;\r\nstruct {\r\nstruct rxrpc_wire_header whdr;\r\nunion {\r\nstruct {\r\n__be32 code;\r\n} abort;\r\nstruct {\r\nstruct rxrpc_ackpacket ack;\r\nu8 padding[3];\r\nstruct rxrpc_ackinfo info;\r\n};\r\n};\r\n} __attribute__((packed)) pkt;\r\nsize_t len;\r\nu32 serial, mtu, call_id;\r\n_enter("%d", conn->debug_id);\r\nchan = &conn->channels[sp->hdr.cid & RXRPC_CHANNELMASK];\r\ncall_id = READ_ONCE(chan->last_call);\r\nsmp_rmb();\r\nif (call_id != sp->hdr.callNumber)\r\nreturn;\r\nmsg.msg_name = &conn->params.peer->srx.transport;\r\nmsg.msg_namelen = conn->params.peer->srx.transport_len;\r\nmsg.msg_control = NULL;\r\nmsg.msg_controllen = 0;\r\nmsg.msg_flags = 0;\r\npkt.whdr.epoch = htonl(sp->hdr.epoch);\r\npkt.whdr.cid = htonl(sp->hdr.cid);\r\npkt.whdr.callNumber = htonl(sp->hdr.callNumber);\r\npkt.whdr.seq = 0;\r\npkt.whdr.type = chan->last_type;\r\npkt.whdr.flags = conn->out_clientflag;\r\npkt.whdr.userStatus = 0;\r\npkt.whdr.securityIndex = conn->security_ix;\r\npkt.whdr._rsvd = 0;\r\npkt.whdr.serviceId = htons(conn->service_id);\r\nlen = sizeof(pkt.whdr);\r\nswitch (chan->last_type) {\r\ncase RXRPC_PACKET_TYPE_ABORT:\r\npkt.abort.code = htonl(chan->last_abort);\r\nlen += sizeof(pkt.abort);\r\nbreak;\r\ncase RXRPC_PACKET_TYPE_ACK:\r\nmtu = conn->params.peer->if_mtu;\r\nmtu -= conn->params.peer->hdrsize;\r\npkt.ack.bufferSpace = 0;\r\npkt.ack.maxSkew = htons(skb->priority);\r\npkt.ack.firstPacket = htonl(chan->last_seq);\r\npkt.ack.previousPacket = htonl(chan->last_seq - 1);\r\npkt.ack.serial = htonl(sp->hdr.serial);\r\npkt.ack.reason = RXRPC_ACK_DUPLICATE;\r\npkt.ack.nAcks = 0;\r\npkt.info.rxMTU = htonl(rxrpc_rx_mtu);\r\npkt.info.maxMTU = htonl(mtu);\r\npkt.info.rwind = htonl(rxrpc_rx_window_size);\r\npkt.info.jumbo_max = htonl(rxrpc_rx_jumbo_max);\r\npkt.whdr.flags |= RXRPC_SLOW_START_OK;\r\nlen += sizeof(pkt.ack) + sizeof(pkt.info);\r\nbreak;\r\n}\r\nsmp_rmb();\r\nif (READ_ONCE(chan->last_call) != call_id)\r\nreturn;\r\niov.iov_base = &pkt;\r\niov.iov_len = len;\r\nserial = atomic_inc_return(&conn->serial);\r\npkt.whdr.serial = htonl(serial);\r\nswitch (chan->last_type) {\r\ncase RXRPC_PACKET_TYPE_ABORT:\r\n_proto("Tx ABORT %%%u { %d } [re]", serial, conn->local_abort);\r\nbreak;\r\ncase RXRPC_PACKET_TYPE_ACK:\r\ntrace_rxrpc_tx_ack(NULL, serial, chan->last_seq, 0,\r\nRXRPC_ACK_DUPLICATE, 0);\r\n_proto("Tx ACK %%%u [re]", serial);\r\nbreak;\r\n}\r\nkernel_sendmsg(conn->params.local->socket, &msg, &iov, 1, len);\r\n_leave("");\r\nreturn;\r\n}\r\nstatic void rxrpc_abort_calls(struct rxrpc_connection *conn,\r\nenum rxrpc_call_completion compl,\r\nu32 abort_code, int error)\r\n{\r\nstruct rxrpc_call *call;\r\nint i;\r\n_enter("{%d},%x", conn->debug_id, abort_code);\r\nspin_lock(&conn->channel_lock);\r\nfor (i = 0; i < RXRPC_MAXCALLS; i++) {\r\ncall = rcu_dereference_protected(\r\nconn->channels[i].call,\r\nlockdep_is_held(&conn->channel_lock));\r\nif (call) {\r\nif (compl == RXRPC_CALL_LOCALLY_ABORTED)\r\ntrace_rxrpc_abort("CON", call->cid,\r\ncall->call_id, 0,\r\nabort_code, error);\r\nif (rxrpc_set_call_completion(call, compl,\r\nabort_code, error))\r\nrxrpc_notify_socket(call);\r\n}\r\n}\r\nspin_unlock(&conn->channel_lock);\r\n_leave("");\r\n}\r\nstatic int rxrpc_abort_connection(struct rxrpc_connection *conn,\r\nint error, u32 abort_code)\r\n{\r\nstruct rxrpc_wire_header whdr;\r\nstruct msghdr msg;\r\nstruct kvec iov[2];\r\n__be32 word;\r\nsize_t len;\r\nu32 serial;\r\nint ret;\r\n_enter("%d,,%u,%u", conn->debug_id, error, abort_code);\r\nspin_lock_bh(&conn->state_lock);\r\nif (conn->state >= RXRPC_CONN_REMOTELY_ABORTED) {\r\nspin_unlock_bh(&conn->state_lock);\r\n_leave(" = 0 [already dead]");\r\nreturn 0;\r\n}\r\nconn->state = RXRPC_CONN_LOCALLY_ABORTED;\r\nspin_unlock_bh(&conn->state_lock);\r\nrxrpc_abort_calls(conn, RXRPC_CALL_LOCALLY_ABORTED, abort_code, error);\r\nmsg.msg_name = &conn->params.peer->srx.transport;\r\nmsg.msg_namelen = conn->params.peer->srx.transport_len;\r\nmsg.msg_control = NULL;\r\nmsg.msg_controllen = 0;\r\nmsg.msg_flags = 0;\r\nwhdr.epoch = htonl(conn->proto.epoch);\r\nwhdr.cid = htonl(conn->proto.cid);\r\nwhdr.callNumber = 0;\r\nwhdr.seq = 0;\r\nwhdr.type = RXRPC_PACKET_TYPE_ABORT;\r\nwhdr.flags = conn->out_clientflag;\r\nwhdr.userStatus = 0;\r\nwhdr.securityIndex = conn->security_ix;\r\nwhdr._rsvd = 0;\r\nwhdr.serviceId = htons(conn->service_id);\r\nword = htonl(conn->local_abort);\r\niov[0].iov_base = &whdr;\r\niov[0].iov_len = sizeof(whdr);\r\niov[1].iov_base = &word;\r\niov[1].iov_len = sizeof(word);\r\nlen = iov[0].iov_len + iov[1].iov_len;\r\nserial = atomic_inc_return(&conn->serial);\r\nwhdr.serial = htonl(serial);\r\n_proto("Tx CONN ABORT %%%u { %d }", serial, conn->local_abort);\r\nret = kernel_sendmsg(conn->params.local->socket, &msg, iov, 2, len);\r\nif (ret < 0) {\r\n_debug("sendmsg failed: %d", ret);\r\nreturn -EAGAIN;\r\n}\r\n_leave(" = 0");\r\nreturn 0;\r\n}\r\nstatic void rxrpc_call_is_secure(struct rxrpc_call *call)\r\n{\r\n_enter("%p", call);\r\nif (call) {\r\nwrite_lock_bh(&call->state_lock);\r\nif (call->state == RXRPC_CALL_SERVER_SECURING) {\r\ncall->state = RXRPC_CALL_SERVER_ACCEPTING;\r\nrxrpc_notify_socket(call);\r\n}\r\nwrite_unlock_bh(&call->state_lock);\r\n}\r\n}\r\nstatic int rxrpc_process_event(struct rxrpc_connection *conn,\r\nstruct sk_buff *skb,\r\nu32 *_abort_code)\r\n{\r\nstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\r\n__be32 wtmp;\r\nu32 abort_code;\r\nint loop, ret;\r\nif (conn->state >= RXRPC_CONN_REMOTELY_ABORTED) {\r\n_leave(" = -ECONNABORTED [%u]", conn->state);\r\nreturn -ECONNABORTED;\r\n}\r\n_enter("{%d},{%u,%%%u},", conn->debug_id, sp->hdr.type, sp->hdr.serial);\r\nswitch (sp->hdr.type) {\r\ncase RXRPC_PACKET_TYPE_DATA:\r\ncase RXRPC_PACKET_TYPE_ACK:\r\nrxrpc_conn_retransmit_call(conn, skb);\r\nreturn 0;\r\ncase RXRPC_PACKET_TYPE_BUSY:\r\nreturn 0;\r\ncase RXRPC_PACKET_TYPE_ABORT:\r\nif (skb_copy_bits(skb, sizeof(struct rxrpc_wire_header),\r\n&wtmp, sizeof(wtmp)) < 0) {\r\ntrace_rxrpc_rx_eproto(NULL, sp->hdr.serial,\r\ntracepoint_string("bad_abort"));\r\nreturn -EPROTO;\r\n}\r\nabort_code = ntohl(wtmp);\r\n_proto("Rx ABORT %%%u { ac=%d }", sp->hdr.serial, abort_code);\r\nconn->state = RXRPC_CONN_REMOTELY_ABORTED;\r\nrxrpc_abort_calls(conn, RXRPC_CALL_REMOTELY_ABORTED,\r\nabort_code, -ECONNABORTED);\r\nreturn -ECONNABORTED;\r\ncase RXRPC_PACKET_TYPE_CHALLENGE:\r\nreturn conn->security->respond_to_challenge(conn, skb,\r\n_abort_code);\r\ncase RXRPC_PACKET_TYPE_RESPONSE:\r\nret = conn->security->verify_response(conn, skb, _abort_code);\r\nif (ret < 0)\r\nreturn ret;\r\nret = conn->security->init_connection_security(conn);\r\nif (ret < 0)\r\nreturn ret;\r\nret = conn->security->prime_packet_security(conn);\r\nif (ret < 0)\r\nreturn ret;\r\nspin_lock(&conn->channel_lock);\r\nspin_lock(&conn->state_lock);\r\nif (conn->state == RXRPC_CONN_SERVICE_CHALLENGING) {\r\nconn->state = RXRPC_CONN_SERVICE;\r\nspin_unlock(&conn->state_lock);\r\nfor (loop = 0; loop < RXRPC_MAXCALLS; loop++)\r\nrxrpc_call_is_secure(\r\nrcu_dereference_protected(\r\nconn->channels[loop].call,\r\nlockdep_is_held(&conn->channel_lock)));\r\n} else {\r\nspin_unlock(&conn->state_lock);\r\n}\r\nspin_unlock(&conn->channel_lock);\r\nreturn 0;\r\ndefault:\r\ntrace_rxrpc_rx_eproto(NULL, sp->hdr.serial,\r\ntracepoint_string("bad_conn_pkt"));\r\nreturn -EPROTO;\r\n}\r\n}\r\nstatic void rxrpc_secure_connection(struct rxrpc_connection *conn)\r\n{\r\nu32 abort_code;\r\nint ret;\r\n_enter("{%d}", conn->debug_id);\r\nASSERT(conn->security_ix != 0);\r\nif (!conn->params.key) {\r\n_debug("set up security");\r\nret = rxrpc_init_server_conn_security(conn);\r\nswitch (ret) {\r\ncase 0:\r\nbreak;\r\ncase -ENOENT:\r\nabort_code = RX_CALL_DEAD;\r\ngoto abort;\r\ndefault:\r\nabort_code = RXKADNOAUTH;\r\ngoto abort;\r\n}\r\n}\r\nif (conn->security->issue_challenge(conn) < 0) {\r\nabort_code = RX_CALL_DEAD;\r\nret = -ENOMEM;\r\ngoto abort;\r\n}\r\n_leave("");\r\nreturn;\r\nabort:\r\n_debug("abort %d, %d", ret, abort_code);\r\nrxrpc_abort_connection(conn, ret, abort_code);\r\n_leave(" [aborted]");\r\n}\r\nvoid rxrpc_process_connection(struct work_struct *work)\r\n{\r\nstruct rxrpc_connection *conn =\r\ncontainer_of(work, struct rxrpc_connection, processor);\r\nstruct sk_buff *skb;\r\nu32 abort_code = RX_PROTOCOL_ERROR;\r\nint ret;\r\nrxrpc_see_connection(conn);\r\nif (test_and_clear_bit(RXRPC_CONN_EV_CHALLENGE, &conn->events))\r\nrxrpc_secure_connection(conn);\r\nwhile ((skb = skb_dequeue(&conn->rx_queue))) {\r\nrxrpc_see_skb(skb, rxrpc_skb_rx_seen);\r\nret = rxrpc_process_event(conn, skb, &abort_code);\r\nswitch (ret) {\r\ncase -EPROTO:\r\ncase -EKEYEXPIRED:\r\ncase -EKEYREJECTED:\r\ngoto protocol_error;\r\ncase -EAGAIN:\r\ngoto requeue_and_leave;\r\ncase -ECONNABORTED:\r\ndefault:\r\nrxrpc_free_skb(skb, rxrpc_skb_rx_freed);\r\nbreak;\r\n}\r\n}\r\nout:\r\nrxrpc_put_connection(conn);\r\n_leave("");\r\nreturn;\r\nrequeue_and_leave:\r\nskb_queue_head(&conn->rx_queue, skb);\r\ngoto out;\r\nprotocol_error:\r\nif (rxrpc_abort_connection(conn, ret, abort_code) < 0)\r\ngoto requeue_and_leave;\r\nrxrpc_free_skb(skb, rxrpc_skb_rx_freed);\r\ngoto out;\r\n}
