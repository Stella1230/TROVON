static int gb_control_get_version(struct gb_control *control)\r\n{\r\nstruct gb_interface *intf = control->connection->intf;\r\nstruct gb_control_version_request request;\r\nstruct gb_control_version_response response;\r\nint ret;\r\nrequest.major = GB_CONTROL_VERSION_MAJOR;\r\nrequest.minor = GB_CONTROL_VERSION_MINOR;\r\nret = gb_operation_sync(control->connection,\r\nGB_CONTROL_TYPE_VERSION,\r\n&request, sizeof(request), &response,\r\nsizeof(response));\r\nif (ret) {\r\ndev_err(&intf->dev,\r\n"failed to get control-protocol version: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nif (response.major > request.major) {\r\ndev_err(&intf->dev,\r\n"unsupported major control-protocol version (%u > %u)\n",\r\nresponse.major, request.major);\r\nreturn -ENOTSUPP;\r\n}\r\ncontrol->protocol_major = response.major;\r\ncontrol->protocol_minor = response.minor;\r\ndev_dbg(&intf->dev, "%s - %u.%u\n", __func__, response.major,\r\nresponse.minor);\r\nreturn 0;\r\n}\r\nstatic int gb_control_get_bundle_version(struct gb_control *control,\r\nstruct gb_bundle *bundle)\r\n{\r\nstruct gb_interface *intf = control->connection->intf;\r\nstruct gb_control_bundle_version_request request;\r\nstruct gb_control_bundle_version_response response;\r\nint ret;\r\nrequest.bundle_id = bundle->id;\r\nret = gb_operation_sync(control->connection,\r\nGB_CONTROL_TYPE_BUNDLE_VERSION,\r\n&request, sizeof(request),\r\n&response, sizeof(response));\r\nif (ret) {\r\ndev_err(&intf->dev,\r\n"failed to get bundle %u class version: %d\n",\r\nbundle->id, ret);\r\nreturn ret;\r\n}\r\nbundle->class_major = response.major;\r\nbundle->class_minor = response.minor;\r\ndev_dbg(&intf->dev, "%s - %u: %u.%u\n", __func__, bundle->id,\r\nresponse.major, response.minor);\r\nreturn 0;\r\n}\r\nint gb_control_get_bundle_versions(struct gb_control *control)\r\n{\r\nstruct gb_interface *intf = control->connection->intf;\r\nstruct gb_bundle *bundle;\r\nint ret;\r\nif (!control->has_bundle_version)\r\nreturn 0;\r\nlist_for_each_entry(bundle, &intf->bundles, links) {\r\nret = gb_control_get_bundle_version(control, bundle);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint gb_control_get_manifest_size_operation(struct gb_interface *intf)\r\n{\r\nstruct gb_control_get_manifest_size_response response;\r\nstruct gb_connection *connection = intf->control->connection;\r\nint ret;\r\nret = gb_operation_sync(connection, GB_CONTROL_TYPE_GET_MANIFEST_SIZE,\r\nNULL, 0, &response, sizeof(response));\r\nif (ret) {\r\ndev_err(&connection->intf->dev,\r\n"failed to get manifest size: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn le16_to_cpu(response.size);\r\n}\r\nint gb_control_get_manifest_operation(struct gb_interface *intf, void *manifest,\r\nsize_t size)\r\n{\r\nstruct gb_connection *connection = intf->control->connection;\r\nreturn gb_operation_sync(connection, GB_CONTROL_TYPE_GET_MANIFEST,\r\nNULL, 0, manifest, size);\r\n}\r\nint gb_control_connected_operation(struct gb_control *control, u16 cport_id)\r\n{\r\nstruct gb_control_connected_request request;\r\nrequest.cport_id = cpu_to_le16(cport_id);\r\nreturn gb_operation_sync(control->connection, GB_CONTROL_TYPE_CONNECTED,\r\n&request, sizeof(request), NULL, 0);\r\n}\r\nint gb_control_disconnected_operation(struct gb_control *control, u16 cport_id)\r\n{\r\nstruct gb_control_disconnected_request request;\r\nrequest.cport_id = cpu_to_le16(cport_id);\r\nreturn gb_operation_sync(control->connection,\r\nGB_CONTROL_TYPE_DISCONNECTED, &request,\r\nsizeof(request), NULL, 0);\r\n}\r\nint gb_control_disconnecting_operation(struct gb_control *control,\r\nu16 cport_id)\r\n{\r\nstruct gb_control_disconnecting_request *request;\r\nstruct gb_operation *operation;\r\nint ret;\r\noperation = gb_operation_create_core(control->connection,\r\nGB_CONTROL_TYPE_DISCONNECTING,\r\nsizeof(*request), 0, 0,\r\nGFP_KERNEL);\r\nif (!operation)\r\nreturn -ENOMEM;\r\nrequest = operation->request->payload;\r\nrequest->cport_id = cpu_to_le16(cport_id);\r\nret = gb_operation_request_send_sync(operation);\r\nif (ret) {\r\ndev_err(&control->dev, "failed to send disconnecting: %d\n",\r\nret);\r\n}\r\ngb_operation_put(operation);\r\nreturn ret;\r\n}\r\nint gb_control_mode_switch_operation(struct gb_control *control)\r\n{\r\nstruct gb_operation *operation;\r\nint ret;\r\noperation = gb_operation_create_core(control->connection,\r\nGB_CONTROL_TYPE_MODE_SWITCH,\r\n0, 0, GB_OPERATION_FLAG_UNIDIRECTIONAL,\r\nGFP_KERNEL);\r\nif (!operation)\r\nreturn -ENOMEM;\r\nret = gb_operation_request_send_sync(operation);\r\nif (ret)\r\ndev_err(&control->dev, "failed to send mode switch: %d\n", ret);\r\ngb_operation_put(operation);\r\nreturn ret;\r\n}\r\nstatic int gb_control_bundle_pm_status_map(u8 status)\r\n{\r\nswitch (status) {\r\ncase GB_CONTROL_BUNDLE_PM_INVAL:\r\nreturn -EINVAL;\r\ncase GB_CONTROL_BUNDLE_PM_BUSY:\r\nreturn -EBUSY;\r\ncase GB_CONTROL_BUNDLE_PM_NA:\r\nreturn -ENOMSG;\r\ncase GB_CONTROL_BUNDLE_PM_FAIL:\r\ndefault:\r\nreturn -EREMOTEIO;\r\n}\r\n}\r\nint gb_control_bundle_suspend(struct gb_control *control, u8 bundle_id)\r\n{\r\nstruct gb_control_bundle_pm_request request;\r\nstruct gb_control_bundle_pm_response response;\r\nint ret;\r\nrequest.bundle_id = bundle_id;\r\nret = gb_operation_sync(control->connection,\r\nGB_CONTROL_TYPE_BUNDLE_SUSPEND, &request,\r\nsizeof(request), &response, sizeof(response));\r\nif (ret) {\r\ndev_err(&control->dev, "failed to send bundle %u suspend: %d\n",\r\nbundle_id, ret);\r\nreturn ret;\r\n}\r\nif (response.status != GB_CONTROL_BUNDLE_PM_OK) {\r\ndev_err(&control->dev, "failed to suspend bundle %u: %d\n",\r\nbundle_id, response.status);\r\nreturn gb_control_bundle_pm_status_map(response.status);\r\n}\r\nreturn 0;\r\n}\r\nint gb_control_bundle_resume(struct gb_control *control, u8 bundle_id)\r\n{\r\nstruct gb_control_bundle_pm_request request;\r\nstruct gb_control_bundle_pm_response response;\r\nint ret;\r\nrequest.bundle_id = bundle_id;\r\nret = gb_operation_sync(control->connection,\r\nGB_CONTROL_TYPE_BUNDLE_RESUME, &request,\r\nsizeof(request), &response, sizeof(response));\r\nif (ret) {\r\ndev_err(&control->dev, "failed to send bundle %u resume: %d\n",\r\nbundle_id, ret);\r\nreturn ret;\r\n}\r\nif (response.status != GB_CONTROL_BUNDLE_PM_OK) {\r\ndev_err(&control->dev, "failed to resume bundle %u: %d\n",\r\nbundle_id, response.status);\r\nreturn gb_control_bundle_pm_status_map(response.status);\r\n}\r\nreturn 0;\r\n}\r\nint gb_control_bundle_deactivate(struct gb_control *control, u8 bundle_id)\r\n{\r\nstruct gb_control_bundle_pm_request request;\r\nstruct gb_control_bundle_pm_response response;\r\nint ret;\r\nrequest.bundle_id = bundle_id;\r\nret = gb_operation_sync(control->connection,\r\nGB_CONTROL_TYPE_BUNDLE_DEACTIVATE, &request,\r\nsizeof(request), &response, sizeof(response));\r\nif (ret) {\r\ndev_err(&control->dev,\r\n"failed to send bundle %u deactivate: %d\n", bundle_id,\r\nret);\r\nreturn ret;\r\n}\r\nif (response.status != GB_CONTROL_BUNDLE_PM_OK) {\r\ndev_err(&control->dev, "failed to deactivate bundle %u: %d\n",\r\nbundle_id, response.status);\r\nreturn gb_control_bundle_pm_status_map(response.status);\r\n}\r\nreturn 0;\r\n}\r\nint gb_control_bundle_activate(struct gb_control *control, u8 bundle_id)\r\n{\r\nstruct gb_control_bundle_pm_request request;\r\nstruct gb_control_bundle_pm_response response;\r\nint ret;\r\nif (!control->has_bundle_activate)\r\nreturn 0;\r\nrequest.bundle_id = bundle_id;\r\nret = gb_operation_sync(control->connection,\r\nGB_CONTROL_TYPE_BUNDLE_ACTIVATE, &request,\r\nsizeof(request), &response, sizeof(response));\r\nif (ret) {\r\ndev_err(&control->dev,\r\n"failed to send bundle %u activate: %d\n", bundle_id,\r\nret);\r\nreturn ret;\r\n}\r\nif (response.status != GB_CONTROL_BUNDLE_PM_OK) {\r\ndev_err(&control->dev, "failed to activate bundle %u: %d\n",\r\nbundle_id, response.status);\r\nreturn gb_control_bundle_pm_status_map(response.status);\r\n}\r\nreturn 0;\r\n}\r\nstatic int gb_control_interface_pm_status_map(u8 status)\r\n{\r\nswitch (status) {\r\ncase GB_CONTROL_INTF_PM_BUSY:\r\nreturn -EBUSY;\r\ncase GB_CONTROL_INTF_PM_NA:\r\nreturn -ENOMSG;\r\ndefault:\r\nreturn -EREMOTEIO;\r\n}\r\n}\r\nint gb_control_interface_suspend_prepare(struct gb_control *control)\r\n{\r\nstruct gb_control_intf_pm_response response;\r\nint ret;\r\nret = gb_operation_sync(control->connection,\r\nGB_CONTROL_TYPE_INTF_SUSPEND_PREPARE, NULL, 0,\r\n&response, sizeof(response));\r\nif (ret) {\r\ndev_err(&control->dev,\r\n"failed to send interface suspend prepare: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (response.status != GB_CONTROL_INTF_PM_OK) {\r\ndev_err(&control->dev, "interface error while preparing suspend: %d\n",\r\nresponse.status);\r\nreturn gb_control_interface_pm_status_map(response.status);\r\n}\r\nreturn 0;\r\n}\r\nint gb_control_interface_deactivate_prepare(struct gb_control *control)\r\n{\r\nstruct gb_control_intf_pm_response response;\r\nint ret;\r\nret = gb_operation_sync(control->connection,\r\nGB_CONTROL_TYPE_INTF_DEACTIVATE_PREPARE, NULL,\r\n0, &response, sizeof(response));\r\nif (ret) {\r\ndev_err(&control->dev, "failed to send interface deactivate prepare: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nif (response.status != GB_CONTROL_INTF_PM_OK) {\r\ndev_err(&control->dev, "interface error while preparing deactivate: %d\n",\r\nresponse.status);\r\nreturn gb_control_interface_pm_status_map(response.status);\r\n}\r\nreturn 0;\r\n}\r\nint gb_control_interface_hibernate_abort(struct gb_control *control)\r\n{\r\nstruct gb_control_intf_pm_response response;\r\nint ret;\r\nret = gb_operation_sync(control->connection,\r\nGB_CONTROL_TYPE_INTF_HIBERNATE_ABORT, NULL, 0,\r\n&response, sizeof(response));\r\nif (ret) {\r\ndev_err(&control->dev,\r\n"failed to send interface aborting hibernate: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nif (response.status != GB_CONTROL_INTF_PM_OK) {\r\ndev_err(&control->dev, "interface error while aborting hibernate: %d\n",\r\nresponse.status);\r\nreturn gb_control_interface_pm_status_map(response.status);\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t vendor_string_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct gb_control *control = to_gb_control(dev);\r\nreturn scnprintf(buf, PAGE_SIZE, "%s\n", control->vendor_string);\r\n}\r\nstatic ssize_t product_string_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct gb_control *control = to_gb_control(dev);\r\nreturn scnprintf(buf, PAGE_SIZE, "%s\n", control->product_string);\r\n}\r\nstatic void gb_control_release(struct device *dev)\r\n{\r\nstruct gb_control *control = to_gb_control(dev);\r\ngb_connection_destroy(control->connection);\r\nkfree(control->vendor_string);\r\nkfree(control->product_string);\r\nkfree(control);\r\n}\r\nstruct gb_control *gb_control_create(struct gb_interface *intf)\r\n{\r\nstruct gb_connection *connection;\r\nstruct gb_control *control;\r\ncontrol = kzalloc(sizeof(*control), GFP_KERNEL);\r\nif (!control)\r\nreturn ERR_PTR(-ENOMEM);\r\ncontrol->intf = intf;\r\nconnection = gb_connection_create_control(intf);\r\nif (IS_ERR(connection)) {\r\ndev_err(&intf->dev,\r\n"failed to create control connection: %ld\n",\r\nPTR_ERR(connection));\r\nkfree(control);\r\nreturn ERR_CAST(connection);\r\n}\r\ncontrol->connection = connection;\r\ncontrol->dev.parent = &intf->dev;\r\ncontrol->dev.bus = &greybus_bus_type;\r\ncontrol->dev.type = &greybus_control_type;\r\ncontrol->dev.groups = control_groups;\r\ncontrol->dev.dma_mask = intf->dev.dma_mask;\r\ndevice_initialize(&control->dev);\r\ndev_set_name(&control->dev, "%s.ctrl", dev_name(&intf->dev));\r\ngb_connection_set_data(control->connection, control);\r\nreturn control;\r\n}\r\nint gb_control_enable(struct gb_control *control)\r\n{\r\nint ret;\r\ndev_dbg(&control->connection->intf->dev, "%s\n", __func__);\r\nret = gb_connection_enable_tx(control->connection);\r\nif (ret) {\r\ndev_err(&control->connection->intf->dev,\r\n"failed to enable control connection: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nret = gb_control_get_version(control);\r\nif (ret)\r\ngoto err_disable_connection;\r\nif (control->protocol_major > 0 || control->protocol_minor > 1)\r\ncontrol->has_bundle_version = true;\r\nif (!(control->intf->quirks & GB_INTERFACE_QUIRK_NO_BUNDLE_ACTIVATE))\r\ncontrol->has_bundle_activate = true;\r\nreturn 0;\r\nerr_disable_connection:\r\ngb_connection_disable(control->connection);\r\nreturn ret;\r\n}\r\nvoid gb_control_disable(struct gb_control *control)\r\n{\r\ndev_dbg(&control->connection->intf->dev, "%s\n", __func__);\r\nif (control->intf->disconnected)\r\ngb_connection_disable_forced(control->connection);\r\nelse\r\ngb_connection_disable(control->connection);\r\n}\r\nint gb_control_suspend(struct gb_control *control)\r\n{\r\ngb_connection_disable(control->connection);\r\nreturn 0;\r\n}\r\nint gb_control_resume(struct gb_control *control)\r\n{\r\nint ret;\r\nret = gb_connection_enable_tx(control->connection);\r\nif (ret) {\r\ndev_err(&control->connection->intf->dev,\r\n"failed to enable control connection: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint gb_control_add(struct gb_control *control)\r\n{\r\nint ret;\r\nret = device_add(&control->dev);\r\nif (ret) {\r\ndev_err(&control->dev,\r\n"failed to register control device: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nvoid gb_control_del(struct gb_control *control)\r\n{\r\nif (device_is_registered(&control->dev))\r\ndevice_del(&control->dev);\r\n}\r\nstruct gb_control *gb_control_get(struct gb_control *control)\r\n{\r\nget_device(&control->dev);\r\nreturn control;\r\n}\r\nvoid gb_control_put(struct gb_control *control)\r\n{\r\nput_device(&control->dev);\r\n}\r\nvoid gb_control_mode_switch_prepare(struct gb_control *control)\r\n{\r\ngb_connection_mode_switch_prepare(control->connection);\r\n}\r\nvoid gb_control_mode_switch_complete(struct gb_control *control)\r\n{\r\ngb_connection_mode_switch_complete(control->connection);\r\n}
