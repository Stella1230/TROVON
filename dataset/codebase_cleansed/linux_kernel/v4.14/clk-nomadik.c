static int nomadik_clk_reboot_handler(struct notifier_block *this,\r\nunsigned long code,\r\nvoid *unused)\r\n{\r\nu32 val;\r\nval = readl(src_base + SRC_XTALCR);\r\nval &= ~SRC_XTALCR_MXTALOVER;\r\nval |= SRC_XTALCR_MXTALEN;\r\npr_crit("force-enabling MXTALO\n");\r\nwritel(val, src_base + SRC_XTALCR);\r\nreturn NOTIFY_OK;\r\n}\r\nstatic void __init nomadik_src_init(void)\r\n{\r\nstruct device_node *np;\r\nu32 val;\r\nnp = of_find_matching_node(NULL, nomadik_src_match);\r\nif (!np) {\r\npr_crit("no matching node for SRC, aborting clock init\n");\r\nreturn;\r\n}\r\nsrc_base = of_iomap(np, 0);\r\nif (!src_base) {\r\npr_err("%s: must have src parent node with REGS (%s)\n",\r\n__func__, np->name);\r\nreturn;\r\n}\r\nval = readl(src_base + SRC_CR);\r\nval |= SRC_CR_T0_ENSEL;\r\nval |= SRC_CR_T1_ENSEL;\r\nval |= SRC_CR_T2_ENSEL;\r\nval |= SRC_CR_T3_ENSEL;\r\nval |= SRC_CR_T4_ENSEL;\r\nval |= SRC_CR_T5_ENSEL;\r\nval |= SRC_CR_T6_ENSEL;\r\nval |= SRC_CR_T7_ENSEL;\r\nwritel(val, src_base + SRC_CR);\r\nval = readl(src_base + SRC_XTALCR);\r\npr_info("SXTALO is %s\n",\r\n(val & SRC_XTALCR_SXTALDIS) ? "disabled" : "enabled");\r\npr_info("MXTAL is %s\n",\r\n(val & SRC_XTALCR_MXTALSTAT) ? "enabled" : "disabled");\r\nif (of_property_read_bool(np, "disable-sxtalo")) {\r\nval |= SRC_XTALCR_SXTALDIS;\r\npr_info("disabling SXTALO\n");\r\n}\r\nif (of_property_read_bool(np, "disable-mxtalo")) {\r\nval |= SRC_XTALCR_MXTALOVER;\r\nval &= ~SRC_XTALCR_MXTALEN;\r\npr_info("disabling MXTALO\n");\r\n}\r\nwritel(val, src_base + SRC_XTALCR);\r\nregister_reboot_notifier(&nomadik_clk_reboot_notifier);\r\n}\r\nstatic int pll_clk_enable(struct clk_hw *hw)\r\n{\r\nstruct clk_pll *pll = to_pll(hw);\r\nu32 val;\r\nspin_lock(&src_lock);\r\nval = readl(src_base + SRC_PLLCR);\r\nif (pll->id == 1) {\r\nif (val & SRC_PLLCR_PLL1OVER) {\r\nval |= SRC_PLLCR_PLL1EN;\r\nwritel(val, src_base + SRC_PLLCR);\r\n}\r\n} else if (pll->id == 2) {\r\nval |= SRC_PLLCR_PLL2EN;\r\nwritel(val, src_base + SRC_PLLCR);\r\n}\r\nspin_unlock(&src_lock);\r\nreturn 0;\r\n}\r\nstatic void pll_clk_disable(struct clk_hw *hw)\r\n{\r\nstruct clk_pll *pll = to_pll(hw);\r\nu32 val;\r\nspin_lock(&src_lock);\r\nval = readl(src_base + SRC_PLLCR);\r\nif (pll->id == 1) {\r\nif (val & SRC_PLLCR_PLL1OVER) {\r\nval &= ~SRC_PLLCR_PLL1EN;\r\nwritel(val, src_base + SRC_PLLCR);\r\n}\r\n} else if (pll->id == 2) {\r\nval &= ~SRC_PLLCR_PLL2EN;\r\nwritel(val, src_base + SRC_PLLCR);\r\n}\r\nspin_unlock(&src_lock);\r\n}\r\nstatic int pll_clk_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct clk_pll *pll = to_pll(hw);\r\nu32 val;\r\nval = readl(src_base + SRC_PLLCR);\r\nif (pll->id == 1) {\r\nif (val & SRC_PLLCR_PLL1OVER)\r\nreturn !!(val & SRC_PLLCR_PLL1EN);\r\n} else if (pll->id == 2) {\r\nreturn !!(val & SRC_PLLCR_PLL2EN);\r\n}\r\nreturn 1;\r\n}\r\nstatic unsigned long pll_clk_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_pll *pll = to_pll(hw);\r\nu32 val;\r\nval = readl(src_base + SRC_PLLFR);\r\nif (pll->id == 1) {\r\nu8 mul;\r\nu8 div;\r\nmul = (val >> 8) & 0x3FU;\r\nmul += 2;\r\ndiv = val & 0x07U;\r\nreturn (parent_rate * mul) >> div;\r\n}\r\nif (pll->id == 2) {\r\nu8 mul;\r\nmul = (val >> 24) & 0x3FU;\r\nmul += 2;\r\nreturn (parent_rate * mul);\r\n}\r\nreturn 0;\r\n}\r\nstatic struct clk_hw * __init\r\npll_clk_register(struct device *dev, const char *name,\r\nconst char *parent_name, u32 id)\r\n{\r\nint ret;\r\nstruct clk_pll *pll;\r\nstruct clk_init_data init;\r\nif (id != 1 && id != 2) {\r\npr_err("%s: the Nomadik has only PLL 1 & 2\n", __func__);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\npll = kzalloc(sizeof(*pll), GFP_KERNEL);\r\nif (!pll)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = name;\r\ninit.ops = &pll_clk_ops;\r\ninit.parent_names = (parent_name ? &parent_name : NULL);\r\ninit.num_parents = (parent_name ? 1 : 0);\r\npll->hw.init = &init;\r\npll->id = id;\r\npr_debug("register PLL1 clock \"%s\"\n", name);\r\nret = clk_hw_register(dev, &pll->hw);\r\nif (ret) {\r\nkfree(pll);\r\nreturn ERR_PTR(ret);\r\n}\r\nreturn &pll->hw;\r\n}\r\nstatic int src_clk_enable(struct clk_hw *hw)\r\n{\r\nstruct clk_src *sclk = to_src(hw);\r\nu32 enreg = sclk->group1 ? SRC_PCKEN1 : SRC_PCKEN0;\r\nu32 sreg = sclk->group1 ? SRC_PCKSR1 : SRC_PCKSR0;\r\nwritel(sclk->clkbit, src_base + enreg);\r\nwhile (!(readl(src_base + sreg) & sclk->clkbit))\r\ncpu_relax();\r\nreturn 0;\r\n}\r\nstatic void src_clk_disable(struct clk_hw *hw)\r\n{\r\nstruct clk_src *sclk = to_src(hw);\r\nu32 disreg = sclk->group1 ? SRC_PCKDIS1 : SRC_PCKDIS0;\r\nu32 sreg = sclk->group1 ? SRC_PCKSR1 : SRC_PCKSR0;\r\nwritel(sclk->clkbit, src_base + disreg);\r\nwhile (readl(src_base + sreg) & sclk->clkbit)\r\ncpu_relax();\r\n}\r\nstatic int src_clk_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct clk_src *sclk = to_src(hw);\r\nu32 sreg = sclk->group1 ? SRC_PCKSR1 : SRC_PCKSR0;\r\nu32 val = readl(src_base + sreg);\r\nreturn !!(val & sclk->clkbit);\r\n}\r\nstatic unsigned long\r\nsrc_clk_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nreturn parent_rate;\r\n}\r\nstatic struct clk_hw * __init\r\nsrc_clk_register(struct device *dev, const char *name,\r\nconst char *parent_name, u8 id)\r\n{\r\nint ret;\r\nstruct clk_src *sclk;\r\nstruct clk_init_data init;\r\nsclk = kzalloc(sizeof(*sclk), GFP_KERNEL);\r\nif (!sclk)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = name;\r\ninit.ops = &src_clk_ops;\r\nif (id == 2)\r\ninit.flags = CLK_IGNORE_UNUSED;\r\nelse\r\ninit.flags = 0;\r\ninit.parent_names = (parent_name ? &parent_name : NULL);\r\ninit.num_parents = (parent_name ? 1 : 0);\r\nsclk->hw.init = &init;\r\nsclk->id = id;\r\nsclk->group1 = (id > 31);\r\nsclk->clkbit = BIT(id & 0x1f);\r\npr_debug("register clock \"%s\" ID: %d group: %d bits: %08x\n",\r\nname, id, sclk->group1, sclk->clkbit);\r\nret = clk_hw_register(dev, &sclk->hw);\r\nif (ret) {\r\nkfree(sclk);\r\nreturn ERR_PTR(ret);\r\n}\r\nreturn &sclk->hw;\r\n}\r\nstatic int nomadik_src_clk_show(struct seq_file *s, void *what)\r\n{\r\nint i;\r\nu32 src_pcksr0 = readl(src_base + SRC_PCKSR0);\r\nu32 src_pcksr1 = readl(src_base + SRC_PCKSR1);\r\nu32 src_pckensr0 = readl(src_base + SRC_PCKENSR0);\r\nu32 src_pckensr1 = readl(src_base + SRC_PCKENSR1);\r\nseq_puts(s, "Clock: Boot: Now: Request: ASKED:\n");\r\nfor (i = 0; i < ARRAY_SIZE(src_clk_names); i++) {\r\nu32 pcksrb = (i < 0x20) ? src_pcksr0_boot : src_pcksr1_boot;\r\nu32 pcksr = (i < 0x20) ? src_pcksr0 : src_pcksr1;\r\nu32 pckreq = (i < 0x20) ? src_pckensr0 : src_pckensr1;\r\nu32 mask = BIT(i & 0x1f);\r\nseq_printf(s, "%s %s %s %s\n",\r\nsrc_clk_names[i],\r\n(pcksrb & mask) ? "on " : "off",\r\n(pcksr & mask) ? "on " : "off",\r\n(pckreq & mask) ? "on " : "off");\r\n}\r\nreturn 0;\r\n}\r\nstatic int nomadik_src_clk_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, nomadik_src_clk_show, NULL);\r\n}\r\nstatic int __init nomadik_src_clk_init_debugfs(void)\r\n{\r\nif (!src_base)\r\nreturn -ENODEV;\r\nsrc_pcksr0_boot = readl(src_base + SRC_PCKSR0);\r\nsrc_pcksr1_boot = readl(src_base + SRC_PCKSR1);\r\ndebugfs_create_file("nomadik-src-clk", S_IFREG | S_IRUGO,\r\nNULL, NULL, &nomadik_src_clk_debugfs_ops);\r\nreturn 0;\r\n}\r\nstatic void __init of_nomadik_pll_setup(struct device_node *np)\r\n{\r\nstruct clk_hw *hw;\r\nconst char *clk_name = np->name;\r\nconst char *parent_name;\r\nu32 pll_id;\r\nif (!src_base)\r\nnomadik_src_init();\r\nif (of_property_read_u32(np, "pll-id", &pll_id)) {\r\npr_err("%s: PLL \"%s\" missing pll-id property\n",\r\n__func__, clk_name);\r\nreturn;\r\n}\r\nparent_name = of_clk_get_parent_name(np, 0);\r\nhw = pll_clk_register(NULL, clk_name, parent_name, pll_id);\r\nif (!IS_ERR(hw))\r\nof_clk_add_hw_provider(np, of_clk_hw_simple_get, hw);\r\n}\r\nstatic void __init of_nomadik_hclk_setup(struct device_node *np)\r\n{\r\nstruct clk_hw *hw;\r\nconst char *clk_name = np->name;\r\nconst char *parent_name;\r\nif (!src_base)\r\nnomadik_src_init();\r\nparent_name = of_clk_get_parent_name(np, 0);\r\nhw = clk_hw_register_divider(NULL, clk_name, parent_name,\r\n0, src_base + SRC_CR,\r\n13, 2,\r\nCLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ALLOW_ZERO,\r\n&src_lock);\r\nif (!IS_ERR(hw))\r\nof_clk_add_hw_provider(np, of_clk_hw_simple_get, hw);\r\n}\r\nstatic void __init of_nomadik_src_clk_setup(struct device_node *np)\r\n{\r\nstruct clk_hw *hw;\r\nconst char *clk_name = np->name;\r\nconst char *parent_name;\r\nu32 clk_id;\r\nif (!src_base)\r\nnomadik_src_init();\r\nif (of_property_read_u32(np, "clock-id", &clk_id)) {\r\npr_err("%s: SRC clock \"%s\" missing clock-id property\n",\r\n__func__, clk_name);\r\nreturn;\r\n}\r\nparent_name = of_clk_get_parent_name(np, 0);\r\nhw = src_clk_register(NULL, clk_name, parent_name, clk_id);\r\nif (!IS_ERR(hw))\r\nof_clk_add_hw_provider(np, of_clk_hw_simple_get, hw);\r\n}
