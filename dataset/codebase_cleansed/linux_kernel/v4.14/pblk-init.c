static int pblk_rw_io(struct request_queue *q, struct pblk *pblk,\r\nstruct bio *bio)\r\n{\r\nint ret;\r\nif (bio_data_dir(bio) == READ) {\r\nblk_queue_split(q, &bio);\r\nret = pblk_submit_read(pblk, bio);\r\nif (ret == NVM_IO_DONE && bio_flagged(bio, BIO_CLONED))\r\nbio_put(bio);\r\nreturn ret;\r\n}\r\nif (unlikely(pblk_get_secs(bio) >= pblk_rl_sysfs_rate_show(&pblk->rl)))\r\nblk_queue_split(q, &bio);\r\nreturn pblk_write_to_cache(pblk, bio, PBLK_IOTYPE_USER);\r\n}\r\nstatic blk_qc_t pblk_make_rq(struct request_queue *q, struct bio *bio)\r\n{\r\nstruct pblk *pblk = q->queuedata;\r\nif (bio_op(bio) == REQ_OP_DISCARD) {\r\npblk_discard(pblk, bio);\r\nif (!(bio->bi_opf & REQ_PREFLUSH)) {\r\nbio_endio(bio);\r\nreturn BLK_QC_T_NONE;\r\n}\r\n}\r\nswitch (pblk_rw_io(q, pblk, bio)) {\r\ncase NVM_IO_ERR:\r\nbio_io_error(bio);\r\nbreak;\r\ncase NVM_IO_DONE:\r\nbio_endio(bio);\r\nbreak;\r\n}\r\nreturn BLK_QC_T_NONE;\r\n}\r\nstatic void pblk_l2p_free(struct pblk *pblk)\r\n{\r\nvfree(pblk->trans_map);\r\n}\r\nstatic int pblk_l2p_init(struct pblk *pblk)\r\n{\r\nsector_t i;\r\nstruct ppa_addr ppa;\r\nint entry_size = 8;\r\nif (pblk->ppaf_bitsize < 32)\r\nentry_size = 4;\r\npblk->trans_map = vmalloc(entry_size * pblk->rl.nr_secs);\r\nif (!pblk->trans_map)\r\nreturn -ENOMEM;\r\npblk_ppa_set_empty(&ppa);\r\nfor (i = 0; i < pblk->rl.nr_secs; i++)\r\npblk_trans_map_set(pblk, i, ppa);\r\nreturn 0;\r\n}\r\nstatic void pblk_rwb_free(struct pblk *pblk)\r\n{\r\nif (pblk_rb_tear_down_check(&pblk->rwb))\r\npr_err("pblk: write buffer error on tear down\n");\r\npblk_rb_data_free(&pblk->rwb);\r\nvfree(pblk_rb_entries_ref(&pblk->rwb));\r\n}\r\nstatic int pblk_rwb_init(struct pblk *pblk)\r\n{\r\nstruct nvm_tgt_dev *dev = pblk->dev;\r\nstruct nvm_geo *geo = &dev->geo;\r\nstruct pblk_rb_entry *entries;\r\nunsigned long nr_entries;\r\nunsigned int power_size, power_seg_sz;\r\nnr_entries = pblk_rb_calculate_size(pblk->pgs_in_buffer);\r\nentries = vzalloc(nr_entries * sizeof(struct pblk_rb_entry));\r\nif (!entries)\r\nreturn -ENOMEM;\r\npower_size = get_count_order(nr_entries);\r\npower_seg_sz = get_count_order(geo->sec_size);\r\nreturn pblk_rb_init(&pblk->rwb, entries, power_size, power_seg_sz);\r\n}\r\nstatic int pblk_set_ppaf(struct pblk *pblk)\r\n{\r\nstruct nvm_tgt_dev *dev = pblk->dev;\r\nstruct nvm_geo *geo = &dev->geo;\r\nstruct nvm_addr_format ppaf = geo->ppaf;\r\nint power_len;\r\npower_len = get_count_order(geo->nr_chnls);\r\nif (1 << power_len != geo->nr_chnls) {\r\npr_err("pblk: supports only power-of-two channel config.\n");\r\nreturn -EINVAL;\r\n}\r\nppaf.ch_len = power_len;\r\npower_len = get_count_order(geo->luns_per_chnl);\r\nif (1 << power_len != geo->luns_per_chnl) {\r\npr_err("pblk: supports only power-of-two LUN config.\n");\r\nreturn -EINVAL;\r\n}\r\nppaf.lun_len = power_len;\r\npblk->ppaf.sec_offset = 0;\r\npblk->ppaf.pln_offset = ppaf.sect_len;\r\npblk->ppaf.ch_offset = pblk->ppaf.pln_offset + ppaf.pln_len;\r\npblk->ppaf.lun_offset = pblk->ppaf.ch_offset + ppaf.ch_len;\r\npblk->ppaf.pg_offset = pblk->ppaf.lun_offset + ppaf.lun_len;\r\npblk->ppaf.blk_offset = pblk->ppaf.pg_offset + ppaf.pg_len;\r\npblk->ppaf.sec_mask = (1ULL << ppaf.sect_len) - 1;\r\npblk->ppaf.pln_mask = ((1ULL << ppaf.pln_len) - 1) <<\r\npblk->ppaf.pln_offset;\r\npblk->ppaf.ch_mask = ((1ULL << ppaf.ch_len) - 1) <<\r\npblk->ppaf.ch_offset;\r\npblk->ppaf.lun_mask = ((1ULL << ppaf.lun_len) - 1) <<\r\npblk->ppaf.lun_offset;\r\npblk->ppaf.pg_mask = ((1ULL << ppaf.pg_len) - 1) <<\r\npblk->ppaf.pg_offset;\r\npblk->ppaf.blk_mask = ((1ULL << ppaf.blk_len) - 1) <<\r\npblk->ppaf.blk_offset;\r\npblk->ppaf_bitsize = pblk->ppaf.blk_offset + ppaf.blk_len;\r\nreturn 0;\r\n}\r\nstatic int pblk_init_global_caches(struct pblk *pblk)\r\n{\r\nchar cache_name[PBLK_CACHE_NAME_LEN];\r\ndown_write(&pblk_lock);\r\npblk_blk_ws_cache = kmem_cache_create("pblk_blk_ws",\r\nsizeof(struct pblk_line_ws), 0, 0, NULL);\r\nif (!pblk_blk_ws_cache) {\r\nup_write(&pblk_lock);\r\nreturn -ENOMEM;\r\n}\r\npblk_rec_cache = kmem_cache_create("pblk_rec",\r\nsizeof(struct pblk_rec_ctx), 0, 0, NULL);\r\nif (!pblk_rec_cache) {\r\nkmem_cache_destroy(pblk_blk_ws_cache);\r\nup_write(&pblk_lock);\r\nreturn -ENOMEM;\r\n}\r\npblk_g_rq_cache = kmem_cache_create("pblk_g_rq", pblk_g_rq_size,\r\n0, 0, NULL);\r\nif (!pblk_g_rq_cache) {\r\nkmem_cache_destroy(pblk_blk_ws_cache);\r\nkmem_cache_destroy(pblk_rec_cache);\r\nup_write(&pblk_lock);\r\nreturn -ENOMEM;\r\n}\r\npblk_w_rq_cache = kmem_cache_create("pblk_w_rq", pblk_w_rq_size,\r\n0, 0, NULL);\r\nif (!pblk_w_rq_cache) {\r\nkmem_cache_destroy(pblk_blk_ws_cache);\r\nkmem_cache_destroy(pblk_rec_cache);\r\nkmem_cache_destroy(pblk_g_rq_cache);\r\nup_write(&pblk_lock);\r\nreturn -ENOMEM;\r\n}\r\nsnprintf(cache_name, sizeof(cache_name), "pblk_line_m_%s",\r\npblk->disk->disk_name);\r\npblk_line_meta_cache = kmem_cache_create(cache_name,\r\npblk->lm.sec_bitmap_len, 0, 0, NULL);\r\nif (!pblk_line_meta_cache) {\r\nkmem_cache_destroy(pblk_blk_ws_cache);\r\nkmem_cache_destroy(pblk_rec_cache);\r\nkmem_cache_destroy(pblk_g_rq_cache);\r\nkmem_cache_destroy(pblk_w_rq_cache);\r\nup_write(&pblk_lock);\r\nreturn -ENOMEM;\r\n}\r\nup_write(&pblk_lock);\r\nreturn 0;\r\n}\r\nstatic int pblk_core_init(struct pblk *pblk)\r\n{\r\nstruct nvm_tgt_dev *dev = pblk->dev;\r\nstruct nvm_geo *geo = &dev->geo;\r\npblk->pgs_in_buffer = NVM_MEM_PAGE_WRITE * geo->sec_per_pg *\r\ngeo->nr_planes * geo->nr_luns;\r\nif (pblk_init_global_caches(pblk))\r\nreturn -ENOMEM;\r\npblk->page_pool = mempool_create_page_pool(PAGE_POOL_SIZE, 0);\r\nif (!pblk->page_pool)\r\nreturn -ENOMEM;\r\npblk->line_ws_pool = mempool_create_slab_pool(PBLK_WS_POOL_SIZE,\r\npblk_blk_ws_cache);\r\nif (!pblk->line_ws_pool)\r\ngoto free_page_pool;\r\npblk->rec_pool = mempool_create_slab_pool(geo->nr_luns, pblk_rec_cache);\r\nif (!pblk->rec_pool)\r\ngoto free_blk_ws_pool;\r\npblk->g_rq_pool = mempool_create_slab_pool(PBLK_READ_REQ_POOL_SIZE,\r\npblk_g_rq_cache);\r\nif (!pblk->g_rq_pool)\r\ngoto free_rec_pool;\r\npblk->w_rq_pool = mempool_create_slab_pool(geo->nr_luns * 2,\r\npblk_w_rq_cache);\r\nif (!pblk->w_rq_pool)\r\ngoto free_g_rq_pool;\r\npblk->line_meta_pool =\r\nmempool_create_slab_pool(PBLK_META_POOL_SIZE,\r\npblk_line_meta_cache);\r\nif (!pblk->line_meta_pool)\r\ngoto free_w_rq_pool;\r\npblk->close_wq = alloc_workqueue("pblk-close-wq",\r\nWQ_MEM_RECLAIM | WQ_UNBOUND, PBLK_NR_CLOSE_JOBS);\r\nif (!pblk->close_wq)\r\ngoto free_line_meta_pool;\r\npblk->bb_wq = alloc_workqueue("pblk-bb-wq",\r\nWQ_MEM_RECLAIM | WQ_UNBOUND, 0);\r\nif (!pblk->bb_wq)\r\ngoto free_close_wq;\r\nif (pblk_set_ppaf(pblk))\r\ngoto free_bb_wq;\r\nif (pblk_rwb_init(pblk))\r\ngoto free_bb_wq;\r\nINIT_LIST_HEAD(&pblk->compl_list);\r\nreturn 0;\r\nfree_bb_wq:\r\ndestroy_workqueue(pblk->bb_wq);\r\nfree_close_wq:\r\ndestroy_workqueue(pblk->close_wq);\r\nfree_line_meta_pool:\r\nmempool_destroy(pblk->line_meta_pool);\r\nfree_w_rq_pool:\r\nmempool_destroy(pblk->w_rq_pool);\r\nfree_g_rq_pool:\r\nmempool_destroy(pblk->g_rq_pool);\r\nfree_rec_pool:\r\nmempool_destroy(pblk->rec_pool);\r\nfree_blk_ws_pool:\r\nmempool_destroy(pblk->line_ws_pool);\r\nfree_page_pool:\r\nmempool_destroy(pblk->page_pool);\r\nreturn -ENOMEM;\r\n}\r\nstatic void pblk_core_free(struct pblk *pblk)\r\n{\r\nif (pblk->close_wq)\r\ndestroy_workqueue(pblk->close_wq);\r\nif (pblk->bb_wq)\r\ndestroy_workqueue(pblk->bb_wq);\r\nmempool_destroy(pblk->page_pool);\r\nmempool_destroy(pblk->line_ws_pool);\r\nmempool_destroy(pblk->rec_pool);\r\nmempool_destroy(pblk->g_rq_pool);\r\nmempool_destroy(pblk->w_rq_pool);\r\nmempool_destroy(pblk->line_meta_pool);\r\nkmem_cache_destroy(pblk_blk_ws_cache);\r\nkmem_cache_destroy(pblk_rec_cache);\r\nkmem_cache_destroy(pblk_g_rq_cache);\r\nkmem_cache_destroy(pblk_w_rq_cache);\r\nkmem_cache_destroy(pblk_line_meta_cache);\r\n}\r\nstatic void pblk_luns_free(struct pblk *pblk)\r\n{\r\nkfree(pblk->luns);\r\n}\r\nstatic void pblk_free_line_bitmaps(struct pblk_line *line)\r\n{\r\nkfree(line->blk_bitmap);\r\nkfree(line->erase_bitmap);\r\n}\r\nstatic void pblk_lines_free(struct pblk *pblk)\r\n{\r\nstruct pblk_line_mgmt *l_mg = &pblk->l_mg;\r\nstruct pblk_line *line;\r\nint i;\r\nspin_lock(&l_mg->free_lock);\r\nfor (i = 0; i < l_mg->nr_lines; i++) {\r\nline = &pblk->lines[i];\r\npblk_line_free(pblk, line);\r\npblk_free_line_bitmaps(line);\r\n}\r\nspin_unlock(&l_mg->free_lock);\r\n}\r\nstatic void pblk_line_meta_free(struct pblk *pblk)\r\n{\r\nstruct pblk_line_mgmt *l_mg = &pblk->l_mg;\r\nint i;\r\nkfree(l_mg->bb_template);\r\nkfree(l_mg->bb_aux);\r\nkfree(l_mg->vsc_list);\r\nspin_lock(&l_mg->free_lock);\r\nfor (i = 0; i < PBLK_DATA_LINES; i++) {\r\nkfree(l_mg->sline_meta[i]);\r\npblk_mfree(l_mg->eline_meta[i]->buf, l_mg->emeta_alloc_type);\r\nkfree(l_mg->eline_meta[i]);\r\n}\r\nspin_unlock(&l_mg->free_lock);\r\nkfree(pblk->lines);\r\n}\r\nstatic int pblk_bb_discovery(struct nvm_tgt_dev *dev, struct pblk_lun *rlun)\r\n{\r\nstruct nvm_geo *geo = &dev->geo;\r\nstruct ppa_addr ppa;\r\nu8 *blks;\r\nint nr_blks, ret;\r\nnr_blks = geo->blks_per_lun * geo->plane_mode;\r\nblks = kmalloc(nr_blks, GFP_KERNEL);\r\nif (!blks)\r\nreturn -ENOMEM;\r\nppa.ppa = 0;\r\nppa.g.ch = rlun->bppa.g.ch;\r\nppa.g.lun = rlun->bppa.g.lun;\r\nret = nvm_get_tgt_bb_tbl(dev, ppa, blks);\r\nif (ret)\r\ngoto out;\r\nnr_blks = nvm_bb_tbl_fold(dev->parent, blks, nr_blks);\r\nif (nr_blks < 0) {\r\nret = nr_blks;\r\ngoto out;\r\n}\r\nrlun->bb_list = blks;\r\nreturn 0;\r\nout:\r\nkfree(blks);\r\nreturn ret;\r\n}\r\nstatic int pblk_bb_line(struct pblk *pblk, struct pblk_line *line,\r\nint blk_per_line)\r\n{\r\nstruct nvm_tgt_dev *dev = pblk->dev;\r\nstruct nvm_geo *geo = &dev->geo;\r\nstruct pblk_lun *rlun;\r\nint bb_cnt = 0;\r\nint i;\r\nfor (i = 0; i < blk_per_line; i++) {\r\nrlun = &pblk->luns[i];\r\nif (rlun->bb_list[line->id] == NVM_BLK_T_FREE)\r\ncontinue;\r\nset_bit(pblk_ppa_to_pos(geo, rlun->bppa), line->blk_bitmap);\r\nbb_cnt++;\r\n}\r\nreturn bb_cnt;\r\n}\r\nstatic int pblk_alloc_line_bitmaps(struct pblk *pblk, struct pblk_line *line)\r\n{\r\nstruct pblk_line_meta *lm = &pblk->lm;\r\nline->blk_bitmap = kzalloc(lm->blk_bitmap_len, GFP_KERNEL);\r\nif (!line->blk_bitmap)\r\nreturn -ENOMEM;\r\nline->erase_bitmap = kzalloc(lm->blk_bitmap_len, GFP_KERNEL);\r\nif (!line->erase_bitmap) {\r\nkfree(line->blk_bitmap);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pblk_luns_init(struct pblk *pblk, struct ppa_addr *luns)\r\n{\r\nstruct nvm_tgt_dev *dev = pblk->dev;\r\nstruct nvm_geo *geo = &dev->geo;\r\nstruct pblk_lun *rlun;\r\nint i, ret;\r\nif (geo->luns_per_chnl < 0) {\r\npr_err("pblk: unbalanced LUN config.\n");\r\nreturn -EINVAL;\r\n}\r\npblk->luns = kcalloc(geo->nr_luns, sizeof(struct pblk_lun), GFP_KERNEL);\r\nif (!pblk->luns)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < geo->nr_luns; i++) {\r\nint ch = i % geo->nr_chnls;\r\nint lun_raw = i / geo->nr_chnls;\r\nint lunid = lun_raw + ch * geo->luns_per_chnl;\r\nrlun = &pblk->luns[i];\r\nrlun->bppa = luns[lunid];\r\nsema_init(&rlun->wr_sem, 1);\r\nret = pblk_bb_discovery(dev, rlun);\r\nif (ret) {\r\nwhile (--i >= 0)\r\nkfree(pblk->luns[i].bb_list);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int pblk_lines_configure(struct pblk *pblk, int flags)\r\n{\r\nstruct pblk_line *line = NULL;\r\nint ret = 0;\r\nif (!(flags & NVM_TARGET_FACTORY)) {\r\nline = pblk_recov_l2p(pblk);\r\nif (IS_ERR(line)) {\r\npr_err("pblk: could not recover l2p table\n");\r\nret = -EFAULT;\r\n}\r\n}\r\nif (!line) {\r\nline = pblk_line_get_first_data(pblk);\r\nif (!line) {\r\npr_err("pblk: line list corrupted\n");\r\nret = -EFAULT;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic unsigned int calc_emeta_len(struct pblk *pblk)\r\n{\r\nstruct pblk_line_meta *lm = &pblk->lm;\r\nstruct pblk_line_mgmt *l_mg = &pblk->l_mg;\r\nstruct nvm_tgt_dev *dev = pblk->dev;\r\nstruct nvm_geo *geo = &dev->geo;\r\nlm->emeta_sec[1] = DIV_ROUND_UP(\r\nsizeof(struct line_emeta) + lm->blk_bitmap_len,\r\ngeo->sec_size);\r\nlm->emeta_len[1] = lm->emeta_sec[1] * geo->sec_size;\r\nlm->dsec_per_line = lm->sec_per_line - lm->emeta_sec[0];\r\nlm->emeta_sec[2] = DIV_ROUND_UP(lm->dsec_per_line * sizeof(u64),\r\ngeo->sec_size);\r\nlm->emeta_len[2] = lm->emeta_sec[2] * geo->sec_size;\r\nlm->emeta_sec[3] = DIV_ROUND_UP(l_mg->nr_lines * sizeof(u32),\r\ngeo->sec_size);\r\nlm->emeta_len[3] = lm->emeta_sec[3] * geo->sec_size;\r\nlm->vsc_list_len = l_mg->nr_lines * sizeof(u32);\r\nreturn (lm->emeta_len[1] + lm->emeta_len[2] + lm->emeta_len[3]);\r\n}\r\nstatic void pblk_set_provision(struct pblk *pblk, long nr_free_blks)\r\n{\r\nstruct nvm_tgt_dev *dev = pblk->dev;\r\nstruct nvm_geo *geo = &dev->geo;\r\nsector_t provisioned;\r\npblk->over_pct = 20;\r\nprovisioned = nr_free_blks;\r\nprovisioned *= (100 - pblk->over_pct);\r\nsector_div(provisioned, 100);\r\npblk->rl.total_blocks = nr_free_blks;\r\npblk->rl.nr_secs = nr_free_blks * geo->sec_per_blk;\r\npblk->capacity = provisioned * geo->sec_per_blk;\r\natomic_set(&pblk->rl.free_blocks, nr_free_blks);\r\n}\r\nstatic int pblk_lines_alloc_metadata(struct pblk *pblk)\r\n{\r\nstruct pblk_line_mgmt *l_mg = &pblk->l_mg;\r\nstruct pblk_line_meta *lm = &pblk->lm;\r\nint i;\r\nfor (i = 0; i < PBLK_DATA_LINES; i++) {\r\nl_mg->sline_meta[i] = kmalloc(lm->smeta_len, GFP_KERNEL);\r\nif (!l_mg->sline_meta[i])\r\ngoto fail_free_smeta;\r\n}\r\nfor (i = 0; i < PBLK_DATA_LINES; i++) {\r\nstruct pblk_emeta *emeta;\r\nemeta = kmalloc(sizeof(struct pblk_emeta), GFP_KERNEL);\r\nif (!emeta)\r\ngoto fail_free_emeta;\r\nif (lm->emeta_len[0] > KMALLOC_MAX_CACHE_SIZE) {\r\nl_mg->emeta_alloc_type = PBLK_VMALLOC_META;\r\nemeta->buf = vmalloc(lm->emeta_len[0]);\r\nif (!emeta->buf) {\r\nkfree(emeta);\r\ngoto fail_free_emeta;\r\n}\r\nemeta->nr_entries = lm->emeta_sec[0];\r\nl_mg->eline_meta[i] = emeta;\r\n} else {\r\nl_mg->emeta_alloc_type = PBLK_KMALLOC_META;\r\nemeta->buf = kmalloc(lm->emeta_len[0], GFP_KERNEL);\r\nif (!emeta->buf) {\r\nkfree(emeta);\r\ngoto fail_free_emeta;\r\n}\r\nemeta->nr_entries = lm->emeta_sec[0];\r\nl_mg->eline_meta[i] = emeta;\r\n}\r\n}\r\nl_mg->vsc_list = kcalloc(l_mg->nr_lines, sizeof(__le32), GFP_KERNEL);\r\nif (!l_mg->vsc_list)\r\ngoto fail_free_emeta;\r\nfor (i = 0; i < l_mg->nr_lines; i++)\r\nl_mg->vsc_list[i] = cpu_to_le32(EMPTY_ENTRY);\r\nreturn 0;\r\nfail_free_emeta:\r\nwhile (--i >= 0) {\r\nvfree(l_mg->eline_meta[i]->buf);\r\nkfree(l_mg->eline_meta[i]);\r\n}\r\nfail_free_smeta:\r\nfor (i = 0; i < PBLK_DATA_LINES; i++)\r\nkfree(l_mg->sline_meta[i]);\r\nreturn -ENOMEM;\r\n}\r\nstatic int pblk_lines_init(struct pblk *pblk)\r\n{\r\nstruct nvm_tgt_dev *dev = pblk->dev;\r\nstruct nvm_geo *geo = &dev->geo;\r\nstruct pblk_line_mgmt *l_mg = &pblk->l_mg;\r\nstruct pblk_line_meta *lm = &pblk->lm;\r\nstruct pblk_line *line;\r\nunsigned int smeta_len, emeta_len;\r\nlong nr_bad_blks, nr_free_blks;\r\nint bb_distance, max_write_ppas, mod;\r\nint i, ret;\r\npblk->min_write_pgs = geo->sec_per_pl * (geo->sec_size / PAGE_SIZE);\r\nmax_write_ppas = pblk->min_write_pgs * geo->nr_luns;\r\npblk->max_write_pgs = (max_write_ppas < nvm_max_phys_sects(dev)) ?\r\nmax_write_ppas : nvm_max_phys_sects(dev);\r\npblk_set_sec_per_write(pblk, pblk->min_write_pgs);\r\nif (pblk->max_write_pgs > PBLK_MAX_REQ_ADDRS) {\r\npr_err("pblk: cannot support device max_phys_sect\n");\r\nreturn -EINVAL;\r\n}\r\ndiv_u64_rem(geo->sec_per_blk, pblk->min_write_pgs, &mod);\r\nif (mod) {\r\npr_err("pblk: bad configuration of sectors/pages\n");\r\nreturn -EINVAL;\r\n}\r\nl_mg->nr_lines = geo->blks_per_lun;\r\nl_mg->log_line = l_mg->data_line = NULL;\r\nl_mg->l_seq_nr = l_mg->d_seq_nr = 0;\r\nl_mg->nr_free_lines = 0;\r\nbitmap_zero(&l_mg->meta_bitmap, PBLK_DATA_LINES);\r\nlm->sec_per_line = geo->sec_per_blk * geo->nr_luns;\r\nlm->blk_per_line = geo->nr_luns;\r\nlm->blk_bitmap_len = BITS_TO_LONGS(geo->nr_luns) * sizeof(long);\r\nlm->sec_bitmap_len = BITS_TO_LONGS(lm->sec_per_line) * sizeof(long);\r\nlm->lun_bitmap_len = BITS_TO_LONGS(geo->nr_luns) * sizeof(long);\r\nlm->high_thrs = lm->sec_per_line / 2;\r\nlm->mid_thrs = lm->sec_per_line / 4;\r\nlm->meta_distance = (geo->nr_luns / 2) * pblk->min_write_pgs;\r\ni = 1;\r\nadd_smeta_page:\r\nlm->smeta_sec = i * geo->sec_per_pl;\r\nlm->smeta_len = lm->smeta_sec * geo->sec_size;\r\nsmeta_len = sizeof(struct line_smeta) + lm->lun_bitmap_len;\r\nif (smeta_len > lm->smeta_len) {\r\ni++;\r\ngoto add_smeta_page;\r\n}\r\ni = 1;\r\nadd_emeta_page:\r\nlm->emeta_sec[0] = i * geo->sec_per_pl;\r\nlm->emeta_len[0] = lm->emeta_sec[0] * geo->sec_size;\r\nemeta_len = calc_emeta_len(pblk);\r\nif (emeta_len > lm->emeta_len[0]) {\r\ni++;\r\ngoto add_emeta_page;\r\n}\r\nlm->emeta_bb = geo->nr_luns - i;\r\nlm->min_blk_line = 1 + DIV_ROUND_UP(lm->smeta_sec + lm->emeta_sec[0],\r\ngeo->sec_per_blk);\r\nif (lm->min_blk_line > lm->blk_per_line) {\r\npr_err("pblk: config. not supported. Min. LUN in line:%d\n",\r\nlm->blk_per_line);\r\nret = -EINVAL;\r\ngoto fail;\r\n}\r\nret = pblk_lines_alloc_metadata(pblk);\r\nif (ret)\r\ngoto fail;\r\nl_mg->bb_template = kzalloc(lm->sec_bitmap_len, GFP_KERNEL);\r\nif (!l_mg->bb_template) {\r\nret = -ENOMEM;\r\ngoto fail_free_meta;\r\n}\r\nl_mg->bb_aux = kzalloc(lm->sec_bitmap_len, GFP_KERNEL);\r\nif (!l_mg->bb_aux) {\r\nret = -ENOMEM;\r\ngoto fail_free_bb_template;\r\n}\r\nbb_distance = (geo->nr_luns) * geo->sec_per_pl;\r\nfor (i = 0; i < lm->sec_per_line; i += bb_distance)\r\nbitmap_set(l_mg->bb_template, i, geo->sec_per_pl);\r\nINIT_LIST_HEAD(&l_mg->free_list);\r\nINIT_LIST_HEAD(&l_mg->corrupt_list);\r\nINIT_LIST_HEAD(&l_mg->bad_list);\r\nINIT_LIST_HEAD(&l_mg->gc_full_list);\r\nINIT_LIST_HEAD(&l_mg->gc_high_list);\r\nINIT_LIST_HEAD(&l_mg->gc_mid_list);\r\nINIT_LIST_HEAD(&l_mg->gc_low_list);\r\nINIT_LIST_HEAD(&l_mg->gc_empty_list);\r\nINIT_LIST_HEAD(&l_mg->emeta_list);\r\nl_mg->gc_lists[0] = &l_mg->gc_high_list;\r\nl_mg->gc_lists[1] = &l_mg->gc_mid_list;\r\nl_mg->gc_lists[2] = &l_mg->gc_low_list;\r\nspin_lock_init(&l_mg->free_lock);\r\nspin_lock_init(&l_mg->close_lock);\r\nspin_lock_init(&l_mg->gc_lock);\r\npblk->lines = kcalloc(l_mg->nr_lines, sizeof(struct pblk_line),\r\nGFP_KERNEL);\r\nif (!pblk->lines) {\r\nret = -ENOMEM;\r\ngoto fail_free_bb_aux;\r\n}\r\nnr_free_blks = 0;\r\nfor (i = 0; i < l_mg->nr_lines; i++) {\r\nint blk_in_line;\r\nline = &pblk->lines[i];\r\nline->pblk = pblk;\r\nline->id = i;\r\nline->type = PBLK_LINETYPE_FREE;\r\nline->state = PBLK_LINESTATE_FREE;\r\nline->gc_group = PBLK_LINEGC_NONE;\r\nline->vsc = &l_mg->vsc_list[i];\r\nspin_lock_init(&line->lock);\r\nret = pblk_alloc_line_bitmaps(pblk, line);\r\nif (ret)\r\ngoto fail_free_lines;\r\nnr_bad_blks = pblk_bb_line(pblk, line, lm->blk_per_line);\r\nif (nr_bad_blks < 0 || nr_bad_blks > lm->blk_per_line) {\r\npblk_free_line_bitmaps(line);\r\nret = -EINVAL;\r\ngoto fail_free_lines;\r\n}\r\nblk_in_line = lm->blk_per_line - nr_bad_blks;\r\nif (blk_in_line < lm->min_blk_line) {\r\nline->state = PBLK_LINESTATE_BAD;\r\nlist_add_tail(&line->list, &l_mg->bad_list);\r\ncontinue;\r\n}\r\nnr_free_blks += blk_in_line;\r\natomic_set(&line->blk_in_line, blk_in_line);\r\nl_mg->nr_free_lines++;\r\nlist_add_tail(&line->list, &l_mg->free_list);\r\n}\r\npblk_set_provision(pblk, nr_free_blks);\r\nfor (i = 0; i < geo->nr_luns; i++)\r\nkfree(pblk->luns[i].bb_list);\r\nreturn 0;\r\nfail_free_lines:\r\nwhile (--i >= 0)\r\npblk_free_line_bitmaps(&pblk->lines[i]);\r\nfail_free_bb_aux:\r\nkfree(l_mg->bb_aux);\r\nfail_free_bb_template:\r\nkfree(l_mg->bb_template);\r\nfail_free_meta:\r\npblk_line_meta_free(pblk);\r\nfail:\r\nfor (i = 0; i < geo->nr_luns; i++)\r\nkfree(pblk->luns[i].bb_list);\r\nreturn ret;\r\n}\r\nstatic int pblk_writer_init(struct pblk *pblk)\r\n{\r\nsetup_timer(&pblk->wtimer, pblk_write_timer_fn, (unsigned long)pblk);\r\nmod_timer(&pblk->wtimer, jiffies + msecs_to_jiffies(100));\r\npblk->writer_ts = kthread_create(pblk_write_ts, pblk, "pblk-writer-t");\r\nif (IS_ERR(pblk->writer_ts)) {\r\npr_err("pblk: could not allocate writer kthread\n");\r\nreturn PTR_ERR(pblk->writer_ts);\r\n}\r\nreturn 0;\r\n}\r\nstatic void pblk_writer_stop(struct pblk *pblk)\r\n{\r\nWARN(pblk_rb_read_count(&pblk->rwb),\r\n"Stopping not fully persisted write buffer\n");\r\nWARN(pblk_rb_sync_count(&pblk->rwb),\r\n"Stopping not fully synced write buffer\n");\r\nif (pblk->writer_ts)\r\nkthread_stop(pblk->writer_ts);\r\ndel_timer(&pblk->wtimer);\r\n}\r\nstatic void pblk_free(struct pblk *pblk)\r\n{\r\npblk_luns_free(pblk);\r\npblk_lines_free(pblk);\r\npblk_line_meta_free(pblk);\r\npblk_core_free(pblk);\r\npblk_l2p_free(pblk);\r\nkfree(pblk);\r\n}\r\nstatic void pblk_tear_down(struct pblk *pblk)\r\n{\r\npblk_pipeline_stop(pblk);\r\npblk_writer_stop(pblk);\r\npblk_rb_sync_l2p(&pblk->rwb);\r\npblk_rwb_free(pblk);\r\npblk_rl_free(&pblk->rl);\r\npr_debug("pblk: consistent tear down\n");\r\n}\r\nstatic void pblk_exit(void *private)\r\n{\r\nstruct pblk *pblk = private;\r\ndown_write(&pblk_lock);\r\npblk_gc_exit(pblk);\r\npblk_tear_down(pblk);\r\npblk_free(pblk);\r\nup_write(&pblk_lock);\r\n}\r\nstatic sector_t pblk_capacity(void *private)\r\n{\r\nstruct pblk *pblk = private;\r\nreturn pblk->capacity * NR_PHY_IN_LOG;\r\n}\r\nstatic void *pblk_init(struct nvm_tgt_dev *dev, struct gendisk *tdisk,\r\nint flags)\r\n{\r\nstruct nvm_geo *geo = &dev->geo;\r\nstruct request_queue *bqueue = dev->q;\r\nstruct request_queue *tqueue = tdisk->queue;\r\nstruct pblk *pblk;\r\nint ret;\r\nif (dev->identity.dom & NVM_RSP_L2P) {\r\npr_err("pblk: device-side L2P table not supported. (%x)\n",\r\ndev->identity.dom);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\npblk = kzalloc(sizeof(struct pblk), GFP_KERNEL);\r\nif (!pblk)\r\nreturn ERR_PTR(-ENOMEM);\r\npblk->dev = dev;\r\npblk->disk = tdisk;\r\npblk->state = PBLK_STATE_RUNNING;\r\nspin_lock_init(&pblk->trans_lock);\r\nspin_lock_init(&pblk->lock);\r\nif (flags & NVM_TARGET_FACTORY)\r\npblk_setup_uuid(pblk);\r\n#ifdef CONFIG_NVM_DEBUG\r\natomic_long_set(&pblk->inflight_writes, 0);\r\natomic_long_set(&pblk->padded_writes, 0);\r\natomic_long_set(&pblk->padded_wb, 0);\r\natomic_long_set(&pblk->nr_flush, 0);\r\natomic_long_set(&pblk->req_writes, 0);\r\natomic_long_set(&pblk->sub_writes, 0);\r\natomic_long_set(&pblk->sync_writes, 0);\r\natomic_long_set(&pblk->inflight_reads, 0);\r\natomic_long_set(&pblk->cache_reads, 0);\r\natomic_long_set(&pblk->sync_reads, 0);\r\natomic_long_set(&pblk->recov_writes, 0);\r\natomic_long_set(&pblk->recov_writes, 0);\r\natomic_long_set(&pblk->recov_gc_writes, 0);\r\n#endif\r\natomic_long_set(&pblk->read_failed, 0);\r\natomic_long_set(&pblk->read_empty, 0);\r\natomic_long_set(&pblk->read_high_ecc, 0);\r\natomic_long_set(&pblk->read_failed_gc, 0);\r\natomic_long_set(&pblk->write_failed, 0);\r\natomic_long_set(&pblk->erase_failed, 0);\r\nret = pblk_luns_init(pblk, dev->luns);\r\nif (ret) {\r\npr_err("pblk: could not initialize luns\n");\r\ngoto fail;\r\n}\r\nret = pblk_lines_init(pblk);\r\nif (ret) {\r\npr_err("pblk: could not initialize lines\n");\r\ngoto fail_free_luns;\r\n}\r\nret = pblk_core_init(pblk);\r\nif (ret) {\r\npr_err("pblk: could not initialize core\n");\r\ngoto fail_free_line_meta;\r\n}\r\nret = pblk_l2p_init(pblk);\r\nif (ret) {\r\npr_err("pblk: could not initialize maps\n");\r\ngoto fail_free_core;\r\n}\r\nret = pblk_lines_configure(pblk, flags);\r\nif (ret) {\r\npr_err("pblk: could not configure lines\n");\r\ngoto fail_free_l2p;\r\n}\r\nret = pblk_writer_init(pblk);\r\nif (ret) {\r\npr_err("pblk: could not initialize write thread\n");\r\ngoto fail_free_lines;\r\n}\r\nret = pblk_gc_init(pblk);\r\nif (ret) {\r\npr_err("pblk: could not initialize gc\n");\r\ngoto fail_stop_writer;\r\n}\r\nblk_queue_logical_block_size(tqueue, queue_physical_block_size(bqueue));\r\nblk_queue_max_hw_sectors(tqueue, queue_max_hw_sectors(bqueue));\r\nblk_queue_write_cache(tqueue, true, false);\r\ntqueue->limits.discard_granularity = geo->pgs_per_blk * geo->pfpg_size;\r\ntqueue->limits.discard_alignment = 0;\r\nblk_queue_max_discard_sectors(tqueue, UINT_MAX >> 9);\r\nqueue_flag_set_unlocked(QUEUE_FLAG_DISCARD, tqueue);\r\npr_info("pblk init: luns:%u, lines:%d, secs:%llu, buf entries:%u\n",\r\ngeo->nr_luns, pblk->l_mg.nr_lines,\r\n(unsigned long long)pblk->rl.nr_secs,\r\npblk->rwb.nr_entries);\r\nwake_up_process(pblk->writer_ts);\r\nreturn pblk;\r\nfail_stop_writer:\r\npblk_writer_stop(pblk);\r\nfail_free_lines:\r\npblk_lines_free(pblk);\r\nfail_free_l2p:\r\npblk_l2p_free(pblk);\r\nfail_free_core:\r\npblk_core_free(pblk);\r\nfail_free_line_meta:\r\npblk_line_meta_free(pblk);\r\nfail_free_luns:\r\npblk_luns_free(pblk);\r\nfail:\r\nkfree(pblk);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic int __init pblk_module_init(void)\r\n{\r\nint ret;\r\npblk_bio_set = bioset_create(BIO_POOL_SIZE, 0, 0);\r\nif (!pblk_bio_set)\r\nreturn -ENOMEM;\r\nret = nvm_register_tgt_type(&tt_pblk);\r\nif (ret)\r\nbioset_free(pblk_bio_set);\r\nreturn ret;\r\n}\r\nstatic void pblk_module_exit(void)\r\n{\r\nbioset_free(pblk_bio_set);\r\nnvm_unregister_tgt_type(&tt_pblk);\r\n}
