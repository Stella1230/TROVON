static unsigned int\r\nsetup_sg(struct scatterlist *sg, const void *address, unsigned int length)\r\n{\r\nsg_set_buf(sg, address, length);\r\nreturn length;\r\n}\r\nstatic inline void sha_pad_init(struct sha_pad *shapad)\r\n{\r\nmemset(shapad->sha_pad1, 0x00, sizeof(shapad->sha_pad1));\r\nmemset(shapad->sha_pad2, 0xF2, sizeof(shapad->sha_pad2));\r\n}\r\nstatic void get_new_key_from_sha(struct ppp_mppe_state * state)\r\n{\r\nAHASH_REQUEST_ON_STACK(req, state->sha1);\r\nstruct scatterlist sg[4];\r\nunsigned int nbytes;\r\nsg_init_table(sg, 4);\r\nnbytes = setup_sg(&sg[0], state->master_key, state->keylen);\r\nnbytes += setup_sg(&sg[1], sha_pad->sha_pad1,\r\nsizeof(sha_pad->sha_pad1));\r\nnbytes += setup_sg(&sg[2], state->session_key, state->keylen);\r\nnbytes += setup_sg(&sg[3], sha_pad->sha_pad2,\r\nsizeof(sha_pad->sha_pad2));\r\nahash_request_set_tfm(req, state->sha1);\r\nahash_request_set_callback(req, 0, NULL, NULL);\r\nahash_request_set_crypt(req, sg, state->sha1_digest, nbytes);\r\ncrypto_ahash_digest(req);\r\nahash_request_zero(req);\r\n}\r\nstatic void mppe_rekey(struct ppp_mppe_state * state, int initial_key)\r\n{\r\nstruct scatterlist sg_in[1], sg_out[1];\r\nSKCIPHER_REQUEST_ON_STACK(req, state->arc4);\r\nskcipher_request_set_tfm(req, state->arc4);\r\nskcipher_request_set_callback(req, 0, NULL, NULL);\r\nget_new_key_from_sha(state);\r\nif (!initial_key) {\r\ncrypto_skcipher_setkey(state->arc4, state->sha1_digest,\r\nstate->keylen);\r\nsg_init_table(sg_in, 1);\r\nsg_init_table(sg_out, 1);\r\nsetup_sg(sg_in, state->sha1_digest, state->keylen);\r\nsetup_sg(sg_out, state->session_key, state->keylen);\r\nskcipher_request_set_crypt(req, sg_in, sg_out, state->keylen,\r\nNULL);\r\nif (crypto_skcipher_encrypt(req))\r\nprintk(KERN_WARNING "mppe_rekey: cipher_encrypt failed\n");\r\n} else {\r\nmemcpy(state->session_key, state->sha1_digest, state->keylen);\r\n}\r\nif (state->keylen == 8) {\r\nstate->session_key[0] = 0xd1;\r\nstate->session_key[1] = 0x26;\r\nstate->session_key[2] = 0x9e;\r\n}\r\ncrypto_skcipher_setkey(state->arc4, state->session_key, state->keylen);\r\nskcipher_request_zero(req);\r\n}\r\nstatic void *mppe_alloc(unsigned char *options, int optlen)\r\n{\r\nstruct ppp_mppe_state *state;\r\nunsigned int digestsize;\r\nif (optlen != CILEN_MPPE + sizeof(state->master_key) ||\r\noptions[0] != CI_MPPE || options[1] != CILEN_MPPE)\r\ngoto out;\r\nstate = kzalloc(sizeof(*state), GFP_KERNEL);\r\nif (state == NULL)\r\ngoto out;\r\nstate->arc4 = crypto_alloc_skcipher("ecb(arc4)", 0, CRYPTO_ALG_ASYNC);\r\nif (IS_ERR(state->arc4)) {\r\nstate->arc4 = NULL;\r\ngoto out_free;\r\n}\r\nstate->sha1 = crypto_alloc_ahash("sha1", 0, CRYPTO_ALG_ASYNC);\r\nif (IS_ERR(state->sha1)) {\r\nstate->sha1 = NULL;\r\ngoto out_free;\r\n}\r\ndigestsize = crypto_ahash_digestsize(state->sha1);\r\nif (digestsize < MPPE_MAX_KEY_LEN)\r\ngoto out_free;\r\nstate->sha1_digest = kmalloc(digestsize, GFP_KERNEL);\r\nif (!state->sha1_digest)\r\ngoto out_free;\r\nmemcpy(state->master_key, &options[CILEN_MPPE],\r\nsizeof(state->master_key));\r\nmemcpy(state->session_key, state->master_key,\r\nsizeof(state->master_key));\r\nreturn (void *)state;\r\nout_free:\r\nkfree(state->sha1_digest);\r\ncrypto_free_ahash(state->sha1);\r\ncrypto_free_skcipher(state->arc4);\r\nkfree(state);\r\nout:\r\nreturn NULL;\r\n}\r\nstatic void mppe_free(void *arg)\r\n{\r\nstruct ppp_mppe_state *state = (struct ppp_mppe_state *) arg;\r\nif (state) {\r\nkfree(state->sha1_digest);\r\ncrypto_free_ahash(state->sha1);\r\ncrypto_free_skcipher(state->arc4);\r\nkfree(state);\r\n}\r\n}\r\nstatic int\r\nmppe_init(void *arg, unsigned char *options, int optlen, int unit, int debug,\r\nconst char *debugstr)\r\n{\r\nstruct ppp_mppe_state *state = (struct ppp_mppe_state *) arg;\r\nunsigned char mppe_opts;\r\nif (optlen != CILEN_MPPE ||\r\noptions[0] != CI_MPPE || options[1] != CILEN_MPPE)\r\nreturn 0;\r\nMPPE_CI_TO_OPTS(&options[2], mppe_opts);\r\nif (mppe_opts & MPPE_OPT_128)\r\nstate->keylen = 16;\r\nelse if (mppe_opts & MPPE_OPT_40)\r\nstate->keylen = 8;\r\nelse {\r\nprintk(KERN_WARNING "%s[%d]: unknown key length\n", debugstr,\r\nunit);\r\nreturn 0;\r\n}\r\nif (mppe_opts & MPPE_OPT_STATEFUL)\r\nstate->stateful = 1;\r\nmppe_rekey(state, 1);\r\nif (debug) {\r\nprintk(KERN_DEBUG "%s[%d]: initialized with %d-bit %s mode\n",\r\ndebugstr, unit, (state->keylen == 16) ? 128 : 40,\r\n(state->stateful) ? "stateful" : "stateless");\r\nprintk(KERN_DEBUG\r\n"%s[%d]: keys: master: %*phN initial session: %*phN\n",\r\ndebugstr, unit,\r\n(int)sizeof(state->master_key), state->master_key,\r\n(int)sizeof(state->session_key), state->session_key);\r\n}\r\nstate->ccount = MPPE_CCOUNT_SPACE - 1;\r\nstate->bits = MPPE_BIT_ENCRYPTED;\r\nstate->unit = unit;\r\nstate->debug = debug;\r\nreturn 1;\r\n}\r\nstatic int\r\nmppe_comp_init(void *arg, unsigned char *options, int optlen, int unit,\r\nint hdrlen, int debug)\r\n{\r\nreturn mppe_init(arg, options, optlen, unit, debug, "mppe_comp_init");\r\n}\r\nstatic void mppe_comp_reset(void *arg)\r\n{\r\nstruct ppp_mppe_state *state = (struct ppp_mppe_state *) arg;\r\nstate->bits |= MPPE_BIT_FLUSHED;\r\n}\r\nstatic int\r\nmppe_compress(void *arg, unsigned char *ibuf, unsigned char *obuf,\r\nint isize, int osize)\r\n{\r\nstruct ppp_mppe_state *state = (struct ppp_mppe_state *) arg;\r\nSKCIPHER_REQUEST_ON_STACK(req, state->arc4);\r\nint proto;\r\nint err;\r\nstruct scatterlist sg_in[1], sg_out[1];\r\nproto = PPP_PROTOCOL(ibuf);\r\nif (proto < 0x0021 || proto > 0x00fa)\r\nreturn 0;\r\nif (osize < isize + MPPE_OVHD + 2) {\r\nprintk(KERN_DEBUG "mppe_compress[%d]: osize too small! "\r\n"(have: %d need: %d)\n", state->unit,\r\nosize, osize + MPPE_OVHD + 2);\r\nreturn -1;\r\n}\r\nosize = isize + MPPE_OVHD + 2;\r\nobuf[0] = PPP_ADDRESS(ibuf);\r\nobuf[1] = PPP_CONTROL(ibuf);\r\nput_unaligned_be16(PPP_COMP, obuf + 2);\r\nobuf += PPP_HDRLEN;\r\nstate->ccount = (state->ccount + 1) % MPPE_CCOUNT_SPACE;\r\nif (state->debug >= 7)\r\nprintk(KERN_DEBUG "mppe_compress[%d]: ccount %d\n", state->unit,\r\nstate->ccount);\r\nput_unaligned_be16(state->ccount, obuf);\r\nif (!state->stateful ||\r\n((state->ccount & 0xff) == 0xff) ||\r\n(state->bits & MPPE_BIT_FLUSHED)) {\r\nif (state->debug && state->stateful)\r\nprintk(KERN_DEBUG "mppe_compress[%d]: rekeying\n",\r\nstate->unit);\r\nmppe_rekey(state, 0);\r\nstate->bits |= MPPE_BIT_FLUSHED;\r\n}\r\nobuf[0] |= state->bits;\r\nstate->bits &= ~MPPE_BIT_FLUSHED;\r\nobuf += MPPE_OVHD;\r\nibuf += 2;\r\nisize -= 2;\r\nsg_init_table(sg_in, 1);\r\nsg_init_table(sg_out, 1);\r\nsetup_sg(sg_in, ibuf, isize);\r\nsetup_sg(sg_out, obuf, osize);\r\nskcipher_request_set_tfm(req, state->arc4);\r\nskcipher_request_set_callback(req, 0, NULL, NULL);\r\nskcipher_request_set_crypt(req, sg_in, sg_out, isize, NULL);\r\nerr = crypto_skcipher_encrypt(req);\r\nskcipher_request_zero(req);\r\nif (err) {\r\nprintk(KERN_DEBUG "crypto_cypher_encrypt failed\n");\r\nreturn -1;\r\n}\r\nstate->stats.unc_bytes += isize;\r\nstate->stats.unc_packets++;\r\nstate->stats.comp_bytes += osize;\r\nstate->stats.comp_packets++;\r\nreturn osize;\r\n}\r\nstatic void mppe_comp_stats(void *arg, struct compstat *stats)\r\n{\r\nstruct ppp_mppe_state *state = (struct ppp_mppe_state *) arg;\r\n*stats = state->stats;\r\n}\r\nstatic int\r\nmppe_decomp_init(void *arg, unsigned char *options, int optlen, int unit,\r\nint hdrlen, int mru, int debug)\r\n{\r\nreturn mppe_init(arg, options, optlen, unit, debug, "mppe_decomp_init");\r\n}\r\nstatic void mppe_decomp_reset(void *arg)\r\n{\r\nreturn;\r\n}\r\nstatic int\r\nmppe_decompress(void *arg, unsigned char *ibuf, int isize, unsigned char *obuf,\r\nint osize)\r\n{\r\nstruct ppp_mppe_state *state = (struct ppp_mppe_state *) arg;\r\nSKCIPHER_REQUEST_ON_STACK(req, state->arc4);\r\nunsigned ccount;\r\nint flushed = MPPE_BITS(ibuf) & MPPE_BIT_FLUSHED;\r\nstruct scatterlist sg_in[1], sg_out[1];\r\nif (isize <= PPP_HDRLEN + MPPE_OVHD) {\r\nif (state->debug)\r\nprintk(KERN_DEBUG\r\n"mppe_decompress[%d]: short pkt (%d)\n",\r\nstate->unit, isize);\r\nreturn DECOMP_ERROR;\r\n}\r\nif (osize < isize - MPPE_OVHD - 1) {\r\nprintk(KERN_DEBUG "mppe_decompress[%d]: osize too small! "\r\n"(have: %d need: %d)\n", state->unit,\r\nosize, isize - MPPE_OVHD - 1);\r\nreturn DECOMP_ERROR;\r\n}\r\nosize = isize - MPPE_OVHD - 2;\r\nccount = MPPE_CCOUNT(ibuf);\r\nif (state->debug >= 7)\r\nprintk(KERN_DEBUG "mppe_decompress[%d]: ccount %d\n",\r\nstate->unit, ccount);\r\nif (!(MPPE_BITS(ibuf) & MPPE_BIT_ENCRYPTED)) {\r\nprintk(KERN_DEBUG\r\n"mppe_decompress[%d]: ENCRYPTED bit not set!\n",\r\nstate->unit);\r\nstate->sanity_errors += 100;\r\ngoto sanity_error;\r\n}\r\nif (!state->stateful && !flushed) {\r\nprintk(KERN_DEBUG "mppe_decompress[%d]: FLUSHED bit not set in "\r\n"stateless mode!\n", state->unit);\r\nstate->sanity_errors += 100;\r\ngoto sanity_error;\r\n}\r\nif (state->stateful && ((ccount & 0xff) == 0xff) && !flushed) {\r\nprintk(KERN_DEBUG "mppe_decompress[%d]: FLUSHED bit not set on "\r\n"flag packet!\n", state->unit);\r\nstate->sanity_errors += 100;\r\ngoto sanity_error;\r\n}\r\nif (!state->stateful) {\r\nif ((ccount - state->ccount) % MPPE_CCOUNT_SPACE\r\n> MPPE_CCOUNT_SPACE / 2) {\r\nstate->sanity_errors++;\r\ngoto sanity_error;\r\n}\r\nwhile (state->ccount != ccount) {\r\nmppe_rekey(state, 0);\r\nstate->ccount = (state->ccount + 1) % MPPE_CCOUNT_SPACE;\r\n}\r\n} else {\r\nif (!state->discard) {\r\nstate->ccount = (state->ccount + 1) % MPPE_CCOUNT_SPACE;\r\nif (ccount != state->ccount) {\r\nstate->discard = 1;\r\nreturn DECOMP_ERROR;\r\n}\r\n} else {\r\nif (!flushed) {\r\nreturn DECOMP_ERROR;\r\n} else {\r\nwhile ((ccount & ~0xff) !=\r\n(state->ccount & ~0xff)) {\r\nmppe_rekey(state, 0);\r\nstate->ccount =\r\n(state->ccount +\r\n256) % MPPE_CCOUNT_SPACE;\r\n}\r\nstate->discard = 0;\r\nstate->ccount = ccount;\r\n}\r\n}\r\nif (flushed)\r\nmppe_rekey(state, 0);\r\n}\r\nobuf[0] = PPP_ADDRESS(ibuf);\r\nobuf[1] = PPP_CONTROL(ibuf);\r\nobuf += 2;\r\nibuf += PPP_HDRLEN + MPPE_OVHD;\r\nisize -= PPP_HDRLEN + MPPE_OVHD;\r\nsg_init_table(sg_in, 1);\r\nsg_init_table(sg_out, 1);\r\nsetup_sg(sg_in, ibuf, 1);\r\nsetup_sg(sg_out, obuf, 1);\r\nskcipher_request_set_tfm(req, state->arc4);\r\nskcipher_request_set_callback(req, 0, NULL, NULL);\r\nskcipher_request_set_crypt(req, sg_in, sg_out, 1, NULL);\r\nif (crypto_skcipher_decrypt(req)) {\r\nprintk(KERN_DEBUG "crypto_cypher_decrypt failed\n");\r\nosize = DECOMP_ERROR;\r\ngoto out_zap_req;\r\n}\r\nif ((obuf[0] & 0x01) != 0) {\r\nobuf[1] = obuf[0];\r\nobuf[0] = 0;\r\nobuf++;\r\nosize++;\r\n}\r\nsetup_sg(sg_in, ibuf + 1, isize - 1);\r\nsetup_sg(sg_out, obuf + 1, osize - 1);\r\nskcipher_request_set_crypt(req, sg_in, sg_out, isize - 1, NULL);\r\nif (crypto_skcipher_decrypt(req)) {\r\nprintk(KERN_DEBUG "crypto_cypher_decrypt failed\n");\r\nosize = DECOMP_ERROR;\r\ngoto out_zap_req;\r\n}\r\nstate->stats.unc_bytes += osize;\r\nstate->stats.unc_packets++;\r\nstate->stats.comp_bytes += isize;\r\nstate->stats.comp_packets++;\r\nstate->sanity_errors >>= 1;\r\nout_zap_req:\r\nskcipher_request_zero(req);\r\nreturn osize;\r\nsanity_error:\r\nif (state->sanity_errors < SANITY_MAX)\r\nreturn DECOMP_ERROR;\r\nelse\r\nreturn DECOMP_FATALERROR;\r\n}\r\nstatic void mppe_incomp(void *arg, unsigned char *ibuf, int icnt)\r\n{\r\nstruct ppp_mppe_state *state = (struct ppp_mppe_state *) arg;\r\nif (state->debug &&\r\n(PPP_PROTOCOL(ibuf) >= 0x0021 && PPP_PROTOCOL(ibuf) <= 0x00fa))\r\nprintk(KERN_DEBUG\r\n"mppe_incomp[%d]: incompressible (unencrypted) data! "\r\n"(proto %04x)\n", state->unit, PPP_PROTOCOL(ibuf));\r\nstate->stats.inc_bytes += icnt;\r\nstate->stats.inc_packets++;\r\nstate->stats.unc_bytes += icnt;\r\nstate->stats.unc_packets++;\r\n}\r\nstatic int __init ppp_mppe_init(void)\r\n{\r\nint answer;\r\nif (!(crypto_has_skcipher("ecb(arc4)", 0, CRYPTO_ALG_ASYNC) &&\r\ncrypto_has_ahash("sha1", 0, CRYPTO_ALG_ASYNC)))\r\nreturn -ENODEV;\r\nsha_pad = kmalloc(sizeof(struct sha_pad), GFP_KERNEL);\r\nif (!sha_pad)\r\nreturn -ENOMEM;\r\nsha_pad_init(sha_pad);\r\nanswer = ppp_register_compressor(&ppp_mppe);\r\nif (answer == 0)\r\nprintk(KERN_INFO "PPP MPPE Compression module registered\n");\r\nelse\r\nkfree(sha_pad);\r\nreturn answer;\r\n}\r\nstatic void __exit ppp_mppe_cleanup(void)\r\n{\r\nppp_unregister_compressor(&ppp_mppe);\r\nkfree(sha_pad);\r\n}
