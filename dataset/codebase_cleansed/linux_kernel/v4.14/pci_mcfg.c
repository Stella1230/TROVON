static int pci_mcfg_quirk_matches(struct mcfg_fixup *f, u16 segment,\r\nstruct resource *bus_range)\r\n{\r\nif (!memcmp(f->oem_id, mcfg_oem_id, ACPI_OEM_ID_SIZE) &&\r\n!memcmp(f->oem_table_id, mcfg_oem_table_id,\r\nACPI_OEM_TABLE_ID_SIZE) &&\r\nf->oem_revision == mcfg_oem_revision &&\r\nf->segment == segment &&\r\nresource_contains(&f->bus_range, bus_range))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void pci_mcfg_apply_quirks(struct acpi_pci_root *root,\r\nstruct resource *cfgres,\r\nstruct pci_ecam_ops **ecam_ops)\r\n{\r\n#ifdef CONFIG_PCI_QUIRKS\r\nu16 segment = root->segment;\r\nstruct resource *bus_range = &root->secondary;\r\nstruct mcfg_fixup *f;\r\nint i;\r\nfor (i = 0, f = mcfg_quirks; i < ARRAY_SIZE(mcfg_quirks); i++, f++) {\r\nif (pci_mcfg_quirk_matches(f, segment, bus_range)) {\r\nif (f->cfgres.start)\r\n*cfgres = f->cfgres;\r\nif (f->ops)\r\n*ecam_ops = f->ops;\r\ndev_info(&root->device->dev, "MCFG quirk: ECAM at %pR for %pR with %ps\n",\r\ncfgres, bus_range, *ecam_ops);\r\nreturn;\r\n}\r\n}\r\n#endif\r\n}\r\nint pci_mcfg_lookup(struct acpi_pci_root *root, struct resource *cfgres,\r\nstruct pci_ecam_ops **ecam_ops)\r\n{\r\nstruct pci_ecam_ops *ops = &pci_generic_ecam_ops;\r\nstruct resource *bus_res = &root->secondary;\r\nu16 seg = root->segment;\r\nstruct mcfg_entry *e;\r\nstruct resource res;\r\nif (root->mcfg_addr)\r\ngoto skip_lookup;\r\nlist_for_each_entry(e, &pci_mcfg_list, list) {\r\nif (e->segment == seg && e->bus_start <= bus_res->start &&\r\ne->bus_end >= bus_res->end) {\r\nroot->mcfg_addr = e->addr;\r\n}\r\n}\r\nskip_lookup:\r\nmemset(&res, 0, sizeof(res));\r\nif (root->mcfg_addr) {\r\nres.start = root->mcfg_addr + (bus_res->start << 20);\r\nres.end = res.start + (resource_size(bus_res) << 20) - 1;\r\nres.flags = IORESOURCE_MEM;\r\n}\r\npci_mcfg_apply_quirks(root, &res, &ops);\r\nif (!res.start)\r\nreturn -ENXIO;\r\n*cfgres = res;\r\n*ecam_ops = ops;\r\nreturn 0;\r\n}\r\nstatic __init int pci_mcfg_parse(struct acpi_table_header *header)\r\n{\r\nstruct acpi_table_mcfg *mcfg;\r\nstruct acpi_mcfg_allocation *mptr;\r\nstruct mcfg_entry *e, *arr;\r\nint i, n;\r\nif (header->length < sizeof(struct acpi_table_mcfg))\r\nreturn -EINVAL;\r\nn = (header->length - sizeof(struct acpi_table_mcfg)) /\r\nsizeof(struct acpi_mcfg_allocation);\r\nmcfg = (struct acpi_table_mcfg *)header;\r\nmptr = (struct acpi_mcfg_allocation *) &mcfg[1];\r\narr = kcalloc(n, sizeof(*arr), GFP_KERNEL);\r\nif (!arr)\r\nreturn -ENOMEM;\r\nfor (i = 0, e = arr; i < n; i++, mptr++, e++) {\r\ne->segment = mptr->pci_segment;\r\ne->addr = mptr->address;\r\ne->bus_start = mptr->start_bus_number;\r\ne->bus_end = mptr->end_bus_number;\r\nlist_add(&e->list, &pci_mcfg_list);\r\n}\r\n#ifdef CONFIG_PCI_QUIRKS\r\nmemcpy(mcfg_oem_id, header->oem_id, ACPI_OEM_ID_SIZE);\r\nmemcpy(mcfg_oem_table_id, header->oem_table_id, ACPI_OEM_TABLE_ID_SIZE);\r\nmcfg_oem_revision = header->oem_revision;\r\n#endif\r\npr_info("MCFG table detected, %d entries\n", n);\r\nreturn 0;\r\n}\r\nvoid __init pci_mmcfg_late_init(void)\r\n{\r\nint err = acpi_table_parse(ACPI_SIG_MCFG, pci_mcfg_parse);\r\nif (err)\r\npr_err("Failed to parse MCFG (%d)\n", err);\r\n}
