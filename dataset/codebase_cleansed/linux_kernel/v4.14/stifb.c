static void\r\nSETUP_HW(struct stifb_info *fb)\r\n{\r\nchar stat;\r\ndo {\r\nstat = READ_BYTE(fb, REG_15b0);\r\nif (!stat)\r\nstat = READ_BYTE(fb, REG_15b0);\r\n} while (stat);\r\n}\r\nstatic void\r\nSETUP_FB(struct stifb_info *fb)\r\n{\r\nunsigned int reg10_value = 0;\r\nSETUP_HW(fb);\r\nswitch (fb->id)\r\n{\r\ncase CRT_ID_VISUALIZE_EG:\r\ncase S9000_ID_ARTIST:\r\ncase S9000_ID_A1659A:\r\nreg10_value = 0x13601000;\r\nbreak;\r\ncase S9000_ID_A1439A:\r\nif (fb->info.var.bits_per_pixel == 32)\r\nreg10_value = 0xBBA0A000;\r\nelse\r\nreg10_value = 0x13601000;\r\nbreak;\r\ncase S9000_ID_HCRX:\r\nif (fb->info.var.bits_per_pixel == 32)\r\nreg10_value = 0xBBA0A000;\r\nelse\r\nreg10_value = 0x13602000;\r\nbreak;\r\ncase S9000_ID_TIMBER:\r\ncase CRX24_OVERLAY_PLANES:\r\nreg10_value = 0x13602000;\r\nbreak;\r\n}\r\nif (reg10_value)\r\nWRITE_WORD(reg10_value, fb, REG_10);\r\nWRITE_WORD(0x83000300, fb, REG_14);\r\nSETUP_HW(fb);\r\nWRITE_BYTE(1, fb, REG_16b1);\r\n}\r\nstatic void\r\nSTART_IMAGE_COLORMAP_ACCESS(struct stifb_info *fb)\r\n{\r\nSETUP_HW(fb);\r\nWRITE_WORD(0xBBE0F000, fb, REG_10);\r\nWRITE_WORD(0x03000300, fb, REG_14);\r\nWRITE_WORD(~0, fb, REG_13);\r\n}\r\nstatic void\r\nWRITE_IMAGE_COLOR(struct stifb_info *fb, int index, int color)\r\n{\r\nSETUP_HW(fb);\r\nWRITE_WORD(((0x100+index)<<2), fb, REG_3);\r\nWRITE_WORD(color, fb, REG_4);\r\n}\r\nstatic void\r\nFINISH_IMAGE_COLORMAP_ACCESS(struct stifb_info *fb)\r\n{\r\nWRITE_WORD(0x400, fb, REG_2);\r\nif (fb->info.var.bits_per_pixel == 32) {\r\nWRITE_WORD(0x83000100, fb, REG_1);\r\n} else {\r\nif (fb->id == S9000_ID_ARTIST || fb->id == CRT_ID_VISUALIZE_EG)\r\nWRITE_WORD(0x80000100, fb, REG_26);\r\nelse\r\nWRITE_WORD(0x80000100, fb, REG_1);\r\n}\r\nSETUP_FB(fb);\r\n}\r\nstatic void\r\nSETUP_RAMDAC(struct stifb_info *fb)\r\n{\r\nSETUP_HW(fb);\r\nWRITE_WORD(0x04000000, fb, 0x1020);\r\nWRITE_WORD(0xff000000, fb, 0x1028);\r\n}\r\nstatic void\r\nCRX24_SETUP_RAMDAC(struct stifb_info *fb)\r\n{\r\nSETUP_HW(fb);\r\nWRITE_WORD(0x04000000, fb, 0x1000);\r\nWRITE_WORD(0x02000000, fb, 0x1004);\r\nWRITE_WORD(0xff000000, fb, 0x1008);\r\nWRITE_WORD(0x05000000, fb, 0x1000);\r\nWRITE_WORD(0x02000000, fb, 0x1004);\r\nWRITE_WORD(0x03000000, fb, 0x1008);\r\n}\r\nstatic void\r\nCRX24_SET_OVLY_MASK(struct stifb_info *fb)\r\n{\r\nSETUP_HW(fb);\r\nWRITE_WORD(0x13a02000, fb, REG_11);\r\nWRITE_WORD(0x03000300, fb, REG_14);\r\nWRITE_WORD(0x000017f0, fb, REG_3);\r\nWRITE_WORD(0xffffffff, fb, REG_13);\r\nWRITE_WORD(0xffffffff, fb, REG_22);\r\nWRITE_WORD(0x00000000, fb, REG_23);\r\n}\r\nstatic void\r\nENABLE_DISABLE_DISPLAY(struct stifb_info *fb, int enable)\r\n{\r\nunsigned int value = enable ? 0x43000000 : 0x03000000;\r\nSETUP_HW(fb);\r\nWRITE_WORD(0x06000000, fb, 0x1030);\r\nWRITE_WORD(value, fb, 0x1038);\r\n}\r\nstatic void\r\nCRX24_ENABLE_DISABLE_DISPLAY(struct stifb_info *fb, int enable)\r\n{\r\nunsigned int value = enable ? 0x10000000 : 0x30000000;\r\nSETUP_HW(fb);\r\nWRITE_WORD(0x01000000, fb, 0x1000);\r\nWRITE_WORD(0x02000000, fb, 0x1004);\r\nWRITE_WORD(value, fb, 0x1008);\r\n}\r\nstatic void\r\nARTIST_ENABLE_DISABLE_DISPLAY(struct stifb_info *fb, int enable)\r\n{\r\nu32 DregsMiscVideo = REG_21;\r\nu32 DregsMiscCtl = REG_27;\r\nSETUP_HW(fb);\r\nif (enable) {\r\nWRITE_WORD(READ_WORD(fb, DregsMiscVideo) | 0x0A000000, fb, DregsMiscVideo);\r\nWRITE_WORD(READ_WORD(fb, DregsMiscCtl) | 0x00800000, fb, DregsMiscCtl);\r\n} else {\r\nWRITE_WORD(READ_WORD(fb, DregsMiscVideo) & ~0x0A000000, fb, DregsMiscVideo);\r\nWRITE_WORD(READ_WORD(fb, DregsMiscCtl) & ~0x00800000, fb, DregsMiscCtl);\r\n}\r\n}\r\nstatic void\r\nHYPER_ENABLE_DISABLE_DISPLAY(struct stifb_info *fb, int enable)\r\n{\r\nu32 DregsHypMiscVideo = REG_33;\r\nunsigned int value;\r\nSETUP_HW(fb);\r\nvalue = READ_WORD(fb, DregsHypMiscVideo);\r\nif (enable)\r\nvalue |= 0x0A000000;\r\nelse\r\nvalue &= ~0x0A000000;\r\nWRITE_WORD(value, fb, DregsHypMiscVideo);\r\n}\r\nstatic void\r\nSETUP_ATTR_ACCESS(struct stifb_info *fb, unsigned BufferNumber)\r\n{\r\nSETUP_HW(fb);\r\nWRITE_WORD(0x2EA0D000, fb, REG_11);\r\nWRITE_WORD(0x23000302, fb, REG_14);\r\nWRITE_WORD(BufferNumber, fb, REG_12);\r\nWRITE_WORD(0xffffffff, fb, REG_8);\r\n}\r\nstatic void\r\nSET_ATTR_SIZE(struct stifb_info *fb, int width, int height)\r\n{\r\nWRITE_WORD(0x00000000, fb, REG_6);\r\nWRITE_WORD((width<<16) | height, fb, REG_9);\r\nWRITE_WORD(0x05000000, fb, REG_6);\r\nWRITE_WORD(0x00040001, fb, REG_9);\r\n}\r\nstatic void\r\nFINISH_ATTR_ACCESS(struct stifb_info *fb)\r\n{\r\nSETUP_HW(fb);\r\nWRITE_WORD(0x00000000, fb, REG_12);\r\n}\r\nstatic void\r\nelkSetupPlanes(struct stifb_info *fb)\r\n{\r\nSETUP_RAMDAC(fb);\r\nSETUP_FB(fb);\r\n}\r\nstatic void\r\nngleSetupAttrPlanes(struct stifb_info *fb, int BufferNumber)\r\n{\r\nSETUP_ATTR_ACCESS(fb, BufferNumber);\r\nSET_ATTR_SIZE(fb, fb->info.var.xres, fb->info.var.yres);\r\nFINISH_ATTR_ACCESS(fb);\r\nSETUP_FB(fb);\r\n}\r\nstatic void\r\nrattlerSetupPlanes(struct stifb_info *fb)\r\n{\r\nint saved_id, y;\r\nCRX24_SETUP_RAMDAC(fb);\r\nsaved_id = fb->id;\r\nfb->id = CRX24_OVERLAY_PLANES;\r\nSETUP_FB(fb);\r\nfb->id = saved_id;\r\nfor (y = 0; y < fb->info.var.yres; ++y)\r\nmemset(fb->info.screen_base + y * fb->info.fix.line_length,\r\n0xff, fb->info.var.xres * fb->info.var.bits_per_pixel/8);\r\nCRX24_SET_OVLY_MASK(fb);\r\nSETUP_FB(fb);\r\n}\r\nstatic NgleLutBltCtl\r\nsetHyperLutBltCtl(struct stifb_info *fb, int offsetWithinLut, int length)\r\n{\r\nNgleLutBltCtl lutBltCtl;\r\nlutBltCtl.all = 0x80000000;\r\nlutBltCtl.fields.length = length;\r\nlutBltCtl.fields.lutType = HYPER_CMAP_TYPE;\r\nif (fb->info.var.bits_per_pixel == 8)\r\nlutBltCtl.fields.lutOffset = 2 * 256;\r\nelse\r\nlutBltCtl.fields.lutOffset = 0 * 256;\r\nlutBltCtl.fields.lutOffset += offsetWithinLut;\r\nreturn lutBltCtl;\r\n}\r\nstatic void hyperUndoITE(struct stifb_info *fb)\r\n{\r\nint nFreeFifoSlots = 0;\r\nu32 fbAddr;\r\nNGLE_LOCK(fb);\r\nGET_FIFO_SLOTS(fb, nFreeFifoSlots, 1);\r\nWRITE_WORD(0xffffffff, fb, REG_32);\r\nGET_FIFO_SLOTS(fb, nFreeFifoSlots, 7);\r\nNGLE_QUICK_SET_DST_BM_ACCESS(fb,\r\nBA(IndexedDcd, Otc04, Ots08, AddrLong,\r\nBAJustPoint(0), BINovly, BAIndexBase(0)));\r\nNGLE_QUICK_SET_IMAGE_BITMAP_OP(fb,\r\nIBOvals(RopSrc, MaskAddrOffset(0),\r\nBitmapExtent08, StaticReg(0),\r\nDataDynamic, MaskOtc, BGx(0), FGx(0)));\r\nfbAddr = NGLE_LONG_FB_ADDRESS(0, 1532, 0);\r\nNGLE_BINC_SET_DSTADDR(fb, fbAddr);\r\nNGLE_REALLY_SET_IMAGE_PLANEMASK(fb, 0xffffff);\r\nNGLE_BINC_SET_DSTMASK(fb, 0xffffffff);\r\nNGLE_BINC_WRITE32(fb, 0);\r\nNGLE_UNLOCK(fb);\r\n}\r\nstatic void\r\nngleDepth8_ClearImagePlanes(struct stifb_info *fb)\r\n{\r\n}\r\nstatic void\r\nngleDepth24_ClearImagePlanes(struct stifb_info *fb)\r\n{\r\n}\r\nstatic void\r\nngleResetAttrPlanes(struct stifb_info *fb, unsigned int ctlPlaneReg)\r\n{\r\nint nFreeFifoSlots = 0;\r\nu32 packed_dst;\r\nu32 packed_len;\r\nNGLE_LOCK(fb);\r\nGET_FIFO_SLOTS(fb, nFreeFifoSlots, 4);\r\nNGLE_QUICK_SET_DST_BM_ACCESS(fb,\r\nBA(IndexedDcd, Otc32, OtsIndirect,\r\nAddrLong, BAJustPoint(0),\r\nBINattr, BAIndexBase(0)));\r\nNGLE_QUICK_SET_CTL_PLN_REG(fb, ctlPlaneReg);\r\nNGLE_SET_TRANSFERDATA(fb, 0xffffffff);\r\nNGLE_QUICK_SET_IMAGE_BITMAP_OP(fb,\r\nIBOvals(RopSrc, MaskAddrOffset(0),\r\nBitmapExtent08, StaticReg(1),\r\nDataDynamic, MaskOtc,\r\nBGx(0), FGx(0)));\r\npacked_dst = 0;\r\npacked_len = (fb->info.var.xres << 16) | fb->info.var.yres;\r\nGET_FIFO_SLOTS(fb, nFreeFifoSlots, 2);\r\nNGLE_SET_DSTXY(fb, packed_dst);\r\nSET_LENXY_START_RECFILL(fb, packed_len);\r\nif (fb->id == S9000_ID_A1659A) {\r\npacked_dst = (1280 << 16);\r\nGET_FIFO_SLOTS(fb, nFreeFifoSlots, 2);\r\nNGLE_SET_DSTXY(fb, packed_dst);\r\npacked_len = (4 << 16) | 1;\r\nSET_LENXY_START_RECFILL(fb, packed_len);\r\n}\r\nGET_FIFO_SLOTS(fb, nFreeFifoSlots, 1);\r\nNGLE_QUICK_SET_CTL_PLN_REG(fb, 0);\r\nNGLE_UNLOCK(fb);\r\n}\r\nstatic void\r\nngleClearOverlayPlanes(struct stifb_info *fb, int mask, int data)\r\n{\r\nint nFreeFifoSlots = 0;\r\nu32 packed_dst;\r\nu32 packed_len;\r\nNGLE_LOCK(fb);\r\nGET_FIFO_SLOTS(fb, nFreeFifoSlots, 8);\r\nNGLE_QUICK_SET_DST_BM_ACCESS(fb,\r\nBA(IndexedDcd, Otc04, Ots08, AddrLong,\r\nBAJustPoint(0), BINovly, BAIndexBase(0)));\r\nNGLE_SET_TRANSFERDATA(fb, 0xffffffff);\r\nNGLE_REALLY_SET_IMAGE_FG_COLOR(fb, data);\r\nNGLE_REALLY_SET_IMAGE_PLANEMASK(fb, mask);\r\npacked_dst = 0;\r\npacked_len = (fb->info.var.xres << 16) | fb->info.var.yres;\r\nNGLE_SET_DSTXY(fb, packed_dst);\r\nNGLE_QUICK_SET_IMAGE_BITMAP_OP(fb,\r\nIBOvals(RopSrc, MaskAddrOffset(0),\r\nBitmapExtent08, StaticReg(0),\r\nDataDynamic, MaskOtc, BGx(0), FGx(0)));\r\nSET_LENXY_START_RECFILL(fb, packed_len);\r\nNGLE_UNLOCK(fb);\r\n}\r\nstatic void\r\nhyperResetPlanes(struct stifb_info *fb, int enable)\r\n{\r\nunsigned int controlPlaneReg;\r\nNGLE_LOCK(fb);\r\nif (IS_24_DEVICE(fb))\r\nif (fb->info.var.bits_per_pixel == 32)\r\ncontrolPlaneReg = 0x04000F00;\r\nelse\r\ncontrolPlaneReg = 0x00000F00;\r\nelse\r\ncontrolPlaneReg = 0x00000F00;\r\nswitch (enable) {\r\ncase ENABLE:\r\nif (IS_24_DEVICE(fb))\r\nngleDepth24_ClearImagePlanes(fb);\r\nelse\r\nngleDepth8_ClearImagePlanes(fb);\r\nngleResetAttrPlanes(fb, controlPlaneReg);\r\nngleClearOverlayPlanes(fb, 0xff, 255);\r\nhyperUndoITE(fb);\r\nbreak;\r\ncase DISABLE:\r\nif (IS_24_DEVICE(fb))\r\nngleDepth24_ClearImagePlanes(fb);\r\nelse\r\nngleDepth8_ClearImagePlanes(fb);\r\nngleResetAttrPlanes(fb, controlPlaneReg);\r\nngleClearOverlayPlanes(fb, 0xff, 0);\r\nbreak;\r\ncase -1:\r\nhyperUndoITE(fb);\r\nngleResetAttrPlanes(fb, controlPlaneReg);\r\nbreak;\r\n}\r\nNGLE_UNLOCK(fb);\r\n}\r\nstatic void\r\nngleGetDeviceRomData(struct stifb_info *fb)\r\n{\r\n#if 0\r\nXXX: FIXME: !!!\r\nint *pBytePerLongDevDepData;\r\nint *pRomTable;\r\nNgleDevRomData *pPackedDevRomData;\r\nint sizePackedDevRomData = sizeof(*pPackedDevRomData);\r\nchar *pCard8;\r\nint i;\r\nchar *mapOrigin = NULL;\r\nint romTableIdx;\r\npPackedDevRomData = fb->ngle_rom;\r\nSETUP_HW(fb);\r\nif (fb->id == S9000_ID_ARTIST) {\r\npPackedDevRomData->cursor_pipeline_delay = 4;\r\npPackedDevRomData->video_interleaves = 4;\r\n} else {\r\npBytePerLongDevDepData = fb->sti->regions[NGLEDEVDEPROM_CRT_REGION];\r\nif (fb->id == S9000_ID_TOMCAT)\r\n{\r\nGET_ROMTABLE_INDEX(romTableIdx);\r\nwhile (romTableIdx > 0)\r\n{\r\npCard8 = (Card8 *) pPackedDevRomData;\r\npRomTable = pBytePerLongDevDepData;\r\nfor (i = 0; i < sizePackedDevRomData; i++)\r\n{\r\n*pCard8++ = (Card8) (*pRomTable++);\r\n}\r\npBytePerLongDevDepData = (Card32 *)\r\n((Card8 *) pBytePerLongDevDepData +\r\npPackedDevRomData->sizeof_ngle_data);\r\nromTableIdx--;\r\n}\r\n}\r\npCard8 = (Card8 *) pPackedDevRomData;\r\nfor (i = 0; i < sizePackedDevRomData; i++)\r\n{\r\n*pCard8++ = (Card8) (*pBytePerLongDevDepData++);\r\n}\r\n}\r\nSETUP_FB(fb);\r\n#endif\r\n}\r\nstatic void __init\r\nSETUP_HCRX(struct stifb_info *fb)\r\n{\r\nint hyperbowl;\r\nint nFreeFifoSlots = 0;\r\nif (fb->id != S9000_ID_HCRX)\r\nreturn;\r\nGET_FIFO_SLOTS(fb, nFreeFifoSlots, 7);\r\nif (IS_24_DEVICE(fb)) {\r\nhyperbowl = (fb->info.var.bits_per_pixel == 32) ?\r\nHYPERBOWL_MODE01_8_24_LUT0_TRANSPARENT_LUT1_OPAQUE :\r\nHYPERBOWL_MODE01_8_24_LUT0_OPAQUE_LUT1_OPAQUE;\r\nWRITE_WORD(hyperbowl, fb, REG_40);\r\nWRITE_WORD(hyperbowl, fb, REG_40);\r\nWRITE_WORD(HYPERBOWL_MODE2_8_24, fb, REG_39);\r\nWRITE_WORD(0x014c0148, fb, REG_42);\r\nWRITE_WORD(0x404c4048, fb, REG_43);\r\nWRITE_WORD(0x034c0348, fb, REG_44);\r\nWRITE_WORD(0x444c4448, fb, REG_45);\r\n} else {\r\nhyperbowl = HYPERBOWL_MODE_FOR_8_OVER_88_LUT0_NO_TRANSPARENCIES;\r\nWRITE_WORD(hyperbowl, fb, REG_40);\r\nWRITE_WORD(hyperbowl, fb, REG_40);\r\nWRITE_WORD(0x00000000, fb, REG_42);\r\nWRITE_WORD(0x00000000, fb, REG_43);\r\nWRITE_WORD(0x00000000, fb, REG_44);\r\nWRITE_WORD(0x444c4048, fb, REG_45);\r\n}\r\n}\r\nstatic int\r\nstifb_setcolreg(u_int regno, u_int red, u_int green,\r\nu_int blue, u_int transp, struct fb_info *info)\r\n{\r\nstruct stifb_info *fb = container_of(info, struct stifb_info, info);\r\nu32 color;\r\nif (regno >= NR_PALETTE)\r\nreturn 1;\r\nred >>= 8;\r\ngreen >>= 8;\r\nblue >>= 8;\r\nDEBUG_OFF();\r\nSTART_IMAGE_COLORMAP_ACCESS(fb);\r\nif (unlikely(fb->info.var.grayscale)) {\r\ncolor = ((red * 77) +\r\n(green * 151) +\r\n(blue * 28)) >> 8;\r\n} else {\r\ncolor = ((red << 16) |\r\n(green << 8) |\r\n(blue));\r\n}\r\nif (fb->info.fix.visual == FB_VISUAL_DIRECTCOLOR) {\r\nstruct fb_var_screeninfo *var = &fb->info.var;\r\nif (regno < 16)\r\n((u32 *)fb->info.pseudo_palette)[regno] =\r\nregno << var->red.offset |\r\nregno << var->green.offset |\r\nregno << var->blue.offset;\r\n}\r\nWRITE_IMAGE_COLOR(fb, regno, color);\r\nif (fb->id == S9000_ID_HCRX) {\r\nNgleLutBltCtl lutBltCtl;\r\nlutBltCtl = setHyperLutBltCtl(fb,\r\n0,\r\n256);\r\nNGLE_BINC_SET_SRCADDR(fb,\r\nNGLE_LONG_FB_ADDRESS(0, 0x100, 0));\r\nSTART_COLORMAPLOAD(fb, lutBltCtl.all);\r\nSETUP_FB(fb);\r\n} else {\r\nFINISH_IMAGE_COLORMAP_ACCESS(fb);\r\n}\r\nDEBUG_ON();\r\nreturn 0;\r\n}\r\nstatic int\r\nstifb_blank(int blank_mode, struct fb_info *info)\r\n{\r\nstruct stifb_info *fb = container_of(info, struct stifb_info, info);\r\nint enable = (blank_mode == 0) ? ENABLE : DISABLE;\r\nswitch (fb->id) {\r\ncase S9000_ID_A1439A:\r\nCRX24_ENABLE_DISABLE_DISPLAY(fb, enable);\r\nbreak;\r\ncase CRT_ID_VISUALIZE_EG:\r\ncase S9000_ID_ARTIST:\r\nARTIST_ENABLE_DISABLE_DISPLAY(fb, enable);\r\nbreak;\r\ncase S9000_ID_HCRX:\r\nHYPER_ENABLE_DISABLE_DISPLAY(fb, enable);\r\nbreak;\r\ncase S9000_ID_A1659A:\r\ncase S9000_ID_TIMBER:\r\ncase CRX24_OVERLAY_PLANES:\r\ndefault:\r\nENABLE_DISABLE_DISPLAY(fb, enable);\r\nbreak;\r\n}\r\nSETUP_FB(fb);\r\nreturn 0;\r\n}\r\nstatic void\r\nstifb_copyarea(struct fb_info *info, const struct fb_copyarea *area)\r\n{\r\nstruct stifb_info *fb = container_of(info, struct stifb_info, info);\r\nSETUP_COPYAREA(fb);\r\nSETUP_HW(fb);\r\nif (fb->info.var.bits_per_pixel == 32) {\r\nWRITE_WORD(0xBBA0A000, fb, REG_10);\r\nNGLE_REALLY_SET_IMAGE_PLANEMASK(fb, 0xffffffff);\r\n} else {\r\nWRITE_WORD(fb->id == S9000_ID_HCRX ? 0x13a02000 : 0x13a01000, fb, REG_10);\r\nNGLE_REALLY_SET_IMAGE_PLANEMASK(fb, 0xff);\r\n}\r\nNGLE_QUICK_SET_IMAGE_BITMAP_OP(fb,\r\nIBOvals(RopSrc, MaskAddrOffset(0),\r\nBitmapExtent08, StaticReg(1),\r\nDataDynamic, MaskOtc, BGx(0), FGx(0)));\r\nWRITE_WORD(((area->sx << 16) | area->sy), fb, REG_24);\r\nWRITE_WORD(((area->width << 16) | area->height), fb, REG_7);\r\nWRITE_WORD(((area->dx << 16) | area->dy), fb, REG_25);\r\nSETUP_FB(fb);\r\n}\r\nstatic void __init\r\nstifb_init_display(struct stifb_info *fb)\r\n{\r\nint id = fb->id;\r\nSETUP_FB(fb);\r\nSETUP_HCRX(fb);\r\nswitch (id) {\r\ncase S9000_ID_HCRX:\r\nhyperResetPlanes(fb, ENABLE);\r\nbreak;\r\ncase S9000_ID_A1439A:\r\nrattlerSetupPlanes(fb);\r\nbreak;\r\ncase S9000_ID_A1659A:\r\ncase S9000_ID_ARTIST:\r\ncase CRT_ID_VISUALIZE_EG:\r\nelkSetupPlanes(fb);\r\nbreak;\r\n}\r\nswitch (id) {\r\ncase S9000_ID_A1659A:\r\ncase S9000_ID_A1439A:\r\nif (fb->info.var.bits_per_pixel == 32)\r\nngleSetupAttrPlanes(fb, BUFF1_CMAP3);\r\nelse {\r\nngleSetupAttrPlanes(fb, BUFF1_CMAP0);\r\n}\r\nif (id == S9000_ID_A1439A)\r\nngleClearOverlayPlanes(fb, 0xff, 0);\r\nbreak;\r\ncase S9000_ID_ARTIST:\r\ncase CRT_ID_VISUALIZE_EG:\r\nif (fb->info.var.bits_per_pixel == 32)\r\nngleSetupAttrPlanes(fb, BUFF1_CMAP3);\r\nelse {\r\nngleSetupAttrPlanes(fb, ARTIST_CMAP0);\r\n}\r\nbreak;\r\n}\r\nstifb_blank(0, (struct fb_info *)fb);\r\nSETUP_FB(fb);\r\n}\r\nstatic int __init stifb_init_fb(struct sti_struct *sti, int bpp_pref)\r\n{\r\nstruct fb_fix_screeninfo *fix;\r\nstruct fb_var_screeninfo *var;\r\nstruct stifb_info *fb;\r\nstruct fb_info *info;\r\nunsigned long sti_rom_address;\r\nchar *dev_name;\r\nint bpp, xres, yres;\r\nfb = kzalloc(sizeof(*fb), GFP_ATOMIC);\r\nif (!fb) {\r\nprintk(KERN_ERR "stifb: Could not allocate stifb structure\n");\r\nreturn -ENODEV;\r\n}\r\ninfo = &fb->info;\r\nfix = &info->fix;\r\nvar = &info->var;\r\nfb->sti = sti;\r\ndev_name = sti->sti_data->inq_outptr.dev_name;\r\nfb->id = fb->sti->graphics_id[0];\r\nswitch (fb->id) {\r\ncase CRT_ID_VISUALIZE_EG:\r\nif (strstr(dev_name, "DX")) {\r\nprintk(KERN_WARNING\r\n"WARNING: stifb framebuffer driver does not support '%s' in double-buffer mode.\n"\r\n"WARNING: Please disable the double-buffer mode in IPL menu (the PARISC-BIOS).\n",\r\ndev_name);\r\ngoto out_err0;\r\n}\r\ncase S9000_ID_ARTIST:\r\ncase S9000_ID_HCRX:\r\ncase S9000_ID_TIMBER:\r\ncase S9000_ID_A1659A:\r\ncase S9000_ID_A1439A:\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "stifb: '%s' (id: 0x%08x) not supported.\n",\r\ndev_name, fb->id);\r\ngoto out_err0;\r\n}\r\nbpp = 8;\r\nxres = sti_onscreen_x(fb->sti);\r\nyres = sti_onscreen_y(fb->sti);\r\nngleGetDeviceRomData(fb);\r\nfix->mmio_start = REGION_BASE(fb,2);\r\nfix->mmio_len = 0x400000;\r\nswitch (fb->id) {\r\ncase S9000_ID_A1659A:\r\nbreak;\r\ncase S9000_ID_ELM:\r\nvar->grayscale = 1;\r\nfb->id = S9000_ID_A1659A;\r\nbreak;\r\ncase S9000_ID_TIMBER:\r\nif (strstr(dev_name, "GRAYSCALE") ||\r\nstrstr(dev_name, "Grayscale") ||\r\nstrstr(dev_name, "grayscale"))\r\nvar->grayscale = 1;\r\nbreak;\r\ncase S9000_ID_TOMCAT:\r\nxres = fb->ngle_rom.x_size_visible;\r\nyres = fb->ngle_rom.y_size_visible;\r\nfb->id = S9000_ID_A1659A;\r\nbreak;\r\ncase S9000_ID_A1439A:\r\nbpp = 32;\r\nbreak;\r\ncase S9000_ID_HCRX:\r\nmemset(&fb->ngle_rom, 0, sizeof(fb->ngle_rom));\r\nif ((fb->sti->regions_phys[0] & 0xfc000000) ==\r\n(fb->sti->regions_phys[2] & 0xfc000000))\r\nsti_rom_address = F_EXTEND(fb->sti->regions_phys[0]);\r\nelse\r\nsti_rom_address = F_EXTEND(fb->sti->regions_phys[1]);\r\nfb->deviceSpecificConfig = gsc_readl(sti_rom_address);\r\nif (IS_24_DEVICE(fb)) {\r\nif (bpp_pref == 8 || bpp_pref == 32)\r\nbpp = bpp_pref;\r\nelse\r\nbpp = 32;\r\n} else\r\nbpp = 8;\r\nREAD_WORD(fb, REG_15);\r\nSETUP_HW(fb);\r\nbreak;\r\ncase CRT_ID_VISUALIZE_EG:\r\ncase S9000_ID_ARTIST:\r\nbreak;\r\ndefault:\r\n#ifdef FALLBACK_TO_1BPP\r\nprintk(KERN_WARNING\r\n"stifb: Unsupported graphics card (id=0x%08x) "\r\n"- now trying 1bpp mode instead\n",\r\nfb->id);\r\nbpp = 1;\r\nbreak;\r\n#else\r\nprintk(KERN_WARNING\r\n"stifb: Unsupported graphics card (id=0x%08x) "\r\n"- skipping.\n",\r\nfb->id);\r\ngoto out_err0;\r\n#endif\r\n}\r\nfix->smem_start = F_EXTEND(fb->sti->regions_phys[1]);\r\nfix->smem_len = fb->sti->regions[1].region_desc.length * 4096;\r\nfix->line_length = (fb->sti->glob_cfg->total_x * bpp) / 8;\r\nif (!fix->line_length)\r\nfix->line_length = 2048;\r\nif (fix->smem_len > yres*fix->line_length)\r\nfix->smem_len = yres*fix->line_length;\r\nfix->accel = FB_ACCEL_NONE;\r\nswitch (bpp) {\r\ncase 1:\r\nfix->type = FB_TYPE_PLANES;\r\nfix->visual = FB_VISUAL_MONO10;\r\nvar->red.length = var->green.length = var->blue.length = 1;\r\nbreak;\r\ncase 8:\r\nfix->type = FB_TYPE_PACKED_PIXELS;\r\nfix->visual = FB_VISUAL_PSEUDOCOLOR;\r\nvar->red.length = var->green.length = var->blue.length = 8;\r\nbreak;\r\ncase 32:\r\nfix->type = FB_TYPE_PACKED_PIXELS;\r\nfix->visual = FB_VISUAL_DIRECTCOLOR;\r\nvar->red.length = var->green.length = var->blue.length = var->transp.length = 8;\r\nvar->blue.offset = 0;\r\nvar->green.offset = 8;\r\nvar->red.offset = 16;\r\nvar->transp.offset = 24;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nvar->xres = var->xres_virtual = xres;\r\nvar->yres = var->yres_virtual = yres;\r\nvar->bits_per_pixel = bpp;\r\nstrcpy(fix->id, "stifb");\r\ninfo->fbops = &stifb_ops;\r\ninfo->screen_base = ioremap_nocache(REGION_BASE(fb,1), fix->smem_len);\r\nif (!info->screen_base) {\r\nprintk(KERN_ERR "stifb: failed to map memory\n");\r\ngoto out_err0;\r\n}\r\ninfo->screen_size = fix->smem_len;\r\ninfo->flags = FBINFO_DEFAULT | FBINFO_HWACCEL_COPYAREA;\r\ninfo->pseudo_palette = &fb->pseudo_palette;\r\nif (fb_alloc_cmap(&info->cmap, NR_PALETTE, 0))\r\ngoto out_err1;\r\nstifb_init_display(fb);\r\nif (!request_mem_region(fix->smem_start, fix->smem_len, "stifb fb")) {\r\nprintk(KERN_ERR "stifb: cannot reserve fb region 0x%04lx-0x%04lx\n",\r\nfix->smem_start, fix->smem_start+fix->smem_len);\r\ngoto out_err2;\r\n}\r\nif (!request_mem_region(fix->mmio_start, fix->mmio_len, "stifb mmio")) {\r\nprintk(KERN_ERR "stifb: cannot reserve sti mmio region 0x%04lx-0x%04lx\n",\r\nfix->mmio_start, fix->mmio_start+fix->mmio_len);\r\ngoto out_err3;\r\n}\r\nif (register_framebuffer(&fb->info) < 0)\r\ngoto out_err4;\r\nsti->info = info;\r\nfb_info(&fb->info, "%s %dx%d-%d frame buffer device, %s, id: %04x, mmio: 0x%04lx\n",\r\nfix->id,\r\nvar->xres,\r\nvar->yres,\r\nvar->bits_per_pixel,\r\ndev_name,\r\nfb->id,\r\nfix->mmio_start);\r\nreturn 0;\r\nout_err4:\r\nrelease_mem_region(fix->mmio_start, fix->mmio_len);\r\nout_err3:\r\nrelease_mem_region(fix->smem_start, fix->smem_len);\r\nout_err2:\r\nfb_dealloc_cmap(&info->cmap);\r\nout_err1:\r\niounmap(info->screen_base);\r\nout_err0:\r\nkfree(fb);\r\nreturn -ENXIO;\r\n}\r\nstatic int __init stifb_init(void)\r\n{\r\nstruct sti_struct *sti;\r\nstruct sti_struct *def_sti;\r\nint i;\r\n#ifndef MODULE\r\nchar *option = NULL;\r\nif (fb_get_options("stifb", &option))\r\nreturn -ENODEV;\r\nstifb_setup(option);\r\n#endif\r\nif (stifb_disabled) {\r\nprintk(KERN_INFO "stifb: disabled by \"stifb=off\" kernel parameter\n");\r\nreturn -ENXIO;\r\n}\r\ndef_sti = sti_get_rom(0);\r\nif (def_sti) {\r\nfor (i = 1; i <= MAX_STI_ROMS; i++) {\r\nsti = sti_get_rom(i);\r\nif (!sti)\r\nbreak;\r\nif (sti == def_sti) {\r\nstifb_init_fb(sti, stifb_bpp_pref[i - 1]);\r\nbreak;\r\n}\r\n}\r\n}\r\nfor (i = 1; i <= MAX_STI_ROMS; i++) {\r\nsti = sti_get_rom(i);\r\nif (!sti)\r\nbreak;\r\nif (sti == def_sti)\r\ncontinue;\r\nstifb_init_fb(sti, stifb_bpp_pref[i - 1]);\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit\r\nstifb_cleanup(void)\r\n{\r\nstruct sti_struct *sti;\r\nint i;\r\nfor (i = 1; i <= MAX_STI_ROMS; i++) {\r\nsti = sti_get_rom(i);\r\nif (!sti)\r\nbreak;\r\nif (sti->info) {\r\nstruct fb_info *info = sti->info;\r\nunregister_framebuffer(sti->info);\r\nrelease_mem_region(info->fix.mmio_start, info->fix.mmio_len);\r\nrelease_mem_region(info->fix.smem_start, info->fix.smem_len);\r\nif (info->screen_base)\r\niounmap(info->screen_base);\r\nfb_dealloc_cmap(&info->cmap);\r\nframebuffer_release(info);\r\n}\r\nsti->info = NULL;\r\n}\r\n}\r\nint __init\r\nstifb_setup(char *options)\r\n{\r\nint i;\r\nif (!options || !*options)\r\nreturn 1;\r\nif (strncmp(options, "off", 3) == 0) {\r\nstifb_disabled = 1;\r\noptions += 3;\r\n}\r\nif (strncmp(options, "bpp", 3) == 0) {\r\noptions += 3;\r\nfor (i = 0; i < MAX_STI_ROMS; i++) {\r\nif (*options++ != ':')\r\nbreak;\r\nstifb_bpp_pref[i] = simple_strtoul(options, &options, 10);\r\n}\r\n}\r\nreturn 1;\r\n}
