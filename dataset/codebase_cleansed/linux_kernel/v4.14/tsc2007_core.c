int tsc2007_xfer(struct tsc2007 *tsc, u8 cmd)\r\n{\r\ns32 data;\r\nu16 val;\r\ndata = i2c_smbus_read_word_data(tsc->client, cmd);\r\nif (data < 0) {\r\ndev_err(&tsc->client->dev, "i2c io error: %d\n", data);\r\nreturn data;\r\n}\r\nval = swab16(data) >> 4;\r\ndev_dbg(&tsc->client->dev, "data: 0x%x, val: 0x%x\n", data, val);\r\nreturn val;\r\n}\r\nstatic void tsc2007_read_values(struct tsc2007 *tsc, struct ts_event *tc)\r\n{\r\ntc->y = tsc2007_xfer(tsc, READ_Y);\r\ntc->x = tsc2007_xfer(tsc, READ_X);\r\ntc->z1 = tsc2007_xfer(tsc, READ_Z1);\r\ntc->z2 = tsc2007_xfer(tsc, READ_Z2);\r\ntsc2007_xfer(tsc, PWRDOWN);\r\n}\r\nu32 tsc2007_calculate_resistance(struct tsc2007 *tsc, struct ts_event *tc)\r\n{\r\nu32 rt = 0;\r\nif (tc->x == MAX_12BIT)\r\ntc->x = 0;\r\nif (likely(tc->x && tc->z1)) {\r\nrt = tc->z2 - tc->z1;\r\nrt *= tc->x;\r\nrt *= tsc->x_plate_ohms;\r\nrt /= tc->z1;\r\nrt = (rt + 2047) >> 12;\r\n}\r\nreturn rt;\r\n}\r\nbool tsc2007_is_pen_down(struct tsc2007 *ts)\r\n{\r\nif (!ts->get_pendown_state)\r\nreturn true;\r\nreturn ts->get_pendown_state(&ts->client->dev);\r\n}\r\nstatic irqreturn_t tsc2007_soft_irq(int irq, void *handle)\r\n{\r\nstruct tsc2007 *ts = handle;\r\nstruct input_dev *input = ts->input;\r\nstruct ts_event tc;\r\nu32 rt;\r\nwhile (!ts->stopped && tsc2007_is_pen_down(ts)) {\r\nmutex_lock(&ts->mlock);\r\ntsc2007_read_values(ts, &tc);\r\nmutex_unlock(&ts->mlock);\r\nrt = tsc2007_calculate_resistance(ts, &tc);\r\nif (!rt && !ts->get_pendown_state) {\r\nbreak;\r\n}\r\nif (rt <= ts->max_rt) {\r\ndev_dbg(&ts->client->dev,\r\n"DOWN point(%4d,%4d), resistance (%4u)\n",\r\ntc.x, tc.y, rt);\r\nrt = ts->max_rt - rt;\r\ninput_report_key(input, BTN_TOUCH, 1);\r\ninput_report_abs(input, ABS_X, tc.x);\r\ninput_report_abs(input, ABS_Y, tc.y);\r\ninput_report_abs(input, ABS_PRESSURE, rt);\r\ninput_sync(input);\r\n} else {\r\ndev_dbg(&ts->client->dev, "ignored pressure %d\n", rt);\r\n}\r\nwait_event_timeout(ts->wait, ts->stopped, ts->poll_period);\r\n}\r\ndev_dbg(&ts->client->dev, "UP\n");\r\ninput_report_key(input, BTN_TOUCH, 0);\r\ninput_report_abs(input, ABS_PRESSURE, 0);\r\ninput_sync(input);\r\nif (ts->clear_penirq)\r\nts->clear_penirq();\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t tsc2007_hard_irq(int irq, void *handle)\r\n{\r\nstruct tsc2007 *ts = handle;\r\nif (tsc2007_is_pen_down(ts))\r\nreturn IRQ_WAKE_THREAD;\r\nif (ts->clear_penirq)\r\nts->clear_penirq();\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void tsc2007_stop(struct tsc2007 *ts)\r\n{\r\nts->stopped = true;\r\nmb();\r\nwake_up(&ts->wait);\r\ndisable_irq(ts->irq);\r\n}\r\nstatic int tsc2007_open(struct input_dev *input_dev)\r\n{\r\nstruct tsc2007 *ts = input_get_drvdata(input_dev);\r\nint err;\r\nts->stopped = false;\r\nmb();\r\nenable_irq(ts->irq);\r\nerr = tsc2007_xfer(ts, PWRDOWN);\r\nif (err < 0) {\r\ntsc2007_stop(ts);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void tsc2007_close(struct input_dev *input_dev)\r\n{\r\nstruct tsc2007 *ts = input_get_drvdata(input_dev);\r\ntsc2007_stop(ts);\r\n}\r\nstatic int tsc2007_get_pendown_state_gpio(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct tsc2007 *ts = i2c_get_clientdata(client);\r\nreturn !gpio_get_value(ts->gpio);\r\n}\r\nstatic int tsc2007_probe_dt(struct i2c_client *client, struct tsc2007 *ts)\r\n{\r\nstruct device_node *np = client->dev.of_node;\r\nu32 val32;\r\nu64 val64;\r\nif (!np) {\r\ndev_err(&client->dev, "missing device tree data\n");\r\nreturn -EINVAL;\r\n}\r\nif (!of_property_read_u32(np, "ti,max-rt", &val32))\r\nts->max_rt = val32;\r\nelse\r\nts->max_rt = MAX_12BIT;\r\nif (!of_property_read_u32(np, "ti,fuzzx", &val32))\r\nts->fuzzx = val32;\r\nif (!of_property_read_u32(np, "ti,fuzzy", &val32))\r\nts->fuzzy = val32;\r\nif (!of_property_read_u32(np, "ti,fuzzz", &val32))\r\nts->fuzzz = val32;\r\nif (!of_property_read_u64(np, "ti,poll-period", &val64))\r\nts->poll_period = msecs_to_jiffies(val64);\r\nelse\r\nts->poll_period = msecs_to_jiffies(1);\r\nif (!of_property_read_u32(np, "ti,x-plate-ohms", &val32)) {\r\nts->x_plate_ohms = val32;\r\n} else {\r\ndev_err(&client->dev, "missing ti,x-plate-ohms devicetree property.");\r\nreturn -EINVAL;\r\n}\r\nts->gpio = of_get_gpio(np, 0);\r\nif (gpio_is_valid(ts->gpio))\r\nts->get_pendown_state = tsc2007_get_pendown_state_gpio;\r\nelse\r\ndev_warn(&client->dev,\r\n"GPIO not specified in DT (of_get_gpio returned %d)\n",\r\nts->gpio);\r\nreturn 0;\r\n}\r\nstatic int tsc2007_probe_dt(struct i2c_client *client, struct tsc2007 *ts)\r\n{\r\ndev_err(&client->dev, "platform data is required!\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int tsc2007_probe_pdev(struct i2c_client *client, struct tsc2007 *ts,\r\nconst struct tsc2007_platform_data *pdata,\r\nconst struct i2c_device_id *id)\r\n{\r\nts->model = pdata->model;\r\nts->x_plate_ohms = pdata->x_plate_ohms;\r\nts->max_rt = pdata->max_rt ? : MAX_12BIT;\r\nts->poll_period = msecs_to_jiffies(pdata->poll_period ? : 1);\r\nts->get_pendown_state = pdata->get_pendown_state;\r\nts->clear_penirq = pdata->clear_penirq;\r\nts->fuzzx = pdata->fuzzx;\r\nts->fuzzy = pdata->fuzzy;\r\nts->fuzzz = pdata->fuzzz;\r\nif (pdata->x_plate_ohms == 0) {\r\ndev_err(&client->dev, "x_plate_ohms is not set up in platform data");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void tsc2007_call_exit_platform_hw(void *data)\r\n{\r\nstruct device *dev = data;\r\nconst struct tsc2007_platform_data *pdata = dev_get_platdata(dev);\r\npdata->exit_platform_hw();\r\n}\r\nstatic int tsc2007_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nconst struct tsc2007_platform_data *pdata =\r\ndev_get_platdata(&client->dev);\r\nstruct tsc2007 *ts;\r\nstruct input_dev *input_dev;\r\nint err;\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_READ_WORD_DATA))\r\nreturn -EIO;\r\nts = devm_kzalloc(&client->dev, sizeof(struct tsc2007), GFP_KERNEL);\r\nif (!ts)\r\nreturn -ENOMEM;\r\nif (pdata)\r\nerr = tsc2007_probe_pdev(client, ts, pdata, id);\r\nelse\r\nerr = tsc2007_probe_dt(client, ts);\r\nif (err)\r\nreturn err;\r\ninput_dev = devm_input_allocate_device(&client->dev);\r\nif (!input_dev)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, ts);\r\nts->client = client;\r\nts->irq = client->irq;\r\nts->input = input_dev;\r\ninit_waitqueue_head(&ts->wait);\r\nmutex_init(&ts->mlock);\r\nsnprintf(ts->phys, sizeof(ts->phys),\r\n"%s/input0", dev_name(&client->dev));\r\ninput_dev->name = "TSC2007 Touchscreen";\r\ninput_dev->phys = ts->phys;\r\ninput_dev->id.bustype = BUS_I2C;\r\ninput_dev->open = tsc2007_open;\r\ninput_dev->close = tsc2007_close;\r\ninput_set_drvdata(input_dev, ts);\r\ninput_set_capability(input_dev, EV_KEY, BTN_TOUCH);\r\ninput_set_abs_params(input_dev, ABS_X, 0, MAX_12BIT, ts->fuzzx, 0);\r\ninput_set_abs_params(input_dev, ABS_Y, 0, MAX_12BIT, ts->fuzzy, 0);\r\ninput_set_abs_params(input_dev, ABS_PRESSURE, 0, MAX_12BIT,\r\nts->fuzzz, 0);\r\nif (pdata) {\r\nif (pdata->exit_platform_hw) {\r\nerr = devm_add_action(&client->dev,\r\ntsc2007_call_exit_platform_hw,\r\n&client->dev);\r\nif (err) {\r\ndev_err(&client->dev,\r\n"Failed to register exit_platform_hw action, %d\n",\r\nerr);\r\nreturn err;\r\n}\r\n}\r\nif (pdata->init_platform_hw)\r\npdata->init_platform_hw();\r\n}\r\nerr = devm_request_threaded_irq(&client->dev, ts->irq,\r\ntsc2007_hard_irq, tsc2007_soft_irq,\r\nIRQF_ONESHOT,\r\nclient->dev.driver->name, ts);\r\nif (err) {\r\ndev_err(&client->dev, "Failed to request irq %d: %d\n",\r\nts->irq, err);\r\nreturn err;\r\n}\r\ntsc2007_stop(ts);\r\nerr = tsc2007_xfer(ts, PWRDOWN);\r\nif (err < 0) {\r\ndev_err(&client->dev,\r\n"Failed to setup chip: %d\n", err);\r\nreturn err;\r\n}\r\nerr = input_register_device(input_dev);\r\nif (err) {\r\ndev_err(&client->dev,\r\n"Failed to register input device: %d\n", err);\r\nreturn err;\r\n}\r\nerr = tsc2007_iio_configure(ts);\r\nif (err) {\r\ndev_err(&client->dev,\r\n"Failed to register with IIO: %d\n", err);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}
