static int acpi_lid_evaluate_state(struct acpi_device *device)\r\n{\r\nunsigned long long lid_state;\r\nacpi_status status;\r\nstatus = acpi_evaluate_integer(device->handle, "_LID", NULL, &lid_state);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENODEV;\r\nreturn lid_state ? 1 : 0;\r\n}\r\nstatic int acpi_lid_notify_state(struct acpi_device *device, int state)\r\n{\r\nstruct acpi_button *button = acpi_driver_data(device);\r\nint ret;\r\nktime_t next_report;\r\nbool do_update;\r\nif (lid_init_state != ACPI_BUTTON_LID_INIT_IGNORE ||\r\nbutton->last_state != !!state)\r\ndo_update = true;\r\nelse\r\ndo_update = false;\r\nnext_report = ktime_add(button->last_time,\r\nms_to_ktime(lid_report_interval));\r\nif (button->last_state == !!state &&\r\nktime_after(ktime_get(), next_report)) {\r\npr_warn_once("The lid device is not compliant to SW_LID.\n");\r\nif (lid_init_state == ACPI_BUTTON_LID_INIT_IGNORE) {\r\ndo_update = true;\r\nif (!state) {\r\ninput_report_switch(button->input,\r\nSW_LID, state);\r\ninput_sync(button->input);\r\n}\r\n}\r\n}\r\nif (do_update) {\r\ninput_report_switch(button->input, SW_LID, !state);\r\ninput_sync(button->input);\r\nbutton->last_state = !!state;\r\nbutton->last_time = ktime_get();\r\n}\r\nif (state)\r\nacpi_pm_wakeup_event(&device->dev);\r\nret = blocking_notifier_call_chain(&acpi_lid_notifier, state, device);\r\nif (ret == NOTIFY_DONE)\r\nret = blocking_notifier_call_chain(&acpi_lid_notifier, state,\r\ndevice);\r\nif (ret == NOTIFY_DONE || ret == NOTIFY_OK) {\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int acpi_button_state_seq_show(struct seq_file *seq, void *offset)\r\n{\r\nstruct acpi_device *device = seq->private;\r\nint state;\r\nstate = acpi_lid_evaluate_state(device);\r\nseq_printf(seq, "state: %s\n",\r\nstate < 0 ? "unsupported" : (state ? "open" : "closed"));\r\nreturn 0;\r\n}\r\nstatic int acpi_button_state_open_fs(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, acpi_button_state_seq_show, PDE_DATA(inode));\r\n}\r\nstatic int acpi_button_add_fs(struct acpi_device *device)\r\n{\r\nstruct acpi_button *button = acpi_driver_data(device);\r\nstruct proc_dir_entry *entry = NULL;\r\nint ret = 0;\r\nif (button->type != ACPI_BUTTON_TYPE_LID)\r\nreturn 0;\r\nif (acpi_button_dir || acpi_lid_dir) {\r\nprintk(KERN_ERR PREFIX "More than one Lid device found!\n");\r\nreturn -EEXIST;\r\n}\r\nacpi_button_dir = proc_mkdir(ACPI_BUTTON_CLASS, acpi_root_dir);\r\nif (!acpi_button_dir)\r\nreturn -ENODEV;\r\nacpi_lid_dir = proc_mkdir(ACPI_BUTTON_SUBCLASS_LID, acpi_button_dir);\r\nif (!acpi_lid_dir) {\r\nret = -ENODEV;\r\ngoto remove_button_dir;\r\n}\r\nacpi_device_dir(device) = proc_mkdir(acpi_device_bid(device), acpi_lid_dir);\r\nif (!acpi_device_dir(device)) {\r\nret = -ENODEV;\r\ngoto remove_lid_dir;\r\n}\r\nentry = proc_create_data(ACPI_BUTTON_FILE_STATE,\r\nS_IRUGO, acpi_device_dir(device),\r\n&acpi_button_state_fops, device);\r\nif (!entry) {\r\nret = -ENODEV;\r\ngoto remove_dev_dir;\r\n}\r\ndone:\r\nreturn ret;\r\nremove_dev_dir:\r\nremove_proc_entry(acpi_device_bid(device),\r\nacpi_lid_dir);\r\nacpi_device_dir(device) = NULL;\r\nremove_lid_dir:\r\nremove_proc_entry(ACPI_BUTTON_SUBCLASS_LID, acpi_button_dir);\r\nacpi_lid_dir = NULL;\r\nremove_button_dir:\r\nremove_proc_entry(ACPI_BUTTON_CLASS, acpi_root_dir);\r\nacpi_button_dir = NULL;\r\ngoto done;\r\n}\r\nstatic int acpi_button_remove_fs(struct acpi_device *device)\r\n{\r\nstruct acpi_button *button = acpi_driver_data(device);\r\nif (button->type != ACPI_BUTTON_TYPE_LID)\r\nreturn 0;\r\nremove_proc_entry(ACPI_BUTTON_FILE_STATE,\r\nacpi_device_dir(device));\r\nremove_proc_entry(acpi_device_bid(device),\r\nacpi_lid_dir);\r\nacpi_device_dir(device) = NULL;\r\nremove_proc_entry(ACPI_BUTTON_SUBCLASS_LID, acpi_button_dir);\r\nacpi_lid_dir = NULL;\r\nremove_proc_entry(ACPI_BUTTON_CLASS, acpi_root_dir);\r\nacpi_button_dir = NULL;\r\nreturn 0;\r\n}\r\nint acpi_lid_notifier_register(struct notifier_block *nb)\r\n{\r\nreturn blocking_notifier_chain_register(&acpi_lid_notifier, nb);\r\n}\r\nint acpi_lid_notifier_unregister(struct notifier_block *nb)\r\n{\r\nreturn blocking_notifier_chain_unregister(&acpi_lid_notifier, nb);\r\n}\r\nint acpi_lid_open(void)\r\n{\r\nif (!lid_device)\r\nreturn -ENODEV;\r\nreturn acpi_lid_evaluate_state(lid_device);\r\n}\r\nstatic int acpi_lid_update_state(struct acpi_device *device)\r\n{\r\nint state;\r\nstate = acpi_lid_evaluate_state(device);\r\nif (state < 0)\r\nreturn state;\r\nreturn acpi_lid_notify_state(device, state);\r\n}\r\nstatic void acpi_lid_initialize_state(struct acpi_device *device)\r\n{\r\nswitch (lid_init_state) {\r\ncase ACPI_BUTTON_LID_INIT_OPEN:\r\n(void)acpi_lid_notify_state(device, 1);\r\nbreak;\r\ncase ACPI_BUTTON_LID_INIT_METHOD:\r\n(void)acpi_lid_update_state(device);\r\nbreak;\r\ncase ACPI_BUTTON_LID_INIT_IGNORE:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void acpi_button_notify(struct acpi_device *device, u32 event)\r\n{\r\nstruct acpi_button *button = acpi_driver_data(device);\r\nstruct input_dev *input;\r\nswitch (event) {\r\ncase ACPI_FIXED_HARDWARE_EVENT:\r\nevent = ACPI_BUTTON_NOTIFY_STATUS;\r\ncase ACPI_BUTTON_NOTIFY_STATUS:\r\ninput = button->input;\r\nif (button->type == ACPI_BUTTON_TYPE_LID) {\r\nacpi_lid_update_state(device);\r\n} else {\r\nint keycode;\r\nacpi_pm_wakeup_event(&device->dev);\r\nif (button->suspended)\r\nbreak;\r\nkeycode = test_bit(KEY_SLEEP, input->keybit) ?\r\nKEY_SLEEP : KEY_POWER;\r\ninput_report_key(input, keycode, 1);\r\ninput_sync(input);\r\ninput_report_key(input, keycode, 0);\r\ninput_sync(input);\r\nacpi_bus_generate_netlink_event(\r\ndevice->pnp.device_class,\r\ndev_name(&device->dev),\r\nevent, ++button->pushed);\r\n}\r\nbreak;\r\ndefault:\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Unsupported event [0x%x]\n", event));\r\nbreak;\r\n}\r\n}\r\nstatic int acpi_button_suspend(struct device *dev)\r\n{\r\nstruct acpi_device *device = to_acpi_device(dev);\r\nstruct acpi_button *button = acpi_driver_data(device);\r\nbutton->suspended = true;\r\nreturn 0;\r\n}\r\nstatic int acpi_button_resume(struct device *dev)\r\n{\r\nstruct acpi_device *device = to_acpi_device(dev);\r\nstruct acpi_button *button = acpi_driver_data(device);\r\nbutton->suspended = false;\r\nif (button->type == ACPI_BUTTON_TYPE_LID)\r\nacpi_lid_initialize_state(device);\r\nreturn 0;\r\n}\r\nstatic int acpi_button_add(struct acpi_device *device)\r\n{\r\nstruct acpi_button *button;\r\nstruct input_dev *input;\r\nconst char *hid = acpi_device_hid(device);\r\nchar *name, *class;\r\nint error;\r\nbutton = kzalloc(sizeof(struct acpi_button), GFP_KERNEL);\r\nif (!button)\r\nreturn -ENOMEM;\r\ndevice->driver_data = button;\r\nbutton->input = input = input_allocate_device();\r\nif (!input) {\r\nerror = -ENOMEM;\r\ngoto err_free_button;\r\n}\r\nname = acpi_device_name(device);\r\nclass = acpi_device_class(device);\r\nif (!strcmp(hid, ACPI_BUTTON_HID_POWER) ||\r\n!strcmp(hid, ACPI_BUTTON_HID_POWERF)) {\r\nbutton->type = ACPI_BUTTON_TYPE_POWER;\r\nstrcpy(name, ACPI_BUTTON_DEVICE_NAME_POWER);\r\nsprintf(class, "%s/%s",\r\nACPI_BUTTON_CLASS, ACPI_BUTTON_SUBCLASS_POWER);\r\n} else if (!strcmp(hid, ACPI_BUTTON_HID_SLEEP) ||\r\n!strcmp(hid, ACPI_BUTTON_HID_SLEEPF)) {\r\nbutton->type = ACPI_BUTTON_TYPE_SLEEP;\r\nstrcpy(name, ACPI_BUTTON_DEVICE_NAME_SLEEP);\r\nsprintf(class, "%s/%s",\r\nACPI_BUTTON_CLASS, ACPI_BUTTON_SUBCLASS_SLEEP);\r\n} else if (!strcmp(hid, ACPI_BUTTON_HID_LID)) {\r\nbutton->type = ACPI_BUTTON_TYPE_LID;\r\nstrcpy(name, ACPI_BUTTON_DEVICE_NAME_LID);\r\nsprintf(class, "%s/%s",\r\nACPI_BUTTON_CLASS, ACPI_BUTTON_SUBCLASS_LID);\r\nbutton->last_state = !!acpi_lid_evaluate_state(device);\r\nbutton->last_time = ktime_get();\r\n} else {\r\nprintk(KERN_ERR PREFIX "Unsupported hid [%s]\n", hid);\r\nerror = -ENODEV;\r\ngoto err_free_input;\r\n}\r\nerror = acpi_button_add_fs(device);\r\nif (error)\r\ngoto err_free_input;\r\nsnprintf(button->phys, sizeof(button->phys), "%s/button/input0", hid);\r\ninput->name = name;\r\ninput->phys = button->phys;\r\ninput->id.bustype = BUS_HOST;\r\ninput->id.product = button->type;\r\ninput->dev.parent = &device->dev;\r\nswitch (button->type) {\r\ncase ACPI_BUTTON_TYPE_POWER:\r\ninput_set_capability(input, EV_KEY, KEY_POWER);\r\nbreak;\r\ncase ACPI_BUTTON_TYPE_SLEEP:\r\ninput_set_capability(input, EV_KEY, KEY_SLEEP);\r\nbreak;\r\ncase ACPI_BUTTON_TYPE_LID:\r\ninput_set_capability(input, EV_SW, SW_LID);\r\nbreak;\r\n}\r\nerror = input_register_device(input);\r\nif (error)\r\ngoto err_remove_fs;\r\nif (button->type == ACPI_BUTTON_TYPE_LID) {\r\nacpi_lid_initialize_state(device);\r\nlid_device = device;\r\n}\r\ndevice_init_wakeup(&device->dev, true);\r\nprintk(KERN_INFO PREFIX "%s [%s]\n", name, acpi_device_bid(device));\r\nreturn 0;\r\nerr_remove_fs:\r\nacpi_button_remove_fs(device);\r\nerr_free_input:\r\ninput_free_device(input);\r\nerr_free_button:\r\nkfree(button);\r\nreturn error;\r\n}\r\nstatic int acpi_button_remove(struct acpi_device *device)\r\n{\r\nstruct acpi_button *button = acpi_driver_data(device);\r\nacpi_button_remove_fs(device);\r\ninput_unregister_device(button->input);\r\nkfree(button);\r\nreturn 0;\r\n}\r\nstatic int param_set_lid_init_state(const char *val, struct kernel_param *kp)\r\n{\r\nint result = 0;\r\nif (!strncmp(val, "open", sizeof("open") - 1)) {\r\nlid_init_state = ACPI_BUTTON_LID_INIT_OPEN;\r\npr_info("Notify initial lid state as open\n");\r\n} else if (!strncmp(val, "method", sizeof("method") - 1)) {\r\nlid_init_state = ACPI_BUTTON_LID_INIT_METHOD;\r\npr_info("Notify initial lid state with _LID return value\n");\r\n} else if (!strncmp(val, "ignore", sizeof("ignore") - 1)) {\r\nlid_init_state = ACPI_BUTTON_LID_INIT_IGNORE;\r\npr_info("Do not notify initial lid state\n");\r\n} else\r\nresult = -EINVAL;\r\nreturn result;\r\n}\r\nstatic int param_get_lid_init_state(char *buffer, struct kernel_param *kp)\r\n{\r\nswitch (lid_init_state) {\r\ncase ACPI_BUTTON_LID_INIT_OPEN:\r\nreturn sprintf(buffer, "open");\r\ncase ACPI_BUTTON_LID_INIT_METHOD:\r\nreturn sprintf(buffer, "method");\r\ncase ACPI_BUTTON_LID_INIT_IGNORE:\r\nreturn sprintf(buffer, "ignore");\r\ndefault:\r\nreturn sprintf(buffer, "invalid");\r\n}\r\nreturn 0;\r\n}
