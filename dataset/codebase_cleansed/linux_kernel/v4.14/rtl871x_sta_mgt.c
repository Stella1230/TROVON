static void _init_stainfo(struct sta_info *psta)\r\n{\r\nmemset((u8 *)psta, 0, sizeof(struct sta_info));\r\nspin_lock_init(&psta->lock);\r\nINIT_LIST_HEAD(&psta->list);\r\nINIT_LIST_HEAD(&psta->hash_list);\r\n_r8712_init_sta_xmit_priv(&psta->sta_xmitpriv);\r\n_r8712_init_sta_recv_priv(&psta->sta_recvpriv);\r\nINIT_LIST_HEAD(&psta->asoc_list);\r\nINIT_LIST_HEAD(&psta->auth_list);\r\n}\r\nu32 _r8712_init_sta_priv(struct sta_priv *pstapriv)\r\n{\r\nstruct sta_info *psta;\r\ns32 i;\r\npstapriv->pallocated_stainfo_buf = kmalloc(sizeof(struct sta_info) *\r\nNUM_STA + 4, GFP_ATOMIC);\r\nif (!pstapriv->pallocated_stainfo_buf)\r\nreturn _FAIL;\r\npstapriv->pstainfo_buf = pstapriv->pallocated_stainfo_buf + 4 -\r\n((addr_t)(pstapriv->pallocated_stainfo_buf) & 3);\r\n_init_queue(&pstapriv->free_sta_queue);\r\nspin_lock_init(&pstapriv->sta_hash_lock);\r\npstapriv->asoc_sta_count = 0;\r\n_init_queue(&pstapriv->sleep_q);\r\n_init_queue(&pstapriv->wakeup_q);\r\npsta = (struct sta_info *)(pstapriv->pstainfo_buf);\r\nfor (i = 0; i < NUM_STA; i++) {\r\n_init_stainfo(psta);\r\nINIT_LIST_HEAD(&(pstapriv->sta_hash[i]));\r\nlist_add_tail(&psta->list, &pstapriv->free_sta_queue.queue);\r\npsta++;\r\n}\r\nINIT_LIST_HEAD(&pstapriv->asoc_list);\r\nINIT_LIST_HEAD(&pstapriv->auth_list);\r\nreturn _SUCCESS;\r\n}\r\nstatic void mfree_all_stainfo(struct sta_priv *pstapriv)\r\n{\r\nunsigned long irqL;\r\nstruct list_head *plist, *phead;\r\nspin_lock_irqsave(&pstapriv->sta_hash_lock, irqL);\r\nphead = &pstapriv->free_sta_queue.queue;\r\nplist = phead->next;\r\nwhile (!end_of_queue_search(phead, plist))\r\nplist = plist->next;\r\nspin_unlock_irqrestore(&pstapriv->sta_hash_lock, irqL);\r\n}\r\nu32 _r8712_free_sta_priv(struct sta_priv *pstapriv)\r\n{\r\nif (pstapriv) {\r\nmfree_all_stainfo(pstapriv);\r\nkfree(pstapriv->pallocated_stainfo_buf);\r\n}\r\nreturn _SUCCESS;\r\n}\r\nstruct sta_info *r8712_alloc_stainfo(struct sta_priv *pstapriv, u8 *hwaddr)\r\n{\r\ns32 index;\r\nstruct list_head *phash_list;\r\nstruct sta_info *psta;\r\nstruct __queue *pfree_sta_queue;\r\nstruct recv_reorder_ctrl *preorder_ctrl;\r\nint i = 0;\r\nu16 wRxSeqInitialValue = 0xffff;\r\nunsigned long flags;\r\npfree_sta_queue = &pstapriv->free_sta_queue;\r\nspin_lock_irqsave(&pfree_sta_queue->lock, flags);\r\npsta = list_first_entry_or_null(&pfree_sta_queue->queue,\r\nstruct sta_info, list);\r\nif (psta) {\r\nlist_del_init(&psta->list);\r\n_init_stainfo(psta);\r\nmemcpy(psta->hwaddr, hwaddr, ETH_ALEN);\r\nindex = wifi_mac_hash(hwaddr);\r\nif (index >= NUM_STA) {\r\npsta = NULL;\r\ngoto exit;\r\n}\r\nphash_list = &pstapriv->sta_hash[index];\r\nlist_add_tail(&psta->hash_list, phash_list);\r\npstapriv->asoc_sta_count++;\r\nfor (i = 0; i < 16; i++)\r\nmemcpy(&psta->sta_recvpriv.rxcache.tid_rxseq[i],\r\n&wRxSeqInitialValue, 2);\r\nfor (i = 0; i < 16; i++) {\r\npreorder_ctrl = &psta->recvreorder_ctrl[i];\r\npreorder_ctrl->padapter = pstapriv->padapter;\r\npreorder_ctrl->indicate_seq = 0xffff;\r\npreorder_ctrl->wend_b = 0xffff;\r\npreorder_ctrl->wsize_b = 64;\r\n_init_queue(&preorder_ctrl->pending_recvframe_queue);\r\nr8712_init_recv_timer(preorder_ctrl);\r\n}\r\n}\r\nexit:\r\nspin_unlock_irqrestore(&pfree_sta_queue->lock, flags);\r\nreturn psta;\r\n}\r\nvoid r8712_free_stainfo(struct _adapter *padapter, struct sta_info *psta)\r\n{\r\nint i;\r\nunsigned long irqL0;\r\nstruct __queue *pfree_sta_queue;\r\nstruct recv_reorder_ctrl *preorder_ctrl;\r\nstruct sta_xmit_priv *pstaxmitpriv;\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nif (psta == NULL)\r\nreturn;\r\npfree_sta_queue = &pstapriv->free_sta_queue;\r\npstaxmitpriv = &psta->sta_xmitpriv;\r\nspin_lock_irqsave(&(pxmitpriv->vo_pending.lock), irqL0);\r\nr8712_free_xmitframe_queue(pxmitpriv, &pstaxmitpriv->vo_q.sta_pending);\r\nlist_del_init(&(pstaxmitpriv->vo_q.tx_pending));\r\nspin_unlock_irqrestore(&(pxmitpriv->vo_pending.lock), irqL0);\r\nspin_lock_irqsave(&(pxmitpriv->vi_pending.lock), irqL0);\r\nr8712_free_xmitframe_queue(pxmitpriv, &pstaxmitpriv->vi_q.sta_pending);\r\nlist_del_init(&(pstaxmitpriv->vi_q.tx_pending));\r\nspin_unlock_irqrestore(&(pxmitpriv->vi_pending.lock), irqL0);\r\nspin_lock_irqsave(&(pxmitpriv->bk_pending.lock), irqL0);\r\nr8712_free_xmitframe_queue(pxmitpriv, &pstaxmitpriv->bk_q.sta_pending);\r\nlist_del_init(&(pstaxmitpriv->bk_q.tx_pending));\r\nspin_unlock_irqrestore(&(pxmitpriv->bk_pending.lock), irqL0);\r\nspin_lock_irqsave(&(pxmitpriv->be_pending.lock), irqL0);\r\nr8712_free_xmitframe_queue(pxmitpriv, &pstaxmitpriv->be_q.sta_pending);\r\nlist_del_init(&(pstaxmitpriv->be_q.tx_pending));\r\nspin_unlock_irqrestore(&(pxmitpriv->be_pending.lock), irqL0);\r\nlist_del_init(&psta->hash_list);\r\npstapriv->asoc_sta_count--;\r\n_r8712_init_sta_xmit_priv(&psta->sta_xmitpriv);\r\n_r8712_init_sta_recv_priv(&psta->sta_recvpriv);\r\nfor (i = 0; i < 16; i++) {\r\npreorder_ctrl = &psta->recvreorder_ctrl[i];\r\ndel_timer(&preorder_ctrl->reordering_ctrl_timer);\r\n}\r\nspin_lock(&(pfree_sta_queue->lock));\r\nlist_add_tail(&psta->list, &pfree_sta_queue->queue);\r\nspin_unlock(&(pfree_sta_queue->lock));\r\n}\r\nvoid r8712_free_all_stainfo(struct _adapter *padapter)\r\n{\r\nunsigned long irqL;\r\nstruct list_head *plist, *phead;\r\ns32 index;\r\nstruct sta_info *psta = NULL;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct sta_info *pbcmc_stainfo = r8712_get_bcmc_stainfo(padapter);\r\nif (pstapriv->asoc_sta_count == 1)\r\nreturn;\r\nspin_lock_irqsave(&pstapriv->sta_hash_lock, irqL);\r\nfor (index = 0; index < NUM_STA; index++) {\r\nphead = &(pstapriv->sta_hash[index]);\r\nplist = phead->next;\r\nwhile (!end_of_queue_search(phead, plist)) {\r\npsta = container_of(plist,\r\nstruct sta_info, hash_list);\r\nplist = plist->next;\r\nif (pbcmc_stainfo != psta)\r\nr8712_free_stainfo(padapter, psta);\r\n}\r\n}\r\nspin_unlock_irqrestore(&pstapriv->sta_hash_lock, irqL);\r\n}\r\nstruct sta_info *r8712_get_stainfo(struct sta_priv *pstapriv, u8 *hwaddr)\r\n{\r\nunsigned long irqL;\r\nstruct list_head *plist, *phead;\r\nstruct sta_info *psta = NULL;\r\nu32 index;\r\nif (hwaddr == NULL)\r\nreturn NULL;\r\nindex = wifi_mac_hash(hwaddr);\r\nspin_lock_irqsave(&pstapriv->sta_hash_lock, irqL);\r\nphead = &(pstapriv->sta_hash[index]);\r\nplist = phead->next;\r\nwhile (!end_of_queue_search(phead, plist)) {\r\npsta = container_of(plist, struct sta_info, hash_list);\r\nif ((!memcmp(psta->hwaddr, hwaddr, ETH_ALEN))) {\r\nbreak;\r\n}\r\npsta = NULL;\r\nplist = plist->next;\r\n}\r\nspin_unlock_irqrestore(&pstapriv->sta_hash_lock, irqL);\r\nreturn psta;\r\n}\r\nvoid r8712_init_bcmc_stainfo(struct _adapter *padapter)\r\n{\r\nunsigned char bcast_addr[6] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nr8712_alloc_stainfo(pstapriv, bcast_addr);\r\n}\r\nstruct sta_info *r8712_get_bcmc_stainfo(struct _adapter *padapter)\r\n{\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nu8 bc_addr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\r\nreturn r8712_get_stainfo(pstapriv, bc_addr);\r\n}\r\nu8 r8712_access_ctrl(struct wlan_acl_pool *pacl_list, u8 *mac_addr)\r\n{\r\nreturn true;\r\n}
