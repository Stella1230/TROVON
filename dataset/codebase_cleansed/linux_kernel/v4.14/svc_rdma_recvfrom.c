static void rdma_build_arg_xdr(struct svc_rqst *rqstp,\r\nstruct svc_rdma_op_ctxt *ctxt,\r\nu32 byte_count)\r\n{\r\nstruct page *page;\r\nu32 bc;\r\nint sge_no;\r\npage = ctxt->pages[0];\r\nput_page(rqstp->rq_pages[0]);\r\nrqstp->rq_pages[0] = page;\r\nrqstp->rq_arg.head[0].iov_base = page_address(page);\r\nrqstp->rq_arg.head[0].iov_len =\r\nmin_t(size_t, byte_count, ctxt->sge[0].length);\r\nrqstp->rq_arg.len = byte_count;\r\nrqstp->rq_arg.buflen = byte_count;\r\nbc = byte_count - rqstp->rq_arg.head[0].iov_len;\r\nrqstp->rq_arg.page_len = bc;\r\nrqstp->rq_arg.page_base = 0;\r\nsge_no = 1;\r\nwhile (bc && sge_no < ctxt->count) {\r\npage = ctxt->pages[sge_no];\r\nput_page(rqstp->rq_pages[sge_no]);\r\nrqstp->rq_pages[sge_no] = page;\r\nbc -= min_t(u32, bc, ctxt->sge[sge_no].length);\r\nsge_no++;\r\n}\r\nrqstp->rq_respages = &rqstp->rq_pages[sge_no];\r\nrqstp->rq_next_page = rqstp->rq_respages + 1;\r\nbc = sge_no;\r\nwhile (sge_no < ctxt->count) {\r\npage = ctxt->pages[sge_no++];\r\nput_page(page);\r\n}\r\nctxt->count = bc;\r\nrqstp->rq_arg.tail[0].iov_base = NULL;\r\nrqstp->rq_arg.tail[0].iov_len = 0;\r\n}\r\nstatic __be32 *xdr_check_read_list(__be32 *p, const __be32 *end)\r\n{\r\nu32 position;\r\nbool first;\r\nfirst = true;\r\nwhile (*p++ != xdr_zero) {\r\nif (first) {\r\nposition = be32_to_cpup(p++);\r\nfirst = false;\r\n} else if (be32_to_cpup(p++) != position) {\r\nreturn NULL;\r\n}\r\np++;\r\nif (be32_to_cpup(p++) > MAX_BYTES_SPECIAL_SEG)\r\nreturn NULL;\r\np += 2;\r\nif (p > end)\r\nreturn NULL;\r\n}\r\nreturn p;\r\n}\r\nstatic __be32 *xdr_check_write_chunk(__be32 *p, const __be32 *end,\r\nu32 maxlen)\r\n{\r\nu32 i, segcount;\r\nsegcount = be32_to_cpup(p++);\r\nfor (i = 0; i < segcount; i++) {\r\np++;\r\nif (be32_to_cpup(p++) > maxlen)\r\nreturn NULL;\r\np += 2;\r\nif (p > end)\r\nreturn NULL;\r\n}\r\nreturn p;\r\n}\r\nstatic __be32 *xdr_check_write_list(__be32 *p, const __be32 *end)\r\n{\r\nu32 chcount;\r\nchcount = 0;\r\nwhile (*p++ != xdr_zero) {\r\np = xdr_check_write_chunk(p, end, MAX_BYTES_WRITE_SEG);\r\nif (!p)\r\nreturn NULL;\r\nif (chcount++ > 1)\r\nreturn NULL;\r\n}\r\nreturn p;\r\n}\r\nstatic __be32 *xdr_check_reply_chunk(__be32 *p, const __be32 *end)\r\n{\r\nif (*p++ != xdr_zero) {\r\np = xdr_check_write_chunk(p, end, MAX_BYTES_SPECIAL_SEG);\r\nif (!p)\r\nreturn NULL;\r\n}\r\nreturn p;\r\n}\r\nstatic int svc_rdma_xdr_decode_req(struct xdr_buf *rq_arg)\r\n{\r\n__be32 *p, *end, *rdma_argp;\r\nunsigned int hdr_len;\r\nchar *proc;\r\nif (rq_arg->len <= RPCRDMA_HDRLEN_ERR)\r\ngoto out_short;\r\nrdma_argp = rq_arg->head[0].iov_base;\r\nif (*(rdma_argp + 1) != rpcrdma_version)\r\ngoto out_version;\r\nswitch (*(rdma_argp + 3)) {\r\ncase rdma_msg:\r\nproc = "RDMA_MSG";\r\nbreak;\r\ncase rdma_nomsg:\r\nproc = "RDMA_NOMSG";\r\nbreak;\r\ncase rdma_done:\r\ngoto out_drop;\r\ncase rdma_error:\r\ngoto out_drop;\r\ndefault:\r\ngoto out_proc;\r\n}\r\nend = (__be32 *)((unsigned long)rdma_argp + rq_arg->len);\r\np = xdr_check_read_list(rdma_argp + 4, end);\r\nif (!p)\r\ngoto out_inval;\r\np = xdr_check_write_list(p, end);\r\nif (!p)\r\ngoto out_inval;\r\np = xdr_check_reply_chunk(p, end);\r\nif (!p)\r\ngoto out_inval;\r\nif (p > end)\r\ngoto out_inval;\r\nrq_arg->head[0].iov_base = p;\r\nhdr_len = (unsigned long)p - (unsigned long)rdma_argp;\r\nrq_arg->head[0].iov_len -= hdr_len;\r\nrq_arg->len -= hdr_len;\r\ndprintk("svcrdma: received %s request for XID 0x%08x, hdr_len=%u\n",\r\nproc, be32_to_cpup(rdma_argp), hdr_len);\r\nreturn hdr_len;\r\nout_short:\r\ndprintk("svcrdma: header too short = %d\n", rq_arg->len);\r\nreturn -EINVAL;\r\nout_version:\r\ndprintk("svcrdma: bad xprt version: %u\n",\r\nbe32_to_cpup(rdma_argp + 1));\r\nreturn -EPROTONOSUPPORT;\r\nout_drop:\r\ndprintk("svcrdma: dropping RDMA_DONE/ERROR message\n");\r\nreturn 0;\r\nout_proc:\r\ndprintk("svcrdma: bad rdma procedure (%u)\n",\r\nbe32_to_cpup(rdma_argp + 3));\r\nreturn -EINVAL;\r\nout_inval:\r\ndprintk("svcrdma: failed to parse transport header\n");\r\nreturn -EINVAL;\r\n}\r\nstatic void rdma_read_complete(struct svc_rqst *rqstp,\r\nstruct svc_rdma_op_ctxt *head)\r\n{\r\nint page_no;\r\nfor (page_no = 0; page_no < head->count; page_no++) {\r\nput_page(rqstp->rq_pages[page_no]);\r\nrqstp->rq_pages[page_no] = head->pages[page_no];\r\n}\r\nrqstp->rq_arg.pages = &rqstp->rq_pages[head->hdr_count];\r\nrqstp->rq_arg.page_len = head->arg.page_len;\r\nrqstp->rq_respages = &rqstp->rq_pages[page_no];\r\nrqstp->rq_next_page = rqstp->rq_respages + 1;\r\nrqstp->rq_arg.head[0] = head->arg.head[0];\r\nrqstp->rq_arg.tail[0] = head->arg.tail[0];\r\nrqstp->rq_arg.len = head->arg.len;\r\nrqstp->rq_arg.buflen = head->arg.buflen;\r\n}\r\nstatic void svc_rdma_send_error(struct svcxprt_rdma *xprt,\r\n__be32 *rdma_argp, int status)\r\n{\r\nstruct svc_rdma_op_ctxt *ctxt;\r\n__be32 *p, *err_msgp;\r\nunsigned int length;\r\nstruct page *page;\r\nint ret;\r\nret = svc_rdma_repost_recv(xprt, GFP_KERNEL);\r\nif (ret)\r\nreturn;\r\npage = alloc_page(GFP_KERNEL);\r\nif (!page)\r\nreturn;\r\nerr_msgp = page_address(page);\r\np = err_msgp;\r\n*p++ = *rdma_argp;\r\n*p++ = *(rdma_argp + 1);\r\n*p++ = xprt->sc_fc_credits;\r\n*p++ = rdma_error;\r\nif (status == -EPROTONOSUPPORT) {\r\n*p++ = err_vers;\r\n*p++ = rpcrdma_version;\r\n*p++ = rpcrdma_version;\r\n} else {\r\n*p++ = err_chunk;\r\n}\r\nlength = (unsigned long)p - (unsigned long)err_msgp;\r\nctxt = svc_rdma_get_context(xprt);\r\nret = svc_rdma_map_reply_hdr(xprt, ctxt, err_msgp, length);\r\nif (ret) {\r\ndprintk("svcrdma: Error %d mapping send for protocol error\n",\r\nret);\r\nreturn;\r\n}\r\nret = svc_rdma_post_send_wr(xprt, ctxt, 1, 0);\r\nif (ret) {\r\ndprintk("svcrdma: Error %d posting send for protocol error\n",\r\nret);\r\nsvc_rdma_unmap_dma(ctxt);\r\nsvc_rdma_put_context(ctxt, 1);\r\n}\r\n}\r\nstatic bool svc_rdma_is_backchannel_reply(struct svc_xprt *xprt,\r\n__be32 *rdma_resp)\r\n{\r\n__be32 *p;\r\nif (!xprt->xpt_bc_xprt)\r\nreturn false;\r\np = rdma_resp + 3;\r\nif (*p++ != rdma_msg)\r\nreturn false;\r\nif (*p++ != xdr_zero)\r\nreturn false;\r\nif (*p++ != xdr_zero)\r\nreturn false;\r\nif (*p++ != xdr_zero)\r\nreturn false;\r\nif (*p++ != *rdma_resp)\r\nreturn false;\r\nif (*p == cpu_to_be32(RPC_CALL))\r\nreturn false;\r\nreturn true;\r\n}\r\nint svc_rdma_recvfrom(struct svc_rqst *rqstp)\r\n{\r\nstruct svc_xprt *xprt = rqstp->rq_xprt;\r\nstruct svcxprt_rdma *rdma_xprt =\r\ncontainer_of(xprt, struct svcxprt_rdma, sc_xprt);\r\nstruct svc_rdma_op_ctxt *ctxt;\r\n__be32 *p;\r\nint ret;\r\nspin_lock(&rdma_xprt->sc_rq_dto_lock);\r\nif (!list_empty(&rdma_xprt->sc_read_complete_q)) {\r\nctxt = list_first_entry(&rdma_xprt->sc_read_complete_q,\r\nstruct svc_rdma_op_ctxt, list);\r\nlist_del(&ctxt->list);\r\nspin_unlock(&rdma_xprt->sc_rq_dto_lock);\r\nrdma_read_complete(rqstp, ctxt);\r\ngoto complete;\r\n} else if (!list_empty(&rdma_xprt->sc_rq_dto_q)) {\r\nctxt = list_first_entry(&rdma_xprt->sc_rq_dto_q,\r\nstruct svc_rdma_op_ctxt, list);\r\nlist_del(&ctxt->list);\r\n} else {\r\nclear_bit(XPT_DATA, &xprt->xpt_flags);\r\nspin_unlock(&rdma_xprt->sc_rq_dto_lock);\r\nreturn 0;\r\n}\r\nspin_unlock(&rdma_xprt->sc_rq_dto_lock);\r\ndprintk("svcrdma: recvfrom: ctxt=%p on xprt=%p, rqstp=%p\n",\r\nctxt, rdma_xprt, rqstp);\r\natomic_inc(&rdma_stat_recv);\r\nrdma_build_arg_xdr(rqstp, ctxt, ctxt->byte_len);\r\np = (__be32 *)rqstp->rq_arg.head[0].iov_base;\r\nret = svc_rdma_xdr_decode_req(&rqstp->rq_arg);\r\nif (ret < 0)\r\ngoto out_err;\r\nif (ret == 0)\r\ngoto out_drop;\r\nrqstp->rq_xprt_hlen = ret;\r\nif (svc_rdma_is_backchannel_reply(xprt, p)) {\r\nret = svc_rdma_handle_bc_reply(xprt->xpt_bc_xprt, p,\r\n&rqstp->rq_arg);\r\nsvc_rdma_put_context(ctxt, 0);\r\nif (ret)\r\ngoto repost;\r\nreturn ret;\r\n}\r\np += rpcrdma_fixed_maxsz;\r\nif (*p != xdr_zero)\r\ngoto out_readchunk;\r\ncomplete:\r\nsvc_rdma_put_context(ctxt, 0);\r\ndprintk("svcrdma: recvfrom: xprt=%p, rqstp=%p, rq_arg.len=%u\n",\r\nrdma_xprt, rqstp, rqstp->rq_arg.len);\r\nrqstp->rq_prot = IPPROTO_MAX;\r\nsvc_xprt_copy_addrs(rqstp, xprt);\r\nreturn rqstp->rq_arg.len;\r\nout_readchunk:\r\nret = svc_rdma_recv_read_chunk(rdma_xprt, rqstp, ctxt, p);\r\nif (ret < 0)\r\ngoto out_postfail;\r\nreturn 0;\r\nout_err:\r\nsvc_rdma_send_error(rdma_xprt, p, ret);\r\nsvc_rdma_put_context(ctxt, 0);\r\nreturn 0;\r\nout_postfail:\r\nif (ret == -EINVAL)\r\nsvc_rdma_send_error(rdma_xprt, p, ret);\r\nsvc_rdma_put_context(ctxt, 1);\r\nreturn ret;\r\nout_drop:\r\nsvc_rdma_put_context(ctxt, 1);\r\nrepost:\r\nreturn svc_rdma_repost_recv(rdma_xprt, GFP_KERNEL);\r\n}
