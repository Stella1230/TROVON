static void pxa168_pll_init(struct pxa168_clk_unit *pxa_unit)\r\n{\r\nstruct clk *clk;\r\nstruct mmp_clk_unit *unit = &pxa_unit->unit;\r\nmmp_register_fixed_rate_clks(unit, fixed_rate_clks,\r\nARRAY_SIZE(fixed_rate_clks));\r\nmmp_register_fixed_factor_clks(unit, fixed_factor_clks,\r\nARRAY_SIZE(fixed_factor_clks));\r\nclk = mmp_clk_register_factor("uart_pll", "pll1_4",\r\nCLK_SET_RATE_PARENT,\r\npxa_unit->mpmu_base + MPMU_UART_PLL,\r\n&uart_factor_masks, uart_factor_tbl,\r\nARRAY_SIZE(uart_factor_tbl), NULL);\r\nmmp_clk_add(unit, PXA168_CLK_UART_PLL, clk);\r\n}\r\nstatic void pxa168_apb_periph_clk_init(struct pxa168_clk_unit *pxa_unit)\r\n{\r\nstruct mmp_clk_unit *unit = &pxa_unit->unit;\r\nmmp_register_mux_clks(unit, apbc_mux_clks, pxa_unit->apbc_base,\r\nARRAY_SIZE(apbc_mux_clks));\r\nmmp_register_gate_clks(unit, apbc_gate_clks, pxa_unit->apbc_base,\r\nARRAY_SIZE(apbc_gate_clks));\r\n}\r\nstatic void pxa168_axi_periph_clk_init(struct pxa168_clk_unit *pxa_unit)\r\n{\r\nstruct mmp_clk_unit *unit = &pxa_unit->unit;\r\nmmp_register_mux_clks(unit, apmu_mux_clks, pxa_unit->apmu_base,\r\nARRAY_SIZE(apmu_mux_clks));\r\nmmp_register_div_clks(unit, apmu_div_clks, pxa_unit->apmu_base,\r\nARRAY_SIZE(apmu_div_clks));\r\nmmp_register_gate_clks(unit, apmu_gate_clks, pxa_unit->apmu_base,\r\nARRAY_SIZE(apmu_gate_clks));\r\n}\r\nstatic void pxa168_clk_reset_init(struct device_node *np,\r\nstruct pxa168_clk_unit *pxa_unit)\r\n{\r\nstruct mmp_clk_reset_cell *cells;\r\nint i, nr_resets;\r\nnr_resets = ARRAY_SIZE(apbc_gate_clks);\r\ncells = kcalloc(nr_resets, sizeof(*cells), GFP_KERNEL);\r\nif (!cells)\r\nreturn;\r\nfor (i = 0; i < nr_resets; i++) {\r\ncells[i].clk_id = apbc_gate_clks[i].id;\r\ncells[i].reg = pxa_unit->apbc_base + apbc_gate_clks[i].offset;\r\ncells[i].flags = 0;\r\ncells[i].lock = apbc_gate_clks[i].lock;\r\ncells[i].bits = 0x4;\r\n}\r\nmmp_clk_reset_register(np, cells, nr_resets);\r\n}\r\nstatic void __init pxa168_clk_init(struct device_node *np)\r\n{\r\nstruct pxa168_clk_unit *pxa_unit;\r\npxa_unit = kzalloc(sizeof(*pxa_unit), GFP_KERNEL);\r\nif (!pxa_unit)\r\nreturn;\r\npxa_unit->mpmu_base = of_iomap(np, 0);\r\nif (!pxa_unit->mpmu_base) {\r\npr_err("failed to map mpmu registers\n");\r\nreturn;\r\n}\r\npxa_unit->apmu_base = of_iomap(np, 1);\r\nif (!pxa_unit->apmu_base) {\r\npr_err("failed to map apmu registers\n");\r\nreturn;\r\n}\r\npxa_unit->apbc_base = of_iomap(np, 2);\r\nif (!pxa_unit->apbc_base) {\r\npr_err("failed to map apbc registers\n");\r\nreturn;\r\n}\r\nmmp_clk_init(np, &pxa_unit->unit, PXA168_NR_CLKS);\r\npxa168_pll_init(pxa_unit);\r\npxa168_apb_periph_clk_init(pxa_unit);\r\npxa168_axi_periph_clk_init(pxa_unit);\r\npxa168_clk_reset_init(np, pxa_unit);\r\n}
