static inline void isd_id_to_devname(char *devname, int sz,\r\nconst struct internal_subdev_id *id,\r\nint ipu_id)\r\n{\r\nint pdev_id = ipu_id * num_isd + id->index;\r\nsnprintf(devname, sz, "%s.%d", id->name, pdev_id);\r\n}\r\nstatic int add_internal_links(struct imx_media_dev *imxmd,\r\nconst struct internal_subdev *isd,\r\nstruct imx_media_subdev *imxsd,\r\nint ipu_id)\r\n{\r\nint i, num_pads, ret;\r\nnum_pads = isd->num_sink_pads + isd->num_src_pads;\r\nfor (i = 0; i < num_pads; i++) {\r\nconst struct internal_pad *intpad = &isd->pad[i];\r\nstruct imx_media_pad *pad = &imxsd->pad[i];\r\nint j;\r\npad->pad.flags = (i < isd->num_sink_pads) ?\r\nMEDIA_PAD_FL_SINK : MEDIA_PAD_FL_SOURCE;\r\npad->devnode = intpad->devnode;\r\nfor (j = 0; ; j++) {\r\nconst struct internal_link *link;\r\nchar remote_devname[32];\r\nlink = &intpad->link[j];\r\nif (!link->remote_id)\r\nbreak;\r\nisd_id_to_devname(remote_devname,\r\nsizeof(remote_devname),\r\nlink->remote_id, ipu_id);\r\nret = imx_media_add_pad_link(imxmd, pad,\r\nNULL, remote_devname,\r\ni, link->remote_pad);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic struct imx_media_subdev *\r\nadd_internal_subdev(struct imx_media_dev *imxmd,\r\nconst struct internal_subdev *isd,\r\nint ipu_id)\r\n{\r\nstruct imx_media_internal_sd_platformdata pdata;\r\nstruct platform_device_info pdevinfo = {0};\r\nstruct imx_media_subdev *imxsd;\r\nstruct platform_device *pdev;\r\npdata.grp_id = isd->id->grp_id;\r\npdata.ipu_id = ipu_id;\r\nimx_media_grp_id_to_sd_name(pdata.sd_name, sizeof(pdata.sd_name),\r\npdata.grp_id, ipu_id);\r\npdevinfo.name = isd->id->name;\r\npdevinfo.id = ipu_id * num_isd + isd->id->index;\r\npdevinfo.parent = imxmd->md.dev;\r\npdevinfo.data = &pdata;\r\npdevinfo.size_data = sizeof(pdata);\r\npdevinfo.dma_mask = DMA_BIT_MASK(32);\r\npdev = platform_device_register_full(&pdevinfo);\r\nif (IS_ERR(pdev))\r\nreturn ERR_CAST(pdev);\r\nimxsd = imx_media_add_async_subdev(imxmd, NULL, pdev);\r\nif (IS_ERR(imxsd))\r\nreturn imxsd;\r\nimxsd->num_sink_pads = isd->num_sink_pads;\r\nimxsd->num_src_pads = isd->num_src_pads;\r\nreturn imxsd;\r\n}\r\nstatic int add_ipu_internal_subdevs(struct imx_media_dev *imxmd,\r\nstruct imx_media_subdev *csi0,\r\nstruct imx_media_subdev *csi1,\r\nint ipu_id)\r\n{\r\nenum isd_enum i;\r\nint ret;\r\nfor (i = 0; i < num_isd; i++) {\r\nconst struct internal_subdev *isd = &internal_subdev[i];\r\nstruct imx_media_subdev *imxsd;\r\nswitch (isd->id->grp_id) {\r\ncase IMX_MEDIA_GRP_ID_CSI0:\r\nimxsd = csi0;\r\nbreak;\r\ncase IMX_MEDIA_GRP_ID_CSI1:\r\nimxsd = csi1;\r\nbreak;\r\ndefault:\r\nimxsd = add_internal_subdev(imxmd, isd, ipu_id);\r\nbreak;\r\n}\r\nif (IS_ERR(imxsd))\r\nreturn PTR_ERR(imxsd);\r\nif (imxsd) {\r\nret = add_internal_links(imxmd, isd, imxsd, ipu_id);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint imx_media_add_internal_subdevs(struct imx_media_dev *imxmd,\r\nstruct imx_media_subdev *csi[4])\r\n{\r\nint ret;\r\nret = add_ipu_internal_subdevs(imxmd, csi[0], csi[1], 0);\r\nif (ret)\r\ngoto remove;\r\nret = add_ipu_internal_subdevs(imxmd, csi[2], csi[3], 1);\r\nif (ret)\r\ngoto remove;\r\nreturn 0;\r\nremove:\r\nimx_media_remove_internal_subdevs(imxmd);\r\nreturn ret;\r\n}\r\nvoid imx_media_remove_internal_subdevs(struct imx_media_dev *imxmd)\r\n{\r\nstruct imx_media_subdev *imxsd;\r\nint i;\r\nfor (i = 0; i < imxmd->subdev_notifier.num_subdevs; i++) {\r\nimxsd = &imxmd->subdev[i];\r\nif (!imxsd->pdev)\r\ncontinue;\r\nplatform_device_unregister(imxsd->pdev);\r\n}\r\n}
