static void sun8i_mixer_commit(struct sunxi_engine *engine)\r\n{\r\nDRM_DEBUG_DRIVER("Committing changes\n");\r\nregmap_write(engine->regs, SUN8I_MIXER_GLOBAL_DBUFF,\r\nSUN8I_MIXER_GLOBAL_DBUFF_ENABLE);\r\n}\r\nvoid sun8i_mixer_layer_enable(struct sun8i_mixer *mixer,\r\nint layer, bool enable)\r\n{\r\nu32 val;\r\nint chan = mixer->cfg->vi_num;\r\nDRM_DEBUG_DRIVER("Enabling layer %d in channel %d\n", layer, chan);\r\nif (enable)\r\nval = SUN8I_MIXER_CHAN_UI_LAYER_ATTR_EN;\r\nelse\r\nval = 0;\r\nregmap_update_bits(mixer->engine.regs,\r\nSUN8I_MIXER_CHAN_UI_LAYER_ATTR(chan, layer),\r\nSUN8I_MIXER_CHAN_UI_LAYER_ATTR_EN, val);\r\nregmap_update_bits(mixer->engine.regs,\r\nSUN8I_MIXER_CHAN_UI_LAYER_ATTR(chan, layer),\r\nSUN8I_MIXER_CHAN_UI_LAYER_ATTR_ALPHA_MODE_MASK,\r\nSUN8I_MIXER_CHAN_UI_LAYER_ATTR_ALPHA_MODE_DEF);\r\nregmap_update_bits(mixer->engine.regs,\r\nSUN8I_MIXER_CHAN_UI_LAYER_ATTR(chan, layer),\r\nSUN8I_MIXER_CHAN_UI_LAYER_ATTR_ALPHA_MASK,\r\nSUN8I_MIXER_CHAN_UI_LAYER_ATTR_ALPHA_DEF);\r\n}\r\nstatic int sun8i_mixer_drm_format_to_layer(struct drm_plane *plane,\r\nu32 format, u32 *mode)\r\n{\r\nswitch (format) {\r\ncase DRM_FORMAT_ARGB8888:\r\n*mode = SUN8I_MIXER_CHAN_UI_LAYER_ATTR_FBFMT_ARGB8888;\r\nbreak;\r\ncase DRM_FORMAT_XRGB8888:\r\n*mode = SUN8I_MIXER_CHAN_UI_LAYER_ATTR_FBFMT_XRGB8888;\r\nbreak;\r\ncase DRM_FORMAT_RGB888:\r\n*mode = SUN8I_MIXER_CHAN_UI_LAYER_ATTR_FBFMT_RGB888;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint sun8i_mixer_update_layer_coord(struct sun8i_mixer *mixer,\r\nint layer, struct drm_plane *plane)\r\n{\r\nstruct drm_plane_state *state = plane->state;\r\nstruct drm_framebuffer *fb = state->fb;\r\nint chan = mixer->cfg->vi_num;\r\nDRM_DEBUG_DRIVER("Updating layer %d\n", layer);\r\nif (plane->type == DRM_PLANE_TYPE_PRIMARY) {\r\nDRM_DEBUG_DRIVER("Primary layer, updating global size W: %u H: %u\n",\r\nstate->crtc_w, state->crtc_h);\r\nregmap_write(mixer->engine.regs, SUN8I_MIXER_GLOBAL_SIZE,\r\nSUN8I_MIXER_SIZE(state->crtc_w,\r\nstate->crtc_h));\r\nDRM_DEBUG_DRIVER("Updating blender size\n");\r\nregmap_write(mixer->engine.regs,\r\nSUN8I_MIXER_BLEND_ATTR_INSIZE(0),\r\nSUN8I_MIXER_SIZE(state->crtc_w,\r\nstate->crtc_h));\r\nregmap_write(mixer->engine.regs, SUN8I_MIXER_BLEND_OUTSIZE,\r\nSUN8I_MIXER_SIZE(state->crtc_w,\r\nstate->crtc_h));\r\nDRM_DEBUG_DRIVER("Updating channel size\n");\r\nregmap_write(mixer->engine.regs,\r\nSUN8I_MIXER_CHAN_UI_OVL_SIZE(chan),\r\nSUN8I_MIXER_SIZE(state->crtc_w,\r\nstate->crtc_h));\r\n}\r\nDRM_DEBUG_DRIVER("Layer line width: %d bytes\n", fb->pitches[0]);\r\nregmap_write(mixer->engine.regs,\r\nSUN8I_MIXER_CHAN_UI_LAYER_PITCH(chan, layer),\r\nfb->pitches[0]);\r\nDRM_DEBUG_DRIVER("Layer size W: %u H: %u\n",\r\nstate->crtc_w, state->crtc_h);\r\nregmap_write(mixer->engine.regs,\r\nSUN8I_MIXER_CHAN_UI_LAYER_SIZE(chan, layer),\r\nSUN8I_MIXER_SIZE(state->crtc_w, state->crtc_h));\r\nDRM_DEBUG_DRIVER("Layer coordinates X: %d Y: %d\n",\r\nstate->crtc_x, state->crtc_y);\r\nregmap_write(mixer->engine.regs,\r\nSUN8I_MIXER_CHAN_UI_LAYER_COORD(chan, layer),\r\nSUN8I_MIXER_COORD(state->crtc_x, state->crtc_y));\r\nreturn 0;\r\n}\r\nint sun8i_mixer_update_layer_formats(struct sun8i_mixer *mixer,\r\nint layer, struct drm_plane *plane)\r\n{\r\nstruct drm_plane_state *state = plane->state;\r\nstruct drm_framebuffer *fb = state->fb;\r\nbool interlaced = false;\r\nu32 val;\r\nint chan = mixer->cfg->vi_num;\r\nint ret;\r\nif (plane->state->crtc)\r\ninterlaced = plane->state->crtc->state->adjusted_mode.flags\r\n& DRM_MODE_FLAG_INTERLACE;\r\nregmap_update_bits(mixer->engine.regs, SUN8I_MIXER_BLEND_OUTCTL,\r\nSUN8I_MIXER_BLEND_OUTCTL_INTERLACED,\r\ninterlaced ?\r\nSUN8I_MIXER_BLEND_OUTCTL_INTERLACED : 0);\r\nDRM_DEBUG_DRIVER("Switching display mixer interlaced mode %s\n",\r\ninterlaced ? "on" : "off");\r\nret = sun8i_mixer_drm_format_to_layer(plane, fb->format->format,\r\n&val);\r\nif (ret) {\r\nDRM_DEBUG_DRIVER("Invalid format\n");\r\nreturn ret;\r\n}\r\nregmap_update_bits(mixer->engine.regs,\r\nSUN8I_MIXER_CHAN_UI_LAYER_ATTR(chan, layer),\r\nSUN8I_MIXER_CHAN_UI_LAYER_ATTR_FBFMT_MASK, val);\r\nreturn 0;\r\n}\r\nint sun8i_mixer_update_layer_buffer(struct sun8i_mixer *mixer,\r\nint layer, struct drm_plane *plane)\r\n{\r\nstruct drm_plane_state *state = plane->state;\r\nstruct drm_framebuffer *fb = state->fb;\r\nstruct drm_gem_cma_object *gem;\r\ndma_addr_t paddr;\r\nint chan = mixer->cfg->vi_num;\r\nint bpp;\r\ngem = drm_fb_cma_get_gem_obj(fb, 0);\r\nDRM_DEBUG_DRIVER("Using GEM @ %pad\n", &gem->paddr);\r\nbpp = fb->format->cpp[0];\r\npaddr = gem->paddr + fb->offsets[0];\r\npaddr += (state->src_x >> 16) * bpp;\r\npaddr += (state->src_y >> 16) * fb->pitches[0];\r\nif (state->crtc_x < 0)\r\npaddr += -state->crtc_x * bpp;\r\nif (state->crtc_y < 0)\r\npaddr += -state->crtc_y * fb->pitches[0];\r\nDRM_DEBUG_DRIVER("Setting buffer address to %pad\n", &paddr);\r\nregmap_write(mixer->engine.regs,\r\nSUN8I_MIXER_CHAN_UI_LAYER_TOP_LADDR(chan, layer),\r\nlower_32_bits(paddr));\r\nreturn 0;\r\n}\r\nstatic int sun8i_mixer_bind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct drm_device *drm = data;\r\nstruct sun4i_drv *drv = drm->dev_private;\r\nstruct sun8i_mixer *mixer;\r\nstruct resource *res;\r\nvoid __iomem *regs;\r\nint i, ret;\r\nret = dma_set_mask(dev, DMA_BIT_MASK(32));\r\nif (ret) {\r\ndev_err(dev, "Cannot do 32-bit DMA.\n");\r\nreturn ret;\r\n}\r\nmixer = devm_kzalloc(dev, sizeof(*mixer), GFP_KERNEL);\r\nif (!mixer)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(dev, mixer);\r\nmixer->engine.ops = &sun8i_engine_ops;\r\nmixer->engine.node = dev->of_node;\r\nmixer->engine.id = -1;\r\nmixer->cfg = of_device_get_match_data(dev);\r\nif (!mixer->cfg)\r\nreturn -EINVAL;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nregs = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(regs))\r\nreturn PTR_ERR(regs);\r\nmixer->engine.regs = devm_regmap_init_mmio(dev, regs,\r\n&sun8i_mixer_regmap_config);\r\nif (IS_ERR(mixer->engine.regs)) {\r\ndev_err(dev, "Couldn't create the mixer regmap\n");\r\nreturn PTR_ERR(mixer->engine.regs);\r\n}\r\nmixer->reset = devm_reset_control_get(dev, NULL);\r\nif (IS_ERR(mixer->reset)) {\r\ndev_err(dev, "Couldn't get our reset line\n");\r\nreturn PTR_ERR(mixer->reset);\r\n}\r\nret = reset_control_deassert(mixer->reset);\r\nif (ret) {\r\ndev_err(dev, "Couldn't deassert our reset line\n");\r\nreturn ret;\r\n}\r\nmixer->bus_clk = devm_clk_get(dev, "bus");\r\nif (IS_ERR(mixer->bus_clk)) {\r\ndev_err(dev, "Couldn't get the mixer bus clock\n");\r\nret = PTR_ERR(mixer->bus_clk);\r\ngoto err_assert_reset;\r\n}\r\nclk_prepare_enable(mixer->bus_clk);\r\nmixer->mod_clk = devm_clk_get(dev, "mod");\r\nif (IS_ERR(mixer->mod_clk)) {\r\ndev_err(dev, "Couldn't get the mixer module clock\n");\r\nret = PTR_ERR(mixer->mod_clk);\r\ngoto err_disable_bus_clk;\r\n}\r\nclk_prepare_enable(mixer->mod_clk);\r\nlist_add_tail(&mixer->engine.list, &drv->engine_list);\r\nfor (i = 0x0; i < 0x20000; i += 4)\r\nregmap_write(mixer->engine.regs, i, 0);\r\nregmap_write(mixer->engine.regs, SUN8I_MIXER_GLOBAL_CTL,\r\nSUN8I_MIXER_GLOBAL_CTL_RT_EN);\r\nregmap_write(mixer->engine.regs, SUN8I_MIXER_BLEND_FCOLOR_CTL,\r\nSUN8I_MIXER_BLEND_FCOLOR_CTL_DEF);\r\nregmap_write(mixer->engine.regs, SUN8I_MIXER_BLEND_PREMULTIPLY,\r\nSUN8I_MIXER_BLEND_PREMULTIPLY_DEF);\r\nregmap_write(mixer->engine.regs, SUN8I_MIXER_BLEND_BKCOLOR,\r\nSUN8I_MIXER_BLEND_BKCOLOR_DEF);\r\nregmap_write(mixer->engine.regs, SUN8I_MIXER_BLEND_MODE(0),\r\nSUN8I_MIXER_BLEND_MODE_DEF);\r\nregmap_write(mixer->engine.regs, SUN8I_MIXER_BLEND_CK_CTL,\r\nSUN8I_MIXER_BLEND_CK_CTL_DEF);\r\nregmap_write(mixer->engine.regs,\r\nSUN8I_MIXER_BLEND_ATTR_FCOLOR(0),\r\nSUN8I_MIXER_BLEND_ATTR_FCOLOR_DEF);\r\nDRM_DEBUG_DRIVER("Selecting channel %d (first UI channel)\n",\r\nmixer->cfg->vi_num);\r\nregmap_write(mixer->engine.regs, SUN8I_MIXER_BLEND_ROUTE,\r\nmixer->cfg->vi_num);\r\nreturn 0;\r\nerr_disable_bus_clk:\r\nclk_disable_unprepare(mixer->bus_clk);\r\nerr_assert_reset:\r\nreset_control_assert(mixer->reset);\r\nreturn ret;\r\n}\r\nstatic void sun8i_mixer_unbind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\nstruct sun8i_mixer *mixer = dev_get_drvdata(dev);\r\nlist_del(&mixer->engine.list);\r\nclk_disable_unprepare(mixer->mod_clk);\r\nclk_disable_unprepare(mixer->bus_clk);\r\nreset_control_assert(mixer->reset);\r\n}\r\nstatic int sun8i_mixer_probe(struct platform_device *pdev)\r\n{\r\nreturn component_add(&pdev->dev, &sun8i_mixer_ops);\r\n}\r\nstatic int sun8i_mixer_remove(struct platform_device *pdev)\r\n{\r\ncomponent_del(&pdev->dev, &sun8i_mixer_ops);\r\nreturn 0;\r\n}
