static void nft_jhash_eval(const struct nft_expr *expr,\r\nstruct nft_regs *regs,\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nstruct nft_jhash *priv = nft_expr_priv(expr);\r\nconst void *data = &regs->data[priv->sreg];\r\nu32 h;\r\nh = reciprocal_scale(jhash(data, priv->len, priv->seed), priv->modulus);\r\nregs->data[priv->dreg] = h + priv->offset;\r\n}\r\nstatic void nft_symhash_eval(const struct nft_expr *expr,\r\nstruct nft_regs *regs,\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nstruct nft_symhash *priv = nft_expr_priv(expr);\r\nstruct sk_buff *skb = pkt->skb;\r\nu32 h;\r\nh = reciprocal_scale(__skb_get_hash_symmetric(skb), priv->modulus);\r\nregs->data[priv->dreg] = h + priv->offset;\r\n}\r\nstatic int nft_jhash_init(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr,\r\nconst struct nlattr * const tb[])\r\n{\r\nstruct nft_jhash *priv = nft_expr_priv(expr);\r\nu32 len;\r\nint err;\r\nif (!tb[NFTA_HASH_SREG] ||\r\n!tb[NFTA_HASH_DREG] ||\r\n!tb[NFTA_HASH_LEN] ||\r\n!tb[NFTA_HASH_MODULUS])\r\nreturn -EINVAL;\r\nif (tb[NFTA_HASH_OFFSET])\r\npriv->offset = ntohl(nla_get_be32(tb[NFTA_HASH_OFFSET]));\r\npriv->sreg = nft_parse_register(tb[NFTA_HASH_SREG]);\r\npriv->dreg = nft_parse_register(tb[NFTA_HASH_DREG]);\r\nerr = nft_parse_u32_check(tb[NFTA_HASH_LEN], U8_MAX, &len);\r\nif (err < 0)\r\nreturn err;\r\nif (len == 0)\r\nreturn -ERANGE;\r\npriv->len = len;\r\npriv->modulus = ntohl(nla_get_be32(tb[NFTA_HASH_MODULUS]));\r\nif (priv->modulus <= 1)\r\nreturn -ERANGE;\r\nif (priv->offset + priv->modulus - 1 < priv->offset)\r\nreturn -EOVERFLOW;\r\nif (tb[NFTA_HASH_SEED]) {\r\npriv->seed = ntohl(nla_get_be32(tb[NFTA_HASH_SEED]));\r\n} else {\r\npriv->autogen_seed = true;\r\nget_random_bytes(&priv->seed, sizeof(priv->seed));\r\n}\r\nreturn nft_validate_register_load(priv->sreg, len) &&\r\nnft_validate_register_store(ctx, priv->dreg, NULL,\r\nNFT_DATA_VALUE, sizeof(u32));\r\n}\r\nstatic int nft_symhash_init(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr,\r\nconst struct nlattr * const tb[])\r\n{\r\nstruct nft_symhash *priv = nft_expr_priv(expr);\r\nif (!tb[NFTA_HASH_DREG] ||\r\n!tb[NFTA_HASH_MODULUS])\r\nreturn -EINVAL;\r\nif (tb[NFTA_HASH_OFFSET])\r\npriv->offset = ntohl(nla_get_be32(tb[NFTA_HASH_OFFSET]));\r\npriv->dreg = nft_parse_register(tb[NFTA_HASH_DREG]);\r\npriv->modulus = ntohl(nla_get_be32(tb[NFTA_HASH_MODULUS]));\r\nif (priv->modulus <= 1)\r\nreturn -ERANGE;\r\nif (priv->offset + priv->modulus - 1 < priv->offset)\r\nreturn -EOVERFLOW;\r\nreturn nft_validate_register_store(ctx, priv->dreg, NULL,\r\nNFT_DATA_VALUE, sizeof(u32));\r\n}\r\nstatic int nft_jhash_dump(struct sk_buff *skb,\r\nconst struct nft_expr *expr)\r\n{\r\nconst struct nft_jhash *priv = nft_expr_priv(expr);\r\nif (nft_dump_register(skb, NFTA_HASH_SREG, priv->sreg))\r\ngoto nla_put_failure;\r\nif (nft_dump_register(skb, NFTA_HASH_DREG, priv->dreg))\r\ngoto nla_put_failure;\r\nif (nla_put_be32(skb, NFTA_HASH_LEN, htonl(priv->len)))\r\ngoto nla_put_failure;\r\nif (nla_put_be32(skb, NFTA_HASH_MODULUS, htonl(priv->modulus)))\r\ngoto nla_put_failure;\r\nif (!priv->autogen_seed &&\r\nnla_put_be32(skb, NFTA_HASH_SEED, htonl(priv->seed)))\r\ngoto nla_put_failure;\r\nif (priv->offset != 0)\r\nif (nla_put_be32(skb, NFTA_HASH_OFFSET, htonl(priv->offset)))\r\ngoto nla_put_failure;\r\nif (nla_put_be32(skb, NFTA_HASH_TYPE, htonl(NFT_HASH_JENKINS)))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic int nft_symhash_dump(struct sk_buff *skb,\r\nconst struct nft_expr *expr)\r\n{\r\nconst struct nft_symhash *priv = nft_expr_priv(expr);\r\nif (nft_dump_register(skb, NFTA_HASH_DREG, priv->dreg))\r\ngoto nla_put_failure;\r\nif (nla_put_be32(skb, NFTA_HASH_MODULUS, htonl(priv->modulus)))\r\ngoto nla_put_failure;\r\nif (priv->offset != 0)\r\nif (nla_put_be32(skb, NFTA_HASH_OFFSET, htonl(priv->offset)))\r\ngoto nla_put_failure;\r\nif (nla_put_be32(skb, NFTA_HASH_TYPE, htonl(NFT_HASH_SYM)))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic const struct nft_expr_ops *\r\nnft_hash_select_ops(const struct nft_ctx *ctx,\r\nconst struct nlattr * const tb[])\r\n{\r\nu32 type;\r\nif (!tb[NFTA_HASH_TYPE])\r\nreturn &nft_jhash_ops;\r\ntype = ntohl(nla_get_be32(tb[NFTA_HASH_TYPE]));\r\nswitch (type) {\r\ncase NFT_HASH_SYM:\r\nreturn &nft_symhash_ops;\r\ncase NFT_HASH_JENKINS:\r\nreturn &nft_jhash_ops;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ERR_PTR(-EOPNOTSUPP);\r\n}\r\nstatic int __init nft_hash_module_init(void)\r\n{\r\nreturn nft_register_expr(&nft_hash_type);\r\n}\r\nstatic void __exit nft_hash_module_exit(void)\r\n{\r\nnft_unregister_expr(&nft_hash_type);\r\n}
