static void cpm2_mask_irq(struct irq_data *d)\r\n{\r\nint bit, word;\r\nunsigned int irq_nr = irqd_to_hwirq(d);\r\nbit = irq_to_siubit[irq_nr];\r\nword = irq_to_siureg[irq_nr];\r\nppc_cached_irq_mask[word] &= ~(1 << bit);\r\nout_be32(&cpm2_intctl->ic_simrh + word, ppc_cached_irq_mask[word]);\r\n}\r\nstatic void cpm2_unmask_irq(struct irq_data *d)\r\n{\r\nint bit, word;\r\nunsigned int irq_nr = irqd_to_hwirq(d);\r\nbit = irq_to_siubit[irq_nr];\r\nword = irq_to_siureg[irq_nr];\r\nppc_cached_irq_mask[word] |= 1 << bit;\r\nout_be32(&cpm2_intctl->ic_simrh + word, ppc_cached_irq_mask[word]);\r\n}\r\nstatic void cpm2_ack(struct irq_data *d)\r\n{\r\nint bit, word;\r\nunsigned int irq_nr = irqd_to_hwirq(d);\r\nbit = irq_to_siubit[irq_nr];\r\nword = irq_to_siureg[irq_nr];\r\nout_be32(&cpm2_intctl->ic_sipnrh + word, 1 << bit);\r\n}\r\nstatic void cpm2_end_irq(struct irq_data *d)\r\n{\r\nint bit, word;\r\nunsigned int irq_nr = irqd_to_hwirq(d);\r\nbit = irq_to_siubit[irq_nr];\r\nword = irq_to_siureg[irq_nr];\r\nppc_cached_irq_mask[word] |= 1 << bit;\r\nout_be32(&cpm2_intctl->ic_simrh + word, ppc_cached_irq_mask[word]);\r\nmb();\r\n}\r\nstatic int cpm2_set_irq_type(struct irq_data *d, unsigned int flow_type)\r\n{\r\nunsigned int src = irqd_to_hwirq(d);\r\nunsigned int vold, vnew, edibit;\r\nif (src >= CPM2_IRQ_PORTC15 && src <= CPM2_IRQ_PORTC0) {\r\nif (flow_type == IRQ_TYPE_NONE)\r\nflow_type = IRQ_TYPE_EDGE_BOTH;\r\nif (flow_type != IRQ_TYPE_EDGE_BOTH &&\r\nflow_type != IRQ_TYPE_EDGE_FALLING)\r\ngoto err_sense;\r\n} else {\r\nif (flow_type == IRQ_TYPE_NONE)\r\nflow_type = IRQ_TYPE_LEVEL_LOW;\r\nif (flow_type & (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_LEVEL_HIGH))\r\ngoto err_sense;\r\n}\r\nirqd_set_trigger_type(d, flow_type);\r\nif (flow_type & IRQ_TYPE_LEVEL_LOW)\r\nirq_set_handler_locked(d, handle_level_irq);\r\nelse\r\nirq_set_handler_locked(d, handle_edge_irq);\r\nif (src >= CPM2_IRQ_EXT1 && src <= CPM2_IRQ_EXT7)\r\nedibit = (14 - (src - CPM2_IRQ_EXT1));\r\nelse\r\nif (src >= CPM2_IRQ_PORTC15 && src <= CPM2_IRQ_PORTC0)\r\nedibit = (31 - (CPM2_IRQ_PORTC0 - src));\r\nelse\r\nreturn (flow_type & IRQ_TYPE_LEVEL_LOW) ?\r\nIRQ_SET_MASK_OK_NOCOPY : -EINVAL;\r\nvold = in_be32(&cpm2_intctl->ic_siexr);\r\nif ((flow_type & IRQ_TYPE_SENSE_MASK) == IRQ_TYPE_EDGE_FALLING)\r\nvnew = vold | (1 << edibit);\r\nelse\r\nvnew = vold & ~(1 << edibit);\r\nif (vold != vnew)\r\nout_be32(&cpm2_intctl->ic_siexr, vnew);\r\nreturn IRQ_SET_MASK_OK_NOCOPY;\r\nerr_sense:\r\npr_err("CPM2 PIC: sense type 0x%x not supported\n", flow_type);\r\nreturn -EINVAL;\r\n}\r\nunsigned int cpm2_get_irq(void)\r\n{\r\nint irq;\r\nunsigned long bits;\r\nbits = in_be32(&cpm2_intctl->ic_sivec);\r\nirq = bits >> 26;\r\nif (irq == 0)\r\nreturn(-1);\r\nreturn irq_linear_revmap(cpm2_pic_host, irq);\r\n}\r\nstatic int cpm2_pic_host_map(struct irq_domain *h, unsigned int virq,\r\nirq_hw_number_t hw)\r\n{\r\npr_debug("cpm2_pic_host_map(%d, 0x%lx)\n", virq, hw);\r\nirq_set_status_flags(virq, IRQ_LEVEL);\r\nirq_set_chip_and_handler(virq, &cpm2_pic, handle_level_irq);\r\nreturn 0;\r\n}\r\nvoid cpm2_pic_init(struct device_node *node)\r\n{\r\nint i;\r\ncpm2_intctl = cpm2_map(im_intctl);\r\nout_be32(&cpm2_intctl->ic_simrh, 0x00000000);\r\nout_be32(&cpm2_intctl->ic_simrl, 0x00000000);\r\nwmb();\r\nout_be32(&cpm2_intctl->ic_sipnrh, 0xffffffff);\r\nout_be32(&cpm2_intctl->ic_sipnrl, 0xffffffff);\r\nwmb();\r\ni = in_be32(&cpm2_intctl->ic_sivec);\r\nrmb();\r\nout_be16(&cpm2_intctl->ic_sicr, 0);\r\nout_be32(&cpm2_intctl->ic_scprrh, 0x05309770);\r\nout_be32(&cpm2_intctl->ic_scprrl, 0x05309770);\r\ncpm2_pic_host = irq_domain_add_linear(node, 64, &cpm2_pic_host_ops, NULL);\r\nif (cpm2_pic_host == NULL) {\r\nprintk(KERN_ERR "CPM2 PIC: failed to allocate irq host!\n");\r\nreturn;\r\n}\r\n}
