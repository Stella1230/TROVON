static int\r\nil4965_verify_inst_sparse(struct il_priv *il, __le32 * image, u32 len)\r\n{\r\nu32 val;\r\nint ret = 0;\r\nu32 errcnt = 0;\r\nu32 i;\r\nD_INFO("ucode inst image size is %u\n", len);\r\nfor (i = 0; i < len; i += 100, image += 100 / sizeof(u32)) {\r\nil_wr(il, HBUS_TARG_MEM_RADDR, i + IL4965_RTC_INST_LOWER_BOUND);\r\nval = _il_rd(il, HBUS_TARG_MEM_RDAT);\r\nif (val != le32_to_cpu(*image)) {\r\nret = -EIO;\r\nerrcnt++;\r\nif (errcnt >= 3)\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nil4965_verify_inst_full(struct il_priv *il, __le32 * image, u32 len)\r\n{\r\nu32 val;\r\nu32 save_len = len;\r\nint ret = 0;\r\nu32 errcnt;\r\nD_INFO("ucode inst image size is %u\n", len);\r\nil_wr(il, HBUS_TARG_MEM_RADDR, IL4965_RTC_INST_LOWER_BOUND);\r\nerrcnt = 0;\r\nfor (; len > 0; len -= sizeof(u32), image++) {\r\nval = _il_rd(il, HBUS_TARG_MEM_RDAT);\r\nif (val != le32_to_cpu(*image)) {\r\nIL_ERR("uCode INST section is invalid at "\r\n"offset 0x%x, is 0x%x, s/b 0x%x\n",\r\nsave_len - len, val, le32_to_cpu(*image));\r\nret = -EIO;\r\nerrcnt++;\r\nif (errcnt >= 20)\r\nbreak;\r\n}\r\n}\r\nif (!errcnt)\r\nD_INFO("ucode image in INSTRUCTION memory is good\n");\r\nreturn ret;\r\n}\r\nint\r\nil4965_verify_ucode(struct il_priv *il)\r\n{\r\n__le32 *image;\r\nu32 len;\r\nint ret;\r\nimage = (__le32 *) il->ucode_boot.v_addr;\r\nlen = il->ucode_boot.len;\r\nret = il4965_verify_inst_sparse(il, image, len);\r\nif (!ret) {\r\nD_INFO("Bootstrap uCode is good in inst SRAM\n");\r\nreturn 0;\r\n}\r\nimage = (__le32 *) il->ucode_init.v_addr;\r\nlen = il->ucode_init.len;\r\nret = il4965_verify_inst_sparse(il, image, len);\r\nif (!ret) {\r\nD_INFO("Initialize uCode is good in inst SRAM\n");\r\nreturn 0;\r\n}\r\nimage = (__le32 *) il->ucode_code.v_addr;\r\nlen = il->ucode_code.len;\r\nret = il4965_verify_inst_sparse(il, image, len);\r\nif (!ret) {\r\nD_INFO("Runtime uCode is good in inst SRAM\n");\r\nreturn 0;\r\n}\r\nIL_ERR("NO VALID UCODE IMAGE IN INSTRUCTION SRAM!!\n");\r\nimage = (__le32 *) il->ucode_boot.v_addr;\r\nlen = il->ucode_boot.len;\r\nret = il4965_verify_inst_full(il, image, len);\r\nreturn ret;\r\n}\r\nint\r\nil4965_eeprom_acquire_semaphore(struct il_priv *il)\r\n{\r\nu16 count;\r\nint ret;\r\nfor (count = 0; count < EEPROM_SEM_RETRY_LIMIT; count++) {\r\nil_set_bit(il, CSR_HW_IF_CONFIG_REG,\r\nCSR_HW_IF_CONFIG_REG_BIT_EEPROM_OWN_SEM);\r\nret =\r\n_il_poll_bit(il, CSR_HW_IF_CONFIG_REG,\r\nCSR_HW_IF_CONFIG_REG_BIT_EEPROM_OWN_SEM,\r\nCSR_HW_IF_CONFIG_REG_BIT_EEPROM_OWN_SEM,\r\nEEPROM_SEM_TIMEOUT);\r\nif (ret >= 0)\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nvoid\r\nil4965_eeprom_release_semaphore(struct il_priv *il)\r\n{\r\nil_clear_bit(il, CSR_HW_IF_CONFIG_REG,\r\nCSR_HW_IF_CONFIG_REG_BIT_EEPROM_OWN_SEM);\r\n}\r\nint\r\nil4965_eeprom_check_version(struct il_priv *il)\r\n{\r\nu16 eeprom_ver;\r\nu16 calib_ver;\r\neeprom_ver = il_eeprom_query16(il, EEPROM_VERSION);\r\ncalib_ver = il_eeprom_query16(il, EEPROM_4965_CALIB_VERSION_OFFSET);\r\nif (eeprom_ver < il->cfg->eeprom_ver ||\r\ncalib_ver < il->cfg->eeprom_calib_ver)\r\ngoto err;\r\nIL_INFO("device EEPROM VER=0x%x, CALIB=0x%x\n", eeprom_ver, calib_ver);\r\nreturn 0;\r\nerr:\r\nIL_ERR("Unsupported (too old) EEPROM VER=0x%x < 0x%x "\r\n"CALIB=0x%x < 0x%x\n", eeprom_ver, il->cfg->eeprom_ver,\r\ncalib_ver, il->cfg->eeprom_calib_ver);\r\nreturn -EINVAL;\r\n}\r\nvoid\r\nil4965_eeprom_get_mac(const struct il_priv *il, u8 * mac)\r\n{\r\nconst u8 *addr = il_eeprom_query_addr(il,\r\nEEPROM_MAC_ADDRESS);\r\nmemcpy(mac, addr, ETH_ALEN);\r\n}\r\nstatic int\r\nil4965_send_led_cmd(struct il_priv *il, struct il_led_cmd *led_cmd)\r\n{\r\nstruct il_host_cmd cmd = {\r\n.id = C_LEDS,\r\n.len = sizeof(struct il_led_cmd),\r\n.data = led_cmd,\r\n.flags = CMD_ASYNC,\r\n.callback = NULL,\r\n};\r\nu32 reg;\r\nreg = _il_rd(il, CSR_LED_REG);\r\nif (reg != (reg & CSR_LED_BSM_CTRL_MSK))\r\n_il_wr(il, CSR_LED_REG, reg & CSR_LED_BSM_CTRL_MSK);\r\nreturn il_send_cmd(il, &cmd);\r\n}\r\nvoid\r\nil4965_led_enable(struct il_priv *il)\r\n{\r\n_il_wr(il, CSR_LED_REG, CSR_LED_REG_TRUN_ON);\r\n}\r\nstatic int\r\nil4965_verify_bsm(struct il_priv *il)\r\n{\r\n__le32 *image = il->ucode_boot.v_addr;\r\nu32 len = il->ucode_boot.len;\r\nu32 reg;\r\nu32 val;\r\nD_INFO("Begin verify bsm\n");\r\nval = il_rd_prph(il, BSM_WR_DWCOUNT_REG);\r\nfor (reg = BSM_SRAM_LOWER_BOUND; reg < BSM_SRAM_LOWER_BOUND + len;\r\nreg += sizeof(u32), image++) {\r\nval = il_rd_prph(il, reg);\r\nif (val != le32_to_cpu(*image)) {\r\nIL_ERR("BSM uCode verification failed at "\r\n"addr 0x%08X+%u (of %u), is 0x%x, s/b 0x%x\n",\r\nBSM_SRAM_LOWER_BOUND, reg - BSM_SRAM_LOWER_BOUND,\r\nlen, val, le32_to_cpu(*image));\r\nreturn -EIO;\r\n}\r\n}\r\nD_INFO("BSM bootstrap uCode image OK\n");\r\nreturn 0;\r\n}\r\nstatic int\r\nil4965_load_bsm(struct il_priv *il)\r\n{\r\n__le32 *image = il->ucode_boot.v_addr;\r\nu32 len = il->ucode_boot.len;\r\ndma_addr_t pinst;\r\ndma_addr_t pdata;\r\nu32 inst_len;\r\nu32 data_len;\r\nint i;\r\nu32 done;\r\nu32 reg_offset;\r\nint ret;\r\nD_INFO("Begin load bsm\n");\r\nil->ucode_type = UCODE_RT;\r\nif (len > IL49_MAX_BSM_SIZE)\r\nreturn -EINVAL;\r\npinst = il->ucode_init.p_addr >> 4;\r\npdata = il->ucode_init_data.p_addr >> 4;\r\ninst_len = il->ucode_init.len;\r\ndata_len = il->ucode_init_data.len;\r\nil_wr_prph(il, BSM_DRAM_INST_PTR_REG, pinst);\r\nil_wr_prph(il, BSM_DRAM_DATA_PTR_REG, pdata);\r\nil_wr_prph(il, BSM_DRAM_INST_BYTECOUNT_REG, inst_len);\r\nil_wr_prph(il, BSM_DRAM_DATA_BYTECOUNT_REG, data_len);\r\nfor (reg_offset = BSM_SRAM_LOWER_BOUND;\r\nreg_offset < BSM_SRAM_LOWER_BOUND + len;\r\nreg_offset += sizeof(u32), image++)\r\n_il_wr_prph(il, reg_offset, le32_to_cpu(*image));\r\nret = il4965_verify_bsm(il);\r\nif (ret)\r\nreturn ret;\r\nil_wr_prph(il, BSM_WR_MEM_SRC_REG, 0x0);\r\nil_wr_prph(il, BSM_WR_MEM_DST_REG, IL49_RTC_INST_LOWER_BOUND);\r\nil_wr_prph(il, BSM_WR_DWCOUNT_REG, len / sizeof(u32));\r\nil_wr_prph(il, BSM_WR_CTRL_REG, BSM_WR_CTRL_REG_BIT_START);\r\nfor (i = 0; i < 100; i++) {\r\ndone = il_rd_prph(il, BSM_WR_CTRL_REG);\r\nif (!(done & BSM_WR_CTRL_REG_BIT_START))\r\nbreak;\r\nudelay(10);\r\n}\r\nif (i < 100)\r\nD_INFO("BSM write complete, poll %d iterations\n", i);\r\nelse {\r\nIL_ERR("BSM write did not complete!\n");\r\nreturn -EIO;\r\n}\r\nil_wr_prph(il, BSM_WR_CTRL_REG, BSM_WR_CTRL_REG_BIT_START_EN);\r\nreturn 0;\r\n}\r\nstatic int\r\nil4965_set_ucode_ptrs(struct il_priv *il)\r\n{\r\ndma_addr_t pinst;\r\ndma_addr_t pdata;\r\nint ret = 0;\r\npinst = il->ucode_code.p_addr >> 4;\r\npdata = il->ucode_data_backup.p_addr >> 4;\r\nil_wr_prph(il, BSM_DRAM_INST_PTR_REG, pinst);\r\nil_wr_prph(il, BSM_DRAM_DATA_PTR_REG, pdata);\r\nil_wr_prph(il, BSM_DRAM_DATA_BYTECOUNT_REG, il->ucode_data.len);\r\nil_wr_prph(il, BSM_DRAM_INST_BYTECOUNT_REG,\r\nil->ucode_code.len | BSM_DRAM_INST_LOAD);\r\nD_INFO("Runtime uCode pointers are set.\n");\r\nreturn ret;\r\n}\r\nstatic void\r\nil4965_init_alive_start(struct il_priv *il)\r\n{\r\nif (il4965_verify_ucode(il)) {\r\nD_INFO("Bad \"initialize\" uCode load.\n");\r\ngoto restart;\r\n}\r\nil->temperature = il4965_hw_get_temperature(il);\r\nD_INFO("Initialization Alive received.\n");\r\nif (il4965_set_ucode_ptrs(il)) {\r\nD_INFO("Couldn't set up uCode pointers.\n");\r\ngoto restart;\r\n}\r\nreturn;\r\nrestart:\r\nqueue_work(il->workqueue, &il->restart);\r\n}\r\nstatic bool\r\niw4965_is_ht40_channel(__le32 rxon_flags)\r\n{\r\nint chan_mod =\r\nle32_to_cpu(rxon_flags & RXON_FLG_CHANNEL_MODE_MSK) >>\r\nRXON_FLG_CHANNEL_MODE_POS;\r\nreturn (chan_mod == CHANNEL_MODE_PURE_40 ||\r\nchan_mod == CHANNEL_MODE_MIXED);\r\n}\r\nvoid\r\nil4965_nic_config(struct il_priv *il)\r\n{\r\nunsigned long flags;\r\nu16 radio_cfg;\r\nspin_lock_irqsave(&il->lock, flags);\r\nradio_cfg = il_eeprom_query16(il, EEPROM_RADIO_CONFIG);\r\nif (EEPROM_RF_CFG_TYPE_MSK(radio_cfg) == EEPROM_4965_RF_CFG_TYPE_MAX)\r\nil_set_bit(il, CSR_HW_IF_CONFIG_REG,\r\nEEPROM_RF_CFG_TYPE_MSK(radio_cfg) |\r\nEEPROM_RF_CFG_STEP_MSK(radio_cfg) |\r\nEEPROM_RF_CFG_DASH_MSK(radio_cfg));\r\nil_set_bit(il, CSR_HW_IF_CONFIG_REG,\r\nCSR_HW_IF_CONFIG_REG_BIT_RADIO_SI |\r\nCSR_HW_IF_CONFIG_REG_BIT_MAC_SI);\r\nil->calib_info =\r\n(struct il_eeprom_calib_info *)\r\nil_eeprom_query_addr(il, EEPROM_4965_CALIB_TXPOWER_OFFSET);\r\nspin_unlock_irqrestore(&il->lock, flags);\r\n}\r\nstatic void\r\nil4965_chain_noise_reset(struct il_priv *il)\r\n{\r\nstruct il_chain_noise_data *data = &(il->chain_noise_data);\r\nif (data->state == IL_CHAIN_NOISE_ALIVE && il_is_any_associated(il)) {\r\nstruct il_calib_diff_gain_cmd cmd;\r\ndata->chain_noise_a = 0;\r\ndata->chain_noise_b = 0;\r\ndata->chain_noise_c = 0;\r\ndata->chain_signal_a = 0;\r\ndata->chain_signal_b = 0;\r\ndata->chain_signal_c = 0;\r\ndata->beacon_count = 0;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.hdr.op_code = IL_PHY_CALIBRATE_DIFF_GAIN_CMD;\r\ncmd.diff_gain_a = 0;\r\ncmd.diff_gain_b = 0;\r\ncmd.diff_gain_c = 0;\r\nif (il_send_cmd_pdu(il, C_PHY_CALIBRATION, sizeof(cmd), &cmd))\r\nIL_ERR("Could not send C_PHY_CALIBRATION\n");\r\ndata->state = IL_CHAIN_NOISE_ACCUMULATE;\r\nD_CALIB("Run chain_noise_calibrate\n");\r\n}\r\n}\r\nstatic s32\r\nil4965_math_div_round(s32 num, s32 denom, s32 * res)\r\n{\r\ns32 sign = 1;\r\nif (num < 0) {\r\nsign = -sign;\r\nnum = -num;\r\n}\r\nif (denom < 0) {\r\nsign = -sign;\r\ndenom = -denom;\r\n}\r\n*res = 1;\r\n*res = ((num * 2 + denom) / (denom * 2)) * sign;\r\nreturn 1;\r\n}\r\nstatic s32\r\nil4965_get_voltage_compensation(s32 eeprom_voltage, s32 current_voltage)\r\n{\r\ns32 comp = 0;\r\nif (TX_POWER_IL_ILLEGAL_VOLTAGE == eeprom_voltage ||\r\nTX_POWER_IL_ILLEGAL_VOLTAGE == current_voltage)\r\nreturn 0;\r\nil4965_math_div_round(current_voltage - eeprom_voltage,\r\nTX_POWER_IL_VOLTAGE_CODES_PER_03V, &comp);\r\nif (current_voltage > eeprom_voltage)\r\ncomp *= 2;\r\nif ((comp < -2) || (comp > 2))\r\ncomp = 0;\r\nreturn comp;\r\n}\r\nstatic s32\r\nil4965_get_tx_atten_grp(u16 channel)\r\n{\r\nif (channel >= CALIB_IL_TX_ATTEN_GR5_FCH &&\r\nchannel <= CALIB_IL_TX_ATTEN_GR5_LCH)\r\nreturn CALIB_CH_GROUP_5;\r\nif (channel >= CALIB_IL_TX_ATTEN_GR1_FCH &&\r\nchannel <= CALIB_IL_TX_ATTEN_GR1_LCH)\r\nreturn CALIB_CH_GROUP_1;\r\nif (channel >= CALIB_IL_TX_ATTEN_GR2_FCH &&\r\nchannel <= CALIB_IL_TX_ATTEN_GR2_LCH)\r\nreturn CALIB_CH_GROUP_2;\r\nif (channel >= CALIB_IL_TX_ATTEN_GR3_FCH &&\r\nchannel <= CALIB_IL_TX_ATTEN_GR3_LCH)\r\nreturn CALIB_CH_GROUP_3;\r\nif (channel >= CALIB_IL_TX_ATTEN_GR4_FCH &&\r\nchannel <= CALIB_IL_TX_ATTEN_GR4_LCH)\r\nreturn CALIB_CH_GROUP_4;\r\nreturn -EINVAL;\r\n}\r\nstatic u32\r\nil4965_get_sub_band(const struct il_priv *il, u32 channel)\r\n{\r\ns32 b = -1;\r\nfor (b = 0; b < EEPROM_TX_POWER_BANDS; b++) {\r\nif (il->calib_info->band_info[b].ch_from == 0)\r\ncontinue;\r\nif (channel >= il->calib_info->band_info[b].ch_from &&\r\nchannel <= il->calib_info->band_info[b].ch_to)\r\nbreak;\r\n}\r\nreturn b;\r\n}\r\nstatic s32\r\nil4965_interpolate_value(s32 x, s32 x1, s32 y1, s32 x2, s32 y2)\r\n{\r\ns32 val;\r\nif (x2 == x1)\r\nreturn y1;\r\nelse {\r\nil4965_math_div_round((x2 - x) * (y1 - y2), (x2 - x1), &val);\r\nreturn val + y2;\r\n}\r\n}\r\nstatic int\r\nil4965_interpolate_chan(struct il_priv *il, u32 channel,\r\nstruct il_eeprom_calib_ch_info *chan_info)\r\n{\r\ns32 s = -1;\r\nu32 c;\r\nu32 m;\r\nconst struct il_eeprom_calib_measure *m1;\r\nconst struct il_eeprom_calib_measure *m2;\r\nstruct il_eeprom_calib_measure *omeas;\r\nu32 ch_i1;\r\nu32 ch_i2;\r\ns = il4965_get_sub_band(il, channel);\r\nif (s >= EEPROM_TX_POWER_BANDS) {\r\nIL_ERR("Tx Power can not find channel %d\n", channel);\r\nreturn -1;\r\n}\r\nch_i1 = il->calib_info->band_info[s].ch1.ch_num;\r\nch_i2 = il->calib_info->band_info[s].ch2.ch_num;\r\nchan_info->ch_num = (u8) channel;\r\nD_TXPOWER("channel %d subband %d factory cal ch %d & %d\n", channel, s,\r\nch_i1, ch_i2);\r\nfor (c = 0; c < EEPROM_TX_POWER_TX_CHAINS; c++) {\r\nfor (m = 0; m < EEPROM_TX_POWER_MEASUREMENTS; m++) {\r\nm1 = &(il->calib_info->band_info[s].ch1.\r\nmeasurements[c][m]);\r\nm2 = &(il->calib_info->band_info[s].ch2.\r\nmeasurements[c][m]);\r\nomeas = &(chan_info->measurements[c][m]);\r\nomeas->actual_pow =\r\n(u8) il4965_interpolate_value(channel, ch_i1,\r\nm1->actual_pow, ch_i2,\r\nm2->actual_pow);\r\nomeas->gain_idx =\r\n(u8) il4965_interpolate_value(channel, ch_i1,\r\nm1->gain_idx, ch_i2,\r\nm2->gain_idx);\r\nomeas->temperature =\r\n(u8) il4965_interpolate_value(channel, ch_i1,\r\nm1->temperature,\r\nch_i2,\r\nm2->temperature);\r\nomeas->pa_det =\r\n(s8) il4965_interpolate_value(channel, ch_i1,\r\nm1->pa_det, ch_i2,\r\nm2->pa_det);\r\nD_TXPOWER("chain %d meas %d AP1=%d AP2=%d AP=%d\n", c,\r\nm, m1->actual_pow, m2->actual_pow,\r\nomeas->actual_pow);\r\nD_TXPOWER("chain %d meas %d NI1=%d NI2=%d NI=%d\n", c,\r\nm, m1->gain_idx, m2->gain_idx,\r\nomeas->gain_idx);\r\nD_TXPOWER("chain %d meas %d PA1=%d PA2=%d PA=%d\n", c,\r\nm, m1->pa_det, m2->pa_det, omeas->pa_det);\r\nD_TXPOWER("chain %d meas %d T1=%d T2=%d T=%d\n", c,\r\nm, m1->temperature, m2->temperature,\r\nomeas->temperature);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic s32\r\nget_min_power_idx(s32 rate_power_idx, u32 band)\r\n{\r\nif (!band) {\r\nif ((rate_power_idx & 7) <= 4)\r\nreturn MIN_TX_GAIN_IDX_52GHZ_EXT;\r\n}\r\nreturn MIN_TX_GAIN_IDX;\r\n}\r\nstatic int\r\nil4965_fill_txpower_tbl(struct il_priv *il, u8 band, u16 channel, u8 is_ht40,\r\nu8 ctrl_chan_high,\r\nstruct il4965_tx_power_db *tx_power_tbl)\r\n{\r\nu8 saturation_power;\r\ns32 target_power;\r\ns32 user_target_power;\r\ns32 power_limit;\r\ns32 current_temp;\r\ns32 reg_limit;\r\ns32 current_regulatory;\r\ns32 txatten_grp = CALIB_CH_GROUP_MAX;\r\nint i;\r\nint c;\r\nconst struct il_channel_info *ch_info = NULL;\r\nstruct il_eeprom_calib_ch_info ch_eeprom_info;\r\nconst struct il_eeprom_calib_measure *measurement;\r\ns16 voltage;\r\ns32 init_voltage;\r\ns32 voltage_compensation;\r\ns32 degrees_per_05db_num;\r\ns32 degrees_per_05db_denom;\r\ns32 factory_temp;\r\ns32 temperature_comp[2];\r\ns32 factory_gain_idx[2];\r\ns32 factory_actual_pwr[2];\r\ns32 power_idx;\r\nuser_target_power = 2 * il->tx_power_user_lmt;\r\nD_TXPOWER("chan %d band %d is_ht40 %d\n", channel, band, is_ht40);\r\nch_info = il_get_channel_info(il, il->band, channel);\r\nif (!il_is_channel_valid(ch_info))\r\nreturn -EINVAL;\r\ntxatten_grp = il4965_get_tx_atten_grp(channel);\r\nif (txatten_grp < 0) {\r\nIL_ERR("Can't find txatten group for channel %d.\n", channel);\r\nreturn txatten_grp;\r\n}\r\nD_TXPOWER("channel %d belongs to txatten group %d\n", channel,\r\ntxatten_grp);\r\nif (is_ht40) {\r\nif (ctrl_chan_high)\r\nchannel -= 2;\r\nelse\r\nchannel += 2;\r\n}\r\nif (band)\r\nsaturation_power = il->calib_info->saturation_power24;\r\nelse\r\nsaturation_power = il->calib_info->saturation_power52;\r\nif (saturation_power < IL_TX_POWER_SATURATION_MIN ||\r\nsaturation_power > IL_TX_POWER_SATURATION_MAX) {\r\nif (band)\r\nsaturation_power = IL_TX_POWER_DEFAULT_SATURATION_24;\r\nelse\r\nsaturation_power = IL_TX_POWER_DEFAULT_SATURATION_52;\r\n}\r\nif (is_ht40)\r\nreg_limit = ch_info->ht40_max_power_avg * 2;\r\nelse\r\nreg_limit = ch_info->max_power_avg * 2;\r\nif ((reg_limit < IL_TX_POWER_REGULATORY_MIN) ||\r\n(reg_limit > IL_TX_POWER_REGULATORY_MAX)) {\r\nif (band)\r\nreg_limit = IL_TX_POWER_DEFAULT_REGULATORY_24;\r\nelse\r\nreg_limit = IL_TX_POWER_DEFAULT_REGULATORY_52;\r\n}\r\nil4965_interpolate_chan(il, channel, &ch_eeprom_info);\r\nvoltage = le16_to_cpu(il->calib_info->voltage);\r\ninit_voltage = (s32) le32_to_cpu(il->card_alive_init.voltage);\r\nvoltage_compensation =\r\nil4965_get_voltage_compensation(voltage, init_voltage);\r\nD_TXPOWER("curr volt %d eeprom volt %d volt comp %d\n", init_voltage,\r\nvoltage, voltage_compensation);\r\ncurrent_temp = max(il->temperature, IL_TX_POWER_TEMPERATURE_MIN);\r\ncurrent_temp = min(il->temperature, IL_TX_POWER_TEMPERATURE_MAX);\r\ncurrent_temp = KELVIN_TO_CELSIUS(current_temp);\r\ndegrees_per_05db_num =\r\ntx_power_cmp_tble[txatten_grp].degrees_per_05db_a;\r\ndegrees_per_05db_denom =\r\ntx_power_cmp_tble[txatten_grp].degrees_per_05db_a_denom;\r\nfor (c = 0; c < 2; c++) {\r\nmeasurement = &ch_eeprom_info.measurements[c][1];\r\nfactory_temp = measurement->temperature;\r\nil4965_math_div_round((current_temp -\r\nfactory_temp) * degrees_per_05db_denom,\r\ndegrees_per_05db_num,\r\n&temperature_comp[c]);\r\nfactory_gain_idx[c] = measurement->gain_idx;\r\nfactory_actual_pwr[c] = measurement->actual_pow;\r\nD_TXPOWER("chain = %d\n", c);\r\nD_TXPOWER("fctry tmp %d, " "curr tmp %d, comp %d steps\n",\r\nfactory_temp, current_temp, temperature_comp[c]);\r\nD_TXPOWER("fctry idx %d, fctry pwr %d\n", factory_gain_idx[c],\r\nfactory_actual_pwr[c]);\r\n}\r\nfor (i = 0; i < POWER_TBL_NUM_ENTRIES; i++) {\r\nu8 is_mimo_rate;\r\nunion il4965_tx_power_dual_stream tx_power;\r\nif (i & 0x8) {\r\ncurrent_regulatory =\r\nreg_limit -\r\nIL_TX_POWER_MIMO_REGULATORY_COMPENSATION;\r\nis_mimo_rate = 1;\r\n} else {\r\ncurrent_regulatory = reg_limit;\r\nis_mimo_rate = 0;\r\n}\r\npower_limit = saturation_power - back_off_table[i];\r\nif (power_limit > current_regulatory)\r\npower_limit = current_regulatory;\r\ntarget_power = user_target_power;\r\nif (target_power > power_limit)\r\ntarget_power = power_limit;\r\nD_TXPOWER("rate %d sat %d reg %d usr %d tgt %d\n", i,\r\nsaturation_power - back_off_table[i],\r\ncurrent_regulatory, user_target_power, target_power);\r\nfor (c = 0; c < 2; c++) {\r\ns32 atten_value;\r\nif (is_mimo_rate)\r\natten_value =\r\n(s32) le32_to_cpu(il->card_alive_init.\r\ntx_atten[txatten_grp][c]);\r\nelse\r\natten_value = 0;\r\npower_idx =\r\n(u8) (factory_gain_idx[c] -\r\n(target_power - factory_actual_pwr[c]) -\r\ntemperature_comp[c] - voltage_compensation +\r\natten_value);\r\nif (power_idx < get_min_power_idx(i, band))\r\npower_idx = get_min_power_idx(i, band);\r\nif (!band)\r\npower_idx += 9;\r\nif (i == POWER_TBL_CCK_ENTRY)\r\npower_idx +=\r\nIL_TX_POWER_CCK_COMPENSATION_C_STEP;\r\nif (power_idx > 107) {\r\nIL_WARN("txpower idx %d > 107\n", power_idx);\r\npower_idx = 107;\r\n}\r\nif (power_idx < 0) {\r\nIL_WARN("txpower idx %d < 0\n", power_idx);\r\npower_idx = 0;\r\n}\r\ntx_power.s.radio_tx_gain[c] =\r\ngain_table[band][power_idx].radio;\r\ntx_power.s.dsp_predis_atten[c] =\r\ngain_table[band][power_idx].dsp;\r\nD_TXPOWER("chain %d mimo %d idx %d "\r\n"gain 0x%02x dsp %d\n", c, atten_value,\r\npower_idx, tx_power.s.radio_tx_gain[c],\r\ntx_power.s.dsp_predis_atten[c]);\r\n}\r\ntx_power_tbl->power_tbl[i].dw = cpu_to_le32(tx_power.dw);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nil4965_send_tx_power(struct il_priv *il)\r\n{\r\nstruct il4965_txpowertable_cmd cmd = { 0 };\r\nint ret;\r\nu8 band = 0;\r\nbool is_ht40 = false;\r\nu8 ctrl_chan_high = 0;\r\nif (WARN_ONCE\r\n(test_bit(S_SCAN_HW, &il->status),\r\n"TX Power requested while scanning!\n"))\r\nreturn -EAGAIN;\r\nband = il->band == NL80211_BAND_2GHZ;\r\nis_ht40 = iw4965_is_ht40_channel(il->active.flags);\r\nif (is_ht40 && (il->active.flags & RXON_FLG_CTRL_CHANNEL_LOC_HI_MSK))\r\nctrl_chan_high = 1;\r\ncmd.band = band;\r\ncmd.channel = il->active.channel;\r\nret =\r\nil4965_fill_txpower_tbl(il, band, le16_to_cpu(il->active.channel),\r\nis_ht40, ctrl_chan_high, &cmd.tx_power);\r\nif (ret)\r\ngoto out;\r\nret = il_send_cmd_pdu(il, C_TX_PWR_TBL, sizeof(cmd), &cmd);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int\r\nil4965_send_rxon_assoc(struct il_priv *il)\r\n{\r\nint ret = 0;\r\nstruct il4965_rxon_assoc_cmd rxon_assoc;\r\nconst struct il_rxon_cmd *rxon1 = &il->staging;\r\nconst struct il_rxon_cmd *rxon2 = &il->active;\r\nif (rxon1->flags == rxon2->flags &&\r\nrxon1->filter_flags == rxon2->filter_flags &&\r\nrxon1->cck_basic_rates == rxon2->cck_basic_rates &&\r\nrxon1->ofdm_ht_single_stream_basic_rates ==\r\nrxon2->ofdm_ht_single_stream_basic_rates &&\r\nrxon1->ofdm_ht_dual_stream_basic_rates ==\r\nrxon2->ofdm_ht_dual_stream_basic_rates &&\r\nrxon1->rx_chain == rxon2->rx_chain &&\r\nrxon1->ofdm_basic_rates == rxon2->ofdm_basic_rates) {\r\nD_INFO("Using current RXON_ASSOC. Not resending.\n");\r\nreturn 0;\r\n}\r\nrxon_assoc.flags = il->staging.flags;\r\nrxon_assoc.filter_flags = il->staging.filter_flags;\r\nrxon_assoc.ofdm_basic_rates = il->staging.ofdm_basic_rates;\r\nrxon_assoc.cck_basic_rates = il->staging.cck_basic_rates;\r\nrxon_assoc.reserved = 0;\r\nrxon_assoc.ofdm_ht_single_stream_basic_rates =\r\nil->staging.ofdm_ht_single_stream_basic_rates;\r\nrxon_assoc.ofdm_ht_dual_stream_basic_rates =\r\nil->staging.ofdm_ht_dual_stream_basic_rates;\r\nrxon_assoc.rx_chain_select_flags = il->staging.rx_chain;\r\nret =\r\nil_send_cmd_pdu_async(il, C_RXON_ASSOC, sizeof(rxon_assoc),\r\n&rxon_assoc, NULL);\r\nreturn ret;\r\n}\r\nstatic int\r\nil4965_commit_rxon(struct il_priv *il)\r\n{\r\nstruct il_rxon_cmd *active_rxon = (void *)&il->active;\r\nint ret;\r\nbool new_assoc = !!(il->staging.filter_flags & RXON_FILTER_ASSOC_MSK);\r\nif (!il_is_alive(il))\r\nreturn -EBUSY;\r\nil->staging.flags |= RXON_FLG_TSF2HOST_MSK;\r\nret = il_check_rxon_cmd(il);\r\nif (ret) {\r\nIL_ERR("Invalid RXON configuration. Not committing.\n");\r\nreturn -EINVAL;\r\n}\r\nif (test_bit(S_CHANNEL_SWITCH_PENDING, &il->status) &&\r\nil->switch_channel != il->staging.channel) {\r\nD_11H("abort channel switch on %d\n",\r\nle16_to_cpu(il->switch_channel));\r\nil_chswitch_done(il, false);\r\n}\r\nif (!il_full_rxon_required(il)) {\r\nret = il_send_rxon_assoc(il);\r\nif (ret) {\r\nIL_ERR("Error setting RXON_ASSOC (%d)\n", ret);\r\nreturn ret;\r\n}\r\nmemcpy(active_rxon, &il->staging, sizeof(*active_rxon));\r\nil_print_rx_config_cmd(il);\r\nil_set_tx_power(il, il->tx_power_next, false);\r\nreturn 0;\r\n}\r\nif (il_is_associated(il) && new_assoc) {\r\nD_INFO("Toggling associated bit on current RXON\n");\r\nactive_rxon->filter_flags &= ~RXON_FILTER_ASSOC_MSK;\r\nret =\r\nil_send_cmd_pdu(il, C_RXON,\r\nsizeof(struct il_rxon_cmd), active_rxon);\r\nif (ret) {\r\nactive_rxon->filter_flags |= RXON_FILTER_ASSOC_MSK;\r\nIL_ERR("Error clearing ASSOC_MSK (%d)\n", ret);\r\nreturn ret;\r\n}\r\nil_clear_ucode_stations(il);\r\nil_restore_stations(il);\r\nret = il4965_restore_default_wep_keys(il);\r\nif (ret) {\r\nIL_ERR("Failed to restore WEP keys (%d)\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nD_INFO("Sending RXON\n" "* with%s RXON_FILTER_ASSOC_MSK\n"\r\n"* channel = %d\n" "* bssid = %pM\n", (new_assoc ? "" : "out"),\r\nle16_to_cpu(il->staging.channel), il->staging.bssid_addr);\r\nil_set_rxon_hwcrypto(il, !il->cfg->mod_params->sw_crypto);\r\nif (!new_assoc) {\r\nret =\r\nil_send_cmd_pdu(il, C_RXON,\r\nsizeof(struct il_rxon_cmd), &il->staging);\r\nif (ret) {\r\nIL_ERR("Error setting new RXON (%d)\n", ret);\r\nreturn ret;\r\n}\r\nD_INFO("Return from !new_assoc RXON.\n");\r\nmemcpy(active_rxon, &il->staging, sizeof(*active_rxon));\r\nil_clear_ucode_stations(il);\r\nil_restore_stations(il);\r\nret = il4965_restore_default_wep_keys(il);\r\nif (ret) {\r\nIL_ERR("Failed to restore WEP keys (%d)\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nif (new_assoc) {\r\nil->start_calib = 0;\r\nret =\r\nil_send_cmd_pdu(il, C_RXON,\r\nsizeof(struct il_rxon_cmd), &il->staging);\r\nif (ret) {\r\nIL_ERR("Error setting new RXON (%d)\n", ret);\r\nreturn ret;\r\n}\r\nmemcpy(active_rxon, &il->staging, sizeof(*active_rxon));\r\n}\r\nil_print_rx_config_cmd(il);\r\nil4965_init_sensitivity(il);\r\nret = il_set_tx_power(il, il->tx_power_next, true);\r\nif (ret) {\r\nIL_ERR("Error sending TX power (%d)\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nil4965_hw_channel_switch(struct il_priv *il,\r\nstruct ieee80211_channel_switch *ch_switch)\r\n{\r\nint rc;\r\nu8 band = 0;\r\nbool is_ht40 = false;\r\nu8 ctrl_chan_high = 0;\r\nstruct il4965_channel_switch_cmd cmd;\r\nconst struct il_channel_info *ch_info;\r\nu32 switch_time_in_usec, ucode_switch_time;\r\nu16 ch;\r\nu32 tsf_low;\r\nu8 switch_count;\r\nu16 beacon_interval = le16_to_cpu(il->timing.beacon_interval);\r\nstruct ieee80211_vif *vif = il->vif;\r\nband = (il->band == NL80211_BAND_2GHZ);\r\nif (WARN_ON_ONCE(vif == NULL))\r\nreturn -EIO;\r\nis_ht40 = iw4965_is_ht40_channel(il->staging.flags);\r\nif (is_ht40 && (il->staging.flags & RXON_FLG_CTRL_CHANNEL_LOC_HI_MSK))\r\nctrl_chan_high = 1;\r\ncmd.band = band;\r\ncmd.expect_beacon = 0;\r\nch = ch_switch->chandef.chan->hw_value;\r\ncmd.channel = cpu_to_le16(ch);\r\ncmd.rxon_flags = il->staging.flags;\r\ncmd.rxon_filter_flags = il->staging.filter_flags;\r\nswitch_count = ch_switch->count;\r\ntsf_low = ch_switch->timestamp & 0x0ffffffff;\r\nif (il->ucode_beacon_time > tsf_low && beacon_interval) {\r\nif (switch_count >\r\n((il->ucode_beacon_time - tsf_low) / beacon_interval)) {\r\nswitch_count -=\r\n(il->ucode_beacon_time - tsf_low) / beacon_interval;\r\n} else\r\nswitch_count = 0;\r\n}\r\nif (switch_count <= 1)\r\ncmd.switch_time = cpu_to_le32(il->ucode_beacon_time);\r\nelse {\r\nswitch_time_in_usec =\r\nvif->bss_conf.beacon_int * switch_count * TIME_UNIT;\r\nucode_switch_time =\r\nil_usecs_to_beacons(il, switch_time_in_usec,\r\nbeacon_interval);\r\ncmd.switch_time =\r\nil_add_beacon_time(il, il->ucode_beacon_time,\r\nucode_switch_time, beacon_interval);\r\n}\r\nD_11H("uCode time for the switch is 0x%x\n", cmd.switch_time);\r\nch_info = il_get_channel_info(il, il->band, ch);\r\nif (ch_info)\r\ncmd.expect_beacon = il_is_channel_radar(ch_info);\r\nelse {\r\nIL_ERR("invalid channel switch from %u to %u\n",\r\nil->active.channel, ch);\r\nreturn -EFAULT;\r\n}\r\nrc = il4965_fill_txpower_tbl(il, band, ch, is_ht40, ctrl_chan_high,\r\n&cmd.tx_power);\r\nif (rc) {\r\nD_11H("error:%d fill txpower_tbl\n", rc);\r\nreturn rc;\r\n}\r\nreturn il_send_cmd_pdu(il, C_CHANNEL_SWITCH, sizeof(cmd), &cmd);\r\n}\r\nstatic void\r\nil4965_txq_update_byte_cnt_tbl(struct il_priv *il, struct il_tx_queue *txq,\r\nu16 byte_cnt)\r\n{\r\nstruct il4965_scd_bc_tbl *scd_bc_tbl = il->scd_bc_tbls.addr;\r\nint txq_id = txq->q.id;\r\nint write_ptr = txq->q.write_ptr;\r\nint len = byte_cnt + IL_TX_CRC_SIZE + IL_TX_DELIMITER_SIZE;\r\n__le16 bc_ent;\r\nWARN_ON(len > 0xFFF || write_ptr >= TFD_QUEUE_SIZE_MAX);\r\nbc_ent = cpu_to_le16(len & 0xFFF);\r\nscd_bc_tbl[txq_id].tfd_offset[write_ptr] = bc_ent;\r\nif (write_ptr < TFD_QUEUE_SIZE_BC_DUP)\r\nscd_bc_tbl[txq_id].tfd_offset[TFD_QUEUE_SIZE_MAX + write_ptr] =\r\nbc_ent;\r\n}\r\nstatic int\r\nil4965_hw_get_temperature(struct il_priv *il)\r\n{\r\ns32 temperature;\r\ns32 vt;\r\ns32 R1, R2, R3;\r\nu32 R4;\r\nif (test_bit(S_TEMPERATURE, &il->status) &&\r\n(il->_4965.stats.flag & STATS_REPLY_FLG_HT40_MODE_MSK)) {\r\nD_TEMP("Running HT40 temperature calibration\n");\r\nR1 = (s32) le32_to_cpu(il->card_alive_init.therm_r1[1]);\r\nR2 = (s32) le32_to_cpu(il->card_alive_init.therm_r2[1]);\r\nR3 = (s32) le32_to_cpu(il->card_alive_init.therm_r3[1]);\r\nR4 = le32_to_cpu(il->card_alive_init.therm_r4[1]);\r\n} else {\r\nD_TEMP("Running temperature calibration\n");\r\nR1 = (s32) le32_to_cpu(il->card_alive_init.therm_r1[0]);\r\nR2 = (s32) le32_to_cpu(il->card_alive_init.therm_r2[0]);\r\nR3 = (s32) le32_to_cpu(il->card_alive_init.therm_r3[0]);\r\nR4 = le32_to_cpu(il->card_alive_init.therm_r4[0]);\r\n}\r\nif (!test_bit(S_TEMPERATURE, &il->status))\r\nvt = sign_extend32(R4, 23);\r\nelse\r\nvt = sign_extend32(le32_to_cpu\r\n(il->_4965.stats.general.common.temperature),\r\n23);\r\nD_TEMP("Calib values R[1-3]: %d %d %d R4: %d\n", R1, R2, R3, vt);\r\nif (R3 == R1) {\r\nIL_ERR("Calibration conflict R1 == R3\n");\r\nreturn -1;\r\n}\r\ntemperature = TEMPERATURE_CALIB_A_VAL * (vt - R2);\r\ntemperature /= (R3 - R1);\r\ntemperature =\r\n(temperature * 97) / 100 + TEMPERATURE_CALIB_KELVIN_OFFSET;\r\nD_TEMP("Calibrated temperature: %dK, %dC\n", temperature,\r\nKELVIN_TO_CELSIUS(temperature));\r\nreturn temperature;\r\n}\r\nstatic int\r\nil4965_is_temp_calib_needed(struct il_priv *il)\r\n{\r\nint temp_diff;\r\nif (!test_bit(S_STATS, &il->status)) {\r\nD_TEMP("Temperature not updated -- no stats.\n");\r\nreturn 0;\r\n}\r\ntemp_diff = il->temperature - il->last_temperature;\r\nif (temp_diff < 0) {\r\nD_POWER("Getting cooler, delta %d\n", temp_diff);\r\ntemp_diff = -temp_diff;\r\n} else if (temp_diff == 0)\r\nD_POWER("Temperature unchanged\n");\r\nelse\r\nD_POWER("Getting warmer, delta %d\n", temp_diff);\r\nif (temp_diff < IL_TEMPERATURE_THRESHOLD) {\r\nD_POWER(" => thermal txpower calib not needed\n");\r\nreturn 0;\r\n}\r\nD_POWER(" => thermal txpower calib needed\n");\r\nreturn 1;\r\n}\r\nvoid\r\nil4965_temperature_calib(struct il_priv *il)\r\n{\r\ns32 temp;\r\ntemp = il4965_hw_get_temperature(il);\r\nif (IL_TX_POWER_TEMPERATURE_OUT_OF_RANGE(temp))\r\nreturn;\r\nif (il->temperature != temp) {\r\nif (il->temperature)\r\nD_TEMP("Temperature changed " "from %dC to %dC\n",\r\nKELVIN_TO_CELSIUS(il->temperature),\r\nKELVIN_TO_CELSIUS(temp));\r\nelse\r\nD_TEMP("Temperature " "initialized to %dC\n",\r\nKELVIN_TO_CELSIUS(temp));\r\n}\r\nil->temperature = temp;\r\nset_bit(S_TEMPERATURE, &il->status);\r\nif (!il->disable_tx_power_cal &&\r\nunlikely(!test_bit(S_SCANNING, &il->status)) &&\r\nil4965_is_temp_calib_needed(il))\r\nqueue_work(il->workqueue, &il->txpower_work);\r\n}\r\nstatic u16\r\nil4965_get_hcmd_size(u8 cmd_id, u16 len)\r\n{\r\nswitch (cmd_id) {\r\ncase C_RXON:\r\nreturn (u16) sizeof(struct il4965_rxon_cmd);\r\ndefault:\r\nreturn len;\r\n}\r\n}\r\nstatic u16\r\nil4965_build_addsta_hcmd(const struct il_addsta_cmd *cmd, u8 * data)\r\n{\r\nstruct il4965_addsta_cmd *addsta = (struct il4965_addsta_cmd *)data;\r\naddsta->mode = cmd->mode;\r\nmemcpy(&addsta->sta, &cmd->sta, sizeof(struct sta_id_modify));\r\nmemcpy(&addsta->key, &cmd->key, sizeof(struct il4965_keyinfo));\r\naddsta->station_flags = cmd->station_flags;\r\naddsta->station_flags_msk = cmd->station_flags_msk;\r\naddsta->tid_disable_tx = cmd->tid_disable_tx;\r\naddsta->add_immediate_ba_tid = cmd->add_immediate_ba_tid;\r\naddsta->remove_immediate_ba_tid = cmd->remove_immediate_ba_tid;\r\naddsta->add_immediate_ba_ssn = cmd->add_immediate_ba_ssn;\r\naddsta->sleep_tx_count = cmd->sleep_tx_count;\r\naddsta->reserved1 = cpu_to_le16(0);\r\naddsta->reserved2 = cpu_to_le16(0);\r\nreturn (u16) sizeof(struct il4965_addsta_cmd);\r\n}\r\nstatic void\r\nil4965_post_scan(struct il_priv *il)\r\n{\r\nif (memcmp(&il->staging, &il->active, sizeof(il->staging)))\r\nil_commit_rxon(il);\r\n}\r\nstatic void\r\nil4965_post_associate(struct il_priv *il)\r\n{\r\nstruct ieee80211_vif *vif = il->vif;\r\nint ret = 0;\r\nif (!vif || !il->is_open)\r\nreturn;\r\nif (test_bit(S_EXIT_PENDING, &il->status))\r\nreturn;\r\nil_scan_cancel_timeout(il, 200);\r\nil->staging.filter_flags &= ~RXON_FILTER_ASSOC_MSK;\r\nil_commit_rxon(il);\r\nret = il_send_rxon_timing(il);\r\nif (ret)\r\nIL_WARN("RXON timing - " "Attempting to continue.\n");\r\nil->staging.filter_flags |= RXON_FILTER_ASSOC_MSK;\r\nil_set_rxon_ht(il, &il->current_ht_config);\r\nif (il->ops->set_rxon_chain)\r\nil->ops->set_rxon_chain(il);\r\nil->staging.assoc_id = cpu_to_le16(vif->bss_conf.aid);\r\nD_ASSOC("assoc id %d beacon interval %d\n", vif->bss_conf.aid,\r\nvif->bss_conf.beacon_int);\r\nif (vif->bss_conf.use_short_preamble)\r\nil->staging.flags |= RXON_FLG_SHORT_PREAMBLE_MSK;\r\nelse\r\nil->staging.flags &= ~RXON_FLG_SHORT_PREAMBLE_MSK;\r\nif (il->staging.flags & RXON_FLG_BAND_24G_MSK) {\r\nif (vif->bss_conf.use_short_slot)\r\nil->staging.flags |= RXON_FLG_SHORT_SLOT_MSK;\r\nelse\r\nil->staging.flags &= ~RXON_FLG_SHORT_SLOT_MSK;\r\n}\r\nil_commit_rxon(il);\r\nD_ASSOC("Associated as %d to: %pM\n", vif->bss_conf.aid,\r\nil->active.bssid_addr);\r\nswitch (vif->type) {\r\ncase NL80211_IFTYPE_STATION:\r\nbreak;\r\ncase NL80211_IFTYPE_ADHOC:\r\nil4965_send_beacon_cmd(il);\r\nbreak;\r\ndefault:\r\nIL_ERR("%s Should not be called in %d mode\n", __func__,\r\nvif->type);\r\nbreak;\r\n}\r\nif (il->chain_noise_data.state == IL_CHAIN_NOISE_DONE)\r\nil_power_update_mode(il, false);\r\nil4965_chain_noise_reset(il);\r\nil->start_calib = 1;\r\n}\r\nstatic void\r\nil4965_config_ap(struct il_priv *il)\r\n{\r\nstruct ieee80211_vif *vif = il->vif;\r\nint ret = 0;\r\nlockdep_assert_held(&il->mutex);\r\nif (test_bit(S_EXIT_PENDING, &il->status))\r\nreturn;\r\nif (!il_is_associated(il)) {\r\nil->staging.filter_flags &= ~RXON_FILTER_ASSOC_MSK;\r\nil_commit_rxon(il);\r\nret = il_send_rxon_timing(il);\r\nif (ret)\r\nIL_WARN("RXON timing failed - "\r\n"Attempting to continue.\n");\r\nil->chain_noise_data.active_chains = il->hw_params.valid_rx_ant;\r\nil_set_rxon_ht(il, &il->current_ht_config);\r\nif (il->ops->set_rxon_chain)\r\nil->ops->set_rxon_chain(il);\r\nil->staging.assoc_id = 0;\r\nif (vif->bss_conf.use_short_preamble)\r\nil->staging.flags |= RXON_FLG_SHORT_PREAMBLE_MSK;\r\nelse\r\nil->staging.flags &= ~RXON_FLG_SHORT_PREAMBLE_MSK;\r\nif (il->staging.flags & RXON_FLG_BAND_24G_MSK) {\r\nif (vif->bss_conf.use_short_slot)\r\nil->staging.flags |= RXON_FLG_SHORT_SLOT_MSK;\r\nelse\r\nil->staging.flags &= ~RXON_FLG_SHORT_SLOT_MSK;\r\n}\r\nil4965_send_beacon_cmd(il);\r\nil->staging.filter_flags |= RXON_FILTER_ASSOC_MSK;\r\nil_commit_rxon(il);\r\n}\r\nil4965_send_beacon_cmd(il);\r\n}
