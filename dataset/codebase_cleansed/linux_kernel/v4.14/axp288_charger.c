static inline int axp288_charger_set_cc(struct axp288_chrg_info *info, int cc)\r\n{\r\nu8 reg_val;\r\nint ret;\r\nif (cc < CHRG_CCCV_CC_OFFSET)\r\ncc = CHRG_CCCV_CC_OFFSET;\r\nelse if (cc > info->max_cc)\r\ncc = info->max_cc;\r\nreg_val = (cc - CHRG_CCCV_CC_OFFSET) / CHRG_CCCV_CC_LSB_RES;\r\ncc = (reg_val * CHRG_CCCV_CC_LSB_RES) + CHRG_CCCV_CC_OFFSET;\r\nreg_val = reg_val << CHRG_CCCV_CC_BIT_POS;\r\nret = regmap_update_bits(info->regmap,\r\nAXP20X_CHRG_CTRL1,\r\nCHRG_CCCV_CC_MASK, reg_val);\r\nif (ret >= 0)\r\ninfo->cc = cc;\r\nreturn ret;\r\n}\r\nstatic inline int axp288_charger_set_cv(struct axp288_chrg_info *info, int cv)\r\n{\r\nu8 reg_val;\r\nint ret;\r\nif (cv <= CV_4100MV) {\r\nreg_val = CHRG_CCCV_CV_4100MV;\r\ncv = CV_4100MV;\r\n} else if (cv <= CV_4150MV) {\r\nreg_val = CHRG_CCCV_CV_4150MV;\r\ncv = CV_4150MV;\r\n} else if (cv <= CV_4200MV) {\r\nreg_val = CHRG_CCCV_CV_4200MV;\r\ncv = CV_4200MV;\r\n} else {\r\nreg_val = CHRG_CCCV_CV_4350MV;\r\ncv = CV_4350MV;\r\n}\r\nreg_val = reg_val << CHRG_CCCV_CV_BIT_POS;\r\nret = regmap_update_bits(info->regmap,\r\nAXP20X_CHRG_CTRL1,\r\nCHRG_CCCV_CV_MASK, reg_val);\r\nif (ret >= 0)\r\ninfo->cv = cv;\r\nreturn ret;\r\n}\r\nstatic inline int axp288_charger_set_vbus_inlmt(struct axp288_chrg_info *info,\r\nint inlmt)\r\n{\r\nint ret;\r\nunsigned int val;\r\nu8 reg_val;\r\nret = regmap_read(info->regmap, AXP20X_CHRG_BAK_CTRL, &val);\r\nif (ret < 0)\r\ngoto set_inlmt_fail;\r\nif (inlmt <= ILIM_100MA) {\r\nreg_val = CHRG_VBUS_ILIM_100MA;\r\ninlmt = ILIM_100MA;\r\n} else if (inlmt <= ILIM_500MA) {\r\nreg_val = CHRG_VBUS_ILIM_500MA;\r\ninlmt = ILIM_500MA;\r\n} else if (inlmt <= ILIM_900MA) {\r\nreg_val = CHRG_VBUS_ILIM_900MA;\r\ninlmt = ILIM_900MA;\r\n} else if (inlmt <= ILIM_1500MA) {\r\nreg_val = CHRG_VBUS_ILIM_1500MA;\r\ninlmt = ILIM_1500MA;\r\n} else if (inlmt <= ILIM_2000MA) {\r\nreg_val = CHRG_VBUS_ILIM_2000MA;\r\ninlmt = ILIM_2000MA;\r\n} else if (inlmt <= ILIM_2500MA) {\r\nreg_val = CHRG_VBUS_ILIM_2500MA;\r\ninlmt = ILIM_2500MA;\r\n} else {\r\nreg_val = CHRG_VBUS_ILIM_3000MA;\r\ninlmt = ILIM_3000MA;\r\n}\r\nreg_val = (val & ~CHRG_VBUS_ILIM_MASK)\r\n| (reg_val << CHRG_VBUS_ILIM_BIT_POS);\r\nret = regmap_write(info->regmap, AXP20X_CHRG_BAK_CTRL, reg_val);\r\nif (ret >= 0)\r\ninfo->inlmt = inlmt;\r\nelse\r\ndev_err(&info->pdev->dev, "charger BAK control %d\n", ret);\r\nset_inlmt_fail:\r\nreturn ret;\r\n}\r\nstatic int axp288_charger_vbus_path_select(struct axp288_chrg_info *info,\r\nbool enable)\r\n{\r\nint ret;\r\nif (enable)\r\nret = regmap_update_bits(info->regmap, AXP20X_VBUS_IPSOUT_MGMT,\r\nVBUS_ISPOUT_VBUS_PATH_DIS, 0);\r\nelse\r\nret = regmap_update_bits(info->regmap, AXP20X_VBUS_IPSOUT_MGMT,\r\nVBUS_ISPOUT_VBUS_PATH_DIS, VBUS_ISPOUT_VBUS_PATH_DIS);\r\nif (ret < 0)\r\ndev_err(&info->pdev->dev, "axp288 vbus path select %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int axp288_charger_enable_charger(struct axp288_chrg_info *info,\r\nbool enable)\r\n{\r\nint ret;\r\nif ((int)enable == info->is_charger_enabled)\r\nreturn 0;\r\nif (enable)\r\nret = regmap_update_bits(info->regmap, AXP20X_CHRG_CTRL1,\r\nCHRG_CCCV_CHG_EN, CHRG_CCCV_CHG_EN);\r\nelse\r\nret = regmap_update_bits(info->regmap, AXP20X_CHRG_CTRL1,\r\nCHRG_CCCV_CHG_EN, 0);\r\nif (ret < 0)\r\ndev_err(&info->pdev->dev, "axp288 enable charger %d\n", ret);\r\nelse\r\ninfo->is_charger_enabled = enable;\r\nreturn ret;\r\n}\r\nstatic int axp288_charger_is_present(struct axp288_chrg_info *info)\r\n{\r\nint ret, present = 0;\r\nunsigned int val;\r\nret = regmap_read(info->regmap, AXP20X_PWR_INPUT_STATUS, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nif (val & PS_STAT_VBUS_PRESENT)\r\npresent = 1;\r\nreturn present;\r\n}\r\nstatic int axp288_charger_is_online(struct axp288_chrg_info *info)\r\n{\r\nint ret, online = 0;\r\nunsigned int val;\r\nret = regmap_read(info->regmap, AXP20X_PWR_INPUT_STATUS, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nif (val & PS_STAT_VBUS_VALID)\r\nonline = 1;\r\nreturn online;\r\n}\r\nstatic int axp288_get_charger_health(struct axp288_chrg_info *info)\r\n{\r\nint ret, pwr_stat, chrg_stat;\r\nint health = POWER_SUPPLY_HEALTH_UNKNOWN;\r\nunsigned int val;\r\nret = regmap_read(info->regmap, AXP20X_PWR_INPUT_STATUS, &val);\r\nif ((ret < 0) || !(val & PS_STAT_VBUS_PRESENT))\r\ngoto health_read_fail;\r\nelse\r\npwr_stat = val;\r\nret = regmap_read(info->regmap, AXP20X_PWR_OP_MODE, &val);\r\nif (ret < 0)\r\ngoto health_read_fail;\r\nelse\r\nchrg_stat = val;\r\nif (!(pwr_stat & PS_STAT_VBUS_VALID))\r\nhealth = POWER_SUPPLY_HEALTH_DEAD;\r\nelse if (chrg_stat & CHRG_STAT_PMIC_OTP)\r\nhealth = POWER_SUPPLY_HEALTH_OVERHEAT;\r\nelse if (chrg_stat & CHRG_STAT_BAT_SAFE_MODE)\r\nhealth = POWER_SUPPLY_HEALTH_SAFETY_TIMER_EXPIRE;\r\nelse\r\nhealth = POWER_SUPPLY_HEALTH_GOOD;\r\nhealth_read_fail:\r\nreturn health;\r\n}\r\nstatic int axp288_charger_usb_set_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nconst union power_supply_propval *val)\r\n{\r\nstruct axp288_chrg_info *info = power_supply_get_drvdata(psy);\r\nint ret = 0;\r\nint scaled_val;\r\nmutex_lock(&info->lock);\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\r\nscaled_val = min(val->intval, info->max_cc);\r\nscaled_val = DIV_ROUND_CLOSEST(scaled_val, 1000);\r\nret = axp288_charger_set_cc(info, scaled_val);\r\nif (ret < 0)\r\ndev_warn(&info->pdev->dev, "set charge current failed\n");\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\r\nscaled_val = min(val->intval, info->max_cv);\r\nscaled_val = DIV_ROUND_CLOSEST(scaled_val, 1000);\r\nret = axp288_charger_set_cv(info, scaled_val);\r\nif (ret < 0)\r\ndev_warn(&info->pdev->dev, "set charge voltage failed\n");\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nmutex_unlock(&info->lock);\r\nreturn ret;\r\n}\r\nstatic int axp288_charger_usb_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct axp288_chrg_info *info = power_supply_get_drvdata(psy);\r\nint ret = 0;\r\nmutex_lock(&info->lock);\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_PRESENT:\r\nif (info->otg.id_short) {\r\nval->intval = 0;\r\nbreak;\r\n}\r\nret = axp288_charger_is_present(info);\r\nif (ret < 0)\r\ngoto psy_get_prop_fail;\r\nval->intval = ret;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_ONLINE:\r\nif (info->otg.id_short) {\r\nval->intval = 0;\r\nbreak;\r\n}\r\nret = axp288_charger_is_online(info);\r\nif (ret < 0)\r\ngoto psy_get_prop_fail;\r\nval->intval = ret;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_HEALTH:\r\nval->intval = axp288_get_charger_health(info);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\r\nval->intval = info->cc * 1000;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX:\r\nval->intval = info->max_cc * 1000;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\r\nval->intval = info->cv * 1000;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX:\r\nval->intval = info->max_cv * 1000;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT:\r\nval->intval = info->inlmt * 1000;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto psy_get_prop_fail;\r\n}\r\npsy_get_prop_fail:\r\nmutex_unlock(&info->lock);\r\nreturn ret;\r\n}\r\nstatic int axp288_charger_property_is_writeable(struct power_supply *psy,\r\nenum power_supply_property psp)\r\n{\r\nint ret;\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\r\ncase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\r\nret = 1;\r\nbreak;\r\ndefault:\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic irqreturn_t axp288_charger_irq_thread_handler(int irq, void *dev)\r\n{\r\nstruct axp288_chrg_info *info = dev;\r\nint i;\r\nfor (i = 0; i < CHRG_INTR_END; i++) {\r\nif (info->irq[i] == irq)\r\nbreak;\r\n}\r\nif (i >= CHRG_INTR_END) {\r\ndev_warn(&info->pdev->dev, "spurious interrupt!!\n");\r\nreturn IRQ_NONE;\r\n}\r\nswitch (i) {\r\ncase VBUS_OV_IRQ:\r\ndev_dbg(&info->pdev->dev, "VBUS Over Voltage INTR\n");\r\nbreak;\r\ncase CHARGE_DONE_IRQ:\r\ndev_dbg(&info->pdev->dev, "Charging Done INTR\n");\r\nbreak;\r\ncase CHARGE_CHARGING_IRQ:\r\ndev_dbg(&info->pdev->dev, "Start Charging IRQ\n");\r\nbreak;\r\ncase BAT_SAFE_QUIT_IRQ:\r\ndev_dbg(&info->pdev->dev,\r\n"Quit Safe Mode(restart timer) Charging IRQ\n");\r\nbreak;\r\ncase BAT_SAFE_ENTER_IRQ:\r\ndev_dbg(&info->pdev->dev,\r\n"Enter Safe Mode(timer expire) Charging IRQ\n");\r\nbreak;\r\ncase QCBTU_IRQ:\r\ndev_dbg(&info->pdev->dev,\r\n"Quit Battery Under Temperature(CHRG) INTR\n");\r\nbreak;\r\ncase CBTU_IRQ:\r\ndev_dbg(&info->pdev->dev,\r\n"Hit Battery Under Temperature(CHRG) INTR\n");\r\nbreak;\r\ncase QCBTO_IRQ:\r\ndev_dbg(&info->pdev->dev,\r\n"Quit Battery Over Temperature(CHRG) INTR\n");\r\nbreak;\r\ncase CBTO_IRQ:\r\ndev_dbg(&info->pdev->dev,\r\n"Hit Battery Over Temperature(CHRG) INTR\n");\r\nbreak;\r\ndefault:\r\ndev_warn(&info->pdev->dev, "Spurious Interrupt!!!\n");\r\ngoto out;\r\n}\r\npower_supply_changed(info->psy_usb);\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void axp288_charger_extcon_evt_worker(struct work_struct *work)\r\n{\r\nstruct axp288_chrg_info *info =\r\ncontainer_of(work, struct axp288_chrg_info, cable.work);\r\nint ret, current_limit;\r\nstruct extcon_dev *edev = info->cable.edev;\r\nbool old_connected = info->cable.connected;\r\nenum power_supply_type old_chg_type = info->cable.chg_type;\r\nif (extcon_get_state(edev, EXTCON_CHG_USB_SDP) > 0) {\r\ndev_dbg(&info->pdev->dev, "USB SDP charger is connected");\r\ninfo->cable.connected = true;\r\ninfo->cable.chg_type = POWER_SUPPLY_TYPE_USB;\r\n} else if (extcon_get_state(edev, EXTCON_CHG_USB_CDP) > 0) {\r\ndev_dbg(&info->pdev->dev, "USB CDP charger is connected");\r\ninfo->cable.connected = true;\r\ninfo->cable.chg_type = POWER_SUPPLY_TYPE_USB_CDP;\r\n} else if (extcon_get_state(edev, EXTCON_CHG_USB_DCP) > 0) {\r\ndev_dbg(&info->pdev->dev, "USB DCP charger is connected");\r\ninfo->cable.connected = true;\r\ninfo->cable.chg_type = POWER_SUPPLY_TYPE_USB_DCP;\r\n} else {\r\nif (old_connected)\r\ndev_dbg(&info->pdev->dev, "USB charger disconnected");\r\ninfo->cable.connected = false;\r\ninfo->cable.chg_type = POWER_SUPPLY_TYPE_USB;\r\n}\r\nif (old_connected == info->cable.connected &&\r\nold_chg_type == info->cable.chg_type)\r\nreturn;\r\nmutex_lock(&info->lock);\r\nif (info->cable.connected) {\r\naxp288_charger_enable_charger(info, false);\r\nswitch (info->cable.chg_type) {\r\ncase POWER_SUPPLY_TYPE_USB:\r\ncurrent_limit = ILIM_500MA;\r\nbreak;\r\ncase POWER_SUPPLY_TYPE_USB_CDP:\r\ncurrent_limit = ILIM_1500MA;\r\nbreak;\r\ncase POWER_SUPPLY_TYPE_USB_DCP:\r\ncurrent_limit = ILIM_2000MA;\r\nbreak;\r\ndefault:\r\ncurrent_limit = 0;\r\nbreak;\r\n}\r\nret = axp288_charger_set_vbus_inlmt(info, current_limit);\r\nif (ret == 0)\r\naxp288_charger_enable_charger(info, true);\r\nelse\r\ndev_err(&info->pdev->dev,\r\n"error setting current limit (%d)", ret);\r\n} else {\r\naxp288_charger_enable_charger(info, false);\r\n}\r\nmutex_unlock(&info->lock);\r\npower_supply_changed(info->psy_usb);\r\n}\r\nstatic int axp288_charger_handle_cable0_evt(struct notifier_block *nb,\r\nunsigned long event, void *param)\r\n{\r\nstruct axp288_chrg_info *info =\r\ncontainer_of(nb, struct axp288_chrg_info, cable.nb[0]);\r\nschedule_work(&info->cable.work);\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int axp288_charger_handle_cable1_evt(struct notifier_block *nb,\r\nunsigned long event, void *param)\r\n{\r\nstruct axp288_chrg_info *info =\r\ncontainer_of(nb, struct axp288_chrg_info, cable.nb[1]);\r\nschedule_work(&info->cable.work);\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int axp288_charger_handle_cable2_evt(struct notifier_block *nb,\r\nunsigned long event, void *param)\r\n{\r\nstruct axp288_chrg_info *info =\r\ncontainer_of(nb, struct axp288_chrg_info, cable.nb[2]);\r\nschedule_work(&info->cable.work);\r\nreturn NOTIFY_OK;\r\n}\r\nstatic void axp288_charger_otg_evt_worker(struct work_struct *work)\r\n{\r\nstruct axp288_chrg_info *info =\r\ncontainer_of(work, struct axp288_chrg_info, otg.work);\r\nstruct extcon_dev *edev = info->otg.cable;\r\nint ret, usb_host = extcon_get_state(edev, EXTCON_USB_HOST);\r\ndev_dbg(&info->pdev->dev, "external connector USB-Host is %s\n",\r\nusb_host ? "attached" : "detached");\r\ninfo->otg.id_short = usb_host;\r\nret = axp288_charger_vbus_path_select(info, !info->otg.id_short);\r\nif (ret < 0)\r\ndev_warn(&info->pdev->dev, "vbus path disable failed\n");\r\n}\r\nstatic int axp288_charger_handle_otg_evt(struct notifier_block *nb,\r\nunsigned long event, void *param)\r\n{\r\nstruct axp288_chrg_info *info =\r\ncontainer_of(nb, struct axp288_chrg_info, otg.id_nb);\r\nschedule_work(&info->otg.work);\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int charger_init_hw_regs(struct axp288_chrg_info *info)\r\n{\r\nint ret, cc, cv;\r\nunsigned int val;\r\nret = regmap_write(info->regmap, AXP20X_V_LTF_CHRG, CHRG_VLTFC_0C);\r\nif (ret < 0) {\r\ndev_err(&info->pdev->dev, "register(%x) write error(%d)\n",\r\nAXP20X_V_LTF_CHRG, ret);\r\nreturn ret;\r\n}\r\nret = regmap_write(info->regmap, AXP20X_V_HTF_CHRG, CHRG_VHTFC_45C);\r\nif (ret < 0) {\r\ndev_err(&info->pdev->dev, "register(%x) write error(%d)\n",\r\nAXP20X_V_HTF_CHRG, ret);\r\nreturn ret;\r\n}\r\nret = regmap_update_bits(info->regmap,\r\nAXP20X_CHRG_CTRL2,\r\nCNTL2_CHG_OUT_TURNON, CNTL2_CHG_OUT_TURNON);\r\nif (ret < 0) {\r\ndev_err(&info->pdev->dev, "register(%x) write error(%d)\n",\r\nAXP20X_CHRG_CTRL2, ret);\r\nreturn ret;\r\n}\r\nret = regmap_update_bits(info->regmap,\r\nAXP20X_CHRG_CTRL1,\r\nCHRG_CCCV_ITERM_20P, 0);\r\nif (ret < 0) {\r\ndev_err(&info->pdev->dev, "register(%x) write error(%d)\n",\r\nAXP20X_CHRG_CTRL1, ret);\r\nreturn ret;\r\n}\r\nret = regmap_update_bits(info->regmap,\r\nAXP20X_CC_CTRL,\r\nFG_CNTL_OCV_ADJ_EN, 0);\r\nif (ret < 0) {\r\ndev_err(&info->pdev->dev, "register(%x) write error(%d)\n",\r\nAXP20X_CC_CTRL, ret);\r\nreturn ret;\r\n}\r\nret = regmap_read(info->regmap, AXP20X_CHRG_CTRL1, &val);\r\nif (ret < 0) {\r\ndev_err(&info->pdev->dev, "register(%x) read error(%d)\n",\r\nAXP20X_CHRG_CTRL1, ret);\r\nreturn ret;\r\n}\r\ncv = (val & CHRG_CCCV_CV_MASK) >> CHRG_CCCV_CV_BIT_POS;\r\nswitch (cv) {\r\ncase CHRG_CCCV_CV_4100MV:\r\ninfo->cv = CV_4100MV;\r\nbreak;\r\ncase CHRG_CCCV_CV_4150MV:\r\ninfo->cv = CV_4150MV;\r\nbreak;\r\ncase CHRG_CCCV_CV_4200MV:\r\ninfo->cv = CV_4200MV;\r\nbreak;\r\ncase CHRG_CCCV_CV_4350MV:\r\ninfo->cv = CV_4350MV;\r\nbreak;\r\n}\r\ncc = (ret & CHRG_CCCV_CC_MASK) >> CHRG_CCCV_CC_BIT_POS;\r\ncc = (cc * CHRG_CCCV_CC_LSB_RES) + CHRG_CCCV_CC_OFFSET;\r\ninfo->cc = cc;\r\ninfo->max_cv = info->cv;\r\ninfo->max_cc = info->cc;\r\nreturn 0;\r\n}\r\nstatic int axp288_charger_probe(struct platform_device *pdev)\r\n{\r\nint ret, i, pirq;\r\nstruct axp288_chrg_info *info;\r\nstruct device *dev = &pdev->dev;\r\nstruct axp20x_dev *axp20x = dev_get_drvdata(pdev->dev.parent);\r\nstruct power_supply_config charger_cfg = {};\r\ninfo = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\ninfo->pdev = pdev;\r\ninfo->regmap = axp20x->regmap;\r\ninfo->regmap_irqc = axp20x->regmap_irqc;\r\ninfo->cable.chg_type = -1;\r\ninfo->is_charger_enabled = -1;\r\ninfo->cable.edev = extcon_get_extcon_dev(AXP288_EXTCON_DEV_NAME);\r\nif (info->cable.edev == NULL) {\r\ndev_dbg(&pdev->dev, "%s is not ready, probe deferred\n",\r\nAXP288_EXTCON_DEV_NAME);\r\nreturn -EPROBE_DEFER;\r\n}\r\nif (acpi_dev_present(USB_HOST_EXTCON_HID, NULL, -1)) {\r\ninfo->otg.cable = extcon_get_extcon_dev(USB_HOST_EXTCON_NAME);\r\nif (info->otg.cable == NULL) {\r\ndev_dbg(dev, "EXTCON_USB_HOST is not ready, probe deferred\n");\r\nreturn -EPROBE_DEFER;\r\n}\r\ndev_info(&pdev->dev,\r\n"Using " USB_HOST_EXTCON_HID " extcon for usb-id\n");\r\n}\r\nplatform_set_drvdata(pdev, info);\r\nmutex_init(&info->lock);\r\nret = charger_init_hw_regs(info);\r\nif (ret)\r\nreturn ret;\r\ncharger_cfg.drv_data = info;\r\ninfo->psy_usb = devm_power_supply_register(dev, &axp288_charger_desc,\r\n&charger_cfg);\r\nif (IS_ERR(info->psy_usb)) {\r\nret = PTR_ERR(info->psy_usb);\r\ndev_err(dev, "failed to register power supply: %d\n", ret);\r\nreturn ret;\r\n}\r\nINIT_WORK(&info->cable.work, axp288_charger_extcon_evt_worker);\r\ninfo->cable.nb[0].notifier_call = axp288_charger_handle_cable0_evt;\r\ninfo->cable.nb[1].notifier_call = axp288_charger_handle_cable1_evt;\r\ninfo->cable.nb[2].notifier_call = axp288_charger_handle_cable2_evt;\r\nfor (i = 0; i < ARRAY_SIZE(cable_ids); i++) {\r\nret = devm_extcon_register_notifier(dev, info->cable.edev,\r\ncable_ids[i], &info->cable.nb[i]);\r\nif (ret) {\r\ndev_err(dev, "failed to register extcon notifier for %u: %d\n",\r\ncable_ids[i], ret);\r\nreturn ret;\r\n}\r\n}\r\nschedule_work(&info->cable.work);\r\nINIT_WORK(&info->otg.work, axp288_charger_otg_evt_worker);\r\ninfo->otg.id_nb.notifier_call = axp288_charger_handle_otg_evt;\r\nif (info->otg.cable) {\r\nret = devm_extcon_register_notifier(&pdev->dev, info->otg.cable,\r\nEXTCON_USB_HOST, &info->otg.id_nb);\r\nif (ret) {\r\ndev_err(dev, "failed to register EXTCON_USB_HOST notifier\n");\r\nreturn ret;\r\n}\r\nschedule_work(&info->otg.work);\r\n}\r\nfor (i = 0; i < CHRG_INTR_END; i++) {\r\npirq = platform_get_irq(info->pdev, i);\r\ninfo->irq[i] = regmap_irq_get_virq(info->regmap_irqc, pirq);\r\nif (info->irq[i] < 0) {\r\ndev_warn(&info->pdev->dev,\r\n"failed to get virtual interrupt=%d\n", pirq);\r\nreturn info->irq[i];\r\n}\r\nret = devm_request_threaded_irq(&info->pdev->dev, info->irq[i],\r\nNULL, axp288_charger_irq_thread_handler,\r\nIRQF_ONESHOT, info->pdev->name, info);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to request interrupt=%d\n",\r\ninfo->irq[i]);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}
