static int cqspi_wait_for_bit(void __iomem *reg, const u32 mask, bool clear)\r\n{\r\nunsigned long end = jiffies + msecs_to_jiffies(CQSPI_TIMEOUT_MS);\r\nu32 val;\r\nwhile (1) {\r\nval = readl(reg);\r\nif (clear)\r\nval = ~val;\r\nval &= mask;\r\nif (val == mask)\r\nreturn 0;\r\nif (time_after(jiffies, end))\r\nreturn -ETIMEDOUT;\r\n}\r\n}\r\nstatic bool cqspi_is_idle(struct cqspi_st *cqspi)\r\n{\r\nu32 reg = readl(cqspi->iobase + CQSPI_REG_CONFIG);\r\nreturn reg & (1 << CQSPI_REG_CONFIG_IDLE_LSB);\r\n}\r\nstatic u32 cqspi_get_rd_sram_level(struct cqspi_st *cqspi)\r\n{\r\nu32 reg = readl(cqspi->iobase + CQSPI_REG_SDRAMLEVEL);\r\nreg >>= CQSPI_REG_SDRAMLEVEL_RD_LSB;\r\nreturn reg & CQSPI_REG_SDRAMLEVEL_RD_MASK;\r\n}\r\nstatic irqreturn_t cqspi_irq_handler(int this_irq, void *dev)\r\n{\r\nstruct cqspi_st *cqspi = dev;\r\nunsigned int irq_status;\r\nirq_status = readl(cqspi->iobase + CQSPI_REG_IRQSTATUS);\r\nwritel(irq_status, cqspi->iobase + CQSPI_REG_IRQSTATUS);\r\nirq_status &= CQSPI_IRQ_MASK_RD | CQSPI_IRQ_MASK_WR;\r\nif (irq_status)\r\ncomplete(&cqspi->transfer_complete);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned int cqspi_calc_rdreg(struct spi_nor *nor, const u8 opcode)\r\n{\r\nstruct cqspi_flash_pdata *f_pdata = nor->priv;\r\nu32 rdreg = 0;\r\nrdreg |= f_pdata->inst_width << CQSPI_REG_RD_INSTR_TYPE_INSTR_LSB;\r\nrdreg |= f_pdata->addr_width << CQSPI_REG_RD_INSTR_TYPE_ADDR_LSB;\r\nrdreg |= f_pdata->data_width << CQSPI_REG_RD_INSTR_TYPE_DATA_LSB;\r\nreturn rdreg;\r\n}\r\nstatic int cqspi_wait_idle(struct cqspi_st *cqspi)\r\n{\r\nconst unsigned int poll_idle_retry = 3;\r\nunsigned int count = 0;\r\nunsigned long timeout;\r\ntimeout = jiffies + msecs_to_jiffies(CQSPI_TIMEOUT_MS);\r\nwhile (1) {\r\nif (cqspi_is_idle(cqspi))\r\ncount++;\r\nelse\r\ncount = 0;\r\nif (count >= poll_idle_retry)\r\nreturn 0;\r\nif (time_after(jiffies, timeout)) {\r\ndev_err(&cqspi->pdev->dev,\r\n"QSPI is still busy after %dms timeout.\n",\r\nCQSPI_TIMEOUT_MS);\r\nreturn -ETIMEDOUT;\r\n}\r\ncpu_relax();\r\n}\r\n}\r\nstatic int cqspi_exec_flash_cmd(struct cqspi_st *cqspi, unsigned int reg)\r\n{\r\nvoid __iomem *reg_base = cqspi->iobase;\r\nint ret;\r\nwritel(reg, reg_base + CQSPI_REG_CMDCTRL);\r\nreg |= CQSPI_REG_CMDCTRL_EXECUTE_MASK;\r\nwritel(reg, reg_base + CQSPI_REG_CMDCTRL);\r\nret = cqspi_wait_for_bit(reg_base + CQSPI_REG_CMDCTRL,\r\nCQSPI_REG_CMDCTRL_INPROGRESS_MASK, 1);\r\nif (ret) {\r\ndev_err(&cqspi->pdev->dev,\r\n"Flash command execution timed out.\n");\r\nreturn ret;\r\n}\r\nreturn cqspi_wait_idle(cqspi);\r\n}\r\nstatic int cqspi_command_read(struct spi_nor *nor,\r\nconst u8 *txbuf, const unsigned n_tx,\r\nu8 *rxbuf, const unsigned n_rx)\r\n{\r\nstruct cqspi_flash_pdata *f_pdata = nor->priv;\r\nstruct cqspi_st *cqspi = f_pdata->cqspi;\r\nvoid __iomem *reg_base = cqspi->iobase;\r\nunsigned int rdreg;\r\nunsigned int reg;\r\nunsigned int read_len;\r\nint status;\r\nif (!n_rx || n_rx > CQSPI_STIG_DATA_LEN_MAX || !rxbuf) {\r\ndev_err(nor->dev, "Invalid input argument, len %d rxbuf 0x%p\n",\r\nn_rx, rxbuf);\r\nreturn -EINVAL;\r\n}\r\nreg = txbuf[0] << CQSPI_REG_CMDCTRL_OPCODE_LSB;\r\nrdreg = cqspi_calc_rdreg(nor, txbuf[0]);\r\nwritel(rdreg, reg_base + CQSPI_REG_RD_INSTR);\r\nreg |= (0x1 << CQSPI_REG_CMDCTRL_RD_EN_LSB);\r\nreg |= (((n_rx - 1) & CQSPI_REG_CMDCTRL_RD_BYTES_MASK)\r\n<< CQSPI_REG_CMDCTRL_RD_BYTES_LSB);\r\nstatus = cqspi_exec_flash_cmd(cqspi, reg);\r\nif (status)\r\nreturn status;\r\nreg = readl(reg_base + CQSPI_REG_CMDREADDATALOWER);\r\nread_len = (n_rx > 4) ? 4 : n_rx;\r\nmemcpy(rxbuf, &reg, read_len);\r\nrxbuf += read_len;\r\nif (n_rx > 4) {\r\nreg = readl(reg_base + CQSPI_REG_CMDREADDATAUPPER);\r\nread_len = n_rx - read_len;\r\nmemcpy(rxbuf, &reg, read_len);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cqspi_command_write(struct spi_nor *nor, const u8 opcode,\r\nconst u8 *txbuf, const unsigned n_tx)\r\n{\r\nstruct cqspi_flash_pdata *f_pdata = nor->priv;\r\nstruct cqspi_st *cqspi = f_pdata->cqspi;\r\nvoid __iomem *reg_base = cqspi->iobase;\r\nunsigned int reg;\r\nunsigned int data;\r\nint ret;\r\nif (n_tx > 4 || (n_tx && !txbuf)) {\r\ndev_err(nor->dev,\r\n"Invalid input argument, cmdlen %d txbuf 0x%p\n",\r\nn_tx, txbuf);\r\nreturn -EINVAL;\r\n}\r\nreg = opcode << CQSPI_REG_CMDCTRL_OPCODE_LSB;\r\nif (n_tx) {\r\nreg |= (0x1 << CQSPI_REG_CMDCTRL_WR_EN_LSB);\r\nreg |= ((n_tx - 1) & CQSPI_REG_CMDCTRL_WR_BYTES_MASK)\r\n<< CQSPI_REG_CMDCTRL_WR_BYTES_LSB;\r\ndata = 0;\r\nmemcpy(&data, txbuf, n_tx);\r\nwritel(data, reg_base + CQSPI_REG_CMDWRITEDATALOWER);\r\n}\r\nret = cqspi_exec_flash_cmd(cqspi, reg);\r\nreturn ret;\r\n}\r\nstatic int cqspi_command_write_addr(struct spi_nor *nor,\r\nconst u8 opcode, const unsigned int addr)\r\n{\r\nstruct cqspi_flash_pdata *f_pdata = nor->priv;\r\nstruct cqspi_st *cqspi = f_pdata->cqspi;\r\nvoid __iomem *reg_base = cqspi->iobase;\r\nunsigned int reg;\r\nreg = opcode << CQSPI_REG_CMDCTRL_OPCODE_LSB;\r\nreg |= (0x1 << CQSPI_REG_CMDCTRL_ADDR_EN_LSB);\r\nreg |= ((nor->addr_width - 1) & CQSPI_REG_CMDCTRL_ADD_BYTES_MASK)\r\n<< CQSPI_REG_CMDCTRL_ADD_BYTES_LSB;\r\nwritel(addr, reg_base + CQSPI_REG_CMDADDRESS);\r\nreturn cqspi_exec_flash_cmd(cqspi, reg);\r\n}\r\nstatic int cqspi_indirect_read_setup(struct spi_nor *nor,\r\nconst unsigned int from_addr)\r\n{\r\nstruct cqspi_flash_pdata *f_pdata = nor->priv;\r\nstruct cqspi_st *cqspi = f_pdata->cqspi;\r\nvoid __iomem *reg_base = cqspi->iobase;\r\nunsigned int dummy_clk = 0;\r\nunsigned int reg;\r\nwritel(from_addr, reg_base + CQSPI_REG_INDIRECTRDSTARTADDR);\r\nreg = nor->read_opcode << CQSPI_REG_RD_INSTR_OPCODE_LSB;\r\nreg |= cqspi_calc_rdreg(nor, nor->read_opcode);\r\ndummy_clk = nor->read_dummy;\r\nif (dummy_clk > CQSPI_DUMMY_CLKS_MAX)\r\ndummy_clk = CQSPI_DUMMY_CLKS_MAX;\r\nif (dummy_clk / 8) {\r\nreg |= (1 << CQSPI_REG_RD_INSTR_MODE_EN_LSB);\r\nwritel(0xFF, reg_base + CQSPI_REG_MODE_BIT);\r\nif (f_pdata->inst_width != CQSPI_INST_TYPE_QUAD)\r\ndummy_clk -= 8;\r\nif (dummy_clk)\r\nreg |= (dummy_clk & CQSPI_REG_RD_INSTR_DUMMY_MASK)\r\n<< CQSPI_REG_RD_INSTR_DUMMY_LSB;\r\n}\r\nwritel(reg, reg_base + CQSPI_REG_RD_INSTR);\r\nreg = readl(reg_base + CQSPI_REG_SIZE);\r\nreg &= ~CQSPI_REG_SIZE_ADDRESS_MASK;\r\nreg |= (nor->addr_width - 1);\r\nwritel(reg, reg_base + CQSPI_REG_SIZE);\r\nreturn 0;\r\n}\r\nstatic int cqspi_indirect_read_execute(struct spi_nor *nor,\r\nu8 *rxbuf, const unsigned n_rx)\r\n{\r\nstruct cqspi_flash_pdata *f_pdata = nor->priv;\r\nstruct cqspi_st *cqspi = f_pdata->cqspi;\r\nvoid __iomem *reg_base = cqspi->iobase;\r\nvoid __iomem *ahb_base = cqspi->ahb_base;\r\nunsigned int remaining = n_rx;\r\nunsigned int bytes_to_read = 0;\r\nint ret = 0;\r\nwritel(remaining, reg_base + CQSPI_REG_INDIRECTRDBYTES);\r\nwritel(CQSPI_IRQ_STATUS_MASK, reg_base + CQSPI_REG_IRQSTATUS);\r\nwritel(CQSPI_IRQ_MASK_RD, reg_base + CQSPI_REG_IRQMASK);\r\nreinit_completion(&cqspi->transfer_complete);\r\nwritel(CQSPI_REG_INDIRECTRD_START_MASK,\r\nreg_base + CQSPI_REG_INDIRECTRD);\r\nwhile (remaining > 0) {\r\nret = wait_for_completion_timeout(&cqspi->transfer_complete,\r\nmsecs_to_jiffies\r\n(CQSPI_READ_TIMEOUT_MS));\r\nbytes_to_read = cqspi_get_rd_sram_level(cqspi);\r\nif (!ret && bytes_to_read == 0) {\r\ndev_err(nor->dev, "Indirect read timeout, no bytes\n");\r\nret = -ETIMEDOUT;\r\ngoto failrd;\r\n}\r\nwhile (bytes_to_read != 0) {\r\nbytes_to_read *= cqspi->fifo_width;\r\nbytes_to_read = bytes_to_read > remaining ?\r\nremaining : bytes_to_read;\r\nioread32_rep(ahb_base, rxbuf,\r\nDIV_ROUND_UP(bytes_to_read, 4));\r\nrxbuf += bytes_to_read;\r\nremaining -= bytes_to_read;\r\nbytes_to_read = cqspi_get_rd_sram_level(cqspi);\r\n}\r\nif (remaining > 0)\r\nreinit_completion(&cqspi->transfer_complete);\r\n}\r\nret = cqspi_wait_for_bit(reg_base + CQSPI_REG_INDIRECTRD,\r\nCQSPI_REG_INDIRECTRD_DONE_MASK, 0);\r\nif (ret) {\r\ndev_err(nor->dev,\r\n"Indirect read completion error (%i)\n", ret);\r\ngoto failrd;\r\n}\r\nwritel(0, reg_base + CQSPI_REG_IRQMASK);\r\nwritel(CQSPI_REG_INDIRECTRD_DONE_MASK, reg_base + CQSPI_REG_INDIRECTRD);\r\nreturn 0;\r\nfailrd:\r\nwritel(0, reg_base + CQSPI_REG_IRQMASK);\r\nwritel(CQSPI_REG_INDIRECTWR_CANCEL_MASK,\r\nreg_base + CQSPI_REG_INDIRECTRD);\r\nreturn ret;\r\n}\r\nstatic int cqspi_indirect_write_setup(struct spi_nor *nor,\r\nconst unsigned int to_addr)\r\n{\r\nunsigned int reg;\r\nstruct cqspi_flash_pdata *f_pdata = nor->priv;\r\nstruct cqspi_st *cqspi = f_pdata->cqspi;\r\nvoid __iomem *reg_base = cqspi->iobase;\r\nreg = nor->program_opcode << CQSPI_REG_WR_INSTR_OPCODE_LSB;\r\nwritel(reg, reg_base + CQSPI_REG_WR_INSTR);\r\nreg = cqspi_calc_rdreg(nor, nor->program_opcode);\r\nwritel(reg, reg_base + CQSPI_REG_RD_INSTR);\r\nwritel(to_addr, reg_base + CQSPI_REG_INDIRECTWRSTARTADDR);\r\nreg = readl(reg_base + CQSPI_REG_SIZE);\r\nreg &= ~CQSPI_REG_SIZE_ADDRESS_MASK;\r\nreg |= (nor->addr_width - 1);\r\nwritel(reg, reg_base + CQSPI_REG_SIZE);\r\nreturn 0;\r\n}\r\nstatic int cqspi_indirect_write_execute(struct spi_nor *nor,\r\nconst u8 *txbuf, const unsigned n_tx)\r\n{\r\nconst unsigned int page_size = nor->page_size;\r\nstruct cqspi_flash_pdata *f_pdata = nor->priv;\r\nstruct cqspi_st *cqspi = f_pdata->cqspi;\r\nvoid __iomem *reg_base = cqspi->iobase;\r\nunsigned int remaining = n_tx;\r\nunsigned int write_bytes;\r\nint ret;\r\nwritel(remaining, reg_base + CQSPI_REG_INDIRECTWRBYTES);\r\nwritel(CQSPI_IRQ_STATUS_MASK, reg_base + CQSPI_REG_IRQSTATUS);\r\nwritel(CQSPI_IRQ_MASK_WR, reg_base + CQSPI_REG_IRQMASK);\r\nreinit_completion(&cqspi->transfer_complete);\r\nwritel(CQSPI_REG_INDIRECTWR_START_MASK,\r\nreg_base + CQSPI_REG_INDIRECTWR);\r\nwhile (remaining > 0) {\r\nwrite_bytes = remaining > page_size ? page_size : remaining;\r\niowrite32_rep(cqspi->ahb_base, txbuf,\r\nDIV_ROUND_UP(write_bytes, 4));\r\nret = wait_for_completion_timeout(&cqspi->transfer_complete,\r\nmsecs_to_jiffies\r\n(CQSPI_TIMEOUT_MS));\r\nif (!ret) {\r\ndev_err(nor->dev, "Indirect write timeout\n");\r\nret = -ETIMEDOUT;\r\ngoto failwr;\r\n}\r\ntxbuf += write_bytes;\r\nremaining -= write_bytes;\r\nif (remaining > 0)\r\nreinit_completion(&cqspi->transfer_complete);\r\n}\r\nret = cqspi_wait_for_bit(reg_base + CQSPI_REG_INDIRECTWR,\r\nCQSPI_REG_INDIRECTWR_DONE_MASK, 0);\r\nif (ret) {\r\ndev_err(nor->dev,\r\n"Indirect write completion error (%i)\n", ret);\r\ngoto failwr;\r\n}\r\nwritel(0, reg_base + CQSPI_REG_IRQMASK);\r\nwritel(CQSPI_REG_INDIRECTWR_DONE_MASK, reg_base + CQSPI_REG_INDIRECTWR);\r\ncqspi_wait_idle(cqspi);\r\nreturn 0;\r\nfailwr:\r\nwritel(0, reg_base + CQSPI_REG_IRQMASK);\r\nwritel(CQSPI_REG_INDIRECTWR_CANCEL_MASK,\r\nreg_base + CQSPI_REG_INDIRECTWR);\r\nreturn ret;\r\n}\r\nstatic void cqspi_chipselect(struct spi_nor *nor)\r\n{\r\nstruct cqspi_flash_pdata *f_pdata = nor->priv;\r\nstruct cqspi_st *cqspi = f_pdata->cqspi;\r\nvoid __iomem *reg_base = cqspi->iobase;\r\nunsigned int chip_select = f_pdata->cs;\r\nunsigned int reg;\r\nreg = readl(reg_base + CQSPI_REG_CONFIG);\r\nif (cqspi->is_decoded_cs) {\r\nreg |= CQSPI_REG_CONFIG_DECODE_MASK;\r\n} else {\r\nreg &= ~CQSPI_REG_CONFIG_DECODE_MASK;\r\nchip_select = 0xF & ~(1 << chip_select);\r\n}\r\nreg &= ~(CQSPI_REG_CONFIG_CHIPSELECT_MASK\r\n<< CQSPI_REG_CONFIG_CHIPSELECT_LSB);\r\nreg |= (chip_select & CQSPI_REG_CONFIG_CHIPSELECT_MASK)\r\n<< CQSPI_REG_CONFIG_CHIPSELECT_LSB;\r\nwritel(reg, reg_base + CQSPI_REG_CONFIG);\r\n}\r\nstatic void cqspi_configure_cs_and_sizes(struct spi_nor *nor)\r\n{\r\nstruct cqspi_flash_pdata *f_pdata = nor->priv;\r\nstruct cqspi_st *cqspi = f_pdata->cqspi;\r\nvoid __iomem *iobase = cqspi->iobase;\r\nunsigned int reg;\r\nreg = readl(iobase + CQSPI_REG_SIZE);\r\nreg &= ~(CQSPI_REG_SIZE_PAGE_MASK << CQSPI_REG_SIZE_PAGE_LSB);\r\nreg &= ~(CQSPI_REG_SIZE_BLOCK_MASK << CQSPI_REG_SIZE_BLOCK_LSB);\r\nreg &= ~CQSPI_REG_SIZE_ADDRESS_MASK;\r\nreg |= (nor->page_size << CQSPI_REG_SIZE_PAGE_LSB);\r\nreg |= (ilog2(nor->mtd.erasesize) << CQSPI_REG_SIZE_BLOCK_LSB);\r\nreg |= (nor->addr_width - 1);\r\nwritel(reg, iobase + CQSPI_REG_SIZE);\r\ncqspi_chipselect(nor);\r\ncqspi->current_page_size = nor->page_size;\r\ncqspi->current_erase_size = nor->mtd.erasesize;\r\ncqspi->current_addr_width = nor->addr_width;\r\n}\r\nstatic unsigned int calculate_ticks_for_ns(const unsigned int ref_clk_hz,\r\nconst unsigned int ns_val)\r\n{\r\nunsigned int ticks;\r\nticks = ref_clk_hz / 1000;\r\nticks = DIV_ROUND_UP(ticks * ns_val, 1000000);\r\nreturn ticks;\r\n}\r\nstatic void cqspi_delay(struct spi_nor *nor)\r\n{\r\nstruct cqspi_flash_pdata *f_pdata = nor->priv;\r\nstruct cqspi_st *cqspi = f_pdata->cqspi;\r\nvoid __iomem *iobase = cqspi->iobase;\r\nconst unsigned int ref_clk_hz = cqspi->master_ref_clk_hz;\r\nunsigned int tshsl, tchsh, tslch, tsd2d;\r\nunsigned int reg;\r\nunsigned int tsclk;\r\ntsclk = DIV_ROUND_UP(ref_clk_hz, cqspi->sclk);\r\ntshsl = calculate_ticks_for_ns(ref_clk_hz, f_pdata->tshsl_ns);\r\nif (tshsl < tsclk)\r\ntshsl = tsclk;\r\ntchsh = calculate_ticks_for_ns(ref_clk_hz, f_pdata->tchsh_ns);\r\ntslch = calculate_ticks_for_ns(ref_clk_hz, f_pdata->tslch_ns);\r\ntsd2d = calculate_ticks_for_ns(ref_clk_hz, f_pdata->tsd2d_ns);\r\nreg = (tshsl & CQSPI_REG_DELAY_TSHSL_MASK)\r\n<< CQSPI_REG_DELAY_TSHSL_LSB;\r\nreg |= (tchsh & CQSPI_REG_DELAY_TCHSH_MASK)\r\n<< CQSPI_REG_DELAY_TCHSH_LSB;\r\nreg |= (tslch & CQSPI_REG_DELAY_TSLCH_MASK)\r\n<< CQSPI_REG_DELAY_TSLCH_LSB;\r\nreg |= (tsd2d & CQSPI_REG_DELAY_TSD2D_MASK)\r\n<< CQSPI_REG_DELAY_TSD2D_LSB;\r\nwritel(reg, iobase + CQSPI_REG_DELAY);\r\n}\r\nstatic void cqspi_config_baudrate_div(struct cqspi_st *cqspi)\r\n{\r\nconst unsigned int ref_clk_hz = cqspi->master_ref_clk_hz;\r\nvoid __iomem *reg_base = cqspi->iobase;\r\nu32 reg, div;\r\ndiv = DIV_ROUND_UP(ref_clk_hz, 2 * cqspi->sclk) - 1;\r\nreg = readl(reg_base + CQSPI_REG_CONFIG);\r\nreg &= ~(CQSPI_REG_CONFIG_BAUD_MASK << CQSPI_REG_CONFIG_BAUD_LSB);\r\nreg |= (div & CQSPI_REG_CONFIG_BAUD_MASK) << CQSPI_REG_CONFIG_BAUD_LSB;\r\nwritel(reg, reg_base + CQSPI_REG_CONFIG);\r\n}\r\nstatic void cqspi_readdata_capture(struct cqspi_st *cqspi,\r\nconst unsigned int bypass,\r\nconst unsigned int delay)\r\n{\r\nvoid __iomem *reg_base = cqspi->iobase;\r\nunsigned int reg;\r\nreg = readl(reg_base + CQSPI_REG_READCAPTURE);\r\nif (bypass)\r\nreg |= (1 << CQSPI_REG_READCAPTURE_BYPASS_LSB);\r\nelse\r\nreg &= ~(1 << CQSPI_REG_READCAPTURE_BYPASS_LSB);\r\nreg &= ~(CQSPI_REG_READCAPTURE_DELAY_MASK\r\n<< CQSPI_REG_READCAPTURE_DELAY_LSB);\r\nreg |= (delay & CQSPI_REG_READCAPTURE_DELAY_MASK)\r\n<< CQSPI_REG_READCAPTURE_DELAY_LSB;\r\nwritel(reg, reg_base + CQSPI_REG_READCAPTURE);\r\n}\r\nstatic void cqspi_controller_enable(struct cqspi_st *cqspi, bool enable)\r\n{\r\nvoid __iomem *reg_base = cqspi->iobase;\r\nunsigned int reg;\r\nreg = readl(reg_base + CQSPI_REG_CONFIG);\r\nif (enable)\r\nreg |= CQSPI_REG_CONFIG_ENABLE_MASK;\r\nelse\r\nreg &= ~CQSPI_REG_CONFIG_ENABLE_MASK;\r\nwritel(reg, reg_base + CQSPI_REG_CONFIG);\r\n}\r\nstatic void cqspi_configure(struct spi_nor *nor)\r\n{\r\nstruct cqspi_flash_pdata *f_pdata = nor->priv;\r\nstruct cqspi_st *cqspi = f_pdata->cqspi;\r\nconst unsigned int sclk = f_pdata->clk_rate;\r\nint switch_cs = (cqspi->current_cs != f_pdata->cs);\r\nint switch_ck = (cqspi->sclk != sclk);\r\nif ((cqspi->current_page_size != nor->page_size) ||\r\n(cqspi->current_erase_size != nor->mtd.erasesize) ||\r\n(cqspi->current_addr_width != nor->addr_width))\r\nswitch_cs = 1;\r\nif (switch_cs || switch_ck)\r\ncqspi_controller_enable(cqspi, 0);\r\nif (switch_cs) {\r\ncqspi->current_cs = f_pdata->cs;\r\ncqspi_configure_cs_and_sizes(nor);\r\n}\r\nif (switch_ck) {\r\ncqspi->sclk = sclk;\r\ncqspi_config_baudrate_div(cqspi);\r\ncqspi_delay(nor);\r\ncqspi_readdata_capture(cqspi, 1, f_pdata->read_delay);\r\n}\r\nif (switch_cs || switch_ck)\r\ncqspi_controller_enable(cqspi, 1);\r\n}\r\nstatic int cqspi_set_protocol(struct spi_nor *nor, const int read)\r\n{\r\nstruct cqspi_flash_pdata *f_pdata = nor->priv;\r\nf_pdata->inst_width = CQSPI_INST_TYPE_SINGLE;\r\nf_pdata->addr_width = CQSPI_INST_TYPE_SINGLE;\r\nf_pdata->data_width = CQSPI_INST_TYPE_SINGLE;\r\nif (read) {\r\nswitch (nor->read_proto) {\r\ncase SNOR_PROTO_1_1_1:\r\nf_pdata->data_width = CQSPI_INST_TYPE_SINGLE;\r\nbreak;\r\ncase SNOR_PROTO_1_1_2:\r\nf_pdata->data_width = CQSPI_INST_TYPE_DUAL;\r\nbreak;\r\ncase SNOR_PROTO_1_1_4:\r\nf_pdata->data_width = CQSPI_INST_TYPE_QUAD;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\ncqspi_configure(nor);\r\nreturn 0;\r\n}\r\nstatic ssize_t cqspi_write(struct spi_nor *nor, loff_t to,\r\nsize_t len, const u_char *buf)\r\n{\r\nint ret;\r\nret = cqspi_set_protocol(nor, 0);\r\nif (ret)\r\nreturn ret;\r\nret = cqspi_indirect_write_setup(nor, to);\r\nif (ret)\r\nreturn ret;\r\nret = cqspi_indirect_write_execute(nor, buf, len);\r\nif (ret)\r\nreturn ret;\r\nreturn len;\r\n}\r\nstatic ssize_t cqspi_read(struct spi_nor *nor, loff_t from,\r\nsize_t len, u_char *buf)\r\n{\r\nint ret;\r\nret = cqspi_set_protocol(nor, 1);\r\nif (ret)\r\nreturn ret;\r\nret = cqspi_indirect_read_setup(nor, from);\r\nif (ret)\r\nreturn ret;\r\nret = cqspi_indirect_read_execute(nor, buf, len);\r\nif (ret)\r\nreturn ret;\r\nreturn len;\r\n}\r\nstatic int cqspi_erase(struct spi_nor *nor, loff_t offs)\r\n{\r\nint ret;\r\nret = cqspi_set_protocol(nor, 0);\r\nif (ret)\r\nreturn ret;\r\nret = nor->write_reg(nor, SPINOR_OP_WREN, NULL, 0);\r\nif (ret)\r\nreturn ret;\r\nret = cqspi_command_write_addr(nor, nor->erase_opcode, offs);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int cqspi_prep(struct spi_nor *nor, enum spi_nor_ops ops)\r\n{\r\nstruct cqspi_flash_pdata *f_pdata = nor->priv;\r\nstruct cqspi_st *cqspi = f_pdata->cqspi;\r\nmutex_lock(&cqspi->bus_mutex);\r\nreturn 0;\r\n}\r\nstatic void cqspi_unprep(struct spi_nor *nor, enum spi_nor_ops ops)\r\n{\r\nstruct cqspi_flash_pdata *f_pdata = nor->priv;\r\nstruct cqspi_st *cqspi = f_pdata->cqspi;\r\nmutex_unlock(&cqspi->bus_mutex);\r\n}\r\nstatic int cqspi_read_reg(struct spi_nor *nor, u8 opcode, u8 *buf, int len)\r\n{\r\nint ret;\r\nret = cqspi_set_protocol(nor, 0);\r\nif (!ret)\r\nret = cqspi_command_read(nor, &opcode, 1, buf, len);\r\nreturn ret;\r\n}\r\nstatic int cqspi_write_reg(struct spi_nor *nor, u8 opcode, u8 *buf, int len)\r\n{\r\nint ret;\r\nret = cqspi_set_protocol(nor, 0);\r\nif (!ret)\r\nret = cqspi_command_write(nor, opcode, buf, len);\r\nreturn ret;\r\n}\r\nstatic int cqspi_of_get_flash_pdata(struct platform_device *pdev,\r\nstruct cqspi_flash_pdata *f_pdata,\r\nstruct device_node *np)\r\n{\r\nif (of_property_read_u32(np, "cdns,read-delay", &f_pdata->read_delay)) {\r\ndev_err(&pdev->dev, "couldn't determine read-delay\n");\r\nreturn -ENXIO;\r\n}\r\nif (of_property_read_u32(np, "cdns,tshsl-ns", &f_pdata->tshsl_ns)) {\r\ndev_err(&pdev->dev, "couldn't determine tshsl-ns\n");\r\nreturn -ENXIO;\r\n}\r\nif (of_property_read_u32(np, "cdns,tsd2d-ns", &f_pdata->tsd2d_ns)) {\r\ndev_err(&pdev->dev, "couldn't determine tsd2d-ns\n");\r\nreturn -ENXIO;\r\n}\r\nif (of_property_read_u32(np, "cdns,tchsh-ns", &f_pdata->tchsh_ns)) {\r\ndev_err(&pdev->dev, "couldn't determine tchsh-ns\n");\r\nreturn -ENXIO;\r\n}\r\nif (of_property_read_u32(np, "cdns,tslch-ns", &f_pdata->tslch_ns)) {\r\ndev_err(&pdev->dev, "couldn't determine tslch-ns\n");\r\nreturn -ENXIO;\r\n}\r\nif (of_property_read_u32(np, "spi-max-frequency", &f_pdata->clk_rate)) {\r\ndev_err(&pdev->dev, "couldn't determine spi-max-frequency\n");\r\nreturn -ENXIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cqspi_of_get_pdata(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct cqspi_st *cqspi = platform_get_drvdata(pdev);\r\ncqspi->is_decoded_cs = of_property_read_bool(np, "cdns,is-decoded-cs");\r\nif (of_property_read_u32(np, "cdns,fifo-depth", &cqspi->fifo_depth)) {\r\ndev_err(&pdev->dev, "couldn't determine fifo-depth\n");\r\nreturn -ENXIO;\r\n}\r\nif (of_property_read_u32(np, "cdns,fifo-width", &cqspi->fifo_width)) {\r\ndev_err(&pdev->dev, "couldn't determine fifo-width\n");\r\nreturn -ENXIO;\r\n}\r\nif (of_property_read_u32(np, "cdns,trigger-address",\r\n&cqspi->trigger_address)) {\r\ndev_err(&pdev->dev, "couldn't determine trigger-address\n");\r\nreturn -ENXIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void cqspi_controller_init(struct cqspi_st *cqspi)\r\n{\r\ncqspi_controller_enable(cqspi, 0);\r\nwritel(0, cqspi->iobase + CQSPI_REG_REMAP);\r\nwritel(0, cqspi->iobase + CQSPI_REG_IRQMASK);\r\nwritel(cqspi->fifo_depth / 2, cqspi->iobase + CQSPI_REG_SRAMPARTITION);\r\nwritel(cqspi->trigger_address,\r\ncqspi->iobase + CQSPI_REG_INDIRECTTRIGGER);\r\nwritel(cqspi->fifo_depth * cqspi->fifo_width / 2,\r\ncqspi->iobase + CQSPI_REG_INDIRECTRDWATERMARK);\r\nwritel(cqspi->fifo_depth * cqspi->fifo_width / 8,\r\ncqspi->iobase + CQSPI_REG_INDIRECTWRWATERMARK);\r\ncqspi_controller_enable(cqspi, 1);\r\n}\r\nstatic int cqspi_setup_flash(struct cqspi_st *cqspi, struct device_node *np)\r\n{\r\nconst struct spi_nor_hwcaps hwcaps = {\r\n.mask = SNOR_HWCAPS_READ |\r\nSNOR_HWCAPS_READ_FAST |\r\nSNOR_HWCAPS_READ_1_1_2 |\r\nSNOR_HWCAPS_READ_1_1_4 |\r\nSNOR_HWCAPS_PP,\r\n};\r\nstruct platform_device *pdev = cqspi->pdev;\r\nstruct device *dev = &pdev->dev;\r\nstruct cqspi_flash_pdata *f_pdata;\r\nstruct spi_nor *nor;\r\nstruct mtd_info *mtd;\r\nunsigned int cs;\r\nint i, ret;\r\nfor_each_available_child_of_node(dev->of_node, np) {\r\nret = of_property_read_u32(np, "reg", &cs);\r\nif (ret) {\r\ndev_err(dev, "Couldn't determine chip select.\n");\r\ngoto err;\r\n}\r\nif (cs >= CQSPI_MAX_CHIPSELECT) {\r\nret = -EINVAL;\r\ndev_err(dev, "Chip select %d out of range.\n", cs);\r\ngoto err;\r\n}\r\nf_pdata = &cqspi->f_pdata[cs];\r\nf_pdata->cqspi = cqspi;\r\nf_pdata->cs = cs;\r\nret = cqspi_of_get_flash_pdata(pdev, f_pdata, np);\r\nif (ret)\r\ngoto err;\r\nnor = &f_pdata->nor;\r\nmtd = &nor->mtd;\r\nmtd->priv = nor;\r\nnor->dev = dev;\r\nspi_nor_set_flash_node(nor, np);\r\nnor->priv = f_pdata;\r\nnor->read_reg = cqspi_read_reg;\r\nnor->write_reg = cqspi_write_reg;\r\nnor->read = cqspi_read;\r\nnor->write = cqspi_write;\r\nnor->erase = cqspi_erase;\r\nnor->prepare = cqspi_prep;\r\nnor->unprepare = cqspi_unprep;\r\nmtd->name = devm_kasprintf(dev, GFP_KERNEL, "%s.%d",\r\ndev_name(dev), cs);\r\nif (!mtd->name) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nret = spi_nor_scan(nor, NULL, &hwcaps);\r\nif (ret)\r\ngoto err;\r\nret = mtd_device_register(mtd, NULL, 0);\r\nif (ret)\r\ngoto err;\r\nf_pdata->registered = true;\r\n}\r\nreturn 0;\r\nerr:\r\nfor (i = 0; i < CQSPI_MAX_CHIPSELECT; i++)\r\nif (cqspi->f_pdata[i].registered)\r\nmtd_device_unregister(&cqspi->f_pdata[i].nor.mtd);\r\nreturn ret;\r\n}\r\nstatic int cqspi_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct device *dev = &pdev->dev;\r\nstruct cqspi_st *cqspi;\r\nstruct resource *res;\r\nstruct resource *res_ahb;\r\nint ret;\r\nint irq;\r\ncqspi = devm_kzalloc(dev, sizeof(*cqspi), GFP_KERNEL);\r\nif (!cqspi)\r\nreturn -ENOMEM;\r\nmutex_init(&cqspi->bus_mutex);\r\ncqspi->pdev = pdev;\r\nplatform_set_drvdata(pdev, cqspi);\r\nret = cqspi_of_get_pdata(pdev);\r\nif (ret) {\r\ndev_err(dev, "Cannot get mandatory OF data.\n");\r\nreturn -ENODEV;\r\n}\r\ncqspi->clk = devm_clk_get(dev, NULL);\r\nif (IS_ERR(cqspi->clk)) {\r\ndev_err(dev, "Cannot claim QSPI clock.\n");\r\nreturn PTR_ERR(cqspi->clk);\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ncqspi->iobase = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(cqspi->iobase)) {\r\ndev_err(dev, "Cannot remap controller address.\n");\r\nreturn PTR_ERR(cqspi->iobase);\r\n}\r\nres_ahb = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\ncqspi->ahb_base = devm_ioremap_resource(dev, res_ahb);\r\nif (IS_ERR(cqspi->ahb_base)) {\r\ndev_err(dev, "Cannot remap AHB address.\n");\r\nreturn PTR_ERR(cqspi->ahb_base);\r\n}\r\ninit_completion(&cqspi->transfer_complete);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(dev, "Cannot obtain IRQ.\n");\r\nreturn -ENXIO;\r\n}\r\nret = clk_prepare_enable(cqspi->clk);\r\nif (ret) {\r\ndev_err(dev, "Cannot enable QSPI clock.\n");\r\nreturn ret;\r\n}\r\ncqspi->master_ref_clk_hz = clk_get_rate(cqspi->clk);\r\nret = devm_request_irq(dev, irq, cqspi_irq_handler, 0,\r\npdev->name, cqspi);\r\nif (ret) {\r\ndev_err(dev, "Cannot request IRQ.\n");\r\ngoto probe_irq_failed;\r\n}\r\ncqspi_wait_idle(cqspi);\r\ncqspi_controller_init(cqspi);\r\ncqspi->current_cs = -1;\r\ncqspi->sclk = 0;\r\nret = cqspi_setup_flash(cqspi, np);\r\nif (ret) {\r\ndev_err(dev, "Cadence QSPI NOR probe failed %d\n", ret);\r\ngoto probe_setup_failed;\r\n}\r\nreturn ret;\r\nprobe_irq_failed:\r\ncqspi_controller_enable(cqspi, 0);\r\nprobe_setup_failed:\r\nclk_disable_unprepare(cqspi->clk);\r\nreturn ret;\r\n}\r\nstatic int cqspi_remove(struct platform_device *pdev)\r\n{\r\nstruct cqspi_st *cqspi = platform_get_drvdata(pdev);\r\nint i;\r\nfor (i = 0; i < CQSPI_MAX_CHIPSELECT; i++)\r\nif (cqspi->f_pdata[i].registered)\r\nmtd_device_unregister(&cqspi->f_pdata[i].nor.mtd);\r\ncqspi_controller_enable(cqspi, 0);\r\nclk_disable_unprepare(cqspi->clk);\r\nreturn 0;\r\n}\r\nstatic int cqspi_suspend(struct device *dev)\r\n{\r\nstruct cqspi_st *cqspi = dev_get_drvdata(dev);\r\ncqspi_controller_enable(cqspi, 0);\r\nreturn 0;\r\n}\r\nstatic int cqspi_resume(struct device *dev)\r\n{\r\nstruct cqspi_st *cqspi = dev_get_drvdata(dev);\r\ncqspi_controller_enable(cqspi, 1);\r\nreturn 0;\r\n}
