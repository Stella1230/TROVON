static inline struct innolux_panel *to_innolux_panel(struct drm_panel *panel)\r\n{\r\nreturn container_of(panel, struct innolux_panel, base);\r\n}\r\nstatic int innolux_panel_disable(struct drm_panel *panel)\r\n{\r\nstruct innolux_panel *innolux = to_innolux_panel(panel);\r\nint err;\r\nif (!innolux->enabled)\r\nreturn 0;\r\ninnolux->backlight->props.power = FB_BLANK_POWERDOWN;\r\nbacklight_update_status(innolux->backlight);\r\nerr = mipi_dsi_dcs_set_display_off(innolux->link);\r\nif (err < 0)\r\nDRM_DEV_ERROR(panel->dev, "failed to set display off: %d\n",\r\nerr);\r\ninnolux->enabled = false;\r\nreturn 0;\r\n}\r\nstatic int innolux_panel_unprepare(struct drm_panel *panel)\r\n{\r\nstruct innolux_panel *innolux = to_innolux_panel(panel);\r\nint err;\r\nif (!innolux->prepared)\r\nreturn 0;\r\nerr = mipi_dsi_dcs_enter_sleep_mode(innolux->link);\r\nif (err < 0) {\r\nDRM_DEV_ERROR(panel->dev, "failed to enter sleep mode: %d\n",\r\nerr);\r\nreturn err;\r\n}\r\ngpiod_set_value_cansleep(innolux->enable_gpio, 0);\r\nmsleep(80);\r\nerr = regulator_disable(innolux->supply);\r\nif (err < 0)\r\nreturn err;\r\ninnolux->prepared = false;\r\nreturn 0;\r\n}\r\nstatic int innolux_panel_prepare(struct drm_panel *panel)\r\n{\r\nstruct innolux_panel *innolux = to_innolux_panel(panel);\r\nint err, regulator_err;\r\nif (innolux->prepared)\r\nreturn 0;\r\ngpiod_set_value_cansleep(innolux->enable_gpio, 0);\r\nerr = regulator_enable(innolux->supply);\r\nif (err < 0)\r\nreturn err;\r\nusleep_range(15000, 16000);\r\ngpiod_set_value_cansleep(innolux->enable_gpio, 1);\r\nusleep_range(15000, 16000);\r\nerr = mipi_dsi_dcs_exit_sleep_mode(innolux->link);\r\nif (err < 0) {\r\nDRM_DEV_ERROR(panel->dev, "failed to exit sleep mode: %d\n",\r\nerr);\r\ngoto poweroff;\r\n}\r\nmsleep(120);\r\nerr = mipi_dsi_dcs_set_display_on(innolux->link);\r\nif (err < 0) {\r\nDRM_DEV_ERROR(panel->dev, "failed to set display on: %d\n",\r\nerr);\r\ngoto poweroff;\r\n}\r\nusleep_range(5000, 6000);\r\ninnolux->prepared = true;\r\nreturn 0;\r\npoweroff:\r\nregulator_err = regulator_disable(innolux->supply);\r\nif (regulator_err)\r\nDRM_DEV_ERROR(panel->dev, "failed to disable regulator: %d\n",\r\nregulator_err);\r\ngpiod_set_value_cansleep(innolux->enable_gpio, 0);\r\nreturn err;\r\n}\r\nstatic int innolux_panel_enable(struct drm_panel *panel)\r\n{\r\nstruct innolux_panel *innolux = to_innolux_panel(panel);\r\nint ret;\r\nif (innolux->enabled)\r\nreturn 0;\r\ninnolux->backlight->props.power = FB_BLANK_UNBLANK;\r\nret = backlight_update_status(innolux->backlight);\r\nif (ret) {\r\nDRM_DEV_ERROR(panel->drm->dev,\r\n"Failed to enable backlight %d\n", ret);\r\nreturn ret;\r\n}\r\ninnolux->enabled = true;\r\nreturn 0;\r\n}\r\nstatic int innolux_panel_get_modes(struct drm_panel *panel)\r\n{\r\nstruct drm_display_mode *mode;\r\nmode = drm_mode_duplicate(panel->drm, &default_mode);\r\nif (!mode) {\r\nDRM_DEV_ERROR(panel->drm->dev, "failed to add mode %ux%ux@%u\n",\r\ndefault_mode.hdisplay, default_mode.vdisplay,\r\ndefault_mode.vrefresh);\r\nreturn -ENOMEM;\r\n}\r\ndrm_mode_set_name(mode);\r\ndrm_mode_probed_add(panel->connector, mode);\r\npanel->connector->display_info.width_mm = 120;\r\npanel->connector->display_info.height_mm = 160;\r\npanel->connector->display_info.bpc = 8;\r\nreturn 1;\r\n}\r\nstatic int innolux_panel_add(struct innolux_panel *innolux)\r\n{\r\nstruct device *dev = &innolux->link->dev;\r\nstruct device_node *np;\r\nint err;\r\ninnolux->supply = devm_regulator_get(dev, "power");\r\nif (IS_ERR(innolux->supply))\r\nreturn PTR_ERR(innolux->supply);\r\ninnolux->enable_gpio = devm_gpiod_get_optional(dev, "enable",\r\nGPIOD_OUT_HIGH);\r\nif (IS_ERR(innolux->enable_gpio)) {\r\nerr = PTR_ERR(innolux->enable_gpio);\r\ndev_dbg(dev, "failed to get enable gpio: %d\n", err);\r\ninnolux->enable_gpio = NULL;\r\n}\r\nnp = of_parse_phandle(dev->of_node, "backlight", 0);\r\nif (np) {\r\ninnolux->backlight = of_find_backlight_by_node(np);\r\nof_node_put(np);\r\nif (!innolux->backlight)\r\nreturn -EPROBE_DEFER;\r\n}\r\ndrm_panel_init(&innolux->base);\r\ninnolux->base.funcs = &innolux_panel_funcs;\r\ninnolux->base.dev = &innolux->link->dev;\r\nerr = drm_panel_add(&innolux->base);\r\nif (err < 0)\r\ngoto put_backlight;\r\nreturn 0;\r\nput_backlight:\r\nput_device(&innolux->backlight->dev);\r\nreturn err;\r\n}\r\nstatic void innolux_panel_del(struct innolux_panel *innolux)\r\n{\r\nif (innolux->base.dev)\r\ndrm_panel_remove(&innolux->base);\r\nput_device(&innolux->backlight->dev);\r\n}\r\nstatic int innolux_panel_probe(struct mipi_dsi_device *dsi)\r\n{\r\nstruct innolux_panel *innolux;\r\nint err;\r\ndsi->lanes = 4;\r\ndsi->format = MIPI_DSI_FMT_RGB888;\r\ndsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_SYNC_PULSE |\r\nMIPI_DSI_MODE_LPM;\r\ninnolux = devm_kzalloc(&dsi->dev, sizeof(*innolux), GFP_KERNEL);\r\nif (!innolux)\r\nreturn -ENOMEM;\r\nmipi_dsi_set_drvdata(dsi, innolux);\r\ninnolux->link = dsi;\r\nerr = innolux_panel_add(innolux);\r\nif (err < 0)\r\nreturn err;\r\nerr = mipi_dsi_attach(dsi);\r\nreturn err;\r\n}\r\nstatic int innolux_panel_remove(struct mipi_dsi_device *dsi)\r\n{\r\nstruct innolux_panel *innolux = mipi_dsi_get_drvdata(dsi);\r\nint err;\r\nerr = innolux_panel_unprepare(&innolux->base);\r\nif (err < 0)\r\nDRM_DEV_ERROR(&dsi->dev, "failed to unprepare panel: %d\n",\r\nerr);\r\nerr = innolux_panel_disable(&innolux->base);\r\nif (err < 0)\r\nDRM_DEV_ERROR(&dsi->dev, "failed to disable panel: %d\n", err);\r\nerr = mipi_dsi_detach(dsi);\r\nif (err < 0)\r\nDRM_DEV_ERROR(&dsi->dev, "failed to detach from DSI host: %d\n",\r\nerr);\r\ndrm_panel_detach(&innolux->base);\r\ninnolux_panel_del(innolux);\r\nreturn 0;\r\n}\r\nstatic void innolux_panel_shutdown(struct mipi_dsi_device *dsi)\r\n{\r\nstruct innolux_panel *innolux = mipi_dsi_get_drvdata(dsi);\r\ninnolux_panel_unprepare(&innolux->base);\r\ninnolux_panel_disable(&innolux->base);\r\n}
