static bool in_init(const struct module *mod, void *loc)\r\n{\r\nreturn (u64)loc - (u64)mod->init_layout.base < mod->init_layout.size;\r\n}\r\nu64 module_emit_plt_entry(struct module *mod, void *loc, const Elf64_Rela *rela,\r\nElf64_Sym *sym)\r\n{\r\nstruct mod_plt_sec *pltsec = !in_init(mod, loc) ? &mod->arch.core :\r\n&mod->arch.init;\r\nstruct plt_entry *plt = (struct plt_entry *)pltsec->plt->sh_addr;\r\nint i = pltsec->plt_num_entries;\r\nu64 val = sym->st_value + rela->r_addend;\r\nplt[i] = (struct plt_entry){\r\ncpu_to_le32(0x92800010 | (((~val ) & 0xffff)) << 5),\r\ncpu_to_le32(0xf2a00010 | ((( val >> 16) & 0xffff)) << 5),\r\ncpu_to_le32(0xf2c00010 | ((( val >> 32) & 0xffff)) << 5),\r\ncpu_to_le32(0xd61f0200)\r\n};\r\nif (i > 0 &&\r\nplt[i].mov0 == plt[i - 1].mov0 &&\r\nplt[i].mov1 == plt[i - 1].mov1 &&\r\nplt[i].mov2 == plt[i - 1].mov2)\r\nreturn (u64)&plt[i - 1];\r\npltsec->plt_num_entries++;\r\nBUG_ON(pltsec->plt_num_entries > pltsec->plt_max_entries);\r\nreturn (u64)&plt[i];\r\n}\r\nstatic int cmp_rela(const void *a, const void *b)\r\n{\r\nconst Elf64_Rela *x = a, *y = b;\r\nint i;\r\ni = cmp_3way(ELF64_R_TYPE(x->r_info), ELF64_R_TYPE(y->r_info));\r\nif (i == 0)\r\ni = cmp_3way(ELF64_R_SYM(x->r_info), ELF64_R_SYM(y->r_info));\r\nif (i == 0)\r\ni = cmp_3way(x->r_addend, y->r_addend);\r\nreturn i;\r\n}\r\nstatic bool duplicate_rel(const Elf64_Rela *rela, int num)\r\n{\r\nreturn num > 0 && cmp_rela(rela + num, rela + num - 1) == 0;\r\n}\r\nstatic unsigned int count_plts(Elf64_Sym *syms, Elf64_Rela *rela, int num,\r\nElf64_Word dstidx)\r\n{\r\nunsigned int ret = 0;\r\nElf64_Sym *s;\r\nint i;\r\nfor (i = 0; i < num; i++) {\r\nswitch (ELF64_R_TYPE(rela[i].r_info)) {\r\ncase R_AARCH64_JUMP26:\r\ncase R_AARCH64_CALL26:\r\ns = syms + ELF64_R_SYM(rela[i].r_info);\r\nif (s->st_shndx == dstidx)\r\nbreak;\r\nif (rela[i].r_addend != 0 || !duplicate_rel(rela, i))\r\nret++;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint module_frob_arch_sections(Elf_Ehdr *ehdr, Elf_Shdr *sechdrs,\r\nchar *secstrings, struct module *mod)\r\n{\r\nunsigned long core_plts = 0;\r\nunsigned long init_plts = 0;\r\nElf64_Sym *syms = NULL;\r\nint i;\r\nfor (i = 0; i < ehdr->e_shnum; i++) {\r\nif (!strcmp(secstrings + sechdrs[i].sh_name, ".plt"))\r\nmod->arch.core.plt = sechdrs + i;\r\nelse if (!strcmp(secstrings + sechdrs[i].sh_name, ".init.plt"))\r\nmod->arch.init.plt = sechdrs + i;\r\nelse if (sechdrs[i].sh_type == SHT_SYMTAB)\r\nsyms = (Elf64_Sym *)sechdrs[i].sh_addr;\r\n}\r\nif (!mod->arch.core.plt || !mod->arch.init.plt) {\r\npr_err("%s: module PLT section(s) missing\n", mod->name);\r\nreturn -ENOEXEC;\r\n}\r\nif (!syms) {\r\npr_err("%s: module symtab section missing\n", mod->name);\r\nreturn -ENOEXEC;\r\n}\r\nfor (i = 0; i < ehdr->e_shnum; i++) {\r\nElf64_Rela *rels = (void *)ehdr + sechdrs[i].sh_offset;\r\nint numrels = sechdrs[i].sh_size / sizeof(Elf64_Rela);\r\nElf64_Shdr *dstsec = sechdrs + sechdrs[i].sh_info;\r\nif (sechdrs[i].sh_type != SHT_RELA)\r\ncontinue;\r\nif (!(dstsec->sh_flags & SHF_EXECINSTR))\r\ncontinue;\r\nsort(rels, numrels, sizeof(Elf64_Rela), cmp_rela, NULL);\r\nif (strncmp(secstrings + dstsec->sh_name, ".init", 5) != 0)\r\ncore_plts += count_plts(syms, rels, numrels,\r\nsechdrs[i].sh_info);\r\nelse\r\ninit_plts += count_plts(syms, rels, numrels,\r\nsechdrs[i].sh_info);\r\n}\r\nmod->arch.core.plt->sh_type = SHT_NOBITS;\r\nmod->arch.core.plt->sh_flags = SHF_EXECINSTR | SHF_ALLOC;\r\nmod->arch.core.plt->sh_addralign = L1_CACHE_BYTES;\r\nmod->arch.core.plt->sh_size = (core_plts + 1) * sizeof(struct plt_entry);\r\nmod->arch.core.plt_num_entries = 0;\r\nmod->arch.core.plt_max_entries = core_plts;\r\nmod->arch.init.plt->sh_type = SHT_NOBITS;\r\nmod->arch.init.plt->sh_flags = SHF_EXECINSTR | SHF_ALLOC;\r\nmod->arch.init.plt->sh_addralign = L1_CACHE_BYTES;\r\nmod->arch.init.plt->sh_size = (init_plts + 1) * sizeof(struct plt_entry);\r\nmod->arch.init.plt_num_entries = 0;\r\nmod->arch.init.plt_max_entries = init_plts;\r\nreturn 0;\r\n}
