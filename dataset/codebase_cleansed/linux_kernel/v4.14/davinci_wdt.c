static int davinci_wdt_start(struct watchdog_device *wdd)\r\n{\r\nu32 tgcr;\r\nu32 timer_margin;\r\nunsigned long wdt_freq;\r\nstruct davinci_wdt_device *davinci_wdt = watchdog_get_drvdata(wdd);\r\nwdt_freq = clk_get_rate(davinci_wdt->clk);\r\niowrite32(0, davinci_wdt->base + TCR);\r\niowrite32(0, davinci_wdt->base + TGCR);\r\ntgcr = TIMMODE_64BIT_WDOG | TIM12RS_UNRESET | TIM34RS_UNRESET;\r\niowrite32(tgcr, davinci_wdt->base + TGCR);\r\niowrite32(0, davinci_wdt->base + TIM12);\r\niowrite32(0, davinci_wdt->base + TIM34);\r\ntimer_margin = (((u64)wdd->timeout * wdt_freq) & 0xffffffff);\r\niowrite32(timer_margin, davinci_wdt->base + PRD12);\r\ntimer_margin = (((u64)wdd->timeout * wdt_freq) >> 32);\r\niowrite32(timer_margin, davinci_wdt->base + PRD34);\r\niowrite32(ENAMODE12_PERIODIC, davinci_wdt->base + TCR);\r\niowrite32(WDKEY_SEQ0 | WDEN, davinci_wdt->base + WDTCR);\r\niowrite32(WDKEY_SEQ1 | WDEN, davinci_wdt->base + WDTCR);\r\nreturn 0;\r\n}\r\nstatic int davinci_wdt_ping(struct watchdog_device *wdd)\r\n{\r\nstruct davinci_wdt_device *davinci_wdt = watchdog_get_drvdata(wdd);\r\niowrite32(WDKEY_SEQ0, davinci_wdt->base + WDTCR);\r\niowrite32(WDKEY_SEQ1, davinci_wdt->base + WDTCR);\r\nreturn 0;\r\n}\r\nstatic unsigned int davinci_wdt_get_timeleft(struct watchdog_device *wdd)\r\n{\r\nu64 timer_counter;\r\nunsigned long freq;\r\nu32 val;\r\nstruct davinci_wdt_device *davinci_wdt = watchdog_get_drvdata(wdd);\r\nval = ioread32(davinci_wdt->base + WDTCR);\r\nif (val & WDFLAG)\r\nreturn 0;\r\nfreq = clk_get_rate(davinci_wdt->clk);\r\nif (!freq)\r\nreturn 0;\r\ntimer_counter = ioread32(davinci_wdt->base + TIM12);\r\ntimer_counter |= ((u64)ioread32(davinci_wdt->base + TIM34) << 32);\r\ndo_div(timer_counter, freq);\r\nreturn wdd->timeout - timer_counter;\r\n}\r\nstatic int davinci_wdt_probe(struct platform_device *pdev)\r\n{\r\nint ret = 0;\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *wdt_mem;\r\nstruct watchdog_device *wdd;\r\nstruct davinci_wdt_device *davinci_wdt;\r\ndavinci_wdt = devm_kzalloc(dev, sizeof(*davinci_wdt), GFP_KERNEL);\r\nif (!davinci_wdt)\r\nreturn -ENOMEM;\r\ndavinci_wdt->clk = devm_clk_get(dev, NULL);\r\nif (IS_ERR(davinci_wdt->clk)) {\r\nif (PTR_ERR(davinci_wdt->clk) != -EPROBE_DEFER)\r\ndev_err(&pdev->dev, "failed to get clock node\n");\r\nreturn PTR_ERR(davinci_wdt->clk);\r\n}\r\nret = clk_prepare_enable(davinci_wdt->clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to prepare clock\n");\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, davinci_wdt);\r\nwdd = &davinci_wdt->wdd;\r\nwdd->info = &davinci_wdt_info;\r\nwdd->ops = &davinci_wdt_ops;\r\nwdd->min_timeout = 1;\r\nwdd->max_timeout = MAX_HEARTBEAT;\r\nwdd->timeout = DEFAULT_HEARTBEAT;\r\nwdd->parent = &pdev->dev;\r\nwatchdog_init_timeout(wdd, heartbeat, dev);\r\ndev_info(dev, "heartbeat %d sec\n", wdd->timeout);\r\nwatchdog_set_drvdata(wdd, davinci_wdt);\r\nwatchdog_set_nowayout(wdd, 1);\r\nwdt_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndavinci_wdt->base = devm_ioremap_resource(dev, wdt_mem);\r\nif (IS_ERR(davinci_wdt->base))\r\nreturn PTR_ERR(davinci_wdt->base);\r\nret = watchdog_register_device(wdd);\r\nif (ret < 0) {\r\nclk_disable_unprepare(davinci_wdt->clk);\r\ndev_err(dev, "cannot register watchdog device\n");\r\n}\r\nreturn ret;\r\n}\r\nstatic int davinci_wdt_remove(struct platform_device *pdev)\r\n{\r\nstruct davinci_wdt_device *davinci_wdt = platform_get_drvdata(pdev);\r\nwatchdog_unregister_device(&davinci_wdt->wdd);\r\nclk_disable_unprepare(davinci_wdt->clk);\r\nreturn 0;\r\n}
