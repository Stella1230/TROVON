static int rmi_f34v7_read_flash_status(struct f34_data *f34)\r\n{\r\nu8 status;\r\nu8 command;\r\nint ret;\r\nret = rmi_read_block(f34->fn->rmi_dev,\r\nf34->fn->fd.data_base_addr + f34->v7.off.flash_status,\r\n&status,\r\nsizeof(status));\r\nif (ret < 0) {\r\nrmi_dbg(RMI_DEBUG_FN, &f34->fn->dev,\r\n"%s: Error %d reading flash status\n", __func__, ret);\r\nreturn ret;\r\n}\r\nf34->v7.in_bl_mode = status >> 7;\r\nf34->v7.flash_status = status & 0x1f;\r\nif (f34->v7.flash_status != 0x00) {\r\ndev_err(&f34->fn->dev, "%s: status=%d, command=0x%02x\n",\r\n__func__, f34->v7.flash_status, f34->v7.command);\r\n}\r\nret = rmi_read_block(f34->fn->rmi_dev,\r\nf34->fn->fd.data_base_addr + f34->v7.off.flash_cmd,\r\n&command,\r\nsizeof(command));\r\nif (ret < 0) {\r\ndev_err(&f34->fn->dev, "%s: Failed to read flash command\n",\r\n__func__);\r\nreturn ret;\r\n}\r\nf34->v7.command = command;\r\nreturn 0;\r\n}\r\nstatic int rmi_f34v7_wait_for_idle(struct f34_data *f34, int timeout_ms)\r\n{\r\nunsigned long timeout;\r\ntimeout = msecs_to_jiffies(timeout_ms);\r\nif (!wait_for_completion_timeout(&f34->v7.cmd_done, timeout)) {\r\ndev_warn(&f34->fn->dev, "%s: Timed out waiting for idle status\n",\r\n__func__);\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rmi_f34v7_write_command_single_transaction(struct f34_data *f34,\r\nu8 cmd)\r\n{\r\nint ret;\r\nu8 base;\r\nstruct f34v7_data_1_5 data_1_5;\r\nbase = f34->fn->fd.data_base_addr;\r\nmemset(&data_1_5, 0, sizeof(data_1_5));\r\nswitch (cmd) {\r\ncase v7_CMD_ERASE_ALL:\r\ndata_1_5.partition_id = CORE_CODE_PARTITION;\r\ndata_1_5.command = CMD_V7_ERASE_AP;\r\nbreak;\r\ncase v7_CMD_ERASE_UI_FIRMWARE:\r\ndata_1_5.partition_id = CORE_CODE_PARTITION;\r\ndata_1_5.command = CMD_V7_ERASE;\r\nbreak;\r\ncase v7_CMD_ERASE_BL_CONFIG:\r\ndata_1_5.partition_id = GLOBAL_PARAMETERS_PARTITION;\r\ndata_1_5.command = CMD_V7_ERASE;\r\nbreak;\r\ncase v7_CMD_ERASE_UI_CONFIG:\r\ndata_1_5.partition_id = CORE_CONFIG_PARTITION;\r\ndata_1_5.command = CMD_V7_ERASE;\r\nbreak;\r\ncase v7_CMD_ERASE_DISP_CONFIG:\r\ndata_1_5.partition_id = DISPLAY_CONFIG_PARTITION;\r\ndata_1_5.command = CMD_V7_ERASE;\r\nbreak;\r\ncase v7_CMD_ERASE_FLASH_CONFIG:\r\ndata_1_5.partition_id = FLASH_CONFIG_PARTITION;\r\ndata_1_5.command = CMD_V7_ERASE;\r\nbreak;\r\ncase v7_CMD_ERASE_GUEST_CODE:\r\ndata_1_5.partition_id = GUEST_CODE_PARTITION;\r\ndata_1_5.command = CMD_V7_ERASE;\r\nbreak;\r\ncase v7_CMD_ENABLE_FLASH_PROG:\r\ndata_1_5.partition_id = BOOTLOADER_PARTITION;\r\ndata_1_5.command = CMD_V7_ENTER_BL;\r\nbreak;\r\n}\r\ndata_1_5.payload[0] = f34->bootloader_id[0];\r\ndata_1_5.payload[1] = f34->bootloader_id[1];\r\nret = rmi_write_block(f34->fn->rmi_dev,\r\nbase + f34->v7.off.partition_id,\r\n&data_1_5, sizeof(data_1_5));\r\nif (ret < 0) {\r\ndev_err(&f34->fn->dev,\r\n"%s: Failed to write single transaction command\n",\r\n__func__);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rmi_f34v7_write_command(struct f34_data *f34, u8 cmd)\r\n{\r\nint ret;\r\nu8 base;\r\nu8 command;\r\nbase = f34->fn->fd.data_base_addr;\r\nswitch (cmd) {\r\ncase v7_CMD_WRITE_FW:\r\ncase v7_CMD_WRITE_CONFIG:\r\ncase v7_CMD_WRITE_GUEST_CODE:\r\ncommand = CMD_V7_WRITE;\r\nbreak;\r\ncase v7_CMD_READ_CONFIG:\r\ncommand = CMD_V7_READ;\r\nbreak;\r\ncase v7_CMD_ERASE_ALL:\r\ncommand = CMD_V7_ERASE_AP;\r\nbreak;\r\ncase v7_CMD_ERASE_UI_FIRMWARE:\r\ncase v7_CMD_ERASE_BL_CONFIG:\r\ncase v7_CMD_ERASE_UI_CONFIG:\r\ncase v7_CMD_ERASE_DISP_CONFIG:\r\ncase v7_CMD_ERASE_FLASH_CONFIG:\r\ncase v7_CMD_ERASE_GUEST_CODE:\r\ncommand = CMD_V7_ERASE;\r\nbreak;\r\ncase v7_CMD_ENABLE_FLASH_PROG:\r\ncommand = CMD_V7_ENTER_BL;\r\nbreak;\r\ndefault:\r\ndev_err(&f34->fn->dev, "%s: Invalid command 0x%02x\n",\r\n__func__, cmd);\r\nreturn -EINVAL;\r\n}\r\nf34->v7.command = command;\r\nswitch (cmd) {\r\ncase v7_CMD_ERASE_ALL:\r\ncase v7_CMD_ERASE_UI_FIRMWARE:\r\ncase v7_CMD_ERASE_BL_CONFIG:\r\ncase v7_CMD_ERASE_UI_CONFIG:\r\ncase v7_CMD_ERASE_DISP_CONFIG:\r\ncase v7_CMD_ERASE_FLASH_CONFIG:\r\ncase v7_CMD_ERASE_GUEST_CODE:\r\ncase v7_CMD_ENABLE_FLASH_PROG:\r\nret = rmi_f34v7_write_command_single_transaction(f34, cmd);\r\nif (ret < 0)\r\nreturn ret;\r\nelse\r\nreturn 0;\r\ndefault:\r\nbreak;\r\n}\r\nrmi_dbg(RMI_DEBUG_FN, &f34->fn->dev, "%s: writing cmd %02X\n",\r\n__func__, command);\r\nret = rmi_write_block(f34->fn->rmi_dev,\r\nbase + f34->v7.off.flash_cmd,\r\n&command, sizeof(command));\r\nif (ret < 0) {\r\ndev_err(&f34->fn->dev, "%s: Failed to write flash command\n",\r\n__func__);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rmi_f34v7_write_partition_id(struct f34_data *f34, u8 cmd)\r\n{\r\nint ret;\r\nu8 base;\r\nu8 partition;\r\nbase = f34->fn->fd.data_base_addr;\r\nswitch (cmd) {\r\ncase v7_CMD_WRITE_FW:\r\npartition = CORE_CODE_PARTITION;\r\nbreak;\r\ncase v7_CMD_WRITE_CONFIG:\r\ncase v7_CMD_READ_CONFIG:\r\nif (f34->v7.config_area == v7_UI_CONFIG_AREA)\r\npartition = CORE_CONFIG_PARTITION;\r\nelse if (f34->v7.config_area == v7_DP_CONFIG_AREA)\r\npartition = DISPLAY_CONFIG_PARTITION;\r\nelse if (f34->v7.config_area == v7_PM_CONFIG_AREA)\r\npartition = GUEST_SERIALIZATION_PARTITION;\r\nelse if (f34->v7.config_area == v7_BL_CONFIG_AREA)\r\npartition = GLOBAL_PARAMETERS_PARTITION;\r\nelse if (f34->v7.config_area == v7_FLASH_CONFIG_AREA)\r\npartition = FLASH_CONFIG_PARTITION;\r\nbreak;\r\ncase v7_CMD_WRITE_GUEST_CODE:\r\npartition = GUEST_CODE_PARTITION;\r\nbreak;\r\ncase v7_CMD_ERASE_ALL:\r\npartition = CORE_CODE_PARTITION;\r\nbreak;\r\ncase v7_CMD_ERASE_BL_CONFIG:\r\npartition = GLOBAL_PARAMETERS_PARTITION;\r\nbreak;\r\ncase v7_CMD_ERASE_UI_CONFIG:\r\npartition = CORE_CONFIG_PARTITION;\r\nbreak;\r\ncase v7_CMD_ERASE_DISP_CONFIG:\r\npartition = DISPLAY_CONFIG_PARTITION;\r\nbreak;\r\ncase v7_CMD_ERASE_FLASH_CONFIG:\r\npartition = FLASH_CONFIG_PARTITION;\r\nbreak;\r\ncase v7_CMD_ERASE_GUEST_CODE:\r\npartition = GUEST_CODE_PARTITION;\r\nbreak;\r\ncase v7_CMD_ENABLE_FLASH_PROG:\r\npartition = BOOTLOADER_PARTITION;\r\nbreak;\r\ndefault:\r\ndev_err(&f34->fn->dev, "%s: Invalid command 0x%02x\n",\r\n__func__, cmd);\r\nreturn -EINVAL;\r\n}\r\nret = rmi_write_block(f34->fn->rmi_dev,\r\nbase + f34->v7.off.partition_id,\r\n&partition, sizeof(partition));\r\nif (ret < 0) {\r\ndev_err(&f34->fn->dev, "%s: Failed to write partition ID\n",\r\n__func__);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rmi_f34v7_read_partition_table(struct f34_data *f34)\r\n{\r\nint ret;\r\nunsigned long timeout;\r\nu8 base;\r\n__le16 length;\r\nu16 block_number = 0;\r\nbase = f34->fn->fd.data_base_addr;\r\nf34->v7.config_area = v7_FLASH_CONFIG_AREA;\r\nret = rmi_f34v7_write_partition_id(f34, v7_CMD_READ_CONFIG);\r\nif (ret < 0)\r\nreturn ret;\r\nret = rmi_write_block(f34->fn->rmi_dev,\r\nbase + f34->v7.off.block_number,\r\n&block_number, sizeof(block_number));\r\nif (ret < 0) {\r\ndev_err(&f34->fn->dev, "%s: Failed to write block number\n",\r\n__func__);\r\nreturn ret;\r\n}\r\nput_unaligned_le16(f34->v7.flash_config_length, &length);\r\nret = rmi_write_block(f34->fn->rmi_dev,\r\nbase + f34->v7.off.transfer_length,\r\n&length, sizeof(length));\r\nif (ret < 0) {\r\ndev_err(&f34->fn->dev, "%s: Failed to write transfer length\n",\r\n__func__);\r\nreturn ret;\r\n}\r\ninit_completion(&f34->v7.cmd_done);\r\nret = rmi_f34v7_write_command(f34, v7_CMD_READ_CONFIG);\r\nif (ret < 0) {\r\ndev_err(&f34->fn->dev, "%s: Failed to write command\n",\r\n__func__);\r\nreturn ret;\r\n}\r\ntimeout = msecs_to_jiffies(F34_WRITE_WAIT_MS);\r\nwhile (time_before(jiffies, timeout)) {\r\nusleep_range(5000, 6000);\r\nrmi_f34v7_read_flash_status(f34);\r\nif (f34->v7.command == v7_CMD_IDLE &&\r\nf34->v7.flash_status == 0x00) {\r\nbreak;\r\n}\r\n}\r\nret = rmi_read_block(f34->fn->rmi_dev,\r\nbase + f34->v7.off.payload,\r\nf34->v7.read_config_buf,\r\nf34->v7.partition_table_bytes);\r\nif (ret < 0) {\r\ndev_err(&f34->fn->dev, "%s: Failed to read block data\n",\r\n__func__);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void rmi_f34v7_parse_partition_table(struct f34_data *f34,\r\nconst void *partition_table,\r\nstruct block_count *blkcount,\r\nstruct physical_address *phyaddr)\r\n{\r\nint i;\r\nint index;\r\nu16 partition_length;\r\nu16 physical_address;\r\nconst struct partition_table *ptable;\r\nfor (i = 0; i < f34->v7.partitions; i++) {\r\nindex = i * 8 + 2;\r\nptable = partition_table + index;\r\npartition_length = le16_to_cpu(ptable->partition_length);\r\nphysical_address = le16_to_cpu(ptable->start_physical_address);\r\nrmi_dbg(RMI_DEBUG_FN, &f34->fn->dev,\r\n"%s: Partition entry %d: %*ph\n",\r\n__func__, i, sizeof(struct partition_table), ptable);\r\nswitch (ptable->partition_id & 0x1f) {\r\ncase CORE_CODE_PARTITION:\r\nblkcount->ui_firmware = partition_length;\r\nphyaddr->ui_firmware = physical_address;\r\nrmi_dbg(RMI_DEBUG_FN, &f34->fn->dev,\r\n"%s: Core code block count: %d\n",\r\n__func__, blkcount->ui_firmware);\r\nbreak;\r\ncase CORE_CONFIG_PARTITION:\r\nblkcount->ui_config = partition_length;\r\nphyaddr->ui_config = physical_address;\r\nrmi_dbg(RMI_DEBUG_FN, &f34->fn->dev,\r\n"%s: Core config block count: %d\n",\r\n__func__, blkcount->ui_config);\r\nbreak;\r\ncase DISPLAY_CONFIG_PARTITION:\r\nblkcount->dp_config = partition_length;\r\nphyaddr->dp_config = physical_address;\r\nrmi_dbg(RMI_DEBUG_FN, &f34->fn->dev,\r\n"%s: Display config block count: %d\n",\r\n__func__, blkcount->dp_config);\r\nbreak;\r\ncase FLASH_CONFIG_PARTITION:\r\nblkcount->fl_config = partition_length;\r\nrmi_dbg(RMI_DEBUG_FN, &f34->fn->dev,\r\n"%s: Flash config block count: %d\n",\r\n__func__, blkcount->fl_config);\r\nbreak;\r\ncase GUEST_CODE_PARTITION:\r\nblkcount->guest_code = partition_length;\r\nphyaddr->guest_code = physical_address;\r\nrmi_dbg(RMI_DEBUG_FN, &f34->fn->dev,\r\n"%s: Guest code block count: %d\n",\r\n__func__, blkcount->guest_code);\r\nbreak;\r\ncase GUEST_SERIALIZATION_PARTITION:\r\nblkcount->pm_config = partition_length;\r\nrmi_dbg(RMI_DEBUG_FN, &f34->fn->dev,\r\n"%s: Guest serialization block count: %d\n",\r\n__func__, blkcount->pm_config);\r\nbreak;\r\ncase GLOBAL_PARAMETERS_PARTITION:\r\nblkcount->bl_config = partition_length;\r\nrmi_dbg(RMI_DEBUG_FN, &f34->fn->dev,\r\n"%s: Global parameters block count: %d\n",\r\n__func__, blkcount->bl_config);\r\nbreak;\r\ncase DEVICE_CONFIG_PARTITION:\r\nblkcount->lockdown = partition_length;\r\nrmi_dbg(RMI_DEBUG_FN, &f34->fn->dev,\r\n"%s: Device config block count: %d\n",\r\n__func__, blkcount->lockdown);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int rmi_f34v7_read_queries_bl_version(struct f34_data *f34)\r\n{\r\nint ret;\r\nu8 base;\r\nint offset;\r\nu8 query_0;\r\nstruct f34v7_query_1_7 query_1_7;\r\nbase = f34->fn->fd.query_base_addr;\r\nret = rmi_read_block(f34->fn->rmi_dev,\r\nbase,\r\n&query_0,\r\nsizeof(query_0));\r\nif (ret < 0) {\r\ndev_err(&f34->fn->dev,\r\n"%s: Failed to read query 0\n", __func__);\r\nreturn ret;\r\n}\r\noffset = (query_0 & 0x7) + 1;\r\nret = rmi_read_block(f34->fn->rmi_dev,\r\nbase + offset,\r\n&query_1_7,\r\nsizeof(query_1_7));\r\nif (ret < 0) {\r\ndev_err(&f34->fn->dev, "%s: Failed to read queries 1 to 7\n",\r\n__func__);\r\nreturn ret;\r\n}\r\nf34->bootloader_id[0] = query_1_7.bl_minor_revision;\r\nf34->bootloader_id[1] = query_1_7.bl_major_revision;\r\nrmi_dbg(RMI_DEBUG_FN, &f34->fn->dev, "Bootloader V%d.%d\n",\r\nf34->bootloader_id[1], f34->bootloader_id[0]);\r\nreturn 0;\r\n}\r\nstatic int rmi_f34v7_read_queries(struct f34_data *f34)\r\n{\r\nint ret;\r\nint i;\r\nu8 base;\r\nint offset;\r\nu8 *ptable;\r\nu8 query_0;\r\nstruct f34v7_query_1_7 query_1_7;\r\nbase = f34->fn->fd.query_base_addr;\r\nret = rmi_read_block(f34->fn->rmi_dev,\r\nbase,\r\n&query_0,\r\nsizeof(query_0));\r\nif (ret < 0) {\r\ndev_err(&f34->fn->dev,\r\n"%s: Failed to read query 0\n", __func__);\r\nreturn ret;\r\n}\r\noffset = (query_0 & 0x07) + 1;\r\nret = rmi_read_block(f34->fn->rmi_dev,\r\nbase + offset,\r\n&query_1_7,\r\nsizeof(query_1_7));\r\nif (ret < 0) {\r\ndev_err(&f34->fn->dev, "%s: Failed to read queries 1 to 7\n",\r\n__func__);\r\nreturn ret;\r\n}\r\nf34->bootloader_id[0] = query_1_7.bl_minor_revision;\r\nf34->bootloader_id[1] = query_1_7.bl_major_revision;\r\nf34->v7.block_size = le16_to_cpu(query_1_7.block_size);\r\nf34->v7.flash_config_length =\r\nle16_to_cpu(query_1_7.flash_config_length);\r\nf34->v7.payload_length = le16_to_cpu(query_1_7.payload_length);\r\nrmi_dbg(RMI_DEBUG_FN, &f34->fn->dev, "%s: f34->v7.block_size = %d\n",\r\n__func__, f34->v7.block_size);\r\nf34->v7.off.flash_status = V7_FLASH_STATUS_OFFSET;\r\nf34->v7.off.partition_id = V7_PARTITION_ID_OFFSET;\r\nf34->v7.off.block_number = V7_BLOCK_NUMBER_OFFSET;\r\nf34->v7.off.transfer_length = V7_TRANSFER_LENGTH_OFFSET;\r\nf34->v7.off.flash_cmd = V7_COMMAND_OFFSET;\r\nf34->v7.off.payload = V7_PAYLOAD_OFFSET;\r\nf34->v7.has_display_cfg = query_1_7.partition_support[1] & HAS_DISP_CFG;\r\nf34->v7.has_guest_code =\r\nquery_1_7.partition_support[1] & HAS_GUEST_CODE;\r\nif (query_0 & HAS_CONFIG_ID) {\r\nu8 f34_ctrl[CONFIG_ID_SIZE];\r\nret = rmi_read_block(f34->fn->rmi_dev,\r\nf34->fn->fd.control_base_addr,\r\nf34_ctrl,\r\nsizeof(f34_ctrl));\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < sizeof(f34_ctrl) - 1 && !f34_ctrl[i]; i++)\r\n;\r\nsnprintf(f34->configuration_id, sizeof(f34->configuration_id),\r\n"%*phN", (int)sizeof(f34_ctrl) - i, f34_ctrl + i);\r\nrmi_dbg(RMI_DEBUG_FN, &f34->fn->dev, "Configuration ID: %s\n",\r\nf34->configuration_id);\r\n}\r\nf34->v7.partitions = 0;\r\nfor (i = 0; i < sizeof(query_1_7.partition_support); i++)\r\nf34->v7.partitions += hweight8(query_1_7.partition_support[i]);\r\nrmi_dbg(RMI_DEBUG_FN, &f34->fn->dev, "%s: Supported partitions: %*ph\n",\r\n__func__, sizeof(query_1_7.partition_support),\r\nquery_1_7.partition_support);\r\nf34->v7.partition_table_bytes = f34->v7.partitions * 8 + 2;\r\nf34->v7.read_config_buf = devm_kzalloc(&f34->fn->dev,\r\nf34->v7.partition_table_bytes,\r\nGFP_KERNEL);\r\nif (!f34->v7.read_config_buf) {\r\nf34->v7.read_config_buf_size = 0;\r\nreturn -ENOMEM;\r\n}\r\nf34->v7.read_config_buf_size = f34->v7.partition_table_bytes;\r\nptable = f34->v7.read_config_buf;\r\nret = rmi_f34v7_read_partition_table(f34);\r\nif (ret < 0) {\r\ndev_err(&f34->fn->dev, "%s: Failed to read partition table\n",\r\n__func__);\r\nreturn ret;\r\n}\r\nrmi_f34v7_parse_partition_table(f34, ptable,\r\n&f34->v7.blkcount, &f34->v7.phyaddr);\r\nreturn 0;\r\n}\r\nstatic int rmi_f34v7_check_ui_firmware_size(struct f34_data *f34)\r\n{\r\nu16 block_count;\r\nblock_count = f34->v7.img.ui_firmware.size / f34->v7.block_size;\r\nf34->update_size += block_count;\r\nif (block_count != f34->v7.blkcount.ui_firmware) {\r\ndev_err(&f34->fn->dev,\r\n"UI firmware size mismatch: %d != %d\n",\r\nblock_count, f34->v7.blkcount.ui_firmware);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rmi_f34v7_check_ui_config_size(struct f34_data *f34)\r\n{\r\nu16 block_count;\r\nblock_count = f34->v7.img.ui_config.size / f34->v7.block_size;\r\nf34->update_size += block_count;\r\nif (block_count != f34->v7.blkcount.ui_config) {\r\ndev_err(&f34->fn->dev, "UI config size mismatch\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rmi_f34v7_check_dp_config_size(struct f34_data *f34)\r\n{\r\nu16 block_count;\r\nblock_count = f34->v7.img.dp_config.size / f34->v7.block_size;\r\nf34->update_size += block_count;\r\nif (block_count != f34->v7.blkcount.dp_config) {\r\ndev_err(&f34->fn->dev, "Display config size mismatch\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rmi_f34v7_check_guest_code_size(struct f34_data *f34)\r\n{\r\nu16 block_count;\r\nblock_count = f34->v7.img.guest_code.size / f34->v7.block_size;\r\nf34->update_size += block_count;\r\nif (block_count != f34->v7.blkcount.guest_code) {\r\ndev_err(&f34->fn->dev, "Guest code size mismatch\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rmi_f34v7_check_bl_config_size(struct f34_data *f34)\r\n{\r\nu16 block_count;\r\nblock_count = f34->v7.img.bl_config.size / f34->v7.block_size;\r\nf34->update_size += block_count;\r\nif (block_count != f34->v7.blkcount.bl_config) {\r\ndev_err(&f34->fn->dev, "Bootloader config size mismatch\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rmi_f34v7_erase_config(struct f34_data *f34)\r\n{\r\nint ret;\r\ndev_info(&f34->fn->dev, "Erasing config...\n");\r\ninit_completion(&f34->v7.cmd_done);\r\nswitch (f34->v7.config_area) {\r\ncase v7_UI_CONFIG_AREA:\r\nret = rmi_f34v7_write_command(f34, v7_CMD_ERASE_UI_CONFIG);\r\nif (ret < 0)\r\nreturn ret;\r\nbreak;\r\ncase v7_DP_CONFIG_AREA:\r\nret = rmi_f34v7_write_command(f34, v7_CMD_ERASE_DISP_CONFIG);\r\nif (ret < 0)\r\nreturn ret;\r\nbreak;\r\ncase v7_BL_CONFIG_AREA:\r\nret = rmi_f34v7_write_command(f34, v7_CMD_ERASE_BL_CONFIG);\r\nif (ret < 0)\r\nreturn ret;\r\nbreak;\r\n}\r\nret = rmi_f34v7_wait_for_idle(f34, F34_ERASE_WAIT_MS);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int rmi_f34v7_erase_guest_code(struct f34_data *f34)\r\n{\r\nint ret;\r\ndev_info(&f34->fn->dev, "Erasing guest code...\n");\r\ninit_completion(&f34->v7.cmd_done);\r\nret = rmi_f34v7_write_command(f34, v7_CMD_ERASE_GUEST_CODE);\r\nif (ret < 0)\r\nreturn ret;\r\nret = rmi_f34v7_wait_for_idle(f34, F34_ERASE_WAIT_MS);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int rmi_f34v7_erase_all(struct f34_data *f34)\r\n{\r\nint ret;\r\ndev_info(&f34->fn->dev, "Erasing firmware...\n");\r\ninit_completion(&f34->v7.cmd_done);\r\nret = rmi_f34v7_write_command(f34, v7_CMD_ERASE_UI_FIRMWARE);\r\nif (ret < 0)\r\nreturn ret;\r\nret = rmi_f34v7_wait_for_idle(f34, F34_ERASE_WAIT_MS);\r\nif (ret < 0)\r\nreturn ret;\r\nf34->v7.config_area = v7_UI_CONFIG_AREA;\r\nret = rmi_f34v7_erase_config(f34);\r\nif (ret < 0)\r\nreturn ret;\r\nif (f34->v7.has_display_cfg) {\r\nf34->v7.config_area = v7_DP_CONFIG_AREA;\r\nret = rmi_f34v7_erase_config(f34);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (f34->v7.new_partition_table && f34->v7.has_guest_code) {\r\nret = rmi_f34v7_erase_guest_code(f34);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rmi_f34v7_read_blocks(struct f34_data *f34,\r\nu16 block_cnt, u8 command)\r\n{\r\nint ret;\r\nu8 base;\r\n__le16 length;\r\nu16 transfer;\r\nu16 max_transfer;\r\nu16 remaining = block_cnt;\r\nu16 block_number = 0;\r\nu16 index = 0;\r\nbase = f34->fn->fd.data_base_addr;\r\nret = rmi_f34v7_write_partition_id(f34, command);\r\nif (ret < 0)\r\nreturn ret;\r\nret = rmi_write_block(f34->fn->rmi_dev,\r\nbase + f34->v7.off.block_number,\r\n&block_number, sizeof(block_number));\r\nif (ret < 0) {\r\ndev_err(&f34->fn->dev, "%s: Failed to write block number\n",\r\n__func__);\r\nreturn ret;\r\n}\r\nmax_transfer = min(f34->v7.payload_length,\r\n(u16)(PAGE_SIZE / f34->v7.block_size));\r\ndo {\r\ntransfer = min(remaining, max_transfer);\r\nput_unaligned_le16(transfer, &length);\r\nret = rmi_write_block(f34->fn->rmi_dev,\r\nbase + f34->v7.off.transfer_length,\r\n&length, sizeof(length));\r\nif (ret < 0) {\r\ndev_err(&f34->fn->dev,\r\n"%s: Write transfer length fail (%d remaining)\n",\r\n__func__, remaining);\r\nreturn ret;\r\n}\r\ninit_completion(&f34->v7.cmd_done);\r\nret = rmi_f34v7_write_command(f34, command);\r\nif (ret < 0)\r\nreturn ret;\r\nret = rmi_f34v7_wait_for_idle(f34, F34_ENABLE_WAIT_MS);\r\nif (ret < 0)\r\nreturn ret;\r\nret = rmi_read_block(f34->fn->rmi_dev,\r\nbase + f34->v7.off.payload,\r\n&f34->v7.read_config_buf[index],\r\ntransfer * f34->v7.block_size);\r\nif (ret < 0) {\r\ndev_err(&f34->fn->dev,\r\n"%s: Read block failed (%d blks remaining)\n",\r\n__func__, remaining);\r\nreturn ret;\r\n}\r\nindex += (transfer * f34->v7.block_size);\r\nremaining -= transfer;\r\n} while (remaining);\r\nreturn 0;\r\n}\r\nstatic int rmi_f34v7_write_f34v7_blocks(struct f34_data *f34,\r\nconst void *block_ptr, u16 block_cnt,\r\nu8 command)\r\n{\r\nint ret;\r\nu8 base;\r\n__le16 length;\r\nu16 transfer;\r\nu16 max_transfer;\r\nu16 remaining = block_cnt;\r\nu16 block_number = 0;\r\nbase = f34->fn->fd.data_base_addr;\r\nret = rmi_f34v7_write_partition_id(f34, command);\r\nif (ret < 0)\r\nreturn ret;\r\nret = rmi_write_block(f34->fn->rmi_dev,\r\nbase + f34->v7.off.block_number,\r\n&block_number, sizeof(block_number));\r\nif (ret < 0) {\r\ndev_err(&f34->fn->dev, "%s: Failed to write block number\n",\r\n__func__);\r\nreturn ret;\r\n}\r\nif (f34->v7.payload_length > (PAGE_SIZE / f34->v7.block_size))\r\nmax_transfer = PAGE_SIZE / f34->v7.block_size;\r\nelse\r\nmax_transfer = f34->v7.payload_length;\r\ndo {\r\ntransfer = min(remaining, max_transfer);\r\nput_unaligned_le16(transfer, &length);\r\ninit_completion(&f34->v7.cmd_done);\r\nret = rmi_write_block(f34->fn->rmi_dev,\r\nbase + f34->v7.off.transfer_length,\r\n&length, sizeof(length));\r\nif (ret < 0) {\r\ndev_err(&f34->fn->dev,\r\n"%s: Write transfer length fail (%d remaining)\n",\r\n__func__, remaining);\r\nreturn ret;\r\n}\r\nret = rmi_f34v7_write_command(f34, command);\r\nif (ret < 0)\r\nreturn ret;\r\nret = rmi_write_block(f34->fn->rmi_dev,\r\nbase + f34->v7.off.payload,\r\nblock_ptr, transfer * f34->v7.block_size);\r\nif (ret < 0) {\r\ndev_err(&f34->fn->dev,\r\n"%s: Failed writing data (%d blks remaining)\n",\r\n__func__, remaining);\r\nreturn ret;\r\n}\r\nret = rmi_f34v7_wait_for_idle(f34, F34_ENABLE_WAIT_MS);\r\nif (ret < 0)\r\nreturn ret;\r\nblock_ptr += (transfer * f34->v7.block_size);\r\nremaining -= transfer;\r\nf34->update_progress += transfer;\r\nf34->update_status = (f34->update_progress * 100) /\r\nf34->update_size;\r\n} while (remaining);\r\nreturn 0;\r\n}\r\nstatic int rmi_f34v7_write_config(struct f34_data *f34)\r\n{\r\nreturn rmi_f34v7_write_f34v7_blocks(f34, f34->v7.config_data,\r\nf34->v7.config_block_count,\r\nv7_CMD_WRITE_CONFIG);\r\n}\r\nstatic int rmi_f34v7_write_ui_config(struct f34_data *f34)\r\n{\r\nf34->v7.config_area = v7_UI_CONFIG_AREA;\r\nf34->v7.config_data = f34->v7.img.ui_config.data;\r\nf34->v7.config_size = f34->v7.img.ui_config.size;\r\nf34->v7.config_block_count = f34->v7.config_size / f34->v7.block_size;\r\nreturn rmi_f34v7_write_config(f34);\r\n}\r\nstatic int rmi_f34v7_write_dp_config(struct f34_data *f34)\r\n{\r\nf34->v7.config_area = v7_DP_CONFIG_AREA;\r\nf34->v7.config_data = f34->v7.img.dp_config.data;\r\nf34->v7.config_size = f34->v7.img.dp_config.size;\r\nf34->v7.config_block_count = f34->v7.config_size / f34->v7.block_size;\r\nreturn rmi_f34v7_write_config(f34);\r\n}\r\nstatic int rmi_f34v7_write_guest_code(struct f34_data *f34)\r\n{\r\nreturn rmi_f34v7_write_f34v7_blocks(f34, f34->v7.img.guest_code.data,\r\nf34->v7.img.guest_code.size /\r\nf34->v7.block_size,\r\nv7_CMD_WRITE_GUEST_CODE);\r\n}\r\nstatic int rmi_f34v7_write_flash_config(struct f34_data *f34)\r\n{\r\nint ret;\r\nf34->v7.config_area = v7_FLASH_CONFIG_AREA;\r\nf34->v7.config_data = f34->v7.img.fl_config.data;\r\nf34->v7.config_size = f34->v7.img.fl_config.size;\r\nf34->v7.config_block_count = f34->v7.config_size / f34->v7.block_size;\r\nif (f34->v7.config_block_count != f34->v7.blkcount.fl_config) {\r\ndev_err(&f34->fn->dev, "%s: Flash config size mismatch\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\ninit_completion(&f34->v7.cmd_done);\r\nret = rmi_f34v7_write_command(f34, v7_CMD_ERASE_FLASH_CONFIG);\r\nif (ret < 0)\r\nreturn ret;\r\nrmi_dbg(RMI_DEBUG_FN, &f34->fn->dev,\r\n"%s: Erase flash config command written\n", __func__);\r\nret = rmi_f34v7_wait_for_idle(f34, F34_WRITE_WAIT_MS);\r\nif (ret < 0)\r\nreturn ret;\r\nret = rmi_f34v7_write_config(f34);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int rmi_f34v7_write_partition_table(struct f34_data *f34)\r\n{\r\nu16 block_count;\r\nint ret;\r\nblock_count = f34->v7.blkcount.bl_config;\r\nf34->v7.config_area = v7_BL_CONFIG_AREA;\r\nf34->v7.config_size = f34->v7.block_size * block_count;\r\ndevm_kfree(&f34->fn->dev, f34->v7.read_config_buf);\r\nf34->v7.read_config_buf = devm_kzalloc(&f34->fn->dev,\r\nf34->v7.config_size, GFP_KERNEL);\r\nif (!f34->v7.read_config_buf) {\r\nf34->v7.read_config_buf_size = 0;\r\nreturn -ENOMEM;\r\n}\r\nf34->v7.read_config_buf_size = f34->v7.config_size;\r\nret = rmi_f34v7_read_blocks(f34, block_count, v7_CMD_READ_CONFIG);\r\nif (ret < 0)\r\nreturn ret;\r\nret = rmi_f34v7_erase_config(f34);\r\nif (ret < 0)\r\nreturn ret;\r\nret = rmi_f34v7_write_flash_config(f34);\r\nif (ret < 0)\r\nreturn ret;\r\nf34->v7.config_area = v7_BL_CONFIG_AREA;\r\nf34->v7.config_data = f34->v7.read_config_buf;\r\nf34->v7.config_size = f34->v7.img.bl_config.size;\r\nf34->v7.config_block_count = f34->v7.config_size / f34->v7.block_size;\r\nret = rmi_f34v7_write_config(f34);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int rmi_f34v7_write_firmware(struct f34_data *f34)\r\n{\r\nu16 blk_count;\r\nblk_count = f34->v7.img.ui_firmware.size / f34->v7.block_size;\r\nreturn rmi_f34v7_write_f34v7_blocks(f34, f34->v7.img.ui_firmware.data,\r\nblk_count, v7_CMD_WRITE_FW);\r\n}\r\nstatic void rmi_f34v7_compare_partition_tables(struct f34_data *f34)\r\n{\r\nif (f34->v7.phyaddr.ui_firmware != f34->v7.img.phyaddr.ui_firmware) {\r\nf34->v7.new_partition_table = true;\r\nreturn;\r\n}\r\nif (f34->v7.phyaddr.ui_config != f34->v7.img.phyaddr.ui_config) {\r\nf34->v7.new_partition_table = true;\r\nreturn;\r\n}\r\nif (f34->v7.has_display_cfg &&\r\nf34->v7.phyaddr.dp_config != f34->v7.img.phyaddr.dp_config) {\r\nf34->v7.new_partition_table = true;\r\nreturn;\r\n}\r\nif (f34->v7.has_guest_code &&\r\nf34->v7.phyaddr.guest_code != f34->v7.img.phyaddr.guest_code) {\r\nf34->v7.new_partition_table = true;\r\nreturn;\r\n}\r\nf34->v7.new_partition_table = false;\r\n}\r\nstatic void rmi_f34v7_parse_img_header_10_bl_container(struct f34_data *f34,\r\nconst void *image)\r\n{\r\nint i;\r\nint num_of_containers;\r\nunsigned int addr;\r\nunsigned int container_id;\r\nunsigned int length;\r\nconst void *content;\r\nconst struct container_descriptor *descriptor;\r\nnum_of_containers = f34->v7.img.bootloader.size / 4 - 1;\r\nfor (i = 1; i <= num_of_containers; i++) {\r\naddr = get_unaligned_le32(f34->v7.img.bootloader.data + i * 4);\r\ndescriptor = image + addr;\r\ncontainer_id = le16_to_cpu(descriptor->container_id);\r\ncontent = image + le32_to_cpu(descriptor->content_address);\r\nlength = le32_to_cpu(descriptor->content_length);\r\nswitch (container_id) {\r\ncase BL_CONFIG_CONTAINER:\r\ncase GLOBAL_PARAMETERS_CONTAINER:\r\nf34->v7.img.bl_config.data = content;\r\nf34->v7.img.bl_config.size = length;\r\nbreak;\r\ncase BL_LOCKDOWN_INFO_CONTAINER:\r\ncase DEVICE_CONFIG_CONTAINER:\r\nf34->v7.img.lockdown.data = content;\r\nf34->v7.img.lockdown.size = length;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void rmi_f34v7_parse_image_header_10(struct f34_data *f34)\r\n{\r\nunsigned int i;\r\nunsigned int num_of_containers;\r\nunsigned int addr;\r\nunsigned int offset;\r\nunsigned int container_id;\r\nunsigned int length;\r\nconst void *image = f34->v7.image;\r\nconst u8 *content;\r\nconst struct container_descriptor *descriptor;\r\nconst struct image_header_10 *header = image;\r\nf34->v7.img.checksum = le32_to_cpu(header->checksum);\r\nrmi_dbg(RMI_DEBUG_FN, &f34->fn->dev, "%s: f34->v7.img.checksum=%X\n",\r\n__func__, f34->v7.img.checksum);\r\noffset = le32_to_cpu(header->top_level_container_start_addr);\r\ndescriptor = image + offset;\r\noffset = le32_to_cpu(descriptor->content_address);\r\nnum_of_containers = le32_to_cpu(descriptor->content_length) / 4;\r\nfor (i = 0; i < num_of_containers; i++) {\r\naddr = get_unaligned_le32(image + offset);\r\noffset += 4;\r\ndescriptor = image + addr;\r\ncontainer_id = le16_to_cpu(descriptor->container_id);\r\ncontent = image + le32_to_cpu(descriptor->content_address);\r\nlength = le32_to_cpu(descriptor->content_length);\r\nrmi_dbg(RMI_DEBUG_FN, &f34->fn->dev,\r\n"%s: container_id=%d, length=%d\n", __func__,\r\ncontainer_id, length);\r\nswitch (container_id) {\r\ncase UI_CONTAINER:\r\ncase CORE_CODE_CONTAINER:\r\nf34->v7.img.ui_firmware.data = content;\r\nf34->v7.img.ui_firmware.size = length;\r\nbreak;\r\ncase UI_CONFIG_CONTAINER:\r\ncase CORE_CONFIG_CONTAINER:\r\nf34->v7.img.ui_config.data = content;\r\nf34->v7.img.ui_config.size = length;\r\nbreak;\r\ncase BL_CONTAINER:\r\nf34->v7.img.bl_version = *content;\r\nf34->v7.img.bootloader.data = content;\r\nf34->v7.img.bootloader.size = length;\r\nrmi_f34v7_parse_img_header_10_bl_container(f34, image);\r\nbreak;\r\ncase GUEST_CODE_CONTAINER:\r\nf34->v7.img.contains_guest_code = true;\r\nf34->v7.img.guest_code.data = content;\r\nf34->v7.img.guest_code.size = length;\r\nbreak;\r\ncase DISPLAY_CONFIG_CONTAINER:\r\nf34->v7.img.contains_display_cfg = true;\r\nf34->v7.img.dp_config.data = content;\r\nf34->v7.img.dp_config.size = length;\r\nbreak;\r\ncase FLASH_CONFIG_CONTAINER:\r\nf34->v7.img.contains_flash_config = true;\r\nf34->v7.img.fl_config.data = content;\r\nf34->v7.img.fl_config.size = length;\r\nbreak;\r\ncase GENERAL_INFORMATION_CONTAINER:\r\nf34->v7.img.contains_firmware_id = true;\r\nf34->v7.img.firmware_id =\r\nget_unaligned_le32(content + 4);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int rmi_f34v7_parse_image_info(struct f34_data *f34)\r\n{\r\nconst struct image_header_10 *header = f34->v7.image;\r\nmemset(&f34->v7.img, 0x00, sizeof(f34->v7.img));\r\nrmi_dbg(RMI_DEBUG_FN, &f34->fn->dev,\r\n"%s: header->major_header_version = %d\n",\r\n__func__, header->major_header_version);\r\nswitch (header->major_header_version) {\r\ncase IMAGE_HEADER_VERSION_10:\r\nrmi_f34v7_parse_image_header_10(f34);\r\nbreak;\r\ndefault:\r\ndev_err(&f34->fn->dev, "Unsupported image file format %02X\n",\r\nheader->major_header_version);\r\nreturn -EINVAL;\r\n}\r\nif (!f34->v7.img.contains_flash_config) {\r\ndev_err(&f34->fn->dev, "%s: No flash config in fw image\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nrmi_f34v7_parse_partition_table(f34, f34->v7.img.fl_config.data,\r\n&f34->v7.img.blkcount, &f34->v7.img.phyaddr);\r\nrmi_f34v7_compare_partition_tables(f34);\r\nreturn 0;\r\n}\r\nint rmi_f34v7_do_reflash(struct f34_data *f34, const struct firmware *fw)\r\n{\r\nint ret;\r\nrmi_f34v7_read_queries_bl_version(f34);\r\nf34->v7.image = fw->data;\r\nf34->update_progress = 0;\r\nf34->update_size = 0;\r\nret = rmi_f34v7_parse_image_info(f34);\r\nif (ret < 0)\r\ngoto fail;\r\nif (!f34->v7.new_partition_table) {\r\nret = rmi_f34v7_check_ui_firmware_size(f34);\r\nif (ret < 0)\r\ngoto fail;\r\nret = rmi_f34v7_check_ui_config_size(f34);\r\nif (ret < 0)\r\ngoto fail;\r\nif (f34->v7.has_display_cfg &&\r\nf34->v7.img.contains_display_cfg) {\r\nret = rmi_f34v7_check_dp_config_size(f34);\r\nif (ret < 0)\r\ngoto fail;\r\n}\r\nif (f34->v7.has_guest_code && f34->v7.img.contains_guest_code) {\r\nret = rmi_f34v7_check_guest_code_size(f34);\r\nif (ret < 0)\r\ngoto fail;\r\n}\r\n} else {\r\nret = rmi_f34v7_check_bl_config_size(f34);\r\nif (ret < 0)\r\ngoto fail;\r\n}\r\nret = rmi_f34v7_erase_all(f34);\r\nif (ret < 0)\r\ngoto fail;\r\nif (f34->v7.new_partition_table) {\r\nret = rmi_f34v7_write_partition_table(f34);\r\nif (ret < 0)\r\ngoto fail;\r\ndev_info(&f34->fn->dev, "%s: Partition table programmed\n",\r\n__func__);\r\n}\r\ndev_info(&f34->fn->dev, "Writing firmware (%d bytes)...\n",\r\nf34->v7.img.ui_firmware.size);\r\nret = rmi_f34v7_write_firmware(f34);\r\nif (ret < 0)\r\ngoto fail;\r\ndev_info(&f34->fn->dev, "Writing config (%d bytes)...\n",\r\nf34->v7.img.ui_config.size);\r\nf34->v7.config_area = v7_UI_CONFIG_AREA;\r\nret = rmi_f34v7_write_ui_config(f34);\r\nif (ret < 0)\r\ngoto fail;\r\nif (f34->v7.has_display_cfg && f34->v7.img.contains_display_cfg) {\r\ndev_info(&f34->fn->dev, "Writing display config...\n");\r\nret = rmi_f34v7_write_dp_config(f34);\r\nif (ret < 0)\r\ngoto fail;\r\n}\r\nif (f34->v7.new_partition_table) {\r\nif (f34->v7.has_guest_code && f34->v7.img.contains_guest_code) {\r\ndev_info(&f34->fn->dev, "Writing guest code...\n");\r\nret = rmi_f34v7_write_guest_code(f34);\r\nif (ret < 0)\r\ngoto fail;\r\n}\r\n}\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int rmi_f34v7_enter_flash_prog(struct f34_data *f34)\r\n{\r\nint ret;\r\nf34->fn->rmi_dev->driver->set_irq_bits(f34->fn->rmi_dev, f34->fn->irq_mask);\r\nret = rmi_f34v7_read_flash_status(f34);\r\nif (ret < 0)\r\nreturn ret;\r\nif (f34->v7.in_bl_mode)\r\nreturn 0;\r\ninit_completion(&f34->v7.cmd_done);\r\nret = rmi_f34v7_write_command(f34, v7_CMD_ENABLE_FLASH_PROG);\r\nif (ret < 0)\r\nreturn ret;\r\nret = rmi_f34v7_wait_for_idle(f34, F34_ENABLE_WAIT_MS);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nint rmi_f34v7_start_reflash(struct f34_data *f34, const struct firmware *fw)\r\n{\r\nint ret = 0;\r\nf34->fn->rmi_dev->driver->set_irq_bits(f34->fn->rmi_dev, f34->fn->irq_mask);\r\nf34->v7.config_area = v7_UI_CONFIG_AREA;\r\nf34->v7.image = fw->data;\r\nret = rmi_f34v7_parse_image_info(f34);\r\nif (ret < 0)\r\ngoto exit;\r\nif (!f34->v7.force_update && f34->v7.new_partition_table) {\r\ndev_err(&f34->fn->dev, "%s: Partition table mismatch\n",\r\n__func__);\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\ndev_info(&f34->fn->dev, "Firmware image OK\n");\r\nret = rmi_f34v7_read_flash_status(f34);\r\nif (ret < 0)\r\ngoto exit;\r\nif (f34->v7.in_bl_mode) {\r\ndev_info(&f34->fn->dev, "%s: Device in bootloader mode\n",\r\n__func__);\r\n}\r\nrmi_f34v7_enter_flash_prog(f34);\r\nreturn 0;\r\nexit:\r\nreturn ret;\r\n}\r\nint rmi_f34v7_probe(struct f34_data *f34)\r\n{\r\nint ret;\r\nret = rmi_read_block(f34->fn->rmi_dev,\r\nf34->fn->fd.query_base_addr + V7_BOOTLOADER_ID_OFFSET,\r\nf34->bootloader_id,\r\nsizeof(f34->bootloader_id));\r\nif (ret < 0) {\r\ndev_err(&f34->fn->dev, "%s: Failed to read bootloader ID\n",\r\n__func__);\r\nreturn ret;\r\n}\r\nif (f34->bootloader_id[1] == '5') {\r\nf34->bl_version = 5;\r\n} else if (f34->bootloader_id[1] == '6') {\r\nf34->bl_version = 6;\r\n} else if (f34->bootloader_id[1] == 7) {\r\nf34->bl_version = 7;\r\n} else {\r\ndev_err(&f34->fn->dev, "%s: Unrecognized bootloader version\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nmemset(&f34->v7.blkcount, 0x00, sizeof(f34->v7.blkcount));\r\nmemset(&f34->v7.phyaddr, 0x00, sizeof(f34->v7.phyaddr));\r\ninit_completion(&f34->v7.cmd_done);\r\nret = rmi_f34v7_read_queries(f34);\r\nif (ret < 0)\r\nreturn ret;\r\nf34->v7.force_update = true;\r\nreturn 0;\r\n}
