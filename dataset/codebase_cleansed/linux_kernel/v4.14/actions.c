static struct sw_flow_key *clone_key(const struct sw_flow_key *key_)\r\n{\r\nstruct action_flow_keys *keys = this_cpu_ptr(flow_keys);\r\nint level = this_cpu_read(exec_actions_level);\r\nstruct sw_flow_key *key = NULL;\r\nif (level <= OVS_DEFERRED_ACTION_THRESHOLD) {\r\nkey = &keys->key[level - 1];\r\n*key = *key_;\r\n}\r\nreturn key;\r\n}\r\nstatic void action_fifo_init(struct action_fifo *fifo)\r\n{\r\nfifo->head = 0;\r\nfifo->tail = 0;\r\n}\r\nstatic bool action_fifo_is_empty(const struct action_fifo *fifo)\r\n{\r\nreturn (fifo->head == fifo->tail);\r\n}\r\nstatic struct deferred_action *action_fifo_get(struct action_fifo *fifo)\r\n{\r\nif (action_fifo_is_empty(fifo))\r\nreturn NULL;\r\nreturn &fifo->fifo[fifo->tail++];\r\n}\r\nstatic struct deferred_action *action_fifo_put(struct action_fifo *fifo)\r\n{\r\nif (fifo->head >= DEFERRED_ACTION_FIFO_SIZE - 1)\r\nreturn NULL;\r\nreturn &fifo->fifo[fifo->head++];\r\n}\r\nstatic struct deferred_action *add_deferred_actions(struct sk_buff *skb,\r\nconst struct sw_flow_key *key,\r\nconst struct nlattr *actions,\r\nconst int actions_len)\r\n{\r\nstruct action_fifo *fifo;\r\nstruct deferred_action *da;\r\nfifo = this_cpu_ptr(action_fifos);\r\nda = action_fifo_put(fifo);\r\nif (da) {\r\nda->skb = skb;\r\nda->actions = actions;\r\nda->actions_len = actions_len;\r\nda->pkt_key = *key;\r\n}\r\nreturn da;\r\n}\r\nstatic void invalidate_flow_key(struct sw_flow_key *key)\r\n{\r\nkey->mac_proto |= SW_FLOW_KEY_INVALID;\r\n}\r\nstatic bool is_flow_key_valid(const struct sw_flow_key *key)\r\n{\r\nreturn !(key->mac_proto & SW_FLOW_KEY_INVALID);\r\n}\r\nstatic void update_ethertype(struct sk_buff *skb, struct ethhdr *hdr,\r\n__be16 ethertype)\r\n{\r\nif (skb->ip_summed == CHECKSUM_COMPLETE) {\r\n__be16 diff[] = { ~(hdr->h_proto), ethertype };\r\nskb->csum = ~csum_partial((char *)diff, sizeof(diff),\r\n~skb->csum);\r\n}\r\nhdr->h_proto = ethertype;\r\n}\r\nstatic int push_mpls(struct sk_buff *skb, struct sw_flow_key *key,\r\nconst struct ovs_action_push_mpls *mpls)\r\n{\r\nstruct mpls_shim_hdr *new_mpls_lse;\r\nif (skb->encapsulation)\r\nreturn -ENOTSUPP;\r\nif (skb_cow_head(skb, MPLS_HLEN) < 0)\r\nreturn -ENOMEM;\r\nif (!skb->inner_protocol) {\r\nskb_set_inner_network_header(skb, skb->mac_len);\r\nskb_set_inner_protocol(skb, skb->protocol);\r\n}\r\nskb_push(skb, MPLS_HLEN);\r\nmemmove(skb_mac_header(skb) - MPLS_HLEN, skb_mac_header(skb),\r\nskb->mac_len);\r\nskb_reset_mac_header(skb);\r\nskb_set_network_header(skb, skb->mac_len);\r\nnew_mpls_lse = mpls_hdr(skb);\r\nnew_mpls_lse->label_stack_entry = mpls->mpls_lse;\r\nskb_postpush_rcsum(skb, new_mpls_lse, MPLS_HLEN);\r\nif (ovs_key_mac_proto(key) == MAC_PROTO_ETHERNET)\r\nupdate_ethertype(skb, eth_hdr(skb), mpls->mpls_ethertype);\r\nskb->protocol = mpls->mpls_ethertype;\r\ninvalidate_flow_key(key);\r\nreturn 0;\r\n}\r\nstatic int pop_mpls(struct sk_buff *skb, struct sw_flow_key *key,\r\nconst __be16 ethertype)\r\n{\r\nint err;\r\nerr = skb_ensure_writable(skb, skb->mac_len + MPLS_HLEN);\r\nif (unlikely(err))\r\nreturn err;\r\nskb_postpull_rcsum(skb, mpls_hdr(skb), MPLS_HLEN);\r\nmemmove(skb_mac_header(skb) + MPLS_HLEN, skb_mac_header(skb),\r\nskb->mac_len);\r\n__skb_pull(skb, MPLS_HLEN);\r\nskb_reset_mac_header(skb);\r\nskb_set_network_header(skb, skb->mac_len);\r\nif (ovs_key_mac_proto(key) == MAC_PROTO_ETHERNET) {\r\nstruct ethhdr *hdr;\r\nhdr = (struct ethhdr *)((void *)mpls_hdr(skb) - ETH_HLEN);\r\nupdate_ethertype(skb, hdr, ethertype);\r\n}\r\nif (eth_p_mpls(skb->protocol))\r\nskb->protocol = ethertype;\r\ninvalidate_flow_key(key);\r\nreturn 0;\r\n}\r\nstatic int set_mpls(struct sk_buff *skb, struct sw_flow_key *flow_key,\r\nconst __be32 *mpls_lse, const __be32 *mask)\r\n{\r\nstruct mpls_shim_hdr *stack;\r\n__be32 lse;\r\nint err;\r\nerr = skb_ensure_writable(skb, skb->mac_len + MPLS_HLEN);\r\nif (unlikely(err))\r\nreturn err;\r\nstack = mpls_hdr(skb);\r\nlse = OVS_MASKED(stack->label_stack_entry, *mpls_lse, *mask);\r\nif (skb->ip_summed == CHECKSUM_COMPLETE) {\r\n__be32 diff[] = { ~(stack->label_stack_entry), lse };\r\nskb->csum = ~csum_partial((char *)diff, sizeof(diff),\r\n~skb->csum);\r\n}\r\nstack->label_stack_entry = lse;\r\nflow_key->mpls.top_lse = lse;\r\nreturn 0;\r\n}\r\nstatic int pop_vlan(struct sk_buff *skb, struct sw_flow_key *key)\r\n{\r\nint err;\r\nerr = skb_vlan_pop(skb);\r\nif (skb_vlan_tag_present(skb)) {\r\ninvalidate_flow_key(key);\r\n} else {\r\nkey->eth.vlan.tci = 0;\r\nkey->eth.vlan.tpid = 0;\r\n}\r\nreturn err;\r\n}\r\nstatic int push_vlan(struct sk_buff *skb, struct sw_flow_key *key,\r\nconst struct ovs_action_push_vlan *vlan)\r\n{\r\nif (skb_vlan_tag_present(skb)) {\r\ninvalidate_flow_key(key);\r\n} else {\r\nkey->eth.vlan.tci = vlan->vlan_tci;\r\nkey->eth.vlan.tpid = vlan->vlan_tpid;\r\n}\r\nreturn skb_vlan_push(skb, vlan->vlan_tpid,\r\nntohs(vlan->vlan_tci) & ~VLAN_TAG_PRESENT);\r\n}\r\nstatic void ether_addr_copy_masked(u8 *dst_, const u8 *src_, const u8 *mask_)\r\n{\r\nu16 *dst = (u16 *)dst_;\r\nconst u16 *src = (const u16 *)src_;\r\nconst u16 *mask = (const u16 *)mask_;\r\nOVS_SET_MASKED(dst[0], src[0], mask[0]);\r\nOVS_SET_MASKED(dst[1], src[1], mask[1]);\r\nOVS_SET_MASKED(dst[2], src[2], mask[2]);\r\n}\r\nstatic int set_eth_addr(struct sk_buff *skb, struct sw_flow_key *flow_key,\r\nconst struct ovs_key_ethernet *key,\r\nconst struct ovs_key_ethernet *mask)\r\n{\r\nint err;\r\nerr = skb_ensure_writable(skb, ETH_HLEN);\r\nif (unlikely(err))\r\nreturn err;\r\nskb_postpull_rcsum(skb, eth_hdr(skb), ETH_ALEN * 2);\r\nether_addr_copy_masked(eth_hdr(skb)->h_source, key->eth_src,\r\nmask->eth_src);\r\nether_addr_copy_masked(eth_hdr(skb)->h_dest, key->eth_dst,\r\nmask->eth_dst);\r\nskb_postpush_rcsum(skb, eth_hdr(skb), ETH_ALEN * 2);\r\nether_addr_copy(flow_key->eth.src, eth_hdr(skb)->h_source);\r\nether_addr_copy(flow_key->eth.dst, eth_hdr(skb)->h_dest);\r\nreturn 0;\r\n}\r\nstatic int pop_eth(struct sk_buff *skb, struct sw_flow_key *key)\r\n{\r\nskb_pull_rcsum(skb, ETH_HLEN);\r\nskb_reset_mac_header(skb);\r\nskb_reset_mac_len(skb);\r\nkey->mac_proto = MAC_PROTO_NONE;\r\ninvalidate_flow_key(key);\r\nreturn 0;\r\n}\r\nstatic int push_eth(struct sk_buff *skb, struct sw_flow_key *key,\r\nconst struct ovs_action_push_eth *ethh)\r\n{\r\nstruct ethhdr *hdr;\r\nif (skb_cow_head(skb, ETH_HLEN) < 0)\r\nreturn -ENOMEM;\r\nskb_push(skb, ETH_HLEN);\r\nskb_reset_mac_header(skb);\r\nskb_reset_mac_len(skb);\r\nhdr = eth_hdr(skb);\r\nether_addr_copy(hdr->h_source, ethh->addresses.eth_src);\r\nether_addr_copy(hdr->h_dest, ethh->addresses.eth_dst);\r\nhdr->h_proto = skb->protocol;\r\nskb_postpush_rcsum(skb, hdr, ETH_HLEN);\r\nkey->mac_proto = MAC_PROTO_ETHERNET;\r\ninvalidate_flow_key(key);\r\nreturn 0;\r\n}\r\nstatic void update_ip_l4_checksum(struct sk_buff *skb, struct iphdr *nh,\r\n__be32 addr, __be32 new_addr)\r\n{\r\nint transport_len = skb->len - skb_transport_offset(skb);\r\nif (nh->frag_off & htons(IP_OFFSET))\r\nreturn;\r\nif (nh->protocol == IPPROTO_TCP) {\r\nif (likely(transport_len >= sizeof(struct tcphdr)))\r\ninet_proto_csum_replace4(&tcp_hdr(skb)->check, skb,\r\naddr, new_addr, true);\r\n} else if (nh->protocol == IPPROTO_UDP) {\r\nif (likely(transport_len >= sizeof(struct udphdr))) {\r\nstruct udphdr *uh = udp_hdr(skb);\r\nif (uh->check || skb->ip_summed == CHECKSUM_PARTIAL) {\r\ninet_proto_csum_replace4(&uh->check, skb,\r\naddr, new_addr, true);\r\nif (!uh->check)\r\nuh->check = CSUM_MANGLED_0;\r\n}\r\n}\r\n}\r\n}\r\nstatic void set_ip_addr(struct sk_buff *skb, struct iphdr *nh,\r\n__be32 *addr, __be32 new_addr)\r\n{\r\nupdate_ip_l4_checksum(skb, nh, *addr, new_addr);\r\ncsum_replace4(&nh->check, *addr, new_addr);\r\nskb_clear_hash(skb);\r\n*addr = new_addr;\r\n}\r\nstatic void update_ipv6_checksum(struct sk_buff *skb, u8 l4_proto,\r\n__be32 addr[4], const __be32 new_addr[4])\r\n{\r\nint transport_len = skb->len - skb_transport_offset(skb);\r\nif (l4_proto == NEXTHDR_TCP) {\r\nif (likely(transport_len >= sizeof(struct tcphdr)))\r\ninet_proto_csum_replace16(&tcp_hdr(skb)->check, skb,\r\naddr, new_addr, true);\r\n} else if (l4_proto == NEXTHDR_UDP) {\r\nif (likely(transport_len >= sizeof(struct udphdr))) {\r\nstruct udphdr *uh = udp_hdr(skb);\r\nif (uh->check || skb->ip_summed == CHECKSUM_PARTIAL) {\r\ninet_proto_csum_replace16(&uh->check, skb,\r\naddr, new_addr, true);\r\nif (!uh->check)\r\nuh->check = CSUM_MANGLED_0;\r\n}\r\n}\r\n} else if (l4_proto == NEXTHDR_ICMP) {\r\nif (likely(transport_len >= sizeof(struct icmp6hdr)))\r\ninet_proto_csum_replace16(&icmp6_hdr(skb)->icmp6_cksum,\r\nskb, addr, new_addr, true);\r\n}\r\n}\r\nstatic void mask_ipv6_addr(const __be32 old[4], const __be32 addr[4],\r\nconst __be32 mask[4], __be32 masked[4])\r\n{\r\nmasked[0] = OVS_MASKED(old[0], addr[0], mask[0]);\r\nmasked[1] = OVS_MASKED(old[1], addr[1], mask[1]);\r\nmasked[2] = OVS_MASKED(old[2], addr[2], mask[2]);\r\nmasked[3] = OVS_MASKED(old[3], addr[3], mask[3]);\r\n}\r\nstatic void set_ipv6_addr(struct sk_buff *skb, u8 l4_proto,\r\n__be32 addr[4], const __be32 new_addr[4],\r\nbool recalculate_csum)\r\n{\r\nif (recalculate_csum)\r\nupdate_ipv6_checksum(skb, l4_proto, addr, new_addr);\r\nskb_clear_hash(skb);\r\nmemcpy(addr, new_addr, sizeof(__be32[4]));\r\n}\r\nstatic void set_ipv6_fl(struct ipv6hdr *nh, u32 fl, u32 mask)\r\n{\r\nOVS_SET_MASKED(nh->flow_lbl[0], (u8)(fl >> 16), (u8)(mask >> 16));\r\nOVS_SET_MASKED(nh->flow_lbl[1], (u8)(fl >> 8), (u8)(mask >> 8));\r\nOVS_SET_MASKED(nh->flow_lbl[2], (u8)fl, (u8)mask);\r\n}\r\nstatic void set_ip_ttl(struct sk_buff *skb, struct iphdr *nh, u8 new_ttl,\r\nu8 mask)\r\n{\r\nnew_ttl = OVS_MASKED(nh->ttl, new_ttl, mask);\r\ncsum_replace2(&nh->check, htons(nh->ttl << 8), htons(new_ttl << 8));\r\nnh->ttl = new_ttl;\r\n}\r\nstatic int set_ipv4(struct sk_buff *skb, struct sw_flow_key *flow_key,\r\nconst struct ovs_key_ipv4 *key,\r\nconst struct ovs_key_ipv4 *mask)\r\n{\r\nstruct iphdr *nh;\r\n__be32 new_addr;\r\nint err;\r\nerr = skb_ensure_writable(skb, skb_network_offset(skb) +\r\nsizeof(struct iphdr));\r\nif (unlikely(err))\r\nreturn err;\r\nnh = ip_hdr(skb);\r\nif (mask->ipv4_src) {\r\nnew_addr = OVS_MASKED(nh->saddr, key->ipv4_src, mask->ipv4_src);\r\nif (unlikely(new_addr != nh->saddr)) {\r\nset_ip_addr(skb, nh, &nh->saddr, new_addr);\r\nflow_key->ipv4.addr.src = new_addr;\r\n}\r\n}\r\nif (mask->ipv4_dst) {\r\nnew_addr = OVS_MASKED(nh->daddr, key->ipv4_dst, mask->ipv4_dst);\r\nif (unlikely(new_addr != nh->daddr)) {\r\nset_ip_addr(skb, nh, &nh->daddr, new_addr);\r\nflow_key->ipv4.addr.dst = new_addr;\r\n}\r\n}\r\nif (mask->ipv4_tos) {\r\nipv4_change_dsfield(nh, ~mask->ipv4_tos, key->ipv4_tos);\r\nflow_key->ip.tos = nh->tos;\r\n}\r\nif (mask->ipv4_ttl) {\r\nset_ip_ttl(skb, nh, key->ipv4_ttl, mask->ipv4_ttl);\r\nflow_key->ip.ttl = nh->ttl;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool is_ipv6_mask_nonzero(const __be32 addr[4])\r\n{\r\nreturn !!(addr[0] | addr[1] | addr[2] | addr[3]);\r\n}\r\nstatic int set_ipv6(struct sk_buff *skb, struct sw_flow_key *flow_key,\r\nconst struct ovs_key_ipv6 *key,\r\nconst struct ovs_key_ipv6 *mask)\r\n{\r\nstruct ipv6hdr *nh;\r\nint err;\r\nerr = skb_ensure_writable(skb, skb_network_offset(skb) +\r\nsizeof(struct ipv6hdr));\r\nif (unlikely(err))\r\nreturn err;\r\nnh = ipv6_hdr(skb);\r\nif (is_ipv6_mask_nonzero(mask->ipv6_src)) {\r\n__be32 *saddr = (__be32 *)&nh->saddr;\r\n__be32 masked[4];\r\nmask_ipv6_addr(saddr, key->ipv6_src, mask->ipv6_src, masked);\r\nif (unlikely(memcmp(saddr, masked, sizeof(masked)))) {\r\nset_ipv6_addr(skb, flow_key->ip.proto, saddr, masked,\r\ntrue);\r\nmemcpy(&flow_key->ipv6.addr.src, masked,\r\nsizeof(flow_key->ipv6.addr.src));\r\n}\r\n}\r\nif (is_ipv6_mask_nonzero(mask->ipv6_dst)) {\r\nunsigned int offset = 0;\r\nint flags = IP6_FH_F_SKIP_RH;\r\nbool recalc_csum = true;\r\n__be32 *daddr = (__be32 *)&nh->daddr;\r\n__be32 masked[4];\r\nmask_ipv6_addr(daddr, key->ipv6_dst, mask->ipv6_dst, masked);\r\nif (unlikely(memcmp(daddr, masked, sizeof(masked)))) {\r\nif (ipv6_ext_hdr(nh->nexthdr))\r\nrecalc_csum = (ipv6_find_hdr(skb, &offset,\r\nNEXTHDR_ROUTING,\r\nNULL, &flags)\r\n!= NEXTHDR_ROUTING);\r\nset_ipv6_addr(skb, flow_key->ip.proto, daddr, masked,\r\nrecalc_csum);\r\nmemcpy(&flow_key->ipv6.addr.dst, masked,\r\nsizeof(flow_key->ipv6.addr.dst));\r\n}\r\n}\r\nif (mask->ipv6_tclass) {\r\nipv6_change_dsfield(nh, ~mask->ipv6_tclass, key->ipv6_tclass);\r\nflow_key->ip.tos = ipv6_get_dsfield(nh);\r\n}\r\nif (mask->ipv6_label) {\r\nset_ipv6_fl(nh, ntohl(key->ipv6_label),\r\nntohl(mask->ipv6_label));\r\nflow_key->ipv6.label =\r\n*(__be32 *)nh & htonl(IPV6_FLOWINFO_FLOWLABEL);\r\n}\r\nif (mask->ipv6_hlimit) {\r\nOVS_SET_MASKED(nh->hop_limit, key->ipv6_hlimit,\r\nmask->ipv6_hlimit);\r\nflow_key->ip.ttl = nh->hop_limit;\r\n}\r\nreturn 0;\r\n}\r\nstatic void set_tp_port(struct sk_buff *skb, __be16 *port,\r\n__be16 new_port, __sum16 *check)\r\n{\r\ninet_proto_csum_replace2(check, skb, *port, new_port, false);\r\n*port = new_port;\r\n}\r\nstatic int set_udp(struct sk_buff *skb, struct sw_flow_key *flow_key,\r\nconst struct ovs_key_udp *key,\r\nconst struct ovs_key_udp *mask)\r\n{\r\nstruct udphdr *uh;\r\n__be16 src, dst;\r\nint err;\r\nerr = skb_ensure_writable(skb, skb_transport_offset(skb) +\r\nsizeof(struct udphdr));\r\nif (unlikely(err))\r\nreturn err;\r\nuh = udp_hdr(skb);\r\nsrc = OVS_MASKED(uh->source, key->udp_src, mask->udp_src);\r\ndst = OVS_MASKED(uh->dest, key->udp_dst, mask->udp_dst);\r\nif (uh->check && skb->ip_summed != CHECKSUM_PARTIAL) {\r\nif (likely(src != uh->source)) {\r\nset_tp_port(skb, &uh->source, src, &uh->check);\r\nflow_key->tp.src = src;\r\n}\r\nif (likely(dst != uh->dest)) {\r\nset_tp_port(skb, &uh->dest, dst, &uh->check);\r\nflow_key->tp.dst = dst;\r\n}\r\nif (unlikely(!uh->check))\r\nuh->check = CSUM_MANGLED_0;\r\n} else {\r\nuh->source = src;\r\nuh->dest = dst;\r\nflow_key->tp.src = src;\r\nflow_key->tp.dst = dst;\r\n}\r\nskb_clear_hash(skb);\r\nreturn 0;\r\n}\r\nstatic int set_tcp(struct sk_buff *skb, struct sw_flow_key *flow_key,\r\nconst struct ovs_key_tcp *key,\r\nconst struct ovs_key_tcp *mask)\r\n{\r\nstruct tcphdr *th;\r\n__be16 src, dst;\r\nint err;\r\nerr = skb_ensure_writable(skb, skb_transport_offset(skb) +\r\nsizeof(struct tcphdr));\r\nif (unlikely(err))\r\nreturn err;\r\nth = tcp_hdr(skb);\r\nsrc = OVS_MASKED(th->source, key->tcp_src, mask->tcp_src);\r\nif (likely(src != th->source)) {\r\nset_tp_port(skb, &th->source, src, &th->check);\r\nflow_key->tp.src = src;\r\n}\r\ndst = OVS_MASKED(th->dest, key->tcp_dst, mask->tcp_dst);\r\nif (likely(dst != th->dest)) {\r\nset_tp_port(skb, &th->dest, dst, &th->check);\r\nflow_key->tp.dst = dst;\r\n}\r\nskb_clear_hash(skb);\r\nreturn 0;\r\n}\r\nstatic int set_sctp(struct sk_buff *skb, struct sw_flow_key *flow_key,\r\nconst struct ovs_key_sctp *key,\r\nconst struct ovs_key_sctp *mask)\r\n{\r\nunsigned int sctphoff = skb_transport_offset(skb);\r\nstruct sctphdr *sh;\r\n__le32 old_correct_csum, new_csum, old_csum;\r\nint err;\r\nerr = skb_ensure_writable(skb, sctphoff + sizeof(struct sctphdr));\r\nif (unlikely(err))\r\nreturn err;\r\nsh = sctp_hdr(skb);\r\nold_csum = sh->checksum;\r\nold_correct_csum = sctp_compute_cksum(skb, sctphoff);\r\nsh->source = OVS_MASKED(sh->source, key->sctp_src, mask->sctp_src);\r\nsh->dest = OVS_MASKED(sh->dest, key->sctp_dst, mask->sctp_dst);\r\nnew_csum = sctp_compute_cksum(skb, sctphoff);\r\nsh->checksum = old_csum ^ old_correct_csum ^ new_csum;\r\nskb_clear_hash(skb);\r\nflow_key->tp.src = sh->source;\r\nflow_key->tp.dst = sh->dest;\r\nreturn 0;\r\n}\r\nstatic int ovs_vport_output(struct net *net, struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct ovs_frag_data *data = this_cpu_ptr(&ovs_frag_data_storage);\r\nstruct vport *vport = data->vport;\r\nif (skb_cow_head(skb, data->l2_len) < 0) {\r\nkfree_skb(skb);\r\nreturn -ENOMEM;\r\n}\r\n__skb_dst_copy(skb, data->dst);\r\n*OVS_CB(skb) = data->cb;\r\nskb->inner_protocol = data->inner_protocol;\r\nskb->vlan_tci = data->vlan_tci;\r\nskb->vlan_proto = data->vlan_proto;\r\nskb_push(skb, data->l2_len);\r\nmemcpy(skb->data, &data->l2_data, data->l2_len);\r\nskb_postpush_rcsum(skb, skb->data, data->l2_len);\r\nskb_reset_mac_header(skb);\r\nif (eth_p_mpls(skb->protocol)) {\r\nskb->inner_network_header = skb->network_header;\r\nskb_set_network_header(skb, data->network_offset);\r\nskb_reset_mac_len(skb);\r\n}\r\novs_vport_send(vport, skb, data->mac_proto);\r\nreturn 0;\r\n}\r\nstatic unsigned int\r\novs_dst_get_mtu(const struct dst_entry *dst)\r\n{\r\nreturn dst->dev->mtu;\r\n}\r\nstatic void prepare_frag(struct vport *vport, struct sk_buff *skb,\r\nu16 orig_network_offset, u8 mac_proto)\r\n{\r\nunsigned int hlen = skb_network_offset(skb);\r\nstruct ovs_frag_data *data;\r\ndata = this_cpu_ptr(&ovs_frag_data_storage);\r\ndata->dst = skb->_skb_refdst;\r\ndata->vport = vport;\r\ndata->cb = *OVS_CB(skb);\r\ndata->inner_protocol = skb->inner_protocol;\r\ndata->network_offset = orig_network_offset;\r\ndata->vlan_tci = skb->vlan_tci;\r\ndata->vlan_proto = skb->vlan_proto;\r\ndata->mac_proto = mac_proto;\r\ndata->l2_len = hlen;\r\nmemcpy(&data->l2_data, skb->data, hlen);\r\nmemset(IPCB(skb), 0, sizeof(struct inet_skb_parm));\r\nskb_pull(skb, hlen);\r\n}\r\nstatic void ovs_fragment(struct net *net, struct vport *vport,\r\nstruct sk_buff *skb, u16 mru,\r\nstruct sw_flow_key *key)\r\n{\r\nu16 orig_network_offset = 0;\r\nif (eth_p_mpls(skb->protocol)) {\r\norig_network_offset = skb_network_offset(skb);\r\nskb->network_header = skb->inner_network_header;\r\n}\r\nif (skb_network_offset(skb) > MAX_L2_LEN) {\r\nOVS_NLERR(1, "L2 header too long to fragment");\r\ngoto err;\r\n}\r\nif (key->eth.type == htons(ETH_P_IP)) {\r\nstruct dst_entry ovs_dst;\r\nunsigned long orig_dst;\r\nprepare_frag(vport, skb, orig_network_offset,\r\novs_key_mac_proto(key));\r\ndst_init(&ovs_dst, &ovs_dst_ops, NULL, 1,\r\nDST_OBSOLETE_NONE, DST_NOCOUNT);\r\novs_dst.dev = vport->dev;\r\norig_dst = skb->_skb_refdst;\r\nskb_dst_set_noref(skb, &ovs_dst);\r\nIPCB(skb)->frag_max_size = mru;\r\nip_do_fragment(net, skb->sk, skb, ovs_vport_output);\r\nrefdst_drop(orig_dst);\r\n} else if (key->eth.type == htons(ETH_P_IPV6)) {\r\nconst struct nf_ipv6_ops *v6ops = nf_get_ipv6_ops();\r\nunsigned long orig_dst;\r\nstruct rt6_info ovs_rt;\r\nif (!v6ops)\r\ngoto err;\r\nprepare_frag(vport, skb, orig_network_offset,\r\novs_key_mac_proto(key));\r\nmemset(&ovs_rt, 0, sizeof(ovs_rt));\r\ndst_init(&ovs_rt.dst, &ovs_dst_ops, NULL, 1,\r\nDST_OBSOLETE_NONE, DST_NOCOUNT);\r\novs_rt.dst.dev = vport->dev;\r\norig_dst = skb->_skb_refdst;\r\nskb_dst_set_noref(skb, &ovs_rt.dst);\r\nIP6CB(skb)->frag_max_size = mru;\r\nv6ops->fragment(net, skb->sk, skb, ovs_vport_output);\r\nrefdst_drop(orig_dst);\r\n} else {\r\nWARN_ONCE(1, "Failed fragment ->%s: eth=%04x, MRU=%d, MTU=%d.",\r\novs_vport_name(vport), ntohs(key->eth.type), mru,\r\nvport->dev->mtu);\r\ngoto err;\r\n}\r\nreturn;\r\nerr:\r\nkfree_skb(skb);\r\n}\r\nstatic void do_output(struct datapath *dp, struct sk_buff *skb, int out_port,\r\nstruct sw_flow_key *key)\r\n{\r\nstruct vport *vport = ovs_vport_rcu(dp, out_port);\r\nif (likely(vport)) {\r\nu16 mru = OVS_CB(skb)->mru;\r\nu32 cutlen = OVS_CB(skb)->cutlen;\r\nif (unlikely(cutlen > 0)) {\r\nif (skb->len - cutlen > ovs_mac_header_len(key))\r\npskb_trim(skb, skb->len - cutlen);\r\nelse\r\npskb_trim(skb, ovs_mac_header_len(key));\r\n}\r\nif (likely(!mru ||\r\n(skb->len <= mru + vport->dev->hard_header_len))) {\r\novs_vport_send(vport, skb, ovs_key_mac_proto(key));\r\n} else if (mru <= vport->dev->mtu) {\r\nstruct net *net = read_pnet(&dp->net);\r\novs_fragment(net, vport, skb, mru, key);\r\n} else {\r\nkfree_skb(skb);\r\n}\r\n} else {\r\nkfree_skb(skb);\r\n}\r\n}\r\nstatic int output_userspace(struct datapath *dp, struct sk_buff *skb,\r\nstruct sw_flow_key *key, const struct nlattr *attr,\r\nconst struct nlattr *actions, int actions_len,\r\nuint32_t cutlen)\r\n{\r\nstruct dp_upcall_info upcall;\r\nconst struct nlattr *a;\r\nint rem;\r\nmemset(&upcall, 0, sizeof(upcall));\r\nupcall.cmd = OVS_PACKET_CMD_ACTION;\r\nupcall.mru = OVS_CB(skb)->mru;\r\nfor (a = nla_data(attr), rem = nla_len(attr); rem > 0;\r\na = nla_next(a, &rem)) {\r\nswitch (nla_type(a)) {\r\ncase OVS_USERSPACE_ATTR_USERDATA:\r\nupcall.userdata = a;\r\nbreak;\r\ncase OVS_USERSPACE_ATTR_PID:\r\nupcall.portid = nla_get_u32(a);\r\nbreak;\r\ncase OVS_USERSPACE_ATTR_EGRESS_TUN_PORT: {\r\nstruct vport *vport;\r\nvport = ovs_vport_rcu(dp, nla_get_u32(a));\r\nif (vport) {\r\nint err;\r\nerr = dev_fill_metadata_dst(vport->dev, skb);\r\nif (!err)\r\nupcall.egress_tun_info = skb_tunnel_info(skb);\r\n}\r\nbreak;\r\n}\r\ncase OVS_USERSPACE_ATTR_ACTIONS: {\r\nupcall.actions = actions;\r\nupcall.actions_len = actions_len;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn ovs_dp_upcall(dp, skb, key, &upcall, cutlen);\r\n}\r\nstatic int sample(struct datapath *dp, struct sk_buff *skb,\r\nstruct sw_flow_key *key, const struct nlattr *attr,\r\nbool last)\r\n{\r\nstruct nlattr *actions;\r\nstruct nlattr *sample_arg;\r\nint rem = nla_len(attr);\r\nconst struct sample_arg *arg;\r\nbool clone_flow_key;\r\nsample_arg = nla_data(attr);\r\narg = nla_data(sample_arg);\r\nactions = nla_next(sample_arg, &rem);\r\nif ((arg->probability != U32_MAX) &&\r\n(!arg->probability || prandom_u32() > arg->probability)) {\r\nif (last)\r\nconsume_skb(skb);\r\nreturn 0;\r\n}\r\nclone_flow_key = !arg->exec;\r\nreturn clone_execute(dp, skb, key, 0, actions, rem, last,\r\nclone_flow_key);\r\n}\r\nstatic void execute_hash(struct sk_buff *skb, struct sw_flow_key *key,\r\nconst struct nlattr *attr)\r\n{\r\nstruct ovs_action_hash *hash_act = nla_data(attr);\r\nu32 hash = 0;\r\nhash = skb_get_hash(skb);\r\nhash = jhash_1word(hash, hash_act->hash_basis);\r\nif (!hash)\r\nhash = 0x1;\r\nkey->ovs_flow_hash = hash;\r\n}\r\nstatic int execute_set_action(struct sk_buff *skb,\r\nstruct sw_flow_key *flow_key,\r\nconst struct nlattr *a)\r\n{\r\nif (nla_type(a) == OVS_KEY_ATTR_TUNNEL_INFO) {\r\nstruct ovs_tunnel_info *tun = nla_data(a);\r\nskb_dst_drop(skb);\r\ndst_hold((struct dst_entry *)tun->tun_dst);\r\nskb_dst_set(skb, (struct dst_entry *)tun->tun_dst);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int execute_masked_set_action(struct sk_buff *skb,\r\nstruct sw_flow_key *flow_key,\r\nconst struct nlattr *a)\r\n{\r\nint err = 0;\r\nswitch (nla_type(a)) {\r\ncase OVS_KEY_ATTR_PRIORITY:\r\nOVS_SET_MASKED(skb->priority, nla_get_u32(a),\r\n*get_mask(a, u32 *));\r\nflow_key->phy.priority = skb->priority;\r\nbreak;\r\ncase OVS_KEY_ATTR_SKB_MARK:\r\nOVS_SET_MASKED(skb->mark, nla_get_u32(a), *get_mask(a, u32 *));\r\nflow_key->phy.skb_mark = skb->mark;\r\nbreak;\r\ncase OVS_KEY_ATTR_TUNNEL_INFO:\r\nerr = -EINVAL;\r\nbreak;\r\ncase OVS_KEY_ATTR_ETHERNET:\r\nerr = set_eth_addr(skb, flow_key, nla_data(a),\r\nget_mask(a, struct ovs_key_ethernet *));\r\nbreak;\r\ncase OVS_KEY_ATTR_IPV4:\r\nerr = set_ipv4(skb, flow_key, nla_data(a),\r\nget_mask(a, struct ovs_key_ipv4 *));\r\nbreak;\r\ncase OVS_KEY_ATTR_IPV6:\r\nerr = set_ipv6(skb, flow_key, nla_data(a),\r\nget_mask(a, struct ovs_key_ipv6 *));\r\nbreak;\r\ncase OVS_KEY_ATTR_TCP:\r\nerr = set_tcp(skb, flow_key, nla_data(a),\r\nget_mask(a, struct ovs_key_tcp *));\r\nbreak;\r\ncase OVS_KEY_ATTR_UDP:\r\nerr = set_udp(skb, flow_key, nla_data(a),\r\nget_mask(a, struct ovs_key_udp *));\r\nbreak;\r\ncase OVS_KEY_ATTR_SCTP:\r\nerr = set_sctp(skb, flow_key, nla_data(a),\r\nget_mask(a, struct ovs_key_sctp *));\r\nbreak;\r\ncase OVS_KEY_ATTR_MPLS:\r\nerr = set_mpls(skb, flow_key, nla_data(a), get_mask(a,\r\n__be32 *));\r\nbreak;\r\ncase OVS_KEY_ATTR_CT_STATE:\r\ncase OVS_KEY_ATTR_CT_ZONE:\r\ncase OVS_KEY_ATTR_CT_MARK:\r\ncase OVS_KEY_ATTR_CT_LABELS:\r\ncase OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV4:\r\ncase OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV6:\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int execute_recirc(struct datapath *dp, struct sk_buff *skb,\r\nstruct sw_flow_key *key,\r\nconst struct nlattr *a, bool last)\r\n{\r\nu32 recirc_id;\r\nif (!is_flow_key_valid(key)) {\r\nint err;\r\nerr = ovs_flow_key_update(skb, key);\r\nif (err)\r\nreturn err;\r\n}\r\nBUG_ON(!is_flow_key_valid(key));\r\nrecirc_id = nla_get_u32(a);\r\nreturn clone_execute(dp, skb, key, recirc_id, NULL, 0, last, true);\r\n}\r\nstatic int do_execute_actions(struct datapath *dp, struct sk_buff *skb,\r\nstruct sw_flow_key *key,\r\nconst struct nlattr *attr, int len)\r\n{\r\nconst struct nlattr *a;\r\nint rem;\r\nfor (a = attr, rem = len; rem > 0;\r\na = nla_next(a, &rem)) {\r\nint err = 0;\r\nswitch (nla_type(a)) {\r\ncase OVS_ACTION_ATTR_OUTPUT: {\r\nint port = nla_get_u32(a);\r\nstruct sk_buff *clone;\r\nif (nla_is_last(a, rem)) {\r\ndo_output(dp, skb, port, key);\r\nreturn 0;\r\n}\r\nclone = skb_clone(skb, GFP_ATOMIC);\r\nif (clone)\r\ndo_output(dp, clone, port, key);\r\nOVS_CB(skb)->cutlen = 0;\r\nbreak;\r\n}\r\ncase OVS_ACTION_ATTR_TRUNC: {\r\nstruct ovs_action_trunc *trunc = nla_data(a);\r\nif (skb->len > trunc->max_len)\r\nOVS_CB(skb)->cutlen = skb->len - trunc->max_len;\r\nbreak;\r\n}\r\ncase OVS_ACTION_ATTR_USERSPACE:\r\noutput_userspace(dp, skb, key, a, attr,\r\nlen, OVS_CB(skb)->cutlen);\r\nOVS_CB(skb)->cutlen = 0;\r\nbreak;\r\ncase OVS_ACTION_ATTR_HASH:\r\nexecute_hash(skb, key, a);\r\nbreak;\r\ncase OVS_ACTION_ATTR_PUSH_MPLS:\r\nerr = push_mpls(skb, key, nla_data(a));\r\nbreak;\r\ncase OVS_ACTION_ATTR_POP_MPLS:\r\nerr = pop_mpls(skb, key, nla_get_be16(a));\r\nbreak;\r\ncase OVS_ACTION_ATTR_PUSH_VLAN:\r\nerr = push_vlan(skb, key, nla_data(a));\r\nbreak;\r\ncase OVS_ACTION_ATTR_POP_VLAN:\r\nerr = pop_vlan(skb, key);\r\nbreak;\r\ncase OVS_ACTION_ATTR_RECIRC: {\r\nbool last = nla_is_last(a, rem);\r\nerr = execute_recirc(dp, skb, key, a, last);\r\nif (last) {\r\nreturn err;\r\n}\r\nbreak;\r\n}\r\ncase OVS_ACTION_ATTR_SET:\r\nerr = execute_set_action(skb, key, nla_data(a));\r\nbreak;\r\ncase OVS_ACTION_ATTR_SET_MASKED:\r\ncase OVS_ACTION_ATTR_SET_TO_MASKED:\r\nerr = execute_masked_set_action(skb, key, nla_data(a));\r\nbreak;\r\ncase OVS_ACTION_ATTR_SAMPLE: {\r\nbool last = nla_is_last(a, rem);\r\nerr = sample(dp, skb, key, a, last);\r\nif (last)\r\nreturn err;\r\nbreak;\r\n}\r\ncase OVS_ACTION_ATTR_CT:\r\nif (!is_flow_key_valid(key)) {\r\nerr = ovs_flow_key_update(skb, key);\r\nif (err)\r\nreturn err;\r\n}\r\nerr = ovs_ct_execute(ovs_dp_get_net(dp), skb, key,\r\nnla_data(a));\r\nif (err)\r\nreturn err == -EINPROGRESS ? 0 : err;\r\nbreak;\r\ncase OVS_ACTION_ATTR_PUSH_ETH:\r\nerr = push_eth(skb, key, nla_data(a));\r\nbreak;\r\ncase OVS_ACTION_ATTR_POP_ETH:\r\nerr = pop_eth(skb, key);\r\nbreak;\r\n}\r\nif (unlikely(err)) {\r\nkfree_skb(skb);\r\nreturn err;\r\n}\r\n}\r\nconsume_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int clone_execute(struct datapath *dp, struct sk_buff *skb,\r\nstruct sw_flow_key *key, u32 recirc_id,\r\nconst struct nlattr *actions, int len,\r\nbool last, bool clone_flow_key)\r\n{\r\nstruct deferred_action *da;\r\nstruct sw_flow_key *clone;\r\nskb = last ? skb : skb_clone(skb, GFP_ATOMIC);\r\nif (!skb) {\r\nreturn 0;\r\n}\r\nclone = clone_flow_key ? clone_key(key) : key;\r\nif (clone) {\r\nint err = 0;\r\nif (actions) {\r\nif (clone_flow_key)\r\n__this_cpu_inc(exec_actions_level);\r\nerr = do_execute_actions(dp, skb, clone,\r\nactions, len);\r\nif (clone_flow_key)\r\n__this_cpu_dec(exec_actions_level);\r\n} else {\r\nclone->recirc_id = recirc_id;\r\novs_dp_process_packet(skb, clone);\r\n}\r\nreturn err;\r\n}\r\nda = add_deferred_actions(skb, key, actions, len);\r\nif (da) {\r\nif (!actions) {\r\nkey = &da->pkt_key;\r\nkey->recirc_id = recirc_id;\r\n}\r\n} else {\r\nkfree_skb(skb);\r\nif (net_ratelimit()) {\r\nif (actions) {\r\npr_warn("%s: deferred action limit reached, drop sample action\n",\r\novs_dp_name(dp));\r\n} else {\r\npr_warn("%s: deferred action limit reached, drop recirc action\n",\r\novs_dp_name(dp));\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void process_deferred_actions(struct datapath *dp)\r\n{\r\nstruct action_fifo *fifo = this_cpu_ptr(action_fifos);\r\nif (action_fifo_is_empty(fifo))\r\nreturn;\r\ndo {\r\nstruct deferred_action *da = action_fifo_get(fifo);\r\nstruct sk_buff *skb = da->skb;\r\nstruct sw_flow_key *key = &da->pkt_key;\r\nconst struct nlattr *actions = da->actions;\r\nint actions_len = da->actions_len;\r\nif (actions)\r\ndo_execute_actions(dp, skb, key, actions, actions_len);\r\nelse\r\novs_dp_process_packet(skb, key);\r\n} while (!action_fifo_is_empty(fifo));\r\naction_fifo_init(fifo);\r\n}\r\nint ovs_execute_actions(struct datapath *dp, struct sk_buff *skb,\r\nconst struct sw_flow_actions *acts,\r\nstruct sw_flow_key *key)\r\n{\r\nint err, level;\r\nlevel = __this_cpu_inc_return(exec_actions_level);\r\nif (unlikely(level > OVS_RECURSION_LIMIT)) {\r\nnet_crit_ratelimited("ovs: recursion limit reached on datapath %s, probable configuration error\n",\r\novs_dp_name(dp));\r\nkfree_skb(skb);\r\nerr = -ENETDOWN;\r\ngoto out;\r\n}\r\nOVS_CB(skb)->acts_origlen = acts->orig_len;\r\nerr = do_execute_actions(dp, skb, key,\r\nacts->actions, acts->actions_len);\r\nif (level == 1)\r\nprocess_deferred_actions(dp);\r\nout:\r\n__this_cpu_dec(exec_actions_level);\r\nreturn err;\r\n}\r\nint action_fifos_init(void)\r\n{\r\naction_fifos = alloc_percpu(struct action_fifo);\r\nif (!action_fifos)\r\nreturn -ENOMEM;\r\nflow_keys = alloc_percpu(struct action_flow_keys);\r\nif (!flow_keys) {\r\nfree_percpu(action_fifos);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nvoid action_fifos_exit(void)\r\n{\r\nfree_percpu(action_fifos);\r\nfree_percpu(flow_keys);\r\n}
