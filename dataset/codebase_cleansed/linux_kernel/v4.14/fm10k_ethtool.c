static void fm10k_add_stat_strings(u8 **p, const char *prefix,\r\nconst struct fm10k_stats stats[],\r\nconst unsigned int size)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < size; i++) {\r\nsnprintf(*p, ETH_GSTRING_LEN, "%s%s",\r\nprefix, stats[i].stat_string);\r\n*p += ETH_GSTRING_LEN;\r\n}\r\n}\r\nstatic void fm10k_get_stat_strings(struct net_device *dev, u8 *data)\r\n{\r\nstruct fm10k_intfc *interface = netdev_priv(dev);\r\nunsigned int i;\r\nfm10k_add_stat_strings(&data, "", fm10k_gstrings_net_stats,\r\nFM10K_NETDEV_STATS_LEN);\r\nfm10k_add_stat_strings(&data, "", fm10k_gstrings_global_stats,\r\nFM10K_GLOBAL_STATS_LEN);\r\nfm10k_add_stat_strings(&data, "", fm10k_gstrings_mbx_stats,\r\nFM10K_MBX_STATS_LEN);\r\nif (interface->hw.mac.type != fm10k_mac_vf)\r\nfm10k_add_stat_strings(&data, "", fm10k_gstrings_pf_stats,\r\nFM10K_PF_STATS_LEN);\r\nfor (i = 0; i < interface->hw.mac.max_queues; i++) {\r\nchar prefix[ETH_GSTRING_LEN];\r\nsnprintf(prefix, ETH_GSTRING_LEN, "tx_queue_%u_", i);\r\nfm10k_add_stat_strings(&data, prefix,\r\nfm10k_gstrings_queue_stats,\r\nFM10K_QUEUE_STATS_LEN);\r\nsnprintf(prefix, ETH_GSTRING_LEN, "rx_queue_%u_", i);\r\nfm10k_add_stat_strings(&data, prefix,\r\nfm10k_gstrings_queue_stats,\r\nFM10K_QUEUE_STATS_LEN);\r\n}\r\n}\r\nstatic void fm10k_get_strings(struct net_device *dev,\r\nu32 stringset, u8 *data)\r\n{\r\nswitch (stringset) {\r\ncase ETH_SS_TEST:\r\nmemcpy(data, fm10k_gstrings_test,\r\nFM10K_TEST_LEN * ETH_GSTRING_LEN);\r\nbreak;\r\ncase ETH_SS_STATS:\r\nfm10k_get_stat_strings(dev, data);\r\nbreak;\r\ncase ETH_SS_PRIV_FLAGS:\r\nmemcpy(data, fm10k_prv_flags,\r\nFM10K_PRV_FLAG_LEN * ETH_GSTRING_LEN);\r\nbreak;\r\n}\r\n}\r\nstatic int fm10k_get_sset_count(struct net_device *dev, int sset)\r\n{\r\nstruct fm10k_intfc *interface = netdev_priv(dev);\r\nstruct fm10k_hw *hw = &interface->hw;\r\nint stats_len = FM10K_STATIC_STATS_LEN;\r\nswitch (sset) {\r\ncase ETH_SS_TEST:\r\nreturn FM10K_TEST_LEN;\r\ncase ETH_SS_STATS:\r\nstats_len += hw->mac.max_queues * 2 * FM10K_QUEUE_STATS_LEN;\r\nif (hw->mac.type != fm10k_mac_vf)\r\nstats_len += FM10K_PF_STATS_LEN;\r\nreturn stats_len;\r\ncase ETH_SS_PRIV_FLAGS:\r\nreturn FM10K_PRV_FLAG_LEN;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic void fm10k_add_ethtool_stats(u64 **data, void *pointer,\r\nconst struct fm10k_stats stats[],\r\nconst unsigned int size)\r\n{\r\nunsigned int i;\r\nchar *p;\r\nif (!pointer) {\r\nfor (i = 0; i < size; i++)\r\n*((*data)++) = 0;\r\nreturn;\r\n}\r\nfor (i = 0; i < size; i++) {\r\np = (char *)pointer + stats[i].stat_offset;\r\nswitch (stats[i].sizeof_stat) {\r\ncase sizeof(u64):\r\n*((*data)++) = *(u64 *)p;\r\nbreak;\r\ncase sizeof(u32):\r\n*((*data)++) = *(u32 *)p;\r\nbreak;\r\ncase sizeof(u16):\r\n*((*data)++) = *(u16 *)p;\r\nbreak;\r\ncase sizeof(u8):\r\n*((*data)++) = *(u8 *)p;\r\nbreak;\r\ndefault:\r\n*((*data)++) = 0;\r\n}\r\n}\r\n}\r\nstatic void fm10k_get_ethtool_stats(struct net_device *netdev,\r\nstruct ethtool_stats __always_unused *stats,\r\nu64 *data)\r\n{\r\nstruct fm10k_intfc *interface = netdev_priv(netdev);\r\nstruct net_device_stats *net_stats = &netdev->stats;\r\nint i;\r\nfm10k_update_stats(interface);\r\nfm10k_add_ethtool_stats(&data, net_stats, fm10k_gstrings_net_stats,\r\nFM10K_NETDEV_STATS_LEN);\r\nfm10k_add_ethtool_stats(&data, interface, fm10k_gstrings_global_stats,\r\nFM10K_GLOBAL_STATS_LEN);\r\nfm10k_add_ethtool_stats(&data, &interface->hw.mbx,\r\nfm10k_gstrings_mbx_stats,\r\nFM10K_MBX_STATS_LEN);\r\nif (interface->hw.mac.type != fm10k_mac_vf) {\r\nfm10k_add_ethtool_stats(&data, interface,\r\nfm10k_gstrings_pf_stats,\r\nFM10K_PF_STATS_LEN);\r\n}\r\nfor (i = 0; i < interface->hw.mac.max_queues; i++) {\r\nstruct fm10k_ring *ring;\r\nring = interface->tx_ring[i];\r\nfm10k_add_ethtool_stats(&data, ring,\r\nfm10k_gstrings_queue_stats,\r\nFM10K_QUEUE_STATS_LEN);\r\nring = interface->rx_ring[i];\r\nfm10k_add_ethtool_stats(&data, ring,\r\nfm10k_gstrings_queue_stats,\r\nFM10K_QUEUE_STATS_LEN);\r\n}\r\n}\r\nstatic void fm10k_get_reg_q(struct fm10k_hw *hw, u32 *buff, int i)\r\n{\r\nint idx = 0;\r\nbuff[idx++] = fm10k_read_reg(hw, FM10K_RDBAL(i));\r\nbuff[idx++] = fm10k_read_reg(hw, FM10K_RDBAH(i));\r\nbuff[idx++] = fm10k_read_reg(hw, FM10K_RDLEN(i));\r\nbuff[idx++] = fm10k_read_reg(hw, FM10K_TPH_RXCTRL(i));\r\nbuff[idx++] = fm10k_read_reg(hw, FM10K_RDH(i));\r\nbuff[idx++] = fm10k_read_reg(hw, FM10K_RDT(i));\r\nbuff[idx++] = fm10k_read_reg(hw, FM10K_RXQCTL(i));\r\nbuff[idx++] = fm10k_read_reg(hw, FM10K_RXDCTL(i));\r\nbuff[idx++] = fm10k_read_reg(hw, FM10K_RXINT(i));\r\nbuff[idx++] = fm10k_read_reg(hw, FM10K_SRRCTL(i));\r\nbuff[idx++] = fm10k_read_reg(hw, FM10K_QPRC(i));\r\nbuff[idx++] = fm10k_read_reg(hw, FM10K_QPRDC(i));\r\nbuff[idx++] = fm10k_read_reg(hw, FM10K_QBRC_L(i));\r\nbuff[idx++] = fm10k_read_reg(hw, FM10K_QBRC_H(i));\r\nbuff[idx++] = fm10k_read_reg(hw, FM10K_TDBAL(i));\r\nbuff[idx++] = fm10k_read_reg(hw, FM10K_TDBAH(i));\r\nbuff[idx++] = fm10k_read_reg(hw, FM10K_TDLEN(i));\r\nbuff[idx++] = fm10k_read_reg(hw, FM10K_TPH_TXCTRL(i));\r\nbuff[idx++] = fm10k_read_reg(hw, FM10K_TDH(i));\r\nbuff[idx++] = fm10k_read_reg(hw, FM10K_TDT(i));\r\nbuff[idx++] = fm10k_read_reg(hw, FM10K_TXDCTL(i));\r\nbuff[idx++] = fm10k_read_reg(hw, FM10K_TXQCTL(i));\r\nbuff[idx++] = fm10k_read_reg(hw, FM10K_TXINT(i));\r\nbuff[idx++] = fm10k_read_reg(hw, FM10K_QPTC(i));\r\nbuff[idx++] = fm10k_read_reg(hw, FM10K_QBTC_L(i));\r\nbuff[idx++] = fm10k_read_reg(hw, FM10K_QBTC_H(i));\r\nbuff[idx++] = fm10k_read_reg(hw, FM10K_TQDLOC(i));\r\nbuff[idx++] = fm10k_read_reg(hw, FM10K_TX_SGLORT(i));\r\nbuff[idx++] = fm10k_read_reg(hw, FM10K_PFVTCTL(i));\r\nBUG_ON(idx != FM10K_REGS_LEN_Q);\r\n}\r\nstatic void fm10k_get_reg_vsi(struct fm10k_hw *hw, u32 *buff, int i)\r\n{\r\nint idx = 0, j;\r\nbuff[idx++] = fm10k_read_reg(hw, FM10K_MRQC(i));\r\nfor (j = 0; j < 10; j++)\r\nbuff[idx++] = fm10k_read_reg(hw, FM10K_RSSRK(i, j));\r\nfor (j = 0; j < 32; j++)\r\nbuff[idx++] = fm10k_read_reg(hw, FM10K_RETA(i, j));\r\nBUG_ON(idx != FM10K_REGS_LEN_VSI);\r\n}\r\nstatic void fm10k_get_regs(struct net_device *netdev,\r\nstruct ethtool_regs *regs, void *p)\r\n{\r\nstruct fm10k_intfc *interface = netdev_priv(netdev);\r\nstruct fm10k_hw *hw = &interface->hw;\r\nu32 *buff = p;\r\nu16 i;\r\nregs->version = BIT(24) | (hw->revision_id << 16) | hw->device_id;\r\nswitch (hw->mac.type) {\r\ncase fm10k_mac_pf:\r\n*(buff++) = fm10k_read_reg(hw, FM10K_CTRL);\r\n*(buff++) = fm10k_read_reg(hw, FM10K_CTRL_EXT);\r\n*(buff++) = fm10k_read_reg(hw, FM10K_GCR);\r\n*(buff++) = fm10k_read_reg(hw, FM10K_GCR_EXT);\r\nfor (i = 0; i < 8; i++) {\r\n*(buff++) = fm10k_read_reg(hw, FM10K_DGLORTMAP(i));\r\n*(buff++) = fm10k_read_reg(hw, FM10K_DGLORTDEC(i));\r\n}\r\nfor (i = 0; i < 65; i++) {\r\nfm10k_get_reg_vsi(hw, buff, i);\r\nbuff += FM10K_REGS_LEN_VSI;\r\n}\r\n*(buff++) = fm10k_read_reg(hw, FM10K_DMA_CTRL);\r\n*(buff++) = fm10k_read_reg(hw, FM10K_DMA_CTRL2);\r\nfor (i = 0; i < FM10K_MAX_QUEUES_PF; i++) {\r\nfm10k_get_reg_q(hw, buff, i);\r\nbuff += FM10K_REGS_LEN_Q;\r\n}\r\n*(buff++) = fm10k_read_reg(hw, FM10K_TPH_CTRL);\r\nfor (i = 0; i < 8; i++)\r\n*(buff++) = fm10k_read_reg(hw, FM10K_INT_MAP(i));\r\nfor (i = 0; i < 130; i++)\r\n*(buff++) = fm10k_read_reg(hw, FM10K_ITR(i));\r\nbreak;\r\ncase fm10k_mac_vf:\r\n*(buff++) = fm10k_read_reg(hw, FM10K_VFCTRL);\r\n*(buff++) = fm10k_read_reg(hw, FM10K_VFINT_MAP);\r\n*(buff++) = fm10k_read_reg(hw, FM10K_VFSYSTIME);\r\nfor (i = 0; i < 8; i++)\r\n*(buff++) = fm10k_read_reg(hw, FM10K_VFITR(i));\r\nfm10k_get_reg_vsi(hw, buff, 0);\r\nbuff += FM10K_REGS_LEN_VSI;\r\nfor (i = 0; i < FM10K_MAX_QUEUES_POOL; i++) {\r\nif (i < hw->mac.max_queues)\r\nfm10k_get_reg_q(hw, buff, i);\r\nelse\r\nmemset(buff, 0, sizeof(u32) * FM10K_REGS_LEN_Q);\r\nbuff += FM10K_REGS_LEN_Q;\r\n}\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\n}\r\nstatic int fm10k_get_regs_len(struct net_device *netdev)\r\n{\r\nstruct fm10k_intfc *interface = netdev_priv(netdev);\r\nstruct fm10k_hw *hw = &interface->hw;\r\nswitch (hw->mac.type) {\r\ncase fm10k_mac_pf:\r\nreturn FM10K_REGS_LEN_PF * sizeof(u32);\r\ncase fm10k_mac_vf:\r\nreturn FM10K_REGS_LEN_VF * sizeof(u32);\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic void fm10k_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstruct fm10k_intfc *interface = netdev_priv(dev);\r\nstrncpy(info->driver, fm10k_driver_name,\r\nsizeof(info->driver) - 1);\r\nstrncpy(info->version, fm10k_driver_version,\r\nsizeof(info->version) - 1);\r\nstrncpy(info->bus_info, pci_name(interface->pdev),\r\nsizeof(info->bus_info) - 1);\r\n}\r\nstatic void fm10k_get_pauseparam(struct net_device *dev,\r\nstruct ethtool_pauseparam *pause)\r\n{\r\nstruct fm10k_intfc *interface = netdev_priv(dev);\r\npause->autoneg = 0;\r\npause->tx_pause = 1;\r\npause->rx_pause = interface->rx_pause ? 1 : 0;\r\n}\r\nstatic int fm10k_set_pauseparam(struct net_device *dev,\r\nstruct ethtool_pauseparam *pause)\r\n{\r\nstruct fm10k_intfc *interface = netdev_priv(dev);\r\nstruct fm10k_hw *hw = &interface->hw;\r\nif (pause->autoneg || !pause->tx_pause)\r\nreturn -EINVAL;\r\nif (hw->mac.type == fm10k_mac_pf)\r\ninterface->rx_pause = pause->rx_pause ? ~0 : 0;\r\nelse if (pause->rx_pause)\r\nreturn -EINVAL;\r\nif (netif_running(dev))\r\nfm10k_update_rx_drop_en(interface);\r\nreturn 0;\r\n}\r\nstatic u32 fm10k_get_msglevel(struct net_device *netdev)\r\n{\r\nstruct fm10k_intfc *interface = netdev_priv(netdev);\r\nreturn interface->msg_enable;\r\n}\r\nstatic void fm10k_set_msglevel(struct net_device *netdev, u32 data)\r\n{\r\nstruct fm10k_intfc *interface = netdev_priv(netdev);\r\ninterface->msg_enable = data;\r\n}\r\nstatic void fm10k_get_ringparam(struct net_device *netdev,\r\nstruct ethtool_ringparam *ring)\r\n{\r\nstruct fm10k_intfc *interface = netdev_priv(netdev);\r\nring->rx_max_pending = FM10K_MAX_RXD;\r\nring->tx_max_pending = FM10K_MAX_TXD;\r\nring->rx_mini_max_pending = 0;\r\nring->rx_jumbo_max_pending = 0;\r\nring->rx_pending = interface->rx_ring_count;\r\nring->tx_pending = interface->tx_ring_count;\r\nring->rx_mini_pending = 0;\r\nring->rx_jumbo_pending = 0;\r\n}\r\nstatic int fm10k_set_ringparam(struct net_device *netdev,\r\nstruct ethtool_ringparam *ring)\r\n{\r\nstruct fm10k_intfc *interface = netdev_priv(netdev);\r\nstruct fm10k_ring *temp_ring;\r\nint i, err = 0;\r\nu32 new_rx_count, new_tx_count;\r\nif ((ring->rx_mini_pending) || (ring->rx_jumbo_pending))\r\nreturn -EINVAL;\r\nnew_tx_count = clamp_t(u32, ring->tx_pending,\r\nFM10K_MIN_TXD, FM10K_MAX_TXD);\r\nnew_tx_count = ALIGN(new_tx_count, FM10K_REQ_TX_DESCRIPTOR_MULTIPLE);\r\nnew_rx_count = clamp_t(u32, ring->rx_pending,\r\nFM10K_MIN_RXD, FM10K_MAX_RXD);\r\nnew_rx_count = ALIGN(new_rx_count, FM10K_REQ_RX_DESCRIPTOR_MULTIPLE);\r\nif ((new_tx_count == interface->tx_ring_count) &&\r\n(new_rx_count == interface->rx_ring_count)) {\r\nreturn 0;\r\n}\r\nwhile (test_and_set_bit(__FM10K_RESETTING, interface->state))\r\nusleep_range(1000, 2000);\r\nif (!netif_running(interface->netdev)) {\r\nfor (i = 0; i < interface->num_tx_queues; i++)\r\ninterface->tx_ring[i]->count = new_tx_count;\r\nfor (i = 0; i < interface->num_rx_queues; i++)\r\ninterface->rx_ring[i]->count = new_rx_count;\r\ninterface->tx_ring_count = new_tx_count;\r\ninterface->rx_ring_count = new_rx_count;\r\ngoto clear_reset;\r\n}\r\ni = max_t(int, interface->num_tx_queues, interface->num_rx_queues);\r\ntemp_ring = vmalloc(i * sizeof(struct fm10k_ring));\r\nif (!temp_ring) {\r\nerr = -ENOMEM;\r\ngoto clear_reset;\r\n}\r\nfm10k_down(interface);\r\nif (new_tx_count != interface->tx_ring_count) {\r\nfor (i = 0; i < interface->num_tx_queues; i++) {\r\nmemcpy(&temp_ring[i], interface->tx_ring[i],\r\nsizeof(struct fm10k_ring));\r\ntemp_ring[i].count = new_tx_count;\r\nerr = fm10k_setup_tx_resources(&temp_ring[i]);\r\nif (err) {\r\nwhile (i) {\r\ni--;\r\nfm10k_free_tx_resources(&temp_ring[i]);\r\n}\r\ngoto err_setup;\r\n}\r\n}\r\nfor (i = 0; i < interface->num_tx_queues; i++) {\r\nfm10k_free_tx_resources(interface->tx_ring[i]);\r\nmemcpy(interface->tx_ring[i], &temp_ring[i],\r\nsizeof(struct fm10k_ring));\r\n}\r\ninterface->tx_ring_count = new_tx_count;\r\n}\r\nif (new_rx_count != interface->rx_ring_count) {\r\nfor (i = 0; i < interface->num_rx_queues; i++) {\r\nmemcpy(&temp_ring[i], interface->rx_ring[i],\r\nsizeof(struct fm10k_ring));\r\ntemp_ring[i].count = new_rx_count;\r\nerr = fm10k_setup_rx_resources(&temp_ring[i]);\r\nif (err) {\r\nwhile (i) {\r\ni--;\r\nfm10k_free_rx_resources(&temp_ring[i]);\r\n}\r\ngoto err_setup;\r\n}\r\n}\r\nfor (i = 0; i < interface->num_rx_queues; i++) {\r\nfm10k_free_rx_resources(interface->rx_ring[i]);\r\nmemcpy(interface->rx_ring[i], &temp_ring[i],\r\nsizeof(struct fm10k_ring));\r\n}\r\ninterface->rx_ring_count = new_rx_count;\r\n}\r\nerr_setup:\r\nfm10k_up(interface);\r\nvfree(temp_ring);\r\nclear_reset:\r\nclear_bit(__FM10K_RESETTING, interface->state);\r\nreturn err;\r\n}\r\nstatic int fm10k_get_coalesce(struct net_device *dev,\r\nstruct ethtool_coalesce *ec)\r\n{\r\nstruct fm10k_intfc *interface = netdev_priv(dev);\r\nec->use_adaptive_tx_coalesce = ITR_IS_ADAPTIVE(interface->tx_itr);\r\nec->tx_coalesce_usecs = interface->tx_itr & ~FM10K_ITR_ADAPTIVE;\r\nec->use_adaptive_rx_coalesce = ITR_IS_ADAPTIVE(interface->rx_itr);\r\nec->rx_coalesce_usecs = interface->rx_itr & ~FM10K_ITR_ADAPTIVE;\r\nreturn 0;\r\n}\r\nstatic int fm10k_set_coalesce(struct net_device *dev,\r\nstruct ethtool_coalesce *ec)\r\n{\r\nstruct fm10k_intfc *interface = netdev_priv(dev);\r\nstruct fm10k_q_vector *qv;\r\nu16 tx_itr, rx_itr;\r\nint i;\r\nif ((ec->rx_coalesce_usecs > FM10K_ITR_MAX) ||\r\n(ec->tx_coalesce_usecs > FM10K_ITR_MAX))\r\nreturn -EINVAL;\r\ntx_itr = ec->tx_coalesce_usecs;\r\nrx_itr = ec->rx_coalesce_usecs;\r\nif (ec->use_adaptive_tx_coalesce)\r\ntx_itr = FM10K_ITR_ADAPTIVE | FM10K_TX_ITR_DEFAULT;\r\nif (ec->use_adaptive_rx_coalesce)\r\nrx_itr = FM10K_ITR_ADAPTIVE | FM10K_RX_ITR_DEFAULT;\r\ninterface->tx_itr = tx_itr;\r\ninterface->rx_itr = rx_itr;\r\nfor (i = 0; i < interface->num_q_vectors; i++) {\r\nqv = interface->q_vector[i];\r\nqv->tx.itr = tx_itr;\r\nqv->rx.itr = rx_itr;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fm10k_get_rss_hash_opts(struct fm10k_intfc *interface,\r\nstruct ethtool_rxnfc *cmd)\r\n{\r\ncmd->data = 0;\r\nswitch (cmd->flow_type) {\r\ncase TCP_V4_FLOW:\r\ncase TCP_V6_FLOW:\r\ncmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\r\ncase UDP_V4_FLOW:\r\nif (test_bit(FM10K_FLAG_RSS_FIELD_IPV4_UDP,\r\ninterface->flags))\r\ncmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\r\ncase SCTP_V4_FLOW:\r\ncase SCTP_V6_FLOW:\r\ncase AH_ESP_V4_FLOW:\r\ncase AH_ESP_V6_FLOW:\r\ncase AH_V4_FLOW:\r\ncase AH_V6_FLOW:\r\ncase ESP_V4_FLOW:\r\ncase ESP_V6_FLOW:\r\ncase IPV4_FLOW:\r\ncase IPV6_FLOW:\r\ncmd->data |= RXH_IP_SRC | RXH_IP_DST;\r\nbreak;\r\ncase UDP_V6_FLOW:\r\nif (test_bit(FM10K_FLAG_RSS_FIELD_IPV6_UDP,\r\ninterface->flags))\r\ncmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\r\ncmd->data |= RXH_IP_SRC | RXH_IP_DST;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fm10k_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd,\r\nu32 __always_unused *rule_locs)\r\n{\r\nstruct fm10k_intfc *interface = netdev_priv(dev);\r\nint ret = -EOPNOTSUPP;\r\nswitch (cmd->cmd) {\r\ncase ETHTOOL_GRXRINGS:\r\ncmd->data = interface->num_rx_queues;\r\nret = 0;\r\nbreak;\r\ncase ETHTOOL_GRXFH:\r\nret = fm10k_get_rss_hash_opts(interface, cmd);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int fm10k_set_rss_hash_opt(struct fm10k_intfc *interface,\r\nstruct ethtool_rxnfc *nfc)\r\n{\r\nint rss_ipv4_udp = test_bit(FM10K_FLAG_RSS_FIELD_IPV4_UDP,\r\ninterface->flags);\r\nint rss_ipv6_udp = test_bit(FM10K_FLAG_RSS_FIELD_IPV6_UDP,\r\ninterface->flags);\r\nif (nfc->data & ~(RXH_IP_SRC | RXH_IP_DST |\r\nRXH_L4_B_0_1 | RXH_L4_B_2_3))\r\nreturn -EINVAL;\r\nswitch (nfc->flow_type) {\r\ncase TCP_V4_FLOW:\r\ncase TCP_V6_FLOW:\r\nif (!(nfc->data & RXH_IP_SRC) ||\r\n!(nfc->data & RXH_IP_DST) ||\r\n!(nfc->data & RXH_L4_B_0_1) ||\r\n!(nfc->data & RXH_L4_B_2_3))\r\nreturn -EINVAL;\r\nbreak;\r\ncase UDP_V4_FLOW:\r\nif (!(nfc->data & RXH_IP_SRC) ||\r\n!(nfc->data & RXH_IP_DST))\r\nreturn -EINVAL;\r\nswitch (nfc->data & (RXH_L4_B_0_1 | RXH_L4_B_2_3)) {\r\ncase 0:\r\nclear_bit(FM10K_FLAG_RSS_FIELD_IPV4_UDP,\r\ninterface->flags);\r\nbreak;\r\ncase (RXH_L4_B_0_1 | RXH_L4_B_2_3):\r\nset_bit(FM10K_FLAG_RSS_FIELD_IPV4_UDP,\r\ninterface->flags);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase UDP_V6_FLOW:\r\nif (!(nfc->data & RXH_IP_SRC) ||\r\n!(nfc->data & RXH_IP_DST))\r\nreturn -EINVAL;\r\nswitch (nfc->data & (RXH_L4_B_0_1 | RXH_L4_B_2_3)) {\r\ncase 0:\r\nclear_bit(FM10K_FLAG_RSS_FIELD_IPV6_UDP,\r\ninterface->flags);\r\nbreak;\r\ncase (RXH_L4_B_0_1 | RXH_L4_B_2_3):\r\nset_bit(FM10K_FLAG_RSS_FIELD_IPV6_UDP,\r\ninterface->flags);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase AH_ESP_V4_FLOW:\r\ncase AH_V4_FLOW:\r\ncase ESP_V4_FLOW:\r\ncase SCTP_V4_FLOW:\r\ncase AH_ESP_V6_FLOW:\r\ncase AH_V6_FLOW:\r\ncase ESP_V6_FLOW:\r\ncase SCTP_V6_FLOW:\r\nif (!(nfc->data & RXH_IP_SRC) ||\r\n!(nfc->data & RXH_IP_DST) ||\r\n(nfc->data & RXH_L4_B_0_1) ||\r\n(nfc->data & RXH_L4_B_2_3))\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif ((rss_ipv4_udp != test_bit(FM10K_FLAG_RSS_FIELD_IPV4_UDP,\r\ninterface->flags)) ||\r\n(rss_ipv6_udp != test_bit(FM10K_FLAG_RSS_FIELD_IPV6_UDP,\r\ninterface->flags))) {\r\nstruct fm10k_hw *hw = &interface->hw;\r\nbool warn = false;\r\nu32 mrqc;\r\nmrqc = FM10K_MRQC_IPV4 |\r\nFM10K_MRQC_TCP_IPV4 |\r\nFM10K_MRQC_IPV6 |\r\nFM10K_MRQC_TCP_IPV6;\r\nif (test_bit(FM10K_FLAG_RSS_FIELD_IPV4_UDP,\r\ninterface->flags)) {\r\nmrqc |= FM10K_MRQC_UDP_IPV4;\r\nwarn = true;\r\n}\r\nif (test_bit(FM10K_FLAG_RSS_FIELD_IPV6_UDP,\r\ninterface->flags)) {\r\nmrqc |= FM10K_MRQC_UDP_IPV6;\r\nwarn = true;\r\n}\r\nif (warn)\r\nnetif_warn(interface, drv, interface->netdev,\r\n"enabling UDP RSS: fragmented packets may arrive out of order to the stack above\n");\r\nfm10k_write_reg(hw, FM10K_MRQC(0), mrqc);\r\n}\r\nreturn 0;\r\n}\r\nstatic int fm10k_set_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd)\r\n{\r\nstruct fm10k_intfc *interface = netdev_priv(dev);\r\nint ret = -EOPNOTSUPP;\r\nswitch (cmd->cmd) {\r\ncase ETHTOOL_SRXFH:\r\nret = fm10k_set_rss_hash_opt(interface, cmd);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int fm10k_mbx_test(struct fm10k_intfc *interface, u64 *data)\r\n{\r\nstruct fm10k_hw *hw = &interface->hw;\r\nstruct fm10k_mbx_info *mbx = &hw->mbx;\r\nu32 attr_flag, test_msg[6];\r\nunsigned long timeout;\r\nint err = -EINVAL;\r\nif (hw->mac.type != fm10k_mac_vf)\r\nreturn 0;\r\nfor (attr_flag = BIT(FM10K_TEST_MSG_UNSET);\r\nattr_flag < BIT(2 * FM10K_TEST_MSG_NESTED);\r\nattr_flag += attr_flag) {\r\nfm10k_tlv_msg_test_create(test_msg, attr_flag);\r\nfm10k_mbx_lock(interface);\r\nmbx->test_result = FM10K_NOT_IMPLEMENTED;\r\nerr = mbx->ops.enqueue_tx(hw, mbx, test_msg);\r\nfm10k_mbx_unlock(interface);\r\ntimeout = jiffies + HZ;\r\ndo {\r\nif (err < 0)\r\ngoto err_out;\r\nusleep_range(500, 1000);\r\nfm10k_mbx_lock(interface);\r\nmbx->ops.process(hw, mbx);\r\nfm10k_mbx_unlock(interface);\r\nerr = mbx->test_result;\r\nif (!err)\r\nbreak;\r\n} while (time_is_after_jiffies(timeout));\r\nif (err)\r\ngoto err_out;\r\n}\r\nerr_out:\r\n*data = err < 0 ? (attr_flag) : (err > 0);\r\nreturn err;\r\n}\r\nstatic void fm10k_self_test(struct net_device *dev,\r\nstruct ethtool_test *eth_test, u64 *data)\r\n{\r\nstruct fm10k_intfc *interface = netdev_priv(dev);\r\nstruct fm10k_hw *hw = &interface->hw;\r\nmemset(data, 0, sizeof(*data) * FM10K_TEST_LEN);\r\nif (FM10K_REMOVED(hw->hw_addr)) {\r\nnetif_err(interface, drv, dev,\r\n"Interface removed - test blocked\n");\r\neth_test->flags |= ETH_TEST_FL_FAILED;\r\nreturn;\r\n}\r\nif (fm10k_mbx_test(interface, &data[FM10K_TEST_MBX]))\r\neth_test->flags |= ETH_TEST_FL_FAILED;\r\n}\r\nstatic u32 fm10k_get_priv_flags(struct net_device *netdev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int fm10k_set_priv_flags(struct net_device *netdev, u32 priv_flags)\r\n{\r\nif (priv_flags >= BIT(FM10K_PRV_FLAG_LEN))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic u32 fm10k_get_reta_size(struct net_device __always_unused *netdev)\r\n{\r\nreturn FM10K_RETA_SIZE * FM10K_RETA_ENTRIES_PER_REG;\r\n}\r\nvoid fm10k_write_reta(struct fm10k_intfc *interface, const u32 *indir)\r\n{\r\nu16 rss_i = interface->ring_feature[RING_F_RSS].indices;\r\nstruct fm10k_hw *hw = &interface->hw;\r\nu32 table[4];\r\nint i, j;\r\nfor (i = 0; i < FM10K_RETA_SIZE; i++) {\r\nu32 reta, n;\r\nfor (j = 0; j < 4; j++) {\r\nif (indir)\r\nn = indir[4 * i + j];\r\nelse\r\nn = ethtool_rxfh_indir_default(4 * i + j,\r\nrss_i);\r\ntable[j] = n;\r\n}\r\nreta = table[0] |\r\n(table[1] << 8) |\r\n(table[2] << 16) |\r\n(table[3] << 24);\r\nif (interface->reta[i] == reta)\r\ncontinue;\r\ninterface->reta[i] = reta;\r\nfm10k_write_reg(hw, FM10K_RETA(0, i), reta);\r\n}\r\n}\r\nstatic int fm10k_get_reta(struct net_device *netdev, u32 *indir)\r\n{\r\nstruct fm10k_intfc *interface = netdev_priv(netdev);\r\nint i;\r\nif (!indir)\r\nreturn 0;\r\nfor (i = 0; i < FM10K_RETA_SIZE; i++, indir += 4) {\r\nu32 reta = interface->reta[i];\r\nindir[0] = (reta << 24) >> 24;\r\nindir[1] = (reta << 16) >> 24;\r\nindir[2] = (reta << 8) >> 24;\r\nindir[3] = (reta) >> 24;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fm10k_set_reta(struct net_device *netdev, const u32 *indir)\r\n{\r\nstruct fm10k_intfc *interface = netdev_priv(netdev);\r\nint i;\r\nu16 rss_i;\r\nif (!indir)\r\nreturn 0;\r\nrss_i = interface->ring_feature[RING_F_RSS].indices;\r\nfor (i = fm10k_get_reta_size(netdev); i--;) {\r\nif (indir[i] < rss_i)\r\ncontinue;\r\nreturn -EINVAL;\r\n}\r\nfm10k_write_reta(interface, indir);\r\nreturn 0;\r\n}\r\nstatic u32 fm10k_get_rssrk_size(struct net_device __always_unused *netdev)\r\n{\r\nreturn FM10K_RSSRK_SIZE * FM10K_RSSRK_ENTRIES_PER_REG;\r\n}\r\nstatic int fm10k_get_rssh(struct net_device *netdev, u32 *indir, u8 *key,\r\nu8 *hfunc)\r\n{\r\nstruct fm10k_intfc *interface = netdev_priv(netdev);\r\nint i, err;\r\nif (hfunc)\r\n*hfunc = ETH_RSS_HASH_TOP;\r\nerr = fm10k_get_reta(netdev, indir);\r\nif (err || !key)\r\nreturn err;\r\nfor (i = 0; i < FM10K_RSSRK_SIZE; i++, key += 4)\r\n*(__le32 *)key = cpu_to_le32(interface->rssrk[i]);\r\nreturn 0;\r\n}\r\nstatic int fm10k_set_rssh(struct net_device *netdev, const u32 *indir,\r\nconst u8 *key, const u8 hfunc)\r\n{\r\nstruct fm10k_intfc *interface = netdev_priv(netdev);\r\nstruct fm10k_hw *hw = &interface->hw;\r\nint i, err;\r\nif (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != ETH_RSS_HASH_TOP)\r\nreturn -EOPNOTSUPP;\r\nerr = fm10k_set_reta(netdev, indir);\r\nif (err || !key)\r\nreturn err;\r\nfor (i = 0; i < FM10K_RSSRK_SIZE; i++, key += 4) {\r\nu32 rssrk = le32_to_cpu(*(__le32 *)key);\r\nif (interface->rssrk[i] == rssrk)\r\ncontinue;\r\ninterface->rssrk[i] = rssrk;\r\nfm10k_write_reg(hw, FM10K_RSSRK(0, i), rssrk);\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int fm10k_max_channels(struct net_device *dev)\r\n{\r\nstruct fm10k_intfc *interface = netdev_priv(dev);\r\nunsigned int max_combined = interface->hw.mac.max_queues;\r\nu8 tcs = netdev_get_num_tc(dev);\r\nif (tcs > 1)\r\nmax_combined = BIT((fls(max_combined / tcs) - 1));\r\nreturn max_combined;\r\n}\r\nstatic void fm10k_get_channels(struct net_device *dev,\r\nstruct ethtool_channels *ch)\r\n{\r\nstruct fm10k_intfc *interface = netdev_priv(dev);\r\nstruct fm10k_hw *hw = &interface->hw;\r\nch->max_combined = fm10k_max_channels(dev);\r\nch->max_other = NON_Q_VECTORS(hw);\r\nch->other_count = ch->max_other;\r\nch->combined_count = interface->ring_feature[RING_F_RSS].indices;\r\n}\r\nstatic int fm10k_set_channels(struct net_device *dev,\r\nstruct ethtool_channels *ch)\r\n{\r\nstruct fm10k_intfc *interface = netdev_priv(dev);\r\nunsigned int count = ch->combined_count;\r\nstruct fm10k_hw *hw = &interface->hw;\r\nif (!count || ch->rx_count || ch->tx_count)\r\nreturn -EINVAL;\r\nif (ch->other_count != NON_Q_VECTORS(hw))\r\nreturn -EINVAL;\r\nif (count > fm10k_max_channels(dev))\r\nreturn -EINVAL;\r\ninterface->ring_feature[RING_F_RSS].limit = count;\r\nreturn fm10k_setup_tc(dev, netdev_get_num_tc(dev));\r\n}\r\nvoid fm10k_set_ethtool_ops(struct net_device *dev)\r\n{\r\ndev->ethtool_ops = &fm10k_ethtool_ops;\r\n}
