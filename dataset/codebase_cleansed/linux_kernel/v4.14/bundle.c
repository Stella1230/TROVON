static ssize_t bundle_class_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct gb_bundle *bundle = to_gb_bundle(dev);\r\nreturn sprintf(buf, "0x%02x\n", bundle->class);\r\n}\r\nstatic ssize_t bundle_id_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct gb_bundle *bundle = to_gb_bundle(dev);\r\nreturn sprintf(buf, "%u\n", bundle->id);\r\n}\r\nstatic ssize_t state_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct gb_bundle *bundle = to_gb_bundle(dev);\r\nif (bundle->state == NULL)\r\nreturn sprintf(buf, "\n");\r\nreturn sprintf(buf, "%s\n", bundle->state);\r\n}\r\nstatic ssize_t state_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nstruct gb_bundle *bundle = to_gb_bundle(dev);\r\nkfree(bundle->state);\r\nbundle->state = kstrdup(buf, GFP_KERNEL);\r\nif (!bundle->state)\r\nreturn -ENOMEM;\r\nsysfs_notify(&bundle->dev.kobj, NULL, "state");\r\nreturn size;\r\n}\r\nstatic struct gb_bundle *gb_bundle_find(struct gb_interface *intf,\r\nu8 bundle_id)\r\n{\r\nstruct gb_bundle *bundle;\r\nlist_for_each_entry(bundle, &intf->bundles, links) {\r\nif (bundle->id == bundle_id)\r\nreturn bundle;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void gb_bundle_release(struct device *dev)\r\n{\r\nstruct gb_bundle *bundle = to_gb_bundle(dev);\r\ntrace_gb_bundle_release(bundle);\r\nkfree(bundle->state);\r\nkfree(bundle->cport_desc);\r\nkfree(bundle);\r\n}\r\nstatic void gb_bundle_disable_all_connections(struct gb_bundle *bundle)\r\n{\r\nstruct gb_connection *connection;\r\nlist_for_each_entry(connection, &bundle->connections, bundle_links)\r\ngb_connection_disable(connection);\r\n}\r\nstatic void gb_bundle_enable_all_connections(struct gb_bundle *bundle)\r\n{\r\nstruct gb_connection *connection;\r\nlist_for_each_entry(connection, &bundle->connections, bundle_links)\r\ngb_connection_enable(connection);\r\n}\r\nstatic int gb_bundle_suspend(struct device *dev)\r\n{\r\nstruct gb_bundle *bundle = to_gb_bundle(dev);\r\nconst struct dev_pm_ops *pm = dev->driver->pm;\r\nint ret;\r\nif (pm && pm->runtime_suspend) {\r\nret = pm->runtime_suspend(&bundle->dev);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\ngb_bundle_disable_all_connections(bundle);\r\n}\r\nret = gb_control_bundle_suspend(bundle->intf->control, bundle->id);\r\nif (ret) {\r\nif (pm && pm->runtime_resume)\r\nret = pm->runtime_resume(dev);\r\nelse\r\ngb_bundle_enable_all_connections(bundle);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int gb_bundle_resume(struct device *dev)\r\n{\r\nstruct gb_bundle *bundle = to_gb_bundle(dev);\r\nconst struct dev_pm_ops *pm = dev->driver->pm;\r\nint ret;\r\nret = gb_control_bundle_resume(bundle->intf->control, bundle->id);\r\nif (ret)\r\nreturn ret;\r\nif (pm && pm->runtime_resume) {\r\nret = pm->runtime_resume(dev);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\ngb_bundle_enable_all_connections(bundle);\r\n}\r\nreturn 0;\r\n}\r\nstatic int gb_bundle_idle(struct device *dev)\r\n{\r\npm_runtime_mark_last_busy(dev);\r\npm_request_autosuspend(dev);\r\nreturn 0;\r\n}\r\nstruct gb_bundle *gb_bundle_create(struct gb_interface *intf, u8 bundle_id,\r\nu8 class)\r\n{\r\nstruct gb_bundle *bundle;\r\nif (bundle_id == BUNDLE_ID_NONE) {\r\ndev_err(&intf->dev, "can't use bundle id %u\n", bundle_id);\r\nreturn NULL;\r\n}\r\nif (gb_bundle_find(intf, bundle_id)) {\r\ndev_err(&intf->dev, "duplicate bundle id %u\n", bundle_id);\r\nreturn NULL;\r\n}\r\nbundle = kzalloc(sizeof(*bundle), GFP_KERNEL);\r\nif (!bundle)\r\nreturn NULL;\r\nbundle->intf = intf;\r\nbundle->id = bundle_id;\r\nbundle->class = class;\r\nINIT_LIST_HEAD(&bundle->connections);\r\nbundle->dev.parent = &intf->dev;\r\nbundle->dev.bus = &greybus_bus_type;\r\nbundle->dev.type = &greybus_bundle_type;\r\nbundle->dev.groups = bundle_groups;\r\nbundle->dev.dma_mask = intf->dev.dma_mask;\r\ndevice_initialize(&bundle->dev);\r\ndev_set_name(&bundle->dev, "%s.%d", dev_name(&intf->dev), bundle_id);\r\nlist_add(&bundle->links, &intf->bundles);\r\ntrace_gb_bundle_create(bundle);\r\nreturn bundle;\r\n}\r\nint gb_bundle_add(struct gb_bundle *bundle)\r\n{\r\nint ret;\r\nret = device_add(&bundle->dev);\r\nif (ret) {\r\ndev_err(&bundle->dev, "failed to register bundle: %d\n", ret);\r\nreturn ret;\r\n}\r\ntrace_gb_bundle_add(bundle);\r\nreturn 0;\r\n}\r\nvoid gb_bundle_destroy(struct gb_bundle *bundle)\r\n{\r\ntrace_gb_bundle_destroy(bundle);\r\nif (device_is_registered(&bundle->dev))\r\ndevice_del(&bundle->dev);\r\nlist_del(&bundle->links);\r\nput_device(&bundle->dev);\r\n}
