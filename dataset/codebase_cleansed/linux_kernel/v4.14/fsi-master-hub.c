static int hub_master_read(struct fsi_master *master, int link,\r\nuint8_t id, uint32_t addr, void *val, size_t size)\r\n{\r\nstruct fsi_master_hub *hub = to_fsi_master_hub(master);\r\nif (id != 0)\r\nreturn -EINVAL;\r\naddr += hub->addr + (link * FSI_HUB_LINK_SIZE);\r\nreturn fsi_slave_read(hub->upstream->slave, addr, val, size);\r\n}\r\nstatic int hub_master_write(struct fsi_master *master, int link,\r\nuint8_t id, uint32_t addr, const void *val, size_t size)\r\n{\r\nstruct fsi_master_hub *hub = to_fsi_master_hub(master);\r\nif (id != 0)\r\nreturn -EINVAL;\r\naddr += hub->addr + (link * FSI_HUB_LINK_SIZE);\r\nreturn fsi_slave_write(hub->upstream->slave, addr, val, size);\r\n}\r\nstatic int hub_master_break(struct fsi_master *master, int link)\r\n{\r\nuint32_t addr, cmd;\r\naddr = 0x4;\r\ncmd = cpu_to_be32(0xc0de0000);\r\nreturn hub_master_write(master, link, 0, addr, &cmd, sizeof(cmd));\r\n}\r\nstatic int hub_master_link_enable(struct fsi_master *master, int link)\r\n{\r\nstruct fsi_master_hub *hub = to_fsi_master_hub(master);\r\nint idx, bit;\r\n__be32 reg;\r\nint rc;\r\nidx = link / 32;\r\nbit = link % 32;\r\nreg = cpu_to_be32(0x80000000 >> bit);\r\nrc = fsi_device_write(hub->upstream, FSI_MSENP0 + (4 * idx), &reg, 4);\r\nmdelay(FSI_LINK_ENABLE_SETUP_TIME);\r\nfsi_device_read(hub->upstream, FSI_MENP0 + (4 * idx), &reg, 4);\r\nreturn rc;\r\n}\r\nstatic void hub_master_release(struct device *dev)\r\n{\r\nstruct fsi_master_hub *hub = to_fsi_master_hub(dev_to_fsi_master(dev));\r\nkfree(hub);\r\n}\r\nstatic inline u32 fsi_mmode_crs0(u32 x)\r\n{\r\nreturn (x & FSI_MMODE_CRS0MASK) << FSI_MMODE_CRS0SHFT;\r\n}\r\nstatic inline u32 fsi_mmode_crs1(u32 x)\r\n{\r\nreturn (x & FSI_MMODE_CRS1MASK) << FSI_MMODE_CRS1SHFT;\r\n}\r\nstatic int hub_master_init(struct fsi_master_hub *hub)\r\n{\r\nstruct fsi_device *dev = hub->upstream;\r\n__be32 reg;\r\nint rc;\r\nreg = cpu_to_be32(FSI_MRESP_RST_ALL_MASTER | FSI_MRESP_RST_ALL_LINK\r\n| FSI_MRESP_RST_MCR | FSI_MRESP_RST_PYE);\r\nrc = fsi_device_write(dev, FSI_MRESP0, &reg, sizeof(reg));\r\nif (rc)\r\nreturn rc;\r\nreg = cpu_to_be32(FSI_MRESP_RST_ALL_MASTER | FSI_MRESP_RST_ALL_LINK\r\n| FSI_MRESP_RST_MCR | FSI_MRESP_RST_PYE);\r\nrc = fsi_device_write(dev, FSI_MRESP0, &reg, sizeof(reg));\r\nif (rc)\r\nreturn rc;\r\nreg = cpu_to_be32(FSI_MECTRL_EOAE | FSI_MECTRL_P8_AUTO_TERM);\r\nrc = fsi_device_write(dev, FSI_MECTRL, &reg, sizeof(reg));\r\nif (rc)\r\nreturn rc;\r\nreg = cpu_to_be32(FSI_MMODE_EIP | FSI_MMODE_ECRC | FSI_MMODE_EPC\r\n| fsi_mmode_crs0(1) | fsi_mmode_crs1(1)\r\n| FSI_MMODE_P8_TO_LSB);\r\nrc = fsi_device_write(dev, FSI_MMODE, &reg, sizeof(reg));\r\nif (rc)\r\nreturn rc;\r\nreg = cpu_to_be32(0xffff0000);\r\nrc = fsi_device_write(dev, FSI_MDLYR, &reg, sizeof(reg));\r\nif (rc)\r\nreturn rc;\r\nreg = ~0;\r\nrc = fsi_device_write(dev, FSI_MSENP0, &reg, sizeof(reg));\r\nif (rc)\r\nreturn rc;\r\nmdelay(FSI_LINK_ENABLE_SETUP_TIME);\r\nrc = fsi_device_write(dev, FSI_MCENP0, &reg, sizeof(reg));\r\nif (rc)\r\nreturn rc;\r\nrc = fsi_device_read(dev, FSI_MAEB, &reg, sizeof(reg));\r\nif (rc)\r\nreturn rc;\r\nreg = cpu_to_be32(FSI_MRESP_RST_ALL_MASTER | FSI_MRESP_RST_ALL_LINK);\r\nrc = fsi_device_write(dev, FSI_MRESP0, &reg, sizeof(reg));\r\nif (rc)\r\nreturn rc;\r\nrc = fsi_device_read(dev, FSI_MLEVP0, &reg, sizeof(reg));\r\nif (rc)\r\nreturn rc;\r\nreg = cpu_to_be32(FSI_MRESB_RST_GEN);\r\nrc = fsi_device_write(dev, FSI_MRESB0, &reg, sizeof(reg));\r\nif (rc)\r\nreturn rc;\r\nreg = cpu_to_be32(FSI_MRESB_RST_ERR);\r\nreturn fsi_device_write(dev, FSI_MRESB0, &reg, sizeof(reg));\r\n}\r\nstatic int hub_master_probe(struct device *dev)\r\n{\r\nstruct fsi_device *fsi_dev = to_fsi_dev(dev);\r\nstruct fsi_master_hub *hub;\r\nuint32_t reg, links;\r\n__be32 __reg;\r\nint rc;\r\nrc = fsi_device_read(fsi_dev, FSI_MVER, &__reg, sizeof(__reg));\r\nif (rc)\r\nreturn rc;\r\nreg = be32_to_cpu(__reg);\r\nlinks = (reg >> 8) & 0xff;\r\ndev_info(dev, "hub version %08x (%d links)\n", reg, links);\r\nrc = fsi_slave_claim_range(fsi_dev->slave, FSI_HUB_LINK_OFFSET,\r\nFSI_HUB_LINK_SIZE * links);\r\nif (rc) {\r\ndev_err(dev, "can't claim slave address range for links");\r\nreturn rc;\r\n}\r\nhub = kzalloc(sizeof(*hub), GFP_KERNEL);\r\nif (!hub) {\r\nrc = -ENOMEM;\r\ngoto err_release;\r\n}\r\nhub->addr = FSI_HUB_LINK_OFFSET;\r\nhub->size = FSI_HUB_LINK_SIZE * links;\r\nhub->upstream = fsi_dev;\r\nhub->master.dev.parent = dev;\r\nhub->master.dev.release = hub_master_release;\r\nhub->master.n_links = links;\r\nhub->master.read = hub_master_read;\r\nhub->master.write = hub_master_write;\r\nhub->master.send_break = hub_master_break;\r\nhub->master.link_enable = hub_master_link_enable;\r\ndev_set_drvdata(dev, hub);\r\nhub_master_init(hub);\r\nrc = fsi_master_register(&hub->master);\r\nif (!rc)\r\nreturn 0;\r\nkfree(hub);\r\nerr_release:\r\nfsi_slave_release_range(fsi_dev->slave, FSI_HUB_LINK_OFFSET,\r\nFSI_HUB_LINK_SIZE * links);\r\nreturn rc;\r\n}\r\nstatic int hub_master_remove(struct device *dev)\r\n{\r\nstruct fsi_master_hub *hub = dev_get_drvdata(dev);\r\nfsi_master_unregister(&hub->master);\r\nfsi_slave_release_range(hub->upstream->slave, hub->addr, hub->size);\r\nreturn 0;\r\n}
