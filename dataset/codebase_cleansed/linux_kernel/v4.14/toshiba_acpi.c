static inline void _set_bit(u32 *word, u32 mask, int value)\r\n{\r\n*word = (*word & ~mask) | (mask * value);\r\n}\r\nstatic int write_acpi_int(const char *methodName, int val)\r\n{\r\nacpi_status status;\r\nstatus = acpi_execute_simple_method(NULL, (char *)methodName, val);\r\nreturn (status == AE_OK) ? 0 : -EIO;\r\n}\r\nstatic acpi_status tci_raw(struct toshiba_acpi_dev *dev,\r\nconst u32 in[TCI_WORDS], u32 out[TCI_WORDS])\r\n{\r\nunion acpi_object in_objs[TCI_WORDS], out_objs[TCI_WORDS + 1];\r\nstruct acpi_object_list params;\r\nstruct acpi_buffer results;\r\nacpi_status status;\r\nint i;\r\nparams.count = TCI_WORDS;\r\nparams.pointer = in_objs;\r\nfor (i = 0; i < TCI_WORDS; ++i) {\r\nin_objs[i].type = ACPI_TYPE_INTEGER;\r\nin_objs[i].integer.value = in[i];\r\n}\r\nresults.length = sizeof(out_objs);\r\nresults.pointer = out_objs;\r\nstatus = acpi_evaluate_object(dev->acpi_dev->handle,\r\n(char *)dev->method_hci, &params,\r\n&results);\r\nif ((status == AE_OK) && (out_objs->package.count <= TCI_WORDS)) {\r\nfor (i = 0; i < out_objs->package.count; ++i)\r\nout[i] = out_objs->package.elements[i].integer.value;\r\n}\r\nreturn status;\r\n}\r\nstatic u32 hci_write(struct toshiba_acpi_dev *dev, u32 reg, u32 in1)\r\n{\r\nu32 in[TCI_WORDS] = { HCI_SET, reg, in1, 0, 0, 0 };\r\nu32 out[TCI_WORDS];\r\nacpi_status status = tci_raw(dev, in, out);\r\nreturn ACPI_SUCCESS(status) ? out[0] : TOS_FAILURE;\r\n}\r\nstatic u32 hci_read(struct toshiba_acpi_dev *dev, u32 reg, u32 *out1)\r\n{\r\nu32 in[TCI_WORDS] = { HCI_GET, reg, 0, 0, 0, 0 };\r\nu32 out[TCI_WORDS];\r\nacpi_status status = tci_raw(dev, in, out);\r\nif (ACPI_FAILURE(status))\r\nreturn TOS_FAILURE;\r\n*out1 = out[2];\r\nreturn out[0];\r\n}\r\nstatic int sci_open(struct toshiba_acpi_dev *dev)\r\n{\r\nu32 in[TCI_WORDS] = { SCI_OPEN, 0, 0, 0, 0, 0 };\r\nu32 out[TCI_WORDS];\r\nacpi_status status = tci_raw(dev, in, out);\r\nif (ACPI_FAILURE(status)) {\r\npr_err("ACPI call to open SCI failed\n");\r\nreturn 0;\r\n}\r\nif (out[0] == TOS_OPEN_CLOSE_OK) {\r\nreturn 1;\r\n} else if (out[0] == TOS_ALREADY_OPEN) {\r\npr_info("Toshiba SCI already opened\n");\r\nreturn 1;\r\n} else if (out[0] == TOS_NOT_SUPPORTED) {\r\nreturn 1;\r\n} else if (out[0] == TOS_NOT_PRESENT) {\r\npr_info("Toshiba SCI is not present\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic void sci_close(struct toshiba_acpi_dev *dev)\r\n{\r\nu32 in[TCI_WORDS] = { SCI_CLOSE, 0, 0, 0, 0, 0 };\r\nu32 out[TCI_WORDS];\r\nacpi_status status = tci_raw(dev, in, out);\r\nif (ACPI_FAILURE(status)) {\r\npr_err("ACPI call to close SCI failed\n");\r\nreturn;\r\n}\r\nif (out[0] == TOS_OPEN_CLOSE_OK)\r\nreturn;\r\nelse if (out[0] == TOS_NOT_OPENED)\r\npr_info("Toshiba SCI not opened\n");\r\nelse if (out[0] == TOS_NOT_PRESENT)\r\npr_info("Toshiba SCI is not present\n");\r\n}\r\nstatic u32 sci_read(struct toshiba_acpi_dev *dev, u32 reg, u32 *out1)\r\n{\r\nu32 in[TCI_WORDS] = { SCI_GET, reg, 0, 0, 0, 0 };\r\nu32 out[TCI_WORDS];\r\nacpi_status status = tci_raw(dev, in, out);\r\nif (ACPI_FAILURE(status))\r\nreturn TOS_FAILURE;\r\n*out1 = out[2];\r\nreturn out[0];\r\n}\r\nstatic u32 sci_write(struct toshiba_acpi_dev *dev, u32 reg, u32 in1)\r\n{\r\nu32 in[TCI_WORDS] = { SCI_SET, reg, in1, 0, 0, 0 };\r\nu32 out[TCI_WORDS];\r\nacpi_status status = tci_raw(dev, in, out);\r\nreturn ACPI_SUCCESS(status) ? out[0] : TOS_FAILURE;\r\n}\r\nstatic void toshiba_illumination_available(struct toshiba_acpi_dev *dev)\r\n{\r\nu32 in[TCI_WORDS] = { SCI_GET, SCI_ILLUMINATION, 0, 0, 0, 0 };\r\nu32 out[TCI_WORDS];\r\nacpi_status status;\r\ndev->illumination_supported = 0;\r\ndev->illumination_led_registered = false;\r\nif (!sci_open(dev))\r\nreturn;\r\nstatus = tci_raw(dev, in, out);\r\nsci_close(dev);\r\nif (ACPI_FAILURE(status)) {\r\npr_err("ACPI call to query Illumination support failed\n");\r\nreturn;\r\n}\r\nif (out[0] != TOS_SUCCESS)\r\nreturn;\r\ndev->illumination_supported = 1;\r\n}\r\nstatic void toshiba_illumination_set(struct led_classdev *cdev,\r\nenum led_brightness brightness)\r\n{\r\nstruct toshiba_acpi_dev *dev = container_of(cdev,\r\nstruct toshiba_acpi_dev, led_dev);\r\nu32 result;\r\nu32 state;\r\nif (!sci_open(dev))\r\nreturn;\r\nstate = brightness ? 1 : 0;\r\nresult = sci_write(dev, SCI_ILLUMINATION, state);\r\nsci_close(dev);\r\nif (result == TOS_FAILURE)\r\npr_err("ACPI call for illumination failed\n");\r\n}\r\nstatic enum led_brightness toshiba_illumination_get(struct led_classdev *cdev)\r\n{\r\nstruct toshiba_acpi_dev *dev = container_of(cdev,\r\nstruct toshiba_acpi_dev, led_dev);\r\nu32 result;\r\nu32 state;\r\nif (!sci_open(dev))\r\nreturn LED_OFF;\r\nresult = sci_read(dev, SCI_ILLUMINATION, &state);\r\nsci_close(dev);\r\nif (result == TOS_FAILURE) {\r\npr_err("ACPI call for illumination failed\n");\r\nreturn LED_OFF;\r\n} else if (result != TOS_SUCCESS) {\r\nreturn LED_OFF;\r\n}\r\nreturn state ? LED_FULL : LED_OFF;\r\n}\r\nstatic void toshiba_kbd_illum_available(struct toshiba_acpi_dev *dev)\r\n{\r\nu32 in[TCI_WORDS] = { SCI_GET, SCI_KBD_ILLUM_STATUS, 0, 0, 0, 0 };\r\nu32 out[TCI_WORDS];\r\nacpi_status status;\r\ndev->kbd_illum_supported = 0;\r\ndev->kbd_led_registered = false;\r\ndev->kbd_event_generated = false;\r\nif (!sci_open(dev))\r\nreturn;\r\nstatus = tci_raw(dev, in, out);\r\nsci_close(dev);\r\nif (ACPI_FAILURE(status)) {\r\npr_err("ACPI call to query kbd illumination support failed\n");\r\nreturn;\r\n}\r\nif (out[0] != TOS_SUCCESS)\r\nreturn;\r\nif (out[3] == SCI_KBD_TIME_MAX)\r\ndev->kbd_type = 2;\r\nelse\r\ndev->kbd_type = 1;\r\ndev->kbd_mode = out[2] & SCI_KBD_MODE_MASK;\r\ndev->kbd_time = out[2] >> HCI_MISC_SHIFT;\r\ndev->kbd_illum_supported = 1;\r\n}\r\nstatic int toshiba_kbd_illum_status_set(struct toshiba_acpi_dev *dev, u32 time)\r\n{\r\nu32 result;\r\nif (!sci_open(dev))\r\nreturn -EIO;\r\nresult = sci_write(dev, SCI_KBD_ILLUM_STATUS, time);\r\nsci_close(dev);\r\nif (result == TOS_FAILURE)\r\npr_err("ACPI call to set KBD backlight status failed\n");\r\nelse if (result == TOS_NOT_SUPPORTED)\r\nreturn -ENODEV;\r\nreturn result == TOS_SUCCESS ? 0 : -EIO;\r\n}\r\nstatic int toshiba_kbd_illum_status_get(struct toshiba_acpi_dev *dev, u32 *time)\r\n{\r\nu32 result;\r\nif (!sci_open(dev))\r\nreturn -EIO;\r\nresult = sci_read(dev, SCI_KBD_ILLUM_STATUS, time);\r\nsci_close(dev);\r\nif (result == TOS_FAILURE)\r\npr_err("ACPI call to get KBD backlight status failed\n");\r\nelse if (result == TOS_NOT_SUPPORTED)\r\nreturn -ENODEV;\r\nreturn result == TOS_SUCCESS ? 0 : -EIO;\r\n}\r\nstatic enum led_brightness toshiba_kbd_backlight_get(struct led_classdev *cdev)\r\n{\r\nstruct toshiba_acpi_dev *dev = container_of(cdev,\r\nstruct toshiba_acpi_dev, kbd_led);\r\nu32 result;\r\nu32 state;\r\nresult = hci_read(dev, HCI_KBD_ILLUMINATION, &state);\r\nif (result == TOS_FAILURE) {\r\npr_err("ACPI call to get the keyboard backlight failed\n");\r\nreturn LED_OFF;\r\n} else if (result != TOS_SUCCESS) {\r\nreturn LED_OFF;\r\n}\r\nreturn state ? LED_FULL : LED_OFF;\r\n}\r\nstatic void toshiba_kbd_backlight_set(struct led_classdev *cdev,\r\nenum led_brightness brightness)\r\n{\r\nstruct toshiba_acpi_dev *dev = container_of(cdev,\r\nstruct toshiba_acpi_dev, kbd_led);\r\nu32 result;\r\nu32 state;\r\nstate = brightness ? 1 : 0;\r\nresult = hci_write(dev, HCI_KBD_ILLUMINATION, state);\r\nif (result == TOS_FAILURE)\r\npr_err("ACPI call to set KBD Illumination mode failed\n");\r\n}\r\nstatic int toshiba_touchpad_set(struct toshiba_acpi_dev *dev, u32 state)\r\n{\r\nu32 result;\r\nif (!sci_open(dev))\r\nreturn -EIO;\r\nresult = sci_write(dev, SCI_TOUCHPAD, state);\r\nsci_close(dev);\r\nif (result == TOS_FAILURE)\r\npr_err("ACPI call to set the touchpad failed\n");\r\nelse if (result == TOS_NOT_SUPPORTED)\r\nreturn -ENODEV;\r\nreturn result == TOS_SUCCESS ? 0 : -EIO;\r\n}\r\nstatic int toshiba_touchpad_get(struct toshiba_acpi_dev *dev, u32 *state)\r\n{\r\nu32 result;\r\nif (!sci_open(dev))\r\nreturn -EIO;\r\nresult = sci_read(dev, SCI_TOUCHPAD, state);\r\nsci_close(dev);\r\nif (result == TOS_FAILURE)\r\npr_err("ACPI call to query the touchpad failed\n");\r\nelse if (result == TOS_NOT_SUPPORTED)\r\nreturn -ENODEV;\r\nreturn result == TOS_SUCCESS ? 0 : -EIO;\r\n}\r\nstatic void toshiba_eco_mode_available(struct toshiba_acpi_dev *dev)\r\n{\r\nu32 in[TCI_WORDS] = { HCI_GET, HCI_ECO_MODE, 0, 0, 0, 0 };\r\nu32 out[TCI_WORDS];\r\nacpi_status status;\r\ndev->eco_supported = 0;\r\ndev->eco_led_registered = false;\r\nstatus = tci_raw(dev, in, out);\r\nif (ACPI_FAILURE(status)) {\r\npr_err("ACPI call to get ECO led failed\n");\r\nreturn;\r\n}\r\nif (out[0] == TOS_INPUT_DATA_ERROR) {\r\nin[3] = 1;\r\nstatus = tci_raw(dev, in, out);\r\nif (ACPI_FAILURE(status)) {\r\npr_err("ACPI call to get ECO led failed\n");\r\nreturn;\r\n}\r\nif (out[0] != TOS_SUCCESS)\r\nreturn;\r\ndev->eco_supported = 1;\r\n}\r\n}\r\nstatic enum led_brightness\r\ntoshiba_eco_mode_get_status(struct led_classdev *cdev)\r\n{\r\nstruct toshiba_acpi_dev *dev = container_of(cdev,\r\nstruct toshiba_acpi_dev, eco_led);\r\nu32 in[TCI_WORDS] = { HCI_GET, HCI_ECO_MODE, 0, 1, 0, 0 };\r\nu32 out[TCI_WORDS];\r\nacpi_status status;\r\nstatus = tci_raw(dev, in, out);\r\nif (ACPI_FAILURE(status)) {\r\npr_err("ACPI call to get ECO led failed\n");\r\nreturn LED_OFF;\r\n}\r\nif (out[0] != TOS_SUCCESS)\r\nreturn LED_OFF;\r\nreturn out[2] ? LED_FULL : LED_OFF;\r\n}\r\nstatic void toshiba_eco_mode_set_status(struct led_classdev *cdev,\r\nenum led_brightness brightness)\r\n{\r\nstruct toshiba_acpi_dev *dev = container_of(cdev,\r\nstruct toshiba_acpi_dev, eco_led);\r\nu32 in[TCI_WORDS] = { HCI_SET, HCI_ECO_MODE, 0, 1, 0, 0 };\r\nu32 out[TCI_WORDS];\r\nacpi_status status;\r\nin[2] = (brightness) ? 1 : 0;\r\nstatus = tci_raw(dev, in, out);\r\nif (ACPI_FAILURE(status))\r\npr_err("ACPI call to set ECO led failed\n");\r\n}\r\nstatic void toshiba_accelerometer_available(struct toshiba_acpi_dev *dev)\r\n{\r\nu32 in[TCI_WORDS] = { HCI_GET, HCI_ACCELEROMETER2, 0, 0, 0, 0 };\r\nu32 out[TCI_WORDS];\r\nacpi_status status;\r\ndev->accelerometer_supported = 0;\r\nstatus = tci_raw(dev, in, out);\r\nif (ACPI_FAILURE(status)) {\r\npr_err("ACPI call to query the accelerometer failed\n");\r\nreturn;\r\n}\r\nif (out[0] != TOS_SUCCESS)\r\nreturn;\r\ndev->accelerometer_supported = 1;\r\n}\r\nstatic int toshiba_accelerometer_get(struct toshiba_acpi_dev *dev,\r\nu32 *xy, u32 *z)\r\n{\r\nu32 in[TCI_WORDS] = { HCI_GET, HCI_ACCELEROMETER, 0, 1, 0, 0 };\r\nu32 out[TCI_WORDS];\r\nacpi_status status;\r\nstatus = tci_raw(dev, in, out);\r\nif (ACPI_FAILURE(status)) {\r\npr_err("ACPI call to query the accelerometer failed\n");\r\nreturn -EIO;\r\n}\r\nif (out[0] == TOS_NOT_SUPPORTED)\r\nreturn -ENODEV;\r\nif (out[0] != TOS_SUCCESS)\r\nreturn -EIO;\r\n*xy = out[2];\r\n*z = out[4];\r\nreturn 0;\r\n}\r\nstatic void toshiba_usb_sleep_charge_available(struct toshiba_acpi_dev *dev)\r\n{\r\nu32 in[TCI_WORDS] = { SCI_GET, SCI_USB_SLEEP_CHARGE, 0, 0, 0, 0 };\r\nu32 out[TCI_WORDS];\r\nacpi_status status;\r\ndev->usb_sleep_charge_supported = 0;\r\nif (!sci_open(dev))\r\nreturn;\r\nstatus = tci_raw(dev, in, out);\r\nif (ACPI_FAILURE(status)) {\r\npr_err("ACPI call to get USB Sleep and Charge mode failed\n");\r\nsci_close(dev);\r\nreturn;\r\n}\r\nif (out[0] != TOS_SUCCESS) {\r\nsci_close(dev);\r\nreturn;\r\n}\r\ndev->usbsc_mode_base = out[4];\r\nin[5] = SCI_USB_CHARGE_BAT_LVL;\r\nstatus = tci_raw(dev, in, out);\r\nsci_close(dev);\r\nif (ACPI_FAILURE(status)) {\r\npr_err("ACPI call to get USB Sleep and Charge mode failed\n");\r\nreturn;\r\n}\r\nif (out[0] != TOS_SUCCESS)\r\nreturn;\r\ndev->usbsc_bat_level = out[2];\r\ndev->usb_sleep_charge_supported = 1;\r\n}\r\nstatic int toshiba_usb_sleep_charge_get(struct toshiba_acpi_dev *dev,\r\nu32 *mode)\r\n{\r\nu32 result;\r\nif (!sci_open(dev))\r\nreturn -EIO;\r\nresult = sci_read(dev, SCI_USB_SLEEP_CHARGE, mode);\r\nsci_close(dev);\r\nif (result == TOS_FAILURE)\r\npr_err("ACPI call to set USB S&C mode failed\n");\r\nelse if (result == TOS_NOT_SUPPORTED)\r\nreturn -ENODEV;\r\nreturn result == TOS_SUCCESS ? 0 : -EIO;\r\n}\r\nstatic int toshiba_usb_sleep_charge_set(struct toshiba_acpi_dev *dev,\r\nu32 mode)\r\n{\r\nu32 result;\r\nif (!sci_open(dev))\r\nreturn -EIO;\r\nresult = sci_write(dev, SCI_USB_SLEEP_CHARGE, mode);\r\nsci_close(dev);\r\nif (result == TOS_FAILURE)\r\npr_err("ACPI call to set USB S&C mode failed\n");\r\nelse if (result == TOS_NOT_SUPPORTED)\r\nreturn -ENODEV;\r\nreturn result == TOS_SUCCESS ? 0 : -EIO;\r\n}\r\nstatic int toshiba_sleep_functions_status_get(struct toshiba_acpi_dev *dev,\r\nu32 *mode)\r\n{\r\nu32 in[TCI_WORDS] = { SCI_GET, SCI_USB_SLEEP_CHARGE, 0, 0, 0, 0 };\r\nu32 out[TCI_WORDS];\r\nacpi_status status;\r\nif (!sci_open(dev))\r\nreturn -EIO;\r\nin[5] = SCI_USB_CHARGE_BAT_LVL;\r\nstatus = tci_raw(dev, in, out);\r\nsci_close(dev);\r\nif (ACPI_FAILURE(status)) {\r\npr_err("ACPI call to get USB S&C battery level failed\n");\r\nreturn -EIO;\r\n}\r\nif (out[0] == TOS_NOT_SUPPORTED)\r\nreturn -ENODEV;\r\nif (out[0] != TOS_SUCCESS)\r\nreturn -EIO;\r\n*mode = out[2];\r\nreturn 0;\r\n}\r\nstatic int toshiba_sleep_functions_status_set(struct toshiba_acpi_dev *dev,\r\nu32 mode)\r\n{\r\nu32 in[TCI_WORDS] = { SCI_SET, SCI_USB_SLEEP_CHARGE, 0, 0, 0, 0 };\r\nu32 out[TCI_WORDS];\r\nacpi_status status;\r\nif (!sci_open(dev))\r\nreturn -EIO;\r\nin[2] = mode;\r\nin[5] = SCI_USB_CHARGE_BAT_LVL;\r\nstatus = tci_raw(dev, in, out);\r\nsci_close(dev);\r\nif (ACPI_FAILURE(status)) {\r\npr_err("ACPI call to set USB S&C battery level failed\n");\r\nreturn -EIO;\r\n}\r\nif (out[0] == TOS_NOT_SUPPORTED)\r\nreturn -ENODEV;\r\nreturn out[0] == TOS_SUCCESS ? 0 : -EIO;\r\n}\r\nstatic int toshiba_usb_rapid_charge_get(struct toshiba_acpi_dev *dev,\r\nu32 *state)\r\n{\r\nu32 in[TCI_WORDS] = { SCI_GET, SCI_USB_SLEEP_CHARGE, 0, 0, 0, 0 };\r\nu32 out[TCI_WORDS];\r\nacpi_status status;\r\nif (!sci_open(dev))\r\nreturn -EIO;\r\nin[5] = SCI_USB_CHARGE_RAPID_DSP;\r\nstatus = tci_raw(dev, in, out);\r\nsci_close(dev);\r\nif (ACPI_FAILURE(status)) {\r\npr_err("ACPI call to get USB Rapid Charge failed\n");\r\nreturn -EIO;\r\n}\r\nif (out[0] == TOS_NOT_SUPPORTED)\r\nreturn -ENODEV;\r\nif (out[0] != TOS_SUCCESS && out[0] != TOS_SUCCESS2)\r\nreturn -EIO;\r\n*state = out[2];\r\nreturn 0;\r\n}\r\nstatic int toshiba_usb_rapid_charge_set(struct toshiba_acpi_dev *dev,\r\nu32 state)\r\n{\r\nu32 in[TCI_WORDS] = { SCI_SET, SCI_USB_SLEEP_CHARGE, 0, 0, 0, 0 };\r\nu32 out[TCI_WORDS];\r\nacpi_status status;\r\nif (!sci_open(dev))\r\nreturn -EIO;\r\nin[2] = state;\r\nin[5] = SCI_USB_CHARGE_RAPID_DSP;\r\nstatus = tci_raw(dev, in, out);\r\nsci_close(dev);\r\nif (ACPI_FAILURE(status)) {\r\npr_err("ACPI call to set USB Rapid Charge failed\n");\r\nreturn -EIO;\r\n}\r\nif (out[0] == TOS_NOT_SUPPORTED)\r\nreturn -ENODEV;\r\nreturn (out[0] == TOS_SUCCESS || out[0] == TOS_SUCCESS2) ? 0 : -EIO;\r\n}\r\nstatic int toshiba_usb_sleep_music_get(struct toshiba_acpi_dev *dev, u32 *state)\r\n{\r\nu32 result;\r\nif (!sci_open(dev))\r\nreturn -EIO;\r\nresult = sci_read(dev, SCI_USB_SLEEP_MUSIC, state);\r\nsci_close(dev);\r\nif (result == TOS_FAILURE)\r\npr_err("ACPI call to get Sleep and Music failed\n");\r\nelse if (result == TOS_NOT_SUPPORTED)\r\nreturn -ENODEV;\r\nreturn result == TOS_SUCCESS ? 0 : -EIO;\r\n}\r\nstatic int toshiba_usb_sleep_music_set(struct toshiba_acpi_dev *dev, u32 state)\r\n{\r\nu32 result;\r\nif (!sci_open(dev))\r\nreturn -EIO;\r\nresult = sci_write(dev, SCI_USB_SLEEP_MUSIC, state);\r\nsci_close(dev);\r\nif (result == TOS_FAILURE)\r\npr_err("ACPI call to set Sleep and Music failed\n");\r\nelse if (result == TOS_NOT_SUPPORTED)\r\nreturn -ENODEV;\r\nreturn result == TOS_SUCCESS ? 0 : -EIO;\r\n}\r\nstatic int toshiba_function_keys_get(struct toshiba_acpi_dev *dev, u32 *mode)\r\n{\r\nu32 result;\r\nif (!sci_open(dev))\r\nreturn -EIO;\r\nresult = sci_read(dev, SCI_KBD_FUNCTION_KEYS, mode);\r\nsci_close(dev);\r\nif (result == TOS_FAILURE)\r\npr_err("ACPI call to get KBD function keys failed\n");\r\nelse if (result == TOS_NOT_SUPPORTED)\r\nreturn -ENODEV;\r\nreturn (result == TOS_SUCCESS || result == TOS_SUCCESS2) ? 0 : -EIO;\r\n}\r\nstatic int toshiba_function_keys_set(struct toshiba_acpi_dev *dev, u32 mode)\r\n{\r\nu32 result;\r\nif (!sci_open(dev))\r\nreturn -EIO;\r\nresult = sci_write(dev, SCI_KBD_FUNCTION_KEYS, mode);\r\nsci_close(dev);\r\nif (result == TOS_FAILURE)\r\npr_err("ACPI call to set KBD function keys failed\n");\r\nelse if (result == TOS_NOT_SUPPORTED)\r\nreturn -ENODEV;\r\nreturn (result == TOS_SUCCESS || result == TOS_SUCCESS2) ? 0 : -EIO;\r\n}\r\nstatic int toshiba_panel_power_on_get(struct toshiba_acpi_dev *dev, u32 *state)\r\n{\r\nu32 result;\r\nif (!sci_open(dev))\r\nreturn -EIO;\r\nresult = sci_read(dev, SCI_PANEL_POWER_ON, state);\r\nsci_close(dev);\r\nif (result == TOS_FAILURE)\r\npr_err("ACPI call to get Panel Power ON failed\n");\r\nelse if (result == TOS_NOT_SUPPORTED)\r\nreturn -ENODEV;\r\nreturn result == TOS_SUCCESS ? 0 : -EIO;\r\n}\r\nstatic int toshiba_panel_power_on_set(struct toshiba_acpi_dev *dev, u32 state)\r\n{\r\nu32 result;\r\nif (!sci_open(dev))\r\nreturn -EIO;\r\nresult = sci_write(dev, SCI_PANEL_POWER_ON, state);\r\nsci_close(dev);\r\nif (result == TOS_FAILURE)\r\npr_err("ACPI call to set Panel Power ON failed\n");\r\nelse if (result == TOS_NOT_SUPPORTED)\r\nreturn -ENODEV;\r\nreturn result == TOS_SUCCESS ? 0 : -EIO;\r\n}\r\nstatic int toshiba_usb_three_get(struct toshiba_acpi_dev *dev, u32 *state)\r\n{\r\nu32 result;\r\nif (!sci_open(dev))\r\nreturn -EIO;\r\nresult = sci_read(dev, SCI_USB_THREE, state);\r\nsci_close(dev);\r\nif (result == TOS_FAILURE)\r\npr_err("ACPI call to get USB 3 failed\n");\r\nelse if (result == TOS_NOT_SUPPORTED)\r\nreturn -ENODEV;\r\nreturn (result == TOS_SUCCESS || result == TOS_SUCCESS2) ? 0 : -EIO;\r\n}\r\nstatic int toshiba_usb_three_set(struct toshiba_acpi_dev *dev, u32 state)\r\n{\r\nu32 result;\r\nif (!sci_open(dev))\r\nreturn -EIO;\r\nresult = sci_write(dev, SCI_USB_THREE, state);\r\nsci_close(dev);\r\nif (result == TOS_FAILURE)\r\npr_err("ACPI call to set USB 3 failed\n");\r\nelse if (result == TOS_NOT_SUPPORTED)\r\nreturn -ENODEV;\r\nreturn (result == TOS_SUCCESS || result == TOS_SUCCESS2) ? 0 : -EIO;\r\n}\r\nstatic int toshiba_hotkey_event_type_get(struct toshiba_acpi_dev *dev,\r\nu32 *type)\r\n{\r\nu32 in[TCI_WORDS] = { HCI_GET, HCI_SYSTEM_INFO, 0x03, 0, 0, 0 };\r\nu32 out[TCI_WORDS];\r\nacpi_status status;\r\nstatus = tci_raw(dev, in, out);\r\nif (ACPI_FAILURE(status)) {\r\npr_err("ACPI call to get System type failed\n");\r\nreturn -EIO;\r\n}\r\nif (out[0] == TOS_NOT_SUPPORTED)\r\nreturn -ENODEV;\r\nif (out[0] != TOS_SUCCESS)\r\nreturn -EIO;\r\n*type = out[3];\r\nreturn 0;\r\n}\r\nstatic int toshiba_wireless_status(struct toshiba_acpi_dev *dev)\r\n{\r\nu32 in[TCI_WORDS] = { HCI_GET, HCI_WIRELESS, 0, 0, 0, 0 };\r\nu32 out[TCI_WORDS];\r\nacpi_status status;\r\nin[3] = HCI_WIRELESS_STATUS;\r\nstatus = tci_raw(dev, in, out);\r\nif (ACPI_FAILURE(status)) {\r\npr_err("ACPI call to get Wireless status failed\n");\r\nreturn -EIO;\r\n}\r\nif (out[0] == TOS_NOT_SUPPORTED)\r\nreturn -ENODEV;\r\nif (out[0] != TOS_SUCCESS)\r\nreturn -EIO;\r\ndev->killswitch = !!(out[2] & HCI_WIRELESS_STATUS);\r\nreturn 0;\r\n}\r\nstatic void toshiba_wwan_available(struct toshiba_acpi_dev *dev)\r\n{\r\nu32 in[TCI_WORDS] = { HCI_GET, HCI_WIRELESS, 0, 0, 0, 0 };\r\nu32 out[TCI_WORDS];\r\nacpi_status status;\r\ndev->wwan_supported = 0;\r\nin[3] = HCI_WIRELESS_WWAN;\r\nstatus = tci_raw(dev, in, out);\r\nif (ACPI_FAILURE(status)) {\r\npr_err("ACPI call to get WWAN status failed\n");\r\nreturn;\r\n}\r\nif (out[0] != TOS_SUCCESS)\r\nreturn;\r\ndev->wwan_supported = (out[2] == HCI_WIRELESS_WWAN_STATUS);\r\n}\r\nstatic int toshiba_wwan_set(struct toshiba_acpi_dev *dev, u32 state)\r\n{\r\nu32 in[TCI_WORDS] = { HCI_SET, HCI_WIRELESS, state, 0, 0, 0 };\r\nu32 out[TCI_WORDS];\r\nacpi_status status;\r\nin[3] = HCI_WIRELESS_WWAN_STATUS;\r\nstatus = tci_raw(dev, in, out);\r\nif (ACPI_FAILURE(status)) {\r\npr_err("ACPI call to set WWAN status failed\n");\r\nreturn -EIO;\r\n}\r\nif (out[0] == TOS_NOT_SUPPORTED)\r\nreturn -ENODEV;\r\nif (out[0] != TOS_SUCCESS)\r\nreturn -EIO;\r\nin[3] = HCI_WIRELESS_WWAN_POWER;\r\nstatus = tci_raw(dev, in, out);\r\nif (ACPI_FAILURE(status)) {\r\npr_err("ACPI call to set WWAN power failed\n");\r\nreturn -EIO;\r\n}\r\nif (out[0] == TOS_NOT_SUPPORTED)\r\nreturn -ENODEV;\r\nreturn out[0] == TOS_SUCCESS ? 0 : -EIO;\r\n}\r\nstatic void toshiba_cooling_method_available(struct toshiba_acpi_dev *dev)\r\n{\r\nu32 in[TCI_WORDS] = { HCI_GET, HCI_COOLING_METHOD, 0, 0, 0, 0 };\r\nu32 out[TCI_WORDS];\r\nacpi_status status;\r\ndev->cooling_method_supported = 0;\r\ndev->max_cooling_method = 0;\r\nstatus = tci_raw(dev, in, out);\r\nif (ACPI_FAILURE(status)) {\r\npr_err("ACPI call to get Cooling Method failed\n");\r\nreturn;\r\n}\r\nif (out[0] != TOS_SUCCESS && out[0] != TOS_SUCCESS2)\r\nreturn;\r\ndev->cooling_method_supported = 1;\r\ndev->max_cooling_method = out[3];\r\n}\r\nstatic int toshiba_cooling_method_get(struct toshiba_acpi_dev *dev, u32 *state)\r\n{\r\nu32 result = hci_read(dev, HCI_COOLING_METHOD, state);\r\nif (result == TOS_FAILURE)\r\npr_err("ACPI call to get Cooling Method failed\n");\r\nif (result == TOS_NOT_SUPPORTED)\r\nreturn -ENODEV;\r\nreturn (result == TOS_SUCCESS || result == TOS_SUCCESS2) ? 0 : -EIO;\r\n}\r\nstatic int toshiba_cooling_method_set(struct toshiba_acpi_dev *dev, u32 state)\r\n{\r\nu32 result = hci_write(dev, HCI_COOLING_METHOD, state);\r\nif (result == TOS_FAILURE)\r\npr_err("ACPI call to set Cooling Method failed\n");\r\nif (result == TOS_NOT_SUPPORTED)\r\nreturn -ENODEV;\r\nreturn (result == TOS_SUCCESS || result == TOS_SUCCESS2) ? 0 : -EIO;\r\n}\r\nstatic int get_tr_backlight_status(struct toshiba_acpi_dev *dev, u32 *status)\r\n{\r\nu32 result = hci_read(dev, HCI_TR_BACKLIGHT, status);\r\nif (result == TOS_FAILURE)\r\npr_err("ACPI call to get Transflective Backlight failed\n");\r\nelse if (result == TOS_NOT_SUPPORTED)\r\nreturn -ENODEV;\r\nreturn result == TOS_SUCCESS ? 0 : -EIO;\r\n}\r\nstatic int set_tr_backlight_status(struct toshiba_acpi_dev *dev, u32 status)\r\n{\r\nu32 result = hci_write(dev, HCI_TR_BACKLIGHT, !status);\r\nif (result == TOS_FAILURE)\r\npr_err("ACPI call to set Transflective Backlight failed\n");\r\nelse if (result == TOS_NOT_SUPPORTED)\r\nreturn -ENODEV;\r\nreturn result == TOS_SUCCESS ? 0 : -EIO;\r\n}\r\nstatic int __get_lcd_brightness(struct toshiba_acpi_dev *dev)\r\n{\r\nint brightness = 0;\r\nu32 result;\r\nu32 value;\r\nif (dev->tr_backlight_supported) {\r\nint ret = get_tr_backlight_status(dev, &value);\r\nif (ret)\r\nreturn ret;\r\nif (value)\r\nreturn 0;\r\nbrightness++;\r\n}\r\nresult = hci_read(dev, HCI_LCD_BRIGHTNESS, &value);\r\nif (result == TOS_FAILURE)\r\npr_err("ACPI call to get LCD Brightness failed\n");\r\nelse if (result == TOS_NOT_SUPPORTED)\r\nreturn -ENODEV;\r\nreturn result == TOS_SUCCESS ?\r\nbrightness + (value >> HCI_LCD_BRIGHTNESS_SHIFT) :\r\n-EIO;\r\n}\r\nstatic int get_lcd_brightness(struct backlight_device *bd)\r\n{\r\nstruct toshiba_acpi_dev *dev = bl_get_data(bd);\r\nreturn __get_lcd_brightness(dev);\r\n}\r\nstatic int lcd_proc_show(struct seq_file *m, void *v)\r\n{\r\nstruct toshiba_acpi_dev *dev = m->private;\r\nint levels;\r\nint value;\r\nif (!dev->backlight_dev)\r\nreturn -ENODEV;\r\nlevels = dev->backlight_dev->props.max_brightness + 1;\r\nvalue = get_lcd_brightness(dev->backlight_dev);\r\nif (value < 0) {\r\npr_err("Error reading LCD brightness\n");\r\nreturn value;\r\n}\r\nseq_printf(m, "brightness: %d\n", value);\r\nseq_printf(m, "brightness_levels: %d\n", levels);\r\nreturn 0;\r\n}\r\nstatic int lcd_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, lcd_proc_show, PDE_DATA(inode));\r\n}\r\nstatic int set_lcd_brightness(struct toshiba_acpi_dev *dev, int value)\r\n{\r\nu32 result;\r\nif (dev->tr_backlight_supported) {\r\nint ret = set_tr_backlight_status(dev, !value);\r\nif (ret)\r\nreturn ret;\r\nif (value)\r\nvalue--;\r\n}\r\nvalue = value << HCI_LCD_BRIGHTNESS_SHIFT;\r\nresult = hci_write(dev, HCI_LCD_BRIGHTNESS, value);\r\nif (result == TOS_FAILURE)\r\npr_err("ACPI call to set LCD Brightness failed\n");\r\nelse if (result == TOS_NOT_SUPPORTED)\r\nreturn -ENODEV;\r\nreturn result == TOS_SUCCESS ? 0 : -EIO;\r\n}\r\nstatic int set_lcd_status(struct backlight_device *bd)\r\n{\r\nstruct toshiba_acpi_dev *dev = bl_get_data(bd);\r\nreturn set_lcd_brightness(dev, bd->props.brightness);\r\n}\r\nstatic ssize_t lcd_proc_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *pos)\r\n{\r\nstruct toshiba_acpi_dev *dev = PDE_DATA(file_inode(file));\r\nchar cmd[42];\r\nsize_t len;\r\nint levels;\r\nint value;\r\nlen = min(count, sizeof(cmd) - 1);\r\nif (copy_from_user(cmd, buf, len))\r\nreturn -EFAULT;\r\ncmd[len] = '\0';\r\nlevels = dev->backlight_dev->props.max_brightness + 1;\r\nif (sscanf(cmd, " brightness : %i", &value) != 1 &&\r\nvalue < 0 && value > levels)\r\nreturn -EINVAL;\r\nif (set_lcd_brightness(dev, value))\r\nreturn -EIO;\r\nreturn count;\r\n}\r\nstatic int get_video_status(struct toshiba_acpi_dev *dev, u32 *status)\r\n{\r\nu32 result = hci_read(dev, HCI_VIDEO_OUT, status);\r\nif (result == TOS_FAILURE)\r\npr_err("ACPI call to get Video-Out failed\n");\r\nelse if (result == TOS_NOT_SUPPORTED)\r\nreturn -ENODEV;\r\nreturn result == TOS_SUCCESS ? 0 : -EIO;\r\n}\r\nstatic int video_proc_show(struct seq_file *m, void *v)\r\n{\r\nstruct toshiba_acpi_dev *dev = m->private;\r\nint is_lcd, is_crt, is_tv;\r\nu32 value;\r\nif (get_video_status(dev, &value))\r\nreturn -EIO;\r\nis_lcd = (value & HCI_VIDEO_OUT_LCD) ? 1 : 0;\r\nis_crt = (value & HCI_VIDEO_OUT_CRT) ? 1 : 0;\r\nis_tv = (value & HCI_VIDEO_OUT_TV) ? 1 : 0;\r\nseq_printf(m, "lcd_out: %d\n", is_lcd);\r\nseq_printf(m, "crt_out: %d\n", is_crt);\r\nseq_printf(m, "tv_out: %d\n", is_tv);\r\nreturn 0;\r\n}\r\nstatic int video_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, video_proc_show, PDE_DATA(inode));\r\n}\r\nstatic ssize_t video_proc_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *pos)\r\n{\r\nstruct toshiba_acpi_dev *dev = PDE_DATA(file_inode(file));\r\nchar *buffer;\r\nchar *cmd;\r\nint lcd_out, crt_out, tv_out;\r\nint remain = count;\r\nint value;\r\nint ret;\r\nu32 video_out;\r\ncmd = memdup_user_nul(buf, count);\r\nif (IS_ERR(cmd))\r\nreturn PTR_ERR(cmd);\r\nbuffer = cmd;\r\nwhile (remain) {\r\nif (sscanf(buffer, " lcd_out : %i", &value) == 1)\r\nlcd_out = value & 1;\r\nelse if (sscanf(buffer, " crt_out : %i", &value) == 1)\r\ncrt_out = value & 1;\r\nelse if (sscanf(buffer, " tv_out : %i", &value) == 1)\r\ntv_out = value & 1;\r\ndo {\r\n++buffer;\r\n--remain;\r\n} while (remain && *(buffer - 1) != ';');\r\n}\r\nkfree(cmd);\r\nlcd_out = crt_out = tv_out = -1;\r\nret = get_video_status(dev, &video_out);\r\nif (!ret) {\r\nunsigned int new_video_out = video_out;\r\nif (lcd_out != -1)\r\n_set_bit(&new_video_out, HCI_VIDEO_OUT_LCD, lcd_out);\r\nif (crt_out != -1)\r\n_set_bit(&new_video_out, HCI_VIDEO_OUT_CRT, crt_out);\r\nif (tv_out != -1)\r\n_set_bit(&new_video_out, HCI_VIDEO_OUT_TV, tv_out);\r\nif (new_video_out != video_out)\r\nret = write_acpi_int(METHOD_VIDEO_OUT, new_video_out);\r\n}\r\nreturn ret ? -EIO : count;\r\n}\r\nstatic int get_fan_status(struct toshiba_acpi_dev *dev, u32 *status)\r\n{\r\nu32 result = hci_read(dev, HCI_FAN, status);\r\nif (result == TOS_FAILURE)\r\npr_err("ACPI call to get Fan status failed\n");\r\nelse if (result == TOS_NOT_SUPPORTED)\r\nreturn -ENODEV;\r\nreturn result == TOS_SUCCESS ? 0 : -EIO;\r\n}\r\nstatic int set_fan_status(struct toshiba_acpi_dev *dev, u32 status)\r\n{\r\nu32 result = hci_write(dev, HCI_FAN, status);\r\nif (result == TOS_FAILURE)\r\npr_err("ACPI call to set Fan status failed\n");\r\nelse if (result == TOS_NOT_SUPPORTED)\r\nreturn -ENODEV;\r\nreturn result == TOS_SUCCESS ? 0 : -EIO;\r\n}\r\nstatic int fan_proc_show(struct seq_file *m, void *v)\r\n{\r\nstruct toshiba_acpi_dev *dev = m->private;\r\nu32 value;\r\nif (get_fan_status(dev, &value))\r\nreturn -EIO;\r\nseq_printf(m, "running: %d\n", (value > 0));\r\nseq_printf(m, "force_on: %d\n", dev->force_fan);\r\nreturn 0;\r\n}\r\nstatic int fan_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, fan_proc_show, PDE_DATA(inode));\r\n}\r\nstatic ssize_t fan_proc_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *pos)\r\n{\r\nstruct toshiba_acpi_dev *dev = PDE_DATA(file_inode(file));\r\nchar cmd[42];\r\nsize_t len;\r\nint value;\r\nlen = min(count, sizeof(cmd) - 1);\r\nif (copy_from_user(cmd, buf, len))\r\nreturn -EFAULT;\r\ncmd[len] = '\0';\r\nif (sscanf(cmd, " force_on : %i", &value) != 1 &&\r\nvalue != 0 && value != 1)\r\nreturn -EINVAL;\r\nif (set_fan_status(dev, value))\r\nreturn -EIO;\r\ndev->force_fan = value;\r\nreturn count;\r\n}\r\nstatic int keys_proc_show(struct seq_file *m, void *v)\r\n{\r\nstruct toshiba_acpi_dev *dev = m->private;\r\nseq_printf(m, "hotkey_ready: %d\n", dev->key_event_valid);\r\nseq_printf(m, "hotkey: 0x%04x\n", dev->last_key_event);\r\nreturn 0;\r\n}\r\nstatic int keys_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, keys_proc_show, PDE_DATA(inode));\r\n}\r\nstatic ssize_t keys_proc_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *pos)\r\n{\r\nstruct toshiba_acpi_dev *dev = PDE_DATA(file_inode(file));\r\nchar cmd[42];\r\nsize_t len;\r\nint value;\r\nlen = min(count, sizeof(cmd) - 1);\r\nif (copy_from_user(cmd, buf, len))\r\nreturn -EFAULT;\r\ncmd[len] = '\0';\r\nif (sscanf(cmd, " hotkey_ready : %i", &value) == 1 && value == 0)\r\ndev->key_event_valid = 0;\r\nelse\r\nreturn -EINVAL;\r\nreturn count;\r\n}\r\nstatic int version_proc_show(struct seq_file *m, void *v)\r\n{\r\nseq_printf(m, "driver: %s\n", TOSHIBA_ACPI_VERSION);\r\nseq_printf(m, "proc_interface: %d\n", PROC_INTERFACE_VERSION);\r\nreturn 0;\r\n}\r\nstatic int version_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, version_proc_show, PDE_DATA(inode));\r\n}\r\nstatic void create_toshiba_proc_entries(struct toshiba_acpi_dev *dev)\r\n{\r\nif (dev->backlight_dev)\r\nproc_create_data("lcd", S_IRUGO | S_IWUSR, toshiba_proc_dir,\r\n&lcd_proc_fops, dev);\r\nif (dev->video_supported)\r\nproc_create_data("video", S_IRUGO | S_IWUSR, toshiba_proc_dir,\r\n&video_proc_fops, dev);\r\nif (dev->fan_supported)\r\nproc_create_data("fan", S_IRUGO | S_IWUSR, toshiba_proc_dir,\r\n&fan_proc_fops, dev);\r\nif (dev->hotkey_dev)\r\nproc_create_data("keys", S_IRUGO | S_IWUSR, toshiba_proc_dir,\r\n&keys_proc_fops, dev);\r\nproc_create_data("version", S_IRUGO, toshiba_proc_dir,\r\n&version_proc_fops, dev);\r\n}\r\nstatic void remove_toshiba_proc_entries(struct toshiba_acpi_dev *dev)\r\n{\r\nif (dev->backlight_dev)\r\nremove_proc_entry("lcd", toshiba_proc_dir);\r\nif (dev->video_supported)\r\nremove_proc_entry("video", toshiba_proc_dir);\r\nif (dev->fan_supported)\r\nremove_proc_entry("fan", toshiba_proc_dir);\r\nif (dev->hotkey_dev)\r\nremove_proc_entry("keys", toshiba_proc_dir);\r\nremove_proc_entry("version", toshiba_proc_dir);\r\n}\r\nstatic ssize_t version_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%s\n", TOSHIBA_ACPI_VERSION);\r\n}\r\nstatic ssize_t fan_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\r\nint state;\r\nint ret;\r\nret = kstrtoint(buf, 0, &state);\r\nif (ret)\r\nreturn ret;\r\nif (state != 0 && state != 1)\r\nreturn -EINVAL;\r\nret = set_fan_status(toshiba, state);\r\nif (ret)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t fan_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\r\nu32 value;\r\nint ret;\r\nret = get_fan_status(toshiba, &value);\r\nif (ret)\r\nreturn ret;\r\nreturn sprintf(buf, "%d\n", value);\r\n}\r\nstatic ssize_t kbd_backlight_mode_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\r\nint mode;\r\nint ret;\r\nret = kstrtoint(buf, 0, &mode);\r\nif (ret)\r\nreturn ret;\r\nif (toshiba->kbd_type == 1) {\r\nif (mode != SCI_KBD_MODE_FNZ && mode != SCI_KBD_MODE_AUTO)\r\nreturn -EINVAL;\r\n} else if (toshiba->kbd_type == 2) {\r\nif (mode != SCI_KBD_MODE_AUTO && mode != SCI_KBD_MODE_ON &&\r\nmode != SCI_KBD_MODE_OFF)\r\nreturn -EINVAL;\r\n}\r\nif (toshiba->kbd_mode != mode) {\r\nint time = toshiba->kbd_time << HCI_MISC_SHIFT;\r\nif (toshiba->kbd_type == 1) {\r\ntime |= toshiba->kbd_mode;\r\n} else if (toshiba->kbd_type == 2) {\r\ntime |= mode;\r\n}\r\nret = toshiba_kbd_illum_status_set(toshiba, time);\r\nif (ret)\r\nreturn ret;\r\ntoshiba->kbd_mode = mode;\r\nif (toshiba->kbd_type == 2 &&\r\n!toshiba_acpi->kbd_event_generated)\r\nschedule_work(&kbd_bl_work);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t kbd_backlight_mode_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\r\nu32 time;\r\nif (toshiba_kbd_illum_status_get(toshiba, &time) < 0)\r\nreturn -EIO;\r\nreturn sprintf(buf, "%i\n", time & SCI_KBD_MODE_MASK);\r\n}\r\nstatic ssize_t kbd_type_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", toshiba->kbd_type);\r\n}\r\nstatic ssize_t available_kbd_modes_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\r\nif (toshiba->kbd_type == 1)\r\nreturn sprintf(buf, "0x%x 0x%x\n",\r\nSCI_KBD_MODE_FNZ, SCI_KBD_MODE_AUTO);\r\nreturn sprintf(buf, "0x%x 0x%x 0x%x\n",\r\nSCI_KBD_MODE_AUTO, SCI_KBD_MODE_ON, SCI_KBD_MODE_OFF);\r\n}\r\nstatic ssize_t kbd_backlight_timeout_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\r\nint time;\r\nint ret;\r\nret = kstrtoint(buf, 0, &time);\r\nif (ret)\r\nreturn ret;\r\nif (toshiba->kbd_type == 1) {\r\nif (time < 0 || time > 60)\r\nreturn -EINVAL;\r\n} else if (toshiba->kbd_type == 2) {\r\nif (time < 1 || time > 60)\r\nreturn -EINVAL;\r\n}\r\nif (toshiba->kbd_time != time) {\r\ntime = time << HCI_MISC_SHIFT;\r\nif (toshiba->kbd_type == 1)\r\ntime |= SCI_KBD_MODE_FNZ;\r\nelse if (toshiba->kbd_type == 2)\r\ntime |= SCI_KBD_MODE_AUTO;\r\nret = toshiba_kbd_illum_status_set(toshiba, time);\r\nif (ret)\r\nreturn ret;\r\ntoshiba->kbd_time = time >> HCI_MISC_SHIFT;\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t kbd_backlight_timeout_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\r\nu32 time;\r\nif (toshiba_kbd_illum_status_get(toshiba, &time) < 0)\r\nreturn -EIO;\r\nreturn sprintf(buf, "%i\n", time >> HCI_MISC_SHIFT);\r\n}\r\nstatic ssize_t touchpad_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\r\nint state;\r\nint ret;\r\nret = kstrtoint(buf, 0, &state);\r\nif (ret)\r\nreturn ret;\r\nif (state != 0 && state != 1)\r\nreturn -EINVAL;\r\nret = toshiba_touchpad_set(toshiba, state);\r\nif (ret)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t touchpad_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\r\nu32 state;\r\nint ret;\r\nret = toshiba_touchpad_get(toshiba, &state);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sprintf(buf, "%i\n", state);\r\n}\r\nstatic ssize_t usb_sleep_charge_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\r\nu32 mode;\r\nint ret;\r\nret = toshiba_usb_sleep_charge_get(toshiba, &mode);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sprintf(buf, "%x\n", mode & SCI_USB_CHARGE_MODE_MASK);\r\n}\r\nstatic ssize_t usb_sleep_charge_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\r\nint state;\r\nu32 mode;\r\nint ret;\r\nret = kstrtoint(buf, 0, &state);\r\nif (ret)\r\nreturn ret;\r\nif (state != 0 && state != 1 && state != 2 && state != 3)\r\nreturn -EINVAL;\r\nmode = toshiba->usbsc_mode_base;\r\nif (state == 0)\r\nmode |= SCI_USB_CHARGE_DISABLED;\r\nelse if (state == 1)\r\nmode |= SCI_USB_CHARGE_ALTERNATE;\r\nelse if (state == 2)\r\nmode |= SCI_USB_CHARGE_AUTO;\r\nelse if (state == 3)\r\nmode |= SCI_USB_CHARGE_TYPICAL;\r\nret = toshiba_usb_sleep_charge_set(toshiba, mode);\r\nif (ret)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t sleep_functions_on_battery_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\r\nint bat_lvl, status;\r\nu32 state;\r\nint ret;\r\nint tmp;\r\nret = toshiba_sleep_functions_status_get(toshiba, &state);\r\nif (ret < 0)\r\nreturn ret;\r\ntmp = state & SCI_USB_CHARGE_BAT_MASK;\r\nstatus = (tmp == 0x4) ? 1 : 0;\r\nbat_lvl = state >> HCI_MISC_SHIFT;\r\nreturn sprintf(buf, "%d %d\n", status, bat_lvl);\r\n}\r\nstatic ssize_t sleep_functions_on_battery_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\r\nu32 status;\r\nint value;\r\nint ret;\r\nint tmp;\r\nret = kstrtoint(buf, 0, &value);\r\nif (ret)\r\nreturn ret;\r\nif (value < 0 || value > 100)\r\nreturn -EINVAL;\r\nif (value == 0) {\r\ntmp = toshiba->usbsc_bat_level << HCI_MISC_SHIFT;\r\nstatus = tmp | SCI_USB_CHARGE_BAT_LVL_OFF;\r\n} else {\r\ntmp = value << HCI_MISC_SHIFT;\r\nstatus = tmp | SCI_USB_CHARGE_BAT_LVL_ON;\r\n}\r\nret = toshiba_sleep_functions_status_set(toshiba, status);\r\nif (ret < 0)\r\nreturn ret;\r\ntoshiba->usbsc_bat_level = status >> HCI_MISC_SHIFT;\r\nreturn count;\r\n}\r\nstatic ssize_t usb_rapid_charge_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\r\nu32 state;\r\nint ret;\r\nret = toshiba_usb_rapid_charge_get(toshiba, &state);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sprintf(buf, "%d\n", state);\r\n}\r\nstatic ssize_t usb_rapid_charge_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\r\nint state;\r\nint ret;\r\nret = kstrtoint(buf, 0, &state);\r\nif (ret)\r\nreturn ret;\r\nif (state != 0 && state != 1)\r\nreturn -EINVAL;\r\nret = toshiba_usb_rapid_charge_set(toshiba, state);\r\nif (ret)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t usb_sleep_music_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\r\nu32 state;\r\nint ret;\r\nret = toshiba_usb_sleep_music_get(toshiba, &state);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sprintf(buf, "%d\n", state);\r\n}\r\nstatic ssize_t usb_sleep_music_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\r\nint state;\r\nint ret;\r\nret = kstrtoint(buf, 0, &state);\r\nif (ret)\r\nreturn ret;\r\nif (state != 0 && state != 1)\r\nreturn -EINVAL;\r\nret = toshiba_usb_sleep_music_set(toshiba, state);\r\nif (ret)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t kbd_function_keys_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\r\nint mode;\r\nint ret;\r\nret = toshiba_function_keys_get(toshiba, &mode);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sprintf(buf, "%d\n", mode);\r\n}\r\nstatic ssize_t kbd_function_keys_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\r\nint mode;\r\nint ret;\r\nret = kstrtoint(buf, 0, &mode);\r\nif (ret)\r\nreturn ret;\r\nif (mode != 0 && mode != 1)\r\nreturn -EINVAL;\r\nret = toshiba_function_keys_set(toshiba, mode);\r\nif (ret)\r\nreturn ret;\r\npr_info("Reboot for changes to KBD Function Keys to take effect");\r\nreturn count;\r\n}\r\nstatic ssize_t panel_power_on_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\r\nu32 state;\r\nint ret;\r\nret = toshiba_panel_power_on_get(toshiba, &state);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sprintf(buf, "%d\n", state);\r\n}\r\nstatic ssize_t panel_power_on_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\r\nint state;\r\nint ret;\r\nret = kstrtoint(buf, 0, &state);\r\nif (ret)\r\nreturn ret;\r\nif (state != 0 && state != 1)\r\nreturn -EINVAL;\r\nret = toshiba_panel_power_on_set(toshiba, state);\r\nif (ret)\r\nreturn ret;\r\npr_info("Reboot for changes to Panel Power ON to take effect");\r\nreturn count;\r\n}\r\nstatic ssize_t usb_three_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\r\nu32 state;\r\nint ret;\r\nret = toshiba_usb_three_get(toshiba, &state);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sprintf(buf, "%d\n", state);\r\n}\r\nstatic ssize_t usb_three_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\r\nint state;\r\nint ret;\r\nret = kstrtoint(buf, 0, &state);\r\nif (ret)\r\nreturn ret;\r\nif (state != 0 && state != 1)\r\nreturn -EINVAL;\r\nret = toshiba_usb_three_set(toshiba, state);\r\nif (ret)\r\nreturn ret;\r\npr_info("Reboot for changes to USB 3 to take effect");\r\nreturn count;\r\n}\r\nstatic ssize_t cooling_method_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\r\nint state;\r\nint ret;\r\nret = toshiba_cooling_method_get(toshiba, &state);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sprintf(buf, "%d %d\n", state, toshiba->max_cooling_method);\r\n}\r\nstatic ssize_t cooling_method_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\r\nint state;\r\nint ret;\r\nret = kstrtoint(buf, 0, &state);\r\nif (ret)\r\nreturn ret;\r\nif (state < 0 || state > toshiba->max_cooling_method)\r\nreturn -EINVAL;\r\nret = toshiba_cooling_method_set(toshiba, state);\r\nif (ret)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic umode_t toshiba_sysfs_is_visible(struct kobject *kobj,\r\nstruct attribute *attr, int idx)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct toshiba_acpi_dev *drv = dev_get_drvdata(dev);\r\nbool exists = true;\r\nif (attr == &dev_attr_fan.attr)\r\nexists = (drv->fan_supported) ? true : false;\r\nelse if (attr == &dev_attr_kbd_backlight_mode.attr)\r\nexists = (drv->kbd_illum_supported) ? true : false;\r\nelse if (attr == &dev_attr_kbd_backlight_timeout.attr)\r\nexists = (drv->kbd_mode == SCI_KBD_MODE_AUTO) ? true : false;\r\nelse if (attr == &dev_attr_touchpad.attr)\r\nexists = (drv->touchpad_supported) ? true : false;\r\nelse if (attr == &dev_attr_usb_sleep_charge.attr)\r\nexists = (drv->usb_sleep_charge_supported) ? true : false;\r\nelse if (attr == &dev_attr_sleep_functions_on_battery.attr)\r\nexists = (drv->usb_sleep_charge_supported) ? true : false;\r\nelse if (attr == &dev_attr_usb_rapid_charge.attr)\r\nexists = (drv->usb_rapid_charge_supported) ? true : false;\r\nelse if (attr == &dev_attr_usb_sleep_music.attr)\r\nexists = (drv->usb_sleep_music_supported) ? true : false;\r\nelse if (attr == &dev_attr_kbd_function_keys.attr)\r\nexists = (drv->kbd_function_keys_supported) ? true : false;\r\nelse if (attr == &dev_attr_panel_power_on.attr)\r\nexists = (drv->panel_power_on_supported) ? true : false;\r\nelse if (attr == &dev_attr_usb_three.attr)\r\nexists = (drv->usb_three_supported) ? true : false;\r\nelse if (attr == &dev_attr_cooling_method.attr)\r\nexists = (drv->cooling_method_supported) ? true : false;\r\nreturn exists ? attr->mode : 0;\r\n}\r\nstatic void toshiba_acpi_kbd_bl_work(struct work_struct *work)\r\n{\r\nstruct acpi_device *acpi_dev = toshiba_acpi->acpi_dev;\r\nif (sysfs_update_group(&acpi_dev->dev.kobj,\r\n&toshiba_attr_group))\r\npr_err("Unable to update sysfs entries\n");\r\nacpi_bus_generate_netlink_event(acpi_dev->pnp.device_class,\r\ndev_name(&acpi_dev->dev),\r\n0x92, 0);\r\n}\r\nstatic int toshiba_iio_accel_get_axis(enum toshiba_iio_accel_chan chan)\r\n{\r\nu32 xyval, zval;\r\nint ret;\r\nret = toshiba_accelerometer_get(toshiba_acpi, &xyval, &zval);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (chan) {\r\ncase AXIS_X:\r\nreturn xyval & HCI_ACCEL_DIRECTION_MASK ?\r\n-(xyval & HCI_ACCEL_MASK) : xyval & HCI_ACCEL_MASK;\r\ncase AXIS_Y:\r\nreturn (xyval >> HCI_MISC_SHIFT) & HCI_ACCEL_DIRECTION_MASK ?\r\n-((xyval >> HCI_MISC_SHIFT) & HCI_ACCEL_MASK) :\r\n(xyval >> HCI_MISC_SHIFT) & HCI_ACCEL_MASK;\r\ncase AXIS_Z:\r\nreturn zval & HCI_ACCEL_DIRECTION_MASK ?\r\n-(zval & HCI_ACCEL_MASK) : zval & HCI_ACCEL_MASK;\r\n}\r\nreturn ret;\r\n}\r\nstatic int toshiba_iio_accel_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2, long mask)\r\n{\r\nint ret;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nret = toshiba_iio_accel_get_axis(chan->channel);\r\nif (ret == -EIO || ret == -ENODEV)\r\nreturn ret;\r\n*val = ret;\r\nreturn IIO_VAL_INT;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int toshiba_acpi_smm_bridge(SMMRegisters *regs)\r\n{\r\nu32 in[TCI_WORDS] = { regs->eax, regs->ebx, regs->ecx,\r\nregs->edx, regs->esi, regs->edi };\r\nu32 out[TCI_WORDS];\r\nacpi_status status;\r\nstatus = tci_raw(toshiba_acpi, in, out);\r\nif (ACPI_FAILURE(status)) {\r\npr_err("ACPI call to query SMM registers failed\n");\r\nreturn -EIO;\r\n}\r\nregs->eax = out[0];\r\nregs->ebx = out[1];\r\nregs->ecx = out[2];\r\nregs->edx = out[3];\r\nregs->esi = out[4];\r\nregs->edi = out[5];\r\nreturn 0;\r\n}\r\nstatic long toshiba_acpi_ioctl(struct file *fp, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nSMMRegisters __user *argp = (SMMRegisters __user *)arg;\r\nSMMRegisters regs;\r\nint ret;\r\nif (!argp)\r\nreturn -EINVAL;\r\nswitch (cmd) {\r\ncase TOSH_SMM:\r\nif (copy_from_user(&regs, argp, sizeof(SMMRegisters)))\r\nreturn -EFAULT;\r\nret = toshiba_acpi_smm_bridge(&regs);\r\nif (ret)\r\nreturn ret;\r\nif (copy_to_user(argp, &regs, sizeof(SMMRegisters)))\r\nreturn -EFAULT;\r\nbreak;\r\ncase TOSHIBA_ACPI_SCI:\r\nif (copy_from_user(&regs, argp, sizeof(SMMRegisters)))\r\nreturn -EFAULT;\r\nif (regs.eax != SCI_GET && regs.eax != SCI_SET)\r\nreturn -EINVAL;\r\nif (!sci_open(toshiba_acpi))\r\nreturn -EIO;\r\nret = toshiba_acpi_smm_bridge(&regs);\r\nsci_close(toshiba_acpi);\r\nif (ret)\r\nreturn ret;\r\nif (copy_to_user(argp, &regs, sizeof(SMMRegisters)))\r\nreturn -EFAULT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int toshiba_acpi_wwan_set_block(void *data, bool blocked)\r\n{\r\nstruct toshiba_acpi_dev *dev = data;\r\nint ret;\r\nret = toshiba_wireless_status(dev);\r\nif (ret)\r\nreturn ret;\r\nif (!dev->killswitch)\r\nreturn 0;\r\nreturn toshiba_wwan_set(dev, !blocked);\r\n}\r\nstatic void toshiba_acpi_wwan_poll(struct rfkill *rfkill, void *data)\r\n{\r\nstruct toshiba_acpi_dev *dev = data;\r\nif (toshiba_wireless_status(dev))\r\nreturn;\r\nrfkill_set_hw_state(dev->wwan_rfk, !dev->killswitch);\r\n}\r\nstatic int toshiba_acpi_setup_wwan_rfkill(struct toshiba_acpi_dev *dev)\r\n{\r\nint ret = toshiba_wireless_status(dev);\r\nif (ret)\r\nreturn ret;\r\ndev->wwan_rfk = rfkill_alloc("Toshiba WWAN",\r\n&dev->acpi_dev->dev,\r\nRFKILL_TYPE_WWAN,\r\n&wwan_rfk_ops,\r\ndev);\r\nif (!dev->wwan_rfk) {\r\npr_err("Unable to allocate WWAN rfkill device\n");\r\nreturn -ENOMEM;\r\n}\r\nrfkill_set_hw_state(dev->wwan_rfk, !dev->killswitch);\r\nret = rfkill_register(dev->wwan_rfk);\r\nif (ret) {\r\npr_err("Unable to register WWAN rfkill device\n");\r\nrfkill_destroy(dev->wwan_rfk);\r\n}\r\nreturn ret;\r\n}\r\nstatic int toshiba_acpi_enable_hotkeys(struct toshiba_acpi_dev *dev)\r\n{\r\nacpi_status status;\r\nu32 result;\r\nstatus = acpi_evaluate_object(dev->acpi_dev->handle,\r\n"ENAB", NULL, NULL);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENODEV;\r\nif (dev->kbd_function_keys_supported && dev->special_functions)\r\nresult = hci_write(dev, HCI_HOTKEY_EVENT,\r\nHCI_HOTKEY_SPECIAL_FUNCTIONS);\r\nelse\r\nresult = hci_write(dev, HCI_HOTKEY_EVENT, HCI_HOTKEY_ENABLE);\r\nif (result == TOS_FAILURE)\r\nreturn -EIO;\r\nelse if (result == TOS_NOT_SUPPORTED)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic bool toshiba_acpi_i8042_filter(unsigned char data, unsigned char str,\r\nstruct serio *port)\r\n{\r\nif (str & I8042_STR_AUXDATA)\r\nreturn false;\r\nif (unlikely(data == 0xe0))\r\nreturn false;\r\nif ((data & 0x7f) == TOS1900_FN_SCAN) {\r\nschedule_work(&toshiba_acpi->hotkey_work);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void toshiba_acpi_hotkey_work(struct work_struct *work)\r\n{\r\nacpi_handle ec_handle = ec_get_handle();\r\nacpi_status status;\r\nif (!ec_handle)\r\nreturn;\r\nstatus = acpi_evaluate_object(ec_handle, "NTFY", NULL, NULL);\r\nif (ACPI_FAILURE(status))\r\npr_err("ACPI NTFY method execution failed\n");\r\n}\r\nstatic int toshiba_acpi_query_hotkey(struct toshiba_acpi_dev *dev)\r\n{\r\nunsigned long long value;\r\nacpi_status status;\r\nstatus = acpi_evaluate_integer(dev->acpi_dev->handle, "INFO",\r\nNULL, &value);\r\nif (ACPI_FAILURE(status)) {\r\npr_err("ACPI INFO method execution failed\n");\r\nreturn -EIO;\r\n}\r\nreturn value;\r\n}\r\nstatic void toshiba_acpi_report_hotkey(struct toshiba_acpi_dev *dev,\r\nint scancode)\r\n{\r\nif (scancode == 0x100)\r\nreturn;\r\nif (scancode & 0x80)\r\nreturn;\r\nif (!sparse_keymap_report_event(dev->hotkey_dev, scancode, 1, true))\r\npr_info("Unknown key %x\n", scancode);\r\n}\r\nstatic void toshiba_acpi_process_hotkeys(struct toshiba_acpi_dev *dev)\r\n{\r\nif (dev->info_supported) {\r\nint scancode = toshiba_acpi_query_hotkey(dev);\r\nif (scancode < 0) {\r\npr_err("Failed to query hotkey event\n");\r\n} else if (scancode != 0) {\r\ntoshiba_acpi_report_hotkey(dev, scancode);\r\ndev->key_event_valid = 1;\r\ndev->last_key_event = scancode;\r\n}\r\n} else if (dev->system_event_supported) {\r\nu32 result;\r\nu32 value;\r\nint retries = 3;\r\ndo {\r\nresult = hci_read(dev, HCI_SYSTEM_EVENT, &value);\r\nswitch (result) {\r\ncase TOS_SUCCESS:\r\ntoshiba_acpi_report_hotkey(dev, (int)value);\r\ndev->key_event_valid = 1;\r\ndev->last_key_event = value;\r\nbreak;\r\ncase TOS_NOT_SUPPORTED:\r\nresult = hci_write(dev, HCI_SYSTEM_EVENT, 1);\r\nif (result == TOS_SUCCESS)\r\npr_notice("Re-enabled hotkeys\n");\r\ndefault:\r\nretries--;\r\nbreak;\r\n}\r\n} while (retries && result != TOS_FIFO_EMPTY);\r\n}\r\n}\r\nstatic int toshiba_acpi_setup_keyboard(struct toshiba_acpi_dev *dev)\r\n{\r\nconst struct key_entry *keymap = toshiba_acpi_keymap;\r\nacpi_handle ec_handle;\r\nint error;\r\nif (disable_hotkeys) {\r\npr_info("Hotkeys disabled by module parameter\n");\r\nreturn 0;\r\n}\r\nif (wmi_has_guid(TOSHIBA_WMI_EVENT_GUID)) {\r\npr_info("WMI event detected, hotkeys will not be monitored\n");\r\nreturn 0;\r\n}\r\nerror = toshiba_acpi_enable_hotkeys(dev);\r\nif (error)\r\nreturn error;\r\nif (toshiba_hotkey_event_type_get(dev, &dev->hotkey_event_type))\r\npr_notice("Unable to query Hotkey Event Type\n");\r\ndev->hotkey_dev = input_allocate_device();\r\nif (!dev->hotkey_dev)\r\nreturn -ENOMEM;\r\ndev->hotkey_dev->name = "Toshiba input device";\r\ndev->hotkey_dev->phys = "toshiba_acpi/input0";\r\ndev->hotkey_dev->id.bustype = BUS_HOST;\r\nif (dev->hotkey_event_type == HCI_SYSTEM_TYPE1 ||\r\n!dev->kbd_function_keys_supported)\r\nkeymap = toshiba_acpi_keymap;\r\nelse if (dev->hotkey_event_type == HCI_SYSTEM_TYPE2 ||\r\ndev->kbd_function_keys_supported)\r\nkeymap = toshiba_acpi_alt_keymap;\r\nelse\r\npr_info("Unknown event type received %x\n",\r\ndev->hotkey_event_type);\r\nerror = sparse_keymap_setup(dev->hotkey_dev, keymap, NULL);\r\nif (error)\r\ngoto err_free_dev;\r\nec_handle = ec_get_handle();\r\nif (ec_handle && acpi_has_method(ec_handle, "NTFY")) {\r\nINIT_WORK(&dev->hotkey_work, toshiba_acpi_hotkey_work);\r\nerror = i8042_install_filter(toshiba_acpi_i8042_filter);\r\nif (error) {\r\npr_err("Error installing key filter\n");\r\ngoto err_free_dev;\r\n}\r\ndev->ntfy_supported = 1;\r\n}\r\nif (acpi_has_method(dev->acpi_dev->handle, "INFO"))\r\ndev->info_supported = 1;\r\nelse if (hci_write(dev, HCI_SYSTEM_EVENT, 1) == TOS_SUCCESS)\r\ndev->system_event_supported = 1;\r\nif (!dev->info_supported && !dev->system_event_supported) {\r\npr_warn("No hotkey query interface found\n");\r\ngoto err_remove_filter;\r\n}\r\nerror = input_register_device(dev->hotkey_dev);\r\nif (error) {\r\npr_info("Unable to register input device\n");\r\ngoto err_remove_filter;\r\n}\r\nreturn 0;\r\nerr_remove_filter:\r\nif (dev->ntfy_supported)\r\ni8042_remove_filter(toshiba_acpi_i8042_filter);\r\nerr_free_dev:\r\ninput_free_device(dev->hotkey_dev);\r\ndev->hotkey_dev = NULL;\r\nreturn error;\r\n}\r\nstatic int toshiba_acpi_setup_backlight(struct toshiba_acpi_dev *dev)\r\n{\r\nstruct backlight_properties props;\r\nint brightness;\r\nint ret;\r\nbrightness = __get_lcd_brightness(dev);\r\nif (brightness < 0)\r\nreturn 0;\r\nif (dev->tr_backlight_supported && brightness == 0)\r\nbrightness++;\r\nret = set_lcd_brightness(dev, brightness);\r\nif (ret) {\r\npr_debug("Backlight method is read-only, disabling backlight support\n");\r\nreturn 0;\r\n}\r\nif (dev->tr_backlight_supported ||\r\ndmi_check_system(toshiba_vendor_backlight_dmi))\r\nacpi_video_set_dmi_backlight_type(acpi_backlight_vendor);\r\nif (acpi_video_get_backlight_type() != acpi_backlight_vendor)\r\nreturn 0;\r\nmemset(&props, 0, sizeof(props));\r\nprops.type = BACKLIGHT_PLATFORM;\r\nprops.max_brightness = HCI_LCD_BRIGHTNESS_LEVELS - 1;\r\nif (dev->tr_backlight_supported)\r\nprops.max_brightness++;\r\ndev->backlight_dev = backlight_device_register("toshiba",\r\n&dev->acpi_dev->dev,\r\ndev,\r\n&toshiba_backlight_data,\r\n&props);\r\nif (IS_ERR(dev->backlight_dev)) {\r\nret = PTR_ERR(dev->backlight_dev);\r\npr_err("Could not register toshiba backlight device\n");\r\ndev->backlight_dev = NULL;\r\nreturn ret;\r\n}\r\ndev->backlight_dev->props.brightness = brightness;\r\nreturn 0;\r\n}\r\nstatic void print_supported_features(struct toshiba_acpi_dev *dev)\r\n{\r\npr_info("Supported laptop features:");\r\nif (dev->hotkey_dev)\r\npr_cont(" hotkeys");\r\nif (dev->backlight_dev)\r\npr_cont(" backlight");\r\nif (dev->video_supported)\r\npr_cont(" video-out");\r\nif (dev->fan_supported)\r\npr_cont(" fan");\r\nif (dev->tr_backlight_supported)\r\npr_cont(" transflective-backlight");\r\nif (dev->illumination_supported)\r\npr_cont(" illumination");\r\nif (dev->kbd_illum_supported)\r\npr_cont(" keyboard-backlight");\r\nif (dev->touchpad_supported)\r\npr_cont(" touchpad");\r\nif (dev->eco_supported)\r\npr_cont(" eco-led");\r\nif (dev->accelerometer_supported)\r\npr_cont(" accelerometer-axes");\r\nif (dev->usb_sleep_charge_supported)\r\npr_cont(" usb-sleep-charge");\r\nif (dev->usb_rapid_charge_supported)\r\npr_cont(" usb-rapid-charge");\r\nif (dev->usb_sleep_music_supported)\r\npr_cont(" usb-sleep-music");\r\nif (dev->kbd_function_keys_supported)\r\npr_cont(" special-function-keys");\r\nif (dev->panel_power_on_supported)\r\npr_cont(" panel-power-on");\r\nif (dev->usb_three_supported)\r\npr_cont(" usb3");\r\nif (dev->wwan_supported)\r\npr_cont(" wwan");\r\nif (dev->cooling_method_supported)\r\npr_cont(" cooling-method");\r\npr_cont("\n");\r\n}\r\nstatic int toshiba_acpi_remove(struct acpi_device *acpi_dev)\r\n{\r\nstruct toshiba_acpi_dev *dev = acpi_driver_data(acpi_dev);\r\nmisc_deregister(&dev->miscdev);\r\nremove_toshiba_proc_entries(dev);\r\nif (dev->accelerometer_supported && dev->indio_dev) {\r\niio_device_unregister(dev->indio_dev);\r\niio_device_free(dev->indio_dev);\r\n}\r\nif (dev->sysfs_created)\r\nsysfs_remove_group(&dev->acpi_dev->dev.kobj,\r\n&toshiba_attr_group);\r\nif (dev->ntfy_supported) {\r\ni8042_remove_filter(toshiba_acpi_i8042_filter);\r\ncancel_work_sync(&dev->hotkey_work);\r\n}\r\nif (dev->hotkey_dev)\r\ninput_unregister_device(dev->hotkey_dev);\r\nbacklight_device_unregister(dev->backlight_dev);\r\nif (dev->illumination_led_registered)\r\nled_classdev_unregister(&dev->led_dev);\r\nif (dev->kbd_led_registered)\r\nled_classdev_unregister(&dev->kbd_led);\r\nif (dev->eco_led_registered)\r\nled_classdev_unregister(&dev->eco_led);\r\nif (dev->wwan_rfk) {\r\nrfkill_unregister(dev->wwan_rfk);\r\nrfkill_destroy(dev->wwan_rfk);\r\n}\r\nif (toshiba_acpi)\r\ntoshiba_acpi = NULL;\r\nkfree(dev);\r\nreturn 0;\r\n}\r\nstatic const char *find_hci_method(acpi_handle handle)\r\n{\r\nif (acpi_has_method(handle, "GHCI"))\r\nreturn "GHCI";\r\nif (acpi_has_method(handle, "SPFC"))\r\nreturn "SPFC";\r\nreturn NULL;\r\n}\r\nstatic int toshiba_acpi_add(struct acpi_device *acpi_dev)\r\n{\r\nstruct toshiba_acpi_dev *dev;\r\nconst char *hci_method;\r\nu32 dummy;\r\nint ret = 0;\r\nif (toshiba_acpi)\r\nreturn -EBUSY;\r\npr_info("Toshiba Laptop ACPI Extras version %s\n",\r\nTOSHIBA_ACPI_VERSION);\r\nhci_method = find_hci_method(acpi_dev->handle);\r\nif (!hci_method) {\r\npr_err("HCI interface not found\n");\r\nreturn -ENODEV;\r\n}\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\ndev->acpi_dev = acpi_dev;\r\ndev->method_hci = hci_method;\r\ndev->miscdev.minor = MISC_DYNAMIC_MINOR;\r\ndev->miscdev.name = "toshiba_acpi";\r\ndev->miscdev.fops = &toshiba_acpi_fops;\r\nret = misc_register(&dev->miscdev);\r\nif (ret) {\r\npr_err("Failed to register miscdevice\n");\r\nkfree(dev);\r\nreturn ret;\r\n}\r\nacpi_dev->driver_data = dev;\r\ndev_set_drvdata(&acpi_dev->dev, dev);\r\nret = toshiba_function_keys_get(dev, &dev->special_functions);\r\ndev->kbd_function_keys_supported = !ret;\r\ndev->hotkey_event_type = 0;\r\nif (toshiba_acpi_setup_keyboard(dev))\r\npr_info("Unable to activate hotkeys\n");\r\nret = get_tr_backlight_status(dev, &dummy);\r\ndev->tr_backlight_supported = !ret;\r\nret = toshiba_acpi_setup_backlight(dev);\r\nif (ret)\r\ngoto error;\r\ntoshiba_illumination_available(dev);\r\nif (dev->illumination_supported) {\r\ndev->led_dev.name = "toshiba::illumination";\r\ndev->led_dev.max_brightness = 1;\r\ndev->led_dev.brightness_set = toshiba_illumination_set;\r\ndev->led_dev.brightness_get = toshiba_illumination_get;\r\nif (!led_classdev_register(&acpi_dev->dev, &dev->led_dev))\r\ndev->illumination_led_registered = true;\r\n}\r\ntoshiba_eco_mode_available(dev);\r\nif (dev->eco_supported) {\r\ndev->eco_led.name = "toshiba::eco_mode";\r\ndev->eco_led.max_brightness = 1;\r\ndev->eco_led.brightness_set = toshiba_eco_mode_set_status;\r\ndev->eco_led.brightness_get = toshiba_eco_mode_get_status;\r\nif (!led_classdev_register(&dev->acpi_dev->dev, &dev->eco_led))\r\ndev->eco_led_registered = true;\r\n}\r\ntoshiba_kbd_illum_available(dev);\r\nif (dev->kbd_illum_supported && dev->kbd_mode == SCI_KBD_MODE_FNZ) {\r\ndev->kbd_led.name = "toshiba::kbd_backlight";\r\ndev->kbd_led.max_brightness = 1;\r\ndev->kbd_led.brightness_set = toshiba_kbd_backlight_set;\r\ndev->kbd_led.brightness_get = toshiba_kbd_backlight_get;\r\nif (!led_classdev_register(&dev->acpi_dev->dev, &dev->kbd_led))\r\ndev->kbd_led_registered = true;\r\n}\r\nret = toshiba_touchpad_get(dev, &dummy);\r\ndev->touchpad_supported = !ret;\r\ntoshiba_accelerometer_available(dev);\r\nif (dev->accelerometer_supported) {\r\ndev->indio_dev = iio_device_alloc(sizeof(*dev));\r\nif (!dev->indio_dev) {\r\npr_err("Unable to allocate iio device\n");\r\ngoto iio_error;\r\n}\r\npr_info("Registering Toshiba accelerometer iio device\n");\r\ndev->indio_dev->info = &toshiba_iio_accel_info;\r\ndev->indio_dev->name = "Toshiba accelerometer";\r\ndev->indio_dev->dev.parent = &acpi_dev->dev;\r\ndev->indio_dev->modes = INDIO_DIRECT_MODE;\r\ndev->indio_dev->channels = toshiba_iio_accel_channels;\r\ndev->indio_dev->num_channels =\r\nARRAY_SIZE(toshiba_iio_accel_channels);\r\nret = iio_device_register(dev->indio_dev);\r\nif (ret < 0) {\r\npr_err("Unable to register iio device\n");\r\niio_device_free(dev->indio_dev);\r\n}\r\n}\r\niio_error:\r\ntoshiba_usb_sleep_charge_available(dev);\r\nret = toshiba_usb_rapid_charge_get(dev, &dummy);\r\ndev->usb_rapid_charge_supported = !ret;\r\nret = toshiba_usb_sleep_music_get(dev, &dummy);\r\ndev->usb_sleep_music_supported = !ret;\r\nret = toshiba_panel_power_on_get(dev, &dummy);\r\ndev->panel_power_on_supported = !ret;\r\nret = toshiba_usb_three_get(dev, &dummy);\r\ndev->usb_three_supported = !ret;\r\nret = get_video_status(dev, &dummy);\r\ndev->video_supported = !ret;\r\nret = get_fan_status(dev, &dummy);\r\ndev->fan_supported = !ret;\r\ntoshiba_wwan_available(dev);\r\nif (dev->wwan_supported)\r\ntoshiba_acpi_setup_wwan_rfkill(dev);\r\ntoshiba_cooling_method_available(dev);\r\nprint_supported_features(dev);\r\nret = sysfs_create_group(&dev->acpi_dev->dev.kobj,\r\n&toshiba_attr_group);\r\nif (ret) {\r\ndev->sysfs_created = 0;\r\ngoto error;\r\n}\r\ndev->sysfs_created = !ret;\r\ncreate_toshiba_proc_entries(dev);\r\ntoshiba_acpi = dev;\r\nreturn 0;\r\nerror:\r\ntoshiba_acpi_remove(acpi_dev);\r\nreturn ret;\r\n}\r\nstatic void toshiba_acpi_notify(struct acpi_device *acpi_dev, u32 event)\r\n{\r\nstruct toshiba_acpi_dev *dev = acpi_driver_data(acpi_dev);\r\nswitch (event) {\r\ncase 0x80:\r\nif (wmi_has_guid(TOSHIBA_WMI_EVENT_GUID))\r\nreturn;\r\ntoshiba_acpi_process_hotkeys(dev);\r\nbreak;\r\ncase 0x81:\r\ncase 0x82:\r\ncase 0x83:\r\npr_info("Dock event received %x\n", event);\r\nbreak;\r\ncase 0x88:\r\npr_info("Thermal event received\n");\r\nbreak;\r\ncase 0x8f:\r\ncase 0x90:\r\nbreak;\r\ncase 0x8c:\r\ncase 0x8b:\r\npr_info("SATA power event received %x\n", event);\r\nbreak;\r\ncase 0x92:\r\ntoshiba_acpi->kbd_event_generated = true;\r\nif (sysfs_update_group(&acpi_dev->dev.kobj,\r\n&toshiba_attr_group))\r\npr_err("Unable to update sysfs entries\n");\r\nbreak;\r\ncase 0x85:\r\ncase 0x8d:\r\ncase 0x8e:\r\ncase 0x94:\r\ncase 0x95:\r\ndefault:\r\npr_info("Unknown event received %x\n", event);\r\nbreak;\r\n}\r\nacpi_bus_generate_netlink_event(acpi_dev->pnp.device_class,\r\ndev_name(&acpi_dev->dev),\r\nevent, (event == 0x80) ?\r\ndev->last_key_event : 0);\r\n}\r\nstatic int toshiba_acpi_suspend(struct device *device)\r\n{\r\nstruct toshiba_acpi_dev *dev = acpi_driver_data(to_acpi_device(device));\r\nif (dev->hotkey_dev) {\r\nu32 result;\r\nresult = hci_write(dev, HCI_HOTKEY_EVENT, HCI_HOTKEY_DISABLE);\r\nif (result != TOS_SUCCESS)\r\npr_info("Unable to disable hotkeys\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int toshiba_acpi_resume(struct device *device)\r\n{\r\nstruct toshiba_acpi_dev *dev = acpi_driver_data(to_acpi_device(device));\r\nif (dev->hotkey_dev) {\r\nif (toshiba_acpi_enable_hotkeys(dev))\r\npr_info("Unable to re-enable hotkeys\n");\r\n}\r\nif (dev->wwan_rfk) {\r\nif (!toshiba_wireless_status(dev))\r\nrfkill_set_hw_state(dev->wwan_rfk, !dev->killswitch);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init toshiba_acpi_init(void)\r\n{\r\nint ret;\r\ntoshiba_proc_dir = proc_mkdir(PROC_TOSHIBA, acpi_root_dir);\r\nif (!toshiba_proc_dir) {\r\npr_err("Unable to create proc dir " PROC_TOSHIBA "\n");\r\nreturn -ENODEV;\r\n}\r\nret = acpi_bus_register_driver(&toshiba_acpi_driver);\r\nif (ret) {\r\npr_err("Failed to register ACPI driver: %d\n", ret);\r\nremove_proc_entry(PROC_TOSHIBA, acpi_root_dir);\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit toshiba_acpi_exit(void)\r\n{\r\nacpi_bus_unregister_driver(&toshiba_acpi_driver);\r\nif (toshiba_proc_dir)\r\nremove_proc_entry(PROC_TOSHIBA, acpi_root_dir);\r\n}
