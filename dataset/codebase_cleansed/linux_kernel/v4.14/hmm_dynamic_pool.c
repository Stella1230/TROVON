static unsigned int get_pages_from_dynamic_pool(void *pool,\r\nstruct hmm_page_object *page_obj,\r\nunsigned int size, bool cached)\r\n{\r\nstruct hmm_page *hmm_page;\r\nunsigned long flags;\r\nunsigned int i = 0;\r\nstruct hmm_dynamic_pool_info *dypool_info = pool;\r\nif (!dypool_info)\r\nreturn 0;\r\nspin_lock_irqsave(&dypool_info->list_lock, flags);\r\nif (dypool_info->initialized) {\r\nwhile (!list_empty(&dypool_info->pages_list)) {\r\nhmm_page = list_entry(dypool_info->pages_list.next,\r\nstruct hmm_page, list);\r\nlist_del(&hmm_page->list);\r\ndypool_info->pgnr--;\r\nspin_unlock_irqrestore(&dypool_info->list_lock, flags);\r\npage_obj[i].page = hmm_page->page;\r\npage_obj[i++].type = HMM_PAGE_TYPE_DYNAMIC;\r\nkmem_cache_free(dypool_info->pgptr_cache, hmm_page);\r\nif (i == size)\r\nreturn i;\r\nspin_lock_irqsave(&dypool_info->list_lock, flags);\r\n}\r\n}\r\nspin_unlock_irqrestore(&dypool_info->list_lock, flags);\r\nreturn i;\r\n}\r\nstatic void free_pages_to_dynamic_pool(void *pool,\r\nstruct hmm_page_object *page_obj)\r\n{\r\nstruct hmm_page *hmm_page;\r\nunsigned long flags;\r\nint ret;\r\nstruct hmm_dynamic_pool_info *dypool_info = pool;\r\nif (!dypool_info)\r\nreturn;\r\nspin_lock_irqsave(&dypool_info->list_lock, flags);\r\nif (!dypool_info->initialized) {\r\nspin_unlock_irqrestore(&dypool_info->list_lock, flags);\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(&dypool_info->list_lock, flags);\r\nif (page_obj->type == HMM_PAGE_TYPE_RESERVED)\r\nreturn;\r\nif (dypool_info->pgnr >= dypool_info->pool_size) {\r\nret = set_pages_wb(page_obj->page, 1);\r\nif (ret)\r\ndev_err(atomisp_dev,\r\n"set page to WB err ...ret=%d\n", ret);\r\nif (!ret) {\r\n__free_pages(page_obj->page, 0);\r\nhmm_mem_stat.sys_size--;\r\n}\r\nreturn;\r\n}\r\nhmm_page = kmem_cache_zalloc(dypool_info->pgptr_cache,\r\nGFP_KERNEL);\r\nif (!hmm_page) {\r\ndev_err(atomisp_dev, "out of memory for hmm_page.\n");\r\nret = set_pages_wb(page_obj->page, 1);\r\nif (ret)\r\ndev_err(atomisp_dev,\r\n"set page to WB err ...ret=%d\n", ret);\r\nif (!ret) {\r\n__free_pages(page_obj->page, 0);\r\nhmm_mem_stat.sys_size--;\r\n}\r\nreturn;\r\n}\r\nhmm_page->page = page_obj->page;\r\nspin_lock_irqsave(&dypool_info->list_lock, flags);\r\nlist_add_tail(&hmm_page->list, &dypool_info->pages_list);\r\ndypool_info->pgnr++;\r\nspin_unlock_irqrestore(&dypool_info->list_lock, flags);\r\nhmm_mem_stat.dyc_size++;\r\n}\r\nstatic int hmm_dynamic_pool_init(void **pool, unsigned int pool_size)\r\n{\r\nstruct hmm_dynamic_pool_info *dypool_info;\r\nif (pool_size == 0)\r\nreturn 0;\r\ndypool_info = kmalloc(sizeof(struct hmm_dynamic_pool_info),\r\nGFP_KERNEL);\r\nif (unlikely(!dypool_info)) {\r\ndev_err(atomisp_dev, "out of memory for repool_info.\n");\r\nreturn -ENOMEM;\r\n}\r\ndypool_info->pgptr_cache = kmem_cache_create("pgptr_cache",\r\nsizeof(struct hmm_page), 0,\r\nSLAB_HWCACHE_ALIGN, NULL);\r\nif (!dypool_info->pgptr_cache) {\r\nkfree(dypool_info);\r\nreturn -ENOMEM;\r\n}\r\nINIT_LIST_HEAD(&dypool_info->pages_list);\r\nspin_lock_init(&dypool_info->list_lock);\r\ndypool_info->initialized = true;\r\ndypool_info->pool_size = pool_size;\r\ndypool_info->pgnr = 0;\r\n*pool = dypool_info;\r\nreturn 0;\r\n}\r\nstatic void hmm_dynamic_pool_exit(void **pool)\r\n{\r\nstruct hmm_dynamic_pool_info *dypool_info = *pool;\r\nstruct hmm_page *hmm_page;\r\nunsigned long flags;\r\nint ret;\r\nif (!dypool_info)\r\nreturn;\r\nspin_lock_irqsave(&dypool_info->list_lock, flags);\r\nif (!dypool_info->initialized) {\r\nspin_unlock_irqrestore(&dypool_info->list_lock, flags);\r\nreturn;\r\n}\r\ndypool_info->initialized = false;\r\nwhile (!list_empty(&dypool_info->pages_list)) {\r\nhmm_page = list_entry(dypool_info->pages_list.next,\r\nstruct hmm_page, list);\r\nlist_del(&hmm_page->list);\r\nspin_unlock_irqrestore(&dypool_info->list_lock, flags);\r\nret = set_pages_wb(hmm_page->page, 1);\r\nif (ret)\r\ndev_err(atomisp_dev,\r\n"set page to WB err...ret=%d\n", ret);\r\nif (!ret) {\r\n__free_pages(hmm_page->page, 0);\r\nhmm_mem_stat.dyc_size--;\r\nhmm_mem_stat.sys_size--;\r\n}\r\nkmem_cache_free(dypool_info->pgptr_cache, hmm_page);\r\nspin_lock_irqsave(&dypool_info->list_lock, flags);\r\n}\r\nspin_unlock_irqrestore(&dypool_info->list_lock, flags);\r\nkmem_cache_destroy(dypool_info->pgptr_cache);\r\nkfree(dypool_info);\r\n*pool = NULL;\r\n}\r\nstatic int hmm_dynamic_pool_inited(void *pool)\r\n{\r\nstruct hmm_dynamic_pool_info *dypool_info = pool;\r\nif (!dypool_info)\r\nreturn 0;\r\nreturn dypool_info->initialized;\r\n}
