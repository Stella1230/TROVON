int adis_write_reg(struct adis *adis, unsigned int reg,\r\nunsigned int value, unsigned int size)\r\n{\r\nunsigned int page = reg / ADIS_PAGE_SIZE;\r\nint ret, i;\r\nstruct spi_message msg;\r\nstruct spi_transfer xfers[] = {\r\n{\r\n.tx_buf = adis->tx,\r\n.bits_per_word = 8,\r\n.len = 2,\r\n.cs_change = 1,\r\n.delay_usecs = adis->data->write_delay,\r\n}, {\r\n.tx_buf = adis->tx + 2,\r\n.bits_per_word = 8,\r\n.len = 2,\r\n.cs_change = 1,\r\n.delay_usecs = adis->data->write_delay,\r\n}, {\r\n.tx_buf = adis->tx + 4,\r\n.bits_per_word = 8,\r\n.len = 2,\r\n.cs_change = 1,\r\n.delay_usecs = adis->data->write_delay,\r\n}, {\r\n.tx_buf = adis->tx + 6,\r\n.bits_per_word = 8,\r\n.len = 2,\r\n.delay_usecs = adis->data->write_delay,\r\n}, {\r\n.tx_buf = adis->tx + 8,\r\n.bits_per_word = 8,\r\n.len = 2,\r\n.delay_usecs = adis->data->write_delay,\r\n},\r\n};\r\nmutex_lock(&adis->txrx_lock);\r\nspi_message_init(&msg);\r\nif (adis->current_page != page) {\r\nadis->tx[0] = ADIS_WRITE_REG(ADIS_REG_PAGE_ID);\r\nadis->tx[1] = page;\r\nspi_message_add_tail(&xfers[0], &msg);\r\n}\r\nswitch (size) {\r\ncase 4:\r\nadis->tx[8] = ADIS_WRITE_REG(reg + 3);\r\nadis->tx[9] = (value >> 24) & 0xff;\r\nadis->tx[6] = ADIS_WRITE_REG(reg + 2);\r\nadis->tx[7] = (value >> 16) & 0xff;\r\ncase 2:\r\nadis->tx[4] = ADIS_WRITE_REG(reg + 1);\r\nadis->tx[5] = (value >> 8) & 0xff;\r\ncase 1:\r\nadis->tx[2] = ADIS_WRITE_REG(reg);\r\nadis->tx[3] = value & 0xff;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto out_unlock;\r\n}\r\nxfers[size].cs_change = 0;\r\nfor (i = 1; i <= size; i++)\r\nspi_message_add_tail(&xfers[i], &msg);\r\nret = spi_sync(adis->spi, &msg);\r\nif (ret) {\r\ndev_err(&adis->spi->dev, "Failed to write register 0x%02X: %d\n",\r\nreg, ret);\r\n} else {\r\nadis->current_page = page;\r\n}\r\nout_unlock:\r\nmutex_unlock(&adis->txrx_lock);\r\nreturn ret;\r\n}\r\nint adis_read_reg(struct adis *adis, unsigned int reg,\r\nunsigned int *val, unsigned int size)\r\n{\r\nunsigned int page = reg / ADIS_PAGE_SIZE;\r\nstruct spi_message msg;\r\nint ret;\r\nstruct spi_transfer xfers[] = {\r\n{\r\n.tx_buf = adis->tx,\r\n.bits_per_word = 8,\r\n.len = 2,\r\n.cs_change = 1,\r\n.delay_usecs = adis->data->write_delay,\r\n}, {\r\n.tx_buf = adis->tx + 2,\r\n.bits_per_word = 8,\r\n.len = 2,\r\n.cs_change = 1,\r\n.delay_usecs = adis->data->read_delay,\r\n}, {\r\n.tx_buf = adis->tx + 4,\r\n.rx_buf = adis->rx,\r\n.bits_per_word = 8,\r\n.len = 2,\r\n.cs_change = 1,\r\n.delay_usecs = adis->data->read_delay,\r\n}, {\r\n.rx_buf = adis->rx + 2,\r\n.bits_per_word = 8,\r\n.len = 2,\r\n.delay_usecs = adis->data->read_delay,\r\n},\r\n};\r\nmutex_lock(&adis->txrx_lock);\r\nspi_message_init(&msg);\r\nif (adis->current_page != page) {\r\nadis->tx[0] = ADIS_WRITE_REG(ADIS_REG_PAGE_ID);\r\nadis->tx[1] = page;\r\nspi_message_add_tail(&xfers[0], &msg);\r\n}\r\nswitch (size) {\r\ncase 4:\r\nadis->tx[2] = ADIS_READ_REG(reg + 2);\r\nadis->tx[3] = 0;\r\nspi_message_add_tail(&xfers[1], &msg);\r\ncase 2:\r\nadis->tx[4] = ADIS_READ_REG(reg);\r\nadis->tx[5] = 0;\r\nspi_message_add_tail(&xfers[2], &msg);\r\nspi_message_add_tail(&xfers[3], &msg);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto out_unlock;\r\n}\r\nret = spi_sync(adis->spi, &msg);\r\nif (ret) {\r\ndev_err(&adis->spi->dev, "Failed to read register 0x%02X: %d\n",\r\nreg, ret);\r\ngoto out_unlock;\r\n} else {\r\nadis->current_page = page;\r\n}\r\nswitch (size) {\r\ncase 4:\r\n*val = get_unaligned_be32(adis->rx);\r\nbreak;\r\ncase 2:\r\n*val = get_unaligned_be16(adis->rx + 2);\r\nbreak;\r\n}\r\nout_unlock:\r\nmutex_unlock(&adis->txrx_lock);\r\nreturn ret;\r\n}\r\nint adis_debugfs_reg_access(struct iio_dev *indio_dev,\r\nunsigned int reg, unsigned int writeval, unsigned int *readval)\r\n{\r\nstruct adis *adis = iio_device_get_drvdata(indio_dev);\r\nif (readval) {\r\nuint16_t val16;\r\nint ret;\r\nret = adis_read_reg_16(adis, reg, &val16);\r\n*readval = val16;\r\nreturn ret;\r\n} else {\r\nreturn adis_write_reg_16(adis, reg, writeval);\r\n}\r\n}\r\nint adis_enable_irq(struct adis *adis, bool enable)\r\n{\r\nint ret = 0;\r\nuint16_t msc;\r\nif (adis->data->enable_irq)\r\nreturn adis->data->enable_irq(adis, enable);\r\nret = adis_read_reg_16(adis, adis->data->msc_ctrl_reg, &msc);\r\nif (ret)\r\ngoto error_ret;\r\nmsc |= ADIS_MSC_CTRL_DATA_RDY_POL_HIGH;\r\nmsc &= ~ADIS_MSC_CTRL_DATA_RDY_DIO2;\r\nif (enable)\r\nmsc |= ADIS_MSC_CTRL_DATA_RDY_EN;\r\nelse\r\nmsc &= ~ADIS_MSC_CTRL_DATA_RDY_EN;\r\nret = adis_write_reg_16(adis, adis->data->msc_ctrl_reg, msc);\r\nerror_ret:\r\nreturn ret;\r\n}\r\nint adis_check_status(struct adis *adis)\r\n{\r\nuint16_t status;\r\nint ret;\r\nint i;\r\nret = adis_read_reg_16(adis, adis->data->diag_stat_reg, &status);\r\nif (ret < 0)\r\nreturn ret;\r\nstatus &= adis->data->status_error_mask;\r\nif (status == 0)\r\nreturn 0;\r\nfor (i = 0; i < 16; ++i) {\r\nif (status & BIT(i)) {\r\ndev_err(&adis->spi->dev, "%s.\n",\r\nadis->data->status_error_msgs[i]);\r\n}\r\n}\r\nreturn -EIO;\r\n}\r\nint adis_reset(struct adis *adis)\r\n{\r\nint ret;\r\nret = adis_write_reg_8(adis, adis->data->glob_cmd_reg,\r\nADIS_GLOB_CMD_SW_RESET);\r\nif (ret)\r\ndev_err(&adis->spi->dev, "Failed to reset device: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int adis_self_test(struct adis *adis)\r\n{\r\nint ret;\r\nret = adis_write_reg_16(adis, adis->data->msc_ctrl_reg,\r\nadis->data->self_test_mask);\r\nif (ret) {\r\ndev_err(&adis->spi->dev, "Failed to initiate self test: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nmsleep(adis->data->startup_delay);\r\nret = adis_check_status(adis);\r\nif (adis->data->self_test_no_autoclear)\r\nadis_write_reg_16(adis, adis->data->msc_ctrl_reg, 0x00);\r\nreturn ret;\r\n}\r\nint adis_initial_startup(struct adis *adis)\r\n{\r\nint ret;\r\nret = adis_self_test(adis);\r\nif (ret) {\r\ndev_err(&adis->spi->dev, "Self-test failed, trying reset.\n");\r\nadis_reset(adis);\r\nmsleep(adis->data->startup_delay);\r\nret = adis_self_test(adis);\r\nif (ret) {\r\ndev_err(&adis->spi->dev, "Second self-test failed, giving up.\n");\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint adis_single_conversion(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan, unsigned int error_mask, int *val)\r\n{\r\nstruct adis *adis = iio_device_get_drvdata(indio_dev);\r\nunsigned int uval;\r\nint ret;\r\nmutex_lock(&indio_dev->mlock);\r\nret = adis_read_reg(adis, chan->address, &uval,\r\nchan->scan_type.storagebits / 8);\r\nif (ret)\r\ngoto err_unlock;\r\nif (uval & error_mask) {\r\nret = adis_check_status(adis);\r\nif (ret)\r\ngoto err_unlock;\r\n}\r\nif (chan->scan_type.sign == 's')\r\n*val = sign_extend32(uval, chan->scan_type.realbits - 1);\r\nelse\r\n*val = uval & ((1 << chan->scan_type.realbits) - 1);\r\nret = IIO_VAL_INT;\r\nerr_unlock:\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\nint adis_init(struct adis *adis, struct iio_dev *indio_dev,\r\nstruct spi_device *spi, const struct adis_data *data)\r\n{\r\nmutex_init(&adis->txrx_lock);\r\nadis->spi = spi;\r\nadis->data = data;\r\niio_device_set_drvdata(indio_dev, adis);\r\nif (data->has_paging) {\r\nadis->current_page = -1;\r\n} else {\r\nadis->current_page = 0;\r\n}\r\nreturn adis_enable_irq(adis, false);\r\n}
