u32 hw_read_otgsc(struct ci_hdrc *ci, u32 mask)\r\n{\r\nstruct ci_hdrc_cable *cable;\r\nu32 val = hw_read(ci, OP_OTGSC, mask);\r\ncable = &ci->platdata->vbus_extcon;\r\nif (!IS_ERR(cable->edev)) {\r\nif (cable->changed)\r\nval |= OTGSC_BSVIS;\r\nelse\r\nval &= ~OTGSC_BSVIS;\r\nif (cable->connected)\r\nval |= OTGSC_BSV;\r\nelse\r\nval &= ~OTGSC_BSV;\r\nif (cable->enabled)\r\nval |= OTGSC_BSVIE;\r\nelse\r\nval &= ~OTGSC_BSVIE;\r\n}\r\ncable = &ci->platdata->id_extcon;\r\nif (!IS_ERR(cable->edev)) {\r\nif (cable->changed)\r\nval |= OTGSC_IDIS;\r\nelse\r\nval &= ~OTGSC_IDIS;\r\nif (cable->connected)\r\nval &= ~OTGSC_ID;\r\nelse\r\nval |= OTGSC_ID;\r\nif (cable->enabled)\r\nval |= OTGSC_IDIE;\r\nelse\r\nval &= ~OTGSC_IDIE;\r\n}\r\nreturn val & mask;\r\n}\r\nvoid hw_write_otgsc(struct ci_hdrc *ci, u32 mask, u32 data)\r\n{\r\nstruct ci_hdrc_cable *cable;\r\ncable = &ci->platdata->vbus_extcon;\r\nif (!IS_ERR(cable->edev)) {\r\nif (data & mask & OTGSC_BSVIS)\r\ncable->changed = false;\r\nif (data & mask & OTGSC_BSVIE) {\r\ncable->enabled = true;\r\ndata &= ~OTGSC_BSVIE;\r\n} else if (mask & OTGSC_BSVIE) {\r\ncable->enabled = false;\r\n}\r\n}\r\ncable = &ci->platdata->id_extcon;\r\nif (!IS_ERR(cable->edev)) {\r\nif (data & mask & OTGSC_IDIS)\r\ncable->changed = false;\r\nif (data & mask & OTGSC_IDIE) {\r\ncable->enabled = true;\r\ndata &= ~OTGSC_IDIE;\r\n} else if (mask & OTGSC_IDIE) {\r\ncable->enabled = false;\r\n}\r\n}\r\nhw_write(ci, OP_OTGSC, mask | OTGSC_INT_STATUS_BITS, data);\r\n}\r\nenum ci_role ci_otg_role(struct ci_hdrc *ci)\r\n{\r\nenum ci_role role = hw_read_otgsc(ci, OTGSC_ID)\r\n? CI_ROLE_GADGET\r\n: CI_ROLE_HOST;\r\nreturn role;\r\n}\r\nvoid ci_handle_vbus_change(struct ci_hdrc *ci)\r\n{\r\nif (!ci->is_otg)\r\nreturn;\r\nif (hw_read_otgsc(ci, OTGSC_BSV) && !ci->vbus_active)\r\nusb_gadget_vbus_connect(&ci->gadget);\r\nelse if (!hw_read_otgsc(ci, OTGSC_BSV) && ci->vbus_active)\r\nusb_gadget_vbus_disconnect(&ci->gadget);\r\n}\r\nstatic int hw_wait_vbus_lower_bsv(struct ci_hdrc *ci)\r\n{\r\nunsigned long elapse = jiffies + msecs_to_jiffies(5000);\r\nu32 mask = OTGSC_BSV;\r\nwhile (hw_read_otgsc(ci, mask)) {\r\nif (time_after(jiffies, elapse)) {\r\ndev_err(ci->dev, "timeout waiting for %08x in OTGSC\n",\r\nmask);\r\nreturn -ETIMEDOUT;\r\n}\r\nmsleep(20);\r\n}\r\nreturn 0;\r\n}\r\nstatic void ci_handle_id_switch(struct ci_hdrc *ci)\r\n{\r\nenum ci_role role = ci_otg_role(ci);\r\nif (role != ci->role) {\r\ndev_dbg(ci->dev, "switching from %s to %s\n",\r\nci_role(ci)->name, ci->roles[role]->name);\r\nci_role_stop(ci);\r\nif (role == CI_ROLE_GADGET &&\r\nIS_ERR(ci->platdata->vbus_extcon.edev))\r\nhw_wait_vbus_lower_bsv(ci);\r\nci_role_start(ci, role);\r\nif (role == CI_ROLE_GADGET)\r\nci_handle_vbus_change(ci);\r\n}\r\n}\r\nstatic void ci_otg_work(struct work_struct *work)\r\n{\r\nstruct ci_hdrc *ci = container_of(work, struct ci_hdrc, work);\r\nif (ci_otg_is_fsm_mode(ci) && !ci_otg_fsm_work(ci)) {\r\nenable_irq(ci->irq);\r\nreturn;\r\n}\r\npm_runtime_get_sync(ci->dev);\r\nif (ci->id_event) {\r\nci->id_event = false;\r\nci_handle_id_switch(ci);\r\n} else if (ci->b_sess_valid_event) {\r\nci->b_sess_valid_event = false;\r\nci_handle_vbus_change(ci);\r\n} else\r\ndev_err(ci->dev, "unexpected event occurs at %s\n", __func__);\r\npm_runtime_put_sync(ci->dev);\r\nenable_irq(ci->irq);\r\n}\r\nint ci_hdrc_otg_init(struct ci_hdrc *ci)\r\n{\r\nINIT_WORK(&ci->work, ci_otg_work);\r\nci->wq = create_freezable_workqueue("ci_otg");\r\nif (!ci->wq) {\r\ndev_err(ci->dev, "can't create workqueue\n");\r\nreturn -ENODEV;\r\n}\r\nif (ci_otg_is_fsm_mode(ci))\r\nreturn ci_hdrc_otg_fsm_init(ci);\r\nreturn 0;\r\n}\r\nvoid ci_hdrc_otg_destroy(struct ci_hdrc *ci)\r\n{\r\nif (ci->wq) {\r\nflush_workqueue(ci->wq);\r\ndestroy_workqueue(ci->wq);\r\n}\r\nhw_write_otgsc(ci, OTGSC_INT_EN_BITS | OTGSC_INT_STATUS_BITS,\r\nOTGSC_INT_STATUS_BITS);\r\nif (ci_otg_is_fsm_mode(ci))\r\nci_hdrc_otg_fsm_remove(ci);\r\n}
