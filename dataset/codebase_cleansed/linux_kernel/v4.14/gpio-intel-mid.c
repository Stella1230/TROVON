static void __iomem *gpio_reg(struct gpio_chip *chip, unsigned offset,\r\nenum GPIO_REG reg_type)\r\n{\r\nstruct intel_mid_gpio *priv = gpiochip_get_data(chip);\r\nunsigned nreg = chip->ngpio / 32;\r\nu8 reg = offset / 32;\r\nreturn priv->reg_base + reg_type * nreg * 4 + reg * 4;\r\n}\r\nstatic void __iomem *gpio_reg_2bit(struct gpio_chip *chip, unsigned offset,\r\nenum GPIO_REG reg_type)\r\n{\r\nstruct intel_mid_gpio *priv = gpiochip_get_data(chip);\r\nunsigned nreg = chip->ngpio / 32;\r\nu8 reg = offset / 16;\r\nreturn priv->reg_base + reg_type * nreg * 4 + reg * 4;\r\n}\r\nstatic int intel_gpio_request(struct gpio_chip *chip, unsigned offset)\r\n{\r\nvoid __iomem *gafr = gpio_reg_2bit(chip, offset, GAFR);\r\nu32 value = readl(gafr);\r\nint shift = (offset % 16) << 1, af = (value >> shift) & 3;\r\nif (af) {\r\nvalue &= ~(3 << shift);\r\nwritel(value, gafr);\r\n}\r\nreturn 0;\r\n}\r\nstatic int intel_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nvoid __iomem *gplr = gpio_reg(chip, offset, GPLR);\r\nreturn !!(readl(gplr) & BIT(offset % 32));\r\n}\r\nstatic void intel_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nvoid __iomem *gpsr, *gpcr;\r\nif (value) {\r\ngpsr = gpio_reg(chip, offset, GPSR);\r\nwritel(BIT(offset % 32), gpsr);\r\n} else {\r\ngpcr = gpio_reg(chip, offset, GPCR);\r\nwritel(BIT(offset % 32), gpcr);\r\n}\r\n}\r\nstatic int intel_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct intel_mid_gpio *priv = gpiochip_get_data(chip);\r\nvoid __iomem *gpdr = gpio_reg(chip, offset, GPDR);\r\nu32 value;\r\nunsigned long flags;\r\nif (priv->pdev)\r\npm_runtime_get(&priv->pdev->dev);\r\nspin_lock_irqsave(&priv->lock, flags);\r\nvalue = readl(gpdr);\r\nvalue &= ~BIT(offset % 32);\r\nwritel(value, gpdr);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nif (priv->pdev)\r\npm_runtime_put(&priv->pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int intel_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned offset, int value)\r\n{\r\nstruct intel_mid_gpio *priv = gpiochip_get_data(chip);\r\nvoid __iomem *gpdr = gpio_reg(chip, offset, GPDR);\r\nunsigned long flags;\r\nintel_gpio_set(chip, offset, value);\r\nif (priv->pdev)\r\npm_runtime_get(&priv->pdev->dev);\r\nspin_lock_irqsave(&priv->lock, flags);\r\nvalue = readl(gpdr);\r\nvalue |= BIT(offset % 32);\r\nwritel(value, gpdr);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nif (priv->pdev)\r\npm_runtime_put(&priv->pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int intel_mid_irq_type(struct irq_data *d, unsigned type)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct intel_mid_gpio *priv = gpiochip_get_data(gc);\r\nu32 gpio = irqd_to_hwirq(d);\r\nunsigned long flags;\r\nu32 value;\r\nvoid __iomem *grer = gpio_reg(&priv->chip, gpio, GRER);\r\nvoid __iomem *gfer = gpio_reg(&priv->chip, gpio, GFER);\r\nif (gpio >= priv->chip.ngpio)\r\nreturn -EINVAL;\r\nif (priv->pdev)\r\npm_runtime_get(&priv->pdev->dev);\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (type & IRQ_TYPE_EDGE_RISING)\r\nvalue = readl(grer) | BIT(gpio % 32);\r\nelse\r\nvalue = readl(grer) & (~BIT(gpio % 32));\r\nwritel(value, grer);\r\nif (type & IRQ_TYPE_EDGE_FALLING)\r\nvalue = readl(gfer) | BIT(gpio % 32);\r\nelse\r\nvalue = readl(gfer) & (~BIT(gpio % 32));\r\nwritel(value, gfer);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nif (priv->pdev)\r\npm_runtime_put(&priv->pdev->dev);\r\nreturn 0;\r\n}\r\nstatic void intel_mid_irq_unmask(struct irq_data *d)\r\n{\r\n}\r\nstatic void intel_mid_irq_mask(struct irq_data *d)\r\n{\r\n}\r\nstatic void intel_mid_irq_handler(struct irq_desc *desc)\r\n{\r\nstruct gpio_chip *gc = irq_desc_get_handler_data(desc);\r\nstruct intel_mid_gpio *priv = gpiochip_get_data(gc);\r\nstruct irq_data *data = irq_desc_get_irq_data(desc);\r\nstruct irq_chip *chip = irq_data_get_irq_chip(data);\r\nu32 base, gpio, mask;\r\nunsigned long pending;\r\nvoid __iomem *gedr;\r\nfor (base = 0; base < priv->chip.ngpio; base += 32) {\r\ngedr = gpio_reg(&priv->chip, base, GEDR);\r\nwhile ((pending = readl(gedr))) {\r\ngpio = __ffs(pending);\r\nmask = BIT(gpio);\r\nwritel(mask, gedr);\r\ngeneric_handle_irq(irq_find_mapping(gc->irqdomain,\r\nbase + gpio));\r\n}\r\n}\r\nchip->irq_eoi(data);\r\n}\r\nstatic void intel_mid_irq_init_hw(struct intel_mid_gpio *priv)\r\n{\r\nvoid __iomem *reg;\r\nunsigned base;\r\nfor (base = 0; base < priv->chip.ngpio; base += 32) {\r\nreg = gpio_reg(&priv->chip, base, GRER);\r\nwritel(0, reg);\r\nreg = gpio_reg(&priv->chip, base, GFER);\r\nwritel(0, reg);\r\nreg = gpio_reg(&priv->chip, base, GEDR);\r\nwritel(~0, reg);\r\n}\r\n}\r\nstatic int __maybe_unused intel_gpio_runtime_idle(struct device *dev)\r\n{\r\nint err = pm_schedule_suspend(dev, 500);\r\nreturn err ?: -EBUSY;\r\n}\r\nstatic int intel_gpio_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nvoid __iomem *base;\r\nstruct intel_mid_gpio *priv;\r\nu32 gpio_base;\r\nu32 irq_base;\r\nint retval;\r\nstruct intel_mid_gpio_ddata *ddata =\r\n(struct intel_mid_gpio_ddata *)id->driver_data;\r\nretval = pcim_enable_device(pdev);\r\nif (retval)\r\nreturn retval;\r\nretval = pcim_iomap_regions(pdev, 1 << 0 | 1 << 1, pci_name(pdev));\r\nif (retval) {\r\ndev_err(&pdev->dev, "I/O memory mapping error\n");\r\nreturn retval;\r\n}\r\nbase = pcim_iomap_table(pdev)[1];\r\nirq_base = readl(base);\r\ngpio_base = readl(sizeof(u32) + base);\r\npcim_iounmap_regions(pdev, 1 << 1);\r\npriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv) {\r\ndev_err(&pdev->dev, "can't allocate chip data\n");\r\nreturn -ENOMEM;\r\n}\r\npriv->reg_base = pcim_iomap_table(pdev)[0];\r\npriv->chip.label = dev_name(&pdev->dev);\r\npriv->chip.parent = &pdev->dev;\r\npriv->chip.request = intel_gpio_request;\r\npriv->chip.direction_input = intel_gpio_direction_input;\r\npriv->chip.direction_output = intel_gpio_direction_output;\r\npriv->chip.get = intel_gpio_get;\r\npriv->chip.set = intel_gpio_set;\r\npriv->chip.base = gpio_base;\r\npriv->chip.ngpio = ddata->ngpio;\r\npriv->chip.can_sleep = false;\r\npriv->pdev = pdev;\r\nspin_lock_init(&priv->lock);\r\npci_set_drvdata(pdev, priv);\r\nretval = devm_gpiochip_add_data(&pdev->dev, &priv->chip, priv);\r\nif (retval) {\r\ndev_err(&pdev->dev, "gpiochip_add error %d\n", retval);\r\nreturn retval;\r\n}\r\nretval = gpiochip_irqchip_add(&priv->chip,\r\n&intel_mid_irqchip,\r\nirq_base,\r\nhandle_simple_irq,\r\nIRQ_TYPE_NONE);\r\nif (retval) {\r\ndev_err(&pdev->dev,\r\n"could not connect irqchip to gpiochip\n");\r\nreturn retval;\r\n}\r\nintel_mid_irq_init_hw(priv);\r\ngpiochip_set_chained_irqchip(&priv->chip,\r\n&intel_mid_irqchip,\r\npdev->irq,\r\nintel_mid_irq_handler);\r\npm_runtime_put_noidle(&pdev->dev);\r\npm_runtime_allow(&pdev->dev);\r\nreturn 0;\r\n}
