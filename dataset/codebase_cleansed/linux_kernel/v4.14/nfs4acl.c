static u32\r\nmask_from_posix(unsigned short perm, unsigned int flags)\r\n{\r\nint mask = NFS4_ANYONE_MODE;\r\nif (flags & NFS4_ACL_OWNER)\r\nmask |= NFS4_OWNER_MODE;\r\nif (perm & ACL_READ)\r\nmask |= NFS4_READ_MODE;\r\nif (perm & ACL_WRITE)\r\nmask |= NFS4_WRITE_MODE;\r\nif ((perm & ACL_WRITE) && (flags & NFS4_ACL_DIR))\r\nmask |= NFS4_ACE_DELETE_CHILD;\r\nif (perm & ACL_EXECUTE)\r\nmask |= NFS4_EXECUTE_MODE;\r\nreturn mask;\r\n}\r\nstatic u32\r\ndeny_mask_from_posix(unsigned short perm, u32 flags)\r\n{\r\nu32 mask = 0;\r\nif (perm & ACL_READ)\r\nmask |= NFS4_READ_MODE;\r\nif (perm & ACL_WRITE)\r\nmask |= NFS4_WRITE_MODE;\r\nif ((perm & ACL_WRITE) && (flags & NFS4_ACL_DIR))\r\nmask |= NFS4_ACE_DELETE_CHILD;\r\nif (perm & ACL_EXECUTE)\r\nmask |= NFS4_EXECUTE_MODE;\r\nreturn mask;\r\n}\r\nstatic void\r\nlow_mode_from_nfs4(u32 perm, unsigned short *mode, unsigned int flags)\r\n{\r\nu32 write_mode = NFS4_WRITE_MODE;\r\nif (flags & NFS4_ACL_DIR)\r\nwrite_mode |= NFS4_ACE_DELETE_CHILD;\r\n*mode = 0;\r\nif ((perm & NFS4_READ_MODE) == NFS4_READ_MODE)\r\n*mode |= ACL_READ;\r\nif ((perm & write_mode) == write_mode)\r\n*mode |= ACL_WRITE;\r\nif ((perm & NFS4_EXECUTE_MODE) == NFS4_EXECUTE_MODE)\r\n*mode |= ACL_EXECUTE;\r\n}\r\nint\r\nnfsd4_get_nfs4_acl(struct svc_rqst *rqstp, struct dentry *dentry,\r\nstruct nfs4_acl **acl)\r\n{\r\nstruct inode *inode = d_inode(dentry);\r\nint error = 0;\r\nstruct posix_acl *pacl = NULL, *dpacl = NULL;\r\nunsigned int flags = 0;\r\nint size = 0;\r\npacl = get_acl(inode, ACL_TYPE_ACCESS);\r\nif (!pacl)\r\npacl = posix_acl_from_mode(inode->i_mode, GFP_KERNEL);\r\nif (IS_ERR(pacl))\r\nreturn PTR_ERR(pacl);\r\nsize += 2 * pacl->a_count;\r\nif (S_ISDIR(inode->i_mode)) {\r\nflags = NFS4_ACL_DIR;\r\ndpacl = get_acl(inode, ACL_TYPE_DEFAULT);\r\nif (IS_ERR(dpacl)) {\r\nerror = PTR_ERR(dpacl);\r\ngoto rel_pacl;\r\n}\r\nif (dpacl)\r\nsize += 2 * dpacl->a_count;\r\n}\r\n*acl = kmalloc(nfs4_acl_bytes(size), GFP_KERNEL);\r\nif (*acl == NULL) {\r\nerror = -ENOMEM;\r\ngoto out;\r\n}\r\n(*acl)->naces = 0;\r\n_posix_to_nfsv4_one(pacl, *acl, flags & ~NFS4_ACL_TYPE_DEFAULT);\r\nif (dpacl)\r\n_posix_to_nfsv4_one(dpacl, *acl, flags | NFS4_ACL_TYPE_DEFAULT);\r\nout:\r\nposix_acl_release(dpacl);\r\nrel_pacl:\r\nposix_acl_release(pacl);\r\nreturn error;\r\n}\r\nstatic void\r\nsummarize_posix_acl(struct posix_acl *acl, struct posix_acl_summary *pas)\r\n{\r\nstruct posix_acl_entry *pa, *pe;\r\nmemset(pas, 0, sizeof(*pas));\r\npas->mask = 07;\r\npe = acl->a_entries + acl->a_count;\r\nFOREACH_ACL_ENTRY(pa, acl, pe) {\r\nswitch (pa->e_tag) {\r\ncase ACL_USER_OBJ:\r\npas->owner = pa->e_perm;\r\nbreak;\r\ncase ACL_GROUP_OBJ:\r\npas->group = pa->e_perm;\r\nbreak;\r\ncase ACL_USER:\r\npas->users |= pa->e_perm;\r\nbreak;\r\ncase ACL_GROUP:\r\npas->groups |= pa->e_perm;\r\nbreak;\r\ncase ACL_OTHER:\r\npas->other = pa->e_perm;\r\nbreak;\r\ncase ACL_MASK:\r\npas->mask = pa->e_perm;\r\nbreak;\r\n}\r\n}\r\npas->users &= pas->mask;\r\npas->group &= pas->mask;\r\npas->groups &= pas->mask;\r\n}\r\nstatic void\r\n_posix_to_nfsv4_one(struct posix_acl *pacl, struct nfs4_acl *acl,\r\nunsigned int flags)\r\n{\r\nstruct posix_acl_entry *pa, *group_owner_entry;\r\nstruct nfs4_ace *ace;\r\nstruct posix_acl_summary pas;\r\nunsigned short deny;\r\nint eflag = ((flags & NFS4_ACL_TYPE_DEFAULT) ?\r\nNFS4_INHERITANCE_FLAGS | NFS4_ACE_INHERIT_ONLY_ACE : 0);\r\nBUG_ON(pacl->a_count < 3);\r\nsummarize_posix_acl(pacl, &pas);\r\npa = pacl->a_entries;\r\nace = acl->aces + acl->naces;\r\ndeny = ~pas.owner;\r\ndeny &= pas.users | pas.group | pas.groups | pas.other;\r\nif (deny) {\r\nace->type = NFS4_ACE_ACCESS_DENIED_ACE_TYPE;\r\nace->flag = eflag;\r\nace->access_mask = deny_mask_from_posix(deny, flags);\r\nace->whotype = NFS4_ACL_WHO_OWNER;\r\nace++;\r\nacl->naces++;\r\n}\r\nace->type = NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE;\r\nace->flag = eflag;\r\nace->access_mask = mask_from_posix(pa->e_perm, flags | NFS4_ACL_OWNER);\r\nace->whotype = NFS4_ACL_WHO_OWNER;\r\nace++;\r\nacl->naces++;\r\npa++;\r\nwhile (pa->e_tag == ACL_USER) {\r\ndeny = ~(pa->e_perm & pas.mask);\r\ndeny &= pas.groups | pas.group | pas.other;\r\nif (deny) {\r\nace->type = NFS4_ACE_ACCESS_DENIED_ACE_TYPE;\r\nace->flag = eflag;\r\nace->access_mask = deny_mask_from_posix(deny, flags);\r\nace->whotype = NFS4_ACL_WHO_NAMED;\r\nace->who_uid = pa->e_uid;\r\nace++;\r\nacl->naces++;\r\n}\r\nace->type = NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE;\r\nace->flag = eflag;\r\nace->access_mask = mask_from_posix(pa->e_perm & pas.mask,\r\nflags);\r\nace->whotype = NFS4_ACL_WHO_NAMED;\r\nace->who_uid = pa->e_uid;\r\nace++;\r\nacl->naces++;\r\npa++;\r\n}\r\ngroup_owner_entry = pa;\r\nace->type = NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE;\r\nace->flag = eflag;\r\nace->access_mask = mask_from_posix(pas.group, flags);\r\nace->whotype = NFS4_ACL_WHO_GROUP;\r\nace++;\r\nacl->naces++;\r\npa++;\r\nwhile (pa->e_tag == ACL_GROUP) {\r\nace->type = NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE;\r\nace->flag = eflag | NFS4_ACE_IDENTIFIER_GROUP;\r\nace->access_mask = mask_from_posix(pa->e_perm & pas.mask,\r\nflags);\r\nace->whotype = NFS4_ACL_WHO_NAMED;\r\nace->who_gid = pa->e_gid;\r\nace++;\r\nacl->naces++;\r\npa++;\r\n}\r\npa = group_owner_entry;\r\ndeny = ~pas.group & pas.other;\r\nif (deny) {\r\nace->type = NFS4_ACE_ACCESS_DENIED_ACE_TYPE;\r\nace->flag = eflag;\r\nace->access_mask = deny_mask_from_posix(deny, flags);\r\nace->whotype = NFS4_ACL_WHO_GROUP;\r\nace++;\r\nacl->naces++;\r\n}\r\npa++;\r\nwhile (pa->e_tag == ACL_GROUP) {\r\ndeny = ~(pa->e_perm & pas.mask);\r\ndeny &= pas.other;\r\nif (deny) {\r\nace->type = NFS4_ACE_ACCESS_DENIED_ACE_TYPE;\r\nace->flag = eflag | NFS4_ACE_IDENTIFIER_GROUP;\r\nace->access_mask = deny_mask_from_posix(deny, flags);\r\nace->whotype = NFS4_ACL_WHO_NAMED;\r\nace->who_gid = pa->e_gid;\r\nace++;\r\nacl->naces++;\r\n}\r\npa++;\r\n}\r\nif (pa->e_tag == ACL_MASK)\r\npa++;\r\nace->type = NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE;\r\nace->flag = eflag;\r\nace->access_mask = mask_from_posix(pa->e_perm, flags);\r\nace->whotype = NFS4_ACL_WHO_EVERYONE;\r\nacl->naces++;\r\n}\r\nstatic bool\r\npace_gt(struct posix_acl_entry *pace1, struct posix_acl_entry *pace2)\r\n{\r\nif (pace1->e_tag != pace2->e_tag)\r\nreturn pace1->e_tag > pace2->e_tag;\r\nif (pace1->e_tag == ACL_USER)\r\nreturn uid_gt(pace1->e_uid, pace2->e_uid);\r\nif (pace1->e_tag == ACL_GROUP)\r\nreturn gid_gt(pace1->e_gid, pace2->e_gid);\r\nreturn false;\r\n}\r\nstatic void\r\nsort_pacl_range(struct posix_acl *pacl, int start, int end) {\r\nint sorted = 0, i;\r\nwhile (!sorted) {\r\nsorted = 1;\r\nfor (i = start; i < end; i++) {\r\nif (pace_gt(&pacl->a_entries[i],\r\n&pacl->a_entries[i+1])) {\r\nsorted = 0;\r\nswap(pacl->a_entries[i],\r\npacl->a_entries[i + 1]);\r\n}\r\n}\r\n}\r\n}\r\nstatic void\r\nsort_pacl(struct posix_acl *pacl)\r\n{\r\nint i, j;\r\nif (!pacl || pacl->a_count <= 4)\r\nreturn;\r\ni = 1;\r\nwhile (pacl->a_entries[i].e_tag == ACL_USER)\r\ni++;\r\nsort_pacl_range(pacl, 1, i-1);\r\nBUG_ON(pacl->a_entries[i].e_tag != ACL_GROUP_OBJ);\r\nj = ++i;\r\nwhile (pacl->a_entries[j].e_tag == ACL_GROUP)\r\nj++;\r\nsort_pacl_range(pacl, i, j-1);\r\nreturn;\r\n}\r\nstatic int\r\ninit_state(struct posix_acl_state *state, int cnt)\r\n{\r\nint alloc;\r\nmemset(state, 0, sizeof(struct posix_acl_state));\r\nstate->empty = 1;\r\nalloc = sizeof(struct posix_ace_state_array)\r\n+ cnt*sizeof(struct posix_user_ace_state);\r\nstate->users = kzalloc(alloc, GFP_KERNEL);\r\nif (!state->users)\r\nreturn -ENOMEM;\r\nstate->groups = kzalloc(alloc, GFP_KERNEL);\r\nif (!state->groups) {\r\nkfree(state->users);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nfree_state(struct posix_acl_state *state) {\r\nkfree(state->users);\r\nkfree(state->groups);\r\n}\r\nstatic inline void add_to_mask(struct posix_acl_state *state, struct posix_ace_state *astate)\r\n{\r\nstate->mask.allow |= astate->allow;\r\n}\r\nstatic struct posix_acl *\r\nposix_state_to_acl(struct posix_acl_state *state, unsigned int flags)\r\n{\r\nstruct posix_acl_entry *pace;\r\nstruct posix_acl *pacl;\r\nint nace;\r\nint i;\r\nif (state->empty && (flags & NFS4_ACL_TYPE_DEFAULT))\r\nreturn NULL;\r\nif (!state->users->n && !state->groups->n)\r\nnace = 3;\r\nelse\r\nnace = 4 + state->users->n + state->groups->n;\r\npacl = posix_acl_alloc(nace, GFP_KERNEL);\r\nif (!pacl)\r\nreturn ERR_PTR(-ENOMEM);\r\npace = pacl->a_entries;\r\npace->e_tag = ACL_USER_OBJ;\r\nlow_mode_from_nfs4(state->owner.allow, &pace->e_perm, flags);\r\nfor (i=0; i < state->users->n; i++) {\r\npace++;\r\npace->e_tag = ACL_USER;\r\nlow_mode_from_nfs4(state->users->aces[i].perms.allow,\r\n&pace->e_perm, flags);\r\npace->e_uid = state->users->aces[i].uid;\r\nadd_to_mask(state, &state->users->aces[i].perms);\r\n}\r\npace++;\r\npace->e_tag = ACL_GROUP_OBJ;\r\nlow_mode_from_nfs4(state->group.allow, &pace->e_perm, flags);\r\nadd_to_mask(state, &state->group);\r\nfor (i=0; i < state->groups->n; i++) {\r\npace++;\r\npace->e_tag = ACL_GROUP;\r\nlow_mode_from_nfs4(state->groups->aces[i].perms.allow,\r\n&pace->e_perm, flags);\r\npace->e_gid = state->groups->aces[i].gid;\r\nadd_to_mask(state, &state->groups->aces[i].perms);\r\n}\r\nif (state->users->n || state->groups->n) {\r\npace++;\r\npace->e_tag = ACL_MASK;\r\nlow_mode_from_nfs4(state->mask.allow, &pace->e_perm, flags);\r\n}\r\npace++;\r\npace->e_tag = ACL_OTHER;\r\nlow_mode_from_nfs4(state->other.allow, &pace->e_perm, flags);\r\nreturn pacl;\r\n}\r\nstatic inline void allow_bits(struct posix_ace_state *astate, u32 mask)\r\n{\r\nastate->allow |= mask & ~astate->deny;\r\n}\r\nstatic inline void deny_bits(struct posix_ace_state *astate, u32 mask)\r\n{\r\nastate->deny |= mask & ~astate->allow;\r\n}\r\nstatic int find_uid(struct posix_acl_state *state, kuid_t uid)\r\n{\r\nstruct posix_ace_state_array *a = state->users;\r\nint i;\r\nfor (i = 0; i < a->n; i++)\r\nif (uid_eq(a->aces[i].uid, uid))\r\nreturn i;\r\na->n++;\r\na->aces[i].uid = uid;\r\na->aces[i].perms.allow = state->everyone.allow;\r\na->aces[i].perms.deny = state->everyone.deny;\r\nreturn i;\r\n}\r\nstatic int find_gid(struct posix_acl_state *state, kgid_t gid)\r\n{\r\nstruct posix_ace_state_array *a = state->groups;\r\nint i;\r\nfor (i = 0; i < a->n; i++)\r\nif (gid_eq(a->aces[i].gid, gid))\r\nreturn i;\r\na->n++;\r\na->aces[i].gid = gid;\r\na->aces[i].perms.allow = state->everyone.allow;\r\na->aces[i].perms.deny = state->everyone.deny;\r\nreturn i;\r\n}\r\nstatic void deny_bits_array(struct posix_ace_state_array *a, u32 mask)\r\n{\r\nint i;\r\nfor (i=0; i < a->n; i++)\r\ndeny_bits(&a->aces[i].perms, mask);\r\n}\r\nstatic void allow_bits_array(struct posix_ace_state_array *a, u32 mask)\r\n{\r\nint i;\r\nfor (i=0; i < a->n; i++)\r\nallow_bits(&a->aces[i].perms, mask);\r\n}\r\nstatic void process_one_v4_ace(struct posix_acl_state *state,\r\nstruct nfs4_ace *ace)\r\n{\r\nu32 mask = ace->access_mask;\r\nint i;\r\nstate->empty = 0;\r\nswitch (ace2type(ace)) {\r\ncase ACL_USER_OBJ:\r\nif (ace->type == NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE) {\r\nallow_bits(&state->owner, mask);\r\n} else {\r\ndeny_bits(&state->owner, mask);\r\n}\r\nbreak;\r\ncase ACL_USER:\r\ni = find_uid(state, ace->who_uid);\r\nif (ace->type == NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE) {\r\nallow_bits(&state->users->aces[i].perms, mask);\r\n} else {\r\ndeny_bits(&state->users->aces[i].perms, mask);\r\nmask = state->users->aces[i].perms.deny;\r\ndeny_bits(&state->owner, mask);\r\n}\r\nbreak;\r\ncase ACL_GROUP_OBJ:\r\nif (ace->type == NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE) {\r\nallow_bits(&state->group, mask);\r\n} else {\r\ndeny_bits(&state->group, mask);\r\nmask = state->group.deny;\r\ndeny_bits(&state->owner, mask);\r\ndeny_bits(&state->everyone, mask);\r\ndeny_bits_array(state->users, mask);\r\ndeny_bits_array(state->groups, mask);\r\n}\r\nbreak;\r\ncase ACL_GROUP:\r\ni = find_gid(state, ace->who_gid);\r\nif (ace->type == NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE) {\r\nallow_bits(&state->groups->aces[i].perms, mask);\r\n} else {\r\ndeny_bits(&state->groups->aces[i].perms, mask);\r\nmask = state->groups->aces[i].perms.deny;\r\ndeny_bits(&state->owner, mask);\r\ndeny_bits(&state->group, mask);\r\ndeny_bits(&state->everyone, mask);\r\ndeny_bits_array(state->users, mask);\r\ndeny_bits_array(state->groups, mask);\r\n}\r\nbreak;\r\ncase ACL_OTHER:\r\nif (ace->type == NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE) {\r\nallow_bits(&state->owner, mask);\r\nallow_bits(&state->group, mask);\r\nallow_bits(&state->other, mask);\r\nallow_bits(&state->everyone, mask);\r\nallow_bits_array(state->users, mask);\r\nallow_bits_array(state->groups, mask);\r\n} else {\r\ndeny_bits(&state->owner, mask);\r\ndeny_bits(&state->group, mask);\r\ndeny_bits(&state->other, mask);\r\ndeny_bits(&state->everyone, mask);\r\ndeny_bits_array(state->users, mask);\r\ndeny_bits_array(state->groups, mask);\r\n}\r\n}\r\n}\r\nstatic int nfs4_acl_nfsv4_to_posix(struct nfs4_acl *acl,\r\nstruct posix_acl **pacl, struct posix_acl **dpacl,\r\nunsigned int flags)\r\n{\r\nstruct posix_acl_state effective_acl_state, default_acl_state;\r\nstruct nfs4_ace *ace;\r\nint ret;\r\nret = init_state(&effective_acl_state, acl->naces);\r\nif (ret)\r\nreturn ret;\r\nret = init_state(&default_acl_state, acl->naces);\r\nif (ret)\r\ngoto out_estate;\r\nret = -EINVAL;\r\nfor (ace = acl->aces; ace < acl->aces + acl->naces; ace++) {\r\nif (ace->type != NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE &&\r\nace->type != NFS4_ACE_ACCESS_DENIED_ACE_TYPE)\r\ngoto out_dstate;\r\nif (ace->flag & ~NFS4_SUPPORTED_FLAGS)\r\ngoto out_dstate;\r\nif ((ace->flag & NFS4_INHERITANCE_FLAGS) == 0) {\r\nprocess_one_v4_ace(&effective_acl_state, ace);\r\ncontinue;\r\n}\r\nif (!(flags & NFS4_ACL_DIR))\r\ngoto out_dstate;\r\nprocess_one_v4_ace(&default_acl_state, ace);\r\nif (!(ace->flag & NFS4_ACE_INHERIT_ONLY_ACE))\r\nprocess_one_v4_ace(&effective_acl_state, ace);\r\n}\r\n*pacl = posix_state_to_acl(&effective_acl_state, flags);\r\nif (IS_ERR(*pacl)) {\r\nret = PTR_ERR(*pacl);\r\n*pacl = NULL;\r\ngoto out_dstate;\r\n}\r\n*dpacl = posix_state_to_acl(&default_acl_state,\r\nflags | NFS4_ACL_TYPE_DEFAULT);\r\nif (IS_ERR(*dpacl)) {\r\nret = PTR_ERR(*dpacl);\r\n*dpacl = NULL;\r\nposix_acl_release(*pacl);\r\n*pacl = NULL;\r\ngoto out_dstate;\r\n}\r\nsort_pacl(*pacl);\r\nsort_pacl(*dpacl);\r\nret = 0;\r\nout_dstate:\r\nfree_state(&default_acl_state);\r\nout_estate:\r\nfree_state(&effective_acl_state);\r\nreturn ret;\r\n}\r\n__be32\r\nnfsd4_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,\r\nstruct nfs4_acl *acl)\r\n{\r\n__be32 error;\r\nint host_error;\r\nstruct dentry *dentry;\r\nstruct inode *inode;\r\nstruct posix_acl *pacl = NULL, *dpacl = NULL;\r\nunsigned int flags = 0;\r\nerror = fh_verify(rqstp, fhp, 0, NFSD_MAY_SATTR);\r\nif (error)\r\nreturn error;\r\ndentry = fhp->fh_dentry;\r\ninode = d_inode(dentry);\r\nif (S_ISDIR(inode->i_mode))\r\nflags = NFS4_ACL_DIR;\r\nhost_error = nfs4_acl_nfsv4_to_posix(acl, &pacl, &dpacl, flags);\r\nif (host_error == -EINVAL)\r\nreturn nfserr_attrnotsupp;\r\nif (host_error < 0)\r\ngoto out_nfserr;\r\nfh_lock(fhp);\r\nhost_error = set_posix_acl(inode, ACL_TYPE_ACCESS, pacl);\r\nif (host_error < 0)\r\ngoto out_drop_lock;\r\nif (S_ISDIR(inode->i_mode)) {\r\nhost_error = set_posix_acl(inode, ACL_TYPE_DEFAULT, dpacl);\r\n}\r\nout_drop_lock:\r\nfh_unlock(fhp);\r\nposix_acl_release(pacl);\r\nposix_acl_release(dpacl);\r\nout_nfserr:\r\nif (host_error == -EOPNOTSUPP)\r\nreturn nfserr_attrnotsupp;\r\nelse\r\nreturn nfserrno(host_error);\r\n}\r\nstatic short\r\nace2type(struct nfs4_ace *ace)\r\n{\r\nswitch (ace->whotype) {\r\ncase NFS4_ACL_WHO_NAMED:\r\nreturn (ace->flag & NFS4_ACE_IDENTIFIER_GROUP ?\r\nACL_GROUP : ACL_USER);\r\ncase NFS4_ACL_WHO_OWNER:\r\nreturn ACL_USER_OBJ;\r\ncase NFS4_ACL_WHO_GROUP:\r\nreturn ACL_GROUP_OBJ;\r\ncase NFS4_ACL_WHO_EVERYONE:\r\nreturn ACL_OTHER;\r\n}\r\nBUG();\r\nreturn -1;\r\n}\r\nint nfs4_acl_bytes(int entries)\r\n{\r\nreturn sizeof(struct nfs4_acl) + entries * sizeof(struct nfs4_ace);\r\n}\r\nint\r\nnfs4_acl_get_whotype(char *p, u32 len)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(s2t_map); i++) {\r\nif (s2t_map[i].stringlen == len &&\r\n0 == memcmp(s2t_map[i].string, p, len))\r\nreturn s2t_map[i].type;\r\n}\r\nreturn NFS4_ACL_WHO_NAMED;\r\n}\r\n__be32 nfs4_acl_write_who(struct xdr_stream *xdr, int who)\r\n{\r\n__be32 *p;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(s2t_map); i++) {\r\nif (s2t_map[i].type != who)\r\ncontinue;\r\np = xdr_reserve_space(xdr, s2t_map[i].stringlen + 4);\r\nif (!p)\r\nreturn nfserr_resource;\r\np = xdr_encode_opaque(p, s2t_map[i].string,\r\ns2t_map[i].stringlen);\r\nreturn 0;\r\n}\r\nWARN_ON_ONCE(1);\r\nreturn nfserr_serverfault;\r\n}
