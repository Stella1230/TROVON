static int setup_sigcontext32(struct pt_regs *regs,\r\nstruct sigcontext32 __user *sc)\r\n{\r\nint err = 0;\r\nint i;\r\nerr |= __put_user(regs->cp0_epc, &sc->sc_pc);\r\nerr |= __put_user(0, &sc->sc_regs[0]);\r\nfor (i = 1; i < 32; i++)\r\nerr |= __put_user(regs->regs[i], &sc->sc_regs[i]);\r\nerr |= __put_user(regs->hi, &sc->sc_mdhi);\r\nerr |= __put_user(regs->lo, &sc->sc_mdlo);\r\nif (cpu_has_dsp) {\r\nerr |= __put_user(rddsp(DSP_MASK), &sc->sc_dsp);\r\nerr |= __put_user(mfhi1(), &sc->sc_hi1);\r\nerr |= __put_user(mflo1(), &sc->sc_lo1);\r\nerr |= __put_user(mfhi2(), &sc->sc_hi2);\r\nerr |= __put_user(mflo2(), &sc->sc_lo2);\r\nerr |= __put_user(mfhi3(), &sc->sc_hi3);\r\nerr |= __put_user(mflo3(), &sc->sc_lo3);\r\n}\r\nerr |= protected_save_fp_context(sc);\r\nreturn err;\r\n}\r\nstatic int restore_sigcontext32(struct pt_regs *regs,\r\nstruct sigcontext32 __user *sc)\r\n{\r\nint err = 0;\r\ns32 treg;\r\nint i;\r\ncurrent->restart_block.fn = do_no_restart_syscall;\r\nerr |= __get_user(regs->cp0_epc, &sc->sc_pc);\r\nerr |= __get_user(regs->hi, &sc->sc_mdhi);\r\nerr |= __get_user(regs->lo, &sc->sc_mdlo);\r\nif (cpu_has_dsp) {\r\nerr |= __get_user(treg, &sc->sc_hi1); mthi1(treg);\r\nerr |= __get_user(treg, &sc->sc_lo1); mtlo1(treg);\r\nerr |= __get_user(treg, &sc->sc_hi2); mthi2(treg);\r\nerr |= __get_user(treg, &sc->sc_lo2); mtlo2(treg);\r\nerr |= __get_user(treg, &sc->sc_hi3); mthi3(treg);\r\nerr |= __get_user(treg, &sc->sc_lo3); mtlo3(treg);\r\nerr |= __get_user(treg, &sc->sc_dsp); wrdsp(treg, DSP_MASK);\r\n}\r\nfor (i = 1; i < 32; i++)\r\nerr |= __get_user(regs->regs[i], &sc->sc_regs[i]);\r\nreturn err ?: protected_restore_fp_context(sc);\r\n}\r\nstatic int setup_frame_32(void *sig_return, struct ksignal *ksig,\r\nstruct pt_regs *regs, sigset_t *set)\r\n{\r\nstruct sigframe32 __user *frame;\r\nint err = 0;\r\nframe = get_sigframe(ksig, regs, sizeof(*frame));\r\nif (!access_ok(VERIFY_WRITE, frame, sizeof (*frame)))\r\nreturn -EFAULT;\r\nerr |= setup_sigcontext32(regs, &frame->sf_sc);\r\nerr |= __copy_conv_sigset_to_user(&frame->sf_mask, set);\r\nif (err)\r\nreturn -EFAULT;\r\nregs->regs[ 4] = ksig->sig;\r\nregs->regs[ 5] = 0;\r\nregs->regs[ 6] = (unsigned long) &frame->sf_sc;\r\nregs->regs[29] = (unsigned long) frame;\r\nregs->regs[31] = (unsigned long) sig_return;\r\nregs->cp0_epc = regs->regs[25] = (unsigned long) ksig->ka.sa.sa_handler;\r\nDEBUGP("SIG deliver (%s:%d): sp=0x%p pc=0x%lx ra=0x%lx\n",\r\ncurrent->comm, current->pid,\r\nframe, regs->cp0_epc, regs->regs[31]);\r\nreturn 0;\r\n}\r\nasmlinkage void sys32_rt_sigreturn(nabi_no_regargs struct pt_regs regs)\r\n{\r\nstruct rt_sigframe32 __user *frame;\r\nsigset_t set;\r\nint sig;\r\nframe = (struct rt_sigframe32 __user *) regs.regs[29];\r\nif (!access_ok(VERIFY_READ, frame, sizeof(*frame)))\r\ngoto badframe;\r\nif (__copy_conv_sigset_from_user(&set, &frame->rs_uc.uc_sigmask))\r\ngoto badframe;\r\nset_current_blocked(&set);\r\nsig = restore_sigcontext32(&regs, &frame->rs_uc.uc_mcontext);\r\nif (sig < 0)\r\ngoto badframe;\r\nelse if (sig)\r\nforce_sig(sig, current);\r\nif (compat_restore_altstack(&frame->rs_uc.uc_stack))\r\ngoto badframe;\r\n__asm__ __volatile__(\r\n"move\t$29, %0\n\t"\r\n"j\tsyscall_exit"\r\n:\r\n:"r" (&regs));\r\nbadframe:\r\nforce_sig(SIGSEGV, current);\r\n}\r\nstatic int setup_rt_frame_32(void *sig_return, struct ksignal *ksig,\r\nstruct pt_regs *regs, sigset_t *set)\r\n{\r\nstruct rt_sigframe32 __user *frame;\r\nint err = 0;\r\nframe = get_sigframe(ksig, regs, sizeof(*frame));\r\nif (!access_ok(VERIFY_WRITE, frame, sizeof (*frame)))\r\nreturn -EFAULT;\r\nerr |= copy_siginfo_to_user32(&frame->rs_info, &ksig->info);\r\nerr |= __put_user(0, &frame->rs_uc.uc_flags);\r\nerr |= __put_user(0, &frame->rs_uc.uc_link);\r\nerr |= __compat_save_altstack(&frame->rs_uc.uc_stack, regs->regs[29]);\r\nerr |= setup_sigcontext32(regs, &frame->rs_uc.uc_mcontext);\r\nerr |= __copy_conv_sigset_to_user(&frame->rs_uc.uc_sigmask, set);\r\nif (err)\r\nreturn -EFAULT;\r\nregs->regs[ 4] = ksig->sig;\r\nregs->regs[ 5] = (unsigned long) &frame->rs_info;\r\nregs->regs[ 6] = (unsigned long) &frame->rs_uc;\r\nregs->regs[29] = (unsigned long) frame;\r\nregs->regs[31] = (unsigned long) sig_return;\r\nregs->cp0_epc = regs->regs[25] = (unsigned long) ksig->ka.sa.sa_handler;\r\nDEBUGP("SIG deliver (%s:%d): sp=0x%p pc=0x%lx ra=0x%lx\n",\r\ncurrent->comm, current->pid,\r\nframe, regs->cp0_epc, regs->regs[31]);\r\nreturn 0;\r\n}\r\nasmlinkage void sys32_sigreturn(nabi_no_regargs struct pt_regs regs)\r\n{\r\nstruct sigframe32 __user *frame;\r\nsigset_t blocked;\r\nint sig;\r\nframe = (struct sigframe32 __user *) regs.regs[29];\r\nif (!access_ok(VERIFY_READ, frame, sizeof(*frame)))\r\ngoto badframe;\r\nif (__copy_conv_sigset_from_user(&blocked, &frame->sf_mask))\r\ngoto badframe;\r\nset_current_blocked(&blocked);\r\nsig = restore_sigcontext32(&regs, &frame->sf_sc);\r\nif (sig < 0)\r\ngoto badframe;\r\nelse if (sig)\r\nforce_sig(sig, current);\r\n__asm__ __volatile__(\r\n"move\t$29, %0\n\t"\r\n"j\tsyscall_exit"\r\n:\r\n:"r" (&regs));\r\nbadframe:\r\nforce_sig(SIGSEGV, current);\r\n}
