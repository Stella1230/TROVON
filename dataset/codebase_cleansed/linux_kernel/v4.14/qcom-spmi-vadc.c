static int vadc_read(struct vadc_priv *vadc, u16 offset, u8 *data)\r\n{\r\nreturn regmap_bulk_read(vadc->regmap, vadc->base + offset, data, 1);\r\n}\r\nstatic int vadc_write(struct vadc_priv *vadc, u16 offset, u8 data)\r\n{\r\nreturn regmap_write(vadc->regmap, vadc->base + offset, data);\r\n}\r\nstatic int vadc_reset(struct vadc_priv *vadc)\r\n{\r\nu8 data;\r\nint ret;\r\nret = vadc_write(vadc, VADC_ACCESS, VADC_ACCESS_DATA);\r\nif (ret)\r\nreturn ret;\r\nret = vadc_read(vadc, VADC_PERH_RESET_CTL3, &data);\r\nif (ret)\r\nreturn ret;\r\nret = vadc_write(vadc, VADC_ACCESS, VADC_ACCESS_DATA);\r\nif (ret)\r\nreturn ret;\r\ndata |= VADC_FOLLOW_WARM_RB;\r\nreturn vadc_write(vadc, VADC_PERH_RESET_CTL3, data);\r\n}\r\nstatic int vadc_set_state(struct vadc_priv *vadc, bool state)\r\n{\r\nreturn vadc_write(vadc, VADC_EN_CTL1, state ? VADC_EN_CTL1_SET : 0);\r\n}\r\nstatic void vadc_show_status(struct vadc_priv *vadc)\r\n{\r\nu8 mode, sta1, chan, dig, en, req;\r\nint ret;\r\nret = vadc_read(vadc, VADC_MODE_CTL, &mode);\r\nif (ret)\r\nreturn;\r\nret = vadc_read(vadc, VADC_ADC_DIG_PARAM, &dig);\r\nif (ret)\r\nreturn;\r\nret = vadc_read(vadc, VADC_ADC_CH_SEL_CTL, &chan);\r\nif (ret)\r\nreturn;\r\nret = vadc_read(vadc, VADC_CONV_REQ, &req);\r\nif (ret)\r\nreturn;\r\nret = vadc_read(vadc, VADC_STATUS1, &sta1);\r\nif (ret)\r\nreturn;\r\nret = vadc_read(vadc, VADC_EN_CTL1, &en);\r\nif (ret)\r\nreturn;\r\ndev_err(vadc->dev,\r\n"mode:%02x en:%02x chan:%02x dig:%02x req:%02x sta1:%02x\n",\r\nmode, en, chan, dig, req, sta1);\r\n}\r\nstatic int vadc_configure(struct vadc_priv *vadc,\r\nstruct vadc_channel_prop *prop)\r\n{\r\nu8 decimation, mode_ctrl;\r\nint ret;\r\nmode_ctrl = (VADC_OP_MODE_NORMAL << VADC_OP_MODE_SHIFT) |\r\nVADC_ADC_TRIM_EN | VADC_AMUX_TRIM_EN;\r\nret = vadc_write(vadc, VADC_MODE_CTL, mode_ctrl);\r\nif (ret)\r\nreturn ret;\r\nret = vadc_write(vadc, VADC_ADC_CH_SEL_CTL, prop->channel);\r\nif (ret)\r\nreturn ret;\r\ndecimation = prop->decimation << VADC_ADC_DIG_DEC_RATIO_SEL_SHIFT;\r\nret = vadc_write(vadc, VADC_ADC_DIG_PARAM, decimation);\r\nif (ret)\r\nreturn ret;\r\nret = vadc_write(vadc, VADC_HW_SETTLE_DELAY, prop->hw_settle_time);\r\nif (ret)\r\nreturn ret;\r\nret = vadc_write(vadc, VADC_FAST_AVG_CTL, prop->avg_samples);\r\nif (ret)\r\nreturn ret;\r\nif (prop->avg_samples)\r\nret = vadc_write(vadc, VADC_FAST_AVG_EN, VADC_FAST_AVG_EN_SET);\r\nelse\r\nret = vadc_write(vadc, VADC_FAST_AVG_EN, 0);\r\nreturn ret;\r\n}\r\nstatic int vadc_poll_wait_eoc(struct vadc_priv *vadc, unsigned int interval_us)\r\n{\r\nunsigned int count, retry;\r\nu8 sta1;\r\nint ret;\r\nretry = interval_us / VADC_CONV_TIME_MIN_US;\r\nfor (count = 0; count < retry; count++) {\r\nret = vadc_read(vadc, VADC_STATUS1, &sta1);\r\nif (ret)\r\nreturn ret;\r\nsta1 &= VADC_STATUS1_REQ_STS_EOC_MASK;\r\nif (sta1 == VADC_STATUS1_EOC)\r\nreturn 0;\r\nusleep_range(VADC_CONV_TIME_MIN_US, VADC_CONV_TIME_MAX_US);\r\n}\r\nvadc_show_status(vadc);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int vadc_read_result(struct vadc_priv *vadc, u16 *data)\r\n{\r\nint ret;\r\nret = regmap_bulk_read(vadc->regmap, vadc->base + VADC_DATA, data, 2);\r\nif (ret)\r\nreturn ret;\r\n*data = clamp_t(u16, *data, VADC_MIN_ADC_CODE, VADC_MAX_ADC_CODE);\r\nreturn 0;\r\n}\r\nstatic struct vadc_channel_prop *vadc_get_channel(struct vadc_priv *vadc,\r\nunsigned int num)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < vadc->nchannels; i++)\r\nif (vadc->chan_props[i].channel == num)\r\nreturn &vadc->chan_props[i];\r\ndev_dbg(vadc->dev, "no such channel %02x\n", num);\r\nreturn NULL;\r\n}\r\nstatic int vadc_do_conversion(struct vadc_priv *vadc,\r\nstruct vadc_channel_prop *prop, u16 *data)\r\n{\r\nunsigned int timeout;\r\nint ret;\r\nmutex_lock(&vadc->lock);\r\nret = vadc_configure(vadc, prop);\r\nif (ret)\r\ngoto unlock;\r\nif (!vadc->poll_eoc)\r\nreinit_completion(&vadc->complete);\r\nret = vadc_set_state(vadc, true);\r\nif (ret)\r\ngoto unlock;\r\nret = vadc_write(vadc, VADC_CONV_REQ, VADC_CONV_REQ_SET);\r\nif (ret)\r\ngoto err_disable;\r\ntimeout = BIT(prop->avg_samples) * VADC_CONV_TIME_MIN_US * 2;\r\nif (vadc->poll_eoc) {\r\nret = vadc_poll_wait_eoc(vadc, timeout);\r\n} else {\r\nret = wait_for_completion_timeout(&vadc->complete, timeout);\r\nif (!ret) {\r\nret = -ETIMEDOUT;\r\ngoto err_disable;\r\n}\r\nret = vadc_poll_wait_eoc(vadc, VADC_CONV_TIME_MIN_US);\r\nif (ret)\r\ngoto err_disable;\r\n}\r\nret = vadc_read_result(vadc, data);\r\nerr_disable:\r\nvadc_set_state(vadc, false);\r\nif (ret)\r\ndev_err(vadc->dev, "conversion failed\n");\r\nunlock:\r\nmutex_unlock(&vadc->lock);\r\nreturn ret;\r\n}\r\nstatic int vadc_measure_ref_points(struct vadc_priv *vadc)\r\n{\r\nstruct vadc_channel_prop *prop;\r\nu16 read_1, read_2;\r\nint ret;\r\nvadc->graph[VADC_CALIB_RATIOMETRIC].dx = VADC_RATIOMETRIC_RANGE;\r\nvadc->graph[VADC_CALIB_ABSOLUTE].dx = VADC_ABSOLUTE_RANGE_UV;\r\nprop = vadc_get_channel(vadc, VADC_REF_1250MV);\r\nret = vadc_do_conversion(vadc, prop, &read_1);\r\nif (ret)\r\ngoto err;\r\nprop = vadc_get_channel(vadc, VADC_SPARE1);\r\nif (!prop)\r\nprop = vadc_get_channel(vadc, VADC_REF_625MV);\r\nret = vadc_do_conversion(vadc, prop, &read_2);\r\nif (ret)\r\ngoto err;\r\nif (read_1 == read_2) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nvadc->graph[VADC_CALIB_ABSOLUTE].dy = read_1 - read_2;\r\nvadc->graph[VADC_CALIB_ABSOLUTE].gnd = read_2;\r\nprop = vadc_get_channel(vadc, VADC_VDD_VADC);\r\nret = vadc_do_conversion(vadc, prop, &read_1);\r\nif (ret)\r\ngoto err;\r\nprop = vadc_get_channel(vadc, VADC_GND_REF);\r\nret = vadc_do_conversion(vadc, prop, &read_2);\r\nif (ret)\r\ngoto err;\r\nif (read_1 == read_2) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nvadc->graph[VADC_CALIB_RATIOMETRIC].dy = read_1 - read_2;\r\nvadc->graph[VADC_CALIB_RATIOMETRIC].gnd = read_2;\r\nerr:\r\nif (ret)\r\ndev_err(vadc->dev, "measure reference points failed\n");\r\nreturn ret;\r\n}\r\nstatic int vadc_prescaling_from_dt(u32 num, u32 den)\r\n{\r\nunsigned int pre;\r\nfor (pre = 0; pre < ARRAY_SIZE(vadc_prescale_ratios); pre++)\r\nif (vadc_prescale_ratios[pre].num == num &&\r\nvadc_prescale_ratios[pre].den == den)\r\nbreak;\r\nif (pre == ARRAY_SIZE(vadc_prescale_ratios))\r\nreturn -EINVAL;\r\nreturn pre;\r\n}\r\nstatic int vadc_hw_settle_time_from_dt(u32 value)\r\n{\r\nif ((value <= 1000 && value % 100) || (value > 1000 && value % 2000))\r\nreturn -EINVAL;\r\nif (value <= 1000)\r\nvalue /= 100;\r\nelse\r\nvalue = value / 2000 + 10;\r\nreturn value;\r\n}\r\nstatic int vadc_avg_samples_from_dt(u32 value)\r\n{\r\nif (!is_power_of_2(value) || value > VADC_AVG_SAMPLES_MAX)\r\nreturn -EINVAL;\r\nreturn __ffs64(value);\r\n}\r\nstatic int vadc_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan, int *val, int *val2,\r\nlong mask)\r\n{\r\nstruct vadc_priv *vadc = iio_priv(indio_dev);\r\nstruct vadc_channel_prop *prop;\r\nu16 adc_code;\r\nint ret;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_PROCESSED:\r\nprop = &vadc->chan_props[chan->address];\r\nret = vadc_do_conversion(vadc, prop, &adc_code);\r\nif (ret)\r\nbreak;\r\nret = qcom_vadc_scale(prop->scale_fn_type,\r\n&vadc->graph[prop->calibration],\r\n&vadc_prescale_ratios[prop->prescale],\r\n(prop->calibration == VADC_CALIB_ABSOLUTE),\r\nadc_code, val);\r\nif (ret)\r\nbreak;\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_RAW:\r\nprop = &vadc->chan_props[chan->address];\r\nret = vadc_do_conversion(vadc, prop, &adc_code);\r\nif (ret)\r\nbreak;\r\n*val = (int)adc_code;\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int vadc_of_xlate(struct iio_dev *indio_dev,\r\nconst struct of_phandle_args *iiospec)\r\n{\r\nstruct vadc_priv *vadc = iio_priv(indio_dev);\r\nunsigned int i;\r\nfor (i = 0; i < vadc->nchannels; i++)\r\nif (vadc->iio_chans[i].channel == iiospec->args[0])\r\nreturn i;\r\nreturn -EINVAL;\r\n}\r\nstatic int vadc_get_dt_channel_data(struct device *dev,\r\nstruct vadc_channel_prop *prop,\r\nstruct device_node *node)\r\n{\r\nconst char *name = node->name;\r\nu32 chan, value, varr[2];\r\nint ret;\r\nret = of_property_read_u32(node, "reg", &chan);\r\nif (ret) {\r\ndev_err(dev, "invalid channel number %s\n", name);\r\nreturn ret;\r\n}\r\nif (chan > VADC_CHAN_MAX || chan < VADC_CHAN_MIN) {\r\ndev_err(dev, "%s invalid channel number %d\n", name, chan);\r\nreturn -EINVAL;\r\n}\r\nprop->channel = chan;\r\nret = of_property_read_u32(node, "qcom,decimation", &value);\r\nif (!ret) {\r\nret = qcom_vadc_decimation_from_dt(value);\r\nif (ret < 0) {\r\ndev_err(dev, "%02x invalid decimation %d\n",\r\nchan, value);\r\nreturn ret;\r\n}\r\nprop->decimation = ret;\r\n} else {\r\nprop->decimation = VADC_DEF_DECIMATION;\r\n}\r\nret = of_property_read_u32_array(node, "qcom,pre-scaling", varr, 2);\r\nif (!ret) {\r\nret = vadc_prescaling_from_dt(varr[0], varr[1]);\r\nif (ret < 0) {\r\ndev_err(dev, "%02x invalid pre-scaling <%d %d>\n",\r\nchan, varr[0], varr[1]);\r\nreturn ret;\r\n}\r\nprop->prescale = ret;\r\n} else {\r\nprop->prescale = vadc_chans[prop->channel].prescale_index;\r\n}\r\nret = of_property_read_u32(node, "qcom,hw-settle-time", &value);\r\nif (!ret) {\r\nret = vadc_hw_settle_time_from_dt(value);\r\nif (ret < 0) {\r\ndev_err(dev, "%02x invalid hw-settle-time %d us\n",\r\nchan, value);\r\nreturn ret;\r\n}\r\nprop->hw_settle_time = ret;\r\n} else {\r\nprop->hw_settle_time = VADC_DEF_HW_SETTLE_TIME;\r\n}\r\nret = of_property_read_u32(node, "qcom,avg-samples", &value);\r\nif (!ret) {\r\nret = vadc_avg_samples_from_dt(value);\r\nif (ret < 0) {\r\ndev_err(dev, "%02x invalid avg-samples %d\n",\r\nchan, value);\r\nreturn ret;\r\n}\r\nprop->avg_samples = ret;\r\n} else {\r\nprop->avg_samples = VADC_DEF_AVG_SAMPLES;\r\n}\r\nif (of_property_read_bool(node, "qcom,ratiometric"))\r\nprop->calibration = VADC_CALIB_RATIOMETRIC;\r\nelse\r\nprop->calibration = VADC_CALIB_ABSOLUTE;\r\ndev_dbg(dev, "%02x name %s\n", chan, name);\r\nreturn 0;\r\n}\r\nstatic int vadc_get_dt_data(struct vadc_priv *vadc, struct device_node *node)\r\n{\r\nconst struct vadc_channels *vadc_chan;\r\nstruct iio_chan_spec *iio_chan;\r\nstruct vadc_channel_prop prop;\r\nstruct device_node *child;\r\nunsigned int index = 0;\r\nint ret;\r\nvadc->nchannels = of_get_available_child_count(node);\r\nif (!vadc->nchannels)\r\nreturn -EINVAL;\r\nvadc->iio_chans = devm_kcalloc(vadc->dev, vadc->nchannels,\r\nsizeof(*vadc->iio_chans), GFP_KERNEL);\r\nif (!vadc->iio_chans)\r\nreturn -ENOMEM;\r\nvadc->chan_props = devm_kcalloc(vadc->dev, vadc->nchannels,\r\nsizeof(*vadc->chan_props), GFP_KERNEL);\r\nif (!vadc->chan_props)\r\nreturn -ENOMEM;\r\niio_chan = vadc->iio_chans;\r\nfor_each_available_child_of_node(node, child) {\r\nret = vadc_get_dt_channel_data(vadc->dev, &prop, child);\r\nif (ret) {\r\nof_node_put(child);\r\nreturn ret;\r\n}\r\nprop.scale_fn_type = vadc_chans[prop.channel].scale_fn_type;\r\nvadc->chan_props[index] = prop;\r\nvadc_chan = &vadc_chans[prop.channel];\r\niio_chan->channel = prop.channel;\r\niio_chan->datasheet_name = vadc_chan->datasheet_name;\r\niio_chan->info_mask_separate = vadc_chan->info_mask;\r\niio_chan->type = vadc_chan->type;\r\niio_chan->indexed = 1;\r\niio_chan->address = index++;\r\niio_chan++;\r\n}\r\nif (!vadc_get_channel(vadc, VADC_REF_1250MV)) {\r\ndev_err(vadc->dev, "Please define 1.25V channel\n");\r\nreturn -ENODEV;\r\n}\r\nif (!vadc_get_channel(vadc, VADC_REF_625MV)) {\r\ndev_err(vadc->dev, "Please define 0.625V channel\n");\r\nreturn -ENODEV;\r\n}\r\nif (!vadc_get_channel(vadc, VADC_VDD_VADC)) {\r\ndev_err(vadc->dev, "Please define VDD channel\n");\r\nreturn -ENODEV;\r\n}\r\nif (!vadc_get_channel(vadc, VADC_GND_REF)) {\r\ndev_err(vadc->dev, "Please define GND channel\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t vadc_isr(int irq, void *dev_id)\r\n{\r\nstruct vadc_priv *vadc = dev_id;\r\ncomplete(&vadc->complete);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int vadc_check_revision(struct vadc_priv *vadc)\r\n{\r\nu8 val;\r\nint ret;\r\nret = vadc_read(vadc, VADC_PERPH_TYPE, &val);\r\nif (ret)\r\nreturn ret;\r\nif (val < VADC_PERPH_TYPE_ADC) {\r\ndev_err(vadc->dev, "%d is not ADC\n", val);\r\nreturn -ENODEV;\r\n}\r\nret = vadc_read(vadc, VADC_PERPH_SUBTYPE, &val);\r\nif (ret)\r\nreturn ret;\r\nif (val < VADC_PERPH_SUBTYPE_VADC) {\r\ndev_err(vadc->dev, "%d is not VADC\n", val);\r\nreturn -ENODEV;\r\n}\r\nret = vadc_read(vadc, VADC_REVISION2, &val);\r\nif (ret)\r\nreturn ret;\r\nif (val < VADC_REVISION2_SUPPORTED_VADC) {\r\ndev_err(vadc->dev, "revision %d not supported\n", val);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vadc_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct device *dev = &pdev->dev;\r\nstruct iio_dev *indio_dev;\r\nstruct vadc_priv *vadc;\r\nstruct regmap *regmap;\r\nint ret, irq_eoc;\r\nu32 reg;\r\nregmap = dev_get_regmap(dev->parent, NULL);\r\nif (!regmap)\r\nreturn -ENODEV;\r\nret = of_property_read_u32(node, "reg", &reg);\r\nif (ret < 0)\r\nreturn ret;\r\nindio_dev = devm_iio_device_alloc(dev, sizeof(*vadc));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\nvadc = iio_priv(indio_dev);\r\nvadc->regmap = regmap;\r\nvadc->dev = dev;\r\nvadc->base = reg;\r\nvadc->are_ref_measured = false;\r\ninit_completion(&vadc->complete);\r\nmutex_init(&vadc->lock);\r\nret = vadc_check_revision(vadc);\r\nif (ret)\r\nreturn ret;\r\nret = vadc_get_dt_data(vadc, node);\r\nif (ret)\r\nreturn ret;\r\nirq_eoc = platform_get_irq(pdev, 0);\r\nif (irq_eoc < 0) {\r\nif (irq_eoc == -EPROBE_DEFER || irq_eoc == -EINVAL)\r\nreturn irq_eoc;\r\nvadc->poll_eoc = true;\r\n} else {\r\nret = devm_request_irq(dev, irq_eoc, vadc_isr, 0,\r\n"spmi-vadc", vadc);\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = vadc_reset(vadc);\r\nif (ret) {\r\ndev_err(dev, "reset failed\n");\r\nreturn ret;\r\n}\r\nret = vadc_measure_ref_points(vadc);\r\nif (ret)\r\nreturn ret;\r\nindio_dev->dev.parent = dev;\r\nindio_dev->dev.of_node = node;\r\nindio_dev->name = pdev->name;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->info = &vadc_info;\r\nindio_dev->channels = vadc->iio_chans;\r\nindio_dev->num_channels = vadc->nchannels;\r\nreturn devm_iio_device_register(dev, indio_dev);\r\n}
