int lovsub_object_init(const struct lu_env *env, struct lu_object *obj,\r\nconst struct lu_object_conf *conf)\r\n{\r\nstruct lovsub_device *dev = lu2lovsub_dev(obj->lo_dev);\r\nstruct lu_object *below;\r\nstruct lu_device *under;\r\nint result;\r\nunder = &dev->acid_next->cd_lu_dev;\r\nbelow = under->ld_ops->ldo_object_alloc(env, obj->lo_header, under);\r\nif (below) {\r\nlu_object_add(obj, below);\r\ncl_object_page_init(lu2cl(obj), sizeof(struct lovsub_page));\r\nresult = 0;\r\n} else {\r\nresult = -ENOMEM;\r\n}\r\nreturn result;\r\n}\r\nstatic void lovsub_object_free(const struct lu_env *env, struct lu_object *obj)\r\n{\r\nstruct lovsub_object *los = lu2lovsub(obj);\r\nstruct lov_object *lov = los->lso_super;\r\nif (lov) {\r\nLASSERT(lov->lo_type == LLT_RAID0);\r\nLASSERT(lov->u.raid0.lo_sub[los->lso_index] == los);\r\nspin_lock(&lov->u.raid0.lo_sub_lock);\r\nlov->u.raid0.lo_sub[los->lso_index] = NULL;\r\nspin_unlock(&lov->u.raid0.lo_sub_lock);\r\n}\r\nlu_object_fini(obj);\r\nlu_object_header_fini(&los->lso_header.coh_lu);\r\nkmem_cache_free(lovsub_object_kmem, los);\r\n}\r\nstatic int lovsub_object_print(const struct lu_env *env, void *cookie,\r\nlu_printer_t p, const struct lu_object *obj)\r\n{\r\nstruct lovsub_object *los = lu2lovsub(obj);\r\nreturn (*p)(env, cookie, "[%d]", los->lso_index);\r\n}\r\nstatic int lovsub_attr_update(const struct lu_env *env, struct cl_object *obj,\r\nconst struct cl_attr *attr, unsigned int valid)\r\n{\r\nstruct lov_object *lov = cl2lovsub(obj)->lso_super;\r\nlov_r0(lov)->lo_attr_valid = 0;\r\nreturn 0;\r\n}\r\nstatic int lovsub_object_glimpse(const struct lu_env *env,\r\nconst struct cl_object *obj,\r\nstruct ost_lvb *lvb)\r\n{\r\nstruct lovsub_object *los = cl2lovsub(obj);\r\nreturn cl_object_glimpse(env, &los->lso_super->lo_cl, lvb);\r\n}\r\nstatic void lovsub_req_attr_set(const struct lu_env *env, struct cl_object *obj,\r\nstruct cl_req_attr *attr)\r\n{\r\nstruct lovsub_object *subobj = cl2lovsub(obj);\r\ncl_req_attr_set(env, &subobj->lso_super->lo_cl, attr);\r\nattr->cra_oa->o_stripe_idx = subobj->lso_index;\r\n}\r\nstruct lu_object *lovsub_object_alloc(const struct lu_env *env,\r\nconst struct lu_object_header *unused,\r\nstruct lu_device *dev)\r\n{\r\nstruct lovsub_object *los;\r\nstruct lu_object *obj;\r\nlos = kmem_cache_zalloc(lovsub_object_kmem, GFP_NOFS);\r\nif (los) {\r\nstruct cl_object_header *hdr;\r\nobj = lovsub2lu(los);\r\nhdr = &los->lso_header;\r\ncl_object_header_init(hdr);\r\nlu_object_init(obj, &hdr->coh_lu, dev);\r\nlu_object_add_top(&hdr->coh_lu, obj);\r\nlos->lso_cl.co_ops = &lovsub_ops;\r\nobj->lo_ops = &lovsub_lu_obj_ops;\r\n} else {\r\nobj = NULL;\r\n}\r\nreturn obj;\r\n}
