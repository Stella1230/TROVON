static void check_nodes_props(struct check *c, struct dt_info *dti, struct node *node)\r\n{\r\nstruct node *child;\r\nTRACE(c, "%s", node->fullpath);\r\nif (c->fn)\r\nc->fn(c, dti, node);\r\nfor_each_child(node, child)\r\ncheck_nodes_props(c, dti, child);\r\n}\r\nstatic bool run_check(struct check *c, struct dt_info *dti)\r\n{\r\nstruct node *dt = dti->dt;\r\nbool error = false;\r\nint i;\r\nassert(!c->inprogress);\r\nif (c->status != UNCHECKED)\r\ngoto out;\r\nc->inprogress = true;\r\nfor (i = 0; i < c->num_prereqs; i++) {\r\nstruct check *prq = c->prereq[i];\r\nerror = error || run_check(prq, dti);\r\nif (prq->status != PASSED) {\r\nc->status = PREREQ;\r\ncheck_msg(c, dti, "Failed prerequisite '%s'",\r\nc->prereq[i]->name);\r\n}\r\n}\r\nif (c->status != UNCHECKED)\r\ngoto out;\r\ncheck_nodes_props(c, dti, dt);\r\nif (c->status == UNCHECKED)\r\nc->status = PASSED;\r\nTRACE(c, "\tCompleted, status %d", c->status);\r\nout:\r\nc->inprogress = false;\r\nif ((c->status != PASSED) && (c->error))\r\nerror = true;\r\nreturn error;\r\n}\r\nstatic inline void check_always_fail(struct check *c, struct dt_info *dti,\r\nstruct node *node)\r\n{\r\nFAIL(c, dti, "always_fail check");\r\n}\r\nstatic void check_is_string(struct check *c, struct dt_info *dti,\r\nstruct node *node)\r\n{\r\nstruct property *prop;\r\nchar *propname = c->data;\r\nprop = get_property(node, propname);\r\nif (!prop)\r\nreturn;\r\nif (!data_is_one_string(prop->val))\r\nFAIL(c, dti, "\"%s\" property in %s is not a string",\r\npropname, node->fullpath);\r\n}\r\nstatic void check_is_cell(struct check *c, struct dt_info *dti,\r\nstruct node *node)\r\n{\r\nstruct property *prop;\r\nchar *propname = c->data;\r\nprop = get_property(node, propname);\r\nif (!prop)\r\nreturn;\r\nif (prop->val.len != sizeof(cell_t))\r\nFAIL(c, dti, "\"%s\" property in %s is not a single cell",\r\npropname, node->fullpath);\r\n}\r\nstatic void check_duplicate_node_names(struct check *c, struct dt_info *dti,\r\nstruct node *node)\r\n{\r\nstruct node *child, *child2;\r\nfor_each_child(node, child)\r\nfor (child2 = child->next_sibling;\r\nchild2;\r\nchild2 = child2->next_sibling)\r\nif (streq(child->name, child2->name))\r\nFAIL(c, dti, "Duplicate node name %s",\r\nchild->fullpath);\r\n}\r\nstatic void check_duplicate_property_names(struct check *c, struct dt_info *dti,\r\nstruct node *node)\r\n{\r\nstruct property *prop, *prop2;\r\nfor_each_property(node, prop) {\r\nfor (prop2 = prop->next; prop2; prop2 = prop2->next) {\r\nif (prop2->deleted)\r\ncontinue;\r\nif (streq(prop->name, prop2->name))\r\nFAIL(c, dti, "Duplicate property name %s in %s",\r\nprop->name, node->fullpath);\r\n}\r\n}\r\n}\r\nstatic void check_node_name_chars(struct check *c, struct dt_info *dti,\r\nstruct node *node)\r\n{\r\nint n = strspn(node->name, c->data);\r\nif (n < strlen(node->name))\r\nFAIL(c, dti, "Bad character '%c' in node %s",\r\nnode->name[n], node->fullpath);\r\n}\r\nstatic void check_node_name_chars_strict(struct check *c, struct dt_info *dti,\r\nstruct node *node)\r\n{\r\nint n = strspn(node->name, c->data);\r\nif (n < node->basenamelen)\r\nFAIL(c, dti, "Character '%c' not recommended in node %s",\r\nnode->name[n], node->fullpath);\r\n}\r\nstatic void check_node_name_format(struct check *c, struct dt_info *dti,\r\nstruct node *node)\r\n{\r\nif (strchr(get_unitname(node), '@'))\r\nFAIL(c, dti, "Node %s has multiple '@' characters in name",\r\nnode->fullpath);\r\n}\r\nstatic void check_unit_address_vs_reg(struct check *c, struct dt_info *dti,\r\nstruct node *node)\r\n{\r\nconst char *unitname = get_unitname(node);\r\nstruct property *prop = get_property(node, "reg");\r\nif (!prop) {\r\nprop = get_property(node, "ranges");\r\nif (prop && !prop->val.len)\r\nprop = NULL;\r\n}\r\nif (prop) {\r\nif (!unitname[0])\r\nFAIL(c, dti, "Node %s has a reg or ranges property, but no unit name",\r\nnode->fullpath);\r\n} else {\r\nif (unitname[0])\r\nFAIL(c, dti, "Node %s has a unit name, but no reg property",\r\nnode->fullpath);\r\n}\r\n}\r\nstatic void check_property_name_chars(struct check *c, struct dt_info *dti,\r\nstruct node *node)\r\n{\r\nstruct property *prop;\r\nfor_each_property(node, prop) {\r\nint n = strspn(prop->name, c->data);\r\nif (n < strlen(prop->name))\r\nFAIL(c, dti, "Bad character '%c' in property name \"%s\", node %s",\r\nprop->name[n], prop->name, node->fullpath);\r\n}\r\n}\r\nstatic void check_property_name_chars_strict(struct check *c,\r\nstruct dt_info *dti,\r\nstruct node *node)\r\n{\r\nstruct property *prop;\r\nfor_each_property(node, prop) {\r\nconst char *name = prop->name;\r\nint n = strspn(name, c->data);\r\nif (n == strlen(prop->name))\r\ncontinue;\r\nif (streq(name, "device_type"))\r\ncontinue;\r\nif (name[n] == '#' && ((n == 0) || (name[n-1] == ','))) {\r\nname += n + 1;\r\nn = strspn(name, c->data);\r\n}\r\nif (n < strlen(name))\r\nFAIL(c, dti, "Character '%c' not recommended in property name \"%s\", node %s",\r\nname[n], prop->name, node->fullpath);\r\n}\r\n}\r\nstatic void check_duplicate_label(struct check *c, struct dt_info *dti,\r\nconst char *label, struct node *node,\r\nstruct property *prop, struct marker *mark)\r\n{\r\nstruct node *dt = dti->dt;\r\nstruct node *othernode = NULL;\r\nstruct property *otherprop = NULL;\r\nstruct marker *othermark = NULL;\r\nothernode = get_node_by_label(dt, label);\r\nif (!othernode)\r\notherprop = get_property_by_label(dt, label, &othernode);\r\nif (!othernode)\r\nothermark = get_marker_label(dt, label, &othernode,\r\n&otherprop);\r\nif (!othernode)\r\nreturn;\r\nif ((othernode != node) || (otherprop != prop) || (othermark != mark))\r\nFAIL(c, dti, "Duplicate label '%s' on " DESCLABEL_FMT\r\n" and " DESCLABEL_FMT,\r\nlabel, DESCLABEL_ARGS(node, prop, mark),\r\nDESCLABEL_ARGS(othernode, otherprop, othermark));\r\n}\r\nstatic void check_duplicate_label_node(struct check *c, struct dt_info *dti,\r\nstruct node *node)\r\n{\r\nstruct label *l;\r\nstruct property *prop;\r\nfor_each_label(node->labels, l)\r\ncheck_duplicate_label(c, dti, l->label, node, NULL, NULL);\r\nfor_each_property(node, prop) {\r\nstruct marker *m = prop->val.markers;\r\nfor_each_label(prop->labels, l)\r\ncheck_duplicate_label(c, dti, l->label, node, prop, NULL);\r\nfor_each_marker_of_type(m, LABEL)\r\ncheck_duplicate_label(c, dti, m->ref, node, prop, m);\r\n}\r\n}\r\nstatic cell_t check_phandle_prop(struct check *c, struct dt_info *dti,\r\nstruct node *node, const char *propname)\r\n{\r\nstruct node *root = dti->dt;\r\nstruct property *prop;\r\nstruct marker *m;\r\ncell_t phandle;\r\nprop = get_property(node, propname);\r\nif (!prop)\r\nreturn 0;\r\nif (prop->val.len != sizeof(cell_t)) {\r\nFAIL(c, dti, "%s has bad length (%d) %s property",\r\nnode->fullpath, prop->val.len, prop->name);\r\nreturn 0;\r\n}\r\nm = prop->val.markers;\r\nfor_each_marker_of_type(m, REF_PHANDLE) {\r\nassert(m->offset == 0);\r\nif (node != get_node_by_ref(root, m->ref))\r\n{\r\nFAIL(c, dti, "%s in %s is a reference to another node",\r\nprop->name, node->fullpath);\r\n}\r\nreturn 0;\r\n}\r\nphandle = propval_cell(prop);\r\nif ((phandle == 0) || (phandle == -1)) {\r\nFAIL(c, dti, "%s has bad value (0x%x) in %s property",\r\nnode->fullpath, phandle, prop->name);\r\nreturn 0;\r\n}\r\nreturn phandle;\r\n}\r\nstatic void check_explicit_phandles(struct check *c, struct dt_info *dti,\r\nstruct node *node)\r\n{\r\nstruct node *root = dti->dt;\r\nstruct node *other;\r\ncell_t phandle, linux_phandle;\r\nassert(!node->phandle);\r\nphandle = check_phandle_prop(c, dti, node, "phandle");\r\nlinux_phandle = check_phandle_prop(c, dti, node, "linux,phandle");\r\nif (!phandle && !linux_phandle)\r\nreturn;\r\nif (linux_phandle && phandle && (phandle != linux_phandle))\r\nFAIL(c, dti, "%s has mismatching 'phandle' and 'linux,phandle'"\r\n" properties", node->fullpath);\r\nif (linux_phandle && !phandle)\r\nphandle = linux_phandle;\r\nother = get_node_by_phandle(root, phandle);\r\nif (other && (other != node)) {\r\nFAIL(c, dti, "%s has duplicated phandle 0x%x (seen before at %s)",\r\nnode->fullpath, phandle, other->fullpath);\r\nreturn;\r\n}\r\nnode->phandle = phandle;\r\n}\r\nstatic void check_name_properties(struct check *c, struct dt_info *dti,\r\nstruct node *node)\r\n{\r\nstruct property **pp, *prop = NULL;\r\nfor (pp = &node->proplist; *pp; pp = &((*pp)->next))\r\nif (streq((*pp)->name, "name")) {\r\nprop = *pp;\r\nbreak;\r\n}\r\nif (!prop)\r\nreturn;\r\nif ((prop->val.len != node->basenamelen+1)\r\n|| (memcmp(prop->val.val, node->name, node->basenamelen) != 0)) {\r\nFAIL(c, dti, "\"name\" property in %s is incorrect (\"%s\" instead"\r\n" of base node name)", node->fullpath, prop->val.val);\r\n} else {\r\n*pp = prop->next;\r\nfree(prop->name);\r\ndata_free(prop->val);\r\nfree(prop);\r\n}\r\n}\r\nstatic void fixup_phandle_references(struct check *c, struct dt_info *dti,\r\nstruct node *node)\r\n{\r\nstruct node *dt = dti->dt;\r\nstruct property *prop;\r\nfor_each_property(node, prop) {\r\nstruct marker *m = prop->val.markers;\r\nstruct node *refnode;\r\ncell_t phandle;\r\nfor_each_marker_of_type(m, REF_PHANDLE) {\r\nassert(m->offset + sizeof(cell_t) <= prop->val.len);\r\nrefnode = get_node_by_ref(dt, m->ref);\r\nif (! refnode) {\r\nif (!(dti->dtsflags & DTSF_PLUGIN))\r\nFAIL(c, dti, "Reference to non-existent node or "\r\n"label \"%s\"\n", m->ref);\r\nelse\r\n*((fdt32_t *)(prop->val.val + m->offset)) =\r\ncpu_to_fdt32(0xffffffff);\r\ncontinue;\r\n}\r\nphandle = get_node_phandle(dt, refnode);\r\n*((fdt32_t *)(prop->val.val + m->offset)) = cpu_to_fdt32(phandle);\r\n}\r\n}\r\n}\r\nstatic void fixup_path_references(struct check *c, struct dt_info *dti,\r\nstruct node *node)\r\n{\r\nstruct node *dt = dti->dt;\r\nstruct property *prop;\r\nfor_each_property(node, prop) {\r\nstruct marker *m = prop->val.markers;\r\nstruct node *refnode;\r\nchar *path;\r\nfor_each_marker_of_type(m, REF_PATH) {\r\nassert(m->offset <= prop->val.len);\r\nrefnode = get_node_by_ref(dt, m->ref);\r\nif (!refnode) {\r\nFAIL(c, dti, "Reference to non-existent node or label \"%s\"\n",\r\nm->ref);\r\ncontinue;\r\n}\r\npath = refnode->fullpath;\r\nprop->val = data_insert_at_marker(prop->val, m, path,\r\nstrlen(path) + 1);\r\n}\r\n}\r\n}\r\nstatic void fixup_addr_size_cells(struct check *c, struct dt_info *dti,\r\nstruct node *node)\r\n{\r\nstruct property *prop;\r\nnode->addr_cells = -1;\r\nnode->size_cells = -1;\r\nprop = get_property(node, "#address-cells");\r\nif (prop)\r\nnode->addr_cells = propval_cell(prop);\r\nprop = get_property(node, "#size-cells");\r\nif (prop)\r\nnode->size_cells = propval_cell(prop);\r\n}\r\nstatic void check_reg_format(struct check *c, struct dt_info *dti,\r\nstruct node *node)\r\n{\r\nstruct property *prop;\r\nint addr_cells, size_cells, entrylen;\r\nprop = get_property(node, "reg");\r\nif (!prop)\r\nreturn;\r\nif (!node->parent) {\r\nFAIL(c, dti, "Root node has a \"reg\" property");\r\nreturn;\r\n}\r\nif (prop->val.len == 0)\r\nFAIL(c, dti, "\"reg\" property in %s is empty", node->fullpath);\r\naddr_cells = node_addr_cells(node->parent);\r\nsize_cells = node_size_cells(node->parent);\r\nentrylen = (addr_cells + size_cells) * sizeof(cell_t);\r\nif (!entrylen || (prop->val.len % entrylen) != 0)\r\nFAIL(c, dti, "\"reg\" property in %s has invalid length (%d bytes) "\r\n"(#address-cells == %d, #size-cells == %d)",\r\nnode->fullpath, prop->val.len, addr_cells, size_cells);\r\n}\r\nstatic void check_ranges_format(struct check *c, struct dt_info *dti,\r\nstruct node *node)\r\n{\r\nstruct property *prop;\r\nint c_addr_cells, p_addr_cells, c_size_cells, p_size_cells, entrylen;\r\nprop = get_property(node, "ranges");\r\nif (!prop)\r\nreturn;\r\nif (!node->parent) {\r\nFAIL(c, dti, "Root node has a \"ranges\" property");\r\nreturn;\r\n}\r\np_addr_cells = node_addr_cells(node->parent);\r\np_size_cells = node_size_cells(node->parent);\r\nc_addr_cells = node_addr_cells(node);\r\nc_size_cells = node_size_cells(node);\r\nentrylen = (p_addr_cells + c_addr_cells + c_size_cells) * sizeof(cell_t);\r\nif (prop->val.len == 0) {\r\nif (p_addr_cells != c_addr_cells)\r\nFAIL(c, dti, "%s has empty \"ranges\" property but its "\r\n"#address-cells (%d) differs from %s (%d)",\r\nnode->fullpath, c_addr_cells, node->parent->fullpath,\r\np_addr_cells);\r\nif (p_size_cells != c_size_cells)\r\nFAIL(c, dti, "%s has empty \"ranges\" property but its "\r\n"#size-cells (%d) differs from %s (%d)",\r\nnode->fullpath, c_size_cells, node->parent->fullpath,\r\np_size_cells);\r\n} else if ((prop->val.len % entrylen) != 0) {\r\nFAIL(c, dti, "\"ranges\" property in %s has invalid length (%d bytes) "\r\n"(parent #address-cells == %d, child #address-cells == %d, "\r\n"#size-cells == %d)", node->fullpath, prop->val.len,\r\np_addr_cells, c_addr_cells, c_size_cells);\r\n}\r\n}\r\nstatic void check_pci_bridge(struct check *c, struct dt_info *dti, struct node *node)\r\n{\r\nstruct property *prop;\r\ncell_t *cells;\r\nprop = get_property(node, "device_type");\r\nif (!prop || !streq(prop->val.val, "pci"))\r\nreturn;\r\nnode->bus = &pci_bus;\r\nif (!strneq(node->name, "pci", node->basenamelen) &&\r\n!strneq(node->name, "pcie", node->basenamelen))\r\nFAIL(c, dti, "Node %s node name is not \"pci\" or \"pcie\"",\r\nnode->fullpath);\r\nprop = get_property(node, "ranges");\r\nif (!prop)\r\nFAIL(c, dti, "Node %s missing ranges for PCI bridge (or not a bridge)",\r\nnode->fullpath);\r\nif (node_addr_cells(node) != 3)\r\nFAIL(c, dti, "Node %s incorrect #address-cells for PCI bridge",\r\nnode->fullpath);\r\nif (node_size_cells(node) != 2)\r\nFAIL(c, dti, "Node %s incorrect #size-cells for PCI bridge",\r\nnode->fullpath);\r\nprop = get_property(node, "bus-range");\r\nif (!prop) {\r\nFAIL(c, dti, "Node %s missing bus-range for PCI bridge",\r\nnode->fullpath);\r\nreturn;\r\n}\r\nif (prop->val.len != (sizeof(cell_t) * 2)) {\r\nFAIL(c, dti, "Node %s bus-range must be 2 cells",\r\nnode->fullpath);\r\nreturn;\r\n}\r\ncells = (cell_t *)prop->val.val;\r\nif (fdt32_to_cpu(cells[0]) > fdt32_to_cpu(cells[1]))\r\nFAIL(c, dti, "Node %s bus-range 1st cell must be less than or equal to 2nd cell",\r\nnode->fullpath);\r\nif (fdt32_to_cpu(cells[1]) > 0xff)\r\nFAIL(c, dti, "Node %s bus-range maximum bus number must be less than 256",\r\nnode->fullpath);\r\n}\r\nstatic void check_pci_device_bus_num(struct check *c, struct dt_info *dti, struct node *node)\r\n{\r\nstruct property *prop;\r\nunsigned int bus_num, min_bus, max_bus;\r\ncell_t *cells;\r\nif (!node->parent || (node->parent->bus != &pci_bus))\r\nreturn;\r\nprop = get_property(node, "reg");\r\nif (!prop)\r\nreturn;\r\ncells = (cell_t *)prop->val.val;\r\nbus_num = (fdt32_to_cpu(cells[0]) & 0x00ff0000) >> 16;\r\nprop = get_property(node->parent, "bus-range");\r\nif (!prop) {\r\nmin_bus = max_bus = 0;\r\n} else {\r\ncells = (cell_t *)prop->val.val;\r\nmin_bus = fdt32_to_cpu(cells[0]);\r\nmax_bus = fdt32_to_cpu(cells[0]);\r\n}\r\nif ((bus_num < min_bus) || (bus_num > max_bus))\r\nFAIL(c, dti, "Node %s PCI bus number %d out of range, expected (%d - %d)",\r\nnode->fullpath, bus_num, min_bus, max_bus);\r\n}\r\nstatic void check_pci_device_reg(struct check *c, struct dt_info *dti, struct node *node)\r\n{\r\nstruct property *prop;\r\nconst char *unitname = get_unitname(node);\r\nchar unit_addr[5];\r\nunsigned int dev, func, reg;\r\ncell_t *cells;\r\nif (!node->parent || (node->parent->bus != &pci_bus))\r\nreturn;\r\nprop = get_property(node, "reg");\r\nif (!prop) {\r\nFAIL(c, dti, "Node %s missing PCI reg property", node->fullpath);\r\nreturn;\r\n}\r\ncells = (cell_t *)prop->val.val;\r\nif (cells[1] || cells[2])\r\nFAIL(c, dti, "Node %s PCI reg config space address cells 2 and 3 must be 0",\r\nnode->fullpath);\r\nreg = fdt32_to_cpu(cells[0]);\r\ndev = (reg & 0xf800) >> 11;\r\nfunc = (reg & 0x700) >> 8;\r\nif (reg & 0xff000000)\r\nFAIL(c, dti, "Node %s PCI reg address is not configuration space",\r\nnode->fullpath);\r\nif (reg & 0x000000ff)\r\nFAIL(c, dti, "Node %s PCI reg config space address register number must be 0",\r\nnode->fullpath);\r\nif (func == 0) {\r\nsnprintf(unit_addr, sizeof(unit_addr), "%x", dev);\r\nif (streq(unitname, unit_addr))\r\nreturn;\r\n}\r\nsnprintf(unit_addr, sizeof(unit_addr), "%x,%x", dev, func);\r\nif (streq(unitname, unit_addr))\r\nreturn;\r\nFAIL(c, dti, "Node %s PCI unit address format error, expected \"%s\"",\r\nnode->fullpath, unit_addr);\r\n}\r\nstatic bool node_is_compatible(struct node *node, const char *compat)\r\n{\r\nstruct property *prop;\r\nconst char *str, *end;\r\nprop = get_property(node, "compatible");\r\nif (!prop)\r\nreturn false;\r\nfor (str = prop->val.val, end = str + prop->val.len; str < end;\r\nstr += strnlen(str, end - str) + 1) {\r\nif (strneq(str, compat, end - str))\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void check_simple_bus_bridge(struct check *c, struct dt_info *dti, struct node *node)\r\n{\r\nif (node_is_compatible(node, "simple-bus"))\r\nnode->bus = &simple_bus;\r\n}\r\nstatic void check_simple_bus_reg(struct check *c, struct dt_info *dti, struct node *node)\r\n{\r\nstruct property *prop;\r\nconst char *unitname = get_unitname(node);\r\nchar unit_addr[17];\r\nunsigned int size;\r\nuint64_t reg = 0;\r\ncell_t *cells = NULL;\r\nif (!node->parent || (node->parent->bus != &simple_bus))\r\nreturn;\r\nprop = get_property(node, "reg");\r\nif (prop)\r\ncells = (cell_t *)prop->val.val;\r\nelse {\r\nprop = get_property(node, "ranges");\r\nif (prop && prop->val.len)\r\ncells = ((cell_t *)prop->val.val) + node_addr_cells(node);\r\n}\r\nif (!cells) {\r\nif (node->parent->parent && !(node->bus == &simple_bus))\r\nFAIL(c, dti, "Node %s missing or empty reg/ranges property", node->fullpath);\r\nreturn;\r\n}\r\nsize = node_addr_cells(node->parent);\r\nwhile (size--)\r\nreg = (reg << 32) | fdt32_to_cpu(*(cells++));\r\nsnprintf(unit_addr, sizeof(unit_addr), "%llx", (unsigned long long)reg);\r\nif (!streq(unitname, unit_addr))\r\nFAIL(c, dti, "Node %s simple-bus unit address format error, expected \"%s\"",\r\nnode->fullpath, unit_addr);\r\n}\r\nstatic void check_unit_address_format(struct check *c, struct dt_info *dti,\r\nstruct node *node)\r\n{\r\nconst char *unitname = get_unitname(node);\r\nif (node->parent && node->parent->bus)\r\nreturn;\r\nif (!unitname[0])\r\nreturn;\r\nif (!strncmp(unitname, "0x", 2)) {\r\nFAIL(c, dti, "Node %s unit name should not have leading \"0x\"",\r\nnode->fullpath);\r\nunitname += 2;\r\n}\r\nif (unitname[0] == '0' && isxdigit(unitname[1]))\r\nFAIL(c, dti, "Node %s unit name should not have leading 0s",\r\nnode->fullpath);\r\n}\r\nstatic void check_avoid_default_addr_size(struct check *c, struct dt_info *dti,\r\nstruct node *node)\r\n{\r\nstruct property *reg, *ranges;\r\nif (!node->parent)\r\nreturn;\r\nreg = get_property(node, "reg");\r\nranges = get_property(node, "ranges");\r\nif (!reg && !ranges)\r\nreturn;\r\nif (node->parent->addr_cells == -1)\r\nFAIL(c, dti, "Relying on default #address-cells value for %s",\r\nnode->fullpath);\r\nif (node->parent->size_cells == -1)\r\nFAIL(c, dti, "Relying on default #size-cells value for %s",\r\nnode->fullpath);\r\n}\r\nstatic void check_obsolete_chosen_interrupt_controller(struct check *c,\r\nstruct dt_info *dti,\r\nstruct node *node)\r\n{\r\nstruct node *dt = dti->dt;\r\nstruct node *chosen;\r\nstruct property *prop;\r\nif (node != dt)\r\nreturn;\r\nchosen = get_node_by_path(dt, "/chosen");\r\nif (!chosen)\r\nreturn;\r\nprop = get_property(chosen, "interrupt-controller");\r\nif (prop)\r\nFAIL(c, dti, "/chosen has obsolete \"interrupt-controller\" "\r\n"property");\r\n}\r\nstatic void enable_warning_error(struct check *c, bool warn, bool error)\r\n{\r\nint i;\r\nif ((warn && !c->warn) || (error && !c->error))\r\nfor (i = 0; i < c->num_prereqs; i++)\r\nenable_warning_error(c->prereq[i], warn, error);\r\nc->warn = c->warn || warn;\r\nc->error = c->error || error;\r\n}\r\nstatic void disable_warning_error(struct check *c, bool warn, bool error)\r\n{\r\nint i;\r\nif ((warn && c->warn) || (error && c->error)) {\r\nfor (i = 0; i < ARRAY_SIZE(check_table); i++) {\r\nstruct check *cc = check_table[i];\r\nint j;\r\nfor (j = 0; j < cc->num_prereqs; j++)\r\nif (cc->prereq[j] == c)\r\ndisable_warning_error(cc, warn, error);\r\n}\r\n}\r\nc->warn = c->warn && !warn;\r\nc->error = c->error && !error;\r\n}\r\nvoid parse_checks_option(bool warn, bool error, const char *arg)\r\n{\r\nint i;\r\nconst char *name = arg;\r\nbool enable = true;\r\nif ((strncmp(arg, "no-", 3) == 0)\r\n|| (strncmp(arg, "no_", 3) == 0)) {\r\nname = arg + 3;\r\nenable = false;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(check_table); i++) {\r\nstruct check *c = check_table[i];\r\nif (streq(c->name, name)) {\r\nif (enable)\r\nenable_warning_error(c, warn, error);\r\nelse\r\ndisable_warning_error(c, warn, error);\r\nreturn;\r\n}\r\n}\r\ndie("Unrecognized check name \"%s\"\n", name);\r\n}\r\nvoid process_checks(bool force, struct dt_info *dti)\r\n{\r\nint i;\r\nint error = 0;\r\nfor (i = 0; i < ARRAY_SIZE(check_table); i++) {\r\nstruct check *c = check_table[i];\r\nif (c->warn || c->error)\r\nerror = error || run_check(c, dti);\r\n}\r\nif (error) {\r\nif (!force) {\r\nfprintf(stderr, "ERROR: Input tree has errors, aborting "\r\n"(use -f to force output)\n");\r\nexit(2);\r\n} else if (quiet < 3) {\r\nfprintf(stderr, "Warning: Input tree has errors, "\r\n"output forced\n");\r\n}\r\n}\r\n}
