static int dibx000_write_word(struct dibx000_i2c_master *mst, u16 reg, u16 val)\r\n{\r\nint ret;\r\nif (mutex_lock_interruptible(&mst->i2c_buffer_lock) < 0) {\r\ndprintk("could not acquire lock\n");\r\nreturn -EINVAL;\r\n}\r\nmst->i2c_write_buffer[0] = (reg >> 8) & 0xff;\r\nmst->i2c_write_buffer[1] = reg & 0xff;\r\nmst->i2c_write_buffer[2] = (val >> 8) & 0xff;\r\nmst->i2c_write_buffer[3] = val & 0xff;\r\nmemset(mst->msg, 0, sizeof(struct i2c_msg));\r\nmst->msg[0].addr = mst->i2c_addr;\r\nmst->msg[0].flags = 0;\r\nmst->msg[0].buf = mst->i2c_write_buffer;\r\nmst->msg[0].len = 4;\r\nret = i2c_transfer(mst->i2c_adap, mst->msg, 1) != 1 ? -EREMOTEIO : 0;\r\nmutex_unlock(&mst->i2c_buffer_lock);\r\nreturn ret;\r\n}\r\nstatic u16 dibx000_read_word(struct dibx000_i2c_master *mst, u16 reg)\r\n{\r\nu16 ret;\r\nif (mutex_lock_interruptible(&mst->i2c_buffer_lock) < 0) {\r\ndprintk("could not acquire lock\n");\r\nreturn 0;\r\n}\r\nmst->i2c_write_buffer[0] = reg >> 8;\r\nmst->i2c_write_buffer[1] = reg & 0xff;\r\nmemset(mst->msg, 0, 2 * sizeof(struct i2c_msg));\r\nmst->msg[0].addr = mst->i2c_addr;\r\nmst->msg[0].flags = 0;\r\nmst->msg[0].buf = mst->i2c_write_buffer;\r\nmst->msg[0].len = 2;\r\nmst->msg[1].addr = mst->i2c_addr;\r\nmst->msg[1].flags = I2C_M_RD;\r\nmst->msg[1].buf = mst->i2c_read_buffer;\r\nmst->msg[1].len = 2;\r\nif (i2c_transfer(mst->i2c_adap, mst->msg, 2) != 2)\r\ndprintk("i2c read error on %d\n", reg);\r\nret = (mst->i2c_read_buffer[0] << 8) | mst->i2c_read_buffer[1];\r\nmutex_unlock(&mst->i2c_buffer_lock);\r\nreturn ret;\r\n}\r\nstatic int dibx000_is_i2c_done(struct dibx000_i2c_master *mst)\r\n{\r\nint i = 100;\r\nu16 status;\r\nwhile (((status = dibx000_read_word(mst, mst->base_reg + 2)) & 0x0100) == 0 && --i > 0)\r\n;\r\nif (i == 0)\r\nreturn -EREMOTEIO;\r\nif ((status & 0x0080) == 0)\r\nreturn -EREMOTEIO;\r\nreturn 0;\r\n}\r\nstatic int dibx000_master_i2c_write(struct dibx000_i2c_master *mst, struct i2c_msg *msg, u8 stop)\r\n{\r\nu16 data;\r\nu16 da;\r\nu16 i;\r\nu16 txlen = msg->len, len;\r\nconst u8 *b = msg->buf;\r\nwhile (txlen) {\r\ndibx000_read_word(mst, mst->base_reg + 2);\r\nlen = txlen > 8 ? 8 : txlen;\r\nfor (i = 0; i < len; i += 2) {\r\ndata = *b++ << 8;\r\nif (i+1 < len)\r\ndata |= *b++;\r\ndibx000_write_word(mst, mst->base_reg, data);\r\n}\r\nda = (((u8) (msg->addr)) << 9) |\r\n(1 << 8) |\r\n(1 << 7) |\r\n(0 << 6) |\r\n(0 << 5) |\r\n((len & 0x7) << 2) |\r\n(0 << 1) |\r\n(0 << 0);\r\nif (txlen == msg->len)\r\nda |= 1 << 5;\r\nif (txlen-len == 0 && stop)\r\nda |= 1 << 6;\r\ndibx000_write_word(mst, mst->base_reg+1, da);\r\nif (dibx000_is_i2c_done(mst) != 0)\r\nreturn -EREMOTEIO;\r\ntxlen -= len;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dibx000_master_i2c_read(struct dibx000_i2c_master *mst, struct i2c_msg *msg)\r\n{\r\nu16 da;\r\nu8 *b = msg->buf;\r\nu16 rxlen = msg->len, len;\r\nwhile (rxlen) {\r\nlen = rxlen > 8 ? 8 : rxlen;\r\nda = (((u8) (msg->addr)) << 9) |\r\n(1 << 8) |\r\n(1 << 7) |\r\n(0 << 6) |\r\n(0 << 5) |\r\n((len & 0x7) << 2) |\r\n(1 << 1) |\r\n(0 << 0);\r\nif (rxlen == msg->len)\r\nda |= 1 << 5;\r\nif (rxlen-len == 0)\r\nda |= 1 << 6;\r\ndibx000_write_word(mst, mst->base_reg+1, da);\r\nif (dibx000_is_i2c_done(mst) != 0)\r\nreturn -EREMOTEIO;\r\nrxlen -= len;\r\nwhile (len) {\r\nda = dibx000_read_word(mst, mst->base_reg);\r\n*b++ = (da >> 8) & 0xff;\r\nlen--;\r\nif (len >= 1) {\r\n*b++ = da & 0xff;\r\nlen--;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint dibx000_i2c_set_speed(struct i2c_adapter *i2c_adap, u16 speed)\r\n{\r\nstruct dibx000_i2c_master *mst = i2c_get_adapdata(i2c_adap);\r\nif (mst->device_rev < DIB7000MC && speed < 235)\r\nspeed = 235;\r\nreturn dibx000_write_word(mst, mst->base_reg + 3, (u16)(60000 / speed));\r\n}\r\nstatic u32 dibx000_i2c_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nstatic int dibx000_i2c_select_interface(struct dibx000_i2c_master *mst,\r\nenum dibx000_i2c_interface intf)\r\n{\r\nif (mst->device_rev > DIB3000MC && mst->selected_interface != intf) {\r\ndprintk("selecting interface: %d\n", intf);\r\nmst->selected_interface = intf;\r\nreturn dibx000_write_word(mst, mst->base_reg + 4, intf);\r\n}\r\nreturn 0;\r\n}\r\nstatic int dibx000_i2c_master_xfer_gpio12(struct i2c_adapter *i2c_adap, struct i2c_msg msg[], int num)\r\n{\r\nstruct dibx000_i2c_master *mst = i2c_get_adapdata(i2c_adap);\r\nint msg_index;\r\nint ret = 0;\r\ndibx000_i2c_select_interface(mst, DIBX000_I2C_INTERFACE_GPIO_1_2);\r\nfor (msg_index = 0; msg_index < num; msg_index++) {\r\nif (msg[msg_index].flags & I2C_M_RD) {\r\nret = dibx000_master_i2c_read(mst, &msg[msg_index]);\r\nif (ret != 0)\r\nreturn 0;\r\n} else {\r\nret = dibx000_master_i2c_write(mst, &msg[msg_index], 1);\r\nif (ret != 0)\r\nreturn 0;\r\n}\r\n}\r\nreturn num;\r\n}\r\nstatic int dibx000_i2c_master_xfer_gpio34(struct i2c_adapter *i2c_adap, struct i2c_msg msg[], int num)\r\n{\r\nstruct dibx000_i2c_master *mst = i2c_get_adapdata(i2c_adap);\r\nint msg_index;\r\nint ret = 0;\r\ndibx000_i2c_select_interface(mst, DIBX000_I2C_INTERFACE_GPIO_3_4);\r\nfor (msg_index = 0; msg_index < num; msg_index++) {\r\nif (msg[msg_index].flags & I2C_M_RD) {\r\nret = dibx000_master_i2c_read(mst, &msg[msg_index]);\r\nif (ret != 0)\r\nreturn 0;\r\n} else {\r\nret = dibx000_master_i2c_write(mst, &msg[msg_index], 1);\r\nif (ret != 0)\r\nreturn 0;\r\n}\r\n}\r\nreturn num;\r\n}\r\nstatic int dibx000_i2c_gate_ctrl(struct dibx000_i2c_master *mst, u8 tx[4],\r\nu8 addr, int onoff)\r\n{\r\nu16 val;\r\nif (onoff)\r\nval = addr << 8;\r\nelse\r\nval = 1 << 7;\r\nif (mst->device_rev > DIB7000)\r\nval <<= 1;\r\ntx[0] = (((mst->base_reg + 1) >> 8) & 0xff);\r\ntx[1] = ((mst->base_reg + 1) & 0xff);\r\ntx[2] = val >> 8;\r\ntx[3] = val & 0xff;\r\nreturn 0;\r\n}\r\nstatic int dibx000_i2c_gated_gpio67_xfer(struct i2c_adapter *i2c_adap,\r\nstruct i2c_msg msg[], int num)\r\n{\r\nstruct dibx000_i2c_master *mst = i2c_get_adapdata(i2c_adap);\r\nint ret;\r\nif (num > 32) {\r\ndprintk("%s: too much I2C message to be transmitted (%i).\\r\nMaximum is 32", __func__, num);\r\nreturn -ENOMEM;\r\n}\r\ndibx000_i2c_select_interface(mst, DIBX000_I2C_INTERFACE_GPIO_6_7);\r\nif (mutex_lock_interruptible(&mst->i2c_buffer_lock) < 0) {\r\ndprintk("could not acquire lock\n");\r\nreturn -EINVAL;\r\n}\r\nmemset(mst->msg, 0, sizeof(struct i2c_msg) * (2 + num));\r\ndibx000_i2c_gate_ctrl(mst, &mst->i2c_write_buffer[0], msg[0].addr, 1);\r\nmst->msg[0].addr = mst->i2c_addr;\r\nmst->msg[0].buf = &mst->i2c_write_buffer[0];\r\nmst->msg[0].len = 4;\r\nmemcpy(&mst->msg[1], msg, sizeof(struct i2c_msg) * num);\r\ndibx000_i2c_gate_ctrl(mst, &mst->i2c_write_buffer[4], 0, 0);\r\nmst->msg[num + 1].addr = mst->i2c_addr;\r\nmst->msg[num + 1].buf = &mst->i2c_write_buffer[4];\r\nmst->msg[num + 1].len = 4;\r\nret = (i2c_transfer(mst->i2c_adap, mst->msg, 2 + num) == 2 + num ?\r\nnum : -EIO);\r\nmutex_unlock(&mst->i2c_buffer_lock);\r\nreturn ret;\r\n}\r\nstatic int dibx000_i2c_gated_tuner_xfer(struct i2c_adapter *i2c_adap,\r\nstruct i2c_msg msg[], int num)\r\n{\r\nstruct dibx000_i2c_master *mst = i2c_get_adapdata(i2c_adap);\r\nint ret;\r\nif (num > 32) {\r\ndprintk("%s: too much I2C message to be transmitted (%i).\\r\nMaximum is 32", __func__, num);\r\nreturn -ENOMEM;\r\n}\r\ndibx000_i2c_select_interface(mst, DIBX000_I2C_INTERFACE_TUNER);\r\nif (mutex_lock_interruptible(&mst->i2c_buffer_lock) < 0) {\r\ndprintk("could not acquire lock\n");\r\nreturn -EINVAL;\r\n}\r\nmemset(mst->msg, 0, sizeof(struct i2c_msg) * (2 + num));\r\ndibx000_i2c_gate_ctrl(mst, &mst->i2c_write_buffer[0], msg[0].addr, 1);\r\nmst->msg[0].addr = mst->i2c_addr;\r\nmst->msg[0].buf = &mst->i2c_write_buffer[0];\r\nmst->msg[0].len = 4;\r\nmemcpy(&mst->msg[1], msg, sizeof(struct i2c_msg) * num);\r\ndibx000_i2c_gate_ctrl(mst, &mst->i2c_write_buffer[4], 0, 0);\r\nmst->msg[num + 1].addr = mst->i2c_addr;\r\nmst->msg[num + 1].buf = &mst->i2c_write_buffer[4];\r\nmst->msg[num + 1].len = 4;\r\nret = (i2c_transfer(mst->i2c_adap, mst->msg, 2 + num) == 2 + num ?\r\nnum : -EIO);\r\nmutex_unlock(&mst->i2c_buffer_lock);\r\nreturn ret;\r\n}\r\nstruct i2c_adapter *dibx000_get_i2c_adapter(struct dibx000_i2c_master *mst,\r\nenum dibx000_i2c_interface intf,\r\nint gating)\r\n{\r\nstruct i2c_adapter *i2c = NULL;\r\nswitch (intf) {\r\ncase DIBX000_I2C_INTERFACE_TUNER:\r\nif (gating)\r\ni2c = &mst->gated_tuner_i2c_adap;\r\nbreak;\r\ncase DIBX000_I2C_INTERFACE_GPIO_1_2:\r\nif (!gating)\r\ni2c = &mst->master_i2c_adap_gpio12;\r\nbreak;\r\ncase DIBX000_I2C_INTERFACE_GPIO_3_4:\r\nif (!gating)\r\ni2c = &mst->master_i2c_adap_gpio34;\r\nbreak;\r\ncase DIBX000_I2C_INTERFACE_GPIO_6_7:\r\nif (gating)\r\ni2c = &mst->master_i2c_adap_gpio67;\r\nbreak;\r\ndefault:\r\npr_err("incorrect I2C interface selected\n");\r\nbreak;\r\n}\r\nreturn i2c;\r\n}\r\nvoid dibx000_reset_i2c_master(struct dibx000_i2c_master *mst)\r\n{\r\nu8 tx[4];\r\nstruct i2c_msg m = {.addr = mst->i2c_addr,.buf = tx,.len = 4 };\r\ndibx000_i2c_gate_ctrl(mst, tx, 0, 0);\r\ni2c_transfer(mst->i2c_adap, &m, 1);\r\nmst->selected_interface = 0xff;\r\ndibx000_i2c_select_interface(mst, DIBX000_I2C_INTERFACE_TUNER);\r\n}\r\nstatic int i2c_adapter_init(struct i2c_adapter *i2c_adap,\r\nstruct i2c_algorithm *algo, const char *name,\r\nstruct dibx000_i2c_master *mst)\r\n{\r\nstrncpy(i2c_adap->name, name, sizeof(i2c_adap->name));\r\ni2c_adap->algo = algo;\r\ni2c_adap->algo_data = NULL;\r\ni2c_set_adapdata(i2c_adap, mst);\r\nif (i2c_add_adapter(i2c_adap) < 0)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nint dibx000_init_i2c_master(struct dibx000_i2c_master *mst, u16 device_rev,\r\nstruct i2c_adapter *i2c_adap, u8 i2c_addr)\r\n{\r\nint ret;\r\nmutex_init(&mst->i2c_buffer_lock);\r\nif (mutex_lock_interruptible(&mst->i2c_buffer_lock) < 0) {\r\ndprintk("could not acquire lock\n");\r\nreturn -EINVAL;\r\n}\r\nmemset(mst->msg, 0, sizeof(struct i2c_msg));\r\nmst->msg[0].addr = i2c_addr >> 1;\r\nmst->msg[0].flags = 0;\r\nmst->msg[0].buf = mst->i2c_write_buffer;\r\nmst->msg[0].len = 4;\r\nmst->device_rev = device_rev;\r\nmst->i2c_adap = i2c_adap;\r\nmst->i2c_addr = i2c_addr >> 1;\r\nif (device_rev == DIB7000P || device_rev == DIB8000)\r\nmst->base_reg = 1024;\r\nelse\r\nmst->base_reg = 768;\r\nmst->gated_tuner_i2c_adap.dev.parent = mst->i2c_adap->dev.parent;\r\nif (i2c_adapter_init\r\n(&mst->gated_tuner_i2c_adap, &dibx000_i2c_gated_tuner_algo,\r\n"DiBX000 tuner I2C bus", mst) != 0)\r\npr_err("could not initialize the tuner i2c_adapter\n");\r\nmst->master_i2c_adap_gpio12.dev.parent = mst->i2c_adap->dev.parent;\r\nif (i2c_adapter_init\r\n(&mst->master_i2c_adap_gpio12, &dibx000_i2c_master_gpio12_xfer_algo,\r\n"DiBX000 master GPIO12 I2C bus", mst) != 0)\r\npr_err("could not initialize the master i2c_adapter\n");\r\nmst->master_i2c_adap_gpio34.dev.parent = mst->i2c_adap->dev.parent;\r\nif (i2c_adapter_init\r\n(&mst->master_i2c_adap_gpio34, &dibx000_i2c_master_gpio34_xfer_algo,\r\n"DiBX000 master GPIO34 I2C bus", mst) != 0)\r\npr_err("could not initialize the master i2c_adapter\n");\r\nmst->master_i2c_adap_gpio67.dev.parent = mst->i2c_adap->dev.parent;\r\nif (i2c_adapter_init\r\n(&mst->master_i2c_adap_gpio67, &dibx000_i2c_gated_gpio67_algo,\r\n"DiBX000 master GPIO67 I2C bus", mst) != 0)\r\npr_err("could not initialize the master i2c_adapter\n");\r\ndibx000_i2c_gate_ctrl(mst, mst->i2c_write_buffer, 0, 0);\r\nret = (i2c_transfer(i2c_adap, mst->msg, 1) == 1);\r\nmutex_unlock(&mst->i2c_buffer_lock);\r\nreturn ret;\r\n}\r\nvoid dibx000_exit_i2c_master(struct dibx000_i2c_master *mst)\r\n{\r\ni2c_del_adapter(&mst->gated_tuner_i2c_adap);\r\ni2c_del_adapter(&mst->master_i2c_adap_gpio12);\r\ni2c_del_adapter(&mst->master_i2c_adap_gpio34);\r\ni2c_del_adapter(&mst->master_i2c_adap_gpio67);\r\n}
