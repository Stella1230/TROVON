static int snd_bcm2835_ctl_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nif (kcontrol->private_value == PCM_PLAYBACK_VOLUME) {\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = CTRL_VOL_MIN;\r\nuinfo->value.integer.max = CTRL_VOL_MAX;\r\n} else if (kcontrol->private_value == PCM_PLAYBACK_MUTE) {\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 1;\r\n} else if (kcontrol->private_value == PCM_PLAYBACK_DEVICE) {\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = AUDIO_DEST_MAX - 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int toggle_mute(struct bcm2835_chip *chip, int nmute)\r\n{\r\nif (chip->mute == nmute)\r\nreturn 0;\r\nif (chip->mute == CTRL_VOL_MUTE) {\r\nchip->volume = chip->old_volume;\r\naudio_info("Unmuting, old_volume = %d, volume = %d ...\n", chip->old_volume, chip->volume);\r\n} else {\r\nchip->old_volume = chip->volume;\r\nchip->volume = 26214;\r\naudio_info("Muting, old_volume = %d, volume = %d ...\n", chip->old_volume, chip->volume);\r\n}\r\nchip->mute = nmute;\r\nreturn 1;\r\n}\r\nstatic int snd_bcm2835_ctl_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct bcm2835_chip *chip = snd_kcontrol_chip(kcontrol);\r\nif (mutex_lock_interruptible(&chip->audio_mutex))\r\nreturn -EINTR;\r\nBUG_ON(!chip && !(chip->avail_substreams & AVAIL_SUBSTREAMS_MASK));\r\nif (kcontrol->private_value == PCM_PLAYBACK_VOLUME)\r\nucontrol->value.integer.value[0] = chip2alsa(chip->volume);\r\nelse if (kcontrol->private_value == PCM_PLAYBACK_MUTE)\r\nucontrol->value.integer.value[0] = chip->mute;\r\nelse if (kcontrol->private_value == PCM_PLAYBACK_DEVICE)\r\nucontrol->value.integer.value[0] = chip->dest;\r\nmutex_unlock(&chip->audio_mutex);\r\nreturn 0;\r\n}\r\nstatic int snd_bcm2835_ctl_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct bcm2835_chip *chip = snd_kcontrol_chip(kcontrol);\r\nint changed = 0;\r\nif (mutex_lock_interruptible(&chip->audio_mutex))\r\nreturn -EINTR;\r\nif (kcontrol->private_value == PCM_PLAYBACK_VOLUME) {\r\naudio_info("Volume change attempted.. volume = %d new_volume = %d\n", chip->volume, (int)ucontrol->value.integer.value[0]);\r\nif (chip->mute == CTRL_VOL_MUTE) {\r\nchanged = 1;\r\ngoto unlock;\r\n}\r\nif (changed || (ucontrol->value.integer.value[0] != chip2alsa(chip->volume))) {\r\nchip->volume = alsa2chip(ucontrol->value.integer.value[0]);\r\nchanged = 1;\r\n}\r\n} else if (kcontrol->private_value == PCM_PLAYBACK_MUTE) {\r\naudio_info(" Mute attempted\n");\r\nchanged = toggle_mute(chip, ucontrol->value.integer.value[0]);\r\n} else if (kcontrol->private_value == PCM_PLAYBACK_DEVICE) {\r\nif (ucontrol->value.integer.value[0] != chip->dest) {\r\nchip->dest = ucontrol->value.integer.value[0];\r\nchanged = 1;\r\n}\r\n}\r\nif (changed && bcm2835_audio_set_ctls(chip))\r\ndev_err(chip->card->dev, "Failed to set ALSA controls..\n");\r\nunlock:\r\nmutex_unlock(&chip->audio_mutex);\r\nreturn changed;\r\n}\r\nstatic int snd_bcm2835_spdif_default_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_bcm2835_spdif_default_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct bcm2835_chip *chip = snd_kcontrol_chip(kcontrol);\r\nint i;\r\nif (mutex_lock_interruptible(&chip->audio_mutex))\r\nreturn -EINTR;\r\nfor (i = 0; i < 4; i++)\r\nucontrol->value.iec958.status[i] =\r\n(chip->spdif_status >> (i * 8)) & 0xff;\r\nmutex_unlock(&chip->audio_mutex);\r\nreturn 0;\r\n}\r\nstatic int snd_bcm2835_spdif_default_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct bcm2835_chip *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned int val = 0;\r\nint i, change;\r\nif (mutex_lock_interruptible(&chip->audio_mutex))\r\nreturn -EINTR;\r\nfor (i = 0; i < 4; i++)\r\nval |= (unsigned int)ucontrol->value.iec958.status[i] << (i * 8);\r\nchange = val != chip->spdif_status;\r\nchip->spdif_status = val;\r\nmutex_unlock(&chip->audio_mutex);\r\nreturn change;\r\n}\r\nstatic int snd_bcm2835_spdif_mask_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_bcm2835_spdif_mask_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nucontrol->value.iec958.status[0] = IEC958_AES0_NONAUDIO;\r\nreturn 0;\r\n}\r\nstatic int snd_bcm2835_spdif_stream_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_bcm2835_spdif_stream_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct bcm2835_chip *chip = snd_kcontrol_chip(kcontrol);\r\nint i;\r\nif (mutex_lock_interruptible(&chip->audio_mutex))\r\nreturn -EINTR;\r\nfor (i = 0; i < 4; i++)\r\nucontrol->value.iec958.status[i] =\r\n(chip->spdif_status >> (i * 8)) & 0xff;\r\nmutex_unlock(&chip->audio_mutex);\r\nreturn 0;\r\n}\r\nstatic int snd_bcm2835_spdif_stream_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct bcm2835_chip *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned int val = 0;\r\nint i, change;\r\nif (mutex_lock_interruptible(&chip->audio_mutex))\r\nreturn -EINTR;\r\nfor (i = 0; i < 4; i++)\r\nval |= (unsigned int)ucontrol->value.iec958.status[i] << (i * 8);\r\nchange = val != chip->spdif_status;\r\nchip->spdif_status = val;\r\nmutex_unlock(&chip->audio_mutex);\r\nreturn change;\r\n}\r\nint snd_bcm2835_new_ctl(struct bcm2835_chip *chip)\r\n{\r\nint err;\r\nunsigned int idx;\r\nstrcpy(chip->card->mixername, "Broadcom Mixer");\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_bcm2835_ctl); idx++) {\r\nerr = snd_ctl_add(chip->card,\r\nsnd_ctl_new1(&snd_bcm2835_ctl[idx], chip));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_bcm2835_spdif); idx++) {\r\nerr = snd_ctl_add(chip->card,\r\nsnd_ctl_new1(&snd_bcm2835_spdif[idx], chip));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nint snd_bcm2835_new_headphones_ctl(struct bcm2835_chip *chip)\r\n{\r\nint err;\r\nunsigned int idx;\r\nstrcpy(chip->card->mixername, "Broadcom Mixer");\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_bcm2835_headphones_ctl); idx++) {\r\nerr = snd_ctl_add(chip->card,\r\nsnd_ctl_new1(&snd_bcm2835_headphones_ctl[idx],\r\nchip));\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nint snd_bcm2835_new_hdmi_ctl(struct bcm2835_chip *chip)\r\n{\r\nint err;\r\nunsigned int idx;\r\nstrcpy(chip->card->mixername, "Broadcom Mixer");\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_bcm2835_hdmi); idx++) {\r\nerr = snd_ctl_add(chip->card,\r\nsnd_ctl_new1(&snd_bcm2835_hdmi[idx], chip));\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}
