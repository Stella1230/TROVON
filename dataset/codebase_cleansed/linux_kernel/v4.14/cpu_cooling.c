static unsigned long get_level(struct cpufreq_cooling_device *cpufreq_cdev,\r\nunsigned int freq)\r\n{\r\nstruct freq_table *freq_table = cpufreq_cdev->freq_table;\r\nunsigned long level;\r\nfor (level = 1; level <= cpufreq_cdev->max_level; level++)\r\nif (freq > freq_table[level].frequency)\r\nbreak;\r\nreturn level - 1;\r\n}\r\nstatic int cpufreq_thermal_notifier(struct notifier_block *nb,\r\nunsigned long event, void *data)\r\n{\r\nstruct cpufreq_policy *policy = data;\r\nunsigned long clipped_freq;\r\nstruct cpufreq_cooling_device *cpufreq_cdev;\r\nif (event != CPUFREQ_ADJUST)\r\nreturn NOTIFY_DONE;\r\nmutex_lock(&cooling_list_lock);\r\nlist_for_each_entry(cpufreq_cdev, &cpufreq_cdev_list, node) {\r\nif (policy->cpu != cpufreq_cdev->policy->cpu)\r\ncontinue;\r\nclipped_freq = cpufreq_cdev->clipped_freq;\r\nif (policy->max > clipped_freq)\r\ncpufreq_verify_within_limits(policy, 0, clipped_freq);\r\nbreak;\r\n}\r\nmutex_unlock(&cooling_list_lock);\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int update_freq_table(struct cpufreq_cooling_device *cpufreq_cdev,\r\nu32 capacitance)\r\n{\r\nstruct freq_table *freq_table = cpufreq_cdev->freq_table;\r\nstruct dev_pm_opp *opp;\r\nstruct device *dev = NULL;\r\nint num_opps = 0, cpu = cpufreq_cdev->policy->cpu, i;\r\ndev = get_cpu_device(cpu);\r\nif (unlikely(!dev)) {\r\ndev_warn(&cpufreq_cdev->cdev->device,\r\n"No cpu device for cpu %d\n", cpu);\r\nreturn -ENODEV;\r\n}\r\nnum_opps = dev_pm_opp_get_opp_count(dev);\r\nif (num_opps < 0)\r\nreturn num_opps;\r\nif (num_opps != cpufreq_cdev->max_level + 1) {\r\ndev_warn(dev, "Number of OPPs not matching with max_levels\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i <= cpufreq_cdev->max_level; i++) {\r\nunsigned long freq = freq_table[i].frequency * 1000;\r\nu32 freq_mhz = freq_table[i].frequency / 1000;\r\nu64 power;\r\nu32 voltage_mv;\r\nopp = dev_pm_opp_find_freq_ceil(dev, &freq);\r\nif (IS_ERR(opp)) {\r\ndev_err(dev, "failed to get opp for %lu frequency\n",\r\nfreq);\r\nreturn -EINVAL;\r\n}\r\nvoltage_mv = dev_pm_opp_get_voltage(opp) / 1000;\r\ndev_pm_opp_put(opp);\r\npower = (u64)capacitance * freq_mhz * voltage_mv * voltage_mv;\r\ndo_div(power, 1000000000);\r\nfreq_table[i].power = power;\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 cpu_freq_to_power(struct cpufreq_cooling_device *cpufreq_cdev,\r\nu32 freq)\r\n{\r\nint i;\r\nstruct freq_table *freq_table = cpufreq_cdev->freq_table;\r\nfor (i = 1; i <= cpufreq_cdev->max_level; i++)\r\nif (freq > freq_table[i].frequency)\r\nbreak;\r\nreturn freq_table[i - 1].power;\r\n}\r\nstatic u32 cpu_power_to_freq(struct cpufreq_cooling_device *cpufreq_cdev,\r\nu32 power)\r\n{\r\nint i;\r\nstruct freq_table *freq_table = cpufreq_cdev->freq_table;\r\nfor (i = 1; i <= cpufreq_cdev->max_level; i++)\r\nif (power > freq_table[i].power)\r\nbreak;\r\nreturn freq_table[i - 1].frequency;\r\n}\r\nstatic u32 get_load(struct cpufreq_cooling_device *cpufreq_cdev, int cpu,\r\nint cpu_idx)\r\n{\r\nu32 load;\r\nu64 now, now_idle, delta_time, delta_idle;\r\nstruct time_in_idle *idle_time = &cpufreq_cdev->idle_time[cpu_idx];\r\nnow_idle = get_cpu_idle_time(cpu, &now, 0);\r\ndelta_idle = now_idle - idle_time->time;\r\ndelta_time = now - idle_time->timestamp;\r\nif (delta_time <= delta_idle)\r\nload = 0;\r\nelse\r\nload = div64_u64(100 * (delta_time - delta_idle), delta_time);\r\nidle_time->time = now_idle;\r\nidle_time->timestamp = now;\r\nreturn load;\r\n}\r\nstatic int get_static_power(struct cpufreq_cooling_device *cpufreq_cdev,\r\nstruct thermal_zone_device *tz, unsigned long freq,\r\nu32 *power)\r\n{\r\nstruct dev_pm_opp *opp;\r\nunsigned long voltage;\r\nstruct cpufreq_policy *policy = cpufreq_cdev->policy;\r\nstruct cpumask *cpumask = policy->related_cpus;\r\nunsigned long freq_hz = freq * 1000;\r\nstruct device *dev;\r\nif (!cpufreq_cdev->plat_get_static_power) {\r\n*power = 0;\r\nreturn 0;\r\n}\r\ndev = get_cpu_device(policy->cpu);\r\nWARN_ON(!dev);\r\nopp = dev_pm_opp_find_freq_exact(dev, freq_hz, true);\r\nif (IS_ERR(opp)) {\r\ndev_warn_ratelimited(dev, "Failed to find OPP for frequency %lu: %ld\n",\r\nfreq_hz, PTR_ERR(opp));\r\nreturn -EINVAL;\r\n}\r\nvoltage = dev_pm_opp_get_voltage(opp);\r\ndev_pm_opp_put(opp);\r\nif (voltage == 0) {\r\ndev_err_ratelimited(dev, "Failed to get voltage for frequency %lu\n",\r\nfreq_hz);\r\nreturn -EINVAL;\r\n}\r\nreturn cpufreq_cdev->plat_get_static_power(cpumask, tz->passive_delay,\r\nvoltage, power);\r\n}\r\nstatic u32 get_dynamic_power(struct cpufreq_cooling_device *cpufreq_cdev,\r\nunsigned long freq)\r\n{\r\nu32 raw_cpu_power;\r\nraw_cpu_power = cpu_freq_to_power(cpufreq_cdev, freq);\r\nreturn (raw_cpu_power * cpufreq_cdev->last_load) / 100;\r\n}\r\nstatic int cpufreq_get_max_state(struct thermal_cooling_device *cdev,\r\nunsigned long *state)\r\n{\r\nstruct cpufreq_cooling_device *cpufreq_cdev = cdev->devdata;\r\n*state = cpufreq_cdev->max_level;\r\nreturn 0;\r\n}\r\nstatic int cpufreq_get_cur_state(struct thermal_cooling_device *cdev,\r\nunsigned long *state)\r\n{\r\nstruct cpufreq_cooling_device *cpufreq_cdev = cdev->devdata;\r\n*state = cpufreq_cdev->cpufreq_state;\r\nreturn 0;\r\n}\r\nstatic int cpufreq_set_cur_state(struct thermal_cooling_device *cdev,\r\nunsigned long state)\r\n{\r\nstruct cpufreq_cooling_device *cpufreq_cdev = cdev->devdata;\r\nunsigned int clip_freq;\r\nif (WARN_ON(state > cpufreq_cdev->max_level))\r\nreturn -EINVAL;\r\nif (cpufreq_cdev->cpufreq_state == state)\r\nreturn 0;\r\nclip_freq = cpufreq_cdev->freq_table[state].frequency;\r\ncpufreq_cdev->cpufreq_state = state;\r\ncpufreq_cdev->clipped_freq = clip_freq;\r\ncpufreq_update_policy(cpufreq_cdev->policy->cpu);\r\nreturn 0;\r\n}\r\nstatic int cpufreq_get_requested_power(struct thermal_cooling_device *cdev,\r\nstruct thermal_zone_device *tz,\r\nu32 *power)\r\n{\r\nunsigned long freq;\r\nint i = 0, cpu, ret;\r\nu32 static_power, dynamic_power, total_load = 0;\r\nstruct cpufreq_cooling_device *cpufreq_cdev = cdev->devdata;\r\nstruct cpufreq_policy *policy = cpufreq_cdev->policy;\r\nu32 *load_cpu = NULL;\r\nfreq = cpufreq_quick_get(policy->cpu);\r\nif (trace_thermal_power_cpu_get_power_enabled()) {\r\nu32 ncpus = cpumask_weight(policy->related_cpus);\r\nload_cpu = kcalloc(ncpus, sizeof(*load_cpu), GFP_KERNEL);\r\n}\r\nfor_each_cpu(cpu, policy->related_cpus) {\r\nu32 load;\r\nif (cpu_online(cpu))\r\nload = get_load(cpufreq_cdev, cpu, i);\r\nelse\r\nload = 0;\r\ntotal_load += load;\r\nif (trace_thermal_power_cpu_limit_enabled() && load_cpu)\r\nload_cpu[i] = load;\r\ni++;\r\n}\r\ncpufreq_cdev->last_load = total_load;\r\ndynamic_power = get_dynamic_power(cpufreq_cdev, freq);\r\nret = get_static_power(cpufreq_cdev, tz, freq, &static_power);\r\nif (ret) {\r\nkfree(load_cpu);\r\nreturn ret;\r\n}\r\nif (load_cpu) {\r\ntrace_thermal_power_cpu_get_power(policy->related_cpus, freq,\r\nload_cpu, i, dynamic_power,\r\nstatic_power);\r\nkfree(load_cpu);\r\n}\r\n*power = static_power + dynamic_power;\r\nreturn 0;\r\n}\r\nstatic int cpufreq_state2power(struct thermal_cooling_device *cdev,\r\nstruct thermal_zone_device *tz,\r\nunsigned long state, u32 *power)\r\n{\r\nunsigned int freq, num_cpus;\r\nu32 static_power, dynamic_power;\r\nint ret;\r\nstruct cpufreq_cooling_device *cpufreq_cdev = cdev->devdata;\r\nif (WARN_ON(state > cpufreq_cdev->max_level))\r\nreturn -EINVAL;\r\nnum_cpus = cpumask_weight(cpufreq_cdev->policy->cpus);\r\nfreq = cpufreq_cdev->freq_table[state].frequency;\r\ndynamic_power = cpu_freq_to_power(cpufreq_cdev, freq) * num_cpus;\r\nret = get_static_power(cpufreq_cdev, tz, freq, &static_power);\r\nif (ret)\r\nreturn ret;\r\n*power = static_power + dynamic_power;\r\nreturn ret;\r\n}\r\nstatic int cpufreq_power2state(struct thermal_cooling_device *cdev,\r\nstruct thermal_zone_device *tz, u32 power,\r\nunsigned long *state)\r\n{\r\nunsigned int cur_freq, target_freq;\r\nint ret;\r\ns32 dyn_power;\r\nu32 last_load, normalised_power, static_power;\r\nstruct cpufreq_cooling_device *cpufreq_cdev = cdev->devdata;\r\nstruct cpufreq_policy *policy = cpufreq_cdev->policy;\r\ncur_freq = cpufreq_quick_get(policy->cpu);\r\nret = get_static_power(cpufreq_cdev, tz, cur_freq, &static_power);\r\nif (ret)\r\nreturn ret;\r\ndyn_power = power - static_power;\r\ndyn_power = dyn_power > 0 ? dyn_power : 0;\r\nlast_load = cpufreq_cdev->last_load ?: 1;\r\nnormalised_power = (dyn_power * 100) / last_load;\r\ntarget_freq = cpu_power_to_freq(cpufreq_cdev, normalised_power);\r\n*state = get_level(cpufreq_cdev, target_freq);\r\ntrace_thermal_power_cpu_limit(policy->related_cpus, target_freq, *state,\r\npower);\r\nreturn 0;\r\n}\r\nstatic unsigned int find_next_max(struct cpufreq_frequency_table *table,\r\nunsigned int prev_max)\r\n{\r\nstruct cpufreq_frequency_table *pos;\r\nunsigned int max = 0;\r\ncpufreq_for_each_valid_entry(pos, table) {\r\nif (pos->frequency > max && pos->frequency < prev_max)\r\nmax = pos->frequency;\r\n}\r\nreturn max;\r\n}\r\nstatic struct thermal_cooling_device *\r\n__cpufreq_cooling_register(struct device_node *np,\r\nstruct cpufreq_policy *policy, u32 capacitance,\r\nget_static_t plat_static_func)\r\n{\r\nstruct thermal_cooling_device *cdev;\r\nstruct cpufreq_cooling_device *cpufreq_cdev;\r\nchar dev_name[THERMAL_NAME_LENGTH];\r\nunsigned int freq, i, num_cpus;\r\nint ret;\r\nstruct thermal_cooling_device_ops *cooling_ops;\r\nbool first;\r\nif (IS_ERR_OR_NULL(policy)) {\r\npr_err("%s: cpufreq policy isn't valid: %p", __func__, policy);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\ni = cpufreq_table_count_valid_entries(policy);\r\nif (!i) {\r\npr_debug("%s: CPUFreq table not found or has no valid entries\n",\r\n__func__);\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\ncpufreq_cdev = kzalloc(sizeof(*cpufreq_cdev), GFP_KERNEL);\r\nif (!cpufreq_cdev)\r\nreturn ERR_PTR(-ENOMEM);\r\ncpufreq_cdev->policy = policy;\r\nnum_cpus = cpumask_weight(policy->related_cpus);\r\ncpufreq_cdev->idle_time = kcalloc(num_cpus,\r\nsizeof(*cpufreq_cdev->idle_time),\r\nGFP_KERNEL);\r\nif (!cpufreq_cdev->idle_time) {\r\ncdev = ERR_PTR(-ENOMEM);\r\ngoto free_cdev;\r\n}\r\ncpufreq_cdev->max_level = i - 1;\r\ncpufreq_cdev->freq_table = kmalloc_array(i,\r\nsizeof(*cpufreq_cdev->freq_table),\r\nGFP_KERNEL);\r\nif (!cpufreq_cdev->freq_table) {\r\ncdev = ERR_PTR(-ENOMEM);\r\ngoto free_idle_time;\r\n}\r\nret = ida_simple_get(&cpufreq_ida, 0, 0, GFP_KERNEL);\r\nif (ret < 0) {\r\ncdev = ERR_PTR(ret);\r\ngoto free_table;\r\n}\r\ncpufreq_cdev->id = ret;\r\nsnprintf(dev_name, sizeof(dev_name), "thermal-cpufreq-%d",\r\ncpufreq_cdev->id);\r\nfor (i = 0, freq = -1; i <= cpufreq_cdev->max_level; i++) {\r\nfreq = find_next_max(policy->freq_table, freq);\r\ncpufreq_cdev->freq_table[i].frequency = freq;\r\nif (!freq)\r\npr_warn("%s: table has duplicate entries\n", __func__);\r\nelse\r\npr_debug("%s: freq:%u KHz\n", __func__, freq);\r\n}\r\nif (capacitance) {\r\ncpufreq_cdev->plat_get_static_power = plat_static_func;\r\nret = update_freq_table(cpufreq_cdev, capacitance);\r\nif (ret) {\r\ncdev = ERR_PTR(ret);\r\ngoto remove_ida;\r\n}\r\ncooling_ops = &cpufreq_power_cooling_ops;\r\n} else {\r\ncooling_ops = &cpufreq_cooling_ops;\r\n}\r\ncdev = thermal_of_cooling_device_register(np, dev_name, cpufreq_cdev,\r\ncooling_ops);\r\nif (IS_ERR(cdev))\r\ngoto remove_ida;\r\ncpufreq_cdev->clipped_freq = cpufreq_cdev->freq_table[0].frequency;\r\ncpufreq_cdev->cdev = cdev;\r\nmutex_lock(&cooling_list_lock);\r\nfirst = list_empty(&cpufreq_cdev_list);\r\nlist_add(&cpufreq_cdev->node, &cpufreq_cdev_list);\r\nmutex_unlock(&cooling_list_lock);\r\nif (first)\r\ncpufreq_register_notifier(&thermal_cpufreq_notifier_block,\r\nCPUFREQ_POLICY_NOTIFIER);\r\nreturn cdev;\r\nremove_ida:\r\nida_simple_remove(&cpufreq_ida, cpufreq_cdev->id);\r\nfree_table:\r\nkfree(cpufreq_cdev->freq_table);\r\nfree_idle_time:\r\nkfree(cpufreq_cdev->idle_time);\r\nfree_cdev:\r\nkfree(cpufreq_cdev);\r\nreturn cdev;\r\n}\r\nstruct thermal_cooling_device *\r\ncpufreq_cooling_register(struct cpufreq_policy *policy)\r\n{\r\nreturn __cpufreq_cooling_register(NULL, policy, 0, NULL);\r\n}\r\nstruct thermal_cooling_device *\r\nof_cpufreq_cooling_register(struct device_node *np,\r\nstruct cpufreq_policy *policy)\r\n{\r\nif (!np)\r\nreturn ERR_PTR(-EINVAL);\r\nreturn __cpufreq_cooling_register(np, policy, 0, NULL);\r\n}\r\nstruct thermal_cooling_device *\r\ncpufreq_power_cooling_register(struct cpufreq_policy *policy, u32 capacitance,\r\nget_static_t plat_static_func)\r\n{\r\nreturn __cpufreq_cooling_register(NULL, policy, capacitance,\r\nplat_static_func);\r\n}\r\nstruct thermal_cooling_device *\r\nof_cpufreq_power_cooling_register(struct device_node *np,\r\nstruct cpufreq_policy *policy,\r\nu32 capacitance,\r\nget_static_t plat_static_func)\r\n{\r\nif (!np)\r\nreturn ERR_PTR(-EINVAL);\r\nreturn __cpufreq_cooling_register(np, policy, capacitance,\r\nplat_static_func);\r\n}\r\nvoid cpufreq_cooling_unregister(struct thermal_cooling_device *cdev)\r\n{\r\nstruct cpufreq_cooling_device *cpufreq_cdev;\r\nbool last;\r\nif (!cdev)\r\nreturn;\r\ncpufreq_cdev = cdev->devdata;\r\nmutex_lock(&cooling_list_lock);\r\nlist_del(&cpufreq_cdev->node);\r\nlast = list_empty(&cpufreq_cdev_list);\r\nmutex_unlock(&cooling_list_lock);\r\nif (last)\r\ncpufreq_unregister_notifier(&thermal_cpufreq_notifier_block,\r\nCPUFREQ_POLICY_NOTIFIER);\r\nthermal_cooling_device_unregister(cpufreq_cdev->cdev);\r\nida_simple_remove(&cpufreq_ida, cpufreq_cdev->id);\r\nkfree(cpufreq_cdev->idle_time);\r\nkfree(cpufreq_cdev->freq_table);\r\nkfree(cpufreq_cdev);\r\n}
