static bool asus_q500a_i8042_filter(unsigned char data, unsigned char str,\r\nstruct serio *port)\r\n{\r\nstatic bool extended;\r\nbool ret = false;\r\nif (str & I8042_STR_AUXDATA)\r\nreturn false;\r\nif (unlikely(data == 0xe1)) {\r\nextended = true;\r\nret = true;\r\n} else if (unlikely(extended)) {\r\nextended = false;\r\nret = true;\r\n}\r\nreturn ret;\r\n}\r\nstatic int dmi_matched(const struct dmi_system_id *dmi)\r\n{\r\npr_info("Identified laptop model '%s'\n", dmi->ident);\r\nquirks = dmi->driver_data;\r\nreturn 1;\r\n}\r\nstatic void asus_nb_wmi_quirks(struct asus_wmi_driver *driver)\r\n{\r\nint ret;\r\nquirks = &quirk_asus_unknown;\r\ndmi_check_system(asus_quirks);\r\ndriver->quirks = quirks;\r\ndriver->panel_power = FB_BLANK_UNBLANK;\r\nif (wapf != -1)\r\nquirks->wapf = wapf;\r\nelse\r\nwapf = quirks->wapf;\r\nif (quirks->i8042_filter) {\r\nret = i8042_install_filter(quirks->i8042_filter);\r\nif (ret) {\r\npr_warn("Unable to install key filter\n");\r\nreturn;\r\n}\r\npr_info("Using i8042 filter function for receiving events\n");\r\n}\r\n}\r\nstatic int __init asus_nb_wmi_init(void)\r\n{\r\nreturn asus_wmi_register_driver(&asus_nb_wmi_driver);\r\n}\r\nstatic void __exit asus_nb_wmi_exit(void)\r\n{\r\nasus_wmi_unregister_driver(&asus_nb_wmi_driver);\r\n}
