static u32 mpc52xx_can_get_clock(struct platform_device *ofdev,\r\nconst char *clock_name, int *mscan_clksrc)\r\n{\r\nunsigned int pvr;\r\nstruct mpc52xx_cdm __iomem *cdm;\r\nstruct device_node *np_cdm;\r\nunsigned int freq;\r\nu32 val;\r\npvr = mfspr(SPRN_PVR);\r\nif (clock_name && strcmp(clock_name, "ip") == 0)\r\n*mscan_clksrc = MSCAN_CLKSRC_BUS;\r\nelse\r\n*mscan_clksrc = MSCAN_CLKSRC_XTAL;\r\nfreq = mpc5xxx_get_bus_frequency(ofdev->dev.of_node);\r\nif (!freq)\r\nreturn 0;\r\nif (*mscan_clksrc == MSCAN_CLKSRC_BUS || pvr == 0x80822011)\r\nreturn freq;\r\nnp_cdm = of_find_matching_node(NULL, mpc52xx_cdm_ids);\r\nif (!np_cdm) {\r\ndev_err(&ofdev->dev, "can't get clock node!\n");\r\nreturn 0;\r\n}\r\ncdm = of_iomap(np_cdm, 0);\r\nif (in_8(&cdm->ipb_clk_sel) & 0x1)\r\nfreq *= 2;\r\nval = in_be32(&cdm->rstcfg);\r\nfreq *= (val & (1 << 5)) ? 8 : 4;\r\nfreq /= (val & (1 << 6)) ? 12 : 16;\r\nof_node_put(np_cdm);\r\niounmap(cdm);\r\nreturn freq;\r\n}\r\nstatic u32 mpc52xx_can_get_clock(struct platform_device *ofdev,\r\nconst char *clock_name, int *mscan_clksrc)\r\n{\r\nreturn 0;\r\n}\r\nstatic u32 mpc512x_can_get_clock(struct platform_device *ofdev,\r\nconst char *clock_source, int *mscan_clksrc)\r\n{\r\nstruct device_node *np;\r\nu32 clockdiv;\r\nenum {\r\nCLK_FROM_AUTO,\r\nCLK_FROM_IPS,\r\nCLK_FROM_SYS,\r\nCLK_FROM_REF,\r\n} clk_from;\r\nstruct clk *clk_in, *clk_can;\r\nunsigned long freq_calc;\r\nstruct mscan_priv *priv;\r\nstruct clk *clk_ipg;\r\nnp = ofdev->dev.of_node;\r\nclockdiv = 1;\r\nof_property_read_u32(np, "fsl,mscan-clock-divider", &clockdiv);\r\ndev_dbg(&ofdev->dev, "device tree specs: clk src[%s] div[%d]\n",\r\nclock_source ? clock_source : "<NULL>", clockdiv);\r\nclk_from = CLK_FROM_AUTO;\r\nif (clock_source) {\r\nif (!strcmp(clock_source, "ip"))\r\nclk_from = CLK_FROM_IPS;\r\nelse if (!strcmp(clock_source, "sys"))\r\nclk_from = CLK_FROM_SYS;\r\nelse if (!strcmp(clock_source, "ref"))\r\nclk_from = CLK_FROM_REF;\r\nelse\r\ngoto err_invalid;\r\ndev_dbg(&ofdev->dev, "got a clk source spec[%d]\n", clk_from);\r\n}\r\nif (clk_from == CLK_FROM_AUTO) {\r\ndev_dbg(&ofdev->dev, "no clk source spec, trying SYS\n");\r\nclk_in = devm_clk_get(&ofdev->dev, "sys");\r\nif (IS_ERR(clk_in))\r\ngoto err_notavail;\r\nfreq_calc = clk_get_rate(clk_in);\r\nfreq_calc += 499999;\r\nfreq_calc /= 1000000;\r\nfreq_calc *= 1000000;\r\nif ((freq_calc % 16000000) == 0) {\r\nclk_from = CLK_FROM_SYS;\r\nclockdiv = freq_calc / 16000000;\r\ndev_dbg(&ofdev->dev,\r\n"clk fit, sys[%lu] div[%d] freq[%lu]\n",\r\nfreq_calc, clockdiv, freq_calc / clockdiv);\r\n}\r\n}\r\nif (clk_from == CLK_FROM_AUTO) {\r\ndev_dbg(&ofdev->dev, "no clk source spec, trying REF\n");\r\nclk_in = devm_clk_get(&ofdev->dev, "ref");\r\nif (IS_ERR(clk_in))\r\ngoto err_notavail;\r\nclk_from = CLK_FROM_REF;\r\nfreq_calc = clk_get_rate(clk_in);\r\ndev_dbg(&ofdev->dev,\r\n"clk fit, ref[%lu] (no div) freq[%lu]\n",\r\nfreq_calc, freq_calc);\r\n}\r\nswitch (clk_from) {\r\ncase CLK_FROM_IPS:\r\nclk_can = devm_clk_get(&ofdev->dev, "ips");\r\nif (IS_ERR(clk_can))\r\ngoto err_notavail;\r\npriv = netdev_priv(dev_get_drvdata(&ofdev->dev));\r\npriv->clk_can = clk_can;\r\nfreq_calc = clk_get_rate(clk_can);\r\n*mscan_clksrc = MSCAN_CLKSRC_IPS;\r\ndev_dbg(&ofdev->dev, "clk from IPS, clksrc[%d] freq[%lu]\n",\r\n*mscan_clksrc, freq_calc);\r\nbreak;\r\ncase CLK_FROM_SYS:\r\ncase CLK_FROM_REF:\r\nclk_can = devm_clk_get(&ofdev->dev, "mclk");\r\nif (IS_ERR(clk_can))\r\ngoto err_notavail;\r\npriv = netdev_priv(dev_get_drvdata(&ofdev->dev));\r\npriv->clk_can = clk_can;\r\nif (clk_from == CLK_FROM_SYS)\r\nclk_in = devm_clk_get(&ofdev->dev, "sys");\r\nif (clk_from == CLK_FROM_REF)\r\nclk_in = devm_clk_get(&ofdev->dev, "ref");\r\nif (IS_ERR(clk_in))\r\ngoto err_notavail;\r\nclk_set_parent(clk_can, clk_in);\r\nfreq_calc = clk_get_rate(clk_in);\r\nfreq_calc /= clockdiv;\r\nclk_set_rate(clk_can, freq_calc);\r\nfreq_calc = clk_get_rate(clk_can);\r\n*mscan_clksrc = MSCAN_CLKSRC_BUS;\r\ndev_dbg(&ofdev->dev, "clk from MCLK, clksrc[%d] freq[%lu]\n",\r\n*mscan_clksrc, freq_calc);\r\nbreak;\r\ndefault:\r\ngoto err_invalid;\r\n}\r\nclk_ipg = devm_clk_get(&ofdev->dev, "ipg");\r\nif (IS_ERR(clk_ipg))\r\ngoto err_notavail_ipg;\r\nif (clk_prepare_enable(clk_ipg))\r\ngoto err_notavail_ipg;\r\npriv = netdev_priv(dev_get_drvdata(&ofdev->dev));\r\npriv->clk_ipg = clk_ipg;\r\nreturn freq_calc;\r\nerr_invalid:\r\ndev_err(&ofdev->dev, "invalid clock source specification\n");\r\nreturn 0;\r\nerr_notavail:\r\ndev_err(&ofdev->dev, "cannot acquire or setup bitrate clock source\n");\r\nreturn 0;\r\nerr_notavail_ipg:\r\ndev_err(&ofdev->dev, "cannot acquire or setup register clock\n");\r\nreturn 0;\r\n}\r\nstatic void mpc512x_can_put_clock(struct platform_device *ofdev)\r\n{\r\nstruct mscan_priv *priv;\r\npriv = netdev_priv(dev_get_drvdata(&ofdev->dev));\r\nif (priv->clk_ipg)\r\nclk_disable_unprepare(priv->clk_ipg);\r\n}\r\nstatic u32 mpc512x_can_get_clock(struct platform_device *ofdev,\r\nconst char *clock_name, int *mscan_clksrc)\r\n{\r\nreturn 0;\r\n}\r\nstatic int mpc5xxx_can_probe(struct platform_device *ofdev)\r\n{\r\nconst struct of_device_id *match;\r\nconst struct mpc5xxx_can_data *data;\r\nstruct device_node *np = ofdev->dev.of_node;\r\nstruct net_device *dev;\r\nstruct mscan_priv *priv;\r\nvoid __iomem *base;\r\nconst char *clock_name = NULL;\r\nint irq, mscan_clksrc = 0;\r\nint err = -ENOMEM;\r\nmatch = of_match_device(mpc5xxx_can_table, &ofdev->dev);\r\nif (!match)\r\nreturn -EINVAL;\r\ndata = match->data;\r\nbase = of_iomap(np, 0);\r\nif (!base) {\r\ndev_err(&ofdev->dev, "couldn't ioremap\n");\r\nreturn err;\r\n}\r\nirq = irq_of_parse_and_map(np, 0);\r\nif (!irq) {\r\ndev_err(&ofdev->dev, "no irq found\n");\r\nerr = -ENODEV;\r\ngoto exit_unmap_mem;\r\n}\r\ndev = alloc_mscandev();\r\nif (!dev)\r\ngoto exit_dispose_irq;\r\nplatform_set_drvdata(ofdev, dev);\r\nSET_NETDEV_DEV(dev, &ofdev->dev);\r\npriv = netdev_priv(dev);\r\npriv->reg_base = base;\r\ndev->irq = irq;\r\nclock_name = of_get_property(np, "fsl,mscan-clock-source", NULL);\r\nBUG_ON(!data);\r\npriv->type = data->type;\r\npriv->can.clock.freq = data->get_clock(ofdev, clock_name,\r\n&mscan_clksrc);\r\nif (!priv->can.clock.freq) {\r\ndev_err(&ofdev->dev, "couldn't get MSCAN clock properties\n");\r\ngoto exit_free_mscan;\r\n}\r\nerr = register_mscandev(dev, mscan_clksrc);\r\nif (err) {\r\ndev_err(&ofdev->dev, "registering %s failed (err=%d)\n",\r\nDRV_NAME, err);\r\ngoto exit_free_mscan;\r\n}\r\ndev_info(&ofdev->dev, "MSCAN at 0x%p, irq %d, clock %d Hz\n",\r\npriv->reg_base, dev->irq, priv->can.clock.freq);\r\nreturn 0;\r\nexit_free_mscan:\r\nfree_candev(dev);\r\nexit_dispose_irq:\r\nirq_dispose_mapping(irq);\r\nexit_unmap_mem:\r\niounmap(base);\r\nreturn err;\r\n}\r\nstatic int mpc5xxx_can_remove(struct platform_device *ofdev)\r\n{\r\nconst struct of_device_id *match;\r\nconst struct mpc5xxx_can_data *data;\r\nstruct net_device *dev = platform_get_drvdata(ofdev);\r\nstruct mscan_priv *priv = netdev_priv(dev);\r\nmatch = of_match_device(mpc5xxx_can_table, &ofdev->dev);\r\ndata = match ? match->data : NULL;\r\nunregister_mscandev(dev);\r\nif (data && data->put_clock)\r\ndata->put_clock(ofdev);\r\niounmap(priv->reg_base);\r\nirq_dispose_mapping(dev->irq);\r\nfree_candev(dev);\r\nreturn 0;\r\n}\r\nstatic int mpc5xxx_can_suspend(struct platform_device *ofdev, pm_message_t state)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(ofdev);\r\nstruct mscan_priv *priv = netdev_priv(dev);\r\nstruct mscan_regs *regs = (struct mscan_regs *)priv->reg_base;\r\n_memcpy_fromio(&saved_regs, regs, sizeof(*regs));\r\nreturn 0;\r\n}\r\nstatic int mpc5xxx_can_resume(struct platform_device *ofdev)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(ofdev);\r\nstruct mscan_priv *priv = netdev_priv(dev);\r\nstruct mscan_regs *regs = (struct mscan_regs *)priv->reg_base;\r\nregs->canctl0 |= MSCAN_INITRQ;\r\nwhile (!(regs->canctl1 & MSCAN_INITAK))\r\nudelay(10);\r\nregs->canctl1 = saved_regs.canctl1;\r\nregs->canbtr0 = saved_regs.canbtr0;\r\nregs->canbtr1 = saved_regs.canbtr1;\r\nregs->canidac = saved_regs.canidac;\r\n_memcpy_toio(&regs->canidar1_0, (void *)&saved_regs.canidar1_0,\r\nsizeof(*regs) - offsetof(struct mscan_regs, canidar1_0));\r\nregs->canctl0 &= ~MSCAN_INITRQ;\r\nregs->cantbsel = saved_regs.cantbsel;\r\nregs->canrier = saved_regs.canrier;\r\nregs->cantier = saved_regs.cantier;\r\nregs->canctl0 = saved_regs.canctl0;\r\nreturn 0;\r\n}
