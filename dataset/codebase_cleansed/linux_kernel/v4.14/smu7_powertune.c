static int smu7_enable_didt(struct pp_hwmgr *hwmgr, const bool enable)\r\n{\r\nuint32_t en = enable ? 1 : 0;\r\nuint32_t block_en = 0;\r\nint32_t result = 0;\r\nuint32_t didt_block;\r\nuint32_t data;\r\nif (hwmgr->chip_id == CHIP_POLARIS11)\r\ndidt_block = Polaris11_DIDTBlock_Info;\r\nelse\r\ndidt_block = DIDTBlock_Info;\r\nblock_en = phm_cap_enabled(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_SQRamping) ? en : 0;\r\ndata = cgs_read_ind_register(hwmgr->device, CGS_IND_REG__DIDT, ixDIDT_SQ_CTRL0);\r\ndata &= ~DIDT_SQ_CTRL0__DIDT_CTRL_EN_MASK;\r\ndata |= ((block_en << DIDT_SQ_CTRL0__DIDT_CTRL_EN__SHIFT) & DIDT_SQ_CTRL0__DIDT_CTRL_EN_MASK);\r\ncgs_write_ind_register(hwmgr->device, CGS_IND_REG__DIDT, ixDIDT_SQ_CTRL0, data);\r\ndidt_block &= ~SQ_Enable_MASK;\r\ndidt_block |= block_en << SQ_Enable_SHIFT;\r\nblock_en = phm_cap_enabled(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_DBRamping) ? en : 0;\r\ndata = cgs_read_ind_register(hwmgr->device, CGS_IND_REG__DIDT, ixDIDT_DB_CTRL0);\r\ndata &= ~DIDT_DB_CTRL0__DIDT_CTRL_EN_MASK;\r\ndata |= ((block_en << DIDT_DB_CTRL0__DIDT_CTRL_EN__SHIFT) & DIDT_DB_CTRL0__DIDT_CTRL_EN_MASK);\r\ncgs_write_ind_register(hwmgr->device, CGS_IND_REG__DIDT, ixDIDT_DB_CTRL0, data);\r\ndidt_block &= ~DB_Enable_MASK;\r\ndidt_block |= block_en << DB_Enable_SHIFT;\r\nblock_en = phm_cap_enabled(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_TDRamping) ? en : 0;\r\ndata = cgs_read_ind_register(hwmgr->device, CGS_IND_REG__DIDT, ixDIDT_TD_CTRL0);\r\ndata &= ~DIDT_TD_CTRL0__DIDT_CTRL_EN_MASK;\r\ndata |= ((block_en << DIDT_TD_CTRL0__DIDT_CTRL_EN__SHIFT) & DIDT_TD_CTRL0__DIDT_CTRL_EN_MASK);\r\ncgs_write_ind_register(hwmgr->device, CGS_IND_REG__DIDT, ixDIDT_TD_CTRL0, data);\r\ndidt_block &= ~TD_Enable_MASK;\r\ndidt_block |= block_en << TD_Enable_SHIFT;\r\nblock_en = phm_cap_enabled(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_TCPRamping) ? en : 0;\r\ndata = cgs_read_ind_register(hwmgr->device, CGS_IND_REG__DIDT, ixDIDT_TCP_CTRL0);\r\ndata &= ~DIDT_TCP_CTRL0__DIDT_CTRL_EN_MASK;\r\ndata |= ((block_en << DIDT_TCP_CTRL0__DIDT_CTRL_EN__SHIFT) & DIDT_TCP_CTRL0__DIDT_CTRL_EN_MASK);\r\ncgs_write_ind_register(hwmgr->device, CGS_IND_REG__DIDT, ixDIDT_TCP_CTRL0, data);\r\ndidt_block &= ~TCP_Enable_MASK;\r\ndidt_block |= block_en << TCP_Enable_SHIFT;\r\nif (enable)\r\nresult = smum_send_msg_to_smc_with_parameter(hwmgr->smumgr, PPSMC_MSG_Didt_Block_Function, didt_block);\r\nreturn result;\r\n}\r\nstatic int smu7_program_pt_config_registers(struct pp_hwmgr *hwmgr,\r\nconst struct gpu_pt_config_reg *cac_config_regs)\r\n{\r\nconst struct gpu_pt_config_reg *config_regs = cac_config_regs;\r\nuint32_t cache = 0;\r\nuint32_t data = 0;\r\nPP_ASSERT_WITH_CODE((config_regs != NULL), "Invalid config register table.", return -EINVAL);\r\nwhile (config_regs->offset != 0xFFFFFFFF) {\r\nif (config_regs->type == GPU_CONFIGREG_CACHE)\r\ncache |= ((config_regs->value << config_regs->shift) & config_regs->mask);\r\nelse {\r\nswitch (config_regs->type) {\r\ncase GPU_CONFIGREG_SMC_IND:\r\ndata = cgs_read_ind_register(hwmgr->device, CGS_IND_REG__SMC, config_regs->offset);\r\nbreak;\r\ncase GPU_CONFIGREG_DIDT_IND:\r\ndata = cgs_read_ind_register(hwmgr->device, CGS_IND_REG__DIDT, config_regs->offset);\r\nbreak;\r\ncase GPU_CONFIGREG_GC_CAC_IND:\r\ndata = cgs_read_ind_register(hwmgr->device, CGS_IND_REG_GC_CAC, config_regs->offset);\r\nbreak;\r\ndefault:\r\ndata = cgs_read_register(hwmgr->device, config_regs->offset);\r\nbreak;\r\n}\r\ndata &= ~config_regs->mask;\r\ndata |= ((config_regs->value << config_regs->shift) & config_regs->mask);\r\ndata |= cache;\r\nswitch (config_regs->type) {\r\ncase GPU_CONFIGREG_SMC_IND:\r\ncgs_write_ind_register(hwmgr->device, CGS_IND_REG__SMC, config_regs->offset, data);\r\nbreak;\r\ncase GPU_CONFIGREG_DIDT_IND:\r\ncgs_write_ind_register(hwmgr->device, CGS_IND_REG__DIDT, config_regs->offset, data);\r\nbreak;\r\ncase GPU_CONFIGREG_GC_CAC_IND:\r\ncgs_write_ind_register(hwmgr->device, CGS_IND_REG_GC_CAC, config_regs->offset, data);\r\nbreak;\r\ndefault:\r\ncgs_write_register(hwmgr->device, config_regs->offset, data);\r\nbreak;\r\n}\r\ncache = 0;\r\n}\r\nconfig_regs++;\r\n}\r\nreturn 0;\r\n}\r\nint smu7_enable_didt_config(struct pp_hwmgr *hwmgr)\r\n{\r\nint result;\r\nuint32_t num_se = 0;\r\nuint32_t count, value, value2;\r\nstruct cgs_system_info sys_info = {0};\r\nsys_info.size = sizeof(struct cgs_system_info);\r\nsys_info.info_id = CGS_SYSTEM_INFO_GFX_SE_INFO;\r\nresult = cgs_query_system_info(hwmgr->device, &sys_info);\r\nif (result == 0)\r\nnum_se = sys_info.value;\r\nif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_SQRamping) ||\r\nphm_cap_enabled(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_DBRamping) ||\r\nphm_cap_enabled(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_TDRamping) ||\r\nphm_cap_enabled(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_TCPRamping)) {\r\ncgs_enter_safe_mode(hwmgr->device, true);\r\nvalue = 0;\r\nvalue2 = cgs_read_register(hwmgr->device, mmGRBM_GFX_INDEX);\r\nfor (count = 0; count < num_se; count++) {\r\nvalue = SYS_GRBM_GFX_INDEX_DATA__INSTANCE_BROADCAST_WRITES_MASK\r\n| SYS_GRBM_GFX_INDEX_DATA__SH_BROADCAST_WRITES_MASK\r\n| (count << SYS_GRBM_GFX_INDEX_DATA__SE_INDEX__SHIFT);\r\ncgs_write_register(hwmgr->device, mmGRBM_GFX_INDEX, value);\r\nif (hwmgr->chip_id == CHIP_POLARIS10) {\r\nresult = smu7_program_pt_config_registers(hwmgr, GCCACConfig_Polaris10);\r\nPP_ASSERT_WITH_CODE((result == 0), "DIDT Config failed.", return result);\r\nresult = smu7_program_pt_config_registers(hwmgr, DIDTConfig_Polaris10);\r\nPP_ASSERT_WITH_CODE((result == 0), "DIDT Config failed.", return result);\r\n} else if (hwmgr->chip_id == CHIP_POLARIS11) {\r\nresult = smu7_program_pt_config_registers(hwmgr, GCCACConfig_Polaris11);\r\nPP_ASSERT_WITH_CODE((result == 0), "DIDT Config failed.", return result);\r\nif (hwmgr->smumgr->is_kicker)\r\nresult = smu7_program_pt_config_registers(hwmgr, DIDTConfig_Polaris11_Kicker);\r\nelse\r\nresult = smu7_program_pt_config_registers(hwmgr, DIDTConfig_Polaris11);\r\nPP_ASSERT_WITH_CODE((result == 0), "DIDT Config failed.", return result);\r\n} else if (hwmgr->chip_id == CHIP_POLARIS12) {\r\nresult = smu7_program_pt_config_registers(hwmgr, GCCACConfig_Polaris11);\r\nPP_ASSERT_WITH_CODE((result == 0), "DIDT Config failed.", return result);\r\nresult = smu7_program_pt_config_registers(hwmgr, DIDTConfig_Polaris12);\r\nPP_ASSERT_WITH_CODE((result == 0), "DIDT Config failed.", return result);\r\n}\r\n}\r\ncgs_write_register(hwmgr->device, mmGRBM_GFX_INDEX, value2);\r\nresult = smu7_enable_didt(hwmgr, true);\r\nPP_ASSERT_WITH_CODE((result == 0), "EnableDiDt failed.", return result);\r\nif (hwmgr->chip_id == CHIP_POLARIS11) {\r\nresult = smum_send_msg_to_smc(hwmgr->smumgr,\r\n(uint16_t)(PPSMC_MSG_EnableDpmDidt));\r\nPP_ASSERT_WITH_CODE((0 == result),\r\n"Failed to enable DPM DIDT.", return result);\r\n}\r\ncgs_enter_safe_mode(hwmgr->device, false);\r\n}\r\nreturn 0;\r\n}\r\nint smu7_disable_didt_config(struct pp_hwmgr *hwmgr)\r\n{\r\nint result;\r\nif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_SQRamping) ||\r\nphm_cap_enabled(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_DBRamping) ||\r\nphm_cap_enabled(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_TDRamping) ||\r\nphm_cap_enabled(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_TCPRamping)) {\r\ncgs_enter_safe_mode(hwmgr->device, true);\r\nresult = smu7_enable_didt(hwmgr, false);\r\nPP_ASSERT_WITH_CODE((result == 0),\r\n"Post DIDT enable clock gating failed.",\r\nreturn result);\r\nif (hwmgr->chip_id == CHIP_POLARIS11) {\r\nresult = smum_send_msg_to_smc(hwmgr->smumgr,\r\n(uint16_t)(PPSMC_MSG_DisableDpmDidt));\r\nPP_ASSERT_WITH_CODE((0 == result),\r\n"Failed to disable DPM DIDT.", return result);\r\n}\r\ncgs_enter_safe_mode(hwmgr->device, false);\r\n}\r\nreturn 0;\r\n}\r\nint smu7_enable_smc_cac(struct pp_hwmgr *hwmgr)\r\n{\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nint result = 0;\r\nif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_CAC)) {\r\nint smc_result;\r\nsmc_result = smum_send_msg_to_smc(hwmgr->smumgr,\r\n(uint16_t)(PPSMC_MSG_EnableCac));\r\nPP_ASSERT_WITH_CODE((0 == smc_result),\r\n"Failed to enable CAC in SMC.", result = -1);\r\ndata->cac_enabled = (0 == smc_result) ? true : false;\r\n}\r\nreturn result;\r\n}\r\nint smu7_disable_smc_cac(struct pp_hwmgr *hwmgr)\r\n{\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nint result = 0;\r\nif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_CAC) && data->cac_enabled) {\r\nint smc_result = smum_send_msg_to_smc(hwmgr->smumgr,\r\n(uint16_t)(PPSMC_MSG_DisableCac));\r\nPP_ASSERT_WITH_CODE((smc_result == 0),\r\n"Failed to disable CAC in SMC.", result = -1);\r\ndata->cac_enabled = false;\r\n}\r\nreturn result;\r\n}\r\nint smu7_set_power_limit(struct pp_hwmgr *hwmgr, uint32_t n)\r\n{\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nif (data->power_containment_features &\r\nPOWERCONTAINMENT_FEATURE_PkgPwrLimit)\r\nreturn smum_send_msg_to_smc_with_parameter(hwmgr->smumgr,\r\nPPSMC_MSG_PkgPwrSetLimit, n);\r\nreturn 0;\r\n}\r\nstatic int smu7_set_overdriver_target_tdp(struct pp_hwmgr *hwmgr,\r\nuint32_t target_tdp)\r\n{\r\nreturn smum_send_msg_to_smc_with_parameter(hwmgr->smumgr,\r\nPPSMC_MSG_OverDriveSetTargetTdp, target_tdp);\r\n}\r\nint smu7_enable_power_containment(struct pp_hwmgr *hwmgr)\r\n{\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nstruct phm_ppt_v1_information *table_info =\r\n(struct phm_ppt_v1_information *)(hwmgr->pptable);\r\nint smc_result;\r\nint result = 0;\r\nstruct phm_cac_tdp_table *cac_table;\r\ndata->power_containment_features = 0;\r\nif (hwmgr->pp_table_version == PP_TABLE_V1)\r\ncac_table = table_info->cac_dtp_table;\r\nelse\r\ncac_table = hwmgr->dyn_state.cac_dtp_table;\r\nif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_PowerContainment)) {\r\nif (data->enable_tdc_limit_feature) {\r\nsmc_result = smum_send_msg_to_smc(hwmgr->smumgr,\r\n(uint16_t)(PPSMC_MSG_TDCLimitEnable));\r\nPP_ASSERT_WITH_CODE((0 == smc_result),\r\n"Failed to enable TDCLimit in SMC.", result = -1;);\r\nif (0 == smc_result)\r\ndata->power_containment_features |=\r\nPOWERCONTAINMENT_FEATURE_TDCLimit;\r\n}\r\nif (data->enable_pkg_pwr_tracking_feature) {\r\nsmc_result = smum_send_msg_to_smc(hwmgr->smumgr,\r\n(uint16_t)(PPSMC_MSG_PkgPwrLimitEnable));\r\nPP_ASSERT_WITH_CODE((0 == smc_result),\r\n"Failed to enable PkgPwrTracking in SMC.", result = -1;);\r\nif (0 == smc_result) {\r\nuint32_t default_limit =\r\n(uint32_t)(cac_table->usMaximumPowerDeliveryLimit * 256);\r\ndata->power_containment_features |=\r\nPOWERCONTAINMENT_FEATURE_PkgPwrLimit;\r\nif (smu7_set_power_limit(hwmgr, default_limit))\r\npr_err("Failed to set Default Power Limit in SMC!");\r\n}\r\n}\r\n}\r\nreturn result;\r\n}\r\nint smu7_disable_power_containment(struct pp_hwmgr *hwmgr)\r\n{\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nint result = 0;\r\nif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_PowerContainment) &&\r\ndata->power_containment_features) {\r\nint smc_result;\r\nif (data->power_containment_features &\r\nPOWERCONTAINMENT_FEATURE_TDCLimit) {\r\nsmc_result = smum_send_msg_to_smc(hwmgr->smumgr,\r\n(uint16_t)(PPSMC_MSG_TDCLimitDisable));\r\nPP_ASSERT_WITH_CODE((smc_result == 0),\r\n"Failed to disable TDCLimit in SMC.",\r\nresult = smc_result);\r\n}\r\nif (data->power_containment_features &\r\nPOWERCONTAINMENT_FEATURE_DTE) {\r\nsmc_result = smum_send_msg_to_smc(hwmgr->smumgr,\r\n(uint16_t)(PPSMC_MSG_DisableDTE));\r\nPP_ASSERT_WITH_CODE((smc_result == 0),\r\n"Failed to disable DTE in SMC.",\r\nresult = smc_result);\r\n}\r\nif (data->power_containment_features &\r\nPOWERCONTAINMENT_FEATURE_PkgPwrLimit) {\r\nsmc_result = smum_send_msg_to_smc(hwmgr->smumgr,\r\n(uint16_t)(PPSMC_MSG_PkgPwrLimitDisable));\r\nPP_ASSERT_WITH_CODE((smc_result == 0),\r\n"Failed to disable PkgPwrTracking in SMC.",\r\nresult = smc_result);\r\n}\r\ndata->power_containment_features = 0;\r\n}\r\nreturn result;\r\n}\r\nint smu7_power_control_set_level(struct pp_hwmgr *hwmgr)\r\n{\r\nstruct phm_ppt_v1_information *table_info =\r\n(struct phm_ppt_v1_information *)(hwmgr->pptable);\r\nstruct phm_cac_tdp_table *cac_table;\r\nint adjust_percent, target_tdp;\r\nint result = 0;\r\nif (hwmgr->pp_table_version == PP_TABLE_V1)\r\ncac_table = table_info->cac_dtp_table;\r\nelse\r\ncac_table = hwmgr->dyn_state.cac_dtp_table;\r\nif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_PowerContainment)) {\r\nadjust_percent = hwmgr->platform_descriptor.TDPAdjustmentPolarity ?\r\nhwmgr->platform_descriptor.TDPAdjustment :\r\n(-1 * hwmgr->platform_descriptor.TDPAdjustment);\r\ntarget_tdp = ((100 + adjust_percent) * (int)(cac_table->usTDP * 256)) / 100;\r\nresult = smu7_set_overdriver_target_tdp(hwmgr, (uint32_t)target_tdp);\r\n}\r\nreturn result;\r\n}
