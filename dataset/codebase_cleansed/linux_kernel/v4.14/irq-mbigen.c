static inline unsigned int get_mbigen_vec_reg(irq_hw_number_t hwirq)\r\n{\r\nunsigned int nid, pin;\r\nhwirq -= RESERVED_IRQ_PER_MBIGEN_CHIP;\r\nnid = hwirq / IRQS_PER_MBIGEN_NODE + 1;\r\npin = hwirq % IRQS_PER_MBIGEN_NODE;\r\nreturn pin * 4 + nid * MBIGEN_NODE_OFFSET\r\n+ REG_MBIGEN_VEC_OFFSET;\r\n}\r\nstatic inline void get_mbigen_type_reg(irq_hw_number_t hwirq,\r\nu32 *mask, u32 *addr)\r\n{\r\nunsigned int nid, irq_ofst, ofst;\r\nhwirq -= RESERVED_IRQ_PER_MBIGEN_CHIP;\r\nnid = hwirq / IRQS_PER_MBIGEN_NODE + 1;\r\nirq_ofst = hwirq % IRQS_PER_MBIGEN_NODE;\r\n*mask = 1 << (irq_ofst % 32);\r\nofst = irq_ofst / 32 * 4;\r\n*addr = ofst + nid * MBIGEN_NODE_OFFSET\r\n+ REG_MBIGEN_TYPE_OFFSET;\r\n}\r\nstatic inline void get_mbigen_clear_reg(irq_hw_number_t hwirq,\r\nu32 *mask, u32 *addr)\r\n{\r\nunsigned int ofst = (hwirq / 32) * 4;\r\n*mask = 1 << (hwirq % 32);\r\n*addr = ofst + REG_MBIGEN_CLEAR_OFFSET;\r\n}\r\nstatic void mbigen_eoi_irq(struct irq_data *data)\r\n{\r\nvoid __iomem *base = data->chip_data;\r\nu32 mask, addr;\r\nget_mbigen_clear_reg(data->hwirq, &mask, &addr);\r\nwritel_relaxed(mask, base + addr);\r\nirq_chip_eoi_parent(data);\r\n}\r\nstatic int mbigen_set_type(struct irq_data *data, unsigned int type)\r\n{\r\nvoid __iomem *base = data->chip_data;\r\nu32 mask, addr, val;\r\nif (type != IRQ_TYPE_LEVEL_HIGH && type != IRQ_TYPE_EDGE_RISING)\r\nreturn -EINVAL;\r\nget_mbigen_type_reg(data->hwirq, &mask, &addr);\r\nval = readl_relaxed(base + addr);\r\nif (type == IRQ_TYPE_LEVEL_HIGH)\r\nval |= mask;\r\nelse\r\nval &= ~mask;\r\nwritel_relaxed(val, base + addr);\r\nreturn 0;\r\n}\r\nstatic void mbigen_write_msg(struct msi_desc *desc, struct msi_msg *msg)\r\n{\r\nstruct irq_data *d = irq_get_irq_data(desc->irq);\r\nvoid __iomem *base = d->chip_data;\r\nu32 val;\r\nbase += get_mbigen_vec_reg(d->hwirq);\r\nval = readl_relaxed(base);\r\nval &= ~(IRQ_EVENT_ID_MASK << IRQ_EVENT_ID_SHIFT);\r\nval |= (msg->data << IRQ_EVENT_ID_SHIFT);\r\nwritel_relaxed(val, base);\r\n}\r\nstatic int mbigen_domain_translate(struct irq_domain *d,\r\nstruct irq_fwspec *fwspec,\r\nunsigned long *hwirq,\r\nunsigned int *type)\r\n{\r\nif (is_of_node(fwspec->fwnode) || is_acpi_device_node(fwspec->fwnode)) {\r\nif (fwspec->param_count != 2)\r\nreturn -EINVAL;\r\nif ((fwspec->param[0] > MAXIMUM_IRQ_PIN_NUM) ||\r\n(fwspec->param[0] < RESERVED_IRQ_PER_MBIGEN_CHIP))\r\nreturn -EINVAL;\r\nelse\r\n*hwirq = fwspec->param[0];\r\nif ((fwspec->param[1] == IRQ_TYPE_EDGE_RISING) ||\r\n(fwspec->param[1] == IRQ_TYPE_LEVEL_HIGH))\r\n*type = fwspec->param[1];\r\nelse\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int mbigen_irq_domain_alloc(struct irq_domain *domain,\r\nunsigned int virq,\r\nunsigned int nr_irqs,\r\nvoid *args)\r\n{\r\nstruct irq_fwspec *fwspec = args;\r\nirq_hw_number_t hwirq;\r\nunsigned int type;\r\nstruct mbigen_device *mgn_chip;\r\nint i, err;\r\nerr = mbigen_domain_translate(domain, fwspec, &hwirq, &type);\r\nif (err)\r\nreturn err;\r\nerr = platform_msi_domain_alloc(domain, virq, nr_irqs);\r\nif (err)\r\nreturn err;\r\nmgn_chip = platform_msi_get_host_data(domain);\r\nfor (i = 0; i < nr_irqs; i++)\r\nirq_domain_set_hwirq_and_chip(domain, virq + i, hwirq + i,\r\n&mbigen_irq_chip, mgn_chip->base);\r\nreturn 0;\r\n}\r\nstatic int mbigen_of_create_domain(struct platform_device *pdev,\r\nstruct mbigen_device *mgn_chip)\r\n{\r\nstruct device *parent;\r\nstruct platform_device *child;\r\nstruct irq_domain *domain;\r\nstruct device_node *np;\r\nu32 num_pins;\r\nfor_each_child_of_node(pdev->dev.of_node, np) {\r\nif (!of_property_read_bool(np, "interrupt-controller"))\r\ncontinue;\r\nparent = platform_bus_type.dev_root;\r\nchild = of_platform_device_create(np, NULL, parent);\r\nif (!child)\r\nreturn -ENOMEM;\r\nif (of_property_read_u32(child->dev.of_node, "num-pins",\r\n&num_pins) < 0) {\r\ndev_err(&pdev->dev, "No num-pins property\n");\r\nreturn -EINVAL;\r\n}\r\ndomain = platform_msi_create_device_domain(&child->dev, num_pins,\r\nmbigen_write_msg,\r\n&mbigen_domain_ops,\r\nmgn_chip);\r\nif (!domain)\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mbigen_acpi_create_domain(struct platform_device *pdev,\r\nstruct mbigen_device *mgn_chip)\r\n{\r\nstruct irq_domain *domain;\r\nu32 num_pins = 0;\r\nint ret;\r\nret = device_property_read_u32(&pdev->dev, "num-pins", &num_pins);\r\nif (ret || num_pins == 0)\r\nreturn -EINVAL;\r\ndomain = platform_msi_create_device_domain(&pdev->dev, num_pins,\r\nmbigen_write_msg,\r\n&mbigen_domain_ops,\r\nmgn_chip);\r\nif (!domain)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic inline int mbigen_acpi_create_domain(struct platform_device *pdev,\r\nstruct mbigen_device *mgn_chip)\r\n{\r\nreturn -ENODEV;\r\n}\r\nstatic int mbigen_device_probe(struct platform_device *pdev)\r\n{\r\nstruct mbigen_device *mgn_chip;\r\nstruct resource *res;\r\nint err;\r\nmgn_chip = devm_kzalloc(&pdev->dev, sizeof(*mgn_chip), GFP_KERNEL);\r\nif (!mgn_chip)\r\nreturn -ENOMEM;\r\nmgn_chip->pdev = pdev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -EINVAL;\r\nmgn_chip->base = devm_ioremap(&pdev->dev, res->start,\r\nresource_size(res));\r\nif (!mgn_chip->base) {\r\ndev_err(&pdev->dev, "failed to ioremap %pR\n", res);\r\nreturn -ENOMEM;\r\n}\r\nif (IS_ENABLED(CONFIG_OF) && pdev->dev.of_node)\r\nerr = mbigen_of_create_domain(pdev, mgn_chip);\r\nelse if (ACPI_COMPANION(&pdev->dev))\r\nerr = mbigen_acpi_create_domain(pdev, mgn_chip);\r\nelse\r\nerr = -EINVAL;\r\nif (err) {\r\ndev_err(&pdev->dev, "Failed to create mbi-gen@%p irqdomain",\r\nmgn_chip->base);\r\nreturn err;\r\n}\r\nplatform_set_drvdata(pdev, mgn_chip);\r\nreturn 0;\r\n}
