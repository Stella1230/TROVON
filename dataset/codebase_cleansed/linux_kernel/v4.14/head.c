struct nvkm_head *\r\nnvkm_head_find(struct nvkm_disp *disp, int id)\r\n{\r\nstruct nvkm_head *head;\r\nlist_for_each_entry(head, &disp->head, head) {\r\nif (head->id == id)\r\nreturn head;\r\n}\r\nreturn NULL;\r\n}\r\nint\r\nnvkm_head_mthd_scanoutpos(struct nvkm_object *object,\r\nstruct nvkm_head *head, void *data, u32 size)\r\n{\r\nunion {\r\nstruct nv04_disp_scanoutpos_v0 v0;\r\n} *args = data;\r\nint ret = -ENOSYS;\r\nnvif_ioctl(object, "head scanoutpos size %d\n", size);\r\nif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {\r\nnvif_ioctl(object, "head scanoutpos vers %d\n",\r\nargs->v0.version);\r\nhead->func->state(head, &head->arm);\r\nargs->v0.vtotal = head->arm.vtotal;\r\nargs->v0.vblanks = head->arm.vblanks;\r\nargs->v0.vblanke = head->arm.vblanke;\r\nargs->v0.htotal = head->arm.htotal;\r\nargs->v0.hblanks = head->arm.hblanks;\r\nargs->v0.hblanke = head->arm.hblanke;\r\nif (!args->v0.vtotal || !args->v0.htotal)\r\nreturn -ENOTSUPP;\r\nargs->v0.time[0] = ktime_to_ns(ktime_get());\r\nhead->func->rgpos(head, &args->v0.hline, &args->v0.vline);\r\nargs->v0.time[1] = ktime_to_ns(ktime_get());\r\n} else\r\nreturn ret;\r\nreturn 0;\r\n}\r\nvoid\r\nnvkm_head_del(struct nvkm_head **phead)\r\n{\r\nstruct nvkm_head *head = *phead;\r\nif (head) {\r\nHEAD_DBG(head, "dtor");\r\nlist_del(&head->head);\r\nkfree(*phead);\r\n*phead = NULL;\r\n}\r\n}\r\nint\r\nnvkm_head_new_(const struct nvkm_head_func *func,\r\nstruct nvkm_disp *disp, int id)\r\n{\r\nstruct nvkm_head *head;\r\nif (!(head = kzalloc(sizeof(*head), GFP_KERNEL)))\r\nreturn -ENOMEM;\r\nhead->func = func;\r\nhead->disp = disp;\r\nhead->id = id;\r\nlist_add_tail(&head->head, &disp->head);\r\nHEAD_DBG(head, "ctor");\r\nreturn 0;\r\n}
