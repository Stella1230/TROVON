static inline struct imx_pm_domain *\r\nto_imx_pm_domain(struct generic_pm_domain *genpd)\r\n{\r\nreturn container_of(genpd, struct imx_pm_domain, base);\r\n}\r\nstatic int imx6_pm_domain_power_off(struct generic_pm_domain *genpd)\r\n{\r\nstruct imx_pm_domain *pd = to_imx_pm_domain(genpd);\r\nint iso, iso2sw;\r\nu32 val;\r\nif (pd->flags & PGC_DOMAIN_FLAG_NO_PD)\r\nreturn -EBUSY;\r\nregmap_read(pd->regmap, pd->reg_offs + GPC_PGC_PUPSCR_OFFS, &val);\r\niso = val & 0x3f;\r\niso2sw = (val >> 8) & 0x3f;\r\nregmap_update_bits(pd->regmap, pd->reg_offs + GPC_PGC_CTRL_OFFS,\r\n0x1, 0x1);\r\nval = BIT(pd->cntr_pdn_bit);\r\nregmap_update_bits(pd->regmap, GPC_CNTR, val, val);\r\nudelay(DIV_ROUND_UP(iso + iso2sw, pd->ipg_rate_mhz));\r\nif (pd->supply)\r\nregulator_disable(pd->supply);\r\nreturn 0;\r\n}\r\nstatic int imx6_pm_domain_power_on(struct generic_pm_domain *genpd)\r\n{\r\nstruct imx_pm_domain *pd = to_imx_pm_domain(genpd);\r\nint i, ret, sw, sw2iso;\r\nu32 val;\r\nif (pd->supply) {\r\nret = regulator_enable(pd->supply);\r\nif (ret) {\r\npr_err("%s: failed to enable regulator: %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\n}\r\nfor (i = 0; i < pd->num_clks; i++)\r\nclk_prepare_enable(pd->clk[i]);\r\nregmap_update_bits(pd->regmap, pd->reg_offs + GPC_PGC_CTRL_OFFS,\r\n0x1, 0x1);\r\nregmap_read(pd->regmap, pd->reg_offs + GPC_PGC_PUPSCR_OFFS, &val);\r\nsw = val & 0x3f;\r\nsw2iso = (val >> 8) & 0x3f;\r\nval = BIT(pd->cntr_pdn_bit + 1);\r\nregmap_update_bits(pd->regmap, GPC_CNTR, val, val);\r\nudelay(DIV_ROUND_UP(sw + sw2iso, pd->ipg_rate_mhz));\r\nfor (i = 0; i < pd->num_clks; i++)\r\nclk_disable_unprepare(pd->clk[i]);\r\nreturn 0;\r\n}\r\nstatic int imx_pgc_get_clocks(struct device *dev, struct imx_pm_domain *domain)\r\n{\r\nint i, ret;\r\nfor (i = 0; ; i++) {\r\nstruct clk *clk = of_clk_get(dev->of_node, i);\r\nif (IS_ERR(clk))\r\nbreak;\r\nif (i >= GPC_CLK_MAX) {\r\ndev_err(dev, "more than %d clocks\n", GPC_CLK_MAX);\r\nret = -EINVAL;\r\ngoto clk_err;\r\n}\r\ndomain->clk[i] = clk;\r\n}\r\ndomain->num_clks = i;\r\nreturn 0;\r\nclk_err:\r\nwhile (i--)\r\nclk_put(domain->clk[i]);\r\nreturn ret;\r\n}\r\nstatic void imx_pgc_put_clocks(struct imx_pm_domain *domain)\r\n{\r\nint i;\r\nfor (i = domain->num_clks - 1; i >= 0; i--)\r\nclk_put(domain->clk[i]);\r\n}\r\nstatic int imx_pgc_parse_dt(struct device *dev, struct imx_pm_domain *domain)\r\n{\r\ndomain->supply = devm_regulator_get_optional(dev, "power");\r\nif (IS_ERR(domain->supply)) {\r\nif (PTR_ERR(domain->supply) == -ENODEV)\r\ndomain->supply = NULL;\r\nelse\r\nreturn PTR_ERR(domain->supply);\r\n}\r\nreturn imx_pgc_get_clocks(dev, domain);\r\n}\r\nstatic int imx_pgc_power_domain_probe(struct platform_device *pdev)\r\n{\r\nstruct imx_pm_domain *domain = pdev->dev.platform_data;\r\nstruct device *dev = &pdev->dev;\r\nint ret;\r\nif (dev->of_node) {\r\nret = imx_pgc_parse_dt(dev, domain);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (domain->base.power_on)\r\ndomain->base.power_on(&domain->base);\r\nif (IS_ENABLED(CONFIG_PM_GENERIC_DOMAINS)) {\r\npm_genpd_init(&domain->base, NULL, false);\r\nret = of_genpd_add_provider_simple(dev->of_node, &domain->base);\r\nif (ret)\r\ngoto genpd_err;\r\n}\r\ndevice_link_add(dev, dev->parent, DL_FLAG_AUTOREMOVE);\r\nreturn 0;\r\ngenpd_err:\r\npm_genpd_remove(&domain->base);\r\nimx_pgc_put_clocks(domain);\r\nreturn ret;\r\n}\r\nstatic int imx_pgc_power_domain_remove(struct platform_device *pdev)\r\n{\r\nstruct imx_pm_domain *domain = pdev->dev.platform_data;\r\nif (IS_ENABLED(CONFIG_PM_GENERIC_DOMAINS)) {\r\nof_genpd_del_provider(pdev->dev.of_node);\r\npm_genpd_remove(&domain->base);\r\nimx_pgc_put_clocks(domain);\r\n}\r\nreturn 0;\r\n}\r\nstatic int imx_gpc_old_dt_init(struct device *dev, struct regmap *regmap,\r\nunsigned int num_domains)\r\n{\r\nstruct imx_pm_domain *domain;\r\nint i, ret;\r\nfor (i = 0; i < num_domains; i++) {\r\ndomain = &imx_gpc_domains[i];\r\ndomain->regmap = regmap;\r\ndomain->ipg_rate_mhz = 66;\r\nif (i == 1) {\r\ndomain->supply = devm_regulator_get(dev, "pu");\r\nif (IS_ERR(domain->supply))\r\nreturn PTR_ERR(domain->supply);;\r\nret = imx_pgc_get_clocks(dev, domain);\r\nif (ret)\r\ngoto clk_err;\r\ndomain->base.power_on(&domain->base);\r\n}\r\n}\r\nfor (i = 0; i < num_domains; i++)\r\npm_genpd_init(&imx_gpc_domains[i].base, NULL, false);\r\nif (IS_ENABLED(CONFIG_PM_GENERIC_DOMAINS)) {\r\nret = of_genpd_add_provider_onecell(dev->of_node,\r\n&imx_gpc_onecell_data);\r\nif (ret)\r\ngoto genpd_err;\r\n}\r\nreturn 0;\r\ngenpd_err:\r\nfor (i = 0; i < num_domains; i++)\r\npm_genpd_remove(&imx_gpc_domains[i].base);\r\nimx_pgc_put_clocks(&imx_gpc_domains[GPC_PGC_DOMAIN_PU]);\r\nclk_err:\r\nreturn ret;\r\n}\r\nstatic int imx_gpc_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *of_id =\r\nof_match_device(imx_gpc_dt_ids, &pdev->dev);\r\nconst struct imx_gpc_dt_data *of_id_data = of_id->data;\r\nstruct device_node *pgc_node;\r\nstruct regmap *regmap;\r\nstruct resource *res;\r\nvoid __iomem *base;\r\nint ret;\r\npgc_node = of_get_child_by_name(pdev->dev.of_node, "pgc");\r\nif (!of_property_read_bool(pdev->dev.of_node, "#power-domain-cells") &&\r\n!pgc_node)\r\nreturn 0;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\nregmap = devm_regmap_init_mmio_clk(&pdev->dev, NULL, base,\r\n&imx_gpc_regmap_config);\r\nif (IS_ERR(regmap)) {\r\nret = PTR_ERR(regmap);\r\ndev_err(&pdev->dev, "failed to init regmap: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nif (of_id_data->err009619_present)\r\nimx_gpc_domains[GPC_PGC_DOMAIN_PU].flags |=\r\nPGC_DOMAIN_FLAG_NO_PD;\r\nif (!pgc_node) {\r\nret = imx_gpc_old_dt_init(&pdev->dev, regmap,\r\nof_id_data->num_domains);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\nstruct imx_pm_domain *domain;\r\nstruct platform_device *pd_pdev;\r\nstruct device_node *np;\r\nstruct clk *ipg_clk;\r\nunsigned int ipg_rate_mhz;\r\nint domain_index;\r\nipg_clk = devm_clk_get(&pdev->dev, "ipg");\r\nif (IS_ERR(ipg_clk))\r\nreturn PTR_ERR(ipg_clk);\r\nipg_rate_mhz = clk_get_rate(ipg_clk) / 1000000;\r\nfor_each_child_of_node(pgc_node, np) {\r\nret = of_property_read_u32(np, "reg", &domain_index);\r\nif (ret) {\r\nof_node_put(np);\r\nreturn ret;\r\n}\r\nif (domain_index >= of_id_data->num_domains)\r\ncontinue;\r\ndomain = &imx_gpc_domains[domain_index];\r\ndomain->regmap = regmap;\r\ndomain->ipg_rate_mhz = ipg_rate_mhz;\r\npd_pdev = platform_device_alloc("imx-pgc-power-domain",\r\ndomain_index);\r\nif (!pd_pdev) {\r\nof_node_put(np);\r\nreturn -ENOMEM;\r\n}\r\npd_pdev->dev.platform_data = domain;\r\npd_pdev->dev.parent = &pdev->dev;\r\npd_pdev->dev.of_node = np;\r\nret = platform_device_add(pd_pdev);\r\nif (ret) {\r\nplatform_device_put(pd_pdev);\r\nof_node_put(np);\r\nreturn ret;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int imx_gpc_remove(struct platform_device *pdev)\r\n{\r\nint ret;\r\nif (!of_get_child_by_name(pdev->dev.of_node, "pgc")) {\r\nof_genpd_del_provider(pdev->dev.of_node);\r\nret = pm_genpd_remove(&imx_gpc_domains[GPC_PGC_DOMAIN_PU].base);\r\nif (ret)\r\nreturn ret;\r\nimx_pgc_put_clocks(&imx_gpc_domains[GPC_PGC_DOMAIN_PU]);\r\nret = pm_genpd_remove(&imx_gpc_domains[GPC_PGC_DOMAIN_ARM].base);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
