static inline struct f_uac2 *func_to_uac2(struct usb_function *f)\r\n{\r\nreturn container_of(f, struct f_uac2, g_audio.func);\r\n}\r\nstatic inline\r\nstruct f_uac2_opts *g_audio_to_uac2_opts(struct g_audio *agdev)\r\n{\r\nreturn container_of(agdev->func.fi, struct f_uac2_opts, func_inst);\r\n}\r\nstatic void set_ep_max_packet_size(const struct f_uac2_opts *uac2_opts,\r\nstruct usb_endpoint_descriptor *ep_desc,\r\nunsigned int factor, bool is_playback)\r\n{\r\nint chmask, srate, ssize;\r\nu16 max_packet_size;\r\nif (is_playback) {\r\nchmask = uac2_opts->p_chmask;\r\nsrate = uac2_opts->p_srate;\r\nssize = uac2_opts->p_ssize;\r\n} else {\r\nchmask = uac2_opts->c_chmask;\r\nsrate = uac2_opts->c_srate;\r\nssize = uac2_opts->c_ssize;\r\n}\r\nmax_packet_size = num_channels(chmask) * ssize *\r\nDIV_ROUND_UP(srate, factor / (1 << (ep_desc->bInterval - 1)));\r\nep_desc->wMaxPacketSize = cpu_to_le16(min_t(u16, max_packet_size,\r\nle16_to_cpu(ep_desc->wMaxPacketSize)));\r\n}\r\nstatic int\r\nafunc_bind(struct usb_configuration *cfg, struct usb_function *fn)\r\n{\r\nstruct f_uac2 *uac2 = func_to_uac2(fn);\r\nstruct g_audio *agdev = func_to_g_audio(fn);\r\nstruct usb_composite_dev *cdev = cfg->cdev;\r\nstruct usb_gadget *gadget = cdev->gadget;\r\nstruct device *dev = &gadget->dev;\r\nstruct f_uac2_opts *uac2_opts;\r\nstruct usb_string *us;\r\nint ret;\r\nuac2_opts = container_of(fn->fi, struct f_uac2_opts, func_inst);\r\nus = usb_gstrings_attach(cdev, fn_strings, ARRAY_SIZE(strings_fn));\r\nif (IS_ERR(us))\r\nreturn PTR_ERR(us);\r\niad_desc.iFunction = us[STR_ASSOC].id;\r\nstd_ac_if_desc.iInterface = us[STR_IF_CTRL].id;\r\nin_clk_src_desc.iClockSource = us[STR_CLKSRC_IN].id;\r\nout_clk_src_desc.iClockSource = us[STR_CLKSRC_OUT].id;\r\nusb_out_it_desc.iTerminal = us[STR_USB_IT].id;\r\nio_in_it_desc.iTerminal = us[STR_IO_IT].id;\r\nusb_in_ot_desc.iTerminal = us[STR_USB_OT].id;\r\nio_out_ot_desc.iTerminal = us[STR_IO_OT].id;\r\nstd_as_out_if0_desc.iInterface = us[STR_AS_OUT_ALT0].id;\r\nstd_as_out_if1_desc.iInterface = us[STR_AS_OUT_ALT1].id;\r\nstd_as_in_if0_desc.iInterface = us[STR_AS_IN_ALT0].id;\r\nstd_as_in_if1_desc.iInterface = us[STR_AS_IN_ALT1].id;\r\nusb_out_it_desc.bNrChannels = num_channels(uac2_opts->c_chmask);\r\nusb_out_it_desc.bmChannelConfig = cpu_to_le32(uac2_opts->c_chmask);\r\nio_in_it_desc.bNrChannels = num_channels(uac2_opts->p_chmask);\r\nio_in_it_desc.bmChannelConfig = cpu_to_le32(uac2_opts->p_chmask);\r\nas_out_hdr_desc.bNrChannels = num_channels(uac2_opts->c_chmask);\r\nas_out_hdr_desc.bmChannelConfig = cpu_to_le32(uac2_opts->c_chmask);\r\nas_in_hdr_desc.bNrChannels = num_channels(uac2_opts->p_chmask);\r\nas_in_hdr_desc.bmChannelConfig = cpu_to_le32(uac2_opts->p_chmask);\r\nas_out_fmt1_desc.bSubslotSize = uac2_opts->c_ssize;\r\nas_out_fmt1_desc.bBitResolution = uac2_opts->c_ssize * 8;\r\nas_in_fmt1_desc.bSubslotSize = uac2_opts->p_ssize;\r\nas_in_fmt1_desc.bBitResolution = uac2_opts->p_ssize * 8;\r\nsnprintf(clksrc_in, sizeof(clksrc_in), "%uHz", uac2_opts->p_srate);\r\nsnprintf(clksrc_out, sizeof(clksrc_out), "%uHz", uac2_opts->c_srate);\r\nret = usb_interface_id(cfg, fn);\r\nif (ret < 0) {\r\ndev_err(dev, "%s:%d Error!\n", __func__, __LINE__);\r\nreturn ret;\r\n}\r\nstd_ac_if_desc.bInterfaceNumber = ret;\r\nuac2->ac_intf = ret;\r\nuac2->ac_alt = 0;\r\nret = usb_interface_id(cfg, fn);\r\nif (ret < 0) {\r\ndev_err(dev, "%s:%d Error!\n", __func__, __LINE__);\r\nreturn ret;\r\n}\r\nstd_as_out_if0_desc.bInterfaceNumber = ret;\r\nstd_as_out_if1_desc.bInterfaceNumber = ret;\r\nuac2->as_out_intf = ret;\r\nuac2->as_out_alt = 0;\r\nret = usb_interface_id(cfg, fn);\r\nif (ret < 0) {\r\ndev_err(dev, "%s:%d Error!\n", __func__, __LINE__);\r\nreturn ret;\r\n}\r\nstd_as_in_if0_desc.bInterfaceNumber = ret;\r\nstd_as_in_if1_desc.bInterfaceNumber = ret;\r\nuac2->as_in_intf = ret;\r\nuac2->as_in_alt = 0;\r\nset_ep_max_packet_size(uac2_opts, &fs_epin_desc, 1000, true);\r\nset_ep_max_packet_size(uac2_opts, &fs_epout_desc, 1000, false);\r\nset_ep_max_packet_size(uac2_opts, &hs_epin_desc, 8000, true);\r\nset_ep_max_packet_size(uac2_opts, &hs_epout_desc, 8000, false);\r\nagdev->out_ep = usb_ep_autoconfig(gadget, &fs_epout_desc);\r\nif (!agdev->out_ep) {\r\ndev_err(dev, "%s:%d Error!\n", __func__, __LINE__);\r\nreturn ret;\r\n}\r\nagdev->in_ep = usb_ep_autoconfig(gadget, &fs_epin_desc);\r\nif (!agdev->in_ep) {\r\ndev_err(dev, "%s:%d Error!\n", __func__, __LINE__);\r\nreturn ret;\r\n}\r\nagdev->in_ep_maxpsize = max_t(u16,\r\nle16_to_cpu(fs_epin_desc.wMaxPacketSize),\r\nle16_to_cpu(hs_epin_desc.wMaxPacketSize));\r\nagdev->out_ep_maxpsize = max_t(u16,\r\nle16_to_cpu(fs_epout_desc.wMaxPacketSize),\r\nle16_to_cpu(hs_epout_desc.wMaxPacketSize));\r\nhs_epout_desc.bEndpointAddress = fs_epout_desc.bEndpointAddress;\r\nhs_epin_desc.bEndpointAddress = fs_epin_desc.bEndpointAddress;\r\nret = usb_assign_descriptors(fn, fs_audio_desc, hs_audio_desc, NULL,\r\nNULL);\r\nif (ret)\r\nreturn ret;\r\nagdev->gadget = gadget;\r\nagdev->params.p_chmask = uac2_opts->p_chmask;\r\nagdev->params.p_srate = uac2_opts->p_srate;\r\nagdev->params.p_ssize = uac2_opts->p_ssize;\r\nagdev->params.c_chmask = uac2_opts->c_chmask;\r\nagdev->params.c_srate = uac2_opts->c_srate;\r\nagdev->params.c_ssize = uac2_opts->c_ssize;\r\nagdev->params.req_number = uac2_opts->req_number;\r\nret = g_audio_setup(agdev, "UAC2 PCM", "UAC2_Gadget");\r\nif (ret)\r\ngoto err_free_descs;\r\nreturn 0;\r\nerr_free_descs:\r\nusb_free_all_descriptors(fn);\r\nagdev->gadget = NULL;\r\nreturn ret;\r\n}\r\nstatic int\r\nafunc_set_alt(struct usb_function *fn, unsigned intf, unsigned alt)\r\n{\r\nstruct usb_composite_dev *cdev = fn->config->cdev;\r\nstruct f_uac2 *uac2 = func_to_uac2(fn);\r\nstruct usb_gadget *gadget = cdev->gadget;\r\nstruct device *dev = &gadget->dev;\r\nint ret = 0;\r\nif (alt > 1) {\r\ndev_err(dev, "%s:%d Error!\n", __func__, __LINE__);\r\nreturn -EINVAL;\r\n}\r\nif (intf == uac2->ac_intf) {\r\nif (alt) {\r\ndev_err(dev, "%s:%d Error!\n", __func__, __LINE__);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nif (intf == uac2->as_out_intf) {\r\nuac2->as_out_alt = alt;\r\nif (alt)\r\nret = u_audio_start_capture(&uac2->g_audio);\r\nelse\r\nu_audio_stop_capture(&uac2->g_audio);\r\n} else if (intf == uac2->as_in_intf) {\r\nuac2->as_in_alt = alt;\r\nif (alt)\r\nret = u_audio_start_playback(&uac2->g_audio);\r\nelse\r\nu_audio_stop_playback(&uac2->g_audio);\r\n} else {\r\ndev_err(dev, "%s:%d Error!\n", __func__, __LINE__);\r\nreturn -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nafunc_get_alt(struct usb_function *fn, unsigned intf)\r\n{\r\nstruct f_uac2 *uac2 = func_to_uac2(fn);\r\nstruct g_audio *agdev = func_to_g_audio(fn);\r\nif (intf == uac2->ac_intf)\r\nreturn uac2->ac_alt;\r\nelse if (intf == uac2->as_out_intf)\r\nreturn uac2->as_out_alt;\r\nelse if (intf == uac2->as_in_intf)\r\nreturn uac2->as_in_alt;\r\nelse\r\ndev_err(&agdev->gadget->dev,\r\n"%s:%d Invalid Interface %d!\n",\r\n__func__, __LINE__, intf);\r\nreturn -EINVAL;\r\n}\r\nstatic void\r\nafunc_disable(struct usb_function *fn)\r\n{\r\nstruct f_uac2 *uac2 = func_to_uac2(fn);\r\nuac2->as_in_alt = 0;\r\nuac2->as_out_alt = 0;\r\nu_audio_stop_capture(&uac2->g_audio);\r\nu_audio_stop_playback(&uac2->g_audio);\r\n}\r\nstatic int\r\nin_rq_cur(struct usb_function *fn, const struct usb_ctrlrequest *cr)\r\n{\r\nstruct usb_request *req = fn->config->cdev->req;\r\nstruct g_audio *agdev = func_to_g_audio(fn);\r\nstruct f_uac2_opts *opts;\r\nu16 w_length = le16_to_cpu(cr->wLength);\r\nu16 w_index = le16_to_cpu(cr->wIndex);\r\nu16 w_value = le16_to_cpu(cr->wValue);\r\nu8 entity_id = (w_index >> 8) & 0xff;\r\nu8 control_selector = w_value >> 8;\r\nint value = -EOPNOTSUPP;\r\nint p_srate, c_srate;\r\nopts = g_audio_to_uac2_opts(agdev);\r\np_srate = opts->p_srate;\r\nc_srate = opts->c_srate;\r\nif (control_selector == UAC2_CS_CONTROL_SAM_FREQ) {\r\nstruct cntrl_cur_lay3 c;\r\nmemset(&c, 0, sizeof(struct cntrl_cur_lay3));\r\nif (entity_id == USB_IN_CLK_ID)\r\nc.dCUR = p_srate;\r\nelse if (entity_id == USB_OUT_CLK_ID)\r\nc.dCUR = c_srate;\r\nvalue = min_t(unsigned, w_length, sizeof c);\r\nmemcpy(req->buf, &c, value);\r\n} else if (control_selector == UAC2_CS_CONTROL_CLOCK_VALID) {\r\n*(u8 *)req->buf = 1;\r\nvalue = min_t(unsigned, w_length, 1);\r\n} else {\r\ndev_err(&agdev->gadget->dev,\r\n"%s:%d control_selector=%d TODO!\n",\r\n__func__, __LINE__, control_selector);\r\n}\r\nreturn value;\r\n}\r\nstatic int\r\nin_rq_range(struct usb_function *fn, const struct usb_ctrlrequest *cr)\r\n{\r\nstruct usb_request *req = fn->config->cdev->req;\r\nstruct g_audio *agdev = func_to_g_audio(fn);\r\nstruct f_uac2_opts *opts;\r\nu16 w_length = le16_to_cpu(cr->wLength);\r\nu16 w_index = le16_to_cpu(cr->wIndex);\r\nu16 w_value = le16_to_cpu(cr->wValue);\r\nu8 entity_id = (w_index >> 8) & 0xff;\r\nu8 control_selector = w_value >> 8;\r\nstruct cntrl_range_lay3 r;\r\nint value = -EOPNOTSUPP;\r\nint p_srate, c_srate;\r\nopts = g_audio_to_uac2_opts(agdev);\r\np_srate = opts->p_srate;\r\nc_srate = opts->c_srate;\r\nif (control_selector == UAC2_CS_CONTROL_SAM_FREQ) {\r\nif (entity_id == USB_IN_CLK_ID)\r\nr.dMIN = p_srate;\r\nelse if (entity_id == USB_OUT_CLK_ID)\r\nr.dMIN = c_srate;\r\nelse\r\nreturn -EOPNOTSUPP;\r\nr.dMAX = r.dMIN;\r\nr.dRES = 0;\r\nr.wNumSubRanges = 1;\r\nvalue = min_t(unsigned, w_length, sizeof r);\r\nmemcpy(req->buf, &r, value);\r\n} else {\r\ndev_err(&agdev->gadget->dev,\r\n"%s:%d control_selector=%d TODO!\n",\r\n__func__, __LINE__, control_selector);\r\n}\r\nreturn value;\r\n}\r\nstatic int\r\nac_rq_in(struct usb_function *fn, const struct usb_ctrlrequest *cr)\r\n{\r\nif (cr->bRequest == UAC2_CS_CUR)\r\nreturn in_rq_cur(fn, cr);\r\nelse if (cr->bRequest == UAC2_CS_RANGE)\r\nreturn in_rq_range(fn, cr);\r\nelse\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int\r\nout_rq_cur(struct usb_function *fn, const struct usb_ctrlrequest *cr)\r\n{\r\nu16 w_length = le16_to_cpu(cr->wLength);\r\nu16 w_value = le16_to_cpu(cr->wValue);\r\nu8 control_selector = w_value >> 8;\r\nif (control_selector == UAC2_CS_CONTROL_SAM_FREQ)\r\nreturn w_length;\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int\r\nsetup_rq_inf(struct usb_function *fn, const struct usb_ctrlrequest *cr)\r\n{\r\nstruct f_uac2 *uac2 = func_to_uac2(fn);\r\nstruct g_audio *agdev = func_to_g_audio(fn);\r\nu16 w_index = le16_to_cpu(cr->wIndex);\r\nu8 intf = w_index & 0xff;\r\nif (intf != uac2->ac_intf) {\r\ndev_err(&agdev->gadget->dev,\r\n"%s:%d Error!\n", __func__, __LINE__);\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (cr->bRequestType & USB_DIR_IN)\r\nreturn ac_rq_in(fn, cr);\r\nelse if (cr->bRequest == UAC2_CS_CUR)\r\nreturn out_rq_cur(fn, cr);\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int\r\nafunc_setup(struct usb_function *fn, const struct usb_ctrlrequest *cr)\r\n{\r\nstruct usb_composite_dev *cdev = fn->config->cdev;\r\nstruct g_audio *agdev = func_to_g_audio(fn);\r\nstruct usb_request *req = cdev->req;\r\nu16 w_length = le16_to_cpu(cr->wLength);\r\nint value = -EOPNOTSUPP;\r\nif ((cr->bRequestType & USB_TYPE_MASK) != USB_TYPE_CLASS)\r\nreturn -EOPNOTSUPP;\r\nif ((cr->bRequestType & USB_RECIP_MASK) == USB_RECIP_INTERFACE)\r\nvalue = setup_rq_inf(fn, cr);\r\nelse\r\ndev_err(&agdev->gadget->dev, "%s:%d Error!\n",\r\n__func__, __LINE__);\r\nif (value >= 0) {\r\nreq->length = value;\r\nreq->zero = value < w_length;\r\nvalue = usb_ep_queue(cdev->gadget->ep0, req, GFP_ATOMIC);\r\nif (value < 0) {\r\ndev_err(&agdev->gadget->dev,\r\n"%s:%d Error!\n", __func__, __LINE__);\r\nreq->status = 0;\r\n}\r\n}\r\nreturn value;\r\n}\r\nstatic inline struct f_uac2_opts *to_f_uac2_opts(struct config_item *item)\r\n{\r\nreturn container_of(to_config_group(item), struct f_uac2_opts,\r\nfunc_inst.group);\r\n}\r\nstatic void f_uac2_attr_release(struct config_item *item)\r\n{\r\nstruct f_uac2_opts *opts = to_f_uac2_opts(item);\r\nusb_put_function_instance(&opts->func_inst);\r\n}\r\nstatic void afunc_free_inst(struct usb_function_instance *f)\r\n{\r\nstruct f_uac2_opts *opts;\r\nopts = container_of(f, struct f_uac2_opts, func_inst);\r\nkfree(opts);\r\n}\r\nstatic struct usb_function_instance *afunc_alloc_inst(void)\r\n{\r\nstruct f_uac2_opts *opts;\r\nopts = kzalloc(sizeof(*opts), GFP_KERNEL);\r\nif (!opts)\r\nreturn ERR_PTR(-ENOMEM);\r\nmutex_init(&opts->lock);\r\nopts->func_inst.free_func_inst = afunc_free_inst;\r\nconfig_group_init_type_name(&opts->func_inst.group, "",\r\n&f_uac2_func_type);\r\nopts->p_chmask = UAC2_DEF_PCHMASK;\r\nopts->p_srate = UAC2_DEF_PSRATE;\r\nopts->p_ssize = UAC2_DEF_PSSIZE;\r\nopts->c_chmask = UAC2_DEF_CCHMASK;\r\nopts->c_srate = UAC2_DEF_CSRATE;\r\nopts->c_ssize = UAC2_DEF_CSSIZE;\r\nopts->req_number = UAC2_DEF_REQ_NUM;\r\nreturn &opts->func_inst;\r\n}\r\nstatic void afunc_free(struct usb_function *f)\r\n{\r\nstruct g_audio *agdev;\r\nstruct f_uac2_opts *opts;\r\nagdev = func_to_g_audio(f);\r\nopts = container_of(f->fi, struct f_uac2_opts, func_inst);\r\nkfree(agdev);\r\nmutex_lock(&opts->lock);\r\n--opts->refcnt;\r\nmutex_unlock(&opts->lock);\r\n}\r\nstatic void afunc_unbind(struct usb_configuration *c, struct usb_function *f)\r\n{\r\nstruct g_audio *agdev = func_to_g_audio(f);\r\ng_audio_cleanup(agdev);\r\nusb_free_all_descriptors(f);\r\nagdev->gadget = NULL;\r\n}\r\nstatic struct usb_function *afunc_alloc(struct usb_function_instance *fi)\r\n{\r\nstruct f_uac2 *uac2;\r\nstruct f_uac2_opts *opts;\r\nuac2 = kzalloc(sizeof(*uac2), GFP_KERNEL);\r\nif (uac2 == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nopts = container_of(fi, struct f_uac2_opts, func_inst);\r\nmutex_lock(&opts->lock);\r\n++opts->refcnt;\r\nmutex_unlock(&opts->lock);\r\nuac2->g_audio.func.name = "uac2_func";\r\nuac2->g_audio.func.bind = afunc_bind;\r\nuac2->g_audio.func.unbind = afunc_unbind;\r\nuac2->g_audio.func.set_alt = afunc_set_alt;\r\nuac2->g_audio.func.get_alt = afunc_get_alt;\r\nuac2->g_audio.func.disable = afunc_disable;\r\nuac2->g_audio.func.setup = afunc_setup;\r\nuac2->g_audio.func.free_func = afunc_free;\r\nreturn &uac2->g_audio.func;\r\n}
