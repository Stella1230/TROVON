static void\r\ncrop_and_interpolate(unsigned int cropped_width,\r\nunsigned int cropped_height,\r\nunsigned int left_padding,\r\nint right_padding,\r\nint top_padding,\r\nconst struct ia_css_shading_table *in_table,\r\nstruct ia_css_shading_table *out_table,\r\nenum ia_css_sc_color color)\r\n{\r\nunsigned int i, j,\r\nsensor_width,\r\nsensor_height,\r\ntable_width,\r\ntable_height,\r\ntable_cell_h,\r\nout_cell_size,\r\nin_cell_size,\r\nout_start_row,\r\npadded_width;\r\nint out_start_col,\r\ntable_cell_w;\r\nunsigned short *in_ptr,\r\n*out_ptr;\r\nassert(in_table != NULL);\r\nassert(out_table != NULL);\r\nsensor_width = in_table->sensor_width;\r\nsensor_height = in_table->sensor_height;\r\ntable_width = in_table->width;\r\ntable_height = in_table->height;\r\nin_ptr = in_table->data[color];\r\nout_ptr = out_table->data[color];\r\npadded_width = cropped_width + left_padding + right_padding;\r\nout_cell_size = CEIL_DIV(padded_width, out_table->width - 1);\r\nin_cell_size = CEIL_DIV(sensor_width, table_width - 1);\r\nout_start_col = ((int)sensor_width - (int)cropped_width)/2 - left_padding;\r\nout_start_row = ((int)sensor_height - (int)cropped_height)/2 - top_padding;\r\ntable_cell_w = (int)((table_width-1) * in_cell_size);\r\ntable_cell_h = (table_height-1) * in_cell_size;\r\nfor (i = 0; i < out_table->height; i++) {\r\nint ty, src_y0, src_y1;\r\nunsigned int sy0, sy1, dy0, dy1, divy;\r\nty = out_start_row + i * out_cell_size;\r\nsrc_y0 = ty / (int)in_cell_size;\r\nif (in_cell_size < out_cell_size)\r\nsrc_y1 = (ty + out_cell_size) / in_cell_size;\r\nelse\r\nsrc_y1 = src_y0 + 1;\r\nsrc_y0 = clamp(src_y0, 0, (int)table_height-1);\r\nsrc_y1 = clamp(src_y1, 0, (int)table_height-1);\r\nty = min(clamp(ty, 0, (int)sensor_height-1),\r\n(int)table_cell_h);\r\nsy0 = min(src_y0 * in_cell_size, sensor_height-1);\r\nsy1 = min(src_y1 * in_cell_size, sensor_height-1);\r\ndy0 = ty - sy0;\r\ndy1 = sy1 - ty;\r\ndivy = sy1 - sy0;\r\nif (divy == 0) {\r\ndy0 = 1;\r\ndivy = 1;\r\n}\r\nfor (j = 0; j < out_table->width; j++, out_ptr++) {\r\nint tx, src_x0, src_x1;\r\nunsigned int sx0, sx1, dx0, dx1, divx;\r\nunsigned short s_ul, s_ur, s_ll, s_lr;\r\ntx = out_start_col + j * out_cell_size;\r\nsrc_x0 = tx / (int)in_cell_size;\r\nif (in_cell_size < out_cell_size) {\r\nsrc_x1 = (tx + out_cell_size) /\r\n(int)in_cell_size;\r\n} else {\r\nsrc_x1 = src_x0 + 1;\r\n}\r\nsrc_x0 = clamp(src_x0, 0, (int)table_width-1);\r\nsrc_x1 = clamp(src_x1, 0, (int)table_width-1);\r\ntx = min(clamp(tx, 0, (int)sensor_width-1),\r\n(int)table_cell_w);\r\nsx0 = min(src_x0 * in_cell_size, sensor_width-1);\r\nsx1 = min(src_x1 * in_cell_size, sensor_width-1);\r\ndx0 = tx - sx0;\r\ndx1 = sx1 - tx;\r\ndivx = sx1 - sx0;\r\nif (divx == 0) {\r\ndx0 = 1;\r\ndivx = 1;\r\n}\r\ns_ul = in_ptr[(table_width*src_y0)+src_x0];\r\ns_ur = in_ptr[(table_width*src_y0)+src_x1];\r\ns_ll = in_ptr[(table_width*src_y1)+src_x0];\r\ns_lr = in_ptr[(table_width*src_y1)+src_x1];\r\n*out_ptr = (unsigned short) ((dx0*dy0*s_lr + dx0*dy1*s_ur + dx1*dy0*s_ll + dx1*dy1*s_ul) /\r\n(divx*divy));\r\n}\r\n}\r\n}\r\nvoid\r\nprepare_shading_table(const struct ia_css_shading_table *in_table,\r\nunsigned int sensor_binning,\r\nstruct ia_css_shading_table **target_table,\r\nconst struct ia_css_binary *binary,\r\nunsigned int bds_factor)\r\n{\r\nunsigned int input_width,\r\ninput_height,\r\ntable_width,\r\ntable_height,\r\nleft_padding,\r\ntop_padding,\r\npadded_width,\r\nleft_cropping,\r\ni;\r\nunsigned int bds_numerator, bds_denominator;\r\nint right_padding;\r\nstruct ia_css_shading_table *result;\r\nassert(target_table != NULL);\r\nassert(binary != NULL);\r\nif (!in_table) {\r\n#ifndef ISP2401\r\nsh_css_params_shading_id_table_generate(target_table, binary);\r\n#else\r\nsh_css_params_shading_id_table_generate(target_table,\r\nbinary->sctbl_legacy_width_per_color, binary->sctbl_legacy_height);\r\n#endif\r\nreturn;\r\n}\r\npadded_width = binary->in_frame_info.padded_width;\r\n#if defined(USE_INPUT_SYSTEM_VERSION_2401)\r\npadded_width = CEIL_MUL(binary->effective_in_frame_res.width + 2*ISP_VEC_NELEMS,\r\n2*ISP_VEC_NELEMS);\r\n#endif\r\ninput_height = binary->in_frame_info.res.height;\r\ninput_width = binary->in_frame_info.res.width;\r\nleft_padding = binary->left_padding;\r\nleft_cropping = (binary->info->sp.pipeline.left_cropping == 0) ?\r\nbinary->dvs_envelope.width : 2*ISP_VEC_NELEMS;\r\nsh_css_bds_factor_get_numerator_denominator\r\n(bds_factor, &bds_numerator, &bds_denominator);\r\nleft_padding = (left_padding + binary->info->sp.pipeline.left_cropping) * bds_numerator / bds_denominator - binary->info->sp.pipeline.left_cropping;\r\nright_padding = (binary->internal_frame_info.res.width - binary->effective_in_frame_res.width * bds_denominator / bds_numerator - left_cropping) * bds_numerator / bds_denominator;\r\ntop_padding = binary->info->sp.pipeline.top_cropping * bds_numerator / bds_denominator - binary->info->sp.pipeline.top_cropping;\r\n#if !defined(USE_WINDOWS_BINNING_FACTOR)\r\ninput_width <<= sensor_binning;\r\ninput_height <<= sensor_binning;\r\nleft_padding <<= sensor_binning;\r\nright_padding <<= sensor_binning;\r\ntop_padding <<= sensor_binning;\r\n#else\r\ninput_width *= sensor_binning;\r\ninput_height *= sensor_binning;\r\nleft_padding *= sensor_binning;\r\nright_padding *= sensor_binning;\r\ntop_padding *= sensor_binning;\r\n#endif\r\ninput_width = min(input_width, in_table->sensor_width);\r\ninput_height = min(input_height, in_table->sensor_height);\r\n#ifndef ISP2401\r\ntable_width = binary->sctbl_width_per_color;\r\ntable_height = binary->sctbl_height;\r\n#else\r\ntable_width = binary->sctbl_legacy_width_per_color;\r\ntable_height = binary->sctbl_legacy_height;\r\n#endif\r\nresult = ia_css_shading_table_alloc(table_width, table_height);\r\nif (result == NULL) {\r\n*target_table = NULL;\r\nreturn;\r\n}\r\nresult->sensor_width = in_table->sensor_width;\r\nresult->sensor_height = in_table->sensor_height;\r\nresult->fraction_bits = in_table->fraction_bits;\r\nfor (i = 0; i < IA_CSS_SC_NUM_COLORS; i++) {\r\ncrop_and_interpolate(input_width, input_height,\r\nleft_padding, right_padding, top_padding,\r\nin_table,\r\nresult, i);\r\n}\r\n*target_table = result;\r\n}\r\nstruct ia_css_shading_table *\r\nia_css_shading_table_alloc(\r\nunsigned int width,\r\nunsigned int height)\r\n{\r\nunsigned int i;\r\nstruct ia_css_shading_table *me;\r\nIA_CSS_ENTER("");\r\nme = kmalloc(sizeof(*me), GFP_KERNEL);\r\nif (me == NULL) {\r\nIA_CSS_ERROR("out of memory");\r\nreturn me;\r\n}\r\nme->width = width;\r\nme->height = height;\r\nme->sensor_width = 0;\r\nme->sensor_height = 0;\r\nme->fraction_bits = 0;\r\nfor (i = 0; i < IA_CSS_SC_NUM_COLORS; i++) {\r\nme->data[i] =\r\nsh_css_malloc(width * height * sizeof(*me->data[0]));\r\nif (me->data[i] == NULL) {\r\nunsigned int j;\r\nfor (j = 0; j < i; j++) {\r\nsh_css_free(me->data[j]);\r\nme->data[j] = NULL;\r\n}\r\nkfree(me);\r\nreturn NULL;\r\n}\r\n}\r\nIA_CSS_LEAVE("");\r\nreturn me;\r\n}\r\nvoid\r\nia_css_shading_table_free(struct ia_css_shading_table *table)\r\n{\r\nunsigned int i;\r\nif (table == NULL)\r\nreturn;\r\nIA_CSS_ENTER("");\r\nfor (i = 0; i < IA_CSS_SC_NUM_COLORS; i++) {\r\nif (table->data[i]) {\r\nsh_css_free(table->data[i]);\r\ntable->data[i] = NULL;\r\n}\r\n}\r\nkfree(table);\r\nIA_CSS_LEAVE("");\r\n}
