static int bnx2i_adapter_ready(struct bnx2i_hba *hba)\r\n{\r\nint retval = 0;\r\nif (!hba || !test_bit(ADAPTER_STATE_UP, &hba->adapter_state) ||\r\ntest_bit(ADAPTER_STATE_GOING_DOWN, &hba->adapter_state) ||\r\ntest_bit(ADAPTER_STATE_LINK_DOWN, &hba->adapter_state))\r\nretval = -EPERM;\r\nreturn retval;\r\n}\r\nstatic void bnx2i_get_write_cmd_bd_idx(struct bnx2i_cmd *cmd, u32 buf_off,\r\nu32 *start_bd_off, u32 *start_bd_idx)\r\n{\r\nstruct iscsi_bd *bd_tbl = cmd->io_tbl.bd_tbl;\r\nu32 cur_offset = 0;\r\nu32 cur_bd_idx = 0;\r\nif (buf_off) {\r\nwhile (buf_off >= (cur_offset + bd_tbl->buffer_length)) {\r\ncur_offset += bd_tbl->buffer_length;\r\ncur_bd_idx++;\r\nbd_tbl++;\r\n}\r\n}\r\n*start_bd_off = buf_off - cur_offset;\r\n*start_bd_idx = cur_bd_idx;\r\n}\r\nstatic void bnx2i_setup_write_cmd_bd_info(struct iscsi_task *task)\r\n{\r\nstruct bnx2i_cmd *cmd = task->dd_data;\r\nu32 start_bd_offset;\r\nu32 start_bd_idx;\r\nu32 buffer_offset = 0;\r\nu32 cmd_len = cmd->req.total_data_transfer_length;\r\nif (!iscsi_task_has_unsol_data(task) && !task->imm_count)\r\nreturn;\r\nbuffer_offset += task->imm_count;\r\nif (task->imm_count == cmd_len)\r\nreturn;\r\nif (iscsi_task_has_unsol_data(task)) {\r\nbnx2i_get_write_cmd_bd_idx(cmd, buffer_offset,\r\n&start_bd_offset, &start_bd_idx);\r\ncmd->req.ud_buffer_offset = start_bd_offset;\r\ncmd->req.ud_start_bd_index = start_bd_idx;\r\nbuffer_offset += task->unsol_r2t.data_length;\r\n}\r\nif (buffer_offset != cmd_len) {\r\nbnx2i_get_write_cmd_bd_idx(cmd, buffer_offset,\r\n&start_bd_offset, &start_bd_idx);\r\nif ((start_bd_offset > task->conn->session->first_burst) ||\r\n(start_bd_idx > scsi_sg_count(cmd->scsi_cmd))) {\r\nint i = 0;\r\niscsi_conn_printk(KERN_ALERT, task->conn,\r\n"bnx2i- error, buf offset 0x%x "\r\n"bd_valid %d use_sg %d\n",\r\nbuffer_offset, cmd->io_tbl.bd_valid,\r\nscsi_sg_count(cmd->scsi_cmd));\r\nfor (i = 0; i < cmd->io_tbl.bd_valid; i++)\r\niscsi_conn_printk(KERN_ALERT, task->conn,\r\n"bnx2i err, bd[%d]: len %x\n",\r\ni, cmd->io_tbl.bd_tbl[i].\\r\nbuffer_length);\r\n}\r\ncmd->req.sd_buffer_offset = start_bd_offset;\r\ncmd->req.sd_start_bd_index = start_bd_idx;\r\n}\r\n}\r\nstatic int bnx2i_map_scsi_sg(struct bnx2i_hba *hba, struct bnx2i_cmd *cmd)\r\n{\r\nstruct scsi_cmnd *sc = cmd->scsi_cmd;\r\nstruct iscsi_bd *bd = cmd->io_tbl.bd_tbl;\r\nstruct scatterlist *sg;\r\nint byte_count = 0;\r\nint bd_count = 0;\r\nint sg_count;\r\nint sg_len;\r\nu64 addr;\r\nint i;\r\nBUG_ON(scsi_sg_count(sc) > ISCSI_MAX_BDS_PER_CMD);\r\nsg_count = scsi_dma_map(sc);\r\nscsi_for_each_sg(sc, sg, sg_count, i) {\r\nsg_len = sg_dma_len(sg);\r\naddr = (u64) sg_dma_address(sg);\r\nbd[bd_count].buffer_addr_lo = addr & 0xffffffff;\r\nbd[bd_count].buffer_addr_hi = addr >> 32;\r\nbd[bd_count].buffer_length = sg_len;\r\nbd[bd_count].flags = 0;\r\nif (bd_count == 0)\r\nbd[bd_count].flags = ISCSI_BD_FIRST_IN_BD_CHAIN;\r\nbyte_count += sg_len;\r\nbd_count++;\r\n}\r\nif (bd_count)\r\nbd[bd_count - 1].flags |= ISCSI_BD_LAST_IN_BD_CHAIN;\r\nBUG_ON(byte_count != scsi_bufflen(sc));\r\nreturn bd_count;\r\n}\r\nstatic void bnx2i_iscsi_map_sg_list(struct bnx2i_cmd *cmd)\r\n{\r\nint bd_count;\r\nbd_count = bnx2i_map_scsi_sg(cmd->conn->hba, cmd);\r\nif (!bd_count) {\r\nstruct iscsi_bd *bd = cmd->io_tbl.bd_tbl;\r\nbd[0].buffer_addr_lo = bd[0].buffer_addr_hi = 0;\r\nbd[0].buffer_length = bd[0].flags = 0;\r\n}\r\ncmd->io_tbl.bd_valid = bd_count;\r\n}\r\nvoid bnx2i_iscsi_unmap_sg_list(struct bnx2i_cmd *cmd)\r\n{\r\nstruct scsi_cmnd *sc = cmd->scsi_cmd;\r\nif (cmd->io_tbl.bd_valid && sc) {\r\nscsi_dma_unmap(sc);\r\ncmd->io_tbl.bd_valid = 0;\r\n}\r\n}\r\nstatic void bnx2i_setup_cmd_wqe_template(struct bnx2i_cmd *cmd)\r\n{\r\nmemset(&cmd->req, 0x00, sizeof(cmd->req));\r\ncmd->req.op_code = 0xFF;\r\ncmd->req.bd_list_addr_lo = (u32) cmd->io_tbl.bd_tbl_dma;\r\ncmd->req.bd_list_addr_hi =\r\n(u32) ((u64) cmd->io_tbl.bd_tbl_dma >> 32);\r\n}\r\nstatic int bnx2i_bind_conn_to_iscsi_cid(struct bnx2i_hba *hba,\r\nstruct bnx2i_conn *bnx2i_conn,\r\nu32 iscsi_cid)\r\n{\r\nif (hba && hba->cid_que.conn_cid_tbl[iscsi_cid]) {\r\niscsi_conn_printk(KERN_ALERT, bnx2i_conn->cls_conn->dd_data,\r\n"conn bind - entry #%d not free\n", iscsi_cid);\r\nreturn -EBUSY;\r\n}\r\nhba->cid_que.conn_cid_tbl[iscsi_cid] = bnx2i_conn;\r\nreturn 0;\r\n}\r\nstruct bnx2i_conn *bnx2i_get_conn_from_id(struct bnx2i_hba *hba,\r\nu16 iscsi_cid)\r\n{\r\nif (!hba->cid_que.conn_cid_tbl) {\r\nprintk(KERN_ERR "bnx2i: ERROR - missing conn<->cid table\n");\r\nreturn NULL;\r\n} else if (iscsi_cid >= hba->max_active_conns) {\r\nprintk(KERN_ERR "bnx2i: wrong cid #%d\n", iscsi_cid);\r\nreturn NULL;\r\n}\r\nreturn hba->cid_que.conn_cid_tbl[iscsi_cid];\r\n}\r\nstatic u32 bnx2i_alloc_iscsi_cid(struct bnx2i_hba *hba)\r\n{\r\nint idx;\r\nif (!hba->cid_que.cid_free_cnt)\r\nreturn -1;\r\nidx = hba->cid_que.cid_q_cons_idx;\r\nhba->cid_que.cid_q_cons_idx++;\r\nif (hba->cid_que.cid_q_cons_idx == hba->cid_que.cid_q_max_idx)\r\nhba->cid_que.cid_q_cons_idx = 0;\r\nhba->cid_que.cid_free_cnt--;\r\nreturn hba->cid_que.cid_que[idx];\r\n}\r\nstatic void bnx2i_free_iscsi_cid(struct bnx2i_hba *hba, u16 iscsi_cid)\r\n{\r\nint idx;\r\nif (iscsi_cid == (u16) -1)\r\nreturn;\r\nhba->cid_que.cid_free_cnt++;\r\nidx = hba->cid_que.cid_q_prod_idx;\r\nhba->cid_que.cid_que[idx] = iscsi_cid;\r\nhba->cid_que.conn_cid_tbl[iscsi_cid] = NULL;\r\nhba->cid_que.cid_q_prod_idx++;\r\nif (hba->cid_que.cid_q_prod_idx == hba->cid_que.cid_q_max_idx)\r\nhba->cid_que.cid_q_prod_idx = 0;\r\n}\r\nstatic int bnx2i_setup_free_cid_que(struct bnx2i_hba *hba)\r\n{\r\nint mem_size;\r\nint i;\r\nmem_size = hba->max_active_conns * sizeof(u32);\r\nmem_size = (mem_size + (PAGE_SIZE - 1)) & PAGE_MASK;\r\nhba->cid_que.cid_que_base = kmalloc(mem_size, GFP_KERNEL);\r\nif (!hba->cid_que.cid_que_base)\r\nreturn -ENOMEM;\r\nmem_size = hba->max_active_conns * sizeof(struct bnx2i_conn *);\r\nmem_size = (mem_size + (PAGE_SIZE - 1)) & PAGE_MASK;\r\nhba->cid_que.conn_cid_tbl = kmalloc(mem_size, GFP_KERNEL);\r\nif (!hba->cid_que.conn_cid_tbl) {\r\nkfree(hba->cid_que.cid_que_base);\r\nhba->cid_que.cid_que_base = NULL;\r\nreturn -ENOMEM;\r\n}\r\nhba->cid_que.cid_que = (u32 *)hba->cid_que.cid_que_base;\r\nhba->cid_que.cid_q_prod_idx = 0;\r\nhba->cid_que.cid_q_cons_idx = 0;\r\nhba->cid_que.cid_q_max_idx = hba->max_active_conns;\r\nhba->cid_que.cid_free_cnt = hba->max_active_conns;\r\nfor (i = 0; i < hba->max_active_conns; i++) {\r\nhba->cid_que.cid_que[i] = i;\r\nhba->cid_que.conn_cid_tbl[i] = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void bnx2i_release_free_cid_que(struct bnx2i_hba *hba)\r\n{\r\nkfree(hba->cid_que.cid_que_base);\r\nhba->cid_que.cid_que_base = NULL;\r\nkfree(hba->cid_que.conn_cid_tbl);\r\nhba->cid_que.conn_cid_tbl = NULL;\r\n}\r\nstatic struct iscsi_endpoint *bnx2i_alloc_ep(struct bnx2i_hba *hba)\r\n{\r\nstruct iscsi_endpoint *ep;\r\nstruct bnx2i_endpoint *bnx2i_ep;\r\nu32 ec_div;\r\nep = iscsi_create_endpoint(sizeof(*bnx2i_ep));\r\nif (!ep) {\r\nprintk(KERN_ERR "bnx2i: Could not allocate ep\n");\r\nreturn NULL;\r\n}\r\nbnx2i_ep = ep->dd_data;\r\nbnx2i_ep->cls_ep = ep;\r\nINIT_LIST_HEAD(&bnx2i_ep->link);\r\nbnx2i_ep->state = EP_STATE_IDLE;\r\nbnx2i_ep->ep_iscsi_cid = (u16) -1;\r\nbnx2i_ep->hba = hba;\r\nbnx2i_ep->hba_age = hba->age;\r\nec_div = event_coal_div;\r\nwhile (ec_div >>= 1)\r\nbnx2i_ep->ec_shift += 1;\r\nhba->ofld_conns_active++;\r\ninit_waitqueue_head(&bnx2i_ep->ofld_wait);\r\nreturn ep;\r\n}\r\nstatic void bnx2i_free_ep(struct iscsi_endpoint *ep)\r\n{\r\nstruct bnx2i_endpoint *bnx2i_ep = ep->dd_data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&bnx2i_resc_lock, flags);\r\nbnx2i_ep->state = EP_STATE_IDLE;\r\nbnx2i_ep->hba->ofld_conns_active--;\r\nif (bnx2i_ep->ep_iscsi_cid != (u16) -1)\r\nbnx2i_free_iscsi_cid(bnx2i_ep->hba, bnx2i_ep->ep_iscsi_cid);\r\nif (bnx2i_ep->conn) {\r\nbnx2i_ep->conn->ep = NULL;\r\nbnx2i_ep->conn = NULL;\r\n}\r\nbnx2i_ep->hba = NULL;\r\nspin_unlock_irqrestore(&bnx2i_resc_lock, flags);\r\niscsi_destroy_endpoint(ep);\r\n}\r\nstatic int bnx2i_alloc_bdt(struct bnx2i_hba *hba, struct iscsi_session *session,\r\nstruct bnx2i_cmd *cmd)\r\n{\r\nstruct io_bdt *io = &cmd->io_tbl;\r\nstruct iscsi_bd *bd;\r\nio->bd_tbl = dma_alloc_coherent(&hba->pcidev->dev,\r\nISCSI_MAX_BDS_PER_CMD * sizeof(*bd),\r\n&io->bd_tbl_dma, GFP_KERNEL);\r\nif (!io->bd_tbl) {\r\niscsi_session_printk(KERN_ERR, session, "Could not "\r\n"allocate bdt.\n");\r\nreturn -ENOMEM;\r\n}\r\nio->bd_valid = 0;\r\nreturn 0;\r\n}\r\nstatic void bnx2i_destroy_cmd_pool(struct bnx2i_hba *hba,\r\nstruct iscsi_session *session)\r\n{\r\nint i;\r\nfor (i = 0; i < session->cmds_max; i++) {\r\nstruct iscsi_task *task = session->cmds[i];\r\nstruct bnx2i_cmd *cmd = task->dd_data;\r\nif (cmd->io_tbl.bd_tbl)\r\ndma_free_coherent(&hba->pcidev->dev,\r\nISCSI_MAX_BDS_PER_CMD *\r\nsizeof(struct iscsi_bd),\r\ncmd->io_tbl.bd_tbl,\r\ncmd->io_tbl.bd_tbl_dma);\r\n}\r\n}\r\nstatic int bnx2i_setup_cmd_pool(struct bnx2i_hba *hba,\r\nstruct iscsi_session *session)\r\n{\r\nint i;\r\nfor (i = 0; i < session->cmds_max; i++) {\r\nstruct iscsi_task *task = session->cmds[i];\r\nstruct bnx2i_cmd *cmd = task->dd_data;\r\ntask->hdr = &cmd->hdr;\r\ntask->hdr_max = sizeof(struct iscsi_hdr);\r\nif (bnx2i_alloc_bdt(hba, session, cmd))\r\ngoto free_bdts;\r\n}\r\nreturn 0;\r\nfree_bdts:\r\nbnx2i_destroy_cmd_pool(hba, session);\r\nreturn -ENOMEM;\r\n}\r\nstatic int bnx2i_setup_mp_bdt(struct bnx2i_hba *hba)\r\n{\r\nint rc = 0;\r\nstruct iscsi_bd *mp_bdt;\r\nu64 addr;\r\nhba->mp_bd_tbl = dma_alloc_coherent(&hba->pcidev->dev, CNIC_PAGE_SIZE,\r\n&hba->mp_bd_dma, GFP_KERNEL);\r\nif (!hba->mp_bd_tbl) {\r\nprintk(KERN_ERR "unable to allocate Middle Path BDT\n");\r\nrc = -1;\r\ngoto out;\r\n}\r\nhba->dummy_buffer = dma_alloc_coherent(&hba->pcidev->dev,\r\nCNIC_PAGE_SIZE,\r\n&hba->dummy_buf_dma, GFP_KERNEL);\r\nif (!hba->dummy_buffer) {\r\nprintk(KERN_ERR "unable to alloc Middle Path Dummy Buffer\n");\r\ndma_free_coherent(&hba->pcidev->dev, CNIC_PAGE_SIZE,\r\nhba->mp_bd_tbl, hba->mp_bd_dma);\r\nhba->mp_bd_tbl = NULL;\r\nrc = -1;\r\ngoto out;\r\n}\r\nmp_bdt = (struct iscsi_bd *) hba->mp_bd_tbl;\r\naddr = (unsigned long) hba->dummy_buf_dma;\r\nmp_bdt->buffer_addr_lo = addr & 0xffffffff;\r\nmp_bdt->buffer_addr_hi = addr >> 32;\r\nmp_bdt->buffer_length = CNIC_PAGE_SIZE;\r\nmp_bdt->flags = ISCSI_BD_LAST_IN_BD_CHAIN |\r\nISCSI_BD_FIRST_IN_BD_CHAIN;\r\nout:\r\nreturn rc;\r\n}\r\nstatic void bnx2i_free_mp_bdt(struct bnx2i_hba *hba)\r\n{\r\nif (hba->mp_bd_tbl) {\r\ndma_free_coherent(&hba->pcidev->dev, CNIC_PAGE_SIZE,\r\nhba->mp_bd_tbl, hba->mp_bd_dma);\r\nhba->mp_bd_tbl = NULL;\r\n}\r\nif (hba->dummy_buffer) {\r\ndma_free_coherent(&hba->pcidev->dev, CNIC_PAGE_SIZE,\r\nhba->dummy_buffer, hba->dummy_buf_dma);\r\nhba->dummy_buffer = NULL;\r\n}\r\nreturn;\r\n}\r\nvoid bnx2i_drop_session(struct iscsi_cls_session *cls_session)\r\n{\r\niscsi_session_failure(cls_session->dd_data, ISCSI_ERR_CONN_FAILED);\r\n}\r\nstatic int bnx2i_ep_destroy_list_add(struct bnx2i_hba *hba,\r\nstruct bnx2i_endpoint *ep)\r\n{\r\nwrite_lock_bh(&hba->ep_rdwr_lock);\r\nlist_add_tail(&ep->link, &hba->ep_destroy_list);\r\nwrite_unlock_bh(&hba->ep_rdwr_lock);\r\nreturn 0;\r\n}\r\nstatic int bnx2i_ep_destroy_list_del(struct bnx2i_hba *hba,\r\nstruct bnx2i_endpoint *ep)\r\n{\r\nwrite_lock_bh(&hba->ep_rdwr_lock);\r\nlist_del_init(&ep->link);\r\nwrite_unlock_bh(&hba->ep_rdwr_lock);\r\nreturn 0;\r\n}\r\nstatic int bnx2i_ep_ofld_list_add(struct bnx2i_hba *hba,\r\nstruct bnx2i_endpoint *ep)\r\n{\r\nwrite_lock_bh(&hba->ep_rdwr_lock);\r\nlist_add_tail(&ep->link, &hba->ep_ofld_list);\r\nwrite_unlock_bh(&hba->ep_rdwr_lock);\r\nreturn 0;\r\n}\r\nstatic int bnx2i_ep_ofld_list_del(struct bnx2i_hba *hba,\r\nstruct bnx2i_endpoint *ep)\r\n{\r\nwrite_lock_bh(&hba->ep_rdwr_lock);\r\nlist_del_init(&ep->link);\r\nwrite_unlock_bh(&hba->ep_rdwr_lock);\r\nreturn 0;\r\n}\r\nstruct bnx2i_endpoint *\r\nbnx2i_find_ep_in_ofld_list(struct bnx2i_hba *hba, u32 iscsi_cid)\r\n{\r\nstruct list_head *list;\r\nstruct list_head *tmp;\r\nstruct bnx2i_endpoint *ep = NULL;\r\nread_lock_bh(&hba->ep_rdwr_lock);\r\nlist_for_each_safe(list, tmp, &hba->ep_ofld_list) {\r\nep = (struct bnx2i_endpoint *)list;\r\nif (ep->ep_iscsi_cid == iscsi_cid)\r\nbreak;\r\nep = NULL;\r\n}\r\nread_unlock_bh(&hba->ep_rdwr_lock);\r\nif (!ep)\r\nprintk(KERN_ERR "l5 cid %d not found\n", iscsi_cid);\r\nreturn ep;\r\n}\r\nstruct bnx2i_endpoint *\r\nbnx2i_find_ep_in_destroy_list(struct bnx2i_hba *hba, u32 iscsi_cid)\r\n{\r\nstruct list_head *list;\r\nstruct list_head *tmp;\r\nstruct bnx2i_endpoint *ep = NULL;\r\nread_lock_bh(&hba->ep_rdwr_lock);\r\nlist_for_each_safe(list, tmp, &hba->ep_destroy_list) {\r\nep = (struct bnx2i_endpoint *)list;\r\nif (ep->ep_iscsi_cid == iscsi_cid)\r\nbreak;\r\nep = NULL;\r\n}\r\nread_unlock_bh(&hba->ep_rdwr_lock);\r\nif (!ep)\r\nprintk(KERN_ERR "l5 cid %d not found\n", iscsi_cid);\r\nreturn ep;\r\n}\r\nstatic void bnx2i_ep_active_list_add(struct bnx2i_hba *hba,\r\nstruct bnx2i_endpoint *ep)\r\n{\r\nwrite_lock_bh(&hba->ep_rdwr_lock);\r\nlist_add_tail(&ep->link, &hba->ep_active_list);\r\nwrite_unlock_bh(&hba->ep_rdwr_lock);\r\n}\r\nstatic void bnx2i_ep_active_list_del(struct bnx2i_hba *hba,\r\nstruct bnx2i_endpoint *ep)\r\n{\r\nwrite_lock_bh(&hba->ep_rdwr_lock);\r\nlist_del_init(&ep->link);\r\nwrite_unlock_bh(&hba->ep_rdwr_lock);\r\n}\r\nstatic void bnx2i_setup_host_queue_size(struct bnx2i_hba *hba,\r\nstruct Scsi_Host *shost)\r\n{\r\nif (test_bit(BNX2I_NX2_DEV_5708, &hba->cnic_dev_type))\r\nshost->can_queue = ISCSI_MAX_CMDS_PER_HBA_5708;\r\nelse if (test_bit(BNX2I_NX2_DEV_5709, &hba->cnic_dev_type))\r\nshost->can_queue = ISCSI_MAX_CMDS_PER_HBA_5709;\r\nelse if (test_bit(BNX2I_NX2_DEV_57710, &hba->cnic_dev_type))\r\nshost->can_queue = ISCSI_MAX_CMDS_PER_HBA_57710;\r\nelse\r\nshost->can_queue = ISCSI_MAX_CMDS_PER_HBA_5708;\r\n}\r\nstruct bnx2i_hba *bnx2i_alloc_hba(struct cnic_dev *cnic)\r\n{\r\nstruct Scsi_Host *shost;\r\nstruct bnx2i_hba *hba;\r\nshost = iscsi_host_alloc(&bnx2i_host_template, sizeof(*hba), 0);\r\nif (!shost)\r\nreturn NULL;\r\nshost->dma_boundary = cnic->pcidev->dma_mask;\r\nshost->transportt = bnx2i_scsi_xport_template;\r\nshost->max_id = ISCSI_MAX_CONNS_PER_HBA;\r\nshost->max_channel = 0;\r\nshost->max_lun = 512;\r\nshost->max_cmd_len = 16;\r\nhba = iscsi_host_priv(shost);\r\nhba->shost = shost;\r\nhba->netdev = cnic->netdev;\r\nhba->pcidev = cnic->pcidev;\r\npci_dev_get(hba->pcidev);\r\nhba->pci_did = hba->pcidev->device;\r\nhba->pci_vid = hba->pcidev->vendor;\r\nhba->pci_sdid = hba->pcidev->subsystem_device;\r\nhba->pci_svid = hba->pcidev->subsystem_vendor;\r\nhba->pci_func = PCI_FUNC(hba->pcidev->devfn);\r\nhba->pci_devno = PCI_SLOT(hba->pcidev->devfn);\r\nbnx2i_identify_device(hba, cnic);\r\nbnx2i_setup_host_queue_size(hba, shost);\r\nhba->reg_base = pci_resource_start(hba->pcidev, 0);\r\nif (test_bit(BNX2I_NX2_DEV_5709, &hba->cnic_dev_type)) {\r\nhba->regview = pci_iomap(hba->pcidev, 0, BNX2_MQ_CONFIG2);\r\nif (!hba->regview)\r\ngoto ioreg_map_err;\r\n} else if (test_bit(BNX2I_NX2_DEV_57710, &hba->cnic_dev_type)) {\r\nhba->regview = pci_iomap(hba->pcidev, 0, 4096);\r\nif (!hba->regview)\r\ngoto ioreg_map_err;\r\n}\r\nif (bnx2i_setup_mp_bdt(hba))\r\ngoto mp_bdt_mem_err;\r\nINIT_LIST_HEAD(&hba->ep_ofld_list);\r\nINIT_LIST_HEAD(&hba->ep_active_list);\r\nINIT_LIST_HEAD(&hba->ep_destroy_list);\r\nrwlock_init(&hba->ep_rdwr_lock);\r\nhba->mtu_supported = BNX2I_MAX_MTU_SUPPORTED;\r\nhba->max_active_conns = ISCSI_MAX_CONNS_PER_HBA;\r\nif (bnx2i_setup_free_cid_que(hba))\r\ngoto cid_que_err;\r\nif (test_bit(BNX2I_NX2_DEV_57710, &hba->cnic_dev_type)) {\r\nif (sq_size && sq_size <= BNX2I_5770X_SQ_WQES_MAX)\r\nhba->max_sqes = sq_size;\r\nelse\r\nhba->max_sqes = BNX2I_5770X_SQ_WQES_DEFAULT;\r\n} else {\r\nif (sq_size && sq_size <= BNX2I_570X_SQ_WQES_MAX)\r\nhba->max_sqes = sq_size;\r\nelse\r\nhba->max_sqes = BNX2I_570X_SQ_WQES_DEFAULT;\r\n}\r\nhba->max_rqes = rq_size;\r\nhba->max_cqes = hba->max_sqes + rq_size;\r\nif (test_bit(BNX2I_NX2_DEV_57710, &hba->cnic_dev_type)) {\r\nif (hba->max_cqes > BNX2I_5770X_CQ_WQES_MAX)\r\nhba->max_cqes = BNX2I_5770X_CQ_WQES_MAX;\r\n} else if (hba->max_cqes > BNX2I_570X_CQ_WQES_MAX)\r\nhba->max_cqes = BNX2I_570X_CQ_WQES_MAX;\r\nhba->num_ccell = hba->max_sqes / 2;\r\nspin_lock_init(&hba->lock);\r\nmutex_init(&hba->net_dev_lock);\r\ninit_waitqueue_head(&hba->eh_wait);\r\nif (test_bit(BNX2I_NX2_DEV_57710, &hba->cnic_dev_type)) {\r\nhba->hba_shutdown_tmo = 30 * HZ;\r\nhba->conn_teardown_tmo = 20 * HZ;\r\nhba->conn_ctx_destroy_tmo = 6 * HZ;\r\n} else {\r\nhba->hba_shutdown_tmo = 20 * HZ;\r\nhba->conn_teardown_tmo = 10 * HZ;\r\nhba->conn_ctx_destroy_tmo = 2 * HZ;\r\n}\r\n#ifdef CONFIG_32BIT\r\nspin_lock_init(&hba->stat_lock);\r\n#endif\r\nmemset(&hba->stats, 0, sizeof(struct iscsi_stats_info));\r\nif (iscsi_host_add(shost, &hba->pcidev->dev))\r\ngoto free_dump_mem;\r\nreturn hba;\r\nfree_dump_mem:\r\nbnx2i_release_free_cid_que(hba);\r\ncid_que_err:\r\nbnx2i_free_mp_bdt(hba);\r\nmp_bdt_mem_err:\r\nif (hba->regview) {\r\npci_iounmap(hba->pcidev, hba->regview);\r\nhba->regview = NULL;\r\n}\r\nioreg_map_err:\r\npci_dev_put(hba->pcidev);\r\nscsi_host_put(shost);\r\nreturn NULL;\r\n}\r\nvoid bnx2i_free_hba(struct bnx2i_hba *hba)\r\n{\r\nstruct Scsi_Host *shost = hba->shost;\r\niscsi_host_remove(shost);\r\nINIT_LIST_HEAD(&hba->ep_ofld_list);\r\nINIT_LIST_HEAD(&hba->ep_active_list);\r\nINIT_LIST_HEAD(&hba->ep_destroy_list);\r\npci_dev_put(hba->pcidev);\r\nif (hba->regview) {\r\npci_iounmap(hba->pcidev, hba->regview);\r\nhba->regview = NULL;\r\n}\r\nbnx2i_free_mp_bdt(hba);\r\nbnx2i_release_free_cid_que(hba);\r\niscsi_host_free(shost);\r\n}\r\nstatic void bnx2i_conn_free_login_resources(struct bnx2i_hba *hba,\r\nstruct bnx2i_conn *bnx2i_conn)\r\n{\r\nif (bnx2i_conn->gen_pdu.resp_bd_tbl) {\r\ndma_free_coherent(&hba->pcidev->dev, CNIC_PAGE_SIZE,\r\nbnx2i_conn->gen_pdu.resp_bd_tbl,\r\nbnx2i_conn->gen_pdu.resp_bd_dma);\r\nbnx2i_conn->gen_pdu.resp_bd_tbl = NULL;\r\n}\r\nif (bnx2i_conn->gen_pdu.req_bd_tbl) {\r\ndma_free_coherent(&hba->pcidev->dev, CNIC_PAGE_SIZE,\r\nbnx2i_conn->gen_pdu.req_bd_tbl,\r\nbnx2i_conn->gen_pdu.req_bd_dma);\r\nbnx2i_conn->gen_pdu.req_bd_tbl = NULL;\r\n}\r\nif (bnx2i_conn->gen_pdu.resp_buf) {\r\ndma_free_coherent(&hba->pcidev->dev,\r\nISCSI_DEF_MAX_RECV_SEG_LEN,\r\nbnx2i_conn->gen_pdu.resp_buf,\r\nbnx2i_conn->gen_pdu.resp_dma_addr);\r\nbnx2i_conn->gen_pdu.resp_buf = NULL;\r\n}\r\nif (bnx2i_conn->gen_pdu.req_buf) {\r\ndma_free_coherent(&hba->pcidev->dev,\r\nISCSI_DEF_MAX_RECV_SEG_LEN,\r\nbnx2i_conn->gen_pdu.req_buf,\r\nbnx2i_conn->gen_pdu.req_dma_addr);\r\nbnx2i_conn->gen_pdu.req_buf = NULL;\r\n}\r\n}\r\nstatic int bnx2i_conn_alloc_login_resources(struct bnx2i_hba *hba,\r\nstruct bnx2i_conn *bnx2i_conn)\r\n{\r\nbnx2i_conn->gen_pdu.req_buf =\r\ndma_alloc_coherent(&hba->pcidev->dev,\r\nISCSI_DEF_MAX_RECV_SEG_LEN,\r\n&bnx2i_conn->gen_pdu.req_dma_addr,\r\nGFP_KERNEL);\r\nif (bnx2i_conn->gen_pdu.req_buf == NULL)\r\ngoto login_req_buf_failure;\r\nbnx2i_conn->gen_pdu.req_buf_size = 0;\r\nbnx2i_conn->gen_pdu.req_wr_ptr = bnx2i_conn->gen_pdu.req_buf;\r\nbnx2i_conn->gen_pdu.resp_buf =\r\ndma_alloc_coherent(&hba->pcidev->dev,\r\nISCSI_DEF_MAX_RECV_SEG_LEN,\r\n&bnx2i_conn->gen_pdu.resp_dma_addr,\r\nGFP_KERNEL);\r\nif (bnx2i_conn->gen_pdu.resp_buf == NULL)\r\ngoto login_resp_buf_failure;\r\nbnx2i_conn->gen_pdu.resp_buf_size = ISCSI_DEF_MAX_RECV_SEG_LEN;\r\nbnx2i_conn->gen_pdu.resp_wr_ptr = bnx2i_conn->gen_pdu.resp_buf;\r\nbnx2i_conn->gen_pdu.req_bd_tbl =\r\ndma_alloc_coherent(&hba->pcidev->dev, CNIC_PAGE_SIZE,\r\n&bnx2i_conn->gen_pdu.req_bd_dma, GFP_KERNEL);\r\nif (bnx2i_conn->gen_pdu.req_bd_tbl == NULL)\r\ngoto login_req_bd_tbl_failure;\r\nbnx2i_conn->gen_pdu.resp_bd_tbl =\r\ndma_alloc_coherent(&hba->pcidev->dev, CNIC_PAGE_SIZE,\r\n&bnx2i_conn->gen_pdu.resp_bd_dma,\r\nGFP_KERNEL);\r\nif (bnx2i_conn->gen_pdu.resp_bd_tbl == NULL)\r\ngoto login_resp_bd_tbl_failure;\r\nreturn 0;\r\nlogin_resp_bd_tbl_failure:\r\ndma_free_coherent(&hba->pcidev->dev, CNIC_PAGE_SIZE,\r\nbnx2i_conn->gen_pdu.req_bd_tbl,\r\nbnx2i_conn->gen_pdu.req_bd_dma);\r\nbnx2i_conn->gen_pdu.req_bd_tbl = NULL;\r\nlogin_req_bd_tbl_failure:\r\ndma_free_coherent(&hba->pcidev->dev, ISCSI_DEF_MAX_RECV_SEG_LEN,\r\nbnx2i_conn->gen_pdu.resp_buf,\r\nbnx2i_conn->gen_pdu.resp_dma_addr);\r\nbnx2i_conn->gen_pdu.resp_buf = NULL;\r\nlogin_resp_buf_failure:\r\ndma_free_coherent(&hba->pcidev->dev, ISCSI_DEF_MAX_RECV_SEG_LEN,\r\nbnx2i_conn->gen_pdu.req_buf,\r\nbnx2i_conn->gen_pdu.req_dma_addr);\r\nbnx2i_conn->gen_pdu.req_buf = NULL;\r\nlogin_req_buf_failure:\r\niscsi_conn_printk(KERN_ERR, bnx2i_conn->cls_conn->dd_data,\r\n"login resource alloc failed!!\n");\r\nreturn -ENOMEM;\r\n}\r\nstatic void bnx2i_iscsi_prep_generic_pdu_bd(struct bnx2i_conn *bnx2i_conn)\r\n{\r\nstruct iscsi_bd *bd_tbl;\r\nbd_tbl = (struct iscsi_bd *) bnx2i_conn->gen_pdu.req_bd_tbl;\r\nbd_tbl->buffer_addr_hi =\r\n(u32) ((u64) bnx2i_conn->gen_pdu.req_dma_addr >> 32);\r\nbd_tbl->buffer_addr_lo = (u32) bnx2i_conn->gen_pdu.req_dma_addr;\r\nbd_tbl->buffer_length = bnx2i_conn->gen_pdu.req_wr_ptr -\r\nbnx2i_conn->gen_pdu.req_buf;\r\nbd_tbl->reserved0 = 0;\r\nbd_tbl->flags = ISCSI_BD_LAST_IN_BD_CHAIN |\r\nISCSI_BD_FIRST_IN_BD_CHAIN;\r\nbd_tbl = (struct iscsi_bd *) bnx2i_conn->gen_pdu.resp_bd_tbl;\r\nbd_tbl->buffer_addr_hi = (u64) bnx2i_conn->gen_pdu.resp_dma_addr >> 32;\r\nbd_tbl->buffer_addr_lo = (u32) bnx2i_conn->gen_pdu.resp_dma_addr;\r\nbd_tbl->buffer_length = ISCSI_DEF_MAX_RECV_SEG_LEN;\r\nbd_tbl->reserved0 = 0;\r\nbd_tbl->flags = ISCSI_BD_LAST_IN_BD_CHAIN |\r\nISCSI_BD_FIRST_IN_BD_CHAIN;\r\n}\r\nstatic int bnx2i_iscsi_send_generic_request(struct iscsi_task *task)\r\n{\r\nstruct bnx2i_cmd *cmd = task->dd_data;\r\nstruct bnx2i_conn *bnx2i_conn = cmd->conn;\r\nint rc = 0;\r\nchar *buf;\r\nint data_len;\r\nbnx2i_iscsi_prep_generic_pdu_bd(bnx2i_conn);\r\nswitch (task->hdr->opcode & ISCSI_OPCODE_MASK) {\r\ncase ISCSI_OP_LOGIN:\r\nbnx2i_send_iscsi_login(bnx2i_conn, task);\r\nbreak;\r\ncase ISCSI_OP_NOOP_OUT:\r\ndata_len = bnx2i_conn->gen_pdu.req_buf_size;\r\nbuf = bnx2i_conn->gen_pdu.req_buf;\r\nif (data_len)\r\nrc = bnx2i_send_iscsi_nopout(bnx2i_conn, task,\r\nbuf, data_len, 1);\r\nelse\r\nrc = bnx2i_send_iscsi_nopout(bnx2i_conn, task,\r\nNULL, 0, 1);\r\nbreak;\r\ncase ISCSI_OP_LOGOUT:\r\nrc = bnx2i_send_iscsi_logout(bnx2i_conn, task);\r\nbreak;\r\ncase ISCSI_OP_SCSI_TMFUNC:\r\nrc = bnx2i_send_iscsi_tmf(bnx2i_conn, task);\r\nbreak;\r\ncase ISCSI_OP_TEXT:\r\nrc = bnx2i_send_iscsi_text(bnx2i_conn, task);\r\nbreak;\r\ndefault:\r\niscsi_conn_printk(KERN_ALERT, bnx2i_conn->cls_conn->dd_data,\r\n"send_gen: unsupported op 0x%x\n",\r\ntask->hdr->opcode);\r\n}\r\nreturn rc;\r\n}\r\nstatic void bnx2i_cpy_scsi_cdb(struct scsi_cmnd *sc, struct bnx2i_cmd *cmd)\r\n{\r\nu32 dword;\r\nint lpcnt;\r\nu8 *srcp;\r\nu32 *dstp;\r\nu32 scsi_lun[2];\r\nint_to_scsilun(sc->device->lun, (struct scsi_lun *) scsi_lun);\r\ncmd->req.lun[0] = be32_to_cpu(scsi_lun[0]);\r\ncmd->req.lun[1] = be32_to_cpu(scsi_lun[1]);\r\nlpcnt = cmd->scsi_cmd->cmd_len / sizeof(dword);\r\nsrcp = (u8 *) sc->cmnd;\r\ndstp = (u32 *) cmd->req.cdb;\r\nwhile (lpcnt--) {\r\nmemcpy(&dword, (const void *) srcp, 4);\r\n*dstp = cpu_to_be32(dword);\r\nsrcp += 4;\r\ndstp++;\r\n}\r\nif (sc->cmd_len & 0x3) {\r\ndword = (u32) srcp[0] | ((u32) srcp[1] << 8);\r\n*dstp = cpu_to_be32(dword);\r\n}\r\n}\r\nstatic void bnx2i_cleanup_task(struct iscsi_task *task)\r\n{\r\nstruct iscsi_conn *conn = task->conn;\r\nstruct bnx2i_conn *bnx2i_conn = conn->dd_data;\r\nstruct bnx2i_hba *hba = bnx2i_conn->hba;\r\nif (!task->sc || task->state == ISCSI_TASK_PENDING)\r\nreturn;\r\nif (task->state == ISCSI_TASK_ABRT_TMF) {\r\nbnx2i_send_cmd_cleanup_req(hba, task->dd_data);\r\nspin_unlock_bh(&conn->session->back_lock);\r\nspin_unlock_bh(&conn->session->frwd_lock);\r\nwait_for_completion_timeout(&bnx2i_conn->cmd_cleanup_cmpl,\r\nmsecs_to_jiffies(ISCSI_CMD_CLEANUP_TIMEOUT));\r\nspin_lock_bh(&conn->session->frwd_lock);\r\nspin_lock_bh(&conn->session->back_lock);\r\n}\r\nbnx2i_iscsi_unmap_sg_list(task->dd_data);\r\n}\r\nstatic int\r\nbnx2i_mtask_xmit(struct iscsi_conn *conn, struct iscsi_task *task)\r\n{\r\nstruct bnx2i_conn *bnx2i_conn = conn->dd_data;\r\nstruct bnx2i_hba *hba = bnx2i_conn->hba;\r\nstruct bnx2i_cmd *cmd = task->dd_data;\r\nmemset(bnx2i_conn->gen_pdu.req_buf, 0, ISCSI_DEF_MAX_RECV_SEG_LEN);\r\nbnx2i_setup_cmd_wqe_template(cmd);\r\nbnx2i_conn->gen_pdu.req_buf_size = task->data_count;\r\nADD_STATS_64(hba, tx_pdus, 1);\r\nADD_STATS_64(hba, tx_bytes, task->data_count);\r\nif (task->data_count) {\r\nmemcpy(bnx2i_conn->gen_pdu.req_buf, task->data,\r\ntask->data_count);\r\nbnx2i_conn->gen_pdu.req_wr_ptr =\r\nbnx2i_conn->gen_pdu.req_buf + task->data_count;\r\n}\r\ncmd->conn = conn->dd_data;\r\ncmd->scsi_cmd = NULL;\r\nreturn bnx2i_iscsi_send_generic_request(task);\r\n}\r\nstatic int bnx2i_task_xmit(struct iscsi_task *task)\r\n{\r\nstruct iscsi_conn *conn = task->conn;\r\nstruct iscsi_session *session = conn->session;\r\nstruct Scsi_Host *shost = iscsi_session_to_shost(session->cls_session);\r\nstruct bnx2i_hba *hba = iscsi_host_priv(shost);\r\nstruct bnx2i_conn *bnx2i_conn = conn->dd_data;\r\nstruct scsi_cmnd *sc = task->sc;\r\nstruct bnx2i_cmd *cmd = task->dd_data;\r\nstruct iscsi_scsi_req *hdr = (struct iscsi_scsi_req *)task->hdr;\r\nif (atomic_read(&bnx2i_conn->ep->num_active_cmds) + 1 >\r\nhba->max_sqes)\r\nreturn -ENOMEM;\r\nif (!sc)\r\nreturn bnx2i_mtask_xmit(conn, task);\r\nbnx2i_setup_cmd_wqe_template(cmd);\r\ncmd->req.op_code = ISCSI_OP_SCSI_CMD;\r\ncmd->conn = bnx2i_conn;\r\ncmd->scsi_cmd = sc;\r\ncmd->req.total_data_transfer_length = scsi_bufflen(sc);\r\ncmd->req.cmd_sn = be32_to_cpu(hdr->cmdsn);\r\nbnx2i_iscsi_map_sg_list(cmd);\r\nbnx2i_cpy_scsi_cdb(sc, cmd);\r\ncmd->req.op_attr = ISCSI_ATTR_SIMPLE;\r\nif (sc->sc_data_direction == DMA_TO_DEVICE) {\r\ncmd->req.op_attr |= ISCSI_CMD_REQUEST_WRITE;\r\ncmd->req.itt = task->itt |\r\n(ISCSI_TASK_TYPE_WRITE << ISCSI_CMD_REQUEST_TYPE_SHIFT);\r\nbnx2i_setup_write_cmd_bd_info(task);\r\n} else {\r\nif (scsi_bufflen(sc))\r\ncmd->req.op_attr |= ISCSI_CMD_REQUEST_READ;\r\ncmd->req.itt = task->itt |\r\n(ISCSI_TASK_TYPE_READ << ISCSI_CMD_REQUEST_TYPE_SHIFT);\r\n}\r\ncmd->req.num_bds = cmd->io_tbl.bd_valid;\r\nif (!cmd->io_tbl.bd_valid) {\r\ncmd->req.bd_list_addr_lo = (u32) hba->mp_bd_dma;\r\ncmd->req.bd_list_addr_hi = (u32) ((u64) hba->mp_bd_dma >> 32);\r\ncmd->req.num_bds = 1;\r\n}\r\nbnx2i_send_iscsi_scsicmd(bnx2i_conn, cmd);\r\nreturn 0;\r\n}\r\nstatic struct iscsi_cls_session *\r\nbnx2i_session_create(struct iscsi_endpoint *ep,\r\nuint16_t cmds_max, uint16_t qdepth,\r\nuint32_t initial_cmdsn)\r\n{\r\nstruct Scsi_Host *shost;\r\nstruct iscsi_cls_session *cls_session;\r\nstruct bnx2i_hba *hba;\r\nstruct bnx2i_endpoint *bnx2i_ep;\r\nif (!ep) {\r\nprintk(KERN_ERR "bnx2i: missing ep.\n");\r\nreturn NULL;\r\n}\r\nbnx2i_ep = ep->dd_data;\r\nshost = bnx2i_ep->hba->shost;\r\nhba = iscsi_host_priv(shost);\r\nif (bnx2i_adapter_ready(hba))\r\nreturn NULL;\r\nif (cmds_max > hba->max_sqes)\r\ncmds_max = hba->max_sqes;\r\nelse if (cmds_max < BNX2I_SQ_WQES_MIN)\r\ncmds_max = BNX2I_SQ_WQES_MIN;\r\ncls_session = iscsi_session_setup(&bnx2i_iscsi_transport, shost,\r\ncmds_max, 0, sizeof(struct bnx2i_cmd),\r\ninitial_cmdsn, ISCSI_MAX_TARGET);\r\nif (!cls_session)\r\nreturn NULL;\r\nif (bnx2i_setup_cmd_pool(hba, cls_session->dd_data))\r\ngoto session_teardown;\r\nreturn cls_session;\r\nsession_teardown:\r\niscsi_session_teardown(cls_session);\r\nreturn NULL;\r\n}\r\nstatic void bnx2i_session_destroy(struct iscsi_cls_session *cls_session)\r\n{\r\nstruct iscsi_session *session = cls_session->dd_data;\r\nstruct Scsi_Host *shost = iscsi_session_to_shost(cls_session);\r\nstruct bnx2i_hba *hba = iscsi_host_priv(shost);\r\nbnx2i_destroy_cmd_pool(hba, session);\r\niscsi_session_teardown(cls_session);\r\n}\r\nstatic struct iscsi_cls_conn *\r\nbnx2i_conn_create(struct iscsi_cls_session *cls_session, uint32_t cid)\r\n{\r\nstruct Scsi_Host *shost = iscsi_session_to_shost(cls_session);\r\nstruct bnx2i_hba *hba = iscsi_host_priv(shost);\r\nstruct bnx2i_conn *bnx2i_conn;\r\nstruct iscsi_cls_conn *cls_conn;\r\nstruct iscsi_conn *conn;\r\ncls_conn = iscsi_conn_setup(cls_session, sizeof(*bnx2i_conn),\r\ncid);\r\nif (!cls_conn)\r\nreturn NULL;\r\nconn = cls_conn->dd_data;\r\nbnx2i_conn = conn->dd_data;\r\nbnx2i_conn->cls_conn = cls_conn;\r\nbnx2i_conn->hba = hba;\r\natomic_set(&bnx2i_conn->work_cnt, 0);\r\nbnx2i_conn->ep = NULL;\r\ninit_completion(&bnx2i_conn->cmd_cleanup_cmpl);\r\nif (bnx2i_conn_alloc_login_resources(hba, bnx2i_conn)) {\r\niscsi_conn_printk(KERN_ALERT, conn,\r\n"conn_new: login resc alloc failed!!\n");\r\ngoto free_conn;\r\n}\r\nreturn cls_conn;\r\nfree_conn:\r\niscsi_conn_teardown(cls_conn);\r\nreturn NULL;\r\n}\r\nstatic int bnx2i_conn_bind(struct iscsi_cls_session *cls_session,\r\nstruct iscsi_cls_conn *cls_conn,\r\nuint64_t transport_fd, int is_leading)\r\n{\r\nstruct iscsi_conn *conn = cls_conn->dd_data;\r\nstruct bnx2i_conn *bnx2i_conn = conn->dd_data;\r\nstruct Scsi_Host *shost = iscsi_session_to_shost(cls_session);\r\nstruct bnx2i_hba *hba = iscsi_host_priv(shost);\r\nstruct bnx2i_endpoint *bnx2i_ep;\r\nstruct iscsi_endpoint *ep;\r\nint ret_code;\r\nep = iscsi_lookup_endpoint(transport_fd);\r\nif (!ep)\r\nreturn -EINVAL;\r\nif (bnx2i_adapter_ready(hba))\r\nreturn -EIO;\r\nbnx2i_ep = ep->dd_data;\r\nif ((bnx2i_ep->state == EP_STATE_TCP_FIN_RCVD) ||\r\n(bnx2i_ep->state == EP_STATE_TCP_RST_RCVD))\r\nreturn -EINVAL;\r\nif (iscsi_conn_bind(cls_session, cls_conn, is_leading))\r\nreturn -EINVAL;\r\nif (bnx2i_ep->hba != hba) {\r\niscsi_conn_printk(KERN_ALERT, cls_conn->dd_data,\r\n"conn bind, ep=0x%p (%s) does not",\r\nbnx2i_ep, bnx2i_ep->hba->netdev->name);\r\niscsi_conn_printk(KERN_ALERT, cls_conn->dd_data,\r\n"belong to hba (%s)\n",\r\nhba->netdev->name);\r\nreturn -EEXIST;\r\n}\r\nbnx2i_ep->conn = bnx2i_conn;\r\nbnx2i_conn->ep = bnx2i_ep;\r\nbnx2i_conn->iscsi_conn_cid = bnx2i_ep->ep_iscsi_cid;\r\nbnx2i_conn->fw_cid = bnx2i_ep->ep_cid;\r\nret_code = bnx2i_bind_conn_to_iscsi_cid(hba, bnx2i_conn,\r\nbnx2i_ep->ep_iscsi_cid);\r\nif (test_bit(BNX2I_NX2_DEV_57710, &bnx2i_ep->hba->cnic_dev_type))\r\nbnx2i_put_rq_buf(bnx2i_conn, 0);\r\nbnx2i_arm_cq_event_coalescing(bnx2i_conn->ep, CNIC_ARM_CQE);\r\nreturn ret_code;\r\n}\r\nstatic void bnx2i_conn_destroy(struct iscsi_cls_conn *cls_conn)\r\n{\r\nstruct iscsi_conn *conn = cls_conn->dd_data;\r\nstruct bnx2i_conn *bnx2i_conn = conn->dd_data;\r\nstruct Scsi_Host *shost;\r\nstruct bnx2i_hba *hba;\r\nstruct bnx2i_work *work, *tmp;\r\nunsigned cpu = 0;\r\nstruct bnx2i_percpu_s *p;\r\nshost = iscsi_session_to_shost(iscsi_conn_to_session(cls_conn));\r\nhba = iscsi_host_priv(shost);\r\nbnx2i_conn_free_login_resources(hba, bnx2i_conn);\r\nif (atomic_read(&bnx2i_conn->work_cnt)) {\r\nfor_each_online_cpu(cpu) {\r\np = &per_cpu(bnx2i_percpu, cpu);\r\nspin_lock_bh(&p->p_work_lock);\r\nlist_for_each_entry_safe(work, tmp,\r\n&p->work_list, list) {\r\nif (work->session == conn->session &&\r\nwork->bnx2i_conn == bnx2i_conn) {\r\nlist_del_init(&work->list);\r\nkfree(work);\r\nif (!atomic_dec_and_test(\r\n&bnx2i_conn->work_cnt))\r\nbreak;\r\n}\r\n}\r\nspin_unlock_bh(&p->p_work_lock);\r\n}\r\n}\r\niscsi_conn_teardown(cls_conn);\r\n}\r\nstatic int bnx2i_ep_get_param(struct iscsi_endpoint *ep,\r\nenum iscsi_param param, char *buf)\r\n{\r\nstruct bnx2i_endpoint *bnx2i_ep = ep->dd_data;\r\nstruct bnx2i_hba *hba = bnx2i_ep->hba;\r\nint len = -ENOTCONN;\r\nif (!hba)\r\nreturn -ENOTCONN;\r\nswitch (param) {\r\ncase ISCSI_PARAM_CONN_PORT:\r\nmutex_lock(&hba->net_dev_lock);\r\nif (bnx2i_ep->cm_sk)\r\nlen = sprintf(buf, "%hu\n", bnx2i_ep->cm_sk->dst_port);\r\nmutex_unlock(&hba->net_dev_lock);\r\nbreak;\r\ncase ISCSI_PARAM_CONN_ADDRESS:\r\nmutex_lock(&hba->net_dev_lock);\r\nif (bnx2i_ep->cm_sk)\r\nlen = sprintf(buf, "%pI4\n", &bnx2i_ep->cm_sk->dst_ip);\r\nmutex_unlock(&hba->net_dev_lock);\r\nbreak;\r\ndefault:\r\nreturn -ENOSYS;\r\n}\r\nreturn len;\r\n}\r\nstatic int bnx2i_host_get_param(struct Scsi_Host *shost,\r\nenum iscsi_host_param param, char *buf)\r\n{\r\nstruct bnx2i_hba *hba = iscsi_host_priv(shost);\r\nint len = 0;\r\nswitch (param) {\r\ncase ISCSI_HOST_PARAM_HWADDRESS:\r\nlen = sysfs_format_mac(buf, hba->cnic->mac_addr, 6);\r\nbreak;\r\ncase ISCSI_HOST_PARAM_NETDEV_NAME:\r\nlen = sprintf(buf, "%s\n", hba->netdev->name);\r\nbreak;\r\ncase ISCSI_HOST_PARAM_IPADDRESS: {\r\nstruct list_head *active_list = &hba->ep_active_list;\r\nread_lock_bh(&hba->ep_rdwr_lock);\r\nif (!list_empty(&hba->ep_active_list)) {\r\nstruct bnx2i_endpoint *bnx2i_ep;\r\nstruct cnic_sock *csk;\r\nbnx2i_ep = list_first_entry(active_list,\r\nstruct bnx2i_endpoint,\r\nlink);\r\ncsk = bnx2i_ep->cm_sk;\r\nif (test_bit(SK_F_IPV6, &csk->flags))\r\nlen = sprintf(buf, "%pI6\n", csk->src_ip);\r\nelse\r\nlen = sprintf(buf, "%pI4\n", csk->src_ip);\r\n}\r\nread_unlock_bh(&hba->ep_rdwr_lock);\r\nbreak;\r\n}\r\ndefault:\r\nreturn iscsi_host_get_param(shost, param, buf);\r\n}\r\nreturn len;\r\n}\r\nstatic int bnx2i_conn_start(struct iscsi_cls_conn *cls_conn)\r\n{\r\nstruct iscsi_conn *conn = cls_conn->dd_data;\r\nstruct bnx2i_conn *bnx2i_conn = conn->dd_data;\r\nbnx2i_conn->ep->state = EP_STATE_ULP_UPDATE_START;\r\nbnx2i_update_iscsi_conn(conn);\r\nbnx2i_conn->ep->ofld_timer.expires = 1 * HZ + jiffies;\r\nbnx2i_conn->ep->ofld_timer.function = bnx2i_ep_ofld_timer;\r\nbnx2i_conn->ep->ofld_timer.data = (unsigned long) bnx2i_conn->ep;\r\nadd_timer(&bnx2i_conn->ep->ofld_timer);\r\nwait_event_interruptible(bnx2i_conn->ep->ofld_wait,\r\nbnx2i_conn->ep->state != EP_STATE_ULP_UPDATE_START);\r\nif (signal_pending(current))\r\nflush_signals(current);\r\ndel_timer_sync(&bnx2i_conn->ep->ofld_timer);\r\niscsi_conn_start(cls_conn);\r\nreturn 0;\r\n}\r\nstatic void bnx2i_conn_get_stats(struct iscsi_cls_conn *cls_conn,\r\nstruct iscsi_stats *stats)\r\n{\r\nstruct iscsi_conn *conn = cls_conn->dd_data;\r\nstats->txdata_octets = conn->txdata_octets;\r\nstats->rxdata_octets = conn->rxdata_octets;\r\nstats->scsicmd_pdus = conn->scsicmd_pdus_cnt;\r\nstats->dataout_pdus = conn->dataout_pdus_cnt;\r\nstats->scsirsp_pdus = conn->scsirsp_pdus_cnt;\r\nstats->datain_pdus = conn->datain_pdus_cnt;\r\nstats->r2t_pdus = conn->r2t_pdus_cnt;\r\nstats->tmfcmd_pdus = conn->tmfcmd_pdus_cnt;\r\nstats->tmfrsp_pdus = conn->tmfrsp_pdus_cnt;\r\nstats->digest_err = 0;\r\nstats->timeout_err = 0;\r\nstrcpy(stats->custom[0].desc, "eh_abort_cnt");\r\nstats->custom[0].value = conn->eh_abort_cnt;\r\nstats->custom_length = 1;\r\n}\r\nstatic struct bnx2i_hba *bnx2i_check_route(struct sockaddr *dst_addr)\r\n{\r\nstruct sockaddr_in *desti = (struct sockaddr_in *) dst_addr;\r\nstruct bnx2i_hba *hba;\r\nstruct cnic_dev *cnic = NULL;\r\nhba = get_adapter_list_head();\r\nif (hba && hba->cnic)\r\ncnic = hba->cnic->cm_select_dev(desti, CNIC_ULP_ISCSI);\r\nif (!cnic) {\r\nprintk(KERN_ALERT "bnx2i: no route,"\r\n"can't connect using cnic\n");\r\ngoto no_nx2_route;\r\n}\r\nhba = bnx2i_find_hba_for_cnic(cnic);\r\nif (!hba)\r\ngoto no_nx2_route;\r\nif (bnx2i_adapter_ready(hba)) {\r\nprintk(KERN_ALERT "bnx2i: check route, hba not found\n");\r\ngoto no_nx2_route;\r\n}\r\nif (hba->netdev->mtu > hba->mtu_supported) {\r\nprintk(KERN_ALERT "bnx2i: %s network i/f mtu is set to %d\n",\r\nhba->netdev->name, hba->netdev->mtu);\r\nprintk(KERN_ALERT "bnx2i: iSCSI HBA can support mtu of %d\n",\r\nhba->mtu_supported);\r\ngoto no_nx2_route;\r\n}\r\nreturn hba;\r\nno_nx2_route:\r\nreturn NULL;\r\n}\r\nstatic int bnx2i_tear_down_conn(struct bnx2i_hba *hba,\r\nstruct bnx2i_endpoint *ep)\r\n{\r\nif (test_bit(BNX2I_CNIC_REGISTERED, &hba->reg_with_cnic) && ep->cm_sk)\r\nhba->cnic->cm_destroy(ep->cm_sk);\r\nif (test_bit(BNX2I_NX2_DEV_57710, &hba->cnic_dev_type) &&\r\nep->state == EP_STATE_DISCONN_TIMEDOUT) {\r\nif (ep->conn && ep->conn->cls_conn &&\r\nep->conn->cls_conn->dd_data) {\r\nstruct iscsi_conn *conn = ep->conn->cls_conn->dd_data;\r\nset_bit(ISCSI_SUSPEND_BIT, &conn->suspend_rx);\r\n}\r\nprintk(KERN_ALERT "bnx2i (%s): - WARN - CONN_DISCON timed out, "\r\n"please submit GRC Dump, NW/PCIe trace, "\r\n"driver msgs to developers for analysis\n",\r\nhba->netdev->name);\r\n}\r\nep->state = EP_STATE_CLEANUP_START;\r\ninit_timer(&ep->ofld_timer);\r\nep->ofld_timer.expires = hba->conn_ctx_destroy_tmo + jiffies;\r\nep->ofld_timer.function = bnx2i_ep_ofld_timer;\r\nep->ofld_timer.data = (unsigned long) ep;\r\nadd_timer(&ep->ofld_timer);\r\nbnx2i_ep_destroy_list_add(hba, ep);\r\nif (bnx2i_send_conn_destroy(hba, ep))\r\nep->state = EP_STATE_CLEANUP_CMPL;\r\nwait_event_interruptible(ep->ofld_wait,\r\n(ep->state != EP_STATE_CLEANUP_START));\r\nif (signal_pending(current))\r\nflush_signals(current);\r\ndel_timer_sync(&ep->ofld_timer);\r\nbnx2i_ep_destroy_list_del(hba, ep);\r\nif (ep->state != EP_STATE_CLEANUP_CMPL)\r\nprintk(KERN_ALERT "bnx2i - conn destroy failed\n");\r\nreturn 0;\r\n}\r\nstatic struct iscsi_endpoint *bnx2i_ep_connect(struct Scsi_Host *shost,\r\nstruct sockaddr *dst_addr,\r\nint non_blocking)\r\n{\r\nu32 iscsi_cid = BNX2I_CID_RESERVED;\r\nstruct sockaddr_in *desti = (struct sockaddr_in *) dst_addr;\r\nstruct sockaddr_in6 *desti6;\r\nstruct bnx2i_endpoint *bnx2i_ep;\r\nstruct bnx2i_hba *hba;\r\nstruct cnic_dev *cnic;\r\nstruct cnic_sockaddr saddr;\r\nstruct iscsi_endpoint *ep;\r\nint rc = 0;\r\nif (shost) {\r\nhba = iscsi_host_priv(shost);\r\n} else\r\nhba = bnx2i_check_route(dst_addr);\r\nif (!hba) {\r\nrc = -EINVAL;\r\ngoto nohba;\r\n}\r\nmutex_lock(&hba->net_dev_lock);\r\nif (bnx2i_adapter_ready(hba) || !hba->cid_que.cid_free_cnt) {\r\nrc = -EPERM;\r\ngoto check_busy;\r\n}\r\ncnic = hba->cnic;\r\nep = bnx2i_alloc_ep(hba);\r\nif (!ep) {\r\nrc = -ENOMEM;\r\ngoto check_busy;\r\n}\r\nbnx2i_ep = ep->dd_data;\r\natomic_set(&bnx2i_ep->num_active_cmds, 0);\r\niscsi_cid = bnx2i_alloc_iscsi_cid(hba);\r\nif (iscsi_cid == -1) {\r\nprintk(KERN_ALERT "bnx2i (%s): alloc_ep - unable to allocate "\r\n"iscsi cid\n", hba->netdev->name);\r\nrc = -ENOMEM;\r\nbnx2i_free_ep(ep);\r\ngoto check_busy;\r\n}\r\nbnx2i_ep->hba_age = hba->age;\r\nrc = bnx2i_alloc_qp_resc(hba, bnx2i_ep);\r\nif (rc != 0) {\r\nprintk(KERN_ALERT "bnx2i (%s): ep_conn - alloc QP resc error"\r\n"\n", hba->netdev->name);\r\nrc = -ENOMEM;\r\ngoto qp_resc_err;\r\n}\r\nbnx2i_ep->ep_iscsi_cid = (u16)iscsi_cid;\r\nbnx2i_ep->state = EP_STATE_OFLD_START;\r\nbnx2i_ep_ofld_list_add(hba, bnx2i_ep);\r\ninit_timer(&bnx2i_ep->ofld_timer);\r\nbnx2i_ep->ofld_timer.expires = 2 * HZ + jiffies;\r\nbnx2i_ep->ofld_timer.function = bnx2i_ep_ofld_timer;\r\nbnx2i_ep->ofld_timer.data = (unsigned long) bnx2i_ep;\r\nadd_timer(&bnx2i_ep->ofld_timer);\r\nif (bnx2i_send_conn_ofld_req(hba, bnx2i_ep)) {\r\nif (bnx2i_ep->state == EP_STATE_OFLD_FAILED_CID_BUSY) {\r\nprintk(KERN_ALERT "bnx2i (%s): iscsi cid %d is busy\n",\r\nhba->netdev->name, bnx2i_ep->ep_iscsi_cid);\r\nrc = -EBUSY;\r\n} else\r\nrc = -ENOSPC;\r\nprintk(KERN_ALERT "bnx2i (%s): unable to send conn offld kwqe"\r\n"\n", hba->netdev->name);\r\nbnx2i_ep_ofld_list_del(hba, bnx2i_ep);\r\ngoto conn_failed;\r\n}\r\nwait_event_interruptible(bnx2i_ep->ofld_wait,\r\nbnx2i_ep->state != EP_STATE_OFLD_START);\r\nif (signal_pending(current))\r\nflush_signals(current);\r\ndel_timer_sync(&bnx2i_ep->ofld_timer);\r\nbnx2i_ep_ofld_list_del(hba, bnx2i_ep);\r\nif (bnx2i_ep->state != EP_STATE_OFLD_COMPL) {\r\nif (bnx2i_ep->state == EP_STATE_OFLD_FAILED_CID_BUSY) {\r\nprintk(KERN_ALERT "bnx2i (%s): iscsi cid %d is busy\n",\r\nhba->netdev->name, bnx2i_ep->ep_iscsi_cid);\r\nrc = -EBUSY;\r\n} else\r\nrc = -ENOSPC;\r\ngoto conn_failed;\r\n}\r\nrc = cnic->cm_create(cnic, CNIC_ULP_ISCSI, bnx2i_ep->ep_cid,\r\niscsi_cid, &bnx2i_ep->cm_sk, bnx2i_ep);\r\nif (rc) {\r\nrc = -EINVAL;\r\ngoto release_ep;\r\n}\r\nbnx2i_ep->cm_sk->rcv_buf = 256 * 1024;\r\nbnx2i_ep->cm_sk->snd_buf = 256 * 1024;\r\nclear_bit(SK_TCP_TIMESTAMP, &bnx2i_ep->cm_sk->tcp_flags);\r\nmemset(&saddr, 0, sizeof(saddr));\r\nif (dst_addr->sa_family == AF_INET) {\r\ndesti = (struct sockaddr_in *) dst_addr;\r\nsaddr.remote.v4 = *desti;\r\nsaddr.local.v4.sin_family = desti->sin_family;\r\n} else if (dst_addr->sa_family == AF_INET6) {\r\ndesti6 = (struct sockaddr_in6 *) dst_addr;\r\nsaddr.remote.v6 = *desti6;\r\nsaddr.local.v6.sin6_family = desti6->sin6_family;\r\n}\r\nbnx2i_ep->timestamp = jiffies;\r\nbnx2i_ep->state = EP_STATE_CONNECT_START;\r\nif (!test_bit(BNX2I_CNIC_REGISTERED, &hba->reg_with_cnic)) {\r\nrc = -EINVAL;\r\ngoto conn_failed;\r\n} else\r\nrc = cnic->cm_connect(bnx2i_ep->cm_sk, &saddr);\r\nif (rc)\r\ngoto release_ep;\r\nbnx2i_ep_active_list_add(hba, bnx2i_ep);\r\nrc = bnx2i_map_ep_dbell_regs(bnx2i_ep);\r\nif (rc)\r\ngoto del_active_ep;\r\nmutex_unlock(&hba->net_dev_lock);\r\nreturn ep;\r\ndel_active_ep:\r\nbnx2i_ep_active_list_del(hba, bnx2i_ep);\r\nrelease_ep:\r\nif (bnx2i_tear_down_conn(hba, bnx2i_ep)) {\r\nmutex_unlock(&hba->net_dev_lock);\r\nreturn ERR_PTR(rc);\r\n}\r\nconn_failed:\r\nbnx2i_free_qp_resc(hba, bnx2i_ep);\r\nqp_resc_err:\r\nbnx2i_free_ep(ep);\r\ncheck_busy:\r\nmutex_unlock(&hba->net_dev_lock);\r\nnohba:\r\nreturn ERR_PTR(rc);\r\n}\r\nstatic int bnx2i_ep_poll(struct iscsi_endpoint *ep, int timeout_ms)\r\n{\r\nstruct bnx2i_endpoint *bnx2i_ep;\r\nint rc = 0;\r\nbnx2i_ep = ep->dd_data;\r\nif ((bnx2i_ep->state == EP_STATE_IDLE) ||\r\n(bnx2i_ep->state == EP_STATE_CONNECT_FAILED) ||\r\n(bnx2i_ep->state == EP_STATE_OFLD_FAILED))\r\nreturn -1;\r\nif (bnx2i_ep->state == EP_STATE_CONNECT_COMPL)\r\nreturn 1;\r\nrc = wait_event_interruptible_timeout(bnx2i_ep->ofld_wait,\r\n((bnx2i_ep->state ==\r\nEP_STATE_OFLD_FAILED) ||\r\n(bnx2i_ep->state ==\r\nEP_STATE_CONNECT_FAILED) ||\r\n(bnx2i_ep->state ==\r\nEP_STATE_CONNECT_COMPL)),\r\nmsecs_to_jiffies(timeout_ms));\r\nif (bnx2i_ep->state == EP_STATE_OFLD_FAILED)\r\nrc = -1;\r\nif (rc > 0)\r\nreturn 1;\r\nelse if (!rc)\r\nreturn 0;\r\nelse\r\nreturn rc;\r\n}\r\nstatic int bnx2i_ep_tcp_conn_active(struct bnx2i_endpoint *bnx2i_ep)\r\n{\r\nint ret;\r\nint cnic_dev_10g = 0;\r\nif (test_bit(BNX2I_NX2_DEV_57710, &bnx2i_ep->hba->cnic_dev_type))\r\ncnic_dev_10g = 1;\r\nswitch (bnx2i_ep->state) {\r\ncase EP_STATE_CLEANUP_FAILED:\r\ncase EP_STATE_OFLD_FAILED:\r\ncase EP_STATE_DISCONN_TIMEDOUT:\r\nret = 0;\r\nbreak;\r\ncase EP_STATE_CONNECT_START:\r\ncase EP_STATE_CONNECT_FAILED:\r\ncase EP_STATE_CONNECT_COMPL:\r\ncase EP_STATE_ULP_UPDATE_START:\r\ncase EP_STATE_ULP_UPDATE_COMPL:\r\ncase EP_STATE_TCP_FIN_RCVD:\r\ncase EP_STATE_LOGOUT_SENT:\r\ncase EP_STATE_LOGOUT_RESP_RCVD:\r\ncase EP_STATE_ULP_UPDATE_FAILED:\r\nret = 1;\r\nbreak;\r\ncase EP_STATE_TCP_RST_RCVD:\r\nif (cnic_dev_10g)\r\nret = 0;\r\nelse\r\nret = 1;\r\nbreak;\r\ndefault:\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nint bnx2i_hw_ep_disconnect(struct bnx2i_endpoint *bnx2i_ep)\r\n{\r\nstruct bnx2i_hba *hba = bnx2i_ep->hba;\r\nstruct cnic_dev *cnic;\r\nstruct iscsi_session *session = NULL;\r\nstruct iscsi_conn *conn = NULL;\r\nint ret = 0;\r\nint close = 0;\r\nint close_ret = 0;\r\nif (!hba)\r\nreturn 0;\r\ncnic = hba->cnic;\r\nif (!cnic)\r\nreturn 0;\r\nif (bnx2i_ep->state == EP_STATE_IDLE ||\r\nbnx2i_ep->state == EP_STATE_DISCONN_TIMEDOUT)\r\nreturn 0;\r\nif (!bnx2i_ep_tcp_conn_active(bnx2i_ep))\r\ngoto destroy_conn;\r\nif (bnx2i_ep->conn) {\r\nconn = bnx2i_ep->conn->cls_conn->dd_data;\r\nsession = conn->session;\r\n}\r\ninit_timer(&bnx2i_ep->ofld_timer);\r\nbnx2i_ep->ofld_timer.expires = hba->conn_teardown_tmo + jiffies;\r\nbnx2i_ep->ofld_timer.function = bnx2i_ep_ofld_timer;\r\nbnx2i_ep->ofld_timer.data = (unsigned long) bnx2i_ep;\r\nadd_timer(&bnx2i_ep->ofld_timer);\r\nif (!test_bit(BNX2I_CNIC_REGISTERED, &hba->reg_with_cnic))\r\ngoto out;\r\nif (session) {\r\nspin_lock_bh(&session->frwd_lock);\r\nif (bnx2i_ep->state != EP_STATE_TCP_FIN_RCVD) {\r\nif (session->state == ISCSI_STATE_LOGGING_OUT) {\r\nif (bnx2i_ep->state == EP_STATE_LOGOUT_SENT) {\r\nprintk(KERN_ALERT "bnx2i (%s): WARNING"\r\n" logout response was not "\r\n"received!\n",\r\nbnx2i_ep->hba->netdev->name);\r\n} else if (bnx2i_ep->state ==\r\nEP_STATE_LOGOUT_RESP_RCVD)\r\nclose = 1;\r\n}\r\n} else\r\nclose = 1;\r\nspin_unlock_bh(&session->frwd_lock);\r\n}\r\nbnx2i_ep->state = EP_STATE_DISCONN_START;\r\nif (close)\r\nclose_ret = cnic->cm_close(bnx2i_ep->cm_sk);\r\nelse\r\nclose_ret = cnic->cm_abort(bnx2i_ep->cm_sk);\r\nif (close_ret)\r\nprintk(KERN_ALERT "bnx2i (%s): close/abort(%d) returned %d\n",\r\nbnx2i_ep->hba->netdev->name, close, close_ret);\r\nelse\r\nwait_event_interruptible(bnx2i_ep->ofld_wait,\r\n((bnx2i_ep->state != EP_STATE_DISCONN_START)\r\n&& (bnx2i_ep->state != EP_STATE_TCP_FIN_RCVD)));\r\nif (signal_pending(current))\r\nflush_signals(current);\r\ndel_timer_sync(&bnx2i_ep->ofld_timer);\r\ndestroy_conn:\r\nbnx2i_ep_active_list_del(hba, bnx2i_ep);\r\nif (bnx2i_tear_down_conn(hba, bnx2i_ep))\r\nreturn -EINVAL;\r\nout:\r\nbnx2i_ep->state = EP_STATE_IDLE;\r\nreturn ret;\r\n}\r\nstatic void bnx2i_ep_disconnect(struct iscsi_endpoint *ep)\r\n{\r\nstruct bnx2i_endpoint *bnx2i_ep;\r\nstruct bnx2i_conn *bnx2i_conn = NULL;\r\nstruct iscsi_conn *conn = NULL;\r\nstruct bnx2i_hba *hba;\r\nbnx2i_ep = ep->dd_data;\r\nwhile ((bnx2i_ep->state == EP_STATE_CONNECT_START) &&\r\n!time_after(jiffies, bnx2i_ep->timestamp + (12 * HZ)))\r\nmsleep(250);\r\nif (bnx2i_ep->conn) {\r\nbnx2i_conn = bnx2i_ep->conn;\r\nconn = bnx2i_conn->cls_conn->dd_data;\r\niscsi_suspend_queue(conn);\r\n}\r\nhba = bnx2i_ep->hba;\r\nmutex_lock(&hba->net_dev_lock);\r\nif (bnx2i_ep->state == EP_STATE_DISCONN_TIMEDOUT)\r\ngoto out;\r\nif (bnx2i_ep->state == EP_STATE_IDLE)\r\ngoto free_resc;\r\nif (!test_bit(ADAPTER_STATE_UP, &hba->adapter_state) ||\r\n(bnx2i_ep->hba_age != hba->age)) {\r\nbnx2i_ep_active_list_del(hba, bnx2i_ep);\r\ngoto free_resc;\r\n}\r\nif (bnx2i_hw_ep_disconnect(bnx2i_ep)) {\r\nmutex_unlock(&hba->net_dev_lock);\r\nreturn;\r\n}\r\nfree_resc:\r\nbnx2i_free_qp_resc(hba, bnx2i_ep);\r\nif (bnx2i_conn)\r\nbnx2i_conn->ep = NULL;\r\nbnx2i_free_ep(ep);\r\nout:\r\nmutex_unlock(&hba->net_dev_lock);\r\nwake_up_interruptible(&hba->eh_wait);\r\n}\r\nstatic int bnx2i_nl_set_path(struct Scsi_Host *shost, struct iscsi_path *params)\r\n{\r\nstruct bnx2i_hba *hba = iscsi_host_priv(shost);\r\nchar *buf = (char *) params;\r\nu16 len = sizeof(*params);\r\nhba->cnic->iscsi_nl_msg_recv(hba->cnic, ISCSI_UEVENT_PATH_UPDATE, buf,\r\nlen);\r\nreturn 0;\r\n}\r\nstatic umode_t bnx2i_attr_is_visible(int param_type, int param)\r\n{\r\nswitch (param_type) {\r\ncase ISCSI_HOST_PARAM:\r\nswitch (param) {\r\ncase ISCSI_HOST_PARAM_NETDEV_NAME:\r\ncase ISCSI_HOST_PARAM_HWADDRESS:\r\ncase ISCSI_HOST_PARAM_IPADDRESS:\r\nreturn S_IRUGO;\r\ndefault:\r\nreturn 0;\r\n}\r\ncase ISCSI_PARAM:\r\nswitch (param) {\r\ncase ISCSI_PARAM_MAX_RECV_DLENGTH:\r\ncase ISCSI_PARAM_MAX_XMIT_DLENGTH:\r\ncase ISCSI_PARAM_HDRDGST_EN:\r\ncase ISCSI_PARAM_DATADGST_EN:\r\ncase ISCSI_PARAM_CONN_ADDRESS:\r\ncase ISCSI_PARAM_CONN_PORT:\r\ncase ISCSI_PARAM_EXP_STATSN:\r\ncase ISCSI_PARAM_PERSISTENT_ADDRESS:\r\ncase ISCSI_PARAM_PERSISTENT_PORT:\r\ncase ISCSI_PARAM_PING_TMO:\r\ncase ISCSI_PARAM_RECV_TMO:\r\ncase ISCSI_PARAM_INITIAL_R2T_EN:\r\ncase ISCSI_PARAM_MAX_R2T:\r\ncase ISCSI_PARAM_IMM_DATA_EN:\r\ncase ISCSI_PARAM_FIRST_BURST:\r\ncase ISCSI_PARAM_MAX_BURST:\r\ncase ISCSI_PARAM_PDU_INORDER_EN:\r\ncase ISCSI_PARAM_DATASEQ_INORDER_EN:\r\ncase ISCSI_PARAM_ERL:\r\ncase ISCSI_PARAM_TARGET_NAME:\r\ncase ISCSI_PARAM_TPGT:\r\ncase ISCSI_PARAM_USERNAME:\r\ncase ISCSI_PARAM_PASSWORD:\r\ncase ISCSI_PARAM_USERNAME_IN:\r\ncase ISCSI_PARAM_PASSWORD_IN:\r\ncase ISCSI_PARAM_FAST_ABORT:\r\ncase ISCSI_PARAM_ABORT_TMO:\r\ncase ISCSI_PARAM_LU_RESET_TMO:\r\ncase ISCSI_PARAM_TGT_RESET_TMO:\r\ncase ISCSI_PARAM_IFACE_NAME:\r\ncase ISCSI_PARAM_INITIATOR_NAME:\r\ncase ISCSI_PARAM_BOOT_ROOT:\r\ncase ISCSI_PARAM_BOOT_NIC:\r\ncase ISCSI_PARAM_BOOT_TARGET:\r\nreturn S_IRUGO;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nreturn 0;\r\n}
