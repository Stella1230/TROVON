static inline struct vsp1_histogram_buffer *\r\nto_vsp1_histogram_buffer(struct vb2_v4l2_buffer *vbuf)\r\n{\r\nreturn container_of(vbuf, struct vsp1_histogram_buffer, buf);\r\n}\r\nstruct vsp1_histogram_buffer *\r\nvsp1_histogram_buffer_get(struct vsp1_histogram *histo)\r\n{\r\nstruct vsp1_histogram_buffer *buf = NULL;\r\nunsigned long flags;\r\nspin_lock_irqsave(&histo->irqlock, flags);\r\nif (list_empty(&histo->irqqueue))\r\ngoto done;\r\nbuf = list_first_entry(&histo->irqqueue, struct vsp1_histogram_buffer,\r\nqueue);\r\nlist_del(&buf->queue);\r\nhisto->readout = true;\r\ndone:\r\nspin_unlock_irqrestore(&histo->irqlock, flags);\r\nreturn buf;\r\n}\r\nvoid vsp1_histogram_buffer_complete(struct vsp1_histogram *histo,\r\nstruct vsp1_histogram_buffer *buf,\r\nsize_t size)\r\n{\r\nstruct vsp1_pipeline *pipe = histo->pipe;\r\nunsigned long flags;\r\nbuf->buf.sequence = pipe->sequence;\r\nbuf->buf.vb2_buf.timestamp = ktime_get_ns();\r\nvb2_set_plane_payload(&buf->buf.vb2_buf, 0, size);\r\nvb2_buffer_done(&buf->buf.vb2_buf, VB2_BUF_STATE_DONE);\r\nspin_lock_irqsave(&histo->irqlock, flags);\r\nhisto->readout = false;\r\nwake_up(&histo->wait_queue);\r\nspin_unlock_irqrestore(&histo->irqlock, flags);\r\n}\r\nstatic int histo_queue_setup(struct vb2_queue *vq, unsigned int *nbuffers,\r\nunsigned int *nplanes, unsigned int sizes[],\r\nstruct device *alloc_devs[])\r\n{\r\nstruct vsp1_histogram *histo = vb2_get_drv_priv(vq);\r\nif (*nplanes) {\r\nif (*nplanes != 1)\r\nreturn -EINVAL;\r\nif (sizes[0] < histo->data_size)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\n*nplanes = 1;\r\nsizes[0] = histo->data_size;\r\nreturn 0;\r\n}\r\nstatic int histo_buffer_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct vsp1_histogram *histo = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct vsp1_histogram_buffer *buf = to_vsp1_histogram_buffer(vbuf);\r\nif (vb->num_planes != 1)\r\nreturn -EINVAL;\r\nif (vb2_plane_size(vb, 0) < histo->data_size)\r\nreturn -EINVAL;\r\nbuf->addr = vb2_plane_vaddr(vb, 0);\r\nreturn 0;\r\n}\r\nstatic void histo_buffer_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct vsp1_histogram *histo = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct vsp1_histogram_buffer *buf = to_vsp1_histogram_buffer(vbuf);\r\nunsigned long flags;\r\nspin_lock_irqsave(&histo->irqlock, flags);\r\nlist_add_tail(&buf->queue, &histo->irqqueue);\r\nspin_unlock_irqrestore(&histo->irqlock, flags);\r\n}\r\nstatic int histo_start_streaming(struct vb2_queue *vq, unsigned int count)\r\n{\r\nreturn 0;\r\n}\r\nstatic void histo_stop_streaming(struct vb2_queue *vq)\r\n{\r\nstruct vsp1_histogram *histo = vb2_get_drv_priv(vq);\r\nstruct vsp1_histogram_buffer *buffer;\r\nunsigned long flags;\r\nspin_lock_irqsave(&histo->irqlock, flags);\r\nlist_for_each_entry(buffer, &histo->irqqueue, queue)\r\nvb2_buffer_done(&buffer->buf.vb2_buf, VB2_BUF_STATE_ERROR);\r\nINIT_LIST_HEAD(&histo->irqqueue);\r\nwait_event_lock_irq(histo->wait_queue, !histo->readout, histo->irqlock);\r\nspin_unlock_irqrestore(&histo->irqlock, flags);\r\n}\r\nstatic int histo_enum_mbus_code(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nstruct vsp1_histogram *histo = subdev_to_histo(subdev);\r\nif (code->pad == HISTO_PAD_SOURCE) {\r\ncode->code = MEDIA_BUS_FMT_FIXED;\r\nreturn 0;\r\n}\r\nreturn vsp1_subdev_enum_mbus_code(subdev, cfg, code, histo->formats,\r\nhisto->num_formats);\r\n}\r\nstatic int histo_enum_frame_size(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_frame_size_enum *fse)\r\n{\r\nif (fse->pad != HISTO_PAD_SINK)\r\nreturn -EINVAL;\r\nreturn vsp1_subdev_enum_frame_size(subdev, cfg, fse, HISTO_MIN_SIZE,\r\nHISTO_MIN_SIZE, HISTO_MAX_SIZE,\r\nHISTO_MAX_SIZE);\r\n}\r\nstatic int histo_get_selection(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_selection *sel)\r\n{\r\nstruct vsp1_histogram *histo = subdev_to_histo(subdev);\r\nstruct v4l2_subdev_pad_config *config;\r\nstruct v4l2_mbus_framefmt *format;\r\nstruct v4l2_rect *crop;\r\nint ret = 0;\r\nif (sel->pad != HISTO_PAD_SINK)\r\nreturn -EINVAL;\r\nmutex_lock(&histo->entity.lock);\r\nconfig = vsp1_entity_get_pad_config(&histo->entity, cfg, sel->which);\r\nif (!config) {\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nswitch (sel->target) {\r\ncase V4L2_SEL_TGT_COMPOSE_BOUNDS:\r\ncase V4L2_SEL_TGT_COMPOSE_DEFAULT:\r\ncrop = vsp1_entity_get_pad_selection(&histo->entity, config,\r\nHISTO_PAD_SINK,\r\nV4L2_SEL_TGT_CROP);\r\nsel->r.left = 0;\r\nsel->r.top = 0;\r\nsel->r.width = crop->width;\r\nsel->r.height = crop->height;\r\nbreak;\r\ncase V4L2_SEL_TGT_CROP_BOUNDS:\r\ncase V4L2_SEL_TGT_CROP_DEFAULT:\r\nformat = vsp1_entity_get_pad_format(&histo->entity, config,\r\nHISTO_PAD_SINK);\r\nsel->r.left = 0;\r\nsel->r.top = 0;\r\nsel->r.width = format->width;\r\nsel->r.height = format->height;\r\nbreak;\r\ncase V4L2_SEL_TGT_COMPOSE:\r\ncase V4L2_SEL_TGT_CROP:\r\nsel->r = *vsp1_entity_get_pad_selection(&histo->entity, config,\r\nsel->pad, sel->target);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\ndone:\r\nmutex_unlock(&histo->entity.lock);\r\nreturn ret;\r\n}\r\nstatic int histo_set_crop(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *config,\r\nstruct v4l2_subdev_selection *sel)\r\n{\r\nstruct vsp1_histogram *histo = subdev_to_histo(subdev);\r\nstruct v4l2_mbus_framefmt *format;\r\nstruct v4l2_rect *selection;\r\nformat = vsp1_entity_get_pad_format(&histo->entity, config,\r\nHISTO_PAD_SINK);\r\nsel->r.left = clamp_t(unsigned int, sel->r.left, 0, format->width - 1);\r\nsel->r.top = clamp_t(unsigned int, sel->r.top, 0, format->height - 1);\r\nsel->r.width = clamp_t(unsigned int, sel->r.width, HISTO_MIN_SIZE,\r\nformat->width - sel->r.left);\r\nsel->r.height = clamp_t(unsigned int, sel->r.height, HISTO_MIN_SIZE,\r\nformat->height - sel->r.top);\r\nselection = vsp1_entity_get_pad_selection(&histo->entity, config,\r\nsel->pad, V4L2_SEL_TGT_CROP);\r\n*selection = sel->r;\r\nselection = vsp1_entity_get_pad_selection(&histo->entity, config,\r\nsel->pad,\r\nV4L2_SEL_TGT_COMPOSE);\r\n*selection = sel->r;\r\nreturn 0;\r\n}\r\nstatic int histo_set_compose(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *config,\r\nstruct v4l2_subdev_selection *sel)\r\n{\r\nstruct vsp1_histogram *histo = subdev_to_histo(subdev);\r\nstruct v4l2_rect *compose;\r\nstruct v4l2_rect *crop;\r\nunsigned int ratio;\r\nsel->r.left = 0;\r\nsel->r.top = 0;\r\ncrop = vsp1_entity_get_pad_selection(&histo->entity, config, sel->pad,\r\nV4L2_SEL_TGT_CROP);\r\nsel->r.width = clamp(sel->r.width, crop->width / 4, crop->width);\r\nratio = 1 << (crop->width * 2 / sel->r.width / 3);\r\nsel->r.width = crop->width / ratio;\r\nsel->r.height = clamp(sel->r.height, crop->height / 4, crop->height);\r\nratio = 1 << (crop->height * 2 / sel->r.height / 3);\r\nsel->r.height = crop->height / ratio;\r\ncompose = vsp1_entity_get_pad_selection(&histo->entity, config,\r\nsel->pad,\r\nV4L2_SEL_TGT_COMPOSE);\r\n*compose = sel->r;\r\nreturn 0;\r\n}\r\nstatic int histo_set_selection(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_selection *sel)\r\n{\r\nstruct vsp1_histogram *histo = subdev_to_histo(subdev);\r\nstruct v4l2_subdev_pad_config *config;\r\nint ret;\r\nif (sel->pad != HISTO_PAD_SINK)\r\nreturn -EINVAL;\r\nmutex_lock(&histo->entity.lock);\r\nconfig = vsp1_entity_get_pad_config(&histo->entity, cfg, sel->which);\r\nif (!config) {\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nif (sel->target == V4L2_SEL_TGT_CROP)\r\nret = histo_set_crop(subdev, config, sel);\r\nelse if (sel->target == V4L2_SEL_TGT_COMPOSE)\r\nret = histo_set_compose(subdev, config, sel);\r\nelse\r\nret = -EINVAL;\r\ndone:\r\nmutex_unlock(&histo->entity.lock);\r\nreturn ret;\r\n}\r\nstatic int histo_get_format(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nif (fmt->pad == HISTO_PAD_SOURCE) {\r\nfmt->format.code = MEDIA_BUS_FMT_FIXED;\r\nfmt->format.width = 0;\r\nfmt->format.height = 0;\r\nfmt->format.field = V4L2_FIELD_NONE;\r\nfmt->format.colorspace = V4L2_COLORSPACE_RAW;\r\nreturn 0;\r\n}\r\nreturn vsp1_subdev_get_pad_format(subdev, cfg, fmt);\r\n}\r\nstatic int histo_set_format(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct vsp1_histogram *histo = subdev_to_histo(subdev);\r\nstruct v4l2_subdev_pad_config *config;\r\nstruct v4l2_mbus_framefmt *format;\r\nstruct v4l2_rect *selection;\r\nunsigned int i;\r\nint ret = 0;\r\nif (fmt->pad != HISTO_PAD_SINK)\r\nreturn histo_get_format(subdev, cfg, fmt);\r\nmutex_lock(&histo->entity.lock);\r\nconfig = vsp1_entity_get_pad_config(&histo->entity, cfg, fmt->which);\r\nif (!config) {\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nfor (i = 0; i < histo->num_formats; ++i) {\r\nif (fmt->format.code == histo->formats[i])\r\nbreak;\r\n}\r\nif (i == histo->num_formats)\r\nfmt->format.code = histo->formats[0];\r\nformat = vsp1_entity_get_pad_format(&histo->entity, config, fmt->pad);\r\nformat->code = fmt->format.code;\r\nformat->width = clamp_t(unsigned int, fmt->format.width,\r\nHISTO_MIN_SIZE, HISTO_MAX_SIZE);\r\nformat->height = clamp_t(unsigned int, fmt->format.height,\r\nHISTO_MIN_SIZE, HISTO_MAX_SIZE);\r\nformat->field = V4L2_FIELD_NONE;\r\nformat->colorspace = V4L2_COLORSPACE_SRGB;\r\nfmt->format = *format;\r\nselection = vsp1_entity_get_pad_selection(&histo->entity, config,\r\nfmt->pad, V4L2_SEL_TGT_CROP);\r\nselection->left = 0;\r\nselection->top = 0;\r\nselection->width = format->width;\r\nselection->height = format->height;\r\nselection = vsp1_entity_get_pad_selection(&histo->entity, config,\r\nfmt->pad,\r\nV4L2_SEL_TGT_COMPOSE);\r\nselection->left = 0;\r\nselection->top = 0;\r\nselection->width = format->width;\r\nselection->height = format->height;\r\ndone:\r\nmutex_unlock(&histo->entity.lock);\r\nreturn ret;\r\n}\r\nstatic int histo_v4l2_querycap(struct file *file, void *fh,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct v4l2_fh *vfh = file->private_data;\r\nstruct vsp1_histogram *histo = vdev_to_histo(vfh->vdev);\r\ncap->capabilities = V4L2_CAP_DEVICE_CAPS | V4L2_CAP_STREAMING\r\n| V4L2_CAP_VIDEO_CAPTURE_MPLANE\r\n| V4L2_CAP_VIDEO_OUTPUT_MPLANE\r\n| V4L2_CAP_META_CAPTURE;\r\ncap->device_caps = V4L2_CAP_META_CAPTURE\r\n| V4L2_CAP_STREAMING;\r\nstrlcpy(cap->driver, "vsp1", sizeof(cap->driver));\r\nstrlcpy(cap->card, histo->video.name, sizeof(cap->card));\r\nsnprintf(cap->bus_info, sizeof(cap->bus_info), "platform:%s",\r\ndev_name(histo->entity.vsp1->dev));\r\nreturn 0;\r\n}\r\nstatic int histo_v4l2_enum_format(struct file *file, void *fh,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nstruct v4l2_fh *vfh = file->private_data;\r\nstruct vsp1_histogram *histo = vdev_to_histo(vfh->vdev);\r\nif (f->index > 0 || f->type != histo->queue.type)\r\nreturn -EINVAL;\r\nf->pixelformat = histo->meta_format;\r\nreturn 0;\r\n}\r\nstatic int histo_v4l2_get_format(struct file *file, void *fh,\r\nstruct v4l2_format *format)\r\n{\r\nstruct v4l2_fh *vfh = file->private_data;\r\nstruct vsp1_histogram *histo = vdev_to_histo(vfh->vdev);\r\nstruct v4l2_meta_format *meta = &format->fmt.meta;\r\nif (format->type != histo->queue.type)\r\nreturn -EINVAL;\r\nmemset(meta, 0, sizeof(*meta));\r\nmeta->dataformat = histo->meta_format;\r\nmeta->buffersize = histo->data_size;\r\nreturn 0;\r\n}\r\nstatic void vsp1_histogram_cleanup(struct vsp1_histogram *histo)\r\n{\r\nif (video_is_registered(&histo->video))\r\nvideo_unregister_device(&histo->video);\r\nmedia_entity_cleanup(&histo->video.entity);\r\n}\r\nvoid vsp1_histogram_destroy(struct vsp1_entity *entity)\r\n{\r\nstruct vsp1_histogram *histo = subdev_to_histo(&entity->subdev);\r\nvsp1_histogram_cleanup(histo);\r\n}\r\nint vsp1_histogram_init(struct vsp1_device *vsp1, struct vsp1_histogram *histo,\r\nenum vsp1_entity_type type, const char *name,\r\nconst struct vsp1_entity_operations *ops,\r\nconst unsigned int *formats, unsigned int num_formats,\r\nsize_t data_size, u32 meta_format)\r\n{\r\nint ret;\r\nhisto->formats = formats;\r\nhisto->num_formats = num_formats;\r\nhisto->data_size = data_size;\r\nhisto->meta_format = meta_format;\r\nhisto->pad.flags = MEDIA_PAD_FL_SINK;\r\nhisto->video.vfl_dir = VFL_DIR_RX;\r\nmutex_init(&histo->lock);\r\nspin_lock_init(&histo->irqlock);\r\nINIT_LIST_HEAD(&histo->irqqueue);\r\ninit_waitqueue_head(&histo->wait_queue);\r\nhisto->entity.ops = ops;\r\nhisto->entity.type = type;\r\nret = vsp1_entity_init(vsp1, &histo->entity, name, 2, &histo_ops,\r\nMEDIA_ENT_F_PROC_VIDEO_STATISTICS);\r\nif (ret < 0)\r\nreturn ret;\r\nret = media_entity_pads_init(&histo->video.entity, 1, &histo->pad);\r\nif (ret < 0)\r\nreturn ret;\r\nhisto->video.v4l2_dev = &vsp1->v4l2_dev;\r\nhisto->video.fops = &histo_v4l2_fops;\r\nsnprintf(histo->video.name, sizeof(histo->video.name),\r\n"%s histo", histo->entity.subdev.name);\r\nhisto->video.vfl_type = VFL_TYPE_GRABBER;\r\nhisto->video.release = video_device_release_empty;\r\nhisto->video.ioctl_ops = &histo_v4l2_ioctl_ops;\r\nvideo_set_drvdata(&histo->video, histo);\r\nhisto->queue.type = V4L2_BUF_TYPE_META_CAPTURE;\r\nhisto->queue.io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\r\nhisto->queue.lock = &histo->lock;\r\nhisto->queue.drv_priv = histo;\r\nhisto->queue.buf_struct_size = sizeof(struct vsp1_histogram_buffer);\r\nhisto->queue.ops = &histo_video_queue_qops;\r\nhisto->queue.mem_ops = &vb2_vmalloc_memops;\r\nhisto->queue.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\r\nhisto->queue.dev = vsp1->dev;\r\nret = vb2_queue_init(&histo->queue);\r\nif (ret < 0) {\r\ndev_err(vsp1->dev, "failed to initialize vb2 queue\n");\r\ngoto error;\r\n}\r\nhisto->video.queue = &histo->queue;\r\nret = video_register_device(&histo->video, VFL_TYPE_GRABBER, -1);\r\nif (ret < 0) {\r\ndev_err(vsp1->dev, "failed to register video device\n");\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\nvsp1_histogram_cleanup(histo);\r\nreturn ret;\r\n}
