static inline struct sun4i_pwm_chip *to_sun4i_pwm_chip(struct pwm_chip *chip)\r\n{\r\nreturn container_of(chip, struct sun4i_pwm_chip, chip);\r\n}\r\nstatic inline u32 sun4i_pwm_readl(struct sun4i_pwm_chip *chip,\r\nunsigned long offset)\r\n{\r\nreturn readl(chip->base + offset);\r\n}\r\nstatic inline void sun4i_pwm_writel(struct sun4i_pwm_chip *chip,\r\nu32 val, unsigned long offset)\r\n{\r\nwritel(val, chip->base + offset);\r\n}\r\nstatic void sun4i_pwm_get_state(struct pwm_chip *chip,\r\nstruct pwm_device *pwm,\r\nstruct pwm_state *state)\r\n{\r\nstruct sun4i_pwm_chip *sun4i_pwm = to_sun4i_pwm_chip(chip);\r\nu64 clk_rate, tmp;\r\nu32 val;\r\nunsigned int prescaler;\r\nclk_rate = clk_get_rate(sun4i_pwm->clk);\r\nval = sun4i_pwm_readl(sun4i_pwm, PWM_CTRL_REG);\r\nif ((val == PWM_PRESCAL_MASK) && sun4i_pwm->data->has_prescaler_bypass)\r\nprescaler = 1;\r\nelse\r\nprescaler = prescaler_table[PWM_REG_PRESCAL(val, pwm->hwpwm)];\r\nif (prescaler == 0)\r\nreturn;\r\nif (val & BIT_CH(PWM_ACT_STATE, pwm->hwpwm))\r\nstate->polarity = PWM_POLARITY_NORMAL;\r\nelse\r\nstate->polarity = PWM_POLARITY_INVERSED;\r\nif (val & BIT_CH(PWM_CLK_GATING | PWM_EN, pwm->hwpwm))\r\nstate->enabled = true;\r\nelse\r\nstate->enabled = false;\r\nval = sun4i_pwm_readl(sun4i_pwm, PWM_CH_PRD(pwm->hwpwm));\r\ntmp = prescaler * NSEC_PER_SEC * PWM_REG_DTY(val);\r\nstate->duty_cycle = DIV_ROUND_CLOSEST_ULL(tmp, clk_rate);\r\ntmp = prescaler * NSEC_PER_SEC * PWM_REG_PRD(val);\r\nstate->period = DIV_ROUND_CLOSEST_ULL(tmp, clk_rate);\r\n}\r\nstatic int sun4i_pwm_calculate(struct sun4i_pwm_chip *sun4i_pwm,\r\nstruct pwm_state *state,\r\nu32 *dty, u32 *prd, unsigned int *prsclr)\r\n{\r\nu64 clk_rate, div = 0;\r\nunsigned int pval, prescaler = 0;\r\nclk_rate = clk_get_rate(sun4i_pwm->clk);\r\nif (sun4i_pwm->data->has_prescaler_bypass) {\r\nprescaler = PWM_PRESCAL_MASK;\r\npval = 1;\r\ndiv = clk_rate * state->period + NSEC_PER_SEC / 2;\r\ndo_div(div, NSEC_PER_SEC);\r\nif (div - 1 > PWM_PRD_MASK)\r\nprescaler = 0;\r\n}\r\nif (prescaler == 0) {\r\nfor (prescaler = 0; prescaler < PWM_PRESCAL_MASK; prescaler++) {\r\nif (!prescaler_table[prescaler])\r\ncontinue;\r\npval = prescaler_table[prescaler];\r\ndiv = clk_rate;\r\ndo_div(div, pval);\r\ndiv = div * state->period;\r\ndo_div(div, NSEC_PER_SEC);\r\nif (div - 1 <= PWM_PRD_MASK)\r\nbreak;\r\n}\r\nif (div - 1 > PWM_PRD_MASK)\r\nreturn -EINVAL;\r\n}\r\n*prd = div;\r\ndiv *= state->duty_cycle;\r\ndo_div(div, state->period);\r\n*dty = div;\r\n*prsclr = prescaler;\r\ndiv = (u64)pval * NSEC_PER_SEC * *prd;\r\nstate->period = DIV_ROUND_CLOSEST_ULL(div, clk_rate);\r\ndiv = (u64)pval * NSEC_PER_SEC * *dty;\r\nstate->duty_cycle = DIV_ROUND_CLOSEST_ULL(div, clk_rate);\r\nreturn 0;\r\n}\r\nstatic int sun4i_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\r\nstruct pwm_state *state)\r\n{\r\nstruct sun4i_pwm_chip *sun4i_pwm = to_sun4i_pwm_chip(chip);\r\nstruct pwm_state cstate;\r\nu32 ctrl;\r\nint ret;\r\nunsigned int delay_us;\r\nunsigned long now;\r\npwm_get_state(pwm, &cstate);\r\nif (!cstate.enabled) {\r\nret = clk_prepare_enable(sun4i_pwm->clk);\r\nif (ret) {\r\ndev_err(chip->dev, "failed to enable PWM clock\n");\r\nreturn ret;\r\n}\r\n}\r\nspin_lock(&sun4i_pwm->ctrl_lock);\r\nctrl = sun4i_pwm_readl(sun4i_pwm, PWM_CTRL_REG);\r\nif ((cstate.period != state->period) ||\r\n(cstate.duty_cycle != state->duty_cycle)) {\r\nu32 period, duty, val;\r\nunsigned int prescaler;\r\nret = sun4i_pwm_calculate(sun4i_pwm, state,\r\n&duty, &period, &prescaler);\r\nif (ret) {\r\ndev_err(chip->dev, "period exceeds the maximum value\n");\r\nspin_unlock(&sun4i_pwm->ctrl_lock);\r\nif (!cstate.enabled)\r\nclk_disable_unprepare(sun4i_pwm->clk);\r\nreturn ret;\r\n}\r\nif (PWM_REG_PRESCAL(ctrl, pwm->hwpwm) != prescaler) {\r\nctrl &= ~BIT_CH(PWM_CLK_GATING, pwm->hwpwm);\r\nsun4i_pwm_writel(sun4i_pwm, ctrl, PWM_CTRL_REG);\r\nctrl &= ~BIT_CH(PWM_PRESCAL_MASK, pwm->hwpwm);\r\nctrl |= BIT_CH(prescaler, pwm->hwpwm);\r\n}\r\nval = (duty & PWM_DTY_MASK) | PWM_PRD(period);\r\nsun4i_pwm_writel(sun4i_pwm, val, PWM_CH_PRD(pwm->hwpwm));\r\nsun4i_pwm->next_period[pwm->hwpwm] = jiffies +\r\nusecs_to_jiffies(cstate.period / 1000 + 1);\r\nsun4i_pwm->needs_delay[pwm->hwpwm] = true;\r\n}\r\nif (state->polarity != PWM_POLARITY_NORMAL)\r\nctrl &= ~BIT_CH(PWM_ACT_STATE, pwm->hwpwm);\r\nelse\r\nctrl |= BIT_CH(PWM_ACT_STATE, pwm->hwpwm);\r\nctrl |= BIT_CH(PWM_CLK_GATING, pwm->hwpwm);\r\nif (state->enabled) {\r\nctrl |= BIT_CH(PWM_EN, pwm->hwpwm);\r\n} else if (!sun4i_pwm->needs_delay[pwm->hwpwm]) {\r\nctrl &= ~BIT_CH(PWM_EN, pwm->hwpwm);\r\nctrl &= ~BIT_CH(PWM_CLK_GATING, pwm->hwpwm);\r\n}\r\nsun4i_pwm_writel(sun4i_pwm, ctrl, PWM_CTRL_REG);\r\nspin_unlock(&sun4i_pwm->ctrl_lock);\r\nif (state->enabled)\r\nreturn 0;\r\nif (!sun4i_pwm->needs_delay[pwm->hwpwm]) {\r\nclk_disable_unprepare(sun4i_pwm->clk);\r\nreturn 0;\r\n}\r\nnow = jiffies;\r\nif (sun4i_pwm->needs_delay[pwm->hwpwm] &&\r\ntime_before(now, sun4i_pwm->next_period[pwm->hwpwm])) {\r\ndelay_us = jiffies_to_usecs(sun4i_pwm->next_period[pwm->hwpwm] -\r\nnow);\r\nif ((delay_us / 500) > MAX_UDELAY_MS)\r\nmsleep(delay_us / 1000 + 1);\r\nelse\r\nusleep_range(delay_us, delay_us * 2);\r\n}\r\nsun4i_pwm->needs_delay[pwm->hwpwm] = false;\r\nspin_lock(&sun4i_pwm->ctrl_lock);\r\nctrl = sun4i_pwm_readl(sun4i_pwm, PWM_CTRL_REG);\r\nctrl &= ~BIT_CH(PWM_CLK_GATING, pwm->hwpwm);\r\nctrl &= ~BIT_CH(PWM_EN, pwm->hwpwm);\r\nsun4i_pwm_writel(sun4i_pwm, ctrl, PWM_CTRL_REG);\r\nspin_unlock(&sun4i_pwm->ctrl_lock);\r\nclk_disable_unprepare(sun4i_pwm->clk);\r\nreturn 0;\r\n}\r\nstatic int sun4i_pwm_probe(struct platform_device *pdev)\r\n{\r\nstruct sun4i_pwm_chip *pwm;\r\nstruct resource *res;\r\nint ret;\r\nconst struct of_device_id *match;\r\nmatch = of_match_device(sun4i_pwm_dt_ids, &pdev->dev);\r\npwm = devm_kzalloc(&pdev->dev, sizeof(*pwm), GFP_KERNEL);\r\nif (!pwm)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npwm->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(pwm->base))\r\nreturn PTR_ERR(pwm->base);\r\npwm->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(pwm->clk))\r\nreturn PTR_ERR(pwm->clk);\r\npwm->data = match->data;\r\npwm->chip.dev = &pdev->dev;\r\npwm->chip.ops = &sun4i_pwm_ops;\r\npwm->chip.base = -1;\r\npwm->chip.npwm = pwm->data->npwm;\r\npwm->chip.of_xlate = of_pwm_xlate_with_flags;\r\npwm->chip.of_pwm_n_cells = 3;\r\nspin_lock_init(&pwm->ctrl_lock);\r\nret = pwmchip_add(&pwm->chip);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to add PWM chip: %d\n", ret);\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, pwm);\r\nreturn 0;\r\n}\r\nstatic int sun4i_pwm_remove(struct platform_device *pdev)\r\n{\r\nstruct sun4i_pwm_chip *pwm = platform_get_drvdata(pdev);\r\nreturn pwmchip_remove(&pwm->chip);\r\n}
