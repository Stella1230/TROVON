static\r\nvoid MichaelInitializeFunction(struct michael_mic_t *Mic, uint8_t *key)\r\n{\r\nMic->K0 = getUInt32(key, 0);\r\nMic->K1 = getUInt32(key, 4);\r\nMichaelClear(Mic);\r\n}\r\nstatic\r\nvoid MichaelAppend(struct michael_mic_t *Mic, uint8_t *src, int nBytes)\r\n{\r\nint addlen;\r\nif (Mic->nBytesInM) {\r\naddlen = 4 - Mic->nBytesInM;\r\nif (addlen > nBytes)\r\naddlen = nBytes;\r\nmemcpy(&Mic->M[Mic->nBytesInM], src, addlen);\r\nMic->nBytesInM += addlen;\r\nsrc += addlen;\r\nnBytes -= addlen;\r\nif (Mic->nBytesInM < 4)\r\nreturn;\r\nMic->L ^= getUInt32(Mic->M, 0);\r\nMichaelBlockFunction(Mic->L, Mic->R);\r\nMic->nBytesInM = 0;\r\n}\r\nwhile (nBytes >= 4) {\r\nMic->L ^= getUInt32(src, 0);\r\nMichaelBlockFunction(Mic->L, Mic->R);\r\nsrc += 4;\r\nnBytes -= 4;\r\n}\r\nif (nBytes > 0) {\r\nMic->nBytesInM = nBytes;\r\nmemcpy(Mic->M, src, nBytes);\r\n}\r\n}\r\nstatic\r\nvoid MichaelGetMIC(struct michael_mic_t *Mic, uint8_t *dst)\r\n{\r\nu8 *data = Mic->M;\r\nswitch (Mic->nBytesInM) {\r\ncase 0:\r\nMic->L ^= 0x5a;\r\nbreak;\r\ncase 1:\r\nMic->L ^= data[0] | 0x5a00;\r\nbreak;\r\ncase 2:\r\nMic->L ^= data[0] | (data[1] << 8) | 0x5a0000;\r\nbreak;\r\ncase 3:\r\nMic->L ^= data[0] | (data[1] << 8) | (data[2] << 16) |\r\n0x5a000000;\r\nbreak;\r\n}\r\nMichaelBlockFunction(Mic->L, Mic->R);\r\nMichaelBlockFunction(Mic->L, Mic->R);\r\nputUInt32(dst, 0, Mic->L);\r\nputUInt32(dst, 4, Mic->R);\r\nMichaelClear(Mic);\r\n}\r\nvoid MichaelMICFunction(struct michael_mic_t *Mic, u8 *Key,\r\nu8 *Data, int Len, u8 priority,\r\nu8 *Result)\r\n{\r\nu8 pad_data[4] = { priority, 0, 0, 0 };\r\nMichaelInitializeFunction(Mic, Key);\r\nMichaelAppend(Mic, (uint8_t *)Data, 12);\r\nMichaelAppend(Mic, pad_data, 4);\r\nMichaelAppend(Mic, (uint8_t *)(Data + 12), Len - 12);\r\nMichaelGetMIC(Mic, Result);\r\n}
