static struct net_device*\r\nieee802154_get_dev(struct net *net, const struct ieee802154_addr *addr)\r\n{\r\nstruct net_device *dev = NULL;\r\nstruct net_device *tmp;\r\n__le16 pan_id, short_addr;\r\nu8 hwaddr[IEEE802154_ADDR_LEN];\r\nswitch (addr->mode) {\r\ncase IEEE802154_ADDR_LONG:\r\nieee802154_devaddr_to_raw(hwaddr, addr->extended_addr);\r\nrcu_read_lock();\r\ndev = dev_getbyhwaddr_rcu(net, ARPHRD_IEEE802154, hwaddr);\r\nif (dev)\r\ndev_hold(dev);\r\nrcu_read_unlock();\r\nbreak;\r\ncase IEEE802154_ADDR_SHORT:\r\nif (addr->pan_id == cpu_to_le16(IEEE802154_PANID_BROADCAST) ||\r\naddr->short_addr == cpu_to_le16(IEEE802154_ADDR_UNDEF) ||\r\naddr->short_addr == cpu_to_le16(IEEE802154_ADDR_BROADCAST))\r\nbreak;\r\nrtnl_lock();\r\nfor_each_netdev(net, tmp) {\r\nif (tmp->type != ARPHRD_IEEE802154)\r\ncontinue;\r\npan_id = tmp->ieee802154_ptr->pan_id;\r\nshort_addr = tmp->ieee802154_ptr->short_addr;\r\nif (pan_id == addr->pan_id &&\r\nshort_addr == addr->short_addr) {\r\ndev = tmp;\r\ndev_hold(dev);\r\nbreak;\r\n}\r\n}\r\nrtnl_unlock();\r\nbreak;\r\ndefault:\r\npr_warn("Unsupported ieee802154 address type: %d\n",\r\naddr->mode);\r\nbreak;\r\n}\r\nreturn dev;\r\n}\r\nstatic int ieee802154_sock_release(struct socket *sock)\r\n{\r\nstruct sock *sk = sock->sk;\r\nif (sk) {\r\nsock->sk = NULL;\r\nsk->sk_prot->close(sk, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ieee802154_sock_sendmsg(struct socket *sock, struct msghdr *msg,\r\nsize_t len)\r\n{\r\nstruct sock *sk = sock->sk;\r\nreturn sk->sk_prot->sendmsg(sk, msg, len);\r\n}\r\nstatic int ieee802154_sock_bind(struct socket *sock, struct sockaddr *uaddr,\r\nint addr_len)\r\n{\r\nstruct sock *sk = sock->sk;\r\nif (sk->sk_prot->bind)\r\nreturn sk->sk_prot->bind(sk, uaddr, addr_len);\r\nreturn sock_no_bind(sock, uaddr, addr_len);\r\n}\r\nstatic int ieee802154_sock_connect(struct socket *sock, struct sockaddr *uaddr,\r\nint addr_len, int flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nif (addr_len < sizeof(uaddr->sa_family))\r\nreturn -EINVAL;\r\nif (uaddr->sa_family == AF_UNSPEC)\r\nreturn sk->sk_prot->disconnect(sk, flags);\r\nreturn sk->sk_prot->connect(sk, uaddr, addr_len);\r\n}\r\nstatic int ieee802154_dev_ioctl(struct sock *sk, struct ifreq __user *arg,\r\nunsigned int cmd)\r\n{\r\nstruct ifreq ifr;\r\nint ret = -ENOIOCTLCMD;\r\nstruct net_device *dev;\r\nif (copy_from_user(&ifr, arg, sizeof(struct ifreq)))\r\nreturn -EFAULT;\r\nifr.ifr_name[IFNAMSIZ-1] = 0;\r\ndev_load(sock_net(sk), ifr.ifr_name);\r\ndev = dev_get_by_name(sock_net(sk), ifr.ifr_name);\r\nif (!dev)\r\nreturn -ENODEV;\r\nif (dev->type == ARPHRD_IEEE802154 && dev->netdev_ops->ndo_do_ioctl)\r\nret = dev->netdev_ops->ndo_do_ioctl(dev, &ifr, cmd);\r\nif (!ret && copy_to_user(arg, &ifr, sizeof(struct ifreq)))\r\nret = -EFAULT;\r\ndev_put(dev);\r\nreturn ret;\r\n}\r\nstatic int ieee802154_sock_ioctl(struct socket *sock, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct sock *sk = sock->sk;\r\nswitch (cmd) {\r\ncase SIOCGSTAMP:\r\nreturn sock_get_timestamp(sk, (struct timeval __user *)arg);\r\ncase SIOCGSTAMPNS:\r\nreturn sock_get_timestampns(sk, (struct timespec __user *)arg);\r\ncase SIOCGIFADDR:\r\ncase SIOCSIFADDR:\r\nreturn ieee802154_dev_ioctl(sk, (struct ifreq __user *)arg,\r\ncmd);\r\ndefault:\r\nif (!sk->sk_prot->ioctl)\r\nreturn -ENOIOCTLCMD;\r\nreturn sk->sk_prot->ioctl(sk, cmd, arg);\r\n}\r\n}\r\nstatic int raw_hash(struct sock *sk)\r\n{\r\nwrite_lock_bh(&raw_lock);\r\nsk_add_node(sk, &raw_head);\r\nsock_prot_inuse_add(sock_net(sk), sk->sk_prot, 1);\r\nwrite_unlock_bh(&raw_lock);\r\nreturn 0;\r\n}\r\nstatic void raw_unhash(struct sock *sk)\r\n{\r\nwrite_lock_bh(&raw_lock);\r\nif (sk_del_node_init(sk))\r\nsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\r\nwrite_unlock_bh(&raw_lock);\r\n}\r\nstatic void raw_close(struct sock *sk, long timeout)\r\n{\r\nsk_common_release(sk);\r\n}\r\nstatic int raw_bind(struct sock *sk, struct sockaddr *_uaddr, int len)\r\n{\r\nstruct ieee802154_addr addr;\r\nstruct sockaddr_ieee802154 *uaddr = (struct sockaddr_ieee802154 *)_uaddr;\r\nint err = 0;\r\nstruct net_device *dev = NULL;\r\nif (len < sizeof(*uaddr))\r\nreturn -EINVAL;\r\nuaddr = (struct sockaddr_ieee802154 *)_uaddr;\r\nif (uaddr->family != AF_IEEE802154)\r\nreturn -EINVAL;\r\nlock_sock(sk);\r\nieee802154_addr_from_sa(&addr, &uaddr->addr);\r\ndev = ieee802154_get_dev(sock_net(sk), &addr);\r\nif (!dev) {\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\nsk->sk_bound_dev_if = dev->ifindex;\r\nsk_dst_reset(sk);\r\ndev_put(dev);\r\nout:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int raw_connect(struct sock *sk, struct sockaddr *uaddr,\r\nint addr_len)\r\n{\r\nreturn -ENOTSUPP;\r\n}\r\nstatic int raw_disconnect(struct sock *sk, int flags)\r\n{\r\nreturn 0;\r\n}\r\nstatic int raw_sendmsg(struct sock *sk, struct msghdr *msg, size_t size)\r\n{\r\nstruct net_device *dev;\r\nunsigned int mtu;\r\nstruct sk_buff *skb;\r\nint hlen, tlen;\r\nint err;\r\nif (msg->msg_flags & MSG_OOB) {\r\npr_debug("msg->msg_flags = 0x%x\n", msg->msg_flags);\r\nreturn -EOPNOTSUPP;\r\n}\r\nlock_sock(sk);\r\nif (!sk->sk_bound_dev_if)\r\ndev = dev_getfirstbyhwtype(sock_net(sk), ARPHRD_IEEE802154);\r\nelse\r\ndev = dev_get_by_index(sock_net(sk), sk->sk_bound_dev_if);\r\nrelease_sock(sk);\r\nif (!dev) {\r\npr_debug("no dev\n");\r\nerr = -ENXIO;\r\ngoto out;\r\n}\r\nmtu = IEEE802154_MTU;\r\npr_debug("name = %s, mtu = %u\n", dev->name, mtu);\r\nif (size > mtu) {\r\npr_debug("size = %zu, mtu = %u\n", size, mtu);\r\nerr = -EMSGSIZE;\r\ngoto out_dev;\r\n}\r\nhlen = LL_RESERVED_SPACE(dev);\r\ntlen = dev->needed_tailroom;\r\nskb = sock_alloc_send_skb(sk, hlen + tlen + size,\r\nmsg->msg_flags & MSG_DONTWAIT, &err);\r\nif (!skb)\r\ngoto out_dev;\r\nskb_reserve(skb, hlen);\r\nskb_reset_mac_header(skb);\r\nskb_reset_network_header(skb);\r\nerr = memcpy_from_msg(skb_put(skb, size), msg, size);\r\nif (err < 0)\r\ngoto out_skb;\r\nskb->dev = dev;\r\nskb->protocol = htons(ETH_P_IEEE802154);\r\nerr = dev_queue_xmit(skb);\r\nif (err > 0)\r\nerr = net_xmit_errno(err);\r\ndev_put(dev);\r\nreturn err ?: size;\r\nout_skb:\r\nkfree_skb(skb);\r\nout_dev:\r\ndev_put(dev);\r\nout:\r\nreturn err;\r\n}\r\nstatic int raw_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,\r\nint noblock, int flags, int *addr_len)\r\n{\r\nsize_t copied = 0;\r\nint err = -EOPNOTSUPP;\r\nstruct sk_buff *skb;\r\nskb = skb_recv_datagram(sk, flags, noblock, &err);\r\nif (!skb)\r\ngoto out;\r\ncopied = skb->len;\r\nif (len < copied) {\r\nmsg->msg_flags |= MSG_TRUNC;\r\ncopied = len;\r\n}\r\nerr = skb_copy_datagram_msg(skb, 0, msg, copied);\r\nif (err)\r\ngoto done;\r\nsock_recv_ts_and_drops(msg, sk, skb);\r\nif (flags & MSG_TRUNC)\r\ncopied = skb->len;\r\ndone:\r\nskb_free_datagram(sk, skb);\r\nout:\r\nif (err)\r\nreturn err;\r\nreturn copied;\r\n}\r\nstatic int raw_rcv_skb(struct sock *sk, struct sk_buff *skb)\r\n{\r\nskb = skb_share_check(skb, GFP_ATOMIC);\r\nif (!skb)\r\nreturn NET_RX_DROP;\r\nif (sock_queue_rcv_skb(sk, skb) < 0) {\r\nkfree_skb(skb);\r\nreturn NET_RX_DROP;\r\n}\r\nreturn NET_RX_SUCCESS;\r\n}\r\nstatic void ieee802154_raw_deliver(struct net_device *dev, struct sk_buff *skb)\r\n{\r\nstruct sock *sk;\r\nread_lock(&raw_lock);\r\nsk_for_each(sk, &raw_head) {\r\nbh_lock_sock(sk);\r\nif (!sk->sk_bound_dev_if ||\r\nsk->sk_bound_dev_if == dev->ifindex) {\r\nstruct sk_buff *clone;\r\nclone = skb_clone(skb, GFP_ATOMIC);\r\nif (clone)\r\nraw_rcv_skb(sk, clone);\r\n}\r\nbh_unlock_sock(sk);\r\n}\r\nread_unlock(&raw_lock);\r\n}\r\nstatic int raw_getsockopt(struct sock *sk, int level, int optname,\r\nchar __user *optval, int __user *optlen)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int raw_setsockopt(struct sock *sk, int level, int optname,\r\nchar __user *optval, unsigned int optlen)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic inline struct dgram_sock *dgram_sk(const struct sock *sk)\r\n{\r\nreturn container_of(sk, struct dgram_sock, sk);\r\n}\r\nstatic int dgram_hash(struct sock *sk)\r\n{\r\nwrite_lock_bh(&dgram_lock);\r\nsk_add_node(sk, &dgram_head);\r\nsock_prot_inuse_add(sock_net(sk), sk->sk_prot, 1);\r\nwrite_unlock_bh(&dgram_lock);\r\nreturn 0;\r\n}\r\nstatic void dgram_unhash(struct sock *sk)\r\n{\r\nwrite_lock_bh(&dgram_lock);\r\nif (sk_del_node_init(sk))\r\nsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\r\nwrite_unlock_bh(&dgram_lock);\r\n}\r\nstatic int dgram_init(struct sock *sk)\r\n{\r\nstruct dgram_sock *ro = dgram_sk(sk);\r\nro->want_ack = 1;\r\nreturn 0;\r\n}\r\nstatic void dgram_close(struct sock *sk, long timeout)\r\n{\r\nsk_common_release(sk);\r\n}\r\nstatic int dgram_bind(struct sock *sk, struct sockaddr *uaddr, int len)\r\n{\r\nstruct sockaddr_ieee802154 *addr = (struct sockaddr_ieee802154 *)uaddr;\r\nstruct ieee802154_addr haddr;\r\nstruct dgram_sock *ro = dgram_sk(sk);\r\nint err = -EINVAL;\r\nstruct net_device *dev;\r\nlock_sock(sk);\r\nro->bound = 0;\r\nif (len < sizeof(*addr))\r\ngoto out;\r\nif (addr->family != AF_IEEE802154)\r\ngoto out;\r\nieee802154_addr_from_sa(&haddr, &addr->addr);\r\ndev = ieee802154_get_dev(sock_net(sk), &haddr);\r\nif (!dev) {\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\nif (dev->type != ARPHRD_IEEE802154) {\r\nerr = -ENODEV;\r\ngoto out_put;\r\n}\r\nro->src_addr = haddr;\r\nro->bound = 1;\r\nerr = 0;\r\nout_put:\r\ndev_put(dev);\r\nout:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int dgram_ioctl(struct sock *sk, int cmd, unsigned long arg)\r\n{\r\nswitch (cmd) {\r\ncase SIOCOUTQ:\r\n{\r\nint amount = sk_wmem_alloc_get(sk);\r\nreturn put_user(amount, (int __user *)arg);\r\n}\r\ncase SIOCINQ:\r\n{\r\nstruct sk_buff *skb;\r\nunsigned long amount;\r\namount = 0;\r\nspin_lock_bh(&sk->sk_receive_queue.lock);\r\nskb = skb_peek(&sk->sk_receive_queue);\r\nif (skb) {\r\namount = skb->len - ieee802154_hdr_length(skb);\r\n}\r\nspin_unlock_bh(&sk->sk_receive_queue.lock);\r\nreturn put_user(amount, (int __user *)arg);\r\n}\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic int dgram_connect(struct sock *sk, struct sockaddr *uaddr,\r\nint len)\r\n{\r\nstruct sockaddr_ieee802154 *addr = (struct sockaddr_ieee802154 *)uaddr;\r\nstruct dgram_sock *ro = dgram_sk(sk);\r\nint err = 0;\r\nif (len < sizeof(*addr))\r\nreturn -EINVAL;\r\nif (addr->family != AF_IEEE802154)\r\nreturn -EINVAL;\r\nlock_sock(sk);\r\nif (!ro->bound) {\r\nerr = -ENETUNREACH;\r\ngoto out;\r\n}\r\nieee802154_addr_from_sa(&ro->dst_addr, &addr->addr);\r\nro->connected = 1;\r\nout:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int dgram_disconnect(struct sock *sk, int flags)\r\n{\r\nstruct dgram_sock *ro = dgram_sk(sk);\r\nlock_sock(sk);\r\nro->connected = 0;\r\nrelease_sock(sk);\r\nreturn 0;\r\n}\r\nstatic int dgram_sendmsg(struct sock *sk, struct msghdr *msg, size_t size)\r\n{\r\nstruct net_device *dev;\r\nunsigned int mtu;\r\nstruct sk_buff *skb;\r\nstruct ieee802154_mac_cb *cb;\r\nstruct dgram_sock *ro = dgram_sk(sk);\r\nstruct ieee802154_addr dst_addr;\r\nint hlen, tlen;\r\nint err;\r\nif (msg->msg_flags & MSG_OOB) {\r\npr_debug("msg->msg_flags = 0x%x\n", msg->msg_flags);\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (!ro->connected && !msg->msg_name)\r\nreturn -EDESTADDRREQ;\r\nelse if (ro->connected && msg->msg_name)\r\nreturn -EISCONN;\r\nif (!ro->bound)\r\ndev = dev_getfirstbyhwtype(sock_net(sk), ARPHRD_IEEE802154);\r\nelse\r\ndev = ieee802154_get_dev(sock_net(sk), &ro->src_addr);\r\nif (!dev) {\r\npr_debug("no dev\n");\r\nerr = -ENXIO;\r\ngoto out;\r\n}\r\nmtu = IEEE802154_MTU;\r\npr_debug("name = %s, mtu = %u\n", dev->name, mtu);\r\nif (size > mtu) {\r\npr_debug("size = %zu, mtu = %u\n", size, mtu);\r\nerr = -EMSGSIZE;\r\ngoto out_dev;\r\n}\r\nhlen = LL_RESERVED_SPACE(dev);\r\ntlen = dev->needed_tailroom;\r\nskb = sock_alloc_send_skb(sk, hlen + tlen + size,\r\nmsg->msg_flags & MSG_DONTWAIT,\r\n&err);\r\nif (!skb)\r\ngoto out_dev;\r\nskb_reserve(skb, hlen);\r\nskb_reset_network_header(skb);\r\ncb = mac_cb_init(skb);\r\ncb->type = IEEE802154_FC_TYPE_DATA;\r\ncb->ackreq = ro->want_ack;\r\nif (msg->msg_name) {\r\nDECLARE_SOCKADDR(struct sockaddr_ieee802154*,\r\ndaddr, msg->msg_name);\r\nieee802154_addr_from_sa(&dst_addr, &daddr->addr);\r\n} else {\r\ndst_addr = ro->dst_addr;\r\n}\r\ncb->secen = ro->secen;\r\ncb->secen_override = ro->secen_override;\r\ncb->seclevel = ro->seclevel;\r\ncb->seclevel_override = ro->seclevel_override;\r\nerr = wpan_dev_hard_header(skb, dev, &dst_addr,\r\nro->bound ? &ro->src_addr : NULL, size);\r\nif (err < 0)\r\ngoto out_skb;\r\nerr = memcpy_from_msg(skb_put(skb, size), msg, size);\r\nif (err < 0)\r\ngoto out_skb;\r\nskb->dev = dev;\r\nskb->protocol = htons(ETH_P_IEEE802154);\r\nerr = dev_queue_xmit(skb);\r\nif (err > 0)\r\nerr = net_xmit_errno(err);\r\ndev_put(dev);\r\nreturn err ?: size;\r\nout_skb:\r\nkfree_skb(skb);\r\nout_dev:\r\ndev_put(dev);\r\nout:\r\nreturn err;\r\n}\r\nstatic int dgram_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,\r\nint noblock, int flags, int *addr_len)\r\n{\r\nsize_t copied = 0;\r\nint err = -EOPNOTSUPP;\r\nstruct sk_buff *skb;\r\nDECLARE_SOCKADDR(struct sockaddr_ieee802154 *, saddr, msg->msg_name);\r\nskb = skb_recv_datagram(sk, flags, noblock, &err);\r\nif (!skb)\r\ngoto out;\r\ncopied = skb->len;\r\nif (len < copied) {\r\nmsg->msg_flags |= MSG_TRUNC;\r\ncopied = len;\r\n}\r\nerr = skb_copy_datagram_msg(skb, 0, msg, copied);\r\nif (err)\r\ngoto done;\r\nsock_recv_ts_and_drops(msg, sk, skb);\r\nif (saddr) {\r\nmemset(saddr, 0, sizeof(*saddr));\r\nsaddr->family = AF_IEEE802154;\r\nieee802154_addr_to_sa(&saddr->addr, &mac_cb(skb)->source);\r\n*addr_len = sizeof(*saddr);\r\n}\r\nif (flags & MSG_TRUNC)\r\ncopied = skb->len;\r\ndone:\r\nskb_free_datagram(sk, skb);\r\nout:\r\nif (err)\r\nreturn err;\r\nreturn copied;\r\n}\r\nstatic int dgram_rcv_skb(struct sock *sk, struct sk_buff *skb)\r\n{\r\nskb = skb_share_check(skb, GFP_ATOMIC);\r\nif (!skb)\r\nreturn NET_RX_DROP;\r\nif (sock_queue_rcv_skb(sk, skb) < 0) {\r\nkfree_skb(skb);\r\nreturn NET_RX_DROP;\r\n}\r\nreturn NET_RX_SUCCESS;\r\n}\r\nstatic inline bool\r\nieee802154_match_sock(__le64 hw_addr, __le16 pan_id, __le16 short_addr,\r\nstruct dgram_sock *ro)\r\n{\r\nif (!ro->bound)\r\nreturn true;\r\nif (ro->src_addr.mode == IEEE802154_ADDR_LONG &&\r\nhw_addr == ro->src_addr.extended_addr)\r\nreturn true;\r\nif (ro->src_addr.mode == IEEE802154_ADDR_SHORT &&\r\npan_id == ro->src_addr.pan_id &&\r\nshort_addr == ro->src_addr.short_addr)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int ieee802154_dgram_deliver(struct net_device *dev, struct sk_buff *skb)\r\n{\r\nstruct sock *sk, *prev = NULL;\r\nint ret = NET_RX_SUCCESS;\r\n__le16 pan_id, short_addr;\r\n__le64 hw_addr;\r\nBUG_ON(dev->type != ARPHRD_IEEE802154);\r\npan_id = dev->ieee802154_ptr->pan_id;\r\nshort_addr = dev->ieee802154_ptr->short_addr;\r\nhw_addr = dev->ieee802154_ptr->extended_addr;\r\nread_lock(&dgram_lock);\r\nsk_for_each(sk, &dgram_head) {\r\nif (ieee802154_match_sock(hw_addr, pan_id, short_addr,\r\ndgram_sk(sk))) {\r\nif (prev) {\r\nstruct sk_buff *clone;\r\nclone = skb_clone(skb, GFP_ATOMIC);\r\nif (clone)\r\ndgram_rcv_skb(prev, clone);\r\n}\r\nprev = sk;\r\n}\r\n}\r\nif (prev) {\r\ndgram_rcv_skb(prev, skb);\r\n} else {\r\nkfree_skb(skb);\r\nret = NET_RX_DROP;\r\n}\r\nread_unlock(&dgram_lock);\r\nreturn ret;\r\n}\r\nstatic int dgram_getsockopt(struct sock *sk, int level, int optname,\r\nchar __user *optval, int __user *optlen)\r\n{\r\nstruct dgram_sock *ro = dgram_sk(sk);\r\nint val, len;\r\nif (level != SOL_IEEE802154)\r\nreturn -EOPNOTSUPP;\r\nif (get_user(len, optlen))\r\nreturn -EFAULT;\r\nlen = min_t(unsigned int, len, sizeof(int));\r\nswitch (optname) {\r\ncase WPAN_WANTACK:\r\nval = ro->want_ack;\r\nbreak;\r\ncase WPAN_SECURITY:\r\nif (!ro->secen_override)\r\nval = WPAN_SECURITY_DEFAULT;\r\nelse if (ro->secen)\r\nval = WPAN_SECURITY_ON;\r\nelse\r\nval = WPAN_SECURITY_OFF;\r\nbreak;\r\ncase WPAN_SECURITY_LEVEL:\r\nif (!ro->seclevel_override)\r\nval = WPAN_SECURITY_LEVEL_DEFAULT;\r\nelse\r\nval = ro->seclevel;\r\nbreak;\r\ndefault:\r\nreturn -ENOPROTOOPT;\r\n}\r\nif (put_user(len, optlen))\r\nreturn -EFAULT;\r\nif (copy_to_user(optval, &val, len))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int dgram_setsockopt(struct sock *sk, int level, int optname,\r\nchar __user *optval, unsigned int optlen)\r\n{\r\nstruct dgram_sock *ro = dgram_sk(sk);\r\nstruct net *net = sock_net(sk);\r\nint val;\r\nint err = 0;\r\nif (optlen < sizeof(int))\r\nreturn -EINVAL;\r\nif (get_user(val, (int __user *)optval))\r\nreturn -EFAULT;\r\nlock_sock(sk);\r\nswitch (optname) {\r\ncase WPAN_WANTACK:\r\nro->want_ack = !!val;\r\nbreak;\r\ncase WPAN_SECURITY:\r\nif (!ns_capable(net->user_ns, CAP_NET_ADMIN) &&\r\n!ns_capable(net->user_ns, CAP_NET_RAW)) {\r\nerr = -EPERM;\r\nbreak;\r\n}\r\nswitch (val) {\r\ncase WPAN_SECURITY_DEFAULT:\r\nro->secen_override = 0;\r\nbreak;\r\ncase WPAN_SECURITY_ON:\r\nro->secen_override = 1;\r\nro->secen = 1;\r\nbreak;\r\ncase WPAN_SECURITY_OFF:\r\nro->secen_override = 1;\r\nro->secen = 0;\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nbreak;\r\ncase WPAN_SECURITY_LEVEL:\r\nif (!ns_capable(net->user_ns, CAP_NET_ADMIN) &&\r\n!ns_capable(net->user_ns, CAP_NET_RAW)) {\r\nerr = -EPERM;\r\nbreak;\r\n}\r\nif (val < WPAN_SECURITY_LEVEL_DEFAULT ||\r\nval > IEEE802154_SCF_SECLEVEL_ENC_MIC128) {\r\nerr = -EINVAL;\r\n} else if (val == WPAN_SECURITY_LEVEL_DEFAULT) {\r\nro->seclevel_override = 0;\r\n} else {\r\nro->seclevel_override = 1;\r\nro->seclevel = val;\r\n}\r\nbreak;\r\ndefault:\r\nerr = -ENOPROTOOPT;\r\nbreak;\r\n}\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int ieee802154_create(struct net *net, struct socket *sock,\r\nint protocol, int kern)\r\n{\r\nstruct sock *sk;\r\nint rc;\r\nstruct proto *proto;\r\nconst struct proto_ops *ops;\r\nif (!net_eq(net, &init_net))\r\nreturn -EAFNOSUPPORT;\r\nswitch (sock->type) {\r\ncase SOCK_RAW:\r\nproto = &ieee802154_raw_prot;\r\nops = &ieee802154_raw_ops;\r\nbreak;\r\ncase SOCK_DGRAM:\r\nproto = &ieee802154_dgram_prot;\r\nops = &ieee802154_dgram_ops;\r\nbreak;\r\ndefault:\r\nrc = -ESOCKTNOSUPPORT;\r\ngoto out;\r\n}\r\nrc = -ENOMEM;\r\nsk = sk_alloc(net, PF_IEEE802154, GFP_KERNEL, proto, kern);\r\nif (!sk)\r\ngoto out;\r\nrc = 0;\r\nsock->ops = ops;\r\nsock_init_data(sock, sk);\r\nsk->sk_family = PF_IEEE802154;\r\nsock_set_flag(sk, SOCK_ZAPPED);\r\nif (sk->sk_prot->hash) {\r\nrc = sk->sk_prot->hash(sk);\r\nif (rc) {\r\nsk_common_release(sk);\r\ngoto out;\r\n}\r\n}\r\nif (sk->sk_prot->init) {\r\nrc = sk->sk_prot->init(sk);\r\nif (rc)\r\nsk_common_release(sk);\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nstatic int ieee802154_rcv(struct sk_buff *skb, struct net_device *dev,\r\nstruct packet_type *pt, struct net_device *orig_dev)\r\n{\r\nif (!netif_running(dev))\r\ngoto drop;\r\npr_debug("got frame, type %d, dev %p\n", dev->type, dev);\r\n#ifdef DEBUG\r\nprint_hex_dump_bytes("ieee802154_rcv ",\r\nDUMP_PREFIX_NONE, skb->data, skb->len);\r\n#endif\r\nif (!net_eq(dev_net(dev), &init_net))\r\ngoto drop;\r\nieee802154_raw_deliver(dev, skb);\r\nif (dev->type != ARPHRD_IEEE802154)\r\ngoto drop;\r\nif (skb->pkt_type != PACKET_OTHERHOST)\r\nreturn ieee802154_dgram_deliver(dev, skb);\r\ndrop:\r\nkfree_skb(skb);\r\nreturn NET_RX_DROP;\r\n}\r\nstatic int __init af_ieee802154_init(void)\r\n{\r\nint rc = -EINVAL;\r\nrc = proto_register(&ieee802154_raw_prot, 1);\r\nif (rc)\r\ngoto out;\r\nrc = proto_register(&ieee802154_dgram_prot, 1);\r\nif (rc)\r\ngoto err_dgram;\r\nrc = sock_register(&ieee802154_family_ops);\r\nif (rc)\r\ngoto err_sock;\r\ndev_add_pack(&ieee802154_packet_type);\r\nrc = 0;\r\ngoto out;\r\nerr_sock:\r\nproto_unregister(&ieee802154_dgram_prot);\r\nerr_dgram:\r\nproto_unregister(&ieee802154_raw_prot);\r\nout:\r\nreturn rc;\r\n}\r\nstatic void __exit af_ieee802154_remove(void)\r\n{\r\ndev_remove_pack(&ieee802154_packet_type);\r\nsock_unregister(PF_IEEE802154);\r\nproto_unregister(&ieee802154_dgram_prot);\r\nproto_unregister(&ieee802154_raw_prot);\r\n}
