static int bcm53573_ilp_enable(struct clk_hw *hw)\r\n{\r\nstruct bcm53573_ilp *ilp = container_of(hw, struct bcm53573_ilp, hw);\r\nregmap_write(ilp->regmap, PMU_SLOW_CLK_PERIOD, 0x10199);\r\nregmap_write(ilp->regmap, 0x674, 0x10000);\r\nreturn 0;\r\n}\r\nstatic void bcm53573_ilp_disable(struct clk_hw *hw)\r\n{\r\nstruct bcm53573_ilp *ilp = container_of(hw, struct bcm53573_ilp, hw);\r\nregmap_write(ilp->regmap, PMU_SLOW_CLK_PERIOD, 0);\r\nregmap_write(ilp->regmap, 0x674, 0);\r\n}\r\nstatic unsigned long bcm53573_ilp_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct bcm53573_ilp *ilp = container_of(hw, struct bcm53573_ilp, hw);\r\nstruct regmap *regmap = ilp->regmap;\r\nu32 last_val, cur_val;\r\nint sum = 0, num = 0, loop_num = 0;\r\nint avg;\r\nregmap_write(regmap, PMU_XTAL_FREQ_RATIO, XTAL_CTL_EN);\r\nregmap_read(regmap, PMU_XTAL_FREQ_RATIO, &last_val);\r\nlast_val &= XTAL_ALP_PER_4ILP;\r\nwhile (num < 20) {\r\nregmap_read(regmap, PMU_XTAL_FREQ_RATIO, &cur_val);\r\ncur_val &= XTAL_ALP_PER_4ILP;\r\nif (cur_val != last_val) {\r\nsum += cur_val;\r\nnum++;\r\nloop_num = 0;\r\nlast_val = cur_val;\r\n} else if (++loop_num > 5000) {\r\nsum += cur_val;\r\nnum++;\r\nbreak;\r\n}\r\ncpu_relax();\r\n}\r\nregmap_write(regmap, PMU_XTAL_FREQ_RATIO, 0x0);\r\navg = sum / num;\r\nreturn parent_rate * 4 / avg;\r\n}\r\nstatic void bcm53573_ilp_init(struct device_node *np)\r\n{\r\nstruct bcm53573_ilp *ilp;\r\nstruct clk_init_data init = { };\r\nconst char *parent_name;\r\nint err;\r\nilp = kzalloc(sizeof(*ilp), GFP_KERNEL);\r\nif (!ilp)\r\nreturn;\r\nparent_name = of_clk_get_parent_name(np, 0);\r\nif (!parent_name) {\r\nerr = -ENOENT;\r\ngoto err_free_ilp;\r\n}\r\nilp->regmap = syscon_node_to_regmap(of_get_parent(np));\r\nif (IS_ERR(ilp->regmap)) {\r\nerr = PTR_ERR(ilp->regmap);\r\ngoto err_free_ilp;\r\n}\r\ninit.name = np->name;\r\ninit.ops = &bcm53573_ilp_clk_ops;\r\ninit.parent_names = &parent_name;\r\ninit.num_parents = 1;\r\nilp->hw.init = &init;\r\nerr = clk_hw_register(NULL, &ilp->hw);\r\nif (err)\r\ngoto err_free_ilp;\r\nerr = of_clk_add_hw_provider(np, of_clk_hw_simple_get, &ilp->hw);\r\nif (err)\r\ngoto err_clk_hw_unregister;\r\nreturn;\r\nerr_clk_hw_unregister:\r\nclk_hw_unregister(&ilp->hw);\r\nerr_free_ilp:\r\nkfree(ilp);\r\npr_err("Failed to init ILP clock: %d\n", err);\r\n}
