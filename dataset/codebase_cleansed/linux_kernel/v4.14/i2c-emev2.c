static inline void em_clear_set_bit(struct em_i2c_device *priv, u8 clear, u8 set, u8 reg)\r\n{\r\nwriteb((readb(priv->base + reg) & ~clear) | set, priv->base + reg);\r\n}\r\nstatic int em_i2c_wait_for_event(struct em_i2c_device *priv)\r\n{\r\nunsigned long time_left;\r\nint status;\r\nreinit_completion(&priv->msg_done);\r\ntime_left = wait_for_completion_timeout(&priv->msg_done, priv->adap.timeout);\r\nif (!time_left)\r\nreturn -ETIMEDOUT;\r\nstatus = readb(priv->base + I2C_OFS_IICSE0);\r\nreturn status & I2C_BIT_ALD0 ? -EAGAIN : status;\r\n}\r\nstatic void em_i2c_stop(struct em_i2c_device *priv)\r\n{\r\nem_clear_set_bit(priv, 0, I2C_BIT_SPT0 | I2C_BIT_SPIE0, I2C_OFS_IICC0);\r\nem_i2c_wait_for_event(priv);\r\n}\r\nstatic void em_i2c_reset(struct i2c_adapter *adap)\r\n{\r\nstruct em_i2c_device *priv = i2c_get_adapdata(adap);\r\nint retr;\r\nif (readb(priv->base + I2C_OFS_IICACT0) & I2C_BIT_IICE0) {\r\nwriteb(0, priv->base + I2C_OFS_IICACT0);\r\nretr = 1000;\r\nwhile (readb(priv->base + I2C_OFS_IICACT0) == 1 && retr)\r\nretr--;\r\nWARN_ON(retr == 0);\r\n}\r\nwriteb(I2C_BIT_DFC0, priv->base + I2C_OFS_IICCL0);\r\nwriteb(I2C_BIT_STCEN | I2C_BIT_IICRSV, priv->base + I2C_OFS_IICF0);\r\nwriteb(I2C_BIT_WTIM0, priv->base + I2C_OFS_IICC0);\r\nwriteb(I2C_BIT_IICE0, priv->base + I2C_OFS_IICACT0);\r\nretr = 1000;\r\nwhile (readb(priv->base + I2C_OFS_IICACT0) == 0 && retr)\r\nretr--;\r\nWARN_ON(retr == 0);\r\n}\r\nstatic int __em_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msg,\r\nint stop)\r\n{\r\nstruct em_i2c_device *priv = i2c_get_adapdata(adap);\r\nint count, status, read = !!(msg->flags & I2C_M_RD);\r\nem_clear_set_bit(priv, 0, I2C_BIT_ACKE0 | I2C_BIT_WTIM0, I2C_OFS_IICC0);\r\nem_clear_set_bit(priv, 0, I2C_BIT_STT0, I2C_OFS_IICC0);\r\nwriteb((msg->addr << 1) | read, priv->base + I2C_OFS_IIC0);\r\nstatus = em_i2c_wait_for_event(priv);\r\nif (status < 0)\r\ngoto out_reset;\r\nif (!(status & I2C_BIT_ACKD0)) {\r\nem_i2c_stop(priv);\r\ngoto out;\r\n}\r\nif (read) {\r\nem_clear_set_bit(priv, I2C_BIT_WTIM0, I2C_BIT_ACKE0, I2C_OFS_IICC0);\r\nem_clear_set_bit(priv, I2C_BIT_WTIM0, I2C_BIT_WREL0, I2C_OFS_IICC0);\r\nstatus = em_i2c_wait_for_event(priv);\r\nif (status < 0)\r\ngoto out_reset;\r\n}\r\nfor (count = 0; count < msg->len; count++) {\r\nif (read) {\r\nmsg->buf[count] = readb(priv->base + I2C_OFS_IIC0);\r\nem_clear_set_bit(priv, 0, I2C_BIT_WREL0, I2C_OFS_IICC0);\r\n} else {\r\nif (!(status & I2C_BIT_ACKD0)) {\r\nem_i2c_stop(priv);\r\ngoto out;\r\n}\r\nwriteb(msg->buf[count], priv->base + I2C_OFS_IIC0);\r\n}\r\nstatus = em_i2c_wait_for_event(priv);\r\nif (status < 0)\r\ngoto out_reset;\r\n}\r\nif (stop)\r\nem_i2c_stop(priv);\r\nreturn count;\r\nout_reset:\r\nem_i2c_reset(adap);\r\nout:\r\nreturn status < 0 ? status : -ENXIO;\r\n}\r\nstatic int em_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,\r\nint num)\r\n{\r\nstruct em_i2c_device *priv = i2c_get_adapdata(adap);\r\nint ret, i;\r\nif (readb(priv->base + I2C_OFS_IICF0) & I2C_BIT_IICBSY)\r\nreturn -EAGAIN;\r\nfor (i = 0; i < num; i++) {\r\nret = __em_i2c_xfer(adap, &msgs[i], (i == (num - 1)));\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn num;\r\n}\r\nstatic bool em_i2c_slave_irq(struct em_i2c_device *priv)\r\n{\r\nu8 status, value;\r\nenum i2c_slave_event event;\r\nint ret;\r\nif (!priv->slave)\r\nreturn false;\r\nstatus = readb(priv->base + I2C_OFS_IICSE0);\r\nif (status & I2C_BIT_EXC0) {\r\nem_clear_set_bit(priv, 0, I2C_BIT_LREL0, I2C_OFS_IICC0);\r\nreturn true;\r\n}\r\nif (status & I2C_BIT_SPD0) {\r\ni2c_slave_event(priv->slave, I2C_SLAVE_STOP, &value);\r\nreturn false;\r\n}\r\nif (!(status & I2C_BIT_COI0))\r\nreturn false;\r\nem_clear_set_bit(priv, 0, I2C_BIT_SPIE0, I2C_OFS_IICC0);\r\nif (status & I2C_BIT_TRC0) {\r\nif (status & I2C_BIT_ACKD0) {\r\nem_clear_set_bit(priv, 0, I2C_BIT_WTIM0, I2C_OFS_IICC0);\r\nevent = status & I2C_BIT_STD0 ?\r\nI2C_SLAVE_READ_REQUESTED :\r\nI2C_SLAVE_READ_PROCESSED;\r\ni2c_slave_event(priv->slave, event, &value);\r\nwriteb(value, priv->base + I2C_OFS_IIC0);\r\n} else {\r\nem_clear_set_bit(priv, 0, I2C_BIT_LREL0, I2C_OFS_IICC0);\r\n}\r\n} else {\r\nem_clear_set_bit(priv, I2C_BIT_WTIM0, I2C_BIT_ACKE0,\r\nI2C_OFS_IICC0);\r\nem_clear_set_bit(priv, I2C_BIT_WTIM0, I2C_BIT_WREL0,\r\nI2C_OFS_IICC0);\r\nif (status & I2C_BIT_STD0) {\r\ni2c_slave_event(priv->slave, I2C_SLAVE_WRITE_REQUESTED,\r\n&value);\r\n} else {\r\nvalue = readb(priv->base + I2C_OFS_IIC0);\r\nret = i2c_slave_event(priv->slave,\r\nI2C_SLAVE_WRITE_RECEIVED, &value);\r\nif (ret < 0)\r\nem_clear_set_bit(priv, I2C_BIT_ACKE0, 0,\r\nI2C_OFS_IICC0);\r\n}\r\n}\r\nreturn true;\r\n}\r\nstatic irqreturn_t em_i2c_irq_handler(int this_irq, void *dev_id)\r\n{\r\nstruct em_i2c_device *priv = dev_id;\r\nif (em_i2c_slave_irq(priv))\r\nreturn IRQ_HANDLED;\r\ncomplete(&priv->msg_done);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic u32 em_i2c_func(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_SLAVE;\r\n}\r\nstatic int em_i2c_reg_slave(struct i2c_client *slave)\r\n{\r\nstruct em_i2c_device *priv = i2c_get_adapdata(slave->adapter);\r\nif (priv->slave)\r\nreturn -EBUSY;\r\nif (slave->flags & I2C_CLIENT_TEN)\r\nreturn -EAFNOSUPPORT;\r\npriv->slave = slave;\r\nwriteb(slave->addr << 1, priv->base + I2C_OFS_SVA0);\r\nreturn 0;\r\n}\r\nstatic int em_i2c_unreg_slave(struct i2c_client *slave)\r\n{\r\nstruct em_i2c_device *priv = i2c_get_adapdata(slave->adapter);\r\nWARN_ON(!priv->slave);\r\nwriteb(0, priv->base + I2C_OFS_SVA0);\r\npriv->slave = NULL;\r\nreturn 0;\r\n}\r\nstatic int em_i2c_probe(struct platform_device *pdev)\r\n{\r\nstruct em_i2c_device *priv;\r\nstruct resource *r;\r\nint irq, ret;\r\npriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npriv->base = devm_ioremap_resource(&pdev->dev, r);\r\nif (IS_ERR(priv->base))\r\nreturn PTR_ERR(priv->base);\r\nstrlcpy(priv->adap.name, "EMEV2 I2C", sizeof(priv->adap.name));\r\npriv->sclk = devm_clk_get(&pdev->dev, "sclk");\r\nif (IS_ERR(priv->sclk))\r\nreturn PTR_ERR(priv->sclk);\r\nret = clk_prepare_enable(priv->sclk);\r\nif (ret)\r\nreturn ret;\r\npriv->adap.timeout = msecs_to_jiffies(100);\r\npriv->adap.retries = 5;\r\npriv->adap.dev.parent = &pdev->dev;\r\npriv->adap.algo = &em_i2c_algo;\r\npriv->adap.owner = THIS_MODULE;\r\npriv->adap.dev.of_node = pdev->dev.of_node;\r\ninit_completion(&priv->msg_done);\r\nplatform_set_drvdata(pdev, priv);\r\ni2c_set_adapdata(&priv->adap, priv);\r\nem_i2c_reset(&priv->adap);\r\nirq = platform_get_irq(pdev, 0);\r\nret = devm_request_irq(&pdev->dev, irq, em_i2c_irq_handler, 0,\r\n"em_i2c", priv);\r\nif (ret)\r\ngoto err_clk;\r\nret = i2c_add_adapter(&priv->adap);\r\nif (ret)\r\ngoto err_clk;\r\ndev_info(&pdev->dev, "Added i2c controller %d, irq %d\n", priv->adap.nr, irq);\r\nreturn 0;\r\nerr_clk:\r\nclk_disable_unprepare(priv->sclk);\r\nreturn ret;\r\n}\r\nstatic int em_i2c_remove(struct platform_device *dev)\r\n{\r\nstruct em_i2c_device *priv = platform_get_drvdata(dev);\r\ni2c_del_adapter(&priv->adap);\r\nclk_disable_unprepare(priv->sclk);\r\nreturn 0;\r\n}
