static struct virtio_ccw_device *to_vc_device(struct virtio_device *vdev)\r\n{\r\nreturn container_of(vdev, struct virtio_ccw_device, vdev);\r\n}\r\nstatic void drop_airq_indicator(struct virtqueue *vq, struct airq_info *info)\r\n{\r\nunsigned long i, flags;\r\nwrite_lock_irqsave(&info->lock, flags);\r\nfor (i = 0; i < airq_iv_end(info->aiv); i++) {\r\nif (vq == (void *)airq_iv_get_ptr(info->aiv, i)) {\r\nairq_iv_free_bit(info->aiv, i);\r\nairq_iv_set_ptr(info->aiv, i, 0);\r\nbreak;\r\n}\r\n}\r\nwrite_unlock_irqrestore(&info->lock, flags);\r\n}\r\nstatic void virtio_airq_handler(struct airq_struct *airq)\r\n{\r\nstruct airq_info *info = container_of(airq, struct airq_info, airq);\r\nunsigned long ai;\r\ninc_irq_stat(IRQIO_VAI);\r\nread_lock(&info->lock);\r\nfor (ai = 0;;) {\r\nai = airq_iv_scan(info->aiv, ai, airq_iv_end(info->aiv));\r\nif (ai == -1UL)\r\nbreak;\r\nvring_interrupt(0, (void *)airq_iv_get_ptr(info->aiv, ai));\r\n}\r\ninfo->summary_indicator = 0;\r\nsmp_wmb();\r\nfor (ai = 0;;) {\r\nai = airq_iv_scan(info->aiv, ai, airq_iv_end(info->aiv));\r\nif (ai == -1UL)\r\nbreak;\r\nvring_interrupt(0, (void *)airq_iv_get_ptr(info->aiv, ai));\r\n}\r\nread_unlock(&info->lock);\r\n}\r\nstatic struct airq_info *new_airq_info(void)\r\n{\r\nstruct airq_info *info;\r\nint rc;\r\ninfo = kzalloc(sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn NULL;\r\nrwlock_init(&info->lock);\r\ninfo->aiv = airq_iv_create(VIRTIO_IV_BITS, AIRQ_IV_ALLOC | AIRQ_IV_PTR);\r\nif (!info->aiv) {\r\nkfree(info);\r\nreturn NULL;\r\n}\r\ninfo->airq.handler = virtio_airq_handler;\r\ninfo->airq.lsi_ptr = &info->summary_indicator;\r\ninfo->airq.lsi_mask = 0xff;\r\ninfo->airq.isc = VIRTIO_AIRQ_ISC;\r\nrc = register_adapter_interrupt(&info->airq);\r\nif (rc) {\r\nairq_iv_release(info->aiv);\r\nkfree(info);\r\nreturn NULL;\r\n}\r\nreturn info;\r\n}\r\nstatic unsigned long get_airq_indicator(struct virtqueue *vqs[], int nvqs,\r\nu64 *first, void **airq_info)\r\n{\r\nint i, j;\r\nstruct airq_info *info;\r\nunsigned long indicator_addr = 0;\r\nunsigned long bit, flags;\r\nfor (i = 0; i < MAX_AIRQ_AREAS && !indicator_addr; i++) {\r\nif (!airq_areas[i])\r\nairq_areas[i] = new_airq_info();\r\ninfo = airq_areas[i];\r\nif (!info)\r\nreturn 0;\r\nwrite_lock_irqsave(&info->lock, flags);\r\nbit = airq_iv_alloc(info->aiv, nvqs);\r\nif (bit == -1UL) {\r\nwrite_unlock_irqrestore(&info->lock, flags);\r\ncontinue;\r\n}\r\n*first = bit;\r\n*airq_info = info;\r\nindicator_addr = (unsigned long)info->aiv->vector;\r\nfor (j = 0; j < nvqs; j++) {\r\nairq_iv_set_ptr(info->aiv, bit + j,\r\n(unsigned long)vqs[j]);\r\n}\r\nwrite_unlock_irqrestore(&info->lock, flags);\r\n}\r\nreturn indicator_addr;\r\n}\r\nstatic void virtio_ccw_drop_indicators(struct virtio_ccw_device *vcdev)\r\n{\r\nstruct virtio_ccw_vq_info *info;\r\nlist_for_each_entry(info, &vcdev->virtqueues, node)\r\ndrop_airq_indicator(info->vq, vcdev->airq_info);\r\n}\r\nstatic int doing_io(struct virtio_ccw_device *vcdev, __u32 flag)\r\n{\r\nunsigned long flags;\r\n__u32 ret;\r\nspin_lock_irqsave(get_ccwdev_lock(vcdev->cdev), flags);\r\nif (vcdev->err)\r\nret = 0;\r\nelse\r\nret = vcdev->curr_io & flag;\r\nspin_unlock_irqrestore(get_ccwdev_lock(vcdev->cdev), flags);\r\nreturn ret;\r\n}\r\nstatic int ccw_io_helper(struct virtio_ccw_device *vcdev,\r\nstruct ccw1 *ccw, __u32 intparm)\r\n{\r\nint ret;\r\nunsigned long flags;\r\nint flag = intparm & VIRTIO_CCW_INTPARM_MASK;\r\ndo {\r\nspin_lock_irqsave(get_ccwdev_lock(vcdev->cdev), flags);\r\nret = ccw_device_start(vcdev->cdev, ccw, intparm, 0, 0);\r\nif (!ret) {\r\nif (!vcdev->curr_io)\r\nvcdev->err = 0;\r\nvcdev->curr_io |= flag;\r\n}\r\nspin_unlock_irqrestore(get_ccwdev_lock(vcdev->cdev), flags);\r\ncpu_relax();\r\n} while (ret == -EBUSY);\r\nwait_event(vcdev->wait_q, doing_io(vcdev, flag) == 0);\r\nreturn ret ? ret : vcdev->err;\r\n}\r\nstatic void virtio_ccw_drop_indicator(struct virtio_ccw_device *vcdev,\r\nstruct ccw1 *ccw)\r\n{\r\nint ret;\r\nunsigned long *indicatorp = NULL;\r\nstruct virtio_thinint_area *thinint_area = NULL;\r\nstruct airq_info *airq_info = vcdev->airq_info;\r\nif (vcdev->is_thinint) {\r\nthinint_area = kzalloc(sizeof(*thinint_area),\r\nGFP_DMA | GFP_KERNEL);\r\nif (!thinint_area)\r\nreturn;\r\nthinint_area->summary_indicator =\r\n(unsigned long) &airq_info->summary_indicator;\r\nthinint_area->isc = VIRTIO_AIRQ_ISC;\r\nccw->cmd_code = CCW_CMD_SET_IND_ADAPTER;\r\nccw->count = sizeof(*thinint_area);\r\nccw->cda = (__u32)(unsigned long) thinint_area;\r\n} else {\r\nindicatorp = kmalloc(sizeof(&vcdev->indicators),\r\nGFP_DMA | GFP_KERNEL);\r\nif (!indicatorp)\r\nreturn;\r\n*indicatorp = 0;\r\nccw->cmd_code = CCW_CMD_SET_IND;\r\nccw->count = sizeof(&vcdev->indicators);\r\nccw->cda = (__u32)(unsigned long) indicatorp;\r\n}\r\nvcdev->indicators = 0;\r\nccw->flags = 0;\r\nret = ccw_io_helper(vcdev, ccw,\r\nvcdev->is_thinint ?\r\nVIRTIO_CCW_DOING_SET_IND_ADAPTER :\r\nVIRTIO_CCW_DOING_SET_IND);\r\nif (ret && (ret != -ENODEV))\r\ndev_info(&vcdev->cdev->dev,\r\n"Failed to deregister indicators (%d)\n", ret);\r\nelse if (vcdev->is_thinint)\r\nvirtio_ccw_drop_indicators(vcdev);\r\nkfree(indicatorp);\r\nkfree(thinint_area);\r\n}\r\nstatic inline long __do_kvm_notify(struct subchannel_id schid,\r\nunsigned long queue_index,\r\nlong cookie)\r\n{\r\nregister unsigned long __nr asm("1") = KVM_S390_VIRTIO_CCW_NOTIFY;\r\nregister struct subchannel_id __schid asm("2") = schid;\r\nregister unsigned long __index asm("3") = queue_index;\r\nregister long __rc asm("2");\r\nregister long __cookie asm("4") = cookie;\r\nasm volatile ("diag 2,4,0x500\n"\r\n: "=d" (__rc) : "d" (__nr), "d" (__schid), "d" (__index),\r\n"d"(__cookie)\r\n: "memory", "cc");\r\nreturn __rc;\r\n}\r\nstatic inline long do_kvm_notify(struct subchannel_id schid,\r\nunsigned long queue_index,\r\nlong cookie)\r\n{\r\ndiag_stat_inc(DIAG_STAT_X500);\r\nreturn __do_kvm_notify(schid, queue_index, cookie);\r\n}\r\nstatic bool virtio_ccw_kvm_notify(struct virtqueue *vq)\r\n{\r\nstruct virtio_ccw_vq_info *info = vq->priv;\r\nstruct virtio_ccw_device *vcdev;\r\nstruct subchannel_id schid;\r\nvcdev = to_vc_device(info->vq->vdev);\r\nccw_device_get_schid(vcdev->cdev, &schid);\r\ninfo->cookie = do_kvm_notify(schid, vq->index, info->cookie);\r\nif (info->cookie < 0)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int virtio_ccw_read_vq_conf(struct virtio_ccw_device *vcdev,\r\nstruct ccw1 *ccw, int index)\r\n{\r\nint ret;\r\nvcdev->config_block->index = index;\r\nccw->cmd_code = CCW_CMD_READ_VQ_CONF;\r\nccw->flags = 0;\r\nccw->count = sizeof(struct vq_config_block);\r\nccw->cda = (__u32)(unsigned long)(vcdev->config_block);\r\nret = ccw_io_helper(vcdev, ccw, VIRTIO_CCW_DOING_READ_VQ_CONF);\r\nif (ret)\r\nreturn ret;\r\nreturn vcdev->config_block->num;\r\n}\r\nstatic void virtio_ccw_del_vq(struct virtqueue *vq, struct ccw1 *ccw)\r\n{\r\nstruct virtio_ccw_device *vcdev = to_vc_device(vq->vdev);\r\nstruct virtio_ccw_vq_info *info = vq->priv;\r\nunsigned long flags;\r\nunsigned long size;\r\nint ret;\r\nunsigned int index = vq->index;\r\nspin_lock_irqsave(&vcdev->lock, flags);\r\nlist_del(&info->node);\r\nspin_unlock_irqrestore(&vcdev->lock, flags);\r\nif (vcdev->revision == 0) {\r\ninfo->info_block->l.queue = 0;\r\ninfo->info_block->l.align = 0;\r\ninfo->info_block->l.index = index;\r\ninfo->info_block->l.num = 0;\r\nccw->count = sizeof(info->info_block->l);\r\n} else {\r\ninfo->info_block->s.desc = 0;\r\ninfo->info_block->s.index = index;\r\ninfo->info_block->s.num = 0;\r\ninfo->info_block->s.avail = 0;\r\ninfo->info_block->s.used = 0;\r\nccw->count = sizeof(info->info_block->s);\r\n}\r\nccw->cmd_code = CCW_CMD_SET_VQ;\r\nccw->flags = 0;\r\nccw->cda = (__u32)(unsigned long)(info->info_block);\r\nret = ccw_io_helper(vcdev, ccw,\r\nVIRTIO_CCW_DOING_SET_VQ | index);\r\nif (ret && (ret != -ENODEV))\r\ndev_warn(&vq->vdev->dev, "Error %d while deleting queue %d\n",\r\nret, index);\r\nvring_del_virtqueue(vq);\r\nsize = PAGE_ALIGN(vring_size(info->num, KVM_VIRTIO_CCW_RING_ALIGN));\r\nfree_pages_exact(info->queue, size);\r\nkfree(info->info_block);\r\nkfree(info);\r\n}\r\nstatic void virtio_ccw_del_vqs(struct virtio_device *vdev)\r\n{\r\nstruct virtqueue *vq, *n;\r\nstruct ccw1 *ccw;\r\nstruct virtio_ccw_device *vcdev = to_vc_device(vdev);\r\nccw = kzalloc(sizeof(*ccw), GFP_DMA | GFP_KERNEL);\r\nif (!ccw)\r\nreturn;\r\nvirtio_ccw_drop_indicator(vcdev, ccw);\r\nlist_for_each_entry_safe(vq, n, &vdev->vqs, list)\r\nvirtio_ccw_del_vq(vq, ccw);\r\nkfree(ccw);\r\n}\r\nstatic struct virtqueue *virtio_ccw_setup_vq(struct virtio_device *vdev,\r\nint i, vq_callback_t *callback,\r\nconst char *name, bool ctx,\r\nstruct ccw1 *ccw)\r\n{\r\nstruct virtio_ccw_device *vcdev = to_vc_device(vdev);\r\nint err;\r\nstruct virtqueue *vq = NULL;\r\nstruct virtio_ccw_vq_info *info;\r\nunsigned long size = 0;\r\nunsigned long flags;\r\ninfo = kzalloc(sizeof(struct virtio_ccw_vq_info), GFP_KERNEL);\r\nif (!info) {\r\ndev_warn(&vcdev->cdev->dev, "no info\n");\r\nerr = -ENOMEM;\r\ngoto out_err;\r\n}\r\ninfo->info_block = kzalloc(sizeof(*info->info_block),\r\nGFP_DMA | GFP_KERNEL);\r\nif (!info->info_block) {\r\ndev_warn(&vcdev->cdev->dev, "no info block\n");\r\nerr = -ENOMEM;\r\ngoto out_err;\r\n}\r\ninfo->num = virtio_ccw_read_vq_conf(vcdev, ccw, i);\r\nif (info->num < 0) {\r\nerr = info->num;\r\ngoto out_err;\r\n}\r\nsize = PAGE_ALIGN(vring_size(info->num, KVM_VIRTIO_CCW_RING_ALIGN));\r\ninfo->queue = alloc_pages_exact(size, GFP_KERNEL | __GFP_ZERO);\r\nif (info->queue == NULL) {\r\ndev_warn(&vcdev->cdev->dev, "no queue\n");\r\nerr = -ENOMEM;\r\ngoto out_err;\r\n}\r\nvq = vring_new_virtqueue(i, info->num, KVM_VIRTIO_CCW_RING_ALIGN, vdev,\r\ntrue, ctx, info->queue, virtio_ccw_kvm_notify,\r\ncallback, name);\r\nif (!vq) {\r\ndev_warn(&vcdev->cdev->dev, "no vq\n");\r\nerr = -ENOMEM;\r\ngoto out_err;\r\n}\r\nif (vcdev->revision == 0) {\r\ninfo->info_block->l.queue = (__u64)info->queue;\r\ninfo->info_block->l.align = KVM_VIRTIO_CCW_RING_ALIGN;\r\ninfo->info_block->l.index = i;\r\ninfo->info_block->l.num = info->num;\r\nccw->count = sizeof(info->info_block->l);\r\n} else {\r\ninfo->info_block->s.desc = (__u64)info->queue;\r\ninfo->info_block->s.index = i;\r\ninfo->info_block->s.num = info->num;\r\ninfo->info_block->s.avail = (__u64)virtqueue_get_avail(vq);\r\ninfo->info_block->s.used = (__u64)virtqueue_get_used(vq);\r\nccw->count = sizeof(info->info_block->s);\r\n}\r\nccw->cmd_code = CCW_CMD_SET_VQ;\r\nccw->flags = 0;\r\nccw->cda = (__u32)(unsigned long)(info->info_block);\r\nerr = ccw_io_helper(vcdev, ccw, VIRTIO_CCW_DOING_SET_VQ | i);\r\nif (err) {\r\ndev_warn(&vcdev->cdev->dev, "SET_VQ failed\n");\r\ngoto out_err;\r\n}\r\ninfo->vq = vq;\r\nvq->priv = info;\r\nspin_lock_irqsave(&vcdev->lock, flags);\r\nlist_add(&info->node, &vcdev->virtqueues);\r\nspin_unlock_irqrestore(&vcdev->lock, flags);\r\nreturn vq;\r\nout_err:\r\nif (vq)\r\nvring_del_virtqueue(vq);\r\nif (info) {\r\nif (info->queue)\r\nfree_pages_exact(info->queue, size);\r\nkfree(info->info_block);\r\n}\r\nkfree(info);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int virtio_ccw_register_adapter_ind(struct virtio_ccw_device *vcdev,\r\nstruct virtqueue *vqs[], int nvqs,\r\nstruct ccw1 *ccw)\r\n{\r\nint ret;\r\nstruct virtio_thinint_area *thinint_area = NULL;\r\nstruct airq_info *info;\r\nthinint_area = kzalloc(sizeof(*thinint_area), GFP_DMA | GFP_KERNEL);\r\nif (!thinint_area) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nthinint_area->indicator = get_airq_indicator(vqs, nvqs,\r\n&thinint_area->bit_nr,\r\n&vcdev->airq_info);\r\nif (!thinint_area->indicator) {\r\nret = -ENOSPC;\r\ngoto out;\r\n}\r\ninfo = vcdev->airq_info;\r\nthinint_area->summary_indicator =\r\n(unsigned long) &info->summary_indicator;\r\nthinint_area->isc = VIRTIO_AIRQ_ISC;\r\nccw->cmd_code = CCW_CMD_SET_IND_ADAPTER;\r\nccw->flags = CCW_FLAG_SLI;\r\nccw->count = sizeof(*thinint_area);\r\nccw->cda = (__u32)(unsigned long)thinint_area;\r\nret = ccw_io_helper(vcdev, ccw, VIRTIO_CCW_DOING_SET_IND_ADAPTER);\r\nif (ret) {\r\nif (ret == -EOPNOTSUPP) {\r\nvirtio_ccw_use_airq = 0;\r\npr_info("Adapter interrupts unsupported on host\n");\r\n} else\r\ndev_warn(&vcdev->cdev->dev,\r\n"enabling adapter interrupts = %d\n", ret);\r\nvirtio_ccw_drop_indicators(vcdev);\r\n}\r\nout:\r\nkfree(thinint_area);\r\nreturn ret;\r\n}\r\nstatic int virtio_ccw_find_vqs(struct virtio_device *vdev, unsigned nvqs,\r\nstruct virtqueue *vqs[],\r\nvq_callback_t *callbacks[],\r\nconst char * const names[],\r\nconst bool *ctx,\r\nstruct irq_affinity *desc)\r\n{\r\nstruct virtio_ccw_device *vcdev = to_vc_device(vdev);\r\nunsigned long *indicatorp = NULL;\r\nint ret, i;\r\nstruct ccw1 *ccw;\r\nccw = kzalloc(sizeof(*ccw), GFP_DMA | GFP_KERNEL);\r\nif (!ccw)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < nvqs; ++i) {\r\nvqs[i] = virtio_ccw_setup_vq(vdev, i, callbacks[i], names[i],\r\nctx ? ctx[i] : false, ccw);\r\nif (IS_ERR(vqs[i])) {\r\nret = PTR_ERR(vqs[i]);\r\nvqs[i] = NULL;\r\ngoto out;\r\n}\r\n}\r\nret = -ENOMEM;\r\nindicatorp = kmalloc(sizeof(&vcdev->indicators), GFP_DMA | GFP_KERNEL);\r\nif (!indicatorp)\r\ngoto out;\r\n*indicatorp = (unsigned long) &vcdev->indicators;\r\nif (vcdev->is_thinint) {\r\nret = virtio_ccw_register_adapter_ind(vcdev, vqs, nvqs, ccw);\r\nif (ret)\r\nvcdev->is_thinint = false;\r\n}\r\nif (!vcdev->is_thinint) {\r\nvcdev->indicators = 0;\r\nccw->cmd_code = CCW_CMD_SET_IND;\r\nccw->flags = 0;\r\nccw->count = sizeof(&vcdev->indicators);\r\nccw->cda = (__u32)(unsigned long) indicatorp;\r\nret = ccw_io_helper(vcdev, ccw, VIRTIO_CCW_DOING_SET_IND);\r\nif (ret)\r\ngoto out;\r\n}\r\n*indicatorp = (unsigned long) &vcdev->indicators2;\r\nvcdev->indicators2 = 0;\r\nccw->cmd_code = CCW_CMD_SET_CONF_IND;\r\nccw->flags = 0;\r\nccw->count = sizeof(&vcdev->indicators2);\r\nccw->cda = (__u32)(unsigned long) indicatorp;\r\nret = ccw_io_helper(vcdev, ccw, VIRTIO_CCW_DOING_SET_CONF_IND);\r\nif (ret)\r\ngoto out;\r\nkfree(indicatorp);\r\nkfree(ccw);\r\nreturn 0;\r\nout:\r\nkfree(indicatorp);\r\nkfree(ccw);\r\nvirtio_ccw_del_vqs(vdev);\r\nreturn ret;\r\n}\r\nstatic void virtio_ccw_reset(struct virtio_device *vdev)\r\n{\r\nstruct virtio_ccw_device *vcdev = to_vc_device(vdev);\r\nstruct ccw1 *ccw;\r\nccw = kzalloc(sizeof(*ccw), GFP_DMA | GFP_KERNEL);\r\nif (!ccw)\r\nreturn;\r\n*vcdev->status = 0;\r\nccw->cmd_code = CCW_CMD_VDEV_RESET;\r\nccw->flags = 0;\r\nccw->count = 0;\r\nccw->cda = 0;\r\nccw_io_helper(vcdev, ccw, VIRTIO_CCW_DOING_RESET);\r\nkfree(ccw);\r\n}\r\nstatic u64 virtio_ccw_get_features(struct virtio_device *vdev)\r\n{\r\nstruct virtio_ccw_device *vcdev = to_vc_device(vdev);\r\nstruct virtio_feature_desc *features;\r\nint ret;\r\nu64 rc;\r\nstruct ccw1 *ccw;\r\nccw = kzalloc(sizeof(*ccw), GFP_DMA | GFP_KERNEL);\r\nif (!ccw)\r\nreturn 0;\r\nfeatures = kzalloc(sizeof(*features), GFP_DMA | GFP_KERNEL);\r\nif (!features) {\r\nrc = 0;\r\ngoto out_free;\r\n}\r\nfeatures->index = 0;\r\nccw->cmd_code = CCW_CMD_READ_FEAT;\r\nccw->flags = 0;\r\nccw->count = sizeof(*features);\r\nccw->cda = (__u32)(unsigned long)features;\r\nret = ccw_io_helper(vcdev, ccw, VIRTIO_CCW_DOING_READ_FEAT);\r\nif (ret) {\r\nrc = 0;\r\ngoto out_free;\r\n}\r\nrc = le32_to_cpu(features->features);\r\nif (vcdev->revision == 0)\r\ngoto out_free;\r\nfeatures->index = 1;\r\nccw->cmd_code = CCW_CMD_READ_FEAT;\r\nccw->flags = 0;\r\nccw->count = sizeof(*features);\r\nccw->cda = (__u32)(unsigned long)features;\r\nret = ccw_io_helper(vcdev, ccw, VIRTIO_CCW_DOING_READ_FEAT);\r\nif (ret == 0)\r\nrc |= (u64)le32_to_cpu(features->features) << 32;\r\nout_free:\r\nkfree(features);\r\nkfree(ccw);\r\nreturn rc;\r\n}\r\nstatic int virtio_ccw_finalize_features(struct virtio_device *vdev)\r\n{\r\nstruct virtio_ccw_device *vcdev = to_vc_device(vdev);\r\nstruct virtio_feature_desc *features;\r\nstruct ccw1 *ccw;\r\nint ret;\r\nif (vcdev->revision >= 1 &&\r\n!__virtio_test_bit(vdev, VIRTIO_F_VERSION_1)) {\r\ndev_err(&vdev->dev, "virtio: device uses revision 1 "\r\n"but does not have VIRTIO_F_VERSION_1\n");\r\nreturn -EINVAL;\r\n}\r\nccw = kzalloc(sizeof(*ccw), GFP_DMA | GFP_KERNEL);\r\nif (!ccw)\r\nreturn -ENOMEM;\r\nfeatures = kzalloc(sizeof(*features), GFP_DMA | GFP_KERNEL);\r\nif (!features) {\r\nret = -ENOMEM;\r\ngoto out_free;\r\n}\r\nvring_transport_features(vdev);\r\nfeatures->index = 0;\r\nfeatures->features = cpu_to_le32((u32)vdev->features);\r\nccw->cmd_code = CCW_CMD_WRITE_FEAT;\r\nccw->flags = 0;\r\nccw->count = sizeof(*features);\r\nccw->cda = (__u32)(unsigned long)features;\r\nret = ccw_io_helper(vcdev, ccw, VIRTIO_CCW_DOING_WRITE_FEAT);\r\nif (ret)\r\ngoto out_free;\r\nif (vcdev->revision == 0)\r\ngoto out_free;\r\nfeatures->index = 1;\r\nfeatures->features = cpu_to_le32(vdev->features >> 32);\r\nccw->cmd_code = CCW_CMD_WRITE_FEAT;\r\nccw->flags = 0;\r\nccw->count = sizeof(*features);\r\nccw->cda = (__u32)(unsigned long)features;\r\nret = ccw_io_helper(vcdev, ccw, VIRTIO_CCW_DOING_WRITE_FEAT);\r\nout_free:\r\nkfree(features);\r\nkfree(ccw);\r\nreturn ret;\r\n}\r\nstatic void virtio_ccw_get_config(struct virtio_device *vdev,\r\nunsigned int offset, void *buf, unsigned len)\r\n{\r\nstruct virtio_ccw_device *vcdev = to_vc_device(vdev);\r\nint ret;\r\nstruct ccw1 *ccw;\r\nvoid *config_area;\r\nccw = kzalloc(sizeof(*ccw), GFP_DMA | GFP_KERNEL);\r\nif (!ccw)\r\nreturn;\r\nconfig_area = kzalloc(VIRTIO_CCW_CONFIG_SIZE, GFP_DMA | GFP_KERNEL);\r\nif (!config_area)\r\ngoto out_free;\r\nccw->cmd_code = CCW_CMD_READ_CONF;\r\nccw->flags = 0;\r\nccw->count = offset + len;\r\nccw->cda = (__u32)(unsigned long)config_area;\r\nret = ccw_io_helper(vcdev, ccw, VIRTIO_CCW_DOING_READ_CONFIG);\r\nif (ret)\r\ngoto out_free;\r\nmemcpy(vcdev->config, config_area, offset + len);\r\nif (buf)\r\nmemcpy(buf, &vcdev->config[offset], len);\r\nif (vcdev->config_ready < offset + len)\r\nvcdev->config_ready = offset + len;\r\nout_free:\r\nkfree(config_area);\r\nkfree(ccw);\r\n}\r\nstatic void virtio_ccw_set_config(struct virtio_device *vdev,\r\nunsigned int offset, const void *buf,\r\nunsigned len)\r\n{\r\nstruct virtio_ccw_device *vcdev = to_vc_device(vdev);\r\nstruct ccw1 *ccw;\r\nvoid *config_area;\r\nccw = kzalloc(sizeof(*ccw), GFP_DMA | GFP_KERNEL);\r\nif (!ccw)\r\nreturn;\r\nconfig_area = kzalloc(VIRTIO_CCW_CONFIG_SIZE, GFP_DMA | GFP_KERNEL);\r\nif (!config_area)\r\ngoto out_free;\r\nif (vcdev->config_ready < offset)\r\nvirtio_ccw_get_config(vdev, 0, NULL, offset);\r\nmemcpy(&vcdev->config[offset], buf, len);\r\nmemcpy(config_area, vcdev->config, sizeof(vcdev->config));\r\nccw->cmd_code = CCW_CMD_WRITE_CONF;\r\nccw->flags = 0;\r\nccw->count = offset + len;\r\nccw->cda = (__u32)(unsigned long)config_area;\r\nccw_io_helper(vcdev, ccw, VIRTIO_CCW_DOING_WRITE_CONFIG);\r\nout_free:\r\nkfree(config_area);\r\nkfree(ccw);\r\n}\r\nstatic u8 virtio_ccw_get_status(struct virtio_device *vdev)\r\n{\r\nstruct virtio_ccw_device *vcdev = to_vc_device(vdev);\r\nu8 old_status = *vcdev->status;\r\nstruct ccw1 *ccw;\r\nif (vcdev->revision < 1)\r\nreturn *vcdev->status;\r\nccw = kzalloc(sizeof(*ccw), GFP_DMA | GFP_KERNEL);\r\nif (!ccw)\r\nreturn old_status;\r\nccw->cmd_code = CCW_CMD_READ_STATUS;\r\nccw->flags = 0;\r\nccw->count = sizeof(*vcdev->status);\r\nccw->cda = (__u32)(unsigned long)vcdev->status;\r\nccw_io_helper(vcdev, ccw, VIRTIO_CCW_DOING_READ_STATUS);\r\nkfree(ccw);\r\nreturn *vcdev->status;\r\n}\r\nstatic void virtio_ccw_set_status(struct virtio_device *vdev, u8 status)\r\n{\r\nstruct virtio_ccw_device *vcdev = to_vc_device(vdev);\r\nu8 old_status = *vcdev->status;\r\nstruct ccw1 *ccw;\r\nint ret;\r\nccw = kzalloc(sizeof(*ccw), GFP_DMA | GFP_KERNEL);\r\nif (!ccw)\r\nreturn;\r\n*vcdev->status = status;\r\nccw->cmd_code = CCW_CMD_WRITE_STATUS;\r\nccw->flags = 0;\r\nccw->count = sizeof(status);\r\nccw->cda = (__u32)(unsigned long)vcdev->status;\r\nret = ccw_io_helper(vcdev, ccw, VIRTIO_CCW_DOING_WRITE_STATUS);\r\nif (ret)\r\n*vcdev->status = old_status;\r\nkfree(ccw);\r\n}\r\nstatic void virtio_ccw_release_dev(struct device *_d)\r\n{\r\nstruct virtio_device *dev = dev_to_virtio(_d);\r\nstruct virtio_ccw_device *vcdev = to_vc_device(dev);\r\nkfree(vcdev->status);\r\nkfree(vcdev->config_block);\r\nkfree(vcdev);\r\n}\r\nstatic int irb_is_error(struct irb *irb)\r\n{\r\nif (scsw_cstat(&irb->scsw) != 0)\r\nreturn 1;\r\nif (scsw_dstat(&irb->scsw) & ~(DEV_STAT_CHN_END | DEV_STAT_DEV_END))\r\nreturn 1;\r\nif (scsw_cc(&irb->scsw) != 0)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic struct virtqueue *virtio_ccw_vq_by_ind(struct virtio_ccw_device *vcdev,\r\nint index)\r\n{\r\nstruct virtio_ccw_vq_info *info;\r\nunsigned long flags;\r\nstruct virtqueue *vq;\r\nvq = NULL;\r\nspin_lock_irqsave(&vcdev->lock, flags);\r\nlist_for_each_entry(info, &vcdev->virtqueues, node) {\r\nif (info->vq->index == index) {\r\nvq = info->vq;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&vcdev->lock, flags);\r\nreturn vq;\r\n}\r\nstatic void virtio_ccw_check_activity(struct virtio_ccw_device *vcdev,\r\n__u32 activity)\r\n{\r\nif (vcdev->curr_io & activity) {\r\nswitch (activity) {\r\ncase VIRTIO_CCW_DOING_READ_FEAT:\r\ncase VIRTIO_CCW_DOING_WRITE_FEAT:\r\ncase VIRTIO_CCW_DOING_READ_CONFIG:\r\ncase VIRTIO_CCW_DOING_WRITE_CONFIG:\r\ncase VIRTIO_CCW_DOING_WRITE_STATUS:\r\ncase VIRTIO_CCW_DOING_READ_STATUS:\r\ncase VIRTIO_CCW_DOING_SET_VQ:\r\ncase VIRTIO_CCW_DOING_SET_IND:\r\ncase VIRTIO_CCW_DOING_SET_CONF_IND:\r\ncase VIRTIO_CCW_DOING_RESET:\r\ncase VIRTIO_CCW_DOING_READ_VQ_CONF:\r\ncase VIRTIO_CCW_DOING_SET_IND_ADAPTER:\r\ncase VIRTIO_CCW_DOING_SET_VIRTIO_REV:\r\nvcdev->curr_io &= ~activity;\r\nwake_up(&vcdev->wait_q);\r\nbreak;\r\ndefault:\r\ndev_warn(&vcdev->cdev->dev,\r\n"Suspicious activity '%08x'\n", activity);\r\nWARN_ON(1);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void virtio_ccw_int_handler(struct ccw_device *cdev,\r\nunsigned long intparm,\r\nstruct irb *irb)\r\n{\r\n__u32 activity = intparm & VIRTIO_CCW_INTPARM_MASK;\r\nstruct virtio_ccw_device *vcdev = dev_get_drvdata(&cdev->dev);\r\nint i;\r\nstruct virtqueue *vq;\r\nif (!vcdev)\r\nreturn;\r\nif (IS_ERR(irb)) {\r\nvcdev->err = PTR_ERR(irb);\r\nvirtio_ccw_check_activity(vcdev, activity);\r\nreturn;\r\n}\r\nif ((intparm == 0) &&\r\n(scsw_stctl(&irb->scsw) ==\r\n(SCSW_STCTL_ALERT_STATUS | SCSW_STCTL_STATUS_PEND))) {\r\n}\r\nif (irb_is_error(irb)) {\r\nif ((scsw_dstat(&irb->scsw) & DEV_STAT_UNIT_CHECK) &&\r\n(irb->ecw[0] & SNS0_CMD_REJECT))\r\nvcdev->err = -EOPNOTSUPP;\r\nelse\r\nvcdev->err = -EIO;\r\n}\r\nvirtio_ccw_check_activity(vcdev, activity);\r\nfor_each_set_bit(i, &vcdev->indicators,\r\nsizeof(vcdev->indicators) * BITS_PER_BYTE) {\r\nclear_bit(i, &vcdev->indicators);\r\nbarrier();\r\nvq = virtio_ccw_vq_by_ind(vcdev, i);\r\nvring_interrupt(0, vq);\r\n}\r\nif (test_bit(0, &vcdev->indicators2)) {\r\nvirtio_config_changed(&vcdev->vdev);\r\nclear_bit(0, &vcdev->indicators2);\r\n}\r\n}\r\nstatic int virtio_ccw_check_autoonline(struct ccw_device *cdev)\r\n{\r\nstruct ccw_dev_id id;\r\nccw_device_get_id(cdev, &id);\r\nif (test_bit(id.devno, devs_no_auto[id.ssid]))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void virtio_ccw_auto_online(void *data, async_cookie_t cookie)\r\n{\r\nstruct ccw_device *cdev = data;\r\nint ret;\r\nret = ccw_device_set_online(cdev);\r\nif (ret)\r\ndev_warn(&cdev->dev, "Failed to set online: %d\n", ret);\r\n}\r\nstatic int virtio_ccw_probe(struct ccw_device *cdev)\r\n{\r\ncdev->handler = virtio_ccw_int_handler;\r\nif (virtio_ccw_check_autoonline(cdev))\r\nasync_schedule(virtio_ccw_auto_online, cdev);\r\nreturn 0;\r\n}\r\nstatic struct virtio_ccw_device *virtio_grab_drvdata(struct ccw_device *cdev)\r\n{\r\nunsigned long flags;\r\nstruct virtio_ccw_device *vcdev;\r\nspin_lock_irqsave(get_ccwdev_lock(cdev), flags);\r\nvcdev = dev_get_drvdata(&cdev->dev);\r\nif (!vcdev || vcdev->going_away) {\r\nspin_unlock_irqrestore(get_ccwdev_lock(cdev), flags);\r\nreturn NULL;\r\n}\r\nvcdev->going_away = true;\r\nspin_unlock_irqrestore(get_ccwdev_lock(cdev), flags);\r\nreturn vcdev;\r\n}\r\nstatic void virtio_ccw_remove(struct ccw_device *cdev)\r\n{\r\nunsigned long flags;\r\nstruct virtio_ccw_device *vcdev = virtio_grab_drvdata(cdev);\r\nif (vcdev && cdev->online) {\r\nif (vcdev->device_lost)\r\nvirtio_break_device(&vcdev->vdev);\r\nunregister_virtio_device(&vcdev->vdev);\r\nspin_lock_irqsave(get_ccwdev_lock(cdev), flags);\r\ndev_set_drvdata(&cdev->dev, NULL);\r\nspin_unlock_irqrestore(get_ccwdev_lock(cdev), flags);\r\n}\r\ncdev->handler = NULL;\r\n}\r\nstatic int virtio_ccw_offline(struct ccw_device *cdev)\r\n{\r\nunsigned long flags;\r\nstruct virtio_ccw_device *vcdev = virtio_grab_drvdata(cdev);\r\nif (!vcdev)\r\nreturn 0;\r\nif (vcdev->device_lost)\r\nvirtio_break_device(&vcdev->vdev);\r\nunregister_virtio_device(&vcdev->vdev);\r\nspin_lock_irqsave(get_ccwdev_lock(cdev), flags);\r\ndev_set_drvdata(&cdev->dev, NULL);\r\nspin_unlock_irqrestore(get_ccwdev_lock(cdev), flags);\r\nreturn 0;\r\n}\r\nstatic int virtio_ccw_set_transport_rev(struct virtio_ccw_device *vcdev)\r\n{\r\nstruct virtio_rev_info *rev;\r\nstruct ccw1 *ccw;\r\nint ret;\r\nccw = kzalloc(sizeof(*ccw), GFP_DMA | GFP_KERNEL);\r\nif (!ccw)\r\nreturn -ENOMEM;\r\nrev = kzalloc(sizeof(*rev), GFP_DMA | GFP_KERNEL);\r\nif (!rev) {\r\nkfree(ccw);\r\nreturn -ENOMEM;\r\n}\r\nccw->cmd_code = CCW_CMD_SET_VIRTIO_REV;\r\nccw->flags = 0;\r\nccw->count = sizeof(*rev);\r\nccw->cda = (__u32)(unsigned long)rev;\r\nvcdev->revision = VIRTIO_CCW_REV_MAX;\r\ndo {\r\nrev->revision = vcdev->revision;\r\nrev->length = 0;\r\nret = ccw_io_helper(vcdev, ccw,\r\nVIRTIO_CCW_DOING_SET_VIRTIO_REV);\r\nif (ret == -EOPNOTSUPP) {\r\nif (vcdev->revision == 0)\r\nret = 0;\r\nelse\r\nvcdev->revision--;\r\n}\r\n} while (ret == -EOPNOTSUPP);\r\nkfree(ccw);\r\nkfree(rev);\r\nreturn ret;\r\n}\r\nstatic int virtio_ccw_online(struct ccw_device *cdev)\r\n{\r\nint ret;\r\nstruct virtio_ccw_device *vcdev;\r\nunsigned long flags;\r\nvcdev = kzalloc(sizeof(*vcdev), GFP_KERNEL);\r\nif (!vcdev) {\r\ndev_warn(&cdev->dev, "Could not get memory for virtio\n");\r\nret = -ENOMEM;\r\ngoto out_free;\r\n}\r\nvcdev->config_block = kzalloc(sizeof(*vcdev->config_block),\r\nGFP_DMA | GFP_KERNEL);\r\nif (!vcdev->config_block) {\r\nret = -ENOMEM;\r\ngoto out_free;\r\n}\r\nvcdev->status = kzalloc(sizeof(*vcdev->status), GFP_DMA | GFP_KERNEL);\r\nif (!vcdev->status) {\r\nret = -ENOMEM;\r\ngoto out_free;\r\n}\r\nvcdev->is_thinint = virtio_ccw_use_airq;\r\nvcdev->vdev.dev.parent = &cdev->dev;\r\nvcdev->vdev.dev.release = virtio_ccw_release_dev;\r\nvcdev->vdev.config = &virtio_ccw_config_ops;\r\nvcdev->cdev = cdev;\r\ninit_waitqueue_head(&vcdev->wait_q);\r\nINIT_LIST_HEAD(&vcdev->virtqueues);\r\nspin_lock_init(&vcdev->lock);\r\nspin_lock_irqsave(get_ccwdev_lock(cdev), flags);\r\ndev_set_drvdata(&cdev->dev, vcdev);\r\nspin_unlock_irqrestore(get_ccwdev_lock(cdev), flags);\r\nvcdev->vdev.id.vendor = cdev->id.cu_type;\r\nvcdev->vdev.id.device = cdev->id.cu_model;\r\nret = virtio_ccw_set_transport_rev(vcdev);\r\nif (ret)\r\ngoto out_free;\r\nret = register_virtio_device(&vcdev->vdev);\r\nif (ret) {\r\ndev_warn(&cdev->dev, "Failed to register virtio device: %d\n",\r\nret);\r\ngoto out_put;\r\n}\r\nreturn 0;\r\nout_put:\r\nspin_lock_irqsave(get_ccwdev_lock(cdev), flags);\r\ndev_set_drvdata(&cdev->dev, NULL);\r\nspin_unlock_irqrestore(get_ccwdev_lock(cdev), flags);\r\nput_device(&vcdev->vdev.dev);\r\nreturn ret;\r\nout_free:\r\nif (vcdev) {\r\nkfree(vcdev->status);\r\nkfree(vcdev->config_block);\r\n}\r\nkfree(vcdev);\r\nreturn ret;\r\n}\r\nstatic int virtio_ccw_cio_notify(struct ccw_device *cdev, int event)\r\n{\r\nint rc;\r\nstruct virtio_ccw_device *vcdev = dev_get_drvdata(&cdev->dev);\r\nif (!vcdev)\r\nreturn NOTIFY_DONE;\r\nswitch (event) {\r\ncase CIO_GONE:\r\nvcdev->device_lost = true;\r\nrc = NOTIFY_DONE;\r\nbreak;\r\ndefault:\r\nrc = NOTIFY_DONE;\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic int __init pure_hex(char **cp, unsigned int *val, int min_digit,\r\nint max_digit, int max_val)\r\n{\r\nint diff;\r\ndiff = 0;\r\n*val = 0;\r\nwhile (diff <= max_digit) {\r\nint value = hex_to_bin(**cp);\r\nif (value < 0)\r\nbreak;\r\n*val = *val * 16 + value;\r\n(*cp)++;\r\ndiff++;\r\n}\r\nif ((diff < min_digit) || (diff > max_digit) || (*val > max_val))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int __init parse_busid(char *str, unsigned int *cssid,\r\nunsigned int *ssid, unsigned int *devno)\r\n{\r\nchar *str_work;\r\nint rc, ret;\r\nrc = 1;\r\nif (*str == '\0')\r\ngoto out;\r\nstr_work = str;\r\nret = pure_hex(&str_work, cssid, 1, 2, __MAX_CSSID);\r\nif (ret || (str_work[0] != '.'))\r\ngoto out;\r\nstr_work++;\r\nret = pure_hex(&str_work, ssid, 1, 1, __MAX_SSID);\r\nif (ret || (str_work[0] != '.'))\r\ngoto out;\r\nstr_work++;\r\nret = pure_hex(&str_work, devno, 4, 4, __MAX_SUBCHANNEL);\r\nif (ret || (str_work[0] != '\0'))\r\ngoto out;\r\nrc = 0;\r\nout:\r\nreturn rc;\r\n}\r\nstatic void __init no_auto_parse(void)\r\n{\r\nunsigned int from_cssid, to_cssid, from_ssid, to_ssid, from, to;\r\nchar *parm, *str;\r\nint rc;\r\nstr = no_auto;\r\nwhile ((parm = strsep(&str, ","))) {\r\nrc = parse_busid(strsep(&parm, "-"), &from_cssid,\r\n&from_ssid, &from);\r\nif (rc)\r\ncontinue;\r\nif (parm != NULL) {\r\nrc = parse_busid(parm, &to_cssid,\r\n&to_ssid, &to);\r\nif ((from_ssid > to_ssid) ||\r\n((from_ssid == to_ssid) && (from > to)))\r\nrc = -EINVAL;\r\n} else {\r\nto_cssid = from_cssid;\r\nto_ssid = from_ssid;\r\nto = from;\r\n}\r\nif (rc)\r\ncontinue;\r\nwhile ((from_ssid < to_ssid) ||\r\n((from_ssid == to_ssid) && (from <= to))) {\r\nset_bit(from, devs_no_auto[from_ssid]);\r\nfrom++;\r\nif (from > __MAX_SUBCHANNEL) {\r\nfrom_ssid++;\r\nfrom = 0;\r\n}\r\n}\r\n}\r\n}\r\nstatic int __init virtio_ccw_init(void)\r\n{\r\nno_auto_parse();\r\nreturn ccw_driver_register(&virtio_ccw_driver);\r\n}
