static inline void bcm2835_i2c_writel(struct bcm2835_i2c_dev *i2c_dev,\r\nu32 reg, u32 val)\r\n{\r\nwritel(val, i2c_dev->regs + reg);\r\n}\r\nstatic inline u32 bcm2835_i2c_readl(struct bcm2835_i2c_dev *i2c_dev, u32 reg)\r\n{\r\nreturn readl(i2c_dev->regs + reg);\r\n}\r\nstatic int bcm2835_i2c_set_divider(struct bcm2835_i2c_dev *i2c_dev)\r\n{\r\nu32 divider;\r\ndivider = DIV_ROUND_UP(clk_get_rate(i2c_dev->clk),\r\ni2c_dev->bus_clk_rate);\r\nif (divider & 1)\r\ndivider++;\r\nif ((divider < BCM2835_I2C_CDIV_MIN) ||\r\n(divider > BCM2835_I2C_CDIV_MAX)) {\r\ndev_err_ratelimited(i2c_dev->dev, "Invalid clock-frequency\n");\r\nreturn -EINVAL;\r\n}\r\nbcm2835_i2c_writel(i2c_dev, BCM2835_I2C_DIV, divider);\r\nreturn 0;\r\n}\r\nstatic void bcm2835_fill_txfifo(struct bcm2835_i2c_dev *i2c_dev)\r\n{\r\nu32 val;\r\nwhile (i2c_dev->msg_buf_remaining) {\r\nval = bcm2835_i2c_readl(i2c_dev, BCM2835_I2C_S);\r\nif (!(val & BCM2835_I2C_S_TXD))\r\nbreak;\r\nbcm2835_i2c_writel(i2c_dev, BCM2835_I2C_FIFO,\r\n*i2c_dev->msg_buf);\r\ni2c_dev->msg_buf++;\r\ni2c_dev->msg_buf_remaining--;\r\n}\r\n}\r\nstatic void bcm2835_drain_rxfifo(struct bcm2835_i2c_dev *i2c_dev)\r\n{\r\nu32 val;\r\nwhile (i2c_dev->msg_buf_remaining) {\r\nval = bcm2835_i2c_readl(i2c_dev, BCM2835_I2C_S);\r\nif (!(val & BCM2835_I2C_S_RXD))\r\nbreak;\r\n*i2c_dev->msg_buf = bcm2835_i2c_readl(i2c_dev,\r\nBCM2835_I2C_FIFO);\r\ni2c_dev->msg_buf++;\r\ni2c_dev->msg_buf_remaining--;\r\n}\r\n}\r\nstatic void bcm2835_i2c_start_transfer(struct bcm2835_i2c_dev *i2c_dev)\r\n{\r\nu32 c = BCM2835_I2C_C_ST | BCM2835_I2C_C_I2CEN;\r\nstruct i2c_msg *msg = i2c_dev->curr_msg;\r\nbool last_msg = (i2c_dev->num_msgs == 1);\r\nif (!i2c_dev->num_msgs)\r\nreturn;\r\ni2c_dev->num_msgs--;\r\ni2c_dev->msg_buf = msg->buf;\r\ni2c_dev->msg_buf_remaining = msg->len;\r\nif (msg->flags & I2C_M_RD)\r\nc |= BCM2835_I2C_C_READ | BCM2835_I2C_C_INTR;\r\nelse\r\nc |= BCM2835_I2C_C_INTT;\r\nif (last_msg)\r\nc |= BCM2835_I2C_C_INTD;\r\nbcm2835_i2c_writel(i2c_dev, BCM2835_I2C_A, msg->addr);\r\nbcm2835_i2c_writel(i2c_dev, BCM2835_I2C_DLEN, msg->len);\r\nbcm2835_i2c_writel(i2c_dev, BCM2835_I2C_C, c);\r\n}\r\nstatic irqreturn_t bcm2835_i2c_isr(int this_irq, void *data)\r\n{\r\nstruct bcm2835_i2c_dev *i2c_dev = data;\r\nu32 val, err;\r\nval = bcm2835_i2c_readl(i2c_dev, BCM2835_I2C_S);\r\nerr = val & (BCM2835_I2C_S_CLKT | BCM2835_I2C_S_ERR);\r\nif (err) {\r\ni2c_dev->msg_err = err;\r\ngoto complete;\r\n}\r\nif (val & BCM2835_I2C_S_DONE) {\r\nif (!i2c_dev->curr_msg) {\r\ndev_err(i2c_dev->dev, "Got unexpected interrupt (from firmware?)\n");\r\n} else if (i2c_dev->curr_msg->flags & I2C_M_RD) {\r\nbcm2835_drain_rxfifo(i2c_dev);\r\nval = bcm2835_i2c_readl(i2c_dev, BCM2835_I2C_S);\r\n}\r\nif ((val & BCM2835_I2C_S_RXD) || i2c_dev->msg_buf_remaining)\r\ni2c_dev->msg_err = BCM2835_I2C_S_LEN;\r\nelse\r\ni2c_dev->msg_err = 0;\r\ngoto complete;\r\n}\r\nif (val & BCM2835_I2C_S_TXW) {\r\nif (!i2c_dev->msg_buf_remaining) {\r\ni2c_dev->msg_err = val | BCM2835_I2C_S_LEN;\r\ngoto complete;\r\n}\r\nbcm2835_fill_txfifo(i2c_dev);\r\nif (i2c_dev->num_msgs && !i2c_dev->msg_buf_remaining) {\r\ni2c_dev->curr_msg++;\r\nbcm2835_i2c_start_transfer(i2c_dev);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nif (val & BCM2835_I2C_S_RXR) {\r\nif (!i2c_dev->msg_buf_remaining) {\r\ni2c_dev->msg_err = val | BCM2835_I2C_S_LEN;\r\ngoto complete;\r\n}\r\nbcm2835_drain_rxfifo(i2c_dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\ncomplete:\r\nbcm2835_i2c_writel(i2c_dev, BCM2835_I2C_C, BCM2835_I2C_C_CLEAR);\r\nbcm2835_i2c_writel(i2c_dev, BCM2835_I2C_S, BCM2835_I2C_S_CLKT |\r\nBCM2835_I2C_S_ERR | BCM2835_I2C_S_DONE);\r\ncomplete(&i2c_dev->completion);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int bcm2835_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[],\r\nint num)\r\n{\r\nstruct bcm2835_i2c_dev *i2c_dev = i2c_get_adapdata(adap);\r\nunsigned long time_left;\r\nint i, ret;\r\nfor (i = 0; i < (num - 1); i++)\r\nif (msgs[i].flags & I2C_M_RD) {\r\ndev_warn_once(i2c_dev->dev,\r\n"only one read message supported, has to be last\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nret = bcm2835_i2c_set_divider(i2c_dev);\r\nif (ret)\r\nreturn ret;\r\ni2c_dev->curr_msg = msgs;\r\ni2c_dev->num_msgs = num;\r\nreinit_completion(&i2c_dev->completion);\r\nbcm2835_i2c_start_transfer(i2c_dev);\r\ntime_left = wait_for_completion_timeout(&i2c_dev->completion,\r\nadap->timeout);\r\nif (!time_left) {\r\nbcm2835_i2c_writel(i2c_dev, BCM2835_I2C_C,\r\nBCM2835_I2C_C_CLEAR);\r\ndev_err(i2c_dev->dev, "i2c transfer timed out\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nif (!i2c_dev->msg_err)\r\nreturn num;\r\ndev_dbg(i2c_dev->dev, "i2c transfer failed: %x\n", i2c_dev->msg_err);\r\nif (i2c_dev->msg_err & BCM2835_I2C_S_ERR)\r\nreturn -EREMOTEIO;\r\nreturn -EIO;\r\n}\r\nstatic u32 bcm2835_i2c_func(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\r\n}\r\nstatic int bcm2835_i2c_probe(struct platform_device *pdev)\r\n{\r\nstruct bcm2835_i2c_dev *i2c_dev;\r\nstruct resource *mem, *irq;\r\nint ret;\r\nstruct i2c_adapter *adap;\r\ni2c_dev = devm_kzalloc(&pdev->dev, sizeof(*i2c_dev), GFP_KERNEL);\r\nif (!i2c_dev)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, i2c_dev);\r\ni2c_dev->dev = &pdev->dev;\r\ninit_completion(&i2c_dev->completion);\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ni2c_dev->regs = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(i2c_dev->regs))\r\nreturn PTR_ERR(i2c_dev->regs);\r\ni2c_dev->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(i2c_dev->clk)) {\r\nif (PTR_ERR(i2c_dev->clk) != -EPROBE_DEFER)\r\ndev_err(&pdev->dev, "Could not get clock\n");\r\nreturn PTR_ERR(i2c_dev->clk);\r\n}\r\nret = of_property_read_u32(pdev->dev.of_node, "clock-frequency",\r\n&i2c_dev->bus_clk_rate);\r\nif (ret < 0) {\r\ndev_warn(&pdev->dev,\r\n"Could not read clock-frequency property\n");\r\ni2c_dev->bus_clk_rate = 100000;\r\n}\r\nirq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!irq) {\r\ndev_err(&pdev->dev, "No IRQ resource\n");\r\nreturn -ENODEV;\r\n}\r\ni2c_dev->irq = irq->start;\r\nret = request_irq(i2c_dev->irq, bcm2835_i2c_isr, IRQF_SHARED,\r\ndev_name(&pdev->dev), i2c_dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Could not request IRQ\n");\r\nreturn -ENODEV;\r\n}\r\nadap = &i2c_dev->adapter;\r\ni2c_set_adapdata(adap, i2c_dev);\r\nadap->owner = THIS_MODULE;\r\nadap->class = I2C_CLASS_DEPRECATED;\r\nstrlcpy(adap->name, "bcm2835 I2C adapter", sizeof(adap->name));\r\nadap->algo = &bcm2835_i2c_algo;\r\nadap->dev.parent = &pdev->dev;\r\nadap->dev.of_node = pdev->dev.of_node;\r\nadap->quirks = &bcm2835_i2c_quirks;\r\nbcm2835_i2c_writel(i2c_dev, BCM2835_I2C_C, 0);\r\nret = i2c_add_adapter(adap);\r\nif (ret)\r\nfree_irq(i2c_dev->irq, i2c_dev);\r\nreturn ret;\r\n}\r\nstatic int bcm2835_i2c_remove(struct platform_device *pdev)\r\n{\r\nstruct bcm2835_i2c_dev *i2c_dev = platform_get_drvdata(pdev);\r\nfree_irq(i2c_dev->irq, i2c_dev);\r\ni2c_del_adapter(&i2c_dev->adapter);\r\nreturn 0;\r\n}
