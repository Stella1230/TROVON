void spu_invalidate_slbs(struct spu *spu)\r\n{\r\nstruct spu_priv2 __iomem *priv2 = spu->priv2;\r\nunsigned long flags;\r\nspin_lock_irqsave(&spu->register_lock, flags);\r\nif (spu_mfc_sr1_get(spu) & MFC_STATE1_RELOCATE_MASK)\r\nout_be64(&priv2->slb_invalidate_all_W, 0UL);\r\nspin_unlock_irqrestore(&spu->register_lock, flags);\r\n}\r\nvoid spu_flush_all_slbs(struct mm_struct *mm)\r\n{\r\nstruct spu *spu;\r\nunsigned long flags;\r\nspin_lock_irqsave(&spu_full_list_lock, flags);\r\nlist_for_each_entry(spu, &spu_full_list, full_list) {\r\nif (spu->mm == mm)\r\nspu_invalidate_slbs(spu);\r\n}\r\nspin_unlock_irqrestore(&spu_full_list_lock, flags);\r\n}\r\nstatic inline void mm_needs_global_tlbie(struct mm_struct *mm)\r\n{\r\nint nr = (NR_CPUS > 1) ? NR_CPUS : NR_CPUS + 1;\r\nbitmap_fill(cpumask_bits(mm_cpumask(mm)), nr);\r\n}\r\nvoid spu_associate_mm(struct spu *spu, struct mm_struct *mm)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&spu_full_list_lock, flags);\r\nspu->mm = mm;\r\nspin_unlock_irqrestore(&spu_full_list_lock, flags);\r\nif (mm)\r\nmm_needs_global_tlbie(mm);\r\n}\r\nint spu_64k_pages_available(void)\r\n{\r\nreturn mmu_psize_defs[MMU_PAGE_64K].shift != 0;\r\n}\r\nstatic void spu_restart_dma(struct spu *spu)\r\n{\r\nstruct spu_priv2 __iomem *priv2 = spu->priv2;\r\nif (!test_bit(SPU_CONTEXT_SWITCH_PENDING, &spu->flags))\r\nout_be64(&priv2->mfc_control_RW, MFC_CNTL_RESTART_DMA_COMMAND);\r\nelse {\r\nset_bit(SPU_CONTEXT_FAULT_PENDING, &spu->flags);\r\nmb();\r\n}\r\n}\r\nstatic inline void spu_load_slb(struct spu *spu, int slbe, struct copro_slb *slb)\r\n{\r\nstruct spu_priv2 __iomem *priv2 = spu->priv2;\r\npr_debug("%s: adding SLB[%d] 0x%016llx 0x%016llx\n",\r\n__func__, slbe, slb->vsid, slb->esid);\r\nout_be64(&priv2->slb_index_W, slbe);\r\nout_be64(&priv2->slb_esid_RW, 0);\r\nout_be64(&priv2->slb_vsid_RW, slb->vsid);\r\nout_be64(&priv2->slb_esid_RW, slb->esid);\r\n}\r\nstatic int __spu_trap_data_seg(struct spu *spu, unsigned long ea)\r\n{\r\nstruct copro_slb slb;\r\nint ret;\r\nret = copro_calculate_slb(spu->mm, ea, &slb);\r\nif (ret)\r\nreturn ret;\r\nspu_load_slb(spu, spu->slb_replace, &slb);\r\nspu->slb_replace++;\r\nif (spu->slb_replace >= 8)\r\nspu->slb_replace = 0;\r\nspu_restart_dma(spu);\r\nspu->stats.slb_flt++;\r\nreturn 0;\r\n}\r\nstatic int __spu_trap_data_map(struct spu *spu, unsigned long ea, u64 dsisr)\r\n{\r\nint ret;\r\npr_debug("%s, %llx, %lx\n", __func__, dsisr, ea);\r\nif ((dsisr & MFC_DSISR_PTE_NOT_FOUND) &&\r\n(REGION_ID(ea) != USER_REGION_ID)) {\r\nspin_unlock(&spu->register_lock);\r\nret = hash_page(ea,\r\n_PAGE_PRESENT | _PAGE_READ | _PAGE_PRIVILEGED,\r\n0x300, dsisr);\r\nspin_lock(&spu->register_lock);\r\nif (!ret) {\r\nspu_restart_dma(spu);\r\nreturn 0;\r\n}\r\n}\r\nspu->class_1_dar = ea;\r\nspu->class_1_dsisr = dsisr;\r\nspu->stop_callback(spu, 1);\r\nspu->class_1_dar = 0;\r\nspu->class_1_dsisr = 0;\r\nreturn 0;\r\n}\r\nstatic void __spu_kernel_slb(void *addr, struct copro_slb *slb)\r\n{\r\nunsigned long ea = (unsigned long)addr;\r\nu64 llp;\r\nif (REGION_ID(ea) == KERNEL_REGION_ID)\r\nllp = mmu_psize_defs[mmu_linear_psize].sllp;\r\nelse\r\nllp = mmu_psize_defs[mmu_virtual_psize].sllp;\r\nslb->vsid = (get_kernel_vsid(ea, MMU_SEGSIZE_256M) << SLB_VSID_SHIFT) |\r\nSLB_VSID_KERNEL | llp;\r\nslb->esid = (ea & ESID_MASK) | SLB_ESID_V;\r\n}\r\nstatic inline int __slb_present(struct copro_slb *slbs, int nr_slbs,\r\nvoid *new_addr)\r\n{\r\nunsigned long ea = (unsigned long)new_addr;\r\nint i;\r\nfor (i = 0; i < nr_slbs; i++)\r\nif (!((slbs[i].esid ^ ea) & ESID_MASK))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nvoid spu_setup_kernel_slbs(struct spu *spu, struct spu_lscsa *lscsa,\r\nvoid *code, int code_size)\r\n{\r\nstruct copro_slb slbs[4];\r\nint i, nr_slbs = 0;\r\nvoid *addrs[] = {\r\nlscsa, (void *)lscsa + sizeof(*lscsa) - 1,\r\ncode, code + code_size - 1\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(addrs); i++) {\r\nif (__slb_present(slbs, nr_slbs, addrs[i]))\r\ncontinue;\r\n__spu_kernel_slb(addrs[i], &slbs[nr_slbs]);\r\nnr_slbs++;\r\n}\r\nspin_lock_irq(&spu->register_lock);\r\nfor (i = 0; i < nr_slbs; i++)\r\nspu_load_slb(spu, i, &slbs[i]);\r\nspin_unlock_irq(&spu->register_lock);\r\n}\r\nstatic irqreturn_t\r\nspu_irq_class_0(int irq, void *data)\r\n{\r\nstruct spu *spu;\r\nunsigned long stat, mask;\r\nspu = data;\r\nspin_lock(&spu->register_lock);\r\nmask = spu_int_mask_get(spu, 0);\r\nstat = spu_int_stat_get(spu, 0) & mask;\r\nspu->class_0_pending |= stat;\r\nspu->class_0_dar = spu_mfc_dar_get(spu);\r\nspu->stop_callback(spu, 0);\r\nspu->class_0_pending = 0;\r\nspu->class_0_dar = 0;\r\nspu_int_stat_clear(spu, 0, stat);\r\nspin_unlock(&spu->register_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t\r\nspu_irq_class_1(int irq, void *data)\r\n{\r\nstruct spu *spu;\r\nunsigned long stat, mask, dar, dsisr;\r\nspu = data;\r\nspin_lock(&spu->register_lock);\r\nmask = spu_int_mask_get(spu, 1);\r\nstat = spu_int_stat_get(spu, 1) & mask;\r\ndar = spu_mfc_dar_get(spu);\r\ndsisr = spu_mfc_dsisr_get(spu);\r\nif (stat & CLASS1_STORAGE_FAULT_INTR)\r\nspu_mfc_dsisr_set(spu, 0ul);\r\nspu_int_stat_clear(spu, 1, stat);\r\npr_debug("%s: %lx %lx %lx %lx\n", __func__, mask, stat,\r\ndar, dsisr);\r\nif (stat & CLASS1_SEGMENT_FAULT_INTR)\r\n__spu_trap_data_seg(spu, dar);\r\nif (stat & CLASS1_STORAGE_FAULT_INTR)\r\n__spu_trap_data_map(spu, dar, dsisr);\r\nif (stat & CLASS1_LS_COMPARE_SUSPEND_ON_GET_INTR)\r\n;\r\nif (stat & CLASS1_LS_COMPARE_SUSPEND_ON_PUT_INTR)\r\n;\r\nspu->class_1_dsisr = 0;\r\nspu->class_1_dar = 0;\r\nspin_unlock(&spu->register_lock);\r\nreturn stat ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic irqreturn_t\r\nspu_irq_class_2(int irq, void *data)\r\n{\r\nstruct spu *spu;\r\nunsigned long stat;\r\nunsigned long mask;\r\nconst int mailbox_intrs =\r\nCLASS2_MAILBOX_THRESHOLD_INTR | CLASS2_MAILBOX_INTR;\r\nspu = data;\r\nspin_lock(&spu->register_lock);\r\nstat = spu_int_stat_get(spu, 2);\r\nmask = spu_int_mask_get(spu, 2);\r\nstat &= mask;\r\nif (stat & mailbox_intrs)\r\nspu_int_mask_and(spu, 2, ~(stat & mailbox_intrs));\r\nspu_int_stat_clear(spu, 2, stat);\r\npr_debug("class 2 interrupt %d, %lx, %lx\n", irq, stat, mask);\r\nif (stat & CLASS2_MAILBOX_INTR)\r\nspu->ibox_callback(spu);\r\nif (stat & CLASS2_SPU_STOP_INTR)\r\nspu->stop_callback(spu, 2);\r\nif (stat & CLASS2_SPU_HALT_INTR)\r\nspu->stop_callback(spu, 2);\r\nif (stat & CLASS2_SPU_DMA_TAG_GROUP_COMPLETE_INTR)\r\nspu->mfc_callback(spu);\r\nif (stat & CLASS2_MAILBOX_THRESHOLD_INTR)\r\nspu->wbox_callback(spu);\r\nspu->stats.class2_intr++;\r\nspin_unlock(&spu->register_lock);\r\nreturn stat ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic int spu_request_irqs(struct spu *spu)\r\n{\r\nint ret = 0;\r\nif (spu->irqs[0]) {\r\nsnprintf(spu->irq_c0, sizeof (spu->irq_c0), "spe%02d.0",\r\nspu->number);\r\nret = request_irq(spu->irqs[0], spu_irq_class_0,\r\n0, spu->irq_c0, spu);\r\nif (ret)\r\ngoto bail0;\r\n}\r\nif (spu->irqs[1]) {\r\nsnprintf(spu->irq_c1, sizeof (spu->irq_c1), "spe%02d.1",\r\nspu->number);\r\nret = request_irq(spu->irqs[1], spu_irq_class_1,\r\n0, spu->irq_c1, spu);\r\nif (ret)\r\ngoto bail1;\r\n}\r\nif (spu->irqs[2]) {\r\nsnprintf(spu->irq_c2, sizeof (spu->irq_c2), "spe%02d.2",\r\nspu->number);\r\nret = request_irq(spu->irqs[2], spu_irq_class_2,\r\n0, spu->irq_c2, spu);\r\nif (ret)\r\ngoto bail2;\r\n}\r\nreturn 0;\r\nbail2:\r\nif (spu->irqs[1])\r\nfree_irq(spu->irqs[1], spu);\r\nbail1:\r\nif (spu->irqs[0])\r\nfree_irq(spu->irqs[0], spu);\r\nbail0:\r\nreturn ret;\r\n}\r\nstatic void spu_free_irqs(struct spu *spu)\r\n{\r\nif (spu->irqs[0])\r\nfree_irq(spu->irqs[0], spu);\r\nif (spu->irqs[1])\r\nfree_irq(spu->irqs[1], spu);\r\nif (spu->irqs[2])\r\nfree_irq(spu->irqs[2], spu);\r\n}\r\nvoid spu_init_channels(struct spu *spu)\r\n{\r\nstatic const struct {\r\nunsigned channel;\r\nunsigned count;\r\n} zero_list[] = {\r\n{ 0x00, 1, }, { 0x01, 1, }, { 0x03, 1, }, { 0x04, 1, },\r\n{ 0x18, 1, }, { 0x19, 1, }, { 0x1b, 1, }, { 0x1d, 1, },\r\n}, count_list[] = {\r\n{ 0x00, 0, }, { 0x03, 0, }, { 0x04, 0, }, { 0x15, 16, },\r\n{ 0x17, 1, }, { 0x18, 0, }, { 0x19, 0, }, { 0x1b, 0, },\r\n{ 0x1c, 1, }, { 0x1d, 0, }, { 0x1e, 1, },\r\n};\r\nstruct spu_priv2 __iomem *priv2;\r\nint i;\r\npriv2 = spu->priv2;\r\nfor (i = 0; i < ARRAY_SIZE(zero_list); i++) {\r\nint count;\r\nout_be64(&priv2->spu_chnlcntptr_RW, zero_list[i].channel);\r\nfor (count = 0; count < zero_list[i].count; count++)\r\nout_be64(&priv2->spu_chnldata_RW, 0);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(count_list); i++) {\r\nout_be64(&priv2->spu_chnlcntptr_RW, count_list[i].channel);\r\nout_be64(&priv2->spu_chnlcnt_RW, count_list[i].count);\r\n}\r\n}\r\nint spu_add_dev_attr(struct device_attribute *attr)\r\n{\r\nstruct spu *spu;\r\nmutex_lock(&spu_full_list_mutex);\r\nlist_for_each_entry(spu, &spu_full_list, full_list)\r\ndevice_create_file(&spu->dev, attr);\r\nmutex_unlock(&spu_full_list_mutex);\r\nreturn 0;\r\n}\r\nint spu_add_dev_attr_group(struct attribute_group *attrs)\r\n{\r\nstruct spu *spu;\r\nint rc = 0;\r\nmutex_lock(&spu_full_list_mutex);\r\nlist_for_each_entry(spu, &spu_full_list, full_list) {\r\nrc = sysfs_create_group(&spu->dev.kobj, attrs);\r\nif (rc) {\r\nprintk(KERN_ERR "%s: can't create sysfs group '%s'\n",\r\n__func__, attrs->name);\r\nlist_for_each_entry_continue_reverse(spu,\r\n&spu_full_list, full_list)\r\nsysfs_remove_group(&spu->dev.kobj, attrs);\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&spu_full_list_mutex);\r\nreturn rc;\r\n}\r\nvoid spu_remove_dev_attr(struct device_attribute *attr)\r\n{\r\nstruct spu *spu;\r\nmutex_lock(&spu_full_list_mutex);\r\nlist_for_each_entry(spu, &spu_full_list, full_list)\r\ndevice_remove_file(&spu->dev, attr);\r\nmutex_unlock(&spu_full_list_mutex);\r\n}\r\nvoid spu_remove_dev_attr_group(struct attribute_group *attrs)\r\n{\r\nstruct spu *spu;\r\nmutex_lock(&spu_full_list_mutex);\r\nlist_for_each_entry(spu, &spu_full_list, full_list)\r\nsysfs_remove_group(&spu->dev.kobj, attrs);\r\nmutex_unlock(&spu_full_list_mutex);\r\n}\r\nstatic int spu_create_dev(struct spu *spu)\r\n{\r\nint ret;\r\nspu->dev.id = spu->number;\r\nspu->dev.bus = &spu_subsys;\r\nret = device_register(&spu->dev);\r\nif (ret) {\r\nprintk(KERN_ERR "Can't register SPU %d with sysfs\n",\r\nspu->number);\r\nreturn ret;\r\n}\r\nsysfs_add_device_to_node(&spu->dev, spu->node);\r\nreturn 0;\r\n}\r\nstatic int __init create_spu(void *data)\r\n{\r\nstruct spu *spu;\r\nint ret;\r\nstatic int number;\r\nunsigned long flags;\r\nret = -ENOMEM;\r\nspu = kzalloc(sizeof (*spu), GFP_KERNEL);\r\nif (!spu)\r\ngoto out;\r\nspu->alloc_state = SPU_FREE;\r\nspin_lock_init(&spu->register_lock);\r\nspin_lock(&spu_lock);\r\nspu->number = number++;\r\nspin_unlock(&spu_lock);\r\nret = spu_create_spu(spu, data);\r\nif (ret)\r\ngoto out_free;\r\nspu_mfc_sdr_setup(spu);\r\nspu_mfc_sr1_set(spu, 0x33);\r\nret = spu_request_irqs(spu);\r\nif (ret)\r\ngoto out_destroy;\r\nret = spu_create_dev(spu);\r\nif (ret)\r\ngoto out_free_irqs;\r\nmutex_lock(&cbe_spu_info[spu->node].list_mutex);\r\nlist_add(&spu->cbe_list, &cbe_spu_info[spu->node].spus);\r\ncbe_spu_info[spu->node].n_spus++;\r\nmutex_unlock(&cbe_spu_info[spu->node].list_mutex);\r\nmutex_lock(&spu_full_list_mutex);\r\nspin_lock_irqsave(&spu_full_list_lock, flags);\r\nlist_add(&spu->full_list, &spu_full_list);\r\nspin_unlock_irqrestore(&spu_full_list_lock, flags);\r\nmutex_unlock(&spu_full_list_mutex);\r\nspu->stats.util_state = SPU_UTIL_IDLE_LOADED;\r\nspu->stats.tstamp = ktime_get_ns();\r\nINIT_LIST_HEAD(&spu->aff_list);\r\ngoto out;\r\nout_free_irqs:\r\nspu_free_irqs(spu);\r\nout_destroy:\r\nspu_destroy_spu(spu);\r\nout_free:\r\nkfree(spu);\r\nout:\r\nreturn ret;\r\n}\r\nstatic unsigned long long spu_acct_time(struct spu *spu,\r\nenum spu_utilization_state state)\r\n{\r\nunsigned long long time = spu->stats.times[state];\r\nif (spu->stats.util_state == state)\r\ntime += ktime_get_ns() - spu->stats.tstamp;\r\nreturn time / NSEC_PER_MSEC;\r\n}\r\nstatic ssize_t spu_stat_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct spu *spu = container_of(dev, struct spu, dev);\r\nreturn sprintf(buf, "%s %llu %llu %llu %llu "\r\n"%llu %llu %llu %llu %llu %llu %llu %llu\n",\r\nspu_state_names[spu->stats.util_state],\r\nspu_acct_time(spu, SPU_UTIL_USER),\r\nspu_acct_time(spu, SPU_UTIL_SYSTEM),\r\nspu_acct_time(spu, SPU_UTIL_IOWAIT),\r\nspu_acct_time(spu, SPU_UTIL_IDLE_LOADED),\r\nspu->stats.vol_ctx_switch,\r\nspu->stats.invol_ctx_switch,\r\nspu->stats.slb_flt,\r\nspu->stats.hash_flt,\r\nspu->stats.min_flt,\r\nspu->stats.maj_flt,\r\nspu->stats.class2_intr,\r\nspu->stats.libassist);\r\n}\r\nstatic void crash_kexec_stop_spus(void)\r\n{\r\nstruct spu *spu;\r\nint i;\r\nu64 tmp;\r\nfor (i = 0; i < CRASH_NUM_SPUS; i++) {\r\nif (!crash_spu_info[i].spu)\r\ncontinue;\r\nspu = crash_spu_info[i].spu;\r\ncrash_spu_info[i].saved_spu_runcntl_RW =\r\nin_be32(&spu->problem->spu_runcntl_RW);\r\ncrash_spu_info[i].saved_spu_status_R =\r\nin_be32(&spu->problem->spu_status_R);\r\ncrash_spu_info[i].saved_spu_npc_RW =\r\nin_be32(&spu->problem->spu_npc_RW);\r\ncrash_spu_info[i].saved_mfc_dar = spu_mfc_dar_get(spu);\r\ncrash_spu_info[i].saved_mfc_dsisr = spu_mfc_dsisr_get(spu);\r\ntmp = spu_mfc_sr1_get(spu);\r\ncrash_spu_info[i].saved_mfc_sr1_RW = tmp;\r\ntmp &= ~MFC_STATE1_MASTER_RUN_CONTROL_MASK;\r\nspu_mfc_sr1_set(spu, tmp);\r\n__delay(200);\r\n}\r\n}\r\nstatic void crash_register_spus(struct list_head *list)\r\n{\r\nstruct spu *spu;\r\nint ret;\r\nlist_for_each_entry(spu, list, full_list) {\r\nif (WARN_ON(spu->number >= CRASH_NUM_SPUS))\r\ncontinue;\r\ncrash_spu_info[spu->number].spu = spu;\r\n}\r\nret = crash_shutdown_register(&crash_kexec_stop_spus);\r\nif (ret)\r\nprintk(KERN_ERR "Could not register SPU crash handler");\r\n}\r\nstatic inline void crash_register_spus(struct list_head *list)\r\n{\r\n}\r\nstatic void spu_shutdown(void)\r\n{\r\nstruct spu *spu;\r\nmutex_lock(&spu_full_list_mutex);\r\nlist_for_each_entry(spu, &spu_full_list, full_list) {\r\nspu_free_irqs(spu);\r\nspu_destroy_spu(spu);\r\n}\r\nmutex_unlock(&spu_full_list_mutex);\r\n}\r\nstatic int __init init_spu_base(void)\r\n{\r\nint i, ret = 0;\r\nfor (i = 0; i < MAX_NUMNODES; i++) {\r\nmutex_init(&cbe_spu_info[i].list_mutex);\r\nINIT_LIST_HEAD(&cbe_spu_info[i].spus);\r\n}\r\nif (!spu_management_ops)\r\ngoto out;\r\nret = subsys_system_register(&spu_subsys, NULL);\r\nif (ret)\r\ngoto out;\r\nret = spu_enumerate_spus(create_spu);\r\nif (ret < 0) {\r\nprintk(KERN_WARNING "%s: Error initializing spus\n",\r\n__func__);\r\ngoto out_unregister_subsys;\r\n}\r\nif (ret > 0)\r\nfb_append_extra_logo(&logo_spe_clut224, ret);\r\nmutex_lock(&spu_full_list_mutex);\r\nxmon_register_spus(&spu_full_list);\r\ncrash_register_spus(&spu_full_list);\r\nmutex_unlock(&spu_full_list_mutex);\r\nspu_add_dev_attr(&dev_attr_stat);\r\nregister_syscore_ops(&spu_syscore_ops);\r\nspu_init_affinity();\r\nreturn 0;\r\nout_unregister_subsys:\r\nbus_unregister(&spu_subsys);\r\nout:\r\nreturn ret;\r\n}
