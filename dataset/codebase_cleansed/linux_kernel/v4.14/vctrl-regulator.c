static int vctrl_calc_ctrl_voltage(struct vctrl_data *vctrl, int out_uV)\r\n{\r\nstruct vctrl_voltage_range *ctrl = &vctrl->vrange.ctrl;\r\nstruct vctrl_voltage_range *out = &vctrl->vrange.out;\r\nreturn ctrl->min_uV +\r\nDIV_ROUND_CLOSEST_ULL((s64)(out_uV - out->min_uV) *\r\n(ctrl->max_uV - ctrl->min_uV),\r\nout->max_uV - out->min_uV);\r\n}\r\nstatic int vctrl_calc_output_voltage(struct vctrl_data *vctrl, int ctrl_uV)\r\n{\r\nstruct vctrl_voltage_range *ctrl = &vctrl->vrange.ctrl;\r\nstruct vctrl_voltage_range *out = &vctrl->vrange.out;\r\nif (ctrl_uV < 0) {\r\npr_err("vctrl: failed to get control voltage\n");\r\nreturn ctrl_uV;\r\n}\r\nif (ctrl_uV < ctrl->min_uV)\r\nreturn out->min_uV;\r\nif (ctrl_uV > ctrl->max_uV)\r\nreturn out->max_uV;\r\nreturn out->min_uV +\r\nDIV_ROUND_CLOSEST_ULL((s64)(ctrl_uV - ctrl->min_uV) *\r\n(out->max_uV - out->min_uV),\r\nctrl->max_uV - ctrl->min_uV);\r\n}\r\nstatic int vctrl_get_voltage(struct regulator_dev *rdev)\r\n{\r\nstruct vctrl_data *vctrl = rdev_get_drvdata(rdev);\r\nint ctrl_uV = regulator_get_voltage(vctrl->ctrl_reg);\r\nreturn vctrl_calc_output_voltage(vctrl, ctrl_uV);\r\n}\r\nstatic int vctrl_set_voltage(struct regulator_dev *rdev,\r\nint req_min_uV, int req_max_uV,\r\nunsigned int *selector)\r\n{\r\nstruct vctrl_data *vctrl = rdev_get_drvdata(rdev);\r\nstruct regulator *ctrl_reg = vctrl->ctrl_reg;\r\nint orig_ctrl_uV = regulator_get_voltage(ctrl_reg);\r\nint uV = vctrl_calc_output_voltage(vctrl, orig_ctrl_uV);\r\nint ret;\r\nif (req_min_uV >= uV || !vctrl->ovp_threshold)\r\nreturn regulator_set_voltage(\r\nctrl_reg,\r\nvctrl_calc_ctrl_voltage(vctrl, req_min_uV),\r\nvctrl_calc_ctrl_voltage(vctrl, req_max_uV));\r\nwhile (uV > req_min_uV) {\r\nint max_drop_uV = (uV * vctrl->ovp_threshold) / 100;\r\nint next_uV;\r\nint next_ctrl_uV;\r\nint delay;\r\nif (max_drop_uV == 0)\r\nmax_drop_uV = 1;\r\nnext_uV = max_t(int, req_min_uV, uV - max_drop_uV);\r\nnext_ctrl_uV = vctrl_calc_ctrl_voltage(vctrl, next_uV);\r\nret = regulator_set_voltage(ctrl_reg,\r\nnext_ctrl_uV,\r\nnext_ctrl_uV);\r\nif (ret)\r\ngoto err;\r\ndelay = DIV_ROUND_UP(uV - next_uV, vctrl->min_slew_down_rate);\r\nusleep_range(delay, delay + DIV_ROUND_UP(delay, 10));\r\nuV = next_uV;\r\n}\r\nreturn 0;\r\nerr:\r\nregulator_set_voltage(ctrl_reg, orig_ctrl_uV, orig_ctrl_uV);\r\nreturn ret;\r\n}\r\nstatic int vctrl_get_voltage_sel(struct regulator_dev *rdev)\r\n{\r\nstruct vctrl_data *vctrl = rdev_get_drvdata(rdev);\r\nreturn vctrl->sel;\r\n}\r\nstatic int vctrl_set_voltage_sel(struct regulator_dev *rdev,\r\nunsigned int selector)\r\n{\r\nstruct vctrl_data *vctrl = rdev_get_drvdata(rdev);\r\nstruct regulator *ctrl_reg = vctrl->ctrl_reg;\r\nunsigned int orig_sel = vctrl->sel;\r\nint ret;\r\nif (selector >= rdev->desc->n_voltages)\r\nreturn -EINVAL;\r\nif (selector >= vctrl->sel || !vctrl->ovp_threshold) {\r\nret = regulator_set_voltage(ctrl_reg,\r\nvctrl->vtable[selector].ctrl,\r\nvctrl->vtable[selector].ctrl);\r\nif (!ret)\r\nvctrl->sel = selector;\r\nreturn ret;\r\n}\r\nwhile (vctrl->sel != selector) {\r\nunsigned int next_sel;\r\nint delay;\r\nif (selector >= vctrl->vtable[vctrl->sel].ovp_min_sel)\r\nnext_sel = selector;\r\nelse\r\nnext_sel = vctrl->vtable[vctrl->sel].ovp_min_sel;\r\nret = regulator_set_voltage(ctrl_reg,\r\nvctrl->vtable[next_sel].ctrl,\r\nvctrl->vtable[next_sel].ctrl);\r\nif (ret) {\r\ndev_err(&rdev->dev,\r\n"failed to set control voltage to %duV\n",\r\nvctrl->vtable[next_sel].ctrl);\r\ngoto err;\r\n}\r\nvctrl->sel = next_sel;\r\ndelay = DIV_ROUND_UP(vctrl->vtable[vctrl->sel].out -\r\nvctrl->vtable[next_sel].out,\r\nvctrl->min_slew_down_rate);\r\nusleep_range(delay, delay + DIV_ROUND_UP(delay, 10));\r\n}\r\nreturn 0;\r\nerr:\r\nif (vctrl->sel != orig_sel) {\r\nif (!regulator_set_voltage(ctrl_reg,\r\nvctrl->vtable[orig_sel].ctrl,\r\nvctrl->vtable[orig_sel].ctrl))\r\nvctrl->sel = orig_sel;\r\nelse\r\ndev_warn(&rdev->dev,\r\n"failed to restore original voltage\n");\r\n}\r\nreturn ret;\r\n}\r\nstatic int vctrl_list_voltage(struct regulator_dev *rdev,\r\nunsigned int selector)\r\n{\r\nstruct vctrl_data *vctrl = rdev_get_drvdata(rdev);\r\nif (selector >= rdev->desc->n_voltages)\r\nreturn -EINVAL;\r\nreturn vctrl->vtable[selector].out;\r\n}\r\nstatic int vctrl_parse_dt(struct platform_device *pdev,\r\nstruct vctrl_data *vctrl)\r\n{\r\nint ret;\r\nstruct device_node *np = pdev->dev.of_node;\r\nu32 pval;\r\nu32 vrange_ctrl[2];\r\nvctrl->ctrl_reg = devm_regulator_get(&pdev->dev, "ctrl");\r\nif (IS_ERR(vctrl->ctrl_reg))\r\nreturn PTR_ERR(vctrl->ctrl_reg);\r\nret = of_property_read_u32(np, "ovp-threshold-percent", &pval);\r\nif (!ret) {\r\nvctrl->ovp_threshold = pval;\r\nif (vctrl->ovp_threshold > 100) {\r\ndev_err(&pdev->dev,\r\n"ovp-threshold-percent (%u) > 100\n",\r\nvctrl->ovp_threshold);\r\nreturn -EINVAL;\r\n}\r\n}\r\nret = of_property_read_u32(np, "min-slew-down-rate", &pval);\r\nif (!ret) {\r\nvctrl->min_slew_down_rate = pval;\r\nif (vctrl->min_slew_down_rate == 0) {\r\ndev_err(&pdev->dev,\r\n"min-slew-down-rate must not be 0\n");\r\nreturn -EINVAL;\r\n} else if (vctrl->min_slew_down_rate > INT_MAX) {\r\ndev_err(&pdev->dev, "min-slew-down-rate (%u) too big\n",\r\nvctrl->min_slew_down_rate);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (vctrl->ovp_threshold && !vctrl->min_slew_down_rate) {\r\ndev_err(&pdev->dev,\r\n"ovp-threshold-percent requires min-slew-down-rate\n");\r\nreturn -EINVAL;\r\n}\r\nret = of_property_read_u32(np, "regulator-min-microvolt", &pval);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"failed to read regulator-min-microvolt: %d\n", ret);\r\nreturn ret;\r\n}\r\nvctrl->vrange.out.min_uV = pval;\r\nret = of_property_read_u32(np, "regulator-max-microvolt", &pval);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"failed to read regulator-max-microvolt: %d\n", ret);\r\nreturn ret;\r\n}\r\nvctrl->vrange.out.max_uV = pval;\r\nret = of_property_read_u32_array(np, "ctrl-voltage-range", vrange_ctrl,\r\n2);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to read ctrl-voltage-range: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nif (vrange_ctrl[0] >= vrange_ctrl[1]) {\r\ndev_err(&pdev->dev, "ctrl-voltage-range is invalid: %d-%d\n",\r\nvrange_ctrl[0], vrange_ctrl[1]);\r\nreturn -EINVAL;\r\n}\r\nvctrl->vrange.ctrl.min_uV = vrange_ctrl[0];\r\nvctrl->vrange.ctrl.max_uV = vrange_ctrl[1];\r\nreturn 0;\r\n}\r\nstatic int vctrl_cmp_ctrl_uV(const void *a, const void *b)\r\n{\r\nconst struct vctrl_voltage_table *at = a;\r\nconst struct vctrl_voltage_table *bt = b;\r\nreturn at->ctrl - bt->ctrl;\r\n}\r\nstatic int vctrl_init_vtable(struct platform_device *pdev)\r\n{\r\nstruct vctrl_data *vctrl = platform_get_drvdata(pdev);\r\nstruct regulator_desc *rdesc = &vctrl->desc;\r\nstruct regulator *ctrl_reg = vctrl->ctrl_reg;\r\nstruct vctrl_voltage_range *vrange_ctrl = &vctrl->vrange.ctrl;\r\nint n_voltages;\r\nint ctrl_uV;\r\nint i, idx_vt;\r\nn_voltages = regulator_count_voltages(ctrl_reg);\r\nrdesc->n_voltages = n_voltages;\r\nfor (i = 0; i < n_voltages; i++) {\r\nctrl_uV = regulator_list_voltage(ctrl_reg, i);\r\nif (ctrl_uV < vrange_ctrl->min_uV ||\r\nctrl_uV > vrange_ctrl->max_uV) {\r\nrdesc->n_voltages--;\r\ncontinue;\r\n}\r\n}\r\nif (rdesc->n_voltages == 0) {\r\ndev_err(&pdev->dev, "invalid configuration\n");\r\nreturn -EINVAL;\r\n}\r\nvctrl->vtable = devm_kcalloc(&pdev->dev, rdesc->n_voltages,\r\nsizeof(struct vctrl_voltage_table),\r\nGFP_KERNEL);\r\nif (!vctrl->vtable)\r\nreturn -ENOMEM;\r\nfor (i = 0, idx_vt = 0; i < n_voltages; i++) {\r\nctrl_uV = regulator_list_voltage(ctrl_reg, i);\r\nif (ctrl_uV < vrange_ctrl->min_uV ||\r\nctrl_uV > vrange_ctrl->max_uV)\r\ncontinue;\r\nvctrl->vtable[idx_vt].ctrl = ctrl_uV;\r\nvctrl->vtable[idx_vt].out =\r\nvctrl_calc_output_voltage(vctrl, ctrl_uV);\r\nidx_vt++;\r\n}\r\nsort(vctrl->vtable, rdesc->n_voltages,\r\nsizeof(struct vctrl_voltage_table), vctrl_cmp_ctrl_uV,\r\nNULL);\r\nfor (i = rdesc->n_voltages - 1; i > 0; i--) {\r\nint j;\r\nint ovp_min_uV = (vctrl->vtable[i].out *\r\n(100 - vctrl->ovp_threshold)) / 100;\r\nfor (j = 0; j < i; j++) {\r\nif (vctrl->vtable[j].out >= ovp_min_uV) {\r\nvctrl->vtable[i].ovp_min_sel = j;\r\nbreak;\r\n}\r\n}\r\nif (j == i) {\r\ndev_warn(&pdev->dev, "switching down from %duV may cause OVP shutdown\n",\r\nvctrl->vtable[i].out);\r\nvctrl->vtable[i].ovp_min_sel = i - 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int vctrl_enable(struct regulator_dev *rdev)\r\n{\r\nstruct vctrl_data *vctrl = rdev_get_drvdata(rdev);\r\nint ret = regulator_enable(vctrl->ctrl_reg);\r\nif (!ret)\r\nvctrl->enabled = true;\r\nreturn ret;\r\n}\r\nstatic int vctrl_disable(struct regulator_dev *rdev)\r\n{\r\nstruct vctrl_data *vctrl = rdev_get_drvdata(rdev);\r\nint ret = regulator_disable(vctrl->ctrl_reg);\r\nif (!ret)\r\nvctrl->enabled = false;\r\nreturn ret;\r\n}\r\nstatic int vctrl_is_enabled(struct regulator_dev *rdev)\r\n{\r\nstruct vctrl_data *vctrl = rdev_get_drvdata(rdev);\r\nreturn vctrl->enabled;\r\n}\r\nstatic int vctrl_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct vctrl_data *vctrl;\r\nconst struct regulator_init_data *init_data;\r\nstruct regulator_desc *rdesc;\r\nstruct regulator_config cfg = { };\r\nstruct vctrl_voltage_range *vrange_ctrl;\r\nint ctrl_uV;\r\nint ret;\r\nvctrl = devm_kzalloc(&pdev->dev, sizeof(struct vctrl_data),\r\nGFP_KERNEL);\r\nif (!vctrl)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, vctrl);\r\nret = vctrl_parse_dt(pdev, vctrl);\r\nif (ret)\r\nreturn ret;\r\nvrange_ctrl = &vctrl->vrange.ctrl;\r\nrdesc = &vctrl->desc;\r\nrdesc->name = "vctrl";\r\nrdesc->type = REGULATOR_VOLTAGE;\r\nrdesc->owner = THIS_MODULE;\r\nif ((regulator_get_linear_step(vctrl->ctrl_reg) == 1) ||\r\n(regulator_count_voltages(vctrl->ctrl_reg) == -EINVAL)) {\r\nrdesc->continuous_voltage_range = true;\r\nrdesc->ops = &vctrl_ops_cont;\r\n} else {\r\nrdesc->ops = &vctrl_ops_non_cont;\r\n}\r\ninit_data = of_get_regulator_init_data(&pdev->dev, np, rdesc);\r\nif (!init_data)\r\nreturn -ENOMEM;\r\ncfg.of_node = np;\r\ncfg.dev = &pdev->dev;\r\ncfg.driver_data = vctrl;\r\ncfg.init_data = init_data;\r\nif (!rdesc->continuous_voltage_range) {\r\nret = vctrl_init_vtable(pdev);\r\nif (ret)\r\nreturn ret;\r\nctrl_uV = regulator_get_voltage(vctrl->ctrl_reg);\r\nif (ctrl_uV < 0) {\r\ndev_err(&pdev->dev, "failed to get control voltage\n");\r\nreturn ctrl_uV;\r\n}\r\nif (ctrl_uV < vrange_ctrl->min_uV) {\r\nvctrl->sel = 0;\r\n} else if (ctrl_uV > vrange_ctrl->max_uV) {\r\nvctrl->sel = rdesc->n_voltages - 1;\r\n} else {\r\nint i;\r\nfor (i = 0; i < rdesc->n_voltages; i++) {\r\nif (ctrl_uV == vctrl->vtable[i].ctrl) {\r\nvctrl->sel = i;\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nvctrl->rdev = devm_regulator_register(&pdev->dev, rdesc, &cfg);\r\nif (IS_ERR(vctrl->rdev)) {\r\nret = PTR_ERR(vctrl->rdev);\r\ndev_err(&pdev->dev, "failed to register regulator: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
