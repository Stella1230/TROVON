static int __rc5t583_set_ext_pwrreq1_control(struct device *dev,\r\nint id, int ext_pwr, int slots)\r\n{\r\nint ret;\r\nuint8_t sleepseq_val = 0;\r\nunsigned int en_bit;\r\nunsigned int slot_bit;\r\nif (id == RC5T583_DS_DC0) {\r\ndev_err(dev, "PWRREQ1 is invalid control for rail %d\n", id);\r\nreturn -EINVAL;\r\n}\r\nen_bit = deepsleep_data[id].ds_pos_bit;\r\nslot_bit = en_bit + 1;\r\nret = rc5t583_read(dev, deepsleep_data[id].reg_add, &sleepseq_val);\r\nif (ret < 0) {\r\ndev_err(dev, "Error in reading reg 0x%x\n",\r\ndeepsleep_data[id].reg_add);\r\nreturn ret;\r\n}\r\nsleepseq_val &= ~(0xF << en_bit);\r\nsleepseq_val |= BIT(en_bit);\r\nsleepseq_val |= ((slots & 0x7) << slot_bit);\r\nret = rc5t583_set_bits(dev, RICOH_ONOFFSEL_REG, BIT(1));\r\nif (ret < 0) {\r\ndev_err(dev, "Error in updating the 0x%02x register\n",\r\nRICOH_ONOFFSEL_REG);\r\nreturn ret;\r\n}\r\nret = rc5t583_write(dev, deepsleep_data[id].reg_add, sleepseq_val);\r\nif (ret < 0) {\r\ndev_err(dev, "Error in writing reg 0x%x\n",\r\ndeepsleep_data[id].reg_add);\r\nreturn ret;\r\n}\r\nif (id == RC5T583_DS_LDO4) {\r\nret = rc5t583_write(dev, RICOH_SWCTL_REG, 0x1);\r\nif (ret < 0)\r\ndev_err(dev, "Error in writing reg 0x%x\n",\r\nRICOH_SWCTL_REG);\r\n}\r\nreturn ret;\r\n}\r\nstatic int __rc5t583_set_ext_pwrreq2_control(struct device *dev,\r\nint id, int ext_pwr)\r\n{\r\nint ret;\r\nif (id != RC5T583_DS_DC0) {\r\ndev_err(dev, "PWRREQ2 is invalid control for rail %d\n", id);\r\nreturn -EINVAL;\r\n}\r\nret = rc5t583_set_bits(dev, RICOH_ONOFFSEL_REG, BIT(2));\r\nif (ret < 0)\r\ndev_err(dev, "Error in updating the ONOFFSEL 0x10 register\n");\r\nreturn ret;\r\n}\r\nint rc5t583_ext_power_req_config(struct device *dev, int ds_id,\r\nint ext_pwr_req, int deepsleep_slot_nr)\r\n{\r\nif ((ext_pwr_req & EXT_PWR_REQ) == EXT_PWR_REQ)\r\nreturn -EINVAL;\r\nif (ext_pwr_req & RC5T583_EXT_PWRREQ1_CONTROL)\r\nreturn __rc5t583_set_ext_pwrreq1_control(dev, ds_id,\r\next_pwr_req, deepsleep_slot_nr);\r\nif (ext_pwr_req & RC5T583_EXT_PWRREQ2_CONTROL)\r\nreturn __rc5t583_set_ext_pwrreq2_control(dev,\r\nds_id, ext_pwr_req);\r\nreturn 0;\r\n}\r\nstatic int rc5t583_clear_ext_power_req(struct rc5t583 *rc5t583,\r\nstruct rc5t583_platform_data *pdata)\r\n{\r\nint ret;\r\nint i;\r\nuint8_t on_off_val = 0;\r\nif (pdata->enable_shutdown)\r\non_off_val = 0x1;\r\nret = rc5t583_write(rc5t583->dev, RICOH_ONOFFSEL_REG, on_off_val);\r\nif (ret < 0)\r\ndev_warn(rc5t583->dev, "Error in writing reg %d error: %d\n",\r\nRICOH_ONOFFSEL_REG, ret);\r\nret = rc5t583_write(rc5t583->dev, RICOH_SWCTL_REG, 0x0);\r\nif (ret < 0)\r\ndev_warn(rc5t583->dev, "Error in writing reg %d error: %d\n",\r\nRICOH_SWCTL_REG, ret);\r\nfor (i = RC5T583_SLPSEQ1; i <= RC5T583_SLPSEQ11; ++i) {\r\nret = rc5t583_write(rc5t583->dev, i, 0x0);\r\nif (ret < 0)\r\ndev_warn(rc5t583->dev,\r\n"Error in writing reg 0x%02x error: %d\n",\r\ni, ret);\r\n}\r\nreturn 0;\r\n}\r\nstatic bool volatile_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase RC5T583_INT_EN_SYS1:\r\ncase RC5T583_INT_EN_SYS2:\r\ncase RC5T583_INT_EN_DCDC:\r\ncase RC5T583_INT_EN_RTC:\r\ncase RC5T583_INT_EN_ADC1:\r\ncase RC5T583_INT_EN_ADC2:\r\ncase RC5T583_INT_EN_ADC3:\r\ncase RC5T583_GPIO_GPEDGE1:\r\ncase RC5T583_GPIO_GPEDGE2:\r\ncase RC5T583_GPIO_EN_INT:\r\nreturn false;\r\ncase RC5T583_GPIO_MON_IOIN:\r\nreturn true;\r\ndefault:\r\nif ((reg >= RC5T583_GPIO_IOSEL) &&\r\n(reg <= RC5T583_GPIO_GPOFUNC))\r\nreturn false;\r\nif ((reg >= RC5T583_SLPSEQ1) && (reg <= RC5T583_SLPSEQ11))\r\nreturn false;\r\nif ((reg >= RC5T583_REG_DC0CTL) && (reg <= RC5T583_REG_SR3CTL))\r\nreturn false;\r\nif ((reg >= RC5T583_REG_LDOEN1) &&\r\n(reg <= RC5T583_REG_LDO9DAC_DS))\r\nreturn false;\r\nbreak;\r\n}\r\nreturn true;\r\n}\r\nstatic int rc5t583_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct rc5t583 *rc5t583;\r\nstruct rc5t583_platform_data *pdata = dev_get_platdata(&i2c->dev);\r\nint ret;\r\nif (!pdata) {\r\ndev_err(&i2c->dev, "Err: Platform data not found\n");\r\nreturn -EINVAL;\r\n}\r\nrc5t583 = devm_kzalloc(&i2c->dev, sizeof(struct rc5t583), GFP_KERNEL);\r\nif (!rc5t583) {\r\ndev_err(&i2c->dev, "Memory allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nrc5t583->dev = &i2c->dev;\r\ni2c_set_clientdata(i2c, rc5t583);\r\nrc5t583->regmap = devm_regmap_init_i2c(i2c, &rc5t583_regmap_config);\r\nif (IS_ERR(rc5t583->regmap)) {\r\nret = PTR_ERR(rc5t583->regmap);\r\ndev_err(&i2c->dev, "regmap initialization failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = rc5t583_clear_ext_power_req(rc5t583, pdata);\r\nif (ret < 0)\r\nreturn ret;\r\nif (i2c->irq) {\r\nret = rc5t583_irq_init(rc5t583, i2c->irq, pdata->irq_base);\r\nif (ret)\r\ndev_warn(&i2c->dev, "IRQ init failed: %d\n", ret);\r\n}\r\nret = devm_mfd_add_devices(rc5t583->dev, -1, rc5t583_subdevs,\r\nARRAY_SIZE(rc5t583_subdevs), NULL, 0, NULL);\r\nif (ret) {\r\ndev_err(&i2c->dev, "add mfd devices failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init rc5t583_i2c_init(void)\r\n{\r\nreturn i2c_add_driver(&rc5t583_i2c_driver);\r\n}\r\nstatic void __exit rc5t583_i2c_exit(void)\r\n{\r\ni2c_del_driver(&rc5t583_i2c_driver);\r\n}
