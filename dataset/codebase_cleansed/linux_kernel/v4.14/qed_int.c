static int qed_mcp_attn_cb(struct qed_hwfn *p_hwfn)\r\n{\r\nu32 tmp = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt, MCP_REG_CPU_STATE);\r\nDP_INFO(p_hwfn->cdev, "MCP_REG_CPU_STATE: %08x - Masking...\n",\r\ntmp);\r\nqed_wr(p_hwfn, p_hwfn->p_dpc_ptt, MCP_REG_CPU_EVENT_MASK,\r\n0xffffffff);\r\nreturn 0;\r\n}\r\nstatic int qed_pswhst_attn_cb(struct qed_hwfn *p_hwfn)\r\n{\r\nu32 tmp = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt,\r\nPSWHST_REG_INCORRECT_ACCESS_VALID);\r\nif (tmp & QED_PSWHST_ATTENTION_INCORRECT_ACCESS) {\r\nu32 addr, data, length;\r\naddr = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt,\r\nPSWHST_REG_INCORRECT_ACCESS_ADDRESS);\r\ndata = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt,\r\nPSWHST_REG_INCORRECT_ACCESS_DATA);\r\nlength = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt,\r\nPSWHST_REG_INCORRECT_ACCESS_LENGTH);\r\nDP_INFO(p_hwfn->cdev,\r\n"Incorrect access to %08x of length %08x - PF [%02x] VF [%04x] [valid %02x] client [%02x] write [%02x] Byte-Enable [%04x] [%08x]\n",\r\naddr, length,\r\n(u8) GET_FIELD(data, ATTENTION_INCORRECT_ACCESS_PF_ID),\r\n(u8) GET_FIELD(data, ATTENTION_INCORRECT_ACCESS_VF_ID),\r\n(u8) GET_FIELD(data,\r\nATTENTION_INCORRECT_ACCESS_VF_VALID),\r\n(u8) GET_FIELD(data,\r\nATTENTION_INCORRECT_ACCESS_CLIENT),\r\n(u8) GET_FIELD(data, ATTENTION_INCORRECT_ACCESS_WR),\r\n(u8) GET_FIELD(data,\r\nATTENTION_INCORRECT_ACCESS_BYTE_EN),\r\ndata);\r\n}\r\nreturn 0;\r\n}\r\nstatic const char *attn_master_to_str(u8 master)\r\n{\r\nswitch (master) {\r\ncase 1: return "PXP";\r\ncase 2: return "MCP";\r\ncase 3: return "MSDM";\r\ncase 4: return "PSDM";\r\ncase 5: return "YSDM";\r\ncase 6: return "USDM";\r\ncase 7: return "TSDM";\r\ncase 8: return "XSDM";\r\ncase 9: return "DBU";\r\ncase 10: return "DMAE";\r\ndefault:\r\nreturn "Unknown";\r\n}\r\n}\r\nstatic int qed_grc_attn_cb(struct qed_hwfn *p_hwfn)\r\n{\r\nu32 tmp, tmp2;\r\ntmp = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt,\r\nGRC_REG_TIMEOUT_ATTN_ACCESS_VALID);\r\nif (!(tmp & QED_GRC_ATTENTION_VALID_BIT))\r\ngoto out;\r\ntmp = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt,\r\nGRC_REG_TIMEOUT_ATTN_ACCESS_DATA_0);\r\ntmp2 = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt,\r\nGRC_REG_TIMEOUT_ATTN_ACCESS_DATA_1);\r\nDP_INFO(p_hwfn->cdev,\r\n"GRC timeout [%08x:%08x] - %s Address [%08x] [Master %s] [PF: %02x %s %02x]\n",\r\ntmp2, tmp,\r\n(tmp & QED_GRC_ATTENTION_RDWR_BIT) ? "Write to" : "Read from",\r\nGET_FIELD(tmp, QED_GRC_ATTENTION_ADDRESS) << 2,\r\nattn_master_to_str(GET_FIELD(tmp, QED_GRC_ATTENTION_MASTER)),\r\nGET_FIELD(tmp2, QED_GRC_ATTENTION_PF),\r\n(GET_FIELD(tmp2, QED_GRC_ATTENTION_PRIV) ==\r\nQED_GRC_ATTENTION_PRIV_VF) ? "VF" : "(Ireelevant)",\r\nGET_FIELD(tmp2, QED_GRC_ATTENTION_VF));\r\nout:\r\nqed_wr(p_hwfn, p_hwfn->p_dpc_ptt,\r\nGRC_REG_TIMEOUT_ATTN_ACCESS_VALID, 0);\r\nreturn 0;\r\n}\r\nstatic int qed_pglub_rbc_attn_cb(struct qed_hwfn *p_hwfn)\r\n{\r\nu32 tmp;\r\ntmp = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt,\r\nPGLUE_B_REG_TX_ERR_WR_DETAILS2);\r\nif (tmp & PGLUE_ATTENTION_VALID) {\r\nu32 addr_lo, addr_hi, details;\r\naddr_lo = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt,\r\nPGLUE_B_REG_TX_ERR_WR_ADD_31_0);\r\naddr_hi = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt,\r\nPGLUE_B_REG_TX_ERR_WR_ADD_63_32);\r\ndetails = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt,\r\nPGLUE_B_REG_TX_ERR_WR_DETAILS);\r\nDP_INFO(p_hwfn,\r\n"Illegal write by chip to [%08x:%08x] blocked.\n"\r\n"Details: %08x [PFID %02x, VFID %02x, VF_VALID %02x]\n"\r\n"Details2 %08x [Was_error %02x BME deassert %02x FID_enable deassert %02x]\n",\r\naddr_hi, addr_lo, details,\r\n(u8)GET_FIELD(details, PGLUE_ATTENTION_DETAILS_PFID),\r\n(u8)GET_FIELD(details, PGLUE_ATTENTION_DETAILS_VFID),\r\nGET_FIELD(details,\r\nPGLUE_ATTENTION_DETAILS_VF_VALID) ? 1 : 0,\r\ntmp,\r\nGET_FIELD(tmp,\r\nPGLUE_ATTENTION_DETAILS2_WAS_ERR) ? 1 : 0,\r\nGET_FIELD(tmp,\r\nPGLUE_ATTENTION_DETAILS2_BME) ? 1 : 0,\r\nGET_FIELD(tmp,\r\nPGLUE_ATTENTION_DETAILS2_FID_EN) ? 1 : 0);\r\n}\r\ntmp = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt,\r\nPGLUE_B_REG_TX_ERR_RD_DETAILS2);\r\nif (tmp & PGLUE_ATTENTION_RD_VALID) {\r\nu32 addr_lo, addr_hi, details;\r\naddr_lo = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt,\r\nPGLUE_B_REG_TX_ERR_RD_ADD_31_0);\r\naddr_hi = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt,\r\nPGLUE_B_REG_TX_ERR_RD_ADD_63_32);\r\ndetails = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt,\r\nPGLUE_B_REG_TX_ERR_RD_DETAILS);\r\nDP_INFO(p_hwfn,\r\n"Illegal read by chip from [%08x:%08x] blocked.\n"\r\n" Details: %08x [PFID %02x, VFID %02x, VF_VALID %02x]\n"\r\n" Details2 %08x [Was_error %02x BME deassert %02x FID_enable deassert %02x]\n",\r\naddr_hi, addr_lo, details,\r\n(u8)GET_FIELD(details, PGLUE_ATTENTION_DETAILS_PFID),\r\n(u8)GET_FIELD(details, PGLUE_ATTENTION_DETAILS_VFID),\r\nGET_FIELD(details,\r\nPGLUE_ATTENTION_DETAILS_VF_VALID) ? 1 : 0,\r\ntmp,\r\nGET_FIELD(tmp, PGLUE_ATTENTION_DETAILS2_WAS_ERR) ? 1\r\n: 0,\r\nGET_FIELD(tmp, PGLUE_ATTENTION_DETAILS2_BME) ? 1 : 0,\r\nGET_FIELD(tmp, PGLUE_ATTENTION_DETAILS2_FID_EN) ? 1\r\n: 0);\r\n}\r\ntmp = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt,\r\nPGLUE_B_REG_TX_ERR_WR_DETAILS_ICPL);\r\nif (tmp & PGLUE_ATTENTION_ICPL_VALID)\r\nDP_INFO(p_hwfn, "ICPL eror - %08x\n", tmp);\r\ntmp = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt,\r\nPGLUE_B_REG_MASTER_ZLR_ERR_DETAILS);\r\nif (tmp & PGLUE_ATTENTION_ZLR_VALID) {\r\nu32 addr_hi, addr_lo;\r\naddr_lo = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt,\r\nPGLUE_B_REG_MASTER_ZLR_ERR_ADD_31_0);\r\naddr_hi = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt,\r\nPGLUE_B_REG_MASTER_ZLR_ERR_ADD_63_32);\r\nDP_INFO(p_hwfn, "ZLR eror - %08x [Address %08x:%08x]\n",\r\ntmp, addr_hi, addr_lo);\r\n}\r\ntmp = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt,\r\nPGLUE_B_REG_VF_ILT_ERR_DETAILS2);\r\nif (tmp & PGLUE_ATTENTION_ILT_VALID) {\r\nu32 addr_hi, addr_lo, details;\r\naddr_lo = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt,\r\nPGLUE_B_REG_VF_ILT_ERR_ADD_31_0);\r\naddr_hi = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt,\r\nPGLUE_B_REG_VF_ILT_ERR_ADD_63_32);\r\ndetails = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt,\r\nPGLUE_B_REG_VF_ILT_ERR_DETAILS);\r\nDP_INFO(p_hwfn,\r\n"ILT error - Details %08x Details2 %08x [Address %08x:%08x]\n",\r\ndetails, tmp, addr_hi, addr_lo);\r\n}\r\nqed_wr(p_hwfn, p_hwfn->p_dpc_ptt,\r\nPGLUE_B_REG_LATCHED_ERRORS_CLR, (1 << 2));\r\nreturn 0;\r\n}\r\nstatic int qed_dorq_attn_cb(struct qed_hwfn *p_hwfn)\r\n{\r\nu32 reason;\r\nreason = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt, DORQ_REG_DB_DROP_REASON) &\r\nQED_DORQ_ATTENTION_REASON_MASK;\r\nif (reason) {\r\nu32 details = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt,\r\nDORQ_REG_DB_DROP_DETAILS);\r\nDP_INFO(p_hwfn->cdev,\r\n"DORQ db_drop: address 0x%08x Opaque FID 0x%04x Size [bytes] 0x%08x Reason: 0x%08x\n",\r\nqed_rd(p_hwfn, p_hwfn->p_dpc_ptt,\r\nDORQ_REG_DB_DROP_DETAILS_ADDRESS),\r\n(u16)(details & QED_DORQ_ATTENTION_OPAQUE_MASK),\r\nGET_FIELD(details, QED_DORQ_ATTENTION_SIZE) * 4,\r\nreason);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic struct aeu_invert_reg_bit *\r\nqed_int_aeu_translate(struct qed_hwfn *p_hwfn,\r\nstruct aeu_invert_reg_bit *p_bit)\r\n{\r\nif (!QED_IS_BB(p_hwfn->cdev))\r\nreturn p_bit;\r\nif (!(p_bit->flags & ATTENTION_BB_DIFFERENT))\r\nreturn p_bit;\r\nreturn &aeu_descs_special[(p_bit->flags & ATTENTION_BB_MASK) >>\r\nATTENTION_BB_SHIFT];\r\n}\r\nstatic bool qed_int_is_parity_flag(struct qed_hwfn *p_hwfn,\r\nstruct aeu_invert_reg_bit *p_bit)\r\n{\r\nreturn !!(qed_int_aeu_translate(p_hwfn, p_bit)->flags &\r\nATTENTION_PARITY);\r\n}\r\nstatic inline u16 qed_attn_update_idx(struct qed_hwfn *p_hwfn,\r\nstruct qed_sb_attn_info *p_sb_desc)\r\n{\r\nu16 rc = 0, index;\r\nmmiowb();\r\nindex = le16_to_cpu(p_sb_desc->sb_attn->sb_index);\r\nif (p_sb_desc->index != index) {\r\np_sb_desc->index = index;\r\nrc = QED_SB_ATT_IDX;\r\n}\r\nmmiowb();\r\nreturn rc;\r\n}\r\nstatic int qed_int_assertion(struct qed_hwfn *p_hwfn, u16 asserted_bits)\r\n{\r\nstruct qed_sb_attn_info *sb_attn_sw = p_hwfn->p_sb_attn;\r\nu32 igu_mask;\r\nigu_mask = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt, IGU_REG_ATTENTION_ENABLE);\r\nDP_VERBOSE(p_hwfn, NETIF_MSG_INTR, "IGU mask: 0x%08x --> 0x%08x\n",\r\nigu_mask, igu_mask & ~(asserted_bits & ATTN_BITS_MASKABLE));\r\nigu_mask &= ~(asserted_bits & ATTN_BITS_MASKABLE);\r\nqed_wr(p_hwfn, p_hwfn->p_dpc_ptt, IGU_REG_ATTENTION_ENABLE, igu_mask);\r\nDP_VERBOSE(p_hwfn, NETIF_MSG_INTR,\r\n"inner known ATTN state: 0x%04x --> 0x%04x\n",\r\nsb_attn_sw->known_attn,\r\nsb_attn_sw->known_attn | asserted_bits);\r\nsb_attn_sw->known_attn |= asserted_bits;\r\nif (asserted_bits & 0x100) {\r\nqed_mcp_handle_events(p_hwfn, p_hwfn->p_dpc_ptt);\r\nqed_wr(p_hwfn, p_hwfn->p_dpc_ptt,\r\nsb_attn_sw->mfw_attn_addr, 0);\r\n}\r\nDIRECT_REG_WR((u8 __iomem *)p_hwfn->regview +\r\nGTT_BAR0_MAP_REG_IGU_CMD +\r\n((IGU_CMD_ATTN_BIT_SET_UPPER -\r\nIGU_CMD_INT_ACK_BASE) << 3),\r\n(u32)asserted_bits);\r\nDP_VERBOSE(p_hwfn, NETIF_MSG_INTR, "set cmd IGU: 0x%04x\n",\r\nasserted_bits);\r\nreturn 0;\r\n}\r\nstatic void qed_int_attn_print(struct qed_hwfn *p_hwfn,\r\nenum block_id id,\r\nenum dbg_attn_type type, bool b_clear)\r\n{\r\nstruct dbg_attn_block_result attn_results;\r\nenum dbg_status status;\r\nmemset(&attn_results, 0, sizeof(attn_results));\r\nstatus = qed_dbg_read_attn(p_hwfn, p_hwfn->p_dpc_ptt, id, type,\r\nb_clear, &attn_results);\r\nif (status != DBG_STATUS_OK)\r\nDP_NOTICE(p_hwfn,\r\n"Failed to parse attention information [status: %s]\n",\r\nqed_dbg_get_status_str(status));\r\nelse\r\nqed_dbg_parse_attn(p_hwfn, &attn_results);\r\n}\r\nstatic int\r\nqed_int_deassertion_aeu_bit(struct qed_hwfn *p_hwfn,\r\nstruct aeu_invert_reg_bit *p_aeu,\r\nu32 aeu_en_reg,\r\nconst char *p_bit_name, u32 bitmask)\r\n{\r\nbool b_fatal = false;\r\nint rc = -EINVAL;\r\nu32 val;\r\nDP_INFO(p_hwfn, "Deasserted attention `%s'[%08x]\n",\r\np_bit_name, bitmask);\r\nif (p_aeu->cb) {\r\nDP_INFO(p_hwfn, "`%s (attention)': Calling Callback function\n",\r\np_bit_name);\r\nrc = p_aeu->cb(p_hwfn);\r\n}\r\nif (rc)\r\nb_fatal = true;\r\nif (p_aeu->block_index != MAX_BLOCK_ID)\r\nqed_int_attn_print(p_hwfn, p_aeu->block_index,\r\nATTN_TYPE_INTERRUPT, !b_fatal);\r\nif (!rc)\r\ngoto out;\r\nval = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt, aeu_en_reg);\r\nqed_wr(p_hwfn, p_hwfn->p_dpc_ptt, aeu_en_reg, (val & ~bitmask));\r\nDP_INFO(p_hwfn, "`%s' - Disabled future attentions\n",\r\np_bit_name);\r\nout:\r\nreturn rc;\r\n}\r\nstatic void qed_int_deassertion_parity(struct qed_hwfn *p_hwfn,\r\nstruct aeu_invert_reg_bit *p_aeu,\r\nu32 aeu_en_reg, u8 bit_index)\r\n{\r\nu32 block_id = p_aeu->block_index, mask, val;\r\nDP_NOTICE(p_hwfn->cdev,\r\n"%s parity attention is set [address 0x%08x, bit %d]\n",\r\np_aeu->bit_name, aeu_en_reg, bit_index);\r\nif (block_id != MAX_BLOCK_ID) {\r\nqed_int_attn_print(p_hwfn, block_id, ATTN_TYPE_PARITY, false);\r\nif (block_id == BLOCK_BTB) {\r\nqed_int_attn_print(p_hwfn, BLOCK_OPTE,\r\nATTN_TYPE_PARITY, false);\r\nqed_int_attn_print(p_hwfn, BLOCK_MCP,\r\nATTN_TYPE_PARITY, false);\r\n}\r\n}\r\nmask = ~BIT(bit_index);\r\nval = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt, aeu_en_reg);\r\nqed_wr(p_hwfn, p_hwfn->p_dpc_ptt, aeu_en_reg, val & mask);\r\nDP_INFO(p_hwfn, "`%s' - Disabled future parity errors\n",\r\np_aeu->bit_name);\r\n}\r\nstatic int qed_int_deassertion(struct qed_hwfn *p_hwfn,\r\nu16 deasserted_bits)\r\n{\r\nstruct qed_sb_attn_info *sb_attn_sw = p_hwfn->p_sb_attn;\r\nu32 aeu_inv_arr[NUM_ATTN_REGS], aeu_mask, aeu_en, en;\r\nu8 i, j, k, bit_idx;\r\nint rc = 0;\r\nfor (i = 0; i < NUM_ATTN_REGS; i++) {\r\naeu_inv_arr[i] = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt,\r\nMISC_REG_AEU_AFTER_INVERT_1_IGU +\r\ni * 0x4);\r\nDP_VERBOSE(p_hwfn, NETIF_MSG_INTR,\r\n"Deasserted bits [%d]: %08x\n",\r\ni, aeu_inv_arr[i]);\r\n}\r\nfor (i = 0; i < NUM_ATTN_REGS; i++) {\r\nstruct aeu_invert_reg *p_aeu = &sb_attn_sw->p_aeu_desc[i];\r\nu32 parities;\r\naeu_en = MISC_REG_AEU_ENABLE1_IGU_OUT_0 + i * sizeof(u32);\r\nen = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt, aeu_en);\r\nparities = sb_attn_sw->parity_mask[i] & aeu_inv_arr[i] & en;\r\nif (!parities)\r\ncontinue;\r\nfor (j = 0, bit_idx = 0; bit_idx < 32; j++) {\r\nstruct aeu_invert_reg_bit *p_bit = &p_aeu->bits[j];\r\nif (qed_int_is_parity_flag(p_hwfn, p_bit) &&\r\n!!(parities & BIT(bit_idx)))\r\nqed_int_deassertion_parity(p_hwfn, p_bit,\r\naeu_en, bit_idx);\r\nbit_idx += ATTENTION_LENGTH(p_bit->flags);\r\n}\r\n}\r\nfor (k = 0; k < MAX_ATTN_GRPS; k++) {\r\nstruct aeu_invert_reg_bit *p_aeu;\r\nif (!(deasserted_bits & (1 << k)))\r\ncontinue;\r\nfor (i = 0; i < NUM_ATTN_REGS; i++) {\r\nu32 bits;\r\naeu_en = MISC_REG_AEU_ENABLE1_IGU_OUT_0 +\r\ni * sizeof(u32) +\r\nk * sizeof(u32) * NUM_ATTN_REGS;\r\nen = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt, aeu_en);\r\nbits = aeu_inv_arr[i] & en;\r\nif (!bits)\r\ncontinue;\r\nfor (j = 0, bit_idx = 0; bit_idx < 32; j++) {\r\nlong unsigned int bitmask;\r\nu8 bit, bit_len;\r\np_aeu = &sb_attn_sw->p_aeu_desc[i].bits[j];\r\np_aeu = qed_int_aeu_translate(p_hwfn, p_aeu);\r\nbit = bit_idx;\r\nbit_len = ATTENTION_LENGTH(p_aeu->flags);\r\nif (qed_int_is_parity_flag(p_hwfn, p_aeu)) {\r\nbit++;\r\nbit_len--;\r\n}\r\nbitmask = bits & (((1 << bit_len) - 1) << bit);\r\nbitmask >>= bit;\r\nif (bitmask) {\r\nu32 flags = p_aeu->flags;\r\nchar bit_name[30];\r\nu8 num;\r\nnum = (u8)find_first_bit(&bitmask,\r\nbit_len);\r\nif (ATTENTION_LENGTH(flags) > 2 ||\r\n((flags & ATTENTION_PAR_INT) &&\r\nATTENTION_LENGTH(flags) > 1))\r\nsnprintf(bit_name, 30,\r\np_aeu->bit_name, num);\r\nelse\r\nstrncpy(bit_name,\r\np_aeu->bit_name, 30);\r\nbitmask <<= bit;\r\nqed_int_deassertion_aeu_bit(p_hwfn,\r\np_aeu,\r\naeu_en,\r\nbit_name,\r\nbitmask);\r\n}\r\nbit_idx += ATTENTION_LENGTH(p_aeu->flags);\r\n}\r\n}\r\n}\r\nDIRECT_REG_WR((u8 __iomem *)p_hwfn->regview +\r\nGTT_BAR0_MAP_REG_IGU_CMD +\r\n((IGU_CMD_ATTN_BIT_CLR_UPPER -\r\nIGU_CMD_INT_ACK_BASE) << 3),\r\n~((u32)deasserted_bits));\r\naeu_mask = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt, IGU_REG_ATTENTION_ENABLE);\r\naeu_mask |= (deasserted_bits & ATTN_BITS_MASKABLE);\r\nqed_wr(p_hwfn, p_hwfn->p_dpc_ptt, IGU_REG_ATTENTION_ENABLE, aeu_mask);\r\nsb_attn_sw->known_attn &= ~deasserted_bits;\r\nreturn rc;\r\n}\r\nstatic int qed_int_attentions(struct qed_hwfn *p_hwfn)\r\n{\r\nstruct qed_sb_attn_info *p_sb_attn_sw = p_hwfn->p_sb_attn;\r\nstruct atten_status_block *p_sb_attn = p_sb_attn_sw->sb_attn;\r\nu32 attn_bits = 0, attn_acks = 0;\r\nu16 asserted_bits, deasserted_bits;\r\n__le16 index;\r\nint rc = 0;\r\ndo {\r\nindex = p_sb_attn->sb_index;\r\nattn_bits = le32_to_cpu(p_sb_attn->atten_bits);\r\nattn_acks = le32_to_cpu(p_sb_attn->atten_ack);\r\n} while (index != p_sb_attn->sb_index);\r\np_sb_attn->sb_index = index;\r\nasserted_bits = (attn_bits & ~attn_acks & ATTN_STATE_BITS) &\r\n~p_sb_attn_sw->known_attn;\r\ndeasserted_bits = (~attn_bits & attn_acks & ATTN_STATE_BITS) &\r\np_sb_attn_sw->known_attn;\r\nif ((asserted_bits & ~0x100) || (deasserted_bits & ~0x100)) {\r\nDP_INFO(p_hwfn,\r\n"Attention: Index: 0x%04x, Bits: 0x%08x, Acks: 0x%08x, asserted: 0x%04x, De-asserted 0x%04x [Prev. known: 0x%04x]\n",\r\nindex, attn_bits, attn_acks, asserted_bits,\r\ndeasserted_bits, p_sb_attn_sw->known_attn);\r\n} else if (asserted_bits == 0x100) {\r\nDP_INFO(p_hwfn, "MFW indication via attention\n");\r\n} else {\r\nDP_VERBOSE(p_hwfn, NETIF_MSG_INTR,\r\n"MFW indication [deassertion]\n");\r\n}\r\nif (asserted_bits) {\r\nrc = qed_int_assertion(p_hwfn, asserted_bits);\r\nif (rc)\r\nreturn rc;\r\n}\r\nif (deasserted_bits)\r\nrc = qed_int_deassertion(p_hwfn, deasserted_bits);\r\nreturn rc;\r\n}\r\nstatic void qed_sb_ack_attn(struct qed_hwfn *p_hwfn,\r\nvoid __iomem *igu_addr, u32 ack_cons)\r\n{\r\nstruct igu_prod_cons_update igu_ack = { 0 };\r\nigu_ack.sb_id_and_flags =\r\n((ack_cons << IGU_PROD_CONS_UPDATE_SB_INDEX_SHIFT) |\r\n(1 << IGU_PROD_CONS_UPDATE_UPDATE_FLAG_SHIFT) |\r\n(IGU_INT_NOP << IGU_PROD_CONS_UPDATE_ENABLE_INT_SHIFT) |\r\n(IGU_SEG_ACCESS_ATTN <<\r\nIGU_PROD_CONS_UPDATE_SEGMENT_ACCESS_SHIFT));\r\nDIRECT_REG_WR(igu_addr, igu_ack.sb_id_and_flags);\r\nmmiowb();\r\nbarrier();\r\n}\r\nvoid qed_int_sp_dpc(unsigned long hwfn_cookie)\r\n{\r\nstruct qed_hwfn *p_hwfn = (struct qed_hwfn *)hwfn_cookie;\r\nstruct qed_pi_info *pi_info = NULL;\r\nstruct qed_sb_attn_info *sb_attn;\r\nstruct qed_sb_info *sb_info;\r\nint arr_size;\r\nu16 rc = 0;\r\nif (!p_hwfn->p_sp_sb) {\r\nDP_ERR(p_hwfn->cdev, "DPC called - no p_sp_sb\n");\r\nreturn;\r\n}\r\nsb_info = &p_hwfn->p_sp_sb->sb_info;\r\narr_size = ARRAY_SIZE(p_hwfn->p_sp_sb->pi_info_arr);\r\nif (!sb_info) {\r\nDP_ERR(p_hwfn->cdev,\r\n"Status block is NULL - cannot ack interrupts\n");\r\nreturn;\r\n}\r\nif (!p_hwfn->p_sb_attn) {\r\nDP_ERR(p_hwfn->cdev, "DPC called - no p_sb_attn");\r\nreturn;\r\n}\r\nsb_attn = p_hwfn->p_sb_attn;\r\nDP_VERBOSE(p_hwfn, NETIF_MSG_INTR, "DPC Called! (hwfn %p %d)\n",\r\np_hwfn, p_hwfn->my_id);\r\nqed_sb_ack(sb_info, IGU_INT_DISABLE, 0);\r\nif (!sb_info->sb_virt) {\r\nDP_ERR(p_hwfn->cdev,\r\n"Interrupt Status block is NULL - cannot check for new interrupts!\n");\r\n} else {\r\nu32 tmp_index = sb_info->sb_ack;\r\nrc = qed_sb_update_sb_idx(sb_info);\r\nDP_VERBOSE(p_hwfn->cdev, NETIF_MSG_INTR,\r\n"Interrupt indices: 0x%08x --> 0x%08x\n",\r\ntmp_index, sb_info->sb_ack);\r\n}\r\nif (!sb_attn || !sb_attn->sb_attn) {\r\nDP_ERR(p_hwfn->cdev,\r\n"Attentions Status block is NULL - cannot check for new attentions!\n");\r\n} else {\r\nu16 tmp_index = sb_attn->index;\r\nrc |= qed_attn_update_idx(p_hwfn, sb_attn);\r\nDP_VERBOSE(p_hwfn->cdev, NETIF_MSG_INTR,\r\n"Attention indices: 0x%08x --> 0x%08x\n",\r\ntmp_index, sb_attn->index);\r\n}\r\nif (!(rc & QED_SB_EVENT_MASK)) {\r\nqed_sb_ack(sb_info, IGU_INT_ENABLE, 1);\r\nreturn;\r\n}\r\nif (!p_hwfn->p_dpc_ptt) {\r\nDP_NOTICE(p_hwfn->cdev, "Failed to allocate PTT\n");\r\nqed_sb_ack(sb_info, IGU_INT_ENABLE, 1);\r\nreturn;\r\n}\r\nif (rc & QED_SB_ATT_IDX)\r\nqed_int_attentions(p_hwfn);\r\nif (rc & QED_SB_IDX) {\r\nint pi;\r\nfor (pi = 0; pi < arr_size; pi++) {\r\npi_info = &p_hwfn->p_sp_sb->pi_info_arr[pi];\r\nif (pi_info->comp_cb)\r\npi_info->comp_cb(p_hwfn, pi_info->cookie);\r\n}\r\n}\r\nif (sb_attn && (rc & QED_SB_ATT_IDX))\r\nqed_sb_ack_attn(p_hwfn, sb_info->igu_addr, sb_attn->index);\r\nqed_sb_ack(sb_info, IGU_INT_ENABLE, 1);\r\n}\r\nstatic void qed_int_sb_attn_free(struct qed_hwfn *p_hwfn)\r\n{\r\nstruct qed_sb_attn_info *p_sb = p_hwfn->p_sb_attn;\r\nif (!p_sb)\r\nreturn;\r\nif (p_sb->sb_attn)\r\ndma_free_coherent(&p_hwfn->cdev->pdev->dev,\r\nSB_ATTN_ALIGNED_SIZE(p_hwfn),\r\np_sb->sb_attn, p_sb->sb_phys);\r\nkfree(p_sb);\r\np_hwfn->p_sb_attn = NULL;\r\n}\r\nstatic void qed_int_sb_attn_setup(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt)\r\n{\r\nstruct qed_sb_attn_info *sb_info = p_hwfn->p_sb_attn;\r\nmemset(sb_info->sb_attn, 0, sizeof(*sb_info->sb_attn));\r\nsb_info->index = 0;\r\nsb_info->known_attn = 0;\r\nqed_wr(p_hwfn, p_ptt, IGU_REG_ATTN_MSG_ADDR_L,\r\nlower_32_bits(p_hwfn->p_sb_attn->sb_phys));\r\nqed_wr(p_hwfn, p_ptt, IGU_REG_ATTN_MSG_ADDR_H,\r\nupper_32_bits(p_hwfn->p_sb_attn->sb_phys));\r\n}\r\nstatic void qed_int_sb_attn_init(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nvoid *sb_virt_addr, dma_addr_t sb_phy_addr)\r\n{\r\nstruct qed_sb_attn_info *sb_info = p_hwfn->p_sb_attn;\r\nint i, j, k;\r\nsb_info->sb_attn = sb_virt_addr;\r\nsb_info->sb_phys = sb_phy_addr;\r\nsb_info->p_aeu_desc = aeu_descs;\r\nmemset(sb_info->parity_mask, 0, sizeof(u32) * NUM_ATTN_REGS);\r\nfor (i = 0; i < NUM_ATTN_REGS; i++) {\r\nfor (j = 0, k = 0; k < 32; j++) {\r\nstruct aeu_invert_reg_bit *p_aeu;\r\np_aeu = &aeu_descs[i].bits[j];\r\nif (qed_int_is_parity_flag(p_hwfn, p_aeu))\r\nsb_info->parity_mask[i] |= 1 << k;\r\nk += ATTENTION_LENGTH(p_aeu->flags);\r\n}\r\nDP_VERBOSE(p_hwfn, NETIF_MSG_INTR,\r\n"Attn Mask [Reg %d]: 0x%08x\n",\r\ni, sb_info->parity_mask[i]);\r\n}\r\nsb_info->mfw_attn_addr = (p_hwfn->rel_pf_id << 3) +\r\nMISC_REG_AEU_GENERAL_ATTN_0;\r\nqed_int_sb_attn_setup(p_hwfn, p_ptt);\r\n}\r\nstatic int qed_int_sb_attn_alloc(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt)\r\n{\r\nstruct qed_dev *cdev = p_hwfn->cdev;\r\nstruct qed_sb_attn_info *p_sb;\r\ndma_addr_t p_phys = 0;\r\nvoid *p_virt;\r\np_sb = kmalloc(sizeof(*p_sb), GFP_KERNEL);\r\nif (!p_sb)\r\nreturn -ENOMEM;\r\np_virt = dma_alloc_coherent(&cdev->pdev->dev,\r\nSB_ATTN_ALIGNED_SIZE(p_hwfn),\r\n&p_phys, GFP_KERNEL);\r\nif (!p_virt) {\r\nkfree(p_sb);\r\nreturn -ENOMEM;\r\n}\r\np_hwfn->p_sb_attn = p_sb;\r\nqed_int_sb_attn_init(p_hwfn, p_ptt, p_virt, p_phys);\r\nreturn 0;\r\n}\r\nvoid qed_init_cau_sb_entry(struct qed_hwfn *p_hwfn,\r\nstruct cau_sb_entry *p_sb_entry,\r\nu8 pf_id, u16 vf_number, u8 vf_valid)\r\n{\r\nstruct qed_dev *cdev = p_hwfn->cdev;\r\nu32 cau_state;\r\nu8 timer_res;\r\nmemset(p_sb_entry, 0, sizeof(*p_sb_entry));\r\nSET_FIELD(p_sb_entry->params, CAU_SB_ENTRY_PF_NUMBER, pf_id);\r\nSET_FIELD(p_sb_entry->params, CAU_SB_ENTRY_VF_NUMBER, vf_number);\r\nSET_FIELD(p_sb_entry->params, CAU_SB_ENTRY_VF_VALID, vf_valid);\r\nSET_FIELD(p_sb_entry->params, CAU_SB_ENTRY_SB_TIMESET0, 0x7F);\r\nSET_FIELD(p_sb_entry->params, CAU_SB_ENTRY_SB_TIMESET1, 0x7F);\r\ncau_state = CAU_HC_DISABLE_STATE;\r\nif (cdev->int_coalescing_mode == QED_COAL_MODE_ENABLE) {\r\ncau_state = CAU_HC_ENABLE_STATE;\r\nif (!cdev->rx_coalesce_usecs)\r\ncdev->rx_coalesce_usecs = QED_CAU_DEF_RX_USECS;\r\nif (!cdev->tx_coalesce_usecs)\r\ncdev->tx_coalesce_usecs = QED_CAU_DEF_TX_USECS;\r\n}\r\nif (cdev->rx_coalesce_usecs <= 0x7F)\r\ntimer_res = 0;\r\nelse if (cdev->rx_coalesce_usecs <= 0xFF)\r\ntimer_res = 1;\r\nelse\r\ntimer_res = 2;\r\nSET_FIELD(p_sb_entry->params, CAU_SB_ENTRY_TIMER_RES0, timer_res);\r\nif (cdev->tx_coalesce_usecs <= 0x7F)\r\ntimer_res = 0;\r\nelse if (cdev->tx_coalesce_usecs <= 0xFF)\r\ntimer_res = 1;\r\nelse\r\ntimer_res = 2;\r\nSET_FIELD(p_sb_entry->params, CAU_SB_ENTRY_TIMER_RES1, timer_res);\r\nSET_FIELD(p_sb_entry->data, CAU_SB_ENTRY_STATE0, cau_state);\r\nSET_FIELD(p_sb_entry->data, CAU_SB_ENTRY_STATE1, cau_state);\r\n}\r\nstatic void qed_int_cau_conf_pi(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu16 igu_sb_id,\r\nu32 pi_index,\r\nenum qed_coalescing_fsm coalescing_fsm,\r\nu8 timeset)\r\n{\r\nstruct cau_pi_entry pi_entry;\r\nu32 sb_offset, pi_offset;\r\nif (IS_VF(p_hwfn->cdev))\r\nreturn;\r\nsb_offset = igu_sb_id * PIS_PER_SB;\r\nmemset(&pi_entry, 0, sizeof(struct cau_pi_entry));\r\nSET_FIELD(pi_entry.prod, CAU_PI_ENTRY_PI_TIMESET, timeset);\r\nif (coalescing_fsm == QED_COAL_RX_STATE_MACHINE)\r\nSET_FIELD(pi_entry.prod, CAU_PI_ENTRY_FSM_SEL, 0);\r\nelse\r\nSET_FIELD(pi_entry.prod, CAU_PI_ENTRY_FSM_SEL, 1);\r\npi_offset = sb_offset + pi_index;\r\nif (p_hwfn->hw_init_done) {\r\nqed_wr(p_hwfn, p_ptt,\r\nCAU_REG_PI_MEMORY + pi_offset * sizeof(u32),\r\n*((u32 *)&(pi_entry)));\r\n} else {\r\nSTORE_RT_REG(p_hwfn,\r\nCAU_REG_PI_MEMORY_RT_OFFSET + pi_offset,\r\n*((u32 *)&(pi_entry)));\r\n}\r\n}\r\nvoid qed_int_cau_conf_sb(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\ndma_addr_t sb_phys,\r\nu16 igu_sb_id, u16 vf_number, u8 vf_valid)\r\n{\r\nstruct cau_sb_entry sb_entry;\r\nqed_init_cau_sb_entry(p_hwfn, &sb_entry, p_hwfn->rel_pf_id,\r\nvf_number, vf_valid);\r\nif (p_hwfn->hw_init_done) {\r\nu64 phys_addr = (u64)sb_phys;\r\nqed_dmae_host2grc(p_hwfn, p_ptt, (u64)(uintptr_t)&phys_addr,\r\nCAU_REG_SB_ADDR_MEMORY +\r\nigu_sb_id * sizeof(u64), 2, 0);\r\nqed_dmae_host2grc(p_hwfn, p_ptt, (u64)(uintptr_t)&sb_entry,\r\nCAU_REG_SB_VAR_MEMORY +\r\nigu_sb_id * sizeof(u64), 2, 0);\r\n} else {\r\nSTORE_RT_REG_AGG(p_hwfn,\r\nCAU_REG_SB_ADDR_MEMORY_RT_OFFSET +\r\nigu_sb_id * 2,\r\nsb_phys);\r\nSTORE_RT_REG_AGG(p_hwfn,\r\nCAU_REG_SB_VAR_MEMORY_RT_OFFSET +\r\nigu_sb_id * 2,\r\nsb_entry);\r\n}\r\nif (p_hwfn->cdev->int_coalescing_mode == QED_COAL_MODE_ENABLE) {\r\nu8 num_tc = p_hwfn->hw_info.num_hw_tc;\r\nu8 timeset, timer_res;\r\nu8 i;\r\nif (p_hwfn->cdev->rx_coalesce_usecs <= 0x7F)\r\ntimer_res = 0;\r\nelse if (p_hwfn->cdev->rx_coalesce_usecs <= 0xFF)\r\ntimer_res = 1;\r\nelse\r\ntimer_res = 2;\r\ntimeset = (u8)(p_hwfn->cdev->rx_coalesce_usecs >> timer_res);\r\nqed_int_cau_conf_pi(p_hwfn, p_ptt, igu_sb_id, RX_PI,\r\nQED_COAL_RX_STATE_MACHINE, timeset);\r\nif (p_hwfn->cdev->tx_coalesce_usecs <= 0x7F)\r\ntimer_res = 0;\r\nelse if (p_hwfn->cdev->tx_coalesce_usecs <= 0xFF)\r\ntimer_res = 1;\r\nelse\r\ntimer_res = 2;\r\ntimeset = (u8)(p_hwfn->cdev->tx_coalesce_usecs >> timer_res);\r\nfor (i = 0; i < num_tc; i++) {\r\nqed_int_cau_conf_pi(p_hwfn, p_ptt,\r\nigu_sb_id, TX_PI(i),\r\nQED_COAL_TX_STATE_MACHINE,\r\ntimeset);\r\n}\r\n}\r\n}\r\nvoid qed_int_sb_setup(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt, struct qed_sb_info *sb_info)\r\n{\r\nsb_info->sb_ack = 0;\r\nmemset(sb_info->sb_virt, 0, sizeof(*sb_info->sb_virt));\r\nif (IS_PF(p_hwfn->cdev))\r\nqed_int_cau_conf_sb(p_hwfn, p_ptt, sb_info->sb_phys,\r\nsb_info->igu_sb_id, 0, 0);\r\n}\r\nstruct qed_igu_block *qed_get_igu_free_sb(struct qed_hwfn *p_hwfn, bool b_is_pf)\r\n{\r\nstruct qed_igu_block *p_block;\r\nu16 igu_id;\r\nfor (igu_id = 0; igu_id < QED_MAPPING_MEMORY_SIZE(p_hwfn->cdev);\r\nigu_id++) {\r\np_block = &p_hwfn->hw_info.p_igu_info->entry[igu_id];\r\nif (!(p_block->status & QED_IGU_STATUS_VALID) ||\r\n!(p_block->status & QED_IGU_STATUS_FREE))\r\ncontinue;\r\nif (!!(p_block->status & QED_IGU_STATUS_PF) == b_is_pf)\r\nreturn p_block;\r\n}\r\nreturn NULL;\r\n}\r\nstatic u16 qed_get_pf_igu_sb_id(struct qed_hwfn *p_hwfn, u16 vector_id)\r\n{\r\nstruct qed_igu_block *p_block;\r\nu16 igu_id;\r\nfor (igu_id = 0; igu_id < QED_MAPPING_MEMORY_SIZE(p_hwfn->cdev);\r\nigu_id++) {\r\np_block = &p_hwfn->hw_info.p_igu_info->entry[igu_id];\r\nif (!(p_block->status & QED_IGU_STATUS_VALID) ||\r\n!p_block->is_pf ||\r\np_block->vector_number != vector_id)\r\ncontinue;\r\nreturn igu_id;\r\n}\r\nreturn QED_SB_INVALID_IDX;\r\n}\r\nu16 qed_get_igu_sb_id(struct qed_hwfn *p_hwfn, u16 sb_id)\r\n{\r\nu16 igu_sb_id;\r\nif (sb_id == QED_SP_SB_ID)\r\nigu_sb_id = p_hwfn->hw_info.p_igu_info->igu_dsb_id;\r\nelse if (IS_PF(p_hwfn->cdev))\r\nigu_sb_id = qed_get_pf_igu_sb_id(p_hwfn, sb_id + 1);\r\nelse\r\nigu_sb_id = qed_vf_get_igu_sb_id(p_hwfn, sb_id);\r\nif (sb_id == QED_SP_SB_ID)\r\nDP_VERBOSE(p_hwfn, NETIF_MSG_INTR,\r\n"Slowpath SB index in IGU is 0x%04x\n", igu_sb_id);\r\nelse\r\nDP_VERBOSE(p_hwfn, NETIF_MSG_INTR,\r\n"SB [%04x] <--> IGU SB [%04x]\n", sb_id, igu_sb_id);\r\nreturn igu_sb_id;\r\n}\r\nint qed_int_sb_init(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nstruct qed_sb_info *sb_info,\r\nvoid *sb_virt_addr, dma_addr_t sb_phy_addr, u16 sb_id)\r\n{\r\nsb_info->sb_virt = sb_virt_addr;\r\nsb_info->sb_phys = sb_phy_addr;\r\nsb_info->igu_sb_id = qed_get_igu_sb_id(p_hwfn, sb_id);\r\nif (sb_id != QED_SP_SB_ID) {\r\nif (IS_PF(p_hwfn->cdev)) {\r\nstruct qed_igu_info *p_info;\r\nstruct qed_igu_block *p_block;\r\np_info = p_hwfn->hw_info.p_igu_info;\r\np_block = &p_info->entry[sb_info->igu_sb_id];\r\np_block->sb_info = sb_info;\r\np_block->status &= ~QED_IGU_STATUS_FREE;\r\np_info->usage.free_cnt--;\r\n} else {\r\nqed_vf_set_sb_info(p_hwfn, sb_id, sb_info);\r\n}\r\n}\r\nsb_info->cdev = p_hwfn->cdev;\r\nif (IS_PF(p_hwfn->cdev)) {\r\nsb_info->igu_addr = (u8 __iomem *)p_hwfn->regview +\r\nGTT_BAR0_MAP_REG_IGU_CMD +\r\n(sb_info->igu_sb_id << 3);\r\n} else {\r\nsb_info->igu_addr = (u8 __iomem *)p_hwfn->regview +\r\nPXP_VF_BAR0_START_IGU +\r\n((IGU_CMD_INT_ACK_BASE +\r\nsb_info->igu_sb_id) << 3);\r\n}\r\nsb_info->flags |= QED_SB_INFO_INIT;\r\nqed_int_sb_setup(p_hwfn, p_ptt, sb_info);\r\nreturn 0;\r\n}\r\nint qed_int_sb_release(struct qed_hwfn *p_hwfn,\r\nstruct qed_sb_info *sb_info, u16 sb_id)\r\n{\r\nstruct qed_igu_block *p_block;\r\nstruct qed_igu_info *p_info;\r\nif (!sb_info)\r\nreturn 0;\r\nsb_info->sb_ack = 0;\r\nmemset(sb_info->sb_virt, 0, sizeof(*sb_info->sb_virt));\r\nif (IS_VF(p_hwfn->cdev)) {\r\nqed_vf_set_sb_info(p_hwfn, sb_id, NULL);\r\nreturn 0;\r\n}\r\np_info = p_hwfn->hw_info.p_igu_info;\r\np_block = &p_info->entry[sb_info->igu_sb_id];\r\nif (!p_block->vector_number) {\r\nDP_ERR(p_hwfn, "Do Not free sp sb using this function");\r\nreturn -EINVAL;\r\n}\r\np_block->sb_info = NULL;\r\np_block->status |= QED_IGU_STATUS_FREE;\r\np_info->usage.free_cnt++;\r\nreturn 0;\r\n}\r\nstatic void qed_int_sp_sb_free(struct qed_hwfn *p_hwfn)\r\n{\r\nstruct qed_sb_sp_info *p_sb = p_hwfn->p_sp_sb;\r\nif (!p_sb)\r\nreturn;\r\nif (p_sb->sb_info.sb_virt)\r\ndma_free_coherent(&p_hwfn->cdev->pdev->dev,\r\nSB_ALIGNED_SIZE(p_hwfn),\r\np_sb->sb_info.sb_virt,\r\np_sb->sb_info.sb_phys);\r\nkfree(p_sb);\r\np_hwfn->p_sp_sb = NULL;\r\n}\r\nstatic int qed_int_sp_sb_alloc(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt)\r\n{\r\nstruct qed_sb_sp_info *p_sb;\r\ndma_addr_t p_phys = 0;\r\nvoid *p_virt;\r\np_sb = kmalloc(sizeof(*p_sb), GFP_KERNEL);\r\nif (!p_sb)\r\nreturn -ENOMEM;\r\np_virt = dma_alloc_coherent(&p_hwfn->cdev->pdev->dev,\r\nSB_ALIGNED_SIZE(p_hwfn),\r\n&p_phys, GFP_KERNEL);\r\nif (!p_virt) {\r\nkfree(p_sb);\r\nreturn -ENOMEM;\r\n}\r\np_hwfn->p_sp_sb = p_sb;\r\nqed_int_sb_init(p_hwfn, p_ptt, &p_sb->sb_info, p_virt,\r\np_phys, QED_SP_SB_ID);\r\nmemset(p_sb->pi_info_arr, 0, sizeof(p_sb->pi_info_arr));\r\nreturn 0;\r\n}\r\nint qed_int_register_cb(struct qed_hwfn *p_hwfn,\r\nqed_int_comp_cb_t comp_cb,\r\nvoid *cookie, u8 *sb_idx, __le16 **p_fw_cons)\r\n{\r\nstruct qed_sb_sp_info *p_sp_sb = p_hwfn->p_sp_sb;\r\nint rc = -ENOMEM;\r\nu8 pi;\r\nfor (pi = 0; pi < ARRAY_SIZE(p_sp_sb->pi_info_arr); pi++) {\r\nif (p_sp_sb->pi_info_arr[pi].comp_cb)\r\ncontinue;\r\np_sp_sb->pi_info_arr[pi].comp_cb = comp_cb;\r\np_sp_sb->pi_info_arr[pi].cookie = cookie;\r\n*sb_idx = pi;\r\n*p_fw_cons = &p_sp_sb->sb_info.sb_virt->pi_array[pi];\r\nrc = 0;\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nint qed_int_unregister_cb(struct qed_hwfn *p_hwfn, u8 pi)\r\n{\r\nstruct qed_sb_sp_info *p_sp_sb = p_hwfn->p_sp_sb;\r\nif (p_sp_sb->pi_info_arr[pi].comp_cb == NULL)\r\nreturn -ENOMEM;\r\np_sp_sb->pi_info_arr[pi].comp_cb = NULL;\r\np_sp_sb->pi_info_arr[pi].cookie = NULL;\r\nreturn 0;\r\n}\r\nu16 qed_int_get_sp_sb_id(struct qed_hwfn *p_hwfn)\r\n{\r\nreturn p_hwfn->p_sp_sb->sb_info.igu_sb_id;\r\n}\r\nvoid qed_int_igu_enable_int(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt, enum qed_int_mode int_mode)\r\n{\r\nu32 igu_pf_conf = IGU_PF_CONF_FUNC_EN | IGU_PF_CONF_ATTN_BIT_EN;\r\np_hwfn->cdev->int_mode = int_mode;\r\nswitch (p_hwfn->cdev->int_mode) {\r\ncase QED_INT_MODE_INTA:\r\nigu_pf_conf |= IGU_PF_CONF_INT_LINE_EN;\r\nigu_pf_conf |= IGU_PF_CONF_SINGLE_ISR_EN;\r\nbreak;\r\ncase QED_INT_MODE_MSI:\r\nigu_pf_conf |= IGU_PF_CONF_MSI_MSIX_EN;\r\nigu_pf_conf |= IGU_PF_CONF_SINGLE_ISR_EN;\r\nbreak;\r\ncase QED_INT_MODE_MSIX:\r\nigu_pf_conf |= IGU_PF_CONF_MSI_MSIX_EN;\r\nbreak;\r\ncase QED_INT_MODE_POLL:\r\nbreak;\r\n}\r\nqed_wr(p_hwfn, p_ptt, IGU_REG_PF_CONFIGURATION, igu_pf_conf);\r\n}\r\nstatic void qed_int_igu_enable_attn(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt)\r\n{\r\nqed_wr(p_hwfn, p_ptt, IGU_REG_ATTENTION_ENABLE, 0);\r\nqed_wr(p_hwfn, p_ptt, IGU_REG_LEADING_EDGE_LATCH, 0xfff);\r\nqed_wr(p_hwfn, p_ptt, IGU_REG_TRAILING_EDGE_LATCH, 0xfff);\r\nqed_wr(p_hwfn, p_ptt, IGU_REG_ATTENTION_ENABLE, 0xfff);\r\nmmiowb();\r\nqed_wr(p_hwfn, p_ptt, MISC_REG_AEU_MASK_ATTN_IGU, 0xff);\r\n}\r\nint\r\nqed_int_igu_enable(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt, enum qed_int_mode int_mode)\r\n{\r\nint rc = 0;\r\nqed_int_igu_enable_attn(p_hwfn, p_ptt);\r\nif ((int_mode != QED_INT_MODE_INTA) || IS_LEAD_HWFN(p_hwfn)) {\r\nrc = qed_slowpath_irq_req(p_hwfn);\r\nif (rc) {\r\nDP_NOTICE(p_hwfn, "Slowpath IRQ request failed\n");\r\nreturn -EINVAL;\r\n}\r\np_hwfn->b_int_requested = true;\r\n}\r\nqed_int_igu_enable_int(p_hwfn, p_ptt, int_mode);\r\np_hwfn->b_int_enabled = 1;\r\nreturn rc;\r\n}\r\nvoid qed_int_igu_disable_int(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt)\r\n{\r\np_hwfn->b_int_enabled = 0;\r\nif (IS_VF(p_hwfn->cdev))\r\nreturn;\r\nqed_wr(p_hwfn, p_ptt, IGU_REG_PF_CONFIGURATION, 0);\r\n}\r\nstatic void qed_int_igu_cleanup_sb(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu16 igu_sb_id,\r\nbool cleanup_set, u16 opaque_fid)\r\n{\r\nu32 cmd_ctrl = 0, val = 0, sb_bit = 0, sb_bit_addr = 0, data = 0;\r\nu32 pxp_addr = IGU_CMD_INT_ACK_BASE + igu_sb_id;\r\nu32 sleep_cnt = IGU_CLEANUP_SLEEP_LENGTH;\r\nSET_FIELD(data, IGU_CLEANUP_CLEANUP_SET, cleanup_set ? 1 : 0);\r\nSET_FIELD(data, IGU_CLEANUP_CLEANUP_TYPE, 0);\r\nSET_FIELD(data, IGU_CLEANUP_COMMAND_TYPE, IGU_COMMAND_TYPE_SET);\r\nSET_FIELD(cmd_ctrl, IGU_CTRL_REG_PXP_ADDR, pxp_addr);\r\nSET_FIELD(cmd_ctrl, IGU_CTRL_REG_FID, opaque_fid);\r\nSET_FIELD(cmd_ctrl, IGU_CTRL_REG_TYPE, IGU_CTRL_CMD_TYPE_WR);\r\nqed_wr(p_hwfn, p_ptt, IGU_REG_COMMAND_REG_32LSB_DATA, data);\r\nbarrier();\r\nqed_wr(p_hwfn, p_ptt, IGU_REG_COMMAND_REG_CTRL, cmd_ctrl);\r\nmmiowb();\r\nsb_bit = 1 << (igu_sb_id % 32);\r\nsb_bit_addr = igu_sb_id / 32 * sizeof(u32);\r\nsb_bit_addr += IGU_REG_CLEANUP_STATUS_0;\r\ndo {\r\nval = qed_rd(p_hwfn, p_ptt, sb_bit_addr);\r\nif ((val & sb_bit) == (cleanup_set ? sb_bit : 0))\r\nbreak;\r\nusleep_range(5000, 10000);\r\n} while (--sleep_cnt);\r\nif (!sleep_cnt)\r\nDP_NOTICE(p_hwfn,\r\n"Timeout waiting for clear status 0x%08x [for sb %d]\n",\r\nval, igu_sb_id);\r\n}\r\nvoid qed_int_igu_init_pure_rt_single(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu16 igu_sb_id, u16 opaque, bool b_set)\r\n{\r\nstruct qed_igu_block *p_block;\r\nint pi, i;\r\np_block = &p_hwfn->hw_info.p_igu_info->entry[igu_sb_id];\r\nDP_VERBOSE(p_hwfn, NETIF_MSG_INTR,\r\n"Cleaning SB [%04x]: func_id= %d is_pf = %d vector_num = 0x%0x\n",\r\nigu_sb_id,\r\np_block->function_id,\r\np_block->is_pf, p_block->vector_number);\r\nif (b_set)\r\nqed_int_igu_cleanup_sb(p_hwfn, p_ptt, igu_sb_id, 1, opaque);\r\nqed_int_igu_cleanup_sb(p_hwfn, p_ptt, igu_sb_id, 0, opaque);\r\nfor (i = 0; i < IGU_CLEANUP_SLEEP_LENGTH; i++) {\r\nu32 val;\r\nval = qed_rd(p_hwfn, p_ptt,\r\nIGU_REG_WRITE_DONE_PENDING +\r\n((igu_sb_id / 32) * 4));\r\nif (val & BIT((igu_sb_id % 32)))\r\nusleep_range(10, 20);\r\nelse\r\nbreak;\r\n}\r\nif (i == IGU_CLEANUP_SLEEP_LENGTH)\r\nDP_NOTICE(p_hwfn,\r\n"Failed SB[0x%08x] still appearing in WRITE_DONE_PENDING\n",\r\nigu_sb_id);\r\nfor (pi = 0; pi < 12; pi++)\r\nqed_wr(p_hwfn, p_ptt,\r\nCAU_REG_PI_MEMORY + (igu_sb_id * 12 + pi) * 4, 0);\r\n}\r\nvoid qed_int_igu_init_pure_rt(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nbool b_set, bool b_slowpath)\r\n{\r\nstruct qed_igu_info *p_info = p_hwfn->hw_info.p_igu_info;\r\nstruct qed_igu_block *p_block;\r\nu16 igu_sb_id = 0;\r\nu32 val = 0;\r\nval = qed_rd(p_hwfn, p_ptt, IGU_REG_BLOCK_CONFIGURATION);\r\nval |= IGU_REG_BLOCK_CONFIGURATION_VF_CLEANUP_EN;\r\nval &= ~IGU_REG_BLOCK_CONFIGURATION_PXP_TPH_INTERFACE_EN;\r\nqed_wr(p_hwfn, p_ptt, IGU_REG_BLOCK_CONFIGURATION, val);\r\nfor (igu_sb_id = 0;\r\nigu_sb_id < QED_MAPPING_MEMORY_SIZE(p_hwfn->cdev); igu_sb_id++) {\r\np_block = &p_info->entry[igu_sb_id];\r\nif (!(p_block->status & QED_IGU_STATUS_VALID) ||\r\n!p_block->is_pf ||\r\n(p_block->status & QED_IGU_STATUS_DSB))\r\ncontinue;\r\nqed_int_igu_init_pure_rt_single(p_hwfn, p_ptt, igu_sb_id,\r\np_hwfn->hw_info.opaque_fid,\r\nb_set);\r\n}\r\nif (b_slowpath)\r\nqed_int_igu_init_pure_rt_single(p_hwfn, p_ptt,\r\np_info->igu_dsb_id,\r\np_hwfn->hw_info.opaque_fid,\r\nb_set);\r\n}\r\nint qed_int_igu_reset_cam(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt)\r\n{\r\nstruct qed_igu_info *p_info = p_hwfn->hw_info.p_igu_info;\r\nstruct qed_igu_block *p_block;\r\nint pf_sbs, vf_sbs;\r\nu16 igu_sb_id;\r\nu32 val, rval;\r\nif (!RESC_NUM(p_hwfn, QED_SB)) {\r\np_info->b_allow_pf_vf_change = false;\r\n} else {\r\np_info->b_allow_pf_vf_change = true;\r\nif (p_info->usage.cnt != RESC_NUM(p_hwfn, QED_SB) - 1) {\r\nDP_INFO(p_hwfn,\r\n"MFW notifies of 0x%04x PF SBs; IGU indicates of only 0x%04x\n",\r\nRESC_NUM(p_hwfn, QED_SB) - 1,\r\np_info->usage.cnt);\r\np_info->usage.cnt = RESC_NUM(p_hwfn, QED_SB) - 1;\r\n}\r\nif (IS_PF_SRIOV(p_hwfn)) {\r\nu16 vfs = p_hwfn->cdev->p_iov_info->total_vfs;\r\nif (vfs != p_info->usage.iov_cnt)\r\nDP_VERBOSE(p_hwfn,\r\nNETIF_MSG_INTR,\r\n"0x%04x VF SBs in IGU CAM != PCI configuration 0x%04x\n",\r\np_info->usage.iov_cnt, vfs);\r\nif (vfs > p_info->usage.free_cnt +\r\np_info->usage.free_cnt_iov - p_info->usage.cnt) {\r\nDP_NOTICE(p_hwfn,\r\n"Not enough SBs for VFs - 0x%04x SBs, from which %04x PFs and %04x are required\n",\r\np_info->usage.free_cnt +\r\np_info->usage.free_cnt_iov,\r\np_info->usage.cnt, vfs);\r\nreturn -EINVAL;\r\n}\r\np_info->usage.iov_cnt = vfs;\r\n}\r\n}\r\np_info->usage.free_cnt = p_info->usage.cnt;\r\np_info->usage.free_cnt_iov = p_info->usage.iov_cnt;\r\np_info->usage.orig = p_info->usage.cnt;\r\np_info->usage.iov_orig = p_info->usage.iov_cnt;\r\npf_sbs = p_info->usage.cnt;\r\nvf_sbs = p_info->usage.iov_cnt;\r\nfor (igu_sb_id = p_info->igu_dsb_id;\r\nigu_sb_id < QED_MAPPING_MEMORY_SIZE(p_hwfn->cdev); igu_sb_id++) {\r\np_block = &p_info->entry[igu_sb_id];\r\nval = 0;\r\nif (!(p_block->status & QED_IGU_STATUS_VALID))\r\ncontinue;\r\nif (p_block->status & QED_IGU_STATUS_DSB) {\r\np_block->function_id = p_hwfn->rel_pf_id;\r\np_block->is_pf = 1;\r\np_block->vector_number = 0;\r\np_block->status = QED_IGU_STATUS_VALID |\r\nQED_IGU_STATUS_PF |\r\nQED_IGU_STATUS_DSB;\r\n} else if (pf_sbs) {\r\npf_sbs--;\r\np_block->function_id = p_hwfn->rel_pf_id;\r\np_block->is_pf = 1;\r\np_block->vector_number = p_info->usage.cnt - pf_sbs;\r\np_block->status = QED_IGU_STATUS_VALID |\r\nQED_IGU_STATUS_PF |\r\nQED_IGU_STATUS_FREE;\r\n} else if (vf_sbs) {\r\np_block->function_id =\r\np_hwfn->cdev->p_iov_info->first_vf_in_pf +\r\np_info->usage.iov_cnt - vf_sbs;\r\np_block->is_pf = 0;\r\np_block->vector_number = 0;\r\np_block->status = QED_IGU_STATUS_VALID |\r\nQED_IGU_STATUS_FREE;\r\nvf_sbs--;\r\n} else {\r\np_block->function_id = 0;\r\np_block->is_pf = 0;\r\np_block->vector_number = 0;\r\n}\r\nSET_FIELD(val, IGU_MAPPING_LINE_FUNCTION_NUMBER,\r\np_block->function_id);\r\nSET_FIELD(val, IGU_MAPPING_LINE_PF_VALID, p_block->is_pf);\r\nSET_FIELD(val, IGU_MAPPING_LINE_VECTOR_NUMBER,\r\np_block->vector_number);\r\nSET_FIELD(val, IGU_MAPPING_LINE_VALID, p_block->is_pf);\r\nrval = qed_rd(p_hwfn, p_ptt,\r\nIGU_REG_MAPPING_MEMORY + sizeof(u32) * igu_sb_id);\r\nif (rval != val) {\r\nqed_wr(p_hwfn, p_ptt,\r\nIGU_REG_MAPPING_MEMORY +\r\nsizeof(u32) * igu_sb_id, val);\r\nDP_VERBOSE(p_hwfn,\r\nNETIF_MSG_INTR,\r\n"IGU reset: [SB 0x%04x] func_id = %d is_pf = %d vector_num = 0x%x [%08x -> %08x]\n",\r\nigu_sb_id,\r\np_block->function_id,\r\np_block->is_pf,\r\np_block->vector_number, rval, val);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void qed_int_igu_read_cam_block(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt, u16 igu_sb_id)\r\n{\r\nu32 val = qed_rd(p_hwfn, p_ptt,\r\nIGU_REG_MAPPING_MEMORY + sizeof(u32) * igu_sb_id);\r\nstruct qed_igu_block *p_block;\r\np_block = &p_hwfn->hw_info.p_igu_info->entry[igu_sb_id];\r\np_block->function_id = GET_FIELD(val, IGU_MAPPING_LINE_FUNCTION_NUMBER);\r\np_block->is_pf = GET_FIELD(val, IGU_MAPPING_LINE_PF_VALID);\r\np_block->vector_number = GET_FIELD(val, IGU_MAPPING_LINE_VECTOR_NUMBER);\r\np_block->igu_sb_id = igu_sb_id;\r\n}\r\nint qed_int_igu_read_cam(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt)\r\n{\r\nstruct qed_igu_info *p_igu_info;\r\nstruct qed_igu_block *p_block;\r\nu32 min_vf = 0, max_vf = 0;\r\nu16 igu_sb_id;\r\np_hwfn->hw_info.p_igu_info = kzalloc(sizeof(*p_igu_info), GFP_KERNEL);\r\nif (!p_hwfn->hw_info.p_igu_info)\r\nreturn -ENOMEM;\r\np_igu_info = p_hwfn->hw_info.p_igu_info;\r\np_igu_info->igu_dsb_id = QED_SB_INVALID_IDX;\r\nif (p_hwfn->cdev->p_iov_info) {\r\nstruct qed_hw_sriov_info *p_iov = p_hwfn->cdev->p_iov_info;\r\nmin_vf = p_iov->first_vf_in_pf;\r\nmax_vf = p_iov->first_vf_in_pf + p_iov->total_vfs;\r\n}\r\nfor (igu_sb_id = 0;\r\nigu_sb_id < QED_MAPPING_MEMORY_SIZE(p_hwfn->cdev); igu_sb_id++) {\r\nqed_int_igu_read_cam_block(p_hwfn, p_ptt, igu_sb_id);\r\np_block = &p_igu_info->entry[igu_sb_id];\r\nif ((p_block->is_pf) &&\r\n(p_block->function_id == p_hwfn->rel_pf_id)) {\r\np_block->status = QED_IGU_STATUS_PF |\r\nQED_IGU_STATUS_VALID |\r\nQED_IGU_STATUS_FREE;\r\nif (p_igu_info->igu_dsb_id != QED_SB_INVALID_IDX)\r\np_igu_info->usage.cnt++;\r\n} else if (!(p_block->is_pf) &&\r\n(p_block->function_id >= min_vf) &&\r\n(p_block->function_id < max_vf)) {\r\np_block->status = QED_IGU_STATUS_VALID |\r\nQED_IGU_STATUS_FREE;\r\nif (p_igu_info->igu_dsb_id != QED_SB_INVALID_IDX)\r\np_igu_info->usage.iov_cnt++;\r\n}\r\nif ((p_block->status & QED_IGU_STATUS_VALID) &&\r\n(p_igu_info->igu_dsb_id == QED_SB_INVALID_IDX)) {\r\np_igu_info->igu_dsb_id = igu_sb_id;\r\np_block->status |= QED_IGU_STATUS_DSB;\r\n}\r\nif ((p_block->status & QED_IGU_STATUS_VALID) ||\r\n(p_hwfn->abs_pf_id == 0)) {\r\nDP_VERBOSE(p_hwfn, NETIF_MSG_INTR,\r\n"IGU_BLOCK: [SB 0x%04x] func_id = %d is_pf = %d vector_num = 0x%x\n",\r\nigu_sb_id, p_block->function_id,\r\np_block->is_pf, p_block->vector_number);\r\n}\r\n}\r\nif (p_igu_info->igu_dsb_id == QED_SB_INVALID_IDX) {\r\nDP_NOTICE(p_hwfn,\r\n"IGU CAM returned invalid values igu_dsb_id=0x%x\n",\r\np_igu_info->igu_dsb_id);\r\nreturn -EINVAL;\r\n}\r\np_igu_info->usage.free_cnt = p_igu_info->usage.cnt;\r\np_igu_info->usage.free_cnt_iov = p_igu_info->usage.iov_cnt;\r\nDP_VERBOSE(p_hwfn, NETIF_MSG_INTR,\r\n"igu_dsb_id=0x%x, num Free SBs - PF: %04x VF: %04x [might change after resource allocation]\n",\r\np_igu_info->igu_dsb_id,\r\np_igu_info->usage.cnt, p_igu_info->usage.iov_cnt);\r\nreturn 0;\r\n}\r\nvoid qed_int_igu_init_rt(struct qed_hwfn *p_hwfn)\r\n{\r\nu32 igu_pf_conf = IGU_PF_CONF_FUNC_EN;\r\nSTORE_RT_REG(p_hwfn, IGU_REG_PF_CONFIGURATION_RT_OFFSET, igu_pf_conf);\r\n}\r\nu64 qed_int_igu_read_sisr_reg(struct qed_hwfn *p_hwfn)\r\n{\r\nu32 lsb_igu_cmd_addr = IGU_REG_SISR_MDPC_WMASK_LSB_UPPER -\r\nIGU_CMD_INT_ACK_BASE;\r\nu32 msb_igu_cmd_addr = IGU_REG_SISR_MDPC_WMASK_MSB_UPPER -\r\nIGU_CMD_INT_ACK_BASE;\r\nu32 intr_status_hi = 0, intr_status_lo = 0;\r\nu64 intr_status = 0;\r\nintr_status_lo = REG_RD(p_hwfn,\r\nGTT_BAR0_MAP_REG_IGU_CMD +\r\nlsb_igu_cmd_addr * 8);\r\nintr_status_hi = REG_RD(p_hwfn,\r\nGTT_BAR0_MAP_REG_IGU_CMD +\r\nmsb_igu_cmd_addr * 8);\r\nintr_status = ((u64)intr_status_hi << 32) + (u64)intr_status_lo;\r\nreturn intr_status;\r\n}\r\nstatic void qed_int_sp_dpc_setup(struct qed_hwfn *p_hwfn)\r\n{\r\ntasklet_init(p_hwfn->sp_dpc,\r\nqed_int_sp_dpc, (unsigned long)p_hwfn);\r\np_hwfn->b_sp_dpc_enabled = true;\r\n}\r\nstatic int qed_int_sp_dpc_alloc(struct qed_hwfn *p_hwfn)\r\n{\r\np_hwfn->sp_dpc = kmalloc(sizeof(*p_hwfn->sp_dpc), GFP_KERNEL);\r\nif (!p_hwfn->sp_dpc)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void qed_int_sp_dpc_free(struct qed_hwfn *p_hwfn)\r\n{\r\nkfree(p_hwfn->sp_dpc);\r\np_hwfn->sp_dpc = NULL;\r\n}\r\nint qed_int_alloc(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt)\r\n{\r\nint rc = 0;\r\nrc = qed_int_sp_dpc_alloc(p_hwfn);\r\nif (rc)\r\nreturn rc;\r\nrc = qed_int_sp_sb_alloc(p_hwfn, p_ptt);\r\nif (rc)\r\nreturn rc;\r\nrc = qed_int_sb_attn_alloc(p_hwfn, p_ptt);\r\nreturn rc;\r\n}\r\nvoid qed_int_free(struct qed_hwfn *p_hwfn)\r\n{\r\nqed_int_sp_sb_free(p_hwfn);\r\nqed_int_sb_attn_free(p_hwfn);\r\nqed_int_sp_dpc_free(p_hwfn);\r\n}\r\nvoid qed_int_setup(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt)\r\n{\r\nqed_int_sb_setup(p_hwfn, p_ptt, &p_hwfn->p_sp_sb->sb_info);\r\nqed_int_sb_attn_setup(p_hwfn, p_ptt);\r\nqed_int_sp_dpc_setup(p_hwfn);\r\n}\r\nvoid qed_int_get_num_sbs(struct qed_hwfn *p_hwfn,\r\nstruct qed_sb_cnt_info *p_sb_cnt_info)\r\n{\r\nstruct qed_igu_info *info = p_hwfn->hw_info.p_igu_info;\r\nif (!info || !p_sb_cnt_info)\r\nreturn;\r\nmemcpy(p_sb_cnt_info, &info->usage, sizeof(*p_sb_cnt_info));\r\n}\r\nvoid qed_int_disable_post_isr_release(struct qed_dev *cdev)\r\n{\r\nint i;\r\nfor_each_hwfn(cdev, i)\r\ncdev->hwfns[i].b_int_requested = false;\r\n}\r\nint qed_int_set_timer_res(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt,\r\nu8 timer_res, u16 sb_id, bool tx)\r\n{\r\nstruct cau_sb_entry sb_entry;\r\nint rc;\r\nif (!p_hwfn->hw_init_done) {\r\nDP_ERR(p_hwfn, "hardware not initialized yet\n");\r\nreturn -EINVAL;\r\n}\r\nrc = qed_dmae_grc2host(p_hwfn, p_ptt, CAU_REG_SB_VAR_MEMORY +\r\nsb_id * sizeof(u64),\r\n(u64)(uintptr_t)&sb_entry, 2, 0);\r\nif (rc) {\r\nDP_ERR(p_hwfn, "dmae_grc2host failed %d\n", rc);\r\nreturn rc;\r\n}\r\nif (tx)\r\nSET_FIELD(sb_entry.params, CAU_SB_ENTRY_TIMER_RES1, timer_res);\r\nelse\r\nSET_FIELD(sb_entry.params, CAU_SB_ENTRY_TIMER_RES0, timer_res);\r\nrc = qed_dmae_host2grc(p_hwfn, p_ptt,\r\n(u64)(uintptr_t)&sb_entry,\r\nCAU_REG_SB_VAR_MEMORY +\r\nsb_id * sizeof(u64), 2, 0);\r\nif (rc) {\r\nDP_ERR(p_hwfn, "dmae_host2grc failed %d\n", rc);\r\nreturn rc;\r\n}\r\nreturn rc;\r\n}
