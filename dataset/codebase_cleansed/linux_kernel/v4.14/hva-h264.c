static int hva_h264_fill_slice_header(struct hva_ctx *pctx,\r\nu8 *slice_header_addr,\r\nstruct hva_controls *ctrls,\r\nint frame_num,\r\nu16 *header_size,\r\nu16 *header_offset0,\r\nu16 *header_offset1,\r\nu16 *header_offset2)\r\n{\r\nstruct device *dev = ctx_to_dev(pctx);\r\nint cabac = V4L2_MPEG_VIDEO_H264_ENTROPY_MODE_CABAC;\r\nconst unsigned char slice_header[] = { 0x00, 0x00, 0x00, 0x01,\r\n0x41, 0x34, 0x07, 0x00};\r\nint idr_pic_id = frame_num % 2;\r\nenum hva_picture_coding_type type;\r\nu32 frame_order = frame_num % ctrls->gop_size;\r\nif (!(frame_num % ctrls->gop_size))\r\ntype = PICTURE_CODING_TYPE_I;\r\nelse\r\ntype = PICTURE_CODING_TYPE_P;\r\nmemcpy(slice_header_addr, slice_header, sizeof(slice_header));\r\n*header_size = 56;\r\n*header_offset0 = 40;\r\n*header_offset1 = 13;\r\n*header_offset2 = 0;\r\nif (type == PICTURE_CODING_TYPE_I) {\r\nslice_header_addr[4] = 0x65;\r\nslice_header_addr[5] = 0x11;\r\nif ((frame_num / ctrls->gop_size) % 2) {\r\n*header_size += 4;\r\n*header_offset1 += 4;\r\nslice_header_addr[6] = 0x04;\r\nslice_header_addr[7] = 0x70;\r\n} else {\r\n*header_size += 2;\r\n*header_offset1 += 2;\r\nslice_header_addr[6] = 0x09;\r\nslice_header_addr[7] = 0xC0;\r\n}\r\n} else {\r\nif (ctrls->entropy_mode == cabac) {\r\n*header_size += 1;\r\n*header_offset1 += 1;\r\nslice_header_addr[7] = 0x80;\r\n}\r\nslice_header_addr[5] += ((frame_order & 0x0C) >> 2);\r\nslice_header_addr[6] += ((frame_order & 0x03) << 6);\r\n}\r\ndev_dbg(dev,\r\n"%s %s slice header order %d idrPicId %d header size %d\n",\r\npctx->name, __func__, frame_order, idr_pic_id, *header_size);\r\nreturn 0;\r\n}\r\nstatic int hva_h264_fill_data_nal(struct hva_ctx *pctx,\r\nunsigned int stuffing_bytes, u8 *addr,\r\nunsigned int stream_size, unsigned int *size)\r\n{\r\nstruct device *dev = ctx_to_dev(pctx);\r\nconst u8 start[] = { 0x00, 0x00, 0x00, 0x01 };\r\ndev_dbg(dev, "%s %s stuffing bytes %d\n", pctx->name, __func__,\r\nstuffing_bytes);\r\nif ((*size + stuffing_bytes + H264_FILLER_DATA_SIZE) > stream_size) {\r\ndev_dbg(dev, "%s %s too many stuffing bytes %d\n",\r\npctx->name, __func__, stuffing_bytes);\r\nreturn 0;\r\n}\r\nmemcpy(addr + *size, start, sizeof(start));\r\n*size += sizeof(start);\r\naddr[*size] = NALU_TYPE_FILLER_DATA;\r\n*size += 1;\r\nmemset(addr + *size, 0xff, stuffing_bytes);\r\n*size += stuffing_bytes;\r\naddr[*size] = 0x80;\r\n*size += 1;\r\nreturn 0;\r\n}\r\nstatic int hva_h264_fill_sei_nal(struct hva_ctx *pctx,\r\nenum hva_h264_sei_payload_type type,\r\nu8 *addr, u32 *size)\r\n{\r\nstruct device *dev = ctx_to_dev(pctx);\r\nconst u8 start[] = { 0x00, 0x00, 0x00, 0x01 };\r\nstruct hva_h264_stereo_video_sei info;\r\nu8 offset = 7;\r\nu8 msg = 0;\r\nmemcpy(addr + *size, start, sizeof(start));\r\n*size += sizeof(start);\r\naddr[*size] = NALU_TYPE_SEI;\r\n*size += 1;\r\naddr[*size] = type;\r\n*size += 1;\r\nswitch (type) {\r\ncase SEI_STEREO_VIDEO_INFO:\r\nmemset(&info, 0, sizeof(info));\r\ninfo.field_views_flag = 1;\r\ninfo.top_field_is_left_view_flag = 1;\r\naddr[*size] = 1;\r\n*size += 1;\r\nmsg = info.field_views_flag << offset--;\r\nif (info.field_views_flag) {\r\nmsg |= info.top_field_is_left_view_flag <<\r\noffset--;\r\n} else {\r\nmsg |= info.current_frame_is_left_view_flag <<\r\noffset--;\r\nmsg |= info.next_frame_is_second_view_flag <<\r\noffset--;\r\n}\r\nmsg |= info.left_view_self_contained_flag << offset--;\r\nmsg |= info.right_view_self_contained_flag << offset--;\r\naddr[*size] = msg;\r\n*size += 1;\r\naddr[*size] = 0x80;\r\n*size += 1;\r\nreturn 0;\r\ncase SEI_BUFFERING_PERIOD:\r\ncase SEI_PICTURE_TIMING:\r\ncase SEI_FRAME_PACKING_ARRANGEMENT:\r\ndefault:\r\ndev_err(dev, "%s sei nal type not supported %d\n",\r\npctx->name, type);\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int hva_h264_prepare_task(struct hva_ctx *pctx,\r\nstruct hva_h264_task *task,\r\nstruct hva_frame *frame,\r\nstruct hva_stream *stream)\r\n{\r\nstruct hva_dev *hva = ctx_to_hdev(pctx);\r\nstruct device *dev = ctx_to_dev(pctx);\r\nstruct hva_h264_ctx *ctx = (struct hva_h264_ctx *)pctx->priv;\r\nstruct hva_buffer *seq_info = ctx->seq_info;\r\nstruct hva_buffer *fwd_ref_frame = ctx->ref_frame;\r\nstruct hva_buffer *loc_rec_frame = ctx->rec_frame;\r\nstruct hva_h264_td *td = &task->td;\r\nstruct hva_controls *ctrls = &pctx->ctrls;\r\nstruct v4l2_fract *time_per_frame = &pctx->ctrls.time_per_frame;\r\nint cavlc = V4L2_MPEG_VIDEO_H264_ENTROPY_MODE_CAVLC;\r\nu32 frame_num = pctx->stream_num;\r\nu32 addr_esram = hva->esram_addr;\r\nenum v4l2_mpeg_video_h264_level level;\r\ndma_addr_t paddr = 0;\r\nu8 *slice_header_vaddr;\r\nu32 frame_width = frame->info.aligned_width;\r\nu32 frame_height = frame->info.aligned_height;\r\nu32 max_cpb_buffer_size;\r\nunsigned int payload = stream->bytesused;\r\nu32 max_bitrate;\r\nif ((frame_width > max(H264_MAX_SIZE_W, H264_MAX_SIZE_H)) ||\r\n(frame_height > max(H264_MAX_SIZE_W, H264_MAX_SIZE_H))) {\r\ndev_err(dev,\r\n"%s width(%d) or height(%d) exceeds limits (%dx%d)\n",\r\npctx->name, frame_width, frame_height,\r\nH264_MAX_SIZE_W, H264_MAX_SIZE_H);\r\npctx->frame_errors++;\r\nreturn -EINVAL;\r\n}\r\nlevel = ctrls->level;\r\nmemset(td, 0, sizeof(struct hva_h264_td));\r\ntd->frame_width = frame_width;\r\ntd->frame_height = frame_height;\r\ntd->window_width = frame_width;\r\ntd->window_height = frame_height;\r\ntd->window_horizontal_offset = 0;\r\ntd->window_vertical_offset = 0;\r\ntd->first_picture_in_sequence = (!frame_num) ? 1 : 0;\r\ntd->pic_order_cnt_type = 2;\r\ntd->use_constrained_intra_flag = false;\r\ntd->brc_type = (ctrls->bitrate_mode == V4L2_MPEG_VIDEO_BITRATE_MODE_CBR)\r\n? BRC_TYPE_CBR : BRC_TYPE_VBR;\r\ntd->entropy_coding_mode = (ctrls->entropy_mode == cavlc) ? CAVLC :\r\nCABAC;\r\ntd->bit_rate = ctrls->bitrate;\r\nif (time_per_frame->numerator >= 536) {\r\ntd->framerate_den = 1;\r\ntd->framerate_num = (time_per_frame->denominator +\r\n(time_per_frame->numerator >> 1) - 1) /\r\ntime_per_frame->numerator;\r\ntd->bit_rate /= time_per_frame->numerator;\r\ntd->bit_rate *= time_per_frame->denominator;\r\ntd->bit_rate /= td->framerate_num;\r\n} else {\r\ntd->framerate_den = time_per_frame->numerator;\r\ntd->framerate_num = time_per_frame->denominator;\r\n}\r\nif (ctrls->profile >= V4L2_MPEG_VIDEO_H264_PROFILE_HIGH)\r\nmax_bitrate = h264_infos_list[level].max_bitrate *\r\nH264_FACTOR_HIGH;\r\nelse\r\nmax_bitrate = h264_infos_list[level].max_bitrate *\r\nH264_FACTOR_BASELINE;\r\nif (td->bit_rate > max_bitrate) {\r\ndev_dbg(dev,\r\n"%s bitrate (%d) larger than level and profile allow, clip to %d\n",\r\npctx->name, td->bit_rate, max_bitrate);\r\ntd->bit_rate = max_bitrate;\r\n}\r\ntd->cpb_buffer_size = ctrls->cpb_size * 8000;\r\nif (ctrls->profile >= V4L2_MPEG_VIDEO_H264_PROFILE_HIGH)\r\nmax_cpb_buffer_size =\r\nh264_infos_list[level].max_cpb_size * H264_FACTOR_HIGH;\r\nelse\r\nmax_cpb_buffer_size =\r\nh264_infos_list[level].max_cpb_size * H264_FACTOR_BASELINE;\r\nif (td->cpb_buffer_size > max_cpb_buffer_size) {\r\ndev_dbg(dev,\r\n"%s cpb size larger than level %d allows, clip to %d\n",\r\npctx->name, td->cpb_buffer_size, max_cpb_buffer_size);\r\ntd->cpb_buffer_size = max_cpb_buffer_size;\r\n}\r\ntd->brc_no_skip = 0;\r\nif ((ctrls->bitrate_mode == V4L2_MPEG_VIDEO_BITRATE_MODE_CBR) &&\r\ntd->bit_rate)\r\ntd->delay = 1000 * (td->cpb_buffer_size / td->bit_rate);\r\nelse\r\ntd->delay = 0;\r\nswitch (frame->info.pixelformat) {\r\ncase V4L2_PIX_FMT_NV12:\r\ntd->sampling_mode = SAMPLING_MODE_NV12;\r\nbreak;\r\ncase V4L2_PIX_FMT_NV21:\r\ntd->sampling_mode = SAMPLING_MODE_NV21;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "%s invalid source pixel format\n",\r\npctx->name);\r\npctx->frame_errors++;\r\nreturn -EINVAL;\r\n}\r\ntd->rgb2_yuv_y_coeff = 0x12031008;\r\ntd->rgb2_yuv_u_coeff = 0x800EF7FB;\r\ntd->rgb2_yuv_v_coeff = 0x80FEF40E;\r\ntd->transform_mode = ctrls->dct8x8;\r\ntd->encoder_complexity = 2;\r\ntd->quant = 28;\r\nif (td->framerate_den == 0) {\r\ndev_err(dev, "%s invalid framerate\n", pctx->name);\r\npctx->frame_errors++;\r\nreturn -EINVAL;\r\n}\r\nif (td->framerate_num == 0)\r\ntd->brc_type = 0;\r\ntd->strict_hrd_compliancy = 1;\r\ntd->qp_min = clamp_val(ctrls->qpmin, 0, 51);\r\ntd->qp_max = clamp_val(ctrls->qpmax, 0, 51);\r\ntd->addr_source_buffer = frame->paddr;\r\ntd->addr_fwd_ref_buffer = fwd_ref_frame->paddr;\r\ntd->addr_rec_buffer = loc_rec_frame->paddr;\r\ntd->addr_output_bitstream_end = (u32)stream->paddr + stream->size;\r\ntd->addr_output_bitstream_start = (u32)stream->paddr;\r\ntd->bitstream_offset = (((u32)stream->paddr & 0xF) << 3) &\r\nBITSTREAM_OFFSET_MASK;\r\ntd->addr_param_out = (u32)ctx->task->paddr +\r\noffsetof(struct hva_h264_task, po);\r\nif (frame_num % 2) {\r\npaddr = seq_info->paddr;\r\ntd->addr_spatial_context = ALIGN(paddr, 0x100);\r\npaddr = seq_info->paddr + DATA_SIZE(frame_width,\r\nframe_height);\r\ntd->addr_temporal_context = ALIGN(paddr, 0x100);\r\n} else {\r\npaddr = seq_info->paddr;\r\ntd->addr_temporal_context = ALIGN(paddr, 0x100);\r\npaddr = seq_info->paddr + DATA_SIZE(frame_width,\r\nframe_height);\r\ntd->addr_spatial_context = ALIGN(paddr, 0x100);\r\n}\r\npaddr = seq_info->paddr + 2 * DATA_SIZE(frame_width, frame_height);\r\ntd->addr_brc_in_out_parameter = ALIGN(paddr, 0x100);\r\npaddr = td->addr_brc_in_out_parameter + BRC_DATA_SIZE;\r\ntd->addr_slice_header = ALIGN(paddr, 0x100);\r\ntd->addr_external_sw = ALIGN(addr_esram, 0x100);\r\naddr_esram += SEARCH_WINDOW_BUFFER_MAX_SIZE(frame_width);\r\ntd->addr_local_rec_buffer = ALIGN(addr_esram, 0x100);\r\naddr_esram += LOCAL_RECONSTRUCTED_BUFFER_MAX_SIZE(frame_width);\r\ntd->addr_lctx = ALIGN(addr_esram, 0x100);\r\naddr_esram += CTX_MB_BUFFER_MAX_SIZE(max(frame_width, frame_height));\r\ntd->addr_cabac_context_buffer = ALIGN(addr_esram, 0x100);\r\nif (!(frame_num % ctrls->gop_size)) {\r\ntd->picture_coding_type = PICTURE_CODING_TYPE_I;\r\nstream->vbuf.flags |= V4L2_BUF_FLAG_KEYFRAME;\r\n} else {\r\ntd->picture_coding_type = PICTURE_CODING_TYPE_P;\r\nstream->vbuf.flags &= ~V4L2_BUF_FLAG_KEYFRAME;\r\n}\r\nslice_header_vaddr = seq_info->vaddr + (td->addr_slice_header -\r\nseq_info->paddr);\r\nhva_h264_fill_slice_header(pctx, slice_header_vaddr, ctrls, frame_num,\r\n&td->slice_header_size_in_bits,\r\n&td->slice_header_offset0,\r\n&td->slice_header_offset1,\r\n&td->slice_header_offset2);\r\ntd->chroma_qp_index_offset = 2;\r\ntd->slice_synchro_enable = 0;\r\ntd->max_slice_number = 1;\r\nif ((stream->vbuf.flags == V4L2_BUF_FLAG_KEYFRAME) &&\r\n(payload > MAX_SPS_PPS_SIZE)) {\r\ndev_err(dev, "%s invalid sps/pps size %d\n", pctx->name,\r\npayload);\r\npctx->frame_errors++;\r\nreturn -EINVAL;\r\n}\r\nif (stream->vbuf.flags != V4L2_BUF_FLAG_KEYFRAME)\r\npayload = 0;\r\nif (ctrls->sei_fp && hva_h264_fill_sei_nal(pctx, SEI_STEREO_VIDEO_INFO,\r\n(u8 *)stream->vaddr,\r\n&payload)) {\r\ndev_err(dev, "%s fail to get SEI nal\n", pctx->name);\r\npctx->frame_errors++;\r\nreturn -EINVAL;\r\n}\r\ntd->non_vcl_nalu_size = payload * 8;\r\ntd->addr_output_bitstream_start += ((payload >> 4) << 4);\r\ntd->bitstream_offset += (payload - ((payload >> 4) << 4)) * 8;\r\nstream->bytesused = payload;\r\nreturn 0;\r\n}\r\nstatic unsigned int hva_h264_get_stream_size(struct hva_h264_task *task)\r\n{\r\nstruct hva_h264_po *po = &task->po;\r\nreturn po->bitstream_size;\r\n}\r\nstatic u32 hva_h264_get_stuffing_bytes(struct hva_h264_task *task)\r\n{\r\nstruct hva_h264_po *po = &task->po;\r\nreturn po->stuffing_bits >> 3;\r\n}\r\nstatic int hva_h264_open(struct hva_ctx *pctx)\r\n{\r\nstruct device *dev = ctx_to_dev(pctx);\r\nstruct hva_h264_ctx *ctx;\r\nstruct hva_dev *hva = ctx_to_hdev(pctx);\r\nu32 frame_width = pctx->frameinfo.aligned_width;\r\nu32 frame_height = pctx->frameinfo.aligned_height;\r\nu32 size;\r\nint ret;\r\nsize = SEARCH_WINDOW_BUFFER_MAX_SIZE(frame_width) +\r\nLOCAL_RECONSTRUCTED_BUFFER_MAX_SIZE(frame_width) +\r\nCTX_MB_BUFFER_MAX_SIZE(max(frame_width, frame_height)) +\r\nCABAC_CONTEXT_BUFFER_MAX_SIZE(frame_width);\r\nif (hva->esram_size < size) {\r\ndev_err(dev, "%s not enough esram (max:%d request:%d)\n",\r\npctx->name, hva->esram_size, size);\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nret = hva_mem_alloc(pctx,\r\n2 * DATA_SIZE(frame_width, frame_height) +\r\nSLICE_HEADER_SIZE +\r\nBRC_DATA_SIZE,\r\n"hva sequence info",\r\n&ctx->seq_info);\r\nif (ret) {\r\ndev_err(dev,\r\n"%s failed to allocate sequence info buffer\n",\r\npctx->name);\r\ngoto err_ctx;\r\n}\r\nret = hva_mem_alloc(pctx,\r\nframe_width * frame_height * 3 / 2,\r\n"hva reference frame",\r\n&ctx->ref_frame);\r\nif (ret) {\r\ndev_err(dev, "%s failed to allocate reference frame buffer\n",\r\npctx->name);\r\ngoto err_seq_info;\r\n}\r\nret = hva_mem_alloc(pctx,\r\nframe_width * frame_height * 3 / 2,\r\n"hva reconstructed frame",\r\n&ctx->rec_frame);\r\nif (ret) {\r\ndev_err(dev,\r\n"%s failed to allocate reconstructed frame buffer\n",\r\npctx->name);\r\ngoto err_ref_frame;\r\n}\r\nret = hva_mem_alloc(pctx,\r\nsizeof(struct hva_h264_task),\r\n"hva task descriptor",\r\n&ctx->task);\r\nif (ret) {\r\ndev_err(dev,\r\n"%s failed to allocate task descriptor\n",\r\npctx->name);\r\ngoto err_rec_frame;\r\n}\r\npctx->priv = (void *)ctx;\r\nreturn 0;\r\nerr_rec_frame:\r\nhva_mem_free(pctx, ctx->rec_frame);\r\nerr_ref_frame:\r\nhva_mem_free(pctx, ctx->ref_frame);\r\nerr_seq_info:\r\nhva_mem_free(pctx, ctx->seq_info);\r\nerr_ctx:\r\ndevm_kfree(dev, ctx);\r\nerr:\r\npctx->sys_errors++;\r\nreturn ret;\r\n}\r\nstatic int hva_h264_close(struct hva_ctx *pctx)\r\n{\r\nstruct hva_h264_ctx *ctx = (struct hva_h264_ctx *)pctx->priv;\r\nstruct device *dev = ctx_to_dev(pctx);\r\nif (ctx->seq_info)\r\nhva_mem_free(pctx, ctx->seq_info);\r\nif (ctx->ref_frame)\r\nhva_mem_free(pctx, ctx->ref_frame);\r\nif (ctx->rec_frame)\r\nhva_mem_free(pctx, ctx->rec_frame);\r\nif (ctx->task)\r\nhva_mem_free(pctx, ctx->task);\r\ndevm_kfree(dev, ctx);\r\nreturn 0;\r\n}\r\nstatic int hva_h264_encode(struct hva_ctx *pctx, struct hva_frame *frame,\r\nstruct hva_stream *stream)\r\n{\r\nstruct hva_h264_ctx *ctx = (struct hva_h264_ctx *)pctx->priv;\r\nstruct hva_h264_task *task = (struct hva_h264_task *)ctx->task->vaddr;\r\nstruct hva_buffer *tmp_frame;\r\nu32 stuffing_bytes = 0;\r\nint ret = 0;\r\nret = hva_h264_prepare_task(pctx, task, frame, stream);\r\nif (ret)\r\ngoto err;\r\nret = hva_hw_execute_task(pctx, H264_ENC, ctx->task);\r\nif (ret)\r\ngoto err;\r\npctx->stream_num++;\r\nstream->bytesused += hva_h264_get_stream_size(task);\r\nstuffing_bytes = hva_h264_get_stuffing_bytes(task);\r\nif (stuffing_bytes)\r\nhva_h264_fill_data_nal(pctx, stuffing_bytes,\r\n(u8 *)stream->vaddr,\r\nstream->size,\r\n&stream->bytesused);\r\ntmp_frame = ctx->ref_frame;\r\nctx->ref_frame = ctx->rec_frame;\r\nctx->rec_frame = tmp_frame;\r\nreturn 0;\r\nerr:\r\nstream->bytesused = 0;\r\nreturn ret;\r\n}
