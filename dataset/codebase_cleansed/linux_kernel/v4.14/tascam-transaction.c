static inline int calculate_message_bytes(u8 status)\r\n{\r\nswitch (status) {\r\ncase 0xf6:\r\ncase 0xf8:\r\ncase 0xfa:\r\ncase 0xfb:\r\ncase 0xfc:\r\ncase 0xfe:\r\ncase 0xff:\r\nreturn 1;\r\ncase 0xf1:\r\ncase 0xf3:\r\nreturn 2;\r\ncase 0xf2:\r\nreturn 3;\r\ncase 0xf0:\r\nreturn 0;\r\ncase 0xf7:\r\nbreak;\r\ncase 0xf4:\r\ncase 0xf5:\r\ncase 0xf9:\r\ncase 0xfd:\r\nbreak;\r\ndefault:\r\nswitch (status & 0xf0) {\r\ncase 0x80:\r\ncase 0x90:\r\ncase 0xa0:\r\ncase 0xb0:\r\ncase 0xe0:\r\nreturn 3;\r\ncase 0xc0:\r\ncase 0xd0:\r\nreturn 2;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int fill_message(struct snd_fw_async_midi_port *port,\r\nstruct snd_rawmidi_substream *substream)\r\n{\r\nint i, len, consume;\r\nu8 *label, *msg;\r\nu8 status;\r\nlabel = port->buf;\r\nmsg = port->buf + 1;\r\nconsume = snd_rawmidi_transmit_peek(substream, msg, 3);\r\nif (consume == 0)\r\nreturn 0;\r\nif (port->on_sysex) {\r\nfor (i = 0; i < consume; ++i) {\r\nif (msg[i] == 0xf7) {\r\nport->on_sysex = false;\r\nbreak;\r\n}\r\n}\r\nif (!port->on_sysex) {\r\nconsume = i + 1;\r\n*label = (substream->number << 4) | 0x07;\r\n} else if (consume == 3) {\r\n*label = (substream->number << 4) | 0x04;\r\n} else {\r\nreturn 0;\r\n}\r\nlen = consume;\r\n} else {\r\nif (msg[0] == 0xf0) {\r\nport->on_sysex = true;\r\nreturn 0;\r\n} else {\r\nif ((msg[0] & 0x80) != 0x80)\r\nstatus = port->running_status;\r\nelse\r\nstatus = msg[0];\r\nlen = calculate_message_bytes(status);\r\nif (len <= 0)\r\nreturn 0;\r\nif ((msg[0] & 0x80) != 0x80) {\r\nif (consume < len - 1)\r\nreturn 0;\r\nconsume = len - 1;\r\nmsg[2] = msg[1];\r\nmsg[1] = msg[0];\r\nmsg[0] = port->running_status;\r\n} else {\r\nif (consume < len)\r\nreturn 0;\r\nconsume = len;\r\nport->running_status = msg[0];\r\n}\r\n}\r\n*label = (substream->number << 4) | (msg[0] >> 4);\r\n}\r\nif (len > 0 && len < 3)\r\nmemset(msg + len, 0, 3 - len);\r\nreturn consume;\r\n}\r\nstatic void async_midi_port_callback(struct fw_card *card, int rcode,\r\nvoid *data, size_t length,\r\nvoid *callback_data)\r\n{\r\nstruct snd_fw_async_midi_port *port = callback_data;\r\nstruct snd_rawmidi_substream *substream = ACCESS_ONCE(port->substream);\r\nif (substream == NULL)\r\nreturn;\r\nif (rcode == RCODE_COMPLETE)\r\nsnd_rawmidi_transmit_ack(substream, port->consume_bytes);\r\nelse if (!rcode_is_permanent_error(rcode))\r\nport->next_ktime = 0;\r\nelse\r\nport->error = true;\r\nport->idling = true;\r\nif (!snd_rawmidi_transmit_empty(substream))\r\nschedule_work(&port->work);\r\n}\r\nstatic void midi_port_work(struct work_struct *work)\r\n{\r\nstruct snd_fw_async_midi_port *port =\r\ncontainer_of(work, struct snd_fw_async_midi_port, work);\r\nstruct snd_rawmidi_substream *substream = ACCESS_ONCE(port->substream);\r\nint generation;\r\nif (!port->idling || port->error)\r\nreturn;\r\nif (substream == NULL || snd_rawmidi_transmit_empty(substream))\r\nreturn;\r\nif (ktime_after(port->next_ktime, ktime_get())) {\r\nschedule_work(&port->work);\r\nreturn;\r\n}\r\nmemset(port->buf, 0, 4);\r\nport->consume_bytes = fill_message(port, substream);\r\nif (port->consume_bytes <= 0) {\r\nif (port->consume_bytes == 0) {\r\nport->next_ktime = 0;\r\nschedule_work(&port->work);\r\n} else {\r\nport->error = true;\r\n}\r\nreturn;\r\n}\r\nport->next_ktime = ktime_add_ns(ktime_get(),\r\nport->consume_bytes * 8 * NSEC_PER_SEC / 31250);\r\nport->idling = false;\r\ngeneration = port->parent->generation;\r\nsmp_rmb();\r\nfw_send_request(port->parent->card, &port->transaction,\r\nTCODE_WRITE_QUADLET_REQUEST,\r\nport->parent->node_id, generation,\r\nport->parent->max_speed,\r\nTSCM_ADDR_BASE + TSCM_OFFSET_MIDI_RX_QUAD,\r\nport->buf, 4, async_midi_port_callback,\r\nport);\r\n}\r\nvoid snd_fw_async_midi_port_init(struct snd_fw_async_midi_port *port)\r\n{\r\nport->idling = true;\r\nport->error = false;\r\nport->running_status = 0;\r\nport->on_sysex = false;\r\n}\r\nstatic void handle_midi_tx(struct fw_card *card, struct fw_request *request,\r\nint tcode, int destination, int source,\r\nint generation, unsigned long long offset,\r\nvoid *data, size_t length, void *callback_data)\r\n{\r\nstruct snd_tscm *tscm = callback_data;\r\nu32 *buf = (u32 *)data;\r\nunsigned int messages;\r\nunsigned int i;\r\nunsigned int port;\r\nstruct snd_rawmidi_substream *substream;\r\nu8 *b;\r\nint bytes;\r\nif (offset != tscm->async_handler.offset)\r\ngoto end;\r\nmessages = length / 8;\r\nfor (i = 0; i < messages; i++) {\r\nb = (u8 *)(buf + i * 2);\r\nport = b[0] >> 4;\r\nif (port >= tscm->spec->midi_capture_ports)\r\ngoto end;\r\nbytes = calculate_message_bytes(b[1]);\r\nif (bytes <= 0) {\r\nfor (bytes = 1; bytes < 4; bytes++) {\r\nif (b[bytes] == 0xf7)\r\nbreak;\r\n}\r\nif (bytes == 4)\r\nbytes = 3;\r\n}\r\nsubstream = ACCESS_ONCE(tscm->tx_midi_substreams[port]);\r\nif (substream != NULL)\r\nsnd_rawmidi_receive(substream, b + 1, bytes);\r\n}\r\nend:\r\nfw_send_response(card, request, RCODE_COMPLETE);\r\n}\r\nint snd_tscm_transaction_register(struct snd_tscm *tscm)\r\n{\r\nstatic const struct fw_address_region resp_register_region = {\r\n.start = 0xffffe0000000ull,\r\n.end = 0xffffe000ffffull,\r\n};\r\nunsigned int i;\r\nint err;\r\ntscm->async_handler.length = 8 * 8;\r\ntscm->async_handler.address_callback = handle_midi_tx;\r\ntscm->async_handler.callback_data = tscm;\r\nerr = fw_core_add_address_handler(&tscm->async_handler,\r\n&resp_register_region);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_tscm_transaction_reregister(tscm);\r\nif (err < 0)\r\ngoto error;\r\nfor (i = 0; i < TSCM_MIDI_OUT_PORT_MAX; i++) {\r\ntscm->out_ports[i].parent = fw_parent_device(tscm->unit);\r\ntscm->out_ports[i].next_ktime = 0;\r\nINIT_WORK(&tscm->out_ports[i].work, midi_port_work);\r\n}\r\nreturn err;\r\nerror:\r\nfw_core_remove_address_handler(&tscm->async_handler);\r\ntscm->async_handler.callback_data = NULL;\r\nreturn err;\r\n}\r\nint snd_tscm_transaction_reregister(struct snd_tscm *tscm)\r\n{\r\nstruct fw_device *device = fw_parent_device(tscm->unit);\r\n__be32 reg;\r\nint err;\r\nreg = cpu_to_be32((device->card->node_id << 16) |\r\n(tscm->async_handler.offset >> 32));\r\nerr = snd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\r\nTSCM_ADDR_BASE + TSCM_OFFSET_MIDI_TX_ADDR_HI,\r\n&reg, sizeof(reg), 0);\r\nif (err < 0)\r\nreturn err;\r\nreg = cpu_to_be32(tscm->async_handler.offset);\r\nerr = snd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\r\nTSCM_ADDR_BASE + TSCM_OFFSET_MIDI_TX_ADDR_LO,\r\n&reg, sizeof(reg), 0);\r\nif (err < 0)\r\nreturn err;\r\nreg = cpu_to_be32(0x00000001);\r\nerr = snd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\r\nTSCM_ADDR_BASE + TSCM_OFFSET_MIDI_TX_ON,\r\n&reg, sizeof(reg), 0);\r\nif (err < 0)\r\nreturn err;\r\nreg = cpu_to_be32(0x0001008e);\r\nreturn snd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\r\nTSCM_ADDR_BASE + TSCM_OFFSET_LED_POWER,\r\n&reg, sizeof(reg), 0);\r\n}\r\nvoid snd_tscm_transaction_unregister(struct snd_tscm *tscm)\r\n{\r\n__be32 reg;\r\nif (tscm->async_handler.callback_data == NULL)\r\nreturn;\r\nreg = cpu_to_be32(0x0000008e);\r\nsnd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\r\nTSCM_ADDR_BASE + TSCM_OFFSET_LED_POWER,\r\n&reg, sizeof(reg), 0);\r\nreg = cpu_to_be32(0x00000000);\r\nsnd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\r\nTSCM_ADDR_BASE + TSCM_OFFSET_MIDI_TX_ON,\r\n&reg, sizeof(reg), 0);\r\nsnd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\r\nTSCM_ADDR_BASE + TSCM_OFFSET_MIDI_TX_ADDR_HI,\r\n&reg, sizeof(reg), 0);\r\nsnd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\r\nTSCM_ADDR_BASE + TSCM_OFFSET_MIDI_TX_ADDR_LO,\r\n&reg, sizeof(reg), 0);\r\nfw_core_remove_address_handler(&tscm->async_handler);\r\ntscm->async_handler.callback_data = NULL;\r\n}
