static int wm8994_suspend(struct device *dev)\r\n{\r\nstruct wm8994 *wm8994 = dev_get_drvdata(dev);\r\nint ret;\r\nswitch (wm8994->type) {\r\ncase WM8958:\r\ncase WM1811:\r\nret = wm8994_reg_read(wm8994, WM8958_MIC_DETECT_1);\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to read power status: %d\n", ret);\r\n} else if (ret & WM8958_MICD_ENA) {\r\ndev_dbg(dev, "CODEC still active, ignoring suspend\n");\r\nreturn 0;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (!wm8994->ldo_ena_always_driven)\r\nwm8994_set_bits(wm8994, WM8994_PULL_CONTROL_2,\r\nWM8994_LDO1ENA_PD | WM8994_LDO2ENA_PD,\r\nWM8994_LDO1ENA_PD | WM8994_LDO2ENA_PD);\r\nwm8994_reg_write(wm8994, WM8994_SOFTWARE_RESET,\r\nwm8994_reg_read(wm8994, WM8994_SOFTWARE_RESET));\r\nregcache_mark_dirty(wm8994->regmap);\r\nret = regcache_sync_region(wm8994->regmap, WM8994_GPIO_1,\r\nWM8994_GPIO_11);\r\nif (ret != 0)\r\ndev_err(dev, "Failed to restore GPIO registers: %d\n", ret);\r\nret = regcache_sync_region(wm8994->regmap,\r\nWM8994_INTERRUPT_STATUS_1_MASK,\r\nWM8994_INTERRUPT_STATUS_1_MASK);\r\nif (ret != 0)\r\ndev_err(dev, "Failed to restore interrupt mask: %d\n", ret);\r\nregcache_cache_only(wm8994->regmap, true);\r\nwm8994->suspended = true;\r\nret = regulator_bulk_disable(wm8994->num_supplies,\r\nwm8994->supplies);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to disable supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8994_resume(struct device *dev)\r\n{\r\nstruct wm8994 *wm8994 = dev_get_drvdata(dev);\r\nint ret;\r\nif (!wm8994->suspended)\r\nreturn 0;\r\nret = regulator_bulk_enable(wm8994->num_supplies,\r\nwm8994->supplies);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to enable supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nregcache_cache_only(wm8994->regmap, false);\r\nret = regcache_sync(wm8994->regmap);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to restore register map: %d\n", ret);\r\ngoto err_enable;\r\n}\r\nwm8994_set_bits(wm8994, WM8994_PULL_CONTROL_2,\r\nWM8994_LDO1ENA_PD | WM8994_LDO2ENA_PD,\r\n0);\r\nwm8994->suspended = false;\r\nreturn 0;\r\nerr_enable:\r\nregulator_bulk_disable(wm8994->num_supplies, wm8994->supplies);\r\nreturn ret;\r\n}\r\nstatic int wm8994_ldo_in_use(struct wm8994_pdata *pdata, int ldo)\r\n{\r\nstruct wm8994_ldo_pdata *ldo_pdata;\r\nif (!pdata)\r\nreturn 0;\r\nldo_pdata = &pdata->ldo[ldo];\r\nif (!ldo_pdata->init_data)\r\nreturn 0;\r\nreturn ldo_pdata->init_data->num_consumer_supplies != 0;\r\n}\r\nstatic int wm8994_ldo_in_use(struct wm8994_pdata *pdata, int ldo)\r\n{\r\nreturn 0;\r\n}\r\nstatic int wm8994_set_pdata_from_of(struct wm8994 *wm8994)\r\n{\r\nstruct device_node *np = wm8994->dev->of_node;\r\nstruct wm8994_pdata *pdata = &wm8994->pdata;\r\nint i;\r\nif (!np)\r\nreturn 0;\r\nif (of_property_read_u32_array(np, "wlf,gpio-cfg", pdata->gpio_defaults,\r\nARRAY_SIZE(pdata->gpio_defaults)) >= 0) {\r\nfor (i = 0; i < ARRAY_SIZE(pdata->gpio_defaults); i++) {\r\nif (wm8994->pdata.gpio_defaults[i] == 0)\r\npdata->gpio_defaults[i]\r\n= WM8994_CONFIGURE_GPIO;\r\n}\r\n}\r\nof_property_read_u32_array(np, "wlf,micbias-cfg", pdata->micbias,\r\nARRAY_SIZE(pdata->micbias));\r\npdata->lineout1_diff = true;\r\npdata->lineout2_diff = true;\r\nif (of_find_property(np, "wlf,lineout1-se", NULL))\r\npdata->lineout1_diff = false;\r\nif (of_find_property(np, "wlf,lineout2-se", NULL))\r\npdata->lineout2_diff = false;\r\nif (of_find_property(np, "wlf,lineout1-feedback", NULL))\r\npdata->lineout1fb = true;\r\nif (of_find_property(np, "wlf,lineout2-feedback", NULL))\r\npdata->lineout2fb = true;\r\nif (of_find_property(np, "wlf,ldoena-always-driven", NULL))\r\npdata->lineout2fb = true;\r\npdata->ldo[0].enable = of_get_named_gpio(np, "wlf,ldo1ena", 0);\r\nif (pdata->ldo[0].enable < 0)\r\npdata->ldo[0].enable = 0;\r\npdata->ldo[1].enable = of_get_named_gpio(np, "wlf,ldo2ena", 0);\r\nif (pdata->ldo[1].enable < 0)\r\npdata->ldo[1].enable = 0;\r\nreturn 0;\r\n}\r\nstatic int wm8994_set_pdata_from_of(struct wm8994 *wm8994)\r\n{\r\nreturn 0;\r\n}\r\nstatic int wm8994_device_init(struct wm8994 *wm8994, int irq)\r\n{\r\nstruct wm8994_pdata *pdata;\r\nstruct regmap_config *regmap_config;\r\nconst struct reg_sequence *regmap_patch = NULL;\r\nconst char *devname;\r\nint ret, i, patch_regs = 0;\r\nint pulls = 0;\r\nif (dev_get_platdata(wm8994->dev)) {\r\npdata = dev_get_platdata(wm8994->dev);\r\nwm8994->pdata = *pdata;\r\n}\r\npdata = &wm8994->pdata;\r\nret = wm8994_set_pdata_from_of(wm8994);\r\nif (ret != 0)\r\nreturn ret;\r\ndev_set_drvdata(wm8994->dev, wm8994);\r\nret = mfd_add_devices(wm8994->dev, 0,\r\nwm8994_regulator_devs,\r\nARRAY_SIZE(wm8994_regulator_devs),\r\nNULL, 0, NULL);\r\nif (ret != 0) {\r\ndev_err(wm8994->dev, "Failed to add children: %d\n", ret);\r\ngoto err;\r\n}\r\nswitch (wm8994->type) {\r\ncase WM1811:\r\nwm8994->num_supplies = ARRAY_SIZE(wm1811_main_supplies);\r\nbreak;\r\ncase WM8994:\r\nwm8994->num_supplies = ARRAY_SIZE(wm8994_main_supplies);\r\nbreak;\r\ncase WM8958:\r\nwm8994->num_supplies = ARRAY_SIZE(wm8958_main_supplies);\r\nbreak;\r\ndefault:\r\nBUG();\r\ngoto err;\r\n}\r\nwm8994->supplies = devm_kzalloc(wm8994->dev,\r\nsizeof(struct regulator_bulk_data) *\r\nwm8994->num_supplies, GFP_KERNEL);\r\nif (!wm8994->supplies) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nswitch (wm8994->type) {\r\ncase WM1811:\r\nfor (i = 0; i < ARRAY_SIZE(wm1811_main_supplies); i++)\r\nwm8994->supplies[i].supply = wm1811_main_supplies[i];\r\nbreak;\r\ncase WM8994:\r\nfor (i = 0; i < ARRAY_SIZE(wm8994_main_supplies); i++)\r\nwm8994->supplies[i].supply = wm8994_main_supplies[i];\r\nbreak;\r\ncase WM8958:\r\nfor (i = 0; i < ARRAY_SIZE(wm8958_main_supplies); i++)\r\nwm8994->supplies[i].supply = wm8958_main_supplies[i];\r\nbreak;\r\ndefault:\r\nBUG();\r\ngoto err;\r\n}\r\nret = regulator_bulk_get(wm8994->dev, wm8994->num_supplies,\r\nwm8994->supplies);\r\nif (ret != 0) {\r\ndev_err(wm8994->dev, "Failed to get supplies: %d\n", ret);\r\ngoto err;\r\n}\r\nret = regulator_bulk_enable(wm8994->num_supplies, wm8994->supplies);\r\nif (ret != 0) {\r\ndev_err(wm8994->dev, "Failed to enable supplies: %d\n", ret);\r\ngoto err_regulator_free;\r\n}\r\nret = wm8994_reg_read(wm8994, WM8994_SOFTWARE_RESET);\r\nif (ret < 0) {\r\ndev_err(wm8994->dev, "Failed to read ID register\n");\r\ngoto err_enable;\r\n}\r\nswitch (ret) {\r\ncase 0x1811:\r\ndevname = "WM1811";\r\nif (wm8994->type != WM1811)\r\ndev_warn(wm8994->dev, "Device registered as type %d\n",\r\nwm8994->type);\r\nwm8994->type = WM1811;\r\nbreak;\r\ncase 0x8994:\r\ndevname = "WM8994";\r\nif (wm8994->type != WM8994)\r\ndev_warn(wm8994->dev, "Device registered as type %d\n",\r\nwm8994->type);\r\nwm8994->type = WM8994;\r\nbreak;\r\ncase 0x8958:\r\ndevname = "WM8958";\r\nif (wm8994->type != WM8958)\r\ndev_warn(wm8994->dev, "Device registered as type %d\n",\r\nwm8994->type);\r\nwm8994->type = WM8958;\r\nbreak;\r\ndefault:\r\ndev_err(wm8994->dev, "Device is not a WM8994, ID is %x\n",\r\nret);\r\nret = -EINVAL;\r\ngoto err_enable;\r\n}\r\nret = wm8994_reg_read(wm8994, WM8994_CHIP_REVISION);\r\nif (ret < 0) {\r\ndev_err(wm8994->dev, "Failed to read revision register: %d\n",\r\nret);\r\ngoto err_enable;\r\n}\r\nwm8994->revision = ret & WM8994_CHIP_REV_MASK;\r\nwm8994->cust_id = (ret & WM8994_CUST_ID_MASK) >> WM8994_CUST_ID_SHIFT;\r\nswitch (wm8994->type) {\r\ncase WM8994:\r\nswitch (wm8994->revision) {\r\ncase 0:\r\ncase 1:\r\ndev_warn(wm8994->dev,\r\n"revision %c not fully supported\n",\r\n'A' + wm8994->revision);\r\nbreak;\r\ncase 2:\r\ncase 3:\r\ndefault:\r\nregmap_patch = wm8994_revc_patch;\r\npatch_regs = ARRAY_SIZE(wm8994_revc_patch);\r\nbreak;\r\n}\r\nbreak;\r\ncase WM8958:\r\nswitch (wm8994->revision) {\r\ncase 0:\r\nregmap_patch = wm8958_reva_patch;\r\npatch_regs = ARRAY_SIZE(wm8958_reva_patch);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase WM1811:\r\nif (wm8994->revision > 1)\r\nwm8994->revision++;\r\nregmap_patch = wm1811_reva_patch;\r\npatch_regs = ARRAY_SIZE(wm1811_reva_patch);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ndev_info(wm8994->dev, "%s revision %c CUST_ID %02x\n", devname,\r\n'A' + wm8994->revision, wm8994->cust_id);\r\nswitch (wm8994->type) {\r\ncase WM1811:\r\nregmap_config = &wm1811_regmap_config;\r\nbreak;\r\ncase WM8994:\r\nregmap_config = &wm8994_regmap_config;\r\nbreak;\r\ncase WM8958:\r\nregmap_config = &wm8958_regmap_config;\r\nbreak;\r\ndefault:\r\ndev_err(wm8994->dev, "Unknown device type %d\n", wm8994->type);\r\nreturn -EINVAL;\r\n}\r\nret = regmap_reinit_cache(wm8994->regmap, regmap_config);\r\nif (ret != 0) {\r\ndev_err(wm8994->dev, "Failed to reinit register cache: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nret = wm8994_reg_write(wm8994, WM8994_SOFTWARE_RESET,\r\nwm8994_reg_read(wm8994, WM8994_SOFTWARE_RESET));\r\nif (ret != 0) {\r\ndev_err(wm8994->dev, "Failed to reset device: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (regmap_patch) {\r\nret = regmap_register_patch(wm8994->regmap, regmap_patch,\r\npatch_regs);\r\nif (ret != 0) {\r\ndev_err(wm8994->dev, "Failed to register patch: %d\n",\r\nret);\r\ngoto err;\r\n}\r\n}\r\nwm8994->irq_base = pdata->irq_base;\r\nwm8994->gpio_base = pdata->gpio_base;\r\nfor (i = 0; i < ARRAY_SIZE(pdata->gpio_defaults); i++) {\r\nif (pdata->gpio_defaults[i]) {\r\nwm8994_set_bits(wm8994, WM8994_GPIO_1 + i,\r\n0xffff, pdata->gpio_defaults[i]);\r\n}\r\n}\r\nwm8994->ldo_ena_always_driven = pdata->ldo_ena_always_driven;\r\nif (pdata->spkmode_pu)\r\npulls |= WM8994_SPKMODE_PU;\r\nwm8994_set_bits(wm8994, WM8994_PULL_CONTROL_2,\r\nWM8994_LDO1ENA_PD | WM8994_LDO2ENA_PD |\r\nWM8994_SPKMODE_PU | WM8994_CSNADDR_PD,\r\npulls);\r\nfor (i = 0; i < WM8994_NUM_LDO_REGS; i++) {\r\nif (wm8994_ldo_in_use(pdata, i))\r\nwm8994_set_bits(wm8994, WM8994_LDO_1 + i,\r\nWM8994_LDO1_DISCH, WM8994_LDO1_DISCH);\r\nelse\r\nwm8994_set_bits(wm8994, WM8994_LDO_1 + i,\r\nWM8994_LDO1_DISCH, 0);\r\n}\r\nwm8994_irq_init(wm8994);\r\nret = mfd_add_devices(wm8994->dev, -1,\r\nwm8994_devs, ARRAY_SIZE(wm8994_devs),\r\nNULL, 0, NULL);\r\nif (ret != 0) {\r\ndev_err(wm8994->dev, "Failed to add children: %d\n", ret);\r\ngoto err_irq;\r\n}\r\npm_runtime_enable(wm8994->dev);\r\npm_runtime_idle(wm8994->dev);\r\nreturn 0;\r\nerr_irq:\r\nwm8994_irq_exit(wm8994);\r\nerr_enable:\r\nregulator_bulk_disable(wm8994->num_supplies,\r\nwm8994->supplies);\r\nerr_regulator_free:\r\nregulator_bulk_free(wm8994->num_supplies, wm8994->supplies);\r\nerr:\r\nmfd_remove_devices(wm8994->dev);\r\nreturn ret;\r\n}\r\nstatic void wm8994_device_exit(struct wm8994 *wm8994)\r\n{\r\npm_runtime_disable(wm8994->dev);\r\nwm8994_irq_exit(wm8994);\r\nregulator_bulk_disable(wm8994->num_supplies, wm8994->supplies);\r\nregulator_bulk_free(wm8994->num_supplies, wm8994->supplies);\r\nmfd_remove_devices(wm8994->dev);\r\n}\r\nstatic int wm8994_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nconst struct of_device_id *of_id;\r\nstruct wm8994 *wm8994;\r\nint ret;\r\nwm8994 = devm_kzalloc(&i2c->dev, sizeof(struct wm8994), GFP_KERNEL);\r\nif (wm8994 == NULL)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(i2c, wm8994);\r\nwm8994->dev = &i2c->dev;\r\nwm8994->irq = i2c->irq;\r\nif (i2c->dev.of_node) {\r\nof_id = of_match_device(wm8994_of_match, &i2c->dev);\r\nif (of_id)\r\nwm8994->type = (enum wm8994_type)of_id->data;\r\n} else {\r\nwm8994->type = id->driver_data;\r\n}\r\nwm8994->regmap = devm_regmap_init_i2c(i2c, &wm8994_base_regmap_config);\r\nif (IS_ERR(wm8994->regmap)) {\r\nret = PTR_ERR(wm8994->regmap);\r\ndev_err(wm8994->dev, "Failed to allocate register map: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nreturn wm8994_device_init(wm8994, i2c->irq);\r\n}\r\nstatic int wm8994_i2c_remove(struct i2c_client *i2c)\r\n{\r\nstruct wm8994 *wm8994 = i2c_get_clientdata(i2c);\r\nwm8994_device_exit(wm8994);\r\nreturn 0;\r\n}
