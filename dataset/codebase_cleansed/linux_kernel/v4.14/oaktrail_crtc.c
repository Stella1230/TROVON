static const struct gma_limit_t *mrst_limit(struct drm_crtc *crtc,\r\nint refclk)\r\n{\r\nconst struct gma_limit_t *limit = NULL;\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nif (gma_pipe_has_type(crtc, INTEL_OUTPUT_LVDS)\r\n|| gma_pipe_has_type(crtc, INTEL_OUTPUT_MIPI)) {\r\nswitch (dev_priv->core_freq) {\r\ncase 100:\r\nlimit = &mrst_limits[MRST_LIMIT_LVDS_100L];\r\nbreak;\r\ncase 166:\r\nlimit = &mrst_limits[MRST_LIMIT_LVDS_83];\r\nbreak;\r\ncase 200:\r\nlimit = &mrst_limits[MRST_LIMIT_LVDS_100];\r\nbreak;\r\n}\r\n} else if (gma_pipe_has_type(crtc, INTEL_OUTPUT_SDVO)) {\r\nlimit = &mrst_limits[MRST_LIMIT_SDVO];\r\n} else {\r\nlimit = NULL;\r\ndev_err(dev->dev, "mrst_limit Wrong display type.\n");\r\n}\r\nreturn limit;\r\n}\r\nstatic void mrst_lvds_clock(int refclk, struct gma_clock_t *clock)\r\n{\r\nclock->dot = (refclk * clock->m) / (14 * clock->p1);\r\n}\r\nstatic void mrst_print_pll(struct gma_clock_t *clock)\r\n{\r\nDRM_DEBUG_DRIVER("dotclock=%d, m=%d, m1=%d, m2=%d, n=%d, p1=%d, p2=%d\n",\r\nclock->dot, clock->m, clock->m1, clock->m2, clock->n,\r\nclock->p1, clock->p2);\r\n}\r\nstatic bool mrst_sdvo_find_best_pll(const struct gma_limit_t *limit,\r\nstruct drm_crtc *crtc, int target,\r\nint refclk, struct gma_clock_t *best_clock)\r\n{\r\nstruct gma_clock_t clock;\r\nu32 target_vco, actual_freq;\r\ns32 freq_error, min_error = 100000;\r\nmemset(best_clock, 0, sizeof(*best_clock));\r\nfor (clock.m = limit->m.min; clock.m <= limit->m.max; clock.m++) {\r\nfor (clock.n = limit->n.min; clock.n <= limit->n.max;\r\nclock.n++) {\r\nfor (clock.p1 = limit->p1.min;\r\nclock.p1 <= limit->p1.max; clock.p1++) {\r\nclock.p = clock.p1 * limit->p2.p2_slow;\r\ntarget_vco = target * clock.p;\r\nif (target_vco > limit->vco.max)\r\nbreak;\r\nif (target_vco < limit->vco.min)\r\ncontinue;\r\nactual_freq = (refclk * clock.m) /\r\n(clock.n * clock.p);\r\nfreq_error = 10000 -\r\n((target * 10000) / actual_freq);\r\nif (freq_error < -min_error) {\r\nbreak;\r\n}\r\nif (freq_error < 0)\r\nfreq_error = -freq_error;\r\nif (freq_error < min_error) {\r\nmin_error = freq_error;\r\n*best_clock = clock;\r\n}\r\n}\r\n}\r\nif (min_error == 0)\r\nbreak;\r\n}\r\nreturn min_error == 0;\r\n}\r\nstatic bool mrst_lvds_find_best_pll(const struct gma_limit_t *limit,\r\nstruct drm_crtc *crtc, int target,\r\nint refclk, struct gma_clock_t *best_clock)\r\n{\r\nstruct gma_clock_t clock;\r\nint err = target;\r\nmemset(best_clock, 0, sizeof(*best_clock));\r\nfor (clock.m = limit->m.min; clock.m <= limit->m.max; clock.m++) {\r\nfor (clock.p1 = limit->p1.min; clock.p1 <= limit->p1.max;\r\nclock.p1++) {\r\nint this_err;\r\nmrst_lvds_clock(refclk, &clock);\r\nthis_err = abs(clock.dot - target);\r\nif (this_err < err) {\r\n*best_clock = clock;\r\nerr = this_err;\r\n}\r\n}\r\n}\r\nreturn err != target;\r\n}\r\nstatic void oaktrail_crtc_dpms(struct drm_crtc *crtc, int mode)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\r\nint pipe = gma_crtc->pipe;\r\nconst struct psb_offset *map = &dev_priv->regmap[pipe];\r\nu32 temp;\r\nint i;\r\nint need_aux = gma_pipe_has_type(crtc, INTEL_OUTPUT_SDVO) ? 1 : 0;\r\nif (gma_pipe_has_type(crtc, INTEL_OUTPUT_HDMI)) {\r\noaktrail_crtc_hdmi_dpms(crtc, mode);\r\nreturn;\r\n}\r\nif (!gma_power_begin(dev, true))\r\nreturn;\r\nswitch (mode) {\r\ncase DRM_MODE_DPMS_ON:\r\ncase DRM_MODE_DPMS_STANDBY:\r\ncase DRM_MODE_DPMS_SUSPEND:\r\nfor (i = 0; i <= need_aux; i++) {\r\ntemp = REG_READ_WITH_AUX(map->dpll, i);\r\nif ((temp & DPLL_VCO_ENABLE) == 0) {\r\nREG_WRITE_WITH_AUX(map->dpll, temp, i);\r\nREG_READ_WITH_AUX(map->dpll, i);\r\nudelay(150);\r\nREG_WRITE_WITH_AUX(map->dpll,\r\ntemp | DPLL_VCO_ENABLE, i);\r\nREG_READ_WITH_AUX(map->dpll, i);\r\nudelay(150);\r\nREG_WRITE_WITH_AUX(map->dpll,\r\ntemp | DPLL_VCO_ENABLE, i);\r\nREG_READ_WITH_AUX(map->dpll, i);\r\nudelay(150);\r\n}\r\ntemp = REG_READ_WITH_AUX(map->conf, i);\r\nif ((temp & PIPEACONF_ENABLE) == 0) {\r\nREG_WRITE_WITH_AUX(map->conf,\r\ntemp | PIPEACONF_ENABLE, i);\r\n}\r\ntemp = REG_READ_WITH_AUX(map->cntr, i);\r\nif ((temp & DISPLAY_PLANE_ENABLE) == 0) {\r\nREG_WRITE_WITH_AUX(map->cntr,\r\ntemp | DISPLAY_PLANE_ENABLE,\r\ni);\r\nREG_WRITE_WITH_AUX(map->base,\r\nREG_READ_WITH_AUX(map->base, i), i);\r\n}\r\n}\r\ngma_crtc_load_lut(crtc);\r\nbreak;\r\ncase DRM_MODE_DPMS_OFF:\r\nfor (i = 0; i <= need_aux; i++) {\r\nREG_WRITE_WITH_AUX(VGACNTRL, VGA_DISP_DISABLE, i);\r\ntemp = REG_READ_WITH_AUX(map->cntr, i);\r\nif ((temp & DISPLAY_PLANE_ENABLE) != 0) {\r\nREG_WRITE_WITH_AUX(map->cntr,\r\ntemp & ~DISPLAY_PLANE_ENABLE, i);\r\nREG_WRITE_WITH_AUX(map->base,\r\nREG_READ(map->base), i);\r\nREG_READ_WITH_AUX(map->base, i);\r\n}\r\ntemp = REG_READ_WITH_AUX(map->conf, i);\r\nif ((temp & PIPEACONF_ENABLE) != 0) {\r\nREG_WRITE_WITH_AUX(map->conf,\r\ntemp & ~PIPEACONF_ENABLE, i);\r\nREG_READ_WITH_AUX(map->conf, i);\r\n}\r\ngma_wait_for_vblank(dev);\r\ntemp = REG_READ_WITH_AUX(map->dpll, i);\r\nif ((temp & DPLL_VCO_ENABLE) != 0) {\r\nREG_WRITE_WITH_AUX(map->dpll,\r\ntemp & ~DPLL_VCO_ENABLE, i);\r\nREG_READ_WITH_AUX(map->dpll, i);\r\n}\r\nudelay(150);\r\n}\r\nbreak;\r\n}\r\nREG_WRITE(DSPARB, 0x3f80);\r\nREG_WRITE(DSPFW1, 0x3f8f0404);\r\nREG_WRITE(DSPFW2, 0x04040f04);\r\nREG_WRITE(DSPFW3, 0x0);\r\nREG_WRITE(DSPFW4, 0x04040404);\r\nREG_WRITE(DSPFW5, 0x04040404);\r\nREG_WRITE(DSPFW6, 0x78);\r\nREG_WRITE(DSPCHICKENBIT, REG_READ(DSPCHICKENBIT) | 0xc040);\r\ngma_power_end(dev);\r\n}\r\nstatic int oaktrail_panel_fitter_pipe(struct drm_device *dev)\r\n{\r\nu32 pfit_control;\r\npfit_control = REG_READ(PFIT_CONTROL);\r\nif ((pfit_control & PFIT_ENABLE) == 0)\r\nreturn -1;\r\nreturn (pfit_control >> 29) & 3;\r\n}\r\nstatic int oaktrail_crtc_mode_set(struct drm_crtc *crtc,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode,\r\nint x, int y,\r\nstruct drm_framebuffer *old_fb)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nint pipe = gma_crtc->pipe;\r\nconst struct psb_offset *map = &dev_priv->regmap[pipe];\r\nint refclk = 0;\r\nstruct gma_clock_t clock;\r\nconst struct gma_limit_t *limit;\r\nu32 dpll = 0, fp = 0, dspcntr, pipeconf;\r\nbool ok, is_sdvo = false;\r\nbool is_lvds = false;\r\nbool is_mipi = false;\r\nstruct drm_mode_config *mode_config = &dev->mode_config;\r\nstruct gma_encoder *gma_encoder = NULL;\r\nuint64_t scalingType = DRM_MODE_SCALE_FULLSCREEN;\r\nstruct drm_connector *connector;\r\nint i;\r\nint need_aux = gma_pipe_has_type(crtc, INTEL_OUTPUT_SDVO) ? 1 : 0;\r\nif (gma_pipe_has_type(crtc, INTEL_OUTPUT_HDMI))\r\nreturn oaktrail_crtc_hdmi_mode_set(crtc, mode, adjusted_mode, x, y, old_fb);\r\nif (!gma_power_begin(dev, true))\r\nreturn 0;\r\nmemcpy(&gma_crtc->saved_mode,\r\nmode,\r\nsizeof(struct drm_display_mode));\r\nmemcpy(&gma_crtc->saved_adjusted_mode,\r\nadjusted_mode,\r\nsizeof(struct drm_display_mode));\r\nlist_for_each_entry(connector, &mode_config->connector_list, head) {\r\nif (!connector->encoder || connector->encoder->crtc != crtc)\r\ncontinue;\r\ngma_encoder = gma_attached_encoder(connector);\r\nswitch (gma_encoder->type) {\r\ncase INTEL_OUTPUT_LVDS:\r\nis_lvds = true;\r\nbreak;\r\ncase INTEL_OUTPUT_SDVO:\r\nis_sdvo = true;\r\nbreak;\r\ncase INTEL_OUTPUT_MIPI:\r\nis_mipi = true;\r\nbreak;\r\n}\r\n}\r\nfor (i = 0; i <= need_aux; i++)\r\nREG_WRITE_WITH_AUX(VGACNTRL, VGA_DISP_DISABLE, i);\r\nif (oaktrail_panel_fitter_pipe(dev) == pipe)\r\nREG_WRITE(PFIT_CONTROL, 0);\r\nfor (i = 0; i <= need_aux; i++) {\r\nREG_WRITE_WITH_AUX(map->src, ((mode->crtc_hdisplay - 1) << 16) |\r\n(mode->crtc_vdisplay - 1), i);\r\n}\r\nif (gma_encoder)\r\ndrm_object_property_get_value(&connector->base,\r\ndev->mode_config.scaling_mode_property, &scalingType);\r\nif (scalingType == DRM_MODE_SCALE_NO_SCALE) {\r\nint offsetX = 0, offsetY = 0;\r\noffsetX = (adjusted_mode->crtc_hdisplay -\r\nmode->crtc_hdisplay) / 2;\r\noffsetY = (adjusted_mode->crtc_vdisplay -\r\nmode->crtc_vdisplay) / 2;\r\nfor (i = 0; i <= need_aux; i++) {\r\nREG_WRITE_WITH_AUX(map->htotal, (mode->crtc_hdisplay - 1) |\r\n((adjusted_mode->crtc_htotal - 1) << 16), i);\r\nREG_WRITE_WITH_AUX(map->vtotal, (mode->crtc_vdisplay - 1) |\r\n((adjusted_mode->crtc_vtotal - 1) << 16), i);\r\nREG_WRITE_WITH_AUX(map->hblank,\r\n(adjusted_mode->crtc_hblank_start - offsetX - 1) |\r\n((adjusted_mode->crtc_hblank_end - offsetX - 1) << 16), i);\r\nREG_WRITE_WITH_AUX(map->hsync,\r\n(adjusted_mode->crtc_hsync_start - offsetX - 1) |\r\n((adjusted_mode->crtc_hsync_end - offsetX - 1) << 16), i);\r\nREG_WRITE_WITH_AUX(map->vblank,\r\n(adjusted_mode->crtc_vblank_start - offsetY - 1) |\r\n((adjusted_mode->crtc_vblank_end - offsetY - 1) << 16), i);\r\nREG_WRITE_WITH_AUX(map->vsync,\r\n(adjusted_mode->crtc_vsync_start - offsetY - 1) |\r\n((adjusted_mode->crtc_vsync_end - offsetY - 1) << 16), i);\r\n}\r\n} else {\r\nfor (i = 0; i <= need_aux; i++) {\r\nREG_WRITE_WITH_AUX(map->htotal, (adjusted_mode->crtc_hdisplay - 1) |\r\n((adjusted_mode->crtc_htotal - 1) << 16), i);\r\nREG_WRITE_WITH_AUX(map->vtotal, (adjusted_mode->crtc_vdisplay - 1) |\r\n((adjusted_mode->crtc_vtotal - 1) << 16), i);\r\nREG_WRITE_WITH_AUX(map->hblank, (adjusted_mode->crtc_hblank_start - 1) |\r\n((adjusted_mode->crtc_hblank_end - 1) << 16), i);\r\nREG_WRITE_WITH_AUX(map->hsync, (adjusted_mode->crtc_hsync_start - 1) |\r\n((adjusted_mode->crtc_hsync_end - 1) << 16), i);\r\nREG_WRITE_WITH_AUX(map->vblank, (adjusted_mode->crtc_vblank_start - 1) |\r\n((adjusted_mode->crtc_vblank_end - 1) << 16), i);\r\nREG_WRITE_WITH_AUX(map->vsync, (adjusted_mode->crtc_vsync_start - 1) |\r\n((adjusted_mode->crtc_vsync_end - 1) << 16), i);\r\n}\r\n}\r\n{\r\nconst struct drm_crtc_helper_funcs *crtc_funcs =\r\ncrtc->helper_private;\r\ncrtc_funcs->mode_set_base(crtc, x, y, old_fb);\r\n}\r\npipeconf = REG_READ(map->conf);\r\ndspcntr = REG_READ(map->cntr);\r\ndspcntr |= DISPPLANE_GAMMA_ENABLE;\r\nif (pipe == 0)\r\ndspcntr |= DISPPLANE_SEL_PIPE_A;\r\nelse\r\ndspcntr |= DISPPLANE_SEL_PIPE_B;\r\nif (is_mipi)\r\ngoto oaktrail_crtc_mode_set_exit;\r\ndpll = 0;\r\nrefclk = is_sdvo ? 96000 : dev_priv->core_freq * 1000;\r\nlimit = mrst_limit(crtc, refclk);\r\nok = limit->find_pll(limit, crtc, adjusted_mode->clock,\r\nrefclk, &clock);\r\nif (is_sdvo) {\r\nclock.p1 = (1L << (clock.p1 - 1));\r\nclock.m -= 2;\r\nclock.n = (1L << (clock.n - 1));\r\n}\r\nif (!ok)\r\nDRM_ERROR("Failed to find proper PLL settings");\r\nmrst_print_pll(&clock);\r\nif (is_sdvo)\r\nfp = clock.n << 16 | clock.m;\r\nelse\r\nfp = oaktrail_m_converts[(clock.m - MRST_M_MIN)] << 8;\r\ndpll |= DPLL_VGA_MODE_DIS;\r\ndpll |= DPLL_VCO_ENABLE;\r\nif (is_lvds)\r\ndpll |= DPLLA_MODE_LVDS;\r\nelse\r\ndpll |= DPLLB_MODE_DAC_SERIAL;\r\nif (is_sdvo) {\r\nint sdvo_pixel_multiply =\r\nadjusted_mode->clock / mode->clock;\r\ndpll |= DPLL_DVO_HIGH_SPEED;\r\ndpll |=\r\n(sdvo_pixel_multiply -\r\n1) << SDVO_MULTIPLIER_SHIFT_HIRES;\r\n}\r\nif (is_sdvo)\r\ndpll |= clock.p1 << 16;\r\nelse\r\ndpll |= (1 << (clock.p1 - 2)) << 17;\r\ndpll |= DPLL_VCO_ENABLE;\r\nif (dpll & DPLL_VCO_ENABLE) {\r\nfor (i = 0; i <= need_aux; i++) {\r\nREG_WRITE_WITH_AUX(map->fp0, fp, i);\r\nREG_WRITE_WITH_AUX(map->dpll, dpll & ~DPLL_VCO_ENABLE, i);\r\nREG_READ_WITH_AUX(map->dpll, i);\r\nudelay(150);\r\n}\r\n}\r\nfor (i = 0; i <= need_aux; i++) {\r\nREG_WRITE_WITH_AUX(map->fp0, fp, i);\r\nREG_WRITE_WITH_AUX(map->dpll, dpll, i);\r\nREG_READ_WITH_AUX(map->dpll, i);\r\nudelay(150);\r\nREG_WRITE_WITH_AUX(map->dpll, dpll, i);\r\nREG_READ_WITH_AUX(map->dpll, i);\r\nudelay(150);\r\nREG_WRITE_WITH_AUX(map->conf, pipeconf, i);\r\nREG_READ_WITH_AUX(map->conf, i);\r\ngma_wait_for_vblank(dev);\r\nREG_WRITE_WITH_AUX(map->cntr, dspcntr, i);\r\ngma_wait_for_vblank(dev);\r\n}\r\noaktrail_crtc_mode_set_exit:\r\ngma_power_end(dev);\r\nreturn 0;\r\n}\r\nstatic int oaktrail_pipe_set_base(struct drm_crtc *crtc,\r\nint x, int y, struct drm_framebuffer *old_fb)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\r\nstruct drm_framebuffer *fb = crtc->primary->fb;\r\nstruct psb_framebuffer *psbfb = to_psb_fb(fb);\r\nint pipe = gma_crtc->pipe;\r\nconst struct psb_offset *map = &dev_priv->regmap[pipe];\r\nunsigned long start, offset;\r\nu32 dspcntr;\r\nint ret = 0;\r\nif (!fb) {\r\ndev_dbg(dev->dev, "No FB bound\n");\r\nreturn 0;\r\n}\r\nif (!gma_power_begin(dev, true))\r\nreturn 0;\r\nstart = psbfb->gtt->offset;\r\noffset = y * fb->pitches[0] + x * fb->format->cpp[0];\r\nREG_WRITE(map->stride, fb->pitches[0]);\r\ndspcntr = REG_READ(map->cntr);\r\ndspcntr &= ~DISPPLANE_PIXFORMAT_MASK;\r\nswitch (fb->format->cpp[0] * 8) {\r\ncase 8:\r\ndspcntr |= DISPPLANE_8BPP;\r\nbreak;\r\ncase 16:\r\nif (fb->format->depth == 15)\r\ndspcntr |= DISPPLANE_15_16BPP;\r\nelse\r\ndspcntr |= DISPPLANE_16BPP;\r\nbreak;\r\ncase 24:\r\ncase 32:\r\ndspcntr |= DISPPLANE_32BPP_NO_ALPHA;\r\nbreak;\r\ndefault:\r\ndev_err(dev->dev, "Unknown color depth\n");\r\nret = -EINVAL;\r\ngoto pipe_set_base_exit;\r\n}\r\nREG_WRITE(map->cntr, dspcntr);\r\nREG_WRITE(map->base, offset);\r\nREG_READ(map->base);\r\nREG_WRITE(map->surf, start);\r\nREG_READ(map->surf);\r\npipe_set_base_exit:\r\ngma_power_end(dev);\r\nreturn ret;\r\n}
