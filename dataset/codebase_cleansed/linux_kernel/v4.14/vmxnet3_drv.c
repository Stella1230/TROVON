static void\r\nvmxnet3_enable_intr(struct vmxnet3_adapter *adapter, unsigned intr_idx)\r\n{\r\nVMXNET3_WRITE_BAR0_REG(adapter, VMXNET3_REG_IMR + intr_idx * 8, 0);\r\n}\r\nstatic void\r\nvmxnet3_disable_intr(struct vmxnet3_adapter *adapter, unsigned intr_idx)\r\n{\r\nVMXNET3_WRITE_BAR0_REG(adapter, VMXNET3_REG_IMR + intr_idx * 8, 1);\r\n}\r\nstatic void\r\nvmxnet3_enable_all_intrs(struct vmxnet3_adapter *adapter)\r\n{\r\nint i;\r\nfor (i = 0; i < adapter->intr.num_intrs; i++)\r\nvmxnet3_enable_intr(adapter, i);\r\nadapter->shared->devRead.intrConf.intrCtrl &=\r\ncpu_to_le32(~VMXNET3_IC_DISABLE_ALL);\r\n}\r\nstatic void\r\nvmxnet3_disable_all_intrs(struct vmxnet3_adapter *adapter)\r\n{\r\nint i;\r\nadapter->shared->devRead.intrConf.intrCtrl |=\r\ncpu_to_le32(VMXNET3_IC_DISABLE_ALL);\r\nfor (i = 0; i < adapter->intr.num_intrs; i++)\r\nvmxnet3_disable_intr(adapter, i);\r\n}\r\nstatic void\r\nvmxnet3_ack_events(struct vmxnet3_adapter *adapter, u32 events)\r\n{\r\nVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_ECR, events);\r\n}\r\nstatic bool\r\nvmxnet3_tq_stopped(struct vmxnet3_tx_queue *tq, struct vmxnet3_adapter *adapter)\r\n{\r\nreturn tq->stopped;\r\n}\r\nstatic void\r\nvmxnet3_tq_start(struct vmxnet3_tx_queue *tq, struct vmxnet3_adapter *adapter)\r\n{\r\ntq->stopped = false;\r\nnetif_start_subqueue(adapter->netdev, tq - adapter->tx_queue);\r\n}\r\nstatic void\r\nvmxnet3_tq_wake(struct vmxnet3_tx_queue *tq, struct vmxnet3_adapter *adapter)\r\n{\r\ntq->stopped = false;\r\nnetif_wake_subqueue(adapter->netdev, (tq - adapter->tx_queue));\r\n}\r\nstatic void\r\nvmxnet3_tq_stop(struct vmxnet3_tx_queue *tq, struct vmxnet3_adapter *adapter)\r\n{\r\ntq->stopped = true;\r\ntq->num_stop++;\r\nnetif_stop_subqueue(adapter->netdev, (tq - adapter->tx_queue));\r\n}\r\nstatic void\r\nvmxnet3_check_link(struct vmxnet3_adapter *adapter, bool affectTxQueue)\r\n{\r\nu32 ret;\r\nint i;\r\nunsigned long flags;\r\nspin_lock_irqsave(&adapter->cmd_lock, flags);\r\nVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD, VMXNET3_CMD_GET_LINK);\r\nret = VMXNET3_READ_BAR1_REG(adapter, VMXNET3_REG_CMD);\r\nspin_unlock_irqrestore(&adapter->cmd_lock, flags);\r\nadapter->link_speed = ret >> 16;\r\nif (ret & 1) {\r\nnetdev_info(adapter->netdev, "NIC Link is Up %d Mbps\n",\r\nadapter->link_speed);\r\nnetif_carrier_on(adapter->netdev);\r\nif (affectTxQueue) {\r\nfor (i = 0; i < adapter->num_tx_queues; i++)\r\nvmxnet3_tq_start(&adapter->tx_queue[i],\r\nadapter);\r\n}\r\n} else {\r\nnetdev_info(adapter->netdev, "NIC Link is Down\n");\r\nnetif_carrier_off(adapter->netdev);\r\nif (affectTxQueue) {\r\nfor (i = 0; i < adapter->num_tx_queues; i++)\r\nvmxnet3_tq_stop(&adapter->tx_queue[i], adapter);\r\n}\r\n}\r\n}\r\nstatic void\r\nvmxnet3_process_events(struct vmxnet3_adapter *adapter)\r\n{\r\nint i;\r\nunsigned long flags;\r\nu32 events = le32_to_cpu(adapter->shared->ecr);\r\nif (!events)\r\nreturn;\r\nvmxnet3_ack_events(adapter, events);\r\nif (events & VMXNET3_ECR_LINK)\r\nvmxnet3_check_link(adapter, true);\r\nif (events & (VMXNET3_ECR_TQERR | VMXNET3_ECR_RQERR)) {\r\nspin_lock_irqsave(&adapter->cmd_lock, flags);\r\nVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,\r\nVMXNET3_CMD_GET_QUEUE_STATUS);\r\nspin_unlock_irqrestore(&adapter->cmd_lock, flags);\r\nfor (i = 0; i < adapter->num_tx_queues; i++)\r\nif (adapter->tqd_start[i].status.stopped)\r\ndev_err(&adapter->netdev->dev,\r\n"%s: tq[%d] error 0x%x\n",\r\nadapter->netdev->name, i, le32_to_cpu(\r\nadapter->tqd_start[i].status.error));\r\nfor (i = 0; i < adapter->num_rx_queues; i++)\r\nif (adapter->rqd_start[i].status.stopped)\r\ndev_err(&adapter->netdev->dev,\r\n"%s: rq[%d] error 0x%x\n",\r\nadapter->netdev->name, i,\r\nadapter->rqd_start[i].status.error);\r\nschedule_work(&adapter->work);\r\n}\r\n}\r\nstatic void vmxnet3_RxDescToCPU(const struct Vmxnet3_RxDesc *srcDesc,\r\nstruct Vmxnet3_RxDesc *dstDesc)\r\n{\r\nu32 *src = (u32 *)srcDesc + 2;\r\nu32 *dst = (u32 *)dstDesc + 2;\r\ndstDesc->addr = le64_to_cpu(srcDesc->addr);\r\n*dst = le32_to_cpu(*src);\r\ndstDesc->ext1 = le32_to_cpu(srcDesc->ext1);\r\n}\r\nstatic void vmxnet3_TxDescToLe(const struct Vmxnet3_TxDesc *srcDesc,\r\nstruct Vmxnet3_TxDesc *dstDesc)\r\n{\r\nint i;\r\nu32 *src = (u32 *)(srcDesc + 1);\r\nu32 *dst = (u32 *)(dstDesc + 1);\r\nfor (i = 2; i > 0; i--) {\r\nsrc--;\r\ndst--;\r\n*dst = cpu_to_le32(*src);\r\n}\r\n}\r\nstatic void vmxnet3_RxCompToCPU(const struct Vmxnet3_RxCompDesc *srcDesc,\r\nstruct Vmxnet3_RxCompDesc *dstDesc)\r\n{\r\nint i = 0;\r\nu32 *src = (u32 *)srcDesc;\r\nu32 *dst = (u32 *)dstDesc;\r\nfor (i = 0; i < sizeof(struct Vmxnet3_RxCompDesc) / sizeof(u32); i++) {\r\n*dst = le32_to_cpu(*src);\r\nsrc++;\r\ndst++;\r\n}\r\n}\r\nstatic u32 get_bitfield32(const __le32 *bitfield, u32 pos, u32 size)\r\n{\r\nu32 temp = le32_to_cpu(*bitfield);\r\nu32 mask = ((1 << size) - 1) << pos;\r\ntemp &= mask;\r\ntemp >>= pos;\r\nreturn temp;\r\n}\r\nstatic void\r\nvmxnet3_unmap_tx_buf(struct vmxnet3_tx_buf_info *tbi,\r\nstruct pci_dev *pdev)\r\n{\r\nif (tbi->map_type == VMXNET3_MAP_SINGLE)\r\ndma_unmap_single(&pdev->dev, tbi->dma_addr, tbi->len,\r\nPCI_DMA_TODEVICE);\r\nelse if (tbi->map_type == VMXNET3_MAP_PAGE)\r\ndma_unmap_page(&pdev->dev, tbi->dma_addr, tbi->len,\r\nPCI_DMA_TODEVICE);\r\nelse\r\nBUG_ON(tbi->map_type != VMXNET3_MAP_NONE);\r\ntbi->map_type = VMXNET3_MAP_NONE;\r\n}\r\nstatic int\r\nvmxnet3_unmap_pkt(u32 eop_idx, struct vmxnet3_tx_queue *tq,\r\nstruct pci_dev *pdev, struct vmxnet3_adapter *adapter)\r\n{\r\nstruct sk_buff *skb;\r\nint entries = 0;\r\nBUG_ON(tq->buf_info[eop_idx].sop_idx != tq->tx_ring.next2comp);\r\nBUG_ON(VMXNET3_TXDESC_GET_EOP(&(tq->tx_ring.base[eop_idx].txd)) != 1);\r\nskb = tq->buf_info[eop_idx].skb;\r\nBUG_ON(skb == NULL);\r\ntq->buf_info[eop_idx].skb = NULL;\r\nVMXNET3_INC_RING_IDX_ONLY(eop_idx, tq->tx_ring.size);\r\nwhile (tq->tx_ring.next2comp != eop_idx) {\r\nvmxnet3_unmap_tx_buf(tq->buf_info + tq->tx_ring.next2comp,\r\npdev);\r\nvmxnet3_cmd_ring_adv_next2comp(&tq->tx_ring);\r\nentries++;\r\n}\r\ndev_kfree_skb_any(skb);\r\nreturn entries;\r\n}\r\nstatic int\r\nvmxnet3_tq_tx_complete(struct vmxnet3_tx_queue *tq,\r\nstruct vmxnet3_adapter *adapter)\r\n{\r\nint completed = 0;\r\nunion Vmxnet3_GenericDesc *gdesc;\r\ngdesc = tq->comp_ring.base + tq->comp_ring.next2proc;\r\nwhile (VMXNET3_TCD_GET_GEN(&gdesc->tcd) == tq->comp_ring.gen) {\r\ncompleted += vmxnet3_unmap_pkt(VMXNET3_TCD_GET_TXIDX(\r\n&gdesc->tcd), tq, adapter->pdev,\r\nadapter);\r\nvmxnet3_comp_ring_adv_next2proc(&tq->comp_ring);\r\ngdesc = tq->comp_ring.base + tq->comp_ring.next2proc;\r\n}\r\nif (completed) {\r\nspin_lock(&tq->tx_lock);\r\nif (unlikely(vmxnet3_tq_stopped(tq, adapter) &&\r\nvmxnet3_cmd_ring_desc_avail(&tq->tx_ring) >\r\nVMXNET3_WAKE_QUEUE_THRESHOLD(tq) &&\r\nnetif_carrier_ok(adapter->netdev))) {\r\nvmxnet3_tq_wake(tq, adapter);\r\n}\r\nspin_unlock(&tq->tx_lock);\r\n}\r\nreturn completed;\r\n}\r\nstatic void\r\nvmxnet3_tq_cleanup(struct vmxnet3_tx_queue *tq,\r\nstruct vmxnet3_adapter *adapter)\r\n{\r\nint i;\r\nwhile (tq->tx_ring.next2comp != tq->tx_ring.next2fill) {\r\nstruct vmxnet3_tx_buf_info *tbi;\r\ntbi = tq->buf_info + tq->tx_ring.next2comp;\r\nvmxnet3_unmap_tx_buf(tbi, adapter->pdev);\r\nif (tbi->skb) {\r\ndev_kfree_skb_any(tbi->skb);\r\ntbi->skb = NULL;\r\n}\r\nvmxnet3_cmd_ring_adv_next2comp(&tq->tx_ring);\r\n}\r\nfor (i = 0; i < tq->tx_ring.size; i++) {\r\nBUG_ON(tq->buf_info[i].skb != NULL ||\r\ntq->buf_info[i].map_type != VMXNET3_MAP_NONE);\r\n}\r\ntq->tx_ring.gen = VMXNET3_INIT_GEN;\r\ntq->tx_ring.next2fill = tq->tx_ring.next2comp = 0;\r\ntq->comp_ring.gen = VMXNET3_INIT_GEN;\r\ntq->comp_ring.next2proc = 0;\r\n}\r\nstatic void\r\nvmxnet3_tq_destroy(struct vmxnet3_tx_queue *tq,\r\nstruct vmxnet3_adapter *adapter)\r\n{\r\nif (tq->tx_ring.base) {\r\ndma_free_coherent(&adapter->pdev->dev, tq->tx_ring.size *\r\nsizeof(struct Vmxnet3_TxDesc),\r\ntq->tx_ring.base, tq->tx_ring.basePA);\r\ntq->tx_ring.base = NULL;\r\n}\r\nif (tq->data_ring.base) {\r\ndma_free_coherent(&adapter->pdev->dev,\r\ntq->data_ring.size * tq->txdata_desc_size,\r\ntq->data_ring.base, tq->data_ring.basePA);\r\ntq->data_ring.base = NULL;\r\n}\r\nif (tq->comp_ring.base) {\r\ndma_free_coherent(&adapter->pdev->dev, tq->comp_ring.size *\r\nsizeof(struct Vmxnet3_TxCompDesc),\r\ntq->comp_ring.base, tq->comp_ring.basePA);\r\ntq->comp_ring.base = NULL;\r\n}\r\nif (tq->buf_info) {\r\ndma_free_coherent(&adapter->pdev->dev,\r\ntq->tx_ring.size * sizeof(tq->buf_info[0]),\r\ntq->buf_info, tq->buf_info_pa);\r\ntq->buf_info = NULL;\r\n}\r\n}\r\nvoid\r\nvmxnet3_tq_destroy_all(struct vmxnet3_adapter *adapter)\r\n{\r\nint i;\r\nfor (i = 0; i < adapter->num_tx_queues; i++)\r\nvmxnet3_tq_destroy(&adapter->tx_queue[i], adapter);\r\n}\r\nstatic void\r\nvmxnet3_tq_init(struct vmxnet3_tx_queue *tq,\r\nstruct vmxnet3_adapter *adapter)\r\n{\r\nint i;\r\nmemset(tq->tx_ring.base, 0, tq->tx_ring.size *\r\nsizeof(struct Vmxnet3_TxDesc));\r\ntq->tx_ring.next2fill = tq->tx_ring.next2comp = 0;\r\ntq->tx_ring.gen = VMXNET3_INIT_GEN;\r\nmemset(tq->data_ring.base, 0,\r\ntq->data_ring.size * tq->txdata_desc_size);\r\nmemset(tq->comp_ring.base, 0, tq->comp_ring.size *\r\nsizeof(struct Vmxnet3_TxCompDesc));\r\ntq->comp_ring.next2proc = 0;\r\ntq->comp_ring.gen = VMXNET3_INIT_GEN;\r\nmemset(tq->buf_info, 0, sizeof(tq->buf_info[0]) * tq->tx_ring.size);\r\nfor (i = 0; i < tq->tx_ring.size; i++)\r\ntq->buf_info[i].map_type = VMXNET3_MAP_NONE;\r\n}\r\nstatic int\r\nvmxnet3_tq_create(struct vmxnet3_tx_queue *tq,\r\nstruct vmxnet3_adapter *adapter)\r\n{\r\nsize_t sz;\r\nBUG_ON(tq->tx_ring.base || tq->data_ring.base ||\r\ntq->comp_ring.base || tq->buf_info);\r\ntq->tx_ring.base = dma_alloc_coherent(&adapter->pdev->dev,\r\ntq->tx_ring.size * sizeof(struct Vmxnet3_TxDesc),\r\n&tq->tx_ring.basePA, GFP_KERNEL);\r\nif (!tq->tx_ring.base) {\r\nnetdev_err(adapter->netdev, "failed to allocate tx ring\n");\r\ngoto err;\r\n}\r\ntq->data_ring.base = dma_alloc_coherent(&adapter->pdev->dev,\r\ntq->data_ring.size * tq->txdata_desc_size,\r\n&tq->data_ring.basePA, GFP_KERNEL);\r\nif (!tq->data_ring.base) {\r\nnetdev_err(adapter->netdev, "failed to allocate tx data ring\n");\r\ngoto err;\r\n}\r\ntq->comp_ring.base = dma_alloc_coherent(&adapter->pdev->dev,\r\ntq->comp_ring.size * sizeof(struct Vmxnet3_TxCompDesc),\r\n&tq->comp_ring.basePA, GFP_KERNEL);\r\nif (!tq->comp_ring.base) {\r\nnetdev_err(adapter->netdev, "failed to allocate tx comp ring\n");\r\ngoto err;\r\n}\r\nsz = tq->tx_ring.size * sizeof(tq->buf_info[0]);\r\ntq->buf_info = dma_zalloc_coherent(&adapter->pdev->dev, sz,\r\n&tq->buf_info_pa, GFP_KERNEL);\r\nif (!tq->buf_info)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nvmxnet3_tq_destroy(tq, adapter);\r\nreturn -ENOMEM;\r\n}\r\nstatic void\r\nvmxnet3_tq_cleanup_all(struct vmxnet3_adapter *adapter)\r\n{\r\nint i;\r\nfor (i = 0; i < adapter->num_tx_queues; i++)\r\nvmxnet3_tq_cleanup(&adapter->tx_queue[i], adapter);\r\n}\r\nstatic int\r\nvmxnet3_rq_alloc_rx_buf(struct vmxnet3_rx_queue *rq, u32 ring_idx,\r\nint num_to_alloc, struct vmxnet3_adapter *adapter)\r\n{\r\nint num_allocated = 0;\r\nstruct vmxnet3_rx_buf_info *rbi_base = rq->buf_info[ring_idx];\r\nstruct vmxnet3_cmd_ring *ring = &rq->rx_ring[ring_idx];\r\nu32 val;\r\nwhile (num_allocated <= num_to_alloc) {\r\nstruct vmxnet3_rx_buf_info *rbi;\r\nunion Vmxnet3_GenericDesc *gd;\r\nrbi = rbi_base + ring->next2fill;\r\ngd = ring->base + ring->next2fill;\r\nif (rbi->buf_type == VMXNET3_RX_BUF_SKB) {\r\nif (rbi->skb == NULL) {\r\nrbi->skb = __netdev_alloc_skb_ip_align(adapter->netdev,\r\nrbi->len,\r\nGFP_KERNEL);\r\nif (unlikely(rbi->skb == NULL)) {\r\nrq->stats.rx_buf_alloc_failure++;\r\nbreak;\r\n}\r\nrbi->dma_addr = dma_map_single(\r\n&adapter->pdev->dev,\r\nrbi->skb->data, rbi->len,\r\nPCI_DMA_FROMDEVICE);\r\nif (dma_mapping_error(&adapter->pdev->dev,\r\nrbi->dma_addr)) {\r\ndev_kfree_skb_any(rbi->skb);\r\nrq->stats.rx_buf_alloc_failure++;\r\nbreak;\r\n}\r\n} else {\r\n}\r\nval = VMXNET3_RXD_BTYPE_HEAD << VMXNET3_RXD_BTYPE_SHIFT;\r\n} else {\r\nBUG_ON(rbi->buf_type != VMXNET3_RX_BUF_PAGE ||\r\nrbi->len != PAGE_SIZE);\r\nif (rbi->page == NULL) {\r\nrbi->page = alloc_page(GFP_ATOMIC);\r\nif (unlikely(rbi->page == NULL)) {\r\nrq->stats.rx_buf_alloc_failure++;\r\nbreak;\r\n}\r\nrbi->dma_addr = dma_map_page(\r\n&adapter->pdev->dev,\r\nrbi->page, 0, PAGE_SIZE,\r\nPCI_DMA_FROMDEVICE);\r\nif (dma_mapping_error(&adapter->pdev->dev,\r\nrbi->dma_addr)) {\r\nput_page(rbi->page);\r\nrq->stats.rx_buf_alloc_failure++;\r\nbreak;\r\n}\r\n} else {\r\n}\r\nval = VMXNET3_RXD_BTYPE_BODY << VMXNET3_RXD_BTYPE_SHIFT;\r\n}\r\ngd->rxd.addr = cpu_to_le64(rbi->dma_addr);\r\ngd->dword[2] = cpu_to_le32((!ring->gen << VMXNET3_RXD_GEN_SHIFT)\r\n| val | rbi->len);\r\nif (num_allocated == num_to_alloc)\r\nbreak;\r\ngd->dword[2] |= cpu_to_le32(ring->gen << VMXNET3_RXD_GEN_SHIFT);\r\nnum_allocated++;\r\nvmxnet3_cmd_ring_adv_next2fill(ring);\r\n}\r\nnetdev_dbg(adapter->netdev,\r\n"alloc_rx_buf: %d allocated, next2fill %u, next2comp %u\n",\r\nnum_allocated, ring->next2fill, ring->next2comp);\r\nBUG_ON(num_allocated != 0 && ring->next2fill == ring->next2comp);\r\nreturn num_allocated;\r\n}\r\nstatic void\r\nvmxnet3_append_frag(struct sk_buff *skb, struct Vmxnet3_RxCompDesc *rcd,\r\nstruct vmxnet3_rx_buf_info *rbi)\r\n{\r\nstruct skb_frag_struct *frag = skb_shinfo(skb)->frags +\r\nskb_shinfo(skb)->nr_frags;\r\nBUG_ON(skb_shinfo(skb)->nr_frags >= MAX_SKB_FRAGS);\r\n__skb_frag_set_page(frag, rbi->page);\r\nfrag->page_offset = 0;\r\nskb_frag_size_set(frag, rcd->len);\r\nskb->data_len += rcd->len;\r\nskb->truesize += PAGE_SIZE;\r\nskb_shinfo(skb)->nr_frags++;\r\n}\r\nstatic int\r\nvmxnet3_map_pkt(struct sk_buff *skb, struct vmxnet3_tx_ctx *ctx,\r\nstruct vmxnet3_tx_queue *tq, struct pci_dev *pdev,\r\nstruct vmxnet3_adapter *adapter)\r\n{\r\nu32 dw2, len;\r\nunsigned long buf_offset;\r\nint i;\r\nunion Vmxnet3_GenericDesc *gdesc;\r\nstruct vmxnet3_tx_buf_info *tbi = NULL;\r\nBUG_ON(ctx->copy_size > skb_headlen(skb));\r\ndw2 = (tq->tx_ring.gen ^ 0x1) << VMXNET3_TXD_GEN_SHIFT;\r\nctx->sop_txd = tq->tx_ring.base + tq->tx_ring.next2fill;\r\ngdesc = ctx->sop_txd;\r\nif (ctx->copy_size) {\r\nctx->sop_txd->txd.addr = cpu_to_le64(tq->data_ring.basePA +\r\ntq->tx_ring.next2fill *\r\ntq->txdata_desc_size);\r\nctx->sop_txd->dword[2] = cpu_to_le32(dw2 | ctx->copy_size);\r\nctx->sop_txd->dword[3] = 0;\r\ntbi = tq->buf_info + tq->tx_ring.next2fill;\r\ntbi->map_type = VMXNET3_MAP_NONE;\r\nnetdev_dbg(adapter->netdev,\r\n"txd[%u]: 0x%Lx 0x%x 0x%x\n",\r\ntq->tx_ring.next2fill,\r\nle64_to_cpu(ctx->sop_txd->txd.addr),\r\nctx->sop_txd->dword[2], ctx->sop_txd->dword[3]);\r\nvmxnet3_cmd_ring_adv_next2fill(&tq->tx_ring);\r\ndw2 = tq->tx_ring.gen << VMXNET3_TXD_GEN_SHIFT;\r\n}\r\nlen = skb_headlen(skb) - ctx->copy_size;\r\nbuf_offset = ctx->copy_size;\r\nwhile (len) {\r\nu32 buf_size;\r\nif (len < VMXNET3_MAX_TX_BUF_SIZE) {\r\nbuf_size = len;\r\ndw2 |= len;\r\n} else {\r\nbuf_size = VMXNET3_MAX_TX_BUF_SIZE;\r\n}\r\ntbi = tq->buf_info + tq->tx_ring.next2fill;\r\ntbi->map_type = VMXNET3_MAP_SINGLE;\r\ntbi->dma_addr = dma_map_single(&adapter->pdev->dev,\r\nskb->data + buf_offset, buf_size,\r\nPCI_DMA_TODEVICE);\r\nif (dma_mapping_error(&adapter->pdev->dev, tbi->dma_addr))\r\nreturn -EFAULT;\r\ntbi->len = buf_size;\r\ngdesc = tq->tx_ring.base + tq->tx_ring.next2fill;\r\nBUG_ON(gdesc->txd.gen == tq->tx_ring.gen);\r\ngdesc->txd.addr = cpu_to_le64(tbi->dma_addr);\r\ngdesc->dword[2] = cpu_to_le32(dw2);\r\ngdesc->dword[3] = 0;\r\nnetdev_dbg(adapter->netdev,\r\n"txd[%u]: 0x%Lx 0x%x 0x%x\n",\r\ntq->tx_ring.next2fill, le64_to_cpu(gdesc->txd.addr),\r\nle32_to_cpu(gdesc->dword[2]), gdesc->dword[3]);\r\nvmxnet3_cmd_ring_adv_next2fill(&tq->tx_ring);\r\ndw2 = tq->tx_ring.gen << VMXNET3_TXD_GEN_SHIFT;\r\nlen -= buf_size;\r\nbuf_offset += buf_size;\r\n}\r\nfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\r\nconst struct skb_frag_struct *frag = &skb_shinfo(skb)->frags[i];\r\nu32 buf_size;\r\nbuf_offset = 0;\r\nlen = skb_frag_size(frag);\r\nwhile (len) {\r\ntbi = tq->buf_info + tq->tx_ring.next2fill;\r\nif (len < VMXNET3_MAX_TX_BUF_SIZE) {\r\nbuf_size = len;\r\ndw2 |= len;\r\n} else {\r\nbuf_size = VMXNET3_MAX_TX_BUF_SIZE;\r\n}\r\ntbi->map_type = VMXNET3_MAP_PAGE;\r\ntbi->dma_addr = skb_frag_dma_map(&adapter->pdev->dev, frag,\r\nbuf_offset, buf_size,\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(&adapter->pdev->dev, tbi->dma_addr))\r\nreturn -EFAULT;\r\ntbi->len = buf_size;\r\ngdesc = tq->tx_ring.base + tq->tx_ring.next2fill;\r\nBUG_ON(gdesc->txd.gen == tq->tx_ring.gen);\r\ngdesc->txd.addr = cpu_to_le64(tbi->dma_addr);\r\ngdesc->dword[2] = cpu_to_le32(dw2);\r\ngdesc->dword[3] = 0;\r\nnetdev_dbg(adapter->netdev,\r\n"txd[%u]: 0x%llx %u %u\n",\r\ntq->tx_ring.next2fill, le64_to_cpu(gdesc->txd.addr),\r\nle32_to_cpu(gdesc->dword[2]), gdesc->dword[3]);\r\nvmxnet3_cmd_ring_adv_next2fill(&tq->tx_ring);\r\ndw2 = tq->tx_ring.gen << VMXNET3_TXD_GEN_SHIFT;\r\nlen -= buf_size;\r\nbuf_offset += buf_size;\r\n}\r\n}\r\nctx->eop_txd = gdesc;\r\ntbi->skb = skb;\r\ntbi->sop_idx = ctx->sop_txd - tq->tx_ring.base;\r\nreturn 0;\r\n}\r\nstatic void\r\nvmxnet3_tq_init_all(struct vmxnet3_adapter *adapter)\r\n{\r\nint i;\r\nfor (i = 0; i < adapter->num_tx_queues; i++)\r\nvmxnet3_tq_init(&adapter->tx_queue[i], adapter);\r\n}\r\nstatic int\r\nvmxnet3_parse_hdr(struct sk_buff *skb, struct vmxnet3_tx_queue *tq,\r\nstruct vmxnet3_tx_ctx *ctx,\r\nstruct vmxnet3_adapter *adapter)\r\n{\r\nu8 protocol = 0;\r\nif (ctx->mss) {\r\nctx->eth_ip_hdr_size = skb_transport_offset(skb);\r\nctx->l4_hdr_size = tcp_hdrlen(skb);\r\nctx->copy_size = ctx->eth_ip_hdr_size + ctx->l4_hdr_size;\r\n} else {\r\nif (skb->ip_summed == CHECKSUM_PARTIAL) {\r\nctx->eth_ip_hdr_size = skb_checksum_start_offset(skb);\r\nif (ctx->ipv4) {\r\nconst struct iphdr *iph = ip_hdr(skb);\r\nprotocol = iph->protocol;\r\n} else if (ctx->ipv6) {\r\nconst struct ipv6hdr *ipv6h = ipv6_hdr(skb);\r\nprotocol = ipv6h->nexthdr;\r\n}\r\nswitch (protocol) {\r\ncase IPPROTO_TCP:\r\nctx->l4_hdr_size = tcp_hdrlen(skb);\r\nbreak;\r\ncase IPPROTO_UDP:\r\nctx->l4_hdr_size = sizeof(struct udphdr);\r\nbreak;\r\ndefault:\r\nctx->l4_hdr_size = 0;\r\nbreak;\r\n}\r\nctx->copy_size = min(ctx->eth_ip_hdr_size +\r\nctx->l4_hdr_size, skb->len);\r\n} else {\r\nctx->eth_ip_hdr_size = 0;\r\nctx->l4_hdr_size = 0;\r\nctx->copy_size = min_t(unsigned int,\r\ntq->txdata_desc_size,\r\nskb_headlen(skb));\r\n}\r\nif (skb->len <= VMXNET3_HDR_COPY_SIZE)\r\nctx->copy_size = skb->len;\r\nif (unlikely(!pskb_may_pull(skb, ctx->copy_size)))\r\ngoto err;\r\n}\r\nif (unlikely(ctx->copy_size > tq->txdata_desc_size)) {\r\ntq->stats.oversized_hdr++;\r\nctx->copy_size = 0;\r\nreturn 0;\r\n}\r\nreturn 1;\r\nerr:\r\nreturn -1;\r\n}\r\nstatic void\r\nvmxnet3_copy_hdr(struct sk_buff *skb, struct vmxnet3_tx_queue *tq,\r\nstruct vmxnet3_tx_ctx *ctx,\r\nstruct vmxnet3_adapter *adapter)\r\n{\r\nstruct Vmxnet3_TxDataDesc *tdd;\r\ntdd = (struct Vmxnet3_TxDataDesc *)((u8 *)tq->data_ring.base +\r\ntq->tx_ring.next2fill *\r\ntq->txdata_desc_size);\r\nmemcpy(tdd->data, skb->data, ctx->copy_size);\r\nnetdev_dbg(adapter->netdev,\r\n"copy %u bytes to dataRing[%u]\n",\r\nctx->copy_size, tq->tx_ring.next2fill);\r\n}\r\nstatic void\r\nvmxnet3_prepare_tso(struct sk_buff *skb,\r\nstruct vmxnet3_tx_ctx *ctx)\r\n{\r\nstruct tcphdr *tcph = tcp_hdr(skb);\r\nif (ctx->ipv4) {\r\nstruct iphdr *iph = ip_hdr(skb);\r\niph->check = 0;\r\ntcph->check = ~csum_tcpudp_magic(iph->saddr, iph->daddr, 0,\r\nIPPROTO_TCP, 0);\r\n} else if (ctx->ipv6) {\r\nstruct ipv6hdr *iph = ipv6_hdr(skb);\r\ntcph->check = ~csum_ipv6_magic(&iph->saddr, &iph->daddr, 0,\r\nIPPROTO_TCP, 0);\r\n}\r\n}\r\nstatic int txd_estimate(const struct sk_buff *skb)\r\n{\r\nint count = VMXNET3_TXD_NEEDED(skb_headlen(skb)) + 1;\r\nint i;\r\nfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\r\nconst struct skb_frag_struct *frag = &skb_shinfo(skb)->frags[i];\r\ncount += VMXNET3_TXD_NEEDED(skb_frag_size(frag));\r\n}\r\nreturn count;\r\n}\r\nstatic int\r\nvmxnet3_tq_xmit(struct sk_buff *skb, struct vmxnet3_tx_queue *tq,\r\nstruct vmxnet3_adapter *adapter, struct net_device *netdev)\r\n{\r\nint ret;\r\nu32 count;\r\nunsigned long flags;\r\nstruct vmxnet3_tx_ctx ctx;\r\nunion Vmxnet3_GenericDesc *gdesc;\r\n#ifdef __BIG_ENDIAN_BITFIELD\r\nunion Vmxnet3_GenericDesc tempTxDesc;\r\n#endif\r\ncount = txd_estimate(skb);\r\nctx.ipv4 = (vlan_get_protocol(skb) == cpu_to_be16(ETH_P_IP));\r\nctx.ipv6 = (vlan_get_protocol(skb) == cpu_to_be16(ETH_P_IPV6));\r\nctx.mss = skb_shinfo(skb)->gso_size;\r\nif (ctx.mss) {\r\nif (skb_header_cloned(skb)) {\r\nif (unlikely(pskb_expand_head(skb, 0, 0,\r\nGFP_ATOMIC) != 0)) {\r\ntq->stats.drop_tso++;\r\ngoto drop_pkt;\r\n}\r\ntq->stats.copy_skb_header++;\r\n}\r\nvmxnet3_prepare_tso(skb, &ctx);\r\n} else {\r\nif (unlikely(count > VMXNET3_MAX_TXD_PER_PKT)) {\r\nif (skb_linearize(skb) != 0) {\r\ntq->stats.drop_too_many_frags++;\r\ngoto drop_pkt;\r\n}\r\ntq->stats.linearized++;\r\ncount = VMXNET3_TXD_NEEDED(skb_headlen(skb)) + 1;\r\n}\r\n}\r\nret = vmxnet3_parse_hdr(skb, tq, &ctx, adapter);\r\nif (ret >= 0) {\r\nBUG_ON(ret <= 0 && ctx.copy_size != 0);\r\nif (ctx.mss) {\r\nif (unlikely(ctx.eth_ip_hdr_size + ctx.l4_hdr_size >\r\nVMXNET3_MAX_TX_BUF_SIZE)) {\r\ntq->stats.drop_oversized_hdr++;\r\ngoto drop_pkt;\r\n}\r\n} else {\r\nif (skb->ip_summed == CHECKSUM_PARTIAL) {\r\nif (unlikely(ctx.eth_ip_hdr_size +\r\nskb->csum_offset >\r\nVMXNET3_MAX_CSUM_OFFSET)) {\r\ntq->stats.drop_oversized_hdr++;\r\ngoto drop_pkt;\r\n}\r\n}\r\n}\r\n} else {\r\ntq->stats.drop_hdr_inspect_err++;\r\ngoto drop_pkt;\r\n}\r\nspin_lock_irqsave(&tq->tx_lock, flags);\r\nif (count > vmxnet3_cmd_ring_desc_avail(&tq->tx_ring)) {\r\ntq->stats.tx_ring_full++;\r\nnetdev_dbg(adapter->netdev,\r\n"tx queue stopped on %s, next2comp %u"\r\n" next2fill %u\n", adapter->netdev->name,\r\ntq->tx_ring.next2comp, tq->tx_ring.next2fill);\r\nvmxnet3_tq_stop(tq, adapter);\r\nspin_unlock_irqrestore(&tq->tx_lock, flags);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nvmxnet3_copy_hdr(skb, tq, &ctx, adapter);\r\nif (vmxnet3_map_pkt(skb, &ctx, tq, adapter->pdev, adapter))\r\ngoto unlock_drop_pkt;\r\nctx.eop_txd->dword[3] = cpu_to_le32(VMXNET3_TXD_CQ | VMXNET3_TXD_EOP);\r\n#ifdef __BIG_ENDIAN_BITFIELD\r\ngdesc = &tempTxDesc;\r\ngdesc->dword[2] = ctx.sop_txd->dword[2];\r\ngdesc->dword[3] = ctx.sop_txd->dword[3];\r\n#else\r\ngdesc = ctx.sop_txd;\r\n#endif\r\nif (ctx.mss) {\r\ngdesc->txd.hlen = ctx.eth_ip_hdr_size + ctx.l4_hdr_size;\r\ngdesc->txd.om = VMXNET3_OM_TSO;\r\ngdesc->txd.msscof = ctx.mss;\r\nle32_add_cpu(&tq->shared->txNumDeferred, (skb->len -\r\ngdesc->txd.hlen + ctx.mss - 1) / ctx.mss);\r\n} else {\r\nif (skb->ip_summed == CHECKSUM_PARTIAL) {\r\ngdesc->txd.hlen = ctx.eth_ip_hdr_size;\r\ngdesc->txd.om = VMXNET3_OM_CSUM;\r\ngdesc->txd.msscof = ctx.eth_ip_hdr_size +\r\nskb->csum_offset;\r\n} else {\r\ngdesc->txd.om = 0;\r\ngdesc->txd.msscof = 0;\r\n}\r\nle32_add_cpu(&tq->shared->txNumDeferred, 1);\r\n}\r\nif (skb_vlan_tag_present(skb)) {\r\ngdesc->txd.ti = 1;\r\ngdesc->txd.tci = skb_vlan_tag_get(skb);\r\n}\r\ngdesc->dword[2] = cpu_to_le32(le32_to_cpu(gdesc->dword[2]) ^\r\nVMXNET3_TXD_GEN);\r\n#ifdef __BIG_ENDIAN_BITFIELD\r\nvmxnet3_TxDescToLe((struct Vmxnet3_TxDesc *)gdesc,\r\n(struct Vmxnet3_TxDesc *)ctx.sop_txd);\r\ngdesc = ctx.sop_txd;\r\n#endif\r\nnetdev_dbg(adapter->netdev,\r\n"txd[%u]: SOP 0x%Lx 0x%x 0x%x\n",\r\n(u32)(ctx.sop_txd -\r\ntq->tx_ring.base), le64_to_cpu(gdesc->txd.addr),\r\nle32_to_cpu(gdesc->dword[2]), le32_to_cpu(gdesc->dword[3]));\r\nspin_unlock_irqrestore(&tq->tx_lock, flags);\r\nif (le32_to_cpu(tq->shared->txNumDeferred) >=\r\nle32_to_cpu(tq->shared->txThreshold)) {\r\ntq->shared->txNumDeferred = 0;\r\nVMXNET3_WRITE_BAR0_REG(adapter,\r\nVMXNET3_REG_TXPROD + tq->qid * 8,\r\ntq->tx_ring.next2fill);\r\n}\r\nreturn NETDEV_TX_OK;\r\nunlock_drop_pkt:\r\nspin_unlock_irqrestore(&tq->tx_lock, flags);\r\ndrop_pkt:\r\ntq->stats.drop_total++;\r\ndev_kfree_skb_any(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic netdev_tx_t\r\nvmxnet3_xmit_frame(struct sk_buff *skb, struct net_device *netdev)\r\n{\r\nstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\r\nBUG_ON(skb->queue_mapping > adapter->num_tx_queues);\r\nreturn vmxnet3_tq_xmit(skb,\r\n&adapter->tx_queue[skb->queue_mapping],\r\nadapter, netdev);\r\n}\r\nstatic void\r\nvmxnet3_rx_csum(struct vmxnet3_adapter *adapter,\r\nstruct sk_buff *skb,\r\nunion Vmxnet3_GenericDesc *gdesc)\r\n{\r\nif (!gdesc->rcd.cnc && adapter->netdev->features & NETIF_F_RXCSUM) {\r\nif (gdesc->rcd.v4 &&\r\n(le32_to_cpu(gdesc->dword[3]) &\r\nVMXNET3_RCD_CSUM_OK) == VMXNET3_RCD_CSUM_OK) {\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\nBUG_ON(!(gdesc->rcd.tcp || gdesc->rcd.udp));\r\nBUG_ON(gdesc->rcd.frg);\r\n} else if (gdesc->rcd.v6 && (le32_to_cpu(gdesc->dword[3]) &\r\n(1 << VMXNET3_RCD_TUC_SHIFT))) {\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\nBUG_ON(!(gdesc->rcd.tcp || gdesc->rcd.udp));\r\nBUG_ON(gdesc->rcd.frg);\r\n} else {\r\nif (gdesc->rcd.csum) {\r\nskb->csum = htons(gdesc->rcd.csum);\r\nskb->ip_summed = CHECKSUM_PARTIAL;\r\n} else {\r\nskb_checksum_none_assert(skb);\r\n}\r\n}\r\n} else {\r\nskb_checksum_none_assert(skb);\r\n}\r\n}\r\nstatic void\r\nvmxnet3_rx_error(struct vmxnet3_rx_queue *rq, struct Vmxnet3_RxCompDesc *rcd,\r\nstruct vmxnet3_rx_ctx *ctx, struct vmxnet3_adapter *adapter)\r\n{\r\nrq->stats.drop_err++;\r\nif (!rcd->fcs)\r\nrq->stats.drop_fcs++;\r\nrq->stats.drop_total++;\r\nif (ctx->skb)\r\ndev_kfree_skb_irq(ctx->skb);\r\nctx->skb = NULL;\r\n}\r\nstatic u32\r\nvmxnet3_get_hdr_len(struct vmxnet3_adapter *adapter, struct sk_buff *skb,\r\nunion Vmxnet3_GenericDesc *gdesc)\r\n{\r\nu32 hlen, maplen;\r\nunion {\r\nvoid *ptr;\r\nstruct ethhdr *eth;\r\nstruct iphdr *ipv4;\r\nstruct ipv6hdr *ipv6;\r\nstruct tcphdr *tcp;\r\n} hdr;\r\nBUG_ON(gdesc->rcd.tcp == 0);\r\nmaplen = skb_headlen(skb);\r\nif (unlikely(sizeof(struct iphdr) + sizeof(struct tcphdr) > maplen))\r\nreturn 0;\r\nhdr.eth = eth_hdr(skb);\r\nif (gdesc->rcd.v4) {\r\nBUG_ON(hdr.eth->h_proto != htons(ETH_P_IP));\r\nhdr.ptr += sizeof(struct ethhdr);\r\nBUG_ON(hdr.ipv4->protocol != IPPROTO_TCP);\r\nhlen = hdr.ipv4->ihl << 2;\r\nhdr.ptr += hdr.ipv4->ihl << 2;\r\n} else if (gdesc->rcd.v6) {\r\nBUG_ON(hdr.eth->h_proto != htons(ETH_P_IPV6));\r\nhdr.ptr += sizeof(struct ethhdr);\r\nif (hdr.ipv6->nexthdr != IPPROTO_TCP)\r\nreturn sizeof(struct ipv6hdr) + sizeof(struct tcphdr);\r\nhlen = sizeof(struct ipv6hdr);\r\nhdr.ptr += sizeof(struct ipv6hdr);\r\n} else {\r\nreturn 0;\r\n}\r\nif (hlen + sizeof(struct tcphdr) > maplen)\r\nreturn 0;\r\nreturn (hlen + (hdr.tcp->doff << 2));\r\n}\r\nstatic int\r\nvmxnet3_rq_rx_complete(struct vmxnet3_rx_queue *rq,\r\nstruct vmxnet3_adapter *adapter, int quota)\r\n{\r\nstatic const u32 rxprod_reg[2] = {\r\nVMXNET3_REG_RXPROD, VMXNET3_REG_RXPROD2\r\n};\r\nu32 num_pkts = 0;\r\nbool skip_page_frags = false;\r\nstruct Vmxnet3_RxCompDesc *rcd;\r\nstruct vmxnet3_rx_ctx *ctx = &rq->rx_ctx;\r\nu16 segCnt = 0, mss = 0;\r\n#ifdef __BIG_ENDIAN_BITFIELD\r\nstruct Vmxnet3_RxDesc rxCmdDesc;\r\nstruct Vmxnet3_RxCompDesc rxComp;\r\n#endif\r\nvmxnet3_getRxComp(rcd, &rq->comp_ring.base[rq->comp_ring.next2proc].rcd,\r\n&rxComp);\r\nwhile (rcd->gen == rq->comp_ring.gen) {\r\nstruct vmxnet3_rx_buf_info *rbi;\r\nstruct sk_buff *skb, *new_skb = NULL;\r\nstruct page *new_page = NULL;\r\ndma_addr_t new_dma_addr;\r\nint num_to_alloc;\r\nstruct Vmxnet3_RxDesc *rxd;\r\nu32 idx, ring_idx;\r\nstruct vmxnet3_cmd_ring *ring = NULL;\r\nif (num_pkts >= quota) {\r\nbreak;\r\n}\r\nBUG_ON(rcd->rqID != rq->qid && rcd->rqID != rq->qid2 &&\r\nrcd->rqID != rq->dataRingQid);\r\nidx = rcd->rxdIdx;\r\nring_idx = VMXNET3_GET_RING_IDX(adapter, rcd->rqID);\r\nring = rq->rx_ring + ring_idx;\r\nvmxnet3_getRxDesc(rxd, &rq->rx_ring[ring_idx].base[idx].rxd,\r\n&rxCmdDesc);\r\nrbi = rq->buf_info[ring_idx] + idx;\r\nBUG_ON(rxd->addr != rbi->dma_addr ||\r\nrxd->len != rbi->len);\r\nif (unlikely(rcd->eop && rcd->err)) {\r\nvmxnet3_rx_error(rq, rcd, ctx, adapter);\r\ngoto rcd_done;\r\n}\r\nif (rcd->sop) {\r\nbool rxDataRingUsed;\r\nu16 len;\r\nBUG_ON(rxd->btype != VMXNET3_RXD_BTYPE_HEAD ||\r\n(rcd->rqID != rq->qid &&\r\nrcd->rqID != rq->dataRingQid));\r\nBUG_ON(rbi->buf_type != VMXNET3_RX_BUF_SKB);\r\nBUG_ON(ctx->skb != NULL || rbi->skb == NULL);\r\nif (unlikely(rcd->len == 0)) {\r\nBUG_ON(!(rcd->sop && rcd->eop));\r\nnetdev_dbg(adapter->netdev,\r\n"rxRing[%u][%u] 0 length\n",\r\nring_idx, idx);\r\ngoto rcd_done;\r\n}\r\nskip_page_frags = false;\r\nctx->skb = rbi->skb;\r\nrxDataRingUsed =\r\nVMXNET3_RX_DATA_RING(adapter, rcd->rqID);\r\nlen = rxDataRingUsed ? rcd->len : rbi->len;\r\nnew_skb = netdev_alloc_skb_ip_align(adapter->netdev,\r\nlen);\r\nif (new_skb == NULL) {\r\nrq->stats.rx_buf_alloc_failure++;\r\nctx->skb = NULL;\r\nrq->stats.drop_total++;\r\nskip_page_frags = true;\r\ngoto rcd_done;\r\n}\r\nif (rxDataRingUsed) {\r\nsize_t sz;\r\nBUG_ON(rcd->len > rq->data_ring.desc_size);\r\nctx->skb = new_skb;\r\nsz = rcd->rxdIdx * rq->data_ring.desc_size;\r\nmemcpy(new_skb->data,\r\n&rq->data_ring.base[sz], rcd->len);\r\n} else {\r\nctx->skb = rbi->skb;\r\nnew_dma_addr =\r\ndma_map_single(&adapter->pdev->dev,\r\nnew_skb->data, rbi->len,\r\nPCI_DMA_FROMDEVICE);\r\nif (dma_mapping_error(&adapter->pdev->dev,\r\nnew_dma_addr)) {\r\ndev_kfree_skb(new_skb);\r\nrq->stats.rx_buf_alloc_failure++;\r\nctx->skb = NULL;\r\nrq->stats.drop_total++;\r\nskip_page_frags = true;\r\ngoto rcd_done;\r\n}\r\ndma_unmap_single(&adapter->pdev->dev,\r\nrbi->dma_addr,\r\nrbi->len,\r\nPCI_DMA_FROMDEVICE);\r\nrbi->skb = new_skb;\r\nrbi->dma_addr = new_dma_addr;\r\nrxd->addr = cpu_to_le64(rbi->dma_addr);\r\nrxd->len = rbi->len;\r\n}\r\n#ifdef VMXNET3_RSS\r\nif (rcd->rssType != VMXNET3_RCD_RSS_TYPE_NONE &&\r\n(adapter->netdev->features & NETIF_F_RXHASH))\r\nskb_set_hash(ctx->skb,\r\nle32_to_cpu(rcd->rssHash),\r\nPKT_HASH_TYPE_L3);\r\n#endif\r\nskb_put(ctx->skb, rcd->len);\r\nif (VMXNET3_VERSION_GE_2(adapter) &&\r\nrcd->type == VMXNET3_CDTYPE_RXCOMP_LRO) {\r\nstruct Vmxnet3_RxCompDescExt *rcdlro;\r\nrcdlro = (struct Vmxnet3_RxCompDescExt *)rcd;\r\nsegCnt = rcdlro->segCnt;\r\nWARN_ON_ONCE(segCnt == 0);\r\nmss = rcdlro->mss;\r\nif (unlikely(segCnt <= 1))\r\nsegCnt = 0;\r\n} else {\r\nsegCnt = 0;\r\n}\r\n} else {\r\nBUG_ON(ctx->skb == NULL && !skip_page_frags);\r\nBUG_ON(rbi->buf_type != VMXNET3_RX_BUF_PAGE);\r\nBUG_ON(rxd->btype != VMXNET3_RXD_BTYPE_BODY);\r\nif (skip_page_frags)\r\ngoto rcd_done;\r\nif (rcd->len) {\r\nnew_page = alloc_page(GFP_ATOMIC);\r\nif (unlikely(!new_page)) {\r\nrq->stats.rx_buf_alloc_failure++;\r\ndev_kfree_skb(ctx->skb);\r\nctx->skb = NULL;\r\nskip_page_frags = true;\r\ngoto rcd_done;\r\n}\r\nnew_dma_addr = dma_map_page(&adapter->pdev->dev,\r\nnew_page,\r\n0, PAGE_SIZE,\r\nPCI_DMA_FROMDEVICE);\r\nif (dma_mapping_error(&adapter->pdev->dev,\r\nnew_dma_addr)) {\r\nput_page(new_page);\r\nrq->stats.rx_buf_alloc_failure++;\r\ndev_kfree_skb(ctx->skb);\r\nctx->skb = NULL;\r\nskip_page_frags = true;\r\ngoto rcd_done;\r\n}\r\ndma_unmap_page(&adapter->pdev->dev,\r\nrbi->dma_addr, rbi->len,\r\nPCI_DMA_FROMDEVICE);\r\nvmxnet3_append_frag(ctx->skb, rcd, rbi);\r\nrbi->page = new_page;\r\nrbi->dma_addr = new_dma_addr;\r\nrxd->addr = cpu_to_le64(rbi->dma_addr);\r\nrxd->len = rbi->len;\r\n}\r\n}\r\nskb = ctx->skb;\r\nif (rcd->eop) {\r\nu32 mtu = adapter->netdev->mtu;\r\nskb->len += skb->data_len;\r\nvmxnet3_rx_csum(adapter, skb,\r\n(union Vmxnet3_GenericDesc *)rcd);\r\nskb->protocol = eth_type_trans(skb, adapter->netdev);\r\nif (!rcd->tcp || !adapter->lro)\r\ngoto not_lro;\r\nif (segCnt != 0 && mss != 0) {\r\nskb_shinfo(skb)->gso_type = rcd->v4 ?\r\nSKB_GSO_TCPV4 : SKB_GSO_TCPV6;\r\nskb_shinfo(skb)->gso_size = mss;\r\nskb_shinfo(skb)->gso_segs = segCnt;\r\n} else if (segCnt != 0 || skb->len > mtu) {\r\nu32 hlen;\r\nhlen = vmxnet3_get_hdr_len(adapter, skb,\r\n(union Vmxnet3_GenericDesc *)rcd);\r\nif (hlen == 0)\r\ngoto not_lro;\r\nskb_shinfo(skb)->gso_type =\r\nrcd->v4 ? SKB_GSO_TCPV4 : SKB_GSO_TCPV6;\r\nif (segCnt != 0) {\r\nskb_shinfo(skb)->gso_segs = segCnt;\r\nskb_shinfo(skb)->gso_size =\r\nDIV_ROUND_UP(skb->len -\r\nhlen, segCnt);\r\n} else {\r\nskb_shinfo(skb)->gso_size = mtu - hlen;\r\n}\r\n}\r\nnot_lro:\r\nif (unlikely(rcd->ts))\r\n__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), rcd->tci);\r\nif (adapter->netdev->features & NETIF_F_LRO)\r\nnetif_receive_skb(skb);\r\nelse\r\nnapi_gro_receive(&rq->napi, skb);\r\nctx->skb = NULL;\r\nnum_pkts++;\r\n}\r\nrcd_done:\r\nring->next2comp = idx;\r\nnum_to_alloc = vmxnet3_cmd_ring_desc_avail(ring);\r\nring = rq->rx_ring + ring_idx;\r\nwhile (num_to_alloc) {\r\nvmxnet3_getRxDesc(rxd, &ring->base[ring->next2fill].rxd,\r\n&rxCmdDesc);\r\nBUG_ON(!rxd->addr);\r\nrxd->gen = ring->gen;\r\nvmxnet3_cmd_ring_adv_next2fill(ring);\r\nnum_to_alloc--;\r\n}\r\nif (unlikely(rq->shared->updateRxProd)) {\r\nVMXNET3_WRITE_BAR0_REG(adapter,\r\nrxprod_reg[ring_idx] + rq->qid * 8,\r\nring->next2fill);\r\n}\r\nvmxnet3_comp_ring_adv_next2proc(&rq->comp_ring);\r\nvmxnet3_getRxComp(rcd,\r\n&rq->comp_ring.base[rq->comp_ring.next2proc].rcd, &rxComp);\r\n}\r\nreturn num_pkts;\r\n}\r\nstatic void\r\nvmxnet3_rq_cleanup(struct vmxnet3_rx_queue *rq,\r\nstruct vmxnet3_adapter *adapter)\r\n{\r\nu32 i, ring_idx;\r\nstruct Vmxnet3_RxDesc *rxd;\r\nfor (ring_idx = 0; ring_idx < 2; ring_idx++) {\r\nfor (i = 0; i < rq->rx_ring[ring_idx].size; i++) {\r\n#ifdef __BIG_ENDIAN_BITFIELD\r\nstruct Vmxnet3_RxDesc rxDesc;\r\n#endif\r\nvmxnet3_getRxDesc(rxd,\r\n&rq->rx_ring[ring_idx].base[i].rxd, &rxDesc);\r\nif (rxd->btype == VMXNET3_RXD_BTYPE_HEAD &&\r\nrq->buf_info[ring_idx][i].skb) {\r\ndma_unmap_single(&adapter->pdev->dev, rxd->addr,\r\nrxd->len, PCI_DMA_FROMDEVICE);\r\ndev_kfree_skb(rq->buf_info[ring_idx][i].skb);\r\nrq->buf_info[ring_idx][i].skb = NULL;\r\n} else if (rxd->btype == VMXNET3_RXD_BTYPE_BODY &&\r\nrq->buf_info[ring_idx][i].page) {\r\ndma_unmap_page(&adapter->pdev->dev, rxd->addr,\r\nrxd->len, PCI_DMA_FROMDEVICE);\r\nput_page(rq->buf_info[ring_idx][i].page);\r\nrq->buf_info[ring_idx][i].page = NULL;\r\n}\r\n}\r\nrq->rx_ring[ring_idx].gen = VMXNET3_INIT_GEN;\r\nrq->rx_ring[ring_idx].next2fill =\r\nrq->rx_ring[ring_idx].next2comp = 0;\r\n}\r\nrq->comp_ring.gen = VMXNET3_INIT_GEN;\r\nrq->comp_ring.next2proc = 0;\r\n}\r\nstatic void\r\nvmxnet3_rq_cleanup_all(struct vmxnet3_adapter *adapter)\r\n{\r\nint i;\r\nfor (i = 0; i < adapter->num_rx_queues; i++)\r\nvmxnet3_rq_cleanup(&adapter->rx_queue[i], adapter);\r\n}\r\nstatic void vmxnet3_rq_destroy(struct vmxnet3_rx_queue *rq,\r\nstruct vmxnet3_adapter *adapter)\r\n{\r\nint i;\r\nint j;\r\nfor (i = 0; i < 2; i++) {\r\nif (rq->buf_info[i]) {\r\nfor (j = 0; j < rq->rx_ring[i].size; j++)\r\nBUG_ON(rq->buf_info[i][j].page != NULL);\r\n}\r\n}\r\nfor (i = 0; i < 2; i++) {\r\nif (rq->rx_ring[i].base) {\r\ndma_free_coherent(&adapter->pdev->dev,\r\nrq->rx_ring[i].size\r\n* sizeof(struct Vmxnet3_RxDesc),\r\nrq->rx_ring[i].base,\r\nrq->rx_ring[i].basePA);\r\nrq->rx_ring[i].base = NULL;\r\n}\r\nrq->buf_info[i] = NULL;\r\n}\r\nif (rq->data_ring.base) {\r\ndma_free_coherent(&adapter->pdev->dev,\r\nrq->rx_ring[0].size * rq->data_ring.desc_size,\r\nrq->data_ring.base, rq->data_ring.basePA);\r\nrq->data_ring.base = NULL;\r\n}\r\nif (rq->comp_ring.base) {\r\ndma_free_coherent(&adapter->pdev->dev, rq->comp_ring.size\r\n* sizeof(struct Vmxnet3_RxCompDesc),\r\nrq->comp_ring.base, rq->comp_ring.basePA);\r\nrq->comp_ring.base = NULL;\r\n}\r\nif (rq->buf_info[0]) {\r\nsize_t sz = sizeof(struct vmxnet3_rx_buf_info) *\r\n(rq->rx_ring[0].size + rq->rx_ring[1].size);\r\ndma_free_coherent(&adapter->pdev->dev, sz, rq->buf_info[0],\r\nrq->buf_info_pa);\r\n}\r\n}\r\nstatic void\r\nvmxnet3_rq_destroy_all_rxdataring(struct vmxnet3_adapter *adapter)\r\n{\r\nint i;\r\nfor (i = 0; i < adapter->num_rx_queues; i++) {\r\nstruct vmxnet3_rx_queue *rq = &adapter->rx_queue[i];\r\nif (rq->data_ring.base) {\r\ndma_free_coherent(&adapter->pdev->dev,\r\n(rq->rx_ring[0].size *\r\nrq->data_ring.desc_size),\r\nrq->data_ring.base,\r\nrq->data_ring.basePA);\r\nrq->data_ring.base = NULL;\r\nrq->data_ring.desc_size = 0;\r\n}\r\n}\r\n}\r\nstatic int\r\nvmxnet3_rq_init(struct vmxnet3_rx_queue *rq,\r\nstruct vmxnet3_adapter *adapter)\r\n{\r\nint i;\r\nfor (i = 0; i < rq->rx_ring[0].size; i++) {\r\nif (i % adapter->rx_buf_per_pkt == 0) {\r\nrq->buf_info[0][i].buf_type = VMXNET3_RX_BUF_SKB;\r\nrq->buf_info[0][i].len = adapter->skb_buf_size;\r\n} else {\r\nrq->buf_info[0][i].buf_type = VMXNET3_RX_BUF_PAGE;\r\nrq->buf_info[0][i].len = PAGE_SIZE;\r\n}\r\n}\r\nfor (i = 0; i < rq->rx_ring[1].size; i++) {\r\nrq->buf_info[1][i].buf_type = VMXNET3_RX_BUF_PAGE;\r\nrq->buf_info[1][i].len = PAGE_SIZE;\r\n}\r\nfor (i = 0; i < 2; i++) {\r\nrq->rx_ring[i].next2fill = rq->rx_ring[i].next2comp = 0;\r\nmemset(rq->rx_ring[i].base, 0, rq->rx_ring[i].size *\r\nsizeof(struct Vmxnet3_RxDesc));\r\nrq->rx_ring[i].gen = VMXNET3_INIT_GEN;\r\n}\r\nif (vmxnet3_rq_alloc_rx_buf(rq, 0, rq->rx_ring[0].size - 1,\r\nadapter) == 0) {\r\nreturn -ENOMEM;\r\n}\r\nvmxnet3_rq_alloc_rx_buf(rq, 1, rq->rx_ring[1].size - 1, adapter);\r\nrq->comp_ring.next2proc = 0;\r\nmemset(rq->comp_ring.base, 0, rq->comp_ring.size *\r\nsizeof(struct Vmxnet3_RxCompDesc));\r\nrq->comp_ring.gen = VMXNET3_INIT_GEN;\r\nrq->rx_ctx.skb = NULL;\r\nreturn 0;\r\n}\r\nstatic int\r\nvmxnet3_rq_init_all(struct vmxnet3_adapter *adapter)\r\n{\r\nint i, err = 0;\r\nfor (i = 0; i < adapter->num_rx_queues; i++) {\r\nerr = vmxnet3_rq_init(&adapter->rx_queue[i], adapter);\r\nif (unlikely(err)) {\r\ndev_err(&adapter->netdev->dev, "%s: failed to "\r\n"initialize rx queue%i\n",\r\nadapter->netdev->name, i);\r\nbreak;\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic int\r\nvmxnet3_rq_create(struct vmxnet3_rx_queue *rq, struct vmxnet3_adapter *adapter)\r\n{\r\nint i;\r\nsize_t sz;\r\nstruct vmxnet3_rx_buf_info *bi;\r\nfor (i = 0; i < 2; i++) {\r\nsz = rq->rx_ring[i].size * sizeof(struct Vmxnet3_RxDesc);\r\nrq->rx_ring[i].base = dma_alloc_coherent(\r\n&adapter->pdev->dev, sz,\r\n&rq->rx_ring[i].basePA,\r\nGFP_KERNEL);\r\nif (!rq->rx_ring[i].base) {\r\nnetdev_err(adapter->netdev,\r\n"failed to allocate rx ring %d\n", i);\r\ngoto err;\r\n}\r\n}\r\nif ((adapter->rxdataring_enabled) && (rq->data_ring.desc_size != 0)) {\r\nsz = rq->rx_ring[0].size * rq->data_ring.desc_size;\r\nrq->data_ring.base =\r\ndma_alloc_coherent(&adapter->pdev->dev, sz,\r\n&rq->data_ring.basePA,\r\nGFP_KERNEL);\r\nif (!rq->data_ring.base) {\r\nnetdev_err(adapter->netdev,\r\n"rx data ring will be disabled\n");\r\nadapter->rxdataring_enabled = false;\r\n}\r\n} else {\r\nrq->data_ring.base = NULL;\r\nrq->data_ring.desc_size = 0;\r\n}\r\nsz = rq->comp_ring.size * sizeof(struct Vmxnet3_RxCompDesc);\r\nrq->comp_ring.base = dma_alloc_coherent(&adapter->pdev->dev, sz,\r\n&rq->comp_ring.basePA,\r\nGFP_KERNEL);\r\nif (!rq->comp_ring.base) {\r\nnetdev_err(adapter->netdev, "failed to allocate rx comp ring\n");\r\ngoto err;\r\n}\r\nsz = sizeof(struct vmxnet3_rx_buf_info) * (rq->rx_ring[0].size +\r\nrq->rx_ring[1].size);\r\nbi = dma_zalloc_coherent(&adapter->pdev->dev, sz, &rq->buf_info_pa,\r\nGFP_KERNEL);\r\nif (!bi)\r\ngoto err;\r\nrq->buf_info[0] = bi;\r\nrq->buf_info[1] = bi + rq->rx_ring[0].size;\r\nreturn 0;\r\nerr:\r\nvmxnet3_rq_destroy(rq, adapter);\r\nreturn -ENOMEM;\r\n}\r\nstatic int\r\nvmxnet3_rq_create_all(struct vmxnet3_adapter *adapter)\r\n{\r\nint i, err = 0;\r\nadapter->rxdataring_enabled = VMXNET3_VERSION_GE_3(adapter);\r\nfor (i = 0; i < adapter->num_rx_queues; i++) {\r\nerr = vmxnet3_rq_create(&adapter->rx_queue[i], adapter);\r\nif (unlikely(err)) {\r\ndev_err(&adapter->netdev->dev,\r\n"%s: failed to create rx queue%i\n",\r\nadapter->netdev->name, i);\r\ngoto err_out;\r\n}\r\n}\r\nif (!adapter->rxdataring_enabled)\r\nvmxnet3_rq_destroy_all_rxdataring(adapter);\r\nreturn err;\r\nerr_out:\r\nvmxnet3_rq_destroy_all(adapter);\r\nreturn err;\r\n}\r\nstatic int\r\nvmxnet3_do_poll(struct vmxnet3_adapter *adapter, int budget)\r\n{\r\nint rcd_done = 0, i;\r\nif (unlikely(adapter->shared->ecr))\r\nvmxnet3_process_events(adapter);\r\nfor (i = 0; i < adapter->num_tx_queues; i++)\r\nvmxnet3_tq_tx_complete(&adapter->tx_queue[i], adapter);\r\nfor (i = 0; i < adapter->num_rx_queues; i++)\r\nrcd_done += vmxnet3_rq_rx_complete(&adapter->rx_queue[i],\r\nadapter, budget);\r\nreturn rcd_done;\r\n}\r\nstatic int\r\nvmxnet3_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct vmxnet3_rx_queue *rx_queue = container_of(napi,\r\nstruct vmxnet3_rx_queue, napi);\r\nint rxd_done;\r\nrxd_done = vmxnet3_do_poll(rx_queue->adapter, budget);\r\nif (rxd_done < budget) {\r\nnapi_complete_done(napi, rxd_done);\r\nvmxnet3_enable_all_intrs(rx_queue->adapter);\r\n}\r\nreturn rxd_done;\r\n}\r\nstatic int\r\nvmxnet3_poll_rx_only(struct napi_struct *napi, int budget)\r\n{\r\nstruct vmxnet3_rx_queue *rq = container_of(napi,\r\nstruct vmxnet3_rx_queue, napi);\r\nstruct vmxnet3_adapter *adapter = rq->adapter;\r\nint rxd_done;\r\nif (adapter->share_intr == VMXNET3_INTR_BUDDYSHARE) {\r\nstruct vmxnet3_tx_queue *tq =\r\n&adapter->tx_queue[rq - adapter->rx_queue];\r\nvmxnet3_tq_tx_complete(tq, adapter);\r\n}\r\nrxd_done = vmxnet3_rq_rx_complete(rq, adapter, budget);\r\nif (rxd_done < budget) {\r\nnapi_complete_done(napi, rxd_done);\r\nvmxnet3_enable_intr(adapter, rq->comp_ring.intr_idx);\r\n}\r\nreturn rxd_done;\r\n}\r\nstatic irqreturn_t\r\nvmxnet3_msix_tx(int irq, void *data)\r\n{\r\nstruct vmxnet3_tx_queue *tq = data;\r\nstruct vmxnet3_adapter *adapter = tq->adapter;\r\nif (adapter->intr.mask_mode == VMXNET3_IMM_ACTIVE)\r\nvmxnet3_disable_intr(adapter, tq->comp_ring.intr_idx);\r\nif (adapter->share_intr == VMXNET3_INTR_TXSHARE) {\r\nint i;\r\nfor (i = 0; i < adapter->num_tx_queues; i++) {\r\nstruct vmxnet3_tx_queue *txq = &adapter->tx_queue[i];\r\nvmxnet3_tq_tx_complete(txq, adapter);\r\n}\r\n} else {\r\nvmxnet3_tq_tx_complete(tq, adapter);\r\n}\r\nvmxnet3_enable_intr(adapter, tq->comp_ring.intr_idx);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t\r\nvmxnet3_msix_rx(int irq, void *data)\r\n{\r\nstruct vmxnet3_rx_queue *rq = data;\r\nstruct vmxnet3_adapter *adapter = rq->adapter;\r\nif (adapter->intr.mask_mode == VMXNET3_IMM_ACTIVE)\r\nvmxnet3_disable_intr(adapter, rq->comp_ring.intr_idx);\r\nnapi_schedule(&rq->napi);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t\r\nvmxnet3_msix_event(int irq, void *data)\r\n{\r\nstruct net_device *dev = data;\r\nstruct vmxnet3_adapter *adapter = netdev_priv(dev);\r\nif (adapter->intr.mask_mode == VMXNET3_IMM_ACTIVE)\r\nvmxnet3_disable_intr(adapter, adapter->intr.event_intr_idx);\r\nif (adapter->shared->ecr)\r\nvmxnet3_process_events(adapter);\r\nvmxnet3_enable_intr(adapter, adapter->intr.event_intr_idx);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t\r\nvmxnet3_intr(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct vmxnet3_adapter *adapter = netdev_priv(dev);\r\nif (adapter->intr.type == VMXNET3_IT_INTX) {\r\nu32 icr = VMXNET3_READ_BAR1_REG(adapter, VMXNET3_REG_ICR);\r\nif (unlikely(icr == 0))\r\nreturn IRQ_NONE;\r\n}\r\nif (adapter->intr.mask_mode == VMXNET3_IMM_ACTIVE)\r\nvmxnet3_disable_all_intrs(adapter);\r\nnapi_schedule(&adapter->rx_queue[0].napi);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\nvmxnet3_netpoll(struct net_device *netdev)\r\n{\r\nstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\r\nswitch (adapter->intr.type) {\r\n#ifdef CONFIG_PCI_MSI\r\ncase VMXNET3_IT_MSIX: {\r\nint i;\r\nfor (i = 0; i < adapter->num_rx_queues; i++)\r\nvmxnet3_msix_rx(0, &adapter->rx_queue[i]);\r\nbreak;\r\n}\r\n#endif\r\ncase VMXNET3_IT_MSI:\r\ndefault:\r\nvmxnet3_intr(0, adapter->netdev);\r\nbreak;\r\n}\r\n}\r\nstatic int\r\nvmxnet3_request_irqs(struct vmxnet3_adapter *adapter)\r\n{\r\nstruct vmxnet3_intr *intr = &adapter->intr;\r\nint err = 0, i;\r\nint vector = 0;\r\n#ifdef CONFIG_PCI_MSI\r\nif (adapter->intr.type == VMXNET3_IT_MSIX) {\r\nfor (i = 0; i < adapter->num_tx_queues; i++) {\r\nif (adapter->share_intr != VMXNET3_INTR_BUDDYSHARE) {\r\nsprintf(adapter->tx_queue[i].name, "%s-tx-%d",\r\nadapter->netdev->name, vector);\r\nerr = request_irq(\r\nintr->msix_entries[vector].vector,\r\nvmxnet3_msix_tx, 0,\r\nadapter->tx_queue[i].name,\r\n&adapter->tx_queue[i]);\r\n} else {\r\nsprintf(adapter->tx_queue[i].name, "%s-rxtx-%d",\r\nadapter->netdev->name, vector);\r\n}\r\nif (err) {\r\ndev_err(&adapter->netdev->dev,\r\n"Failed to request irq for MSIX, %s, "\r\n"error %d\n",\r\nadapter->tx_queue[i].name, err);\r\nreturn err;\r\n}\r\nif (adapter->share_intr == VMXNET3_INTR_TXSHARE) {\r\nfor (; i < adapter->num_tx_queues; i++)\r\nadapter->tx_queue[i].comp_ring.intr_idx\r\n= vector;\r\nvector++;\r\nbreak;\r\n} else {\r\nadapter->tx_queue[i].comp_ring.intr_idx\r\n= vector++;\r\n}\r\n}\r\nif (adapter->share_intr == VMXNET3_INTR_BUDDYSHARE)\r\nvector = 0;\r\nfor (i = 0; i < adapter->num_rx_queues; i++) {\r\nif (adapter->share_intr != VMXNET3_INTR_BUDDYSHARE)\r\nsprintf(adapter->rx_queue[i].name, "%s-rx-%d",\r\nadapter->netdev->name, vector);\r\nelse\r\nsprintf(adapter->rx_queue[i].name, "%s-rxtx-%d",\r\nadapter->netdev->name, vector);\r\nerr = request_irq(intr->msix_entries[vector].vector,\r\nvmxnet3_msix_rx, 0,\r\nadapter->rx_queue[i].name,\r\n&(adapter->rx_queue[i]));\r\nif (err) {\r\nnetdev_err(adapter->netdev,\r\n"Failed to request irq for MSIX, "\r\n"%s, error %d\n",\r\nadapter->rx_queue[i].name, err);\r\nreturn err;\r\n}\r\nadapter->rx_queue[i].comp_ring.intr_idx = vector++;\r\n}\r\nsprintf(intr->event_msi_vector_name, "%s-event-%d",\r\nadapter->netdev->name, vector);\r\nerr = request_irq(intr->msix_entries[vector].vector,\r\nvmxnet3_msix_event, 0,\r\nintr->event_msi_vector_name, adapter->netdev);\r\nintr->event_intr_idx = vector;\r\n} else if (intr->type == VMXNET3_IT_MSI) {\r\nadapter->num_rx_queues = 1;\r\nerr = request_irq(adapter->pdev->irq, vmxnet3_intr, 0,\r\nadapter->netdev->name, adapter->netdev);\r\n} else {\r\n#endif\r\nadapter->num_rx_queues = 1;\r\nerr = request_irq(adapter->pdev->irq, vmxnet3_intr,\r\nIRQF_SHARED, adapter->netdev->name,\r\nadapter->netdev);\r\n#ifdef CONFIG_PCI_MSI\r\n}\r\n#endif\r\nintr->num_intrs = vector + 1;\r\nif (err) {\r\nnetdev_err(adapter->netdev,\r\n"Failed to request irq (intr type:%d), error %d\n",\r\nintr->type, err);\r\n} else {\r\nfor (i = 0; i < adapter->num_rx_queues; i++) {\r\nstruct vmxnet3_rx_queue *rq = &adapter->rx_queue[i];\r\nrq->qid = i;\r\nrq->qid2 = i + adapter->num_rx_queues;\r\nrq->dataRingQid = i + 2 * adapter->num_rx_queues;\r\n}\r\nfor (i = 0; i < intr->num_intrs; i++)\r\nintr->mod_levels[i] = UPT1_IML_ADAPTIVE;\r\nif (adapter->intr.type != VMXNET3_IT_MSIX) {\r\nadapter->intr.event_intr_idx = 0;\r\nfor (i = 0; i < adapter->num_tx_queues; i++)\r\nadapter->tx_queue[i].comp_ring.intr_idx = 0;\r\nadapter->rx_queue[0].comp_ring.intr_idx = 0;\r\n}\r\nnetdev_info(adapter->netdev,\r\n"intr type %u, mode %u, %u vectors allocated\n",\r\nintr->type, intr->mask_mode, intr->num_intrs);\r\n}\r\nreturn err;\r\n}\r\nstatic void\r\nvmxnet3_free_irqs(struct vmxnet3_adapter *adapter)\r\n{\r\nstruct vmxnet3_intr *intr = &adapter->intr;\r\nBUG_ON(intr->type == VMXNET3_IT_AUTO || intr->num_intrs <= 0);\r\nswitch (intr->type) {\r\n#ifdef CONFIG_PCI_MSI\r\ncase VMXNET3_IT_MSIX:\r\n{\r\nint i, vector = 0;\r\nif (adapter->share_intr != VMXNET3_INTR_BUDDYSHARE) {\r\nfor (i = 0; i < adapter->num_tx_queues; i++) {\r\nfree_irq(intr->msix_entries[vector++].vector,\r\n&(adapter->tx_queue[i]));\r\nif (adapter->share_intr == VMXNET3_INTR_TXSHARE)\r\nbreak;\r\n}\r\n}\r\nfor (i = 0; i < adapter->num_rx_queues; i++) {\r\nfree_irq(intr->msix_entries[vector++].vector,\r\n&(adapter->rx_queue[i]));\r\n}\r\nfree_irq(intr->msix_entries[vector].vector,\r\nadapter->netdev);\r\nBUG_ON(vector >= intr->num_intrs);\r\nbreak;\r\n}\r\n#endif\r\ncase VMXNET3_IT_MSI:\r\nfree_irq(adapter->pdev->irq, adapter->netdev);\r\nbreak;\r\ncase VMXNET3_IT_INTX:\r\nfree_irq(adapter->pdev->irq, adapter->netdev);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic void\r\nvmxnet3_restore_vlan(struct vmxnet3_adapter *adapter)\r\n{\r\nu32 *vfTable = adapter->shared->devRead.rxFilterConf.vfTable;\r\nu16 vid;\r\nVMXNET3_SET_VFTABLE_ENTRY(vfTable, 0);\r\nfor_each_set_bit(vid, adapter->active_vlans, VLAN_N_VID)\r\nVMXNET3_SET_VFTABLE_ENTRY(vfTable, vid);\r\n}\r\nstatic int\r\nvmxnet3_vlan_rx_add_vid(struct net_device *netdev, __be16 proto, u16 vid)\r\n{\r\nstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\r\nif (!(netdev->flags & IFF_PROMISC)) {\r\nu32 *vfTable = adapter->shared->devRead.rxFilterConf.vfTable;\r\nunsigned long flags;\r\nVMXNET3_SET_VFTABLE_ENTRY(vfTable, vid);\r\nspin_lock_irqsave(&adapter->cmd_lock, flags);\r\nVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,\r\nVMXNET3_CMD_UPDATE_VLAN_FILTERS);\r\nspin_unlock_irqrestore(&adapter->cmd_lock, flags);\r\n}\r\nset_bit(vid, adapter->active_vlans);\r\nreturn 0;\r\n}\r\nstatic int\r\nvmxnet3_vlan_rx_kill_vid(struct net_device *netdev, __be16 proto, u16 vid)\r\n{\r\nstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\r\nif (!(netdev->flags & IFF_PROMISC)) {\r\nu32 *vfTable = adapter->shared->devRead.rxFilterConf.vfTable;\r\nunsigned long flags;\r\nVMXNET3_CLEAR_VFTABLE_ENTRY(vfTable, vid);\r\nspin_lock_irqsave(&adapter->cmd_lock, flags);\r\nVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,\r\nVMXNET3_CMD_UPDATE_VLAN_FILTERS);\r\nspin_unlock_irqrestore(&adapter->cmd_lock, flags);\r\n}\r\nclear_bit(vid, adapter->active_vlans);\r\nreturn 0;\r\n}\r\nstatic u8 *\r\nvmxnet3_copy_mc(struct net_device *netdev)\r\n{\r\nu8 *buf = NULL;\r\nu32 sz = netdev_mc_count(netdev) * ETH_ALEN;\r\nif (sz <= 0xffff) {\r\nbuf = kmalloc(sz, GFP_ATOMIC);\r\nif (buf) {\r\nstruct netdev_hw_addr *ha;\r\nint i = 0;\r\nnetdev_for_each_mc_addr(ha, netdev)\r\nmemcpy(buf + i++ * ETH_ALEN, ha->addr,\r\nETH_ALEN);\r\n}\r\n}\r\nreturn buf;\r\n}\r\nstatic void\r\nvmxnet3_set_mc(struct net_device *netdev)\r\n{\r\nstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\r\nunsigned long flags;\r\nstruct Vmxnet3_RxFilterConf *rxConf =\r\n&adapter->shared->devRead.rxFilterConf;\r\nu8 *new_table = NULL;\r\ndma_addr_t new_table_pa = 0;\r\nbool new_table_pa_valid = false;\r\nu32 new_mode = VMXNET3_RXM_UCAST;\r\nif (netdev->flags & IFF_PROMISC) {\r\nu32 *vfTable = adapter->shared->devRead.rxFilterConf.vfTable;\r\nmemset(vfTable, 0, VMXNET3_VFT_SIZE * sizeof(*vfTable));\r\nnew_mode |= VMXNET3_RXM_PROMISC;\r\n} else {\r\nvmxnet3_restore_vlan(adapter);\r\n}\r\nif (netdev->flags & IFF_BROADCAST)\r\nnew_mode |= VMXNET3_RXM_BCAST;\r\nif (netdev->flags & IFF_ALLMULTI)\r\nnew_mode |= VMXNET3_RXM_ALL_MULTI;\r\nelse\r\nif (!netdev_mc_empty(netdev)) {\r\nnew_table = vmxnet3_copy_mc(netdev);\r\nif (new_table) {\r\nsize_t sz = netdev_mc_count(netdev) * ETH_ALEN;\r\nrxConf->mfTableLen = cpu_to_le16(sz);\r\nnew_table_pa = dma_map_single(\r\n&adapter->pdev->dev,\r\nnew_table,\r\nsz,\r\nPCI_DMA_TODEVICE);\r\nif (!dma_mapping_error(&adapter->pdev->dev,\r\nnew_table_pa)) {\r\nnew_mode |= VMXNET3_RXM_MCAST;\r\nnew_table_pa_valid = true;\r\nrxConf->mfTablePA = cpu_to_le64(\r\nnew_table_pa);\r\n}\r\n}\r\nif (!new_table_pa_valid) {\r\nnetdev_info(netdev,\r\n"failed to copy mcast list, setting ALL_MULTI\n");\r\nnew_mode |= VMXNET3_RXM_ALL_MULTI;\r\n}\r\n}\r\nif (!(new_mode & VMXNET3_RXM_MCAST)) {\r\nrxConf->mfTableLen = 0;\r\nrxConf->mfTablePA = 0;\r\n}\r\nspin_lock_irqsave(&adapter->cmd_lock, flags);\r\nif (new_mode != rxConf->rxMode) {\r\nrxConf->rxMode = cpu_to_le32(new_mode);\r\nVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,\r\nVMXNET3_CMD_UPDATE_RX_MODE);\r\nVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,\r\nVMXNET3_CMD_UPDATE_VLAN_FILTERS);\r\n}\r\nVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,\r\nVMXNET3_CMD_UPDATE_MAC_FILTERS);\r\nspin_unlock_irqrestore(&adapter->cmd_lock, flags);\r\nif (new_table_pa_valid)\r\ndma_unmap_single(&adapter->pdev->dev, new_table_pa,\r\nrxConf->mfTableLen, PCI_DMA_TODEVICE);\r\nkfree(new_table);\r\n}\r\nvoid\r\nvmxnet3_rq_destroy_all(struct vmxnet3_adapter *adapter)\r\n{\r\nint i;\r\nfor (i = 0; i < adapter->num_rx_queues; i++)\r\nvmxnet3_rq_destroy(&adapter->rx_queue[i], adapter);\r\n}\r\nstatic void\r\nvmxnet3_setup_driver_shared(struct vmxnet3_adapter *adapter)\r\n{\r\nstruct Vmxnet3_DriverShared *shared = adapter->shared;\r\nstruct Vmxnet3_DSDevRead *devRead = &shared->devRead;\r\nstruct Vmxnet3_TxQueueConf *tqc;\r\nstruct Vmxnet3_RxQueueConf *rqc;\r\nint i;\r\nmemset(shared, 0, sizeof(*shared));\r\nshared->magic = cpu_to_le32(VMXNET3_REV1_MAGIC);\r\ndevRead->misc.driverInfo.version = cpu_to_le32(\r\nVMXNET3_DRIVER_VERSION_NUM);\r\ndevRead->misc.driverInfo.gos.gosBits = (sizeof(void *) == 4 ?\r\nVMXNET3_GOS_BITS_32 : VMXNET3_GOS_BITS_64);\r\ndevRead->misc.driverInfo.gos.gosType = VMXNET3_GOS_TYPE_LINUX;\r\n*((u32 *)&devRead->misc.driverInfo.gos) = cpu_to_le32(\r\n*((u32 *)&devRead->misc.driverInfo.gos));\r\ndevRead->misc.driverInfo.vmxnet3RevSpt = cpu_to_le32(1);\r\ndevRead->misc.driverInfo.uptVerSpt = cpu_to_le32(1);\r\ndevRead->misc.ddPA = cpu_to_le64(adapter->adapter_pa);\r\ndevRead->misc.ddLen = cpu_to_le32(sizeof(struct vmxnet3_adapter));\r\nif (adapter->netdev->features & NETIF_F_RXCSUM)\r\ndevRead->misc.uptFeatures |= UPT1_F_RXCSUM;\r\nif (adapter->netdev->features & NETIF_F_LRO) {\r\ndevRead->misc.uptFeatures |= UPT1_F_LRO;\r\ndevRead->misc.maxNumRxSG = cpu_to_le16(1 + MAX_SKB_FRAGS);\r\n}\r\nif (adapter->netdev->features & NETIF_F_HW_VLAN_CTAG_RX)\r\ndevRead->misc.uptFeatures |= UPT1_F_RXVLAN;\r\ndevRead->misc.mtu = cpu_to_le32(adapter->netdev->mtu);\r\ndevRead->misc.queueDescPA = cpu_to_le64(adapter->queue_desc_pa);\r\ndevRead->misc.queueDescLen = cpu_to_le32(\r\nadapter->num_tx_queues * sizeof(struct Vmxnet3_TxQueueDesc) +\r\nadapter->num_rx_queues * sizeof(struct Vmxnet3_RxQueueDesc));\r\ndevRead->misc.numTxQueues = adapter->num_tx_queues;\r\nfor (i = 0; i < adapter->num_tx_queues; i++) {\r\nstruct vmxnet3_tx_queue *tq = &adapter->tx_queue[i];\r\nBUG_ON(adapter->tx_queue[i].tx_ring.base == NULL);\r\ntqc = &adapter->tqd_start[i].conf;\r\ntqc->txRingBasePA = cpu_to_le64(tq->tx_ring.basePA);\r\ntqc->dataRingBasePA = cpu_to_le64(tq->data_ring.basePA);\r\ntqc->compRingBasePA = cpu_to_le64(tq->comp_ring.basePA);\r\ntqc->ddPA = cpu_to_le64(tq->buf_info_pa);\r\ntqc->txRingSize = cpu_to_le32(tq->tx_ring.size);\r\ntqc->dataRingSize = cpu_to_le32(tq->data_ring.size);\r\ntqc->txDataRingDescSize = cpu_to_le32(tq->txdata_desc_size);\r\ntqc->compRingSize = cpu_to_le32(tq->comp_ring.size);\r\ntqc->ddLen = cpu_to_le32(\r\nsizeof(struct vmxnet3_tx_buf_info) *\r\ntqc->txRingSize);\r\ntqc->intrIdx = tq->comp_ring.intr_idx;\r\n}\r\ndevRead->misc.numRxQueues = adapter->num_rx_queues;\r\nfor (i = 0; i < adapter->num_rx_queues; i++) {\r\nstruct vmxnet3_rx_queue *rq = &adapter->rx_queue[i];\r\nrqc = &adapter->rqd_start[i].conf;\r\nrqc->rxRingBasePA[0] = cpu_to_le64(rq->rx_ring[0].basePA);\r\nrqc->rxRingBasePA[1] = cpu_to_le64(rq->rx_ring[1].basePA);\r\nrqc->compRingBasePA = cpu_to_le64(rq->comp_ring.basePA);\r\nrqc->ddPA = cpu_to_le64(rq->buf_info_pa);\r\nrqc->rxRingSize[0] = cpu_to_le32(rq->rx_ring[0].size);\r\nrqc->rxRingSize[1] = cpu_to_le32(rq->rx_ring[1].size);\r\nrqc->compRingSize = cpu_to_le32(rq->comp_ring.size);\r\nrqc->ddLen = cpu_to_le32(\r\nsizeof(struct vmxnet3_rx_buf_info) *\r\n(rqc->rxRingSize[0] +\r\nrqc->rxRingSize[1]));\r\nrqc->intrIdx = rq->comp_ring.intr_idx;\r\nif (VMXNET3_VERSION_GE_3(adapter)) {\r\nrqc->rxDataRingBasePA =\r\ncpu_to_le64(rq->data_ring.basePA);\r\nrqc->rxDataRingDescSize =\r\ncpu_to_le16(rq->data_ring.desc_size);\r\n}\r\n}\r\n#ifdef VMXNET3_RSS\r\nmemset(adapter->rss_conf, 0, sizeof(*adapter->rss_conf));\r\nif (adapter->rss) {\r\nstruct UPT1_RSSConf *rssConf = adapter->rss_conf;\r\ndevRead->misc.uptFeatures |= UPT1_F_RSS;\r\ndevRead->misc.numRxQueues = adapter->num_rx_queues;\r\nrssConf->hashType = UPT1_RSS_HASH_TYPE_TCP_IPV4 |\r\nUPT1_RSS_HASH_TYPE_IPV4 |\r\nUPT1_RSS_HASH_TYPE_TCP_IPV6 |\r\nUPT1_RSS_HASH_TYPE_IPV6;\r\nrssConf->hashFunc = UPT1_RSS_HASH_FUNC_TOEPLITZ;\r\nrssConf->hashKeySize = UPT1_RSS_MAX_KEY_SIZE;\r\nrssConf->indTableSize = VMXNET3_RSS_IND_TABLE_SIZE;\r\nnetdev_rss_key_fill(rssConf->hashKey, sizeof(rssConf->hashKey));\r\nfor (i = 0; i < rssConf->indTableSize; i++)\r\nrssConf->indTable[i] = ethtool_rxfh_indir_default(\r\ni, adapter->num_rx_queues);\r\ndevRead->rssConfDesc.confVer = 1;\r\ndevRead->rssConfDesc.confLen = cpu_to_le32(sizeof(*rssConf));\r\ndevRead->rssConfDesc.confPA =\r\ncpu_to_le64(adapter->rss_conf_pa);\r\n}\r\n#endif\r\ndevRead->intrConf.autoMask = adapter->intr.mask_mode ==\r\nVMXNET3_IMM_AUTO;\r\ndevRead->intrConf.numIntrs = adapter->intr.num_intrs;\r\nfor (i = 0; i < adapter->intr.num_intrs; i++)\r\ndevRead->intrConf.modLevels[i] = adapter->intr.mod_levels[i];\r\ndevRead->intrConf.eventIntrIdx = adapter->intr.event_intr_idx;\r\ndevRead->intrConf.intrCtrl |= cpu_to_le32(VMXNET3_IC_DISABLE_ALL);\r\ndevRead->rxFilterConf.rxMode = 0;\r\nvmxnet3_restore_vlan(adapter);\r\nvmxnet3_write_mac_addr(adapter, adapter->netdev->dev_addr);\r\n}\r\nstatic void\r\nvmxnet3_init_coalesce(struct vmxnet3_adapter *adapter)\r\n{\r\nstruct Vmxnet3_DriverShared *shared = adapter->shared;\r\nunion Vmxnet3_CmdInfo *cmdInfo = &shared->cu.cmdInfo;\r\nunsigned long flags;\r\nif (!VMXNET3_VERSION_GE_3(adapter))\r\nreturn;\r\nspin_lock_irqsave(&adapter->cmd_lock, flags);\r\ncmdInfo->varConf.confVer = 1;\r\ncmdInfo->varConf.confLen =\r\ncpu_to_le32(sizeof(*adapter->coal_conf));\r\ncmdInfo->varConf.confPA = cpu_to_le64(adapter->coal_conf_pa);\r\nif (adapter->default_coal_mode) {\r\nVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,\r\nVMXNET3_CMD_GET_COALESCE);\r\n} else {\r\nVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,\r\nVMXNET3_CMD_SET_COALESCE);\r\n}\r\nspin_unlock_irqrestore(&adapter->cmd_lock, flags);\r\n}\r\nint\r\nvmxnet3_activate_dev(struct vmxnet3_adapter *adapter)\r\n{\r\nint err, i;\r\nu32 ret;\r\nunsigned long flags;\r\nnetdev_dbg(adapter->netdev, "%s: skb_buf_size %d, rx_buf_per_pkt %d,"\r\n" ring sizes %u %u %u\n", adapter->netdev->name,\r\nadapter->skb_buf_size, adapter->rx_buf_per_pkt,\r\nadapter->tx_queue[0].tx_ring.size,\r\nadapter->rx_queue[0].rx_ring[0].size,\r\nadapter->rx_queue[0].rx_ring[1].size);\r\nvmxnet3_tq_init_all(adapter);\r\nerr = vmxnet3_rq_init_all(adapter);\r\nif (err) {\r\nnetdev_err(adapter->netdev,\r\n"Failed to init rx queue error %d\n", err);\r\ngoto rq_err;\r\n}\r\nerr = vmxnet3_request_irqs(adapter);\r\nif (err) {\r\nnetdev_err(adapter->netdev,\r\n"Failed to setup irq for error %d\n", err);\r\ngoto irq_err;\r\n}\r\nvmxnet3_setup_driver_shared(adapter);\r\nVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_DSAL, VMXNET3_GET_ADDR_LO(\r\nadapter->shared_pa));\r\nVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_DSAH, VMXNET3_GET_ADDR_HI(\r\nadapter->shared_pa));\r\nspin_lock_irqsave(&adapter->cmd_lock, flags);\r\nVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,\r\nVMXNET3_CMD_ACTIVATE_DEV);\r\nret = VMXNET3_READ_BAR1_REG(adapter, VMXNET3_REG_CMD);\r\nspin_unlock_irqrestore(&adapter->cmd_lock, flags);\r\nif (ret != 0) {\r\nnetdev_err(adapter->netdev,\r\n"Failed to activate dev: error %u\n", ret);\r\nerr = -EINVAL;\r\ngoto activate_err;\r\n}\r\nvmxnet3_init_coalesce(adapter);\r\nfor (i = 0; i < adapter->num_rx_queues; i++) {\r\nVMXNET3_WRITE_BAR0_REG(adapter,\r\nVMXNET3_REG_RXPROD + i * VMXNET3_REG_ALIGN,\r\nadapter->rx_queue[i].rx_ring[0].next2fill);\r\nVMXNET3_WRITE_BAR0_REG(adapter, (VMXNET3_REG_RXPROD2 +\r\n(i * VMXNET3_REG_ALIGN)),\r\nadapter->rx_queue[i].rx_ring[1].next2fill);\r\n}\r\nvmxnet3_set_mc(adapter->netdev);\r\nvmxnet3_check_link(adapter, true);\r\nfor (i = 0; i < adapter->num_rx_queues; i++)\r\nnapi_enable(&adapter->rx_queue[i].napi);\r\nvmxnet3_enable_all_intrs(adapter);\r\nclear_bit(VMXNET3_STATE_BIT_QUIESCED, &adapter->state);\r\nreturn 0;\r\nactivate_err:\r\nVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_DSAL, 0);\r\nVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_DSAH, 0);\r\nvmxnet3_free_irqs(adapter);\r\nirq_err:\r\nrq_err:\r\nvmxnet3_rq_cleanup_all(adapter);\r\nreturn err;\r\n}\r\nvoid\r\nvmxnet3_reset_dev(struct vmxnet3_adapter *adapter)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&adapter->cmd_lock, flags);\r\nVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD, VMXNET3_CMD_RESET_DEV);\r\nspin_unlock_irqrestore(&adapter->cmd_lock, flags);\r\n}\r\nint\r\nvmxnet3_quiesce_dev(struct vmxnet3_adapter *adapter)\r\n{\r\nint i;\r\nunsigned long flags;\r\nif (test_and_set_bit(VMXNET3_STATE_BIT_QUIESCED, &adapter->state))\r\nreturn 0;\r\nspin_lock_irqsave(&adapter->cmd_lock, flags);\r\nVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,\r\nVMXNET3_CMD_QUIESCE_DEV);\r\nspin_unlock_irqrestore(&adapter->cmd_lock, flags);\r\nvmxnet3_disable_all_intrs(adapter);\r\nfor (i = 0; i < adapter->num_rx_queues; i++)\r\nnapi_disable(&adapter->rx_queue[i].napi);\r\nnetif_tx_disable(adapter->netdev);\r\nadapter->link_speed = 0;\r\nnetif_carrier_off(adapter->netdev);\r\nvmxnet3_tq_cleanup_all(adapter);\r\nvmxnet3_rq_cleanup_all(adapter);\r\nvmxnet3_free_irqs(adapter);\r\nreturn 0;\r\n}\r\nstatic void\r\nvmxnet3_write_mac_addr(struct vmxnet3_adapter *adapter, u8 *mac)\r\n{\r\nu32 tmp;\r\ntmp = *(u32 *)mac;\r\nVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_MACL, tmp);\r\ntmp = (mac[5] << 8) | mac[4];\r\nVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_MACH, tmp);\r\n}\r\nstatic int\r\nvmxnet3_set_mac_addr(struct net_device *netdev, void *p)\r\n{\r\nstruct sockaddr *addr = p;\r\nstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\r\nmemcpy(netdev->dev_addr, addr->sa_data, netdev->addr_len);\r\nvmxnet3_write_mac_addr(adapter, addr->sa_data);\r\nreturn 0;\r\n}\r\nstatic int\r\nvmxnet3_alloc_pci_resources(struct vmxnet3_adapter *adapter, bool *dma64)\r\n{\r\nint err;\r\nunsigned long mmio_start, mmio_len;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nerr = pci_enable_device(pdev);\r\nif (err) {\r\ndev_err(&pdev->dev, "Failed to enable adapter: error %d\n", err);\r\nreturn err;\r\n}\r\nif (pci_set_dma_mask(pdev, DMA_BIT_MASK(64)) == 0) {\r\nif (pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(64)) != 0) {\r\ndev_err(&pdev->dev,\r\n"pci_set_consistent_dma_mask failed\n");\r\nerr = -EIO;\r\ngoto err_set_mask;\r\n}\r\n*dma64 = true;\r\n} else {\r\nif (pci_set_dma_mask(pdev, DMA_BIT_MASK(32)) != 0) {\r\ndev_err(&pdev->dev,\r\n"pci_set_dma_mask failed\n");\r\nerr = -EIO;\r\ngoto err_set_mask;\r\n}\r\n*dma64 = false;\r\n}\r\nerr = pci_request_selected_regions(pdev, (1 << 2) - 1,\r\nvmxnet3_driver_name);\r\nif (err) {\r\ndev_err(&pdev->dev,\r\n"Failed to request region for adapter: error %d\n", err);\r\ngoto err_set_mask;\r\n}\r\npci_set_master(pdev);\r\nmmio_start = pci_resource_start(pdev, 0);\r\nmmio_len = pci_resource_len(pdev, 0);\r\nadapter->hw_addr0 = ioremap(mmio_start, mmio_len);\r\nif (!adapter->hw_addr0) {\r\ndev_err(&pdev->dev, "Failed to map bar0\n");\r\nerr = -EIO;\r\ngoto err_ioremap;\r\n}\r\nmmio_start = pci_resource_start(pdev, 1);\r\nmmio_len = pci_resource_len(pdev, 1);\r\nadapter->hw_addr1 = ioremap(mmio_start, mmio_len);\r\nif (!adapter->hw_addr1) {\r\ndev_err(&pdev->dev, "Failed to map bar1\n");\r\nerr = -EIO;\r\ngoto err_bar1;\r\n}\r\nreturn 0;\r\nerr_bar1:\r\niounmap(adapter->hw_addr0);\r\nerr_ioremap:\r\npci_release_selected_regions(pdev, (1 << 2) - 1);\r\nerr_set_mask:\r\npci_disable_device(pdev);\r\nreturn err;\r\n}\r\nstatic void\r\nvmxnet3_free_pci_resources(struct vmxnet3_adapter *adapter)\r\n{\r\nBUG_ON(!adapter->pdev);\r\niounmap(adapter->hw_addr0);\r\niounmap(adapter->hw_addr1);\r\npci_release_selected_regions(adapter->pdev, (1 << 2) - 1);\r\npci_disable_device(adapter->pdev);\r\n}\r\nstatic void\r\nvmxnet3_adjust_rx_ring_size(struct vmxnet3_adapter *adapter)\r\n{\r\nsize_t sz, i, ring0_size, ring1_size, comp_size;\r\nstruct vmxnet3_rx_queue *rq = &adapter->rx_queue[0];\r\nif (adapter->netdev->mtu <= VMXNET3_MAX_SKB_BUF_SIZE -\r\nVMXNET3_MAX_ETH_HDR_SIZE) {\r\nadapter->skb_buf_size = adapter->netdev->mtu +\r\nVMXNET3_MAX_ETH_HDR_SIZE;\r\nif (adapter->skb_buf_size < VMXNET3_MIN_T0_BUF_SIZE)\r\nadapter->skb_buf_size = VMXNET3_MIN_T0_BUF_SIZE;\r\nadapter->rx_buf_per_pkt = 1;\r\n} else {\r\nadapter->skb_buf_size = VMXNET3_MAX_SKB_BUF_SIZE;\r\nsz = adapter->netdev->mtu - VMXNET3_MAX_SKB_BUF_SIZE +\r\nVMXNET3_MAX_ETH_HDR_SIZE;\r\nadapter->rx_buf_per_pkt = 1 + (sz + PAGE_SIZE - 1) / PAGE_SIZE;\r\n}\r\nsz = adapter->rx_buf_per_pkt * VMXNET3_RING_SIZE_ALIGN;\r\nring0_size = adapter->rx_queue[0].rx_ring[0].size;\r\nring0_size = (ring0_size + sz - 1) / sz * sz;\r\nring0_size = min_t(u32, ring0_size, VMXNET3_RX_RING_MAX_SIZE /\r\nsz * sz);\r\nring1_size = adapter->rx_queue[0].rx_ring[1].size;\r\nring1_size = (ring1_size + sz - 1) / sz * sz;\r\nring1_size = min_t(u32, ring1_size, VMXNET3_RX_RING2_MAX_SIZE /\r\nsz * sz);\r\ncomp_size = ring0_size + ring1_size;\r\nfor (i = 0; i < adapter->num_rx_queues; i++) {\r\nrq = &adapter->rx_queue[i];\r\nrq->rx_ring[0].size = ring0_size;\r\nrq->rx_ring[1].size = ring1_size;\r\nrq->comp_ring.size = comp_size;\r\n}\r\n}\r\nint\r\nvmxnet3_create_queues(struct vmxnet3_adapter *adapter, u32 tx_ring_size,\r\nu32 rx_ring_size, u32 rx_ring2_size,\r\nu16 txdata_desc_size, u16 rxdata_desc_size)\r\n{\r\nint err = 0, i;\r\nfor (i = 0; i < adapter->num_tx_queues; i++) {\r\nstruct vmxnet3_tx_queue *tq = &adapter->tx_queue[i];\r\ntq->tx_ring.size = tx_ring_size;\r\ntq->data_ring.size = tx_ring_size;\r\ntq->comp_ring.size = tx_ring_size;\r\ntq->txdata_desc_size = txdata_desc_size;\r\ntq->shared = &adapter->tqd_start[i].ctrl;\r\ntq->stopped = true;\r\ntq->adapter = adapter;\r\ntq->qid = i;\r\nerr = vmxnet3_tq_create(tq, adapter);\r\nif (err)\r\ngoto queue_err;\r\n}\r\nadapter->rx_queue[0].rx_ring[0].size = rx_ring_size;\r\nadapter->rx_queue[0].rx_ring[1].size = rx_ring2_size;\r\nvmxnet3_adjust_rx_ring_size(adapter);\r\nadapter->rxdataring_enabled = VMXNET3_VERSION_GE_3(adapter);\r\nfor (i = 0; i < adapter->num_rx_queues; i++) {\r\nstruct vmxnet3_rx_queue *rq = &adapter->rx_queue[i];\r\nrq->shared = &adapter->rqd_start[i].ctrl;\r\nrq->adapter = adapter;\r\nrq->data_ring.desc_size = rxdata_desc_size;\r\nerr = vmxnet3_rq_create(rq, adapter);\r\nif (err) {\r\nif (i == 0) {\r\nnetdev_err(adapter->netdev,\r\n"Could not allocate any rx queues. "\r\n"Aborting.\n");\r\ngoto queue_err;\r\n} else {\r\nnetdev_info(adapter->netdev,\r\n"Number of rx queues changed "\r\n"to : %d.\n", i);\r\nadapter->num_rx_queues = i;\r\nerr = 0;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!adapter->rxdataring_enabled)\r\nvmxnet3_rq_destroy_all_rxdataring(adapter);\r\nreturn err;\r\nqueue_err:\r\nvmxnet3_tq_destroy_all(adapter);\r\nreturn err;\r\n}\r\nstatic int\r\nvmxnet3_open(struct net_device *netdev)\r\n{\r\nstruct vmxnet3_adapter *adapter;\r\nint err, i;\r\nadapter = netdev_priv(netdev);\r\nfor (i = 0; i < adapter->num_tx_queues; i++)\r\nspin_lock_init(&adapter->tx_queue[i].tx_lock);\r\nif (VMXNET3_VERSION_GE_3(adapter)) {\r\nunsigned long flags;\r\nu16 txdata_desc_size;\r\nspin_lock_irqsave(&adapter->cmd_lock, flags);\r\nVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,\r\nVMXNET3_CMD_GET_TXDATA_DESC_SIZE);\r\ntxdata_desc_size = VMXNET3_READ_BAR1_REG(adapter,\r\nVMXNET3_REG_CMD);\r\nspin_unlock_irqrestore(&adapter->cmd_lock, flags);\r\nif ((txdata_desc_size < VMXNET3_TXDATA_DESC_MIN_SIZE) ||\r\n(txdata_desc_size > VMXNET3_TXDATA_DESC_MAX_SIZE) ||\r\n(txdata_desc_size & VMXNET3_TXDATA_DESC_SIZE_MASK)) {\r\nadapter->txdata_desc_size =\r\nsizeof(struct Vmxnet3_TxDataDesc);\r\n} else {\r\nadapter->txdata_desc_size = txdata_desc_size;\r\n}\r\n} else {\r\nadapter->txdata_desc_size = sizeof(struct Vmxnet3_TxDataDesc);\r\n}\r\nerr = vmxnet3_create_queues(adapter,\r\nadapter->tx_ring_size,\r\nadapter->rx_ring_size,\r\nadapter->rx_ring2_size,\r\nadapter->txdata_desc_size,\r\nadapter->rxdata_desc_size);\r\nif (err)\r\ngoto queue_err;\r\nerr = vmxnet3_activate_dev(adapter);\r\nif (err)\r\ngoto activate_err;\r\nreturn 0;\r\nactivate_err:\r\nvmxnet3_rq_destroy_all(adapter);\r\nvmxnet3_tq_destroy_all(adapter);\r\nqueue_err:\r\nreturn err;\r\n}\r\nstatic int\r\nvmxnet3_close(struct net_device *netdev)\r\n{\r\nstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\r\nwhile (test_and_set_bit(VMXNET3_STATE_BIT_RESETTING, &adapter->state))\r\nmsleep(1);\r\nvmxnet3_quiesce_dev(adapter);\r\nvmxnet3_rq_destroy_all(adapter);\r\nvmxnet3_tq_destroy_all(adapter);\r\nclear_bit(VMXNET3_STATE_BIT_RESETTING, &adapter->state);\r\nreturn 0;\r\n}\r\nvoid\r\nvmxnet3_force_close(struct vmxnet3_adapter *adapter)\r\n{\r\nint i;\r\nBUG_ON(test_bit(VMXNET3_STATE_BIT_RESETTING, &adapter->state));\r\nfor (i = 0; i < adapter->num_rx_queues; i++)\r\nnapi_enable(&adapter->rx_queue[i].napi);\r\nclear_bit(VMXNET3_STATE_BIT_QUIESCED, &adapter->state);\r\ndev_close(adapter->netdev);\r\n}\r\nstatic int\r\nvmxnet3_change_mtu(struct net_device *netdev, int new_mtu)\r\n{\r\nstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\r\nint err = 0;\r\nnetdev->mtu = new_mtu;\r\nwhile (test_and_set_bit(VMXNET3_STATE_BIT_RESETTING, &adapter->state))\r\nmsleep(1);\r\nif (netif_running(netdev)) {\r\nvmxnet3_quiesce_dev(adapter);\r\nvmxnet3_reset_dev(adapter);\r\nvmxnet3_rq_destroy_all(adapter);\r\nvmxnet3_adjust_rx_ring_size(adapter);\r\nerr = vmxnet3_rq_create_all(adapter);\r\nif (err) {\r\nnetdev_err(netdev,\r\n"failed to re-create rx queues, "\r\n" error %d. Closing it.\n", err);\r\ngoto out;\r\n}\r\nerr = vmxnet3_activate_dev(adapter);\r\nif (err) {\r\nnetdev_err(netdev,\r\n"failed to re-activate, error %d. "\r\n"Closing it\n", err);\r\ngoto out;\r\n}\r\n}\r\nout:\r\nclear_bit(VMXNET3_STATE_BIT_RESETTING, &adapter->state);\r\nif (err)\r\nvmxnet3_force_close(adapter);\r\nreturn err;\r\n}\r\nstatic void\r\nvmxnet3_declare_features(struct vmxnet3_adapter *adapter, bool dma64)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nnetdev->hw_features = NETIF_F_SG | NETIF_F_RXCSUM |\r\nNETIF_F_HW_CSUM | NETIF_F_HW_VLAN_CTAG_TX |\r\nNETIF_F_HW_VLAN_CTAG_RX | NETIF_F_TSO | NETIF_F_TSO6 |\r\nNETIF_F_LRO;\r\nif (dma64)\r\nnetdev->hw_features |= NETIF_F_HIGHDMA;\r\nnetdev->vlan_features = netdev->hw_features &\r\n~(NETIF_F_HW_VLAN_CTAG_TX |\r\nNETIF_F_HW_VLAN_CTAG_RX);\r\nnetdev->features = netdev->hw_features | NETIF_F_HW_VLAN_CTAG_FILTER;\r\n}\r\nstatic void\r\nvmxnet3_read_mac_addr(struct vmxnet3_adapter *adapter, u8 *mac)\r\n{\r\nu32 tmp;\r\ntmp = VMXNET3_READ_BAR1_REG(adapter, VMXNET3_REG_MACL);\r\n*(u32 *)mac = tmp;\r\ntmp = VMXNET3_READ_BAR1_REG(adapter, VMXNET3_REG_MACH);\r\nmac[4] = tmp & 0xff;\r\nmac[5] = (tmp >> 8) & 0xff;\r\n}\r\nstatic int\r\nvmxnet3_acquire_msix_vectors(struct vmxnet3_adapter *adapter, int nvec)\r\n{\r\nint ret = pci_enable_msix_range(adapter->pdev,\r\nadapter->intr.msix_entries, nvec, nvec);\r\nif (ret == -ENOSPC && nvec > VMXNET3_LINUX_MIN_MSIX_VECT) {\r\ndev_err(&adapter->netdev->dev,\r\n"Failed to enable %d MSI-X, trying %d\n",\r\nnvec, VMXNET3_LINUX_MIN_MSIX_VECT);\r\nret = pci_enable_msix_range(adapter->pdev,\r\nadapter->intr.msix_entries,\r\nVMXNET3_LINUX_MIN_MSIX_VECT,\r\nVMXNET3_LINUX_MIN_MSIX_VECT);\r\n}\r\nif (ret < 0) {\r\ndev_err(&adapter->netdev->dev,\r\n"Failed to enable MSI-X, error: %d\n", ret);\r\n}\r\nreturn ret;\r\n}\r\nstatic void\r\nvmxnet3_alloc_intr_resources(struct vmxnet3_adapter *adapter)\r\n{\r\nu32 cfg;\r\nunsigned long flags;\r\nspin_lock_irqsave(&adapter->cmd_lock, flags);\r\nVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,\r\nVMXNET3_CMD_GET_CONF_INTR);\r\ncfg = VMXNET3_READ_BAR1_REG(adapter, VMXNET3_REG_CMD);\r\nspin_unlock_irqrestore(&adapter->cmd_lock, flags);\r\nadapter->intr.type = cfg & 0x3;\r\nadapter->intr.mask_mode = (cfg >> 2) & 0x3;\r\nif (adapter->intr.type == VMXNET3_IT_AUTO) {\r\nadapter->intr.type = VMXNET3_IT_MSIX;\r\n}\r\n#ifdef CONFIG_PCI_MSI\r\nif (adapter->intr.type == VMXNET3_IT_MSIX) {\r\nint i, nvec;\r\nnvec = adapter->share_intr == VMXNET3_INTR_TXSHARE ?\r\n1 : adapter->num_tx_queues;\r\nnvec += adapter->share_intr == VMXNET3_INTR_BUDDYSHARE ?\r\n0 : adapter->num_rx_queues;\r\nnvec += 1;\r\nnvec = nvec > VMXNET3_LINUX_MIN_MSIX_VECT ?\r\nnvec : VMXNET3_LINUX_MIN_MSIX_VECT;\r\nfor (i = 0; i < nvec; i++)\r\nadapter->intr.msix_entries[i].entry = i;\r\nnvec = vmxnet3_acquire_msix_vectors(adapter, nvec);\r\nif (nvec < 0)\r\ngoto msix_err;\r\nif (nvec == VMXNET3_LINUX_MIN_MSIX_VECT) {\r\nif (adapter->share_intr != VMXNET3_INTR_BUDDYSHARE\r\n|| adapter->num_rx_queues != 1) {\r\nadapter->share_intr = VMXNET3_INTR_TXSHARE;\r\nnetdev_err(adapter->netdev,\r\n"Number of rx queues : 1\n");\r\nadapter->num_rx_queues = 1;\r\n}\r\n}\r\nadapter->intr.num_intrs = nvec;\r\nreturn;\r\nmsix_err:\r\ndev_info(&adapter->pdev->dev,\r\n"Failed to enable MSI-X, error %d. "\r\n"Limiting #rx queues to 1, try MSI.\n", nvec);\r\nadapter->intr.type = VMXNET3_IT_MSI;\r\n}\r\nif (adapter->intr.type == VMXNET3_IT_MSI) {\r\nif (!pci_enable_msi(adapter->pdev)) {\r\nadapter->num_rx_queues = 1;\r\nadapter->intr.num_intrs = 1;\r\nreturn;\r\n}\r\n}\r\n#endif\r\nadapter->num_rx_queues = 1;\r\ndev_info(&adapter->netdev->dev,\r\n"Using INTx interrupt, #Rx queues: 1.\n");\r\nadapter->intr.type = VMXNET3_IT_INTX;\r\nadapter->intr.num_intrs = 1;\r\n}\r\nstatic void\r\nvmxnet3_free_intr_resources(struct vmxnet3_adapter *adapter)\r\n{\r\nif (adapter->intr.type == VMXNET3_IT_MSIX)\r\npci_disable_msix(adapter->pdev);\r\nelse if (adapter->intr.type == VMXNET3_IT_MSI)\r\npci_disable_msi(adapter->pdev);\r\nelse\r\nBUG_ON(adapter->intr.type != VMXNET3_IT_INTX);\r\n}\r\nstatic void\r\nvmxnet3_tx_timeout(struct net_device *netdev)\r\n{\r\nstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\r\nadapter->tx_timeout_count++;\r\nnetdev_err(adapter->netdev, "tx hang\n");\r\nschedule_work(&adapter->work);\r\n}\r\nstatic void\r\nvmxnet3_reset_work(struct work_struct *data)\r\n{\r\nstruct vmxnet3_adapter *adapter;\r\nadapter = container_of(data, struct vmxnet3_adapter, work);\r\nif (test_and_set_bit(VMXNET3_STATE_BIT_RESETTING, &adapter->state))\r\nreturn;\r\nrtnl_lock();\r\nif (netif_running(adapter->netdev)) {\r\nnetdev_notice(adapter->netdev, "resetting\n");\r\nvmxnet3_quiesce_dev(adapter);\r\nvmxnet3_reset_dev(adapter);\r\nvmxnet3_activate_dev(adapter);\r\n} else {\r\nnetdev_info(adapter->netdev, "already closed\n");\r\n}\r\nrtnl_unlock();\r\nnetif_wake_queue(adapter->netdev);\r\nclear_bit(VMXNET3_STATE_BIT_RESETTING, &adapter->state);\r\n}\r\nstatic int\r\nvmxnet3_probe_device(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nstatic const struct net_device_ops vmxnet3_netdev_ops = {\r\n.ndo_open = vmxnet3_open,\r\n.ndo_stop = vmxnet3_close,\r\n.ndo_start_xmit = vmxnet3_xmit_frame,\r\n.ndo_set_mac_address = vmxnet3_set_mac_addr,\r\n.ndo_change_mtu = vmxnet3_change_mtu,\r\n.ndo_set_features = vmxnet3_set_features,\r\n.ndo_get_stats64 = vmxnet3_get_stats64,\r\n.ndo_tx_timeout = vmxnet3_tx_timeout,\r\n.ndo_set_rx_mode = vmxnet3_set_mc,\r\n.ndo_vlan_rx_add_vid = vmxnet3_vlan_rx_add_vid,\r\n.ndo_vlan_rx_kill_vid = vmxnet3_vlan_rx_kill_vid,\r\n#ifdef CONFIG_NET_POLL_CONTROLLER\r\n.ndo_poll_controller = vmxnet3_netpoll,\r\n#endif\r\n};\r\nint err;\r\nbool dma64 = false;\r\nu32 ver;\r\nstruct net_device *netdev;\r\nstruct vmxnet3_adapter *adapter;\r\nu8 mac[ETH_ALEN];\r\nint size;\r\nint num_tx_queues;\r\nint num_rx_queues;\r\nif (!pci_msi_enabled())\r\nenable_mq = 0;\r\n#ifdef VMXNET3_RSS\r\nif (enable_mq)\r\nnum_rx_queues = min(VMXNET3_DEVICE_MAX_RX_QUEUES,\r\n(int)num_online_cpus());\r\nelse\r\n#endif\r\nnum_rx_queues = 1;\r\nnum_rx_queues = rounddown_pow_of_two(num_rx_queues);\r\nif (enable_mq)\r\nnum_tx_queues = min(VMXNET3_DEVICE_MAX_TX_QUEUES,\r\n(int)num_online_cpus());\r\nelse\r\nnum_tx_queues = 1;\r\nnum_tx_queues = rounddown_pow_of_two(num_tx_queues);\r\nnetdev = alloc_etherdev_mq(sizeof(struct vmxnet3_adapter),\r\nmax(num_tx_queues, num_rx_queues));\r\ndev_info(&pdev->dev,\r\n"# of Tx queues : %d, # of Rx queues : %d\n",\r\nnum_tx_queues, num_rx_queues);\r\nif (!netdev)\r\nreturn -ENOMEM;\r\npci_set_drvdata(pdev, netdev);\r\nadapter = netdev_priv(netdev);\r\nadapter->netdev = netdev;\r\nadapter->pdev = pdev;\r\nadapter->tx_ring_size = VMXNET3_DEF_TX_RING_SIZE;\r\nadapter->rx_ring_size = VMXNET3_DEF_RX_RING_SIZE;\r\nadapter->rx_ring2_size = VMXNET3_DEF_RX_RING2_SIZE;\r\nspin_lock_init(&adapter->cmd_lock);\r\nadapter->adapter_pa = dma_map_single(&adapter->pdev->dev, adapter,\r\nsizeof(struct vmxnet3_adapter),\r\nPCI_DMA_TODEVICE);\r\nif (dma_mapping_error(&adapter->pdev->dev, adapter->adapter_pa)) {\r\ndev_err(&pdev->dev, "Failed to map dma\n");\r\nerr = -EFAULT;\r\ngoto err_dma_map;\r\n}\r\nadapter->shared = dma_alloc_coherent(\r\n&adapter->pdev->dev,\r\nsizeof(struct Vmxnet3_DriverShared),\r\n&adapter->shared_pa, GFP_KERNEL);\r\nif (!adapter->shared) {\r\ndev_err(&pdev->dev, "Failed to allocate memory\n");\r\nerr = -ENOMEM;\r\ngoto err_alloc_shared;\r\n}\r\nadapter->num_rx_queues = num_rx_queues;\r\nadapter->num_tx_queues = num_tx_queues;\r\nadapter->rx_buf_per_pkt = 1;\r\nsize = sizeof(struct Vmxnet3_TxQueueDesc) * adapter->num_tx_queues;\r\nsize += sizeof(struct Vmxnet3_RxQueueDesc) * adapter->num_rx_queues;\r\nadapter->tqd_start = dma_alloc_coherent(&adapter->pdev->dev, size,\r\n&adapter->queue_desc_pa,\r\nGFP_KERNEL);\r\nif (!adapter->tqd_start) {\r\ndev_err(&pdev->dev, "Failed to allocate memory\n");\r\nerr = -ENOMEM;\r\ngoto err_alloc_queue_desc;\r\n}\r\nadapter->rqd_start = (struct Vmxnet3_RxQueueDesc *)(adapter->tqd_start +\r\nadapter->num_tx_queues);\r\nadapter->pm_conf = dma_alloc_coherent(&adapter->pdev->dev,\r\nsizeof(struct Vmxnet3_PMConf),\r\n&adapter->pm_conf_pa,\r\nGFP_KERNEL);\r\nif (adapter->pm_conf == NULL) {\r\nerr = -ENOMEM;\r\ngoto err_alloc_pm;\r\n}\r\n#ifdef VMXNET3_RSS\r\nadapter->rss_conf = dma_alloc_coherent(&adapter->pdev->dev,\r\nsizeof(struct UPT1_RSSConf),\r\n&adapter->rss_conf_pa,\r\nGFP_KERNEL);\r\nif (adapter->rss_conf == NULL) {\r\nerr = -ENOMEM;\r\ngoto err_alloc_rss;\r\n}\r\n#endif\r\nerr = vmxnet3_alloc_pci_resources(adapter, &dma64);\r\nif (err < 0)\r\ngoto err_alloc_pci;\r\nver = VMXNET3_READ_BAR1_REG(adapter, VMXNET3_REG_VRRS);\r\nif (ver & (1 << VMXNET3_REV_3)) {\r\nVMXNET3_WRITE_BAR1_REG(adapter,\r\nVMXNET3_REG_VRRS,\r\n1 << VMXNET3_REV_3);\r\nadapter->version = VMXNET3_REV_3 + 1;\r\n} else if (ver & (1 << VMXNET3_REV_2)) {\r\nVMXNET3_WRITE_BAR1_REG(adapter,\r\nVMXNET3_REG_VRRS,\r\n1 << VMXNET3_REV_2);\r\nadapter->version = VMXNET3_REV_2 + 1;\r\n} else if (ver & (1 << VMXNET3_REV_1)) {\r\nVMXNET3_WRITE_BAR1_REG(adapter,\r\nVMXNET3_REG_VRRS,\r\n1 << VMXNET3_REV_1);\r\nadapter->version = VMXNET3_REV_1 + 1;\r\n} else {\r\ndev_err(&pdev->dev,\r\n"Incompatible h/w version (0x%x) for adapter\n", ver);\r\nerr = -EBUSY;\r\ngoto err_ver;\r\n}\r\ndev_dbg(&pdev->dev, "Using device version %d\n", adapter->version);\r\nver = VMXNET3_READ_BAR1_REG(adapter, VMXNET3_REG_UVRS);\r\nif (ver & 1) {\r\nVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_UVRS, 1);\r\n} else {\r\ndev_err(&pdev->dev,\r\n"Incompatible upt version (0x%x) for adapter\n", ver);\r\nerr = -EBUSY;\r\ngoto err_ver;\r\n}\r\nif (VMXNET3_VERSION_GE_3(adapter)) {\r\nadapter->coal_conf =\r\ndma_alloc_coherent(&adapter->pdev->dev,\r\nsizeof(struct Vmxnet3_CoalesceScheme)\r\n,\r\n&adapter->coal_conf_pa,\r\nGFP_KERNEL);\r\nif (!adapter->coal_conf) {\r\nerr = -ENOMEM;\r\ngoto err_ver;\r\n}\r\nmemset(adapter->coal_conf, 0, sizeof(*adapter->coal_conf));\r\nadapter->coal_conf->coalMode = VMXNET3_COALESCE_DISABLED;\r\nadapter->default_coal_mode = true;\r\n}\r\nSET_NETDEV_DEV(netdev, &pdev->dev);\r\nvmxnet3_declare_features(adapter, dma64);\r\nadapter->rxdata_desc_size = VMXNET3_VERSION_GE_3(adapter) ?\r\nVMXNET3_DEF_RXDATA_DESC_SIZE : 0;\r\nif (adapter->num_tx_queues == adapter->num_rx_queues)\r\nadapter->share_intr = VMXNET3_INTR_BUDDYSHARE;\r\nelse\r\nadapter->share_intr = VMXNET3_INTR_DONTSHARE;\r\nvmxnet3_alloc_intr_resources(adapter);\r\n#ifdef VMXNET3_RSS\r\nif (adapter->num_rx_queues > 1 &&\r\nadapter->intr.type == VMXNET3_IT_MSIX) {\r\nadapter->rss = true;\r\nnetdev->hw_features |= NETIF_F_RXHASH;\r\nnetdev->features |= NETIF_F_RXHASH;\r\ndev_dbg(&pdev->dev, "RSS is enabled.\n");\r\n} else {\r\nadapter->rss = false;\r\n}\r\n#endif\r\nvmxnet3_read_mac_addr(adapter, mac);\r\nmemcpy(netdev->dev_addr, mac, netdev->addr_len);\r\nnetdev->netdev_ops = &vmxnet3_netdev_ops;\r\nvmxnet3_set_ethtool_ops(netdev);\r\nnetdev->watchdog_timeo = 5 * HZ;\r\nnetdev->min_mtu = VMXNET3_MIN_MTU;\r\nnetdev->max_mtu = VMXNET3_MAX_MTU;\r\nINIT_WORK(&adapter->work, vmxnet3_reset_work);\r\nset_bit(VMXNET3_STATE_BIT_QUIESCED, &adapter->state);\r\nif (adapter->intr.type == VMXNET3_IT_MSIX) {\r\nint i;\r\nfor (i = 0; i < adapter->num_rx_queues; i++) {\r\nnetif_napi_add(adapter->netdev,\r\n&adapter->rx_queue[i].napi,\r\nvmxnet3_poll_rx_only, 64);\r\n}\r\n} else {\r\nnetif_napi_add(adapter->netdev, &adapter->rx_queue[0].napi,\r\nvmxnet3_poll, 64);\r\n}\r\nnetif_set_real_num_tx_queues(adapter->netdev, adapter->num_tx_queues);\r\nnetif_set_real_num_rx_queues(adapter->netdev, adapter->num_rx_queues);\r\nnetif_carrier_off(netdev);\r\nerr = register_netdev(netdev);\r\nif (err) {\r\ndev_err(&pdev->dev, "Failed to register adapter\n");\r\ngoto err_register;\r\n}\r\nvmxnet3_check_link(adapter, false);\r\nreturn 0;\r\nerr_register:\r\nif (VMXNET3_VERSION_GE_3(adapter)) {\r\ndma_free_coherent(&adapter->pdev->dev,\r\nsizeof(struct Vmxnet3_CoalesceScheme),\r\nadapter->coal_conf, adapter->coal_conf_pa);\r\n}\r\nvmxnet3_free_intr_resources(adapter);\r\nerr_ver:\r\nvmxnet3_free_pci_resources(adapter);\r\nerr_alloc_pci:\r\n#ifdef VMXNET3_RSS\r\ndma_free_coherent(&adapter->pdev->dev, sizeof(struct UPT1_RSSConf),\r\nadapter->rss_conf, adapter->rss_conf_pa);\r\nerr_alloc_rss:\r\n#endif\r\ndma_free_coherent(&adapter->pdev->dev, sizeof(struct Vmxnet3_PMConf),\r\nadapter->pm_conf, adapter->pm_conf_pa);\r\nerr_alloc_pm:\r\ndma_free_coherent(&adapter->pdev->dev, size, adapter->tqd_start,\r\nadapter->queue_desc_pa);\r\nerr_alloc_queue_desc:\r\ndma_free_coherent(&adapter->pdev->dev,\r\nsizeof(struct Vmxnet3_DriverShared),\r\nadapter->shared, adapter->shared_pa);\r\nerr_alloc_shared:\r\ndma_unmap_single(&adapter->pdev->dev, adapter->adapter_pa,\r\nsizeof(struct vmxnet3_adapter), PCI_DMA_TODEVICE);\r\nerr_dma_map:\r\nfree_netdev(netdev);\r\nreturn err;\r\n}\r\nstatic void\r\nvmxnet3_remove_device(struct pci_dev *pdev)\r\n{\r\nstruct net_device *netdev = pci_get_drvdata(pdev);\r\nstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\r\nint size = 0;\r\nint num_rx_queues;\r\n#ifdef VMXNET3_RSS\r\nif (enable_mq)\r\nnum_rx_queues = min(VMXNET3_DEVICE_MAX_RX_QUEUES,\r\n(int)num_online_cpus());\r\nelse\r\n#endif\r\nnum_rx_queues = 1;\r\nnum_rx_queues = rounddown_pow_of_two(num_rx_queues);\r\ncancel_work_sync(&adapter->work);\r\nunregister_netdev(netdev);\r\nvmxnet3_free_intr_resources(adapter);\r\nvmxnet3_free_pci_resources(adapter);\r\nif (VMXNET3_VERSION_GE_3(adapter)) {\r\ndma_free_coherent(&adapter->pdev->dev,\r\nsizeof(struct Vmxnet3_CoalesceScheme),\r\nadapter->coal_conf, adapter->coal_conf_pa);\r\n}\r\n#ifdef VMXNET3_RSS\r\ndma_free_coherent(&adapter->pdev->dev, sizeof(struct UPT1_RSSConf),\r\nadapter->rss_conf, adapter->rss_conf_pa);\r\n#endif\r\ndma_free_coherent(&adapter->pdev->dev, sizeof(struct Vmxnet3_PMConf),\r\nadapter->pm_conf, adapter->pm_conf_pa);\r\nsize = sizeof(struct Vmxnet3_TxQueueDesc) * adapter->num_tx_queues;\r\nsize += sizeof(struct Vmxnet3_RxQueueDesc) * num_rx_queues;\r\ndma_free_coherent(&adapter->pdev->dev, size, adapter->tqd_start,\r\nadapter->queue_desc_pa);\r\ndma_free_coherent(&adapter->pdev->dev,\r\nsizeof(struct Vmxnet3_DriverShared),\r\nadapter->shared, adapter->shared_pa);\r\ndma_unmap_single(&adapter->pdev->dev, adapter->adapter_pa,\r\nsizeof(struct vmxnet3_adapter), PCI_DMA_TODEVICE);\r\nfree_netdev(netdev);\r\n}\r\nstatic void vmxnet3_shutdown_device(struct pci_dev *pdev)\r\n{\r\nstruct net_device *netdev = pci_get_drvdata(pdev);\r\nstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\r\nunsigned long flags;\r\nwhile (test_and_set_bit(VMXNET3_STATE_BIT_RESETTING, &adapter->state))\r\nmsleep(1);\r\nif (test_and_set_bit(VMXNET3_STATE_BIT_QUIESCED,\r\n&adapter->state)) {\r\nclear_bit(VMXNET3_STATE_BIT_RESETTING, &adapter->state);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&adapter->cmd_lock, flags);\r\nVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,\r\nVMXNET3_CMD_QUIESCE_DEV);\r\nspin_unlock_irqrestore(&adapter->cmd_lock, flags);\r\nvmxnet3_disable_all_intrs(adapter);\r\nclear_bit(VMXNET3_STATE_BIT_RESETTING, &adapter->state);\r\n}\r\nstatic int\r\nvmxnet3_suspend(struct device *device)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(device);\r\nstruct net_device *netdev = pci_get_drvdata(pdev);\r\nstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\r\nstruct Vmxnet3_PMConf *pmConf;\r\nstruct ethhdr *ehdr;\r\nstruct arphdr *ahdr;\r\nu8 *arpreq;\r\nstruct in_device *in_dev;\r\nstruct in_ifaddr *ifa;\r\nunsigned long flags;\r\nint i = 0;\r\nif (!netif_running(netdev))\r\nreturn 0;\r\nfor (i = 0; i < adapter->num_rx_queues; i++)\r\nnapi_disable(&adapter->rx_queue[i].napi);\r\nvmxnet3_disable_all_intrs(adapter);\r\nvmxnet3_free_irqs(adapter);\r\nvmxnet3_free_intr_resources(adapter);\r\nnetif_device_detach(netdev);\r\nnetif_tx_stop_all_queues(netdev);\r\npmConf = adapter->pm_conf;\r\nmemset(pmConf, 0, sizeof(*pmConf));\r\nif (adapter->wol & WAKE_UCAST) {\r\npmConf->filters[i].patternSize = ETH_ALEN;\r\npmConf->filters[i].maskSize = 1;\r\nmemcpy(pmConf->filters[i].pattern, netdev->dev_addr, ETH_ALEN);\r\npmConf->filters[i].mask[0] = 0x3F;\r\npmConf->wakeUpEvents |= VMXNET3_PM_WAKEUP_FILTER;\r\ni++;\r\n}\r\nif (adapter->wol & WAKE_ARP) {\r\nin_dev = in_dev_get(netdev);\r\nif (!in_dev)\r\ngoto skip_arp;\r\nifa = (struct in_ifaddr *)in_dev->ifa_list;\r\nif (!ifa)\r\ngoto skip_arp;\r\npmConf->filters[i].patternSize = ETH_HLEN +\r\nsizeof(struct arphdr) +\r\n2 * ETH_ALEN +\r\n2 * sizeof(u32);\r\npmConf->filters[i].maskSize =\r\n(pmConf->filters[i].patternSize - 1) / 8 + 1;\r\nehdr = (struct ethhdr *)pmConf->filters[i].pattern;\r\nehdr->h_proto = htons(ETH_P_ARP);\r\nahdr = (struct arphdr *)&pmConf->filters[i].pattern[ETH_HLEN];\r\nahdr->ar_op = htons(ARPOP_REQUEST);\r\narpreq = (u8 *)(ahdr + 1);\r\narpreq += 2 * ETH_ALEN + sizeof(u32);\r\n*(u32 *)arpreq = ifa->ifa_address;\r\npmConf->filters[i].mask[0] = 0x00;\r\npmConf->filters[i].mask[1] = 0x30;\r\npmConf->filters[i].mask[2] = 0x30;\r\npmConf->filters[i].mask[3] = 0x00;\r\npmConf->filters[i].mask[4] = 0xC0;\r\npmConf->filters[i].mask[5] = 0x03;\r\nin_dev_put(in_dev);\r\npmConf->wakeUpEvents |= VMXNET3_PM_WAKEUP_FILTER;\r\ni++;\r\n}\r\nskip_arp:\r\nif (adapter->wol & WAKE_MAGIC)\r\npmConf->wakeUpEvents |= VMXNET3_PM_WAKEUP_MAGIC;\r\npmConf->numFilters = i;\r\nadapter->shared->devRead.pmConfDesc.confVer = cpu_to_le32(1);\r\nadapter->shared->devRead.pmConfDesc.confLen = cpu_to_le32(sizeof(\r\n*pmConf));\r\nadapter->shared->devRead.pmConfDesc.confPA =\r\ncpu_to_le64(adapter->pm_conf_pa);\r\nspin_lock_irqsave(&adapter->cmd_lock, flags);\r\nVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,\r\nVMXNET3_CMD_UPDATE_PMCFG);\r\nspin_unlock_irqrestore(&adapter->cmd_lock, flags);\r\npci_save_state(pdev);\r\npci_enable_wake(pdev, pci_choose_state(pdev, PMSG_SUSPEND),\r\nadapter->wol);\r\npci_disable_device(pdev);\r\npci_set_power_state(pdev, pci_choose_state(pdev, PMSG_SUSPEND));\r\nreturn 0;\r\n}\r\nstatic int\r\nvmxnet3_resume(struct device *device)\r\n{\r\nint err;\r\nunsigned long flags;\r\nstruct pci_dev *pdev = to_pci_dev(device);\r\nstruct net_device *netdev = pci_get_drvdata(pdev);\r\nstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\r\nif (!netif_running(netdev))\r\nreturn 0;\r\npci_set_power_state(pdev, PCI_D0);\r\npci_restore_state(pdev);\r\nerr = pci_enable_device_mem(pdev);\r\nif (err != 0)\r\nreturn err;\r\npci_enable_wake(pdev, PCI_D0, 0);\r\nvmxnet3_alloc_intr_resources(adapter);\r\nspin_lock_irqsave(&adapter->cmd_lock, flags);\r\nVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,\r\nVMXNET3_CMD_QUIESCE_DEV);\r\nspin_unlock_irqrestore(&adapter->cmd_lock, flags);\r\nvmxnet3_tq_cleanup_all(adapter);\r\nvmxnet3_rq_cleanup_all(adapter);\r\nvmxnet3_reset_dev(adapter);\r\nerr = vmxnet3_activate_dev(adapter);\r\nif (err != 0) {\r\nnetdev_err(netdev,\r\n"failed to re-activate on resume, error: %d", err);\r\nvmxnet3_force_close(adapter);\r\nreturn err;\r\n}\r\nnetif_device_attach(netdev);\r\nreturn 0;\r\n}\r\nstatic int __init\r\nvmxnet3_init_module(void)\r\n{\r\npr_info("%s - version %s\n", VMXNET3_DRIVER_DESC,\r\nVMXNET3_DRIVER_VERSION_REPORT);\r\nreturn pci_register_driver(&vmxnet3_driver);\r\n}\r\nstatic void\r\nvmxnet3_exit_module(void)\r\n{\r\npci_unregister_driver(&vmxnet3_driver);\r\n}
