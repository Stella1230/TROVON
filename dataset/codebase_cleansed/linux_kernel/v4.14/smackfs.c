static inline void smack_catset_bit(unsigned int cat, char *catsetp)\r\n{\r\nif (cat == 0 || cat > (SMK_CIPSOLEN * 8))\r\nreturn;\r\ncatsetp[(cat - 1) / 8] |= 0x80 >> ((cat - 1) % 8);\r\n}\r\nstatic void smk_netlabel_audit_set(struct netlbl_audit *nap)\r\n{\r\nstruct smack_known *skp = smk_of_current();\r\nnap->loginuid = audit_get_loginuid(current);\r\nnap->sessionid = audit_get_sessionid(current);\r\nnap->secid = skp->smk_secid;\r\n}\r\nstatic int smk_set_access(struct smack_parsed_rule *srp,\r\nstruct list_head *rule_list,\r\nstruct mutex *rule_lock, int global)\r\n{\r\nstruct smack_rule *sp;\r\nstruct smack_master_list *smlp;\r\nint found = 0;\r\nint rc = 0;\r\nmutex_lock(rule_lock);\r\nlist_for_each_entry_rcu(sp, rule_list, list) {\r\nif (sp->smk_object == srp->smk_object &&\r\nsp->smk_subject == srp->smk_subject) {\r\nfound = 1;\r\nsp->smk_access |= srp->smk_access1;\r\nsp->smk_access &= ~srp->smk_access2;\r\nbreak;\r\n}\r\n}\r\nif (found == 0) {\r\nsp = kzalloc(sizeof(*sp), GFP_KERNEL);\r\nif (sp == NULL) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nsp->smk_subject = srp->smk_subject;\r\nsp->smk_object = srp->smk_object;\r\nsp->smk_access = srp->smk_access1 & ~srp->smk_access2;\r\nlist_add_rcu(&sp->list, rule_list);\r\nif (global) {\r\nmutex_unlock(rule_lock);\r\nsmlp = kzalloc(sizeof(*smlp), GFP_KERNEL);\r\nif (smlp != NULL) {\r\nsmlp->smk_rule = sp;\r\nmutex_lock(&smack_master_list_lock);\r\nlist_add_rcu(&smlp->list, &smack_rule_list);\r\nmutex_unlock(&smack_master_list_lock);\r\n} else\r\nrc = -ENOMEM;\r\nreturn rc;\r\n}\r\n}\r\nout:\r\nmutex_unlock(rule_lock);\r\nreturn rc;\r\n}\r\nstatic int smk_perm_from_str(const char *string)\r\n{\r\nint perm = 0;\r\nconst char *cp;\r\nfor (cp = string; ; cp++)\r\nswitch (*cp) {\r\ncase '-':\r\nbreak;\r\ncase 'r':\r\ncase 'R':\r\nperm |= MAY_READ;\r\nbreak;\r\ncase 'w':\r\ncase 'W':\r\nperm |= MAY_WRITE;\r\nbreak;\r\ncase 'x':\r\ncase 'X':\r\nperm |= MAY_EXEC;\r\nbreak;\r\ncase 'a':\r\ncase 'A':\r\nperm |= MAY_APPEND;\r\nbreak;\r\ncase 't':\r\ncase 'T':\r\nperm |= MAY_TRANSMUTE;\r\nbreak;\r\ncase 'l':\r\ncase 'L':\r\nperm |= MAY_LOCK;\r\nbreak;\r\ncase 'b':\r\ncase 'B':\r\nperm |= MAY_BRINGUP;\r\nbreak;\r\ndefault:\r\nreturn perm;\r\n}\r\n}\r\nstatic int smk_fill_rule(const char *subject, const char *object,\r\nconst char *access1, const char *access2,\r\nstruct smack_parsed_rule *rule, int import,\r\nint len)\r\n{\r\nconst char *cp;\r\nstruct smack_known *skp;\r\nif (import) {\r\nrule->smk_subject = smk_import_entry(subject, len);\r\nif (IS_ERR(rule->smk_subject))\r\nreturn PTR_ERR(rule->smk_subject);\r\nrule->smk_object = smk_import_entry(object, len);\r\nif (IS_ERR(rule->smk_object))\r\nreturn PTR_ERR(rule->smk_object);\r\n} else {\r\ncp = smk_parse_smack(subject, len);\r\nif (IS_ERR(cp))\r\nreturn PTR_ERR(cp);\r\nskp = smk_find_entry(cp);\r\nkfree(cp);\r\nif (skp == NULL)\r\nreturn -ENOENT;\r\nrule->smk_subject = skp;\r\ncp = smk_parse_smack(object, len);\r\nif (IS_ERR(cp))\r\nreturn PTR_ERR(cp);\r\nskp = smk_find_entry(cp);\r\nkfree(cp);\r\nif (skp == NULL)\r\nreturn -ENOENT;\r\nrule->smk_object = skp;\r\n}\r\nrule->smk_access1 = smk_perm_from_str(access1);\r\nif (access2)\r\nrule->smk_access2 = smk_perm_from_str(access2);\r\nelse\r\nrule->smk_access2 = ~rule->smk_access1;\r\nreturn 0;\r\n}\r\nstatic int smk_parse_rule(const char *data, struct smack_parsed_rule *rule,\r\nint import)\r\n{\r\nint rc;\r\nrc = smk_fill_rule(data, data + SMK_LABELLEN,\r\ndata + SMK_LABELLEN + SMK_LABELLEN, NULL, rule,\r\nimport, SMK_LABELLEN);\r\nreturn rc;\r\n}\r\nstatic ssize_t smk_parse_long_rule(char *data, struct smack_parsed_rule *rule,\r\nint import, int tokens)\r\n{\r\nssize_t cnt = 0;\r\nchar *tok[4];\r\nint rc;\r\nint i;\r\nfor (i = 0; i < tokens; ++i) {\r\nwhile (isspace(data[cnt]))\r\ndata[cnt++] = '\0';\r\nif (data[cnt] == '\0')\r\nreturn -EINVAL;\r\ntok[i] = data + cnt;\r\nwhile (data[cnt] && !isspace(data[cnt]))\r\n++cnt;\r\n}\r\nwhile (isspace(data[cnt]))\r\ndata[cnt++] = '\0';\r\nwhile (i < 4)\r\ntok[i++] = NULL;\r\nrc = smk_fill_rule(tok[0], tok[1], tok[2], tok[3], rule, import, 0);\r\nreturn rc == 0 ? cnt : rc;\r\n}\r\nstatic ssize_t smk_write_rules_list(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos,\r\nstruct list_head *rule_list,\r\nstruct mutex *rule_lock, int format)\r\n{\r\nstruct smack_parsed_rule rule;\r\nchar *data;\r\nint rc;\r\nint trunc = 0;\r\nint tokens;\r\nssize_t cnt = 0;\r\nif (*ppos != 0)\r\nreturn -EINVAL;\r\nif (format == SMK_FIXED24_FMT) {\r\nif (count < SMK_OLOADLEN || count > SMK_LOADLEN)\r\nreturn -EINVAL;\r\n} else {\r\nif (count >= PAGE_SIZE) {\r\ncount = PAGE_SIZE - 1;\r\ntrunc = 1;\r\n}\r\n}\r\ndata = memdup_user_nul(buf, count);\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nif (trunc) {\r\nwhile (count > 0 && (data[count - 1] != '\n'))\r\n--count;\r\nif (count == 0) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\ndata[count] = '\0';\r\ntokens = (format == SMK_CHANGE_FMT ? 4 : 3);\r\nwhile (cnt < count) {\r\nif (format == SMK_FIXED24_FMT) {\r\nrc = smk_parse_rule(data, &rule, 1);\r\nif (rc < 0)\r\ngoto out;\r\ncnt = count;\r\n} else {\r\nrc = smk_parse_long_rule(data + cnt, &rule, 1, tokens);\r\nif (rc < 0)\r\ngoto out;\r\nif (rc == 0) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\ncnt += rc;\r\n}\r\nif (rule_list == NULL)\r\nrc = smk_set_access(&rule, &rule.smk_subject->smk_rules,\r\n&rule.smk_subject->smk_rules_lock, 1);\r\nelse\r\nrc = smk_set_access(&rule, rule_list, rule_lock, 0);\r\nif (rc)\r\ngoto out;\r\n}\r\nrc = cnt;\r\nout:\r\nkfree(data);\r\nreturn rc;\r\n}\r\nstatic void *smk_seq_start(struct seq_file *s, loff_t *pos,\r\nstruct list_head *head)\r\n{\r\nstruct list_head *list;\r\nint i = *pos;\r\nrcu_read_lock();\r\nfor (list = rcu_dereference(list_next_rcu(head));\r\nlist != head;\r\nlist = rcu_dereference(list_next_rcu(list))) {\r\nif (i-- == 0)\r\nreturn list;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void *smk_seq_next(struct seq_file *s, void *v, loff_t *pos,\r\nstruct list_head *head)\r\n{\r\nstruct list_head *list = v;\r\n++*pos;\r\nlist = rcu_dereference(list_next_rcu(list));\r\nreturn (list == head) ? NULL : list;\r\n}\r\nstatic void smk_seq_stop(struct seq_file *s, void *v)\r\n{\r\nrcu_read_unlock();\r\n}\r\nstatic void smk_rule_show(struct seq_file *s, struct smack_rule *srp, int max)\r\n{\r\nif (strlen(srp->smk_subject->smk_known) >= max ||\r\nstrlen(srp->smk_object->smk_known) >= max)\r\nreturn;\r\nif (srp->smk_access == 0)\r\nreturn;\r\nseq_printf(s, "%s %s",\r\nsrp->smk_subject->smk_known,\r\nsrp->smk_object->smk_known);\r\nseq_putc(s, ' ');\r\nif (srp->smk_access & MAY_READ)\r\nseq_putc(s, 'r');\r\nif (srp->smk_access & MAY_WRITE)\r\nseq_putc(s, 'w');\r\nif (srp->smk_access & MAY_EXEC)\r\nseq_putc(s, 'x');\r\nif (srp->smk_access & MAY_APPEND)\r\nseq_putc(s, 'a');\r\nif (srp->smk_access & MAY_TRANSMUTE)\r\nseq_putc(s, 't');\r\nif (srp->smk_access & MAY_LOCK)\r\nseq_putc(s, 'l');\r\nif (srp->smk_access & MAY_BRINGUP)\r\nseq_putc(s, 'b');\r\nseq_putc(s, '\n');\r\n}\r\nstatic void *load2_seq_start(struct seq_file *s, loff_t *pos)\r\n{\r\nreturn smk_seq_start(s, pos, &smack_rule_list);\r\n}\r\nstatic void *load2_seq_next(struct seq_file *s, void *v, loff_t *pos)\r\n{\r\nreturn smk_seq_next(s, v, pos, &smack_rule_list);\r\n}\r\nstatic int load_seq_show(struct seq_file *s, void *v)\r\n{\r\nstruct list_head *list = v;\r\nstruct smack_master_list *smlp =\r\nlist_entry_rcu(list, struct smack_master_list, list);\r\nsmk_rule_show(s, smlp->smk_rule, SMK_LABELLEN);\r\nreturn 0;\r\n}\r\nstatic int smk_open_load(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &load_seq_ops);\r\n}\r\nstatic ssize_t smk_write_load(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nif (!smack_privileged(CAP_MAC_ADMIN))\r\nreturn -EPERM;\r\nreturn smk_write_rules_list(file, buf, count, ppos, NULL, NULL,\r\nSMK_FIXED24_FMT);\r\n}\r\nstatic void smk_cipso_doi(void)\r\n{\r\nint rc;\r\nstruct cipso_v4_doi *doip;\r\nstruct netlbl_audit nai;\r\nsmk_netlabel_audit_set(&nai);\r\nrc = netlbl_cfg_map_del(NULL, PF_INET, NULL, NULL, &nai);\r\nif (rc != 0)\r\nprintk(KERN_WARNING "%s:%d remove rc = %d\n",\r\n__func__, __LINE__, rc);\r\ndoip = kmalloc(sizeof(struct cipso_v4_doi), GFP_KERNEL);\r\nif (doip == NULL)\r\npanic("smack: Failed to initialize cipso DOI.\n");\r\ndoip->map.std = NULL;\r\ndoip->doi = smk_cipso_doi_value;\r\ndoip->type = CIPSO_V4_MAP_PASS;\r\ndoip->tags[0] = CIPSO_V4_TAG_RBITMAP;\r\nfor (rc = 1; rc < CIPSO_V4_TAG_MAXCNT; rc++)\r\ndoip->tags[rc] = CIPSO_V4_TAG_INVALID;\r\nrc = netlbl_cfg_cipsov4_add(doip, &nai);\r\nif (rc != 0) {\r\nprintk(KERN_WARNING "%s:%d cipso add rc = %d\n",\r\n__func__, __LINE__, rc);\r\nkfree(doip);\r\nreturn;\r\n}\r\nrc = netlbl_cfg_cipsov4_map_add(doip->doi, NULL, NULL, NULL, &nai);\r\nif (rc != 0) {\r\nprintk(KERN_WARNING "%s:%d map add rc = %d\n",\r\n__func__, __LINE__, rc);\r\nkfree(doip);\r\nreturn;\r\n}\r\n}\r\nstatic void smk_unlbl_ambient(char *oldambient)\r\n{\r\nint rc;\r\nstruct netlbl_audit nai;\r\nsmk_netlabel_audit_set(&nai);\r\nif (oldambient != NULL) {\r\nrc = netlbl_cfg_map_del(oldambient, PF_INET, NULL, NULL, &nai);\r\nif (rc != 0)\r\nprintk(KERN_WARNING "%s:%d remove rc = %d\n",\r\n__func__, __LINE__, rc);\r\n}\r\nif (smack_net_ambient == NULL)\r\nsmack_net_ambient = &smack_known_floor;\r\nrc = netlbl_cfg_unlbl_map_add(smack_net_ambient->smk_known, PF_INET,\r\nNULL, NULL, &nai);\r\nif (rc != 0)\r\nprintk(KERN_WARNING "%s:%d add rc = %d\n",\r\n__func__, __LINE__, rc);\r\n}\r\nstatic void *cipso_seq_start(struct seq_file *s, loff_t *pos)\r\n{\r\nreturn smk_seq_start(s, pos, &smack_known_list);\r\n}\r\nstatic void *cipso_seq_next(struct seq_file *s, void *v, loff_t *pos)\r\n{\r\nreturn smk_seq_next(s, v, pos, &smack_known_list);\r\n}\r\nstatic int cipso_seq_show(struct seq_file *s, void *v)\r\n{\r\nstruct list_head *list = v;\r\nstruct smack_known *skp =\r\nlist_entry_rcu(list, struct smack_known, list);\r\nstruct netlbl_lsm_catmap *cmp = skp->smk_netlabel.attr.mls.cat;\r\nchar sep = '/';\r\nint i;\r\nif (strlen(skp->smk_known) >= SMK_LABELLEN)\r\nreturn 0;\r\nseq_printf(s, "%s %3d", skp->smk_known, skp->smk_netlabel.attr.mls.lvl);\r\nfor (i = netlbl_catmap_walk(cmp, 0); i >= 0;\r\ni = netlbl_catmap_walk(cmp, i + 1)) {\r\nseq_printf(s, "%c%d", sep, i);\r\nsep = ',';\r\n}\r\nseq_putc(s, '\n');\r\nreturn 0;\r\n}\r\nstatic int smk_open_cipso(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &cipso_seq_ops);\r\n}\r\nstatic ssize_t smk_set_cipso(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos, int format)\r\n{\r\nstruct smack_known *skp;\r\nstruct netlbl_lsm_secattr ncats;\r\nchar mapcatset[SMK_CIPSOLEN];\r\nint maplevel;\r\nunsigned int cat;\r\nint catlen;\r\nssize_t rc = -EINVAL;\r\nchar *data = NULL;\r\nchar *rule;\r\nint ret;\r\nint i;\r\nif (!smack_privileged(CAP_MAC_ADMIN))\r\nreturn -EPERM;\r\nif (*ppos != 0)\r\nreturn -EINVAL;\r\nif (format == SMK_FIXED24_FMT &&\r\n(count < SMK_CIPSOMIN || count > SMK_CIPSOMAX))\r\nreturn -EINVAL;\r\ndata = memdup_user_nul(buf, count);\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nrule = data;\r\nmutex_lock(&smack_cipso_lock);\r\nskp = smk_import_entry(rule, 0);\r\nif (IS_ERR(skp)) {\r\nrc = PTR_ERR(skp);\r\ngoto out;\r\n}\r\nif (format == SMK_FIXED24_FMT)\r\nrule += SMK_LABELLEN;\r\nelse\r\nrule += strlen(skp->smk_known) + 1;\r\nret = sscanf(rule, "%d", &maplevel);\r\nif (ret != 1 || maplevel > SMACK_CIPSO_MAXLEVEL)\r\ngoto out;\r\nrule += SMK_DIGITLEN;\r\nret = sscanf(rule, "%d", &catlen);\r\nif (ret != 1 || catlen > SMACK_CIPSO_MAXCATNUM)\r\ngoto out;\r\nif (format == SMK_FIXED24_FMT &&\r\ncount != (SMK_CIPSOMIN + catlen * SMK_DIGITLEN))\r\ngoto out;\r\nmemset(mapcatset, 0, sizeof(mapcatset));\r\nfor (i = 0; i < catlen; i++) {\r\nrule += SMK_DIGITLEN;\r\nret = sscanf(rule, "%u", &cat);\r\nif (ret != 1 || cat > SMACK_CIPSO_MAXCATNUM)\r\ngoto out;\r\nsmack_catset_bit(cat, mapcatset);\r\n}\r\nrc = smk_netlbl_mls(maplevel, mapcatset, &ncats, SMK_CIPSOLEN);\r\nif (rc >= 0) {\r\nnetlbl_catmap_free(skp->smk_netlabel.attr.mls.cat);\r\nskp->smk_netlabel.attr.mls.cat = ncats.attr.mls.cat;\r\nskp->smk_netlabel.attr.mls.lvl = ncats.attr.mls.lvl;\r\nrc = count;\r\n}\r\nout:\r\nmutex_unlock(&smack_cipso_lock);\r\nkfree(data);\r\nreturn rc;\r\n}\r\nstatic ssize_t smk_write_cipso(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nreturn smk_set_cipso(file, buf, count, ppos, SMK_FIXED24_FMT);\r\n}\r\nstatic int cipso2_seq_show(struct seq_file *s, void *v)\r\n{\r\nstruct list_head *list = v;\r\nstruct smack_known *skp =\r\nlist_entry_rcu(list, struct smack_known, list);\r\nstruct netlbl_lsm_catmap *cmp = skp->smk_netlabel.attr.mls.cat;\r\nchar sep = '/';\r\nint i;\r\nseq_printf(s, "%s %3d", skp->smk_known, skp->smk_netlabel.attr.mls.lvl);\r\nfor (i = netlbl_catmap_walk(cmp, 0); i >= 0;\r\ni = netlbl_catmap_walk(cmp, i + 1)) {\r\nseq_printf(s, "%c%d", sep, i);\r\nsep = ',';\r\n}\r\nseq_putc(s, '\n');\r\nreturn 0;\r\n}\r\nstatic int smk_open_cipso2(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &cipso2_seq_ops);\r\n}\r\nstatic ssize_t smk_write_cipso2(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nreturn smk_set_cipso(file, buf, count, ppos, SMK_LONG_FMT);\r\n}\r\nstatic void *net4addr_seq_start(struct seq_file *s, loff_t *pos)\r\n{\r\nreturn smk_seq_start(s, pos, &smk_net4addr_list);\r\n}\r\nstatic void *net4addr_seq_next(struct seq_file *s, void *v, loff_t *pos)\r\n{\r\nreturn smk_seq_next(s, v, pos, &smk_net4addr_list);\r\n}\r\nstatic int net4addr_seq_show(struct seq_file *s, void *v)\r\n{\r\nstruct list_head *list = v;\r\nstruct smk_net4addr *skp =\r\nlist_entry_rcu(list, struct smk_net4addr, list);\r\nchar *kp = SMACK_CIPSO_OPTION;\r\nif (skp->smk_label != NULL)\r\nkp = skp->smk_label->smk_known;\r\nseq_printf(s, "%pI4/%d %s\n", &skp->smk_host.s_addr,\r\nskp->smk_masks, kp);\r\nreturn 0;\r\n}\r\nstatic int smk_open_net4addr(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &net4addr_seq_ops);\r\n}\r\nstatic void smk_net4addr_insert(struct smk_net4addr *new)\r\n{\r\nstruct smk_net4addr *m;\r\nstruct smk_net4addr *m_next;\r\nif (list_empty(&smk_net4addr_list)) {\r\nlist_add_rcu(&new->list, &smk_net4addr_list);\r\nreturn;\r\n}\r\nm = list_entry_rcu(smk_net4addr_list.next,\r\nstruct smk_net4addr, list);\r\nif (new->smk_masks > m->smk_masks) {\r\nlist_add_rcu(&new->list, &smk_net4addr_list);\r\nreturn;\r\n}\r\nlist_for_each_entry_rcu(m, &smk_net4addr_list, list) {\r\nif (list_is_last(&m->list, &smk_net4addr_list)) {\r\nlist_add_rcu(&new->list, &m->list);\r\nreturn;\r\n}\r\nm_next = list_entry_rcu(m->list.next,\r\nstruct smk_net4addr, list);\r\nif (new->smk_masks > m_next->smk_masks) {\r\nlist_add_rcu(&new->list, &m->list);\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic ssize_t smk_write_net4addr(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct smk_net4addr *snp;\r\nstruct sockaddr_in newname;\r\nchar *smack;\r\nstruct smack_known *skp = NULL;\r\nchar *data;\r\nchar *host = (char *)&newname.sin_addr.s_addr;\r\nint rc;\r\nstruct netlbl_audit audit_info;\r\nstruct in_addr mask;\r\nunsigned int m;\r\nunsigned int masks;\r\nint found;\r\nu32 mask_bits = (1<<31);\r\n__be32 nsa;\r\nu32 temp_mask;\r\nif (!smack_privileged(CAP_MAC_ADMIN))\r\nreturn -EPERM;\r\nif (*ppos != 0)\r\nreturn -EINVAL;\r\nif (count < SMK_NETLBLADDRMIN)\r\nreturn -EINVAL;\r\ndata = memdup_user_nul(buf, count);\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nsmack = kzalloc(count + 1, GFP_KERNEL);\r\nif (smack == NULL) {\r\nrc = -ENOMEM;\r\ngoto free_data_out;\r\n}\r\nrc = sscanf(data, "%hhd.%hhd.%hhd.%hhd/%u %s",\r\n&host[0], &host[1], &host[2], &host[3], &masks, smack);\r\nif (rc != 6) {\r\nrc = sscanf(data, "%hhd.%hhd.%hhd.%hhd %s",\r\n&host[0], &host[1], &host[2], &host[3], smack);\r\nif (rc != 5) {\r\nrc = -EINVAL;\r\ngoto free_out;\r\n}\r\nm = BEBITS;\r\nmasks = 32;\r\n}\r\nif (masks > BEBITS) {\r\nrc = -EINVAL;\r\ngoto free_out;\r\n}\r\nif (smack[0] != '-') {\r\nskp = smk_import_entry(smack, 0);\r\nif (IS_ERR(skp)) {\r\nrc = PTR_ERR(skp);\r\ngoto free_out;\r\n}\r\n} else {\r\nif (strcmp(smack, SMACK_CIPSO_OPTION) != 0) {\r\nrc = -EINVAL;\r\ngoto free_out;\r\n}\r\n}\r\nfor (m = masks, temp_mask = 0; m > 0; m--) {\r\ntemp_mask |= mask_bits;\r\nmask_bits >>= 1;\r\n}\r\nmask.s_addr = cpu_to_be32(temp_mask);\r\nnewname.sin_addr.s_addr &= mask.s_addr;\r\nmutex_lock(&smk_net4addr_lock);\r\nnsa = newname.sin_addr.s_addr;\r\nfound = 0;\r\nlist_for_each_entry_rcu(snp, &smk_net4addr_list, list) {\r\nif (snp->smk_host.s_addr == nsa && snp->smk_masks == masks) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nsmk_netlabel_audit_set(&audit_info);\r\nif (found == 0) {\r\nsnp = kzalloc(sizeof(*snp), GFP_KERNEL);\r\nif (snp == NULL)\r\nrc = -ENOMEM;\r\nelse {\r\nrc = 0;\r\nsnp->smk_host.s_addr = newname.sin_addr.s_addr;\r\nsnp->smk_mask.s_addr = mask.s_addr;\r\nsnp->smk_label = skp;\r\nsnp->smk_masks = masks;\r\nsmk_net4addr_insert(snp);\r\n}\r\n} else {\r\nif (snp->smk_label != NULL)\r\nrc = netlbl_cfg_unlbl_static_del(&init_net, NULL,\r\n&snp->smk_host, &snp->smk_mask,\r\nPF_INET, &audit_info);\r\nelse\r\nrc = 0;\r\nsnp->smk_label = skp;\r\n}\r\nif (rc == 0 && skp != NULL)\r\nrc = netlbl_cfg_unlbl_static_add(&init_net, NULL,\r\n&snp->smk_host, &snp->smk_mask, PF_INET,\r\nsnp->smk_label->smk_secid, &audit_info);\r\nif (rc == 0)\r\nrc = count;\r\nmutex_unlock(&smk_net4addr_lock);\r\nfree_out:\r\nkfree(smack);\r\nfree_data_out:\r\nkfree(data);\r\nreturn rc;\r\n}\r\nstatic void *net6addr_seq_start(struct seq_file *s, loff_t *pos)\r\n{\r\nreturn smk_seq_start(s, pos, &smk_net6addr_list);\r\n}\r\nstatic void *net6addr_seq_next(struct seq_file *s, void *v, loff_t *pos)\r\n{\r\nreturn smk_seq_next(s, v, pos, &smk_net6addr_list);\r\n}\r\nstatic int net6addr_seq_show(struct seq_file *s, void *v)\r\n{\r\nstruct list_head *list = v;\r\nstruct smk_net6addr *skp =\r\nlist_entry(list, struct smk_net6addr, list);\r\nif (skp->smk_label != NULL)\r\nseq_printf(s, "%pI6/%d %s\n", &skp->smk_host, skp->smk_masks,\r\nskp->smk_label->smk_known);\r\nreturn 0;\r\n}\r\nstatic int smk_open_net6addr(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &net6addr_seq_ops);\r\n}\r\nstatic void smk_net6addr_insert(struct smk_net6addr *new)\r\n{\r\nstruct smk_net6addr *m_next;\r\nstruct smk_net6addr *m;\r\nif (list_empty(&smk_net6addr_list)) {\r\nlist_add_rcu(&new->list, &smk_net6addr_list);\r\nreturn;\r\n}\r\nm = list_entry_rcu(smk_net6addr_list.next,\r\nstruct smk_net6addr, list);\r\nif (new->smk_masks > m->smk_masks) {\r\nlist_add_rcu(&new->list, &smk_net6addr_list);\r\nreturn;\r\n}\r\nlist_for_each_entry_rcu(m, &smk_net6addr_list, list) {\r\nif (list_is_last(&m->list, &smk_net6addr_list)) {\r\nlist_add_rcu(&new->list, &m->list);\r\nreturn;\r\n}\r\nm_next = list_entry_rcu(m->list.next,\r\nstruct smk_net6addr, list);\r\nif (new->smk_masks > m_next->smk_masks) {\r\nlist_add_rcu(&new->list, &m->list);\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic ssize_t smk_write_net6addr(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct smk_net6addr *snp;\r\nstruct in6_addr newname;\r\nstruct in6_addr fullmask;\r\nstruct smack_known *skp = NULL;\r\nchar *smack;\r\nchar *data;\r\nint rc = 0;\r\nint found = 0;\r\nint i;\r\nunsigned int scanned[8];\r\nunsigned int m;\r\nunsigned int mask = 128;\r\nif (!smack_privileged(CAP_MAC_ADMIN))\r\nreturn -EPERM;\r\nif (*ppos != 0)\r\nreturn -EINVAL;\r\nif (count < SMK_NETLBLADDRMIN)\r\nreturn -EINVAL;\r\ndata = memdup_user_nul(buf, count);\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nsmack = kzalloc(count + 1, GFP_KERNEL);\r\nif (smack == NULL) {\r\nrc = -ENOMEM;\r\ngoto free_data_out;\r\n}\r\ni = sscanf(data, "%x:%x:%x:%x:%x:%x:%x:%x/%u %s",\r\n&scanned[0], &scanned[1], &scanned[2], &scanned[3],\r\n&scanned[4], &scanned[5], &scanned[6], &scanned[7],\r\n&mask, smack);\r\nif (i != 10) {\r\ni = sscanf(data, "%x:%x:%x:%x:%x:%x:%x:%x %s",\r\n&scanned[0], &scanned[1], &scanned[2],\r\n&scanned[3], &scanned[4], &scanned[5],\r\n&scanned[6], &scanned[7], smack);\r\nif (i != 9) {\r\nrc = -EINVAL;\r\ngoto free_out;\r\n}\r\n}\r\nif (mask > 128) {\r\nrc = -EINVAL;\r\ngoto free_out;\r\n}\r\nfor (i = 0; i < 8; i++) {\r\nif (scanned[i] > 0xffff) {\r\nrc = -EINVAL;\r\ngoto free_out;\r\n}\r\nnewname.s6_addr16[i] = htons(scanned[i]);\r\n}\r\nif (smack[0] != '-') {\r\nskp = smk_import_entry(smack, 0);\r\nif (IS_ERR(skp)) {\r\nrc = PTR_ERR(skp);\r\ngoto free_out;\r\n}\r\n} else {\r\nif (strcmp(smack, SMACK_DELETE_OPTION) != 0) {\r\nrc = -EINVAL;\r\ngoto free_out;\r\n}\r\n}\r\nfor (i = 0, m = mask; i < 8; i++) {\r\nif (m >= 16) {\r\nfullmask.s6_addr16[i] = 0xffff;\r\nm -= 16;\r\n} else if (m > 0) {\r\nfullmask.s6_addr16[i] = (1 << m) - 1;\r\nm = 0;\r\n} else\r\nfullmask.s6_addr16[i] = 0;\r\nnewname.s6_addr16[i] &= fullmask.s6_addr16[i];\r\n}\r\nmutex_lock(&smk_net6addr_lock);\r\nlist_for_each_entry_rcu(snp, &smk_net6addr_list, list) {\r\nif (mask != snp->smk_masks)\r\ncontinue;\r\nfor (found = 1, i = 0; i < 8; i++) {\r\nif (newname.s6_addr16[i] !=\r\nsnp->smk_host.s6_addr16[i]) {\r\nfound = 0;\r\nbreak;\r\n}\r\n}\r\nif (found == 1)\r\nbreak;\r\n}\r\nif (found == 0) {\r\nsnp = kzalloc(sizeof(*snp), GFP_KERNEL);\r\nif (snp == NULL)\r\nrc = -ENOMEM;\r\nelse {\r\nsnp->smk_host = newname;\r\nsnp->smk_mask = fullmask;\r\nsnp->smk_masks = mask;\r\nsnp->smk_label = skp;\r\nsmk_net6addr_insert(snp);\r\n}\r\n} else {\r\nsnp->smk_label = skp;\r\n}\r\nif (rc == 0)\r\nrc = count;\r\nmutex_unlock(&smk_net6addr_lock);\r\nfree_out:\r\nkfree(smack);\r\nfree_data_out:\r\nkfree(data);\r\nreturn rc;\r\n}\r\nstatic ssize_t smk_read_doi(struct file *filp, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar temp[80];\r\nssize_t rc;\r\nif (*ppos != 0)\r\nreturn 0;\r\nsprintf(temp, "%d", smk_cipso_doi_value);\r\nrc = simple_read_from_buffer(buf, count, ppos, temp, strlen(temp));\r\nreturn rc;\r\n}\r\nstatic ssize_t smk_write_doi(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar temp[80];\r\nint i;\r\nif (!smack_privileged(CAP_MAC_ADMIN))\r\nreturn -EPERM;\r\nif (count >= sizeof(temp) || count == 0)\r\nreturn -EINVAL;\r\nif (copy_from_user(temp, buf, count) != 0)\r\nreturn -EFAULT;\r\ntemp[count] = '\0';\r\nif (sscanf(temp, "%d", &i) != 1)\r\nreturn -EINVAL;\r\nsmk_cipso_doi_value = i;\r\nsmk_cipso_doi();\r\nreturn count;\r\n}\r\nstatic ssize_t smk_read_direct(struct file *filp, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar temp[80];\r\nssize_t rc;\r\nif (*ppos != 0)\r\nreturn 0;\r\nsprintf(temp, "%d", smack_cipso_direct);\r\nrc = simple_read_from_buffer(buf, count, ppos, temp, strlen(temp));\r\nreturn rc;\r\n}\r\nstatic ssize_t smk_write_direct(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct smack_known *skp;\r\nchar temp[80];\r\nint i;\r\nif (!smack_privileged(CAP_MAC_ADMIN))\r\nreturn -EPERM;\r\nif (count >= sizeof(temp) || count == 0)\r\nreturn -EINVAL;\r\nif (copy_from_user(temp, buf, count) != 0)\r\nreturn -EFAULT;\r\ntemp[count] = '\0';\r\nif (sscanf(temp, "%d", &i) != 1)\r\nreturn -EINVAL;\r\nif (smack_cipso_direct != i) {\r\nmutex_lock(&smack_known_lock);\r\nlist_for_each_entry_rcu(skp, &smack_known_list, list)\r\nif (skp->smk_netlabel.attr.mls.lvl ==\r\nsmack_cipso_direct)\r\nskp->smk_netlabel.attr.mls.lvl = i;\r\nsmack_cipso_direct = i;\r\nmutex_unlock(&smack_known_lock);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t smk_read_mapped(struct file *filp, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar temp[80];\r\nssize_t rc;\r\nif (*ppos != 0)\r\nreturn 0;\r\nsprintf(temp, "%d", smack_cipso_mapped);\r\nrc = simple_read_from_buffer(buf, count, ppos, temp, strlen(temp));\r\nreturn rc;\r\n}\r\nstatic ssize_t smk_write_mapped(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct smack_known *skp;\r\nchar temp[80];\r\nint i;\r\nif (!smack_privileged(CAP_MAC_ADMIN))\r\nreturn -EPERM;\r\nif (count >= sizeof(temp) || count == 0)\r\nreturn -EINVAL;\r\nif (copy_from_user(temp, buf, count) != 0)\r\nreturn -EFAULT;\r\ntemp[count] = '\0';\r\nif (sscanf(temp, "%d", &i) != 1)\r\nreturn -EINVAL;\r\nif (smack_cipso_mapped != i) {\r\nmutex_lock(&smack_known_lock);\r\nlist_for_each_entry_rcu(skp, &smack_known_list, list)\r\nif (skp->smk_netlabel.attr.mls.lvl ==\r\nsmack_cipso_mapped)\r\nskp->smk_netlabel.attr.mls.lvl = i;\r\nsmack_cipso_mapped = i;\r\nmutex_unlock(&smack_known_lock);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t smk_read_ambient(struct file *filp, char __user *buf,\r\nsize_t cn, loff_t *ppos)\r\n{\r\nssize_t rc;\r\nint asize;\r\nif (*ppos != 0)\r\nreturn 0;\r\nmutex_lock(&smack_ambient_lock);\r\nasize = strlen(smack_net_ambient->smk_known) + 1;\r\nif (cn >= asize)\r\nrc = simple_read_from_buffer(buf, cn, ppos,\r\nsmack_net_ambient->smk_known,\r\nasize);\r\nelse\r\nrc = -EINVAL;\r\nmutex_unlock(&smack_ambient_lock);\r\nreturn rc;\r\n}\r\nstatic ssize_t smk_write_ambient(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct smack_known *skp;\r\nchar *oldambient;\r\nchar *data;\r\nint rc = count;\r\nif (!smack_privileged(CAP_MAC_ADMIN))\r\nreturn -EPERM;\r\ndata = memdup_user_nul(buf, count);\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nskp = smk_import_entry(data, count);\r\nif (IS_ERR(skp)) {\r\nrc = PTR_ERR(skp);\r\ngoto out;\r\n}\r\nmutex_lock(&smack_ambient_lock);\r\noldambient = smack_net_ambient->smk_known;\r\nsmack_net_ambient = skp;\r\nsmk_unlbl_ambient(oldambient);\r\nmutex_unlock(&smack_ambient_lock);\r\nout:\r\nkfree(data);\r\nreturn rc;\r\n}\r\nstatic void *onlycap_seq_start(struct seq_file *s, loff_t *pos)\r\n{\r\nreturn smk_seq_start(s, pos, &smack_onlycap_list);\r\n}\r\nstatic void *onlycap_seq_next(struct seq_file *s, void *v, loff_t *pos)\r\n{\r\nreturn smk_seq_next(s, v, pos, &smack_onlycap_list);\r\n}\r\nstatic int onlycap_seq_show(struct seq_file *s, void *v)\r\n{\r\nstruct list_head *list = v;\r\nstruct smack_known_list_elem *sklep =\r\nlist_entry_rcu(list, struct smack_known_list_elem, list);\r\nseq_puts(s, sklep->smk_label->smk_known);\r\nseq_putc(s, ' ');\r\nreturn 0;\r\n}\r\nstatic int smk_open_onlycap(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &onlycap_seq_ops);\r\n}\r\nstatic void smk_list_swap_rcu(struct list_head *public,\r\nstruct list_head *private)\r\n{\r\nstruct list_head *first, *last;\r\nif (list_empty(public)) {\r\nlist_splice_init_rcu(private, public, synchronize_rcu);\r\n} else {\r\nfirst = public->next;\r\nlast = public->prev;\r\nprivate->prev->next = public;\r\nprivate->next->prev = public;\r\nrcu_assign_pointer(public->next, private->next);\r\npublic->prev = private->prev;\r\nsynchronize_rcu();\r\nprivate->next = first;\r\nprivate->prev = last;\r\nfirst->prev = private;\r\nlast->next = private;\r\n}\r\n}\r\nstatic int smk_parse_label_list(char *data, struct list_head *list)\r\n{\r\nchar *tok;\r\nstruct smack_known *skp;\r\nstruct smack_known_list_elem *sklep;\r\nwhile ((tok = strsep(&data, " ")) != NULL) {\r\nif (!*tok)\r\ncontinue;\r\nskp = smk_import_entry(tok, 0);\r\nif (IS_ERR(skp))\r\nreturn PTR_ERR(skp);\r\nsklep = kzalloc(sizeof(*sklep), GFP_KERNEL);\r\nif (sklep == NULL)\r\nreturn -ENOMEM;\r\nsklep->smk_label = skp;\r\nlist_add(&sklep->list, list);\r\n}\r\nreturn 0;\r\n}\r\nvoid smk_destroy_label_list(struct list_head *list)\r\n{\r\nstruct smack_known_list_elem *sklep;\r\nstruct smack_known_list_elem *sklep2;\r\nlist_for_each_entry_safe(sklep, sklep2, list, list)\r\nkfree(sklep);\r\nINIT_LIST_HEAD(list);\r\n}\r\nstatic ssize_t smk_write_onlycap(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar *data;\r\nLIST_HEAD(list_tmp);\r\nint rc;\r\nif (!smack_privileged(CAP_MAC_ADMIN))\r\nreturn -EPERM;\r\ndata = memdup_user_nul(buf, count);\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nrc = smk_parse_label_list(data, &list_tmp);\r\nkfree(data);\r\nif (!rc || (rc == -EINVAL && list_empty(&list_tmp))) {\r\nmutex_lock(&smack_onlycap_lock);\r\nsmk_list_swap_rcu(&smack_onlycap_list, &list_tmp);\r\nmutex_unlock(&smack_onlycap_lock);\r\nrc = count;\r\n}\r\nsmk_destroy_label_list(&list_tmp);\r\nreturn rc;\r\n}\r\nstatic ssize_t smk_read_unconfined(struct file *filp, char __user *buf,\r\nsize_t cn, loff_t *ppos)\r\n{\r\nchar *smack = "";\r\nssize_t rc = -EINVAL;\r\nint asize;\r\nif (*ppos != 0)\r\nreturn 0;\r\nif (smack_unconfined != NULL)\r\nsmack = smack_unconfined->smk_known;\r\nasize = strlen(smack) + 1;\r\nif (cn >= asize)\r\nrc = simple_read_from_buffer(buf, cn, ppos, smack, asize);\r\nreturn rc;\r\n}\r\nstatic ssize_t smk_write_unconfined(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar *data;\r\nstruct smack_known *skp;\r\nint rc = count;\r\nif (!smack_privileged(CAP_MAC_ADMIN))\r\nreturn -EPERM;\r\ndata = memdup_user_nul(buf, count);\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nskp = smk_import_entry(data, count);\r\nif (PTR_ERR(skp) == -EINVAL)\r\nskp = NULL;\r\nelse if (IS_ERR(skp)) {\r\nrc = PTR_ERR(skp);\r\ngoto freeout;\r\n}\r\nsmack_unconfined = skp;\r\nfreeout:\r\nkfree(data);\r\nreturn rc;\r\n}\r\nstatic ssize_t smk_read_logging(struct file *filp, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar temp[32];\r\nssize_t rc;\r\nif (*ppos != 0)\r\nreturn 0;\r\nsprintf(temp, "%d\n", log_policy);\r\nrc = simple_read_from_buffer(buf, count, ppos, temp, strlen(temp));\r\nreturn rc;\r\n}\r\nstatic ssize_t smk_write_logging(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar temp[32];\r\nint i;\r\nif (!smack_privileged(CAP_MAC_ADMIN))\r\nreturn -EPERM;\r\nif (count >= sizeof(temp) || count == 0)\r\nreturn -EINVAL;\r\nif (copy_from_user(temp, buf, count) != 0)\r\nreturn -EFAULT;\r\ntemp[count] = '\0';\r\nif (sscanf(temp, "%d", &i) != 1)\r\nreturn -EINVAL;\r\nif (i < 0 || i > 3)\r\nreturn -EINVAL;\r\nlog_policy = i;\r\nreturn count;\r\n}\r\nstatic void *load_self_seq_start(struct seq_file *s, loff_t *pos)\r\n{\r\nstruct task_smack *tsp = current_security();\r\nreturn smk_seq_start(s, pos, &tsp->smk_rules);\r\n}\r\nstatic void *load_self_seq_next(struct seq_file *s, void *v, loff_t *pos)\r\n{\r\nstruct task_smack *tsp = current_security();\r\nreturn smk_seq_next(s, v, pos, &tsp->smk_rules);\r\n}\r\nstatic int load_self_seq_show(struct seq_file *s, void *v)\r\n{\r\nstruct list_head *list = v;\r\nstruct smack_rule *srp =\r\nlist_entry_rcu(list, struct smack_rule, list);\r\nsmk_rule_show(s, srp, SMK_LABELLEN);\r\nreturn 0;\r\n}\r\nstatic int smk_open_load_self(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &load_self_seq_ops);\r\n}\r\nstatic ssize_t smk_write_load_self(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct task_smack *tsp = current_security();\r\nreturn smk_write_rules_list(file, buf, count, ppos, &tsp->smk_rules,\r\n&tsp->smk_rules_lock, SMK_FIXED24_FMT);\r\n}\r\nstatic ssize_t smk_user_access(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos, int format)\r\n{\r\nstruct smack_parsed_rule rule;\r\nchar *data;\r\nint res;\r\ndata = simple_transaction_get(file, buf, count);\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nif (format == SMK_FIXED24_FMT) {\r\nif (count < SMK_LOADLEN)\r\nreturn -EINVAL;\r\nres = smk_parse_rule(data, &rule, 0);\r\n} else {\r\nres = smk_parse_long_rule(data, &rule, 0, 3);\r\n}\r\nif (res >= 0)\r\nres = smk_access(rule.smk_subject, rule.smk_object,\r\nrule.smk_access1, NULL);\r\nelse if (res != -ENOENT)\r\nreturn res;\r\ndata[0] = res >= 0 ? '1' : '0';\r\ndata[1] = '\0';\r\nsimple_transaction_set(file, 2);\r\nif (format == SMK_FIXED24_FMT)\r\nreturn SMK_LOADLEN;\r\nreturn count;\r\n}\r\nstatic ssize_t smk_write_access(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nreturn smk_user_access(file, buf, count, ppos, SMK_FIXED24_FMT);\r\n}\r\nstatic int load2_seq_show(struct seq_file *s, void *v)\r\n{\r\nstruct list_head *list = v;\r\nstruct smack_master_list *smlp =\r\nlist_entry_rcu(list, struct smack_master_list, list);\r\nsmk_rule_show(s, smlp->smk_rule, SMK_LONGLABEL);\r\nreturn 0;\r\n}\r\nstatic int smk_open_load2(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &load2_seq_ops);\r\n}\r\nstatic ssize_t smk_write_load2(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nif (!smack_privileged(CAP_MAC_ADMIN))\r\nreturn -EPERM;\r\nreturn smk_write_rules_list(file, buf, count, ppos, NULL, NULL,\r\nSMK_LONG_FMT);\r\n}\r\nstatic void *load_self2_seq_start(struct seq_file *s, loff_t *pos)\r\n{\r\nstruct task_smack *tsp = current_security();\r\nreturn smk_seq_start(s, pos, &tsp->smk_rules);\r\n}\r\nstatic void *load_self2_seq_next(struct seq_file *s, void *v, loff_t *pos)\r\n{\r\nstruct task_smack *tsp = current_security();\r\nreturn smk_seq_next(s, v, pos, &tsp->smk_rules);\r\n}\r\nstatic int load_self2_seq_show(struct seq_file *s, void *v)\r\n{\r\nstruct list_head *list = v;\r\nstruct smack_rule *srp =\r\nlist_entry_rcu(list, struct smack_rule, list);\r\nsmk_rule_show(s, srp, SMK_LONGLABEL);\r\nreturn 0;\r\n}\r\nstatic int smk_open_load_self2(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &load_self2_seq_ops);\r\n}\r\nstatic ssize_t smk_write_load_self2(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct task_smack *tsp = current_security();\r\nreturn smk_write_rules_list(file, buf, count, ppos, &tsp->smk_rules,\r\n&tsp->smk_rules_lock, SMK_LONG_FMT);\r\n}\r\nstatic ssize_t smk_write_access2(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nreturn smk_user_access(file, buf, count, ppos, SMK_LONG_FMT);\r\n}\r\nstatic ssize_t smk_write_revoke_subj(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar *data;\r\nconst char *cp;\r\nstruct smack_known *skp;\r\nstruct smack_rule *sp;\r\nstruct list_head *rule_list;\r\nstruct mutex *rule_lock;\r\nint rc = count;\r\nif (*ppos != 0)\r\nreturn -EINVAL;\r\nif (!smack_privileged(CAP_MAC_ADMIN))\r\nreturn -EPERM;\r\nif (count == 0 || count > SMK_LONGLABEL)\r\nreturn -EINVAL;\r\ndata = memdup_user(buf, count);\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\ncp = smk_parse_smack(data, count);\r\nif (IS_ERR(cp)) {\r\nrc = PTR_ERR(cp);\r\ngoto out_data;\r\n}\r\nskp = smk_find_entry(cp);\r\nif (skp == NULL)\r\ngoto out_cp;\r\nrule_list = &skp->smk_rules;\r\nrule_lock = &skp->smk_rules_lock;\r\nmutex_lock(rule_lock);\r\nlist_for_each_entry_rcu(sp, rule_list, list)\r\nsp->smk_access = 0;\r\nmutex_unlock(rule_lock);\r\nout_cp:\r\nkfree(cp);\r\nout_data:\r\nkfree(data);\r\nreturn rc;\r\n}\r\nstatic int smk_init_sysfs(void)\r\n{\r\nreturn sysfs_create_mount_point(fs_kobj, "smackfs");\r\n}\r\nstatic ssize_t smk_write_change_rule(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nif (!smack_privileged(CAP_MAC_ADMIN))\r\nreturn -EPERM;\r\nreturn smk_write_rules_list(file, buf, count, ppos, NULL, NULL,\r\nSMK_CHANGE_FMT);\r\n}\r\nstatic ssize_t smk_read_syslog(struct file *filp, char __user *buf,\r\nsize_t cn, loff_t *ppos)\r\n{\r\nstruct smack_known *skp;\r\nssize_t rc = -EINVAL;\r\nint asize;\r\nif (*ppos != 0)\r\nreturn 0;\r\nif (smack_syslog_label == NULL)\r\nskp = &smack_known_star;\r\nelse\r\nskp = smack_syslog_label;\r\nasize = strlen(skp->smk_known) + 1;\r\nif (cn >= asize)\r\nrc = simple_read_from_buffer(buf, cn, ppos, skp->smk_known,\r\nasize);\r\nreturn rc;\r\n}\r\nstatic ssize_t smk_write_syslog(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar *data;\r\nstruct smack_known *skp;\r\nint rc = count;\r\nif (!smack_privileged(CAP_MAC_ADMIN))\r\nreturn -EPERM;\r\ndata = memdup_user_nul(buf, count);\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nskp = smk_import_entry(data, count);\r\nif (IS_ERR(skp))\r\nrc = PTR_ERR(skp);\r\nelse\r\nsmack_syslog_label = skp;\r\nkfree(data);\r\nreturn rc;\r\n}\r\nstatic void *relabel_self_seq_start(struct seq_file *s, loff_t *pos)\r\n{\r\nstruct task_smack *tsp = current_security();\r\nreturn smk_seq_start(s, pos, &tsp->smk_relabel);\r\n}\r\nstatic void *relabel_self_seq_next(struct seq_file *s, void *v, loff_t *pos)\r\n{\r\nstruct task_smack *tsp = current_security();\r\nreturn smk_seq_next(s, v, pos, &tsp->smk_relabel);\r\n}\r\nstatic int relabel_self_seq_show(struct seq_file *s, void *v)\r\n{\r\nstruct list_head *list = v;\r\nstruct smack_known_list_elem *sklep =\r\nlist_entry(list, struct smack_known_list_elem, list);\r\nseq_puts(s, sklep->smk_label->smk_known);\r\nseq_putc(s, ' ');\r\nreturn 0;\r\n}\r\nstatic int smk_open_relabel_self(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &relabel_self_seq_ops);\r\n}\r\nstatic ssize_t smk_write_relabel_self(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct task_smack *tsp = current_security();\r\nchar *data;\r\nint rc;\r\nLIST_HEAD(list_tmp);\r\nif (!smack_privileged(CAP_MAC_ADMIN))\r\nreturn -EPERM;\r\nif (*ppos != 0)\r\nreturn -EINVAL;\r\ndata = memdup_user_nul(buf, count);\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nrc = smk_parse_label_list(data, &list_tmp);\r\nkfree(data);\r\nif (!rc || (rc == -EINVAL && list_empty(&list_tmp))) {\r\nsmk_destroy_label_list(&tsp->smk_relabel);\r\nlist_splice(&list_tmp, &tsp->smk_relabel);\r\nreturn count;\r\n}\r\nsmk_destroy_label_list(&list_tmp);\r\nreturn rc;\r\n}\r\nstatic ssize_t smk_read_ptrace(struct file *filp, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar temp[32];\r\nssize_t rc;\r\nif (*ppos != 0)\r\nreturn 0;\r\nsprintf(temp, "%d\n", smack_ptrace_rule);\r\nrc = simple_read_from_buffer(buf, count, ppos, temp, strlen(temp));\r\nreturn rc;\r\n}\r\nstatic ssize_t smk_write_ptrace(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar temp[32];\r\nint i;\r\nif (!smack_privileged(CAP_MAC_ADMIN))\r\nreturn -EPERM;\r\nif (*ppos != 0 || count >= sizeof(temp) || count == 0)\r\nreturn -EINVAL;\r\nif (copy_from_user(temp, buf, count) != 0)\r\nreturn -EFAULT;\r\ntemp[count] = '\0';\r\nif (sscanf(temp, "%d", &i) != 1)\r\nreturn -EINVAL;\r\nif (i < SMACK_PTRACE_DEFAULT || i > SMACK_PTRACE_MAX)\r\nreturn -EINVAL;\r\nsmack_ptrace_rule = i;\r\nreturn count;\r\n}\r\nstatic int smk_fill_super(struct super_block *sb, void *data, int silent)\r\n{\r\nint rc;\r\nstruct inode *root_inode;\r\nstatic const struct tree_descr smack_files[] = {\r\n[SMK_LOAD] = {\r\n"load", &smk_load_ops, S_IRUGO|S_IWUSR},\r\n[SMK_CIPSO] = {\r\n"cipso", &smk_cipso_ops, S_IRUGO|S_IWUSR},\r\n[SMK_DOI] = {\r\n"doi", &smk_doi_ops, S_IRUGO|S_IWUSR},\r\n[SMK_DIRECT] = {\r\n"direct", &smk_direct_ops, S_IRUGO|S_IWUSR},\r\n[SMK_AMBIENT] = {\r\n"ambient", &smk_ambient_ops, S_IRUGO|S_IWUSR},\r\n[SMK_NET4ADDR] = {\r\n"netlabel", &smk_net4addr_ops, S_IRUGO|S_IWUSR},\r\n[SMK_ONLYCAP] = {\r\n"onlycap", &smk_onlycap_ops, S_IRUGO|S_IWUSR},\r\n[SMK_LOGGING] = {\r\n"logging", &smk_logging_ops, S_IRUGO|S_IWUSR},\r\n[SMK_LOAD_SELF] = {\r\n"load-self", &smk_load_self_ops, S_IRUGO|S_IWUGO},\r\n[SMK_ACCESSES] = {\r\n"access", &smk_access_ops, S_IRUGO|S_IWUGO},\r\n[SMK_MAPPED] = {\r\n"mapped", &smk_mapped_ops, S_IRUGO|S_IWUSR},\r\n[SMK_LOAD2] = {\r\n"load2", &smk_load2_ops, S_IRUGO|S_IWUSR},\r\n[SMK_LOAD_SELF2] = {\r\n"load-self2", &smk_load_self2_ops, S_IRUGO|S_IWUGO},\r\n[SMK_ACCESS2] = {\r\n"access2", &smk_access2_ops, S_IRUGO|S_IWUGO},\r\n[SMK_CIPSO2] = {\r\n"cipso2", &smk_cipso2_ops, S_IRUGO|S_IWUSR},\r\n[SMK_REVOKE_SUBJ] = {\r\n"revoke-subject", &smk_revoke_subj_ops,\r\nS_IRUGO|S_IWUSR},\r\n[SMK_CHANGE_RULE] = {\r\n"change-rule", &smk_change_rule_ops, S_IRUGO|S_IWUSR},\r\n[SMK_SYSLOG] = {\r\n"syslog", &smk_syslog_ops, S_IRUGO|S_IWUSR},\r\n[SMK_PTRACE] = {\r\n"ptrace", &smk_ptrace_ops, S_IRUGO|S_IWUSR},\r\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\r\n[SMK_UNCONFINED] = {\r\n"unconfined", &smk_unconfined_ops, S_IRUGO|S_IWUSR},\r\n#endif\r\n#if IS_ENABLED(CONFIG_IPV6)\r\n[SMK_NET6ADDR] = {\r\n"ipv6host", &smk_net6addr_ops, S_IRUGO|S_IWUSR},\r\n#endif\r\n[SMK_RELABEL_SELF] = {\r\n"relabel-self", &smk_relabel_self_ops,\r\nS_IRUGO|S_IWUGO},\r\n{""}\r\n};\r\nrc = simple_fill_super(sb, SMACK_MAGIC, smack_files);\r\nif (rc != 0) {\r\nprintk(KERN_ERR "%s failed %d while creating inodes\n",\r\n__func__, rc);\r\nreturn rc;\r\n}\r\nroot_inode = d_inode(sb->s_root);\r\nreturn 0;\r\n}\r\nstatic struct dentry *smk_mount(struct file_system_type *fs_type,\r\nint flags, const char *dev_name, void *data)\r\n{\r\nreturn mount_single(fs_type, flags, data, smk_fill_super);\r\n}\r\nstatic int __init smk_preset_netlabel(struct smack_known *skp)\r\n{\r\nskp->smk_netlabel.domain = skp->smk_known;\r\nskp->smk_netlabel.flags =\r\nNETLBL_SECATTR_DOMAIN | NETLBL_SECATTR_MLS_LVL;\r\nreturn smk_netlbl_mls(smack_cipso_direct, skp->smk_known,\r\n&skp->smk_netlabel, strlen(skp->smk_known));\r\n}\r\nstatic int __init init_smk_fs(void)\r\n{\r\nint err;\r\nint rc;\r\nif (smack_enabled == 0)\r\nreturn 0;\r\nerr = smk_init_sysfs();\r\nif (err)\r\nprintk(KERN_ERR "smackfs: sysfs mountpoint problem.\n");\r\nerr = register_filesystem(&smk_fs_type);\r\nif (!err) {\r\nsmackfs_mount = kern_mount(&smk_fs_type);\r\nif (IS_ERR(smackfs_mount)) {\r\nprintk(KERN_ERR "smackfs: could not mount!\n");\r\nerr = PTR_ERR(smackfs_mount);\r\nsmackfs_mount = NULL;\r\n}\r\n}\r\nsmk_cipso_doi();\r\nsmk_unlbl_ambient(NULL);\r\nrc = smk_preset_netlabel(&smack_known_floor);\r\nif (err == 0 && rc < 0)\r\nerr = rc;\r\nrc = smk_preset_netlabel(&smack_known_hat);\r\nif (err == 0 && rc < 0)\r\nerr = rc;\r\nrc = smk_preset_netlabel(&smack_known_huh);\r\nif (err == 0 && rc < 0)\r\nerr = rc;\r\nrc = smk_preset_netlabel(&smack_known_star);\r\nif (err == 0 && rc < 0)\r\nerr = rc;\r\nrc = smk_preset_netlabel(&smack_known_web);\r\nif (err == 0 && rc < 0)\r\nerr = rc;\r\nreturn err;\r\n}
