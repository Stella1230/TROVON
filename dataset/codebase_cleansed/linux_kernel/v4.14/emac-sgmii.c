static void emac_sgmii_link_init(struct emac_adapter *adpt)\r\n{\r\nstruct emac_sgmii *phy = &adpt->phy;\r\nu32 val;\r\nval = readl(phy->base + EMAC_SGMII_PHY_AUTONEG_CFG2);\r\nval &= ~(FORCE_AN_RX_CFG | FORCE_AN_TX_CFG);\r\nval |= AN_ENABLE;\r\nwritel(val, phy->base + EMAC_SGMII_PHY_AUTONEG_CFG2);\r\n}\r\nstatic int emac_sgmii_irq_clear(struct emac_adapter *adpt, u32 irq_bits)\r\n{\r\nstruct emac_sgmii *phy = &adpt->phy;\r\nu32 status;\r\nwritel_relaxed(irq_bits, phy->base + EMAC_SGMII_PHY_INTERRUPT_CLEAR);\r\nwritel_relaxed(IRQ_GLOBAL_CLEAR, phy->base + EMAC_SGMII_PHY_IRQ_CMD);\r\nwmb();\r\nif (readl_poll_timeout_atomic(phy->base +\r\nEMAC_SGMII_PHY_INTERRUPT_STATUS,\r\nstatus, !(status & irq_bits), 1,\r\nSGMII_PHY_IRQ_CLR_WAIT_TIME)) {\r\nnetdev_err(adpt->netdev,\r\n"error: failed clear SGMII irq: status:0x%x bits:0x%x\n",\r\nstatus, irq_bits);\r\nreturn -EIO;\r\n}\r\nwritel_relaxed(0, phy->base + EMAC_SGMII_PHY_IRQ_CMD);\r\nwritel_relaxed(0, phy->base + EMAC_SGMII_PHY_INTERRUPT_CLEAR);\r\nwmb();\r\nreturn 0;\r\n}\r\nstatic irqreturn_t emac_sgmii_interrupt(int irq, void *data)\r\n{\r\nstruct emac_adapter *adpt = data;\r\nstruct emac_sgmii *phy = &adpt->phy;\r\nu32 status;\r\nstatus = readl(phy->base + EMAC_SGMII_PHY_INTERRUPT_STATUS);\r\nstatus &= SGMII_ISR_MASK;\r\nif (!status)\r\nreturn IRQ_HANDLED;\r\nif (status & SGMII_PHY_INTERRUPT_ERR) {\r\nint count;\r\ncount = atomic_inc_return(&phy->decode_error_count);\r\nif (count == DECODE_ERROR_LIMIT) {\r\nschedule_work(&adpt->work_thread);\r\natomic_set(&phy->decode_error_count, 0);\r\n}\r\n} else {\r\natomic_set(&phy->decode_error_count, 0);\r\n}\r\nif (emac_sgmii_irq_clear(adpt, status)) {\r\nnetdev_warn(adpt->netdev, "failed to clear SGMII interrupt\n");\r\nschedule_work(&adpt->work_thread);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void emac_sgmii_reset_prepare(struct emac_adapter *adpt)\r\n{\r\nstruct emac_sgmii *phy = &adpt->phy;\r\nu32 val;\r\nval = readl(phy->base + EMAC_EMAC_WRAPPER_CSR2);\r\nwritel(((val & ~PHY_RESET) | PHY_RESET), phy->base +\r\nEMAC_EMAC_WRAPPER_CSR2);\r\nmsleep(50);\r\nval = readl(phy->base + EMAC_EMAC_WRAPPER_CSR2);\r\nwritel((val & ~PHY_RESET), phy->base + EMAC_EMAC_WRAPPER_CSR2);\r\nmsleep(50);\r\n}\r\nvoid emac_sgmii_reset(struct emac_adapter *adpt)\r\n{\r\nint ret;\r\nemac_sgmii_reset_prepare(adpt);\r\nemac_sgmii_link_init(adpt);\r\nret = adpt->phy.initialize(adpt);\r\nif (ret)\r\nnetdev_err(adpt->netdev,\r\n"could not reinitialize internal PHY (error=%i)\n",\r\nret);\r\n}\r\nstatic int emac_sgmii_open(struct emac_adapter *adpt)\r\n{\r\nstruct emac_sgmii *sgmii = &adpt->phy;\r\nint ret;\r\nif (sgmii->irq) {\r\nret = emac_sgmii_irq_clear(adpt, 0xff);\r\nif (ret)\r\nreturn ret;\r\nwritel(0, sgmii->base + EMAC_SGMII_PHY_INTERRUPT_MASK);\r\nret = request_irq(sgmii->irq, emac_sgmii_interrupt, 0,\r\n"emac-sgmii", adpt);\r\nif (ret) {\r\nnetdev_err(adpt->netdev,\r\n"could not register handler for internal PHY\n");\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int emac_sgmii_close(struct emac_adapter *adpt)\r\n{\r\nstruct emac_sgmii *sgmii = &adpt->phy;\r\nwritel(0, sgmii->base + EMAC_SGMII_PHY_INTERRUPT_MASK);\r\nfree_irq(sgmii->irq, adpt);\r\nreturn 0;\r\n}\r\nstatic int emac_sgmii_link_up(struct emac_adapter *adpt)\r\n{\r\nstruct emac_sgmii *sgmii = &adpt->phy;\r\nint ret;\r\nret = emac_sgmii_irq_clear(adpt, 0xff);\r\nif (ret)\r\nreturn ret;\r\nwritel(SGMII_ISR_MASK, sgmii->base + EMAC_SGMII_PHY_INTERRUPT_MASK);\r\nreturn 0;\r\n}\r\nstatic int emac_sgmii_link_down(struct emac_adapter *adpt)\r\n{\r\nstruct emac_sgmii *sgmii = &adpt->phy;\r\nwritel(0, sgmii->base + EMAC_SGMII_PHY_INTERRUPT_MASK);\r\nsynchronize_irq(sgmii->irq);\r\nreturn 0;\r\n}\r\nstatic int emac_sgmii_acpi_match(struct device *dev, void *data)\r\n{\r\n#ifdef CONFIG_ACPI\r\nstatic const struct acpi_device_id match_table[] = {\r\n{\r\n.id = "QCOM8071",\r\n},\r\n{}\r\n};\r\nconst struct acpi_device_id *id = acpi_match_device(match_table, dev);\r\nemac_sgmii_function *initialize = data;\r\nif (id) {\r\nacpi_handle handle = ACPI_HANDLE(dev);\r\nunsigned long long hrv;\r\nacpi_status status;\r\nstatus = acpi_evaluate_integer(handle, "_HRV", NULL, &hrv);\r\nif (status) {\r\nif (status == AE_NOT_FOUND)\r\nhrv = 1;\r\nelse\r\nreturn 0;\r\n}\r\nswitch (hrv) {\r\ncase 1:\r\n*initialize = emac_sgmii_init_qdf2432;\r\nreturn 1;\r\ncase 2:\r\n*initialize = emac_sgmii_init_qdf2400;\r\nreturn 1;\r\n}\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int emac_sgmii_dummy(struct emac_adapter *adpt)\r\n{\r\nreturn 0;\r\n}\r\nint emac_sgmii_config(struct platform_device *pdev, struct emac_adapter *adpt)\r\n{\r\nstruct platform_device *sgmii_pdev = NULL;\r\nstruct emac_sgmii *phy = &adpt->phy;\r\nstruct resource *res;\r\nint ret;\r\nif (has_acpi_companion(&pdev->dev)) {\r\nstruct device *dev;\r\ndev = device_find_child(&pdev->dev, &phy->initialize,\r\nemac_sgmii_acpi_match);\r\nif (!dev) {\r\ndev_warn(&pdev->dev, "cannot find internal phy node\n");\r\nphy->open = emac_sgmii_dummy;\r\nphy->close = emac_sgmii_dummy;\r\nphy->link_up = emac_sgmii_dummy;\r\nphy->link_down = emac_sgmii_dummy;\r\nreturn 0;\r\n}\r\nsgmii_pdev = to_platform_device(dev);\r\n} else {\r\nconst struct of_device_id *match;\r\nstruct device_node *np;\r\nnp = of_parse_phandle(pdev->dev.of_node, "internal-phy", 0);\r\nif (!np) {\r\ndev_err(&pdev->dev, "missing internal-phy property\n");\r\nreturn -ENODEV;\r\n}\r\nsgmii_pdev = of_find_device_by_node(np);\r\nif (!sgmii_pdev) {\r\ndev_err(&pdev->dev, "invalid internal-phy property\n");\r\nreturn -ENODEV;\r\n}\r\nmatch = of_match_device(emac_sgmii_dt_match, &sgmii_pdev->dev);\r\nif (!match) {\r\ndev_err(&pdev->dev, "unrecognized internal phy node\n");\r\nret = -ENODEV;\r\ngoto error_put_device;\r\n}\r\nphy->initialize = (emac_sgmii_function)match->data;\r\n}\r\nphy->open = emac_sgmii_open;\r\nphy->close = emac_sgmii_close;\r\nphy->link_up = emac_sgmii_link_up;\r\nphy->link_down = emac_sgmii_link_down;\r\nres = platform_get_resource(sgmii_pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nret = -EINVAL;\r\ngoto error_put_device;\r\n}\r\nphy->base = ioremap(res->start, resource_size(res));\r\nif (!phy->base) {\r\nret = -ENOMEM;\r\ngoto error_put_device;\r\n}\r\nres = platform_get_resource(sgmii_pdev, IORESOURCE_MEM, 1);\r\nif (res) {\r\nphy->digital = ioremap(res->start, resource_size(res));\r\nif (!phy->digital) {\r\nret = -ENOMEM;\r\ngoto error_unmap_base;\r\n}\r\n}\r\nret = phy->initialize(adpt);\r\nif (ret)\r\ngoto error;\r\nemac_sgmii_link_init(adpt);\r\nret = platform_get_irq(sgmii_pdev, 0);\r\nif (ret > 0)\r\nphy->irq = ret;\r\nput_device(&sgmii_pdev->dev);\r\nreturn 0;\r\nerror:\r\nif (phy->digital)\r\niounmap(phy->digital);\r\nerror_unmap_base:\r\niounmap(phy->base);\r\nerror_put_device:\r\nput_device(&sgmii_pdev->dev);\r\nreturn ret;\r\n}
