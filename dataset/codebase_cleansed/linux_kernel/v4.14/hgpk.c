static int hgpk_mode_from_name(const char *buf, int len)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(hgpk_mode_names); i++) {\r\nconst char *name = hgpk_mode_names[i];\r\nif (strlen(name) == len && !strncasecmp(name, buf, len))\r\nreturn i;\r\n}\r\nreturn HGPK_MODE_INVALID;\r\n}\r\nstatic int approx_half(int curr, int prev)\r\n{\r\nint belowhalf, abovehalf;\r\nif (curr < 5 || prev < 5)\r\nreturn 0;\r\nbelowhalf = (prev * 8) / 20;\r\nabovehalf = (prev * 12) / 20;\r\nreturn belowhalf < curr && curr <= abovehalf;\r\n}\r\nstatic int hgpk_discard_decay_hack(struct psmouse *psmouse, int x, int y)\r\n{\r\nstruct hgpk_data *priv = psmouse->private;\r\nint avx, avy;\r\nbool do_recal = false;\r\navx = abs(x);\r\navy = abs(y);\r\nif (avx > recalib_delta ||\r\n(avx > recalib_delta / 2 && ((avx / 4) > priv->xlast))) {\r\npsmouse_warn(psmouse, "detected %dpx jump in x\n", x);\r\npriv->xbigj = avx;\r\n} else if (approx_half(avx, priv->xbigj)) {\r\npsmouse_warn(psmouse, "detected secondary %dpx jump in x\n", x);\r\npriv->xbigj = avx;\r\npriv->xsaw_secondary++;\r\n} else {\r\nif (priv->xbigj && priv->xsaw_secondary > 1)\r\ndo_recal = true;\r\npriv->xbigj = 0;\r\npriv->xsaw_secondary = 0;\r\n}\r\nif (avy > recalib_delta ||\r\n(avy > recalib_delta / 2 && ((avy / 4) > priv->ylast))) {\r\npsmouse_warn(psmouse, "detected %dpx jump in y\n", y);\r\npriv->ybigj = avy;\r\n} else if (approx_half(avy, priv->ybigj)) {\r\npsmouse_warn(psmouse, "detected secondary %dpx jump in y\n", y);\r\npriv->ybigj = avy;\r\npriv->ysaw_secondary++;\r\n} else {\r\nif (priv->ybigj && priv->ysaw_secondary > 1)\r\ndo_recal = true;\r\npriv->ybigj = 0;\r\npriv->ysaw_secondary = 0;\r\n}\r\npriv->xlast = avx;\r\npriv->ylast = avy;\r\nif (do_recal && jumpy_delay) {\r\npsmouse_warn(psmouse, "scheduling recalibration\n");\r\npsmouse_queue_work(psmouse, &priv->recalib_wq,\r\nmsecs_to_jiffies(jumpy_delay));\r\n}\r\nreturn priv->xbigj || priv->ybigj;\r\n}\r\nstatic void hgpk_reset_spew_detection(struct hgpk_data *priv)\r\n{\r\npriv->spew_count = 0;\r\npriv->dupe_count = 0;\r\npriv->x_tally = 0;\r\npriv->y_tally = 0;\r\npriv->spew_flag = NO_SPEW;\r\n}\r\nstatic void hgpk_reset_hack_state(struct psmouse *psmouse)\r\n{\r\nstruct hgpk_data *priv = psmouse->private;\r\npriv->abs_x = priv->abs_y = -1;\r\npriv->xlast = priv->ylast = ILLEGAL_XY;\r\npriv->xbigj = priv->ybigj = 0;\r\npriv->xsaw_secondary = priv->ysaw_secondary = 0;\r\nhgpk_reset_spew_detection(priv);\r\n}\r\nstatic void hgpk_spewing_hack(struct psmouse *psmouse,\r\nint l, int r, int x, int y)\r\n{\r\nstruct hgpk_data *priv = psmouse->private;\r\nif (l || r)\r\nreturn;\r\nif (!spew_delay)\r\nreturn;\r\nif (abs(x) > 3 || abs(y) > 3) {\r\nhgpk_reset_spew_detection(priv);\r\nreturn;\r\n}\r\npriv->x_tally += x;\r\npriv->y_tally += y;\r\nswitch (priv->spew_flag) {\r\ncase NO_SPEW:\r\npriv->spew_flag = MAYBE_SPEWING;\r\ncase MAYBE_SPEWING:\r\npriv->spew_count++;\r\nif (priv->spew_count < SPEW_WATCH_COUNT)\r\nbreak;\r\npriv->spew_flag = SPEW_DETECTED;\r\ncase SPEW_DETECTED:\r\nif (abs(priv->x_tally) < 3 && abs(priv->y_tally) < 3) {\r\npsmouse_warn(psmouse, "packet spew detected (%d,%d)\n",\r\npriv->x_tally, priv->y_tally);\r\npriv->spew_flag = RECALIBRATING;\r\npsmouse_queue_work(psmouse, &priv->recalib_wq,\r\nmsecs_to_jiffies(spew_delay));\r\n}\r\nbreak;\r\ncase RECALIBRATING:\r\nbreak;\r\n}\r\n}\r\nstatic bool hgpk_is_byte_valid(struct psmouse *psmouse, unsigned char *packet)\r\n{\r\nstruct hgpk_data *priv = psmouse->private;\r\nint pktcnt = psmouse->pktcnt;\r\nbool valid;\r\nswitch (priv->mode) {\r\ncase HGPK_MODE_MOUSE:\r\nvalid = (packet[0] & 0x0C) == 0x08;\r\nbreak;\r\ncase HGPK_MODE_GLIDESENSOR:\r\nvalid = pktcnt == 1 ?\r\npacket[0] == HGPK_GS : !(packet[pktcnt - 1] & 0x80);\r\nbreak;\r\ncase HGPK_MODE_PENTABLET:\r\nvalid = pktcnt == 1 ?\r\npacket[0] == HGPK_PT : !(packet[pktcnt - 1] & 0x80);\r\nbreak;\r\ndefault:\r\nvalid = false;\r\nbreak;\r\n}\r\nif (!valid)\r\npsmouse_dbg(psmouse,\r\n"bad data, mode %d (%d) %*ph\n",\r\npriv->mode, pktcnt, 6, psmouse->packet);\r\nreturn valid;\r\n}\r\nstatic void hgpk_process_advanced_packet(struct psmouse *psmouse)\r\n{\r\nstruct hgpk_data *priv = psmouse->private;\r\nstruct input_dev *idev = psmouse->dev;\r\nunsigned char *packet = psmouse->packet;\r\nint down = !!(packet[2] & 2);\r\nint left = !!(packet[3] & 1);\r\nint right = !!(packet[3] & 2);\r\nint x = packet[1] | ((packet[2] & 0x78) << 4);\r\nint y = packet[4] | ((packet[3] & 0x70) << 3);\r\nif (priv->mode == HGPK_MODE_GLIDESENSOR) {\r\nint pt_down = !!(packet[2] & 1);\r\nint finger_down = !!(packet[2] & 2);\r\nint z = packet[5];\r\ninput_report_abs(idev, ABS_PRESSURE, z);\r\nif (tpdebug)\r\npsmouse_dbg(psmouse, "pd=%d fd=%d z=%d",\r\npt_down, finger_down, z);\r\n} else {\r\nif (tpdebug)\r\npsmouse_dbg(psmouse, "pd=%d ", down);\r\n}\r\nif (tpdebug)\r\npsmouse_dbg(psmouse, "l=%d r=%d x=%d y=%d\n",\r\nleft, right, x, y);\r\ninput_report_key(idev, BTN_TOUCH, down);\r\ninput_report_key(idev, BTN_LEFT, left);\r\ninput_report_key(idev, BTN_RIGHT, right);\r\nif (!down) {\r\nhgpk_reset_hack_state(psmouse);\r\ngoto done;\r\n}\r\nif (x == priv->abs_x && y == priv->abs_y) {\r\nif (++priv->dupe_count > SPEW_WATCH_COUNT) {\r\nif (tpdebug)\r\npsmouse_dbg(psmouse, "hard spew detected\n");\r\npriv->spew_flag = RECALIBRATING;\r\npsmouse_queue_work(psmouse, &priv->recalib_wq,\r\nmsecs_to_jiffies(spew_delay));\r\n}\r\ngoto done;\r\n}\r\npriv->dupe_count = 0;\r\nif (priv->mode != HGPK_MODE_PENTABLET && priv->abs_x != -1) {\r\nint x_diff = priv->abs_x - x;\r\nint y_diff = priv->abs_y - y;\r\nif (hgpk_discard_decay_hack(psmouse, x_diff, y_diff)) {\r\nif (tpdebug)\r\npsmouse_dbg(psmouse, "discarding\n");\r\ngoto done;\r\n}\r\nhgpk_spewing_hack(psmouse, left, right, x_diff, y_diff);\r\n}\r\ninput_report_abs(idev, ABS_X, x);\r\ninput_report_abs(idev, ABS_Y, y);\r\npriv->abs_x = x;\r\npriv->abs_y = y;\r\ndone:\r\ninput_sync(idev);\r\n}\r\nstatic void hgpk_process_simple_packet(struct psmouse *psmouse)\r\n{\r\nstruct input_dev *dev = psmouse->dev;\r\nunsigned char *packet = psmouse->packet;\r\nint left = packet[0] & 1;\r\nint right = (packet[0] >> 1) & 1;\r\nint x = packet[1] - ((packet[0] << 4) & 0x100);\r\nint y = ((packet[0] << 3) & 0x100) - packet[2];\r\nif (packet[0] & 0xc0)\r\npsmouse_dbg(psmouse,\r\n"overflow -- 0x%02x 0x%02x 0x%02x\n",\r\npacket[0], packet[1], packet[2]);\r\nif (hgpk_discard_decay_hack(psmouse, x, y)) {\r\nif (tpdebug)\r\npsmouse_dbg(psmouse, "discarding\n");\r\nreturn;\r\n}\r\nhgpk_spewing_hack(psmouse, left, right, x, y);\r\nif (tpdebug)\r\npsmouse_dbg(psmouse, "l=%d r=%d x=%d y=%d\n",\r\nleft, right, x, y);\r\ninput_report_key(dev, BTN_LEFT, left);\r\ninput_report_key(dev, BTN_RIGHT, right);\r\ninput_report_rel(dev, REL_X, x);\r\ninput_report_rel(dev, REL_Y, y);\r\ninput_sync(dev);\r\n}\r\nstatic psmouse_ret_t hgpk_process_byte(struct psmouse *psmouse)\r\n{\r\nstruct hgpk_data *priv = psmouse->private;\r\nif (!hgpk_is_byte_valid(psmouse, psmouse->packet))\r\nreturn PSMOUSE_BAD_DATA;\r\nif (psmouse->pktcnt >= psmouse->pktsize) {\r\nif (priv->mode == HGPK_MODE_MOUSE)\r\nhgpk_process_simple_packet(psmouse);\r\nelse\r\nhgpk_process_advanced_packet(psmouse);\r\nreturn PSMOUSE_FULL_PACKET;\r\n}\r\nif (priv->recalib_window) {\r\nif (time_before(jiffies, priv->recalib_window)) {\r\npsmouse_dbg(psmouse,\r\n"packet inside calibration window, queueing another recalibration\n");\r\npsmouse_queue_work(psmouse, &priv->recalib_wq,\r\nmsecs_to_jiffies(post_interrupt_delay));\r\n}\r\npriv->recalib_window = 0;\r\n}\r\nreturn PSMOUSE_GOOD_DATA;\r\n}\r\nstatic int hgpk_select_mode(struct psmouse *psmouse)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nstruct hgpk_data *priv = psmouse->private;\r\nint i;\r\nint cmd;\r\nconst int advanced_init[] = {\r\nPSMOUSE_CMD_DISABLE, PSMOUSE_CMD_DISABLE,\r\nPSMOUSE_CMD_DISABLE, PSMOUSE_CMD_DISABLE,\r\n0xf2, 0xf2, 0xf2,\r\n};\r\nswitch (priv->mode) {\r\ncase HGPK_MODE_MOUSE:\r\npsmouse->pktsize = 3;\r\nbreak;\r\ncase HGPK_MODE_GLIDESENSOR:\r\ncase HGPK_MODE_PENTABLET:\r\npsmouse->pktsize = 6;\r\nfor (i = 0; i < ARRAY_SIZE(advanced_init); i++)\r\nif (ps2_command(ps2dev, NULL, advanced_init[i]))\r\nreturn -EIO;\r\ncmd = priv->mode == HGPK_MODE_GLIDESENSOR ?\r\nPSMOUSE_CMD_SETSCALE11 : PSMOUSE_CMD_SETSCALE21;\r\nif (ps2_command(ps2dev, NULL, cmd))\r\nreturn -EIO;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void hgpk_setup_input_device(struct input_dev *input,\r\nstruct input_dev *old_input,\r\nenum hgpk_mode mode)\r\n{\r\nif (old_input) {\r\ninput->name = old_input->name;\r\ninput->phys = old_input->phys;\r\ninput->id = old_input->id;\r\ninput->dev.parent = old_input->dev.parent;\r\n}\r\nmemset(input->evbit, 0, sizeof(input->evbit));\r\nmemset(input->relbit, 0, sizeof(input->relbit));\r\nmemset(input->keybit, 0, sizeof(input->keybit));\r\n__set_bit(EV_KEY, input->evbit);\r\n__set_bit(BTN_LEFT, input->keybit);\r\n__set_bit(BTN_RIGHT, input->keybit);\r\nswitch (mode) {\r\ncase HGPK_MODE_MOUSE:\r\n__set_bit(EV_REL, input->evbit);\r\n__set_bit(REL_X, input->relbit);\r\n__set_bit(REL_Y, input->relbit);\r\nbreak;\r\ncase HGPK_MODE_GLIDESENSOR:\r\n__set_bit(BTN_TOUCH, input->keybit);\r\n__set_bit(BTN_TOOL_FINGER, input->keybit);\r\n__set_bit(EV_ABS, input->evbit);\r\ninput_set_abs_params(input, ABS_PRESSURE, 0, 15, 0, 0);\r\ninput_set_abs_params(input, ABS_X, 0, 399, 0, 0);\r\ninput_set_abs_params(input, ABS_Y, 0, 290, 0, 0);\r\ninput_abs_set_res(input, ABS_X, 8);\r\ninput_abs_set_res(input, ABS_Y, 8);\r\nbreak;\r\ncase HGPK_MODE_PENTABLET:\r\n__set_bit(BTN_TOUCH, input->keybit);\r\n__set_bit(BTN_TOOL_FINGER, input->keybit);\r\n__set_bit(EV_ABS, input->evbit);\r\ninput_set_abs_params(input, ABS_X, 0, 999, 0, 0);\r\ninput_set_abs_params(input, ABS_Y, 5, 239, 0, 0);\r\ninput_abs_set_res(input, ABS_X, 6);\r\ninput_abs_set_res(input, ABS_Y, 8);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic int hgpk_reset_device(struct psmouse *psmouse, bool recalibrate)\r\n{\r\nint err;\r\npsmouse_reset(psmouse);\r\nif (recalibrate) {\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nif (ps2_command(ps2dev, NULL, 0xf5) ||\r\nps2_command(ps2dev, NULL, 0xf5) ||\r\nps2_command(ps2dev, NULL, 0xe6) ||\r\nps2_command(ps2dev, NULL, 0xf5)) {\r\nreturn -1;\r\n}\r\nmsleep(150);\r\n}\r\nerr = hgpk_select_mode(psmouse);\r\nif (err) {\r\npsmouse_err(psmouse, "failed to select mode\n");\r\nreturn err;\r\n}\r\nhgpk_reset_hack_state(psmouse);\r\nreturn 0;\r\n}\r\nstatic int hgpk_force_recalibrate(struct psmouse *psmouse)\r\n{\r\nstruct hgpk_data *priv = psmouse->private;\r\nint err;\r\nif (psmouse->model < HGPK_MODEL_C)\r\nreturn 0;\r\nif (!autorecal) {\r\npsmouse_dbg(psmouse, "recalibration disabled, ignoring\n");\r\nreturn 0;\r\n}\r\npsmouse_dbg(psmouse, "recalibrating touchpad..\n");\r\npsmouse_set_state(psmouse, PSMOUSE_INITIALIZING);\r\nerr = hgpk_reset_device(psmouse, true);\r\nif (err)\r\nreturn err;\r\nif (psmouse_activate(psmouse))\r\nreturn -1;\r\nif (tpdebug)\r\npsmouse_dbg(psmouse, "touchpad reactivated\n");\r\nif (recal_guard_time)\r\npriv->recalib_window = jiffies +\r\nmsecs_to_jiffies(recal_guard_time);\r\nreturn 0;\r\n}\r\nstatic int hgpk_toggle_powersave(struct psmouse *psmouse, int enable)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nint timeo;\r\nint err;\r\nif (psmouse->model < HGPK_MODEL_D)\r\nreturn 0;\r\nif (enable) {\r\npsmouse_set_state(psmouse, PSMOUSE_INITIALIZING);\r\nfor (timeo = 20; timeo > 0; timeo--) {\r\nif (!ps2_sendbyte(ps2dev, PSMOUSE_CMD_DISABLE, 20))\r\nbreak;\r\nmsleep(25);\r\n}\r\nerr = hgpk_reset_device(psmouse, false);\r\nif (err) {\r\npsmouse_err(psmouse, "Failed to reset device!\n");\r\nreturn err;\r\n}\r\npsmouse_activate(psmouse);\r\npsmouse_dbg(psmouse, "Touchpad powered up.\n");\r\n} else {\r\npsmouse_dbg(psmouse, "Powering off touchpad.\n");\r\nif (ps2_command(ps2dev, NULL, 0xec) ||\r\nps2_command(ps2dev, NULL, 0xec) ||\r\nps2_command(ps2dev, NULL, 0xea)) {\r\nreturn -1;\r\n}\r\npsmouse_set_state(psmouse, PSMOUSE_IGNORE);\r\nps2_sendbyte(ps2dev, 0xec, 20);\r\n}\r\nreturn 0;\r\n}\r\nstatic int hgpk_poll(struct psmouse *psmouse)\r\n{\r\nreturn -1;\r\n}\r\nstatic int hgpk_reconnect(struct psmouse *psmouse)\r\n{\r\nstruct hgpk_data *priv = psmouse->private;\r\nif (olpc_board_at_least(olpc_board(0xb2)))\r\nif (psmouse->ps2dev.serio->dev.power.power_state.event !=\r\nPM_EVENT_ON)\r\nreturn 0;\r\npriv->powered = 1;\r\nreturn hgpk_reset_device(psmouse, false);\r\n}\r\nstatic ssize_t hgpk_show_powered(struct psmouse *psmouse, void *data, char *buf)\r\n{\r\nstruct hgpk_data *priv = psmouse->private;\r\nreturn sprintf(buf, "%d\n", priv->powered);\r\n}\r\nstatic ssize_t hgpk_set_powered(struct psmouse *psmouse, void *data,\r\nconst char *buf, size_t count)\r\n{\r\nstruct hgpk_data *priv = psmouse->private;\r\nunsigned int value;\r\nint err;\r\nerr = kstrtouint(buf, 10, &value);\r\nif (err)\r\nreturn err;\r\nif (value > 1)\r\nreturn -EINVAL;\r\nif (value != priv->powered) {\r\nerr = hgpk_toggle_powersave(psmouse, value);\r\nif (!err)\r\npriv->powered = value;\r\n}\r\nreturn err ? err : count;\r\n}\r\nstatic ssize_t attr_show_mode(struct psmouse *psmouse, void *data, char *buf)\r\n{\r\nstruct hgpk_data *priv = psmouse->private;\r\nreturn sprintf(buf, "%s\n", hgpk_mode_names[priv->mode]);\r\n}\r\nstatic ssize_t attr_set_mode(struct psmouse *psmouse, void *data,\r\nconst char *buf, size_t len)\r\n{\r\nstruct hgpk_data *priv = psmouse->private;\r\nenum hgpk_mode old_mode = priv->mode;\r\nenum hgpk_mode new_mode = hgpk_mode_from_name(buf, len);\r\nstruct input_dev *old_dev = psmouse->dev;\r\nstruct input_dev *new_dev;\r\nint err;\r\nif (new_mode == HGPK_MODE_INVALID)\r\nreturn -EINVAL;\r\nif (old_mode == new_mode)\r\nreturn len;\r\nnew_dev = input_allocate_device();\r\nif (!new_dev)\r\nreturn -ENOMEM;\r\npsmouse_set_state(psmouse, PSMOUSE_INITIALIZING);\r\npriv->mode = new_mode;\r\nerr = hgpk_reset_device(psmouse, false);\r\nif (err)\r\ngoto err_try_restore;\r\nhgpk_setup_input_device(new_dev, old_dev, new_mode);\r\npsmouse_set_state(psmouse, PSMOUSE_CMD_MODE);\r\nerr = input_register_device(new_dev);\r\nif (err)\r\ngoto err_try_restore;\r\npsmouse->dev = new_dev;\r\ninput_unregister_device(old_dev);\r\nreturn len;\r\nerr_try_restore:\r\ninput_free_device(new_dev);\r\npriv->mode = old_mode;\r\nhgpk_reset_device(psmouse, false);\r\nreturn err;\r\n}\r\nstatic ssize_t hgpk_trigger_recal_show(struct psmouse *psmouse,\r\nvoid *data, char *buf)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t hgpk_trigger_recal(struct psmouse *psmouse, void *data,\r\nconst char *buf, size_t count)\r\n{\r\nstruct hgpk_data *priv = psmouse->private;\r\nunsigned int value;\r\nint err;\r\nerr = kstrtouint(buf, 10, &value);\r\nif (err)\r\nreturn err;\r\nif (value != 1)\r\nreturn -EINVAL;\r\npsmouse_queue_work(psmouse, &priv->recalib_wq, 0);\r\nreturn count;\r\n}\r\nstatic void hgpk_disconnect(struct psmouse *psmouse)\r\n{\r\nstruct hgpk_data *priv = psmouse->private;\r\ndevice_remove_file(&psmouse->ps2dev.serio->dev,\r\n&psmouse_attr_powered.dattr);\r\ndevice_remove_file(&psmouse->ps2dev.serio->dev,\r\n&psmouse_attr_hgpk_mode.dattr);\r\nif (psmouse->model >= HGPK_MODEL_C)\r\ndevice_remove_file(&psmouse->ps2dev.serio->dev,\r\n&psmouse_attr_recalibrate.dattr);\r\npsmouse_reset(psmouse);\r\nkfree(priv);\r\n}\r\nstatic void hgpk_recalib_work(struct work_struct *work)\r\n{\r\nstruct delayed_work *w = to_delayed_work(work);\r\nstruct hgpk_data *priv = container_of(w, struct hgpk_data, recalib_wq);\r\nstruct psmouse *psmouse = priv->psmouse;\r\nif (hgpk_force_recalibrate(psmouse))\r\npsmouse_err(psmouse, "recalibration failed!\n");\r\n}\r\nstatic int hgpk_register(struct psmouse *psmouse)\r\n{\r\nstruct hgpk_data *priv = psmouse->private;\r\nint err;\r\npsmouse->protocol_handler = hgpk_process_byte;\r\npsmouse->poll = hgpk_poll;\r\npsmouse->disconnect = hgpk_disconnect;\r\npsmouse->reconnect = hgpk_reconnect;\r\npsmouse->resync_time = 0;\r\npsmouse->resetafter = 1024;\r\nhgpk_setup_input_device(psmouse->dev, NULL, priv->mode);\r\nerr = device_create_file(&psmouse->ps2dev.serio->dev,\r\n&psmouse_attr_powered.dattr);\r\nif (err) {\r\npsmouse_err(psmouse, "Failed creating 'powered' sysfs node\n");\r\nreturn err;\r\n}\r\nerr = device_create_file(&psmouse->ps2dev.serio->dev,\r\n&psmouse_attr_hgpk_mode.dattr);\r\nif (err) {\r\npsmouse_err(psmouse,\r\n"Failed creating 'hgpk_mode' sysfs node\n");\r\ngoto err_remove_powered;\r\n}\r\nif (psmouse->model >= HGPK_MODEL_C) {\r\nerr = device_create_file(&psmouse->ps2dev.serio->dev,\r\n&psmouse_attr_recalibrate.dattr);\r\nif (err) {\r\npsmouse_err(psmouse,\r\n"Failed creating 'recalibrate' sysfs node\n");\r\ngoto err_remove_mode;\r\n}\r\n}\r\nreturn 0;\r\nerr_remove_mode:\r\ndevice_remove_file(&psmouse->ps2dev.serio->dev,\r\n&psmouse_attr_hgpk_mode.dattr);\r\nerr_remove_powered:\r\ndevice_remove_file(&psmouse->ps2dev.serio->dev,\r\n&psmouse_attr_powered.dattr);\r\nreturn err;\r\n}\r\nint hgpk_init(struct psmouse *psmouse)\r\n{\r\nstruct hgpk_data *priv;\r\nint err;\r\npriv = kzalloc(sizeof(struct hgpk_data), GFP_KERNEL);\r\nif (!priv) {\r\nerr = -ENOMEM;\r\ngoto alloc_fail;\r\n}\r\npsmouse->private = priv;\r\npriv->psmouse = psmouse;\r\npriv->powered = true;\r\npriv->mode = hgpk_default_mode;\r\nINIT_DELAYED_WORK(&priv->recalib_wq, hgpk_recalib_work);\r\nerr = hgpk_reset_device(psmouse, false);\r\nif (err)\r\ngoto init_fail;\r\nerr = hgpk_register(psmouse);\r\nif (err)\r\ngoto init_fail;\r\nreturn 0;\r\ninit_fail:\r\nkfree(priv);\r\nalloc_fail:\r\nreturn err;\r\n}\r\nstatic enum hgpk_model_t hgpk_get_model(struct psmouse *psmouse)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nunsigned char param[3];\r\nif (ps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSCALE21) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSCALE21) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSCALE21) ||\r\nps2_command(ps2dev, param, PSMOUSE_CMD_GETINFO)) {\r\nreturn -EIO;\r\n}\r\npsmouse_dbg(psmouse, "ID: %*ph\n", 3, param);\r\nif (param[0] != 0x67 || param[1] != 0x00)\r\nreturn -ENODEV;\r\npsmouse_info(psmouse, "OLPC touchpad revision 0x%x\n", param[2]);\r\nreturn param[2];\r\n}\r\nint hgpk_detect(struct psmouse *psmouse, bool set_properties)\r\n{\r\nint version;\r\nversion = hgpk_get_model(psmouse);\r\nif (version < 0)\r\nreturn version;\r\nif (set_properties) {\r\npsmouse->vendor = "ALPS";\r\npsmouse->name = "HGPK";\r\npsmouse->model = version;\r\n}\r\nreturn 0;\r\n}\r\nvoid hgpk_module_init(void)\r\n{\r\nhgpk_default_mode = hgpk_mode_from_name(hgpk_mode_name,\r\nstrlen(hgpk_mode_name));\r\nif (hgpk_default_mode == HGPK_MODE_INVALID) {\r\nhgpk_default_mode = HGPK_MODE_MOUSE;\r\nstrlcpy(hgpk_mode_name, hgpk_mode_names[HGPK_MODE_MOUSE],\r\nsizeof(hgpk_mode_name));\r\n}\r\n}
