void qed_iwarp_init_devinfo(struct qed_hwfn *p_hwfn)\r\n{\r\nstruct qed_rdma_device *dev = p_hwfn->p_rdma_info->dev;\r\ndev->max_inline = IWARP_REQ_MAX_INLINE_DATA_SIZE;\r\ndev->max_qp = min_t(u32,\r\nIWARP_MAX_QPS,\r\np_hwfn->p_rdma_info->num_qps) -\r\nQED_IWARP_PREALLOC_CNT;\r\ndev->max_cq = dev->max_qp;\r\ndev->max_qp_resp_rd_atomic_resc = QED_IWARP_IRD_DEFAULT;\r\ndev->max_qp_req_rd_atomic_resc = QED_IWARP_ORD_DEFAULT;\r\n}\r\nvoid qed_iwarp_init_hw(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt)\r\n{\r\np_hwfn->rdma_prs_search_reg = PRS_REG_SEARCH_TCP;\r\nqed_wr(p_hwfn, p_ptt, p_hwfn->rdma_prs_search_reg, 1);\r\np_hwfn->b_rdma_enabled_in_prs = true;\r\n}\r\nstatic void qed_iwarp_cid_cleaned(struct qed_hwfn *p_hwfn, u32 cid)\r\n{\r\ncid -= qed_cxt_get_proto_cid_start(p_hwfn, p_hwfn->p_rdma_info->proto);\r\nspin_lock_bh(&p_hwfn->p_rdma_info->lock);\r\nif (cid < QED_IWARP_PREALLOC_CNT)\r\nqed_bmap_release_id(p_hwfn, &p_hwfn->p_rdma_info->tcp_cid_map,\r\ncid);\r\nelse\r\nqed_bmap_release_id(p_hwfn, &p_hwfn->p_rdma_info->cid_map, cid);\r\nspin_unlock_bh(&p_hwfn->p_rdma_info->lock);\r\n}\r\nstatic int qed_iwarp_alloc_cid(struct qed_hwfn *p_hwfn, u32 *cid)\r\n{\r\nint rc;\r\nspin_lock_bh(&p_hwfn->p_rdma_info->lock);\r\nrc = qed_rdma_bmap_alloc_id(p_hwfn, &p_hwfn->p_rdma_info->cid_map, cid);\r\nspin_unlock_bh(&p_hwfn->p_rdma_info->lock);\r\nif (rc) {\r\nDP_NOTICE(p_hwfn, "Failed in allocating iwarp cid\n");\r\nreturn rc;\r\n}\r\n*cid += qed_cxt_get_proto_cid_start(p_hwfn, p_hwfn->p_rdma_info->proto);\r\nrc = qed_cxt_dynamic_ilt_alloc(p_hwfn, QED_ELEM_CXT, *cid);\r\nif (rc)\r\nqed_iwarp_cid_cleaned(p_hwfn, *cid);\r\nreturn rc;\r\n}\r\nstatic void qed_iwarp_set_tcp_cid(struct qed_hwfn *p_hwfn, u32 cid)\r\n{\r\ncid -= qed_cxt_get_proto_cid_start(p_hwfn, p_hwfn->p_rdma_info->proto);\r\nspin_lock_bh(&p_hwfn->p_rdma_info->lock);\r\nqed_bmap_set_id(p_hwfn, &p_hwfn->p_rdma_info->tcp_cid_map, cid);\r\nspin_unlock_bh(&p_hwfn->p_rdma_info->lock);\r\n}\r\nstatic int qed_iwarp_alloc_tcp_cid(struct qed_hwfn *p_hwfn, u32 *cid)\r\n{\r\nint rc;\r\nspin_lock_bh(&p_hwfn->p_rdma_info->lock);\r\nrc = qed_rdma_bmap_alloc_id(p_hwfn,\r\n&p_hwfn->p_rdma_info->tcp_cid_map, cid);\r\nspin_unlock_bh(&p_hwfn->p_rdma_info->lock);\r\nif (rc) {\r\nDP_VERBOSE(p_hwfn, QED_MSG_RDMA,\r\n"can't allocate iwarp tcp cid max-count=%d\n",\r\np_hwfn->p_rdma_info->tcp_cid_map.max_count);\r\n*cid = QED_IWARP_INVALID_TCP_CID;\r\nreturn rc;\r\n}\r\n*cid += qed_cxt_get_proto_cid_start(p_hwfn,\r\np_hwfn->p_rdma_info->proto);\r\nreturn 0;\r\n}\r\nint qed_iwarp_create_qp(struct qed_hwfn *p_hwfn,\r\nstruct qed_rdma_qp *qp,\r\nstruct qed_rdma_create_qp_out_params *out_params)\r\n{\r\nstruct iwarp_create_qp_ramrod_data *p_ramrod;\r\nstruct qed_sp_init_data init_data;\r\nstruct qed_spq_entry *p_ent;\r\nu16 physical_queue;\r\nu32 cid;\r\nint rc;\r\nqp->shared_queue = dma_alloc_coherent(&p_hwfn->cdev->pdev->dev,\r\nIWARP_SHARED_QUEUE_PAGE_SIZE,\r\n&qp->shared_queue_phys_addr,\r\nGFP_KERNEL);\r\nif (!qp->shared_queue)\r\nreturn -ENOMEM;\r\nout_params->sq_pbl_virt = (u8 *)qp->shared_queue +\r\nIWARP_SHARED_QUEUE_PAGE_SQ_PBL_OFFSET;\r\nout_params->sq_pbl_phys = qp->shared_queue_phys_addr +\r\nIWARP_SHARED_QUEUE_PAGE_SQ_PBL_OFFSET;\r\nout_params->rq_pbl_virt = (u8 *)qp->shared_queue +\r\nIWARP_SHARED_QUEUE_PAGE_RQ_PBL_OFFSET;\r\nout_params->rq_pbl_phys = qp->shared_queue_phys_addr +\r\nIWARP_SHARED_QUEUE_PAGE_RQ_PBL_OFFSET;\r\nrc = qed_iwarp_alloc_cid(p_hwfn, &cid);\r\nif (rc)\r\ngoto err1;\r\nqp->icid = (u16)cid;\r\nmemset(&init_data, 0, sizeof(init_data));\r\ninit_data.opaque_fid = p_hwfn->hw_info.opaque_fid;\r\ninit_data.cid = qp->icid;\r\ninit_data.comp_mode = QED_SPQ_MODE_EBLOCK;\r\nrc = qed_sp_init_request(p_hwfn, &p_ent,\r\nIWARP_RAMROD_CMD_ID_CREATE_QP,\r\nPROTOCOLID_IWARP, &init_data);\r\nif (rc)\r\ngoto err2;\r\np_ramrod = &p_ent->ramrod.iwarp_create_qp;\r\nSET_FIELD(p_ramrod->flags,\r\nIWARP_CREATE_QP_RAMROD_DATA_FMR_AND_RESERVED_EN,\r\nqp->fmr_and_reserved_lkey);\r\nSET_FIELD(p_ramrod->flags,\r\nIWARP_CREATE_QP_RAMROD_DATA_SIGNALED_COMP, qp->signal_all);\r\nSET_FIELD(p_ramrod->flags,\r\nIWARP_CREATE_QP_RAMROD_DATA_RDMA_RD_EN,\r\nqp->incoming_rdma_read_en);\r\nSET_FIELD(p_ramrod->flags,\r\nIWARP_CREATE_QP_RAMROD_DATA_RDMA_WR_EN,\r\nqp->incoming_rdma_write_en);\r\nSET_FIELD(p_ramrod->flags,\r\nIWARP_CREATE_QP_RAMROD_DATA_ATOMIC_EN,\r\nqp->incoming_atomic_en);\r\nSET_FIELD(p_ramrod->flags,\r\nIWARP_CREATE_QP_RAMROD_DATA_SRQ_FLG, qp->use_srq);\r\np_ramrod->pd = qp->pd;\r\np_ramrod->sq_num_pages = qp->sq_num_pages;\r\np_ramrod->rq_num_pages = qp->rq_num_pages;\r\np_ramrod->qp_handle_for_cqe.hi = cpu_to_le32(qp->qp_handle.hi);\r\np_ramrod->qp_handle_for_cqe.lo = cpu_to_le32(qp->qp_handle.lo);\r\np_ramrod->cq_cid_for_sq =\r\ncpu_to_le32((p_hwfn->hw_info.opaque_fid << 16) | qp->sq_cq_id);\r\np_ramrod->cq_cid_for_rq =\r\ncpu_to_le32((p_hwfn->hw_info.opaque_fid << 16) | qp->rq_cq_id);\r\np_ramrod->dpi = cpu_to_le16(qp->dpi);\r\nphysical_queue = qed_get_cm_pq_idx(p_hwfn, PQ_FLAGS_OFLD);\r\np_ramrod->physical_q0 = cpu_to_le16(physical_queue);\r\nphysical_queue = qed_get_cm_pq_idx(p_hwfn, PQ_FLAGS_ACK);\r\np_ramrod->physical_q1 = cpu_to_le16(physical_queue);\r\nrc = qed_spq_post(p_hwfn, p_ent, NULL);\r\nif (rc)\r\ngoto err2;\r\nreturn rc;\r\nerr2:\r\nqed_iwarp_cid_cleaned(p_hwfn, cid);\r\nerr1:\r\ndma_free_coherent(&p_hwfn->cdev->pdev->dev,\r\nIWARP_SHARED_QUEUE_PAGE_SIZE,\r\nqp->shared_queue, qp->shared_queue_phys_addr);\r\nreturn rc;\r\n}\r\nstatic int qed_iwarp_modify_fw(struct qed_hwfn *p_hwfn, struct qed_rdma_qp *qp)\r\n{\r\nstruct iwarp_modify_qp_ramrod_data *p_ramrod;\r\nstruct qed_sp_init_data init_data;\r\nstruct qed_spq_entry *p_ent;\r\nint rc;\r\nmemset(&init_data, 0, sizeof(init_data));\r\ninit_data.cid = qp->icid;\r\ninit_data.opaque_fid = p_hwfn->hw_info.opaque_fid;\r\ninit_data.comp_mode = QED_SPQ_MODE_EBLOCK;\r\nrc = qed_sp_init_request(p_hwfn, &p_ent,\r\nIWARP_RAMROD_CMD_ID_MODIFY_QP,\r\np_hwfn->p_rdma_info->proto, &init_data);\r\nif (rc)\r\nreturn rc;\r\np_ramrod = &p_ent->ramrod.iwarp_modify_qp;\r\nSET_FIELD(p_ramrod->flags, IWARP_MODIFY_QP_RAMROD_DATA_STATE_TRANS_EN,\r\n0x1);\r\nif (qp->iwarp_state == QED_IWARP_QP_STATE_CLOSING)\r\np_ramrod->transition_to_state = IWARP_MODIFY_QP_STATE_CLOSING;\r\nelse\r\np_ramrod->transition_to_state = IWARP_MODIFY_QP_STATE_ERROR;\r\nrc = qed_spq_post(p_hwfn, p_ent, NULL);\r\nDP_VERBOSE(p_hwfn, QED_MSG_RDMA, "QP(0x%x)rc=%d\n", qp->icid, rc);\r\nreturn rc;\r\n}\r\nenum qed_iwarp_qp_state qed_roce2iwarp_state(enum qed_roce_qp_state state)\r\n{\r\nswitch (state) {\r\ncase QED_ROCE_QP_STATE_RESET:\r\ncase QED_ROCE_QP_STATE_INIT:\r\ncase QED_ROCE_QP_STATE_RTR:\r\nreturn QED_IWARP_QP_STATE_IDLE;\r\ncase QED_ROCE_QP_STATE_RTS:\r\nreturn QED_IWARP_QP_STATE_RTS;\r\ncase QED_ROCE_QP_STATE_SQD:\r\nreturn QED_IWARP_QP_STATE_CLOSING;\r\ncase QED_ROCE_QP_STATE_ERR:\r\nreturn QED_IWARP_QP_STATE_ERROR;\r\ncase QED_ROCE_QP_STATE_SQE:\r\nreturn QED_IWARP_QP_STATE_TERMINATE;\r\ndefault:\r\nreturn QED_IWARP_QP_STATE_ERROR;\r\n}\r\n}\r\nstatic enum qed_roce_qp_state\r\nqed_iwarp2roce_state(enum qed_iwarp_qp_state state)\r\n{\r\nswitch (state) {\r\ncase QED_IWARP_QP_STATE_IDLE:\r\nreturn QED_ROCE_QP_STATE_INIT;\r\ncase QED_IWARP_QP_STATE_RTS:\r\nreturn QED_ROCE_QP_STATE_RTS;\r\ncase QED_IWARP_QP_STATE_TERMINATE:\r\nreturn QED_ROCE_QP_STATE_SQE;\r\ncase QED_IWARP_QP_STATE_CLOSING:\r\nreturn QED_ROCE_QP_STATE_SQD;\r\ncase QED_IWARP_QP_STATE_ERROR:\r\nreturn QED_ROCE_QP_STATE_ERR;\r\ndefault:\r\nreturn QED_ROCE_QP_STATE_ERR;\r\n}\r\n}\r\nint\r\nqed_iwarp_modify_qp(struct qed_hwfn *p_hwfn,\r\nstruct qed_rdma_qp *qp,\r\nenum qed_iwarp_qp_state new_state, bool internal)\r\n{\r\nenum qed_iwarp_qp_state prev_iw_state;\r\nbool modify_fw = false;\r\nint rc = 0;\r\nspin_lock_bh(&p_hwfn->p_rdma_info->iwarp.qp_lock);\r\nprev_iw_state = qp->iwarp_state;\r\nif (prev_iw_state == new_state) {\r\nspin_unlock_bh(&p_hwfn->p_rdma_info->iwarp.qp_lock);\r\nreturn 0;\r\n}\r\nswitch (prev_iw_state) {\r\ncase QED_IWARP_QP_STATE_IDLE:\r\nswitch (new_state) {\r\ncase QED_IWARP_QP_STATE_RTS:\r\nqp->iwarp_state = QED_IWARP_QP_STATE_RTS;\r\nbreak;\r\ncase QED_IWARP_QP_STATE_ERROR:\r\nqp->iwarp_state = QED_IWARP_QP_STATE_ERROR;\r\nif (!internal)\r\nmodify_fw = true;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase QED_IWARP_QP_STATE_RTS:\r\nswitch (new_state) {\r\ncase QED_IWARP_QP_STATE_CLOSING:\r\nif (!internal)\r\nmodify_fw = true;\r\nqp->iwarp_state = QED_IWARP_QP_STATE_CLOSING;\r\nbreak;\r\ncase QED_IWARP_QP_STATE_ERROR:\r\nif (!internal)\r\nmodify_fw = true;\r\nqp->iwarp_state = QED_IWARP_QP_STATE_ERROR;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase QED_IWARP_QP_STATE_ERROR:\r\nswitch (new_state) {\r\ncase QED_IWARP_QP_STATE_IDLE:\r\nqp->iwarp_state = new_state;\r\nbreak;\r\ncase QED_IWARP_QP_STATE_CLOSING:\r\nbreak;\r\ndefault:\r\nrc = -EINVAL;\r\n}\r\nbreak;\r\ncase QED_IWARP_QP_STATE_TERMINATE:\r\ncase QED_IWARP_QP_STATE_CLOSING:\r\nqp->iwarp_state = new_state;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nDP_VERBOSE(p_hwfn, QED_MSG_RDMA, "QP(0x%x) %s --> %s%s\n",\r\nqp->icid,\r\niwarp_state_names[prev_iw_state],\r\niwarp_state_names[qp->iwarp_state],\r\ninternal ? "internal" : "");\r\nspin_unlock_bh(&p_hwfn->p_rdma_info->iwarp.qp_lock);\r\nif (modify_fw)\r\nrc = qed_iwarp_modify_fw(p_hwfn, qp);\r\nreturn rc;\r\n}\r\nint qed_iwarp_fw_destroy(struct qed_hwfn *p_hwfn, struct qed_rdma_qp *qp)\r\n{\r\nstruct qed_sp_init_data init_data;\r\nstruct qed_spq_entry *p_ent;\r\nint rc;\r\nmemset(&init_data, 0, sizeof(init_data));\r\ninit_data.cid = qp->icid;\r\ninit_data.opaque_fid = p_hwfn->hw_info.opaque_fid;\r\ninit_data.comp_mode = QED_SPQ_MODE_EBLOCK;\r\nrc = qed_sp_init_request(p_hwfn, &p_ent,\r\nIWARP_RAMROD_CMD_ID_DESTROY_QP,\r\np_hwfn->p_rdma_info->proto, &init_data);\r\nif (rc)\r\nreturn rc;\r\nrc = qed_spq_post(p_hwfn, p_ent, NULL);\r\nDP_VERBOSE(p_hwfn, QED_MSG_RDMA, "QP(0x%x) rc = %d\n", qp->icid, rc);\r\nreturn rc;\r\n}\r\nstatic void qed_iwarp_destroy_ep(struct qed_hwfn *p_hwfn,\r\nstruct qed_iwarp_ep *ep,\r\nbool remove_from_active_list)\r\n{\r\ndma_free_coherent(&p_hwfn->cdev->pdev->dev,\r\nsizeof(*ep->ep_buffer_virt),\r\nep->ep_buffer_virt, ep->ep_buffer_phys);\r\nif (remove_from_active_list) {\r\nspin_lock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\r\nlist_del(&ep->list_entry);\r\nspin_unlock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\r\n}\r\nif (ep->qp)\r\nep->qp->ep = NULL;\r\nkfree(ep);\r\n}\r\nint qed_iwarp_destroy_qp(struct qed_hwfn *p_hwfn, struct qed_rdma_qp *qp)\r\n{\r\nstruct qed_iwarp_ep *ep = qp->ep;\r\nint wait_count = 0;\r\nint rc = 0;\r\nif (qp->iwarp_state != QED_IWARP_QP_STATE_ERROR) {\r\nrc = qed_iwarp_modify_qp(p_hwfn, qp,\r\nQED_IWARP_QP_STATE_ERROR, false);\r\nif (rc)\r\nreturn rc;\r\n}\r\nif (ep) {\r\nwhile (ep->state != QED_IWARP_EP_CLOSED && wait_count++ < 200)\r\nmsleep(100);\r\nif (ep->state != QED_IWARP_EP_CLOSED)\r\nDP_NOTICE(p_hwfn, "ep state close timeout state=%x\n",\r\nep->state);\r\nqed_iwarp_destroy_ep(p_hwfn, ep, false);\r\n}\r\nrc = qed_iwarp_fw_destroy(p_hwfn, qp);\r\nif (qp->shared_queue)\r\ndma_free_coherent(&p_hwfn->cdev->pdev->dev,\r\nIWARP_SHARED_QUEUE_PAGE_SIZE,\r\nqp->shared_queue, qp->shared_queue_phys_addr);\r\nreturn rc;\r\n}\r\nstatic int\r\nqed_iwarp_create_ep(struct qed_hwfn *p_hwfn, struct qed_iwarp_ep **ep_out)\r\n{\r\nstruct qed_iwarp_ep *ep;\r\nint rc;\r\nep = kzalloc(sizeof(*ep), GFP_KERNEL);\r\nif (!ep)\r\nreturn -ENOMEM;\r\nep->state = QED_IWARP_EP_INIT;\r\nep->ep_buffer_virt = dma_alloc_coherent(&p_hwfn->cdev->pdev->dev,\r\nsizeof(*ep->ep_buffer_virt),\r\n&ep->ep_buffer_phys,\r\nGFP_KERNEL);\r\nif (!ep->ep_buffer_virt) {\r\nrc = -ENOMEM;\r\ngoto err;\r\n}\r\nep->sig = QED_EP_SIG;\r\n*ep_out = ep;\r\nreturn 0;\r\nerr:\r\nkfree(ep);\r\nreturn rc;\r\n}\r\nstatic void\r\nqed_iwarp_print_tcp_ramrod(struct qed_hwfn *p_hwfn,\r\nstruct iwarp_tcp_offload_ramrod_data *p_tcp_ramrod)\r\n{\r\nDP_VERBOSE(p_hwfn, QED_MSG_RDMA, "local_mac=%x %x %x, remote_mac=%x %x %x\n",\r\np_tcp_ramrod->tcp.local_mac_addr_lo,\r\np_tcp_ramrod->tcp.local_mac_addr_mid,\r\np_tcp_ramrod->tcp.local_mac_addr_hi,\r\np_tcp_ramrod->tcp.remote_mac_addr_lo,\r\np_tcp_ramrod->tcp.remote_mac_addr_mid,\r\np_tcp_ramrod->tcp.remote_mac_addr_hi);\r\nif (p_tcp_ramrod->tcp.ip_version == TCP_IPV4) {\r\nDP_VERBOSE(p_hwfn, QED_MSG_RDMA,\r\n"local_ip=%pI4h:%x, remote_ip=%pI4h:%x, vlan=%x\n",\r\np_tcp_ramrod->tcp.local_ip,\r\np_tcp_ramrod->tcp.local_port,\r\np_tcp_ramrod->tcp.remote_ip,\r\np_tcp_ramrod->tcp.remote_port,\r\np_tcp_ramrod->tcp.vlan_id);\r\n} else {\r\nDP_VERBOSE(p_hwfn, QED_MSG_RDMA,\r\n"local_ip=%pI6:%x, remote_ip=%pI6:%x, vlan=%x\n",\r\np_tcp_ramrod->tcp.local_ip,\r\np_tcp_ramrod->tcp.local_port,\r\np_tcp_ramrod->tcp.remote_ip,\r\np_tcp_ramrod->tcp.remote_port,\r\np_tcp_ramrod->tcp.vlan_id);\r\n}\r\nDP_VERBOSE(p_hwfn, QED_MSG_RDMA,\r\n"flow_label=%x, ttl=%x, tos_or_tc=%x, mss=%x, rcv_wnd_scale=%x, connect_mode=%x, flags=%x\n",\r\np_tcp_ramrod->tcp.flow_label,\r\np_tcp_ramrod->tcp.ttl,\r\np_tcp_ramrod->tcp.tos_or_tc,\r\np_tcp_ramrod->tcp.mss,\r\np_tcp_ramrod->tcp.rcv_wnd_scale,\r\np_tcp_ramrod->tcp.connect_mode,\r\np_tcp_ramrod->tcp.flags);\r\nDP_VERBOSE(p_hwfn, QED_MSG_RDMA, "syn_ip_payload_length=%x, lo=%x, hi=%x\n",\r\np_tcp_ramrod->tcp.syn_ip_payload_length,\r\np_tcp_ramrod->tcp.syn_phy_addr_lo,\r\np_tcp_ramrod->tcp.syn_phy_addr_hi);\r\n}\r\nstatic int\r\nqed_iwarp_tcp_offload(struct qed_hwfn *p_hwfn, struct qed_iwarp_ep *ep)\r\n{\r\nstruct qed_iwarp_info *iwarp_info = &p_hwfn->p_rdma_info->iwarp;\r\nstruct iwarp_tcp_offload_ramrod_data *p_tcp_ramrod;\r\nstruct tcp_offload_params_opt2 *tcp;\r\nstruct qed_sp_init_data init_data;\r\nstruct qed_spq_entry *p_ent;\r\ndma_addr_t async_output_phys;\r\ndma_addr_t in_pdata_phys;\r\nu16 physical_q;\r\nu8 tcp_flags;\r\nint rc;\r\nint i;\r\nmemset(&init_data, 0, sizeof(init_data));\r\ninit_data.cid = ep->tcp_cid;\r\ninit_data.opaque_fid = p_hwfn->hw_info.opaque_fid;\r\nif (ep->connect_mode == TCP_CONNECT_PASSIVE)\r\ninit_data.comp_mode = QED_SPQ_MODE_CB;\r\nelse\r\ninit_data.comp_mode = QED_SPQ_MODE_EBLOCK;\r\nrc = qed_sp_init_request(p_hwfn, &p_ent,\r\nIWARP_RAMROD_CMD_ID_TCP_OFFLOAD,\r\nPROTOCOLID_IWARP, &init_data);\r\nif (rc)\r\nreturn rc;\r\np_tcp_ramrod = &p_ent->ramrod.iwarp_tcp_offload;\r\nin_pdata_phys = ep->ep_buffer_phys +\r\noffsetof(struct qed_iwarp_ep_memory, in_pdata);\r\nDMA_REGPAIR_LE(p_tcp_ramrod->iwarp.incoming_ulp_buffer.addr,\r\nin_pdata_phys);\r\np_tcp_ramrod->iwarp.incoming_ulp_buffer.len =\r\ncpu_to_le16(sizeof(ep->ep_buffer_virt->in_pdata));\r\nasync_output_phys = ep->ep_buffer_phys +\r\noffsetof(struct qed_iwarp_ep_memory, async_output);\r\nDMA_REGPAIR_LE(p_tcp_ramrod->iwarp.async_eqe_output_buf,\r\nasync_output_phys);\r\np_tcp_ramrod->iwarp.handle_for_async.hi = cpu_to_le32(PTR_HI(ep));\r\np_tcp_ramrod->iwarp.handle_for_async.lo = cpu_to_le32(PTR_LO(ep));\r\nphysical_q = qed_get_cm_pq_idx(p_hwfn, PQ_FLAGS_OFLD);\r\np_tcp_ramrod->iwarp.physical_q0 = cpu_to_le16(physical_q);\r\nphysical_q = qed_get_cm_pq_idx(p_hwfn, PQ_FLAGS_ACK);\r\np_tcp_ramrod->iwarp.physical_q1 = cpu_to_le16(physical_q);\r\np_tcp_ramrod->iwarp.mpa_mode = iwarp_info->mpa_rev;\r\ntcp = &p_tcp_ramrod->tcp;\r\nqed_set_fw_mac_addr(&tcp->remote_mac_addr_hi,\r\n&tcp->remote_mac_addr_mid,\r\n&tcp->remote_mac_addr_lo, ep->remote_mac_addr);\r\nqed_set_fw_mac_addr(&tcp->local_mac_addr_hi, &tcp->local_mac_addr_mid,\r\n&tcp->local_mac_addr_lo, ep->local_mac_addr);\r\ntcp->vlan_id = cpu_to_le16(ep->cm_info.vlan);\r\ntcp_flags = p_hwfn->p_rdma_info->iwarp.tcp_flags;\r\ntcp->flags = 0;\r\nSET_FIELD(tcp->flags, TCP_OFFLOAD_PARAMS_OPT2_TS_EN,\r\n!!(tcp_flags & QED_IWARP_TS_EN));\r\nSET_FIELD(tcp->flags, TCP_OFFLOAD_PARAMS_OPT2_DA_EN,\r\n!!(tcp_flags & QED_IWARP_DA_EN));\r\ntcp->ip_version = ep->cm_info.ip_version;\r\nfor (i = 0; i < 4; i++) {\r\ntcp->remote_ip[i] = cpu_to_le32(ep->cm_info.remote_ip[i]);\r\ntcp->local_ip[i] = cpu_to_le32(ep->cm_info.local_ip[i]);\r\n}\r\ntcp->remote_port = cpu_to_le16(ep->cm_info.remote_port);\r\ntcp->local_port = cpu_to_le16(ep->cm_info.local_port);\r\ntcp->mss = cpu_to_le16(ep->mss);\r\ntcp->flow_label = 0;\r\ntcp->ttl = 0x40;\r\ntcp->tos_or_tc = 0;\r\ntcp->rcv_wnd_scale = (u8)p_hwfn->p_rdma_info->iwarp.rcv_wnd_scale;\r\ntcp->connect_mode = ep->connect_mode;\r\nif (ep->connect_mode == TCP_CONNECT_PASSIVE) {\r\ntcp->syn_ip_payload_length =\r\ncpu_to_le16(ep->syn_ip_payload_length);\r\ntcp->syn_phy_addr_hi = DMA_HI_LE(ep->syn_phy_addr);\r\ntcp->syn_phy_addr_lo = DMA_LO_LE(ep->syn_phy_addr);\r\n}\r\nqed_iwarp_print_tcp_ramrod(p_hwfn, p_tcp_ramrod);\r\nrc = qed_spq_post(p_hwfn, p_ent, NULL);\r\nDP_VERBOSE(p_hwfn, QED_MSG_RDMA,\r\n"EP(0x%x) Offload completed rc=%d\n", ep->tcp_cid, rc);\r\nreturn rc;\r\n}\r\nstatic void\r\nqed_iwarp_mpa_received(struct qed_hwfn *p_hwfn, struct qed_iwarp_ep *ep)\r\n{\r\nstruct qed_iwarp_info *iwarp_info = &p_hwfn->p_rdma_info->iwarp;\r\nstruct qed_iwarp_cm_event_params params;\r\nstruct mpa_v2_hdr *mpa_v2;\r\nunion async_output *async_data;\r\nu16 mpa_ord, mpa_ird;\r\nu8 mpa_hdr_size = 0;\r\nu8 mpa_rev;\r\nasync_data = &ep->ep_buffer_virt->async_output;\r\nmpa_rev = async_data->mpa_request.mpa_handshake_mode;\r\nDP_VERBOSE(p_hwfn, QED_MSG_RDMA,\r\n"private_data_len=%x handshake_mode=%x private_data=(%x)\n",\r\nasync_data->mpa_request.ulp_data_len,\r\nmpa_rev, *((u32 *)(ep->ep_buffer_virt->in_pdata)));\r\nif (mpa_rev == MPA_NEGOTIATION_TYPE_ENHANCED) {\r\nmpa_v2 = (struct mpa_v2_hdr *)ep->ep_buffer_virt->in_pdata;\r\nmpa_hdr_size = sizeof(*mpa_v2);\r\nmpa_ord = ntohs(mpa_v2->ord);\r\nmpa_ird = ntohs(mpa_v2->ird);\r\nep->cm_info.ord = (u8)min_t(u16,\r\n(mpa_ord & MPA_V2_IRD_ORD_MASK),\r\nQED_IWARP_ORD_DEFAULT);\r\nep->cm_info.ird = (u8)min_t(u16,\r\n(mpa_ird & MPA_V2_IRD_ORD_MASK),\r\nQED_IWARP_IRD_DEFAULT);\r\nep->rtr_type = MPA_RTR_TYPE_NONE;\r\nif (mpa_ird & MPA_V2_PEER2PEER_MODEL) {\r\nif (mpa_ord & MPA_V2_WRITE_RTR)\r\nep->rtr_type |= MPA_RTR_TYPE_ZERO_WRITE;\r\nif (mpa_ord & MPA_V2_READ_RTR)\r\nep->rtr_type |= MPA_RTR_TYPE_ZERO_READ;\r\nif (mpa_ird & MPA_V2_SEND_RTR)\r\nep->rtr_type |= MPA_RTR_TYPE_ZERO_SEND;\r\nep->rtr_type &= iwarp_info->rtr_type;\r\nif (ep->rtr_type == MPA_RTR_TYPE_NONE)\r\nep->rtr_type = iwarp_info->rtr_type;\r\n}\r\nep->mpa_rev = MPA_NEGOTIATION_TYPE_ENHANCED;\r\n} else {\r\nep->cm_info.ord = QED_IWARP_ORD_DEFAULT;\r\nep->cm_info.ird = QED_IWARP_IRD_DEFAULT;\r\nep->mpa_rev = MPA_NEGOTIATION_TYPE_BASIC;\r\n}\r\nDP_VERBOSE(p_hwfn, QED_MSG_RDMA,\r\n"MPA_NEGOTIATE (v%d): ORD: 0x%x IRD: 0x%x rtr:0x%x ulp_data_len = %x mpa_hdr_size = %x\n",\r\nmpa_rev, ep->cm_info.ord, ep->cm_info.ird, ep->rtr_type,\r\nasync_data->mpa_request.ulp_data_len, mpa_hdr_size);\r\nep->cm_info.private_data = ep->ep_buffer_virt->in_pdata + mpa_hdr_size;\r\nep->cm_info.private_data_len = async_data->mpa_request.ulp_data_len -\r\nmpa_hdr_size;\r\nparams.event = QED_IWARP_EVENT_MPA_REQUEST;\r\nparams.cm_info = &ep->cm_info;\r\nparams.ep_context = ep;\r\nparams.status = 0;\r\nep->state = QED_IWARP_EP_MPA_REQ_RCVD;\r\nep->event_cb(ep->cb_context, &params);\r\n}\r\nstatic int\r\nqed_iwarp_mpa_offload(struct qed_hwfn *p_hwfn, struct qed_iwarp_ep *ep)\r\n{\r\nstruct iwarp_mpa_offload_ramrod_data *p_mpa_ramrod;\r\nstruct qed_sp_init_data init_data;\r\ndma_addr_t async_output_phys;\r\nstruct qed_spq_entry *p_ent;\r\ndma_addr_t out_pdata_phys;\r\ndma_addr_t in_pdata_phys;\r\nstruct qed_rdma_qp *qp;\r\nbool reject;\r\nint rc;\r\nif (!ep)\r\nreturn -EINVAL;\r\nqp = ep->qp;\r\nreject = !qp;\r\nmemset(&init_data, 0, sizeof(init_data));\r\ninit_data.cid = reject ? ep->tcp_cid : qp->icid;\r\ninit_data.opaque_fid = p_hwfn->hw_info.opaque_fid;\r\nif (ep->connect_mode == TCP_CONNECT_ACTIVE)\r\ninit_data.comp_mode = QED_SPQ_MODE_CB;\r\nelse\r\ninit_data.comp_mode = QED_SPQ_MODE_EBLOCK;\r\nrc = qed_sp_init_request(p_hwfn, &p_ent,\r\nIWARP_RAMROD_CMD_ID_MPA_OFFLOAD,\r\nPROTOCOLID_IWARP, &init_data);\r\nif (rc)\r\nreturn rc;\r\np_mpa_ramrod = &p_ent->ramrod.iwarp_mpa_offload;\r\nout_pdata_phys = ep->ep_buffer_phys +\r\noffsetof(struct qed_iwarp_ep_memory, out_pdata);\r\nDMA_REGPAIR_LE(p_mpa_ramrod->common.outgoing_ulp_buffer.addr,\r\nout_pdata_phys);\r\np_mpa_ramrod->common.outgoing_ulp_buffer.len =\r\nep->cm_info.private_data_len;\r\np_mpa_ramrod->common.crc_needed = p_hwfn->p_rdma_info->iwarp.crc_needed;\r\np_mpa_ramrod->common.out_rq.ord = ep->cm_info.ord;\r\np_mpa_ramrod->common.out_rq.ird = ep->cm_info.ird;\r\np_mpa_ramrod->tcp_cid = p_hwfn->hw_info.opaque_fid << 16 | ep->tcp_cid;\r\nin_pdata_phys = ep->ep_buffer_phys +\r\noffsetof(struct qed_iwarp_ep_memory, in_pdata);\r\np_mpa_ramrod->tcp_connect_side = ep->connect_mode;\r\nDMA_REGPAIR_LE(p_mpa_ramrod->incoming_ulp_buffer.addr,\r\nin_pdata_phys);\r\np_mpa_ramrod->incoming_ulp_buffer.len =\r\ncpu_to_le16(sizeof(ep->ep_buffer_virt->in_pdata));\r\nasync_output_phys = ep->ep_buffer_phys +\r\noffsetof(struct qed_iwarp_ep_memory, async_output);\r\nDMA_REGPAIR_LE(p_mpa_ramrod->async_eqe_output_buf,\r\nasync_output_phys);\r\np_mpa_ramrod->handle_for_async.hi = cpu_to_le32(PTR_HI(ep));\r\np_mpa_ramrod->handle_for_async.lo = cpu_to_le32(PTR_LO(ep));\r\nif (!reject) {\r\nDMA_REGPAIR_LE(p_mpa_ramrod->shared_queue_addr,\r\nqp->shared_queue_phys_addr);\r\np_mpa_ramrod->stats_counter_id =\r\nRESC_START(p_hwfn, QED_RDMA_STATS_QUEUE) + qp->stats_queue;\r\n} else {\r\np_mpa_ramrod->common.reject = 1;\r\n}\r\np_mpa_ramrod->mode = ep->mpa_rev;\r\nSET_FIELD(p_mpa_ramrod->rtr_pref,\r\nIWARP_MPA_OFFLOAD_RAMROD_DATA_RTR_SUPPORTED, ep->rtr_type);\r\nep->state = QED_IWARP_EP_MPA_OFFLOADED;\r\nrc = qed_spq_post(p_hwfn, p_ent, NULL);\r\nif (!reject)\r\nep->cid = qp->icid;\r\nDP_VERBOSE(p_hwfn,\r\nQED_MSG_RDMA,\r\n"QP(0x%x) EP(0x%x) MPA Offload rc = %d IRD=0x%x ORD=0x%x rtr_type=%d mpa_rev=%d reject=%d\n",\r\nreject ? 0xffff : qp->icid,\r\nep->tcp_cid,\r\nrc,\r\nep->cm_info.ird,\r\nep->cm_info.ord, ep->rtr_type, ep->mpa_rev, reject);\r\nreturn rc;\r\n}\r\nstatic void\r\nqed_iwarp_return_ep(struct qed_hwfn *p_hwfn, struct qed_iwarp_ep *ep)\r\n{\r\nep->state = QED_IWARP_EP_INIT;\r\nif (ep->qp)\r\nep->qp->ep = NULL;\r\nep->qp = NULL;\r\nmemset(&ep->cm_info, 0, sizeof(ep->cm_info));\r\nif (ep->tcp_cid == QED_IWARP_INVALID_TCP_CID) {\r\nqed_iwarp_alloc_tcp_cid(p_hwfn, &ep->tcp_cid);\r\n}\r\nspin_lock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\r\nlist_del(&ep->list_entry);\r\nlist_add_tail(&ep->list_entry,\r\n&p_hwfn->p_rdma_info->iwarp.ep_free_list);\r\nspin_unlock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\r\n}\r\nvoid\r\nqed_iwarp_parse_private_data(struct qed_hwfn *p_hwfn, struct qed_iwarp_ep *ep)\r\n{\r\nstruct mpa_v2_hdr *mpa_v2_params;\r\nunion async_output *async_data;\r\nu16 mpa_ird, mpa_ord;\r\nu8 mpa_data_size = 0;\r\nif (MPA_REV2(p_hwfn->p_rdma_info->iwarp.mpa_rev)) {\r\nmpa_v2_params =\r\n(struct mpa_v2_hdr *)(ep->ep_buffer_virt->in_pdata);\r\nmpa_data_size = sizeof(*mpa_v2_params);\r\nmpa_ird = ntohs(mpa_v2_params->ird);\r\nmpa_ord = ntohs(mpa_v2_params->ord);\r\nep->cm_info.ird = (u8)(mpa_ord & MPA_V2_IRD_ORD_MASK);\r\nep->cm_info.ord = (u8)(mpa_ird & MPA_V2_IRD_ORD_MASK);\r\n}\r\nasync_data = &ep->ep_buffer_virt->async_output;\r\nep->cm_info.private_data = ep->ep_buffer_virt->in_pdata + mpa_data_size;\r\nep->cm_info.private_data_len = async_data->mpa_response.ulp_data_len -\r\nmpa_data_size;\r\n}\r\nvoid\r\nqed_iwarp_mpa_reply_arrived(struct qed_hwfn *p_hwfn, struct qed_iwarp_ep *ep)\r\n{\r\nstruct qed_iwarp_cm_event_params params;\r\nif (ep->connect_mode == TCP_CONNECT_PASSIVE) {\r\nDP_NOTICE(p_hwfn,\r\n"MPA reply event not expected on passive side!\n");\r\nreturn;\r\n}\r\nparams.event = QED_IWARP_EVENT_ACTIVE_MPA_REPLY;\r\nqed_iwarp_parse_private_data(p_hwfn, ep);\r\nDP_VERBOSE(p_hwfn, QED_MSG_RDMA,\r\n"MPA_NEGOTIATE (v%d): ORD: 0x%x IRD: 0x%x\n",\r\nep->mpa_rev, ep->cm_info.ord, ep->cm_info.ird);\r\nparams.cm_info = &ep->cm_info;\r\nparams.ep_context = ep;\r\nparams.status = 0;\r\nep->mpa_reply_processed = true;\r\nep->event_cb(ep->cb_context, &params);\r\n}\r\nstatic void\r\nqed_iwarp_mpa_complete(struct qed_hwfn *p_hwfn,\r\nstruct qed_iwarp_ep *ep, u8 fw_return_code)\r\n{\r\nstruct qed_iwarp_cm_event_params params;\r\nif (ep->connect_mode == TCP_CONNECT_ACTIVE)\r\nparams.event = QED_IWARP_EVENT_ACTIVE_COMPLETE;\r\nelse\r\nparams.event = QED_IWARP_EVENT_PASSIVE_COMPLETE;\r\nif (ep->connect_mode == TCP_CONNECT_ACTIVE && !ep->mpa_reply_processed)\r\nqed_iwarp_parse_private_data(p_hwfn, ep);\r\nDP_VERBOSE(p_hwfn, QED_MSG_RDMA,\r\n"MPA_NEGOTIATE (v%d): ORD: 0x%x IRD: 0x%x\n",\r\nep->mpa_rev, ep->cm_info.ord, ep->cm_info.ird);\r\nparams.cm_info = &ep->cm_info;\r\nparams.ep_context = ep;\r\nep->state = QED_IWARP_EP_CLOSED;\r\nswitch (fw_return_code) {\r\ncase RDMA_RETURN_OK:\r\nep->qp->max_rd_atomic_req = ep->cm_info.ord;\r\nep->qp->max_rd_atomic_resp = ep->cm_info.ird;\r\nqed_iwarp_modify_qp(p_hwfn, ep->qp, QED_IWARP_QP_STATE_RTS, 1);\r\nep->state = QED_IWARP_EP_ESTABLISHED;\r\nparams.status = 0;\r\nbreak;\r\ncase IWARP_CONN_ERROR_MPA_TIMEOUT:\r\nDP_NOTICE(p_hwfn, "%s(0x%x) MPA timeout\n",\r\nQED_IWARP_CONNECT_MODE_STRING(ep), ep->cid);\r\nparams.status = -EBUSY;\r\nbreak;\r\ncase IWARP_CONN_ERROR_MPA_ERROR_REJECT:\r\nDP_NOTICE(p_hwfn, "%s(0x%x) MPA Reject\n",\r\nQED_IWARP_CONNECT_MODE_STRING(ep), ep->cid);\r\nparams.status = -ECONNREFUSED;\r\nbreak;\r\ncase IWARP_CONN_ERROR_MPA_RST:\r\nDP_NOTICE(p_hwfn, "%s(0x%x) MPA reset(tcp cid: 0x%x)\n",\r\nQED_IWARP_CONNECT_MODE_STRING(ep), ep->cid,\r\nep->tcp_cid);\r\nparams.status = -ECONNRESET;\r\nbreak;\r\ncase IWARP_CONN_ERROR_MPA_FIN:\r\nDP_NOTICE(p_hwfn, "%s(0x%x) MPA received FIN\n",\r\nQED_IWARP_CONNECT_MODE_STRING(ep), ep->cid);\r\nparams.status = -ECONNREFUSED;\r\nbreak;\r\ncase IWARP_CONN_ERROR_MPA_INSUF_IRD:\r\nDP_NOTICE(p_hwfn, "%s(0x%x) MPA insufficient ird\n",\r\nQED_IWARP_CONNECT_MODE_STRING(ep), ep->cid);\r\nparams.status = -ECONNREFUSED;\r\nbreak;\r\ncase IWARP_CONN_ERROR_MPA_RTR_MISMATCH:\r\nDP_NOTICE(p_hwfn, "%s(0x%x) MPA RTR MISMATCH\n",\r\nQED_IWARP_CONNECT_MODE_STRING(ep), ep->cid);\r\nparams.status = -ECONNREFUSED;\r\nbreak;\r\ncase IWARP_CONN_ERROR_MPA_INVALID_PACKET:\r\nDP_NOTICE(p_hwfn, "%s(0x%x) MPA Invalid Packet\n",\r\nQED_IWARP_CONNECT_MODE_STRING(ep), ep->cid);\r\nparams.status = -ECONNREFUSED;\r\nbreak;\r\ncase IWARP_CONN_ERROR_MPA_LOCAL_ERROR:\r\nDP_NOTICE(p_hwfn, "%s(0x%x) MPA Local Error\n",\r\nQED_IWARP_CONNECT_MODE_STRING(ep), ep->cid);\r\nparams.status = -ECONNREFUSED;\r\nbreak;\r\ncase IWARP_CONN_ERROR_MPA_TERMINATE:\r\nDP_NOTICE(p_hwfn, "%s(0x%x) MPA TERMINATE\n",\r\nQED_IWARP_CONNECT_MODE_STRING(ep), ep->cid);\r\nparams.status = -ECONNREFUSED;\r\nbreak;\r\ndefault:\r\nparams.status = -ECONNRESET;\r\nbreak;\r\n}\r\nep->event_cb(ep->cb_context, &params);\r\nif (fw_return_code != RDMA_RETURN_OK) {\r\nep->tcp_cid = QED_IWARP_INVALID_TCP_CID;\r\nif ((ep->connect_mode == TCP_CONNECT_PASSIVE) &&\r\n(!ep->qp)) {\r\nqed_iwarp_return_ep(p_hwfn, ep);\r\n} else {\r\nspin_lock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\r\nlist_del(&ep->list_entry);\r\nspin_unlock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\r\n}\r\n}\r\n}\r\nstatic void\r\nqed_iwarp_mpa_v2_set_private(struct qed_hwfn *p_hwfn,\r\nstruct qed_iwarp_ep *ep, u8 *mpa_data_size)\r\n{\r\nstruct mpa_v2_hdr *mpa_v2_params;\r\nu16 mpa_ird, mpa_ord;\r\n*mpa_data_size = 0;\r\nif (MPA_REV2(ep->mpa_rev)) {\r\nmpa_v2_params =\r\n(struct mpa_v2_hdr *)ep->ep_buffer_virt->out_pdata;\r\n*mpa_data_size = sizeof(*mpa_v2_params);\r\nmpa_ird = (u16)ep->cm_info.ird;\r\nmpa_ord = (u16)ep->cm_info.ord;\r\nif (ep->rtr_type != MPA_RTR_TYPE_NONE) {\r\nmpa_ird |= MPA_V2_PEER2PEER_MODEL;\r\nif (ep->rtr_type & MPA_RTR_TYPE_ZERO_SEND)\r\nmpa_ird |= MPA_V2_SEND_RTR;\r\nif (ep->rtr_type & MPA_RTR_TYPE_ZERO_WRITE)\r\nmpa_ord |= MPA_V2_WRITE_RTR;\r\nif (ep->rtr_type & MPA_RTR_TYPE_ZERO_READ)\r\nmpa_ord |= MPA_V2_READ_RTR;\r\n}\r\nmpa_v2_params->ird = htons(mpa_ird);\r\nmpa_v2_params->ord = htons(mpa_ord);\r\nDP_VERBOSE(p_hwfn,\r\nQED_MSG_RDMA,\r\n"MPA_NEGOTIATE Header: [%x ord:%x ird] %x ord:%x ird:%x peer2peer:%x rtr_send:%x rtr_write:%x rtr_read:%x\n",\r\nmpa_v2_params->ird,\r\nmpa_v2_params->ord,\r\n*((u32 *)mpa_v2_params),\r\nmpa_ord & MPA_V2_IRD_ORD_MASK,\r\nmpa_ird & MPA_V2_IRD_ORD_MASK,\r\n!!(mpa_ird & MPA_V2_PEER2PEER_MODEL),\r\n!!(mpa_ird & MPA_V2_SEND_RTR),\r\n!!(mpa_ord & MPA_V2_WRITE_RTR),\r\n!!(mpa_ord & MPA_V2_READ_RTR));\r\n}\r\n}\r\nint qed_iwarp_connect(void *rdma_cxt,\r\nstruct qed_iwarp_connect_in *iparams,\r\nstruct qed_iwarp_connect_out *oparams)\r\n{\r\nstruct qed_hwfn *p_hwfn = rdma_cxt;\r\nstruct qed_iwarp_info *iwarp_info;\r\nstruct qed_iwarp_ep *ep;\r\nu8 mpa_data_size = 0;\r\nu8 ts_hdr_size = 0;\r\nu32 cid;\r\nint rc;\r\nif ((iparams->cm_info.ord > QED_IWARP_ORD_DEFAULT) ||\r\n(iparams->cm_info.ird > QED_IWARP_IRD_DEFAULT)) {\r\nDP_NOTICE(p_hwfn,\r\n"QP(0x%x) ERROR: Invalid ord(0x%x)/ird(0x%x)\n",\r\niparams->qp->icid, iparams->cm_info.ord,\r\niparams->cm_info.ird);\r\nreturn -EINVAL;\r\n}\r\niwarp_info = &p_hwfn->p_rdma_info->iwarp;\r\nrc = qed_iwarp_alloc_cid(p_hwfn, &cid);\r\nif (rc)\r\nreturn rc;\r\nrc = qed_iwarp_create_ep(p_hwfn, &ep);\r\nif (rc)\r\ngoto err;\r\nep->tcp_cid = cid;\r\nspin_lock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\r\nlist_add_tail(&ep->list_entry, &p_hwfn->p_rdma_info->iwarp.ep_list);\r\nspin_unlock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\r\nep->qp = iparams->qp;\r\nep->qp->ep = ep;\r\nether_addr_copy(ep->remote_mac_addr, iparams->remote_mac_addr);\r\nether_addr_copy(ep->local_mac_addr, iparams->local_mac_addr);\r\nmemcpy(&ep->cm_info, &iparams->cm_info, sizeof(ep->cm_info));\r\nep->cm_info.ord = iparams->cm_info.ord;\r\nep->cm_info.ird = iparams->cm_info.ird;\r\nep->rtr_type = iwarp_info->rtr_type;\r\nif (!iwarp_info->peer2peer)\r\nep->rtr_type = MPA_RTR_TYPE_NONE;\r\nif ((ep->rtr_type & MPA_RTR_TYPE_ZERO_READ) && (ep->cm_info.ord == 0))\r\nep->cm_info.ord = 1;\r\nep->mpa_rev = iwarp_info->mpa_rev;\r\nqed_iwarp_mpa_v2_set_private(p_hwfn, ep, &mpa_data_size);\r\nep->cm_info.private_data = ep->ep_buffer_virt->out_pdata;\r\nep->cm_info.private_data_len = iparams->cm_info.private_data_len +\r\nmpa_data_size;\r\nmemcpy((u8 *)ep->ep_buffer_virt->out_pdata + mpa_data_size,\r\niparams->cm_info.private_data,\r\niparams->cm_info.private_data_len);\r\nif (p_hwfn->p_rdma_info->iwarp.tcp_flags & QED_IWARP_TS_EN)\r\nts_hdr_size = TIMESTAMP_HEADER_SIZE;\r\nep->mss = iparams->mss - ts_hdr_size;\r\nep->mss = min_t(u16, QED_IWARP_MAX_FW_MSS, ep->mss);\r\nep->event_cb = iparams->event_cb;\r\nep->cb_context = iparams->cb_context;\r\nep->connect_mode = TCP_CONNECT_ACTIVE;\r\noparams->ep_context = ep;\r\nrc = qed_iwarp_tcp_offload(p_hwfn, ep);\r\nDP_VERBOSE(p_hwfn, QED_MSG_RDMA, "QP(0x%x) EP(0x%x) rc = %d\n",\r\niparams->qp->icid, ep->tcp_cid, rc);\r\nif (rc) {\r\nqed_iwarp_destroy_ep(p_hwfn, ep, true);\r\ngoto err;\r\n}\r\nreturn rc;\r\nerr:\r\nqed_iwarp_cid_cleaned(p_hwfn, cid);\r\nreturn rc;\r\n}\r\nstatic struct qed_iwarp_ep *qed_iwarp_get_free_ep(struct qed_hwfn *p_hwfn)\r\n{\r\nstruct qed_iwarp_ep *ep = NULL;\r\nint rc;\r\nspin_lock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\r\nif (list_empty(&p_hwfn->p_rdma_info->iwarp.ep_free_list)) {\r\nDP_ERR(p_hwfn, "Ep list is empty\n");\r\ngoto out;\r\n}\r\nep = list_first_entry(&p_hwfn->p_rdma_info->iwarp.ep_free_list,\r\nstruct qed_iwarp_ep, list_entry);\r\nif (ep->tcp_cid == QED_IWARP_INVALID_TCP_CID) {\r\nrc = qed_iwarp_alloc_tcp_cid(p_hwfn, &ep->tcp_cid);\r\nif (rc) {\r\nep->tcp_cid = QED_IWARP_INVALID_TCP_CID;\r\nep = NULL;\r\ngoto out;\r\n}\r\n}\r\nlist_del(&ep->list_entry);\r\nout:\r\nspin_unlock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\r\nreturn ep;\r\n}\r\nstatic int\r\nqed_iwarp_wait_cid_map_cleared(struct qed_hwfn *p_hwfn, struct qed_bmap *bmap)\r\n{\r\nint prev_weight = 0;\r\nint wait_count = 0;\r\nint weight = 0;\r\nweight = bitmap_weight(bmap->bitmap, bmap->max_count);\r\nprev_weight = weight;\r\nwhile (weight) {\r\nmsleep(QED_IWARP_MAX_CID_CLEAN_TIME);\r\nweight = bitmap_weight(bmap->bitmap, bmap->max_count);\r\nif (prev_weight == weight) {\r\nwait_count++;\r\n} else {\r\nprev_weight = weight;\r\nwait_count = 0;\r\n}\r\nif (wait_count > QED_IWARP_MAX_NO_PROGRESS_CNT) {\r\nDP_NOTICE(p_hwfn,\r\n"%s bitmap wait timed out (%d cids pending)\n",\r\nbmap->name, weight);\r\nreturn -EBUSY;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int qed_iwarp_wait_for_all_cids(struct qed_hwfn *p_hwfn)\r\n{\r\nint rc;\r\nint i;\r\nrc = qed_iwarp_wait_cid_map_cleared(p_hwfn,\r\n&p_hwfn->p_rdma_info->tcp_cid_map);\r\nif (rc)\r\nreturn rc;\r\nfor (i = 0; i < QED_IWARP_PREALLOC_CNT; i++)\r\nqed_bmap_release_id(p_hwfn, &p_hwfn->p_rdma_info->cid_map, i);\r\nreturn qed_iwarp_wait_cid_map_cleared(p_hwfn,\r\n&p_hwfn->p_rdma_info->cid_map);\r\n}\r\nstatic void qed_iwarp_free_prealloc_ep(struct qed_hwfn *p_hwfn)\r\n{\r\nstruct qed_iwarp_ep *ep;\r\nwhile (!list_empty(&p_hwfn->p_rdma_info->iwarp.ep_free_list)) {\r\nspin_lock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\r\nep = list_first_entry(&p_hwfn->p_rdma_info->iwarp.ep_free_list,\r\nstruct qed_iwarp_ep, list_entry);\r\nif (!ep) {\r\nspin_unlock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\r\nbreak;\r\n}\r\nlist_del(&ep->list_entry);\r\nspin_unlock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\r\nif (ep->tcp_cid != QED_IWARP_INVALID_TCP_CID)\r\nqed_iwarp_cid_cleaned(p_hwfn, ep->tcp_cid);\r\nqed_iwarp_destroy_ep(p_hwfn, ep, false);\r\n}\r\n}\r\nstatic int qed_iwarp_prealloc_ep(struct qed_hwfn *p_hwfn, bool init)\r\n{\r\nstruct qed_iwarp_ep *ep;\r\nint rc = 0;\r\nint count;\r\nu32 cid;\r\nint i;\r\ncount = init ? QED_IWARP_PREALLOC_CNT : 1;\r\nfor (i = 0; i < count; i++) {\r\nrc = qed_iwarp_create_ep(p_hwfn, &ep);\r\nif (rc)\r\nreturn rc;\r\nif (init) {\r\nrc = qed_iwarp_alloc_cid(p_hwfn, &cid);\r\nif (rc)\r\ngoto err;\r\nqed_iwarp_set_tcp_cid(p_hwfn, cid);\r\n} else {\r\nqed_iwarp_alloc_tcp_cid(p_hwfn, &cid);\r\n}\r\nep->tcp_cid = cid;\r\nspin_lock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\r\nlist_add_tail(&ep->list_entry,\r\n&p_hwfn->p_rdma_info->iwarp.ep_free_list);\r\nspin_unlock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\r\n}\r\nreturn rc;\r\nerr:\r\nqed_iwarp_destroy_ep(p_hwfn, ep, false);\r\nreturn rc;\r\n}\r\nint qed_iwarp_alloc(struct qed_hwfn *p_hwfn)\r\n{\r\nint rc;\r\nrc = qed_rdma_bmap_alloc(p_hwfn, &p_hwfn->p_rdma_info->tcp_cid_map,\r\nQED_IWARP_PREALLOC_CNT, "TCP_CID");\r\nif (rc) {\r\nDP_VERBOSE(p_hwfn, QED_MSG_RDMA,\r\n"Failed to allocate tcp cid, rc = %d\n", rc);\r\nreturn rc;\r\n}\r\nINIT_LIST_HEAD(&p_hwfn->p_rdma_info->iwarp.ep_free_list);\r\nspin_lock_init(&p_hwfn->p_rdma_info->iwarp.iw_lock);\r\nreturn qed_iwarp_prealloc_ep(p_hwfn, true);\r\n}\r\nvoid qed_iwarp_resc_free(struct qed_hwfn *p_hwfn)\r\n{\r\nqed_rdma_bmap_free(p_hwfn, &p_hwfn->p_rdma_info->tcp_cid_map, 1);\r\n}\r\nint qed_iwarp_accept(void *rdma_cxt, struct qed_iwarp_accept_in *iparams)\r\n{\r\nstruct qed_hwfn *p_hwfn = rdma_cxt;\r\nstruct qed_iwarp_ep *ep;\r\nu8 mpa_data_size = 0;\r\nint rc;\r\nep = iparams->ep_context;\r\nif (!ep) {\r\nDP_ERR(p_hwfn, "Ep Context receive in accept is NULL\n");\r\nreturn -EINVAL;\r\n}\r\nDP_VERBOSE(p_hwfn, QED_MSG_RDMA, "QP(0x%x) EP(0x%x)\n",\r\niparams->qp->icid, ep->tcp_cid);\r\nif ((iparams->ord > QED_IWARP_ORD_DEFAULT) ||\r\n(iparams->ird > QED_IWARP_IRD_DEFAULT)) {\r\nDP_VERBOSE(p_hwfn,\r\nQED_MSG_RDMA,\r\n"QP(0x%x) EP(0x%x) ERROR: Invalid ord(0x%x)/ird(0x%x)\n",\r\niparams->qp->icid,\r\nep->tcp_cid, iparams->ord, iparams->ord);\r\nreturn -EINVAL;\r\n}\r\nqed_iwarp_prealloc_ep(p_hwfn, false);\r\nep->cb_context = iparams->cb_context;\r\nep->qp = iparams->qp;\r\nep->qp->ep = ep;\r\nif (ep->mpa_rev == MPA_NEGOTIATION_TYPE_ENHANCED) {\r\nif (iparams->ord > ep->cm_info.ird)\r\niparams->ord = ep->cm_info.ird;\r\nif ((ep->rtr_type & MPA_RTR_TYPE_ZERO_READ) &&\r\n(iparams->ird == 0))\r\niparams->ird = 1;\r\n}\r\nep->cm_info.ord = iparams->ord;\r\nep->cm_info.ird = iparams->ird;\r\nqed_iwarp_mpa_v2_set_private(p_hwfn, ep, &mpa_data_size);\r\nep->cm_info.private_data = ep->ep_buffer_virt->out_pdata;\r\nep->cm_info.private_data_len = iparams->private_data_len +\r\nmpa_data_size;\r\nmemcpy((u8 *)ep->ep_buffer_virt->out_pdata + mpa_data_size,\r\niparams->private_data, iparams->private_data_len);\r\nrc = qed_iwarp_mpa_offload(p_hwfn, ep);\r\nif (rc)\r\nqed_iwarp_modify_qp(p_hwfn,\r\niparams->qp, QED_IWARP_QP_STATE_ERROR, 1);\r\nreturn rc;\r\n}\r\nint qed_iwarp_reject(void *rdma_cxt, struct qed_iwarp_reject_in *iparams)\r\n{\r\nstruct qed_hwfn *p_hwfn = rdma_cxt;\r\nstruct qed_iwarp_ep *ep;\r\nu8 mpa_data_size = 0;\r\nep = iparams->ep_context;\r\nif (!ep) {\r\nDP_ERR(p_hwfn, "Ep Context receive in reject is NULL\n");\r\nreturn -EINVAL;\r\n}\r\nDP_VERBOSE(p_hwfn, QED_MSG_RDMA, "EP(0x%x)\n", ep->tcp_cid);\r\nep->cb_context = iparams->cb_context;\r\nep->qp = NULL;\r\nqed_iwarp_mpa_v2_set_private(p_hwfn, ep, &mpa_data_size);\r\nep->cm_info.private_data = ep->ep_buffer_virt->out_pdata;\r\nep->cm_info.private_data_len = iparams->private_data_len +\r\nmpa_data_size;\r\nmemcpy((u8 *)ep->ep_buffer_virt->out_pdata + mpa_data_size,\r\niparams->private_data, iparams->private_data_len);\r\nreturn qed_iwarp_mpa_offload(p_hwfn, ep);\r\n}\r\nstatic void\r\nqed_iwarp_print_cm_info(struct qed_hwfn *p_hwfn,\r\nstruct qed_iwarp_cm_info *cm_info)\r\n{\r\nDP_VERBOSE(p_hwfn, QED_MSG_RDMA, "ip_version = %d\n",\r\ncm_info->ip_version);\r\nif (cm_info->ip_version == QED_TCP_IPV4)\r\nDP_VERBOSE(p_hwfn, QED_MSG_RDMA,\r\n"remote_ip %pI4h:%x, local_ip %pI4h:%x vlan=%x\n",\r\ncm_info->remote_ip, cm_info->remote_port,\r\ncm_info->local_ip, cm_info->local_port,\r\ncm_info->vlan);\r\nelse\r\nDP_VERBOSE(p_hwfn, QED_MSG_RDMA,\r\n"remote_ip %pI6:%x, local_ip %pI6:%x vlan=%x\n",\r\ncm_info->remote_ip, cm_info->remote_port,\r\ncm_info->local_ip, cm_info->local_port,\r\ncm_info->vlan);\r\nDP_VERBOSE(p_hwfn, QED_MSG_RDMA,\r\n"private_data_len = %x ord = %d, ird = %d\n",\r\ncm_info->private_data_len, cm_info->ord, cm_info->ird);\r\n}\r\nstatic int\r\nqed_iwarp_ll2_post_rx(struct qed_hwfn *p_hwfn,\r\nstruct qed_iwarp_ll2_buff *buf, u8 handle)\r\n{\r\nint rc;\r\nrc = qed_ll2_post_rx_buffer(p_hwfn, handle, buf->data_phys_addr,\r\n(u16)buf->buff_size, buf, 1);\r\nif (rc) {\r\nDP_NOTICE(p_hwfn,\r\n"Failed to repost rx buffer to ll2 rc = %d, handle=%d\n",\r\nrc, handle);\r\ndma_free_coherent(&p_hwfn->cdev->pdev->dev, buf->buff_size,\r\nbuf->data, buf->data_phys_addr);\r\nkfree(buf);\r\n}\r\nreturn rc;\r\n}\r\nstatic bool\r\nqed_iwarp_ep_exists(struct qed_hwfn *p_hwfn, struct qed_iwarp_cm_info *cm_info)\r\n{\r\nstruct qed_iwarp_ep *ep = NULL;\r\nbool found = false;\r\nlist_for_each_entry(ep,\r\n&p_hwfn->p_rdma_info->iwarp.ep_list,\r\nlist_entry) {\r\nif ((ep->cm_info.local_port == cm_info->local_port) &&\r\n(ep->cm_info.remote_port == cm_info->remote_port) &&\r\n(ep->cm_info.vlan == cm_info->vlan) &&\r\n!memcmp(&ep->cm_info.local_ip, cm_info->local_ip,\r\nsizeof(cm_info->local_ip)) &&\r\n!memcmp(&ep->cm_info.remote_ip, cm_info->remote_ip,\r\nsizeof(cm_info->remote_ip))) {\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nif (found) {\r\nDP_NOTICE(p_hwfn,\r\n"SYN received on active connection - dropping\n");\r\nqed_iwarp_print_cm_info(p_hwfn, cm_info);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic struct qed_iwarp_listener *\r\nqed_iwarp_get_listener(struct qed_hwfn *p_hwfn,\r\nstruct qed_iwarp_cm_info *cm_info)\r\n{\r\nstruct qed_iwarp_listener *listener = NULL;\r\nstatic const u32 ip_zero[4] = { 0, 0, 0, 0 };\r\nbool found = false;\r\nqed_iwarp_print_cm_info(p_hwfn, cm_info);\r\nlist_for_each_entry(listener,\r\n&p_hwfn->p_rdma_info->iwarp.listen_list,\r\nlist_entry) {\r\nif (listener->port == cm_info->local_port) {\r\nif (!memcmp(listener->ip_addr,\r\nip_zero, sizeof(ip_zero))) {\r\nfound = true;\r\nbreak;\r\n}\r\nif (!memcmp(listener->ip_addr,\r\ncm_info->local_ip,\r\nsizeof(cm_info->local_ip)) &&\r\n(listener->vlan == cm_info->vlan)) {\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (found) {\r\nDP_VERBOSE(p_hwfn, QED_MSG_RDMA, "listener found = %p\n",\r\nlistener);\r\nreturn listener;\r\n}\r\nDP_VERBOSE(p_hwfn, QED_MSG_RDMA, "listener not found\n");\r\nreturn NULL;\r\n}\r\nstatic int\r\nqed_iwarp_parse_rx_pkt(struct qed_hwfn *p_hwfn,\r\nstruct qed_iwarp_cm_info *cm_info,\r\nvoid *buf,\r\nu8 *remote_mac_addr,\r\nu8 *local_mac_addr,\r\nint *payload_len, int *tcp_start_offset)\r\n{\r\nstruct vlan_ethhdr *vethh;\r\nbool vlan_valid = false;\r\nstruct ipv6hdr *ip6h;\r\nstruct ethhdr *ethh;\r\nstruct tcphdr *tcph;\r\nstruct iphdr *iph;\r\nint eth_hlen;\r\nint ip_hlen;\r\nint eth_type;\r\nint i;\r\nethh = buf;\r\neth_type = ntohs(ethh->h_proto);\r\nif (eth_type == ETH_P_8021Q) {\r\nvlan_valid = true;\r\nvethh = (struct vlan_ethhdr *)ethh;\r\ncm_info->vlan = ntohs(vethh->h_vlan_TCI) & VLAN_VID_MASK;\r\neth_type = ntohs(vethh->h_vlan_encapsulated_proto);\r\n}\r\neth_hlen = ETH_HLEN + (vlan_valid ? sizeof(u32) : 0);\r\nether_addr_copy(remote_mac_addr, ethh->h_source);\r\nether_addr_copy(local_mac_addr, ethh->h_dest);\r\nDP_VERBOSE(p_hwfn, QED_MSG_RDMA, "eth_type =%d source mac: %pM\n",\r\neth_type, ethh->h_source);\r\nDP_VERBOSE(p_hwfn, QED_MSG_RDMA, "eth_hlen=%d destination mac: %pM\n",\r\neth_hlen, ethh->h_dest);\r\niph = (struct iphdr *)((u8 *)(ethh) + eth_hlen);\r\nif (eth_type == ETH_P_IP) {\r\ncm_info->local_ip[0] = ntohl(iph->daddr);\r\ncm_info->remote_ip[0] = ntohl(iph->saddr);\r\ncm_info->ip_version = TCP_IPV4;\r\nip_hlen = (iph->ihl) * sizeof(u32);\r\n*payload_len = ntohs(iph->tot_len) - ip_hlen;\r\n} else if (eth_type == ETH_P_IPV6) {\r\nip6h = (struct ipv6hdr *)iph;\r\nfor (i = 0; i < 4; i++) {\r\ncm_info->local_ip[i] =\r\nntohl(ip6h->daddr.in6_u.u6_addr32[i]);\r\ncm_info->remote_ip[i] =\r\nntohl(ip6h->saddr.in6_u.u6_addr32[i]);\r\n}\r\ncm_info->ip_version = TCP_IPV6;\r\nip_hlen = sizeof(*ip6h);\r\n*payload_len = ntohs(ip6h->payload_len);\r\n} else {\r\nDP_NOTICE(p_hwfn, "Unexpected ethertype on ll2 %x\n", eth_type);\r\nreturn -EINVAL;\r\n}\r\ntcph = (struct tcphdr *)((u8 *)iph + ip_hlen);\r\nif (!tcph->syn) {\r\nDP_NOTICE(p_hwfn,\r\n"Only SYN type packet expected on this ll2 conn, iph->ihl=%d source=%d dest=%d\n",\r\niph->ihl, tcph->source, tcph->dest);\r\nreturn -EINVAL;\r\n}\r\ncm_info->local_port = ntohs(tcph->dest);\r\ncm_info->remote_port = ntohs(tcph->source);\r\nqed_iwarp_print_cm_info(p_hwfn, cm_info);\r\n*tcp_start_offset = eth_hlen + ip_hlen;\r\nreturn 0;\r\n}\r\nstatic void\r\nqed_iwarp_ll2_comp_syn_pkt(void *cxt, struct qed_ll2_comp_rx_data *data)\r\n{\r\nstruct qed_iwarp_ll2_buff *buf = data->cookie;\r\nstruct qed_iwarp_listener *listener;\r\nstruct qed_ll2_tx_pkt_info tx_pkt;\r\nstruct qed_iwarp_cm_info cm_info;\r\nstruct qed_hwfn *p_hwfn = cxt;\r\nu8 remote_mac_addr[ETH_ALEN];\r\nu8 local_mac_addr[ETH_ALEN];\r\nstruct qed_iwarp_ep *ep;\r\nint tcp_start_offset;\r\nu8 ts_hdr_size = 0;\r\nu8 ll2_syn_handle;\r\nint payload_len;\r\nu32 hdr_size;\r\nint rc;\r\nmemset(&cm_info, 0, sizeof(cm_info));\r\nll2_syn_handle = p_hwfn->p_rdma_info->iwarp.ll2_syn_handle;\r\nif (GET_FIELD(data->parse_flags,\r\nPARSING_AND_ERR_FLAGS_L4CHKSMWASCALCULATED) &&\r\nGET_FIELD(data->parse_flags, PARSING_AND_ERR_FLAGS_L4CHKSMERROR)) {\r\nDP_NOTICE(p_hwfn, "Syn packet received with checksum error\n");\r\ngoto err;\r\n}\r\nrc = qed_iwarp_parse_rx_pkt(p_hwfn, &cm_info, (u8 *)(buf->data) +\r\ndata->u.placement_offset, remote_mac_addr,\r\nlocal_mac_addr, &payload_len,\r\n&tcp_start_offset);\r\nif (rc)\r\ngoto err;\r\nlistener = qed_iwarp_get_listener(p_hwfn, &cm_info);\r\nif (!listener) {\r\nDP_VERBOSE(p_hwfn,\r\nQED_MSG_RDMA,\r\n"SYN received on tuple not listened on parse_flags=%d packet len=%d\n",\r\ndata->parse_flags, data->length.packet_length);\r\nmemset(&tx_pkt, 0, sizeof(tx_pkt));\r\ntx_pkt.num_of_bds = 1;\r\ntx_pkt.vlan = data->vlan;\r\nif (GET_FIELD(data->parse_flags,\r\nPARSING_AND_ERR_FLAGS_TAG8021QEXIST))\r\nSET_FIELD(tx_pkt.bd_flags,\r\nCORE_TX_BD_DATA_VLAN_INSERTION, 1);\r\ntx_pkt.l4_hdr_offset_w = (data->length.packet_length) >> 2;\r\ntx_pkt.tx_dest = QED_LL2_TX_DEST_LB;\r\ntx_pkt.first_frag = buf->data_phys_addr +\r\ndata->u.placement_offset;\r\ntx_pkt.first_frag_len = data->length.packet_length;\r\ntx_pkt.cookie = buf;\r\nrc = qed_ll2_prepare_tx_packet(p_hwfn, ll2_syn_handle,\r\n&tx_pkt, true);\r\nif (rc) {\r\nDP_NOTICE(p_hwfn,\r\n"Can't post SYN back to chip rc=%d\n", rc);\r\ngoto err;\r\n}\r\nreturn;\r\n}\r\nDP_VERBOSE(p_hwfn, QED_MSG_RDMA, "Received syn on listening port\n");\r\nif (qed_iwarp_ep_exists(p_hwfn, &cm_info))\r\ngoto err;\r\nep = qed_iwarp_get_free_ep(p_hwfn);\r\nif (!ep)\r\ngoto err;\r\nspin_lock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\r\nlist_add_tail(&ep->list_entry, &p_hwfn->p_rdma_info->iwarp.ep_list);\r\nspin_unlock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\r\nether_addr_copy(ep->remote_mac_addr, remote_mac_addr);\r\nether_addr_copy(ep->local_mac_addr, local_mac_addr);\r\nmemcpy(&ep->cm_info, &cm_info, sizeof(ep->cm_info));\r\nif (p_hwfn->p_rdma_info->iwarp.tcp_flags & QED_IWARP_TS_EN)\r\nts_hdr_size = TIMESTAMP_HEADER_SIZE;\r\nhdr_size = ((cm_info.ip_version == QED_TCP_IPV4) ? 40 : 60) +\r\nts_hdr_size;\r\nep->mss = p_hwfn->p_rdma_info->iwarp.max_mtu - hdr_size;\r\nep->mss = min_t(u16, QED_IWARP_MAX_FW_MSS, ep->mss);\r\nep->event_cb = listener->event_cb;\r\nep->cb_context = listener->cb_context;\r\nep->connect_mode = TCP_CONNECT_PASSIVE;\r\nep->syn = buf;\r\nep->syn_ip_payload_length = (u16)payload_len;\r\nep->syn_phy_addr = buf->data_phys_addr + data->u.placement_offset +\r\ntcp_start_offset;\r\nrc = qed_iwarp_tcp_offload(p_hwfn, ep);\r\nif (rc) {\r\nqed_iwarp_return_ep(p_hwfn, ep);\r\ngoto err;\r\n}\r\nreturn;\r\nerr:\r\nqed_iwarp_ll2_post_rx(p_hwfn, buf, ll2_syn_handle);\r\n}\r\nstatic void qed_iwarp_ll2_rel_rx_pkt(void *cxt, u8 connection_handle,\r\nvoid *cookie, dma_addr_t rx_buf_addr,\r\nbool b_last_packet)\r\n{\r\nstruct qed_iwarp_ll2_buff *buffer = cookie;\r\nstruct qed_hwfn *p_hwfn = cxt;\r\ndma_free_coherent(&p_hwfn->cdev->pdev->dev, buffer->buff_size,\r\nbuffer->data, buffer->data_phys_addr);\r\nkfree(buffer);\r\n}\r\nstatic void qed_iwarp_ll2_comp_tx_pkt(void *cxt, u8 connection_handle,\r\nvoid *cookie, dma_addr_t first_frag_addr,\r\nbool b_last_fragment, bool b_last_packet)\r\n{\r\nstruct qed_iwarp_ll2_buff *buffer = cookie;\r\nstruct qed_hwfn *p_hwfn = cxt;\r\nqed_iwarp_ll2_post_rx(p_hwfn, buffer, connection_handle);\r\n}\r\nstatic void qed_iwarp_ll2_rel_tx_pkt(void *cxt, u8 connection_handle,\r\nvoid *cookie, dma_addr_t first_frag_addr,\r\nbool b_last_fragment, bool b_last_packet)\r\n{\r\nstruct qed_iwarp_ll2_buff *buffer = cookie;\r\nstruct qed_hwfn *p_hwfn = cxt;\r\nif (!buffer)\r\nreturn;\r\ndma_free_coherent(&p_hwfn->cdev->pdev->dev, buffer->buff_size,\r\nbuffer->data, buffer->data_phys_addr);\r\nkfree(buffer);\r\n}\r\nstatic int qed_iwarp_ll2_stop(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt)\r\n{\r\nstruct qed_iwarp_info *iwarp_info = &p_hwfn->p_rdma_info->iwarp;\r\nint rc = 0;\r\nif (iwarp_info->ll2_syn_handle != QED_IWARP_HANDLE_INVAL) {\r\nrc = qed_ll2_terminate_connection(p_hwfn,\r\niwarp_info->ll2_syn_handle);\r\nif (rc)\r\nDP_INFO(p_hwfn, "Failed to terminate syn connection\n");\r\nqed_ll2_release_connection(p_hwfn, iwarp_info->ll2_syn_handle);\r\niwarp_info->ll2_syn_handle = QED_IWARP_HANDLE_INVAL;\r\n}\r\nqed_llh_remove_mac_filter(p_hwfn,\r\np_ptt, p_hwfn->p_rdma_info->iwarp.mac_addr);\r\nreturn rc;\r\n}\r\nstatic int\r\nqed_iwarp_ll2_alloc_buffers(struct qed_hwfn *p_hwfn,\r\nint num_rx_bufs, int buff_size, u8 ll2_handle)\r\n{\r\nstruct qed_iwarp_ll2_buff *buffer;\r\nint rc = 0;\r\nint i;\r\nfor (i = 0; i < num_rx_bufs; i++) {\r\nbuffer = kzalloc(sizeof(*buffer), GFP_KERNEL);\r\nif (!buffer) {\r\nrc = -ENOMEM;\r\nbreak;\r\n}\r\nbuffer->data = dma_alloc_coherent(&p_hwfn->cdev->pdev->dev,\r\nbuff_size,\r\n&buffer->data_phys_addr,\r\nGFP_KERNEL);\r\nif (!buffer->data) {\r\nkfree(buffer);\r\nrc = -ENOMEM;\r\nbreak;\r\n}\r\nbuffer->buff_size = buff_size;\r\nrc = qed_iwarp_ll2_post_rx(p_hwfn, buffer, ll2_handle);\r\nif (rc)\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic int\r\nqed_iwarp_ll2_start(struct qed_hwfn *p_hwfn,\r\nstruct qed_rdma_start_in_params *params,\r\nstruct qed_ptt *p_ptt)\r\n{\r\nstruct qed_iwarp_info *iwarp_info;\r\nstruct qed_ll2_acquire_data data;\r\nstruct qed_ll2_cbs cbs;\r\nint rc = 0;\r\niwarp_info = &p_hwfn->p_rdma_info->iwarp;\r\niwarp_info->ll2_syn_handle = QED_IWARP_HANDLE_INVAL;\r\niwarp_info->max_mtu = params->max_mtu;\r\nether_addr_copy(p_hwfn->p_rdma_info->iwarp.mac_addr, params->mac_addr);\r\nrc = qed_llh_add_mac_filter(p_hwfn, p_ptt, params->mac_addr);\r\nif (rc)\r\nreturn rc;\r\ncbs.rx_comp_cb = qed_iwarp_ll2_comp_syn_pkt;\r\ncbs.rx_release_cb = qed_iwarp_ll2_rel_rx_pkt;\r\ncbs.tx_comp_cb = qed_iwarp_ll2_comp_tx_pkt;\r\ncbs.tx_release_cb = qed_iwarp_ll2_rel_tx_pkt;\r\ncbs.cookie = p_hwfn;\r\nmemset(&data, 0, sizeof(data));\r\ndata.input.conn_type = QED_LL2_TYPE_IWARP;\r\ndata.input.mtu = QED_IWARP_MAX_SYN_PKT_SIZE;\r\ndata.input.rx_num_desc = QED_IWARP_LL2_SYN_RX_SIZE;\r\ndata.input.tx_num_desc = QED_IWARP_LL2_SYN_TX_SIZE;\r\ndata.input.tx_max_bds_per_packet = 1;\r\ndata.input.tx_tc = PKT_LB_TC;\r\ndata.input.tx_dest = QED_LL2_TX_DEST_LB;\r\ndata.p_connection_handle = &iwarp_info->ll2_syn_handle;\r\ndata.cbs = &cbs;\r\nrc = qed_ll2_acquire_connection(p_hwfn, &data);\r\nif (rc) {\r\nDP_NOTICE(p_hwfn, "Failed to acquire LL2 connection\n");\r\nqed_llh_remove_mac_filter(p_hwfn, p_ptt, params->mac_addr);\r\nreturn rc;\r\n}\r\nrc = qed_ll2_establish_connection(p_hwfn, iwarp_info->ll2_syn_handle);\r\nif (rc) {\r\nDP_NOTICE(p_hwfn, "Failed to establish LL2 connection\n");\r\ngoto err;\r\n}\r\nrc = qed_iwarp_ll2_alloc_buffers(p_hwfn,\r\nQED_IWARP_LL2_SYN_RX_SIZE,\r\nQED_IWARP_MAX_SYN_PKT_SIZE,\r\niwarp_info->ll2_syn_handle);\r\nif (rc)\r\ngoto err;\r\nreturn rc;\r\nerr:\r\nqed_iwarp_ll2_stop(p_hwfn, p_ptt);\r\nreturn rc;\r\n}\r\nint qed_iwarp_setup(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt,\r\nstruct qed_rdma_start_in_params *params)\r\n{\r\nstruct qed_iwarp_info *iwarp_info;\r\nu32 rcv_wnd_size;\r\niwarp_info = &p_hwfn->p_rdma_info->iwarp;\r\niwarp_info->tcp_flags = QED_IWARP_TS_EN;\r\nrcv_wnd_size = QED_IWARP_RCV_WND_SIZE_DEF;\r\niwarp_info->rcv_wnd_scale = ilog2(rcv_wnd_size) -\r\nilog2(QED_IWARP_RCV_WND_SIZE_MIN);\r\niwarp_info->crc_needed = QED_IWARP_PARAM_CRC_NEEDED;\r\niwarp_info->mpa_rev = MPA_NEGOTIATION_TYPE_ENHANCED;\r\niwarp_info->peer2peer = QED_IWARP_PARAM_P2P;\r\niwarp_info->rtr_type = MPA_RTR_TYPE_ZERO_SEND |\r\nMPA_RTR_TYPE_ZERO_WRITE |\r\nMPA_RTR_TYPE_ZERO_READ;\r\nspin_lock_init(&p_hwfn->p_rdma_info->iwarp.qp_lock);\r\nINIT_LIST_HEAD(&p_hwfn->p_rdma_info->iwarp.ep_list);\r\nINIT_LIST_HEAD(&p_hwfn->p_rdma_info->iwarp.listen_list);\r\nqed_spq_register_async_cb(p_hwfn, PROTOCOLID_IWARP,\r\nqed_iwarp_async_event);\r\nreturn qed_iwarp_ll2_start(p_hwfn, params, p_ptt);\r\n}\r\nint qed_iwarp_stop(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt)\r\n{\r\nint rc;\r\nqed_iwarp_free_prealloc_ep(p_hwfn);\r\nrc = qed_iwarp_wait_for_all_cids(p_hwfn);\r\nif (rc)\r\nreturn rc;\r\nqed_spq_unregister_async_cb(p_hwfn, PROTOCOLID_IWARP);\r\nreturn qed_iwarp_ll2_stop(p_hwfn, p_ptt);\r\n}\r\nvoid qed_iwarp_qp_in_error(struct qed_hwfn *p_hwfn,\r\nstruct qed_iwarp_ep *ep, u8 fw_return_code)\r\n{\r\nstruct qed_iwarp_cm_event_params params;\r\nqed_iwarp_modify_qp(p_hwfn, ep->qp, QED_IWARP_QP_STATE_ERROR, true);\r\nparams.event = QED_IWARP_EVENT_CLOSE;\r\nparams.ep_context = ep;\r\nparams.cm_info = &ep->cm_info;\r\nparams.status = (fw_return_code == IWARP_QP_IN_ERROR_GOOD_CLOSE) ?\r\n0 : -ECONNRESET;\r\nep->state = QED_IWARP_EP_CLOSED;\r\nspin_lock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\r\nlist_del(&ep->list_entry);\r\nspin_unlock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\r\nep->event_cb(ep->cb_context, &params);\r\n}\r\nvoid qed_iwarp_exception_received(struct qed_hwfn *p_hwfn,\r\nstruct qed_iwarp_ep *ep, int fw_ret_code)\r\n{\r\nstruct qed_iwarp_cm_event_params params;\r\nbool event_cb = false;\r\nDP_VERBOSE(p_hwfn, QED_MSG_RDMA, "EP(0x%x) fw_ret_code=%d\n",\r\nep->cid, fw_ret_code);\r\nswitch (fw_ret_code) {\r\ncase IWARP_EXCEPTION_DETECTED_LLP_CLOSED:\r\nparams.status = 0;\r\nparams.event = QED_IWARP_EVENT_DISCONNECT;\r\nevent_cb = true;\r\nbreak;\r\ncase IWARP_EXCEPTION_DETECTED_LLP_RESET:\r\nparams.status = -ECONNRESET;\r\nparams.event = QED_IWARP_EVENT_DISCONNECT;\r\nevent_cb = true;\r\nbreak;\r\ncase IWARP_EXCEPTION_DETECTED_RQ_EMPTY:\r\nparams.event = QED_IWARP_EVENT_RQ_EMPTY;\r\nevent_cb = true;\r\nbreak;\r\ncase IWARP_EXCEPTION_DETECTED_IRQ_FULL:\r\nparams.event = QED_IWARP_EVENT_IRQ_FULL;\r\nevent_cb = true;\r\nbreak;\r\ncase IWARP_EXCEPTION_DETECTED_LLP_TIMEOUT:\r\nparams.event = QED_IWARP_EVENT_LLP_TIMEOUT;\r\nevent_cb = true;\r\nbreak;\r\ncase IWARP_EXCEPTION_DETECTED_REMOTE_PROTECTION_ERROR:\r\nparams.event = QED_IWARP_EVENT_REMOTE_PROTECTION_ERROR;\r\nevent_cb = true;\r\nbreak;\r\ncase IWARP_EXCEPTION_DETECTED_CQ_OVERFLOW:\r\nparams.event = QED_IWARP_EVENT_CQ_OVERFLOW;\r\nevent_cb = true;\r\nbreak;\r\ncase IWARP_EXCEPTION_DETECTED_LOCAL_CATASTROPHIC:\r\nparams.event = QED_IWARP_EVENT_QP_CATASTROPHIC;\r\nevent_cb = true;\r\nbreak;\r\ncase IWARP_EXCEPTION_DETECTED_LOCAL_ACCESS_ERROR:\r\nparams.event = QED_IWARP_EVENT_LOCAL_ACCESS_ERROR;\r\nevent_cb = true;\r\nbreak;\r\ncase IWARP_EXCEPTION_DETECTED_REMOTE_OPERATION_ERROR:\r\nparams.event = QED_IWARP_EVENT_REMOTE_OPERATION_ERROR;\r\nevent_cb = true;\r\nbreak;\r\ncase IWARP_EXCEPTION_DETECTED_TERMINATE_RECEIVED:\r\nparams.event = QED_IWARP_EVENT_TERMINATE_RECEIVED;\r\nevent_cb = true;\r\nbreak;\r\ndefault:\r\nDP_VERBOSE(p_hwfn, QED_MSG_RDMA,\r\n"Unhandled exception received...fw_ret_code=%d\n",\r\nfw_ret_code);\r\nbreak;\r\n}\r\nif (event_cb) {\r\nparams.ep_context = ep;\r\nparams.cm_info = &ep->cm_info;\r\nep->event_cb(ep->cb_context, &params);\r\n}\r\n}\r\nstatic void\r\nqed_iwarp_tcp_connect_unsuccessful(struct qed_hwfn *p_hwfn,\r\nstruct qed_iwarp_ep *ep, u8 fw_return_code)\r\n{\r\nstruct qed_iwarp_cm_event_params params;\r\nmemset(&params, 0, sizeof(params));\r\nparams.event = QED_IWARP_EVENT_ACTIVE_COMPLETE;\r\nparams.ep_context = ep;\r\nparams.cm_info = &ep->cm_info;\r\nep->state = QED_IWARP_EP_CLOSED;\r\nswitch (fw_return_code) {\r\ncase IWARP_CONN_ERROR_TCP_CONNECT_INVALID_PACKET:\r\nDP_VERBOSE(p_hwfn, QED_MSG_RDMA,\r\n"%s(0x%x) TCP connect got invalid packet\n",\r\nQED_IWARP_CONNECT_MODE_STRING(ep), ep->tcp_cid);\r\nparams.status = -ECONNRESET;\r\nbreak;\r\ncase IWARP_CONN_ERROR_TCP_CONNECTION_RST:\r\nDP_VERBOSE(p_hwfn, QED_MSG_RDMA,\r\n"%s(0x%x) TCP Connection Reset\n",\r\nQED_IWARP_CONNECT_MODE_STRING(ep), ep->tcp_cid);\r\nparams.status = -ECONNRESET;\r\nbreak;\r\ncase IWARP_CONN_ERROR_TCP_CONNECT_TIMEOUT:\r\nDP_NOTICE(p_hwfn, "%s(0x%x) TCP timeout\n",\r\nQED_IWARP_CONNECT_MODE_STRING(ep), ep->tcp_cid);\r\nparams.status = -EBUSY;\r\nbreak;\r\ncase IWARP_CONN_ERROR_MPA_NOT_SUPPORTED_VER:\r\nDP_NOTICE(p_hwfn, "%s(0x%x) MPA not supported VER\n",\r\nQED_IWARP_CONNECT_MODE_STRING(ep), ep->tcp_cid);\r\nparams.status = -ECONNREFUSED;\r\nbreak;\r\ncase IWARP_CONN_ERROR_MPA_INVALID_PACKET:\r\nDP_NOTICE(p_hwfn, "%s(0x%x) MPA Invalid Packet\n",\r\nQED_IWARP_CONNECT_MODE_STRING(ep), ep->tcp_cid);\r\nparams.status = -ECONNRESET;\r\nbreak;\r\ndefault:\r\nDP_ERR(p_hwfn,\r\n"%s(0x%x) Unexpected return code tcp connect: %d\n",\r\nQED_IWARP_CONNECT_MODE_STRING(ep),\r\nep->tcp_cid, fw_return_code);\r\nparams.status = -ECONNRESET;\r\nbreak;\r\n}\r\nif (ep->connect_mode == TCP_CONNECT_PASSIVE) {\r\nep->tcp_cid = QED_IWARP_INVALID_TCP_CID;\r\nqed_iwarp_return_ep(p_hwfn, ep);\r\n} else {\r\nep->event_cb(ep->cb_context, &params);\r\nspin_lock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\r\nlist_del(&ep->list_entry);\r\nspin_unlock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\r\n}\r\n}\r\nvoid\r\nqed_iwarp_connect_complete(struct qed_hwfn *p_hwfn,\r\nstruct qed_iwarp_ep *ep, u8 fw_return_code)\r\n{\r\nu8 ll2_syn_handle = p_hwfn->p_rdma_info->iwarp.ll2_syn_handle;\r\nif (ep->connect_mode == TCP_CONNECT_PASSIVE) {\r\nqed_iwarp_ll2_post_rx(p_hwfn, ep->syn, ll2_syn_handle);\r\nep->syn = NULL;\r\nif (fw_return_code == RDMA_RETURN_OK)\r\nqed_iwarp_mpa_received(p_hwfn, ep);\r\nelse\r\nqed_iwarp_tcp_connect_unsuccessful(p_hwfn, ep,\r\nfw_return_code);\r\n} else {\r\nif (fw_return_code == RDMA_RETURN_OK)\r\nqed_iwarp_mpa_offload(p_hwfn, ep);\r\nelse\r\nqed_iwarp_tcp_connect_unsuccessful(p_hwfn, ep,\r\nfw_return_code);\r\n}\r\n}\r\nstatic inline bool\r\nqed_iwarp_check_ep_ok(struct qed_hwfn *p_hwfn, struct qed_iwarp_ep *ep)\r\n{\r\nif (!ep || (ep->sig != QED_EP_SIG)) {\r\nDP_ERR(p_hwfn, "ERROR ON ASYNC ep=%p\n", ep);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic int qed_iwarp_async_event(struct qed_hwfn *p_hwfn,\r\nu8 fw_event_code, u16 echo,\r\nunion event_ring_data *data,\r\nu8 fw_return_code)\r\n{\r\nstruct regpair *fw_handle = &data->rdma_data.async_handle;\r\nstruct qed_iwarp_ep *ep = NULL;\r\nu16 cid;\r\nep = (struct qed_iwarp_ep *)(uintptr_t)HILO_64(fw_handle->hi,\r\nfw_handle->lo);\r\nswitch (fw_event_code) {\r\ncase IWARP_EVENT_TYPE_ASYNC_CONNECT_COMPLETE:\r\nif (!qed_iwarp_check_ep_ok(p_hwfn, ep))\r\nreturn -EINVAL;\r\nDP_VERBOSE(p_hwfn,\r\nQED_MSG_RDMA,\r\n"EP(0x%x) IWARP_EVENT_TYPE_ASYNC_CONNECT_COMPLETE fw_ret_code=%d\n",\r\nep->tcp_cid, fw_return_code);\r\nqed_iwarp_connect_complete(p_hwfn, ep, fw_return_code);\r\nbreak;\r\ncase IWARP_EVENT_TYPE_ASYNC_EXCEPTION_DETECTED:\r\nif (!qed_iwarp_check_ep_ok(p_hwfn, ep))\r\nreturn -EINVAL;\r\nDP_VERBOSE(p_hwfn,\r\nQED_MSG_RDMA,\r\n"QP(0x%x) IWARP_EVENT_TYPE_ASYNC_EXCEPTION_DETECTED fw_ret_code=%d\n",\r\nep->cid, fw_return_code);\r\nqed_iwarp_exception_received(p_hwfn, ep, fw_return_code);\r\nbreak;\r\ncase IWARP_EVENT_TYPE_ASYNC_QP_IN_ERROR_STATE:\r\nif (!qed_iwarp_check_ep_ok(p_hwfn, ep))\r\nreturn -EINVAL;\r\nDP_VERBOSE(p_hwfn,\r\nQED_MSG_RDMA,\r\n"QP(0x%x) IWARP_EVENT_TYPE_ASYNC_QP_IN_ERROR_STATE fw_ret_code=%d\n",\r\nep->cid, fw_return_code);\r\nqed_iwarp_qp_in_error(p_hwfn, ep, fw_return_code);\r\nbreak;\r\ncase IWARP_EVENT_TYPE_ASYNC_ENHANCED_MPA_REPLY_ARRIVED:\r\nif (!qed_iwarp_check_ep_ok(p_hwfn, ep))\r\nreturn -EINVAL;\r\nDP_VERBOSE(p_hwfn,\r\nQED_MSG_RDMA,\r\n"QP(0x%x) IWARP_EVENT_TYPE_ASYNC_MPA_HANDSHAKE_MPA_REPLY_ARRIVED fw_ret_code=%d\n",\r\nep->cid, fw_return_code);\r\nqed_iwarp_mpa_reply_arrived(p_hwfn, ep);\r\nbreak;\r\ncase IWARP_EVENT_TYPE_ASYNC_MPA_HANDSHAKE_COMPLETE:\r\nif (!qed_iwarp_check_ep_ok(p_hwfn, ep))\r\nreturn -EINVAL;\r\nDP_VERBOSE(p_hwfn,\r\nQED_MSG_RDMA,\r\n"QP(0x%x) IWARP_EVENT_TYPE_ASYNC_MPA_HANDSHAKE_COMPLETE fw_ret_code=%d\n",\r\nep->cid, fw_return_code);\r\nqed_iwarp_mpa_complete(p_hwfn, ep, fw_return_code);\r\nbreak;\r\ncase IWARP_EVENT_TYPE_ASYNC_CID_CLEANED:\r\ncid = (u16)le32_to_cpu(fw_handle->lo);\r\nDP_VERBOSE(p_hwfn, QED_MSG_RDMA,\r\n"(0x%x)IWARP_EVENT_TYPE_ASYNC_CID_CLEANED\n", cid);\r\nqed_iwarp_cid_cleaned(p_hwfn, cid);\r\nbreak;\r\ncase IWARP_EVENT_TYPE_ASYNC_CQ_OVERFLOW:\r\nDP_NOTICE(p_hwfn, "IWARP_EVENT_TYPE_ASYNC_CQ_OVERFLOW\n");\r\np_hwfn->p_rdma_info->events.affiliated_event(\r\np_hwfn->p_rdma_info->events.context,\r\nQED_IWARP_EVENT_CQ_OVERFLOW,\r\n(void *)fw_handle);\r\nbreak;\r\ndefault:\r\nDP_ERR(p_hwfn, "Received unexpected async iwarp event %d\n",\r\nfw_event_code);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nqed_iwarp_create_listen(void *rdma_cxt,\r\nstruct qed_iwarp_listen_in *iparams,\r\nstruct qed_iwarp_listen_out *oparams)\r\n{\r\nstruct qed_hwfn *p_hwfn = rdma_cxt;\r\nstruct qed_iwarp_listener *listener;\r\nlistener = kzalloc(sizeof(*listener), GFP_KERNEL);\r\nif (!listener)\r\nreturn -ENOMEM;\r\nlistener->ip_version = iparams->ip_version;\r\nmemcpy(listener->ip_addr, iparams->ip_addr, sizeof(listener->ip_addr));\r\nlistener->port = iparams->port;\r\nlistener->vlan = iparams->vlan;\r\nlistener->event_cb = iparams->event_cb;\r\nlistener->cb_context = iparams->cb_context;\r\nlistener->max_backlog = iparams->max_backlog;\r\noparams->handle = listener;\r\nspin_lock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\r\nlist_add_tail(&listener->list_entry,\r\n&p_hwfn->p_rdma_info->iwarp.listen_list);\r\nspin_unlock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\r\nDP_VERBOSE(p_hwfn,\r\nQED_MSG_RDMA,\r\n"callback=%p handle=%p ip=%x:%x:%x:%x port=0x%x vlan=0x%x\n",\r\nlistener->event_cb,\r\nlistener,\r\nlistener->ip_addr[0],\r\nlistener->ip_addr[1],\r\nlistener->ip_addr[2],\r\nlistener->ip_addr[3], listener->port, listener->vlan);\r\nreturn 0;\r\n}\r\nint qed_iwarp_destroy_listen(void *rdma_cxt, void *handle)\r\n{\r\nstruct qed_iwarp_listener *listener = handle;\r\nstruct qed_hwfn *p_hwfn = rdma_cxt;\r\nDP_VERBOSE(p_hwfn, QED_MSG_RDMA, "handle=%p\n", handle);\r\nspin_lock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\r\nlist_del(&listener->list_entry);\r\nspin_unlock_bh(&p_hwfn->p_rdma_info->iwarp.iw_lock);\r\nkfree(listener);\r\nreturn 0;\r\n}\r\nint qed_iwarp_send_rtr(void *rdma_cxt, struct qed_iwarp_send_rtr_in *iparams)\r\n{\r\nstruct qed_hwfn *p_hwfn = rdma_cxt;\r\nstruct qed_sp_init_data init_data;\r\nstruct qed_spq_entry *p_ent;\r\nstruct qed_iwarp_ep *ep;\r\nstruct qed_rdma_qp *qp;\r\nint rc;\r\nep = iparams->ep_context;\r\nif (!ep) {\r\nDP_ERR(p_hwfn, "Ep Context receive in send_rtr is NULL\n");\r\nreturn -EINVAL;\r\n}\r\nqp = ep->qp;\r\nDP_VERBOSE(p_hwfn, QED_MSG_RDMA, "QP(0x%x) EP(0x%x)\n",\r\nqp->icid, ep->tcp_cid);\r\nmemset(&init_data, 0, sizeof(init_data));\r\ninit_data.cid = qp->icid;\r\ninit_data.opaque_fid = p_hwfn->hw_info.opaque_fid;\r\ninit_data.comp_mode = QED_SPQ_MODE_CB;\r\nrc = qed_sp_init_request(p_hwfn, &p_ent,\r\nIWARP_RAMROD_CMD_ID_MPA_OFFLOAD_SEND_RTR,\r\nPROTOCOLID_IWARP, &init_data);\r\nif (rc)\r\nreturn rc;\r\nrc = qed_spq_post(p_hwfn, p_ent, NULL);\r\nDP_VERBOSE(p_hwfn, QED_MSG_RDMA, "rc = 0x%x\n", rc);\r\nreturn rc;\r\n}\r\nvoid\r\nqed_iwarp_query_qp(struct qed_rdma_qp *qp,\r\nstruct qed_rdma_query_qp_out_params *out_params)\r\n{\r\nout_params->state = qed_iwarp2roce_state(qp->iwarp_state);\r\n}
