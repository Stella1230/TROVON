static int ttyport_receive_buf(struct tty_port *port, const unsigned char *cp,\r\nconst unsigned char *fp, size_t count)\r\n{\r\nstruct serdev_controller *ctrl = port->client_data;\r\nstruct serport *serport = serdev_controller_get_drvdata(ctrl);\r\nif (!test_bit(SERPORT_ACTIVE, &serport->flags))\r\nreturn 0;\r\nreturn serdev_controller_receive_buf(ctrl, cp, count);\r\n}\r\nstatic void ttyport_write_wakeup(struct tty_port *port)\r\n{\r\nstruct serdev_controller *ctrl = port->client_data;\r\nstruct serport *serport = serdev_controller_get_drvdata(ctrl);\r\nif (test_and_clear_bit(TTY_DO_WRITE_WAKEUP, &port->tty->flags) &&\r\ntest_bit(SERPORT_ACTIVE, &serport->flags))\r\nserdev_controller_write_wakeup(ctrl);\r\nwake_up_interruptible_poll(&port->tty->write_wait, POLLOUT);\r\n}\r\nstatic int ttyport_write_buf(struct serdev_controller *ctrl, const unsigned char *data, size_t len)\r\n{\r\nstruct serport *serport = serdev_controller_get_drvdata(ctrl);\r\nstruct tty_struct *tty = serport->tty;\r\nif (!test_bit(SERPORT_ACTIVE, &serport->flags))\r\nreturn 0;\r\nset_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\r\nreturn tty->ops->write(serport->tty, data, len);\r\n}\r\nstatic void ttyport_write_flush(struct serdev_controller *ctrl)\r\n{\r\nstruct serport *serport = serdev_controller_get_drvdata(ctrl);\r\nstruct tty_struct *tty = serport->tty;\r\ntty_driver_flush_buffer(tty);\r\n}\r\nstatic int ttyport_write_room(struct serdev_controller *ctrl)\r\n{\r\nstruct serport *serport = serdev_controller_get_drvdata(ctrl);\r\nstruct tty_struct *tty = serport->tty;\r\nreturn tty_write_room(tty);\r\n}\r\nstatic int ttyport_open(struct serdev_controller *ctrl)\r\n{\r\nstruct serport *serport = serdev_controller_get_drvdata(ctrl);\r\nstruct tty_struct *tty;\r\nstruct ktermios ktermios;\r\ntty = tty_init_dev(serport->tty_drv, serport->tty_idx);\r\nif (IS_ERR(tty))\r\nreturn PTR_ERR(tty);\r\nserport->tty = tty;\r\nif (tty->ops->open)\r\ntty->ops->open(serport->tty, NULL);\r\nelse\r\ntty_port_open(serport->port, tty, NULL);\r\nktermios = tty->termios;\r\nktermios.c_iflag &= ~(IGNBRK | BRKINT | PARMRK | ISTRIP |\r\nINLCR | IGNCR | ICRNL | IXON);\r\nktermios.c_oflag &= ~OPOST;\r\nktermios.c_lflag &= ~(ECHO | ECHONL | ICANON | ISIG | IEXTEN);\r\nktermios.c_cflag &= ~(CSIZE | PARENB);\r\nktermios.c_cflag |= CS8;\r\nktermios.c_cflag |= CRTSCTS;\r\ntty_set_termios(tty, &ktermios);\r\nset_bit(SERPORT_ACTIVE, &serport->flags);\r\ntty_unlock(serport->tty);\r\nreturn 0;\r\n}\r\nstatic void ttyport_close(struct serdev_controller *ctrl)\r\n{\r\nstruct serport *serport = serdev_controller_get_drvdata(ctrl);\r\nstruct tty_struct *tty = serport->tty;\r\nclear_bit(SERPORT_ACTIVE, &serport->flags);\r\nif (tty->ops->close)\r\ntty->ops->close(tty, NULL);\r\ntty_release_struct(tty, serport->tty_idx);\r\n}\r\nstatic unsigned int ttyport_set_baudrate(struct serdev_controller *ctrl, unsigned int speed)\r\n{\r\nstruct serport *serport = serdev_controller_get_drvdata(ctrl);\r\nstruct tty_struct *tty = serport->tty;\r\nstruct ktermios ktermios = tty->termios;\r\nktermios.c_cflag &= ~CBAUD;\r\ntty_termios_encode_baud_rate(&ktermios, speed, speed);\r\ntty_set_termios(tty, &ktermios);\r\nreturn ktermios.c_ospeed;\r\n}\r\nstatic void ttyport_set_flow_control(struct serdev_controller *ctrl, bool enable)\r\n{\r\nstruct serport *serport = serdev_controller_get_drvdata(ctrl);\r\nstruct tty_struct *tty = serport->tty;\r\nstruct ktermios ktermios = tty->termios;\r\nif (enable)\r\nktermios.c_cflag |= CRTSCTS;\r\nelse\r\nktermios.c_cflag &= ~CRTSCTS;\r\ntty_set_termios(tty, &ktermios);\r\n}\r\nstatic void ttyport_wait_until_sent(struct serdev_controller *ctrl, long timeout)\r\n{\r\nstruct serport *serport = serdev_controller_get_drvdata(ctrl);\r\nstruct tty_struct *tty = serport->tty;\r\ntty_wait_until_sent(tty, timeout);\r\n}\r\nstatic int ttyport_get_tiocm(struct serdev_controller *ctrl)\r\n{\r\nstruct serport *serport = serdev_controller_get_drvdata(ctrl);\r\nstruct tty_struct *tty = serport->tty;\r\nif (!tty->ops->tiocmget)\r\nreturn -ENOTSUPP;\r\nreturn tty->driver->ops->tiocmget(tty);\r\n}\r\nstatic int ttyport_set_tiocm(struct serdev_controller *ctrl, unsigned int set, unsigned int clear)\r\n{\r\nstruct serport *serport = serdev_controller_get_drvdata(ctrl);\r\nstruct tty_struct *tty = serport->tty;\r\nif (!tty->ops->tiocmset)\r\nreturn -ENOTSUPP;\r\nreturn tty->driver->ops->tiocmset(tty, set, clear);\r\n}\r\nstruct device *serdev_tty_port_register(struct tty_port *port,\r\nstruct device *parent,\r\nstruct tty_driver *drv, int idx)\r\n{\r\nconst struct tty_port_client_operations *old_ops;\r\nstruct serdev_controller *ctrl;\r\nstruct serport *serport;\r\nint ret;\r\nif (!port || !drv || !parent)\r\nreturn ERR_PTR(-ENODEV);\r\nctrl = serdev_controller_alloc(parent, sizeof(struct serport));\r\nif (!ctrl)\r\nreturn ERR_PTR(-ENOMEM);\r\nserport = serdev_controller_get_drvdata(ctrl);\r\nserport->port = port;\r\nserport->tty_idx = idx;\r\nserport->tty_drv = drv;\r\nctrl->ops = &ctrl_ops;\r\nold_ops = port->client_ops;\r\nport->client_ops = &client_ops;\r\nport->client_data = ctrl;\r\nret = serdev_controller_add(ctrl);\r\nif (ret)\r\ngoto err_reset_data;\r\ndev_info(&ctrl->dev, "tty port %s%d registered\n", drv->name, idx);\r\nreturn &ctrl->dev;\r\nerr_reset_data:\r\nport->client_data = NULL;\r\nport->client_ops = old_ops;\r\nserdev_controller_put(ctrl);\r\nreturn ERR_PTR(ret);\r\n}\r\nint serdev_tty_port_unregister(struct tty_port *port)\r\n{\r\nstruct serdev_controller *ctrl = port->client_data;\r\nstruct serport *serport = serdev_controller_get_drvdata(ctrl);\r\nif (!serport)\r\nreturn -ENODEV;\r\nserdev_controller_remove(ctrl);\r\nport->client_ops = NULL;\r\nport->client_data = NULL;\r\nserdev_controller_put(ctrl);\r\nreturn 0;\r\n}
