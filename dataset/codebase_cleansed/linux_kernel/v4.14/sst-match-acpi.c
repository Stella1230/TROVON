static acpi_status sst_acpi_find_name(acpi_handle handle, u32 level,\r\nvoid *context, void **ret)\r\n{\r\nstruct acpi_device *adev;\r\nconst char *name = NULL;\r\nif (acpi_bus_get_device(handle, &adev))\r\nreturn AE_OK;\r\nif (adev->status.present && adev->status.functional) {\r\nname = acpi_dev_name(adev);\r\n*(const char **)ret = name;\r\nreturn AE_CTRL_TERMINATE;\r\n}\r\nreturn AE_OK;\r\n}\r\nconst char *sst_acpi_find_name_from_hid(const u8 hid[ACPI_ID_LEN])\r\n{\r\nconst char *name = NULL;\r\nacpi_status status;\r\nstatus = acpi_get_devices(hid, sst_acpi_find_name, NULL,\r\n(void **)&name);\r\nif (ACPI_FAILURE(status) || name[0] == '\0')\r\nreturn NULL;\r\nreturn name;\r\n}\r\nstatic acpi_status sst_acpi_mach_match(acpi_handle handle, u32 level,\r\nvoid *context, void **ret)\r\n{\r\nunsigned long long sta;\r\nacpi_status status;\r\n*(bool *)context = true;\r\nstatus = acpi_evaluate_integer(handle, "_STA", NULL, &sta);\r\nif (ACPI_FAILURE(status) || !(sta & ACPI_STA_DEVICE_PRESENT))\r\n*(bool *)context = false;\r\nreturn AE_OK;\r\n}\r\nbool sst_acpi_check_hid(const u8 hid[ACPI_ID_LEN])\r\n{\r\nacpi_status status;\r\nbool found = false;\r\nstatus = acpi_get_devices(hid, sst_acpi_mach_match, &found, NULL);\r\nif (ACPI_FAILURE(status))\r\nreturn false;\r\nreturn found;\r\n}\r\nstruct sst_acpi_mach *sst_acpi_find_machine(struct sst_acpi_mach *machines)\r\n{\r\nstruct sst_acpi_mach *mach;\r\nfor (mach = machines; mach->id[0]; mach++) {\r\nif (sst_acpi_check_hid(mach->id) == true) {\r\nif (mach->machine_quirk == NULL)\r\nreturn mach;\r\nif (mach->machine_quirk(mach) != NULL)\r\nreturn mach;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic acpi_status sst_acpi_find_package(acpi_handle handle, u32 level,\r\nvoid *context, void **ret)\r\n{\r\nstruct acpi_device *adev;\r\nacpi_status status = AE_OK;\r\nstruct sst_acpi_package_context *pkg_ctx = context;\r\npkg_ctx->data_valid = false;\r\nif (acpi_bus_get_device(handle, &adev))\r\nreturn AE_OK;\r\nif (adev->status.present && adev->status.functional) {\r\nstruct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};\r\nunion acpi_object *myobj = NULL;\r\nstatus = acpi_evaluate_object_typed(handle, pkg_ctx->name,\r\nNULL, &buffer,\r\nACPI_TYPE_PACKAGE);\r\nif (ACPI_FAILURE(status))\r\nreturn AE_OK;\r\nmyobj = buffer.pointer;\r\nif (!myobj || myobj->package.count != pkg_ctx->length) {\r\nkfree(buffer.pointer);\r\nreturn AE_OK;\r\n}\r\nstatus = acpi_extract_package(myobj,\r\npkg_ctx->format, pkg_ctx->state);\r\nif (ACPI_FAILURE(status)) {\r\nkfree(buffer.pointer);\r\nreturn AE_OK;\r\n}\r\nkfree(buffer.pointer);\r\npkg_ctx->data_valid = true;\r\nreturn AE_CTRL_TERMINATE;\r\n}\r\nreturn AE_OK;\r\n}\r\nbool sst_acpi_find_package_from_hid(const u8 hid[ACPI_ID_LEN],\r\nstruct sst_acpi_package_context *ctx)\r\n{\r\nacpi_status status;\r\nstatus = acpi_get_devices(hid, sst_acpi_find_package, ctx, NULL);\r\nif (ACPI_FAILURE(status) || !ctx->data_valid)\r\nreturn false;\r\nreturn true;\r\n}\r\nstruct sst_acpi_mach *sst_acpi_codec_list(void *arg)\r\n{\r\nstruct sst_acpi_mach *mach = arg;\r\nstruct sst_codecs *codec_list = (struct sst_codecs *) mach->quirk_data;\r\nint i;\r\nif (mach->quirk_data == NULL)\r\nreturn mach;\r\nfor (i = 0; i < codec_list->num_codecs; i++) {\r\nif (sst_acpi_check_hid(codec_list->codecs[i]) != true)\r\nreturn NULL;\r\n}\r\nreturn mach;\r\n}
