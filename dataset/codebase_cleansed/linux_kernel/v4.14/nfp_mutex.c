static u32 nfp_mutex_locked(u16 interface)\r\n{\r\nreturn (u32)interface << 16 | 0x000f;\r\n}\r\nstatic u32 nfp_mutex_unlocked(u16 interface)\r\n{\r\nreturn (u32)interface << 16 | 0x0000;\r\n}\r\nstatic bool nfp_mutex_is_locked(u32 val)\r\n{\r\nreturn (val & 0xffff) == 0x000f;\r\n}\r\nstatic bool nfp_mutex_is_unlocked(u32 val)\r\n{\r\nreturn (val & 0xffff) == 0000;\r\n}\r\nstatic int\r\nnfp_cpp_mutex_validate(u16 interface, int *target, unsigned long long address)\r\n{\r\nif (NFP_CPP_INTERFACE_TYPE_of(interface) ==\r\nNFP_CPP_INTERFACE_TYPE_INVALID)\r\nreturn -EINVAL;\r\nif (address & 7)\r\nreturn -EINVAL;\r\nif (*target != NFP_CPP_TARGET_MU)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nint nfp_cpp_mutex_init(struct nfp_cpp *cpp,\r\nint target, unsigned long long address, u32 key)\r\n{\r\nconst u32 muw = NFP_CPP_ID(target, 4, 0);\r\nu16 interface = nfp_cpp_interface(cpp);\r\nint err;\r\nerr = nfp_cpp_mutex_validate(interface, &target, address);\r\nif (err)\r\nreturn err;\r\nerr = nfp_cpp_writel(cpp, muw, address + 4, key);\r\nif (err)\r\nreturn err;\r\nerr = nfp_cpp_writel(cpp, muw, address, nfp_mutex_locked(interface));\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstruct nfp_cpp_mutex *nfp_cpp_mutex_alloc(struct nfp_cpp *cpp, int target,\r\nunsigned long long address, u32 key)\r\n{\r\nconst u32 mur = NFP_CPP_ID(target, 3, 0);\r\nu16 interface = nfp_cpp_interface(cpp);\r\nstruct nfp_cpp_mutex *mutex;\r\nint err;\r\nu32 tmp;\r\nerr = nfp_cpp_mutex_validate(interface, &target, address);\r\nif (err)\r\nreturn NULL;\r\nerr = nfp_cpp_readl(cpp, mur, address + 4, &tmp);\r\nif (err < 0)\r\nreturn NULL;\r\nif (tmp != key)\r\nreturn NULL;\r\nmutex = kzalloc(sizeof(*mutex), GFP_KERNEL);\r\nif (!mutex)\r\nreturn NULL;\r\nmutex->cpp = cpp;\r\nmutex->target = target;\r\nmutex->address = address;\r\nmutex->key = key;\r\nmutex->depth = 0;\r\nreturn mutex;\r\n}\r\nvoid nfp_cpp_mutex_free(struct nfp_cpp_mutex *mutex)\r\n{\r\nkfree(mutex);\r\n}\r\nint nfp_cpp_mutex_lock(struct nfp_cpp_mutex *mutex)\r\n{\r\nunsigned long warn_at = jiffies + NFP_MUTEX_WAIT_FIRST_WARN * HZ;\r\nunsigned long err_at = jiffies + NFP_MUTEX_WAIT_ERROR * HZ;\r\nunsigned int timeout_ms = 1;\r\nint err;\r\nfor (;;) {\r\nerr = nfp_cpp_mutex_trylock(mutex);\r\nif (err != -EBUSY)\r\nbreak;\r\nerr = msleep_interruptible(timeout_ms);\r\nif (err != 0)\r\nreturn -ERESTARTSYS;\r\nif (time_is_before_eq_jiffies(warn_at)) {\r\nwarn_at = jiffies + NFP_MUTEX_WAIT_NEXT_WARN * HZ;\r\nnfp_warn(mutex->cpp,\r\n"Warning: waiting for NFP mutex [depth:%hd target:%d addr:%llx key:%08x]\n",\r\nmutex->depth,\r\nmutex->target, mutex->address, mutex->key);\r\n}\r\nif (time_is_before_eq_jiffies(err_at)) {\r\nnfp_err(mutex->cpp, "Error: mutex wait timed out\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nreturn err;\r\n}\r\nint nfp_cpp_mutex_unlock(struct nfp_cpp_mutex *mutex)\r\n{\r\nconst u32 muw = NFP_CPP_ID(mutex->target, 4, 0);\r\nconst u32 mur = NFP_CPP_ID(mutex->target, 3, 0);\r\nstruct nfp_cpp *cpp = mutex->cpp;\r\nu32 key, value;\r\nu16 interface;\r\nint err;\r\ninterface = nfp_cpp_interface(cpp);\r\nif (mutex->depth > 1) {\r\nmutex->depth--;\r\nreturn 0;\r\n}\r\nerr = nfp_cpp_readl(mutex->cpp, mur, mutex->address + 4, &key);\r\nif (err < 0)\r\nreturn err;\r\nif (key != mutex->key)\r\nreturn -EPERM;\r\nerr = nfp_cpp_readl(mutex->cpp, mur, mutex->address, &value);\r\nif (err < 0)\r\nreturn err;\r\nif (value != nfp_mutex_locked(interface))\r\nreturn -EACCES;\r\nerr = nfp_cpp_writel(cpp, muw, mutex->address,\r\nnfp_mutex_unlocked(interface));\r\nif (err < 0)\r\nreturn err;\r\nmutex->depth = 0;\r\nreturn 0;\r\n}\r\nint nfp_cpp_mutex_trylock(struct nfp_cpp_mutex *mutex)\r\n{\r\nconst u32 muw = NFP_CPP_ID(mutex->target, 4, 0);\r\nconst u32 mus = NFP_CPP_ID(mutex->target, 5, 3);\r\nconst u32 mur = NFP_CPP_ID(mutex->target, 3, 0);\r\nstruct nfp_cpp *cpp = mutex->cpp;\r\nu32 key, value, tmp;\r\nint err;\r\nif (mutex->depth > 0) {\r\nif (mutex->depth == NFP_MUTEX_DEPTH_MAX)\r\nreturn -E2BIG;\r\nmutex->depth++;\r\nreturn 0;\r\n}\r\nerr = nfp_cpp_readl(cpp, mur, mutex->address + 4, &key);\r\nif (err < 0)\r\nreturn err;\r\nif (key != mutex->key)\r\nreturn -EPERM;\r\nvalue = nfp_mutex_locked(nfp_cpp_interface(cpp));\r\nerr = nfp_cpp_readl(cpp, mus, mutex->address, &tmp);\r\nif (err < 0)\r\nreturn err;\r\nif (nfp_mutex_is_unlocked(tmp)) {\r\nerr = nfp_cpp_writel(cpp, muw, mutex->address, value);\r\nif (err < 0)\r\nreturn err;\r\nmutex->depth = 1;\r\nreturn 0;\r\n}\r\nreturn nfp_mutex_is_locked(tmp) ? -EBUSY : -EINVAL;\r\n}
