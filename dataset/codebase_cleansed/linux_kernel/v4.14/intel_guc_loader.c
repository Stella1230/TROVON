static u32 get_gttype(struct drm_i915_private *dev_priv)\r\n{\r\nreturn 0;\r\n}\r\nstatic u32 get_core_family(struct drm_i915_private *dev_priv)\r\n{\r\nu32 gen = INTEL_GEN(dev_priv);\r\nswitch (gen) {\r\ncase 9:\r\nreturn GUC_CORE_FAMILY_GEN9;\r\ndefault:\r\nMISSING_CASE(gen);\r\nreturn GUC_CORE_FAMILY_UNKNOWN;\r\n}\r\n}\r\nstatic void guc_params_init(struct drm_i915_private *dev_priv)\r\n{\r\nstruct intel_guc *guc = &dev_priv->guc;\r\nu32 params[GUC_CTL_MAX_DWORDS];\r\nint i;\r\nmemset(&params, 0, sizeof(params));\r\nparams[GUC_CTL_DEVICE_INFO] |=\r\n(get_gttype(dev_priv) << GUC_CTL_GTTYPE_SHIFT) |\r\n(get_core_family(dev_priv) << GUC_CTL_COREFAMILY_SHIFT);\r\nparams[GUC_CTL_ARAT_HIGH] = 0;\r\nparams[GUC_CTL_ARAT_LOW] = 100000000;\r\nparams[GUC_CTL_WA] |= GUC_CTL_WA_UK_BY_DRIVER;\r\nparams[GUC_CTL_FEATURE] |= GUC_CTL_DISABLE_SCHEDULER |\r\nGUC_CTL_VCS2_ENABLED;\r\nparams[GUC_CTL_LOG_PARAMS] = guc->log.flags;\r\nif (i915.guc_log_level >= 0) {\r\nparams[GUC_CTL_DEBUG] =\r\ni915.guc_log_level << GUC_LOG_VERBOSITY_SHIFT;\r\n} else\r\nparams[GUC_CTL_DEBUG] = GUC_LOG_DISABLED;\r\nif (i915.enable_guc_submission) {\r\nu32 ads = guc_ggtt_offset(guc->ads_vma) >> PAGE_SHIFT;\r\nu32 pgs = guc_ggtt_offset(dev_priv->guc.stage_desc_pool);\r\nu32 ctx_in_16 = GUC_MAX_STAGE_DESCRIPTORS / 16;\r\nparams[GUC_CTL_DEBUG] |= ads << GUC_ADS_ADDR_SHIFT;\r\nparams[GUC_CTL_DEBUG] |= GUC_ADS_ENABLED;\r\npgs >>= PAGE_SHIFT;\r\nparams[GUC_CTL_CTXINFO] = (pgs << GUC_CTL_BASE_ADDR_SHIFT) |\r\n(ctx_in_16 << GUC_CTL_CTXNUM_IN16_SHIFT);\r\nparams[GUC_CTL_FEATURE] |= GUC_CTL_KERNEL_SUBMISSIONS;\r\nparams[GUC_CTL_FEATURE] &= ~GUC_CTL_DISABLE_SCHEDULER;\r\n}\r\nI915_WRITE(SOFT_SCRATCH(0), 0);\r\nfor (i = 0; i < GUC_CTL_MAX_DWORDS; i++)\r\nI915_WRITE(SOFT_SCRATCH(1 + i), params[i]);\r\n}\r\nstatic inline bool guc_ucode_response(struct drm_i915_private *dev_priv,\r\nu32 *status)\r\n{\r\nu32 val = I915_READ(GUC_STATUS);\r\nu32 uk_val = val & GS_UKERNEL_MASK;\r\n*status = val;\r\nreturn (uk_val == GS_UKERNEL_READY ||\r\n((val & GS_MIA_CORE_STATE) && uk_val == GS_UKERNEL_LAPIC_DONE));\r\n}\r\nstatic int guc_ucode_xfer_dma(struct drm_i915_private *dev_priv,\r\nstruct i915_vma *vma)\r\n{\r\nstruct intel_uc_fw *guc_fw = &dev_priv->guc.fw;\r\nunsigned long offset;\r\nstruct sg_table *sg = vma->pages;\r\nu32 status, rsa[UOS_RSA_SCRATCH_MAX_COUNT];\r\nint i, ret = 0;\r\noffset = guc_fw->rsa_offset;\r\nsg_pcopy_to_buffer(sg->sgl, sg->nents, rsa, sizeof(rsa), offset);\r\nfor (i = 0; i < UOS_RSA_SCRATCH_MAX_COUNT; i++)\r\nI915_WRITE(UOS_RSA_SCRATCH(i), rsa[i]);\r\nI915_WRITE(DMA_COPY_SIZE, guc_fw->header_size + guc_fw->ucode_size);\r\noffset = guc_ggtt_offset(vma) + guc_fw->header_offset;\r\nI915_WRITE(DMA_ADDR_0_LOW, lower_32_bits(offset));\r\nI915_WRITE(DMA_ADDR_0_HIGH, upper_32_bits(offset) & 0xFFFF);\r\nI915_WRITE(DMA_ADDR_1_LOW, 0x2000);\r\nI915_WRITE(DMA_ADDR_1_HIGH, DMA_ADDRESS_SPACE_WOPCM);\r\nI915_WRITE(DMA_CTRL, _MASKED_BIT_ENABLE(UOS_MOVE | START_DMA));\r\nret = wait_for(guc_ucode_response(dev_priv, &status), 100);\r\nDRM_DEBUG_DRIVER("DMA status 0x%x, GuC status 0x%x\n",\r\nI915_READ(DMA_CTRL), status);\r\nif ((status & GS_BOOTROM_MASK) == GS_BOOTROM_RSA_FAILED) {\r\nDRM_ERROR("GuC firmware signature verification failed\n");\r\nret = -ENOEXEC;\r\n}\r\nDRM_DEBUG_DRIVER("returning %d\n", ret);\r\nreturn ret;\r\n}\r\nu32 intel_guc_wopcm_size(struct drm_i915_private *dev_priv)\r\n{\r\nu32 wopcm_size = GUC_WOPCM_TOP;\r\nif (IS_GEN9_LP(dev_priv))\r\nwopcm_size -= BXT_GUC_WOPCM_RC6_RESERVED;\r\nreturn wopcm_size;\r\n}\r\nstatic int guc_ucode_xfer(struct drm_i915_private *dev_priv)\r\n{\r\nstruct intel_uc_fw *guc_fw = &dev_priv->guc.fw;\r\nstruct i915_vma *vma;\r\nint ret;\r\nret = i915_gem_object_set_to_gtt_domain(guc_fw->obj, false);\r\nif (ret) {\r\nDRM_DEBUG_DRIVER("set-domain failed %d\n", ret);\r\nreturn ret;\r\n}\r\nvma = i915_gem_object_ggtt_pin(guc_fw->obj, NULL, 0, 0,\r\nPIN_OFFSET_BIAS | GUC_WOPCM_TOP);\r\nif (IS_ERR(vma)) {\r\nDRM_DEBUG_DRIVER("pin failed %d\n", (int)PTR_ERR(vma));\r\nreturn PTR_ERR(vma);\r\n}\r\nintel_uncore_forcewake_get(dev_priv, FORCEWAKE_ALL);\r\nI915_WRITE(GUC_SHIM_CONTROL, GUC_SHIM_CONTROL_VALUE);\r\nif (IS_BXT_REVID(dev_priv, 0, BXT_REVID_A1)) {\r\nI915_WRITE(GUC_SHIM_CONTROL, (I915_READ(GUC_SHIM_CONTROL) &\r\n~GUC_ENABLE_MIA_CLOCK_GATING));\r\n}\r\nif (IS_BXT_REVID(dev_priv, 0, BXT_REVID_B0))\r\nI915_WRITE(GEN6_GFXPAUSE, 0x30FFF);\r\nif (IS_GEN9_LP(dev_priv))\r\nI915_WRITE(GEN9LP_GT_PM_CONFIG, GT_DOORBELL_ENABLE);\r\nelse\r\nI915_WRITE(GEN9_GT_PM_CONFIG, GT_DOORBELL_ENABLE);\r\nif (IS_GEN9(dev_priv)) {\r\nI915_WRITE(GEN7_MISCCPCTL, (GEN8_DOP_CLOCK_GATE_GUC_ENABLE |\r\nI915_READ(GEN7_MISCCPCTL)));\r\nI915_WRITE(GUC_ARAT_C6DIS, 0x1FF);\r\n}\r\nguc_params_init(dev_priv);\r\nret = guc_ucode_xfer_dma(dev_priv, vma);\r\nintel_uncore_forcewake_put(dev_priv, FORCEWAKE_ALL);\r\ni915_vma_unpin(vma);\r\nreturn ret;\r\n}\r\nint intel_guc_init_hw(struct intel_guc *guc)\r\n{\r\nstruct drm_i915_private *dev_priv = guc_to_i915(guc);\r\nconst char *fw_path = guc->fw.path;\r\nint ret;\r\nDRM_DEBUG_DRIVER("GuC fw status: path %s, fetch %s, load %s\n",\r\nfw_path,\r\nintel_uc_fw_status_repr(guc->fw.fetch_status),\r\nintel_uc_fw_status_repr(guc->fw.load_status));\r\nif (guc->fw.fetch_status != INTEL_UC_FIRMWARE_SUCCESS)\r\nreturn -EIO;\r\nguc->fw.load_status = INTEL_UC_FIRMWARE_PENDING;\r\nDRM_DEBUG_DRIVER("GuC fw status: fetch %s, load %s\n",\r\nintel_uc_fw_status_repr(guc->fw.fetch_status),\r\nintel_uc_fw_status_repr(guc->fw.load_status));\r\nret = guc_ucode_xfer(dev_priv);\r\nif (ret)\r\nreturn -EAGAIN;\r\nguc->fw.load_status = INTEL_UC_FIRMWARE_SUCCESS;\r\nDRM_INFO("GuC %s (firmware %s [version %u.%u])\n",\r\ni915.enable_guc_submission ? "submission enabled" : "loaded",\r\nguc->fw.path,\r\nguc->fw.major_ver_found, guc->fw.minor_ver_found);\r\nreturn 0;\r\n}\r\nint intel_guc_select_fw(struct intel_guc *guc)\r\n{\r\nstruct drm_i915_private *dev_priv = guc_to_i915(guc);\r\nguc->fw.path = NULL;\r\nguc->fw.fetch_status = INTEL_UC_FIRMWARE_NONE;\r\nguc->fw.load_status = INTEL_UC_FIRMWARE_NONE;\r\nguc->fw.type = INTEL_UC_FW_TYPE_GUC;\r\nif (i915.guc_firmware_path) {\r\nguc->fw.path = i915.guc_firmware_path;\r\nguc->fw.major_ver_wanted = 0;\r\nguc->fw.minor_ver_wanted = 0;\r\n} else if (IS_SKYLAKE(dev_priv)) {\r\nguc->fw.path = I915_SKL_GUC_UCODE;\r\nguc->fw.major_ver_wanted = SKL_FW_MAJOR;\r\nguc->fw.minor_ver_wanted = SKL_FW_MINOR;\r\n} else if (IS_BROXTON(dev_priv)) {\r\nguc->fw.path = I915_BXT_GUC_UCODE;\r\nguc->fw.major_ver_wanted = BXT_FW_MAJOR;\r\nguc->fw.minor_ver_wanted = BXT_FW_MINOR;\r\n} else if (IS_KABYLAKE(dev_priv) || IS_COFFEELAKE(dev_priv)) {\r\nguc->fw.path = I915_KBL_GUC_UCODE;\r\nguc->fw.major_ver_wanted = KBL_FW_MAJOR;\r\nguc->fw.minor_ver_wanted = KBL_FW_MINOR;\r\n} else if (IS_GEMINILAKE(dev_priv)) {\r\nguc->fw.path = I915_GLK_GUC_UCODE;\r\nguc->fw.major_ver_wanted = GLK_FW_MAJOR;\r\nguc->fw.minor_ver_wanted = GLK_FW_MINOR;\r\n} else {\r\nDRM_ERROR("No GuC firmware known for platform with GuC!\n");\r\nreturn -ENOENT;\r\n}\r\nreturn 0;\r\n}
