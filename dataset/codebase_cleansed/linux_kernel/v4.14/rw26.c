static void ll_invalidatepage(struct page *vmpage, unsigned int offset,\r\nunsigned int length)\r\n{\r\nstruct inode *inode;\r\nstruct lu_env *env;\r\nstruct cl_page *page;\r\nstruct cl_object *obj;\r\nLASSERT(PageLocked(vmpage));\r\nLASSERT(!PageWriteback(vmpage));\r\nif (offset == 0 && length == PAGE_SIZE) {\r\nenv = cl_env_percpu_get();\r\nLASSERT(!IS_ERR(env));\r\ninode = vmpage->mapping->host;\r\nobj = ll_i2info(inode)->lli_clob;\r\nif (obj) {\r\npage = cl_vmpage_page(vmpage, obj);\r\nif (page) {\r\ncl_page_delete(env, page);\r\ncl_page_put(env, page);\r\n}\r\n} else {\r\nLASSERT(vmpage->private == 0);\r\n}\r\ncl_env_percpu_put(env);\r\n}\r\n}\r\nstatic int ll_releasepage(struct page *vmpage, gfp_t gfp_mask)\r\n{\r\nstruct lu_env *env;\r\nstruct cl_object *obj;\r\nstruct cl_page *page;\r\nstruct address_space *mapping;\r\nint result = 0;\r\nLASSERT(PageLocked(vmpage));\r\nif (PageWriteback(vmpage) || PageDirty(vmpage))\r\nreturn 0;\r\nmapping = vmpage->mapping;\r\nif (!mapping)\r\nreturn 1;\r\nobj = ll_i2info(mapping->host)->lli_clob;\r\nif (!obj)\r\nreturn 1;\r\nif (page_count(vmpage) > 3)\r\nreturn 0;\r\npage = cl_vmpage_page(vmpage, obj);\r\nif (!page)\r\nreturn 1;\r\nenv = cl_env_percpu_get();\r\nLASSERT(!IS_ERR(env));\r\nif (!cl_page_in_use(page)) {\r\nresult = 1;\r\ncl_page_delete(env, page);\r\n}\r\nLASSERT(cl_object_refc(obj) > 1);\r\ncl_page_put(env, page);\r\ncl_env_percpu_put(env);\r\nreturn result;\r\n}\r\nstatic void ll_free_user_pages(struct page **pages, int npages, int do_dirty)\r\n{\r\nint i;\r\nfor (i = 0; i < npages; i++) {\r\nif (do_dirty)\r\nset_page_dirty_lock(pages[i]);\r\nput_page(pages[i]);\r\n}\r\nkvfree(pages);\r\n}\r\nssize_t ll_direct_rw_pages(const struct lu_env *env, struct cl_io *io,\r\nint rw, struct inode *inode,\r\nstruct ll_dio_pages *pv)\r\n{\r\nstruct cl_page *clp;\r\nstruct cl_2queue *queue;\r\nstruct cl_object *obj = io->ci_obj;\r\nint i;\r\nssize_t rc = 0;\r\nloff_t file_offset = pv->ldp_start_offset;\r\nsize_t size = pv->ldp_size;\r\nint page_count = pv->ldp_nr;\r\nstruct page **pages = pv->ldp_pages;\r\nsize_t page_size = cl_page_size(obj);\r\nbool do_io;\r\nint io_pages = 0;\r\nqueue = &io->ci_queue;\r\ncl_2queue_init(queue);\r\nfor (i = 0; i < page_count; i++) {\r\nif (pv->ldp_offsets)\r\nfile_offset = pv->ldp_offsets[i];\r\nLASSERT(!(file_offset & (page_size - 1)));\r\nclp = cl_page_find(env, obj, cl_index(obj, file_offset),\r\npv->ldp_pages[i], CPT_TRANSIENT);\r\nif (IS_ERR(clp)) {\r\nrc = PTR_ERR(clp);\r\nbreak;\r\n}\r\nrc = cl_page_own(env, io, clp);\r\nif (rc) {\r\nLASSERT(clp->cp_state == CPS_FREEING);\r\ncl_page_put(env, clp);\r\nbreak;\r\n}\r\ndo_io = true;\r\nif (clp->cp_type == CPT_CACHEABLE) {\r\nstruct page *vmpage = cl_page_vmpage(clp);\r\nstruct page *src_page;\r\nstruct page *dst_page;\r\nvoid *src;\r\nvoid *dst;\r\nsrc_page = (rw == WRITE) ? pages[i] : vmpage;\r\ndst_page = (rw == WRITE) ? vmpage : pages[i];\r\nsrc = kmap_atomic(src_page);\r\ndst = kmap_atomic(dst_page);\r\nmemcpy(dst, src, min(page_size, size));\r\nkunmap_atomic(dst);\r\nkunmap_atomic(src);\r\nif (rw == WRITE)\r\nset_page_dirty(vmpage);\r\nif (rw == READ) {\r\ncl_page_disown(env, io, clp);\r\ndo_io = false;\r\n}\r\n}\r\nif (likely(do_io)) {\r\ncl_page_list_add(&queue->c2_qin, clp);\r\ncl_page_clip(env, clp, 0, min(size, page_size));\r\n++io_pages;\r\n}\r\ncl_page_put(env, clp);\r\nsize -= page_size;\r\nfile_offset += page_size;\r\n}\r\nif (rc == 0 && io_pages) {\r\nrc = cl_io_submit_sync(env, io,\r\nrw == READ ? CRT_READ : CRT_WRITE,\r\nqueue, 0);\r\n}\r\nif (rc == 0)\r\nrc = pv->ldp_size;\r\ncl_2queue_discard(env, io, queue);\r\ncl_2queue_disown(env, io, queue);\r\ncl_2queue_fini(env, queue);\r\nreturn rc;\r\n}\r\nstatic ssize_t ll_direct_IO_26_seg(const struct lu_env *env, struct cl_io *io,\r\nint rw, struct inode *inode,\r\nstruct address_space *mapping,\r\nsize_t size, loff_t file_offset,\r\nstruct page **pages, int page_count)\r\n{\r\nstruct ll_dio_pages pvec = {\r\n.ldp_pages = pages,\r\n.ldp_nr = page_count,\r\n.ldp_size = size,\r\n.ldp_offsets = NULL,\r\n.ldp_start_offset = file_offset\r\n};\r\nreturn ll_direct_rw_pages(env, io, rw, inode, &pvec);\r\n}\r\nstatic ssize_t ll_direct_IO_26(struct kiocb *iocb, struct iov_iter *iter)\r\n{\r\nstruct ll_cl_context *lcc;\r\nconst struct lu_env *env;\r\nstruct cl_io *io;\r\nstruct file *file = iocb->ki_filp;\r\nstruct inode *inode = file->f_mapping->host;\r\nloff_t file_offset = iocb->ki_pos;\r\nssize_t count = iov_iter_count(iter);\r\nssize_t tot_bytes = 0, result = 0;\r\nlong size = MAX_DIO_SIZE;\r\nif (iov_iter_rw(iter) == READ && file_offset >= i_size_read(inode))\r\nreturn 0;\r\nif ((file_offset & ~PAGE_MASK) || (count & ~PAGE_MASK))\r\nreturn -EINVAL;\r\nCDEBUG(D_VFSTRACE, "VFS Op:inode=" DFID "(%p), size=%zd (max %lu), offset=%lld=%llx, pages %zd (max %lu)\n",\r\nPFID(ll_inode2fid(inode)), inode, count, MAX_DIO_SIZE,\r\nfile_offset, file_offset, count >> PAGE_SHIFT,\r\nMAX_DIO_SIZE >> PAGE_SHIFT);\r\nif (iov_iter_alignment(iter) & ~PAGE_MASK)\r\nreturn -EINVAL;\r\nlcc = ll_cl_find(file);\r\nif (!lcc)\r\nreturn -EIO;\r\nenv = lcc->lcc_env;\r\nLASSERT(!IS_ERR(env));\r\nio = lcc->lcc_io;\r\nLASSERT(io);\r\nwhile (iov_iter_count(iter)) {\r\nstruct page **pages;\r\nsize_t offs;\r\ncount = min_t(size_t, iov_iter_count(iter), size);\r\nif (iov_iter_rw(iter) == READ) {\r\nif (file_offset >= i_size_read(inode))\r\nbreak;\r\nif (file_offset + count > i_size_read(inode))\r\ncount = i_size_read(inode) - file_offset;\r\n}\r\nresult = iov_iter_get_pages_alloc(iter, &pages, count, &offs);\r\nif (likely(result > 0)) {\r\nint n = DIV_ROUND_UP(result + offs, PAGE_SIZE);\r\nresult = ll_direct_IO_26_seg(env, io, iov_iter_rw(iter),\r\ninode, file->f_mapping,\r\nresult, file_offset, pages,\r\nn);\r\nll_free_user_pages(pages, n, iov_iter_rw(iter) == READ);\r\n}\r\nif (unlikely(result <= 0)) {\r\nif (result == -ENOMEM &&\r\nsize > (PAGE_SIZE / sizeof(*pages)) *\r\nPAGE_SIZE) {\r\nsize = ((((size / 2) - 1) |\r\n~PAGE_MASK) + 1) &\r\nPAGE_MASK;\r\nCDEBUG(D_VFSTRACE, "DIO size now %lu\n",\r\nsize);\r\ncontinue;\r\n}\r\ngoto out;\r\n}\r\niov_iter_advance(iter, result);\r\ntot_bytes += result;\r\nfile_offset += result;\r\n}\r\nout:\r\nif (tot_bytes > 0) {\r\nstruct vvp_io *vio = vvp_env_io(env);\r\nvio->u.write.vui_written += tot_bytes;\r\n}\r\nreturn tot_bytes ? tot_bytes : result;\r\n}\r\nstatic int ll_prepare_partial_page(const struct lu_env *env, struct cl_io *io,\r\nstruct cl_page *pg)\r\n{\r\nstruct cl_attr *attr = vvp_env_thread_attr(env);\r\nstruct cl_object *obj = io->ci_obj;\r\nstruct vvp_page *vpg = cl_object_page_slice(obj, pg);\r\nloff_t offset = cl_offset(obj, vvp_index(vpg));\r\nint result;\r\ncl_object_attr_lock(obj);\r\nresult = cl_object_attr_get(env, obj, attr);\r\ncl_object_attr_unlock(obj);\r\nif (result == 0) {\r\nif (attr->cat_kms <= offset) {\r\nchar *kaddr = kmap_atomic(vpg->vpg_page);\r\nmemset(kaddr, 0, cl_page_size(obj));\r\nkunmap_atomic(kaddr);\r\n} else if (vpg->vpg_defer_uptodate) {\r\nvpg->vpg_ra_used = 1;\r\n} else {\r\nresult = ll_page_sync_io(env, io, pg, CRT_READ);\r\n}\r\n}\r\nreturn result;\r\n}\r\nstatic int ll_write_begin(struct file *file, struct address_space *mapping,\r\nloff_t pos, unsigned int len, unsigned int flags,\r\nstruct page **pagep, void **fsdata)\r\n{\r\nstruct ll_cl_context *lcc;\r\nconst struct lu_env *env = NULL;\r\nstruct cl_io *io;\r\nstruct cl_page *page = NULL;\r\nstruct cl_object *clob = ll_i2info(mapping->host)->lli_clob;\r\npgoff_t index = pos >> PAGE_SHIFT;\r\nstruct page *vmpage = NULL;\r\nunsigned int from = pos & (PAGE_SIZE - 1);\r\nunsigned int to = from + len;\r\nint result = 0;\r\nCDEBUG(D_VFSTRACE, "Writing %lu of %d to %d bytes\n", index, from, len);\r\nlcc = ll_cl_find(file);\r\nif (!lcc) {\r\nio = NULL;\r\nresult = -EIO;\r\ngoto out;\r\n}\r\nenv = lcc->lcc_env;\r\nio = lcc->lcc_io;\r\nvmpage = grab_cache_page_nowait(mapping, index);\r\nif (unlikely(!vmpage || PageDirty(vmpage) || PageWriteback(vmpage))) {\r\nstruct vvp_io *vio = vvp_env_io(env);\r\nstruct cl_page_list *plist = &vio->u.write.vui_queue;\r\nif (vmpage && plist->pl_nr > 0) {\r\nunlock_page(vmpage);\r\nput_page(vmpage);\r\nvmpage = NULL;\r\n}\r\nresult = vvp_io_write_commit(env, io);\r\nif (result < 0)\r\ngoto out;\r\nif (!vmpage) {\r\nvmpage = grab_cache_page_write_begin(mapping, index,\r\nflags);\r\nif (!vmpage) {\r\nresult = -ENOMEM;\r\ngoto out;\r\n}\r\n}\r\n}\r\npage = cl_page_find(env, clob, vmpage->index, vmpage, CPT_CACHEABLE);\r\nif (IS_ERR(page)) {\r\nresult = PTR_ERR(page);\r\ngoto out;\r\n}\r\nlcc->lcc_page = page;\r\nlu_ref_add(&page->cp_reference, "cl_io", io);\r\ncl_page_assume(env, io, page);\r\nif (!PageUptodate(vmpage)) {\r\nif (from == 0 && to == PAGE_SIZE) {\r\nCL_PAGE_HEADER(D_PAGE, env, page, "full page write\n");\r\nPOISON_PAGE(vmpage, 0x11);\r\n} else {\r\nresult = ll_prepare_partial_page(env, io, page);\r\nif (result == 0)\r\nSetPageUptodate(vmpage);\r\n}\r\n}\r\nif (result < 0)\r\ncl_page_unassume(env, io, page);\r\nout:\r\nif (result < 0) {\r\nif (vmpage) {\r\nunlock_page(vmpage);\r\nput_page(vmpage);\r\n}\r\nif (!IS_ERR_OR_NULL(page)) {\r\nlu_ref_del(&page->cp_reference, "cl_io", io);\r\ncl_page_put(env, page);\r\n}\r\nif (io)\r\nio->ci_result = result;\r\n} else {\r\n*pagep = vmpage;\r\n*fsdata = lcc;\r\n}\r\nreturn result;\r\n}\r\nstatic int ll_write_end(struct file *file, struct address_space *mapping,\r\nloff_t pos, unsigned int len, unsigned int copied,\r\nstruct page *vmpage, void *fsdata)\r\n{\r\nstruct ll_cl_context *lcc = fsdata;\r\nconst struct lu_env *env;\r\nstruct cl_io *io;\r\nstruct vvp_io *vio;\r\nstruct cl_page *page;\r\nunsigned int from = pos & (PAGE_SIZE - 1);\r\nbool unplug = false;\r\nint result = 0;\r\nput_page(vmpage);\r\nenv = lcc->lcc_env;\r\npage = lcc->lcc_page;\r\nio = lcc->lcc_io;\r\nvio = vvp_env_io(env);\r\nLASSERT(cl_page_is_owned(page, io));\r\nif (copied > 0) {\r\nstruct cl_page_list *plist = &vio->u.write.vui_queue;\r\nlcc->lcc_page = NULL;\r\ncl_page_list_add(plist, page);\r\nif (plist->pl_nr == 1)\r\nvio->u.write.vui_from = from;\r\nelse\r\nLASSERT(from == 0);\r\nvio->u.write.vui_to = from + copied;\r\nif (PageDirty(vmpage))\r\nunplug = true;\r\nif (plist->pl_nr >= PTLRPC_MAX_BRW_PAGES)\r\nunplug = true;\r\nCL_PAGE_DEBUG(D_VFSTRACE, env, page,\r\n"queued page: %d.\n", plist->pl_nr);\r\n} else {\r\ncl_page_disown(env, io, page);\r\nlcc->lcc_page = NULL;\r\nlu_ref_del(&page->cp_reference, "cl_io", io);\r\ncl_page_put(env, page);\r\nunplug = true;\r\n}\r\nif (unplug ||\r\nfile->f_flags & O_SYNC || IS_SYNC(file_inode(file)))\r\nresult = vvp_io_write_commit(env, io);\r\nif (result < 0)\r\nio->ci_result = result;\r\nreturn result >= 0 ? copied : result;\r\n}\r\nstatic int ll_migratepage(struct address_space *mapping,\r\nstruct page *newpage, struct page *page,\r\nenum migrate_mode mode\r\n)\r\n{\r\nreturn -EIO;\r\n}
