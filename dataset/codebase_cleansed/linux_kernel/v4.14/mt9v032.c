static struct mt9v032 *to_mt9v032(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct mt9v032, subdev);\r\n}\r\nstatic int\r\nmt9v032_update_aec_agc(struct mt9v032 *mt9v032, u16 which, int enable)\r\n{\r\nstruct regmap *map = mt9v032->regmap;\r\nu16 value = mt9v032->aec_agc;\r\nint ret;\r\nif (enable)\r\nvalue |= which;\r\nelse\r\nvalue &= ~which;\r\nret = regmap_write(map, MT9V032_AEC_AGC_ENABLE, value);\r\nif (ret < 0)\r\nreturn ret;\r\nmt9v032->aec_agc = value;\r\nreturn 0;\r\n}\r\nstatic int\r\nmt9v032_update_hblank(struct mt9v032 *mt9v032)\r\n{\r\nstruct v4l2_rect *crop = &mt9v032->crop;\r\nunsigned int min_hblank = mt9v032->model->data->min_hblank;\r\nunsigned int hblank;\r\nif (mt9v032->version->version == MT9V034_CHIP_ID_REV1)\r\nmin_hblank += (mt9v032->hratio - 1) * 10;\r\nmin_hblank = max_t(int, mt9v032->model->data->min_row_time - crop->width,\r\nmin_hblank);\r\nhblank = max_t(unsigned int, mt9v032->hblank, min_hblank);\r\nreturn regmap_write(mt9v032->regmap, MT9V032_HORIZONTAL_BLANKING,\r\nhblank);\r\n}\r\nstatic int mt9v032_power_on(struct mt9v032 *mt9v032)\r\n{\r\nstruct regmap *map = mt9v032->regmap;\r\nint ret;\r\ngpiod_set_value_cansleep(mt9v032->reset_gpio, 1);\r\nret = clk_set_rate(mt9v032->clk, mt9v032->sysclk);\r\nif (ret < 0)\r\nreturn ret;\r\nret = clk_prepare_enable(mt9v032->clk);\r\nif (ret)\r\nreturn ret;\r\nudelay(1);\r\nif (mt9v032->reset_gpio) {\r\ngpiod_set_value_cansleep(mt9v032->reset_gpio, 0);\r\nudelay(1);\r\n}\r\nret = regmap_write(map, MT9V032_RESET, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nret = regmap_write(map, MT9V032_RESET, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn regmap_write(map, MT9V032_CHIP_CONTROL,\r\nMT9V032_CHIP_CONTROL_MASTER_MODE);\r\n}\r\nstatic void mt9v032_power_off(struct mt9v032 *mt9v032)\r\n{\r\nclk_disable_unprepare(mt9v032->clk);\r\n}\r\nstatic int __mt9v032_set_power(struct mt9v032 *mt9v032, bool on)\r\n{\r\nstruct regmap *map = mt9v032->regmap;\r\nint ret;\r\nif (!on) {\r\nmt9v032_power_off(mt9v032);\r\nreturn 0;\r\n}\r\nret = mt9v032_power_on(mt9v032);\r\nif (ret < 0)\r\nreturn ret;\r\nif (mt9v032->pdata && mt9v032->pdata->clk_pol) {\r\nret = regmap_write(map, mt9v032->model->data->pclk_reg,\r\nMT9V032_PIXEL_CLOCK_INV_PXL_CLK);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nret = regmap_write(map, MT9V032_ROW_NOISE_CORR_CONTROL, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn v4l2_ctrl_handler_setup(&mt9v032->ctrls);\r\n}\r\nstatic struct v4l2_mbus_framefmt *\r\n__mt9v032_get_pad_format(struct mt9v032 *mt9v032, struct v4l2_subdev_pad_config *cfg,\r\nunsigned int pad, enum v4l2_subdev_format_whence which)\r\n{\r\nswitch (which) {\r\ncase V4L2_SUBDEV_FORMAT_TRY:\r\nreturn v4l2_subdev_get_try_format(&mt9v032->subdev, cfg, pad);\r\ncase V4L2_SUBDEV_FORMAT_ACTIVE:\r\nreturn &mt9v032->format;\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nstatic struct v4l2_rect *\r\n__mt9v032_get_pad_crop(struct mt9v032 *mt9v032, struct v4l2_subdev_pad_config *cfg,\r\nunsigned int pad, enum v4l2_subdev_format_whence which)\r\n{\r\nswitch (which) {\r\ncase V4L2_SUBDEV_FORMAT_TRY:\r\nreturn v4l2_subdev_get_try_crop(&mt9v032->subdev, cfg, pad);\r\ncase V4L2_SUBDEV_FORMAT_ACTIVE:\r\nreturn &mt9v032->crop;\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nstatic int mt9v032_s_stream(struct v4l2_subdev *subdev, int enable)\r\n{\r\nconst u16 mode = MT9V032_CHIP_CONTROL_DOUT_ENABLE\r\n| MT9V032_CHIP_CONTROL_SEQUENTIAL;\r\nstruct mt9v032 *mt9v032 = to_mt9v032(subdev);\r\nstruct v4l2_rect *crop = &mt9v032->crop;\r\nstruct regmap *map = mt9v032->regmap;\r\nunsigned int hbin;\r\nunsigned int vbin;\r\nint ret;\r\nif (!enable)\r\nreturn regmap_update_bits(map, MT9V032_CHIP_CONTROL, mode, 0);\r\nhbin = fls(mt9v032->hratio) - 1;\r\nvbin = fls(mt9v032->vratio) - 1;\r\nret = regmap_update_bits(map, MT9V032_READ_MODE,\r\n~MT9V032_READ_MODE_RESERVED,\r\nhbin << MT9V032_READ_MODE_COLUMN_BIN_SHIFT |\r\nvbin << MT9V032_READ_MODE_ROW_BIN_SHIFT);\r\nif (ret < 0)\r\nreturn ret;\r\nret = regmap_write(map, MT9V032_COLUMN_START, crop->left);\r\nif (ret < 0)\r\nreturn ret;\r\nret = regmap_write(map, MT9V032_ROW_START, crop->top);\r\nif (ret < 0)\r\nreturn ret;\r\nret = regmap_write(map, MT9V032_WINDOW_WIDTH, crop->width);\r\nif (ret < 0)\r\nreturn ret;\r\nret = regmap_write(map, MT9V032_WINDOW_HEIGHT, crop->height);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mt9v032_update_hblank(mt9v032);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn regmap_update_bits(map, MT9V032_CHIP_CONTROL, mode, mode);\r\n}\r\nstatic int mt9v032_enum_mbus_code(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nif (code->index > 0)\r\nreturn -EINVAL;\r\ncode->code = MEDIA_BUS_FMT_SGRBG10_1X10;\r\nreturn 0;\r\n}\r\nstatic int mt9v032_enum_frame_size(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_frame_size_enum *fse)\r\n{\r\nif (fse->index >= 3 || fse->code != MEDIA_BUS_FMT_SGRBG10_1X10)\r\nreturn -EINVAL;\r\nfse->min_width = MT9V032_WINDOW_WIDTH_DEF / (1 << fse->index);\r\nfse->max_width = fse->min_width;\r\nfse->min_height = MT9V032_WINDOW_HEIGHT_DEF / (1 << fse->index);\r\nfse->max_height = fse->min_height;\r\nreturn 0;\r\n}\r\nstatic int mt9v032_get_format(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *format)\r\n{\r\nstruct mt9v032 *mt9v032 = to_mt9v032(subdev);\r\nformat->format = *__mt9v032_get_pad_format(mt9v032, cfg, format->pad,\r\nformat->which);\r\nreturn 0;\r\n}\r\nstatic void mt9v032_configure_pixel_rate(struct mt9v032 *mt9v032)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&mt9v032->subdev);\r\nint ret;\r\nret = v4l2_ctrl_s_ctrl_int64(mt9v032->pixel_rate,\r\nmt9v032->sysclk / mt9v032->hratio);\r\nif (ret < 0)\r\ndev_warn(&client->dev, "failed to set pixel rate (%d)\n", ret);\r\n}\r\nstatic unsigned int mt9v032_calc_ratio(unsigned int input, unsigned int output)\r\n{\r\nif (output * 3 > input * 2)\r\nreturn 1;\r\nif (output * 3 > input)\r\nreturn 2;\r\nreturn 4;\r\n}\r\nstatic int mt9v032_set_format(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *format)\r\n{\r\nstruct mt9v032 *mt9v032 = to_mt9v032(subdev);\r\nstruct v4l2_mbus_framefmt *__format;\r\nstruct v4l2_rect *__crop;\r\nunsigned int width;\r\nunsigned int height;\r\nunsigned int hratio;\r\nunsigned int vratio;\r\n__crop = __mt9v032_get_pad_crop(mt9v032, cfg, format->pad,\r\nformat->which);\r\nwidth = clamp(ALIGN(format->format.width, 2),\r\nmax_t(unsigned int, __crop->width / 4,\r\nMT9V032_WINDOW_WIDTH_MIN),\r\n__crop->width);\r\nheight = clamp(ALIGN(format->format.height, 2),\r\nmax_t(unsigned int, __crop->height / 4,\r\nMT9V032_WINDOW_HEIGHT_MIN),\r\n__crop->height);\r\nhratio = mt9v032_calc_ratio(__crop->width, width);\r\nvratio = mt9v032_calc_ratio(__crop->height, height);\r\n__format = __mt9v032_get_pad_format(mt9v032, cfg, format->pad,\r\nformat->which);\r\n__format->width = __crop->width / hratio;\r\n__format->height = __crop->height / vratio;\r\nif (format->which == V4L2_SUBDEV_FORMAT_ACTIVE) {\r\nmt9v032->hratio = hratio;\r\nmt9v032->vratio = vratio;\r\nmt9v032_configure_pixel_rate(mt9v032);\r\n}\r\nformat->format = *__format;\r\nreturn 0;\r\n}\r\nstatic int mt9v032_get_selection(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_selection *sel)\r\n{\r\nstruct mt9v032 *mt9v032 = to_mt9v032(subdev);\r\nif (sel->target != V4L2_SEL_TGT_CROP)\r\nreturn -EINVAL;\r\nsel->r = *__mt9v032_get_pad_crop(mt9v032, cfg, sel->pad, sel->which);\r\nreturn 0;\r\n}\r\nstatic int mt9v032_set_selection(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_selection *sel)\r\n{\r\nstruct mt9v032 *mt9v032 = to_mt9v032(subdev);\r\nstruct v4l2_mbus_framefmt *__format;\r\nstruct v4l2_rect *__crop;\r\nstruct v4l2_rect rect;\r\nif (sel->target != V4L2_SEL_TGT_CROP)\r\nreturn -EINVAL;\r\nrect.left = clamp(ALIGN(sel->r.left + 1, 2) - 1,\r\nMT9V032_COLUMN_START_MIN,\r\nMT9V032_COLUMN_START_MAX);\r\nrect.top = clamp(ALIGN(sel->r.top + 1, 2) - 1,\r\nMT9V032_ROW_START_MIN,\r\nMT9V032_ROW_START_MAX);\r\nrect.width = clamp_t(unsigned int, ALIGN(sel->r.width, 2),\r\nMT9V032_WINDOW_WIDTH_MIN,\r\nMT9V032_WINDOW_WIDTH_MAX);\r\nrect.height = clamp_t(unsigned int, ALIGN(sel->r.height, 2),\r\nMT9V032_WINDOW_HEIGHT_MIN,\r\nMT9V032_WINDOW_HEIGHT_MAX);\r\nrect.width = min_t(unsigned int,\r\nrect.width, MT9V032_PIXEL_ARRAY_WIDTH - rect.left);\r\nrect.height = min_t(unsigned int,\r\nrect.height, MT9V032_PIXEL_ARRAY_HEIGHT - rect.top);\r\n__crop = __mt9v032_get_pad_crop(mt9v032, cfg, sel->pad, sel->which);\r\nif (rect.width != __crop->width || rect.height != __crop->height) {\r\n__format = __mt9v032_get_pad_format(mt9v032, cfg, sel->pad,\r\nsel->which);\r\n__format->width = rect.width;\r\n__format->height = rect.height;\r\nif (sel->which == V4L2_SUBDEV_FORMAT_ACTIVE) {\r\nmt9v032->hratio = 1;\r\nmt9v032->vratio = 1;\r\nmt9v032_configure_pixel_rate(mt9v032);\r\n}\r\n}\r\n*__crop = rect;\r\nsel->r = rect;\r\nreturn 0;\r\n}\r\nstatic int mt9v032_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct mt9v032 *mt9v032 =\r\ncontainer_of(ctrl->handler, struct mt9v032, ctrls);\r\nstruct regmap *map = mt9v032->regmap;\r\nu32 freq;\r\nu16 data;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUTOGAIN:\r\nreturn mt9v032_update_aec_agc(mt9v032, MT9V032_AGC_ENABLE,\r\nctrl->val);\r\ncase V4L2_CID_GAIN:\r\nreturn regmap_write(map, MT9V032_ANALOG_GAIN, ctrl->val);\r\ncase V4L2_CID_EXPOSURE_AUTO:\r\nreturn mt9v032_update_aec_agc(mt9v032, MT9V032_AEC_ENABLE,\r\n!ctrl->val);\r\ncase V4L2_CID_EXPOSURE:\r\nreturn regmap_write(map, MT9V032_TOTAL_SHUTTER_WIDTH,\r\nctrl->val);\r\ncase V4L2_CID_HBLANK:\r\nmt9v032->hblank = ctrl->val;\r\nreturn mt9v032_update_hblank(mt9v032);\r\ncase V4L2_CID_VBLANK:\r\nreturn regmap_write(map, MT9V032_VERTICAL_BLANKING,\r\nctrl->val);\r\ncase V4L2_CID_PIXEL_RATE:\r\ncase V4L2_CID_LINK_FREQ:\r\nif (mt9v032->link_freq == NULL)\r\nbreak;\r\nfreq = mt9v032->pdata->link_freqs[mt9v032->link_freq->val];\r\n*mt9v032->pixel_rate->p_new.p_s64 = freq;\r\nmt9v032->sysclk = freq;\r\nbreak;\r\ncase V4L2_CID_TEST_PATTERN:\r\nswitch (mt9v032->test_pattern->val) {\r\ncase 0:\r\ndata = 0;\r\nbreak;\r\ncase 1:\r\ndata = MT9V032_TEST_PATTERN_GRAY_VERTICAL\r\n| MT9V032_TEST_PATTERN_ENABLE;\r\nbreak;\r\ncase 2:\r\ndata = MT9V032_TEST_PATTERN_GRAY_HORIZONTAL\r\n| MT9V032_TEST_PATTERN_ENABLE;\r\nbreak;\r\ncase 3:\r\ndata = MT9V032_TEST_PATTERN_GRAY_DIAGONAL\r\n| MT9V032_TEST_PATTERN_ENABLE;\r\nbreak;\r\ndefault:\r\ndata = (mt9v032->test_pattern_color->val <<\r\nMT9V032_TEST_PATTERN_DATA_SHIFT)\r\n| MT9V032_TEST_PATTERN_USE_DATA\r\n| MT9V032_TEST_PATTERN_ENABLE\r\n| MT9V032_TEST_PATTERN_FLIP;\r\nbreak;\r\n}\r\nreturn regmap_write(map, MT9V032_TEST_PATTERN, data);\r\ncase V4L2_CID_AEGC_DESIRED_BIN:\r\nreturn regmap_write(map, MT9V032_AEGC_DESIRED_BIN, ctrl->val);\r\ncase V4L2_CID_AEC_LPF:\r\nreturn regmap_write(map, MT9V032_AEC_LPF, ctrl->val);\r\ncase V4L2_CID_AGC_LPF:\r\nreturn regmap_write(map, MT9V032_AGC_LPF, ctrl->val);\r\ncase V4L2_CID_AEC_UPDATE_INTERVAL:\r\nreturn regmap_write(map, MT9V032_AEC_UPDATE_FREQUENCY,\r\nctrl->val);\r\ncase V4L2_CID_AGC_UPDATE_INTERVAL:\r\nreturn regmap_write(map, MT9V032_AGC_UPDATE_FREQUENCY,\r\nctrl->val);\r\ncase V4L2_CID_AEC_MAX_SHUTTER_WIDTH:\r\nreturn regmap_write(map,\r\nmt9v032->model->data->aec_max_shutter_reg,\r\nctrl->val);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mt9v032_set_power(struct v4l2_subdev *subdev, int on)\r\n{\r\nstruct mt9v032 *mt9v032 = to_mt9v032(subdev);\r\nint ret = 0;\r\nmutex_lock(&mt9v032->power_lock);\r\nif (mt9v032->power_count == !on) {\r\nret = __mt9v032_set_power(mt9v032, !!on);\r\nif (ret < 0)\r\ngoto done;\r\n}\r\nmt9v032->power_count += on ? 1 : -1;\r\nWARN_ON(mt9v032->power_count < 0);\r\ndone:\r\nmutex_unlock(&mt9v032->power_lock);\r\nreturn ret;\r\n}\r\nstatic int mt9v032_registered(struct v4l2_subdev *subdev)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(subdev);\r\nstruct mt9v032 *mt9v032 = to_mt9v032(subdev);\r\nunsigned int i;\r\nu32 version;\r\nint ret;\r\ndev_info(&client->dev, "Probing MT9V032 at address 0x%02x\n",\r\nclient->addr);\r\nret = mt9v032_power_on(mt9v032);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "MT9V032 power up failed\n");\r\nreturn ret;\r\n}\r\nret = regmap_read(mt9v032->regmap, MT9V032_CHIP_VERSION, &version);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Failed reading chip version\n");\r\nreturn ret;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(mt9v032_versions); ++i) {\r\nif (mt9v032_versions[i].version == version) {\r\nmt9v032->version = &mt9v032_versions[i];\r\nbreak;\r\n}\r\n}\r\nif (mt9v032->version == NULL) {\r\ndev_err(&client->dev, "Unsupported chip version 0x%04x\n",\r\nversion);\r\nreturn -ENODEV;\r\n}\r\nmt9v032_power_off(mt9v032);\r\ndev_info(&client->dev, "%s detected at address 0x%02x\n",\r\nmt9v032->version->name, client->addr);\r\nmt9v032_configure_pixel_rate(mt9v032);\r\nreturn ret;\r\n}\r\nstatic int mt9v032_open(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)\r\n{\r\nstruct mt9v032 *mt9v032 = to_mt9v032(subdev);\r\nstruct v4l2_mbus_framefmt *format;\r\nstruct v4l2_rect *crop;\r\ncrop = v4l2_subdev_get_try_crop(subdev, fh->pad, 0);\r\ncrop->left = MT9V032_COLUMN_START_DEF;\r\ncrop->top = MT9V032_ROW_START_DEF;\r\ncrop->width = MT9V032_WINDOW_WIDTH_DEF;\r\ncrop->height = MT9V032_WINDOW_HEIGHT_DEF;\r\nformat = v4l2_subdev_get_try_format(subdev, fh->pad, 0);\r\nif (mt9v032->model->color)\r\nformat->code = MEDIA_BUS_FMT_SGRBG10_1X10;\r\nelse\r\nformat->code = MEDIA_BUS_FMT_Y10_1X10;\r\nformat->width = MT9V032_WINDOW_WIDTH_DEF;\r\nformat->height = MT9V032_WINDOW_HEIGHT_DEF;\r\nformat->field = V4L2_FIELD_NONE;\r\nformat->colorspace = V4L2_COLORSPACE_SRGB;\r\nreturn mt9v032_set_power(subdev, 1);\r\n}\r\nstatic int mt9v032_close(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)\r\n{\r\nreturn mt9v032_set_power(subdev, 0);\r\n}\r\nstatic struct mt9v032_platform_data *\r\nmt9v032_get_pdata(struct i2c_client *client)\r\n{\r\nstruct mt9v032_platform_data *pdata = NULL;\r\nstruct v4l2_fwnode_endpoint endpoint;\r\nstruct device_node *np;\r\nstruct property *prop;\r\nif (!IS_ENABLED(CONFIG_OF) || !client->dev.of_node)\r\nreturn client->dev.platform_data;\r\nnp = of_graph_get_next_endpoint(client->dev.of_node, NULL);\r\nif (!np)\r\nreturn NULL;\r\nif (v4l2_fwnode_endpoint_parse(of_fwnode_handle(np), &endpoint) < 0)\r\ngoto done;\r\npdata = devm_kzalloc(&client->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\ngoto done;\r\nprop = of_find_property(np, "link-frequencies", NULL);\r\nif (prop) {\r\nu64 *link_freqs;\r\nsize_t size = prop->length / sizeof(*link_freqs);\r\nlink_freqs = devm_kcalloc(&client->dev, size,\r\nsizeof(*link_freqs), GFP_KERNEL);\r\nif (!link_freqs)\r\ngoto done;\r\nif (of_property_read_u64_array(np, "link-frequencies",\r\nlink_freqs, size) < 0)\r\ngoto done;\r\npdata->link_freqs = link_freqs;\r\npdata->link_def_freq = link_freqs[0];\r\n}\r\npdata->clk_pol = !!(endpoint.bus.parallel.flags &\r\nV4L2_MBUS_PCLK_SAMPLE_RISING);\r\ndone:\r\nof_node_put(np);\r\nreturn pdata;\r\n}\r\nstatic int mt9v032_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *did)\r\n{\r\nstruct mt9v032_platform_data *pdata = mt9v032_get_pdata(client);\r\nstruct mt9v032 *mt9v032;\r\nunsigned int i;\r\nint ret;\r\nmt9v032 = devm_kzalloc(&client->dev, sizeof(*mt9v032), GFP_KERNEL);\r\nif (!mt9v032)\r\nreturn -ENOMEM;\r\nmt9v032->regmap = devm_regmap_init_i2c(client, &mt9v032_regmap_config);\r\nif (IS_ERR(mt9v032->regmap))\r\nreturn PTR_ERR(mt9v032->regmap);\r\nmt9v032->clk = devm_clk_get(&client->dev, NULL);\r\nif (IS_ERR(mt9v032->clk))\r\nreturn PTR_ERR(mt9v032->clk);\r\nmt9v032->reset_gpio = devm_gpiod_get_optional(&client->dev, "reset",\r\nGPIOD_OUT_HIGH);\r\nif (IS_ERR(mt9v032->reset_gpio))\r\nreturn PTR_ERR(mt9v032->reset_gpio);\r\nmt9v032->standby_gpio = devm_gpiod_get_optional(&client->dev, "standby",\r\nGPIOD_OUT_LOW);\r\nif (IS_ERR(mt9v032->standby_gpio))\r\nreturn PTR_ERR(mt9v032->standby_gpio);\r\nmutex_init(&mt9v032->power_lock);\r\nmt9v032->pdata = pdata;\r\nmt9v032->model = (const void *)did->driver_data;\r\nv4l2_ctrl_handler_init(&mt9v032->ctrls, 11 +\r\nARRAY_SIZE(mt9v032_aegc_controls));\r\nv4l2_ctrl_new_std(&mt9v032->ctrls, &mt9v032_ctrl_ops,\r\nV4L2_CID_AUTOGAIN, 0, 1, 1, 1);\r\nv4l2_ctrl_new_std(&mt9v032->ctrls, &mt9v032_ctrl_ops,\r\nV4L2_CID_GAIN, MT9V032_ANALOG_GAIN_MIN,\r\nMT9V032_ANALOG_GAIN_MAX, 1, MT9V032_ANALOG_GAIN_DEF);\r\nv4l2_ctrl_new_std_menu(&mt9v032->ctrls, &mt9v032_ctrl_ops,\r\nV4L2_CID_EXPOSURE_AUTO, V4L2_EXPOSURE_MANUAL, 0,\r\nV4L2_EXPOSURE_AUTO);\r\nv4l2_ctrl_new_std(&mt9v032->ctrls, &mt9v032_ctrl_ops,\r\nV4L2_CID_EXPOSURE, mt9v032->model->data->min_shutter,\r\nmt9v032->model->data->max_shutter, 1,\r\nMT9V032_TOTAL_SHUTTER_WIDTH_DEF);\r\nv4l2_ctrl_new_std(&mt9v032->ctrls, &mt9v032_ctrl_ops,\r\nV4L2_CID_HBLANK, mt9v032->model->data->min_hblank,\r\nMT9V032_HORIZONTAL_BLANKING_MAX, 1,\r\nMT9V032_HORIZONTAL_BLANKING_DEF);\r\nv4l2_ctrl_new_std(&mt9v032->ctrls, &mt9v032_ctrl_ops,\r\nV4L2_CID_VBLANK, mt9v032->model->data->min_vblank,\r\nmt9v032->model->data->max_vblank, 1,\r\nMT9V032_VERTICAL_BLANKING_DEF);\r\nmt9v032->test_pattern = v4l2_ctrl_new_std_menu_items(&mt9v032->ctrls,\r\n&mt9v032_ctrl_ops, V4L2_CID_TEST_PATTERN,\r\nARRAY_SIZE(mt9v032_test_pattern_menu) - 1, 0, 0,\r\nmt9v032_test_pattern_menu);\r\nmt9v032->test_pattern_color = v4l2_ctrl_new_custom(&mt9v032->ctrls,\r\n&mt9v032_test_pattern_color, NULL);\r\nv4l2_ctrl_new_custom(&mt9v032->ctrls,\r\nmt9v032->model->data->aec_max_shutter_v4l2_ctrl,\r\nNULL);\r\nfor (i = 0; i < ARRAY_SIZE(mt9v032_aegc_controls); ++i)\r\nv4l2_ctrl_new_custom(&mt9v032->ctrls, &mt9v032_aegc_controls[i],\r\nNULL);\r\nv4l2_ctrl_cluster(2, &mt9v032->test_pattern);\r\nmt9v032->pixel_rate =\r\nv4l2_ctrl_new_std(&mt9v032->ctrls, &mt9v032_ctrl_ops,\r\nV4L2_CID_PIXEL_RATE, 1, INT_MAX, 1, 1);\r\nif (pdata && pdata->link_freqs) {\r\nunsigned int def = 0;\r\nfor (i = 0; pdata->link_freqs[i]; ++i) {\r\nif (pdata->link_freqs[i] == pdata->link_def_freq)\r\ndef = i;\r\n}\r\nmt9v032->link_freq =\r\nv4l2_ctrl_new_int_menu(&mt9v032->ctrls,\r\n&mt9v032_ctrl_ops,\r\nV4L2_CID_LINK_FREQ, i - 1, def,\r\npdata->link_freqs);\r\nv4l2_ctrl_cluster(2, &mt9v032->link_freq);\r\n}\r\nmt9v032->subdev.ctrl_handler = &mt9v032->ctrls;\r\nif (mt9v032->ctrls.error) {\r\ndev_err(&client->dev, "control initialization error %d\n",\r\nmt9v032->ctrls.error);\r\nret = mt9v032->ctrls.error;\r\ngoto err;\r\n}\r\nmt9v032->crop.left = MT9V032_COLUMN_START_DEF;\r\nmt9v032->crop.top = MT9V032_ROW_START_DEF;\r\nmt9v032->crop.width = MT9V032_WINDOW_WIDTH_DEF;\r\nmt9v032->crop.height = MT9V032_WINDOW_HEIGHT_DEF;\r\nif (mt9v032->model->color)\r\nmt9v032->format.code = MEDIA_BUS_FMT_SGRBG10_1X10;\r\nelse\r\nmt9v032->format.code = MEDIA_BUS_FMT_Y10_1X10;\r\nmt9v032->format.width = MT9V032_WINDOW_WIDTH_DEF;\r\nmt9v032->format.height = MT9V032_WINDOW_HEIGHT_DEF;\r\nmt9v032->format.field = V4L2_FIELD_NONE;\r\nmt9v032->format.colorspace = V4L2_COLORSPACE_SRGB;\r\nmt9v032->hratio = 1;\r\nmt9v032->vratio = 1;\r\nmt9v032->aec_agc = MT9V032_AEC_ENABLE | MT9V032_AGC_ENABLE;\r\nmt9v032->hblank = MT9V032_HORIZONTAL_BLANKING_DEF;\r\nmt9v032->sysclk = MT9V032_SYSCLK_FREQ_DEF;\r\nv4l2_i2c_subdev_init(&mt9v032->subdev, client, &mt9v032_subdev_ops);\r\nmt9v032->subdev.internal_ops = &mt9v032_subdev_internal_ops;\r\nmt9v032->subdev.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\nmt9v032->pad.flags = MEDIA_PAD_FL_SOURCE;\r\nret = media_entity_pads_init(&mt9v032->subdev.entity, 1, &mt9v032->pad);\r\nif (ret < 0)\r\ngoto err;\r\nmt9v032->subdev.dev = &client->dev;\r\nret = v4l2_async_register_subdev(&mt9v032->subdev);\r\nif (ret < 0)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nmedia_entity_cleanup(&mt9v032->subdev.entity);\r\nv4l2_ctrl_handler_free(&mt9v032->ctrls);\r\nreturn ret;\r\n}\r\nstatic int mt9v032_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *subdev = i2c_get_clientdata(client);\r\nstruct mt9v032 *mt9v032 = to_mt9v032(subdev);\r\nv4l2_async_unregister_subdev(subdev);\r\nv4l2_ctrl_handler_free(&mt9v032->ctrls);\r\nmedia_entity_cleanup(&subdev->entity);\r\nreturn 0;\r\n}
