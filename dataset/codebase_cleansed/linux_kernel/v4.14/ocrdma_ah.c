static u16 ocrdma_hdr_type_to_proto_num(int devid, u8 hdr_type)\r\n{\r\nswitch (hdr_type) {\r\ncase OCRDMA_L3_TYPE_IB_GRH:\r\nreturn (u16)ETH_P_IBOE;\r\ncase OCRDMA_L3_TYPE_IPV4:\r\nreturn (u16)0x0800;\r\ncase OCRDMA_L3_TYPE_IPV6:\r\nreturn (u16)0x86dd;\r\ndefault:\r\npr_err("ocrdma%d: Invalid network header\n", devid);\r\nreturn 0;\r\n}\r\n}\r\nstatic inline int set_av_attr(struct ocrdma_dev *dev, struct ocrdma_ah *ah,\r\nstruct rdma_ah_attr *attr, union ib_gid *sgid,\r\nint pdid, bool *isvlan, u16 vlan_tag)\r\n{\r\nint status;\r\nstruct ocrdma_eth_vlan eth;\r\nstruct ocrdma_grh grh;\r\nint eth_sz;\r\nu16 proto_num = 0;\r\nu8 nxthdr = 0x11;\r\nstruct iphdr ipv4;\r\nconst struct ib_global_route *ib_grh;\r\nunion {\r\nstruct sockaddr _sockaddr;\r\nstruct sockaddr_in _sockaddr_in;\r\nstruct sockaddr_in6 _sockaddr_in6;\r\n} sgid_addr, dgid_addr;\r\nmemset(&eth, 0, sizeof(eth));\r\nmemset(&grh, 0, sizeof(grh));\r\nproto_num = ocrdma_hdr_type_to_proto_num(dev->id, ah->hdr_type);\r\nif (!proto_num)\r\nreturn -EINVAL;\r\nnxthdr = (proto_num == ETH_P_IBOE) ? 0x1b : 0x11;\r\nif (!vlan_tag || (vlan_tag > 0xFFF))\r\nvlan_tag = dev->pvid;\r\nif (vlan_tag || dev->pfc_state) {\r\nif (!vlan_tag) {\r\npr_err("ocrdma%d:Using VLAN with PFC is recommended\n",\r\ndev->id);\r\npr_err("ocrdma%d:Using VLAN 0 for this connection\n",\r\ndev->id);\r\n}\r\neth.eth_type = cpu_to_be16(0x8100);\r\neth.roce_eth_type = cpu_to_be16(proto_num);\r\nvlan_tag |= (dev->sl & 0x07) << OCRDMA_VID_PCP_SHIFT;\r\neth.vlan_tag = cpu_to_be16(vlan_tag);\r\neth_sz = sizeof(struct ocrdma_eth_vlan);\r\n*isvlan = true;\r\n} else {\r\neth.eth_type = cpu_to_be16(proto_num);\r\neth_sz = sizeof(struct ocrdma_eth_basic);\r\n}\r\nmemcpy(&eth.smac[0], &dev->nic_info.mac_addr[0], ETH_ALEN);\r\nstatus = ocrdma_resolve_dmac(dev, attr, &eth.dmac[0]);\r\nif (status)\r\nreturn status;\r\nib_grh = rdma_ah_read_grh(attr);\r\nah->sgid_index = ib_grh->sgid_index;\r\nmemcpy(&ah->av->eth_hdr, &eth, eth_sz);\r\nif (ah->hdr_type == RDMA_NETWORK_IPV4) {\r\n*((__be16 *)&ipv4) = htons((4 << 12) | (5 << 8) |\r\nib_grh->traffic_class);\r\nipv4.id = cpu_to_be16(pdid);\r\nipv4.frag_off = htons(IP_DF);\r\nipv4.tot_len = htons(0);\r\nipv4.ttl = ib_grh->hop_limit;\r\nipv4.protocol = nxthdr;\r\nrdma_gid2ip(&sgid_addr._sockaddr, sgid);\r\nipv4.saddr = sgid_addr._sockaddr_in.sin_addr.s_addr;\r\nrdma_gid2ip(&dgid_addr._sockaddr, &ib_grh->dgid);\r\nipv4.daddr = dgid_addr._sockaddr_in.sin_addr.s_addr;\r\nmemcpy((u8 *)ah->av + eth_sz, &ipv4, sizeof(struct iphdr));\r\n} else {\r\nmemcpy(&grh.sgid[0], sgid->raw, sizeof(union ib_gid));\r\ngrh.tclass_flow = cpu_to_be32((6 << 28) |\r\n(ib_grh->traffic_class << 24) |\r\nib_grh->flow_label);\r\nmemcpy(&grh.dgid[0], ib_grh->dgid.raw,\r\nsizeof(ib_grh->dgid.raw));\r\ngrh.pdid_hoplimit = cpu_to_be32((pdid << 16) |\r\n(nxthdr << 8) |\r\nib_grh->hop_limit);\r\nmemcpy((u8 *)ah->av + eth_sz, &grh, sizeof(struct ocrdma_grh));\r\n}\r\nif (*isvlan)\r\nah->av->valid |= OCRDMA_AV_VLAN_VALID;\r\nah->av->valid = cpu_to_le32(ah->av->valid);\r\nreturn status;\r\n}\r\nstruct ib_ah *ocrdma_create_ah(struct ib_pd *ibpd, struct rdma_ah_attr *attr,\r\nstruct ib_udata *udata)\r\n{\r\nu32 *ahid_addr;\r\nint status;\r\nstruct ocrdma_ah *ah;\r\nbool isvlan = false;\r\nu16 vlan_tag = 0xffff;\r\nstruct ib_gid_attr sgid_attr;\r\nstruct ocrdma_pd *pd = get_ocrdma_pd(ibpd);\r\nstruct ocrdma_dev *dev = get_ocrdma_dev(ibpd->device);\r\nconst struct ib_global_route *grh;\r\nunion ib_gid sgid;\r\nif ((attr->type != RDMA_AH_ATTR_TYPE_ROCE) ||\r\n!(rdma_ah_get_ah_flags(attr) & IB_AH_GRH))\r\nreturn ERR_PTR(-EINVAL);\r\ngrh = rdma_ah_read_grh(attr);\r\nif (atomic_cmpxchg(&dev->update_sl, 1, 0))\r\nocrdma_init_service_level(dev);\r\nah = kzalloc(sizeof(*ah), GFP_ATOMIC);\r\nif (!ah)\r\nreturn ERR_PTR(-ENOMEM);\r\nstatus = ocrdma_alloc_av(dev, ah);\r\nif (status)\r\ngoto av_err;\r\nstatus = ib_get_cached_gid(&dev->ibdev, 1, grh->sgid_index, &sgid,\r\n&sgid_attr);\r\nif (status) {\r\npr_err("%s(): Failed to query sgid, status = %d\n",\r\n__func__, status);\r\ngoto av_conf_err;\r\n}\r\nif (sgid_attr.ndev) {\r\nif (is_vlan_dev(sgid_attr.ndev))\r\nvlan_tag = vlan_dev_vlan_id(sgid_attr.ndev);\r\ndev_put(sgid_attr.ndev);\r\n}\r\nah->hdr_type = ib_gid_to_network_type(sgid_attr.gid_type, &sgid);\r\nif ((pd->uctx) &&\r\n(!rdma_is_multicast_addr((struct in6_addr *)grh->dgid.raw)) &&\r\n(!rdma_link_local_addr((struct in6_addr *)grh->dgid.raw))) {\r\nstatus = rdma_addr_find_l2_eth_by_grh(&sgid, &grh->dgid,\r\nattr->roce.dmac,\r\n&vlan_tag,\r\n&sgid_attr.ndev->ifindex,\r\nNULL);\r\nif (status) {\r\npr_err("%s(): Failed to resolve dmac from gid."\r\n"status = %d\n", __func__, status);\r\ngoto av_conf_err;\r\n}\r\n}\r\nstatus = set_av_attr(dev, ah, attr, &sgid, pd->id, &isvlan, vlan_tag);\r\nif (status)\r\ngoto av_conf_err;\r\nif ((pd->uctx) && (pd->uctx->ah_tbl.va)) {\r\nahid_addr = pd->uctx->ah_tbl.va + rdma_ah_get_dlid(attr);\r\n*ahid_addr = 0;\r\n*ahid_addr |= ah->id & OCRDMA_AH_ID_MASK;\r\nif (ocrdma_is_udp_encap_supported(dev)) {\r\n*ahid_addr |= ((u32)ah->hdr_type &\r\nOCRDMA_AH_L3_TYPE_MASK) <<\r\nOCRDMA_AH_L3_TYPE_SHIFT;\r\n}\r\nif (isvlan)\r\n*ahid_addr |= (OCRDMA_AH_VLAN_VALID_MASK <<\r\nOCRDMA_AH_VLAN_VALID_SHIFT);\r\n}\r\nreturn &ah->ibah;\r\nav_conf_err:\r\nocrdma_free_av(dev, ah);\r\nav_err:\r\nkfree(ah);\r\nreturn ERR_PTR(status);\r\n}\r\nint ocrdma_destroy_ah(struct ib_ah *ibah)\r\n{\r\nstruct ocrdma_ah *ah = get_ocrdma_ah(ibah);\r\nstruct ocrdma_dev *dev = get_ocrdma_dev(ibah->device);\r\nocrdma_free_av(dev, ah);\r\nkfree(ah);\r\nreturn 0;\r\n}\r\nint ocrdma_query_ah(struct ib_ah *ibah, struct rdma_ah_attr *attr)\r\n{\r\nstruct ocrdma_ah *ah = get_ocrdma_ah(ibah);\r\nstruct ocrdma_av *av = ah->av;\r\nstruct ocrdma_grh *grh;\r\nattr->type = ibah->type;\r\nif (ah->av->valid & OCRDMA_AV_VALID) {\r\ngrh = (struct ocrdma_grh *)((u8 *)ah->av +\r\nsizeof(struct ocrdma_eth_vlan));\r\nrdma_ah_set_sl(attr, be16_to_cpu(av->eth_hdr.vlan_tag) >> 13);\r\n} else {\r\ngrh = (struct ocrdma_grh *)((u8 *)ah->av +\r\nsizeof(struct ocrdma_eth_basic));\r\nrdma_ah_set_sl(attr, 0);\r\n}\r\nrdma_ah_set_grh(attr, NULL,\r\nbe32_to_cpu(grh->tclass_flow) & 0xffffffff,\r\nah->sgid_index,\r\nbe32_to_cpu(grh->pdid_hoplimit) & 0xff,\r\nbe32_to_cpu(grh->tclass_flow) >> 24);\r\nrdma_ah_set_dgid_raw(attr, &grh->dgid[0]);\r\nreturn 0;\r\n}\r\nint ocrdma_modify_ah(struct ib_ah *ibah, struct rdma_ah_attr *attr)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nint ocrdma_process_mad(struct ib_device *ibdev,\r\nint process_mad_flags,\r\nu8 port_num,\r\nconst struct ib_wc *in_wc,\r\nconst struct ib_grh *in_grh,\r\nconst struct ib_mad_hdr *in, size_t in_mad_size,\r\nstruct ib_mad_hdr *out, size_t *out_mad_size,\r\nu16 *out_mad_pkey_index)\r\n{\r\nint status;\r\nstruct ocrdma_dev *dev;\r\nconst struct ib_mad *in_mad = (const struct ib_mad *)in;\r\nstruct ib_mad *out_mad = (struct ib_mad *)out;\r\nif (WARN_ON_ONCE(in_mad_size != sizeof(*in_mad) ||\r\n*out_mad_size != sizeof(*out_mad)))\r\nreturn IB_MAD_RESULT_FAILURE;\r\nswitch (in_mad->mad_hdr.mgmt_class) {\r\ncase IB_MGMT_CLASS_PERF_MGMT:\r\ndev = get_ocrdma_dev(ibdev);\r\nif (!ocrdma_pma_counters(dev, out_mad))\r\nstatus = IB_MAD_RESULT_SUCCESS | IB_MAD_RESULT_REPLY;\r\nelse\r\nstatus = IB_MAD_RESULT_SUCCESS;\r\nbreak;\r\ndefault:\r\nstatus = IB_MAD_RESULT_SUCCESS;\r\nbreak;\r\n}\r\nreturn status;\r\n}
