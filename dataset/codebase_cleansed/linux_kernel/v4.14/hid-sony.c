static inline void sony_schedule_work(struct sony_sc *sc,\r\nenum sony_worker which)\r\n{\r\nswitch (which) {\r\ncase SONY_WORKER_STATE:\r\nif (!sc->defer_initialization)\r\nschedule_work(&sc->state_worker);\r\nbreak;\r\ncase SONY_WORKER_HOTPLUG:\r\nif (sc->hotplug_worker_initialized)\r\nschedule_work(&sc->hotplug_worker);\r\nbreak;\r\n}\r\n}\r\nstatic ssize_t ds4_show_poll_interval(struct device *dev,\r\nstruct device_attribute\r\n*attr, char *buf)\r\n{\r\nstruct hid_device *hdev = to_hid_device(dev);\r\nstruct sony_sc *sc = hid_get_drvdata(hdev);\r\nreturn snprintf(buf, PAGE_SIZE, "%i\n", sc->ds4_bt_poll_interval);\r\n}\r\nstatic ssize_t ds4_store_poll_interval(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct hid_device *hdev = to_hid_device(dev);\r\nstruct sony_sc *sc = hid_get_drvdata(hdev);\r\nunsigned long flags;\r\nu8 interval;\r\nif (kstrtou8(buf, 0, &interval))\r\nreturn -EINVAL;\r\nif (interval > DS4_BT_MAX_POLL_INTERVAL_MS)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&sc->lock, flags);\r\nsc->ds4_bt_poll_interval = interval;\r\nspin_unlock_irqrestore(&sc->lock, flags);\r\nsony_schedule_work(sc, SONY_WORKER_STATE);\r\nreturn count;\r\n}\r\nstatic u8 *motion_fixup(struct hid_device *hdev, u8 *rdesc,\r\nunsigned int *rsize)\r\n{\r\n*rsize = sizeof(motion_rdesc);\r\nreturn motion_rdesc;\r\n}\r\nstatic u8 *ps3remote_fixup(struct hid_device *hdev, u8 *rdesc,\r\nunsigned int *rsize)\r\n{\r\n*rsize = sizeof(ps3remote_rdesc);\r\nreturn ps3remote_rdesc;\r\n}\r\nstatic int ps3remote_mapping(struct hid_device *hdev, struct hid_input *hi,\r\nstruct hid_field *field, struct hid_usage *usage,\r\nunsigned long **bit, int *max)\r\n{\r\nunsigned int key = usage->hid & HID_USAGE;\r\nif ((usage->hid & HID_USAGE_PAGE) != HID_UP_BUTTON)\r\nreturn -1;\r\nswitch (usage->collection_index) {\r\ncase 1:\r\nif (key >= ARRAY_SIZE(ps3remote_keymap_joypad_buttons))\r\nreturn -1;\r\nkey = ps3remote_keymap_joypad_buttons[key];\r\nif (!key)\r\nreturn -1;\r\nbreak;\r\ncase 2:\r\nif (key >= ARRAY_SIZE(ps3remote_keymap_remote_buttons))\r\nreturn -1;\r\nkey = ps3remote_keymap_remote_buttons[key];\r\nif (!key)\r\nreturn -1;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nhid_map_usage_clear(hi, usage, bit, max, EV_KEY, key);\r\nreturn 1;\r\n}\r\nstatic int navigation_mapping(struct hid_device *hdev, struct hid_input *hi,\r\nstruct hid_field *field, struct hid_usage *usage,\r\nunsigned long **bit, int *max)\r\n{\r\nif ((usage->hid & HID_USAGE_PAGE) == HID_UP_BUTTON) {\r\nunsigned int key = usage->hid & HID_USAGE;\r\nif (key >= ARRAY_SIZE(sixaxis_keymap))\r\nreturn -1;\r\nkey = navigation_keymap[key];\r\nif (!key)\r\nreturn -1;\r\nhid_map_usage_clear(hi, usage, bit, max, EV_KEY, key);\r\nreturn 1;\r\n} else if (usage->hid == HID_GD_POINTER) {\r\nswitch (usage->usage_index) {\r\ncase 8:\r\nusage->hid = HID_GD_Z;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nhid_map_usage_clear(hi, usage, bit, max, EV_ABS, usage->hid & 0xf);\r\nreturn 1;\r\n} else if ((usage->hid & HID_USAGE_PAGE) == HID_UP_GENDESK) {\r\nunsigned int abs = usage->hid & HID_USAGE;\r\nif (abs >= ARRAY_SIZE(navigation_absmap))\r\nreturn -1;\r\nabs = navigation_absmap[abs];\r\nhid_map_usage_clear(hi, usage, bit, max, EV_ABS, abs);\r\nreturn 1;\r\n}\r\nreturn -1;\r\n}\r\nstatic int sixaxis_mapping(struct hid_device *hdev, struct hid_input *hi,\r\nstruct hid_field *field, struct hid_usage *usage,\r\nunsigned long **bit, int *max)\r\n{\r\nif ((usage->hid & HID_USAGE_PAGE) == HID_UP_BUTTON) {\r\nunsigned int key = usage->hid & HID_USAGE;\r\nif (key >= ARRAY_SIZE(sixaxis_keymap))\r\nreturn -1;\r\nkey = sixaxis_keymap[key];\r\nhid_map_usage_clear(hi, usage, bit, max, EV_KEY, key);\r\nreturn 1;\r\n} else if (usage->hid == HID_GD_POINTER) {\r\nswitch (usage->usage_index) {\r\ncase 8:\r\nusage->hid = HID_GD_Z;\r\nbreak;\r\ncase 9:\r\nusage->hid = HID_GD_RZ;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nhid_map_usage_clear(hi, usage, bit, max, EV_ABS, usage->hid & 0xf);\r\nreturn 1;\r\n} else if ((usage->hid & HID_USAGE_PAGE) == HID_UP_GENDESK) {\r\nunsigned int abs = usage->hid & HID_USAGE;\r\nif (abs >= ARRAY_SIZE(sixaxis_absmap))\r\nreturn -1;\r\nabs = sixaxis_absmap[abs];\r\nhid_map_usage_clear(hi, usage, bit, max, EV_ABS, abs);\r\nreturn 1;\r\n}\r\nreturn -1;\r\n}\r\nstatic int ds4_mapping(struct hid_device *hdev, struct hid_input *hi,\r\nstruct hid_field *field, struct hid_usage *usage,\r\nunsigned long **bit, int *max)\r\n{\r\nif ((usage->hid & HID_USAGE_PAGE) == HID_UP_BUTTON) {\r\nunsigned int key = usage->hid & HID_USAGE;\r\nif (key >= ARRAY_SIZE(ds4_keymap))\r\nreturn -1;\r\nkey = ds4_keymap[key];\r\nhid_map_usage_clear(hi, usage, bit, max, EV_KEY, key);\r\nreturn 1;\r\n} else if ((usage->hid & HID_USAGE_PAGE) == HID_UP_GENDESK) {\r\nunsigned int abs = usage->hid & HID_USAGE;\r\nif (usage->hid == HID_GD_HATSWITCH)\r\nreturn 0;\r\nif (abs >= ARRAY_SIZE(ds4_absmap))\r\nreturn -1;\r\nabs = ds4_absmap[abs];\r\nhid_map_usage_clear(hi, usage, bit, max, EV_ABS, abs);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic u8 *sony_report_fixup(struct hid_device *hdev, u8 *rdesc,\r\nunsigned int *rsize)\r\n{\r\nstruct sony_sc *sc = hid_get_drvdata(hdev);\r\nif (sc->quirks & (SINO_LITE_CONTROLLER | FUTUREMAX_DANCE_MAT))\r\nreturn rdesc;\r\nif ((sc->quirks & VAIO_RDESC_CONSTANT) && *rsize >= 56 &&\r\nrdesc[2] == 0x09 && rdesc[3] == 0x02 &&\r\nrdesc[54] == 0x81 && rdesc[55] == 0x07) {\r\nhid_info(hdev, "Fixing up Sony RF Receiver report descriptor\n");\r\nrdesc[55] = 0x06;\r\n}\r\nif (sc->quirks & MOTION_CONTROLLER)\r\nreturn motion_fixup(hdev, rdesc, rsize);\r\nif (sc->quirks & PS3REMOTE)\r\nreturn ps3remote_fixup(hdev, rdesc, rsize);\r\nreturn rdesc;\r\n}\r\nstatic void sixaxis_parse_report(struct sony_sc *sc, u8 *rd, int size)\r\n{\r\nstatic const u8 sixaxis_battery_capacity[] = { 0, 1, 25, 50, 75, 100 };\r\nunsigned long flags;\r\nint offset;\r\nu8 cable_state, battery_capacity, battery_charging;\r\noffset = (sc->quirks & MOTION_CONTROLLER) ? 12 : 30;\r\nif (rd[offset] >= 0xee) {\r\nbattery_capacity = 100;\r\nbattery_charging = !(rd[offset] & 0x01);\r\ncable_state = 1;\r\n} else {\r\nu8 index = rd[offset] <= 5 ? rd[offset] : 5;\r\nbattery_capacity = sixaxis_battery_capacity[index];\r\nbattery_charging = 0;\r\ncable_state = 0;\r\n}\r\nspin_lock_irqsave(&sc->lock, flags);\r\nsc->cable_state = cable_state;\r\nsc->battery_capacity = battery_capacity;\r\nsc->battery_charging = battery_charging;\r\nspin_unlock_irqrestore(&sc->lock, flags);\r\nif (sc->quirks & SIXAXIS_CONTROLLER) {\r\nint val;\r\noffset = SIXAXIS_INPUT_REPORT_ACC_X_OFFSET;\r\nval = ((rd[offset+1] << 8) | rd[offset]) - 511;\r\ninput_report_abs(sc->sensor_dev, ABS_X, val);\r\nval = 511 - ((rd[offset+5] << 8) | rd[offset+4]);\r\ninput_report_abs(sc->sensor_dev, ABS_Y, val);\r\nval = 511 - ((rd[offset+3] << 8) | rd[offset+2]);\r\ninput_report_abs(sc->sensor_dev, ABS_Z, val);\r\ninput_sync(sc->sensor_dev);\r\n}\r\n}\r\nstatic void dualshock4_parse_report(struct sony_sc *sc, u8 *rd, int size)\r\n{\r\nstruct hid_input *hidinput = list_entry(sc->hdev->inputs.next,\r\nstruct hid_input, list);\r\nstruct input_dev *input_dev = hidinput->input;\r\nunsigned long flags;\r\nint n, m, offset, num_touch_data, max_touch_data;\r\nu8 cable_state, battery_capacity, battery_charging;\r\nu16 timestamp;\r\nint data_offset = (sc->quirks & DUALSHOCK4_CONTROLLER_BT) ? 2 : 0;\r\noffset = data_offset + DS4_INPUT_REPORT_BUTTON_OFFSET;\r\ninput_report_key(sc->touchpad, BTN_LEFT, rd[offset+2] & 0x2);\r\nif (rd[0] == 17) {\r\nint value;\r\noffset = data_offset + DS4_INPUT_REPORT_AXIS_OFFSET;\r\ninput_report_abs(input_dev, ABS_X, rd[offset]);\r\ninput_report_abs(input_dev, ABS_Y, rd[offset+1]);\r\ninput_report_abs(input_dev, ABS_RX, rd[offset+2]);\r\ninput_report_abs(input_dev, ABS_RY, rd[offset+3]);\r\nvalue = rd[offset+4] & 0xf;\r\nif (value > 7)\r\nvalue = 8;\r\ninput_report_abs(input_dev, ABS_HAT0X, ds4_hat_mapping[value].x);\r\ninput_report_abs(input_dev, ABS_HAT0Y, ds4_hat_mapping[value].y);\r\ninput_report_key(input_dev, BTN_WEST, rd[offset+4] & 0x10);\r\ninput_report_key(input_dev, BTN_SOUTH, rd[offset+4] & 0x20);\r\ninput_report_key(input_dev, BTN_EAST, rd[offset+4] & 0x40);\r\ninput_report_key(input_dev, BTN_NORTH, rd[offset+4] & 0x80);\r\ninput_report_key(input_dev, BTN_TL, rd[offset+5] & 0x1);\r\ninput_report_key(input_dev, BTN_TR, rd[offset+5] & 0x2);\r\ninput_report_key(input_dev, BTN_TL2, rd[offset+5] & 0x4);\r\ninput_report_key(input_dev, BTN_TR2, rd[offset+5] & 0x8);\r\ninput_report_key(input_dev, BTN_SELECT, rd[offset+5] & 0x10);\r\ninput_report_key(input_dev, BTN_START, rd[offset+5] & 0x20);\r\ninput_report_key(input_dev, BTN_THUMBL, rd[offset+5] & 0x40);\r\ninput_report_key(input_dev, BTN_THUMBR, rd[offset+5] & 0x80);\r\ninput_report_key(input_dev, BTN_MODE, rd[offset+6] & 0x1);\r\ninput_report_abs(input_dev, ABS_Z, rd[offset+7]);\r\ninput_report_abs(input_dev, ABS_RZ, rd[offset+8]);\r\ninput_sync(input_dev);\r\n}\r\noffset = data_offset + DS4_INPUT_REPORT_TIMESTAMP_OFFSET;\r\ntimestamp = get_unaligned_le16(&rd[offset]);\r\nif (!sc->timestamp_initialized) {\r\nsc->timestamp_us = ((unsigned int)timestamp * 16) / 3;\r\nsc->timestamp_initialized = true;\r\n} else {\r\nu16 delta;\r\nif (sc->prev_timestamp > timestamp)\r\ndelta = (U16_MAX - sc->prev_timestamp + timestamp + 1);\r\nelse\r\ndelta = timestamp - sc->prev_timestamp;\r\nsc->timestamp_us += (delta * 16) / 3;\r\n}\r\nsc->prev_timestamp = timestamp;\r\ninput_event(sc->sensor_dev, EV_MSC, MSC_TIMESTAMP, sc->timestamp_us);\r\noffset = data_offset + DS4_INPUT_REPORT_GYRO_X_OFFSET;\r\nfor (n = 0; n < 6; n++) {\r\nint raw_data = (short)((rd[offset+1] << 8) | rd[offset]);\r\nstruct ds4_calibration_data *calib = &sc->ds4_calib_data[n];\r\nint calib_data = mult_frac(calib->sens_numer,\r\nraw_data - calib->bias,\r\ncalib->sens_denom);\r\ninput_report_abs(sc->sensor_dev, calib->abs_code, calib_data);\r\noffset += 2;\r\n}\r\ninput_sync(sc->sensor_dev);\r\noffset = data_offset + DS4_INPUT_REPORT_BATTERY_OFFSET;\r\ncable_state = (rd[offset] >> 4) & 0x01;\r\nbattery_capacity = rd[offset] & 0x0F;\r\nif (!cable_state || battery_capacity > 10)\r\nbattery_charging = 0;\r\nelse\r\nbattery_charging = 1;\r\nif (!cable_state)\r\nbattery_capacity++;\r\nif (battery_capacity > 10)\r\nbattery_capacity = 10;\r\nbattery_capacity *= 10;\r\nspin_lock_irqsave(&sc->lock, flags);\r\nsc->cable_state = cable_state;\r\nsc->battery_capacity = battery_capacity;\r\nsc->battery_charging = battery_charging;\r\nspin_unlock_irqrestore(&sc->lock, flags);\r\noffset = data_offset + DS4_INPUT_REPORT_TOUCHPAD_OFFSET;\r\nmax_touch_data = (sc->quirks & DUALSHOCK4_CONTROLLER_BT) ? 4 : 3;\r\nif (rd[offset] > 0 && rd[offset] <= max_touch_data)\r\nnum_touch_data = rd[offset];\r\nelse\r\nnum_touch_data = 1;\r\noffset += 1;\r\nfor (m = 0; m < num_touch_data; m++) {\r\noffset += 1;\r\nfor (n = 0; n < 2; n++) {\r\nu16 x, y;\r\nbool active;\r\nx = rd[offset+1] | ((rd[offset+2] & 0xF) << 8);\r\ny = ((rd[offset+2] & 0xF0) >> 4) | (rd[offset+3] << 4);\r\nactive = !(rd[offset] >> 7);\r\ninput_mt_slot(sc->touchpad, n);\r\ninput_mt_report_slot_state(sc->touchpad, MT_TOOL_FINGER, active);\r\nif (active) {\r\ninput_report_abs(sc->touchpad, ABS_MT_POSITION_X, x);\r\ninput_report_abs(sc->touchpad, ABS_MT_POSITION_Y, y);\r\n}\r\noffset += 4;\r\n}\r\ninput_mt_sync_frame(sc->touchpad);\r\ninput_sync(sc->touchpad);\r\n}\r\n}\r\nstatic int sony_raw_event(struct hid_device *hdev, struct hid_report *report,\r\nu8 *rd, int size)\r\n{\r\nstruct sony_sc *sc = hid_get_drvdata(hdev);\r\nif ((sc->quirks & SIXAXIS_CONTROLLER) && rd[0] == 0x01 && size == 49) {\r\nif (rd[1] == 0xff)\r\nreturn -EINVAL;\r\nswap(rd[41], rd[42]);\r\nswap(rd[43], rd[44]);\r\nswap(rd[45], rd[46]);\r\nswap(rd[47], rd[48]);\r\nsixaxis_parse_report(sc, rd, size);\r\n} else if ((sc->quirks & MOTION_CONTROLLER_BT) && rd[0] == 0x01 && size == 49) {\r\nsixaxis_parse_report(sc, rd, size);\r\n} else if ((sc->quirks & NAVIGATION_CONTROLLER) && rd[0] == 0x01 &&\r\nsize == 49) {\r\nsixaxis_parse_report(sc, rd, size);\r\n} else if ((sc->quirks & DUALSHOCK4_CONTROLLER_USB) && rd[0] == 0x01 &&\r\nsize == 64) {\r\ndualshock4_parse_report(sc, rd, size);\r\n} else if (((sc->quirks & DUALSHOCK4_CONTROLLER_BT) && rd[0] == 0x11 &&\r\nsize == 78)) {\r\nu8 bthdr = 0xA1;\r\nu32 crc;\r\nu32 report_crc;\r\ncrc = crc32_le(0xFFFFFFFF, &bthdr, 1);\r\ncrc = ~crc32_le(crc, rd, DS4_INPUT_REPORT_0x11_SIZE-4);\r\nreport_crc = get_unaligned_le32(&rd[DS4_INPUT_REPORT_0x11_SIZE-4]);\r\nif (crc != report_crc) {\r\nhid_dbg(sc->hdev, "DualShock 4 input report's CRC check failed, received crc 0x%0x != 0x%0x\n",\r\nreport_crc, crc);\r\nreturn -EILSEQ;\r\n}\r\ndualshock4_parse_report(sc, rd, size);\r\n} else if ((sc->quirks & DUALSHOCK4_DONGLE) && rd[0] == 0x01 &&\r\nsize == 64) {\r\nunsigned long flags;\r\nenum ds4_dongle_state dongle_state;\r\nbool connected = (rd[31] & 0x04) ? false : true;\r\nspin_lock_irqsave(&sc->lock, flags);\r\ndongle_state = sc->ds4_dongle_state;\r\nspin_unlock_irqrestore(&sc->lock, flags);\r\nif (dongle_state == DONGLE_DISCONNECTED && connected) {\r\nhid_info(sc->hdev, "DualShock 4 USB dongle: controller connected\n");\r\nsony_set_leds(sc);\r\nspin_lock_irqsave(&sc->lock, flags);\r\nsc->ds4_dongle_state = DONGLE_CALIBRATING;\r\nspin_unlock_irqrestore(&sc->lock, flags);\r\nsony_schedule_work(sc, SONY_WORKER_HOTPLUG);\r\nreturn 0;\r\n} else if ((dongle_state == DONGLE_CONNECTED ||\r\ndongle_state == DONGLE_DISABLED) && !connected) {\r\nhid_info(sc->hdev, "DualShock 4 USB dongle: controller disconnected\n");\r\nspin_lock_irqsave(&sc->lock, flags);\r\nsc->ds4_dongle_state = DONGLE_DISCONNECTED;\r\nspin_unlock_irqrestore(&sc->lock, flags);\r\nreturn 0;\r\n} else if (dongle_state == DONGLE_CALIBRATING ||\r\ndongle_state == DONGLE_DISABLED ||\r\ndongle_state == DONGLE_DISCONNECTED) {\r\nreturn 0;\r\n}\r\ndualshock4_parse_report(sc, rd, size);\r\n}\r\nif (sc->defer_initialization) {\r\nsc->defer_initialization = 0;\r\nsony_schedule_work(sc, SONY_WORKER_STATE);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sony_mapping(struct hid_device *hdev, struct hid_input *hi,\r\nstruct hid_field *field, struct hid_usage *usage,\r\nunsigned long **bit, int *max)\r\n{\r\nstruct sony_sc *sc = hid_get_drvdata(hdev);\r\nif (sc->quirks & BUZZ_CONTROLLER) {\r\nunsigned int key = usage->hid & HID_USAGE;\r\nif ((usage->hid & HID_USAGE_PAGE) != HID_UP_BUTTON)\r\nreturn -1;\r\nswitch (usage->collection_index) {\r\ncase 1:\r\nif (key >= ARRAY_SIZE(buzz_keymap))\r\nreturn -1;\r\nkey = buzz_keymap[key];\r\nif (!key)\r\nreturn -1;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nhid_map_usage_clear(hi, usage, bit, max, EV_KEY, key);\r\nreturn 1;\r\n}\r\nif (sc->quirks & PS3REMOTE)\r\nreturn ps3remote_mapping(hdev, hi, field, usage, bit, max);\r\nif (sc->quirks & NAVIGATION_CONTROLLER)\r\nreturn navigation_mapping(hdev, hi, field, usage, bit, max);\r\nif (sc->quirks & SIXAXIS_CONTROLLER)\r\nreturn sixaxis_mapping(hdev, hi, field, usage, bit, max);\r\nif (sc->quirks & DUALSHOCK4_CONTROLLER)\r\nreturn ds4_mapping(hdev, hi, field, usage, bit, max);\r\nreturn 0;\r\n}\r\nstatic int sony_register_touchpad(struct sony_sc *sc, int touch_count,\r\nint w, int h)\r\n{\r\nsize_t name_sz;\r\nchar *name;\r\nint ret;\r\nsc->touchpad = input_allocate_device();\r\nif (!sc->touchpad)\r\nreturn -ENOMEM;\r\ninput_set_drvdata(sc->touchpad, sc);\r\nsc->touchpad->dev.parent = &sc->hdev->dev;\r\nsc->touchpad->phys = sc->hdev->phys;\r\nsc->touchpad->uniq = sc->hdev->uniq;\r\nsc->touchpad->id.bustype = sc->hdev->bus;\r\nsc->touchpad->id.vendor = sc->hdev->vendor;\r\nsc->touchpad->id.product = sc->hdev->product;\r\nsc->touchpad->id.version = sc->hdev->version;\r\nname_sz = strlen(sc->hdev->name) + sizeof(DS4_TOUCHPAD_SUFFIX);\r\nname = kzalloc(name_sz, GFP_KERNEL);\r\nif (!name) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nsnprintf(name, name_sz, "%s" DS4_TOUCHPAD_SUFFIX, sc->hdev->name);\r\nsc->touchpad->name = name;\r\nret = input_mt_init_slots(sc->touchpad, touch_count, INPUT_MT_POINTER);\r\nif (ret < 0)\r\ngoto err;\r\n__set_bit(EV_KEY, sc->touchpad->evbit);\r\n__set_bit(BTN_LEFT, sc->touchpad->keybit);\r\n__set_bit(INPUT_PROP_BUTTONPAD, sc->touchpad->propbit);\r\ninput_set_abs_params(sc->touchpad, ABS_MT_POSITION_X, 0, w, 0, 0);\r\ninput_set_abs_params(sc->touchpad, ABS_MT_POSITION_Y, 0, h, 0, 0);\r\nret = input_register_device(sc->touchpad);\r\nif (ret < 0)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nkfree(sc->touchpad->name);\r\nsc->touchpad->name = NULL;\r\ninput_free_device(sc->touchpad);\r\nsc->touchpad = NULL;\r\nreturn ret;\r\n}\r\nstatic void sony_unregister_touchpad(struct sony_sc *sc)\r\n{\r\nif (!sc->touchpad)\r\nreturn;\r\nkfree(sc->touchpad->name);\r\nsc->touchpad->name = NULL;\r\ninput_unregister_device(sc->touchpad);\r\nsc->touchpad = NULL;\r\n}\r\nstatic int sony_register_sensors(struct sony_sc *sc)\r\n{\r\nsize_t name_sz;\r\nchar *name;\r\nint ret;\r\nint range;\r\nsc->sensor_dev = input_allocate_device();\r\nif (!sc->sensor_dev)\r\nreturn -ENOMEM;\r\ninput_set_drvdata(sc->sensor_dev, sc);\r\nsc->sensor_dev->dev.parent = &sc->hdev->dev;\r\nsc->sensor_dev->phys = sc->hdev->phys;\r\nsc->sensor_dev->uniq = sc->hdev->uniq;\r\nsc->sensor_dev->id.bustype = sc->hdev->bus;\r\nsc->sensor_dev->id.vendor = sc->hdev->vendor;\r\nsc->sensor_dev->id.product = sc->hdev->product;\r\nsc->sensor_dev->id.version = sc->hdev->version;\r\nname_sz = strlen(sc->hdev->name) + sizeof(SENSOR_SUFFIX);\r\nname = kzalloc(name_sz, GFP_KERNEL);\r\nif (!name) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nsnprintf(name, name_sz, "%s" SENSOR_SUFFIX, sc->hdev->name);\r\nsc->sensor_dev->name = name;\r\nif (sc->quirks & SIXAXIS_CONTROLLER) {\r\ninput_set_abs_params(sc->sensor_dev, ABS_X, -512, 511, 4, 0);\r\ninput_set_abs_params(sc->sensor_dev, ABS_Y, -512, 511, 4, 0);\r\ninput_set_abs_params(sc->sensor_dev, ABS_Z, -512, 511, 4, 0);\r\ninput_abs_set_res(sc->sensor_dev, ABS_X, SIXAXIS_ACC_RES_PER_G);\r\ninput_abs_set_res(sc->sensor_dev, ABS_Y, SIXAXIS_ACC_RES_PER_G);\r\ninput_abs_set_res(sc->sensor_dev, ABS_Z, SIXAXIS_ACC_RES_PER_G);\r\n} else if (sc->quirks & DUALSHOCK4_CONTROLLER) {\r\nrange = DS4_ACC_RES_PER_G*4;\r\ninput_set_abs_params(sc->sensor_dev, ABS_X, -range, range, 16, 0);\r\ninput_set_abs_params(sc->sensor_dev, ABS_Y, -range, range, 16, 0);\r\ninput_set_abs_params(sc->sensor_dev, ABS_Z, -range, range, 16, 0);\r\ninput_abs_set_res(sc->sensor_dev, ABS_X, DS4_ACC_RES_PER_G);\r\ninput_abs_set_res(sc->sensor_dev, ABS_Y, DS4_ACC_RES_PER_G);\r\ninput_abs_set_res(sc->sensor_dev, ABS_Z, DS4_ACC_RES_PER_G);\r\nrange = DS4_GYRO_RES_PER_DEG_S*2048;\r\ninput_set_abs_params(sc->sensor_dev, ABS_RX, -range, range, 16, 0);\r\ninput_set_abs_params(sc->sensor_dev, ABS_RY, -range, range, 16, 0);\r\ninput_set_abs_params(sc->sensor_dev, ABS_RZ, -range, range, 16, 0);\r\ninput_abs_set_res(sc->sensor_dev, ABS_RX, DS4_GYRO_RES_PER_DEG_S);\r\ninput_abs_set_res(sc->sensor_dev, ABS_RY, DS4_GYRO_RES_PER_DEG_S);\r\ninput_abs_set_res(sc->sensor_dev, ABS_RZ, DS4_GYRO_RES_PER_DEG_S);\r\n__set_bit(EV_MSC, sc->sensor_dev->evbit);\r\n__set_bit(MSC_TIMESTAMP, sc->sensor_dev->mscbit);\r\n}\r\n__set_bit(INPUT_PROP_ACCELEROMETER, sc->sensor_dev->propbit);\r\nret = input_register_device(sc->sensor_dev);\r\nif (ret < 0)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nkfree(sc->sensor_dev->name);\r\nsc->sensor_dev->name = NULL;\r\ninput_free_device(sc->sensor_dev);\r\nsc->sensor_dev = NULL;\r\nreturn ret;\r\n}\r\nstatic void sony_unregister_sensors(struct sony_sc *sc)\r\n{\r\nif (!sc->sensor_dev)\r\nreturn;\r\nkfree(sc->sensor_dev->name);\r\nsc->sensor_dev->name = NULL;\r\ninput_unregister_device(sc->sensor_dev);\r\nsc->sensor_dev = NULL;\r\n}\r\nstatic int sixaxis_set_operational_usb(struct hid_device *hdev)\r\n{\r\nconst int buf_size =\r\nmax(SIXAXIS_REPORT_0xF2_SIZE, SIXAXIS_REPORT_0xF5_SIZE);\r\nu8 *buf;\r\nint ret;\r\nbuf = kmalloc(buf_size, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nret = hid_hw_raw_request(hdev, 0xf2, buf, SIXAXIS_REPORT_0xF2_SIZE,\r\nHID_FEATURE_REPORT, HID_REQ_GET_REPORT);\r\nif (ret < 0) {\r\nhid_err(hdev, "can't set operational mode: step 1\n");\r\ngoto out;\r\n}\r\nret = hid_hw_raw_request(hdev, 0xf5, buf, SIXAXIS_REPORT_0xF5_SIZE,\r\nHID_FEATURE_REPORT, HID_REQ_GET_REPORT);\r\nif (ret < 0) {\r\nhid_err(hdev, "can't set operational mode: step 2\n");\r\ngoto out;\r\n}\r\nret = hid_hw_output_report(hdev, buf, 1);\r\nif (ret < 0) {\r\nhid_info(hdev, "can't set operational mode: step 3, ignoring\n");\r\nret = 0;\r\n}\r\nout:\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int sixaxis_set_operational_bt(struct hid_device *hdev)\r\n{\r\nstatic const u8 report[] = { 0xf4, 0x42, 0x03, 0x00, 0x00 };\r\nu8 *buf;\r\nint ret;\r\nbuf = kmemdup(report, sizeof(report), GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nret = hid_hw_raw_request(hdev, buf[0], buf, sizeof(report),\r\nHID_FEATURE_REPORT, HID_REQ_SET_REPORT);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int dualshock4_get_calibration_data(struct sony_sc *sc)\r\n{\r\nu8 *buf;\r\nint ret;\r\nshort gyro_pitch_bias, gyro_pitch_plus, gyro_pitch_minus;\r\nshort gyro_yaw_bias, gyro_yaw_plus, gyro_yaw_minus;\r\nshort gyro_roll_bias, gyro_roll_plus, gyro_roll_minus;\r\nshort gyro_speed_plus, gyro_speed_minus;\r\nshort acc_x_plus, acc_x_minus;\r\nshort acc_y_plus, acc_y_minus;\r\nshort acc_z_plus, acc_z_minus;\r\nint speed_2x;\r\nint range_2g;\r\nif (sc->quirks & (DUALSHOCK4_CONTROLLER_USB | DUALSHOCK4_DONGLE)) {\r\nbuf = kmalloc(DS4_FEATURE_REPORT_0x02_SIZE, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nret = hid_hw_raw_request(sc->hdev, 0x02, buf,\r\nDS4_FEATURE_REPORT_0x02_SIZE,\r\nHID_FEATURE_REPORT,\r\nHID_REQ_GET_REPORT);\r\nif (ret < 0)\r\ngoto err_stop;\r\n} else {\r\nu8 bthdr = 0xA3;\r\nu32 crc;\r\nu32 report_crc;\r\nint retries;\r\nbuf = kmalloc(DS4_FEATURE_REPORT_0x05_SIZE, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nfor (retries = 0; retries < 3; retries++) {\r\nret = hid_hw_raw_request(sc->hdev, 0x05, buf,\r\nDS4_FEATURE_REPORT_0x05_SIZE,\r\nHID_FEATURE_REPORT,\r\nHID_REQ_GET_REPORT);\r\nif (ret < 0)\r\ngoto err_stop;\r\ncrc = crc32_le(0xFFFFFFFF, &bthdr, 1);\r\ncrc = ~crc32_le(crc, buf, DS4_FEATURE_REPORT_0x05_SIZE-4);\r\nreport_crc = get_unaligned_le32(&buf[DS4_FEATURE_REPORT_0x05_SIZE-4]);\r\nif (crc != report_crc) {\r\nhid_warn(sc->hdev, "DualShock 4 calibration report's CRC check failed, received crc 0x%0x != 0x%0x\n",\r\nreport_crc, crc);\r\nif (retries < 2) {\r\nhid_warn(sc->hdev, "Retrying DualShock 4 get calibration report request\n");\r\ncontinue;\r\n} else {\r\nret = -EILSEQ;\r\ngoto err_stop;\r\n}\r\n} else {\r\nbreak;\r\n}\r\n}\r\n}\r\ngyro_pitch_bias = get_unaligned_le16(&buf[1]);\r\ngyro_yaw_bias = get_unaligned_le16(&buf[3]);\r\ngyro_roll_bias = get_unaligned_le16(&buf[5]);\r\nif (sc->quirks & DUALSHOCK4_CONTROLLER_USB) {\r\ngyro_pitch_plus = get_unaligned_le16(&buf[7]);\r\ngyro_pitch_minus = get_unaligned_le16(&buf[9]);\r\ngyro_yaw_plus = get_unaligned_le16(&buf[11]);\r\ngyro_yaw_minus = get_unaligned_le16(&buf[13]);\r\ngyro_roll_plus = get_unaligned_le16(&buf[15]);\r\ngyro_roll_minus = get_unaligned_le16(&buf[17]);\r\n} else {\r\ngyro_pitch_plus = get_unaligned_le16(&buf[7]);\r\ngyro_yaw_plus = get_unaligned_le16(&buf[9]);\r\ngyro_roll_plus = get_unaligned_le16(&buf[11]);\r\ngyro_pitch_minus = get_unaligned_le16(&buf[13]);\r\ngyro_yaw_minus = get_unaligned_le16(&buf[15]);\r\ngyro_roll_minus = get_unaligned_le16(&buf[17]);\r\n}\r\ngyro_speed_plus = get_unaligned_le16(&buf[19]);\r\ngyro_speed_minus = get_unaligned_le16(&buf[21]);\r\nacc_x_plus = get_unaligned_le16(&buf[23]);\r\nacc_x_minus = get_unaligned_le16(&buf[25]);\r\nacc_y_plus = get_unaligned_le16(&buf[27]);\r\nacc_y_minus = get_unaligned_le16(&buf[29]);\r\nacc_z_plus = get_unaligned_le16(&buf[31]);\r\nacc_z_minus = get_unaligned_le16(&buf[33]);\r\nspeed_2x = (gyro_speed_plus + gyro_speed_minus);\r\nsc->ds4_calib_data[0].abs_code = ABS_RX;\r\nsc->ds4_calib_data[0].bias = gyro_pitch_bias;\r\nsc->ds4_calib_data[0].sens_numer = speed_2x*DS4_GYRO_RES_PER_DEG_S;\r\nsc->ds4_calib_data[0].sens_denom = gyro_pitch_plus - gyro_pitch_minus;\r\nsc->ds4_calib_data[1].abs_code = ABS_RY;\r\nsc->ds4_calib_data[1].bias = gyro_yaw_bias;\r\nsc->ds4_calib_data[1].sens_numer = speed_2x*DS4_GYRO_RES_PER_DEG_S;\r\nsc->ds4_calib_data[1].sens_denom = gyro_yaw_plus - gyro_yaw_minus;\r\nsc->ds4_calib_data[2].abs_code = ABS_RZ;\r\nsc->ds4_calib_data[2].bias = gyro_roll_bias;\r\nsc->ds4_calib_data[2].sens_numer = speed_2x*DS4_GYRO_RES_PER_DEG_S;\r\nsc->ds4_calib_data[2].sens_denom = gyro_roll_plus - gyro_roll_minus;\r\nrange_2g = acc_x_plus - acc_x_minus;\r\nsc->ds4_calib_data[3].abs_code = ABS_X;\r\nsc->ds4_calib_data[3].bias = acc_x_plus - range_2g / 2;\r\nsc->ds4_calib_data[3].sens_numer = 2*DS4_ACC_RES_PER_G;\r\nsc->ds4_calib_data[3].sens_denom = range_2g;\r\nrange_2g = acc_y_plus - acc_y_minus;\r\nsc->ds4_calib_data[4].abs_code = ABS_Y;\r\nsc->ds4_calib_data[4].bias = acc_y_plus - range_2g / 2;\r\nsc->ds4_calib_data[4].sens_numer = 2*DS4_ACC_RES_PER_G;\r\nsc->ds4_calib_data[4].sens_denom = range_2g;\r\nrange_2g = acc_z_plus - acc_z_minus;\r\nsc->ds4_calib_data[5].abs_code = ABS_Z;\r\nsc->ds4_calib_data[5].bias = acc_z_plus - range_2g / 2;\r\nsc->ds4_calib_data[5].sens_numer = 2*DS4_ACC_RES_PER_G;\r\nsc->ds4_calib_data[5].sens_denom = range_2g;\r\nerr_stop:\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic void dualshock4_calibration_work(struct work_struct *work)\r\n{\r\nstruct sony_sc *sc = container_of(work, struct sony_sc, hotplug_worker);\r\nunsigned long flags;\r\nenum ds4_dongle_state dongle_state;\r\nint ret;\r\nret = dualshock4_get_calibration_data(sc);\r\nif (ret < 0) {\r\nhid_err(sc->hdev, "DualShock 4 USB dongle: calibration failed, disabling device\n");\r\ndongle_state = DONGLE_DISABLED;\r\n} else {\r\nhid_info(sc->hdev, "DualShock 4 USB dongle: calibration completed\n");\r\ndongle_state = DONGLE_CONNECTED;\r\n}\r\nspin_lock_irqsave(&sc->lock, flags);\r\nsc->ds4_dongle_state = dongle_state;\r\nspin_unlock_irqrestore(&sc->lock, flags);\r\n}\r\nstatic void sixaxis_set_leds_from_id(struct sony_sc *sc)\r\n{\r\nstatic const u8 sixaxis_leds[10][4] = {\r\n{ 0x01, 0x00, 0x00, 0x00 },\r\n{ 0x00, 0x01, 0x00, 0x00 },\r\n{ 0x00, 0x00, 0x01, 0x00 },\r\n{ 0x00, 0x00, 0x00, 0x01 },\r\n{ 0x01, 0x00, 0x00, 0x01 },\r\n{ 0x00, 0x01, 0x00, 0x01 },\r\n{ 0x00, 0x00, 0x01, 0x01 },\r\n{ 0x01, 0x00, 0x01, 0x01 },\r\n{ 0x00, 0x01, 0x01, 0x01 },\r\n{ 0x01, 0x01, 0x01, 0x01 }\r\n};\r\nint id = sc->device_id;\r\nBUILD_BUG_ON(MAX_LEDS < ARRAY_SIZE(sixaxis_leds[0]));\r\nif (id < 0)\r\nreturn;\r\nid %= 10;\r\nmemcpy(sc->led_state, sixaxis_leds[id], sizeof(sixaxis_leds[id]));\r\n}\r\nstatic void dualshock4_set_leds_from_id(struct sony_sc *sc)\r\n{\r\nstatic const u8 color_code[7][3] = {\r\n{ 0x00, 0x00, 0x40 },\r\n{ 0x40, 0x00, 0x00 },\r\n{ 0x00, 0x40, 0x00 },\r\n{ 0x20, 0x00, 0x20 },\r\n{ 0x02, 0x01, 0x00 },\r\n{ 0x00, 0x01, 0x01 },\r\n{ 0x01, 0x01, 0x01 }\r\n};\r\nint id = sc->device_id;\r\nBUILD_BUG_ON(MAX_LEDS < ARRAY_SIZE(color_code[0]));\r\nif (id < 0)\r\nreturn;\r\nid %= 7;\r\nmemcpy(sc->led_state, color_code[id], sizeof(color_code[id]));\r\n}\r\nstatic void buzz_set_leds(struct sony_sc *sc)\r\n{\r\nstruct hid_device *hdev = sc->hdev;\r\nstruct list_head *report_list =\r\n&hdev->report_enum[HID_OUTPUT_REPORT].report_list;\r\nstruct hid_report *report = list_entry(report_list->next,\r\nstruct hid_report, list);\r\ns32 *value = report->field[0]->value;\r\nBUILD_BUG_ON(MAX_LEDS < 4);\r\nvalue[0] = 0x00;\r\nvalue[1] = sc->led_state[0] ? 0xff : 0x00;\r\nvalue[2] = sc->led_state[1] ? 0xff : 0x00;\r\nvalue[3] = sc->led_state[2] ? 0xff : 0x00;\r\nvalue[4] = sc->led_state[3] ? 0xff : 0x00;\r\nvalue[5] = 0x00;\r\nvalue[6] = 0x00;\r\nhid_hw_request(hdev, report, HID_REQ_SET_REPORT);\r\n}\r\nstatic void sony_set_leds(struct sony_sc *sc)\r\n{\r\nif (!(sc->quirks & BUZZ_CONTROLLER))\r\nsony_schedule_work(sc, SONY_WORKER_STATE);\r\nelse\r\nbuzz_set_leds(sc);\r\n}\r\nstatic void sony_led_set_brightness(struct led_classdev *led,\r\nenum led_brightness value)\r\n{\r\nstruct device *dev = led->dev->parent;\r\nstruct hid_device *hdev = to_hid_device(dev);\r\nstruct sony_sc *drv_data;\r\nint n;\r\nint force_update;\r\ndrv_data = hid_get_drvdata(hdev);\r\nif (!drv_data) {\r\nhid_err(hdev, "No device data\n");\r\nreturn;\r\n}\r\nforce_update = !!(drv_data->quirks & SIXAXIS_CONTROLLER_USB);\r\nfor (n = 0; n < drv_data->led_count; n++) {\r\nif (led == drv_data->leds[n] && (force_update ||\r\n(value != drv_data->led_state[n] ||\r\ndrv_data->led_delay_on[n] ||\r\ndrv_data->led_delay_off[n]))) {\r\ndrv_data->led_state[n] = value;\r\ndrv_data->led_delay_on[n] = 0;\r\ndrv_data->led_delay_off[n] = 0;\r\nsony_set_leds(drv_data);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic enum led_brightness sony_led_get_brightness(struct led_classdev *led)\r\n{\r\nstruct device *dev = led->dev->parent;\r\nstruct hid_device *hdev = to_hid_device(dev);\r\nstruct sony_sc *drv_data;\r\nint n;\r\ndrv_data = hid_get_drvdata(hdev);\r\nif (!drv_data) {\r\nhid_err(hdev, "No device data\n");\r\nreturn LED_OFF;\r\n}\r\nfor (n = 0; n < drv_data->led_count; n++) {\r\nif (led == drv_data->leds[n])\r\nreturn drv_data->led_state[n];\r\n}\r\nreturn LED_OFF;\r\n}\r\nstatic int sony_led_blink_set(struct led_classdev *led, unsigned long *delay_on,\r\nunsigned long *delay_off)\r\n{\r\nstruct device *dev = led->dev->parent;\r\nstruct hid_device *hdev = to_hid_device(dev);\r\nstruct sony_sc *drv_data = hid_get_drvdata(hdev);\r\nint n;\r\nu8 new_on, new_off;\r\nif (!drv_data) {\r\nhid_err(hdev, "No device data\n");\r\nreturn -EINVAL;\r\n}\r\nif (*delay_on > 2550)\r\n*delay_on = 2550;\r\nif (*delay_off > 2550)\r\n*delay_off = 2550;\r\nif (!*delay_on && !*delay_off)\r\n*delay_on = *delay_off = 500;\r\nnew_on = *delay_on / 10;\r\nnew_off = *delay_off / 10;\r\nfor (n = 0; n < drv_data->led_count; n++) {\r\nif (led == drv_data->leds[n])\r\nbreak;\r\n}\r\nif (n >= drv_data->led_count)\r\nreturn -EINVAL;\r\nif (new_on != drv_data->led_delay_on[n] ||\r\nnew_off != drv_data->led_delay_off[n]) {\r\ndrv_data->led_delay_on[n] = new_on;\r\ndrv_data->led_delay_off[n] = new_off;\r\nsony_schedule_work(drv_data, SONY_WORKER_STATE);\r\n}\r\nreturn 0;\r\n}\r\nstatic void sony_leds_remove(struct sony_sc *sc)\r\n{\r\nstruct led_classdev *led;\r\nint n;\r\nBUG_ON(!(sc->quirks & SONY_LED_SUPPORT));\r\nfor (n = 0; n < sc->led_count; n++) {\r\nled = sc->leds[n];\r\nsc->leds[n] = NULL;\r\nif (!led)\r\ncontinue;\r\nled_classdev_unregister(led);\r\nkfree(led);\r\n}\r\nsc->led_count = 0;\r\n}\r\nstatic int sony_leds_init(struct sony_sc *sc)\r\n{\r\nstruct hid_device *hdev = sc->hdev;\r\nint n, ret = 0;\r\nint use_ds4_names;\r\nstruct led_classdev *led;\r\nsize_t name_sz;\r\nchar *name;\r\nsize_t name_len;\r\nconst char *name_fmt;\r\nstatic const char * const ds4_name_str[] = { "red", "green", "blue",\r\n"global" };\r\nu8 max_brightness[MAX_LEDS] = { [0 ... (MAX_LEDS - 1)] = 1 };\r\nu8 use_hw_blink[MAX_LEDS] = { 0 };\r\nBUG_ON(!(sc->quirks & SONY_LED_SUPPORT));\r\nif (sc->quirks & BUZZ_CONTROLLER) {\r\nsc->led_count = 4;\r\nuse_ds4_names = 0;\r\nname_len = strlen("::buzz#");\r\nname_fmt = "%s::buzz%d";\r\nif (!hid_validate_values(hdev, HID_OUTPUT_REPORT, 0, 0, 7))\r\nreturn -ENODEV;\r\n} else if (sc->quirks & DUALSHOCK4_CONTROLLER) {\r\ndualshock4_set_leds_from_id(sc);\r\nsc->led_state[3] = 1;\r\nsc->led_count = 4;\r\nmemset(max_brightness, 255, 3);\r\nuse_hw_blink[3] = 1;\r\nuse_ds4_names = 1;\r\nname_len = 0;\r\nname_fmt = "%s:%s";\r\n} else if (sc->quirks & MOTION_CONTROLLER) {\r\nsc->led_count = 3;\r\nmemset(max_brightness, 255, 3);\r\nuse_ds4_names = 1;\r\nname_len = 0;\r\nname_fmt = "%s:%s";\r\n} else if (sc->quirks & NAVIGATION_CONTROLLER) {\r\nstatic const u8 navigation_leds[4] = {0x01, 0x00, 0x00, 0x00};\r\nmemcpy(sc->led_state, navigation_leds, sizeof(navigation_leds));\r\nsc->led_count = 1;\r\nmemset(use_hw_blink, 1, 4);\r\nuse_ds4_names = 0;\r\nname_len = strlen("::sony#");\r\nname_fmt = "%s::sony%d";\r\n} else {\r\nsixaxis_set_leds_from_id(sc);\r\nsc->led_count = 4;\r\nmemset(use_hw_blink, 1, 4);\r\nuse_ds4_names = 0;\r\nname_len = strlen("::sony#");\r\nname_fmt = "%s::sony%d";\r\n}\r\nsony_set_leds(sc);\r\nname_sz = strlen(dev_name(&hdev->dev)) + name_len + 1;\r\nfor (n = 0; n < sc->led_count; n++) {\r\nif (use_ds4_names)\r\nname_sz = strlen(dev_name(&hdev->dev)) + strlen(ds4_name_str[n]) + 2;\r\nled = kzalloc(sizeof(struct led_classdev) + name_sz, GFP_KERNEL);\r\nif (!led) {\r\nhid_err(hdev, "Couldn't allocate memory for LED %d\n", n);\r\nret = -ENOMEM;\r\ngoto error_leds;\r\n}\r\nname = (void *)(&led[1]);\r\nif (use_ds4_names)\r\nsnprintf(name, name_sz, name_fmt, dev_name(&hdev->dev),\r\nds4_name_str[n]);\r\nelse\r\nsnprintf(name, name_sz, name_fmt, dev_name(&hdev->dev), n + 1);\r\nled->name = name;\r\nled->brightness = sc->led_state[n];\r\nled->max_brightness = max_brightness[n];\r\nled->flags = LED_CORE_SUSPENDRESUME;\r\nled->brightness_get = sony_led_get_brightness;\r\nled->brightness_set = sony_led_set_brightness;\r\nif (use_hw_blink[n])\r\nled->blink_set = sony_led_blink_set;\r\nsc->leds[n] = led;\r\nret = led_classdev_register(&hdev->dev, led);\r\nif (ret) {\r\nhid_err(hdev, "Failed to register LED %d\n", n);\r\nsc->leds[n] = NULL;\r\nkfree(led);\r\ngoto error_leds;\r\n}\r\n}\r\nreturn ret;\r\nerror_leds:\r\nsony_leds_remove(sc);\r\nreturn ret;\r\n}\r\nstatic void sixaxis_send_output_report(struct sony_sc *sc)\r\n{\r\nstatic const union sixaxis_output_report_01 default_report = {\r\n.buf = {\r\n0x01,\r\n0x01, 0xff, 0x00, 0xff, 0x00,\r\n0x00, 0x00, 0x00, 0x00, 0x00,\r\n0xff, 0x27, 0x10, 0x00, 0x32,\r\n0xff, 0x27, 0x10, 0x00, 0x32,\r\n0xff, 0x27, 0x10, 0x00, 0x32,\r\n0xff, 0x27, 0x10, 0x00, 0x32,\r\n0x00, 0x00, 0x00, 0x00, 0x00\r\n}\r\n};\r\nstruct sixaxis_output_report *report =\r\n(struct sixaxis_output_report *)sc->output_report_dmabuf;\r\nint n;\r\nmemcpy(report, &default_report, sizeof(struct sixaxis_output_report));\r\n#ifdef CONFIG_SONY_FF\r\nreport->rumble.right_motor_on = sc->right ? 1 : 0;\r\nreport->rumble.left_motor_force = sc->left;\r\n#endif\r\nreport->leds_bitmap |= sc->led_state[0] << 1;\r\nreport->leds_bitmap |= sc->led_state[1] << 2;\r\nreport->leds_bitmap |= sc->led_state[2] << 3;\r\nreport->leds_bitmap |= sc->led_state[3] << 4;\r\nif ((report->leds_bitmap & 0x1E) == 0)\r\nreport->leds_bitmap |= 0x20;\r\nfor (n = 0; n < 4; n++) {\r\nif (sc->led_delay_on[n] || sc->led_delay_off[n]) {\r\nreport->led[3 - n].duty_off = sc->led_delay_off[n];\r\nreport->led[3 - n].duty_on = sc->led_delay_on[n];\r\n}\r\n}\r\nhid_hw_raw_request(sc->hdev, report->report_id, (u8 *)report,\r\nsizeof(struct sixaxis_output_report),\r\nHID_OUTPUT_REPORT, HID_REQ_SET_REPORT);\r\n}\r\nstatic void dualshock4_send_output_report(struct sony_sc *sc)\r\n{\r\nstruct hid_device *hdev = sc->hdev;\r\nu8 *buf = sc->output_report_dmabuf;\r\nint offset;\r\nif (sc->quirks & (DUALSHOCK4_CONTROLLER_USB | DUALSHOCK4_DONGLE)) {\r\nmemset(buf, 0, DS4_OUTPUT_REPORT_0x05_SIZE);\r\nbuf[0] = 0x05;\r\nbuf[1] = 0x07;\r\noffset = 4;\r\n} else {\r\nmemset(buf, 0, DS4_OUTPUT_REPORT_0x11_SIZE);\r\nbuf[0] = 0x11;\r\nbuf[1] = 0xC0 | sc->ds4_bt_poll_interval;\r\nbuf[3] = 0x07;\r\noffset = 6;\r\n}\r\n#ifdef CONFIG_SONY_FF\r\nbuf[offset++] = sc->right;\r\nbuf[offset++] = sc->left;\r\n#else\r\noffset += 2;\r\n#endif\r\nif (sc->led_state[3]) {\r\nbuf[offset++] = sc->led_state[0];\r\nbuf[offset++] = sc->led_state[1];\r\nbuf[offset++] = sc->led_state[2];\r\n} else {\r\noffset += 3;\r\n}\r\nbuf[offset++] = sc->led_delay_on[3];\r\nbuf[offset++] = sc->led_delay_off[3];\r\nif (sc->quirks & (DUALSHOCK4_CONTROLLER_USB | DUALSHOCK4_DONGLE))\r\nhid_hw_output_report(hdev, buf, DS4_OUTPUT_REPORT_0x05_SIZE);\r\nelse {\r\nu8 bthdr = 0xA2;\r\nu32 crc;\r\ncrc = crc32_le(0xFFFFFFFF, &bthdr, 1);\r\ncrc = ~crc32_le(crc, buf, DS4_OUTPUT_REPORT_0x11_SIZE-4);\r\nput_unaligned_le32(crc, &buf[74]);\r\nhid_hw_output_report(hdev, buf, DS4_OUTPUT_REPORT_0x11_SIZE);\r\n}\r\n}\r\nstatic void motion_send_output_report(struct sony_sc *sc)\r\n{\r\nstruct hid_device *hdev = sc->hdev;\r\nstruct motion_output_report_02 *report =\r\n(struct motion_output_report_02 *)sc->output_report_dmabuf;\r\nmemset(report, 0, MOTION_REPORT_0x02_SIZE);\r\nreport->type = 0x02;\r\nreport->r = sc->led_state[0];\r\nreport->g = sc->led_state[1];\r\nreport->b = sc->led_state[2];\r\n#ifdef CONFIG_SONY_FF\r\nreport->rumble = max(sc->right, sc->left);\r\n#endif\r\nhid_hw_output_report(hdev, (u8 *)report, MOTION_REPORT_0x02_SIZE);\r\n}\r\nstatic inline void sony_send_output_report(struct sony_sc *sc)\r\n{\r\nif (sc->send_output_report)\r\nsc->send_output_report(sc);\r\n}\r\nstatic void sony_state_worker(struct work_struct *work)\r\n{\r\nstruct sony_sc *sc = container_of(work, struct sony_sc, state_worker);\r\nsc->send_output_report(sc);\r\n}\r\nstatic int sony_allocate_output_report(struct sony_sc *sc)\r\n{\r\nif ((sc->quirks & SIXAXIS_CONTROLLER) ||\r\n(sc->quirks & NAVIGATION_CONTROLLER))\r\nsc->output_report_dmabuf =\r\nkmalloc(sizeof(union sixaxis_output_report_01),\r\nGFP_KERNEL);\r\nelse if (sc->quirks & DUALSHOCK4_CONTROLLER_BT)\r\nsc->output_report_dmabuf = kmalloc(DS4_OUTPUT_REPORT_0x11_SIZE,\r\nGFP_KERNEL);\r\nelse if (sc->quirks & (DUALSHOCK4_CONTROLLER_USB | DUALSHOCK4_DONGLE))\r\nsc->output_report_dmabuf = kmalloc(DS4_OUTPUT_REPORT_0x05_SIZE,\r\nGFP_KERNEL);\r\nelse if (sc->quirks & MOTION_CONTROLLER)\r\nsc->output_report_dmabuf = kmalloc(MOTION_REPORT_0x02_SIZE,\r\nGFP_KERNEL);\r\nelse\r\nreturn 0;\r\nif (!sc->output_report_dmabuf)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int sony_play_effect(struct input_dev *dev, void *data,\r\nstruct ff_effect *effect)\r\n{\r\nstruct hid_device *hid = input_get_drvdata(dev);\r\nstruct sony_sc *sc = hid_get_drvdata(hid);\r\nif (effect->type != FF_RUMBLE)\r\nreturn 0;\r\nsc->left = effect->u.rumble.strong_magnitude / 256;\r\nsc->right = effect->u.rumble.weak_magnitude / 256;\r\nsony_schedule_work(sc, SONY_WORKER_STATE);\r\nreturn 0;\r\n}\r\nstatic int sony_init_ff(struct sony_sc *sc)\r\n{\r\nstruct hid_input *hidinput = list_entry(sc->hdev->inputs.next,\r\nstruct hid_input, list);\r\nstruct input_dev *input_dev = hidinput->input;\r\ninput_set_capability(input_dev, EV_FF, FF_RUMBLE);\r\nreturn input_ff_create_memless(input_dev, NULL, sony_play_effect);\r\n}\r\nstatic int sony_init_ff(struct sony_sc *sc)\r\n{\r\nreturn 0;\r\n}\r\nstatic int sony_battery_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct sony_sc *sc = power_supply_get_drvdata(psy);\r\nunsigned long flags;\r\nint ret = 0;\r\nu8 battery_charging, battery_capacity, cable_state;\r\nspin_lock_irqsave(&sc->lock, flags);\r\nbattery_charging = sc->battery_charging;\r\nbattery_capacity = sc->battery_capacity;\r\ncable_state = sc->cable_state;\r\nspin_unlock_irqrestore(&sc->lock, flags);\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_PRESENT:\r\nval->intval = 1;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_SCOPE:\r\nval->intval = POWER_SUPPLY_SCOPE_DEVICE;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CAPACITY:\r\nval->intval = battery_capacity;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_STATUS:\r\nif (battery_charging)\r\nval->intval = POWER_SUPPLY_STATUS_CHARGING;\r\nelse\r\nif (battery_capacity == 100 && cable_state)\r\nval->intval = POWER_SUPPLY_STATUS_FULL;\r\nelse\r\nval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int sony_battery_probe(struct sony_sc *sc, int append_dev_id)\r\n{\r\nconst char *battery_str_fmt = append_dev_id ?\r\n"sony_controller_battery_%pMR_%i" :\r\n"sony_controller_battery_%pMR";\r\nstruct power_supply_config psy_cfg = { .drv_data = sc, };\r\nstruct hid_device *hdev = sc->hdev;\r\nint ret;\r\nsc->battery_capacity = 100;\r\nsc->battery_desc.properties = sony_battery_props;\r\nsc->battery_desc.num_properties = ARRAY_SIZE(sony_battery_props);\r\nsc->battery_desc.get_property = sony_battery_get_property;\r\nsc->battery_desc.type = POWER_SUPPLY_TYPE_BATTERY;\r\nsc->battery_desc.use_for_apm = 0;\r\nsc->battery_desc.name = kasprintf(GFP_KERNEL, battery_str_fmt,\r\nsc->mac_address, sc->device_id);\r\nif (!sc->battery_desc.name)\r\nreturn -ENOMEM;\r\nsc->battery = power_supply_register(&hdev->dev, &sc->battery_desc,\r\n&psy_cfg);\r\nif (IS_ERR(sc->battery)) {\r\nret = PTR_ERR(sc->battery);\r\nhid_err(hdev, "Unable to register battery device\n");\r\ngoto err_free;\r\n}\r\npower_supply_powers(sc->battery, &hdev->dev);\r\nreturn 0;\r\nerr_free:\r\nkfree(sc->battery_desc.name);\r\nsc->battery_desc.name = NULL;\r\nreturn ret;\r\n}\r\nstatic void sony_battery_remove(struct sony_sc *sc)\r\n{\r\nif (!sc->battery_desc.name)\r\nreturn;\r\npower_supply_unregister(sc->battery);\r\nkfree(sc->battery_desc.name);\r\nsc->battery_desc.name = NULL;\r\n}\r\nstatic inline int sony_compare_connection_type(struct sony_sc *sc0,\r\nstruct sony_sc *sc1)\r\n{\r\nconst int sc0_not_bt = !(sc0->quirks & SONY_BT_DEVICE);\r\nconst int sc1_not_bt = !(sc1->quirks & SONY_BT_DEVICE);\r\nreturn sc0_not_bt == sc1_not_bt;\r\n}\r\nstatic int sony_check_add_dev_list(struct sony_sc *sc)\r\n{\r\nstruct sony_sc *entry;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&sony_dev_list_lock, flags);\r\nlist_for_each_entry(entry, &sony_device_list, list_node) {\r\nret = memcmp(sc->mac_address, entry->mac_address,\r\nsizeof(sc->mac_address));\r\nif (!ret) {\r\nif (sony_compare_connection_type(sc, entry)) {\r\nret = 1;\r\n} else {\r\nret = -EEXIST;\r\nhid_info(sc->hdev,\r\n"controller with MAC address %pMR already connected\n",\r\nsc->mac_address);\r\n}\r\ngoto unlock;\r\n}\r\n}\r\nret = 0;\r\nlist_add(&(sc->list_node), &sony_device_list);\r\nunlock:\r\nspin_unlock_irqrestore(&sony_dev_list_lock, flags);\r\nreturn ret;\r\n}\r\nstatic void sony_remove_dev_list(struct sony_sc *sc)\r\n{\r\nunsigned long flags;\r\nif (sc->list_node.next) {\r\nspin_lock_irqsave(&sony_dev_list_lock, flags);\r\nlist_del(&(sc->list_node));\r\nspin_unlock_irqrestore(&sony_dev_list_lock, flags);\r\n}\r\n}\r\nstatic int sony_get_bt_devaddr(struct sony_sc *sc)\r\n{\r\nint ret;\r\nret = strlen(sc->hdev->uniq);\r\nif (ret != 17)\r\nreturn -EINVAL;\r\nret = sscanf(sc->hdev->uniq,\r\n"%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx",\r\n&sc->mac_address[5], &sc->mac_address[4], &sc->mac_address[3],\r\n&sc->mac_address[2], &sc->mac_address[1], &sc->mac_address[0]);\r\nif (ret != 6)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int sony_check_add(struct sony_sc *sc)\r\n{\r\nu8 *buf = NULL;\r\nint n, ret;\r\nif ((sc->quirks & DUALSHOCK4_CONTROLLER_BT) ||\r\n(sc->quirks & MOTION_CONTROLLER_BT) ||\r\n(sc->quirks & NAVIGATION_CONTROLLER_BT) ||\r\n(sc->quirks & SIXAXIS_CONTROLLER_BT)) {\r\nif (sony_get_bt_devaddr(sc) < 0) {\r\nhid_warn(sc->hdev, "UNIQ does not contain a MAC address; duplicate check skipped\n");\r\nreturn 0;\r\n}\r\n} else if (sc->quirks & (DUALSHOCK4_CONTROLLER_USB | DUALSHOCK4_DONGLE)) {\r\nbuf = kmalloc(DS4_FEATURE_REPORT_0x81_SIZE, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nret = hid_hw_raw_request(sc->hdev, 0x81, buf,\r\nDS4_FEATURE_REPORT_0x81_SIZE, HID_FEATURE_REPORT,\r\nHID_REQ_GET_REPORT);\r\nif (ret != DS4_FEATURE_REPORT_0x81_SIZE) {\r\nhid_err(sc->hdev, "failed to retrieve feature report 0x81 with the DualShock 4 MAC address\n");\r\nret = ret < 0 ? ret : -EINVAL;\r\ngoto out_free;\r\n}\r\nmemcpy(sc->mac_address, &buf[1], sizeof(sc->mac_address));\r\nsnprintf(sc->hdev->uniq, sizeof(sc->hdev->uniq),\r\n"%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx",\r\nsc->mac_address[5], sc->mac_address[4],\r\nsc->mac_address[3], sc->mac_address[2],\r\nsc->mac_address[1], sc->mac_address[0]);\r\n} else if ((sc->quirks & SIXAXIS_CONTROLLER_USB) ||\r\n(sc->quirks & NAVIGATION_CONTROLLER_USB)) {\r\nbuf = kmalloc(SIXAXIS_REPORT_0xF2_SIZE, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nret = hid_hw_raw_request(sc->hdev, 0xf2, buf,\r\nSIXAXIS_REPORT_0xF2_SIZE, HID_FEATURE_REPORT,\r\nHID_REQ_GET_REPORT);\r\nif (ret != SIXAXIS_REPORT_0xF2_SIZE) {\r\nhid_err(sc->hdev, "failed to retrieve feature report 0xf2 with the Sixaxis MAC address\n");\r\nret = ret < 0 ? ret : -EINVAL;\r\ngoto out_free;\r\n}\r\nfor (n = 0; n < 6; n++)\r\nsc->mac_address[5-n] = buf[4+n];\r\nsnprintf(sc->hdev->uniq, sizeof(sc->hdev->uniq),\r\n"%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx",\r\nsc->mac_address[5], sc->mac_address[4],\r\nsc->mac_address[3], sc->mac_address[2],\r\nsc->mac_address[1], sc->mac_address[0]);\r\n} else {\r\nreturn 0;\r\n}\r\nret = sony_check_add_dev_list(sc);\r\nout_free:\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int sony_set_device_id(struct sony_sc *sc)\r\n{\r\nint ret;\r\nif ((sc->quirks & SIXAXIS_CONTROLLER) ||\r\n(sc->quirks & DUALSHOCK4_CONTROLLER)) {\r\nret = ida_simple_get(&sony_device_id_allocator, 0, 0,\r\nGFP_KERNEL);\r\nif (ret < 0) {\r\nsc->device_id = -1;\r\nreturn ret;\r\n}\r\nsc->device_id = ret;\r\n} else {\r\nsc->device_id = -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void sony_release_device_id(struct sony_sc *sc)\r\n{\r\nif (sc->device_id >= 0) {\r\nida_simple_remove(&sony_device_id_allocator, sc->device_id);\r\nsc->device_id = -1;\r\n}\r\n}\r\nstatic inline void sony_init_output_report(struct sony_sc *sc,\r\nvoid (*send_output_report)(struct sony_sc *))\r\n{\r\nsc->send_output_report = send_output_report;\r\nif (!sc->state_worker_initialized)\r\nINIT_WORK(&sc->state_worker, sony_state_worker);\r\nsc->state_worker_initialized = 1;\r\n}\r\nstatic inline void sony_cancel_work_sync(struct sony_sc *sc)\r\n{\r\nif (sc->hotplug_worker_initialized)\r\ncancel_work_sync(&sc->hotplug_worker);\r\nif (sc->state_worker_initialized)\r\ncancel_work_sync(&sc->state_worker);\r\n}\r\nstatic int sony_input_configured(struct hid_device *hdev,\r\nstruct hid_input *hidinput)\r\n{\r\nstruct sony_sc *sc = hid_get_drvdata(hdev);\r\nint append_dev_id;\r\nint ret;\r\nret = sony_set_device_id(sc);\r\nif (ret < 0) {\r\nhid_err(hdev, "failed to allocate the device id\n");\r\ngoto err_stop;\r\n}\r\nret = append_dev_id = sony_check_add(sc);\r\nif (ret < 0)\r\ngoto err_stop;\r\nret = sony_allocate_output_report(sc);\r\nif (ret < 0) {\r\nhid_err(hdev, "failed to allocate the output report buffer\n");\r\ngoto err_stop;\r\n}\r\nif (sc->quirks & NAVIGATION_CONTROLLER_USB) {\r\nhdev->quirks |= HID_QUIRK_NO_OUTPUT_REPORTS_ON_INTR_EP;\r\nhdev->quirks |= HID_QUIRK_SKIP_OUTPUT_REPORT_ID;\r\nsc->defer_initialization = 1;\r\nret = sixaxis_set_operational_usb(hdev);\r\nif (ret < 0) {\r\nhid_err(hdev, "Failed to set controller into operational mode\n");\r\ngoto err_stop;\r\n}\r\nsony_init_output_report(sc, sixaxis_send_output_report);\r\n} else if (sc->quirks & NAVIGATION_CONTROLLER_BT) {\r\nhdev->quirks |= HID_QUIRK_NO_OUTPUT_REPORTS_ON_INTR_EP;\r\nret = sixaxis_set_operational_bt(hdev);\r\nif (ret < 0) {\r\nhid_err(hdev, "Failed to set controller into operational mode\n");\r\ngoto err_stop;\r\n}\r\nsony_init_output_report(sc, sixaxis_send_output_report);\r\n} else if (sc->quirks & SIXAXIS_CONTROLLER_USB) {\r\nhdev->quirks |= HID_QUIRK_NO_OUTPUT_REPORTS_ON_INTR_EP;\r\nhdev->quirks |= HID_QUIRK_SKIP_OUTPUT_REPORT_ID;\r\nsc->defer_initialization = 1;\r\nret = sixaxis_set_operational_usb(hdev);\r\nif (ret < 0) {\r\nhid_err(hdev, "Failed to set controller into operational mode\n");\r\ngoto err_stop;\r\n}\r\nret = sony_register_sensors(sc);\r\nif (ret) {\r\nhid_err(sc->hdev,\r\n"Unable to initialize motion sensors: %d\n", ret);\r\ngoto err_stop;\r\n}\r\nsony_init_output_report(sc, sixaxis_send_output_report);\r\n} else if (sc->quirks & SIXAXIS_CONTROLLER_BT) {\r\nhdev->quirks |= HID_QUIRK_NO_OUTPUT_REPORTS_ON_INTR_EP;\r\nret = sixaxis_set_operational_bt(hdev);\r\nif (ret < 0) {\r\nhid_err(hdev, "Failed to set controller into operational mode\n");\r\ngoto err_stop;\r\n}\r\nret = sony_register_sensors(sc);\r\nif (ret) {\r\nhid_err(sc->hdev,\r\n"Unable to initialize motion sensors: %d\n", ret);\r\ngoto err_stop;\r\n}\r\nsony_init_output_report(sc, sixaxis_send_output_report);\r\n} else if (sc->quirks & DUALSHOCK4_CONTROLLER) {\r\nret = dualshock4_get_calibration_data(sc);\r\nif (ret < 0) {\r\nhid_err(hdev, "Failed to get calibration data from Dualshock 4\n");\r\ngoto err_stop;\r\n}\r\nret = sony_register_touchpad(sc, 2, 1920, 942);\r\nif (ret) {\r\nhid_err(sc->hdev,\r\n"Unable to initialize multi-touch slots: %d\n",\r\nret);\r\ngoto err_stop;\r\n}\r\nret = sony_register_sensors(sc);\r\nif (ret) {\r\nhid_err(sc->hdev,\r\n"Unable to initialize motion sensors: %d\n", ret);\r\ngoto err_stop;\r\n}\r\nif (sc->quirks & DUALSHOCK4_CONTROLLER_BT) {\r\nsc->ds4_bt_poll_interval = DS4_BT_DEFAULT_POLL_INTERVAL_MS;\r\nret = device_create_file(&sc->hdev->dev, &dev_attr_bt_poll_interval);\r\nif (ret)\r\nhid_warn(sc->hdev,\r\n"can't create sysfs bt_poll_interval attribute err: %d\n",\r\nret);\r\n}\r\nif (sc->quirks & DUALSHOCK4_DONGLE) {\r\nINIT_WORK(&sc->hotplug_worker, dualshock4_calibration_work);\r\nsc->hotplug_worker_initialized = 1;\r\nsc->ds4_dongle_state = DONGLE_DISCONNECTED;\r\n}\r\nsony_init_output_report(sc, dualshock4_send_output_report);\r\n} else if (sc->quirks & MOTION_CONTROLLER) {\r\nsony_init_output_report(sc, motion_send_output_report);\r\n} else {\r\nret = 0;\r\n}\r\nif (sc->quirks & SONY_LED_SUPPORT) {\r\nret = sony_leds_init(sc);\r\nif (ret < 0)\r\ngoto err_stop;\r\n}\r\nif (sc->quirks & SONY_BATTERY_SUPPORT) {\r\nret = sony_battery_probe(sc, append_dev_id);\r\nif (ret < 0)\r\ngoto err_stop;\r\nret = hid_hw_open(hdev);\r\nif (ret < 0) {\r\nhid_err(hdev, "hw open failed\n");\r\ngoto err_stop;\r\n}\r\n}\r\nif (sc->quirks & SONY_FF_SUPPORT) {\r\nret = sony_init_ff(sc);\r\nif (ret < 0)\r\ngoto err_close;\r\n}\r\nreturn 0;\r\nerr_close:\r\nhid_hw_close(hdev);\r\nerr_stop:\r\nif (sc->ds4_bt_poll_interval)\r\ndevice_remove_file(&sc->hdev->dev, &dev_attr_bt_poll_interval);\r\nif (sc->quirks & SONY_LED_SUPPORT)\r\nsony_leds_remove(sc);\r\nif (sc->quirks & SONY_BATTERY_SUPPORT)\r\nsony_battery_remove(sc);\r\nif (sc->touchpad)\r\nsony_unregister_touchpad(sc);\r\nif (sc->sensor_dev)\r\nsony_unregister_sensors(sc);\r\nsony_cancel_work_sync(sc);\r\nkfree(sc->output_report_dmabuf);\r\nsony_remove_dev_list(sc);\r\nsony_release_device_id(sc);\r\nhid_hw_stop(hdev);\r\nreturn ret;\r\n}\r\nstatic int sony_probe(struct hid_device *hdev, const struct hid_device_id *id)\r\n{\r\nint ret;\r\nunsigned long quirks = id->driver_data;\r\nstruct sony_sc *sc;\r\nunsigned int connect_mask = HID_CONNECT_DEFAULT;\r\nif (!strcmp(hdev->name, "FutureMax Dance Mat"))\r\nquirks |= FUTUREMAX_DANCE_MAT;\r\nsc = devm_kzalloc(&hdev->dev, sizeof(*sc), GFP_KERNEL);\r\nif (sc == NULL) {\r\nhid_err(hdev, "can't alloc sony descriptor\n");\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&sc->lock);\r\nsc->quirks = quirks;\r\nhid_set_drvdata(hdev, sc);\r\nsc->hdev = hdev;\r\nret = hid_parse(hdev);\r\nif (ret) {\r\nhid_err(hdev, "parse failed\n");\r\nreturn ret;\r\n}\r\nif (sc->quirks & VAIO_RDESC_CONSTANT)\r\nconnect_mask |= HID_CONNECT_HIDDEV_FORCE;\r\nelse if (sc->quirks & SIXAXIS_CONTROLLER)\r\nconnect_mask |= HID_CONNECT_HIDDEV_FORCE;\r\nif (sc->quirks & (SIXAXIS_CONTROLLER | DUALSHOCK4_CONTROLLER))\r\nhdev->version |= 0x8000;\r\nret = hid_hw_start(hdev, connect_mask);\r\nif (ret) {\r\nhid_err(hdev, "hw start failed\n");\r\nreturn ret;\r\n}\r\nif (!(hdev->claimed & HID_CLAIMED_INPUT)) {\r\nhid_err(hdev, "failed to claim input\n");\r\nreturn -ENODEV;\r\n}\r\nreturn ret;\r\n}\r\nstatic void sony_remove(struct hid_device *hdev)\r\n{\r\nstruct sony_sc *sc = hid_get_drvdata(hdev);\r\nhid_hw_close(hdev);\r\nif (sc->quirks & SONY_LED_SUPPORT)\r\nsony_leds_remove(sc);\r\nif (sc->quirks & SONY_BATTERY_SUPPORT)\r\nsony_battery_remove(sc);\r\nif (sc->touchpad)\r\nsony_unregister_touchpad(sc);\r\nif (sc->sensor_dev)\r\nsony_unregister_sensors(sc);\r\nif (sc->quirks & DUALSHOCK4_CONTROLLER_BT)\r\ndevice_remove_file(&sc->hdev->dev, &dev_attr_bt_poll_interval);\r\nsony_cancel_work_sync(sc);\r\nkfree(sc->output_report_dmabuf);\r\nsony_remove_dev_list(sc);\r\nsony_release_device_id(sc);\r\nhid_hw_stop(hdev);\r\n}\r\nstatic int sony_suspend(struct hid_device *hdev, pm_message_t message)\r\n{\r\n#ifdef CONFIG_SONY_FF\r\nif (SONY_FF_SUPPORT) {\r\nstruct sony_sc *sc = hid_get_drvdata(hdev);\r\nsc->left = sc->right = 0;\r\nsony_send_output_report(sc);\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int sony_resume(struct hid_device *hdev)\r\n{\r\nstruct sony_sc *sc = hid_get_drvdata(hdev);\r\nif ((sc->quirks & SIXAXIS_CONTROLLER_USB) ||\r\n(sc->quirks & NAVIGATION_CONTROLLER_USB)) {\r\nsixaxis_set_operational_usb(sc->hdev);\r\nsc->defer_initialization = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init sony_init(void)\r\n{\r\ndbg_hid("Sony:%s\n", __func__);\r\nreturn hid_register_driver(&sony_driver);\r\n}\r\nstatic void __exit sony_exit(void)\r\n{\r\ndbg_hid("Sony:%s\n", __func__);\r\nhid_unregister_driver(&sony_driver);\r\nida_destroy(&sony_device_id_allocator);\r\n}
