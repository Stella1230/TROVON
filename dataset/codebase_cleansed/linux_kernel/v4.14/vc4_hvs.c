void vc4_hvs_dump_state(struct drm_device *dev)\r\n{\r\nstruct vc4_dev *vc4 = to_vc4_dev(dev);\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(hvs_regs); i++) {\r\nDRM_INFO("0x%04x (%s): 0x%08x\n",\r\nhvs_regs[i].reg, hvs_regs[i].name,\r\nHVS_READ(hvs_regs[i].reg));\r\n}\r\nDRM_INFO("HVS ctx:\n");\r\nfor (i = 0; i < 64; i += 4) {\r\nDRM_INFO("0x%08x (%s): 0x%08x 0x%08x 0x%08x 0x%08x\n",\r\ni * 4, i < HVS_BOOTLOADER_DLIST_END ? "B" : "D",\r\nreadl((u32 __iomem *)vc4->hvs->dlist + i + 0),\r\nreadl((u32 __iomem *)vc4->hvs->dlist + i + 1),\r\nreadl((u32 __iomem *)vc4->hvs->dlist + i + 2),\r\nreadl((u32 __iomem *)vc4->hvs->dlist + i + 3));\r\n}\r\n}\r\nint vc4_hvs_debugfs_regs(struct seq_file *m, void *unused)\r\n{\r\nstruct drm_info_node *node = (struct drm_info_node *)m->private;\r\nstruct drm_device *dev = node->minor->dev;\r\nstruct vc4_dev *vc4 = to_vc4_dev(dev);\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(hvs_regs); i++) {\r\nseq_printf(m, "%s (0x%04x): 0x%08x\n",\r\nhvs_regs[i].name, hvs_regs[i].reg,\r\nHVS_READ(hvs_regs[i].reg));\r\n}\r\nreturn 0;\r\n}\r\nstatic int vc4_hvs_upload_linear_kernel(struct vc4_hvs *hvs,\r\nstruct drm_mm_node *space,\r\nconst u32 *kernel)\r\n{\r\nint ret, i;\r\nu32 __iomem *dst_kernel;\r\nret = drm_mm_insert_node(&hvs->dlist_mm, space, VC4_KERNEL_DWORDS);\r\nif (ret) {\r\nDRM_ERROR("Failed to allocate space for filter kernel: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\ndst_kernel = hvs->dlist + space->start;\r\nfor (i = 0; i < VC4_KERNEL_DWORDS; i++) {\r\nif (i < VC4_LINEAR_PHASE_KERNEL_DWORDS)\r\nwritel(kernel[i], &dst_kernel[i]);\r\nelse {\r\nwritel(kernel[VC4_KERNEL_DWORDS - i - 1],\r\n&dst_kernel[i]);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int vc4_hvs_bind(struct device *dev, struct device *master, void *data)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct drm_device *drm = dev_get_drvdata(master);\r\nstruct vc4_dev *vc4 = drm->dev_private;\r\nstruct vc4_hvs *hvs = NULL;\r\nint ret;\r\nu32 dispctrl;\r\nhvs = devm_kzalloc(&pdev->dev, sizeof(*hvs), GFP_KERNEL);\r\nif (!hvs)\r\nreturn -ENOMEM;\r\nhvs->pdev = pdev;\r\nhvs->regs = vc4_ioremap_regs(pdev, 0);\r\nif (IS_ERR(hvs->regs))\r\nreturn PTR_ERR(hvs->regs);\r\nhvs->dlist = hvs->regs + SCALER_DLIST_START;\r\nspin_lock_init(&hvs->mm_lock);\r\ndrm_mm_init(&hvs->dlist_mm,\r\nHVS_BOOTLOADER_DLIST_END,\r\n(SCALER_DLIST_SIZE >> 2) - HVS_BOOTLOADER_DLIST_END);\r\ndrm_mm_init(&hvs->lbm_mm, 0, 96 * 1024);\r\nret = vc4_hvs_upload_linear_kernel(hvs,\r\n&hvs->mitchell_netravali_filter,\r\nmitchell_netravali_1_3_1_3_kernel);\r\nif (ret)\r\nreturn ret;\r\nvc4->hvs = hvs;\r\ndispctrl = HVS_READ(SCALER_DISPCTRL);\r\ndispctrl |= SCALER_DISPCTRL_ENABLE;\r\ndispctrl &= ~SCALER_DISPCTRL_DSP3_MUX_MASK;\r\ndispctrl |= VC4_SET_FIELD(2, SCALER_DISPCTRL_DSP3_MUX);\r\nHVS_WRITE(SCALER_DISPCTRL, dispctrl);\r\nreturn 0;\r\n}\r\nstatic void vc4_hvs_unbind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\nstruct drm_device *drm = dev_get_drvdata(master);\r\nstruct vc4_dev *vc4 = drm->dev_private;\r\nif (vc4->hvs->mitchell_netravali_filter.allocated)\r\ndrm_mm_remove_node(&vc4->hvs->mitchell_netravali_filter);\r\ndrm_mm_takedown(&vc4->hvs->dlist_mm);\r\ndrm_mm_takedown(&vc4->hvs->lbm_mm);\r\nvc4->hvs = NULL;\r\n}\r\nstatic int vc4_hvs_dev_probe(struct platform_device *pdev)\r\n{\r\nreturn component_add(&pdev->dev, &vc4_hvs_ops);\r\n}\r\nstatic int vc4_hvs_dev_remove(struct platform_device *pdev)\r\n{\r\ncomponent_del(&pdev->dev, &vc4_hvs_ops);\r\nreturn 0;\r\n}
