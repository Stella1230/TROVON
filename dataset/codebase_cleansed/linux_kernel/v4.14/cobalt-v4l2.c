static int cobalt_queue_setup(struct vb2_queue *q,\r\nunsigned int *num_buffers, unsigned int *num_planes,\r\nunsigned int sizes[], struct device *alloc_devs[])\r\n{\r\nstruct cobalt_stream *s = q->drv_priv;\r\nunsigned size = s->stride * s->height;\r\nif (*num_buffers < 3)\r\n*num_buffers = 3;\r\nif (*num_buffers > NR_BUFS)\r\n*num_buffers = NR_BUFS;\r\nif (*num_planes)\r\nreturn sizes[0] < size ? -EINVAL : 0;\r\n*num_planes = 1;\r\nsizes[0] = size;\r\nreturn 0;\r\n}\r\nstatic int cobalt_buf_init(struct vb2_buffer *vb)\r\n{\r\nstruct cobalt_stream *s = vb->vb2_queue->drv_priv;\r\nstruct cobalt *cobalt = s->cobalt;\r\nconst size_t max_pages_per_line =\r\n(COBALT_MAX_WIDTH * COBALT_MAX_BPP) / PAGE_SIZE + 2;\r\nconst size_t bytes =\r\nCOBALT_MAX_HEIGHT * max_pages_per_line * 0x20;\r\nconst size_t audio_bytes = ((1920 * 4) / PAGE_SIZE + 1) * 0x20;\r\nstruct sg_dma_desc_info *desc = &s->dma_desc_info[vb->index];\r\nstruct sg_table *sg_desc = vb2_dma_sg_plane_desc(vb, 0);\r\nunsigned size;\r\nint ret;\r\nsize = s->stride * s->height;\r\nif (vb2_plane_size(vb, 0) < size) {\r\ncobalt_info("data will not fit into plane (%lu < %u)\n",\r\nvb2_plane_size(vb, 0), size);\r\nreturn -EINVAL;\r\n}\r\nif (desc->virt == NULL) {\r\ndesc->dev = &cobalt->pci_dev->dev;\r\ndescriptor_list_allocate(desc,\r\ns->is_audio ? audio_bytes : bytes);\r\nif (desc->virt == NULL)\r\nreturn -ENOMEM;\r\n}\r\nret = descriptor_list_create(cobalt, sg_desc->sgl,\r\n!s->is_output, sg_desc->nents, size,\r\ns->width * s->bpp, s->stride, desc);\r\nif (ret)\r\ndescriptor_list_free(desc);\r\nreturn ret;\r\n}\r\nstatic void cobalt_buf_cleanup(struct vb2_buffer *vb)\r\n{\r\nstruct cobalt_stream *s = vb->vb2_queue->drv_priv;\r\nstruct sg_dma_desc_info *desc = &s->dma_desc_info[vb->index];\r\ndescriptor_list_free(desc);\r\n}\r\nstatic int cobalt_buf_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct cobalt_stream *s = vb->vb2_queue->drv_priv;\r\nvb2_set_plane_payload(vb, 0, s->stride * s->height);\r\nvbuf->field = V4L2_FIELD_NONE;\r\nreturn 0;\r\n}\r\nstatic void chain_all_buffers(struct cobalt_stream *s)\r\n{\r\nstruct sg_dma_desc_info *desc[NR_BUFS];\r\nstruct cobalt_buffer *cb;\r\nstruct list_head *p;\r\nint i = 0;\r\nlist_for_each(p, &s->bufs) {\r\ncb = list_entry(p, struct cobalt_buffer, list);\r\ndesc[i] = &s->dma_desc_info[cb->vb.vb2_buf.index];\r\nif (i > 0)\r\ndescriptor_list_chain(desc[i-1], desc[i]);\r\ni++;\r\n}\r\n}\r\nstatic void cobalt_buf_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct vb2_queue *q = vb->vb2_queue;\r\nstruct cobalt_stream *s = q->drv_priv;\r\nstruct cobalt_buffer *cb = to_cobalt_buffer(vbuf);\r\nstruct sg_dma_desc_info *desc = &s->dma_desc_info[vb->index];\r\nunsigned long flags;\r\ndescriptor_list_loopback(desc);\r\ndescriptor_list_interrupt_disable(desc);\r\nspin_lock_irqsave(&s->irqlock, flags);\r\nlist_add_tail(&cb->list, &s->bufs);\r\nchain_all_buffers(s);\r\nspin_unlock_irqrestore(&s->irqlock, flags);\r\n}\r\nstatic void cobalt_enable_output(struct cobalt_stream *s)\r\n{\r\nstruct cobalt *cobalt = s->cobalt;\r\nstruct v4l2_bt_timings *bt = &s->timings.bt;\r\nstruct m00514_syncgen_flow_evcnt_regmap __iomem *vo =\r\nCOBALT_TX_BASE(cobalt);\r\nunsigned fmt = s->pixfmt != V4L2_PIX_FMT_BGR32 ?\r\nM00514_CONTROL_BITMAP_FORMAT_16_BPP_MSK : 0;\r\nstruct v4l2_subdev_format sd_fmt = {\r\n.which = V4L2_SUBDEV_FORMAT_ACTIVE,\r\n};\r\nu64 clk = bt->pixelclock;\r\nif (bt->flags & V4L2_DV_FL_REDUCED_FPS)\r\nclk = div_u64(clk * 1000ULL, 1001);\r\nif (!cobalt_cpld_set_freq(cobalt, clk)) {\r\ncobalt_err("pixelclock out of range\n");\r\nreturn;\r\n}\r\nsd_fmt.format.colorspace = s->colorspace;\r\nsd_fmt.format.xfer_func = s->xfer_func;\r\nsd_fmt.format.ycbcr_enc = s->ycbcr_enc;\r\nsd_fmt.format.quantization = s->quantization;\r\nsd_fmt.format.width = bt->width;\r\nsd_fmt.format.height = bt->height;\r\nswitch (s->pixfmt) {\r\ncase V4L2_PIX_FMT_YUYV:\r\nsd_fmt.format.code = MEDIA_BUS_FMT_UYVY8_1X16;\r\nbreak;\r\ncase V4L2_PIX_FMT_BGR32:\r\nsd_fmt.format.code = MEDIA_BUS_FMT_RGB888_1X24;\r\nbreak;\r\n}\r\nv4l2_subdev_call(s->sd, pad, set_fmt, NULL, &sd_fmt);\r\niowrite32(0, &vo->control);\r\niowrite32(bt->hsync, &vo->sync_generator_h_sync_length);\r\niowrite32(bt->hbackporch, &vo->sync_generator_h_backporch_length);\r\niowrite32(bt->width, &vo->sync_generator_h_active_length);\r\niowrite32(bt->hfrontporch, &vo->sync_generator_h_frontporch_length);\r\niowrite32(bt->vsync, &vo->sync_generator_v_sync_length);\r\niowrite32(bt->vbackporch, &vo->sync_generator_v_backporch_length);\r\niowrite32(bt->height, &vo->sync_generator_v_active_length);\r\niowrite32(bt->vfrontporch, &vo->sync_generator_v_frontporch_length);\r\niowrite32(0x9900c1, &vo->error_color);\r\niowrite32(M00514_CONTROL_BITMAP_SYNC_GENERATOR_LOAD_PARAM_MSK | fmt,\r\n&vo->control);\r\niowrite32(M00514_CONTROL_BITMAP_EVCNT_CLEAR_MSK | fmt, &vo->control);\r\niowrite32(M00514_CONTROL_BITMAP_SYNC_GENERATOR_ENABLE_MSK |\r\nM00514_CONTROL_BITMAP_FLOW_CTRL_OUTPUT_ENABLE_MSK |\r\nfmt, &vo->control);\r\n}\r\nstatic void cobalt_enable_input(struct cobalt_stream *s)\r\n{\r\nstruct cobalt *cobalt = s->cobalt;\r\nint ch = (int)s->video_channel;\r\nstruct m00235_fdma_packer_regmap __iomem *packer;\r\nstruct v4l2_subdev_format sd_fmt_yuyv = {\r\n.pad = s->pad_source,\r\n.which = V4L2_SUBDEV_FORMAT_ACTIVE,\r\n.format.code = MEDIA_BUS_FMT_YUYV8_1X16,\r\n};\r\nstruct v4l2_subdev_format sd_fmt_rgb = {\r\n.pad = s->pad_source,\r\n.which = V4L2_SUBDEV_FORMAT_ACTIVE,\r\n.format.code = MEDIA_BUS_FMT_RGB888_1X24,\r\n};\r\ncobalt_dbg(1, "video_channel %d (%s, %s)\n",\r\ns->video_channel,\r\ns->input == 0 ? "hdmi" : "generator",\r\n"YUYV");\r\npacker = COBALT_CVI_PACKER(cobalt, ch);\r\nswitch (s->pixfmt) {\r\ncase V4L2_PIX_FMT_YUYV:\r\niowrite32(M00235_CONTROL_BITMAP_ENABLE_MSK |\r\n(1 << M00235_CONTROL_BITMAP_PACK_FORMAT_OFST),\r\n&packer->control);\r\nv4l2_subdev_call(s->sd, pad, set_fmt, NULL,\r\n&sd_fmt_yuyv);\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB24:\r\niowrite32(M00235_CONTROL_BITMAP_ENABLE_MSK |\r\n(2 << M00235_CONTROL_BITMAP_PACK_FORMAT_OFST),\r\n&packer->control);\r\nv4l2_subdev_call(s->sd, pad, set_fmt, NULL,\r\n&sd_fmt_rgb);\r\nbreak;\r\ncase V4L2_PIX_FMT_BGR32:\r\niowrite32(M00235_CONTROL_BITMAP_ENABLE_MSK |\r\nM00235_CONTROL_BITMAP_ENDIAN_FORMAT_MSK |\r\n(3 << M00235_CONTROL_BITMAP_PACK_FORMAT_OFST),\r\n&packer->control);\r\nv4l2_subdev_call(s->sd, pad, set_fmt, NULL,\r\n&sd_fmt_rgb);\r\nbreak;\r\n}\r\n}\r\nstatic void cobalt_dma_start_streaming(struct cobalt_stream *s)\r\n{\r\nstruct cobalt *cobalt = s->cobalt;\r\nint rx = s->video_channel;\r\nstruct m00460_evcnt_regmap __iomem *evcnt =\r\nCOBALT_CVI_EVCNT(cobalt, rx);\r\nstruct cobalt_buffer *cb;\r\nunsigned long flags;\r\nspin_lock_irqsave(&s->irqlock, flags);\r\nif (!s->is_output) {\r\niowrite32(M00460_CONTROL_BITMAP_CLEAR_MSK, &evcnt->control);\r\niowrite32(M00460_CONTROL_BITMAP_ENABLE_MSK, &evcnt->control);\r\n} else {\r\nstruct m00514_syncgen_flow_evcnt_regmap __iomem *vo =\r\nCOBALT_TX_BASE(cobalt);\r\nu32 ctrl = ioread32(&vo->control);\r\nctrl &= ~(M00514_CONTROL_BITMAP_EVCNT_ENABLE_MSK |\r\nM00514_CONTROL_BITMAP_EVCNT_CLEAR_MSK);\r\niowrite32(ctrl | M00514_CONTROL_BITMAP_EVCNT_CLEAR_MSK,\r\n&vo->control);\r\niowrite32(ctrl | M00514_CONTROL_BITMAP_EVCNT_ENABLE_MSK,\r\n&vo->control);\r\n}\r\ncb = list_first_entry(&s->bufs, struct cobalt_buffer, list);\r\nomni_sg_dma_start(s, &s->dma_desc_info[cb->vb.vb2_buf.index]);\r\nspin_unlock_irqrestore(&s->irqlock, flags);\r\n}\r\nstatic int cobalt_start_streaming(struct vb2_queue *q, unsigned int count)\r\n{\r\nstruct cobalt_stream *s = q->drv_priv;\r\nstruct cobalt *cobalt = s->cobalt;\r\nstruct m00233_video_measure_regmap __iomem *vmr;\r\nstruct m00473_freewheel_regmap __iomem *fw;\r\nstruct m00479_clk_loss_detector_regmap __iomem *clkloss;\r\nint rx = s->video_channel;\r\nstruct m00389_cvi_regmap __iomem *cvi = COBALT_CVI(cobalt, rx);\r\nstruct m00460_evcnt_regmap __iomem *evcnt = COBALT_CVI_EVCNT(cobalt, rx);\r\nstruct v4l2_bt_timings *bt = &s->timings.bt;\r\nu64 tot_size;\r\nu32 clk_freq;\r\nif (s->is_audio)\r\ngoto done;\r\nif (s->is_output) {\r\ns->unstable_frame = false;\r\ncobalt_enable_output(s);\r\ngoto done;\r\n}\r\ncobalt_enable_input(s);\r\nfw = COBALT_CVI_FREEWHEEL(cobalt, rx);\r\nvmr = COBALT_CVI_VMR(cobalt, rx);\r\nclkloss = COBALT_CVI_CLK_LOSS(cobalt, rx);\r\niowrite32(M00460_CONTROL_BITMAP_CLEAR_MSK, &evcnt->control);\r\niowrite32(M00460_CONTROL_BITMAP_ENABLE_MSK, &evcnt->control);\r\niowrite32(bt->width, &cvi->frame_width);\r\niowrite32(bt->height, &cvi->frame_height);\r\ntot_size = V4L2_DV_BT_FRAME_WIDTH(bt) * V4L2_DV_BT_FRAME_HEIGHT(bt);\r\niowrite32(div_u64((u64)V4L2_DV_BT_FRAME_WIDTH(bt) * COBALT_CLK * 4,\r\nbt->pixelclock), &vmr->hsync_timeout_val);\r\niowrite32(M00233_CONTROL_BITMAP_ENABLE_MEASURE_MSK, &vmr->control);\r\nclk_freq = ioread32(&fw->clk_freq);\r\niowrite32(clk_freq / 1000000, &clkloss->ref_clk_cnt_val);\r\niowrite32(div_u64(bt->pixelclock * 995, 1000000000),\r\n&clkloss->test_clk_cnt_val);\r\niowrite32(bt->width * bt->height, &fw->active_length);\r\niowrite32(div_u64((u64)clk_freq * tot_size, bt->pixelclock),\r\n&fw->total_length);\r\niowrite32(M00233_IRQ_TRIGGERS_BITMAP_VACTIVE_AREA_MSK |\r\nM00233_IRQ_TRIGGERS_BITMAP_HACTIVE_AREA_MSK,\r\n&vmr->irq_triggers);\r\niowrite32(0, &cvi->control);\r\niowrite32(M00233_CONTROL_BITMAP_ENABLE_MEASURE_MSK, &vmr->control);\r\niowrite32(0xff, &fw->output_color);\r\niowrite32(M00479_CTRL_BITMAP_ENABLE_MSK, &clkloss->ctrl);\r\niowrite32(M00473_CTRL_BITMAP_ENABLE_MSK |\r\nM00473_CTRL_BITMAP_FORCE_FREEWHEEL_MODE_MSK, &fw->ctrl);\r\ns->unstable_frame = true;\r\ns->enable_freewheel = false;\r\ns->enable_cvi = false;\r\ns->skip_first_frames = 0;\r\ndone:\r\ns->sequence = 0;\r\ncobalt_dma_start_streaming(s);\r\nreturn 0;\r\n}\r\nstatic void cobalt_dma_stop_streaming(struct cobalt_stream *s)\r\n{\r\nstruct cobalt *cobalt = s->cobalt;\r\nstruct sg_dma_desc_info *desc;\r\nstruct cobalt_buffer *cb;\r\nstruct list_head *p;\r\nunsigned long flags;\r\nint timeout_msec = 100;\r\nint rx = s->video_channel;\r\nstruct m00460_evcnt_regmap __iomem *evcnt =\r\nCOBALT_CVI_EVCNT(cobalt, rx);\r\nif (!s->is_output) {\r\niowrite32(0, &evcnt->control);\r\n} else if (!s->is_audio) {\r\nstruct m00514_syncgen_flow_evcnt_regmap __iomem *vo =\r\nCOBALT_TX_BASE(cobalt);\r\niowrite32(M00514_CONTROL_BITMAP_EVCNT_CLEAR_MSK, &vo->control);\r\niowrite32(0, &vo->control);\r\n}\r\nspin_lock_irqsave(&s->irqlock, flags);\r\nlist_for_each(p, &s->bufs) {\r\ncb = list_entry(p, struct cobalt_buffer, list);\r\ndesc = &s->dma_desc_info[cb->vb.vb2_buf.index];\r\ndescriptor_list_end_of_chain(desc);\r\n}\r\nspin_unlock_irqrestore(&s->irqlock, flags);\r\nif (!wait_event_timeout(s->q.done_wq, is_dma_done(s),\r\nmsecs_to_jiffies(timeout_msec))) {\r\nomni_sg_dma_abort_channel(s);\r\npr_warn("aborted\n");\r\n}\r\ncobalt_write_bar0(cobalt, DMA_INTERRUPT_STATUS_REG,\r\n1 << s->dma_channel);\r\n}\r\nstatic void cobalt_stop_streaming(struct vb2_queue *q)\r\n{\r\nstruct cobalt_stream *s = q->drv_priv;\r\nstruct cobalt *cobalt = s->cobalt;\r\nint rx = s->video_channel;\r\nstruct m00233_video_measure_regmap __iomem *vmr;\r\nstruct m00473_freewheel_regmap __iomem *fw;\r\nstruct m00479_clk_loss_detector_regmap __iomem *clkloss;\r\nstruct cobalt_buffer *cb;\r\nstruct list_head *p, *safe;\r\nunsigned long flags;\r\ncobalt_dma_stop_streaming(s);\r\nspin_lock_irqsave(&s->irqlock, flags);\r\nlist_for_each_safe(p, safe, &s->bufs) {\r\ncb = list_entry(p, struct cobalt_buffer, list);\r\nlist_del(&cb->list);\r\nvb2_buffer_done(&cb->vb.vb2_buf, VB2_BUF_STATE_ERROR);\r\n}\r\nspin_unlock_irqrestore(&s->irqlock, flags);\r\nif (s->is_audio || s->is_output)\r\nreturn;\r\nfw = COBALT_CVI_FREEWHEEL(cobalt, rx);\r\nvmr = COBALT_CVI_VMR(cobalt, rx);\r\nclkloss = COBALT_CVI_CLK_LOSS(cobalt, rx);\r\niowrite32(0, &vmr->control);\r\niowrite32(M00233_CONTROL_BITMAP_ENABLE_MEASURE_MSK, &vmr->control);\r\niowrite32(0, &fw->ctrl);\r\niowrite32(0, &clkloss->ctrl);\r\n}\r\nstatic int cobalt_cobaltc(struct cobalt *cobalt, unsigned int cmd, void *arg)\r\n{\r\nstruct v4l2_dbg_register *regs = arg;\r\nvoid __iomem *adrs = cobalt->bar1 + regs->reg;\r\ncobalt_info("cobalt_cobaltc: adrs = %p\n", adrs);\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nregs->size = 4;\r\nif (cmd == VIDIOC_DBG_S_REGISTER)\r\niowrite32(regs->val, adrs);\r\nelse\r\nregs->val = ioread32(adrs);\r\nreturn 0;\r\n}\r\nstatic int cobalt_g_register(struct file *file, void *priv_fh,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct cobalt_stream *s = video_drvdata(file);\r\nstruct cobalt *cobalt = s->cobalt;\r\nreturn cobalt_cobaltc(cobalt, VIDIOC_DBG_G_REGISTER, reg);\r\n}\r\nstatic int cobalt_s_register(struct file *file, void *priv_fh,\r\nconst struct v4l2_dbg_register *reg)\r\n{\r\nstruct cobalt_stream *s = video_drvdata(file);\r\nstruct cobalt *cobalt = s->cobalt;\r\nreturn cobalt_cobaltc(cobalt, VIDIOC_DBG_S_REGISTER,\r\n(struct v4l2_dbg_register *)reg);\r\n}\r\nstatic int cobalt_querycap(struct file *file, void *priv_fh,\r\nstruct v4l2_capability *vcap)\r\n{\r\nstruct cobalt_stream *s = video_drvdata(file);\r\nstruct cobalt *cobalt = s->cobalt;\r\nstrlcpy(vcap->driver, "cobalt", sizeof(vcap->driver));\r\nstrlcpy(vcap->card, "cobalt", sizeof(vcap->card));\r\nsnprintf(vcap->bus_info, sizeof(vcap->bus_info),\r\n"PCIe:%s", pci_name(cobalt->pci_dev));\r\nvcap->device_caps = V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;\r\nif (s->is_output)\r\nvcap->device_caps |= V4L2_CAP_VIDEO_OUTPUT;\r\nelse\r\nvcap->device_caps |= V4L2_CAP_VIDEO_CAPTURE;\r\nvcap->capabilities = vcap->device_caps | V4L2_CAP_DEVICE_CAPS |\r\nV4L2_CAP_VIDEO_CAPTURE;\r\nif (cobalt->have_hsma_tx)\r\nvcap->capabilities |= V4L2_CAP_VIDEO_OUTPUT;\r\nreturn 0;\r\n}\r\nstatic void cobalt_video_input_status_show(struct cobalt_stream *s)\r\n{\r\nstruct m00389_cvi_regmap __iomem *cvi;\r\nstruct m00233_video_measure_regmap __iomem *vmr;\r\nstruct m00473_freewheel_regmap __iomem *fw;\r\nstruct m00479_clk_loss_detector_regmap __iomem *clkloss;\r\nstruct m00235_fdma_packer_regmap __iomem *packer;\r\nint rx = s->video_channel;\r\nstruct cobalt *cobalt = s->cobalt;\r\nu32 cvi_ctrl, cvi_stat;\r\nu32 vmr_ctrl, vmr_stat;\r\ncvi = COBALT_CVI(cobalt, rx);\r\nvmr = COBALT_CVI_VMR(cobalt, rx);\r\nfw = COBALT_CVI_FREEWHEEL(cobalt, rx);\r\nclkloss = COBALT_CVI_CLK_LOSS(cobalt, rx);\r\npacker = COBALT_CVI_PACKER(cobalt, rx);\r\ncvi_ctrl = ioread32(&cvi->control);\r\ncvi_stat = ioread32(&cvi->status);\r\nvmr_ctrl = ioread32(&vmr->control);\r\nvmr_stat = ioread32(&vmr->status);\r\ncobalt_info("rx%d: cvi resolution: %dx%d\n", rx,\r\nioread32(&cvi->frame_width), ioread32(&cvi->frame_height));\r\ncobalt_info("rx%d: cvi control: %s%s%s\n", rx,\r\n(cvi_ctrl & M00389_CONTROL_BITMAP_ENABLE_MSK) ?\r\n"enable " : "disable ",\r\n(cvi_ctrl & M00389_CONTROL_BITMAP_HSYNC_POLARITY_LOW_MSK) ?\r\n"HSync- " : "HSync+ ",\r\n(cvi_ctrl & M00389_CONTROL_BITMAP_VSYNC_POLARITY_LOW_MSK) ?\r\n"VSync- " : "VSync+ ");\r\ncobalt_info("rx%d: cvi status: %s%s\n", rx,\r\n(cvi_stat & M00389_STATUS_BITMAP_LOCK_MSK) ?\r\n"lock " : "no-lock ",\r\n(cvi_stat & M00389_STATUS_BITMAP_ERROR_MSK) ?\r\n"error " : "no-error ");\r\ncobalt_info("rx%d: Measurements: %s%s%s%s%s%s%s\n", rx,\r\n(vmr_ctrl & M00233_CONTROL_BITMAP_HSYNC_POLARITY_LOW_MSK) ?\r\n"HSync- " : "HSync+ ",\r\n(vmr_ctrl & M00233_CONTROL_BITMAP_VSYNC_POLARITY_LOW_MSK) ?\r\n"VSync- " : "VSync+ ",\r\n(vmr_ctrl & M00233_CONTROL_BITMAP_ENABLE_MEASURE_MSK) ?\r\n"enabled " : "disabled ",\r\n(vmr_ctrl & M00233_CONTROL_BITMAP_ENABLE_INTERRUPT_MSK) ?\r\n"irq-enabled " : "irq-disabled ",\r\n(vmr_ctrl & M00233_CONTROL_BITMAP_UPDATE_ON_HSYNC_MSK) ?\r\n"update-on-hsync " : "",\r\n(vmr_stat & M00233_STATUS_BITMAP_HSYNC_TIMEOUT_MSK) ?\r\n"hsync-timeout " : "",\r\n(vmr_stat & M00233_STATUS_BITMAP_INIT_DONE_MSK) ?\r\n"init-done" : "");\r\ncobalt_info("rx%d: irq_status: 0x%02x irq_triggers: 0x%02x\n", rx,\r\nioread32(&vmr->irq_status) & 0xff,\r\nioread32(&vmr->irq_triggers) & 0xff);\r\ncobalt_info("rx%d: vsync: %d\n", rx, ioread32(&vmr->vsync_time));\r\ncobalt_info("rx%d: vbp: %d\n", rx, ioread32(&vmr->vback_porch));\r\ncobalt_info("rx%d: vact: %d\n", rx, ioread32(&vmr->vactive_area));\r\ncobalt_info("rx%d: vfb: %d\n", rx, ioread32(&vmr->vfront_porch));\r\ncobalt_info("rx%d: hsync: %d\n", rx, ioread32(&vmr->hsync_time));\r\ncobalt_info("rx%d: hbp: %d\n", rx, ioread32(&vmr->hback_porch));\r\ncobalt_info("rx%d: hact: %d\n", rx, ioread32(&vmr->hactive_area));\r\ncobalt_info("rx%d: hfb: %d\n", rx, ioread32(&vmr->hfront_porch));\r\ncobalt_info("rx%d: Freewheeling: %s%s%s\n", rx,\r\n(ioread32(&fw->ctrl) & M00473_CTRL_BITMAP_ENABLE_MSK) ?\r\n"enabled " : "disabled ",\r\n(ioread32(&fw->ctrl) & M00473_CTRL_BITMAP_FORCE_FREEWHEEL_MODE_MSK) ?\r\n"forced " : "",\r\n(ioread32(&fw->status) & M00473_STATUS_BITMAP_FREEWHEEL_MODE_MSK) ?\r\n"freewheeling " : "video-passthrough ");\r\niowrite32(0xff, &vmr->irq_status);\r\ncobalt_info("rx%d: Clock Loss Detection: %s%s\n", rx,\r\n(ioread32(&clkloss->ctrl) & M00479_CTRL_BITMAP_ENABLE_MSK) ?\r\n"enabled " : "disabled ",\r\n(ioread32(&clkloss->status) & M00479_STATUS_BITMAP_CLOCK_MISSING_MSK) ?\r\n"clock-missing " : "found-clock ");\r\ncobalt_info("rx%d: Packer: %x\n", rx, ioread32(&packer->control));\r\n}\r\nstatic int cobalt_log_status(struct file *file, void *priv_fh)\r\n{\r\nstruct cobalt_stream *s = video_drvdata(file);\r\nstruct cobalt *cobalt = s->cobalt;\r\nstruct m00514_syncgen_flow_evcnt_regmap __iomem *vo =\r\nCOBALT_TX_BASE(cobalt);\r\nu8 stat;\r\ncobalt_info("%s", cobalt->hdl_info);\r\ncobalt_info("sysctrl: %08x, sysstat: %08x\n",\r\ncobalt_g_sysctrl(cobalt),\r\ncobalt_g_sysstat(cobalt));\r\ncobalt_info("dma channel: %d, video channel: %d\n",\r\ns->dma_channel, s->video_channel);\r\ncobalt_pcie_status_show(cobalt);\r\ncobalt_cpld_status(cobalt);\r\ncobalt_irq_log_status(cobalt);\r\nv4l2_subdev_call(s->sd, core, log_status);\r\nif (!s->is_output) {\r\ncobalt_video_input_status_show(s);\r\nreturn 0;\r\n}\r\nstat = ioread32(&vo->rd_status);\r\ncobalt_info("tx: status: %s%s\n",\r\n(stat & M00514_RD_STATUS_BITMAP_FLOW_CTRL_NO_DATA_ERROR_MSK) ?\r\n"no_data " : "",\r\n(stat & M00514_RD_STATUS_BITMAP_READY_BUFFER_FULL_MSK) ?\r\n"ready_buffer_full " : "");\r\ncobalt_info("tx: evcnt: %d\n", ioread32(&vo->rd_evcnt_count));\r\nreturn 0;\r\n}\r\nstatic int cobalt_enum_dv_timings(struct file *file, void *priv_fh,\r\nstruct v4l2_enum_dv_timings *timings)\r\n{\r\nstruct cobalt_stream *s = video_drvdata(file);\r\nif (s->input == 1) {\r\nif (timings->index)\r\nreturn -EINVAL;\r\nmemset(timings->reserved, 0, sizeof(timings->reserved));\r\ntimings->timings = cea1080p60;\r\nreturn 0;\r\n}\r\ntimings->pad = 0;\r\nreturn v4l2_subdev_call(s->sd,\r\npad, enum_dv_timings, timings);\r\n}\r\nstatic int cobalt_s_dv_timings(struct file *file, void *priv_fh,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct cobalt_stream *s = video_drvdata(file);\r\nint err;\r\nif (s->input == 1) {\r\n*timings = cea1080p60;\r\nreturn 0;\r\n}\r\nif (v4l2_match_dv_timings(timings, &s->timings, 0, true))\r\nreturn 0;\r\nif (vb2_is_busy(&s->q))\r\nreturn -EBUSY;\r\nerr = v4l2_subdev_call(s->sd,\r\nvideo, s_dv_timings, timings);\r\nif (!err) {\r\ns->timings = *timings;\r\ns->width = timings->bt.width;\r\ns->height = timings->bt.height;\r\ns->stride = timings->bt.width * s->bpp;\r\n}\r\nreturn err;\r\n}\r\nstatic int cobalt_g_dv_timings(struct file *file, void *priv_fh,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct cobalt_stream *s = video_drvdata(file);\r\nif (s->input == 1) {\r\n*timings = cea1080p60;\r\nreturn 0;\r\n}\r\nreturn v4l2_subdev_call(s->sd,\r\nvideo, g_dv_timings, timings);\r\n}\r\nstatic int cobalt_query_dv_timings(struct file *file, void *priv_fh,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct cobalt_stream *s = video_drvdata(file);\r\nif (s->input == 1) {\r\n*timings = cea1080p60;\r\nreturn 0;\r\n}\r\nreturn v4l2_subdev_call(s->sd,\r\nvideo, query_dv_timings, timings);\r\n}\r\nstatic int cobalt_dv_timings_cap(struct file *file, void *priv_fh,\r\nstruct v4l2_dv_timings_cap *cap)\r\n{\r\nstruct cobalt_stream *s = video_drvdata(file);\r\ncap->pad = 0;\r\nreturn v4l2_subdev_call(s->sd,\r\npad, dv_timings_cap, cap);\r\n}\r\nstatic int cobalt_enum_fmt_vid_cap(struct file *file, void *priv_fh,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nswitch (f->index) {\r\ncase 0:\r\nstrlcpy(f->description, "YUV 4:2:2", sizeof(f->description));\r\nf->pixelformat = V4L2_PIX_FMT_YUYV;\r\nbreak;\r\ncase 1:\r\nstrlcpy(f->description, "RGB24", sizeof(f->description));\r\nf->pixelformat = V4L2_PIX_FMT_RGB24;\r\nbreak;\r\ncase 2:\r\nstrlcpy(f->description, "RGB32", sizeof(f->description));\r\nf->pixelformat = V4L2_PIX_FMT_BGR32;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cobalt_g_fmt_vid_cap(struct file *file, void *priv_fh,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cobalt_stream *s = video_drvdata(file);\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nstruct v4l2_subdev_format sd_fmt;\r\npix->width = s->width;\r\npix->height = s->height;\r\npix->bytesperline = s->stride;\r\npix->field = V4L2_FIELD_NONE;\r\nif (s->input == 1) {\r\npix->colorspace = V4L2_COLORSPACE_SRGB;\r\n} else {\r\nsd_fmt.pad = s->pad_source;\r\nsd_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;\r\nv4l2_subdev_call(s->sd, pad, get_fmt, NULL, &sd_fmt);\r\nv4l2_fill_pix_format(pix, &sd_fmt.format);\r\n}\r\npix->pixelformat = s->pixfmt;\r\npix->sizeimage = pix->bytesperline * pix->height;\r\nreturn 0;\r\n}\r\nstatic int cobalt_try_fmt_vid_cap(struct file *file, void *priv_fh,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cobalt_stream *s = video_drvdata(file);\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nstruct v4l2_subdev_format sd_fmt;\r\nif ((pix->width < 176) || (pix->height < 144)) {\r\npix->width = 176;\r\npix->height = 144;\r\n}\r\nif ((pix->width > 1920) || (pix->height > 1080)) {\r\npix->width = 1920;\r\npix->height = 1080;\r\n}\r\npix->width &= ~0x3;\r\npix->height &= ~0x1;\r\nif (s->input == 1) {\r\npix->width = 1920;\r\npix->height = 1080;\r\npix->colorspace = V4L2_COLORSPACE_SRGB;\r\n} else {\r\nsd_fmt.pad = s->pad_source;\r\nsd_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;\r\nv4l2_subdev_call(s->sd, pad, get_fmt, NULL, &sd_fmt);\r\nv4l2_fill_pix_format(pix, &sd_fmt.format);\r\n}\r\nswitch (pix->pixelformat) {\r\ncase V4L2_PIX_FMT_YUYV:\r\ndefault:\r\npix->bytesperline = max(pix->bytesperline & ~0x3,\r\npix->width * COBALT_BYTES_PER_PIXEL_YUYV);\r\npix->pixelformat = V4L2_PIX_FMT_YUYV;\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB24:\r\npix->bytesperline = max(pix->bytesperline & ~0x3,\r\npix->width * COBALT_BYTES_PER_PIXEL_RGB24);\r\nbreak;\r\ncase V4L2_PIX_FMT_BGR32:\r\npix->bytesperline = max(pix->bytesperline & ~0x3,\r\npix->width * COBALT_BYTES_PER_PIXEL_RGB32);\r\nbreak;\r\n}\r\npix->sizeimage = pix->bytesperline * pix->height;\r\npix->field = V4L2_FIELD_NONE;\r\npix->priv = 0;\r\nreturn 0;\r\n}\r\nstatic int cobalt_s_fmt_vid_cap(struct file *file, void *priv_fh,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cobalt_stream *s = video_drvdata(file);\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nif (vb2_is_busy(&s->q))\r\nreturn -EBUSY;\r\nif (cobalt_try_fmt_vid_cap(file, priv_fh, f))\r\nreturn -EINVAL;\r\ns->width = pix->width;\r\ns->height = pix->height;\r\ns->stride = pix->bytesperline;\r\nswitch (pix->pixelformat) {\r\ncase V4L2_PIX_FMT_YUYV:\r\ns->bpp = COBALT_BYTES_PER_PIXEL_YUYV;\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB24:\r\ns->bpp = COBALT_BYTES_PER_PIXEL_RGB24;\r\nbreak;\r\ncase V4L2_PIX_FMT_BGR32:\r\ns->bpp = COBALT_BYTES_PER_PIXEL_RGB32;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ns->pixfmt = pix->pixelformat;\r\ncobalt_enable_input(s);\r\nreturn 0;\r\n}\r\nstatic int cobalt_try_fmt_vid_out(struct file *file, void *priv_fh,\r\nstruct v4l2_format *f)\r\n{\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nif ((pix->width < 176) || (pix->height < 144)) {\r\npix->width = 176;\r\npix->height = 144;\r\n}\r\nif ((pix->width > 1920) || (pix->height > 1080)) {\r\npix->width = 1920;\r\npix->height = 1080;\r\n}\r\npix->width &= ~0x3;\r\npix->height &= ~0x1;\r\nswitch (pix->pixelformat) {\r\ncase V4L2_PIX_FMT_YUYV:\r\ndefault:\r\npix->bytesperline = max(pix->bytesperline & ~0x3,\r\npix->width * COBALT_BYTES_PER_PIXEL_YUYV);\r\npix->pixelformat = V4L2_PIX_FMT_YUYV;\r\nbreak;\r\ncase V4L2_PIX_FMT_BGR32:\r\npix->bytesperline = max(pix->bytesperline & ~0x3,\r\npix->width * COBALT_BYTES_PER_PIXEL_RGB32);\r\nbreak;\r\n}\r\npix->sizeimage = pix->bytesperline * pix->height;\r\npix->field = V4L2_FIELD_NONE;\r\nreturn 0;\r\n}\r\nstatic int cobalt_g_fmt_vid_out(struct file *file, void *priv_fh,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cobalt_stream *s = video_drvdata(file);\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\npix->width = s->width;\r\npix->height = s->height;\r\npix->bytesperline = s->stride;\r\npix->field = V4L2_FIELD_NONE;\r\npix->pixelformat = s->pixfmt;\r\npix->colorspace = s->colorspace;\r\npix->xfer_func = s->xfer_func;\r\npix->ycbcr_enc = s->ycbcr_enc;\r\npix->quantization = s->quantization;\r\npix->sizeimage = pix->bytesperline * pix->height;\r\nreturn 0;\r\n}\r\nstatic int cobalt_enum_fmt_vid_out(struct file *file, void *priv_fh,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nswitch (f->index) {\r\ncase 0:\r\nstrlcpy(f->description, "YUV 4:2:2", sizeof(f->description));\r\nf->pixelformat = V4L2_PIX_FMT_YUYV;\r\nbreak;\r\ncase 1:\r\nstrlcpy(f->description, "RGB32", sizeof(f->description));\r\nf->pixelformat = V4L2_PIX_FMT_BGR32;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cobalt_s_fmt_vid_out(struct file *file, void *priv_fh,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cobalt_stream *s = video_drvdata(file);\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nstruct v4l2_subdev_format sd_fmt = { 0 };\r\nu32 code;\r\nif (cobalt_try_fmt_vid_out(file, priv_fh, f))\r\nreturn -EINVAL;\r\nif (vb2_is_busy(&s->q) && (pix->pixelformat != s->pixfmt ||\r\npix->width != s->width || pix->height != s->height ||\r\npix->bytesperline != s->stride))\r\nreturn -EBUSY;\r\nswitch (pix->pixelformat) {\r\ncase V4L2_PIX_FMT_YUYV:\r\ns->bpp = COBALT_BYTES_PER_PIXEL_YUYV;\r\ncode = MEDIA_BUS_FMT_UYVY8_1X16;\r\nbreak;\r\ncase V4L2_PIX_FMT_BGR32:\r\ns->bpp = COBALT_BYTES_PER_PIXEL_RGB32;\r\ncode = MEDIA_BUS_FMT_RGB888_1X24;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ns->width = pix->width;\r\ns->height = pix->height;\r\ns->stride = pix->bytesperline;\r\ns->pixfmt = pix->pixelformat;\r\ns->colorspace = pix->colorspace;\r\ns->xfer_func = pix->xfer_func;\r\ns->ycbcr_enc = pix->ycbcr_enc;\r\ns->quantization = pix->quantization;\r\nsd_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;\r\nv4l2_fill_mbus_format(&sd_fmt.format, pix, code);\r\nv4l2_subdev_call(s->sd, pad, set_fmt, NULL, &sd_fmt);\r\nreturn 0;\r\n}\r\nstatic int cobalt_enum_input(struct file *file, void *priv_fh,\r\nstruct v4l2_input *inp)\r\n{\r\nstruct cobalt_stream *s = video_drvdata(file);\r\nif (inp->index > 1)\r\nreturn -EINVAL;\r\nif (inp->index == 0)\r\nsnprintf(inp->name, sizeof(inp->name),\r\n"HDMI-%d", s->video_channel);\r\nelse\r\nsnprintf(inp->name, sizeof(inp->name),\r\n"Generator-%d", s->video_channel);\r\ninp->type = V4L2_INPUT_TYPE_CAMERA;\r\ninp->capabilities = V4L2_IN_CAP_DV_TIMINGS;\r\nif (inp->index == 1)\r\nreturn 0;\r\nreturn v4l2_subdev_call(s->sd,\r\nvideo, g_input_status, &inp->status);\r\n}\r\nstatic int cobalt_g_input(struct file *file, void *priv_fh, unsigned int *i)\r\n{\r\nstruct cobalt_stream *s = video_drvdata(file);\r\n*i = s->input;\r\nreturn 0;\r\n}\r\nstatic int cobalt_s_input(struct file *file, void *priv_fh, unsigned int i)\r\n{\r\nstruct cobalt_stream *s = video_drvdata(file);\r\nif (i >= 2)\r\nreturn -EINVAL;\r\nif (vb2_is_busy(&s->q))\r\nreturn -EBUSY;\r\ns->input = i;\r\ncobalt_enable_input(s);\r\nif (s->input == 1)\r\nreturn 0;\r\nreturn v4l2_subdev_call(s->sd, video, s_routing,\r\nADV76XX_PAD_HDMI_PORT_A, 0, 0);\r\n}\r\nstatic int cobalt_enum_output(struct file *file, void *priv_fh,\r\nstruct v4l2_output *out)\r\n{\r\nif (out->index)\r\nreturn -EINVAL;\r\nsnprintf(out->name, sizeof(out->name), "HDMI-%d", out->index);\r\nout->type = V4L2_OUTPUT_TYPE_ANALOG;\r\nout->capabilities = V4L2_OUT_CAP_DV_TIMINGS;\r\nreturn 0;\r\n}\r\nstatic int cobalt_g_output(struct file *file, void *priv_fh, unsigned int *i)\r\n{\r\n*i = 0;\r\nreturn 0;\r\n}\r\nstatic int cobalt_s_output(struct file *file, void *priv_fh, unsigned int i)\r\n{\r\nreturn i ? -EINVAL : 0;\r\n}\r\nstatic int cobalt_g_edid(struct file *file, void *fh, struct v4l2_edid *edid)\r\n{\r\nstruct cobalt_stream *s = video_drvdata(file);\r\nu32 pad = edid->pad;\r\nint ret;\r\nif (edid->pad >= (s->is_output ? 1 : 2))\r\nreturn -EINVAL;\r\nedid->pad = 0;\r\nret = v4l2_subdev_call(s->sd, pad, get_edid, edid);\r\nedid->pad = pad;\r\nreturn ret;\r\n}\r\nstatic int cobalt_s_edid(struct file *file, void *fh, struct v4l2_edid *edid)\r\n{\r\nstruct cobalt_stream *s = video_drvdata(file);\r\nu32 pad = edid->pad;\r\nint ret;\r\nif (edid->pad >= 2)\r\nreturn -EINVAL;\r\nedid->pad = 0;\r\nret = v4l2_subdev_call(s->sd, pad, set_edid, edid);\r\nedid->pad = pad;\r\nreturn ret;\r\n}\r\nstatic int cobalt_subscribe_event(struct v4l2_fh *fh,\r\nconst struct v4l2_event_subscription *sub)\r\n{\r\nswitch (sub->type) {\r\ncase V4L2_EVENT_SOURCE_CHANGE:\r\nreturn v4l2_event_subscribe(fh, sub, 4, NULL);\r\n}\r\nreturn v4l2_ctrl_subscribe_event(fh, sub);\r\n}\r\nstatic int cobalt_g_parm(struct file *file, void *fh, struct v4l2_streamparm *a)\r\n{\r\nif (a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\na->parm.capture.timeperframe.numerator = 1;\r\na->parm.capture.timeperframe.denominator = 60;\r\na->parm.capture.readbuffers = 3;\r\nreturn 0;\r\n}\r\nstatic int cobalt_cropcap(struct file *file, void *fh, struct v4l2_cropcap *cc)\r\n{\r\nstruct cobalt_stream *s = video_drvdata(file);\r\nstruct v4l2_dv_timings timings;\r\nint err = 0;\r\nif (cc->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nif (s->input == 1)\r\ntimings = cea1080p60;\r\nelse\r\nerr = v4l2_subdev_call(s->sd, video, g_dv_timings, &timings);\r\nif (!err) {\r\ncc->bounds.width = cc->defrect.width = timings.bt.width;\r\ncc->bounds.height = cc->defrect.height = timings.bt.height;\r\ncc->pixelaspect = v4l2_dv_timings_aspect_ratio(&timings);\r\n}\r\nreturn err;\r\n}\r\nstatic int cobalt_node_register(struct cobalt *cobalt, int node)\r\n{\r\nstatic const struct v4l2_dv_timings dv1080p60 =\r\nV4L2_DV_BT_CEA_1920X1080P60;\r\nstruct cobalt_stream *s = cobalt->streams + node;\r\nstruct video_device *vdev = &s->vdev;\r\nstruct vb2_queue *q = &s->q;\r\nint ret;\r\nmutex_init(&s->lock);\r\nspin_lock_init(&s->irqlock);\r\nsnprintf(vdev->name, sizeof(vdev->name),\r\n"%s-%d", cobalt->v4l2_dev.name, node);\r\ns->width = 1920;\r\ns->height = s->is_audio ? 4 : 1080;\r\nif (s->is_audio) {\r\ns->bpp = 1;\r\ns->pixfmt = V4L2_PIX_FMT_GREY;\r\n} else if (s->is_output) {\r\ns->bpp = COBALT_BYTES_PER_PIXEL_RGB32;\r\ns->pixfmt = V4L2_PIX_FMT_BGR32;\r\n} else {\r\ns->bpp = COBALT_BYTES_PER_PIXEL_YUYV;\r\ns->pixfmt = V4L2_PIX_FMT_YUYV;\r\n}\r\ns->colorspace = V4L2_COLORSPACE_SRGB;\r\ns->stride = s->width * s->bpp;\r\nif (!s->is_audio) {\r\nif (s->is_dummy)\r\ncobalt_warn("Setting up dummy video node %d\n", node);\r\nvdev->v4l2_dev = &cobalt->v4l2_dev;\r\nif (s->is_dummy)\r\nvdev->fops = &cobalt_empty_fops;\r\nelse\r\nvdev->fops = s->is_output ? &cobalt_out_fops :\r\n&cobalt_fops;\r\nvdev->release = video_device_release_empty;\r\nvdev->vfl_dir = s->is_output ? VFL_DIR_TX : VFL_DIR_RX;\r\nvdev->lock = &s->lock;\r\nif (s->sd)\r\nvdev->ctrl_handler = s->sd->ctrl_handler;\r\ns->timings = dv1080p60;\r\nv4l2_subdev_call(s->sd, video, s_dv_timings, &s->timings);\r\nif (!s->is_output && s->sd)\r\ncobalt_enable_input(s);\r\nvdev->ioctl_ops = s->is_dummy ? &cobalt_ioctl_empty_ops :\r\n&cobalt_ioctl_ops;\r\n}\r\nINIT_LIST_HEAD(&s->bufs);\r\nq->type = s->is_output ? V4L2_BUF_TYPE_VIDEO_OUTPUT :\r\nV4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\r\nq->io_modes |= s->is_output ? VB2_WRITE : VB2_READ;\r\nq->drv_priv = s;\r\nq->buf_struct_size = sizeof(struct cobalt_buffer);\r\nq->ops = &cobalt_qops;\r\nq->mem_ops = &vb2_dma_sg_memops;\r\nq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nq->min_buffers_needed = 2;\r\nq->lock = &s->lock;\r\nq->dev = &cobalt->pci_dev->dev;\r\nvdev->queue = q;\r\nvideo_set_drvdata(vdev, s);\r\nret = vb2_queue_init(q);\r\nif (!s->is_audio && ret == 0)\r\nret = video_register_device(vdev, VFL_TYPE_GRABBER, -1);\r\nelse if (!s->is_dummy)\r\nret = cobalt_alsa_init(s);\r\nif (ret < 0) {\r\nif (!s->is_audio)\r\ncobalt_err("couldn't register v4l2 device node %d\n",\r\nnode);\r\nreturn ret;\r\n}\r\ncobalt_info("registered node %d\n", node);\r\nreturn 0;\r\n}\r\nint cobalt_nodes_register(struct cobalt *cobalt)\r\n{\r\nint node, ret;\r\nfor (node = 0; node < COBALT_NUM_STREAMS; node++) {\r\nret = cobalt_node_register(cobalt, node);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nvoid cobalt_nodes_unregister(struct cobalt *cobalt)\r\n{\r\nint node;\r\nfor (node = 0; node < COBALT_NUM_STREAMS; node++) {\r\nstruct cobalt_stream *s = cobalt->streams + node;\r\nstruct video_device *vdev = &s->vdev;\r\nif (!s->is_audio)\r\nvideo_unregister_device(vdev);\r\nelse if (!s->is_dummy)\r\ncobalt_alsa_exit(s);\r\n}\r\n}
