static u32 _rtl92d_phy_calculate_bit_shift(u32 bitmask)\r\n{\r\nu32 i;\r\nfor (i = 0; i <= 31; i++) {\r\nif (((bitmask >> i) & 0x1) == 1)\r\nbreak;\r\n}\r\nreturn i;\r\n}\r\nu32 rtl92d_phy_query_bb_reg(struct ieee80211_hw *hw, u32 regaddr, u32 bitmask)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\r\nu32 returnvalue, originalvalue, bitshift;\r\nRT_TRACE(rtlpriv, COMP_RF, DBG_TRACE, "regaddr(%#x), bitmask(%#x)\n",\r\nregaddr, bitmask);\r\nif (rtlhal->during_mac1init_radioa || rtlhal->during_mac0init_radiob) {\r\nu8 dbi_direct = 0;\r\nif (rtlhal->during_mac1init_radioa)\r\ndbi_direct = BIT(3);\r\nelse if (rtlhal->during_mac0init_radiob)\r\ndbi_direct = BIT(3) | BIT(2);\r\noriginalvalue = rtl92de_read_dword_dbi(hw, (u16)regaddr,\r\ndbi_direct);\r\n} else {\r\noriginalvalue = rtl_read_dword(rtlpriv, regaddr);\r\n}\r\nbitshift = _rtl92d_phy_calculate_bit_shift(bitmask);\r\nreturnvalue = (originalvalue & bitmask) >> bitshift;\r\nRT_TRACE(rtlpriv, COMP_RF, DBG_TRACE,\r\n"BBR MASK=0x%x Addr[0x%x]=0x%x\n",\r\nbitmask, regaddr, originalvalue);\r\nreturn returnvalue;\r\n}\r\nvoid rtl92d_phy_set_bb_reg(struct ieee80211_hw *hw,\r\nu32 regaddr, u32 bitmask, u32 data)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\r\nu8 dbi_direct = 0;\r\nu32 originalvalue, bitshift;\r\nRT_TRACE(rtlpriv, COMP_RF, DBG_TRACE,\r\n"regaddr(%#x), bitmask(%#x), data(%#x)\n",\r\nregaddr, bitmask, data);\r\nif (rtlhal->during_mac1init_radioa)\r\ndbi_direct = BIT(3);\r\nelse if (rtlhal->during_mac0init_radiob)\r\ndbi_direct = BIT(3) | BIT(2);\r\nif (bitmask != MASKDWORD) {\r\nif (rtlhal->during_mac1init_radioa ||\r\nrtlhal->during_mac0init_radiob)\r\noriginalvalue = rtl92de_read_dword_dbi(hw,\r\n(u16) regaddr,\r\ndbi_direct);\r\nelse\r\noriginalvalue = rtl_read_dword(rtlpriv, regaddr);\r\nbitshift = _rtl92d_phy_calculate_bit_shift(bitmask);\r\ndata = ((originalvalue & (~bitmask)) | (data << bitshift));\r\n}\r\nif (rtlhal->during_mac1init_radioa || rtlhal->during_mac0init_radiob)\r\nrtl92de_write_dword_dbi(hw, (u16) regaddr, data, dbi_direct);\r\nelse\r\nrtl_write_dword(rtlpriv, regaddr, data);\r\nRT_TRACE(rtlpriv, COMP_RF, DBG_TRACE,\r\n"regaddr(%#x), bitmask(%#x), data(%#x)\n",\r\nregaddr, bitmask, data);\r\n}\r\nstatic u32 _rtl92d_phy_rf_serial_read(struct ieee80211_hw *hw,\r\nenum radio_path rfpath, u32 offset)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_phy *rtlphy = &(rtlpriv->phy);\r\nstruct bb_reg_def *pphyreg = &rtlphy->phyreg_def[rfpath];\r\nu32 newoffset;\r\nu32 tmplong, tmplong2;\r\nu8 rfpi_enable = 0;\r\nu32 retvalue;\r\nnewoffset = offset;\r\ntmplong = rtl_get_bbreg(hw, RFPGA0_XA_HSSIPARAMETER2, MASKDWORD);\r\nif (rfpath == RF90_PATH_A)\r\ntmplong2 = tmplong;\r\nelse\r\ntmplong2 = rtl_get_bbreg(hw, pphyreg->rfhssi_para2, MASKDWORD);\r\ntmplong2 = (tmplong2 & (~BLSSIREADADDRESS)) |\r\n(newoffset << 23) | BLSSIREADEDGE;\r\nrtl_set_bbreg(hw, RFPGA0_XA_HSSIPARAMETER2, MASKDWORD,\r\ntmplong & (~BLSSIREADEDGE));\r\nudelay(10);\r\nrtl_set_bbreg(hw, pphyreg->rfhssi_para2, MASKDWORD, tmplong2);\r\nudelay(50);\r\nudelay(50);\r\nrtl_set_bbreg(hw, RFPGA0_XA_HSSIPARAMETER2, MASKDWORD,\r\ntmplong | BLSSIREADEDGE);\r\nudelay(10);\r\nif (rfpath == RF90_PATH_A)\r\nrfpi_enable = (u8) rtl_get_bbreg(hw, RFPGA0_XA_HSSIPARAMETER1,\r\nBIT(8));\r\nelse if (rfpath == RF90_PATH_B)\r\nrfpi_enable = (u8) rtl_get_bbreg(hw, RFPGA0_XB_HSSIPARAMETER1,\r\nBIT(8));\r\nif (rfpi_enable)\r\nretvalue = rtl_get_bbreg(hw, pphyreg->rf_rbpi,\r\nBLSSIREADBACKDATA);\r\nelse\r\nretvalue = rtl_get_bbreg(hw, pphyreg->rf_rb,\r\nBLSSIREADBACKDATA);\r\nRT_TRACE(rtlpriv, COMP_RF, DBG_TRACE, "RFR-%d Addr[0x%x] = 0x%x\n",\r\nrfpath, pphyreg->rf_rb, retvalue);\r\nreturn retvalue;\r\n}\r\nstatic void _rtl92d_phy_rf_serial_write(struct ieee80211_hw *hw,\r\nenum radio_path rfpath,\r\nu32 offset, u32 data)\r\n{\r\nu32 data_and_addr;\r\nu32 newoffset;\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_phy *rtlphy = &(rtlpriv->phy);\r\nstruct bb_reg_def *pphyreg = &rtlphy->phyreg_def[rfpath];\r\nnewoffset = offset;\r\ndata_and_addr = ((newoffset << 20) | (data & 0x000fffff)) & 0x0fffffff;\r\nrtl_set_bbreg(hw, pphyreg->rf3wire_offset, MASKDWORD, data_and_addr);\r\nRT_TRACE(rtlpriv, COMP_RF, DBG_TRACE, "RFW-%d Addr[0x%x]=0x%x\n",\r\nrfpath, pphyreg->rf3wire_offset, data_and_addr);\r\n}\r\nu32 rtl92d_phy_query_rf_reg(struct ieee80211_hw *hw,\r\nenum radio_path rfpath, u32 regaddr, u32 bitmask)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu32 original_value, readback_value, bitshift;\r\nunsigned long flags;\r\nRT_TRACE(rtlpriv, COMP_RF, DBG_TRACE,\r\n"regaddr(%#x), rfpath(%#x), bitmask(%#x)\n",\r\nregaddr, rfpath, bitmask);\r\nspin_lock_irqsave(&rtlpriv->locks.rf_lock, flags);\r\noriginal_value = _rtl92d_phy_rf_serial_read(hw, rfpath, regaddr);\r\nbitshift = _rtl92d_phy_calculate_bit_shift(bitmask);\r\nreadback_value = (original_value & bitmask) >> bitshift;\r\nspin_unlock_irqrestore(&rtlpriv->locks.rf_lock, flags);\r\nRT_TRACE(rtlpriv, COMP_RF, DBG_TRACE,\r\n"regaddr(%#x), rfpath(%#x), bitmask(%#x), original_value(%#x)\n",\r\nregaddr, rfpath, bitmask, original_value);\r\nreturn readback_value;\r\n}\r\nvoid rtl92d_phy_set_rf_reg(struct ieee80211_hw *hw, enum radio_path rfpath,\r\nu32 regaddr, u32 bitmask, u32 data)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_phy *rtlphy = &(rtlpriv->phy);\r\nu32 original_value, bitshift;\r\nunsigned long flags;\r\nRT_TRACE(rtlpriv, COMP_RF, DBG_TRACE,\r\n"regaddr(%#x), bitmask(%#x), data(%#x), rfpath(%#x)\n",\r\nregaddr, bitmask, data, rfpath);\r\nif (bitmask == 0)\r\nreturn;\r\nspin_lock_irqsave(&rtlpriv->locks.rf_lock, flags);\r\nif (rtlphy->rf_mode != RF_OP_BY_FW) {\r\nif (bitmask != RFREG_OFFSET_MASK) {\r\noriginal_value = _rtl92d_phy_rf_serial_read(hw,\r\nrfpath, regaddr);\r\nbitshift = _rtl92d_phy_calculate_bit_shift(bitmask);\r\ndata = ((original_value & (~bitmask)) |\r\n(data << bitshift));\r\n}\r\n_rtl92d_phy_rf_serial_write(hw, rfpath, regaddr, data);\r\n}\r\nspin_unlock_irqrestore(&rtlpriv->locks.rf_lock, flags);\r\nRT_TRACE(rtlpriv, COMP_RF, DBG_TRACE,\r\n"regaddr(%#x), bitmask(%#x), data(%#x), rfpath(%#x)\n",\r\nregaddr, bitmask, data, rfpath);\r\n}\r\nbool rtl92d_phy_mac_config(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu32 i;\r\nu32 arraylength;\r\nu32 *ptrarray;\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE, "Read Rtl819XMACPHY_Array\n");\r\narraylength = MAC_2T_ARRAYLENGTH;\r\nptrarray = rtl8192de_mac_2tarray;\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE, "Img:Rtl819XMAC_Array\n");\r\nfor (i = 0; i < arraylength; i = i + 2)\r\nrtl_write_byte(rtlpriv, ptrarray[i], (u8) ptrarray[i + 1]);\r\nif (rtlpriv->rtlhal.macphymode == SINGLEMAC_SINGLEPHY) {\r\nrtl_write_byte(rtlpriv, REG_MAX_AGGR_NUM, 0x0B);\r\n} else {\r\nrtl_write_byte(rtlpriv, REG_MAX_AGGR_NUM, 0x07);\r\n}\r\nreturn true;\r\n}\r\nstatic void _rtl92d_phy_init_bb_rf_register_definition(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_phy *rtlphy = &(rtlpriv->phy);\r\nrtlphy->phyreg_def[RF90_PATH_A].rfintfs = RFPGA0_XAB_RFINTERFACESW;\r\nrtlphy->phyreg_def[RF90_PATH_B].rfintfs = RFPGA0_XAB_RFINTERFACESW;\r\nrtlphy->phyreg_def[RF90_PATH_C].rfintfs = RFPGA0_XCD_RFINTERFACESW;\r\nrtlphy->phyreg_def[RF90_PATH_D].rfintfs = RFPGA0_XCD_RFINTERFACESW;\r\nrtlphy->phyreg_def[RF90_PATH_A].rfintfi = RFPGA0_XAB_RFINTERFACERB;\r\nrtlphy->phyreg_def[RF90_PATH_B].rfintfi = RFPGA0_XAB_RFINTERFACERB;\r\nrtlphy->phyreg_def[RF90_PATH_C].rfintfi = RFPGA0_XCD_RFINTERFACERB;\r\nrtlphy->phyreg_def[RF90_PATH_D].rfintfi = RFPGA0_XCD_RFINTERFACERB;\r\nrtlphy->phyreg_def[RF90_PATH_A].rfintfo = RFPGA0_XA_RFINTERFACEOE;\r\nrtlphy->phyreg_def[RF90_PATH_B].rfintfo = RFPGA0_XB_RFINTERFACEOE;\r\nrtlphy->phyreg_def[RF90_PATH_A].rfintfe = RFPGA0_XA_RFINTERFACEOE;\r\nrtlphy->phyreg_def[RF90_PATH_B].rfintfe = RFPGA0_XB_RFINTERFACEOE;\r\nrtlphy->phyreg_def[RF90_PATH_A].rf3wire_offset =\r\nRFPGA0_XA_LSSIPARAMETER;\r\nrtlphy->phyreg_def[RF90_PATH_B].rf3wire_offset =\r\nRFPGA0_XB_LSSIPARAMETER;\r\nrtlphy->phyreg_def[RF90_PATH_A].rflssi_select = RFPGA0_XAB_RFPARAMETER;\r\nrtlphy->phyreg_def[RF90_PATH_B].rflssi_select = RFPGA0_XAB_RFPARAMETER;\r\nrtlphy->phyreg_def[RF90_PATH_C].rflssi_select = RFPGA0_XCD_RFPARAMETER;\r\nrtlphy->phyreg_def[RF90_PATH_D].rflssi_select = RFPGA0_XCD_RFPARAMETER;\r\nrtlphy->phyreg_def[RF90_PATH_A].rftxgain_stage = RFPGA0_TXGAINSTAGE;\r\nrtlphy->phyreg_def[RF90_PATH_B].rftxgain_stage = RFPGA0_TXGAINSTAGE;\r\nrtlphy->phyreg_def[RF90_PATH_C].rftxgain_stage = RFPGA0_TXGAINSTAGE;\r\nrtlphy->phyreg_def[RF90_PATH_D].rftxgain_stage = RFPGA0_TXGAINSTAGE;\r\nrtlphy->phyreg_def[RF90_PATH_A].rfhssi_para1 = RFPGA0_XA_HSSIPARAMETER1;\r\nrtlphy->phyreg_def[RF90_PATH_B].rfhssi_para1 = RFPGA0_XB_HSSIPARAMETER1;\r\nrtlphy->phyreg_def[RF90_PATH_A].rfhssi_para2 = RFPGA0_XA_HSSIPARAMETER2;\r\nrtlphy->phyreg_def[RF90_PATH_B].rfhssi_para2 = RFPGA0_XB_HSSIPARAMETER2;\r\nrtlphy->phyreg_def[RF90_PATH_A].rfsw_ctrl = RFPGA0_XAB_SWITCHCONTROL;\r\nrtlphy->phyreg_def[RF90_PATH_B].rfsw_ctrl = RFPGA0_XAB_SWITCHCONTROL;\r\nrtlphy->phyreg_def[RF90_PATH_C].rfsw_ctrl = RFPGA0_XCD_SWITCHCONTROL;\r\nrtlphy->phyreg_def[RF90_PATH_D].rfsw_ctrl = RFPGA0_XCD_SWITCHCONTROL;\r\nrtlphy->phyreg_def[RF90_PATH_A].rfagc_control1 = ROFDM0_XAAGCCORE1;\r\nrtlphy->phyreg_def[RF90_PATH_B].rfagc_control1 = ROFDM0_XBAGCCORE1;\r\nrtlphy->phyreg_def[RF90_PATH_C].rfagc_control1 = ROFDM0_XCAGCCORE1;\r\nrtlphy->phyreg_def[RF90_PATH_D].rfagc_control1 = ROFDM0_XDAGCCORE1;\r\nrtlphy->phyreg_def[RF90_PATH_A].rfagc_control2 = ROFDM0_XAAGCCORE2;\r\nrtlphy->phyreg_def[RF90_PATH_B].rfagc_control2 = ROFDM0_XBAGCCORE2;\r\nrtlphy->phyreg_def[RF90_PATH_C].rfagc_control2 = ROFDM0_XCAGCCORE2;\r\nrtlphy->phyreg_def[RF90_PATH_D].rfagc_control2 = ROFDM0_XDAGCCORE2;\r\nrtlphy->phyreg_def[RF90_PATH_A].rfrxiq_imbal = ROFDM0_XARXIQIMBALANCE;\r\nrtlphy->phyreg_def[RF90_PATH_B].rfrxiq_imbal = ROFDM0_XBRXIQIMBALANCE;\r\nrtlphy->phyreg_def[RF90_PATH_C].rfrxiq_imbal = ROFDM0_XCRXIQIMBALANCE;\r\nrtlphy->phyreg_def[RF90_PATH_D].rfrxiq_imbal = ROFDM0_XDRXIQIMBALANCE;\r\nrtlphy->phyreg_def[RF90_PATH_A].rfrx_afe = ROFDM0_XARXAFE;\r\nrtlphy->phyreg_def[RF90_PATH_B].rfrx_afe = ROFDM0_XBRXAFE;\r\nrtlphy->phyreg_def[RF90_PATH_C].rfrx_afe = ROFDM0_XCRXAFE;\r\nrtlphy->phyreg_def[RF90_PATH_D].rfrx_afe = ROFDM0_XDRXAFE;\r\nrtlphy->phyreg_def[RF90_PATH_A].rftxiq_imbal = ROFDM0_XATxIQIMBALANCE;\r\nrtlphy->phyreg_def[RF90_PATH_B].rftxiq_imbal = ROFDM0_XBTxIQIMBALANCE;\r\nrtlphy->phyreg_def[RF90_PATH_C].rftxiq_imbal = ROFDM0_XCTxIQIMBALANCE;\r\nrtlphy->phyreg_def[RF90_PATH_D].rftxiq_imbal = ROFDM0_XDTxIQIMBALANCE;\r\nrtlphy->phyreg_def[RF90_PATH_A].rftx_afe = ROFDM0_XATxAFE;\r\nrtlphy->phyreg_def[RF90_PATH_B].rftx_afe = ROFDM0_XBTxAFE;\r\nrtlphy->phyreg_def[RF90_PATH_C].rftx_afe = ROFDM0_XCTxAFE;\r\nrtlphy->phyreg_def[RF90_PATH_D].rftx_afe = ROFDM0_XDTxAFE;\r\nrtlphy->phyreg_def[RF90_PATH_A].rf_rb = RFPGA0_XA_LSSIREADBACK;\r\nrtlphy->phyreg_def[RF90_PATH_B].rf_rb = RFPGA0_XB_LSSIREADBACK;\r\nrtlphy->phyreg_def[RF90_PATH_C].rf_rb = RFPGA0_XC_LSSIREADBACK;\r\nrtlphy->phyreg_def[RF90_PATH_D].rf_rb = RFPGA0_XD_LSSIREADBACK;\r\nrtlphy->phyreg_def[RF90_PATH_A].rf_rbpi = TRANSCEIVERA_HSPI_READBACK;\r\nrtlphy->phyreg_def[RF90_PATH_B].rf_rbpi = TRANSCEIVERB_HSPI_READBACK;\r\n}\r\nstatic bool _rtl92d_phy_config_bb_with_headerfile(struct ieee80211_hw *hw,\r\nu8 configtype)\r\n{\r\nint i;\r\nu32 *phy_regarray_table;\r\nu32 *agctab_array_table = NULL;\r\nu32 *agctab_5garray_table;\r\nu16 phy_reg_arraylen, agctab_arraylen = 0, agctab_5garraylen;\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nif (rtlhal->interfaceindex == 0) {\r\nagctab_arraylen = AGCTAB_ARRAYLENGTH;\r\nagctab_array_table = rtl8192de_agctab_array;\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n" ===> phy:MAC0, Rtl819XAGCTAB_Array\n");\r\n} else {\r\nif (rtlhal->current_bandtype == BAND_ON_2_4G) {\r\nagctab_arraylen = AGCTAB_2G_ARRAYLENGTH;\r\nagctab_array_table = rtl8192de_agctab_2garray;\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n" ===> phy:MAC1, Rtl819XAGCTAB_2GArray\n");\r\n} else {\r\nagctab_5garraylen = AGCTAB_5G_ARRAYLENGTH;\r\nagctab_5garray_table = rtl8192de_agctab_5garray;\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n" ===> phy:MAC1, Rtl819XAGCTAB_5GArray\n");\r\n}\r\n}\r\nphy_reg_arraylen = PHY_REG_2T_ARRAYLENGTH;\r\nphy_regarray_table = rtl8192de_phy_reg_2tarray;\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n" ===> phy:Rtl819XPHY_REG_Array_PG\n");\r\nif (configtype == BASEBAND_CONFIG_PHY_REG) {\r\nfor (i = 0; i < phy_reg_arraylen; i = i + 2) {\r\nrtl_addr_delay(phy_regarray_table[i]);\r\nrtl_set_bbreg(hw, phy_regarray_table[i], MASKDWORD,\r\nphy_regarray_table[i + 1]);\r\nudelay(1);\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE,\r\n"The phy_regarray_table[0] is %x Rtl819XPHY_REGArray[1] is %x\n",\r\nphy_regarray_table[i],\r\nphy_regarray_table[i + 1]);\r\n}\r\n} else if (configtype == BASEBAND_CONFIG_AGC_TAB) {\r\nif (rtlhal->interfaceindex == 0) {\r\nfor (i = 0; i < agctab_arraylen; i = i + 2) {\r\nrtl_set_bbreg(hw, agctab_array_table[i],\r\nMASKDWORD,\r\nagctab_array_table[i + 1]);\r\nudelay(1);\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE,\r\n"The Rtl819XAGCTAB_Array_Table[0] is %u Rtl819XPHY_REGArray[1] is %u\n",\r\nagctab_array_table[i],\r\nagctab_array_table[i + 1]);\r\n}\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"Normal Chip, MAC0, load Rtl819XAGCTAB_Array\n");\r\n} else {\r\nif (rtlhal->current_bandtype == BAND_ON_2_4G) {\r\nfor (i = 0; i < agctab_arraylen; i = i + 2) {\r\nrtl_set_bbreg(hw, agctab_array_table[i],\r\nMASKDWORD,\r\nagctab_array_table[i + 1]);\r\nudelay(1);\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE,\r\n"The Rtl819XAGCTAB_Array_Table[0] is %u Rtl819XPHY_REGArray[1] is %u\n",\r\nagctab_array_table[i],\r\nagctab_array_table[i + 1]);\r\n}\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"Load Rtl819XAGCTAB_2GArray\n");\r\n} else {\r\nfor (i = 0; i < agctab_5garraylen; i = i + 2) {\r\nrtl_set_bbreg(hw,\r\nagctab_5garray_table[i],\r\nMASKDWORD,\r\nagctab_5garray_table[i + 1]);\r\nudelay(1);\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE,\r\n"The Rtl819XAGCTAB_5GArray_Table[0] is %u Rtl819XPHY_REGArray[1] is %u\n",\r\nagctab_5garray_table[i],\r\nagctab_5garray_table[i + 1]);\r\n}\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"Load Rtl819XAGCTAB_5GArray\n");\r\n}\r\n}\r\n}\r\nreturn true;\r\n}\r\nstatic void _rtl92d_store_pwrindex_diffrate_offset(struct ieee80211_hw *hw,\r\nu32 regaddr, u32 bitmask,\r\nu32 data)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_phy *rtlphy = &(rtlpriv->phy);\r\nint index;\r\nif (regaddr == RTXAGC_A_RATE18_06)\r\nindex = 0;\r\nelse if (regaddr == RTXAGC_A_RATE54_24)\r\nindex = 1;\r\nelse if (regaddr == RTXAGC_A_CCK1_MCS32)\r\nindex = 6;\r\nelse if (regaddr == RTXAGC_B_CCK11_A_CCK2_11 && bitmask == 0xffffff00)\r\nindex = 7;\r\nelse if (regaddr == RTXAGC_A_MCS03_MCS00)\r\nindex = 2;\r\nelse if (regaddr == RTXAGC_A_MCS07_MCS04)\r\nindex = 3;\r\nelse if (regaddr == RTXAGC_A_MCS11_MCS08)\r\nindex = 4;\r\nelse if (regaddr == RTXAGC_A_MCS15_MCS12)\r\nindex = 5;\r\nelse if (regaddr == RTXAGC_B_RATE18_06)\r\nindex = 8;\r\nelse if (regaddr == RTXAGC_B_RATE54_24)\r\nindex = 9;\r\nelse if (regaddr == RTXAGC_B_CCK1_55_MCS32)\r\nindex = 14;\r\nelse if (regaddr == RTXAGC_B_CCK11_A_CCK2_11 && bitmask == 0x000000ff)\r\nindex = 15;\r\nelse if (regaddr == RTXAGC_B_MCS03_MCS00)\r\nindex = 10;\r\nelse if (regaddr == RTXAGC_B_MCS07_MCS04)\r\nindex = 11;\r\nelse if (regaddr == RTXAGC_B_MCS11_MCS08)\r\nindex = 12;\r\nelse if (regaddr == RTXAGC_B_MCS15_MCS12)\r\nindex = 13;\r\nelse\r\nreturn;\r\nrtlphy->mcs_offset[rtlphy->pwrgroup_cnt][index] = data;\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE,\r\n"MCSTxPowerLevelOriginalOffset[%d][%d] = 0x%x\n",\r\nrtlphy->pwrgroup_cnt, index,\r\nrtlphy->mcs_offset[rtlphy->pwrgroup_cnt][index]);\r\nif (index == 13)\r\nrtlphy->pwrgroup_cnt++;\r\n}\r\nstatic bool _rtl92d_phy_config_bb_with_pgheaderfile(struct ieee80211_hw *hw,\r\nu8 configtype)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nint i;\r\nu32 *phy_regarray_table_pg;\r\nu16 phy_regarray_pg_len;\r\nphy_regarray_pg_len = PHY_REG_ARRAY_PG_LENGTH;\r\nphy_regarray_table_pg = rtl8192de_phy_reg_array_pg;\r\nif (configtype == BASEBAND_CONFIG_PHY_REG) {\r\nfor (i = 0; i < phy_regarray_pg_len; i = i + 3) {\r\nrtl_addr_delay(phy_regarray_table_pg[i]);\r\n_rtl92d_store_pwrindex_diffrate_offset(hw,\r\nphy_regarray_table_pg[i],\r\nphy_regarray_table_pg[i + 1],\r\nphy_regarray_table_pg[i + 2]);\r\n}\r\n} else {\r\nRT_TRACE(rtlpriv, COMP_SEND, DBG_TRACE,\r\n"configtype != BaseBand_Config_PHY_REG\n");\r\n}\r\nreturn true;\r\n}\r\nstatic bool _rtl92d_phy_bb_config(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_phy *rtlphy = &(rtlpriv->phy);\r\nstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\r\nbool rtstatus = true;\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE, "==>\n");\r\nrtstatus = _rtl92d_phy_config_bb_with_headerfile(hw,\r\nBASEBAND_CONFIG_PHY_REG);\r\nif (!rtstatus) {\r\npr_err("Write BB Reg Fail!!\n");\r\nreturn false;\r\n}\r\nif (rtlefuse->autoload_failflag == false) {\r\nrtlphy->pwrgroup_cnt = 0;\r\nrtstatus = _rtl92d_phy_config_bb_with_pgheaderfile(hw,\r\nBASEBAND_CONFIG_PHY_REG);\r\n}\r\nif (!rtstatus) {\r\npr_err("BB_PG Reg Fail!!\n");\r\nreturn false;\r\n}\r\nrtstatus = _rtl92d_phy_config_bb_with_headerfile(hw,\r\nBASEBAND_CONFIG_AGC_TAB);\r\nif (!rtstatus) {\r\npr_err("AGC Table Fail\n");\r\nreturn false;\r\n}\r\nrtlphy->cck_high_power = (bool) (rtl_get_bbreg(hw,\r\nRFPGA0_XA_HSSIPARAMETER2, 0x200));\r\nreturn true;\r\n}\r\nbool rtl92d_phy_bb_config(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu16 regval;\r\nu32 regvaldw;\r\nu8 value;\r\n_rtl92d_phy_init_bb_rf_register_definition(hw);\r\nregval = rtl_read_word(rtlpriv, REG_SYS_FUNC_EN);\r\nrtl_write_word(rtlpriv, REG_SYS_FUNC_EN,\r\nregval | BIT(13) | BIT(0) | BIT(1));\r\nrtl_write_byte(rtlpriv, REG_AFE_PLL_CTRL, 0x83);\r\nrtl_write_byte(rtlpriv, REG_AFE_PLL_CTRL + 1, 0xdb);\r\nvalue = rtl_read_byte(rtlpriv, REG_RF_CTRL);\r\nrtl_write_byte(rtlpriv, REG_RF_CTRL, value | RF_EN | RF_RSTB |\r\nRF_SDMRSTB);\r\nrtl_write_byte(rtlpriv, REG_SYS_FUNC_EN, FEN_PPLL | FEN_PCIEA |\r\nFEN_DIO_PCIE | FEN_BB_GLB_RSTn | FEN_BBRSTB);\r\nrtl_write_byte(rtlpriv, REG_AFE_XTAL_CTRL + 1, 0x80);\r\nif (!(IS_92D_SINGLEPHY(rtlpriv->rtlhal.version))) {\r\nregvaldw = rtl_read_dword(rtlpriv, REG_LEDCFG0);\r\nrtl_write_dword(rtlpriv, REG_LEDCFG0, regvaldw | BIT(23));\r\n}\r\nreturn _rtl92d_phy_bb_config(hw);\r\n}\r\nbool rtl92d_phy_rf_config(struct ieee80211_hw *hw)\r\n{\r\nreturn rtl92d_phy_rf6052_config(hw);\r\n}\r\nbool rtl92d_phy_config_rf_with_headerfile(struct ieee80211_hw *hw,\r\nenum rf_content content,\r\nenum radio_path rfpath)\r\n{\r\nint i;\r\nu32 *radioa_array_table;\r\nu32 *radiob_array_table;\r\nu16 radioa_arraylen, radiob_arraylen;\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nradioa_arraylen = RADIOA_2T_ARRAYLENGTH;\r\nradioa_array_table = rtl8192de_radioa_2tarray;\r\nradiob_arraylen = RADIOB_2T_ARRAYLENGTH;\r\nradiob_array_table = rtl8192de_radiob_2tarray;\r\nif (rtlpriv->efuse.internal_pa_5g[0]) {\r\nradioa_arraylen = RADIOA_2T_INT_PA_ARRAYLENGTH;\r\nradioa_array_table = rtl8192de_radioa_2t_int_paarray;\r\n}\r\nif (rtlpriv->efuse.internal_pa_5g[1]) {\r\nradiob_arraylen = RADIOB_2T_INT_PA_ARRAYLENGTH;\r\nradiob_array_table = rtl8192de_radiob_2t_int_paarray;\r\n}\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"PHY_ConfigRFWithHeaderFile() Radio_A:Rtl819XRadioA_1TArray\n");\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"PHY_ConfigRFWithHeaderFile() Radio_B:Rtl819XRadioB_1TArray\n");\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE, "Radio No %x\n", rfpath);\r\nif ((content == radiob_txt) && (rfpath == RF90_PATH_A)) {\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n" ===> althougth Path A, we load radiob.txt\n");\r\nradioa_arraylen = radiob_arraylen;\r\nradioa_array_table = radiob_array_table;\r\n}\r\nswitch (rfpath) {\r\ncase RF90_PATH_A:\r\nfor (i = 0; i < radioa_arraylen; i = i + 2) {\r\nrtl_rfreg_delay(hw, rfpath, radioa_array_table[i],\r\nRFREG_OFFSET_MASK,\r\nradioa_array_table[i + 1]);\r\n}\r\nbreak;\r\ncase RF90_PATH_B:\r\nfor (i = 0; i < radiob_arraylen; i = i + 2) {\r\nrtl_rfreg_delay(hw, rfpath, radiob_array_table[i],\r\nRFREG_OFFSET_MASK,\r\nradiob_array_table[i + 1]);\r\n}\r\nbreak;\r\ncase RF90_PATH_C:\r\ncase RF90_PATH_D:\r\npr_err("switch case %#x not processed\n", rfpath);\r\nbreak;\r\n}\r\nreturn true;\r\n}\r\nvoid rtl92d_phy_get_hw_reg_originalvalue(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_phy *rtlphy = &(rtlpriv->phy);\r\nrtlphy->default_initialgain[0] =\r\n(u8) rtl_get_bbreg(hw, ROFDM0_XAAGCCORE1, MASKBYTE0);\r\nrtlphy->default_initialgain[1] =\r\n(u8) rtl_get_bbreg(hw, ROFDM0_XBAGCCORE1, MASKBYTE0);\r\nrtlphy->default_initialgain[2] =\r\n(u8) rtl_get_bbreg(hw, ROFDM0_XCAGCCORE1, MASKBYTE0);\r\nrtlphy->default_initialgain[3] =\r\n(u8) rtl_get_bbreg(hw, ROFDM0_XDAGCCORE1, MASKBYTE0);\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE,\r\n"Default initial gain (c50=0x%x, c58=0x%x, c60=0x%x, c68=0x%x\n",\r\nrtlphy->default_initialgain[0],\r\nrtlphy->default_initialgain[1],\r\nrtlphy->default_initialgain[2],\r\nrtlphy->default_initialgain[3]);\r\nrtlphy->framesync = (u8)rtl_get_bbreg(hw, ROFDM0_RXDETECTOR3,\r\nMASKBYTE0);\r\nrtlphy->framesync_c34 = rtl_get_bbreg(hw, ROFDM0_RXDETECTOR2,\r\nMASKDWORD);\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE,\r\n"Default framesync (0x%x) = 0x%x\n",\r\nROFDM0_RXDETECTOR3, rtlphy->framesync);\r\n}\r\nstatic void _rtl92d_get_txpower_index(struct ieee80211_hw *hw, u8 channel,\r\nu8 *cckpowerlevel, u8 *ofdmpowerlevel)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_phy *rtlphy = &(rtlpriv->phy);\r\nstruct rtl_hal *rtlhal = &(rtlpriv->rtlhal);\r\nstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\r\nu8 index = (channel - 1);\r\nif (rtlhal->current_bandtype == BAND_ON_2_4G) {\r\ncckpowerlevel[RF90_PATH_A] =\r\nrtlefuse->txpwrlevel_cck[RF90_PATH_A][index];\r\ncckpowerlevel[RF90_PATH_B] =\r\nrtlefuse->txpwrlevel_cck[RF90_PATH_B][index];\r\n} else {\r\ncckpowerlevel[RF90_PATH_A] = 0;\r\ncckpowerlevel[RF90_PATH_B] = 0;\r\n}\r\nif (rtlphy->rf_type == RF_1T2R || rtlphy->rf_type == RF_1T1R) {\r\nofdmpowerlevel[RF90_PATH_A] =\r\nrtlefuse->txpwrlevel_ht40_1s[RF90_PATH_A][index];\r\nofdmpowerlevel[RF90_PATH_B] =\r\nrtlefuse->txpwrlevel_ht40_1s[RF90_PATH_B][index];\r\n} else if (rtlphy->rf_type == RF_2T2R) {\r\nofdmpowerlevel[RF90_PATH_A] =\r\nrtlefuse->txpwrlevel_ht40_2s[RF90_PATH_A][index];\r\nofdmpowerlevel[RF90_PATH_B] =\r\nrtlefuse->txpwrlevel_ht40_2s[RF90_PATH_B][index];\r\n}\r\n}\r\nstatic void _rtl92d_ccxpower_index_check(struct ieee80211_hw *hw,\r\nu8 channel, u8 *cckpowerlevel, u8 *ofdmpowerlevel)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_phy *rtlphy = &(rtlpriv->phy);\r\nrtlphy->cur_cck_txpwridx = cckpowerlevel[0];\r\nrtlphy->cur_ofdm24g_txpwridx = ofdmpowerlevel[0];\r\n}\r\nstatic u8 _rtl92c_phy_get_rightchnlplace(u8 chnl)\r\n{\r\nu8 place = chnl;\r\nif (chnl > 14) {\r\nfor (place = 14; place < sizeof(channel5g); place++) {\r\nif (channel5g[place] == chnl) {\r\nplace++;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn place;\r\n}\r\nvoid rtl92d_phy_set_txpower_level(struct ieee80211_hw *hw, u8 channel)\r\n{\r\nstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu8 cckpowerlevel[2], ofdmpowerlevel[2];\r\nif (!rtlefuse->txpwr_fromeprom)\r\nreturn;\r\nchannel = _rtl92c_phy_get_rightchnlplace(channel);\r\n_rtl92d_get_txpower_index(hw, channel, &cckpowerlevel[0],\r\n&ofdmpowerlevel[0]);\r\nif (rtlpriv->rtlhal.current_bandtype == BAND_ON_2_4G)\r\n_rtl92d_ccxpower_index_check(hw, channel, &cckpowerlevel[0],\r\n&ofdmpowerlevel[0]);\r\nif (rtlpriv->rtlhal.current_bandtype == BAND_ON_2_4G)\r\nrtl92d_phy_rf6052_set_cck_txpower(hw, &cckpowerlevel[0]);\r\nrtl92d_phy_rf6052_set_ofdm_txpower(hw, &ofdmpowerlevel[0], channel);\r\n}\r\nvoid rtl92d_phy_set_bw_mode(struct ieee80211_hw *hw,\r\nenum nl80211_channel_type ch_type)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_phy *rtlphy = &(rtlpriv->phy);\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\r\nunsigned long flag = 0;\r\nu8 reg_prsr_rsc;\r\nu8 reg_bw_opmode;\r\nif (rtlphy->set_bwmode_inprogress)\r\nreturn;\r\nif ((is_hal_stop(rtlhal)) || (RT_CANNOT_IO(hw))) {\r\nRT_TRACE(rtlpriv, COMP_ERR, DBG_WARNING,\r\n"FALSE driver sleep or unload\n");\r\nreturn;\r\n}\r\nrtlphy->set_bwmode_inprogress = true;\r\nRT_TRACE(rtlpriv, COMP_SCAN, DBG_TRACE, "Switch to %s bandwidth\n",\r\nrtlphy->current_chan_bw == HT_CHANNEL_WIDTH_20 ?\r\n"20MHz" : "40MHz");\r\nreg_bw_opmode = rtl_read_byte(rtlpriv, REG_BWOPMODE);\r\nreg_prsr_rsc = rtl_read_byte(rtlpriv, REG_RRSR + 2);\r\nswitch (rtlphy->current_chan_bw) {\r\ncase HT_CHANNEL_WIDTH_20:\r\nreg_bw_opmode |= BW_OPMODE_20MHZ;\r\nrtl_write_byte(rtlpriv, REG_BWOPMODE, reg_bw_opmode);\r\nbreak;\r\ncase HT_CHANNEL_WIDTH_20_40:\r\nreg_bw_opmode &= ~BW_OPMODE_20MHZ;\r\nrtl_write_byte(rtlpriv, REG_BWOPMODE, reg_bw_opmode);\r\nreg_prsr_rsc = (reg_prsr_rsc & 0x90) |\r\n(mac->cur_40_prime_sc << 5);\r\nrtl_write_byte(rtlpriv, REG_RRSR + 2, reg_prsr_rsc);\r\nbreak;\r\ndefault:\r\npr_err("unknown bandwidth: %#X\n",\r\nrtlphy->current_chan_bw);\r\nbreak;\r\n}\r\nswitch (rtlphy->current_chan_bw) {\r\ncase HT_CHANNEL_WIDTH_20:\r\nrtl_set_bbreg(hw, RFPGA0_RFMOD, BRFMOD, 0x0);\r\nrtl_set_bbreg(hw, RFPGA1_RFMOD, BRFMOD, 0x0);\r\nrtl_set_bbreg(hw, RFPGA0_ANALOGPARAMETER2, BIT(10) |\r\nBIT(11), 3);\r\nbreak;\r\ncase HT_CHANNEL_WIDTH_20_40:\r\nrtl_set_bbreg(hw, RFPGA0_RFMOD, BRFMOD, 0x1);\r\nrtl_set_bbreg(hw, RFPGA1_RFMOD, BRFMOD, 0x1);\r\nif (rtlhal->current_bandtype == BAND_ON_2_4G) {\r\nrtl92d_acquire_cckandrw_pagea_ctl(hw, &flag);\r\nrtl_set_bbreg(hw, RCCK0_SYSTEM, BCCKSIDEBAND,\r\n(mac->cur_40_prime_sc >> 1));\r\nrtl92d_release_cckandrw_pagea_ctl(hw, &flag);\r\n}\r\nrtl_set_bbreg(hw, ROFDM1_LSTF, 0xC00, mac->cur_40_prime_sc);\r\nrtl_set_bbreg(hw, RFPGA0_ANALOGPARAMETER2, BIT(10) |\r\nBIT(11), 0);\r\nrtl_set_bbreg(hw, 0x818, (BIT(26) | BIT(27)),\r\n(mac->cur_40_prime_sc ==\r\nHAL_PRIME_CHNL_OFFSET_LOWER) ? 2 : 1);\r\nbreak;\r\ndefault:\r\npr_err("unknown bandwidth: %#X\n",\r\nrtlphy->current_chan_bw);\r\nbreak;\r\n}\r\nrtl92d_phy_rf6052_set_bandwidth(hw, rtlphy->current_chan_bw);\r\nrtlphy->set_bwmode_inprogress = false;\r\nRT_TRACE(rtlpriv, COMP_SCAN, DBG_TRACE, "<==\n");\r\n}\r\nstatic void _rtl92d_phy_stop_trx_before_changeband(struct ieee80211_hw *hw)\r\n{\r\nrtl_set_bbreg(hw, RFPGA0_RFMOD, BCCKEN, 0);\r\nrtl_set_bbreg(hw, RFPGA0_RFMOD, BOFDMEN, 0);\r\nrtl_set_bbreg(hw, ROFDM0_TRXPATHENABLE, MASKBYTE0, 0x00);\r\nrtl_set_bbreg(hw, ROFDM1_TRXPATHENABLE, BDWORD, 0x0);\r\n}\r\nstatic void rtl92d_phy_switch_wirelessband(struct ieee80211_hw *hw, u8 band)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nu8 value8;\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "==>\n");\r\nrtlhal->bandset = band;\r\nrtlhal->current_bandtype = band;\r\nif (IS_92D_SINGLEPHY(rtlhal->version))\r\nrtlhal->bandset = BAND_ON_BOTH;\r\n_rtl92d_phy_stop_trx_before_changeband(hw);\r\nif (rtlhal->current_bandtype == BAND_ON_2_4G) {\r\nRT_TRACE(rtlpriv, COMP_CMD, DBG_DMESG, "====>2.4G\n");\r\nif (rtlhal->interfaceindex == 1)\r\n_rtl92d_phy_config_bb_with_headerfile(hw,\r\nBASEBAND_CONFIG_AGC_TAB);\r\n} else {\r\nRT_TRACE(rtlpriv, COMP_CMD, DBG_DMESG, "====>5G\n");\r\nif (rtlhal->interfaceindex == 1)\r\n_rtl92d_phy_config_bb_with_headerfile(hw,\r\nBASEBAND_CONFIG_AGC_TAB);\r\n}\r\nrtl92d_update_bbrf_configuration(hw);\r\nif (rtlhal->current_bandtype == BAND_ON_2_4G)\r\nrtl_set_bbreg(hw, RFPGA0_RFMOD, BCCKEN, 0x1);\r\nrtl_set_bbreg(hw, RFPGA0_RFMOD, BOFDMEN, 0x1);\r\nrtlhal->reloadtxpowerindex = true;\r\nif (rtlhal->current_bandtype == BAND_ON_2_4G) {\r\nvalue8 = rtl_read_byte(rtlpriv, (rtlhal->interfaceindex ==\r\n0 ? REG_MAC0 : REG_MAC1));\r\nvalue8 |= BIT(1);\r\nrtl_write_byte(rtlpriv, (rtlhal->interfaceindex ==\r\n0 ? REG_MAC0 : REG_MAC1), value8);\r\n} else {\r\nvalue8 = rtl_read_byte(rtlpriv, (rtlhal->interfaceindex ==\r\n0 ? REG_MAC0 : REG_MAC1));\r\nvalue8 &= (~BIT(1));\r\nrtl_write_byte(rtlpriv, (rtlhal->interfaceindex ==\r\n0 ? REG_MAC0 : REG_MAC1), value8);\r\n}\r\nmdelay(1);\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "<==Switch Band OK\n");\r\n}\r\nstatic void _rtl92d_phy_reload_imr_setting(struct ieee80211_hw *hw,\r\nu8 channel, u8 rfpath)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu32 imr_num = MAX_RF_IMR_INDEX;\r\nu32 rfmask = RFREG_OFFSET_MASK;\r\nu8 group, i;\r\nunsigned long flag = 0;\r\nRT_TRACE(rtlpriv, COMP_CMD, DBG_LOUD, "====>path %d\n", rfpath);\r\nif (rtlpriv->rtlhal.current_bandtype == BAND_ON_5G) {\r\nRT_TRACE(rtlpriv, COMP_CMD, DBG_LOUD, "====>5G\n");\r\nrtl_set_bbreg(hw, RFPGA0_RFMOD, BIT(25) | BIT(24), 0);\r\nrtl_set_bbreg(hw, RFPGA0_ANALOGPARAMETER4, 0x00f00000, 0xf);\r\nif (channel > 99)\r\nrtl_set_bbreg(hw, ROFDM1_CFOTRACKING, BIT(13) |\r\nBIT(14), 2);\r\nelse\r\nrtl_set_bbreg(hw, ROFDM1_CFOTRACKING, BIT(13) |\r\nBIT(14), 1);\r\ngroup = channel <= 64 ? 1 : 2;\r\nimr_num = MAX_RF_IMR_INDEX_NORMAL;\r\nfor (i = 0; i < imr_num; i++)\r\nrtl_set_rfreg(hw, (enum radio_path)rfpath,\r\nrf_reg_for_5g_swchnl_normal[i], rfmask,\r\nrf_imr_param_normal[0][group][i]);\r\nrtl_set_bbreg(hw, RFPGA0_ANALOGPARAMETER4, 0x00f00000, 0);\r\nrtl_set_bbreg(hw, RFPGA0_RFMOD, BOFDMEN, 1);\r\n} else {\r\nRT_TRACE(rtlpriv, COMP_SCAN, DBG_LOUD,\r\n"Load RF IMR parameters for G band. IMR already setting %d\n",\r\nrtlpriv->rtlhal.load_imrandiqk_setting_for2g);\r\nRT_TRACE(rtlpriv, COMP_CMD, DBG_LOUD, "====>2.4G\n");\r\nif (!rtlpriv->rtlhal.load_imrandiqk_setting_for2g) {\r\nRT_TRACE(rtlpriv, COMP_SCAN, DBG_LOUD,\r\n"Load RF IMR parameters for G band. %d\n",\r\nrfpath);\r\nrtl92d_acquire_cckandrw_pagea_ctl(hw, &flag);\r\nrtl_set_bbreg(hw, RFPGA0_RFMOD, BIT(25) | BIT(24), 0);\r\nrtl_set_bbreg(hw, RFPGA0_ANALOGPARAMETER4,\r\n0x00f00000, 0xf);\r\nimr_num = MAX_RF_IMR_INDEX_NORMAL;\r\nfor (i = 0; i < imr_num; i++) {\r\nrtl_set_rfreg(hw, (enum radio_path)rfpath,\r\nrf_reg_for_5g_swchnl_normal[i],\r\nRFREG_OFFSET_MASK,\r\nrf_imr_param_normal[0][0][i]);\r\n}\r\nrtl_set_bbreg(hw, RFPGA0_ANALOGPARAMETER4,\r\n0x00f00000, 0);\r\nrtl_set_bbreg(hw, RFPGA0_RFMOD, BOFDMEN | BCCKEN, 3);\r\nrtl92d_release_cckandrw_pagea_ctl(hw, &flag);\r\n}\r\n}\r\nRT_TRACE(rtlpriv, COMP_CMD, DBG_LOUD, "<====\n");\r\n}\r\nstatic void _rtl92d_phy_enable_rf_env(struct ieee80211_hw *hw,\r\nu8 rfpath, u32 *pu4_regval)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_phy *rtlphy = &(rtlpriv->phy);\r\nstruct bb_reg_def *pphyreg = &rtlphy->phyreg_def[rfpath];\r\nRT_TRACE(rtlpriv, COMP_RF, DBG_LOUD, "====>\n");\r\nswitch (rfpath) {\r\ncase RF90_PATH_A:\r\ncase RF90_PATH_C:\r\n*pu4_regval = rtl_get_bbreg(hw, pphyreg->rfintfs, BRFSI_RFENV);\r\nbreak;\r\ncase RF90_PATH_B:\r\ncase RF90_PATH_D:\r\n*pu4_regval =\r\nrtl_get_bbreg(hw, pphyreg->rfintfs, BRFSI_RFENV << 16);\r\nbreak;\r\n}\r\nrtl_set_bbreg(hw, pphyreg->rfintfe, BRFSI_RFENV << 16, 0x1);\r\nudelay(1);\r\nrtl_set_bbreg(hw, pphyreg->rfintfo, BRFSI_RFENV, 0x1);\r\nudelay(1);\r\nrtl_set_bbreg(hw, pphyreg->rfhssi_para2, B3WIREADDRESSLENGTH, 0x0);\r\nudelay(1);\r\nrtl_set_bbreg(hw, pphyreg->rfhssi_para2, B3WIREDATALENGTH, 0x0);\r\nudelay(1);\r\nRT_TRACE(rtlpriv, COMP_RF, DBG_LOUD, "<====\n");\r\n}\r\nstatic void _rtl92d_phy_restore_rf_env(struct ieee80211_hw *hw, u8 rfpath,\r\nu32 *pu4_regval)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_phy *rtlphy = &(rtlpriv->phy);\r\nstruct bb_reg_def *pphyreg = &rtlphy->phyreg_def[rfpath];\r\nRT_TRACE(rtlpriv, COMP_RF, DBG_LOUD, "=====>\n");\r\nswitch (rfpath) {\r\ncase RF90_PATH_A:\r\ncase RF90_PATH_C:\r\nrtl_set_bbreg(hw, pphyreg->rfintfs, BRFSI_RFENV, *pu4_regval);\r\nbreak;\r\ncase RF90_PATH_B:\r\ncase RF90_PATH_D:\r\nrtl_set_bbreg(hw, pphyreg->rfintfs, BRFSI_RFENV << 16,\r\n*pu4_regval);\r\nbreak;\r\n}\r\nRT_TRACE(rtlpriv, COMP_RF, DBG_LOUD, "<=====\n");\r\n}\r\nstatic void _rtl92d_phy_switch_rf_setting(struct ieee80211_hw *hw, u8 channel)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_phy *rtlphy = &(rtlpriv->phy);\r\nstruct rtl_hal *rtlhal = &(rtlpriv->rtlhal);\r\nu8 path = rtlhal->current_bandtype ==\r\nBAND_ON_5G ? RF90_PATH_A : RF90_PATH_B;\r\nu8 index = 0, i = 0, rfpath = RF90_PATH_A;\r\nbool need_pwr_down = false, internal_pa = false;\r\nu32 u4regvalue, mask = 0x1C000, value = 0, u4tmp, u4tmp2;\r\nRT_TRACE(rtlpriv, COMP_CMD, DBG_LOUD, "====>\n");\r\nif (rtlhal->current_bandtype == BAND_ON_5G) {\r\nRT_TRACE(rtlpriv, COMP_CMD, DBG_LOUD, "====>5G\n");\r\nu4tmp = curveindex_5g[channel - 1];\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK,\r\n"ver 1 set RF-A, 5G, 0x28 = 0x%x !!\n", u4tmp);\r\nfor (i = 0; i < RF_CHNL_NUM_5G; i++) {\r\nif (channel == rf_chnl_5g[i] && channel <= 140)\r\nindex = 0;\r\n}\r\nfor (i = 0; i < RF_CHNL_NUM_5G_40M; i++) {\r\nif (channel == rf_chnl_5g_40m[i] && channel <= 140)\r\nindex = 1;\r\n}\r\nif (channel == 149 || channel == 155 || channel == 161)\r\nindex = 2;\r\nelse if (channel == 151 || channel == 153 || channel == 163\r\n|| channel == 165)\r\nindex = 3;\r\nelse if (channel == 157 || channel == 159)\r\nindex = 4;\r\nif (rtlhal->macphymode == DUALMAC_DUALPHY\r\n&& rtlhal->interfaceindex == 1) {\r\nneed_pwr_down = rtl92d_phy_enable_anotherphy(hw, false);\r\nrtlhal->during_mac1init_radioa = true;\r\nif (need_pwr_down)\r\n_rtl92d_phy_enable_rf_env(hw, path,\r\n&u4regvalue);\r\n}\r\nfor (i = 0; i < RF_REG_NUM_FOR_C_CUT_5G; i++) {\r\nif (i == 0 && (rtlhal->macphymode == DUALMAC_DUALPHY)) {\r\nrtl_set_rfreg(hw, (enum radio_path)path,\r\nrf_reg_for_c_cut_5g[i],\r\nRFREG_OFFSET_MASK, 0xE439D);\r\n} else if (rf_reg_for_c_cut_5g[i] == RF_SYN_G4) {\r\nu4tmp2 = (rf_reg_pram_c_5g[index][i] &\r\n0x7FF) | (u4tmp << 11);\r\nif (channel == 36)\r\nu4tmp2 &= ~(BIT(7) | BIT(6));\r\nrtl_set_rfreg(hw, (enum radio_path)path,\r\nrf_reg_for_c_cut_5g[i],\r\nRFREG_OFFSET_MASK, u4tmp2);\r\n} else {\r\nrtl_set_rfreg(hw, (enum radio_path)path,\r\nrf_reg_for_c_cut_5g[i],\r\nRFREG_OFFSET_MASK,\r\nrf_reg_pram_c_5g[index][i]);\r\n}\r\nRT_TRACE(rtlpriv, COMP_RF, DBG_TRACE,\r\n"offset 0x%x value 0x%x path %d index %d readback 0x%x\n",\r\nrf_reg_for_c_cut_5g[i],\r\nrf_reg_pram_c_5g[index][i],\r\npath, index,\r\nrtl_get_rfreg(hw, (enum radio_path)path,\r\nrf_reg_for_c_cut_5g[i],\r\nRFREG_OFFSET_MASK));\r\n}\r\nif (need_pwr_down)\r\n_rtl92d_phy_restore_rf_env(hw, path, &u4regvalue);\r\nif (rtlhal->during_mac1init_radioa)\r\nrtl92d_phy_powerdown_anotherphy(hw, false);\r\nif (channel < 149)\r\nvalue = 0x07;\r\nelse if (channel >= 149)\r\nvalue = 0x02;\r\nif (channel >= 36 && channel <= 64)\r\nindex = 0;\r\nelse if (channel >= 100 && channel <= 140)\r\nindex = 1;\r\nelse\r\nindex = 2;\r\nfor (rfpath = RF90_PATH_A; rfpath < rtlphy->num_total_rfpath;\r\nrfpath++) {\r\nif (rtlhal->macphymode == DUALMAC_DUALPHY &&\r\nrtlhal->interfaceindex == 1)\r\ninternal_pa = rtlpriv->efuse.internal_pa_5g[1];\r\nelse\r\ninternal_pa =\r\nrtlpriv->efuse.internal_pa_5g[rfpath];\r\nif (internal_pa) {\r\nfor (i = 0;\r\ni < RF_REG_NUM_FOR_C_CUT_5G_INTERNALPA;\r\ni++) {\r\nrtl_set_rfreg(hw, rfpath,\r\nrf_for_c_cut_5g_internal_pa[i],\r\nRFREG_OFFSET_MASK,\r\nrf_pram_c_5g_int_pa[index][i]);\r\nRT_TRACE(rtlpriv, COMP_RF, DBG_LOUD,\r\n"offset 0x%x value 0x%x path %d index %d\n",\r\nrf_for_c_cut_5g_internal_pa[i],\r\nrf_pram_c_5g_int_pa[index][i],\r\nrfpath, index);\r\n}\r\n} else {\r\nrtl_set_rfreg(hw, (enum radio_path)rfpath, 0x0B,\r\nmask, value);\r\n}\r\n}\r\n} else if (rtlhal->current_bandtype == BAND_ON_2_4G) {\r\nRT_TRACE(rtlpriv, COMP_CMD, DBG_LOUD, "====>2.4G\n");\r\nu4tmp = curveindex_2g[channel - 1];\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK,\r\n"ver 3 set RF-B, 2G, 0x28 = 0x%x !!\n", u4tmp);\r\nif (channel == 1 || channel == 2 || channel == 4 || channel == 9\r\n|| channel == 10 || channel == 11 || channel == 12)\r\nindex = 0;\r\nelse if (channel == 3 || channel == 13 || channel == 14)\r\nindex = 1;\r\nelse if (channel >= 5 && channel <= 8)\r\nindex = 2;\r\nif (rtlhal->macphymode == DUALMAC_DUALPHY) {\r\npath = RF90_PATH_A;\r\nif (rtlhal->interfaceindex == 0) {\r\nneed_pwr_down =\r\nrtl92d_phy_enable_anotherphy(hw, true);\r\nrtlhal->during_mac0init_radiob = true;\r\nif (need_pwr_down)\r\n_rtl92d_phy_enable_rf_env(hw, path,\r\n&u4regvalue);\r\n}\r\n}\r\nfor (i = 0; i < RF_REG_NUM_FOR_C_CUT_2G; i++) {\r\nif (rf_reg_for_c_cut_2g[i] == RF_SYN_G7)\r\nrtl_set_rfreg(hw, (enum radio_path)path,\r\nrf_reg_for_c_cut_2g[i],\r\nRFREG_OFFSET_MASK,\r\n(rf_reg_param_for_c_cut_2g[index][i] |\r\nBIT(17)));\r\nelse\r\nrtl_set_rfreg(hw, (enum radio_path)path,\r\nrf_reg_for_c_cut_2g[i],\r\nRFREG_OFFSET_MASK,\r\nrf_reg_param_for_c_cut_2g\r\n[index][i]);\r\nRT_TRACE(rtlpriv, COMP_RF, DBG_TRACE,\r\n"offset 0x%x value 0x%x mak 0x%x path %d index %d readback 0x%x\n",\r\nrf_reg_for_c_cut_2g[i],\r\nrf_reg_param_for_c_cut_2g[index][i],\r\nrf_reg_mask_for_c_cut_2g[i], path, index,\r\nrtl_get_rfreg(hw, (enum radio_path)path,\r\nrf_reg_for_c_cut_2g[i],\r\nRFREG_OFFSET_MASK));\r\n}\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK,\r\n"cosa ver 3 set RF-B, 2G, 0x28 = 0x%x !!\n",\r\nrf_syn_g4_for_c_cut_2g | (u4tmp << 11));\r\nrtl_set_rfreg(hw, (enum radio_path)path, RF_SYN_G4,\r\nRFREG_OFFSET_MASK,\r\nrf_syn_g4_for_c_cut_2g | (u4tmp << 11));\r\nif (need_pwr_down)\r\n_rtl92d_phy_restore_rf_env(hw, path, &u4regvalue);\r\nif (rtlhal->during_mac0init_radiob)\r\nrtl92d_phy_powerdown_anotherphy(hw, true);\r\n}\r\nRT_TRACE(rtlpriv, COMP_CMD, DBG_LOUD, "<====\n");\r\n}\r\nu8 rtl92d_get_rightchnlplace_for_iqk(u8 chnl)\r\n{\r\nu8 channel_all[59] = {\r\n1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,\r\n36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58,\r\n60, 62, 64, 100, 102, 104, 106, 108, 110, 112,\r\n114, 116, 118, 120, 122, 124, 126, 128, 130,\r\n132, 134, 136, 138, 140, 149, 151, 153, 155,\r\n157, 159, 161, 163, 165\r\n};\r\nu8 place = chnl;\r\nif (chnl > 14) {\r\nfor (place = 14; place < sizeof(channel_all); place++) {\r\nif (channel_all[place] == chnl)\r\nreturn place - 13;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic u8 _rtl92d_phy_patha_iqk(struct ieee80211_hw *hw, bool configpathb)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nu32 regeac, rege94, rege9c, regea4;\r\nu8 result = 0;\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "Path A IQK!\n");\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "Path-A IQK setting!\n");\r\nif (rtlhal->interfaceindex == 0) {\r\nrtl_set_bbreg(hw, 0xe30, MASKDWORD, 0x10008c1f);\r\nrtl_set_bbreg(hw, 0xe34, MASKDWORD, 0x10008c1f);\r\n} else {\r\nrtl_set_bbreg(hw, 0xe30, MASKDWORD, 0x10008c22);\r\nrtl_set_bbreg(hw, 0xe34, MASKDWORD, 0x10008c22);\r\n}\r\nrtl_set_bbreg(hw, 0xe38, MASKDWORD, 0x82140102);\r\nrtl_set_bbreg(hw, 0xe3c, MASKDWORD, 0x28160206);\r\nif (configpathb) {\r\nrtl_set_bbreg(hw, 0xe50, MASKDWORD, 0x10008c22);\r\nrtl_set_bbreg(hw, 0xe54, MASKDWORD, 0x10008c22);\r\nrtl_set_bbreg(hw, 0xe58, MASKDWORD, 0x82140102);\r\nrtl_set_bbreg(hw, 0xe5c, MASKDWORD, 0x28160206);\r\n}\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "LO calibration setting!\n");\r\nrtl_set_bbreg(hw, 0xe4c, MASKDWORD, 0x00462911);\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "One shot, path A LOK & IQK!\n");\r\nrtl_set_bbreg(hw, 0xe48, MASKDWORD, 0xf9000000);\r\nrtl_set_bbreg(hw, 0xe48, MASKDWORD, 0xf8000000);\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK,\r\n"Delay %d ms for One shot, path A LOK & IQK\n",\r\nIQK_DELAY_TIME);\r\nmdelay(IQK_DELAY_TIME);\r\nregeac = rtl_get_bbreg(hw, 0xeac, MASKDWORD);\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "0xeac = 0x%x\n", regeac);\r\nrege94 = rtl_get_bbreg(hw, 0xe94, MASKDWORD);\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "0xe94 = 0x%x\n", rege94);\r\nrege9c = rtl_get_bbreg(hw, 0xe9c, MASKDWORD);\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "0xe9c = 0x%x\n", rege9c);\r\nregea4 = rtl_get_bbreg(hw, 0xea4, MASKDWORD);\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "0xea4 = 0x%x\n", regea4);\r\nif (!(regeac & BIT(28)) && (((rege94 & 0x03FF0000) >> 16) != 0x142) &&\r\n(((rege9c & 0x03FF0000) >> 16) != 0x42))\r\nresult |= 0x01;\r\nelse\r\nreturn result;\r\nif (!(regeac & BIT(27)) && (((regea4 & 0x03FF0000) >> 16) != 0x132) &&\r\n(((regeac & 0x03FF0000) >> 16) != 0x36))\r\nresult |= 0x02;\r\nelse\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "Path A Rx IQK fail!!\n");\r\nreturn result;\r\n}\r\nstatic u8 _rtl92d_phy_patha_iqk_5g_normal(struct ieee80211_hw *hw,\r\nbool configpathb)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nstruct rtl_phy *rtlphy = &(rtlpriv->phy);\r\nu32 regeac, rege94, rege9c, regea4;\r\nu8 result = 0;\r\nu8 i;\r\nu8 retrycount = 2;\r\nu32 TxOKBit = BIT(28), RxOKBit = BIT(27);\r\nif (rtlhal->interfaceindex == 1) {\r\nTxOKBit = BIT(31);\r\nRxOKBit = BIT(30);\r\n}\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "Path A IQK!\n");\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "Path-A IQK setting!\n");\r\nrtl_set_bbreg(hw, 0xe30, MASKDWORD, 0x18008c1f);\r\nrtl_set_bbreg(hw, 0xe34, MASKDWORD, 0x18008c1f);\r\nrtl_set_bbreg(hw, 0xe38, MASKDWORD, 0x82140307);\r\nrtl_set_bbreg(hw, 0xe3c, MASKDWORD, 0x68160960);\r\nif (configpathb) {\r\nrtl_set_bbreg(hw, 0xe50, MASKDWORD, 0x18008c2f);\r\nrtl_set_bbreg(hw, 0xe54, MASKDWORD, 0x18008c2f);\r\nrtl_set_bbreg(hw, 0xe58, MASKDWORD, 0x82110000);\r\nrtl_set_bbreg(hw, 0xe5c, MASKDWORD, 0x68110000);\r\n}\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "LO calibration setting!\n");\r\nrtl_set_bbreg(hw, 0xe4c, MASKDWORD, 0x00462911);\r\nrtl_set_bbreg(hw, RFPGA0_XAB_RFINTERFACESW, MASKDWORD, 0x07000f60);\r\nrtl_set_bbreg(hw, RFPGA0_XA_RFINTERFACEOE, MASKDWORD, 0x66e60e30);\r\nfor (i = 0; i < retrycount; i++) {\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK,\r\n"One shot, path A LOK & IQK!\n");\r\nrtl_set_bbreg(hw, 0xe48, MASKDWORD, 0xf9000000);\r\nrtl_set_bbreg(hw, 0xe48, MASKDWORD, 0xf8000000);\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK,\r\n"Delay %d ms for One shot, path A LOK & IQK.\n",\r\nIQK_DELAY_TIME);\r\nmdelay(IQK_DELAY_TIME * 10);\r\nregeac = rtl_get_bbreg(hw, 0xeac, MASKDWORD);\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "0xeac = 0x%x\n", regeac);\r\nrege94 = rtl_get_bbreg(hw, 0xe94, MASKDWORD);\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "0xe94 = 0x%x\n", rege94);\r\nrege9c = rtl_get_bbreg(hw, 0xe9c, MASKDWORD);\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "0xe9c = 0x%x\n", rege9c);\r\nregea4 = rtl_get_bbreg(hw, 0xea4, MASKDWORD);\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "0xea4 = 0x%x\n", regea4);\r\nif (!(regeac & TxOKBit) &&\r\n(((rege94 & 0x03FF0000) >> 16) != 0x142)) {\r\nresult |= 0x01;\r\n} else {\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK,\r\n"Path A Tx IQK fail!!\n");\r\ncontinue;\r\n}\r\nif (!(regeac & RxOKBit) &&\r\n(((regea4 & 0x03FF0000) >> 16) != 0x132)) {\r\nresult |= 0x02;\r\nbreak;\r\n} else {\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK,\r\n"Path A Rx IQK fail!!\n");\r\n}\r\n}\r\nrtl_set_bbreg(hw, RFPGA0_XAB_RFINTERFACESW, MASKDWORD,\r\nrtlphy->iqk_bb_backup[0]);\r\nrtl_set_bbreg(hw, RFPGA0_XA_RFINTERFACEOE, MASKDWORD,\r\nrtlphy->iqk_bb_backup[1]);\r\nreturn result;\r\n}\r\nstatic u8 _rtl92d_phy_pathb_iqk(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu32 regeac, regeb4, regebc, regec4, regecc;\r\nu8 result = 0;\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "Path B IQK!\n");\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "One shot, path A LOK & IQK!\n");\r\nrtl_set_bbreg(hw, 0xe60, MASKDWORD, 0x00000002);\r\nrtl_set_bbreg(hw, 0xe60, MASKDWORD, 0x00000000);\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK,\r\n"Delay %d ms for One shot, path B LOK & IQK\n", IQK_DELAY_TIME);\r\nmdelay(IQK_DELAY_TIME);\r\nregeac = rtl_get_bbreg(hw, 0xeac, MASKDWORD);\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "0xeac = 0x%x\n", regeac);\r\nregeb4 = rtl_get_bbreg(hw, 0xeb4, MASKDWORD);\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "0xeb4 = 0x%x\n", regeb4);\r\nregebc = rtl_get_bbreg(hw, 0xebc, MASKDWORD);\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "0xebc = 0x%x\n", regebc);\r\nregec4 = rtl_get_bbreg(hw, 0xec4, MASKDWORD);\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "0xec4 = 0x%x\n", regec4);\r\nregecc = rtl_get_bbreg(hw, 0xecc, MASKDWORD);\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "0xecc = 0x%x\n", regecc);\r\nif (!(regeac & BIT(31)) && (((regeb4 & 0x03FF0000) >> 16) != 0x142) &&\r\n(((regebc & 0x03FF0000) >> 16) != 0x42))\r\nresult |= 0x01;\r\nelse\r\nreturn result;\r\nif (!(regeac & BIT(30)) && (((regec4 & 0x03FF0000) >> 16) != 0x132) &&\r\n(((regecc & 0x03FF0000) >> 16) != 0x36))\r\nresult |= 0x02;\r\nelse\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "Path B Rx IQK fail!!\n");\r\nreturn result;\r\n}\r\nstatic u8 _rtl92d_phy_pathb_iqk_5g_normal(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_phy *rtlphy = &(rtlpriv->phy);\r\nu32 regeac, regeb4, regebc, regec4, regecc;\r\nu8 result = 0;\r\nu8 i;\r\nu8 retrycount = 2;\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "Path B IQK!\n");\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "Path-A IQK setting!\n");\r\nrtl_set_bbreg(hw, 0xe30, MASKDWORD, 0x18008c1f);\r\nrtl_set_bbreg(hw, 0xe34, MASKDWORD, 0x18008c1f);\r\nrtl_set_bbreg(hw, 0xe38, MASKDWORD, 0x82110000);\r\nrtl_set_bbreg(hw, 0xe3c, MASKDWORD, 0x68110000);\r\nrtl_set_bbreg(hw, 0xe50, MASKDWORD, 0x18008c2f);\r\nrtl_set_bbreg(hw, 0xe54, MASKDWORD, 0x18008c2f);\r\nrtl_set_bbreg(hw, 0xe58, MASKDWORD, 0x82140307);\r\nrtl_set_bbreg(hw, 0xe5c, MASKDWORD, 0x68160960);\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "LO calibration setting!\n");\r\nrtl_set_bbreg(hw, 0xe4c, MASKDWORD, 0x00462911);\r\nrtl_set_bbreg(hw, RFPGA0_XAB_RFINTERFACESW, MASKDWORD, 0x0f600700);\r\nrtl_set_bbreg(hw, RFPGA0_XB_RFINTERFACEOE, MASKDWORD, 0x061f0d30);\r\nfor (i = 0; i < retrycount; i++) {\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK,\r\n"One shot, path A LOK & IQK!\n");\r\nrtl_set_bbreg(hw, 0xe48, MASKDWORD, 0xfa000000);\r\nrtl_set_bbreg(hw, 0xe48, MASKDWORD, 0xf8000000);\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK,\r\n"Delay %d ms for One shot, path B LOK & IQK.\n", 10);\r\nmdelay(IQK_DELAY_TIME * 10);\r\nregeac = rtl_get_bbreg(hw, 0xeac, MASKDWORD);\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "0xeac = 0x%x\n", regeac);\r\nregeb4 = rtl_get_bbreg(hw, 0xeb4, MASKDWORD);\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "0xeb4 = 0x%x\n", regeb4);\r\nregebc = rtl_get_bbreg(hw, 0xebc, MASKDWORD);\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "0xebc = 0x%x\n", regebc);\r\nregec4 = rtl_get_bbreg(hw, 0xec4, MASKDWORD);\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "0xec4 = 0x%x\n", regec4);\r\nregecc = rtl_get_bbreg(hw, 0xecc, MASKDWORD);\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "0xecc = 0x%x\n", regecc);\r\nif (!(regeac & BIT(31)) &&\r\n(((regeb4 & 0x03FF0000) >> 16) != 0x142))\r\nresult |= 0x01;\r\nelse\r\ncontinue;\r\nif (!(regeac & BIT(30)) &&\r\n(((regec4 & 0x03FF0000) >> 16) != 0x132)) {\r\nresult |= 0x02;\r\nbreak;\r\n} else {\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK,\r\n"Path B Rx IQK fail!!\n");\r\n}\r\n}\r\nrtl_set_bbreg(hw, RFPGA0_XAB_RFINTERFACESW, MASKDWORD,\r\nrtlphy->iqk_bb_backup[0]);\r\nrtl_set_bbreg(hw, RFPGA0_XB_RFINTERFACEOE, MASKDWORD,\r\nrtlphy->iqk_bb_backup[2]);\r\nreturn result;\r\n}\r\nstatic void _rtl92d_phy_save_adda_registers(struct ieee80211_hw *hw,\r\nu32 *adda_reg, u32 *adda_backup,\r\nu32 regnum)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu32 i;\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "Save ADDA parameters.\n");\r\nfor (i = 0; i < regnum; i++)\r\nadda_backup[i] = rtl_get_bbreg(hw, adda_reg[i], MASKDWORD);\r\n}\r\nstatic void _rtl92d_phy_save_mac_registers(struct ieee80211_hw *hw,\r\nu32 *macreg, u32 *macbackup)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu32 i;\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "Save MAC parameters.\n");\r\nfor (i = 0; i < (IQK_MAC_REG_NUM - 1); i++)\r\nmacbackup[i] = rtl_read_byte(rtlpriv, macreg[i]);\r\nmacbackup[i] = rtl_read_dword(rtlpriv, macreg[i]);\r\n}\r\nstatic void _rtl92d_phy_reload_adda_registers(struct ieee80211_hw *hw,\r\nu32 *adda_reg, u32 *adda_backup,\r\nu32 regnum)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu32 i;\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK,\r\n"Reload ADDA power saving parameters !\n");\r\nfor (i = 0; i < regnum; i++)\r\nrtl_set_bbreg(hw, adda_reg[i], MASKDWORD, adda_backup[i]);\r\n}\r\nstatic void _rtl92d_phy_reload_mac_registers(struct ieee80211_hw *hw,\r\nu32 *macreg, u32 *macbackup)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu32 i;\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "Reload MAC parameters !\n");\r\nfor (i = 0; i < (IQK_MAC_REG_NUM - 1); i++)\r\nrtl_write_byte(rtlpriv, macreg[i], (u8) macbackup[i]);\r\nrtl_write_byte(rtlpriv, macreg[i], macbackup[i]);\r\n}\r\nstatic void _rtl92d_phy_path_adda_on(struct ieee80211_hw *hw,\r\nu32 *adda_reg, bool patha_on, bool is2t)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu32 pathon;\r\nu32 i;\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "ADDA ON.\n");\r\npathon = patha_on ? 0x04db25a4 : 0x0b1b25a4;\r\nif (patha_on)\r\npathon = rtlpriv->rtlhal.interfaceindex == 0 ?\r\n0x04db25a4 : 0x0b1b25a4;\r\nfor (i = 0; i < IQK_ADDA_REG_NUM; i++)\r\nrtl_set_bbreg(hw, adda_reg[i], MASKDWORD, pathon);\r\n}\r\nstatic void _rtl92d_phy_mac_setting_calibration(struct ieee80211_hw *hw,\r\nu32 *macreg, u32 *macbackup)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu32 i;\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "MAC settings for Calibration.\n");\r\nrtl_write_byte(rtlpriv, macreg[0], 0x3F);\r\nfor (i = 1; i < (IQK_MAC_REG_NUM - 1); i++)\r\nrtl_write_byte(rtlpriv, macreg[i], (u8)(macbackup[i] &\r\n(~BIT(3))));\r\nrtl_write_byte(rtlpriv, macreg[i], (u8) (macbackup[i] & (~BIT(5))));\r\n}\r\nstatic void _rtl92d_phy_patha_standby(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "Path-A standby mode!\n");\r\nrtl_set_bbreg(hw, 0xe28, MASKDWORD, 0x0);\r\nrtl_set_bbreg(hw, RFPGA0_XA_LSSIPARAMETER, MASKDWORD, 0x00010000);\r\nrtl_set_bbreg(hw, 0xe28, MASKDWORD, 0x80800000);\r\n}\r\nstatic void _rtl92d_phy_pimode_switch(struct ieee80211_hw *hw, bool pi_mode)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu32 mode;\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK,\r\n"BB Switch to %s mode!\n", pi_mode ? "PI" : "SI");\r\nmode = pi_mode ? 0x01000100 : 0x01000000;\r\nrtl_set_bbreg(hw, 0x820, MASKDWORD, mode);\r\nrtl_set_bbreg(hw, 0x828, MASKDWORD, mode);\r\n}\r\nstatic void _rtl92d_phy_iq_calibrate(struct ieee80211_hw *hw, long result[][8],\r\nu8 t, bool is2t)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_phy *rtlphy = &(rtlpriv->phy);\r\nu32 i;\r\nu8 patha_ok, pathb_ok;\r\nstatic u32 adda_reg[IQK_ADDA_REG_NUM] = {\r\nRFPGA0_XCD_SWITCHCONTROL, 0xe6c, 0xe70, 0xe74,\r\n0xe78, 0xe7c, 0xe80, 0xe84,\r\n0xe88, 0xe8c, 0xed0, 0xed4,\r\n0xed8, 0xedc, 0xee0, 0xeec\r\n};\r\nstatic u32 iqk_mac_reg[IQK_MAC_REG_NUM] = {\r\n0x522, 0x550, 0x551, 0x040\r\n};\r\nstatic u32 iqk_bb_reg[IQK_BB_REG_NUM] = {\r\nRFPGA0_XAB_RFINTERFACESW, RFPGA0_XA_RFINTERFACEOE,\r\nRFPGA0_XB_RFINTERFACEOE, ROFDM0_TRMUXPAR,\r\nRFPGA0_XCD_RFINTERFACESW, ROFDM0_TRXPATHENABLE,\r\nRFPGA0_RFMOD, RFPGA0_ANALOGPARAMETER4,\r\nROFDM0_XAAGCCORE1, ROFDM0_XBAGCCORE1\r\n};\r\nconst u32 retrycount = 2;\r\nu32 bbvalue;\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "IQK for 2.4G :Start!!!\n");\r\nif (t == 0) {\r\nbbvalue = rtl_get_bbreg(hw, RFPGA0_RFMOD, MASKDWORD);\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "==>0x%08x\n", bbvalue);\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "IQ Calibration for %s\n",\r\nis2t ? "2T2R" : "1T1R");\r\n_rtl92d_phy_save_adda_registers(hw, adda_reg,\r\nrtlphy->adda_backup, IQK_ADDA_REG_NUM);\r\n_rtl92d_phy_save_mac_registers(hw, iqk_mac_reg,\r\nrtlphy->iqk_mac_backup);\r\n_rtl92d_phy_save_adda_registers(hw, iqk_bb_reg,\r\nrtlphy->iqk_bb_backup, IQK_BB_REG_NUM);\r\n}\r\n_rtl92d_phy_path_adda_on(hw, adda_reg, true, is2t);\r\nif (t == 0)\r\nrtlphy->rfpi_enable = (u8) rtl_get_bbreg(hw,\r\nRFPGA0_XA_HSSIPARAMETER1, BIT(8));\r\nif (!rtlphy->rfpi_enable)\r\n_rtl92d_phy_pimode_switch(hw, true);\r\nrtl_set_bbreg(hw, RFPGA0_RFMOD, BIT(24), 0x00);\r\nrtl_set_bbreg(hw, ROFDM0_TRXPATHENABLE, MASKDWORD, 0x03a05600);\r\nrtl_set_bbreg(hw, ROFDM0_TRMUXPAR, MASKDWORD, 0x000800e4);\r\nrtl_set_bbreg(hw, RFPGA0_XCD_RFINTERFACESW, MASKDWORD, 0x22204000);\r\nrtl_set_bbreg(hw, RFPGA0_ANALOGPARAMETER4, 0xf00000, 0x0f);\r\nif (is2t) {\r\nrtl_set_bbreg(hw, RFPGA0_XA_LSSIPARAMETER, MASKDWORD,\r\n0x00010000);\r\nrtl_set_bbreg(hw, RFPGA0_XB_LSSIPARAMETER, MASKDWORD,\r\n0x00010000);\r\n}\r\n_rtl92d_phy_mac_setting_calibration(hw, iqk_mac_reg,\r\nrtlphy->iqk_mac_backup);\r\nrtl_set_bbreg(hw, 0xb68, MASKDWORD, 0x0f600000);\r\nif (is2t)\r\nrtl_set_bbreg(hw, 0xb6c, MASKDWORD, 0x0f600000);\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "IQK setting!\n");\r\nrtl_set_bbreg(hw, 0xe28, MASKDWORD, 0x80800000);\r\nrtl_set_bbreg(hw, 0xe40, MASKDWORD, 0x01007c00);\r\nrtl_set_bbreg(hw, 0xe44, MASKDWORD, 0x01004800);\r\nfor (i = 0; i < retrycount; i++) {\r\npatha_ok = _rtl92d_phy_patha_iqk(hw, is2t);\r\nif (patha_ok == 0x03) {\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK,\r\n"Path A IQK Success!!\n");\r\nresult[t][0] = (rtl_get_bbreg(hw, 0xe94, MASKDWORD) &\r\n0x3FF0000) >> 16;\r\nresult[t][1] = (rtl_get_bbreg(hw, 0xe9c, MASKDWORD) &\r\n0x3FF0000) >> 16;\r\nresult[t][2] = (rtl_get_bbreg(hw, 0xea4, MASKDWORD) &\r\n0x3FF0000) >> 16;\r\nresult[t][3] = (rtl_get_bbreg(hw, 0xeac, MASKDWORD) &\r\n0x3FF0000) >> 16;\r\nbreak;\r\n} else if (i == (retrycount - 1) && patha_ok == 0x01) {\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK,\r\n"Path A IQK Only Tx Success!!\n");\r\nresult[t][0] = (rtl_get_bbreg(hw, 0xe94, MASKDWORD) &\r\n0x3FF0000) >> 16;\r\nresult[t][1] = (rtl_get_bbreg(hw, 0xe9c, MASKDWORD) &\r\n0x3FF0000) >> 16;\r\n}\r\n}\r\nif (0x00 == patha_ok)\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "Path A IQK failed!!\n");\r\nif (is2t) {\r\n_rtl92d_phy_patha_standby(hw);\r\n_rtl92d_phy_path_adda_on(hw, adda_reg, false, is2t);\r\nfor (i = 0; i < retrycount; i++) {\r\npathb_ok = _rtl92d_phy_pathb_iqk(hw);\r\nif (pathb_ok == 0x03) {\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK,\r\n"Path B IQK Success!!\n");\r\nresult[t][4] = (rtl_get_bbreg(hw, 0xeb4,\r\nMASKDWORD) & 0x3FF0000) >> 16;\r\nresult[t][5] = (rtl_get_bbreg(hw, 0xebc,\r\nMASKDWORD) & 0x3FF0000) >> 16;\r\nresult[t][6] = (rtl_get_bbreg(hw, 0xec4,\r\nMASKDWORD) & 0x3FF0000) >> 16;\r\nresult[t][7] = (rtl_get_bbreg(hw, 0xecc,\r\nMASKDWORD) & 0x3FF0000) >> 16;\r\nbreak;\r\n} else if (i == (retrycount - 1) && pathb_ok == 0x01) {\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK,\r\n"Path B Only Tx IQK Success!!\n");\r\nresult[t][4] = (rtl_get_bbreg(hw, 0xeb4,\r\nMASKDWORD) & 0x3FF0000) >> 16;\r\nresult[t][5] = (rtl_get_bbreg(hw, 0xebc,\r\nMASKDWORD) & 0x3FF0000) >> 16;\r\n}\r\n}\r\nif (0x00 == pathb_ok)\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK,\r\n"Path B IQK failed!!\n");\r\n}\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK,\r\n"IQK:Back to BB mode, load original value!\n");\r\nrtl_set_bbreg(hw, 0xe28, MASKDWORD, 0);\r\nif (t != 0) {\r\nif (!rtlphy->rfpi_enable)\r\n_rtl92d_phy_pimode_switch(hw, false);\r\n_rtl92d_phy_reload_adda_registers(hw, adda_reg,\r\nrtlphy->adda_backup, IQK_ADDA_REG_NUM);\r\n_rtl92d_phy_reload_mac_registers(hw, iqk_mac_reg,\r\nrtlphy->iqk_mac_backup);\r\nif (is2t)\r\n_rtl92d_phy_reload_adda_registers(hw, iqk_bb_reg,\r\nrtlphy->iqk_bb_backup,\r\nIQK_BB_REG_NUM);\r\nelse\r\n_rtl92d_phy_reload_adda_registers(hw, iqk_bb_reg,\r\nrtlphy->iqk_bb_backup,\r\nIQK_BB_REG_NUM - 1);\r\nrtl_set_bbreg(hw, 0xe30, MASKDWORD, 0x01008c00);\r\nrtl_set_bbreg(hw, 0xe34, MASKDWORD, 0x01008c00);\r\n}\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "<==\n");\r\n}\r\nstatic void _rtl92d_phy_iq_calibrate_5g_normal(struct ieee80211_hw *hw,\r\nlong result[][8], u8 t)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_phy *rtlphy = &(rtlpriv->phy);\r\nstruct rtl_hal *rtlhal = &(rtlpriv->rtlhal);\r\nu8 patha_ok, pathb_ok;\r\nstatic u32 adda_reg[IQK_ADDA_REG_NUM] = {\r\nRFPGA0_XCD_SWITCHCONTROL, 0xe6c, 0xe70, 0xe74,\r\n0xe78, 0xe7c, 0xe80, 0xe84,\r\n0xe88, 0xe8c, 0xed0, 0xed4,\r\n0xed8, 0xedc, 0xee0, 0xeec\r\n};\r\nstatic u32 iqk_mac_reg[IQK_MAC_REG_NUM] = {\r\n0x522, 0x550, 0x551, 0x040\r\n};\r\nstatic u32 iqk_bb_reg[IQK_BB_REG_NUM] = {\r\nRFPGA0_XAB_RFINTERFACESW, RFPGA0_XA_RFINTERFACEOE,\r\nRFPGA0_XB_RFINTERFACEOE, ROFDM0_TRMUXPAR,\r\nRFPGA0_XCD_RFINTERFACESW, ROFDM0_TRXPATHENABLE,\r\nRFPGA0_RFMOD, RFPGA0_ANALOGPARAMETER4,\r\nROFDM0_XAAGCCORE1, ROFDM0_XBAGCCORE1\r\n};\r\nu32 bbvalue;\r\nbool is2t = IS_92D_SINGLEPHY(rtlhal->version);\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "IQK for 5G NORMAL:Start!!!\n");\r\nmdelay(IQK_DELAY_TIME * 20);\r\nif (t == 0) {\r\nbbvalue = rtl_get_bbreg(hw, RFPGA0_RFMOD, MASKDWORD);\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "==>0x%08x\n", bbvalue);\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "IQ Calibration for %s\n",\r\nis2t ? "2T2R" : "1T1R");\r\n_rtl92d_phy_save_adda_registers(hw, adda_reg,\r\nrtlphy->adda_backup,\r\nIQK_ADDA_REG_NUM);\r\n_rtl92d_phy_save_mac_registers(hw, iqk_mac_reg,\r\nrtlphy->iqk_mac_backup);\r\nif (is2t)\r\n_rtl92d_phy_save_adda_registers(hw, iqk_bb_reg,\r\nrtlphy->iqk_bb_backup,\r\nIQK_BB_REG_NUM);\r\nelse\r\n_rtl92d_phy_save_adda_registers(hw, iqk_bb_reg,\r\nrtlphy->iqk_bb_backup,\r\nIQK_BB_REG_NUM - 1);\r\n}\r\n_rtl92d_phy_path_adda_on(hw, adda_reg, true, is2t);\r\n_rtl92d_phy_mac_setting_calibration(hw, iqk_mac_reg,\r\nrtlphy->iqk_mac_backup);\r\nif (t == 0)\r\nrtlphy->rfpi_enable = (u8) rtl_get_bbreg(hw,\r\nRFPGA0_XA_HSSIPARAMETER1, BIT(8));\r\nif (!rtlphy->rfpi_enable)\r\n_rtl92d_phy_pimode_switch(hw, true);\r\nrtl_set_bbreg(hw, RFPGA0_RFMOD, BIT(24), 0x00);\r\nrtl_set_bbreg(hw, ROFDM0_TRXPATHENABLE, MASKDWORD, 0x03a05600);\r\nrtl_set_bbreg(hw, ROFDM0_TRMUXPAR, MASKDWORD, 0x000800e4);\r\nrtl_set_bbreg(hw, RFPGA0_XCD_RFINTERFACESW, MASKDWORD, 0x22208000);\r\nrtl_set_bbreg(hw, RFPGA0_ANALOGPARAMETER4, 0xf00000, 0x0f);\r\nrtl_set_bbreg(hw, 0xb68, MASKDWORD, 0x0f600000);\r\nif (is2t)\r\nrtl_set_bbreg(hw, 0xb6c, MASKDWORD, 0x0f600000);\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "IQK setting!\n");\r\nrtl_set_bbreg(hw, 0xe28, MASKDWORD, 0x80800000);\r\nrtl_set_bbreg(hw, 0xe40, MASKDWORD, 0x10007c00);\r\nrtl_set_bbreg(hw, 0xe44, MASKDWORD, 0x01004800);\r\npatha_ok = _rtl92d_phy_patha_iqk_5g_normal(hw, is2t);\r\nif (patha_ok == 0x03) {\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "Path A IQK Success!!\n");\r\nresult[t][0] = (rtl_get_bbreg(hw, 0xe94, MASKDWORD) &\r\n0x3FF0000) >> 16;\r\nresult[t][1] = (rtl_get_bbreg(hw, 0xe9c, MASKDWORD) &\r\n0x3FF0000) >> 16;\r\nresult[t][2] = (rtl_get_bbreg(hw, 0xea4, MASKDWORD) &\r\n0x3FF0000) >> 16;\r\nresult[t][3] = (rtl_get_bbreg(hw, 0xeac, MASKDWORD) &\r\n0x3FF0000) >> 16;\r\n} else if (patha_ok == 0x01) {\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK,\r\n"Path A IQK Only Tx Success!!\n");\r\nresult[t][0] = (rtl_get_bbreg(hw, 0xe94, MASKDWORD) &\r\n0x3FF0000) >> 16;\r\nresult[t][1] = (rtl_get_bbreg(hw, 0xe9c, MASKDWORD) &\r\n0x3FF0000) >> 16;\r\n} else {\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "Path A IQK Fail!!\n");\r\n}\r\nif (is2t) {\r\n_rtl92d_phy_path_adda_on(hw, adda_reg, false, is2t);\r\npathb_ok = _rtl92d_phy_pathb_iqk_5g_normal(hw);\r\nif (pathb_ok == 0x03) {\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK,\r\n"Path B IQK Success!!\n");\r\nresult[t][4] = (rtl_get_bbreg(hw, 0xeb4, MASKDWORD) &\r\n0x3FF0000) >> 16;\r\nresult[t][5] = (rtl_get_bbreg(hw, 0xebc, MASKDWORD) &\r\n0x3FF0000) >> 16;\r\nresult[t][6] = (rtl_get_bbreg(hw, 0xec4, MASKDWORD) &\r\n0x3FF0000) >> 16;\r\nresult[t][7] = (rtl_get_bbreg(hw, 0xecc, MASKDWORD) &\r\n0x3FF0000) >> 16;\r\n} else if (pathb_ok == 0x01) {\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK,\r\n"Path B Only Tx IQK Success!!\n");\r\nresult[t][4] = (rtl_get_bbreg(hw, 0xeb4, MASKDWORD) &\r\n0x3FF0000) >> 16;\r\nresult[t][5] = (rtl_get_bbreg(hw, 0xebc, MASKDWORD) &\r\n0x3FF0000) >> 16;\r\n} else {\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK,\r\n"Path B IQK failed!!\n");\r\n}\r\n}\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK,\r\n"IQK:Back to BB mode, load original value!\n");\r\nrtl_set_bbreg(hw, 0xe28, MASKDWORD, 0);\r\nif (t != 0) {\r\nif (is2t)\r\n_rtl92d_phy_reload_adda_registers(hw, iqk_bb_reg,\r\nrtlphy->iqk_bb_backup,\r\nIQK_BB_REG_NUM);\r\nelse\r\n_rtl92d_phy_reload_adda_registers(hw, iqk_bb_reg,\r\nrtlphy->iqk_bb_backup,\r\nIQK_BB_REG_NUM - 1);\r\n_rtl92d_phy_reload_mac_registers(hw, iqk_mac_reg,\r\nrtlphy->iqk_mac_backup);\r\nif (!rtlphy->rfpi_enable)\r\n_rtl92d_phy_pimode_switch(hw, false);\r\n_rtl92d_phy_reload_adda_registers(hw, adda_reg,\r\nrtlphy->adda_backup,\r\nIQK_ADDA_REG_NUM);\r\n}\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "<==\n");\r\n}\r\nstatic bool _rtl92d_phy_simularity_compare(struct ieee80211_hw *hw,\r\nlong result[][8], u8 c1, u8 c2)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_hal *rtlhal = &(rtlpriv->rtlhal);\r\nu32 i, j, diff, sim_bitmap, bound;\r\nu8 final_candidate[2] = {0xFF, 0xFF};\r\nbool bresult = true;\r\nbool is2t = IS_92D_SINGLEPHY(rtlhal->version);\r\nif (is2t)\r\nbound = 8;\r\nelse\r\nbound = 4;\r\nsim_bitmap = 0;\r\nfor (i = 0; i < bound; i++) {\r\ndiff = (result[c1][i] > result[c2][i]) ? (result[c1][i] -\r\nresult[c2][i]) : (result[c2][i] - result[c1][i]);\r\nif (diff > MAX_TOLERANCE_92D) {\r\nif ((i == 2 || i == 6) && !sim_bitmap) {\r\nif (result[c1][i] + result[c1][i + 1] == 0)\r\nfinal_candidate[(i / 4)] = c2;\r\nelse if (result[c2][i] + result[c2][i + 1] == 0)\r\nfinal_candidate[(i / 4)] = c1;\r\nelse\r\nsim_bitmap = sim_bitmap | (1 << i);\r\n} else {\r\nsim_bitmap = sim_bitmap | (1 << i);\r\n}\r\n}\r\n}\r\nif (sim_bitmap == 0) {\r\nfor (i = 0; i < (bound / 4); i++) {\r\nif (final_candidate[i] != 0xFF) {\r\nfor (j = i * 4; j < (i + 1) * 4 - 2; j++)\r\nresult[3][j] =\r\nresult[final_candidate[i]][j];\r\nbresult = false;\r\n}\r\n}\r\nreturn bresult;\r\n}\r\nif (!(sim_bitmap & 0x0F)) {\r\nfor (i = 0; i < 4; i++)\r\nresult[3][i] = result[c1][i];\r\n} else if (!(sim_bitmap & 0x03)) {\r\nfor (i = 0; i < 2; i++)\r\nresult[3][i] = result[c1][i];\r\n}\r\nif (!(sim_bitmap & 0xF0) && is2t) {\r\nfor (i = 4; i < 8; i++)\r\nresult[3][i] = result[c1][i];\r\n} else if (!(sim_bitmap & 0x30)) {\r\nfor (i = 4; i < 6; i++)\r\nresult[3][i] = result[c1][i];\r\n}\r\nreturn false;\r\n}\r\nstatic void _rtl92d_phy_patha_fill_iqk_matrix(struct ieee80211_hw *hw,\r\nbool iqk_ok, long result[][8],\r\nu8 final_candidate, bool txonly)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_hal *rtlhal = &(rtlpriv->rtlhal);\r\nu32 oldval_0, val_x, tx0_a, reg;\r\nlong val_y, tx0_c;\r\nbool is2t = IS_92D_SINGLEPHY(rtlhal->version) ||\r\nrtlhal->macphymode == DUALMAC_DUALPHY;\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK,\r\n"Path A IQ Calibration %s !\n", iqk_ok ? "Success" : "Failed");\r\nif (final_candidate == 0xFF) {\r\nreturn;\r\n} else if (iqk_ok) {\r\noldval_0 = (rtl_get_bbreg(hw, ROFDM0_XATxIQIMBALANCE,\r\nMASKDWORD) >> 22) & 0x3FF;\r\nval_x = result[final_candidate][0];\r\nif ((val_x & 0x00000200) != 0)\r\nval_x = val_x | 0xFFFFFC00;\r\ntx0_a = (val_x * oldval_0) >> 8;\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK,\r\n"X = 0x%x, tx0_a = 0x%x, oldval_0 0x%x\n",\r\nval_x, tx0_a, oldval_0);\r\nrtl_set_bbreg(hw, ROFDM0_XATxIQIMBALANCE, 0x3FF, tx0_a);\r\nrtl_set_bbreg(hw, ROFDM0_ECCATHRESHOLD, BIT(24),\r\n((val_x * oldval_0 >> 7) & 0x1));\r\nval_y = result[final_candidate][1];\r\nif ((val_y & 0x00000200) != 0)\r\nval_y = val_y | 0xFFFFFC00;\r\nif (rtlhal->interfaceindex == 1 &&\r\nrtlhal->current_bandtype == BAND_ON_5G)\r\nval_y += 3;\r\ntx0_c = (val_y * oldval_0) >> 8;\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK,\r\n"Y = 0x%lx, tx0_c = 0x%lx\n",\r\nval_y, tx0_c);\r\nrtl_set_bbreg(hw, ROFDM0_XCTxAFE, 0xF0000000,\r\n((tx0_c & 0x3C0) >> 6));\r\nrtl_set_bbreg(hw, ROFDM0_XATxIQIMBALANCE, 0x003F0000,\r\n(tx0_c & 0x3F));\r\nif (is2t)\r\nrtl_set_bbreg(hw, ROFDM0_ECCATHRESHOLD, BIT(26),\r\n((val_y * oldval_0 >> 7) & 0x1));\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "0xC80 = 0x%x\n",\r\nrtl_get_bbreg(hw, ROFDM0_XATxIQIMBALANCE,\r\nMASKDWORD));\r\nif (txonly) {\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "only Tx OK\n");\r\nreturn;\r\n}\r\nreg = result[final_candidate][2];\r\nrtl_set_bbreg(hw, ROFDM0_XARXIQIMBALANCE, 0x3FF, reg);\r\nreg = result[final_candidate][3] & 0x3F;\r\nrtl_set_bbreg(hw, ROFDM0_XARXIQIMBALANCE, 0xFC00, reg);\r\nreg = (result[final_candidate][3] >> 6) & 0xF;\r\nrtl_set_bbreg(hw, 0xca0, 0xF0000000, reg);\r\n}\r\n}\r\nstatic void _rtl92d_phy_pathb_fill_iqk_matrix(struct ieee80211_hw *hw,\r\nbool iqk_ok, long result[][8], u8 final_candidate, bool txonly)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_hal *rtlhal = &(rtlpriv->rtlhal);\r\nu32 oldval_1, val_x, tx1_a, reg;\r\nlong val_y, tx1_c;\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "Path B IQ Calibration %s !\n",\r\niqk_ok ? "Success" : "Failed");\r\nif (final_candidate == 0xFF) {\r\nreturn;\r\n} else if (iqk_ok) {\r\noldval_1 = (rtl_get_bbreg(hw, ROFDM0_XBTxIQIMBALANCE,\r\nMASKDWORD) >> 22) & 0x3FF;\r\nval_x = result[final_candidate][4];\r\nif ((val_x & 0x00000200) != 0)\r\nval_x = val_x | 0xFFFFFC00;\r\ntx1_a = (val_x * oldval_1) >> 8;\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "X = 0x%x, tx1_a = 0x%x\n",\r\nval_x, tx1_a);\r\nrtl_set_bbreg(hw, ROFDM0_XBTxIQIMBALANCE, 0x3FF, tx1_a);\r\nrtl_set_bbreg(hw, ROFDM0_ECCATHRESHOLD, BIT(28),\r\n((val_x * oldval_1 >> 7) & 0x1));\r\nval_y = result[final_candidate][5];\r\nif ((val_y & 0x00000200) != 0)\r\nval_y = val_y | 0xFFFFFC00;\r\nif (rtlhal->current_bandtype == BAND_ON_5G)\r\nval_y += 3;\r\ntx1_c = (val_y * oldval_1) >> 8;\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "Y = 0x%lx, tx1_c = 0x%lx\n",\r\nval_y, tx1_c);\r\nrtl_set_bbreg(hw, ROFDM0_XDTxAFE, 0xF0000000,\r\n((tx1_c & 0x3C0) >> 6));\r\nrtl_set_bbreg(hw, ROFDM0_XBTxIQIMBALANCE, 0x003F0000,\r\n(tx1_c & 0x3F));\r\nrtl_set_bbreg(hw, ROFDM0_ECCATHRESHOLD, BIT(30),\r\n((val_y * oldval_1 >> 7) & 0x1));\r\nif (txonly)\r\nreturn;\r\nreg = result[final_candidate][6];\r\nrtl_set_bbreg(hw, ROFDM0_XBRXIQIMBALANCE, 0x3FF, reg);\r\nreg = result[final_candidate][7] & 0x3F;\r\nrtl_set_bbreg(hw, ROFDM0_XBRXIQIMBALANCE, 0xFC00, reg);\r\nreg = (result[final_candidate][7] >> 6) & 0xF;\r\nrtl_set_bbreg(hw, ROFDM0_AGCRSSITABLE, 0x0000F000, reg);\r\n}\r\n}\r\nvoid rtl92d_phy_iq_calibrate(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_phy *rtlphy = &(rtlpriv->phy);\r\nstruct rtl_hal *rtlhal = &(rtlpriv->rtlhal);\r\nlong result[4][8];\r\nu8 i, final_candidate, indexforchannel;\r\nbool patha_ok, pathb_ok;\r\nlong rege94, rege9c, regea4, regeac, regeb4;\r\nlong regebc, regec4, regecc, regtmp = 0;\r\nbool is12simular, is13simular, is23simular;\r\nunsigned long flag = 0;\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK,\r\n"IQK:Start!!!channel %d\n", rtlphy->current_channel);\r\nfor (i = 0; i < 8; i++) {\r\nresult[0][i] = 0;\r\nresult[1][i] = 0;\r\nresult[2][i] = 0;\r\nresult[3][i] = 0;\r\n}\r\nfinal_candidate = 0xff;\r\npatha_ok = false;\r\npathb_ok = false;\r\nis12simular = false;\r\nis23simular = false;\r\nis13simular = false;\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK,\r\n"IQK !!!currentband %d\n", rtlhal->current_bandtype);\r\nrtl92d_acquire_cckandrw_pagea_ctl(hw, &flag);\r\nfor (i = 0; i < 3; i++) {\r\nif (rtlhal->current_bandtype == BAND_ON_5G) {\r\n_rtl92d_phy_iq_calibrate_5g_normal(hw, result, i);\r\n} else if (rtlhal->current_bandtype == BAND_ON_2_4G) {\r\nif (IS_92D_SINGLEPHY(rtlhal->version))\r\n_rtl92d_phy_iq_calibrate(hw, result, i, true);\r\nelse\r\n_rtl92d_phy_iq_calibrate(hw, result, i, false);\r\n}\r\nif (i == 1) {\r\nis12simular = _rtl92d_phy_simularity_compare(hw, result,\r\n0, 1);\r\nif (is12simular) {\r\nfinal_candidate = 0;\r\nbreak;\r\n}\r\n}\r\nif (i == 2) {\r\nis13simular = _rtl92d_phy_simularity_compare(hw, result,\r\n0, 2);\r\nif (is13simular) {\r\nfinal_candidate = 0;\r\nbreak;\r\n}\r\nis23simular = _rtl92d_phy_simularity_compare(hw, result,\r\n1, 2);\r\nif (is23simular) {\r\nfinal_candidate = 1;\r\n} else {\r\nfor (i = 0; i < 8; i++)\r\nregtmp += result[3][i];\r\nif (regtmp != 0)\r\nfinal_candidate = 3;\r\nelse\r\nfinal_candidate = 0xFF;\r\n}\r\n}\r\n}\r\nrtl92d_release_cckandrw_pagea_ctl(hw, &flag);\r\nfor (i = 0; i < 4; i++) {\r\nrege94 = result[i][0];\r\nrege9c = result[i][1];\r\nregea4 = result[i][2];\r\nregeac = result[i][3];\r\nregeb4 = result[i][4];\r\nregebc = result[i][5];\r\nregec4 = result[i][6];\r\nregecc = result[i][7];\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK,\r\n"IQK: rege94=%lx rege9c=%lx regea4=%lx regeac=%lx regeb4=%lx regebc=%lx regec4=%lx regecc=%lx\n",\r\nrege94, rege9c, regea4, regeac, regeb4, regebc, regec4,\r\nregecc);\r\n}\r\nif (final_candidate != 0xff) {\r\nrtlphy->reg_e94 = rege94 = result[final_candidate][0];\r\nrtlphy->reg_e9c = rege9c = result[final_candidate][1];\r\nregea4 = result[final_candidate][2];\r\nregeac = result[final_candidate][3];\r\nrtlphy->reg_eb4 = regeb4 = result[final_candidate][4];\r\nrtlphy->reg_ebc = regebc = result[final_candidate][5];\r\nregec4 = result[final_candidate][6];\r\nregecc = result[final_candidate][7];\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK,\r\n"IQK: final_candidate is %x\n", final_candidate);\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK,\r\n"IQK: rege94=%lx rege9c=%lx regea4=%lx regeac=%lx regeb4=%lx regebc=%lx regec4=%lx regecc=%lx\n",\r\nrege94, rege9c, regea4, regeac, regeb4, regebc, regec4,\r\nregecc);\r\npatha_ok = pathb_ok = true;\r\n} else {\r\nrtlphy->reg_e94 = rtlphy->reg_eb4 = 0x100;\r\nrtlphy->reg_e9c = rtlphy->reg_ebc = 0x0;\r\n}\r\nif ((rege94 != 0) )\r\n_rtl92d_phy_patha_fill_iqk_matrix(hw, patha_ok, result,\r\nfinal_candidate, (regea4 == 0));\r\nif (IS_92D_SINGLEPHY(rtlhal->version)) {\r\nif ((regeb4 != 0) )\r\n_rtl92d_phy_pathb_fill_iqk_matrix(hw, pathb_ok, result,\r\nfinal_candidate, (regec4 == 0));\r\n}\r\nif (final_candidate != 0xFF) {\r\nindexforchannel = rtl92d_get_rightchnlplace_for_iqk(\r\nrtlphy->current_channel);\r\nfor (i = 0; i < IQK_MATRIX_REG_NUM; i++)\r\nrtlphy->iqk_matrix[indexforchannel].\r\nvalue[0][i] = result[final_candidate][i];\r\nrtlphy->iqk_matrix[indexforchannel].iqk_done =\r\ntrue;\r\nRT_TRACE(rtlpriv, COMP_SCAN | COMP_MLME, DBG_LOUD,\r\n"IQK OK indexforchannel %d\n", indexforchannel);\r\n}\r\n}\r\nvoid rtl92d_phy_reload_iqk_setting(struct ieee80211_hw *hw, u8 channel)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_phy *rtlphy = &(rtlpriv->phy);\r\nstruct rtl_hal *rtlhal = &(rtlpriv->rtlhal);\r\nu8 indexforchannel;\r\nRT_TRACE(rtlpriv, COMP_CMD, DBG_LOUD, "channel %d\n", channel);\r\nindexforchannel = rtl92d_get_rightchnlplace_for_iqk(channel);\r\nRT_TRACE(rtlpriv, COMP_CMD, DBG_LOUD, "indexforchannel %d done %d\n",\r\nindexforchannel,\r\nrtlphy->iqk_matrix[indexforchannel].iqk_done);\r\nif (0 && !rtlphy->iqk_matrix[indexforchannel].iqk_done &&\r\nrtlphy->need_iqk) {\r\nRT_TRACE(rtlpriv, COMP_SCAN | COMP_INIT, DBG_LOUD,\r\n"Do IQK Matrix reg for channel:%d....\n", channel);\r\nrtl92d_phy_iq_calibrate(hw);\r\n} else {\r\nif (((!rtlhal->load_imrandiqk_setting_for2g) &&\r\nindexforchannel == 0) || indexforchannel > 0) {\r\nRT_TRACE(rtlpriv, COMP_SCAN, DBG_LOUD,\r\n"Just Read IQK Matrix reg for channel:%d....\n",\r\nchannel);\r\nif ((rtlphy->iqk_matrix[indexforchannel].\r\nvalue[0] != NULL)\r\n)\r\n_rtl92d_phy_patha_fill_iqk_matrix(hw, true,\r\nrtlphy->iqk_matrix[\r\nindexforchannel].value, 0,\r\n(rtlphy->iqk_matrix[\r\nindexforchannel].value[0][2] == 0));\r\nif (IS_92D_SINGLEPHY(rtlhal->version)) {\r\nif ((rtlphy->iqk_matrix[\r\nindexforchannel].value[0][4] != 0)\r\n)\r\n_rtl92d_phy_pathb_fill_iqk_matrix(hw,\r\ntrue,\r\nrtlphy->iqk_matrix[\r\nindexforchannel].value, 0,\r\n(rtlphy->iqk_matrix[\r\nindexforchannel].value[0][6]\r\n== 0));\r\n}\r\n}\r\n}\r\nrtlphy->need_iqk = false;\r\nRT_TRACE(rtlpriv, COMP_CMD, DBG_LOUD, "<====\n");\r\n}\r\nstatic u32 _rtl92d_phy_get_abs(u32 val1, u32 val2)\r\n{\r\nu32 ret;\r\nif (val1 >= val2)\r\nret = val1 - val2;\r\nelse\r\nret = val2 - val1;\r\nreturn ret;\r\n}\r\nstatic bool _rtl92d_is_legal_5g_channel(struct ieee80211_hw *hw, u8 channel)\r\n{\r\nint i;\r\nfor (i = 0; i < sizeof(channel5g); i++)\r\nif (channel == channel5g[i])\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void _rtl92d_phy_calc_curvindex(struct ieee80211_hw *hw,\r\nu32 *targetchnl, u32 * curvecount_val,\r\nbool is5g, u32 *curveindex)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu32 smallest_abs_val = 0xffffffff, u4tmp;\r\nu8 i, j;\r\nu8 chnl_num = is5g ? TARGET_CHNL_NUM_5G : TARGET_CHNL_NUM_2G;\r\nfor (i = 0; i < chnl_num; i++) {\r\nif (is5g && !_rtl92d_is_legal_5g_channel(hw, i + 1))\r\ncontinue;\r\ncurveindex[i] = 0;\r\nfor (j = 0; j < (CV_CURVE_CNT * 2); j++) {\r\nu4tmp = _rtl92d_phy_get_abs(targetchnl[i],\r\ncurvecount_val[j]);\r\nif (u4tmp < smallest_abs_val) {\r\ncurveindex[i] = j;\r\nsmallest_abs_val = u4tmp;\r\n}\r\n}\r\nsmallest_abs_val = 0xffffffff;\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "curveindex[%d] = %x\n",\r\ni, curveindex[i]);\r\n}\r\n}\r\nstatic void _rtl92d_phy_reload_lck_setting(struct ieee80211_hw *hw,\r\nu8 channel)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu8 erfpath = rtlpriv->rtlhal.current_bandtype ==\r\nBAND_ON_5G ? RF90_PATH_A :\r\nIS_92D_SINGLEPHY(rtlpriv->rtlhal.version) ?\r\nRF90_PATH_B : RF90_PATH_A;\r\nu32 u4tmp = 0, u4regvalue = 0;\r\nbool bneed_powerdown_radio = false;\r\nRT_TRACE(rtlpriv, COMP_CMD, DBG_LOUD, "path %d\n", erfpath);\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "band type = %d\n",\r\nrtlpriv->rtlhal.current_bandtype);\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "channel = %d\n", channel);\r\nif (rtlpriv->rtlhal.current_bandtype == BAND_ON_5G) {\r\nu4tmp = curveindex_5g[channel-1];\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK,\r\n"ver 1 set RF-A, 5G, 0x28 = 0x%x !!\n", u4tmp);\r\nif (rtlpriv->rtlhal.macphymode == DUALMAC_DUALPHY &&\r\nrtlpriv->rtlhal.interfaceindex == 1) {\r\nbneed_powerdown_radio =\r\nrtl92d_phy_enable_anotherphy(hw, false);\r\nrtlpriv->rtlhal.during_mac1init_radioa = true;\r\nif (bneed_powerdown_radio)\r\n_rtl92d_phy_enable_rf_env(hw, erfpath,\r\n&u4regvalue);\r\n}\r\nrtl_set_rfreg(hw, erfpath, RF_SYN_G4, 0x3f800, u4tmp);\r\nif (bneed_powerdown_radio)\r\n_rtl92d_phy_restore_rf_env(hw, erfpath, &u4regvalue);\r\nif (rtlpriv->rtlhal.during_mac1init_radioa)\r\nrtl92d_phy_powerdown_anotherphy(hw, false);\r\n} else if (rtlpriv->rtlhal.current_bandtype == BAND_ON_2_4G) {\r\nu4tmp = curveindex_2g[channel-1];\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK,\r\n"ver 3 set RF-B, 2G, 0x28 = 0x%x !!\n", u4tmp);\r\nif (rtlpriv->rtlhal.macphymode == DUALMAC_DUALPHY &&\r\nrtlpriv->rtlhal.interfaceindex == 0) {\r\nbneed_powerdown_radio =\r\nrtl92d_phy_enable_anotherphy(hw, true);\r\nrtlpriv->rtlhal.during_mac0init_radiob = true;\r\nif (bneed_powerdown_radio)\r\n_rtl92d_phy_enable_rf_env(hw, erfpath,\r\n&u4regvalue);\r\n}\r\nrtl_set_rfreg(hw, erfpath, RF_SYN_G4, 0x3f800, u4tmp);\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK,\r\n"ver 3 set RF-B, 2G, 0x28 = 0x%x !!\n",\r\nrtl_get_rfreg(hw, erfpath, RF_SYN_G4, 0x3f800));\r\nif (bneed_powerdown_radio)\r\n_rtl92d_phy_restore_rf_env(hw, erfpath, &u4regvalue);\r\nif (rtlpriv->rtlhal.during_mac0init_radiob)\r\nrtl92d_phy_powerdown_anotherphy(hw, true);\r\n}\r\nRT_TRACE(rtlpriv, COMP_CMD, DBG_LOUD, "<====\n");\r\n}\r\nstatic void _rtl92d_phy_lc_calibrate_sw(struct ieee80211_hw *hw, bool is2t)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_hal *rtlhal = &(rtlpriv->rtlhal);\r\nstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\r\nu8 tmpreg, index, rf_mode[2];\r\nu8 path = is2t ? 2 : 1;\r\nu8 i;\r\nu32 u4tmp, offset;\r\nu32 curvecount_val[CV_CURVE_CNT * 2] = {0};\r\nu16 timeout = 800, timecount = 0;\r\ntmpreg = rtl_read_byte(rtlpriv, 0xd03);\r\nif ((tmpreg & 0x70) != 0)\r\nrtl_write_byte(rtlpriv, 0xd03, tmpreg & 0x8F);\r\nelse\r\nrtl_write_byte(rtlpriv, REG_TXPAUSE, 0xFF);\r\nrtl_set_bbreg(hw, RFPGA0_ANALOGPARAMETER4, 0xF00000, 0x0F);\r\nfor (index = 0; index < path; index++) {\r\noffset = index == 0 ? ROFDM0_XAAGCCORE1 : ROFDM0_XBAGCCORE1;\r\nrf_mode[index] = rtl_read_byte(rtlpriv, offset);\r\nrtl_set_rfreg(hw, (enum radio_path)index, RF_AC,\r\nRFREG_OFFSET_MASK, 0x010000);\r\nif (rtlpci->init_ready) {\r\nrtl_set_rfreg(hw, (enum radio_path)index, RF_SYN_G7,\r\nBIT(17), 0x0);\r\nrtl_set_rfreg(hw, (enum radio_path)index, RF_CHNLBW,\r\n0x08000, 0x01);\r\n}\r\nu4tmp = rtl_get_rfreg(hw, (enum radio_path)index, RF_SYN_G6,\r\nRFREG_OFFSET_MASK);\r\nwhile ((!(u4tmp & BIT(11))) && timecount <= timeout) {\r\nmdelay(50);\r\ntimecount += 50;\r\nu4tmp = rtl_get_rfreg(hw, (enum radio_path)index,\r\nRF_SYN_G6, RFREG_OFFSET_MASK);\r\n}\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK,\r\n"PHY_LCK finish delay for %d ms=2\n", timecount);\r\nu4tmp = rtl_get_rfreg(hw, index, RF_SYN_G4, RFREG_OFFSET_MASK);\r\nif (index == 0 && rtlhal->interfaceindex == 0) {\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK,\r\n"path-A / 5G LCK\n");\r\n} else {\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK,\r\n"path-B / 2.4G LCK\n");\r\n}\r\nmemset(&curvecount_val[0], 0, CV_CURVE_CNT * 2);\r\nrtl_set_rfreg(hw, (enum radio_path)index, RF_CHNLBW,\r\n0x08000, 0x0);\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "set RF 0x18[15] = 0\n");\r\nfor (i = 0; i < CV_CURVE_CNT; i++) {\r\nu32 readval = 0, readval2 = 0;\r\nrtl_set_rfreg(hw, (enum radio_path)index, 0x3F,\r\n0x7f, i);\r\nrtl_set_rfreg(hw, (enum radio_path)index, 0x4D,\r\nRFREG_OFFSET_MASK, 0x0);\r\nreadval = rtl_get_rfreg(hw, (enum radio_path)index,\r\n0x4F, RFREG_OFFSET_MASK);\r\ncurvecount_val[2 * i + 1] = (readval & 0xfffe0) >> 5;\r\nreadval2 = rtl_get_rfreg(hw, (enum radio_path)index,\r\n0x50, 0xffc00);\r\ncurvecount_val[2 * i] = (((readval & 0x1F) << 10) |\r\nreadval2);\r\n}\r\nif (index == 0 && rtlhal->interfaceindex == 0)\r\n_rtl92d_phy_calc_curvindex(hw, targetchnl_5g,\r\ncurvecount_val,\r\ntrue, curveindex_5g);\r\nelse\r\n_rtl92d_phy_calc_curvindex(hw, targetchnl_2g,\r\ncurvecount_val,\r\nfalse, curveindex_2g);\r\nrtl_set_rfreg(hw, (enum radio_path)index, RF_SYN_G7,\r\nBIT(17), 0x1);\r\n}\r\nfor (index = 0; index < path; index++) {\r\noffset = index == 0 ? ROFDM0_XAAGCCORE1 : ROFDM0_XBAGCCORE1;\r\nrtl_write_byte(rtlpriv, offset, 0x50);\r\nrtl_write_byte(rtlpriv, offset, rf_mode[index]);\r\n}\r\nif ((tmpreg & 0x70) != 0)\r\nrtl_write_byte(rtlpriv, 0xd03, tmpreg);\r\nelse\r\nrtl_write_byte(rtlpriv, REG_TXPAUSE, 0x00);\r\nrtl_set_bbreg(hw, RFPGA0_ANALOGPARAMETER4, 0xF00000, 0x00);\r\n_rtl92d_phy_reload_lck_setting(hw, rtlpriv->phy.current_channel);\r\n}\r\nstatic void _rtl92d_phy_lc_calibrate(struct ieee80211_hw *hw, bool is2t)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "cosa PHY_LCK ver=2\n");\r\n_rtl92d_phy_lc_calibrate_sw(hw, is2t);\r\n}\r\nvoid rtl92d_phy_lc_calibrate(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_phy *rtlphy = &(rtlpriv->phy);\r\nstruct rtl_hal *rtlhal = &(rtlpriv->rtlhal);\r\nu32 timeout = 2000, timecount = 0;\r\nwhile (rtlpriv->mac80211.act_scanning && timecount < timeout) {\r\nudelay(50);\r\ntimecount += 50;\r\n}\r\nrtlphy->lck_inprogress = true;\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK,\r\n"LCK:Start!!! currentband %x delay %d ms\n",\r\nrtlhal->current_bandtype, timecount);\r\nif (IS_92D_SINGLEPHY(rtlhal->version)) {\r\n_rtl92d_phy_lc_calibrate(hw, true);\r\n} else {\r\n_rtl92d_phy_lc_calibrate(hw, false);\r\n}\r\nrtlphy->lck_inprogress = false;\r\nRTPRINT(rtlpriv, FINIT, INIT_IQK, "LCK:Finish!!!\n");\r\n}\r\nvoid rtl92d_phy_ap_calibrate(struct ieee80211_hw *hw, s8 delta)\r\n{\r\nreturn;\r\n}\r\nstatic bool _rtl92d_phy_set_sw_chnl_cmdarray(struct swchnlcmd *cmdtable,\r\nu32 cmdtableidx, u32 cmdtablesz, enum swchnlcmd_id cmdid,\r\nu32 para1, u32 para2, u32 msdelay)\r\n{\r\nstruct swchnlcmd *pcmd;\r\nif (cmdtable == NULL) {\r\nWARN_ONCE(true, "rtl8192de: cmdtable cannot be NULL\n");\r\nreturn false;\r\n}\r\nif (cmdtableidx >= cmdtablesz)\r\nreturn false;\r\npcmd = cmdtable + cmdtableidx;\r\npcmd->cmdid = cmdid;\r\npcmd->para1 = para1;\r\npcmd->para2 = para2;\r\npcmd->msdelay = msdelay;\r\nreturn true;\r\n}\r\nvoid rtl92d_phy_reset_iqk_result(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_phy *rtlphy = &(rtlpriv->phy);\r\nu8 i;\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"settings regs %d default regs %d\n",\r\n(int)(sizeof(rtlphy->iqk_matrix) /\r\nsizeof(struct iqk_matrix_regs)),\r\nIQK_MATRIX_REG_NUM);\r\nfor (i = 0; i < IQK_MATRIX_SETTINGS_NUM; i++) {\r\nrtlphy->iqk_matrix[i].value[0][0] = 0x100;\r\nrtlphy->iqk_matrix[i].value[0][2] = 0x100;\r\nrtlphy->iqk_matrix[i].value[0][4] = 0x100;\r\nrtlphy->iqk_matrix[i].value[0][6] = 0x100;\r\nrtlphy->iqk_matrix[i].value[0][1] = 0x0;\r\nrtlphy->iqk_matrix[i].value[0][3] = 0x0;\r\nrtlphy->iqk_matrix[i].value[0][5] = 0x0;\r\nrtlphy->iqk_matrix[i].value[0][7] = 0x0;\r\nrtlphy->iqk_matrix[i].iqk_done = false;\r\n}\r\n}\r\nstatic bool _rtl92d_phy_sw_chnl_step_by_step(struct ieee80211_hw *hw,\r\nu8 channel, u8 *stage, u8 *step,\r\nu32 *delay)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_phy *rtlphy = &(rtlpriv->phy);\r\nstruct swchnlcmd precommoncmd[MAX_PRECMD_CNT];\r\nu32 precommoncmdcnt;\r\nstruct swchnlcmd postcommoncmd[MAX_POSTCMD_CNT];\r\nu32 postcommoncmdcnt;\r\nstruct swchnlcmd rfdependcmd[MAX_RFDEPENDCMD_CNT];\r\nu32 rfdependcmdcnt;\r\nstruct swchnlcmd *currentcmd = NULL;\r\nu8 rfpath;\r\nu8 num_total_rfpath = rtlphy->num_total_rfpath;\r\nprecommoncmdcnt = 0;\r\n_rtl92d_phy_set_sw_chnl_cmdarray(precommoncmd, precommoncmdcnt++,\r\nMAX_PRECMD_CNT,\r\nCMDID_SET_TXPOWEROWER_LEVEL, 0, 0, 0);\r\n_rtl92d_phy_set_sw_chnl_cmdarray(precommoncmd, precommoncmdcnt++,\r\nMAX_PRECMD_CNT, CMDID_END, 0, 0, 0);\r\npostcommoncmdcnt = 0;\r\n_rtl92d_phy_set_sw_chnl_cmdarray(postcommoncmd, postcommoncmdcnt++,\r\nMAX_POSTCMD_CNT, CMDID_END, 0, 0, 0);\r\nrfdependcmdcnt = 0;\r\n_rtl92d_phy_set_sw_chnl_cmdarray(rfdependcmd, rfdependcmdcnt++,\r\nMAX_RFDEPENDCMD_CNT, CMDID_RF_WRITEREG,\r\nRF_CHNLBW, channel, 0);\r\n_rtl92d_phy_set_sw_chnl_cmdarray(rfdependcmd, rfdependcmdcnt++,\r\nMAX_RFDEPENDCMD_CNT, CMDID_END,\r\n0, 0, 0);\r\ndo {\r\nswitch (*stage) {\r\ncase 0:\r\ncurrentcmd = &precommoncmd[*step];\r\nbreak;\r\ncase 1:\r\ncurrentcmd = &rfdependcmd[*step];\r\nbreak;\r\ncase 2:\r\ncurrentcmd = &postcommoncmd[*step];\r\nbreak;\r\n}\r\nif (currentcmd->cmdid == CMDID_END) {\r\nif ((*stage) == 2) {\r\nreturn true;\r\n} else {\r\n(*stage)++;\r\n(*step) = 0;\r\ncontinue;\r\n}\r\n}\r\nswitch (currentcmd->cmdid) {\r\ncase CMDID_SET_TXPOWEROWER_LEVEL:\r\nrtl92d_phy_set_txpower_level(hw, channel);\r\nbreak;\r\ncase CMDID_WRITEPORT_ULONG:\r\nrtl_write_dword(rtlpriv, currentcmd->para1,\r\ncurrentcmd->para2);\r\nbreak;\r\ncase CMDID_WRITEPORT_USHORT:\r\nrtl_write_word(rtlpriv, currentcmd->para1,\r\n(u16)currentcmd->para2);\r\nbreak;\r\ncase CMDID_WRITEPORT_UCHAR:\r\nrtl_write_byte(rtlpriv, currentcmd->para1,\r\n(u8)currentcmd->para2);\r\nbreak;\r\ncase CMDID_RF_WRITEREG:\r\nfor (rfpath = 0; rfpath < num_total_rfpath; rfpath++) {\r\nrtlphy->rfreg_chnlval[rfpath] =\r\n((rtlphy->rfreg_chnlval[rfpath] &\r\n0xffffff00) | currentcmd->para2);\r\nif (rtlpriv->rtlhal.current_bandtype ==\r\nBAND_ON_5G) {\r\nif (currentcmd->para2 > 99)\r\nrtlphy->rfreg_chnlval[rfpath] =\r\nrtlphy->rfreg_chnlval\r\n[rfpath] | (BIT(18));\r\nelse\r\nrtlphy->rfreg_chnlval[rfpath] =\r\nrtlphy->rfreg_chnlval\r\n[rfpath] & (~BIT(18));\r\nrtlphy->rfreg_chnlval[rfpath] |=\r\n(BIT(16) | BIT(8));\r\n} else {\r\nrtlphy->rfreg_chnlval[rfpath] &=\r\n~(BIT(8) | BIT(16) | BIT(18));\r\n}\r\nrtl_set_rfreg(hw, (enum radio_path)rfpath,\r\ncurrentcmd->para1,\r\nRFREG_OFFSET_MASK,\r\nrtlphy->rfreg_chnlval[rfpath]);\r\n_rtl92d_phy_reload_imr_setting(hw, channel,\r\nrfpath);\r\n}\r\n_rtl92d_phy_switch_rf_setting(hw, channel);\r\nrtl92d_phy_reload_iqk_setting(hw, channel);\r\nbreak;\r\ndefault:\r\npr_err("switch case %#x not processed\n",\r\ncurrentcmd->cmdid);\r\nbreak;\r\n}\r\nbreak;\r\n} while (true);\r\n(*delay) = currentcmd->msdelay;\r\n(*step)++;\r\nreturn false;\r\n}\r\nu8 rtl92d_phy_sw_chnl(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_phy *rtlphy = &(rtlpriv->phy);\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nu32 delay;\r\nu32 timeout = 1000, timecount = 0;\r\nu8 channel = rtlphy->current_channel;\r\nu32 ret_value;\r\nif (rtlphy->sw_chnl_inprogress)\r\nreturn 0;\r\nif (rtlphy->set_bwmode_inprogress)\r\nreturn 0;\r\nif ((is_hal_stop(rtlhal)) || (RT_CANNOT_IO(hw))) {\r\nRT_TRACE(rtlpriv, COMP_CHAN, DBG_LOUD,\r\n"sw_chnl_inprogress false driver sleep or unload\n");\r\nreturn 0;\r\n}\r\nwhile (rtlphy->lck_inprogress && timecount < timeout) {\r\nmdelay(50);\r\ntimecount += 50;\r\n}\r\nif (rtlhal->macphymode == SINGLEMAC_SINGLEPHY &&\r\nrtlhal->bandset == BAND_ON_BOTH) {\r\nret_value = rtl_get_bbreg(hw, RFPGA0_XAB_RFPARAMETER,\r\nMASKDWORD);\r\nif (rtlphy->current_channel > 14 && !(ret_value & BIT(0)))\r\nrtl92d_phy_switch_wirelessband(hw, BAND_ON_5G);\r\nelse if (rtlphy->current_channel <= 14 && (ret_value & BIT(0)))\r\nrtl92d_phy_switch_wirelessband(hw, BAND_ON_2_4G);\r\n}\r\nswitch (rtlhal->current_bandtype) {\r\ncase BAND_ON_5G:\r\nif (channel <= 14)\r\nreturn 0;\r\nWARN_ONCE((channel <= 14), "rtl8192de: 5G but channel<=14\n");\r\nbreak;\r\ncase BAND_ON_2_4G:\r\nif (channel > 14)\r\nreturn 0;\r\nWARN_ONCE((channel > 14), "rtl8192de: 2G but channel>14\n");\r\nbreak;\r\ndefault:\r\nWARN_ONCE(true, "rtl8192de: Invalid WirelessMode(%#x)!!\n",\r\nrtlpriv->mac80211.mode);\r\nbreak;\r\n}\r\nrtlphy->sw_chnl_inprogress = true;\r\nif (channel == 0)\r\nchannel = 1;\r\nrtlphy->sw_chnl_stage = 0;\r\nrtlphy->sw_chnl_step = 0;\r\nRT_TRACE(rtlpriv, COMP_SCAN, DBG_TRACE,\r\n"switch to channel%d\n", rtlphy->current_channel);\r\ndo {\r\nif (!rtlphy->sw_chnl_inprogress)\r\nbreak;\r\nif (!_rtl92d_phy_sw_chnl_step_by_step(hw,\r\nrtlphy->current_channel,\r\n&rtlphy->sw_chnl_stage, &rtlphy->sw_chnl_step, &delay)) {\r\nif (delay > 0)\r\nmdelay(delay);\r\nelse\r\ncontinue;\r\n} else {\r\nrtlphy->sw_chnl_inprogress = false;\r\n}\r\nbreak;\r\n} while (true);\r\nRT_TRACE(rtlpriv, COMP_SCAN, DBG_TRACE, "<==\n");\r\nrtlphy->sw_chnl_inprogress = false;\r\nreturn 1;\r\n}\r\nstatic void rtl92d_phy_set_io(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct dig_t *de_digtable = &rtlpriv->dm_digtable;\r\nstruct rtl_phy *rtlphy = &(rtlpriv->phy);\r\nRT_TRACE(rtlpriv, COMP_CMD, DBG_TRACE,\r\n"--->Cmd(%#x), set_io_inprogress(%d)\n",\r\nrtlphy->current_io_type, rtlphy->set_io_inprogress);\r\nswitch (rtlphy->current_io_type) {\r\ncase IO_CMD_RESUME_DM_BY_SCAN:\r\nde_digtable->cur_igvalue = rtlphy->initgain_backup.xaagccore1;\r\nrtl92d_dm_write_dig(hw);\r\nrtl92d_phy_set_txpower_level(hw, rtlphy->current_channel);\r\nbreak;\r\ncase IO_CMD_PAUSE_DM_BY_SCAN:\r\nrtlphy->initgain_backup.xaagccore1 = de_digtable->cur_igvalue;\r\nde_digtable->cur_igvalue = 0x37;\r\nrtl92d_dm_write_dig(hw);\r\nbreak;\r\ndefault:\r\npr_err("switch case %#x not processed\n",\r\nrtlphy->current_io_type);\r\nbreak;\r\n}\r\nrtlphy->set_io_inprogress = false;\r\nRT_TRACE(rtlpriv, COMP_CMD, DBG_TRACE, "<---(%#x)\n",\r\nrtlphy->current_io_type);\r\n}\r\nbool rtl92d_phy_set_io_cmd(struct ieee80211_hw *hw, enum io_type iotype)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_phy *rtlphy = &(rtlpriv->phy);\r\nbool postprocessing = false;\r\nRT_TRACE(rtlpriv, COMP_CMD, DBG_TRACE,\r\n"-->IO Cmd(%#x), set_io_inprogress(%d)\n",\r\niotype, rtlphy->set_io_inprogress);\r\ndo {\r\nswitch (iotype) {\r\ncase IO_CMD_RESUME_DM_BY_SCAN:\r\nRT_TRACE(rtlpriv, COMP_CMD, DBG_TRACE,\r\n"[IO CMD] Resume DM after scan\n");\r\npostprocessing = true;\r\nbreak;\r\ncase IO_CMD_PAUSE_DM_BY_SCAN:\r\nRT_TRACE(rtlpriv, COMP_CMD, DBG_TRACE,\r\n"[IO CMD] Pause DM before scan\n");\r\npostprocessing = true;\r\nbreak;\r\ndefault:\r\npr_err("switch case %#x not processed\n",\r\niotype);\r\nbreak;\r\n}\r\n} while (false);\r\nif (postprocessing && !rtlphy->set_io_inprogress) {\r\nrtlphy->set_io_inprogress = true;\r\nrtlphy->current_io_type = iotype;\r\n} else {\r\nreturn false;\r\n}\r\nrtl92d_phy_set_io(hw);\r\nRT_TRACE(rtlpriv, COMP_CMD, DBG_TRACE, "<--IO Type(%#x)\n", iotype);\r\nreturn true;\r\n}\r\nstatic void _rtl92d_phy_set_rfon(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nif (rtlpriv->rtlhal.macphymode == SINGLEMAC_SINGLEPHY)\r\nrtl_write_byte(rtlpriv, REG_SPS0_CTRL, 0x2b);\r\nrtl_write_byte(rtlpriv, REG_SYS_FUNC_EN, 0xE3);\r\nrtl_write_byte(rtlpriv, REG_APSD_CTRL, 0x00);\r\nrtl_write_byte(rtlpriv, REG_SYS_FUNC_EN, 0xE2);\r\nrtl_write_byte(rtlpriv, REG_SYS_FUNC_EN, 0xE3);\r\nrtl_write_byte(rtlpriv, REG_TXPAUSE, 0x00);\r\n}\r\nstatic void _rtl92d_phy_set_rfsleep(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu32 u4btmp;\r\nu8 delay = 5;\r\nrtl_write_byte(rtlpriv, REG_TXPAUSE, 0xFF);\r\nrtl_set_rfreg(hw, RF90_PATH_A, 0x00, RFREG_OFFSET_MASK, 0x00);\r\nrtl_write_byte(rtlpriv, REG_APSD_CTRL, 0x40);\r\nu4btmp = rtl_get_rfreg(hw, RF90_PATH_A, 0, RFREG_OFFSET_MASK);\r\nwhile (u4btmp != 0 && delay > 0) {\r\nrtl_write_byte(rtlpriv, REG_APSD_CTRL, 0x0);\r\nrtl_set_rfreg(hw, RF90_PATH_A, 0x00, RFREG_OFFSET_MASK, 0x00);\r\nrtl_write_byte(rtlpriv, REG_APSD_CTRL, 0x40);\r\nu4btmp = rtl_get_rfreg(hw, RF90_PATH_A, 0, RFREG_OFFSET_MASK);\r\ndelay--;\r\n}\r\nif (delay == 0) {\r\nrtl_write_byte(rtlpriv, REG_APSD_CTRL, 0x00);\r\nrtl_write_byte(rtlpriv, REG_SYS_FUNC_EN, 0xE2);\r\nrtl_write_byte(rtlpriv, REG_SYS_FUNC_EN, 0xE3);\r\nrtl_write_byte(rtlpriv, REG_TXPAUSE, 0x00);\r\nRT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD,\r\n"Fail !!! Switch RF timeout\n");\r\nreturn;\r\n}\r\nrtl_write_byte(rtlpriv, REG_SYS_FUNC_EN, 0xE2);\r\nif (rtlpriv->rtlhal.macphymode == SINGLEMAC_SINGLEPHY)\r\nrtl_write_byte(rtlpriv, REG_SPS0_CTRL, 0x22);\r\n}\r\nbool rtl92d_phy_set_rf_power_state(struct ieee80211_hw *hw,\r\nenum rf_pwrstate rfpwr_state)\r\n{\r\nbool bresult = true;\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_pci_priv *pcipriv = rtl_pcipriv(hw);\r\nstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\r\nstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\r\nstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\r\nu8 i, queue_id;\r\nstruct rtl8192_tx_ring *ring = NULL;\r\nif (rfpwr_state == ppsc->rfpwr_state)\r\nreturn false;\r\nswitch (rfpwr_state) {\r\ncase ERFON:\r\nif ((ppsc->rfpwr_state == ERFOFF) &&\r\nRT_IN_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_HALT_NIC)) {\r\nbool rtstatus;\r\nu32 InitializeCount = 0;\r\ndo {\r\nInitializeCount++;\r\nRT_TRACE(rtlpriv, COMP_RF, DBG_DMESG,\r\n"IPS Set eRf nic enable\n");\r\nrtstatus = rtl_ps_enable_nic(hw);\r\n} while (!rtstatus && (InitializeCount < 10));\r\nRT_CLEAR_PS_LEVEL(ppsc,\r\nRT_RF_OFF_LEVL_HALT_NIC);\r\n} else {\r\nRT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG,\r\n"awake, sleeped:%d ms state_inap:%x\n",\r\njiffies_to_msecs(jiffies -\r\nppsc->last_sleep_jiffies),\r\nrtlpriv->psc.state_inap);\r\nppsc->last_awake_jiffies = jiffies;\r\n_rtl92d_phy_set_rfon(hw);\r\n}\r\nif (mac->link_state == MAC80211_LINKED)\r\nrtlpriv->cfg->ops->led_control(hw,\r\nLED_CTL_LINK);\r\nelse\r\nrtlpriv->cfg->ops->led_control(hw,\r\nLED_CTL_NO_LINK);\r\nbreak;\r\ncase ERFOFF:\r\nif (ppsc->reg_rfps_level & RT_RF_OFF_LEVL_HALT_NIC) {\r\nRT_TRACE(rtlpriv, COMP_RF, DBG_DMESG,\r\n"IPS Set eRf nic disable\n");\r\nrtl_ps_disable_nic(hw);\r\nRT_SET_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_HALT_NIC);\r\n} else {\r\nif (ppsc->rfoff_reason == RF_CHANGE_BY_IPS)\r\nrtlpriv->cfg->ops->led_control(hw,\r\nLED_CTL_NO_LINK);\r\nelse\r\nrtlpriv->cfg->ops->led_control(hw,\r\nLED_CTL_POWER_OFF);\r\n}\r\nbreak;\r\ncase ERFSLEEP:\r\nif (ppsc->rfpwr_state == ERFOFF)\r\nreturn false;\r\nfor (queue_id = 0, i = 0;\r\nqueue_id < RTL_PCI_MAX_TX_QUEUE_COUNT;) {\r\nring = &pcipriv->dev.tx_ring[queue_id];\r\nif (skb_queue_len(&ring->queue) == 0 ||\r\nqueue_id == BEACON_QUEUE) {\r\nqueue_id++;\r\ncontinue;\r\n} else if (rtlpci->pdev->current_state != PCI_D0) {\r\nRT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD,\r\n"eRf Off/Sleep: %d times TcbBusyQueue[%d] !=0 but lower power state!\n",\r\ni + 1, queue_id);\r\nbreak;\r\n} else {\r\nRT_TRACE(rtlpriv, COMP_ERR, DBG_WARNING,\r\n"eRf Off/Sleep: %d times TcbBusyQueue[%d] =%d before doze!\n",\r\ni + 1, queue_id,\r\nskb_queue_len(&ring->queue));\r\nudelay(10);\r\ni++;\r\n}\r\nif (i >= MAX_DOZE_WAITING_TIMES_9x) {\r\nRT_TRACE(rtlpriv, COMP_ERR, DBG_WARNING,\r\n"ERFOFF: %d times TcbBusyQueue[%d] = %d !\n",\r\nMAX_DOZE_WAITING_TIMES_9x, queue_id,\r\nskb_queue_len(&ring->queue));\r\nbreak;\r\n}\r\n}\r\nRT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG,\r\n"Set rfsleep awaked:%d ms\n",\r\njiffies_to_msecs(jiffies - ppsc->last_awake_jiffies));\r\nRT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG,\r\n"sleep awaked:%d ms state_inap:%x\n",\r\njiffies_to_msecs(jiffies -\r\nppsc->last_awake_jiffies),\r\nrtlpriv->psc.state_inap);\r\nppsc->last_sleep_jiffies = jiffies;\r\n_rtl92d_phy_set_rfsleep(hw);\r\nbreak;\r\ndefault:\r\npr_err("switch case %#x not processed\n",\r\nrfpwr_state);\r\nbresult = false;\r\nbreak;\r\n}\r\nif (bresult)\r\nppsc->rfpwr_state = rfpwr_state;\r\nreturn bresult;\r\n}\r\nvoid rtl92d_phy_config_macphymode(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nu8 offset = REG_MAC_PHY_CTRL_NORMAL;\r\nswitch (rtlhal->macphymode) {\r\ncase DUALMAC_DUALPHY:\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"MacPhyMode: DUALMAC_DUALPHY\n");\r\nrtl_write_byte(rtlpriv, offset, 0xF3);\r\nbreak;\r\ncase SINGLEMAC_SINGLEPHY:\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"MacPhyMode: SINGLEMAC_SINGLEPHY\n");\r\nrtl_write_byte(rtlpriv, offset, 0xF4);\r\nbreak;\r\ncase DUALMAC_SINGLEPHY:\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"MacPhyMode: DUALMAC_SINGLEPHY\n");\r\nrtl_write_byte(rtlpriv, offset, 0xF1);\r\nbreak;\r\n}\r\n}\r\nvoid rtl92d_phy_config_macphymode_info(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nstruct rtl_phy *rtlphy = &(rtlpriv->phy);\r\nswitch (rtlhal->macphymode) {\r\ncase DUALMAC_SINGLEPHY:\r\nrtlphy->rf_type = RF_2T2R;\r\nrtlhal->version |= RF_TYPE_2T2R;\r\nrtlhal->bandset = BAND_ON_BOTH;\r\nrtlhal->current_bandtype = BAND_ON_2_4G;\r\nbreak;\r\ncase SINGLEMAC_SINGLEPHY:\r\nrtlphy->rf_type = RF_2T2R;\r\nrtlhal->version |= RF_TYPE_2T2R;\r\nrtlhal->bandset = BAND_ON_BOTH;\r\nrtlhal->current_bandtype = BAND_ON_2_4G;\r\nbreak;\r\ncase DUALMAC_DUALPHY:\r\nrtlphy->rf_type = RF_1T1R;\r\nrtlhal->version &= RF_TYPE_1T1R;\r\nif (rtlhal->interfaceindex == 0) {\r\nrtlhal->bandset = BAND_ON_5G;\r\nrtlhal->current_bandtype = BAND_ON_5G;\r\n} else {\r\nrtlhal->bandset = BAND_ON_2_4G;\r\nrtlhal->current_bandtype = BAND_ON_2_4G;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nu8 rtl92d_get_chnlgroup_fromarray(u8 chnl)\r\n{\r\nu8 group;\r\nu8 channel_info[59] = {\r\n1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,\r\n36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56,\r\n58, 60, 62, 64, 100, 102, 104, 106, 108,\r\n110, 112, 114, 116, 118, 120, 122, 124,\r\n126, 128, 130, 132, 134, 136, 138, 140,\r\n149, 151, 153, 155, 157, 159, 161, 163,\r\n165\r\n};\r\nif (channel_info[chnl] <= 3)\r\ngroup = 0;\r\nelse if (channel_info[chnl] <= 9)\r\ngroup = 1;\r\nelse if (channel_info[chnl] <= 14)\r\ngroup = 2;\r\nelse if (channel_info[chnl] <= 44)\r\ngroup = 3;\r\nelse if (channel_info[chnl] <= 54)\r\ngroup = 4;\r\nelse if (channel_info[chnl] <= 64)\r\ngroup = 5;\r\nelse if (channel_info[chnl] <= 112)\r\ngroup = 6;\r\nelse if (channel_info[chnl] <= 126)\r\ngroup = 7;\r\nelse if (channel_info[chnl] <= 140)\r\ngroup = 8;\r\nelse if (channel_info[chnl] <= 153)\r\ngroup = 9;\r\nelse if (channel_info[chnl] <= 159)\r\ngroup = 10;\r\nelse\r\ngroup = 11;\r\nreturn group;\r\n}\r\nvoid rtl92d_phy_set_poweron(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nunsigned long flags;\r\nu8 value8;\r\nu16 i;\r\nu32 mac_reg = (rtlhal->interfaceindex == 0 ? REG_MAC0 : REG_MAC1);\r\nif (rtlhal->current_bandtype == BAND_ON_2_4G) {\r\nvalue8 = rtl_read_byte(rtlpriv, mac_reg);\r\nvalue8 |= BIT(1);\r\nrtl_write_byte(rtlpriv, mac_reg, value8);\r\n} else {\r\nvalue8 = rtl_read_byte(rtlpriv, mac_reg);\r\nvalue8 &= (~BIT(1));\r\nrtl_write_byte(rtlpriv, mac_reg, value8);\r\n}\r\nif (rtlhal->macphymode == SINGLEMAC_SINGLEPHY) {\r\nvalue8 = rtl_read_byte(rtlpriv, REG_MAC0);\r\nrtl_write_byte(rtlpriv, REG_MAC0, value8 | MAC0_ON);\r\n} else {\r\nspin_lock_irqsave(&globalmutex_power, flags);\r\nif (rtlhal->interfaceindex == 0) {\r\nvalue8 = rtl_read_byte(rtlpriv, REG_MAC0);\r\nrtl_write_byte(rtlpriv, REG_MAC0, value8 | MAC0_ON);\r\n} else {\r\nvalue8 = rtl_read_byte(rtlpriv, REG_MAC1);\r\nrtl_write_byte(rtlpriv, REG_MAC1, value8 | MAC1_ON);\r\n}\r\nvalue8 = rtl_read_byte(rtlpriv, REG_POWER_OFF_IN_PROCESS);\r\nspin_unlock_irqrestore(&globalmutex_power, flags);\r\nfor (i = 0; i < 200; i++) {\r\nif ((value8 & BIT(7)) == 0) {\r\nbreak;\r\n} else {\r\nudelay(500);\r\nspin_lock_irqsave(&globalmutex_power, flags);\r\nvalue8 = rtl_read_byte(rtlpriv,\r\nREG_POWER_OFF_IN_PROCESS);\r\nspin_unlock_irqrestore(&globalmutex_power,\r\nflags);\r\n}\r\n}\r\nif (i == 200)\r\nWARN_ONCE(true, "rtl8192de: Another mac power off over time\n");\r\n}\r\n}\r\nvoid rtl92d_phy_config_maccoexist_rfpage(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nswitch (rtlpriv->rtlhal.macphymode) {\r\ncase DUALMAC_DUALPHY:\r\nrtl_write_byte(rtlpriv, REG_DMC, 0x0);\r\nrtl_write_byte(rtlpriv, REG_RX_PKT_LIMIT, 0x08);\r\nrtl_write_word(rtlpriv, REG_TRXFF_BNDY + 2, 0x13ff);\r\nbreak;\r\ncase DUALMAC_SINGLEPHY:\r\nrtl_write_byte(rtlpriv, REG_DMC, 0xf8);\r\nrtl_write_byte(rtlpriv, REG_RX_PKT_LIMIT, 0x08);\r\nrtl_write_word(rtlpriv, REG_TRXFF_BNDY + 2, 0x13ff);\r\nbreak;\r\ncase SINGLEMAC_SINGLEPHY:\r\nrtl_write_byte(rtlpriv, REG_DMC, 0x0);\r\nrtl_write_byte(rtlpriv, REG_RX_PKT_LIMIT, 0x10);\r\nrtl_write_word(rtlpriv, (REG_TRXFF_BNDY + 2), 0x27FF);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nvoid rtl92d_update_bbrf_configuration(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nstruct rtl_phy *rtlphy = &(rtlpriv->phy);\r\nstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\r\nu8 rfpath, i;\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "==>\n");\r\nif (rtlhal->current_bandtype == BAND_ON_2_4G) {\r\nrtl_set_bbreg(hw, RFPGA0_XAB_RFPARAMETER, BIT(0), 0x0);\r\nrtl_set_bbreg(hw, RFPGA0_XAB_RFPARAMETER, BIT(15), 0x0);\r\nif (rtlhal->macphymode != DUALMAC_DUALPHY) {\r\nrtl_set_bbreg(hw, RFPGA0_XAB_RFPARAMETER, BIT(16), 0x0);\r\nrtl_set_bbreg(hw, RFPGA0_XAB_RFPARAMETER, BIT(31), 0x0);\r\n}\r\nrtl_set_bbreg(hw, ROFDM0_AGCRSSITABLE, BIT(6) | BIT(7), 0x0);\r\nrtl_set_bbreg(hw, ROFDM1_CFOTRACKING, BIT(14) | BIT(13), 0x0);\r\nrtl_set_bbreg(hw, 0xB30, 0x00F00000, 0xa);\r\nrtl_set_bbreg(hw, ROFDM0_XATxIQIMBALANCE, MASKDWORD,\r\n0x40000100);\r\nrtl_set_bbreg(hw, ROFDM0_XBTxIQIMBALANCE, MASKDWORD,\r\n0x40000100);\r\nif (rtlhal->macphymode == DUALMAC_DUALPHY) {\r\nrtl_set_bbreg(hw, RFPGA0_XAB_RFINTERFACESW,\r\nBIT(10) | BIT(6) | BIT(5),\r\n((rtlefuse->eeprom_c9 & BIT(3)) >> 3) |\r\n(rtlefuse->eeprom_c9 & BIT(1)) |\r\n((rtlefuse->eeprom_cc & BIT(1)) << 4));\r\nrtl_set_bbreg(hw, RFPGA0_XA_RFINTERFACEOE,\r\nBIT(10) | BIT(6) | BIT(5),\r\n((rtlefuse->eeprom_c9 & BIT(2)) >> 2) |\r\n((rtlefuse->eeprom_c9 & BIT(0)) << 1) |\r\n((rtlefuse->eeprom_cc & BIT(0)) << 5));\r\nrtl_set_bbreg(hw, RFPGA0_XAB_RFPARAMETER, BIT(15), 0);\r\n} else {\r\nrtl_set_bbreg(hw, RFPGA0_XAB_RFINTERFACESW,\r\nBIT(26) | BIT(22) | BIT(21) | BIT(10) |\r\nBIT(6) | BIT(5),\r\n((rtlefuse->eeprom_c9 & BIT(3)) >> 3) |\r\n(rtlefuse->eeprom_c9 & BIT(1)) |\r\n((rtlefuse->eeprom_cc & BIT(1)) << 4) |\r\n((rtlefuse->eeprom_c9 & BIT(7)) << 9) |\r\n((rtlefuse->eeprom_c9 & BIT(5)) << 12) |\r\n((rtlefuse->eeprom_cc & BIT(3)) << 18));\r\nrtl_set_bbreg(hw, RFPGA0_XA_RFINTERFACEOE,\r\nBIT(10) | BIT(6) | BIT(5),\r\n((rtlefuse->eeprom_c9 & BIT(2)) >> 2) |\r\n((rtlefuse->eeprom_c9 & BIT(0)) << 1) |\r\n((rtlefuse->eeprom_cc & BIT(0)) << 5));\r\nrtl_set_bbreg(hw, RFPGA0_XB_RFINTERFACEOE,\r\nBIT(10) | BIT(6) | BIT(5),\r\n((rtlefuse->eeprom_c9 & BIT(6)) >> 6) |\r\n((rtlefuse->eeprom_c9 & BIT(4)) >> 3) |\r\n((rtlefuse->eeprom_cc & BIT(2)) << 3));\r\nrtl_set_bbreg(hw, RFPGA0_XAB_RFPARAMETER,\r\nBIT(31) | BIT(15), 0);\r\n}\r\n} else {\r\nrtl_set_bbreg(hw, RFPGA0_XAB_RFPARAMETER, BIT(0), 0x1);\r\nrtl_set_bbreg(hw, RFPGA0_XAB_RFPARAMETER, BIT(15), 0x1);\r\nif (rtlhal->macphymode != DUALMAC_DUALPHY) {\r\nrtl_set_bbreg(hw, RFPGA0_XAB_RFPARAMETER, BIT(16), 0x1);\r\nrtl_set_bbreg(hw, RFPGA0_XAB_RFPARAMETER, BIT(31), 0x1);\r\n}\r\nrtl_set_bbreg(hw, ROFDM0_AGCRSSITABLE, BIT(6) | BIT(7), 0x1);\r\nrtl_set_bbreg(hw, ROFDM1_CFOTRACKING, BIT(14) | BIT(13), 0x1);\r\nrtl_set_bbreg(hw, 0xB30, 0x00F00000, 0x0);\r\nif (rtlefuse->internal_pa_5g[0])\r\nrtl_set_bbreg(hw, ROFDM0_XATxIQIMBALANCE, MASKDWORD,\r\n0x2d4000b5);\r\nelse\r\nrtl_set_bbreg(hw, ROFDM0_XATxIQIMBALANCE, MASKDWORD,\r\n0x20000080);\r\nif (rtlefuse->internal_pa_5g[1])\r\nrtl_set_bbreg(hw, ROFDM0_XBTxIQIMBALANCE, MASKDWORD,\r\n0x2d4000b5);\r\nelse\r\nrtl_set_bbreg(hw, ROFDM0_XBTxIQIMBALANCE, MASKDWORD,\r\n0x20000080);\r\nif (rtlhal->macphymode == DUALMAC_DUALPHY) {\r\nrtl_set_bbreg(hw, RFPGA0_XAB_RFINTERFACESW,\r\nBIT(10) | BIT(6) | BIT(5),\r\n(rtlefuse->eeprom_cc & BIT(5)));\r\nrtl_set_bbreg(hw, RFPGA0_XA_RFINTERFACEOE, BIT(10),\r\n((rtlefuse->eeprom_cc & BIT(4)) >> 4));\r\nrtl_set_bbreg(hw, RFPGA0_XAB_RFPARAMETER, BIT(15),\r\n(rtlefuse->eeprom_cc & BIT(4)) >> 4);\r\n} else {\r\nrtl_set_bbreg(hw, RFPGA0_XAB_RFINTERFACESW,\r\nBIT(26) | BIT(22) | BIT(21) | BIT(10) |\r\nBIT(6) | BIT(5),\r\n(rtlefuse->eeprom_cc & BIT(5)) |\r\n((rtlefuse->eeprom_cc & BIT(7)) << 14));\r\nrtl_set_bbreg(hw, RFPGA0_XA_RFINTERFACEOE, BIT(10),\r\n((rtlefuse->eeprom_cc & BIT(4)) >> 4));\r\nrtl_set_bbreg(hw, RFPGA0_XB_RFINTERFACEOE, BIT(10),\r\n((rtlefuse->eeprom_cc & BIT(6)) >> 6));\r\nrtl_set_bbreg(hw, RFPGA0_XAB_RFPARAMETER,\r\nBIT(31) | BIT(15),\r\n((rtlefuse->eeprom_cc & BIT(4)) >> 4) |\r\n((rtlefuse->eeprom_cc & BIT(6)) << 10));\r\n}\r\n}\r\nrtl_set_bbreg(hw, ROFDM0_XARXIQIMBALANCE, MASKDWORD, 0x40000100);\r\nrtl_set_bbreg(hw, ROFDM0_XBRXIQIMBALANCE, MASKDWORD, 0x40000100);\r\nrtl_set_bbreg(hw, ROFDM0_XCTxAFE, 0xF0000000, 0x00);\r\nrtl_set_bbreg(hw, ROFDM0_ECCATHRESHOLD, BIT(30) | BIT(28) |\r\nBIT(26) | BIT(24), 0x00);\r\nrtl_set_bbreg(hw, ROFDM0_XDTxAFE, 0xF0000000, 0x00);\r\nrtl_set_bbreg(hw, 0xca0, 0xF0000000, 0x00);\r\nrtl_set_bbreg(hw, ROFDM0_AGCRSSITABLE, 0x0000F000, 0x00);\r\nfor (rfpath = RF90_PATH_A; rfpath < rtlphy->num_total_rfpath;\r\nrfpath++) {\r\nif (rtlhal->current_bandtype == BAND_ON_2_4G) {\r\nrtl_set_rfreg(hw, rfpath, RF_CHNLBW, BIT(8) | BIT(16) |\r\nBIT(18), 0);\r\nrtl_set_rfreg(hw, (enum radio_path)rfpath, 0x0B,\r\n0x1c000, 0x07);\r\n} else {\r\nrtl_set_rfreg(hw, rfpath, RF_CHNLBW, BIT(8) |\r\nBIT(16) | BIT(18),\r\n(BIT(16) | BIT(8)) >> 8);\r\n}\r\n}\r\nif (rtlphy->rf_type == RF_1T1R) {\r\nrtl_set_bbreg(hw, ROFDM0_TRXPATHENABLE, MASKBYTE0, 0x11);\r\nrtl_set_bbreg(hw, ROFDM1_TRXPATHENABLE, BDWORD, 0x1);\r\nif (rtlhal->interfaceindex == 0) {\r\nrtl_set_bbreg(hw, RFPGA0_ADDALLOCKEN, BIT(12) |\r\nBIT(13), 0x3);\r\n} else {\r\nrtl92d_phy_enable_anotherphy(hw, false);\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"MAC1 use DBI to update 0x888\n");\r\nrtl92de_write_dword_dbi(hw, RFPGA0_ADDALLOCKEN,\r\nrtl92de_read_dword_dbi(hw,\r\nRFPGA0_ADDALLOCKEN,\r\nBIT(3)) | BIT(12) | BIT(13),\r\nBIT(3));\r\nrtl92d_phy_powerdown_anotherphy(hw, false);\r\n}\r\n} else {\r\nrtl_set_bbreg(hw, ROFDM0_TRXPATHENABLE, MASKBYTE0, 0x33);\r\nrtl_set_bbreg(hw, ROFDM1_TRXPATHENABLE, BDWORD, 0x3);\r\nrtl_set_bbreg(hw, RFPGA0_ADDALLOCKEN, BIT(12) | BIT(13), 0);\r\n}\r\nfor (rfpath = RF90_PATH_A; rfpath < rtlphy->num_total_rfpath;\r\nrfpath++) {\r\nrtlphy->rfreg_chnlval[rfpath] = rtl_get_rfreg(hw, rfpath,\r\nRF_CHNLBW, RFREG_OFFSET_MASK);\r\nrtlphy->reg_rf3c[rfpath] = rtl_get_rfreg(hw, rfpath, 0x3C,\r\nRFREG_OFFSET_MASK);\r\n}\r\nfor (i = 0; i < 2; i++)\r\nRT_TRACE(rtlpriv, COMP_RF, DBG_LOUD, "RF 0x18 = 0x%x\n",\r\nrtlphy->rfreg_chnlval[i]);\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "<==\n");\r\n}\r\nbool rtl92d_phy_check_poweroff(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nu8 u1btmp;\r\nunsigned long flags;\r\nif (rtlhal->macphymode == SINGLEMAC_SINGLEPHY) {\r\nu1btmp = rtl_read_byte(rtlpriv, REG_MAC0);\r\nrtl_write_byte(rtlpriv, REG_MAC0, u1btmp & (~MAC0_ON));\r\nreturn true;\r\n}\r\nspin_lock_irqsave(&globalmutex_power, flags);\r\nif (rtlhal->interfaceindex == 0) {\r\nu1btmp = rtl_read_byte(rtlpriv, REG_MAC0);\r\nrtl_write_byte(rtlpriv, REG_MAC0, u1btmp & (~MAC0_ON));\r\nu1btmp = rtl_read_byte(rtlpriv, REG_MAC1);\r\nu1btmp &= MAC1_ON;\r\n} else {\r\nu1btmp = rtl_read_byte(rtlpriv, REG_MAC1);\r\nrtl_write_byte(rtlpriv, REG_MAC1, u1btmp & (~MAC1_ON));\r\nu1btmp = rtl_read_byte(rtlpriv, REG_MAC0);\r\nu1btmp &= MAC0_ON;\r\n}\r\nif (u1btmp) {\r\nspin_unlock_irqrestore(&globalmutex_power, flags);\r\nreturn false;\r\n}\r\nu1btmp = rtl_read_byte(rtlpriv, REG_POWER_OFF_IN_PROCESS);\r\nu1btmp |= BIT(7);\r\nrtl_write_byte(rtlpriv, REG_POWER_OFF_IN_PROCESS, u1btmp);\r\nspin_unlock_irqrestore(&globalmutex_power, flags);\r\nreturn true;\r\n}
