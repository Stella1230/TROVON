static inline void\r\nsuperio_outb(int ioreg, int reg, int val)\r\n{\r\noutb(reg, ioreg);\r\noutb(val, ioreg + 1);\r\n}\r\nstatic inline int\r\nsuperio_inb(int ioreg, int reg)\r\n{\r\noutb(reg, ioreg);\r\nreturn inb(ioreg + 1);\r\n}\r\nstatic inline void\r\nsuperio_select(int ioreg, int ld)\r\n{\r\noutb(SIO_REG_LDSEL, ioreg);\r\noutb(ld, ioreg + 1);\r\n}\r\nstatic inline int\r\nsuperio_enter(int ioreg)\r\n{\r\nif (!request_muxed_region(ioreg, 2, DRVNAME))\r\nreturn -EBUSY;\r\noutb(0x87, ioreg);\r\noutb(0x87, ioreg);\r\nreturn 0;\r\n}\r\nstatic inline void\r\nsuperio_exit(int ioreg)\r\n{\r\noutb(0xaa, ioreg);\r\noutb(0x02, ioreg);\r\noutb(0x02, ioreg + 1);\r\nrelease_region(ioreg, 2);\r\n}\r\nstatic int is_word_sized(u16 reg)\r\n{\r\nreturn ((((reg & 0xff00) == 0x100\r\n|| (reg & 0xff00) == 0x200)\r\n&& ((reg & 0x00ff) == 0x50\r\n|| (reg & 0x00ff) == 0x53\r\n|| (reg & 0x00ff) == 0x55))\r\n|| (reg & 0xfff0) == 0x630\r\n|| reg == 0x640 || reg == 0x642\r\n|| ((reg & 0xfff0) == 0x650\r\n&& (reg & 0x000f) >= 0x06)\r\n|| reg == 0x73 || reg == 0x75 || reg == 0x77\r\n);\r\n}\r\nstatic inline unsigned int step_time_from_reg(u8 reg, u8 mode)\r\n{\r\nreturn mode ? 100 * reg : 400 * reg;\r\n}\r\nstatic inline u8 step_time_to_reg(unsigned int msec, u8 mode)\r\n{\r\nreturn clamp_val((mode ? (msec + 50) / 100 : (msec + 200) / 400),\r\n1, 255);\r\n}\r\nstatic unsigned int fan_from_reg8(u16 reg, unsigned int divreg)\r\n{\r\nif (reg == 0 || reg == 255)\r\nreturn 0;\r\nreturn 1350000U / (reg << divreg);\r\n}\r\nstatic unsigned int fan_from_reg13(u16 reg, unsigned int divreg)\r\n{\r\nif ((reg & 0xff1f) == 0xff1f)\r\nreturn 0;\r\nreg = (reg & 0x1f) | ((reg & 0xff00) >> 3);\r\nif (reg == 0)\r\nreturn 0;\r\nreturn 1350000U / reg;\r\n}\r\nstatic unsigned int fan_from_reg16(u16 reg, unsigned int divreg)\r\n{\r\nif (reg == 0 || reg == 0xffff)\r\nreturn 0;\r\nreturn 1350000U / (reg << divreg);\r\n}\r\nstatic inline unsigned int\r\ndiv_from_reg(u8 reg)\r\n{\r\nreturn 1 << reg;\r\n}\r\nstatic inline long in_from_reg(u8 reg, u8 nr, const u16 *scale_in)\r\n{\r\nreturn DIV_ROUND_CLOSEST(reg * scale_in[nr], 100);\r\n}\r\nstatic inline u8 in_to_reg(u32 val, u8 nr, const u16 *scale_in)\r\n{\r\nreturn clamp_val(DIV_ROUND_CLOSEST(val * 100, scale_in[nr]), 0, 255);\r\n}\r\nstatic inline void w83627ehf_set_bank(struct w83627ehf_data *data, u16 reg)\r\n{\r\nu8 bank = reg >> 8;\r\nif (data->bank != bank) {\r\noutb_p(W83627EHF_REG_BANK, data->addr + ADDR_REG_OFFSET);\r\noutb_p(bank, data->addr + DATA_REG_OFFSET);\r\ndata->bank = bank;\r\n}\r\n}\r\nstatic u16 w83627ehf_read_value(struct w83627ehf_data *data, u16 reg)\r\n{\r\nint res, word_sized = is_word_sized(reg);\r\nmutex_lock(&data->lock);\r\nw83627ehf_set_bank(data, reg);\r\noutb_p(reg & 0xff, data->addr + ADDR_REG_OFFSET);\r\nres = inb_p(data->addr + DATA_REG_OFFSET);\r\nif (word_sized) {\r\noutb_p((reg & 0xff) + 1,\r\ndata->addr + ADDR_REG_OFFSET);\r\nres = (res << 8) + inb_p(data->addr + DATA_REG_OFFSET);\r\n}\r\nmutex_unlock(&data->lock);\r\nreturn res;\r\n}\r\nstatic int w83627ehf_write_value(struct w83627ehf_data *data, u16 reg,\r\nu16 value)\r\n{\r\nint word_sized = is_word_sized(reg);\r\nmutex_lock(&data->lock);\r\nw83627ehf_set_bank(data, reg);\r\noutb_p(reg & 0xff, data->addr + ADDR_REG_OFFSET);\r\nif (word_sized) {\r\noutb_p(value >> 8, data->addr + DATA_REG_OFFSET);\r\noutb_p((reg & 0xff) + 1,\r\ndata->addr + ADDR_REG_OFFSET);\r\n}\r\noutb_p(value & 0xff, data->addr + DATA_REG_OFFSET);\r\nmutex_unlock(&data->lock);\r\nreturn 0;\r\n}\r\nstatic u16 w83627ehf_read_temp(struct w83627ehf_data *data, u16 reg)\r\n{\r\nu16 res;\r\nres = w83627ehf_read_value(data, reg);\r\nif (!is_word_sized(reg))\r\nres <<= 8;\r\nreturn res;\r\n}\r\nstatic int w83627ehf_write_temp(struct w83627ehf_data *data, u16 reg,\r\nu16 value)\r\n{\r\nif (!is_word_sized(reg))\r\nvalue >>= 8;\r\nreturn w83627ehf_write_value(data, reg, value);\r\n}\r\nstatic void nct6775_write_fan_div(struct w83627ehf_data *data, int nr)\r\n{\r\nu8 reg;\r\nswitch (nr) {\r\ncase 0:\r\nreg = (w83627ehf_read_value(data, NCT6775_REG_FANDIV1) & 0x70)\r\n| (data->fan_div[0] & 0x7);\r\nw83627ehf_write_value(data, NCT6775_REG_FANDIV1, reg);\r\nbreak;\r\ncase 1:\r\nreg = (w83627ehf_read_value(data, NCT6775_REG_FANDIV1) & 0x7)\r\n| ((data->fan_div[1] << 4) & 0x70);\r\nw83627ehf_write_value(data, NCT6775_REG_FANDIV1, reg);\r\nbreak;\r\ncase 2:\r\nreg = (w83627ehf_read_value(data, NCT6775_REG_FANDIV2) & 0x70)\r\n| (data->fan_div[2] & 0x7);\r\nw83627ehf_write_value(data, NCT6775_REG_FANDIV2, reg);\r\nbreak;\r\ncase 3:\r\nreg = (w83627ehf_read_value(data, NCT6775_REG_FANDIV2) & 0x7)\r\n| ((data->fan_div[3] << 4) & 0x70);\r\nw83627ehf_write_value(data, NCT6775_REG_FANDIV2, reg);\r\nbreak;\r\n}\r\n}\r\nstatic void w83627ehf_write_fan_div(struct w83627ehf_data *data, int nr)\r\n{\r\nu8 reg;\r\nswitch (nr) {\r\ncase 0:\r\nreg = (w83627ehf_read_value(data, W83627EHF_REG_FANDIV1) & 0xcf)\r\n| ((data->fan_div[0] & 0x03) << 4);\r\nreg |= (data->has_fan & (1 << 4)) ? 1 : 0;\r\nw83627ehf_write_value(data, W83627EHF_REG_FANDIV1, reg);\r\nreg = (w83627ehf_read_value(data, W83627EHF_REG_VBAT) & 0xdf)\r\n| ((data->fan_div[0] & 0x04) << 3);\r\nw83627ehf_write_value(data, W83627EHF_REG_VBAT, reg);\r\nbreak;\r\ncase 1:\r\nreg = (w83627ehf_read_value(data, W83627EHF_REG_FANDIV1) & 0x3f)\r\n| ((data->fan_div[1] & 0x03) << 6);\r\nreg |= (data->has_fan & (1 << 4)) ? 1 : 0;\r\nw83627ehf_write_value(data, W83627EHF_REG_FANDIV1, reg);\r\nreg = (w83627ehf_read_value(data, W83627EHF_REG_VBAT) & 0xbf)\r\n| ((data->fan_div[1] & 0x04) << 4);\r\nw83627ehf_write_value(data, W83627EHF_REG_VBAT, reg);\r\nbreak;\r\ncase 2:\r\nreg = (w83627ehf_read_value(data, W83627EHF_REG_FANDIV2) & 0x3f)\r\n| ((data->fan_div[2] & 0x03) << 6);\r\nw83627ehf_write_value(data, W83627EHF_REG_FANDIV2, reg);\r\nreg = (w83627ehf_read_value(data, W83627EHF_REG_VBAT) & 0x7f)\r\n| ((data->fan_div[2] & 0x04) << 5);\r\nw83627ehf_write_value(data, W83627EHF_REG_VBAT, reg);\r\nbreak;\r\ncase 3:\r\nreg = (w83627ehf_read_value(data, W83627EHF_REG_DIODE) & 0xfc)\r\n| (data->fan_div[3] & 0x03);\r\nw83627ehf_write_value(data, W83627EHF_REG_DIODE, reg);\r\nreg = (w83627ehf_read_value(data, W83627EHF_REG_SMI_OVT) & 0x7f)\r\n| ((data->fan_div[3] & 0x04) << 5);\r\nw83627ehf_write_value(data, W83627EHF_REG_SMI_OVT, reg);\r\nbreak;\r\ncase 4:\r\nreg = (w83627ehf_read_value(data, W83627EHF_REG_DIODE) & 0x73)\r\n| ((data->fan_div[4] & 0x03) << 2)\r\n| ((data->fan_div[4] & 0x04) << 5);\r\nw83627ehf_write_value(data, W83627EHF_REG_DIODE, reg);\r\nbreak;\r\n}\r\n}\r\nstatic void w83627ehf_write_fan_div_common(struct device *dev,\r\nstruct w83627ehf_data *data, int nr)\r\n{\r\nstruct w83627ehf_sio_data *sio_data = dev_get_platdata(dev);\r\nif (sio_data->kind == nct6776)\r\n;\r\nelse if (sio_data->kind == nct6775)\r\nnct6775_write_fan_div(data, nr);\r\nelse\r\nw83627ehf_write_fan_div(data, nr);\r\n}\r\nstatic void nct6775_update_fan_div(struct w83627ehf_data *data)\r\n{\r\nu8 i;\r\ni = w83627ehf_read_value(data, NCT6775_REG_FANDIV1);\r\ndata->fan_div[0] = i & 0x7;\r\ndata->fan_div[1] = (i & 0x70) >> 4;\r\ni = w83627ehf_read_value(data, NCT6775_REG_FANDIV2);\r\ndata->fan_div[2] = i & 0x7;\r\nif (data->has_fan & (1<<3))\r\ndata->fan_div[3] = (i & 0x70) >> 4;\r\n}\r\nstatic void w83627ehf_update_fan_div(struct w83627ehf_data *data)\r\n{\r\nint i;\r\ni = w83627ehf_read_value(data, W83627EHF_REG_FANDIV1);\r\ndata->fan_div[0] = (i >> 4) & 0x03;\r\ndata->fan_div[1] = (i >> 6) & 0x03;\r\ni = w83627ehf_read_value(data, W83627EHF_REG_FANDIV2);\r\ndata->fan_div[2] = (i >> 6) & 0x03;\r\ni = w83627ehf_read_value(data, W83627EHF_REG_VBAT);\r\ndata->fan_div[0] |= (i >> 3) & 0x04;\r\ndata->fan_div[1] |= (i >> 4) & 0x04;\r\ndata->fan_div[2] |= (i >> 5) & 0x04;\r\nif (data->has_fan & ((1 << 3) | (1 << 4))) {\r\ni = w83627ehf_read_value(data, W83627EHF_REG_DIODE);\r\ndata->fan_div[3] = i & 0x03;\r\ndata->fan_div[4] = ((i >> 2) & 0x03)\r\n| ((i >> 5) & 0x04);\r\n}\r\nif (data->has_fan & (1 << 3)) {\r\ni = w83627ehf_read_value(data, W83627EHF_REG_SMI_OVT);\r\ndata->fan_div[3] |= (i >> 5) & 0x04;\r\n}\r\n}\r\nstatic void w83627ehf_update_fan_div_common(struct device *dev,\r\nstruct w83627ehf_data *data)\r\n{\r\nstruct w83627ehf_sio_data *sio_data = dev_get_platdata(dev);\r\nif (sio_data->kind == nct6776)\r\n;\r\nelse if (sio_data->kind == nct6775)\r\nnct6775_update_fan_div(data);\r\nelse\r\nw83627ehf_update_fan_div(data);\r\n}\r\nstatic void nct6775_update_pwm(struct w83627ehf_data *data)\r\n{\r\nint i;\r\nint pwmcfg, fanmodecfg;\r\nfor (i = 0; i < data->pwm_num; i++) {\r\npwmcfg = w83627ehf_read_value(data,\r\nW83627EHF_REG_PWM_ENABLE[i]);\r\nfanmodecfg = w83627ehf_read_value(data,\r\nNCT6775_REG_FAN_MODE[i]);\r\ndata->pwm_mode[i] =\r\n((pwmcfg >> W83627EHF_PWM_MODE_SHIFT[i]) & 1) ? 0 : 1;\r\ndata->pwm_enable[i] = ((fanmodecfg >> 4) & 7) + 1;\r\ndata->tolerance[i] = fanmodecfg & 0x0f;\r\ndata->pwm[i] = w83627ehf_read_value(data, data->REG_PWM[i]);\r\n}\r\n}\r\nstatic void w83627ehf_update_pwm(struct w83627ehf_data *data)\r\n{\r\nint i;\r\nint pwmcfg = 0, tolerance = 0;\r\nfor (i = 0; i < data->pwm_num; i++) {\r\nif (!(data->has_fan & (1 << i)))\r\ncontinue;\r\nif (i != 1) {\r\npwmcfg = w83627ehf_read_value(data,\r\nW83627EHF_REG_PWM_ENABLE[i]);\r\ntolerance = w83627ehf_read_value(data,\r\nW83627EHF_REG_TOLERANCE[i]);\r\n}\r\ndata->pwm_mode[i] =\r\n((pwmcfg >> W83627EHF_PWM_MODE_SHIFT[i]) & 1) ? 0 : 1;\r\ndata->pwm_enable[i] = ((pwmcfg >> W83627EHF_PWM_ENABLE_SHIFT[i])\r\n& 3) + 1;\r\ndata->pwm[i] = w83627ehf_read_value(data, data->REG_PWM[i]);\r\ndata->tolerance[i] = (tolerance >> (i == 1 ? 4 : 0)) & 0x0f;\r\n}\r\n}\r\nstatic void w83627ehf_update_pwm_common(struct device *dev,\r\nstruct w83627ehf_data *data)\r\n{\r\nstruct w83627ehf_sio_data *sio_data = dev_get_platdata(dev);\r\nif (sio_data->kind == nct6775 || sio_data->kind == nct6776)\r\nnct6775_update_pwm(data);\r\nelse\r\nw83627ehf_update_pwm(data);\r\n}\r\nstatic struct w83627ehf_data *w83627ehf_update_device(struct device *dev)\r\n{\r\nstruct w83627ehf_data *data = dev_get_drvdata(dev);\r\nstruct w83627ehf_sio_data *sio_data = dev_get_platdata(dev);\r\nint i;\r\nmutex_lock(&data->update_lock);\r\nif (time_after(jiffies, data->last_updated + HZ + HZ/2)\r\n|| !data->valid) {\r\nw83627ehf_update_fan_div_common(dev, data);\r\nfor (i = 0; i < data->in_num; i++) {\r\nif ((i == 6) && data->in6_skip)\r\ncontinue;\r\ndata->in[i] = w83627ehf_read_value(data,\r\nW83627EHF_REG_IN(i));\r\ndata->in_min[i] = w83627ehf_read_value(data,\r\nW83627EHF_REG_IN_MIN(i));\r\ndata->in_max[i] = w83627ehf_read_value(data,\r\nW83627EHF_REG_IN_MAX(i));\r\n}\r\nfor (i = 0; i < 5; i++) {\r\nu16 reg;\r\nif (!(data->has_fan & (1 << i)))\r\ncontinue;\r\nreg = w83627ehf_read_value(data, data->REG_FAN[i]);\r\ndata->rpm[i] = data->fan_from_reg(reg,\r\ndata->fan_div[i]);\r\nif (data->has_fan_min & (1 << i))\r\ndata->fan_min[i] = w83627ehf_read_value(data,\r\ndata->REG_FAN_MIN[i]);\r\nif (data->has_fan_div\r\n&& (reg >= 0xff || (sio_data->kind == nct6775\r\n&& reg == 0x00))\r\n&& data->fan_div[i] < 0x07) {\r\ndev_dbg(dev,\r\n"Increasing fan%d clock divider from %u to %u\n",\r\ni + 1, div_from_reg(data->fan_div[i]),\r\ndiv_from_reg(data->fan_div[i] + 1));\r\ndata->fan_div[i]++;\r\nw83627ehf_write_fan_div_common(dev, data, i);\r\nif ((data->has_fan_min & (1 << i))\r\n&& data->fan_min[i] >= 2\r\n&& data->fan_min[i] != 255)\r\nw83627ehf_write_value(data,\r\ndata->REG_FAN_MIN[i],\r\n(data->fan_min[i] /= 2));\r\n}\r\n}\r\nw83627ehf_update_pwm_common(dev, data);\r\nfor (i = 0; i < data->pwm_num; i++) {\r\nif (!(data->has_fan & (1 << i)))\r\ncontinue;\r\ndata->fan_start_output[i] =\r\nw83627ehf_read_value(data,\r\ndata->REG_FAN_START_OUTPUT[i]);\r\ndata->fan_stop_output[i] =\r\nw83627ehf_read_value(data,\r\ndata->REG_FAN_STOP_OUTPUT[i]);\r\ndata->fan_stop_time[i] =\r\nw83627ehf_read_value(data,\r\ndata->REG_FAN_STOP_TIME[i]);\r\nif (data->REG_FAN_MAX_OUTPUT &&\r\ndata->REG_FAN_MAX_OUTPUT[i] != 0xff)\r\ndata->fan_max_output[i] =\r\nw83627ehf_read_value(data,\r\ndata->REG_FAN_MAX_OUTPUT[i]);\r\nif (data->REG_FAN_STEP_OUTPUT &&\r\ndata->REG_FAN_STEP_OUTPUT[i] != 0xff)\r\ndata->fan_step_output[i] =\r\nw83627ehf_read_value(data,\r\ndata->REG_FAN_STEP_OUTPUT[i]);\r\ndata->target_temp[i] =\r\nw83627ehf_read_value(data,\r\ndata->REG_TARGET[i]) &\r\n(data->pwm_mode[i] == 1 ? 0x7f : 0xff);\r\n}\r\nfor (i = 0; i < NUM_REG_TEMP; i++) {\r\nif (!(data->have_temp & (1 << i)))\r\ncontinue;\r\ndata->temp[i] = w83627ehf_read_temp(data,\r\ndata->reg_temp[i]);\r\nif (data->reg_temp_over[i])\r\ndata->temp_max[i]\r\n= w83627ehf_read_temp(data,\r\ndata->reg_temp_over[i]);\r\nif (data->reg_temp_hyst[i])\r\ndata->temp_max_hyst[i]\r\n= w83627ehf_read_temp(data,\r\ndata->reg_temp_hyst[i]);\r\nif (i > 2)\r\ncontinue;\r\nif (data->have_temp_offset & (1 << i))\r\ndata->temp_offset[i]\r\n= w83627ehf_read_value(data,\r\nW83627EHF_REG_TEMP_OFFSET[i]);\r\n}\r\ndata->alarms = w83627ehf_read_value(data,\r\nW83627EHF_REG_ALARM1) |\r\n(w83627ehf_read_value(data,\r\nW83627EHF_REG_ALARM2) << 8) |\r\n(w83627ehf_read_value(data,\r\nW83627EHF_REG_ALARM3) << 16);\r\ndata->caseopen = w83627ehf_read_value(data,\r\nW83627EHF_REG_CASEOPEN_DET);\r\ndata->last_updated = jiffies;\r\ndata->valid = 1;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn data;\r\n}\r\nstatic ssize_t show_alarm(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct w83627ehf_data *data = w83627ehf_update_device(dev);\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nreturn sprintf(buf, "%u\n", (data->alarms >> nr) & 0x01);\r\n}\r\nstatic ssize_t\r\nshow_fan(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct w83627ehf_data *data = w83627ehf_update_device(dev);\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nreturn sprintf(buf, "%d\n", data->rpm[nr]);\r\n}\r\nstatic ssize_t\r\nshow_fan_min(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct w83627ehf_data *data = w83627ehf_update_device(dev);\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nreturn sprintf(buf, "%d\n",\r\ndata->fan_from_reg_min(data->fan_min[nr],\r\ndata->fan_div[nr]));\r\n}\r\nstatic ssize_t\r\nshow_fan_div(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct w83627ehf_data *data = w83627ehf_update_device(dev);\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nreturn sprintf(buf, "%u\n", div_from_reg(data->fan_div[nr]));\r\n}\r\nstatic ssize_t\r\nstore_fan_min(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct w83627ehf_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nunsigned long val;\r\nint err;\r\nunsigned int reg;\r\nu8 new_div;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err < 0)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\nif (!data->has_fan_div) {\r\nif (!val) {\r\nval = 0xff1f;\r\n} else {\r\nif (val > 1350000U)\r\nval = 135000U;\r\nval = 1350000U / val;\r\nval = (val & 0x1f) | ((val << 3) & 0xff00);\r\n}\r\ndata->fan_min[nr] = val;\r\ngoto done;\r\n}\r\nif (!val) {\r\ndata->fan_min[nr] = 255;\r\nnew_div = data->fan_div[nr];\r\ndev_info(dev, "fan%u low limit and alarm disabled\n", nr + 1);\r\n} else if ((reg = 1350000U / val) >= 128 * 255) {\r\ndata->fan_min[nr] = 254;\r\nnew_div = 7;\r\ndev_warn(dev,\r\n"fan%u low limit %lu below minimum %u, set to minimum\n",\r\nnr + 1, val, data->fan_from_reg_min(254, 7));\r\n} else if (!reg) {\r\ndata->fan_min[nr] = 1;\r\nnew_div = 0;\r\ndev_warn(dev,\r\n"fan%u low limit %lu above maximum %u, set to maximum\n",\r\nnr + 1, val, data->fan_from_reg_min(1, 0));\r\n} else {\r\nnew_div = 0;\r\nwhile (reg > 192 && new_div < 7) {\r\nreg >>= 1;\r\nnew_div++;\r\n}\r\ndata->fan_min[nr] = reg;\r\n}\r\nif (new_div != data->fan_div[nr]) {\r\ndev_dbg(dev, "fan%u clock divider changed from %u to %u\n",\r\nnr + 1, div_from_reg(data->fan_div[nr]),\r\ndiv_from_reg(new_div));\r\ndata->fan_div[nr] = new_div;\r\nw83627ehf_write_fan_div_common(dev, data, nr);\r\ndata->last_updated = jiffies;\r\n}\r\ndone:\r\nw83627ehf_write_value(data, data->REG_FAN_MIN[nr],\r\ndata->fan_min[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_temp_label(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct w83627ehf_data *data = w83627ehf_update_device(dev);\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nreturn sprintf(buf, "%s\n", data->temp_label[data->temp_src[nr]]);\r\n}\r\nstatic ssize_t\r\nshow_temp_offset(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct w83627ehf_data *data = w83627ehf_update_device(dev);\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nreturn sprintf(buf, "%d\n",\r\ndata->temp_offset[sensor_attr->index] * 1000);\r\n}\r\nstatic ssize_t\r\nstore_temp_offset(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct w83627ehf_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err < 0)\r\nreturn err;\r\nval = clamp_val(DIV_ROUND_CLOSEST(val, 1000), -128, 127);\r\nmutex_lock(&data->update_lock);\r\ndata->temp_offset[nr] = val;\r\nw83627ehf_write_value(data, W83627EHF_REG_TEMP_OFFSET[nr], val);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_temp_type(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct w83627ehf_data *data = w83627ehf_update_device(dev);\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nreturn sprintf(buf, "%d\n", (int)data->temp_type[nr]);\r\n}\r\nstatic ssize_t\r\nstore_pwm_mode(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct w83627ehf_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nstruct w83627ehf_sio_data *sio_data = dev_get_platdata(dev);\r\nint nr = sensor_attr->index;\r\nunsigned long val;\r\nint err;\r\nu16 reg;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err < 0)\r\nreturn err;\r\nif (val > 1)\r\nreturn -EINVAL;\r\nif (sio_data->kind == nct6776 && nr && val != 1)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\nreg = w83627ehf_read_value(data, W83627EHF_REG_PWM_ENABLE[nr]);\r\ndata->pwm_mode[nr] = val;\r\nreg &= ~(1 << W83627EHF_PWM_MODE_SHIFT[nr]);\r\nif (!val)\r\nreg |= 1 << W83627EHF_PWM_MODE_SHIFT[nr];\r\nw83627ehf_write_value(data, W83627EHF_REG_PWM_ENABLE[nr], reg);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nstore_pwm(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct w83627ehf_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err < 0)\r\nreturn err;\r\nval = clamp_val(val, 0, 255);\r\nmutex_lock(&data->update_lock);\r\ndata->pwm[nr] = val;\r\nw83627ehf_write_value(data, data->REG_PWM[nr], val);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nstore_pwm_enable(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct w83627ehf_data *data = dev_get_drvdata(dev);\r\nstruct w83627ehf_sio_data *sio_data = dev_get_platdata(dev);\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nunsigned long val;\r\nint err;\r\nu16 reg;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err < 0)\r\nreturn err;\r\nif (!val || (val > 4 && val != data->pwm_enable_orig[nr]))\r\nreturn -EINVAL;\r\nif (sio_data->kind == nct6776 && val == 4)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\ndata->pwm_enable[nr] = val;\r\nif (sio_data->kind == nct6775 || sio_data->kind == nct6776) {\r\nreg = w83627ehf_read_value(data,\r\nNCT6775_REG_FAN_MODE[nr]);\r\nreg &= 0x0f;\r\nreg |= (val - 1) << 4;\r\nw83627ehf_write_value(data,\r\nNCT6775_REG_FAN_MODE[nr], reg);\r\n} else {\r\nreg = w83627ehf_read_value(data, W83627EHF_REG_PWM_ENABLE[nr]);\r\nreg &= ~(0x03 << W83627EHF_PWM_ENABLE_SHIFT[nr]);\r\nreg |= (val - 1) << W83627EHF_PWM_ENABLE_SHIFT[nr];\r\nw83627ehf_write_value(data, W83627EHF_REG_PWM_ENABLE[nr], reg);\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nstore_target_temp(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct w83627ehf_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err < 0)\r\nreturn err;\r\nval = clamp_val(DIV_ROUND_CLOSEST(val, 1000), 0, 127);\r\nmutex_lock(&data->update_lock);\r\ndata->target_temp[nr] = val;\r\nw83627ehf_write_value(data, data->REG_TARGET[nr], val);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nstore_tolerance(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct w83627ehf_data *data = dev_get_drvdata(dev);\r\nstruct w83627ehf_sio_data *sio_data = dev_get_platdata(dev);\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nu16 reg;\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err < 0)\r\nreturn err;\r\nval = clamp_val(DIV_ROUND_CLOSEST(val, 1000), 0, 15);\r\nmutex_lock(&data->update_lock);\r\nif (sio_data->kind == nct6775 || sio_data->kind == nct6776) {\r\nif (sio_data->kind == nct6776 && val > 7)\r\nval = 7;\r\nreg = w83627ehf_read_value(data, NCT6775_REG_FAN_MODE[nr]);\r\nreg = (reg & 0xf0) | val;\r\nw83627ehf_write_value(data, NCT6775_REG_FAN_MODE[nr], reg);\r\n} else {\r\nreg = w83627ehf_read_value(data, W83627EHF_REG_TOLERANCE[nr]);\r\nif (nr == 1)\r\nreg = (reg & 0x0f) | (val << 4);\r\nelse\r\nreg = (reg & 0xf0) | val;\r\nw83627ehf_write_value(data, W83627EHF_REG_TOLERANCE[nr], reg);\r\n}\r\ndata->tolerance[nr] = val;\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t name_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct w83627ehf_data *data = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%s\n", data->name);\r\n}\r\nstatic ssize_t\r\ncpu0_vid_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct w83627ehf_data *data = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", vid_from_reg(data->vid, data->vrm));\r\n}\r\nstatic ssize_t\r\nshow_caseopen(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct w83627ehf_data *data = w83627ehf_update_device(dev);\r\nreturn sprintf(buf, "%d\n",\r\n!!(data->caseopen & to_sensor_dev_attr_2(attr)->index));\r\n}\r\nstatic ssize_t\r\nclear_caseopen(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct w83627ehf_data *data = dev_get_drvdata(dev);\r\nunsigned long val;\r\nu16 reg, mask;\r\nif (kstrtoul(buf, 10, &val) || val != 0)\r\nreturn -EINVAL;\r\nmask = to_sensor_dev_attr_2(attr)->nr;\r\nmutex_lock(&data->update_lock);\r\nreg = w83627ehf_read_value(data, W83627EHF_REG_CASEOPEN_CLR);\r\nw83627ehf_write_value(data, W83627EHF_REG_CASEOPEN_CLR, reg | mask);\r\nw83627ehf_write_value(data, W83627EHF_REG_CASEOPEN_CLR, reg & ~mask);\r\ndata->valid = 0;\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic void w83627ehf_device_remove_files(struct device *dev)\r\n{\r\nint i;\r\nstruct w83627ehf_data *data = dev_get_drvdata(dev);\r\nfor (i = 0; i < ARRAY_SIZE(sda_sf3_arrays); i++)\r\ndevice_remove_file(dev, &sda_sf3_arrays[i].dev_attr);\r\nfor (i = 0; i < ARRAY_SIZE(sda_sf3_max_step_arrays); i++) {\r\nstruct sensor_device_attribute *attr =\r\n&sda_sf3_max_step_arrays[i];\r\nif (data->REG_FAN_STEP_OUTPUT &&\r\ndata->REG_FAN_STEP_OUTPUT[attr->index] != 0xff)\r\ndevice_remove_file(dev, &attr->dev_attr);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(sda_sf3_arrays_fan3); i++)\r\ndevice_remove_file(dev, &sda_sf3_arrays_fan3[i].dev_attr);\r\nfor (i = 0; i < ARRAY_SIZE(sda_sf3_arrays_fan4); i++)\r\ndevice_remove_file(dev, &sda_sf3_arrays_fan4[i].dev_attr);\r\nfor (i = 0; i < data->in_num; i++) {\r\nif ((i == 6) && data->in6_skip)\r\ncontinue;\r\ndevice_remove_file(dev, &sda_in_input[i].dev_attr);\r\ndevice_remove_file(dev, &sda_in_alarm[i].dev_attr);\r\ndevice_remove_file(dev, &sda_in_min[i].dev_attr);\r\ndevice_remove_file(dev, &sda_in_max[i].dev_attr);\r\n}\r\nfor (i = 0; i < 5; i++) {\r\ndevice_remove_file(dev, &sda_fan_input[i].dev_attr);\r\ndevice_remove_file(dev, &sda_fan_alarm[i].dev_attr);\r\ndevice_remove_file(dev, &sda_fan_div[i].dev_attr);\r\ndevice_remove_file(dev, &sda_fan_min[i].dev_attr);\r\n}\r\nfor (i = 0; i < data->pwm_num; i++) {\r\ndevice_remove_file(dev, &sda_pwm[i].dev_attr);\r\ndevice_remove_file(dev, &sda_pwm_mode[i].dev_attr);\r\ndevice_remove_file(dev, &sda_pwm_enable[i].dev_attr);\r\ndevice_remove_file(dev, &sda_target_temp[i].dev_attr);\r\ndevice_remove_file(dev, &sda_tolerance[i].dev_attr);\r\n}\r\nfor (i = 0; i < NUM_REG_TEMP; i++) {\r\nif (!(data->have_temp & (1 << i)))\r\ncontinue;\r\ndevice_remove_file(dev, &sda_temp_input[i].dev_attr);\r\ndevice_remove_file(dev, &sda_temp_label[i].dev_attr);\r\nif (i == 2 && data->temp3_val_only)\r\ncontinue;\r\ndevice_remove_file(dev, &sda_temp_max[i].dev_attr);\r\ndevice_remove_file(dev, &sda_temp_max_hyst[i].dev_attr);\r\nif (i > 2)\r\ncontinue;\r\ndevice_remove_file(dev, &sda_temp_alarm[i].dev_attr);\r\ndevice_remove_file(dev, &sda_temp_type[i].dev_attr);\r\ndevice_remove_file(dev, &sda_temp_offset[i].dev_attr);\r\n}\r\ndevice_remove_file(dev, &sda_caseopen[0].dev_attr);\r\ndevice_remove_file(dev, &sda_caseopen[1].dev_attr);\r\ndevice_remove_file(dev, &dev_attr_name);\r\ndevice_remove_file(dev, &dev_attr_cpu0_vid);\r\n}\r\nstatic inline void w83627ehf_init_device(struct w83627ehf_data *data,\r\nenum kinds kind)\r\n{\r\nint i;\r\nu8 tmp, diode;\r\ntmp = w83627ehf_read_value(data, W83627EHF_REG_CONFIG);\r\nif (!(tmp & 0x01))\r\nw83627ehf_write_value(data, W83627EHF_REG_CONFIG,\r\ntmp | 0x01);\r\nfor (i = 0; i < NUM_REG_TEMP; i++) {\r\nif (!(data->have_temp & (1 << i)))\r\ncontinue;\r\nif (!data->reg_temp_config[i])\r\ncontinue;\r\ntmp = w83627ehf_read_value(data,\r\ndata->reg_temp_config[i]);\r\nif (tmp & 0x01)\r\nw83627ehf_write_value(data,\r\ndata->reg_temp_config[i],\r\ntmp & 0xfe);\r\n}\r\ntmp = w83627ehf_read_value(data, W83627EHF_REG_VBAT);\r\nif (!(tmp & 0x01))\r\nw83627ehf_write_value(data, W83627EHF_REG_VBAT, tmp | 0x01);\r\nswitch (kind) {\r\ncase w83627ehf:\r\ndiode = w83627ehf_read_value(data, W83627EHF_REG_DIODE);\r\nbreak;\r\ncase w83627uhg:\r\ndiode = 0x00;\r\nbreak;\r\ndefault:\r\ndiode = 0x70;\r\n}\r\nfor (i = 0; i < 3; i++) {\r\nconst char *label = NULL;\r\nif (data->temp_label)\r\nlabel = data->temp_label[data->temp_src[i]];\r\nif (label && strncmp(label, "PECI", 4) == 0)\r\ndata->temp_type[i] = 6;\r\nelse if (label && strncmp(label, "AMD", 3) == 0)\r\ndata->temp_type[i] = 5;\r\nelse if ((tmp & (0x02 << i)))\r\ndata->temp_type[i] = (diode & (0x10 << i)) ? 1 : 3;\r\nelse\r\ndata->temp_type[i] = 4;\r\n}\r\n}\r\nstatic void w82627ehf_swap_tempreg(struct w83627ehf_data *data,\r\nint r1, int r2)\r\n{\r\nswap(data->temp_src[r1], data->temp_src[r2]);\r\nswap(data->reg_temp[r1], data->reg_temp[r2]);\r\nswap(data->reg_temp_over[r1], data->reg_temp_over[r2]);\r\nswap(data->reg_temp_hyst[r1], data->reg_temp_hyst[r2]);\r\nswap(data->reg_temp_config[r1], data->reg_temp_config[r2]);\r\n}\r\nstatic void\r\nw83627ehf_set_temp_reg_ehf(struct w83627ehf_data *data, int n_temp)\r\n{\r\nint i;\r\nfor (i = 0; i < n_temp; i++) {\r\ndata->reg_temp[i] = W83627EHF_REG_TEMP[i];\r\ndata->reg_temp_over[i] = W83627EHF_REG_TEMP_OVER[i];\r\ndata->reg_temp_hyst[i] = W83627EHF_REG_TEMP_HYST[i];\r\ndata->reg_temp_config[i] = W83627EHF_REG_TEMP_CONFIG[i];\r\n}\r\n}\r\nstatic void\r\nw83627ehf_check_fan_inputs(const struct w83627ehf_sio_data *sio_data,\r\nstruct w83627ehf_data *data)\r\n{\r\nint fan3pin, fan4pin, fan4min, fan5pin, regval;\r\nif (sio_data->kind == w83627uhg) {\r\ndata->has_fan = 0x03;\r\ndata->has_fan_min = 0x03;\r\nreturn;\r\n}\r\nif (sio_data->kind == nct6775) {\r\nfan3pin = 1;\r\nfan4pin = !(superio_inb(sio_data->sioreg, 0x2A) & 0x80);\r\nfan4min = 0;\r\nfan5pin = 0;\r\n} else if (sio_data->kind == nct6776) {\r\nbool gpok = superio_inb(sio_data->sioreg, 0x27) & 0x80;\r\nsuperio_select(sio_data->sioreg, W83627EHF_LD_HWM);\r\nregval = superio_inb(sio_data->sioreg, SIO_REG_ENABLE);\r\nif (regval & 0x80)\r\nfan3pin = gpok;\r\nelse\r\nfan3pin = !(superio_inb(sio_data->sioreg, 0x24) & 0x40);\r\nif (regval & 0x40)\r\nfan4pin = gpok;\r\nelse\r\nfan4pin = !!(superio_inb(sio_data->sioreg, 0x1C) & 0x01);\r\nif (regval & 0x20)\r\nfan5pin = gpok;\r\nelse\r\nfan5pin = !!(superio_inb(sio_data->sioreg, 0x1C) & 0x02);\r\nfan4min = fan4pin;\r\n} else if (sio_data->kind == w83667hg || sio_data->kind == w83667hg_b) {\r\nfan3pin = 1;\r\nfan4pin = superio_inb(sio_data->sioreg, 0x27) & 0x40;\r\nfan5pin = superio_inb(sio_data->sioreg, 0x27) & 0x20;\r\nfan4min = fan4pin;\r\n} else {\r\nfan3pin = 1;\r\nfan4pin = !(superio_inb(sio_data->sioreg, 0x29) & 0x06);\r\nfan5pin = !(superio_inb(sio_data->sioreg, 0x24) & 0x02);\r\nfan4min = fan4pin;\r\n}\r\ndata->has_fan = data->has_fan_min = 0x03;\r\ndata->has_fan |= (fan3pin << 2);\r\ndata->has_fan_min |= (fan3pin << 2);\r\nif (sio_data->kind == nct6775 || sio_data->kind == nct6776) {\r\ndata->has_fan |= (fan4pin << 3) | (fan5pin << 4);\r\ndata->has_fan_min |= (fan4min << 3) | (fan5pin << 4);\r\n} else {\r\nregval = w83627ehf_read_value(data, W83627EHF_REG_FANDIV1);\r\nif ((regval & (1 << 2)) && fan4pin) {\r\ndata->has_fan |= (1 << 3);\r\ndata->has_fan_min |= (1 << 3);\r\n}\r\nif (!(regval & (1 << 1)) && fan5pin) {\r\ndata->has_fan |= (1 << 4);\r\ndata->has_fan_min |= (1 << 4);\r\n}\r\n}\r\n}\r\nstatic int w83627ehf_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct w83627ehf_sio_data *sio_data = dev_get_platdata(dev);\r\nstruct w83627ehf_data *data;\r\nstruct resource *res;\r\nu8 en_vrm10;\r\nint i, err = 0;\r\nres = platform_get_resource(pdev, IORESOURCE_IO, 0);\r\nif (!request_region(res->start, IOREGION_LENGTH, DRVNAME)) {\r\nerr = -EBUSY;\r\ndev_err(dev, "Failed to request region 0x%lx-0x%lx\n",\r\n(unsigned long)res->start,\r\n(unsigned long)res->start + IOREGION_LENGTH - 1);\r\ngoto exit;\r\n}\r\ndata = devm_kzalloc(&pdev->dev, sizeof(struct w83627ehf_data),\r\nGFP_KERNEL);\r\nif (!data) {\r\nerr = -ENOMEM;\r\ngoto exit_release;\r\n}\r\ndata->addr = res->start;\r\nmutex_init(&data->lock);\r\nmutex_init(&data->update_lock);\r\ndata->name = w83627ehf_device_names[sio_data->kind];\r\ndata->bank = 0xff;\r\nplatform_set_drvdata(pdev, data);\r\ndata->in_num = (sio_data->kind == w83627ehf) ? 10 : 9;\r\nswitch (sio_data->kind) {\r\ndefault:\r\ndata->pwm_num = 4;\r\nbreak;\r\ncase w83667hg:\r\ncase w83667hg_b:\r\ncase nct6775:\r\ncase nct6776:\r\ndata->pwm_num = 3;\r\nbreak;\r\ncase w83627uhg:\r\ndata->pwm_num = 2;\r\nbreak;\r\n}\r\ndata->have_temp = 0x07;\r\nif (sio_data->kind == nct6775 || sio_data->kind == nct6776) {\r\nint mask = 0;\r\nfor (i = 0; i < NUM_REG_TEMP; i++) {\r\nu8 src;\r\ndata->reg_temp[i] = NCT6775_REG_TEMP[i];\r\ndata->reg_temp_over[i] = NCT6775_REG_TEMP_OVER[i];\r\ndata->reg_temp_hyst[i] = NCT6775_REG_TEMP_HYST[i];\r\ndata->reg_temp_config[i] = NCT6775_REG_TEMP_CONFIG[i];\r\nsrc = w83627ehf_read_value(data,\r\nNCT6775_REG_TEMP_SOURCE[i]);\r\nsrc &= 0x1f;\r\nif (src && !(mask & (1 << src))) {\r\ndata->have_temp |= 1 << i;\r\nmask |= 1 << src;\r\n}\r\ndata->temp_src[i] = src;\r\nif (i > 0 && data->temp_src[0] != 1\r\n&& data->temp_src[i] == 1)\r\nw82627ehf_swap_tempreg(data, 0, i);\r\nif (i > 1 && data->temp_src[1] != 2\r\n&& data->temp_src[i] == 2)\r\nw82627ehf_swap_tempreg(data, 1, i);\r\nif (i > 2 && data->temp_src[2] != 3\r\n&& data->temp_src[i] == 3)\r\nw82627ehf_swap_tempreg(data, 2, i);\r\n}\r\nif (sio_data->kind == nct6776) {\r\nif (data->temp_src[2] == 3) {\r\nu8 reg;\r\nif (data->reg_temp_config[2])\r\nreg = w83627ehf_read_value(data,\r\ndata->reg_temp_config[2]);\r\nelse\r\nreg = 0;\r\nif (reg & 0x01)\r\ndata->have_temp &= ~(1 << 2);\r\nelse\r\ndata->in6_skip = 1;\r\n}\r\ndata->temp_label = nct6776_temp_label;\r\n} else {\r\ndata->temp_label = nct6775_temp_label;\r\n}\r\ndata->have_temp_offset = data->have_temp & 0x07;\r\nfor (i = 0; i < 3; i++) {\r\nif (data->temp_src[i] > 3)\r\ndata->have_temp_offset &= ~(1 << i);\r\n}\r\n} else if (sio_data->kind == w83667hg_b) {\r\nu8 reg;\r\nw83627ehf_set_temp_reg_ehf(data, 4);\r\nreg = w83627ehf_read_value(data, 0x4a);\r\ndata->temp_src[0] = reg >> 5;\r\nreg = w83627ehf_read_value(data, 0x49);\r\ndata->temp_src[1] = reg & 0x07;\r\ndata->temp_src[2] = (reg >> 4) & 0x07;\r\nreg = w83627ehf_read_value(data, 0x7d);\r\nreg &= 0x07;\r\nif (reg != data->temp_src[0] && reg != data->temp_src[1]\r\n&& reg != data->temp_src[2]) {\r\ndata->temp_src[3] = reg;\r\ndata->have_temp |= 1 << 3;\r\n}\r\nreg = w83627ehf_read_value(data, W83627EHF_REG_TEMP_CONFIG[2]);\r\nif (data->temp_src[2] == 2 && (reg & 0x01))\r\ndata->have_temp &= ~(1 << 2);\r\nif ((data->temp_src[2] == 2 && (data->have_temp & (1 << 2)))\r\n|| (data->temp_src[3] == 2 && (data->have_temp & (1 << 3))))\r\ndata->in6_skip = 1;\r\ndata->temp_label = w83667hg_b_temp_label;\r\ndata->have_temp_offset = data->have_temp & 0x07;\r\nfor (i = 0; i < 3; i++) {\r\nif (data->temp_src[i] > 2)\r\ndata->have_temp_offset &= ~(1 << i);\r\n}\r\n} else if (sio_data->kind == w83627uhg) {\r\nu8 reg;\r\nw83627ehf_set_temp_reg_ehf(data, 3);\r\ndata->temp_src[0] = 0;\r\nreg = w83627ehf_read_value(data, 0x49) & 0x07;\r\nif (reg == 0)\r\ndata->temp_src[1] = 1;\r\nelse if (reg >= 2 && reg <= 5)\r\ndata->temp_src[1] = reg + 2;\r\nelse\r\ndata->have_temp &= ~(1 << 1);\r\nreg = w83627ehf_read_value(data, 0x4a);\r\ndata->temp_src[2] = reg >> 5;\r\nif (data->temp_src[2] == 2 || data->temp_src[2] == 3 ||\r\ndata->temp_src[2] == data->temp_src[0] ||\r\n((data->have_temp & (1 << 1)) &&\r\ndata->temp_src[2] == data->temp_src[1]))\r\ndata->have_temp &= ~(1 << 2);\r\nelse\r\ndata->temp3_val_only = 1;\r\ndata->in6_skip = 1;\r\ndata->temp_label = w83667hg_b_temp_label;\r\ndata->have_temp_offset = data->have_temp & 0x03;\r\nfor (i = 0; i < 3; i++) {\r\nif (data->temp_src[i] > 1)\r\ndata->have_temp_offset &= ~(1 << i);\r\n}\r\n} else {\r\nw83627ehf_set_temp_reg_ehf(data, 3);\r\nif (sio_data->kind == w83667hg) {\r\nu8 reg;\r\nreg = w83627ehf_read_value(data,\r\nW83627EHF_REG_TEMP_CONFIG[2]);\r\nif (reg & 0x01)\r\ndata->have_temp &= ~(1 << 2);\r\nelse\r\ndata->in6_skip = 1;\r\n}\r\ndata->have_temp_offset = data->have_temp & 0x07;\r\n}\r\nif (sio_data->kind == nct6775) {\r\ndata->has_fan_div = true;\r\ndata->fan_from_reg = fan_from_reg16;\r\ndata->fan_from_reg_min = fan_from_reg8;\r\ndata->REG_PWM = NCT6775_REG_PWM;\r\ndata->REG_TARGET = NCT6775_REG_TARGET;\r\ndata->REG_FAN = NCT6775_REG_FAN;\r\ndata->REG_FAN_MIN = W83627EHF_REG_FAN_MIN;\r\ndata->REG_FAN_START_OUTPUT = NCT6775_REG_FAN_START_OUTPUT;\r\ndata->REG_FAN_STOP_OUTPUT = NCT6775_REG_FAN_STOP_OUTPUT;\r\ndata->REG_FAN_STOP_TIME = NCT6775_REG_FAN_STOP_TIME;\r\ndata->REG_FAN_MAX_OUTPUT = NCT6775_REG_FAN_MAX_OUTPUT;\r\ndata->REG_FAN_STEP_OUTPUT = NCT6775_REG_FAN_STEP_OUTPUT;\r\n} else if (sio_data->kind == nct6776) {\r\ndata->has_fan_div = false;\r\ndata->fan_from_reg = fan_from_reg13;\r\ndata->fan_from_reg_min = fan_from_reg13;\r\ndata->REG_PWM = NCT6775_REG_PWM;\r\ndata->REG_TARGET = NCT6775_REG_TARGET;\r\ndata->REG_FAN = NCT6775_REG_FAN;\r\ndata->REG_FAN_MIN = NCT6776_REG_FAN_MIN;\r\ndata->REG_FAN_START_OUTPUT = NCT6775_REG_FAN_START_OUTPUT;\r\ndata->REG_FAN_STOP_OUTPUT = NCT6775_REG_FAN_STOP_OUTPUT;\r\ndata->REG_FAN_STOP_TIME = NCT6775_REG_FAN_STOP_TIME;\r\n} else if (sio_data->kind == w83667hg_b) {\r\ndata->has_fan_div = true;\r\ndata->fan_from_reg = fan_from_reg8;\r\ndata->fan_from_reg_min = fan_from_reg8;\r\ndata->REG_PWM = W83627EHF_REG_PWM;\r\ndata->REG_TARGET = W83627EHF_REG_TARGET;\r\ndata->REG_FAN = W83627EHF_REG_FAN;\r\ndata->REG_FAN_MIN = W83627EHF_REG_FAN_MIN;\r\ndata->REG_FAN_START_OUTPUT = W83627EHF_REG_FAN_START_OUTPUT;\r\ndata->REG_FAN_STOP_OUTPUT = W83627EHF_REG_FAN_STOP_OUTPUT;\r\ndata->REG_FAN_STOP_TIME = W83627EHF_REG_FAN_STOP_TIME;\r\ndata->REG_FAN_MAX_OUTPUT =\r\nW83627EHF_REG_FAN_MAX_OUTPUT_W83667_B;\r\ndata->REG_FAN_STEP_OUTPUT =\r\nW83627EHF_REG_FAN_STEP_OUTPUT_W83667_B;\r\n} else {\r\ndata->has_fan_div = true;\r\ndata->fan_from_reg = fan_from_reg8;\r\ndata->fan_from_reg_min = fan_from_reg8;\r\ndata->REG_PWM = W83627EHF_REG_PWM;\r\ndata->REG_TARGET = W83627EHF_REG_TARGET;\r\ndata->REG_FAN = W83627EHF_REG_FAN;\r\ndata->REG_FAN_MIN = W83627EHF_REG_FAN_MIN;\r\ndata->REG_FAN_START_OUTPUT = W83627EHF_REG_FAN_START_OUTPUT;\r\ndata->REG_FAN_STOP_OUTPUT = W83627EHF_REG_FAN_STOP_OUTPUT;\r\ndata->REG_FAN_STOP_TIME = W83627EHF_REG_FAN_STOP_TIME;\r\ndata->REG_FAN_MAX_OUTPUT =\r\nW83627EHF_REG_FAN_MAX_OUTPUT_COMMON;\r\ndata->REG_FAN_STEP_OUTPUT =\r\nW83627EHF_REG_FAN_STEP_OUTPUT_COMMON;\r\n}\r\nif (sio_data->kind == w83627uhg)\r\ndata->scale_in = scale_in_w83627uhg;\r\nelse\r\ndata->scale_in = scale_in_common;\r\nw83627ehf_init_device(data, sio_data->kind);\r\ndata->vrm = vid_which_vrm();\r\nerr = superio_enter(sio_data->sioreg);\r\nif (err)\r\ngoto exit_release;\r\nif (sio_data->kind == w83667hg || sio_data->kind == w83667hg_b ||\r\nsio_data->kind == nct6775 || sio_data->kind == nct6776) {\r\nsuperio_select(sio_data->sioreg, W83667HG_LD_VID);\r\ndata->vid = superio_inb(sio_data->sioreg, 0xe3);\r\nerr = device_create_file(dev, &dev_attr_cpu0_vid);\r\nif (err) {\r\nsuperio_exit(sio_data->sioreg);\r\ngoto exit_release;\r\n}\r\n} else if (sio_data->kind != w83627uhg) {\r\nsuperio_select(sio_data->sioreg, W83627EHF_LD_HWM);\r\nif (superio_inb(sio_data->sioreg, SIO_REG_VID_CTRL) & 0x80) {\r\nif (sio_data->kind == w83627ehf) {\r\nen_vrm10 = superio_inb(sio_data->sioreg,\r\nSIO_REG_EN_VRM10);\r\nif ((en_vrm10 & 0x08) && data->vrm == 90) {\r\ndev_warn(dev,\r\n"Setting VID input voltage to TTL\n");\r\nsuperio_outb(sio_data->sioreg,\r\nSIO_REG_EN_VRM10,\r\nen_vrm10 & ~0x08);\r\n} else if (!(en_vrm10 & 0x08)\r\n&& data->vrm == 100) {\r\ndev_warn(dev,\r\n"Setting VID input voltage to VRM10\n");\r\nsuperio_outb(sio_data->sioreg,\r\nSIO_REG_EN_VRM10,\r\nen_vrm10 | 0x08);\r\n}\r\n}\r\ndata->vid = superio_inb(sio_data->sioreg,\r\nSIO_REG_VID_DATA);\r\nif (sio_data->kind == w83627ehf)\r\ndata->vid &= 0x3f;\r\nerr = device_create_file(dev, &dev_attr_cpu0_vid);\r\nif (err) {\r\nsuperio_exit(sio_data->sioreg);\r\ngoto exit_release;\r\n}\r\n} else {\r\ndev_info(dev,\r\n"VID pins in output mode, CPU VID not available\n");\r\n}\r\n}\r\nif (fan_debounce &&\r\n(sio_data->kind == nct6775 || sio_data->kind == nct6776)) {\r\nu8 tmp;\r\nsuperio_select(sio_data->sioreg, W83627EHF_LD_HWM);\r\ntmp = superio_inb(sio_data->sioreg, NCT6775_REG_FAN_DEBOUNCE);\r\nif (sio_data->kind == nct6776)\r\nsuperio_outb(sio_data->sioreg, NCT6775_REG_FAN_DEBOUNCE,\r\n0x3e | tmp);\r\nelse\r\nsuperio_outb(sio_data->sioreg, NCT6775_REG_FAN_DEBOUNCE,\r\n0x1e | tmp);\r\npr_info("Enabled fan debounce for chip %s\n", data->name);\r\n}\r\nw83627ehf_check_fan_inputs(sio_data, data);\r\nsuperio_exit(sio_data->sioreg);\r\nw83627ehf_update_fan_div_common(dev, data);\r\nw83627ehf_update_pwm_common(dev, data);\r\nfor (i = 0; i < data->pwm_num; i++)\r\ndata->pwm_enable_orig[i] = data->pwm_enable[i];\r\nfor (i = 0; i < ARRAY_SIZE(sda_sf3_arrays); i++) {\r\nerr = device_create_file(dev, &sda_sf3_arrays[i].dev_attr);\r\nif (err)\r\ngoto exit_remove;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(sda_sf3_max_step_arrays); i++) {\r\nstruct sensor_device_attribute *attr =\r\n&sda_sf3_max_step_arrays[i];\r\nif (data->REG_FAN_STEP_OUTPUT &&\r\ndata->REG_FAN_STEP_OUTPUT[attr->index] != 0xff) {\r\nerr = device_create_file(dev, &attr->dev_attr);\r\nif (err)\r\ngoto exit_remove;\r\n}\r\n}\r\nif ((data->has_fan & (1 << 2)) && data->pwm_num >= 3)\r\nfor (i = 0; i < ARRAY_SIZE(sda_sf3_arrays_fan3); i++) {\r\nerr = device_create_file(dev,\r\n&sda_sf3_arrays_fan3[i].dev_attr);\r\nif (err)\r\ngoto exit_remove;\r\n}\r\nif ((data->has_fan & (1 << 3)) && data->pwm_num >= 4)\r\nfor (i = 0; i < ARRAY_SIZE(sda_sf3_arrays_fan4); i++) {\r\nerr = device_create_file(dev,\r\n&sda_sf3_arrays_fan4[i].dev_attr);\r\nif (err)\r\ngoto exit_remove;\r\n}\r\nfor (i = 0; i < data->in_num; i++) {\r\nif ((i == 6) && data->in6_skip)\r\ncontinue;\r\nif ((err = device_create_file(dev, &sda_in_input[i].dev_attr))\r\n|| (err = device_create_file(dev,\r\n&sda_in_alarm[i].dev_attr))\r\n|| (err = device_create_file(dev,\r\n&sda_in_min[i].dev_attr))\r\n|| (err = device_create_file(dev,\r\n&sda_in_max[i].dev_attr)))\r\ngoto exit_remove;\r\n}\r\nfor (i = 0; i < 5; i++) {\r\nif (data->has_fan & (1 << i)) {\r\nif ((err = device_create_file(dev,\r\n&sda_fan_input[i].dev_attr))\r\n|| (err = device_create_file(dev,\r\n&sda_fan_alarm[i].dev_attr)))\r\ngoto exit_remove;\r\nif (sio_data->kind != nct6776) {\r\nerr = device_create_file(dev,\r\n&sda_fan_div[i].dev_attr);\r\nif (err)\r\ngoto exit_remove;\r\n}\r\nif (data->has_fan_min & (1 << i)) {\r\nerr = device_create_file(dev,\r\n&sda_fan_min[i].dev_attr);\r\nif (err)\r\ngoto exit_remove;\r\n}\r\nif (i < data->pwm_num &&\r\n((err = device_create_file(dev,\r\n&sda_pwm[i].dev_attr))\r\n|| (err = device_create_file(dev,\r\n&sda_pwm_mode[i].dev_attr))\r\n|| (err = device_create_file(dev,\r\n&sda_pwm_enable[i].dev_attr))\r\n|| (err = device_create_file(dev,\r\n&sda_target_temp[i].dev_attr))\r\n|| (err = device_create_file(dev,\r\n&sda_tolerance[i].dev_attr))))\r\ngoto exit_remove;\r\n}\r\n}\r\nfor (i = 0; i < NUM_REG_TEMP; i++) {\r\nif (!(data->have_temp & (1 << i)))\r\ncontinue;\r\nerr = device_create_file(dev, &sda_temp_input[i].dev_attr);\r\nif (err)\r\ngoto exit_remove;\r\nif (data->temp_label) {\r\nerr = device_create_file(dev,\r\n&sda_temp_label[i].dev_attr);\r\nif (err)\r\ngoto exit_remove;\r\n}\r\nif (i == 2 && data->temp3_val_only)\r\ncontinue;\r\nif (data->reg_temp_over[i]) {\r\nerr = device_create_file(dev,\r\n&sda_temp_max[i].dev_attr);\r\nif (err)\r\ngoto exit_remove;\r\n}\r\nif (data->reg_temp_hyst[i]) {\r\nerr = device_create_file(dev,\r\n&sda_temp_max_hyst[i].dev_attr);\r\nif (err)\r\ngoto exit_remove;\r\n}\r\nif (i > 2)\r\ncontinue;\r\nif ((err = device_create_file(dev,\r\n&sda_temp_alarm[i].dev_attr))\r\n|| (err = device_create_file(dev,\r\n&sda_temp_type[i].dev_attr)))\r\ngoto exit_remove;\r\nif (data->have_temp_offset & (1 << i)) {\r\nerr = device_create_file(dev,\r\n&sda_temp_offset[i].dev_attr);\r\nif (err)\r\ngoto exit_remove;\r\n}\r\n}\r\nerr = device_create_file(dev, &sda_caseopen[0].dev_attr);\r\nif (err)\r\ngoto exit_remove;\r\nif (sio_data->kind == nct6776) {\r\nerr = device_create_file(dev, &sda_caseopen[1].dev_attr);\r\nif (err)\r\ngoto exit_remove;\r\n}\r\nerr = device_create_file(dev, &dev_attr_name);\r\nif (err)\r\ngoto exit_remove;\r\ndata->hwmon_dev = hwmon_device_register(dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nerr = PTR_ERR(data->hwmon_dev);\r\ngoto exit_remove;\r\n}\r\nreturn 0;\r\nexit_remove:\r\nw83627ehf_device_remove_files(dev);\r\nexit_release:\r\nrelease_region(res->start, IOREGION_LENGTH);\r\nexit:\r\nreturn err;\r\n}\r\nstatic int w83627ehf_remove(struct platform_device *pdev)\r\n{\r\nstruct w83627ehf_data *data = platform_get_drvdata(pdev);\r\nhwmon_device_unregister(data->hwmon_dev);\r\nw83627ehf_device_remove_files(&pdev->dev);\r\nrelease_region(data->addr, IOREGION_LENGTH);\r\nreturn 0;\r\n}\r\nstatic int w83627ehf_suspend(struct device *dev)\r\n{\r\nstruct w83627ehf_data *data = w83627ehf_update_device(dev);\r\nstruct w83627ehf_sio_data *sio_data = dev_get_platdata(dev);\r\nmutex_lock(&data->update_lock);\r\ndata->vbat = w83627ehf_read_value(data, W83627EHF_REG_VBAT);\r\nif (sio_data->kind == nct6775) {\r\ndata->fandiv1 = w83627ehf_read_value(data, NCT6775_REG_FANDIV1);\r\ndata->fandiv2 = w83627ehf_read_value(data, NCT6775_REG_FANDIV2);\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn 0;\r\n}\r\nstatic int w83627ehf_resume(struct device *dev)\r\n{\r\nstruct w83627ehf_data *data = dev_get_drvdata(dev);\r\nstruct w83627ehf_sio_data *sio_data = dev_get_platdata(dev);\r\nint i;\r\nmutex_lock(&data->update_lock);\r\ndata->bank = 0xff;\r\nfor (i = 0; i < data->in_num; i++) {\r\nif ((i == 6) && data->in6_skip)\r\ncontinue;\r\nw83627ehf_write_value(data, W83627EHF_REG_IN_MIN(i),\r\ndata->in_min[i]);\r\nw83627ehf_write_value(data, W83627EHF_REG_IN_MAX(i),\r\ndata->in_max[i]);\r\n}\r\nfor (i = 0; i < 5; i++) {\r\nif (!(data->has_fan_min & (1 << i)))\r\ncontinue;\r\nw83627ehf_write_value(data, data->REG_FAN_MIN[i],\r\ndata->fan_min[i]);\r\n}\r\nfor (i = 0; i < NUM_REG_TEMP; i++) {\r\nif (!(data->have_temp & (1 << i)))\r\ncontinue;\r\nif (data->reg_temp_over[i])\r\nw83627ehf_write_temp(data, data->reg_temp_over[i],\r\ndata->temp_max[i]);\r\nif (data->reg_temp_hyst[i])\r\nw83627ehf_write_temp(data, data->reg_temp_hyst[i],\r\ndata->temp_max_hyst[i]);\r\nif (i > 2)\r\ncontinue;\r\nif (data->have_temp_offset & (1 << i))\r\nw83627ehf_write_value(data,\r\nW83627EHF_REG_TEMP_OFFSET[i],\r\ndata->temp_offset[i]);\r\n}\r\nw83627ehf_write_value(data, W83627EHF_REG_VBAT, data->vbat);\r\nif (sio_data->kind == nct6775) {\r\nw83627ehf_write_value(data, NCT6775_REG_FANDIV1, data->fandiv1);\r\nw83627ehf_write_value(data, NCT6775_REG_FANDIV2, data->fandiv2);\r\n}\r\ndata->valid = 0;\r\nmutex_unlock(&data->update_lock);\r\nreturn 0;\r\n}\r\nstatic int __init w83627ehf_find(int sioaddr, unsigned short *addr,\r\nstruct w83627ehf_sio_data *sio_data)\r\n{\r\nstatic const char sio_name_W83627EHF[] __initconst = "W83627EHF";\r\nstatic const char sio_name_W83627EHG[] __initconst = "W83627EHG";\r\nstatic const char sio_name_W83627DHG[] __initconst = "W83627DHG";\r\nstatic const char sio_name_W83627DHG_P[] __initconst = "W83627DHG-P";\r\nstatic const char sio_name_W83627UHG[] __initconst = "W83627UHG";\r\nstatic const char sio_name_W83667HG[] __initconst = "W83667HG";\r\nstatic const char sio_name_W83667HG_B[] __initconst = "W83667HG-B";\r\nstatic const char sio_name_NCT6775[] __initconst = "NCT6775F";\r\nstatic const char sio_name_NCT6776[] __initconst = "NCT6776F";\r\nu16 val;\r\nconst char *sio_name;\r\nint err;\r\nerr = superio_enter(sioaddr);\r\nif (err)\r\nreturn err;\r\nif (force_id)\r\nval = force_id;\r\nelse\r\nval = (superio_inb(sioaddr, SIO_REG_DEVID) << 8)\r\n| superio_inb(sioaddr, SIO_REG_DEVID + 1);\r\nswitch (val & SIO_ID_MASK) {\r\ncase SIO_W83627EHF_ID:\r\nsio_data->kind = w83627ehf;\r\nsio_name = sio_name_W83627EHF;\r\nbreak;\r\ncase SIO_W83627EHG_ID:\r\nsio_data->kind = w83627ehf;\r\nsio_name = sio_name_W83627EHG;\r\nbreak;\r\ncase SIO_W83627DHG_ID:\r\nsio_data->kind = w83627dhg;\r\nsio_name = sio_name_W83627DHG;\r\nbreak;\r\ncase SIO_W83627DHG_P_ID:\r\nsio_data->kind = w83627dhg_p;\r\nsio_name = sio_name_W83627DHG_P;\r\nbreak;\r\ncase SIO_W83627UHG_ID:\r\nsio_data->kind = w83627uhg;\r\nsio_name = sio_name_W83627UHG;\r\nbreak;\r\ncase SIO_W83667HG_ID:\r\nsio_data->kind = w83667hg;\r\nsio_name = sio_name_W83667HG;\r\nbreak;\r\ncase SIO_W83667HG_B_ID:\r\nsio_data->kind = w83667hg_b;\r\nsio_name = sio_name_W83667HG_B;\r\nbreak;\r\ncase SIO_NCT6775_ID:\r\nsio_data->kind = nct6775;\r\nsio_name = sio_name_NCT6775;\r\nbreak;\r\ncase SIO_NCT6776_ID:\r\nsio_data->kind = nct6776;\r\nsio_name = sio_name_NCT6776;\r\nbreak;\r\ndefault:\r\nif (val != 0xffff)\r\npr_debug("unsupported chip ID: 0x%04x\n", val);\r\nsuperio_exit(sioaddr);\r\nreturn -ENODEV;\r\n}\r\nsuperio_select(sioaddr, W83627EHF_LD_HWM);\r\nval = (superio_inb(sioaddr, SIO_REG_ADDR) << 8)\r\n| superio_inb(sioaddr, SIO_REG_ADDR + 1);\r\n*addr = val & IOREGION_ALIGNMENT;\r\nif (*addr == 0) {\r\npr_err("Refusing to enable a Super-I/O device with a base I/O port 0\n");\r\nsuperio_exit(sioaddr);\r\nreturn -ENODEV;\r\n}\r\nval = superio_inb(sioaddr, SIO_REG_ENABLE);\r\nif (!(val & 0x01)) {\r\npr_warn("Forcibly enabling Super-I/O. Sensor is probably unusable.\n");\r\nsuperio_outb(sioaddr, SIO_REG_ENABLE, val | 0x01);\r\n}\r\nsuperio_exit(sioaddr);\r\npr_info("Found %s chip at %#x\n", sio_name, *addr);\r\nsio_data->sioreg = sioaddr;\r\nreturn 0;\r\n}\r\nstatic int __init sensors_w83627ehf_init(void)\r\n{\r\nint err;\r\nunsigned short address;\r\nstruct resource res;\r\nstruct w83627ehf_sio_data sio_data;\r\nif (w83627ehf_find(0x2e, &address, &sio_data) &&\r\nw83627ehf_find(0x4e, &address, &sio_data))\r\nreturn -ENODEV;\r\nerr = platform_driver_register(&w83627ehf_driver);\r\nif (err)\r\ngoto exit;\r\npdev = platform_device_alloc(DRVNAME, address);\r\nif (!pdev) {\r\nerr = -ENOMEM;\r\npr_err("Device allocation failed\n");\r\ngoto exit_unregister;\r\n}\r\nerr = platform_device_add_data(pdev, &sio_data,\r\nsizeof(struct w83627ehf_sio_data));\r\nif (err) {\r\npr_err("Platform data allocation failed\n");\r\ngoto exit_device_put;\r\n}\r\nmemset(&res, 0, sizeof(res));\r\nres.name = DRVNAME;\r\nres.start = address + IOREGION_OFFSET;\r\nres.end = address + IOREGION_OFFSET + IOREGION_LENGTH - 1;\r\nres.flags = IORESOURCE_IO;\r\nerr = acpi_check_resource_conflict(&res);\r\nif (err)\r\ngoto exit_device_put;\r\nerr = platform_device_add_resources(pdev, &res, 1);\r\nif (err) {\r\npr_err("Device resource addition failed (%d)\n", err);\r\ngoto exit_device_put;\r\n}\r\nerr = platform_device_add(pdev);\r\nif (err) {\r\npr_err("Device addition failed (%d)\n", err);\r\ngoto exit_device_put;\r\n}\r\nreturn 0;\r\nexit_device_put:\r\nplatform_device_put(pdev);\r\nexit_unregister:\r\nplatform_driver_unregister(&w83627ehf_driver);\r\nexit:\r\nreturn err;\r\n}\r\nstatic void __exit sensors_w83627ehf_exit(void)\r\n{\r\nplatform_device_unregister(pdev);\r\nplatform_driver_unregister(&w83627ehf_driver);\r\n}
