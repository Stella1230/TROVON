void init_mlme_ap_info(struct adapter *padapter)\r\n{\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct wlan_acl_pool *pacl_list = &pstapriv->acl_list;\r\nspin_lock_init(&pmlmepriv->bcn_update_lock);\r\n_rtw_init_queue(&pacl_list->acl_node_q);\r\nstart_ap_mode(padapter);\r\n}\r\nvoid free_mlme_ap_info(struct adapter *padapter)\r\n{\r\nstruct sta_info *psta = NULL;\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\npmlmepriv->update_bcn = false;\r\npmlmeext->bstart_bss = false;\r\nrtw_sta_flush(padapter);\r\npmlmeinfo->state = _HW_STATE_NOLINK_;\r\nrtw_free_all_stainfo(padapter);\r\npsta = rtw_get_bcmc_stainfo(padapter);\r\nrtw_free_stainfo(padapter, psta);\r\n}\r\nstatic void update_BCNTIM(struct adapter *padapter)\r\n{\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nstruct wlan_bssid_ex *pnetwork_mlmeext = &(pmlmeinfo->network);\r\nunsigned char *pie = pnetwork_mlmeext->IEs;\r\nif (true) {\r\nu8 *p, *dst_ie, *premainder_ie = NULL, *pbackup_remainder_ie = NULL;\r\n__le16 tim_bitmap_le;\r\nuint offset, tmp_len, tim_ielen, tim_ie_offset, remainder_ielen;\r\ntim_bitmap_le = cpu_to_le16(pstapriv->tim_bitmap);\r\np = rtw_get_ie(\r\npie + _FIXED_IE_LENGTH_,\r\n_TIM_IE_,\r\n&tim_ielen,\r\npnetwork_mlmeext->IELength - _FIXED_IE_LENGTH_\r\n);\r\nif (p != NULL && tim_ielen > 0) {\r\ntim_ielen += 2;\r\npremainder_ie = p+tim_ielen;\r\ntim_ie_offset = (sint)(p - pie);\r\nremainder_ielen = pnetwork_mlmeext->IELength - tim_ie_offset - tim_ielen;\r\ndst_ie = p;\r\n} else{\r\ntim_ielen = 0;\r\noffset = _FIXED_IE_LENGTH_;\r\np = rtw_get_ie(\r\npie + _BEACON_IE_OFFSET_,\r\n_SSID_IE_,\r\n&tmp_len,\r\n(pnetwork_mlmeext->IELength - _BEACON_IE_OFFSET_)\r\n);\r\nif (p != NULL)\r\noffset += tmp_len+2;\r\np = rtw_get_ie(\r\npie + _BEACON_IE_OFFSET_,\r\n_SUPPORTEDRATES_IE_, &tmp_len,\r\n(pnetwork_mlmeext->IELength - _BEACON_IE_OFFSET_)\r\n);\r\nif (p != NULL)\r\noffset += tmp_len+2;\r\noffset += 3;\r\npremainder_ie = pie + offset;\r\nremainder_ielen = pnetwork_mlmeext->IELength - offset - tim_ielen;\r\ndst_ie = pie + offset;\r\n}\r\nif (remainder_ielen > 0) {\r\npbackup_remainder_ie = rtw_malloc(remainder_ielen);\r\nif (pbackup_remainder_ie && premainder_ie)\r\nmemcpy(pbackup_remainder_ie, premainder_ie, remainder_ielen);\r\n}\r\n*dst_ie++ = _TIM_IE_;\r\nif ((pstapriv->tim_bitmap&0xff00) && (pstapriv->tim_bitmap&0x00fe))\r\ntim_ielen = 5;\r\nelse\r\ntim_ielen = 4;\r\n*dst_ie++ = tim_ielen;\r\n*dst_ie++ = 0;\r\n*dst_ie++ = 1;\r\nif (pstapriv->tim_bitmap&BIT(0))\r\n*dst_ie++ = BIT(0);\r\nelse\r\n*dst_ie++ = 0;\r\nif (tim_ielen == 4) {\r\n__le16 pvb;\r\nif (pstapriv->tim_bitmap&0xff00)\r\npvb = cpu_to_le16(pstapriv->tim_bitmap >> 8);\r\nelse\r\npvb = tim_bitmap_le;\r\n*dst_ie++ = le16_to_cpu(pvb);\r\n} else if (tim_ielen == 5) {\r\nmemcpy(dst_ie, &tim_bitmap_le, 2);\r\ndst_ie += 2;\r\n}\r\nif (pbackup_remainder_ie) {\r\nmemcpy(dst_ie, pbackup_remainder_ie, remainder_ielen);\r\nkfree(pbackup_remainder_ie);\r\n}\r\noffset = (uint)(dst_ie - pie);\r\npnetwork_mlmeext->IELength = offset + remainder_ielen;\r\n}\r\n}\r\nu8 chk_sta_is_alive(struct sta_info *psta)\r\n{\r\n#ifdef DBG_EXPIRATION_CHK\r\nDBG_871X(\r\n"sta:"MAC_FMT", rssi:%d, rx:"STA_PKTS_FMT", expire_to:%u, %s%ssq_len:%u\n"\r\n, MAC_ARG(psta->hwaddr)\r\n, psta->rssi_stat.UndecoratedSmoothedPWDB\r\n, STA_RX_PKTS_DIFF_ARG(psta)\r\n, psta->expire_to\r\n, psta->state&WIFI_SLEEP_STATE?"PS, ":""\r\n, psta->state&WIFI_STA_ALIVE_CHK_STATE?"SAC, ":""\r\n, psta->sleepq_len\r\n);\r\n#endif\r\nsta_update_last_rx_pkts(psta);\r\nreturn true;\r\n}\r\nvoid expire_timeout_chk(struct adapter *padapter)\r\n{\r\nstruct list_head *phead, *plist;\r\nu8 updated = false;\r\nstruct sta_info *psta = NULL;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nu8 chk_alive_num = 0;\r\nchar chk_alive_list[NUM_STA];\r\nint i;\r\nspin_lock_bh(&pstapriv->auth_list_lock);\r\nphead = &pstapriv->auth_list;\r\nplist = get_next(phead);\r\n#ifdef DBG_EXPIRATION_CHK\r\nif (phead != plist) {\r\nDBG_871X(FUNC_NDEV_FMT" auth_list, cnt:%u\n"\r\n, FUNC_NDEV_ARG(padapter->pnetdev), pstapriv->auth_list_cnt);\r\n}\r\n#endif\r\nwhile (phead != plist) {\r\npsta = LIST_CONTAINOR(plist, struct sta_info, auth_list);\r\nplist = get_next(plist);\r\nif (psta->expire_to > 0) {\r\npsta->expire_to--;\r\nif (psta->expire_to == 0) {\r\nlist_del_init(&psta->auth_list);\r\npstapriv->auth_list_cnt--;\r\nDBG_871X(\r\n"auth expire %02X%02X%02X%02X%02X%02X\n",\r\npsta->hwaddr[0],\r\npsta->hwaddr[1],\r\npsta->hwaddr[2],\r\npsta->hwaddr[3],\r\npsta->hwaddr[4],\r\npsta->hwaddr[5]\r\n);\r\nspin_unlock_bh(&pstapriv->auth_list_lock);\r\nrtw_free_stainfo(padapter, psta);\r\nspin_lock_bh(&pstapriv->auth_list_lock);\r\n}\r\n}\r\n}\r\nspin_unlock_bh(&pstapriv->auth_list_lock);\r\npsta = NULL;\r\nspin_lock_bh(&pstapriv->asoc_list_lock);\r\nphead = &pstapriv->asoc_list;\r\nplist = get_next(phead);\r\n#ifdef DBG_EXPIRATION_CHK\r\nif (phead != plist) {\r\nDBG_871X(FUNC_NDEV_FMT" asoc_list, cnt:%u\n"\r\n, FUNC_NDEV_ARG(padapter->pnetdev), pstapriv->asoc_list_cnt);\r\n}\r\n#endif\r\nwhile (phead != plist) {\r\npsta = LIST_CONTAINOR(plist, struct sta_info, asoc_list);\r\nplist = get_next(plist);\r\n#ifdef CONFIG_AUTO_AP_MODE\r\nif (psta->isrc)\r\ncontinue;\r\n#endif\r\nif (chk_sta_is_alive(psta) || !psta->expire_to) {\r\npsta->expire_to = pstapriv->expire_to;\r\npsta->keep_alive_trycnt = 0;\r\npsta->under_exist_checking = 0;\r\n} else {\r\nif (psta->expire_to > 0)\r\npsta->expire_to--;\r\n}\r\nif (psta->expire_to == 0) {\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nif (padapter->registrypriv.wifi_spec == 1) {\r\npsta->expire_to = pstapriv->expire_to;\r\ncontinue;\r\n}\r\nif (psta->state & WIFI_SLEEP_STATE) {\r\nif (!(psta->state & WIFI_STA_ALIVE_CHK_STATE)) {\r\npsta->expire_to = pstapriv->expire_to;\r\npsta->state |= WIFI_STA_ALIVE_CHK_STATE;\r\npstapriv->tim_bitmap |= BIT(psta->aid);\r\nupdate_beacon(padapter, _TIM_IE_, NULL, true);\r\nif (!pmlmeext->active_keep_alive_check)\r\ncontinue;\r\n}\r\n}\r\nif (pmlmeext->active_keep_alive_check) {\r\nint stainfo_offset;\r\nstainfo_offset = rtw_stainfo_offset(pstapriv, psta);\r\nif (stainfo_offset_valid(stainfo_offset))\r\nchk_alive_list[chk_alive_num++] = stainfo_offset;\r\ncontinue;\r\n}\r\nlist_del_init(&psta->asoc_list);\r\npstapriv->asoc_list_cnt--;\r\nDBG_871X(\r\n"asoc expire "MAC_FMT", state = 0x%x\n",\r\nMAC_ARG(psta->hwaddr),\r\npsta->state\r\n);\r\nupdated = ap_free_sta(padapter, psta, false, WLAN_REASON_DEAUTH_LEAVING);\r\n} else{\r\nif (psta->sleepq_len > (NR_XMITFRAME/pstapriv->asoc_list_cnt)\r\n&& padapter->xmitpriv.free_xmitframe_cnt < ((\r\nNR_XMITFRAME/pstapriv->asoc_list_cnt\r\n)/2)\r\n) {\r\nDBG_871X(\r\n"%s sta:"MAC_FMT", sleepq_len:%u, free_xmitframe_cnt:%u, asoc_list_cnt:%u, clear sleep_q\n",\r\n__func__,\r\nMAC_ARG(psta->hwaddr),\r\npsta->sleepq_len,\r\npadapter->xmitpriv.free_xmitframe_cnt,\r\npstapriv->asoc_list_cnt\r\n);\r\nwakeup_sta_to_xmit(padapter, psta);\r\n}\r\n}\r\n}\r\nspin_unlock_bh(&pstapriv->asoc_list_lock);\r\nif (chk_alive_num) {\r\nu8 backup_oper_channel = 0;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nif (rtw_get_oper_ch(padapter) != pmlmeext->cur_channel) {\r\nbackup_oper_channel = rtw_get_oper_ch(padapter);\r\nSelectChannel(padapter, pmlmeext->cur_channel);\r\n}\r\nfor (i = 0; i < chk_alive_num; i++) {\r\nint ret = _FAIL;\r\npsta = rtw_get_stainfo_by_offset(pstapriv, chk_alive_list[i]);\r\nif (!(psta->state & _FW_LINKED))\r\ncontinue;\r\nif (psta->state & WIFI_SLEEP_STATE)\r\nret = issue_nulldata(padapter, psta->hwaddr, 0, 1, 50);\r\nelse\r\nret = issue_nulldata(padapter, psta->hwaddr, 0, 3, 50);\r\npsta->keep_alive_trycnt++;\r\nif (ret == _SUCCESS) {\r\nDBG_871X(\r\n"asoc check, sta(" MAC_FMT ") is alive\n",\r\nMAC_ARG(psta->hwaddr)\r\n);\r\npsta->expire_to = pstapriv->expire_to;\r\npsta->keep_alive_trycnt = 0;\r\ncontinue;\r\n} else if (psta->keep_alive_trycnt <= 3) {\r\nDBG_871X(\r\n"ack check for asoc expire, keep_alive_trycnt =%d\n",\r\npsta->keep_alive_trycnt);\r\npsta->expire_to = 1;\r\ncontinue;\r\n}\r\npsta->keep_alive_trycnt = 0;\r\nDBG_871X(\r\n"asoc expire "MAC_FMT", state = 0x%x\n",\r\nMAC_ARG(psta->hwaddr),\r\npsta->state);\r\nspin_lock_bh(&pstapriv->asoc_list_lock);\r\nif (list_empty(&psta->asoc_list) == false) {\r\nlist_del_init(&psta->asoc_list);\r\npstapriv->asoc_list_cnt--;\r\nupdated = ap_free_sta(padapter, psta, false, WLAN_REASON_DEAUTH_LEAVING);\r\n}\r\nspin_unlock_bh(&pstapriv->asoc_list_lock);\r\n}\r\nif (backup_oper_channel > 0)\r\nSelectChannel(padapter, backup_oper_channel);\r\n}\r\nassociated_clients_update(padapter, updated);\r\n}\r\nvoid add_RATid(struct adapter *padapter, struct sta_info *psta, u8 rssi_level)\r\n{\r\nunsigned char sta_band = 0, shortGIrate = false;\r\nunsigned int tx_ra_bitmap = 0;\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nstruct wlan_bssid_ex\r\n*pcur_network = (struct wlan_bssid_ex *)&pmlmepriv->cur_network.network;\r\nif (!psta)\r\nreturn;\r\nif (!(psta->state & _FW_LINKED))\r\nreturn;\r\nrtw_hal_update_sta_rate_mask(padapter, psta);\r\ntx_ra_bitmap = psta->ra_mask;\r\nshortGIrate = query_ra_short_GI(psta);\r\nif (pcur_network->Configuration.DSConfig > 14) {\r\nif (tx_ra_bitmap & 0xffff000)\r\nsta_band |= WIRELESS_11_5N;\r\nif (tx_ra_bitmap & 0xff0)\r\nsta_band |= WIRELESS_11A;\r\n} else {\r\nif (tx_ra_bitmap & 0xffff000)\r\nsta_band |= WIRELESS_11_24N;\r\nif (tx_ra_bitmap & 0xff0)\r\nsta_band |= WIRELESS_11G;\r\nif (tx_ra_bitmap & 0x0f)\r\nsta_band |= WIRELESS_11B;\r\n}\r\npsta->wireless_mode = sta_band;\r\npsta->raid = rtw_hal_networktype_to_raid(padapter, psta);\r\nif (psta->aid < NUM_STA) {\r\nu8 arg[4] = {0};\r\narg[0] = psta->mac_id;\r\narg[1] = psta->raid;\r\narg[2] = shortGIrate;\r\narg[3] = psta->init_rate;\r\nDBG_871X("%s => mac_id:%d , raid:%d , shortGIrate =%d, bitmap = 0x%x\n",\r\n__func__, psta->mac_id, psta->raid, shortGIrate, tx_ra_bitmap);\r\nrtw_hal_add_ra_tid(padapter, tx_ra_bitmap, arg, rssi_level);\r\n} else{\r\nDBG_871X("station aid %d exceed the max number\n", psta->aid);\r\n}\r\n}\r\nvoid update_bmc_sta(struct adapter *padapter)\r\n{\r\nunsigned char network_type;\r\nint supportRateNum = 0;\r\nunsigned int tx_ra_bitmap = 0;\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nstruct wlan_bssid_ex\r\n*pcur_network = (struct wlan_bssid_ex *)&pmlmepriv->cur_network.network;\r\nstruct sta_info *psta = rtw_get_bcmc_stainfo(padapter);\r\nif (psta) {\r\npsta->aid = 0;\r\npsta->mac_id = psta->aid + 1;\r\npmlmeinfo->FW_sta_info[psta->mac_id].psta = psta;\r\npsta->qos_option = 0;\r\npsta->htpriv.ht_option = false;\r\npsta->ieee8021x_blocked = 0;\r\nmemset((void *)&psta->sta_stats, 0, sizeof(struct stainfo_stats));\r\nsupportRateNum = rtw_get_rateset_len((u8 *)&pcur_network->SupportedRates);\r\nnetwork_type = rtw_check_network_type(\r\n(u8 *)&pcur_network->SupportedRates,\r\nsupportRateNum,\r\npcur_network->Configuration.DSConfig\r\n);\r\nif (IsSupportedTxCCK(network_type)) {\r\nnetwork_type = WIRELESS_11B;\r\n} else if (network_type == WIRELESS_INVALID) {\r\nif (pcur_network->Configuration.DSConfig > 14)\r\nnetwork_type = WIRELESS_11A;\r\nelse\r\nnetwork_type = WIRELESS_11B;\r\n}\r\nupdate_sta_basic_rate(psta, network_type);\r\npsta->wireless_mode = network_type;\r\nrtw_hal_update_sta_rate_mask(padapter, psta);\r\ntx_ra_bitmap = psta->ra_mask;\r\npsta->raid = rtw_hal_networktype_to_raid(padapter, psta);\r\nrtw_hal_set_odm_var(padapter, HAL_ODM_STA_INFO, psta, true);\r\n{\r\nu8 arg[4] = {0};\r\narg[0] = psta->mac_id;\r\narg[1] = psta->raid;\r\narg[2] = 0;\r\narg[3] = psta->init_rate;\r\nDBG_871X("%s => mac_id:%d , raid:%d , bitmap = 0x%x\n",\r\n__func__, psta->mac_id, psta->raid, tx_ra_bitmap);\r\nrtw_hal_add_ra_tid(padapter, tx_ra_bitmap, arg, 0);\r\n}\r\nrtw_sta_media_status_rpt(padapter, psta, 1);\r\nspin_lock_bh(&psta->lock);\r\npsta->state = _FW_LINKED;\r\nspin_unlock_bh(&psta->lock);\r\n} else{\r\nDBG_871X("add_RATid_bmc_sta error!\n");\r\n}\r\n}\r\nvoid update_sta_info_apmode(struct adapter *padapter, struct sta_info *psta)\r\n{\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\r\nstruct ht_priv *phtpriv_ap = &pmlmepriv->htpriv;\r\nstruct ht_priv *phtpriv_sta = &psta->htpriv;\r\nu8 cur_ldpc_cap = 0, cur_stbc_cap = 0, cur_beamform_cap = 0;\r\nDBG_871X("%s\n", __func__);\r\nrtw_hal_set_odm_var(padapter, HAL_ODM_STA_INFO, psta, true);\r\nif (psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_8021X)\r\npsta->ieee8021x_blocked = true;\r\nelse\r\npsta->ieee8021x_blocked = false;\r\nVCS_update(padapter, psta);\r\nif (phtpriv_sta->ht_option) {\r\nphtpriv_sta->ampdu_enable = phtpriv_ap->ampdu_enable;\r\nphtpriv_sta->rx_ampdu_min_spacing = (\r\nphtpriv_sta->ht_cap.ampdu_params_info&IEEE80211_HT_CAP_AMPDU_DENSITY\r\n)>>2;\r\nif ((\r\nphtpriv_sta->ht_cap.cap_info & phtpriv_ap->ht_cap.cap_info\r\n) & cpu_to_le16(IEEE80211_HT_CAP_SUP_WIDTH))\r\npsta->bw_mode = CHANNEL_WIDTH_40;\r\nelse\r\npsta->bw_mode = CHANNEL_WIDTH_20;\r\nif (pmlmeext->cur_bwmode < psta->bw_mode)\r\npsta->bw_mode = pmlmeext->cur_bwmode;\r\nphtpriv_sta->ch_offset = pmlmeext->cur_ch_offset;\r\nif ((\r\nphtpriv_sta->ht_cap.cap_info & phtpriv_ap->ht_cap.cap_info\r\n) & cpu_to_le16(IEEE80211_HT_CAP_SGI_20))\r\nphtpriv_sta->sgi_20m = true;\r\nif ((\r\nphtpriv_sta->ht_cap.cap_info & phtpriv_ap->ht_cap.cap_info\r\n) & cpu_to_le16(IEEE80211_HT_CAP_SGI_40)) {\r\nif (psta->bw_mode == CHANNEL_WIDTH_40)\r\nphtpriv_sta->sgi_40m = true;\r\nelse\r\nphtpriv_sta->sgi_40m = false;\r\n}\r\npsta->qos_option = true;\r\nif (TEST_FLAG(phtpriv_ap->ldpc_cap, LDPC_HT_ENABLE_TX) &&\r\nGET_HT_CAPABILITY_ELE_LDPC_CAP((u8 *)(&phtpriv_sta->ht_cap))) {\r\nSET_FLAG(cur_ldpc_cap, (LDPC_HT_ENABLE_TX | LDPC_HT_CAP_TX));\r\nDBG_871X("Enable HT Tx LDPC for STA(%d)\n", psta->aid);\r\n}\r\nif (TEST_FLAG(phtpriv_ap->stbc_cap, STBC_HT_ENABLE_TX) &&\r\nGET_HT_CAPABILITY_ELE_RX_STBC((u8 *)(&phtpriv_sta->ht_cap))) {\r\nSET_FLAG(cur_stbc_cap, (STBC_HT_ENABLE_TX | STBC_HT_CAP_TX));\r\nDBG_871X("Enable HT Tx STBC for STA(%d)\n", psta->aid);\r\n}\r\n} else{\r\nphtpriv_sta->ampdu_enable = false;\r\nphtpriv_sta->sgi_20m = false;\r\nphtpriv_sta->sgi_40m = false;\r\npsta->bw_mode = CHANNEL_WIDTH_20;\r\nphtpriv_sta->ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;\r\n}\r\nphtpriv_sta->ldpc_cap = cur_ldpc_cap;\r\nphtpriv_sta->stbc_cap = cur_stbc_cap;\r\nphtpriv_sta->beamform_cap = cur_beamform_cap;\r\nsend_delba(padapter, 0, psta->hwaddr);\r\nsend_delba(padapter, 1, psta->hwaddr);\r\nphtpriv_sta->agg_enable_bitmap = 0x0;\r\nphtpriv_sta->candidate_tid_bitmap = 0x0;\r\nupdate_ldpc_stbc_cap(psta);\r\nmemset((void *)&psta->sta_stats, 0, sizeof(struct stainfo_stats));\r\nspin_lock_bh(&psta->lock);\r\npsta->state |= _FW_LINKED;\r\nspin_unlock_bh(&psta->lock);\r\n}\r\nstatic void update_ap_info(struct adapter *padapter, struct sta_info *psta)\r\n{\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nstruct wlan_bssid_ex\r\n*pnetwork = (struct wlan_bssid_ex *)&pmlmepriv->cur_network.network;\r\nstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\r\nstruct ht_priv *phtpriv_ap = &pmlmepriv->htpriv;\r\npsta->wireless_mode = pmlmeext->cur_wireless_mode;\r\npsta->bssratelen = rtw_get_rateset_len(pnetwork->SupportedRates);\r\nmemcpy(psta->bssrateset, pnetwork->SupportedRates, psta->bssratelen);\r\nif (phtpriv_ap->ht_option) {\r\nif ((phtpriv_ap->ht_cap.cap_info) & cpu_to_le16(IEEE80211_HT_CAP_SGI_20))\r\nphtpriv_ap->sgi_20m = true;\r\nif ((phtpriv_ap->ht_cap.cap_info) & cpu_to_le16(IEEE80211_HT_CAP_SGI_40))\r\nphtpriv_ap->sgi_40m = true;\r\npsta->qos_option = true;\r\n} else{\r\nphtpriv_ap->ampdu_enable = false;\r\nphtpriv_ap->sgi_20m = false;\r\nphtpriv_ap->sgi_40m = false;\r\n}\r\npsta->bw_mode = pmlmeext->cur_bwmode;\r\nphtpriv_ap->ch_offset = pmlmeext->cur_ch_offset;\r\nphtpriv_ap->agg_enable_bitmap = 0x0;\r\nphtpriv_ap->candidate_tid_bitmap = 0x0;\r\nmemcpy(&psta->htpriv, &pmlmepriv->htpriv, sizeof(struct ht_priv));\r\n}\r\nstatic void update_hw_ht_param(struct adapter *padapter)\r\n{\r\nunsigned char max_AMPDU_len;\r\nunsigned char min_MPDU_spacing;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nDBG_871X("%s\n", __func__);\r\nmax_AMPDU_len = pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x03;\r\nmin_MPDU_spacing = (\r\npmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x1c\r\n) >> 2;\r\nrtw_hal_set_hwreg(\r\npadapter,\r\nHW_VAR_AMPDU_MIN_SPACE,\r\n(u8 *)(&min_MPDU_spacing)\r\n);\r\nrtw_hal_set_hwreg(padapter, HW_VAR_AMPDU_FACTOR, (u8 *)(&max_AMPDU_len));\r\npmlmeinfo->SM_PS = (le16_to_cpu(\r\npmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info\r\n) & 0x0C) >> 2;\r\nif (pmlmeinfo->SM_PS == WLAN_HT_CAP_SM_PS_STATIC)\r\nDBG_871X("%s(): WLAN_HT_CAP_SM_PS_STATIC\n", __func__);\r\n}\r\nvoid start_bss_network(struct adapter *padapter, u8 *pbuf)\r\n{\r\nu8 *p;\r\nu8 val8, cur_channel, cur_bwmode, cur_ch_offset;\r\nu16 bcn_interval;\r\nu32 acparm;\r\nint ie_len;\r\nstruct registry_priv *pregpriv = &padapter->registrypriv;\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nstruct security_priv *psecuritypriv = &(padapter->securitypriv);\r\nstruct wlan_bssid_ex\r\n*pnetwork = (struct wlan_bssid_ex *)&pmlmepriv->cur_network.network;\r\nstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nstruct wlan_bssid_ex *pnetwork_mlmeext = &(pmlmeinfo->network);\r\nstruct HT_info_element *pht_info = NULL;\r\nu8 cbw40_enable = 0;\r\nbcn_interval = (u16)pnetwork->Configuration.BeaconPeriod;\r\ncur_channel = pnetwork->Configuration.DSConfig;\r\ncur_bwmode = CHANNEL_WIDTH_20;\r\ncur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;\r\nif (NULL == rtw_get_wps_ie(\r\npnetwork->IEs+_FIXED_IE_LENGTH_,\r\npnetwork->IELength-_FIXED_IE_LENGTH_,\r\nNULL,\r\nNULL\r\n))\r\npmlmeext->bstart_bss = true;\r\nif (pmlmepriv->qospriv.qos_option)\r\npmlmeinfo->WMM_enable = true;\r\nif (pmlmepriv->htpriv.ht_option) {\r\npmlmeinfo->WMM_enable = true;\r\npmlmeinfo->HT_enable = true;\r\nupdate_hw_ht_param(padapter);\r\n}\r\nif (pmlmepriv->cur_network.join_res != true) {\r\nif (\r\n(psecuritypriv->dot11PrivacyAlgrthm != _WEP40_) &&\r\n(psecuritypriv->dot11PrivacyAlgrthm != _WEP104_)\r\n)\r\nflush_all_cam_entry(padapter);\r\n}\r\nSet_MSR(padapter, _HW_STATE_AP_);\r\nrtw_hal_set_hwreg(padapter, HW_VAR_BSSID, pnetwork->MacAddress);\r\nacparm = 0x002F3217;\r\nrtw_hal_set_hwreg(padapter, HW_VAR_AC_PARAM_VO, (u8 *)(&acparm));\r\nacparm = 0x005E4317;\r\nrtw_hal_set_hwreg(padapter, HW_VAR_AC_PARAM_VI, (u8 *)(&acparm));\r\nacparm = 0x005ea42b;\r\nrtw_hal_set_hwreg(padapter, HW_VAR_AC_PARAM_BE, (u8 *)(&acparm));\r\nacparm = 0x0000A444;\r\nrtw_hal_set_hwreg(padapter, HW_VAR_AC_PARAM_BK, (u8 *)(&acparm));\r\nval8 = (\r\npsecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_8021X\r\n) ? 0xcc : 0xcf;\r\nrtw_hal_set_hwreg(padapter, HW_VAR_SEC_CFG, (u8 *)(&val8));\r\nrtw_hal_set_hwreg(padapter, HW_VAR_BEACON_INTERVAL, (u8 *)(&bcn_interval));\r\nrtw_hal_set_hwreg(padapter, HW_VAR_DO_IQK, NULL);\r\nif (pmlmepriv->cur_network.join_res != true) {\r\nSwitch_DM_Func(padapter, DYNAMIC_ALL_FUNC_ENABLE, true);\r\n}\r\np = rtw_get_ie(\r\n(pnetwork->IEs + sizeof(struct ndis_802_11_fix_ie)),\r\n_HT_ADD_INFO_IE_,\r\n&ie_len,\r\n(pnetwork->IELength - sizeof(struct ndis_802_11_fix_ie))\r\n);\r\nif (p && ie_len) {\r\npht_info = (struct HT_info_element *)(p+2);\r\nif (cur_channel > 14) {\r\nif ((pregpriv->bw_mode & 0xf0) > 0)\r\ncbw40_enable = 1;\r\n} else {\r\nif ((pregpriv->bw_mode & 0x0f) > 0)\r\ncbw40_enable = 1;\r\n}\r\nif ((cbw40_enable) && (pht_info->infos[0] & BIT(2))) {\r\ncur_bwmode = CHANNEL_WIDTH_40;\r\nswitch (pht_info->infos[0] & 0x3) {\r\ncase 1:\r\ncur_ch_offset = HAL_PRIME_CHNL_OFFSET_LOWER;\r\nbreak;\r\ncase 3:\r\ncur_ch_offset = HAL_PRIME_CHNL_OFFSET_UPPER;\r\nbreak;\r\ndefault:\r\ncur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;\r\nbreak;\r\n}\r\n}\r\n}\r\nset_channel_bwmode(padapter, cur_channel, cur_ch_offset, cur_bwmode);\r\nDBG_871X(\r\n"CH =%d, BW =%d, offset =%d\n",\r\ncur_channel,\r\ncur_bwmode,\r\ncur_ch_offset\r\n);\r\npmlmeext->cur_channel = cur_channel;\r\npmlmeext->cur_bwmode = cur_bwmode;\r\npmlmeext->cur_ch_offset = cur_ch_offset;\r\npmlmeext->cur_wireless_mode = pmlmepriv->cur_network.network_type;\r\nmemcpy(pnetwork_mlmeext, pnetwork, pnetwork->Length);\r\nupdate_wireless_mode(padapter);\r\nUpdateBrateTbl(padapter, pnetwork->SupportedRates);\r\nrtw_hal_set_hwreg(padapter, HW_VAR_BASIC_RATE, pnetwork->SupportedRates);\r\nupdate_capinfo(\r\npadapter,\r\nrtw_get_capability((struct wlan_bssid_ex *)pnetwork)\r\n);\r\nif (true == pmlmeext->bstart_bss) {\r\nupdate_beacon(padapter, _TIM_IE_, NULL, true);\r\n#ifndef CONFIG_INTERRUPT_BASED_TXBCN\r\nif (send_beacon(padapter) == _FAIL)\r\nDBG_871X("issue_beacon, fail!\n");\r\n#endif\r\n}\r\nupdate_bmc_sta(padapter);\r\n}\r\nint rtw_check_beacon_data(struct adapter *padapter, u8 *pbuf, int len)\r\n{\r\nint ret = _SUCCESS;\r\nu8 *p;\r\nu8 *pHT_caps_ie = NULL;\r\nu8 *pHT_info_ie = NULL;\r\nstruct sta_info *psta = NULL;\r\nu16 cap, ht_cap = false;\r\nuint ie_len = 0;\r\nint group_cipher, pairwise_cipher;\r\nu8 channel, network_type, supportRate[NDIS_802_11_LENGTH_RATES_EX];\r\nint supportRateNum = 0;\r\nu8 OUI1[] = {0x00, 0x50, 0xf2, 0x01};\r\nu8 WMM_PARA_IE[] = {0x00, 0x50, 0xf2, 0x02, 0x01, 0x01};\r\nstruct registry_priv *pregistrypriv = &padapter->registrypriv;\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nstruct wlan_bssid_ex\r\n*pbss_network = (struct wlan_bssid_ex *)&pmlmepriv->cur_network.network;\r\nu8 *ie = pbss_network->IEs;\r\nDBG_871X("%s, len =%d\n", __func__, len);\r\nif (check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)\r\nreturn _FAIL;\r\nif (len > MAX_IE_SZ)\r\nreturn _FAIL;\r\npbss_network->IELength = len;\r\nmemset(ie, 0, MAX_IE_SZ);\r\nmemcpy(ie, pbuf, pbss_network->IELength);\r\nif (pbss_network->InfrastructureMode != Ndis802_11APMode)\r\nreturn _FAIL;\r\npbss_network->Rssi = 0;\r\nmemcpy(pbss_network->MacAddress, myid(&(padapter->eeprompriv)), ETH_ALEN);\r\np = rtw_get_beacon_interval_from_ie(ie);\r\npbss_network->Configuration.BeaconPeriod = RTW_GET_LE16(p);\r\ncap = RTW_GET_LE16(ie);\r\np = rtw_get_ie(\r\nie + _BEACON_IE_OFFSET_,\r\n_SSID_IE_,\r\n&ie_len,\r\n(pbss_network->IELength - _BEACON_IE_OFFSET_)\r\n);\r\nif (p && ie_len > 0) {\r\nmemset(&pbss_network->Ssid, 0, sizeof(struct ndis_802_11_ssid));\r\nmemcpy(pbss_network->Ssid.Ssid, (p + 2), ie_len);\r\npbss_network->Ssid.SsidLength = ie_len;\r\n}\r\nchannel = 0;\r\npbss_network->Configuration.Length = 0;\r\np = rtw_get_ie(\r\nie + _BEACON_IE_OFFSET_,\r\n_DSSET_IE_, &ie_len,\r\n(pbss_network->IELength - _BEACON_IE_OFFSET_)\r\n);\r\nif (p && ie_len > 0)\r\nchannel = *(p + 2);\r\npbss_network->Configuration.DSConfig = channel;\r\nmemset(supportRate, 0, NDIS_802_11_LENGTH_RATES_EX);\r\np = rtw_get_ie(\r\nie + _BEACON_IE_OFFSET_,\r\n_SUPPORTEDRATES_IE_,\r\n&ie_len,\r\n(pbss_network->IELength - _BEACON_IE_OFFSET_)\r\n);\r\nif (p != NULL) {\r\nmemcpy(supportRate, p+2, ie_len);\r\nsupportRateNum = ie_len;\r\n}\r\np = rtw_get_ie(\r\nie + _BEACON_IE_OFFSET_,\r\n_EXT_SUPPORTEDRATES_IE_,\r\n&ie_len,\r\npbss_network->IELength - _BEACON_IE_OFFSET_\r\n);\r\nif (p != NULL) {\r\nmemcpy(supportRate+supportRateNum, p+2, ie_len);\r\nsupportRateNum += ie_len;\r\n}\r\nnetwork_type = rtw_check_network_type(supportRate, supportRateNum, channel);\r\nrtw_set_supported_rate(pbss_network->SupportedRates, network_type);\r\np = rtw_get_ie(\r\nie + _BEACON_IE_OFFSET_,\r\n_ERPINFO_IE_,\r\n&ie_len,\r\n(pbss_network->IELength - _BEACON_IE_OFFSET_)\r\n);\r\nif (p && ie_len > 0)\r\nERP_IE_handler(padapter, (struct ndis_80211_var_ie *)p);\r\nif (cap & BIT(4))\r\npbss_network->Privacy = 1;\r\nelse\r\npbss_network->Privacy = 0;\r\npsecuritypriv->wpa_psk = 0;\r\ngroup_cipher = 0; pairwise_cipher = 0;\r\npsecuritypriv->wpa2_group_cipher = _NO_PRIVACY_;\r\npsecuritypriv->wpa2_pairwise_cipher = _NO_PRIVACY_;\r\np = rtw_get_ie(\r\nie + _BEACON_IE_OFFSET_,\r\n_RSN_IE_2_,\r\n&ie_len,\r\n(pbss_network->IELength - _BEACON_IE_OFFSET_)\r\n);\r\nif (p && ie_len > 0) {\r\nif (rtw_parse_wpa2_ie(\r\np,\r\nie_len+2,\r\n&group_cipher,\r\n&pairwise_cipher,\r\nNULL\r\n) == _SUCCESS) {\r\npsecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;\r\npsecuritypriv->dot8021xalg = 1;\r\npsecuritypriv->wpa_psk |= BIT(1);\r\npsecuritypriv->wpa2_group_cipher = group_cipher;\r\npsecuritypriv->wpa2_pairwise_cipher = pairwise_cipher;\r\n}\r\n}\r\nie_len = 0;\r\ngroup_cipher = 0; pairwise_cipher = 0;\r\npsecuritypriv->wpa_group_cipher = _NO_PRIVACY_;\r\npsecuritypriv->wpa_pairwise_cipher = _NO_PRIVACY_;\r\nfor (p = ie + _BEACON_IE_OFFSET_; ; p += (ie_len + 2)) {\r\np = rtw_get_ie(\r\np,\r\n_SSN_IE_1_,\r\n&ie_len,\r\n(pbss_network->IELength - _BEACON_IE_OFFSET_ - (ie_len + 2))\r\n);\r\nif ((p) && (!memcmp(p+2, OUI1, 4))) {\r\nif (rtw_parse_wpa_ie(\r\np,\r\nie_len+2,\r\n&group_cipher,\r\n&pairwise_cipher,\r\nNULL\r\n) == _SUCCESS) {\r\npsecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;\r\npsecuritypriv->dot8021xalg = 1;\r\npsecuritypriv->wpa_psk |= BIT(0);\r\npsecuritypriv->wpa_group_cipher = group_cipher;\r\npsecuritypriv->wpa_pairwise_cipher = pairwise_cipher;\r\n}\r\nbreak;\r\n}\r\nif ((p == NULL) || (ie_len == 0))\r\nbreak;\r\n}\r\nie_len = 0;\r\npmlmepriv->qospriv.qos_option = 0;\r\nif (pregistrypriv->wmm_enable) {\r\nfor (p = ie + _BEACON_IE_OFFSET_; ; p += (ie_len + 2)) {\r\np = rtw_get_ie(\r\np,\r\n_VENDOR_SPECIFIC_IE_,\r\n&ie_len,\r\n(pbss_network->IELength - _BEACON_IE_OFFSET_ - (ie_len + 2))\r\n);\r\nif ((p) && !memcmp(p+2, WMM_PARA_IE, 6)) {\r\npmlmepriv->qospriv.qos_option = 1;\r\n*(p+8) |= BIT(7);\r\n*(p + 10) &= ~BIT(4);\r\n*(p + 14) &= ~BIT(4);\r\n*(p + 18) &= ~BIT(4);\r\n*(p + 22) &= ~BIT(4);\r\nbreak;\r\n}\r\nif ((p == NULL) || (ie_len == 0))\r\nbreak;\r\n}\r\n}\r\np = rtw_get_ie(\r\nie + _BEACON_IE_OFFSET_,\r\n_HT_CAPABILITY_IE_,\r\n&ie_len,\r\n(pbss_network->IELength - _BEACON_IE_OFFSET_)\r\n);\r\nif (p && ie_len > 0) {\r\nu8 rf_type = 0;\r\nu8 max_rx_ampdu_factor = 0;\r\nstruct rtw_ieee80211_ht_cap *pht_cap = (struct rtw_ieee80211_ht_cap *)(p+2);\r\npHT_caps_ie = p;\r\nht_cap = true;\r\nnetwork_type |= WIRELESS_11_24N;\r\nrtw_ht_use_default_setting(padapter);\r\nif (pmlmepriv->htpriv.sgi_20m == false)\r\npht_cap->cap_info &= cpu_to_le16(~(IEEE80211_HT_CAP_SGI_20));\r\nif (pmlmepriv->htpriv.sgi_40m == false)\r\npht_cap->cap_info &= cpu_to_le16(~(IEEE80211_HT_CAP_SGI_40));\r\nif (!TEST_FLAG(pmlmepriv->htpriv.ldpc_cap, LDPC_HT_ENABLE_RX))\r\npht_cap->cap_info &= cpu_to_le16(~(IEEE80211_HT_CAP_LDPC_CODING));\r\nif (!TEST_FLAG(pmlmepriv->htpriv.stbc_cap, STBC_HT_ENABLE_TX))\r\npht_cap->cap_info &= cpu_to_le16(~(IEEE80211_HT_CAP_TX_STBC));\r\nif (!TEST_FLAG(pmlmepriv->htpriv.stbc_cap, STBC_HT_ENABLE_RX))\r\npht_cap->cap_info &= cpu_to_le16(~(IEEE80211_HT_CAP_RX_STBC_3R));\r\npht_cap->ampdu_params_info &= ~(\r\nIEEE80211_HT_CAP_AMPDU_FACTOR|IEEE80211_HT_CAP_AMPDU_DENSITY\r\n);\r\nif ((psecuritypriv->wpa_pairwise_cipher & WPA_CIPHER_CCMP) ||\r\n(psecuritypriv->wpa2_pairwise_cipher & WPA_CIPHER_CCMP)) {\r\npht_cap->ampdu_params_info |= (IEEE80211_HT_CAP_AMPDU_DENSITY&(0x07<<2));\r\n} else{\r\npht_cap->ampdu_params_info |= (IEEE80211_HT_CAP_AMPDU_DENSITY&0x00);\r\n}\r\nrtw_hal_get_def_var(\r\npadapter,\r\nHW_VAR_MAX_RX_AMPDU_FACTOR,\r\n&max_rx_ampdu_factor\r\n);\r\npht_cap->ampdu_params_info |= (\r\nIEEE80211_HT_CAP_AMPDU_FACTOR & max_rx_ampdu_factor\r\n);\r\nrtw_hal_get_hwreg(padapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));\r\nif (rf_type == RF_1T1R) {\r\npht_cap->supp_mcs_set[0] = 0xff;\r\npht_cap->supp_mcs_set[1] = 0x0;\r\n}\r\nmemcpy(&pmlmepriv->htpriv.ht_cap, p+2, ie_len);\r\n}\r\np = rtw_get_ie(\r\nie + _BEACON_IE_OFFSET_,\r\n_HT_ADD_INFO_IE_,\r\n&ie_len,\r\n(pbss_network->IELength - _BEACON_IE_OFFSET_)\r\n);\r\nif (p && ie_len > 0)\r\npHT_info_ie = p;\r\nswitch (network_type) {\r\ncase WIRELESS_11B:\r\npbss_network->NetworkTypeInUse = Ndis802_11DS;\r\nbreak;\r\ncase WIRELESS_11G:\r\ncase WIRELESS_11BG:\r\ncase WIRELESS_11G_24N:\r\ncase WIRELESS_11BG_24N:\r\npbss_network->NetworkTypeInUse = Ndis802_11OFDM24;\r\nbreak;\r\ncase WIRELESS_11A:\r\npbss_network->NetworkTypeInUse = Ndis802_11OFDM5;\r\nbreak;\r\ndefault:\r\npbss_network->NetworkTypeInUse = Ndis802_11OFDM24;\r\nbreak;\r\n}\r\npmlmepriv->cur_network.network_type = network_type;\r\npmlmepriv->htpriv.ht_option = false;\r\nif ((psecuritypriv->wpa2_pairwise_cipher&WPA_CIPHER_TKIP) ||\r\n(psecuritypriv->wpa_pairwise_cipher&WPA_CIPHER_TKIP)) {\r\n}\r\nif (pregistrypriv->ht_enable && ht_cap == true) {\r\npmlmepriv->htpriv.ht_option = true;\r\npmlmepriv->qospriv.qos_option = 1;\r\nif (pregistrypriv->ampdu_enable == 1)\r\npmlmepriv->htpriv.ampdu_enable = true;\r\nHT_caps_handler(padapter, (struct ndis_80211_var_ie *)pHT_caps_ie);\r\nHT_info_handler(padapter, (struct ndis_80211_var_ie *)pHT_info_ie);\r\n}\r\npbss_network->Length = get_wlan_bssid_ex_sz(\r\n(struct wlan_bssid_ex *)pbss_network\r\n);\r\nrtw_startbss_cmd(padapter, RTW_CMDF_WAIT_ACK);\r\npsta = rtw_get_stainfo(&padapter->stapriv, pbss_network->MacAddress);\r\nif (!psta) {\r\npsta = rtw_alloc_stainfo(&padapter->stapriv, pbss_network->MacAddress);\r\nif (psta == NULL)\r\nreturn _FAIL;\r\n}\r\nupdate_ap_info(padapter, psta);\r\npsta->state |= WIFI_AP_STATE;\r\nrtw_indicate_connect(padapter);\r\npmlmepriv->cur_network.join_res = true;\r\nreturn ret;\r\n}\r\nvoid rtw_set_macaddr_acl(struct adapter *padapter, int mode)\r\n{\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct wlan_acl_pool *pacl_list = &pstapriv->acl_list;\r\nDBG_871X("%s, mode =%d\n", __func__, mode);\r\npacl_list->mode = mode;\r\n}\r\nint rtw_acl_add_sta(struct adapter *padapter, u8 *addr)\r\n{\r\nstruct list_head *plist, *phead;\r\nu8 added = false;\r\nint i, ret = 0;\r\nstruct rtw_wlan_acl_node *paclnode;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct wlan_acl_pool *pacl_list = &pstapriv->acl_list;\r\nstruct __queue *pacl_node_q = &pacl_list->acl_node_q;\r\nDBG_871X(\r\n"%s(acl_num =%d) =" MAC_FMT "\n",\r\n__func__,\r\npacl_list->num,\r\nMAC_ARG(addr)\r\n);\r\nif ((NUM_ACL-1) < pacl_list->num)\r\nreturn (-1);\r\nspin_lock_bh(&(pacl_node_q->lock));\r\nphead = get_list_head(pacl_node_q);\r\nplist = get_next(phead);\r\nwhile (phead != plist) {\r\npaclnode = LIST_CONTAINOR(plist, struct rtw_wlan_acl_node, list);\r\nplist = get_next(plist);\r\nif (!memcmp(paclnode->addr, addr, ETH_ALEN)) {\r\nif (paclnode->valid == true) {\r\nadded = true;\r\nDBG_871X("%s, sta has been added\n", __func__);\r\nbreak;\r\n}\r\n}\r\n}\r\nspin_unlock_bh(&(pacl_node_q->lock));\r\nif (added == true)\r\nreturn ret;\r\nspin_lock_bh(&(pacl_node_q->lock));\r\nfor (i = 0; i < NUM_ACL; i++) {\r\npaclnode = &pacl_list->aclnode[i];\r\nif (paclnode->valid == false) {\r\nINIT_LIST_HEAD(&paclnode->list);\r\nmemcpy(paclnode->addr, addr, ETH_ALEN);\r\npaclnode->valid = true;\r\nlist_add_tail(&paclnode->list, get_list_head(pacl_node_q));\r\npacl_list->num++;\r\nbreak;\r\n}\r\n}\r\nDBG_871X("%s, acl_num =%d\n", __func__, pacl_list->num);\r\nspin_unlock_bh(&(pacl_node_q->lock));\r\nreturn ret;\r\n}\r\nint rtw_acl_remove_sta(struct adapter *padapter, u8 *addr)\r\n{\r\nstruct list_head *plist, *phead;\r\nint ret = 0;\r\nstruct rtw_wlan_acl_node *paclnode;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct wlan_acl_pool *pacl_list = &pstapriv->acl_list;\r\nstruct __queue *pacl_node_q = &pacl_list->acl_node_q;\r\nu8 baddr[ETH_ALEN] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\r\nDBG_871X(\r\n"%s(acl_num =%d) =" MAC_FMT "\n",\r\n__func__,\r\npacl_list->num,\r\nMAC_ARG(addr)\r\n);\r\nspin_lock_bh(&(pacl_node_q->lock));\r\nphead = get_list_head(pacl_node_q);\r\nplist = get_next(phead);\r\nwhile (phead != plist) {\r\npaclnode = LIST_CONTAINOR(plist, struct rtw_wlan_acl_node, list);\r\nplist = get_next(plist);\r\nif (\r\n!memcmp(paclnode->addr, addr, ETH_ALEN) ||\r\n!memcmp(baddr, addr, ETH_ALEN)\r\n) {\r\nif (paclnode->valid == true) {\r\npaclnode->valid = false;\r\nlist_del_init(&paclnode->list);\r\npacl_list->num--;\r\n}\r\n}\r\n}\r\nspin_unlock_bh(&(pacl_node_q->lock));\r\nDBG_871X("%s, acl_num =%d\n", __func__, pacl_list->num);\r\nreturn ret;\r\n}\r\nu8 rtw_ap_set_pairwise_key(struct adapter *padapter, struct sta_info *psta)\r\n{\r\nstruct cmd_obj *ph2c;\r\nstruct set_stakey_parm *psetstakey_para;\r\nstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\r\nu8 res = _SUCCESS;\r\nph2c = (struct cmd_obj *)rtw_zmalloc(sizeof(struct cmd_obj));\r\nif (ph2c == NULL) {\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\npsetstakey_para = (struct set_stakey_parm *)rtw_zmalloc(\r\nsizeof(struct set_stakey_parm)\r\n);\r\nif (psetstakey_para == NULL) {\r\nkfree((u8 *) ph2c);\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\ninit_h2fwcmd_w_parm_no_rsp(ph2c, psetstakey_para, _SetStaKey_CMD_);\r\npsetstakey_para->algorithm = (u8)psta->dot118021XPrivacy;\r\nmemcpy(psetstakey_para->addr, psta->hwaddr, ETH_ALEN);\r\nmemcpy(psetstakey_para->key, &psta->dot118021x_UncstKey, 16);\r\nres = rtw_enqueue_cmd(pcmdpriv, ph2c);\r\nexit:\r\nreturn res;\r\n}\r\nstatic int rtw_ap_set_key(\r\nstruct adapter *padapter,\r\nu8 *key,\r\nu8 alg,\r\nint keyid,\r\nu8 set_tx\r\n)\r\n{\r\nu8 keylen;\r\nstruct cmd_obj *pcmd;\r\nstruct setkey_parm *psetkeyparm;\r\nstruct cmd_priv *pcmdpriv = &(padapter->cmdpriv);\r\nint res = _SUCCESS;\r\npcmd = (struct cmd_obj *)rtw_zmalloc(sizeof(struct cmd_obj));\r\nif (pcmd == NULL) {\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\npsetkeyparm = (struct setkey_parm *)rtw_zmalloc(sizeof(struct setkey_parm));\r\nif (psetkeyparm == NULL) {\r\nkfree((unsigned char *)pcmd);\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\nmemset(psetkeyparm, 0, sizeof(struct setkey_parm));\r\npsetkeyparm->keyid = (u8)keyid;\r\nif (is_wep_enc(alg))\r\npadapter->securitypriv.key_mask |= BIT(psetkeyparm->keyid);\r\npsetkeyparm->algorithm = alg;\r\npsetkeyparm->set_tx = set_tx;\r\nswitch (alg) {\r\ncase _WEP40_:\r\nkeylen = 5;\r\nbreak;\r\ncase _WEP104_:\r\nkeylen = 13;\r\nbreak;\r\ncase _TKIP_:\r\ncase _TKIP_WTMIC_:\r\ncase _AES_:\r\ndefault:\r\nkeylen = 16;\r\n}\r\nmemcpy(&(psetkeyparm->key[0]), key, keylen);\r\npcmd->cmdcode = _SetKey_CMD_;\r\npcmd->parmbuf = (u8 *)psetkeyparm;\r\npcmd->cmdsz = (sizeof(struct setkey_parm));\r\npcmd->rsp = NULL;\r\npcmd->rspsz = 0;\r\nINIT_LIST_HEAD(&pcmd->list);\r\nres = rtw_enqueue_cmd(pcmdpriv, pcmd);\r\nexit:\r\nreturn res;\r\n}\r\nint rtw_ap_set_group_key(struct adapter *padapter, u8 *key, u8 alg, int keyid)\r\n{\r\nDBG_871X("%s\n", __func__);\r\nreturn rtw_ap_set_key(padapter, key, alg, keyid, 1);\r\n}\r\nint rtw_ap_set_wep_key(\r\nstruct adapter *padapter,\r\nu8 *key,\r\nu8 keylen,\r\nint keyid,\r\nu8 set_tx\r\n)\r\n{\r\nu8 alg;\r\nswitch (keylen) {\r\ncase 5:\r\nalg = _WEP40_;\r\nbreak;\r\ncase 13:\r\nalg = _WEP104_;\r\nbreak;\r\ndefault:\r\nalg = _NO_PRIVACY_;\r\n}\r\nDBG_871X("%s\n", __func__);\r\nreturn rtw_ap_set_key(padapter, key, alg, keyid, set_tx);\r\n}\r\nstatic void update_bcn_fixed_ie(struct adapter *padapter)\r\n{\r\nDBG_871X("%s\n", __func__);\r\n}\r\nstatic void update_bcn_erpinfo_ie(struct adapter *padapter)\r\n{\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nstruct wlan_bssid_ex *pnetwork = &(pmlmeinfo->network);\r\nunsigned char *p, *ie = pnetwork->IEs;\r\nu32 len = 0;\r\nDBG_871X("%s, ERP_enable =%d\n", __func__, pmlmeinfo->ERP_enable);\r\nif (!pmlmeinfo->ERP_enable)\r\nreturn;\r\np = rtw_get_ie(\r\nie + _BEACON_IE_OFFSET_,\r\n_ERPINFO_IE_,\r\n&len,\r\n(pnetwork->IELength - _BEACON_IE_OFFSET_)\r\n);\r\nif (p && len > 0) {\r\nstruct ndis_80211_var_ie *pIE = (struct ndis_80211_var_ie *)p;\r\nif (pmlmepriv->num_sta_non_erp == 1)\r\npIE->data[0] |= RTW_ERP_INFO_NON_ERP_PRESENT|RTW_ERP_INFO_USE_PROTECTION;\r\nelse\r\npIE->data[0] &= ~(\r\nRTW_ERP_INFO_NON_ERP_PRESENT|RTW_ERP_INFO_USE_PROTECTION\r\n);\r\nif (pmlmepriv->num_sta_no_short_preamble > 0)\r\npIE->data[0] |= RTW_ERP_INFO_BARKER_PREAMBLE_MODE;\r\nelse\r\npIE->data[0] &= ~(RTW_ERP_INFO_BARKER_PREAMBLE_MODE);\r\nERP_IE_handler(padapter, pIE);\r\n}\r\n}\r\nstatic void update_bcn_htcap_ie(struct adapter *padapter)\r\n{\r\nDBG_871X("%s\n", __func__);\r\n}\r\nstatic void update_bcn_htinfo_ie(struct adapter *padapter)\r\n{\r\nDBG_871X("%s\n", __func__);\r\n}\r\nstatic void update_bcn_rsn_ie(struct adapter *padapter)\r\n{\r\nDBG_871X("%s\n", __func__);\r\n}\r\nstatic void update_bcn_wpa_ie(struct adapter *padapter)\r\n{\r\nDBG_871X("%s\n", __func__);\r\n}\r\nstatic void update_bcn_wmm_ie(struct adapter *padapter)\r\n{\r\nDBG_871X("%s\n", __func__);\r\n}\r\nstatic void update_bcn_wps_ie(struct adapter *padapter)\r\n{\r\nu8 *pwps_ie = NULL;\r\nu8 *pwps_ie_src;\r\nu8 *premainder_ie;\r\nu8 *pbackup_remainder_ie = NULL;\r\nuint wps_ielen = 0, wps_offset, remainder_ielen;\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nstruct wlan_bssid_ex *pnetwork = &(pmlmeinfo->network);\r\nunsigned char *ie = pnetwork->IEs;\r\nu32 ielen = pnetwork->IELength;\r\nDBG_871X("%s\n", __func__);\r\npwps_ie = rtw_get_wps_ie(\r\nie+_FIXED_IE_LENGTH_,\r\nielen-_FIXED_IE_LENGTH_,\r\nNULL,\r\n&wps_ielen\r\n);\r\nif (pwps_ie == NULL || wps_ielen == 0)\r\nreturn;\r\npwps_ie_src = pmlmepriv->wps_beacon_ie;\r\nif (pwps_ie_src == NULL)\r\nreturn;\r\nwps_offset = (uint)(pwps_ie-ie);\r\npremainder_ie = pwps_ie + wps_ielen;\r\nremainder_ielen = ielen - wps_offset - wps_ielen;\r\nif (remainder_ielen > 0) {\r\npbackup_remainder_ie = rtw_malloc(remainder_ielen);\r\nif (pbackup_remainder_ie)\r\nmemcpy(pbackup_remainder_ie, premainder_ie, remainder_ielen);\r\n}\r\nwps_ielen = (uint)pwps_ie_src[1];\r\nif ((wps_offset+wps_ielen+2+remainder_ielen) <= MAX_IE_SZ) {\r\nmemcpy(pwps_ie, pwps_ie_src, wps_ielen+2);\r\npwps_ie += (wps_ielen+2);\r\nif (pbackup_remainder_ie)\r\nmemcpy(pwps_ie, pbackup_remainder_ie, remainder_ielen);\r\npnetwork->IELength = wps_offset + (wps_ielen+2) + remainder_ielen;\r\n}\r\nkfree(pbackup_remainder_ie);\r\n#if defined(CONFIG_INTERRUPT_BASED_TXBCN)\r\nif ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE) {\r\nu8 sr = 0;\r\nrtw_get_wps_attr_content(\r\npwps_ie_src,\r\nwps_ielen,\r\nWPS_ATTR_SELECTED_REGISTRAR,\r\n(u8 *)(&sr),\r\nNULL\r\n);\r\nif (sr) {\r\nset_fwstate(pmlmepriv, WIFI_UNDER_WPS);\r\nDBG_871X("%s, set WIFI_UNDER_WPS\n", __func__);\r\n}\r\n}\r\n#endif\r\n}\r\nstatic void update_bcn_p2p_ie(struct adapter *padapter)\r\n{\r\n}\r\nstatic void update_bcn_vendor_spec_ie(struct adapter *padapter, u8 *oui)\r\n{\r\nDBG_871X("%s\n", __func__);\r\nif (!memcmp(RTW_WPA_OUI, oui, 4))\r\nupdate_bcn_wpa_ie(padapter);\r\nelse if (!memcmp(WMM_OUI, oui, 4))\r\nupdate_bcn_wmm_ie(padapter);\r\nelse if (!memcmp(WPS_OUI, oui, 4))\r\nupdate_bcn_wps_ie(padapter);\r\nelse if (!memcmp(P2P_OUI, oui, 4))\r\nupdate_bcn_p2p_ie(padapter);\r\nelse\r\nDBG_871X("unknown OUI type!\n");\r\n}\r\nvoid update_beacon(struct adapter *padapter, u8 ie_id, u8 *oui, u8 tx)\r\n{\r\nstruct mlme_priv *pmlmepriv;\r\nstruct mlme_ext_priv *pmlmeext;\r\nif (!padapter)\r\nreturn;\r\npmlmepriv = &(padapter->mlmepriv);\r\npmlmeext = &(padapter->mlmeextpriv);\r\nif (false == pmlmeext->bstart_bss)\r\nreturn;\r\nspin_lock_bh(&pmlmepriv->bcn_update_lock);\r\nswitch (ie_id) {\r\ncase 0xFF:\r\nupdate_bcn_fixed_ie(padapter);\r\nbreak;\r\ncase _TIM_IE_:\r\nupdate_BCNTIM(padapter);\r\nbreak;\r\ncase _ERPINFO_IE_:\r\nupdate_bcn_erpinfo_ie(padapter);\r\nbreak;\r\ncase _HT_CAPABILITY_IE_:\r\nupdate_bcn_htcap_ie(padapter);\r\nbreak;\r\ncase _RSN_IE_2_:\r\nupdate_bcn_rsn_ie(padapter);\r\nbreak;\r\ncase _HT_ADD_INFO_IE_:\r\nupdate_bcn_htinfo_ie(padapter);\r\nbreak;\r\ncase _VENDOR_SPECIFIC_IE_:\r\nupdate_bcn_vendor_spec_ie(padapter, oui);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\npmlmepriv->update_bcn = true;\r\nspin_unlock_bh(&pmlmepriv->bcn_update_lock);\r\n#ifndef CONFIG_INTERRUPT_BASED_TXBCN\r\nif (tx) {\r\nset_tx_beacon_cmd(padapter);\r\n}\r\n#endif\r\n}\r\nstatic int rtw_ht_operation_update(struct adapter *padapter)\r\n{\r\nu16 cur_op_mode, new_op_mode;\r\nint op_mode_changes = 0;\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nstruct ht_priv *phtpriv_ap = &pmlmepriv->htpriv;\r\nif (pmlmepriv->htpriv.ht_option == true)\r\nreturn 0;\r\nDBG_871X("%s current operation mode = 0x%X\n",\r\n__func__, pmlmepriv->ht_op_mode);\r\nif (!(pmlmepriv->ht_op_mode & HT_INFO_OPERATION_MODE_NON_GF_DEVS_PRESENT)\r\n&& pmlmepriv->num_sta_ht_no_gf) {\r\npmlmepriv->ht_op_mode |=\r\nHT_INFO_OPERATION_MODE_NON_GF_DEVS_PRESENT;\r\nop_mode_changes++;\r\n} else if ((pmlmepriv->ht_op_mode &\r\nHT_INFO_OPERATION_MODE_NON_GF_DEVS_PRESENT) &&\r\npmlmepriv->num_sta_ht_no_gf == 0) {\r\npmlmepriv->ht_op_mode &=\r\n~HT_INFO_OPERATION_MODE_NON_GF_DEVS_PRESENT;\r\nop_mode_changes++;\r\n}\r\nif (!(pmlmepriv->ht_op_mode & HT_INFO_OPERATION_MODE_NON_HT_STA_PRESENT) &&\r\n(pmlmepriv->num_sta_no_ht || pmlmepriv->olbc_ht)) {\r\npmlmepriv->ht_op_mode |= HT_INFO_OPERATION_MODE_NON_HT_STA_PRESENT;\r\nop_mode_changes++;\r\n} else if ((pmlmepriv->ht_op_mode &\r\nHT_INFO_OPERATION_MODE_NON_HT_STA_PRESENT) &&\r\n(pmlmepriv->num_sta_no_ht == 0 && !pmlmepriv->olbc_ht)) {\r\npmlmepriv->ht_op_mode &=\r\n~HT_INFO_OPERATION_MODE_NON_HT_STA_PRESENT;\r\nop_mode_changes++;\r\n}\r\nnew_op_mode = 0;\r\nif (pmlmepriv->num_sta_no_ht ||\r\n(pmlmepriv->ht_op_mode & HT_INFO_OPERATION_MODE_NON_GF_DEVS_PRESENT))\r\nnew_op_mode = OP_MODE_MIXED;\r\nelse if (\r\n(le16_to_cpu(phtpriv_ap->ht_cap.cap_info) & IEEE80211_HT_CAP_SUP_WIDTH)\r\n&& pmlmepriv->num_sta_ht_20mhz)\r\nnew_op_mode = OP_MODE_20MHZ_HT_STA_ASSOCED;\r\nelse if (pmlmepriv->olbc_ht)\r\nnew_op_mode = OP_MODE_MAY_BE_LEGACY_STAS;\r\nelse\r\nnew_op_mode = OP_MODE_PURE;\r\ncur_op_mode = pmlmepriv->ht_op_mode & HT_INFO_OPERATION_MODE_OP_MODE_MASK;\r\nif (cur_op_mode != new_op_mode) {\r\npmlmepriv->ht_op_mode &= ~HT_INFO_OPERATION_MODE_OP_MODE_MASK;\r\npmlmepriv->ht_op_mode |= new_op_mode;\r\nop_mode_changes++;\r\n}\r\nDBG_871X("%s new operation mode = 0x%X changes =%d\n",\r\n__func__, pmlmepriv->ht_op_mode, op_mode_changes);\r\nreturn op_mode_changes;\r\n}\r\nvoid associated_clients_update(struct adapter *padapter, u8 updated)\r\n{\r\nif (updated == true) {\r\nstruct list_head *phead, *plist;\r\nstruct sta_info *psta = NULL;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nspin_lock_bh(&pstapriv->asoc_list_lock);\r\nphead = &pstapriv->asoc_list;\r\nplist = get_next(phead);\r\nwhile (phead != plist) {\r\npsta = LIST_CONTAINOR(plist, struct sta_info, asoc_list);\r\nplist = get_next(plist);\r\nVCS_update(padapter, psta);\r\n}\r\nspin_unlock_bh(&pstapriv->asoc_list_lock);\r\n}\r\n}\r\nvoid bss_cap_update_on_sta_join(struct adapter *padapter, struct sta_info *psta)\r\n{\r\nu8 beacon_updated = false;\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\r\nif (!(psta->flags & WLAN_STA_SHORT_PREAMBLE)) {\r\nif (!psta->no_short_preamble_set) {\r\npsta->no_short_preamble_set = 1;\r\npmlmepriv->num_sta_no_short_preamble++;\r\nif ((pmlmeext->cur_wireless_mode > WIRELESS_11B) &&\r\n(pmlmepriv->num_sta_no_short_preamble == 1)) {\r\nbeacon_updated = true;\r\nupdate_beacon(padapter, 0xFF, NULL, true);\r\n}\r\n}\r\n} else{\r\nif (psta->no_short_preamble_set) {\r\npsta->no_short_preamble_set = 0;\r\npmlmepriv->num_sta_no_short_preamble--;\r\nif ((pmlmeext->cur_wireless_mode > WIRELESS_11B) &&\r\n(pmlmepriv->num_sta_no_short_preamble == 0)) {\r\nbeacon_updated = true;\r\nupdate_beacon(padapter, 0xFF, NULL, true);\r\n}\r\n}\r\n}\r\nif (psta->flags & WLAN_STA_NONERP) {\r\nif (!psta->nonerp_set) {\r\npsta->nonerp_set = 1;\r\npmlmepriv->num_sta_non_erp++;\r\nif (pmlmepriv->num_sta_non_erp == 1) {\r\nbeacon_updated = true;\r\nupdate_beacon(padapter, _ERPINFO_IE_, NULL, true);\r\n}\r\n}\r\n} else{\r\nif (psta->nonerp_set) {\r\npsta->nonerp_set = 0;\r\npmlmepriv->num_sta_non_erp--;\r\nif (pmlmepriv->num_sta_non_erp == 0) {\r\nbeacon_updated = true;\r\nupdate_beacon(padapter, _ERPINFO_IE_, NULL, true);\r\n}\r\n}\r\n}\r\nif (!(psta->capability & WLAN_CAPABILITY_SHORT_SLOT)) {\r\nif (!psta->no_short_slot_time_set) {\r\npsta->no_short_slot_time_set = 1;\r\npmlmepriv->num_sta_no_short_slot_time++;\r\nif ((pmlmeext->cur_wireless_mode > WIRELESS_11B) &&\r\n(pmlmepriv->num_sta_no_short_slot_time == 1)) {\r\nbeacon_updated = true;\r\nupdate_beacon(padapter, 0xFF, NULL, true);\r\n}\r\n}\r\n} else{\r\nif (psta->no_short_slot_time_set) {\r\npsta->no_short_slot_time_set = 0;\r\npmlmepriv->num_sta_no_short_slot_time--;\r\nif ((pmlmeext->cur_wireless_mode > WIRELESS_11B) &&\r\n(pmlmepriv->num_sta_no_short_slot_time == 0)) {\r\nbeacon_updated = true;\r\nupdate_beacon(padapter, 0xFF, NULL, true);\r\n}\r\n}\r\n}\r\nif (psta->flags & WLAN_STA_HT) {\r\nu16 ht_capab = le16_to_cpu(psta->htpriv.ht_cap.cap_info);\r\nDBG_871X("HT: STA " MAC_FMT " HT Capabilities "\r\n"Info: 0x%04x\n", MAC_ARG(psta->hwaddr), ht_capab);\r\nif (psta->no_ht_set) {\r\npsta->no_ht_set = 0;\r\npmlmepriv->num_sta_no_ht--;\r\n}\r\nif ((ht_capab & IEEE80211_HT_CAP_GRN_FLD) == 0) {\r\nif (!psta->no_ht_gf_set) {\r\npsta->no_ht_gf_set = 1;\r\npmlmepriv->num_sta_ht_no_gf++;\r\n}\r\nDBG_871X("%s STA " MAC_FMT " - no "\r\n"greenfield, num of non-gf stations %d\n",\r\n__func__, MAC_ARG(psta->hwaddr),\r\npmlmepriv->num_sta_ht_no_gf);\r\n}\r\nif ((ht_capab & IEEE80211_HT_CAP_SUP_WIDTH) == 0) {\r\nif (!psta->ht_20mhz_set) {\r\npsta->ht_20mhz_set = 1;\r\npmlmepriv->num_sta_ht_20mhz++;\r\n}\r\nDBG_871X("%s STA " MAC_FMT " - 20 MHz HT, "\r\n"num of 20MHz HT STAs %d\n",\r\n__func__, MAC_ARG(psta->hwaddr),\r\npmlmepriv->num_sta_ht_20mhz);\r\n}\r\n} else{\r\nif (!psta->no_ht_set) {\r\npsta->no_ht_set = 1;\r\npmlmepriv->num_sta_no_ht++;\r\n}\r\nif (pmlmepriv->htpriv.ht_option == true) {\r\nDBG_871X("%s STA " MAC_FMT\r\n" - no HT, num of non-HT stations %d\n",\r\n__func__, MAC_ARG(psta->hwaddr),\r\npmlmepriv->num_sta_no_ht);\r\n}\r\n}\r\nif (rtw_ht_operation_update(padapter) > 0) {\r\nupdate_beacon(padapter, _HT_CAPABILITY_IE_, NULL, false);\r\nupdate_beacon(padapter, _HT_ADD_INFO_IE_, NULL, true);\r\n}\r\nassociated_clients_update(padapter, beacon_updated);\r\nDBG_871X("%s, updated =%d\n", __func__, beacon_updated);\r\n}\r\nu8 bss_cap_update_on_sta_leave(struct adapter *padapter, struct sta_info *psta)\r\n{\r\nu8 beacon_updated = false;\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\r\nif (!psta)\r\nreturn beacon_updated;\r\nif (psta->no_short_preamble_set) {\r\npsta->no_short_preamble_set = 0;\r\npmlmepriv->num_sta_no_short_preamble--;\r\nif (pmlmeext->cur_wireless_mode > WIRELESS_11B\r\n&& pmlmepriv->num_sta_no_short_preamble == 0){\r\nbeacon_updated = true;\r\nupdate_beacon(padapter, 0xFF, NULL, true);\r\n}\r\n}\r\nif (psta->nonerp_set) {\r\npsta->nonerp_set = 0;\r\npmlmepriv->num_sta_non_erp--;\r\nif (pmlmepriv->num_sta_non_erp == 0) {\r\nbeacon_updated = true;\r\nupdate_beacon(padapter, _ERPINFO_IE_, NULL, true);\r\n}\r\n}\r\nif (psta->no_short_slot_time_set) {\r\npsta->no_short_slot_time_set = 0;\r\npmlmepriv->num_sta_no_short_slot_time--;\r\nif (pmlmeext->cur_wireless_mode > WIRELESS_11B\r\n&& pmlmepriv->num_sta_no_short_slot_time == 0){\r\nbeacon_updated = true;\r\nupdate_beacon(padapter, 0xFF, NULL, true);\r\n}\r\n}\r\nif (psta->no_ht_gf_set) {\r\npsta->no_ht_gf_set = 0;\r\npmlmepriv->num_sta_ht_no_gf--;\r\n}\r\nif (psta->no_ht_set) {\r\npsta->no_ht_set = 0;\r\npmlmepriv->num_sta_no_ht--;\r\n}\r\nif (psta->ht_20mhz_set) {\r\npsta->ht_20mhz_set = 0;\r\npmlmepriv->num_sta_ht_20mhz--;\r\n}\r\nif (rtw_ht_operation_update(padapter) > 0) {\r\nupdate_beacon(padapter, _HT_CAPABILITY_IE_, NULL, false);\r\nupdate_beacon(padapter, _HT_ADD_INFO_IE_, NULL, true);\r\n}\r\nDBG_871X("%s, updated =%d\n", __func__, beacon_updated);\r\nreturn beacon_updated;\r\n}\r\nu8 ap_free_sta(\r\nstruct adapter *padapter,\r\nstruct sta_info *psta,\r\nbool active,\r\nu16 reason\r\n)\r\n{\r\nu8 beacon_updated = false;\r\nif (!psta)\r\nreturn beacon_updated;\r\nif (active == true) {\r\nsend_delba(padapter, 0, psta->hwaddr);\r\nsend_delba(padapter, 1, psta->hwaddr);\r\nissue_deauth(padapter, psta->hwaddr, reason);\r\n}\r\npsta->htpriv.agg_enable_bitmap = 0x0;\r\npsta->htpriv.candidate_tid_bitmap = 0x0;\r\nrtw_clearstakey_cmd(padapter, psta, true);\r\nspin_lock_bh(&psta->lock);\r\npsta->state &= ~_FW_LINKED;\r\nspin_unlock_bh(&psta->lock);\r\nrtw_cfg80211_indicate_sta_disassoc(padapter, psta->hwaddr, reason);\r\nreport_del_sta_event(padapter, psta->hwaddr, reason);\r\nbeacon_updated = bss_cap_update_on_sta_leave(padapter, psta);\r\nrtw_free_stainfo(padapter, psta);\r\nreturn beacon_updated;\r\n}\r\nint rtw_sta_flush(struct adapter *padapter)\r\n{\r\nstruct list_head *phead, *plist;\r\nint ret = 0;\r\nstruct sta_info *psta = NULL;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nu8 bc_addr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\r\nDBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(padapter->pnetdev));\r\nif ((pmlmeinfo->state&0x03) != WIFI_FW_AP_STATE)\r\nreturn ret;\r\nspin_lock_bh(&pstapriv->asoc_list_lock);\r\nphead = &pstapriv->asoc_list;\r\nplist = get_next(phead);\r\nwhile (phead != plist) {\r\npsta = LIST_CONTAINOR(plist, struct sta_info, asoc_list);\r\nplist = get_next(plist);\r\nlist_del_init(&psta->asoc_list);\r\npstapriv->asoc_list_cnt--;\r\nap_free_sta(padapter, psta, true, WLAN_REASON_DEAUTH_LEAVING);\r\n}\r\nspin_unlock_bh(&pstapriv->asoc_list_lock);\r\nissue_deauth(padapter, bc_addr, WLAN_REASON_DEAUTH_LEAVING);\r\nassociated_clients_update(padapter, true);\r\nreturn ret;\r\n}\r\nvoid sta_info_update(struct adapter *padapter, struct sta_info *psta)\r\n{\r\nint flags = psta->flags;\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nif (WLAN_STA_WME&flags)\r\npsta->qos_option = 1;\r\nelse\r\npsta->qos_option = 0;\r\nif (pmlmepriv->qospriv.qos_option == 0)\r\npsta->qos_option = 0;\r\nif (WLAN_STA_HT&flags) {\r\npsta->htpriv.ht_option = true;\r\npsta->qos_option = 1;\r\n} else{\r\npsta->htpriv.ht_option = false;\r\n}\r\nif (pmlmepriv->htpriv.ht_option == false)\r\npsta->htpriv.ht_option = false;\r\nupdate_sta_info_apmode(padapter, psta);\r\n}\r\nvoid ap_sta_info_defer_update(struct adapter *padapter, struct sta_info *psta)\r\n{\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nif (psta->state & _FW_LINKED) {\r\npmlmeinfo->FW_sta_info[psta->mac_id].psta = psta;\r\nadd_RATid(padapter, psta, 0);\r\n}\r\n}\r\nvoid rtw_ap_restore_network(struct adapter *padapter)\r\n{\r\nstruct mlme_priv *mlmepriv = &padapter->mlmepriv;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct sta_info *psta;\r\nstruct security_priv *psecuritypriv = &(padapter->securitypriv);\r\nstruct list_head *phead, *plist;\r\nu8 chk_alive_num = 0;\r\nchar chk_alive_list[NUM_STA];\r\nint i;\r\nrtw_setopmode_cmd(padapter, Ndis802_11APMode, false);\r\nset_channel_bwmode(\r\npadapter,\r\npmlmeext->cur_channel,\r\npmlmeext->cur_ch_offset,\r\npmlmeext->cur_bwmode\r\n);\r\nstart_bss_network(padapter, (u8 *)&mlmepriv->cur_network.network);\r\nif ((padapter->securitypriv.dot11PrivacyAlgrthm == _TKIP_) ||\r\n(padapter->securitypriv.dot11PrivacyAlgrthm == _AES_)) {\r\nrtw_set_key(\r\npadapter,\r\npsecuritypriv,\r\npsecuritypriv->dot118021XGrpKeyid,\r\n0,\r\nfalse\r\n);\r\n}\r\nspin_lock_bh(&pstapriv->asoc_list_lock);\r\nphead = &pstapriv->asoc_list;\r\nplist = get_next(phead);\r\nwhile (phead != plist) {\r\nint stainfo_offset;\r\npsta = LIST_CONTAINOR(plist, struct sta_info, asoc_list);\r\nplist = get_next(plist);\r\nstainfo_offset = rtw_stainfo_offset(pstapriv, psta);\r\nif (stainfo_offset_valid(stainfo_offset))\r\nchk_alive_list[chk_alive_num++] = stainfo_offset;\r\n}\r\nspin_unlock_bh(&pstapriv->asoc_list_lock);\r\nfor (i = 0; i < chk_alive_num; i++) {\r\npsta = rtw_get_stainfo_by_offset(pstapriv, chk_alive_list[i]);\r\nif (psta == NULL) {\r\nDBG_871X(FUNC_ADPT_FMT" sta_info is null\n", FUNC_ADPT_ARG(padapter));\r\n} else if (psta->state & _FW_LINKED) {\r\nrtw_sta_media_status_rpt(padapter, psta, 1);\r\nUpdate_RA_Entry(padapter, psta);\r\nif ((padapter->securitypriv.dot11PrivacyAlgrthm == _TKIP_) ||\r\n(padapter->securitypriv.dot11PrivacyAlgrthm == _AES_)) {\r\nrtw_setstakey_cmd(padapter, psta, true, false);\r\n}\r\n}\r\n}\r\n}\r\nvoid start_ap_mode(struct adapter *padapter)\r\n{\r\nint i;\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct wlan_acl_pool *pacl_list = &pstapriv->acl_list;\r\npmlmepriv->update_bcn = false;\r\npmlmeext->bstart_bss = false;\r\npmlmepriv->num_sta_non_erp = 0;\r\npmlmepriv->num_sta_no_short_slot_time = 0;\r\npmlmepriv->num_sta_no_short_preamble = 0;\r\npmlmepriv->num_sta_ht_no_gf = 0;\r\npmlmepriv->num_sta_no_ht = 0;\r\npmlmepriv->num_sta_ht_20mhz = 0;\r\npmlmepriv->olbc = false;\r\npmlmepriv->olbc_ht = false;\r\npmlmepriv->ht_op_mode = 0;\r\nfor (i = 0; i < NUM_STA; i++)\r\npstapriv->sta_aid[i] = NULL;\r\npmlmepriv->wps_beacon_ie = NULL;\r\npmlmepriv->wps_probe_resp_ie = NULL;\r\npmlmepriv->wps_assoc_resp_ie = NULL;\r\npmlmepriv->p2p_beacon_ie = NULL;\r\npmlmepriv->p2p_probe_resp_ie = NULL;\r\nINIT_LIST_HEAD(&(pacl_list->acl_node_q.queue));\r\npacl_list->num = 0;\r\npacl_list->mode = 0;\r\nfor (i = 0; i < NUM_ACL; i++) {\r\nINIT_LIST_HEAD(&pacl_list->aclnode[i].list);\r\npacl_list->aclnode[i].valid = false;\r\n}\r\n}\r\nvoid stop_ap_mode(struct adapter *padapter)\r\n{\r\nstruct list_head *phead, *plist;\r\nstruct rtw_wlan_acl_node *paclnode;\r\nstruct sta_info *psta = NULL;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct wlan_acl_pool *pacl_list = &pstapriv->acl_list;\r\nstruct __queue *pacl_node_q = &pacl_list->acl_node_q;\r\npmlmepriv->update_bcn = false;\r\npmlmeext->bstart_bss = false;\r\nmemset(\r\n(unsigned char *)&padapter->securitypriv,\r\n0,\r\nsizeof(struct security_priv)\r\n);\r\npadapter->securitypriv.ndisauthtype = Ndis802_11AuthModeOpen;\r\npadapter->securitypriv.ndisencryptstatus = Ndis802_11WEPDisabled;\r\nspin_lock_bh(&(pacl_node_q->lock));\r\nphead = get_list_head(pacl_node_q);\r\nplist = get_next(phead);\r\nwhile (phead != plist) {\r\npaclnode = LIST_CONTAINOR(plist, struct rtw_wlan_acl_node, list);\r\nplist = get_next(plist);\r\nif (paclnode->valid == true) {\r\npaclnode->valid = false;\r\nlist_del_init(&paclnode->list);\r\npacl_list->num--;\r\n}\r\n}\r\nspin_unlock_bh(&(pacl_node_q->lock));\r\nDBG_871X("%s, free acl_node_queue, num =%d\n", __func__, pacl_list->num);\r\nrtw_sta_flush(padapter);\r\nrtw_free_all_stainfo(padapter);\r\npsta = rtw_get_bcmc_stainfo(padapter);\r\nrtw_free_stainfo(padapter, psta);\r\nrtw_init_bcmc_stainfo(padapter);\r\nrtw_free_mlme_priv_ie_data(pmlmepriv);\r\nrtw_btcoex_MediaStatusNotify(padapter, 0);\r\n}
