struct iscsi_tiqn *iscsit_get_tiqn_for_login(unsigned char *buf)\r\n{\r\nstruct iscsi_tiqn *tiqn = NULL;\r\nspin_lock(&tiqn_lock);\r\nlist_for_each_entry(tiqn, &g_tiqn_list, tiqn_list) {\r\nif (!strcmp(tiqn->tiqn, buf)) {\r\nspin_lock(&tiqn->tiqn_state_lock);\r\nif (tiqn->tiqn_state == TIQN_STATE_ACTIVE) {\r\ntiqn->tiqn_access_count++;\r\nspin_unlock(&tiqn->tiqn_state_lock);\r\nspin_unlock(&tiqn_lock);\r\nreturn tiqn;\r\n}\r\nspin_unlock(&tiqn->tiqn_state_lock);\r\n}\r\n}\r\nspin_unlock(&tiqn_lock);\r\nreturn NULL;\r\n}\r\nstatic int iscsit_set_tiqn_shutdown(struct iscsi_tiqn *tiqn)\r\n{\r\nspin_lock(&tiqn->tiqn_state_lock);\r\nif (tiqn->tiqn_state == TIQN_STATE_ACTIVE) {\r\ntiqn->tiqn_state = TIQN_STATE_SHUTDOWN;\r\nspin_unlock(&tiqn->tiqn_state_lock);\r\nreturn 0;\r\n}\r\nspin_unlock(&tiqn->tiqn_state_lock);\r\nreturn -1;\r\n}\r\nvoid iscsit_put_tiqn_for_login(struct iscsi_tiqn *tiqn)\r\n{\r\nspin_lock(&tiqn->tiqn_state_lock);\r\ntiqn->tiqn_access_count--;\r\nspin_unlock(&tiqn->tiqn_state_lock);\r\n}\r\nstruct iscsi_tiqn *iscsit_add_tiqn(unsigned char *buf)\r\n{\r\nstruct iscsi_tiqn *tiqn = NULL;\r\nint ret;\r\nif (strlen(buf) >= ISCSI_IQN_LEN) {\r\npr_err("Target IQN exceeds %d bytes\n",\r\nISCSI_IQN_LEN);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\ntiqn = kzalloc(sizeof(*tiqn), GFP_KERNEL);\r\nif (!tiqn)\r\nreturn ERR_PTR(-ENOMEM);\r\nsprintf(tiqn->tiqn, "%s", buf);\r\nINIT_LIST_HEAD(&tiqn->tiqn_list);\r\nINIT_LIST_HEAD(&tiqn->tiqn_tpg_list);\r\nspin_lock_init(&tiqn->tiqn_state_lock);\r\nspin_lock_init(&tiqn->tiqn_tpg_lock);\r\nspin_lock_init(&tiqn->sess_err_stats.lock);\r\nspin_lock_init(&tiqn->login_stats.lock);\r\nspin_lock_init(&tiqn->logout_stats.lock);\r\ntiqn->tiqn_state = TIQN_STATE_ACTIVE;\r\nidr_preload(GFP_KERNEL);\r\nspin_lock(&tiqn_lock);\r\nret = idr_alloc(&tiqn_idr, NULL, 0, 0, GFP_NOWAIT);\r\nif (ret < 0) {\r\npr_err("idr_alloc() failed for tiqn->tiqn_index\n");\r\nspin_unlock(&tiqn_lock);\r\nidr_preload_end();\r\nkfree(tiqn);\r\nreturn ERR_PTR(ret);\r\n}\r\ntiqn->tiqn_index = ret;\r\nlist_add_tail(&tiqn->tiqn_list, &g_tiqn_list);\r\nspin_unlock(&tiqn_lock);\r\nidr_preload_end();\r\npr_debug("CORE[0] - Added iSCSI Target IQN: %s\n", tiqn->tiqn);\r\nreturn tiqn;\r\n}\r\nstatic void iscsit_wait_for_tiqn(struct iscsi_tiqn *tiqn)\r\n{\r\nspin_lock(&tiqn->tiqn_state_lock);\r\nwhile (tiqn->tiqn_access_count != 0) {\r\nspin_unlock(&tiqn->tiqn_state_lock);\r\nmsleep(10);\r\nspin_lock(&tiqn->tiqn_state_lock);\r\n}\r\nspin_unlock(&tiqn->tiqn_state_lock);\r\n}\r\nvoid iscsit_del_tiqn(struct iscsi_tiqn *tiqn)\r\n{\r\nif (iscsit_set_tiqn_shutdown(tiqn) < 0) {\r\npr_err("iscsit_set_tiqn_shutdown() failed\n");\r\nreturn;\r\n}\r\niscsit_wait_for_tiqn(tiqn);\r\nspin_lock(&tiqn_lock);\r\nlist_del(&tiqn->tiqn_list);\r\nidr_remove(&tiqn_idr, tiqn->tiqn_index);\r\nspin_unlock(&tiqn_lock);\r\npr_debug("CORE[0] - Deleted iSCSI Target IQN: %s\n",\r\ntiqn->tiqn);\r\nkfree(tiqn);\r\n}\r\nint iscsit_access_np(struct iscsi_np *np, struct iscsi_portal_group *tpg)\r\n{\r\nint ret;\r\nspin_lock_bh(&np->np_thread_lock);\r\nif (np->np_thread_state != ISCSI_NP_THREAD_ACTIVE) {\r\nspin_unlock_bh(&np->np_thread_lock);\r\nreturn -1;\r\n}\r\nspin_unlock_bh(&np->np_thread_lock);\r\nspin_lock_bh(&tpg->tpg_state_lock);\r\nif (tpg->tpg_state != TPG_STATE_ACTIVE) {\r\nspin_unlock_bh(&tpg->tpg_state_lock);\r\nreturn -1;\r\n}\r\nspin_unlock_bh(&tpg->tpg_state_lock);\r\nret = down_interruptible(&tpg->np_login_sem);\r\nif (ret != 0)\r\nreturn -1;\r\nspin_lock_bh(&tpg->tpg_state_lock);\r\nif (tpg->tpg_state != TPG_STATE_ACTIVE) {\r\nspin_unlock_bh(&tpg->tpg_state_lock);\r\nup(&tpg->np_login_sem);\r\nreturn -1;\r\n}\r\nspin_unlock_bh(&tpg->tpg_state_lock);\r\nreturn 0;\r\n}\r\nvoid iscsit_login_kref_put(struct kref *kref)\r\n{\r\nstruct iscsi_tpg_np *tpg_np = container_of(kref,\r\nstruct iscsi_tpg_np, tpg_np_kref);\r\ncomplete(&tpg_np->tpg_np_comp);\r\n}\r\nint iscsit_deaccess_np(struct iscsi_np *np, struct iscsi_portal_group *tpg,\r\nstruct iscsi_tpg_np *tpg_np)\r\n{\r\nstruct iscsi_tiqn *tiqn = tpg->tpg_tiqn;\r\nup(&tpg->np_login_sem);\r\nif (tpg_np)\r\nkref_put(&tpg_np->tpg_np_kref, iscsit_login_kref_put);\r\nif (tiqn)\r\niscsit_put_tiqn_for_login(tiqn);\r\nreturn 0;\r\n}\r\nbool iscsit_check_np_match(\r\nstruct sockaddr_storage *sockaddr,\r\nstruct iscsi_np *np,\r\nint network_transport)\r\n{\r\nstruct sockaddr_in *sock_in, *sock_in_e;\r\nstruct sockaddr_in6 *sock_in6, *sock_in6_e;\r\nbool ip_match = false;\r\nu16 port, port_e;\r\nif (sockaddr->ss_family == AF_INET6) {\r\nsock_in6 = (struct sockaddr_in6 *)sockaddr;\r\nsock_in6_e = (struct sockaddr_in6 *)&np->np_sockaddr;\r\nif (!memcmp(&sock_in6->sin6_addr.in6_u,\r\n&sock_in6_e->sin6_addr.in6_u,\r\nsizeof(struct in6_addr)))\r\nip_match = true;\r\nport = ntohs(sock_in6->sin6_port);\r\nport_e = ntohs(sock_in6_e->sin6_port);\r\n} else {\r\nsock_in = (struct sockaddr_in *)sockaddr;\r\nsock_in_e = (struct sockaddr_in *)&np->np_sockaddr;\r\nif (sock_in->sin_addr.s_addr == sock_in_e->sin_addr.s_addr)\r\nip_match = true;\r\nport = ntohs(sock_in->sin_port);\r\nport_e = ntohs(sock_in_e->sin_port);\r\n}\r\nif (ip_match && (port_e == port) &&\r\n(np->np_network_transport == network_transport))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic struct iscsi_np *iscsit_get_np(\r\nstruct sockaddr_storage *sockaddr,\r\nint network_transport)\r\n{\r\nstruct iscsi_np *np;\r\nbool match;\r\nlist_for_each_entry(np, &g_np_list, np_list) {\r\nspin_lock_bh(&np->np_thread_lock);\r\nif (np->np_thread_state != ISCSI_NP_THREAD_ACTIVE) {\r\nspin_unlock_bh(&np->np_thread_lock);\r\ncontinue;\r\n}\r\nmatch = iscsit_check_np_match(sockaddr, np, network_transport);\r\nif (match) {\r\nnp->np_exports++;\r\nspin_unlock_bh(&np->np_thread_lock);\r\nreturn np;\r\n}\r\nspin_unlock_bh(&np->np_thread_lock);\r\n}\r\nreturn NULL;\r\n}\r\nstruct iscsi_np *iscsit_add_np(\r\nstruct sockaddr_storage *sockaddr,\r\nint network_transport)\r\n{\r\nstruct iscsi_np *np;\r\nint ret;\r\nmutex_lock(&np_lock);\r\nnp = iscsit_get_np(sockaddr, network_transport);\r\nif (np) {\r\nmutex_unlock(&np_lock);\r\nreturn np;\r\n}\r\nnp = kzalloc(sizeof(*np), GFP_KERNEL);\r\nif (!np) {\r\nmutex_unlock(&np_lock);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nnp->np_flags |= NPF_IP_NETWORK;\r\nnp->np_network_transport = network_transport;\r\nspin_lock_init(&np->np_thread_lock);\r\ninit_completion(&np->np_restart_comp);\r\nINIT_LIST_HEAD(&np->np_list);\r\nret = iscsi_target_setup_login_socket(np, sockaddr);\r\nif (ret != 0) {\r\nkfree(np);\r\nmutex_unlock(&np_lock);\r\nreturn ERR_PTR(ret);\r\n}\r\nnp->np_thread = kthread_run(iscsi_target_login_thread, np, "iscsi_np");\r\nif (IS_ERR(np->np_thread)) {\r\npr_err("Unable to create kthread: iscsi_np\n");\r\nret = PTR_ERR(np->np_thread);\r\nkfree(np);\r\nmutex_unlock(&np_lock);\r\nreturn ERR_PTR(ret);\r\n}\r\nnp->np_exports = 1;\r\nnp->np_thread_state = ISCSI_NP_THREAD_ACTIVE;\r\nlist_add_tail(&np->np_list, &g_np_list);\r\nmutex_unlock(&np_lock);\r\npr_debug("CORE[0] - Added Network Portal: %pISpc on %s\n",\r\n&np->np_sockaddr, np->np_transport->name);\r\nreturn np;\r\n}\r\nint iscsit_reset_np_thread(\r\nstruct iscsi_np *np,\r\nstruct iscsi_tpg_np *tpg_np,\r\nstruct iscsi_portal_group *tpg,\r\nbool shutdown)\r\n{\r\nspin_lock_bh(&np->np_thread_lock);\r\nif (np->np_thread_state == ISCSI_NP_THREAD_INACTIVE) {\r\nspin_unlock_bh(&np->np_thread_lock);\r\nreturn 0;\r\n}\r\nnp->np_thread_state = ISCSI_NP_THREAD_RESET;\r\natomic_inc(&np->np_reset_count);\r\nif (np->np_thread) {\r\nspin_unlock_bh(&np->np_thread_lock);\r\nsend_sig(SIGINT, np->np_thread, 1);\r\nwait_for_completion(&np->np_restart_comp);\r\nspin_lock_bh(&np->np_thread_lock);\r\n}\r\nspin_unlock_bh(&np->np_thread_lock);\r\nif (tpg_np && shutdown) {\r\nkref_put(&tpg_np->tpg_np_kref, iscsit_login_kref_put);\r\nwait_for_completion(&tpg_np->tpg_np_comp);\r\n}\r\nreturn 0;\r\n}\r\nstatic void iscsit_free_np(struct iscsi_np *np)\r\n{\r\nif (np->np_socket)\r\nsock_release(np->np_socket);\r\n}\r\nint iscsit_del_np(struct iscsi_np *np)\r\n{\r\nspin_lock_bh(&np->np_thread_lock);\r\nnp->np_exports--;\r\nif (np->np_exports) {\r\nnp->enabled = true;\r\nspin_unlock_bh(&np->np_thread_lock);\r\nreturn 0;\r\n}\r\nnp->np_thread_state = ISCSI_NP_THREAD_SHUTDOWN;\r\nspin_unlock_bh(&np->np_thread_lock);\r\nif (np->np_thread) {\r\nsend_sig(SIGINT, np->np_thread, 1);\r\nkthread_stop(np->np_thread);\r\nnp->np_thread = NULL;\r\n}\r\nnp->np_transport->iscsit_free_np(np);\r\nmutex_lock(&np_lock);\r\nlist_del(&np->np_list);\r\nmutex_unlock(&np_lock);\r\npr_debug("CORE[0] - Removed Network Portal: %pISpc on %s\n",\r\n&np->np_sockaddr, np->np_transport->name);\r\niscsit_put_transport(np->np_transport);\r\nkfree(np);\r\nreturn 0;\r\n}\r\nint iscsit_queue_rsp(struct iscsi_conn *conn, struct iscsi_cmd *cmd)\r\n{\r\nreturn iscsit_add_cmd_to_response_queue(cmd, cmd->conn, cmd->i_state);\r\n}\r\nvoid iscsit_aborted_task(struct iscsi_conn *conn, struct iscsi_cmd *cmd)\r\n{\r\nspin_lock_bh(&conn->cmd_lock);\r\nif (!list_empty(&cmd->i_conn_node) &&\r\n!(cmd->se_cmd.transport_state & CMD_T_FABRIC_STOP))\r\nlist_del_init(&cmd->i_conn_node);\r\nspin_unlock_bh(&conn->cmd_lock);\r\n__iscsit_free_cmd(cmd, true);\r\n}\r\nstatic int\r\niscsit_xmit_nondatain_pdu(struct iscsi_conn *conn, struct iscsi_cmd *cmd,\r\nconst void *data_buf, u32 data_buf_len)\r\n{\r\nstruct iscsi_hdr *hdr = (struct iscsi_hdr *)cmd->pdu;\r\nstruct kvec *iov;\r\nu32 niov = 0, tx_size = ISCSI_HDR_LEN;\r\nint ret;\r\niov = &cmd->iov_misc[0];\r\niov[niov].iov_base = cmd->pdu;\r\niov[niov++].iov_len = ISCSI_HDR_LEN;\r\nif (conn->conn_ops->HeaderDigest) {\r\nu32 *header_digest = (u32 *)&cmd->pdu[ISCSI_HDR_LEN];\r\niscsit_do_crypto_hash_buf(conn->conn_tx_hash, hdr,\r\nISCSI_HDR_LEN, 0, NULL,\r\n(u8 *)header_digest);\r\niov[0].iov_len += ISCSI_CRC_LEN;\r\ntx_size += ISCSI_CRC_LEN;\r\npr_debug("Attaching CRC32C HeaderDigest"\r\n" to opcode 0x%x 0x%08x\n",\r\nhdr->opcode, *header_digest);\r\n}\r\nif (data_buf_len) {\r\nu32 padding = ((-data_buf_len) & 3);\r\niov[niov].iov_base = (void *)data_buf;\r\niov[niov++].iov_len = data_buf_len;\r\ntx_size += data_buf_len;\r\nif (padding != 0) {\r\niov[niov].iov_base = &cmd->pad_bytes;\r\niov[niov++].iov_len = padding;\r\ntx_size += padding;\r\npr_debug("Attaching %u additional"\r\n" padding bytes.\n", padding);\r\n}\r\nif (conn->conn_ops->DataDigest) {\r\niscsit_do_crypto_hash_buf(conn->conn_tx_hash,\r\ndata_buf, data_buf_len,\r\npadding,\r\n(u8 *)&cmd->pad_bytes,\r\n(u8 *)&cmd->data_crc);\r\niov[niov].iov_base = &cmd->data_crc;\r\niov[niov++].iov_len = ISCSI_CRC_LEN;\r\ntx_size += ISCSI_CRC_LEN;\r\npr_debug("Attached DataDigest for %u"\r\n" bytes opcode 0x%x, CRC 0x%08x\n",\r\ndata_buf_len, hdr->opcode, cmd->data_crc);\r\n}\r\n}\r\ncmd->iov_misc_count = niov;\r\ncmd->tx_size = tx_size;\r\nret = iscsit_send_tx_data(cmd, conn, 1);\r\nif (ret < 0) {\r\niscsit_tx_thread_wait_for_tcp(conn);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\niscsit_xmit_datain_pdu(struct iscsi_conn *conn, struct iscsi_cmd *cmd,\r\nconst struct iscsi_datain *datain)\r\n{\r\nstruct kvec *iov;\r\nu32 iov_count = 0, tx_size = 0;\r\nint ret, iov_ret;\r\niov = &cmd->iov_data[0];\r\niov[iov_count].iov_base = cmd->pdu;\r\niov[iov_count++].iov_len = ISCSI_HDR_LEN;\r\ntx_size += ISCSI_HDR_LEN;\r\nif (conn->conn_ops->HeaderDigest) {\r\nu32 *header_digest = (u32 *)&cmd->pdu[ISCSI_HDR_LEN];\r\niscsit_do_crypto_hash_buf(conn->conn_tx_hash, cmd->pdu,\r\nISCSI_HDR_LEN, 0, NULL,\r\n(u8 *)header_digest);\r\niov[0].iov_len += ISCSI_CRC_LEN;\r\ntx_size += ISCSI_CRC_LEN;\r\npr_debug("Attaching CRC32 HeaderDigest for DataIN PDU 0x%08x\n",\r\n*header_digest);\r\n}\r\niov_ret = iscsit_map_iovec(cmd, &cmd->iov_data[1],\r\ndatain->offset, datain->length);\r\nif (iov_ret < 0)\r\nreturn -1;\r\niov_count += iov_ret;\r\ntx_size += datain->length;\r\ncmd->padding = ((-datain->length) & 3);\r\nif (cmd->padding) {\r\niov[iov_count].iov_base = cmd->pad_bytes;\r\niov[iov_count++].iov_len = cmd->padding;\r\ntx_size += cmd->padding;\r\npr_debug("Attaching %u padding bytes\n", cmd->padding);\r\n}\r\nif (conn->conn_ops->DataDigest) {\r\ncmd->data_crc = iscsit_do_crypto_hash_sg(conn->conn_tx_hash,\r\ncmd, datain->offset,\r\ndatain->length,\r\ncmd->padding,\r\ncmd->pad_bytes);\r\niov[iov_count].iov_base = &cmd->data_crc;\r\niov[iov_count++].iov_len = ISCSI_CRC_LEN;\r\ntx_size += ISCSI_CRC_LEN;\r\npr_debug("Attached CRC32C DataDigest %d bytes, crc 0x%08x\n",\r\ndatain->length + cmd->padding, cmd->data_crc);\r\n}\r\ncmd->iov_data_count = iov_count;\r\ncmd->tx_size = tx_size;\r\nret = iscsit_fe_sendpage_sg(cmd, conn);\r\niscsit_unmap_iovec(cmd);\r\nif (ret < 0) {\r\niscsit_tx_thread_wait_for_tcp(conn);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int iscsit_xmit_pdu(struct iscsi_conn *conn, struct iscsi_cmd *cmd,\r\nstruct iscsi_datain_req *dr, const void *buf,\r\nu32 buf_len)\r\n{\r\nif (dr)\r\nreturn iscsit_xmit_datain_pdu(conn, cmd, buf);\r\nelse\r\nreturn iscsit_xmit_nondatain_pdu(conn, cmd, buf, buf_len);\r\n}\r\nstatic enum target_prot_op iscsit_get_sup_prot_ops(struct iscsi_conn *conn)\r\n{\r\nreturn TARGET_PROT_NORMAL;\r\n}\r\nstatic int __init iscsi_target_init_module(void)\r\n{\r\nint ret = 0, size;\r\npr_debug("iSCSI-Target "ISCSIT_VERSION"\n");\r\niscsit_global = kzalloc(sizeof(*iscsit_global), GFP_KERNEL);\r\nif (!iscsit_global)\r\nreturn -1;\r\nspin_lock_init(&iscsit_global->ts_bitmap_lock);\r\nmutex_init(&auth_id_lock);\r\nspin_lock_init(&sess_idr_lock);\r\nidr_init(&tiqn_idr);\r\nidr_init(&sess_idr);\r\nret = target_register_template(&iscsi_ops);\r\nif (ret)\r\ngoto out;\r\nsize = BITS_TO_LONGS(ISCSIT_BITMAP_BITS) * sizeof(long);\r\niscsit_global->ts_bitmap = vzalloc(size);\r\nif (!iscsit_global->ts_bitmap)\r\ngoto configfs_out;\r\nlio_qr_cache = kmem_cache_create("lio_qr_cache",\r\nsizeof(struct iscsi_queue_req),\r\n__alignof__(struct iscsi_queue_req), 0, NULL);\r\nif (!lio_qr_cache) {\r\npr_err("nable to kmem_cache_create() for"\r\n" lio_qr_cache\n");\r\ngoto bitmap_out;\r\n}\r\nlio_dr_cache = kmem_cache_create("lio_dr_cache",\r\nsizeof(struct iscsi_datain_req),\r\n__alignof__(struct iscsi_datain_req), 0, NULL);\r\nif (!lio_dr_cache) {\r\npr_err("Unable to kmem_cache_create() for"\r\n" lio_dr_cache\n");\r\ngoto qr_out;\r\n}\r\nlio_ooo_cache = kmem_cache_create("lio_ooo_cache",\r\nsizeof(struct iscsi_ooo_cmdsn),\r\n__alignof__(struct iscsi_ooo_cmdsn), 0, NULL);\r\nif (!lio_ooo_cache) {\r\npr_err("Unable to kmem_cache_create() for"\r\n" lio_ooo_cache\n");\r\ngoto dr_out;\r\n}\r\nlio_r2t_cache = kmem_cache_create("lio_r2t_cache",\r\nsizeof(struct iscsi_r2t), __alignof__(struct iscsi_r2t),\r\n0, NULL);\r\nif (!lio_r2t_cache) {\r\npr_err("Unable to kmem_cache_create() for"\r\n" lio_r2t_cache\n");\r\ngoto ooo_out;\r\n}\r\niscsit_register_transport(&iscsi_target_transport);\r\nif (iscsit_load_discovery_tpg() < 0)\r\ngoto r2t_out;\r\nreturn ret;\r\nr2t_out:\r\niscsit_unregister_transport(&iscsi_target_transport);\r\nkmem_cache_destroy(lio_r2t_cache);\r\nooo_out:\r\nkmem_cache_destroy(lio_ooo_cache);\r\ndr_out:\r\nkmem_cache_destroy(lio_dr_cache);\r\nqr_out:\r\nkmem_cache_destroy(lio_qr_cache);\r\nbitmap_out:\r\nvfree(iscsit_global->ts_bitmap);\r\nconfigfs_out:\r\nif (iscsit_global->discovery_tpg)\r\niscsit_tpg_disable_portal_group(iscsit_global->discovery_tpg, 1);\r\ntarget_unregister_template(&iscsi_ops);\r\nout:\r\nkfree(iscsit_global);\r\nreturn -ENOMEM;\r\n}\r\nstatic void __exit iscsi_target_cleanup_module(void)\r\n{\r\niscsit_release_discovery_tpg();\r\niscsit_unregister_transport(&iscsi_target_transport);\r\nkmem_cache_destroy(lio_qr_cache);\r\nkmem_cache_destroy(lio_dr_cache);\r\nkmem_cache_destroy(lio_ooo_cache);\r\nkmem_cache_destroy(lio_r2t_cache);\r\nif (iscsit_global->discovery_tpg)\r\niscsit_tpg_disable_portal_group(iscsit_global->discovery_tpg, 1);\r\ntarget_unregister_template(&iscsi_ops);\r\nvfree(iscsit_global->ts_bitmap);\r\nkfree(iscsit_global);\r\n}\r\nint iscsit_add_reject(\r\nstruct iscsi_conn *conn,\r\nu8 reason,\r\nunsigned char *buf)\r\n{\r\nstruct iscsi_cmd *cmd;\r\ncmd = iscsit_allocate_cmd(conn, TASK_INTERRUPTIBLE);\r\nif (!cmd)\r\nreturn -1;\r\ncmd->iscsi_opcode = ISCSI_OP_REJECT;\r\ncmd->reject_reason = reason;\r\ncmd->buf_ptr = kmemdup(buf, ISCSI_HDR_LEN, GFP_KERNEL);\r\nif (!cmd->buf_ptr) {\r\npr_err("Unable to allocate memory for cmd->buf_ptr\n");\r\niscsit_free_cmd(cmd, false);\r\nreturn -1;\r\n}\r\nspin_lock_bh(&conn->cmd_lock);\r\nlist_add_tail(&cmd->i_conn_node, &conn->conn_cmd_list);\r\nspin_unlock_bh(&conn->cmd_lock);\r\ncmd->i_state = ISTATE_SEND_REJECT;\r\niscsit_add_cmd_to_response_queue(cmd, conn, cmd->i_state);\r\nreturn -1;\r\n}\r\nstatic int iscsit_add_reject_from_cmd(\r\nstruct iscsi_cmd *cmd,\r\nu8 reason,\r\nbool add_to_conn,\r\nunsigned char *buf)\r\n{\r\nstruct iscsi_conn *conn;\r\nif (!cmd->conn) {\r\npr_err("cmd->conn is NULL for ITT: 0x%08x\n",\r\ncmd->init_task_tag);\r\nreturn -1;\r\n}\r\nconn = cmd->conn;\r\ncmd->iscsi_opcode = ISCSI_OP_REJECT;\r\ncmd->reject_reason = reason;\r\ncmd->buf_ptr = kmemdup(buf, ISCSI_HDR_LEN, GFP_KERNEL);\r\nif (!cmd->buf_ptr) {\r\npr_err("Unable to allocate memory for cmd->buf_ptr\n");\r\niscsit_free_cmd(cmd, false);\r\nreturn -1;\r\n}\r\nif (add_to_conn) {\r\nspin_lock_bh(&conn->cmd_lock);\r\nlist_add_tail(&cmd->i_conn_node, &conn->conn_cmd_list);\r\nspin_unlock_bh(&conn->cmd_lock);\r\n}\r\ncmd->i_state = ISTATE_SEND_REJECT;\r\niscsit_add_cmd_to_response_queue(cmd, conn, cmd->i_state);\r\nif (cmd->se_cmd.se_tfo != NULL) {\r\npr_debug("iscsi reject: calling target_put_sess_cmd >>>>>>\n");\r\ntarget_put_sess_cmd(&cmd->se_cmd);\r\n}\r\nreturn -1;\r\n}\r\nstatic int iscsit_add_reject_cmd(struct iscsi_cmd *cmd, u8 reason,\r\nunsigned char *buf)\r\n{\r\nreturn iscsit_add_reject_from_cmd(cmd, reason, true, buf);\r\n}\r\nint iscsit_reject_cmd(struct iscsi_cmd *cmd, u8 reason, unsigned char *buf)\r\n{\r\nreturn iscsit_add_reject_from_cmd(cmd, reason, false, buf);\r\n}\r\nstatic int iscsit_map_iovec(\r\nstruct iscsi_cmd *cmd,\r\nstruct kvec *iov,\r\nu32 data_offset,\r\nu32 data_length)\r\n{\r\nu32 i = 0;\r\nstruct scatterlist *sg;\r\nunsigned int page_off;\r\nu32 ent = data_offset / PAGE_SIZE;\r\nif (ent >= cmd->se_cmd.t_data_nents) {\r\npr_err("Initial page entry out-of-bounds\n");\r\nreturn -1;\r\n}\r\nsg = &cmd->se_cmd.t_data_sg[ent];\r\npage_off = (data_offset % PAGE_SIZE);\r\ncmd->first_data_sg = sg;\r\ncmd->first_data_sg_off = page_off;\r\nwhile (data_length) {\r\nu32 cur_len = min_t(u32, data_length, sg->length - page_off);\r\niov[i].iov_base = kmap(sg_page(sg)) + sg->offset + page_off;\r\niov[i].iov_len = cur_len;\r\ndata_length -= cur_len;\r\npage_off = 0;\r\nsg = sg_next(sg);\r\ni++;\r\n}\r\ncmd->kmapped_nents = i;\r\nreturn i;\r\n}\r\nstatic void iscsit_unmap_iovec(struct iscsi_cmd *cmd)\r\n{\r\nu32 i;\r\nstruct scatterlist *sg;\r\nsg = cmd->first_data_sg;\r\nfor (i = 0; i < cmd->kmapped_nents; i++)\r\nkunmap(sg_page(&sg[i]));\r\n}\r\nstatic void iscsit_ack_from_expstatsn(struct iscsi_conn *conn, u32 exp_statsn)\r\n{\r\nLIST_HEAD(ack_list);\r\nstruct iscsi_cmd *cmd, *cmd_p;\r\nconn->exp_statsn = exp_statsn;\r\nif (conn->sess->sess_ops->RDMAExtensions)\r\nreturn;\r\nspin_lock_bh(&conn->cmd_lock);\r\nlist_for_each_entry_safe(cmd, cmd_p, &conn->conn_cmd_list, i_conn_node) {\r\nspin_lock(&cmd->istate_lock);\r\nif ((cmd->i_state == ISTATE_SENT_STATUS) &&\r\niscsi_sna_lt(cmd->stat_sn, exp_statsn)) {\r\ncmd->i_state = ISTATE_REMOVE;\r\nspin_unlock(&cmd->istate_lock);\r\nlist_move_tail(&cmd->i_conn_node, &ack_list);\r\ncontinue;\r\n}\r\nspin_unlock(&cmd->istate_lock);\r\n}\r\nspin_unlock_bh(&conn->cmd_lock);\r\nlist_for_each_entry_safe(cmd, cmd_p, &ack_list, i_conn_node) {\r\nlist_del_init(&cmd->i_conn_node);\r\niscsit_free_cmd(cmd, false);\r\n}\r\n}\r\nstatic int iscsit_allocate_iovecs(struct iscsi_cmd *cmd)\r\n{\r\nu32 iov_count = max(1UL, DIV_ROUND_UP(cmd->se_cmd.data_length, PAGE_SIZE));\r\niov_count += ISCSI_IOV_DATA_BUFFER;\r\ncmd->iov_data = kcalloc(iov_count, sizeof(*cmd->iov_data), GFP_KERNEL);\r\nif (!cmd->iov_data)\r\nreturn -ENOMEM;\r\ncmd->orig_iov_data_count = iov_count;\r\nreturn 0;\r\n}\r\nint iscsit_setup_scsi_cmd(struct iscsi_conn *conn, struct iscsi_cmd *cmd,\r\nunsigned char *buf)\r\n{\r\nint data_direction, payload_length;\r\nstruct iscsi_scsi_req *hdr;\r\nint iscsi_task_attr;\r\nint sam_task_attr;\r\natomic_long_inc(&conn->sess->cmd_pdus);\r\nhdr = (struct iscsi_scsi_req *) buf;\r\npayload_length = ntoh24(hdr->dlength);\r\nif (!(hdr->flags & ISCSI_FLAG_CMD_WRITE) &&\r\n!(hdr->flags & ISCSI_FLAG_CMD_FINAL)) {\r\npr_err("ISCSI_FLAG_CMD_WRITE & ISCSI_FLAG_CMD_FINAL"\r\n" not set. Bad iSCSI Initiator.\n");\r\nreturn iscsit_add_reject_cmd(cmd,\r\nISCSI_REASON_BOOKMARK_INVALID, buf);\r\n}\r\nif (((hdr->flags & ISCSI_FLAG_CMD_READ) ||\r\n(hdr->flags & ISCSI_FLAG_CMD_WRITE)) && !hdr->data_length) {\r\nhdr->flags &= ~ISCSI_FLAG_CMD_READ;\r\nhdr->flags &= ~ISCSI_FLAG_CMD_WRITE;\r\npr_warn("ISCSI_FLAG_CMD_READ or ISCSI_FLAG_CMD_WRITE"\r\n" set when Expected Data Transfer Length is 0 for"\r\n" CDB: 0x%02x, Fixing up flags\n", hdr->cdb[0]);\r\n}\r\nif (!(hdr->flags & ISCSI_FLAG_CMD_READ) &&\r\n!(hdr->flags & ISCSI_FLAG_CMD_WRITE) && (hdr->data_length != 0)) {\r\npr_err("ISCSI_FLAG_CMD_READ and/or ISCSI_FLAG_CMD_WRITE"\r\n" MUST be set if Expected Data Transfer Length is not 0."\r\n" Bad iSCSI Initiator\n");\r\nreturn iscsit_add_reject_cmd(cmd,\r\nISCSI_REASON_BOOKMARK_INVALID, buf);\r\n}\r\nif ((hdr->flags & ISCSI_FLAG_CMD_READ) &&\r\n(hdr->flags & ISCSI_FLAG_CMD_WRITE)) {\r\npr_err("Bidirectional operations not supported!\n");\r\nreturn iscsit_add_reject_cmd(cmd,\r\nISCSI_REASON_BOOKMARK_INVALID, buf);\r\n}\r\nif (hdr->opcode & ISCSI_OP_IMMEDIATE) {\r\npr_err("Illegally set Immediate Bit in iSCSI Initiator"\r\n" Scsi Command PDU.\n");\r\nreturn iscsit_add_reject_cmd(cmd,\r\nISCSI_REASON_BOOKMARK_INVALID, buf);\r\n}\r\nif (payload_length && !conn->sess->sess_ops->ImmediateData) {\r\npr_err("ImmediateData=No but DataSegmentLength=%u,"\r\n" protocol error.\n", payload_length);\r\nreturn iscsit_add_reject_cmd(cmd,\r\nISCSI_REASON_PROTOCOL_ERROR, buf);\r\n}\r\nif ((be32_to_cpu(hdr->data_length) == payload_length) &&\r\n(!(hdr->flags & ISCSI_FLAG_CMD_FINAL))) {\r\npr_err("Expected Data Transfer Length and Length of"\r\n" Immediate Data are the same, but ISCSI_FLAG_CMD_FINAL"\r\n" bit is not set protocol error\n");\r\nreturn iscsit_add_reject_cmd(cmd,\r\nISCSI_REASON_PROTOCOL_ERROR, buf);\r\n}\r\nif (payload_length > be32_to_cpu(hdr->data_length)) {\r\npr_err("DataSegmentLength: %u is greater than"\r\n" EDTL: %u, protocol error.\n", payload_length,\r\nhdr->data_length);\r\nreturn iscsit_add_reject_cmd(cmd,\r\nISCSI_REASON_PROTOCOL_ERROR, buf);\r\n}\r\nif (payload_length > conn->conn_ops->MaxXmitDataSegmentLength) {\r\npr_err("DataSegmentLength: %u is greater than"\r\n" MaxXmitDataSegmentLength: %u, protocol error.\n",\r\npayload_length, conn->conn_ops->MaxXmitDataSegmentLength);\r\nreturn iscsit_add_reject_cmd(cmd,\r\nISCSI_REASON_PROTOCOL_ERROR, buf);\r\n}\r\nif (payload_length > conn->sess->sess_ops->FirstBurstLength) {\r\npr_err("DataSegmentLength: %u is greater than"\r\n" FirstBurstLength: %u, protocol error.\n",\r\npayload_length, conn->sess->sess_ops->FirstBurstLength);\r\nreturn iscsit_add_reject_cmd(cmd,\r\nISCSI_REASON_BOOKMARK_INVALID, buf);\r\n}\r\ndata_direction = (hdr->flags & ISCSI_FLAG_CMD_WRITE) ? DMA_TO_DEVICE :\r\n(hdr->flags & ISCSI_FLAG_CMD_READ) ? DMA_FROM_DEVICE :\r\nDMA_NONE;\r\ncmd->data_direction = data_direction;\r\niscsi_task_attr = hdr->flags & ISCSI_FLAG_CMD_ATTR_MASK;\r\nif ((iscsi_task_attr == ISCSI_ATTR_UNTAGGED) ||\r\n(iscsi_task_attr == ISCSI_ATTR_SIMPLE))\r\nsam_task_attr = TCM_SIMPLE_TAG;\r\nelse if (iscsi_task_attr == ISCSI_ATTR_ORDERED)\r\nsam_task_attr = TCM_ORDERED_TAG;\r\nelse if (iscsi_task_attr == ISCSI_ATTR_HEAD_OF_QUEUE)\r\nsam_task_attr = TCM_HEAD_TAG;\r\nelse if (iscsi_task_attr == ISCSI_ATTR_ACA)\r\nsam_task_attr = TCM_ACA_TAG;\r\nelse {\r\npr_debug("Unknown iSCSI Task Attribute: 0x%02x, using"\r\n" TCM_SIMPLE_TAG\n", iscsi_task_attr);\r\nsam_task_attr = TCM_SIMPLE_TAG;\r\n}\r\ncmd->iscsi_opcode = ISCSI_OP_SCSI_CMD;\r\ncmd->i_state = ISTATE_NEW_CMD;\r\ncmd->immediate_cmd = ((hdr->opcode & ISCSI_OP_IMMEDIATE) ? 1 : 0);\r\ncmd->immediate_data = (payload_length) ? 1 : 0;\r\ncmd->unsolicited_data = ((!(hdr->flags & ISCSI_FLAG_CMD_FINAL) &&\r\n(hdr->flags & ISCSI_FLAG_CMD_WRITE)) ? 1 : 0);\r\nif (cmd->unsolicited_data)\r\ncmd->cmd_flags |= ICF_NON_IMMEDIATE_UNSOLICITED_DATA;\r\nconn->sess->init_task_tag = cmd->init_task_tag = hdr->itt;\r\nif (hdr->flags & ISCSI_FLAG_CMD_READ)\r\ncmd->targ_xfer_tag = session_get_next_ttt(conn->sess);\r\nelse\r\ncmd->targ_xfer_tag = 0xFFFFFFFF;\r\ncmd->cmd_sn = be32_to_cpu(hdr->cmdsn);\r\ncmd->exp_stat_sn = be32_to_cpu(hdr->exp_statsn);\r\ncmd->first_burst_len = payload_length;\r\nif (!conn->sess->sess_ops->RDMAExtensions &&\r\ncmd->data_direction == DMA_FROM_DEVICE) {\r\nstruct iscsi_datain_req *dr;\r\ndr = iscsit_allocate_datain_req();\r\nif (!dr)\r\nreturn iscsit_add_reject_cmd(cmd,\r\nISCSI_REASON_BOOKMARK_NO_RESOURCES, buf);\r\niscsit_attach_datain_req(cmd, dr);\r\n}\r\ntransport_init_se_cmd(&cmd->se_cmd, &iscsi_ops,\r\nconn->sess->se_sess, be32_to_cpu(hdr->data_length),\r\ncmd->data_direction, sam_task_attr,\r\ncmd->sense_buffer + 2);\r\npr_debug("Got SCSI Command, ITT: 0x%08x, CmdSN: 0x%08x,"\r\n" ExpXferLen: %u, Length: %u, CID: %hu\n", hdr->itt,\r\nhdr->cmdsn, be32_to_cpu(hdr->data_length), payload_length,\r\nconn->cid);\r\ntarget_get_sess_cmd(&cmd->se_cmd, true);\r\ncmd->sense_reason = transport_lookup_cmd_lun(&cmd->se_cmd,\r\nscsilun_to_int(&hdr->lun));\r\nif (cmd->sense_reason)\r\ngoto attach_cmd;\r\ncmd->se_cmd.tag = (__force u32)cmd->init_task_tag;\r\ncmd->sense_reason = target_setup_cmd_from_cdb(&cmd->se_cmd, hdr->cdb);\r\nif (cmd->sense_reason) {\r\nif (cmd->sense_reason == TCM_OUT_OF_RESOURCES) {\r\nreturn iscsit_add_reject_cmd(cmd,\r\nISCSI_REASON_BOOKMARK_NO_RESOURCES, buf);\r\n}\r\ngoto attach_cmd;\r\n}\r\nif (iscsit_build_pdu_and_seq_lists(cmd, payload_length) < 0) {\r\nreturn iscsit_add_reject_cmd(cmd,\r\nISCSI_REASON_BOOKMARK_NO_RESOURCES, buf);\r\n}\r\nattach_cmd:\r\nspin_lock_bh(&conn->cmd_lock);\r\nlist_add_tail(&cmd->i_conn_node, &conn->conn_cmd_list);\r\nspin_unlock_bh(&conn->cmd_lock);\r\ncore_alua_check_nonop_delay(&cmd->se_cmd);\r\nreturn 0;\r\n}\r\nvoid iscsit_set_unsoliticed_dataout(struct iscsi_cmd *cmd)\r\n{\r\niscsit_set_dataout_sequence_values(cmd);\r\nspin_lock_bh(&cmd->dataout_timeout_lock);\r\niscsit_start_dataout_timer(cmd, cmd->conn);\r\nspin_unlock_bh(&cmd->dataout_timeout_lock);\r\n}\r\nint iscsit_process_scsi_cmd(struct iscsi_conn *conn, struct iscsi_cmd *cmd,\r\nstruct iscsi_scsi_req *hdr)\r\n{\r\nint cmdsn_ret = 0;\r\nif (!cmd->immediate_data) {\r\ncmdsn_ret = iscsit_sequence_cmd(conn, cmd,\r\n(unsigned char *)hdr, hdr->cmdsn);\r\nif (cmdsn_ret == CMDSN_ERROR_CANNOT_RECOVER)\r\nreturn -1;\r\nelse if (cmdsn_ret == CMDSN_LOWER_THAN_EXP) {\r\ntarget_put_sess_cmd(&cmd->se_cmd);\r\nreturn 0;\r\n}\r\n}\r\niscsit_ack_from_expstatsn(conn, be32_to_cpu(hdr->exp_statsn));\r\nif (!cmd->immediate_data) {\r\nif (!cmd->sense_reason && cmd->unsolicited_data)\r\niscsit_set_unsoliticed_dataout(cmd);\r\nif (!cmd->sense_reason)\r\nreturn 0;\r\ntarget_put_sess_cmd(&cmd->se_cmd);\r\nreturn 0;\r\n}\r\nif (cmd->sense_reason)\r\nreturn 1;\r\ncmd->sense_reason = transport_generic_new_cmd(&cmd->se_cmd);\r\nif (cmd->sense_reason)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int\r\niscsit_get_immediate_data(struct iscsi_cmd *cmd, struct iscsi_scsi_req *hdr,\r\nbool dump_payload)\r\n{\r\nint cmdsn_ret = 0, immed_ret = IMMEDIATE_DATA_NORMAL_OPERATION;\r\nif (dump_payload)\r\ngoto after_immediate_data;\r\nif (cmd->first_burst_len > cmd->se_cmd.data_length) {\r\ncmd->sense_reason = TCM_INVALID_CDB_FIELD;\r\ngoto after_immediate_data;\r\n}\r\nimmed_ret = iscsit_handle_immediate_data(cmd, hdr,\r\ncmd->first_burst_len);\r\nafter_immediate_data:\r\nif (immed_ret == IMMEDIATE_DATA_NORMAL_OPERATION) {\r\ncmdsn_ret = iscsit_sequence_cmd(cmd->conn, cmd,\r\n(unsigned char *)hdr, hdr->cmdsn);\r\nif (cmdsn_ret == CMDSN_ERROR_CANNOT_RECOVER)\r\nreturn -1;\r\nif (cmd->sense_reason || cmdsn_ret == CMDSN_LOWER_THAN_EXP) {\r\nint rc;\r\nrc = iscsit_dump_data_payload(cmd->conn,\r\ncmd->first_burst_len, 1);\r\ntarget_put_sess_cmd(&cmd->se_cmd);\r\nreturn rc;\r\n} else if (cmd->unsolicited_data)\r\niscsit_set_unsoliticed_dataout(cmd);\r\n} else if (immed_ret == IMMEDIATE_DATA_ERL1_CRC_FAILURE) {\r\ncmd->i_state = ISTATE_REMOVE;\r\niscsit_add_cmd_to_immediate_queue(cmd, cmd->conn, cmd->i_state);\r\n} else\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int\r\niscsit_handle_scsi_cmd(struct iscsi_conn *conn, struct iscsi_cmd *cmd,\r\nunsigned char *buf)\r\n{\r\nstruct iscsi_scsi_req *hdr = (struct iscsi_scsi_req *)buf;\r\nint rc, immed_data;\r\nbool dump_payload = false;\r\nrc = iscsit_setup_scsi_cmd(conn, cmd, buf);\r\nif (rc < 0)\r\nreturn 0;\r\nif (iscsit_allocate_iovecs(cmd) < 0) {\r\nreturn iscsit_reject_cmd(cmd,\r\nISCSI_REASON_BOOKMARK_NO_RESOURCES, buf);\r\n}\r\nimmed_data = cmd->immediate_data;\r\nrc = iscsit_process_scsi_cmd(conn, cmd, hdr);\r\nif (rc < 0)\r\nreturn rc;\r\nelse if (rc > 0)\r\ndump_payload = true;\r\nif (!immed_data)\r\nreturn 0;\r\nreturn iscsit_get_immediate_data(cmd, hdr, dump_payload);\r\n}\r\nstatic u32 iscsit_do_crypto_hash_sg(\r\nstruct ahash_request *hash,\r\nstruct iscsi_cmd *cmd,\r\nu32 data_offset,\r\nu32 data_length,\r\nu32 padding,\r\nu8 *pad_bytes)\r\n{\r\nu32 data_crc;\r\nstruct scatterlist *sg;\r\nunsigned int page_off;\r\ncrypto_ahash_init(hash);\r\nsg = cmd->first_data_sg;\r\npage_off = cmd->first_data_sg_off;\r\nwhile (data_length) {\r\nu32 cur_len = min_t(u32, data_length, (sg->length - page_off));\r\nahash_request_set_crypt(hash, sg, NULL, cur_len);\r\ncrypto_ahash_update(hash);\r\ndata_length -= cur_len;\r\npage_off = 0;\r\nsg = sg_next(sg);\r\n}\r\nif (padding) {\r\nstruct scatterlist pad_sg;\r\nsg_init_one(&pad_sg, pad_bytes, padding);\r\nahash_request_set_crypt(hash, &pad_sg, (u8 *)&data_crc,\r\npadding);\r\ncrypto_ahash_finup(hash);\r\n} else {\r\nahash_request_set_crypt(hash, NULL, (u8 *)&data_crc, 0);\r\ncrypto_ahash_final(hash);\r\n}\r\nreturn data_crc;\r\n}\r\nstatic void iscsit_do_crypto_hash_buf(\r\nstruct ahash_request *hash,\r\nconst void *buf,\r\nu32 payload_length,\r\nu32 padding,\r\nu8 *pad_bytes,\r\nu8 *data_crc)\r\n{\r\nstruct scatterlist sg[2];\r\nsg_init_table(sg, ARRAY_SIZE(sg));\r\nsg_set_buf(sg, buf, payload_length);\r\nsg_set_buf(sg + 1, pad_bytes, padding);\r\nahash_request_set_crypt(hash, sg, data_crc, payload_length + padding);\r\ncrypto_ahash_digest(hash);\r\n}\r\nint\r\n__iscsit_check_dataout_hdr(struct iscsi_conn *conn, void *buf,\r\nstruct iscsi_cmd *cmd, u32 payload_length,\r\nbool *success)\r\n{\r\nstruct iscsi_data *hdr = buf;\r\nstruct se_cmd *se_cmd;\r\nint rc;\r\natomic_long_add(payload_length, &conn->sess->rx_data_octets);\r\npr_debug("Got DataOut ITT: 0x%08x, TTT: 0x%08x,"\r\n" DataSN: 0x%08x, Offset: %u, Length: %u, CID: %hu\n",\r\nhdr->itt, hdr->ttt, hdr->datasn, ntohl(hdr->offset),\r\npayload_length, conn->cid);\r\nif (cmd->cmd_flags & ICF_GOT_LAST_DATAOUT) {\r\npr_err("Command ITT: 0x%08x received DataOUT after"\r\n" last DataOUT received, dumping payload\n",\r\ncmd->init_task_tag);\r\nreturn iscsit_dump_data_payload(conn, payload_length, 1);\r\n}\r\nif (cmd->data_direction != DMA_TO_DEVICE) {\r\npr_err("Command ITT: 0x%08x received DataOUT for a"\r\n" NON-WRITE command.\n", cmd->init_task_tag);\r\nreturn iscsit_dump_data_payload(conn, payload_length, 1);\r\n}\r\nse_cmd = &cmd->se_cmd;\r\niscsit_mod_dataout_timer(cmd);\r\nif ((be32_to_cpu(hdr->offset) + payload_length) > cmd->se_cmd.data_length) {\r\npr_err("DataOut Offset: %u, Length %u greater than"\r\n" iSCSI Command EDTL %u, protocol error.\n",\r\nhdr->offset, payload_length, cmd->se_cmd.data_length);\r\nreturn iscsit_reject_cmd(cmd, ISCSI_REASON_BOOKMARK_INVALID, buf);\r\n}\r\nif (cmd->unsolicited_data) {\r\nint dump_unsolicited_data = 0;\r\nif (conn->sess->sess_ops->InitialR2T) {\r\npr_err("Received unexpected unsolicited data"\r\n" while InitialR2T=Yes, protocol error.\n");\r\ntransport_send_check_condition_and_sense(&cmd->se_cmd,\r\nTCM_UNEXPECTED_UNSOLICITED_DATA, 0);\r\nreturn -1;\r\n}\r\nWARN_ON(se_cmd->t_state != TRANSPORT_WRITE_PENDING);\r\nif (!(se_cmd->se_cmd_flags & SCF_SUPPORTED_SAM_OPCODE))\r\ndump_unsolicited_data = 1;\r\nif (dump_unsolicited_data) {\r\nif (hdr->flags & ISCSI_FLAG_CMD_FINAL)\r\niscsit_stop_dataout_timer(cmd);\r\ntransport_check_aborted_status(se_cmd,\r\n(hdr->flags & ISCSI_FLAG_CMD_FINAL));\r\nreturn iscsit_dump_data_payload(conn, payload_length, 1);\r\n}\r\n} else {\r\nif (se_cmd->transport_state & CMD_T_ABORTED) {\r\nif (hdr->flags & ISCSI_FLAG_CMD_FINAL)\r\nif (--cmd->outstanding_r2ts < 1) {\r\niscsit_stop_dataout_timer(cmd);\r\ntransport_check_aborted_status(\r\nse_cmd, 1);\r\n}\r\nreturn iscsit_dump_data_payload(conn, payload_length, 1);\r\n}\r\n}\r\nrc = iscsit_check_pre_dataout(cmd, buf);\r\nif (rc == DATAOUT_WITHIN_COMMAND_RECOVERY)\r\nreturn 0;\r\nelse if (rc == DATAOUT_CANNOT_RECOVER)\r\nreturn -1;\r\n*success = true;\r\nreturn 0;\r\n}\r\nint\r\niscsit_check_dataout_hdr(struct iscsi_conn *conn, void *buf,\r\nstruct iscsi_cmd **out_cmd)\r\n{\r\nstruct iscsi_data *hdr = buf;\r\nstruct iscsi_cmd *cmd;\r\nu32 payload_length = ntoh24(hdr->dlength);\r\nint rc;\r\nbool success = false;\r\nif (!payload_length) {\r\npr_warn_ratelimited("DataOUT payload is ZERO, ignoring.\n");\r\nreturn 0;\r\n}\r\nif (payload_length > conn->conn_ops->MaxXmitDataSegmentLength) {\r\npr_err_ratelimited("DataSegmentLength: %u is greater than"\r\n" MaxXmitDataSegmentLength: %u\n", payload_length,\r\nconn->conn_ops->MaxXmitDataSegmentLength);\r\nreturn iscsit_add_reject(conn, ISCSI_REASON_PROTOCOL_ERROR, buf);\r\n}\r\ncmd = iscsit_find_cmd_from_itt_or_dump(conn, hdr->itt, payload_length);\r\nif (!cmd)\r\nreturn 0;\r\nrc = __iscsit_check_dataout_hdr(conn, buf, cmd, payload_length, &success);\r\nif (success)\r\n*out_cmd = cmd;\r\nreturn rc;\r\n}\r\nstatic int\r\niscsit_get_dataout(struct iscsi_conn *conn, struct iscsi_cmd *cmd,\r\nstruct iscsi_data *hdr)\r\n{\r\nstruct kvec *iov;\r\nu32 checksum, iov_count = 0, padding = 0, rx_got = 0, rx_size = 0;\r\nu32 payload_length = ntoh24(hdr->dlength);\r\nint iov_ret, data_crc_failed = 0;\r\nrx_size += payload_length;\r\niov = &cmd->iov_data[0];\r\niov_ret = iscsit_map_iovec(cmd, iov, be32_to_cpu(hdr->offset),\r\npayload_length);\r\nif (iov_ret < 0)\r\nreturn -1;\r\niov_count += iov_ret;\r\npadding = ((-payload_length) & 3);\r\nif (padding != 0) {\r\niov[iov_count].iov_base = cmd->pad_bytes;\r\niov[iov_count++].iov_len = padding;\r\nrx_size += padding;\r\npr_debug("Receiving %u padding bytes.\n", padding);\r\n}\r\nif (conn->conn_ops->DataDigest) {\r\niov[iov_count].iov_base = &checksum;\r\niov[iov_count++].iov_len = ISCSI_CRC_LEN;\r\nrx_size += ISCSI_CRC_LEN;\r\n}\r\nrx_got = rx_data(conn, &cmd->iov_data[0], iov_count, rx_size);\r\niscsit_unmap_iovec(cmd);\r\nif (rx_got != rx_size)\r\nreturn -1;\r\nif (conn->conn_ops->DataDigest) {\r\nu32 data_crc;\r\ndata_crc = iscsit_do_crypto_hash_sg(conn->conn_rx_hash, cmd,\r\nbe32_to_cpu(hdr->offset),\r\npayload_length, padding,\r\ncmd->pad_bytes);\r\nif (checksum != data_crc) {\r\npr_err("ITT: 0x%08x, Offset: %u, Length: %u,"\r\n" DataSN: 0x%08x, CRC32C DataDigest 0x%08x"\r\n" does not match computed 0x%08x\n",\r\nhdr->itt, hdr->offset, payload_length,\r\nhdr->datasn, checksum, data_crc);\r\ndata_crc_failed = 1;\r\n} else {\r\npr_debug("Got CRC32C DataDigest 0x%08x for"\r\n" %u bytes of Data Out\n", checksum,\r\npayload_length);\r\n}\r\n}\r\nreturn data_crc_failed;\r\n}\r\nint\r\niscsit_check_dataout_payload(struct iscsi_cmd *cmd, struct iscsi_data *hdr,\r\nbool data_crc_failed)\r\n{\r\nstruct iscsi_conn *conn = cmd->conn;\r\nint rc, ooo_cmdsn;\r\nrc = iscsit_check_post_dataout(cmd, (unsigned char *)hdr, data_crc_failed);\r\nif ((rc == DATAOUT_NORMAL) || (rc == DATAOUT_WITHIN_COMMAND_RECOVERY))\r\nreturn 0;\r\nelse if (rc == DATAOUT_SEND_R2T) {\r\niscsit_set_dataout_sequence_values(cmd);\r\nconn->conn_transport->iscsit_get_dataout(conn, cmd, false);\r\n} else if (rc == DATAOUT_SEND_TO_TRANSPORT) {\r\nspin_lock_bh(&cmd->istate_lock);\r\nooo_cmdsn = (cmd->cmd_flags & ICF_OOO_CMDSN);\r\ncmd->cmd_flags |= ICF_GOT_LAST_DATAOUT;\r\ncmd->i_state = ISTATE_RECEIVED_LAST_DATAOUT;\r\nspin_unlock_bh(&cmd->istate_lock);\r\niscsit_stop_dataout_timer(cmd);\r\nif (ooo_cmdsn)\r\nreturn 0;\r\ntarget_execute_cmd(&cmd->se_cmd);\r\nreturn 0;\r\n} else\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int iscsit_handle_data_out(struct iscsi_conn *conn, unsigned char *buf)\r\n{\r\nstruct iscsi_cmd *cmd = NULL;\r\nstruct iscsi_data *hdr = (struct iscsi_data *)buf;\r\nint rc;\r\nbool data_crc_failed = false;\r\nrc = iscsit_check_dataout_hdr(conn, buf, &cmd);\r\nif (rc < 0)\r\nreturn 0;\r\nelse if (!cmd)\r\nreturn 0;\r\nrc = iscsit_get_dataout(conn, cmd, hdr);\r\nif (rc < 0)\r\nreturn rc;\r\nelse if (rc > 0)\r\ndata_crc_failed = true;\r\nreturn iscsit_check_dataout_payload(cmd, hdr, data_crc_failed);\r\n}\r\nint iscsit_setup_nop_out(struct iscsi_conn *conn, struct iscsi_cmd *cmd,\r\nstruct iscsi_nopout *hdr)\r\n{\r\nu32 payload_length = ntoh24(hdr->dlength);\r\nif (!(hdr->flags & ISCSI_FLAG_CMD_FINAL)) {\r\npr_err("NopOUT Flag's, Left Most Bit not set, protocol error.\n");\r\nif (!cmd)\r\nreturn iscsit_add_reject(conn, ISCSI_REASON_PROTOCOL_ERROR,\r\n(unsigned char *)hdr);\r\nreturn iscsit_reject_cmd(cmd, ISCSI_REASON_PROTOCOL_ERROR,\r\n(unsigned char *)hdr);\r\n}\r\nif (hdr->itt == RESERVED_ITT && !(hdr->opcode & ISCSI_OP_IMMEDIATE)) {\r\npr_err("NOPOUT ITT is reserved, but Immediate Bit is"\r\n" not set, protocol error.\n");\r\nif (!cmd)\r\nreturn iscsit_add_reject(conn, ISCSI_REASON_PROTOCOL_ERROR,\r\n(unsigned char *)hdr);\r\nreturn iscsit_reject_cmd(cmd, ISCSI_REASON_PROTOCOL_ERROR,\r\n(unsigned char *)hdr);\r\n}\r\nif (payload_length > conn->conn_ops->MaxXmitDataSegmentLength) {\r\npr_err("NOPOUT Ping Data DataSegmentLength: %u is"\r\n" greater than MaxXmitDataSegmentLength: %u, protocol"\r\n" error.\n", payload_length,\r\nconn->conn_ops->MaxXmitDataSegmentLength);\r\nif (!cmd)\r\nreturn iscsit_add_reject(conn, ISCSI_REASON_PROTOCOL_ERROR,\r\n(unsigned char *)hdr);\r\nreturn iscsit_reject_cmd(cmd, ISCSI_REASON_PROTOCOL_ERROR,\r\n(unsigned char *)hdr);\r\n}\r\npr_debug("Got NOPOUT Ping %s ITT: 0x%08x, TTT: 0x%08x,"\r\n" CmdSN: 0x%08x, ExpStatSN: 0x%08x, Length: %u\n",\r\nhdr->itt == RESERVED_ITT ? "Response" : "Request",\r\nhdr->itt, hdr->ttt, hdr->cmdsn, hdr->exp_statsn,\r\npayload_length);\r\nif (hdr->ttt == cpu_to_be32(0xFFFFFFFF)) {\r\ncmd->iscsi_opcode = ISCSI_OP_NOOP_OUT;\r\ncmd->i_state = ISTATE_SEND_NOPIN;\r\ncmd->immediate_cmd = ((hdr->opcode & ISCSI_OP_IMMEDIATE) ?\r\n1 : 0);\r\nconn->sess->init_task_tag = cmd->init_task_tag = hdr->itt;\r\ncmd->targ_xfer_tag = 0xFFFFFFFF;\r\ncmd->cmd_sn = be32_to_cpu(hdr->cmdsn);\r\ncmd->exp_stat_sn = be32_to_cpu(hdr->exp_statsn);\r\ncmd->data_direction = DMA_NONE;\r\n}\r\nreturn 0;\r\n}\r\nint iscsit_process_nop_out(struct iscsi_conn *conn, struct iscsi_cmd *cmd,\r\nstruct iscsi_nopout *hdr)\r\n{\r\nstruct iscsi_cmd *cmd_p = NULL;\r\nint cmdsn_ret = 0;\r\nif (hdr->itt != RESERVED_ITT) {\r\nif (!cmd)\r\nreturn iscsit_add_reject(conn, ISCSI_REASON_PROTOCOL_ERROR,\r\n(unsigned char *)hdr);\r\nspin_lock_bh(&conn->cmd_lock);\r\nlist_add_tail(&cmd->i_conn_node, &conn->conn_cmd_list);\r\nspin_unlock_bh(&conn->cmd_lock);\r\niscsit_ack_from_expstatsn(conn, be32_to_cpu(hdr->exp_statsn));\r\nif (hdr->opcode & ISCSI_OP_IMMEDIATE) {\r\niscsit_add_cmd_to_response_queue(cmd, conn,\r\ncmd->i_state);\r\nreturn 0;\r\n}\r\ncmdsn_ret = iscsit_sequence_cmd(conn, cmd,\r\n(unsigned char *)hdr, hdr->cmdsn);\r\nif (cmdsn_ret == CMDSN_LOWER_THAN_EXP)\r\nreturn 0;\r\nif (cmdsn_ret == CMDSN_ERROR_CANNOT_RECOVER)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nif (hdr->ttt != cpu_to_be32(0xFFFFFFFF)) {\r\ncmd_p = iscsit_find_cmd_from_ttt(conn, be32_to_cpu(hdr->ttt));\r\nif (!cmd_p)\r\nreturn -EINVAL;\r\niscsit_stop_nopin_response_timer(conn);\r\ncmd_p->i_state = ISTATE_REMOVE;\r\niscsit_add_cmd_to_immediate_queue(cmd_p, conn, cmd_p->i_state);\r\niscsit_start_nopin_timer(conn);\r\nreturn 0;\r\n}\r\nif (cmd)\r\niscsit_free_cmd(cmd, false);\r\nreturn 0;\r\n}\r\nstatic int iscsit_handle_nop_out(struct iscsi_conn *conn, struct iscsi_cmd *cmd,\r\nunsigned char *buf)\r\n{\r\nunsigned char *ping_data = NULL;\r\nstruct iscsi_nopout *hdr = (struct iscsi_nopout *)buf;\r\nstruct kvec *iov = NULL;\r\nu32 payload_length = ntoh24(hdr->dlength);\r\nint ret;\r\nret = iscsit_setup_nop_out(conn, cmd, hdr);\r\nif (ret < 0)\r\nreturn 0;\r\nif (payload_length && hdr->ttt == cpu_to_be32(0xFFFFFFFF)) {\r\nu32 checksum, data_crc, padding = 0;\r\nint niov = 0, rx_got, rx_size = payload_length;\r\nping_data = kzalloc(payload_length + 1, GFP_KERNEL);\r\nif (!ping_data) {\r\nret = -1;\r\ngoto out;\r\n}\r\niov = &cmd->iov_misc[0];\r\niov[niov].iov_base = ping_data;\r\niov[niov++].iov_len = payload_length;\r\npadding = ((-payload_length) & 3);\r\nif (padding != 0) {\r\npr_debug("Receiving %u additional bytes"\r\n" for padding.\n", padding);\r\niov[niov].iov_base = &cmd->pad_bytes;\r\niov[niov++].iov_len = padding;\r\nrx_size += padding;\r\n}\r\nif (conn->conn_ops->DataDigest) {\r\niov[niov].iov_base = &checksum;\r\niov[niov++].iov_len = ISCSI_CRC_LEN;\r\nrx_size += ISCSI_CRC_LEN;\r\n}\r\nrx_got = rx_data(conn, &cmd->iov_misc[0], niov, rx_size);\r\nif (rx_got != rx_size) {\r\nret = -1;\r\ngoto out;\r\n}\r\nif (conn->conn_ops->DataDigest) {\r\niscsit_do_crypto_hash_buf(conn->conn_rx_hash,\r\nping_data, payload_length,\r\npadding, cmd->pad_bytes,\r\n(u8 *)&data_crc);\r\nif (checksum != data_crc) {\r\npr_err("Ping data CRC32C DataDigest"\r\n" 0x%08x does not match computed 0x%08x\n",\r\nchecksum, data_crc);\r\nif (!conn->sess->sess_ops->ErrorRecoveryLevel) {\r\npr_err("Unable to recover from"\r\n" NOPOUT Ping DataCRC failure while in"\r\n" ERL=0.\n");\r\nret = -1;\r\ngoto out;\r\n} else {\r\npr_debug("Dropping NOPOUT"\r\n" Command CmdSN: 0x%08x due to"\r\n" DataCRC error.\n", hdr->cmdsn);\r\nret = 0;\r\ngoto out;\r\n}\r\n} else {\r\npr_debug("Got CRC32C DataDigest"\r\n" 0x%08x for %u bytes of ping data.\n",\r\nchecksum, payload_length);\r\n}\r\n}\r\nping_data[payload_length] = '\0';\r\ncmd->buf_ptr = ping_data;\r\ncmd->buf_ptr_size = payload_length;\r\npr_debug("Got %u bytes of NOPOUT ping"\r\n" data.\n", payload_length);\r\npr_debug("Ping Data: \"%s\"\n", ping_data);\r\n}\r\nreturn iscsit_process_nop_out(conn, cmd, hdr);\r\nout:\r\nif (cmd)\r\niscsit_free_cmd(cmd, false);\r\nkfree(ping_data);\r\nreturn ret;\r\n}\r\nstatic enum tcm_tmreq_table iscsit_convert_tmf(u8 iscsi_tmf)\r\n{\r\nswitch (iscsi_tmf) {\r\ncase ISCSI_TM_FUNC_ABORT_TASK:\r\nreturn TMR_ABORT_TASK;\r\ncase ISCSI_TM_FUNC_ABORT_TASK_SET:\r\nreturn TMR_ABORT_TASK_SET;\r\ncase ISCSI_TM_FUNC_CLEAR_ACA:\r\nreturn TMR_CLEAR_ACA;\r\ncase ISCSI_TM_FUNC_CLEAR_TASK_SET:\r\nreturn TMR_CLEAR_TASK_SET;\r\ncase ISCSI_TM_FUNC_LOGICAL_UNIT_RESET:\r\nreturn TMR_LUN_RESET;\r\ncase ISCSI_TM_FUNC_TARGET_WARM_RESET:\r\nreturn TMR_TARGET_WARM_RESET;\r\ncase ISCSI_TM_FUNC_TARGET_COLD_RESET:\r\nreturn TMR_TARGET_COLD_RESET;\r\ndefault:\r\nreturn TMR_UNKNOWN;\r\n}\r\n}\r\nint\r\niscsit_handle_task_mgt_cmd(struct iscsi_conn *conn, struct iscsi_cmd *cmd,\r\nunsigned char *buf)\r\n{\r\nstruct se_tmr_req *se_tmr;\r\nstruct iscsi_tmr_req *tmr_req;\r\nstruct iscsi_tm *hdr;\r\nint out_of_order_cmdsn = 0, ret;\r\nbool sess_ref = false;\r\nu8 function, tcm_function = TMR_UNKNOWN;\r\nhdr = (struct iscsi_tm *) buf;\r\nhdr->flags &= ~ISCSI_FLAG_CMD_FINAL;\r\nfunction = hdr->flags;\r\npr_debug("Got Task Management Request ITT: 0x%08x, CmdSN:"\r\n" 0x%08x, Function: 0x%02x, RefTaskTag: 0x%08x, RefCmdSN:"\r\n" 0x%08x, CID: %hu\n", hdr->itt, hdr->cmdsn, function,\r\nhdr->rtt, hdr->refcmdsn, conn->cid);\r\nif ((function != ISCSI_TM_FUNC_ABORT_TASK) &&\r\n((function != ISCSI_TM_FUNC_TASK_REASSIGN) &&\r\nhdr->rtt != RESERVED_ITT)) {\r\npr_err("RefTaskTag should be set to 0xFFFFFFFF.\n");\r\nhdr->rtt = RESERVED_ITT;\r\n}\r\nif ((function == ISCSI_TM_FUNC_TASK_REASSIGN) &&\r\n!(hdr->opcode & ISCSI_OP_IMMEDIATE)) {\r\npr_err("Task Management Request TASK_REASSIGN not"\r\n" issued as immediate command, bad iSCSI Initiator"\r\n"implementation\n");\r\nreturn iscsit_add_reject_cmd(cmd,\r\nISCSI_REASON_PROTOCOL_ERROR, buf);\r\n}\r\nif ((function != ISCSI_TM_FUNC_ABORT_TASK) &&\r\nbe32_to_cpu(hdr->refcmdsn) != ISCSI_RESERVED_TAG)\r\nhdr->refcmdsn = cpu_to_be32(ISCSI_RESERVED_TAG);\r\ncmd->data_direction = DMA_NONE;\r\ncmd->tmr_req = kzalloc(sizeof(*cmd->tmr_req), GFP_KERNEL);\r\nif (!cmd->tmr_req)\r\nreturn iscsit_add_reject_cmd(cmd,\r\nISCSI_REASON_BOOKMARK_NO_RESOURCES,\r\nbuf);\r\nif (function != ISCSI_TM_FUNC_TASK_REASSIGN) {\r\ntransport_init_se_cmd(&cmd->se_cmd, &iscsi_ops,\r\nconn->sess->se_sess, 0, DMA_NONE,\r\nTCM_SIMPLE_TAG, cmd->sense_buffer + 2);\r\ntarget_get_sess_cmd(&cmd->se_cmd, true);\r\nsess_ref = true;\r\ntcm_function = iscsit_convert_tmf(function);\r\nif (tcm_function == TMR_UNKNOWN) {\r\npr_err("Unknown iSCSI TMR Function:"\r\n" 0x%02x\n", function);\r\nreturn iscsit_add_reject_cmd(cmd,\r\nISCSI_REASON_BOOKMARK_NO_RESOURCES, buf);\r\n}\r\n}\r\nret = core_tmr_alloc_req(&cmd->se_cmd, cmd->tmr_req, tcm_function,\r\nGFP_KERNEL);\r\nif (ret < 0)\r\nreturn iscsit_add_reject_cmd(cmd,\r\nISCSI_REASON_BOOKMARK_NO_RESOURCES, buf);\r\ncmd->tmr_req->se_tmr_req = cmd->se_cmd.se_tmr_req;\r\ncmd->iscsi_opcode = ISCSI_OP_SCSI_TMFUNC;\r\ncmd->i_state = ISTATE_SEND_TASKMGTRSP;\r\ncmd->immediate_cmd = ((hdr->opcode & ISCSI_OP_IMMEDIATE) ? 1 : 0);\r\ncmd->init_task_tag = hdr->itt;\r\ncmd->targ_xfer_tag = 0xFFFFFFFF;\r\ncmd->cmd_sn = be32_to_cpu(hdr->cmdsn);\r\ncmd->exp_stat_sn = be32_to_cpu(hdr->exp_statsn);\r\nse_tmr = cmd->se_cmd.se_tmr_req;\r\ntmr_req = cmd->tmr_req;\r\nif (function != ISCSI_TM_FUNC_TASK_REASSIGN) {\r\nret = transport_lookup_tmr_lun(&cmd->se_cmd,\r\nscsilun_to_int(&hdr->lun));\r\nif (ret < 0) {\r\nse_tmr->response = ISCSI_TMF_RSP_NO_LUN;\r\ngoto attach;\r\n}\r\n}\r\nswitch (function) {\r\ncase ISCSI_TM_FUNC_ABORT_TASK:\r\nse_tmr->response = iscsit_tmr_abort_task(cmd, buf);\r\nif (se_tmr->response)\r\ngoto attach;\r\nbreak;\r\ncase ISCSI_TM_FUNC_ABORT_TASK_SET:\r\ncase ISCSI_TM_FUNC_CLEAR_ACA:\r\ncase ISCSI_TM_FUNC_CLEAR_TASK_SET:\r\ncase ISCSI_TM_FUNC_LOGICAL_UNIT_RESET:\r\nbreak;\r\ncase ISCSI_TM_FUNC_TARGET_WARM_RESET:\r\nif (iscsit_tmr_task_warm_reset(conn, tmr_req, buf) < 0) {\r\nse_tmr->response = ISCSI_TMF_RSP_AUTH_FAILED;\r\ngoto attach;\r\n}\r\nbreak;\r\ncase ISCSI_TM_FUNC_TARGET_COLD_RESET:\r\nif (iscsit_tmr_task_cold_reset(conn, tmr_req, buf) < 0) {\r\nse_tmr->response = ISCSI_TMF_RSP_AUTH_FAILED;\r\ngoto attach;\r\n}\r\nbreak;\r\ncase ISCSI_TM_FUNC_TASK_REASSIGN:\r\nse_tmr->response = iscsit_tmr_task_reassign(cmd, buf);\r\nif (se_tmr->response)\r\nbreak;\r\nif (iscsit_check_task_reassign_expdatasn(tmr_req, conn) < 0)\r\nreturn iscsit_add_reject_cmd(cmd,\r\nISCSI_REASON_BOOKMARK_INVALID, buf);\r\nbreak;\r\ndefault:\r\npr_err("Unknown TMR function: 0x%02x, protocol"\r\n" error.\n", function);\r\nse_tmr->response = ISCSI_TMF_RSP_NOT_SUPPORTED;\r\ngoto attach;\r\n}\r\nif ((function != ISCSI_TM_FUNC_TASK_REASSIGN) &&\r\n(se_tmr->response == ISCSI_TMF_RSP_COMPLETE))\r\nse_tmr->call_transport = 1;\r\nattach:\r\nspin_lock_bh(&conn->cmd_lock);\r\nlist_add_tail(&cmd->i_conn_node, &conn->conn_cmd_list);\r\nspin_unlock_bh(&conn->cmd_lock);\r\nif (!(hdr->opcode & ISCSI_OP_IMMEDIATE)) {\r\nint cmdsn_ret = iscsit_sequence_cmd(conn, cmd, buf, hdr->cmdsn);\r\nif (cmdsn_ret == CMDSN_HIGHER_THAN_EXP)\r\nout_of_order_cmdsn = 1;\r\nelse if (cmdsn_ret == CMDSN_LOWER_THAN_EXP)\r\nreturn 0;\r\nelse if (cmdsn_ret == CMDSN_ERROR_CANNOT_RECOVER)\r\nreturn -1;\r\n}\r\niscsit_ack_from_expstatsn(conn, be32_to_cpu(hdr->exp_statsn));\r\nif (out_of_order_cmdsn || !(hdr->opcode & ISCSI_OP_IMMEDIATE))\r\nreturn 0;\r\nif (se_tmr->call_transport)\r\nreturn transport_generic_handle_tmr(&cmd->se_cmd);\r\nif (sess_ref) {\r\npr_debug("Handle TMR, using sess_ref=true check\n");\r\ntarget_put_sess_cmd(&cmd->se_cmd);\r\n}\r\niscsit_add_cmd_to_response_queue(cmd, conn, cmd->i_state);\r\nreturn 0;\r\n}\r\nint\r\niscsit_setup_text_cmd(struct iscsi_conn *conn, struct iscsi_cmd *cmd,\r\nstruct iscsi_text *hdr)\r\n{\r\nu32 payload_length = ntoh24(hdr->dlength);\r\nif (payload_length > conn->conn_ops->MaxXmitDataSegmentLength) {\r\npr_err("Unable to accept text parameter length: %u"\r\n"greater than MaxXmitDataSegmentLength %u.\n",\r\npayload_length, conn->conn_ops->MaxXmitDataSegmentLength);\r\nreturn iscsit_reject_cmd(cmd, ISCSI_REASON_PROTOCOL_ERROR,\r\n(unsigned char *)hdr);\r\n}\r\nif (!(hdr->flags & ISCSI_FLAG_CMD_FINAL) ||\r\n(hdr->flags & ISCSI_FLAG_TEXT_CONTINUE)) {\r\npr_err("Multi sequence text commands currently not supported\n");\r\nreturn iscsit_reject_cmd(cmd, ISCSI_REASON_CMD_NOT_SUPPORTED,\r\n(unsigned char *)hdr);\r\n}\r\npr_debug("Got Text Request: ITT: 0x%08x, CmdSN: 0x%08x,"\r\n" ExpStatSN: 0x%08x, Length: %u\n", hdr->itt, hdr->cmdsn,\r\nhdr->exp_statsn, payload_length);\r\ncmd->iscsi_opcode = ISCSI_OP_TEXT;\r\ncmd->i_state = ISTATE_SEND_TEXTRSP;\r\ncmd->immediate_cmd = ((hdr->opcode & ISCSI_OP_IMMEDIATE) ? 1 : 0);\r\nconn->sess->init_task_tag = cmd->init_task_tag = hdr->itt;\r\ncmd->targ_xfer_tag = 0xFFFFFFFF;\r\ncmd->cmd_sn = be32_to_cpu(hdr->cmdsn);\r\ncmd->exp_stat_sn = be32_to_cpu(hdr->exp_statsn);\r\ncmd->data_direction = DMA_NONE;\r\nkfree(cmd->text_in_ptr);\r\ncmd->text_in_ptr = NULL;\r\nreturn 0;\r\n}\r\nint\r\niscsit_process_text_cmd(struct iscsi_conn *conn, struct iscsi_cmd *cmd,\r\nstruct iscsi_text *hdr)\r\n{\r\nunsigned char *text_in = cmd->text_in_ptr, *text_ptr;\r\nint cmdsn_ret;\r\nif (!text_in) {\r\ncmd->targ_xfer_tag = be32_to_cpu(hdr->ttt);\r\nif (cmd->targ_xfer_tag == 0xFFFFFFFF) {\r\npr_err("Unable to locate text_in buffer for sendtargets"\r\n" discovery\n");\r\ngoto reject;\r\n}\r\ngoto empty_sendtargets;\r\n}\r\nif (strncmp("SendTargets", text_in, 11) != 0) {\r\npr_err("Received Text Data that is not"\r\n" SendTargets, cannot continue.\n");\r\ngoto reject;\r\n}\r\ntext_ptr = strchr(text_in, '=');\r\nif (!text_ptr) {\r\npr_err("No \"=\" separator found in Text Data,"\r\n" cannot continue.\n");\r\ngoto reject;\r\n}\r\nif (!strncmp("=All", text_ptr, 4)) {\r\ncmd->cmd_flags |= ICF_SENDTARGETS_ALL;\r\n} else if (!strncmp("=iqn.", text_ptr, 5) ||\r\n!strncmp("=eui.", text_ptr, 5)) {\r\ncmd->cmd_flags |= ICF_SENDTARGETS_SINGLE;\r\n} else {\r\npr_err("Unable to locate valid SendTargets=%s value\n", text_ptr);\r\ngoto reject;\r\n}\r\nspin_lock_bh(&conn->cmd_lock);\r\nlist_add_tail(&cmd->i_conn_node, &conn->conn_cmd_list);\r\nspin_unlock_bh(&conn->cmd_lock);\r\nempty_sendtargets:\r\niscsit_ack_from_expstatsn(conn, be32_to_cpu(hdr->exp_statsn));\r\nif (!(hdr->opcode & ISCSI_OP_IMMEDIATE)) {\r\ncmdsn_ret = iscsit_sequence_cmd(conn, cmd,\r\n(unsigned char *)hdr, hdr->cmdsn);\r\nif (cmdsn_ret == CMDSN_ERROR_CANNOT_RECOVER)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nreturn iscsit_execute_cmd(cmd, 0);\r\nreject:\r\nreturn iscsit_reject_cmd(cmd, ISCSI_REASON_PROTOCOL_ERROR,\r\n(unsigned char *)hdr);\r\n}\r\nstatic int\r\niscsit_handle_text_cmd(struct iscsi_conn *conn, struct iscsi_cmd *cmd,\r\nunsigned char *buf)\r\n{\r\nstruct iscsi_text *hdr = (struct iscsi_text *)buf;\r\nchar *text_in = NULL;\r\nu32 payload_length = ntoh24(hdr->dlength);\r\nint rx_size, rc;\r\nrc = iscsit_setup_text_cmd(conn, cmd, hdr);\r\nif (rc < 0)\r\nreturn 0;\r\nrx_size = payload_length;\r\nif (payload_length) {\r\nu32 checksum = 0, data_crc = 0;\r\nu32 padding = 0, pad_bytes = 0;\r\nint niov = 0, rx_got;\r\nstruct kvec iov[3];\r\ntext_in = kzalloc(payload_length, GFP_KERNEL);\r\nif (!text_in)\r\ngoto reject;\r\ncmd->text_in_ptr = text_in;\r\nmemset(iov, 0, 3 * sizeof(struct kvec));\r\niov[niov].iov_base = text_in;\r\niov[niov++].iov_len = payload_length;\r\npadding = ((-payload_length) & 3);\r\nif (padding != 0) {\r\niov[niov].iov_base = &pad_bytes;\r\niov[niov++].iov_len = padding;\r\nrx_size += padding;\r\npr_debug("Receiving %u additional bytes"\r\n" for padding.\n", padding);\r\n}\r\nif (conn->conn_ops->DataDigest) {\r\niov[niov].iov_base = &checksum;\r\niov[niov++].iov_len = ISCSI_CRC_LEN;\r\nrx_size += ISCSI_CRC_LEN;\r\n}\r\nrx_got = rx_data(conn, &iov[0], niov, rx_size);\r\nif (rx_got != rx_size)\r\ngoto reject;\r\nif (conn->conn_ops->DataDigest) {\r\niscsit_do_crypto_hash_buf(conn->conn_rx_hash,\r\ntext_in, payload_length,\r\npadding, (u8 *)&pad_bytes,\r\n(u8 *)&data_crc);\r\nif (checksum != data_crc) {\r\npr_err("Text data CRC32C DataDigest"\r\n" 0x%08x does not match computed"\r\n" 0x%08x\n", checksum, data_crc);\r\nif (!conn->sess->sess_ops->ErrorRecoveryLevel) {\r\npr_err("Unable to recover from"\r\n" Text Data digest failure while in"\r\n" ERL=0.\n");\r\ngoto reject;\r\n} else {\r\npr_debug("Dropping Text"\r\n" Command CmdSN: 0x%08x due to"\r\n" DataCRC error.\n", hdr->cmdsn);\r\nkfree(text_in);\r\nreturn 0;\r\n}\r\n} else {\r\npr_debug("Got CRC32C DataDigest"\r\n" 0x%08x for %u bytes of text data.\n",\r\nchecksum, payload_length);\r\n}\r\n}\r\ntext_in[payload_length - 1] = '\0';\r\npr_debug("Successfully read %d bytes of text"\r\n" data.\n", payload_length);\r\n}\r\nreturn iscsit_process_text_cmd(conn, cmd, hdr);\r\nreject:\r\nkfree(cmd->text_in_ptr);\r\ncmd->text_in_ptr = NULL;\r\nreturn iscsit_reject_cmd(cmd, ISCSI_REASON_PROTOCOL_ERROR, buf);\r\n}\r\nint iscsit_logout_closesession(struct iscsi_cmd *cmd, struct iscsi_conn *conn)\r\n{\r\nstruct iscsi_conn *conn_p;\r\nstruct iscsi_session *sess = conn->sess;\r\npr_debug("Received logout request CLOSESESSION on CID: %hu"\r\n" for SID: %u.\n", conn->cid, conn->sess->sid);\r\natomic_set(&sess->session_logout, 1);\r\natomic_set(&conn->conn_logout_remove, 1);\r\nconn->conn_logout_reason = ISCSI_LOGOUT_REASON_CLOSE_SESSION;\r\niscsit_inc_conn_usage_count(conn);\r\niscsit_inc_session_usage_count(sess);\r\nspin_lock_bh(&sess->conn_lock);\r\nlist_for_each_entry(conn_p, &sess->sess_conn_list, conn_list) {\r\nif (conn_p->conn_state != TARG_CONN_STATE_LOGGED_IN)\r\ncontinue;\r\npr_debug("Moving to TARG_CONN_STATE_IN_LOGOUT.\n");\r\nconn_p->conn_state = TARG_CONN_STATE_IN_LOGOUT;\r\n}\r\nspin_unlock_bh(&sess->conn_lock);\r\niscsit_add_cmd_to_response_queue(cmd, conn, cmd->i_state);\r\nreturn 0;\r\n}\r\nint iscsit_logout_closeconnection(struct iscsi_cmd *cmd, struct iscsi_conn *conn)\r\n{\r\nstruct iscsi_conn *l_conn;\r\nstruct iscsi_session *sess = conn->sess;\r\npr_debug("Received logout request CLOSECONNECTION for CID:"\r\n" %hu on CID: %hu.\n", cmd->logout_cid, conn->cid);\r\nif (conn->cid == cmd->logout_cid) {\r\nspin_lock_bh(&conn->state_lock);\r\npr_debug("Moving to TARG_CONN_STATE_IN_LOGOUT.\n");\r\nconn->conn_state = TARG_CONN_STATE_IN_LOGOUT;\r\natomic_set(&conn->conn_logout_remove, 1);\r\nconn->conn_logout_reason = ISCSI_LOGOUT_REASON_CLOSE_CONNECTION;\r\niscsit_inc_conn_usage_count(conn);\r\nspin_unlock_bh(&conn->state_lock);\r\n} else {\r\nl_conn = iscsit_get_conn_from_cid(sess,\r\ncmd->logout_cid);\r\nif (!l_conn) {\r\ncmd->logout_response = ISCSI_LOGOUT_CID_NOT_FOUND;\r\niscsit_add_cmd_to_response_queue(cmd, conn,\r\ncmd->i_state);\r\nreturn 0;\r\n}\r\niscsit_dec_conn_usage_count(l_conn);\r\n}\r\niscsit_add_cmd_to_response_queue(cmd, conn, cmd->i_state);\r\nreturn 0;\r\n}\r\nint iscsit_logout_removeconnforrecovery(struct iscsi_cmd *cmd, struct iscsi_conn *conn)\r\n{\r\nstruct iscsi_session *sess = conn->sess;\r\npr_debug("Received explicit REMOVECONNFORRECOVERY logout for"\r\n" CID: %hu on CID: %hu.\n", cmd->logout_cid, conn->cid);\r\nif (sess->sess_ops->ErrorRecoveryLevel != 2) {\r\npr_err("Received Logout Request REMOVECONNFORRECOVERY"\r\n" while ERL!=2.\n");\r\ncmd->logout_response = ISCSI_LOGOUT_RECOVERY_UNSUPPORTED;\r\niscsit_add_cmd_to_response_queue(cmd, conn, cmd->i_state);\r\nreturn 0;\r\n}\r\nif (conn->cid == cmd->logout_cid) {\r\npr_err("Received Logout Request REMOVECONNFORRECOVERY"\r\n" with CID: %hu on CID: %hu, implementation error.\n",\r\ncmd->logout_cid, conn->cid);\r\ncmd->logout_response = ISCSI_LOGOUT_CLEANUP_FAILED;\r\niscsit_add_cmd_to_response_queue(cmd, conn, cmd->i_state);\r\nreturn 0;\r\n}\r\niscsit_add_cmd_to_response_queue(cmd, conn, cmd->i_state);\r\nreturn 0;\r\n}\r\nint\r\niscsit_handle_logout_cmd(struct iscsi_conn *conn, struct iscsi_cmd *cmd,\r\nunsigned char *buf)\r\n{\r\nint cmdsn_ret, logout_remove = 0;\r\nu8 reason_code = 0;\r\nstruct iscsi_logout *hdr;\r\nstruct iscsi_tiqn *tiqn = iscsit_snmp_get_tiqn(conn);\r\nhdr = (struct iscsi_logout *) buf;\r\nreason_code = (hdr->flags & 0x7f);\r\nif (tiqn) {\r\nspin_lock(&tiqn->logout_stats.lock);\r\nif (reason_code == ISCSI_LOGOUT_REASON_CLOSE_SESSION)\r\ntiqn->logout_stats.normal_logouts++;\r\nelse\r\ntiqn->logout_stats.abnormal_logouts++;\r\nspin_unlock(&tiqn->logout_stats.lock);\r\n}\r\npr_debug("Got Logout Request ITT: 0x%08x CmdSN: 0x%08x"\r\n" ExpStatSN: 0x%08x Reason: 0x%02x CID: %hu on CID: %hu\n",\r\nhdr->itt, hdr->cmdsn, hdr->exp_statsn, reason_code,\r\nhdr->cid, conn->cid);\r\nif (conn->conn_state != TARG_CONN_STATE_LOGGED_IN) {\r\npr_err("Received logout request on connection that"\r\n" is not in logged in state, ignoring request.\n");\r\niscsit_free_cmd(cmd, false);\r\nreturn 0;\r\n}\r\ncmd->iscsi_opcode = ISCSI_OP_LOGOUT;\r\ncmd->i_state = ISTATE_SEND_LOGOUTRSP;\r\ncmd->immediate_cmd = ((hdr->opcode & ISCSI_OP_IMMEDIATE) ? 1 : 0);\r\nconn->sess->init_task_tag = cmd->init_task_tag = hdr->itt;\r\ncmd->targ_xfer_tag = 0xFFFFFFFF;\r\ncmd->cmd_sn = be32_to_cpu(hdr->cmdsn);\r\ncmd->exp_stat_sn = be32_to_cpu(hdr->exp_statsn);\r\ncmd->logout_cid = be16_to_cpu(hdr->cid);\r\ncmd->logout_reason = reason_code;\r\ncmd->data_direction = DMA_NONE;\r\nif ((reason_code == ISCSI_LOGOUT_REASON_CLOSE_SESSION) ||\r\n((reason_code == ISCSI_LOGOUT_REASON_CLOSE_CONNECTION) &&\r\nbe16_to_cpu(hdr->cid) == conn->cid))\r\nlogout_remove = 1;\r\nspin_lock_bh(&conn->cmd_lock);\r\nlist_add_tail(&cmd->i_conn_node, &conn->conn_cmd_list);\r\nspin_unlock_bh(&conn->cmd_lock);\r\nif (reason_code != ISCSI_LOGOUT_REASON_RECOVERY)\r\niscsit_ack_from_expstatsn(conn, be32_to_cpu(hdr->exp_statsn));\r\nif (cmd->immediate_cmd) {\r\nint ret = iscsit_execute_cmd(cmd, 0);\r\nif (ret < 0)\r\nreturn ret;\r\n} else {\r\ncmdsn_ret = iscsit_sequence_cmd(conn, cmd, buf, hdr->cmdsn);\r\nif (cmdsn_ret == CMDSN_LOWER_THAN_EXP)\r\nlogout_remove = 0;\r\nelse if (cmdsn_ret == CMDSN_ERROR_CANNOT_RECOVER)\r\nreturn -1;\r\n}\r\nreturn logout_remove;\r\n}\r\nint iscsit_handle_snack(\r\nstruct iscsi_conn *conn,\r\nunsigned char *buf)\r\n{\r\nstruct iscsi_snack *hdr;\r\nhdr = (struct iscsi_snack *) buf;\r\nhdr->flags &= ~ISCSI_FLAG_CMD_FINAL;\r\npr_debug("Got ISCSI_INIT_SNACK, ITT: 0x%08x, ExpStatSN:"\r\n" 0x%08x, Type: 0x%02x, BegRun: 0x%08x, RunLength: 0x%08x,"\r\n" CID: %hu\n", hdr->itt, hdr->exp_statsn, hdr->flags,\r\nhdr->begrun, hdr->runlength, conn->cid);\r\nif (!conn->sess->sess_ops->ErrorRecoveryLevel) {\r\npr_err("Initiator sent SNACK request while in"\r\n" ErrorRecoveryLevel=0.\n");\r\nreturn iscsit_add_reject(conn, ISCSI_REASON_PROTOCOL_ERROR,\r\nbuf);\r\n}\r\nswitch (hdr->flags & ISCSI_FLAG_SNACK_TYPE_MASK) {\r\ncase 0:\r\nreturn iscsit_handle_recovery_datain_or_r2t(conn, buf,\r\nhdr->itt,\r\nbe32_to_cpu(hdr->ttt),\r\nbe32_to_cpu(hdr->begrun),\r\nbe32_to_cpu(hdr->runlength));\r\ncase ISCSI_FLAG_SNACK_TYPE_STATUS:\r\nreturn iscsit_handle_status_snack(conn, hdr->itt,\r\nbe32_to_cpu(hdr->ttt),\r\nbe32_to_cpu(hdr->begrun), be32_to_cpu(hdr->runlength));\r\ncase ISCSI_FLAG_SNACK_TYPE_DATA_ACK:\r\nreturn iscsit_handle_data_ack(conn, be32_to_cpu(hdr->ttt),\r\nbe32_to_cpu(hdr->begrun),\r\nbe32_to_cpu(hdr->runlength));\r\ncase ISCSI_FLAG_SNACK_TYPE_RDATA:\r\npr_err("R-Data SNACK Not Supported.\n");\r\nreturn iscsit_add_reject(conn, ISCSI_REASON_PROTOCOL_ERROR,\r\nbuf);\r\ndefault:\r\npr_err("Unknown SNACK type 0x%02x, protocol"\r\n" error.\n", hdr->flags & 0x0f);\r\nreturn iscsit_add_reject(conn, ISCSI_REASON_PROTOCOL_ERROR,\r\nbuf);\r\n}\r\nreturn 0;\r\n}\r\nstatic void iscsit_rx_thread_wait_for_tcp(struct iscsi_conn *conn)\r\n{\r\nif ((conn->sock->sk->sk_shutdown & SEND_SHUTDOWN) ||\r\n(conn->sock->sk->sk_shutdown & RCV_SHUTDOWN)) {\r\nwait_for_completion_interruptible_timeout(\r\n&conn->rx_half_close_comp,\r\nISCSI_RX_THREAD_TCP_TIMEOUT * HZ);\r\n}\r\n}\r\nstatic int iscsit_handle_immediate_data(\r\nstruct iscsi_cmd *cmd,\r\nstruct iscsi_scsi_req *hdr,\r\nu32 length)\r\n{\r\nint iov_ret, rx_got = 0, rx_size = 0;\r\nu32 checksum, iov_count = 0, padding = 0;\r\nstruct iscsi_conn *conn = cmd->conn;\r\nstruct kvec *iov;\r\niov_ret = iscsit_map_iovec(cmd, cmd->iov_data, cmd->write_data_done, length);\r\nif (iov_ret < 0)\r\nreturn IMMEDIATE_DATA_CANNOT_RECOVER;\r\nrx_size = length;\r\niov_count = iov_ret;\r\niov = &cmd->iov_data[0];\r\npadding = ((-length) & 3);\r\nif (padding != 0) {\r\niov[iov_count].iov_base = cmd->pad_bytes;\r\niov[iov_count++].iov_len = padding;\r\nrx_size += padding;\r\n}\r\nif (conn->conn_ops->DataDigest) {\r\niov[iov_count].iov_base = &checksum;\r\niov[iov_count++].iov_len = ISCSI_CRC_LEN;\r\nrx_size += ISCSI_CRC_LEN;\r\n}\r\nrx_got = rx_data(conn, &cmd->iov_data[0], iov_count, rx_size);\r\niscsit_unmap_iovec(cmd);\r\nif (rx_got != rx_size) {\r\niscsit_rx_thread_wait_for_tcp(conn);\r\nreturn IMMEDIATE_DATA_CANNOT_RECOVER;\r\n}\r\nif (conn->conn_ops->DataDigest) {\r\nu32 data_crc;\r\ndata_crc = iscsit_do_crypto_hash_sg(conn->conn_rx_hash, cmd,\r\ncmd->write_data_done, length, padding,\r\ncmd->pad_bytes);\r\nif (checksum != data_crc) {\r\npr_err("ImmediateData CRC32C DataDigest 0x%08x"\r\n" does not match computed 0x%08x\n", checksum,\r\ndata_crc);\r\nif (!conn->sess->sess_ops->ErrorRecoveryLevel) {\r\npr_err("Unable to recover from"\r\n" Immediate Data digest failure while"\r\n" in ERL=0.\n");\r\niscsit_reject_cmd(cmd,\r\nISCSI_REASON_DATA_DIGEST_ERROR,\r\n(unsigned char *)hdr);\r\nreturn IMMEDIATE_DATA_CANNOT_RECOVER;\r\n} else {\r\niscsit_reject_cmd(cmd,\r\nISCSI_REASON_DATA_DIGEST_ERROR,\r\n(unsigned char *)hdr);\r\nreturn IMMEDIATE_DATA_ERL1_CRC_FAILURE;\r\n}\r\n} else {\r\npr_debug("Got CRC32C DataDigest 0x%08x for"\r\n" %u bytes of Immediate Data\n", checksum,\r\nlength);\r\n}\r\n}\r\ncmd->write_data_done += length;\r\nif (cmd->write_data_done == cmd->se_cmd.data_length) {\r\nspin_lock_bh(&cmd->istate_lock);\r\ncmd->cmd_flags |= ICF_GOT_LAST_DATAOUT;\r\ncmd->i_state = ISTATE_RECEIVED_LAST_DATAOUT;\r\nspin_unlock_bh(&cmd->istate_lock);\r\n}\r\nreturn IMMEDIATE_DATA_NORMAL_OPERATION;\r\n}\r\nstatic void iscsit_build_conn_drop_async_message(struct iscsi_conn *conn)\r\n{\r\nstruct iscsi_cmd *cmd;\r\nstruct iscsi_conn *conn_p;\r\nbool found = false;\r\nlist_for_each_entry(conn_p, &conn->sess->sess_conn_list, conn_list) {\r\nif (conn_p->conn_state == TARG_CONN_STATE_LOGGED_IN) {\r\niscsit_inc_conn_usage_count(conn_p);\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nif (!found)\r\nreturn;\r\ncmd = iscsit_allocate_cmd(conn_p, TASK_RUNNING);\r\nif (!cmd) {\r\niscsit_dec_conn_usage_count(conn_p);\r\nreturn;\r\n}\r\ncmd->logout_cid = conn->cid;\r\ncmd->iscsi_opcode = ISCSI_OP_ASYNC_EVENT;\r\ncmd->i_state = ISTATE_SEND_ASYNCMSG;\r\nspin_lock_bh(&conn_p->cmd_lock);\r\nlist_add_tail(&cmd->i_conn_node, &conn_p->conn_cmd_list);\r\nspin_unlock_bh(&conn_p->cmd_lock);\r\niscsit_add_cmd_to_response_queue(cmd, conn_p, cmd->i_state);\r\niscsit_dec_conn_usage_count(conn_p);\r\n}\r\nstatic int iscsit_send_conn_drop_async_message(\r\nstruct iscsi_cmd *cmd,\r\nstruct iscsi_conn *conn)\r\n{\r\nstruct iscsi_async *hdr;\r\ncmd->iscsi_opcode = ISCSI_OP_ASYNC_EVENT;\r\nhdr = (struct iscsi_async *) cmd->pdu;\r\nhdr->opcode = ISCSI_OP_ASYNC_EVENT;\r\nhdr->flags = ISCSI_FLAG_CMD_FINAL;\r\ncmd->init_task_tag = RESERVED_ITT;\r\ncmd->targ_xfer_tag = 0xFFFFFFFF;\r\nput_unaligned_be64(0xFFFFFFFFFFFFFFFFULL, &hdr->rsvd4[0]);\r\ncmd->stat_sn = conn->stat_sn++;\r\nhdr->statsn = cpu_to_be32(cmd->stat_sn);\r\nhdr->exp_cmdsn = cpu_to_be32(conn->sess->exp_cmd_sn);\r\nhdr->max_cmdsn = cpu_to_be32((u32) atomic_read(&conn->sess->max_cmd_sn));\r\nhdr->async_event = ISCSI_ASYNC_MSG_DROPPING_CONNECTION;\r\nhdr->param1 = cpu_to_be16(cmd->logout_cid);\r\nhdr->param2 = cpu_to_be16(conn->sess->sess_ops->DefaultTime2Wait);\r\nhdr->param3 = cpu_to_be16(conn->sess->sess_ops->DefaultTime2Retain);\r\npr_debug("Sending Connection Dropped Async Message StatSN:"\r\n" 0x%08x, for CID: %hu on CID: %hu\n", cmd->stat_sn,\r\ncmd->logout_cid, conn->cid);\r\nreturn conn->conn_transport->iscsit_xmit_pdu(conn, cmd, NULL, NULL, 0);\r\n}\r\nstatic void iscsit_tx_thread_wait_for_tcp(struct iscsi_conn *conn)\r\n{\r\nif ((conn->sock->sk->sk_shutdown & SEND_SHUTDOWN) ||\r\n(conn->sock->sk->sk_shutdown & RCV_SHUTDOWN)) {\r\nwait_for_completion_interruptible_timeout(\r\n&conn->tx_half_close_comp,\r\nISCSI_TX_THREAD_TCP_TIMEOUT * HZ);\r\n}\r\n}\r\nvoid\r\niscsit_build_datain_pdu(struct iscsi_cmd *cmd, struct iscsi_conn *conn,\r\nstruct iscsi_datain *datain, struct iscsi_data_rsp *hdr,\r\nbool set_statsn)\r\n{\r\nhdr->opcode = ISCSI_OP_SCSI_DATA_IN;\r\nhdr->flags = datain->flags;\r\nif (hdr->flags & ISCSI_FLAG_DATA_STATUS) {\r\nif (cmd->se_cmd.se_cmd_flags & SCF_OVERFLOW_BIT) {\r\nhdr->flags |= ISCSI_FLAG_DATA_OVERFLOW;\r\nhdr->residual_count = cpu_to_be32(cmd->se_cmd.residual_count);\r\n} else if (cmd->se_cmd.se_cmd_flags & SCF_UNDERFLOW_BIT) {\r\nhdr->flags |= ISCSI_FLAG_DATA_UNDERFLOW;\r\nhdr->residual_count = cpu_to_be32(cmd->se_cmd.residual_count);\r\n}\r\n}\r\nhton24(hdr->dlength, datain->length);\r\nif (hdr->flags & ISCSI_FLAG_DATA_ACK)\r\nint_to_scsilun(cmd->se_cmd.orig_fe_lun,\r\n(struct scsi_lun *)&hdr->lun);\r\nelse\r\nput_unaligned_le64(0xFFFFFFFFFFFFFFFFULL, &hdr->lun);\r\nhdr->itt = cmd->init_task_tag;\r\nif (hdr->flags & ISCSI_FLAG_DATA_ACK)\r\nhdr->ttt = cpu_to_be32(cmd->targ_xfer_tag);\r\nelse\r\nhdr->ttt = cpu_to_be32(0xFFFFFFFF);\r\nif (set_statsn)\r\nhdr->statsn = cpu_to_be32(cmd->stat_sn);\r\nelse\r\nhdr->statsn = cpu_to_be32(0xFFFFFFFF);\r\nhdr->exp_cmdsn = cpu_to_be32(conn->sess->exp_cmd_sn);\r\nhdr->max_cmdsn = cpu_to_be32((u32) atomic_read(&conn->sess->max_cmd_sn));\r\nhdr->datasn = cpu_to_be32(datain->data_sn);\r\nhdr->offset = cpu_to_be32(datain->offset);\r\npr_debug("Built DataIN ITT: 0x%08x, StatSN: 0x%08x,"\r\n" DataSN: 0x%08x, Offset: %u, Length: %u, CID: %hu\n",\r\ncmd->init_task_tag, ntohl(hdr->statsn), ntohl(hdr->datasn),\r\nntohl(hdr->offset), datain->length, conn->cid);\r\n}\r\nstatic int iscsit_send_datain(struct iscsi_cmd *cmd, struct iscsi_conn *conn)\r\n{\r\nstruct iscsi_data_rsp *hdr = (struct iscsi_data_rsp *)&cmd->pdu[0];\r\nstruct iscsi_datain datain;\r\nstruct iscsi_datain_req *dr;\r\nint eodr = 0, ret;\r\nbool set_statsn = false;\r\nmemset(&datain, 0, sizeof(struct iscsi_datain));\r\ndr = iscsit_get_datain_values(cmd, &datain);\r\nif (!dr) {\r\npr_err("iscsit_get_datain_values failed for ITT: 0x%08x\n",\r\ncmd->init_task_tag);\r\nreturn -1;\r\n}\r\nif ((datain.offset + datain.length) > cmd->se_cmd.data_length) {\r\npr_err("Command ITT: 0x%08x, datain.offset: %u and"\r\n" datain.length: %u exceeds cmd->data_length: %u\n",\r\ncmd->init_task_tag, datain.offset, datain.length,\r\ncmd->se_cmd.data_length);\r\nreturn -1;\r\n}\r\natomic_long_add(datain.length, &conn->sess->tx_data_octets);\r\nif ((datain.flags & ISCSI_FLAG_DATA_STATUS) &&\r\n(cmd->se_cmd.se_cmd_flags & SCF_TRANSPORT_TASK_SENSE))\r\ndatain.flags &= ~ISCSI_FLAG_DATA_STATUS;\r\nelse {\r\nif ((dr->dr_complete == DATAIN_COMPLETE_NORMAL) ||\r\n(dr->dr_complete == DATAIN_COMPLETE_CONNECTION_RECOVERY)) {\r\niscsit_increment_maxcmdsn(cmd, conn->sess);\r\ncmd->stat_sn = conn->stat_sn++;\r\nset_statsn = true;\r\n} else if (dr->dr_complete ==\r\nDATAIN_COMPLETE_WITHIN_COMMAND_RECOVERY)\r\nset_statsn = true;\r\n}\r\niscsit_build_datain_pdu(cmd, conn, &datain, hdr, set_statsn);\r\nret = conn->conn_transport->iscsit_xmit_pdu(conn, cmd, dr, &datain, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nif (dr->dr_complete) {\r\neodr = (cmd->se_cmd.se_cmd_flags & SCF_TRANSPORT_TASK_SENSE) ?\r\n2 : 1;\r\niscsit_free_datain_req(cmd, dr);\r\n}\r\nreturn eodr;\r\n}\r\nint\r\niscsit_build_logout_rsp(struct iscsi_cmd *cmd, struct iscsi_conn *conn,\r\nstruct iscsi_logout_rsp *hdr)\r\n{\r\nstruct iscsi_conn *logout_conn = NULL;\r\nstruct iscsi_conn_recovery *cr = NULL;\r\nstruct iscsi_session *sess = conn->sess;\r\nswitch (cmd->logout_reason) {\r\ncase ISCSI_LOGOUT_REASON_CLOSE_SESSION:\r\npr_debug("iSCSI session logout successful, setting"\r\n" logout response to ISCSI_LOGOUT_SUCCESS.\n");\r\ncmd->logout_response = ISCSI_LOGOUT_SUCCESS;\r\nbreak;\r\ncase ISCSI_LOGOUT_REASON_CLOSE_CONNECTION:\r\nif (cmd->logout_response == ISCSI_LOGOUT_CID_NOT_FOUND)\r\nbreak;\r\npr_debug("iSCSI CID: %hu logout on CID: %hu"\r\n" successful.\n", cmd->logout_cid, conn->cid);\r\ncmd->logout_response = ISCSI_LOGOUT_SUCCESS;\r\nbreak;\r\ncase ISCSI_LOGOUT_REASON_RECOVERY:\r\nif ((cmd->logout_response == ISCSI_LOGOUT_RECOVERY_UNSUPPORTED) ||\r\n(cmd->logout_response == ISCSI_LOGOUT_CLEANUP_FAILED))\r\nbreak;\r\nlogout_conn = iscsit_get_conn_from_cid_rcfr(sess,\r\ncmd->logout_cid);\r\nif (logout_conn) {\r\niscsit_connection_reinstatement_rcfr(logout_conn);\r\niscsit_dec_conn_usage_count(logout_conn);\r\n}\r\ncr = iscsit_get_inactive_connection_recovery_entry(\r\nconn->sess, cmd->logout_cid);\r\nif (!cr) {\r\npr_err("Unable to locate CID: %hu for"\r\n" REMOVECONNFORRECOVERY Logout Request.\n",\r\ncmd->logout_cid);\r\ncmd->logout_response = ISCSI_LOGOUT_CID_NOT_FOUND;\r\nbreak;\r\n}\r\niscsit_discard_cr_cmds_by_expstatsn(cr, cmd->exp_stat_sn);\r\npr_debug("iSCSI REMOVECONNFORRECOVERY logout"\r\n" for recovery for CID: %hu on CID: %hu successful.\n",\r\ncmd->logout_cid, conn->cid);\r\ncmd->logout_response = ISCSI_LOGOUT_SUCCESS;\r\nbreak;\r\ndefault:\r\npr_err("Unknown cmd->logout_reason: 0x%02x\n",\r\ncmd->logout_reason);\r\nreturn -1;\r\n}\r\nhdr->opcode = ISCSI_OP_LOGOUT_RSP;\r\nhdr->flags |= ISCSI_FLAG_CMD_FINAL;\r\nhdr->response = cmd->logout_response;\r\nhdr->itt = cmd->init_task_tag;\r\ncmd->stat_sn = conn->stat_sn++;\r\nhdr->statsn = cpu_to_be32(cmd->stat_sn);\r\niscsit_increment_maxcmdsn(cmd, conn->sess);\r\nhdr->exp_cmdsn = cpu_to_be32(conn->sess->exp_cmd_sn);\r\nhdr->max_cmdsn = cpu_to_be32((u32) atomic_read(&conn->sess->max_cmd_sn));\r\npr_debug("Built Logout Response ITT: 0x%08x StatSN:"\r\n" 0x%08x Response: 0x%02x CID: %hu on CID: %hu\n",\r\ncmd->init_task_tag, cmd->stat_sn, hdr->response,\r\ncmd->logout_cid, conn->cid);\r\nreturn 0;\r\n}\r\nstatic int\r\niscsit_send_logout(struct iscsi_cmd *cmd, struct iscsi_conn *conn)\r\n{\r\nint rc;\r\nrc = iscsit_build_logout_rsp(cmd, conn,\r\n(struct iscsi_logout_rsp *)&cmd->pdu[0]);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn conn->conn_transport->iscsit_xmit_pdu(conn, cmd, NULL, NULL, 0);\r\n}\r\nvoid\r\niscsit_build_nopin_rsp(struct iscsi_cmd *cmd, struct iscsi_conn *conn,\r\nstruct iscsi_nopin *hdr, bool nopout_response)\r\n{\r\nhdr->opcode = ISCSI_OP_NOOP_IN;\r\nhdr->flags |= ISCSI_FLAG_CMD_FINAL;\r\nhton24(hdr->dlength, cmd->buf_ptr_size);\r\nif (nopout_response)\r\nput_unaligned_le64(0xFFFFFFFFFFFFFFFFULL, &hdr->lun);\r\nhdr->itt = cmd->init_task_tag;\r\nhdr->ttt = cpu_to_be32(cmd->targ_xfer_tag);\r\ncmd->stat_sn = (nopout_response) ? conn->stat_sn++ :\r\nconn->stat_sn;\r\nhdr->statsn = cpu_to_be32(cmd->stat_sn);\r\nif (nopout_response)\r\niscsit_increment_maxcmdsn(cmd, conn->sess);\r\nhdr->exp_cmdsn = cpu_to_be32(conn->sess->exp_cmd_sn);\r\nhdr->max_cmdsn = cpu_to_be32((u32) atomic_read(&conn->sess->max_cmd_sn));\r\npr_debug("Built NOPIN %s Response ITT: 0x%08x, TTT: 0x%08x,"\r\n" StatSN: 0x%08x, Length %u\n", (nopout_response) ?\r\n"Solicited" : "Unsolicited", cmd->init_task_tag,\r\ncmd->targ_xfer_tag, cmd->stat_sn, cmd->buf_ptr_size);\r\n}\r\nstatic int iscsit_send_unsolicited_nopin(\r\nstruct iscsi_cmd *cmd,\r\nstruct iscsi_conn *conn,\r\nint want_response)\r\n{\r\nstruct iscsi_nopin *hdr = (struct iscsi_nopin *)&cmd->pdu[0];\r\nint ret;\r\niscsit_build_nopin_rsp(cmd, conn, hdr, false);\r\npr_debug("Sending Unsolicited NOPIN TTT: 0x%08x StatSN:"\r\n" 0x%08x CID: %hu\n", hdr->ttt, cmd->stat_sn, conn->cid);\r\nret = conn->conn_transport->iscsit_xmit_pdu(conn, cmd, NULL, NULL, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nspin_lock_bh(&cmd->istate_lock);\r\ncmd->i_state = want_response ?\r\nISTATE_SENT_NOPIN_WANT_RESPONSE : ISTATE_SENT_STATUS;\r\nspin_unlock_bh(&cmd->istate_lock);\r\nreturn 0;\r\n}\r\nstatic int\r\niscsit_send_nopin(struct iscsi_cmd *cmd, struct iscsi_conn *conn)\r\n{\r\nstruct iscsi_nopin *hdr = (struct iscsi_nopin *)&cmd->pdu[0];\r\niscsit_build_nopin_rsp(cmd, conn, hdr, true);\r\npr_debug("Echoing back %u bytes of ping data.\n", cmd->buf_ptr_size);\r\nreturn conn->conn_transport->iscsit_xmit_pdu(conn, cmd, NULL,\r\ncmd->buf_ptr,\r\ncmd->buf_ptr_size);\r\n}\r\nstatic int iscsit_send_r2t(\r\nstruct iscsi_cmd *cmd,\r\nstruct iscsi_conn *conn)\r\n{\r\nstruct iscsi_r2t *r2t;\r\nstruct iscsi_r2t_rsp *hdr;\r\nint ret;\r\nr2t = iscsit_get_r2t_from_list(cmd);\r\nif (!r2t)\r\nreturn -1;\r\nhdr = (struct iscsi_r2t_rsp *) cmd->pdu;\r\nmemset(hdr, 0, ISCSI_HDR_LEN);\r\nhdr->opcode = ISCSI_OP_R2T;\r\nhdr->flags |= ISCSI_FLAG_CMD_FINAL;\r\nint_to_scsilun(cmd->se_cmd.orig_fe_lun,\r\n(struct scsi_lun *)&hdr->lun);\r\nhdr->itt = cmd->init_task_tag;\r\nif (conn->conn_transport->iscsit_get_r2t_ttt)\r\nconn->conn_transport->iscsit_get_r2t_ttt(conn, cmd, r2t);\r\nelse\r\nr2t->targ_xfer_tag = session_get_next_ttt(conn->sess);\r\nhdr->ttt = cpu_to_be32(r2t->targ_xfer_tag);\r\nhdr->statsn = cpu_to_be32(conn->stat_sn);\r\nhdr->exp_cmdsn = cpu_to_be32(conn->sess->exp_cmd_sn);\r\nhdr->max_cmdsn = cpu_to_be32((u32) atomic_read(&conn->sess->max_cmd_sn));\r\nhdr->r2tsn = cpu_to_be32(r2t->r2t_sn);\r\nhdr->data_offset = cpu_to_be32(r2t->offset);\r\nhdr->data_length = cpu_to_be32(r2t->xfer_len);\r\npr_debug("Built %sR2T, ITT: 0x%08x, TTT: 0x%08x, StatSN:"\r\n" 0x%08x, R2TSN: 0x%08x, Offset: %u, DDTL: %u, CID: %hu\n",\r\n(!r2t->recovery_r2t) ? "" : "Recovery ", cmd->init_task_tag,\r\nr2t->targ_xfer_tag, ntohl(hdr->statsn), r2t->r2t_sn,\r\nr2t->offset, r2t->xfer_len, conn->cid);\r\nspin_lock_bh(&cmd->r2t_lock);\r\nr2t->sent_r2t = 1;\r\nspin_unlock_bh(&cmd->r2t_lock);\r\nret = conn->conn_transport->iscsit_xmit_pdu(conn, cmd, NULL, NULL, 0);\r\nif (ret < 0) {\r\nreturn ret;\r\n}\r\nspin_lock_bh(&cmd->dataout_timeout_lock);\r\niscsit_start_dataout_timer(cmd, conn);\r\nspin_unlock_bh(&cmd->dataout_timeout_lock);\r\nreturn 0;\r\n}\r\nint iscsit_build_r2ts_for_cmd(\r\nstruct iscsi_conn *conn,\r\nstruct iscsi_cmd *cmd,\r\nbool recovery)\r\n{\r\nint first_r2t = 1;\r\nu32 offset = 0, xfer_len = 0;\r\nspin_lock_bh(&cmd->r2t_lock);\r\nif (cmd->cmd_flags & ICF_SENT_LAST_R2T) {\r\nspin_unlock_bh(&cmd->r2t_lock);\r\nreturn 0;\r\n}\r\nif (conn->sess->sess_ops->DataSequenceInOrder &&\r\n!recovery)\r\ncmd->r2t_offset = max(cmd->r2t_offset, cmd->write_data_done);\r\nwhile (cmd->outstanding_r2ts < conn->sess->sess_ops->MaxOutstandingR2T) {\r\nif (conn->sess->sess_ops->DataSequenceInOrder) {\r\noffset = cmd->r2t_offset;\r\nif (first_r2t && recovery) {\r\nint new_data_end = offset +\r\nconn->sess->sess_ops->MaxBurstLength -\r\ncmd->next_burst_len;\r\nif (new_data_end > cmd->se_cmd.data_length)\r\nxfer_len = cmd->se_cmd.data_length - offset;\r\nelse\r\nxfer_len =\r\nconn->sess->sess_ops->MaxBurstLength -\r\ncmd->next_burst_len;\r\n} else {\r\nint new_data_end = offset +\r\nconn->sess->sess_ops->MaxBurstLength;\r\nif (new_data_end > cmd->se_cmd.data_length)\r\nxfer_len = cmd->se_cmd.data_length - offset;\r\nelse\r\nxfer_len = conn->sess->sess_ops->MaxBurstLength;\r\n}\r\ncmd->r2t_offset += xfer_len;\r\nif (cmd->r2t_offset == cmd->se_cmd.data_length)\r\ncmd->cmd_flags |= ICF_SENT_LAST_R2T;\r\n} else {\r\nstruct iscsi_seq *seq;\r\nseq = iscsit_get_seq_holder_for_r2t(cmd);\r\nif (!seq) {\r\nspin_unlock_bh(&cmd->r2t_lock);\r\nreturn -1;\r\n}\r\noffset = seq->offset;\r\nxfer_len = seq->xfer_len;\r\nif (cmd->seq_send_order == cmd->seq_count)\r\ncmd->cmd_flags |= ICF_SENT_LAST_R2T;\r\n}\r\ncmd->outstanding_r2ts++;\r\nfirst_r2t = 0;\r\nif (iscsit_add_r2t_to_list(cmd, offset, xfer_len, 0, 0) < 0) {\r\nspin_unlock_bh(&cmd->r2t_lock);\r\nreturn -1;\r\n}\r\nif (cmd->cmd_flags & ICF_SENT_LAST_R2T)\r\nbreak;\r\n}\r\nspin_unlock_bh(&cmd->r2t_lock);\r\nreturn 0;\r\n}\r\nvoid iscsit_build_rsp_pdu(struct iscsi_cmd *cmd, struct iscsi_conn *conn,\r\nbool inc_stat_sn, struct iscsi_scsi_rsp *hdr)\r\n{\r\nif (inc_stat_sn)\r\ncmd->stat_sn = conn->stat_sn++;\r\natomic_long_inc(&conn->sess->rsp_pdus);\r\nmemset(hdr, 0, ISCSI_HDR_LEN);\r\nhdr->opcode = ISCSI_OP_SCSI_CMD_RSP;\r\nhdr->flags |= ISCSI_FLAG_CMD_FINAL;\r\nif (cmd->se_cmd.se_cmd_flags & SCF_OVERFLOW_BIT) {\r\nhdr->flags |= ISCSI_FLAG_CMD_OVERFLOW;\r\nhdr->residual_count = cpu_to_be32(cmd->se_cmd.residual_count);\r\n} else if (cmd->se_cmd.se_cmd_flags & SCF_UNDERFLOW_BIT) {\r\nhdr->flags |= ISCSI_FLAG_CMD_UNDERFLOW;\r\nhdr->residual_count = cpu_to_be32(cmd->se_cmd.residual_count);\r\n}\r\nhdr->response = cmd->iscsi_response;\r\nhdr->cmd_status = cmd->se_cmd.scsi_status;\r\nhdr->itt = cmd->init_task_tag;\r\nhdr->statsn = cpu_to_be32(cmd->stat_sn);\r\niscsit_increment_maxcmdsn(cmd, conn->sess);\r\nhdr->exp_cmdsn = cpu_to_be32(conn->sess->exp_cmd_sn);\r\nhdr->max_cmdsn = cpu_to_be32((u32) atomic_read(&conn->sess->max_cmd_sn));\r\npr_debug("Built SCSI Response, ITT: 0x%08x, StatSN: 0x%08x,"\r\n" Response: 0x%02x, SAM Status: 0x%02x, CID: %hu\n",\r\ncmd->init_task_tag, cmd->stat_sn, cmd->se_cmd.scsi_status,\r\ncmd->se_cmd.scsi_status, conn->cid);\r\n}\r\nstatic int iscsit_send_response(struct iscsi_cmd *cmd, struct iscsi_conn *conn)\r\n{\r\nstruct iscsi_scsi_rsp *hdr = (struct iscsi_scsi_rsp *)&cmd->pdu[0];\r\nbool inc_stat_sn = (cmd->i_state == ISTATE_SEND_STATUS);\r\nvoid *data_buf = NULL;\r\nu32 padding = 0, data_buf_len = 0;\r\niscsit_build_rsp_pdu(cmd, conn, inc_stat_sn, hdr);\r\nif (cmd->se_cmd.sense_buffer &&\r\n((cmd->se_cmd.se_cmd_flags & SCF_TRANSPORT_TASK_SENSE) ||\r\n(cmd->se_cmd.se_cmd_flags & SCF_EMULATED_TASK_SENSE))) {\r\nput_unaligned_be16(cmd->se_cmd.scsi_sense_length, cmd->sense_buffer);\r\ncmd->se_cmd.scsi_sense_length += sizeof (__be16);\r\npadding = -(cmd->se_cmd.scsi_sense_length) & 3;\r\nhton24(hdr->dlength, (u32)cmd->se_cmd.scsi_sense_length);\r\ndata_buf = cmd->sense_buffer;\r\ndata_buf_len = cmd->se_cmd.scsi_sense_length + padding;\r\nif (padding) {\r\nmemset(cmd->sense_buffer +\r\ncmd->se_cmd.scsi_sense_length, 0, padding);\r\npr_debug("Adding %u bytes of padding to"\r\n" SENSE.\n", padding);\r\n}\r\npr_debug("Attaching SENSE DATA: %u bytes to iSCSI"\r\n" Response PDU\n",\r\ncmd->se_cmd.scsi_sense_length);\r\n}\r\nreturn conn->conn_transport->iscsit_xmit_pdu(conn, cmd, NULL, data_buf,\r\ndata_buf_len);\r\n}\r\nstatic u8 iscsit_convert_tcm_tmr_rsp(struct se_tmr_req *se_tmr)\r\n{\r\nswitch (se_tmr->response) {\r\ncase TMR_FUNCTION_COMPLETE:\r\nreturn ISCSI_TMF_RSP_COMPLETE;\r\ncase TMR_TASK_DOES_NOT_EXIST:\r\nreturn ISCSI_TMF_RSP_NO_TASK;\r\ncase TMR_LUN_DOES_NOT_EXIST:\r\nreturn ISCSI_TMF_RSP_NO_LUN;\r\ncase TMR_TASK_MGMT_FUNCTION_NOT_SUPPORTED:\r\nreturn ISCSI_TMF_RSP_NOT_SUPPORTED;\r\ncase TMR_FUNCTION_REJECTED:\r\ndefault:\r\nreturn ISCSI_TMF_RSP_REJECTED;\r\n}\r\n}\r\nvoid\r\niscsit_build_task_mgt_rsp(struct iscsi_cmd *cmd, struct iscsi_conn *conn,\r\nstruct iscsi_tm_rsp *hdr)\r\n{\r\nstruct se_tmr_req *se_tmr = cmd->se_cmd.se_tmr_req;\r\nhdr->opcode = ISCSI_OP_SCSI_TMFUNC_RSP;\r\nhdr->flags = ISCSI_FLAG_CMD_FINAL;\r\nhdr->response = iscsit_convert_tcm_tmr_rsp(se_tmr);\r\nhdr->itt = cmd->init_task_tag;\r\ncmd->stat_sn = conn->stat_sn++;\r\nhdr->statsn = cpu_to_be32(cmd->stat_sn);\r\niscsit_increment_maxcmdsn(cmd, conn->sess);\r\nhdr->exp_cmdsn = cpu_to_be32(conn->sess->exp_cmd_sn);\r\nhdr->max_cmdsn = cpu_to_be32((u32) atomic_read(&conn->sess->max_cmd_sn));\r\npr_debug("Built Task Management Response ITT: 0x%08x,"\r\n" StatSN: 0x%08x, Response: 0x%02x, CID: %hu\n",\r\ncmd->init_task_tag, cmd->stat_sn, hdr->response, conn->cid);\r\n}\r\nstatic int\r\niscsit_send_task_mgt_rsp(struct iscsi_cmd *cmd, struct iscsi_conn *conn)\r\n{\r\nstruct iscsi_tm_rsp *hdr = (struct iscsi_tm_rsp *)&cmd->pdu[0];\r\niscsit_build_task_mgt_rsp(cmd, conn, hdr);\r\nreturn conn->conn_transport->iscsit_xmit_pdu(conn, cmd, NULL, NULL, 0);\r\n}\r\nstatic bool iscsit_check_inaddr_any(struct iscsi_np *np)\r\n{\r\nbool ret = false;\r\nif (np->np_sockaddr.ss_family == AF_INET6) {\r\nconst struct sockaddr_in6 sin6 = {\r\n.sin6_addr = IN6ADDR_ANY_INIT };\r\nstruct sockaddr_in6 *sock_in6 =\r\n(struct sockaddr_in6 *)&np->np_sockaddr;\r\nif (!memcmp(sock_in6->sin6_addr.s6_addr,\r\nsin6.sin6_addr.s6_addr, 16))\r\nret = true;\r\n} else {\r\nstruct sockaddr_in * sock_in =\r\n(struct sockaddr_in *)&np->np_sockaddr;\r\nif (sock_in->sin_addr.s_addr == htonl(INADDR_ANY))\r\nret = true;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\niscsit_build_sendtargets_response(struct iscsi_cmd *cmd,\r\nenum iscsit_transport_type network_transport,\r\nint skip_bytes, bool *completed)\r\n{\r\nchar *payload = NULL;\r\nstruct iscsi_conn *conn = cmd->conn;\r\nstruct iscsi_portal_group *tpg;\r\nstruct iscsi_tiqn *tiqn;\r\nstruct iscsi_tpg_np *tpg_np;\r\nint buffer_len, end_of_buf = 0, len = 0, payload_len = 0;\r\nint target_name_printed;\r\nunsigned char buf[ISCSI_IQN_LEN+12];\r\nunsigned char *text_in = cmd->text_in_ptr, *text_ptr = NULL;\r\nbool active;\r\nbuffer_len = min(conn->conn_ops->MaxRecvDataSegmentLength,\r\nSENDTARGETS_BUF_LIMIT);\r\npayload = kzalloc(buffer_len, GFP_KERNEL);\r\nif (!payload)\r\nreturn -ENOMEM;\r\nif (cmd->cmd_flags & ICF_SENDTARGETS_SINGLE) {\r\ntext_ptr = strchr(text_in, '=');\r\nif (!text_ptr) {\r\npr_err("Unable to locate '=' string in text_in:"\r\n" %s\n", text_in);\r\nkfree(payload);\r\nreturn -EINVAL;\r\n}\r\ntext_ptr += 1;\r\n}\r\nspin_lock(&tiqn_lock);\r\nlist_for_each_entry(tiqn, &g_tiqn_list, tiqn_list) {\r\nif ((cmd->cmd_flags & ICF_SENDTARGETS_SINGLE) &&\r\nstrcmp(tiqn->tiqn, text_ptr)) {\r\ncontinue;\r\n}\r\ntarget_name_printed = 0;\r\nspin_lock(&tiqn->tiqn_tpg_lock);\r\nlist_for_each_entry(tpg, &tiqn->tiqn_tpg_list, tpg_list) {\r\nif ((tpg->tpg_attrib.generate_node_acls == 0) &&\r\n(tpg->tpg_attrib.demo_mode_discovery == 0) &&\r\n(!target_tpg_has_node_acl(&tpg->tpg_se_tpg,\r\ncmd->conn->sess->sess_ops->InitiatorName))) {\r\ncontinue;\r\n}\r\nspin_lock(&tpg->tpg_state_lock);\r\nactive = (tpg->tpg_state == TPG_STATE_ACTIVE);\r\nspin_unlock(&tpg->tpg_state_lock);\r\nif (!active && tpg->tpg_attrib.tpg_enabled_sendtargets)\r\ncontinue;\r\nspin_lock(&tpg->tpg_np_lock);\r\nlist_for_each_entry(tpg_np, &tpg->tpg_gnp_list,\r\ntpg_np_list) {\r\nstruct iscsi_np *np = tpg_np->tpg_np;\r\nbool inaddr_any = iscsit_check_inaddr_any(np);\r\nstruct sockaddr_storage *sockaddr;\r\nif (np->np_network_transport != network_transport)\r\ncontinue;\r\nif (!target_name_printed) {\r\nlen = sprintf(buf, "TargetName=%s",\r\ntiqn->tiqn);\r\nlen += 1;\r\nif ((len + payload_len) > buffer_len) {\r\nspin_unlock(&tpg->tpg_np_lock);\r\nspin_unlock(&tiqn->tiqn_tpg_lock);\r\nend_of_buf = 1;\r\ngoto eob;\r\n}\r\nif (skip_bytes && len <= skip_bytes) {\r\nskip_bytes -= len;\r\n} else {\r\nmemcpy(payload + payload_len, buf, len);\r\npayload_len += len;\r\ntarget_name_printed = 1;\r\nif (len > skip_bytes)\r\nskip_bytes = 0;\r\n}\r\n}\r\nif (inaddr_any)\r\nsockaddr = &conn->local_sockaddr;\r\nelse\r\nsockaddr = &np->np_sockaddr;\r\nlen = sprintf(buf, "TargetAddress="\r\n"%pISpc,%hu",\r\nsockaddr,\r\ntpg->tpgt);\r\nlen += 1;\r\nif ((len + payload_len) > buffer_len) {\r\nspin_unlock(&tpg->tpg_np_lock);\r\nspin_unlock(&tiqn->tiqn_tpg_lock);\r\nend_of_buf = 1;\r\ngoto eob;\r\n}\r\nif (skip_bytes && len <= skip_bytes) {\r\nskip_bytes -= len;\r\n} else {\r\nmemcpy(payload + payload_len, buf, len);\r\npayload_len += len;\r\nif (len > skip_bytes)\r\nskip_bytes = 0;\r\n}\r\n}\r\nspin_unlock(&tpg->tpg_np_lock);\r\n}\r\nspin_unlock(&tiqn->tiqn_tpg_lock);\r\neob:\r\nif (end_of_buf) {\r\n*completed = false;\r\nbreak;\r\n}\r\nif (cmd->cmd_flags & ICF_SENDTARGETS_SINGLE)\r\nbreak;\r\n}\r\nspin_unlock(&tiqn_lock);\r\ncmd->buf_ptr = payload;\r\nreturn payload_len;\r\n}\r\nint\r\niscsit_build_text_rsp(struct iscsi_cmd *cmd, struct iscsi_conn *conn,\r\nstruct iscsi_text_rsp *hdr,\r\nenum iscsit_transport_type network_transport)\r\n{\r\nint text_length, padding;\r\nbool completed = true;\r\ntext_length = iscsit_build_sendtargets_response(cmd, network_transport,\r\ncmd->read_data_done,\r\n&completed);\r\nif (text_length < 0)\r\nreturn text_length;\r\nif (completed) {\r\nhdr->flags = ISCSI_FLAG_CMD_FINAL;\r\n} else {\r\nhdr->flags = ISCSI_FLAG_TEXT_CONTINUE;\r\ncmd->read_data_done += text_length;\r\nif (cmd->targ_xfer_tag == 0xFFFFFFFF)\r\ncmd->targ_xfer_tag = session_get_next_ttt(conn->sess);\r\n}\r\nhdr->opcode = ISCSI_OP_TEXT_RSP;\r\npadding = ((-text_length) & 3);\r\nhton24(hdr->dlength, text_length);\r\nhdr->itt = cmd->init_task_tag;\r\nhdr->ttt = cpu_to_be32(cmd->targ_xfer_tag);\r\ncmd->stat_sn = conn->stat_sn++;\r\nhdr->statsn = cpu_to_be32(cmd->stat_sn);\r\niscsit_increment_maxcmdsn(cmd, conn->sess);\r\ncmd->maxcmdsn_inc = 0;\r\nhdr->exp_cmdsn = cpu_to_be32(conn->sess->exp_cmd_sn);\r\nhdr->max_cmdsn = cpu_to_be32((u32) atomic_read(&conn->sess->max_cmd_sn));\r\npr_debug("Built Text Response: ITT: 0x%08x, TTT: 0x%08x, StatSN: 0x%08x,"\r\n" Length: %u, CID: %hu F: %d C: %d\n", cmd->init_task_tag,\r\ncmd->targ_xfer_tag, cmd->stat_sn, text_length, conn->cid,\r\n!!(hdr->flags & ISCSI_FLAG_CMD_FINAL),\r\n!!(hdr->flags & ISCSI_FLAG_TEXT_CONTINUE));\r\nreturn text_length + padding;\r\n}\r\nstatic int iscsit_send_text_rsp(\r\nstruct iscsi_cmd *cmd,\r\nstruct iscsi_conn *conn)\r\n{\r\nstruct iscsi_text_rsp *hdr = (struct iscsi_text_rsp *)cmd->pdu;\r\nint text_length;\r\ntext_length = iscsit_build_text_rsp(cmd, conn, hdr,\r\nconn->conn_transport->transport_type);\r\nif (text_length < 0)\r\nreturn text_length;\r\nreturn conn->conn_transport->iscsit_xmit_pdu(conn, cmd, NULL,\r\ncmd->buf_ptr,\r\ntext_length);\r\n}\r\nvoid\r\niscsit_build_reject(struct iscsi_cmd *cmd, struct iscsi_conn *conn,\r\nstruct iscsi_reject *hdr)\r\n{\r\nhdr->opcode = ISCSI_OP_REJECT;\r\nhdr->reason = cmd->reject_reason;\r\nhdr->flags |= ISCSI_FLAG_CMD_FINAL;\r\nhton24(hdr->dlength, ISCSI_HDR_LEN);\r\nhdr->ffffffff = cpu_to_be32(0xffffffff);\r\ncmd->stat_sn = conn->stat_sn++;\r\nhdr->statsn = cpu_to_be32(cmd->stat_sn);\r\nhdr->exp_cmdsn = cpu_to_be32(conn->sess->exp_cmd_sn);\r\nhdr->max_cmdsn = cpu_to_be32((u32) atomic_read(&conn->sess->max_cmd_sn));\r\n}\r\nstatic int iscsit_send_reject(\r\nstruct iscsi_cmd *cmd,\r\nstruct iscsi_conn *conn)\r\n{\r\nstruct iscsi_reject *hdr = (struct iscsi_reject *)&cmd->pdu[0];\r\niscsit_build_reject(cmd, conn, hdr);\r\npr_debug("Built Reject PDU StatSN: 0x%08x, Reason: 0x%02x,"\r\n" CID: %hu\n", ntohl(hdr->statsn), hdr->reason, conn->cid);\r\nreturn conn->conn_transport->iscsit_xmit_pdu(conn, cmd, NULL,\r\ncmd->buf_ptr,\r\nISCSI_HDR_LEN);\r\n}\r\nvoid iscsit_thread_get_cpumask(struct iscsi_conn *conn)\r\n{\r\nint ord, cpu;\r\nord = conn->bitmap_id % cpumask_weight(cpu_online_mask);\r\nfor_each_online_cpu(cpu) {\r\nif (ord-- == 0) {\r\ncpumask_set_cpu(cpu, conn->conn_cpumask);\r\nreturn;\r\n}\r\n}\r\ndump_stack();\r\ncpumask_setall(conn->conn_cpumask);\r\n}\r\nint\r\niscsit_immediate_queue(struct iscsi_conn *conn, struct iscsi_cmd *cmd, int state)\r\n{\r\nint ret;\r\nswitch (state) {\r\ncase ISTATE_SEND_R2T:\r\nret = iscsit_send_r2t(cmd, conn);\r\nif (ret < 0)\r\ngoto err;\r\nbreak;\r\ncase ISTATE_REMOVE:\r\nspin_lock_bh(&conn->cmd_lock);\r\nlist_del_init(&cmd->i_conn_node);\r\nspin_unlock_bh(&conn->cmd_lock);\r\niscsit_free_cmd(cmd, false);\r\nbreak;\r\ncase ISTATE_SEND_NOPIN_WANT_RESPONSE:\r\niscsit_mod_nopin_response_timer(conn);\r\nret = iscsit_send_unsolicited_nopin(cmd, conn, 1);\r\nif (ret < 0)\r\ngoto err;\r\nbreak;\r\ncase ISTATE_SEND_NOPIN_NO_RESPONSE:\r\nret = iscsit_send_unsolicited_nopin(cmd, conn, 0);\r\nif (ret < 0)\r\ngoto err;\r\nbreak;\r\ndefault:\r\npr_err("Unknown Opcode: 0x%02x ITT:"\r\n" 0x%08x, i_state: %d on CID: %hu\n",\r\ncmd->iscsi_opcode, cmd->init_task_tag, state,\r\nconn->cid);\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nreturn -1;\r\n}\r\nstatic int\r\niscsit_handle_immediate_queue(struct iscsi_conn *conn)\r\n{\r\nstruct iscsit_transport *t = conn->conn_transport;\r\nstruct iscsi_queue_req *qr;\r\nstruct iscsi_cmd *cmd;\r\nu8 state;\r\nint ret;\r\nwhile ((qr = iscsit_get_cmd_from_immediate_queue(conn))) {\r\natomic_set(&conn->check_immediate_queue, 0);\r\ncmd = qr->cmd;\r\nstate = qr->state;\r\nkmem_cache_free(lio_qr_cache, qr);\r\nret = t->iscsit_immediate_queue(conn, cmd, state);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint\r\niscsit_response_queue(struct iscsi_conn *conn, struct iscsi_cmd *cmd, int state)\r\n{\r\nint ret;\r\ncheck_rsp_state:\r\nswitch (state) {\r\ncase ISTATE_SEND_DATAIN:\r\nret = iscsit_send_datain(cmd, conn);\r\nif (ret < 0)\r\ngoto err;\r\nelse if (!ret)\r\ngoto check_rsp_state;\r\nelse if (ret == 1) {\r\nspin_lock_bh(&cmd->istate_lock);\r\ncmd->i_state = ISTATE_SENT_STATUS;\r\nspin_unlock_bh(&cmd->istate_lock);\r\nif (atomic_read(&conn->check_immediate_queue))\r\nreturn 1;\r\nreturn 0;\r\n} else if (ret == 2) {\r\nspin_lock_bh(&cmd->istate_lock);\r\ncmd->i_state = ISTATE_SEND_STATUS;\r\nspin_unlock_bh(&cmd->istate_lock);\r\nstate = ISTATE_SEND_STATUS;\r\ngoto check_rsp_state;\r\n}\r\nbreak;\r\ncase ISTATE_SEND_STATUS:\r\ncase ISTATE_SEND_STATUS_RECOVERY:\r\nret = iscsit_send_response(cmd, conn);\r\nbreak;\r\ncase ISTATE_SEND_LOGOUTRSP:\r\nret = iscsit_send_logout(cmd, conn);\r\nbreak;\r\ncase ISTATE_SEND_ASYNCMSG:\r\nret = iscsit_send_conn_drop_async_message(\r\ncmd, conn);\r\nbreak;\r\ncase ISTATE_SEND_NOPIN:\r\nret = iscsit_send_nopin(cmd, conn);\r\nbreak;\r\ncase ISTATE_SEND_REJECT:\r\nret = iscsit_send_reject(cmd, conn);\r\nbreak;\r\ncase ISTATE_SEND_TASKMGTRSP:\r\nret = iscsit_send_task_mgt_rsp(cmd, conn);\r\nif (ret != 0)\r\nbreak;\r\nret = iscsit_tmr_post_handler(cmd, conn);\r\nif (ret != 0)\r\niscsit_fall_back_to_erl0(conn->sess);\r\nbreak;\r\ncase ISTATE_SEND_TEXTRSP:\r\nret = iscsit_send_text_rsp(cmd, conn);\r\nbreak;\r\ndefault:\r\npr_err("Unknown Opcode: 0x%02x ITT:"\r\n" 0x%08x, i_state: %d on CID: %hu\n",\r\ncmd->iscsi_opcode, cmd->init_task_tag,\r\nstate, conn->cid);\r\ngoto err;\r\n}\r\nif (ret < 0)\r\ngoto err;\r\nswitch (state) {\r\ncase ISTATE_SEND_LOGOUTRSP:\r\nif (!iscsit_logout_post_handler(cmd, conn))\r\nreturn -ECONNRESET;\r\ncase ISTATE_SEND_STATUS:\r\ncase ISTATE_SEND_ASYNCMSG:\r\ncase ISTATE_SEND_NOPIN:\r\ncase ISTATE_SEND_STATUS_RECOVERY:\r\ncase ISTATE_SEND_TEXTRSP:\r\ncase ISTATE_SEND_TASKMGTRSP:\r\ncase ISTATE_SEND_REJECT:\r\nspin_lock_bh(&cmd->istate_lock);\r\ncmd->i_state = ISTATE_SENT_STATUS;\r\nspin_unlock_bh(&cmd->istate_lock);\r\nbreak;\r\ndefault:\r\npr_err("Unknown Opcode: 0x%02x ITT:"\r\n" 0x%08x, i_state: %d on CID: %hu\n",\r\ncmd->iscsi_opcode, cmd->init_task_tag,\r\ncmd->i_state, conn->cid);\r\ngoto err;\r\n}\r\nif (atomic_read(&conn->check_immediate_queue))\r\nreturn 1;\r\nreturn 0;\r\nerr:\r\nreturn -1;\r\n}\r\nstatic int iscsit_handle_response_queue(struct iscsi_conn *conn)\r\n{\r\nstruct iscsit_transport *t = conn->conn_transport;\r\nstruct iscsi_queue_req *qr;\r\nstruct iscsi_cmd *cmd;\r\nu8 state;\r\nint ret;\r\nwhile ((qr = iscsit_get_cmd_from_response_queue(conn))) {\r\ncmd = qr->cmd;\r\nstate = qr->state;\r\nkmem_cache_free(lio_qr_cache, qr);\r\nret = t->iscsit_response_queue(conn, cmd, state);\r\nif (ret == 1 || ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint iscsi_target_tx_thread(void *arg)\r\n{\r\nint ret = 0;\r\nstruct iscsi_conn *conn = arg;\r\nbool conn_freed = false;\r\nallow_signal(SIGINT);\r\nwhile (!kthread_should_stop()) {\r\niscsit_thread_check_cpumask(conn, current, 1);\r\nwait_event_interruptible(conn->queues_wq,\r\n!iscsit_conn_all_queues_empty(conn));\r\nif (signal_pending(current))\r\ngoto transport_err;\r\nget_immediate:\r\nret = iscsit_handle_immediate_queue(conn);\r\nif (ret < 0)\r\ngoto transport_err;\r\nret = iscsit_handle_response_queue(conn);\r\nif (ret == 1) {\r\ngoto get_immediate;\r\n} else if (ret == -ECONNRESET) {\r\nconn_freed = true;\r\ngoto out;\r\n} else if (ret < 0) {\r\ngoto transport_err;\r\n}\r\n}\r\ntransport_err:\r\nif (conn->conn_state != TARG_CONN_STATE_IN_LOGIN)\r\niscsit_take_action_for_connection_exit(conn, &conn_freed);\r\nout:\r\nif (!conn_freed) {\r\nwhile (!kthread_should_stop()) {\r\nmsleep(100);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int iscsi_target_rx_opcode(struct iscsi_conn *conn, unsigned char *buf)\r\n{\r\nstruct iscsi_hdr *hdr = (struct iscsi_hdr *)buf;\r\nstruct iscsi_cmd *cmd;\r\nint ret = 0;\r\nswitch (hdr->opcode & ISCSI_OPCODE_MASK) {\r\ncase ISCSI_OP_SCSI_CMD:\r\ncmd = iscsit_allocate_cmd(conn, TASK_INTERRUPTIBLE);\r\nif (!cmd)\r\ngoto reject;\r\nret = iscsit_handle_scsi_cmd(conn, cmd, buf);\r\nbreak;\r\ncase ISCSI_OP_SCSI_DATA_OUT:\r\nret = iscsit_handle_data_out(conn, buf);\r\nbreak;\r\ncase ISCSI_OP_NOOP_OUT:\r\ncmd = NULL;\r\nif (hdr->ttt == cpu_to_be32(0xFFFFFFFF)) {\r\ncmd = iscsit_allocate_cmd(conn, TASK_INTERRUPTIBLE);\r\nif (!cmd)\r\ngoto reject;\r\n}\r\nret = iscsit_handle_nop_out(conn, cmd, buf);\r\nbreak;\r\ncase ISCSI_OP_SCSI_TMFUNC:\r\ncmd = iscsit_allocate_cmd(conn, TASK_INTERRUPTIBLE);\r\nif (!cmd)\r\ngoto reject;\r\nret = iscsit_handle_task_mgt_cmd(conn, cmd, buf);\r\nbreak;\r\ncase ISCSI_OP_TEXT:\r\nif (hdr->ttt != cpu_to_be32(0xFFFFFFFF)) {\r\ncmd = iscsit_find_cmd_from_itt(conn, hdr->itt);\r\nif (!cmd)\r\ngoto reject;\r\n} else {\r\ncmd = iscsit_allocate_cmd(conn, TASK_INTERRUPTIBLE);\r\nif (!cmd)\r\ngoto reject;\r\n}\r\nret = iscsit_handle_text_cmd(conn, cmd, buf);\r\nbreak;\r\ncase ISCSI_OP_LOGOUT:\r\ncmd = iscsit_allocate_cmd(conn, TASK_INTERRUPTIBLE);\r\nif (!cmd)\r\ngoto reject;\r\nret = iscsit_handle_logout_cmd(conn, cmd, buf);\r\nif (ret > 0)\r\nwait_for_completion_timeout(&conn->conn_logout_comp,\r\nSECONDS_FOR_LOGOUT_COMP * HZ);\r\nbreak;\r\ncase ISCSI_OP_SNACK:\r\nret = iscsit_handle_snack(conn, buf);\r\nbreak;\r\ndefault:\r\npr_err("Got unknown iSCSI OpCode: 0x%02x\n", hdr->opcode);\r\nif (!conn->sess->sess_ops->ErrorRecoveryLevel) {\r\npr_err("Cannot recover from unknown"\r\n" opcode while ERL=0, closing iSCSI connection.\n");\r\nreturn -1;\r\n}\r\npr_err("Unable to recover from unknown opcode while OFMarker=No,"\r\n" closing iSCSI connection.\n");\r\nret = -1;\r\nbreak;\r\n}\r\nreturn ret;\r\nreject:\r\nreturn iscsit_add_reject(conn, ISCSI_REASON_BOOKMARK_NO_RESOURCES, buf);\r\n}\r\nstatic bool iscsi_target_check_conn_state(struct iscsi_conn *conn)\r\n{\r\nbool ret;\r\nspin_lock_bh(&conn->state_lock);\r\nret = (conn->conn_state != TARG_CONN_STATE_LOGGED_IN);\r\nspin_unlock_bh(&conn->state_lock);\r\nreturn ret;\r\n}\r\nstatic void iscsit_get_rx_pdu(struct iscsi_conn *conn)\r\n{\r\nint ret;\r\nu8 buffer[ISCSI_HDR_LEN], opcode;\r\nu32 checksum = 0, digest = 0;\r\nstruct kvec iov;\r\nwhile (!kthread_should_stop()) {\r\niscsit_thread_check_cpumask(conn, current, 0);\r\nmemset(buffer, 0, ISCSI_HDR_LEN);\r\nmemset(&iov, 0, sizeof(struct kvec));\r\niov.iov_base = buffer;\r\niov.iov_len = ISCSI_HDR_LEN;\r\nret = rx_data(conn, &iov, 1, ISCSI_HDR_LEN);\r\nif (ret != ISCSI_HDR_LEN) {\r\niscsit_rx_thread_wait_for_tcp(conn);\r\nreturn;\r\n}\r\nif (conn->conn_ops->HeaderDigest) {\r\niov.iov_base = &digest;\r\niov.iov_len = ISCSI_CRC_LEN;\r\nret = rx_data(conn, &iov, 1, ISCSI_CRC_LEN);\r\nif (ret != ISCSI_CRC_LEN) {\r\niscsit_rx_thread_wait_for_tcp(conn);\r\nreturn;\r\n}\r\niscsit_do_crypto_hash_buf(conn->conn_rx_hash,\r\nbuffer, ISCSI_HDR_LEN,\r\n0, NULL, (u8 *)&checksum);\r\nif (digest != checksum) {\r\npr_err("HeaderDigest CRC32C failed,"\r\n" received 0x%08x, computed 0x%08x\n",\r\ndigest, checksum);\r\nmemset(buffer, 0xff, ISCSI_HDR_LEN);\r\natomic_long_inc(&conn->sess->conn_digest_errors);\r\n} else {\r\npr_debug("Got HeaderDigest CRC32C"\r\n" 0x%08x\n", checksum);\r\n}\r\n}\r\nif (conn->conn_state == TARG_CONN_STATE_IN_LOGOUT)\r\nreturn;\r\nopcode = buffer[0] & ISCSI_OPCODE_MASK;\r\nif (conn->sess->sess_ops->SessionType &&\r\n((!(opcode & ISCSI_OP_TEXT)) ||\r\n(!(opcode & ISCSI_OP_LOGOUT)))) {\r\npr_err("Received illegal iSCSI Opcode: 0x%02x"\r\n" while in Discovery Session, rejecting.\n", opcode);\r\niscsit_add_reject(conn, ISCSI_REASON_PROTOCOL_ERROR,\r\nbuffer);\r\nreturn;\r\n}\r\nret = iscsi_target_rx_opcode(conn, buffer);\r\nif (ret < 0)\r\nreturn;\r\n}\r\n}\r\nint iscsi_target_rx_thread(void *arg)\r\n{\r\nint rc;\r\nstruct iscsi_conn *conn = arg;\r\nbool conn_freed = false;\r\nallow_signal(SIGINT);\r\nrc = wait_for_completion_interruptible(&conn->rx_login_comp);\r\nif (rc < 0 || iscsi_target_check_conn_state(conn))\r\ngoto out;\r\nif (!conn->conn_transport->iscsit_get_rx_pdu)\r\nreturn 0;\r\nconn->conn_transport->iscsit_get_rx_pdu(conn);\r\nif (!signal_pending(current))\r\natomic_set(&conn->transport_failed, 1);\r\niscsit_take_action_for_connection_exit(conn, &conn_freed);\r\nout:\r\nif (!conn_freed) {\r\nwhile (!kthread_should_stop()) {\r\nmsleep(100);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void iscsit_release_commands_from_conn(struct iscsi_conn *conn)\r\n{\r\nLIST_HEAD(tmp_list);\r\nstruct iscsi_cmd *cmd = NULL, *cmd_tmp = NULL;\r\nstruct iscsi_session *sess = conn->sess;\r\nspin_lock_bh(&conn->cmd_lock);\r\nlist_splice_init(&conn->conn_cmd_list, &tmp_list);\r\nlist_for_each_entry(cmd, &tmp_list, i_conn_node) {\r\nstruct se_cmd *se_cmd = &cmd->se_cmd;\r\nif (se_cmd->se_tfo != NULL) {\r\nspin_lock(&se_cmd->t_state_lock);\r\nse_cmd->transport_state |= CMD_T_FABRIC_STOP;\r\nspin_unlock(&se_cmd->t_state_lock);\r\n}\r\n}\r\nspin_unlock_bh(&conn->cmd_lock);\r\nlist_for_each_entry_safe(cmd, cmd_tmp, &tmp_list, i_conn_node) {\r\nlist_del_init(&cmd->i_conn_node);\r\niscsit_increment_maxcmdsn(cmd, sess);\r\niscsit_free_cmd(cmd, true);\r\n}\r\n}\r\nstatic void iscsit_stop_timers_for_cmds(\r\nstruct iscsi_conn *conn)\r\n{\r\nstruct iscsi_cmd *cmd;\r\nspin_lock_bh(&conn->cmd_lock);\r\nlist_for_each_entry(cmd, &conn->conn_cmd_list, i_conn_node) {\r\nif (cmd->data_direction == DMA_TO_DEVICE)\r\niscsit_stop_dataout_timer(cmd);\r\n}\r\nspin_unlock_bh(&conn->cmd_lock);\r\n}\r\nint iscsit_close_connection(\r\nstruct iscsi_conn *conn)\r\n{\r\nint conn_logout = (conn->conn_state == TARG_CONN_STATE_IN_LOGOUT);\r\nstruct iscsi_session *sess = conn->sess;\r\npr_debug("Closing iSCSI connection CID %hu on SID:"\r\n" %u\n", conn->cid, sess->sid);\r\nif (!conn->conn_transport->rdma_shutdown)\r\ncomplete(&conn->conn_logout_comp);\r\nif (!strcmp(current->comm, ISCSI_RX_THREAD_NAME)) {\r\nif (conn->tx_thread &&\r\ncmpxchg(&conn->tx_thread_active, true, false)) {\r\nsend_sig(SIGINT, conn->tx_thread, 1);\r\nkthread_stop(conn->tx_thread);\r\n}\r\n} else if (!strcmp(current->comm, ISCSI_TX_THREAD_NAME)) {\r\nif (conn->rx_thread &&\r\ncmpxchg(&conn->rx_thread_active, true, false)) {\r\nsend_sig(SIGINT, conn->rx_thread, 1);\r\nkthread_stop(conn->rx_thread);\r\n}\r\n}\r\nspin_lock(&iscsit_global->ts_bitmap_lock);\r\nbitmap_release_region(iscsit_global->ts_bitmap, conn->bitmap_id,\r\nget_order(1));\r\nspin_unlock(&iscsit_global->ts_bitmap_lock);\r\niscsit_stop_timers_for_cmds(conn);\r\niscsit_stop_nopin_response_timer(conn);\r\niscsit_stop_nopin_timer(conn);\r\nif (conn->conn_transport->iscsit_wait_conn)\r\nconn->conn_transport->iscsit_wait_conn(conn);\r\nif (atomic_read(&conn->connection_recovery)) {\r\niscsit_discard_unacknowledged_ooo_cmdsns_for_conn(conn);\r\niscsit_prepare_cmds_for_reallegiance(conn);\r\n} else {\r\niscsit_clear_ooo_cmdsns_for_conn(conn);\r\niscsit_release_commands_from_conn(conn);\r\n}\r\niscsit_free_queue_reqs_for_conn(conn);\r\nif (atomic_read(&conn->conn_logout_remove)) {\r\nif (conn->conn_logout_reason == ISCSI_LOGOUT_REASON_CLOSE_SESSION) {\r\niscsit_dec_conn_usage_count(conn);\r\niscsit_dec_session_usage_count(sess);\r\n}\r\nif (conn->conn_logout_reason == ISCSI_LOGOUT_REASON_CLOSE_CONNECTION)\r\niscsit_dec_conn_usage_count(conn);\r\natomic_set(&conn->conn_logout_remove, 0);\r\natomic_set(&sess->session_reinstatement, 0);\r\natomic_set(&sess->session_fall_back_to_erl0, 1);\r\n}\r\nspin_lock_bh(&sess->conn_lock);\r\nlist_del(&conn->conn_list);\r\nif (atomic_read(&conn->connection_recovery))\r\niscsit_build_conn_drop_async_message(conn);\r\nspin_unlock_bh(&sess->conn_lock);\r\nspin_lock_bh(&conn->state_lock);\r\nif (atomic_read(&conn->sleep_on_conn_wait_comp)) {\r\nspin_unlock_bh(&conn->state_lock);\r\ncomplete(&conn->conn_wait_comp);\r\nwait_for_completion(&conn->conn_post_wait_comp);\r\nspin_lock_bh(&conn->state_lock);\r\n}\r\nif (atomic_read(&conn->connection_wait_rcfr)) {\r\nspin_unlock_bh(&conn->state_lock);\r\ncomplete(&conn->conn_wait_rcfr_comp);\r\nwait_for_completion(&conn->conn_post_wait_comp);\r\nspin_lock_bh(&conn->state_lock);\r\n}\r\natomic_set(&conn->connection_reinstatement, 1);\r\nspin_unlock_bh(&conn->state_lock);\r\niscsit_check_conn_usage_count(conn);\r\nahash_request_free(conn->conn_tx_hash);\r\nif (conn->conn_rx_hash) {\r\nstruct crypto_ahash *tfm;\r\ntfm = crypto_ahash_reqtfm(conn->conn_rx_hash);\r\nahash_request_free(conn->conn_rx_hash);\r\ncrypto_free_ahash(tfm);\r\n}\r\nfree_cpumask_var(conn->conn_cpumask);\r\nkfree(conn->conn_ops);\r\nconn->conn_ops = NULL;\r\nif (conn->sock)\r\nsock_release(conn->sock);\r\nif (conn->conn_transport->iscsit_free_conn)\r\nconn->conn_transport->iscsit_free_conn(conn);\r\niscsit_put_transport(conn->conn_transport);\r\npr_debug("Moving to TARG_CONN_STATE_FREE.\n");\r\nconn->conn_state = TARG_CONN_STATE_FREE;\r\nkfree(conn);\r\nspin_lock_bh(&sess->conn_lock);\r\natomic_dec(&sess->nconn);\r\npr_debug("Decremented iSCSI connection count to %hu from node:"\r\n" %s\n", atomic_read(&sess->nconn),\r\nsess->sess_ops->InitiatorName);\r\nif ((sess->sess_ops->ErrorRecoveryLevel != 2) && !conn_logout &&\r\n!atomic_read(&sess->session_logout))\r\natomic_set(&sess->session_fall_back_to_erl0, 1);\r\nif (atomic_read(&sess->nconn)) {\r\nif (!atomic_read(&sess->session_reinstatement) &&\r\n!atomic_read(&sess->session_fall_back_to_erl0)) {\r\nspin_unlock_bh(&sess->conn_lock);\r\nreturn 0;\r\n}\r\nif (!atomic_read(&sess->session_stop_active)) {\r\natomic_set(&sess->session_stop_active, 1);\r\nspin_unlock_bh(&sess->conn_lock);\r\niscsit_stop_session(sess, 0, 0);\r\nreturn 0;\r\n}\r\nspin_unlock_bh(&sess->conn_lock);\r\nreturn 0;\r\n}\r\nif (!atomic_read(&sess->session_reinstatement) &&\r\natomic_read(&sess->session_fall_back_to_erl0)) {\r\nspin_unlock_bh(&sess->conn_lock);\r\niscsit_close_session(sess);\r\nreturn 0;\r\n} else if (atomic_read(&sess->session_logout)) {\r\npr_debug("Moving to TARG_SESS_STATE_FREE.\n");\r\nsess->session_state = TARG_SESS_STATE_FREE;\r\nspin_unlock_bh(&sess->conn_lock);\r\nif (atomic_read(&sess->sleep_on_sess_wait_comp))\r\ncomplete(&sess->session_wait_comp);\r\nreturn 0;\r\n} else {\r\npr_debug("Moving to TARG_SESS_STATE_FAILED.\n");\r\nsess->session_state = TARG_SESS_STATE_FAILED;\r\nif (!atomic_read(&sess->session_continuation)) {\r\nspin_unlock_bh(&sess->conn_lock);\r\niscsit_start_time2retain_handler(sess);\r\n} else\r\nspin_unlock_bh(&sess->conn_lock);\r\nif (atomic_read(&sess->sleep_on_sess_wait_comp))\r\ncomplete(&sess->session_wait_comp);\r\nreturn 0;\r\n}\r\n}\r\nint iscsit_close_session(struct iscsi_session *sess)\r\n{\r\nstruct iscsi_portal_group *tpg = sess->tpg;\r\nstruct se_portal_group *se_tpg = &tpg->tpg_se_tpg;\r\nif (atomic_read(&sess->nconn)) {\r\npr_err("%d connection(s) still exist for iSCSI session"\r\n" to %s\n", atomic_read(&sess->nconn),\r\nsess->sess_ops->InitiatorName);\r\nBUG();\r\n}\r\nspin_lock_bh(&se_tpg->session_lock);\r\natomic_set(&sess->session_logout, 1);\r\natomic_set(&sess->session_reinstatement, 1);\r\niscsit_stop_time2retain_timer(sess);\r\nspin_unlock_bh(&se_tpg->session_lock);\r\ntransport_deregister_session_configfs(sess->se_sess);\r\nif (!in_interrupt()) {\r\nif (iscsit_check_session_usage_count(sess) == 1)\r\niscsit_stop_session(sess, 1, 1);\r\n} else {\r\nif (iscsit_check_session_usage_count(sess) == 2) {\r\natomic_set(&sess->session_logout, 0);\r\niscsit_start_time2retain_handler(sess);\r\nreturn 0;\r\n}\r\n}\r\ntransport_deregister_session(sess->se_sess);\r\nif (sess->sess_ops->ErrorRecoveryLevel == 2)\r\niscsit_free_connection_recovery_entires(sess);\r\niscsit_free_all_ooo_cmdsns(sess);\r\nspin_lock_bh(&se_tpg->session_lock);\r\npr_debug("Moving to TARG_SESS_STATE_FREE.\n");\r\nsess->session_state = TARG_SESS_STATE_FREE;\r\npr_debug("Released iSCSI session from node: %s\n",\r\nsess->sess_ops->InitiatorName);\r\ntpg->nsessions--;\r\nif (tpg->tpg_tiqn)\r\ntpg->tpg_tiqn->tiqn_nsessions--;\r\npr_debug("Decremented number of active iSCSI Sessions on"\r\n" iSCSI TPG: %hu to %u\n", tpg->tpgt, tpg->nsessions);\r\nspin_lock(&sess_idr_lock);\r\nidr_remove(&sess_idr, sess->session_index);\r\nspin_unlock(&sess_idr_lock);\r\nkfree(sess->sess_ops);\r\nsess->sess_ops = NULL;\r\nspin_unlock_bh(&se_tpg->session_lock);\r\nkfree(sess);\r\nreturn 0;\r\n}\r\nstatic void iscsit_logout_post_handler_closesession(\r\nstruct iscsi_conn *conn)\r\n{\r\nstruct iscsi_session *sess = conn->sess;\r\nint sleep = 1;\r\nif (!conn->conn_transport->rdma_shutdown) {\r\nsleep = cmpxchg(&conn->tx_thread_active, true, false);\r\nif (!sleep)\r\nreturn;\r\n}\r\natomic_set(&conn->conn_logout_remove, 0);\r\ncomplete(&conn->conn_logout_comp);\r\niscsit_dec_conn_usage_count(conn);\r\niscsit_stop_session(sess, sleep, sleep);\r\niscsit_dec_session_usage_count(sess);\r\niscsit_close_session(sess);\r\n}\r\nstatic void iscsit_logout_post_handler_samecid(\r\nstruct iscsi_conn *conn)\r\n{\r\nint sleep = 1;\r\nif (!conn->conn_transport->rdma_shutdown) {\r\nsleep = cmpxchg(&conn->tx_thread_active, true, false);\r\nif (!sleep)\r\nreturn;\r\n}\r\natomic_set(&conn->conn_logout_remove, 0);\r\ncomplete(&conn->conn_logout_comp);\r\niscsit_cause_connection_reinstatement(conn, sleep);\r\niscsit_dec_conn_usage_count(conn);\r\n}\r\nstatic void iscsit_logout_post_handler_diffcid(\r\nstruct iscsi_conn *conn,\r\nu16 cid)\r\n{\r\nstruct iscsi_conn *l_conn;\r\nstruct iscsi_session *sess = conn->sess;\r\nbool conn_found = false;\r\nif (!sess)\r\nreturn;\r\nspin_lock_bh(&sess->conn_lock);\r\nlist_for_each_entry(l_conn, &sess->sess_conn_list, conn_list) {\r\nif (l_conn->cid == cid) {\r\niscsit_inc_conn_usage_count(l_conn);\r\nconn_found = true;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_bh(&sess->conn_lock);\r\nif (!conn_found)\r\nreturn;\r\nif (l_conn->sock)\r\nl_conn->sock->ops->shutdown(l_conn->sock, RCV_SHUTDOWN);\r\nspin_lock_bh(&l_conn->state_lock);\r\npr_debug("Moving to TARG_CONN_STATE_IN_LOGOUT.\n");\r\nl_conn->conn_state = TARG_CONN_STATE_IN_LOGOUT;\r\nspin_unlock_bh(&l_conn->state_lock);\r\niscsit_cause_connection_reinstatement(l_conn, 1);\r\niscsit_dec_conn_usage_count(l_conn);\r\n}\r\nint iscsit_logout_post_handler(\r\nstruct iscsi_cmd *cmd,\r\nstruct iscsi_conn *conn)\r\n{\r\nint ret = 0;\r\nswitch (cmd->logout_reason) {\r\ncase ISCSI_LOGOUT_REASON_CLOSE_SESSION:\r\nswitch (cmd->logout_response) {\r\ncase ISCSI_LOGOUT_SUCCESS:\r\ncase ISCSI_LOGOUT_CLEANUP_FAILED:\r\ndefault:\r\niscsit_logout_post_handler_closesession(conn);\r\nbreak;\r\n}\r\nret = 0;\r\nbreak;\r\ncase ISCSI_LOGOUT_REASON_CLOSE_CONNECTION:\r\nif (conn->cid == cmd->logout_cid) {\r\nswitch (cmd->logout_response) {\r\ncase ISCSI_LOGOUT_SUCCESS:\r\ncase ISCSI_LOGOUT_CLEANUP_FAILED:\r\ndefault:\r\niscsit_logout_post_handler_samecid(conn);\r\nbreak;\r\n}\r\nret = 0;\r\n} else {\r\nswitch (cmd->logout_response) {\r\ncase ISCSI_LOGOUT_SUCCESS:\r\niscsit_logout_post_handler_diffcid(conn,\r\ncmd->logout_cid);\r\nbreak;\r\ncase ISCSI_LOGOUT_CID_NOT_FOUND:\r\ncase ISCSI_LOGOUT_CLEANUP_FAILED:\r\ndefault:\r\nbreak;\r\n}\r\nret = 1;\r\n}\r\nbreak;\r\ncase ISCSI_LOGOUT_REASON_RECOVERY:\r\nswitch (cmd->logout_response) {\r\ncase ISCSI_LOGOUT_SUCCESS:\r\ncase ISCSI_LOGOUT_CID_NOT_FOUND:\r\ncase ISCSI_LOGOUT_RECOVERY_UNSUPPORTED:\r\ncase ISCSI_LOGOUT_CLEANUP_FAILED:\r\ndefault:\r\nbreak;\r\n}\r\nret = 1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nvoid iscsit_fail_session(struct iscsi_session *sess)\r\n{\r\nstruct iscsi_conn *conn;\r\nspin_lock_bh(&sess->conn_lock);\r\nlist_for_each_entry(conn, &sess->sess_conn_list, conn_list) {\r\npr_debug("Moving to TARG_CONN_STATE_CLEANUP_WAIT.\n");\r\nconn->conn_state = TARG_CONN_STATE_CLEANUP_WAIT;\r\n}\r\nspin_unlock_bh(&sess->conn_lock);\r\npr_debug("Moving to TARG_SESS_STATE_FAILED.\n");\r\nsess->session_state = TARG_SESS_STATE_FAILED;\r\n}\r\nint iscsit_free_session(struct iscsi_session *sess)\r\n{\r\nu16 conn_count = atomic_read(&sess->nconn);\r\nstruct iscsi_conn *conn, *conn_tmp = NULL;\r\nint is_last;\r\nspin_lock_bh(&sess->conn_lock);\r\natomic_set(&sess->sleep_on_sess_wait_comp, 1);\r\nlist_for_each_entry_safe(conn, conn_tmp, &sess->sess_conn_list,\r\nconn_list) {\r\nif (conn_count == 0)\r\nbreak;\r\nif (list_is_last(&conn->conn_list, &sess->sess_conn_list)) {\r\nis_last = 1;\r\n} else {\r\niscsit_inc_conn_usage_count(conn_tmp);\r\nis_last = 0;\r\n}\r\niscsit_inc_conn_usage_count(conn);\r\nspin_unlock_bh(&sess->conn_lock);\r\niscsit_cause_connection_reinstatement(conn, 1);\r\nspin_lock_bh(&sess->conn_lock);\r\niscsit_dec_conn_usage_count(conn);\r\nif (is_last == 0)\r\niscsit_dec_conn_usage_count(conn_tmp);\r\nconn_count--;\r\n}\r\nif (atomic_read(&sess->nconn)) {\r\nspin_unlock_bh(&sess->conn_lock);\r\nwait_for_completion(&sess->session_wait_comp);\r\n} else\r\nspin_unlock_bh(&sess->conn_lock);\r\niscsit_close_session(sess);\r\nreturn 0;\r\n}\r\nvoid iscsit_stop_session(\r\nstruct iscsi_session *sess,\r\nint session_sleep,\r\nint connection_sleep)\r\n{\r\nu16 conn_count = atomic_read(&sess->nconn);\r\nstruct iscsi_conn *conn, *conn_tmp = NULL;\r\nint is_last;\r\nspin_lock_bh(&sess->conn_lock);\r\nif (session_sleep)\r\natomic_set(&sess->sleep_on_sess_wait_comp, 1);\r\nif (connection_sleep) {\r\nlist_for_each_entry_safe(conn, conn_tmp, &sess->sess_conn_list,\r\nconn_list) {\r\nif (conn_count == 0)\r\nbreak;\r\nif (list_is_last(&conn->conn_list, &sess->sess_conn_list)) {\r\nis_last = 1;\r\n} else {\r\niscsit_inc_conn_usage_count(conn_tmp);\r\nis_last = 0;\r\n}\r\niscsit_inc_conn_usage_count(conn);\r\nspin_unlock_bh(&sess->conn_lock);\r\niscsit_cause_connection_reinstatement(conn, 1);\r\nspin_lock_bh(&sess->conn_lock);\r\niscsit_dec_conn_usage_count(conn);\r\nif (is_last == 0)\r\niscsit_dec_conn_usage_count(conn_tmp);\r\nconn_count--;\r\n}\r\n} else {\r\nlist_for_each_entry(conn, &sess->sess_conn_list, conn_list)\r\niscsit_cause_connection_reinstatement(conn, 0);\r\n}\r\nif (session_sleep && atomic_read(&sess->nconn)) {\r\nspin_unlock_bh(&sess->conn_lock);\r\nwait_for_completion(&sess->session_wait_comp);\r\n} else\r\nspin_unlock_bh(&sess->conn_lock);\r\n}\r\nint iscsit_release_sessions_for_tpg(struct iscsi_portal_group *tpg, int force)\r\n{\r\nstruct iscsi_session *sess;\r\nstruct se_portal_group *se_tpg = &tpg->tpg_se_tpg;\r\nstruct se_session *se_sess, *se_sess_tmp;\r\nLIST_HEAD(free_list);\r\nint session_count = 0;\r\nspin_lock_bh(&se_tpg->session_lock);\r\nif (tpg->nsessions && !force) {\r\nspin_unlock_bh(&se_tpg->session_lock);\r\nreturn -1;\r\n}\r\nlist_for_each_entry_safe(se_sess, se_sess_tmp, &se_tpg->tpg_sess_list,\r\nsess_list) {\r\nsess = (struct iscsi_session *)se_sess->fabric_sess_ptr;\r\nspin_lock(&sess->conn_lock);\r\nif (atomic_read(&sess->session_fall_back_to_erl0) ||\r\natomic_read(&sess->session_logout) ||\r\n(sess->time2retain_timer_flags & ISCSI_TF_EXPIRED)) {\r\nspin_unlock(&sess->conn_lock);\r\ncontinue;\r\n}\r\natomic_set(&sess->session_reinstatement, 1);\r\natomic_set(&sess->session_fall_back_to_erl0, 1);\r\nspin_unlock(&sess->conn_lock);\r\nlist_move_tail(&se_sess->sess_list, &free_list);\r\n}\r\nspin_unlock_bh(&se_tpg->session_lock);\r\nlist_for_each_entry_safe(se_sess, se_sess_tmp, &free_list, sess_list) {\r\nsess = (struct iscsi_session *)se_sess->fabric_sess_ptr;\r\niscsit_free_session(sess);\r\nsession_count++;\r\n}\r\npr_debug("Released %d iSCSI Session(s) from Target Portal"\r\n" Group: %hu\n", session_count, tpg->tpgt);\r\nreturn 0;\r\n}
