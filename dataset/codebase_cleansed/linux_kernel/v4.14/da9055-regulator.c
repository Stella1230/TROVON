static unsigned int da9055_buck_get_mode(struct regulator_dev *rdev)\r\n{\r\nstruct da9055_regulator *regulator = rdev_get_drvdata(rdev);\r\nstruct da9055_regulator_info *info = regulator->info;\r\nint ret, mode = 0;\r\nret = da9055_reg_read(regulator->da9055, info->mode.reg);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch ((ret & info->mode.mask) >> info->mode.shift) {\r\ncase DA9055_BUCK_MODE_SYNC:\r\nmode = REGULATOR_MODE_FAST;\r\nbreak;\r\ncase DA9055_BUCK_MODE_AUTO:\r\nmode = REGULATOR_MODE_NORMAL;\r\nbreak;\r\ncase DA9055_BUCK_MODE_SLEEP:\r\nmode = REGULATOR_MODE_STANDBY;\r\nbreak;\r\n}\r\nreturn mode;\r\n}\r\nstatic int da9055_buck_set_mode(struct regulator_dev *rdev,\r\nunsigned int mode)\r\n{\r\nstruct da9055_regulator *regulator = rdev_get_drvdata(rdev);\r\nstruct da9055_regulator_info *info = regulator->info;\r\nint val = 0;\r\nswitch (mode) {\r\ncase REGULATOR_MODE_FAST:\r\nval = DA9055_BUCK_MODE_SYNC << info->mode.shift;\r\nbreak;\r\ncase REGULATOR_MODE_NORMAL:\r\nval = DA9055_BUCK_MODE_AUTO << info->mode.shift;\r\nbreak;\r\ncase REGULATOR_MODE_STANDBY:\r\nval = DA9055_BUCK_MODE_SLEEP << info->mode.shift;\r\nbreak;\r\n}\r\nreturn da9055_reg_update(regulator->da9055, info->mode.reg,\r\ninfo->mode.mask, val);\r\n}\r\nstatic unsigned int da9055_ldo_get_mode(struct regulator_dev *rdev)\r\n{\r\nstruct da9055_regulator *regulator = rdev_get_drvdata(rdev);\r\nstruct da9055_regulator_info *info = regulator->info;\r\nint ret;\r\nret = da9055_reg_read(regulator->da9055, info->volt.reg_b);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret >> info->volt.sl_shift)\r\nreturn REGULATOR_MODE_STANDBY;\r\nelse\r\nreturn REGULATOR_MODE_NORMAL;\r\n}\r\nstatic int da9055_ldo_set_mode(struct regulator_dev *rdev, unsigned int mode)\r\n{\r\nstruct da9055_regulator *regulator = rdev_get_drvdata(rdev);\r\nstruct da9055_regulator_info *info = regulator->info;\r\nstruct da9055_volt_reg volt = info->volt;\r\nint val = 0;\r\nswitch (mode) {\r\ncase REGULATOR_MODE_NORMAL:\r\ncase REGULATOR_MODE_FAST:\r\nval = DA9055_LDO_MODE_SYNC;\r\nbreak;\r\ncase REGULATOR_MODE_STANDBY:\r\nval = DA9055_LDO_MODE_SLEEP;\r\nbreak;\r\n}\r\nreturn da9055_reg_update(regulator->da9055, volt.reg_b,\r\n1 << volt.sl_shift,\r\nval << volt.sl_shift);\r\n}\r\nstatic int da9055_buck_get_current_limit(struct regulator_dev *rdev)\r\n{\r\nstruct da9055_regulator *regulator = rdev_get_drvdata(rdev);\r\nstruct da9055_regulator_info *info = regulator->info;\r\nint ret;\r\nret = da9055_reg_read(regulator->da9055, DA9055_REG_BUCK_LIM);\r\nif (ret < 0)\r\nreturn ret;\r\nret &= info->mode.mask;\r\nreturn da9055_current_limits[ret >> info->mode.shift];\r\n}\r\nstatic int da9055_buck_set_current_limit(struct regulator_dev *rdev, int min_uA,\r\nint max_uA)\r\n{\r\nstruct da9055_regulator *regulator = rdev_get_drvdata(rdev);\r\nstruct da9055_regulator_info *info = regulator->info;\r\nint i;\r\nfor (i = ARRAY_SIZE(da9055_current_limits) - 1; i >= 0; i--) {\r\nif ((min_uA <= da9055_current_limits[i]) &&\r\n(da9055_current_limits[i] <= max_uA))\r\nreturn da9055_reg_update(regulator->da9055,\r\nDA9055_REG_BUCK_LIM,\r\ninfo->mode.mask,\r\ni << info->mode.shift);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int da9055_regulator_get_voltage_sel(struct regulator_dev *rdev)\r\n{\r\nstruct da9055_regulator *regulator = rdev_get_drvdata(rdev);\r\nstruct da9055_regulator_info *info = regulator->info;\r\nstruct da9055_volt_reg volt = info->volt;\r\nint ret, sel;\r\nret = da9055_reg_read(regulator->da9055, info->conf.reg);\r\nif (ret < 0)\r\nreturn ret;\r\nret &= info->conf.sel_mask;\r\nif (ret == DA9055_REGUALTOR_SET_A)\r\nret = da9055_reg_read(regulator->da9055, volt.reg_a);\r\nelse\r\nret = da9055_reg_read(regulator->da9055, volt.reg_b);\r\nif (ret < 0)\r\nreturn ret;\r\nsel = (ret & volt.v_mask);\r\nreturn sel;\r\n}\r\nstatic int da9055_regulator_set_voltage_sel(struct regulator_dev *rdev,\r\nunsigned int selector)\r\n{\r\nstruct da9055_regulator *regulator = rdev_get_drvdata(rdev);\r\nstruct da9055_regulator_info *info = regulator->info;\r\nint ret;\r\nif (regulator->reg_rselect == NO_GPIO) {\r\nret = da9055_reg_update(regulator->da9055, info->conf.reg,\r\ninfo->conf.sel_mask, DA9055_SEL_REG_A);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn da9055_reg_update(regulator->da9055, info->volt.reg_a,\r\ninfo->volt.v_mask, selector);\r\n}\r\nret = da9055_reg_read(regulator->da9055, info->conf.reg);\r\nif (ret < 0)\r\nreturn ret;\r\nret &= info->conf.sel_mask;\r\nif (ret == DA9055_REGUALTOR_SET_A)\r\nreturn da9055_reg_update(regulator->da9055, info->volt.reg_a,\r\ninfo->volt.v_mask, selector);\r\nelse\r\nreturn da9055_reg_update(regulator->da9055, info->volt.reg_b,\r\ninfo->volt.v_mask, selector);\r\n}\r\nstatic int da9055_regulator_set_suspend_voltage(struct regulator_dev *rdev,\r\nint uV)\r\n{\r\nstruct da9055_regulator *regulator = rdev_get_drvdata(rdev);\r\nstruct da9055_regulator_info *info = regulator->info;\r\nint ret;\r\nif (regulator->reg_rselect == NO_GPIO) {\r\nret = da9055_reg_update(regulator->da9055, info->conf.reg,\r\ninfo->conf.sel_mask, DA9055_SEL_REG_B);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nret = regulator_map_voltage_linear(rdev, uV, uV);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn da9055_reg_update(regulator->da9055, info->volt.reg_b,\r\ninfo->volt.v_mask, ret);\r\n}\r\nstatic int da9055_suspend_enable(struct regulator_dev *rdev)\r\n{\r\nstruct da9055_regulator *regulator = rdev_get_drvdata(rdev);\r\nstruct da9055_regulator_info *info = regulator->info;\r\nif (regulator->reg_rselect == NO_GPIO)\r\nreturn da9055_reg_update(regulator->da9055, info->conf.reg,\r\ninfo->conf.sel_mask, DA9055_SEL_REG_B);\r\nelse\r\nreturn 0;\r\n}\r\nstatic int da9055_suspend_disable(struct regulator_dev *rdev)\r\n{\r\nstruct da9055_regulator *regulator = rdev_get_drvdata(rdev);\r\nstruct da9055_regulator_info *info = regulator->info;\r\nif (regulator->reg_rselect == NO_GPIO)\r\nreturn da9055_reg_update(regulator->da9055, info->conf.reg,\r\ninfo->conf.sel_mask, DA9055_SEL_REG_A);\r\nelse\r\nreturn 0;\r\n}\r\nstatic int da9055_gpio_init(struct da9055_regulator *regulator,\r\nstruct regulator_config *config,\r\nstruct da9055_pdata *pdata, int id)\r\n{\r\nstruct da9055_regulator_info *info = regulator->info;\r\nint ret = 0;\r\nif (!pdata)\r\nreturn 0;\r\nif (pdata->gpio_ren && pdata->gpio_ren[id]) {\r\nchar name[18];\r\nint gpio_mux = pdata->gpio_ren[id];\r\nconfig->ena_gpio = pdata->ena_gpio[id];\r\nconfig->ena_gpio_flags = GPIOF_OUT_INIT_HIGH;\r\nconfig->ena_gpio_invert = 1;\r\nsprintf(name, "DA9055 GPI %d", gpio_mux);\r\nret = devm_gpio_request_one(config->dev, gpio_mux, GPIOF_DIR_IN,\r\nname);\r\nif (ret < 0)\r\ngoto err;\r\nret = da9055_reg_update(regulator->da9055, info->conf.reg,\r\nDA9055_E_GPI_MASK,\r\npdata->reg_ren[id]\r\n<< DA9055_E_GPI_SHIFT);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nif (pdata->gpio_rsel && pdata->gpio_rsel[id]) {\r\nchar name[18];\r\nint gpio_mux = pdata->gpio_rsel[id];\r\nregulator->reg_rselect = pdata->reg_rsel[id];\r\nsprintf(name, "DA9055 GPI %d", gpio_mux);\r\nret = devm_gpio_request_one(config->dev, gpio_mux, GPIOF_DIR_IN,\r\nname);\r\nif (ret < 0)\r\ngoto err;\r\nret = da9055_reg_update(regulator->da9055, info->conf.reg,\r\nDA9055_V_GPI_MASK,\r\npdata->reg_rsel[id]\r\n<< DA9055_V_GPI_SHIFT);\r\n}\r\nerr:\r\nreturn ret;\r\n}\r\nstatic irqreturn_t da9055_ldo5_6_oc_irq(int irq, void *data)\r\n{\r\nstruct da9055_regulator *regulator = data;\r\nregulator_notifier_call_chain(regulator->rdev,\r\nREGULATOR_EVENT_OVER_CURRENT, NULL);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic inline struct da9055_regulator_info *find_regulator_info(int id)\r\n{\r\nstruct da9055_regulator_info *info;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(da9055_regulator_info); i++) {\r\ninfo = &da9055_regulator_info[i];\r\nif (info->reg_desc.id == id)\r\nreturn info;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int da9055_regulator_dt_init(struct platform_device *pdev,\r\nstruct da9055_regulator *regulator,\r\nstruct regulator_config *config,\r\nint regid)\r\n{\r\nstruct device_node *nproot, *np;\r\nint ret;\r\nnproot = of_node_get(pdev->dev.parent->of_node);\r\nif (!nproot)\r\nreturn -ENODEV;\r\nnp = of_get_child_by_name(nproot, "regulators");\r\nif (!np)\r\nreturn -ENODEV;\r\nret = of_regulator_match(&pdev->dev, np, &da9055_reg_matches[regid], 1);\r\nof_node_put(nproot);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Error matching regulator: %d\n", ret);\r\nreturn ret;\r\n}\r\nconfig->init_data = da9055_reg_matches[regid].init_data;\r\nconfig->of_node = da9055_reg_matches[regid].of_node;\r\nif (!config->of_node)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic inline int da9055_regulator_dt_init(struct platform_device *pdev,\r\nstruct da9055_regulator *regulator,\r\nstruct regulator_config *config,\r\nint regid)\r\n{\r\nreturn -ENODEV;\r\n}\r\nstatic int da9055_regulator_probe(struct platform_device *pdev)\r\n{\r\nstruct regulator_config config = { };\r\nstruct da9055_regulator *regulator;\r\nstruct da9055 *da9055 = dev_get_drvdata(pdev->dev.parent);\r\nstruct da9055_pdata *pdata = dev_get_platdata(da9055->dev);\r\nint ret, irq;\r\nregulator = devm_kzalloc(&pdev->dev, sizeof(struct da9055_regulator),\r\nGFP_KERNEL);\r\nif (!regulator)\r\nreturn -ENOMEM;\r\nregulator->info = find_regulator_info(pdev->id);\r\nif (regulator->info == NULL) {\r\ndev_err(&pdev->dev, "invalid regulator ID specified\n");\r\nreturn -EINVAL;\r\n}\r\nregulator->da9055 = da9055;\r\nconfig.dev = &pdev->dev;\r\nconfig.driver_data = regulator;\r\nconfig.regmap = da9055->regmap;\r\nif (pdata && pdata->regulators) {\r\nconfig.init_data = pdata->regulators[pdev->id];\r\n} else {\r\nret = da9055_regulator_dt_init(pdev, regulator, &config,\r\npdev->id);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nret = da9055_gpio_init(regulator, &config, pdata, pdev->id);\r\nif (ret < 0)\r\nreturn ret;\r\nregulator->rdev = devm_regulator_register(&pdev->dev,\r\n&regulator->info->reg_desc,\r\n&config);\r\nif (IS_ERR(regulator->rdev)) {\r\ndev_err(&pdev->dev, "Failed to register regulator %s\n",\r\nregulator->info->reg_desc.name);\r\nreturn PTR_ERR(regulator->rdev);\r\n}\r\nif (pdev->id == DA9055_ID_LDO5 || pdev->id == DA9055_ID_LDO6) {\r\nirq = platform_get_irq_byname(pdev, "REGULATOR");\r\nif (irq < 0)\r\nreturn irq;\r\nret = devm_request_threaded_irq(&pdev->dev, irq, NULL,\r\nda9055_ldo5_6_oc_irq,\r\nIRQF_TRIGGER_HIGH |\r\nIRQF_ONESHOT |\r\nIRQF_PROBE_SHARED,\r\npdev->name, regulator);\r\nif (ret != 0) {\r\nif (ret != -EBUSY) {\r\ndev_err(&pdev->dev,\r\n"Failed to request Regulator IRQ %d: %d\n",\r\nirq, ret);\r\nreturn ret;\r\n}\r\n}\r\n}\r\nplatform_set_drvdata(pdev, regulator);\r\nreturn 0;\r\n}\r\nstatic int __init da9055_regulator_init(void)\r\n{\r\nreturn platform_driver_register(&da9055_regulator_driver);\r\n}\r\nstatic void __exit da9055_regulator_exit(void)\r\n{\r\nplatform_driver_unregister(&da9055_regulator_driver);\r\n}
