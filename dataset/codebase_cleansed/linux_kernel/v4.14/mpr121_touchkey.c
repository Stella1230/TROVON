static void mpr121_vdd_supply_disable(void *data)\r\n{\r\nstruct regulator *vdd_supply = data;\r\nregulator_disable(vdd_supply);\r\n}\r\nstatic struct regulator *mpr121_vdd_supply_init(struct device *dev)\r\n{\r\nstruct regulator *vdd_supply;\r\nint err;\r\nvdd_supply = devm_regulator_get(dev, "vdd");\r\nif (IS_ERR(vdd_supply)) {\r\ndev_err(dev, "failed to get vdd regulator: %ld\n",\r\nPTR_ERR(vdd_supply));\r\nreturn vdd_supply;\r\n}\r\nerr = regulator_enable(vdd_supply);\r\nif (err) {\r\ndev_err(dev, "failed to enable vdd regulator: %d\n", err);\r\nreturn ERR_PTR(err);\r\n}\r\nerr = devm_add_action(dev, mpr121_vdd_supply_disable, vdd_supply);\r\nif (err) {\r\nregulator_disable(vdd_supply);\r\ndev_err(dev, "failed to add disable regulator action: %d\n",\r\nerr);\r\nreturn ERR_PTR(err);\r\n}\r\nreturn vdd_supply;\r\n}\r\nstatic irqreturn_t mpr_touchkey_interrupt(int irq, void *dev_id)\r\n{\r\nstruct mpr121_touchkey *mpr121 = dev_id;\r\nstruct i2c_client *client = mpr121->client;\r\nstruct input_dev *input = mpr121->input_dev;\r\nunsigned long bit_changed;\r\nunsigned int key_num;\r\nint reg;\r\nreg = i2c_smbus_read_byte_data(client, ELE_TOUCH_STATUS_1_ADDR);\r\nif (reg < 0) {\r\ndev_err(&client->dev, "i2c read error [%d]\n", reg);\r\ngoto out;\r\n}\r\nreg <<= 8;\r\nreg |= i2c_smbus_read_byte_data(client, ELE_TOUCH_STATUS_0_ADDR);\r\nif (reg < 0) {\r\ndev_err(&client->dev, "i2c read error [%d]\n", reg);\r\ngoto out;\r\n}\r\nreg &= TOUCH_STATUS_MASK;\r\nbit_changed = reg ^ mpr121->statusbits;\r\nmpr121->statusbits = reg;\r\nfor_each_set_bit(key_num, &bit_changed, mpr121->keycount) {\r\nunsigned int key_val, pressed;\r\npressed = reg & BIT(key_num);\r\nkey_val = mpr121->keycodes[key_num];\r\ninput_event(input, EV_MSC, MSC_SCAN, key_num);\r\ninput_report_key(input, key_val, pressed);\r\ndev_dbg(&client->dev, "key %d %d %s\n", key_num, key_val,\r\npressed ? "pressed" : "released");\r\n}\r\ninput_sync(input);\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mpr121_phys_init(struct mpr121_touchkey *mpr121,\r\nstruct i2c_client *client, int vdd_uv)\r\n{\r\nconst struct mpr121_init_register *reg;\r\nunsigned char usl, lsl, tl, eleconf;\r\nint i, t, vdd, ret;\r\nfor (i = 0; i <= MPR121_MAX_KEY_COUNT; i++) {\r\nt = ELE0_TOUCH_THRESHOLD_ADDR + (i * 2);\r\nret = i2c_smbus_write_byte_data(client, t, TOUCH_THRESHOLD);\r\nif (ret < 0)\r\ngoto err_i2c_write;\r\nret = i2c_smbus_write_byte_data(client, t + 1,\r\nRELEASE_THRESHOLD);\r\nif (ret < 0)\r\ngoto err_i2c_write;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(init_reg_table); i++) {\r\nreg = &init_reg_table[i];\r\nret = i2c_smbus_write_byte_data(client, reg->addr, reg->val);\r\nif (ret < 0)\r\ngoto err_i2c_write;\r\n}\r\nvdd = vdd_uv / 1000;\r\nusl = ((vdd - 700) * 256) / vdd;\r\nlsl = (usl * 65) / 100;\r\ntl = (usl * 90) / 100;\r\nret = i2c_smbus_write_byte_data(client, AUTO_CONFIG_USL_ADDR, usl);\r\nret |= i2c_smbus_write_byte_data(client, AUTO_CONFIG_LSL_ADDR, lsl);\r\nret |= i2c_smbus_write_byte_data(client, AUTO_CONFIG_TL_ADDR, tl);\r\neleconf = mpr121->keycount | ELECTRODE_CONF_QUICK_CHARGE;\r\nret |= i2c_smbus_write_byte_data(client, ELECTRODE_CONF_ADDR,\r\neleconf);\r\nif (ret != 0)\r\ngoto err_i2c_write;\r\ndev_dbg(&client->dev, "set up with %x keys.\n", mpr121->keycount);\r\nreturn 0;\r\nerr_i2c_write:\r\ndev_err(&client->dev, "i2c write error: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int mpr_touchkey_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &client->dev;\r\nstruct regulator *vdd_supply;\r\nint vdd_uv;\r\nstruct mpr121_touchkey *mpr121;\r\nstruct input_dev *input_dev;\r\nint error;\r\nint i;\r\nif (!client->irq) {\r\ndev_err(dev, "irq number should not be zero\n");\r\nreturn -EINVAL;\r\n}\r\nvdd_supply = mpr121_vdd_supply_init(dev);\r\nif (IS_ERR(vdd_supply))\r\nreturn PTR_ERR(vdd_supply);\r\nvdd_uv = regulator_get_voltage(vdd_supply);\r\nmpr121 = devm_kzalloc(dev, sizeof(*mpr121), GFP_KERNEL);\r\nif (!mpr121)\r\nreturn -ENOMEM;\r\ninput_dev = devm_input_allocate_device(dev);\r\nif (!input_dev)\r\nreturn -ENOMEM;\r\nmpr121->client = client;\r\nmpr121->input_dev = input_dev;\r\nmpr121->keycount = device_property_read_u32_array(dev, "linux,keycodes",\r\nNULL, 0);\r\nif (mpr121->keycount > MPR121_MAX_KEY_COUNT) {\r\ndev_err(dev, "too many keys defined (%d)\n", mpr121->keycount);\r\nreturn -EINVAL;\r\n}\r\nerror = device_property_read_u32_array(dev, "linux,keycodes",\r\nmpr121->keycodes,\r\nmpr121->keycount);\r\nif (error) {\r\ndev_err(dev,\r\n"failed to read linux,keycode property: %d\n", error);\r\nreturn error;\r\n}\r\ninput_dev->name = "Freescale MPR121 Touchkey";\r\ninput_dev->id.bustype = BUS_I2C;\r\ninput_dev->dev.parent = dev;\r\nif (device_property_read_bool(dev, "autorepeat"))\r\n__set_bit(EV_REP, input_dev->evbit);\r\ninput_set_capability(input_dev, EV_MSC, MSC_SCAN);\r\ninput_dev->keycode = mpr121->keycodes;\r\ninput_dev->keycodesize = sizeof(mpr121->keycodes[0]);\r\ninput_dev->keycodemax = mpr121->keycount;\r\nfor (i = 0; i < mpr121->keycount; i++)\r\ninput_set_capability(input_dev, EV_KEY, mpr121->keycodes[i]);\r\nerror = mpr121_phys_init(mpr121, client, vdd_uv);\r\nif (error) {\r\ndev_err(dev, "Failed to init register\n");\r\nreturn error;\r\n}\r\nerror = devm_request_threaded_irq(dev, client->irq, NULL,\r\nmpr_touchkey_interrupt,\r\nIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\r\ndev->driver->name, mpr121);\r\nif (error) {\r\ndev_err(dev, "Failed to register interrupt\n");\r\nreturn error;\r\n}\r\nerror = input_register_device(input_dev);\r\nif (error)\r\nreturn error;\r\ni2c_set_clientdata(client, mpr121);\r\ndevice_init_wakeup(dev,\r\ndevice_property_read_bool(dev, "wakeup-source"));\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused mpr_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nif (device_may_wakeup(&client->dev))\r\nenable_irq_wake(client->irq);\r\ni2c_smbus_write_byte_data(client, ELECTRODE_CONF_ADDR, 0x00);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused mpr_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct mpr121_touchkey *mpr121 = i2c_get_clientdata(client);\r\nif (device_may_wakeup(&client->dev))\r\ndisable_irq_wake(client->irq);\r\ni2c_smbus_write_byte_data(client, ELECTRODE_CONF_ADDR,\r\nmpr121->keycount);\r\nreturn 0;\r\n}
