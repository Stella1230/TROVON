static int trackpoint_power_on_reset(struct ps2dev *ps2dev)\r\n{\r\nunsigned char results[2];\r\nint tries = 0;\r\ndo {\r\nif (ps2_command(ps2dev, NULL, MAKE_PS2_CMD(0, 0, TP_COMMAND)) ||\r\nps2_command(ps2dev, results, MAKE_PS2_CMD(0, 2, TP_POR)))\r\nreturn -1;\r\n} while (results[0] == 0xFC && results[1] == 0x00 && ++tries < 2);\r\nif (results[0] != 0xAA || results[1] != 0x00)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int trackpoint_read(struct ps2dev *ps2dev,\r\nunsigned char loc, unsigned char *results)\r\n{\r\nif (ps2_command(ps2dev, NULL, MAKE_PS2_CMD(0, 0, TP_COMMAND)) ||\r\nps2_command(ps2dev, results, MAKE_PS2_CMD(0, 1, loc))) {\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int trackpoint_write(struct ps2dev *ps2dev,\r\nunsigned char loc, unsigned char val)\r\n{\r\nif (ps2_command(ps2dev, NULL, MAKE_PS2_CMD(0, 0, TP_COMMAND)) ||\r\nps2_command(ps2dev, NULL, MAKE_PS2_CMD(0, 0, TP_WRITE_MEM)) ||\r\nps2_command(ps2dev, NULL, MAKE_PS2_CMD(0, 0, loc)) ||\r\nps2_command(ps2dev, NULL, MAKE_PS2_CMD(0, 0, val))) {\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int trackpoint_toggle_bit(struct ps2dev *ps2dev,\r\nunsigned char loc, unsigned char mask)\r\n{\r\nif (loc < 0x20 || loc >= 0x2F)\r\nreturn -1;\r\nif (ps2_command(ps2dev, NULL, MAKE_PS2_CMD(0, 0, TP_COMMAND)) ||\r\nps2_command(ps2dev, NULL, MAKE_PS2_CMD(0, 0, TP_TOGGLE)) ||\r\nps2_command(ps2dev, NULL, MAKE_PS2_CMD(0, 0, loc)) ||\r\nps2_command(ps2dev, NULL, MAKE_PS2_CMD(0, 0, mask))) {\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int trackpoint_update_bit(struct ps2dev *ps2dev, unsigned char loc,\r\nunsigned char mask, unsigned char value)\r\n{\r\nint retval = 0;\r\nunsigned char data;\r\ntrackpoint_read(ps2dev, loc, &data);\r\nif (((data & mask) == mask) != !!value)\r\nretval = trackpoint_toggle_bit(ps2dev, loc, mask);\r\nreturn retval;\r\n}\r\nstatic ssize_t trackpoint_show_int_attr(struct psmouse *psmouse, void *data, char *buf)\r\n{\r\nstruct trackpoint_data *tp = psmouse->private;\r\nstruct trackpoint_attr_data *attr = data;\r\nunsigned char value = *(unsigned char *)((char *)tp + attr->field_offset);\r\nif (attr->inverted)\r\nvalue = !value;\r\nreturn sprintf(buf, "%u\n", value);\r\n}\r\nstatic ssize_t trackpoint_set_int_attr(struct psmouse *psmouse, void *data,\r\nconst char *buf, size_t count)\r\n{\r\nstruct trackpoint_data *tp = psmouse->private;\r\nstruct trackpoint_attr_data *attr = data;\r\nunsigned char *field = (unsigned char *)((char *)tp + attr->field_offset);\r\nunsigned char value;\r\nint err;\r\nerr = kstrtou8(buf, 10, &value);\r\nif (err)\r\nreturn err;\r\n*field = value;\r\ntrackpoint_write(&psmouse->ps2dev, attr->command, value);\r\nreturn count;\r\n}\r\nstatic ssize_t trackpoint_set_bit_attr(struct psmouse *psmouse, void *data,\r\nconst char *buf, size_t count)\r\n{\r\nstruct trackpoint_data *tp = psmouse->private;\r\nstruct trackpoint_attr_data *attr = data;\r\nunsigned char *field = (unsigned char *)((char *)tp + attr->field_offset);\r\nunsigned int value;\r\nint err;\r\nerr = kstrtouint(buf, 10, &value);\r\nif (err)\r\nreturn err;\r\nif (value > 1)\r\nreturn -EINVAL;\r\nif (attr->inverted)\r\nvalue = !value;\r\nif (*field != value) {\r\n*field = value;\r\ntrackpoint_toggle_bit(&psmouse->ps2dev, attr->command, attr->mask);\r\n}\r\nreturn count;\r\n}\r\nstatic int trackpoint_start_protocol(struct psmouse *psmouse, unsigned char *firmware_id)\r\n{\r\nunsigned char param[2] = { 0 };\r\nif (ps2_command(&psmouse->ps2dev, param, MAKE_PS2_CMD(0, 2, TP_READ_ID)))\r\nreturn -1;\r\nif (!(param[0] & TP_MAGIC_IDENT))\r\nreturn -1;\r\nif (firmware_id)\r\n*firmware_id = param[1];\r\nreturn 0;\r\n}\r\nstatic int trackpoint_sync(struct psmouse *psmouse, bool in_power_on_state)\r\n{\r\nstruct trackpoint_data *tp = psmouse->private;\r\nif (!in_power_on_state) {\r\ntrackpoint_update_bit(&psmouse->ps2dev, TP_TOGGLE_TWOHAND,\r\nTP_MASK_TWOHAND, TP_DEF_TWOHAND);\r\ntrackpoint_update_bit(&psmouse->ps2dev, TP_TOGGLE_SOURCE_TAG,\r\nTP_MASK_SOURCE_TAG, TP_DEF_SOURCE_TAG);\r\ntrackpoint_update_bit(&psmouse->ps2dev, TP_TOGGLE_MB,\r\nTP_MASK_MB, TP_DEF_MB);\r\n}\r\nTRACKPOINT_UPDATE(in_power_on_state, psmouse, tp, sensitivity);\r\nTRACKPOINT_UPDATE(in_power_on_state, psmouse, tp, inertia);\r\nTRACKPOINT_UPDATE(in_power_on_state, psmouse, tp, speed);\r\nTRACKPOINT_UPDATE(in_power_on_state, psmouse, tp, reach);\r\nTRACKPOINT_UPDATE(in_power_on_state, psmouse, tp, draghys);\r\nTRACKPOINT_UPDATE(in_power_on_state, psmouse, tp, mindrag);\r\nTRACKPOINT_UPDATE(in_power_on_state, psmouse, tp, thresh);\r\nTRACKPOINT_UPDATE(in_power_on_state, psmouse, tp, upthresh);\r\nTRACKPOINT_UPDATE(in_power_on_state, psmouse, tp, ztime);\r\nTRACKPOINT_UPDATE(in_power_on_state, psmouse, tp, jenks);\r\nTRACKPOINT_UPDATE(in_power_on_state, psmouse, tp, drift_time);\r\nTRACKPOINT_UPDATE(in_power_on_state, psmouse, tp, press_to_select);\r\nTRACKPOINT_UPDATE(in_power_on_state, psmouse, tp, skipback);\r\nTRACKPOINT_UPDATE(in_power_on_state, psmouse, tp, ext_dev);\r\nreturn 0;\r\n}\r\nstatic void trackpoint_defaults(struct trackpoint_data *tp)\r\n{\r\nTRACKPOINT_SET_POWER_ON_DEFAULT(tp, sensitivity);\r\nTRACKPOINT_SET_POWER_ON_DEFAULT(tp, speed);\r\nTRACKPOINT_SET_POWER_ON_DEFAULT(tp, reach);\r\nTRACKPOINT_SET_POWER_ON_DEFAULT(tp, draghys);\r\nTRACKPOINT_SET_POWER_ON_DEFAULT(tp, mindrag);\r\nTRACKPOINT_SET_POWER_ON_DEFAULT(tp, thresh);\r\nTRACKPOINT_SET_POWER_ON_DEFAULT(tp, upthresh);\r\nTRACKPOINT_SET_POWER_ON_DEFAULT(tp, ztime);\r\nTRACKPOINT_SET_POWER_ON_DEFAULT(tp, jenks);\r\nTRACKPOINT_SET_POWER_ON_DEFAULT(tp, drift_time);\r\nTRACKPOINT_SET_POWER_ON_DEFAULT(tp, inertia);\r\nTRACKPOINT_SET_POWER_ON_DEFAULT(tp, press_to_select);\r\nTRACKPOINT_SET_POWER_ON_DEFAULT(tp, skipback);\r\nTRACKPOINT_SET_POWER_ON_DEFAULT(tp, ext_dev);\r\n}\r\nstatic void trackpoint_disconnect(struct psmouse *psmouse)\r\n{\r\nsysfs_remove_group(&psmouse->ps2dev.serio->dev.kobj, &trackpoint_attr_group);\r\nkfree(psmouse->private);\r\npsmouse->private = NULL;\r\n}\r\nstatic int trackpoint_reconnect(struct psmouse *psmouse)\r\n{\r\nint reset_fail;\r\nif (trackpoint_start_protocol(psmouse, NULL))\r\nreturn -1;\r\nreset_fail = trackpoint_power_on_reset(&psmouse->ps2dev);\r\nif (trackpoint_sync(psmouse, !reset_fail))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nint trackpoint_detect(struct psmouse *psmouse, bool set_properties)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nunsigned char firmware_id;\r\nunsigned char button_info;\r\nint error;\r\nif (trackpoint_start_protocol(psmouse, &firmware_id))\r\nreturn -1;\r\nif (!set_properties)\r\nreturn 0;\r\nif (trackpoint_read(ps2dev, TP_EXT_BTN, &button_info)) {\r\npsmouse_warn(psmouse, "failed to get extended button data, assuming 3 buttons\n");\r\nbutton_info = 0x33;\r\n}\r\npsmouse->private = kzalloc(sizeof(struct trackpoint_data), GFP_KERNEL);\r\nif (!psmouse->private)\r\nreturn -ENOMEM;\r\npsmouse->vendor = "IBM";\r\npsmouse->name = "TrackPoint";\r\npsmouse->reconnect = trackpoint_reconnect;\r\npsmouse->disconnect = trackpoint_disconnect;\r\nif ((button_info & 0x0f) >= 3)\r\n__set_bit(BTN_MIDDLE, psmouse->dev->keybit);\r\n__set_bit(INPUT_PROP_POINTER, psmouse->dev->propbit);\r\n__set_bit(INPUT_PROP_POINTING_STICK, psmouse->dev->propbit);\r\ntrackpoint_defaults(psmouse->private);\r\nerror = trackpoint_power_on_reset(ps2dev);\r\nif (error)\r\ntrackpoint_sync(psmouse, false);\r\nerror = sysfs_create_group(&ps2dev->serio->dev.kobj, &trackpoint_attr_group);\r\nif (error) {\r\npsmouse_err(psmouse,\r\n"failed to create sysfs attributes, error: %d\n",\r\nerror);\r\nkfree(psmouse->private);\r\npsmouse->private = NULL;\r\nreturn -1;\r\n}\r\npsmouse_info(psmouse,\r\n"IBM TrackPoint firmware: 0x%02x, buttons: %d/%d\n",\r\nfirmware_id,\r\n(button_info & 0xf0) >> 4, button_info & 0x0f);\r\nreturn 0;\r\n}
