static void virtinput_queue_evtbuf(struct virtio_input *vi,\r\nstruct virtio_input_event *evtbuf)\r\n{\r\nstruct scatterlist sg[1];\r\nsg_init_one(sg, evtbuf, sizeof(*evtbuf));\r\nvirtqueue_add_inbuf(vi->evt, sg, 1, evtbuf, GFP_ATOMIC);\r\n}\r\nstatic void virtinput_recv_events(struct virtqueue *vq)\r\n{\r\nstruct virtio_input *vi = vq->vdev->priv;\r\nstruct virtio_input_event *event;\r\nunsigned long flags;\r\nunsigned int len;\r\nspin_lock_irqsave(&vi->lock, flags);\r\nif (vi->ready) {\r\nwhile ((event = virtqueue_get_buf(vi->evt, &len)) != NULL) {\r\nspin_unlock_irqrestore(&vi->lock, flags);\r\ninput_event(vi->idev,\r\nle16_to_cpu(event->type),\r\nle16_to_cpu(event->code),\r\nle32_to_cpu(event->value));\r\nspin_lock_irqsave(&vi->lock, flags);\r\nvirtinput_queue_evtbuf(vi, event);\r\n}\r\nvirtqueue_kick(vq);\r\n}\r\nspin_unlock_irqrestore(&vi->lock, flags);\r\n}\r\nstatic int virtinput_send_status(struct virtio_input *vi,\r\nu16 type, u16 code, s32 value)\r\n{\r\nstruct virtio_input_event *stsbuf;\r\nstruct scatterlist sg[1];\r\nunsigned long flags;\r\nint rc;\r\nstsbuf = kzalloc(sizeof(*stsbuf), GFP_ATOMIC);\r\nif (!stsbuf)\r\nreturn -ENOMEM;\r\nstsbuf->type = cpu_to_le16(type);\r\nstsbuf->code = cpu_to_le16(code);\r\nstsbuf->value = cpu_to_le32(value);\r\nsg_init_one(sg, stsbuf, sizeof(*stsbuf));\r\nspin_lock_irqsave(&vi->lock, flags);\r\nif (vi->ready) {\r\nrc = virtqueue_add_outbuf(vi->sts, sg, 1, stsbuf, GFP_ATOMIC);\r\nvirtqueue_kick(vi->sts);\r\n} else {\r\nrc = -ENODEV;\r\n}\r\nspin_unlock_irqrestore(&vi->lock, flags);\r\nif (rc != 0)\r\nkfree(stsbuf);\r\nreturn rc;\r\n}\r\nstatic void virtinput_recv_status(struct virtqueue *vq)\r\n{\r\nstruct virtio_input *vi = vq->vdev->priv;\r\nstruct virtio_input_event *stsbuf;\r\nunsigned long flags;\r\nunsigned int len;\r\nspin_lock_irqsave(&vi->lock, flags);\r\nwhile ((stsbuf = virtqueue_get_buf(vi->sts, &len)) != NULL)\r\nkfree(stsbuf);\r\nspin_unlock_irqrestore(&vi->lock, flags);\r\n}\r\nstatic int virtinput_status(struct input_dev *idev, unsigned int type,\r\nunsigned int code, int value)\r\n{\r\nstruct virtio_input *vi = input_get_drvdata(idev);\r\nreturn virtinput_send_status(vi, type, code, value);\r\n}\r\nstatic u8 virtinput_cfg_select(struct virtio_input *vi,\r\nu8 select, u8 subsel)\r\n{\r\nu8 size;\r\nvirtio_cwrite(vi->vdev, struct virtio_input_config, select, &select);\r\nvirtio_cwrite(vi->vdev, struct virtio_input_config, subsel, &subsel);\r\nvirtio_cread(vi->vdev, struct virtio_input_config, size, &size);\r\nreturn size;\r\n}\r\nstatic void virtinput_cfg_bits(struct virtio_input *vi, int select, int subsel,\r\nunsigned long *bits, unsigned int bitcount)\r\n{\r\nunsigned int bit;\r\nu8 *virtio_bits;\r\nu8 bytes;\r\nbytes = virtinput_cfg_select(vi, select, subsel);\r\nif (!bytes)\r\nreturn;\r\nif (bitcount > bytes * 8)\r\nbitcount = bytes * 8;\r\nvirtio_bits = kzalloc(bytes, GFP_KERNEL);\r\nif (!virtio_bits)\r\nreturn;\r\nvirtio_cread_bytes(vi->vdev, offsetof(struct virtio_input_config,\r\nu.bitmap),\r\nvirtio_bits, bytes);\r\nfor (bit = 0; bit < bitcount; bit++) {\r\nif (virtio_bits[bit / 8] & (1 << (bit % 8)))\r\n__set_bit(bit, bits);\r\n}\r\nkfree(virtio_bits);\r\nif (select == VIRTIO_INPUT_CFG_EV_BITS)\r\n__set_bit(subsel, vi->idev->evbit);\r\n}\r\nstatic void virtinput_cfg_abs(struct virtio_input *vi, int abs)\r\n{\r\nu32 mi, ma, re, fu, fl;\r\nvirtinput_cfg_select(vi, VIRTIO_INPUT_CFG_ABS_INFO, abs);\r\nvirtio_cread(vi->vdev, struct virtio_input_config, u.abs.min, &mi);\r\nvirtio_cread(vi->vdev, struct virtio_input_config, u.abs.max, &ma);\r\nvirtio_cread(vi->vdev, struct virtio_input_config, u.abs.res, &re);\r\nvirtio_cread(vi->vdev, struct virtio_input_config, u.abs.fuzz, &fu);\r\nvirtio_cread(vi->vdev, struct virtio_input_config, u.abs.flat, &fl);\r\ninput_set_abs_params(vi->idev, abs, mi, ma, fu, fl);\r\ninput_abs_set_res(vi->idev, abs, re);\r\n}\r\nstatic int virtinput_init_vqs(struct virtio_input *vi)\r\n{\r\nstruct virtqueue *vqs[2];\r\nvq_callback_t *cbs[] = { virtinput_recv_events,\r\nvirtinput_recv_status };\r\nstatic const char * const names[] = { "events", "status" };\r\nint err;\r\nerr = virtio_find_vqs(vi->vdev, 2, vqs, cbs, names, NULL);\r\nif (err)\r\nreturn err;\r\nvi->evt = vqs[0];\r\nvi->sts = vqs[1];\r\nreturn 0;\r\n}\r\nstatic void virtinput_fill_evt(struct virtio_input *vi)\r\n{\r\nunsigned long flags;\r\nint i, size;\r\nspin_lock_irqsave(&vi->lock, flags);\r\nsize = virtqueue_get_vring_size(vi->evt);\r\nif (size > ARRAY_SIZE(vi->evts))\r\nsize = ARRAY_SIZE(vi->evts);\r\nfor (i = 0; i < size; i++)\r\nvirtinput_queue_evtbuf(vi, &vi->evts[i]);\r\nvirtqueue_kick(vi->evt);\r\nspin_unlock_irqrestore(&vi->lock, flags);\r\n}\r\nstatic int virtinput_probe(struct virtio_device *vdev)\r\n{\r\nstruct virtio_input *vi;\r\nunsigned long flags;\r\nsize_t size;\r\nint abs, err;\r\nif (!virtio_has_feature(vdev, VIRTIO_F_VERSION_1))\r\nreturn -ENODEV;\r\nvi = kzalloc(sizeof(*vi), GFP_KERNEL);\r\nif (!vi)\r\nreturn -ENOMEM;\r\nvdev->priv = vi;\r\nvi->vdev = vdev;\r\nspin_lock_init(&vi->lock);\r\nerr = virtinput_init_vqs(vi);\r\nif (err)\r\ngoto err_init_vq;\r\nvi->idev = input_allocate_device();\r\nif (!vi->idev) {\r\nerr = -ENOMEM;\r\ngoto err_input_alloc;\r\n}\r\ninput_set_drvdata(vi->idev, vi);\r\nsize = virtinput_cfg_select(vi, VIRTIO_INPUT_CFG_ID_NAME, 0);\r\nvirtio_cread_bytes(vi->vdev, offsetof(struct virtio_input_config,\r\nu.string),\r\nvi->name, min(size, sizeof(vi->name)));\r\nsize = virtinput_cfg_select(vi, VIRTIO_INPUT_CFG_ID_SERIAL, 0);\r\nvirtio_cread_bytes(vi->vdev, offsetof(struct virtio_input_config,\r\nu.string),\r\nvi->serial, min(size, sizeof(vi->serial)));\r\nsnprintf(vi->phys, sizeof(vi->phys),\r\n"virtio%d/input0", vdev->index);\r\nvi->idev->name = vi->name;\r\nvi->idev->phys = vi->phys;\r\nvi->idev->uniq = vi->serial;\r\nsize = virtinput_cfg_select(vi, VIRTIO_INPUT_CFG_ID_DEVIDS, 0);\r\nif (size >= sizeof(struct virtio_input_devids)) {\r\nvirtio_cread(vi->vdev, struct virtio_input_config,\r\nu.ids.bustype, &vi->idev->id.bustype);\r\nvirtio_cread(vi->vdev, struct virtio_input_config,\r\nu.ids.vendor, &vi->idev->id.vendor);\r\nvirtio_cread(vi->vdev, struct virtio_input_config,\r\nu.ids.product, &vi->idev->id.product);\r\nvirtio_cread(vi->vdev, struct virtio_input_config,\r\nu.ids.version, &vi->idev->id.version);\r\n} else {\r\nvi->idev->id.bustype = BUS_VIRTUAL;\r\n}\r\nvirtinput_cfg_bits(vi, VIRTIO_INPUT_CFG_PROP_BITS, 0,\r\nvi->idev->propbit, INPUT_PROP_CNT);\r\nsize = virtinput_cfg_select(vi, VIRTIO_INPUT_CFG_EV_BITS, EV_REP);\r\nif (size)\r\n__set_bit(EV_REP, vi->idev->evbit);\r\nvi->idev->dev.parent = &vdev->dev;\r\nvi->idev->event = virtinput_status;\r\nvirtinput_cfg_bits(vi, VIRTIO_INPUT_CFG_EV_BITS, EV_KEY,\r\nvi->idev->keybit, KEY_CNT);\r\nvirtinput_cfg_bits(vi, VIRTIO_INPUT_CFG_EV_BITS, EV_REL,\r\nvi->idev->relbit, REL_CNT);\r\nvirtinput_cfg_bits(vi, VIRTIO_INPUT_CFG_EV_BITS, EV_ABS,\r\nvi->idev->absbit, ABS_CNT);\r\nvirtinput_cfg_bits(vi, VIRTIO_INPUT_CFG_EV_BITS, EV_MSC,\r\nvi->idev->mscbit, MSC_CNT);\r\nvirtinput_cfg_bits(vi, VIRTIO_INPUT_CFG_EV_BITS, EV_SW,\r\nvi->idev->swbit, SW_CNT);\r\nvirtinput_cfg_bits(vi, VIRTIO_INPUT_CFG_EV_BITS, EV_LED,\r\nvi->idev->ledbit, LED_CNT);\r\nvirtinput_cfg_bits(vi, VIRTIO_INPUT_CFG_EV_BITS, EV_SND,\r\nvi->idev->sndbit, SND_CNT);\r\nif (test_bit(EV_ABS, vi->idev->evbit)) {\r\nfor (abs = 0; abs < ABS_CNT; abs++) {\r\nif (!test_bit(abs, vi->idev->absbit))\r\ncontinue;\r\nvirtinput_cfg_abs(vi, abs);\r\n}\r\n}\r\nvirtio_device_ready(vdev);\r\nvi->ready = true;\r\nerr = input_register_device(vi->idev);\r\nif (err)\r\ngoto err_input_register;\r\nvirtinput_fill_evt(vi);\r\nreturn 0;\r\nerr_input_register:\r\nspin_lock_irqsave(&vi->lock, flags);\r\nvi->ready = false;\r\nspin_unlock_irqrestore(&vi->lock, flags);\r\ninput_free_device(vi->idev);\r\nerr_input_alloc:\r\nvdev->config->del_vqs(vdev);\r\nerr_init_vq:\r\nkfree(vi);\r\nreturn err;\r\n}\r\nstatic void virtinput_remove(struct virtio_device *vdev)\r\n{\r\nstruct virtio_input *vi = vdev->priv;\r\nvoid *buf;\r\nunsigned long flags;\r\nspin_lock_irqsave(&vi->lock, flags);\r\nvi->ready = false;\r\nspin_unlock_irqrestore(&vi->lock, flags);\r\ninput_unregister_device(vi->idev);\r\nvdev->config->reset(vdev);\r\nwhile ((buf = virtqueue_detach_unused_buf(vi->sts)) != NULL)\r\nkfree(buf);\r\nvdev->config->del_vqs(vdev);\r\nkfree(vi);\r\n}\r\nstatic int virtinput_freeze(struct virtio_device *vdev)\r\n{\r\nstruct virtio_input *vi = vdev->priv;\r\nunsigned long flags;\r\nspin_lock_irqsave(&vi->lock, flags);\r\nvi->ready = false;\r\nspin_unlock_irqrestore(&vi->lock, flags);\r\nvdev->config->del_vqs(vdev);\r\nreturn 0;\r\n}\r\nstatic int virtinput_restore(struct virtio_device *vdev)\r\n{\r\nstruct virtio_input *vi = vdev->priv;\r\nint err;\r\nerr = virtinput_init_vqs(vi);\r\nif (err)\r\nreturn err;\r\nvirtio_device_ready(vdev);\r\nvi->ready = true;\r\nvirtinput_fill_evt(vi);\r\nreturn 0;\r\n}
