static struct rds_ib_device *rds_ib_get_device(__be32 ipaddr)\r\n{\r\nstruct rds_ib_device *rds_ibdev;\r\nstruct rds_ib_ipaddr *i_ipaddr;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(rds_ibdev, &rds_ib_devices, list) {\r\nlist_for_each_entry_rcu(i_ipaddr, &rds_ibdev->ipaddr_list, list) {\r\nif (i_ipaddr->ipaddr == ipaddr) {\r\nrefcount_inc(&rds_ibdev->refcount);\r\nrcu_read_unlock();\r\nreturn rds_ibdev;\r\n}\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn NULL;\r\n}\r\nstatic int rds_ib_add_ipaddr(struct rds_ib_device *rds_ibdev, __be32 ipaddr)\r\n{\r\nstruct rds_ib_ipaddr *i_ipaddr;\r\ni_ipaddr = kmalloc(sizeof *i_ipaddr, GFP_KERNEL);\r\nif (!i_ipaddr)\r\nreturn -ENOMEM;\r\ni_ipaddr->ipaddr = ipaddr;\r\nspin_lock_irq(&rds_ibdev->spinlock);\r\nlist_add_tail_rcu(&i_ipaddr->list, &rds_ibdev->ipaddr_list);\r\nspin_unlock_irq(&rds_ibdev->spinlock);\r\nreturn 0;\r\n}\r\nstatic void rds_ib_remove_ipaddr(struct rds_ib_device *rds_ibdev, __be32 ipaddr)\r\n{\r\nstruct rds_ib_ipaddr *i_ipaddr;\r\nstruct rds_ib_ipaddr *to_free = NULL;\r\nspin_lock_irq(&rds_ibdev->spinlock);\r\nlist_for_each_entry_rcu(i_ipaddr, &rds_ibdev->ipaddr_list, list) {\r\nif (i_ipaddr->ipaddr == ipaddr) {\r\nlist_del_rcu(&i_ipaddr->list);\r\nto_free = i_ipaddr;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irq(&rds_ibdev->spinlock);\r\nif (to_free)\r\nkfree_rcu(to_free, rcu);\r\n}\r\nint rds_ib_update_ipaddr(struct rds_ib_device *rds_ibdev, __be32 ipaddr)\r\n{\r\nstruct rds_ib_device *rds_ibdev_old;\r\nrds_ibdev_old = rds_ib_get_device(ipaddr);\r\nif (!rds_ibdev_old)\r\nreturn rds_ib_add_ipaddr(rds_ibdev, ipaddr);\r\nif (rds_ibdev_old != rds_ibdev) {\r\nrds_ib_remove_ipaddr(rds_ibdev_old, ipaddr);\r\nrds_ib_dev_put(rds_ibdev_old);\r\nreturn rds_ib_add_ipaddr(rds_ibdev, ipaddr);\r\n}\r\nrds_ib_dev_put(rds_ibdev_old);\r\nreturn 0;\r\n}\r\nvoid rds_ib_add_conn(struct rds_ib_device *rds_ibdev, struct rds_connection *conn)\r\n{\r\nstruct rds_ib_connection *ic = conn->c_transport_data;\r\nspin_lock_irq(&ib_nodev_conns_lock);\r\nBUG_ON(list_empty(&ib_nodev_conns));\r\nBUG_ON(list_empty(&ic->ib_node));\r\nlist_del(&ic->ib_node);\r\nspin_lock(&rds_ibdev->spinlock);\r\nlist_add_tail(&ic->ib_node, &rds_ibdev->conn_list);\r\nspin_unlock(&rds_ibdev->spinlock);\r\nspin_unlock_irq(&ib_nodev_conns_lock);\r\nic->rds_ibdev = rds_ibdev;\r\nrefcount_inc(&rds_ibdev->refcount);\r\n}\r\nvoid rds_ib_remove_conn(struct rds_ib_device *rds_ibdev, struct rds_connection *conn)\r\n{\r\nstruct rds_ib_connection *ic = conn->c_transport_data;\r\nspin_lock(&ib_nodev_conns_lock);\r\nspin_lock_irq(&rds_ibdev->spinlock);\r\nBUG_ON(list_empty(&ic->ib_node));\r\nlist_del(&ic->ib_node);\r\nspin_unlock_irq(&rds_ibdev->spinlock);\r\nlist_add_tail(&ic->ib_node, &ib_nodev_conns);\r\nspin_unlock(&ib_nodev_conns_lock);\r\nic->rds_ibdev = NULL;\r\nrds_ib_dev_put(rds_ibdev);\r\n}\r\nvoid rds_ib_destroy_nodev_conns(void)\r\n{\r\nstruct rds_ib_connection *ic, *_ic;\r\nLIST_HEAD(tmp_list);\r\nspin_lock_irq(&ib_nodev_conns_lock);\r\nlist_splice(&ib_nodev_conns, &tmp_list);\r\nspin_unlock_irq(&ib_nodev_conns_lock);\r\nlist_for_each_entry_safe(ic, _ic, &tmp_list, ib_node)\r\nrds_conn_destroy(ic->conn);\r\n}\r\nvoid rds_ib_get_mr_info(struct rds_ib_device *rds_ibdev, struct rds_info_rdma_connection *iinfo)\r\n{\r\nstruct rds_ib_mr_pool *pool_1m = rds_ibdev->mr_1m_pool;\r\niinfo->rdma_mr_max = pool_1m->max_items;\r\niinfo->rdma_mr_size = pool_1m->fmr_attr.max_pages;\r\n}\r\nstruct rds_ib_mr *rds_ib_reuse_mr(struct rds_ib_mr_pool *pool)\r\n{\r\nstruct rds_ib_mr *ibmr = NULL;\r\nstruct llist_node *ret;\r\nunsigned long *flag;\r\npreempt_disable();\r\nflag = this_cpu_ptr(&clean_list_grace);\r\nset_bit(CLEAN_LIST_BUSY_BIT, flag);\r\nret = llist_del_first(&pool->clean_list);\r\nif (ret) {\r\nibmr = llist_entry(ret, struct rds_ib_mr, llnode);\r\nif (pool->pool_type == RDS_IB_MR_8K_POOL)\r\nrds_ib_stats_inc(s_ib_rdma_mr_8k_reused);\r\nelse\r\nrds_ib_stats_inc(s_ib_rdma_mr_1m_reused);\r\n}\r\nclear_bit(CLEAN_LIST_BUSY_BIT, flag);\r\npreempt_enable();\r\nreturn ibmr;\r\n}\r\nstatic inline void wait_clean_list_grace(void)\r\n{\r\nint cpu;\r\nunsigned long *flag;\r\nfor_each_online_cpu(cpu) {\r\nflag = &per_cpu(clean_list_grace, cpu);\r\nwhile (test_bit(CLEAN_LIST_BUSY_BIT, flag))\r\ncpu_relax();\r\n}\r\n}\r\nvoid rds_ib_sync_mr(void *trans_private, int direction)\r\n{\r\nstruct rds_ib_mr *ibmr = trans_private;\r\nstruct rds_ib_device *rds_ibdev = ibmr->device;\r\nswitch (direction) {\r\ncase DMA_FROM_DEVICE:\r\nib_dma_sync_sg_for_cpu(rds_ibdev->dev, ibmr->sg,\r\nibmr->sg_dma_len, DMA_BIDIRECTIONAL);\r\nbreak;\r\ncase DMA_TO_DEVICE:\r\nib_dma_sync_sg_for_device(rds_ibdev->dev, ibmr->sg,\r\nibmr->sg_dma_len, DMA_BIDIRECTIONAL);\r\nbreak;\r\n}\r\n}\r\nvoid __rds_ib_teardown_mr(struct rds_ib_mr *ibmr)\r\n{\r\nstruct rds_ib_device *rds_ibdev = ibmr->device;\r\nif (ibmr->sg_dma_len) {\r\nib_dma_unmap_sg(rds_ibdev->dev,\r\nibmr->sg, ibmr->sg_len,\r\nDMA_BIDIRECTIONAL);\r\nibmr->sg_dma_len = 0;\r\n}\r\nif (ibmr->sg_len) {\r\nunsigned int i;\r\nfor (i = 0; i < ibmr->sg_len; ++i) {\r\nstruct page *page = sg_page(&ibmr->sg[i]);\r\nWARN_ON(!page->mapping && irqs_disabled());\r\nset_page_dirty(page);\r\nput_page(page);\r\n}\r\nkfree(ibmr->sg);\r\nibmr->sg = NULL;\r\nibmr->sg_len = 0;\r\n}\r\n}\r\nvoid rds_ib_teardown_mr(struct rds_ib_mr *ibmr)\r\n{\r\nunsigned int pinned = ibmr->sg_len;\r\n__rds_ib_teardown_mr(ibmr);\r\nif (pinned) {\r\nstruct rds_ib_mr_pool *pool = ibmr->pool;\r\natomic_sub(pinned, &pool->free_pinned);\r\n}\r\n}\r\nstatic inline unsigned int rds_ib_flush_goal(struct rds_ib_mr_pool *pool, int free_all)\r\n{\r\nunsigned int item_count;\r\nitem_count = atomic_read(&pool->item_count);\r\nif (free_all)\r\nreturn item_count;\r\nreturn 0;\r\n}\r\nstatic unsigned int llist_append_to_list(struct llist_head *llist,\r\nstruct list_head *list)\r\n{\r\nstruct rds_ib_mr *ibmr;\r\nstruct llist_node *node;\r\nstruct llist_node *next;\r\nunsigned int count = 0;\r\nnode = llist_del_all(llist);\r\nwhile (node) {\r\nnext = node->next;\r\nibmr = llist_entry(node, struct rds_ib_mr, llnode);\r\nlist_add_tail(&ibmr->unmap_list, list);\r\nnode = next;\r\ncount++;\r\n}\r\nreturn count;\r\n}\r\nstatic void list_to_llist_nodes(struct rds_ib_mr_pool *pool,\r\nstruct list_head *list,\r\nstruct llist_node **nodes_head,\r\nstruct llist_node **nodes_tail)\r\n{\r\nstruct rds_ib_mr *ibmr;\r\nstruct llist_node *cur = NULL;\r\nstruct llist_node **next = nodes_head;\r\nlist_for_each_entry(ibmr, list, unmap_list) {\r\ncur = &ibmr->llnode;\r\n*next = cur;\r\nnext = &cur->next;\r\n}\r\n*next = NULL;\r\n*nodes_tail = cur;\r\n}\r\nint rds_ib_flush_mr_pool(struct rds_ib_mr_pool *pool,\r\nint free_all, struct rds_ib_mr **ibmr_ret)\r\n{\r\nstruct rds_ib_mr *ibmr;\r\nstruct llist_node *clean_nodes;\r\nstruct llist_node *clean_tail;\r\nLIST_HEAD(unmap_list);\r\nunsigned long unpinned = 0;\r\nunsigned int nfreed = 0, dirty_to_clean = 0, free_goal;\r\nif (pool->pool_type == RDS_IB_MR_8K_POOL)\r\nrds_ib_stats_inc(s_ib_rdma_mr_8k_pool_flush);\r\nelse\r\nrds_ib_stats_inc(s_ib_rdma_mr_1m_pool_flush);\r\nif (ibmr_ret) {\r\nDEFINE_WAIT(wait);\r\nwhile (!mutex_trylock(&pool->flush_lock)) {\r\nibmr = rds_ib_reuse_mr(pool);\r\nif (ibmr) {\r\n*ibmr_ret = ibmr;\r\nfinish_wait(&pool->flush_wait, &wait);\r\ngoto out_nolock;\r\n}\r\nprepare_to_wait(&pool->flush_wait, &wait,\r\nTASK_UNINTERRUPTIBLE);\r\nif (llist_empty(&pool->clean_list))\r\nschedule();\r\nibmr = rds_ib_reuse_mr(pool);\r\nif (ibmr) {\r\n*ibmr_ret = ibmr;\r\nfinish_wait(&pool->flush_wait, &wait);\r\ngoto out_nolock;\r\n}\r\n}\r\nfinish_wait(&pool->flush_wait, &wait);\r\n} else\r\nmutex_lock(&pool->flush_lock);\r\nif (ibmr_ret) {\r\nibmr = rds_ib_reuse_mr(pool);\r\nif (ibmr) {\r\n*ibmr_ret = ibmr;\r\ngoto out;\r\n}\r\n}\r\ndirty_to_clean = llist_append_to_list(&pool->drop_list, &unmap_list);\r\ndirty_to_clean += llist_append_to_list(&pool->free_list, &unmap_list);\r\nif (free_all)\r\nllist_append_to_list(&pool->clean_list, &unmap_list);\r\nfree_goal = rds_ib_flush_goal(pool, free_all);\r\nif (list_empty(&unmap_list))\r\ngoto out;\r\nif (pool->use_fastreg)\r\nrds_ib_unreg_frmr(&unmap_list, &nfreed, &unpinned, free_goal);\r\nelse\r\nrds_ib_unreg_fmr(&unmap_list, &nfreed, &unpinned, free_goal);\r\nif (!list_empty(&unmap_list)) {\r\nwait_clean_list_grace();\r\nlist_to_llist_nodes(pool, &unmap_list, &clean_nodes, &clean_tail);\r\nif (ibmr_ret)\r\n*ibmr_ret = llist_entry(clean_nodes, struct rds_ib_mr, llnode);\r\nif (clean_nodes->next)\r\nllist_add_batch(clean_nodes->next, clean_tail, &pool->clean_list);\r\n}\r\natomic_sub(unpinned, &pool->free_pinned);\r\natomic_sub(dirty_to_clean, &pool->dirty_count);\r\natomic_sub(nfreed, &pool->item_count);\r\nout:\r\nmutex_unlock(&pool->flush_lock);\r\nif (waitqueue_active(&pool->flush_wait))\r\nwake_up(&pool->flush_wait);\r\nout_nolock:\r\nreturn 0;\r\n}\r\nstruct rds_ib_mr *rds_ib_try_reuse_ibmr(struct rds_ib_mr_pool *pool)\r\n{\r\nstruct rds_ib_mr *ibmr = NULL;\r\nint iter = 0;\r\nif (atomic_read(&pool->dirty_count) >= pool->max_items_soft / 10)\r\nqueue_delayed_work(rds_ib_mr_wq, &pool->flush_worker, 10);\r\nwhile (1) {\r\nibmr = rds_ib_reuse_mr(pool);\r\nif (ibmr)\r\nreturn ibmr;\r\nif (atomic_inc_return(&pool->item_count) <= pool->max_items)\r\nbreak;\r\natomic_dec(&pool->item_count);\r\nif (++iter > 2) {\r\nif (pool->pool_type == RDS_IB_MR_8K_POOL)\r\nrds_ib_stats_inc(s_ib_rdma_mr_8k_pool_depleted);\r\nelse\r\nrds_ib_stats_inc(s_ib_rdma_mr_1m_pool_depleted);\r\nreturn ERR_PTR(-EAGAIN);\r\n}\r\nif (pool->pool_type == RDS_IB_MR_8K_POOL)\r\nrds_ib_stats_inc(s_ib_rdma_mr_8k_pool_wait);\r\nelse\r\nrds_ib_stats_inc(s_ib_rdma_mr_1m_pool_wait);\r\nrds_ib_flush_mr_pool(pool, 0, &ibmr);\r\nif (ibmr)\r\nreturn ibmr;\r\n}\r\nreturn ibmr;\r\n}\r\nstatic void rds_ib_mr_pool_flush_worker(struct work_struct *work)\r\n{\r\nstruct rds_ib_mr_pool *pool = container_of(work, struct rds_ib_mr_pool, flush_worker.work);\r\nrds_ib_flush_mr_pool(pool, 0, NULL);\r\n}\r\nvoid rds_ib_free_mr(void *trans_private, int invalidate)\r\n{\r\nstruct rds_ib_mr *ibmr = trans_private;\r\nstruct rds_ib_mr_pool *pool = ibmr->pool;\r\nstruct rds_ib_device *rds_ibdev = ibmr->device;\r\nrdsdebug("RDS/IB: free_mr nents %u\n", ibmr->sg_len);\r\nif (rds_ibdev->use_fastreg)\r\nrds_ib_free_frmr_list(ibmr);\r\nelse\r\nrds_ib_free_fmr_list(ibmr);\r\natomic_add(ibmr->sg_len, &pool->free_pinned);\r\natomic_inc(&pool->dirty_count);\r\nif (atomic_read(&pool->free_pinned) >= pool->max_free_pinned ||\r\natomic_read(&pool->dirty_count) >= pool->max_items / 5)\r\nqueue_delayed_work(rds_ib_mr_wq, &pool->flush_worker, 10);\r\nif (invalidate) {\r\nif (likely(!in_interrupt())) {\r\nrds_ib_flush_mr_pool(pool, 0, NULL);\r\n} else {\r\nqueue_delayed_work(rds_ib_mr_wq,\r\n&pool->flush_worker, 10);\r\n}\r\n}\r\nrds_ib_dev_put(rds_ibdev);\r\n}\r\nvoid rds_ib_flush_mrs(void)\r\n{\r\nstruct rds_ib_device *rds_ibdev;\r\ndown_read(&rds_ib_devices_lock);\r\nlist_for_each_entry(rds_ibdev, &rds_ib_devices, list) {\r\nif (rds_ibdev->mr_8k_pool)\r\nrds_ib_flush_mr_pool(rds_ibdev->mr_8k_pool, 0, NULL);\r\nif (rds_ibdev->mr_1m_pool)\r\nrds_ib_flush_mr_pool(rds_ibdev->mr_1m_pool, 0, NULL);\r\n}\r\nup_read(&rds_ib_devices_lock);\r\n}\r\nvoid *rds_ib_get_mr(struct scatterlist *sg, unsigned long nents,\r\nstruct rds_sock *rs, u32 *key_ret)\r\n{\r\nstruct rds_ib_device *rds_ibdev;\r\nstruct rds_ib_mr *ibmr = NULL;\r\nstruct rds_ib_connection *ic = rs->rs_conn->c_transport_data;\r\nint ret;\r\nrds_ibdev = rds_ib_get_device(rs->rs_bound_addr);\r\nif (!rds_ibdev) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nif (!rds_ibdev->mr_8k_pool || !rds_ibdev->mr_1m_pool) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nif (rds_ibdev->use_fastreg)\r\nibmr = rds_ib_reg_frmr(rds_ibdev, ic, sg, nents, key_ret);\r\nelse\r\nibmr = rds_ib_reg_fmr(rds_ibdev, sg, nents, key_ret);\r\nif (ibmr)\r\nrds_ibdev = NULL;\r\nout:\r\nif (!ibmr)\r\npr_warn("RDS/IB: rds_ib_get_mr failed (errno=%d)\n", ret);\r\nif (rds_ibdev)\r\nrds_ib_dev_put(rds_ibdev);\r\nreturn ibmr;\r\n}\r\nvoid rds_ib_destroy_mr_pool(struct rds_ib_mr_pool *pool)\r\n{\r\ncancel_delayed_work_sync(&pool->flush_worker);\r\nrds_ib_flush_mr_pool(pool, 1, NULL);\r\nWARN_ON(atomic_read(&pool->item_count));\r\nWARN_ON(atomic_read(&pool->free_pinned));\r\nkfree(pool);\r\n}\r\nstruct rds_ib_mr_pool *rds_ib_create_mr_pool(struct rds_ib_device *rds_ibdev,\r\nint pool_type)\r\n{\r\nstruct rds_ib_mr_pool *pool;\r\npool = kzalloc(sizeof(*pool), GFP_KERNEL);\r\nif (!pool)\r\nreturn ERR_PTR(-ENOMEM);\r\npool->pool_type = pool_type;\r\ninit_llist_head(&pool->free_list);\r\ninit_llist_head(&pool->drop_list);\r\ninit_llist_head(&pool->clean_list);\r\nmutex_init(&pool->flush_lock);\r\ninit_waitqueue_head(&pool->flush_wait);\r\nINIT_DELAYED_WORK(&pool->flush_worker, rds_ib_mr_pool_flush_worker);\r\nif (pool_type == RDS_IB_MR_1M_POOL) {\r\npool->fmr_attr.max_pages = RDS_MR_1M_MSG_SIZE + 1;\r\npool->max_items = RDS_MR_1M_POOL_SIZE;\r\n} else {\r\npool->fmr_attr.max_pages = RDS_MR_8K_MSG_SIZE + 1;\r\npool->max_items = RDS_MR_8K_POOL_SIZE;\r\n}\r\npool->max_free_pinned = pool->max_items * pool->fmr_attr.max_pages / 4;\r\npool->fmr_attr.max_maps = rds_ibdev->fmr_max_remaps;\r\npool->fmr_attr.page_shift = PAGE_SHIFT;\r\npool->max_items_soft = rds_ibdev->max_mrs * 3 / 4;\r\npool->use_fastreg = rds_ibdev->use_fastreg;\r\nreturn pool;\r\n}\r\nint rds_ib_mr_init(void)\r\n{\r\nrds_ib_mr_wq = alloc_workqueue("rds_mr_flushd", WQ_MEM_RECLAIM, 0);\r\nif (!rds_ib_mr_wq)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid rds_ib_mr_exit(void)\r\n{\r\ndestroy_workqueue(rds_ib_mr_wq);\r\n}
