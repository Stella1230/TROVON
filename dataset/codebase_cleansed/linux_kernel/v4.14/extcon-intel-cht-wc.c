static int cht_wc_extcon_get_id(struct cht_wc_extcon_data *ext, int pwrsrc_sts)\r\n{\r\nif (pwrsrc_sts & CHT_WC_PWRSRC_ID_GND)\r\nreturn USB_ID_GND;\r\nif (pwrsrc_sts & CHT_WC_PWRSRC_ID_FLOAT)\r\nreturn USB_ID_FLOAT;\r\nreturn USB_ID_FLOAT;\r\n}\r\nstatic int cht_wc_extcon_get_charger(struct cht_wc_extcon_data *ext,\r\nbool ignore_errors)\r\n{\r\nint ret, usbsrc, status;\r\nunsigned long timeout;\r\ntimeout = jiffies + msecs_to_jiffies(800);\r\ndo {\r\nret = regmap_read(ext->regmap, CHT_WC_USBSRC, &usbsrc);\r\nif (ret) {\r\ndev_err(ext->dev, "Error reading usbsrc: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatus = usbsrc & CHT_WC_USBSRC_STS_MASK;\r\nif (status == CHT_WC_USBSRC_STS_SUCCESS ||\r\nstatus == CHT_WC_USBSRC_STS_FAIL)\r\nbreak;\r\nmsleep(50);\r\n} while (time_before(jiffies, timeout));\r\nif (status != CHT_WC_USBSRC_STS_SUCCESS) {\r\nif (ignore_errors)\r\nreturn EXTCON_CHG_USB_SDP;\r\nif (status == CHT_WC_USBSRC_STS_FAIL)\r\ndev_warn(ext->dev, "Could not detect charger type\n");\r\nelse\r\ndev_warn(ext->dev, "Timeout detecting charger type\n");\r\nreturn EXTCON_CHG_USB_SDP;\r\n}\r\nusbsrc = (usbsrc & CHT_WC_USBSRC_TYPE_MASK) >> CHT_WC_USBSRC_TYPE_SHIFT;\r\nswitch (usbsrc) {\r\ndefault:\r\ndev_warn(ext->dev,\r\n"Unhandled charger type %d, defaulting to SDP\n",\r\nret);\r\ncase CHT_WC_USBSRC_TYPE_SDP:\r\ncase CHT_WC_USBSRC_TYPE_FLOAT_DP_DN:\r\ncase CHT_WC_USBSRC_TYPE_OTHER:\r\nreturn EXTCON_CHG_USB_SDP;\r\ncase CHT_WC_USBSRC_TYPE_CDP:\r\nreturn EXTCON_CHG_USB_CDP;\r\ncase CHT_WC_USBSRC_TYPE_DCP:\r\ncase CHT_WC_USBSRC_TYPE_DCP_EXTPHY:\r\ncase CHT_WC_USBSRC_TYPE_MHL:\r\nreturn EXTCON_CHG_USB_DCP;\r\ncase CHT_WC_USBSRC_TYPE_ACA:\r\nreturn EXTCON_CHG_USB_ACA;\r\n}\r\n}\r\nstatic void cht_wc_extcon_set_phymux(struct cht_wc_extcon_data *ext, u8 state)\r\n{\r\nint ret;\r\nret = regmap_write(ext->regmap, CHT_WC_PHYCTRL, state);\r\nif (ret)\r\ndev_err(ext->dev, "Error writing phyctrl: %d\n", ret);\r\n}\r\nstatic void cht_wc_extcon_set_5v_boost(struct cht_wc_extcon_data *ext,\r\nbool enable)\r\n{\r\nint ret, val;\r\nval = enable ? CHT_WC_VBUS_GPIO_CTLO_OUTPUT : 0;\r\nret = regmap_update_bits(ext->regmap, CHT_WC_VBUS_GPIO_CTLO,\r\nCHT_WC_VBUS_GPIO_CTLO_OUTPUT, val);\r\nif (ret)\r\ndev_err(ext->dev, "Error writing Vbus GPIO CTLO: %d\n", ret);\r\n}\r\nstatic void cht_wc_extcon_set_state(struct cht_wc_extcon_data *ext,\r\nunsigned int cable, bool state)\r\n{\r\nextcon_set_state_sync(ext->edev, cable, state);\r\nif (cable == EXTCON_CHG_USB_SDP)\r\nextcon_set_state_sync(ext->edev, EXTCON_USB, state);\r\n}\r\nstatic void cht_wc_extcon_pwrsrc_event(struct cht_wc_extcon_data *ext)\r\n{\r\nint ret, pwrsrc_sts, id;\r\nunsigned int cable = EXTCON_NONE;\r\nbool ignore_get_charger_errors = ext->usb_host;\r\nret = regmap_read(ext->regmap, CHT_WC_PWRSRC_STS, &pwrsrc_sts);\r\nif (ret) {\r\ndev_err(ext->dev, "Error reading pwrsrc status: %d\n", ret);\r\nreturn;\r\n}\r\nid = cht_wc_extcon_get_id(ext, pwrsrc_sts);\r\nif (id == USB_ID_GND) {\r\ngoto charger_det_done;\r\n}\r\nif (!(pwrsrc_sts & CHT_WC_PWRSRC_VBUS)) {\r\ncht_wc_extcon_set_phymux(ext, MUX_SEL_PMIC);\r\ngoto set_state;\r\n}\r\nret = cht_wc_extcon_get_charger(ext, ignore_get_charger_errors);\r\nif (ret >= 0)\r\ncable = ret;\r\ncharger_det_done:\r\ncht_wc_extcon_set_phymux(ext, MUX_SEL_SOC);\r\nset_state:\r\nif (cable != ext->previous_cable) {\r\ncht_wc_extcon_set_state(ext, cable, true);\r\ncht_wc_extcon_set_state(ext, ext->previous_cable, false);\r\next->previous_cable = cable;\r\n}\r\next->usb_host = ((id == USB_ID_GND) || (id == USB_RID_A));\r\nextcon_set_state_sync(ext->edev, EXTCON_USB_HOST, ext->usb_host);\r\n}\r\nstatic irqreturn_t cht_wc_extcon_isr(int irq, void *data)\r\n{\r\nstruct cht_wc_extcon_data *ext = data;\r\nint ret, irqs;\r\nret = regmap_read(ext->regmap, CHT_WC_PWRSRC_IRQ, &irqs);\r\nif (ret) {\r\ndev_err(ext->dev, "Error reading irqs: %d\n", ret);\r\nreturn IRQ_NONE;\r\n}\r\ncht_wc_extcon_pwrsrc_event(ext);\r\nret = regmap_write(ext->regmap, CHT_WC_PWRSRC_IRQ, irqs);\r\nif (ret) {\r\ndev_err(ext->dev, "Error writing irqs: %d\n", ret);\r\nreturn IRQ_NONE;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int cht_wc_extcon_sw_control(struct cht_wc_extcon_data *ext, bool enable)\r\n{\r\nint ret, mask, val;\r\nmask = CHT_WC_CHGRCTRL0_SWCONTROL | CHT_WC_CHGRCTRL0_CCSM_OFF_MASK;\r\nval = enable ? mask : 0;\r\nret = regmap_update_bits(ext->regmap, CHT_WC_CHGRCTRL0, mask, val);\r\nif (ret)\r\ndev_err(ext->dev, "Error setting sw control: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int cht_wc_extcon_probe(struct platform_device *pdev)\r\n{\r\nstruct intel_soc_pmic *pmic = dev_get_drvdata(pdev->dev.parent);\r\nstruct cht_wc_extcon_data *ext;\r\nint irq, ret;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn irq;\r\next = devm_kzalloc(&pdev->dev, sizeof(*ext), GFP_KERNEL);\r\nif (!ext)\r\nreturn -ENOMEM;\r\next->dev = &pdev->dev;\r\next->regmap = pmic->regmap;\r\next->previous_cable = EXTCON_NONE;\r\next->edev = devm_extcon_dev_allocate(ext->dev, cht_wc_extcon_cables);\r\nif (IS_ERR(ext->edev))\r\nreturn PTR_ERR(ext->edev);\r\ncht_wc_extcon_set_5v_boost(ext, false);\r\nret = cht_wc_extcon_sw_control(ext, true);\r\nif (ret)\r\nreturn ret;\r\nret = devm_extcon_dev_register(ext->dev, ext->edev);\r\nif (ret) {\r\ndev_err(ext->dev, "Error registering extcon device: %d\n", ret);\r\ngoto disable_sw_control;\r\n}\r\ncht_wc_extcon_set_phymux(ext, MUX_SEL_PMIC);\r\ncht_wc_extcon_pwrsrc_event(ext);\r\nret = devm_request_threaded_irq(ext->dev, irq, NULL, cht_wc_extcon_isr,\r\nIRQF_ONESHOT, pdev->name, ext);\r\nif (ret) {\r\ndev_err(ext->dev, "Error requesting interrupt: %d\n", ret);\r\ngoto disable_sw_control;\r\n}\r\nret = regmap_write(ext->regmap, CHT_WC_PWRSRC_IRQ_MASK,\r\n(int)~(CHT_WC_PWRSRC_VBUS | CHT_WC_PWRSRC_ID_GND |\r\nCHT_WC_PWRSRC_ID_FLOAT));\r\nif (ret) {\r\ndev_err(ext->dev, "Error writing irq-mask: %d\n", ret);\r\ngoto disable_sw_control;\r\n}\r\nplatform_set_drvdata(pdev, ext);\r\nreturn 0;\r\ndisable_sw_control:\r\ncht_wc_extcon_sw_control(ext, false);\r\nreturn ret;\r\n}\r\nstatic int cht_wc_extcon_remove(struct platform_device *pdev)\r\n{\r\nstruct cht_wc_extcon_data *ext = platform_get_drvdata(pdev);\r\ncht_wc_extcon_sw_control(ext, false);\r\nreturn 0;\r\n}
