static inline u32 mpic_fsl_err_read(u32 __iomem *base, unsigned int err_reg)\r\n{\r\nreturn in_be32(base + (err_reg >> 2));\r\n}\r\nstatic inline void mpic_fsl_err_write(u32 __iomem *base, u32 value)\r\n{\r\nout_be32(base + (MPIC_ERR_INT_EIMR >> 2), value);\r\n}\r\nstatic void fsl_mpic_mask_err(struct irq_data *d)\r\n{\r\nu32 eimr;\r\nstruct mpic *mpic = irq_data_get_irq_chip_data(d);\r\nunsigned int src = virq_to_hw(d->irq) - mpic->err_int_vecs[0];\r\neimr = mpic_fsl_err_read(mpic->err_regs, MPIC_ERR_INT_EIMR);\r\neimr |= (1 << (31 - src));\r\nmpic_fsl_err_write(mpic->err_regs, eimr);\r\n}\r\nstatic void fsl_mpic_unmask_err(struct irq_data *d)\r\n{\r\nu32 eimr;\r\nstruct mpic *mpic = irq_data_get_irq_chip_data(d);\r\nunsigned int src = virq_to_hw(d->irq) - mpic->err_int_vecs[0];\r\neimr = mpic_fsl_err_read(mpic->err_regs, MPIC_ERR_INT_EIMR);\r\neimr &= ~(1 << (31 - src));\r\nmpic_fsl_err_write(mpic->err_regs, eimr);\r\n}\r\nint mpic_setup_error_int(struct mpic *mpic, int intvec)\r\n{\r\nint i;\r\nmpic->err_regs = ioremap(mpic->paddr + MPIC_ERR_INT_BASE, 0x1000);\r\nif (!mpic->err_regs) {\r\npr_err("could not map mpic error registers\n");\r\nreturn -ENOMEM;\r\n}\r\nmpic->hc_err = fsl_mpic_err_chip;\r\nmpic->hc_err.name = mpic->name;\r\nmpic->flags |= MPIC_FSL_HAS_EIMR;\r\nfor (i = MPIC_MAX_ERR - 1; i >= 0; i--)\r\nmpic->err_int_vecs[i] = --intvec;\r\nreturn 0;\r\n}\r\nint mpic_map_error_int(struct mpic *mpic, unsigned int virq, irq_hw_number_t hw)\r\n{\r\nif ((mpic->flags & MPIC_FSL_HAS_EIMR) &&\r\n(hw >= mpic->err_int_vecs[0] &&\r\nhw <= mpic->err_int_vecs[MPIC_MAX_ERR - 1])) {\r\nWARN_ON(mpic->flags & MPIC_SECONDARY);\r\npr_debug("mpic: mapping as Error Interrupt\n");\r\nirq_set_chip_data(virq, mpic);\r\nirq_set_chip_and_handler(virq, &mpic->hc_err,\r\nhandle_level_irq);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t fsl_error_int_handler(int irq, void *data)\r\n{\r\nstruct mpic *mpic = (struct mpic *) data;\r\nu32 eisr, eimr;\r\nint errint;\r\nunsigned int cascade_irq;\r\neisr = mpic_fsl_err_read(mpic->err_regs, MPIC_ERR_INT_EISR);\r\neimr = mpic_fsl_err_read(mpic->err_regs, MPIC_ERR_INT_EIMR);\r\nif (!(eisr & ~eimr))\r\nreturn IRQ_NONE;\r\nwhile (eisr) {\r\nerrint = __builtin_clz(eisr);\r\ncascade_irq = irq_linear_revmap(mpic->irqhost,\r\nmpic->err_int_vecs[errint]);\r\nWARN_ON(!cascade_irq);\r\nif (cascade_irq) {\r\ngeneric_handle_irq(cascade_irq);\r\n} else {\r\neimr |= 1 << (31 - errint);\r\nmpic_fsl_err_write(mpic->err_regs, eimr);\r\n}\r\neisr &= ~(1 << (31 - errint));\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid mpic_err_int_init(struct mpic *mpic, irq_hw_number_t irqnum)\r\n{\r\nunsigned int virq;\r\nint ret;\r\nvirq = irq_create_mapping(mpic->irqhost, irqnum);\r\nif (!virq) {\r\npr_err("Error interrupt setup failed\n");\r\nreturn;\r\n}\r\nmpic_fsl_err_write(mpic->err_regs, ~0);\r\nret = request_irq(virq, fsl_error_int_handler, IRQF_NO_THREAD,\r\n"mpic-error-int", mpic);\r\nif (ret)\r\npr_err("Failed to register error interrupt handler\n");\r\n}
