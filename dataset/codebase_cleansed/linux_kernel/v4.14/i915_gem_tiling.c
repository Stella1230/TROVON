u32 i915_gem_fence_size(struct drm_i915_private *i915,\r\nu32 size, unsigned int tiling, unsigned int stride)\r\n{\r\nu32 ggtt_size;\r\nGEM_BUG_ON(!size);\r\nif (tiling == I915_TILING_NONE)\r\nreturn size;\r\nGEM_BUG_ON(!stride);\r\nif (INTEL_GEN(i915) >= 4) {\r\nstride *= i915_gem_tile_height(tiling);\r\nGEM_BUG_ON(!IS_ALIGNED(stride, I965_FENCE_PAGE));\r\nreturn roundup(size, stride);\r\n}\r\nif (IS_GEN3(i915))\r\nggtt_size = 1024*1024;\r\nelse\r\nggtt_size = 512*1024;\r\nwhile (ggtt_size < size)\r\nggtt_size <<= 1;\r\nreturn ggtt_size;\r\n}\r\nu32 i915_gem_fence_alignment(struct drm_i915_private *i915, u32 size,\r\nunsigned int tiling, unsigned int stride)\r\n{\r\nGEM_BUG_ON(!size);\r\nif (tiling == I915_TILING_NONE)\r\nreturn I915_GTT_MIN_ALIGNMENT;\r\nif (INTEL_GEN(i915) >= 4)\r\nreturn I965_FENCE_PAGE;\r\nreturn i915_gem_fence_size(i915, size, tiling, stride);\r\n}\r\nstatic bool\r\ni915_tiling_ok(struct drm_i915_gem_object *obj,\r\nunsigned int tiling, unsigned int stride)\r\n{\r\nstruct drm_i915_private *i915 = to_i915(obj->base.dev);\r\nunsigned int tile_width;\r\nif (tiling == I915_TILING_NONE)\r\nreturn true;\r\nif (tiling > I915_TILING_LAST)\r\nreturn false;\r\nif (INTEL_GEN(i915) >= 7) {\r\nif (stride / 128 > GEN7_FENCE_MAX_PITCH_VAL)\r\nreturn false;\r\n} else if (INTEL_GEN(i915) >= 4) {\r\nif (stride / 128 > I965_FENCE_MAX_PITCH_VAL)\r\nreturn false;\r\n} else {\r\nif (stride > 8192)\r\nreturn false;\r\nif (!is_power_of_2(stride))\r\nreturn false;\r\n}\r\nif (IS_GEN2(i915) ||\r\n(tiling == I915_TILING_Y && HAS_128_BYTE_Y_TILING(i915)))\r\ntile_width = 128;\r\nelse\r\ntile_width = 512;\r\nif (!stride || !IS_ALIGNED(stride, tile_width))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool i915_vma_fence_prepare(struct i915_vma *vma,\r\nint tiling_mode, unsigned int stride)\r\n{\r\nstruct drm_i915_private *i915 = vma->vm->i915;\r\nu32 size, alignment;\r\nif (!i915_vma_is_map_and_fenceable(vma))\r\nreturn true;\r\nsize = i915_gem_fence_size(i915, vma->size, tiling_mode, stride);\r\nif (vma->node.size < size)\r\nreturn false;\r\nalignment = i915_gem_fence_alignment(i915, vma->size, tiling_mode, stride);\r\nif (!IS_ALIGNED(vma->node.start, alignment))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int\r\ni915_gem_object_fence_prepare(struct drm_i915_gem_object *obj,\r\nint tiling_mode, unsigned int stride)\r\n{\r\nstruct i915_vma *vma;\r\nint ret;\r\nif (tiling_mode == I915_TILING_NONE)\r\nreturn 0;\r\nlist_for_each_entry(vma, &obj->vma_list, obj_link) {\r\nif (!i915_vma_is_ggtt(vma))\r\nbreak;\r\nif (i915_vma_fence_prepare(vma, tiling_mode, stride))\r\ncontinue;\r\nret = i915_vma_unbind(vma);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint\r\ni915_gem_object_set_tiling(struct drm_i915_gem_object *obj,\r\nunsigned int tiling, unsigned int stride)\r\n{\r\nstruct drm_i915_private *i915 = to_i915(obj->base.dev);\r\nstruct i915_vma *vma;\r\nint err;\r\nBUILD_BUG_ON(I915_TILING_LAST & STRIDE_MASK);\r\nGEM_BUG_ON(!i915_tiling_ok(obj, tiling, stride));\r\nGEM_BUG_ON(!stride ^ (tiling == I915_TILING_NONE));\r\nlockdep_assert_held(&i915->drm.struct_mutex);\r\nif ((tiling | stride) == obj->tiling_and_stride)\r\nreturn 0;\r\nif (i915_gem_object_is_framebuffer(obj))\r\nreturn -EBUSY;\r\nerr = i915_gem_object_fence_prepare(obj, tiling, stride);\r\nif (err)\r\nreturn err;\r\ni915_gem_object_lock(obj);\r\nif (i915_gem_object_is_framebuffer(obj)) {\r\ni915_gem_object_unlock(obj);\r\nreturn -EBUSY;\r\n}\r\nmutex_lock(&obj->mm.lock);\r\nif (obj->mm.pages &&\r\nobj->mm.madv == I915_MADV_WILLNEED &&\r\ni915->quirks & QUIRK_PIN_SWIZZLED_PAGES) {\r\nif (tiling == I915_TILING_NONE) {\r\nGEM_BUG_ON(!obj->mm.quirked);\r\n__i915_gem_object_unpin_pages(obj);\r\nobj->mm.quirked = false;\r\n}\r\nif (!i915_gem_object_is_tiled(obj)) {\r\nGEM_BUG_ON(obj->mm.quirked);\r\n__i915_gem_object_pin_pages(obj);\r\nobj->mm.quirked = true;\r\n}\r\n}\r\nmutex_unlock(&obj->mm.lock);\r\nlist_for_each_entry(vma, &obj->vma_list, obj_link) {\r\nif (!i915_vma_is_ggtt(vma))\r\nbreak;\r\nvma->fence_size =\r\ni915_gem_fence_size(i915, vma->size, tiling, stride);\r\nvma->fence_alignment =\r\ni915_gem_fence_alignment(i915,\r\nvma->size, tiling, stride);\r\nif (vma->fence)\r\nvma->fence->dirty = true;\r\n}\r\nobj->tiling_and_stride = tiling | stride;\r\ni915_gem_object_unlock(obj);\r\ni915_gem_release_mmap(obj);\r\nif (i915_gem_object_needs_bit17_swizzle(obj)) {\r\nif (!obj->bit_17) {\r\nobj->bit_17 = kcalloc(BITS_TO_LONGS(obj->base.size >> PAGE_SHIFT),\r\nsizeof(long), GFP_KERNEL);\r\n}\r\n} else {\r\nkfree(obj->bit_17);\r\nobj->bit_17 = NULL;\r\n}\r\nreturn 0;\r\n}\r\nint\r\ni915_gem_set_tiling_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file)\r\n{\r\nstruct drm_i915_gem_set_tiling *args = data;\r\nstruct drm_i915_gem_object *obj;\r\nint err;\r\nobj = i915_gem_object_lookup(file, args->handle);\r\nif (!obj)\r\nreturn -ENOENT;\r\nif (!i915_tiling_ok(obj, args->tiling_mode, args->stride)) {\r\nerr = -EINVAL;\r\ngoto err;\r\n}\r\nif (args->tiling_mode == I915_TILING_NONE) {\r\nargs->swizzle_mode = I915_BIT_6_SWIZZLE_NONE;\r\nargs->stride = 0;\r\n} else {\r\nif (args->tiling_mode == I915_TILING_X)\r\nargs->swizzle_mode = to_i915(dev)->mm.bit_6_swizzle_x;\r\nelse\r\nargs->swizzle_mode = to_i915(dev)->mm.bit_6_swizzle_y;\r\nif (args->swizzle_mode == I915_BIT_6_SWIZZLE_9_17)\r\nargs->swizzle_mode = I915_BIT_6_SWIZZLE_9;\r\nif (args->swizzle_mode == I915_BIT_6_SWIZZLE_9_10_17)\r\nargs->swizzle_mode = I915_BIT_6_SWIZZLE_9_10;\r\nif (args->swizzle_mode == I915_BIT_6_SWIZZLE_UNKNOWN) {\r\nargs->tiling_mode = I915_TILING_NONE;\r\nargs->swizzle_mode = I915_BIT_6_SWIZZLE_NONE;\r\nargs->stride = 0;\r\n}\r\n}\r\nerr = mutex_lock_interruptible(&dev->struct_mutex);\r\nif (err)\r\ngoto err;\r\nerr = i915_gem_object_set_tiling(obj, args->tiling_mode, args->stride);\r\nmutex_unlock(&dev->struct_mutex);\r\nargs->stride = i915_gem_object_get_stride(obj);\r\nargs->tiling_mode = i915_gem_object_get_tiling(obj);\r\nerr:\r\ni915_gem_object_put(obj);\r\nreturn err;\r\n}\r\nint\r\ni915_gem_get_tiling_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file)\r\n{\r\nstruct drm_i915_gem_get_tiling *args = data;\r\nstruct drm_i915_private *dev_priv = to_i915(dev);\r\nstruct drm_i915_gem_object *obj;\r\nint err = -ENOENT;\r\nrcu_read_lock();\r\nobj = i915_gem_object_lookup_rcu(file, args->handle);\r\nif (obj) {\r\nargs->tiling_mode =\r\nREAD_ONCE(obj->tiling_and_stride) & TILING_MASK;\r\nerr = 0;\r\n}\r\nrcu_read_unlock();\r\nif (unlikely(err))\r\nreturn err;\r\nswitch (args->tiling_mode) {\r\ncase I915_TILING_X:\r\nargs->swizzle_mode = dev_priv->mm.bit_6_swizzle_x;\r\nbreak;\r\ncase I915_TILING_Y:\r\nargs->swizzle_mode = dev_priv->mm.bit_6_swizzle_y;\r\nbreak;\r\ndefault:\r\ncase I915_TILING_NONE:\r\nargs->swizzle_mode = I915_BIT_6_SWIZZLE_NONE;\r\nbreak;\r\n}\r\nif (dev_priv->quirks & QUIRK_PIN_SWIZZLED_PAGES)\r\nargs->phys_swizzle_mode = I915_BIT_6_SWIZZLE_UNKNOWN;\r\nelse\r\nargs->phys_swizzle_mode = args->swizzle_mode;\r\nif (args->swizzle_mode == I915_BIT_6_SWIZZLE_9_17)\r\nargs->swizzle_mode = I915_BIT_6_SWIZZLE_9;\r\nif (args->swizzle_mode == I915_BIT_6_SWIZZLE_9_10_17)\r\nargs->swizzle_mode = I915_BIT_6_SWIZZLE_9_10;\r\nreturn 0;\r\n}
