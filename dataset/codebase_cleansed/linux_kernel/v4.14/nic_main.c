static void nic_reg_write(struct nicpf *nic, u64 offset, u64 val)\r\n{\r\nwriteq_relaxed(val, nic->reg_base + offset);\r\n}\r\nstatic u64 nic_reg_read(struct nicpf *nic, u64 offset)\r\n{\r\nreturn readq_relaxed(nic->reg_base + offset);\r\n}\r\nstatic void nic_enable_mbx_intr(struct nicpf *nic)\r\n{\r\nint vf_cnt = pci_sriov_get_totalvfs(nic->pdev);\r\n#define INTR_MASK(vfs) ((vfs < 64) ? (BIT_ULL(vfs) - 1) : (~0ull))\r\nnic_reg_write(nic, NIC_PF_MAILBOX_INT, INTR_MASK(vf_cnt));\r\nnic_reg_write(nic, NIC_PF_MAILBOX_ENA_W1S, INTR_MASK(vf_cnt));\r\nif (vf_cnt > 64) {\r\nnic_reg_write(nic, NIC_PF_MAILBOX_INT + sizeof(u64),\r\nINTR_MASK(vf_cnt - 64));\r\nnic_reg_write(nic, NIC_PF_MAILBOX_ENA_W1S + sizeof(u64),\r\nINTR_MASK(vf_cnt - 64));\r\n}\r\n}\r\nstatic void nic_clear_mbx_intr(struct nicpf *nic, int vf, int mbx_reg)\r\n{\r\nnic_reg_write(nic, NIC_PF_MAILBOX_INT + (mbx_reg << 3), BIT_ULL(vf));\r\n}\r\nstatic u64 nic_get_mbx_addr(int vf)\r\n{\r\nreturn NIC_PF_VF_0_127_MAILBOX_0_1 + (vf << NIC_VF_NUM_SHIFT);\r\n}\r\nstatic void nic_send_msg_to_vf(struct nicpf *nic, int vf, union nic_mbx *mbx)\r\n{\r\nvoid __iomem *mbx_addr = nic->reg_base + nic_get_mbx_addr(vf);\r\nu64 *msg = (u64 *)mbx;\r\nif (pass1_silicon(nic->pdev)) {\r\nwriteq_relaxed(msg[0], mbx_addr);\r\nwriteq_relaxed(msg[1], mbx_addr + 8);\r\n} else {\r\nwriteq_relaxed(msg[1], mbx_addr + 8);\r\nwriteq_relaxed(msg[0], mbx_addr);\r\n}\r\n}\r\nstatic void nic_mbx_send_ready(struct nicpf *nic, int vf)\r\n{\r\nunion nic_mbx mbx = {};\r\nint bgx_idx, lmac;\r\nconst char *mac;\r\nmbx.nic_cfg.msg = NIC_MBOX_MSG_READY;\r\nmbx.nic_cfg.vf_id = vf;\r\nmbx.nic_cfg.tns_mode = NIC_TNS_BYPASS_MODE;\r\nif (vf < nic->num_vf_en) {\r\nbgx_idx = NIC_GET_BGX_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vf]);\r\nlmac = NIC_GET_LMAC_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vf]);\r\nmac = bgx_get_lmac_mac(nic->node, bgx_idx, lmac);\r\nif (mac)\r\nether_addr_copy((u8 *)&mbx.nic_cfg.mac_addr, mac);\r\n}\r\nmbx.nic_cfg.sqs_mode = (vf >= nic->num_vf_en) ? true : false;\r\nmbx.nic_cfg.node_id = nic->node;\r\nmbx.nic_cfg.loopback_supported = vf < nic->num_vf_en;\r\nnic_send_msg_to_vf(nic, vf, &mbx);\r\n}\r\nstatic void nic_mbx_send_ack(struct nicpf *nic, int vf)\r\n{\r\nunion nic_mbx mbx = {};\r\nmbx.msg.msg = NIC_MBOX_MSG_ACK;\r\nnic_send_msg_to_vf(nic, vf, &mbx);\r\n}\r\nstatic void nic_mbx_send_nack(struct nicpf *nic, int vf)\r\n{\r\nunion nic_mbx mbx = {};\r\nmbx.msg.msg = NIC_MBOX_MSG_NACK;\r\nnic_send_msg_to_vf(nic, vf, &mbx);\r\n}\r\nstatic int nic_rcv_queue_sw_sync(struct nicpf *nic)\r\n{\r\nu16 timeout = ~0x00;\r\nnic_reg_write(nic, NIC_PF_SW_SYNC_RX, 0x01);\r\nwhile (timeout) {\r\nif (nic_reg_read(nic, NIC_PF_SW_SYNC_RX_DONE) & 0x1)\r\nbreak;\r\ntimeout--;\r\n}\r\nnic_reg_write(nic, NIC_PF_SW_SYNC_RX, 0x00);\r\nif (!timeout) {\r\ndev_err(&nic->pdev->dev, "Receive queue software sync failed");\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void nic_get_bgx_stats(struct nicpf *nic, struct bgx_stats_msg *bgx)\r\n{\r\nint bgx_idx, lmac;\r\nunion nic_mbx mbx = {};\r\nbgx_idx = NIC_GET_BGX_FROM_VF_LMAC_MAP(nic->vf_lmac_map[bgx->vf_id]);\r\nlmac = NIC_GET_LMAC_FROM_VF_LMAC_MAP(nic->vf_lmac_map[bgx->vf_id]);\r\nmbx.bgx_stats.msg = NIC_MBOX_MSG_BGX_STATS;\r\nmbx.bgx_stats.vf_id = bgx->vf_id;\r\nmbx.bgx_stats.rx = bgx->rx;\r\nmbx.bgx_stats.idx = bgx->idx;\r\nif (bgx->rx)\r\nmbx.bgx_stats.stats = bgx_get_rx_stats(nic->node, bgx_idx,\r\nlmac, bgx->idx);\r\nelse\r\nmbx.bgx_stats.stats = bgx_get_tx_stats(nic->node, bgx_idx,\r\nlmac, bgx->idx);\r\nnic_send_msg_to_vf(nic, bgx->vf_id, &mbx);\r\n}\r\nstatic int nic_update_hw_frs(struct nicpf *nic, int new_frs, int vf)\r\n{\r\nint bgx, lmac, lmac_cnt;\r\nu64 lmac_credits;\r\nif ((new_frs > NIC_HW_MAX_FRS) || (new_frs < NIC_HW_MIN_FRS))\r\nreturn 1;\r\nbgx = NIC_GET_BGX_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vf]);\r\nlmac = NIC_GET_LMAC_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vf]);\r\nlmac += bgx * MAX_LMAC_PER_BGX;\r\nnew_frs += VLAN_ETH_HLEN + ETH_FCS_LEN + 4;\r\nlmac_cnt = bgx_get_lmac_count(nic->node, bgx);\r\nlmac_credits = nic_reg_read(nic, NIC_PF_LMAC_0_7_CREDIT + (lmac * 8));\r\nlmac_credits &= ~(0xFFFFFULL << 12);\r\nlmac_credits |= (((((48 * 1024) / lmac_cnt) - new_frs) / 16) << 12);\r\nnic_reg_write(nic, NIC_PF_LMAC_0_7_CREDIT + (lmac * 8), lmac_credits);\r\nif (!pass1_silicon(nic->pdev))\r\nnic_reg_write(nic,\r\nNIC_PF_LMAC_0_7_CFG2 + (lmac * 8), new_frs);\r\nreturn 0;\r\n}\r\nstatic void nic_set_tx_pkt_pad(struct nicpf *nic, int size)\r\n{\r\nint lmac, max_lmac;\r\nu16 sdevid;\r\nu64 lmac_cfg;\r\nif (size > 52)\r\nsize = 52;\r\npci_read_config_word(nic->pdev, PCI_SUBSYSTEM_ID, &sdevid);\r\nif (sdevid == PCI_SUBSYS_DEVID_81XX_NIC_PF)\r\nmax_lmac = ((nic->hw->bgx_cnt - 1) * MAX_LMAC_PER_BGX) + 1;\r\nelse\r\nmax_lmac = nic->hw->bgx_cnt * MAX_LMAC_PER_BGX;\r\nfor (lmac = 0; lmac < max_lmac; lmac++) {\r\nlmac_cfg = nic_reg_read(nic, NIC_PF_LMAC_0_7_CFG | (lmac << 3));\r\nlmac_cfg &= ~(0xF << 2);\r\nlmac_cfg |= ((size / 4) << 2);\r\nnic_reg_write(nic, NIC_PF_LMAC_0_7_CFG | (lmac << 3), lmac_cfg);\r\n}\r\n}\r\nstatic void nic_set_lmac_vf_mapping(struct nicpf *nic)\r\n{\r\nunsigned bgx_map = bgx_get_map(nic->node);\r\nint bgx, next_bgx_lmac = 0;\r\nint lmac, lmac_cnt = 0;\r\nu64 lmac_credit;\r\nnic->num_vf_en = 0;\r\nfor (bgx = 0; bgx < nic->hw->bgx_cnt; bgx++) {\r\nif (!(bgx_map & (1 << bgx)))\r\ncontinue;\r\nlmac_cnt = bgx_get_lmac_count(nic->node, bgx);\r\nfor (lmac = 0; lmac < lmac_cnt; lmac++)\r\nnic->vf_lmac_map[next_bgx_lmac++] =\r\nNIC_SET_VF_LMAC_MAP(bgx, lmac);\r\nnic->num_vf_en += lmac_cnt;\r\nlmac_credit = (1ull << 1);\r\nlmac_credit |= (0x1ff << 2);\r\nlmac_credit |= (((((48 * 1024) / lmac_cnt) -\r\nNIC_HW_MAX_FRS) / 16) << 12);\r\nlmac = bgx * MAX_LMAC_PER_BGX;\r\nfor (; lmac < lmac_cnt + (bgx * MAX_LMAC_PER_BGX); lmac++)\r\nnic_reg_write(nic,\r\nNIC_PF_LMAC_0_7_CREDIT + (lmac * 8),\r\nlmac_credit);\r\nif (nic->num_vf_en >= pci_sriov_get_totalvfs(nic->pdev)) {\r\nnic->num_vf_en = pci_sriov_get_totalvfs(nic->pdev);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void nic_free_lmacmem(struct nicpf *nic)\r\n{\r\nkfree(nic->vf_lmac_map);\r\nkfree(nic->link);\r\nkfree(nic->duplex);\r\nkfree(nic->speed);\r\n}\r\nstatic int nic_get_hw_info(struct nicpf *nic)\r\n{\r\nu8 max_lmac;\r\nu16 sdevid;\r\nstruct hw_info *hw = nic->hw;\r\npci_read_config_word(nic->pdev, PCI_SUBSYSTEM_ID, &sdevid);\r\nswitch (sdevid) {\r\ncase PCI_SUBSYS_DEVID_88XX_NIC_PF:\r\nhw->bgx_cnt = MAX_BGX_PER_CN88XX;\r\nhw->chans_per_lmac = 16;\r\nhw->chans_per_bgx = 128;\r\nhw->cpi_cnt = 2048;\r\nhw->rssi_cnt = 4096;\r\nhw->rss_ind_tbl_size = NIC_MAX_RSS_IDR_TBL_SIZE;\r\nhw->tl3_cnt = 256;\r\nhw->tl2_cnt = 64;\r\nhw->tl1_cnt = 2;\r\nhw->tl1_per_bgx = true;\r\nbreak;\r\ncase PCI_SUBSYS_DEVID_81XX_NIC_PF:\r\nhw->bgx_cnt = MAX_BGX_PER_CN81XX;\r\nhw->chans_per_lmac = 8;\r\nhw->chans_per_bgx = 32;\r\nhw->chans_per_rgx = 8;\r\nhw->chans_per_lbk = 24;\r\nhw->cpi_cnt = 512;\r\nhw->rssi_cnt = 256;\r\nhw->rss_ind_tbl_size = 32;\r\nhw->tl3_cnt = 64;\r\nhw->tl2_cnt = 16;\r\nhw->tl1_cnt = 10;\r\nhw->tl1_per_bgx = false;\r\nbreak;\r\ncase PCI_SUBSYS_DEVID_83XX_NIC_PF:\r\nhw->bgx_cnt = MAX_BGX_PER_CN83XX;\r\nhw->chans_per_lmac = 8;\r\nhw->chans_per_bgx = 32;\r\nhw->chans_per_lbk = 64;\r\nhw->cpi_cnt = 2048;\r\nhw->rssi_cnt = 1024;\r\nhw->rss_ind_tbl_size = 64;\r\nhw->tl3_cnt = 256;\r\nhw->tl2_cnt = 64;\r\nhw->tl1_cnt = 18;\r\nhw->tl1_per_bgx = false;\r\nbreak;\r\n}\r\nhw->tl4_cnt = MAX_QUEUES_PER_QSET * pci_sriov_get_totalvfs(nic->pdev);\r\nmax_lmac = hw->bgx_cnt * MAX_LMAC_PER_BGX;\r\nnic->vf_lmac_map = kmalloc_array(max_lmac, sizeof(u8), GFP_KERNEL);\r\nif (!nic->vf_lmac_map)\r\ngoto error;\r\nnic->link = kmalloc_array(max_lmac, sizeof(u8), GFP_KERNEL);\r\nif (!nic->link)\r\ngoto error;\r\nnic->duplex = kmalloc_array(max_lmac, sizeof(u8), GFP_KERNEL);\r\nif (!nic->duplex)\r\ngoto error;\r\nnic->speed = kmalloc_array(max_lmac, sizeof(u32), GFP_KERNEL);\r\nif (!nic->speed)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nnic_free_lmacmem(nic);\r\nreturn -ENOMEM;\r\n}\r\nstatic int nic_init_hw(struct nicpf *nic)\r\n{\r\nint i, err;\r\nu64 cqm_cfg;\r\nerr = nic_get_hw_info(nic);\r\nif (err)\r\nreturn err;\r\nnic_reg_write(nic, NIC_PF_CFG, 0x3);\r\nnic_reg_write(nic, NIC_PF_BP_CFG, (1ULL << 6) | 0x03);\r\nif (nic->pdev->subsystem_device == PCI_SUBSYS_DEVID_88XX_NIC_PF) {\r\nnic_reg_write(nic, NIC_PF_INTF_0_1_SEND_CFG,\r\n(NIC_TNS_BYPASS_MODE << 7) | BGX0_BLOCK);\r\nnic_reg_write(nic, NIC_PF_INTF_0_1_SEND_CFG | (1 << 8),\r\n(NIC_TNS_BYPASS_MODE << 7) | BGX1_BLOCK);\r\n}\r\nnic_reg_write(nic, NIC_PF_INTF_0_1_BP_CFG,\r\n(1ULL << 63) | BGX0_BLOCK);\r\nnic_reg_write(nic, NIC_PF_INTF_0_1_BP_CFG + (1 << 8),\r\n(1ULL << 63) | BGX1_BLOCK);\r\nnic->pkind.minlen = 0;\r\nnic->pkind.maxlen = NIC_HW_MAX_FRS + VLAN_ETH_HLEN + ETH_FCS_LEN + 4;\r\nnic->pkind.lenerr_en = 1;\r\nnic->pkind.rx_hdr = 0;\r\nnic->pkind.hdr_sl = 0;\r\nfor (i = 0; i < NIC_MAX_PKIND; i++)\r\nnic_reg_write(nic, NIC_PF_PKIND_0_15_CFG | (i << 3),\r\n*(u64 *)&nic->pkind);\r\nnic_set_tx_pkt_pad(nic, NIC_HW_MIN_FRS);\r\nnic_reg_write(nic, NIC_PF_INTR_TIMER_CFG, NICPF_CLK_PER_INT_TICK);\r\nnic_reg_write(nic, NIC_PF_RX_ETYPE_0_7,\r\n(2 << 19) | (ETYPE_ALG_VLAN_STRIP << 16) | ETH_P_8021Q);\r\ncqm_cfg = nic_reg_read(nic, NIC_PF_CQM_CFG);\r\nif (cqm_cfg < NICPF_CQM_MIN_DROP_LEVEL)\r\nnic_reg_write(nic, NIC_PF_CQM_CFG, NICPF_CQM_MIN_DROP_LEVEL);\r\nreturn 0;\r\n}\r\nstatic void nic_config_cpi(struct nicpf *nic, struct cpi_cfg_msg *cfg)\r\n{\r\nstruct hw_info *hw = nic->hw;\r\nu32 vnic, bgx, lmac, chan;\r\nu32 padd, cpi_count = 0;\r\nu64 cpi_base, cpi, rssi_base, rssi;\r\nu8 qset, rq_idx = 0;\r\nvnic = cfg->vf_id;\r\nbgx = NIC_GET_BGX_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vnic]);\r\nlmac = NIC_GET_LMAC_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vnic]);\r\nchan = (lmac * hw->chans_per_lmac) + (bgx * hw->chans_per_bgx);\r\ncpi_base = vnic * NIC_MAX_CPI_PER_LMAC;\r\nrssi_base = vnic * hw->rss_ind_tbl_size;\r\nnic_reg_write(nic, NIC_PF_CHAN_0_255_RX_BP_CFG | (chan << 3),\r\n(1ull << 63) | (vnic << 0));\r\nnic_reg_write(nic, NIC_PF_CHAN_0_255_RX_CFG | (chan << 3),\r\n((u64)cfg->cpi_alg << 62) | (cpi_base << 48));\r\nif (cfg->cpi_alg == CPI_ALG_NONE)\r\ncpi_count = 1;\r\nelse if (cfg->cpi_alg == CPI_ALG_VLAN)\r\ncpi_count = 8;\r\nelse if (cfg->cpi_alg == CPI_ALG_VLAN16)\r\ncpi_count = 16;\r\nelse if (cfg->cpi_alg == CPI_ALG_DIFF)\r\ncpi_count = NIC_MAX_CPI_PER_LMAC;\r\nqset = cfg->vf_id;\r\nrssi = rssi_base;\r\nfor (; rssi < (rssi_base + cfg->rq_cnt); rssi++) {\r\nnic_reg_write(nic, NIC_PF_RSSI_0_4097_RQ | (rssi << 3),\r\n(qset << 3) | rq_idx);\r\nrq_idx++;\r\n}\r\nrssi = 0;\r\ncpi = cpi_base;\r\nfor (; cpi < (cpi_base + cpi_count); cpi++) {\r\nif (cfg->cpi_alg != CPI_ALG_DIFF)\r\npadd = cpi % cpi_count;\r\nelse\r\npadd = cpi % 8;\r\nif (pass1_silicon(nic->pdev)) {\r\nnic_reg_write(nic, NIC_PF_CPI_0_2047_CFG | (cpi << 3),\r\n(vnic << 24) | (padd << 16) |\r\n(rssi_base + rssi));\r\n} else {\r\nnic_reg_write(nic, NIC_PF_CPI_0_2047_CFG | (cpi << 3),\r\n(padd << 16));\r\nnic_reg_write(nic, NIC_PF_MPI_0_2047_CFG | (cpi << 3),\r\n(vnic << 24) | (rssi_base + rssi));\r\n}\r\nif ((rssi + 1) >= cfg->rq_cnt)\r\ncontinue;\r\nif (cfg->cpi_alg == CPI_ALG_VLAN)\r\nrssi++;\r\nelse if (cfg->cpi_alg == CPI_ALG_VLAN16)\r\nrssi = ((cpi - cpi_base) & 0xe) >> 1;\r\nelse if (cfg->cpi_alg == CPI_ALG_DIFF)\r\nrssi = ((cpi - cpi_base) & 0x38) >> 3;\r\n}\r\nnic->cpi_base[cfg->vf_id] = cpi_base;\r\nnic->rssi_base[cfg->vf_id] = rssi_base;\r\n}\r\nstatic void nic_send_rss_size(struct nicpf *nic, int vf)\r\n{\r\nunion nic_mbx mbx = {};\r\nu64 *msg;\r\nmsg = (u64 *)&mbx;\r\nmbx.rss_size.msg = NIC_MBOX_MSG_RSS_SIZE;\r\nmbx.rss_size.ind_tbl_size = nic->hw->rss_ind_tbl_size;\r\nnic_send_msg_to_vf(nic, vf, &mbx);\r\n}\r\nstatic void nic_config_rss(struct nicpf *nic, struct rss_cfg_msg *cfg)\r\n{\r\nu8 qset, idx = 0;\r\nu64 cpi_cfg, cpi_base, rssi_base, rssi;\r\nu64 idx_addr;\r\nrssi_base = nic->rssi_base[cfg->vf_id] + cfg->tbl_offset;\r\nrssi = rssi_base;\r\nqset = cfg->vf_id;\r\nfor (; rssi < (rssi_base + cfg->tbl_len); rssi++) {\r\nu8 svf = cfg->ind_tbl[idx] >> 3;\r\nif (svf)\r\nqset = nic->vf_sqs[cfg->vf_id][svf - 1];\r\nelse\r\nqset = cfg->vf_id;\r\nnic_reg_write(nic, NIC_PF_RSSI_0_4097_RQ | (rssi << 3),\r\n(qset << 3) | (cfg->ind_tbl[idx] & 0x7));\r\nidx++;\r\n}\r\ncpi_base = nic->cpi_base[cfg->vf_id];\r\nif (pass1_silicon(nic->pdev))\r\nidx_addr = NIC_PF_CPI_0_2047_CFG;\r\nelse\r\nidx_addr = NIC_PF_MPI_0_2047_CFG;\r\ncpi_cfg = nic_reg_read(nic, idx_addr | (cpi_base << 3));\r\ncpi_cfg &= ~(0xFULL << 20);\r\ncpi_cfg |= (cfg->hash_bits << 20);\r\nnic_reg_write(nic, idx_addr | (cpi_base << 3), cpi_cfg);\r\n}\r\nstatic void nic_tx_channel_cfg(struct nicpf *nic, u8 vnic,\r\nstruct sq_cfg_msg *sq)\r\n{\r\nstruct hw_info *hw = nic->hw;\r\nu32 bgx, lmac, chan;\r\nu32 tl2, tl3, tl4;\r\nu32 rr_quantum;\r\nu8 sq_idx = sq->sq_num;\r\nu8 pqs_vnic;\r\nint svf;\r\nif (sq->sqs_mode)\r\npqs_vnic = nic->pqs_vf[vnic];\r\nelse\r\npqs_vnic = vnic;\r\nbgx = NIC_GET_BGX_FROM_VF_LMAC_MAP(nic->vf_lmac_map[pqs_vnic]);\r\nlmac = NIC_GET_LMAC_FROM_VF_LMAC_MAP(nic->vf_lmac_map[pqs_vnic]);\r\nrr_quantum = ((NIC_HW_MAX_FRS + 24) / 4);\r\nif (hw->tl1_per_bgx) {\r\ntl4 = bgx * (hw->tl4_cnt / hw->bgx_cnt);\r\nif (!sq->sqs_mode) {\r\ntl4 += (lmac * MAX_QUEUES_PER_QSET);\r\n} else {\r\nfor (svf = 0; svf < MAX_SQS_PER_VF; svf++) {\r\nif (nic->vf_sqs[pqs_vnic][svf] == vnic)\r\nbreak;\r\n}\r\ntl4 += (MAX_LMAC_PER_BGX * MAX_QUEUES_PER_QSET);\r\ntl4 += (lmac * MAX_QUEUES_PER_QSET * MAX_SQS_PER_VF);\r\ntl4 += (svf * MAX_QUEUES_PER_QSET);\r\n}\r\n} else {\r\ntl4 = (vnic * MAX_QUEUES_PER_QSET);\r\n}\r\ntl4 += sq_idx;\r\ntl3 = tl4 / (hw->tl4_cnt / hw->tl3_cnt);\r\nnic_reg_write(nic, NIC_PF_QSET_0_127_SQ_0_7_CFG2 |\r\n((u64)vnic << NIC_QS_ID_SHIFT) |\r\n((u32)sq_idx << NIC_Q_NUM_SHIFT), tl4);\r\nnic_reg_write(nic, NIC_PF_TL4_0_1023_CFG | (tl4 << 3),\r\n((u64)vnic << 27) | ((u32)sq_idx << 24) | rr_quantum);\r\nnic_reg_write(nic, NIC_PF_TL3_0_255_CFG | (tl3 << 3), rr_quantum);\r\nchan = (lmac * hw->chans_per_lmac) + (bgx * hw->chans_per_bgx);\r\nif (hw->tl1_per_bgx)\r\nnic_reg_write(nic, NIC_PF_TL3_0_255_CHAN | (tl3 << 3), chan);\r\nelse\r\nnic_reg_write(nic, NIC_PF_TL3_0_255_CHAN | (tl3 << 3), 0);\r\nnic_reg_write(nic, NIC_PF_CHAN_0_255_TX_CFG | (chan << 3), 1);\r\ntl2 = tl3 >> 2;\r\nnic_reg_write(nic, NIC_PF_TL3A_0_63_CFG | (tl2 << 3), tl2);\r\nnic_reg_write(nic, NIC_PF_TL2_0_63_CFG | (tl2 << 3), rr_quantum);\r\nnic_reg_write(nic, NIC_PF_TL2_0_63_PRI | (tl2 << 3), 0x00);\r\nif (!hw->tl1_per_bgx)\r\nnic_reg_write(nic, NIC_PF_TL2_LMAC | (tl2 << 3),\r\nlmac + (bgx * MAX_LMAC_PER_BGX));\r\n}\r\nstatic void nic_send_pnicvf(struct nicpf *nic, int sqs)\r\n{\r\nunion nic_mbx mbx = {};\r\nmbx.nicvf.msg = NIC_MBOX_MSG_PNICVF_PTR;\r\nmbx.nicvf.nicvf = nic->nicvf[nic->pqs_vf[sqs]];\r\nnic_send_msg_to_vf(nic, sqs, &mbx);\r\n}\r\nstatic void nic_send_snicvf(struct nicpf *nic, struct nicvf_ptr *nicvf)\r\n{\r\nunion nic_mbx mbx = {};\r\nint sqs_id = nic->vf_sqs[nicvf->vf_id][nicvf->sqs_id];\r\nmbx.nicvf.msg = NIC_MBOX_MSG_SNICVF_PTR;\r\nmbx.nicvf.sqs_id = nicvf->sqs_id;\r\nmbx.nicvf.nicvf = nic->nicvf[sqs_id];\r\nnic_send_msg_to_vf(nic, nicvf->vf_id, &mbx);\r\n}\r\nstatic int nic_nxt_avail_sqs(struct nicpf *nic)\r\n{\r\nint sqs;\r\nfor (sqs = 0; sqs < nic->num_sqs_en; sqs++) {\r\nif (!nic->sqs_used[sqs])\r\nnic->sqs_used[sqs] = true;\r\nelse\r\ncontinue;\r\nreturn sqs + nic->num_vf_en;\r\n}\r\nreturn -1;\r\n}\r\nstatic void nic_alloc_sqs(struct nicpf *nic, struct sqs_alloc *sqs)\r\n{\r\nunion nic_mbx mbx = {};\r\nint idx, alloc_qs = 0;\r\nint sqs_id;\r\nif (!nic->num_sqs_en)\r\ngoto send_mbox;\r\nfor (idx = 0; idx < sqs->qs_count; idx++) {\r\nsqs_id = nic_nxt_avail_sqs(nic);\r\nif (sqs_id < 0)\r\nbreak;\r\nnic->vf_sqs[sqs->vf_id][idx] = sqs_id;\r\nnic->pqs_vf[sqs_id] = sqs->vf_id;\r\nalloc_qs++;\r\n}\r\nsend_mbox:\r\nmbx.sqs_alloc.msg = NIC_MBOX_MSG_ALLOC_SQS;\r\nmbx.sqs_alloc.vf_id = sqs->vf_id;\r\nmbx.sqs_alloc.qs_count = alloc_qs;\r\nnic_send_msg_to_vf(nic, sqs->vf_id, &mbx);\r\n}\r\nstatic int nic_config_loopback(struct nicpf *nic, struct set_loopback *lbk)\r\n{\r\nint bgx_idx, lmac_idx;\r\nif (lbk->vf_id >= nic->num_vf_en)\r\nreturn -1;\r\nbgx_idx = NIC_GET_BGX_FROM_VF_LMAC_MAP(nic->vf_lmac_map[lbk->vf_id]);\r\nlmac_idx = NIC_GET_LMAC_FROM_VF_LMAC_MAP(nic->vf_lmac_map[lbk->vf_id]);\r\nbgx_lmac_internal_loopback(nic->node, bgx_idx, lmac_idx, lbk->enable);\r\nnic_reg_write(nic, NIC_PF_CQ_AVG_CFG,\r\n(BIT_ULL(20) | 0x2ull << 14 | 0x1));\r\nnic_reg_write(nic, NIC_PF_RRM_AVG_CFG,\r\n(BIT_ULL(20) | 0x3ull << 14 | 0x1));\r\nreturn 0;\r\n}\r\nstatic int nic_reset_stat_counters(struct nicpf *nic,\r\nint vf, struct reset_stat_cfg *cfg)\r\n{\r\nint i, stat, qnum;\r\nu64 reg_addr;\r\nfor (i = 0; i < RX_STATS_ENUM_LAST; i++) {\r\nif (cfg->rx_stat_mask & BIT(i)) {\r\nreg_addr = NIC_PF_VNIC_0_127_RX_STAT_0_13 |\r\n(vf << NIC_QS_ID_SHIFT) |\r\n(i << 3);\r\nnic_reg_write(nic, reg_addr, 0);\r\n}\r\n}\r\nfor (i = 0; i < TX_STATS_ENUM_LAST; i++) {\r\nif (cfg->tx_stat_mask & BIT(i)) {\r\nreg_addr = NIC_PF_VNIC_0_127_TX_STAT_0_4 |\r\n(vf << NIC_QS_ID_SHIFT) |\r\n(i << 3);\r\nnic_reg_write(nic, reg_addr, 0);\r\n}\r\n}\r\nfor (i = 0; i <= 15; i++) {\r\nqnum = i >> 1;\r\nstat = i & 1 ? 1 : 0;\r\nreg_addr = (vf << NIC_QS_ID_SHIFT) |\r\n(qnum << NIC_Q_NUM_SHIFT) | (stat << 3);\r\nif (cfg->rq_stat_mask & BIT(i)) {\r\nreg_addr |= NIC_PF_QSET_0_127_RQ_0_7_STAT_0_1;\r\nnic_reg_write(nic, reg_addr, 0);\r\n}\r\nif (cfg->sq_stat_mask & BIT(i)) {\r\nreg_addr |= NIC_PF_QSET_0_127_SQ_0_7_STAT_0_1;\r\nnic_reg_write(nic, reg_addr, 0);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void nic_enable_tunnel_parsing(struct nicpf *nic, int vf)\r\n{\r\nu64 prot_def = (IPV6_PROT << 32) | (IPV4_PROT << 16) | ET_PROT;\r\nu64 vxlan_prot_def = (IPV6_PROT_DEF << 32) |\r\n(IPV4_PROT_DEF) << 16 | ET_PROT_DEF;\r\nnic_reg_write(nic, NIC_PF_RX_GENEVE_DEF,\r\n(1ULL << 63 | UDP_GENEVE_PORT_NUM));\r\nnic_reg_write(nic, NIC_PF_RX_GENEVE_PROT_DEF,\r\n((7ULL << 61) | prot_def));\r\nnic_reg_write(nic, NIC_PF_RX_NVGRE_PROT_DEF,\r\n((7ULL << 61) | prot_def));\r\nnic_reg_write(nic, NIC_PF_RX_VXLAN_DEF_0_1,\r\n((1ULL << 63) | UDP_VXLAN_PORT_NUM));\r\nnic_reg_write(nic, NIC_PF_RX_VXLAN_PROT_DEF,\r\n((0xfULL << 60) | vxlan_prot_def));\r\n}\r\nstatic void nic_enable_vf(struct nicpf *nic, int vf, bool enable)\r\n{\r\nint bgx, lmac;\r\nnic->vf_enabled[vf] = enable;\r\nif (vf >= nic->num_vf_en)\r\nreturn;\r\nbgx = NIC_GET_BGX_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vf]);\r\nlmac = NIC_GET_LMAC_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vf]);\r\nbgx_lmac_rx_tx_enable(nic->node, bgx, lmac, enable);\r\n}\r\nstatic void nic_pause_frame(struct nicpf *nic, int vf, struct pfc *cfg)\r\n{\r\nint bgx, lmac;\r\nstruct pfc pfc;\r\nunion nic_mbx mbx = {};\r\nif (vf >= nic->num_vf_en)\r\nreturn;\r\nbgx = NIC_GET_BGX_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vf]);\r\nlmac = NIC_GET_LMAC_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vf]);\r\nif (cfg->get) {\r\nbgx_lmac_get_pfc(nic->node, bgx, lmac, &pfc);\r\nmbx.pfc.msg = NIC_MBOX_MSG_PFC;\r\nmbx.pfc.autoneg = pfc.autoneg;\r\nmbx.pfc.fc_rx = pfc.fc_rx;\r\nmbx.pfc.fc_tx = pfc.fc_tx;\r\nnic_send_msg_to_vf(nic, vf, &mbx);\r\n} else {\r\nbgx_lmac_set_pfc(nic->node, bgx, lmac, cfg);\r\nnic_mbx_send_ack(nic, vf);\r\n}\r\n}\r\nstatic void nic_handle_mbx_intr(struct nicpf *nic, int vf)\r\n{\r\nunion nic_mbx mbx = {};\r\nu64 *mbx_data;\r\nu64 mbx_addr;\r\nu64 reg_addr;\r\nu64 cfg;\r\nint bgx, lmac;\r\nint i;\r\nint ret = 0;\r\nnic->mbx_lock[vf] = true;\r\nmbx_addr = nic_get_mbx_addr(vf);\r\nmbx_data = (u64 *)&mbx;\r\nfor (i = 0; i < NIC_PF_VF_MAILBOX_SIZE; i++) {\r\n*mbx_data = nic_reg_read(nic, mbx_addr);\r\nmbx_data++;\r\nmbx_addr += sizeof(u64);\r\n}\r\ndev_dbg(&nic->pdev->dev, "%s: Mailbox msg 0x%02x from VF%d\n",\r\n__func__, mbx.msg.msg, vf);\r\nswitch (mbx.msg.msg) {\r\ncase NIC_MBOX_MSG_READY:\r\nnic_mbx_send_ready(nic, vf);\r\nif (vf < nic->num_vf_en) {\r\nnic->link[vf] = 0;\r\nnic->duplex[vf] = 0;\r\nnic->speed[vf] = 0;\r\n}\r\ngoto unlock;\r\ncase NIC_MBOX_MSG_QS_CFG:\r\nreg_addr = NIC_PF_QSET_0_127_CFG |\r\n(mbx.qs.num << NIC_QS_ID_SHIFT);\r\ncfg = mbx.qs.cfg;\r\nif (vf >= nic->num_vf_en) {\r\ncfg = cfg & (~0x7FULL);\r\ncfg |= nic->pqs_vf[vf];\r\n}\r\nnic_reg_write(nic, reg_addr, cfg);\r\nbreak;\r\ncase NIC_MBOX_MSG_RQ_CFG:\r\nreg_addr = NIC_PF_QSET_0_127_RQ_0_7_CFG |\r\n(mbx.rq.qs_num << NIC_QS_ID_SHIFT) |\r\n(mbx.rq.rq_num << NIC_Q_NUM_SHIFT);\r\nnic_reg_write(nic, reg_addr, mbx.rq.cfg);\r\nif (pass2_silicon(nic->pdev))\r\nnic_reg_write(nic, NIC_PF_RX_CFG, 0x01);\r\nif (!pass1_silicon(nic->pdev))\r\nnic_enable_tunnel_parsing(nic, vf);\r\nbreak;\r\ncase NIC_MBOX_MSG_RQ_BP_CFG:\r\nreg_addr = NIC_PF_QSET_0_127_RQ_0_7_BP_CFG |\r\n(mbx.rq.qs_num << NIC_QS_ID_SHIFT) |\r\n(mbx.rq.rq_num << NIC_Q_NUM_SHIFT);\r\nnic_reg_write(nic, reg_addr, mbx.rq.cfg);\r\nbreak;\r\ncase NIC_MBOX_MSG_RQ_SW_SYNC:\r\nret = nic_rcv_queue_sw_sync(nic);\r\nbreak;\r\ncase NIC_MBOX_MSG_RQ_DROP_CFG:\r\nreg_addr = NIC_PF_QSET_0_127_RQ_0_7_DROP_CFG |\r\n(mbx.rq.qs_num << NIC_QS_ID_SHIFT) |\r\n(mbx.rq.rq_num << NIC_Q_NUM_SHIFT);\r\nnic_reg_write(nic, reg_addr, mbx.rq.cfg);\r\nbreak;\r\ncase NIC_MBOX_MSG_SQ_CFG:\r\nreg_addr = NIC_PF_QSET_0_127_SQ_0_7_CFG |\r\n(mbx.sq.qs_num << NIC_QS_ID_SHIFT) |\r\n(mbx.sq.sq_num << NIC_Q_NUM_SHIFT);\r\nnic_reg_write(nic, reg_addr, mbx.sq.cfg);\r\nnic_tx_channel_cfg(nic, mbx.qs.num, &mbx.sq);\r\nbreak;\r\ncase NIC_MBOX_MSG_SET_MAC:\r\nif (vf >= nic->num_vf_en) {\r\nret = -1;\r\nbreak;\r\n}\r\nlmac = mbx.mac.vf_id;\r\nbgx = NIC_GET_BGX_FROM_VF_LMAC_MAP(nic->vf_lmac_map[lmac]);\r\nlmac = NIC_GET_LMAC_FROM_VF_LMAC_MAP(nic->vf_lmac_map[lmac]);\r\nbgx_set_lmac_mac(nic->node, bgx, lmac, mbx.mac.mac_addr);\r\nbreak;\r\ncase NIC_MBOX_MSG_SET_MAX_FRS:\r\nret = nic_update_hw_frs(nic, mbx.frs.max_frs,\r\nmbx.frs.vf_id);\r\nbreak;\r\ncase NIC_MBOX_MSG_CPI_CFG:\r\nnic_config_cpi(nic, &mbx.cpi_cfg);\r\nbreak;\r\ncase NIC_MBOX_MSG_RSS_SIZE:\r\nnic_send_rss_size(nic, vf);\r\ngoto unlock;\r\ncase NIC_MBOX_MSG_RSS_CFG:\r\ncase NIC_MBOX_MSG_RSS_CFG_CONT:\r\nnic_config_rss(nic, &mbx.rss_cfg);\r\nbreak;\r\ncase NIC_MBOX_MSG_CFG_DONE:\r\nnic_enable_vf(nic, vf, true);\r\ngoto unlock;\r\ncase NIC_MBOX_MSG_SHUTDOWN:\r\nif (vf >= nic->num_vf_en)\r\nnic->sqs_used[vf - nic->num_vf_en] = false;\r\nnic->pqs_vf[vf] = 0;\r\nnic_enable_vf(nic, vf, false);\r\nbreak;\r\ncase NIC_MBOX_MSG_ALLOC_SQS:\r\nnic_alloc_sqs(nic, &mbx.sqs_alloc);\r\ngoto unlock;\r\ncase NIC_MBOX_MSG_NICVF_PTR:\r\nnic->nicvf[vf] = mbx.nicvf.nicvf;\r\nbreak;\r\ncase NIC_MBOX_MSG_PNICVF_PTR:\r\nnic_send_pnicvf(nic, vf);\r\ngoto unlock;\r\ncase NIC_MBOX_MSG_SNICVF_PTR:\r\nnic_send_snicvf(nic, &mbx.nicvf);\r\ngoto unlock;\r\ncase NIC_MBOX_MSG_BGX_STATS:\r\nnic_get_bgx_stats(nic, &mbx.bgx_stats);\r\ngoto unlock;\r\ncase NIC_MBOX_MSG_LOOPBACK:\r\nret = nic_config_loopback(nic, &mbx.lbk);\r\nbreak;\r\ncase NIC_MBOX_MSG_RESET_STAT_COUNTER:\r\nret = nic_reset_stat_counters(nic, vf, &mbx.reset_stat);\r\nbreak;\r\ncase NIC_MBOX_MSG_PFC:\r\nnic_pause_frame(nic, vf, &mbx.pfc);\r\ngoto unlock;\r\ndefault:\r\ndev_err(&nic->pdev->dev,\r\n"Invalid msg from VF%d, msg 0x%x\n", vf, mbx.msg.msg);\r\nbreak;\r\n}\r\nif (!ret) {\r\nnic_mbx_send_ack(nic, vf);\r\n} else if (mbx.msg.msg != NIC_MBOX_MSG_READY) {\r\ndev_err(&nic->pdev->dev, "NACK for MBOX 0x%02x from VF %d\n",\r\nmbx.msg.msg, vf);\r\nnic_mbx_send_nack(nic, vf);\r\n}\r\nunlock:\r\nnic->mbx_lock[vf] = false;\r\n}\r\nstatic irqreturn_t nic_mbx_intr_handler(int irq, void *nic_irq)\r\n{\r\nstruct nicpf *nic = (struct nicpf *)nic_irq;\r\nint mbx;\r\nu64 intr;\r\nu8 vf, vf_per_mbx_reg = 64;\r\nif (irq == pci_irq_vector(nic->pdev, NIC_PF_INTR_ID_MBOX0))\r\nmbx = 0;\r\nelse\r\nmbx = 1;\r\nintr = nic_reg_read(nic, NIC_PF_MAILBOX_INT + (mbx << 3));\r\ndev_dbg(&nic->pdev->dev, "PF interrupt Mbox%d 0x%llx\n", mbx, intr);\r\nfor (vf = 0; vf < vf_per_mbx_reg; vf++) {\r\nif (intr & (1ULL << vf)) {\r\ndev_dbg(&nic->pdev->dev, "Intr from VF %d\n",\r\nvf + (mbx * vf_per_mbx_reg));\r\nnic_handle_mbx_intr(nic, vf + (mbx * vf_per_mbx_reg));\r\nnic_clear_mbx_intr(nic, vf, mbx);\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void nic_free_all_interrupts(struct nicpf *nic)\r\n{\r\nint irq;\r\nfor (irq = 0; irq < nic->num_vec; irq++) {\r\nif (nic->irq_allocated[irq])\r\nfree_irq(pci_irq_vector(nic->pdev, irq), nic);\r\nnic->irq_allocated[irq] = false;\r\n}\r\n}\r\nstatic int nic_register_interrupts(struct nicpf *nic)\r\n{\r\nint i, ret;\r\nnic->num_vec = pci_msix_vec_count(nic->pdev);\r\nret = pci_alloc_irq_vectors(nic->pdev, nic->num_vec, nic->num_vec,\r\nPCI_IRQ_MSIX);\r\nif (ret < 0) {\r\ndev_err(&nic->pdev->dev,\r\n"Request for #%d msix vectors failed, returned %d\n",\r\nnic->num_vec, ret);\r\nreturn 1;\r\n}\r\nfor (i = NIC_PF_INTR_ID_MBOX0; i < nic->num_vec; i++) {\r\nsprintf(nic->irq_name[i],\r\n"NICPF Mbox%d", (i - NIC_PF_INTR_ID_MBOX0));\r\nret = request_irq(pci_irq_vector(nic->pdev, i),\r\nnic_mbx_intr_handler, 0,\r\nnic->irq_name[i], nic);\r\nif (ret)\r\ngoto fail;\r\nnic->irq_allocated[i] = true;\r\n}\r\nnic_enable_mbx_intr(nic);\r\nreturn 0;\r\nfail:\r\ndev_err(&nic->pdev->dev, "Request irq failed\n");\r\nnic_free_all_interrupts(nic);\r\npci_free_irq_vectors(nic->pdev);\r\nnic->num_vec = 0;\r\nreturn ret;\r\n}\r\nstatic void nic_unregister_interrupts(struct nicpf *nic)\r\n{\r\nnic_free_all_interrupts(nic);\r\npci_free_irq_vectors(nic->pdev);\r\nnic->num_vec = 0;\r\n}\r\nstatic int nic_num_sqs_en(struct nicpf *nic, int vf_en)\r\n{\r\nint pos, sqs_per_vf = MAX_SQS_PER_VF_SINGLE_NODE;\r\nu16 total_vf;\r\nif (num_online_cpus() <= MAX_QUEUES_PER_QSET)\r\nreturn 0;\r\nif (nr_node_ids > 1)\r\nsqs_per_vf = MAX_SQS_PER_VF;\r\npos = pci_find_ext_capability(nic->pdev, PCI_EXT_CAP_ID_SRIOV);\r\npci_read_config_word(nic->pdev, (pos + PCI_SRIOV_TOTAL_VF), &total_vf);\r\nreturn min(total_vf - vf_en, vf_en * sqs_per_vf);\r\n}\r\nstatic int nic_sriov_init(struct pci_dev *pdev, struct nicpf *nic)\r\n{\r\nint pos = 0;\r\nint vf_en;\r\nint err;\r\nu16 total_vf_cnt;\r\npos = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_SRIOV);\r\nif (!pos) {\r\ndev_err(&pdev->dev, "SRIOV capability is not found in PCIe config space\n");\r\nreturn -ENODEV;\r\n}\r\npci_read_config_word(pdev, (pos + PCI_SRIOV_TOTAL_VF), &total_vf_cnt);\r\nif (total_vf_cnt < nic->num_vf_en)\r\nnic->num_vf_en = total_vf_cnt;\r\nif (!total_vf_cnt)\r\nreturn 0;\r\nvf_en = nic->num_vf_en;\r\nnic->num_sqs_en = nic_num_sqs_en(nic, nic->num_vf_en);\r\nvf_en += nic->num_sqs_en;\r\nerr = pci_enable_sriov(pdev, vf_en);\r\nif (err) {\r\ndev_err(&pdev->dev, "SRIOV enable failed, num VF is %d\n",\r\nvf_en);\r\nnic->num_vf_en = 0;\r\nreturn err;\r\n}\r\ndev_info(&pdev->dev, "SRIOV enabled, number of VF available %d\n",\r\nvf_en);\r\nnic->flags |= NIC_SRIOV_ENABLED;\r\nreturn 0;\r\n}\r\nstatic void nic_poll_for_link(struct work_struct *work)\r\n{\r\nunion nic_mbx mbx = {};\r\nstruct nicpf *nic;\r\nstruct bgx_link_status link;\r\nu8 vf, bgx, lmac;\r\nnic = container_of(work, struct nicpf, dwork.work);\r\nmbx.link_status.msg = NIC_MBOX_MSG_BGX_LINK_CHANGE;\r\nfor (vf = 0; vf < nic->num_vf_en; vf++) {\r\nif (!nic->vf_enabled[vf])\r\ncontinue;\r\nbgx = NIC_GET_BGX_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vf]);\r\nlmac = NIC_GET_LMAC_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vf]);\r\nbgx_get_lmac_link_state(nic->node, bgx, lmac, &link);\r\nif (nic->link[vf] == link.link_up)\r\ncontinue;\r\nif (!nic->mbx_lock[vf]) {\r\nnic->link[vf] = link.link_up;\r\nnic->duplex[vf] = link.duplex;\r\nnic->speed[vf] = link.speed;\r\nmbx.link_status.link_up = link.link_up;\r\nmbx.link_status.duplex = link.duplex;\r\nmbx.link_status.speed = link.speed;\r\nmbx.link_status.mac_type = link.mac_type;\r\nnic_send_msg_to_vf(nic, vf, &mbx);\r\n}\r\n}\r\nqueue_delayed_work(nic->check_link, &nic->dwork, HZ * 2);\r\n}\r\nstatic int nic_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct nicpf *nic;\r\nint err;\r\nBUILD_BUG_ON(sizeof(union nic_mbx) > 16);\r\nnic = devm_kzalloc(dev, sizeof(*nic), GFP_KERNEL);\r\nif (!nic)\r\nreturn -ENOMEM;\r\nnic->hw = devm_kzalloc(dev, sizeof(struct hw_info), GFP_KERNEL);\r\nif (!nic->hw) {\r\ndevm_kfree(dev, nic);\r\nreturn -ENOMEM;\r\n}\r\npci_set_drvdata(pdev, nic);\r\nnic->pdev = pdev;\r\nerr = pci_enable_device(pdev);\r\nif (err) {\r\ndev_err(dev, "Failed to enable PCI device\n");\r\npci_set_drvdata(pdev, NULL);\r\nreturn err;\r\n}\r\nerr = pci_request_regions(pdev, DRV_NAME);\r\nif (err) {\r\ndev_err(dev, "PCI request regions failed 0x%x\n", err);\r\ngoto err_disable_device;\r\n}\r\nerr = pci_set_dma_mask(pdev, DMA_BIT_MASK(48));\r\nif (err) {\r\ndev_err(dev, "Unable to get usable DMA configuration\n");\r\ngoto err_release_regions;\r\n}\r\nerr = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(48));\r\nif (err) {\r\ndev_err(dev, "Unable to get 48-bit DMA for consistent allocations\n");\r\ngoto err_release_regions;\r\n}\r\nnic->reg_base = pcim_iomap(pdev, PCI_CFG_REG_BAR_NUM, 0);\r\nif (!nic->reg_base) {\r\ndev_err(dev, "Cannot map config register space, aborting\n");\r\nerr = -ENOMEM;\r\ngoto err_release_regions;\r\n}\r\nnic->node = nic_get_node_id(pdev);\r\nerr = nic_init_hw(nic);\r\nif (err)\r\ngoto err_release_regions;\r\nnic_set_lmac_vf_mapping(nic);\r\nerr = nic_register_interrupts(nic);\r\nif (err)\r\ngoto err_release_regions;\r\nerr = nic_sriov_init(pdev, nic);\r\nif (err)\r\ngoto err_unregister_interrupts;\r\nnic->check_link = alloc_workqueue("check_link_status",\r\nWQ_UNBOUND | WQ_MEM_RECLAIM, 1);\r\nif (!nic->check_link) {\r\nerr = -ENOMEM;\r\ngoto err_disable_sriov;\r\n}\r\nINIT_DELAYED_WORK(&nic->dwork, nic_poll_for_link);\r\nqueue_delayed_work(nic->check_link, &nic->dwork, 0);\r\nreturn 0;\r\nerr_disable_sriov:\r\nif (nic->flags & NIC_SRIOV_ENABLED)\r\npci_disable_sriov(pdev);\r\nerr_unregister_interrupts:\r\nnic_unregister_interrupts(nic);\r\nerr_release_regions:\r\npci_release_regions(pdev);\r\nerr_disable_device:\r\nnic_free_lmacmem(nic);\r\ndevm_kfree(dev, nic->hw);\r\ndevm_kfree(dev, nic);\r\npci_disable_device(pdev);\r\npci_set_drvdata(pdev, NULL);\r\nreturn err;\r\n}\r\nstatic void nic_remove(struct pci_dev *pdev)\r\n{\r\nstruct nicpf *nic = pci_get_drvdata(pdev);\r\nif (nic->flags & NIC_SRIOV_ENABLED)\r\npci_disable_sriov(pdev);\r\nif (nic->check_link) {\r\ncancel_delayed_work_sync(&nic->dwork);\r\ndestroy_workqueue(nic->check_link);\r\n}\r\nnic_unregister_interrupts(nic);\r\npci_release_regions(pdev);\r\nnic_free_lmacmem(nic);\r\ndevm_kfree(&pdev->dev, nic->hw);\r\ndevm_kfree(&pdev->dev, nic);\r\npci_disable_device(pdev);\r\npci_set_drvdata(pdev, NULL);\r\n}\r\nstatic int __init nic_init_module(void)\r\n{\r\npr_info("%s, ver %s\n", DRV_NAME, DRV_VERSION);\r\nreturn pci_register_driver(&nic_driver);\r\n}\r\nstatic void __exit nic_cleanup_module(void)\r\n{\r\npci_unregister_driver(&nic_driver);\r\n}
