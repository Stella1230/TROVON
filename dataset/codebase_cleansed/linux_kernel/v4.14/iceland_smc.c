static void iceland_initialize_power_tune_defaults(struct pp_hwmgr *hwmgr)\r\n{\r\nstruct iceland_smumgr *smu_data = (struct iceland_smumgr *)(hwmgr->smumgr->backend);\r\nstruct cgs_system_info sys_info = {0};\r\nuint32_t dev_id;\r\nsys_info.size = sizeof(struct cgs_system_info);\r\nsys_info.info_id = CGS_SYSTEM_INFO_PCIE_DEV;\r\ncgs_query_system_info(hwmgr->device, &sys_info);\r\ndev_id = (uint32_t)sys_info.value;\r\nswitch (dev_id) {\r\ncase DEVICE_ID_VI_ICELAND_M_6900:\r\ncase DEVICE_ID_VI_ICELAND_M_6903:\r\nsmu_data->power_tune_defaults = &defaults_icelandxt;\r\nbreak;\r\ncase DEVICE_ID_VI_ICELAND_M_6901:\r\ncase DEVICE_ID_VI_ICELAND_M_6902:\r\nsmu_data->power_tune_defaults = &defaults_icelandpro;\r\nbreak;\r\ndefault:\r\nsmu_data->power_tune_defaults = &defaults_iceland;\r\npr_warn("Unknown V.I. Device ID.\n");\r\nbreak;\r\n}\r\nreturn;\r\n}\r\nstatic int iceland_populate_svi_load_line(struct pp_hwmgr *hwmgr)\r\n{\r\nstruct iceland_smumgr *smu_data = (struct iceland_smumgr *)(hwmgr->smumgr->backend);\r\nconst struct iceland_pt_defaults *defaults = smu_data->power_tune_defaults;\r\nsmu_data->power_tune_table.SviLoadLineEn = defaults->svi_load_line_en;\r\nsmu_data->power_tune_table.SviLoadLineVddC = defaults->svi_load_line_vddc;\r\nsmu_data->power_tune_table.SviLoadLineTrimVddC = 3;\r\nsmu_data->power_tune_table.SviLoadLineOffsetVddC = 0;\r\nreturn 0;\r\n}\r\nstatic int iceland_populate_tdc_limit(struct pp_hwmgr *hwmgr)\r\n{\r\nuint16_t tdc_limit;\r\nstruct iceland_smumgr *smu_data = (struct iceland_smumgr *)(hwmgr->smumgr->backend);\r\nconst struct iceland_pt_defaults *defaults = smu_data->power_tune_defaults;\r\ntdc_limit = (uint16_t)(hwmgr->dyn_state.cac_dtp_table->usTDC * 256);\r\nsmu_data->power_tune_table.TDC_VDDC_PkgLimit =\r\nCONVERT_FROM_HOST_TO_SMC_US(tdc_limit);\r\nsmu_data->power_tune_table.TDC_VDDC_ThrottleReleaseLimitPerc =\r\ndefaults->tdc_vddc_throttle_release_limit_perc;\r\nsmu_data->power_tune_table.TDC_MAWt = defaults->tdc_mawt;\r\nreturn 0;\r\n}\r\nstatic int iceland_populate_dw8(struct pp_hwmgr *hwmgr, uint32_t fuse_table_offset)\r\n{\r\nstruct iceland_smumgr *smu_data = (struct iceland_smumgr *)(hwmgr->smumgr->backend);\r\nconst struct iceland_pt_defaults *defaults = smu_data->power_tune_defaults;\r\nuint32_t temp;\r\nif (smu7_read_smc_sram_dword(hwmgr->smumgr,\r\nfuse_table_offset +\r\noffsetof(SMU71_Discrete_PmFuses, TdcWaterfallCtl),\r\n(uint32_t *)&temp, SMC_RAM_END))\r\nPP_ASSERT_WITH_CODE(false,\r\n"Attempt to read PmFuses.DW6 (SviLoadLineEn) from SMC Failed!",\r\nreturn -EINVAL);\r\nelse\r\nsmu_data->power_tune_table.TdcWaterfallCtl = defaults->tdc_waterfall_ctl;\r\nreturn 0;\r\n}\r\nstatic int iceland_populate_temperature_scaler(struct pp_hwmgr *hwmgr)\r\n{\r\nreturn 0;\r\n}\r\nstatic int iceland_populate_gnb_lpml(struct pp_hwmgr *hwmgr)\r\n{\r\nint i;\r\nstruct iceland_smumgr *smu_data = (struct iceland_smumgr *)(hwmgr->smumgr->backend);\r\nfor (i = 0; i < 8; i++)\r\nsmu_data->power_tune_table.GnbLPML[i] = 0;\r\nreturn 0;\r\n}\r\nstatic int iceland_min_max_vgnb_lpml_id_from_bapm_vddc(struct pp_hwmgr *hwmgr)\r\n{\r\nreturn 0;\r\n}\r\nstatic int iceland_populate_bapm_vddc_base_leakage_sidd(struct pp_hwmgr *hwmgr)\r\n{\r\nstruct iceland_smumgr *smu_data = (struct iceland_smumgr *)(hwmgr->smumgr->backend);\r\nuint16_t HiSidd = smu_data->power_tune_table.BapmVddCBaseLeakageHiSidd;\r\nuint16_t LoSidd = smu_data->power_tune_table.BapmVddCBaseLeakageLoSidd;\r\nstruct phm_cac_tdp_table *cac_table = hwmgr->dyn_state.cac_dtp_table;\r\nHiSidd = (uint16_t)(cac_table->usHighCACLeakage / 100 * 256);\r\nLoSidd = (uint16_t)(cac_table->usLowCACLeakage / 100 * 256);\r\nsmu_data->power_tune_table.BapmVddCBaseLeakageHiSidd =\r\nCONVERT_FROM_HOST_TO_SMC_US(HiSidd);\r\nsmu_data->power_tune_table.BapmVddCBaseLeakageLoSidd =\r\nCONVERT_FROM_HOST_TO_SMC_US(LoSidd);\r\nreturn 0;\r\n}\r\nstatic int iceland_populate_bapm_vddc_vid_sidd(struct pp_hwmgr *hwmgr)\r\n{\r\nint i;\r\nstruct iceland_smumgr *smu_data = (struct iceland_smumgr *)(hwmgr->smumgr->backend);\r\nuint8_t *hi_vid = smu_data->power_tune_table.BapmVddCVidHiSidd;\r\nuint8_t *lo_vid = smu_data->power_tune_table.BapmVddCVidLoSidd;\r\nPP_ASSERT_WITH_CODE(NULL != hwmgr->dyn_state.cac_leakage_table,\r\n"The CAC Leakage table does not exist!", return -EINVAL);\r\nPP_ASSERT_WITH_CODE(hwmgr->dyn_state.cac_leakage_table->count <= 8,\r\n"There should never be more than 8 entries for BapmVddcVid!!!", return -EINVAL);\r\nPP_ASSERT_WITH_CODE(hwmgr->dyn_state.cac_leakage_table->count == hwmgr->dyn_state.vddc_dependency_on_sclk->count,\r\n"CACLeakageTable->count and VddcDependencyOnSCLk->count not equal", return -EINVAL);\r\nif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_EVV)) {\r\nfor (i = 0; (uint32_t) i < hwmgr->dyn_state.cac_leakage_table->count; i++) {\r\nlo_vid[i] = convert_to_vid(hwmgr->dyn_state.cac_leakage_table->entries[i].Vddc1);\r\nhi_vid[i] = convert_to_vid(hwmgr->dyn_state.cac_leakage_table->entries[i].Vddc2);\r\n}\r\n} else {\r\nPP_ASSERT_WITH_CODE(false, "Iceland should always support EVV", return -EINVAL);\r\n}\r\nreturn 0;\r\n}\r\nstatic int iceland_populate_vddc_vid(struct pp_hwmgr *hwmgr)\r\n{\r\nint i;\r\nstruct iceland_smumgr *smu_data = (struct iceland_smumgr *)(hwmgr->smumgr->backend);\r\nuint8_t *vid = smu_data->power_tune_table.VddCVid;\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nPP_ASSERT_WITH_CODE(data->vddc_voltage_table.count <= 8,\r\n"There should never be more than 8 entries for VddcVid!!!",\r\nreturn -EINVAL);\r\nfor (i = 0; i < (int)data->vddc_voltage_table.count; i++) {\r\nvid[i] = convert_to_vid(data->vddc_voltage_table.entries[i].value);\r\n}\r\nreturn 0;\r\n}\r\nstatic int iceland_populate_pm_fuses(struct pp_hwmgr *hwmgr)\r\n{\r\nstruct iceland_smumgr *smu_data = (struct iceland_smumgr *)(hwmgr->smumgr->backend);\r\nuint32_t pm_fuse_table_offset;\r\nif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_PowerContainment)) {\r\nif (smu7_read_smc_sram_dword(hwmgr->smumgr,\r\nSMU71_FIRMWARE_HEADER_LOCATION +\r\noffsetof(SMU71_Firmware_Header, PmFuseTable),\r\n&pm_fuse_table_offset, SMC_RAM_END))\r\nPP_ASSERT_WITH_CODE(false,\r\n"Attempt to get pm_fuse_table_offset Failed!",\r\nreturn -EINVAL);\r\nif (iceland_populate_bapm_vddc_vid_sidd(hwmgr))\r\nPP_ASSERT_WITH_CODE(false,\r\n"Attempt to populate bapm vddc vid Failed!",\r\nreturn -EINVAL);\r\nif (iceland_populate_vddc_vid(hwmgr))\r\nPP_ASSERT_WITH_CODE(false,\r\n"Attempt to populate vddc vid Failed!",\r\nreturn -EINVAL);\r\nif (iceland_populate_svi_load_line(hwmgr))\r\nPP_ASSERT_WITH_CODE(false,\r\n"Attempt to populate SviLoadLine Failed!",\r\nreturn -EINVAL);\r\nif (iceland_populate_tdc_limit(hwmgr))\r\nPP_ASSERT_WITH_CODE(false,\r\n"Attempt to populate TDCLimit Failed!", return -EINVAL);\r\nif (iceland_populate_dw8(hwmgr, pm_fuse_table_offset))\r\nPP_ASSERT_WITH_CODE(false,\r\n"Attempt to populate TdcWaterfallCtl, "\r\n"LPMLTemperature Min and Max Failed!",\r\nreturn -EINVAL);\r\nif (0 != iceland_populate_temperature_scaler(hwmgr))\r\nPP_ASSERT_WITH_CODE(false,\r\n"Attempt to populate LPMLTemperatureScaler Failed!",\r\nreturn -EINVAL);\r\nif (iceland_populate_gnb_lpml(hwmgr))\r\nPP_ASSERT_WITH_CODE(false,\r\n"Attempt to populate GnbLPML Failed!",\r\nreturn -EINVAL);\r\nif (iceland_min_max_vgnb_lpml_id_from_bapm_vddc(hwmgr))\r\nPP_ASSERT_WITH_CODE(false,\r\n"Attempt to populate GnbLPML Min and Max Vid Failed!",\r\nreturn -EINVAL);\r\nif (iceland_populate_bapm_vddc_base_leakage_sidd(hwmgr))\r\nPP_ASSERT_WITH_CODE(false,\r\n"Attempt to populate BapmVddCBaseLeakage Hi and Lo Sidd Failed!",\r\nreturn -EINVAL);\r\nif (smu7_copy_bytes_to_smc(hwmgr->smumgr, pm_fuse_table_offset,\r\n(uint8_t *)&smu_data->power_tune_table,\r\nsizeof(struct SMU71_Discrete_PmFuses), SMC_RAM_END))\r\nPP_ASSERT_WITH_CODE(false,\r\n"Attempt to download PmFuseTable Failed!",\r\nreturn -EINVAL);\r\n}\r\nreturn 0;\r\n}\r\nstatic int iceland_get_dependecy_volt_by_clk(struct pp_hwmgr *hwmgr,\r\nstruct phm_clock_voltage_dependency_table *allowed_clock_voltage_table,\r\nuint32_t clock, uint32_t *vol)\r\n{\r\nuint32_t i = 0;\r\nif (allowed_clock_voltage_table->count == 0)\r\nreturn -EINVAL;\r\nfor (i = 0; i < allowed_clock_voltage_table->count; i++) {\r\nif (allowed_clock_voltage_table->entries[i].clk >= clock) {\r\n*vol = allowed_clock_voltage_table->entries[i].v;\r\nreturn 0;\r\n}\r\n}\r\n*vol = allowed_clock_voltage_table->entries[i - 1].v;\r\nreturn 0;\r\n}\r\nstatic int iceland_get_std_voltage_value_sidd(struct pp_hwmgr *hwmgr,\r\npp_atomctrl_voltage_table_entry *tab, uint16_t *hi,\r\nuint16_t *lo)\r\n{\r\nuint16_t v_index;\r\nbool vol_found = false;\r\n*hi = tab->value * VOLTAGE_SCALE;\r\n*lo = tab->value * VOLTAGE_SCALE;\r\nPP_ASSERT_WITH_CODE(NULL != hwmgr->dyn_state.vddc_dependency_on_sclk,\r\n"The SCLK/VDDC Dependency Table does not exist.\n",\r\nreturn -EINVAL);\r\nif (NULL == hwmgr->dyn_state.cac_leakage_table) {\r\npr_warn("CAC Leakage Table does not exist, using vddc.\n");\r\nreturn 0;\r\n}\r\nfor (v_index = 0; (uint32_t)v_index < hwmgr->dyn_state.vddc_dependency_on_sclk->count; v_index++) {\r\nif (tab->value == hwmgr->dyn_state.vddc_dependency_on_sclk->entries[v_index].v) {\r\nvol_found = true;\r\nif ((uint32_t)v_index < hwmgr->dyn_state.cac_leakage_table->count) {\r\n*lo = hwmgr->dyn_state.cac_leakage_table->entries[v_index].Vddc * VOLTAGE_SCALE;\r\n*hi = (uint16_t)(hwmgr->dyn_state.cac_leakage_table->entries[v_index].Leakage * VOLTAGE_SCALE);\r\n} else {\r\npr_warn("Index from SCLK/VDDC Dependency Table exceeds the CAC Leakage Table index, using maximum index from CAC table.\n");\r\n*lo = hwmgr->dyn_state.cac_leakage_table->entries[hwmgr->dyn_state.cac_leakage_table->count - 1].Vddc * VOLTAGE_SCALE;\r\n*hi = (uint16_t)(hwmgr->dyn_state.cac_leakage_table->entries[hwmgr->dyn_state.cac_leakage_table->count - 1].Leakage * VOLTAGE_SCALE);\r\n}\r\nbreak;\r\n}\r\n}\r\nif (!vol_found) {\r\nfor (v_index = 0; (uint32_t)v_index < hwmgr->dyn_state.vddc_dependency_on_sclk->count; v_index++) {\r\nif (tab->value <= hwmgr->dyn_state.vddc_dependency_on_sclk->entries[v_index].v) {\r\nvol_found = true;\r\nif ((uint32_t)v_index < hwmgr->dyn_state.cac_leakage_table->count) {\r\n*lo = hwmgr->dyn_state.cac_leakage_table->entries[v_index].Vddc * VOLTAGE_SCALE;\r\n*hi = (uint16_t)(hwmgr->dyn_state.cac_leakage_table->entries[v_index].Leakage) * VOLTAGE_SCALE;\r\n} else {\r\npr_warn("Index from SCLK/VDDC Dependency Table exceeds the CAC Leakage Table index in second look up, using maximum index from CAC table.");\r\n*lo = hwmgr->dyn_state.cac_leakage_table->entries[hwmgr->dyn_state.cac_leakage_table->count - 1].Vddc * VOLTAGE_SCALE;\r\n*hi = (uint16_t)(hwmgr->dyn_state.cac_leakage_table->entries[hwmgr->dyn_state.cac_leakage_table->count - 1].Leakage * VOLTAGE_SCALE);\r\n}\r\nbreak;\r\n}\r\n}\r\nif (!vol_found)\r\npr_warn("Unable to get std_vddc from SCLK/VDDC Dependency Table, using vddc.\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int iceland_populate_smc_voltage_table(struct pp_hwmgr *hwmgr,\r\npp_atomctrl_voltage_table_entry *tab,\r\nSMU71_Discrete_VoltageLevel *smc_voltage_tab)\r\n{\r\nint result;\r\nresult = iceland_get_std_voltage_value_sidd(hwmgr, tab,\r\n&smc_voltage_tab->StdVoltageHiSidd,\r\n&smc_voltage_tab->StdVoltageLoSidd);\r\nif (0 != result) {\r\nsmc_voltage_tab->StdVoltageHiSidd = tab->value * VOLTAGE_SCALE;\r\nsmc_voltage_tab->StdVoltageLoSidd = tab->value * VOLTAGE_SCALE;\r\n}\r\nsmc_voltage_tab->Voltage = PP_HOST_TO_SMC_US(tab->value * VOLTAGE_SCALE);\r\nCONVERT_FROM_HOST_TO_SMC_US(smc_voltage_tab->StdVoltageHiSidd);\r\nCONVERT_FROM_HOST_TO_SMC_US(smc_voltage_tab->StdVoltageHiSidd);\r\nreturn 0;\r\n}\r\nstatic int iceland_populate_smc_vddc_table(struct pp_hwmgr *hwmgr,\r\nSMU71_Discrete_DpmTable *table)\r\n{\r\nunsigned int count;\r\nint result;\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\ntable->VddcLevelCount = data->vddc_voltage_table.count;\r\nfor (count = 0; count < table->VddcLevelCount; count++) {\r\nresult = iceland_populate_smc_voltage_table(hwmgr,\r\n&(data->vddc_voltage_table.entries[count]),\r\n&(table->VddcLevel[count]));\r\nPP_ASSERT_WITH_CODE(0 == result, "do not populate SMC VDDC voltage table", return -EINVAL);\r\nif (SMU7_VOLTAGE_CONTROL_BY_GPIO == data->voltage_control)\r\ntable->VddcLevel[count].Smio |= data->vddc_voltage_table.entries[count].smio_low;\r\nelse if (SMU7_VOLTAGE_CONTROL_BY_SVID2 == data->voltage_control)\r\ntable->VddcLevel[count].Smio = 0;\r\n}\r\nCONVERT_FROM_HOST_TO_SMC_UL(table->VddcLevelCount);\r\nreturn 0;\r\n}\r\nstatic int iceland_populate_smc_vdd_ci_table(struct pp_hwmgr *hwmgr,\r\nSMU71_Discrete_DpmTable *table)\r\n{\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nuint32_t count;\r\nint result;\r\ntable->VddciLevelCount = data->vddci_voltage_table.count;\r\nfor (count = 0; count < table->VddciLevelCount; count++) {\r\nresult = iceland_populate_smc_voltage_table(hwmgr,\r\n&(data->vddci_voltage_table.entries[count]),\r\n&(table->VddciLevel[count]));\r\nPP_ASSERT_WITH_CODE(result == 0, "do not populate SMC VDDCI voltage table", return -EINVAL);\r\nif (SMU7_VOLTAGE_CONTROL_BY_GPIO == data->vddci_control)\r\ntable->VddciLevel[count].Smio |= data->vddci_voltage_table.entries[count].smio_low;\r\nelse\r\ntable->VddciLevel[count].Smio |= 0;\r\n}\r\nCONVERT_FROM_HOST_TO_SMC_UL(table->VddciLevelCount);\r\nreturn 0;\r\n}\r\nstatic int iceland_populate_smc_mvdd_table(struct pp_hwmgr *hwmgr,\r\nSMU71_Discrete_DpmTable *table)\r\n{\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nuint32_t count;\r\nint result;\r\ntable->MvddLevelCount = data->mvdd_voltage_table.count;\r\nfor (count = 0; count < table->VddciLevelCount; count++) {\r\nresult = iceland_populate_smc_voltage_table(hwmgr,\r\n&(data->mvdd_voltage_table.entries[count]),\r\n&table->MvddLevel[count]);\r\nPP_ASSERT_WITH_CODE(result == 0, "do not populate SMC mvdd voltage table", return -EINVAL);\r\nif (SMU7_VOLTAGE_CONTROL_BY_GPIO == data->mvdd_control)\r\ntable->MvddLevel[count].Smio |= data->mvdd_voltage_table.entries[count].smio_low;\r\nelse\r\ntable->MvddLevel[count].Smio |= 0;\r\n}\r\nCONVERT_FROM_HOST_TO_SMC_UL(table->MvddLevelCount);\r\nreturn 0;\r\n}\r\nstatic int iceland_populate_smc_voltage_tables(struct pp_hwmgr *hwmgr,\r\nSMU71_Discrete_DpmTable *table)\r\n{\r\nint result;\r\nresult = iceland_populate_smc_vddc_table(hwmgr, table);\r\nPP_ASSERT_WITH_CODE(0 == result,\r\n"can not populate VDDC voltage table to SMC", return -EINVAL);\r\nresult = iceland_populate_smc_vdd_ci_table(hwmgr, table);\r\nPP_ASSERT_WITH_CODE(0 == result,\r\n"can not populate VDDCI voltage table to SMC", return -EINVAL);\r\nresult = iceland_populate_smc_mvdd_table(hwmgr, table);\r\nPP_ASSERT_WITH_CODE(0 == result,\r\n"can not populate MVDD voltage table to SMC", return -EINVAL);\r\nreturn 0;\r\n}\r\nstatic int iceland_populate_ulv_level(struct pp_hwmgr *hwmgr,\r\nstruct SMU71_Discrete_Ulv *state)\r\n{\r\nuint32_t voltage_response_time, ulv_voltage;\r\nint result;\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nstate->CcPwrDynRm = 0;\r\nstate->CcPwrDynRm1 = 0;\r\nresult = pp_tables_get_response_times(hwmgr, &voltage_response_time, &ulv_voltage);\r\nPP_ASSERT_WITH_CODE((0 == result), "can not get ULV voltage value", return result;);\r\nif (ulv_voltage == 0) {\r\ndata->ulv_supported = false;\r\nreturn 0;\r\n}\r\nif (data->voltage_control != SMU7_VOLTAGE_CONTROL_BY_SVID2) {\r\nif (ulv_voltage > hwmgr->dyn_state.vddc_dependency_on_sclk->entries[0].v)\r\nstate->VddcOffset = 0;\r\nelse\r\nstate->VddcOffset = (uint16_t)(hwmgr->dyn_state.vddc_dependency_on_sclk->entries[0].v - ulv_voltage);\r\n} else {\r\nif (ulv_voltage > hwmgr->dyn_state.vddc_dependency_on_sclk->entries[0].v)\r\nstate->VddcOffsetVid = 0;\r\nelse\r\nstate->VddcOffsetVid = (uint8_t)(\r\n(hwmgr->dyn_state.vddc_dependency_on_sclk->entries[0].v - ulv_voltage)\r\n* VOLTAGE_VID_OFFSET_SCALE2\r\n/ VOLTAGE_VID_OFFSET_SCALE1);\r\n}\r\nstate->VddcPhase = 1;\r\nCONVERT_FROM_HOST_TO_SMC_UL(state->CcPwrDynRm);\r\nCONVERT_FROM_HOST_TO_SMC_UL(state->CcPwrDynRm1);\r\nCONVERT_FROM_HOST_TO_SMC_US(state->VddcOffset);\r\nreturn 0;\r\n}\r\nstatic int iceland_populate_ulv_state(struct pp_hwmgr *hwmgr,\r\nSMU71_Discrete_Ulv *ulv_level)\r\n{\r\nreturn iceland_populate_ulv_level(hwmgr, ulv_level);\r\n}\r\nstatic int iceland_populate_smc_link_level(struct pp_hwmgr *hwmgr, SMU71_Discrete_DpmTable *table)\r\n{\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nstruct smu7_dpm_table *dpm_table = &data->dpm_table;\r\nstruct iceland_smumgr *smu_data = (struct iceland_smumgr *)(hwmgr->smumgr->backend);\r\nuint32_t i;\r\nfor (i = 0; i <= dpm_table->pcie_speed_table.count; i++) {\r\ntable->LinkLevel[i].PcieGenSpeed =\r\n(uint8_t)dpm_table->pcie_speed_table.dpm_levels[i].value;\r\ntable->LinkLevel[i].PcieLaneCount =\r\n(uint8_t)encode_pcie_lane_width(dpm_table->pcie_speed_table.dpm_levels[i].param1);\r\ntable->LinkLevel[i].EnabledForActivity =\r\n1;\r\ntable->LinkLevel[i].SPC =\r\n(uint8_t)(data->pcie_spc_cap & 0xff);\r\ntable->LinkLevel[i].DownThreshold =\r\nPP_HOST_TO_SMC_UL(5);\r\ntable->LinkLevel[i].UpThreshold =\r\nPP_HOST_TO_SMC_UL(30);\r\n}\r\nsmu_data->smc_state_table.LinkLevelCount =\r\n(uint8_t)dpm_table->pcie_speed_table.count;\r\ndata->dpm_level_enable_mask.pcie_dpm_enable_mask =\r\nphm_get_dpm_level_enable_mask_value(&dpm_table->pcie_speed_table);\r\nreturn 0;\r\n}\r\nstatic int iceland_calculate_sclk_params(struct pp_hwmgr *hwmgr,\r\nuint32_t engine_clock, SMU71_Discrete_GraphicsLevel *sclk)\r\n{\r\nconst struct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\npp_atomctrl_clock_dividers_vi dividers;\r\nuint32_t spll_func_cntl = data->clock_registers.vCG_SPLL_FUNC_CNTL;\r\nuint32_t spll_func_cntl_3 = data->clock_registers.vCG_SPLL_FUNC_CNTL_3;\r\nuint32_t spll_func_cntl_4 = data->clock_registers.vCG_SPLL_FUNC_CNTL_4;\r\nuint32_t cg_spll_spread_spectrum = data->clock_registers.vCG_SPLL_SPREAD_SPECTRUM;\r\nuint32_t cg_spll_spread_spectrum_2 = data->clock_registers.vCG_SPLL_SPREAD_SPECTRUM_2;\r\nuint32_t reference_clock;\r\nuint32_t reference_divider;\r\nuint32_t fbdiv;\r\nint result;\r\nresult = atomctrl_get_engine_pll_dividers_vi(hwmgr, engine_clock, &dividers);\r\nPP_ASSERT_WITH_CODE(result == 0,\r\n"Error retrieving Engine Clock dividers from VBIOS.", return result);\r\nreference_clock = atomctrl_get_reference_clock(hwmgr);\r\nreference_divider = 1 + dividers.uc_pll_ref_div;\r\nfbdiv = dividers.ul_fb_div.ul_fb_divider & 0x3FFFFFF;\r\nspll_func_cntl = PHM_SET_FIELD(spll_func_cntl,\r\nCG_SPLL_FUNC_CNTL, SPLL_REF_DIV, dividers.uc_pll_ref_div);\r\nspll_func_cntl = PHM_SET_FIELD(spll_func_cntl,\r\nCG_SPLL_FUNC_CNTL, SPLL_PDIV_A, dividers.uc_pll_post_div);\r\nspll_func_cntl_3 = PHM_SET_FIELD(spll_func_cntl_3,\r\nCG_SPLL_FUNC_CNTL_3, SPLL_FB_DIV, fbdiv);\r\nspll_func_cntl_3 = PHM_SET_FIELD(spll_func_cntl_3,\r\nCG_SPLL_FUNC_CNTL_3, SPLL_DITHEN, 1);\r\nif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_EngineSpreadSpectrumSupport)) {\r\npp_atomctrl_internal_ss_info ss_info;\r\nuint32_t vcoFreq = engine_clock * dividers.uc_pll_post_div;\r\nif (0 == atomctrl_get_engine_clock_spread_spectrum(hwmgr, vcoFreq, &ss_info)) {\r\nuint32_t clkS = reference_clock * 5 / (reference_divider * ss_info.speed_spectrum_rate);\r\nuint32_t clkV = 4 * ss_info.speed_spectrum_percentage * fbdiv / (clkS * 10000);\r\ncg_spll_spread_spectrum =\r\nPHM_SET_FIELD(cg_spll_spread_spectrum, CG_SPLL_SPREAD_SPECTRUM, CLKS, clkS);\r\ncg_spll_spread_spectrum =\r\nPHM_SET_FIELD(cg_spll_spread_spectrum, CG_SPLL_SPREAD_SPECTRUM, SSEN, 1);\r\ncg_spll_spread_spectrum_2 =\r\nPHM_SET_FIELD(cg_spll_spread_spectrum_2, CG_SPLL_SPREAD_SPECTRUM_2, CLKV, clkV);\r\n}\r\n}\r\nsclk->SclkFrequency = engine_clock;\r\nsclk->CgSpllFuncCntl3 = spll_func_cntl_3;\r\nsclk->CgSpllFuncCntl4 = spll_func_cntl_4;\r\nsclk->SpllSpreadSpectrum = cg_spll_spread_spectrum;\r\nsclk->SpllSpreadSpectrum2 = cg_spll_spread_spectrum_2;\r\nsclk->SclkDid = (uint8_t)dividers.pll_post_divider;\r\nreturn 0;\r\n}\r\nstatic int iceland_populate_phase_value_based_on_sclk(struct pp_hwmgr *hwmgr,\r\nconst struct phm_phase_shedding_limits_table *pl,\r\nuint32_t sclk, uint32_t *p_shed)\r\n{\r\nunsigned int i;\r\n*p_shed = 1;\r\nfor (i = 0; i < pl->count; i++) {\r\nif (sclk < pl->entries[i].Sclk) {\r\n*p_shed = i;\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int iceland_populate_single_graphic_level(struct pp_hwmgr *hwmgr,\r\nuint32_t engine_clock,\r\nuint16_t sclk_activity_level_threshold,\r\nSMU71_Discrete_GraphicsLevel *graphic_level)\r\n{\r\nint result;\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nresult = iceland_calculate_sclk_params(hwmgr, engine_clock, graphic_level);\r\nresult = iceland_get_dependecy_volt_by_clk(hwmgr,\r\nhwmgr->dyn_state.vddc_dependency_on_sclk, engine_clock,\r\n&graphic_level->MinVddc);\r\nPP_ASSERT_WITH_CODE((0 == result),\r\n"can not find VDDC voltage value for VDDC \\r\nengine clock dependency table", return result);\r\ngraphic_level->SclkFrequency = engine_clock;\r\ngraphic_level->MinVddcPhases = 1;\r\nif (data->vddc_phase_shed_control)\r\niceland_populate_phase_value_based_on_sclk(hwmgr,\r\nhwmgr->dyn_state.vddc_phase_shed_limits_table,\r\nengine_clock,\r\n&graphic_level->MinVddcPhases);\r\ngraphic_level->ActivityLevel = sclk_activity_level_threshold;\r\ngraphic_level->CcPwrDynRm = 0;\r\ngraphic_level->CcPwrDynRm1 = 0;\r\ngraphic_level->EnabledForActivity = 0;\r\ngraphic_level->EnabledForThrottle = 1;\r\ngraphic_level->UpHyst = 0;\r\ngraphic_level->DownHyst = 100;\r\ngraphic_level->VoltageDownHyst = 0;\r\ngraphic_level->PowerThrottle = 0;\r\ndata->display_timing.min_clock_in_sr =\r\nhwmgr->display_config.min_core_set_clock_in_sr;\r\nif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_SclkDeepSleep))\r\ngraphic_level->DeepSleepDivId =\r\nsmu7_get_sleep_divider_id_from_clock(engine_clock,\r\ndata->display_timing.min_clock_in_sr);\r\ngraphic_level->DisplayWatermark = PPSMC_DISPLAY_WATERMARK_LOW;\r\nif (0 == result) {\r\ngraphic_level->MinVddc = PP_HOST_TO_SMC_UL(graphic_level->MinVddc * VOLTAGE_SCALE);\r\nCONVERT_FROM_HOST_TO_SMC_UL(graphic_level->MinVddcPhases);\r\nCONVERT_FROM_HOST_TO_SMC_UL(graphic_level->SclkFrequency);\r\nCONVERT_FROM_HOST_TO_SMC_US(graphic_level->ActivityLevel);\r\nCONVERT_FROM_HOST_TO_SMC_UL(graphic_level->CgSpllFuncCntl3);\r\nCONVERT_FROM_HOST_TO_SMC_UL(graphic_level->CgSpllFuncCntl4);\r\nCONVERT_FROM_HOST_TO_SMC_UL(graphic_level->SpllSpreadSpectrum);\r\nCONVERT_FROM_HOST_TO_SMC_UL(graphic_level->SpllSpreadSpectrum2);\r\nCONVERT_FROM_HOST_TO_SMC_UL(graphic_level->CcPwrDynRm);\r\nCONVERT_FROM_HOST_TO_SMC_UL(graphic_level->CcPwrDynRm1);\r\n}\r\nreturn result;\r\n}\r\nint iceland_populate_all_graphic_levels(struct pp_hwmgr *hwmgr)\r\n{\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nstruct iceland_smumgr *smu_data = (struct iceland_smumgr *)(hwmgr->smumgr->backend);\r\nstruct smu7_dpm_table *dpm_table = &data->dpm_table;\r\nuint32_t level_array_adress = smu_data->smu7_data.dpm_table_start +\r\noffsetof(SMU71_Discrete_DpmTable, GraphicsLevel);\r\nuint32_t level_array_size = sizeof(SMU71_Discrete_GraphicsLevel) *\r\nSMU71_MAX_LEVELS_GRAPHICS;\r\nSMU71_Discrete_GraphicsLevel *levels = smu_data->smc_state_table.GraphicsLevel;\r\nuint32_t i;\r\nuint8_t highest_pcie_level_enabled = 0;\r\nuint8_t lowest_pcie_level_enabled = 0, mid_pcie_level_enabled = 0;\r\nuint8_t count = 0;\r\nint result = 0;\r\nmemset(levels, 0x00, level_array_size);\r\nfor (i = 0; i < dpm_table->sclk_table.count; i++) {\r\nresult = iceland_populate_single_graphic_level(hwmgr,\r\ndpm_table->sclk_table.dpm_levels[i].value,\r\n(uint16_t)smu_data->activity_target[i],\r\n&(smu_data->smc_state_table.GraphicsLevel[i]));\r\nif (result != 0)\r\nreturn result;\r\nif (i > 1)\r\nsmu_data->smc_state_table.GraphicsLevel[i].DeepSleepDivId = 0;\r\n}\r\nsmu_data->smc_state_table.GraphicsLevel[0].EnabledForActivity = 1;\r\nif (dpm_table->sclk_table.count > 1)\r\nsmu_data->smc_state_table.GraphicsLevel[dpm_table->sclk_table.count-1].DisplayWatermark =\r\nPPSMC_DISPLAY_WATERMARK_HIGH;\r\nsmu_data->smc_state_table.GraphicsDpmLevelCount =\r\n(uint8_t)dpm_table->sclk_table.count;\r\ndata->dpm_level_enable_mask.sclk_dpm_enable_mask =\r\nphm_get_dpm_level_enable_mask_value(&dpm_table->sclk_table);\r\nwhile ((data->dpm_level_enable_mask.pcie_dpm_enable_mask &\r\n(1 << (highest_pcie_level_enabled + 1))) != 0) {\r\nhighest_pcie_level_enabled++;\r\n}\r\nwhile ((data->dpm_level_enable_mask.pcie_dpm_enable_mask &\r\n(1 << lowest_pcie_level_enabled)) == 0) {\r\nlowest_pcie_level_enabled++;\r\n}\r\nwhile ((count < highest_pcie_level_enabled) &&\r\n((data->dpm_level_enable_mask.pcie_dpm_enable_mask &\r\n(1 << (lowest_pcie_level_enabled + 1 + count))) == 0)) {\r\ncount++;\r\n}\r\nmid_pcie_level_enabled = (lowest_pcie_level_enabled+1+count) < highest_pcie_level_enabled ?\r\n(lowest_pcie_level_enabled+1+count) : highest_pcie_level_enabled;\r\nfor (i = 2; i < dpm_table->sclk_table.count; i++) {\r\nsmu_data->smc_state_table.GraphicsLevel[i].pcieDpmLevel = highest_pcie_level_enabled;\r\n}\r\nsmu_data->smc_state_table.GraphicsLevel[0].pcieDpmLevel = lowest_pcie_level_enabled;\r\nsmu_data->smc_state_table.GraphicsLevel[1].pcieDpmLevel = mid_pcie_level_enabled;\r\nresult = smu7_copy_bytes_to_smc(hwmgr->smumgr, level_array_adress,\r\n(uint8_t *)levels, (uint32_t)level_array_size,\r\nSMC_RAM_END);\r\nreturn result;\r\n}\r\nstatic int iceland_calculate_mclk_params(\r\nstruct pp_hwmgr *hwmgr,\r\nuint32_t memory_clock,\r\nSMU71_Discrete_MemoryLevel *mclk,\r\nbool strobe_mode,\r\nbool dllStateOn\r\n)\r\n{\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nuint32_t dll_cntl = data->clock_registers.vDLL_CNTL;\r\nuint32_t mclk_pwrmgt_cntl = data->clock_registers.vMCLK_PWRMGT_CNTL;\r\nuint32_t mpll_ad_func_cntl = data->clock_registers.vMPLL_AD_FUNC_CNTL;\r\nuint32_t mpll_dq_func_cntl = data->clock_registers.vMPLL_DQ_FUNC_CNTL;\r\nuint32_t mpll_func_cntl = data->clock_registers.vMPLL_FUNC_CNTL;\r\nuint32_t mpll_func_cntl_1 = data->clock_registers.vMPLL_FUNC_CNTL_1;\r\nuint32_t mpll_func_cntl_2 = data->clock_registers.vMPLL_FUNC_CNTL_2;\r\nuint32_t mpll_ss1 = data->clock_registers.vMPLL_SS1;\r\nuint32_t mpll_ss2 = data->clock_registers.vMPLL_SS2;\r\npp_atomctrl_memory_clock_param mpll_param;\r\nint result;\r\nresult = atomctrl_get_memory_pll_dividers_si(hwmgr,\r\nmemory_clock, &mpll_param, strobe_mode);\r\nPP_ASSERT_WITH_CODE(0 == result,\r\n"Error retrieving Memory Clock Parameters from VBIOS.", return result);\r\nmpll_func_cntl = PHM_SET_FIELD(mpll_func_cntl, MPLL_FUNC_CNTL, BWCTRL, mpll_param.bw_ctrl);\r\nmpll_func_cntl_1 = PHM_SET_FIELD(mpll_func_cntl_1,\r\nMPLL_FUNC_CNTL_1, CLKF, mpll_param.mpll_fb_divider.cl_kf);\r\nmpll_func_cntl_1 = PHM_SET_FIELD(mpll_func_cntl_1,\r\nMPLL_FUNC_CNTL_1, CLKFRAC, mpll_param.mpll_fb_divider.clk_frac);\r\nmpll_func_cntl_1 = PHM_SET_FIELD(mpll_func_cntl_1,\r\nMPLL_FUNC_CNTL_1, VCO_MODE, mpll_param.vco_mode);\r\nmpll_ad_func_cntl = PHM_SET_FIELD(mpll_ad_func_cntl,\r\nMPLL_AD_FUNC_CNTL, YCLK_POST_DIV, mpll_param.mpll_post_divider);\r\nif (data->is_memory_gddr5) {\r\nmpll_dq_func_cntl = PHM_SET_FIELD(mpll_dq_func_cntl,\r\nMPLL_DQ_FUNC_CNTL, YCLK_SEL, mpll_param.yclk_sel);\r\nmpll_dq_func_cntl = PHM_SET_FIELD(mpll_dq_func_cntl,\r\nMPLL_DQ_FUNC_CNTL, YCLK_POST_DIV, mpll_param.mpll_post_divider);\r\n}\r\nif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_MemorySpreadSpectrumSupport)) {\r\npp_atomctrl_internal_ss_info ss_info;\r\nuint32_t freq_nom;\r\nuint32_t tmp;\r\nuint32_t reference_clock = atomctrl_get_mpll_reference_clock(hwmgr);\r\nif (1 == mpll_param.qdr)\r\nfreq_nom = memory_clock * 4 * (1 << mpll_param.mpll_post_divider);\r\nelse\r\nfreq_nom = memory_clock * 2 * (1 << mpll_param.mpll_post_divider);\r\ntmp = (freq_nom / reference_clock);\r\ntmp = tmp * tmp;\r\nif (0 == atomctrl_get_memory_clock_spread_spectrum(hwmgr, freq_nom, &ss_info)) {\r\nuint32_t clks = reference_clock * 5 / ss_info.speed_spectrum_rate;\r\nuint32_t clkv =\r\n(uint32_t)((((131 * ss_info.speed_spectrum_percentage *\r\nss_info.speed_spectrum_rate) / 100) * tmp) / freq_nom);\r\nmpll_ss1 = PHM_SET_FIELD(mpll_ss1, MPLL_SS1, CLKV, clkv);\r\nmpll_ss2 = PHM_SET_FIELD(mpll_ss2, MPLL_SS2, CLKS, clks);\r\n}\r\n}\r\nmclk_pwrmgt_cntl = PHM_SET_FIELD(mclk_pwrmgt_cntl,\r\nMCLK_PWRMGT_CNTL, DLL_SPEED, mpll_param.dll_speed);\r\nmclk_pwrmgt_cntl = PHM_SET_FIELD(mclk_pwrmgt_cntl,\r\nMCLK_PWRMGT_CNTL, MRDCK0_PDNB, dllStateOn);\r\nmclk_pwrmgt_cntl = PHM_SET_FIELD(mclk_pwrmgt_cntl,\r\nMCLK_PWRMGT_CNTL, MRDCK1_PDNB, dllStateOn);\r\nmclk->MclkFrequency = memory_clock;\r\nmclk->MpllFuncCntl = mpll_func_cntl;\r\nmclk->MpllFuncCntl_1 = mpll_func_cntl_1;\r\nmclk->MpllFuncCntl_2 = mpll_func_cntl_2;\r\nmclk->MpllAdFuncCntl = mpll_ad_func_cntl;\r\nmclk->MpllDqFuncCntl = mpll_dq_func_cntl;\r\nmclk->MclkPwrmgtCntl = mclk_pwrmgt_cntl;\r\nmclk->DllCntl = dll_cntl;\r\nmclk->MpllSs1 = mpll_ss1;\r\nmclk->MpllSs2 = mpll_ss2;\r\nreturn 0;\r\n}\r\nstatic uint8_t iceland_get_mclk_frequency_ratio(uint32_t memory_clock,\r\nbool strobe_mode)\r\n{\r\nuint8_t mc_para_index;\r\nif (strobe_mode) {\r\nif (memory_clock < 12500) {\r\nmc_para_index = 0x00;\r\n} else if (memory_clock > 47500) {\r\nmc_para_index = 0x0f;\r\n} else {\r\nmc_para_index = (uint8_t)((memory_clock - 10000) / 2500);\r\n}\r\n} else {\r\nif (memory_clock < 65000) {\r\nmc_para_index = 0x00;\r\n} else if (memory_clock > 135000) {\r\nmc_para_index = 0x0f;\r\n} else {\r\nmc_para_index = (uint8_t)((memory_clock - 60000) / 5000);\r\n}\r\n}\r\nreturn mc_para_index;\r\n}\r\nstatic uint8_t iceland_get_ddr3_mclk_frequency_ratio(uint32_t memory_clock)\r\n{\r\nuint8_t mc_para_index;\r\nif (memory_clock < 10000) {\r\nmc_para_index = 0;\r\n} else if (memory_clock >= 80000) {\r\nmc_para_index = 0x0f;\r\n} else {\r\nmc_para_index = (uint8_t)((memory_clock - 10000) / 5000 + 1);\r\n}\r\nreturn mc_para_index;\r\n}\r\nstatic int iceland_populate_phase_value_based_on_mclk(struct pp_hwmgr *hwmgr, const struct phm_phase_shedding_limits_table *pl,\r\nuint32_t memory_clock, uint32_t *p_shed)\r\n{\r\nunsigned int i;\r\n*p_shed = 1;\r\nfor (i = 0; i < pl->count; i++) {\r\nif (memory_clock < pl->entries[i].Mclk) {\r\n*p_shed = i;\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int iceland_populate_single_memory_level(\r\nstruct pp_hwmgr *hwmgr,\r\nuint32_t memory_clock,\r\nSMU71_Discrete_MemoryLevel *memory_level\r\n)\r\n{\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nint result = 0;\r\nbool dll_state_on;\r\nstruct cgs_display_info info = {0};\r\nuint32_t mclk_edc_wr_enable_threshold = 40000;\r\nuint32_t mclk_edc_enable_threshold = 40000;\r\nuint32_t mclk_strobe_mode_threshold = 40000;\r\nif (hwmgr->dyn_state.vddc_dependency_on_mclk != NULL) {\r\nresult = iceland_get_dependecy_volt_by_clk(hwmgr,\r\nhwmgr->dyn_state.vddc_dependency_on_mclk, memory_clock, &memory_level->MinVddc);\r\nPP_ASSERT_WITH_CODE((0 == result),\r\n"can not find MinVddc voltage value from memory VDDC voltage dependency table", return result);\r\n}\r\nif (data->vddci_control == SMU7_VOLTAGE_CONTROL_NONE) {\r\nmemory_level->MinVddci = memory_level->MinVddc;\r\n} else if (NULL != hwmgr->dyn_state.vddci_dependency_on_mclk) {\r\nresult = iceland_get_dependecy_volt_by_clk(hwmgr,\r\nhwmgr->dyn_state.vddci_dependency_on_mclk,\r\nmemory_clock,\r\n&memory_level->MinVddci);\r\nPP_ASSERT_WITH_CODE((0 == result),\r\n"can not find MinVddci voltage value from memory VDDCI voltage dependency table", return result);\r\n}\r\nmemory_level->MinVddcPhases = 1;\r\nif (data->vddc_phase_shed_control) {\r\niceland_populate_phase_value_based_on_mclk(hwmgr, hwmgr->dyn_state.vddc_phase_shed_limits_table,\r\nmemory_clock, &memory_level->MinVddcPhases);\r\n}\r\nmemory_level->EnabledForThrottle = 1;\r\nmemory_level->EnabledForActivity = 0;\r\nmemory_level->UpHyst = 0;\r\nmemory_level->DownHyst = 100;\r\nmemory_level->VoltageDownHyst = 0;\r\nmemory_level->ActivityLevel = (uint16_t)data->mclk_activity_target;\r\nmemory_level->StutterEnable = 0;\r\nmemory_level->StrobeEnable = 0;\r\nmemory_level->EdcReadEnable = 0;\r\nmemory_level->EdcWriteEnable = 0;\r\nmemory_level->RttEnable = 0;\r\nmemory_level->DisplayWatermark = PPSMC_DISPLAY_WATERMARK_LOW;\r\ncgs_get_active_displays_info(hwmgr->device, &info);\r\ndata->display_timing.num_existing_displays = info.display_count;\r\nmemory_level->StrobeEnable = (mclk_strobe_mode_threshold != 0) &&\r\n(memory_clock <= mclk_strobe_mode_threshold);\r\nif (data->is_memory_gddr5) {\r\nmemory_level->StrobeRatio = iceland_get_mclk_frequency_ratio(memory_clock,\r\nmemory_level->StrobeEnable);\r\nif ((mclk_edc_enable_threshold != 0) &&\r\n(memory_clock > mclk_edc_enable_threshold)) {\r\nmemory_level->EdcReadEnable = 1;\r\n}\r\nif ((mclk_edc_wr_enable_threshold != 0) &&\r\n(memory_clock > mclk_edc_wr_enable_threshold)) {\r\nmemory_level->EdcWriteEnable = 1;\r\n}\r\nif (memory_level->StrobeEnable) {\r\nif (iceland_get_mclk_frequency_ratio(memory_clock, 1) >=\r\n((cgs_read_register(hwmgr->device, mmMC_SEQ_MISC7) >> 16) & 0xf))\r\ndll_state_on = ((cgs_read_register(hwmgr->device, mmMC_SEQ_MISC5) >> 1) & 0x1) ? 1 : 0;\r\nelse\r\ndll_state_on = ((cgs_read_register(hwmgr->device, mmMC_SEQ_MISC6) >> 1) & 0x1) ? 1 : 0;\r\n} else\r\ndll_state_on = data->dll_default_on;\r\n} else {\r\nmemory_level->StrobeRatio =\r\niceland_get_ddr3_mclk_frequency_ratio(memory_clock);\r\ndll_state_on = ((cgs_read_register(hwmgr->device, mmMC_SEQ_MISC5) >> 1) & 0x1) ? 1 : 0;\r\n}\r\nresult = iceland_calculate_mclk_params(hwmgr,\r\nmemory_clock, memory_level, memory_level->StrobeEnable, dll_state_on);\r\nif (0 == result) {\r\nmemory_level->MinVddc = PP_HOST_TO_SMC_UL(memory_level->MinVddc * VOLTAGE_SCALE);\r\nCONVERT_FROM_HOST_TO_SMC_UL(memory_level->MinVddcPhases);\r\nmemory_level->MinVddci = PP_HOST_TO_SMC_UL(memory_level->MinVddci * VOLTAGE_SCALE);\r\nmemory_level->MinMvdd = PP_HOST_TO_SMC_UL(memory_level->MinMvdd * VOLTAGE_SCALE);\r\nCONVERT_FROM_HOST_TO_SMC_UL(memory_level->MclkFrequency);\r\nCONVERT_FROM_HOST_TO_SMC_US(memory_level->ActivityLevel);\r\nCONVERT_FROM_HOST_TO_SMC_UL(memory_level->MpllFuncCntl);\r\nCONVERT_FROM_HOST_TO_SMC_UL(memory_level->MpllFuncCntl_1);\r\nCONVERT_FROM_HOST_TO_SMC_UL(memory_level->MpllFuncCntl_2);\r\nCONVERT_FROM_HOST_TO_SMC_UL(memory_level->MpllAdFuncCntl);\r\nCONVERT_FROM_HOST_TO_SMC_UL(memory_level->MpllDqFuncCntl);\r\nCONVERT_FROM_HOST_TO_SMC_UL(memory_level->MclkPwrmgtCntl);\r\nCONVERT_FROM_HOST_TO_SMC_UL(memory_level->DllCntl);\r\nCONVERT_FROM_HOST_TO_SMC_UL(memory_level->MpllSs1);\r\nCONVERT_FROM_HOST_TO_SMC_UL(memory_level->MpllSs2);\r\n}\r\nreturn result;\r\n}\r\nint iceland_populate_all_memory_levels(struct pp_hwmgr *hwmgr)\r\n{\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nstruct iceland_smumgr *smu_data = (struct iceland_smumgr *)(hwmgr->smumgr->backend);\r\nstruct smu7_dpm_table *dpm_table = &data->dpm_table;\r\nint result;\r\nuint32_t level_array_adress = smu_data->smu7_data.dpm_table_start + offsetof(SMU71_Discrete_DpmTable, MemoryLevel);\r\nuint32_t level_array_size = sizeof(SMU71_Discrete_MemoryLevel) * SMU71_MAX_LEVELS_MEMORY;\r\nSMU71_Discrete_MemoryLevel *levels = smu_data->smc_state_table.MemoryLevel;\r\nuint32_t i;\r\nmemset(levels, 0x00, level_array_size);\r\nfor (i = 0; i < dpm_table->mclk_table.count; i++) {\r\nPP_ASSERT_WITH_CODE((0 != dpm_table->mclk_table.dpm_levels[i].value),\r\n"can not populate memory level as memory clock is zero", return -EINVAL);\r\nresult = iceland_populate_single_memory_level(hwmgr, dpm_table->mclk_table.dpm_levels[i].value,\r\n&(smu_data->smc_state_table.MemoryLevel[i]));\r\nif (0 != result) {\r\nreturn result;\r\n}\r\n}\r\nsmu_data->smc_state_table.MemoryLevel[0].EnabledForActivity = 1;\r\nsmu_data->smc_state_table.MemoryLevel[0].ActivityLevel = 0x1F;\r\nCONVERT_FROM_HOST_TO_SMC_US(smu_data->smc_state_table.MemoryLevel[0].ActivityLevel);\r\nsmu_data->smc_state_table.MemoryDpmLevelCount = (uint8_t)dpm_table->mclk_table.count;\r\ndata->dpm_level_enable_mask.mclk_dpm_enable_mask = phm_get_dpm_level_enable_mask_value(&dpm_table->mclk_table);\r\nsmu_data->smc_state_table.MemoryLevel[dpm_table->mclk_table.count-1].DisplayWatermark = PPSMC_DISPLAY_WATERMARK_HIGH;\r\nresult = smu7_copy_bytes_to_smc(hwmgr->smumgr,\r\nlevel_array_adress, (uint8_t *)levels, (uint32_t)level_array_size,\r\nSMC_RAM_END);\r\nreturn result;\r\n}\r\nstatic int iceland_populate_mvdd_value(struct pp_hwmgr *hwmgr, uint32_t mclk,\r\nSMU71_Discrete_VoltageLevel *voltage)\r\n{\r\nconst struct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nuint32_t i = 0;\r\nif (SMU7_VOLTAGE_CONTROL_NONE != data->mvdd_control) {\r\nfor (i = 0; i < hwmgr->dyn_state.mvdd_dependency_on_mclk->count; i++) {\r\nif (mclk <= hwmgr->dyn_state.mvdd_dependency_on_mclk->entries[i].clk) {\r\nvoltage->Voltage = data->mvdd_voltage_table.entries[i].value;\r\nbreak;\r\n}\r\n}\r\nPP_ASSERT_WITH_CODE(i < hwmgr->dyn_state.mvdd_dependency_on_mclk->count,\r\n"MVDD Voltage is outside the supported range.", return -EINVAL);\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int iceland_populate_smc_acpi_level(struct pp_hwmgr *hwmgr,\r\nSMU71_Discrete_DpmTable *table)\r\n{\r\nint result = 0;\r\nconst struct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nstruct pp_atomctrl_clock_dividers_vi dividers;\r\nuint32_t vddc_phase_shed_control = 0;\r\nSMU71_Discrete_VoltageLevel voltage_level;\r\nuint32_t spll_func_cntl = data->clock_registers.vCG_SPLL_FUNC_CNTL;\r\nuint32_t spll_func_cntl_2 = data->clock_registers.vCG_SPLL_FUNC_CNTL_2;\r\nuint32_t dll_cntl = data->clock_registers.vDLL_CNTL;\r\nuint32_t mclk_pwrmgt_cntl = data->clock_registers.vMCLK_PWRMGT_CNTL;\r\ntable->ACPILevel.Flags &= ~PPSMC_SWSTATE_FLAG_DC;\r\nif (data->acpi_vddc)\r\ntable->ACPILevel.MinVddc = PP_HOST_TO_SMC_UL(data->acpi_vddc * VOLTAGE_SCALE);\r\nelse\r\ntable->ACPILevel.MinVddc = PP_HOST_TO_SMC_UL(data->min_vddc_in_pptable * VOLTAGE_SCALE);\r\ntable->ACPILevel.MinVddcPhases = vddc_phase_shed_control ? 0 : 1;\r\ntable->ACPILevel.SclkFrequency = atomctrl_get_reference_clock(hwmgr);\r\nresult = atomctrl_get_engine_pll_dividers_vi(hwmgr,\r\ntable->ACPILevel.SclkFrequency, &dividers);\r\nPP_ASSERT_WITH_CODE(result == 0,\r\n"Error retrieving Engine Clock dividers from VBIOS.", return result);\r\ntable->ACPILevel.SclkDid = (uint8_t)dividers.pll_post_divider;\r\ntable->ACPILevel.DisplayWatermark = PPSMC_DISPLAY_WATERMARK_LOW;\r\ntable->ACPILevel.DeepSleepDivId = 0;\r\nspll_func_cntl = PHM_SET_FIELD(spll_func_cntl,\r\nCG_SPLL_FUNC_CNTL, SPLL_PWRON, 0);\r\nspll_func_cntl = PHM_SET_FIELD(spll_func_cntl,\r\nCG_SPLL_FUNC_CNTL, SPLL_RESET, 1);\r\nspll_func_cntl_2 = PHM_SET_FIELD(spll_func_cntl_2,\r\nCG_SPLL_FUNC_CNTL_2, SCLK_MUX_SEL, 4);\r\ntable->ACPILevel.CgSpllFuncCntl = spll_func_cntl;\r\ntable->ACPILevel.CgSpllFuncCntl2 = spll_func_cntl_2;\r\ntable->ACPILevel.CgSpllFuncCntl3 = data->clock_registers.vCG_SPLL_FUNC_CNTL_3;\r\ntable->ACPILevel.CgSpllFuncCntl4 = data->clock_registers.vCG_SPLL_FUNC_CNTL_4;\r\ntable->ACPILevel.SpllSpreadSpectrum = data->clock_registers.vCG_SPLL_SPREAD_SPECTRUM;\r\ntable->ACPILevel.SpllSpreadSpectrum2 = data->clock_registers.vCG_SPLL_SPREAD_SPECTRUM_2;\r\ntable->ACPILevel.CcPwrDynRm = 0;\r\ntable->ACPILevel.CcPwrDynRm1 = 0;\r\nCONVERT_FROM_HOST_TO_SMC_UL(table->ACPILevel.Flags);\r\nCONVERT_FROM_HOST_TO_SMC_UL(table->ACPILevel.SclkFrequency);\r\nCONVERT_FROM_HOST_TO_SMC_UL(table->ACPILevel.CgSpllFuncCntl);\r\nCONVERT_FROM_HOST_TO_SMC_UL(table->ACPILevel.CgSpllFuncCntl2);\r\nCONVERT_FROM_HOST_TO_SMC_UL(table->ACPILevel.CgSpllFuncCntl3);\r\nCONVERT_FROM_HOST_TO_SMC_UL(table->ACPILevel.CgSpllFuncCntl4);\r\nCONVERT_FROM_HOST_TO_SMC_UL(table->ACPILevel.SpllSpreadSpectrum);\r\nCONVERT_FROM_HOST_TO_SMC_UL(table->ACPILevel.SpllSpreadSpectrum2);\r\nCONVERT_FROM_HOST_TO_SMC_UL(table->ACPILevel.CcPwrDynRm);\r\nCONVERT_FROM_HOST_TO_SMC_UL(table->ACPILevel.CcPwrDynRm1);\r\ntable->MemoryACPILevel.MinVddc = table->ACPILevel.MinVddc;\r\ntable->MemoryACPILevel.MinVddcPhases = table->ACPILevel.MinVddcPhases;\r\nif (SMU7_VOLTAGE_CONTROL_NONE == data->vddci_control)\r\ntable->MemoryACPILevel.MinVddci = table->MemoryACPILevel.MinVddc;\r\nelse {\r\nif (data->acpi_vddci != 0)\r\ntable->MemoryACPILevel.MinVddci = PP_HOST_TO_SMC_UL(data->acpi_vddci * VOLTAGE_SCALE);\r\nelse\r\ntable->MemoryACPILevel.MinVddci = PP_HOST_TO_SMC_UL(data->min_vddci_in_pptable * VOLTAGE_SCALE);\r\n}\r\nif (0 == iceland_populate_mvdd_value(hwmgr, 0, &voltage_level))\r\ntable->MemoryACPILevel.MinMvdd =\r\nPP_HOST_TO_SMC_UL(voltage_level.Voltage * VOLTAGE_SCALE);\r\nelse\r\ntable->MemoryACPILevel.MinMvdd = 0;\r\nmclk_pwrmgt_cntl = PHM_SET_FIELD(mclk_pwrmgt_cntl,\r\nMCLK_PWRMGT_CNTL, MRDCK0_RESET, 0x1);\r\nmclk_pwrmgt_cntl = PHM_SET_FIELD(mclk_pwrmgt_cntl,\r\nMCLK_PWRMGT_CNTL, MRDCK1_RESET, 0x1);\r\nmclk_pwrmgt_cntl = PHM_SET_FIELD(mclk_pwrmgt_cntl,\r\nMCLK_PWRMGT_CNTL, MRDCK0_PDNB, 0);\r\nmclk_pwrmgt_cntl = PHM_SET_FIELD(mclk_pwrmgt_cntl,\r\nMCLK_PWRMGT_CNTL, MRDCK1_PDNB, 0);\r\ndll_cntl = PHM_SET_FIELD(dll_cntl,\r\nDLL_CNTL, MRDCK0_BYPASS, 0);\r\ndll_cntl = PHM_SET_FIELD(dll_cntl,\r\nDLL_CNTL, MRDCK1_BYPASS, 0);\r\ntable->MemoryACPILevel.DllCntl =\r\nPP_HOST_TO_SMC_UL(dll_cntl);\r\ntable->MemoryACPILevel.MclkPwrmgtCntl =\r\nPP_HOST_TO_SMC_UL(mclk_pwrmgt_cntl);\r\ntable->MemoryACPILevel.MpllAdFuncCntl =\r\nPP_HOST_TO_SMC_UL(data->clock_registers.vMPLL_AD_FUNC_CNTL);\r\ntable->MemoryACPILevel.MpllDqFuncCntl =\r\nPP_HOST_TO_SMC_UL(data->clock_registers.vMPLL_DQ_FUNC_CNTL);\r\ntable->MemoryACPILevel.MpllFuncCntl =\r\nPP_HOST_TO_SMC_UL(data->clock_registers.vMPLL_FUNC_CNTL);\r\ntable->MemoryACPILevel.MpllFuncCntl_1 =\r\nPP_HOST_TO_SMC_UL(data->clock_registers.vMPLL_FUNC_CNTL_1);\r\ntable->MemoryACPILevel.MpllFuncCntl_2 =\r\nPP_HOST_TO_SMC_UL(data->clock_registers.vMPLL_FUNC_CNTL_2);\r\ntable->MemoryACPILevel.MpllSs1 =\r\nPP_HOST_TO_SMC_UL(data->clock_registers.vMPLL_SS1);\r\ntable->MemoryACPILevel.MpllSs2 =\r\nPP_HOST_TO_SMC_UL(data->clock_registers.vMPLL_SS2);\r\ntable->MemoryACPILevel.EnabledForThrottle = 0;\r\ntable->MemoryACPILevel.EnabledForActivity = 0;\r\ntable->MemoryACPILevel.UpHyst = 0;\r\ntable->MemoryACPILevel.DownHyst = 100;\r\ntable->MemoryACPILevel.VoltageDownHyst = 0;\r\ntable->MemoryACPILevel.ActivityLevel = PP_HOST_TO_SMC_US((uint16_t)data->mclk_activity_target);\r\ntable->MemoryACPILevel.StutterEnable = 0;\r\ntable->MemoryACPILevel.StrobeEnable = 0;\r\ntable->MemoryACPILevel.EdcReadEnable = 0;\r\ntable->MemoryACPILevel.EdcWriteEnable = 0;\r\ntable->MemoryACPILevel.RttEnable = 0;\r\nreturn result;\r\n}\r\nstatic int iceland_populate_smc_uvd_level(struct pp_hwmgr *hwmgr,\r\nSMU71_Discrete_DpmTable *table)\r\n{\r\nreturn 0;\r\n}\r\nstatic int iceland_populate_smc_vce_level(struct pp_hwmgr *hwmgr,\r\nSMU71_Discrete_DpmTable *table)\r\n{\r\nreturn 0;\r\n}\r\nstatic int iceland_populate_smc_acp_level(struct pp_hwmgr *hwmgr,\r\nSMU71_Discrete_DpmTable *table)\r\n{\r\nreturn 0;\r\n}\r\nstatic int iceland_populate_smc_samu_level(struct pp_hwmgr *hwmgr,\r\nSMU71_Discrete_DpmTable *table)\r\n{\r\nreturn 0;\r\n}\r\nstatic int iceland_populate_memory_timing_parameters(\r\nstruct pp_hwmgr *hwmgr,\r\nuint32_t engine_clock,\r\nuint32_t memory_clock,\r\nstruct SMU71_Discrete_MCArbDramTimingTableEntry *arb_regs\r\n)\r\n{\r\nuint32_t dramTiming;\r\nuint32_t dramTiming2;\r\nuint32_t burstTime;\r\nint result;\r\nresult = atomctrl_set_engine_dram_timings_rv770(hwmgr,\r\nengine_clock, memory_clock);\r\nPP_ASSERT_WITH_CODE(result == 0,\r\n"Error calling VBIOS to set DRAM_TIMING.", return result);\r\ndramTiming = cgs_read_register(hwmgr->device, mmMC_ARB_DRAM_TIMING);\r\ndramTiming2 = cgs_read_register(hwmgr->device, mmMC_ARB_DRAM_TIMING2);\r\nburstTime = PHM_READ_FIELD(hwmgr->device, MC_ARB_BURST_TIME, STATE0);\r\narb_regs->McArbDramTiming = PP_HOST_TO_SMC_UL(dramTiming);\r\narb_regs->McArbDramTiming2 = PP_HOST_TO_SMC_UL(dramTiming2);\r\narb_regs->McArbBurstTime = (uint8_t)burstTime;\r\nreturn 0;\r\n}\r\nstatic int iceland_program_memory_timing_parameters(struct pp_hwmgr *hwmgr)\r\n{\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nstruct iceland_smumgr *smu_data = (struct iceland_smumgr *)(hwmgr->smumgr->backend);\r\nint result = 0;\r\nSMU71_Discrete_MCArbDramTimingTable arb_regs;\r\nuint32_t i, j;\r\nmemset(&arb_regs, 0x00, sizeof(SMU71_Discrete_MCArbDramTimingTable));\r\nfor (i = 0; i < data->dpm_table.sclk_table.count; i++) {\r\nfor (j = 0; j < data->dpm_table.mclk_table.count; j++) {\r\nresult = iceland_populate_memory_timing_parameters\r\n(hwmgr, data->dpm_table.sclk_table.dpm_levels[i].value,\r\ndata->dpm_table.mclk_table.dpm_levels[j].value,\r\n&arb_regs.entries[i][j]);\r\nif (0 != result) {\r\nbreak;\r\n}\r\n}\r\n}\r\nif (0 == result) {\r\nresult = smu7_copy_bytes_to_smc(\r\nhwmgr->smumgr,\r\nsmu_data->smu7_data.arb_table_start,\r\n(uint8_t *)&arb_regs,\r\nsizeof(SMU71_Discrete_MCArbDramTimingTable),\r\nSMC_RAM_END\r\n);\r\n}\r\nreturn result;\r\n}\r\nstatic int iceland_populate_smc_boot_level(struct pp_hwmgr *hwmgr,\r\nSMU71_Discrete_DpmTable *table)\r\n{\r\nint result = 0;\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nstruct iceland_smumgr *smu_data = (struct iceland_smumgr *)(hwmgr->smumgr->backend);\r\ntable->GraphicsBootLevel = 0;\r\ntable->MemoryBootLevel = 0;\r\nresult = phm_find_boot_level(&(data->dpm_table.sclk_table),\r\ndata->vbios_boot_state.sclk_bootup_value,\r\n(uint32_t *)&(smu_data->smc_state_table.GraphicsBootLevel));\r\nif (0 != result) {\r\nsmu_data->smc_state_table.GraphicsBootLevel = 0;\r\npr_err("VBIOS did not find boot engine clock value \\r\nin dependency table. Using Graphics DPM level 0!");\r\nresult = 0;\r\n}\r\nresult = phm_find_boot_level(&(data->dpm_table.mclk_table),\r\ndata->vbios_boot_state.mclk_bootup_value,\r\n(uint32_t *)&(smu_data->smc_state_table.MemoryBootLevel));\r\nif (0 != result) {\r\nsmu_data->smc_state_table.MemoryBootLevel = 0;\r\npr_err("VBIOS did not find boot engine clock value \\r\nin dependency table. Using Memory DPM level 0!");\r\nresult = 0;\r\n}\r\ntable->BootVddc = data->vbios_boot_state.vddc_bootup_value;\r\nif (SMU7_VOLTAGE_CONTROL_NONE == data->vddci_control)\r\ntable->BootVddci = table->BootVddc;\r\nelse\r\ntable->BootVddci = data->vbios_boot_state.vddci_bootup_value;\r\ntable->BootMVdd = data->vbios_boot_state.mvdd_bootup_value;\r\nreturn result;\r\n}\r\nstatic int iceland_populate_mc_reg_address(struct pp_smumgr *smumgr,\r\nSMU71_Discrete_MCRegisters *mc_reg_table)\r\n{\r\nconst struct iceland_smumgr *smu_data = (struct iceland_smumgr *)smumgr->backend;\r\nuint32_t i, j;\r\nfor (i = 0, j = 0; j < smu_data->mc_reg_table.last; j++) {\r\nif (smu_data->mc_reg_table.validflag & 1<<j) {\r\nPP_ASSERT_WITH_CODE(i < SMU71_DISCRETE_MC_REGISTER_ARRAY_SIZE,\r\n"Index of mc_reg_table->address[] array out of boundary", return -EINVAL);\r\nmc_reg_table->address[i].s0 =\r\nPP_HOST_TO_SMC_US(smu_data->mc_reg_table.mc_reg_address[j].s0);\r\nmc_reg_table->address[i].s1 =\r\nPP_HOST_TO_SMC_US(smu_data->mc_reg_table.mc_reg_address[j].s1);\r\ni++;\r\n}\r\n}\r\nmc_reg_table->last = (uint8_t)i;\r\nreturn 0;\r\n}\r\nstatic void iceland_convert_mc_registers(\r\nconst struct iceland_mc_reg_entry *entry,\r\nSMU71_Discrete_MCRegisterSet *data,\r\nuint32_t num_entries, uint32_t valid_flag)\r\n{\r\nuint32_t i, j;\r\nfor (i = 0, j = 0; j < num_entries; j++) {\r\nif (valid_flag & 1<<j) {\r\ndata->value[i] = PP_HOST_TO_SMC_UL(entry->mc_data[j]);\r\ni++;\r\n}\r\n}\r\n}\r\nstatic int iceland_convert_mc_reg_table_entry_to_smc(\r\nstruct pp_smumgr *smumgr,\r\nconst uint32_t memory_clock,\r\nSMU71_Discrete_MCRegisterSet *mc_reg_table_data\r\n)\r\n{\r\nstruct iceland_smumgr *smu_data = (struct iceland_smumgr *)(smumgr->backend);\r\nuint32_t i = 0;\r\nfor (i = 0; i < smu_data->mc_reg_table.num_entries; i++) {\r\nif (memory_clock <=\r\nsmu_data->mc_reg_table.mc_reg_table_entry[i].mclk_max) {\r\nbreak;\r\n}\r\n}\r\nif ((i == smu_data->mc_reg_table.num_entries) && (i > 0))\r\n--i;\r\niceland_convert_mc_registers(&smu_data->mc_reg_table.mc_reg_table_entry[i],\r\nmc_reg_table_data, smu_data->mc_reg_table.last,\r\nsmu_data->mc_reg_table.validflag);\r\nreturn 0;\r\n}\r\nstatic int iceland_convert_mc_reg_table_to_smc(struct pp_hwmgr *hwmgr,\r\nSMU71_Discrete_MCRegisters *mc_regs)\r\n{\r\nint result = 0;\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nint res;\r\nuint32_t i;\r\nfor (i = 0; i < data->dpm_table.mclk_table.count; i++) {\r\nres = iceland_convert_mc_reg_table_entry_to_smc(\r\nhwmgr->smumgr,\r\ndata->dpm_table.mclk_table.dpm_levels[i].value,\r\n&mc_regs->data[i]\r\n);\r\nif (0 != res)\r\nresult = res;\r\n}\r\nreturn result;\r\n}\r\nstatic int iceland_update_and_upload_mc_reg_table(struct pp_hwmgr *hwmgr)\r\n{\r\nstruct pp_smumgr *smumgr = hwmgr->smumgr;\r\nstruct iceland_smumgr *smu_data = (struct iceland_smumgr *)(smumgr->backend);\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nuint32_t address;\r\nint32_t result;\r\nif (0 == (data->need_update_smu7_dpm_table & DPMTABLE_OD_UPDATE_MCLK))\r\nreturn 0;\r\nmemset(&smu_data->mc_regs, 0, sizeof(SMU71_Discrete_MCRegisters));\r\nresult = iceland_convert_mc_reg_table_to_smc(hwmgr, &(smu_data->mc_regs));\r\nif (result != 0)\r\nreturn result;\r\naddress = smu_data->smu7_data.mc_reg_table_start + (uint32_t)offsetof(SMU71_Discrete_MCRegisters, data[0]);\r\nreturn smu7_copy_bytes_to_smc(hwmgr->smumgr, address,\r\n(uint8_t *)&smu_data->mc_regs.data[0],\r\nsizeof(SMU71_Discrete_MCRegisterSet) * data->dpm_table.mclk_table.count,\r\nSMC_RAM_END);\r\n}\r\nstatic int iceland_populate_initial_mc_reg_table(struct pp_hwmgr *hwmgr)\r\n{\r\nint result;\r\nstruct pp_smumgr *smumgr = hwmgr->smumgr;\r\nstruct iceland_smumgr *smu_data = (struct iceland_smumgr *)(smumgr->backend);\r\nmemset(&smu_data->mc_regs, 0x00, sizeof(SMU71_Discrete_MCRegisters));\r\nresult = iceland_populate_mc_reg_address(smumgr, &(smu_data->mc_regs));\r\nPP_ASSERT_WITH_CODE(0 == result,\r\n"Failed to initialize MCRegTable for the MC register addresses!", return result;);\r\nresult = iceland_convert_mc_reg_table_to_smc(hwmgr, &smu_data->mc_regs);\r\nPP_ASSERT_WITH_CODE(0 == result,\r\n"Failed to initialize MCRegTable for driver state!", return result;);\r\nreturn smu7_copy_bytes_to_smc(smumgr, smu_data->smu7_data.mc_reg_table_start,\r\n(uint8_t *)&smu_data->mc_regs, sizeof(SMU71_Discrete_MCRegisters), SMC_RAM_END);\r\n}\r\nstatic int iceland_populate_smc_initial_state(struct pp_hwmgr *hwmgr)\r\n{\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nstruct iceland_smumgr *smu_data = (struct iceland_smumgr *)(hwmgr->smumgr->backend);\r\nuint8_t count, level;\r\ncount = (uint8_t)(hwmgr->dyn_state.vddc_dependency_on_sclk->count);\r\nfor (level = 0; level < count; level++) {\r\nif (hwmgr->dyn_state.vddc_dependency_on_sclk->entries[level].clk\r\n>= data->vbios_boot_state.sclk_bootup_value) {\r\nsmu_data->smc_state_table.GraphicsBootLevel = level;\r\nbreak;\r\n}\r\n}\r\ncount = (uint8_t)(hwmgr->dyn_state.vddc_dependency_on_mclk->count);\r\nfor (level = 0; level < count; level++) {\r\nif (hwmgr->dyn_state.vddc_dependency_on_mclk->entries[level].clk\r\n>= data->vbios_boot_state.mclk_bootup_value) {\r\nsmu_data->smc_state_table.MemoryBootLevel = level;\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int iceland_populate_bapm_parameters_in_dpm_table(struct pp_hwmgr *hwmgr)\r\n{\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nstruct iceland_smumgr *smu_data = (struct iceland_smumgr *)(hwmgr->smumgr->backend);\r\nconst struct iceland_pt_defaults *defaults = smu_data->power_tune_defaults;\r\nSMU71_Discrete_DpmTable *dpm_table = &(smu_data->smc_state_table);\r\nstruct phm_cac_tdp_table *cac_dtp_table = hwmgr->dyn_state.cac_dtp_table;\r\nstruct phm_ppm_table *ppm = hwmgr->dyn_state.ppm_parameter_table;\r\nconst uint16_t *def1, *def2;\r\nint i, j, k;\r\ndpm_table->DefaultTdp = PP_HOST_TO_SMC_US((uint16_t)(cac_dtp_table->usTDP * 256));\r\ndpm_table->TargetTdp = PP_HOST_TO_SMC_US((uint16_t)(cac_dtp_table->usConfigurableTDP * 256));\r\ndpm_table->DTETjOffset = 0;\r\ndpm_table->GpuTjMax = (uint8_t)(data->thermal_temp_setting.temperature_high / PP_TEMPERATURE_UNITS_PER_CENTIGRADES);\r\ndpm_table->GpuTjHyst = 8;\r\ndpm_table->DTEAmbientTempBase = defaults->dte_ambient_temp_base;\r\nif (NULL != ppm) {\r\ndpm_table->PPM_PkgPwrLimit = (uint16_t)ppm->dgpu_tdp * 256 / 1000;\r\ndpm_table->PPM_TemperatureLimit = (uint16_t)ppm->tj_max * 256;\r\n} else {\r\ndpm_table->PPM_PkgPwrLimit = 0;\r\ndpm_table->PPM_TemperatureLimit = 0;\r\n}\r\nCONVERT_FROM_HOST_TO_SMC_US(dpm_table->PPM_PkgPwrLimit);\r\nCONVERT_FROM_HOST_TO_SMC_US(dpm_table->PPM_TemperatureLimit);\r\ndpm_table->BAPM_TEMP_GRADIENT = PP_HOST_TO_SMC_UL(defaults->bamp_temp_gradient);\r\ndef1 = defaults->bapmti_r;\r\ndef2 = defaults->bapmti_rc;\r\nfor (i = 0; i < SMU71_DTE_ITERATIONS; i++) {\r\nfor (j = 0; j < SMU71_DTE_SOURCES; j++) {\r\nfor (k = 0; k < SMU71_DTE_SINKS; k++) {\r\ndpm_table->BAPMTI_R[i][j][k] = PP_HOST_TO_SMC_US(*def1);\r\ndpm_table->BAPMTI_RC[i][j][k] = PP_HOST_TO_SMC_US(*def2);\r\ndef1++;\r\ndef2++;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int iceland_populate_smc_svi2_config(struct pp_hwmgr *hwmgr,\r\nSMU71_Discrete_DpmTable *tab)\r\n{\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nif (SMU7_VOLTAGE_CONTROL_BY_SVID2 == data->voltage_control)\r\ntab->SVI2Enable |= VDDC_ON_SVI2;\r\nif (SMU7_VOLTAGE_CONTROL_BY_SVID2 == data->vddci_control)\r\ntab->SVI2Enable |= VDDCI_ON_SVI2;\r\nelse\r\ntab->MergedVddci = 1;\r\nif (SMU7_VOLTAGE_CONTROL_BY_SVID2 == data->mvdd_control)\r\ntab->SVI2Enable |= MVDD_ON_SVI2;\r\nPP_ASSERT_WITH_CODE(tab->SVI2Enable != (VDDC_ON_SVI2 | VDDCI_ON_SVI2 | MVDD_ON_SVI2) &&\r\n(tab->SVI2Enable & VDDC_ON_SVI2), "SVI2 domain configuration is incorrect!", return -EINVAL);\r\nreturn 0;\r\n}\r\nint iceland_init_smc_table(struct pp_hwmgr *hwmgr)\r\n{\r\nint result;\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nstruct iceland_smumgr *smu_data = (struct iceland_smumgr *)(hwmgr->smumgr->backend);\r\nSMU71_Discrete_DpmTable *table = &(smu_data->smc_state_table);\r\niceland_initialize_power_tune_defaults(hwmgr);\r\nmemset(&(smu_data->smc_state_table), 0x00, sizeof(smu_data->smc_state_table));\r\nif (SMU7_VOLTAGE_CONTROL_NONE != data->voltage_control) {\r\niceland_populate_smc_voltage_tables(hwmgr, table);\r\n}\r\nif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_AutomaticDCTransition))\r\ntable->SystemFlags |= PPSMC_SYSTEMFLAG_GPIO_DC;\r\nif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_StepVddc))\r\ntable->SystemFlags |= PPSMC_SYSTEMFLAG_STEPVDDC;\r\nif (data->is_memory_gddr5)\r\ntable->SystemFlags |= PPSMC_SYSTEMFLAG_GDDR5;\r\nif (data->ulv_supported) {\r\nresult = iceland_populate_ulv_state(hwmgr, &(smu_data->ulv_setting));\r\nPP_ASSERT_WITH_CODE(0 == result,\r\n"Failed to initialize ULV state!", return result;);\r\ncgs_write_ind_register(hwmgr->device, CGS_IND_REG__SMC,\r\nixCG_ULV_PARAMETER, 0x40035);\r\n}\r\nresult = iceland_populate_smc_link_level(hwmgr, table);\r\nPP_ASSERT_WITH_CODE(0 == result,\r\n"Failed to initialize Link Level!", return result;);\r\nresult = iceland_populate_all_graphic_levels(hwmgr);\r\nPP_ASSERT_WITH_CODE(0 == result,\r\n"Failed to initialize Graphics Level!", return result;);\r\nresult = iceland_populate_all_memory_levels(hwmgr);\r\nPP_ASSERT_WITH_CODE(0 == result,\r\n"Failed to initialize Memory Level!", return result;);\r\nresult = iceland_populate_smc_acpi_level(hwmgr, table);\r\nPP_ASSERT_WITH_CODE(0 == result,\r\n"Failed to initialize ACPI Level!", return result;);\r\nresult = iceland_populate_smc_vce_level(hwmgr, table);\r\nPP_ASSERT_WITH_CODE(0 == result,\r\n"Failed to initialize VCE Level!", return result;);\r\nresult = iceland_populate_smc_acp_level(hwmgr, table);\r\nPP_ASSERT_WITH_CODE(0 == result,\r\n"Failed to initialize ACP Level!", return result;);\r\nresult = iceland_populate_smc_samu_level(hwmgr, table);\r\nPP_ASSERT_WITH_CODE(0 == result,\r\n"Failed to initialize SAMU Level!", return result;);\r\nresult = iceland_program_memory_timing_parameters(hwmgr);\r\nPP_ASSERT_WITH_CODE(0 == result,\r\n"Failed to Write ARB settings for the initial state.", return result;);\r\nresult = iceland_populate_smc_uvd_level(hwmgr, table);\r\nPP_ASSERT_WITH_CODE(0 == result,\r\n"Failed to initialize UVD Level!", return result;);\r\ntable->GraphicsBootLevel = 0;\r\ntable->MemoryBootLevel = 0;\r\nresult = iceland_populate_smc_boot_level(hwmgr, table);\r\nPP_ASSERT_WITH_CODE(0 == result,\r\n"Failed to initialize Boot Level!", return result;);\r\nresult = iceland_populate_smc_initial_state(hwmgr);\r\nPP_ASSERT_WITH_CODE(0 == result, "Failed to initialize Boot State!", return result);\r\nresult = iceland_populate_bapm_parameters_in_dpm_table(hwmgr);\r\nPP_ASSERT_WITH_CODE(0 == result, "Failed to populate BAPM Parameters!", return result);\r\ntable->GraphicsVoltageChangeEnable = 1;\r\ntable->GraphicsThermThrottleEnable = 1;\r\ntable->GraphicsInterval = 1;\r\ntable->VoltageInterval = 1;\r\ntable->ThermalInterval = 1;\r\ntable->TemperatureLimitHigh =\r\n(data->thermal_temp_setting.temperature_high *\r\nSMU7_Q88_FORMAT_CONVERSION_UNIT) / PP_TEMPERATURE_UNITS_PER_CENTIGRADES;\r\ntable->TemperatureLimitLow =\r\n(data->thermal_temp_setting.temperature_low *\r\nSMU7_Q88_FORMAT_CONVERSION_UNIT) / PP_TEMPERATURE_UNITS_PER_CENTIGRADES;\r\ntable->MemoryVoltageChangeEnable = 1;\r\ntable->MemoryInterval = 1;\r\ntable->VoltageResponseTime = 0;\r\ntable->PhaseResponseTime = 0;\r\ntable->MemoryThermThrottleEnable = 1;\r\ntable->PCIeBootLinkLevel = 0;\r\ntable->PCIeGenInterval = 1;\r\nresult = iceland_populate_smc_svi2_config(hwmgr, table);\r\nPP_ASSERT_WITH_CODE(0 == result,\r\n"Failed to populate SVI2 setting!", return result);\r\ntable->ThermGpio = 17;\r\ntable->SclkStepSize = 0x4000;\r\nCONVERT_FROM_HOST_TO_SMC_UL(table->SystemFlags);\r\nCONVERT_FROM_HOST_TO_SMC_UL(table->SmioMaskVddcVid);\r\nCONVERT_FROM_HOST_TO_SMC_UL(table->SmioMaskVddcPhase);\r\nCONVERT_FROM_HOST_TO_SMC_UL(table->SmioMaskVddciVid);\r\nCONVERT_FROM_HOST_TO_SMC_UL(table->SmioMaskMvddVid);\r\nCONVERT_FROM_HOST_TO_SMC_UL(table->SclkStepSize);\r\nCONVERT_FROM_HOST_TO_SMC_US(table->TemperatureLimitHigh);\r\nCONVERT_FROM_HOST_TO_SMC_US(table->TemperatureLimitLow);\r\nCONVERT_FROM_HOST_TO_SMC_US(table->VoltageResponseTime);\r\nCONVERT_FROM_HOST_TO_SMC_US(table->PhaseResponseTime);\r\ntable->BootVddc = PP_HOST_TO_SMC_US(table->BootVddc * VOLTAGE_SCALE);\r\ntable->BootVddci = PP_HOST_TO_SMC_US(table->BootVddci * VOLTAGE_SCALE);\r\ntable->BootMVdd = PP_HOST_TO_SMC_US(table->BootMVdd * VOLTAGE_SCALE);\r\nresult = smu7_copy_bytes_to_smc(hwmgr->smumgr, smu_data->smu7_data.dpm_table_start +\r\noffsetof(SMU71_Discrete_DpmTable, SystemFlags),\r\n(uint8_t *)&(table->SystemFlags),\r\nsizeof(SMU71_Discrete_DpmTable)-3 * sizeof(SMU71_PIDController),\r\nSMC_RAM_END);\r\nPP_ASSERT_WITH_CODE(0 == result,\r\n"Failed to upload dpm data to SMC memory!", return result;);\r\nresult = smu7_copy_bytes_to_smc(hwmgr->smumgr,\r\nsmu_data->smu7_data.ulv_setting_starts,\r\n(uint8_t *)&(smu_data->ulv_setting),\r\nsizeof(SMU71_Discrete_Ulv),\r\nSMC_RAM_END);\r\nresult = iceland_populate_initial_mc_reg_table(hwmgr);\r\nPP_ASSERT_WITH_CODE((0 == result),\r\n"Failed to populate initialize MC Reg table!", return result);\r\nresult = iceland_populate_pm_fuses(hwmgr);\r\nPP_ASSERT_WITH_CODE(0 == result,\r\n"Failed to populate PM fuses to SMC memory!", return result);\r\nreturn 0;\r\n}\r\nint iceland_thermal_setup_fan_table(struct pp_hwmgr *hwmgr)\r\n{\r\nstruct smu7_smumgr *smu7_data = (struct smu7_smumgr *)(hwmgr->smumgr->backend);\r\nSMU71_Discrete_FanTable fan_table = { FDO_MODE_HARDWARE };\r\nuint32_t duty100;\r\nuint32_t t_diff1, t_diff2, pwm_diff1, pwm_diff2;\r\nuint16_t fdo_min, slope1, slope2;\r\nuint32_t reference_clock;\r\nint res;\r\nuint64_t tmp64;\r\nif (!phm_cap_enabled(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_MicrocodeFanControl))\r\nreturn 0;\r\nif (hwmgr->thermal_controller.fanInfo.bNoFan) {\r\nphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_MicrocodeFanControl);\r\nreturn 0;\r\n}\r\nif (0 == smu7_data->fan_table_start) {\r\nphm_cap_unset(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_MicrocodeFanControl);\r\nreturn 0;\r\n}\r\nduty100 = PHM_READ_VFPF_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC, CG_FDO_CTRL1, FMAX_DUTY100);\r\nif (0 == duty100) {\r\nphm_cap_unset(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_MicrocodeFanControl);\r\nreturn 0;\r\n}\r\ntmp64 = hwmgr->thermal_controller.advanceFanControlParameters.usPWMMin * duty100;\r\ndo_div(tmp64, 10000);\r\nfdo_min = (uint16_t)tmp64;\r\nt_diff1 = hwmgr->thermal_controller.advanceFanControlParameters.usTMed - hwmgr->thermal_controller.advanceFanControlParameters.usTMin;\r\nt_diff2 = hwmgr->thermal_controller.advanceFanControlParameters.usTHigh - hwmgr->thermal_controller.advanceFanControlParameters.usTMed;\r\npwm_diff1 = hwmgr->thermal_controller.advanceFanControlParameters.usPWMMed - hwmgr->thermal_controller.advanceFanControlParameters.usPWMMin;\r\npwm_diff2 = hwmgr->thermal_controller.advanceFanControlParameters.usPWMHigh - hwmgr->thermal_controller.advanceFanControlParameters.usPWMMed;\r\nslope1 = (uint16_t)((50 + ((16 * duty100 * pwm_diff1) / t_diff1)) / 100);\r\nslope2 = (uint16_t)((50 + ((16 * duty100 * pwm_diff2) / t_diff2)) / 100);\r\nfan_table.TempMin = cpu_to_be16((50 + hwmgr->thermal_controller.advanceFanControlParameters.usTMin) / 100);\r\nfan_table.TempMed = cpu_to_be16((50 + hwmgr->thermal_controller.advanceFanControlParameters.usTMed) / 100);\r\nfan_table.TempMax = cpu_to_be16((50 + hwmgr->thermal_controller.advanceFanControlParameters.usTMax) / 100);\r\nfan_table.Slope1 = cpu_to_be16(slope1);\r\nfan_table.Slope2 = cpu_to_be16(slope2);\r\nfan_table.FdoMin = cpu_to_be16(fdo_min);\r\nfan_table.HystDown = cpu_to_be16(hwmgr->thermal_controller.advanceFanControlParameters.ucTHyst);\r\nfan_table.HystUp = cpu_to_be16(1);\r\nfan_table.HystSlope = cpu_to_be16(1);\r\nfan_table.TempRespLim = cpu_to_be16(5);\r\nreference_clock = smu7_get_xclk(hwmgr);\r\nfan_table.RefreshPeriod = cpu_to_be32((hwmgr->thermal_controller.advanceFanControlParameters.ulCycleDelay * reference_clock) / 1600);\r\nfan_table.FdoMax = cpu_to_be16((uint16_t)duty100);\r\nfan_table.TempSrc = (uint8_t)PHM_READ_VFPF_INDIRECT_FIELD(hwmgr->device, CGS_IND_REG__SMC, CG_MULT_THERMAL_CTRL, TEMP_SEL);\r\nres = smu7_copy_bytes_to_smc(hwmgr->smumgr, smu7_data->fan_table_start, (uint8_t *)&fan_table, (uint32_t)sizeof(fan_table), SMC_RAM_END);\r\nreturn 0;\r\n}\r\nstatic int iceland_program_mem_timing_parameters(struct pp_hwmgr *hwmgr)\r\n{\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nif (data->need_update_smu7_dpm_table &\r\n(DPMTABLE_OD_UPDATE_SCLK + DPMTABLE_OD_UPDATE_MCLK))\r\nreturn iceland_program_memory_timing_parameters(hwmgr);\r\nreturn 0;\r\n}\r\nint iceland_update_sclk_threshold(struct pp_hwmgr *hwmgr)\r\n{\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nstruct iceland_smumgr *smu_data = (struct iceland_smumgr *)(hwmgr->smumgr->backend);\r\nint result = 0;\r\nuint32_t low_sclk_interrupt_threshold = 0;\r\nif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_SclkThrottleLowNotification)\r\n&& (hwmgr->gfx_arbiter.sclk_threshold !=\r\ndata->low_sclk_interrupt_threshold)) {\r\ndata->low_sclk_interrupt_threshold =\r\nhwmgr->gfx_arbiter.sclk_threshold;\r\nlow_sclk_interrupt_threshold =\r\ndata->low_sclk_interrupt_threshold;\r\nCONVERT_FROM_HOST_TO_SMC_UL(low_sclk_interrupt_threshold);\r\nresult = smu7_copy_bytes_to_smc(\r\nhwmgr->smumgr,\r\nsmu_data->smu7_data.dpm_table_start +\r\noffsetof(SMU71_Discrete_DpmTable,\r\nLowSclkInterruptThreshold),\r\n(uint8_t *)&low_sclk_interrupt_threshold,\r\nsizeof(uint32_t),\r\nSMC_RAM_END);\r\n}\r\nresult = iceland_update_and_upload_mc_reg_table(hwmgr);\r\nPP_ASSERT_WITH_CODE((0 == result), "Failed to upload MC reg table!", return result);\r\nresult = iceland_program_mem_timing_parameters(hwmgr);\r\nPP_ASSERT_WITH_CODE((result == 0),\r\n"Failed to program memory timing parameters!",\r\n);\r\nreturn result;\r\n}\r\nuint32_t iceland_get_offsetof(uint32_t type, uint32_t member)\r\n{\r\nswitch (type) {\r\ncase SMU_SoftRegisters:\r\nswitch (member) {\r\ncase HandshakeDisables:\r\nreturn offsetof(SMU71_SoftRegisters, HandshakeDisables);\r\ncase VoltageChangeTimeout:\r\nreturn offsetof(SMU71_SoftRegisters, VoltageChangeTimeout);\r\ncase AverageGraphicsActivity:\r\nreturn offsetof(SMU71_SoftRegisters, AverageGraphicsActivity);\r\ncase PreVBlankGap:\r\nreturn offsetof(SMU71_SoftRegisters, PreVBlankGap);\r\ncase VBlankTimeout:\r\nreturn offsetof(SMU71_SoftRegisters, VBlankTimeout);\r\ncase UcodeLoadStatus:\r\nreturn offsetof(SMU71_SoftRegisters, UcodeLoadStatus);\r\n}\r\ncase SMU_Discrete_DpmTable:\r\nswitch (member) {\r\ncase LowSclkInterruptThreshold:\r\nreturn offsetof(SMU71_Discrete_DpmTable, LowSclkInterruptThreshold);\r\n}\r\n}\r\npr_warn("can't get the offset of type %x member %x\n", type, member);\r\nreturn 0;\r\n}\r\nuint32_t iceland_get_mac_definition(uint32_t value)\r\n{\r\nswitch (value) {\r\ncase SMU_MAX_LEVELS_GRAPHICS:\r\nreturn SMU71_MAX_LEVELS_GRAPHICS;\r\ncase SMU_MAX_LEVELS_MEMORY:\r\nreturn SMU71_MAX_LEVELS_MEMORY;\r\ncase SMU_MAX_LEVELS_LINK:\r\nreturn SMU71_MAX_LEVELS_LINK;\r\ncase SMU_MAX_ENTRIES_SMIO:\r\nreturn SMU71_MAX_ENTRIES_SMIO;\r\ncase SMU_MAX_LEVELS_VDDC:\r\nreturn SMU71_MAX_LEVELS_VDDC;\r\ncase SMU_MAX_LEVELS_VDDCI:\r\nreturn SMU71_MAX_LEVELS_VDDCI;\r\ncase SMU_MAX_LEVELS_MVDD:\r\nreturn SMU71_MAX_LEVELS_MVDD;\r\n}\r\npr_warn("can't get the mac of %x\n", value);\r\nreturn 0;\r\n}\r\nint iceland_process_firmware_header(struct pp_hwmgr *hwmgr)\r\n{\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nstruct smu7_smumgr *smu7_data = (struct smu7_smumgr *)(hwmgr->smumgr->backend);\r\nuint32_t tmp;\r\nint result;\r\nbool error = false;\r\nresult = smu7_read_smc_sram_dword(hwmgr->smumgr,\r\nSMU71_FIRMWARE_HEADER_LOCATION +\r\noffsetof(SMU71_Firmware_Header, DpmTable),\r\n&tmp, SMC_RAM_END);\r\nif (0 == result) {\r\nsmu7_data->dpm_table_start = tmp;\r\n}\r\nerror |= (0 != result);\r\nresult = smu7_read_smc_sram_dword(hwmgr->smumgr,\r\nSMU71_FIRMWARE_HEADER_LOCATION +\r\noffsetof(SMU71_Firmware_Header, SoftRegisters),\r\n&tmp, SMC_RAM_END);\r\nif (0 == result) {\r\ndata->soft_regs_start = tmp;\r\nsmu7_data->soft_regs_start = tmp;\r\n}\r\nerror |= (0 != result);\r\nresult = smu7_read_smc_sram_dword(hwmgr->smumgr,\r\nSMU71_FIRMWARE_HEADER_LOCATION +\r\noffsetof(SMU71_Firmware_Header, mcRegisterTable),\r\n&tmp, SMC_RAM_END);\r\nif (0 == result) {\r\nsmu7_data->mc_reg_table_start = tmp;\r\n}\r\nresult = smu7_read_smc_sram_dword(hwmgr->smumgr,\r\nSMU71_FIRMWARE_HEADER_LOCATION +\r\noffsetof(SMU71_Firmware_Header, FanTable),\r\n&tmp, SMC_RAM_END);\r\nif (0 == result) {\r\nsmu7_data->fan_table_start = tmp;\r\n}\r\nerror |= (0 != result);\r\nresult = smu7_read_smc_sram_dword(hwmgr->smumgr,\r\nSMU71_FIRMWARE_HEADER_LOCATION +\r\noffsetof(SMU71_Firmware_Header, mcArbDramTimingTable),\r\n&tmp, SMC_RAM_END);\r\nif (0 == result) {\r\nsmu7_data->arb_table_start = tmp;\r\n}\r\nerror |= (0 != result);\r\nresult = smu7_read_smc_sram_dword(hwmgr->smumgr,\r\nSMU71_FIRMWARE_HEADER_LOCATION +\r\noffsetof(SMU71_Firmware_Header, Version),\r\n&tmp, SMC_RAM_END);\r\nif (0 == result) {\r\nhwmgr->microcode_version_info.SMC = tmp;\r\n}\r\nerror |= (0 != result);\r\nresult = smu7_read_smc_sram_dword(hwmgr->smumgr,\r\nSMU71_FIRMWARE_HEADER_LOCATION +\r\noffsetof(SMU71_Firmware_Header, UlvSettings),\r\n&tmp, SMC_RAM_END);\r\nif (0 == result) {\r\nsmu7_data->ulv_setting_starts = tmp;\r\n}\r\nerror |= (0 != result);\r\nreturn error ? 1 : 0;\r\n}\r\nstatic uint8_t iceland_get_memory_modile_index(struct pp_hwmgr *hwmgr)\r\n{\r\nreturn (uint8_t) (0xFF & (cgs_read_register(hwmgr->device, mmBIOS_SCRATCH_4) >> 16));\r\n}\r\nstatic bool iceland_check_s0_mc_reg_index(uint16_t in_reg, uint16_t *out_reg)\r\n{\r\nbool result = true;\r\nswitch (in_reg) {\r\ncase mmMC_SEQ_RAS_TIMING:\r\n*out_reg = mmMC_SEQ_RAS_TIMING_LP;\r\nbreak;\r\ncase mmMC_SEQ_DLL_STBY:\r\n*out_reg = mmMC_SEQ_DLL_STBY_LP;\r\nbreak;\r\ncase mmMC_SEQ_G5PDX_CMD0:\r\n*out_reg = mmMC_SEQ_G5PDX_CMD0_LP;\r\nbreak;\r\ncase mmMC_SEQ_G5PDX_CMD1:\r\n*out_reg = mmMC_SEQ_G5PDX_CMD1_LP;\r\nbreak;\r\ncase mmMC_SEQ_G5PDX_CTRL:\r\n*out_reg = mmMC_SEQ_G5PDX_CTRL_LP;\r\nbreak;\r\ncase mmMC_SEQ_CAS_TIMING:\r\n*out_reg = mmMC_SEQ_CAS_TIMING_LP;\r\nbreak;\r\ncase mmMC_SEQ_MISC_TIMING:\r\n*out_reg = mmMC_SEQ_MISC_TIMING_LP;\r\nbreak;\r\ncase mmMC_SEQ_MISC_TIMING2:\r\n*out_reg = mmMC_SEQ_MISC_TIMING2_LP;\r\nbreak;\r\ncase mmMC_SEQ_PMG_DVS_CMD:\r\n*out_reg = mmMC_SEQ_PMG_DVS_CMD_LP;\r\nbreak;\r\ncase mmMC_SEQ_PMG_DVS_CTL:\r\n*out_reg = mmMC_SEQ_PMG_DVS_CTL_LP;\r\nbreak;\r\ncase mmMC_SEQ_RD_CTL_D0:\r\n*out_reg = mmMC_SEQ_RD_CTL_D0_LP;\r\nbreak;\r\ncase mmMC_SEQ_RD_CTL_D1:\r\n*out_reg = mmMC_SEQ_RD_CTL_D1_LP;\r\nbreak;\r\ncase mmMC_SEQ_WR_CTL_D0:\r\n*out_reg = mmMC_SEQ_WR_CTL_D0_LP;\r\nbreak;\r\ncase mmMC_SEQ_WR_CTL_D1:\r\n*out_reg = mmMC_SEQ_WR_CTL_D1_LP;\r\nbreak;\r\ncase mmMC_PMG_CMD_EMRS:\r\n*out_reg = mmMC_SEQ_PMG_CMD_EMRS_LP;\r\nbreak;\r\ncase mmMC_PMG_CMD_MRS:\r\n*out_reg = mmMC_SEQ_PMG_CMD_MRS_LP;\r\nbreak;\r\ncase mmMC_PMG_CMD_MRS1:\r\n*out_reg = mmMC_SEQ_PMG_CMD_MRS1_LP;\r\nbreak;\r\ncase mmMC_SEQ_PMG_TIMING:\r\n*out_reg = mmMC_SEQ_PMG_TIMING_LP;\r\nbreak;\r\ncase mmMC_PMG_CMD_MRS2:\r\n*out_reg = mmMC_SEQ_PMG_CMD_MRS2_LP;\r\nbreak;\r\ncase mmMC_SEQ_WR_CTL_2:\r\n*out_reg = mmMC_SEQ_WR_CTL_2_LP;\r\nbreak;\r\ndefault:\r\nresult = false;\r\nbreak;\r\n}\r\nreturn result;\r\n}\r\nstatic int iceland_set_s0_mc_reg_index(struct iceland_mc_reg_table *table)\r\n{\r\nuint32_t i;\r\nuint16_t address;\r\nfor (i = 0; i < table->last; i++) {\r\ntable->mc_reg_address[i].s0 =\r\niceland_check_s0_mc_reg_index(table->mc_reg_address[i].s1, &address)\r\n? address : table->mc_reg_address[i].s1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int iceland_copy_vbios_smc_reg_table(const pp_atomctrl_mc_reg_table *table,\r\nstruct iceland_mc_reg_table *ni_table)\r\n{\r\nuint8_t i, j;\r\nPP_ASSERT_WITH_CODE((table->last <= SMU71_DISCRETE_MC_REGISTER_ARRAY_SIZE),\r\n"Invalid VramInfo table.", return -EINVAL);\r\nPP_ASSERT_WITH_CODE((table->num_entries <= MAX_AC_TIMING_ENTRIES),\r\n"Invalid VramInfo table.", return -EINVAL);\r\nfor (i = 0; i < table->last; i++) {\r\nni_table->mc_reg_address[i].s1 = table->mc_reg_address[i].s1;\r\n}\r\nni_table->last = table->last;\r\nfor (i = 0; i < table->num_entries; i++) {\r\nni_table->mc_reg_table_entry[i].mclk_max =\r\ntable->mc_reg_table_entry[i].mclk_max;\r\nfor (j = 0; j < table->last; j++) {\r\nni_table->mc_reg_table_entry[i].mc_data[j] =\r\ntable->mc_reg_table_entry[i].mc_data[j];\r\n}\r\n}\r\nni_table->num_entries = table->num_entries;\r\nreturn 0;\r\n}\r\nstatic int iceland_set_mc_special_registers(struct pp_hwmgr *hwmgr,\r\nstruct iceland_mc_reg_table *table)\r\n{\r\nuint8_t i, j, k;\r\nuint32_t temp_reg;\r\nstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\r\nfor (i = 0, j = table->last; i < table->last; i++) {\r\nPP_ASSERT_WITH_CODE((j < SMU71_DISCRETE_MC_REGISTER_ARRAY_SIZE),\r\n"Invalid VramInfo table.", return -EINVAL);\r\nswitch (table->mc_reg_address[i].s1) {\r\ncase mmMC_SEQ_MISC1:\r\ntemp_reg = cgs_read_register(hwmgr->device, mmMC_PMG_CMD_EMRS);\r\ntable->mc_reg_address[j].s1 = mmMC_PMG_CMD_EMRS;\r\ntable->mc_reg_address[j].s0 = mmMC_SEQ_PMG_CMD_EMRS_LP;\r\nfor (k = 0; k < table->num_entries; k++) {\r\ntable->mc_reg_table_entry[k].mc_data[j] =\r\n((temp_reg & 0xffff0000)) |\r\n((table->mc_reg_table_entry[k].mc_data[i] & 0xffff0000) >> 16);\r\n}\r\nj++;\r\nPP_ASSERT_WITH_CODE((j < SMU71_DISCRETE_MC_REGISTER_ARRAY_SIZE),\r\n"Invalid VramInfo table.", return -EINVAL);\r\ntemp_reg = cgs_read_register(hwmgr->device, mmMC_PMG_CMD_MRS);\r\ntable->mc_reg_address[j].s1 = mmMC_PMG_CMD_MRS;\r\ntable->mc_reg_address[j].s0 = mmMC_SEQ_PMG_CMD_MRS_LP;\r\nfor (k = 0; k < table->num_entries; k++) {\r\ntable->mc_reg_table_entry[k].mc_data[j] =\r\n(temp_reg & 0xffff0000) |\r\n(table->mc_reg_table_entry[k].mc_data[i] & 0x0000ffff);\r\nif (!data->is_memory_gddr5) {\r\ntable->mc_reg_table_entry[k].mc_data[j] |= 0x100;\r\n}\r\n}\r\nj++;\r\nPP_ASSERT_WITH_CODE((j <= SMU71_DISCRETE_MC_REGISTER_ARRAY_SIZE),\r\n"Invalid VramInfo table.", return -EINVAL);\r\nif (!data->is_memory_gddr5 && j < SMU71_DISCRETE_MC_REGISTER_ARRAY_SIZE) {\r\ntable->mc_reg_address[j].s1 = mmMC_PMG_AUTO_CMD;\r\ntable->mc_reg_address[j].s0 = mmMC_PMG_AUTO_CMD;\r\nfor (k = 0; k < table->num_entries; k++) {\r\ntable->mc_reg_table_entry[k].mc_data[j] =\r\n(table->mc_reg_table_entry[k].mc_data[i] & 0xffff0000) >> 16;\r\n}\r\nj++;\r\nPP_ASSERT_WITH_CODE((j <= SMU71_DISCRETE_MC_REGISTER_ARRAY_SIZE),\r\n"Invalid VramInfo table.", return -EINVAL);\r\n}\r\nbreak;\r\ncase mmMC_SEQ_RESERVE_M:\r\ntemp_reg = cgs_read_register(hwmgr->device, mmMC_PMG_CMD_MRS1);\r\ntable->mc_reg_address[j].s1 = mmMC_PMG_CMD_MRS1;\r\ntable->mc_reg_address[j].s0 = mmMC_SEQ_PMG_CMD_MRS1_LP;\r\nfor (k = 0; k < table->num_entries; k++) {\r\ntable->mc_reg_table_entry[k].mc_data[j] =\r\n(temp_reg & 0xffff0000) |\r\n(table->mc_reg_table_entry[k].mc_data[i] & 0x0000ffff);\r\n}\r\nj++;\r\nPP_ASSERT_WITH_CODE((j <= SMU71_DISCRETE_MC_REGISTER_ARRAY_SIZE),\r\n"Invalid VramInfo table.", return -EINVAL);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\ntable->last = j;\r\nreturn 0;\r\n}\r\nstatic int iceland_set_valid_flag(struct iceland_mc_reg_table *table)\r\n{\r\nuint8_t i, j;\r\nfor (i = 0; i < table->last; i++) {\r\nfor (j = 1; j < table->num_entries; j++) {\r\nif (table->mc_reg_table_entry[j-1].mc_data[i] !=\r\ntable->mc_reg_table_entry[j].mc_data[i]) {\r\ntable->validflag |= (1<<i);\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint iceland_initialize_mc_reg_table(struct pp_hwmgr *hwmgr)\r\n{\r\nint result;\r\nstruct iceland_smumgr *smu_data = (struct iceland_smumgr *)(hwmgr->smumgr->backend);\r\npp_atomctrl_mc_reg_table *table;\r\nstruct iceland_mc_reg_table *ni_table = &smu_data->mc_reg_table;\r\nuint8_t module_index = iceland_get_memory_modile_index(hwmgr);\r\ntable = kzalloc(sizeof(pp_atomctrl_mc_reg_table), GFP_KERNEL);\r\nif (NULL == table)\r\nreturn -ENOMEM;\r\ncgs_write_register(hwmgr->device, mmMC_SEQ_RAS_TIMING_LP, cgs_read_register(hwmgr->device, mmMC_SEQ_RAS_TIMING));\r\ncgs_write_register(hwmgr->device, mmMC_SEQ_CAS_TIMING_LP, cgs_read_register(hwmgr->device, mmMC_SEQ_CAS_TIMING));\r\ncgs_write_register(hwmgr->device, mmMC_SEQ_DLL_STBY_LP, cgs_read_register(hwmgr->device, mmMC_SEQ_DLL_STBY));\r\ncgs_write_register(hwmgr->device, mmMC_SEQ_G5PDX_CMD0_LP, cgs_read_register(hwmgr->device, mmMC_SEQ_G5PDX_CMD0));\r\ncgs_write_register(hwmgr->device, mmMC_SEQ_G5PDX_CMD1_LP, cgs_read_register(hwmgr->device, mmMC_SEQ_G5PDX_CMD1));\r\ncgs_write_register(hwmgr->device, mmMC_SEQ_G5PDX_CTRL_LP, cgs_read_register(hwmgr->device, mmMC_SEQ_G5PDX_CTRL));\r\ncgs_write_register(hwmgr->device, mmMC_SEQ_PMG_DVS_CMD_LP, cgs_read_register(hwmgr->device, mmMC_SEQ_PMG_DVS_CMD));\r\ncgs_write_register(hwmgr->device, mmMC_SEQ_PMG_DVS_CTL_LP, cgs_read_register(hwmgr->device, mmMC_SEQ_PMG_DVS_CTL));\r\ncgs_write_register(hwmgr->device, mmMC_SEQ_MISC_TIMING_LP, cgs_read_register(hwmgr->device, mmMC_SEQ_MISC_TIMING));\r\ncgs_write_register(hwmgr->device, mmMC_SEQ_MISC_TIMING2_LP, cgs_read_register(hwmgr->device, mmMC_SEQ_MISC_TIMING2));\r\ncgs_write_register(hwmgr->device, mmMC_SEQ_PMG_CMD_EMRS_LP, cgs_read_register(hwmgr->device, mmMC_PMG_CMD_EMRS));\r\ncgs_write_register(hwmgr->device, mmMC_SEQ_PMG_CMD_MRS_LP, cgs_read_register(hwmgr->device, mmMC_PMG_CMD_MRS));\r\ncgs_write_register(hwmgr->device, mmMC_SEQ_PMG_CMD_MRS1_LP, cgs_read_register(hwmgr->device, mmMC_PMG_CMD_MRS1));\r\ncgs_write_register(hwmgr->device, mmMC_SEQ_WR_CTL_D0_LP, cgs_read_register(hwmgr->device, mmMC_SEQ_WR_CTL_D0));\r\ncgs_write_register(hwmgr->device, mmMC_SEQ_WR_CTL_D1_LP, cgs_read_register(hwmgr->device, mmMC_SEQ_WR_CTL_D1));\r\ncgs_write_register(hwmgr->device, mmMC_SEQ_RD_CTL_D0_LP, cgs_read_register(hwmgr->device, mmMC_SEQ_RD_CTL_D0));\r\ncgs_write_register(hwmgr->device, mmMC_SEQ_RD_CTL_D1_LP, cgs_read_register(hwmgr->device, mmMC_SEQ_RD_CTL_D1));\r\ncgs_write_register(hwmgr->device, mmMC_SEQ_PMG_TIMING_LP, cgs_read_register(hwmgr->device, mmMC_SEQ_PMG_TIMING));\r\ncgs_write_register(hwmgr->device, mmMC_SEQ_PMG_CMD_MRS2_LP, cgs_read_register(hwmgr->device, mmMC_PMG_CMD_MRS2));\r\ncgs_write_register(hwmgr->device, mmMC_SEQ_WR_CTL_2_LP, cgs_read_register(hwmgr->device, mmMC_SEQ_WR_CTL_2));\r\nmemset(table, 0x00, sizeof(pp_atomctrl_mc_reg_table));\r\nresult = atomctrl_initialize_mc_reg_table(hwmgr, module_index, table);\r\nif (0 == result)\r\nresult = iceland_copy_vbios_smc_reg_table(table, ni_table);\r\nif (0 == result) {\r\niceland_set_s0_mc_reg_index(ni_table);\r\nresult = iceland_set_mc_special_registers(hwmgr, ni_table);\r\n}\r\nif (0 == result)\r\niceland_set_valid_flag(ni_table);\r\nkfree(table);\r\nreturn result;\r\n}\r\nbool iceland_is_dpm_running(struct pp_hwmgr *hwmgr)\r\n{\r\nreturn (1 == PHM_READ_INDIRECT_FIELD(hwmgr->device,\r\nCGS_IND_REG__SMC, FEATURE_STATUS, VOLTAGE_CONTROLLER_ON))\r\n? true : false;\r\n}
