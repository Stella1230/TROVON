static irqreturn_t axp20x_ac_power_irq(int irq, void *devid)\r\n{\r\nstruct axp20x_ac_power *power = devid;\r\npower_supply_changed(power->supply);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int axp20x_ac_power_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct axp20x_ac_power *power = power_supply_get_drvdata(psy);\r\nint ret, reg;\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_HEALTH:\r\nret = regmap_read(power->regmap, AXP20X_PWR_INPUT_STATUS, &reg);\r\nif (ret)\r\nreturn ret;\r\nif (reg & AXP20X_PWR_STATUS_ACIN_PRESENT) {\r\nval->intval = POWER_SUPPLY_HEALTH_GOOD;\r\nreturn 0;\r\n}\r\nval->intval = POWER_SUPPLY_HEALTH_UNKNOWN;\r\nreturn 0;\r\ncase POWER_SUPPLY_PROP_PRESENT:\r\nret = regmap_read(power->regmap, AXP20X_PWR_INPUT_STATUS, &reg);\r\nif (ret)\r\nreturn ret;\r\nval->intval = !!(reg & AXP20X_PWR_STATUS_ACIN_PRESENT);\r\nreturn 0;\r\ncase POWER_SUPPLY_PROP_ONLINE:\r\nret = regmap_read(power->regmap, AXP20X_PWR_INPUT_STATUS, &reg);\r\nif (ret)\r\nreturn ret;\r\nval->intval = !!(reg & AXP20X_PWR_STATUS_ACIN_AVAIL);\r\nreturn 0;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_NOW:\r\nret = iio_read_channel_processed(power->acin_v, &val->intval);\r\nif (ret)\r\nreturn ret;\r\nval->intval *= 1000;\r\nreturn 0;\r\ncase POWER_SUPPLY_PROP_CURRENT_NOW:\r\nret = iio_read_channel_processed(power->acin_i, &val->intval);\r\nif (ret)\r\nreturn ret;\r\nval->intval *= 1000;\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int axp20x_ac_power_probe(struct platform_device *pdev)\r\n{\r\nstruct axp20x_dev *axp20x = dev_get_drvdata(pdev->dev.parent);\r\nstruct power_supply_config psy_cfg = {};\r\nstruct axp20x_ac_power *power;\r\nstruct axp_data *axp_data;\r\nstatic const char * const irq_names[] = { "ACIN_PLUGIN", "ACIN_REMOVAL",\r\nNULL };\r\nint i, irq, ret;\r\nif (!of_device_is_available(pdev->dev.of_node))\r\nreturn -ENODEV;\r\nif (!axp20x) {\r\ndev_err(&pdev->dev, "Parent drvdata not set\n");\r\nreturn -EINVAL;\r\n}\r\npower = devm_kzalloc(&pdev->dev, sizeof(*power), GFP_KERNEL);\r\nif (!power)\r\nreturn -ENOMEM;\r\naxp_data = (struct axp_data *)of_device_get_match_data(&pdev->dev);\r\nif (axp_data->acin_adc) {\r\npower->acin_v = devm_iio_channel_get(&pdev->dev, "acin_v");\r\nif (IS_ERR(power->acin_v)) {\r\nif (PTR_ERR(power->acin_v) == -ENODEV)\r\nreturn -EPROBE_DEFER;\r\nreturn PTR_ERR(power->acin_v);\r\n}\r\npower->acin_i = devm_iio_channel_get(&pdev->dev, "acin_i");\r\nif (IS_ERR(power->acin_i)) {\r\nif (PTR_ERR(power->acin_i) == -ENODEV)\r\nreturn -EPROBE_DEFER;\r\nreturn PTR_ERR(power->acin_i);\r\n}\r\n}\r\npower->regmap = dev_get_regmap(pdev->dev.parent, NULL);\r\nplatform_set_drvdata(pdev, power);\r\npsy_cfg.of_node = pdev->dev.of_node;\r\npsy_cfg.drv_data = power;\r\npower->supply = devm_power_supply_register(&pdev->dev,\r\naxp_data->power_desc,\r\n&psy_cfg);\r\nif (IS_ERR(power->supply))\r\nreturn PTR_ERR(power->supply);\r\nfor (i = 0; irq_names[i]; i++) {\r\nirq = platform_get_irq_byname(pdev, irq_names[i]);\r\nif (irq < 0) {\r\ndev_warn(&pdev->dev, "No IRQ for %s: %d\n",\r\nirq_names[i], irq);\r\ncontinue;\r\n}\r\nirq = regmap_irq_get_virq(axp20x->regmap_irqc, irq);\r\nret = devm_request_any_context_irq(&pdev->dev, irq,\r\naxp20x_ac_power_irq, 0,\r\nDRVNAME, power);\r\nif (ret < 0)\r\ndev_warn(&pdev->dev, "Error requesting %s IRQ: %d\n",\r\nirq_names[i], ret);\r\n}\r\nreturn 0;\r\n}
