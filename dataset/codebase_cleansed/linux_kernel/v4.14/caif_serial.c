static inline void update_tty_status(struct ser_device *ser)\r\n{\r\nser->tty_status =\r\nser->tty->stopped << 5 |\r\nser->tty->flow_stopped << 3 |\r\nser->tty->packet << 2 |\r\nser->tty->port->low_latency << 1;\r\n}\r\nstatic inline void debugfs_init(struct ser_device *ser, struct tty_struct *tty)\r\n{\r\nser->debugfs_tty_dir =\r\ndebugfs_create_dir(tty->name, debugfsdir);\r\nif (!IS_ERR(ser->debugfs_tty_dir)) {\r\ndebugfs_create_blob("last_tx_msg", S_IRUSR,\r\nser->debugfs_tty_dir,\r\n&ser->tx_blob);\r\ndebugfs_create_blob("last_rx_msg", S_IRUSR,\r\nser->debugfs_tty_dir,\r\n&ser->rx_blob);\r\ndebugfs_create_x32("ser_state", S_IRUSR,\r\nser->debugfs_tty_dir,\r\n(u32 *)&ser->state);\r\ndebugfs_create_x8("tty_status", S_IRUSR,\r\nser->debugfs_tty_dir,\r\n&ser->tty_status);\r\n}\r\nser->tx_blob.data = ser->tx_data;\r\nser->tx_blob.size = 0;\r\nser->rx_blob.data = ser->rx_data;\r\nser->rx_blob.size = 0;\r\n}\r\nstatic inline void debugfs_deinit(struct ser_device *ser)\r\n{\r\ndebugfs_remove_recursive(ser->debugfs_tty_dir);\r\n}\r\nstatic inline void debugfs_rx(struct ser_device *ser, const u8 *data, int size)\r\n{\r\nif (size > sizeof(ser->rx_data))\r\nsize = sizeof(ser->rx_data);\r\nmemcpy(ser->rx_data, data, size);\r\nser->rx_blob.data = ser->rx_data;\r\nser->rx_blob.size = size;\r\n}\r\nstatic inline void debugfs_tx(struct ser_device *ser, const u8 *data, int size)\r\n{\r\nif (size > sizeof(ser->tx_data))\r\nsize = sizeof(ser->tx_data);\r\nmemcpy(ser->tx_data, data, size);\r\nser->tx_blob.data = ser->tx_data;\r\nser->tx_blob.size = size;\r\n}\r\nstatic inline void debugfs_init(struct ser_device *ser, struct tty_struct *tty)\r\n{\r\n}\r\nstatic inline void debugfs_deinit(struct ser_device *ser)\r\n{\r\n}\r\nstatic inline void update_tty_status(struct ser_device *ser)\r\n{\r\n}\r\nstatic inline void debugfs_rx(struct ser_device *ser, const u8 *data, int size)\r\n{\r\n}\r\nstatic inline void debugfs_tx(struct ser_device *ser, const u8 *data, int size)\r\n{\r\n}\r\nstatic void ldisc_receive(struct tty_struct *tty, const u8 *data,\r\nchar *flags, int count)\r\n{\r\nstruct sk_buff *skb = NULL;\r\nstruct ser_device *ser;\r\nint ret;\r\nser = tty->disc_data;\r\nif (!ser->common.use_stx && !ser->tx_started) {\r\ndev_info(&ser->dev->dev,\r\n"Bytes received before initial transmission -"\r\n"bytes discarded.\n");\r\nreturn;\r\n}\r\nBUG_ON(ser->dev == NULL);\r\nskb = netdev_alloc_skb(ser->dev, count+1);\r\nif (skb == NULL)\r\nreturn;\r\nskb_put_data(skb, data, count);\r\nskb->protocol = htons(ETH_P_CAIF);\r\nskb_reset_mac_header(skb);\r\ndebugfs_rx(ser, data, count);\r\nret = netif_rx_ni(skb);\r\nif (!ret) {\r\nser->dev->stats.rx_packets++;\r\nser->dev->stats.rx_bytes += count;\r\n} else\r\n++ser->dev->stats.rx_dropped;\r\nupdate_tty_status(ser);\r\n}\r\nstatic int handle_tx(struct ser_device *ser)\r\n{\r\nstruct tty_struct *tty;\r\nstruct sk_buff *skb;\r\nint tty_wr, len, room;\r\ntty = ser->tty;\r\nser->tx_started = true;\r\nif (test_and_set_bit(CAIF_SENDING, &ser->state))\r\nreturn 0;\r\nwhile ((skb = skb_peek(&ser->head)) != NULL) {\r\nlen = skb->len;\r\nroom = tty_write_room(tty);\r\nif (!room)\r\nbreak;\r\nif (room > ser_write_chunk)\r\nroom = ser_write_chunk;\r\nif (len > room)\r\nlen = room;\r\nif (!ser_loop) {\r\ntty_wr = tty->ops->write(tty, skb->data, len);\r\nupdate_tty_status(ser);\r\n} else {\r\ntty_wr = len;\r\nldisc_receive(tty, skb->data, NULL, len);\r\n}\r\nser->dev->stats.tx_packets++;\r\nser->dev->stats.tx_bytes += tty_wr;\r\nif (tty_wr < 0)\r\ngoto error;\r\nskb_pull(skb, tty_wr);\r\nif (skb->len == 0) {\r\nstruct sk_buff *tmp = skb_dequeue(&ser->head);\r\nWARN_ON(tmp != skb);\r\nif (in_interrupt())\r\ndev_kfree_skb_irq(skb);\r\nelse\r\nkfree_skb(skb);\r\n}\r\n}\r\nif (ser->head.qlen <= SEND_QUEUE_LOW &&\r\ntest_and_clear_bit(CAIF_FLOW_OFF_SENT, &ser->state) &&\r\nser->common.flowctrl != NULL)\r\nser->common.flowctrl(ser->dev, ON);\r\nclear_bit(CAIF_SENDING, &ser->state);\r\nreturn 0;\r\nerror:\r\nclear_bit(CAIF_SENDING, &ser->state);\r\nreturn tty_wr;\r\n}\r\nstatic int caif_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct ser_device *ser;\r\nBUG_ON(dev == NULL);\r\nser = netdev_priv(dev);\r\nif (ser->head.qlen > SEND_QUEUE_HIGH &&\r\n!test_and_set_bit(CAIF_FLOW_OFF_SENT, &ser->state) &&\r\nser->common.flowctrl != NULL)\r\nser->common.flowctrl(ser->dev, OFF);\r\nskb_queue_tail(&ser->head, skb);\r\nreturn handle_tx(ser);\r\n}\r\nstatic void ldisc_tx_wakeup(struct tty_struct *tty)\r\n{\r\nstruct ser_device *ser;\r\nser = tty->disc_data;\r\nBUG_ON(ser == NULL);\r\nWARN_ON(ser->tty != tty);\r\nhandle_tx(ser);\r\n}\r\nstatic void ser_release(struct work_struct *work)\r\n{\r\nstruct list_head list;\r\nstruct ser_device *ser, *tmp;\r\nspin_lock(&ser_lock);\r\nlist_replace_init(&ser_release_list, &list);\r\nspin_unlock(&ser_lock);\r\nif (!list_empty(&list)) {\r\nrtnl_lock();\r\nlist_for_each_entry_safe(ser, tmp, &list, node) {\r\ndev_close(ser->dev);\r\nunregister_netdevice(ser->dev);\r\ndebugfs_deinit(ser);\r\n}\r\nrtnl_unlock();\r\n}\r\n}\r\nstatic int ldisc_open(struct tty_struct *tty)\r\n{\r\nstruct ser_device *ser;\r\nstruct net_device *dev;\r\nchar name[64];\r\nint result;\r\nif (tty->ops->write == NULL)\r\nreturn -EOPNOTSUPP;\r\nif (!capable(CAP_SYS_ADMIN) && !capable(CAP_SYS_TTY_CONFIG))\r\nreturn -EPERM;\r\nser_release(NULL);\r\nresult = snprintf(name, sizeof(name), "cf%s", tty->name);\r\nif (result >= IFNAMSIZ)\r\nreturn -EINVAL;\r\ndev = alloc_netdev(sizeof(*ser), name, NET_NAME_UNKNOWN,\r\ncaifdev_setup);\r\nif (!dev)\r\nreturn -ENOMEM;\r\nser = netdev_priv(dev);\r\nser->tty = tty_kref_get(tty);\r\nser->dev = dev;\r\ndebugfs_init(ser, tty);\r\ntty->receive_room = N_TTY_BUF_SIZE;\r\ntty->disc_data = ser;\r\nset_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\r\nrtnl_lock();\r\nresult = register_netdevice(dev);\r\nif (result) {\r\nrtnl_unlock();\r\nfree_netdev(dev);\r\nreturn -ENODEV;\r\n}\r\nspin_lock(&ser_lock);\r\nlist_add(&ser->node, &ser_list);\r\nspin_unlock(&ser_lock);\r\nrtnl_unlock();\r\nnetif_stop_queue(dev);\r\nupdate_tty_status(ser);\r\nreturn 0;\r\n}\r\nstatic void ldisc_close(struct tty_struct *tty)\r\n{\r\nstruct ser_device *ser = tty->disc_data;\r\ntty_kref_put(ser->tty);\r\nspin_lock(&ser_lock);\r\nlist_move(&ser->node, &ser_release_list);\r\nspin_unlock(&ser_lock);\r\nschedule_work(&ser_release_work);\r\n}\r\nstatic int register_ldisc(void)\r\n{\r\nint result;\r\nresult = tty_register_ldisc(N_CAIF, &caif_ldisc);\r\nif (result < 0) {\r\npr_err("cannot register CAIF ldisc=%d err=%d\n", N_CAIF,\r\nresult);\r\nreturn result;\r\n}\r\nreturn result;\r\n}\r\nstatic void caifdev_setup(struct net_device *dev)\r\n{\r\nstruct ser_device *serdev = netdev_priv(dev);\r\ndev->features = 0;\r\ndev->netdev_ops = &netdev_ops;\r\ndev->type = ARPHRD_CAIF;\r\ndev->flags = IFF_POINTOPOINT | IFF_NOARP;\r\ndev->mtu = CAIF_MAX_MTU;\r\ndev->priv_flags |= IFF_NO_QUEUE;\r\ndev->needs_free_netdev = true;\r\nskb_queue_head_init(&serdev->head);\r\nserdev->common.link_select = CAIF_LINK_LOW_LATENCY;\r\nserdev->common.use_frag = true;\r\nserdev->common.use_stx = ser_use_stx;\r\nserdev->common.use_fcs = ser_use_fcs;\r\nserdev->dev = dev;\r\n}\r\nstatic int caif_net_open(struct net_device *dev)\r\n{\r\nnetif_wake_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int caif_net_close(struct net_device *dev)\r\n{\r\nnetif_stop_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int __init caif_ser_init(void)\r\n{\r\nint ret;\r\nret = register_ldisc();\r\ndebugfsdir = debugfs_create_dir("caif_serial", NULL);\r\nreturn ret;\r\n}\r\nstatic void __exit caif_ser_exit(void)\r\n{\r\nspin_lock(&ser_lock);\r\nlist_splice(&ser_list, &ser_release_list);\r\nspin_unlock(&ser_lock);\r\nser_release(NULL);\r\ncancel_work_sync(&ser_release_work);\r\ntty_unregister_ldisc(N_CAIF);\r\ndebugfs_remove_recursive(debugfsdir);\r\n}
