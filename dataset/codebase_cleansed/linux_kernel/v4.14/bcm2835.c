static void snd_devm_unregister_child(struct device *dev, void *res)\r\n{\r\nstruct device *childdev = *(struct device **)res;\r\ndevice_unregister(childdev);\r\n}\r\nstatic int snd_devm_add_child(struct device *dev, struct device *child)\r\n{\r\nstruct device **dr;\r\nint ret;\r\ndr = devres_alloc(snd_devm_unregister_child, sizeof(*dr), GFP_KERNEL);\r\nif (!dr)\r\nreturn -ENOMEM;\r\nret = device_add(child);\r\nif (ret) {\r\ndevres_free(dr);\r\nreturn ret;\r\n}\r\n*dr = child;\r\ndevres_add(dev, dr);\r\nreturn 0;\r\n}\r\nstatic struct device *\r\nsnd_create_device(struct device *parent,\r\nstruct device_driver *driver,\r\nconst char *name)\r\n{\r\nstruct device *device;\r\nint ret;\r\ndevice = devm_kzalloc(parent, sizeof(*device), GFP_KERNEL);\r\nif (!device)\r\nreturn ERR_PTR(-ENOMEM);\r\ndevice_initialize(device);\r\ndevice->parent = parent;\r\ndevice->driver = driver;\r\ndev_set_name(device, "%s", name);\r\nret = snd_devm_add_child(parent, device);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\nreturn device;\r\n}\r\nstatic int snd_bcm2835_free(struct bcm2835_chip *chip)\r\n{\r\nkfree(chip);\r\nreturn 0;\r\n}\r\nstatic int snd_bcm2835_dev_free(struct snd_device *device)\r\n{\r\nreturn snd_bcm2835_free(device->device_data);\r\n}\r\nstatic int snd_bcm2835_create(struct snd_card *card,\r\nstruct bcm2835_chip **rchip)\r\n{\r\nstruct bcm2835_chip *chip;\r\nint err;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_bcm2835_dev_free,\r\n};\r\n*rchip = NULL;\r\nchip = kzalloc(sizeof(*chip), GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\nchip->card = card;\r\nerr = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops);\r\nif (err) {\r\nsnd_bcm2835_free(chip);\r\nreturn err;\r\n}\r\n*rchip = chip;\r\nreturn 0;\r\n}\r\nstatic void snd_devm_card_free(struct device *dev, void *res)\r\n{\r\nstruct snd_card *snd_card = *(struct snd_card **)res;\r\nsnd_card_free(snd_card);\r\n}\r\nstatic struct snd_card *snd_devm_card_new(struct device *dev)\r\n{\r\nstruct snd_card **dr;\r\nstruct snd_card *card;\r\nint ret;\r\ndr = devres_alloc(snd_devm_card_free, sizeof(*dr), GFP_KERNEL);\r\nif (!dr)\r\nreturn ERR_PTR(-ENOMEM);\r\nret = snd_card_new(dev, -1, NULL, THIS_MODULE, 0, &card);\r\nif (ret) {\r\ndevres_free(dr);\r\nreturn ERR_PTR(ret);\r\n}\r\n*dr = card;\r\ndevres_add(dev, dr);\r\nreturn card;\r\n}\r\nstatic int bcm2835_audio_alsa_newpcm(struct bcm2835_chip *chip,\r\nconst char *name,\r\nenum snd_bcm2835_route route,\r\nu32 numchannels)\r\n{\r\nint err;\r\nerr = snd_bcm2835_new_pcm(chip, numchannels - 1);\r\nif (err)\r\nreturn err;\r\nerr = snd_bcm2835_new_spdif_pcm(chip);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int snd_add_child_device(struct device *device,\r\nstruct bcm2835_audio_driver *audio_driver,\r\nu32 numchans)\r\n{\r\nstruct snd_card *card;\r\nstruct device *child;\r\nstruct bcm2835_chip *chip;\r\nint err, i;\r\nchild = snd_create_device(device, &audio_driver->driver,\r\naudio_driver->driver.name);\r\nif (IS_ERR(child)) {\r\ndev_err(device,\r\n"Unable to create child device %p, error %ld",\r\naudio_driver->driver.name,\r\nPTR_ERR(child));\r\nreturn PTR_ERR(child);\r\n}\r\ncard = snd_devm_card_new(child);\r\nif (IS_ERR(card)) {\r\ndev_err(child, "Failed to create card");\r\nreturn PTR_ERR(card);\r\n}\r\nsnd_card_set_dev(card, child);\r\nstrcpy(card->driver, audio_driver->driver.name);\r\nstrcpy(card->shortname, audio_driver->shortname);\r\nstrcpy(card->longname, audio_driver->longname);\r\nerr = snd_bcm2835_create(card, &chip);\r\nif (err) {\r\ndev_err(child, "Failed to create chip, error %d\n", err);\r\nreturn err;\r\n}\r\nchip->dev = child;\r\nerr = audio_driver->newpcm(chip, audio_driver->shortname,\r\naudio_driver->route,\r\nnumchans);\r\nif (err) {\r\ndev_err(child, "Failed to create pcm, error %d\n", err);\r\nreturn err;\r\n}\r\nerr = audio_driver->newctl(chip);\r\nif (err) {\r\ndev_err(child, "Failed to create controls, error %d\n", err);\r\nreturn err;\r\n}\r\nfor (i = 0; i < numchans; i++)\r\nchip->avail_substreams |= (1 << i);\r\nerr = snd_card_register(card);\r\nif (err) {\r\ndev_err(child, "Failed to register card, error %d\n", err);\r\nreturn err;\r\n}\r\ndev_set_drvdata(child, card);\r\ndev_info(child, "card created with %d channels\n", numchans);\r\nreturn 0;\r\n}\r\nstatic int snd_add_child_devices(struct device *device, u32 numchans)\r\n{\r\nint i;\r\nint count_devices = 0;\r\nint minchannels = 0;\r\nint extrachannels = 0;\r\nint extrachannels_per_driver = 0;\r\nint extrachannels_remainder = 0;\r\nfor (i = 0; i < ARRAY_SIZE(children_devices); i++)\r\nif (*children_devices[i].is_enabled)\r\ncount_devices++;\r\nif (!count_devices)\r\nreturn 0;\r\nfor (i = 0; i < ARRAY_SIZE(children_devices); i++)\r\nif (*children_devices[i].is_enabled)\r\nminchannels +=\r\nchildren_devices[i].audio_driver->minchannels;\r\nif (minchannels < numchans) {\r\nextrachannels = numchans - minchannels;\r\nextrachannels_per_driver = extrachannels / count_devices;\r\nextrachannels_remainder = extrachannels % count_devices;\r\n}\r\ndev_dbg(device, "minchannels %d\n", minchannels);\r\ndev_dbg(device, "extrachannels %d\n", extrachannels);\r\ndev_dbg(device, "extrachannels_per_driver %d\n",\r\nextrachannels_per_driver);\r\ndev_dbg(device, "extrachannels_remainder %d\n",\r\nextrachannels_remainder);\r\nfor (i = 0; i < ARRAY_SIZE(children_devices); i++) {\r\nint err;\r\nint numchannels_this_device;\r\nstruct bcm2835_audio_driver *audio_driver;\r\nif (!*children_devices[i].is_enabled)\r\ncontinue;\r\naudio_driver = children_devices[i].audio_driver;\r\nif (audio_driver->minchannels > numchans) {\r\ndev_err(device,\r\n"Out of channels, needed %d but only %d left\n",\r\naudio_driver->minchannels,\r\nnumchans);\r\ncontinue;\r\n}\r\nnumchannels_this_device =\r\naudio_driver->minchannels + extrachannels_per_driver +\r\nextrachannels_remainder;\r\nextrachannels_remainder = 0;\r\nnumchans -= numchannels_this_device;\r\nerr = snd_add_child_device(device, audio_driver,\r\nnumchannels_this_device);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_bcm2835_alsa_probe_dt(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nu32 numchans;\r\nint err;\r\nerr = of_property_read_u32(dev->of_node, "brcm,pwm-channels",\r\n&numchans);\r\nif (err) {\r\ndev_err(dev, "Failed to get DT property 'brcm,pwm-channels'");\r\nreturn err;\r\n}\r\nif (numchans == 0 || numchans > MAX_SUBSTREAMS) {\r\nnumchans = MAX_SUBSTREAMS;\r\ndev_warn(dev,\r\n"Illegal 'brcm,pwm-channels' value, will use %u\n",\r\nnumchans);\r\n}\r\nerr = snd_add_child_devices(dev, numchans);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int snd_bcm2835_alsa_suspend(struct platform_device *pdev,\r\npm_message_t state)\r\n{\r\nreturn 0;\r\n}\r\nstatic int snd_bcm2835_alsa_resume(struct platform_device *pdev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int bcm2835_alsa_device_init(void)\r\n{\r\nint retval;\r\nretval = platform_driver_register(&bcm2835_alsa0_driver);\r\nif (retval)\r\npr_err("Error registering bcm2835_audio driver %d .\n", retval);\r\nreturn retval;\r\n}\r\nstatic void bcm2835_alsa_device_exit(void)\r\n{\r\nplatform_driver_unregister(&bcm2835_alsa0_driver);\r\n}
