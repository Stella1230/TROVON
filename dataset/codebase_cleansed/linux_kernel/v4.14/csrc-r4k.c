static u64 c0_hpt_read(struct clocksource *cs)\r\n{\r\nreturn read_c0_count();\r\n}\r\nstatic u64 __maybe_unused notrace r4k_read_sched_clock(void)\r\n{\r\nreturn read_c0_count();\r\n}\r\nstatic inline unsigned int rdhwr_count(void)\r\n{\r\nunsigned int count;\r\n__asm__ __volatile__(\r\n" .set push\n"\r\n" .set mips32r2\n"\r\n" rdhwr %0, $2\n"\r\n" .set pop\n"\r\n: "=r" (count));\r\nreturn count;\r\n}\r\nstatic bool rdhwr_count_usable(void)\r\n{\r\nunsigned int prev, curr, i;\r\nfor (i = 0, prev = rdhwr_count(); i < 100; i++) {\r\ncurr = rdhwr_count();\r\nif (curr != prev)\r\nreturn true;\r\nprev = curr;\r\n}\r\npr_warn("Not using R4K clocksource in VDSO due to broken RDHWR\n");\r\nreturn false;\r\n}\r\nint __init init_r4k_clocksource(void)\r\n{\r\nif (!cpu_has_counter || !mips_hpt_frequency)\r\nreturn -ENXIO;\r\nclocksource_mips.rating = 200 + mips_hpt_frequency / 10000000;\r\nif (cpu_has_mips_r2_r6 && rdhwr_count_usable())\r\nclocksource_mips.archdata.vdso_clock_mode = VDSO_CLOCK_R4K;\r\nclocksource_register_hz(&clocksource_mips, mips_hpt_frequency);\r\n#ifndef CONFIG_CPU_FREQ\r\nsched_clock_register(r4k_read_sched_clock, 32, mips_hpt_frequency);\r\n#endif\r\nreturn 0;\r\n}
