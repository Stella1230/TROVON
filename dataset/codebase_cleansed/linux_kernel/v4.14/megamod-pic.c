static void mask_megamod(struct irq_data *data)\r\n{\r\nstruct megamod_pic *pic = irq_data_get_irq_chip_data(data);\r\nirq_hw_number_t src = irqd_to_hwirq(data);\r\nu32 __iomem *evtmask = &pic->regs->evtmask[src / 32];\r\nraw_spin_lock(&pic->lock);\r\nsoc_writel(soc_readl(evtmask) | (1 << (src & 31)), evtmask);\r\nraw_spin_unlock(&pic->lock);\r\n}\r\nstatic void unmask_megamod(struct irq_data *data)\r\n{\r\nstruct megamod_pic *pic = irq_data_get_irq_chip_data(data);\r\nirq_hw_number_t src = irqd_to_hwirq(data);\r\nu32 __iomem *evtmask = &pic->regs->evtmask[src / 32];\r\nraw_spin_lock(&pic->lock);\r\nsoc_writel(soc_readl(evtmask) & ~(1 << (src & 31)), evtmask);\r\nraw_spin_unlock(&pic->lock);\r\n}\r\nstatic void megamod_irq_cascade(struct irq_desc *desc)\r\n{\r\nstruct megamod_cascade_data *cascade;\r\nstruct megamod_pic *pic;\r\nunsigned int irq;\r\nu32 events;\r\nint n, idx;\r\ncascade = irq_desc_get_handler_data(desc);\r\npic = cascade->pic;\r\nidx = cascade->index;\r\nwhile ((events = soc_readl(&pic->regs->mevtflag[idx])) != 0) {\r\nn = __ffs(events);\r\nirq = irq_linear_revmap(pic->irqhost, idx * 32 + n);\r\nsoc_writel(1 << n, &pic->regs->evtclr[idx]);\r\ngeneric_handle_irq(irq);\r\n}\r\n}\r\nstatic int megamod_map(struct irq_domain *h, unsigned int virq,\r\nirq_hw_number_t hw)\r\n{\r\nstruct megamod_pic *pic = h->host_data;\r\nint i;\r\nfor (i = 0; i < NR_MUX_OUTPUTS; i++)\r\nif (pic->output_to_irq[i] == hw)\r\nreturn -1;\r\nirq_set_chip_data(virq, pic);\r\nirq_set_chip_and_handler(virq, &megamod_chip, handle_level_irq);\r\nirq_set_irq_type(virq, IRQ_TYPE_NONE);\r\nreturn 0;\r\n}\r\nstatic void __init set_megamod_mux(struct megamod_pic *pic, int src, int output)\r\n{\r\nint index, offset;\r\nu32 val;\r\nif (src < 0 || src >= (NR_COMBINERS * 32)) {\r\npic->output_to_irq[output] = IRQ_UNMAPPED;\r\nreturn;\r\n}\r\nindex = output / 4;\r\noffset = (output & 3) * 8;\r\nval = soc_readl(&pic->regs->intmux[index]);\r\nval &= ~(0xff << offset);\r\nval |= src << offset;\r\nsoc_writel(val, &pic->regs->intmux[index]);\r\n}\r\nstatic void __init parse_priority_map(struct megamod_pic *pic,\r\nint *mapping, int size)\r\n{\r\nstruct device_node *np = irq_domain_get_of_node(pic->irqhost);\r\nconst __be32 *map;\r\nint i, maplen;\r\nu32 val;\r\nmap = of_get_property(np, "ti,c64x+megamod-pic-mux", &maplen);\r\nif (map) {\r\nmaplen /= 4;\r\nif (maplen > size)\r\nmaplen = size;\r\nfor (i = 0; i < maplen; i++) {\r\nval = be32_to_cpup(map);\r\nif (val && val >= 4)\r\nmapping[i] = val;\r\n++map;\r\n}\r\n}\r\n}\r\nstatic struct megamod_pic * __init init_megamod_pic(struct device_node *np)\r\n{\r\nstruct megamod_pic *pic;\r\nint i, irq;\r\nint mapping[NR_MUX_OUTPUTS];\r\npr_info("Initializing C64x+ Megamodule PIC\n");\r\npic = kzalloc(sizeof(struct megamod_pic), GFP_KERNEL);\r\nif (!pic) {\r\npr_err("%pOF: Could not alloc PIC structure.\n", np);\r\nreturn NULL;\r\n}\r\npic->irqhost = irq_domain_add_linear(np, NR_COMBINERS * 32,\r\n&megamod_domain_ops, pic);\r\nif (!pic->irqhost) {\r\npr_err("%pOF: Could not alloc host.\n", np);\r\ngoto error_free;\r\n}\r\npic->irqhost->host_data = pic;\r\nraw_spin_lock_init(&pic->lock);\r\npic->regs = of_iomap(np, 0);\r\nif (!pic->regs) {\r\npr_err("%pOF: Could not map registers.\n", np);\r\ngoto error_free;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(mapping); i++)\r\nmapping[i] = IRQ_UNMAPPED;\r\nparse_priority_map(pic, mapping, ARRAY_SIZE(mapping));\r\nfor (i = 0; i < NR_COMBINERS; i++) {\r\nstruct irq_data *irq_data;\r\nirq_hw_number_t hwirq;\r\nirq = irq_of_parse_and_map(np, i);\r\nif (irq == NO_IRQ)\r\ncontinue;\r\nirq_data = irq_get_irq_data(irq);\r\nif (!irq_data) {\r\npr_err("%pOF: combiner-%d no irq_data for virq %d!\n",\r\nnp, i, irq);\r\ncontinue;\r\n}\r\nhwirq = irq_data->hwirq;\r\nif (hwirq < 4 || hwirq >= NR_PRIORITY_IRQS) {\r\npr_err("%pOF: combiner-%d core irq %ld out of range!\n",\r\nnp, i, hwirq);\r\ncontinue;\r\n}\r\nmapping[hwirq - 4] = i;\r\npr_debug("%pOF: combiner-%d cascading to hwirq %ld\n",\r\nnp, i, hwirq);\r\ncascade_data[i].pic = pic;\r\ncascade_data[i].index = i;\r\nsoc_writel(~0, &pic->regs->evtmask[i]);\r\nsoc_writel(~0, &pic->regs->evtclr[i]);\r\nirq_set_chained_handler_and_data(irq, megamod_irq_cascade,\r\n&cascade_data[i]);\r\n}\r\nfor (i = 0; i < NR_MUX_OUTPUTS; i++) {\r\nif (mapping[i] != IRQ_UNMAPPED) {\r\npr_debug("%pOF: setting mux %d to priority %d\n",\r\nnp, mapping[i], i + 4);\r\nset_megamod_mux(pic, mapping[i], i);\r\n}\r\n}\r\nreturn pic;\r\nerror_free:\r\nkfree(pic);\r\nreturn NULL;\r\n}\r\nstatic int get_exception(void)\r\n{\r\nint i, bit;\r\nu32 mask;\r\nfor (i = 0; i < NR_COMBINERS; i++) {\r\nmask = soc_readl(&mm_pic->regs->mexpflag[i]);\r\nif (mask) {\r\nbit = __ffs(mask);\r\nsoc_writel(1 << bit, &mm_pic->regs->evtclr[i]);\r\nreturn (i * 32) + bit;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nstatic void assert_event(unsigned int val)\r\n{\r\nsoc_writel(val, &mm_pic->regs->evtasrt);\r\n}\r\nvoid __init megamod_pic_init(void)\r\n{\r\nstruct device_node *np;\r\nnp = of_find_compatible_node(NULL, NULL, "ti,c64x+megamod-pic");\r\nif (!np)\r\nreturn;\r\nmm_pic = init_megamod_pic(np);\r\nof_node_put(np);\r\nsoc_ops.get_exception = get_exception;\r\nsoc_ops.assert_event = assert_event;\r\nreturn;\r\n}
