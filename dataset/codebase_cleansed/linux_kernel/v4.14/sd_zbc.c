static void sd_zbc_parse_report(struct scsi_disk *sdkp,\r\nu8 *buf,\r\nstruct blk_zone *zone)\r\n{\r\nstruct scsi_device *sdp = sdkp->device;\r\nmemset(zone, 0, sizeof(struct blk_zone));\r\nzone->type = buf[0] & 0x0f;\r\nzone->cond = (buf[1] >> 4) & 0xf;\r\nif (buf[1] & 0x01)\r\nzone->reset = 1;\r\nif (buf[1] & 0x02)\r\nzone->non_seq = 1;\r\nzone->len = logical_to_sectors(sdp, get_unaligned_be64(&buf[8]));\r\nzone->start = logical_to_sectors(sdp, get_unaligned_be64(&buf[16]));\r\nzone->wp = logical_to_sectors(sdp, get_unaligned_be64(&buf[24]));\r\nif (zone->type != ZBC_ZONE_TYPE_CONV &&\r\nzone->cond == ZBC_ZONE_COND_FULL)\r\nzone->wp = zone->start + zone->len;\r\n}\r\nstatic int sd_zbc_report_zones(struct scsi_disk *sdkp, unsigned char *buf,\r\nunsigned int buflen, sector_t lba)\r\n{\r\nstruct scsi_device *sdp = sdkp->device;\r\nconst int timeout = sdp->request_queue->rq_timeout;\r\nstruct scsi_sense_hdr sshdr;\r\nunsigned char cmd[16];\r\nunsigned int rep_len;\r\nint result;\r\nmemset(cmd, 0, 16);\r\ncmd[0] = ZBC_IN;\r\ncmd[1] = ZI_REPORT_ZONES;\r\nput_unaligned_be64(lba, &cmd[2]);\r\nput_unaligned_be32(buflen, &cmd[10]);\r\nmemset(buf, 0, buflen);\r\nresult = scsi_execute_req(sdp, cmd, DMA_FROM_DEVICE,\r\nbuf, buflen, &sshdr,\r\ntimeout, SD_MAX_RETRIES, NULL);\r\nif (result) {\r\nsd_printk(KERN_ERR, sdkp,\r\n"REPORT ZONES lba %llu failed with %d/%d\n",\r\n(unsigned long long)lba,\r\nhost_byte(result), driver_byte(result));\r\nreturn -EIO;\r\n}\r\nrep_len = get_unaligned_be32(&buf[0]);\r\nif (rep_len < 64) {\r\nsd_printk(KERN_ERR, sdkp,\r\n"REPORT ZONES report invalid length %u\n",\r\nrep_len);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nint sd_zbc_setup_report_cmnd(struct scsi_cmnd *cmd)\r\n{\r\nstruct request *rq = cmd->request;\r\nstruct scsi_disk *sdkp = scsi_disk(rq->rq_disk);\r\nsector_t lba, sector = blk_rq_pos(rq);\r\nunsigned int nr_bytes = blk_rq_bytes(rq);\r\nint ret;\r\nWARN_ON(nr_bytes == 0);\r\nif (!sd_is_zoned(sdkp))\r\nreturn BLKPREP_KILL;\r\nret = scsi_init_io(cmd);\r\nif (ret != BLKPREP_OK)\r\nreturn ret;\r\ncmd->cmd_len = 16;\r\nmemset(cmd->cmnd, 0, cmd->cmd_len);\r\ncmd->cmnd[0] = ZBC_IN;\r\ncmd->cmnd[1] = ZI_REPORT_ZONES;\r\nlba = sectors_to_logical(sdkp->device, sector);\r\nput_unaligned_be64(lba, &cmd->cmnd[2]);\r\nput_unaligned_be32(nr_bytes, &cmd->cmnd[10]);\r\ncmd->cmnd[14] = ZBC_REPORT_ZONE_PARTIAL;\r\ncmd->sc_data_direction = DMA_FROM_DEVICE;\r\ncmd->sdb.length = nr_bytes;\r\ncmd->transfersize = sdkp->device->sector_size;\r\ncmd->allowed = 0;\r\nrq->__data_len = nr_bytes;\r\nreturn BLKPREP_OK;\r\n}\r\nstatic void sd_zbc_report_zones_complete(struct scsi_cmnd *scmd,\r\nunsigned int good_bytes)\r\n{\r\nstruct request *rq = scmd->request;\r\nstruct scsi_disk *sdkp = scsi_disk(rq->rq_disk);\r\nstruct sg_mapping_iter miter;\r\nstruct blk_zone_report_hdr hdr;\r\nstruct blk_zone zone;\r\nunsigned int offset, bytes = 0;\r\nunsigned long flags;\r\nu8 *buf;\r\nif (good_bytes < 64)\r\nreturn;\r\nmemset(&hdr, 0, sizeof(struct blk_zone_report_hdr));\r\nsg_miter_start(&miter, scsi_sglist(scmd), scsi_sg_count(scmd),\r\nSG_MITER_TO_SG | SG_MITER_ATOMIC);\r\nlocal_irq_save(flags);\r\nwhile (sg_miter_next(&miter) && bytes < good_bytes) {\r\nbuf = miter.addr;\r\noffset = 0;\r\nif (bytes == 0) {\r\nhdr.nr_zones = min_t(unsigned int,\r\n(good_bytes - 64) / 64,\r\nget_unaligned_be32(&buf[0]) / 64);\r\nmemcpy(buf, &hdr, sizeof(struct blk_zone_report_hdr));\r\noffset += 64;\r\nbytes += 64;\r\n}\r\nwhile (offset < miter.length && hdr.nr_zones) {\r\nWARN_ON(offset > miter.length);\r\nbuf = miter.addr + offset;\r\nsd_zbc_parse_report(sdkp, buf, &zone);\r\nmemcpy(buf, &zone, sizeof(struct blk_zone));\r\noffset += 64;\r\nbytes += 64;\r\nhdr.nr_zones--;\r\n}\r\nif (!hdr.nr_zones)\r\nbreak;\r\n}\r\nsg_miter_stop(&miter);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic inline sector_t sd_zbc_zone_sectors(struct scsi_disk *sdkp)\r\n{\r\nreturn logical_to_sectors(sdkp->device, sdkp->zone_blocks);\r\n}\r\nstatic inline unsigned int sd_zbc_zone_no(struct scsi_disk *sdkp,\r\nsector_t sector)\r\n{\r\nreturn sectors_to_logical(sdkp->device, sector) >> sdkp->zone_shift;\r\n}\r\nint sd_zbc_setup_reset_cmnd(struct scsi_cmnd *cmd)\r\n{\r\nstruct request *rq = cmd->request;\r\nstruct scsi_disk *sdkp = scsi_disk(rq->rq_disk);\r\nsector_t sector = blk_rq_pos(rq);\r\nsector_t block = sectors_to_logical(sdkp->device, sector);\r\nif (!sd_is_zoned(sdkp))\r\nreturn BLKPREP_KILL;\r\nif (sdkp->device->changed)\r\nreturn BLKPREP_KILL;\r\nif (sector & (sd_zbc_zone_sectors(sdkp) - 1))\r\nreturn BLKPREP_KILL;\r\ncmd->cmd_len = 16;\r\nmemset(cmd->cmnd, 0, cmd->cmd_len);\r\ncmd->cmnd[0] = ZBC_OUT;\r\ncmd->cmnd[1] = ZO_RESET_WRITE_POINTER;\r\nput_unaligned_be64(block, &cmd->cmnd[2]);\r\nrq->timeout = SD_TIMEOUT;\r\ncmd->sc_data_direction = DMA_NONE;\r\ncmd->transfersize = 0;\r\ncmd->allowed = 0;\r\nreturn BLKPREP_OK;\r\n}\r\nint sd_zbc_write_lock_zone(struct scsi_cmnd *cmd)\r\n{\r\nstruct request *rq = cmd->request;\r\nstruct scsi_disk *sdkp = scsi_disk(rq->rq_disk);\r\nsector_t sector = blk_rq_pos(rq);\r\nsector_t zone_sectors = sd_zbc_zone_sectors(sdkp);\r\nunsigned int zno = sd_zbc_zone_no(sdkp, sector);\r\nif (blk_queue_zoned_model(sdkp->disk->queue) == BLK_ZONED_HM &&\r\n(sector & (zone_sectors - 1)) + blk_rq_sectors(rq) > zone_sectors)\r\nreturn BLKPREP_KILL;\r\nif (sdkp->zones_wlock &&\r\ntest_and_set_bit(zno, sdkp->zones_wlock))\r\nreturn BLKPREP_DEFER;\r\nWARN_ON_ONCE(cmd->flags & SCMD_ZONE_WRITE_LOCK);\r\ncmd->flags |= SCMD_ZONE_WRITE_LOCK;\r\nreturn BLKPREP_OK;\r\n}\r\nvoid sd_zbc_write_unlock_zone(struct scsi_cmnd *cmd)\r\n{\r\nstruct request *rq = cmd->request;\r\nstruct scsi_disk *sdkp = scsi_disk(rq->rq_disk);\r\nif (sdkp->zones_wlock && cmd->flags & SCMD_ZONE_WRITE_LOCK) {\r\nunsigned int zno = sd_zbc_zone_no(sdkp, blk_rq_pos(rq));\r\nWARN_ON_ONCE(!test_bit(zno, sdkp->zones_wlock));\r\ncmd->flags &= ~SCMD_ZONE_WRITE_LOCK;\r\nclear_bit_unlock(zno, sdkp->zones_wlock);\r\nsmp_mb__after_atomic();\r\n}\r\n}\r\nvoid sd_zbc_complete(struct scsi_cmnd *cmd,\r\nunsigned int good_bytes,\r\nstruct scsi_sense_hdr *sshdr)\r\n{\r\nint result = cmd->result;\r\nstruct request *rq = cmd->request;\r\nswitch (req_op(rq)) {\r\ncase REQ_OP_ZONE_RESET:\r\nif (result &&\r\nsshdr->sense_key == ILLEGAL_REQUEST &&\r\nsshdr->asc == 0x24)\r\nrq->rq_flags |= RQF_QUIET;\r\nbreak;\r\ncase REQ_OP_WRITE:\r\ncase REQ_OP_WRITE_ZEROES:\r\ncase REQ_OP_WRITE_SAME:\r\nif (result &&\r\nsshdr->sense_key == ILLEGAL_REQUEST &&\r\nsshdr->asc == 0x21)\r\ncmd->allowed = 0;\r\nbreak;\r\ncase REQ_OP_ZONE_REPORT:\r\nif (!result)\r\nsd_zbc_report_zones_complete(cmd, good_bytes);\r\nbreak;\r\n}\r\n}\r\nstatic int sd_zbc_read_zoned_characteristics(struct scsi_disk *sdkp,\r\nunsigned char *buf)\r\n{\r\nif (scsi_get_vpd_page(sdkp->device, 0xb6, buf, 64)) {\r\nsd_printk(KERN_NOTICE, sdkp,\r\n"Unconstrained-read check failed\n");\r\nreturn -ENODEV;\r\n}\r\nif (sdkp->device->type != TYPE_ZBC) {\r\nsdkp->urswrz = 1;\r\nsdkp->zones_optimal_open = get_unaligned_be64(&buf[8]);\r\nsdkp->zones_optimal_nonseq = get_unaligned_be64(&buf[12]);\r\nsdkp->zones_max_open = 0;\r\n} else {\r\nsdkp->urswrz = buf[4] & 1;\r\nsdkp->zones_optimal_open = 0;\r\nsdkp->zones_optimal_nonseq = 0;\r\nsdkp->zones_max_open = get_unaligned_be64(&buf[16]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sd_zbc_check_capacity(struct scsi_disk *sdkp,\r\nunsigned char *buf)\r\n{\r\nsector_t lba;\r\nint ret;\r\nif (sdkp->rc_basis != 0)\r\nreturn 0;\r\nret = sd_zbc_report_zones(sdkp, buf, SD_BUF_SIZE, 0);\r\nif (ret)\r\nreturn ret;\r\nlba = get_unaligned_be64(&buf[8]);\r\nif (lba + 1 == sdkp->capacity)\r\nreturn 0;\r\nif (sdkp->first_scan)\r\nsd_printk(KERN_WARNING, sdkp,\r\n"Changing capacity from %llu to max LBA+1 %llu\n",\r\n(unsigned long long)sdkp->capacity,\r\n(unsigned long long)lba + 1);\r\nsdkp->capacity = lba + 1;\r\nreturn 0;\r\n}\r\nstatic int sd_zbc_check_zone_size(struct scsi_disk *sdkp)\r\n{\r\nu64 zone_blocks;\r\nsector_t block = 0;\r\nunsigned char *buf;\r\nunsigned char *rec;\r\nunsigned int buf_len;\r\nunsigned int list_length;\r\nint ret;\r\nu8 same;\r\nsdkp->zone_blocks = 0;\r\nbuf = kmalloc(SD_ZBC_BUF_SIZE, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nret = sd_zbc_report_zones(sdkp, buf, SD_ZBC_BUF_SIZE, 0);\r\nif (ret) {\r\nzone_blocks = 0;\r\ngoto out;\r\n}\r\nsame = buf[4] & 0x0f;\r\nif (same > 0) {\r\nrec = &buf[64];\r\nzone_blocks = get_unaligned_be64(&rec[8]);\r\ngoto out;\r\n}\r\ndo {\r\nlist_length = get_unaligned_be32(&buf[0]) + 64;\r\nrec = buf + 64;\r\nif (list_length < SD_ZBC_BUF_SIZE)\r\nbuf_len = list_length;\r\nelse\r\nbuf_len = SD_ZBC_BUF_SIZE;\r\nwhile (rec < buf + buf_len) {\r\nzone_blocks = get_unaligned_be64(&rec[8]);\r\nif (sdkp->zone_blocks == 0) {\r\nsdkp->zone_blocks = zone_blocks;\r\n} else if (zone_blocks != sdkp->zone_blocks &&\r\n(block + zone_blocks < sdkp->capacity\r\n|| zone_blocks > sdkp->zone_blocks)) {\r\nzone_blocks = 0;\r\ngoto out;\r\n}\r\nblock += zone_blocks;\r\nrec += 64;\r\n}\r\nif (block < sdkp->capacity) {\r\nret = sd_zbc_report_zones(sdkp, buf,\r\nSD_ZBC_BUF_SIZE, block);\r\nif (ret)\r\nreturn ret;\r\n}\r\n} while (block < sdkp->capacity);\r\nzone_blocks = sdkp->zone_blocks;\r\nout:\r\nkfree(buf);\r\nif (!zone_blocks) {\r\nif (sdkp->first_scan)\r\nsd_printk(KERN_NOTICE, sdkp,\r\n"Devices with non constant zone "\r\n"size are not supported\n");\r\nreturn -ENODEV;\r\n}\r\nif (!is_power_of_2(zone_blocks)) {\r\nif (sdkp->first_scan)\r\nsd_printk(KERN_NOTICE, sdkp,\r\n"Devices with non power of 2 zone "\r\n"size are not supported\n");\r\nreturn -ENODEV;\r\n}\r\nif (logical_to_sectors(sdkp->device, zone_blocks) > UINT_MAX) {\r\nif (sdkp->first_scan)\r\nsd_printk(KERN_NOTICE, sdkp,\r\n"Zone size too large\n");\r\nreturn -ENODEV;\r\n}\r\nsdkp->zone_blocks = zone_blocks;\r\nreturn 0;\r\n}\r\nstatic int sd_zbc_setup(struct scsi_disk *sdkp)\r\n{\r\nblk_queue_chunk_sectors(sdkp->disk->queue,\r\nlogical_to_sectors(sdkp->device, sdkp->zone_blocks));\r\nsdkp->zone_shift = ilog2(sdkp->zone_blocks);\r\nsdkp->nr_zones = sdkp->capacity >> sdkp->zone_shift;\r\nif (sdkp->capacity & (sdkp->zone_blocks - 1))\r\nsdkp->nr_zones++;\r\nif (!sdkp->zones_wlock) {\r\nsdkp->zones_wlock = kcalloc(BITS_TO_LONGS(sdkp->nr_zones),\r\nsizeof(unsigned long),\r\nGFP_KERNEL);\r\nif (!sdkp->zones_wlock)\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nint sd_zbc_read_zones(struct scsi_disk *sdkp,\r\nunsigned char *buf)\r\n{\r\nint ret;\r\nif (!sd_is_zoned(sdkp))\r\nreturn 0;\r\nret = sd_zbc_read_zoned_characteristics(sdkp, buf);\r\nif (ret)\r\ngoto err;\r\nif (!sdkp->urswrz) {\r\nif (sdkp->first_scan)\r\nsd_printk(KERN_NOTICE, sdkp,\r\n"constrained reads devices are not supported\n");\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nret = sd_zbc_check_capacity(sdkp, buf);\r\nif (ret)\r\ngoto err;\r\nret = sd_zbc_check_zone_size(sdkp);\r\nif (ret)\r\ngoto err;\r\nret = sd_zbc_setup(sdkp);\r\nif (ret)\r\ngoto err;\r\nsdkp->device->use_16_for_rw = 1;\r\nsdkp->device->use_10_for_rw = 0;\r\nreturn 0;\r\nerr:\r\nsdkp->capacity = 0;\r\nreturn ret;\r\n}\r\nvoid sd_zbc_remove(struct scsi_disk *sdkp)\r\n{\r\nkfree(sdkp->zones_wlock);\r\nsdkp->zones_wlock = NULL;\r\n}\r\nvoid sd_zbc_print_zones(struct scsi_disk *sdkp)\r\n{\r\nif (!sd_is_zoned(sdkp) || !sdkp->capacity)\r\nreturn;\r\nif (sdkp->capacity & (sdkp->zone_blocks - 1))\r\nsd_printk(KERN_NOTICE, sdkp,\r\n"%u zones of %u logical blocks + 1 runt zone\n",\r\nsdkp->nr_zones - 1,\r\nsdkp->zone_blocks);\r\nelse\r\nsd_printk(KERN_NOTICE, sdkp,\r\n"%u zones of %u logical blocks\n",\r\nsdkp->nr_zones,\r\nsdkp->zone_blocks);\r\n}
