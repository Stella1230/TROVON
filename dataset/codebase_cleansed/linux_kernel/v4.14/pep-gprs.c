static __be16 gprs_type_trans(struct sk_buff *skb)\r\n{\r\nconst u8 *pvfc;\r\nu8 buf;\r\npvfc = skb_header_pointer(skb, 0, 1, &buf);\r\nif (!pvfc)\r\nreturn htons(0);\r\nswitch (*pvfc >> 4) {\r\ncase 4:\r\nreturn htons(ETH_P_IP);\r\ncase 6:\r\nreturn htons(ETH_P_IPV6);\r\n}\r\nreturn htons(0);\r\n}\r\nstatic void gprs_writeable(struct gprs_dev *gp)\r\n{\r\nstruct net_device *dev = gp->dev;\r\nif (pep_writeable(gp->sk))\r\nnetif_wake_queue(dev);\r\n}\r\nstatic void gprs_state_change(struct sock *sk)\r\n{\r\nstruct gprs_dev *gp = sk->sk_user_data;\r\nif (sk->sk_state == TCP_CLOSE_WAIT) {\r\nstruct net_device *dev = gp->dev;\r\nnetif_stop_queue(dev);\r\nnetif_carrier_off(dev);\r\n}\r\n}\r\nstatic int gprs_recv(struct gprs_dev *gp, struct sk_buff *skb)\r\n{\r\nstruct net_device *dev = gp->dev;\r\nint err = 0;\r\n__be16 protocol = gprs_type_trans(skb);\r\nif (!protocol) {\r\nerr = -EINVAL;\r\ngoto drop;\r\n}\r\nif (skb_headroom(skb) & 3) {\r\nstruct sk_buff *rskb, *fs;\r\nint flen = 0;\r\nrskb = netdev_alloc_skb(dev, 0);\r\nif (!rskb) {\r\nerr = -ENOBUFS;\r\ngoto drop;\r\n}\r\nskb_shinfo(rskb)->frag_list = skb;\r\nrskb->len += skb->len;\r\nrskb->data_len += rskb->len;\r\nrskb->truesize += rskb->len;\r\nskb_walk_frags(skb, fs)\r\nflen += fs->len;\r\nskb->next = skb_shinfo(skb)->frag_list;\r\nskb_frag_list_init(skb);\r\nskb->len -= flen;\r\nskb->data_len -= flen;\r\nskb->truesize -= flen;\r\nskb = rskb;\r\n}\r\nskb->protocol = protocol;\r\nskb_reset_mac_header(skb);\r\nskb->dev = dev;\r\nif (likely(dev->flags & IFF_UP)) {\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += skb->len;\r\nnetif_rx(skb);\r\nskb = NULL;\r\n} else\r\nerr = -ENODEV;\r\ndrop:\r\nif (skb) {\r\ndev_kfree_skb(skb);\r\ndev->stats.rx_dropped++;\r\n}\r\nreturn err;\r\n}\r\nstatic void gprs_data_ready(struct sock *sk)\r\n{\r\nstruct gprs_dev *gp = sk->sk_user_data;\r\nstruct sk_buff *skb;\r\nwhile ((skb = pep_read(sk)) != NULL) {\r\nskb_orphan(skb);\r\ngprs_recv(gp, skb);\r\n}\r\n}\r\nstatic void gprs_write_space(struct sock *sk)\r\n{\r\nstruct gprs_dev *gp = sk->sk_user_data;\r\nif (netif_running(gp->dev))\r\ngprs_writeable(gp);\r\n}\r\nstatic int gprs_open(struct net_device *dev)\r\n{\r\nstruct gprs_dev *gp = netdev_priv(dev);\r\ngprs_writeable(gp);\r\nreturn 0;\r\n}\r\nstatic int gprs_close(struct net_device *dev)\r\n{\r\nnetif_stop_queue(dev);\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t gprs_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct gprs_dev *gp = netdev_priv(dev);\r\nstruct sock *sk = gp->sk;\r\nint len, err;\r\nswitch (skb->protocol) {\r\ncase htons(ETH_P_IP):\r\ncase htons(ETH_P_IPV6):\r\nbreak;\r\ndefault:\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nskb_orphan(skb);\r\nskb_set_owner_w(skb, sk);\r\nlen = skb->len;\r\nerr = pep_write(sk, skb);\r\nif (err) {\r\nnet_dbg_ratelimited("%s: TX error (%d)\n", dev->name, err);\r\ndev->stats.tx_aborted_errors++;\r\ndev->stats.tx_errors++;\r\n} else {\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += len;\r\n}\r\nnetif_stop_queue(dev);\r\nif (pep_writeable(sk))\r\nnetif_wake_queue(dev);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void gprs_setup(struct net_device *dev)\r\n{\r\ndev->features = NETIF_F_FRAGLIST;\r\ndev->type = ARPHRD_PHONET_PIPE;\r\ndev->flags = IFF_POINTOPOINT | IFF_NOARP;\r\ndev->mtu = GPRS_DEFAULT_MTU;\r\ndev->min_mtu = 576;\r\ndev->max_mtu = (PHONET_MAX_MTU - 11);\r\ndev->hard_header_len = 0;\r\ndev->addr_len = 0;\r\ndev->tx_queue_len = 10;\r\ndev->netdev_ops = &gprs_netdev_ops;\r\ndev->needs_free_netdev = true;\r\n}\r\nint gprs_attach(struct sock *sk)\r\n{\r\nstatic const char ifname[] = "gprs%d";\r\nstruct gprs_dev *gp;\r\nstruct net_device *dev;\r\nint err;\r\nif (unlikely(sk->sk_type == SOCK_STREAM))\r\nreturn -EINVAL;\r\ndev = alloc_netdev(sizeof(*gp), ifname, NET_NAME_UNKNOWN, gprs_setup);\r\nif (!dev)\r\nreturn -ENOMEM;\r\ngp = netdev_priv(dev);\r\ngp->sk = sk;\r\ngp->dev = dev;\r\nnetif_stop_queue(dev);\r\nerr = register_netdev(dev);\r\nif (err) {\r\nfree_netdev(dev);\r\nreturn err;\r\n}\r\nlock_sock(sk);\r\nif (unlikely(sk->sk_user_data)) {\r\nerr = -EBUSY;\r\ngoto out_rel;\r\n}\r\nif (unlikely((1 << sk->sk_state & (TCPF_CLOSE|TCPF_LISTEN)) ||\r\nsock_flag(sk, SOCK_DEAD))) {\r\nerr = -EINVAL;\r\ngoto out_rel;\r\n}\r\nsk->sk_user_data = gp;\r\ngp->old_state_change = sk->sk_state_change;\r\ngp->old_data_ready = sk->sk_data_ready;\r\ngp->old_write_space = sk->sk_write_space;\r\nsk->sk_state_change = gprs_state_change;\r\nsk->sk_data_ready = gprs_data_ready;\r\nsk->sk_write_space = gprs_write_space;\r\nrelease_sock(sk);\r\nsock_hold(sk);\r\nprintk(KERN_DEBUG"%s: attached\n", dev->name);\r\nreturn dev->ifindex;\r\nout_rel:\r\nrelease_sock(sk);\r\nunregister_netdev(dev);\r\nreturn err;\r\n}\r\nvoid gprs_detach(struct sock *sk)\r\n{\r\nstruct gprs_dev *gp = sk->sk_user_data;\r\nstruct net_device *dev = gp->dev;\r\nlock_sock(sk);\r\nsk->sk_user_data = NULL;\r\nsk->sk_state_change = gp->old_state_change;\r\nsk->sk_data_ready = gp->old_data_ready;\r\nsk->sk_write_space = gp->old_write_space;\r\nrelease_sock(sk);\r\nprintk(KERN_DEBUG"%s: detached\n", dev->name);\r\nunregister_netdev(dev);\r\nsock_put(sk);\r\n}
