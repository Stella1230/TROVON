static void board_check_revision(void)\r\n{\r\nif (of_machine_is_compatible("nokia,n800"))\r\nboard_caps = NOKIA_N800;\r\nelse if (of_machine_is_compatible("nokia,n810"))\r\nboard_caps = NOKIA_N810;\r\nelse if (of_machine_is_compatible("nokia,n810-wimax"))\r\nboard_caps = NOKIA_N810_WIMAX;\r\nif (!board_caps)\r\npr_err("Unknown board\n");\r\n}\r\nstatic int tusb_set_power(int state)\r\n{\r\nint i, retval = 0;\r\nif (state) {\r\ngpio_set_value(TUSB6010_GPIO_ENABLE, 1);\r\nmsleep(1);\r\ni = 100;\r\nwhile (i && gpio_get_value(TUSB6010_GPIO_INT)) {\r\nmsleep(1);\r\ni--;\r\n}\r\nif (!i) {\r\nprintk(KERN_ERR "tusb: powerup failed\n");\r\nretval = -ENODEV;\r\n}\r\n} else {\r\ngpio_set_value(TUSB6010_GPIO_ENABLE, 0);\r\nmsleep(10);\r\n}\r\nreturn retval;\r\n}\r\nstatic void __init n8x0_usb_init(void)\r\n{\r\nint ret = 0;\r\nstatic const char announce[] __initconst = KERN_INFO "TUSB 6010\n";\r\nret = gpio_request_one(TUSB6010_GPIO_ENABLE, GPIOF_OUT_INIT_LOW,\r\n"TUSB6010 enable");\r\nif (ret != 0) {\r\nprintk(KERN_ERR "Could not get TUSB power GPIO%i\n",\r\nTUSB6010_GPIO_ENABLE);\r\nreturn;\r\n}\r\ntusb_set_power(0);\r\nret = tusb6010_setup_interface(&tusb_data, TUSB6010_REFCLK_19, 2,\r\nTUSB6010_ASYNC_CS, TUSB6010_SYNC_CS,\r\nTUSB6010_GPIO_INT, TUSB6010_DMACHAN);\r\nif (ret != 0)\r\ngoto err;\r\nprintk(announce);\r\nreturn;\r\nerr:\r\ngpio_free(TUSB6010_GPIO_ENABLE);\r\n}\r\nstatic void __init n8x0_usb_init(void) {}\r\nstatic int n8x0_mmc_switch_slot(struct device *dev, int slot)\r\n{\r\n#ifdef CONFIG_MMC_DEBUG\r\ndev_dbg(dev, "Choose slot %d\n", slot + 1);\r\n#endif\r\ngpio_set_value(N8X0_SLOT_SWITCH_GPIO, slot);\r\nreturn 0;\r\n}\r\nstatic int n8x0_mmc_set_power_menelaus(struct device *dev, int slot,\r\nint power_on, int vdd)\r\n{\r\nint mV;\r\n#ifdef CONFIG_MMC_DEBUG\r\ndev_dbg(dev, "Set slot %d power: %s (vdd %d)\n", slot + 1,\r\npower_on ? "on" : "off", vdd);\r\n#endif\r\nif (slot == 0) {\r\nif (!power_on)\r\nreturn menelaus_set_vmmc(0);\r\nswitch (1 << vdd) {\r\ncase MMC_VDD_33_34:\r\ncase MMC_VDD_32_33:\r\ncase MMC_VDD_31_32:\r\nmV = 3100;\r\nbreak;\r\ncase MMC_VDD_30_31:\r\nmV = 3000;\r\nbreak;\r\ncase MMC_VDD_28_29:\r\nmV = 2800;\r\nbreak;\r\ncase MMC_VDD_165_195:\r\nmV = 1850;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nreturn menelaus_set_vmmc(mV);\r\n} else {\r\nif (!power_on)\r\nreturn menelaus_set_vdcdc(3, 0);\r\nswitch (1 << vdd) {\r\ncase MMC_VDD_33_34:\r\ncase MMC_VDD_32_33:\r\nmV = 3300;\r\nbreak;\r\ncase MMC_VDD_30_31:\r\ncase MMC_VDD_29_30:\r\nmV = 3000;\r\nbreak;\r\ncase MMC_VDD_28_29:\r\ncase MMC_VDD_27_28:\r\nmV = 2800;\r\nbreak;\r\ncase MMC_VDD_24_25:\r\ncase MMC_VDD_23_24:\r\nmV = 2400;\r\nbreak;\r\ncase MMC_VDD_22_23:\r\ncase MMC_VDD_21_22:\r\nmV = 2200;\r\nbreak;\r\ncase MMC_VDD_20_21:\r\nmV = 2000;\r\nbreak;\r\ncase MMC_VDD_165_195:\r\nmV = 1800;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nreturn menelaus_set_vdcdc(3, mV);\r\n}\r\nreturn 0;\r\n}\r\nstatic void n810_set_power_emmc(struct device *dev,\r\nint power_on)\r\n{\r\ndev_dbg(dev, "Set EMMC power %s\n", power_on ? "on" : "off");\r\nif (power_on) {\r\ngpio_set_value(N810_EMMC_VSD_GPIO, 1);\r\nmsleep(1);\r\ngpio_set_value(N810_EMMC_VIO_GPIO, 1);\r\nmsleep(1);\r\n} else {\r\ngpio_set_value(N810_EMMC_VIO_GPIO, 0);\r\nmsleep(50);\r\ngpio_set_value(N810_EMMC_VSD_GPIO, 0);\r\nmsleep(50);\r\n}\r\n}\r\nstatic int n8x0_mmc_set_power(struct device *dev, int slot, int power_on,\r\nint vdd)\r\n{\r\nif (board_is_n800() || slot == 0)\r\nreturn n8x0_mmc_set_power_menelaus(dev, slot, power_on, vdd);\r\nn810_set_power_emmc(dev, power_on);\r\nreturn 0;\r\n}\r\nstatic int n8x0_mmc_set_bus_mode(struct device *dev, int slot, int bus_mode)\r\n{\r\nint r;\r\ndev_dbg(dev, "Set slot %d bus mode %s\n", slot + 1,\r\nbus_mode == MMC_BUSMODE_OPENDRAIN ? "open-drain" : "push-pull");\r\nBUG_ON(slot != 0 && slot != 1);\r\nslot++;\r\nswitch (bus_mode) {\r\ncase MMC_BUSMODE_OPENDRAIN:\r\nr = menelaus_set_mmc_opendrain(slot, 1);\r\nbreak;\r\ncase MMC_BUSMODE_PUSHPULL:\r\nr = menelaus_set_mmc_opendrain(slot, 0);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nif (r != 0 && printk_ratelimit())\r\ndev_err(dev, "MMC: unable to set bus mode for slot %d\n",\r\nslot);\r\nreturn r;\r\n}\r\nstatic int n8x0_mmc_get_cover_state(struct device *dev, int slot)\r\n{\r\nslot++;\r\nBUG_ON(slot != 1 && slot != 2);\r\nif (slot == 1)\r\nreturn slot1_cover_open;\r\nelse\r\nreturn slot2_cover_open;\r\n}\r\nstatic void n8x0_mmc_callback(void *data, u8 card_mask)\r\n{\r\nint bit, *openp, index;\r\nif (board_is_n800()) {\r\nbit = 1 << 1;\r\nopenp = &slot2_cover_open;\r\nindex = 1;\r\n} else {\r\nbit = 1;\r\nopenp = &slot1_cover_open;\r\nindex = 0;\r\n}\r\nif (card_mask & bit)\r\n*openp = 1;\r\nelse\r\n*openp = 0;\r\n#ifdef CONFIG_MMC_OMAP\r\nomap_mmc_notify_cover_event(mmc_device, index, *openp);\r\n#else\r\npr_warn("MMC: notify cover event not available\n");\r\n#endif\r\n}\r\nstatic int n8x0_mmc_late_init(struct device *dev)\r\n{\r\nint r, bit, *openp;\r\nint vs2sel;\r\nmmc_device = dev;\r\nr = menelaus_set_slot_sel(1);\r\nif (r < 0)\r\nreturn r;\r\nif (board_is_n800())\r\nvs2sel = 0;\r\nelse\r\nvs2sel = 2;\r\nr = menelaus_set_mmc_slot(2, 0, vs2sel, 1);\r\nif (r < 0)\r\nreturn r;\r\nn8x0_mmc_set_power(dev, 0, MMC_POWER_ON, 16);\r\nn8x0_mmc_set_power(dev, 1, MMC_POWER_ON, 16);\r\nr = menelaus_set_mmc_slot(1, 1, 0, 1);\r\nif (r < 0)\r\nreturn r;\r\nr = menelaus_set_mmc_slot(2, 1, vs2sel, 1);\r\nif (r < 0)\r\nreturn r;\r\nr = menelaus_get_slot_pin_states();\r\nif (r < 0)\r\nreturn r;\r\nif (board_is_n800()) {\r\nbit = 1 << 1;\r\nopenp = &slot2_cover_open;\r\n} else {\r\nbit = 1;\r\nopenp = &slot1_cover_open;\r\nslot2_cover_open = 0;\r\n}\r\nif (r == 0xf || r == (0xf & ~bit))\r\nr = ~r;\r\nif (r & bit)\r\n*openp = 1;\r\nelse\r\n*openp = 0;\r\nr = menelaus_register_mmc_callback(n8x0_mmc_callback, NULL);\r\nreturn r;\r\n}\r\nstatic void n8x0_mmc_shutdown(struct device *dev)\r\n{\r\nint vs2sel;\r\nif (board_is_n800())\r\nvs2sel = 0;\r\nelse\r\nvs2sel = 2;\r\nmenelaus_set_mmc_slot(1, 0, 0, 0);\r\nmenelaus_set_mmc_slot(2, 0, vs2sel, 0);\r\n}\r\nstatic void n8x0_mmc_cleanup(struct device *dev)\r\n{\r\nmenelaus_unregister_mmc_callback();\r\ngpio_free(N8X0_SLOT_SWITCH_GPIO);\r\nif (board_is_n810()) {\r\ngpio_free(N810_EMMC_VSD_GPIO);\r\ngpio_free(N810_EMMC_VIO_GPIO);\r\n}\r\n}\r\nstatic void __init n8x0_mmc_init(void)\r\n{\r\nint err;\r\nif (board_is_n810()) {\r\nmmc1_data.slots[0].name = "external";\r\nmmc1_data.slots[1].name = "internal";\r\nmmc1_data.slots[1].ban_openended = 1;\r\n}\r\nerr = gpio_request_one(N8X0_SLOT_SWITCH_GPIO, GPIOF_OUT_INIT_LOW,\r\n"MMC slot switch");\r\nif (err)\r\nreturn;\r\nif (board_is_n810()) {\r\nerr = gpio_request_array(n810_emmc_gpios,\r\nARRAY_SIZE(n810_emmc_gpios));\r\nif (err) {\r\ngpio_free(N8X0_SLOT_SWITCH_GPIO);\r\nreturn;\r\n}\r\n}\r\nmmc1_data.nr_slots = 2;\r\nmmc_data[0] = &mmc1_data;\r\n}\r\nvoid __init n8x0_mmc_init(void)\r\n{\r\n}\r\nstatic int n8x0_auto_sleep_regulators(void)\r\n{\r\nu32 val;\r\nint ret;\r\nval = EN_VPLL_SLEEP | EN_VMMC_SLEEP \\r\n| EN_VAUX_SLEEP | EN_VIO_SLEEP \\r\n| EN_VMEM_SLEEP | EN_DC3_SLEEP \\r\n| EN_VC_SLEEP | EN_DC2_SLEEP;\r\nret = menelaus_set_regulator_sleep(1, val);\r\nif (ret < 0) {\r\npr_err("Could not set regulators to sleep on menelaus: %u\n",\r\nret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int n8x0_auto_voltage_scale(void)\r\n{\r\nint ret;\r\nret = menelaus_set_vcore_hw(1400, 1050);\r\nif (ret < 0) {\r\npr_err("Could not set VCORE voltage on menelaus: %u\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int n8x0_menelaus_late_init(struct device *dev)\r\n{\r\nint ret;\r\nret = n8x0_auto_voltage_scale();\r\nif (ret < 0)\r\nreturn ret;\r\nret = n8x0_auto_sleep_regulators();\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int n8x0_menelaus_late_init(struct device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __init n8x0_late_initcall(void)\r\n{\r\nif (!board_caps)\r\nreturn -ENODEV;\r\nn8x0_mmc_init();\r\nn8x0_usb_init();\r\nreturn 0;\r\n}\r\nvoid * __init n8x0_legacy_init(void)\r\n{\r\nboard_check_revision();\r\nspi_register_board_info(n800_spi_board_info,\r\nARRAY_SIZE(n800_spi_board_info));\r\nreturn &mmc1_data;\r\n}
