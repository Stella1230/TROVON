int get_gadget_descs(struct vudc *udc)\r\n{\r\nstruct vrequest *usb_req;\r\nstruct vep *ep0 = to_vep(udc->gadget.ep0);\r\nstruct usb_device_descriptor *ddesc = &udc->dev_desc;\r\nstruct usb_ctrlrequest req;\r\nint ret;\r\nif (!udc->driver || !udc->pullup)\r\nreturn -EINVAL;\r\nreq.bRequestType = USB_DIR_IN | USB_TYPE_STANDARD | USB_RECIP_DEVICE;\r\nreq.bRequest = USB_REQ_GET_DESCRIPTOR;\r\nreq.wValue = cpu_to_le16(USB_DT_DEVICE << 8);\r\nreq.wIndex = cpu_to_le16(0);\r\nreq.wLength = cpu_to_le16(sizeof(*ddesc));\r\nspin_unlock(&udc->lock);\r\nret = udc->driver->setup(&(udc->gadget), &req);\r\nspin_lock(&udc->lock);\r\nif (ret < 0)\r\ngoto out;\r\nusb_req = list_last_entry(&ep0->req_queue, struct vrequest, req_entry);\r\nlist_del(&usb_req->req_entry);\r\nif (usb_req->req.length > sizeof(*ddesc)) {\r\nret = -EOVERFLOW;\r\ngoto giveback_req;\r\n}\r\nmemcpy(ddesc, usb_req->req.buf, sizeof(*ddesc));\r\nudc->desc_cached = 1;\r\nret = 0;\r\ngiveback_req:\r\nusb_req->req.status = 0;\r\nusb_req->req.actual = usb_req->req.length;\r\nusb_gadget_giveback_request(&(ep0->ep), &(usb_req->req));\r\nout:\r\nreturn ret;\r\n}\r\nstatic ssize_t dev_desc_read(struct file *file, struct kobject *kobj,\r\nstruct bin_attribute *attr, char *out,\r\nloff_t off, size_t count)\r\n{\r\nstruct device *dev = kobj_to_dev(kobj);\r\nstruct vudc *udc = (struct vudc *)dev_get_drvdata(dev);\r\nchar *desc_ptr = (char *) &udc->dev_desc;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nif (!udc->desc_cached) {\r\nret = -ENODEV;\r\ngoto unlock;\r\n}\r\nmemcpy(out, desc_ptr + off, count);\r\nret = count;\r\nunlock:\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn ret;\r\n}\r\nstatic ssize_t store_sockfd(struct device *dev, struct device_attribute *attr,\r\nconst char *in, size_t count)\r\n{\r\nstruct vudc *udc = (struct vudc *) dev_get_drvdata(dev);\r\nint rv;\r\nint sockfd = 0;\r\nint err;\r\nstruct socket *socket;\r\nunsigned long flags;\r\nint ret;\r\nrv = kstrtoint(in, 0, &sockfd);\r\nif (rv != 0)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nif (!udc || !udc->driver || !udc->pullup) {\r\ndev_err(dev, "no device or gadget not bound");\r\nret = -ENODEV;\r\ngoto unlock;\r\n}\r\nif (sockfd != -1) {\r\nif (udc->connected) {\r\ndev_err(dev, "Device already connected");\r\nret = -EBUSY;\r\ngoto unlock;\r\n}\r\nspin_lock_irq(&udc->ud.lock);\r\nif (udc->ud.status != SDEV_ST_AVAILABLE) {\r\nret = -EINVAL;\r\ngoto unlock_ud;\r\n}\r\nsocket = sockfd_lookup(sockfd, &err);\r\nif (!socket) {\r\ndev_err(dev, "failed to lookup sock");\r\nret = -EINVAL;\r\ngoto unlock_ud;\r\n}\r\nudc->ud.tcp_socket = socket;\r\nspin_unlock_irq(&udc->ud.lock);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nudc->ud.tcp_rx = kthread_get_run(&v_rx_loop,\r\n&udc->ud, "vudc_rx");\r\nudc->ud.tcp_tx = kthread_get_run(&v_tx_loop,\r\n&udc->ud, "vudc_tx");\r\nspin_lock_irqsave(&udc->lock, flags);\r\nspin_lock_irq(&udc->ud.lock);\r\nudc->ud.status = SDEV_ST_USED;\r\nspin_unlock_irq(&udc->ud.lock);\r\ndo_gettimeofday(&udc->start_time);\r\nv_start_timer(udc);\r\nudc->connected = 1;\r\n} else {\r\nif (!udc->connected) {\r\ndev_err(dev, "Device not connected");\r\nret = -EINVAL;\r\ngoto unlock;\r\n}\r\nspin_lock_irq(&udc->ud.lock);\r\nif (udc->ud.status != SDEV_ST_USED) {\r\nret = -EINVAL;\r\ngoto unlock_ud;\r\n}\r\nspin_unlock_irq(&udc->ud.lock);\r\nusbip_event_add(&udc->ud, VUDC_EVENT_DOWN);\r\n}\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn count;\r\nunlock_ud:\r\nspin_unlock_irq(&udc->ud.lock);\r\nunlock:\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn ret;\r\n}\r\nstatic ssize_t usbip_status_show(struct device *dev,\r\nstruct device_attribute *attr, char *out)\r\n{\r\nstruct vudc *udc = (struct vudc *) dev_get_drvdata(dev);\r\nint status;\r\nif (!udc) {\r\ndev_err(dev, "no device");\r\nreturn -ENODEV;\r\n}\r\nspin_lock_irq(&udc->ud.lock);\r\nstatus = udc->ud.status;\r\nspin_unlock_irq(&udc->ud.lock);\r\nreturn snprintf(out, PAGE_SIZE, "%d\n", status);\r\n}
