static int brcmf_pno_store_request(struct brcmf_pno_info *pi,\r\nstruct cfg80211_sched_scan_request *req)\r\n{\r\nif (WARN(pi->n_reqs == BRCMF_PNO_MAX_BUCKETS,\r\n"pno request storage full\n"))\r\nreturn -ENOSPC;\r\nbrcmf_dbg(SCAN, "reqid=%llu\n", req->reqid);\r\nmutex_lock(&pi->req_lock);\r\npi->reqs[pi->n_reqs++] = req;\r\nmutex_unlock(&pi->req_lock);\r\nreturn 0;\r\n}\r\nstatic int brcmf_pno_remove_request(struct brcmf_pno_info *pi, u64 reqid)\r\n{\r\nint i, err = 0;\r\nmutex_lock(&pi->req_lock);\r\nfor (i = 0; i < pi->n_reqs; i++) {\r\nif (pi->reqs[i]->reqid == reqid)\r\nbreak;\r\n}\r\nif (WARN(i == pi->n_reqs, "reqid not found\n")) {\r\nerr = -ENOENT;\r\ngoto done;\r\n}\r\nbrcmf_dbg(SCAN, "reqid=%llu\n", reqid);\r\npi->n_reqs--;\r\nif (!pi->n_reqs || i == pi->n_reqs)\r\ngoto done;\r\nwhile (i <= pi->n_reqs - 1) {\r\npi->reqs[i] = pi->reqs[i + 1];\r\ni++;\r\n}\r\ndone:\r\nmutex_unlock(&pi->req_lock);\r\nreturn err;\r\n}\r\nstatic int brcmf_pno_channel_config(struct brcmf_if *ifp,\r\nstruct brcmf_pno_config_le *cfg)\r\n{\r\ncfg->reporttype = 0;\r\ncfg->flags = 0;\r\nreturn brcmf_fil_iovar_data_set(ifp, "pfn_cfg", cfg, sizeof(*cfg));\r\n}\r\nstatic int brcmf_pno_config(struct brcmf_if *ifp, u32 scan_freq,\r\nu32 mscan, u32 bestn)\r\n{\r\nstruct brcmf_pno_param_le pfn_param;\r\nu16 flags;\r\nu32 pfnmem;\r\ns32 err;\r\nmemset(&pfn_param, 0, sizeof(pfn_param));\r\npfn_param.version = cpu_to_le32(BRCMF_PNO_VERSION);\r\nflags = BIT(BRCMF_PNO_IMMEDIATE_SCAN_BIT) |\r\nBIT(BRCMF_PNO_ENABLE_ADAPTSCAN_BIT);\r\npfn_param.repeat = BRCMF_PNO_REPEAT;\r\npfn_param.exp = BRCMF_PNO_FREQ_EXPO_MAX;\r\npfn_param.scan_freq = cpu_to_le32(scan_freq);\r\nif (mscan) {\r\npfnmem = bestn;\r\nerr = brcmf_fil_iovar_int_set(ifp, "pfnmem", pfnmem);\r\nif (err < 0) {\r\nbrcmf_err("failed to set pfnmem\n");\r\ngoto exit;\r\n}\r\nerr = brcmf_fil_iovar_int_get(ifp, "pfnmem", &pfnmem);\r\nif (err < 0) {\r\nbrcmf_err("failed to get pfnmem\n");\r\ngoto exit;\r\n}\r\nmscan = min_t(u32, mscan, pfnmem);\r\npfn_param.mscan = mscan;\r\npfn_param.bestn = bestn;\r\nflags |= BIT(BRCMF_PNO_ENABLE_BD_SCAN_BIT);\r\nbrcmf_dbg(INFO, "mscan=%d, bestn=%d\n", mscan, bestn);\r\n}\r\npfn_param.flags = cpu_to_le16(flags);\r\nerr = brcmf_fil_iovar_data_set(ifp, "pfn_set", &pfn_param,\r\nsizeof(pfn_param));\r\nif (err)\r\nbrcmf_err("pfn_set failed, err=%d\n", err);\r\nexit:\r\nreturn err;\r\n}\r\nstatic int brcmf_pno_set_random(struct brcmf_if *ifp, struct brcmf_pno_info *pi)\r\n{\r\nstruct brcmf_pno_macaddr_le pfn_mac;\r\nu8 *mac_addr = NULL;\r\nu8 *mac_mask = NULL;\r\nint err, i;\r\nfor (i = 0; i < pi->n_reqs; i++)\r\nif (pi->reqs[i]->flags & NL80211_SCAN_FLAG_RANDOM_ADDR) {\r\nmac_addr = pi->reqs[i]->mac_addr;\r\nmac_mask = pi->reqs[i]->mac_addr_mask;\r\nbreak;\r\n}\r\nif (!mac_addr)\r\nreturn 0;\r\npfn_mac.version = BRCMF_PFN_MACADDR_CFG_VER;\r\npfn_mac.flags = BRCMF_PFN_MAC_OUI_ONLY | BRCMF_PFN_SET_MAC_UNASSOC;\r\nmemcpy(pfn_mac.mac, mac_addr, ETH_ALEN);\r\nfor (i = 0; i < ETH_ALEN; i++) {\r\npfn_mac.mac[i] &= mac_mask[i];\r\npfn_mac.mac[i] |= get_random_int() & ~(mac_mask[i]);\r\n}\r\npfn_mac.mac[0] &= 0xFE;\r\npfn_mac.mac[0] |= 0x02;\r\nbrcmf_dbg(SCAN, "enabling random mac: reqid=%llu mac=%pM\n",\r\npi->reqs[i]->reqid, pfn_mac.mac);\r\nerr = brcmf_fil_iovar_data_set(ifp, "pfn_macaddr", &pfn_mac,\r\nsizeof(pfn_mac));\r\nif (err)\r\nbrcmf_err("pfn_macaddr failed, err=%d\n", err);\r\nreturn err;\r\n}\r\nstatic int brcmf_pno_add_ssid(struct brcmf_if *ifp, struct cfg80211_ssid *ssid,\r\nbool active)\r\n{\r\nstruct brcmf_pno_net_param_le pfn;\r\nint err;\r\npfn.auth = cpu_to_le32(WLAN_AUTH_OPEN);\r\npfn.wpa_auth = cpu_to_le32(BRCMF_PNO_WPA_AUTH_ANY);\r\npfn.wsec = cpu_to_le32(0);\r\npfn.infra = cpu_to_le32(1);\r\npfn.flags = 0;\r\nif (active)\r\npfn.flags = cpu_to_le32(1 << BRCMF_PNO_HIDDEN_BIT);\r\npfn.ssid.SSID_len = cpu_to_le32(ssid->ssid_len);\r\nmemcpy(pfn.ssid.SSID, ssid->ssid, ssid->ssid_len);\r\nbrcmf_dbg(SCAN, "adding ssid=%.32s (active=%d)\n", ssid->ssid, active);\r\nerr = brcmf_fil_iovar_data_set(ifp, "pfn_add", &pfn, sizeof(pfn));\r\nif (err < 0)\r\nbrcmf_err("adding failed: err=%d\n", err);\r\nreturn err;\r\n}\r\nstatic int brcmf_pno_add_bssid(struct brcmf_if *ifp, const u8 *bssid)\r\n{\r\nstruct brcmf_pno_bssid_le bssid_cfg;\r\nint err;\r\nmemcpy(bssid_cfg.bssid, bssid, ETH_ALEN);\r\nbssid_cfg.flags = 0;\r\nbrcmf_dbg(SCAN, "adding bssid=%pM\n", bssid);\r\nerr = brcmf_fil_iovar_data_set(ifp, "pfn_add_bssid", &bssid_cfg,\r\nsizeof(bssid_cfg));\r\nif (err < 0)\r\nbrcmf_err("adding failed: err=%d\n", err);\r\nreturn err;\r\n}\r\nstatic bool brcmf_is_ssid_active(struct cfg80211_ssid *ssid,\r\nstruct cfg80211_sched_scan_request *req)\r\n{\r\nint i;\r\nif (!ssid || !req->ssids || !req->n_ssids)\r\nreturn false;\r\nfor (i = 0; i < req->n_ssids; i++) {\r\nif (ssid->ssid_len == req->ssids[i].ssid_len) {\r\nif (!strncmp(ssid->ssid, req->ssids[i].ssid,\r\nssid->ssid_len))\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic int brcmf_pno_clean(struct brcmf_if *ifp)\r\n{\r\nint ret;\r\nret = brcmf_fil_iovar_int_set(ifp, "pfn", 0);\r\nif (ret == 0) {\r\nret = brcmf_fil_iovar_data_set(ifp, "pfnclear", NULL, 0);\r\n}\r\nif (ret < 0)\r\nbrcmf_err("failed code %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int brcmf_pno_get_bucket_channels(struct cfg80211_sched_scan_request *r,\r\nstruct brcmf_pno_config_le *pno_cfg)\r\n{\r\nu32 n_chan = le32_to_cpu(pno_cfg->channel_num);\r\nu16 chan;\r\nint i, err = 0;\r\nfor (i = 0; i < r->n_channels; i++) {\r\nif (n_chan >= BRCMF_NUMCHANNELS) {\r\nerr = -ENOSPC;\r\ngoto done;\r\n}\r\nchan = r->channels[i]->hw_value;\r\nbrcmf_dbg(SCAN, "[%d] Chan : %u\n", n_chan, chan);\r\npno_cfg->channel_list[n_chan++] = cpu_to_le16(chan);\r\n}\r\nerr = n_chan;\r\ndone:\r\npno_cfg->channel_num = cpu_to_le32(n_chan);\r\nreturn err;\r\n}\r\nstatic int brcmf_pno_prep_fwconfig(struct brcmf_pno_info *pi,\r\nstruct brcmf_pno_config_le *pno_cfg,\r\nstruct brcmf_gscan_bucket_config **buckets,\r\nu32 *scan_freq)\r\n{\r\nstruct cfg80211_sched_scan_request *sr;\r\nstruct brcmf_gscan_bucket_config *fw_buckets;\r\nint i, err, chidx;\r\nbrcmf_dbg(SCAN, "n_reqs=%d\n", pi->n_reqs);\r\nif (WARN_ON(!pi->n_reqs))\r\nreturn -ENODATA;\r\n*scan_freq = pi->reqs[0]->scan_plans[0].interval;\r\nfor (i = 1; i < pi->n_reqs; i++) {\r\nsr = pi->reqs[i];\r\n*scan_freq = gcd(sr->scan_plans[0].interval, *scan_freq);\r\n}\r\nif (*scan_freq < BRCMF_PNO_SCHED_SCAN_MIN_PERIOD) {\r\nbrcmf_dbg(SCAN, "scan period too small, using minimum\n");\r\n*scan_freq = BRCMF_PNO_SCHED_SCAN_MIN_PERIOD;\r\n}\r\n*buckets = NULL;\r\nfw_buckets = kcalloc(pi->n_reqs, sizeof(*fw_buckets), GFP_KERNEL);\r\nif (!fw_buckets)\r\nreturn -ENOMEM;\r\nmemset(pno_cfg, 0, sizeof(*pno_cfg));\r\nfor (i = 0; i < pi->n_reqs; i++) {\r\nsr = pi->reqs[i];\r\nchidx = brcmf_pno_get_bucket_channels(sr, pno_cfg);\r\nif (chidx < 0) {\r\nerr = chidx;\r\ngoto fail;\r\n}\r\nfw_buckets[i].bucket_end_index = chidx - 1;\r\nfw_buckets[i].bucket_freq_multiple =\r\nsr->scan_plans[0].interval / *scan_freq;\r\nif (!fw_buckets[i].bucket_freq_multiple)\r\nfw_buckets[i].bucket_freq_multiple = 1;\r\nfw_buckets[i].flag = BRCMF_PNO_REPORT_NO_BATCH;\r\n}\r\nif (BRCMF_SCAN_ON()) {\r\nbrcmf_err("base period=%u\n", *scan_freq);\r\nfor (i = 0; i < pi->n_reqs; i++) {\r\nbrcmf_err("[%d] period %u max %u repeat %u flag %x idx %u\n",\r\ni, fw_buckets[i].bucket_freq_multiple,\r\nle16_to_cpu(fw_buckets[i].max_freq_multiple),\r\nfw_buckets[i].repeat, fw_buckets[i].flag,\r\nfw_buckets[i].bucket_end_index);\r\n}\r\n}\r\n*buckets = fw_buckets;\r\nreturn pi->n_reqs;\r\nfail:\r\nkfree(fw_buckets);\r\nreturn err;\r\n}\r\nstatic int brcmf_pno_config_networks(struct brcmf_if *ifp,\r\nstruct brcmf_pno_info *pi)\r\n{\r\nstruct cfg80211_sched_scan_request *r;\r\nstruct cfg80211_match_set *ms;\r\nbool active;\r\nint i, j, err = 0;\r\nfor (i = 0; i < pi->n_reqs; i++) {\r\nr = pi->reqs[i];\r\nfor (j = 0; j < r->n_match_sets; j++) {\r\nms = &r->match_sets[j];\r\nif (ms->ssid.ssid_len) {\r\nactive = brcmf_is_ssid_active(&ms->ssid, r);\r\nerr = brcmf_pno_add_ssid(ifp, &ms->ssid,\r\nactive);\r\n}\r\nif (!err && is_valid_ether_addr(ms->bssid))\r\nerr = brcmf_pno_add_bssid(ifp, ms->bssid);\r\nif (err < 0)\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int brcmf_pno_config_sched_scans(struct brcmf_if *ifp)\r\n{\r\nstruct brcmf_pno_info *pi;\r\nstruct brcmf_gscan_config *gscan_cfg;\r\nstruct brcmf_gscan_bucket_config *buckets;\r\nstruct brcmf_pno_config_le pno_cfg;\r\nsize_t gsz;\r\nu32 scan_freq;\r\nint err, n_buckets;\r\npi = ifp_to_pno(ifp);\r\nn_buckets = brcmf_pno_prep_fwconfig(pi, &pno_cfg, &buckets,\r\n&scan_freq);\r\nif (n_buckets < 0)\r\nreturn n_buckets;\r\ngsz = sizeof(*gscan_cfg) + (n_buckets - 1) * sizeof(*buckets);\r\ngscan_cfg = kzalloc(gsz, GFP_KERNEL);\r\nif (!gscan_cfg) {\r\nerr = -ENOMEM;\r\ngoto free_buckets;\r\n}\r\nerr = brcmf_pno_clean(ifp);\r\nif (err < 0) {\r\nbrcmf_err("failed error=%d\n", err);\r\ngoto free_gscan;\r\n}\r\nerr = brcmf_pno_config(ifp, scan_freq, 0, 0);\r\nif (err < 0)\r\ngoto free_gscan;\r\nerr = brcmf_pno_channel_config(ifp, &pno_cfg);\r\nif (err < 0)\r\ngoto clean;\r\ngscan_cfg->version = cpu_to_le16(BRCMF_GSCAN_CFG_VERSION);\r\ngscan_cfg->retry_threshold = GSCAN_RETRY_THRESHOLD;\r\ngscan_cfg->buffer_threshold = GSCAN_BATCH_NO_THR_SET;\r\ngscan_cfg->flags = BRCMF_GSCAN_CFG_ALL_BUCKETS_IN_1ST_SCAN;\r\ngscan_cfg->count_of_channel_buckets = n_buckets;\r\nmemcpy(&gscan_cfg->bucket[0], buckets,\r\nn_buckets * sizeof(*buckets));\r\nerr = brcmf_fil_iovar_data_set(ifp, "pfn_gscan_cfg", gscan_cfg, gsz);\r\nif (err < 0)\r\ngoto clean;\r\nerr = brcmf_pno_set_random(ifp, pi);\r\nif (err < 0)\r\ngoto clean;\r\nerr = brcmf_pno_config_networks(ifp, pi);\r\nif (err < 0)\r\ngoto clean;\r\nerr = brcmf_fil_iovar_int_set(ifp, "pfn", 1);\r\nclean:\r\nif (err < 0)\r\nbrcmf_pno_clean(ifp);\r\nfree_gscan:\r\nkfree(gscan_cfg);\r\nfree_buckets:\r\nkfree(buckets);\r\nreturn err;\r\n}\r\nint brcmf_pno_start_sched_scan(struct brcmf_if *ifp,\r\nstruct cfg80211_sched_scan_request *req)\r\n{\r\nstruct brcmf_pno_info *pi;\r\nint ret;\r\nbrcmf_dbg(TRACE, "reqid=%llu\n", req->reqid);\r\npi = ifp_to_pno(ifp);\r\nret = brcmf_pno_store_request(pi, req);\r\nif (ret < 0)\r\nreturn ret;\r\nret = brcmf_pno_config_sched_scans(ifp);\r\nif (ret < 0) {\r\nbrcmf_pno_remove_request(pi, req->reqid);\r\nif (pi->n_reqs)\r\n(void)brcmf_pno_config_sched_scans(ifp);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint brcmf_pno_stop_sched_scan(struct brcmf_if *ifp, u64 reqid)\r\n{\r\nstruct brcmf_pno_info *pi;\r\nint err;\r\nbrcmf_dbg(TRACE, "reqid=%llu\n", reqid);\r\npi = ifp_to_pno(ifp);\r\nerr = brcmf_pno_remove_request(pi, reqid);\r\nif (err)\r\nreturn err;\r\nbrcmf_pno_clean(ifp);\r\nif (pi->n_reqs)\r\n(void)brcmf_pno_config_sched_scans(ifp);\r\nreturn 0;\r\n}\r\nint brcmf_pno_attach(struct brcmf_cfg80211_info *cfg)\r\n{\r\nstruct brcmf_pno_info *pi;\r\nbrcmf_dbg(TRACE, "enter\n");\r\npi = kzalloc(sizeof(*pi), GFP_KERNEL);\r\nif (!pi)\r\nreturn -ENOMEM;\r\ncfg->pno = pi;\r\nmutex_init(&pi->req_lock);\r\nreturn 0;\r\n}\r\nvoid brcmf_pno_detach(struct brcmf_cfg80211_info *cfg)\r\n{\r\nstruct brcmf_pno_info *pi;\r\nbrcmf_dbg(TRACE, "enter\n");\r\npi = cfg->pno;\r\ncfg->pno = NULL;\r\nWARN_ON(pi->n_reqs);\r\nmutex_destroy(&pi->req_lock);\r\nkfree(pi);\r\n}\r\nvoid brcmf_pno_wiphy_params(struct wiphy *wiphy, bool gscan)\r\n{\r\nwiphy->max_sched_scan_reqs = gscan ? BRCMF_PNO_MAX_BUCKETS : 1;\r\nwiphy->max_sched_scan_ssids = BRCMF_PNO_MAX_PFN_COUNT;\r\nwiphy->max_match_sets = BRCMF_PNO_MAX_PFN_COUNT;\r\nwiphy->max_sched_scan_ie_len = BRCMF_SCAN_IE_LEN_MAX;\r\nwiphy->max_sched_scan_plan_interval = BRCMF_PNO_SCHED_SCAN_MAX_PERIOD;\r\n}\r\nu64 brcmf_pno_find_reqid_by_bucket(struct brcmf_pno_info *pi, u32 bucket)\r\n{\r\nu64 reqid = 0;\r\nmutex_lock(&pi->req_lock);\r\nif (bucket < pi->n_reqs)\r\nreqid = pi->reqs[bucket]->reqid;\r\nmutex_unlock(&pi->req_lock);\r\nreturn reqid;\r\n}\r\nu32 brcmf_pno_get_bucket_map(struct brcmf_pno_info *pi,\r\nstruct brcmf_pno_net_info_le *ni)\r\n{\r\nstruct cfg80211_sched_scan_request *req;\r\nstruct cfg80211_match_set *ms;\r\nu32 bucket_map = 0;\r\nint i, j;\r\nmutex_lock(&pi->req_lock);\r\nfor (i = 0; i < pi->n_reqs; i++) {\r\nreq = pi->reqs[i];\r\nif (!req->n_match_sets)\r\ncontinue;\r\nfor (j = 0; j < req->n_match_sets; j++) {\r\nms = &req->match_sets[j];\r\nif (ms->ssid.ssid_len == ni->SSID_len &&\r\n!memcmp(ms->ssid.ssid, ni->SSID, ni->SSID_len)) {\r\nbucket_map |= BIT(i);\r\nbreak;\r\n}\r\nif (is_valid_ether_addr(ms->bssid) &&\r\n!memcmp(ms->bssid, ni->bssid, ETH_ALEN)) {\r\nbucket_map |= BIT(i);\r\nbreak;\r\n}\r\n}\r\n}\r\nmutex_unlock(&pi->req_lock);\r\nreturn bucket_map;\r\n}
