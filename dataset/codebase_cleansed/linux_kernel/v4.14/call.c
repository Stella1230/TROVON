static void optee_cq_wait_init(struct optee_call_queue *cq,\r\nstruct optee_call_waiter *w)\r\n{\r\nmutex_lock(&cq->mutex);\r\ninit_completion(&w->c);\r\nlist_add_tail(&w->list_node, &cq->waiters);\r\nmutex_unlock(&cq->mutex);\r\n}\r\nstatic void optee_cq_wait_for_completion(struct optee_call_queue *cq,\r\nstruct optee_call_waiter *w)\r\n{\r\nwait_for_completion(&w->c);\r\nmutex_lock(&cq->mutex);\r\nlist_del(&w->list_node);\r\nreinit_completion(&w->c);\r\nlist_add_tail(&w->list_node, &cq->waiters);\r\nmutex_unlock(&cq->mutex);\r\n}\r\nstatic void optee_cq_complete_one(struct optee_call_queue *cq)\r\n{\r\nstruct optee_call_waiter *w;\r\nlist_for_each_entry(w, &cq->waiters, list_node) {\r\nif (!completion_done(&w->c)) {\r\ncomplete(&w->c);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void optee_cq_wait_final(struct optee_call_queue *cq,\r\nstruct optee_call_waiter *w)\r\n{\r\nmutex_lock(&cq->mutex);\r\nlist_del(&w->list_node);\r\noptee_cq_complete_one(cq);\r\nif (completion_done(&w->c))\r\noptee_cq_complete_one(cq);\r\nmutex_unlock(&cq->mutex);\r\n}\r\nstatic struct optee_session *find_session(struct optee_context_data *ctxdata,\r\nu32 session_id)\r\n{\r\nstruct optee_session *sess;\r\nlist_for_each_entry(sess, &ctxdata->sess_list, list_node)\r\nif (sess->session_id == session_id)\r\nreturn sess;\r\nreturn NULL;\r\n}\r\nu32 optee_do_call_with_arg(struct tee_context *ctx, phys_addr_t parg)\r\n{\r\nstruct optee *optee = tee_get_drvdata(ctx->teedev);\r\nstruct optee_call_waiter w;\r\nstruct optee_rpc_param param = { };\r\nu32 ret;\r\nparam.a0 = OPTEE_SMC_CALL_WITH_ARG;\r\nreg_pair_from_64(&param.a1, &param.a2, parg);\r\noptee_cq_wait_init(&optee->call_queue, &w);\r\nwhile (true) {\r\nstruct arm_smccc_res res;\r\noptee->invoke_fn(param.a0, param.a1, param.a2, param.a3,\r\nparam.a4, param.a5, param.a6, param.a7,\r\n&res);\r\nif (res.a0 == OPTEE_SMC_RETURN_ETHREAD_LIMIT) {\r\noptee_cq_wait_for_completion(&optee->call_queue, &w);\r\n} else if (OPTEE_SMC_RETURN_IS_RPC(res.a0)) {\r\nparam.a0 = res.a0;\r\nparam.a1 = res.a1;\r\nparam.a2 = res.a2;\r\nparam.a3 = res.a3;\r\noptee_handle_rpc(ctx, &param);\r\n} else {\r\nret = res.a0;\r\nbreak;\r\n}\r\n}\r\noptee_cq_wait_final(&optee->call_queue, &w);\r\nreturn ret;\r\n}\r\nstatic struct tee_shm *get_msg_arg(struct tee_context *ctx, size_t num_params,\r\nstruct optee_msg_arg **msg_arg,\r\nphys_addr_t *msg_parg)\r\n{\r\nint rc;\r\nstruct tee_shm *shm;\r\nstruct optee_msg_arg *ma;\r\nshm = tee_shm_alloc(ctx, OPTEE_MSG_GET_ARG_SIZE(num_params),\r\nTEE_SHM_MAPPED);\r\nif (IS_ERR(shm))\r\nreturn shm;\r\nma = tee_shm_get_va(shm, 0);\r\nif (IS_ERR(ma)) {\r\nrc = PTR_ERR(ma);\r\ngoto out;\r\n}\r\nrc = tee_shm_get_pa(shm, 0, msg_parg);\r\nif (rc)\r\ngoto out;\r\nmemset(ma, 0, OPTEE_MSG_GET_ARG_SIZE(num_params));\r\nma->num_params = num_params;\r\n*msg_arg = ma;\r\nout:\r\nif (rc) {\r\ntee_shm_free(shm);\r\nreturn ERR_PTR(rc);\r\n}\r\nreturn shm;\r\n}\r\nint optee_open_session(struct tee_context *ctx,\r\nstruct tee_ioctl_open_session_arg *arg,\r\nstruct tee_param *param)\r\n{\r\nstruct optee_context_data *ctxdata = ctx->data;\r\nint rc;\r\nstruct tee_shm *shm;\r\nstruct optee_msg_arg *msg_arg;\r\nphys_addr_t msg_parg;\r\nstruct optee_session *sess = NULL;\r\nshm = get_msg_arg(ctx, arg->num_params + 2, &msg_arg, &msg_parg);\r\nif (IS_ERR(shm))\r\nreturn PTR_ERR(shm);\r\nmsg_arg->cmd = OPTEE_MSG_CMD_OPEN_SESSION;\r\nmsg_arg->cancel_id = arg->cancel_id;\r\nmsg_arg->params[0].attr = OPTEE_MSG_ATTR_TYPE_VALUE_INPUT |\r\nOPTEE_MSG_ATTR_META;\r\nmsg_arg->params[1].attr = OPTEE_MSG_ATTR_TYPE_VALUE_INPUT |\r\nOPTEE_MSG_ATTR_META;\r\nmemcpy(&msg_arg->params[0].u.value, arg->uuid, sizeof(arg->uuid));\r\nmemcpy(&msg_arg->params[1].u.value, arg->uuid, sizeof(arg->clnt_uuid));\r\nmsg_arg->params[1].u.value.c = arg->clnt_login;\r\nrc = optee_to_msg_param(msg_arg->params + 2, arg->num_params, param);\r\nif (rc)\r\ngoto out;\r\nsess = kzalloc(sizeof(*sess), GFP_KERNEL);\r\nif (!sess) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nif (optee_do_call_with_arg(ctx, msg_parg)) {\r\nmsg_arg->ret = TEEC_ERROR_COMMUNICATION;\r\nmsg_arg->ret_origin = TEEC_ORIGIN_COMMS;\r\n}\r\nif (msg_arg->ret == TEEC_SUCCESS) {\r\nsess->session_id = msg_arg->session;\r\nmutex_lock(&ctxdata->mutex);\r\nlist_add(&sess->list_node, &ctxdata->sess_list);\r\nmutex_unlock(&ctxdata->mutex);\r\n} else {\r\nkfree(sess);\r\n}\r\nif (optee_from_msg_param(param, arg->num_params, msg_arg->params + 2)) {\r\narg->ret = TEEC_ERROR_COMMUNICATION;\r\narg->ret_origin = TEEC_ORIGIN_COMMS;\r\noptee_close_session(ctx, msg_arg->session);\r\n} else {\r\narg->session = msg_arg->session;\r\narg->ret = msg_arg->ret;\r\narg->ret_origin = msg_arg->ret_origin;\r\n}\r\nout:\r\ntee_shm_free(shm);\r\nreturn rc;\r\n}\r\nint optee_close_session(struct tee_context *ctx, u32 session)\r\n{\r\nstruct optee_context_data *ctxdata = ctx->data;\r\nstruct tee_shm *shm;\r\nstruct optee_msg_arg *msg_arg;\r\nphys_addr_t msg_parg;\r\nstruct optee_session *sess;\r\nmutex_lock(&ctxdata->mutex);\r\nsess = find_session(ctxdata, session);\r\nif (sess)\r\nlist_del(&sess->list_node);\r\nmutex_unlock(&ctxdata->mutex);\r\nif (!sess)\r\nreturn -EINVAL;\r\nkfree(sess);\r\nshm = get_msg_arg(ctx, 0, &msg_arg, &msg_parg);\r\nif (IS_ERR(shm))\r\nreturn PTR_ERR(shm);\r\nmsg_arg->cmd = OPTEE_MSG_CMD_CLOSE_SESSION;\r\nmsg_arg->session = session;\r\noptee_do_call_with_arg(ctx, msg_parg);\r\ntee_shm_free(shm);\r\nreturn 0;\r\n}\r\nint optee_invoke_func(struct tee_context *ctx, struct tee_ioctl_invoke_arg *arg,\r\nstruct tee_param *param)\r\n{\r\nstruct optee_context_data *ctxdata = ctx->data;\r\nstruct tee_shm *shm;\r\nstruct optee_msg_arg *msg_arg;\r\nphys_addr_t msg_parg;\r\nstruct optee_session *sess;\r\nint rc;\r\nmutex_lock(&ctxdata->mutex);\r\nsess = find_session(ctxdata, arg->session);\r\nmutex_unlock(&ctxdata->mutex);\r\nif (!sess)\r\nreturn -EINVAL;\r\nshm = get_msg_arg(ctx, arg->num_params, &msg_arg, &msg_parg);\r\nif (IS_ERR(shm))\r\nreturn PTR_ERR(shm);\r\nmsg_arg->cmd = OPTEE_MSG_CMD_INVOKE_COMMAND;\r\nmsg_arg->func = arg->func;\r\nmsg_arg->session = arg->session;\r\nmsg_arg->cancel_id = arg->cancel_id;\r\nrc = optee_to_msg_param(msg_arg->params, arg->num_params, param);\r\nif (rc)\r\ngoto out;\r\nif (optee_do_call_with_arg(ctx, msg_parg)) {\r\nmsg_arg->ret = TEEC_ERROR_COMMUNICATION;\r\nmsg_arg->ret_origin = TEEC_ORIGIN_COMMS;\r\n}\r\nif (optee_from_msg_param(param, arg->num_params, msg_arg->params)) {\r\nmsg_arg->ret = TEEC_ERROR_COMMUNICATION;\r\nmsg_arg->ret_origin = TEEC_ORIGIN_COMMS;\r\n}\r\narg->ret = msg_arg->ret;\r\narg->ret_origin = msg_arg->ret_origin;\r\nout:\r\ntee_shm_free(shm);\r\nreturn rc;\r\n}\r\nint optee_cancel_req(struct tee_context *ctx, u32 cancel_id, u32 session)\r\n{\r\nstruct optee_context_data *ctxdata = ctx->data;\r\nstruct tee_shm *shm;\r\nstruct optee_msg_arg *msg_arg;\r\nphys_addr_t msg_parg;\r\nstruct optee_session *sess;\r\nmutex_lock(&ctxdata->mutex);\r\nsess = find_session(ctxdata, session);\r\nmutex_unlock(&ctxdata->mutex);\r\nif (!sess)\r\nreturn -EINVAL;\r\nshm = get_msg_arg(ctx, 0, &msg_arg, &msg_parg);\r\nif (IS_ERR(shm))\r\nreturn PTR_ERR(shm);\r\nmsg_arg->cmd = OPTEE_MSG_CMD_CANCEL;\r\nmsg_arg->session = session;\r\nmsg_arg->cancel_id = cancel_id;\r\noptee_do_call_with_arg(ctx, msg_parg);\r\ntee_shm_free(shm);\r\nreturn 0;\r\n}\r\nvoid optee_enable_shm_cache(struct optee *optee)\r\n{\r\nstruct optee_call_waiter w;\r\noptee_cq_wait_init(&optee->call_queue, &w);\r\nwhile (true) {\r\nstruct arm_smccc_res res;\r\noptee->invoke_fn(OPTEE_SMC_ENABLE_SHM_CACHE, 0, 0, 0, 0, 0, 0,\r\n0, &res);\r\nif (res.a0 == OPTEE_SMC_RETURN_OK)\r\nbreak;\r\noptee_cq_wait_for_completion(&optee->call_queue, &w);\r\n}\r\noptee_cq_wait_final(&optee->call_queue, &w);\r\n}\r\nvoid optee_disable_shm_cache(struct optee *optee)\r\n{\r\nstruct optee_call_waiter w;\r\noptee_cq_wait_init(&optee->call_queue, &w);\r\nwhile (true) {\r\nunion {\r\nstruct arm_smccc_res smccc;\r\nstruct optee_smc_disable_shm_cache_result result;\r\n} res;\r\noptee->invoke_fn(OPTEE_SMC_DISABLE_SHM_CACHE, 0, 0, 0, 0, 0, 0,\r\n0, &res.smccc);\r\nif (res.result.status == OPTEE_SMC_RETURN_ENOTAVAIL)\r\nbreak;\r\nif (res.result.status == OPTEE_SMC_RETURN_OK) {\r\nstruct tee_shm *shm;\r\nshm = reg_pair_to_ptr(res.result.shm_upper32,\r\nres.result.shm_lower32);\r\ntee_shm_free(shm);\r\n} else {\r\noptee_cq_wait_for_completion(&optee->call_queue, &w);\r\n}\r\n}\r\noptee_cq_wait_final(&optee->call_queue, &w);\r\n}
