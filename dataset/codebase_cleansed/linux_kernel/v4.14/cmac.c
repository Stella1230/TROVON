static int crypto_cmac_digest_setkey(struct crypto_shash *parent,\r\nconst u8 *inkey, unsigned int keylen)\r\n{\r\nunsigned long alignmask = crypto_shash_alignmask(parent);\r\nstruct cmac_tfm_ctx *ctx = crypto_shash_ctx(parent);\r\nunsigned int bs = crypto_shash_blocksize(parent);\r\n__be64 *consts = PTR_ALIGN((void *)ctx->ctx,\r\n(alignmask | (__alignof__(__be64) - 1)) + 1);\r\nu64 _const[2];\r\nint i, err = 0;\r\nu8 msb_mask, gfmask;\r\nerr = crypto_cipher_setkey(ctx->child, inkey, keylen);\r\nif (err)\r\nreturn err;\r\nmemset(consts, 0, bs);\r\ncrypto_cipher_encrypt_one(ctx->child, (u8 *)consts, (u8 *)consts);\r\nswitch (bs) {\r\ncase 16:\r\ngfmask = 0x87;\r\n_const[0] = be64_to_cpu(consts[1]);\r\n_const[1] = be64_to_cpu(consts[0]);\r\nfor (i = 0; i < 4; i += 2) {\r\nmsb_mask = ((s64)_const[1] >> 63) & gfmask;\r\n_const[1] = (_const[1] << 1) | (_const[0] >> 63);\r\n_const[0] = (_const[0] << 1) ^ msb_mask;\r\nconsts[i + 0] = cpu_to_be64(_const[1]);\r\nconsts[i + 1] = cpu_to_be64(_const[0]);\r\n}\r\nbreak;\r\ncase 8:\r\ngfmask = 0x1B;\r\n_const[0] = be64_to_cpu(consts[0]);\r\nfor (i = 0; i < 2; i++) {\r\nmsb_mask = ((s64)_const[0] >> 63) & gfmask;\r\n_const[0] = (_const[0] << 1) ^ msb_mask;\r\nconsts[i] = cpu_to_be64(_const[0]);\r\n}\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int crypto_cmac_digest_init(struct shash_desc *pdesc)\r\n{\r\nunsigned long alignmask = crypto_shash_alignmask(pdesc->tfm);\r\nstruct cmac_desc_ctx *ctx = shash_desc_ctx(pdesc);\r\nint bs = crypto_shash_blocksize(pdesc->tfm);\r\nu8 *prev = PTR_ALIGN((void *)ctx->ctx, alignmask + 1) + bs;\r\nctx->len = 0;\r\nmemset(prev, 0, bs);\r\nreturn 0;\r\n}\r\nstatic int crypto_cmac_digest_update(struct shash_desc *pdesc, const u8 *p,\r\nunsigned int len)\r\n{\r\nstruct crypto_shash *parent = pdesc->tfm;\r\nunsigned long alignmask = crypto_shash_alignmask(parent);\r\nstruct cmac_tfm_ctx *tctx = crypto_shash_ctx(parent);\r\nstruct cmac_desc_ctx *ctx = shash_desc_ctx(pdesc);\r\nstruct crypto_cipher *tfm = tctx->child;\r\nint bs = crypto_shash_blocksize(parent);\r\nu8 *odds = PTR_ALIGN((void *)ctx->ctx, alignmask + 1);\r\nu8 *prev = odds + bs;\r\nif ((ctx->len + len) <= bs) {\r\nmemcpy(odds + ctx->len, p, len);\r\nctx->len += len;\r\nreturn 0;\r\n}\r\nmemcpy(odds + ctx->len, p, bs - ctx->len);\r\nlen -= bs - ctx->len;\r\np += bs - ctx->len;\r\ncrypto_xor(prev, odds, bs);\r\ncrypto_cipher_encrypt_one(tfm, prev, prev);\r\nctx->len = 0;\r\nwhile (len > bs) {\r\ncrypto_xor(prev, p, bs);\r\ncrypto_cipher_encrypt_one(tfm, prev, prev);\r\np += bs;\r\nlen -= bs;\r\n}\r\nif (len) {\r\nmemcpy(odds, p, len);\r\nctx->len = len;\r\n}\r\nreturn 0;\r\n}\r\nstatic int crypto_cmac_digest_final(struct shash_desc *pdesc, u8 *out)\r\n{\r\nstruct crypto_shash *parent = pdesc->tfm;\r\nunsigned long alignmask = crypto_shash_alignmask(parent);\r\nstruct cmac_tfm_ctx *tctx = crypto_shash_ctx(parent);\r\nstruct cmac_desc_ctx *ctx = shash_desc_ctx(pdesc);\r\nstruct crypto_cipher *tfm = tctx->child;\r\nint bs = crypto_shash_blocksize(parent);\r\nu8 *consts = PTR_ALIGN((void *)tctx->ctx,\r\n(alignmask | (__alignof__(__be64) - 1)) + 1);\r\nu8 *odds = PTR_ALIGN((void *)ctx->ctx, alignmask + 1);\r\nu8 *prev = odds + bs;\r\nunsigned int offset = 0;\r\nif (ctx->len != bs) {\r\nunsigned int rlen;\r\nu8 *p = odds + ctx->len;\r\n*p = 0x80;\r\np++;\r\nrlen = bs - ctx->len - 1;\r\nif (rlen)\r\nmemset(p, 0, rlen);\r\noffset += bs;\r\n}\r\ncrypto_xor(prev, odds, bs);\r\ncrypto_xor(prev, consts + offset, bs);\r\ncrypto_cipher_encrypt_one(tfm, out, prev);\r\nreturn 0;\r\n}\r\nstatic int cmac_init_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_cipher *cipher;\r\nstruct crypto_instance *inst = (void *)tfm->__crt_alg;\r\nstruct crypto_spawn *spawn = crypto_instance_ctx(inst);\r\nstruct cmac_tfm_ctx *ctx = crypto_tfm_ctx(tfm);\r\ncipher = crypto_spawn_cipher(spawn);\r\nif (IS_ERR(cipher))\r\nreturn PTR_ERR(cipher);\r\nctx->child = cipher;\r\nreturn 0;\r\n}\r\nstatic void cmac_exit_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct cmac_tfm_ctx *ctx = crypto_tfm_ctx(tfm);\r\ncrypto_free_cipher(ctx->child);\r\n}\r\nstatic int cmac_create(struct crypto_template *tmpl, struct rtattr **tb)\r\n{\r\nstruct shash_instance *inst;\r\nstruct crypto_alg *alg;\r\nunsigned long alignmask;\r\nint err;\r\nerr = crypto_check_attr_type(tb, CRYPTO_ALG_TYPE_SHASH);\r\nif (err)\r\nreturn err;\r\nalg = crypto_get_attr_alg(tb, CRYPTO_ALG_TYPE_CIPHER,\r\nCRYPTO_ALG_TYPE_MASK);\r\nif (IS_ERR(alg))\r\nreturn PTR_ERR(alg);\r\nswitch (alg->cra_blocksize) {\r\ncase 16:\r\ncase 8:\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\ngoto out_put_alg;\r\n}\r\ninst = shash_alloc_instance("cmac", alg);\r\nerr = PTR_ERR(inst);\r\nif (IS_ERR(inst))\r\ngoto out_put_alg;\r\nerr = crypto_init_spawn(shash_instance_ctx(inst), alg,\r\nshash_crypto_instance(inst),\r\nCRYPTO_ALG_TYPE_MASK);\r\nif (err)\r\ngoto out_free_inst;\r\nalignmask = alg->cra_alignmask;\r\ninst->alg.base.cra_alignmask = alignmask;\r\ninst->alg.base.cra_priority = alg->cra_priority;\r\ninst->alg.base.cra_blocksize = alg->cra_blocksize;\r\ninst->alg.digestsize = alg->cra_blocksize;\r\ninst->alg.descsize =\r\nALIGN(sizeof(struct cmac_desc_ctx), crypto_tfm_ctx_alignment())\r\n+ (alignmask & ~(crypto_tfm_ctx_alignment() - 1))\r\n+ alg->cra_blocksize * 2;\r\ninst->alg.base.cra_ctxsize =\r\nALIGN(sizeof(struct cmac_tfm_ctx), crypto_tfm_ctx_alignment())\r\n+ ((alignmask | (__alignof__(__be64) - 1)) &\r\n~(crypto_tfm_ctx_alignment() - 1))\r\n+ alg->cra_blocksize * 2;\r\ninst->alg.base.cra_init = cmac_init_tfm;\r\ninst->alg.base.cra_exit = cmac_exit_tfm;\r\ninst->alg.init = crypto_cmac_digest_init;\r\ninst->alg.update = crypto_cmac_digest_update;\r\ninst->alg.final = crypto_cmac_digest_final;\r\ninst->alg.setkey = crypto_cmac_digest_setkey;\r\nerr = shash_register_instance(tmpl, inst);\r\nif (err) {\r\nout_free_inst:\r\nshash_free_instance(shash_crypto_instance(inst));\r\n}\r\nout_put_alg:\r\ncrypto_mod_put(alg);\r\nreturn err;\r\n}\r\nstatic int __init crypto_cmac_module_init(void)\r\n{\r\nreturn crypto_register_template(&crypto_cmac_tmpl);\r\n}\r\nstatic void __exit crypto_cmac_module_exit(void)\r\n{\r\ncrypto_unregister_template(&crypto_cmac_tmpl);\r\n}
