static int nfp_release_stats_entry(struct nfp_app *app, u32 stats_context_id)\r\n{\r\nstruct nfp_flower_priv *priv = app->priv;\r\nstruct circ_buf *ring;\r\nring = &priv->stats_ids.free_list;\r\nif (!CIRC_SPACE(ring->head, ring->tail, NFP_FL_STATS_ENTRY_RS *\r\nNFP_FL_STATS_ELEM_RS -\r\nNFP_FL_STATS_ELEM_RS + 1))\r\nreturn -ENOBUFS;\r\nmemcpy(&ring->buf[ring->head], &stats_context_id, NFP_FL_STATS_ELEM_RS);\r\nring->head = (ring->head + NFP_FL_STATS_ELEM_RS) %\r\n(NFP_FL_STATS_ENTRY_RS * NFP_FL_STATS_ELEM_RS);\r\nreturn 0;\r\n}\r\nstatic int nfp_get_stats_entry(struct nfp_app *app, u32 *stats_context_id)\r\n{\r\nstruct nfp_flower_priv *priv = app->priv;\r\nu32 freed_stats_id, temp_stats_id;\r\nstruct circ_buf *ring;\r\nring = &priv->stats_ids.free_list;\r\nfreed_stats_id = NFP_FL_STATS_ENTRY_RS;\r\nif (priv->stats_ids.init_unalloc > 0) {\r\n*stats_context_id = priv->stats_ids.init_unalloc - 1;\r\npriv->stats_ids.init_unalloc--;\r\nreturn 0;\r\n}\r\nif (ring->head == ring->tail) {\r\n*stats_context_id = freed_stats_id;\r\nreturn -ENOENT;\r\n}\r\nmemcpy(&temp_stats_id, &ring->buf[ring->tail], NFP_FL_STATS_ELEM_RS);\r\n*stats_context_id = temp_stats_id;\r\nmemcpy(&ring->buf[ring->tail], &freed_stats_id, NFP_FL_STATS_ELEM_RS);\r\nring->tail = (ring->tail + NFP_FL_STATS_ELEM_RS) %\r\n(NFP_FL_STATS_ENTRY_RS * NFP_FL_STATS_ELEM_RS);\r\nreturn 0;\r\n}\r\nstruct nfp_fl_payload *\r\nnfp_flower_search_fl_table(struct nfp_app *app, unsigned long tc_flower_cookie)\r\n{\r\nstruct nfp_flower_priv *priv = app->priv;\r\nstruct nfp_fl_payload *flower_entry;\r\nhash_for_each_possible_rcu(priv->flow_table, flower_entry, link,\r\ntc_flower_cookie)\r\nif (flower_entry->tc_flower_cookie == tc_flower_cookie)\r\nreturn flower_entry;\r\nreturn NULL;\r\n}\r\nstatic void\r\nnfp_flower_update_stats(struct nfp_app *app, struct nfp_fl_stats_frame *stats)\r\n{\r\nstruct nfp_fl_payload *nfp_flow;\r\nunsigned long flower_cookie;\r\nflower_cookie = be64_to_cpu(stats->stats_cookie);\r\nrcu_read_lock();\r\nnfp_flow = nfp_flower_search_fl_table(app, flower_cookie);\r\nif (!nfp_flow)\r\ngoto exit_rcu_unlock;\r\nif (nfp_flow->meta.host_ctx_id != stats->stats_con_id)\r\ngoto exit_rcu_unlock;\r\nspin_lock(&nfp_flow->lock);\r\nnfp_flow->stats.pkts += be32_to_cpu(stats->pkt_count);\r\nnfp_flow->stats.bytes += be64_to_cpu(stats->byte_count);\r\nnfp_flow->stats.used = jiffies;\r\nspin_unlock(&nfp_flow->lock);\r\nexit_rcu_unlock:\r\nrcu_read_unlock();\r\n}\r\nvoid nfp_flower_rx_flow_stats(struct nfp_app *app, struct sk_buff *skb)\r\n{\r\nunsigned int msg_len = skb->len - NFP_FLOWER_CMSG_HLEN;\r\nstruct nfp_fl_stats_frame *stats_frame;\r\nunsigned char *msg;\r\nint i;\r\nmsg = nfp_flower_cmsg_get_data(skb);\r\nstats_frame = (struct nfp_fl_stats_frame *)msg;\r\nfor (i = 0; i < msg_len / sizeof(*stats_frame); i++)\r\nnfp_flower_update_stats(app, stats_frame + i);\r\n}\r\nstatic int nfp_release_mask_id(struct nfp_app *app, u8 mask_id)\r\n{\r\nstruct nfp_flower_priv *priv = app->priv;\r\nstruct circ_buf *ring;\r\nstruct timespec64 now;\r\nring = &priv->mask_ids.mask_id_free_list;\r\nif (CIRC_SPACE(ring->head, ring->tail, NFP_FLOWER_MASK_ENTRY_RS) == 0)\r\nreturn -ENOBUFS;\r\nmemcpy(&ring->buf[ring->head], &mask_id, NFP_FLOWER_MASK_ELEMENT_RS);\r\nring->head = (ring->head + NFP_FLOWER_MASK_ELEMENT_RS) %\r\n(NFP_FLOWER_MASK_ENTRY_RS * NFP_FLOWER_MASK_ELEMENT_RS);\r\ngetnstimeofday64(&now);\r\npriv->mask_ids.last_used[mask_id] = now;\r\nreturn 0;\r\n}\r\nstatic int nfp_mask_alloc(struct nfp_app *app, u8 *mask_id)\r\n{\r\nstruct nfp_flower_priv *priv = app->priv;\r\nstruct timespec64 delta, now;\r\nstruct circ_buf *ring;\r\nu8 temp_id, freed_id;\r\nring = &priv->mask_ids.mask_id_free_list;\r\nfreed_id = NFP_FLOWER_MASK_ENTRY_RS - 1;\r\nif (priv->mask_ids.init_unallocated > 0) {\r\n*mask_id = priv->mask_ids.init_unallocated;\r\npriv->mask_ids.init_unallocated--;\r\nreturn 0;\r\n}\r\nif (ring->head == ring->tail)\r\ngoto err_not_found;\r\nmemcpy(&temp_id, &ring->buf[ring->tail], NFP_FLOWER_MASK_ELEMENT_RS);\r\n*mask_id = temp_id;\r\ngetnstimeofday64(&now);\r\ndelta = timespec64_sub(now, priv->mask_ids.last_used[*mask_id]);\r\nif (timespec64_to_ns(&delta) < NFP_FL_MASK_REUSE_TIME_NS)\r\ngoto err_not_found;\r\nmemcpy(&ring->buf[ring->tail], &freed_id, NFP_FLOWER_MASK_ELEMENT_RS);\r\nring->tail = (ring->tail + NFP_FLOWER_MASK_ELEMENT_RS) %\r\n(NFP_FLOWER_MASK_ENTRY_RS * NFP_FLOWER_MASK_ELEMENT_RS);\r\nreturn 0;\r\nerr_not_found:\r\n*mask_id = freed_id;\r\nreturn -ENOENT;\r\n}\r\nstatic int\r\nnfp_add_mask_table(struct nfp_app *app, char *mask_data, u32 mask_len)\r\n{\r\nstruct nfp_flower_priv *priv = app->priv;\r\nstruct nfp_mask_id_table *mask_entry;\r\nunsigned long hash_key;\r\nu8 mask_id;\r\nif (nfp_mask_alloc(app, &mask_id))\r\nreturn -ENOENT;\r\nmask_entry = kmalloc(sizeof(*mask_entry), GFP_KERNEL);\r\nif (!mask_entry) {\r\nnfp_release_mask_id(app, mask_id);\r\nreturn -ENOMEM;\r\n}\r\nINIT_HLIST_NODE(&mask_entry->link);\r\nmask_entry->mask_id = mask_id;\r\nhash_key = jhash(mask_data, mask_len, priv->mask_id_seed);\r\nmask_entry->hash_key = hash_key;\r\nmask_entry->ref_cnt = 1;\r\nhash_add(priv->mask_table, &mask_entry->link, hash_key);\r\nreturn mask_id;\r\n}\r\nstatic struct nfp_mask_id_table *\r\nnfp_search_mask_table(struct nfp_app *app, char *mask_data, u32 mask_len)\r\n{\r\nstruct nfp_flower_priv *priv = app->priv;\r\nstruct nfp_mask_id_table *mask_entry;\r\nunsigned long hash_key;\r\nhash_key = jhash(mask_data, mask_len, priv->mask_id_seed);\r\nhash_for_each_possible(priv->mask_table, mask_entry, link, hash_key)\r\nif (mask_entry->hash_key == hash_key)\r\nreturn mask_entry;\r\nreturn NULL;\r\n}\r\nstatic int\r\nnfp_find_in_mask_table(struct nfp_app *app, char *mask_data, u32 mask_len)\r\n{\r\nstruct nfp_mask_id_table *mask_entry;\r\nmask_entry = nfp_search_mask_table(app, mask_data, mask_len);\r\nif (!mask_entry)\r\nreturn -ENOENT;\r\nmask_entry->ref_cnt++;\r\nreturn mask_entry->mask_id;\r\n}\r\nstatic bool\r\nnfp_check_mask_add(struct nfp_app *app, char *mask_data, u32 mask_len,\r\nu8 *meta_flags, u8 *mask_id)\r\n{\r\nint id;\r\nid = nfp_find_in_mask_table(app, mask_data, mask_len);\r\nif (id < 0) {\r\nid = nfp_add_mask_table(app, mask_data, mask_len);\r\nif (id < 0)\r\nreturn false;\r\n*meta_flags |= NFP_FL_META_FLAG_NEW_MASK;\r\n}\r\n*mask_id = id;\r\nreturn true;\r\n}\r\nstatic bool\r\nnfp_check_mask_remove(struct nfp_app *app, char *mask_data, u32 mask_len,\r\nu8 *meta_flags, u8 *mask_id)\r\n{\r\nstruct nfp_mask_id_table *mask_entry;\r\nmask_entry = nfp_search_mask_table(app, mask_data, mask_len);\r\nif (!mask_entry)\r\nreturn false;\r\n*mask_id = mask_entry->mask_id;\r\nmask_entry->ref_cnt--;\r\nif (!mask_entry->ref_cnt) {\r\nhash_del(&mask_entry->link);\r\nnfp_release_mask_id(app, *mask_id);\r\nkfree(mask_entry);\r\nif (meta_flags)\r\n*meta_flags |= NFP_FL_META_FLAG_LAST_MASK;\r\n}\r\nreturn true;\r\n}\r\nint nfp_compile_flow_metadata(struct nfp_app *app,\r\nstruct tc_cls_flower_offload *flow,\r\nstruct nfp_fl_payload *nfp_flow)\r\n{\r\nstruct nfp_flower_priv *priv = app->priv;\r\nstruct nfp_fl_payload *check_entry;\r\nu8 new_mask_id;\r\nu32 stats_cxt;\r\nif (nfp_get_stats_entry(app, &stats_cxt))\r\nreturn -ENOENT;\r\nnfp_flow->meta.host_ctx_id = cpu_to_be32(stats_cxt);\r\nnfp_flow->meta.host_cookie = cpu_to_be64(flow->cookie);\r\nnew_mask_id = 0;\r\nif (!nfp_check_mask_add(app, nfp_flow->mask_data,\r\nnfp_flow->meta.mask_len,\r\n&nfp_flow->meta.flags, &new_mask_id)) {\r\nif (nfp_release_stats_entry(app, stats_cxt))\r\nreturn -EINVAL;\r\nreturn -ENOENT;\r\n}\r\nnfp_flow->meta.flow_version = cpu_to_be64(priv->flower_version);\r\npriv->flower_version++;\r\nnfp_flow->unmasked_data[NFP_FL_MASK_ID_LOCATION] = new_mask_id;\r\nnfp_flow->stats.pkts = 0;\r\nnfp_flow->stats.bytes = 0;\r\nnfp_flow->stats.used = jiffies;\r\ncheck_entry = nfp_flower_search_fl_table(app, flow->cookie);\r\nif (check_entry) {\r\nif (nfp_release_stats_entry(app, stats_cxt))\r\nreturn -EINVAL;\r\nif (!nfp_check_mask_remove(app, nfp_flow->mask_data,\r\nnfp_flow->meta.mask_len,\r\nNULL, &new_mask_id))\r\nreturn -EINVAL;\r\nreturn -EEXIST;\r\n}\r\nreturn 0;\r\n}\r\nint nfp_modify_flow_metadata(struct nfp_app *app,\r\nstruct nfp_fl_payload *nfp_flow)\r\n{\r\nstruct nfp_flower_priv *priv = app->priv;\r\nu8 new_mask_id = 0;\r\nu32 temp_ctx_id;\r\nnfp_check_mask_remove(app, nfp_flow->mask_data,\r\nnfp_flow->meta.mask_len, &nfp_flow->meta.flags,\r\n&new_mask_id);\r\nnfp_flow->meta.flow_version = cpu_to_be64(priv->flower_version);\r\npriv->flower_version++;\r\nnfp_flow->unmasked_data[NFP_FL_MASK_ID_LOCATION] = new_mask_id;\r\ntemp_ctx_id = be32_to_cpu(nfp_flow->meta.host_ctx_id);\r\nreturn nfp_release_stats_entry(app, temp_ctx_id);\r\n}\r\nint nfp_flower_metadata_init(struct nfp_app *app)\r\n{\r\nstruct nfp_flower_priv *priv = app->priv;\r\nhash_init(priv->mask_table);\r\nhash_init(priv->flow_table);\r\nget_random_bytes(&priv->mask_id_seed, sizeof(priv->mask_id_seed));\r\npriv->mask_ids.mask_id_free_list.buf =\r\nkmalloc_array(NFP_FLOWER_MASK_ENTRY_RS,\r\nNFP_FLOWER_MASK_ELEMENT_RS, GFP_KERNEL);\r\nif (!priv->mask_ids.mask_id_free_list.buf)\r\nreturn -ENOMEM;\r\npriv->mask_ids.init_unallocated = NFP_FLOWER_MASK_ENTRY_RS - 1;\r\npriv->mask_ids.last_used =\r\nkmalloc_array(NFP_FLOWER_MASK_ENTRY_RS,\r\nsizeof(*priv->mask_ids.last_used), GFP_KERNEL);\r\nif (!priv->mask_ids.last_used)\r\ngoto err_free_mask_id;\r\npriv->stats_ids.free_list.buf =\r\nvmalloc(NFP_FL_STATS_ENTRY_RS * NFP_FL_STATS_ELEM_RS);\r\nif (!priv->stats_ids.free_list.buf)\r\ngoto err_free_last_used;\r\npriv->stats_ids.init_unalloc = NFP_FL_REPEATED_HASH_MAX;\r\nreturn 0;\r\nerr_free_last_used:\r\nkfree(priv->mask_ids.last_used);\r\nerr_free_mask_id:\r\nkfree(priv->mask_ids.mask_id_free_list.buf);\r\nreturn -ENOMEM;\r\n}\r\nvoid nfp_flower_metadata_cleanup(struct nfp_app *app)\r\n{\r\nstruct nfp_flower_priv *priv = app->priv;\r\nif (!priv)\r\nreturn;\r\nkfree(priv->mask_ids.mask_id_free_list.buf);\r\nkfree(priv->mask_ids.last_used);\r\nvfree(priv->stats_ids.free_list.buf);\r\n}
