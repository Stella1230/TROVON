static int __init hung_task_panic_setup(char *str)\r\n{\r\nint rc = kstrtouint(str, 0, &sysctl_hung_task_panic);\r\nif (rc)\r\nreturn rc;\r\nreturn 1;\r\n}\r\nstatic int\r\nhung_task_panic(struct notifier_block *this, unsigned long event, void *ptr)\r\n{\r\ndid_panic = 1;\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic void check_hung_task(struct task_struct *t, unsigned long timeout)\r\n{\r\nunsigned long switch_count = t->nvcsw + t->nivcsw;\r\nif (unlikely(t->flags & (PF_FROZEN | PF_FREEZER_SKIP)))\r\nreturn;\r\nif (unlikely(!switch_count))\r\nreturn;\r\nif (switch_count != t->last_switch_count) {\r\nt->last_switch_count = switch_count;\r\nreturn;\r\n}\r\ntrace_sched_process_hang(t);\r\nif (!sysctl_hung_task_warnings && !sysctl_hung_task_panic)\r\nreturn;\r\nif (sysctl_hung_task_warnings) {\r\nif (sysctl_hung_task_warnings > 0)\r\nsysctl_hung_task_warnings--;\r\npr_err("INFO: task %s:%d blocked for more than %ld seconds.\n",\r\nt->comm, t->pid, timeout);\r\npr_err(" %s %s %.*s\n",\r\nprint_tainted(), init_utsname()->release,\r\n(int)strcspn(init_utsname()->version, " "),\r\ninit_utsname()->version);\r\npr_err("\"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\""\r\n" disables this message.\n");\r\nsched_show_task(t);\r\nhung_task_show_lock = true;\r\n}\r\ntouch_nmi_watchdog();\r\nif (sysctl_hung_task_panic) {\r\nif (hung_task_show_lock)\r\ndebug_show_all_locks();\r\ntrigger_all_cpu_backtrace();\r\npanic("hung_task: blocked tasks");\r\n}\r\n}\r\nstatic bool rcu_lock_break(struct task_struct *g, struct task_struct *t)\r\n{\r\nbool can_cont;\r\nget_task_struct(g);\r\nget_task_struct(t);\r\nrcu_read_unlock();\r\ncond_resched();\r\nrcu_read_lock();\r\ncan_cont = pid_alive(g) && pid_alive(t);\r\nput_task_struct(t);\r\nput_task_struct(g);\r\nreturn can_cont;\r\n}\r\nstatic void check_hung_uninterruptible_tasks(unsigned long timeout)\r\n{\r\nint max_count = sysctl_hung_task_check_count;\r\nint batch_count = HUNG_TASK_BATCHING;\r\nstruct task_struct *g, *t;\r\nif (test_taint(TAINT_DIE) || did_panic)\r\nreturn;\r\nhung_task_show_lock = false;\r\nrcu_read_lock();\r\nfor_each_process_thread(g, t) {\r\nif (!max_count--)\r\ngoto unlock;\r\nif (!--batch_count) {\r\nbatch_count = HUNG_TASK_BATCHING;\r\nif (!rcu_lock_break(g, t))\r\ngoto unlock;\r\n}\r\nif (t->state == TASK_UNINTERRUPTIBLE)\r\ncheck_hung_task(t, timeout);\r\n}\r\nunlock:\r\nrcu_read_unlock();\r\nif (hung_task_show_lock)\r\ndebug_show_all_locks();\r\n}\r\nstatic long hung_timeout_jiffies(unsigned long last_checked,\r\nunsigned long timeout)\r\n{\r\nreturn timeout ? last_checked - jiffies + timeout * HZ :\r\nMAX_SCHEDULE_TIMEOUT;\r\n}\r\nint proc_dohung_task_timeout_secs(struct ctl_table *table, int write,\r\nvoid __user *buffer,\r\nsize_t *lenp, loff_t *ppos)\r\n{\r\nint ret;\r\nret = proc_doulongvec_minmax(table, write, buffer, lenp, ppos);\r\nif (ret || !write)\r\ngoto out;\r\nwake_up_process(watchdog_task);\r\nout:\r\nreturn ret;\r\n}\r\nvoid reset_hung_task_detector(void)\r\n{\r\natomic_set(&reset_hung_task, 1);\r\n}\r\nstatic int watchdog(void *dummy)\r\n{\r\nunsigned long hung_last_checked = jiffies;\r\nset_user_nice(current, 0);\r\nfor ( ; ; ) {\r\nunsigned long timeout = sysctl_hung_task_timeout_secs;\r\nlong t = hung_timeout_jiffies(hung_last_checked, timeout);\r\nif (t <= 0) {\r\nif (!atomic_xchg(&reset_hung_task, 0))\r\ncheck_hung_uninterruptible_tasks(timeout);\r\nhung_last_checked = jiffies;\r\ncontinue;\r\n}\r\nschedule_timeout_interruptible(t);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init hung_task_init(void)\r\n{\r\natomic_notifier_chain_register(&panic_notifier_list, &panic_block);\r\nwatchdog_task = kthread_run(watchdog, NULL, "khungtaskd");\r\nreturn 0;\r\n}
