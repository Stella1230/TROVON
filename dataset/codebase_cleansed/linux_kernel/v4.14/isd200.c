static void isd200_build_sense(struct us_data *us, struct scsi_cmnd *srb)\r\n{\r\nstruct isd200_info *info = (struct isd200_info *)us->extra;\r\nstruct sense_data *buf = (struct sense_data *) &srb->sense_buffer[0];\r\nunsigned char error = info->ATARegs[ATA_REG_ERROR_OFFSET];\r\nif(error & ATA_ERROR_MEDIA_CHANGE) {\r\nbuf->ErrorCode = 0x70 | SENSE_ERRCODE_VALID;\r\nbuf->AdditionalSenseLength = 0xb;\r\nbuf->Flags = UNIT_ATTENTION;\r\nbuf->AdditionalSenseCode = 0;\r\nbuf->AdditionalSenseCodeQualifier = 0;\r\n} else if (error & ATA_MCR) {\r\nbuf->ErrorCode = 0x70 | SENSE_ERRCODE_VALID;\r\nbuf->AdditionalSenseLength = 0xb;\r\nbuf->Flags = UNIT_ATTENTION;\r\nbuf->AdditionalSenseCode = 0;\r\nbuf->AdditionalSenseCodeQualifier = 0;\r\n} else if (error & ATA_TRK0NF) {\r\nbuf->ErrorCode = 0x70 | SENSE_ERRCODE_VALID;\r\nbuf->AdditionalSenseLength = 0xb;\r\nbuf->Flags = NOT_READY;\r\nbuf->AdditionalSenseCode = 0;\r\nbuf->AdditionalSenseCodeQualifier = 0;\r\n} else if (error & ATA_UNC) {\r\nbuf->ErrorCode = 0x70 | SENSE_ERRCODE_VALID;\r\nbuf->AdditionalSenseLength = 0xb;\r\nbuf->Flags = DATA_PROTECT;\r\nbuf->AdditionalSenseCode = 0;\r\nbuf->AdditionalSenseCodeQualifier = 0;\r\n} else {\r\nbuf->ErrorCode = 0;\r\nbuf->AdditionalSenseLength = 0;\r\nbuf->Flags = 0;\r\nbuf->AdditionalSenseCode = 0;\r\nbuf->AdditionalSenseCodeQualifier = 0;\r\n}\r\n}\r\nstatic void isd200_set_srb(struct isd200_info *info,\r\nenum dma_data_direction dir, void* buff, unsigned bufflen)\r\n{\r\nstruct scsi_cmnd *srb = &info->srb;\r\nif (buff)\r\nsg_init_one(&info->sg, buff, bufflen);\r\nsrb->sc_data_direction = dir;\r\nsrb->sdb.table.sgl = buff ? &info->sg : NULL;\r\nsrb->sdb.length = bufflen;\r\nsrb->sdb.table.nents = buff ? 1 : 0;\r\n}\r\nstatic void isd200_srb_set_bufflen(struct scsi_cmnd *srb, unsigned bufflen)\r\n{\r\nsrb->sdb.length = bufflen;\r\n}\r\nstatic int isd200_action( struct us_data *us, int action,\r\nvoid* pointer, int value )\r\n{\r\nunion ata_cdb ata;\r\nstatic struct scsi_device srb_dev;\r\nstruct isd200_info *info = (struct isd200_info *)us->extra;\r\nstruct scsi_cmnd *srb = &info->srb;\r\nint status;\r\nmemset(&ata, 0, sizeof(ata));\r\nsrb->cmnd = info->cmnd;\r\nsrb->device = &srb_dev;\r\nata.generic.SignatureByte0 = info->ConfigData.ATAMajorCommand;\r\nata.generic.SignatureByte1 = info->ConfigData.ATAMinorCommand;\r\nata.generic.TransferBlockSize = 1;\r\nswitch ( action ) {\r\ncase ACTION_READ_STATUS:\r\nusb_stor_dbg(us, " isd200_action(READ_STATUS)\n");\r\nata.generic.ActionSelect = ACTION_SELECT_0|ACTION_SELECT_2;\r\nata.generic.RegisterSelect =\r\nREG_CYLINDER_LOW | REG_CYLINDER_HIGH |\r\nREG_STATUS | REG_ERROR;\r\nisd200_set_srb(info, DMA_FROM_DEVICE, pointer, value);\r\nbreak;\r\ncase ACTION_ENUM:\r\nusb_stor_dbg(us, " isd200_action(ENUM,0x%02x)\n", value);\r\nata.generic.ActionSelect = ACTION_SELECT_1|ACTION_SELECT_2|\r\nACTION_SELECT_3|ACTION_SELECT_4|\r\nACTION_SELECT_5;\r\nata.generic.RegisterSelect = REG_DEVICE_HEAD;\r\nata.write.DeviceHeadByte = value;\r\nisd200_set_srb(info, DMA_NONE, NULL, 0);\r\nbreak;\r\ncase ACTION_RESET:\r\nusb_stor_dbg(us, " isd200_action(RESET)\n");\r\nata.generic.ActionSelect = ACTION_SELECT_1|ACTION_SELECT_2|\r\nACTION_SELECT_3|ACTION_SELECT_4;\r\nata.generic.RegisterSelect = REG_DEVICE_CONTROL;\r\nata.write.DeviceControlByte = ATA_DC_RESET_CONTROLLER;\r\nisd200_set_srb(info, DMA_NONE, NULL, 0);\r\nbreak;\r\ncase ACTION_REENABLE:\r\nusb_stor_dbg(us, " isd200_action(REENABLE)\n");\r\nata.generic.ActionSelect = ACTION_SELECT_1|ACTION_SELECT_2|\r\nACTION_SELECT_3|ACTION_SELECT_4;\r\nata.generic.RegisterSelect = REG_DEVICE_CONTROL;\r\nata.write.DeviceControlByte = ATA_DC_REENABLE_CONTROLLER;\r\nisd200_set_srb(info, DMA_NONE, NULL, 0);\r\nbreak;\r\ncase ACTION_SOFT_RESET:\r\nusb_stor_dbg(us, " isd200_action(SOFT_RESET)\n");\r\nata.generic.ActionSelect = ACTION_SELECT_1|ACTION_SELECT_5;\r\nata.generic.RegisterSelect = REG_DEVICE_HEAD | REG_COMMAND;\r\nata.write.DeviceHeadByte = info->DeviceHead;\r\nata.write.CommandByte = ATA_CMD_DEV_RESET;\r\nisd200_set_srb(info, DMA_NONE, NULL, 0);\r\nbreak;\r\ncase ACTION_IDENTIFY:\r\nusb_stor_dbg(us, " isd200_action(IDENTIFY)\n");\r\nata.generic.RegisterSelect = REG_COMMAND;\r\nata.write.CommandByte = ATA_CMD_ID_ATA;\r\nisd200_set_srb(info, DMA_FROM_DEVICE, info->id,\r\nATA_ID_WORDS * 2);\r\nbreak;\r\ndefault:\r\nusb_stor_dbg(us, "Error: Undefined action %d\n", action);\r\nreturn ISD200_ERROR;\r\n}\r\nmemcpy(srb->cmnd, &ata, sizeof(ata.generic));\r\nsrb->cmd_len = sizeof(ata.generic);\r\nstatus = usb_stor_Bulk_transport(srb, us);\r\nif (status == USB_STOR_TRANSPORT_GOOD)\r\nstatus = ISD200_GOOD;\r\nelse {\r\nusb_stor_dbg(us, " isd200_action(0x%02x) error: %d\n",\r\naction, status);\r\nstatus = ISD200_ERROR;\r\n}\r\nreturn status;\r\n}\r\nstatic int isd200_read_regs( struct us_data *us )\r\n{\r\nstruct isd200_info *info = (struct isd200_info *)us->extra;\r\nint retStatus = ISD200_GOOD;\r\nint transferStatus;\r\nusb_stor_dbg(us, "Entering isd200_IssueATAReadRegs\n");\r\ntransferStatus = isd200_action( us, ACTION_READ_STATUS,\r\ninfo->RegsBuf, sizeof(info->ATARegs) );\r\nif (transferStatus != ISD200_TRANSPORT_GOOD) {\r\nusb_stor_dbg(us, " Error reading ATA registers\n");\r\nretStatus = ISD200_ERROR;\r\n} else {\r\nmemcpy(info->ATARegs, info->RegsBuf, sizeof(info->ATARegs));\r\nusb_stor_dbg(us, " Got ATA Register[ATA_REG_ERROR_OFFSET] = 0x%x\n",\r\ninfo->ATARegs[ATA_REG_ERROR_OFFSET]);\r\n}\r\nreturn retStatus;\r\n}\r\nstatic void isd200_invoke_transport( struct us_data *us,\r\nstruct scsi_cmnd *srb,\r\nunion ata_cdb *ataCdb )\r\n{\r\nint need_auto_sense = 0;\r\nint transferStatus;\r\nint result;\r\nmemcpy(srb->cmnd, ataCdb, sizeof(ataCdb->generic));\r\nsrb->cmd_len = sizeof(ataCdb->generic);\r\ntransferStatus = usb_stor_Bulk_transport(srb, us);\r\nif (test_bit(US_FLIDX_TIMED_OUT, &us->dflags)) {\r\nusb_stor_dbg(us, "-- command was aborted\n");\r\ngoto Handle_Abort;\r\n}\r\nswitch (transferStatus) {\r\ncase USB_STOR_TRANSPORT_GOOD:\r\nsrb->result = SAM_STAT_GOOD;\r\nbreak;\r\ncase USB_STOR_TRANSPORT_NO_SENSE:\r\nusb_stor_dbg(us, "-- transport indicates protocol failure\n");\r\nsrb->result = SAM_STAT_CHECK_CONDITION;\r\nreturn;\r\ncase USB_STOR_TRANSPORT_FAILED:\r\nusb_stor_dbg(us, "-- transport indicates command failure\n");\r\nneed_auto_sense = 1;\r\nbreak;\r\ncase USB_STOR_TRANSPORT_ERROR:\r\nusb_stor_dbg(us, "-- transport indicates transport error\n");\r\nsrb->result = DID_ERROR << 16;\r\nreturn;\r\ndefault:\r\nusb_stor_dbg(us, "-- transport indicates unknown error\n");\r\nsrb->result = DID_ERROR << 16;\r\nreturn;\r\n}\r\nif ((scsi_get_resid(srb) > 0) &&\r\n!((srb->cmnd[0] == REQUEST_SENSE) ||\r\n(srb->cmnd[0] == INQUIRY) ||\r\n(srb->cmnd[0] == MODE_SENSE) ||\r\n(srb->cmnd[0] == LOG_SENSE) ||\r\n(srb->cmnd[0] == MODE_SENSE_10))) {\r\nusb_stor_dbg(us, "-- unexpectedly short transfer\n");\r\nneed_auto_sense = 1;\r\n}\r\nif (need_auto_sense) {\r\nresult = isd200_read_regs(us);\r\nif (test_bit(US_FLIDX_TIMED_OUT, &us->dflags)) {\r\nusb_stor_dbg(us, "-- auto-sense aborted\n");\r\ngoto Handle_Abort;\r\n}\r\nif (result == ISD200_GOOD) {\r\nisd200_build_sense(us, srb);\r\nsrb->result = SAM_STAT_CHECK_CONDITION;\r\nif ((srb->sense_buffer[2] & 0xf) == 0x0)\r\nsrb->result = SAM_STAT_GOOD;\r\n} else {\r\nsrb->result = DID_ERROR << 16;\r\n}\r\n}\r\nif (transferStatus == USB_STOR_TRANSPORT_FAILED)\r\nsrb->result = SAM_STAT_CHECK_CONDITION;\r\nreturn;\r\nHandle_Abort:\r\nsrb->result = DID_ABORT << 16;\r\nclear_bit(US_FLIDX_ABORTING, &us->dflags);\r\n}\r\nstatic void isd200_log_config(struct us_data *us, struct isd200_info *info)\r\n{\r\nusb_stor_dbg(us, " Event Notification: 0x%x\n",\r\ninfo->ConfigData.EventNotification);\r\nusb_stor_dbg(us, " External Clock: 0x%x\n",\r\ninfo->ConfigData.ExternalClock);\r\nusb_stor_dbg(us, " ATA Init Timeout: 0x%x\n",\r\ninfo->ConfigData.ATAInitTimeout);\r\nusb_stor_dbg(us, " ATAPI Command Block Size: 0x%x\n",\r\n(info->ConfigData.ATAConfig & ATACFG_BLOCKSIZE) >> 6);\r\nusb_stor_dbg(us, " Master/Slave Selection: 0x%x\n",\r\ninfo->ConfigData.ATAConfig & ATACFG_MASTER);\r\nusb_stor_dbg(us, " ATAPI Reset: 0x%x\n",\r\ninfo->ConfigData.ATAConfig & ATACFG_ATAPI_RESET);\r\nusb_stor_dbg(us, " ATA Timing: 0x%x\n",\r\ninfo->ConfigData.ATAConfig & ATACFG_TIMING);\r\nusb_stor_dbg(us, " ATA Major Command: 0x%x\n",\r\ninfo->ConfigData.ATAMajorCommand);\r\nusb_stor_dbg(us, " ATA Minor Command: 0x%x\n",\r\ninfo->ConfigData.ATAMinorCommand);\r\nusb_stor_dbg(us, " Init Status: 0x%x\n",\r\ninfo->ConfigData.ATAExtraConfig & ATACFGE_INIT_STATUS);\r\nusb_stor_dbg(us, " Config Descriptor 2: 0x%x\n",\r\ninfo->ConfigData.ATAExtraConfig & ATACFGE_CONF_DESC2);\r\nusb_stor_dbg(us, " Skip Device Boot: 0x%x\n",\r\ninfo->ConfigData.ATAExtraConfig & ATACFGE_SKIP_BOOT);\r\nusb_stor_dbg(us, " ATA 3 State Suspend: 0x%x\n",\r\ninfo->ConfigData.ATAExtraConfig & ATACFGE_STATE_SUSPEND);\r\nusb_stor_dbg(us, " Descriptor Override: 0x%x\n",\r\ninfo->ConfigData.ATAExtraConfig & ATACFGE_DESC_OVERRIDE);\r\nusb_stor_dbg(us, " Last LUN Identifier: 0x%x\n",\r\ninfo->ConfigData.ATAExtraConfig & ATACFGE_LAST_LUN);\r\nusb_stor_dbg(us, " SRST Enable: 0x%x\n",\r\ninfo->ConfigData.ATAExtraConfig & CFG_CAPABILITY_SRST);\r\n}\r\nstatic int isd200_write_config( struct us_data *us )\r\n{\r\nstruct isd200_info *info = (struct isd200_info *)us->extra;\r\nint retStatus = ISD200_GOOD;\r\nint result;\r\n#ifdef CONFIG_USB_STORAGE_DEBUG\r\nusb_stor_dbg(us, "Entering isd200_write_config\n");\r\nusb_stor_dbg(us, " Writing the following ISD200 Config Data:\n");\r\nisd200_log_config(us, info);\r\n#endif\r\nresult = usb_stor_ctrl_transfer(\r\nus,\r\nus->send_ctrl_pipe,\r\n0x01,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_OUT,\r\n0x0000,\r\n0x0002,\r\n(void *) &info->ConfigData,\r\nsizeof(info->ConfigData));\r\nif (result >= 0) {\r\nusb_stor_dbg(us, " ISD200 Config Data was written successfully\n");\r\n} else {\r\nusb_stor_dbg(us, " Request to write ISD200 Config Data failed!\n");\r\nretStatus = ISD200_ERROR;\r\n}\r\nusb_stor_dbg(us, "Leaving isd200_write_config %08X\n", retStatus);\r\nreturn retStatus;\r\n}\r\nstatic int isd200_read_config( struct us_data *us )\r\n{\r\nstruct isd200_info *info = (struct isd200_info *)us->extra;\r\nint retStatus = ISD200_GOOD;\r\nint result;\r\nusb_stor_dbg(us, "Entering isd200_read_config\n");\r\nresult = usb_stor_ctrl_transfer(\r\nus,\r\nus->recv_ctrl_pipe,\r\n0x02,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,\r\n0x0000,\r\n0x0002,\r\n(void *) &info->ConfigData,\r\nsizeof(info->ConfigData));\r\nif (result >= 0) {\r\nusb_stor_dbg(us, " Retrieved the following ISD200 Config Data:\n");\r\n#ifdef CONFIG_USB_STORAGE_DEBUG\r\nisd200_log_config(us, info);\r\n#endif\r\n} else {\r\nusb_stor_dbg(us, " Request to get ISD200 Config Data failed!\n");\r\nretStatus = ISD200_ERROR;\r\n}\r\nusb_stor_dbg(us, "Leaving isd200_read_config %08X\n", retStatus);\r\nreturn retStatus;\r\n}\r\nstatic int isd200_atapi_soft_reset( struct us_data *us )\r\n{\r\nint retStatus = ISD200_GOOD;\r\nint transferStatus;\r\nusb_stor_dbg(us, "Entering isd200_atapi_soft_reset\n");\r\ntransferStatus = isd200_action( us, ACTION_SOFT_RESET, NULL, 0 );\r\nif (transferStatus != ISD200_TRANSPORT_GOOD) {\r\nusb_stor_dbg(us, " Error issuing Atapi Soft Reset\n");\r\nretStatus = ISD200_ERROR;\r\n}\r\nusb_stor_dbg(us, "Leaving isd200_atapi_soft_reset %08X\n", retStatus);\r\nreturn retStatus;\r\n}\r\nstatic int isd200_srst( struct us_data *us )\r\n{\r\nint retStatus = ISD200_GOOD;\r\nint transferStatus;\r\nusb_stor_dbg(us, "Entering isd200_SRST\n");\r\ntransferStatus = isd200_action( us, ACTION_RESET, NULL, 0 );\r\nif (transferStatus != ISD200_TRANSPORT_GOOD) {\r\nusb_stor_dbg(us, " Error issuing SRST\n");\r\nretStatus = ISD200_ERROR;\r\n} else {\r\nmsleep(10);\r\ntransferStatus = isd200_action( us, ACTION_REENABLE, NULL, 0 );\r\nif (transferStatus != ISD200_TRANSPORT_GOOD) {\r\nusb_stor_dbg(us, " Error taking drive out of reset\n");\r\nretStatus = ISD200_ERROR;\r\n} else {\r\nmsleep(50);\r\n}\r\n}\r\nusb_stor_dbg(us, "Leaving isd200_srst %08X\n", retStatus);\r\nreturn retStatus;\r\n}\r\nstatic int isd200_try_enum(struct us_data *us, unsigned char master_slave,\r\nint detect )\r\n{\r\nint status = ISD200_GOOD;\r\nunsigned long endTime;\r\nstruct isd200_info *info = (struct isd200_info *)us->extra;\r\nunsigned char *regs = info->RegsBuf;\r\nint recheckAsMaster = 0;\r\nif ( detect )\r\nendTime = jiffies + ISD200_ENUM_DETECT_TIMEOUT * HZ;\r\nelse\r\nendTime = jiffies + ISD200_ENUM_BSY_TIMEOUT * HZ;\r\nwhile(1) {\r\nstatus = isd200_action( us, ACTION_ENUM, NULL, master_slave );\r\nif ( status != ISD200_GOOD )\r\nbreak;\r\nstatus = isd200_action( us, ACTION_READ_STATUS,\r\nregs, 8 );\r\nif ( status != ISD200_GOOD )\r\nbreak;\r\nif (!detect) {\r\nif (regs[ATA_REG_STATUS_OFFSET] & ATA_BUSY) {\r\nusb_stor_dbg(us, " %s status is still BSY, try again...\n",\r\nmaster_slave == ATA_ADDRESS_DEVHEAD_STD ?\r\n"Master" : "Slave");\r\n} else {\r\nusb_stor_dbg(us, " %s status !BSY, continue with next operation\n",\r\nmaster_slave == ATA_ADDRESS_DEVHEAD_STD ?\r\n"Master" : "Slave");\r\nbreak;\r\n}\r\n}\r\nelse if (regs[ATA_REG_STATUS_OFFSET] &\r\n(ATA_BUSY | ATA_DF | ATA_ERR)) {\r\nusb_stor_dbg(us, " Status indicates it is not ready, try again...\n");\r\n}\r\nelse if (regs[ATA_REG_STATUS_OFFSET] & ATA_DRDY) {\r\nusb_stor_dbg(us, " Identified ATA device\n");\r\ninfo->DeviceFlags |= DF_ATA_DEVICE;\r\ninfo->DeviceHead = master_slave;\r\nbreak;\r\n}\r\nelse if (regs[ATA_REG_HCYL_OFFSET] == 0xEB &&\r\nregs[ATA_REG_LCYL_OFFSET] == 0x14) {\r\nif ((master_slave & ATA_ADDRESS_DEVHEAD_SLAVE) &&\r\n!recheckAsMaster) {\r\nusb_stor_dbg(us, " Identified ATAPI device as slave. Rechecking again as master\n");\r\nrecheckAsMaster = 1;\r\nmaster_slave = ATA_ADDRESS_DEVHEAD_STD;\r\n} else {\r\nusb_stor_dbg(us, " Identified ATAPI device\n");\r\ninfo->DeviceHead = master_slave;\r\nstatus = isd200_atapi_soft_reset(us);\r\nbreak;\r\n}\r\n} else {\r\nusb_stor_dbg(us, " Not ATA, not ATAPI - Weird\n");\r\nbreak;\r\n}\r\nif (time_after_eq(jiffies, endTime)) {\r\nif (!detect)\r\nusb_stor_dbg(us, " BSY check timeout, just continue with next operation...\n");\r\nelse\r\nusb_stor_dbg(us, " Device detect timeout!\n");\r\nbreak;\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic int isd200_manual_enum(struct us_data *us)\r\n{\r\nstruct isd200_info *info = (struct isd200_info *)us->extra;\r\nint retStatus = ISD200_GOOD;\r\nusb_stor_dbg(us, "Entering isd200_manual_enum\n");\r\nretStatus = isd200_read_config(us);\r\nif (retStatus == ISD200_GOOD) {\r\nint isslave;\r\nretStatus = isd200_try_enum( us, ATA_ADDRESS_DEVHEAD_STD, 0);\r\nif (retStatus == ISD200_GOOD)\r\nretStatus = isd200_try_enum( us, ATA_ADDRESS_DEVHEAD_SLAVE, 0);\r\nif (retStatus == ISD200_GOOD) {\r\nretStatus = isd200_srst(us);\r\nif (retStatus == ISD200_GOOD)\r\nretStatus = isd200_try_enum( us, ATA_ADDRESS_DEVHEAD_STD, 1);\r\n}\r\nisslave = (info->DeviceHead & ATA_ADDRESS_DEVHEAD_SLAVE) ? 1 : 0;\r\nif (!(info->ConfigData.ATAConfig & ATACFG_MASTER)) {\r\nusb_stor_dbg(us, " Setting Master/Slave selection to %d\n",\r\nisslave);\r\ninfo->ConfigData.ATAConfig &= 0x3f;\r\ninfo->ConfigData.ATAConfig |= (isslave<<6);\r\nretStatus = isd200_write_config(us);\r\n}\r\n}\r\nusb_stor_dbg(us, "Leaving isd200_manual_enum %08X\n", retStatus);\r\nreturn(retStatus);\r\n}\r\nstatic void isd200_fix_driveid(u16 *id)\r\n{\r\n#ifndef __LITTLE_ENDIAN\r\n# ifdef __BIG_ENDIAN\r\nint i;\r\nfor (i = 0; i < ATA_ID_WORDS; i++)\r\nid[i] = __le16_to_cpu(id[i]);\r\n# else\r\n# error "Please fix <asm/byteorder.h>"\r\n# endif\r\n#endif\r\n}\r\nstatic void isd200_dump_driveid(struct us_data *us, u16 *id)\r\n{\r\nusb_stor_dbg(us, " Identify Data Structure:\n");\r\nusb_stor_dbg(us, " config = 0x%x\n", id[ATA_ID_CONFIG]);\r\nusb_stor_dbg(us, " cyls = 0x%x\n", id[ATA_ID_CYLS]);\r\nusb_stor_dbg(us, " heads = 0x%x\n", id[ATA_ID_HEADS]);\r\nusb_stor_dbg(us, " track_bytes = 0x%x\n", id[4]);\r\nusb_stor_dbg(us, " sector_bytes = 0x%x\n", id[5]);\r\nusb_stor_dbg(us, " sectors = 0x%x\n", id[ATA_ID_SECTORS]);\r\nusb_stor_dbg(us, " serial_no[0] = 0x%x\n", *(char *)&id[ATA_ID_SERNO]);\r\nusb_stor_dbg(us, " buf_type = 0x%x\n", id[20]);\r\nusb_stor_dbg(us, " buf_size = 0x%x\n", id[ATA_ID_BUF_SIZE]);\r\nusb_stor_dbg(us, " ecc_bytes = 0x%x\n", id[22]);\r\nusb_stor_dbg(us, " fw_rev[0] = 0x%x\n", *(char *)&id[ATA_ID_FW_REV]);\r\nusb_stor_dbg(us, " model[0] = 0x%x\n", *(char *)&id[ATA_ID_PROD]);\r\nusb_stor_dbg(us, " max_multsect = 0x%x\n", id[ATA_ID_MAX_MULTSECT] & 0xff);\r\nusb_stor_dbg(us, " dword_io = 0x%x\n", id[ATA_ID_DWORD_IO]);\r\nusb_stor_dbg(us, " capability = 0x%x\n", id[ATA_ID_CAPABILITY] >> 8);\r\nusb_stor_dbg(us, " tPIO = 0x%x\n", id[ATA_ID_OLD_PIO_MODES] >> 8);\r\nusb_stor_dbg(us, " tDMA = 0x%x\n", id[ATA_ID_OLD_DMA_MODES] >> 8);\r\nusb_stor_dbg(us, " field_valid = 0x%x\n", id[ATA_ID_FIELD_VALID]);\r\nusb_stor_dbg(us, " cur_cyls = 0x%x\n", id[ATA_ID_CUR_CYLS]);\r\nusb_stor_dbg(us, " cur_heads = 0x%x\n", id[ATA_ID_CUR_HEADS]);\r\nusb_stor_dbg(us, " cur_sectors = 0x%x\n", id[ATA_ID_CUR_SECTORS]);\r\nusb_stor_dbg(us, " cur_capacity = 0x%x\n", ata_id_u32(id, 57));\r\nusb_stor_dbg(us, " multsect = 0x%x\n", id[ATA_ID_MULTSECT] & 0xff);\r\nusb_stor_dbg(us, " lba_capacity = 0x%x\n", ata_id_u32(id, ATA_ID_LBA_CAPACITY));\r\nusb_stor_dbg(us, " command_set_1 = 0x%x\n", id[ATA_ID_COMMAND_SET_1]);\r\nusb_stor_dbg(us, " command_set_2 = 0x%x\n", id[ATA_ID_COMMAND_SET_2]);\r\n}\r\nstatic int isd200_get_inquiry_data( struct us_data *us )\r\n{\r\nstruct isd200_info *info = (struct isd200_info *)us->extra;\r\nint retStatus = ISD200_GOOD;\r\nu16 *id = info->id;\r\nusb_stor_dbg(us, "Entering isd200_get_inquiry_data\n");\r\ninfo->DeviceHead = ATA_ADDRESS_DEVHEAD_STD;\r\nretStatus = isd200_manual_enum(us);\r\nif (retStatus == ISD200_GOOD) {\r\nint transferStatus;\r\nif (info->DeviceFlags & DF_ATA_DEVICE) {\r\ntransferStatus = isd200_action( us, ACTION_IDENTIFY,\r\nid, ATA_ID_WORDS * 2);\r\nif (transferStatus != ISD200_TRANSPORT_GOOD) {\r\nusb_stor_dbg(us, " Error issuing ATA Command Identify\n");\r\nretStatus = ISD200_ERROR;\r\n} else {\r\nint i;\r\n__be16 *src;\r\n__u16 *dest;\r\nisd200_fix_driveid(id);\r\nisd200_dump_driveid(us, id);\r\nmemset(&info->InquiryData, 0, sizeof(info->InquiryData));\r\ninfo->InquiryData.DeviceType = DIRECT_ACCESS_DEVICE;\r\ninfo->InquiryData.AdditionalLength = 0x1F;\r\nif (id[ATA_ID_COMMAND_SET_1] & COMMANDSET_MEDIA_STATUS) {\r\ninfo->InquiryData.DeviceTypeModifier = DEVICE_REMOVABLE;\r\ninfo->DeviceFlags |= DF_REMOVABLE_MEDIA;\r\n}\r\nsrc = (__be16 *)&id[ATA_ID_PROD];\r\ndest = (__u16*)info->InquiryData.VendorId;\r\nfor (i=0;i<4;i++)\r\ndest[i] = be16_to_cpu(src[i]);\r\nsrc = (__be16 *)&id[ATA_ID_PROD + 8/2];\r\ndest = (__u16*)info->InquiryData.ProductId;\r\nfor (i=0;i<8;i++)\r\ndest[i] = be16_to_cpu(src[i]);\r\nsrc = (__be16 *)&id[ATA_ID_FW_REV];\r\ndest = (__u16*)info->InquiryData.ProductRevisionLevel;\r\nfor (i=0;i<2;i++)\r\ndest[i] = be16_to_cpu(src[i]);\r\nif (id[ATA_ID_COMMAND_SET_2] & COMMANDSET_MEDIA_STATUS) {\r\nusb_stor_dbg(us, " Device supports Media Status Notification\n");\r\ninfo->DeviceFlags |= DF_MEDIA_STATUS_ENABLED;\r\n}\r\nelse\r\ninfo->DeviceFlags &= ~DF_MEDIA_STATUS_ENABLED;\r\n}\r\n} else {\r\nus->protocol_name = "Transparent SCSI";\r\nus->proto_handler = usb_stor_transparent_scsi_command;\r\nusb_stor_dbg(us, "Protocol changed to: %s\n",\r\nus->protocol_name);\r\nus->extra_destructor(info);\r\nkfree(info);\r\nus->extra = NULL;\r\nus->extra_destructor = NULL;\r\n}\r\n}\r\nusb_stor_dbg(us, "Leaving isd200_get_inquiry_data %08X\n", retStatus);\r\nreturn(retStatus);\r\n}\r\nstatic int isd200_scsi_to_ata(struct scsi_cmnd *srb, struct us_data *us,\r\nunion ata_cdb * ataCdb)\r\n{\r\nstruct isd200_info *info = (struct isd200_info *)us->extra;\r\nu16 *id = info->id;\r\nint sendToTransport = 1;\r\nunsigned char sectnum, head;\r\nunsigned short cylinder;\r\nunsigned long lba;\r\nunsigned long blockCount;\r\nunsigned char senseData[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };\r\nmemset(ataCdb, 0, sizeof(union ata_cdb));\r\nswitch (srb->cmnd[0]) {\r\ncase INQUIRY:\r\nusb_stor_dbg(us, " ATA OUT - INQUIRY\n");\r\nusb_stor_set_xfer_buf((unsigned char *) &info->InquiryData,\r\nsizeof(info->InquiryData), srb);\r\nsrb->result = SAM_STAT_GOOD;\r\nsendToTransport = 0;\r\nbreak;\r\ncase MODE_SENSE:\r\nusb_stor_dbg(us, " ATA OUT - SCSIOP_MODE_SENSE\n");\r\nusb_stor_set_xfer_buf(senseData, sizeof(senseData), srb);\r\nif (info->DeviceFlags & DF_MEDIA_STATUS_ENABLED)\r\n{\r\nataCdb->generic.SignatureByte0 = info->ConfigData.ATAMajorCommand;\r\nataCdb->generic.SignatureByte1 = info->ConfigData.ATAMinorCommand;\r\nataCdb->generic.TransferBlockSize = 1;\r\nataCdb->generic.RegisterSelect = REG_COMMAND;\r\nataCdb->write.CommandByte = ATA_COMMAND_GET_MEDIA_STATUS;\r\nisd200_srb_set_bufflen(srb, 0);\r\n} else {\r\nusb_stor_dbg(us, " Media Status not supported, just report okay\n");\r\nsrb->result = SAM_STAT_GOOD;\r\nsendToTransport = 0;\r\n}\r\nbreak;\r\ncase TEST_UNIT_READY:\r\nusb_stor_dbg(us, " ATA OUT - SCSIOP_TEST_UNIT_READY\n");\r\nif (info->DeviceFlags & DF_MEDIA_STATUS_ENABLED)\r\n{\r\nataCdb->generic.SignatureByte0 = info->ConfigData.ATAMajorCommand;\r\nataCdb->generic.SignatureByte1 = info->ConfigData.ATAMinorCommand;\r\nataCdb->generic.TransferBlockSize = 1;\r\nataCdb->generic.RegisterSelect = REG_COMMAND;\r\nataCdb->write.CommandByte = ATA_COMMAND_GET_MEDIA_STATUS;\r\nisd200_srb_set_bufflen(srb, 0);\r\n} else {\r\nusb_stor_dbg(us, " Media Status not supported, just report okay\n");\r\nsrb->result = SAM_STAT_GOOD;\r\nsendToTransport = 0;\r\n}\r\nbreak;\r\ncase READ_CAPACITY:\r\n{\r\nunsigned long capacity;\r\nstruct read_capacity_data readCapacityData;\r\nusb_stor_dbg(us, " ATA OUT - SCSIOP_READ_CAPACITY\n");\r\nif (ata_id_has_lba(id))\r\ncapacity = ata_id_u32(id, ATA_ID_LBA_CAPACITY) - 1;\r\nelse\r\ncapacity = (id[ATA_ID_HEADS] * id[ATA_ID_CYLS] *\r\nid[ATA_ID_SECTORS]) - 1;\r\nreadCapacityData.LogicalBlockAddress = cpu_to_be32(capacity);\r\nreadCapacityData.BytesPerBlock = cpu_to_be32(0x200);\r\nusb_stor_set_xfer_buf((unsigned char *) &readCapacityData,\r\nsizeof(readCapacityData), srb);\r\nsrb->result = SAM_STAT_GOOD;\r\nsendToTransport = 0;\r\n}\r\nbreak;\r\ncase READ_10:\r\nusb_stor_dbg(us, " ATA OUT - SCSIOP_READ\n");\r\nlba = be32_to_cpu(*(__be32 *)&srb->cmnd[2]);\r\nblockCount = (unsigned long)srb->cmnd[7]<<8 | (unsigned long)srb->cmnd[8];\r\nif (ata_id_has_lba(id)) {\r\nsectnum = (unsigned char)(lba);\r\ncylinder = (unsigned short)(lba>>8);\r\nhead = ATA_ADDRESS_DEVHEAD_LBA_MODE | (unsigned char)(lba>>24 & 0x0F);\r\n} else {\r\nsectnum = (u8)((lba % id[ATA_ID_SECTORS]) + 1);\r\ncylinder = (u16)(lba / (id[ATA_ID_SECTORS] *\r\nid[ATA_ID_HEADS]));\r\nhead = (u8)((lba / id[ATA_ID_SECTORS]) %\r\nid[ATA_ID_HEADS]);\r\n}\r\nataCdb->generic.SignatureByte0 = info->ConfigData.ATAMajorCommand;\r\nataCdb->generic.SignatureByte1 = info->ConfigData.ATAMinorCommand;\r\nataCdb->generic.TransferBlockSize = 1;\r\nataCdb->generic.RegisterSelect =\r\nREG_SECTOR_COUNT | REG_SECTOR_NUMBER |\r\nREG_CYLINDER_LOW | REG_CYLINDER_HIGH |\r\nREG_DEVICE_HEAD | REG_COMMAND;\r\nataCdb->write.SectorCountByte = (unsigned char)blockCount;\r\nataCdb->write.SectorNumberByte = sectnum;\r\nataCdb->write.CylinderHighByte = (unsigned char)(cylinder>>8);\r\nataCdb->write.CylinderLowByte = (unsigned char)cylinder;\r\nataCdb->write.DeviceHeadByte = (head | ATA_ADDRESS_DEVHEAD_STD);\r\nataCdb->write.CommandByte = ATA_CMD_PIO_READ;\r\nbreak;\r\ncase WRITE_10:\r\nusb_stor_dbg(us, " ATA OUT - SCSIOP_WRITE\n");\r\nlba = be32_to_cpu(*(__be32 *)&srb->cmnd[2]);\r\nblockCount = (unsigned long)srb->cmnd[7]<<8 | (unsigned long)srb->cmnd[8];\r\nif (ata_id_has_lba(id)) {\r\nsectnum = (unsigned char)(lba);\r\ncylinder = (unsigned short)(lba>>8);\r\nhead = ATA_ADDRESS_DEVHEAD_LBA_MODE | (unsigned char)(lba>>24 & 0x0F);\r\n} else {\r\nsectnum = (u8)((lba % id[ATA_ID_SECTORS]) + 1);\r\ncylinder = (u16)(lba / (id[ATA_ID_SECTORS] *\r\nid[ATA_ID_HEADS]));\r\nhead = (u8)((lba / id[ATA_ID_SECTORS]) %\r\nid[ATA_ID_HEADS]);\r\n}\r\nataCdb->generic.SignatureByte0 = info->ConfigData.ATAMajorCommand;\r\nataCdb->generic.SignatureByte1 = info->ConfigData.ATAMinorCommand;\r\nataCdb->generic.TransferBlockSize = 1;\r\nataCdb->generic.RegisterSelect =\r\nREG_SECTOR_COUNT | REG_SECTOR_NUMBER |\r\nREG_CYLINDER_LOW | REG_CYLINDER_HIGH |\r\nREG_DEVICE_HEAD | REG_COMMAND;\r\nataCdb->write.SectorCountByte = (unsigned char)blockCount;\r\nataCdb->write.SectorNumberByte = sectnum;\r\nataCdb->write.CylinderHighByte = (unsigned char)(cylinder>>8);\r\nataCdb->write.CylinderLowByte = (unsigned char)cylinder;\r\nataCdb->write.DeviceHeadByte = (head | ATA_ADDRESS_DEVHEAD_STD);\r\nataCdb->write.CommandByte = ATA_CMD_PIO_WRITE;\r\nbreak;\r\ncase ALLOW_MEDIUM_REMOVAL:\r\nusb_stor_dbg(us, " ATA OUT - SCSIOP_MEDIUM_REMOVAL\n");\r\nif (info->DeviceFlags & DF_REMOVABLE_MEDIA) {\r\nusb_stor_dbg(us, " srb->cmnd[4] = 0x%X\n",\r\nsrb->cmnd[4]);\r\nataCdb->generic.SignatureByte0 = info->ConfigData.ATAMajorCommand;\r\nataCdb->generic.SignatureByte1 = info->ConfigData.ATAMinorCommand;\r\nataCdb->generic.TransferBlockSize = 1;\r\nataCdb->generic.RegisterSelect = REG_COMMAND;\r\nataCdb->write.CommandByte = (srb->cmnd[4] & 0x1) ?\r\nATA_CMD_MEDIA_LOCK : ATA_CMD_MEDIA_UNLOCK;\r\nisd200_srb_set_bufflen(srb, 0);\r\n} else {\r\nusb_stor_dbg(us, " Not removeable media, just report okay\n");\r\nsrb->result = SAM_STAT_GOOD;\r\nsendToTransport = 0;\r\n}\r\nbreak;\r\ncase START_STOP:\r\nusb_stor_dbg(us, " ATA OUT - SCSIOP_START_STOP_UNIT\n");\r\nusb_stor_dbg(us, " srb->cmnd[4] = 0x%X\n", srb->cmnd[4]);\r\nif ((srb->cmnd[4] & 0x3) == 0x2) {\r\nusb_stor_dbg(us, " Media Eject\n");\r\nataCdb->generic.SignatureByte0 = info->ConfigData.ATAMajorCommand;\r\nataCdb->generic.SignatureByte1 = info->ConfigData.ATAMinorCommand;\r\nataCdb->generic.TransferBlockSize = 0;\r\nataCdb->generic.RegisterSelect = REG_COMMAND;\r\nataCdb->write.CommandByte = ATA_COMMAND_MEDIA_EJECT;\r\n} else if ((srb->cmnd[4] & 0x3) == 0x1) {\r\nusb_stor_dbg(us, " Get Media Status\n");\r\nataCdb->generic.SignatureByte0 = info->ConfigData.ATAMajorCommand;\r\nataCdb->generic.SignatureByte1 = info->ConfigData.ATAMinorCommand;\r\nataCdb->generic.TransferBlockSize = 1;\r\nataCdb->generic.RegisterSelect = REG_COMMAND;\r\nataCdb->write.CommandByte = ATA_COMMAND_GET_MEDIA_STATUS;\r\nisd200_srb_set_bufflen(srb, 0);\r\n} else {\r\nusb_stor_dbg(us, " Nothing to do, just report okay\n");\r\nsrb->result = SAM_STAT_GOOD;\r\nsendToTransport = 0;\r\n}\r\nbreak;\r\ndefault:\r\nusb_stor_dbg(us, "Unsupported SCSI command - 0x%X\n",\r\nsrb->cmnd[0]);\r\nsrb->result = DID_ERROR << 16;\r\nsendToTransport = 0;\r\nbreak;\r\n}\r\nreturn(sendToTransport);\r\n}\r\nstatic void isd200_free_info_ptrs(void *info_)\r\n{\r\nstruct isd200_info *info = (struct isd200_info *) info_;\r\nif (info) {\r\nkfree(info->id);\r\nkfree(info->RegsBuf);\r\nkfree(info->srb.sense_buffer);\r\n}\r\n}\r\nstatic int isd200_init_info(struct us_data *us)\r\n{\r\nstruct isd200_info *info;\r\ninfo = kzalloc(sizeof(struct isd200_info), GFP_KERNEL);\r\nif (!info)\r\nreturn ISD200_ERROR;\r\ninfo->id = kzalloc(ATA_ID_WORDS * 2, GFP_KERNEL);\r\ninfo->RegsBuf = kmalloc(sizeof(info->ATARegs), GFP_KERNEL);\r\ninfo->srb.sense_buffer = kmalloc(SCSI_SENSE_BUFFERSIZE, GFP_KERNEL);\r\nif (!info->id || !info->RegsBuf || !info->srb.sense_buffer) {\r\nisd200_free_info_ptrs(info);\r\nkfree(info);\r\nreturn ISD200_ERROR;\r\n}\r\nus->extra = info;\r\nus->extra_destructor = isd200_free_info_ptrs;\r\nreturn ISD200_GOOD;\r\n}\r\nstatic int isd200_Initialization(struct us_data *us)\r\n{\r\nusb_stor_dbg(us, "ISD200 Initialization...\n");\r\nif (isd200_init_info(us) == ISD200_ERROR) {\r\nusb_stor_dbg(us, "ERROR Initializing ISD200 Info struct\n");\r\n} else {\r\nif (isd200_get_inquiry_data(us) != ISD200_GOOD)\r\nusb_stor_dbg(us, "ISD200 Initialization Failure\n");\r\nelse\r\nusb_stor_dbg(us, "ISD200 Initialization complete\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic void isd200_ata_command(struct scsi_cmnd *srb, struct us_data *us)\r\n{\r\nint sendToTransport = 1, orig_bufflen;\r\nunion ata_cdb ataCdb;\r\nif (us->extra == NULL) {\r\nusb_stor_dbg(us, "ERROR Driver not initialized\n");\r\nsrb->result = DID_ERROR << 16;\r\nreturn;\r\n}\r\nscsi_set_resid(srb, 0);\r\norig_bufflen = scsi_bufflen(srb);\r\nsendToTransport = isd200_scsi_to_ata(srb, us, &ataCdb);\r\nif (sendToTransport)\r\nisd200_invoke_transport(us, srb, &ataCdb);\r\nisd200_srb_set_bufflen(srb, orig_bufflen);\r\n}\r\nstatic int isd200_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct us_data *us;\r\nint result;\r\nresult = usb_stor_probe1(&us, intf, id,\r\n(id - isd200_usb_ids) + isd200_unusual_dev_list,\r\n&isd200_host_template);\r\nif (result)\r\nreturn result;\r\nus->protocol_name = "ISD200 ATA/ATAPI";\r\nus->proto_handler = isd200_ata_command;\r\nresult = usb_stor_probe2(us);\r\nreturn result;\r\n}
