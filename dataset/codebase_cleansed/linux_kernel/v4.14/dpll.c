static void __init _register_dpll(struct clk_hw *hw,\r\nstruct device_node *node)\r\n{\r\nstruct clk_hw_omap *clk_hw = to_clk_hw_omap(hw);\r\nstruct dpll_data *dd = clk_hw->dpll_data;\r\nstruct clk *clk;\r\nclk = of_clk_get(node, 0);\r\nif (IS_ERR(clk)) {\r\npr_debug("clk-ref missing for %s, retry later\n",\r\nnode->name);\r\nif (!ti_clk_retry_init(node, hw, _register_dpll))\r\nreturn;\r\ngoto cleanup;\r\n}\r\ndd->clk_ref = __clk_get_hw(clk);\r\nclk = of_clk_get(node, 1);\r\nif (IS_ERR(clk)) {\r\npr_debug("clk-bypass missing for %s, retry later\n",\r\nnode->name);\r\nif (!ti_clk_retry_init(node, hw, _register_dpll))\r\nreturn;\r\ngoto cleanup;\r\n}\r\ndd->clk_bypass = __clk_get_hw(clk);\r\nclk = ti_clk_register(NULL, &clk_hw->hw, node->name);\r\nif (!IS_ERR(clk)) {\r\nomap2_init_clk_hw_omap_clocks(&clk_hw->hw);\r\nof_clk_add_provider(node, of_clk_src_simple_get, clk);\r\nkfree(clk_hw->hw.init->parent_names);\r\nkfree(clk_hw->hw.init);\r\nreturn;\r\n}\r\ncleanup:\r\nkfree(clk_hw->dpll_data);\r\nkfree(clk_hw->hw.init->parent_names);\r\nkfree(clk_hw->hw.init);\r\nkfree(clk_hw);\r\n}\r\nvoid _get_reg(u8 module, u16 offset, struct clk_omap_reg *reg)\r\n{\r\nreg->index = module;\r\nreg->offset = offset;\r\n}\r\nstruct clk *ti_clk_register_dpll(struct ti_clk *setup)\r\n{\r\nstruct clk_hw_omap *clk_hw;\r\nstruct clk_init_data init = { NULL };\r\nstruct dpll_data *dd;\r\nstruct clk *clk;\r\nstruct ti_clk_dpll *dpll;\r\nconst struct clk_ops *ops = &omap3_dpll_ck_ops;\r\nstruct clk *clk_ref;\r\nstruct clk *clk_bypass;\r\ndpll = setup->data;\r\nif (dpll->num_parents < 2)\r\nreturn ERR_PTR(-EINVAL);\r\nclk_ref = clk_get_sys(NULL, dpll->parents[0]);\r\nclk_bypass = clk_get_sys(NULL, dpll->parents[1]);\r\nif (IS_ERR_OR_NULL(clk_ref) || IS_ERR_OR_NULL(clk_bypass))\r\nreturn ERR_PTR(-EAGAIN);\r\ndd = kzalloc(sizeof(*dd), GFP_KERNEL);\r\nclk_hw = kzalloc(sizeof(*clk_hw), GFP_KERNEL);\r\nif (!dd || !clk_hw) {\r\nclk = ERR_PTR(-ENOMEM);\r\ngoto cleanup;\r\n}\r\nclk_hw->dpll_data = dd;\r\nclk_hw->ops = &clkhwops_omap3_dpll;\r\nclk_hw->hw.init = &init;\r\ninit.name = setup->name;\r\ninit.ops = ops;\r\ninit.num_parents = dpll->num_parents;\r\ninit.parent_names = dpll->parents;\r\n_get_reg(dpll->module, dpll->control_reg, &dd->control_reg);\r\n_get_reg(dpll->module, dpll->idlest_reg, &dd->idlest_reg);\r\n_get_reg(dpll->module, dpll->mult_div1_reg, &dd->mult_div1_reg);\r\n_get_reg(dpll->module, dpll->autoidle_reg, &dd->autoidle_reg);\r\ndd->modes = dpll->modes;\r\ndd->div1_mask = dpll->div1_mask;\r\ndd->idlest_mask = dpll->idlest_mask;\r\ndd->mult_mask = dpll->mult_mask;\r\ndd->autoidle_mask = dpll->autoidle_mask;\r\ndd->enable_mask = dpll->enable_mask;\r\ndd->sddiv_mask = dpll->sddiv_mask;\r\ndd->dco_mask = dpll->dco_mask;\r\ndd->max_divider = dpll->max_divider;\r\ndd->min_divider = dpll->min_divider;\r\ndd->max_multiplier = dpll->max_multiplier;\r\ndd->auto_recal_bit = dpll->auto_recal_bit;\r\ndd->recal_en_bit = dpll->recal_en_bit;\r\ndd->recal_st_bit = dpll->recal_st_bit;\r\ndd->clk_ref = __clk_get_hw(clk_ref);\r\ndd->clk_bypass = __clk_get_hw(clk_bypass);\r\nif (dpll->flags & CLKF_CORE)\r\nops = &omap3_dpll_core_ck_ops;\r\nif (dpll->flags & CLKF_PER)\r\nops = &omap3_dpll_per_ck_ops;\r\nif (dpll->flags & CLKF_J_TYPE)\r\ndd->flags |= DPLL_J_TYPE;\r\nclk = ti_clk_register(NULL, &clk_hw->hw, setup->name);\r\nif (!IS_ERR(clk))\r\nreturn clk;\r\ncleanup:\r\nkfree(dd);\r\nkfree(clk_hw);\r\nreturn clk;\r\n}\r\nstatic void _register_dpll_x2(struct device_node *node,\r\nconst struct clk_ops *ops,\r\nconst struct clk_hw_omap_ops *hw_ops)\r\n{\r\nstruct clk *clk;\r\nstruct clk_init_data init = { NULL };\r\nstruct clk_hw_omap *clk_hw;\r\nconst char *name = node->name;\r\nconst char *parent_name;\r\nparent_name = of_clk_get_parent_name(node, 0);\r\nif (!parent_name) {\r\npr_err("%s must have parent\n", node->name);\r\nreturn;\r\n}\r\nclk_hw = kzalloc(sizeof(*clk_hw), GFP_KERNEL);\r\nif (!clk_hw)\r\nreturn;\r\nclk_hw->ops = hw_ops;\r\nclk_hw->hw.init = &init;\r\ninit.name = name;\r\ninit.ops = ops;\r\ninit.parent_names = &parent_name;\r\ninit.num_parents = 1;\r\n#if defined(CONFIG_ARCH_OMAP4) || defined(CONFIG_SOC_OMAP5) || \\r\ndefined(CONFIG_SOC_DRA7XX)\r\nif (hw_ops == &clkhwops_omap4_dpllmx) {\r\nint ret;\r\nret = of_property_count_elems_of_size(node, "reg", 1);\r\nif (ret <= 0) {\r\nclk_hw->ops = NULL;\r\n} else if (ti_clk_get_reg_addr(node, 0, &clk_hw->clksel_reg)) {\r\nkfree(clk_hw);\r\nreturn;\r\n}\r\n}\r\n#endif\r\nclk = ti_clk_register(NULL, &clk_hw->hw, name);\r\nif (IS_ERR(clk)) {\r\nkfree(clk_hw);\r\n} else {\r\nomap2_init_clk_hw_omap_clocks(&clk_hw->hw);\r\nof_clk_add_provider(node, of_clk_src_simple_get, clk);\r\n}\r\n}\r\nstatic void __init of_ti_dpll_setup(struct device_node *node,\r\nconst struct clk_ops *ops,\r\nconst struct dpll_data *ddt)\r\n{\r\nstruct clk_hw_omap *clk_hw = NULL;\r\nstruct clk_init_data *init = NULL;\r\nconst char **parent_names = NULL;\r\nstruct dpll_data *dd = NULL;\r\nu8 dpll_mode = 0;\r\ndd = kzalloc(sizeof(*dd), GFP_KERNEL);\r\nclk_hw = kzalloc(sizeof(*clk_hw), GFP_KERNEL);\r\ninit = kzalloc(sizeof(*init), GFP_KERNEL);\r\nif (!dd || !clk_hw || !init)\r\ngoto cleanup;\r\nmemcpy(dd, ddt, sizeof(*dd));\r\nclk_hw->dpll_data = dd;\r\nclk_hw->ops = &clkhwops_omap3_dpll;\r\nclk_hw->hw.init = init;\r\ninit->name = node->name;\r\ninit->ops = ops;\r\ninit->num_parents = of_clk_get_parent_count(node);\r\nif (!init->num_parents) {\r\npr_err("%s must have parent(s)\n", node->name);\r\ngoto cleanup;\r\n}\r\nparent_names = kzalloc(sizeof(char *) * init->num_parents, GFP_KERNEL);\r\nif (!parent_names)\r\ngoto cleanup;\r\nof_clk_parent_fill(node, parent_names, init->num_parents);\r\ninit->parent_names = parent_names;\r\nif (ti_clk_get_reg_addr(node, 0, &dd->control_reg))\r\ngoto cleanup;\r\nif (!dd->idlest_mask) {\r\nif (ti_clk_get_reg_addr(node, 1, &dd->mult_div1_reg))\r\ngoto cleanup;\r\n#ifdef CONFIG_ARCH_OMAP2\r\nclk_hw->ops = &clkhwops_omap2xxx_dpll;\r\nomap2xxx_clkt_dpllcore_init(&clk_hw->hw);\r\n#endif\r\n} else {\r\nif (ti_clk_get_reg_addr(node, 1, &dd->idlest_reg))\r\ngoto cleanup;\r\nif (ti_clk_get_reg_addr(node, 2, &dd->mult_div1_reg))\r\ngoto cleanup;\r\n}\r\nif (dd->autoidle_mask) {\r\nif (ti_clk_get_reg_addr(node, 3, &dd->autoidle_reg))\r\ngoto cleanup;\r\n}\r\nif (of_property_read_bool(node, "ti,low-power-stop"))\r\ndpll_mode |= 1 << DPLL_LOW_POWER_STOP;\r\nif (of_property_read_bool(node, "ti,low-power-bypass"))\r\ndpll_mode |= 1 << DPLL_LOW_POWER_BYPASS;\r\nif (of_property_read_bool(node, "ti,lock"))\r\ndpll_mode |= 1 << DPLL_LOCKED;\r\nif (dpll_mode)\r\ndd->modes = dpll_mode;\r\n_register_dpll(&clk_hw->hw, node);\r\nreturn;\r\ncleanup:\r\nkfree(dd);\r\nkfree(parent_names);\r\nkfree(init);\r\nkfree(clk_hw);\r\n}\r\nstatic void __init of_ti_omap4_dpll_x2_setup(struct device_node *node)\r\n{\r\n_register_dpll_x2(node, &dpll_x2_ck_ops, &clkhwops_omap4_dpllmx);\r\n}\r\nstatic void __init of_ti_am3_dpll_x2_setup(struct device_node *node)\r\n{\r\n_register_dpll_x2(node, &dpll_x2_ck_ops, NULL);\r\n}\r\nstatic void __init of_ti_omap3_dpll_setup(struct device_node *node)\r\n{\r\nconst struct dpll_data dd = {\r\n.idlest_mask = 0x1,\r\n.enable_mask = 0x7,\r\n.autoidle_mask = 0x7,\r\n.mult_mask = 0x7ff << 8,\r\n.div1_mask = 0x7f,\r\n.max_multiplier = 2047,\r\n.max_divider = 128,\r\n.min_divider = 1,\r\n.freqsel_mask = 0xf0,\r\n.modes = (1 << DPLL_LOW_POWER_BYPASS) | (1 << DPLL_LOCKED),\r\n};\r\nif ((of_machine_is_compatible("ti,omap3630") ||\r\nof_machine_is_compatible("ti,omap36xx")) &&\r\n!strcmp(node->name, "dpll5_ck"))\r\nof_ti_dpll_setup(node, &omap3_dpll5_ck_ops, &dd);\r\nelse\r\nof_ti_dpll_setup(node, &omap3_dpll_ck_ops, &dd);\r\n}\r\nstatic void __init of_ti_omap3_core_dpll_setup(struct device_node *node)\r\n{\r\nconst struct dpll_data dd = {\r\n.idlest_mask = 0x1,\r\n.enable_mask = 0x7,\r\n.autoidle_mask = 0x7,\r\n.mult_mask = 0x7ff << 16,\r\n.div1_mask = 0x7f << 8,\r\n.max_multiplier = 2047,\r\n.max_divider = 128,\r\n.min_divider = 1,\r\n.freqsel_mask = 0xf0,\r\n};\r\nof_ti_dpll_setup(node, &omap3_dpll_core_ck_ops, &dd);\r\n}\r\nstatic void __init of_ti_omap3_per_dpll_setup(struct device_node *node)\r\n{\r\nconst struct dpll_data dd = {\r\n.idlest_mask = 0x1 << 1,\r\n.enable_mask = 0x7 << 16,\r\n.autoidle_mask = 0x7 << 3,\r\n.mult_mask = 0x7ff << 8,\r\n.div1_mask = 0x7f,\r\n.max_multiplier = 2047,\r\n.max_divider = 128,\r\n.min_divider = 1,\r\n.freqsel_mask = 0xf00000,\r\n.modes = (1 << DPLL_LOW_POWER_STOP) | (1 << DPLL_LOCKED),\r\n};\r\nof_ti_dpll_setup(node, &omap3_dpll_per_ck_ops, &dd);\r\n}\r\nstatic void __init of_ti_omap3_per_jtype_dpll_setup(struct device_node *node)\r\n{\r\nconst struct dpll_data dd = {\r\n.idlest_mask = 0x1 << 1,\r\n.enable_mask = 0x7 << 16,\r\n.autoidle_mask = 0x7 << 3,\r\n.mult_mask = 0xfff << 8,\r\n.div1_mask = 0x7f,\r\n.max_multiplier = 4095,\r\n.max_divider = 128,\r\n.min_divider = 1,\r\n.sddiv_mask = 0xff << 24,\r\n.dco_mask = 0xe << 20,\r\n.flags = DPLL_J_TYPE,\r\n.modes = (1 << DPLL_LOW_POWER_STOP) | (1 << DPLL_LOCKED),\r\n};\r\nof_ti_dpll_setup(node, &omap3_dpll_per_ck_ops, &dd);\r\n}\r\nstatic void __init of_ti_omap4_dpll_setup(struct device_node *node)\r\n{\r\nconst struct dpll_data dd = {\r\n.idlest_mask = 0x1,\r\n.enable_mask = 0x7,\r\n.autoidle_mask = 0x7,\r\n.mult_mask = 0x7ff << 8,\r\n.div1_mask = 0x7f,\r\n.max_multiplier = 2047,\r\n.max_divider = 128,\r\n.min_divider = 1,\r\n.modes = (1 << DPLL_LOW_POWER_BYPASS) | (1 << DPLL_LOCKED),\r\n};\r\nof_ti_dpll_setup(node, &dpll_ck_ops, &dd);\r\n}\r\nstatic void __init of_ti_omap5_mpu_dpll_setup(struct device_node *node)\r\n{\r\nconst struct dpll_data dd = {\r\n.idlest_mask = 0x1,\r\n.enable_mask = 0x7,\r\n.autoidle_mask = 0x7,\r\n.mult_mask = 0x7ff << 8,\r\n.div1_mask = 0x7f,\r\n.max_multiplier = 2047,\r\n.max_divider = 128,\r\n.dcc_mask = BIT(22),\r\n.dcc_rate = 1400000000,\r\n.min_divider = 1,\r\n.modes = (1 << DPLL_LOW_POWER_BYPASS) | (1 << DPLL_LOCKED),\r\n};\r\nof_ti_dpll_setup(node, &dpll_ck_ops, &dd);\r\n}\r\nstatic void __init of_ti_omap4_core_dpll_setup(struct device_node *node)\r\n{\r\nconst struct dpll_data dd = {\r\n.idlest_mask = 0x1,\r\n.enable_mask = 0x7,\r\n.autoidle_mask = 0x7,\r\n.mult_mask = 0x7ff << 8,\r\n.div1_mask = 0x7f,\r\n.max_multiplier = 2047,\r\n.max_divider = 128,\r\n.min_divider = 1,\r\n.modes = (1 << DPLL_LOW_POWER_BYPASS) | (1 << DPLL_LOCKED),\r\n};\r\nof_ti_dpll_setup(node, &dpll_core_ck_ops, &dd);\r\n}\r\nstatic void __init of_ti_omap4_m4xen_dpll_setup(struct device_node *node)\r\n{\r\nconst struct dpll_data dd = {\r\n.idlest_mask = 0x1,\r\n.enable_mask = 0x7,\r\n.autoidle_mask = 0x7,\r\n.mult_mask = 0x7ff << 8,\r\n.div1_mask = 0x7f,\r\n.max_multiplier = 2047,\r\n.max_divider = 128,\r\n.min_divider = 1,\r\n.m4xen_mask = 0x800,\r\n.lpmode_mask = 1 << 10,\r\n.modes = (1 << DPLL_LOW_POWER_BYPASS) | (1 << DPLL_LOCKED),\r\n};\r\nof_ti_dpll_setup(node, &dpll_m4xen_ck_ops, &dd);\r\n}\r\nstatic void __init of_ti_omap4_jtype_dpll_setup(struct device_node *node)\r\n{\r\nconst struct dpll_data dd = {\r\n.idlest_mask = 0x1,\r\n.enable_mask = 0x7,\r\n.autoidle_mask = 0x7,\r\n.mult_mask = 0xfff << 8,\r\n.div1_mask = 0xff,\r\n.max_multiplier = 4095,\r\n.max_divider = 256,\r\n.min_divider = 1,\r\n.sddiv_mask = 0xff << 24,\r\n.flags = DPLL_J_TYPE,\r\n.modes = (1 << DPLL_LOW_POWER_BYPASS) | (1 << DPLL_LOCKED),\r\n};\r\nof_ti_dpll_setup(node, &dpll_m4xen_ck_ops, &dd);\r\n}\r\nstatic void __init of_ti_am3_no_gate_dpll_setup(struct device_node *node)\r\n{\r\nconst struct dpll_data dd = {\r\n.idlest_mask = 0x1,\r\n.enable_mask = 0x7,\r\n.mult_mask = 0x7ff << 8,\r\n.div1_mask = 0x7f,\r\n.max_multiplier = 2047,\r\n.max_divider = 128,\r\n.min_divider = 1,\r\n.max_rate = 1000000000,\r\n.modes = (1 << DPLL_LOW_POWER_BYPASS) | (1 << DPLL_LOCKED),\r\n};\r\nof_ti_dpll_setup(node, &dpll_no_gate_ck_ops, &dd);\r\n}\r\nstatic void __init of_ti_am3_jtype_dpll_setup(struct device_node *node)\r\n{\r\nconst struct dpll_data dd = {\r\n.idlest_mask = 0x1,\r\n.enable_mask = 0x7,\r\n.mult_mask = 0x7ff << 8,\r\n.div1_mask = 0x7f,\r\n.max_multiplier = 4095,\r\n.max_divider = 256,\r\n.min_divider = 2,\r\n.flags = DPLL_J_TYPE,\r\n.max_rate = 2000000000,\r\n.modes = (1 << DPLL_LOW_POWER_BYPASS) | (1 << DPLL_LOCKED),\r\n};\r\nof_ti_dpll_setup(node, &dpll_ck_ops, &dd);\r\n}\r\nstatic void __init of_ti_am3_no_gate_jtype_dpll_setup(struct device_node *node)\r\n{\r\nconst struct dpll_data dd = {\r\n.idlest_mask = 0x1,\r\n.enable_mask = 0x7,\r\n.mult_mask = 0x7ff << 8,\r\n.div1_mask = 0x7f,\r\n.max_multiplier = 2047,\r\n.max_divider = 128,\r\n.min_divider = 1,\r\n.max_rate = 2000000000,\r\n.flags = DPLL_J_TYPE,\r\n.modes = (1 << DPLL_LOW_POWER_BYPASS) | (1 << DPLL_LOCKED),\r\n};\r\nof_ti_dpll_setup(node, &dpll_no_gate_ck_ops, &dd);\r\n}\r\nstatic void __init of_ti_am3_dpll_setup(struct device_node *node)\r\n{\r\nconst struct dpll_data dd = {\r\n.idlest_mask = 0x1,\r\n.enable_mask = 0x7,\r\n.mult_mask = 0x7ff << 8,\r\n.div1_mask = 0x7f,\r\n.max_multiplier = 2047,\r\n.max_divider = 128,\r\n.min_divider = 1,\r\n.max_rate = 1000000000,\r\n.modes = (1 << DPLL_LOW_POWER_BYPASS) | (1 << DPLL_LOCKED),\r\n};\r\nof_ti_dpll_setup(node, &dpll_ck_ops, &dd);\r\n}\r\nstatic void __init of_ti_am3_core_dpll_setup(struct device_node *node)\r\n{\r\nconst struct dpll_data dd = {\r\n.idlest_mask = 0x1,\r\n.enable_mask = 0x7,\r\n.mult_mask = 0x7ff << 8,\r\n.div1_mask = 0x7f,\r\n.max_multiplier = 2047,\r\n.max_divider = 128,\r\n.min_divider = 1,\r\n.max_rate = 1000000000,\r\n.modes = (1 << DPLL_LOW_POWER_BYPASS) | (1 << DPLL_LOCKED),\r\n};\r\nof_ti_dpll_setup(node, &dpll_core_ck_ops, &dd);\r\n}\r\nstatic void __init of_ti_omap2_core_dpll_setup(struct device_node *node)\r\n{\r\nconst struct dpll_data dd = {\r\n.enable_mask = 0x3,\r\n.mult_mask = 0x3ff << 12,\r\n.div1_mask = 0xf << 8,\r\n.max_divider = 16,\r\n.min_divider = 1,\r\n};\r\nof_ti_dpll_setup(node, &omap2_dpll_core_ck_ops, &dd);\r\n}
