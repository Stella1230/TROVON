static void reg_w(struct gspca_dev *gspca_dev,\r\nu16 value, u16 index)\r\n{\r\nstruct usb_device *dev = gspca_dev->dev;\r\nint ret;\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\r\n0x02,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nvalue,\r\nindex,\r\nNULL,\r\n0,\r\n500);\r\nif (ret < 0) {\r\npr_err("reg_w err %d\n", ret);\r\ngspca_dev->usb_err = ret;\r\n}\r\n}\r\nstatic int sd_config(struct gspca_dev *gspca_dev,\r\nconst struct usb_device_id *id)\r\n{\r\ngspca_dev->cam.cam_mode = vga_mode;\r\ngspca_dev->cam.nmodes = ARRAY_SIZE(vga_mode);\r\ngspca_dev->cam.no_urb_create = 1;\r\nreturn 0;\r\n}\r\nstatic int sd_init(struct gspca_dev *gspca_dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int sd_start(struct gspca_dev *gspca_dev)\r\n{\r\nstruct urb *urb;\r\nint i, n;\r\n#if MAX_NURBS < 4\r\n#error "Not enough URBs in the gspca table"\r\n#endif\r\n#define SD_PKT_SZ 64\r\n#define SD_NPKT 32\r\nfor (n = 0; n < 4; n++) {\r\nurb = usb_alloc_urb(SD_NPKT, GFP_KERNEL);\r\nif (!urb)\r\nreturn -ENOMEM;\r\ngspca_dev->urb[n] = urb;\r\nurb->transfer_buffer = usb_alloc_coherent(gspca_dev->dev,\r\nSD_PKT_SZ * SD_NPKT,\r\nGFP_KERNEL,\r\n&urb->transfer_dma);\r\nif (urb->transfer_buffer == NULL) {\r\npr_err("usb_alloc_coherent failed\n");\r\nreturn -ENOMEM;\r\n}\r\nurb->dev = gspca_dev->dev;\r\nurb->context = gspca_dev;\r\nurb->transfer_buffer_length = SD_PKT_SZ * SD_NPKT;\r\nurb->pipe = usb_rcvisocpipe(gspca_dev->dev,\r\nn & 1 ? 0x82 : 0x83);\r\nurb->transfer_flags = URB_ISO_ASAP\r\n| URB_NO_TRANSFER_DMA_MAP;\r\nurb->interval = 1;\r\nurb->complete = sd_isoc_irq;\r\nurb->number_of_packets = SD_NPKT;\r\nfor (i = 0; i < SD_NPKT; i++) {\r\nurb->iso_frame_desc[i].length = SD_PKT_SZ;\r\nurb->iso_frame_desc[i].offset = SD_PKT_SZ * i;\r\n}\r\n}\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\r\n{\r\nstruct usb_interface *intf;\r\nreg_w(gspca_dev, 0x003c, 0x0003);\r\nreg_w(gspca_dev, 0x003c, 0x0004);\r\nreg_w(gspca_dev, 0x003c, 0x0005);\r\nreg_w(gspca_dev, 0x003c, 0x0006);\r\nreg_w(gspca_dev, 0x003c, 0x0007);\r\nintf = usb_ifnum_to_if(gspca_dev->dev, gspca_dev->iface);\r\nusb_set_interface(gspca_dev->dev, gspca_dev->iface,\r\nintf->num_altsetting - 1);\r\n}\r\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *data,\r\nint len)\r\n{\r\n}\r\nstatic void sd_isoc_irq(struct urb *urb)\r\n{\r\nstruct gspca_dev *gspca_dev = (struct gspca_dev *) urb->context;\r\nstruct urb *urb0;\r\nu8 *data;\r\nint i, st;\r\nPDEBUG(D_PACK, "sd isoc irq");\r\nif (!gspca_dev->streaming)\r\nreturn;\r\nif (urb->status != 0) {\r\nif (urb->status == -ESHUTDOWN)\r\nreturn;\r\n#ifdef CONFIG_PM\r\nif (gspca_dev->frozen)\r\nreturn;\r\n#endif\r\npr_err("urb status: %d\n", urb->status);\r\nreturn;\r\n}\r\nif (urb == gspca_dev->urb[0] || urb == gspca_dev->urb[2])\r\nreturn;\r\nif (urb == gspca_dev->urb[1])\r\nurb0 = gspca_dev->urb[0];\r\nelse\r\nurb0 = gspca_dev->urb[2];\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\nif (urb0->iso_frame_desc[i].actual_length != SD_PKT_SZ\r\n|| urb->iso_frame_desc[i].actual_length != SD_PKT_SZ) {\r\nPERR("ISOC bad lengths %d / %d",\r\nurb0->iso_frame_desc[i].actual_length,\r\nurb->iso_frame_desc[i].actual_length);\r\ngspca_dev->last_packet_type = DISCARD_PACKET;\r\ncontinue;\r\n}\r\nst = urb0->iso_frame_desc[i].status;\r\nif (st == 0)\r\nst = urb->iso_frame_desc[i].status;\r\nif (st) {\r\npr_err("ISOC data error: [%d] status=%d\n",\r\ni, st);\r\ngspca_dev->last_packet_type = DISCARD_PACKET;\r\ncontinue;\r\n}\r\ndata = (u8 *) urb0->transfer_buffer\r\n+ urb0->iso_frame_desc[i].offset;\r\nif (data[0] == 0x80 && (data[1] & 0xfe) == 0xba) {\r\ngspca_frame_add(gspca_dev, LAST_PACKET,\r\nNULL, 0);\r\ngspca_frame_add(gspca_dev, FIRST_PACKET,\r\ndata + 4, SD_PKT_SZ - 4);\r\n} else if (data[0] == 0x04 && (data[1] & 0xfe) == 0xba) {\r\ngspca_frame_add(gspca_dev, INTER_PACKET,\r\ndata + 4, SD_PKT_SZ - 4);\r\n} else {\r\ngspca_dev->last_packet_type = DISCARD_PACKET;\r\ncontinue;\r\n}\r\ndata = (u8 *) urb->transfer_buffer\r\n+ urb->iso_frame_desc[i].offset;\r\ngspca_frame_add(gspca_dev, INTER_PACKET,\r\ndata, SD_PKT_SZ);\r\n}\r\nst = usb_submit_urb(urb0, GFP_ATOMIC);\r\nif (st < 0)\r\npr_err("usb_submit_urb(0) ret %d\n", st);\r\nst = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (st < 0)\r\npr_err("usb_submit_urb() ret %d\n", st);\r\n}\r\nstatic int sd_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\r\nTHIS_MODULE);\r\n}
