static int bnep_sock_release(struct socket *sock)\r\n{\r\nstruct sock *sk = sock->sk;\r\nBT_DBG("sock %p sk %p", sock, sk);\r\nif (!sk)\r\nreturn 0;\r\nbt_sock_unlink(&bnep_sk_list, sk);\r\nsock_orphan(sk);\r\nsock_put(sk);\r\nreturn 0;\r\n}\r\nstatic int bnep_sock_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct bnep_connlist_req cl;\r\nstruct bnep_connadd_req ca;\r\nstruct bnep_conndel_req cd;\r\nstruct bnep_conninfo ci;\r\nstruct socket *nsock;\r\nvoid __user *argp = (void __user *)arg;\r\n__u32 supp_feat = BIT(BNEP_SETUP_RESPONSE);\r\nint err;\r\nBT_DBG("cmd %x arg %lx", cmd, arg);\r\nswitch (cmd) {\r\ncase BNEPCONNADD:\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (copy_from_user(&ca, argp, sizeof(ca)))\r\nreturn -EFAULT;\r\nnsock = sockfd_lookup(ca.sock, &err);\r\nif (!nsock)\r\nreturn err;\r\nif (nsock->sk->sk_state != BT_CONNECTED) {\r\nsockfd_put(nsock);\r\nreturn -EBADFD;\r\n}\r\nca.device[sizeof(ca.device)-1] = 0;\r\nerr = bnep_add_connection(&ca, nsock);\r\nif (!err) {\r\nif (copy_to_user(argp, &ca, sizeof(ca)))\r\nerr = -EFAULT;\r\n} else\r\nsockfd_put(nsock);\r\nreturn err;\r\ncase BNEPCONNDEL:\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (copy_from_user(&cd, argp, sizeof(cd)))\r\nreturn -EFAULT;\r\nreturn bnep_del_connection(&cd);\r\ncase BNEPGETCONNLIST:\r\nif (copy_from_user(&cl, argp, sizeof(cl)))\r\nreturn -EFAULT;\r\nif (cl.cnum <= 0)\r\nreturn -EINVAL;\r\nerr = bnep_get_connlist(&cl);\r\nif (!err && copy_to_user(argp, &cl, sizeof(cl)))\r\nreturn -EFAULT;\r\nreturn err;\r\ncase BNEPGETCONNINFO:\r\nif (copy_from_user(&ci, argp, sizeof(ci)))\r\nreturn -EFAULT;\r\nerr = bnep_get_conninfo(&ci);\r\nif (!err && copy_to_user(argp, &ci, sizeof(ci)))\r\nreturn -EFAULT;\r\nreturn err;\r\ncase BNEPGETSUPPFEAT:\r\nif (copy_to_user(argp, &supp_feat, sizeof(supp_feat)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bnep_sock_compat_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\r\n{\r\nif (cmd == BNEPGETCONNLIST) {\r\nstruct bnep_connlist_req cl;\r\nu32 uci;\r\nint err;\r\nif (get_user(cl.cnum, (u32 __user *) arg) ||\r\nget_user(uci, (u32 __user *) (arg + 4)))\r\nreturn -EFAULT;\r\ncl.ci = compat_ptr(uci);\r\nif (cl.cnum <= 0)\r\nreturn -EINVAL;\r\nerr = bnep_get_connlist(&cl);\r\nif (!err && put_user(cl.cnum, (u32 __user *) arg))\r\nerr = -EFAULT;\r\nreturn err;\r\n}\r\nreturn bnep_sock_ioctl(sock, cmd, arg);\r\n}\r\nstatic int bnep_sock_create(struct net *net, struct socket *sock, int protocol,\r\nint kern)\r\n{\r\nstruct sock *sk;\r\nBT_DBG("sock %p", sock);\r\nif (sock->type != SOCK_RAW)\r\nreturn -ESOCKTNOSUPPORT;\r\nsk = sk_alloc(net, PF_BLUETOOTH, GFP_ATOMIC, &bnep_proto, kern);\r\nif (!sk)\r\nreturn -ENOMEM;\r\nsock_init_data(sock, sk);\r\nsock->ops = &bnep_sock_ops;\r\nsock->state = SS_UNCONNECTED;\r\nsock_reset_flag(sk, SOCK_ZAPPED);\r\nsk->sk_protocol = protocol;\r\nsk->sk_state = BT_OPEN;\r\nbt_sock_link(&bnep_sk_list, sk);\r\nreturn 0;\r\n}\r\nint __init bnep_sock_init(void)\r\n{\r\nint err;\r\nerr = proto_register(&bnep_proto, 0);\r\nif (err < 0)\r\nreturn err;\r\nerr = bt_sock_register(BTPROTO_BNEP, &bnep_sock_family_ops);\r\nif (err < 0) {\r\nBT_ERR("Can't register BNEP socket");\r\ngoto error;\r\n}\r\nerr = bt_procfs_init(&init_net, "bnep", &bnep_sk_list, NULL);\r\nif (err < 0) {\r\nBT_ERR("Failed to create BNEP proc file");\r\nbt_sock_unregister(BTPROTO_BNEP);\r\ngoto error;\r\n}\r\nBT_INFO("BNEP socket layer initialized");\r\nreturn 0;\r\nerror:\r\nproto_unregister(&bnep_proto);\r\nreturn err;\r\n}\r\nvoid __exit bnep_sock_cleanup(void)\r\n{\r\nbt_procfs_cleanup(&init_net, "bnep");\r\nbt_sock_unregister(BTPROTO_BNEP);\r\nproto_unregister(&bnep_proto);\r\n}
