static ssize_t vboot_context_read(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *att, char *buf,\r\nloff_t pos, size_t count)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct cros_ec_dev *ec = container_of(dev, struct cros_ec_dev,\r\nclass_dev);\r\nstruct cros_ec_device *ecdev = ec->ec_dev;\r\nstruct ec_params_vbnvcontext *params;\r\nstruct cros_ec_command *msg;\r\nint err;\r\nconst size_t para_sz = sizeof(params->op);\r\nconst size_t resp_sz = sizeof(struct ec_response_vbnvcontext);\r\nconst size_t payload = max(para_sz, resp_sz);\r\nmsg = kmalloc(sizeof(*msg) + payload, GFP_KERNEL);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nparams = (struct ec_params_vbnvcontext *)msg->data;\r\nparams->op = EC_VBNV_CONTEXT_OP_READ;\r\nmsg->version = EC_VER_VBNV_CONTEXT;\r\nmsg->command = EC_CMD_VBNV_CONTEXT;\r\nmsg->outsize = para_sz;\r\nmsg->insize = resp_sz;\r\nerr = cros_ec_cmd_xfer(ecdev, msg);\r\nif (err < 0) {\r\ndev_err(dev, "Error sending read request: %d\n", err);\r\nkfree(msg);\r\nreturn err;\r\n}\r\nmemcpy(buf, msg->data, resp_sz);\r\nkfree(msg);\r\nreturn resp_sz;\r\n}\r\nstatic ssize_t vboot_context_write(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *attr, char *buf,\r\nloff_t pos, size_t count)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct cros_ec_dev *ec = container_of(dev, struct cros_ec_dev,\r\nclass_dev);\r\nstruct cros_ec_device *ecdev = ec->ec_dev;\r\nstruct ec_params_vbnvcontext *params;\r\nstruct cros_ec_command *msg;\r\nint err;\r\nconst size_t para_sz = sizeof(*params);\r\nconst size_t data_sz = sizeof(params->block);\r\nif (count != data_sz)\r\nreturn -EINVAL;\r\nmsg = kmalloc(sizeof(*msg) + para_sz, GFP_KERNEL);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nparams = (struct ec_params_vbnvcontext *)msg->data;\r\nparams->op = EC_VBNV_CONTEXT_OP_WRITE;\r\nmemcpy(params->block, buf, data_sz);\r\nmsg->version = EC_VER_VBNV_CONTEXT;\r\nmsg->command = EC_CMD_VBNV_CONTEXT;\r\nmsg->outsize = para_sz;\r\nmsg->insize = 0;\r\nerr = cros_ec_cmd_xfer(ecdev, msg);\r\nif (err < 0) {\r\ndev_err(dev, "Error sending write request: %d\n", err);\r\nkfree(msg);\r\nreturn err;\r\n}\r\nkfree(msg);\r\nreturn data_sz;\r\n}\r\nstatic umode_t cros_ec_vbc_is_visible(struct kobject *kobj,\r\nstruct bin_attribute *a, int n)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct cros_ec_dev *ec = container_of(dev, struct cros_ec_dev,\r\nclass_dev);\r\nstruct device_node *np = ec->ec_dev->dev->of_node;\r\nif (IS_ENABLED(CONFIG_OF) && np) {\r\nif (of_property_read_bool(np, "google,has-vbc-nvram"))\r\nreturn a->attr.mode;\r\n}\r\nreturn 0;\r\n}
