static void psc724_wm8766_write(struct snd_wm8766 *wm, u16 addr, u16 data)\r\n{\r\nstruct psc724_spec *spec = container_of(wm, struct psc724_spec, wm8766);\r\nstruct snd_ice1712 *ice = spec->ice;\r\nu32 st, bits;\r\nint i;\r\nsnd_ice1712_save_gpio_status(ice);\r\nst = ((addr & 0x7f) << 9) | (data & 0x1ff);\r\nsnd_ice1712_gpio_set_dir(ice, ice->gpio.direction | PSC724_SPI_MASK);\r\nsnd_ice1712_gpio_set_mask(ice, ice->gpio.write_mask & ~PSC724_SPI_MASK);\r\nbits = snd_ice1712_gpio_read(ice) & ~PSC724_SPI_MASK;\r\nsnd_ice1712_gpio_write(ice, bits);\r\nfor (i = 0; i < 16; i++) {\r\nudelay(PSC724_SPI_DELAY);\r\nbits &= ~PSC724_SPI_CLK;\r\nst <<= 1;\r\nif (st & 0x10000)\r\nbits |= PSC724_SPI_DATA;\r\nelse\r\nbits &= ~PSC724_SPI_DATA;\r\nsnd_ice1712_gpio_write(ice, bits);\r\nudelay(PSC724_SPI_DELAY);\r\nbits |= PSC724_SPI_CLK;\r\nsnd_ice1712_gpio_write(ice, bits);\r\n}\r\nudelay(PSC724_SPI_DELAY);\r\nbits |= PSC724_SPI_LOAD;\r\nsnd_ice1712_gpio_write(ice, bits);\r\nudelay(PSC724_SPI_DELAY);\r\nbits |= (PSC724_SPI_DATA | PSC724_SPI_CLK);\r\nsnd_ice1712_gpio_write(ice, bits);\r\nsnd_ice1712_restore_gpio_status(ice);\r\n}\r\nstatic void psc724_wm8776_write(struct snd_wm8776 *wm, u8 addr, u8 data)\r\n{\r\nstruct psc724_spec *spec = container_of(wm, struct psc724_spec, wm8776);\r\nsnd_vt1724_write_i2c(spec->ice, 0x34, addr, data);\r\n}\r\nstatic void psc724_set_master_switch(struct snd_ice1712 *ice, bool on)\r\n{\r\nunsigned int bits = snd_ice1712_gpio_read(ice);\r\nstruct psc724_spec *spec = ice->spec;\r\nspec->mute_all = !on;\r\nif (on)\r\nbits &= ~(GPIO_MUTE_ALL | GPIO_MUTE_SUR);\r\nelse\r\nbits |= GPIO_MUTE_ALL | GPIO_MUTE_SUR;\r\nsnd_ice1712_gpio_write(ice, bits);\r\n}\r\nstatic bool psc724_get_master_switch(struct snd_ice1712 *ice)\r\n{\r\nstruct psc724_spec *spec = ice->spec;\r\nreturn !spec->mute_all;\r\n}\r\nstatic void psc724_set_jack_state(struct snd_ice1712 *ice, bool hp_connected)\r\n{\r\nstruct psc724_spec *spec = ice->spec;\r\nstruct snd_ctl_elem_id elem_id;\r\nstruct snd_kcontrol *kctl;\r\nu16 power = spec->wm8776.regs[WM8776_REG_PWRDOWN] & ~WM8776_PWR_HPPD;\r\npsc724_set_master_switch(ice, !hp_connected);\r\nif (!hp_connected)\r\npower |= WM8776_PWR_HPPD;\r\nsnd_wm8776_set_power(&spec->wm8776, power);\r\nspec->hp_connected = hp_connected;\r\nmemset(&elem_id, 0, sizeof(elem_id));\r\nelem_id.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nstrlcpy(elem_id.name, "Master Speakers Playback Switch",\r\nsizeof(elem_id.name));\r\nkctl = snd_ctl_find_id(ice->card, &elem_id);\r\nsnd_ctl_notify(ice->card, SNDRV_CTL_EVENT_MASK_VALUE, &kctl->id);\r\nstrlcpy(elem_id.name, spec->wm8776.ctl[WM8776_CTL_HP_SW].name,\r\nsizeof(elem_id.name));\r\nkctl = snd_ctl_find_id(ice->card, &elem_id);\r\nsnd_ctl_notify(ice->card, SNDRV_CTL_EVENT_MASK_VALUE, &kctl->id);\r\n}\r\nstatic void psc724_update_hp_jack_state(struct work_struct *work)\r\n{\r\nstruct psc724_spec *spec = container_of(work, struct psc724_spec,\r\nhp_work.work);\r\nstruct snd_ice1712 *ice = spec->ice;\r\nbool hp_connected = snd_ice1712_gpio_read(ice) & GPIO_HP_JACK;\r\nschedule_delayed_work(&spec->hp_work, msecs_to_jiffies(JACK_INTERVAL));\r\nif (hp_connected == spec->hp_connected)\r\nreturn;\r\npsc724_set_jack_state(ice, hp_connected);\r\n}\r\nstatic void psc724_set_jack_detection(struct snd_ice1712 *ice, bool on)\r\n{\r\nstruct psc724_spec *spec = ice->spec;\r\nif (spec->jack_detect == on)\r\nreturn;\r\nspec->jack_detect = on;\r\nif (on) {\r\nbool hp_connected = snd_ice1712_gpio_read(ice) & GPIO_HP_JACK;\r\npsc724_set_jack_state(ice, hp_connected);\r\nschedule_delayed_work(&spec->hp_work,\r\nmsecs_to_jiffies(JACK_INTERVAL));\r\n} else\r\ncancel_delayed_work_sync(&spec->hp_work);\r\n}\r\nstatic bool psc724_get_jack_detection(struct snd_ice1712 *ice)\r\n{\r\nstruct psc724_spec *spec = ice->spec;\r\nreturn spec->jack_detect;\r\n}\r\nstatic int psc724_ctl_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nint n = kcontrol->private_value;\r\nucontrol->value.integer.value[0] = psc724_cont[n].get(ice);\r\nreturn 0;\r\n}\r\nstatic int psc724_ctl_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nint n = kcontrol->private_value;\r\npsc724_cont[n].set(ice, ucontrol->value.integer.value[0]);\r\nreturn 0;\r\n}\r\nstatic int psc724_add_controls(struct snd_ice1712 *ice)\r\n{\r\nstruct snd_kcontrol_new cont;\r\nstruct snd_kcontrol *ctl;\r\nint err, i;\r\nstruct psc724_spec *spec = ice->spec;\r\nspec->wm8776.ctl[WM8776_CTL_DAC_VOL].name = front_volume;\r\nspec->wm8776.ctl[WM8776_CTL_DAC_SW].name = front_switch;\r\nspec->wm8776.ctl[WM8776_CTL_DAC_ZC_SW].name = front_zc;\r\nspec->wm8776.ctl[WM8776_CTL_AUX_SW].name = NULL;\r\nspec->wm8776.ctl[WM8776_CTL_DAC_IZD_SW].name = front_izd;\r\nspec->wm8776.ctl[WM8776_CTL_PHASE_SW].name = front_phase;\r\nspec->wm8776.ctl[WM8776_CTL_DEEMPH_SW].name = front_deemph;\r\nspec->wm8776.ctl[WM8776_CTL_INPUT1_SW].name = ain1_switch;\r\nspec->wm8776.ctl[WM8776_CTL_INPUT2_SW].name = ain2_switch;\r\nspec->wm8776.ctl[WM8776_CTL_INPUT3_SW].name = ain3_switch;\r\nspec->wm8776.ctl[WM8776_CTL_INPUT4_SW].name = ain4_switch;\r\nspec->wm8776.ctl[WM8776_CTL_INPUT5_SW].name = ain5_switch;\r\nsnd_wm8776_build_controls(&spec->wm8776);\r\nspec->wm8766.ctl[WM8766_CTL_CH1_VOL].name = rear_volume;\r\nspec->wm8766.ctl[WM8766_CTL_CH2_VOL].name = clfe_volume;\r\nspec->wm8766.ctl[WM8766_CTL_CH3_VOL].name = NULL;\r\nspec->wm8766.ctl[WM8766_CTL_CH1_SW].name = rear_switch;\r\nspec->wm8766.ctl[WM8766_CTL_CH2_SW].name = clfe_switch;\r\nspec->wm8766.ctl[WM8766_CTL_CH3_SW].name = NULL;\r\nspec->wm8766.ctl[WM8766_CTL_PHASE1_SW].name = rear_phase;\r\nspec->wm8766.ctl[WM8766_CTL_PHASE2_SW].name = clfe_phase;\r\nspec->wm8766.ctl[WM8766_CTL_PHASE3_SW].name = NULL;\r\nspec->wm8766.ctl[WM8766_CTL_DEEMPH1_SW].name = rear_deemph;\r\nspec->wm8766.ctl[WM8766_CTL_DEEMPH2_SW].name = clfe_deemph;\r\nspec->wm8766.ctl[WM8766_CTL_DEEMPH3_SW].name = NULL;\r\nspec->wm8766.ctl[WM8766_CTL_IZD_SW].name = rear_clfe_izd;\r\nspec->wm8766.ctl[WM8766_CTL_ZC_SW].name = rear_clfe_zc;\r\nsnd_wm8766_build_controls(&spec->wm8766);\r\nmemset(&cont, 0, sizeof(cont));\r\ncont.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nfor (i = 0; i < ARRAY_SIZE(psc724_cont); i++) {\r\ncont.private_value = i;\r\ncont.name = psc724_cont[i].name;\r\ncont.access = SNDRV_CTL_ELEM_ACCESS_READWRITE;\r\ncont.info = snd_ctl_boolean_mono_info;\r\ncont.get = psc724_ctl_get;\r\ncont.put = psc724_ctl_put;\r\nctl = snd_ctl_new1(&cont, ice);\r\nif (!ctl)\r\nreturn -ENOMEM;\r\nerr = snd_ctl_add(ice->card, ctl);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void psc724_set_pro_rate(struct snd_ice1712 *ice, unsigned int rate)\r\n{\r\nstruct psc724_spec *spec = ice->spec;\r\nsnd_wm8776_volume_restore(&spec->wm8776);\r\nsnd_wm8766_volume_restore(&spec->wm8766);\r\n}\r\nstatic int psc724_resume(struct snd_ice1712 *ice)\r\n{\r\nstruct psc724_spec *spec = ice->spec;\r\nsnd_wm8776_resume(&spec->wm8776);\r\nsnd_wm8766_resume(&spec->wm8766);\r\nreturn 0;\r\n}\r\nstatic int psc724_init(struct snd_ice1712 *ice)\r\n{\r\nstruct psc724_spec *spec;\r\nspec = kzalloc(sizeof(*spec), GFP_KERNEL);\r\nif (!spec)\r\nreturn -ENOMEM;\r\nice->spec = spec;\r\nspec->ice = ice;\r\nice->num_total_dacs = 6;\r\nice->num_total_adcs = 2;\r\nspec->wm8776.ops.write = psc724_wm8776_write;\r\nspec->wm8776.card = ice->card;\r\nsnd_wm8776_init(&spec->wm8776);\r\nspec->wm8766.ops.write = psc724_wm8766_write;\r\nspec->wm8766.card = ice->card;\r\n#ifdef CONFIG_PM_SLEEP\r\nice->pm_resume = psc724_resume;\r\nice->pm_suspend_enabled = 1;\r\n#endif\r\nsnd_wm8766_init(&spec->wm8766);\r\nsnd_wm8766_set_if(&spec->wm8766,\r\nWM8766_IF_FMT_I2S | WM8766_IF_IWL_24BIT);\r\nice->gpio.set_pro_rate = psc724_set_pro_rate;\r\nINIT_DELAYED_WORK(&spec->hp_work, psc724_update_hp_jack_state);\r\npsc724_set_jack_detection(ice, true);\r\nreturn 0;\r\n}\r\nstatic void psc724_exit(struct snd_ice1712 *ice)\r\n{\r\nstruct psc724_spec *spec = ice->spec;\r\ncancel_delayed_work_sync(&spec->hp_work);\r\n}
