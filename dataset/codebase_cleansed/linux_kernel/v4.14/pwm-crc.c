static inline struct crystalcove_pwm *to_crc_pwm(struct pwm_chip *pc)\r\n{\r\nreturn container_of(pc, struct crystalcove_pwm, chip);\r\n}\r\nstatic int crc_pwm_enable(struct pwm_chip *c, struct pwm_device *pwm)\r\n{\r\nstruct crystalcove_pwm *crc_pwm = to_crc_pwm(c);\r\nregmap_write(crc_pwm->regmap, BACKLIGHT_EN, 1);\r\nreturn 0;\r\n}\r\nstatic void crc_pwm_disable(struct pwm_chip *c, struct pwm_device *pwm)\r\n{\r\nstruct crystalcove_pwm *crc_pwm = to_crc_pwm(c);\r\nregmap_write(crc_pwm->regmap, BACKLIGHT_EN, 0);\r\n}\r\nstatic int crc_pwm_config(struct pwm_chip *c, struct pwm_device *pwm,\r\nint duty_ns, int period_ns)\r\n{\r\nstruct crystalcove_pwm *crc_pwm = to_crc_pwm(c);\r\nstruct device *dev = crc_pwm->chip.dev;\r\nint level;\r\nif (period_ns > PWM_MAX_PERIOD_NS) {\r\ndev_err(dev, "un-supported period_ns\n");\r\nreturn -EINVAL;\r\n}\r\nif (pwm_get_period(pwm) != period_ns) {\r\nint clk_div;\r\ncrc_pwm_disable(c, pwm);\r\nclk_div = PWM_BASE_CLK * period_ns / NSEC_PER_SEC;\r\nregmap_write(crc_pwm->regmap, PWM0_CLK_DIV,\r\nclk_div | PWM_OUTPUT_ENABLE);\r\ncrc_pwm_enable(c, pwm);\r\n}\r\nlevel = duty_ns * PWM_MAX_LEVEL / period_ns;\r\nregmap_write(crc_pwm->regmap, PWM0_DUTY_CYCLE, level);\r\nreturn 0;\r\n}\r\nstatic int crystalcove_pwm_probe(struct platform_device *pdev)\r\n{\r\nstruct crystalcove_pwm *pwm;\r\nstruct device *dev = pdev->dev.parent;\r\nstruct intel_soc_pmic *pmic = dev_get_drvdata(dev);\r\npwm = devm_kzalloc(&pdev->dev, sizeof(*pwm), GFP_KERNEL);\r\nif (!pwm)\r\nreturn -ENOMEM;\r\npwm->chip.dev = &pdev->dev;\r\npwm->chip.ops = &crc_pwm_ops;\r\npwm->chip.base = -1;\r\npwm->chip.npwm = 1;\r\npwm->regmap = pmic->regmap;\r\nplatform_set_drvdata(pdev, pwm);\r\nreturn pwmchip_add(&pwm->chip);\r\n}\r\nstatic int crystalcove_pwm_remove(struct platform_device *pdev)\r\n{\r\nstruct crystalcove_pwm *pwm = platform_get_drvdata(pdev);\r\nreturn pwmchip_remove(&pwm->chip);\r\n}
