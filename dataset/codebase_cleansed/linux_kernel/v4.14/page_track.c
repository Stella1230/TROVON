void kvm_page_track_free_memslot(struct kvm_memory_slot *free,\r\nstruct kvm_memory_slot *dont)\r\n{\r\nint i;\r\nfor (i = 0; i < KVM_PAGE_TRACK_MAX; i++)\r\nif (!dont || free->arch.gfn_track[i] !=\r\ndont->arch.gfn_track[i]) {\r\nkvfree(free->arch.gfn_track[i]);\r\nfree->arch.gfn_track[i] = NULL;\r\n}\r\n}\r\nint kvm_page_track_create_memslot(struct kvm_memory_slot *slot,\r\nunsigned long npages)\r\n{\r\nint i;\r\nfor (i = 0; i < KVM_PAGE_TRACK_MAX; i++) {\r\nslot->arch.gfn_track[i] = kvzalloc(npages *\r\nsizeof(*slot->arch.gfn_track[i]), GFP_KERNEL);\r\nif (!slot->arch.gfn_track[i])\r\ngoto track_free;\r\n}\r\nreturn 0;\r\ntrack_free:\r\nkvm_page_track_free_memslot(slot, NULL);\r\nreturn -ENOMEM;\r\n}\r\nstatic inline bool page_track_mode_is_valid(enum kvm_page_track_mode mode)\r\n{\r\nif (mode < 0 || mode >= KVM_PAGE_TRACK_MAX)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic void update_gfn_track(struct kvm_memory_slot *slot, gfn_t gfn,\r\nenum kvm_page_track_mode mode, short count)\r\n{\r\nint index, val;\r\nindex = gfn_to_index(gfn, slot->base_gfn, PT_PAGE_TABLE_LEVEL);\r\nval = slot->arch.gfn_track[mode][index];\r\nif (WARN_ON(val + count < 0 || val + count > USHRT_MAX))\r\nreturn;\r\nslot->arch.gfn_track[mode][index] += count;\r\n}\r\nvoid kvm_slot_page_track_add_page(struct kvm *kvm,\r\nstruct kvm_memory_slot *slot, gfn_t gfn,\r\nenum kvm_page_track_mode mode)\r\n{\r\nif (WARN_ON(!page_track_mode_is_valid(mode)))\r\nreturn;\r\nupdate_gfn_track(slot, gfn, mode, 1);\r\nkvm_mmu_gfn_disallow_lpage(slot, gfn);\r\nif (mode == KVM_PAGE_TRACK_WRITE)\r\nif (kvm_mmu_slot_gfn_write_protect(kvm, slot, gfn))\r\nkvm_flush_remote_tlbs(kvm);\r\n}\r\nvoid kvm_slot_page_track_remove_page(struct kvm *kvm,\r\nstruct kvm_memory_slot *slot, gfn_t gfn,\r\nenum kvm_page_track_mode mode)\r\n{\r\nif (WARN_ON(!page_track_mode_is_valid(mode)))\r\nreturn;\r\nupdate_gfn_track(slot, gfn, mode, -1);\r\nkvm_mmu_gfn_allow_lpage(slot, gfn);\r\n}\r\nbool kvm_page_track_is_active(struct kvm_vcpu *vcpu, gfn_t gfn,\r\nenum kvm_page_track_mode mode)\r\n{\r\nstruct kvm_memory_slot *slot;\r\nint index;\r\nif (WARN_ON(!page_track_mode_is_valid(mode)))\r\nreturn false;\r\nslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\r\nif (!slot)\r\nreturn false;\r\nindex = gfn_to_index(gfn, slot->base_gfn, PT_PAGE_TABLE_LEVEL);\r\nreturn !!ACCESS_ONCE(slot->arch.gfn_track[mode][index]);\r\n}\r\nvoid kvm_page_track_cleanup(struct kvm *kvm)\r\n{\r\nstruct kvm_page_track_notifier_head *head;\r\nhead = &kvm->arch.track_notifier_head;\r\ncleanup_srcu_struct(&head->track_srcu);\r\n}\r\nvoid kvm_page_track_init(struct kvm *kvm)\r\n{\r\nstruct kvm_page_track_notifier_head *head;\r\nhead = &kvm->arch.track_notifier_head;\r\ninit_srcu_struct(&head->track_srcu);\r\nINIT_HLIST_HEAD(&head->track_notifier_list);\r\n}\r\nvoid\r\nkvm_page_track_register_notifier(struct kvm *kvm,\r\nstruct kvm_page_track_notifier_node *n)\r\n{\r\nstruct kvm_page_track_notifier_head *head;\r\nhead = &kvm->arch.track_notifier_head;\r\nspin_lock(&kvm->mmu_lock);\r\nhlist_add_head_rcu(&n->node, &head->track_notifier_list);\r\nspin_unlock(&kvm->mmu_lock);\r\n}\r\nvoid\r\nkvm_page_track_unregister_notifier(struct kvm *kvm,\r\nstruct kvm_page_track_notifier_node *n)\r\n{\r\nstruct kvm_page_track_notifier_head *head;\r\nhead = &kvm->arch.track_notifier_head;\r\nspin_lock(&kvm->mmu_lock);\r\nhlist_del_rcu(&n->node);\r\nspin_unlock(&kvm->mmu_lock);\r\nsynchronize_srcu(&head->track_srcu);\r\n}\r\nvoid kvm_page_track_write(struct kvm_vcpu *vcpu, gpa_t gpa, const u8 *new,\r\nint bytes)\r\n{\r\nstruct kvm_page_track_notifier_head *head;\r\nstruct kvm_page_track_notifier_node *n;\r\nint idx;\r\nhead = &vcpu->kvm->arch.track_notifier_head;\r\nif (hlist_empty(&head->track_notifier_list))\r\nreturn;\r\nidx = srcu_read_lock(&head->track_srcu);\r\nhlist_for_each_entry_rcu(n, &head->track_notifier_list, node)\r\nif (n->track_write)\r\nn->track_write(vcpu, gpa, new, bytes, n);\r\nsrcu_read_unlock(&head->track_srcu, idx);\r\n}\r\nvoid kvm_page_track_flush_slot(struct kvm *kvm, struct kvm_memory_slot *slot)\r\n{\r\nstruct kvm_page_track_notifier_head *head;\r\nstruct kvm_page_track_notifier_node *n;\r\nint idx;\r\nhead = &kvm->arch.track_notifier_head;\r\nif (hlist_empty(&head->track_notifier_list))\r\nreturn;\r\nidx = srcu_read_lock(&head->track_srcu);\r\nhlist_for_each_entry_rcu(n, &head->track_notifier_list, node)\r\nif (n->track_flush_slot)\r\nn->track_flush_slot(kvm, slot, n);\r\nsrcu_read_unlock(&head->track_srcu, idx);\r\n}
