static void qed_ll2b_complete_tx_packet(void *cxt,\r\nu8 connection_handle,\r\nvoid *cookie,\r\ndma_addr_t first_frag_addr,\r\nbool b_last_fragment,\r\nbool b_last_packet)\r\n{\r\nstruct qed_hwfn *p_hwfn = cxt;\r\nstruct qed_dev *cdev = p_hwfn->cdev;\r\nstruct sk_buff *skb = cookie;\r\ndma_unmap_single(&p_hwfn->cdev->pdev->dev, first_frag_addr,\r\nskb_headlen(skb), DMA_TO_DEVICE);\r\nif (cdev->ll2->cbs && cdev->ll2->cbs->tx_cb)\r\ncdev->ll2->cbs->tx_cb(cdev->ll2->cb_cookie, skb,\r\nb_last_fragment);\r\ndev_kfree_skb_any(skb);\r\n}\r\nstatic int qed_ll2_alloc_buffer(struct qed_dev *cdev,\r\nu8 **data, dma_addr_t *phys_addr)\r\n{\r\n*data = kmalloc(cdev->ll2->rx_size, GFP_ATOMIC);\r\nif (!(*data)) {\r\nDP_INFO(cdev, "Failed to allocate LL2 buffer data\n");\r\nreturn -ENOMEM;\r\n}\r\n*phys_addr = dma_map_single(&cdev->pdev->dev,\r\n((*data) + NET_SKB_PAD),\r\ncdev->ll2->rx_size, DMA_FROM_DEVICE);\r\nif (dma_mapping_error(&cdev->pdev->dev, *phys_addr)) {\r\nDP_INFO(cdev, "Failed to map LL2 buffer data\n");\r\nkfree((*data));\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qed_ll2_dealloc_buffer(struct qed_dev *cdev,\r\nstruct qed_ll2_buffer *buffer)\r\n{\r\nspin_lock_bh(&cdev->ll2->lock);\r\ndma_unmap_single(&cdev->pdev->dev, buffer->phys_addr,\r\ncdev->ll2->rx_size, DMA_FROM_DEVICE);\r\nkfree(buffer->data);\r\nlist_del(&buffer->list);\r\ncdev->ll2->rx_cnt--;\r\nif (!cdev->ll2->rx_cnt)\r\nDP_INFO(cdev, "All LL2 entries were removed\n");\r\nspin_unlock_bh(&cdev->ll2->lock);\r\nreturn 0;\r\n}\r\nstatic void qed_ll2_kill_buffers(struct qed_dev *cdev)\r\n{\r\nstruct qed_ll2_buffer *buffer, *tmp_buffer;\r\nlist_for_each_entry_safe(buffer, tmp_buffer, &cdev->ll2->list, list)\r\nqed_ll2_dealloc_buffer(cdev, buffer);\r\n}\r\nvoid qed_ll2b_complete_rx_packet(void *cxt, struct qed_ll2_comp_rx_data *data)\r\n{\r\nstruct qed_hwfn *p_hwfn = cxt;\r\nstruct qed_ll2_buffer *buffer = data->cookie;\r\nstruct qed_dev *cdev = p_hwfn->cdev;\r\ndma_addr_t new_phys_addr;\r\nstruct sk_buff *skb;\r\nbool reuse = false;\r\nint rc = -EINVAL;\r\nu8 *new_data;\r\nDP_VERBOSE(p_hwfn,\r\n(NETIF_MSG_RX_STATUS | QED_MSG_STORAGE | NETIF_MSG_PKTDATA),\r\n"Got an LL2 Rx completion: [Buffer at phys 0x%llx, offset 0x%02x] Length 0x%04x Parse_flags 0x%04x vlan 0x%04x Opaque data [0x%08x:0x%08x]\n",\r\n(u64)data->rx_buf_addr,\r\ndata->u.placement_offset,\r\ndata->length.packet_length,\r\ndata->parse_flags,\r\ndata->vlan, data->opaque_data_0, data->opaque_data_1);\r\nif ((cdev->dp_module & NETIF_MSG_PKTDATA) && buffer->data) {\r\nprint_hex_dump(KERN_INFO, "",\r\nDUMP_PREFIX_OFFSET, 16, 1,\r\nbuffer->data, data->length.packet_length, false);\r\n}\r\nif (data->length.packet_length < ETH_HLEN)\r\nreuse = true;\r\nif (!reuse)\r\nrc = qed_ll2_alloc_buffer(p_hwfn->cdev, &new_data,\r\n&new_phys_addr);\r\nif (rc)\r\ngoto out_post;\r\ndma_unmap_single(&cdev->pdev->dev, buffer->phys_addr,\r\ncdev->ll2->rx_size, DMA_FROM_DEVICE);\r\nskb = build_skb(buffer->data, 0);\r\nif (!skb) {\r\nrc = -ENOMEM;\r\ngoto out_post;\r\n}\r\ndata->u.placement_offset += NET_SKB_PAD;\r\nskb_reserve(skb, data->u.placement_offset);\r\nskb_put(skb, data->length.packet_length);\r\nskb_checksum_none_assert(skb);\r\nskb_reset_mac_header(skb);\r\nskb->protocol = eth_hdr(skb)->h_proto;\r\nif (cdev->ll2->cbs && cdev->ll2->cbs->rx_cb) {\r\nif (data->vlan)\r\n__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q),\r\ndata->vlan);\r\ncdev->ll2->cbs->rx_cb(cdev->ll2->cb_cookie, skb,\r\ndata->opaque_data_0,\r\ndata->opaque_data_1);\r\n}\r\nbuffer->data = new_data;\r\nbuffer->phys_addr = new_phys_addr;\r\nout_post:\r\nrc = qed_ll2_post_rx_buffer(QED_LEADING_HWFN(cdev), cdev->ll2->handle,\r\nbuffer->phys_addr, 0, buffer, 1);\r\nif (rc)\r\nqed_ll2_dealloc_buffer(cdev, buffer);\r\n}\r\nstatic struct qed_ll2_info *__qed_ll2_handle_sanity(struct qed_hwfn *p_hwfn,\r\nu8 connection_handle,\r\nbool b_lock,\r\nbool b_only_active)\r\n{\r\nstruct qed_ll2_info *p_ll2_conn, *p_ret = NULL;\r\nif (connection_handle >= QED_MAX_NUM_OF_LL2_CONNECTIONS)\r\nreturn NULL;\r\nif (!p_hwfn->p_ll2_info)\r\nreturn NULL;\r\np_ll2_conn = &p_hwfn->p_ll2_info[connection_handle];\r\nif (b_only_active) {\r\nif (b_lock)\r\nmutex_lock(&p_ll2_conn->mutex);\r\nif (p_ll2_conn->b_active)\r\np_ret = p_ll2_conn;\r\nif (b_lock)\r\nmutex_unlock(&p_ll2_conn->mutex);\r\n} else {\r\np_ret = p_ll2_conn;\r\n}\r\nreturn p_ret;\r\n}\r\nstatic struct qed_ll2_info *qed_ll2_handle_sanity(struct qed_hwfn *p_hwfn,\r\nu8 connection_handle)\r\n{\r\nreturn __qed_ll2_handle_sanity(p_hwfn, connection_handle, false, true);\r\n}\r\nstatic struct qed_ll2_info *qed_ll2_handle_sanity_lock(struct qed_hwfn *p_hwfn,\r\nu8 connection_handle)\r\n{\r\nreturn __qed_ll2_handle_sanity(p_hwfn, connection_handle, true, true);\r\n}\r\nstatic struct qed_ll2_info *qed_ll2_handle_sanity_inactive(struct qed_hwfn\r\n*p_hwfn,\r\nu8 connection_handle)\r\n{\r\nreturn __qed_ll2_handle_sanity(p_hwfn, connection_handle, false, false);\r\n}\r\nstatic void qed_ll2_txq_flush(struct qed_hwfn *p_hwfn, u8 connection_handle)\r\n{\r\nbool b_last_packet = false, b_last_frag = false;\r\nstruct qed_ll2_tx_packet *p_pkt = NULL;\r\nstruct qed_ll2_info *p_ll2_conn;\r\nstruct qed_ll2_tx_queue *p_tx;\r\ndma_addr_t tx_frag;\r\np_ll2_conn = qed_ll2_handle_sanity_inactive(p_hwfn, connection_handle);\r\nif (!p_ll2_conn)\r\nreturn;\r\np_tx = &p_ll2_conn->tx_queue;\r\nwhile (!list_empty(&p_tx->active_descq)) {\r\np_pkt = list_first_entry(&p_tx->active_descq,\r\nstruct qed_ll2_tx_packet, list_entry);\r\nif (!p_pkt)\r\nbreak;\r\nlist_del(&p_pkt->list_entry);\r\nb_last_packet = list_empty(&p_tx->active_descq);\r\nlist_add_tail(&p_pkt->list_entry, &p_tx->free_descq);\r\nif (p_ll2_conn->input.conn_type == QED_LL2_TYPE_OOO) {\r\nstruct qed_ooo_buffer *p_buffer;\r\np_buffer = (struct qed_ooo_buffer *)p_pkt->cookie;\r\nqed_ooo_put_free_buffer(p_hwfn, p_hwfn->p_ooo_info,\r\np_buffer);\r\n} else {\r\np_tx->cur_completing_packet = *p_pkt;\r\np_tx->cur_completing_bd_idx = 1;\r\nb_last_frag =\r\np_tx->cur_completing_bd_idx == p_pkt->bd_used;\r\ntx_frag = p_pkt->bds_set[0].tx_frag;\r\np_ll2_conn->cbs.tx_release_cb(p_ll2_conn->cbs.cookie,\r\np_ll2_conn->my_id,\r\np_pkt->cookie,\r\ntx_frag,\r\nb_last_frag,\r\nb_last_packet);\r\n}\r\n}\r\n}\r\nstatic int qed_ll2_txq_completion(struct qed_hwfn *p_hwfn, void *p_cookie)\r\n{\r\nstruct qed_ll2_info *p_ll2_conn = p_cookie;\r\nstruct qed_ll2_tx_queue *p_tx = &p_ll2_conn->tx_queue;\r\nu16 new_idx = 0, num_bds = 0, num_bds_in_packet = 0;\r\nstruct qed_ll2_tx_packet *p_pkt;\r\nbool b_last_frag = false;\r\nunsigned long flags;\r\nint rc = -EINVAL;\r\nspin_lock_irqsave(&p_tx->lock, flags);\r\nif (p_tx->b_completing_packet) {\r\nrc = -EBUSY;\r\ngoto out;\r\n}\r\nnew_idx = le16_to_cpu(*p_tx->p_fw_cons);\r\nnum_bds = ((s16)new_idx - (s16)p_tx->bds_idx);\r\nwhile (num_bds) {\r\nif (list_empty(&p_tx->active_descq))\r\ngoto out;\r\np_pkt = list_first_entry(&p_tx->active_descq,\r\nstruct qed_ll2_tx_packet, list_entry);\r\nif (!p_pkt)\r\ngoto out;\r\np_tx->b_completing_packet = true;\r\np_tx->cur_completing_packet = *p_pkt;\r\nnum_bds_in_packet = p_pkt->bd_used;\r\nlist_del(&p_pkt->list_entry);\r\nif (num_bds < num_bds_in_packet) {\r\nDP_NOTICE(p_hwfn,\r\n"Rest of BDs does not cover whole packet\n");\r\ngoto out;\r\n}\r\nnum_bds -= num_bds_in_packet;\r\np_tx->bds_idx += num_bds_in_packet;\r\nwhile (num_bds_in_packet--)\r\nqed_chain_consume(&p_tx->txq_chain);\r\np_tx->cur_completing_bd_idx = 1;\r\nb_last_frag = p_tx->cur_completing_bd_idx == p_pkt->bd_used;\r\nlist_add_tail(&p_pkt->list_entry, &p_tx->free_descq);\r\nspin_unlock_irqrestore(&p_tx->lock, flags);\r\np_ll2_conn->cbs.tx_comp_cb(p_ll2_conn->cbs.cookie,\r\np_ll2_conn->my_id,\r\np_pkt->cookie,\r\np_pkt->bds_set[0].tx_frag,\r\nb_last_frag, !num_bds);\r\nspin_lock_irqsave(&p_tx->lock, flags);\r\n}\r\np_tx->b_completing_packet = false;\r\nrc = 0;\r\nout:\r\nspin_unlock_irqrestore(&p_tx->lock, flags);\r\nreturn rc;\r\n}\r\nstatic void qed_ll2_rxq_parse_gsi(struct qed_hwfn *p_hwfn,\r\nunion core_rx_cqe_union *p_cqe,\r\nstruct qed_ll2_comp_rx_data *data)\r\n{\r\ndata->parse_flags = le16_to_cpu(p_cqe->rx_cqe_gsi.parse_flags.flags);\r\ndata->length.data_length = le16_to_cpu(p_cqe->rx_cqe_gsi.data_length);\r\ndata->vlan = le16_to_cpu(p_cqe->rx_cqe_gsi.vlan);\r\ndata->opaque_data_0 = le32_to_cpu(p_cqe->rx_cqe_gsi.src_mac_addrhi);\r\ndata->opaque_data_1 = le16_to_cpu(p_cqe->rx_cqe_gsi.src_mac_addrlo);\r\ndata->u.data_length_error = p_cqe->rx_cqe_gsi.data_length_error;\r\n}\r\nstatic void qed_ll2_rxq_parse_reg(struct qed_hwfn *p_hwfn,\r\nunion core_rx_cqe_union *p_cqe,\r\nstruct qed_ll2_comp_rx_data *data)\r\n{\r\ndata->parse_flags = le16_to_cpu(p_cqe->rx_cqe_fp.parse_flags.flags);\r\ndata->length.packet_length =\r\nle16_to_cpu(p_cqe->rx_cqe_fp.packet_length);\r\ndata->vlan = le16_to_cpu(p_cqe->rx_cqe_fp.vlan);\r\ndata->opaque_data_0 = le32_to_cpu(p_cqe->rx_cqe_fp.opaque_data.data[0]);\r\ndata->opaque_data_1 = le32_to_cpu(p_cqe->rx_cqe_fp.opaque_data.data[1]);\r\ndata->u.placement_offset = p_cqe->rx_cqe_fp.placement_offset;\r\n}\r\nstatic int\r\nqed_ll2_rxq_handle_completion(struct qed_hwfn *p_hwfn,\r\nstruct qed_ll2_info *p_ll2_conn,\r\nunion core_rx_cqe_union *p_cqe,\r\nunsigned long *p_lock_flags, bool b_last_cqe)\r\n{\r\nstruct qed_ll2_rx_queue *p_rx = &p_ll2_conn->rx_queue;\r\nstruct qed_ll2_rx_packet *p_pkt = NULL;\r\nstruct qed_ll2_comp_rx_data data;\r\nif (!list_empty(&p_rx->active_descq))\r\np_pkt = list_first_entry(&p_rx->active_descq,\r\nstruct qed_ll2_rx_packet, list_entry);\r\nif (!p_pkt) {\r\nDP_NOTICE(p_hwfn,\r\n"[%d] LL2 Rx completion but active_descq is empty\n",\r\np_ll2_conn->input.conn_type);\r\nreturn -EIO;\r\n}\r\nlist_del(&p_pkt->list_entry);\r\nif (p_cqe->rx_cqe_sp.type == CORE_RX_CQE_TYPE_REGULAR)\r\nqed_ll2_rxq_parse_reg(p_hwfn, p_cqe, &data);\r\nelse\r\nqed_ll2_rxq_parse_gsi(p_hwfn, p_cqe, &data);\r\nif (qed_chain_consume(&p_rx->rxq_chain) != p_pkt->rxq_bd)\r\nDP_NOTICE(p_hwfn,\r\n"Mismatch between active_descq and the LL2 Rx chain\n");\r\nlist_add_tail(&p_pkt->list_entry, &p_rx->free_descq);\r\ndata.connection_handle = p_ll2_conn->my_id;\r\ndata.cookie = p_pkt->cookie;\r\ndata.rx_buf_addr = p_pkt->rx_buf_addr;\r\ndata.b_last_packet = b_last_cqe;\r\nspin_unlock_irqrestore(&p_rx->lock, *p_lock_flags);\r\np_ll2_conn->cbs.rx_comp_cb(p_ll2_conn->cbs.cookie, &data);\r\nspin_lock_irqsave(&p_rx->lock, *p_lock_flags);\r\nreturn 0;\r\n}\r\nstatic int qed_ll2_rxq_completion(struct qed_hwfn *p_hwfn, void *cookie)\r\n{\r\nstruct qed_ll2_info *p_ll2_conn = (struct qed_ll2_info *)cookie;\r\nstruct qed_ll2_rx_queue *p_rx = &p_ll2_conn->rx_queue;\r\nunion core_rx_cqe_union *cqe = NULL;\r\nu16 cq_new_idx = 0, cq_old_idx = 0;\r\nunsigned long flags = 0;\r\nint rc = 0;\r\nspin_lock_irqsave(&p_rx->lock, flags);\r\ncq_new_idx = le16_to_cpu(*p_rx->p_fw_cons);\r\ncq_old_idx = qed_chain_get_cons_idx(&p_rx->rcq_chain);\r\nwhile (cq_new_idx != cq_old_idx) {\r\nbool b_last_cqe = (cq_new_idx == cq_old_idx);\r\ncqe =\r\n(union core_rx_cqe_union *)\r\nqed_chain_consume(&p_rx->rcq_chain);\r\ncq_old_idx = qed_chain_get_cons_idx(&p_rx->rcq_chain);\r\nDP_VERBOSE(p_hwfn,\r\nQED_MSG_LL2,\r\n"LL2 [sw. cons %04x, fw. at %04x] - Got Packet of type %02x\n",\r\ncq_old_idx, cq_new_idx, cqe->rx_cqe_sp.type);\r\nswitch (cqe->rx_cqe_sp.type) {\r\ncase CORE_RX_CQE_TYPE_SLOW_PATH:\r\nDP_NOTICE(p_hwfn, "LL2 - unexpected Rx CQE slowpath\n");\r\nrc = -EINVAL;\r\nbreak;\r\ncase CORE_RX_CQE_TYPE_GSI_OFFLOAD:\r\ncase CORE_RX_CQE_TYPE_REGULAR:\r\nrc = qed_ll2_rxq_handle_completion(p_hwfn, p_ll2_conn,\r\ncqe, &flags,\r\nb_last_cqe);\r\nbreak;\r\ndefault:\r\nrc = -EIO;\r\n}\r\n}\r\nspin_unlock_irqrestore(&p_rx->lock, flags);\r\nreturn rc;\r\n}\r\nstatic void qed_ll2_rxq_flush(struct qed_hwfn *p_hwfn, u8 connection_handle)\r\n{\r\nstruct qed_ll2_info *p_ll2_conn = NULL;\r\nstruct qed_ll2_rx_packet *p_pkt = NULL;\r\nstruct qed_ll2_rx_queue *p_rx;\r\np_ll2_conn = qed_ll2_handle_sanity_inactive(p_hwfn, connection_handle);\r\nif (!p_ll2_conn)\r\nreturn;\r\np_rx = &p_ll2_conn->rx_queue;\r\nwhile (!list_empty(&p_rx->active_descq)) {\r\np_pkt = list_first_entry(&p_rx->active_descq,\r\nstruct qed_ll2_rx_packet, list_entry);\r\nif (!p_pkt)\r\nbreak;\r\nlist_move_tail(&p_pkt->list_entry, &p_rx->free_descq);\r\nif (p_ll2_conn->input.conn_type == QED_LL2_TYPE_OOO) {\r\nstruct qed_ooo_buffer *p_buffer;\r\np_buffer = (struct qed_ooo_buffer *)p_pkt->cookie;\r\nqed_ooo_put_free_buffer(p_hwfn, p_hwfn->p_ooo_info,\r\np_buffer);\r\n} else {\r\ndma_addr_t rx_buf_addr = p_pkt->rx_buf_addr;\r\nvoid *cookie = p_pkt->cookie;\r\nbool b_last;\r\nb_last = list_empty(&p_rx->active_descq);\r\np_ll2_conn->cbs.rx_release_cb(p_ll2_conn->cbs.cookie,\r\np_ll2_conn->my_id,\r\ncookie,\r\nrx_buf_addr, b_last);\r\n}\r\n}\r\n}\r\nstatic u8 qed_ll2_convert_rx_parse_to_tx_flags(u16 parse_flags)\r\n{\r\nu8 bd_flags = 0;\r\nif (GET_FIELD(parse_flags, PARSING_AND_ERR_FLAGS_TAG8021QEXIST))\r\nSET_FIELD(bd_flags, CORE_TX_BD_DATA_VLAN_INSERTION, 1);\r\nreturn bd_flags;\r\n}\r\nstatic int qed_ll2_lb_rxq_handler(struct qed_hwfn *p_hwfn,\r\nstruct qed_ll2_info *p_ll2_conn)\r\n{\r\nstruct qed_ll2_rx_queue *p_rx = &p_ll2_conn->rx_queue;\r\nu16 packet_length = 0, parse_flags = 0, vlan = 0;\r\nstruct qed_ll2_rx_packet *p_pkt = NULL;\r\nu32 num_ooo_add_to_peninsula = 0, cid;\r\nunion core_rx_cqe_union *cqe = NULL;\r\nu16 cq_new_idx = 0, cq_old_idx = 0;\r\nstruct qed_ooo_buffer *p_buffer;\r\nstruct ooo_opaque *iscsi_ooo;\r\nu8 placement_offset = 0;\r\nu8 cqe_type;\r\ncq_new_idx = le16_to_cpu(*p_rx->p_fw_cons);\r\ncq_old_idx = qed_chain_get_cons_idx(&p_rx->rcq_chain);\r\nif (cq_new_idx == cq_old_idx)\r\nreturn 0;\r\nwhile (cq_new_idx != cq_old_idx) {\r\nstruct core_rx_fast_path_cqe *p_cqe_fp;\r\ncqe = qed_chain_consume(&p_rx->rcq_chain);\r\ncq_old_idx = qed_chain_get_cons_idx(&p_rx->rcq_chain);\r\ncqe_type = cqe->rx_cqe_sp.type;\r\nif (cqe_type != CORE_RX_CQE_TYPE_REGULAR) {\r\nDP_NOTICE(p_hwfn,\r\n"Got a non-regular LB LL2 completion [type 0x%02x]\n",\r\ncqe_type);\r\nreturn -EINVAL;\r\n}\r\np_cqe_fp = &cqe->rx_cqe_fp;\r\nplacement_offset = p_cqe_fp->placement_offset;\r\nparse_flags = le16_to_cpu(p_cqe_fp->parse_flags.flags);\r\npacket_length = le16_to_cpu(p_cqe_fp->packet_length);\r\nvlan = le16_to_cpu(p_cqe_fp->vlan);\r\niscsi_ooo = (struct ooo_opaque *)&p_cqe_fp->opaque_data;\r\nqed_ooo_save_history_entry(p_hwfn, p_hwfn->p_ooo_info,\r\niscsi_ooo);\r\ncid = le32_to_cpu(iscsi_ooo->cid);\r\nif (iscsi_ooo->drop_size)\r\nqed_ooo_delete_isles(p_hwfn, p_hwfn->p_ooo_info, cid,\r\niscsi_ooo->drop_isle,\r\niscsi_ooo->drop_size);\r\nif (iscsi_ooo->ooo_opcode == TCP_EVENT_NOP)\r\ncontinue;\r\nif (list_empty(&p_rx->active_descq)) {\r\nDP_NOTICE(p_hwfn,\r\n"LL2 OOO RX chain has no submitted buffers\n"\r\n);\r\nreturn -EIO;\r\n}\r\np_pkt = list_first_entry(&p_rx->active_descq,\r\nstruct qed_ll2_rx_packet, list_entry);\r\nif ((iscsi_ooo->ooo_opcode == TCP_EVENT_ADD_NEW_ISLE) ||\r\n(iscsi_ooo->ooo_opcode == TCP_EVENT_ADD_ISLE_RIGHT) ||\r\n(iscsi_ooo->ooo_opcode == TCP_EVENT_ADD_ISLE_LEFT) ||\r\n(iscsi_ooo->ooo_opcode == TCP_EVENT_ADD_PEN) ||\r\n(iscsi_ooo->ooo_opcode == TCP_EVENT_JOIN)) {\r\nif (!p_pkt) {\r\nDP_NOTICE(p_hwfn,\r\n"LL2 OOO RX packet is not valid\n");\r\nreturn -EIO;\r\n}\r\nlist_del(&p_pkt->list_entry);\r\np_buffer = (struct qed_ooo_buffer *)p_pkt->cookie;\r\np_buffer->packet_length = packet_length;\r\np_buffer->parse_flags = parse_flags;\r\np_buffer->vlan = vlan;\r\np_buffer->placement_offset = placement_offset;\r\nqed_chain_consume(&p_rx->rxq_chain);\r\nlist_add_tail(&p_pkt->list_entry, &p_rx->free_descq);\r\nswitch (iscsi_ooo->ooo_opcode) {\r\ncase TCP_EVENT_ADD_NEW_ISLE:\r\nqed_ooo_add_new_isle(p_hwfn,\r\np_hwfn->p_ooo_info,\r\ncid,\r\niscsi_ooo->ooo_isle,\r\np_buffer);\r\nbreak;\r\ncase TCP_EVENT_ADD_ISLE_RIGHT:\r\nqed_ooo_add_new_buffer(p_hwfn,\r\np_hwfn->p_ooo_info,\r\ncid,\r\niscsi_ooo->ooo_isle,\r\np_buffer,\r\nQED_OOO_RIGHT_BUF);\r\nbreak;\r\ncase TCP_EVENT_ADD_ISLE_LEFT:\r\nqed_ooo_add_new_buffer(p_hwfn,\r\np_hwfn->p_ooo_info,\r\ncid,\r\niscsi_ooo->ooo_isle,\r\np_buffer,\r\nQED_OOO_LEFT_BUF);\r\nbreak;\r\ncase TCP_EVENT_JOIN:\r\nqed_ooo_add_new_buffer(p_hwfn,\r\np_hwfn->p_ooo_info,\r\ncid,\r\niscsi_ooo->ooo_isle +\r\n1,\r\np_buffer,\r\nQED_OOO_LEFT_BUF);\r\nqed_ooo_join_isles(p_hwfn,\r\np_hwfn->p_ooo_info,\r\ncid, iscsi_ooo->ooo_isle);\r\nbreak;\r\ncase TCP_EVENT_ADD_PEN:\r\nnum_ooo_add_to_peninsula++;\r\nqed_ooo_put_ready_buffer(p_hwfn,\r\np_hwfn->p_ooo_info,\r\np_buffer, true);\r\nbreak;\r\n}\r\n} else {\r\nDP_NOTICE(p_hwfn,\r\n"Unexpected event (%d) TX OOO completion\n",\r\niscsi_ooo->ooo_opcode);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nqed_ooo_submit_tx_buffers(struct qed_hwfn *p_hwfn,\r\nstruct qed_ll2_info *p_ll2_conn)\r\n{\r\nstruct qed_ll2_tx_pkt_info tx_pkt;\r\nstruct qed_ooo_buffer *p_buffer;\r\nu16 l4_hdr_offset_w;\r\ndma_addr_t first_frag;\r\nu16 parse_flags;\r\nu8 bd_flags;\r\nint rc;\r\nwhile ((p_buffer = qed_ooo_get_ready_buffer(p_hwfn,\r\np_hwfn->p_ooo_info))) {\r\nl4_hdr_offset_w = 0;\r\nbd_flags = 0;\r\nfirst_frag = p_buffer->rx_buffer_phys_addr +\r\np_buffer->placement_offset;\r\nparse_flags = p_buffer->parse_flags;\r\nbd_flags = qed_ll2_convert_rx_parse_to_tx_flags(parse_flags);\r\nSET_FIELD(bd_flags, CORE_TX_BD_DATA_FORCE_VLAN_MODE, 1);\r\nSET_FIELD(bd_flags, CORE_TX_BD_DATA_L4_PROTOCOL, 1);\r\nmemset(&tx_pkt, 0, sizeof(tx_pkt));\r\ntx_pkt.num_of_bds = 1;\r\ntx_pkt.vlan = p_buffer->vlan;\r\ntx_pkt.bd_flags = bd_flags;\r\ntx_pkt.l4_hdr_offset_w = l4_hdr_offset_w;\r\ntx_pkt.tx_dest = p_ll2_conn->tx_dest;\r\ntx_pkt.first_frag = first_frag;\r\ntx_pkt.first_frag_len = p_buffer->packet_length;\r\ntx_pkt.cookie = p_buffer;\r\nrc = qed_ll2_prepare_tx_packet(p_hwfn, p_ll2_conn->my_id,\r\n&tx_pkt, true);\r\nif (rc) {\r\nqed_ooo_put_ready_buffer(p_hwfn, p_hwfn->p_ooo_info,\r\np_buffer, false);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void\r\nqed_ooo_submit_rx_buffers(struct qed_hwfn *p_hwfn,\r\nstruct qed_ll2_info *p_ll2_conn)\r\n{\r\nstruct qed_ooo_buffer *p_buffer;\r\nint rc;\r\nwhile ((p_buffer = qed_ooo_get_free_buffer(p_hwfn,\r\np_hwfn->p_ooo_info))) {\r\nrc = qed_ll2_post_rx_buffer(p_hwfn,\r\np_ll2_conn->my_id,\r\np_buffer->rx_buffer_phys_addr,\r\n0, p_buffer, true);\r\nif (rc) {\r\nqed_ooo_put_free_buffer(p_hwfn,\r\np_hwfn->p_ooo_info, p_buffer);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int qed_ll2_lb_rxq_completion(struct qed_hwfn *p_hwfn, void *p_cookie)\r\n{\r\nstruct qed_ll2_info *p_ll2_conn = (struct qed_ll2_info *)p_cookie;\r\nint rc;\r\nrc = qed_ll2_lb_rxq_handler(p_hwfn, p_ll2_conn);\r\nif (rc)\r\nreturn rc;\r\nqed_ooo_submit_rx_buffers(p_hwfn, p_ll2_conn);\r\nqed_ooo_submit_tx_buffers(p_hwfn, p_ll2_conn);\r\nreturn 0;\r\n}\r\nstatic int qed_ll2_lb_txq_completion(struct qed_hwfn *p_hwfn, void *p_cookie)\r\n{\r\nstruct qed_ll2_info *p_ll2_conn = (struct qed_ll2_info *)p_cookie;\r\nstruct qed_ll2_tx_queue *p_tx = &p_ll2_conn->tx_queue;\r\nstruct qed_ll2_tx_packet *p_pkt = NULL;\r\nstruct qed_ooo_buffer *p_buffer;\r\nbool b_dont_submit_rx = false;\r\nu16 new_idx = 0, num_bds = 0;\r\nint rc;\r\nnew_idx = le16_to_cpu(*p_tx->p_fw_cons);\r\nnum_bds = ((s16)new_idx - (s16)p_tx->bds_idx);\r\nif (!num_bds)\r\nreturn 0;\r\nwhile (num_bds) {\r\nif (list_empty(&p_tx->active_descq))\r\nreturn -EINVAL;\r\np_pkt = list_first_entry(&p_tx->active_descq,\r\nstruct qed_ll2_tx_packet, list_entry);\r\nif (!p_pkt)\r\nreturn -EINVAL;\r\nif (p_pkt->bd_used != 1) {\r\nDP_NOTICE(p_hwfn,\r\n"Unexpectedly many BDs(%d) in TX OOO completion\n",\r\np_pkt->bd_used);\r\nreturn -EINVAL;\r\n}\r\nlist_del(&p_pkt->list_entry);\r\nnum_bds--;\r\np_tx->bds_idx++;\r\nqed_chain_consume(&p_tx->txq_chain);\r\np_buffer = (struct qed_ooo_buffer *)p_pkt->cookie;\r\nlist_add_tail(&p_pkt->list_entry, &p_tx->free_descq);\r\nif (b_dont_submit_rx) {\r\nqed_ooo_put_free_buffer(p_hwfn, p_hwfn->p_ooo_info,\r\np_buffer);\r\ncontinue;\r\n}\r\nrc = qed_ll2_post_rx_buffer(p_hwfn, p_ll2_conn->my_id,\r\np_buffer->rx_buffer_phys_addr, 0,\r\np_buffer, true);\r\nif (rc != 0) {\r\nqed_ooo_put_free_buffer(p_hwfn,\r\np_hwfn->p_ooo_info, p_buffer);\r\nb_dont_submit_rx = true;\r\n}\r\n}\r\nqed_ooo_submit_tx_buffers(p_hwfn, p_ll2_conn);\r\nreturn 0;\r\n}\r\nstatic void qed_ll2_stop_ooo(struct qed_dev *cdev)\r\n{\r\nstruct qed_hwfn *hwfn = QED_LEADING_HWFN(cdev);\r\nu8 *handle = &hwfn->pf_params.iscsi_pf_params.ll2_ooo_queue_id;\r\nDP_VERBOSE(cdev, QED_MSG_STORAGE, "Stopping LL2 OOO queue [%02x]\n",\r\n*handle);\r\nqed_ll2_terminate_connection(hwfn, *handle);\r\nqed_ll2_release_connection(hwfn, *handle);\r\n*handle = QED_LL2_UNUSED_HANDLE;\r\n}\r\nstatic int qed_sp_ll2_rx_queue_start(struct qed_hwfn *p_hwfn,\r\nstruct qed_ll2_info *p_ll2_conn,\r\nu8 action_on_error)\r\n{\r\nenum qed_ll2_conn_type conn_type = p_ll2_conn->input.conn_type;\r\nstruct qed_ll2_rx_queue *p_rx = &p_ll2_conn->rx_queue;\r\nstruct core_rx_start_ramrod_data *p_ramrod = NULL;\r\nstruct qed_spq_entry *p_ent = NULL;\r\nstruct qed_sp_init_data init_data;\r\nu16 cqe_pbl_size;\r\nint rc = 0;\r\nmemset(&init_data, 0, sizeof(init_data));\r\ninit_data.cid = p_ll2_conn->cid;\r\ninit_data.opaque_fid = p_hwfn->hw_info.opaque_fid;\r\ninit_data.comp_mode = QED_SPQ_MODE_EBLOCK;\r\nrc = qed_sp_init_request(p_hwfn, &p_ent,\r\nCORE_RAMROD_RX_QUEUE_START,\r\nPROTOCOLID_CORE, &init_data);\r\nif (rc)\r\nreturn rc;\r\np_ramrod = &p_ent->ramrod.core_rx_queue_start;\r\np_ramrod->sb_id = cpu_to_le16(qed_int_get_sp_sb_id(p_hwfn));\r\np_ramrod->sb_index = p_rx->rx_sb_index;\r\np_ramrod->complete_event_flg = 1;\r\np_ramrod->mtu = cpu_to_le16(p_ll2_conn->input.mtu);\r\nDMA_REGPAIR_LE(p_ramrod->bd_base, p_rx->rxq_chain.p_phys_addr);\r\ncqe_pbl_size = (u16)qed_chain_get_page_cnt(&p_rx->rcq_chain);\r\np_ramrod->num_of_pbl_pages = cpu_to_le16(cqe_pbl_size);\r\nDMA_REGPAIR_LE(p_ramrod->cqe_pbl_addr,\r\nqed_chain_get_pbl_phys(&p_rx->rcq_chain));\r\np_ramrod->drop_ttl0_flg = p_ll2_conn->input.rx_drop_ttl0_flg;\r\np_ramrod->inner_vlan_removal_en = p_ll2_conn->input.rx_vlan_removal_en;\r\np_ramrod->queue_id = p_ll2_conn->queue_id;\r\np_ramrod->main_func_queue = (conn_type == QED_LL2_TYPE_OOO) ? 0 : 1;\r\nif ((IS_MF_DEFAULT(p_hwfn) || IS_MF_SI(p_hwfn)) &&\r\np_ramrod->main_func_queue && (conn_type != QED_LL2_TYPE_ROCE) &&\r\n(conn_type != QED_LL2_TYPE_IWARP)) {\r\np_ramrod->mf_si_bcast_accept_all = 1;\r\np_ramrod->mf_si_mcast_accept_all = 1;\r\n} else {\r\np_ramrod->mf_si_bcast_accept_all = 0;\r\np_ramrod->mf_si_mcast_accept_all = 0;\r\n}\r\np_ramrod->action_on_error.error_type = action_on_error;\r\np_ramrod->gsi_offload_flag = p_ll2_conn->input.gsi_enable;\r\nreturn qed_spq_post(p_hwfn, p_ent, NULL);\r\n}\r\nstatic int qed_sp_ll2_tx_queue_start(struct qed_hwfn *p_hwfn,\r\nstruct qed_ll2_info *p_ll2_conn)\r\n{\r\nenum qed_ll2_conn_type conn_type = p_ll2_conn->input.conn_type;\r\nstruct qed_ll2_tx_queue *p_tx = &p_ll2_conn->tx_queue;\r\nstruct core_tx_start_ramrod_data *p_ramrod = NULL;\r\nstruct qed_spq_entry *p_ent = NULL;\r\nstruct qed_sp_init_data init_data;\r\nu16 pq_id = 0, pbl_size;\r\nint rc = -EINVAL;\r\nif (!QED_LL2_TX_REGISTERED(p_ll2_conn))\r\nreturn 0;\r\nif (p_ll2_conn->input.conn_type == QED_LL2_TYPE_OOO)\r\np_ll2_conn->tx_stats_en = 0;\r\nelse\r\np_ll2_conn->tx_stats_en = 1;\r\nmemset(&init_data, 0, sizeof(init_data));\r\ninit_data.cid = p_ll2_conn->cid;\r\ninit_data.opaque_fid = p_hwfn->hw_info.opaque_fid;\r\ninit_data.comp_mode = QED_SPQ_MODE_EBLOCK;\r\nrc = qed_sp_init_request(p_hwfn, &p_ent,\r\nCORE_RAMROD_TX_QUEUE_START,\r\nPROTOCOLID_CORE, &init_data);\r\nif (rc)\r\nreturn rc;\r\np_ramrod = &p_ent->ramrod.core_tx_queue_start;\r\np_ramrod->sb_id = cpu_to_le16(qed_int_get_sp_sb_id(p_hwfn));\r\np_ramrod->sb_index = p_tx->tx_sb_index;\r\np_ramrod->mtu = cpu_to_le16(p_ll2_conn->input.mtu);\r\np_ramrod->stats_en = p_ll2_conn->tx_stats_en;\r\np_ramrod->stats_id = p_ll2_conn->tx_stats_id;\r\nDMA_REGPAIR_LE(p_ramrod->pbl_base_addr,\r\nqed_chain_get_pbl_phys(&p_tx->txq_chain));\r\npbl_size = qed_chain_get_page_cnt(&p_tx->txq_chain);\r\np_ramrod->pbl_size = cpu_to_le16(pbl_size);\r\nswitch (p_ll2_conn->input.tx_tc) {\r\ncase PURE_LB_TC:\r\npq_id = qed_get_cm_pq_idx(p_hwfn, PQ_FLAGS_LB);\r\nbreak;\r\ncase PKT_LB_TC:\r\npq_id = qed_get_cm_pq_idx(p_hwfn, PQ_FLAGS_OOO);\r\nbreak;\r\ndefault:\r\npq_id = qed_get_cm_pq_idx(p_hwfn, PQ_FLAGS_OFLD);\r\nbreak;\r\n}\r\np_ramrod->qm_pq_id = cpu_to_le16(pq_id);\r\nswitch (conn_type) {\r\ncase QED_LL2_TYPE_FCOE:\r\np_ramrod->conn_type = PROTOCOLID_FCOE;\r\nbreak;\r\ncase QED_LL2_TYPE_ISCSI:\r\np_ramrod->conn_type = PROTOCOLID_ISCSI;\r\nbreak;\r\ncase QED_LL2_TYPE_ROCE:\r\np_ramrod->conn_type = PROTOCOLID_ROCE;\r\nbreak;\r\ncase QED_LL2_TYPE_IWARP:\r\np_ramrod->conn_type = PROTOCOLID_IWARP;\r\nbreak;\r\ncase QED_LL2_TYPE_OOO:\r\nif (p_hwfn->hw_info.personality == QED_PCI_ISCSI)\r\np_ramrod->conn_type = PROTOCOLID_ISCSI;\r\nelse\r\np_ramrod->conn_type = PROTOCOLID_IWARP;\r\nbreak;\r\ndefault:\r\np_ramrod->conn_type = PROTOCOLID_ETH;\r\nDP_NOTICE(p_hwfn, "Unknown connection type: %d\n", conn_type);\r\n}\r\np_ramrod->gsi_offload_flag = p_ll2_conn->input.gsi_enable;\r\nreturn qed_spq_post(p_hwfn, p_ent, NULL);\r\n}\r\nstatic int qed_sp_ll2_rx_queue_stop(struct qed_hwfn *p_hwfn,\r\nstruct qed_ll2_info *p_ll2_conn)\r\n{\r\nstruct core_rx_stop_ramrod_data *p_ramrod = NULL;\r\nstruct qed_spq_entry *p_ent = NULL;\r\nstruct qed_sp_init_data init_data;\r\nint rc = -EINVAL;\r\nmemset(&init_data, 0, sizeof(init_data));\r\ninit_data.cid = p_ll2_conn->cid;\r\ninit_data.opaque_fid = p_hwfn->hw_info.opaque_fid;\r\ninit_data.comp_mode = QED_SPQ_MODE_EBLOCK;\r\nrc = qed_sp_init_request(p_hwfn, &p_ent,\r\nCORE_RAMROD_RX_QUEUE_STOP,\r\nPROTOCOLID_CORE, &init_data);\r\nif (rc)\r\nreturn rc;\r\np_ramrod = &p_ent->ramrod.core_rx_queue_stop;\r\np_ramrod->complete_event_flg = 1;\r\np_ramrod->queue_id = p_ll2_conn->queue_id;\r\nreturn qed_spq_post(p_hwfn, p_ent, NULL);\r\n}\r\nstatic int qed_sp_ll2_tx_queue_stop(struct qed_hwfn *p_hwfn,\r\nstruct qed_ll2_info *p_ll2_conn)\r\n{\r\nstruct qed_spq_entry *p_ent = NULL;\r\nstruct qed_sp_init_data init_data;\r\nint rc = -EINVAL;\r\nmemset(&init_data, 0, sizeof(init_data));\r\ninit_data.cid = p_ll2_conn->cid;\r\ninit_data.opaque_fid = p_hwfn->hw_info.opaque_fid;\r\ninit_data.comp_mode = QED_SPQ_MODE_EBLOCK;\r\nrc = qed_sp_init_request(p_hwfn, &p_ent,\r\nCORE_RAMROD_TX_QUEUE_STOP,\r\nPROTOCOLID_CORE, &init_data);\r\nif (rc)\r\nreturn rc;\r\nreturn qed_spq_post(p_hwfn, p_ent, NULL);\r\n}\r\nstatic int\r\nqed_ll2_acquire_connection_rx(struct qed_hwfn *p_hwfn,\r\nstruct qed_ll2_info *p_ll2_info)\r\n{\r\nstruct qed_ll2_rx_packet *p_descq;\r\nu32 capacity;\r\nint rc = 0;\r\nif (!p_ll2_info->input.rx_num_desc)\r\ngoto out;\r\nrc = qed_chain_alloc(p_hwfn->cdev,\r\nQED_CHAIN_USE_TO_CONSUME_PRODUCE,\r\nQED_CHAIN_MODE_NEXT_PTR,\r\nQED_CHAIN_CNT_TYPE_U16,\r\np_ll2_info->input.rx_num_desc,\r\nsizeof(struct core_rx_bd),\r\n&p_ll2_info->rx_queue.rxq_chain, NULL);\r\nif (rc) {\r\nDP_NOTICE(p_hwfn, "Failed to allocate ll2 rxq chain\n");\r\ngoto out;\r\n}\r\ncapacity = qed_chain_get_capacity(&p_ll2_info->rx_queue.rxq_chain);\r\np_descq = kcalloc(capacity, sizeof(struct qed_ll2_rx_packet),\r\nGFP_KERNEL);\r\nif (!p_descq) {\r\nrc = -ENOMEM;\r\nDP_NOTICE(p_hwfn, "Failed to allocate ll2 Rx desc\n");\r\ngoto out;\r\n}\r\np_ll2_info->rx_queue.descq_array = p_descq;\r\nrc = qed_chain_alloc(p_hwfn->cdev,\r\nQED_CHAIN_USE_TO_CONSUME_PRODUCE,\r\nQED_CHAIN_MODE_PBL,\r\nQED_CHAIN_CNT_TYPE_U16,\r\np_ll2_info->input.rx_num_desc,\r\nsizeof(struct core_rx_fast_path_cqe),\r\n&p_ll2_info->rx_queue.rcq_chain, NULL);\r\nif (rc) {\r\nDP_NOTICE(p_hwfn, "Failed to allocate ll2 rcq chain\n");\r\ngoto out;\r\n}\r\nDP_VERBOSE(p_hwfn, QED_MSG_LL2,\r\n"Allocated LL2 Rxq [Type %08x] with 0x%08x buffers\n",\r\np_ll2_info->input.conn_type, p_ll2_info->input.rx_num_desc);\r\nout:\r\nreturn rc;\r\n}\r\nstatic int qed_ll2_acquire_connection_tx(struct qed_hwfn *p_hwfn,\r\nstruct qed_ll2_info *p_ll2_info)\r\n{\r\nstruct qed_ll2_tx_packet *p_descq;\r\nu32 capacity;\r\nint rc = 0;\r\nif (!p_ll2_info->input.tx_num_desc)\r\ngoto out;\r\nrc = qed_chain_alloc(p_hwfn->cdev,\r\nQED_CHAIN_USE_TO_CONSUME_PRODUCE,\r\nQED_CHAIN_MODE_PBL,\r\nQED_CHAIN_CNT_TYPE_U16,\r\np_ll2_info->input.tx_num_desc,\r\nsizeof(struct core_tx_bd),\r\n&p_ll2_info->tx_queue.txq_chain, NULL);\r\nif (rc)\r\ngoto out;\r\ncapacity = qed_chain_get_capacity(&p_ll2_info->tx_queue.txq_chain);\r\np_descq = kcalloc(capacity, sizeof(struct qed_ll2_tx_packet),\r\nGFP_KERNEL);\r\nif (!p_descq) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\np_ll2_info->tx_queue.descq_array = p_descq;\r\nDP_VERBOSE(p_hwfn, QED_MSG_LL2,\r\n"Allocated LL2 Txq [Type %08x] with 0x%08x buffers\n",\r\np_ll2_info->input.conn_type, p_ll2_info->input.tx_num_desc);\r\nout:\r\nif (rc)\r\nDP_NOTICE(p_hwfn,\r\n"Can't allocate memory for Tx LL2 with 0x%08x buffers\n",\r\np_ll2_info->input.tx_num_desc);\r\nreturn rc;\r\n}\r\nstatic int\r\nqed_ll2_acquire_connection_ooo(struct qed_hwfn *p_hwfn,\r\nstruct qed_ll2_info *p_ll2_info, u16 mtu)\r\n{\r\nstruct qed_ooo_buffer *p_buf = NULL;\r\nvoid *p_virt;\r\nu16 buf_idx;\r\nint rc = 0;\r\nif (p_ll2_info->input.conn_type != QED_LL2_TYPE_OOO)\r\nreturn rc;\r\nif (!p_ll2_info->input.rx_num_ooo_buffers) {\r\nu16 num_desc = p_ll2_info->input.rx_num_desc;\r\nif (!num_desc)\r\nreturn -EINVAL;\r\np_ll2_info->input.rx_num_ooo_buffers = num_desc * 2;\r\n}\r\nfor (buf_idx = 0; buf_idx < p_ll2_info->input.rx_num_ooo_buffers;\r\nbuf_idx++) {\r\np_buf = kzalloc(sizeof(*p_buf), GFP_KERNEL);\r\nif (!p_buf) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\np_buf->rx_buffer_size = mtu + 26 + ETH_CACHE_LINE_SIZE;\r\np_buf->rx_buffer_size = (p_buf->rx_buffer_size +\r\nETH_CACHE_LINE_SIZE - 1) &\r\n~(ETH_CACHE_LINE_SIZE - 1);\r\np_virt = dma_alloc_coherent(&p_hwfn->cdev->pdev->dev,\r\np_buf->rx_buffer_size,\r\n&p_buf->rx_buffer_phys_addr,\r\nGFP_KERNEL);\r\nif (!p_virt) {\r\nkfree(p_buf);\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\np_buf->rx_buffer_virt_addr = p_virt;\r\nqed_ooo_put_free_buffer(p_hwfn, p_hwfn->p_ooo_info, p_buf);\r\n}\r\nDP_VERBOSE(p_hwfn, QED_MSG_LL2,\r\n"Allocated [%04x] LL2 OOO buffers [each of size 0x%08x]\n",\r\np_ll2_info->input.rx_num_ooo_buffers, p_buf->rx_buffer_size);\r\nout:\r\nreturn rc;\r\n}\r\nstatic int\r\nqed_ll2_set_cbs(struct qed_ll2_info *p_ll2_info, const struct qed_ll2_cbs *cbs)\r\n{\r\nif (!cbs || (!cbs->rx_comp_cb ||\r\n!cbs->rx_release_cb ||\r\n!cbs->tx_comp_cb || !cbs->tx_release_cb || !cbs->cookie))\r\nreturn -EINVAL;\r\np_ll2_info->cbs.rx_comp_cb = cbs->rx_comp_cb;\r\np_ll2_info->cbs.rx_release_cb = cbs->rx_release_cb;\r\np_ll2_info->cbs.tx_comp_cb = cbs->tx_comp_cb;\r\np_ll2_info->cbs.tx_release_cb = cbs->tx_release_cb;\r\np_ll2_info->cbs.cookie = cbs->cookie;\r\nreturn 0;\r\n}\r\nstatic enum core_error_handle\r\nqed_ll2_get_error_choice(enum qed_ll2_error_handle err)\r\n{\r\nswitch (err) {\r\ncase QED_LL2_DROP_PACKET:\r\nreturn LL2_DROP_PACKET;\r\ncase QED_LL2_DO_NOTHING:\r\nreturn LL2_DO_NOTHING;\r\ncase QED_LL2_ASSERT:\r\nreturn LL2_ASSERT;\r\ndefault:\r\nreturn LL2_DO_NOTHING;\r\n}\r\n}\r\nint qed_ll2_acquire_connection(void *cxt, struct qed_ll2_acquire_data *data)\r\n{\r\nstruct qed_hwfn *p_hwfn = cxt;\r\nqed_int_comp_cb_t comp_rx_cb, comp_tx_cb;\r\nstruct qed_ll2_info *p_ll2_info = NULL;\r\nu8 i, *p_tx_max;\r\nint rc;\r\nif (!data->p_connection_handle || !p_hwfn->p_ll2_info)\r\nreturn -EINVAL;\r\nfor (i = 0; (i < QED_MAX_NUM_OF_LL2_CONNECTIONS); i++) {\r\nmutex_lock(&p_hwfn->p_ll2_info[i].mutex);\r\nif (p_hwfn->p_ll2_info[i].b_active) {\r\nmutex_unlock(&p_hwfn->p_ll2_info[i].mutex);\r\ncontinue;\r\n}\r\np_hwfn->p_ll2_info[i].b_active = true;\r\np_ll2_info = &p_hwfn->p_ll2_info[i];\r\nmutex_unlock(&p_hwfn->p_ll2_info[i].mutex);\r\nbreak;\r\n}\r\nif (!p_ll2_info)\r\nreturn -EBUSY;\r\nmemcpy(&p_ll2_info->input, &data->input, sizeof(p_ll2_info->input));\r\np_ll2_info->tx_dest = (data->input.tx_dest == QED_LL2_TX_DEST_NW) ?\r\nCORE_TX_DEST_NW : CORE_TX_DEST_LB;\r\np_tx_max = &p_ll2_info->input.tx_max_bds_per_packet;\r\nif (*p_tx_max == 0)\r\n*p_tx_max = CORE_LL2_TX_MAX_BDS_PER_PACKET;\r\nelse\r\n*p_tx_max = min_t(u8, *p_tx_max,\r\nCORE_LL2_TX_MAX_BDS_PER_PACKET);\r\nrc = qed_ll2_set_cbs(p_ll2_info, data->cbs);\r\nif (rc) {\r\nDP_NOTICE(p_hwfn, "Invalid callback functions\n");\r\ngoto q_allocate_fail;\r\n}\r\nrc = qed_ll2_acquire_connection_rx(p_hwfn, p_ll2_info);\r\nif (rc)\r\ngoto q_allocate_fail;\r\nrc = qed_ll2_acquire_connection_tx(p_hwfn, p_ll2_info);\r\nif (rc)\r\ngoto q_allocate_fail;\r\nrc = qed_ll2_acquire_connection_ooo(p_hwfn, p_ll2_info,\r\ndata->input.mtu);\r\nif (rc)\r\ngoto q_allocate_fail;\r\nif (data->input.conn_type == QED_LL2_TYPE_OOO) {\r\ncomp_rx_cb = qed_ll2_lb_rxq_completion;\r\ncomp_tx_cb = qed_ll2_lb_txq_completion;\r\n} else {\r\ncomp_rx_cb = qed_ll2_rxq_completion;\r\ncomp_tx_cb = qed_ll2_txq_completion;\r\n}\r\nif (data->input.rx_num_desc) {\r\nqed_int_register_cb(p_hwfn, comp_rx_cb,\r\n&p_hwfn->p_ll2_info[i],\r\n&p_ll2_info->rx_queue.rx_sb_index,\r\n&p_ll2_info->rx_queue.p_fw_cons);\r\np_ll2_info->rx_queue.b_cb_registred = true;\r\n}\r\nif (data->input.tx_num_desc) {\r\nqed_int_register_cb(p_hwfn,\r\ncomp_tx_cb,\r\n&p_hwfn->p_ll2_info[i],\r\n&p_ll2_info->tx_queue.tx_sb_index,\r\n&p_ll2_info->tx_queue.p_fw_cons);\r\np_ll2_info->tx_queue.b_cb_registred = true;\r\n}\r\n*data->p_connection_handle = i;\r\nreturn rc;\r\nq_allocate_fail:\r\nqed_ll2_release_connection(p_hwfn, i);\r\nreturn -ENOMEM;\r\n}\r\nstatic int qed_ll2_establish_connection_rx(struct qed_hwfn *p_hwfn,\r\nstruct qed_ll2_info *p_ll2_conn)\r\n{\r\nenum qed_ll2_error_handle error_input;\r\nenum core_error_handle error_mode;\r\nu8 action_on_error = 0;\r\nif (!QED_LL2_RX_REGISTERED(p_ll2_conn))\r\nreturn 0;\r\nDIRECT_REG_WR(p_ll2_conn->rx_queue.set_prod_addr, 0x0);\r\nerror_input = p_ll2_conn->input.ai_err_packet_too_big;\r\nerror_mode = qed_ll2_get_error_choice(error_input);\r\nSET_FIELD(action_on_error,\r\nCORE_RX_ACTION_ON_ERROR_PACKET_TOO_BIG, error_mode);\r\nerror_input = p_ll2_conn->input.ai_err_no_buf;\r\nerror_mode = qed_ll2_get_error_choice(error_input);\r\nSET_FIELD(action_on_error, CORE_RX_ACTION_ON_ERROR_NO_BUFF, error_mode);\r\nreturn qed_sp_ll2_rx_queue_start(p_hwfn, p_ll2_conn, action_on_error);\r\n}\r\nstatic void\r\nqed_ll2_establish_connection_ooo(struct qed_hwfn *p_hwfn,\r\nstruct qed_ll2_info *p_ll2_conn)\r\n{\r\nif (p_ll2_conn->input.conn_type != QED_LL2_TYPE_OOO)\r\nreturn;\r\nqed_ooo_release_all_isles(p_hwfn, p_hwfn->p_ooo_info);\r\nqed_ooo_submit_rx_buffers(p_hwfn, p_ll2_conn);\r\n}\r\nint qed_ll2_establish_connection(void *cxt, u8 connection_handle)\r\n{\r\nstruct qed_hwfn *p_hwfn = cxt;\r\nstruct qed_ll2_info *p_ll2_conn;\r\nstruct qed_ll2_rx_queue *p_rx;\r\nstruct qed_ll2_tx_queue *p_tx;\r\nstruct qed_ptt *p_ptt;\r\nint rc = -EINVAL;\r\nu32 i, capacity;\r\nu8 qid;\r\np_ptt = qed_ptt_acquire(p_hwfn);\r\nif (!p_ptt)\r\nreturn -EAGAIN;\r\np_ll2_conn = qed_ll2_handle_sanity_lock(p_hwfn, connection_handle);\r\nif (!p_ll2_conn) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\np_rx = &p_ll2_conn->rx_queue;\r\np_tx = &p_ll2_conn->tx_queue;\r\nqed_chain_reset(&p_rx->rxq_chain);\r\nqed_chain_reset(&p_rx->rcq_chain);\r\nINIT_LIST_HEAD(&p_rx->active_descq);\r\nINIT_LIST_HEAD(&p_rx->free_descq);\r\nINIT_LIST_HEAD(&p_rx->posting_descq);\r\nspin_lock_init(&p_rx->lock);\r\ncapacity = qed_chain_get_capacity(&p_rx->rxq_chain);\r\nfor (i = 0; i < capacity; i++)\r\nlist_add_tail(&p_rx->descq_array[i].list_entry,\r\n&p_rx->free_descq);\r\n*p_rx->p_fw_cons = 0;\r\nqed_chain_reset(&p_tx->txq_chain);\r\nINIT_LIST_HEAD(&p_tx->active_descq);\r\nINIT_LIST_HEAD(&p_tx->free_descq);\r\nINIT_LIST_HEAD(&p_tx->sending_descq);\r\nspin_lock_init(&p_tx->lock);\r\ncapacity = qed_chain_get_capacity(&p_tx->txq_chain);\r\nfor (i = 0; i < capacity; i++)\r\nlist_add_tail(&p_tx->descq_array[i].list_entry,\r\n&p_tx->free_descq);\r\np_tx->cur_completing_bd_idx = 0;\r\np_tx->bds_idx = 0;\r\np_tx->b_completing_packet = false;\r\np_tx->cur_send_packet = NULL;\r\np_tx->cur_send_frag_num = 0;\r\np_tx->cur_completing_frag_num = 0;\r\n*p_tx->p_fw_cons = 0;\r\nrc = qed_cxt_acquire_cid(p_hwfn, PROTOCOLID_CORE, &p_ll2_conn->cid);\r\nif (rc)\r\ngoto out;\r\nqid = p_hwfn->hw_info.resc_start[QED_LL2_QUEUE] + connection_handle;\r\np_ll2_conn->queue_id = qid;\r\np_ll2_conn->tx_stats_id = qid;\r\np_rx->set_prod_addr = (u8 __iomem *)p_hwfn->regview +\r\nGTT_BAR0_MAP_REG_TSDM_RAM +\r\nTSTORM_LL2_RX_PRODS_OFFSET(qid);\r\np_tx->doorbell_addr = (u8 __iomem *)p_hwfn->doorbells +\r\nqed_db_addr(p_ll2_conn->cid,\r\nDQ_DEMS_LEGACY);\r\nrc = qed_ll2_establish_connection_rx(p_hwfn, p_ll2_conn);\r\nif (rc)\r\ngoto out;\r\nrc = qed_sp_ll2_tx_queue_start(p_hwfn, p_ll2_conn);\r\nif (rc)\r\ngoto out;\r\nif (!QED_IS_RDMA_PERSONALITY(p_hwfn))\r\nqed_wr(p_hwfn, p_ptt, PRS_REG_USE_LIGHT_L2, 1);\r\nqed_ll2_establish_connection_ooo(p_hwfn, p_ll2_conn);\r\nif (p_ll2_conn->input.conn_type == QED_LL2_TYPE_FCOE) {\r\nqed_llh_add_protocol_filter(p_hwfn, p_ptt,\r\n0x8906, 0,\r\nQED_LLH_FILTER_ETHERTYPE);\r\nqed_llh_add_protocol_filter(p_hwfn, p_ptt,\r\n0x8914, 0,\r\nQED_LLH_FILTER_ETHERTYPE);\r\n}\r\nout:\r\nqed_ptt_release(p_hwfn, p_ptt);\r\nreturn rc;\r\n}\r\nstatic void qed_ll2_post_rx_buffer_notify_fw(struct qed_hwfn *p_hwfn,\r\nstruct qed_ll2_rx_queue *p_rx,\r\nstruct qed_ll2_rx_packet *p_curp)\r\n{\r\nstruct qed_ll2_rx_packet *p_posting_packet = NULL;\r\nstruct core_ll2_rx_prod rx_prod = { 0, 0, 0 };\r\nbool b_notify_fw = false;\r\nu16 bd_prod, cq_prod;\r\nwhile (!list_empty(&p_rx->posting_descq)) {\r\np_posting_packet = list_first_entry(&p_rx->posting_descq,\r\nstruct qed_ll2_rx_packet,\r\nlist_entry);\r\nlist_move_tail(&p_posting_packet->list_entry,\r\n&p_rx->active_descq);\r\nb_notify_fw = true;\r\n}\r\nif (p_curp) {\r\nlist_add_tail(&p_curp->list_entry, &p_rx->active_descq);\r\nb_notify_fw = true;\r\n}\r\nif (!b_notify_fw)\r\nreturn;\r\nbd_prod = qed_chain_get_prod_idx(&p_rx->rxq_chain);\r\ncq_prod = qed_chain_get_prod_idx(&p_rx->rcq_chain);\r\nrx_prod.bd_prod = cpu_to_le16(bd_prod);\r\nrx_prod.cqe_prod = cpu_to_le16(cq_prod);\r\nDIRECT_REG_WR(p_rx->set_prod_addr, *((u32 *)&rx_prod));\r\n}\r\nint qed_ll2_post_rx_buffer(void *cxt,\r\nu8 connection_handle,\r\ndma_addr_t addr,\r\nu16 buf_len, void *cookie, u8 notify_fw)\r\n{\r\nstruct qed_hwfn *p_hwfn = cxt;\r\nstruct core_rx_bd_with_buff_len *p_curb = NULL;\r\nstruct qed_ll2_rx_packet *p_curp = NULL;\r\nstruct qed_ll2_info *p_ll2_conn;\r\nstruct qed_ll2_rx_queue *p_rx;\r\nunsigned long flags;\r\nvoid *p_data;\r\nint rc = 0;\r\np_ll2_conn = qed_ll2_handle_sanity(p_hwfn, connection_handle);\r\nif (!p_ll2_conn)\r\nreturn -EINVAL;\r\np_rx = &p_ll2_conn->rx_queue;\r\nspin_lock_irqsave(&p_rx->lock, flags);\r\nif (!list_empty(&p_rx->free_descq))\r\np_curp = list_first_entry(&p_rx->free_descq,\r\nstruct qed_ll2_rx_packet, list_entry);\r\nif (p_curp) {\r\nif (qed_chain_get_elem_left(&p_rx->rxq_chain) &&\r\nqed_chain_get_elem_left(&p_rx->rcq_chain)) {\r\np_data = qed_chain_produce(&p_rx->rxq_chain);\r\np_curb = (struct core_rx_bd_with_buff_len *)p_data;\r\nqed_chain_produce(&p_rx->rcq_chain);\r\n}\r\n}\r\nif (!p_curp || !p_curb) {\r\nrc = -EBUSY;\r\np_curp = NULL;\r\ngoto out_notify;\r\n}\r\nDMA_REGPAIR_LE(p_curb->addr, addr);\r\np_curb->buff_length = cpu_to_le16(buf_len);\r\np_curp->rx_buf_addr = addr;\r\np_curp->cookie = cookie;\r\np_curp->rxq_bd = p_curb;\r\np_curp->buf_length = buf_len;\r\nlist_del(&p_curp->list_entry);\r\nif (!notify_fw) {\r\nlist_add_tail(&p_curp->list_entry, &p_rx->posting_descq);\r\ngoto out;\r\n}\r\nout_notify:\r\nqed_ll2_post_rx_buffer_notify_fw(p_hwfn, p_rx, p_curp);\r\nout:\r\nspin_unlock_irqrestore(&p_rx->lock, flags);\r\nreturn rc;\r\n}\r\nstatic void qed_ll2_prepare_tx_packet_set(struct qed_hwfn *p_hwfn,\r\nstruct qed_ll2_tx_queue *p_tx,\r\nstruct qed_ll2_tx_packet *p_curp,\r\nstruct qed_ll2_tx_pkt_info *pkt,\r\nu8 notify_fw)\r\n{\r\nlist_del(&p_curp->list_entry);\r\np_curp->cookie = pkt->cookie;\r\np_curp->bd_used = pkt->num_of_bds;\r\np_curp->notify_fw = notify_fw;\r\np_tx->cur_send_packet = p_curp;\r\np_tx->cur_send_frag_num = 0;\r\np_curp->bds_set[p_tx->cur_send_frag_num].tx_frag = pkt->first_frag;\r\np_curp->bds_set[p_tx->cur_send_frag_num].frag_len = pkt->first_frag_len;\r\np_tx->cur_send_frag_num++;\r\n}\r\nstatic void\r\nqed_ll2_prepare_tx_packet_set_bd(struct qed_hwfn *p_hwfn,\r\nstruct qed_ll2_info *p_ll2,\r\nstruct qed_ll2_tx_packet *p_curp,\r\nstruct qed_ll2_tx_pkt_info *pkt)\r\n{\r\nstruct qed_chain *p_tx_chain = &p_ll2->tx_queue.txq_chain;\r\nu16 prod_idx = qed_chain_get_prod_idx(p_tx_chain);\r\nstruct core_tx_bd *start_bd = NULL;\r\nenum core_roce_flavor_type roce_flavor;\r\nenum core_tx_dest tx_dest;\r\nu16 bd_data = 0, frag_idx;\r\nroce_flavor = (pkt->qed_roce_flavor == QED_LL2_ROCE) ? CORE_ROCE\r\n: CORE_RROCE;\r\ntx_dest = (pkt->tx_dest == QED_LL2_TX_DEST_NW) ? CORE_TX_DEST_NW\r\n: CORE_TX_DEST_LB;\r\nstart_bd = (struct core_tx_bd *)qed_chain_produce(p_tx_chain);\r\nstart_bd->nw_vlan_or_lb_echo = cpu_to_le16(pkt->vlan);\r\nSET_FIELD(start_bd->bitfield1, CORE_TX_BD_L4_HDR_OFFSET_W,\r\ncpu_to_le16(pkt->l4_hdr_offset_w));\r\nSET_FIELD(start_bd->bitfield1, CORE_TX_BD_TX_DST, tx_dest);\r\nbd_data |= pkt->bd_flags;\r\nSET_FIELD(bd_data, CORE_TX_BD_DATA_START_BD, 0x1);\r\nSET_FIELD(bd_data, CORE_TX_BD_DATA_NBDS, pkt->num_of_bds);\r\nSET_FIELD(bd_data, CORE_TX_BD_DATA_ROCE_FLAV, roce_flavor);\r\nstart_bd->bd_data.as_bitfield = cpu_to_le16(bd_data);\r\nDMA_REGPAIR_LE(start_bd->addr, pkt->first_frag);\r\nstart_bd->nbytes = cpu_to_le16(pkt->first_frag_len);\r\nDP_VERBOSE(p_hwfn,\r\n(NETIF_MSG_TX_QUEUED | QED_MSG_LL2),\r\n"LL2 [q 0x%02x cid 0x%08x type 0x%08x] Tx Producer at [0x%04x] - set with a %04x bytes %02x BDs buffer at %08x:%08x\n",\r\np_ll2->queue_id,\r\np_ll2->cid,\r\np_ll2->input.conn_type,\r\nprod_idx,\r\npkt->first_frag_len,\r\npkt->num_of_bds,\r\nle32_to_cpu(start_bd->addr.hi),\r\nle32_to_cpu(start_bd->addr.lo));\r\nif (p_ll2->tx_queue.cur_send_frag_num == pkt->num_of_bds)\r\nreturn;\r\nfor (frag_idx = p_ll2->tx_queue.cur_send_frag_num;\r\nfrag_idx < pkt->num_of_bds; frag_idx++) {\r\nstruct core_tx_bd **p_bd = &p_curp->bds_set[frag_idx].txq_bd;\r\n*p_bd = (struct core_tx_bd *)qed_chain_produce(p_tx_chain);\r\n(*p_bd)->bd_data.as_bitfield = 0;\r\n(*p_bd)->bitfield1 = 0;\r\np_curp->bds_set[frag_idx].tx_frag = 0;\r\np_curp->bds_set[frag_idx].frag_len = 0;\r\n}\r\n}\r\nstatic void qed_ll2_tx_packet_notify(struct qed_hwfn *p_hwfn,\r\nstruct qed_ll2_info *p_ll2_conn)\r\n{\r\nbool b_notify = p_ll2_conn->tx_queue.cur_send_packet->notify_fw;\r\nstruct qed_ll2_tx_queue *p_tx = &p_ll2_conn->tx_queue;\r\nstruct qed_ll2_tx_packet *p_pkt = NULL;\r\nstruct core_db_data db_msg = { 0, 0, 0 };\r\nu16 bd_prod;\r\nif (p_ll2_conn->tx_queue.cur_send_frag_num !=\r\np_ll2_conn->tx_queue.cur_send_packet->bd_used)\r\nreturn;\r\nlist_add_tail(&p_ll2_conn->tx_queue.cur_send_packet->list_entry,\r\n&p_ll2_conn->tx_queue.sending_descq);\r\np_ll2_conn->tx_queue.cur_send_packet = NULL;\r\np_ll2_conn->tx_queue.cur_send_frag_num = 0;\r\nif (!b_notify)\r\nreturn;\r\nbd_prod = qed_chain_get_prod_idx(&p_ll2_conn->tx_queue.txq_chain);\r\nwhile (!list_empty(&p_tx->sending_descq)) {\r\np_pkt = list_first_entry(&p_tx->sending_descq,\r\nstruct qed_ll2_tx_packet, list_entry);\r\nif (!p_pkt)\r\nbreak;\r\nlist_move_tail(&p_pkt->list_entry, &p_tx->active_descq);\r\n}\r\nSET_FIELD(db_msg.params, CORE_DB_DATA_DEST, DB_DEST_XCM);\r\nSET_FIELD(db_msg.params, CORE_DB_DATA_AGG_CMD, DB_AGG_CMD_SET);\r\nSET_FIELD(db_msg.params, CORE_DB_DATA_AGG_VAL_SEL,\r\nDQ_XCM_CORE_TX_BD_PROD_CMD);\r\ndb_msg.agg_flags = DQ_XCM_CORE_DQ_CF_CMD;\r\ndb_msg.spq_prod = cpu_to_le16(bd_prod);\r\nwmb();\r\nDIRECT_REG_WR(p_tx->doorbell_addr, *((u32 *)&db_msg));\r\nDP_VERBOSE(p_hwfn,\r\n(NETIF_MSG_TX_QUEUED | QED_MSG_LL2),\r\n"LL2 [q 0x%02x cid 0x%08x type 0x%08x] Doorbelled [producer 0x%04x]\n",\r\np_ll2_conn->queue_id,\r\np_ll2_conn->cid,\r\np_ll2_conn->input.conn_type, db_msg.spq_prod);\r\n}\r\nint qed_ll2_prepare_tx_packet(void *cxt,\r\nu8 connection_handle,\r\nstruct qed_ll2_tx_pkt_info *pkt,\r\nbool notify_fw)\r\n{\r\nstruct qed_hwfn *p_hwfn = cxt;\r\nstruct qed_ll2_tx_packet *p_curp = NULL;\r\nstruct qed_ll2_info *p_ll2_conn = NULL;\r\nstruct qed_ll2_tx_queue *p_tx;\r\nstruct qed_chain *p_tx_chain;\r\nunsigned long flags;\r\nint rc = 0;\r\np_ll2_conn = qed_ll2_handle_sanity(p_hwfn, connection_handle);\r\nif (!p_ll2_conn)\r\nreturn -EINVAL;\r\np_tx = &p_ll2_conn->tx_queue;\r\np_tx_chain = &p_tx->txq_chain;\r\nif (pkt->num_of_bds > CORE_LL2_TX_MAX_BDS_PER_PACKET)\r\nreturn -EIO;\r\nspin_lock_irqsave(&p_tx->lock, flags);\r\nif (p_tx->cur_send_packet) {\r\nrc = -EEXIST;\r\ngoto out;\r\n}\r\nif (!list_empty(&p_tx->free_descq))\r\np_curp = list_first_entry(&p_tx->free_descq,\r\nstruct qed_ll2_tx_packet, list_entry);\r\nif (p_curp && qed_chain_get_elem_left(p_tx_chain) < pkt->num_of_bds)\r\np_curp = NULL;\r\nif (!p_curp) {\r\nrc = -EBUSY;\r\ngoto out;\r\n}\r\nqed_ll2_prepare_tx_packet_set(p_hwfn, p_tx, p_curp, pkt, notify_fw);\r\nqed_ll2_prepare_tx_packet_set_bd(p_hwfn, p_ll2_conn, p_curp, pkt);\r\nqed_ll2_tx_packet_notify(p_hwfn, p_ll2_conn);\r\nout:\r\nspin_unlock_irqrestore(&p_tx->lock, flags);\r\nreturn rc;\r\n}\r\nint qed_ll2_set_fragment_of_tx_packet(void *cxt,\r\nu8 connection_handle,\r\ndma_addr_t addr, u16 nbytes)\r\n{\r\nstruct qed_ll2_tx_packet *p_cur_send_packet = NULL;\r\nstruct qed_hwfn *p_hwfn = cxt;\r\nstruct qed_ll2_info *p_ll2_conn = NULL;\r\nu16 cur_send_frag_num = 0;\r\nstruct core_tx_bd *p_bd;\r\nunsigned long flags;\r\np_ll2_conn = qed_ll2_handle_sanity(p_hwfn, connection_handle);\r\nif (!p_ll2_conn)\r\nreturn -EINVAL;\r\nif (!p_ll2_conn->tx_queue.cur_send_packet)\r\nreturn -EINVAL;\r\np_cur_send_packet = p_ll2_conn->tx_queue.cur_send_packet;\r\ncur_send_frag_num = p_ll2_conn->tx_queue.cur_send_frag_num;\r\nif (cur_send_frag_num >= p_cur_send_packet->bd_used)\r\nreturn -EINVAL;\r\np_bd = p_cur_send_packet->bds_set[cur_send_frag_num].txq_bd;\r\nDMA_REGPAIR_LE(p_bd->addr, addr);\r\np_bd->nbytes = cpu_to_le16(nbytes);\r\np_cur_send_packet->bds_set[cur_send_frag_num].tx_frag = addr;\r\np_cur_send_packet->bds_set[cur_send_frag_num].frag_len = nbytes;\r\np_ll2_conn->tx_queue.cur_send_frag_num++;\r\nspin_lock_irqsave(&p_ll2_conn->tx_queue.lock, flags);\r\nqed_ll2_tx_packet_notify(p_hwfn, p_ll2_conn);\r\nspin_unlock_irqrestore(&p_ll2_conn->tx_queue.lock, flags);\r\nreturn 0;\r\n}\r\nint qed_ll2_terminate_connection(void *cxt, u8 connection_handle)\r\n{\r\nstruct qed_hwfn *p_hwfn = cxt;\r\nstruct qed_ll2_info *p_ll2_conn = NULL;\r\nint rc = -EINVAL;\r\nstruct qed_ptt *p_ptt;\r\np_ptt = qed_ptt_acquire(p_hwfn);\r\nif (!p_ptt)\r\nreturn -EAGAIN;\r\np_ll2_conn = qed_ll2_handle_sanity_lock(p_hwfn, connection_handle);\r\nif (!p_ll2_conn) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nif (QED_LL2_TX_REGISTERED(p_ll2_conn)) {\r\nrc = qed_sp_ll2_tx_queue_stop(p_hwfn, p_ll2_conn);\r\nif (rc)\r\ngoto out;\r\nqed_ll2_txq_flush(p_hwfn, connection_handle);\r\n}\r\nif (QED_LL2_RX_REGISTERED(p_ll2_conn)) {\r\nrc = qed_sp_ll2_rx_queue_stop(p_hwfn, p_ll2_conn);\r\nif (rc)\r\ngoto out;\r\nqed_ll2_rxq_flush(p_hwfn, connection_handle);\r\n}\r\nif (p_ll2_conn->input.conn_type == QED_LL2_TYPE_OOO)\r\nqed_ooo_release_all_isles(p_hwfn, p_hwfn->p_ooo_info);\r\nif (p_ll2_conn->input.conn_type == QED_LL2_TYPE_FCOE) {\r\nqed_llh_remove_protocol_filter(p_hwfn, p_ptt,\r\n0x8906, 0,\r\nQED_LLH_FILTER_ETHERTYPE);\r\nqed_llh_remove_protocol_filter(p_hwfn, p_ptt,\r\n0x8914, 0,\r\nQED_LLH_FILTER_ETHERTYPE);\r\n}\r\nout:\r\nqed_ptt_release(p_hwfn, p_ptt);\r\nreturn rc;\r\n}\r\nstatic void qed_ll2_release_connection_ooo(struct qed_hwfn *p_hwfn,\r\nstruct qed_ll2_info *p_ll2_conn)\r\n{\r\nstruct qed_ooo_buffer *p_buffer;\r\nif (p_ll2_conn->input.conn_type != QED_LL2_TYPE_OOO)\r\nreturn;\r\nqed_ooo_release_all_isles(p_hwfn, p_hwfn->p_ooo_info);\r\nwhile ((p_buffer = qed_ooo_get_free_buffer(p_hwfn,\r\np_hwfn->p_ooo_info))) {\r\ndma_free_coherent(&p_hwfn->cdev->pdev->dev,\r\np_buffer->rx_buffer_size,\r\np_buffer->rx_buffer_virt_addr,\r\np_buffer->rx_buffer_phys_addr);\r\nkfree(p_buffer);\r\n}\r\n}\r\nvoid qed_ll2_release_connection(void *cxt, u8 connection_handle)\r\n{\r\nstruct qed_hwfn *p_hwfn = cxt;\r\nstruct qed_ll2_info *p_ll2_conn = NULL;\r\np_ll2_conn = qed_ll2_handle_sanity(p_hwfn, connection_handle);\r\nif (!p_ll2_conn)\r\nreturn;\r\nif (QED_LL2_RX_REGISTERED(p_ll2_conn)) {\r\np_ll2_conn->rx_queue.b_cb_registred = false;\r\nqed_int_unregister_cb(p_hwfn, p_ll2_conn->rx_queue.rx_sb_index);\r\n}\r\nif (QED_LL2_TX_REGISTERED(p_ll2_conn)) {\r\np_ll2_conn->tx_queue.b_cb_registred = false;\r\nqed_int_unregister_cb(p_hwfn, p_ll2_conn->tx_queue.tx_sb_index);\r\n}\r\nkfree(p_ll2_conn->tx_queue.descq_array);\r\nqed_chain_free(p_hwfn->cdev, &p_ll2_conn->tx_queue.txq_chain);\r\nkfree(p_ll2_conn->rx_queue.descq_array);\r\nqed_chain_free(p_hwfn->cdev, &p_ll2_conn->rx_queue.rxq_chain);\r\nqed_chain_free(p_hwfn->cdev, &p_ll2_conn->rx_queue.rcq_chain);\r\nqed_cxt_release_cid(p_hwfn, p_ll2_conn->cid);\r\nqed_ll2_release_connection_ooo(p_hwfn, p_ll2_conn);\r\nmutex_lock(&p_ll2_conn->mutex);\r\np_ll2_conn->b_active = false;\r\nmutex_unlock(&p_ll2_conn->mutex);\r\n}\r\nint qed_ll2_alloc(struct qed_hwfn *p_hwfn)\r\n{\r\nstruct qed_ll2_info *p_ll2_connections;\r\nu8 i;\r\np_ll2_connections = kcalloc(QED_MAX_NUM_OF_LL2_CONNECTIONS,\r\nsizeof(struct qed_ll2_info), GFP_KERNEL);\r\nif (!p_ll2_connections) {\r\nDP_NOTICE(p_hwfn, "Failed to allocate `struct qed_ll2'\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < QED_MAX_NUM_OF_LL2_CONNECTIONS; i++)\r\np_ll2_connections[i].my_id = i;\r\np_hwfn->p_ll2_info = p_ll2_connections;\r\nreturn 0;\r\n}\r\nvoid qed_ll2_setup(struct qed_hwfn *p_hwfn)\r\n{\r\nint i;\r\nfor (i = 0; i < QED_MAX_NUM_OF_LL2_CONNECTIONS; i++)\r\nmutex_init(&p_hwfn->p_ll2_info[i].mutex);\r\n}\r\nvoid qed_ll2_free(struct qed_hwfn *p_hwfn)\r\n{\r\nif (!p_hwfn->p_ll2_info)\r\nreturn;\r\nkfree(p_hwfn->p_ll2_info);\r\np_hwfn->p_ll2_info = NULL;\r\n}\r\nstatic void _qed_ll2_get_port_stats(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nstruct qed_ll2_stats *p_stats)\r\n{\r\nstruct core_ll2_port_stats port_stats;\r\nmemset(&port_stats, 0, sizeof(port_stats));\r\nqed_memcpy_from(p_hwfn, p_ptt, &port_stats,\r\nBAR0_MAP_REG_TSDM_RAM +\r\nTSTORM_LL2_PORT_STAT_OFFSET(MFW_PORT(p_hwfn)),\r\nsizeof(port_stats));\r\np_stats->gsi_invalid_hdr = HILO_64_REGPAIR(port_stats.gsi_invalid_hdr);\r\np_stats->gsi_invalid_pkt_length =\r\nHILO_64_REGPAIR(port_stats.gsi_invalid_pkt_length);\r\np_stats->gsi_unsupported_pkt_typ =\r\nHILO_64_REGPAIR(port_stats.gsi_unsupported_pkt_typ);\r\np_stats->gsi_crcchksm_error =\r\nHILO_64_REGPAIR(port_stats.gsi_crcchksm_error);\r\n}\r\nstatic void _qed_ll2_get_tstats(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nstruct qed_ll2_info *p_ll2_conn,\r\nstruct qed_ll2_stats *p_stats)\r\n{\r\nstruct core_ll2_tstorm_per_queue_stat tstats;\r\nu8 qid = p_ll2_conn->queue_id;\r\nu32 tstats_addr;\r\nmemset(&tstats, 0, sizeof(tstats));\r\ntstats_addr = BAR0_MAP_REG_TSDM_RAM +\r\nCORE_LL2_TSTORM_PER_QUEUE_STAT_OFFSET(qid);\r\nqed_memcpy_from(p_hwfn, p_ptt, &tstats, tstats_addr, sizeof(tstats));\r\np_stats->packet_too_big_discard =\r\nHILO_64_REGPAIR(tstats.packet_too_big_discard);\r\np_stats->no_buff_discard = HILO_64_REGPAIR(tstats.no_buff_discard);\r\n}\r\nstatic void _qed_ll2_get_ustats(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nstruct qed_ll2_info *p_ll2_conn,\r\nstruct qed_ll2_stats *p_stats)\r\n{\r\nstruct core_ll2_ustorm_per_queue_stat ustats;\r\nu8 qid = p_ll2_conn->queue_id;\r\nu32 ustats_addr;\r\nmemset(&ustats, 0, sizeof(ustats));\r\nustats_addr = BAR0_MAP_REG_USDM_RAM +\r\nCORE_LL2_USTORM_PER_QUEUE_STAT_OFFSET(qid);\r\nqed_memcpy_from(p_hwfn, p_ptt, &ustats, ustats_addr, sizeof(ustats));\r\np_stats->rcv_ucast_bytes = HILO_64_REGPAIR(ustats.rcv_ucast_bytes);\r\np_stats->rcv_mcast_bytes = HILO_64_REGPAIR(ustats.rcv_mcast_bytes);\r\np_stats->rcv_bcast_bytes = HILO_64_REGPAIR(ustats.rcv_bcast_bytes);\r\np_stats->rcv_ucast_pkts = HILO_64_REGPAIR(ustats.rcv_ucast_pkts);\r\np_stats->rcv_mcast_pkts = HILO_64_REGPAIR(ustats.rcv_mcast_pkts);\r\np_stats->rcv_bcast_pkts = HILO_64_REGPAIR(ustats.rcv_bcast_pkts);\r\n}\r\nstatic void _qed_ll2_get_pstats(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nstruct qed_ll2_info *p_ll2_conn,\r\nstruct qed_ll2_stats *p_stats)\r\n{\r\nstruct core_ll2_pstorm_per_queue_stat pstats;\r\nu8 stats_id = p_ll2_conn->tx_stats_id;\r\nu32 pstats_addr;\r\nmemset(&pstats, 0, sizeof(pstats));\r\npstats_addr = BAR0_MAP_REG_PSDM_RAM +\r\nCORE_LL2_PSTORM_PER_QUEUE_STAT_OFFSET(stats_id);\r\nqed_memcpy_from(p_hwfn, p_ptt, &pstats, pstats_addr, sizeof(pstats));\r\np_stats->sent_ucast_bytes = HILO_64_REGPAIR(pstats.sent_ucast_bytes);\r\np_stats->sent_mcast_bytes = HILO_64_REGPAIR(pstats.sent_mcast_bytes);\r\np_stats->sent_bcast_bytes = HILO_64_REGPAIR(pstats.sent_bcast_bytes);\r\np_stats->sent_ucast_pkts = HILO_64_REGPAIR(pstats.sent_ucast_pkts);\r\np_stats->sent_mcast_pkts = HILO_64_REGPAIR(pstats.sent_mcast_pkts);\r\np_stats->sent_bcast_pkts = HILO_64_REGPAIR(pstats.sent_bcast_pkts);\r\n}\r\nint qed_ll2_get_stats(void *cxt,\r\nu8 connection_handle, struct qed_ll2_stats *p_stats)\r\n{\r\nstruct qed_hwfn *p_hwfn = cxt;\r\nstruct qed_ll2_info *p_ll2_conn = NULL;\r\nstruct qed_ptt *p_ptt;\r\nmemset(p_stats, 0, sizeof(*p_stats));\r\nif ((connection_handle >= QED_MAX_NUM_OF_LL2_CONNECTIONS) ||\r\n!p_hwfn->p_ll2_info)\r\nreturn -EINVAL;\r\np_ll2_conn = &p_hwfn->p_ll2_info[connection_handle];\r\np_ptt = qed_ptt_acquire(p_hwfn);\r\nif (!p_ptt) {\r\nDP_ERR(p_hwfn, "Failed to acquire ptt\n");\r\nreturn -EINVAL;\r\n}\r\nif (p_ll2_conn->input.gsi_enable)\r\n_qed_ll2_get_port_stats(p_hwfn, p_ptt, p_stats);\r\n_qed_ll2_get_tstats(p_hwfn, p_ptt, p_ll2_conn, p_stats);\r\n_qed_ll2_get_ustats(p_hwfn, p_ptt, p_ll2_conn, p_stats);\r\nif (p_ll2_conn->tx_stats_en)\r\n_qed_ll2_get_pstats(p_hwfn, p_ptt, p_ll2_conn, p_stats);\r\nqed_ptt_release(p_hwfn, p_ptt);\r\nreturn 0;\r\n}\r\nstatic void qed_ll2b_release_rx_packet(void *cxt,\r\nu8 connection_handle,\r\nvoid *cookie,\r\ndma_addr_t rx_buf_addr,\r\nbool b_last_packet)\r\n{\r\nstruct qed_hwfn *p_hwfn = cxt;\r\nqed_ll2_dealloc_buffer(p_hwfn->cdev, cookie);\r\n}\r\nstatic void qed_ll2_register_cb_ops(struct qed_dev *cdev,\r\nconst struct qed_ll2_cb_ops *ops,\r\nvoid *cookie)\r\n{\r\ncdev->ll2->cbs = ops;\r\ncdev->ll2->cb_cookie = cookie;\r\n}\r\nstatic void qed_ll2_set_conn_data(struct qed_dev *cdev,\r\nstruct qed_ll2_acquire_data *data,\r\nstruct qed_ll2_params *params,\r\nenum qed_ll2_conn_type conn_type,\r\nu8 *handle, bool lb)\r\n{\r\nmemset(data, 0, sizeof(*data));\r\ndata->input.conn_type = conn_type;\r\ndata->input.mtu = params->mtu;\r\ndata->input.rx_num_desc = QED_LL2_RX_SIZE;\r\ndata->input.rx_drop_ttl0_flg = params->drop_ttl0_packets;\r\ndata->input.rx_vlan_removal_en = params->rx_vlan_stripping;\r\ndata->input.tx_num_desc = QED_LL2_TX_SIZE;\r\ndata->p_connection_handle = handle;\r\ndata->cbs = &ll2_cbs;\r\nll2_cbs.cookie = QED_LEADING_HWFN(cdev);\r\nif (lb) {\r\ndata->input.tx_tc = PKT_LB_TC;\r\ndata->input.tx_dest = QED_LL2_TX_DEST_LB;\r\n} else {\r\ndata->input.tx_tc = 0;\r\ndata->input.tx_dest = QED_LL2_TX_DEST_NW;\r\n}\r\n}\r\nstatic int qed_ll2_start_ooo(struct qed_dev *cdev,\r\nstruct qed_ll2_params *params)\r\n{\r\nstruct qed_hwfn *hwfn = QED_LEADING_HWFN(cdev);\r\nu8 *handle = &hwfn->pf_params.iscsi_pf_params.ll2_ooo_queue_id;\r\nstruct qed_ll2_acquire_data data;\r\nint rc;\r\nqed_ll2_set_conn_data(cdev, &data, params,\r\nQED_LL2_TYPE_OOO, handle, true);\r\nrc = qed_ll2_acquire_connection(hwfn, &data);\r\nif (rc) {\r\nDP_INFO(cdev, "Failed to acquire LL2 OOO connection\n");\r\ngoto out;\r\n}\r\nrc = qed_ll2_establish_connection(hwfn, *handle);\r\nif (rc) {\r\nDP_INFO(cdev, "Failed to establist LL2 OOO connection\n");\r\ngoto fail;\r\n}\r\nreturn 0;\r\nfail:\r\nqed_ll2_release_connection(hwfn, *handle);\r\nout:\r\n*handle = QED_LL2_UNUSED_HANDLE;\r\nreturn rc;\r\n}\r\nstatic int qed_ll2_start(struct qed_dev *cdev, struct qed_ll2_params *params)\r\n{\r\nstruct qed_ll2_buffer *buffer, *tmp_buffer;\r\nenum qed_ll2_conn_type conn_type;\r\nstruct qed_ll2_acquire_data data;\r\nstruct qed_ptt *p_ptt;\r\nint rc, i;\r\nINIT_LIST_HEAD(&cdev->ll2->list);\r\nspin_lock_init(&cdev->ll2->lock);\r\ncdev->ll2->rx_size = NET_SKB_PAD + ETH_HLEN +\r\nL1_CACHE_BYTES + params->mtu;\r\nDP_INFO(cdev, "Allocating LL2 buffers of size %08x bytes\n",\r\ncdev->ll2->rx_size);\r\nfor (i = 0; i < QED_LL2_RX_SIZE; i++) {\r\nbuffer = kzalloc(sizeof(*buffer), GFP_KERNEL);\r\nif (!buffer) {\r\nDP_INFO(cdev, "Failed to allocate LL2 buffers\n");\r\ngoto fail;\r\n}\r\nrc = qed_ll2_alloc_buffer(cdev, (u8 **)&buffer->data,\r\n&buffer->phys_addr);\r\nif (rc) {\r\nkfree(buffer);\r\ngoto fail;\r\n}\r\nlist_add_tail(&buffer->list, &cdev->ll2->list);\r\n}\r\nswitch (QED_LEADING_HWFN(cdev)->hw_info.personality) {\r\ncase QED_PCI_FCOE:\r\nconn_type = QED_LL2_TYPE_FCOE;\r\nbreak;\r\ncase QED_PCI_ISCSI:\r\nconn_type = QED_LL2_TYPE_ISCSI;\r\nbreak;\r\ncase QED_PCI_ETH_ROCE:\r\nconn_type = QED_LL2_TYPE_ROCE;\r\nbreak;\r\ndefault:\r\nconn_type = QED_LL2_TYPE_TEST;\r\n}\r\nqed_ll2_set_conn_data(cdev, &data, params, conn_type,\r\n&cdev->ll2->handle, false);\r\nrc = qed_ll2_acquire_connection(QED_LEADING_HWFN(cdev), &data);\r\nif (rc) {\r\nDP_INFO(cdev, "Failed to acquire LL2 connection\n");\r\ngoto fail;\r\n}\r\nrc = qed_ll2_establish_connection(QED_LEADING_HWFN(cdev),\r\ncdev->ll2->handle);\r\nif (rc) {\r\nDP_INFO(cdev, "Failed to establish LL2 connection\n");\r\ngoto release_fail;\r\n}\r\nspin_lock_bh(&cdev->ll2->lock);\r\nlist_for_each_entry_safe(buffer, tmp_buffer, &cdev->ll2->list, list) {\r\nrc = qed_ll2_post_rx_buffer(QED_LEADING_HWFN(cdev),\r\ncdev->ll2->handle,\r\nbuffer->phys_addr, 0, buffer, 1);\r\nif (rc) {\r\nDP_INFO(cdev,\r\n"Failed to post an Rx buffer; Deleting it\n");\r\ndma_unmap_single(&cdev->pdev->dev, buffer->phys_addr,\r\ncdev->ll2->rx_size, DMA_FROM_DEVICE);\r\nkfree(buffer->data);\r\nlist_del(&buffer->list);\r\nkfree(buffer);\r\n} else {\r\ncdev->ll2->rx_cnt++;\r\n}\r\n}\r\nspin_unlock_bh(&cdev->ll2->lock);\r\nif (!cdev->ll2->rx_cnt) {\r\nDP_INFO(cdev, "Failed passing even a single Rx buffer\n");\r\ngoto release_terminate;\r\n}\r\nif (!is_valid_ether_addr(params->ll2_mac_address)) {\r\nDP_INFO(cdev, "Invalid Ethernet address\n");\r\ngoto release_terminate;\r\n}\r\nif (cdev->hwfns[0].hw_info.personality == QED_PCI_ISCSI &&\r\ncdev->hwfns[0].pf_params.iscsi_pf_params.ooo_enable) {\r\nDP_VERBOSE(cdev, QED_MSG_STORAGE, "Starting OOO LL2 queue\n");\r\nrc = qed_ll2_start_ooo(cdev, params);\r\nif (rc) {\r\nDP_INFO(cdev,\r\n"Failed to initialize the OOO LL2 queue\n");\r\ngoto release_terminate;\r\n}\r\n}\r\np_ptt = qed_ptt_acquire(QED_LEADING_HWFN(cdev));\r\nif (!p_ptt) {\r\nDP_INFO(cdev, "Failed to acquire PTT\n");\r\ngoto release_terminate;\r\n}\r\nrc = qed_llh_add_mac_filter(QED_LEADING_HWFN(cdev), p_ptt,\r\nparams->ll2_mac_address);\r\nqed_ptt_release(QED_LEADING_HWFN(cdev), p_ptt);\r\nif (rc) {\r\nDP_ERR(cdev, "Failed to allocate LLH filter\n");\r\ngoto release_terminate_all;\r\n}\r\nether_addr_copy(cdev->ll2_mac_address, params->ll2_mac_address);\r\nreturn 0;\r\nrelease_terminate_all:\r\nrelease_terminate:\r\nqed_ll2_terminate_connection(QED_LEADING_HWFN(cdev), cdev->ll2->handle);\r\nrelease_fail:\r\nqed_ll2_release_connection(QED_LEADING_HWFN(cdev), cdev->ll2->handle);\r\nfail:\r\nqed_ll2_kill_buffers(cdev);\r\ncdev->ll2->handle = QED_LL2_UNUSED_HANDLE;\r\nreturn -EINVAL;\r\n}\r\nstatic int qed_ll2_stop(struct qed_dev *cdev)\r\n{\r\nstruct qed_ptt *p_ptt;\r\nint rc;\r\nif (cdev->ll2->handle == QED_LL2_UNUSED_HANDLE)\r\nreturn 0;\r\np_ptt = qed_ptt_acquire(QED_LEADING_HWFN(cdev));\r\nif (!p_ptt) {\r\nDP_INFO(cdev, "Failed to acquire PTT\n");\r\ngoto fail;\r\n}\r\nqed_llh_remove_mac_filter(QED_LEADING_HWFN(cdev), p_ptt,\r\ncdev->ll2_mac_address);\r\nqed_ptt_release(QED_LEADING_HWFN(cdev), p_ptt);\r\neth_zero_addr(cdev->ll2_mac_address);\r\nif (cdev->hwfns[0].hw_info.personality == QED_PCI_ISCSI &&\r\ncdev->hwfns[0].pf_params.iscsi_pf_params.ooo_enable)\r\nqed_ll2_stop_ooo(cdev);\r\nrc = qed_ll2_terminate_connection(QED_LEADING_HWFN(cdev),\r\ncdev->ll2->handle);\r\nif (rc)\r\nDP_INFO(cdev, "Failed to terminate LL2 connection\n");\r\nqed_ll2_kill_buffers(cdev);\r\nqed_ll2_release_connection(QED_LEADING_HWFN(cdev), cdev->ll2->handle);\r\ncdev->ll2->handle = QED_LL2_UNUSED_HANDLE;\r\nreturn rc;\r\nfail:\r\nreturn -EINVAL;\r\n}\r\nstatic int qed_ll2_start_xmit(struct qed_dev *cdev, struct sk_buff *skb)\r\n{\r\nstruct qed_ll2_tx_pkt_info pkt;\r\nconst skb_frag_t *frag;\r\nint rc = -EINVAL, i;\r\ndma_addr_t mapping;\r\nu16 vlan = 0;\r\nu8 flags = 0;\r\nif (unlikely(skb->ip_summed != CHECKSUM_NONE)) {\r\nDP_INFO(cdev, "Cannot transmit a checksumed packet\n");\r\nreturn -EINVAL;\r\n}\r\nif (1 + skb_shinfo(skb)->nr_frags > CORE_LL2_TX_MAX_BDS_PER_PACKET) {\r\nDP_ERR(cdev, "Cannot transmit a packet with %d fragments\n",\r\n1 + skb_shinfo(skb)->nr_frags);\r\nreturn -EINVAL;\r\n}\r\nmapping = dma_map_single(&cdev->pdev->dev, skb->data,\r\nskb->len, DMA_TO_DEVICE);\r\nif (unlikely(dma_mapping_error(&cdev->pdev->dev, mapping))) {\r\nDP_NOTICE(cdev, "SKB mapping failed\n");\r\nreturn -EINVAL;\r\n}\r\nif (!((vlan_get_protocol(skb) == htons(ETH_P_IPV6)) &&\r\nipv6_hdr(skb)->nexthdr == NEXTHDR_IPV6))\r\nflags |= BIT(CORE_TX_BD_DATA_IP_CSUM_SHIFT);\r\nif (skb_vlan_tag_present(skb)) {\r\nvlan = skb_vlan_tag_get(skb);\r\nflags |= BIT(CORE_TX_BD_DATA_VLAN_INSERTION_SHIFT);\r\n}\r\nmemset(&pkt, 0, sizeof(pkt));\r\npkt.num_of_bds = 1 + skb_shinfo(skb)->nr_frags;\r\npkt.vlan = vlan;\r\npkt.bd_flags = flags;\r\npkt.tx_dest = QED_LL2_TX_DEST_NW;\r\npkt.first_frag = mapping;\r\npkt.first_frag_len = skb->len;\r\npkt.cookie = skb;\r\nrc = qed_ll2_prepare_tx_packet(&cdev->hwfns[0], cdev->ll2->handle,\r\n&pkt, 1);\r\nif (rc)\r\ngoto err;\r\nfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\r\nfrag = &skb_shinfo(skb)->frags[i];\r\nmapping = skb_frag_dma_map(&cdev->pdev->dev, frag, 0,\r\nskb_frag_size(frag), DMA_TO_DEVICE);\r\nif (unlikely(dma_mapping_error(&cdev->pdev->dev, mapping))) {\r\nDP_NOTICE(cdev,\r\n"Unable to map frag - dropping packet\n");\r\ngoto err;\r\n}\r\nrc = qed_ll2_set_fragment_of_tx_packet(QED_LEADING_HWFN(cdev),\r\ncdev->ll2->handle,\r\nmapping,\r\nskb_frag_size(frag));\r\nif (rc)\r\ngoto err2;\r\n}\r\nreturn 0;\r\nerr:\r\ndma_unmap_single(&cdev->pdev->dev, mapping, skb->len, DMA_TO_DEVICE);\r\nerr2:\r\nreturn rc;\r\n}\r\nstatic int qed_ll2_stats(struct qed_dev *cdev, struct qed_ll2_stats *stats)\r\n{\r\nif (!cdev->ll2)\r\nreturn -EINVAL;\r\nreturn qed_ll2_get_stats(QED_LEADING_HWFN(cdev),\r\ncdev->ll2->handle, stats);\r\n}\r\nint qed_ll2_alloc_if(struct qed_dev *cdev)\r\n{\r\ncdev->ll2 = kzalloc(sizeof(*cdev->ll2), GFP_KERNEL);\r\nreturn cdev->ll2 ? 0 : -ENOMEM;\r\n}\r\nvoid qed_ll2_dealloc_if(struct qed_dev *cdev)\r\n{\r\nkfree(cdev->ll2);\r\ncdev->ll2 = NULL;\r\n}
