static inline void snd_opl4_wait(struct snd_opl4 *opl4)\r\n{\r\nint timeout = 10;\r\nwhile ((inb(opl4->fm_port) & OPL4_STATUS_BUSY) && --timeout > 0)\r\n;\r\n}\r\nvoid snd_opl4_write(struct snd_opl4 *opl4, u8 reg, u8 value)\r\n{\r\nsnd_opl4_wait(opl4);\r\noutb(reg, opl4->pcm_port);\r\nsnd_opl4_wait(opl4);\r\noutb(value, opl4->pcm_port + 1);\r\n}\r\nu8 snd_opl4_read(struct snd_opl4 *opl4, u8 reg)\r\n{\r\nsnd_opl4_wait(opl4);\r\noutb(reg, opl4->pcm_port);\r\nsnd_opl4_wait(opl4);\r\nreturn inb(opl4->pcm_port + 1);\r\n}\r\nvoid snd_opl4_read_memory(struct snd_opl4 *opl4, char *buf, int offset, int size)\r\n{\r\nunsigned long flags;\r\nu8 memcfg;\r\nspin_lock_irqsave(&opl4->reg_lock, flags);\r\nmemcfg = snd_opl4_read(opl4, OPL4_REG_MEMORY_CONFIGURATION);\r\nsnd_opl4_write(opl4, OPL4_REG_MEMORY_CONFIGURATION, memcfg | OPL4_MODE_BIT);\r\nsnd_opl4_write(opl4, OPL4_REG_MEMORY_ADDRESS_HIGH, offset >> 16);\r\nsnd_opl4_write(opl4, OPL4_REG_MEMORY_ADDRESS_MID, offset >> 8);\r\nsnd_opl4_write(opl4, OPL4_REG_MEMORY_ADDRESS_LOW, offset);\r\nsnd_opl4_wait(opl4);\r\noutb(OPL4_REG_MEMORY_DATA, opl4->pcm_port);\r\nsnd_opl4_wait(opl4);\r\ninsb(opl4->pcm_port + 1, buf, size);\r\nsnd_opl4_write(opl4, OPL4_REG_MEMORY_CONFIGURATION, memcfg);\r\nspin_unlock_irqrestore(&opl4->reg_lock, flags);\r\n}\r\nvoid snd_opl4_write_memory(struct snd_opl4 *opl4, const char *buf, int offset, int size)\r\n{\r\nunsigned long flags;\r\nu8 memcfg;\r\nspin_lock_irqsave(&opl4->reg_lock, flags);\r\nmemcfg = snd_opl4_read(opl4, OPL4_REG_MEMORY_CONFIGURATION);\r\nsnd_opl4_write(opl4, OPL4_REG_MEMORY_CONFIGURATION, memcfg | OPL4_MODE_BIT);\r\nsnd_opl4_write(opl4, OPL4_REG_MEMORY_ADDRESS_HIGH, offset >> 16);\r\nsnd_opl4_write(opl4, OPL4_REG_MEMORY_ADDRESS_MID, offset >> 8);\r\nsnd_opl4_write(opl4, OPL4_REG_MEMORY_ADDRESS_LOW, offset);\r\nsnd_opl4_wait(opl4);\r\noutb(OPL4_REG_MEMORY_DATA, opl4->pcm_port);\r\nsnd_opl4_wait(opl4);\r\noutsb(opl4->pcm_port + 1, buf, size);\r\nsnd_opl4_write(opl4, OPL4_REG_MEMORY_CONFIGURATION, memcfg);\r\nspin_unlock_irqrestore(&opl4->reg_lock, flags);\r\n}\r\nstatic void snd_opl4_enable_opl4(struct snd_opl4 *opl4)\r\n{\r\noutb(OPL3_REG_MODE, opl4->fm_port + 2);\r\ninb(opl4->fm_port);\r\ninb(opl4->fm_port);\r\noutb(OPL3_OPL3_ENABLE | OPL3_OPL4_ENABLE, opl4->fm_port + 3);\r\ninb(opl4->fm_port);\r\ninb(opl4->fm_port);\r\n}\r\nstatic int snd_opl4_detect(struct snd_opl4 *opl4)\r\n{\r\nu8 id1, id2;\r\nsnd_opl4_enable_opl4(opl4);\r\nid1 = snd_opl4_read(opl4, OPL4_REG_MEMORY_CONFIGURATION);\r\nsnd_printdd("OPL4[02]=%02x\n", id1);\r\nswitch (id1 & OPL4_DEVICE_ID_MASK) {\r\ncase 0x20:\r\nopl4->hardware = OPL3_HW_OPL4;\r\nbreak;\r\ncase 0x40:\r\nopl4->hardware = OPL3_HW_OPL4_ML;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nsnd_opl4_write(opl4, OPL4_REG_MIX_CONTROL_FM, 0x00);\r\nsnd_opl4_write(opl4, OPL4_REG_MIX_CONTROL_PCM, 0xff);\r\nid1 = snd_opl4_read(opl4, OPL4_REG_MIX_CONTROL_FM);\r\nid2 = snd_opl4_read(opl4, OPL4_REG_MIX_CONTROL_PCM);\r\nsnd_printdd("OPL4 id1=%02x id2=%02x\n", id1, id2);\r\nif (id1 != 0x00 || id2 != 0xff)\r\nreturn -ENODEV;\r\nsnd_opl4_write(opl4, OPL4_REG_MIX_CONTROL_FM, 0x3f);\r\nsnd_opl4_write(opl4, OPL4_REG_MIX_CONTROL_PCM, 0x3f);\r\nsnd_opl4_write(opl4, OPL4_REG_MEMORY_CONFIGURATION, 0x00);\r\nreturn 0;\r\n}\r\nstatic void snd_opl4_seq_dev_free(struct snd_seq_device *seq_dev)\r\n{\r\nstruct snd_opl4 *opl4 = seq_dev->private_data;\r\nopl4->seq_dev = NULL;\r\n}\r\nstatic int snd_opl4_create_seq_dev(struct snd_opl4 *opl4, int seq_device)\r\n{\r\nopl4->seq_dev_num = seq_device;\r\nif (snd_seq_device_new(opl4->card, seq_device, SNDRV_SEQ_DEV_ID_OPL4,\r\nsizeof(struct snd_opl4 *), &opl4->seq_dev) >= 0) {\r\nstrcpy(opl4->seq_dev->name, "OPL4 Wavetable");\r\n*(struct snd_opl4 **)SNDRV_SEQ_DEVICE_ARGPTR(opl4->seq_dev) = opl4;\r\nopl4->seq_dev->private_data = opl4;\r\nopl4->seq_dev->private_free = snd_opl4_seq_dev_free;\r\n}\r\nreturn 0;\r\n}\r\nstatic void snd_opl4_free(struct snd_opl4 *opl4)\r\n{\r\nsnd_opl4_free_proc(opl4);\r\nrelease_and_free_resource(opl4->res_fm_port);\r\nrelease_and_free_resource(opl4->res_pcm_port);\r\nkfree(opl4);\r\n}\r\nstatic int snd_opl4_dev_free(struct snd_device *device)\r\n{\r\nstruct snd_opl4 *opl4 = device->device_data;\r\nsnd_opl4_free(opl4);\r\nreturn 0;\r\n}\r\nint snd_opl4_create(struct snd_card *card,\r\nunsigned long fm_port, unsigned long pcm_port,\r\nint seq_device,\r\nstruct snd_opl3 **ropl3, struct snd_opl4 **ropl4)\r\n{\r\nstruct snd_opl4 *opl4;\r\nstruct snd_opl3 *opl3;\r\nint err;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_opl4_dev_free\r\n};\r\nif (ropl3)\r\n*ropl3 = NULL;\r\nif (ropl4)\r\n*ropl4 = NULL;\r\nopl4 = kzalloc(sizeof(*opl4), GFP_KERNEL);\r\nif (!opl4)\r\nreturn -ENOMEM;\r\nopl4->res_fm_port = request_region(fm_port, 8, "OPL4 FM");\r\nopl4->res_pcm_port = request_region(pcm_port, 8, "OPL4 PCM/MIX");\r\nif (!opl4->res_fm_port || !opl4->res_pcm_port) {\r\nsnd_printk(KERN_ERR "opl4: can't grab ports 0x%lx, 0x%lx\n", fm_port, pcm_port);\r\nsnd_opl4_free(opl4);\r\nreturn -EBUSY;\r\n}\r\nopl4->card = card;\r\nopl4->fm_port = fm_port;\r\nopl4->pcm_port = pcm_port;\r\nspin_lock_init(&opl4->reg_lock);\r\nmutex_init(&opl4->access_mutex);\r\nerr = snd_opl4_detect(opl4);\r\nif (err < 0) {\r\nsnd_opl4_free(opl4);\r\nsnd_printd("OPL4 chip not detected at %#lx/%#lx\n", fm_port, pcm_port);\r\nreturn err;\r\n}\r\nerr = snd_device_new(card, SNDRV_DEV_CODEC, opl4, &ops);\r\nif (err < 0) {\r\nsnd_opl4_free(opl4);\r\nreturn err;\r\n}\r\nerr = snd_opl3_create(card, fm_port, fm_port + 2, opl4->hardware, 1, &opl3);\r\nif (err < 0) {\r\nsnd_device_free(card, opl4);\r\nreturn err;\r\n}\r\nsnd_opl4_enable_opl4(opl4);\r\nsnd_opl4_create_mixer(opl4);\r\nsnd_opl4_create_proc(opl4);\r\n#if IS_ENABLED(CONFIG_SND_SEQUENCER)\r\nopl4->seq_client = -1;\r\nif (opl4->hardware < OPL3_HW_OPL4_ML)\r\nsnd_opl4_create_seq_dev(opl4, seq_device);\r\n#endif\r\nif (ropl3)\r\n*ropl3 = opl3;\r\nif (ropl4)\r\n*ropl4 = opl4;\r\nreturn 0;\r\n}\r\nstatic int __init alsa_opl4_init(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __exit alsa_opl4_exit(void)\r\n{\r\n}
