int drm_encoder_register_all(struct drm_device *dev)\r\n{\r\nstruct drm_encoder *encoder;\r\nint ret = 0;\r\ndrm_for_each_encoder(encoder, dev) {\r\nif (encoder->funcs->late_register)\r\nret = encoder->funcs->late_register(encoder);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nvoid drm_encoder_unregister_all(struct drm_device *dev)\r\n{\r\nstruct drm_encoder *encoder;\r\ndrm_for_each_encoder(encoder, dev) {\r\nif (encoder->funcs->early_unregister)\r\nencoder->funcs->early_unregister(encoder);\r\n}\r\n}\r\nint drm_encoder_init(struct drm_device *dev,\r\nstruct drm_encoder *encoder,\r\nconst struct drm_encoder_funcs *funcs,\r\nint encoder_type, const char *name, ...)\r\n{\r\nint ret;\r\nret = drm_mode_object_add(dev, &encoder->base, DRM_MODE_OBJECT_ENCODER);\r\nif (ret)\r\nreturn ret;\r\nencoder->dev = dev;\r\nencoder->encoder_type = encoder_type;\r\nencoder->funcs = funcs;\r\nif (name) {\r\nva_list ap;\r\nva_start(ap, name);\r\nencoder->name = kvasprintf(GFP_KERNEL, name, ap);\r\nva_end(ap);\r\n} else {\r\nencoder->name = kasprintf(GFP_KERNEL, "%s-%d",\r\ndrm_encoder_enum_list[encoder_type].name,\r\nencoder->base.id);\r\n}\r\nif (!encoder->name) {\r\nret = -ENOMEM;\r\ngoto out_put;\r\n}\r\nlist_add_tail(&encoder->head, &dev->mode_config.encoder_list);\r\nencoder->index = dev->mode_config.num_encoder++;\r\nout_put:\r\nif (ret)\r\ndrm_mode_object_unregister(dev, &encoder->base);\r\nreturn ret;\r\n}\r\nvoid drm_encoder_cleanup(struct drm_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nif (encoder->bridge) {\r\nstruct drm_bridge *bridge = encoder->bridge;\r\nstruct drm_bridge *next;\r\nwhile (bridge) {\r\nnext = bridge->next;\r\ndrm_bridge_detach(bridge);\r\nbridge = next;\r\n}\r\n}\r\ndrm_mode_object_unregister(dev, &encoder->base);\r\nkfree(encoder->name);\r\nlist_del(&encoder->head);\r\ndev->mode_config.num_encoder--;\r\nmemset(encoder, 0, sizeof(*encoder));\r\n}\r\nstatic struct drm_crtc *drm_encoder_get_crtc(struct drm_encoder *encoder)\r\n{\r\nstruct drm_connector *connector;\r\nstruct drm_device *dev = encoder->dev;\r\nbool uses_atomic = false;\r\nstruct drm_connector_list_iter conn_iter;\r\ndrm_connector_list_iter_begin(dev, &conn_iter);\r\ndrm_for_each_connector_iter(connector, &conn_iter) {\r\nif (!connector->state)\r\ncontinue;\r\nuses_atomic = true;\r\nif (connector->state->best_encoder != encoder)\r\ncontinue;\r\ndrm_connector_list_iter_end(&conn_iter);\r\nreturn connector->state->crtc;\r\n}\r\ndrm_connector_list_iter_end(&conn_iter);\r\nif (uses_atomic)\r\nreturn NULL;\r\nreturn encoder->crtc;\r\n}\r\nint drm_mode_getencoder(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_mode_get_encoder *enc_resp = data;\r\nstruct drm_encoder *encoder;\r\nstruct drm_crtc *crtc;\r\nif (!drm_core_check_feature(dev, DRIVER_MODESET))\r\nreturn -EINVAL;\r\nencoder = drm_encoder_find(dev, enc_resp->encoder_id);\r\nif (!encoder)\r\nreturn -ENOENT;\r\ndrm_modeset_lock(&dev->mode_config.connection_mutex, NULL);\r\ncrtc = drm_encoder_get_crtc(encoder);\r\nif (crtc)\r\nenc_resp->crtc_id = crtc->base.id;\r\nelse\r\nenc_resp->crtc_id = 0;\r\ndrm_modeset_unlock(&dev->mode_config.connection_mutex);\r\nenc_resp->encoder_type = encoder->encoder_type;\r\nenc_resp->encoder_id = encoder->base.id;\r\nenc_resp->possible_crtcs = encoder->possible_crtcs;\r\nenc_resp->possible_clones = encoder->possible_clones;\r\nreturn 0;\r\n}
