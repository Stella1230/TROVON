static void byt_set_termios(struct uart_port *p, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nunsigned int baud = tty_termios_baud_rate(termios);\r\nstruct lpss8250 *lpss = p->private_data;\r\nunsigned long fref = lpss->board->freq, fuart = baud * 16;\r\nunsigned long w = BIT(15) - 1;\r\nunsigned long m, n;\r\nu32 reg;\r\nfuart = fuart ? fuart : 9600 * 16;\r\nfuart *= rounddown_pow_of_two(fref / fuart);\r\nrational_best_approximation(fuart, fref, w, w, &m, &n);\r\np->uartclk = fuart;\r\nreg = (m << BYT_PRV_CLK_M_VAL_SHIFT) | (n << BYT_PRV_CLK_N_VAL_SHIFT);\r\nwritel(reg, p->membase + BYT_PRV_CLK);\r\nreg |= BYT_PRV_CLK_EN | BYT_PRV_CLK_UPDATE;\r\nwritel(reg, p->membase + BYT_PRV_CLK);\r\np->status &= ~UPSTAT_AUTOCTS;\r\nif (termios->c_cflag & CRTSCTS)\r\np->status |= UPSTAT_AUTOCTS;\r\nserial8250_do_set_termios(p, termios, old);\r\n}\r\nstatic unsigned int byt_get_mctrl(struct uart_port *port)\r\n{\r\nunsigned int ret = serial8250_do_get_mctrl(port);\r\nret |= TIOCM_CAR | TIOCM_DSR;\r\nreturn ret;\r\n}\r\nstatic int byt_serial_setup(struct lpss8250 *lpss, struct uart_port *port)\r\n{\r\nstruct dw_dma_slave *param = &lpss->dma_param;\r\nstruct uart_8250_port *up = up_to_u8250p(port);\r\nstruct pci_dev *pdev = to_pci_dev(port->dev);\r\nunsigned int dma_devfn = PCI_DEVFN(PCI_SLOT(pdev->devfn), 0);\r\nstruct pci_dev *dma_dev = pci_get_slot(pdev->bus, dma_devfn);\r\nswitch (pdev->device) {\r\ncase PCI_DEVICE_ID_INTEL_BYT_UART1:\r\ncase PCI_DEVICE_ID_INTEL_BSW_UART1:\r\ncase PCI_DEVICE_ID_INTEL_BDW_UART1:\r\nparam->src_id = 3;\r\nparam->dst_id = 2;\r\nbreak;\r\ncase PCI_DEVICE_ID_INTEL_BYT_UART2:\r\ncase PCI_DEVICE_ID_INTEL_BSW_UART2:\r\ncase PCI_DEVICE_ID_INTEL_BDW_UART2:\r\nparam->src_id = 5;\r\nparam->dst_id = 4;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nparam->dma_dev = &dma_dev->dev;\r\nparam->m_master = 0;\r\nparam->p_master = 1;\r\nport->fifosize = 64;\r\nup->tx_loadsz = 64;\r\nlpss->dma_maxburst = 16;\r\nport->set_termios = byt_set_termios;\r\nport->get_mctrl = byt_get_mctrl;\r\nwritel(BYT_TX_OVF_INT_MASK, port->membase + BYT_TX_OVF_INT);\r\nreturn 0;\r\n}\r\nstatic void qrk_serial_setup_dma(struct lpss8250 *lpss, struct uart_port *port)\r\n{\r\nstruct uart_8250_dma *dma = &lpss->dma;\r\nstruct dw_dma_chip *chip = &lpss->dma_chip;\r\nstruct dw_dma_slave *param = &lpss->dma_param;\r\nstruct pci_dev *pdev = to_pci_dev(port->dev);\r\nint ret;\r\nchip->dev = &pdev->dev;\r\nchip->irq = pci_irq_vector(pdev, 0);\r\nchip->regs = pci_ioremap_bar(pdev, 1);\r\nchip->pdata = &qrk_serial_dma_pdata;\r\nret = dw_dma_probe(chip);\r\nif (ret)\r\nreturn;\r\npci_try_set_mwi(pdev);\r\ndma->rx_dma_addr = 0xfffff000;\r\ndma->tx_dma_addr = 0xfffff000;\r\nparam->dma_dev = &pdev->dev;\r\nparam->src_id = 0;\r\nparam->dst_id = 1;\r\nparam->hs_polarity = true;\r\nlpss->dma_maxburst = 8;\r\n}\r\nstatic void qrk_serial_exit_dma(struct lpss8250 *lpss)\r\n{\r\nstruct dw_dma_slave *param = &lpss->dma_param;\r\nif (!param->dma_dev)\r\nreturn;\r\ndw_dma_remove(&lpss->dma_chip);\r\n}\r\nstatic void qrk_serial_setup_dma(struct lpss8250 *lpss, struct uart_port *port) {}\r\nstatic void qrk_serial_exit_dma(struct lpss8250 *lpss) {}\r\nstatic int qrk_serial_setup(struct lpss8250 *lpss, struct uart_port *port)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(port->dev);\r\nint ret;\r\npci_set_master(pdev);\r\nret = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_ALL_TYPES);\r\nif (ret < 0)\r\nreturn ret;\r\nport->irq = pci_irq_vector(pdev, 0);\r\nqrk_serial_setup_dma(lpss, port);\r\nreturn 0;\r\n}\r\nstatic void qrk_serial_exit(struct lpss8250 *lpss)\r\n{\r\nqrk_serial_exit_dma(lpss);\r\n}\r\nstatic bool lpss8250_dma_filter(struct dma_chan *chan, void *param)\r\n{\r\nstruct dw_dma_slave *dws = param;\r\nif (dws->dma_dev != chan->device->dev)\r\nreturn false;\r\nchan->private = dws;\r\nreturn true;\r\n}\r\nstatic int lpss8250_dma_setup(struct lpss8250 *lpss, struct uart_8250_port *port)\r\n{\r\nstruct uart_8250_dma *dma = &lpss->dma;\r\nstruct dw_dma_slave *rx_param, *tx_param;\r\nstruct device *dev = port->port.dev;\r\nif (!lpss->dma_param.dma_dev)\r\nreturn 0;\r\nrx_param = devm_kzalloc(dev, sizeof(*rx_param), GFP_KERNEL);\r\nif (!rx_param)\r\nreturn -ENOMEM;\r\ntx_param = devm_kzalloc(dev, sizeof(*tx_param), GFP_KERNEL);\r\nif (!tx_param)\r\nreturn -ENOMEM;\r\n*rx_param = lpss->dma_param;\r\ndma->rxconf.src_maxburst = lpss->dma_maxburst;\r\n*tx_param = lpss->dma_param;\r\ndma->txconf.dst_maxburst = lpss->dma_maxburst;\r\ndma->fn = lpss8250_dma_filter;\r\ndma->rx_param = rx_param;\r\ndma->tx_param = tx_param;\r\nport->dma = dma;\r\nreturn 0;\r\n}\r\nstatic int lpss8250_probe(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nstruct uart_8250_port uart;\r\nstruct lpss8250 *lpss;\r\nint ret;\r\nret = pcim_enable_device(pdev);\r\nif (ret)\r\nreturn ret;\r\nlpss = devm_kzalloc(&pdev->dev, sizeof(*lpss), GFP_KERNEL);\r\nif (!lpss)\r\nreturn -ENOMEM;\r\nlpss->board = (struct lpss8250_board *)id->driver_data;\r\nmemset(&uart, 0, sizeof(struct uart_8250_port));\r\nuart.port.dev = &pdev->dev;\r\nuart.port.irq = pdev->irq;\r\nuart.port.private_data = lpss;\r\nuart.port.type = PORT_16550A;\r\nuart.port.iotype = UPIO_MEM;\r\nuart.port.regshift = 2;\r\nuart.port.uartclk = lpss->board->base_baud * 16;\r\nuart.port.flags = UPF_SHARE_IRQ | UPF_FIXED_PORT | UPF_FIXED_TYPE;\r\nuart.capabilities = UART_CAP_FIFO | UART_CAP_AFE;\r\nuart.port.mapbase = pci_resource_start(pdev, 0);\r\nuart.port.membase = pcim_iomap(pdev, 0, 0);\r\nif (!uart.port.membase)\r\nreturn -ENOMEM;\r\nret = lpss->board->setup(lpss, &uart.port);\r\nif (ret)\r\nreturn ret;\r\nret = lpss8250_dma_setup(lpss, &uart);\r\nif (ret)\r\ngoto err_exit;\r\nret = serial8250_register_8250_port(&uart);\r\nif (ret < 0)\r\ngoto err_exit;\r\nlpss->line = ret;\r\npci_set_drvdata(pdev, lpss);\r\nreturn 0;\r\nerr_exit:\r\nif (lpss->board->exit)\r\nlpss->board->exit(lpss);\r\nreturn ret;\r\n}\r\nstatic void lpss8250_remove(struct pci_dev *pdev)\r\n{\r\nstruct lpss8250 *lpss = pci_get_drvdata(pdev);\r\nserial8250_unregister_port(lpss->line);\r\nif (lpss->board->exit)\r\nlpss->board->exit(lpss);\r\n}
