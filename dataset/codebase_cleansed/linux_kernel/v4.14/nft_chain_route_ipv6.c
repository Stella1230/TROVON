static unsigned int nf_route_table_hook(void *priv,\r\nstruct sk_buff *skb,\r\nconst struct nf_hook_state *state)\r\n{\r\nunsigned int ret;\r\nstruct nft_pktinfo pkt;\r\nstruct in6_addr saddr, daddr;\r\nu_int8_t hop_limit;\r\nu32 mark, flowlabel;\r\nint err;\r\nnft_set_pktinfo_ipv6(&pkt, skb, state);\r\nmemcpy(&saddr, &ipv6_hdr(skb)->saddr, sizeof(saddr));\r\nmemcpy(&daddr, &ipv6_hdr(skb)->daddr, sizeof(daddr));\r\nmark = skb->mark;\r\nhop_limit = ipv6_hdr(skb)->hop_limit;\r\nflowlabel = *((u32 *)ipv6_hdr(skb));\r\nret = nft_do_chain(&pkt, priv);\r\nif (ret != NF_DROP && ret != NF_STOLEN &&\r\n(memcmp(&ipv6_hdr(skb)->saddr, &saddr, sizeof(saddr)) ||\r\nmemcmp(&ipv6_hdr(skb)->daddr, &daddr, sizeof(daddr)) ||\r\nskb->mark != mark ||\r\nipv6_hdr(skb)->hop_limit != hop_limit ||\r\nflowlabel != *((u_int32_t *)ipv6_hdr(skb)))) {\r\nerr = ip6_route_me_harder(state->net, skb);\r\nif (err < 0)\r\nret = NF_DROP_ERR(err);\r\n}\r\nreturn ret;\r\n}\r\nstatic int __init nft_chain_route_init(void)\r\n{\r\nreturn nft_register_chain_type(&nft_chain_route_ipv6);\r\n}\r\nstatic void __exit nft_chain_route_exit(void)\r\n{\r\nnft_unregister_chain_type(&nft_chain_route_ipv6);\r\n}
