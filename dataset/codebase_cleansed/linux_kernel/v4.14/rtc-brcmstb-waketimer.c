static inline void brcmstb_waketmr_clear_alarm(struct brcmstb_waketmr *timer)\r\n{\r\nwritel_relaxed(1, timer->base + BRCMSTB_WKTMR_EVENT);\r\n(void)readl_relaxed(timer->base + BRCMSTB_WKTMR_EVENT);\r\n}\r\nstatic void brcmstb_waketmr_set_alarm(struct brcmstb_waketmr *timer,\r\nunsigned int secs)\r\n{\r\nbrcmstb_waketmr_clear_alarm(timer);\r\nwritel_relaxed(secs + 1, timer->base + BRCMSTB_WKTMR_ALARM);\r\n}\r\nstatic irqreturn_t brcmstb_waketmr_irq(int irq, void *data)\r\n{\r\nstruct brcmstb_waketmr *timer = data;\r\npm_wakeup_event(timer->dev, 0);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void wktmr_read(struct brcmstb_waketmr *timer,\r\nstruct wktmr_time *t)\r\n{\r\nu32 tmp;\r\ndo {\r\nt->sec = readl_relaxed(timer->base + BRCMSTB_WKTMR_COUNTER);\r\ntmp = readl_relaxed(timer->base + BRCMSTB_WKTMR_PRESCALER_VAL);\r\n} while (tmp >= timer->rate);\r\nt->pre = timer->rate - tmp;\r\n}\r\nstatic int brcmstb_waketmr_prepare_suspend(struct brcmstb_waketmr *timer)\r\n{\r\nstruct device *dev = timer->dev;\r\nint ret = 0;\r\nif (device_may_wakeup(dev)) {\r\nret = enable_irq_wake(timer->irq);\r\nif (ret) {\r\ndev_err(dev, "failed to enable wake-up interrupt\n");\r\nreturn ret;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int brcmstb_waketmr_reboot(struct notifier_block *nb,\r\nunsigned long action, void *data)\r\n{\r\nstruct brcmstb_waketmr *timer;\r\ntimer = container_of(nb, struct brcmstb_waketmr, reboot_notifier);\r\nif (action == SYS_POWER_OFF)\r\nbrcmstb_waketmr_prepare_suspend(timer);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int brcmstb_waketmr_gettime(struct device *dev,\r\nstruct rtc_time *tm)\r\n{\r\nstruct brcmstb_waketmr *timer = dev_get_drvdata(dev);\r\nstruct wktmr_time now;\r\nwktmr_read(timer, &now);\r\nrtc_time_to_tm(now.sec, tm);\r\nreturn 0;\r\n}\r\nstatic int brcmstb_waketmr_settime(struct device *dev,\r\nstruct rtc_time *tm)\r\n{\r\nstruct brcmstb_waketmr *timer = dev_get_drvdata(dev);\r\ntime64_t sec;\r\nsec = rtc_tm_to_time64(tm);\r\nif (sec > U32_MAX || sec < 0)\r\nreturn -EINVAL;\r\nwritel_relaxed(sec, timer->base + BRCMSTB_WKTMR_COUNTER);\r\nreturn 0;\r\n}\r\nstatic int brcmstb_waketmr_getalarm(struct device *dev,\r\nstruct rtc_wkalrm *alarm)\r\n{\r\nstruct brcmstb_waketmr *timer = dev_get_drvdata(dev);\r\ntime64_t sec;\r\nu32 reg;\r\nsec = readl_relaxed(timer->base + BRCMSTB_WKTMR_ALARM);\r\nif (sec != 0) {\r\nalarm->enabled = 1;\r\nrtc_time64_to_tm(sec, &alarm->time);\r\n}\r\nreg = readl_relaxed(timer->base + BRCMSTB_WKTMR_EVENT);\r\nalarm->pending = !!(reg & 1);\r\nreturn 0;\r\n}\r\nstatic int brcmstb_waketmr_setalarm(struct device *dev,\r\nstruct rtc_wkalrm *alarm)\r\n{\r\nstruct brcmstb_waketmr *timer = dev_get_drvdata(dev);\r\ntime64_t sec;\r\nif (alarm->enabled)\r\nsec = rtc_tm_to_time64(&alarm->time);\r\nelse\r\nsec = 0;\r\nif (sec > U32_MAX || sec < 0)\r\nreturn -EINVAL;\r\nbrcmstb_waketmr_set_alarm(timer, sec);\r\nreturn 0;\r\n}\r\nstatic int brcmstb_waketmr_alarm_enable(struct device *dev,\r\nunsigned int enabled)\r\n{\r\nreturn 0;\r\n}\r\nstatic int brcmstb_waketmr_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct brcmstb_waketmr *timer;\r\nstruct resource *res;\r\nint ret;\r\ntimer = devm_kzalloc(dev, sizeof(*timer), GFP_KERNEL);\r\nif (!timer)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, timer);\r\ntimer->dev = dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ntimer->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(timer->base))\r\nreturn PTR_ERR(timer->base);\r\ndevice_set_wakeup_capable(dev, true);\r\ndevice_wakeup_enable(dev);\r\ntimer->irq = platform_get_irq(pdev, 0);\r\nif (timer->irq < 0)\r\nreturn -ENODEV;\r\ntimer->clk = devm_clk_get(dev, NULL);\r\nif (!IS_ERR(timer->clk)) {\r\nret = clk_prepare_enable(timer->clk);\r\nif (ret)\r\nreturn ret;\r\ntimer->rate = clk_get_rate(timer->clk);\r\nif (!timer->rate)\r\ntimer->rate = BRCMSTB_WKTMR_DEFAULT_FREQ;\r\n} else {\r\ntimer->rate = BRCMSTB_WKTMR_DEFAULT_FREQ;\r\ntimer->clk = NULL;\r\n}\r\nret = devm_request_irq(dev, timer->irq, brcmstb_waketmr_irq, 0,\r\n"brcmstb-waketimer", timer);\r\nif (ret < 0)\r\nreturn ret;\r\ntimer->reboot_notifier.notifier_call = brcmstb_waketmr_reboot;\r\nregister_reboot_notifier(&timer->reboot_notifier);\r\ntimer->rtc = rtc_device_register("brcmstb-waketmr", dev,\r\n&brcmstb_waketmr_ops, THIS_MODULE);\r\nif (IS_ERR(timer->rtc)) {\r\ndev_err(dev, "unable to register device\n");\r\nunregister_reboot_notifier(&timer->reboot_notifier);\r\nreturn PTR_ERR(timer->rtc);\r\n}\r\ndev_info(dev, "registered, with irq %d\n", timer->irq);\r\nreturn ret;\r\n}\r\nstatic int brcmstb_waketmr_remove(struct platform_device *pdev)\r\n{\r\nstruct brcmstb_waketmr *timer = dev_get_drvdata(&pdev->dev);\r\nunregister_reboot_notifier(&timer->reboot_notifier);\r\nrtc_device_unregister(timer->rtc);\r\nreturn 0;\r\n}\r\nstatic int brcmstb_waketmr_suspend(struct device *dev)\r\n{\r\nstruct brcmstb_waketmr *timer = dev_get_drvdata(dev);\r\nreturn brcmstb_waketmr_prepare_suspend(timer);\r\n}\r\nstatic int brcmstb_waketmr_resume(struct device *dev)\r\n{\r\nstruct brcmstb_waketmr *timer = dev_get_drvdata(dev);\r\nint ret;\r\nif (!device_may_wakeup(dev))\r\nreturn 0;\r\nret = disable_irq_wake(timer->irq);\r\nbrcmstb_waketmr_clear_alarm(timer);\r\nreturn ret;\r\n}
