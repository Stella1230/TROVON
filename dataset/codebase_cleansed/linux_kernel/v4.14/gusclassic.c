static int snd_gusclassic_match(struct device *dev, unsigned int n)\r\n{\r\nreturn enable[n];\r\n}\r\nstatic int snd_gusclassic_create(struct snd_card *card,\r\nstruct device *dev, unsigned int n,\r\nstruct snd_gus_card **rgus)\r\n{\r\nstatic long possible_ports[] = {0x220, 0x230, 0x240, 0x250, 0x260};\r\nstatic int possible_irqs[] = {5, 11, 12, 9, 7, 15, 3, 4, -1};\r\nstatic int possible_dmas[] = {5, 6, 7, 1, 3, -1};\r\nint i, error;\r\nif (irq[n] == SNDRV_AUTO_IRQ) {\r\nirq[n] = snd_legacy_find_free_irq(possible_irqs);\r\nif (irq[n] < 0) {\r\ndev_err(dev, "unable to find a free IRQ\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nif (dma1[n] == SNDRV_AUTO_DMA) {\r\ndma1[n] = snd_legacy_find_free_dma(possible_dmas);\r\nif (dma1[n] < 0) {\r\ndev_err(dev, "unable to find a free DMA1\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nif (dma2[n] == SNDRV_AUTO_DMA) {\r\ndma2[n] = snd_legacy_find_free_dma(possible_dmas);\r\nif (dma2[n] < 0) {\r\ndev_err(dev, "unable to find a free DMA2\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nif (port[n] != SNDRV_AUTO_PORT)\r\nreturn snd_gus_create(card, port[n], irq[n], dma1[n], dma2[n],\r\n0, channels[n], pcm_channels[n], 0, rgus);\r\ni = 0;\r\ndo {\r\nport[n] = possible_ports[i];\r\nerror = snd_gus_create(card, port[n], irq[n], dma1[n], dma2[n],\r\n0, channels[n], pcm_channels[n], 0, rgus);\r\n} while (error < 0 && ++i < ARRAY_SIZE(possible_ports));\r\nreturn error;\r\n}\r\nstatic int snd_gusclassic_detect(struct snd_gus_card *gus)\r\n{\r\nunsigned char d;\r\nsnd_gf1_i_write8(gus, SNDRV_GF1_GB_RESET, 0);\r\nif (((d = snd_gf1_i_look8(gus, SNDRV_GF1_GB_RESET)) & 0x07) != 0) {\r\nsnd_printdd("[0x%lx] check 1 failed - 0x%x\n", gus->gf1.port, d);\r\nreturn -ENODEV;\r\n}\r\nudelay(160);\r\nsnd_gf1_i_write8(gus, SNDRV_GF1_GB_RESET, 1);\r\nudelay(160);\r\nif (((d = snd_gf1_i_look8(gus, SNDRV_GF1_GB_RESET)) & 0x07) != 1) {\r\nsnd_printdd("[0x%lx] check 2 failed - 0x%x\n", gus->gf1.port, d);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_gusclassic_probe(struct device *dev, unsigned int n)\r\n{\r\nstruct snd_card *card;\r\nstruct snd_gus_card *gus;\r\nint error;\r\nerror = snd_card_new(dev, index[n], id[n], THIS_MODULE, 0, &card);\r\nif (error < 0)\r\nreturn error;\r\nif (pcm_channels[n] < 2)\r\npcm_channels[n] = 2;\r\nerror = snd_gusclassic_create(card, dev, n, &gus);\r\nif (error < 0)\r\ngoto out;\r\nerror = snd_gusclassic_detect(gus);\r\nif (error < 0)\r\ngoto out;\r\ngus->joystick_dac = joystick_dac[n];\r\nerror = snd_gus_initialize(gus);\r\nif (error < 0)\r\ngoto out;\r\nerror = -ENODEV;\r\nif (gus->max_flag || gus->ess_flag) {\r\ndev_err(dev, "GUS Classic or ACE soundcard was "\r\n"not detected at 0x%lx\n", gus->gf1.port);\r\ngoto out;\r\n}\r\nerror = snd_gf1_new_mixer(gus);\r\nif (error < 0)\r\ngoto out;\r\nerror = snd_gf1_pcm_new(gus, 0, 0);\r\nif (error < 0)\r\ngoto out;\r\nif (!gus->ace_flag) {\r\nerror = snd_gf1_rawmidi_new(gus, 0);\r\nif (error < 0)\r\ngoto out;\r\n}\r\nsprintf(card->longname + strlen(card->longname),\r\n" at 0x%lx, irq %d, dma %d",\r\ngus->gf1.port, gus->gf1.irq, gus->gf1.dma1);\r\nif (gus->gf1.dma2 >= 0)\r\nsprintf(card->longname + strlen(card->longname),\r\n"&%d", gus->gf1.dma2);\r\nerror = snd_card_register(card);\r\nif (error < 0)\r\ngoto out;\r\ndev_set_drvdata(dev, card);\r\nreturn 0;\r\nout: snd_card_free(card);\r\nreturn error;\r\n}\r\nstatic int snd_gusclassic_remove(struct device *dev, unsigned int n)\r\n{\r\nsnd_card_free(dev_get_drvdata(dev));\r\nreturn 0;\r\n}
