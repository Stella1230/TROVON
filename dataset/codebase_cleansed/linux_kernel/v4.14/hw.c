static void ath9k_hw_set_clockrate(struct ath_hw *ah)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ath9k_channel *chan = ah->curchan;\r\nunsigned int clockrate;\r\nif (AR_SREV_9287(ah) && AR_SREV_9287_13_OR_LATER(ah))\r\nclockrate = 117;\r\nelse if (!chan)\r\nclockrate = ATH9K_CLOCK_RATE_CCK;\r\nelse if (IS_CHAN_2GHZ(chan))\r\nclockrate = ATH9K_CLOCK_RATE_2GHZ_OFDM;\r\nelse if (ah->caps.hw_caps & ATH9K_HW_CAP_FASTCLOCK)\r\nclockrate = ATH9K_CLOCK_FAST_RATE_5GHZ_OFDM;\r\nelse\r\nclockrate = ATH9K_CLOCK_RATE_5GHZ_OFDM;\r\nif (chan) {\r\nif (IS_CHAN_HT40(chan))\r\nclockrate *= 2;\r\nif (IS_CHAN_HALF_RATE(chan))\r\nclockrate /= 2;\r\nif (IS_CHAN_QUARTER_RATE(chan))\r\nclockrate /= 4;\r\n}\r\ncommon->clockrate = clockrate;\r\n}\r\nstatic u32 ath9k_hw_mac_to_clks(struct ath_hw *ah, u32 usecs)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nreturn usecs * common->clockrate;\r\n}\r\nbool ath9k_hw_wait(struct ath_hw *ah, u32 reg, u32 mask, u32 val, u32 timeout)\r\n{\r\nint i;\r\nBUG_ON(timeout < AH_TIME_QUANTUM);\r\nfor (i = 0; i < (timeout / AH_TIME_QUANTUM); i++) {\r\nif ((REG_READ(ah, reg) & mask) == val)\r\nreturn true;\r\nudelay(AH_TIME_QUANTUM);\r\n}\r\nath_dbg(ath9k_hw_common(ah), ANY,\r\n"timeout (%d us) on reg 0x%x: 0x%08x & 0x%08x != 0x%08x\n",\r\ntimeout, reg, REG_READ(ah, reg), mask, val);\r\nreturn false;\r\n}\r\nvoid ath9k_hw_synth_delay(struct ath_hw *ah, struct ath9k_channel *chan,\r\nint hw_delay)\r\n{\r\nhw_delay /= 10;\r\nif (IS_CHAN_HALF_RATE(chan))\r\nhw_delay *= 2;\r\nelse if (IS_CHAN_QUARTER_RATE(chan))\r\nhw_delay *= 4;\r\nudelay(hw_delay + BASE_ACTIVATE_DELAY);\r\n}\r\nvoid ath9k_hw_write_array(struct ath_hw *ah, const struct ar5416IniArray *array,\r\nint column, unsigned int *writecnt)\r\n{\r\nint r;\r\nENABLE_REGWRITE_BUFFER(ah);\r\nfor (r = 0; r < array->ia_rows; r++) {\r\nREG_WRITE(ah, INI_RA(array, r, 0),\r\nINI_RA(array, r, column));\r\nDO_DELAY(*writecnt);\r\n}\r\nREGWRITE_BUFFER_FLUSH(ah);\r\n}\r\nvoid ath9k_hw_read_array(struct ath_hw *ah, u32 array[][2], int size)\r\n{\r\nu32 *tmp_reg_list, *tmp_data;\r\nint i;\r\ntmp_reg_list = kmalloc(size * sizeof(u32), GFP_KERNEL);\r\nif (!tmp_reg_list) {\r\ndev_err(ah->dev, "%s: tmp_reg_list: alloc filed\n", __func__);\r\nreturn;\r\n}\r\ntmp_data = kmalloc(size * sizeof(u32), GFP_KERNEL);\r\nif (!tmp_data) {\r\ndev_err(ah->dev, "%s tmp_data: alloc filed\n", __func__);\r\ngoto error_tmp_data;\r\n}\r\nfor (i = 0; i < size; i++)\r\ntmp_reg_list[i] = array[i][0];\r\nREG_READ_MULTI(ah, tmp_reg_list, tmp_data, size);\r\nfor (i = 0; i < size; i++)\r\narray[i][1] = tmp_data[i];\r\nkfree(tmp_data);\r\nerror_tmp_data:\r\nkfree(tmp_reg_list);\r\n}\r\nu32 ath9k_hw_reverse_bits(u32 val, u32 n)\r\n{\r\nu32 retval;\r\nint i;\r\nfor (i = 0, retval = 0; i < n; i++) {\r\nretval = (retval << 1) | (val & 1);\r\nval >>= 1;\r\n}\r\nreturn retval;\r\n}\r\nu16 ath9k_hw_computetxtime(struct ath_hw *ah,\r\nu8 phy, int kbps,\r\nu32 frameLen, u16 rateix,\r\nbool shortPreamble)\r\n{\r\nu32 bitsPerSymbol, numBits, numSymbols, phyTime, txTime;\r\nif (kbps == 0)\r\nreturn 0;\r\nswitch (phy) {\r\ncase WLAN_RC_PHY_CCK:\r\nphyTime = CCK_PREAMBLE_BITS + CCK_PLCP_BITS;\r\nif (shortPreamble)\r\nphyTime >>= 1;\r\nnumBits = frameLen << 3;\r\ntxTime = CCK_SIFS_TIME + phyTime + ((numBits * 1000) / kbps);\r\nbreak;\r\ncase WLAN_RC_PHY_OFDM:\r\nif (ah->curchan && IS_CHAN_QUARTER_RATE(ah->curchan)) {\r\nbitsPerSymbol = (kbps * OFDM_SYMBOL_TIME_QUARTER) / 1000;\r\nnumBits = OFDM_PLCP_BITS + (frameLen << 3);\r\nnumSymbols = DIV_ROUND_UP(numBits, bitsPerSymbol);\r\ntxTime = OFDM_SIFS_TIME_QUARTER\r\n+ OFDM_PREAMBLE_TIME_QUARTER\r\n+ (numSymbols * OFDM_SYMBOL_TIME_QUARTER);\r\n} else if (ah->curchan &&\r\nIS_CHAN_HALF_RATE(ah->curchan)) {\r\nbitsPerSymbol = (kbps * OFDM_SYMBOL_TIME_HALF) / 1000;\r\nnumBits = OFDM_PLCP_BITS + (frameLen << 3);\r\nnumSymbols = DIV_ROUND_UP(numBits, bitsPerSymbol);\r\ntxTime = OFDM_SIFS_TIME_HALF +\r\nOFDM_PREAMBLE_TIME_HALF\r\n+ (numSymbols * OFDM_SYMBOL_TIME_HALF);\r\n} else {\r\nbitsPerSymbol = (kbps * OFDM_SYMBOL_TIME) / 1000;\r\nnumBits = OFDM_PLCP_BITS + (frameLen << 3);\r\nnumSymbols = DIV_ROUND_UP(numBits, bitsPerSymbol);\r\ntxTime = OFDM_SIFS_TIME + OFDM_PREAMBLE_TIME\r\n+ (numSymbols * OFDM_SYMBOL_TIME);\r\n}\r\nbreak;\r\ndefault:\r\nath_err(ath9k_hw_common(ah),\r\n"Unknown phy %u (rate ix %u)\n", phy, rateix);\r\ntxTime = 0;\r\nbreak;\r\n}\r\nreturn txTime;\r\n}\r\nvoid ath9k_hw_get_channel_centers(struct ath_hw *ah,\r\nstruct ath9k_channel *chan,\r\nstruct chan_centers *centers)\r\n{\r\nint8_t extoff;\r\nif (!IS_CHAN_HT40(chan)) {\r\ncenters->ctl_center = centers->ext_center =\r\ncenters->synth_center = chan->channel;\r\nreturn;\r\n}\r\nif (IS_CHAN_HT40PLUS(chan)) {\r\ncenters->synth_center =\r\nchan->channel + HT40_CHANNEL_CENTER_SHIFT;\r\nextoff = 1;\r\n} else {\r\ncenters->synth_center =\r\nchan->channel - HT40_CHANNEL_CENTER_SHIFT;\r\nextoff = -1;\r\n}\r\ncenters->ctl_center =\r\ncenters->synth_center - (extoff * HT40_CHANNEL_CENTER_SHIFT);\r\ncenters->ext_center =\r\ncenters->synth_center + (extoff * HT40_CHANNEL_CENTER_SHIFT);\r\n}\r\nstatic void ath9k_hw_read_revisions(struct ath_hw *ah)\r\n{\r\nu32 val;\r\nif (ah->get_mac_revision)\r\nah->hw_version.macRev = ah->get_mac_revision();\r\nswitch (ah->hw_version.devid) {\r\ncase AR5416_AR9100_DEVID:\r\nah->hw_version.macVersion = AR_SREV_VERSION_9100;\r\nbreak;\r\ncase AR9300_DEVID_AR9330:\r\nah->hw_version.macVersion = AR_SREV_VERSION_9330;\r\nif (!ah->get_mac_revision) {\r\nval = REG_READ(ah, AR_SREV);\r\nah->hw_version.macRev = MS(val, AR_SREV_REVISION2);\r\n}\r\nreturn;\r\ncase AR9300_DEVID_AR9340:\r\nah->hw_version.macVersion = AR_SREV_VERSION_9340;\r\nreturn;\r\ncase AR9300_DEVID_QCA955X:\r\nah->hw_version.macVersion = AR_SREV_VERSION_9550;\r\nreturn;\r\ncase AR9300_DEVID_AR953X:\r\nah->hw_version.macVersion = AR_SREV_VERSION_9531;\r\nreturn;\r\ncase AR9300_DEVID_QCA956X:\r\nah->hw_version.macVersion = AR_SREV_VERSION_9561;\r\nreturn;\r\n}\r\nval = REG_READ(ah, AR_SREV) & AR_SREV_ID;\r\nif (val == 0xFF) {\r\nval = REG_READ(ah, AR_SREV);\r\nah->hw_version.macVersion =\r\n(val & AR_SREV_VERSION2) >> AR_SREV_TYPE2_S;\r\nah->hw_version.macRev = MS(val, AR_SREV_REVISION2);\r\nif (AR_SREV_9462(ah) || AR_SREV_9565(ah))\r\nah->is_pciexpress = true;\r\nelse\r\nah->is_pciexpress = (val &\r\nAR_SREV_TYPE2_HOST_MODE) ? 0 : 1;\r\n} else {\r\nif (!AR_SREV_9100(ah))\r\nah->hw_version.macVersion = MS(val, AR_SREV_VERSION);\r\nah->hw_version.macRev = val & AR_SREV_REVISION;\r\nif (ah->hw_version.macVersion == AR_SREV_VERSION_5416_PCIE)\r\nah->is_pciexpress = true;\r\n}\r\n}\r\nstatic void ath9k_hw_disablepcie(struct ath_hw *ah)\r\n{\r\nif (!AR_SREV_5416(ah))\r\nreturn;\r\nREG_WRITE(ah, AR_PCIE_SERDES, 0x9248fc00);\r\nREG_WRITE(ah, AR_PCIE_SERDES, 0x24924924);\r\nREG_WRITE(ah, AR_PCIE_SERDES, 0x28000029);\r\nREG_WRITE(ah, AR_PCIE_SERDES, 0x57160824);\r\nREG_WRITE(ah, AR_PCIE_SERDES, 0x25980579);\r\nREG_WRITE(ah, AR_PCIE_SERDES, 0x00000000);\r\nREG_WRITE(ah, AR_PCIE_SERDES, 0x1aaabe40);\r\nREG_WRITE(ah, AR_PCIE_SERDES, 0xbe105554);\r\nREG_WRITE(ah, AR_PCIE_SERDES, 0x000e1007);\r\nREG_WRITE(ah, AR_PCIE_SERDES2, 0x00000000);\r\n}\r\nstatic bool ath9k_hw_chip_test(struct ath_hw *ah)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nu32 regAddr[2] = { AR_STA_ID0 };\r\nu32 regHold[2];\r\nstatic const u32 patternData[4] = {\r\n0x55555555, 0xaaaaaaaa, 0x66666666, 0x99999999\r\n};\r\nint i, j, loop_max;\r\nif (!AR_SREV_9300_20_OR_LATER(ah)) {\r\nloop_max = 2;\r\nregAddr[1] = AR_PHY_BASE + (8 << 2);\r\n} else\r\nloop_max = 1;\r\nfor (i = 0; i < loop_max; i++) {\r\nu32 addr = regAddr[i];\r\nu32 wrData, rdData;\r\nregHold[i] = REG_READ(ah, addr);\r\nfor (j = 0; j < 0x100; j++) {\r\nwrData = (j << 16) | j;\r\nREG_WRITE(ah, addr, wrData);\r\nrdData = REG_READ(ah, addr);\r\nif (rdData != wrData) {\r\nath_err(common,\r\n"address test failed addr: 0x%08x - wr:0x%08x != rd:0x%08x\n",\r\naddr, wrData, rdData);\r\nreturn false;\r\n}\r\n}\r\nfor (j = 0; j < 4; j++) {\r\nwrData = patternData[j];\r\nREG_WRITE(ah, addr, wrData);\r\nrdData = REG_READ(ah, addr);\r\nif (wrData != rdData) {\r\nath_err(common,\r\n"address test failed addr: 0x%08x - wr:0x%08x != rd:0x%08x\n",\r\naddr, wrData, rdData);\r\nreturn false;\r\n}\r\n}\r\nREG_WRITE(ah, regAddr[i], regHold[i]);\r\n}\r\nudelay(100);\r\nreturn true;\r\n}\r\nstatic void ath9k_hw_init_config(struct ath_hw *ah)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nah->config.dma_beacon_response_time = 1;\r\nah->config.sw_beacon_response_time = 6;\r\nah->config.cwm_ignore_extcca = false;\r\nah->config.analog_shiftreg = 1;\r\nah->config.rx_intr_mitigation = true;\r\nif (AR_SREV_9300_20_OR_LATER(ah)) {\r\nah->config.rimt_last = 500;\r\nah->config.rimt_first = 2000;\r\n} else {\r\nah->config.rimt_last = 250;\r\nah->config.rimt_first = 700;\r\n}\r\nif (AR_SREV_9462(ah) || AR_SREV_9565(ah))\r\nah->config.pll_pwrsave = 7;\r\nif (num_possible_cpus() > 1)\r\nah->config.serialize_regmode = SER_REG_MODE_AUTO;\r\nif (NR_CPUS > 1 && ah->config.serialize_regmode == SER_REG_MODE_AUTO) {\r\nif (ah->hw_version.macVersion == AR_SREV_VERSION_5416_PCI ||\r\n((AR_SREV_9160(ah) || AR_SREV_9280(ah) || AR_SREV_9287(ah)) &&\r\n!ah->is_pciexpress)) {\r\nah->config.serialize_regmode = SER_REG_MODE_ON;\r\n} else {\r\nah->config.serialize_regmode = SER_REG_MODE_OFF;\r\n}\r\n}\r\nath_dbg(common, RESET, "serialize_regmode is %d\n",\r\nah->config.serialize_regmode);\r\nif (AR_SREV_9285(ah) || AR_SREV_9271(ah))\r\nah->config.max_txtrig_level = MAX_TX_FIFO_THRESHOLD >> 1;\r\nelse\r\nah->config.max_txtrig_level = MAX_TX_FIFO_THRESHOLD;\r\n}\r\nstatic void ath9k_hw_init_defaults(struct ath_hw *ah)\r\n{\r\nstruct ath_regulatory *regulatory = ath9k_hw_regulatory(ah);\r\nregulatory->country_code = CTRY_DEFAULT;\r\nregulatory->power_limit = MAX_RATE_POWER;\r\nah->hw_version.magic = AR5416_MAGIC;\r\nah->hw_version.subvendorid = 0;\r\nah->sta_id1_defaults = AR_STA_ID1_CRPT_MIC_ENABLE |\r\nAR_STA_ID1_MCAST_KSRCH;\r\nif (AR_SREV_9100(ah))\r\nah->sta_id1_defaults |= AR_STA_ID1_AR9100_BA_FIX;\r\nah->slottime = 9;\r\nah->globaltxtimeout = (u32) -1;\r\nah->power_mode = ATH9K_PM_UNDEFINED;\r\nah->htc_reset_init = true;\r\nah->tpc_enabled = false;\r\nah->ani_function = ATH9K_ANI_ALL;\r\nif (!AR_SREV_9300_20_OR_LATER(ah))\r\nah->ani_function &= ~ATH9K_ANI_MRC_CCK;\r\nif (AR_SREV_9285(ah) || AR_SREV_9271(ah))\r\nah->tx_trig_level = (AR_FTRIG_256B >> AR_FTRIG_S);\r\nelse\r\nah->tx_trig_level = (AR_FTRIG_512B >> AR_FTRIG_S);\r\n}\r\nstatic void ath9k_hw_init_macaddr(struct ath_hw *ah)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nint i;\r\nu16 eeval;\r\nstatic const u32 EEP_MAC[] = { EEP_MAC_LSW, EEP_MAC_MID, EEP_MAC_MSW };\r\nif (is_valid_ether_addr(common->macaddr))\r\nreturn;\r\nfor (i = 0; i < 3; i++) {\r\neeval = ah->eep_ops->get_eeprom(ah, EEP_MAC[i]);\r\ncommon->macaddr[2 * i] = eeval >> 8;\r\ncommon->macaddr[2 * i + 1] = eeval & 0xff;\r\n}\r\nif (is_valid_ether_addr(common->macaddr))\r\nreturn;\r\nath_err(common, "eeprom contains invalid mac address: %pM\n",\r\ncommon->macaddr);\r\nrandom_ether_addr(common->macaddr);\r\nath_err(common, "random mac address will be used: %pM\n",\r\ncommon->macaddr);\r\nreturn;\r\n}\r\nstatic int ath9k_hw_post_init(struct ath_hw *ah)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nint ecode;\r\nif (common->bus_ops->ath_bus_type != ATH_USB) {\r\nif (!ath9k_hw_chip_test(ah))\r\nreturn -ENODEV;\r\n}\r\nif (!AR_SREV_9300_20_OR_LATER(ah)) {\r\necode = ar9002_hw_rf_claim(ah);\r\nif (ecode != 0)\r\nreturn ecode;\r\n}\r\necode = ath9k_hw_eeprom_init(ah);\r\nif (ecode != 0)\r\nreturn ecode;\r\nath_dbg(ath9k_hw_common(ah), CONFIG, "Eeprom VER: %d, REV: %d\n",\r\nah->eep_ops->get_eeprom_ver(ah),\r\nah->eep_ops->get_eeprom_rev(ah));\r\nath9k_hw_ani_init(ah);\r\nif (AR_SREV_9300_20_OR_LATER(ah)) {\r\nu16 regdmn = ah->eep_ops->get_eeprom(ah, EEP_REG_0);\r\nif ((regdmn & 0xF0) == CTL_FCC) {\r\nah->nf_2g.max = AR_PHY_CCA_MAX_GOOD_VAL_9300_FCC_2GHZ;\r\nah->nf_5g.max = AR_PHY_CCA_MAX_GOOD_VAL_9300_FCC_5GHZ;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ath9k_hw_attach_ops(struct ath_hw *ah)\r\n{\r\nif (!AR_SREV_9300_20_OR_LATER(ah))\r\nreturn ar9002_hw_attach_ops(ah);\r\nar9003_hw_attach_ops(ah);\r\nreturn 0;\r\n}\r\nstatic int __ath9k_hw_init(struct ath_hw *ah)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nint r = 0;\r\nath9k_hw_read_revisions(ah);\r\nswitch (ah->hw_version.macVersion) {\r\ncase AR_SREV_VERSION_5416_PCI:\r\ncase AR_SREV_VERSION_5416_PCIE:\r\ncase AR_SREV_VERSION_9160:\r\ncase AR_SREV_VERSION_9100:\r\ncase AR_SREV_VERSION_9280:\r\ncase AR_SREV_VERSION_9285:\r\ncase AR_SREV_VERSION_9287:\r\ncase AR_SREV_VERSION_9271:\r\ncase AR_SREV_VERSION_9300:\r\ncase AR_SREV_VERSION_9330:\r\ncase AR_SREV_VERSION_9485:\r\ncase AR_SREV_VERSION_9340:\r\ncase AR_SREV_VERSION_9462:\r\ncase AR_SREV_VERSION_9550:\r\ncase AR_SREV_VERSION_9565:\r\ncase AR_SREV_VERSION_9531:\r\ncase AR_SREV_VERSION_9561:\r\nbreak;\r\ndefault:\r\nath_err(common,\r\n"Mac Chip Rev 0x%02x.%x is not supported by this driver\n",\r\nah->hw_version.macVersion, ah->hw_version.macRev);\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (AR_SREV_9300_20_OR_LATER(ah)) {\r\nah->WARegVal = REG_READ(ah, AR_WA);\r\nah->WARegVal |= (AR_WA_D3_L1_DISABLE |\r\nAR_WA_ASPM_TIMER_BASED_DISABLE);\r\n}\r\nif (!ath9k_hw_set_reset_reg(ah, ATH9K_RESET_POWER_ON)) {\r\nath_err(common, "Couldn't reset chip\n");\r\nreturn -EIO;\r\n}\r\nif (AR_SREV_9565(ah)) {\r\nah->WARegVal |= AR_WA_BIT22;\r\nREG_WRITE(ah, AR_WA, ah->WARegVal);\r\n}\r\nath9k_hw_init_defaults(ah);\r\nath9k_hw_init_config(ah);\r\nr = ath9k_hw_attach_ops(ah);\r\nif (r)\r\nreturn r;\r\nif (!ath9k_hw_setpower(ah, ATH9K_PM_AWAKE)) {\r\nath_err(common, "Couldn't wakeup chip\n");\r\nreturn -EIO;\r\n}\r\nif (AR_SREV_9271(ah) || AR_SREV_9100(ah) || AR_SREV_9340(ah) ||\r\nAR_SREV_9330(ah) || AR_SREV_9550(ah))\r\nah->is_pciexpress = false;\r\nah->hw_version.phyRev = REG_READ(ah, AR_PHY_CHIP_ID);\r\nath9k_hw_init_cal_settings(ah);\r\nif (!ah->is_pciexpress)\r\nath9k_hw_disablepcie(ah);\r\nr = ath9k_hw_post_init(ah);\r\nif (r)\r\nreturn r;\r\nath9k_hw_init_mode_gain_regs(ah);\r\nr = ath9k_hw_fill_cap_info(ah);\r\nif (r)\r\nreturn r;\r\nath9k_hw_init_macaddr(ah);\r\nath9k_hw_init_hang_checks(ah);\r\ncommon->state = ATH_HW_INITIALIZED;\r\nreturn 0;\r\n}\r\nint ath9k_hw_init(struct ath_hw *ah)\r\n{\r\nint ret;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nswitch (ah->hw_version.devid) {\r\ncase AR5416_DEVID_PCI:\r\ncase AR5416_DEVID_PCIE:\r\ncase AR5416_AR9100_DEVID:\r\ncase AR9160_DEVID_PCI:\r\ncase AR9280_DEVID_PCI:\r\ncase AR9280_DEVID_PCIE:\r\ncase AR9285_DEVID_PCIE:\r\ncase AR9287_DEVID_PCI:\r\ncase AR9287_DEVID_PCIE:\r\ncase AR2427_DEVID_PCIE:\r\ncase AR9300_DEVID_PCIE:\r\ncase AR9300_DEVID_AR9485_PCIE:\r\ncase AR9300_DEVID_AR9330:\r\ncase AR9300_DEVID_AR9340:\r\ncase AR9300_DEVID_QCA955X:\r\ncase AR9300_DEVID_AR9580:\r\ncase AR9300_DEVID_AR9462:\r\ncase AR9485_DEVID_AR1111:\r\ncase AR9300_DEVID_AR9565:\r\ncase AR9300_DEVID_AR953X:\r\ncase AR9300_DEVID_QCA956X:\r\nbreak;\r\ndefault:\r\nif (common->bus_ops->ath_bus_type == ATH_USB)\r\nbreak;\r\nath_err(common, "Hardware device ID 0x%04x not supported\n",\r\nah->hw_version.devid);\r\nreturn -EOPNOTSUPP;\r\n}\r\nret = __ath9k_hw_init(ah);\r\nif (ret) {\r\nath_err(common,\r\n"Unable to initialize hardware; initialization status: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nath_dynack_init(ah);\r\nreturn 0;\r\n}\r\nstatic void ath9k_hw_init_qos(struct ath_hw *ah)\r\n{\r\nENABLE_REGWRITE_BUFFER(ah);\r\nREG_WRITE(ah, AR_MIC_QOS_CONTROL, 0x100aa);\r\nREG_WRITE(ah, AR_MIC_QOS_SELECT, 0x3210);\r\nREG_WRITE(ah, AR_QOS_NO_ACK,\r\nSM(2, AR_QOS_NO_ACK_TWO_BIT) |\r\nSM(5, AR_QOS_NO_ACK_BIT_OFF) |\r\nSM(0, AR_QOS_NO_ACK_BYTE_OFF));\r\nREG_WRITE(ah, AR_TXOP_X, AR_TXOP_X_VAL);\r\nREG_WRITE(ah, AR_TXOP_0_3, 0xFFFFFFFF);\r\nREG_WRITE(ah, AR_TXOP_4_7, 0xFFFFFFFF);\r\nREG_WRITE(ah, AR_TXOP_8_11, 0xFFFFFFFF);\r\nREG_WRITE(ah, AR_TXOP_12_15, 0xFFFFFFFF);\r\nREGWRITE_BUFFER_FLUSH(ah);\r\n}\r\nu32 ar9003_get_pll_sqsum_dvc(struct ath_hw *ah)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nint i = 0;\r\nREG_CLR_BIT(ah, PLL3, PLL3_DO_MEAS_MASK);\r\nudelay(100);\r\nREG_SET_BIT(ah, PLL3, PLL3_DO_MEAS_MASK);\r\nwhile ((REG_READ(ah, PLL4) & PLL4_MEAS_DONE) == 0) {\r\nudelay(100);\r\nif (WARN_ON_ONCE(i >= 100)) {\r\nath_err(common, "PLL4 measurement not done\n");\r\nbreak;\r\n}\r\ni++;\r\n}\r\nreturn (REG_READ(ah, PLL3) & SQSUM_DVC_MASK) >> 3;\r\n}\r\nstatic void ath9k_hw_init_pll(struct ath_hw *ah,\r\nstruct ath9k_channel *chan)\r\n{\r\nu32 pll;\r\npll = ath9k_hw_compute_pll_control(ah, chan);\r\nif (AR_SREV_9485(ah) || AR_SREV_9565(ah)) {\r\nREG_RMW_FIELD(ah, AR_CH0_BB_DPLL2,\r\nAR_CH0_BB_DPLL2_PLL_PWD, 0x1);\r\nREG_RMW_FIELD(ah, AR_CH0_BB_DPLL2,\r\nAR_CH0_DPLL2_KD, 0x40);\r\nREG_RMW_FIELD(ah, AR_CH0_BB_DPLL2,\r\nAR_CH0_DPLL2_KI, 0x4);\r\nREG_RMW_FIELD(ah, AR_CH0_BB_DPLL1,\r\nAR_CH0_BB_DPLL1_REFDIV, 0x5);\r\nREG_RMW_FIELD(ah, AR_CH0_BB_DPLL1,\r\nAR_CH0_BB_DPLL1_NINI, 0x58);\r\nREG_RMW_FIELD(ah, AR_CH0_BB_DPLL1,\r\nAR_CH0_BB_DPLL1_NFRAC, 0x0);\r\nREG_RMW_FIELD(ah, AR_CH0_BB_DPLL2,\r\nAR_CH0_BB_DPLL2_OUTDIV, 0x1);\r\nREG_RMW_FIELD(ah, AR_CH0_BB_DPLL2,\r\nAR_CH0_BB_DPLL2_LOCAL_PLL, 0x1);\r\nREG_RMW_FIELD(ah, AR_CH0_BB_DPLL2,\r\nAR_CH0_BB_DPLL2_EN_NEGTRIG, 0x1);\r\nREG_RMW_FIELD(ah, AR_CH0_BB_DPLL3,\r\nAR_CH0_BB_DPLL3_PHASE_SHIFT, 0x6);\r\nREG_RMW_FIELD(ah, AR_CH0_BB_DPLL2,\r\nAR_CH0_BB_DPLL2_PLL_PWD, 0x0);\r\nudelay(1000);\r\n} else if (AR_SREV_9330(ah)) {\r\nu32 ddr_dpll2, pll_control2, kd;\r\nif (ah->is_clk_25mhz) {\r\nddr_dpll2 = 0x18e82f01;\r\npll_control2 = 0xe04a3d;\r\nkd = 0x1d;\r\n} else {\r\nddr_dpll2 = 0x19e82f01;\r\npll_control2 = 0x886666;\r\nkd = 0x3d;\r\n}\r\nREG_WRITE(ah, AR_CH0_DDR_DPLL2, ddr_dpll2);\r\nREG_RMW_FIELD(ah, AR_CH0_DDR_DPLL3,\r\nAR_CH0_DPLL3_PHASE_SHIFT, 0x1);\r\nREG_WRITE(ah, AR_RTC_PLL_CONTROL,\r\npll | AR_RTC_9300_PLL_BYPASS);\r\nudelay(1000);\r\nREG_WRITE(ah, AR_RTC_PLL_CONTROL2, pll_control2);\r\nREG_RMW_FIELD(ah, AR_CH0_BB_DPLL2, AR_CH0_DPLL2_KD, kd);\r\nREG_RMW_FIELD(ah, AR_CH0_BB_DPLL2, AR_CH0_DPLL2_KI, 0x06);\r\nREG_RMW_FIELD(ah, AR_CH0_BB_DPLL3,\r\nAR_CH0_BB_DPLL3_PHASE_SHIFT, 0x1);\r\n} else if (AR_SREV_9340(ah) || AR_SREV_9550(ah) || AR_SREV_9531(ah) ||\r\nAR_SREV_9561(ah)) {\r\nu32 regval, pll2_divint, pll2_divfrac, refdiv;\r\nREG_WRITE(ah, AR_RTC_PLL_CONTROL,\r\npll | AR_RTC_9300_SOC_PLL_BYPASS);\r\nudelay(1000);\r\nREG_SET_BIT(ah, AR_PHY_PLL_MODE, 0x1 << 16);\r\nudelay(100);\r\nif (ah->is_clk_25mhz) {\r\nif (AR_SREV_9531(ah) || AR_SREV_9561(ah)) {\r\npll2_divint = 0x1c;\r\npll2_divfrac = 0xa3d2;\r\nrefdiv = 1;\r\n} else {\r\npll2_divint = 0x54;\r\npll2_divfrac = 0x1eb85;\r\nrefdiv = 3;\r\n}\r\n} else {\r\nif (AR_SREV_9340(ah)) {\r\npll2_divint = 88;\r\npll2_divfrac = 0;\r\nrefdiv = 5;\r\n} else {\r\npll2_divint = 0x11;\r\npll2_divfrac = (AR_SREV_9531(ah) ||\r\nAR_SREV_9561(ah)) ?\r\n0x26665 : 0x26666;\r\nrefdiv = 1;\r\n}\r\n}\r\nregval = REG_READ(ah, AR_PHY_PLL_MODE);\r\nif (AR_SREV_9531(ah) || AR_SREV_9561(ah))\r\nregval |= (0x1 << 22);\r\nelse\r\nregval |= (0x1 << 16);\r\nREG_WRITE(ah, AR_PHY_PLL_MODE, regval);\r\nudelay(100);\r\nREG_WRITE(ah, AR_PHY_PLL_CONTROL, (refdiv << 27) |\r\n(pll2_divint << 18) | pll2_divfrac);\r\nudelay(100);\r\nregval = REG_READ(ah, AR_PHY_PLL_MODE);\r\nif (AR_SREV_9340(ah))\r\nregval = (regval & 0x80071fff) |\r\n(0x1 << 30) |\r\n(0x1 << 13) |\r\n(0x4 << 26) |\r\n(0x18 << 19);\r\nelse if (AR_SREV_9531(ah) || AR_SREV_9561(ah)) {\r\nregval = (regval & 0x01c00fff) |\r\n(0x1 << 31) |\r\n(0x2 << 29) |\r\n(0xa << 25) |\r\n(0x1 << 19);\r\nif (AR_SREV_9531(ah))\r\nregval |= (0x6 << 12);\r\n} else\r\nregval = (regval & 0x80071fff) |\r\n(0x3 << 30) |\r\n(0x1 << 13) |\r\n(0x4 << 26) |\r\n(0x60 << 19);\r\nREG_WRITE(ah, AR_PHY_PLL_MODE, regval);\r\nif (AR_SREV_9531(ah) || AR_SREV_9561(ah))\r\nREG_WRITE(ah, AR_PHY_PLL_MODE,\r\nREG_READ(ah, AR_PHY_PLL_MODE) & 0xffbfffff);\r\nelse\r\nREG_WRITE(ah, AR_PHY_PLL_MODE,\r\nREG_READ(ah, AR_PHY_PLL_MODE) & 0xfffeffff);\r\nudelay(1000);\r\n}\r\nif (AR_SREV_9565(ah))\r\npll |= 0x40000;\r\nREG_WRITE(ah, AR_RTC_PLL_CONTROL, pll);\r\nif (AR_SREV_9485(ah) || AR_SREV_9340(ah) || AR_SREV_9330(ah) ||\r\nAR_SREV_9550(ah))\r\nudelay(1000);\r\nif (AR_SREV_9271(ah)) {\r\nudelay(500);\r\nREG_WRITE(ah, 0x50040, 0x304);\r\n}\r\nudelay(RTC_PLL_SETTLE_DELAY);\r\nREG_WRITE(ah, AR_RTC_SLEEP_CLK, AR_RTC_FORCE_DERIVED_CLK);\r\n}\r\nstatic void ath9k_hw_init_interrupt_masks(struct ath_hw *ah,\r\nenum nl80211_iftype opmode)\r\n{\r\nu32 sync_default = AR_INTR_SYNC_DEFAULT;\r\nu32 imr_reg = AR_IMR_TXERR |\r\nAR_IMR_TXURN |\r\nAR_IMR_RXERR |\r\nAR_IMR_RXORN |\r\nAR_IMR_BCNMISC;\r\nif (AR_SREV_9340(ah) || AR_SREV_9550(ah) || AR_SREV_9531(ah) ||\r\nAR_SREV_9561(ah))\r\nsync_default &= ~AR_INTR_SYNC_HOST1_FATAL;\r\nif (AR_SREV_9300_20_OR_LATER(ah)) {\r\nimr_reg |= AR_IMR_RXOK_HP;\r\nif (ah->config.rx_intr_mitigation)\r\nimr_reg |= AR_IMR_RXINTM | AR_IMR_RXMINTR;\r\nelse\r\nimr_reg |= AR_IMR_RXOK_LP;\r\n} else {\r\nif (ah->config.rx_intr_mitigation)\r\nimr_reg |= AR_IMR_RXINTM | AR_IMR_RXMINTR;\r\nelse\r\nimr_reg |= AR_IMR_RXOK;\r\n}\r\nif (ah->config.tx_intr_mitigation)\r\nimr_reg |= AR_IMR_TXINTM | AR_IMR_TXMINTR;\r\nelse\r\nimr_reg |= AR_IMR_TXOK;\r\nENABLE_REGWRITE_BUFFER(ah);\r\nREG_WRITE(ah, AR_IMR, imr_reg);\r\nah->imrs2_reg |= AR_IMR_S2_GTT;\r\nREG_WRITE(ah, AR_IMR_S2, ah->imrs2_reg);\r\nif (!AR_SREV_9100(ah)) {\r\nREG_WRITE(ah, AR_INTR_SYNC_CAUSE, 0xFFFFFFFF);\r\nREG_WRITE(ah, AR_INTR_SYNC_ENABLE, sync_default);\r\nREG_WRITE(ah, AR_INTR_SYNC_MASK, 0);\r\n}\r\nREGWRITE_BUFFER_FLUSH(ah);\r\nif (AR_SREV_9300_20_OR_LATER(ah)) {\r\nREG_WRITE(ah, AR_INTR_PRIO_ASYNC_ENABLE, 0);\r\nREG_WRITE(ah, AR_INTR_PRIO_ASYNC_MASK, 0);\r\nREG_WRITE(ah, AR_INTR_PRIO_SYNC_ENABLE, 0);\r\nREG_WRITE(ah, AR_INTR_PRIO_SYNC_MASK, 0);\r\n}\r\n}\r\nstatic void ath9k_hw_set_sifs_time(struct ath_hw *ah, u32 us)\r\n{\r\nu32 val = ath9k_hw_mac_to_clks(ah, us - 2);\r\nval = min(val, (u32) 0xFFFF);\r\nREG_WRITE(ah, AR_D_GBL_IFS_SIFS, val);\r\n}\r\nvoid ath9k_hw_setslottime(struct ath_hw *ah, u32 us)\r\n{\r\nu32 val = ath9k_hw_mac_to_clks(ah, us);\r\nval = min(val, (u32) 0xFFFF);\r\nREG_WRITE(ah, AR_D_GBL_IFS_SLOT, val);\r\n}\r\nvoid ath9k_hw_set_ack_timeout(struct ath_hw *ah, u32 us)\r\n{\r\nu32 val = ath9k_hw_mac_to_clks(ah, us);\r\nval = min(val, (u32) MS(0xFFFFFFFF, AR_TIME_OUT_ACK));\r\nREG_RMW_FIELD(ah, AR_TIME_OUT, AR_TIME_OUT_ACK, val);\r\n}\r\nvoid ath9k_hw_set_cts_timeout(struct ath_hw *ah, u32 us)\r\n{\r\nu32 val = ath9k_hw_mac_to_clks(ah, us);\r\nval = min(val, (u32) MS(0xFFFFFFFF, AR_TIME_OUT_CTS));\r\nREG_RMW_FIELD(ah, AR_TIME_OUT, AR_TIME_OUT_CTS, val);\r\n}\r\nstatic bool ath9k_hw_set_global_txtimeout(struct ath_hw *ah, u32 tu)\r\n{\r\nif (tu > 0xFFFF) {\r\nath_dbg(ath9k_hw_common(ah), XMIT, "bad global tx timeout %u\n",\r\ntu);\r\nah->globaltxtimeout = (u32) -1;\r\nreturn false;\r\n} else {\r\nREG_RMW_FIELD(ah, AR_GTXTO, AR_GTXTO_TIMEOUT_LIMIT, tu);\r\nah->globaltxtimeout = tu;\r\nreturn true;\r\n}\r\n}\r\nvoid ath9k_hw_init_global_settings(struct ath_hw *ah)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nconst struct ath9k_channel *chan = ah->curchan;\r\nint acktimeout, ctstimeout, ack_offset = 0;\r\nint slottime;\r\nint sifstime;\r\nint rx_lat = 0, tx_lat = 0, eifs = 0;\r\nu32 reg;\r\nath_dbg(ath9k_hw_common(ah), RESET, "ah->misc_mode 0x%x\n",\r\nah->misc_mode);\r\nif (!chan)\r\nreturn;\r\nif (ah->misc_mode != 0)\r\nREG_SET_BIT(ah, AR_PCU_MISC, ah->misc_mode);\r\nif (IS_CHAN_A_FAST_CLOCK(ah, chan))\r\nrx_lat = 41;\r\nelse\r\nrx_lat = 37;\r\ntx_lat = 54;\r\nif (IS_CHAN_5GHZ(chan))\r\nsifstime = 16;\r\nelse\r\nsifstime = 10;\r\nif (IS_CHAN_HALF_RATE(chan)) {\r\neifs = 175;\r\nrx_lat *= 2;\r\ntx_lat *= 2;\r\nif (IS_CHAN_A_FAST_CLOCK(ah, chan))\r\ntx_lat += 11;\r\nsifstime = 32;\r\nack_offset = 16;\r\nslottime = 13;\r\n} else if (IS_CHAN_QUARTER_RATE(chan)) {\r\neifs = 340;\r\nrx_lat = (rx_lat * 4) - 1;\r\ntx_lat *= 4;\r\nif (IS_CHAN_A_FAST_CLOCK(ah, chan))\r\ntx_lat += 22;\r\nsifstime = 64;\r\nack_offset = 32;\r\nslottime = 21;\r\n} else {\r\nif (AR_SREV_9287(ah) && AR_SREV_9287_13_OR_LATER(ah)) {\r\neifs = AR_D_GBL_IFS_EIFS_ASYNC_FIFO;\r\nreg = AR_USEC_ASYNC_FIFO;\r\n} else {\r\neifs = REG_READ(ah, AR_D_GBL_IFS_EIFS)/\r\ncommon->clockrate;\r\nreg = REG_READ(ah, AR_USEC);\r\n}\r\nrx_lat = MS(reg, AR_USEC_RX_LAT);\r\ntx_lat = MS(reg, AR_USEC_TX_LAT);\r\nslottime = ah->slottime;\r\n}\r\nslottime += 3 * ah->coverage_class;\r\nacktimeout = slottime + sifstime + ack_offset;\r\nctstimeout = acktimeout;\r\nif (IS_CHAN_2GHZ(chan) &&\r\n!IS_CHAN_HALF_RATE(chan) && !IS_CHAN_QUARTER_RATE(chan)) {\r\nacktimeout += 64 - sifstime - ah->slottime;\r\nctstimeout += 48 - sifstime - ah->slottime;\r\n}\r\nif (ah->dynack.enabled) {\r\nacktimeout = ah->dynack.ackto;\r\nctstimeout = acktimeout;\r\nslottime = (acktimeout - 3) / 2;\r\n} else {\r\nah->dynack.ackto = acktimeout;\r\n}\r\nath9k_hw_set_sifs_time(ah, sifstime);\r\nath9k_hw_setslottime(ah, slottime);\r\nath9k_hw_set_ack_timeout(ah, acktimeout);\r\nath9k_hw_set_cts_timeout(ah, ctstimeout);\r\nif (ah->globaltxtimeout != (u32) -1)\r\nath9k_hw_set_global_txtimeout(ah, ah->globaltxtimeout);\r\nREG_WRITE(ah, AR_D_GBL_IFS_EIFS, ath9k_hw_mac_to_clks(ah, eifs));\r\nREG_RMW(ah, AR_USEC,\r\n(common->clockrate - 1) |\r\nSM(rx_lat, AR_USEC_RX_LAT) |\r\nSM(tx_lat, AR_USEC_TX_LAT),\r\nAR_USEC_TX_LAT | AR_USEC_RX_LAT | AR_USEC_USEC);\r\n}\r\nvoid ath9k_hw_deinit(struct ath_hw *ah)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nif (common->state < ATH_HW_INITIALIZED)\r\nreturn;\r\nath9k_hw_setpower(ah, ATH9K_PM_FULL_SLEEP);\r\n}\r\nu32 ath9k_regd_get_ctl(struct ath_regulatory *reg, struct ath9k_channel *chan)\r\n{\r\nu32 ctl = ath_regd_get_band_ctl(reg, chan->chan->band);\r\nif (IS_CHAN_2GHZ(chan))\r\nctl |= CTL_11G;\r\nelse\r\nctl |= CTL_11A;\r\nreturn ctl;\r\n}\r\nstatic inline void ath9k_hw_set_dma(struct ath_hw *ah)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nint txbuf_size;\r\nENABLE_REGWRITE_BUFFER(ah);\r\nif (!AR_SREV_9300_20_OR_LATER(ah))\r\nREG_SET_BIT(ah, AR_AHB_MODE, AR_AHB_PREFETCH_RD_EN);\r\nREG_RMW(ah, AR_TXCFG, AR_TXCFG_DMASZ_128B, AR_TXCFG_DMASZ_MASK);\r\nREGWRITE_BUFFER_FLUSH(ah);\r\nif (!AR_SREV_9300_20_OR_LATER(ah))\r\nREG_RMW_FIELD(ah, AR_TXCFG, AR_FTRIG, ah->tx_trig_level);\r\nENABLE_REGWRITE_BUFFER(ah);\r\nREG_RMW(ah, AR_RXCFG, AR_RXCFG_DMASZ_128B, AR_RXCFG_DMASZ_MASK);\r\nREG_WRITE(ah, AR_RXFIFO_CFG, 0x200);\r\nif (AR_SREV_9300_20_OR_LATER(ah)) {\r\nREG_RMW_FIELD(ah, AR_RXBP_THRESH, AR_RXBP_THRESH_HP, 0x1);\r\nREG_RMW_FIELD(ah, AR_RXBP_THRESH, AR_RXBP_THRESH_LP, 0x1);\r\nath9k_hw_set_rx_bufsize(ah, common->rx_bufsize -\r\nah->caps.rx_status_len);\r\n}\r\nif (AR_SREV_9285(ah)) {\r\ntxbuf_size = AR_9285_PCU_TXBUF_CTRL_USABLE_SIZE;\r\n} else if (AR_SREV_9340_13_OR_LATER(ah)) {\r\ntxbuf_size = AR_9340_PCU_TXBUF_CTRL_USABLE_SIZE;\r\n} else {\r\ntxbuf_size = AR_PCU_TXBUF_CTRL_USABLE_SIZE;\r\n}\r\nif (!AR_SREV_9271(ah))\r\nREG_WRITE(ah, AR_PCU_TXBUF_CTRL, txbuf_size);\r\nREGWRITE_BUFFER_FLUSH(ah);\r\nif (AR_SREV_9300_20_OR_LATER(ah))\r\nath9k_hw_reset_txstatus_ring(ah);\r\n}\r\nstatic void ath9k_hw_set_operating_mode(struct ath_hw *ah, int opmode)\r\n{\r\nu32 mask = AR_STA_ID1_STA_AP | AR_STA_ID1_ADHOC;\r\nu32 set = AR_STA_ID1_KSRCH_MODE;\r\nENABLE_REG_RMW_BUFFER(ah);\r\nswitch (opmode) {\r\ncase NL80211_IFTYPE_ADHOC:\r\nif (!AR_SREV_9340_13(ah)) {\r\nset |= AR_STA_ID1_ADHOC;\r\nREG_SET_BIT(ah, AR_CFG, AR_CFG_AP_ADHOC_INDICATION);\r\nbreak;\r\n}\r\ncase NL80211_IFTYPE_OCB:\r\ncase NL80211_IFTYPE_MESH_POINT:\r\ncase NL80211_IFTYPE_AP:\r\nset |= AR_STA_ID1_STA_AP;\r\ncase NL80211_IFTYPE_STATION:\r\nREG_CLR_BIT(ah, AR_CFG, AR_CFG_AP_ADHOC_INDICATION);\r\nbreak;\r\ndefault:\r\nif (!ah->is_monitoring)\r\nset = 0;\r\nbreak;\r\n}\r\nREG_RMW(ah, AR_STA_ID1, set, mask);\r\nREG_RMW_BUFFER_FLUSH(ah);\r\n}\r\nvoid ath9k_hw_get_delta_slope_vals(struct ath_hw *ah, u32 coef_scaled,\r\nu32 *coef_mantissa, u32 *coef_exponent)\r\n{\r\nu32 coef_exp, coef_man;\r\nfor (coef_exp = 31; coef_exp > 0; coef_exp--)\r\nif ((coef_scaled >> coef_exp) & 0x1)\r\nbreak;\r\ncoef_exp = 14 - (coef_exp - COEF_SCALE_S);\r\ncoef_man = coef_scaled + (1 << (COEF_SCALE_S - coef_exp - 1));\r\n*coef_mantissa = coef_man >> (COEF_SCALE_S - coef_exp);\r\n*coef_exponent = coef_exp - 16;\r\n}\r\nstatic bool ath9k_hw_ar9330_reset_war(struct ath_hw *ah, int type)\r\n{\r\nint i, npend = 0;\r\nfor (i = 0; i < AR_NUM_QCU; i++) {\r\nnpend = ath9k_hw_numtxpending(ah, i);\r\nif (npend)\r\nbreak;\r\n}\r\nif (ah->external_reset &&\r\n(npend || type == ATH9K_RESET_COLD)) {\r\nint reset_err = 0;\r\nath_dbg(ath9k_hw_common(ah), RESET,\r\n"reset MAC via external reset\n");\r\nreset_err = ah->external_reset();\r\nif (reset_err) {\r\nath_err(ath9k_hw_common(ah),\r\n"External reset failed, err=%d\n",\r\nreset_err);\r\nreturn false;\r\n}\r\nREG_WRITE(ah, AR_RTC_RESET, 1);\r\n}\r\nreturn true;\r\n}\r\nstatic bool ath9k_hw_set_reset(struct ath_hw *ah, int type)\r\n{\r\nu32 rst_flags;\r\nu32 tmpReg;\r\nif (AR_SREV_9100(ah)) {\r\nREG_RMW_FIELD(ah, AR_RTC_DERIVED_CLK,\r\nAR_RTC_DERIVED_CLK_PERIOD, 1);\r\n(void)REG_READ(ah, AR_RTC_DERIVED_CLK);\r\n}\r\nENABLE_REGWRITE_BUFFER(ah);\r\nif (AR_SREV_9300_20_OR_LATER(ah)) {\r\nREG_WRITE(ah, AR_WA, ah->WARegVal);\r\nudelay(10);\r\n}\r\nREG_WRITE(ah, AR_RTC_FORCE_WAKE, AR_RTC_FORCE_WAKE_EN |\r\nAR_RTC_FORCE_WAKE_ON_INT);\r\nif (AR_SREV_9100(ah)) {\r\nrst_flags = AR_RTC_RC_MAC_WARM | AR_RTC_RC_MAC_COLD |\r\nAR_RTC_RC_COLD_RESET | AR_RTC_RC_WARM_RESET;\r\n} else {\r\ntmpReg = REG_READ(ah, AR_INTR_SYNC_CAUSE);\r\nif (AR_SREV_9340(ah))\r\ntmpReg &= AR9340_INTR_SYNC_LOCAL_TIMEOUT;\r\nelse\r\ntmpReg &= AR_INTR_SYNC_LOCAL_TIMEOUT |\r\nAR_INTR_SYNC_RADM_CPL_TIMEOUT;\r\nif (tmpReg) {\r\nu32 val;\r\nREG_WRITE(ah, AR_INTR_SYNC_ENABLE, 0);\r\nval = AR_RC_HOSTIF;\r\nif (!AR_SREV_9300_20_OR_LATER(ah))\r\nval |= AR_RC_AHB;\r\nREG_WRITE(ah, AR_RC, val);\r\n} else if (!AR_SREV_9300_20_OR_LATER(ah))\r\nREG_WRITE(ah, AR_RC, AR_RC_AHB);\r\nrst_flags = AR_RTC_RC_MAC_WARM;\r\nif (type == ATH9K_RESET_COLD)\r\nrst_flags |= AR_RTC_RC_MAC_COLD;\r\n}\r\nif (AR_SREV_9330(ah)) {\r\nif (!ath9k_hw_ar9330_reset_war(ah, type))\r\nreturn false;\r\n}\r\nif (ath9k_hw_mci_is_enabled(ah))\r\nar9003_mci_check_gpm_offset(ah);\r\nif (AR_SREV_9300(ah) || AR_SREV_9580(ah)) {\r\nREG_SET_BIT(ah, AR_CFG, AR_CFG_HALT_REQ);\r\nath9k_hw_wait(ah, AR_CFG, AR_CFG_HALT_ACK, AR_CFG_HALT_ACK,\r\n20 * AH_WAIT_TIMEOUT);\r\nREG_CLR_BIT(ah, AR_CFG, AR_CFG_HALT_REQ);\r\n}\r\nREG_WRITE(ah, AR_RTC_RC, rst_flags);\r\nREGWRITE_BUFFER_FLUSH(ah);\r\nif (AR_SREV_9300_20_OR_LATER(ah))\r\nudelay(50);\r\nelse if (AR_SREV_9100(ah))\r\nmdelay(10);\r\nelse\r\nudelay(100);\r\nREG_WRITE(ah, AR_RTC_RC, 0);\r\nif (!ath9k_hw_wait(ah, AR_RTC_RC, AR_RTC_RC_M, 0, AH_WAIT_TIMEOUT)) {\r\nath_dbg(ath9k_hw_common(ah), RESET, "RTC stuck in MAC reset\n");\r\nreturn false;\r\n}\r\nif (!AR_SREV_9100(ah))\r\nREG_WRITE(ah, AR_RC, 0);\r\nif (AR_SREV_9100(ah))\r\nudelay(50);\r\nreturn true;\r\n}\r\nstatic bool ath9k_hw_set_reset_power_on(struct ath_hw *ah)\r\n{\r\nENABLE_REGWRITE_BUFFER(ah);\r\nif (AR_SREV_9300_20_OR_LATER(ah)) {\r\nREG_WRITE(ah, AR_WA, ah->WARegVal);\r\nudelay(10);\r\n}\r\nREG_WRITE(ah, AR_RTC_FORCE_WAKE, AR_RTC_FORCE_WAKE_EN |\r\nAR_RTC_FORCE_WAKE_ON_INT);\r\nif (!AR_SREV_9100(ah) && !AR_SREV_9300_20_OR_LATER(ah))\r\nREG_WRITE(ah, AR_RC, AR_RC_AHB);\r\nREG_WRITE(ah, AR_RTC_RESET, 0);\r\nREGWRITE_BUFFER_FLUSH(ah);\r\nudelay(2);\r\nif (!AR_SREV_9100(ah) && !AR_SREV_9300_20_OR_LATER(ah))\r\nREG_WRITE(ah, AR_RC, 0);\r\nREG_WRITE(ah, AR_RTC_RESET, 1);\r\nif (!ath9k_hw_wait(ah,\r\nAR_RTC_STATUS,\r\nAR_RTC_STATUS_M,\r\nAR_RTC_STATUS_ON,\r\nAH_WAIT_TIMEOUT)) {\r\nath_dbg(ath9k_hw_common(ah), RESET, "RTC not waking up\n");\r\nreturn false;\r\n}\r\nreturn ath9k_hw_set_reset(ah, ATH9K_RESET_WARM);\r\n}\r\nstatic bool ath9k_hw_set_reset_reg(struct ath_hw *ah, u32 type)\r\n{\r\nbool ret = false;\r\nif (AR_SREV_9300_20_OR_LATER(ah)) {\r\nREG_WRITE(ah, AR_WA, ah->WARegVal);\r\nudelay(10);\r\n}\r\nREG_WRITE(ah, AR_RTC_FORCE_WAKE,\r\nAR_RTC_FORCE_WAKE_EN | AR_RTC_FORCE_WAKE_ON_INT);\r\nif (!ah->reset_power_on)\r\ntype = ATH9K_RESET_POWER_ON;\r\nswitch (type) {\r\ncase ATH9K_RESET_POWER_ON:\r\nret = ath9k_hw_set_reset_power_on(ah);\r\nif (ret)\r\nah->reset_power_on = true;\r\nbreak;\r\ncase ATH9K_RESET_WARM:\r\ncase ATH9K_RESET_COLD:\r\nret = ath9k_hw_set_reset(ah, type);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic bool ath9k_hw_chip_reset(struct ath_hw *ah,\r\nstruct ath9k_channel *chan)\r\n{\r\nint reset_type = ATH9K_RESET_WARM;\r\nif (AR_SREV_9280(ah)) {\r\nif (ah->eep_ops->get_eeprom(ah, EEP_OL_PWRCTRL))\r\nreset_type = ATH9K_RESET_POWER_ON;\r\nelse\r\nreset_type = ATH9K_RESET_COLD;\r\n} else if (ah->chip_fullsleep || REG_READ(ah, AR_Q_TXE) ||\r\n(REG_READ(ah, AR_CR) & AR_CR_RXE))\r\nreset_type = ATH9K_RESET_COLD;\r\nif (!ath9k_hw_set_reset_reg(ah, reset_type))\r\nreturn false;\r\nif (!ath9k_hw_setpower(ah, ATH9K_PM_AWAKE))\r\nreturn false;\r\nah->chip_fullsleep = false;\r\nif (AR_SREV_9330(ah))\r\nar9003_hw_internal_regulator_apply(ah);\r\nath9k_hw_init_pll(ah, chan);\r\nreturn true;\r\n}\r\nstatic bool ath9k_hw_channel_change(struct ath_hw *ah,\r\nstruct ath9k_channel *chan)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ath9k_hw_capabilities *pCap = &ah->caps;\r\nbool band_switch = false, mode_diff = false;\r\nu8 ini_reloaded = 0;\r\nu32 qnum;\r\nint r;\r\nif (pCap->hw_caps & ATH9K_HW_CAP_FCC_BAND_SWITCH) {\r\nu32 flags_diff = chan->channelFlags ^ ah->curchan->channelFlags;\r\nband_switch = !!(flags_diff & CHANNEL_5GHZ);\r\nmode_diff = !!(flags_diff & ~CHANNEL_HT);\r\n}\r\nfor (qnum = 0; qnum < AR_NUM_QCU; qnum++) {\r\nif (ath9k_hw_numtxpending(ah, qnum)) {\r\nath_dbg(common, QUEUE,\r\n"Transmit frames pending on queue %d\n", qnum);\r\nreturn false;\r\n}\r\n}\r\nif (!ath9k_hw_rfbus_req(ah)) {\r\nath_err(common, "Could not kill baseband RX\n");\r\nreturn false;\r\n}\r\nif (band_switch || mode_diff) {\r\nath9k_hw_mark_phy_inactive(ah);\r\nudelay(5);\r\nif (band_switch)\r\nath9k_hw_init_pll(ah, chan);\r\nif (ath9k_hw_fast_chan_change(ah, chan, &ini_reloaded)) {\r\nath_err(common, "Failed to do fast channel change\n");\r\nreturn false;\r\n}\r\n}\r\nath9k_hw_set_channel_regs(ah, chan);\r\nr = ath9k_hw_rf_set_freq(ah, chan);\r\nif (r) {\r\nath_err(common, "Failed to set channel\n");\r\nreturn false;\r\n}\r\nath9k_hw_set_clockrate(ah);\r\nath9k_hw_apply_txpower(ah, chan, false);\r\nath9k_hw_set_delta_slope(ah, chan);\r\nath9k_hw_spur_mitigate_freq(ah, chan);\r\nif (band_switch || ini_reloaded)\r\nah->eep_ops->set_board_values(ah, chan);\r\nath9k_hw_init_bb(ah, chan);\r\nath9k_hw_rfbus_done(ah);\r\nif (band_switch || ini_reloaded) {\r\nah->ah_flags |= AH_FASTCC;\r\nath9k_hw_init_cal(ah, chan);\r\nah->ah_flags &= ~AH_FASTCC;\r\n}\r\nreturn true;\r\n}\r\nstatic void ath9k_hw_apply_gpio_override(struct ath_hw *ah)\r\n{\r\nu32 gpio_mask = ah->gpio_mask;\r\nint i;\r\nfor (i = 0; gpio_mask; i++, gpio_mask >>= 1) {\r\nif (!(gpio_mask & 1))\r\ncontinue;\r\nath9k_hw_gpio_request_out(ah, i, NULL,\r\nAR_GPIO_OUTPUT_MUX_AS_OUTPUT);\r\nath9k_hw_set_gpio(ah, i, !!(ah->gpio_val & BIT(i)));\r\nath9k_hw_gpio_free(ah, i);\r\n}\r\n}\r\nvoid ath9k_hw_check_nav(struct ath_hw *ah)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nu32 val;\r\nval = REG_READ(ah, AR_NAV);\r\nif (val != 0xdeadbeef && val > 0x7fff) {\r\nath_dbg(common, BSTUCK, "Abnormal NAV: 0x%x\n", val);\r\nREG_WRITE(ah, AR_NAV, 0);\r\n}\r\n}\r\nbool ath9k_hw_check_alive(struct ath_hw *ah)\r\n{\r\nint count = 50;\r\nu32 reg, last_val;\r\nif (REG_READ(ah, AR_CFG) == 0xdeadbeef)\r\nreturn false;\r\nif (AR_SREV_9300(ah))\r\nreturn !ath9k_hw_detect_mac_hang(ah);\r\nif (AR_SREV_9285_12_OR_LATER(ah))\r\nreturn true;\r\nlast_val = REG_READ(ah, AR_OBS_BUS_1);\r\ndo {\r\nreg = REG_READ(ah, AR_OBS_BUS_1);\r\nif (reg != last_val)\r\nreturn true;\r\nudelay(1);\r\nlast_val = reg;\r\nif ((reg & 0x7E7FFFEF) == 0x00702400)\r\ncontinue;\r\nswitch (reg & 0x7E000B00) {\r\ncase 0x1E000000:\r\ncase 0x52000B00:\r\ncase 0x18000B00:\r\ncontinue;\r\ndefault:\r\nreturn true;\r\n}\r\n} while (count-- > 0);\r\nreturn false;\r\n}\r\nstatic void ath9k_hw_init_mfp(struct ath_hw *ah)\r\n{\r\nif (AR_SREV_9280_20_OR_LATER(ah)) {\r\nREG_RMW_FIELD(ah, AR_AES_MUTE_MASK1, AR_AES_MUTE_MASK1_FC_MGMT,\r\n0xc7ff);\r\nif (AR_SREV_9271(ah) || AR_DEVID_7010(ah))\r\nah->sw_mgmt_crypto_tx = true;\r\nelse\r\nah->sw_mgmt_crypto_tx = false;\r\nah->sw_mgmt_crypto_rx = false;\r\n} else if (AR_SREV_9160_10_OR_LATER(ah)) {\r\nREG_CLR_BIT(ah, AR_PCU_MISC_MODE2,\r\nAR_PCU_MISC_MODE2_MGMT_CRYPTO_ENABLE);\r\nREG_SET_BIT(ah, AR_PCU_MISC_MODE2,\r\nAR_PCU_MISC_MODE2_NO_CRYPTO_FOR_NON_DATA_PKT);\r\nah->sw_mgmt_crypto_tx = true;\r\nah->sw_mgmt_crypto_rx = true;\r\n} else {\r\nah->sw_mgmt_crypto_tx = true;\r\nah->sw_mgmt_crypto_rx = true;\r\n}\r\n}\r\nstatic void ath9k_hw_reset_opmode(struct ath_hw *ah,\r\nu32 macStaId1, u32 saveDefAntenna)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nENABLE_REGWRITE_BUFFER(ah);\r\nREG_RMW(ah, AR_STA_ID1, macStaId1\r\n| AR_STA_ID1_RTS_USE_DEF\r\n| ah->sta_id1_defaults,\r\n~AR_STA_ID1_SADH_MASK);\r\nath_hw_setbssidmask(common);\r\nREG_WRITE(ah, AR_DEF_ANTENNA, saveDefAntenna);\r\nath9k_hw_write_associd(ah);\r\nREG_WRITE(ah, AR_ISR, ~0);\r\nREG_WRITE(ah, AR_RSSI_THR, INIT_RSSI_THR);\r\nREGWRITE_BUFFER_FLUSH(ah);\r\nath9k_hw_set_operating_mode(ah, ah->opmode);\r\n}\r\nstatic void ath9k_hw_init_queues(struct ath_hw *ah)\r\n{\r\nint i;\r\nENABLE_REGWRITE_BUFFER(ah);\r\nfor (i = 0; i < AR_NUM_DCU; i++)\r\nREG_WRITE(ah, AR_DQCUMASK(i), 1 << i);\r\nREGWRITE_BUFFER_FLUSH(ah);\r\nah->intr_txqs = 0;\r\nfor (i = 0; i < ATH9K_NUM_TX_QUEUES; i++)\r\nath9k_hw_resettxqueue(ah, i);\r\n}\r\nstatic void ath9k_hw_init_desc(struct ath_hw *ah)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nif (AR_SREV_9100(ah)) {\r\nu32 mask;\r\nmask = REG_READ(ah, AR_CFG);\r\nif (mask & (AR_CFG_SWRB | AR_CFG_SWTB | AR_CFG_SWRG)) {\r\nath_dbg(common, RESET, "CFG Byte Swap Set 0x%x\n",\r\nmask);\r\n} else {\r\nmask = INIT_CONFIG_STATUS | AR_CFG_SWRB | AR_CFG_SWTB;\r\nREG_WRITE(ah, AR_CFG, mask);\r\nath_dbg(common, RESET, "Setting CFG 0x%x\n",\r\nREG_READ(ah, AR_CFG));\r\n}\r\n} else {\r\nif (common->bus_ops->ath_bus_type == ATH_USB) {\r\nif (AR_SREV_9271(ah))\r\nREG_WRITE(ah, AR_CFG, AR_CFG_SWRB | AR_CFG_SWTB);\r\nelse\r\nREG_WRITE(ah, AR_CFG, AR_CFG_SWTD | AR_CFG_SWRD);\r\n}\r\n#ifdef __BIG_ENDIAN\r\nelse if (AR_SREV_9330(ah) || AR_SREV_9340(ah) ||\r\nAR_SREV_9550(ah) || AR_SREV_9531(ah) ||\r\nAR_SREV_9561(ah))\r\nREG_RMW(ah, AR_CFG, AR_CFG_SWRB | AR_CFG_SWTB, 0);\r\nelse\r\nREG_WRITE(ah, AR_CFG, AR_CFG_SWTD | AR_CFG_SWRD);\r\n#endif\r\n}\r\n}\r\nstatic int ath9k_hw_do_fastcc(struct ath_hw *ah, struct ath9k_channel *chan)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ath9k_hw_capabilities *pCap = &ah->caps;\r\nint ret;\r\nif (AR_SREV_9280(ah) && common->bus_ops->ath_bus_type == ATH_PCI)\r\ngoto fail;\r\nif (ah->chip_fullsleep)\r\ngoto fail;\r\nif (!ah->curchan)\r\ngoto fail;\r\nif (chan->channel == ah->curchan->channel)\r\ngoto fail;\r\nif ((ah->curchan->channelFlags | chan->channelFlags) &\r\n(CHANNEL_HALF | CHANNEL_QUARTER))\r\ngoto fail;\r\nif (!(pCap->hw_caps & ATH9K_HW_CAP_FCC_BAND_SWITCH) &&\r\n((chan->channelFlags ^ ah->curchan->channelFlags) & ~CHANNEL_HT))\r\ngoto fail;\r\nif (!ath9k_hw_check_alive(ah))\r\ngoto fail;\r\nif (AR_SREV_9462(ah) && (ah->caldata &&\r\n(!test_bit(TXIQCAL_DONE, &ah->caldata->cal_flags) ||\r\n!test_bit(TXCLCAL_DONE, &ah->caldata->cal_flags) ||\r\n!test_bit(RTT_DONE, &ah->caldata->cal_flags))))\r\ngoto fail;\r\nath_dbg(common, RESET, "FastChannelChange for %d -> %d\n",\r\nah->curchan->channel, chan->channel);\r\nret = ath9k_hw_channel_change(ah, chan);\r\nif (!ret)\r\ngoto fail;\r\nif (ath9k_hw_mci_is_enabled(ah))\r\nar9003_mci_2g5g_switch(ah, false);\r\nath9k_hw_loadnf(ah, ah->curchan);\r\nath9k_hw_start_nfcal(ah, true);\r\nif (AR_SREV_9271(ah))\r\nar9002_hw_load_ani_reg(ah, chan);\r\nreturn 0;\r\nfail:\r\nreturn -EINVAL;\r\n}\r\nu32 ath9k_hw_get_tsf_offset(struct timespec *last, struct timespec *cur)\r\n{\r\nstruct timespec ts;\r\ns64 usec;\r\nif (!cur) {\r\ngetrawmonotonic(&ts);\r\ncur = &ts;\r\n}\r\nusec = cur->tv_sec * 1000000ULL + cur->tv_nsec / 1000;\r\nusec -= last->tv_sec * 1000000ULL + last->tv_nsec / 1000;\r\nreturn (u32) usec;\r\n}\r\nint ath9k_hw_reset(struct ath_hw *ah, struct ath9k_channel *chan,\r\nstruct ath9k_hw_cal_data *caldata, bool fastcc)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nu32 saveLedState;\r\nu32 saveDefAntenna;\r\nu32 macStaId1;\r\nstruct timespec tsf_ts;\r\nu32 tsf_offset;\r\nu64 tsf = 0;\r\nint r;\r\nbool start_mci_reset = false;\r\nbool save_fullsleep = ah->chip_fullsleep;\r\nif (ath9k_hw_mci_is_enabled(ah)) {\r\nstart_mci_reset = ar9003_mci_start_reset(ah, chan);\r\nif (start_mci_reset)\r\nreturn 0;\r\n}\r\nif (!ath9k_hw_setpower(ah, ATH9K_PM_AWAKE))\r\nreturn -EIO;\r\nif (ah->curchan && !ah->chip_fullsleep)\r\nath9k_hw_getnf(ah, ah->curchan);\r\nah->caldata = caldata;\r\nif (caldata && (chan->channel != caldata->channel ||\r\nchan->channelFlags != caldata->channelFlags)) {\r\nmemset(caldata, 0, sizeof(*caldata));\r\nath9k_init_nfcal_hist_buffer(ah, chan);\r\n} else if (caldata) {\r\nclear_bit(PAPRD_PACKET_SENT, &caldata->cal_flags);\r\n}\r\nah->noise = ath9k_hw_getchan_noise(ah, chan, chan->noisefloor);\r\nif (fastcc) {\r\nr = ath9k_hw_do_fastcc(ah, chan);\r\nif (!r)\r\nreturn r;\r\n}\r\nif (ath9k_hw_mci_is_enabled(ah))\r\nar9003_mci_stop_bt(ah, save_fullsleep);\r\nsaveDefAntenna = REG_READ(ah, AR_DEF_ANTENNA);\r\nif (saveDefAntenna == 0)\r\nsaveDefAntenna = 1;\r\nmacStaId1 = REG_READ(ah, AR_STA_ID1) & AR_STA_ID1_BASE_RATE_11B;\r\ngetrawmonotonic(&tsf_ts);\r\ntsf = ath9k_hw_gettsf64(ah);\r\nsaveLedState = REG_READ(ah, AR_CFG_LED) &\r\n(AR_CFG_LED_ASSOC_CTL | AR_CFG_LED_MODE_SEL |\r\nAR_CFG_LED_BLINK_THRESH_SEL | AR_CFG_LED_BLINK_SLOW);\r\nath9k_hw_mark_phy_inactive(ah);\r\nah->paprd_table_write_done = false;\r\nif (AR_SREV_9271(ah) && ah->htc_reset_init) {\r\nREG_WRITE(ah,\r\nAR9271_RESET_POWER_DOWN_CONTROL,\r\nAR9271_RADIO_RF_RST);\r\nudelay(50);\r\n}\r\nif (!ath9k_hw_chip_reset(ah, chan)) {\r\nath_err(common, "Chip reset failed\n");\r\nreturn -EINVAL;\r\n}\r\nif (AR_SREV_9271(ah) && ah->htc_reset_init) {\r\nah->htc_reset_init = false;\r\nREG_WRITE(ah,\r\nAR9271_RESET_POWER_DOWN_CONTROL,\r\nAR9271_GATE_MAC_CTL);\r\nudelay(50);\r\n}\r\ntsf_offset = ath9k_hw_get_tsf_offset(&tsf_ts, NULL);\r\nath9k_hw_settsf64(ah, tsf + tsf_offset);\r\nif (AR_SREV_9280_20_OR_LATER(ah))\r\nREG_SET_BIT(ah, AR_GPIO_INPUT_EN_VAL, AR_GPIO_JTAG_DISABLE);\r\nif (!AR_SREV_9300_20_OR_LATER(ah))\r\nar9002_hw_enable_async_fifo(ah);\r\nr = ath9k_hw_process_ini(ah, chan);\r\nif (r)\r\nreturn r;\r\nath9k_hw_set_rfmode(ah, chan);\r\nif (ath9k_hw_mci_is_enabled(ah))\r\nar9003_mci_reset(ah, false, IS_CHAN_2GHZ(chan), save_fullsleep);\r\nif (AR_SREV_9100(ah) && (ath9k_hw_gettsf64(ah) < tsf)) {\r\ntsf_offset = ath9k_hw_get_tsf_offset(&tsf_ts, NULL);\r\nath9k_hw_settsf64(ah, tsf + tsf_offset);\r\n}\r\nath9k_hw_init_mfp(ah);\r\nath9k_hw_set_delta_slope(ah, chan);\r\nath9k_hw_spur_mitigate_freq(ah, chan);\r\nah->eep_ops->set_board_values(ah, chan);\r\nath9k_hw_reset_opmode(ah, macStaId1, saveDefAntenna);\r\nr = ath9k_hw_rf_set_freq(ah, chan);\r\nif (r)\r\nreturn r;\r\nath9k_hw_set_clockrate(ah);\r\nath9k_hw_init_queues(ah);\r\nath9k_hw_init_interrupt_masks(ah, ah->opmode);\r\nath9k_hw_ani_cache_ini_regs(ah);\r\nath9k_hw_init_qos(ah);\r\nif (ah->caps.hw_caps & ATH9K_HW_CAP_RFSILENT)\r\nath9k_hw_gpio_request_in(ah, ah->rfkill_gpio, "ath9k-rfkill");\r\nath9k_hw_init_global_settings(ah);\r\nif (AR_SREV_9287(ah) && AR_SREV_9287_13_OR_LATER(ah)) {\r\nREG_SET_BIT(ah, AR_MAC_PCU_LOGIC_ANALYZER,\r\nAR_MAC_PCU_LOGIC_ANALYZER_DISBUG20768);\r\nREG_RMW_FIELD(ah, AR_AHB_MODE, AR_AHB_CUSTOM_BURST_EN,\r\nAR_AHB_CUSTOM_BURST_ASYNC_FIFO_VAL);\r\nREG_SET_BIT(ah, AR_PCU_MISC_MODE2,\r\nAR_PCU_MISC_MODE2_ENABLE_AGGWEP);\r\n}\r\nREG_SET_BIT(ah, AR_STA_ID1, AR_STA_ID1_PRESERVE_SEQNUM);\r\nath9k_hw_set_dma(ah);\r\nif (!ath9k_hw_mci_is_enabled(ah))\r\nREG_WRITE(ah, AR_OBS, 8);\r\nENABLE_REG_RMW_BUFFER(ah);\r\nif (ah->config.rx_intr_mitigation) {\r\nREG_RMW_FIELD(ah, AR_RIMT, AR_RIMT_LAST, ah->config.rimt_last);\r\nREG_RMW_FIELD(ah, AR_RIMT, AR_RIMT_FIRST, ah->config.rimt_first);\r\n}\r\nif (ah->config.tx_intr_mitigation) {\r\nREG_RMW_FIELD(ah, AR_TIMT, AR_TIMT_LAST, 300);\r\nREG_RMW_FIELD(ah, AR_TIMT, AR_TIMT_FIRST, 750);\r\n}\r\nREG_RMW_BUFFER_FLUSH(ah);\r\nath9k_hw_init_bb(ah, chan);\r\nif (caldata) {\r\nclear_bit(TXIQCAL_DONE, &caldata->cal_flags);\r\nclear_bit(TXCLCAL_DONE, &caldata->cal_flags);\r\n}\r\nif (!ath9k_hw_init_cal(ah, chan))\r\nreturn -EIO;\r\nif (ath9k_hw_mci_is_enabled(ah) && ar9003_mci_end_reset(ah, chan, caldata))\r\nreturn -EIO;\r\nENABLE_REGWRITE_BUFFER(ah);\r\nath9k_hw_restore_chainmask(ah);\r\nREG_WRITE(ah, AR_CFG_LED, saveLedState | AR_CFG_SCLK_32KHZ);\r\nREGWRITE_BUFFER_FLUSH(ah);\r\nath9k_hw_gen_timer_start_tsf2(ah);\r\nath9k_hw_init_desc(ah);\r\nif (ath9k_hw_btcoex_is_enabled(ah))\r\nath9k_hw_btcoex_enable(ah);\r\nif (ath9k_hw_mci_is_enabled(ah))\r\nar9003_mci_check_bt(ah);\r\nif (AR_SREV_9300_20_OR_LATER(ah)) {\r\nath9k_hw_loadnf(ah, chan);\r\nath9k_hw_start_nfcal(ah, true);\r\n}\r\nif (AR_SREV_9300_20_OR_LATER(ah))\r\nar9003_hw_bb_watchdog_config(ah);\r\nif (ah->config.hw_hang_checks & HW_PHYRESTART_CLC_WAR)\r\nar9003_hw_disable_phy_restart(ah);\r\nath9k_hw_apply_gpio_override(ah);\r\nif (AR_SREV_9565(ah) && common->bt_ant_diversity)\r\nREG_SET_BIT(ah, AR_BTCOEX_WL_LNADIV, AR_BTCOEX_WL_LNADIV_FORCE_ON);\r\nif (ah->hw->conf.radar_enabled) {\r\nah->radar_conf.ext_channel = IS_CHAN_HT40(chan);\r\nath9k_hw_set_radar_params(ah);\r\n}\r\nreturn 0;\r\n}\r\nstatic void ath9k_set_power_sleep(struct ath_hw *ah)\r\n{\r\nREG_SET_BIT(ah, AR_STA_ID1, AR_STA_ID1_PWR_SAV);\r\nif (AR_SREV_9462(ah) || AR_SREV_9565(ah)) {\r\nREG_CLR_BIT(ah, AR_TIMER_MODE, 0xff);\r\nREG_CLR_BIT(ah, AR_NDP2_TIMER_MODE, 0xff);\r\nREG_CLR_BIT(ah, AR_SLP32_INC, 0xfffff);\r\nREG_WRITE(ah, AR_MCI_INTERRUPT_RX_MSG_EN, 0);\r\nudelay(100);\r\n}\r\nREG_CLR_BIT(ah, AR_RTC_FORCE_WAKE, AR_RTC_FORCE_WAKE_EN);\r\nif (ath9k_hw_mci_is_enabled(ah))\r\nudelay(100);\r\nif (!AR_SREV_9100(ah) && !AR_SREV_9300_20_OR_LATER(ah))\r\nREG_WRITE(ah, AR_RC, AR_RC_AHB | AR_RC_HOSTIF);\r\nif (!AR_SREV_5416(ah) && !AR_SREV_9271(ah)) {\r\nREG_CLR_BIT(ah, AR_RTC_RESET, AR_RTC_RESET_EN);\r\nudelay(2);\r\n}\r\nif (AR_SREV_9300_20_OR_LATER(ah))\r\nREG_WRITE(ah, AR_WA, ah->WARegVal & ~AR_WA_D3_L1_DISABLE);\r\n}\r\nstatic void ath9k_set_power_network_sleep(struct ath_hw *ah)\r\n{\r\nstruct ath9k_hw_capabilities *pCap = &ah->caps;\r\nREG_SET_BIT(ah, AR_STA_ID1, AR_STA_ID1_PWR_SAV);\r\nif (!(pCap->hw_caps & ATH9K_HW_CAP_AUTOSLEEP)) {\r\nREG_WRITE(ah, AR_RTC_FORCE_WAKE,\r\nAR_RTC_FORCE_WAKE_ON_INT);\r\n} else {\r\nif (ath9k_hw_mci_is_enabled(ah))\r\nREG_CLR_BIT(ah, AR_MCI_INTERRUPT_RX_MSG_EN,\r\nAR_MCI_INTERRUPT_RX_HW_MSG_MASK);\r\nREG_CLR_BIT(ah, AR_RTC_FORCE_WAKE, AR_RTC_FORCE_WAKE_EN);\r\nif (ath9k_hw_mci_is_enabled(ah))\r\nudelay(30);\r\n}\r\nif (AR_SREV_9300_20_OR_LATER(ah))\r\nREG_WRITE(ah, AR_WA, ah->WARegVal & ~AR_WA_D3_L1_DISABLE);\r\n}\r\nstatic bool ath9k_hw_set_power_awake(struct ath_hw *ah)\r\n{\r\nu32 val;\r\nint i;\r\nif (AR_SREV_9300_20_OR_LATER(ah)) {\r\nREG_WRITE(ah, AR_WA, ah->WARegVal);\r\nudelay(10);\r\n}\r\nif ((REG_READ(ah, AR_RTC_STATUS) &\r\nAR_RTC_STATUS_M) == AR_RTC_STATUS_SHUTDOWN) {\r\nif (!ath9k_hw_set_reset_reg(ah, ATH9K_RESET_POWER_ON)) {\r\nreturn false;\r\n}\r\nif (!AR_SREV_9300_20_OR_LATER(ah))\r\nath9k_hw_init_pll(ah, NULL);\r\n}\r\nif (AR_SREV_9100(ah))\r\nREG_SET_BIT(ah, AR_RTC_RESET,\r\nAR_RTC_RESET_EN);\r\nREG_SET_BIT(ah, AR_RTC_FORCE_WAKE,\r\nAR_RTC_FORCE_WAKE_EN);\r\nif (AR_SREV_9100(ah))\r\nmdelay(10);\r\nelse\r\nudelay(50);\r\nfor (i = POWER_UP_TIME / 50; i > 0; i--) {\r\nval = REG_READ(ah, AR_RTC_STATUS) & AR_RTC_STATUS_M;\r\nif (val == AR_RTC_STATUS_ON)\r\nbreak;\r\nudelay(50);\r\nREG_SET_BIT(ah, AR_RTC_FORCE_WAKE,\r\nAR_RTC_FORCE_WAKE_EN);\r\n}\r\nif (i == 0) {\r\nath_err(ath9k_hw_common(ah),\r\n"Failed to wakeup in %uus\n",\r\nPOWER_UP_TIME / 20);\r\nreturn false;\r\n}\r\nif (ath9k_hw_mci_is_enabled(ah))\r\nar9003_mci_set_power_awake(ah);\r\nREG_CLR_BIT(ah, AR_STA_ID1, AR_STA_ID1_PWR_SAV);\r\nreturn true;\r\n}\r\nbool ath9k_hw_setpower(struct ath_hw *ah, enum ath9k_power_mode mode)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nint status = true;\r\nstatic const char *modes[] = {\r\n"AWAKE",\r\n"FULL-SLEEP",\r\n"NETWORK SLEEP",\r\n"UNDEFINED"\r\n};\r\nif (ah->power_mode == mode)\r\nreturn status;\r\nath_dbg(common, RESET, "%s -> %s\n",\r\nmodes[ah->power_mode], modes[mode]);\r\nswitch (mode) {\r\ncase ATH9K_PM_AWAKE:\r\nstatus = ath9k_hw_set_power_awake(ah);\r\nbreak;\r\ncase ATH9K_PM_FULL_SLEEP:\r\nif (ath9k_hw_mci_is_enabled(ah))\r\nar9003_mci_set_full_sleep(ah);\r\nath9k_set_power_sleep(ah);\r\nah->chip_fullsleep = true;\r\nbreak;\r\ncase ATH9K_PM_NETWORK_SLEEP:\r\nath9k_set_power_network_sleep(ah);\r\nbreak;\r\ndefault:\r\nath_err(common, "Unknown power mode %u\n", mode);\r\nreturn false;\r\n}\r\nah->power_mode = mode;\r\nif (!(ah->ah_flags & AH_UNPLUGGED))\r\nATH_DBG_WARN_ON_ONCE(!status);\r\nreturn status;\r\n}\r\nvoid ath9k_hw_beaconinit(struct ath_hw *ah, u32 next_beacon, u32 beacon_period)\r\n{\r\nint flags = 0;\r\nENABLE_REGWRITE_BUFFER(ah);\r\nswitch (ah->opmode) {\r\ncase NL80211_IFTYPE_ADHOC:\r\nREG_SET_BIT(ah, AR_TXCFG,\r\nAR_TXCFG_ADHOC_BEACON_ATIM_TX_POLICY);\r\ncase NL80211_IFTYPE_MESH_POINT:\r\ncase NL80211_IFTYPE_AP:\r\nREG_WRITE(ah, AR_NEXT_TBTT_TIMER, next_beacon);\r\nREG_WRITE(ah, AR_NEXT_DMA_BEACON_ALERT, next_beacon -\r\nTU_TO_USEC(ah->config.dma_beacon_response_time));\r\nREG_WRITE(ah, AR_NEXT_SWBA, next_beacon -\r\nTU_TO_USEC(ah->config.sw_beacon_response_time));\r\nflags |=\r\nAR_TBTT_TIMER_EN | AR_DBA_TIMER_EN | AR_SWBA_TIMER_EN;\r\nbreak;\r\ndefault:\r\nath_dbg(ath9k_hw_common(ah), BEACON,\r\n"%s: unsupported opmode: %d\n", __func__, ah->opmode);\r\nreturn;\r\nbreak;\r\n}\r\nREG_WRITE(ah, AR_BEACON_PERIOD, beacon_period);\r\nREG_WRITE(ah, AR_DMA_BEACON_PERIOD, beacon_period);\r\nREG_WRITE(ah, AR_SWBA_PERIOD, beacon_period);\r\nREGWRITE_BUFFER_FLUSH(ah);\r\nREG_SET_BIT(ah, AR_TIMER_MODE, flags);\r\n}\r\nvoid ath9k_hw_set_sta_beacon_timers(struct ath_hw *ah,\r\nconst struct ath9k_beacon_state *bs)\r\n{\r\nu32 nextTbtt, beaconintval, dtimperiod, beacontimeout;\r\nstruct ath9k_hw_capabilities *pCap = &ah->caps;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nENABLE_REGWRITE_BUFFER(ah);\r\nREG_WRITE(ah, AR_NEXT_TBTT_TIMER, bs->bs_nexttbtt);\r\nREG_WRITE(ah, AR_BEACON_PERIOD, bs->bs_intval);\r\nREG_WRITE(ah, AR_DMA_BEACON_PERIOD, bs->bs_intval);\r\nREGWRITE_BUFFER_FLUSH(ah);\r\nREG_RMW_FIELD(ah, AR_RSSI_THR,\r\nAR_RSSI_THR_BM_THR, bs->bs_bmissthreshold);\r\nbeaconintval = bs->bs_intval;\r\nif (bs->bs_sleepduration > beaconintval)\r\nbeaconintval = bs->bs_sleepduration;\r\ndtimperiod = bs->bs_dtimperiod;\r\nif (bs->bs_sleepduration > dtimperiod)\r\ndtimperiod = bs->bs_sleepduration;\r\nif (beaconintval == dtimperiod)\r\nnextTbtt = bs->bs_nextdtim;\r\nelse\r\nnextTbtt = bs->bs_nexttbtt;\r\nath_dbg(common, BEACON, "next DTIM %u\n", bs->bs_nextdtim);\r\nath_dbg(common, BEACON, "next beacon %u\n", nextTbtt);\r\nath_dbg(common, BEACON, "beacon period %u\n", beaconintval);\r\nath_dbg(common, BEACON, "DTIM period %u\n", dtimperiod);\r\nENABLE_REGWRITE_BUFFER(ah);\r\nREG_WRITE(ah, AR_NEXT_DTIM, bs->bs_nextdtim - SLEEP_SLOP);\r\nREG_WRITE(ah, AR_NEXT_TIM, nextTbtt - SLEEP_SLOP);\r\nREG_WRITE(ah, AR_SLEEP1,\r\nSM((CAB_TIMEOUT_VAL << 3), AR_SLEEP1_CAB_TIMEOUT)\r\n| AR_SLEEP1_ASSUME_DTIM);\r\nif (pCap->hw_caps & ATH9K_HW_CAP_AUTOSLEEP)\r\nbeacontimeout = (BEACON_TIMEOUT_VAL << 3);\r\nelse\r\nbeacontimeout = MIN_BEACON_TIMEOUT_VAL;\r\nREG_WRITE(ah, AR_SLEEP2,\r\nSM(beacontimeout, AR_SLEEP2_BEACON_TIMEOUT));\r\nREG_WRITE(ah, AR_TIM_PERIOD, beaconintval);\r\nREG_WRITE(ah, AR_DTIM_PERIOD, dtimperiod);\r\nREGWRITE_BUFFER_FLUSH(ah);\r\nREG_SET_BIT(ah, AR_TIMER_MODE,\r\nAR_TBTT_TIMER_EN | AR_TIM_TIMER_EN |\r\nAR_DTIM_TIMER_EN);\r\nREG_WRITE(ah, AR_TSFOOR_THRESHOLD, bs->bs_tsfoor_threshold);\r\n}\r\nstatic u8 fixup_chainmask(u8 chip_chainmask, u8 eeprom_chainmask)\r\n{\r\neeprom_chainmask &= chip_chainmask;\r\nif (eeprom_chainmask)\r\nreturn eeprom_chainmask;\r\nelse\r\nreturn chip_chainmask;\r\n}\r\nstatic bool ath9k_hw_dfs_tested(struct ath_hw *ah)\r\n{\r\nswitch (ah->hw_version.macVersion) {\r\ncase AR_SREV_VERSION_9280:\r\ncase AR_SREV_VERSION_9580:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic void ath9k_gpio_cap_init(struct ath_hw *ah)\r\n{\r\nstruct ath9k_hw_capabilities *pCap = &ah->caps;\r\nif (AR_SREV_9271(ah)) {\r\npCap->num_gpio_pins = AR9271_NUM_GPIO;\r\npCap->gpio_mask = AR9271_GPIO_MASK;\r\n} else if (AR_DEVID_7010(ah)) {\r\npCap->num_gpio_pins = AR7010_NUM_GPIO;\r\npCap->gpio_mask = AR7010_GPIO_MASK;\r\n} else if (AR_SREV_9287(ah)) {\r\npCap->num_gpio_pins = AR9287_NUM_GPIO;\r\npCap->gpio_mask = AR9287_GPIO_MASK;\r\n} else if (AR_SREV_9285(ah)) {\r\npCap->num_gpio_pins = AR9285_NUM_GPIO;\r\npCap->gpio_mask = AR9285_GPIO_MASK;\r\n} else if (AR_SREV_9280(ah)) {\r\npCap->num_gpio_pins = AR9280_NUM_GPIO;\r\npCap->gpio_mask = AR9280_GPIO_MASK;\r\n} else if (AR_SREV_9300(ah)) {\r\npCap->num_gpio_pins = AR9300_NUM_GPIO;\r\npCap->gpio_mask = AR9300_GPIO_MASK;\r\n} else if (AR_SREV_9330(ah)) {\r\npCap->num_gpio_pins = AR9330_NUM_GPIO;\r\npCap->gpio_mask = AR9330_GPIO_MASK;\r\n} else if (AR_SREV_9340(ah)) {\r\npCap->num_gpio_pins = AR9340_NUM_GPIO;\r\npCap->gpio_mask = AR9340_GPIO_MASK;\r\n} else if (AR_SREV_9462(ah)) {\r\npCap->num_gpio_pins = AR9462_NUM_GPIO;\r\npCap->gpio_mask = AR9462_GPIO_MASK;\r\n} else if (AR_SREV_9485(ah)) {\r\npCap->num_gpio_pins = AR9485_NUM_GPIO;\r\npCap->gpio_mask = AR9485_GPIO_MASK;\r\n} else if (AR_SREV_9531(ah)) {\r\npCap->num_gpio_pins = AR9531_NUM_GPIO;\r\npCap->gpio_mask = AR9531_GPIO_MASK;\r\n} else if (AR_SREV_9550(ah)) {\r\npCap->num_gpio_pins = AR9550_NUM_GPIO;\r\npCap->gpio_mask = AR9550_GPIO_MASK;\r\n} else if (AR_SREV_9561(ah)) {\r\npCap->num_gpio_pins = AR9561_NUM_GPIO;\r\npCap->gpio_mask = AR9561_GPIO_MASK;\r\n} else if (AR_SREV_9565(ah)) {\r\npCap->num_gpio_pins = AR9565_NUM_GPIO;\r\npCap->gpio_mask = AR9565_GPIO_MASK;\r\n} else if (AR_SREV_9580(ah)) {\r\npCap->num_gpio_pins = AR9580_NUM_GPIO;\r\npCap->gpio_mask = AR9580_GPIO_MASK;\r\n} else {\r\npCap->num_gpio_pins = AR_NUM_GPIO;\r\npCap->gpio_mask = AR_GPIO_MASK;\r\n}\r\n}\r\nint ath9k_hw_fill_cap_info(struct ath_hw *ah)\r\n{\r\nstruct ath9k_hw_capabilities *pCap = &ah->caps;\r\nstruct ath_regulatory *regulatory = ath9k_hw_regulatory(ah);\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nu16 eeval;\r\nu8 ant_div_ctl1, tx_chainmask, rx_chainmask;\r\neeval = ah->eep_ops->get_eeprom(ah, EEP_REG_0);\r\nregulatory->current_rd = eeval;\r\nif (ah->opmode != NL80211_IFTYPE_AP &&\r\nah->hw_version.subvendorid == AR_SUBVENDOR_ID_NEW_A) {\r\nif (regulatory->current_rd == 0x64 ||\r\nregulatory->current_rd == 0x65)\r\nregulatory->current_rd += 5;\r\nelse if (regulatory->current_rd == 0x41)\r\nregulatory->current_rd = 0x43;\r\nath_dbg(common, REGULATORY, "regdomain mapped to 0x%x\n",\r\nregulatory->current_rd);\r\n}\r\neeval = ah->eep_ops->get_eeprom(ah, EEP_OP_MODE);\r\nif (eeval & AR5416_OPFLAGS_11A) {\r\nif (ah->disable_5ghz)\r\nath_warn(common, "disabling 5GHz band\n");\r\nelse\r\npCap->hw_caps |= ATH9K_HW_CAP_5GHZ;\r\n}\r\nif (eeval & AR5416_OPFLAGS_11G) {\r\nif (ah->disable_2ghz)\r\nath_warn(common, "disabling 2GHz band\n");\r\nelse\r\npCap->hw_caps |= ATH9K_HW_CAP_2GHZ;\r\n}\r\nif ((pCap->hw_caps & (ATH9K_HW_CAP_2GHZ | ATH9K_HW_CAP_5GHZ)) == 0) {\r\nath_err(common, "both bands are disabled\n");\r\nreturn -EINVAL;\r\n}\r\nath9k_gpio_cap_init(ah);\r\nif (AR_SREV_9485(ah) ||\r\nAR_SREV_9285(ah) ||\r\nAR_SREV_9330(ah) ||\r\nAR_SREV_9565(ah))\r\npCap->chip_chainmask = 1;\r\nelse if (!AR_SREV_9280_20_OR_LATER(ah))\r\npCap->chip_chainmask = 7;\r\nelse if (!AR_SREV_9300_20_OR_LATER(ah) ||\r\nAR_SREV_9340(ah) ||\r\nAR_SREV_9462(ah) ||\r\nAR_SREV_9531(ah))\r\npCap->chip_chainmask = 3;\r\nelse\r\npCap->chip_chainmask = 7;\r\npCap->tx_chainmask = ah->eep_ops->get_eeprom(ah, EEP_TX_MASK);\r\nif ((ah->hw_version.devid == AR5416_DEVID_PCI) &&\r\n!(eeval & AR5416_OPFLAGS_11A) &&\r\n!(AR_SREV_9271(ah)))\r\npCap->rx_chainmask = ath9k_hw_gpio_get(ah, 0) ? 0x5 : 0x7;\r\nelse if (AR_SREV_9100(ah))\r\npCap->rx_chainmask = 0x7;\r\nelse\r\npCap->rx_chainmask = ah->eep_ops->get_eeprom(ah, EEP_RX_MASK);\r\npCap->tx_chainmask = fixup_chainmask(pCap->chip_chainmask, pCap->tx_chainmask);\r\npCap->rx_chainmask = fixup_chainmask(pCap->chip_chainmask, pCap->rx_chainmask);\r\nah->txchainmask = pCap->tx_chainmask;\r\nah->rxchainmask = pCap->rx_chainmask;\r\nah->misc_mode |= AR_PCU_MIC_NEW_LOC_ENA;\r\nif (AR_SREV_9300_20_OR_LATER(ah))\r\nah->misc_mode |= AR_PCU_ALWAYS_PERFORM_KEYSEARCH;\r\ncommon->crypt_caps |= ATH_CRYPT_CAP_CIPHER_AESCCM;\r\nif (ah->hw_version.devid != AR2427_DEVID_PCIE)\r\npCap->hw_caps |= ATH9K_HW_CAP_HT;\r\nelse\r\npCap->hw_caps &= ~ATH9K_HW_CAP_HT;\r\nif (AR_SREV_9160_10_OR_LATER(ah) || AR_SREV_9100(ah))\r\npCap->rts_aggr_limit = ATH_AMPDU_LIMIT_MAX;\r\nelse\r\npCap->rts_aggr_limit = (8 * 1024);\r\n#ifdef CONFIG_ATH9K_RFKILL\r\nah->rfsilent = ah->eep_ops->get_eeprom(ah, EEP_RF_SILENT);\r\nif (ah->rfsilent & EEP_RFSILENT_ENABLED) {\r\nah->rfkill_gpio =\r\nMS(ah->rfsilent, EEP_RFSILENT_GPIO_SEL);\r\nah->rfkill_polarity =\r\nMS(ah->rfsilent, EEP_RFSILENT_POLARITY);\r\npCap->hw_caps |= ATH9K_HW_CAP_RFSILENT;\r\n}\r\n#endif\r\nif (AR_SREV_9271(ah) || AR_SREV_9300_20_OR_LATER(ah))\r\npCap->hw_caps |= ATH9K_HW_CAP_AUTOSLEEP;\r\nelse\r\npCap->hw_caps &= ~ATH9K_HW_CAP_AUTOSLEEP;\r\nif (AR_SREV_9280(ah) || AR_SREV_9285(ah))\r\npCap->hw_caps &= ~ATH9K_HW_CAP_4KB_SPLITTRANS;\r\nelse\r\npCap->hw_caps |= ATH9K_HW_CAP_4KB_SPLITTRANS;\r\nif (AR_SREV_9300_20_OR_LATER(ah)) {\r\npCap->hw_caps |= ATH9K_HW_CAP_EDMA | ATH9K_HW_CAP_FASTCLOCK;\r\nif (!AR_SREV_9330(ah) && !AR_SREV_9485(ah) &&\r\n!AR_SREV_9561(ah) && !AR_SREV_9565(ah))\r\npCap->hw_caps |= ATH9K_HW_CAP_LDPC;\r\npCap->rx_hp_qdepth = ATH9K_HW_RX_HP_QDEPTH;\r\npCap->rx_lp_qdepth = ATH9K_HW_RX_LP_QDEPTH;\r\npCap->rx_status_len = sizeof(struct ar9003_rxs);\r\npCap->tx_desc_len = sizeof(struct ar9003_txc);\r\npCap->txs_len = sizeof(struct ar9003_txs);\r\n} else {\r\npCap->tx_desc_len = sizeof(struct ath_desc);\r\nif (AR_SREV_9280_20(ah))\r\npCap->hw_caps |= ATH9K_HW_CAP_FASTCLOCK;\r\n}\r\nif (AR_SREV_9300_20_OR_LATER(ah))\r\npCap->hw_caps |= ATH9K_HW_CAP_RAC_SUPPORTED;\r\nif (AR_SREV_9561(ah))\r\nah->ent_mode = 0x3BDA000;\r\nelse if (AR_SREV_9300_20_OR_LATER(ah))\r\nah->ent_mode = REG_READ(ah, AR_ENT_OTP);\r\nif (AR_SREV_9287_11_OR_LATER(ah) || AR_SREV_9271(ah))\r\npCap->hw_caps |= ATH9K_HW_CAP_SGI_20;\r\nif (AR_SREV_9285(ah)) {\r\nif (ah->eep_ops->get_eeprom(ah, EEP_MODAL_VER) >= 3) {\r\nant_div_ctl1 =\r\nah->eep_ops->get_eeprom(ah, EEP_ANT_DIV_CTL1);\r\nif ((ant_div_ctl1 & 0x1) && ((ant_div_ctl1 >> 3) & 0x1)) {\r\npCap->hw_caps |= ATH9K_HW_CAP_ANT_DIV_COMB;\r\nath_info(common, "Enable LNA combining\n");\r\n}\r\n}\r\n}\r\nif (AR_SREV_9300_20_OR_LATER(ah)) {\r\nif (ah->eep_ops->get_eeprom(ah, EEP_CHAIN_MASK_REDUCE))\r\npCap->hw_caps |= ATH9K_HW_CAP_APM;\r\n}\r\nif (AR_SREV_9330(ah) || AR_SREV_9485(ah) || AR_SREV_9565(ah)) {\r\nant_div_ctl1 = ah->eep_ops->get_eeprom(ah, EEP_ANT_DIV_CTL1);\r\nif ((ant_div_ctl1 >> 0x6) == 0x3) {\r\npCap->hw_caps |= ATH9K_HW_CAP_ANT_DIV_COMB;\r\nath_info(common, "Enable LNA combining\n");\r\n}\r\n}\r\nif (ath9k_hw_dfs_tested(ah))\r\npCap->hw_caps |= ATH9K_HW_CAP_DFS;\r\ntx_chainmask = pCap->tx_chainmask;\r\nrx_chainmask = pCap->rx_chainmask;\r\nwhile (tx_chainmask || rx_chainmask) {\r\nif (tx_chainmask & BIT(0))\r\npCap->max_txchains++;\r\nif (rx_chainmask & BIT(0))\r\npCap->max_rxchains++;\r\ntx_chainmask >>= 1;\r\nrx_chainmask >>= 1;\r\n}\r\nif (AR_SREV_9462(ah) || AR_SREV_9565(ah)) {\r\nif (!(ah->ent_mode & AR_ENT_OTP_49GHZ_DISABLE))\r\npCap->hw_caps |= ATH9K_HW_CAP_MCI;\r\nif (AR_SREV_9462_20_OR_LATER(ah))\r\npCap->hw_caps |= ATH9K_HW_CAP_RTT;\r\n}\r\nif (AR_SREV_9300_20_OR_LATER(ah) &&\r\nah->eep_ops->get_eeprom(ah, EEP_PAPRD))\r\npCap->hw_caps |= ATH9K_HW_CAP_PAPRD;\r\n#ifdef CONFIG_ATH9K_WOW\r\nif (AR_SREV_9462_20_OR_LATER(ah) || AR_SREV_9565_11_OR_LATER(ah))\r\nah->wow.max_patterns = MAX_NUM_PATTERN;\r\nelse\r\nah->wow.max_patterns = MAX_NUM_PATTERN_LEGACY;\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void ath9k_hw_gpio_cfg_output_mux(struct ath_hw *ah, u32 gpio, u32 type)\r\n{\r\nint addr;\r\nu32 gpio_shift, tmp;\r\nif (gpio > 11)\r\naddr = AR_GPIO_OUTPUT_MUX3;\r\nelse if (gpio > 5)\r\naddr = AR_GPIO_OUTPUT_MUX2;\r\nelse\r\naddr = AR_GPIO_OUTPUT_MUX1;\r\ngpio_shift = (gpio % 6) * 5;\r\nif (AR_SREV_9280_20_OR_LATER(ah) ||\r\n(addr != AR_GPIO_OUTPUT_MUX1)) {\r\nREG_RMW(ah, addr, (type << gpio_shift),\r\n(0x1f << gpio_shift));\r\n} else {\r\ntmp = REG_READ(ah, addr);\r\ntmp = ((tmp & 0x1F0) << 1) | (tmp & ~0x1F0);\r\ntmp &= ~(0x1f << gpio_shift);\r\ntmp |= (type << gpio_shift);\r\nREG_WRITE(ah, addr, tmp);\r\n}\r\n}\r\nstatic void ath9k_hw_gpio_cfg_soc(struct ath_hw *ah, u32 gpio, bool out,\r\nconst char *label)\r\n{\r\nif (ah->caps.gpio_requested & BIT(gpio))\r\nreturn;\r\ngpio_free(gpio);\r\nif (gpio_request_one(gpio, out ? GPIOF_OUT_INIT_LOW : GPIOF_IN, label))\r\nreturn;\r\nah->caps.gpio_requested |= BIT(gpio);\r\n}\r\nstatic void ath9k_hw_gpio_cfg_wmac(struct ath_hw *ah, u32 gpio, bool out,\r\nu32 ah_signal_type)\r\n{\r\nu32 gpio_set, gpio_shift = gpio;\r\nif (AR_DEVID_7010(ah)) {\r\ngpio_set = out ?\r\nAR7010_GPIO_OE_AS_OUTPUT : AR7010_GPIO_OE_AS_INPUT;\r\nREG_RMW(ah, AR7010_GPIO_OE, gpio_set << gpio_shift,\r\nAR7010_GPIO_OE_MASK << gpio_shift);\r\n} else if (AR_SREV_SOC(ah)) {\r\ngpio_set = out ? 1 : 0;\r\nREG_RMW(ah, AR_GPIO_OE_OUT, gpio_set << gpio_shift,\r\ngpio_set << gpio_shift);\r\n} else {\r\ngpio_shift = gpio << 1;\r\ngpio_set = out ?\r\nAR_GPIO_OE_OUT_DRV_ALL : AR_GPIO_OE_OUT_DRV_NO;\r\nREG_RMW(ah, AR_GPIO_OE_OUT, gpio_set << gpio_shift,\r\nAR_GPIO_OE_OUT_DRV << gpio_shift);\r\nif (out)\r\nath9k_hw_gpio_cfg_output_mux(ah, gpio, ah_signal_type);\r\n}\r\n}\r\nstatic void ath9k_hw_gpio_request(struct ath_hw *ah, u32 gpio, bool out,\r\nconst char *label, u32 ah_signal_type)\r\n{\r\nWARN_ON(gpio >= ah->caps.num_gpio_pins);\r\nif (BIT(gpio) & ah->caps.gpio_mask)\r\nath9k_hw_gpio_cfg_wmac(ah, gpio, out, ah_signal_type);\r\nelse if (AR_SREV_SOC(ah))\r\nath9k_hw_gpio_cfg_soc(ah, gpio, out, label);\r\nelse\r\nWARN_ON(1);\r\n}\r\nvoid ath9k_hw_gpio_request_in(struct ath_hw *ah, u32 gpio, const char *label)\r\n{\r\nath9k_hw_gpio_request(ah, gpio, false, label, 0);\r\n}\r\nvoid ath9k_hw_gpio_request_out(struct ath_hw *ah, u32 gpio, const char *label,\r\nu32 ah_signal_type)\r\n{\r\nath9k_hw_gpio_request(ah, gpio, true, label, ah_signal_type);\r\n}\r\nvoid ath9k_hw_gpio_free(struct ath_hw *ah, u32 gpio)\r\n{\r\nif (!AR_SREV_SOC(ah))\r\nreturn;\r\nWARN_ON(gpio >= ah->caps.num_gpio_pins);\r\nif (ah->caps.gpio_requested & BIT(gpio)) {\r\ngpio_free(gpio);\r\nah->caps.gpio_requested &= ~BIT(gpio);\r\n}\r\n}\r\nu32 ath9k_hw_gpio_get(struct ath_hw *ah, u32 gpio)\r\n{\r\nu32 val = 0xffffffff;\r\n#define MS_REG_READ(x, y) \\r\n(MS(REG_READ(ah, AR_GPIO_IN_OUT), x##_GPIO_IN_VAL) & BIT(y))\r\nWARN_ON(gpio >= ah->caps.num_gpio_pins);\r\nif (BIT(gpio) & ah->caps.gpio_mask) {\r\nif (AR_SREV_9271(ah))\r\nval = MS_REG_READ(AR9271, gpio);\r\nelse if (AR_SREV_9287(ah))\r\nval = MS_REG_READ(AR9287, gpio);\r\nelse if (AR_SREV_9285(ah))\r\nval = MS_REG_READ(AR9285, gpio);\r\nelse if (AR_SREV_9280(ah))\r\nval = MS_REG_READ(AR928X, gpio);\r\nelse if (AR_DEVID_7010(ah))\r\nval = REG_READ(ah, AR7010_GPIO_IN) & BIT(gpio);\r\nelse if (AR_SREV_9300_20_OR_LATER(ah))\r\nval = REG_READ(ah, AR_GPIO_IN) & BIT(gpio);\r\nelse\r\nval = MS_REG_READ(AR, gpio);\r\n} else if (BIT(gpio) & ah->caps.gpio_requested) {\r\nval = gpio_get_value(gpio) & BIT(gpio);\r\n} else {\r\nWARN_ON(1);\r\n}\r\nreturn !!val;\r\n}\r\nvoid ath9k_hw_set_gpio(struct ath_hw *ah, u32 gpio, u32 val)\r\n{\r\nWARN_ON(gpio >= ah->caps.num_gpio_pins);\r\nif (AR_DEVID_7010(ah) || AR_SREV_9271(ah))\r\nval = !val;\r\nelse\r\nval = !!val;\r\nif (BIT(gpio) & ah->caps.gpio_mask) {\r\nu32 out_addr = AR_DEVID_7010(ah) ?\r\nAR7010_GPIO_OUT : AR_GPIO_IN_OUT;\r\nREG_RMW(ah, out_addr, val << gpio, BIT(gpio));\r\n} else if (BIT(gpio) & ah->caps.gpio_requested) {\r\ngpio_set_value(gpio, val);\r\n} else {\r\nWARN_ON(1);\r\n}\r\n}\r\nvoid ath9k_hw_setantenna(struct ath_hw *ah, u32 antenna)\r\n{\r\nREG_WRITE(ah, AR_DEF_ANTENNA, (antenna & 0x7));\r\n}\r\nu32 ath9k_hw_getrxfilter(struct ath_hw *ah)\r\n{\r\nu32 bits = REG_READ(ah, AR_RX_FILTER);\r\nu32 phybits = REG_READ(ah, AR_PHY_ERR);\r\nif (phybits & AR_PHY_ERR_RADAR)\r\nbits |= ATH9K_RX_FILTER_PHYRADAR;\r\nif (phybits & (AR_PHY_ERR_OFDM_TIMING | AR_PHY_ERR_CCK_TIMING))\r\nbits |= ATH9K_RX_FILTER_PHYERR;\r\nreturn bits;\r\n}\r\nvoid ath9k_hw_setrxfilter(struct ath_hw *ah, u32 bits)\r\n{\r\nu32 phybits;\r\nENABLE_REGWRITE_BUFFER(ah);\r\nREG_WRITE(ah, AR_RX_FILTER, bits);\r\nphybits = 0;\r\nif (bits & ATH9K_RX_FILTER_PHYRADAR)\r\nphybits |= AR_PHY_ERR_RADAR;\r\nif (bits & ATH9K_RX_FILTER_PHYERR)\r\nphybits |= AR_PHY_ERR_OFDM_TIMING | AR_PHY_ERR_CCK_TIMING;\r\nREG_WRITE(ah, AR_PHY_ERR, phybits);\r\nif (phybits)\r\nREG_SET_BIT(ah, AR_RXCFG, AR_RXCFG_ZLFDMA);\r\nelse\r\nREG_CLR_BIT(ah, AR_RXCFG, AR_RXCFG_ZLFDMA);\r\nREGWRITE_BUFFER_FLUSH(ah);\r\n}\r\nbool ath9k_hw_phy_disable(struct ath_hw *ah)\r\n{\r\nif (ath9k_hw_mci_is_enabled(ah))\r\nar9003_mci_bt_gain_ctrl(ah);\r\nif (!ath9k_hw_set_reset_reg(ah, ATH9K_RESET_WARM))\r\nreturn false;\r\nath9k_hw_init_pll(ah, NULL);\r\nah->htc_reset_init = true;\r\nreturn true;\r\n}\r\nbool ath9k_hw_disable(struct ath_hw *ah)\r\n{\r\nif (!ath9k_hw_setpower(ah, ATH9K_PM_AWAKE))\r\nreturn false;\r\nif (!ath9k_hw_set_reset_reg(ah, ATH9K_RESET_COLD))\r\nreturn false;\r\nath9k_hw_init_pll(ah, NULL);\r\nreturn true;\r\n}\r\nstatic int get_antenna_gain(struct ath_hw *ah, struct ath9k_channel *chan)\r\n{\r\nenum eeprom_param gain_param;\r\nif (IS_CHAN_2GHZ(chan))\r\ngain_param = EEP_ANTENNA_GAIN_2G;\r\nelse\r\ngain_param = EEP_ANTENNA_GAIN_5G;\r\nreturn ah->eep_ops->get_eeprom(ah, gain_param);\r\n}\r\nvoid ath9k_hw_apply_txpower(struct ath_hw *ah, struct ath9k_channel *chan,\r\nbool test)\r\n{\r\nstruct ath_regulatory *reg = ath9k_hw_regulatory(ah);\r\nstruct ieee80211_channel *channel;\r\nint chan_pwr, new_pwr;\r\nif (!chan)\r\nreturn;\r\nchannel = chan->chan;\r\nchan_pwr = min_t(int, channel->max_power * 2, MAX_RATE_POWER);\r\nnew_pwr = min_t(int, chan_pwr, reg->power_limit);\r\nah->eep_ops->set_txpower(ah, chan,\r\nath9k_regd_get_ctl(reg, chan),\r\nget_antenna_gain(ah, chan), new_pwr, test);\r\n}\r\nvoid ath9k_hw_set_txpowerlimit(struct ath_hw *ah, u32 limit, bool test)\r\n{\r\nstruct ath_regulatory *reg = ath9k_hw_regulatory(ah);\r\nstruct ath9k_channel *chan = ah->curchan;\r\nstruct ieee80211_channel *channel = chan->chan;\r\nreg->power_limit = min_t(u32, limit, MAX_RATE_POWER);\r\nif (test)\r\nchannel->max_power = MAX_RATE_POWER / 2;\r\nath9k_hw_apply_txpower(ah, chan, test);\r\nif (test)\r\nchannel->max_power = DIV_ROUND_UP(reg->max_power_level, 2);\r\n}\r\nvoid ath9k_hw_setopmode(struct ath_hw *ah)\r\n{\r\nath9k_hw_set_operating_mode(ah, ah->opmode);\r\n}\r\nvoid ath9k_hw_setmcastfilter(struct ath_hw *ah, u32 filter0, u32 filter1)\r\n{\r\nREG_WRITE(ah, AR_MCAST_FIL0, filter0);\r\nREG_WRITE(ah, AR_MCAST_FIL1, filter1);\r\n}\r\nvoid ath9k_hw_write_associd(struct ath_hw *ah)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nREG_WRITE(ah, AR_BSS_ID0, get_unaligned_le32(common->curbssid));\r\nREG_WRITE(ah, AR_BSS_ID1, get_unaligned_le16(common->curbssid + 4) |\r\n((common->curaid & 0x3fff) << AR_BSS_ID1_AID_S));\r\n}\r\nu64 ath9k_hw_gettsf64(struct ath_hw *ah)\r\n{\r\nu32 tsf_lower, tsf_upper1, tsf_upper2;\r\nint i;\r\ntsf_upper1 = REG_READ(ah, AR_TSF_U32);\r\nfor (i = 0; i < ATH9K_MAX_TSF_READ; i++) {\r\ntsf_lower = REG_READ(ah, AR_TSF_L32);\r\ntsf_upper2 = REG_READ(ah, AR_TSF_U32);\r\nif (tsf_upper2 == tsf_upper1)\r\nbreak;\r\ntsf_upper1 = tsf_upper2;\r\n}\r\nWARN_ON( i == ATH9K_MAX_TSF_READ );\r\nreturn (((u64)tsf_upper1 << 32) | tsf_lower);\r\n}\r\nvoid ath9k_hw_settsf64(struct ath_hw *ah, u64 tsf64)\r\n{\r\nREG_WRITE(ah, AR_TSF_L32, tsf64 & 0xffffffff);\r\nREG_WRITE(ah, AR_TSF_U32, (tsf64 >> 32) & 0xffffffff);\r\n}\r\nvoid ath9k_hw_reset_tsf(struct ath_hw *ah)\r\n{\r\nif (!ath9k_hw_wait(ah, AR_SLP32_MODE, AR_SLP32_TSF_WRITE_STATUS, 0,\r\nAH_TSF_WRITE_TIMEOUT))\r\nath_dbg(ath9k_hw_common(ah), RESET,\r\n"AR_SLP32_TSF_WRITE_STATUS limit exceeded\n");\r\nREG_WRITE(ah, AR_RESET_TSF, AR_RESET_TSF_ONCE);\r\n}\r\nvoid ath9k_hw_set_tsfadjust(struct ath_hw *ah, bool set)\r\n{\r\nif (set)\r\nah->misc_mode |= AR_PCU_TX_ADD_TSF;\r\nelse\r\nah->misc_mode &= ~AR_PCU_TX_ADD_TSF;\r\n}\r\nvoid ath9k_hw_set11nmac2040(struct ath_hw *ah, struct ath9k_channel *chan)\r\n{\r\nu32 macmode;\r\nif (IS_CHAN_HT40(chan) && !ah->config.cwm_ignore_extcca)\r\nmacmode = AR_2040_JOINED_RX_CLEAR;\r\nelse\r\nmacmode = 0;\r\nREG_WRITE(ah, AR_2040_MODE, macmode);\r\n}\r\nu32 ath9k_hw_gettsf32(struct ath_hw *ah)\r\n{\r\nreturn REG_READ(ah, AR_TSF_L32);\r\n}\r\nvoid ath9k_hw_gen_timer_start_tsf2(struct ath_hw *ah)\r\n{\r\nstruct ath_gen_timer_table *timer_table = &ah->hw_gen_timers;\r\nif (timer_table->tsf2_enabled) {\r\nREG_SET_BIT(ah, AR_DIRECT_CONNECT, AR_DC_AP_STA_EN);\r\nREG_SET_BIT(ah, AR_RESET_TSF, AR_RESET_TSF2_ONCE);\r\n}\r\n}\r\nstruct ath_gen_timer *ath_gen_timer_alloc(struct ath_hw *ah,\r\nvoid (*trigger)(void *),\r\nvoid (*overflow)(void *),\r\nvoid *arg,\r\nu8 timer_index)\r\n{\r\nstruct ath_gen_timer_table *timer_table = &ah->hw_gen_timers;\r\nstruct ath_gen_timer *timer;\r\nif ((timer_index < AR_FIRST_NDP_TIMER) ||\r\n(timer_index >= ATH_MAX_GEN_TIMER))\r\nreturn NULL;\r\nif ((timer_index > AR_FIRST_NDP_TIMER) &&\r\n!AR_SREV_9300_20_OR_LATER(ah))\r\nreturn NULL;\r\ntimer = kzalloc(sizeof(struct ath_gen_timer), GFP_KERNEL);\r\nif (timer == NULL)\r\nreturn NULL;\r\ntimer_table->timers[timer_index] = timer;\r\ntimer->index = timer_index;\r\ntimer->trigger = trigger;\r\ntimer->overflow = overflow;\r\ntimer->arg = arg;\r\nif ((timer_index > AR_FIRST_NDP_TIMER) && !timer_table->tsf2_enabled) {\r\ntimer_table->tsf2_enabled = true;\r\nath9k_hw_gen_timer_start_tsf2(ah);\r\n}\r\nreturn timer;\r\n}\r\nvoid ath9k_hw_gen_timer_start(struct ath_hw *ah,\r\nstruct ath_gen_timer *timer,\r\nu32 timer_next,\r\nu32 timer_period)\r\n{\r\nstruct ath_gen_timer_table *timer_table = &ah->hw_gen_timers;\r\nu32 mask = 0;\r\ntimer_table->timer_mask |= BIT(timer->index);\r\nREG_WRITE(ah, gen_tmr_configuration[timer->index].next_addr,\r\ntimer_next);\r\nREG_WRITE(ah, gen_tmr_configuration[timer->index].period_addr,\r\ntimer_period);\r\nREG_SET_BIT(ah, gen_tmr_configuration[timer->index].mode_addr,\r\ngen_tmr_configuration[timer->index].mode_mask);\r\nif (AR_SREV_9462(ah) || AR_SREV_9565(ah)) {\r\nif ((timer->index < AR_GEN_TIMER_BANK_1_LEN))\r\nREG_CLR_BIT(ah, AR_MAC_PCU_GEN_TIMER_TSF_SEL,\r\n(1 << timer->index));\r\nelse\r\nREG_SET_BIT(ah, AR_MAC_PCU_GEN_TIMER_TSF_SEL,\r\n(1 << timer->index));\r\n}\r\nif (timer->trigger)\r\nmask |= SM(AR_GENTMR_BIT(timer->index),\r\nAR_IMR_S5_GENTIMER_TRIG);\r\nif (timer->overflow)\r\nmask |= SM(AR_GENTMR_BIT(timer->index),\r\nAR_IMR_S5_GENTIMER_THRESH);\r\nREG_SET_BIT(ah, AR_IMR_S5, mask);\r\nif ((ah->imask & ATH9K_INT_GENTIMER) == 0) {\r\nah->imask |= ATH9K_INT_GENTIMER;\r\nath9k_hw_set_interrupts(ah);\r\n}\r\n}\r\nvoid ath9k_hw_gen_timer_stop(struct ath_hw *ah, struct ath_gen_timer *timer)\r\n{\r\nstruct ath_gen_timer_table *timer_table = &ah->hw_gen_timers;\r\nREG_CLR_BIT(ah, gen_tmr_configuration[timer->index].mode_addr,\r\ngen_tmr_configuration[timer->index].mode_mask);\r\nif (AR_SREV_9462(ah) || AR_SREV_9565(ah)) {\r\nif ((timer->index >= AR_GEN_TIMER_BANK_1_LEN)) {\r\nREG_CLR_BIT(ah, AR_MAC_PCU_GEN_TIMER_TSF_SEL,\r\n(1 << timer->index));\r\n}\r\n}\r\nREG_CLR_BIT(ah, AR_IMR_S5,\r\n(SM(AR_GENTMR_BIT(timer->index), AR_IMR_S5_GENTIMER_THRESH) |\r\nSM(AR_GENTMR_BIT(timer->index), AR_IMR_S5_GENTIMER_TRIG)));\r\ntimer_table->timer_mask &= ~BIT(timer->index);\r\nif (timer_table->timer_mask == 0) {\r\nah->imask &= ~ATH9K_INT_GENTIMER;\r\nath9k_hw_set_interrupts(ah);\r\n}\r\n}\r\nvoid ath_gen_timer_free(struct ath_hw *ah, struct ath_gen_timer *timer)\r\n{\r\nstruct ath_gen_timer_table *timer_table = &ah->hw_gen_timers;\r\ntimer_table->timers[timer->index] = NULL;\r\nkfree(timer);\r\n}\r\nvoid ath_gen_timer_isr(struct ath_hw *ah)\r\n{\r\nstruct ath_gen_timer_table *timer_table = &ah->hw_gen_timers;\r\nstruct ath_gen_timer *timer;\r\nunsigned long trigger_mask, thresh_mask;\r\nunsigned int index;\r\ntrigger_mask = ah->intr_gen_timer_trigger;\r\nthresh_mask = ah->intr_gen_timer_thresh;\r\ntrigger_mask &= timer_table->timer_mask;\r\nthresh_mask &= timer_table->timer_mask;\r\nfor_each_set_bit(index, &thresh_mask, ARRAY_SIZE(timer_table->timers)) {\r\ntimer = timer_table->timers[index];\r\nif (!timer)\r\ncontinue;\r\nif (!timer->overflow)\r\ncontinue;\r\ntrigger_mask &= ~BIT(index);\r\ntimer->overflow(timer->arg);\r\n}\r\nfor_each_set_bit(index, &trigger_mask, ARRAY_SIZE(timer_table->timers)) {\r\ntimer = timer_table->timers[index];\r\nif (!timer)\r\ncontinue;\r\nif (!timer->trigger)\r\ncontinue;\r\ntimer->trigger(timer->arg);\r\n}\r\n}\r\nstatic const char *ath9k_hw_mac_bb_name(u32 mac_bb_version)\r\n{\r\nint i;\r\nfor (i=0; i<ARRAY_SIZE(ath_mac_bb_names); i++) {\r\nif (ath_mac_bb_names[i].version == mac_bb_version) {\r\nreturn ath_mac_bb_names[i].name;\r\n}\r\n}\r\nreturn "????";\r\n}\r\nstatic const char *ath9k_hw_rf_name(u16 rf_version)\r\n{\r\nint i;\r\nfor (i=0; i<ARRAY_SIZE(ath_rf_names); i++) {\r\nif (ath_rf_names[i].version == rf_version) {\r\nreturn ath_rf_names[i].name;\r\n}\r\n}\r\nreturn "????";\r\n}\r\nvoid ath9k_hw_name(struct ath_hw *ah, char *hw_name, size_t len)\r\n{\r\nint used;\r\nif (AR_SREV_9280_20_OR_LATER(ah)) {\r\nused = scnprintf(hw_name, len,\r\n"Atheros AR%s Rev:%x",\r\nath9k_hw_mac_bb_name(ah->hw_version.macVersion),\r\nah->hw_version.macRev);\r\n}\r\nelse {\r\nused = scnprintf(hw_name, len,\r\n"Atheros AR%s MAC/BB Rev:%x AR%s RF Rev:%x",\r\nath9k_hw_mac_bb_name(ah->hw_version.macVersion),\r\nah->hw_version.macRev,\r\nath9k_hw_rf_name((ah->hw_version.analog5GhzRev\r\n& AR_RADIO_SREV_MAJOR)),\r\nah->hw_version.phyRev);\r\n}\r\nhw_name[used] = '\0';\r\n}
