static irqreturn_t ppi_irq_err(int irq, void *dev_id)\r\n{\r\nstruct ppi_if *ppi = dev_id;\r\nconst struct ppi_info *info = ppi->info;\r\nswitch (info->type) {\r\ncase PPI_TYPE_PPI:\r\n{\r\nstruct bfin_ppi_regs *reg = info->base;\r\nunsigned short status;\r\nstatus = bfin_read16(&reg->status);\r\nif (status & 0x3000)\r\nppi->err = true;\r\nbfin_write16(&reg->status, 0xff00);\r\nbreak;\r\n}\r\ncase PPI_TYPE_EPPI:\r\n{\r\nstruct bfin_eppi_regs *reg = info->base;\r\nunsigned short status;\r\nstatus = bfin_read16(&reg->status);\r\nif (status & 0x2)\r\nppi->err = true;\r\nbfin_write16(&reg->status, 0xffff);\r\nbreak;\r\n}\r\ncase PPI_TYPE_EPPI3:\r\n{\r\nstruct bfin_eppi3_regs *reg = info->base;\r\nunsigned long stat;\r\nstat = bfin_read32(&reg->stat);\r\nif (stat & 0x2)\r\nppi->err = true;\r\nbfin_write32(&reg->stat, 0xc0ff);\r\nbreak;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ppi_attach_irq(struct ppi_if *ppi, irq_handler_t handler)\r\n{\r\nconst struct ppi_info *info = ppi->info;\r\nint ret;\r\nret = request_dma(info->dma_ch, "PPI_DMA");\r\nif (ret) {\r\npr_err("Unable to allocate DMA channel for PPI\n");\r\nreturn ret;\r\n}\r\nset_dma_callback(info->dma_ch, handler, ppi);\r\nif (ppi->err_int) {\r\nret = request_irq(info->irq_err, ppi_irq_err, 0, "PPI ERROR", ppi);\r\nif (ret) {\r\npr_err("Unable to allocate IRQ for PPI\n");\r\nfree_dma(info->dma_ch);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void ppi_detach_irq(struct ppi_if *ppi)\r\n{\r\nconst struct ppi_info *info = ppi->info;\r\nif (ppi->err_int)\r\nfree_irq(info->irq_err, ppi);\r\nfree_dma(info->dma_ch);\r\n}\r\nstatic int ppi_start(struct ppi_if *ppi)\r\n{\r\nconst struct ppi_info *info = ppi->info;\r\nenable_dma(info->dma_ch);\r\nppi->ppi_control |= PORT_EN;\r\nswitch (info->type) {\r\ncase PPI_TYPE_PPI:\r\n{\r\nstruct bfin_ppi_regs *reg = info->base;\r\nbfin_write16(&reg->control, ppi->ppi_control);\r\nbreak;\r\n}\r\ncase PPI_TYPE_EPPI:\r\n{\r\nstruct bfin_eppi_regs *reg = info->base;\r\nbfin_write32(&reg->control, ppi->ppi_control);\r\nbreak;\r\n}\r\ncase PPI_TYPE_EPPI3:\r\n{\r\nstruct bfin_eppi3_regs *reg = info->base;\r\nbfin_write32(&reg->ctl, ppi->ppi_control);\r\nbreak;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nSSYNC();\r\nreturn 0;\r\n}\r\nstatic int ppi_stop(struct ppi_if *ppi)\r\n{\r\nconst struct ppi_info *info = ppi->info;\r\nppi->ppi_control &= ~PORT_EN;\r\nswitch (info->type) {\r\ncase PPI_TYPE_PPI:\r\n{\r\nstruct bfin_ppi_regs *reg = info->base;\r\nbfin_write16(&reg->control, ppi->ppi_control);\r\nbreak;\r\n}\r\ncase PPI_TYPE_EPPI:\r\n{\r\nstruct bfin_eppi_regs *reg = info->base;\r\nbfin_write32(&reg->control, ppi->ppi_control);\r\nbreak;\r\n}\r\ncase PPI_TYPE_EPPI3:\r\n{\r\nstruct bfin_eppi3_regs *reg = info->base;\r\nbfin_write32(&reg->ctl, ppi->ppi_control);\r\nbreak;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nclear_dma_irqstat(info->dma_ch);\r\ndisable_dma(info->dma_ch);\r\nSSYNC();\r\nreturn 0;\r\n}\r\nstatic int ppi_set_params(struct ppi_if *ppi, struct ppi_params *params)\r\n{\r\nconst struct ppi_info *info = ppi->info;\r\nint dma32 = 0;\r\nint dma_config, bytes_per_line;\r\nint hcount, hdelay, samples_per_line;\r\n#ifdef CONFIG_PINCTRL\r\nstatic const char * const pin_state[] = {"8bit", "16bit", "24bit"};\r\nstruct pinctrl *pctrl;\r\nstruct pinctrl_state *pstate;\r\nif (params->dlen > 24 || params->dlen <= 0)\r\nreturn -EINVAL;\r\npctrl = devm_pinctrl_get(ppi->dev);\r\nif (IS_ERR(pctrl))\r\nreturn PTR_ERR(pctrl);\r\npstate = pinctrl_lookup_state(pctrl,\r\npin_state[(params->dlen + 7) / 8 - 1]);\r\nif (pinctrl_select_state(pctrl, pstate))\r\nreturn -EINVAL;\r\n#endif\r\nbytes_per_line = params->width * params->bpp / 8;\r\nhcount = params->width * params->bpp / params->dlen;\r\nhdelay = params->hdelay * params->bpp / params->dlen;\r\nsamples_per_line = params->line * params->bpp / params->dlen;\r\nif (params->int_mask == 0xFFFFFFFF)\r\nppi->err_int = false;\r\nelse\r\nppi->err_int = true;\r\ndma_config = (DMA_FLOW_STOP | RESTART | DMA2D | DI_EN_Y);\r\nppi->ppi_control = params->ppi_control & ~PORT_EN;\r\nif (!(ppi->ppi_control & PORT_DIR))\r\ndma_config |= WNR;\r\nswitch (info->type) {\r\ncase PPI_TYPE_PPI:\r\n{\r\nstruct bfin_ppi_regs *reg = info->base;\r\nif (params->ppi_control & DMA32)\r\ndma32 = 1;\r\nbfin_write16(&reg->control, ppi->ppi_control);\r\nbfin_write16(&reg->count, samples_per_line - 1);\r\nbfin_write16(&reg->frame, params->frame);\r\nbreak;\r\n}\r\ncase PPI_TYPE_EPPI:\r\n{\r\nstruct bfin_eppi_regs *reg = info->base;\r\nif ((params->ppi_control & PACK_EN)\r\n|| (params->ppi_control & 0x38000) > DLEN_16)\r\ndma32 = 1;\r\nbfin_write32(&reg->control, ppi->ppi_control);\r\nbfin_write16(&reg->line, samples_per_line);\r\nbfin_write16(&reg->frame, params->frame);\r\nbfin_write16(&reg->hdelay, hdelay);\r\nbfin_write16(&reg->vdelay, params->vdelay);\r\nbfin_write16(&reg->hcount, hcount);\r\nbfin_write16(&reg->vcount, params->height);\r\nbreak;\r\n}\r\ncase PPI_TYPE_EPPI3:\r\n{\r\nstruct bfin_eppi3_regs *reg = info->base;\r\nif ((params->ppi_control & PACK_EN)\r\n|| (params->ppi_control & 0x70000) > DLEN_16)\r\ndma32 = 1;\r\nbfin_write32(&reg->ctl, ppi->ppi_control);\r\nbfin_write32(&reg->line, samples_per_line);\r\nbfin_write32(&reg->frame, params->frame);\r\nbfin_write32(&reg->hdly, hdelay);\r\nbfin_write32(&reg->vdly, params->vdelay);\r\nbfin_write32(&reg->hcnt, hcount);\r\nbfin_write32(&reg->vcnt, params->height);\r\nif (params->int_mask)\r\nbfin_write32(&reg->imsk, params->int_mask & 0xFF);\r\nif (ppi->ppi_control & PORT_DIR) {\r\nu32 hsync_width, vsync_width, vsync_period;\r\nhsync_width = params->hsync\r\n* params->bpp / params->dlen;\r\nvsync_width = params->vsync * samples_per_line;\r\nvsync_period = samples_per_line * params->frame;\r\nbfin_write32(&reg->fs1_wlhb, hsync_width);\r\nbfin_write32(&reg->fs1_paspl, samples_per_line);\r\nbfin_write32(&reg->fs2_wlvb, vsync_width);\r\nbfin_write32(&reg->fs2_palpf, vsync_period);\r\n}\r\nbreak;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (dma32) {\r\ndma_config |= WDSIZE_32 | PSIZE_32;\r\nset_dma_x_count(info->dma_ch, bytes_per_line >> 2);\r\nset_dma_x_modify(info->dma_ch, 4);\r\nset_dma_y_modify(info->dma_ch, 4);\r\n} else {\r\ndma_config |= WDSIZE_16 | PSIZE_16;\r\nset_dma_x_count(info->dma_ch, bytes_per_line >> 1);\r\nset_dma_x_modify(info->dma_ch, 2);\r\nset_dma_y_modify(info->dma_ch, 2);\r\n}\r\nset_dma_y_count(info->dma_ch, params->height);\r\nset_dma_config(info->dma_ch, dma_config);\r\nSSYNC();\r\nreturn 0;\r\n}\r\nstatic void ppi_update_addr(struct ppi_if *ppi, unsigned long addr)\r\n{\r\nset_dma_start_addr(ppi->info->dma_ch, addr);\r\n}\r\nstruct ppi_if *ppi_create_instance(struct platform_device *pdev,\r\nconst struct ppi_info *info)\r\n{\r\nstruct ppi_if *ppi;\r\nif (!info || !info->pin_req)\r\nreturn NULL;\r\n#ifndef CONFIG_PINCTRL\r\nif (peripheral_request_list(info->pin_req, KBUILD_MODNAME)) {\r\ndev_err(&pdev->dev, "request peripheral failed\n");\r\nreturn NULL;\r\n}\r\n#endif\r\nppi = kzalloc(sizeof(*ppi), GFP_KERNEL);\r\nif (!ppi) {\r\nperipheral_free_list(info->pin_req);\r\ndev_err(&pdev->dev, "unable to allocate memory for ppi handle\n");\r\nreturn NULL;\r\n}\r\nppi->ops = &ppi_ops;\r\nppi->info = info;\r\nppi->dev = &pdev->dev;\r\npr_info("ppi probe success\n");\r\nreturn ppi;\r\n}\r\nvoid ppi_delete_instance(struct ppi_if *ppi)\r\n{\r\nperipheral_free_list(ppi->info->pin_req);\r\nkfree(ppi);\r\n}
