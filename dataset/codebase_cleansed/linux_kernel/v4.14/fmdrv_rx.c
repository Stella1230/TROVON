void fm_rx_reset_rds_cache(struct fmdev *fmdev)\r\n{\r\nfmdev->rx.rds.flag = FM_RDS_DISABLE;\r\nfmdev->rx.rds.last_blk_idx = 0;\r\nfmdev->rx.rds.wr_idx = 0;\r\nfmdev->rx.rds.rd_idx = 0;\r\nif (fmdev->rx.af_mode == FM_RX_RDS_AF_SWITCH_MODE_ON)\r\nfmdev->irq_info.mask |= FM_LEV_EVENT;\r\n}\r\nvoid fm_rx_reset_station_info(struct fmdev *fmdev)\r\n{\r\nfmdev->rx.stat_info.picode = FM_NO_PI_CODE;\r\nfmdev->rx.stat_info.afcache_size = 0;\r\nfmdev->rx.stat_info.af_list_max = 0;\r\n}\r\nint fm_rx_set_freq(struct fmdev *fmdev, u32 freq)\r\n{\r\nunsigned long timeleft;\r\nu16 payload, curr_frq, intr_flag;\r\nu32 curr_frq_in_khz;\r\nu32 resp_len;\r\nint ret;\r\nif (freq < fmdev->rx.region.bot_freq || freq > fmdev->rx.region.top_freq) {\r\nfmerr("Invalid frequency %d\n", freq);\r\nreturn -EINVAL;\r\n}\r\npayload = FM_RX_AUDIO_ENABLE_I2S_AND_ANALOG;\r\nret = fmc_send_cmd(fmdev, AUDIO_ENABLE_SET, REG_WR, &payload,\r\nsizeof(payload), NULL, NULL);\r\nif (ret < 0)\r\nreturn ret;\r\npayload = FM_RX_IFFREQ_HILO_AUTOMATIC;\r\nret = fmc_send_cmd(fmdev, HILO_SET, REG_WR, &payload,\r\nsizeof(payload), NULL, NULL);\r\nif (ret < 0)\r\nreturn ret;\r\npayload = (freq - fmdev->rx.region.bot_freq) / FM_FREQ_MUL;\r\nret = fmc_send_cmd(fmdev, FREQ_SET, REG_WR, &payload,\r\nsizeof(payload), NULL, NULL);\r\nif (ret < 0)\r\nreturn ret;\r\nret = fmc_send_cmd(fmdev, FLAG_GET, REG_RD, NULL, 2, NULL, NULL);\r\nif (ret < 0)\r\nreturn ret;\r\nintr_flag = fmdev->irq_info.mask;\r\nfmdev->irq_info.mask = (FM_FR_EVENT | FM_BL_EVENT);\r\npayload = fmdev->irq_info.mask;\r\nret = fmc_send_cmd(fmdev, INT_MASK_SET, REG_WR, &payload,\r\nsizeof(payload), NULL, NULL);\r\nif (ret < 0)\r\nreturn ret;\r\npayload = FM_TUNER_PRESET_MODE;\r\nret = fmc_send_cmd(fmdev, TUNER_MODE_SET, REG_WR, &payload,\r\nsizeof(payload), NULL, NULL);\r\nif (ret < 0)\r\ngoto exit;\r\ninit_completion(&fmdev->maintask_comp);\r\ntimeleft = wait_for_completion_timeout(&fmdev->maintask_comp,\r\nFM_DRV_TX_TIMEOUT);\r\nif (!timeleft) {\r\nfmerr("Timeout(%d sec),didn't get tune ended int\n",\r\njiffies_to_msecs(FM_DRV_TX_TIMEOUT) / 1000);\r\nret = -ETIMEDOUT;\r\ngoto exit;\r\n}\r\nret = fmc_send_cmd(fmdev, FREQ_SET, REG_RD, NULL, 2, &curr_frq, &resp_len);\r\nif (ret < 0)\r\ngoto exit;\r\ncurr_frq = be16_to_cpu((__force __be16)curr_frq);\r\ncurr_frq_in_khz = (fmdev->rx.region.bot_freq + ((u32)curr_frq * FM_FREQ_MUL));\r\nif (curr_frq_in_khz != freq) {\r\npr_info("Frequency is set to (%d) but requested freq is (%d)\n",\r\ncurr_frq_in_khz, freq);\r\n}\r\nfmdev->rx.freq = curr_frq_in_khz;\r\nexit:\r\nfmdev->irq_info.mask = intr_flag;\r\npayload = fmdev->irq_info.mask;\r\nret = fmc_send_cmd(fmdev, INT_MASK_SET, REG_WR, &payload,\r\nsizeof(payload), NULL, NULL);\r\nif (ret < 0)\r\nreturn ret;\r\nfm_rx_reset_rds_cache(fmdev);\r\nfm_rx_reset_station_info(fmdev);\r\nreturn ret;\r\n}\r\nstatic int fm_rx_set_channel_spacing(struct fmdev *fmdev, u32 spacing)\r\n{\r\nu16 payload;\r\nint ret;\r\nif (spacing > 0 && spacing <= 50000)\r\nspacing = FM_CHANNEL_SPACING_50KHZ;\r\nelse if (spacing > 50000 && spacing <= 100000)\r\nspacing = FM_CHANNEL_SPACING_100KHZ;\r\nelse\r\nspacing = FM_CHANNEL_SPACING_200KHZ;\r\npayload = spacing;\r\nret = fmc_send_cmd(fmdev, CHANL_BW_SET, REG_WR, &payload,\r\nsizeof(payload), NULL, NULL);\r\nif (ret < 0)\r\nreturn ret;\r\nfmdev->rx.region.chanl_space = spacing * FM_FREQ_MUL;\r\nreturn ret;\r\n}\r\nint fm_rx_seek(struct fmdev *fmdev, u32 seek_upward,\r\nu32 wrap_around, u32 spacing)\r\n{\r\nu32 resp_len;\r\nu16 curr_frq, next_frq, last_frq;\r\nu16 payload, int_reason, intr_flag;\r\nu16 offset, space_idx;\r\nunsigned long timeleft;\r\nint ret;\r\nret = fm_rx_set_channel_spacing(fmdev, spacing);\r\nif (ret < 0) {\r\nfmerr("Failed to set channel spacing\n");\r\nreturn ret;\r\n}\r\nret = fmc_send_cmd(fmdev, FREQ_SET, REG_RD, NULL,\r\nsizeof(curr_frq), &curr_frq, &resp_len);\r\nif (ret < 0)\r\nreturn ret;\r\ncurr_frq = be16_to_cpu((__force __be16)curr_frq);\r\nlast_frq = (fmdev->rx.region.top_freq - fmdev->rx.region.bot_freq) / FM_FREQ_MUL;\r\nspace_idx = fmdev->rx.region.chanl_space / FM_FREQ_MUL;\r\noffset = curr_frq % space_idx;\r\nnext_frq = seek_upward ? curr_frq + space_idx :\r\ncurr_frq - space_idx ;\r\nif ((short)next_frq < 0)\r\nnext_frq = last_frq - offset;\r\nelse if (next_frq > last_frq)\r\nnext_frq = 0 + offset;\r\nagain:\r\npayload = next_frq;\r\nret = fmc_send_cmd(fmdev, FREQ_SET, REG_WR, &payload,\r\nsizeof(payload), NULL, NULL);\r\nif (ret < 0)\r\nreturn ret;\r\npayload = (seek_upward ? FM_SEARCH_DIRECTION_UP : FM_SEARCH_DIRECTION_DOWN);\r\nret = fmc_send_cmd(fmdev, SEARCH_DIR_SET, REG_WR, &payload,\r\nsizeof(payload), NULL, NULL);\r\nif (ret < 0)\r\nreturn ret;\r\nret = fmc_send_cmd(fmdev, FLAG_GET, REG_RD, NULL, 2, NULL, NULL);\r\nif (ret < 0)\r\nreturn ret;\r\nintr_flag = fmdev->irq_info.mask;\r\nfmdev->irq_info.mask = (FM_FR_EVENT | FM_BL_EVENT);\r\npayload = fmdev->irq_info.mask;\r\nret = fmc_send_cmd(fmdev, INT_MASK_SET, REG_WR, &payload,\r\nsizeof(payload), NULL, NULL);\r\nif (ret < 0)\r\nreturn ret;\r\npayload = FM_TUNER_AUTONOMOUS_SEARCH_MODE;\r\nret = fmc_send_cmd(fmdev, TUNER_MODE_SET, REG_WR, &payload,\r\nsizeof(payload), NULL, NULL);\r\nif (ret < 0)\r\nreturn ret;\r\ninit_completion(&fmdev->maintask_comp);\r\ntimeleft = wait_for_completion_timeout(&fmdev->maintask_comp,\r\nFM_DRV_RX_SEEK_TIMEOUT);\r\nif (!timeleft) {\r\nfmerr("Timeout(%d sec),didn't get tune ended int\n",\r\njiffies_to_msecs(FM_DRV_RX_SEEK_TIMEOUT) / 1000);\r\nreturn -ENODATA;\r\n}\r\nint_reason = fmdev->irq_info.flag & (FM_TUNE_COMPLETE | FM_BAND_LIMIT);\r\nfmdev->irq_info.mask = intr_flag;\r\npayload = fmdev->irq_info.mask;\r\nret = fmc_send_cmd(fmdev, INT_MASK_SET, REG_WR, &payload,\r\nsizeof(payload), NULL, NULL);\r\nif (ret < 0)\r\nreturn ret;\r\nif (int_reason & FM_BL_EVENT) {\r\nif (wrap_around == 0) {\r\nfmdev->rx.freq = seek_upward ?\r\nfmdev->rx.region.top_freq :\r\nfmdev->rx.region.bot_freq;\r\n} else {\r\nfmdev->rx.freq = seek_upward ?\r\nfmdev->rx.region.bot_freq :\r\nfmdev->rx.region.top_freq;\r\nnext_frq = (fmdev->rx.freq -\r\nfmdev->rx.region.bot_freq) / FM_FREQ_MUL;\r\ngoto again;\r\n}\r\n} else {\r\nret = fmc_send_cmd(fmdev, FREQ_SET, REG_RD, NULL, 2,\r\n&curr_frq, &resp_len);\r\nif (ret < 0)\r\nreturn ret;\r\ncurr_frq = be16_to_cpu((__force __be16)curr_frq);\r\nfmdev->rx.freq = (fmdev->rx.region.bot_freq +\r\n((u32)curr_frq * FM_FREQ_MUL));\r\n}\r\nfm_rx_reset_rds_cache(fmdev);\r\nfm_rx_reset_station_info(fmdev);\r\nreturn ret;\r\n}\r\nint fm_rx_set_volume(struct fmdev *fmdev, u16 vol_to_set)\r\n{\r\nu16 payload;\r\nint ret;\r\nif (fmdev->curr_fmmode != FM_MODE_RX)\r\nreturn -EPERM;\r\nif (vol_to_set > FM_RX_VOLUME_MAX) {\r\nfmerr("Volume is not within(%d-%d) range\n",\r\nFM_RX_VOLUME_MIN, FM_RX_VOLUME_MAX);\r\nreturn -EINVAL;\r\n}\r\nvol_to_set *= FM_RX_VOLUME_GAIN_STEP;\r\npayload = vol_to_set;\r\nret = fmc_send_cmd(fmdev, VOLUME_SET, REG_WR, &payload,\r\nsizeof(payload), NULL, NULL);\r\nif (ret < 0)\r\nreturn ret;\r\nfmdev->rx.volume = vol_to_set;\r\nreturn ret;\r\n}\r\nint fm_rx_get_volume(struct fmdev *fmdev, u16 *curr_vol)\r\n{\r\nif (fmdev->curr_fmmode != FM_MODE_RX)\r\nreturn -EPERM;\r\nif (curr_vol == NULL) {\r\nfmerr("Invalid memory\n");\r\nreturn -ENOMEM;\r\n}\r\n*curr_vol = fmdev->rx.volume / FM_RX_VOLUME_GAIN_STEP;\r\nreturn 0;\r\n}\r\nint fm_rx_get_band_freq_range(struct fmdev *fmdev, u32 *bot_freq, u32 *top_freq)\r\n{\r\nif (bot_freq != NULL)\r\n*bot_freq = fmdev->rx.region.bot_freq;\r\nif (top_freq != NULL)\r\n*top_freq = fmdev->rx.region.top_freq;\r\nreturn 0;\r\n}\r\nvoid fm_rx_get_region(struct fmdev *fmdev, u8 *region)\r\n{\r\n*region = fmdev->rx.region.fm_band;\r\n}\r\nint fm_rx_set_region(struct fmdev *fmdev, u8 region_to_set)\r\n{\r\nu16 payload;\r\nu32 new_frq = 0;\r\nint ret;\r\nif (region_to_set != FM_BAND_EUROPE_US &&\r\nregion_to_set != FM_BAND_JAPAN) {\r\nfmerr("Invalid band\n");\r\nreturn -EINVAL;\r\n}\r\nif (fmdev->rx.region.fm_band == region_to_set) {\r\nfmerr("Requested band is already configured\n");\r\nreturn 0;\r\n}\r\npayload = (u16)region_to_set;\r\nret = fmc_send_cmd(fmdev, BAND_SET, REG_WR, &payload,\r\nsizeof(payload), NULL, NULL);\r\nif (ret < 0)\r\nreturn ret;\r\nfmc_update_region_info(fmdev, region_to_set);\r\nif (fmdev->rx.freq < fmdev->rx.region.bot_freq)\r\nnew_frq = fmdev->rx.region.bot_freq;\r\nelse if (fmdev->rx.freq > fmdev->rx.region.top_freq)\r\nnew_frq = fmdev->rx.region.top_freq;\r\nif (new_frq) {\r\nfmdbg("Current freq is not within band limit boundary,switching to %d KHz\n",\r\nnew_frq);\r\nret = fm_rx_set_freq(fmdev, new_frq);\r\n}\r\nreturn ret;\r\n}\r\nint fm_rx_get_mute_mode(struct fmdev *fmdev, u8 *curr_mute_mode)\r\n{\r\nif (fmdev->curr_fmmode != FM_MODE_RX)\r\nreturn -EPERM;\r\nif (curr_mute_mode == NULL) {\r\nfmerr("Invalid memory\n");\r\nreturn -ENOMEM;\r\n}\r\n*curr_mute_mode = fmdev->rx.mute_mode;\r\nreturn 0;\r\n}\r\nstatic int fm_config_rx_mute_reg(struct fmdev *fmdev)\r\n{\r\nu16 payload, muteval;\r\nint ret;\r\nmuteval = 0;\r\nswitch (fmdev->rx.mute_mode) {\r\ncase FM_MUTE_ON:\r\nmuteval = FM_RX_AC_MUTE_MODE;\r\nbreak;\r\ncase FM_MUTE_OFF:\r\nmuteval = FM_RX_UNMUTE_MODE;\r\nbreak;\r\ncase FM_MUTE_ATTENUATE:\r\nmuteval = FM_RX_SOFT_MUTE_FORCE_MODE;\r\nbreak;\r\n}\r\nif (fmdev->rx.rf_depend_mute == FM_RX_RF_DEPENDENT_MUTE_ON)\r\nmuteval |= FM_RX_RF_DEP_MODE;\r\nelse\r\nmuteval &= ~FM_RX_RF_DEP_MODE;\r\npayload = muteval;\r\nret = fmc_send_cmd(fmdev, MUTE_STATUS_SET, REG_WR, &payload,\r\nsizeof(payload), NULL, NULL);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nint fm_rx_set_mute_mode(struct fmdev *fmdev, u8 mute_mode_toset)\r\n{\r\nu8 org_state;\r\nint ret;\r\nif (fmdev->rx.mute_mode == mute_mode_toset)\r\nreturn 0;\r\norg_state = fmdev->rx.mute_mode;\r\nfmdev->rx.mute_mode = mute_mode_toset;\r\nret = fm_config_rx_mute_reg(fmdev);\r\nif (ret < 0) {\r\nfmdev->rx.mute_mode = org_state;\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint fm_rx_get_rfdepend_softmute(struct fmdev *fmdev, u8 *curr_mute_mode)\r\n{\r\nif (fmdev->curr_fmmode != FM_MODE_RX)\r\nreturn -EPERM;\r\nif (curr_mute_mode == NULL) {\r\nfmerr("Invalid memory\n");\r\nreturn -ENOMEM;\r\n}\r\n*curr_mute_mode = fmdev->rx.rf_depend_mute;\r\nreturn 0;\r\n}\r\nint fm_rx_set_rfdepend_softmute(struct fmdev *fmdev, u8 rfdepend_mute)\r\n{\r\nu8 org_state;\r\nint ret;\r\nif (fmdev->curr_fmmode != FM_MODE_RX)\r\nreturn -EPERM;\r\nif (rfdepend_mute != FM_RX_RF_DEPENDENT_MUTE_ON &&\r\nrfdepend_mute != FM_RX_RF_DEPENDENT_MUTE_OFF) {\r\nfmerr("Invalid RF dependent soft mute\n");\r\nreturn -EINVAL;\r\n}\r\nif (fmdev->rx.rf_depend_mute == rfdepend_mute)\r\nreturn 0;\r\norg_state = fmdev->rx.rf_depend_mute;\r\nfmdev->rx.rf_depend_mute = rfdepend_mute;\r\nret = fm_config_rx_mute_reg(fmdev);\r\nif (ret < 0) {\r\nfmdev->rx.rf_depend_mute = org_state;\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint fm_rx_get_rssi_level(struct fmdev *fmdev, u16 *rssilvl)\r\n{\r\n__be16 curr_rssi_lel;\r\nu32 resp_len;\r\nint ret;\r\nif (rssilvl == NULL) {\r\nfmerr("Invalid memory\n");\r\nreturn -ENOMEM;\r\n}\r\nret = fmc_send_cmd(fmdev, RSSI_LVL_GET, REG_RD, NULL, 2,\r\n&curr_rssi_lel, &resp_len);\r\nif (ret < 0)\r\nreturn ret;\r\n*rssilvl = be16_to_cpu(curr_rssi_lel);\r\nreturn 0;\r\n}\r\nint fm_rx_set_rssi_threshold(struct fmdev *fmdev, short rssi_lvl_toset)\r\n{\r\nu16 payload;\r\nint ret;\r\nif (rssi_lvl_toset < FM_RX_RSSI_THRESHOLD_MIN ||\r\nrssi_lvl_toset > FM_RX_RSSI_THRESHOLD_MAX) {\r\nfmerr("Invalid RSSI threshold level\n");\r\nreturn -EINVAL;\r\n}\r\npayload = (u16)rssi_lvl_toset;\r\nret = fmc_send_cmd(fmdev, SEARCH_LVL_SET, REG_WR, &payload,\r\nsizeof(payload), NULL, NULL);\r\nif (ret < 0)\r\nreturn ret;\r\nfmdev->rx.rssi_threshold = rssi_lvl_toset;\r\nreturn 0;\r\n}\r\nint fm_rx_get_rssi_threshold(struct fmdev *fmdev, short *curr_rssi_lvl)\r\n{\r\nif (fmdev->curr_fmmode != FM_MODE_RX)\r\nreturn -EPERM;\r\nif (curr_rssi_lvl == NULL) {\r\nfmerr("Invalid memory\n");\r\nreturn -ENOMEM;\r\n}\r\n*curr_rssi_lvl = fmdev->rx.rssi_threshold;\r\nreturn 0;\r\n}\r\nint fm_rx_set_stereo_mono(struct fmdev *fmdev, u16 mode)\r\n{\r\nu16 payload;\r\nint ret;\r\nif (mode != FM_STEREO_MODE && mode != FM_MONO_MODE) {\r\nfmerr("Invalid mode\n");\r\nreturn -EINVAL;\r\n}\r\npayload = (u16)mode;\r\nret = fmc_send_cmd(fmdev, MOST_MODE_SET, REG_WR, &payload,\r\nsizeof(payload), NULL, NULL);\r\nif (ret < 0)\r\nreturn ret;\r\npayload = FM_STEREO_SOFT_BLEND;\r\nret = fmc_send_cmd(fmdev, MOST_BLEND_SET, REG_WR, &payload,\r\nsizeof(payload), NULL, NULL);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nint fm_rx_get_stereo_mono(struct fmdev *fmdev, u16 *mode)\r\n{\r\n__be16 curr_mode;\r\nu32 resp_len;\r\nint ret;\r\nif (mode == NULL) {\r\nfmerr("Invalid memory\n");\r\nreturn -ENOMEM;\r\n}\r\nret = fmc_send_cmd(fmdev, MOST_MODE_SET, REG_RD, NULL, 2,\r\n&curr_mode, &resp_len);\r\nif (ret < 0)\r\nreturn ret;\r\n*mode = be16_to_cpu(curr_mode);\r\nreturn 0;\r\n}\r\nint fm_rx_set_deemphasis_mode(struct fmdev *fmdev, u16 mode)\r\n{\r\nu16 payload;\r\nint ret;\r\nif (fmdev->curr_fmmode != FM_MODE_RX)\r\nreturn -EPERM;\r\nif (mode != FM_RX_EMPHASIS_FILTER_50_USEC &&\r\nmode != FM_RX_EMPHASIS_FILTER_75_USEC) {\r\nfmerr("Invalid rx de-emphasis mode (%d)\n", mode);\r\nreturn -EINVAL;\r\n}\r\npayload = mode;\r\nret = fmc_send_cmd(fmdev, DEMPH_MODE_SET, REG_WR, &payload,\r\nsizeof(payload), NULL, NULL);\r\nif (ret < 0)\r\nreturn ret;\r\nfmdev->rx.deemphasis_mode = mode;\r\nreturn 0;\r\n}\r\nint fm_rx_get_deemph_mode(struct fmdev *fmdev, u16 *curr_deemphasis_mode)\r\n{\r\nif (fmdev->curr_fmmode != FM_MODE_RX)\r\nreturn -EPERM;\r\nif (curr_deemphasis_mode == NULL) {\r\nfmerr("Invalid memory\n");\r\nreturn -ENOMEM;\r\n}\r\n*curr_deemphasis_mode = fmdev->rx.deemphasis_mode;\r\nreturn 0;\r\n}\r\nint fm_rx_set_rds_mode(struct fmdev *fmdev, u8 rds_en_dis)\r\n{\r\nu16 payload;\r\nint ret;\r\nif (rds_en_dis != FM_RDS_ENABLE && rds_en_dis != FM_RDS_DISABLE) {\r\nfmerr("Invalid rds option\n");\r\nreturn -EINVAL;\r\n}\r\nif (rds_en_dis == FM_RDS_ENABLE\r\n&& fmdev->rx.rds.flag == FM_RDS_DISABLE) {\r\npayload = FM_RX_PWR_SET_FM_AND_RDS_BLK_ON;\r\nret = fmc_send_cmd(fmdev, POWER_SET, REG_WR, &payload,\r\nsizeof(payload), NULL, NULL);\r\nif (ret < 0)\r\nreturn ret;\r\npayload = FM_RX_RDS_FLUSH_FIFO;\r\nret = fmc_send_cmd(fmdev, RDS_CNTRL_SET, REG_WR, &payload,\r\nsizeof(payload), NULL, NULL);\r\nif (ret < 0)\r\nreturn ret;\r\nret = fmc_send_cmd(fmdev, FLAG_GET, REG_RD, NULL, 2,\r\nNULL, NULL);\r\nif (ret < 0)\r\nreturn ret;\r\npayload = FM_RX_RDS_FIFO_THRESHOLD;\r\nret = fmc_send_cmd(fmdev, RDS_MEM_SET, REG_WR, &payload,\r\nsizeof(payload), NULL, NULL);\r\nif (ret < 0)\r\nreturn ret;\r\nfmdev->irq_info.mask |= FM_RDS_EVENT;\r\npayload = fmdev->irq_info.mask;\r\nret = fmc_send_cmd(fmdev, INT_MASK_SET, REG_WR, &payload,\r\nsizeof(payload), NULL, NULL);\r\nif (ret < 0) {\r\nfmdev->irq_info.mask &= ~FM_RDS_EVENT;\r\nreturn ret;\r\n}\r\nfmdev->rx.rds.flag = FM_RDS_ENABLE;\r\n} else if (rds_en_dis == FM_RDS_DISABLE\r\n&& fmdev->rx.rds.flag == FM_RDS_ENABLE) {\r\npayload = FM_RX_PWR_SET_FM_ON_RDS_OFF;\r\nret = fmc_send_cmd(fmdev, POWER_SET, REG_WR, &payload,\r\nsizeof(payload), NULL, NULL);\r\nif (ret < 0)\r\nreturn ret;\r\nfmdev->rx.rds.last_blk_idx = 0;\r\nfmdev->rx.rds.wr_idx = 0;\r\nfmdev->rx.rds.rd_idx = 0;\r\nfm_rx_reset_station_info(fmdev);\r\nfmdev->irq_info.mask &= ~(FM_RDS_EVENT);\r\nfmdev->rx.rds.flag = FM_RDS_DISABLE;\r\n}\r\nreturn 0;\r\n}\r\nint fm_rx_get_rds_mode(struct fmdev *fmdev, u8 *curr_rds_en_dis)\r\n{\r\nif (fmdev->curr_fmmode != FM_MODE_RX)\r\nreturn -EPERM;\r\nif (curr_rds_en_dis == NULL) {\r\nfmerr("Invalid memory\n");\r\nreturn -ENOMEM;\r\n}\r\n*curr_rds_en_dis = fmdev->rx.rds.flag;\r\nreturn 0;\r\n}\r\nint fm_rx_set_rds_system(struct fmdev *fmdev, u8 rds_mode)\r\n{\r\nu16 payload;\r\nint ret;\r\nif (fmdev->curr_fmmode != FM_MODE_RX)\r\nreturn -EPERM;\r\nif (rds_mode != FM_RDS_SYSTEM_RDS && rds_mode != FM_RDS_SYSTEM_RBDS) {\r\nfmerr("Invalid rds mode\n");\r\nreturn -EINVAL;\r\n}\r\npayload = (u16)rds_mode;\r\nret = fmc_send_cmd(fmdev, RDS_SYSTEM_SET, REG_WR, &payload,\r\nsizeof(payload), NULL, NULL);\r\nif (ret < 0)\r\nreturn ret;\r\nfmdev->rx.rds_mode = rds_mode;\r\nreturn 0;\r\n}\r\nint fm_rx_set_af_switch(struct fmdev *fmdev, u8 af_mode)\r\n{\r\nu16 payload;\r\nint ret;\r\nif (fmdev->curr_fmmode != FM_MODE_RX)\r\nreturn -EPERM;\r\nif (af_mode != FM_RX_RDS_AF_SWITCH_MODE_ON &&\r\naf_mode != FM_RX_RDS_AF_SWITCH_MODE_OFF) {\r\nfmerr("Invalid af mode\n");\r\nreturn -EINVAL;\r\n}\r\nif (af_mode == FM_RX_RDS_AF_SWITCH_MODE_ON)\r\nfmdev->irq_info.mask |= FM_LEV_EVENT;\r\nelse\r\nfmdev->irq_info.mask &= ~FM_LEV_EVENT;\r\npayload = fmdev->irq_info.mask;\r\nret = fmc_send_cmd(fmdev, INT_MASK_SET, REG_WR, &payload,\r\nsizeof(payload), NULL, NULL);\r\nif (ret < 0)\r\nreturn ret;\r\nfmdev->rx.af_mode = af_mode;\r\nreturn 0;\r\n}\r\nint fm_rx_get_af_switch(struct fmdev *fmdev, u8 *af_mode)\r\n{\r\nif (fmdev->curr_fmmode != FM_MODE_RX)\r\nreturn -EPERM;\r\nif (af_mode == NULL) {\r\nfmerr("Invalid memory\n");\r\nreturn -ENOMEM;\r\n}\r\n*af_mode = fmdev->rx.af_mode;\r\nreturn 0;\r\n}
