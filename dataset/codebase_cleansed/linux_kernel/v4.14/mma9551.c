static int mma9551_read_incli_chan(struct i2c_client *client,\r\nconst struct iio_chan_spec *chan,\r\nint *val)\r\n{\r\nu8 quad_shift, angle, quadrant;\r\nu16 reg_addr;\r\nint ret;\r\nswitch (chan->channel2) {\r\ncase IIO_MOD_X:\r\nreg_addr = MMA9551_TILT_YZ_ANG_REG;\r\nquad_shift = MMA9551_TILT_YZ_QUAD_SHIFT;\r\nbreak;\r\ncase IIO_MOD_Y:\r\nreg_addr = MMA9551_TILT_XZ_ANG_REG;\r\nquad_shift = MMA9551_TILT_XZ_QUAD_SHIFT;\r\nbreak;\r\ncase IIO_MOD_Z:\r\nreg_addr = MMA9551_TILT_XY_ANG_REG;\r\nquad_shift = MMA9551_TILT_XY_QUAD_SHIFT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = mma9551_set_power_state(client, true);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mma9551_read_status_byte(client, MMA9551_APPID_TILT,\r\nreg_addr, &angle);\r\nif (ret < 0)\r\ngoto out_poweroff;\r\nret = mma9551_read_status_byte(client, MMA9551_APPID_TILT,\r\nMMA9551_TILT_QUAD_REG, &quadrant);\r\nif (ret < 0)\r\ngoto out_poweroff;\r\nangle &= ~MMA9551_TILT_ANGFLG;\r\nquadrant = (quadrant >> quad_shift) & 0x03;\r\nif (quadrant == 1 || quadrant == 3)\r\n*val = 90 * (quadrant + 1) - angle;\r\nelse\r\n*val = angle + 90 * quadrant;\r\nret = IIO_VAL_INT;\r\nout_poweroff:\r\nmma9551_set_power_state(client, false);\r\nreturn ret;\r\n}\r\nstatic int mma9551_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2, long mask)\r\n{\r\nstruct mma9551_data *data = iio_priv(indio_dev);\r\nint ret;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_PROCESSED:\r\nswitch (chan->type) {\r\ncase IIO_INCLI:\r\nmutex_lock(&data->mutex);\r\nret = mma9551_read_incli_chan(data->client, chan, val);\r\nmutex_unlock(&data->mutex);\r\nreturn ret;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncase IIO_CHAN_INFO_RAW:\r\nswitch (chan->type) {\r\ncase IIO_ACCEL:\r\nmutex_lock(&data->mutex);\r\nret = mma9551_read_accel_chan(data->client,\r\nchan, val, val2);\r\nmutex_unlock(&data->mutex);\r\nreturn ret;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncase IIO_CHAN_INFO_SCALE:\r\nswitch (chan->type) {\r\ncase IIO_ACCEL:\r\nreturn mma9551_read_accel_scale(val, val2);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int mma9551_read_event_config(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan,\r\nenum iio_event_type type,\r\nenum iio_event_direction dir)\r\n{\r\nstruct mma9551_data *data = iio_priv(indio_dev);\r\nswitch (chan->type) {\r\ncase IIO_INCLI:\r\nreturn data->event_enabled[chan->channel2 - 1];\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int mma9551_config_incli_event(struct iio_dev *indio_dev,\r\nenum iio_modifier axis,\r\nint state)\r\n{\r\nstruct mma9551_data *data = iio_priv(indio_dev);\r\nenum mma9551_tilt_axis mma_axis;\r\nint ret;\r\nmma_axis = axis - 1;\r\nif (data->event_enabled[mma_axis] == state)\r\nreturn 0;\r\nif (state == 0) {\r\nret = mma9551_gpio_config(data->client,\r\n(enum mma9551_gpio_pin)mma_axis,\r\nMMA9551_APPID_NONE, 0, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mma9551_set_power_state(data->client, false);\r\nif (ret < 0)\r\nreturn ret;\r\n} else {\r\nint bitnum;\r\nswitch (axis) {\r\ncase IIO_MOD_X:\r\nbitnum = 7 + 8 * MMA9551_TILT_YZ_ANG_REG;\r\nbreak;\r\ncase IIO_MOD_Y:\r\nbitnum = 7 + 8 * MMA9551_TILT_XZ_ANG_REG;\r\nbreak;\r\ncase IIO_MOD_Z:\r\nbitnum = 7 + 8 * MMA9551_TILT_XY_ANG_REG;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = mma9551_set_power_state(data->client, true);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mma9551_gpio_config(data->client,\r\n(enum mma9551_gpio_pin)mma_axis,\r\nMMA9551_APPID_TILT, bitnum, 0);\r\nif (ret < 0) {\r\nmma9551_set_power_state(data->client, false);\r\nreturn ret;\r\n}\r\n}\r\ndata->event_enabled[mma_axis] = state;\r\nreturn ret;\r\n}\r\nstatic int mma9551_write_event_config(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan,\r\nenum iio_event_type type,\r\nenum iio_event_direction dir,\r\nint state)\r\n{\r\nstruct mma9551_data *data = iio_priv(indio_dev);\r\nint ret;\r\nswitch (chan->type) {\r\ncase IIO_INCLI:\r\nmutex_lock(&data->mutex);\r\nret = mma9551_config_incli_event(indio_dev,\r\nchan->channel2, state);\r\nmutex_unlock(&data->mutex);\r\nreturn ret;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int mma9551_write_event_value(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan,\r\nenum iio_event_type type,\r\nenum iio_event_direction dir,\r\nenum iio_event_info info,\r\nint val, int val2)\r\n{\r\nstruct mma9551_data *data = iio_priv(indio_dev);\r\nint ret;\r\nswitch (chan->type) {\r\ncase IIO_INCLI:\r\nif (val2 != 0 || val < 1 || val > 10)\r\nreturn -EINVAL;\r\nmutex_lock(&data->mutex);\r\nret = mma9551_update_config_bits(data->client,\r\nMMA9551_APPID_TILT,\r\nMMA9551_TILT_CFG_REG,\r\nMMA9551_TILT_ANG_THRESH_MASK,\r\nval);\r\nmutex_unlock(&data->mutex);\r\nreturn ret;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int mma9551_read_event_value(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan,\r\nenum iio_event_type type,\r\nenum iio_event_direction dir,\r\nenum iio_event_info info,\r\nint *val, int *val2)\r\n{\r\nstruct mma9551_data *data = iio_priv(indio_dev);\r\nint ret;\r\nu8 tmp;\r\nswitch (chan->type) {\r\ncase IIO_INCLI:\r\nmutex_lock(&data->mutex);\r\nret = mma9551_read_config_byte(data->client,\r\nMMA9551_APPID_TILT,\r\nMMA9551_TILT_CFG_REG, &tmp);\r\nmutex_unlock(&data->mutex);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = tmp & MMA9551_TILT_ANG_THRESH_MASK;\r\n*val2 = 0;\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic irqreturn_t mma9551_event_handler(int irq, void *private)\r\n{\r\nstruct iio_dev *indio_dev = private;\r\nstruct mma9551_data *data = iio_priv(indio_dev);\r\nint i, ret, mma_axis = -1;\r\nu16 reg;\r\nu8 val;\r\nmutex_lock(&data->mutex);\r\nfor (i = 0; i < 3; i++)\r\nif (irq == data->irqs[i]) {\r\nmma_axis = i;\r\nbreak;\r\n}\r\nif (mma_axis == -1) {\r\ndev_warn(&data->client->dev,\r\n"irq triggered on unused line %d\n", data->irqs[3]);\r\ngoto out;\r\n}\r\nswitch (mma_axis) {\r\ncase mma9551_x:\r\nreg = MMA9551_TILT_YZ_ANG_REG;\r\nbreak;\r\ncase mma9551_y:\r\nreg = MMA9551_TILT_XZ_ANG_REG;\r\nbreak;\r\ncase mma9551_z:\r\nreg = MMA9551_TILT_XY_ANG_REG;\r\nbreak;\r\n}\r\nret = mma9551_read_status_byte(data->client, MMA9551_APPID_TILT,\r\nreg, &val);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev,\r\n"error %d reading tilt register in IRQ\n", ret);\r\ngoto out;\r\n}\r\niio_push_event(indio_dev,\r\nIIO_MOD_EVENT_CODE(IIO_INCLI, 0, (mma_axis + 1),\r\nIIO_EV_TYPE_ROC, IIO_EV_DIR_RISING),\r\niio_get_time_ns(indio_dev));\r\nout:\r\nmutex_unlock(&data->mutex);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mma9551_init(struct mma9551_data *data)\r\n{\r\nint ret;\r\nret = mma9551_read_version(data->client);\r\nif (ret)\r\nreturn ret;\r\nreturn mma9551_set_device_state(data->client, true);\r\n}\r\nstatic int mma9551_gpio_probe(struct iio_dev *indio_dev)\r\n{\r\nstruct gpio_desc *gpio;\r\nint i, ret;\r\nstruct mma9551_data *data = iio_priv(indio_dev);\r\nstruct device *dev = &data->client->dev;\r\nfor (i = 0; i < MMA9551_GPIO_COUNT; i++) {\r\ngpio = devm_gpiod_get_index(dev, NULL, i, GPIOD_IN);\r\nif (IS_ERR(gpio)) {\r\ndev_err(dev, "acpi gpio get index failed\n");\r\nreturn PTR_ERR(gpio);\r\n}\r\nret = gpiod_to_irq(gpio);\r\nif (ret < 0)\r\nreturn ret;\r\ndata->irqs[i] = ret;\r\nret = devm_request_threaded_irq(dev, data->irqs[i],\r\nNULL, mma9551_event_handler,\r\nIRQF_TRIGGER_RISING | IRQF_ONESHOT,\r\nMMA9551_IRQ_NAME, indio_dev);\r\nif (ret < 0) {\r\ndev_err(dev, "request irq %d failed\n", data->irqs[i]);\r\nreturn ret;\r\n}\r\ndev_dbg(dev, "gpio resource, no:%d irq:%d\n",\r\ndesc_to_gpio(gpio), data->irqs[i]);\r\n}\r\nreturn 0;\r\n}\r\nstatic const char *mma9551_match_acpi_device(struct device *dev)\r\n{\r\nconst struct acpi_device_id *id;\r\nid = acpi_match_device(dev->driver->acpi_match_table, dev);\r\nif (!id)\r\nreturn NULL;\r\nreturn dev_name(dev);\r\n}\r\nstatic int mma9551_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct mma9551_data *data;\r\nstruct iio_dev *indio_dev;\r\nconst char *name = NULL;\r\nint ret;\r\nindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\ndata = iio_priv(indio_dev);\r\ni2c_set_clientdata(client, indio_dev);\r\ndata->client = client;\r\nif (id)\r\nname = id->name;\r\nelse if (ACPI_HANDLE(&client->dev))\r\nname = mma9551_match_acpi_device(&client->dev);\r\nret = mma9551_init(data);\r\nif (ret < 0)\r\nreturn ret;\r\nmutex_init(&data->mutex);\r\nindio_dev->dev.parent = &client->dev;\r\nindio_dev->channels = mma9551_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(mma9551_channels);\r\nindio_dev->name = name;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->info = &mma9551_info;\r\nret = mma9551_gpio_probe(indio_dev);\r\nif (ret < 0)\r\ngoto out_poweroff;\r\nret = pm_runtime_set_active(&client->dev);\r\nif (ret < 0)\r\ngoto out_poweroff;\r\npm_runtime_enable(&client->dev);\r\npm_runtime_set_autosuspend_delay(&client->dev,\r\nMMA9551_AUTO_SUSPEND_DELAY_MS);\r\npm_runtime_use_autosuspend(&client->dev);\r\nret = iio_device_register(indio_dev);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "unable to register iio device\n");\r\ngoto out_poweroff;\r\n}\r\nreturn 0;\r\nout_poweroff:\r\nmma9551_set_device_state(client, false);\r\nreturn ret;\r\n}\r\nstatic int mma9551_remove(struct i2c_client *client)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(client);\r\nstruct mma9551_data *data = iio_priv(indio_dev);\r\niio_device_unregister(indio_dev);\r\npm_runtime_disable(&client->dev);\r\npm_runtime_set_suspended(&client->dev);\r\npm_runtime_put_noidle(&client->dev);\r\nmutex_lock(&data->mutex);\r\nmma9551_set_device_state(data->client, false);\r\nmutex_unlock(&data->mutex);\r\nreturn 0;\r\n}\r\nstatic int mma9551_runtime_suspend(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct mma9551_data *data = iio_priv(indio_dev);\r\nint ret;\r\nmutex_lock(&data->mutex);\r\nret = mma9551_set_device_state(data->client, false);\r\nmutex_unlock(&data->mutex);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "powering off device failed\n");\r\nreturn -EAGAIN;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mma9551_runtime_resume(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct mma9551_data *data = iio_priv(indio_dev);\r\nint ret;\r\nret = mma9551_set_device_state(data->client, true);\r\nif (ret < 0)\r\nreturn ret;\r\nmma9551_sleep(MMA9551_DEFAULT_SAMPLE_RATE);\r\nreturn 0;\r\n}\r\nstatic int mma9551_suspend(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct mma9551_data *data = iio_priv(indio_dev);\r\nint ret;\r\nmutex_lock(&data->mutex);\r\nret = mma9551_set_device_state(data->client, false);\r\nmutex_unlock(&data->mutex);\r\nreturn ret;\r\n}\r\nstatic int mma9551_resume(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct mma9551_data *data = iio_priv(indio_dev);\r\nint ret;\r\nmutex_lock(&data->mutex);\r\nret = mma9551_set_device_state(data->client, true);\r\nmutex_unlock(&data->mutex);\r\nreturn ret;\r\n}
