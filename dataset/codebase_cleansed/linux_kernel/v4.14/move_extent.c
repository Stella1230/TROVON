static inline int\r\nget_ext_path(struct inode *inode, ext4_lblk_t lblock,\r\nstruct ext4_ext_path **ppath)\r\n{\r\nstruct ext4_ext_path *path;\r\npath = ext4_find_extent(inode, lblock, ppath, EXT4_EX_NOCACHE);\r\nif (IS_ERR(path))\r\nreturn PTR_ERR(path);\r\nif (path[ext_depth(inode)].p_ext == NULL) {\r\next4_ext_drop_refs(path);\r\nkfree(path);\r\n*ppath = NULL;\r\nreturn -ENODATA;\r\n}\r\n*ppath = path;\r\nreturn 0;\r\n}\r\nvoid\r\next4_double_down_write_data_sem(struct inode *first, struct inode *second)\r\n{\r\nif (first < second) {\r\ndown_write(&EXT4_I(first)->i_data_sem);\r\ndown_write_nested(&EXT4_I(second)->i_data_sem, I_DATA_SEM_OTHER);\r\n} else {\r\ndown_write(&EXT4_I(second)->i_data_sem);\r\ndown_write_nested(&EXT4_I(first)->i_data_sem, I_DATA_SEM_OTHER);\r\n}\r\n}\r\nvoid\r\next4_double_up_write_data_sem(struct inode *orig_inode,\r\nstruct inode *donor_inode)\r\n{\r\nup_write(&EXT4_I(orig_inode)->i_data_sem);\r\nup_write(&EXT4_I(donor_inode)->i_data_sem);\r\n}\r\nstatic int\r\nmext_check_coverage(struct inode *inode, ext4_lblk_t from, ext4_lblk_t count,\r\nint unwritten, int *err)\r\n{\r\nstruct ext4_ext_path *path = NULL;\r\nstruct ext4_extent *ext;\r\nint ret = 0;\r\next4_lblk_t last = from + count;\r\nwhile (from < last) {\r\n*err = get_ext_path(inode, from, &path);\r\nif (*err)\r\ngoto out;\r\next = path[ext_depth(inode)].p_ext;\r\nif (unwritten != ext4_ext_is_unwritten(ext))\r\ngoto out;\r\nfrom += ext4_ext_get_actual_len(ext);\r\next4_ext_drop_refs(path);\r\n}\r\nret = 1;\r\nout:\r\next4_ext_drop_refs(path);\r\nkfree(path);\r\nreturn ret;\r\n}\r\nstatic int\r\nmext_page_double_lock(struct inode *inode1, struct inode *inode2,\r\npgoff_t index1, pgoff_t index2, struct page *page[2])\r\n{\r\nstruct address_space *mapping[2];\r\nunsigned fl = AOP_FLAG_NOFS;\r\nBUG_ON(!inode1 || !inode2);\r\nif (inode1 < inode2) {\r\nmapping[0] = inode1->i_mapping;\r\nmapping[1] = inode2->i_mapping;\r\n} else {\r\npgoff_t tmp = index1;\r\nindex1 = index2;\r\nindex2 = tmp;\r\nmapping[0] = inode2->i_mapping;\r\nmapping[1] = inode1->i_mapping;\r\n}\r\npage[0] = grab_cache_page_write_begin(mapping[0], index1, fl);\r\nif (!page[0])\r\nreturn -ENOMEM;\r\npage[1] = grab_cache_page_write_begin(mapping[1], index2, fl);\r\nif (!page[1]) {\r\nunlock_page(page[0]);\r\nput_page(page[0]);\r\nreturn -ENOMEM;\r\n}\r\nwait_on_page_writeback(page[0]);\r\nwait_on_page_writeback(page[1]);\r\nif (inode1 > inode2)\r\nswap(page[0], page[1]);\r\nreturn 0;\r\n}\r\nstatic int\r\nmext_page_mkuptodate(struct page *page, unsigned from, unsigned to)\r\n{\r\nstruct inode *inode = page->mapping->host;\r\nsector_t block;\r\nstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\r\nunsigned int blocksize, block_start, block_end;\r\nint i, err, nr = 0, partial = 0;\r\nBUG_ON(!PageLocked(page));\r\nBUG_ON(PageWriteback(page));\r\nif (PageUptodate(page))\r\nreturn 0;\r\nblocksize = i_blocksize(inode);\r\nif (!page_has_buffers(page))\r\ncreate_empty_buffers(page, blocksize, 0);\r\nhead = page_buffers(page);\r\nblock = (sector_t)page->index << (PAGE_SHIFT - inode->i_blkbits);\r\nfor (bh = head, block_start = 0; bh != head || !block_start;\r\nblock++, block_start = block_end, bh = bh->b_this_page) {\r\nblock_end = block_start + blocksize;\r\nif (block_end <= from || block_start >= to) {\r\nif (!buffer_uptodate(bh))\r\npartial = 1;\r\ncontinue;\r\n}\r\nif (buffer_uptodate(bh))\r\ncontinue;\r\nif (!buffer_mapped(bh)) {\r\nerr = ext4_get_block(inode, block, bh, 0);\r\nif (err) {\r\nSetPageError(page);\r\nreturn err;\r\n}\r\nif (!buffer_mapped(bh)) {\r\nzero_user(page, block_start, blocksize);\r\nset_buffer_uptodate(bh);\r\ncontinue;\r\n}\r\n}\r\nBUG_ON(nr >= MAX_BUF_PER_PAGE);\r\narr[nr++] = bh;\r\n}\r\nif (!nr)\r\ngoto out;\r\nfor (i = 0; i < nr; i++) {\r\nbh = arr[i];\r\nif (!bh_uptodate_or_lock(bh)) {\r\nerr = bh_submit_read(bh);\r\nif (err)\r\nreturn err;\r\n}\r\n}\r\nout:\r\nif (!partial)\r\nSetPageUptodate(page);\r\nreturn 0;\r\n}\r\nstatic int\r\nmove_extent_per_page(struct file *o_filp, struct inode *donor_inode,\r\npgoff_t orig_page_offset, pgoff_t donor_page_offset,\r\nint data_offset_in_page,\r\nint block_len_in_page, int unwritten, int *err)\r\n{\r\nstruct inode *orig_inode = file_inode(o_filp);\r\nstruct page *pagep[2] = {NULL, NULL};\r\nhandle_t *handle;\r\next4_lblk_t orig_blk_offset, donor_blk_offset;\r\nunsigned long blocksize = orig_inode->i_sb->s_blocksize;\r\nunsigned int tmp_data_size, data_size, replaced_size;\r\nint i, err2, jblocks, retries = 0;\r\nint replaced_count = 0;\r\nint from = data_offset_in_page << orig_inode->i_blkbits;\r\nint blocks_per_page = PAGE_SIZE >> orig_inode->i_blkbits;\r\nstruct super_block *sb = orig_inode->i_sb;\r\nstruct buffer_head *bh = NULL;\r\nagain:\r\n*err = 0;\r\njblocks = ext4_writepage_trans_blocks(orig_inode) * 2;\r\nhandle = ext4_journal_start(orig_inode, EXT4_HT_MOVE_EXTENTS, jblocks);\r\nif (IS_ERR(handle)) {\r\n*err = PTR_ERR(handle);\r\nreturn 0;\r\n}\r\norig_blk_offset = orig_page_offset * blocks_per_page +\r\ndata_offset_in_page;\r\ndonor_blk_offset = donor_page_offset * blocks_per_page +\r\ndata_offset_in_page;\r\nif ((orig_blk_offset + block_len_in_page - 1) ==\r\n((orig_inode->i_size - 1) >> orig_inode->i_blkbits)) {\r\ntmp_data_size = orig_inode->i_size & (blocksize - 1);\r\nif (tmp_data_size == 0)\r\ntmp_data_size = blocksize;\r\ndata_size = tmp_data_size +\r\n((block_len_in_page - 1) << orig_inode->i_blkbits);\r\n} else\r\ndata_size = block_len_in_page << orig_inode->i_blkbits;\r\nreplaced_size = data_size;\r\n*err = mext_page_double_lock(orig_inode, donor_inode, orig_page_offset,\r\ndonor_page_offset, pagep);\r\nif (unlikely(*err < 0))\r\ngoto stop_journal;\r\nif (unwritten) {\r\next4_double_down_write_data_sem(orig_inode, donor_inode);\r\nunwritten = mext_check_coverage(orig_inode, orig_blk_offset,\r\nblock_len_in_page, 1, err);\r\nif (*err)\r\ngoto drop_data_sem;\r\nunwritten &= mext_check_coverage(donor_inode, donor_blk_offset,\r\nblock_len_in_page, 1, err);\r\nif (*err)\r\ngoto drop_data_sem;\r\nif (!unwritten) {\r\next4_double_up_write_data_sem(orig_inode, donor_inode);\r\ngoto data_copy;\r\n}\r\nif ((page_has_private(pagep[0]) &&\r\n!try_to_release_page(pagep[0], 0)) ||\r\n(page_has_private(pagep[1]) &&\r\n!try_to_release_page(pagep[1], 0))) {\r\n*err = -EBUSY;\r\ngoto drop_data_sem;\r\n}\r\nreplaced_count = ext4_swap_extents(handle, orig_inode,\r\ndonor_inode, orig_blk_offset,\r\ndonor_blk_offset,\r\nblock_len_in_page, 1, err);\r\ndrop_data_sem:\r\next4_double_up_write_data_sem(orig_inode, donor_inode);\r\ngoto unlock_pages;\r\n}\r\ndata_copy:\r\n*err = mext_page_mkuptodate(pagep[0], from, from + replaced_size);\r\nif (*err)\r\ngoto unlock_pages;\r\nif ((page_has_private(pagep[0]) && !try_to_release_page(pagep[0], 0)) ||\r\n(page_has_private(pagep[1]) && !try_to_release_page(pagep[1], 0))) {\r\n*err = -EBUSY;\r\ngoto unlock_pages;\r\n}\r\next4_double_down_write_data_sem(orig_inode, donor_inode);\r\nreplaced_count = ext4_swap_extents(handle, orig_inode, donor_inode,\r\norig_blk_offset, donor_blk_offset,\r\nblock_len_in_page, 1, err);\r\next4_double_up_write_data_sem(orig_inode, donor_inode);\r\nif (*err) {\r\nif (replaced_count) {\r\nblock_len_in_page = replaced_count;\r\nreplaced_size =\r\nblock_len_in_page << orig_inode->i_blkbits;\r\n} else\r\ngoto unlock_pages;\r\n}\r\nif (!page_has_buffers(pagep[0]))\r\ncreate_empty_buffers(pagep[0], 1 << orig_inode->i_blkbits, 0);\r\nbh = page_buffers(pagep[0]);\r\nfor (i = 0; i < data_offset_in_page; i++)\r\nbh = bh->b_this_page;\r\nfor (i = 0; i < block_len_in_page; i++) {\r\n*err = ext4_get_block(orig_inode, orig_blk_offset + i, bh, 0);\r\nif (*err < 0)\r\nbreak;\r\nbh = bh->b_this_page;\r\n}\r\nif (!*err)\r\n*err = block_commit_write(pagep[0], from, from + replaced_size);\r\nif (unlikely(*err < 0))\r\ngoto repair_branches;\r\n*err = ext4_jbd2_inode_add_write(handle, orig_inode);\r\nunlock_pages:\r\nunlock_page(pagep[0]);\r\nput_page(pagep[0]);\r\nunlock_page(pagep[1]);\r\nput_page(pagep[1]);\r\nstop_journal:\r\next4_journal_stop(handle);\r\nif (*err == -ENOSPC &&\r\next4_should_retry_alloc(sb, &retries))\r\ngoto again;\r\nif (*err == -EBUSY && retries++ < 4 && EXT4_SB(sb)->s_journal &&\r\njbd2_journal_force_commit_nested(EXT4_SB(sb)->s_journal))\r\ngoto again;\r\nreturn replaced_count;\r\nrepair_branches:\r\next4_double_down_write_data_sem(orig_inode, donor_inode);\r\nreplaced_count = ext4_swap_extents(handle, donor_inode, orig_inode,\r\norig_blk_offset, donor_blk_offset,\r\nblock_len_in_page, 0, &err2);\r\next4_double_up_write_data_sem(orig_inode, donor_inode);\r\nif (replaced_count != block_len_in_page) {\r\nEXT4_ERROR_INODE_BLOCK(orig_inode, (sector_t)(orig_blk_offset),\r\n"Unable to copy data block,"\r\n" data will be lost.");\r\n*err = -EIO;\r\n}\r\nreplaced_count = 0;\r\ngoto unlock_pages;\r\n}\r\nstatic int\r\nmext_check_arguments(struct inode *orig_inode,\r\nstruct inode *donor_inode, __u64 orig_start,\r\n__u64 donor_start, __u64 *len)\r\n{\r\n__u64 orig_eof, donor_eof;\r\nunsigned int blkbits = orig_inode->i_blkbits;\r\nunsigned int blocksize = 1 << blkbits;\r\norig_eof = (i_size_read(orig_inode) + blocksize - 1) >> blkbits;\r\ndonor_eof = (i_size_read(donor_inode) + blocksize - 1) >> blkbits;\r\nif (donor_inode->i_mode & (S_ISUID|S_ISGID)) {\r\next4_debug("ext4 move extent: suid or sgid is set"\r\n" to donor file [ino:orig %lu, donor %lu]\n",\r\norig_inode->i_ino, donor_inode->i_ino);\r\nreturn -EINVAL;\r\n}\r\nif (IS_IMMUTABLE(donor_inode) || IS_APPEND(donor_inode))\r\nreturn -EPERM;\r\nif (IS_SWAPFILE(orig_inode) || IS_SWAPFILE(donor_inode)) {\r\next4_debug("ext4 move extent: The argument files should "\r\n"not be swapfile [ino:orig %lu, donor %lu]\n",\r\norig_inode->i_ino, donor_inode->i_ino);\r\nreturn -EBUSY;\r\n}\r\nif (ext4_is_quota_file(orig_inode) && ext4_is_quota_file(donor_inode)) {\r\next4_debug("ext4 move extent: The argument files should "\r\n"not be quota files [ino:orig %lu, donor %lu]\n",\r\norig_inode->i_ino, donor_inode->i_ino);\r\nreturn -EBUSY;\r\n}\r\nif (!(ext4_test_inode_flag(orig_inode, EXT4_INODE_EXTENTS))) {\r\next4_debug("ext4 move extent: orig file is not extents "\r\n"based file [ino:orig %lu]\n", orig_inode->i_ino);\r\nreturn -EOPNOTSUPP;\r\n} else if (!(ext4_test_inode_flag(donor_inode, EXT4_INODE_EXTENTS))) {\r\next4_debug("ext4 move extent: donor file is not extents "\r\n"based file [ino:donor %lu]\n", donor_inode->i_ino);\r\nreturn -EOPNOTSUPP;\r\n}\r\nif ((!orig_inode->i_size) || (!donor_inode->i_size)) {\r\next4_debug("ext4 move extent: File size is 0 byte\n");\r\nreturn -EINVAL;\r\n}\r\nif ((orig_start & ~(PAGE_MASK >> orig_inode->i_blkbits)) !=\r\n(donor_start & ~(PAGE_MASK >> orig_inode->i_blkbits))) {\r\next4_debug("ext4 move extent: orig and donor's start "\r\n"offsets are not aligned [ino:orig %lu, donor %lu]\n",\r\norig_inode->i_ino, donor_inode->i_ino);\r\nreturn -EINVAL;\r\n}\r\nif ((orig_start >= EXT_MAX_BLOCKS) ||\r\n(donor_start >= EXT_MAX_BLOCKS) ||\r\n(*len > EXT_MAX_BLOCKS) ||\r\n(donor_start + *len >= EXT_MAX_BLOCKS) ||\r\n(orig_start + *len >= EXT_MAX_BLOCKS)) {\r\next4_debug("ext4 move extent: Can't handle over [%u] blocks "\r\n"[ino:orig %lu, donor %lu]\n", EXT_MAX_BLOCKS,\r\norig_inode->i_ino, donor_inode->i_ino);\r\nreturn -EINVAL;\r\n}\r\nif (orig_eof < orig_start + *len - 1)\r\n*len = orig_eof - orig_start;\r\nif (donor_eof < donor_start + *len - 1)\r\n*len = donor_eof - donor_start;\r\nif (!*len) {\r\next4_debug("ext4 move extent: len should not be 0 "\r\n"[ino:orig %lu, donor %lu]\n", orig_inode->i_ino,\r\ndonor_inode->i_ino);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint\r\next4_move_extents(struct file *o_filp, struct file *d_filp, __u64 orig_blk,\r\n__u64 donor_blk, __u64 len, __u64 *moved_len)\r\n{\r\nstruct inode *orig_inode = file_inode(o_filp);\r\nstruct inode *donor_inode = file_inode(d_filp);\r\nstruct ext4_ext_path *path = NULL;\r\nint blocks_per_page = PAGE_SIZE >> orig_inode->i_blkbits;\r\next4_lblk_t o_end, o_start = orig_blk;\r\next4_lblk_t d_start = donor_blk;\r\nint ret;\r\nif (orig_inode->i_sb != donor_inode->i_sb) {\r\next4_debug("ext4 move extent: The argument files "\r\n"should be in same FS [ino:orig %lu, donor %lu]\n",\r\norig_inode->i_ino, donor_inode->i_ino);\r\nreturn -EINVAL;\r\n}\r\nif (orig_inode == donor_inode) {\r\next4_debug("ext4 move extent: The argument files should not "\r\n"be same inode [ino:orig %lu, donor %lu]\n",\r\norig_inode->i_ino, donor_inode->i_ino);\r\nreturn -EINVAL;\r\n}\r\nif (!S_ISREG(orig_inode->i_mode) || !S_ISREG(donor_inode->i_mode)) {\r\next4_debug("ext4 move extent: The argument files should be "\r\n"regular file [ino:orig %lu, donor %lu]\n",\r\norig_inode->i_ino, donor_inode->i_ino);\r\nreturn -EINVAL;\r\n}\r\nif (ext4_should_journal_data(orig_inode) ||\r\next4_should_journal_data(donor_inode)) {\r\next4_msg(orig_inode->i_sb, KERN_ERR,\r\n"Online defrag not supported with data journaling");\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (ext4_encrypted_inode(orig_inode) ||\r\next4_encrypted_inode(donor_inode)) {\r\next4_msg(orig_inode->i_sb, KERN_ERR,\r\n"Online defrag not supported for encrypted files");\r\nreturn -EOPNOTSUPP;\r\n}\r\nlock_two_nondirectories(orig_inode, donor_inode);\r\next4_inode_block_unlocked_dio(orig_inode);\r\next4_inode_block_unlocked_dio(donor_inode);\r\ninode_dio_wait(orig_inode);\r\ninode_dio_wait(donor_inode);\r\next4_double_down_write_data_sem(orig_inode, donor_inode);\r\nret = mext_check_arguments(orig_inode, donor_inode, orig_blk,\r\ndonor_blk, &len);\r\nif (ret)\r\ngoto out;\r\no_end = o_start + len;\r\nwhile (o_start < o_end) {\r\nstruct ext4_extent *ex;\r\next4_lblk_t cur_blk, next_blk;\r\npgoff_t orig_page_index, donor_page_index;\r\nint offset_in_page;\r\nint unwritten, cur_len;\r\nret = get_ext_path(orig_inode, o_start, &path);\r\nif (ret)\r\ngoto out;\r\nex = path[path->p_depth].p_ext;\r\nnext_blk = ext4_ext_next_allocated_block(path);\r\ncur_blk = le32_to_cpu(ex->ee_block);\r\ncur_len = ext4_ext_get_actual_len(ex);\r\nif (cur_blk + cur_len - 1 < o_start) {\r\nif (next_blk == EXT_MAX_BLOCKS) {\r\no_start = o_end;\r\nret = -ENODATA;\r\ngoto out;\r\n}\r\nd_start += next_blk - o_start;\r\no_start = next_blk;\r\ncontinue;\r\n} else if (cur_blk > o_start) {\r\nd_start += cur_blk - o_start;\r\no_start = cur_blk;\r\nif (cur_blk >= o_end)\r\ngoto out;\r\n} else {\r\ncur_len += cur_blk - o_start;\r\n}\r\nunwritten = ext4_ext_is_unwritten(ex);\r\nif (o_end - o_start < cur_len)\r\ncur_len = o_end - o_start;\r\norig_page_index = o_start >> (PAGE_SHIFT -\r\norig_inode->i_blkbits);\r\ndonor_page_index = d_start >> (PAGE_SHIFT -\r\ndonor_inode->i_blkbits);\r\noffset_in_page = o_start % blocks_per_page;\r\nif (cur_len > blocks_per_page- offset_in_page)\r\ncur_len = blocks_per_page - offset_in_page;\r\next4_double_up_write_data_sem(orig_inode, donor_inode);\r\nmove_extent_per_page(o_filp, donor_inode,\r\norig_page_index, donor_page_index,\r\noffset_in_page, cur_len,\r\nunwritten, &ret);\r\next4_double_down_write_data_sem(orig_inode, donor_inode);\r\nif (ret < 0)\r\nbreak;\r\no_start += cur_len;\r\nd_start += cur_len;\r\n}\r\n*moved_len = o_start - orig_blk;\r\nif (*moved_len > len)\r\n*moved_len = len;\r\nout:\r\nif (*moved_len) {\r\next4_discard_preallocations(orig_inode);\r\next4_discard_preallocations(donor_inode);\r\n}\r\next4_ext_drop_refs(path);\r\nkfree(path);\r\next4_double_up_write_data_sem(orig_inode, donor_inode);\r\next4_inode_resume_unlocked_dio(orig_inode);\r\next4_inode_resume_unlocked_dio(donor_inode);\r\nunlock_two_nondirectories(orig_inode, donor_inode);\r\nreturn ret;\r\n}
