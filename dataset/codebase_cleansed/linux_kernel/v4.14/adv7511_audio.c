static void adv7511_calc_cts_n(unsigned int f_tmds, unsigned int fs,\r\nunsigned int *cts, unsigned int *n)\r\n{\r\nswitch (fs) {\r\ncase 32000:\r\n*n = 4096;\r\nbreak;\r\ncase 44100:\r\n*n = 6272;\r\nbreak;\r\ncase 48000:\r\n*n = 6144;\r\nbreak;\r\n}\r\n*cts = ((f_tmds * *n) / (128 * fs)) * 1000;\r\n}\r\nstatic int adv7511_update_cts_n(struct adv7511 *adv7511)\r\n{\r\nunsigned int cts = 0;\r\nunsigned int n = 0;\r\nadv7511_calc_cts_n(adv7511->f_tmds, adv7511->f_audio, &cts, &n);\r\nregmap_write(adv7511->regmap, ADV7511_REG_N0, (n >> 16) & 0xf);\r\nregmap_write(adv7511->regmap, ADV7511_REG_N1, (n >> 8) & 0xff);\r\nregmap_write(adv7511->regmap, ADV7511_REG_N2, n & 0xff);\r\nregmap_write(adv7511->regmap, ADV7511_REG_CTS_MANUAL0,\r\n(cts >> 16) & 0xf);\r\nregmap_write(adv7511->regmap, ADV7511_REG_CTS_MANUAL1,\r\n(cts >> 8) & 0xff);\r\nregmap_write(adv7511->regmap, ADV7511_REG_CTS_MANUAL2,\r\ncts & 0xff);\r\nreturn 0;\r\n}\r\nint adv7511_hdmi_hw_params(struct device *dev, void *data,\r\nstruct hdmi_codec_daifmt *fmt,\r\nstruct hdmi_codec_params *hparms)\r\n{\r\nstruct adv7511 *adv7511 = dev_get_drvdata(dev);\r\nunsigned int audio_source, i2s_format = 0;\r\nunsigned int invert_clock;\r\nunsigned int rate;\r\nunsigned int len;\r\nswitch (hparms->sample_rate) {\r\ncase 32000:\r\nrate = ADV7511_SAMPLE_FREQ_32000;\r\nbreak;\r\ncase 44100:\r\nrate = ADV7511_SAMPLE_FREQ_44100;\r\nbreak;\r\ncase 48000:\r\nrate = ADV7511_SAMPLE_FREQ_48000;\r\nbreak;\r\ncase 88200:\r\nrate = ADV7511_SAMPLE_FREQ_88200;\r\nbreak;\r\ncase 96000:\r\nrate = ADV7511_SAMPLE_FREQ_96000;\r\nbreak;\r\ncase 176400:\r\nrate = ADV7511_SAMPLE_FREQ_176400;\r\nbreak;\r\ncase 192000:\r\nrate = ADV7511_SAMPLE_FREQ_192000;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (hparms->sample_width) {\r\ncase 16:\r\nlen = ADV7511_I2S_SAMPLE_LEN_16;\r\nbreak;\r\ncase 18:\r\nlen = ADV7511_I2S_SAMPLE_LEN_18;\r\nbreak;\r\ncase 20:\r\nlen = ADV7511_I2S_SAMPLE_LEN_20;\r\nbreak;\r\ncase 24:\r\nlen = ADV7511_I2S_SAMPLE_LEN_24;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt->fmt) {\r\ncase HDMI_I2S:\r\naudio_source = ADV7511_AUDIO_SOURCE_I2S;\r\ni2s_format = ADV7511_I2S_FORMAT_I2S;\r\nbreak;\r\ncase HDMI_RIGHT_J:\r\naudio_source = ADV7511_AUDIO_SOURCE_I2S;\r\ni2s_format = ADV7511_I2S_FORMAT_RIGHT_J;\r\nbreak;\r\ncase HDMI_LEFT_J:\r\naudio_source = ADV7511_AUDIO_SOURCE_I2S;\r\ni2s_format = ADV7511_I2S_FORMAT_LEFT_J;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ninvert_clock = fmt->bit_clk_inv;\r\nregmap_update_bits(adv7511->regmap, ADV7511_REG_AUDIO_SOURCE, 0x70,\r\naudio_source << 4);\r\nregmap_update_bits(adv7511->regmap, ADV7511_REG_AUDIO_CONFIG, BIT(6),\r\ninvert_clock << 6);\r\nregmap_update_bits(adv7511->regmap, ADV7511_REG_I2S_CONFIG, 0x03,\r\ni2s_format);\r\nadv7511->audio_source = audio_source;\r\nadv7511->f_audio = hparms->sample_rate;\r\nadv7511_update_cts_n(adv7511);\r\nregmap_update_bits(adv7511->regmap, ADV7511_REG_AUDIO_CFG3,\r\nADV7511_AUDIO_CFG3_LEN_MASK, len);\r\nregmap_update_bits(adv7511->regmap, ADV7511_REG_I2C_FREQ_ID_CFG,\r\nADV7511_I2C_FREQ_ID_CFG_RATE_MASK, rate << 4);\r\nregmap_write(adv7511->regmap, 0x73, 0x1);\r\nreturn 0;\r\n}\r\nstatic int audio_startup(struct device *dev, void *data)\r\n{\r\nstruct adv7511 *adv7511 = dev_get_drvdata(dev);\r\nregmap_update_bits(adv7511->regmap, ADV7511_REG_AUDIO_CONFIG,\r\nBIT(7), 0);\r\nregmap_update_bits(adv7511->regmap, ADV7511_REG_INFOFRAME_UPDATE,\r\nBIT(5), BIT(5));\r\nregmap_update_bits(adv7511->regmap, ADV7511_REG_PACKET_ENABLE1,\r\nBIT(5), BIT(5));\r\nregmap_update_bits(adv7511->regmap, ADV7511_REG_PACKET_ENABLE1,\r\nBIT(6), BIT(6));\r\nregmap_update_bits(adv7511->regmap, ADV7511_REG_AUDIO_CFG1,\r\nBIT(5), BIT(5));\r\nregmap_update_bits(adv7511->regmap, ADV7511_REG_PACKET_ENABLE1,\r\nBIT(3), BIT(3));\r\nregmap_update_bits(adv7511->regmap, ADV7511_REG_GC(0),\r\nBIT(7) | BIT(6), BIT(7));\r\nregmap_update_bits(adv7511->regmap, ADV7511_REG_GC(1),\r\nBIT(5), 0);\r\nreturn 0;\r\n}\r\nstatic void audio_shutdown(struct device *dev, void *data)\r\n{\r\n}\r\nstatic int adv7511_hdmi_i2s_get_dai_id(struct snd_soc_component *component,\r\nstruct device_node *endpoint)\r\n{\r\nstruct of_endpoint of_ep;\r\nint ret;\r\nret = of_graph_parse_endpoint(endpoint, &of_ep);\r\nif (ret < 0)\r\nreturn ret;\r\nif (of_ep.port == 2)\r\nreturn 0;\r\nreturn -EINVAL;\r\n}\r\nint adv7511_audio_init(struct device *dev, struct adv7511 *adv7511)\r\n{\r\nadv7511->audio_pdev = platform_device_register_data(dev,\r\nHDMI_CODEC_DRV_NAME,\r\nPLATFORM_DEVID_AUTO,\r\n&codec_data,\r\nsizeof(codec_data));\r\nreturn PTR_ERR_OR_ZERO(adv7511->audio_pdev);\r\n}\r\nvoid adv7511_audio_exit(struct adv7511 *adv7511)\r\n{\r\nif (adv7511->audio_pdev) {\r\nplatform_device_unregister(adv7511->audio_pdev);\r\nadv7511->audio_pdev = NULL;\r\n}\r\n}
