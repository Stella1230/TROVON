static int __init parse_LABC_control(char *arg)\r\n{\r\nif (!arg)\r\nreturn -EINVAL;\r\nif (!strcasecmp(arg, "0"))\r\nLABC_control = 0;\r\nelse if (!strcasecmp(arg, "1"))\r\nLABC_control = 1;\r\nreturn 0;\r\n}\r\nvoid mdfld_dsi_gen_fifo_ready(struct drm_device *dev, u32 gen_fifo_stat_reg,\r\nu32 fifo_stat)\r\n{\r\nu32 GEN_BF_time_out_count;\r\nfor (GEN_BF_time_out_count = 0;\r\nGEN_BF_time_out_count < GEN_FB_TIME_OUT;\r\nGEN_BF_time_out_count++) {\r\nif ((REG_READ(gen_fifo_stat_reg) & fifo_stat) == fifo_stat)\r\nbreak;\r\nudelay(100);\r\n}\r\nif (GEN_BF_time_out_count == GEN_FB_TIME_OUT)\r\nDRM_ERROR("mdfld_dsi_gen_fifo_ready, Timeout. gen_fifo_stat_reg = 0x%x.\n",\r\ngen_fifo_stat_reg);\r\n}\r\nvoid mdfld_dsi_brightness_init(struct mdfld_dsi_config *dsi_config, int pipe)\r\n{\r\nstruct mdfld_dsi_pkg_sender *sender =\r\nmdfld_dsi_get_pkg_sender(dsi_config);\r\nstruct drm_device *dev;\r\nstruct drm_psb_private *dev_priv;\r\nu32 gen_ctrl_val;\r\nif (!sender) {\r\nDRM_ERROR("No sender found\n");\r\nreturn;\r\n}\r\ndev = sender->dev;\r\ndev_priv = dev->dev_private;\r\nmdfld_dsi_send_mcs_short(sender, write_display_brightness, 0xd8, 1,\r\ntrue);\r\nmdfld_dsi_send_mcs_short(sender, write_cabc_min_bright, 0x33, 1, true);\r\ngen_ctrl_val = BRIGHT_CNTL_BLOCK_ON | DISPLAY_DIMMING_ON |\r\nBACKLIGHT_ON;\r\nif (LABC_control == 1)\r\ngen_ctrl_val |= DISPLAY_DIMMING_ON | DISPLAY_BRIGHTNESS_AUTO\r\n| GAMMA_AUTO;\r\nif (LABC_control == 1)\r\ngen_ctrl_val |= AMBIENT_LIGHT_SENSE_ON;\r\ndev_priv->mipi_ctrl_display = gen_ctrl_val;\r\nmdfld_dsi_send_mcs_short(sender, write_ctrl_display, (u8)gen_ctrl_val,\r\n1, true);\r\nmdfld_dsi_send_mcs_short(sender, write_ctrl_cabc, UI_IMAGE, 1, true);\r\n}\r\nvoid mdfld_dsi_brightness_control(struct drm_device *dev, int pipe, int level)\r\n{\r\nstruct mdfld_dsi_pkg_sender *sender;\r\nstruct drm_psb_private *dev_priv;\r\nstruct mdfld_dsi_config *dsi_config;\r\nu32 gen_ctrl_val = 0;\r\nint p_type = TMD_VID;\r\nif (!dev || (pipe != 0 && pipe != 2)) {\r\nDRM_ERROR("Invalid parameter\n");\r\nreturn;\r\n}\r\np_type = mdfld_get_panel_type(dev, 0);\r\ndev_priv = dev->dev_private;\r\nif (pipe)\r\ndsi_config = dev_priv->dsi_configs[1];\r\nelse\r\ndsi_config = dev_priv->dsi_configs[0];\r\nsender = mdfld_dsi_get_pkg_sender(dsi_config);\r\nif (!sender) {\r\nDRM_ERROR("No sender found\n");\r\nreturn;\r\n}\r\ngen_ctrl_val = (level * 0xff / MDFLD_DSI_BRIGHTNESS_MAX_LEVEL) & 0xff;\r\ndev_dbg(sender->dev->dev, "pipe = %d, gen_ctrl_val = %d.\n",\r\npipe, gen_ctrl_val);\r\nif (p_type == TMD_VID) {\r\nmdfld_dsi_send_mcs_short(sender, tmd_write_display_brightness,\r\n(u8)gen_ctrl_val, 1, true);\r\n} else {\r\nmdfld_dsi_send_mcs_short(sender, write_display_brightness,\r\n(u8)gen_ctrl_val, 1, true);\r\nif (level == 0)\r\ngen_ctrl_val = 0;\r\nelse\r\ngen_ctrl_val = dev_priv->mipi_ctrl_display;\r\nmdfld_dsi_send_mcs_short(sender, write_ctrl_display,\r\n(u8)gen_ctrl_val, 1, true);\r\n}\r\n}\r\nstatic int mdfld_dsi_get_panel_status(struct mdfld_dsi_config *dsi_config,\r\nu8 dcs, u32 *data, bool hs)\r\n{\r\nstruct mdfld_dsi_pkg_sender *sender\r\n= mdfld_dsi_get_pkg_sender(dsi_config);\r\nif (!sender || !data) {\r\nDRM_ERROR("Invalid parameter\n");\r\nreturn -EINVAL;\r\n}\r\nreturn mdfld_dsi_read_mcs(sender, dcs, data, 1, hs);\r\n}\r\nint mdfld_dsi_get_power_mode(struct mdfld_dsi_config *dsi_config, u32 *mode,\r\nbool hs)\r\n{\r\nif (!dsi_config || !mode) {\r\nDRM_ERROR("Invalid parameter\n");\r\nreturn -EINVAL;\r\n}\r\nreturn mdfld_dsi_get_panel_status(dsi_config, 0x0a, mode, hs);\r\n}\r\nvoid mdfld_dsi_controller_init(struct mdfld_dsi_config *dsi_config, int pipe)\r\n{\r\nif (!dsi_config || ((pipe != 0) && (pipe != 2))) {\r\nDRM_ERROR("Invalid parameters\n");\r\nreturn;\r\n}\r\nmdfld_dsi_dpi_controller_init(dsi_config, pipe);\r\n}\r\nstatic void mdfld_dsi_connector_save(struct drm_connector *connector)\r\n{\r\n}\r\nstatic void mdfld_dsi_connector_restore(struct drm_connector *connector)\r\n{\r\n}\r\nstatic enum drm_connector_status\r\nmdfld_dsi_connector_detect(struct drm_connector *connector, bool force)\r\n{\r\nstruct mdfld_dsi_connector *dsi_connector\r\n= mdfld_dsi_connector(connector);\r\ndsi_connector->status = connector_status_connected;\r\nreturn dsi_connector->status;\r\n}\r\nstatic int mdfld_dsi_connector_set_property(struct drm_connector *connector,\r\nstruct drm_property *property,\r\nuint64_t value)\r\n{\r\nstruct drm_encoder *encoder = connector->encoder;\r\nif (!strcmp(property->name, "scaling mode") && encoder) {\r\nstruct gma_crtc *gma_crtc = to_gma_crtc(encoder->crtc);\r\nbool centerechange;\r\nuint64_t val;\r\nif (!gma_crtc)\r\ngoto set_prop_error;\r\nswitch (value) {\r\ncase DRM_MODE_SCALE_FULLSCREEN:\r\nbreak;\r\ncase DRM_MODE_SCALE_NO_SCALE:\r\nbreak;\r\ncase DRM_MODE_SCALE_ASPECT:\r\nbreak;\r\ndefault:\r\ngoto set_prop_error;\r\n}\r\nif (drm_object_property_get_value(&connector->base, property, &val))\r\ngoto set_prop_error;\r\nif (val == value)\r\ngoto set_prop_done;\r\nif (drm_object_property_set_value(&connector->base,\r\nproperty, value))\r\ngoto set_prop_error;\r\ncenterechange = (val == DRM_MODE_SCALE_NO_SCALE) ||\r\n(value == DRM_MODE_SCALE_NO_SCALE);\r\nif (gma_crtc->saved_mode.hdisplay != 0 &&\r\ngma_crtc->saved_mode.vdisplay != 0) {\r\nif (centerechange) {\r\nif (!drm_crtc_helper_set_mode(encoder->crtc,\r\n&gma_crtc->saved_mode,\r\nencoder->crtc->x,\r\nencoder->crtc->y,\r\nencoder->crtc->primary->fb))\r\ngoto set_prop_error;\r\n} else {\r\nconst struct drm_encoder_helper_funcs *funcs =\r\nencoder->helper_private;\r\nfuncs->mode_set(encoder,\r\n&gma_crtc->saved_mode,\r\n&gma_crtc->saved_adjusted_mode);\r\n}\r\n}\r\n} else if (!strcmp(property->name, "backlight") && encoder) {\r\nif (drm_object_property_set_value(&connector->base, property,\r\nvalue))\r\ngoto set_prop_error;\r\nelse\r\ngma_backlight_set(encoder->dev, value);\r\n}\r\nset_prop_done:\r\nreturn 0;\r\nset_prop_error:\r\nreturn -1;\r\n}\r\nstatic void mdfld_dsi_connector_destroy(struct drm_connector *connector)\r\n{\r\nstruct mdfld_dsi_connector *dsi_connector =\r\nmdfld_dsi_connector(connector);\r\nstruct mdfld_dsi_pkg_sender *sender;\r\nif (!dsi_connector)\r\nreturn;\r\ndrm_connector_unregister(connector);\r\ndrm_connector_cleanup(connector);\r\nsender = dsi_connector->pkg_sender;\r\nmdfld_dsi_pkg_sender_destroy(sender);\r\nkfree(dsi_connector);\r\n}\r\nstatic int mdfld_dsi_connector_get_modes(struct drm_connector *connector)\r\n{\r\nstruct mdfld_dsi_connector *dsi_connector =\r\nmdfld_dsi_connector(connector);\r\nstruct mdfld_dsi_config *dsi_config =\r\nmdfld_dsi_get_config(dsi_connector);\r\nstruct drm_display_mode *fixed_mode = dsi_config->fixed_mode;\r\nstruct drm_display_mode *dup_mode = NULL;\r\nstruct drm_device *dev = connector->dev;\r\nif (fixed_mode) {\r\ndev_dbg(dev->dev, "fixed_mode %dx%d\n",\r\nfixed_mode->hdisplay, fixed_mode->vdisplay);\r\ndup_mode = drm_mode_duplicate(dev, fixed_mode);\r\ndrm_mode_probed_add(connector, dup_mode);\r\nreturn 1;\r\n}\r\nDRM_ERROR("Didn't get any modes!\n");\r\nreturn 0;\r\n}\r\nstatic int mdfld_dsi_connector_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct mdfld_dsi_connector *dsi_connector =\r\nmdfld_dsi_connector(connector);\r\nstruct mdfld_dsi_config *dsi_config =\r\nmdfld_dsi_get_config(dsi_connector);\r\nstruct drm_display_mode *fixed_mode = dsi_config->fixed_mode;\r\nif (mode->flags & DRM_MODE_FLAG_DBLSCAN)\r\nreturn MODE_NO_DBLESCAN;\r\nif (mode->flags & DRM_MODE_FLAG_INTERLACE)\r\nreturn MODE_NO_INTERLACE;\r\nif (fixed_mode) {\r\nif (mode->hdisplay != fixed_mode->hdisplay)\r\nreturn MODE_PANEL;\r\nif (mode->vdisplay != fixed_mode->vdisplay)\r\nreturn MODE_PANEL;\r\n}\r\nreturn MODE_OK;\r\n}\r\nstatic struct drm_encoder *mdfld_dsi_connector_best_encoder(\r\nstruct drm_connector *connector)\r\n{\r\nstruct mdfld_dsi_connector *dsi_connector =\r\nmdfld_dsi_connector(connector);\r\nstruct mdfld_dsi_config *dsi_config =\r\nmdfld_dsi_get_config(dsi_connector);\r\nreturn &dsi_config->encoder->base.base;\r\n}\r\nstatic int mdfld_dsi_get_default_config(struct drm_device *dev,\r\nstruct mdfld_dsi_config *config, int pipe)\r\n{\r\nif (!dev || !config) {\r\nDRM_ERROR("Invalid parameters");\r\nreturn -EINVAL;\r\n}\r\nconfig->bpp = 24;\r\nif (mdfld_get_panel_type(dev, pipe) == TC35876X)\r\nconfig->lane_count = 4;\r\nelse\r\nconfig->lane_count = 2;\r\nconfig->channel_num = 0;\r\nif (mdfld_get_panel_type(dev, pipe) == TMD_VID)\r\nconfig->video_mode = MDFLD_DSI_VIDEO_NON_BURST_MODE_SYNC_PULSE;\r\nelse if (mdfld_get_panel_type(dev, pipe) == TC35876X)\r\nconfig->video_mode =\r\nMDFLD_DSI_VIDEO_NON_BURST_MODE_SYNC_EVENTS;\r\nelse\r\nconfig->video_mode = MDFLD_DSI_VIDEO_BURST_MODE;\r\nreturn 0;\r\n}\r\nint mdfld_dsi_panel_reset(int pipe)\r\n{\r\nunsigned gpio;\r\nint ret = 0;\r\nswitch (pipe) {\r\ncase 0:\r\ngpio = 128;\r\nbreak;\r\ncase 2:\r\ngpio = 34;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Invalid output\n");\r\nreturn -EINVAL;\r\n}\r\nret = gpio_request(gpio, "gfx");\r\nif (ret) {\r\nDRM_ERROR("gpio_rqueset failed\n");\r\nreturn ret;\r\n}\r\nret = gpio_direction_output(gpio, 1);\r\nif (ret) {\r\nDRM_ERROR("gpio_direction_output failed\n");\r\ngoto gpio_error;\r\n}\r\ngpio_get_value(128);\r\ngpio_error:\r\nif (gpio_is_valid(gpio))\r\ngpio_free(gpio);\r\nreturn ret;\r\n}\r\nvoid mdfld_dsi_output_init(struct drm_device *dev,\r\nint pipe,\r\nconst struct panel_funcs *p_vid_funcs)\r\n{\r\nstruct mdfld_dsi_config *dsi_config;\r\nstruct mdfld_dsi_connector *dsi_connector;\r\nstruct drm_connector *connector;\r\nstruct mdfld_dsi_encoder *encoder;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct panel_info dsi_panel_info;\r\nu32 width_mm, height_mm;\r\ndev_dbg(dev->dev, "init DSI output on pipe %d\n", pipe);\r\nif (pipe != 0 && pipe != 2) {\r\nDRM_ERROR("Invalid parameter\n");\r\nreturn;\r\n}\r\ndsi_connector = kzalloc(sizeof(struct mdfld_dsi_connector), GFP_KERNEL);\r\nif (!dsi_connector) {\r\nDRM_ERROR("No memory");\r\nreturn;\r\n}\r\ndsi_connector->pipe = pipe;\r\ndsi_config = kzalloc(sizeof(struct mdfld_dsi_config),\r\nGFP_KERNEL);\r\nif (!dsi_config) {\r\nDRM_ERROR("cannot allocate memory for DSI config\n");\r\ngoto dsi_init_err0;\r\n}\r\nmdfld_dsi_get_default_config(dev, dsi_config, pipe);\r\ndsi_connector->private = dsi_config;\r\ndsi_config->changed = 1;\r\ndsi_config->dev = dev;\r\ndsi_config->fixed_mode = p_vid_funcs->get_config_mode(dev);\r\nif (p_vid_funcs->get_panel_info(dev, pipe, &dsi_panel_info))\r\ngoto dsi_init_err0;\r\nwidth_mm = dsi_panel_info.width_mm;\r\nheight_mm = dsi_panel_info.height_mm;\r\ndsi_config->mode = dsi_config->fixed_mode;\r\ndsi_config->connector = dsi_connector;\r\nif (!dsi_config->fixed_mode) {\r\nDRM_ERROR("No pannel fixed mode was found\n");\r\ngoto dsi_init_err0;\r\n}\r\nif (pipe && dev_priv->dsi_configs[0]) {\r\ndsi_config->dvr_ic_inited = 0;\r\ndev_priv->dsi_configs[1] = dsi_config;\r\n} else if (pipe == 0) {\r\ndsi_config->dvr_ic_inited = 1;\r\ndev_priv->dsi_configs[0] = dsi_config;\r\n} else {\r\nDRM_ERROR("Trying to init MIPI1 before MIPI0\n");\r\ngoto dsi_init_err0;\r\n}\r\nconnector = &dsi_connector->base.base;\r\ndsi_connector->base.save = mdfld_dsi_connector_save;\r\ndsi_connector->base.restore = mdfld_dsi_connector_restore;\r\ndrm_connector_init(dev, connector, &mdfld_dsi_connector_funcs,\r\nDRM_MODE_CONNECTOR_LVDS);\r\ndrm_connector_helper_add(connector, &mdfld_dsi_connector_helper_funcs);\r\nconnector->display_info.subpixel_order = SubPixelHorizontalRGB;\r\nconnector->display_info.width_mm = width_mm;\r\nconnector->display_info.height_mm = height_mm;\r\nconnector->interlace_allowed = false;\r\nconnector->doublescan_allowed = false;\r\ndrm_object_attach_property(&connector->base,\r\ndev->mode_config.scaling_mode_property,\r\nDRM_MODE_SCALE_FULLSCREEN);\r\ndrm_object_attach_property(&connector->base,\r\ndev_priv->backlight_property,\r\nMDFLD_DSI_BRIGHTNESS_MAX_LEVEL);\r\nif (mdfld_dsi_pkg_sender_init(dsi_connector, pipe)) {\r\nDRM_ERROR("Package Sender initialization failed on pipe %d\n",\r\npipe);\r\ngoto dsi_init_err0;\r\n}\r\nencoder = mdfld_dsi_dpi_init(dev, dsi_connector, p_vid_funcs);\r\nif (!encoder) {\r\nDRM_ERROR("Create DPI encoder failed\n");\r\ngoto dsi_init_err1;\r\n}\r\nencoder->private = dsi_config;\r\ndsi_config->encoder = encoder;\r\nencoder->base.type = (pipe == 0) ? INTEL_OUTPUT_MIPI :\r\nINTEL_OUTPUT_MIPI2;\r\ndrm_connector_register(connector);\r\nreturn;\r\ndsi_init_err1:\r\nmdfld_dsi_pkg_sender_destroy(dsi_connector->pkg_sender);\r\ndrm_connector_cleanup(connector);\r\nkfree(dsi_config->fixed_mode);\r\nkfree(dsi_config);\r\ndsi_init_err0:\r\nkfree(dsi_connector);\r\n}
