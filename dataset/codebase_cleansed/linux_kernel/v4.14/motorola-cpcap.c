static int cpcap_sense_irq(struct regmap *regmap, int irq)\r\n{\r\nint regnum = irq / CPCAP_REGISTER_BITS;\r\nint mask = BIT(irq % CPCAP_REGISTER_BITS);\r\nint reg = CPCAP_REG_INTS1 + (regnum * CPCAP_REGISTER_SIZE);\r\nint err, val;\r\nif (reg < CPCAP_REG_INTS1 || reg > CPCAP_REG_INTS4)\r\nreturn -EINVAL;\r\nerr = regmap_read(regmap, reg, &val);\r\nif (err)\r\nreturn err;\r\nreturn !!(val & mask);\r\n}\r\nint cpcap_sense_virq(struct regmap *regmap, int virq)\r\n{\r\nstruct regmap_irq_chip_data *d = irq_get_chip_data(virq);\r\nint irq_base = regmap_irq_chip_get_base(d);\r\nreturn cpcap_sense_irq(regmap, virq - irq_base);\r\n}\r\nstatic int cpcap_check_revision(struct cpcap_ddata *cpcap)\r\n{\r\nu16 vendor, rev;\r\nint ret;\r\nret = cpcap_get_vendor(&cpcap->spi->dev, cpcap->regmap, &vendor);\r\nif (ret)\r\nreturn ret;\r\nret = cpcap_get_revision(&cpcap->spi->dev, cpcap->regmap, &rev);\r\nif (ret)\r\nreturn ret;\r\ndev_info(&cpcap->spi->dev, "CPCAP vendor: %s rev: %i.%i (%x)\n",\r\nvendor == CPCAP_VENDOR_ST ? "ST" : "TI",\r\nCPCAP_REVISION_MAJOR(rev), CPCAP_REVISION_MINOR(rev),\r\nrev);\r\nif (rev < CPCAP_REVISION_2_1) {\r\ndev_info(&cpcap->spi->dev,\r\n"Please add old CPCAP revision support as needed\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void cpcap_init_one_regmap_irq(struct cpcap_ddata *cpcap,\r\nstruct regmap_irq *rirq,\r\nint irq_base, int irq)\r\n{\r\nunsigned int reg_offset;\r\nunsigned int bit, mask;\r\nreg_offset = irq - irq_base;\r\nreg_offset /= cpcap->regmap_conf->val_bits;\r\nreg_offset *= cpcap->regmap_conf->reg_stride;\r\nbit = irq % cpcap->regmap_conf->val_bits;\r\nmask = (1 << bit);\r\nrirq->reg_offset = reg_offset;\r\nrirq->mask = mask;\r\n}\r\nstatic int cpcap_init_irq_chip(struct cpcap_ddata *cpcap, int irq_chip,\r\nint irq_start, int nr_irqs)\r\n{\r\nstruct regmap_irq_chip *chip = &cpcap_irq_chip[irq_chip];\r\nint i, ret;\r\nfor (i = irq_start; i < irq_start + nr_irqs; i++) {\r\nstruct regmap_irq *rirq = &cpcap->irqs[i];\r\ncpcap_init_one_regmap_irq(cpcap, rirq, irq_start, i);\r\n}\r\nchip->irqs = &cpcap->irqs[irq_start];\r\nchip->num_irqs = nr_irqs;\r\nchip->irq_drv_data = cpcap;\r\nret = devm_regmap_add_irq_chip(&cpcap->spi->dev, cpcap->regmap,\r\ncpcap->spi->irq,\r\nirq_get_trigger_type(cpcap->spi->irq) |\r\nIRQF_SHARED, -1,\r\nchip, &cpcap->irqdata[irq_chip]);\r\nif (ret) {\r\ndev_err(&cpcap->spi->dev, "could not add irq chip %i: %i\n",\r\nirq_chip, ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cpcap_init_irq(struct cpcap_ddata *cpcap)\r\n{\r\nint ret;\r\ncpcap->irqs = devm_kzalloc(&cpcap->spi->dev,\r\nsizeof(*cpcap->irqs) *\r\nCPCAP_NR_IRQ_REG_BANKS *\r\ncpcap->regmap_conf->val_bits,\r\nGFP_KERNEL);\r\nif (!cpcap->irqs)\r\nreturn -ENOMEM;\r\nret = cpcap_init_irq_chip(cpcap, 0, 0, 16);\r\nif (ret)\r\nreturn ret;\r\nret = cpcap_init_irq_chip(cpcap, 1, 16, 16);\r\nif (ret)\r\nreturn ret;\r\nret = cpcap_init_irq_chip(cpcap, 2, 32, 64);\r\nif (ret)\r\nreturn ret;\r\nenable_irq_wake(cpcap->spi->irq);\r\nreturn 0;\r\n}\r\nstatic int cpcap_probe(struct spi_device *spi)\r\n{\r\nconst struct of_device_id *match;\r\nstruct cpcap_ddata *cpcap;\r\nint ret;\r\nmatch = of_match_device(of_match_ptr(cpcap_of_match), &spi->dev);\r\nif (!match)\r\nreturn -ENODEV;\r\ncpcap = devm_kzalloc(&spi->dev, sizeof(*cpcap), GFP_KERNEL);\r\nif (!cpcap)\r\nreturn -ENOMEM;\r\ncpcap->spi = spi;\r\nspi_set_drvdata(spi, cpcap);\r\nspi->bits_per_word = 16;\r\nspi->mode = SPI_MODE_0 | SPI_CS_HIGH;\r\nret = spi_setup(spi);\r\nif (ret)\r\nreturn ret;\r\ncpcap->regmap_conf = &cpcap_regmap_config;\r\ncpcap->regmap = devm_regmap_init_spi(spi, &cpcap_regmap_config);\r\nif (IS_ERR(cpcap->regmap)) {\r\nret = PTR_ERR(cpcap->regmap);\r\ndev_err(&cpcap->spi->dev, "Failed to initialize regmap: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nret = cpcap_check_revision(cpcap);\r\nif (ret) {\r\ndev_err(&cpcap->spi->dev, "Failed to detect CPCAP: %i\n", ret);\r\nreturn ret;\r\n}\r\nret = cpcap_init_irq(cpcap);\r\nif (ret)\r\nreturn ret;\r\nreturn devm_of_platform_populate(&cpcap->spi->dev);\r\n}
