static unsigned HOST_WIDE_INT get_random_const(void)\r\n{\r\nunsigned int i;\r\nunsigned HOST_WIDE_INT ret = 0;\r\nfor (i = 0; i < 8 * sizeof(ret); i++) {\r\nret = (ret << 1) | (seed & 1);\r\nseed >>= 1;\r\nif (ret & 1)\r\nseed ^= 0xD800000000000000ULL;\r\n}\r\nreturn ret;\r\n}\r\nstatic tree tree_get_random_const(tree type)\r\n{\r\nunsigned long long mask;\r\nmask = 1ULL << (TREE_INT_CST_LOW(TYPE_SIZE(type)) - 1);\r\nmask = 2 * (mask - 1) + 1;\r\nif (TYPE_UNSIGNED(type))\r\nreturn build_int_cstu(type, mask & get_random_const());\r\nreturn build_int_cst(type, mask & get_random_const());\r\n}\r\nstatic tree handle_latent_entropy_attribute(tree *node, tree name,\r\ntree args __unused,\r\nint flags __unused,\r\nbool *no_add_attrs)\r\n{\r\ntree type;\r\n#if BUILDING_GCC_VERSION <= 4007\r\nVEC(constructor_elt, gc) *vals;\r\n#else\r\nvec<constructor_elt, va_gc> *vals;\r\n#endif\r\nswitch (TREE_CODE(*node)) {\r\ndefault:\r\n*no_add_attrs = true;\r\nerror("%qE attribute only applies to functions and variables",\r\nname);\r\nbreak;\r\ncase VAR_DECL:\r\nif (DECL_INITIAL(*node)) {\r\n*no_add_attrs = true;\r\nerror("variable %qD with %qE attribute must not be initialized",\r\n*node, name);\r\nbreak;\r\n}\r\nif (!TREE_STATIC(*node)) {\r\n*no_add_attrs = true;\r\nerror("variable %qD with %qE attribute must not be local",\r\n*node, name);\r\nbreak;\r\n}\r\ntype = TREE_TYPE(*node);\r\nswitch (TREE_CODE(type)) {\r\ndefault:\r\n*no_add_attrs = true;\r\nerror("variable %qD with %qE attribute must be an integer or a fixed length integer array type or a fixed sized structure with integer fields",\r\n*node, name);\r\nbreak;\r\ncase RECORD_TYPE: {\r\ntree fld, lst = TYPE_FIELDS(type);\r\nunsigned int nelt = 0;\r\nfor (fld = lst; fld; nelt++, fld = TREE_CHAIN(fld)) {\r\ntree fieldtype;\r\nfieldtype = TREE_TYPE(fld);\r\nif (TREE_CODE(fieldtype) == INTEGER_TYPE)\r\ncontinue;\r\n*no_add_attrs = true;\r\nerror("structure variable %qD with %qE attribute has a non-integer field %qE",\r\n*node, name, fld);\r\nbreak;\r\n}\r\nif (fld)\r\nbreak;\r\n#if BUILDING_GCC_VERSION <= 4007\r\nvals = VEC_alloc(constructor_elt, gc, nelt);\r\n#else\r\nvec_alloc(vals, nelt);\r\n#endif\r\nfor (fld = lst; fld; fld = TREE_CHAIN(fld)) {\r\ntree random_const, fld_t = TREE_TYPE(fld);\r\nrandom_const = tree_get_random_const(fld_t);\r\nCONSTRUCTOR_APPEND_ELT(vals, fld, random_const);\r\n}\r\nDECL_INITIAL(*node) = build_constructor(type, vals);\r\nbreak;\r\n}\r\ncase INTEGER_TYPE:\r\nDECL_INITIAL(*node) = tree_get_random_const(type);\r\nbreak;\r\ncase ARRAY_TYPE: {\r\ntree elt_type, array_size, elt_size;\r\nunsigned int i, nelt;\r\nHOST_WIDE_INT array_size_int, elt_size_int;\r\nelt_type = TREE_TYPE(type);\r\nelt_size = TYPE_SIZE_UNIT(TREE_TYPE(type));\r\narray_size = TYPE_SIZE_UNIT(type);\r\nif (TREE_CODE(elt_type) != INTEGER_TYPE || !array_size\r\n|| TREE_CODE(array_size) != INTEGER_CST) {\r\n*no_add_attrs = true;\r\nerror("array variable %qD with %qE attribute must be a fixed length integer array type",\r\n*node, name);\r\nbreak;\r\n}\r\narray_size_int = TREE_INT_CST_LOW(array_size);\r\nelt_size_int = TREE_INT_CST_LOW(elt_size);\r\nnelt = array_size_int / elt_size_int;\r\n#if BUILDING_GCC_VERSION <= 4007\r\nvals = VEC_alloc(constructor_elt, gc, nelt);\r\n#else\r\nvec_alloc(vals, nelt);\r\n#endif\r\nfor (i = 0; i < nelt; i++) {\r\ntree cst = size_int(i);\r\ntree rand_cst = tree_get_random_const(elt_type);\r\nCONSTRUCTOR_APPEND_ELT(vals, cst, rand_cst);\r\n}\r\nDECL_INITIAL(*node) = build_constructor(type, vals);\r\nbreak;\r\n}\r\n}\r\nbreak;\r\ncase FUNCTION_DECL:\r\nbreak;\r\n}\r\nreturn NULL_TREE;\r\n}\r\nstatic void register_attributes(void *event_data __unused, void *data __unused)\r\n{\r\nregister_attribute(&latent_entropy_attr);\r\n}\r\nstatic bool latent_entropy_gate(void)\r\n{\r\ntree list;\r\nif (TREE_THIS_VOLATILE(current_function_decl))\r\nreturn false;\r\nif (EDGE_COUNT(EXIT_BLOCK_PTR_FOR_FN(cfun)->preds) == 0)\r\nreturn false;\r\nlist = DECL_ATTRIBUTES(current_function_decl);\r\nreturn lookup_attribute("latent_entropy", list) != NULL_TREE;\r\n}\r\nstatic tree create_var(tree type, const char *name)\r\n{\r\ntree var;\r\nvar = create_tmp_var(type, name);\r\nadd_referenced_var(var);\r\nmark_sym_for_renaming(var);\r\nreturn var;\r\n}\r\nstatic enum tree_code get_op(tree *rhs)\r\n{\r\nstatic enum tree_code op;\r\nunsigned HOST_WIDE_INT random_const;\r\nrandom_const = get_random_const();\r\nswitch (op) {\r\ncase BIT_XOR_EXPR:\r\nop = PLUS_EXPR;\r\nbreak;\r\ncase PLUS_EXPR:\r\nif (rhs) {\r\nop = LROTATE_EXPR;\r\nrandom_const %= TYPE_PRECISION(long_unsigned_type_node);\r\nbreak;\r\n}\r\ncase LROTATE_EXPR:\r\ndefault:\r\nop = BIT_XOR_EXPR;\r\nbreak;\r\n}\r\nif (rhs)\r\n*rhs = build_int_cstu(long_unsigned_type_node, random_const);\r\nreturn op;\r\n}\r\nstatic gimple create_assign(enum tree_code code, tree lhs, tree op1,\r\ntree op2)\r\n{\r\nreturn gimple_build_assign_with_ops(code, lhs, op1, op2);\r\n}\r\nstatic void perturb_local_entropy(basic_block bb, tree local_entropy)\r\n{\r\ngimple_stmt_iterator gsi;\r\ngimple assign;\r\ntree rhs;\r\nenum tree_code op;\r\nop = get_op(&rhs);\r\nassign = create_assign(op, local_entropy, local_entropy, rhs);\r\ngsi = gsi_after_labels(bb);\r\ngsi_insert_before(&gsi, assign, GSI_NEW_STMT);\r\nupdate_stmt(assign);\r\n}\r\nstatic void __perturb_latent_entropy(gimple_stmt_iterator *gsi,\r\ntree local_entropy)\r\n{\r\ngimple assign;\r\ntree temp;\r\nenum tree_code op;\r\ntemp = create_var(long_unsigned_type_node, "temp_latent_entropy");\r\nadd_referenced_var(latent_entropy_decl);\r\nmark_sym_for_renaming(latent_entropy_decl);\r\nassign = gimple_build_assign(temp, latent_entropy_decl);\r\ngsi_insert_before(gsi, assign, GSI_NEW_STMT);\r\nupdate_stmt(assign);\r\nop = get_op(NULL);\r\nassign = create_assign(op, temp, temp, local_entropy);\r\ngsi_insert_after(gsi, assign, GSI_NEW_STMT);\r\nupdate_stmt(assign);\r\nassign = gimple_build_assign(latent_entropy_decl, temp);\r\ngsi_insert_after(gsi, assign, GSI_NEW_STMT);\r\nupdate_stmt(assign);\r\n}\r\nstatic bool handle_tail_calls(basic_block bb, tree local_entropy)\r\n{\r\ngimple_stmt_iterator gsi;\r\nfor (gsi = gsi_start_bb(bb); !gsi_end_p(gsi); gsi_next(&gsi)) {\r\ngcall *call;\r\ngimple stmt = gsi_stmt(gsi);\r\nif (!is_gimple_call(stmt))\r\ncontinue;\r\ncall = as_a_gcall(stmt);\r\nif (!gimple_call_tail_p(call))\r\ncontinue;\r\n__perturb_latent_entropy(&gsi, local_entropy);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void perturb_latent_entropy(tree local_entropy)\r\n{\r\nedge_iterator ei;\r\nedge e, last_bb_e;\r\nbasic_block last_bb;\r\ngcc_assert(single_pred_p(EXIT_BLOCK_PTR_FOR_FN(cfun)));\r\nlast_bb_e = single_pred_edge(EXIT_BLOCK_PTR_FOR_FN(cfun));\r\nFOR_EACH_EDGE(e, ei, last_bb_e->src->preds) {\r\nif (ENTRY_BLOCK_PTR_FOR_FN(cfun) == e->src)\r\ncontinue;\r\nif (EXIT_BLOCK_PTR_FOR_FN(cfun) == e->src)\r\ncontinue;\r\nhandle_tail_calls(e->src, local_entropy);\r\n}\r\nlast_bb = single_pred(EXIT_BLOCK_PTR_FOR_FN(cfun));\r\nif (!handle_tail_calls(last_bb, local_entropy)) {\r\ngimple_stmt_iterator gsi = gsi_last_bb(last_bb);\r\n__perturb_latent_entropy(&gsi, local_entropy);\r\n}\r\n}\r\nstatic void init_local_entropy(basic_block bb, tree local_entropy)\r\n{\r\ngimple assign, call;\r\ntree frame_addr, rand_const, tmp, fndecl, udi_frame_addr;\r\nenum tree_code op;\r\nunsigned HOST_WIDE_INT rand_cst;\r\ngimple_stmt_iterator gsi = gsi_after_labels(bb);\r\nframe_addr = create_var(ptr_type_node, "local_entropy_frameaddr");\r\nfndecl = builtin_decl_implicit(BUILT_IN_FRAME_ADDRESS);\r\ncall = gimple_build_call(fndecl, 1, integer_zero_node);\r\ngimple_call_set_lhs(call, frame_addr);\r\ngsi_insert_before(&gsi, call, GSI_NEW_STMT);\r\nupdate_stmt(call);\r\nudi_frame_addr = fold_convert(long_unsigned_type_node, frame_addr);\r\nassign = gimple_build_assign(local_entropy, udi_frame_addr);\r\ngsi_insert_after(&gsi, assign, GSI_NEW_STMT);\r\nupdate_stmt(assign);\r\ntmp = create_var(long_unsigned_type_node, "temp_latent_entropy");\r\nadd_referenced_var(latent_entropy_decl);\r\nmark_sym_for_renaming(latent_entropy_decl);\r\nassign = gimple_build_assign(tmp, latent_entropy_decl);\r\ngsi_insert_after(&gsi, assign, GSI_NEW_STMT);\r\nupdate_stmt(assign);\r\nassign = create_assign(BIT_XOR_EXPR, local_entropy, local_entropy, tmp);\r\ngsi_insert_after(&gsi, assign, GSI_NEW_STMT);\r\nupdate_stmt(assign);\r\nrand_cst = get_random_const();\r\nrand_const = build_int_cstu(long_unsigned_type_node, rand_cst);\r\nop = get_op(NULL);\r\nassign = create_assign(op, local_entropy, local_entropy, rand_const);\r\ngsi_insert_after(&gsi, assign, GSI_NEW_STMT);\r\nupdate_stmt(assign);\r\n}\r\nstatic bool create_latent_entropy_decl(void)\r\n{\r\nvarpool_node_ptr node;\r\nif (latent_entropy_decl != NULL_TREE)\r\nreturn true;\r\nFOR_EACH_VARIABLE(node) {\r\ntree name, var = NODE_DECL(node);\r\nif (DECL_NAME_LENGTH(var) < sizeof("latent_entropy") - 1)\r\ncontinue;\r\nname = DECL_NAME(var);\r\nif (strcmp(IDENTIFIER_POINTER(name), "latent_entropy"))\r\ncontinue;\r\nlatent_entropy_decl = var;\r\nbreak;\r\n}\r\nreturn latent_entropy_decl != NULL_TREE;\r\n}\r\nstatic unsigned int latent_entropy_execute(void)\r\n{\r\nbasic_block bb;\r\ntree local_entropy;\r\nif (!create_latent_entropy_decl())\r\nreturn 0;\r\ngcc_assert(single_succ_p(ENTRY_BLOCK_PTR_FOR_FN(cfun)));\r\nbb = single_succ(ENTRY_BLOCK_PTR_FOR_FN(cfun));\r\nif (!single_pred_p(bb)) {\r\nsplit_edge(single_succ_edge(ENTRY_BLOCK_PTR_FOR_FN(cfun)));\r\ngcc_assert(single_succ_p(ENTRY_BLOCK_PTR_FOR_FN(cfun)));\r\nbb = single_succ(ENTRY_BLOCK_PTR_FOR_FN(cfun));\r\n}\r\nlocal_entropy = create_var(long_unsigned_type_node, "local_entropy");\r\ninit_local_entropy(bb, local_entropy);\r\nbb = bb->next_bb;\r\nwhile (bb != EXIT_BLOCK_PTR_FOR_FN(cfun)) {\r\nperturb_local_entropy(bb, local_entropy);\r\nbb = bb->next_bb;\r\n};\r\nperturb_latent_entropy(local_entropy);\r\nreturn 0;\r\n}\r\nstatic void latent_entropy_start_unit(void *gcc_data __unused,\r\nvoid *user_data __unused)\r\n{\r\ntree type, id;\r\nint quals;\r\nseed = get_random_seed(false);\r\nif (in_lto_p)\r\nreturn;\r\nquals = TYPE_QUALS(long_unsigned_type_node) | TYPE_QUAL_VOLATILE;\r\ntype = build_qualified_type(long_unsigned_type_node, quals);\r\nid = get_identifier("latent_entropy");\r\nlatent_entropy_decl = build_decl(UNKNOWN_LOCATION, VAR_DECL, id, type);\r\nTREE_STATIC(latent_entropy_decl) = 1;\r\nTREE_PUBLIC(latent_entropy_decl) = 1;\r\nTREE_USED(latent_entropy_decl) = 1;\r\nDECL_PRESERVE_P(latent_entropy_decl) = 1;\r\nTREE_THIS_VOLATILE(latent_entropy_decl) = 1;\r\nDECL_EXTERNAL(latent_entropy_decl) = 1;\r\nDECL_ARTIFICIAL(latent_entropy_decl) = 1;\r\nlang_hooks.decls.pushdecl(latent_entropy_decl);\r\n}\r\n__visible int plugin_init(struct plugin_name_args *plugin_info,\r\nstruct plugin_gcc_version *version)\r\n{\r\nbool enabled = true;\r\nconst char * const plugin_name = plugin_info->base_name;\r\nconst int argc = plugin_info->argc;\r\nconst struct plugin_argument * const argv = plugin_info->argv;\r\nint i;\r\nstatic const struct ggc_root_tab gt_ggc_r_gt_latent_entropy[] = {\r\n{\r\n.base = &latent_entropy_decl,\r\n.nelt = 1,\r\n.stride = sizeof(latent_entropy_decl),\r\n.cb = &gt_ggc_mx_tree_node,\r\n.pchw = &gt_pch_nx_tree_node\r\n},\r\nLAST_GGC_ROOT_TAB\r\n};\r\nPASS_INFO(latent_entropy, "optimized", 1, PASS_POS_INSERT_BEFORE);\r\nif (!plugin_default_version_check(version, &gcc_version)) {\r\nerror(G_("incompatible gcc/plugin versions"));\r\nreturn 1;\r\n}\r\nfor (i = 0; i < argc; ++i) {\r\nif (!(strcmp(argv[i].key, "disable"))) {\r\nenabled = false;\r\ncontinue;\r\n}\r\nerror(G_("unknown option '-fplugin-arg-%s-%s'"), plugin_name, argv[i].key);\r\n}\r\nregister_callback(plugin_name, PLUGIN_INFO, NULL,\r\n&latent_entropy_plugin_info);\r\nif (enabled) {\r\nregister_callback(plugin_name, PLUGIN_START_UNIT,\r\n&latent_entropy_start_unit, NULL);\r\nregister_callback(plugin_name, PLUGIN_REGISTER_GGC_ROOTS,\r\nNULL, (void *)&gt_ggc_r_gt_latent_entropy);\r\nregister_callback(plugin_name, PLUGIN_PASS_MANAGER_SETUP, NULL,\r\n&latent_entropy_pass_info);\r\n}\r\nregister_callback(plugin_name, PLUGIN_ATTRIBUTES, register_attributes,\r\nNULL);\r\nreturn 0;\r\n}
