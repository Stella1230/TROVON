static void i2c_mux_gpio_set(const struct gpiomux *mux, unsigned val)\r\n{\r\nint i;\r\nfor (i = 0; i < mux->data.n_gpios; i++)\r\nmux->values[i] = (val >> i) & 1;\r\ngpiod_set_array_value_cansleep(mux->data.n_gpios,\r\nmux->gpios, mux->values);\r\n}\r\nstatic int i2c_mux_gpio_select(struct i2c_mux_core *muxc, u32 chan)\r\n{\r\nstruct gpiomux *mux = i2c_mux_priv(muxc);\r\ni2c_mux_gpio_set(mux, chan);\r\nreturn 0;\r\n}\r\nstatic int i2c_mux_gpio_deselect(struct i2c_mux_core *muxc, u32 chan)\r\n{\r\nstruct gpiomux *mux = i2c_mux_priv(muxc);\r\ni2c_mux_gpio_set(mux, mux->data.idle);\r\nreturn 0;\r\n}\r\nstatic int match_gpio_chip_by_label(struct gpio_chip *chip,\r\nvoid *data)\r\n{\r\nreturn !strcmp(chip->label, data);\r\n}\r\nstatic int i2c_mux_gpio_probe_dt(struct gpiomux *mux,\r\nstruct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct device_node *adapter_np, *child;\r\nstruct i2c_adapter *adapter;\r\nunsigned *values, *gpios;\r\nint i = 0, ret;\r\nif (!np)\r\nreturn -ENODEV;\r\nadapter_np = of_parse_phandle(np, "i2c-parent", 0);\r\nif (!adapter_np) {\r\ndev_err(&pdev->dev, "Cannot parse i2c-parent\n");\r\nreturn -ENODEV;\r\n}\r\nadapter = of_find_i2c_adapter_by_node(adapter_np);\r\nof_node_put(adapter_np);\r\nif (!adapter)\r\nreturn -EPROBE_DEFER;\r\nmux->data.parent = i2c_adapter_id(adapter);\r\nput_device(&adapter->dev);\r\nmux->data.n_values = of_get_child_count(np);\r\nvalues = devm_kzalloc(&pdev->dev,\r\nsizeof(*mux->data.values) * mux->data.n_values,\r\nGFP_KERNEL);\r\nif (!values) {\r\ndev_err(&pdev->dev, "Cannot allocate values array");\r\nreturn -ENOMEM;\r\n}\r\nfor_each_child_of_node(np, child) {\r\nof_property_read_u32(child, "reg", values + i);\r\ni++;\r\n}\r\nmux->data.values = values;\r\nif (of_property_read_u32(np, "idle-state", &mux->data.idle))\r\nmux->data.idle = I2C_MUX_GPIO_NO_IDLE;\r\nmux->data.n_gpios = of_gpio_named_count(np, "mux-gpios");\r\nif (mux->data.n_gpios < 0) {\r\ndev_err(&pdev->dev, "Missing mux-gpios property in the DT.\n");\r\nreturn -EINVAL;\r\n}\r\ngpios = devm_kzalloc(&pdev->dev,\r\nsizeof(*mux->data.gpios) * mux->data.n_gpios, GFP_KERNEL);\r\nif (!gpios) {\r\ndev_err(&pdev->dev, "Cannot allocate gpios array");\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < mux->data.n_gpios; i++) {\r\nret = of_get_named_gpio(np, "mux-gpios", i);\r\nif (ret < 0)\r\nreturn ret;\r\ngpios[i] = ret;\r\n}\r\nmux->data.gpios = gpios;\r\nreturn 0;\r\n}\r\nstatic int i2c_mux_gpio_probe_dt(struct gpiomux *mux,\r\nstruct platform_device *pdev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int i2c_mux_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct i2c_mux_core *muxc;\r\nstruct gpiomux *mux;\r\nstruct i2c_adapter *parent;\r\nstruct i2c_adapter *root;\r\nunsigned initial_state, gpio_base;\r\nint i, ret;\r\nmux = devm_kzalloc(&pdev->dev, sizeof(*mux), GFP_KERNEL);\r\nif (!mux)\r\nreturn -ENOMEM;\r\nif (!dev_get_platdata(&pdev->dev)) {\r\nret = i2c_mux_gpio_probe_dt(mux, pdev);\r\nif (ret < 0)\r\nreturn ret;\r\n} else {\r\nmemcpy(&mux->data, dev_get_platdata(&pdev->dev),\r\nsizeof(mux->data));\r\n}\r\nif (mux->data.gpio_chip) {\r\nstruct gpio_chip *gpio;\r\ngpio = gpiochip_find(mux->data.gpio_chip,\r\nmatch_gpio_chip_by_label);\r\nif (!gpio)\r\nreturn -EPROBE_DEFER;\r\ngpio_base = gpio->base;\r\n} else {\r\ngpio_base = 0;\r\n}\r\nparent = i2c_get_adapter(mux->data.parent);\r\nif (!parent)\r\nreturn -EPROBE_DEFER;\r\nmuxc = i2c_mux_alloc(parent, &pdev->dev, mux->data.n_values,\r\nmux->data.n_gpios * sizeof(*mux->gpios) +\r\nmux->data.n_gpios * sizeof(*mux->values), 0,\r\ni2c_mux_gpio_select, NULL);\r\nif (!muxc) {\r\nret = -ENOMEM;\r\ngoto alloc_failed;\r\n}\r\nmux->gpios = muxc->priv;\r\nmux->values = (int *)(mux->gpios + mux->data.n_gpios);\r\nmuxc->priv = mux;\r\nplatform_set_drvdata(pdev, muxc);\r\nroot = i2c_root_adapter(&parent->dev);\r\nmuxc->mux_locked = true;\r\nmux->gpio_base = gpio_base;\r\nif (mux->data.idle != I2C_MUX_GPIO_NO_IDLE) {\r\ninitial_state = mux->data.idle;\r\nmuxc->deselect = i2c_mux_gpio_deselect;\r\n} else {\r\ninitial_state = mux->data.values[0];\r\n}\r\nfor (i = 0; i < mux->data.n_gpios; i++) {\r\nstruct device *gpio_dev;\r\nstruct gpio_desc *gpio_desc;\r\nret = gpio_request(gpio_base + mux->data.gpios[i], "i2c-mux-gpio");\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to request GPIO %d\n",\r\nmux->data.gpios[i]);\r\ngoto err_request_gpio;\r\n}\r\nret = gpio_direction_output(gpio_base + mux->data.gpios[i],\r\ninitial_state & (1 << i));\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"Failed to set direction of GPIO %d to output\n",\r\nmux->data.gpios[i]);\r\ni++;\r\ngoto err_request_gpio;\r\n}\r\ngpio_desc = gpio_to_desc(gpio_base + mux->data.gpios[i]);\r\nmux->gpios[i] = gpio_desc;\r\nif (!muxc->mux_locked)\r\ncontinue;\r\ngpio_dev = &gpio_desc->gdev->dev;\r\nmuxc->mux_locked = i2c_root_adapter(gpio_dev) == root;\r\n}\r\nif (muxc->mux_locked)\r\ndev_info(&pdev->dev, "mux-locked i2c mux\n");\r\nfor (i = 0; i < mux->data.n_values; i++) {\r\nu32 nr = mux->data.base_nr ? (mux->data.base_nr + i) : 0;\r\nunsigned int class = mux->data.classes ? mux->data.classes[i] : 0;\r\nret = i2c_mux_add_adapter(muxc, nr, mux->data.values[i], class);\r\nif (ret)\r\ngoto add_adapter_failed;\r\n}\r\ndev_info(&pdev->dev, "%d port mux on %s adapter\n",\r\nmux->data.n_values, parent->name);\r\nreturn 0;\r\nadd_adapter_failed:\r\ni2c_mux_del_adapters(muxc);\r\ni = mux->data.n_gpios;\r\nerr_request_gpio:\r\nfor (; i > 0; i--)\r\ngpio_free(gpio_base + mux->data.gpios[i - 1]);\r\nalloc_failed:\r\ni2c_put_adapter(parent);\r\nreturn ret;\r\n}\r\nstatic int i2c_mux_gpio_remove(struct platform_device *pdev)\r\n{\r\nstruct i2c_mux_core *muxc = platform_get_drvdata(pdev);\r\nstruct gpiomux *mux = i2c_mux_priv(muxc);\r\nint i;\r\ni2c_mux_del_adapters(muxc);\r\nfor (i = 0; i < mux->data.n_gpios; i++)\r\ngpio_free(mux->gpio_base + mux->data.gpios[i]);\r\ni2c_put_adapter(muxc->parent);\r\nreturn 0;\r\n}
