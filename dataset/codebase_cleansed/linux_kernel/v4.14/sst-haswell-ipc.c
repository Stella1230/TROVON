static inline u32 msg_get_global_type(u32 msg)\r\n{\r\nreturn (msg & IPC_GLB_TYPE_MASK) >> IPC_GLB_TYPE_SHIFT;\r\n}\r\nstatic inline u32 msg_get_global_reply(u32 msg)\r\n{\r\nreturn (msg & IPC_GLB_REPLY_MASK) >> IPC_GLB_REPLY_SHIFT;\r\n}\r\nstatic inline u32 msg_get_stream_type(u32 msg)\r\n{\r\nreturn (msg & IPC_STR_TYPE_MASK) >> IPC_STR_TYPE_SHIFT;\r\n}\r\nstatic inline u32 msg_get_stage_type(u32 msg)\r\n{\r\nreturn (msg & IPC_STG_TYPE_MASK) >> IPC_STG_TYPE_SHIFT;\r\n}\r\nstatic inline u32 msg_get_stream_id(u32 msg)\r\n{\r\nreturn (msg & IPC_STR_ID_MASK) >> IPC_STR_ID_SHIFT;\r\n}\r\nstatic inline u32 msg_get_notify_reason(u32 msg)\r\n{\r\nreturn (msg & IPC_STG_TYPE_MASK) >> IPC_STG_TYPE_SHIFT;\r\n}\r\nstatic inline u32 msg_get_module_operation(u32 msg)\r\n{\r\nreturn (msg & IPC_MODULE_OPERATION_MASK) >> IPC_MODULE_OPERATION_SHIFT;\r\n}\r\nstatic inline u32 msg_get_module_id(u32 msg)\r\n{\r\nreturn (msg & IPC_MODULE_ID_MASK) >> IPC_MODULE_ID_SHIFT;\r\n}\r\nu32 create_channel_map(enum sst_hsw_channel_config config)\r\n{\r\nswitch (config) {\r\ncase SST_HSW_CHANNEL_CONFIG_MONO:\r\nreturn (0xFFFFFFF0 | SST_HSW_CHANNEL_CENTER);\r\ncase SST_HSW_CHANNEL_CONFIG_STEREO:\r\nreturn (0xFFFFFF00 | SST_HSW_CHANNEL_LEFT\r\n| (SST_HSW_CHANNEL_RIGHT << 4));\r\ncase SST_HSW_CHANNEL_CONFIG_2_POINT_1:\r\nreturn (0xFFFFF000 | SST_HSW_CHANNEL_LEFT\r\n| (SST_HSW_CHANNEL_RIGHT << 4)\r\n| (SST_HSW_CHANNEL_LFE << 8 ));\r\ncase SST_HSW_CHANNEL_CONFIG_3_POINT_0:\r\nreturn (0xFFFFF000 | SST_HSW_CHANNEL_LEFT\r\n| (SST_HSW_CHANNEL_CENTER << 4)\r\n| (SST_HSW_CHANNEL_RIGHT << 8));\r\ncase SST_HSW_CHANNEL_CONFIG_3_POINT_1:\r\nreturn (0xFFFF0000 | SST_HSW_CHANNEL_LEFT\r\n| (SST_HSW_CHANNEL_CENTER << 4)\r\n| (SST_HSW_CHANNEL_RIGHT << 8)\r\n| (SST_HSW_CHANNEL_LFE << 12));\r\ncase SST_HSW_CHANNEL_CONFIG_QUATRO:\r\nreturn (0xFFFF0000 | SST_HSW_CHANNEL_LEFT\r\n| (SST_HSW_CHANNEL_RIGHT << 4)\r\n| (SST_HSW_CHANNEL_LEFT_SURROUND << 8)\r\n| (SST_HSW_CHANNEL_RIGHT_SURROUND << 12));\r\ncase SST_HSW_CHANNEL_CONFIG_4_POINT_0:\r\nreturn (0xFFFF0000 | SST_HSW_CHANNEL_LEFT\r\n| (SST_HSW_CHANNEL_CENTER << 4)\r\n| (SST_HSW_CHANNEL_RIGHT << 8)\r\n| (SST_HSW_CHANNEL_CENTER_SURROUND << 12));\r\ncase SST_HSW_CHANNEL_CONFIG_5_POINT_0:\r\nreturn (0xFFF00000 | SST_HSW_CHANNEL_LEFT\r\n| (SST_HSW_CHANNEL_CENTER << 4)\r\n| (SST_HSW_CHANNEL_RIGHT << 8)\r\n| (SST_HSW_CHANNEL_LEFT_SURROUND << 12)\r\n| (SST_HSW_CHANNEL_RIGHT_SURROUND << 16));\r\ncase SST_HSW_CHANNEL_CONFIG_5_POINT_1:\r\nreturn (0xFF000000 | SST_HSW_CHANNEL_CENTER\r\n| (SST_HSW_CHANNEL_LEFT << 4)\r\n| (SST_HSW_CHANNEL_RIGHT << 8)\r\n| (SST_HSW_CHANNEL_LEFT_SURROUND << 12)\r\n| (SST_HSW_CHANNEL_RIGHT_SURROUND << 16)\r\n| (SST_HSW_CHANNEL_LFE << 20));\r\ncase SST_HSW_CHANNEL_CONFIG_DUAL_MONO:\r\nreturn (0xFFFFFF00 | SST_HSW_CHANNEL_LEFT\r\n| (SST_HSW_CHANNEL_LEFT << 4));\r\ndefault:\r\nreturn 0xFFFFFFFF;\r\n}\r\n}\r\nstatic struct sst_hsw_stream *get_stream_by_id(struct sst_hsw *hsw,\r\nint stream_id)\r\n{\r\nstruct sst_hsw_stream *stream;\r\nlist_for_each_entry(stream, &hsw->stream_list, node) {\r\nif (stream->reply.stream_hw_id == stream_id)\r\nreturn stream;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void hsw_fw_ready(struct sst_hsw *hsw, u32 header)\r\n{\r\nstruct sst_hsw_ipc_fw_ready fw_ready;\r\nu32 offset;\r\nu8 fw_info[IPC_MAX_MAILBOX_BYTES - 5 * sizeof(u32)];\r\nchar *tmp[5], *pinfo;\r\nint i = 0;\r\noffset = (header & 0x1FFFFFFF) << 3;\r\ndev_dbg(hsw->dev, "ipc: DSP is ready 0x%8.8x offset %d\n",\r\nheader, offset);\r\nsst_dsp_read(hsw->dsp, &fw_ready, offset, sizeof(fw_ready));\r\nsst_dsp_mailbox_init(hsw->dsp, fw_ready.inbox_offset,\r\nfw_ready.inbox_size, fw_ready.outbox_offset,\r\nfw_ready.outbox_size);\r\nhsw->boot_complete = true;\r\nwake_up(&hsw->boot_wait);\r\ndev_dbg(hsw->dev, " mailbox upstream 0x%x - size 0x%x\n",\r\nfw_ready.inbox_offset, fw_ready.inbox_size);\r\ndev_dbg(hsw->dev, " mailbox downstream 0x%x - size 0x%x\n",\r\nfw_ready.outbox_offset, fw_ready.outbox_size);\r\nif (fw_ready.fw_info_size < sizeof(fw_ready.fw_info)) {\r\nfw_ready.fw_info[fw_ready.fw_info_size] = 0;\r\ndev_dbg(hsw->dev, " Firmware info: %s \n", fw_ready.fw_info);\r\nmemcpy(fw_info, fw_ready.fw_info, fw_ready.fw_info_size);\r\npinfo = &fw_info[0];\r\nfor (i = 0; i < ARRAY_SIZE(tmp); i++)\r\ntmp[i] = strsep(&pinfo, " ");\r\ndev_info(hsw->dev, "FW loaded, mailbox readback FW info: type %s, - "\r\n"version: %s.%s, build %s, source commit id: %s\n",\r\ntmp[0], tmp[1], tmp[2], tmp[3], tmp[4]);\r\n}\r\n}\r\nstatic void hsw_notification_work(struct work_struct *work)\r\n{\r\nstruct sst_hsw_stream *stream = container_of(work,\r\nstruct sst_hsw_stream, notify_work);\r\nstruct sst_hsw_ipc_stream_glitch_position *glitch = &stream->glitch;\r\nstruct sst_hsw_ipc_stream_get_position *pos = &stream->rpos;\r\nstruct sst_hsw *hsw = stream->hsw;\r\nu32 reason;\r\nreason = msg_get_notify_reason(stream->header);\r\nswitch (reason) {\r\ncase IPC_STG_GLITCH:\r\ntrace_ipc_notification("DSP stream under/overrun",\r\nstream->reply.stream_hw_id);\r\nsst_dsp_inbox_read(hsw->dsp, glitch, sizeof(*glitch));\r\ndev_err(hsw->dev, "glitch %d pos 0x%x write pos 0x%x\n",\r\nglitch->glitch_type, glitch->present_pos,\r\nglitch->write_pos);\r\nbreak;\r\ncase IPC_POSITION_CHANGED:\r\ntrace_ipc_notification("DSP stream position changed for",\r\nstream->reply.stream_hw_id);\r\nsst_dsp_inbox_read(hsw->dsp, pos, sizeof(*pos));\r\nif (stream->notify_position)\r\nstream->notify_position(stream, stream->pdata);\r\nbreak;\r\ndefault:\r\ndev_err(hsw->dev, "error: unknown notification 0x%x\n",\r\nstream->header);\r\nbreak;\r\n}\r\nsst_dsp_shim_update_bits(hsw->dsp, SST_IPCD,\r\nSST_IPCD_BUSY | SST_IPCD_DONE, SST_IPCD_DONE);\r\nsst_dsp_shim_update_bits(hsw->dsp, SST_IMRX, SST_IMRX_BUSY, 0);\r\n}\r\nstatic void hsw_stream_update(struct sst_hsw *hsw, struct ipc_message *msg)\r\n{\r\nstruct sst_hsw_stream *stream;\r\nu32 header = msg->header & ~(IPC_STATUS_MASK | IPC_GLB_REPLY_MASK);\r\nu32 stream_id = msg_get_stream_id(header);\r\nu32 stream_msg = msg_get_stream_type(header);\r\nstream = get_stream_by_id(hsw, stream_id);\r\nif (stream == NULL)\r\nreturn;\r\nswitch (stream_msg) {\r\ncase IPC_STR_STAGE_MESSAGE:\r\ncase IPC_STR_NOTIFICATION:\r\nbreak;\r\ncase IPC_STR_RESET:\r\ntrace_ipc_notification("stream reset", stream->reply.stream_hw_id);\r\nbreak;\r\ncase IPC_STR_PAUSE:\r\nstream->running = false;\r\ntrace_ipc_notification("stream paused",\r\nstream->reply.stream_hw_id);\r\nbreak;\r\ncase IPC_STR_RESUME:\r\nstream->running = true;\r\ntrace_ipc_notification("stream running",\r\nstream->reply.stream_hw_id);\r\nbreak;\r\n}\r\n}\r\nstatic int hsw_process_reply(struct sst_hsw *hsw, u32 header)\r\n{\r\nstruct ipc_message *msg;\r\nu32 reply = msg_get_global_reply(header);\r\ntrace_ipc_reply("processing -->", header);\r\nmsg = sst_ipc_reply_find_msg(&hsw->ipc, header);\r\nif (msg == NULL) {\r\ntrace_ipc_error("error: can't find message header", header);\r\nreturn -EIO;\r\n}\r\nswitch (reply) {\r\ncase IPC_GLB_REPLY_PENDING:\r\ntrace_ipc_pending_reply("received", header);\r\nmsg->pending = true;\r\nhsw->ipc.pending = true;\r\nreturn 1;\r\ncase IPC_GLB_REPLY_SUCCESS:\r\nif (msg->pending) {\r\ntrace_ipc_pending_reply("completed", header);\r\nsst_dsp_inbox_read(hsw->dsp, msg->rx_data,\r\nmsg->rx_size);\r\nhsw->ipc.pending = false;\r\n} else {\r\nsst_dsp_outbox_read(hsw->dsp, msg->rx_data,\r\nmsg->rx_size);\r\n}\r\nbreak;\r\ncase IPC_GLB_REPLY_UNKNOWN_MESSAGE_TYPE:\r\ntrace_ipc_error("error: unknown message type", header);\r\nmsg->errno = -EBADMSG;\r\nbreak;\r\ncase IPC_GLB_REPLY_OUT_OF_RESOURCES:\r\ntrace_ipc_error("error: out of resources", header);\r\nmsg->errno = -ENOMEM;\r\nbreak;\r\ncase IPC_GLB_REPLY_BUSY:\r\ntrace_ipc_error("error: reply busy", header);\r\nmsg->errno = -EBUSY;\r\nbreak;\r\ncase IPC_GLB_REPLY_FAILURE:\r\ntrace_ipc_error("error: reply failure", header);\r\nmsg->errno = -EINVAL;\r\nbreak;\r\ncase IPC_GLB_REPLY_STAGE_UNINITIALIZED:\r\ntrace_ipc_error("error: stage uninitialized", header);\r\nmsg->errno = -EINVAL;\r\nbreak;\r\ncase IPC_GLB_REPLY_NOT_FOUND:\r\ntrace_ipc_error("error: reply not found", header);\r\nmsg->errno = -EINVAL;\r\nbreak;\r\ncase IPC_GLB_REPLY_SOURCE_NOT_STARTED:\r\ntrace_ipc_error("error: source not started", header);\r\nmsg->errno = -EINVAL;\r\nbreak;\r\ncase IPC_GLB_REPLY_INVALID_REQUEST:\r\ntrace_ipc_error("error: invalid request", header);\r\nmsg->errno = -EINVAL;\r\nbreak;\r\ncase IPC_GLB_REPLY_ERROR_INVALID_PARAM:\r\ntrace_ipc_error("error: invalid parameter", header);\r\nmsg->errno = -EINVAL;\r\nbreak;\r\ndefault:\r\ntrace_ipc_error("error: unknown reply", header);\r\nmsg->errno = -EINVAL;\r\nbreak;\r\n}\r\nif (msg_get_global_type(header) == IPC_GLB_STREAM_MESSAGE)\r\nhsw_stream_update(hsw, msg);\r\nlist_del(&msg->list);\r\nsst_ipc_tx_msg_reply_complete(&hsw->ipc, msg);\r\nreturn 1;\r\n}\r\nstatic int hsw_module_message(struct sst_hsw *hsw, u32 header)\r\n{\r\nu32 operation, module_id;\r\nint handled = 0;\r\noperation = msg_get_module_operation(header);\r\nmodule_id = msg_get_module_id(header);\r\ndev_dbg(hsw->dev, "received module message header: 0x%8.8x\n",\r\nheader);\r\ndev_dbg(hsw->dev, "operation: 0x%8.8x module_id: 0x%8.8x\n",\r\noperation, module_id);\r\nswitch (operation) {\r\ncase IPC_MODULE_NOTIFICATION:\r\ndev_dbg(hsw->dev, "module notification received");\r\nhandled = 1;\r\nbreak;\r\ndefault:\r\nhandled = hsw_process_reply(hsw, header);\r\nbreak;\r\n}\r\nreturn handled;\r\n}\r\nstatic int hsw_stream_message(struct sst_hsw *hsw, u32 header)\r\n{\r\nu32 stream_msg, stream_id, stage_type;\r\nstruct sst_hsw_stream *stream;\r\nint handled = 0;\r\nstream_msg = msg_get_stream_type(header);\r\nstream_id = msg_get_stream_id(header);\r\nstage_type = msg_get_stage_type(header);\r\nstream = get_stream_by_id(hsw, stream_id);\r\nif (stream == NULL)\r\nreturn handled;\r\nstream->header = header;\r\nswitch (stream_msg) {\r\ncase IPC_STR_STAGE_MESSAGE:\r\ndev_err(hsw->dev, "error: stage msg not implemented 0x%8.8x\n",\r\nheader);\r\nbreak;\r\ncase IPC_STR_NOTIFICATION:\r\nschedule_work(&stream->notify_work);\r\nbreak;\r\ndefault:\r\nhandled = hsw_process_reply(hsw, header);\r\nbreak;\r\n}\r\nreturn handled;\r\n}\r\nstatic int hsw_log_message(struct sst_hsw *hsw, u32 header)\r\n{\r\nu32 operation = (header & IPC_LOG_OP_MASK) >> IPC_LOG_OP_SHIFT;\r\nstruct sst_hsw_log_stream *stream = &hsw->log_stream;\r\nint ret = 1;\r\nif (operation != IPC_DEBUG_REQUEST_LOG_DUMP) {\r\ndev_err(hsw->dev,\r\n"error: log msg not implemented 0x%8.8x\n", header);\r\nreturn 0;\r\n}\r\nmutex_lock(&stream->rw_mutex);\r\nstream->last_pos = stream->curr_pos;\r\nsst_dsp_inbox_read(\r\nhsw->dsp, &stream->curr_pos, sizeof(stream->curr_pos));\r\nmutex_unlock(&stream->rw_mutex);\r\nschedule_work(&stream->notify_work);\r\nreturn ret;\r\n}\r\nstatic int hsw_process_notification(struct sst_hsw *hsw)\r\n{\r\nstruct sst_dsp *sst = hsw->dsp;\r\nu32 type, header;\r\nint handled = 1;\r\nheader = sst_dsp_shim_read_unlocked(sst, SST_IPCD);\r\ntype = msg_get_global_type(header);\r\ntrace_ipc_request("processing -->", header);\r\nif (!hsw->boot_complete && header & IPC_FW_READY) {\r\nhsw_fw_ready(hsw, header);\r\nreturn handled;\r\n}\r\nswitch (type) {\r\ncase IPC_GLB_GET_FW_VERSION:\r\ncase IPC_GLB_ALLOCATE_STREAM:\r\ncase IPC_GLB_FREE_STREAM:\r\ncase IPC_GLB_GET_FW_CAPABILITIES:\r\ncase IPC_GLB_REQUEST_DUMP:\r\ncase IPC_GLB_GET_DEVICE_FORMATS:\r\ncase IPC_GLB_SET_DEVICE_FORMATS:\r\ncase IPC_GLB_ENTER_DX_STATE:\r\ncase IPC_GLB_GET_MIXER_STREAM_INFO:\r\ncase IPC_GLB_MAX_IPC_MESSAGE_TYPE:\r\ncase IPC_GLB_RESTORE_CONTEXT:\r\ncase IPC_GLB_SHORT_REPLY:\r\ndev_err(hsw->dev, "error: message type %d header 0x%x\n",\r\ntype, header);\r\nbreak;\r\ncase IPC_GLB_STREAM_MESSAGE:\r\nhandled = hsw_stream_message(hsw, header);\r\nbreak;\r\ncase IPC_GLB_DEBUG_LOG_MESSAGE:\r\nhandled = hsw_log_message(hsw, header);\r\nbreak;\r\ncase IPC_GLB_MODULE_OPERATION:\r\nhandled = hsw_module_message(hsw, header);\r\nbreak;\r\ndefault:\r\ndev_err(hsw->dev, "error: unexpected type %d hdr 0x%8.8x\n",\r\ntype, header);\r\nbreak;\r\n}\r\nreturn handled;\r\n}\r\nstatic irqreturn_t hsw_irq_thread(int irq, void *context)\r\n{\r\nstruct sst_dsp *sst = (struct sst_dsp *) context;\r\nstruct sst_hsw *hsw = sst_dsp_get_thread_context(sst);\r\nstruct sst_generic_ipc *ipc = &hsw->ipc;\r\nu32 ipcx, ipcd;\r\nunsigned long flags;\r\nspin_lock_irqsave(&sst->spinlock, flags);\r\nipcx = sst_dsp_ipc_msg_rx(hsw->dsp);\r\nipcd = sst_dsp_shim_read_unlocked(sst, SST_IPCD);\r\nif (ipcx & SST_IPCX_DONE) {\r\nhsw_process_reply(hsw, ipcx);\r\nsst_dsp_shim_update_bits_unlocked(sst, SST_IPCX,\r\nSST_IPCX_DONE, 0);\r\nsst_dsp_shim_update_bits_unlocked(sst, SST_IMRX,\r\nSST_IMRX_DONE, 0);\r\n}\r\nif (ipcd & SST_IPCD_BUSY) {\r\nhsw_process_notification(hsw);\r\nsst_dsp_shim_update_bits_unlocked(sst, SST_IPCD,\r\nSST_IPCD_BUSY | SST_IPCD_DONE, SST_IPCD_DONE);\r\nsst_dsp_shim_update_bits_unlocked(sst, SST_IMRX,\r\nSST_IMRX_BUSY, 0);\r\n}\r\nspin_unlock_irqrestore(&sst->spinlock, flags);\r\nschedule_work(&ipc->kwork);\r\nreturn IRQ_HANDLED;\r\n}\r\nint sst_hsw_fw_get_version(struct sst_hsw *hsw,\r\nstruct sst_hsw_ipc_fw_version *version)\r\n{\r\nint ret;\r\nret = sst_ipc_tx_message_wait(&hsw->ipc,\r\nIPC_GLB_TYPE(IPC_GLB_GET_FW_VERSION),\r\nNULL, 0, version, sizeof(*version));\r\nif (ret < 0)\r\ndev_err(hsw->dev, "error: get version failed\n");\r\nreturn ret;\r\n}\r\nint sst_hsw_stream_get_volume(struct sst_hsw *hsw, struct sst_hsw_stream *stream,\r\nu32 stage_id, u32 channel, u32 *volume)\r\n{\r\nif (channel > 1)\r\nreturn -EINVAL;\r\nsst_dsp_read(hsw->dsp, volume,\r\nstream->reply.volume_register_address[channel],\r\nsizeof(*volume));\r\nreturn 0;\r\n}\r\nint sst_hsw_stream_set_volume(struct sst_hsw *hsw,\r\nstruct sst_hsw_stream *stream, u32 stage_id, u32 channel, u32 volume)\r\n{\r\nstruct sst_hsw_ipc_volume_req *req;\r\nu32 header;\r\nint ret;\r\ntrace_ipc_request("set stream volume", stream->reply.stream_hw_id);\r\nif (channel >= 2 && channel != SST_HSW_CHANNELS_ALL)\r\nreturn -EINVAL;\r\nheader = IPC_GLB_TYPE(IPC_GLB_STREAM_MESSAGE) |\r\nIPC_STR_TYPE(IPC_STR_STAGE_MESSAGE);\r\nheader |= (stream->reply.stream_hw_id << IPC_STR_ID_SHIFT);\r\nheader |= (IPC_STG_SET_VOLUME << IPC_STG_TYPE_SHIFT);\r\nheader |= (stage_id << IPC_STG_ID_SHIFT);\r\nreq = &stream->vol_req;\r\nreq->target_volume = volume;\r\nif (channel == SST_HSW_CHANNELS_ALL) {\r\nif (hsw->mute[0] && hsw->mute[1]) {\r\nhsw->mute_volume[0] = hsw->mute_volume[1] = volume;\r\nreturn 0;\r\n} else if (hsw->mute[0])\r\nreq->channel = 1;\r\nelse if (hsw->mute[1])\r\nreq->channel = 0;\r\nelse\r\nreq->channel = SST_HSW_CHANNELS_ALL;\r\n} else {\r\nif (hsw->mute[channel]) {\r\nhsw->mute_volume[channel] = volume;\r\nreturn 0;\r\n}\r\nreq->channel = channel;\r\n}\r\nret = sst_ipc_tx_message_wait(&hsw->ipc, header, req,\r\nsizeof(*req), NULL, 0);\r\nif (ret < 0) {\r\ndev_err(hsw->dev, "error: set stream volume failed\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint sst_hsw_mixer_get_volume(struct sst_hsw *hsw, u32 stage_id, u32 channel,\r\nu32 *volume)\r\n{\r\nif (channel > 1)\r\nreturn -EINVAL;\r\nsst_dsp_read(hsw->dsp, volume,\r\nhsw->mixer_info.volume_register_address[channel],\r\nsizeof(*volume));\r\nreturn 0;\r\n}\r\nint sst_hsw_mixer_set_volume(struct sst_hsw *hsw, u32 stage_id, u32 channel,\r\nu32 volume)\r\n{\r\nstruct sst_hsw_ipc_volume_req req;\r\nu32 header;\r\nint ret;\r\ntrace_ipc_request("set mixer volume", volume);\r\nif (channel >= 2 && channel != SST_HSW_CHANNELS_ALL)\r\nreturn -EINVAL;\r\nif (channel == SST_HSW_CHANNELS_ALL) {\r\nif (hsw->mute[0] && hsw->mute[1]) {\r\nhsw->mute_volume[0] = hsw->mute_volume[1] = volume;\r\nreturn 0;\r\n} else if (hsw->mute[0])\r\nreq.channel = 1;\r\nelse if (hsw->mute[1])\r\nreq.channel = 0;\r\nelse\r\nreq.channel = SST_HSW_CHANNELS_ALL;\r\n} else {\r\nif (hsw->mute[channel]) {\r\nhsw->mute_volume[channel] = volume;\r\nreturn 0;\r\n}\r\nreq.channel = channel;\r\n}\r\nheader = IPC_GLB_TYPE(IPC_GLB_STREAM_MESSAGE) |\r\nIPC_STR_TYPE(IPC_STR_STAGE_MESSAGE);\r\nheader |= (hsw->mixer_info.mixer_hw_id << IPC_STR_ID_SHIFT);\r\nheader |= (IPC_STG_SET_VOLUME << IPC_STG_TYPE_SHIFT);\r\nheader |= (stage_id << IPC_STG_ID_SHIFT);\r\nreq.curve_duration = hsw->curve_duration;\r\nreq.curve_type = hsw->curve_type;\r\nreq.target_volume = volume;\r\nret = sst_ipc_tx_message_wait(&hsw->ipc, header, &req,\r\nsizeof(req), NULL, 0);\r\nif (ret < 0) {\r\ndev_err(hsw->dev, "error: set mixer volume failed\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstruct sst_hsw_stream *sst_hsw_stream_new(struct sst_hsw *hsw, int id,\r\nu32 (*notify_position)(struct sst_hsw_stream *stream, void *data),\r\nvoid *data)\r\n{\r\nstruct sst_hsw_stream *stream;\r\nstruct sst_dsp *sst = hsw->dsp;\r\nunsigned long flags;\r\nstream = kzalloc(sizeof(*stream), GFP_KERNEL);\r\nif (stream == NULL)\r\nreturn NULL;\r\nspin_lock_irqsave(&sst->spinlock, flags);\r\nstream->reply.stream_hw_id = INVALID_STREAM_HW_ID;\r\nlist_add(&stream->node, &hsw->stream_list);\r\nstream->notify_position = notify_position;\r\nstream->pdata = data;\r\nstream->hsw = hsw;\r\nstream->host_id = id;\r\nINIT_WORK(&stream->notify_work, hsw_notification_work);\r\nspin_unlock_irqrestore(&sst->spinlock, flags);\r\nreturn stream;\r\n}\r\nint sst_hsw_stream_free(struct sst_hsw *hsw, struct sst_hsw_stream *stream)\r\n{\r\nu32 header;\r\nint ret = 0;\r\nstruct sst_dsp *sst = hsw->dsp;\r\nunsigned long flags;\r\nif (!stream) {\r\ndev_warn(hsw->dev, "warning: stream is NULL, no stream to free, ignore it.\n");\r\nreturn 0;\r\n}\r\nif (!stream->commited)\r\ngoto out;\r\ntrace_ipc_request("stream free", stream->host_id);\r\nstream->free_req.stream_id = stream->reply.stream_hw_id;\r\nheader = IPC_GLB_TYPE(IPC_GLB_FREE_STREAM);\r\nret = sst_ipc_tx_message_wait(&hsw->ipc, header, &stream->free_req,\r\nsizeof(stream->free_req), NULL, 0);\r\nif (ret < 0) {\r\ndev_err(hsw->dev, "error: free stream %d failed\n",\r\nstream->free_req.stream_id);\r\nreturn -EAGAIN;\r\n}\r\ntrace_hsw_stream_free_req(stream, &stream->free_req);\r\nout:\r\ncancel_work_sync(&stream->notify_work);\r\nspin_lock_irqsave(&sst->spinlock, flags);\r\nlist_del(&stream->node);\r\nkfree(stream);\r\nspin_unlock_irqrestore(&sst->spinlock, flags);\r\nreturn ret;\r\n}\r\nint sst_hsw_stream_set_bits(struct sst_hsw *hsw,\r\nstruct sst_hsw_stream *stream, enum sst_hsw_bitdepth bits)\r\n{\r\nif (stream->commited) {\r\ndev_err(hsw->dev, "error: stream committed for set bits\n");\r\nreturn -EINVAL;\r\n}\r\nstream->request.format.bitdepth = bits;\r\nreturn 0;\r\n}\r\nint sst_hsw_stream_set_channels(struct sst_hsw *hsw,\r\nstruct sst_hsw_stream *stream, int channels)\r\n{\r\nif (stream->commited) {\r\ndev_err(hsw->dev, "error: stream committed for set channels\n");\r\nreturn -EINVAL;\r\n}\r\nstream->request.format.ch_num = channels;\r\nreturn 0;\r\n}\r\nint sst_hsw_stream_set_rate(struct sst_hsw *hsw,\r\nstruct sst_hsw_stream *stream, int rate)\r\n{\r\nif (stream->commited) {\r\ndev_err(hsw->dev, "error: stream committed for set rate\n");\r\nreturn -EINVAL;\r\n}\r\nstream->request.format.frequency = rate;\r\nreturn 0;\r\n}\r\nint sst_hsw_stream_set_map_config(struct sst_hsw *hsw,\r\nstruct sst_hsw_stream *stream, u32 map,\r\nenum sst_hsw_channel_config config)\r\n{\r\nif (stream->commited) {\r\ndev_err(hsw->dev, "error: stream committed for set map\n");\r\nreturn -EINVAL;\r\n}\r\nstream->request.format.map = map;\r\nstream->request.format.config = config;\r\nreturn 0;\r\n}\r\nint sst_hsw_stream_set_style(struct sst_hsw *hsw,\r\nstruct sst_hsw_stream *stream, enum sst_hsw_interleaving style)\r\n{\r\nif (stream->commited) {\r\ndev_err(hsw->dev, "error: stream committed for set style\n");\r\nreturn -EINVAL;\r\n}\r\nstream->request.format.style = style;\r\nreturn 0;\r\n}\r\nint sst_hsw_stream_set_valid(struct sst_hsw *hsw,\r\nstruct sst_hsw_stream *stream, u32 bits)\r\n{\r\nif (stream->commited) {\r\ndev_err(hsw->dev, "error: stream committed for set valid bits\n");\r\nreturn -EINVAL;\r\n}\r\nstream->request.format.valid_bit = bits;\r\nreturn 0;\r\n}\r\nint sst_hsw_stream_format(struct sst_hsw *hsw, struct sst_hsw_stream *stream,\r\nenum sst_hsw_stream_path_id path_id,\r\nenum sst_hsw_stream_type stream_type,\r\nenum sst_hsw_stream_format format_id)\r\n{\r\nif (stream->commited) {\r\ndev_err(hsw->dev, "error: stream committed for set format\n");\r\nreturn -EINVAL;\r\n}\r\nstream->request.path_id = path_id;\r\nstream->request.stream_type = stream_type;\r\nstream->request.format_id = format_id;\r\ntrace_hsw_stream_alloc_request(stream, &stream->request);\r\nreturn 0;\r\n}\r\nint sst_hsw_stream_buffer(struct sst_hsw *hsw, struct sst_hsw_stream *stream,\r\nu32 ring_pt_address, u32 num_pages,\r\nu32 ring_size, u32 ring_offset, u32 ring_first_pfn)\r\n{\r\nif (stream->commited) {\r\ndev_err(hsw->dev, "error: stream committed for buffer\n");\r\nreturn -EINVAL;\r\n}\r\nstream->request.ringinfo.ring_pt_address = ring_pt_address;\r\nstream->request.ringinfo.num_pages = num_pages;\r\nstream->request.ringinfo.ring_size = ring_size;\r\nstream->request.ringinfo.ring_offset = ring_offset;\r\nstream->request.ringinfo.ring_first_pfn = ring_first_pfn;\r\ntrace_hsw_stream_buffer(stream);\r\nreturn 0;\r\n}\r\nint sst_hsw_stream_set_module_info(struct sst_hsw *hsw,\r\nstruct sst_hsw_stream *stream, struct sst_module_runtime *runtime)\r\n{\r\nstruct sst_hsw_module_map *map = &stream->request.map;\r\nstruct sst_dsp *dsp = sst_hsw_get_dsp(hsw);\r\nstruct sst_module *module = runtime->module;\r\nif (stream->commited) {\r\ndev_err(hsw->dev, "error: stream committed for set module\n");\r\nreturn -EINVAL;\r\n}\r\nmap->module_entries_count = 1;\r\nmap->module_entries[0].module_id = module->id;\r\nmap->module_entries[0].entry_point = module->entry;\r\nstream->request.persistent_mem.offset =\r\nsst_dsp_get_offset(dsp, runtime->persistent_offset, SST_MEM_DRAM);\r\nstream->request.persistent_mem.size = module->persistent_size;\r\nstream->request.scratch_mem.offset =\r\nsst_dsp_get_offset(dsp, dsp->scratch_offset, SST_MEM_DRAM);\r\nstream->request.scratch_mem.size = dsp->scratch_size;\r\ndev_dbg(hsw->dev, "module %d runtime %d using:\n", module->id,\r\nruntime->id);\r\ndev_dbg(hsw->dev, " persistent offset 0x%x bytes 0x%x\n",\r\nstream->request.persistent_mem.offset,\r\nstream->request.persistent_mem.size);\r\ndev_dbg(hsw->dev, " scratch offset 0x%x bytes 0x%x\n",\r\nstream->request.scratch_mem.offset,\r\nstream->request.scratch_mem.size);\r\nreturn 0;\r\n}\r\nint sst_hsw_stream_commit(struct sst_hsw *hsw, struct sst_hsw_stream *stream)\r\n{\r\nstruct sst_hsw_ipc_stream_alloc_req *str_req = &stream->request;\r\nstruct sst_hsw_ipc_stream_alloc_reply *reply = &stream->reply;\r\nu32 header;\r\nint ret;\r\nif (!stream) {\r\ndev_warn(hsw->dev, "warning: stream is NULL, no stream to commit, ignore it.\n");\r\nreturn 0;\r\n}\r\nif (stream->commited) {\r\ndev_warn(hsw->dev, "warning: stream is already committed, ignore it.\n");\r\nreturn 0;\r\n}\r\ntrace_ipc_request("stream alloc", stream->host_id);\r\nheader = IPC_GLB_TYPE(IPC_GLB_ALLOCATE_STREAM);\r\nret = sst_ipc_tx_message_wait(&hsw->ipc, header, str_req,\r\nsizeof(*str_req), reply, sizeof(*reply));\r\nif (ret < 0) {\r\ndev_err(hsw->dev, "error: stream commit failed\n");\r\nreturn ret;\r\n}\r\nstream->commited = 1;\r\ntrace_hsw_stream_alloc_reply(stream);\r\nreturn 0;\r\n}\r\nsnd_pcm_uframes_t sst_hsw_stream_get_old_position(struct sst_hsw *hsw,\r\nstruct sst_hsw_stream *stream)\r\n{\r\nreturn stream->old_position;\r\n}\r\nvoid sst_hsw_stream_set_old_position(struct sst_hsw *hsw,\r\nstruct sst_hsw_stream *stream, snd_pcm_uframes_t val)\r\n{\r\nstream->old_position = val;\r\n}\r\nbool sst_hsw_stream_get_silence_start(struct sst_hsw *hsw,\r\nstruct sst_hsw_stream *stream)\r\n{\r\nreturn stream->play_silence;\r\n}\r\nvoid sst_hsw_stream_set_silence_start(struct sst_hsw *hsw,\r\nstruct sst_hsw_stream *stream, bool val)\r\n{\r\nstream->play_silence = val;\r\n}\r\nint sst_hsw_mixer_get_info(struct sst_hsw *hsw)\r\n{\r\nstruct sst_hsw_ipc_stream_info_reply *reply;\r\nu32 header;\r\nint ret;\r\nreply = &hsw->mixer_info;\r\nheader = IPC_GLB_TYPE(IPC_GLB_GET_MIXER_STREAM_INFO);\r\ntrace_ipc_request("get global mixer info", 0);\r\nret = sst_ipc_tx_message_wait(&hsw->ipc, header, NULL, 0,\r\nreply, sizeof(*reply));\r\nif (ret < 0) {\r\ndev_err(hsw->dev, "error: get stream info failed\n");\r\nreturn ret;\r\n}\r\ntrace_hsw_mixer_info_reply(reply);\r\nreturn 0;\r\n}\r\nstatic int sst_hsw_stream_operations(struct sst_hsw *hsw, int type,\r\nint stream_id, int wait)\r\n{\r\nu32 header;\r\nheader = IPC_GLB_TYPE(IPC_GLB_STREAM_MESSAGE) | IPC_STR_TYPE(type);\r\nheader |= (stream_id << IPC_STR_ID_SHIFT);\r\nif (wait)\r\nreturn sst_ipc_tx_message_wait(&hsw->ipc, header,\r\nNULL, 0, NULL, 0);\r\nelse\r\nreturn sst_ipc_tx_message_nowait(&hsw->ipc, header, NULL, 0);\r\n}\r\nint sst_hsw_stream_pause(struct sst_hsw *hsw, struct sst_hsw_stream *stream,\r\nint wait)\r\n{\r\nint ret;\r\nif (!stream) {\r\ndev_warn(hsw->dev, "warning: stream is NULL, no stream to pause, ignore it.\n");\r\nreturn 0;\r\n}\r\ntrace_ipc_request("stream pause", stream->reply.stream_hw_id);\r\nret = sst_hsw_stream_operations(hsw, IPC_STR_PAUSE,\r\nstream->reply.stream_hw_id, wait);\r\nif (ret < 0)\r\ndev_err(hsw->dev, "error: failed to pause stream %d\n",\r\nstream->reply.stream_hw_id);\r\nreturn ret;\r\n}\r\nint sst_hsw_stream_resume(struct sst_hsw *hsw, struct sst_hsw_stream *stream,\r\nint wait)\r\n{\r\nint ret;\r\nif (!stream) {\r\ndev_warn(hsw->dev, "warning: stream is NULL, no stream to resume, ignore it.\n");\r\nreturn 0;\r\n}\r\ntrace_ipc_request("stream resume", stream->reply.stream_hw_id);\r\nret = sst_hsw_stream_operations(hsw, IPC_STR_RESUME,\r\nstream->reply.stream_hw_id, wait);\r\nif (ret < 0)\r\ndev_err(hsw->dev, "error: failed to resume stream %d\n",\r\nstream->reply.stream_hw_id);\r\nreturn ret;\r\n}\r\nint sst_hsw_stream_reset(struct sst_hsw *hsw, struct sst_hsw_stream *stream)\r\n{\r\nint ret, tries = 10;\r\nif (!stream) {\r\ndev_warn(hsw->dev, "warning: stream is NULL, no stream to reset, ignore it.\n");\r\nreturn 0;\r\n}\r\nif (!stream->commited)\r\nreturn 0;\r\nwhile (stream->running && --tries)\r\nmsleep(1);\r\nif (!tries) {\r\ndev_err(hsw->dev, "error: reset stream %d still running\n",\r\nstream->reply.stream_hw_id);\r\nreturn -EINVAL;\r\n}\r\ntrace_ipc_request("stream reset", stream->reply.stream_hw_id);\r\nret = sst_hsw_stream_operations(hsw, IPC_STR_RESET,\r\nstream->reply.stream_hw_id, 1);\r\nif (ret < 0)\r\ndev_err(hsw->dev, "error: failed to reset stream %d\n",\r\nstream->reply.stream_hw_id);\r\nreturn ret;\r\n}\r\nu32 sst_hsw_get_dsp_position(struct sst_hsw *hsw,\r\nstruct sst_hsw_stream *stream)\r\n{\r\nu32 rpos;\r\nsst_dsp_read(hsw->dsp, &rpos,\r\nstream->reply.read_position_register_address, sizeof(rpos));\r\nreturn rpos;\r\n}\r\nu64 sst_hsw_get_dsp_presentation_position(struct sst_hsw *hsw,\r\nstruct sst_hsw_stream *stream)\r\n{\r\nu64 ppos;\r\nsst_dsp_read(hsw->dsp, &ppos,\r\nstream->reply.presentation_position_register_address,\r\nsizeof(ppos));\r\nreturn ppos;\r\n}\r\nint sst_hsw_device_set_config(struct sst_hsw *hsw,\r\nenum sst_hsw_device_id dev, enum sst_hsw_device_mclk mclk,\r\nenum sst_hsw_device_mode mode, u32 clock_divider)\r\n{\r\nstruct sst_hsw_ipc_device_config_req config;\r\nu32 header;\r\nint ret;\r\ntrace_ipc_request("set device config", dev);\r\nhsw->dx_dev = config.ssp_interface = dev;\r\nhsw->dx_mclk = config.clock_frequency = mclk;\r\nhsw->dx_mode = config.mode = mode;\r\nhsw->dx_clock_divider = config.clock_divider = clock_divider;\r\nif (mode == SST_HSW_DEVICE_TDM_CLOCK_MASTER)\r\nconfig.channels = 4;\r\nelse\r\nconfig.channels = 2;\r\ntrace_hsw_device_config_req(&config);\r\nheader = IPC_GLB_TYPE(IPC_GLB_SET_DEVICE_FORMATS);\r\nret = sst_ipc_tx_message_wait(&hsw->ipc, header, &config,\r\nsizeof(config), NULL, 0);\r\nif (ret < 0)\r\ndev_err(hsw->dev, "error: set device formats failed\n");\r\nreturn ret;\r\n}\r\nint sst_hsw_dx_set_state(struct sst_hsw *hsw,\r\nenum sst_hsw_dx_state state, struct sst_hsw_ipc_dx_reply *dx)\r\n{\r\nu32 header, state_;\r\nint ret, item;\r\nheader = IPC_GLB_TYPE(IPC_GLB_ENTER_DX_STATE);\r\nstate_ = state;\r\ntrace_ipc_request("PM enter Dx state", state);\r\nret = sst_ipc_tx_message_wait(&hsw->ipc, header, &state_,\r\nsizeof(state_), dx, sizeof(*dx));\r\nif (ret < 0) {\r\ndev_err(hsw->dev, "ipc: error set dx state %d failed\n", state);\r\nreturn ret;\r\n}\r\nfor (item = 0; item < dx->entries_no; item++) {\r\ndev_dbg(hsw->dev,\r\n"Item[%d] offset[%x] - size[%x] - source[%x]\n",\r\nitem, dx->mem_info[item].offset,\r\ndx->mem_info[item].size,\r\ndx->mem_info[item].source);\r\n}\r\ndev_dbg(hsw->dev, "ipc: got %d entry numbers for state %d\n",\r\ndx->entries_no, state);\r\nreturn ret;\r\n}\r\nstruct sst_module_runtime *sst_hsw_runtime_module_create(struct sst_hsw *hsw,\r\nint mod_id, int offset)\r\n{\r\nstruct sst_dsp *dsp = hsw->dsp;\r\nstruct sst_module *module;\r\nstruct sst_module_runtime *runtime;\r\nint err;\r\nmodule = sst_module_get_from_id(dsp, mod_id);\r\nif (module == NULL) {\r\ndev_err(dsp->dev, "error: failed to get module %d for pcm\n",\r\nmod_id);\r\nreturn NULL;\r\n}\r\nruntime = sst_module_runtime_new(module, mod_id, NULL);\r\nif (runtime == NULL) {\r\ndev_err(dsp->dev, "error: failed to create module %d runtime\n",\r\nmod_id);\r\nreturn NULL;\r\n}\r\nerr = sst_module_runtime_alloc_blocks(runtime, offset);\r\nif (err < 0) {\r\ndev_err(dsp->dev, "error: failed to alloc blocks for module %d runtime\n",\r\nmod_id);\r\nsst_module_runtime_free(runtime);\r\nreturn NULL;\r\n}\r\ndev_dbg(dsp->dev, "runtime id %d created for module %d\n", runtime->id,\r\nmod_id);\r\nreturn runtime;\r\n}\r\nvoid sst_hsw_runtime_module_free(struct sst_module_runtime *runtime)\r\n{\r\nsst_module_runtime_free_blocks(runtime);\r\nsst_module_runtime_free(runtime);\r\n}\r\nstatic int sst_hsw_dx_state_dump(struct sst_hsw *hsw)\r\n{\r\nstruct sst_dsp *sst = hsw->dsp;\r\nu32 item, offset, size;\r\nint ret = 0;\r\ntrace_ipc_request("PM state dump. Items #", SST_HSW_MAX_DX_REGIONS);\r\nif (hsw->dx.entries_no > SST_HSW_MAX_DX_REGIONS) {\r\ndev_err(hsw->dev,\r\n"error: number of FW context regions greater than %d\n",\r\nSST_HSW_MAX_DX_REGIONS);\r\nmemset(&hsw->dx, 0, sizeof(hsw->dx));\r\nreturn -EINVAL;\r\n}\r\nret = sst_dsp_dma_get_channel(sst, 0);\r\nif (ret < 0) {\r\ndev_err(hsw->dev, "error: cant allocate dma channel %d\n", ret);\r\nreturn ret;\r\n}\r\nsst_dsp_shim_update_bits(sst, SST_HMDC,\r\nSST_HMDC_HDDA_E0_ALLCH | SST_HMDC_HDDA_E1_ALLCH,\r\nSST_HMDC_HDDA_E0_ALLCH | SST_HMDC_HDDA_E1_ALLCH);\r\nfor (item = 0; item < hsw->dx.entries_no; item++) {\r\nif (hsw->dx.mem_info[item].source == SST_HSW_DX_TYPE_MEMORY_DUMP\r\n&& hsw->dx.mem_info[item].offset > DSP_DRAM_ADDR_OFFSET\r\n&& hsw->dx.mem_info[item].offset <\r\nDSP_DRAM_ADDR_OFFSET + SST_HSW_DX_CONTEXT_SIZE) {\r\noffset = hsw->dx.mem_info[item].offset\r\n- DSP_DRAM_ADDR_OFFSET;\r\nsize = (hsw->dx.mem_info[item].size + 3) & (~3);\r\nret = sst_dsp_dma_copyfrom(sst, hsw->dx_context_paddr + offset,\r\nsst->addr.lpe_base + offset, size);\r\nif (ret < 0) {\r\ndev_err(hsw->dev,\r\n"error: FW context dump failed\n");\r\nmemset(&hsw->dx, 0, sizeof(hsw->dx));\r\ngoto out;\r\n}\r\n}\r\n}\r\nout:\r\nsst_dsp_dma_put_channel(sst);\r\nreturn ret;\r\n}\r\nstatic int sst_hsw_dx_state_restore(struct sst_hsw *hsw)\r\n{\r\nstruct sst_dsp *sst = hsw->dsp;\r\nu32 item, offset, size;\r\nint ret;\r\nfor (item = 0; item < hsw->dx.entries_no; item++) {\r\nif (hsw->dx.mem_info[item].source == SST_HSW_DX_TYPE_MEMORY_DUMP\r\n&& hsw->dx.mem_info[item].offset > DSP_DRAM_ADDR_OFFSET\r\n&& hsw->dx.mem_info[item].offset <\r\nDSP_DRAM_ADDR_OFFSET + SST_HSW_DX_CONTEXT_SIZE) {\r\noffset = hsw->dx.mem_info[item].offset\r\n- DSP_DRAM_ADDR_OFFSET;\r\nsize = (hsw->dx.mem_info[item].size + 3) & (~3);\r\nret = sst_dsp_dma_copyto(sst, sst->addr.lpe_base + offset,\r\nhsw->dx_context_paddr + offset, size);\r\nif (ret < 0) {\r\ndev_err(hsw->dev,\r\n"error: FW context restore failed\n");\r\nreturn ret;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint sst_hsw_dsp_load(struct sst_hsw *hsw)\r\n{\r\nstruct sst_dsp *dsp = hsw->dsp;\r\nstruct sst_fw *sst_fw, *t;\r\nint ret;\r\ndev_dbg(hsw->dev, "loading audio DSP....");\r\nret = sst_dsp_wake(dsp);\r\nif (ret < 0) {\r\ndev_err(hsw->dev, "error: failed to wake audio DSP\n");\r\nreturn -ENODEV;\r\n}\r\nret = sst_dsp_dma_get_channel(dsp, 0);\r\nif (ret < 0) {\r\ndev_err(hsw->dev, "error: cant allocate dma channel %d\n", ret);\r\nreturn ret;\r\n}\r\nlist_for_each_entry_safe_reverse(sst_fw, t, &dsp->fw_list, list) {\r\nret = sst_fw_reload(sst_fw);\r\nif (ret < 0) {\r\ndev_err(hsw->dev, "error: SST FW reload failed\n");\r\nsst_dsp_dma_put_channel(dsp);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nret = sst_block_alloc_scratch(hsw->dsp);\r\nif (ret < 0)\r\nreturn -EINVAL;\r\nsst_dsp_dma_put_channel(dsp);\r\nreturn 0;\r\n}\r\nstatic int sst_hsw_dsp_restore(struct sst_hsw *hsw)\r\n{\r\nstruct sst_dsp *dsp = hsw->dsp;\r\nint ret;\r\ndev_dbg(hsw->dev, "restoring audio DSP....");\r\nret = sst_dsp_dma_get_channel(dsp, 0);\r\nif (ret < 0) {\r\ndev_err(hsw->dev, "error: cant allocate dma channel %d\n", ret);\r\nreturn ret;\r\n}\r\nret = sst_hsw_dx_state_restore(hsw);\r\nif (ret < 0) {\r\ndev_err(hsw->dev, "error: SST FW context restore failed\n");\r\nsst_dsp_dma_put_channel(dsp);\r\nreturn -ENOMEM;\r\n}\r\nsst_dsp_dma_put_channel(dsp);\r\nsst_dsp_boot(dsp);\r\nreturn ret;\r\n}\r\nint sst_hsw_dsp_runtime_suspend(struct sst_hsw *hsw)\r\n{\r\nint ret;\r\ndev_dbg(hsw->dev, "audio dsp runtime suspend\n");\r\nret = sst_hsw_dx_set_state(hsw, SST_HSW_DX_STATE_D3, &hsw->dx);\r\nif (ret < 0)\r\nreturn ret;\r\nsst_dsp_stall(hsw->dsp);\r\nret = sst_hsw_dx_state_dump(hsw);\r\nif (ret < 0)\r\nreturn ret;\r\nsst_ipc_drop_all(&hsw->ipc);\r\nreturn 0;\r\n}\r\nint sst_hsw_dsp_runtime_sleep(struct sst_hsw *hsw)\r\n{\r\nstruct sst_fw *sst_fw, *t;\r\nstruct sst_dsp *dsp = hsw->dsp;\r\nlist_for_each_entry_safe(sst_fw, t, &dsp->fw_list, list) {\r\nsst_fw_unload(sst_fw);\r\n}\r\nsst_block_free_scratch(dsp);\r\nhsw->boot_complete = false;\r\nsst_dsp_sleep(dsp);\r\nreturn 0;\r\n}\r\nint sst_hsw_dsp_runtime_resume(struct sst_hsw *hsw)\r\n{\r\nstruct device *dev = hsw->dev;\r\nint ret;\r\ndev_dbg(dev, "audio dsp runtime resume\n");\r\nif (hsw->boot_complete)\r\nreturn 1;\r\nret = sst_hsw_dsp_restore(hsw);\r\nif (ret < 0)\r\ndev_err(dev, "error: audio DSP boot failure\n");\r\nsst_hsw_init_module_state(hsw);\r\nret = wait_event_timeout(hsw->boot_wait, hsw->boot_complete,\r\nmsecs_to_jiffies(IPC_BOOT_MSECS));\r\nif (ret == 0) {\r\ndev_err(hsw->dev, "error: audio DSP boot timeout IPCD 0x%x IPCX 0x%x\n",\r\nsst_dsp_shim_read_unlocked(hsw->dsp, SST_IPCD),\r\nsst_dsp_shim_read_unlocked(hsw->dsp, SST_IPCX));\r\nreturn -EIO;\r\n}\r\nret = sst_hsw_device_set_config(hsw, hsw->dx_dev, hsw->dx_mclk,\r\nhsw->dx_mode, hsw->dx_clock_divider);\r\nif (ret < 0)\r\ndev_err(dev, "error: SSP re-initialization failed\n");\r\nreturn ret;\r\n}\r\nstruct sst_dsp *sst_hsw_get_dsp(struct sst_hsw *hsw)\r\n{\r\nreturn hsw->dsp;\r\n}\r\nvoid sst_hsw_init_module_state(struct sst_hsw *hsw)\r\n{\r\nstruct sst_module *module;\r\nenum sst_hsw_module_id id;\r\nfor (id = SST_HSW_MODULE_BASE_FW; id < SST_HSW_MAX_MODULE_ID; id++) {\r\nmodule = sst_module_get_from_id(hsw->dsp, id);\r\nif (module) {\r\nif (id == SST_HSW_MODULE_WAVES)\r\nmodule->state = SST_MODULE_STATE_INITIALIZED;\r\nelse\r\nmodule->state = SST_MODULE_STATE_ACTIVE;\r\n}\r\n}\r\n}\r\nbool sst_hsw_is_module_loaded(struct sst_hsw *hsw, u32 module_id)\r\n{\r\nstruct sst_module *module;\r\nmodule = sst_module_get_from_id(hsw->dsp, module_id);\r\nif (module == NULL || module->state == SST_MODULE_STATE_UNLOADED)\r\nreturn false;\r\nelse\r\nreturn true;\r\n}\r\nbool sst_hsw_is_module_active(struct sst_hsw *hsw, u32 module_id)\r\n{\r\nstruct sst_module *module;\r\nmodule = sst_module_get_from_id(hsw->dsp, module_id);\r\nif (module != NULL && module->state == SST_MODULE_STATE_ACTIVE)\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nvoid sst_hsw_set_module_enabled_rtd3(struct sst_hsw *hsw, u32 module_id)\r\n{\r\nhsw->enabled_modules_rtd3 |= (1 << module_id);\r\n}\r\nvoid sst_hsw_set_module_disabled_rtd3(struct sst_hsw *hsw, u32 module_id)\r\n{\r\nhsw->enabled_modules_rtd3 &= ~(1 << module_id);\r\n}\r\nbool sst_hsw_is_module_enabled_rtd3(struct sst_hsw *hsw, u32 module_id)\r\n{\r\nreturn hsw->enabled_modules_rtd3 & (1 << module_id);\r\n}\r\nvoid sst_hsw_reset_param_buf(struct sst_hsw *hsw)\r\n{\r\nhsw->param_idx_w = 0;\r\nhsw->param_idx_r = 0;\r\nmemset((void *)hsw->param_buf, 0, sizeof(hsw->param_buf));\r\n}\r\nint sst_hsw_store_param_line(struct sst_hsw *hsw, u8 *buf)\r\n{\r\nif (hsw->param_idx_w > WAVES_PARAM_LINES - 1) {\r\ndev_warn(hsw->dev, "warning: param buffer overflow!\n");\r\nreturn -EPERM;\r\n}\r\nmemcpy(hsw->param_buf[hsw->param_idx_w], buf, WAVES_PARAM_COUNT);\r\nhsw->param_idx_w++;\r\nreturn 0;\r\n}\r\nint sst_hsw_load_param_line(struct sst_hsw *hsw, u8 *buf)\r\n{\r\nu8 id = 0;\r\nwhile (hsw->param_idx_r < WAVES_PARAM_LINES) {\r\nid = hsw->param_buf[hsw->param_idx_r][0];\r\nhsw->param_idx_r++;\r\nif (buf[0] == id) {\r\nmemcpy(buf, hsw->param_buf[hsw->param_idx_r],\r\nWAVES_PARAM_COUNT);\r\nbreak;\r\n}\r\n}\r\nif (hsw->param_idx_r > WAVES_PARAM_LINES - 1) {\r\ndev_dbg(hsw->dev, "end of buffer, roll to the beginning\n");\r\nhsw->param_idx_r = 0;\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nint sst_hsw_launch_param_buf(struct sst_hsw *hsw)\r\n{\r\nint ret, idx;\r\nif (!sst_hsw_is_module_active(hsw, SST_HSW_MODULE_WAVES)) {\r\ndev_dbg(hsw->dev, "module waves is not active\n");\r\nreturn 0;\r\n}\r\nfor (idx = 0; idx < hsw->param_idx_w; idx++) {\r\nret = sst_hsw_module_set_param(hsw,\r\nSST_HSW_MODULE_WAVES, 0, hsw->param_buf[idx][0],\r\nWAVES_PARAM_COUNT, hsw->param_buf[idx]);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint sst_hsw_module_load(struct sst_hsw *hsw,\r\nu32 module_id, u32 instance_id, char *name)\r\n{\r\nint ret = 0;\r\nconst struct firmware *fw = NULL;\r\nstruct sst_fw *hsw_sst_fw;\r\nstruct sst_module *module;\r\nstruct device *dev = hsw->dev;\r\nstruct sst_dsp *dsp = hsw->dsp;\r\ndev_dbg(dev, "sst_hsw_module_load id=%d, name='%s'", module_id, name);\r\nmodule = sst_module_get_from_id(dsp, module_id);\r\nif (module == NULL) {\r\nif (module_id == SST_HSW_MODULE_BASE_FW) {\r\nfw = dsp->pdata->fw;\r\nif (!fw) {\r\ndev_err(dev, "request Base fw failed\n");\r\nreturn -ENODEV;\r\n}\r\n} else {\r\nret = request_firmware(&fw, name, dev);\r\nif (ret) {\r\ndev_info(dev, "fw image %s not available(%d)\n",\r\nname, ret);\r\nreturn ret;\r\n}\r\n}\r\nhsw_sst_fw = sst_fw_new(dsp, fw, hsw);\r\nif (hsw_sst_fw == NULL) {\r\ndev_err(dev, "error: failed to load firmware\n");\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nmodule = sst_module_get_from_id(dsp, module_id);\r\nif (module == NULL) {\r\ndev_err(dev, "error: no module %d in firmware %s\n",\r\nmodule_id, name);\r\n}\r\n} else\r\ndev_info(dev, "module %d (%s) already loaded\n",\r\nmodule_id, name);\r\nout:\r\nif (fw && module_id != SST_HSW_MODULE_BASE_FW)\r\nrelease_firmware(fw);\r\nreturn ret;\r\n}\r\nint sst_hsw_module_enable(struct sst_hsw *hsw,\r\nu32 module_id, u32 instance_id)\r\n{\r\nint ret;\r\nu32 header = 0;\r\nstruct sst_hsw_ipc_module_config config;\r\nstruct sst_module *module;\r\nstruct sst_module_runtime *runtime;\r\nstruct device *dev = hsw->dev;\r\nstruct sst_dsp *dsp = hsw->dsp;\r\nif (!sst_hsw_is_module_loaded(hsw, module_id)) {\r\ndev_dbg(dev, "module %d not loaded\n", module_id);\r\nreturn 0;\r\n}\r\nif (sst_hsw_is_module_active(hsw, module_id)) {\r\ndev_info(dev, "module %d already enabled\n", module_id);\r\nreturn 0;\r\n}\r\nmodule = sst_module_get_from_id(dsp, module_id);\r\nif (module == NULL) {\r\ndev_err(dev, "module %d not valid\n", module_id);\r\nreturn -ENXIO;\r\n}\r\nruntime = sst_module_runtime_get_from_id(module, module_id);\r\nif (runtime == NULL) {\r\ndev_err(dev, "runtime %d not valid", module_id);\r\nreturn -ENXIO;\r\n}\r\nheader = IPC_GLB_TYPE(IPC_GLB_MODULE_OPERATION) |\r\nIPC_MODULE_OPERATION(IPC_MODULE_ENABLE) |\r\nIPC_MODULE_ID(module_id);\r\ndev_dbg(dev, "module enable header: %x\n", header);\r\nconfig.map.module_entries_count = 1;\r\nconfig.map.module_entries[0].module_id = module->id;\r\nconfig.map.module_entries[0].entry_point = module->entry;\r\nconfig.persistent_mem.offset =\r\nsst_dsp_get_offset(dsp,\r\nruntime->persistent_offset, SST_MEM_DRAM);\r\nconfig.persistent_mem.size = module->persistent_size;\r\nconfig.scratch_mem.offset =\r\nsst_dsp_get_offset(dsp,\r\ndsp->scratch_offset, SST_MEM_DRAM);\r\nconfig.scratch_mem.size = module->scratch_size;\r\ndev_dbg(dev, "mod %d enable p:%d @ %x, s:%d @ %x, ep: %x",\r\nconfig.map.module_entries[0].module_id,\r\nconfig.persistent_mem.size,\r\nconfig.persistent_mem.offset,\r\nconfig.scratch_mem.size, config.scratch_mem.offset,\r\nconfig.map.module_entries[0].entry_point);\r\nret = sst_ipc_tx_message_wait(&hsw->ipc, header,\r\n&config, sizeof(config), NULL, 0);\r\nif (ret < 0)\r\ndev_err(dev, "ipc: module enable failed - %d\n", ret);\r\nelse\r\nmodule->state = SST_MODULE_STATE_ACTIVE;\r\nreturn ret;\r\n}\r\nint sst_hsw_module_disable(struct sst_hsw *hsw,\r\nu32 module_id, u32 instance_id)\r\n{\r\nint ret;\r\nu32 header;\r\nstruct sst_module *module;\r\nstruct device *dev = hsw->dev;\r\nstruct sst_dsp *dsp = hsw->dsp;\r\nif (!sst_hsw_is_module_loaded(hsw, module_id)) {\r\ndev_dbg(dev, "module %d not loaded\n", module_id);\r\nreturn 0;\r\n}\r\nif (!sst_hsw_is_module_active(hsw, module_id)) {\r\ndev_info(dev, "module %d already disabled\n", module_id);\r\nreturn 0;\r\n}\r\nmodule = sst_module_get_from_id(dsp, module_id);\r\nif (module == NULL) {\r\ndev_err(dev, "module %d not valid\n", module_id);\r\nreturn -ENXIO;\r\n}\r\nheader = IPC_GLB_TYPE(IPC_GLB_MODULE_OPERATION) |\r\nIPC_MODULE_OPERATION(IPC_MODULE_DISABLE) |\r\nIPC_MODULE_ID(module_id);\r\nret = sst_ipc_tx_message_wait(&hsw->ipc, header, NULL, 0, NULL, 0);\r\nif (ret < 0)\r\ndev_err(dev, "module disable failed - %d\n", ret);\r\nelse\r\nmodule->state = SST_MODULE_STATE_INITIALIZED;\r\nreturn ret;\r\n}\r\nint sst_hsw_module_set_param(struct sst_hsw *hsw,\r\nu32 module_id, u32 instance_id, u32 parameter_id,\r\nu32 param_size, char *param)\r\n{\r\nint ret;\r\nu32 header = 0;\r\nu32 payload_size = 0, transfer_parameter_size = 0;\r\nstruct sst_hsw_transfer_parameter *parameter;\r\nstruct device *dev = hsw->dev;\r\nheader = IPC_GLB_TYPE(IPC_GLB_MODULE_OPERATION) |\r\nIPC_MODULE_OPERATION(IPC_MODULE_SET_PARAMETER) |\r\nIPC_MODULE_ID(module_id);\r\ndev_dbg(dev, "sst_hsw_module_set_param header=%x\n", header);\r\npayload_size = param_size +\r\nsizeof(struct sst_hsw_transfer_parameter) -\r\nsizeof(struct sst_hsw_transfer_list);\r\ndev_dbg(dev, "parameter size : %d\n", param_size);\r\ndev_dbg(dev, "payload size : %d\n", payload_size);\r\nif (payload_size <= SST_HSW_IPC_MAX_SHORT_PARAMETER_SIZE) {\r\ndev_dbg(dev, "transfer parameter size : %d\n",\r\ntransfer_parameter_size);\r\ntransfer_parameter_size = ALIGN(payload_size, 4);\r\ndev_dbg(dev, "transfer parameter aligned size : %d\n",\r\ntransfer_parameter_size);\r\nparameter = kzalloc(transfer_parameter_size, GFP_KERNEL);\r\nif (parameter == NULL)\r\nreturn -ENOMEM;\r\nmemcpy(parameter->data, param, param_size);\r\n} else {\r\ndev_warn(dev, "transfer parameter size too large!");\r\nreturn 0;\r\n}\r\nparameter->parameter_id = parameter_id;\r\nparameter->data_size = param_size;\r\nret = sst_ipc_tx_message_wait(&hsw->ipc, header,\r\nparameter, transfer_parameter_size , NULL, 0);\r\nif (ret < 0)\r\ndev_err(dev, "ipc: module set parameter failed - %d\n", ret);\r\nkfree(parameter);\r\nreturn ret;\r\n}\r\nstatic void hsw_tx_msg(struct sst_generic_ipc *ipc, struct ipc_message *msg)\r\n{\r\nsst_dsp_outbox_write(ipc->dsp, msg->tx_data, msg->tx_size);\r\nsst_dsp_ipc_msg_tx(ipc->dsp, msg->header);\r\n}\r\nstatic void hsw_shim_dbg(struct sst_generic_ipc *ipc, const char *text)\r\n{\r\nstruct sst_dsp *sst = ipc->dsp;\r\nu32 isr, ipcd, imrx, ipcx;\r\nipcx = sst_dsp_shim_read_unlocked(sst, SST_IPCX);\r\nisr = sst_dsp_shim_read_unlocked(sst, SST_ISRX);\r\nipcd = sst_dsp_shim_read_unlocked(sst, SST_IPCD);\r\nimrx = sst_dsp_shim_read_unlocked(sst, SST_IMRX);\r\ndev_err(ipc->dev,\r\n"ipc: --%s-- ipcx 0x%8.8x isr 0x%8.8x ipcd 0x%8.8x imrx 0x%8.8x\n",\r\ntext, ipcx, isr, ipcd, imrx);\r\n}\r\nstatic void hsw_tx_data_copy(struct ipc_message *msg, char *tx_data,\r\nsize_t tx_size)\r\n{\r\nmemcpy(msg->tx_data, tx_data, tx_size);\r\n}\r\nstatic u64 hsw_reply_msg_match(u64 header, u64 *mask)\r\n{\r\nheader &= ~(IPC_STATUS_MASK | IPC_GLB_REPLY_MASK);\r\n*mask = (u64)-1;\r\nreturn header;\r\n}\r\nstatic bool hsw_is_dsp_busy(struct sst_dsp *dsp)\r\n{\r\nu64 ipcx;\r\nipcx = sst_dsp_shim_read_unlocked(dsp, SST_IPCX);\r\nreturn (ipcx & (SST_IPCX_BUSY | SST_IPCX_DONE));\r\n}\r\nint sst_hsw_dsp_init(struct device *dev, struct sst_pdata *pdata)\r\n{\r\nstruct sst_hsw_ipc_fw_version version;\r\nstruct sst_hsw *hsw;\r\nstruct sst_generic_ipc *ipc;\r\nint ret;\r\ndev_dbg(dev, "initialising Audio DSP IPC\n");\r\nhsw = devm_kzalloc(dev, sizeof(*hsw), GFP_KERNEL);\r\nif (hsw == NULL)\r\nreturn -ENOMEM;\r\nhsw->dev = dev;\r\nipc = &hsw->ipc;\r\nipc->dev = dev;\r\nipc->ops.tx_msg = hsw_tx_msg;\r\nipc->ops.shim_dbg = hsw_shim_dbg;\r\nipc->ops.tx_data_copy = hsw_tx_data_copy;\r\nipc->ops.reply_msg_match = hsw_reply_msg_match;\r\nipc->ops.is_dsp_busy = hsw_is_dsp_busy;\r\nipc->tx_data_max_size = IPC_MAX_MAILBOX_BYTES;\r\nipc->rx_data_max_size = IPC_MAX_MAILBOX_BYTES;\r\nret = sst_ipc_init(ipc);\r\nif (ret != 0)\r\ngoto ipc_init_err;\r\nINIT_LIST_HEAD(&hsw->stream_list);\r\ninit_waitqueue_head(&hsw->boot_wait);\r\nhsw_dev.thread_context = hsw;\r\nhsw->dsp = sst_dsp_new(dev, &hsw_dev, pdata);\r\nif (hsw->dsp == NULL) {\r\nret = -ENODEV;\r\ngoto dsp_new_err;\r\n}\r\nipc->dsp = hsw->dsp;\r\nhsw->dx_context = dma_alloc_coherent(hsw->dsp->dma_dev,\r\nSST_HSW_DX_CONTEXT_SIZE, &hsw->dx_context_paddr, GFP_KERNEL);\r\nif (hsw->dx_context == NULL) {\r\nret = -ENOMEM;\r\ngoto dma_err;\r\n}\r\nsst_dsp_reset(hsw->dsp);\r\nret = sst_hsw_module_load(hsw, SST_HSW_MODULE_BASE_FW, 0, "Base");\r\nif (ret < 0)\r\ngoto fw_err;\r\nsst_hsw_module_load(hsw, SST_HSW_MODULE_WAVES, 0, "intel/IntcPP01.bin");\r\nret = sst_block_alloc_scratch(hsw->dsp);\r\nif (ret < 0)\r\ngoto boot_err;\r\nsst_hsw_reset_param_buf(hsw);\r\nsst_dsp_boot(hsw->dsp);\r\nret = wait_event_timeout(hsw->boot_wait, hsw->boot_complete,\r\nmsecs_to_jiffies(IPC_BOOT_MSECS));\r\nif (ret == 0) {\r\nret = -EIO;\r\ndev_err(hsw->dev, "error: audio DSP boot timeout IPCD 0x%x IPCX 0x%x\n",\r\nsst_dsp_shim_read_unlocked(hsw->dsp, SST_IPCD),\r\nsst_dsp_shim_read_unlocked(hsw->dsp, SST_IPCX));\r\ngoto boot_err;\r\n}\r\nsst_hsw_init_module_state(hsw);\r\nsst_hsw_fw_get_version(hsw, &version);\r\nret = sst_hsw_mixer_get_info(hsw);\r\nif (ret < 0) {\r\ndev_err(hsw->dev, "error: failed to get stream info\n");\r\ngoto boot_err;\r\n}\r\npdata->dsp = hsw;\r\nreturn 0;\r\nboot_err:\r\nsst_dsp_reset(hsw->dsp);\r\nsst_fw_free_all(hsw->dsp);\r\nfw_err:\r\ndma_free_coherent(hsw->dsp->dma_dev, SST_HSW_DX_CONTEXT_SIZE,\r\nhsw->dx_context, hsw->dx_context_paddr);\r\ndma_err:\r\nsst_dsp_free(hsw->dsp);\r\ndsp_new_err:\r\nsst_ipc_fini(ipc);\r\nipc_init_err:\r\nreturn ret;\r\n}\r\nvoid sst_hsw_dsp_free(struct device *dev, struct sst_pdata *pdata)\r\n{\r\nstruct sst_hsw *hsw = pdata->dsp;\r\nsst_dsp_reset(hsw->dsp);\r\nsst_fw_free_all(hsw->dsp);\r\ndma_free_coherent(hsw->dsp->dma_dev, SST_HSW_DX_CONTEXT_SIZE,\r\nhsw->dx_context, hsw->dx_context_paddr);\r\nsst_dsp_free(hsw->dsp);\r\nsst_ipc_fini(&hsw->ipc);\r\n}
