static inline unsigned int rpm_from_cnt(u8 val, u32 clk, u16 div)\r\n{\r\nreturn ((val == 0x00) ? 0 : ((clk*30)/(val*div)));\r\n}\r\nstatic int g760a_read_value(struct i2c_client *client, enum g760a_regs reg)\r\n{\r\nreturn i2c_smbus_read_byte_data(client, reg);\r\n}\r\nstatic int g760a_write_value(struct i2c_client *client, enum g760a_regs reg,\r\nu16 value)\r\n{\r\nreturn i2c_smbus_write_byte_data(client, reg, value);\r\n}\r\nstatic struct g760a_data *g760a_update_client(struct device *dev)\r\n{\r\nstruct g760a_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nmutex_lock(&data->update_lock);\r\nif (time_after(jiffies, data->last_updated + G760A_UPDATE_INTERVAL)\r\n|| !data->valid) {\r\ndev_dbg(&client->dev, "Starting g760a update\n");\r\ndata->set_cnt = g760a_read_value(client, G760A_REG_SET_CNT);\r\ndata->act_cnt = g760a_read_value(client, G760A_REG_ACT_CNT);\r\ndata->fan_sta = g760a_read_value(client, G760A_REG_FAN_STA);\r\ndata->last_updated = jiffies;\r\ndata->valid = 1;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn data;\r\n}\r\nstatic ssize_t fan1_input_show(struct device *dev,\r\nstruct device_attribute *da, char *buf)\r\n{\r\nstruct g760a_data *data = g760a_update_client(dev);\r\nunsigned int rpm = 0;\r\nmutex_lock(&data->update_lock);\r\nif (!(data->fan_sta & G760A_REG_FAN_STA_RPM_LOW))\r\nrpm = rpm_from_cnt(data->act_cnt, data->clk, data->fan_div);\r\nmutex_unlock(&data->update_lock);\r\nreturn sprintf(buf, "%d\n", rpm);\r\n}\r\nstatic ssize_t fan1_alarm_show(struct device *dev,\r\nstruct device_attribute *da, char *buf)\r\n{\r\nstruct g760a_data *data = g760a_update_client(dev);\r\nint fan_alarm = (data->fan_sta & G760A_REG_FAN_STA_RPM_OFF) ? 1 : 0;\r\nreturn sprintf(buf, "%d\n", fan_alarm);\r\n}\r\nstatic ssize_t pwm1_show(struct device *dev, struct device_attribute *da,\r\nchar *buf)\r\n{\r\nstruct g760a_data *data = g760a_update_client(dev);\r\nreturn sprintf(buf, "%d\n", PWM_FROM_CNT(data->set_cnt));\r\n}\r\nstatic ssize_t pwm1_store(struct device *dev, struct device_attribute *da,\r\nconst char *buf, size_t count)\r\n{\r\nstruct g760a_data *data = g760a_update_client(dev);\r\nstruct i2c_client *client = data->client;\r\nunsigned long val;\r\nif (kstrtoul(buf, 10, &val))\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\ndata->set_cnt = PWM_TO_CNT(clamp_val(val, 0, 255));\r\ng760a_write_value(client, G760A_REG_SET_CNT, data->set_cnt);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic int g760a_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &client->dev;\r\nstruct g760a_data *data;\r\nstruct device *hwmon_dev;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -EIO;\r\ndata = devm_kzalloc(dev, sizeof(struct g760a_data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->client = client;\r\nmutex_init(&data->update_lock);\r\ndata->fan_div = G760A_DEFAULT_FAN_DIV;\r\ndata->clk = G760A_DEFAULT_CLK;\r\nhwmon_dev = devm_hwmon_device_register_with_groups(dev, client->name,\r\ndata,\r\ng760a_groups);\r\nreturn PTR_ERR_OR_ZERO(hwmon_dev);\r\n}
