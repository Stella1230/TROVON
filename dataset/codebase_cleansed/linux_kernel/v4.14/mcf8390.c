static inline u32 NE_PTR(u32 addr)\r\n{\r\nif (addr & 1)\r\nreturn addr - 1 + NE2000_ODDOFFSET;\r\nreturn addr;\r\n}\r\nstatic inline u32 NE_DATA_PTR(u32 addr)\r\n{\r\nreturn addr;\r\n}\r\nvoid ei_outb(u32 val, u32 addr)\r\n{\r\nNE2000_BYTE *rp;\r\nrp = (NE2000_BYTE *) NE_PTR(addr);\r\n*rp = RSWAP(val);\r\n}\r\nu8 ei_inb(u32 addr)\r\n{\r\nNE2000_BYTE *rp, val;\r\nrp = (NE2000_BYTE *) NE_PTR(addr);\r\nval = *rp;\r\nreturn (u8) (RSWAP(val) & 0xff);\r\n}\r\nvoid ei_insb(u32 addr, void *vbuf, int len)\r\n{\r\nNE2000_BYTE *rp, val;\r\nu8 *buf;\r\nbuf = (u8 *) vbuf;\r\nrp = (NE2000_BYTE *) NE_DATA_PTR(addr);\r\nfor (; (len > 0); len--) {\r\nval = *rp;\r\n*buf++ = RSWAP(val);\r\n}\r\n}\r\nvoid ei_insw(u32 addr, void *vbuf, int len)\r\n{\r\nvolatile u16 *rp;\r\nu16 w, *buf;\r\nbuf = (u16 *) vbuf;\r\nrp = (volatile u16 *) NE_DATA_PTR(addr);\r\nfor (; (len > 0); len--) {\r\nw = *rp;\r\n*buf++ = BSWAP(w);\r\n}\r\n}\r\nvoid ei_outsb(u32 addr, const void *vbuf, int len)\r\n{\r\nNE2000_BYTE *rp, val;\r\nu8 *buf;\r\nbuf = (u8 *) vbuf;\r\nrp = (NE2000_BYTE *) NE_DATA_PTR(addr);\r\nfor (; (len > 0); len--) {\r\nval = *buf++;\r\n*rp = RSWAP(val);\r\n}\r\n}\r\nvoid ei_outsw(u32 addr, const void *vbuf, int len)\r\n{\r\nvolatile u16 *rp;\r\nu16 w, *buf;\r\nbuf = (u16 *) vbuf;\r\nrp = (volatile u16 *) NE_DATA_PTR(addr);\r\nfor (; (len > 0); len--) {\r\nw = *buf++;\r\n*rp = BSWAP(w);\r\n}\r\n}\r\nstatic void mcf8390_reset_8390(struct net_device *dev)\r\n{\r\nunsigned long reset_start_time = jiffies;\r\nu32 addr = dev->base_addr;\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nnetif_dbg(ei_local, hw, dev, "resetting the 8390 t=%ld...\n", jiffies);\r\nei_outb(ei_inb(addr + NE_RESET), addr + NE_RESET);\r\nei_status.txing = 0;\r\nei_status.dmaing = 0;\r\nwhile ((ei_inb(addr + NE_EN0_ISR) & ENISR_RESET) == 0) {\r\nif (time_after(jiffies, reset_start_time + 2 * HZ / 100)) {\r\nnetdev_warn(dev, "%s: did not complete\n", __func__);\r\nbreak;\r\n}\r\n}\r\nei_outb(ENISR_RESET, addr + NE_EN0_ISR);\r\n}\r\nstatic void mcf8390_dmaing_err(const char *func, struct net_device *dev,\r\nstruct ei_device *ei_local)\r\n{\r\nnetdev_err(dev, "%s: DMAing conflict [DMAstat:%d][irqlock:%d]\n",\r\nfunc, ei_local->dmaing, ei_local->irqlock);\r\n}\r\nstatic void mcf8390_get_8390_hdr(struct net_device *dev,\r\nstruct e8390_pkt_hdr *hdr, int ring_page)\r\n{\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nu32 addr = dev->base_addr;\r\nif (ei_local->dmaing) {\r\nmcf8390_dmaing_err(__func__, dev, ei_local);\r\nreturn;\r\n}\r\nei_local->dmaing |= 0x01;\r\nei_outb(E8390_NODMA + E8390_PAGE0 + E8390_START, addr + NE_CMD);\r\nei_outb(ENISR_RDC, addr + NE_EN0_ISR);\r\nei_outb(sizeof(struct e8390_pkt_hdr), addr + NE_EN0_RCNTLO);\r\nei_outb(0, addr + NE_EN0_RCNTHI);\r\nei_outb(0, addr + NE_EN0_RSARLO);\r\nei_outb(ring_page, addr + NE_EN0_RSARHI);\r\nei_outb(E8390_RREAD + E8390_START, addr + NE_CMD);\r\nei_insw(addr + NE_DATAPORT, hdr, sizeof(struct e8390_pkt_hdr) >> 1);\r\noutb(ENISR_RDC, addr + NE_EN0_ISR);\r\nei_local->dmaing &= ~0x01;\r\nhdr->count = cpu_to_le16(hdr->count);\r\n}\r\nstatic void mcf8390_block_input(struct net_device *dev, int count,\r\nstruct sk_buff *skb, int ring_offset)\r\n{\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nu32 addr = dev->base_addr;\r\nchar *buf = skb->data;\r\nif (ei_local->dmaing) {\r\nmcf8390_dmaing_err(__func__, dev, ei_local);\r\nreturn;\r\n}\r\nei_local->dmaing |= 0x01;\r\nei_outb(E8390_NODMA + E8390_PAGE0 + E8390_START, addr + NE_CMD);\r\nei_outb(ENISR_RDC, addr + NE_EN0_ISR);\r\nei_outb(count & 0xff, addr + NE_EN0_RCNTLO);\r\nei_outb(count >> 8, addr + NE_EN0_RCNTHI);\r\nei_outb(ring_offset & 0xff, addr + NE_EN0_RSARLO);\r\nei_outb(ring_offset >> 8, addr + NE_EN0_RSARHI);\r\nei_outb(E8390_RREAD + E8390_START, addr + NE_CMD);\r\nei_insw(addr + NE_DATAPORT, buf, count >> 1);\r\nif (count & 1)\r\nbuf[count - 1] = ei_inb(addr + NE_DATAPORT);\r\nei_outb(ENISR_RDC, addr + NE_EN0_ISR);\r\nei_local->dmaing &= ~0x01;\r\n}\r\nstatic void mcf8390_block_output(struct net_device *dev, int count,\r\nconst unsigned char *buf,\r\nconst int start_page)\r\n{\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nu32 addr = dev->base_addr;\r\nunsigned long dma_start;\r\nif (count & 0x1)\r\ncount++;\r\nif (ei_local->dmaing) {\r\nmcf8390_dmaing_err(__func__, dev, ei_local);\r\nreturn;\r\n}\r\nei_local->dmaing |= 0x01;\r\nei_outb(E8390_PAGE0 + E8390_START + E8390_NODMA, addr + NE_CMD);\r\nei_outb(ENISR_RDC, addr + NE_EN0_ISR);\r\nei_outb(count & 0xff, addr + NE_EN0_RCNTLO);\r\nei_outb(count >> 8, addr + NE_EN0_RCNTHI);\r\nei_outb(0x00, addr + NE_EN0_RSARLO);\r\nei_outb(start_page, addr + NE_EN0_RSARHI);\r\nei_outb(E8390_RWRITE + E8390_START, addr + NE_CMD);\r\nei_outsw(addr + NE_DATAPORT, buf, count >> 1);\r\ndma_start = jiffies;\r\nwhile ((ei_inb(addr + NE_EN0_ISR) & ENISR_RDC) == 0) {\r\nif (time_after(jiffies, dma_start + 2 * HZ / 100)) {\r\nnetdev_warn(dev, "timeout waiting for Tx RDC\n");\r\nmcf8390_reset_8390(dev);\r\n__NS8390_init(dev, 1);\r\nbreak;\r\n}\r\n}\r\nei_outb(ENISR_RDC, addr + NE_EN0_ISR);\r\nei_local->dmaing &= ~0x01;\r\n}\r\nstatic int mcf8390_init(struct net_device *dev)\r\n{\r\nstatic u32 offsets[] = {\r\n0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\r\n0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\r\n};\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nunsigned char SA_prom[32];\r\nu32 addr = dev->base_addr;\r\nint start_page, stop_page;\r\nint i, ret;\r\nmcf8390_reset_8390(dev);\r\n{\r\nstatic const struct {\r\nu32 value;\r\nu32 offset;\r\n} program_seq[] = {\r\n{E8390_NODMA + E8390_PAGE0 + E8390_STOP, NE_CMD},\r\n{0x48, NE_EN0_DCFG},\r\n{0x00, NE_EN0_RCNTLO},\r\n{0x00, NE_EN0_RCNTHI},\r\n{0x00, NE_EN0_IMR},\r\n{0xFF, NE_EN0_ISR},\r\n{E8390_RXOFF, NE_EN0_RXCR},\r\n{E8390_TXOFF, NE_EN0_TXCR},\r\n{32, NE_EN0_RCNTLO},\r\n{0x00, NE_EN0_RCNTHI},\r\n{0x00, NE_EN0_RSARLO},\r\n{0x00, NE_EN0_RSARHI},\r\n{E8390_RREAD + E8390_START, NE_CMD},\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(program_seq); i++) {\r\nei_outb(program_seq[i].value,\r\naddr + program_seq[i].offset);\r\n}\r\n}\r\nfor (i = 0; i < 16; i++) {\r\nSA_prom[i] = ei_inb(addr + NE_DATAPORT);\r\nei_inb(addr + NE_DATAPORT);\r\n}\r\nei_outb(0x49, addr + NE_EN0_DCFG);\r\nstart_page = NESM_START_PG;\r\nstop_page = NESM_STOP_PG;\r\nret = request_irq(dev->irq, __ei_interrupt, 0, dev->name, dev);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < ETH_ALEN; i++)\r\ndev->dev_addr[i] = SA_prom[i];\r\nnetdev_dbg(dev, "Found ethernet address: %pM\n", dev->dev_addr);\r\nei_local->name = "mcf8390";\r\nei_local->tx_start_page = start_page;\r\nei_local->stop_page = stop_page;\r\nei_local->word16 = 1;\r\nei_local->rx_start_page = start_page + TX_PAGES;\r\nei_local->reset_8390 = mcf8390_reset_8390;\r\nei_local->block_input = mcf8390_block_input;\r\nei_local->block_output = mcf8390_block_output;\r\nei_local->get_8390_hdr = mcf8390_get_8390_hdr;\r\nei_local->reg_offset = offsets;\r\ndev->netdev_ops = &mcf8390_netdev_ops;\r\n__NS8390_init(dev, 0);\r\nret = register_netdev(dev);\r\nif (ret) {\r\nfree_irq(dev->irq, dev);\r\nreturn ret;\r\n}\r\nnetdev_info(dev, "addr=0x%08x irq=%d, Ethernet Address %pM\n",\r\naddr, dev->irq, dev->dev_addr);\r\nreturn 0;\r\n}\r\nstatic int mcf8390_probe(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev;\r\nstruct ei_device *ei_local;\r\nstruct resource *mem, *irq;\r\nresource_size_t msize;\r\nint ret;\r\nirq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (irq == NULL) {\r\ndev_err(&pdev->dev, "no IRQ specified?\n");\r\nreturn -ENXIO;\r\n}\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (mem == NULL) {\r\ndev_err(&pdev->dev, "no memory address specified?\n");\r\nreturn -ENXIO;\r\n}\r\nmsize = resource_size(mem);\r\nif (!request_mem_region(mem->start, msize, pdev->name))\r\nreturn -EBUSY;\r\ndev = ____alloc_ei_netdev(0);\r\nif (dev == NULL) {\r\nrelease_mem_region(mem->start, msize);\r\nreturn -ENOMEM;\r\n}\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\nplatform_set_drvdata(pdev, dev);\r\nei_local = netdev_priv(dev);\r\nei_local->msg_enable = mcf8390_msg_enable;\r\ndev->irq = irq->start;\r\ndev->base_addr = mem->start;\r\nret = mcf8390_init(dev);\r\nif (ret) {\r\nrelease_mem_region(mem->start, msize);\r\nfree_netdev(dev);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mcf8390_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(pdev);\r\nstruct resource *mem;\r\nunregister_netdev(dev);\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (mem)\r\nrelease_mem_region(mem->start, resource_size(mem));\r\nfree_netdev(dev);\r\nreturn 0;\r\n}
