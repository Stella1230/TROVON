static u_long get_line_length(int xres_virtual, int bpp)\r\n{\r\nu_long length;\r\nlength = xres_virtual * bpp;\r\nlength = (length + 31) & ~31;\r\nlength >>= 3;\r\nreturn (length);\r\n}\r\nstatic int vfb_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nu_long line_length;\r\nif (var->vmode & FB_VMODE_CONUPDATE) {\r\nvar->vmode |= FB_VMODE_YWRAP;\r\nvar->xoffset = info->var.xoffset;\r\nvar->yoffset = info->var.yoffset;\r\n}\r\nif (!var->xres)\r\nvar->xres = 1;\r\nif (!var->yres)\r\nvar->yres = 1;\r\nif (var->xres > var->xres_virtual)\r\nvar->xres_virtual = var->xres;\r\nif (var->yres > var->yres_virtual)\r\nvar->yres_virtual = var->yres;\r\nif (var->bits_per_pixel <= 1)\r\nvar->bits_per_pixel = 1;\r\nelse if (var->bits_per_pixel <= 8)\r\nvar->bits_per_pixel = 8;\r\nelse if (var->bits_per_pixel <= 16)\r\nvar->bits_per_pixel = 16;\r\nelse if (var->bits_per_pixel <= 24)\r\nvar->bits_per_pixel = 24;\r\nelse if (var->bits_per_pixel <= 32)\r\nvar->bits_per_pixel = 32;\r\nelse\r\nreturn -EINVAL;\r\nif (var->xres_virtual < var->xoffset + var->xres)\r\nvar->xres_virtual = var->xoffset + var->xres;\r\nif (var->yres_virtual < var->yoffset + var->yres)\r\nvar->yres_virtual = var->yoffset + var->yres;\r\nline_length =\r\nget_line_length(var->xres_virtual, var->bits_per_pixel);\r\nif (line_length * var->yres_virtual > videomemorysize)\r\nreturn -ENOMEM;\r\nswitch (var->bits_per_pixel) {\r\ncase 1:\r\ncase 8:\r\nvar->red.offset = 0;\r\nvar->red.length = 8;\r\nvar->green.offset = 0;\r\nvar->green.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 8;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nbreak;\r\ncase 16:\r\nif (var->transp.length) {\r\nvar->red.offset = 0;\r\nvar->red.length = 5;\r\nvar->green.offset = 5;\r\nvar->green.length = 5;\r\nvar->blue.offset = 10;\r\nvar->blue.length = 5;\r\nvar->transp.offset = 15;\r\nvar->transp.length = 1;\r\n} else {\r\nvar->red.offset = 0;\r\nvar->red.length = 5;\r\nvar->green.offset = 5;\r\nvar->green.length = 6;\r\nvar->blue.offset = 11;\r\nvar->blue.length = 5;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\n}\r\nbreak;\r\ncase 24:\r\nvar->red.offset = 0;\r\nvar->red.length = 8;\r\nvar->green.offset = 8;\r\nvar->green.length = 8;\r\nvar->blue.offset = 16;\r\nvar->blue.length = 8;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nbreak;\r\ncase 32:\r\nvar->red.offset = 0;\r\nvar->red.length = 8;\r\nvar->green.offset = 8;\r\nvar->green.length = 8;\r\nvar->blue.offset = 16;\r\nvar->blue.length = 8;\r\nvar->transp.offset = 24;\r\nvar->transp.length = 8;\r\nbreak;\r\n}\r\nvar->red.msb_right = 0;\r\nvar->green.msb_right = 0;\r\nvar->blue.msb_right = 0;\r\nvar->transp.msb_right = 0;\r\nreturn 0;\r\n}\r\nstatic int vfb_set_par(struct fb_info *info)\r\n{\r\ninfo->fix.line_length = get_line_length(info->var.xres_virtual,\r\ninfo->var.bits_per_pixel);\r\nreturn 0;\r\n}\r\nstatic int vfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\r\nu_int transp, struct fb_info *info)\r\n{\r\nif (regno >= 256)\r\nreturn 1;\r\nif (info->var.grayscale) {\r\nred = green = blue =\r\n(red * 77 + green * 151 + blue * 28) >> 8;\r\n}\r\n#define CNVT_TOHW(val,width) ((((val)<<(width))+0x7FFF-(val))>>16)\r\nswitch (info->fix.visual) {\r\ncase FB_VISUAL_TRUECOLOR:\r\ncase FB_VISUAL_PSEUDOCOLOR:\r\nred = CNVT_TOHW(red, info->var.red.length);\r\ngreen = CNVT_TOHW(green, info->var.green.length);\r\nblue = CNVT_TOHW(blue, info->var.blue.length);\r\ntransp = CNVT_TOHW(transp, info->var.transp.length);\r\nbreak;\r\ncase FB_VISUAL_DIRECTCOLOR:\r\nred = CNVT_TOHW(red, 8);\r\ngreen = CNVT_TOHW(green, 8);\r\nblue = CNVT_TOHW(blue, 8);\r\ntransp = CNVT_TOHW(transp, 8);\r\nbreak;\r\n}\r\n#undef CNVT_TOHW\r\nif (info->fix.visual == FB_VISUAL_TRUECOLOR) {\r\nu32 v;\r\nif (regno >= 16)\r\nreturn 1;\r\nv = (red << info->var.red.offset) |\r\n(green << info->var.green.offset) |\r\n(blue << info->var.blue.offset) |\r\n(transp << info->var.transp.offset);\r\nswitch (info->var.bits_per_pixel) {\r\ncase 8:\r\nbreak;\r\ncase 16:\r\n((u32 *) (info->pseudo_palette))[regno] = v;\r\nbreak;\r\ncase 24:\r\ncase 32:\r\n((u32 *) (info->pseudo_palette))[regno] = v;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vfb_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nif (var->vmode & FB_VMODE_YWRAP) {\r\nif (var->yoffset >= info->var.yres_virtual ||\r\nvar->xoffset)\r\nreturn -EINVAL;\r\n} else {\r\nif (var->xoffset + info->var.xres > info->var.xres_virtual ||\r\nvar->yoffset + info->var.yres > info->var.yres_virtual)\r\nreturn -EINVAL;\r\n}\r\ninfo->var.xoffset = var->xoffset;\r\ninfo->var.yoffset = var->yoffset;\r\nif (var->vmode & FB_VMODE_YWRAP)\r\ninfo->var.vmode |= FB_VMODE_YWRAP;\r\nelse\r\ninfo->var.vmode &= ~FB_VMODE_YWRAP;\r\nreturn 0;\r\n}\r\nstatic int vfb_mmap(struct fb_info *info,\r\nstruct vm_area_struct *vma)\r\n{\r\nreturn remap_vmalloc_range(vma, (void *)info->fix.smem_start, vma->vm_pgoff);\r\n}\r\nstatic int __init vfb_setup(char *options)\r\n{\r\nchar *this_opt;\r\nvfb_enable = 0;\r\nif (!options)\r\nreturn 1;\r\nvfb_enable = 1;\r\nif (!*options)\r\nreturn 1;\r\nwhile ((this_opt = strsep(&options, ",")) != NULL) {\r\nif (!*this_opt)\r\ncontinue;\r\nif (!strcmp(this_opt, "disable"))\r\nvfb_enable = 0;\r\nelse\r\nmode_option = this_opt;\r\n}\r\nreturn 1;\r\n}\r\nstatic int vfb_probe(struct platform_device *dev)\r\n{\r\nstruct fb_info *info;\r\nunsigned int size = PAGE_ALIGN(videomemorysize);\r\nint retval = -ENOMEM;\r\nif (!(videomemory = vmalloc_32_user(size)))\r\nreturn retval;\r\ninfo = framebuffer_alloc(sizeof(u32) * 256, &dev->dev);\r\nif (!info)\r\ngoto err;\r\ninfo->screen_base = (char __iomem *)videomemory;\r\ninfo->fbops = &vfb_ops;\r\nif (!fb_find_mode(&info->var, info, mode_option,\r\nNULL, 0, &vfb_default, 8)){\r\nfb_err(info, "Unable to find usable video mode.\n");\r\nretval = -EINVAL;\r\ngoto err1;\r\n}\r\nvfb_fix.smem_start = (unsigned long) videomemory;\r\nvfb_fix.smem_len = videomemorysize;\r\ninfo->fix = vfb_fix;\r\ninfo->pseudo_palette = info->par;\r\ninfo->par = NULL;\r\ninfo->flags = FBINFO_FLAG_DEFAULT;\r\nretval = fb_alloc_cmap(&info->cmap, 256, 0);\r\nif (retval < 0)\r\ngoto err1;\r\nretval = register_framebuffer(info);\r\nif (retval < 0)\r\ngoto err2;\r\nplatform_set_drvdata(dev, info);\r\nfb_info(info, "Virtual frame buffer device, using %ldK of video memory\n",\r\nvideomemorysize >> 10);\r\nreturn 0;\r\nerr2:\r\nfb_dealloc_cmap(&info->cmap);\r\nerr1:\r\nframebuffer_release(info);\r\nerr:\r\nvfree(videomemory);\r\nreturn retval;\r\n}\r\nstatic int vfb_remove(struct platform_device *dev)\r\n{\r\nstruct fb_info *info = platform_get_drvdata(dev);\r\nif (info) {\r\nunregister_framebuffer(info);\r\nvfree(videomemory);\r\nfb_dealloc_cmap(&info->cmap);\r\nframebuffer_release(info);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init vfb_init(void)\r\n{\r\nint ret = 0;\r\n#ifndef MODULE\r\nchar *option = NULL;\r\nif (fb_get_options("vfb", &option))\r\nreturn -ENODEV;\r\nvfb_setup(option);\r\n#endif\r\nif (!vfb_enable)\r\nreturn -ENXIO;\r\nret = platform_driver_register(&vfb_driver);\r\nif (!ret) {\r\nvfb_device = platform_device_alloc("vfb", 0);\r\nif (vfb_device)\r\nret = platform_device_add(vfb_device);\r\nelse\r\nret = -ENOMEM;\r\nif (ret) {\r\nplatform_device_put(vfb_device);\r\nplatform_driver_unregister(&vfb_driver);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit vfb_exit(void)\r\n{\r\nplatform_device_unregister(vfb_device);\r\nplatform_driver_unregister(&vfb_driver);\r\n}
