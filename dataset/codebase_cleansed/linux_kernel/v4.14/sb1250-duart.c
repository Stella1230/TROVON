static u64 __read_sbdchn(struct sbd_port *sport, int reg)\r\n{\r\nvoid __iomem *csr = sport->port.membase + reg;\r\nreturn __raw_readq(csr);\r\n}\r\nstatic u64 __read_sbdshr(struct sbd_port *sport, int reg)\r\n{\r\nvoid __iomem *csr = sport->memctrl + reg;\r\nreturn __raw_readq(csr);\r\n}\r\nstatic void __write_sbdchn(struct sbd_port *sport, int reg, u64 value)\r\n{\r\nvoid __iomem *csr = sport->port.membase + reg;\r\n__raw_writeq(value, csr);\r\n}\r\nstatic void __write_sbdshr(struct sbd_port *sport, int reg, u64 value)\r\n{\r\nvoid __iomem *csr = sport->memctrl + reg;\r\n__raw_writeq(value, csr);\r\n}\r\nstatic void __war_sbd1956(struct sbd_port *sport)\r\n{\r\n__read_sbdchn(sport, R_DUART_MODE_REG_1);\r\n__read_sbdchn(sport, R_DUART_MODE_REG_2);\r\n}\r\nstatic unsigned char read_sbdchn(struct sbd_port *sport, int reg)\r\n{\r\nunsigned char retval;\r\nretval = __read_sbdchn(sport, reg);\r\nif (SIBYTE_1956_WAR)\r\n__war_sbd1956(sport);\r\nreturn retval;\r\n}\r\nstatic unsigned char read_sbdshr(struct sbd_port *sport, int reg)\r\n{\r\nunsigned char retval;\r\nretval = __read_sbdshr(sport, reg);\r\nif (SIBYTE_1956_WAR)\r\n__war_sbd1956(sport);\r\nreturn retval;\r\n}\r\nstatic void write_sbdchn(struct sbd_port *sport, int reg, unsigned int value)\r\n{\r\n__write_sbdchn(sport, reg, value);\r\nif (SIBYTE_1956_WAR)\r\n__war_sbd1956(sport);\r\n}\r\nstatic void write_sbdshr(struct sbd_port *sport, int reg, unsigned int value)\r\n{\r\n__write_sbdshr(sport, reg, value);\r\nif (SIBYTE_1956_WAR)\r\n__war_sbd1956(sport);\r\n}\r\nstatic int sbd_receive_ready(struct sbd_port *sport)\r\n{\r\nreturn read_sbdchn(sport, R_DUART_STATUS) & M_DUART_RX_RDY;\r\n}\r\nstatic int sbd_receive_drain(struct sbd_port *sport)\r\n{\r\nint loops = 10000;\r\nwhile (sbd_receive_ready(sport) && --loops)\r\nread_sbdchn(sport, R_DUART_RX_HOLD);\r\nreturn loops;\r\n}\r\nstatic int __maybe_unused sbd_transmit_ready(struct sbd_port *sport)\r\n{\r\nreturn read_sbdchn(sport, R_DUART_STATUS) & M_DUART_TX_RDY;\r\n}\r\nstatic int __maybe_unused sbd_transmit_drain(struct sbd_port *sport)\r\n{\r\nint loops = 10000;\r\nwhile (!sbd_transmit_ready(sport) && --loops)\r\nudelay(2);\r\nreturn loops;\r\n}\r\nstatic int sbd_transmit_empty(struct sbd_port *sport)\r\n{\r\nreturn read_sbdchn(sport, R_DUART_STATUS) & M_DUART_TX_EMT;\r\n}\r\nstatic int sbd_line_drain(struct sbd_port *sport)\r\n{\r\nint loops = 10000;\r\nwhile (!sbd_transmit_empty(sport) && --loops)\r\nudelay(2);\r\nreturn loops;\r\n}\r\nstatic unsigned int sbd_tx_empty(struct uart_port *uport)\r\n{\r\nstruct sbd_port *sport = to_sport(uport);\r\nreturn sbd_transmit_empty(sport) ? TIOCSER_TEMT : 0;\r\n}\r\nstatic unsigned int sbd_get_mctrl(struct uart_port *uport)\r\n{\r\nstruct sbd_port *sport = to_sport(uport);\r\nunsigned int mctrl, status;\r\nstatus = read_sbdshr(sport, R_DUART_IN_PORT);\r\nstatus >>= (uport->line) % 2;\r\nmctrl = (!(status & M_DUART_IN_PIN0_VAL) ? TIOCM_CTS : 0) |\r\n(!(status & M_DUART_IN_PIN4_VAL) ? TIOCM_CAR : 0) |\r\n(!(status & M_DUART_RIN0_PIN) ? TIOCM_RNG : 0) |\r\n(!(status & M_DUART_IN_PIN2_VAL) ? TIOCM_DSR : 0);\r\nreturn mctrl;\r\n}\r\nstatic void sbd_set_mctrl(struct uart_port *uport, unsigned int mctrl)\r\n{\r\nstruct sbd_port *sport = to_sport(uport);\r\nunsigned int clr = 0, set = 0, mode2;\r\nif (mctrl & TIOCM_DTR)\r\nset |= M_DUART_SET_OPR2;\r\nelse\r\nclr |= M_DUART_CLR_OPR2;\r\nif (mctrl & TIOCM_RTS)\r\nset |= M_DUART_SET_OPR0;\r\nelse\r\nclr |= M_DUART_CLR_OPR0;\r\nclr <<= (uport->line) % 2;\r\nset <<= (uport->line) % 2;\r\nmode2 = read_sbdchn(sport, R_DUART_MODE_REG_2);\r\nmode2 &= ~M_DUART_CHAN_MODE;\r\nif (mctrl & TIOCM_LOOP)\r\nmode2 |= V_DUART_CHAN_MODE_LCL_LOOP;\r\nelse\r\nmode2 |= V_DUART_CHAN_MODE_NORMAL;\r\nwrite_sbdshr(sport, R_DUART_CLEAR_OPR, clr);\r\nwrite_sbdshr(sport, R_DUART_SET_OPR, set);\r\nwrite_sbdchn(sport, R_DUART_MODE_REG_2, mode2);\r\n}\r\nstatic void sbd_stop_tx(struct uart_port *uport)\r\n{\r\nstruct sbd_port *sport = to_sport(uport);\r\nwrite_sbdchn(sport, R_DUART_CMD, M_DUART_TX_DIS);\r\nsport->tx_stopped = 1;\r\n}\r\nstatic void sbd_start_tx(struct uart_port *uport)\r\n{\r\nstruct sbd_port *sport = to_sport(uport);\r\nunsigned int mask;\r\nmask = read_sbdshr(sport, R_DUART_IMRREG((uport->line) % 2));\r\nmask |= M_DUART_IMR_TX;\r\nwrite_sbdshr(sport, R_DUART_IMRREG((uport->line) % 2), mask);\r\nwrite_sbdchn(sport, R_DUART_CMD, M_DUART_TX_EN);\r\nsport->tx_stopped = 0;\r\n}\r\nstatic void sbd_stop_rx(struct uart_port *uport)\r\n{\r\nstruct sbd_port *sport = to_sport(uport);\r\nwrite_sbdshr(sport, R_DUART_IMRREG((uport->line) % 2), 0);\r\n}\r\nstatic void sbd_enable_ms(struct uart_port *uport)\r\n{\r\nstruct sbd_port *sport = to_sport(uport);\r\nwrite_sbdchn(sport, R_DUART_AUXCTL_X,\r\nM_DUART_CIN_CHNG_ENA | M_DUART_CTS_CHNG_ENA);\r\n}\r\nstatic void sbd_break_ctl(struct uart_port *uport, int break_state)\r\n{\r\nstruct sbd_port *sport = to_sport(uport);\r\nif (break_state == -1)\r\nwrite_sbdchn(sport, R_DUART_CMD, V_DUART_MISC_CMD_START_BREAK);\r\nelse\r\nwrite_sbdchn(sport, R_DUART_CMD, V_DUART_MISC_CMD_STOP_BREAK);\r\n}\r\nstatic void sbd_receive_chars(struct sbd_port *sport)\r\n{\r\nstruct uart_port *uport = &sport->port;\r\nstruct uart_icount *icount;\r\nunsigned int status, ch, flag;\r\nint count;\r\nfor (count = 16; count; count--) {\r\nstatus = read_sbdchn(sport, R_DUART_STATUS);\r\nif (!(status & M_DUART_RX_RDY))\r\nbreak;\r\nch = read_sbdchn(sport, R_DUART_RX_HOLD);\r\nflag = TTY_NORMAL;\r\nicount = &uport->icount;\r\nicount->rx++;\r\nif (unlikely(status &\r\n(M_DUART_RCVD_BRK | M_DUART_FRM_ERR |\r\nM_DUART_PARITY_ERR | M_DUART_OVRUN_ERR))) {\r\nif (status & M_DUART_RCVD_BRK) {\r\nicount->brk++;\r\nif (uart_handle_break(uport))\r\ncontinue;\r\n} else if (status & M_DUART_FRM_ERR)\r\nicount->frame++;\r\nelse if (status & M_DUART_PARITY_ERR)\r\nicount->parity++;\r\nif (status & M_DUART_OVRUN_ERR)\r\nicount->overrun++;\r\nstatus &= uport->read_status_mask;\r\nif (status & M_DUART_RCVD_BRK)\r\nflag = TTY_BREAK;\r\nelse if (status & M_DUART_FRM_ERR)\r\nflag = TTY_FRAME;\r\nelse if (status & M_DUART_PARITY_ERR)\r\nflag = TTY_PARITY;\r\n}\r\nif (uart_handle_sysrq_char(uport, ch))\r\ncontinue;\r\nuart_insert_char(uport, status, M_DUART_OVRUN_ERR, ch, flag);\r\n}\r\ntty_flip_buffer_push(&uport->state->port);\r\n}\r\nstatic void sbd_transmit_chars(struct sbd_port *sport)\r\n{\r\nstruct uart_port *uport = &sport->port;\r\nstruct circ_buf *xmit = &sport->port.state->xmit;\r\nunsigned int mask;\r\nint stop_tx;\r\nif (sport->port.x_char) {\r\nwrite_sbdchn(sport, R_DUART_TX_HOLD, sport->port.x_char);\r\nsport->port.icount.tx++;\r\nsport->port.x_char = 0;\r\nreturn;\r\n}\r\nstop_tx = (uart_circ_empty(xmit) || uart_tx_stopped(&sport->port));\r\nif (!stop_tx) {\r\nwrite_sbdchn(sport, R_DUART_TX_HOLD, xmit->buf[xmit->tail]);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nsport->port.icount.tx++;\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&sport->port);\r\n}\r\nif (stop_tx || uart_circ_empty(xmit)) {\r\nmask = read_sbdshr(sport, R_DUART_IMRREG((uport->line) % 2));\r\nmask &= ~M_DUART_IMR_TX;\r\nwrite_sbdshr(sport, R_DUART_IMRREG((uport->line) % 2), mask);\r\n}\r\n}\r\nstatic void sbd_status_handle(struct sbd_port *sport)\r\n{\r\nstruct uart_port *uport = &sport->port;\r\nunsigned int delta;\r\ndelta = read_sbdshr(sport, R_DUART_INCHREG((uport->line) % 2));\r\ndelta >>= (uport->line) % 2;\r\nif (delta & (M_DUART_IN_PIN0_VAL << S_DUART_IN_PIN_CHNG))\r\nuart_handle_cts_change(uport, !(delta & M_DUART_IN_PIN0_VAL));\r\nif (delta & (M_DUART_IN_PIN2_VAL << S_DUART_IN_PIN_CHNG))\r\nuport->icount.dsr++;\r\nif (delta & ((M_DUART_IN_PIN2_VAL | M_DUART_IN_PIN0_VAL) <<\r\nS_DUART_IN_PIN_CHNG))\r\nwake_up_interruptible(&uport->state->port.delta_msr_wait);\r\n}\r\nstatic irqreturn_t sbd_interrupt(int irq, void *dev_id)\r\n{\r\nstruct sbd_port *sport = dev_id;\r\nstruct uart_port *uport = &sport->port;\r\nirqreturn_t status = IRQ_NONE;\r\nunsigned int intstat;\r\nint count;\r\nfor (count = 16; count; count--) {\r\nintstat = read_sbdshr(sport,\r\nR_DUART_ISRREG((uport->line) % 2));\r\nintstat &= read_sbdshr(sport,\r\nR_DUART_IMRREG((uport->line) % 2));\r\nintstat &= M_DUART_ISR_ALL;\r\nif (!intstat)\r\nbreak;\r\nif (intstat & M_DUART_ISR_RX)\r\nsbd_receive_chars(sport);\r\nif (intstat & M_DUART_ISR_IN)\r\nsbd_status_handle(sport);\r\nif (intstat & M_DUART_ISR_TX)\r\nsbd_transmit_chars(sport);\r\nstatus = IRQ_HANDLED;\r\n}\r\nreturn status;\r\n}\r\nstatic int sbd_startup(struct uart_port *uport)\r\n{\r\nstruct sbd_port *sport = to_sport(uport);\r\nunsigned int mode1;\r\nint ret;\r\nret = request_irq(sport->port.irq, sbd_interrupt,\r\nIRQF_SHARED, "sb1250-duart", sport);\r\nif (ret)\r\nreturn ret;\r\nsbd_receive_drain(sport);\r\nwrite_sbdchn(sport, R_DUART_CMD, V_DUART_MISC_CMD_RESET_BREAK_INT);\r\nread_sbdshr(sport, R_DUART_INCHREG((uport->line) % 2));\r\nmode1 = read_sbdchn(sport, R_DUART_MODE_REG_1);\r\nmode1 &= ~(M_DUART_RX_IRQ_SEL_RXFULL | M_DUART_TX_IRQ_SEL_TXEMPT);\r\nwrite_sbdchn(sport, R_DUART_MODE_REG_1, mode1);\r\nwrite_sbdchn(sport, R_DUART_CMD, M_DUART_TX_DIS | M_DUART_RX_EN);\r\nsport->tx_stopped = 1;\r\nwrite_sbdshr(sport, R_DUART_IMRREG((uport->line) % 2),\r\nM_DUART_IMR_IN | M_DUART_IMR_RX);\r\nreturn 0;\r\n}\r\nstatic void sbd_shutdown(struct uart_port *uport)\r\n{\r\nstruct sbd_port *sport = to_sport(uport);\r\nwrite_sbdchn(sport, R_DUART_CMD, M_DUART_TX_DIS | M_DUART_RX_DIS);\r\nsport->tx_stopped = 1;\r\nfree_irq(sport->port.irq, sport);\r\n}\r\nstatic void sbd_init_port(struct sbd_port *sport)\r\n{\r\nstruct uart_port *uport = &sport->port;\r\nif (sport->initialised)\r\nreturn;\r\nwrite_sbdchn(sport, R_DUART_CMD, V_DUART_MISC_CMD_RESET_TX);\r\nwrite_sbdchn(sport, R_DUART_CMD, V_DUART_MISC_CMD_RESET_RX);\r\nwrite_sbdchn(sport, R_DUART_MODE_REG_1, V_DUART_BITS_PER_CHAR_8);\r\nwrite_sbdchn(sport, R_DUART_MODE_REG_2, 0);\r\nwrite_sbdchn(sport, R_DUART_FULL_CTL,\r\nV_DUART_INT_TIME(0) | V_DUART_SIG_FULL(15));\r\nwrite_sbdchn(sport, R_DUART_OPCR_X, 0);\r\nwrite_sbdchn(sport, R_DUART_AUXCTL_X, 0);\r\nwrite_sbdshr(sport, R_DUART_IMRREG((uport->line) % 2), 0);\r\nsport->initialised = 1;\r\n}\r\nstatic void sbd_set_termios(struct uart_port *uport, struct ktermios *termios,\r\nstruct ktermios *old_termios)\r\n{\r\nstruct sbd_port *sport = to_sport(uport);\r\nunsigned int mode1 = 0, mode2 = 0, aux = 0;\r\nunsigned int mode1mask = 0, mode2mask = 0, auxmask = 0;\r\nunsigned int oldmode1, oldmode2, oldaux;\r\nunsigned int baud, brg;\r\nunsigned int command;\r\nmode1mask |= ~(M_DUART_PARITY_MODE | M_DUART_PARITY_TYPE_ODD |\r\nM_DUART_BITS_PER_CHAR);\r\nmode2mask |= ~M_DUART_STOP_BIT_LEN_2;\r\nauxmask |= ~M_DUART_CTS_CHNG_ENA;\r\nswitch (termios->c_cflag & CSIZE) {\r\ncase CS5:\r\ncase CS6:\r\nmode1mask |= M_DUART_PARITY_MODE;\r\nbreak;\r\ncase CS7:\r\nmode1 |= V_DUART_BITS_PER_CHAR_7;\r\nbreak;\r\ncase CS8:\r\ndefault:\r\nmode1 |= V_DUART_BITS_PER_CHAR_8;\r\nbreak;\r\n}\r\nif (termios->c_cflag & CSTOPB)\r\nmode2 |= M_DUART_STOP_BIT_LEN_2;\r\nelse\r\nmode2 |= M_DUART_STOP_BIT_LEN_1;\r\nif (termios->c_cflag & PARENB)\r\nmode1 |= V_DUART_PARITY_MODE_ADD;\r\nelse\r\nmode1 |= V_DUART_PARITY_MODE_NONE;\r\nif (termios->c_cflag & PARODD)\r\nmode1 |= M_DUART_PARITY_TYPE_ODD;\r\nelse\r\nmode1 |= M_DUART_PARITY_TYPE_EVEN;\r\nbaud = uart_get_baud_rate(uport, termios, old_termios, 1200, 5000000);\r\nbrg = V_DUART_BAUD_RATE(baud);\r\nif (brg > M_DUART_CLK_COUNTER)\r\nbrg = M_DUART_CLK_COUNTER;\r\nuart_update_timeout(uport, termios->c_cflag, baud);\r\nuport->read_status_mask = M_DUART_OVRUN_ERR;\r\nif (termios->c_iflag & INPCK)\r\nuport->read_status_mask |= M_DUART_FRM_ERR |\r\nM_DUART_PARITY_ERR;\r\nif (termios->c_iflag & (IGNBRK | BRKINT | PARMRK))\r\nuport->read_status_mask |= M_DUART_RCVD_BRK;\r\nuport->ignore_status_mask = 0;\r\nif (termios->c_iflag & IGNPAR)\r\nuport->ignore_status_mask |= M_DUART_FRM_ERR |\r\nM_DUART_PARITY_ERR;\r\nif (termios->c_iflag & IGNBRK) {\r\nuport->ignore_status_mask |= M_DUART_RCVD_BRK;\r\nif (termios->c_iflag & IGNPAR)\r\nuport->ignore_status_mask |= M_DUART_OVRUN_ERR;\r\n}\r\nif (termios->c_cflag & CREAD)\r\ncommand = M_DUART_RX_EN;\r\nelse\r\ncommand = M_DUART_RX_DIS;\r\nif (termios->c_cflag & CRTSCTS)\r\naux |= M_DUART_CTS_CHNG_ENA;\r\nelse\r\naux &= ~M_DUART_CTS_CHNG_ENA;\r\nspin_lock(&uport->lock);\r\nif (sport->tx_stopped)\r\ncommand |= M_DUART_TX_DIS;\r\nelse\r\ncommand |= M_DUART_TX_EN;\r\noldmode1 = read_sbdchn(sport, R_DUART_MODE_REG_1) & mode1mask;\r\noldmode2 = read_sbdchn(sport, R_DUART_MODE_REG_2) & mode2mask;\r\noldaux = read_sbdchn(sport, R_DUART_AUXCTL_X) & auxmask;\r\nif (!sport->tx_stopped)\r\nsbd_line_drain(sport);\r\nwrite_sbdchn(sport, R_DUART_CMD, M_DUART_TX_DIS | M_DUART_RX_DIS);\r\nwrite_sbdchn(sport, R_DUART_MODE_REG_1, mode1 | oldmode1);\r\nwrite_sbdchn(sport, R_DUART_MODE_REG_2, mode2 | oldmode2);\r\nwrite_sbdchn(sport, R_DUART_CLK_SEL, brg);\r\nwrite_sbdchn(sport, R_DUART_AUXCTL_X, aux | oldaux);\r\nwrite_sbdchn(sport, R_DUART_CMD, command);\r\nspin_unlock(&uport->lock);\r\n}\r\nstatic const char *sbd_type(struct uart_port *uport)\r\n{\r\nreturn "SB1250 DUART";\r\n}\r\nstatic void sbd_release_port(struct uart_port *uport)\r\n{\r\nstruct sbd_port *sport = to_sport(uport);\r\nstruct sbd_duart *duart = sport->duart;\r\niounmap(sport->memctrl);\r\nsport->memctrl = NULL;\r\niounmap(uport->membase);\r\nuport->membase = NULL;\r\nif(refcount_dec_and_test(&duart->map_guard))\r\nrelease_mem_region(duart->mapctrl, DUART_CHANREG_SPACING);\r\nrelease_mem_region(uport->mapbase, DUART_CHANREG_SPACING);\r\n}\r\nstatic int sbd_map_port(struct uart_port *uport)\r\n{\r\nconst char *err = KERN_ERR "sbd: Cannot map MMIO\n";\r\nstruct sbd_port *sport = to_sport(uport);\r\nstruct sbd_duart *duart = sport->duart;\r\nif (!uport->membase)\r\nuport->membase = ioremap_nocache(uport->mapbase,\r\nDUART_CHANREG_SPACING);\r\nif (!uport->membase) {\r\nprintk(err);\r\nreturn -ENOMEM;\r\n}\r\nif (!sport->memctrl)\r\nsport->memctrl = ioremap_nocache(duart->mapctrl,\r\nDUART_CHANREG_SPACING);\r\nif (!sport->memctrl) {\r\nprintk(err);\r\niounmap(uport->membase);\r\nuport->membase = NULL;\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sbd_request_port(struct uart_port *uport)\r\n{\r\nconst char *err = KERN_ERR "sbd: Unable to reserve MMIO resource\n";\r\nstruct sbd_duart *duart = to_sport(uport)->duart;\r\nint ret = 0;\r\nif (!request_mem_region(uport->mapbase, DUART_CHANREG_SPACING,\r\n"sb1250-duart")) {\r\nprintk(err);\r\nreturn -EBUSY;\r\n}\r\nrefcount_inc(&duart->map_guard);\r\nif (refcount_read(&duart->map_guard) == 1) {\r\nif (!request_mem_region(duart->mapctrl, DUART_CHANREG_SPACING,\r\n"sb1250-duart")) {\r\nrefcount_dec(&duart->map_guard);\r\nprintk(err);\r\nret = -EBUSY;\r\n}\r\n}\r\nif (!ret) {\r\nret = sbd_map_port(uport);\r\nif (ret) {\r\nif (refcount_dec_and_test(&duart->map_guard))\r\nrelease_mem_region(duart->mapctrl,\r\nDUART_CHANREG_SPACING);\r\n}\r\n}\r\nif (ret) {\r\nrelease_mem_region(uport->mapbase, DUART_CHANREG_SPACING);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void sbd_config_port(struct uart_port *uport, int flags)\r\n{\r\nstruct sbd_port *sport = to_sport(uport);\r\nif (flags & UART_CONFIG_TYPE) {\r\nif (sbd_request_port(uport))\r\nreturn;\r\nuport->type = PORT_SB1250_DUART;\r\nsbd_init_port(sport);\r\n}\r\n}\r\nstatic int sbd_verify_port(struct uart_port *uport, struct serial_struct *ser)\r\n{\r\nint ret = 0;\r\nif (ser->type != PORT_UNKNOWN && ser->type != PORT_SB1250_DUART)\r\nret = -EINVAL;\r\nif (ser->irq != uport->irq)\r\nret = -EINVAL;\r\nif (ser->baud_base != uport->uartclk / 16)\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nstatic void __init sbd_probe_duarts(void)\r\n{\r\nstatic int probed;\r\nint chip, side;\r\nint max_lines, line;\r\nif (probed)\r\nreturn;\r\nswitch (soc_type) {\r\ncase K_SYS_SOC_TYPE_BCM1x55:\r\ncase K_SYS_SOC_TYPE_BCM1x80:\r\nmax_lines = 4;\r\nbreak;\r\ndefault:\r\nmax_lines = 2;\r\nbreak;\r\n}\r\nprobed = 1;\r\nfor (chip = 0, line = 0; chip < DUART_MAX_CHIP && line < max_lines;\r\nchip++) {\r\nsbd_duarts[chip].mapctrl = SBD_CTRLREGS(line);\r\nfor (side = 0; side < DUART_MAX_SIDE && line < max_lines;\r\nside++, line++) {\r\nstruct sbd_port *sport = &sbd_duarts[chip].sport[side];\r\nstruct uart_port *uport = &sport->port;\r\nsport->duart = &sbd_duarts[chip];\r\nuport->irq = SBD_INT(line);\r\nuport->uartclk = 100000000 / 20 * 16;\r\nuport->fifosize = 16;\r\nuport->iotype = UPIO_MEM;\r\nuport->flags = UPF_BOOT_AUTOCONF;\r\nuport->ops = &sbd_ops;\r\nuport->line = line;\r\nuport->mapbase = SBD_CHANREGS(line);\r\n}\r\n}\r\n}\r\nstatic void sbd_console_putchar(struct uart_port *uport, int ch)\r\n{\r\nstruct sbd_port *sport = to_sport(uport);\r\nsbd_transmit_drain(sport);\r\nwrite_sbdchn(sport, R_DUART_TX_HOLD, ch);\r\n}\r\nstatic void sbd_console_write(struct console *co, const char *s,\r\nunsigned int count)\r\n{\r\nint chip = co->index / DUART_MAX_SIDE;\r\nint side = co->index % DUART_MAX_SIDE;\r\nstruct sbd_port *sport = &sbd_duarts[chip].sport[side];\r\nstruct uart_port *uport = &sport->port;\r\nunsigned long flags;\r\nunsigned int mask;\r\nspin_lock_irqsave(&uport->lock, flags);\r\nmask = read_sbdshr(sport, R_DUART_IMRREG((uport->line) % 2));\r\nwrite_sbdshr(sport, R_DUART_IMRREG((uport->line) % 2),\r\nmask & ~M_DUART_IMR_TX);\r\nwrite_sbdchn(sport, R_DUART_CMD, M_DUART_TX_EN);\r\nspin_unlock_irqrestore(&uport->lock, flags);\r\nuart_console_write(&sport->port, s, count, sbd_console_putchar);\r\nspin_lock_irqsave(&uport->lock, flags);\r\nsbd_line_drain(sport);\r\nif (sport->tx_stopped)\r\nwrite_sbdchn(sport, R_DUART_CMD, M_DUART_TX_DIS);\r\nwrite_sbdshr(sport, R_DUART_IMRREG((uport->line) % 2), mask);\r\nspin_unlock_irqrestore(&uport->lock, flags);\r\n}\r\nstatic int __init sbd_console_setup(struct console *co, char *options)\r\n{\r\nint chip = co->index / DUART_MAX_SIDE;\r\nint side = co->index % DUART_MAX_SIDE;\r\nstruct sbd_port *sport = &sbd_duarts[chip].sport[side];\r\nstruct uart_port *uport = &sport->port;\r\nint baud = 115200;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nint ret;\r\nif (!sport->duart)\r\nreturn -ENXIO;\r\nret = sbd_map_port(uport);\r\nif (ret)\r\nreturn ret;\r\nsbd_init_port(sport);\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nreturn uart_set_options(uport, co, baud, parity, bits, flow);\r\n}\r\nstatic int __init sbd_serial_console_init(void)\r\n{\r\nsbd_probe_duarts();\r\nregister_console(&sbd_console);\r\nreturn 0;\r\n}\r\nstatic int __init sbd_init(void)\r\n{\r\nint i, ret;\r\nsbd_probe_duarts();\r\nret = uart_register_driver(&sbd_reg);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < DUART_MAX_CHIP * DUART_MAX_SIDE; i++) {\r\nstruct sbd_duart *duart = &sbd_duarts[i / DUART_MAX_SIDE];\r\nstruct sbd_port *sport = &duart->sport[i % DUART_MAX_SIDE];\r\nstruct uart_port *uport = &sport->port;\r\nif (sport->duart)\r\nuart_add_one_port(&sbd_reg, uport);\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit sbd_exit(void)\r\n{\r\nint i;\r\nfor (i = DUART_MAX_CHIP * DUART_MAX_SIDE - 1; i >= 0; i--) {\r\nstruct sbd_duart *duart = &sbd_duarts[i / DUART_MAX_SIDE];\r\nstruct sbd_port *sport = &duart->sport[i % DUART_MAX_SIDE];\r\nstruct uart_port *uport = &sport->port;\r\nif (sport->duart)\r\nuart_remove_one_port(&sbd_reg, uport);\r\n}\r\nuart_unregister_driver(&sbd_reg);\r\n}
