static inline char __iomem *pci_dev_base(unsigned int seg, unsigned int bus, unsigned int devfn)\r\n{\r\nstruct pci_mmcfg_region *cfg = pci_mmconfig_lookup(seg, bus);\r\nif (cfg && cfg->virt)\r\nreturn cfg->virt + (PCI_MMCFG_BUS_OFFSET(bus) | (devfn << 12));\r\nreturn NULL;\r\n}\r\nstatic int pci_mmcfg_read_numachip(unsigned int seg, unsigned int bus,\r\nunsigned int devfn, int reg, int len, u32 *value)\r\n{\r\nchar __iomem *addr;\r\nif (unlikely((bus > 255) || (devfn > 255) || (reg > 4095))) {\r\nerr: *value = -1;\r\nreturn -EINVAL;\r\n}\r\nif (unlikely(bus == 0 && devfn >= limit)) {\r\n*value = -1;\r\nreturn 0;\r\n}\r\nrcu_read_lock();\r\naddr = pci_dev_base(seg, bus, devfn);\r\nif (!addr) {\r\nrcu_read_unlock();\r\ngoto err;\r\n}\r\nswitch (len) {\r\ncase 1:\r\n*value = mmio_config_readb(addr + reg);\r\nbreak;\r\ncase 2:\r\n*value = mmio_config_readw(addr + reg);\r\nbreak;\r\ncase 4:\r\n*value = mmio_config_readl(addr + reg);\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nstatic int pci_mmcfg_write_numachip(unsigned int seg, unsigned int bus,\r\nunsigned int devfn, int reg, int len, u32 value)\r\n{\r\nchar __iomem *addr;\r\nif (unlikely((bus > 255) || (devfn > 255) || (reg > 4095)))\r\nreturn -EINVAL;\r\nif (unlikely(bus == 0 && devfn >= limit))\r\nreturn 0;\r\nrcu_read_lock();\r\naddr = pci_dev_base(seg, bus, devfn);\r\nif (!addr) {\r\nrcu_read_unlock();\r\nreturn -EINVAL;\r\n}\r\nswitch (len) {\r\ncase 1:\r\nmmio_config_writeb(addr + reg, value);\r\nbreak;\r\ncase 2:\r\nmmio_config_writew(addr + reg, value);\r\nbreak;\r\ncase 4:\r\nmmio_config_writel(addr + reg, value);\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nint __init pci_numachip_init(void)\r\n{\r\nint ret = 0;\r\nu32 val;\r\nret = raw_pci_read(0, 0, PCI_DEVFN(0x18, 0), 0x60, sizeof(val), &val);\r\nif (ret)\r\ngoto out;\r\nlimit = PCI_DEVFN(0x18 + ((val >> 4) & 7) + 1, 0);\r\nraw_pci_ops = raw_pci_ext_ops = &pci_mmcfg_numachip;\r\nout:\r\nreturn ret;\r\n}
