static unsigned char edid_get_byte(struct intel_vgpu *vgpu)\r\n{\r\nstruct intel_vgpu_i2c_edid *edid = &vgpu->display.i2c_edid;\r\nunsigned char chr = 0;\r\nif (edid->state == I2C_NOT_SPECIFIED || !edid->slave_selected) {\r\ngvt_vgpu_err("Driver tries to read EDID without proper sequence!\n");\r\nreturn 0;\r\n}\r\nif (edid->current_edid_read >= EDID_SIZE) {\r\ngvt_vgpu_err("edid_get_byte() exceeds the size of EDID!\n");\r\nreturn 0;\r\n}\r\nif (!edid->edid_available) {\r\ngvt_vgpu_err("Reading EDID but EDID is not available!\n");\r\nreturn 0;\r\n}\r\nif (intel_vgpu_has_monitor_on_port(vgpu, edid->port)) {\r\nstruct intel_vgpu_edid_data *edid_data =\r\nintel_vgpu_port(vgpu, edid->port)->edid;\r\nchr = edid_data->edid_block[edid->current_edid_read];\r\nedid->current_edid_read++;\r\n} else {\r\ngvt_vgpu_err("No EDID available during the reading?\n");\r\n}\r\nreturn chr;\r\n}\r\nstatic inline int get_port_from_gmbus0(u32 gmbus0)\r\n{\r\nint port_select = gmbus0 & _GMBUS_PIN_SEL_MASK;\r\nint port = -EINVAL;\r\nif (port_select == 2)\r\nport = PORT_E;\r\nelse if (port_select == 4)\r\nport = PORT_C;\r\nelse if (port_select == 5)\r\nport = PORT_B;\r\nelse if (port_select == 6)\r\nport = PORT_D;\r\nreturn port;\r\n}\r\nstatic void reset_gmbus_controller(struct intel_vgpu *vgpu)\r\n{\r\nvgpu_vreg(vgpu, PCH_GMBUS2) = GMBUS_HW_RDY;\r\nif (!vgpu->display.i2c_edid.edid_available)\r\nvgpu_vreg(vgpu, PCH_GMBUS2) |= GMBUS_SATOER;\r\nvgpu->display.i2c_edid.gmbus.phase = GMBUS_IDLE_PHASE;\r\n}\r\nstatic int gmbus0_mmio_write(struct intel_vgpu *vgpu,\r\nunsigned int offset, void *p_data, unsigned int bytes)\r\n{\r\nint port, pin_select;\r\nmemcpy(&vgpu_vreg(vgpu, offset), p_data, bytes);\r\npin_select = vgpu_vreg(vgpu, offset) & _GMBUS_PIN_SEL_MASK;\r\nintel_vgpu_init_i2c_edid(vgpu);\r\nif (pin_select == 0)\r\nreturn 0;\r\nport = get_port_from_gmbus0(pin_select);\r\nif (WARN_ON(port < 0))\r\nreturn 0;\r\nvgpu->display.i2c_edid.state = I2C_GMBUS;\r\nvgpu->display.i2c_edid.gmbus.phase = GMBUS_IDLE_PHASE;\r\nvgpu_vreg(vgpu, PCH_GMBUS2) &= ~GMBUS_ACTIVE;\r\nvgpu_vreg(vgpu, PCH_GMBUS2) |= GMBUS_HW_RDY | GMBUS_HW_WAIT_PHASE;\r\nif (intel_vgpu_has_monitor_on_port(vgpu, port) &&\r\n!intel_vgpu_port_is_dp(vgpu, port)) {\r\nvgpu->display.i2c_edid.port = port;\r\nvgpu->display.i2c_edid.edid_available = true;\r\nvgpu_vreg(vgpu, PCH_GMBUS2) &= ~GMBUS_SATOER;\r\n} else\r\nvgpu_vreg(vgpu, PCH_GMBUS2) |= GMBUS_SATOER;\r\nreturn 0;\r\n}\r\nstatic int gmbus1_mmio_write(struct intel_vgpu *vgpu, unsigned int offset,\r\nvoid *p_data, unsigned int bytes)\r\n{\r\nstruct intel_vgpu_i2c_edid *i2c_edid = &vgpu->display.i2c_edid;\r\nu32 slave_addr;\r\nu32 wvalue = *(u32 *)p_data;\r\nif (vgpu_vreg(vgpu, offset) & GMBUS_SW_CLR_INT) {\r\nif (!(wvalue & GMBUS_SW_CLR_INT)) {\r\nvgpu_vreg(vgpu, offset) &= ~GMBUS_SW_CLR_INT;\r\nreset_gmbus_controller(vgpu);\r\n}\r\n} else {\r\nif (wvalue & GMBUS_SW_CLR_INT) {\r\nvgpu_vreg(vgpu, PCH_GMBUS2) &= ~GMBUS_INT;\r\nvgpu_vreg(vgpu, PCH_GMBUS2) |= GMBUS_HW_RDY;\r\n}\r\nif (wvalue & GMBUS_SW_RDY)\r\nwvalue &= ~GMBUS_SW_RDY;\r\ni2c_edid->gmbus.total_byte_count =\r\ngmbus1_total_byte_count(wvalue);\r\nslave_addr = gmbus1_slave_addr(wvalue);\r\nif (slave_addr == EDID_ADDR) {\r\ni2c_edid->slave_selected = true;\r\n} else if (slave_addr != 0) {\r\ngvt_dbg_dpy(\r\n"vgpu%d: unsupported gmbus slave addr(0x%x)\n"\r\n" gmbus operations will be ignored.\n",\r\nvgpu->id, slave_addr);\r\n}\r\nif (wvalue & GMBUS_CYCLE_INDEX)\r\ni2c_edid->current_edid_read =\r\ngmbus1_slave_index(wvalue);\r\ni2c_edid->gmbus.cycle_type = gmbus1_bus_cycle(wvalue);\r\nswitch (gmbus1_bus_cycle(wvalue)) {\r\ncase GMBUS_NOCYCLE:\r\nbreak;\r\ncase GMBUS_STOP:\r\nif (gmbus1_bus_cycle(vgpu_vreg(vgpu, offset))\r\n!= GMBUS_NOCYCLE) {\r\nintel_vgpu_init_i2c_edid(vgpu);\r\ni2c_edid->gmbus.phase = GMBUS_IDLE_PHASE;\r\nvgpu_vreg(vgpu, PCH_GMBUS2) &= ~GMBUS_ACTIVE;\r\n}\r\nbreak;\r\ncase NIDX_NS_W:\r\ncase IDX_NS_W:\r\ncase NIDX_STOP:\r\ncase IDX_STOP:\r\ni2c_edid->gmbus.phase = GMBUS_DATA_PHASE;\r\nvgpu_vreg(vgpu, PCH_GMBUS2) |= GMBUS_ACTIVE;\r\nbreak;\r\ndefault:\r\ngvt_vgpu_err("Unknown/reserved GMBUS cycle detected!\n");\r\nbreak;\r\n}\r\nvgpu_vreg(vgpu, offset) = wvalue;\r\n}\r\nreturn 0;\r\n}\r\nstatic int gmbus3_mmio_write(struct intel_vgpu *vgpu, unsigned int offset,\r\nvoid *p_data, unsigned int bytes)\r\n{\r\nWARN_ON(1);\r\nreturn 0;\r\n}\r\nstatic int gmbus3_mmio_read(struct intel_vgpu *vgpu, unsigned int offset,\r\nvoid *p_data, unsigned int bytes)\r\n{\r\nint i;\r\nunsigned char byte_data;\r\nstruct intel_vgpu_i2c_edid *i2c_edid = &vgpu->display.i2c_edid;\r\nint byte_left = i2c_edid->gmbus.total_byte_count -\r\ni2c_edid->current_edid_read;\r\nint byte_count = byte_left;\r\nu32 reg_data = 0;\r\nif (vgpu_vreg(vgpu, PCH_GMBUS1) & GMBUS_SLAVE_READ) {\r\nif (byte_left <= 0) {\r\nmemcpy(p_data, &vgpu_vreg(vgpu, offset), bytes);\r\nreturn 0;\r\n}\r\nif (byte_count > 4)\r\nbyte_count = 4;\r\nfor (i = 0; i < byte_count; i++) {\r\nbyte_data = edid_get_byte(vgpu);\r\nreg_data |= (byte_data << (i << 3));\r\n}\r\nmemcpy(&vgpu_vreg(vgpu, offset), &reg_data, byte_count);\r\nmemcpy(p_data, &vgpu_vreg(vgpu, offset), bytes);\r\nif (byte_left <= 4) {\r\nswitch (i2c_edid->gmbus.cycle_type) {\r\ncase NIDX_STOP:\r\ncase IDX_STOP:\r\ni2c_edid->gmbus.phase = GMBUS_IDLE_PHASE;\r\nbreak;\r\ncase NIDX_NS_W:\r\ncase IDX_NS_W:\r\ndefault:\r\ni2c_edid->gmbus.phase = GMBUS_WAIT_PHASE;\r\nbreak;\r\n}\r\nintel_vgpu_init_i2c_edid(vgpu);\r\n}\r\n} else {\r\nmemcpy(p_data, &vgpu_vreg(vgpu, offset), bytes);\r\ngvt_vgpu_err("warning: gmbus3 read with nothing returned\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int gmbus2_mmio_read(struct intel_vgpu *vgpu, unsigned int offset,\r\nvoid *p_data, unsigned int bytes)\r\n{\r\nu32 value = vgpu_vreg(vgpu, offset);\r\nif (!(vgpu_vreg(vgpu, offset) & GMBUS_INUSE))\r\nvgpu_vreg(vgpu, offset) |= GMBUS_INUSE;\r\nmemcpy(p_data, (void *)&value, bytes);\r\nreturn 0;\r\n}\r\nstatic int gmbus2_mmio_write(struct intel_vgpu *vgpu, unsigned int offset,\r\nvoid *p_data, unsigned int bytes)\r\n{\r\nu32 wvalue = *(u32 *)p_data;\r\nif (wvalue & GMBUS_INUSE)\r\nvgpu_vreg(vgpu, offset) &= ~GMBUS_INUSE;\r\nreturn 0;\r\n}\r\nint intel_gvt_i2c_handle_gmbus_read(struct intel_vgpu *vgpu,\r\nunsigned int offset, void *p_data, unsigned int bytes)\r\n{\r\nif (WARN_ON(bytes > 8 && (offset & (bytes - 1))))\r\nreturn -EINVAL;\r\nif (offset == i915_mmio_reg_offset(PCH_GMBUS2))\r\nreturn gmbus2_mmio_read(vgpu, offset, p_data, bytes);\r\nelse if (offset == i915_mmio_reg_offset(PCH_GMBUS3))\r\nreturn gmbus3_mmio_read(vgpu, offset, p_data, bytes);\r\nmemcpy(p_data, &vgpu_vreg(vgpu, offset), bytes);\r\nreturn 0;\r\n}\r\nint intel_gvt_i2c_handle_gmbus_write(struct intel_vgpu *vgpu,\r\nunsigned int offset, void *p_data, unsigned int bytes)\r\n{\r\nif (WARN_ON(bytes > 8 && (offset & (bytes - 1))))\r\nreturn -EINVAL;\r\nif (offset == i915_mmio_reg_offset(PCH_GMBUS0))\r\nreturn gmbus0_mmio_write(vgpu, offset, p_data, bytes);\r\nelse if (offset == i915_mmio_reg_offset(PCH_GMBUS1))\r\nreturn gmbus1_mmio_write(vgpu, offset, p_data, bytes);\r\nelse if (offset == i915_mmio_reg_offset(PCH_GMBUS2))\r\nreturn gmbus2_mmio_write(vgpu, offset, p_data, bytes);\r\nelse if (offset == i915_mmio_reg_offset(PCH_GMBUS3))\r\nreturn gmbus3_mmio_write(vgpu, offset, p_data, bytes);\r\nmemcpy(&vgpu_vreg(vgpu, offset), p_data, bytes);\r\nreturn 0;\r\n}\r\nstatic inline int get_aux_ch_reg(unsigned int offset)\r\n{\r\nint reg;\r\nswitch (offset & 0xff) {\r\ncase 0x10:\r\nreg = AUX_CH_CTL;\r\nbreak;\r\ncase 0x14:\r\nreg = AUX_CH_DATA1;\r\nbreak;\r\ncase 0x18:\r\nreg = AUX_CH_DATA2;\r\nbreak;\r\ncase 0x1c:\r\nreg = AUX_CH_DATA3;\r\nbreak;\r\ncase 0x20:\r\nreg = AUX_CH_DATA4;\r\nbreak;\r\ncase 0x24:\r\nreg = AUX_CH_DATA5;\r\nbreak;\r\ndefault:\r\nreg = -1;\r\nbreak;\r\n}\r\nreturn reg;\r\n}\r\nvoid intel_gvt_i2c_handle_aux_ch_write(struct intel_vgpu *vgpu,\r\nint port_idx,\r\nunsigned int offset,\r\nvoid *p_data)\r\n{\r\nstruct intel_vgpu_i2c_edid *i2c_edid = &vgpu->display.i2c_edid;\r\nint msg_length, ret_msg_size;\r\nint msg, addr, ctrl, op;\r\nu32 value = *(u32 *)p_data;\r\nint aux_data_for_write = 0;\r\nint reg = get_aux_ch_reg(offset);\r\nif (reg != AUX_CH_CTL) {\r\nvgpu_vreg(vgpu, offset) = value;\r\nreturn;\r\n}\r\nmsg_length = AUX_CTL_MSG_LENGTH(value);\r\nmsg = vgpu_vreg(vgpu, offset + 4);\r\naddr = (msg >> 8) & 0xffff;\r\nctrl = (msg >> 24) & 0xff;\r\nop = ctrl >> 4;\r\nif (!(value & DP_AUX_CH_CTL_SEND_BUSY)) {\r\nreturn;\r\n}\r\nret_msg_size = (((op & 0x1) == GVT_AUX_I2C_READ) ? 2 : 1);\r\nvgpu_vreg(vgpu, offset) =\r\nDP_AUX_CH_CTL_DONE |\r\n((ret_msg_size << DP_AUX_CH_CTL_MESSAGE_SIZE_SHIFT) &\r\nDP_AUX_CH_CTL_MESSAGE_SIZE_MASK);\r\nif (msg_length == 3) {\r\nif (!(op & GVT_AUX_I2C_MOT)) {\r\nintel_vgpu_init_i2c_edid(vgpu);\r\n} else {\r\ni2c_edid->aux_ch.i2c_over_aux_ch = true;\r\ni2c_edid->aux_ch.aux_ch_mot = true;\r\nif (addr == 0) {\r\nintel_vgpu_init_i2c_edid(vgpu);\r\n} else if (addr == EDID_ADDR) {\r\ni2c_edid->state = I2C_AUX_CH;\r\ni2c_edid->port = port_idx;\r\ni2c_edid->slave_selected = true;\r\nif (intel_vgpu_has_monitor_on_port(vgpu,\r\nport_idx) &&\r\nintel_vgpu_port_is_dp(vgpu, port_idx))\r\ni2c_edid->edid_available = true;\r\n}\r\n}\r\n} else if ((op & 0x1) == GVT_AUX_I2C_WRITE) {\r\n} else {\r\nif (WARN_ON((op & 0x1) != GVT_AUX_I2C_READ))\r\nreturn;\r\nif (WARN_ON(msg_length != 4))\r\nreturn;\r\nif (i2c_edid->edid_available && i2c_edid->slave_selected) {\r\nunsigned char val = edid_get_byte(vgpu);\r\naux_data_for_write = (val << 16);\r\n} else\r\naux_data_for_write = (0xff << 16);\r\n}\r\naux_data_for_write |= GVT_AUX_I2C_REPLY_ACK << 24;\r\nvgpu_vreg(vgpu, offset + 4) = aux_data_for_write;\r\n}\r\nvoid intel_vgpu_init_i2c_edid(struct intel_vgpu *vgpu)\r\n{\r\nstruct intel_vgpu_i2c_edid *edid = &vgpu->display.i2c_edid;\r\nedid->state = I2C_NOT_SPECIFIED;\r\nedid->port = -1;\r\nedid->slave_selected = false;\r\nedid->edid_available = false;\r\nedid->current_edid_read = 0;\r\nmemset(&edid->gmbus, 0, sizeof(struct intel_vgpu_i2c_gmbus));\r\nedid->aux_ch.i2c_over_aux_ch = false;\r\nedid->aux_ch.aux_ch_mot = false;\r\n}
