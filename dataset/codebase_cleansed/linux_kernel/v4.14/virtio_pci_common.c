void vp_synchronize_vectors(struct virtio_device *vdev)\r\n{\r\nstruct virtio_pci_device *vp_dev = to_vp_device(vdev);\r\nint i;\r\nif (vp_dev->intx_enabled)\r\nsynchronize_irq(vp_dev->pci_dev->irq);\r\nfor (i = 0; i < vp_dev->msix_vectors; ++i)\r\nsynchronize_irq(pci_irq_vector(vp_dev->pci_dev, i));\r\n}\r\nbool vp_notify(struct virtqueue *vq)\r\n{\r\niowrite16(vq->index, (void __iomem *)vq->priv);\r\nreturn true;\r\n}\r\nstatic irqreturn_t vp_config_changed(int irq, void *opaque)\r\n{\r\nstruct virtio_pci_device *vp_dev = opaque;\r\nvirtio_config_changed(&vp_dev->vdev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t vp_vring_interrupt(int irq, void *opaque)\r\n{\r\nstruct virtio_pci_device *vp_dev = opaque;\r\nstruct virtio_pci_vq_info *info;\r\nirqreturn_t ret = IRQ_NONE;\r\nunsigned long flags;\r\nspin_lock_irqsave(&vp_dev->lock, flags);\r\nlist_for_each_entry(info, &vp_dev->virtqueues, node) {\r\nif (vring_interrupt(irq, info->vq) == IRQ_HANDLED)\r\nret = IRQ_HANDLED;\r\n}\r\nspin_unlock_irqrestore(&vp_dev->lock, flags);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t vp_interrupt(int irq, void *opaque)\r\n{\r\nstruct virtio_pci_device *vp_dev = opaque;\r\nu8 isr;\r\nisr = ioread8(vp_dev->isr);\r\nif (!isr)\r\nreturn IRQ_NONE;\r\nif (isr & VIRTIO_PCI_ISR_CONFIG)\r\nvp_config_changed(irq, opaque);\r\nreturn vp_vring_interrupt(irq, opaque);\r\n}\r\nstatic int vp_request_msix_vectors(struct virtio_device *vdev, int nvectors,\r\nbool per_vq_vectors, struct irq_affinity *desc)\r\n{\r\nstruct virtio_pci_device *vp_dev = to_vp_device(vdev);\r\nconst char *name = dev_name(&vp_dev->vdev.dev);\r\nunsigned flags = PCI_IRQ_MSIX;\r\nunsigned i, v;\r\nint err = -ENOMEM;\r\nvp_dev->msix_vectors = nvectors;\r\nvp_dev->msix_names = kmalloc(nvectors * sizeof *vp_dev->msix_names,\r\nGFP_KERNEL);\r\nif (!vp_dev->msix_names)\r\ngoto error;\r\nvp_dev->msix_affinity_masks\r\n= kzalloc(nvectors * sizeof *vp_dev->msix_affinity_masks,\r\nGFP_KERNEL);\r\nif (!vp_dev->msix_affinity_masks)\r\ngoto error;\r\nfor (i = 0; i < nvectors; ++i)\r\nif (!alloc_cpumask_var(&vp_dev->msix_affinity_masks[i],\r\nGFP_KERNEL))\r\ngoto error;\r\nif (desc) {\r\nflags |= PCI_IRQ_AFFINITY;\r\ndesc->pre_vectors++;\r\n}\r\nerr = pci_alloc_irq_vectors_affinity(vp_dev->pci_dev, nvectors,\r\nnvectors, flags, desc);\r\nif (err < 0)\r\ngoto error;\r\nvp_dev->msix_enabled = 1;\r\nv = vp_dev->msix_used_vectors;\r\nsnprintf(vp_dev->msix_names[v], sizeof *vp_dev->msix_names,\r\n"%s-config", name);\r\nerr = request_irq(pci_irq_vector(vp_dev->pci_dev, v),\r\nvp_config_changed, 0, vp_dev->msix_names[v],\r\nvp_dev);\r\nif (err)\r\ngoto error;\r\n++vp_dev->msix_used_vectors;\r\nv = vp_dev->config_vector(vp_dev, v);\r\nif (v == VIRTIO_MSI_NO_VECTOR) {\r\nerr = -EBUSY;\r\ngoto error;\r\n}\r\nif (!per_vq_vectors) {\r\nv = vp_dev->msix_used_vectors;\r\nsnprintf(vp_dev->msix_names[v], sizeof *vp_dev->msix_names,\r\n"%s-virtqueues", name);\r\nerr = request_irq(pci_irq_vector(vp_dev->pci_dev, v),\r\nvp_vring_interrupt, 0, vp_dev->msix_names[v],\r\nvp_dev);\r\nif (err)\r\ngoto error;\r\n++vp_dev->msix_used_vectors;\r\n}\r\nreturn 0;\r\nerror:\r\nreturn err;\r\n}\r\nstatic struct virtqueue *vp_setup_vq(struct virtio_device *vdev, unsigned index,\r\nvoid (*callback)(struct virtqueue *vq),\r\nconst char *name,\r\nbool ctx,\r\nu16 msix_vec)\r\n{\r\nstruct virtio_pci_device *vp_dev = to_vp_device(vdev);\r\nstruct virtio_pci_vq_info *info = kmalloc(sizeof *info, GFP_KERNEL);\r\nstruct virtqueue *vq;\r\nunsigned long flags;\r\nif (!info)\r\nreturn ERR_PTR(-ENOMEM);\r\nvq = vp_dev->setup_vq(vp_dev, info, index, callback, name, ctx,\r\nmsix_vec);\r\nif (IS_ERR(vq))\r\ngoto out_info;\r\ninfo->vq = vq;\r\nif (callback) {\r\nspin_lock_irqsave(&vp_dev->lock, flags);\r\nlist_add(&info->node, &vp_dev->virtqueues);\r\nspin_unlock_irqrestore(&vp_dev->lock, flags);\r\n} else {\r\nINIT_LIST_HEAD(&info->node);\r\n}\r\nvp_dev->vqs[index] = info;\r\nreturn vq;\r\nout_info:\r\nkfree(info);\r\nreturn vq;\r\n}\r\nstatic void vp_del_vq(struct virtqueue *vq)\r\n{\r\nstruct virtio_pci_device *vp_dev = to_vp_device(vq->vdev);\r\nstruct virtio_pci_vq_info *info = vp_dev->vqs[vq->index];\r\nunsigned long flags;\r\nspin_lock_irqsave(&vp_dev->lock, flags);\r\nlist_del(&info->node);\r\nspin_unlock_irqrestore(&vp_dev->lock, flags);\r\nvp_dev->del_vq(info);\r\nkfree(info);\r\n}\r\nvoid vp_del_vqs(struct virtio_device *vdev)\r\n{\r\nstruct virtio_pci_device *vp_dev = to_vp_device(vdev);\r\nstruct virtqueue *vq, *n;\r\nint i;\r\nlist_for_each_entry_safe(vq, n, &vdev->vqs, list) {\r\nif (vp_dev->per_vq_vectors) {\r\nint v = vp_dev->vqs[vq->index]->msix_vector;\r\nif (v != VIRTIO_MSI_NO_VECTOR) {\r\nint irq = pci_irq_vector(vp_dev->pci_dev, v);\r\nirq_set_affinity_hint(irq, NULL);\r\nfree_irq(irq, vq);\r\n}\r\n}\r\nvp_del_vq(vq);\r\n}\r\nvp_dev->per_vq_vectors = false;\r\nif (vp_dev->intx_enabled) {\r\nfree_irq(vp_dev->pci_dev->irq, vp_dev);\r\nvp_dev->intx_enabled = 0;\r\n}\r\nfor (i = 0; i < vp_dev->msix_used_vectors; ++i)\r\nfree_irq(pci_irq_vector(vp_dev->pci_dev, i), vp_dev);\r\nfor (i = 0; i < vp_dev->msix_vectors; i++)\r\nif (vp_dev->msix_affinity_masks[i])\r\nfree_cpumask_var(vp_dev->msix_affinity_masks[i]);\r\nif (vp_dev->msix_enabled) {\r\nvp_dev->config_vector(vp_dev, VIRTIO_MSI_NO_VECTOR);\r\npci_free_irq_vectors(vp_dev->pci_dev);\r\nvp_dev->msix_enabled = 0;\r\n}\r\nvp_dev->msix_vectors = 0;\r\nvp_dev->msix_used_vectors = 0;\r\nkfree(vp_dev->msix_names);\r\nvp_dev->msix_names = NULL;\r\nkfree(vp_dev->msix_affinity_masks);\r\nvp_dev->msix_affinity_masks = NULL;\r\nkfree(vp_dev->vqs);\r\nvp_dev->vqs = NULL;\r\n}\r\nstatic int vp_find_vqs_msix(struct virtio_device *vdev, unsigned nvqs,\r\nstruct virtqueue *vqs[], vq_callback_t *callbacks[],\r\nconst char * const names[], bool per_vq_vectors,\r\nconst bool *ctx,\r\nstruct irq_affinity *desc)\r\n{\r\nstruct virtio_pci_device *vp_dev = to_vp_device(vdev);\r\nu16 msix_vec;\r\nint i, err, nvectors, allocated_vectors;\r\nvp_dev->vqs = kcalloc(nvqs, sizeof(*vp_dev->vqs), GFP_KERNEL);\r\nif (!vp_dev->vqs)\r\nreturn -ENOMEM;\r\nif (per_vq_vectors) {\r\nnvectors = 1;\r\nfor (i = 0; i < nvqs; ++i)\r\nif (callbacks[i])\r\n++nvectors;\r\n} else {\r\nnvectors = 2;\r\n}\r\nerr = vp_request_msix_vectors(vdev, nvectors, per_vq_vectors,\r\nper_vq_vectors ? desc : NULL);\r\nif (err)\r\ngoto error_find;\r\nvp_dev->per_vq_vectors = per_vq_vectors;\r\nallocated_vectors = vp_dev->msix_used_vectors;\r\nfor (i = 0; i < nvqs; ++i) {\r\nif (!names[i]) {\r\nvqs[i] = NULL;\r\ncontinue;\r\n}\r\nif (!callbacks[i])\r\nmsix_vec = VIRTIO_MSI_NO_VECTOR;\r\nelse if (vp_dev->per_vq_vectors)\r\nmsix_vec = allocated_vectors++;\r\nelse\r\nmsix_vec = VP_MSIX_VQ_VECTOR;\r\nvqs[i] = vp_setup_vq(vdev, i, callbacks[i], names[i],\r\nctx ? ctx[i] : false,\r\nmsix_vec);\r\nif (IS_ERR(vqs[i])) {\r\nerr = PTR_ERR(vqs[i]);\r\ngoto error_find;\r\n}\r\nif (!vp_dev->per_vq_vectors || msix_vec == VIRTIO_MSI_NO_VECTOR)\r\ncontinue;\r\nsnprintf(vp_dev->msix_names[msix_vec],\r\nsizeof *vp_dev->msix_names,\r\n"%s-%s",\r\ndev_name(&vp_dev->vdev.dev), names[i]);\r\nerr = request_irq(pci_irq_vector(vp_dev->pci_dev, msix_vec),\r\nvring_interrupt, 0,\r\nvp_dev->msix_names[msix_vec],\r\nvqs[i]);\r\nif (err)\r\ngoto error_find;\r\n}\r\nreturn 0;\r\nerror_find:\r\nvp_del_vqs(vdev);\r\nreturn err;\r\n}\r\nstatic int vp_find_vqs_intx(struct virtio_device *vdev, unsigned nvqs,\r\nstruct virtqueue *vqs[], vq_callback_t *callbacks[],\r\nconst char * const names[], const bool *ctx)\r\n{\r\nstruct virtio_pci_device *vp_dev = to_vp_device(vdev);\r\nint i, err;\r\nvp_dev->vqs = kcalloc(nvqs, sizeof(*vp_dev->vqs), GFP_KERNEL);\r\nif (!vp_dev->vqs)\r\nreturn -ENOMEM;\r\nerr = request_irq(vp_dev->pci_dev->irq, vp_interrupt, IRQF_SHARED,\r\ndev_name(&vdev->dev), vp_dev);\r\nif (err)\r\ngoto out_del_vqs;\r\nvp_dev->intx_enabled = 1;\r\nvp_dev->per_vq_vectors = false;\r\nfor (i = 0; i < nvqs; ++i) {\r\nif (!names[i]) {\r\nvqs[i] = NULL;\r\ncontinue;\r\n}\r\nvqs[i] = vp_setup_vq(vdev, i, callbacks[i], names[i],\r\nctx ? ctx[i] : false,\r\nVIRTIO_MSI_NO_VECTOR);\r\nif (IS_ERR(vqs[i])) {\r\nerr = PTR_ERR(vqs[i]);\r\ngoto out_del_vqs;\r\n}\r\n}\r\nreturn 0;\r\nout_del_vqs:\r\nvp_del_vqs(vdev);\r\nreturn err;\r\n}\r\nint vp_find_vqs(struct virtio_device *vdev, unsigned nvqs,\r\nstruct virtqueue *vqs[], vq_callback_t *callbacks[],\r\nconst char * const names[], const bool *ctx,\r\nstruct irq_affinity *desc)\r\n{\r\nint err;\r\nerr = vp_find_vqs_msix(vdev, nvqs, vqs, callbacks, names, true, ctx, desc);\r\nif (!err)\r\nreturn 0;\r\nerr = vp_find_vqs_msix(vdev, nvqs, vqs, callbacks, names, false, ctx, desc);\r\nif (!err)\r\nreturn 0;\r\nreturn vp_find_vqs_intx(vdev, nvqs, vqs, callbacks, names, ctx);\r\n}\r\nconst char *vp_bus_name(struct virtio_device *vdev)\r\n{\r\nstruct virtio_pci_device *vp_dev = to_vp_device(vdev);\r\nreturn pci_name(vp_dev->pci_dev);\r\n}\r\nint vp_set_vq_affinity(struct virtqueue *vq, int cpu)\r\n{\r\nstruct virtio_device *vdev = vq->vdev;\r\nstruct virtio_pci_device *vp_dev = to_vp_device(vdev);\r\nstruct virtio_pci_vq_info *info = vp_dev->vqs[vq->index];\r\nstruct cpumask *mask;\r\nunsigned int irq;\r\nif (!vq->callback)\r\nreturn -EINVAL;\r\nif (vp_dev->msix_enabled) {\r\nmask = vp_dev->msix_affinity_masks[info->msix_vector];\r\nirq = pci_irq_vector(vp_dev->pci_dev, info->msix_vector);\r\nif (cpu == -1)\r\nirq_set_affinity_hint(irq, NULL);\r\nelse {\r\ncpumask_clear(mask);\r\ncpumask_set_cpu(cpu, mask);\r\nirq_set_affinity_hint(irq, mask);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nconst struct cpumask *vp_get_vq_affinity(struct virtio_device *vdev, int index)\r\n{\r\nstruct virtio_pci_device *vp_dev = to_vp_device(vdev);\r\nif (!vp_dev->per_vq_vectors ||\r\nvp_dev->vqs[index]->msix_vector == VIRTIO_MSI_NO_VECTOR)\r\nreturn NULL;\r\nreturn pci_irq_get_affinity(vp_dev->pci_dev,\r\nvp_dev->vqs[index]->msix_vector);\r\n}\r\nstatic int virtio_pci_freeze(struct device *dev)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nstruct virtio_pci_device *vp_dev = pci_get_drvdata(pci_dev);\r\nint ret;\r\nret = virtio_device_freeze(&vp_dev->vdev);\r\nif (!ret)\r\npci_disable_device(pci_dev);\r\nreturn ret;\r\n}\r\nstatic int virtio_pci_restore(struct device *dev)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nstruct virtio_pci_device *vp_dev = pci_get_drvdata(pci_dev);\r\nint ret;\r\nret = pci_enable_device(pci_dev);\r\nif (ret)\r\nreturn ret;\r\npci_set_master(pci_dev);\r\nreturn virtio_device_restore(&vp_dev->vdev);\r\n}\r\nstatic void virtio_pci_release_dev(struct device *_d)\r\n{\r\nstruct virtio_device *vdev = dev_to_virtio(_d);\r\nstruct virtio_pci_device *vp_dev = to_vp_device(vdev);\r\nkfree(vp_dev);\r\n}\r\nstatic int virtio_pci_probe(struct pci_dev *pci_dev,\r\nconst struct pci_device_id *id)\r\n{\r\nstruct virtio_pci_device *vp_dev;\r\nint rc;\r\nvp_dev = kzalloc(sizeof(struct virtio_pci_device), GFP_KERNEL);\r\nif (!vp_dev)\r\nreturn -ENOMEM;\r\npci_set_drvdata(pci_dev, vp_dev);\r\nvp_dev->vdev.dev.parent = &pci_dev->dev;\r\nvp_dev->vdev.dev.release = virtio_pci_release_dev;\r\nvp_dev->pci_dev = pci_dev;\r\nINIT_LIST_HEAD(&vp_dev->virtqueues);\r\nspin_lock_init(&vp_dev->lock);\r\nrc = pci_enable_device(pci_dev);\r\nif (rc)\r\ngoto err_enable_device;\r\nif (force_legacy) {\r\nrc = virtio_pci_legacy_probe(vp_dev);\r\nif (rc == -ENODEV || rc == -ENOMEM)\r\nrc = virtio_pci_modern_probe(vp_dev);\r\nif (rc)\r\ngoto err_probe;\r\n} else {\r\nrc = virtio_pci_modern_probe(vp_dev);\r\nif (rc == -ENODEV)\r\nrc = virtio_pci_legacy_probe(vp_dev);\r\nif (rc)\r\ngoto err_probe;\r\n}\r\npci_set_master(pci_dev);\r\nrc = register_virtio_device(&vp_dev->vdev);\r\nif (rc)\r\ngoto err_register;\r\nreturn 0;\r\nerr_register:\r\nif (vp_dev->ioaddr)\r\nvirtio_pci_legacy_remove(vp_dev);\r\nelse\r\nvirtio_pci_modern_remove(vp_dev);\r\nerr_probe:\r\npci_disable_device(pci_dev);\r\nerr_enable_device:\r\nkfree(vp_dev);\r\nreturn rc;\r\n}\r\nstatic void virtio_pci_remove(struct pci_dev *pci_dev)\r\n{\r\nstruct virtio_pci_device *vp_dev = pci_get_drvdata(pci_dev);\r\nstruct device *dev = get_device(&vp_dev->vdev.dev);\r\nunregister_virtio_device(&vp_dev->vdev);\r\nif (vp_dev->ioaddr)\r\nvirtio_pci_legacy_remove(vp_dev);\r\nelse\r\nvirtio_pci_modern_remove(vp_dev);\r\npci_disable_device(pci_dev);\r\nput_device(dev);\r\n}
