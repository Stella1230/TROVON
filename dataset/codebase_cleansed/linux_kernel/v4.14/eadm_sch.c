static void EADM_LOG_HEX(int level, void *data, int length)\r\n{\r\nif (!debug_level_enabled(eadm_debug, level))\r\nreturn;\r\nwhile (length > 0) {\r\ndebug_event(eadm_debug, level, data, length);\r\nlength -= eadm_debug->buf_size;\r\ndata += eadm_debug->buf_size;\r\n}\r\n}\r\nstatic void orb_init(union orb *orb)\r\n{\r\nmemset(orb, 0, sizeof(union orb));\r\norb->eadm.compat1 = 1;\r\norb->eadm.compat2 = 1;\r\norb->eadm.fmt = 1;\r\norb->eadm.x = 1;\r\n}\r\nstatic int eadm_subchannel_start(struct subchannel *sch, struct aob *aob)\r\n{\r\nunion orb *orb = &get_eadm_private(sch)->orb;\r\nint cc;\r\norb_init(orb);\r\norb->eadm.aob = (u32)__pa(aob);\r\norb->eadm.intparm = (u32)(addr_t)sch;\r\norb->eadm.key = PAGE_DEFAULT_KEY >> 4;\r\nEADM_LOG(6, "start");\r\nEADM_LOG_HEX(6, &sch->schid, sizeof(sch->schid));\r\ncc = ssch(sch->schid, orb);\r\nswitch (cc) {\r\ncase 0:\r\nsch->schib.scsw.eadm.actl |= SCSW_ACTL_START_PEND;\r\nbreak;\r\ncase 1:\r\ncase 2:\r\nreturn -EBUSY;\r\ncase 3:\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int eadm_subchannel_clear(struct subchannel *sch)\r\n{\r\nint cc;\r\ncc = csch(sch->schid);\r\nif (cc)\r\nreturn -ENODEV;\r\nsch->schib.scsw.eadm.actl |= SCSW_ACTL_CLEAR_PEND;\r\nreturn 0;\r\n}\r\nstatic void eadm_subchannel_timeout(unsigned long data)\r\n{\r\nstruct subchannel *sch = (struct subchannel *) data;\r\nspin_lock_irq(sch->lock);\r\nEADM_LOG(1, "timeout");\r\nEADM_LOG_HEX(1, &sch->schid, sizeof(sch->schid));\r\nif (eadm_subchannel_clear(sch))\r\nEADM_LOG(0, "clear failed");\r\nspin_unlock_irq(sch->lock);\r\n}\r\nstatic void eadm_subchannel_set_timeout(struct subchannel *sch, int expires)\r\n{\r\nstruct eadm_private *private = get_eadm_private(sch);\r\nif (expires == 0) {\r\ndel_timer(&private->timer);\r\nreturn;\r\n}\r\nif (timer_pending(&private->timer)) {\r\nif (mod_timer(&private->timer, jiffies + expires))\r\nreturn;\r\n}\r\nprivate->timer.function = eadm_subchannel_timeout;\r\nprivate->timer.data = (unsigned long) sch;\r\nprivate->timer.expires = jiffies + expires;\r\nadd_timer(&private->timer);\r\n}\r\nstatic void eadm_subchannel_irq(struct subchannel *sch)\r\n{\r\nstruct eadm_private *private = get_eadm_private(sch);\r\nstruct eadm_scsw *scsw = &sch->schib.scsw.eadm;\r\nstruct irb *irb = this_cpu_ptr(&cio_irb);\r\nblk_status_t error = BLK_STS_OK;\r\nEADM_LOG(6, "irq");\r\nEADM_LOG_HEX(6, irb, sizeof(*irb));\r\ninc_irq_stat(IRQIO_ADM);\r\nif ((scsw->stctl & (SCSW_STCTL_ALERT_STATUS | SCSW_STCTL_STATUS_PEND))\r\n&& scsw->eswf == 1 && irb->esw.eadm.erw.r)\r\nerror = BLK_STS_IOERR;\r\nif (scsw->fctl & SCSW_FCTL_CLEAR_FUNC)\r\nerror = BLK_STS_TIMEOUT;\r\neadm_subchannel_set_timeout(sch, 0);\r\nif (private->state != EADM_BUSY) {\r\nEADM_LOG(1, "irq unsol");\r\nEADM_LOG_HEX(1, irb, sizeof(*irb));\r\nprivate->state = EADM_NOT_OPER;\r\ncss_sched_sch_todo(sch, SCH_TODO_EVAL);\r\nreturn;\r\n}\r\nscm_irq_handler((struct aob *)(unsigned long)scsw->aob, error);\r\nprivate->state = EADM_IDLE;\r\nif (private->completion)\r\ncomplete(private->completion);\r\n}\r\nstatic struct subchannel *eadm_get_idle_sch(void)\r\n{\r\nstruct eadm_private *private;\r\nstruct subchannel *sch;\r\nunsigned long flags;\r\nspin_lock_irqsave(&list_lock, flags);\r\nlist_for_each_entry(private, &eadm_list, head) {\r\nsch = private->sch;\r\nspin_lock(sch->lock);\r\nif (private->state == EADM_IDLE) {\r\nprivate->state = EADM_BUSY;\r\nlist_move_tail(&private->head, &eadm_list);\r\nspin_unlock(sch->lock);\r\nspin_unlock_irqrestore(&list_lock, flags);\r\nreturn sch;\r\n}\r\nspin_unlock(sch->lock);\r\n}\r\nspin_unlock_irqrestore(&list_lock, flags);\r\nreturn NULL;\r\n}\r\nint eadm_start_aob(struct aob *aob)\r\n{\r\nstruct eadm_private *private;\r\nstruct subchannel *sch;\r\nunsigned long flags;\r\nint ret;\r\nsch = eadm_get_idle_sch();\r\nif (!sch)\r\nreturn -EBUSY;\r\nspin_lock_irqsave(sch->lock, flags);\r\neadm_subchannel_set_timeout(sch, EADM_TIMEOUT);\r\nret = eadm_subchannel_start(sch, aob);\r\nif (!ret)\r\ngoto out_unlock;\r\neadm_subchannel_set_timeout(sch, 0);\r\nprivate = get_eadm_private(sch);\r\nprivate->state = EADM_NOT_OPER;\r\ncss_sched_sch_todo(sch, SCH_TODO_EVAL);\r\nout_unlock:\r\nspin_unlock_irqrestore(sch->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int eadm_subchannel_probe(struct subchannel *sch)\r\n{\r\nstruct eadm_private *private;\r\nint ret;\r\nprivate = kzalloc(sizeof(*private), GFP_KERNEL | GFP_DMA);\r\nif (!private)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&private->head);\r\ninit_timer(&private->timer);\r\nspin_lock_irq(sch->lock);\r\nset_eadm_private(sch, private);\r\nprivate->state = EADM_IDLE;\r\nprivate->sch = sch;\r\nsch->isc = EADM_SCH_ISC;\r\nret = cio_enable_subchannel(sch, (u32)(unsigned long)sch);\r\nif (ret) {\r\nset_eadm_private(sch, NULL);\r\nspin_unlock_irq(sch->lock);\r\nkfree(private);\r\ngoto out;\r\n}\r\nspin_unlock_irq(sch->lock);\r\nspin_lock_irq(&list_lock);\r\nlist_add(&private->head, &eadm_list);\r\nspin_unlock_irq(&list_lock);\r\nif (dev_get_uevent_suppress(&sch->dev)) {\r\ndev_set_uevent_suppress(&sch->dev, 0);\r\nkobject_uevent(&sch->dev.kobj, KOBJ_ADD);\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic void eadm_quiesce(struct subchannel *sch)\r\n{\r\nstruct eadm_private *private = get_eadm_private(sch);\r\nDECLARE_COMPLETION_ONSTACK(completion);\r\nint ret;\r\nspin_lock_irq(sch->lock);\r\nif (private->state != EADM_BUSY)\r\ngoto disable;\r\nif (eadm_subchannel_clear(sch))\r\ngoto disable;\r\nprivate->completion = &completion;\r\nspin_unlock_irq(sch->lock);\r\nwait_for_completion_io(&completion);\r\nspin_lock_irq(sch->lock);\r\nprivate->completion = NULL;\r\ndisable:\r\neadm_subchannel_set_timeout(sch, 0);\r\ndo {\r\nret = cio_disable_subchannel(sch);\r\n} while (ret == -EBUSY);\r\nspin_unlock_irq(sch->lock);\r\n}\r\nstatic int eadm_subchannel_remove(struct subchannel *sch)\r\n{\r\nstruct eadm_private *private = get_eadm_private(sch);\r\nspin_lock_irq(&list_lock);\r\nlist_del(&private->head);\r\nspin_unlock_irq(&list_lock);\r\neadm_quiesce(sch);\r\nspin_lock_irq(sch->lock);\r\nset_eadm_private(sch, NULL);\r\nspin_unlock_irq(sch->lock);\r\nkfree(private);\r\nreturn 0;\r\n}\r\nstatic void eadm_subchannel_shutdown(struct subchannel *sch)\r\n{\r\neadm_quiesce(sch);\r\n}\r\nstatic int eadm_subchannel_freeze(struct subchannel *sch)\r\n{\r\nreturn cio_disable_subchannel(sch);\r\n}\r\nstatic int eadm_subchannel_restore(struct subchannel *sch)\r\n{\r\nreturn cio_enable_subchannel(sch, (u32)(unsigned long)sch);\r\n}\r\nstatic int eadm_subchannel_sch_event(struct subchannel *sch, int process)\r\n{\r\nstruct eadm_private *private;\r\nunsigned long flags;\r\nspin_lock_irqsave(sch->lock, flags);\r\nif (!device_is_registered(&sch->dev))\r\ngoto out_unlock;\r\nif (work_pending(&sch->todo_work))\r\ngoto out_unlock;\r\nif (cio_update_schib(sch)) {\r\ncss_sched_sch_todo(sch, SCH_TODO_UNREG);\r\ngoto out_unlock;\r\n}\r\nprivate = get_eadm_private(sch);\r\nif (private->state == EADM_NOT_OPER)\r\nprivate->state = EADM_IDLE;\r\nout_unlock:\r\nspin_unlock_irqrestore(sch->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int __init eadm_sch_init(void)\r\n{\r\nint ret;\r\nif (!css_general_characteristics.eadm)\r\nreturn -ENXIO;\r\neadm_debug = debug_register("eadm_log", 16, 1, 16);\r\nif (!eadm_debug)\r\nreturn -ENOMEM;\r\ndebug_register_view(eadm_debug, &debug_hex_ascii_view);\r\ndebug_set_level(eadm_debug, 2);\r\nisc_register(EADM_SCH_ISC);\r\nret = css_driver_register(&eadm_subchannel_driver);\r\nif (ret)\r\ngoto cleanup;\r\nreturn ret;\r\ncleanup:\r\nisc_unregister(EADM_SCH_ISC);\r\ndebug_unregister(eadm_debug);\r\nreturn ret;\r\n}\r\nstatic void __exit eadm_sch_exit(void)\r\n{\r\ncss_driver_unregister(&eadm_subchannel_driver);\r\nisc_unregister(EADM_SCH_ISC);\r\ndebug_unregister(eadm_debug);\r\n}
