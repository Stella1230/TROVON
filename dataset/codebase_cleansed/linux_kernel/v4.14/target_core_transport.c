int init_se_kmem_caches(void)\r\n{\r\nse_sess_cache = kmem_cache_create("se_sess_cache",\r\nsizeof(struct se_session), __alignof__(struct se_session),\r\n0, NULL);\r\nif (!se_sess_cache) {\r\npr_err("kmem_cache_create() for struct se_session"\r\n" failed\n");\r\ngoto out;\r\n}\r\nse_ua_cache = kmem_cache_create("se_ua_cache",\r\nsizeof(struct se_ua), __alignof__(struct se_ua),\r\n0, NULL);\r\nif (!se_ua_cache) {\r\npr_err("kmem_cache_create() for struct se_ua failed\n");\r\ngoto out_free_sess_cache;\r\n}\r\nt10_pr_reg_cache = kmem_cache_create("t10_pr_reg_cache",\r\nsizeof(struct t10_pr_registration),\r\n__alignof__(struct t10_pr_registration), 0, NULL);\r\nif (!t10_pr_reg_cache) {\r\npr_err("kmem_cache_create() for struct t10_pr_registration"\r\n" failed\n");\r\ngoto out_free_ua_cache;\r\n}\r\nt10_alua_lu_gp_cache = kmem_cache_create("t10_alua_lu_gp_cache",\r\nsizeof(struct t10_alua_lu_gp), __alignof__(struct t10_alua_lu_gp),\r\n0, NULL);\r\nif (!t10_alua_lu_gp_cache) {\r\npr_err("kmem_cache_create() for t10_alua_lu_gp_cache"\r\n" failed\n");\r\ngoto out_free_pr_reg_cache;\r\n}\r\nt10_alua_lu_gp_mem_cache = kmem_cache_create("t10_alua_lu_gp_mem_cache",\r\nsizeof(struct t10_alua_lu_gp_member),\r\n__alignof__(struct t10_alua_lu_gp_member), 0, NULL);\r\nif (!t10_alua_lu_gp_mem_cache) {\r\npr_err("kmem_cache_create() for t10_alua_lu_gp_mem_"\r\n"cache failed\n");\r\ngoto out_free_lu_gp_cache;\r\n}\r\nt10_alua_tg_pt_gp_cache = kmem_cache_create("t10_alua_tg_pt_gp_cache",\r\nsizeof(struct t10_alua_tg_pt_gp),\r\n__alignof__(struct t10_alua_tg_pt_gp), 0, NULL);\r\nif (!t10_alua_tg_pt_gp_cache) {\r\npr_err("kmem_cache_create() for t10_alua_tg_pt_gp_"\r\n"cache failed\n");\r\ngoto out_free_lu_gp_mem_cache;\r\n}\r\nt10_alua_lba_map_cache = kmem_cache_create(\r\n"t10_alua_lba_map_cache",\r\nsizeof(struct t10_alua_lba_map),\r\n__alignof__(struct t10_alua_lba_map), 0, NULL);\r\nif (!t10_alua_lba_map_cache) {\r\npr_err("kmem_cache_create() for t10_alua_lba_map_"\r\n"cache failed\n");\r\ngoto out_free_tg_pt_gp_cache;\r\n}\r\nt10_alua_lba_map_mem_cache = kmem_cache_create(\r\n"t10_alua_lba_map_mem_cache",\r\nsizeof(struct t10_alua_lba_map_member),\r\n__alignof__(struct t10_alua_lba_map_member), 0, NULL);\r\nif (!t10_alua_lba_map_mem_cache) {\r\npr_err("kmem_cache_create() for t10_alua_lba_map_mem_"\r\n"cache failed\n");\r\ngoto out_free_lba_map_cache;\r\n}\r\ntarget_completion_wq = alloc_workqueue("target_completion",\r\nWQ_MEM_RECLAIM, 0);\r\nif (!target_completion_wq)\r\ngoto out_free_lba_map_mem_cache;\r\nreturn 0;\r\nout_free_lba_map_mem_cache:\r\nkmem_cache_destroy(t10_alua_lba_map_mem_cache);\r\nout_free_lba_map_cache:\r\nkmem_cache_destroy(t10_alua_lba_map_cache);\r\nout_free_tg_pt_gp_cache:\r\nkmem_cache_destroy(t10_alua_tg_pt_gp_cache);\r\nout_free_lu_gp_mem_cache:\r\nkmem_cache_destroy(t10_alua_lu_gp_mem_cache);\r\nout_free_lu_gp_cache:\r\nkmem_cache_destroy(t10_alua_lu_gp_cache);\r\nout_free_pr_reg_cache:\r\nkmem_cache_destroy(t10_pr_reg_cache);\r\nout_free_ua_cache:\r\nkmem_cache_destroy(se_ua_cache);\r\nout_free_sess_cache:\r\nkmem_cache_destroy(se_sess_cache);\r\nout:\r\nreturn -ENOMEM;\r\n}\r\nvoid release_se_kmem_caches(void)\r\n{\r\ndestroy_workqueue(target_completion_wq);\r\nkmem_cache_destroy(se_sess_cache);\r\nkmem_cache_destroy(se_ua_cache);\r\nkmem_cache_destroy(t10_pr_reg_cache);\r\nkmem_cache_destroy(t10_alua_lu_gp_cache);\r\nkmem_cache_destroy(t10_alua_lu_gp_mem_cache);\r\nkmem_cache_destroy(t10_alua_tg_pt_gp_cache);\r\nkmem_cache_destroy(t10_alua_lba_map_cache);\r\nkmem_cache_destroy(t10_alua_lba_map_mem_cache);\r\n}\r\nu32 scsi_get_new_index(scsi_index_t type)\r\n{\r\nu32 new_index;\r\nBUG_ON((type < 0) || (type >= SCSI_INDEX_TYPE_MAX));\r\nspin_lock(&scsi_mib_index_lock);\r\nnew_index = ++scsi_mib_index[type];\r\nspin_unlock(&scsi_mib_index_lock);\r\nreturn new_index;\r\n}\r\nvoid transport_subsystem_check_init(void)\r\n{\r\nint ret;\r\nstatic int sub_api_initialized;\r\nif (sub_api_initialized)\r\nreturn;\r\nret = request_module("target_core_iblock");\r\nif (ret != 0)\r\npr_err("Unable to load target_core_iblock\n");\r\nret = request_module("target_core_file");\r\nif (ret != 0)\r\npr_err("Unable to load target_core_file\n");\r\nret = request_module("target_core_pscsi");\r\nif (ret != 0)\r\npr_err("Unable to load target_core_pscsi\n");\r\nret = request_module("target_core_user");\r\nif (ret != 0)\r\npr_err("Unable to load target_core_user\n");\r\nsub_api_initialized = 1;\r\n}\r\nstruct se_session *transport_init_session(enum target_prot_op sup_prot_ops)\r\n{\r\nstruct se_session *se_sess;\r\nse_sess = kmem_cache_zalloc(se_sess_cache, GFP_KERNEL);\r\nif (!se_sess) {\r\npr_err("Unable to allocate struct se_session from"\r\n" se_sess_cache\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nINIT_LIST_HEAD(&se_sess->sess_list);\r\nINIT_LIST_HEAD(&se_sess->sess_acl_list);\r\nINIT_LIST_HEAD(&se_sess->sess_cmd_list);\r\nINIT_LIST_HEAD(&se_sess->sess_wait_list);\r\nspin_lock_init(&se_sess->sess_cmd_lock);\r\nse_sess->sup_prot_ops = sup_prot_ops;\r\nreturn se_sess;\r\n}\r\nint transport_alloc_session_tags(struct se_session *se_sess,\r\nunsigned int tag_num, unsigned int tag_size)\r\n{\r\nint rc;\r\nse_sess->sess_cmd_map = kzalloc(tag_num * tag_size,\r\nGFP_KERNEL | __GFP_NOWARN | __GFP_RETRY_MAYFAIL);\r\nif (!se_sess->sess_cmd_map) {\r\nse_sess->sess_cmd_map = vzalloc(tag_num * tag_size);\r\nif (!se_sess->sess_cmd_map) {\r\npr_err("Unable to allocate se_sess->sess_cmd_map\n");\r\nreturn -ENOMEM;\r\n}\r\n}\r\nrc = percpu_ida_init(&se_sess->sess_tag_pool, tag_num);\r\nif (rc < 0) {\r\npr_err("Unable to init se_sess->sess_tag_pool,"\r\n" tag_num: %u\n", tag_num);\r\nkvfree(se_sess->sess_cmd_map);\r\nse_sess->sess_cmd_map = NULL;\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstruct se_session *transport_init_session_tags(unsigned int tag_num,\r\nunsigned int tag_size,\r\nenum target_prot_op sup_prot_ops)\r\n{\r\nstruct se_session *se_sess;\r\nint rc;\r\nif (tag_num != 0 && !tag_size) {\r\npr_err("init_session_tags called with percpu-ida tag_num:"\r\n" %u, but zero tag_size\n", tag_num);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (!tag_num && tag_size) {\r\npr_err("init_session_tags called with percpu-ida tag_size:"\r\n" %u, but zero tag_num\n", tag_size);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nse_sess = transport_init_session(sup_prot_ops);\r\nif (IS_ERR(se_sess))\r\nreturn se_sess;\r\nrc = transport_alloc_session_tags(se_sess, tag_num, tag_size);\r\nif (rc < 0) {\r\ntransport_free_session(se_sess);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nreturn se_sess;\r\n}\r\nvoid __transport_register_session(\r\nstruct se_portal_group *se_tpg,\r\nstruct se_node_acl *se_nacl,\r\nstruct se_session *se_sess,\r\nvoid *fabric_sess_ptr)\r\n{\r\nconst struct target_core_fabric_ops *tfo = se_tpg->se_tpg_tfo;\r\nunsigned char buf[PR_REG_ISID_LEN];\r\nse_sess->se_tpg = se_tpg;\r\nse_sess->fabric_sess_ptr = fabric_sess_ptr;\r\nif (se_nacl) {\r\nif (se_nacl->saved_prot_type)\r\nse_sess->sess_prot_type = se_nacl->saved_prot_type;\r\nelse if (tfo->tpg_check_prot_fabric_only)\r\nse_sess->sess_prot_type = se_nacl->saved_prot_type =\r\ntfo->tpg_check_prot_fabric_only(se_tpg);\r\nif (se_tpg->se_tpg_tfo->sess_get_initiator_sid != NULL) {\r\nmemset(&buf[0], 0, PR_REG_ISID_LEN);\r\nse_tpg->se_tpg_tfo->sess_get_initiator_sid(se_sess,\r\n&buf[0], PR_REG_ISID_LEN);\r\nse_sess->sess_bin_isid = get_unaligned_be64(&buf[0]);\r\n}\r\nspin_lock_irq(&se_nacl->nacl_sess_lock);\r\nse_nacl->nacl_sess = se_sess;\r\nlist_add_tail(&se_sess->sess_acl_list,\r\n&se_nacl->acl_sess_list);\r\nspin_unlock_irq(&se_nacl->nacl_sess_lock);\r\n}\r\nlist_add_tail(&se_sess->sess_list, &se_tpg->tpg_sess_list);\r\npr_debug("TARGET_CORE[%s]: Registered fabric_sess_ptr: %p\n",\r\nse_tpg->se_tpg_tfo->get_fabric_name(), se_sess->fabric_sess_ptr);\r\n}\r\nvoid transport_register_session(\r\nstruct se_portal_group *se_tpg,\r\nstruct se_node_acl *se_nacl,\r\nstruct se_session *se_sess,\r\nvoid *fabric_sess_ptr)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&se_tpg->session_lock, flags);\r\n__transport_register_session(se_tpg, se_nacl, se_sess, fabric_sess_ptr);\r\nspin_unlock_irqrestore(&se_tpg->session_lock, flags);\r\n}\r\nstruct se_session *\r\ntarget_alloc_session(struct se_portal_group *tpg,\r\nunsigned int tag_num, unsigned int tag_size,\r\nenum target_prot_op prot_op,\r\nconst char *initiatorname, void *private,\r\nint (*callback)(struct se_portal_group *,\r\nstruct se_session *, void *))\r\n{\r\nstruct se_session *sess;\r\nif (tag_num != 0)\r\nsess = transport_init_session_tags(tag_num, tag_size, prot_op);\r\nelse\r\nsess = transport_init_session(prot_op);\r\nif (IS_ERR(sess))\r\nreturn sess;\r\nsess->se_node_acl = core_tpg_check_initiator_node_acl(tpg,\r\n(unsigned char *)initiatorname);\r\nif (!sess->se_node_acl) {\r\ntransport_free_session(sess);\r\nreturn ERR_PTR(-EACCES);\r\n}\r\nif (callback != NULL) {\r\nint rc = callback(tpg, sess, private);\r\nif (rc) {\r\ntransport_free_session(sess);\r\nreturn ERR_PTR(rc);\r\n}\r\n}\r\ntransport_register_session(tpg, sess->se_node_acl, sess, private);\r\nreturn sess;\r\n}\r\nssize_t target_show_dynamic_sessions(struct se_portal_group *se_tpg, char *page)\r\n{\r\nstruct se_session *se_sess;\r\nssize_t len = 0;\r\nspin_lock_bh(&se_tpg->session_lock);\r\nlist_for_each_entry(se_sess, &se_tpg->tpg_sess_list, sess_list) {\r\nif (!se_sess->se_node_acl)\r\ncontinue;\r\nif (!se_sess->se_node_acl->dynamic_node_acl)\r\ncontinue;\r\nif (strlen(se_sess->se_node_acl->initiatorname) + 1 + len > PAGE_SIZE)\r\nbreak;\r\nlen += snprintf(page + len, PAGE_SIZE - len, "%s\n",\r\nse_sess->se_node_acl->initiatorname);\r\nlen += 1;\r\n}\r\nspin_unlock_bh(&se_tpg->session_lock);\r\nreturn len;\r\n}\r\nstatic void target_complete_nacl(struct kref *kref)\r\n{\r\nstruct se_node_acl *nacl = container_of(kref,\r\nstruct se_node_acl, acl_kref);\r\nstruct se_portal_group *se_tpg = nacl->se_tpg;\r\nif (!nacl->dynamic_stop) {\r\ncomplete(&nacl->acl_free_comp);\r\nreturn;\r\n}\r\nmutex_lock(&se_tpg->acl_node_mutex);\r\nlist_del_init(&nacl->acl_list);\r\nmutex_unlock(&se_tpg->acl_node_mutex);\r\ncore_tpg_wait_for_nacl_pr_ref(nacl);\r\ncore_free_device_list_for_node(nacl, se_tpg);\r\nkfree(nacl);\r\n}\r\nvoid target_put_nacl(struct se_node_acl *nacl)\r\n{\r\nkref_put(&nacl->acl_kref, target_complete_nacl);\r\n}\r\nvoid transport_deregister_session_configfs(struct se_session *se_sess)\r\n{\r\nstruct se_node_acl *se_nacl;\r\nunsigned long flags;\r\nse_nacl = se_sess->se_node_acl;\r\nif (se_nacl) {\r\nspin_lock_irqsave(&se_nacl->nacl_sess_lock, flags);\r\nif (!list_empty(&se_sess->sess_acl_list))\r\nlist_del_init(&se_sess->sess_acl_list);\r\nif (list_empty(&se_nacl->acl_sess_list))\r\nse_nacl->nacl_sess = NULL;\r\nelse {\r\nse_nacl->nacl_sess = container_of(\r\nse_nacl->acl_sess_list.prev,\r\nstruct se_session, sess_acl_list);\r\n}\r\nspin_unlock_irqrestore(&se_nacl->nacl_sess_lock, flags);\r\n}\r\n}\r\nvoid transport_free_session(struct se_session *se_sess)\r\n{\r\nstruct se_node_acl *se_nacl = se_sess->se_node_acl;\r\nif (se_nacl) {\r\nstruct se_portal_group *se_tpg = se_nacl->se_tpg;\r\nconst struct target_core_fabric_ops *se_tfo = se_tpg->se_tpg_tfo;\r\nunsigned long flags;\r\nse_sess->se_node_acl = NULL;\r\nmutex_lock(&se_tpg->acl_node_mutex);\r\nif (se_nacl->dynamic_node_acl &&\r\n!se_tfo->tpg_check_demo_mode_cache(se_tpg)) {\r\nspin_lock_irqsave(&se_nacl->nacl_sess_lock, flags);\r\nif (list_empty(&se_nacl->acl_sess_list))\r\nse_nacl->dynamic_stop = true;\r\nspin_unlock_irqrestore(&se_nacl->nacl_sess_lock, flags);\r\nif (se_nacl->dynamic_stop)\r\nlist_del_init(&se_nacl->acl_list);\r\n}\r\nmutex_unlock(&se_tpg->acl_node_mutex);\r\nif (se_nacl->dynamic_stop)\r\ntarget_put_nacl(se_nacl);\r\ntarget_put_nacl(se_nacl);\r\n}\r\nif (se_sess->sess_cmd_map) {\r\npercpu_ida_destroy(&se_sess->sess_tag_pool);\r\nkvfree(se_sess->sess_cmd_map);\r\n}\r\nkmem_cache_free(se_sess_cache, se_sess);\r\n}\r\nvoid transport_deregister_session(struct se_session *se_sess)\r\n{\r\nstruct se_portal_group *se_tpg = se_sess->se_tpg;\r\nunsigned long flags;\r\nif (!se_tpg) {\r\ntransport_free_session(se_sess);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&se_tpg->session_lock, flags);\r\nlist_del(&se_sess->sess_list);\r\nse_sess->se_tpg = NULL;\r\nse_sess->fabric_sess_ptr = NULL;\r\nspin_unlock_irqrestore(&se_tpg->session_lock, flags);\r\npr_debug("TARGET_CORE[%s]: Deregistered fabric_sess\n",\r\nse_tpg->se_tpg_tfo->get_fabric_name());\r\ntransport_free_session(se_sess);\r\n}\r\nstatic void target_remove_from_state_list(struct se_cmd *cmd)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nunsigned long flags;\r\nif (!dev)\r\nreturn;\r\nspin_lock_irqsave(&dev->execute_task_lock, flags);\r\nif (cmd->state_active) {\r\nlist_del(&cmd->state_list);\r\ncmd->state_active = false;\r\n}\r\nspin_unlock_irqrestore(&dev->execute_task_lock, flags);\r\n}\r\nstatic int transport_cmd_check_stop_to_fabric(struct se_cmd *cmd)\r\n{\r\nunsigned long flags;\r\ntarget_remove_from_state_list(cmd);\r\ncmd->se_lun = NULL;\r\nspin_lock_irqsave(&cmd->t_state_lock, flags);\r\nif (cmd->transport_state & CMD_T_STOP) {\r\npr_debug("%s:%d CMD_T_STOP for ITT: 0x%08llx\n",\r\n__func__, __LINE__, cmd->tag);\r\nspin_unlock_irqrestore(&cmd->t_state_lock, flags);\r\ncomplete_all(&cmd->t_transport_stop_comp);\r\nreturn 1;\r\n}\r\ncmd->transport_state &= ~CMD_T_ACTIVE;\r\nspin_unlock_irqrestore(&cmd->t_state_lock, flags);\r\nreturn cmd->se_tfo->check_stop_free(cmd);\r\n}\r\nstatic void transport_lun_remove_cmd(struct se_cmd *cmd)\r\n{\r\nstruct se_lun *lun = cmd->se_lun;\r\nif (!lun)\r\nreturn;\r\nif (cmpxchg(&cmd->lun_ref_active, true, false))\r\npercpu_ref_put(&lun->lun_ref);\r\n}\r\nint transport_cmd_finish_abort(struct se_cmd *cmd, int remove)\r\n{\r\nbool ack_kref = (cmd->se_cmd_flags & SCF_ACK_KREF);\r\nint ret = 0;\r\nif (cmd->se_cmd_flags & SCF_SE_LUN_CMD)\r\ntransport_lun_remove_cmd(cmd);\r\nif (remove)\r\ncmd->se_tfo->aborted_task(cmd);\r\nif (transport_cmd_check_stop_to_fabric(cmd))\r\nreturn 1;\r\nif (remove && ack_kref)\r\nret = transport_put_cmd(cmd);\r\nreturn ret;\r\n}\r\nstatic void target_complete_failure_work(struct work_struct *work)\r\n{\r\nstruct se_cmd *cmd = container_of(work, struct se_cmd, work);\r\ntransport_generic_request_failure(cmd,\r\nTCM_LOGICAL_UNIT_COMMUNICATION_FAILURE);\r\n}\r\nstatic unsigned char *transport_get_sense_buffer(struct se_cmd *cmd)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nWARN_ON(!cmd->se_lun);\r\nif (!dev)\r\nreturn NULL;\r\nif (cmd->se_cmd_flags & SCF_SENT_CHECK_CONDITION)\r\nreturn NULL;\r\ncmd->scsi_sense_length = TRANSPORT_SENSE_BUFFER;\r\npr_debug("HBA_[%u]_PLUG[%s]: Requesting sense for SAM STATUS: 0x%02x\n",\r\ndev->se_hba->hba_id, dev->transport->name, cmd->scsi_status);\r\nreturn cmd->sense_buffer;\r\n}\r\nvoid transport_copy_sense_to_cmd(struct se_cmd *cmd, unsigned char *sense)\r\n{\r\nunsigned char *cmd_sense_buf;\r\nunsigned long flags;\r\nspin_lock_irqsave(&cmd->t_state_lock, flags);\r\ncmd_sense_buf = transport_get_sense_buffer(cmd);\r\nif (!cmd_sense_buf) {\r\nspin_unlock_irqrestore(&cmd->t_state_lock, flags);\r\nreturn;\r\n}\r\ncmd->se_cmd_flags |= SCF_TRANSPORT_TASK_SENSE;\r\nmemcpy(cmd_sense_buf, sense, cmd->scsi_sense_length);\r\nspin_unlock_irqrestore(&cmd->t_state_lock, flags);\r\n}\r\nvoid target_complete_cmd(struct se_cmd *cmd, u8 scsi_status)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nint success;\r\nunsigned long flags;\r\ncmd->scsi_status = scsi_status;\r\nspin_lock_irqsave(&cmd->t_state_lock, flags);\r\nswitch (cmd->scsi_status) {\r\ncase SAM_STAT_CHECK_CONDITION:\r\nif (cmd->se_cmd_flags & SCF_TRANSPORT_TASK_SENSE)\r\nsuccess = 1;\r\nelse\r\nsuccess = 0;\r\nbreak;\r\ndefault:\r\nsuccess = 1;\r\nbreak;\r\n}\r\nif (cmd->transport_state & CMD_T_ABORTED ||\r\ncmd->transport_state & CMD_T_STOP) {\r\nspin_unlock_irqrestore(&cmd->t_state_lock, flags);\r\nif (cmd->se_cmd_flags & SCF_COMPARE_AND_WRITE) {\r\nup(&dev->caw_sem);\r\n}\r\ncomplete_all(&cmd->t_transport_stop_comp);\r\nreturn;\r\n} else if (!success) {\r\nINIT_WORK(&cmd->work, target_complete_failure_work);\r\n} else {\r\nINIT_WORK(&cmd->work, target_complete_ok_work);\r\n}\r\ncmd->t_state = TRANSPORT_COMPLETE;\r\ncmd->transport_state |= (CMD_T_COMPLETE | CMD_T_ACTIVE);\r\nspin_unlock_irqrestore(&cmd->t_state_lock, flags);\r\nif (cmd->se_cmd_flags & SCF_USE_CPUID)\r\nqueue_work_on(cmd->cpuid, target_completion_wq, &cmd->work);\r\nelse\r\nqueue_work(target_completion_wq, &cmd->work);\r\n}\r\nvoid target_complete_cmd_with_length(struct se_cmd *cmd, u8 scsi_status, int length)\r\n{\r\nif (scsi_status == SAM_STAT_GOOD && length < cmd->data_length) {\r\nif (cmd->se_cmd_flags & SCF_UNDERFLOW_BIT) {\r\ncmd->residual_count += cmd->data_length - length;\r\n} else {\r\ncmd->se_cmd_flags |= SCF_UNDERFLOW_BIT;\r\ncmd->residual_count = cmd->data_length - length;\r\n}\r\ncmd->data_length = length;\r\n}\r\ntarget_complete_cmd(cmd, scsi_status);\r\n}\r\nstatic void target_add_to_state_list(struct se_cmd *cmd)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->execute_task_lock, flags);\r\nif (!cmd->state_active) {\r\nlist_add_tail(&cmd->state_list, &dev->state_list);\r\ncmd->state_active = true;\r\n}\r\nspin_unlock_irqrestore(&dev->execute_task_lock, flags);\r\n}\r\nvoid target_qf_do_work(struct work_struct *work)\r\n{\r\nstruct se_device *dev = container_of(work, struct se_device,\r\nqf_work_queue);\r\nLIST_HEAD(qf_cmd_list);\r\nstruct se_cmd *cmd, *cmd_tmp;\r\nspin_lock_irq(&dev->qf_cmd_lock);\r\nlist_splice_init(&dev->qf_cmd_list, &qf_cmd_list);\r\nspin_unlock_irq(&dev->qf_cmd_lock);\r\nlist_for_each_entry_safe(cmd, cmd_tmp, &qf_cmd_list, se_qf_node) {\r\nlist_del(&cmd->se_qf_node);\r\natomic_dec_mb(&dev->dev_qf_count);\r\npr_debug("Processing %s cmd: %p QUEUE_FULL in work queue"\r\n" context: %s\n", cmd->se_tfo->get_fabric_name(), cmd,\r\n(cmd->t_state == TRANSPORT_COMPLETE_QF_OK) ? "COMPLETE_OK" :\r\n(cmd->t_state == TRANSPORT_COMPLETE_QF_WP) ? "WRITE_PENDING"\r\n: "UNKNOWN");\r\nif (cmd->t_state == TRANSPORT_COMPLETE_QF_WP)\r\ntransport_write_pending_qf(cmd);\r\nelse if (cmd->t_state == TRANSPORT_COMPLETE_QF_OK ||\r\ncmd->t_state == TRANSPORT_COMPLETE_QF_ERR)\r\ntransport_complete_qf(cmd);\r\n}\r\n}\r\nunsigned char *transport_dump_cmd_direction(struct se_cmd *cmd)\r\n{\r\nswitch (cmd->data_direction) {\r\ncase DMA_NONE:\r\nreturn "NONE";\r\ncase DMA_FROM_DEVICE:\r\nreturn "READ";\r\ncase DMA_TO_DEVICE:\r\nreturn "WRITE";\r\ncase DMA_BIDIRECTIONAL:\r\nreturn "BIDI";\r\ndefault:\r\nbreak;\r\n}\r\nreturn "UNKNOWN";\r\n}\r\nvoid transport_dump_dev_state(\r\nstruct se_device *dev,\r\nchar *b,\r\nint *bl)\r\n{\r\n*bl += sprintf(b + *bl, "Status: ");\r\nif (dev->export_count)\r\n*bl += sprintf(b + *bl, "ACTIVATED");\r\nelse\r\n*bl += sprintf(b + *bl, "DEACTIVATED");\r\n*bl += sprintf(b + *bl, " Max Queue Depth: %d", dev->queue_depth);\r\n*bl += sprintf(b + *bl, " SectorSize: %u HwMaxSectors: %u\n",\r\ndev->dev_attrib.block_size,\r\ndev->dev_attrib.hw_max_sectors);\r\n*bl += sprintf(b + *bl, " ");\r\n}\r\nvoid transport_dump_vpd_proto_id(\r\nstruct t10_vpd *vpd,\r\nunsigned char *p_buf,\r\nint p_buf_len)\r\n{\r\nunsigned char buf[VPD_TMP_BUF_SIZE];\r\nint len;\r\nmemset(buf, 0, VPD_TMP_BUF_SIZE);\r\nlen = sprintf(buf, "T10 VPD Protocol Identifier: ");\r\nswitch (vpd->protocol_identifier) {\r\ncase 0x00:\r\nsprintf(buf+len, "Fibre Channel\n");\r\nbreak;\r\ncase 0x10:\r\nsprintf(buf+len, "Parallel SCSI\n");\r\nbreak;\r\ncase 0x20:\r\nsprintf(buf+len, "SSA\n");\r\nbreak;\r\ncase 0x30:\r\nsprintf(buf+len, "IEEE 1394\n");\r\nbreak;\r\ncase 0x40:\r\nsprintf(buf+len, "SCSI Remote Direct Memory Access"\r\n" Protocol\n");\r\nbreak;\r\ncase 0x50:\r\nsprintf(buf+len, "Internet SCSI (iSCSI)\n");\r\nbreak;\r\ncase 0x60:\r\nsprintf(buf+len, "SAS Serial SCSI Protocol\n");\r\nbreak;\r\ncase 0x70:\r\nsprintf(buf+len, "Automation/Drive Interface Transport"\r\n" Protocol\n");\r\nbreak;\r\ncase 0x80:\r\nsprintf(buf+len, "AT Attachment Interface ATA/ATAPI\n");\r\nbreak;\r\ndefault:\r\nsprintf(buf+len, "Unknown 0x%02x\n",\r\nvpd->protocol_identifier);\r\nbreak;\r\n}\r\nif (p_buf)\r\nstrncpy(p_buf, buf, p_buf_len);\r\nelse\r\npr_debug("%s", buf);\r\n}\r\nvoid\r\ntransport_set_vpd_proto_id(struct t10_vpd *vpd, unsigned char *page_83)\r\n{\r\nif (page_83[1] & 0x80) {\r\nvpd->protocol_identifier = (page_83[0] & 0xf0);\r\nvpd->protocol_identifier_set = 1;\r\ntransport_dump_vpd_proto_id(vpd, NULL, 0);\r\n}\r\n}\r\nint transport_dump_vpd_assoc(\r\nstruct t10_vpd *vpd,\r\nunsigned char *p_buf,\r\nint p_buf_len)\r\n{\r\nunsigned char buf[VPD_TMP_BUF_SIZE];\r\nint ret = 0;\r\nint len;\r\nmemset(buf, 0, VPD_TMP_BUF_SIZE);\r\nlen = sprintf(buf, "T10 VPD Identifier Association: ");\r\nswitch (vpd->association) {\r\ncase 0x00:\r\nsprintf(buf+len, "addressed logical unit\n");\r\nbreak;\r\ncase 0x10:\r\nsprintf(buf+len, "target port\n");\r\nbreak;\r\ncase 0x20:\r\nsprintf(buf+len, "SCSI target device\n");\r\nbreak;\r\ndefault:\r\nsprintf(buf+len, "Unknown 0x%02x\n", vpd->association);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (p_buf)\r\nstrncpy(p_buf, buf, p_buf_len);\r\nelse\r\npr_debug("%s", buf);\r\nreturn ret;\r\n}\r\nint transport_set_vpd_assoc(struct t10_vpd *vpd, unsigned char *page_83)\r\n{\r\nvpd->association = (page_83[1] & 0x30);\r\nreturn transport_dump_vpd_assoc(vpd, NULL, 0);\r\n}\r\nint transport_dump_vpd_ident_type(\r\nstruct t10_vpd *vpd,\r\nunsigned char *p_buf,\r\nint p_buf_len)\r\n{\r\nunsigned char buf[VPD_TMP_BUF_SIZE];\r\nint ret = 0;\r\nint len;\r\nmemset(buf, 0, VPD_TMP_BUF_SIZE);\r\nlen = sprintf(buf, "T10 VPD Identifier Type: ");\r\nswitch (vpd->device_identifier_type) {\r\ncase 0x00:\r\nsprintf(buf+len, "Vendor specific\n");\r\nbreak;\r\ncase 0x01:\r\nsprintf(buf+len, "T10 Vendor ID based\n");\r\nbreak;\r\ncase 0x02:\r\nsprintf(buf+len, "EUI-64 based\n");\r\nbreak;\r\ncase 0x03:\r\nsprintf(buf+len, "NAA\n");\r\nbreak;\r\ncase 0x04:\r\nsprintf(buf+len, "Relative target port identifier\n");\r\nbreak;\r\ncase 0x08:\r\nsprintf(buf+len, "SCSI name string\n");\r\nbreak;\r\ndefault:\r\nsprintf(buf+len, "Unsupported: 0x%02x\n",\r\nvpd->device_identifier_type);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (p_buf) {\r\nif (p_buf_len < strlen(buf)+1)\r\nreturn -EINVAL;\r\nstrncpy(p_buf, buf, p_buf_len);\r\n} else {\r\npr_debug("%s", buf);\r\n}\r\nreturn ret;\r\n}\r\nint transport_set_vpd_ident_type(struct t10_vpd *vpd, unsigned char *page_83)\r\n{\r\nvpd->device_identifier_type = (page_83[1] & 0x0f);\r\nreturn transport_dump_vpd_ident_type(vpd, NULL, 0);\r\n}\r\nint transport_dump_vpd_ident(\r\nstruct t10_vpd *vpd,\r\nunsigned char *p_buf,\r\nint p_buf_len)\r\n{\r\nunsigned char buf[VPD_TMP_BUF_SIZE];\r\nint ret = 0;\r\nmemset(buf, 0, VPD_TMP_BUF_SIZE);\r\nswitch (vpd->device_identifier_code_set) {\r\ncase 0x01:\r\nsnprintf(buf, sizeof(buf),\r\n"T10 VPD Binary Device Identifier: %s\n",\r\n&vpd->device_identifier[0]);\r\nbreak;\r\ncase 0x02:\r\nsnprintf(buf, sizeof(buf),\r\n"T10 VPD ASCII Device Identifier: %s\n",\r\n&vpd->device_identifier[0]);\r\nbreak;\r\ncase 0x03:\r\nsnprintf(buf, sizeof(buf),\r\n"T10 VPD UTF-8 Device Identifier: %s\n",\r\n&vpd->device_identifier[0]);\r\nbreak;\r\ndefault:\r\nsprintf(buf, "T10 VPD Device Identifier encoding unsupported:"\r\n" 0x%02x", vpd->device_identifier_code_set);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (p_buf)\r\nstrncpy(p_buf, buf, p_buf_len);\r\nelse\r\npr_debug("%s", buf);\r\nreturn ret;\r\n}\r\nint\r\ntransport_set_vpd_ident(struct t10_vpd *vpd, unsigned char *page_83)\r\n{\r\nstatic const char hex_str[] = "0123456789abcdef";\r\nint j = 0, i = 4;\r\nvpd->device_identifier_code_set = (page_83[0] & 0x0f);\r\nswitch (vpd->device_identifier_code_set) {\r\ncase 0x01:\r\nvpd->device_identifier[j++] =\r\nhex_str[vpd->device_identifier_type];\r\nwhile (i < (4 + page_83[3])) {\r\nvpd->device_identifier[j++] =\r\nhex_str[(page_83[i] & 0xf0) >> 4];\r\nvpd->device_identifier[j++] =\r\nhex_str[page_83[i] & 0x0f];\r\ni++;\r\n}\r\nbreak;\r\ncase 0x02:\r\ncase 0x03:\r\nwhile (i < (4 + page_83[3]))\r\nvpd->device_identifier[j++] = page_83[i++];\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn transport_dump_vpd_ident(vpd, NULL, 0);\r\n}\r\nstatic sense_reason_t\r\ntarget_check_max_data_sg_nents(struct se_cmd *cmd, struct se_device *dev,\r\nunsigned int size)\r\n{\r\nu32 mtl;\r\nif (!cmd->se_tfo->max_data_sg_nents)\r\nreturn TCM_NO_SENSE;\r\nmtl = (cmd->se_tfo->max_data_sg_nents * PAGE_SIZE);\r\nif (cmd->data_length > mtl) {\r\nif (cmd->se_cmd_flags & SCF_OVERFLOW_BIT) {\r\ncmd->residual_count = (size - mtl);\r\n} else if (cmd->se_cmd_flags & SCF_UNDERFLOW_BIT) {\r\nu32 orig_dl = size + cmd->residual_count;\r\ncmd->residual_count = (orig_dl - mtl);\r\n} else {\r\ncmd->se_cmd_flags |= SCF_UNDERFLOW_BIT;\r\ncmd->residual_count = (cmd->data_length - mtl);\r\n}\r\ncmd->data_length = mtl;\r\nif (cmd->prot_length) {\r\nu32 sectors = (mtl / dev->dev_attrib.block_size);\r\ncmd->prot_length = dev->prot_length * sectors;\r\n}\r\n}\r\nreturn TCM_NO_SENSE;\r\n}\r\nsense_reason_t\r\ntarget_cmd_size_check(struct se_cmd *cmd, unsigned int size)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nif (cmd->unknown_data_length) {\r\ncmd->data_length = size;\r\n} else if (size != cmd->data_length) {\r\npr_warn_ratelimited("TARGET_CORE[%s]: Expected Transfer Length:"\r\n" %u does not match SCSI CDB Length: %u for SAM Opcode:"\r\n" 0x%02x\n", cmd->se_tfo->get_fabric_name(),\r\ncmd->data_length, size, cmd->t_task_cdb[0]);\r\nif (cmd->data_direction == DMA_TO_DEVICE) {\r\nif (cmd->se_cmd_flags & SCF_SCSI_DATA_CDB) {\r\npr_err_ratelimited("Rejecting underflow/overflow"\r\n" for WRITE data CDB\n");\r\nreturn TCM_INVALID_CDB_FIELD;\r\n}\r\nif (size > cmd->data_length) {\r\npr_err_ratelimited("Rejecting overflow for"\r\n" WRITE control CDB\n");\r\nreturn TCM_INVALID_CDB_FIELD;\r\n}\r\n}\r\nif (dev->dev_attrib.block_size != 512) {\r\npr_err("Failing OVERFLOW/UNDERFLOW for LBA op"\r\n" CDB on non 512-byte sector setup subsystem"\r\n" plugin: %s\n", dev->transport->name);\r\nreturn TCM_INVALID_CDB_FIELD;\r\n}\r\nif (size > cmd->data_length) {\r\ncmd->se_cmd_flags |= SCF_OVERFLOW_BIT;\r\ncmd->residual_count = (size - cmd->data_length);\r\n} else {\r\ncmd->se_cmd_flags |= SCF_UNDERFLOW_BIT;\r\ncmd->residual_count = (cmd->data_length - size);\r\ncmd->data_length = size;\r\n}\r\n}\r\nreturn target_check_max_data_sg_nents(cmd, dev, size);\r\n}\r\nvoid transport_init_se_cmd(\r\nstruct se_cmd *cmd,\r\nconst struct target_core_fabric_ops *tfo,\r\nstruct se_session *se_sess,\r\nu32 data_length,\r\nint data_direction,\r\nint task_attr,\r\nunsigned char *sense_buffer)\r\n{\r\nINIT_LIST_HEAD(&cmd->se_delayed_node);\r\nINIT_LIST_HEAD(&cmd->se_qf_node);\r\nINIT_LIST_HEAD(&cmd->se_cmd_list);\r\nINIT_LIST_HEAD(&cmd->state_list);\r\ninit_completion(&cmd->t_transport_stop_comp);\r\ninit_completion(&cmd->cmd_wait_comp);\r\nspin_lock_init(&cmd->t_state_lock);\r\nINIT_WORK(&cmd->work, NULL);\r\nkref_init(&cmd->cmd_kref);\r\ncmd->se_tfo = tfo;\r\ncmd->se_sess = se_sess;\r\ncmd->data_length = data_length;\r\ncmd->data_direction = data_direction;\r\ncmd->sam_task_attr = task_attr;\r\ncmd->sense_buffer = sense_buffer;\r\ncmd->state_active = false;\r\n}\r\nstatic sense_reason_t\r\ntransport_check_alloc_task_attr(struct se_cmd *cmd)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nif (dev->transport->transport_flags & TRANSPORT_FLAG_PASSTHROUGH)\r\nreturn 0;\r\nif (cmd->sam_task_attr == TCM_ACA_TAG) {\r\npr_debug("SAM Task Attribute ACA"\r\n" emulation is not supported\n");\r\nreturn TCM_INVALID_CDB_FIELD;\r\n}\r\nreturn 0;\r\n}\r\nsense_reason_t\r\ntarget_setup_cmd_from_cdb(struct se_cmd *cmd, unsigned char *cdb)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nsense_reason_t ret;\r\nif (scsi_command_size(cdb) > SCSI_MAX_VARLEN_CDB_SIZE) {\r\npr_err("Received SCSI CDB with command_size: %d that"\r\n" exceeds SCSI_MAX_VARLEN_CDB_SIZE: %d\n",\r\nscsi_command_size(cdb), SCSI_MAX_VARLEN_CDB_SIZE);\r\nreturn TCM_INVALID_CDB_FIELD;\r\n}\r\nif (scsi_command_size(cdb) > sizeof(cmd->__t_task_cdb)) {\r\ncmd->t_task_cdb = kzalloc(scsi_command_size(cdb),\r\nGFP_KERNEL);\r\nif (!cmd->t_task_cdb) {\r\npr_err("Unable to allocate cmd->t_task_cdb"\r\n" %u > sizeof(cmd->__t_task_cdb): %lu ops\n",\r\nscsi_command_size(cdb),\r\n(unsigned long)sizeof(cmd->__t_task_cdb));\r\nreturn TCM_OUT_OF_RESOURCES;\r\n}\r\n} else\r\ncmd->t_task_cdb = &cmd->__t_task_cdb[0];\r\nmemcpy(cmd->t_task_cdb, cdb, scsi_command_size(cdb));\r\ntrace_target_sequencer_start(cmd);\r\nret = dev->transport->parse_cdb(cmd);\r\nif (ret == TCM_UNSUPPORTED_SCSI_OPCODE)\r\npr_warn_ratelimited("%s/%s: Unsupported SCSI Opcode 0x%02x, sending CHECK_CONDITION.\n",\r\ncmd->se_tfo->get_fabric_name(),\r\ncmd->se_sess->se_node_acl->initiatorname,\r\ncmd->t_task_cdb[0]);\r\nif (ret)\r\nreturn ret;\r\nret = transport_check_alloc_task_attr(cmd);\r\nif (ret)\r\nreturn ret;\r\ncmd->se_cmd_flags |= SCF_SUPPORTED_SAM_OPCODE;\r\natomic_long_inc(&cmd->se_lun->lun_stats.cmd_pdus);\r\nreturn 0;\r\n}\r\nint transport_handle_cdb_direct(\r\nstruct se_cmd *cmd)\r\n{\r\nsense_reason_t ret;\r\nif (!cmd->se_lun) {\r\ndump_stack();\r\npr_err("cmd->se_lun is NULL\n");\r\nreturn -EINVAL;\r\n}\r\nif (in_interrupt()) {\r\ndump_stack();\r\npr_err("transport_generic_handle_cdb cannot be called"\r\n" from interrupt context\n");\r\nreturn -EINVAL;\r\n}\r\ncmd->t_state = TRANSPORT_NEW_CMD;\r\ncmd->transport_state |= CMD_T_ACTIVE;\r\nret = transport_generic_new_cmd(cmd);\r\nif (ret)\r\ntransport_generic_request_failure(cmd, ret);\r\nreturn 0;\r\n}\r\nsense_reason_t\r\ntransport_generic_map_mem_to_cmd(struct se_cmd *cmd, struct scatterlist *sgl,\r\nu32 sgl_count, struct scatterlist *sgl_bidi, u32 sgl_bidi_count)\r\n{\r\nif (!sgl || !sgl_count)\r\nreturn 0;\r\nif (cmd->se_cmd_flags & SCF_OVERFLOW_BIT) {\r\npr_warn("Rejecting SCSI DATA overflow for fabric using"\r\n" SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC\n");\r\nreturn TCM_INVALID_CDB_FIELD;\r\n}\r\ncmd->t_data_sg = sgl;\r\ncmd->t_data_nents = sgl_count;\r\ncmd->t_bidi_data_sg = sgl_bidi;\r\ncmd->t_bidi_data_nents = sgl_bidi_count;\r\ncmd->se_cmd_flags |= SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC;\r\nreturn 0;\r\n}\r\nint target_submit_cmd_map_sgls(struct se_cmd *se_cmd, struct se_session *se_sess,\r\nunsigned char *cdb, unsigned char *sense, u64 unpacked_lun,\r\nu32 data_length, int task_attr, int data_dir, int flags,\r\nstruct scatterlist *sgl, u32 sgl_count,\r\nstruct scatterlist *sgl_bidi, u32 sgl_bidi_count,\r\nstruct scatterlist *sgl_prot, u32 sgl_prot_count)\r\n{\r\nstruct se_portal_group *se_tpg;\r\nsense_reason_t rc;\r\nint ret;\r\nse_tpg = se_sess->se_tpg;\r\nBUG_ON(!se_tpg);\r\nBUG_ON(se_cmd->se_tfo || se_cmd->se_sess);\r\nBUG_ON(in_interrupt());\r\ntransport_init_se_cmd(se_cmd, se_tpg->se_tpg_tfo, se_sess,\r\ndata_length, data_dir, task_attr, sense);\r\nif (flags & TARGET_SCF_USE_CPUID)\r\nse_cmd->se_cmd_flags |= SCF_USE_CPUID;\r\nelse\r\nse_cmd->cpuid = WORK_CPU_UNBOUND;\r\nif (flags & TARGET_SCF_UNKNOWN_SIZE)\r\nse_cmd->unknown_data_length = 1;\r\nret = target_get_sess_cmd(se_cmd, flags & TARGET_SCF_ACK_KREF);\r\nif (ret)\r\nreturn ret;\r\nif (flags & TARGET_SCF_BIDI_OP)\r\nse_cmd->se_cmd_flags |= SCF_BIDI;\r\nrc = transport_lookup_cmd_lun(se_cmd, unpacked_lun);\r\nif (rc) {\r\ntransport_send_check_condition_and_sense(se_cmd, rc, 0);\r\ntarget_put_sess_cmd(se_cmd);\r\nreturn 0;\r\n}\r\nrc = target_setup_cmd_from_cdb(se_cmd, cdb);\r\nif (rc != 0) {\r\ntransport_generic_request_failure(se_cmd, rc);\r\nreturn 0;\r\n}\r\nif (sgl_prot_count) {\r\nse_cmd->t_prot_sg = sgl_prot;\r\nse_cmd->t_prot_nents = sgl_prot_count;\r\nse_cmd->se_cmd_flags |= SCF_PASSTHROUGH_PROT_SG_TO_MEM_NOALLOC;\r\n}\r\nif (sgl_count != 0) {\r\nBUG_ON(!sgl);\r\nif (!(se_cmd->se_cmd_flags & SCF_SCSI_DATA_CDB) &&\r\nse_cmd->data_direction == DMA_FROM_DEVICE) {\r\nunsigned char *buf = NULL;\r\nif (sgl)\r\nbuf = kmap(sg_page(sgl)) + sgl->offset;\r\nif (buf) {\r\nmemset(buf, 0, sgl->length);\r\nkunmap(sg_page(sgl));\r\n}\r\n}\r\nrc = transport_generic_map_mem_to_cmd(se_cmd, sgl, sgl_count,\r\nsgl_bidi, sgl_bidi_count);\r\nif (rc != 0) {\r\ntransport_generic_request_failure(se_cmd, rc);\r\nreturn 0;\r\n}\r\n}\r\ncore_alua_check_nonop_delay(se_cmd);\r\ntransport_handle_cdb_direct(se_cmd);\r\nreturn 0;\r\n}\r\nint target_submit_cmd(struct se_cmd *se_cmd, struct se_session *se_sess,\r\nunsigned char *cdb, unsigned char *sense, u64 unpacked_lun,\r\nu32 data_length, int task_attr, int data_dir, int flags)\r\n{\r\nreturn target_submit_cmd_map_sgls(se_cmd, se_sess, cdb, sense,\r\nunpacked_lun, data_length, task_attr, data_dir,\r\nflags, NULL, 0, NULL, 0, NULL, 0);\r\n}\r\nstatic void target_complete_tmr_failure(struct work_struct *work)\r\n{\r\nstruct se_cmd *se_cmd = container_of(work, struct se_cmd, work);\r\nse_cmd->se_tmr_req->response = TMR_LUN_DOES_NOT_EXIST;\r\nse_cmd->se_tfo->queue_tm_rsp(se_cmd);\r\ntransport_lun_remove_cmd(se_cmd);\r\ntransport_cmd_check_stop_to_fabric(se_cmd);\r\n}\r\nstatic bool target_lookup_lun_from_tag(struct se_session *se_sess, u64 tag,\r\nu64 *unpacked_lun)\r\n{\r\nstruct se_cmd *se_cmd;\r\nunsigned long flags;\r\nbool ret = false;\r\nspin_lock_irqsave(&se_sess->sess_cmd_lock, flags);\r\nlist_for_each_entry(se_cmd, &se_sess->sess_cmd_list, se_cmd_list) {\r\nif (se_cmd->se_cmd_flags & SCF_SCSI_TMR_CDB)\r\ncontinue;\r\nif (se_cmd->tag == tag) {\r\n*unpacked_lun = se_cmd->orig_fe_lun;\r\nret = true;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&se_sess->sess_cmd_lock, flags);\r\nreturn ret;\r\n}\r\nint target_submit_tmr(struct se_cmd *se_cmd, struct se_session *se_sess,\r\nunsigned char *sense, u64 unpacked_lun,\r\nvoid *fabric_tmr_ptr, unsigned char tm_type,\r\ngfp_t gfp, u64 tag, int flags)\r\n{\r\nstruct se_portal_group *se_tpg;\r\nint ret;\r\nse_tpg = se_sess->se_tpg;\r\nBUG_ON(!se_tpg);\r\ntransport_init_se_cmd(se_cmd, se_tpg->se_tpg_tfo, se_sess,\r\n0, DMA_NONE, TCM_SIMPLE_TAG, sense);\r\nret = core_tmr_alloc_req(se_cmd, fabric_tmr_ptr, tm_type, gfp);\r\nif (ret < 0)\r\nreturn -ENOMEM;\r\nif (tm_type == TMR_ABORT_TASK)\r\nse_cmd->se_tmr_req->ref_task_tag = tag;\r\nret = target_get_sess_cmd(se_cmd, flags & TARGET_SCF_ACK_KREF);\r\nif (ret) {\r\ncore_tmr_release_req(se_cmd->se_tmr_req);\r\nreturn ret;\r\n}\r\nif (tm_type == TMR_ABORT_TASK && (flags & TARGET_SCF_LOOKUP_LUN_FROM_TAG)) {\r\nif (!target_lookup_lun_from_tag(se_sess, tag, &unpacked_lun))\r\ngoto failure;\r\n}\r\nret = transport_lookup_tmr_lun(se_cmd, unpacked_lun);\r\nif (ret)\r\ngoto failure;\r\ntransport_generic_handle_tmr(se_cmd);\r\nreturn 0;\r\nfailure:\r\nINIT_WORK(&se_cmd->work, target_complete_tmr_failure);\r\nschedule_work(&se_cmd->work);\r\nreturn 0;\r\n}\r\nvoid transport_generic_request_failure(struct se_cmd *cmd,\r\nsense_reason_t sense_reason)\r\n{\r\nint ret = 0, post_ret = 0;\r\nif (transport_check_aborted_status(cmd, 1))\r\nreturn;\r\npr_debug("-----[ Storage Engine Exception; sense_reason %d\n",\r\nsense_reason);\r\ntarget_show_cmd("-----[ ", cmd);\r\ntransport_complete_task_attr(cmd);\r\nif ((cmd->se_cmd_flags & SCF_COMPARE_AND_WRITE) &&\r\ncmd->transport_complete_callback)\r\ncmd->transport_complete_callback(cmd, false, &post_ret);\r\nswitch (sense_reason) {\r\ncase TCM_NON_EXISTENT_LUN:\r\ncase TCM_UNSUPPORTED_SCSI_OPCODE:\r\ncase TCM_INVALID_CDB_FIELD:\r\ncase TCM_INVALID_PARAMETER_LIST:\r\ncase TCM_PARAMETER_LIST_LENGTH_ERROR:\r\ncase TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE:\r\ncase TCM_UNKNOWN_MODE_PAGE:\r\ncase TCM_WRITE_PROTECTED:\r\ncase TCM_ADDRESS_OUT_OF_RANGE:\r\ncase TCM_CHECK_CONDITION_ABORT_CMD:\r\ncase TCM_CHECK_CONDITION_UNIT_ATTENTION:\r\ncase TCM_CHECK_CONDITION_NOT_READY:\r\ncase TCM_LOGICAL_BLOCK_GUARD_CHECK_FAILED:\r\ncase TCM_LOGICAL_BLOCK_APP_TAG_CHECK_FAILED:\r\ncase TCM_LOGICAL_BLOCK_REF_TAG_CHECK_FAILED:\r\ncase TCM_COPY_TARGET_DEVICE_NOT_REACHABLE:\r\ncase TCM_TOO_MANY_TARGET_DESCS:\r\ncase TCM_UNSUPPORTED_TARGET_DESC_TYPE_CODE:\r\ncase TCM_TOO_MANY_SEGMENT_DESCS:\r\ncase TCM_UNSUPPORTED_SEGMENT_DESC_TYPE_CODE:\r\nbreak;\r\ncase TCM_OUT_OF_RESOURCES:\r\nsense_reason = TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\nbreak;\r\ncase TCM_RESERVATION_CONFLICT:\r\ncmd->scsi_status = SAM_STAT_RESERVATION_CONFLICT;\r\nif (cmd->se_sess &&\r\ncmd->se_dev->dev_attrib.emulate_ua_intlck_ctrl == 2) {\r\ntarget_ua_allocate_lun(cmd->se_sess->se_node_acl,\r\ncmd->orig_fe_lun, 0x2C,\r\nASCQ_2CH_PREVIOUS_RESERVATION_CONFLICT_STATUS);\r\n}\r\ntrace_target_cmd_complete(cmd);\r\nret = cmd->se_tfo->queue_status(cmd);\r\nif (ret)\r\ngoto queue_full;\r\ngoto check_stop;\r\ndefault:\r\npr_err("Unknown transport error for CDB 0x%02x: %d\n",\r\ncmd->t_task_cdb[0], sense_reason);\r\nsense_reason = TCM_UNSUPPORTED_SCSI_OPCODE;\r\nbreak;\r\n}\r\nret = transport_send_check_condition_and_sense(cmd, sense_reason, 0);\r\nif (ret)\r\ngoto queue_full;\r\ncheck_stop:\r\ntransport_lun_remove_cmd(cmd);\r\ntransport_cmd_check_stop_to_fabric(cmd);\r\nreturn;\r\nqueue_full:\r\ntransport_handle_queue_full(cmd, cmd->se_dev, ret, false);\r\n}\r\nvoid __target_execute_cmd(struct se_cmd *cmd, bool do_checks)\r\n{\r\nsense_reason_t ret;\r\nif (!cmd->execute_cmd) {\r\nret = TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\ngoto err;\r\n}\r\nif (do_checks) {\r\nret = target_scsi3_ua_check(cmd);\r\nif (ret)\r\ngoto err;\r\nret = target_alua_state_check(cmd);\r\nif (ret)\r\ngoto err;\r\nret = target_check_reservation(cmd);\r\nif (ret) {\r\ncmd->scsi_status = SAM_STAT_RESERVATION_CONFLICT;\r\ngoto err;\r\n}\r\n}\r\nret = cmd->execute_cmd(cmd);\r\nif (!ret)\r\nreturn;\r\nerr:\r\nspin_lock_irq(&cmd->t_state_lock);\r\ncmd->transport_state &= ~CMD_T_SENT;\r\nspin_unlock_irq(&cmd->t_state_lock);\r\ntransport_generic_request_failure(cmd, ret);\r\n}\r\nstatic int target_write_prot_action(struct se_cmd *cmd)\r\n{\r\nu32 sectors;\r\nswitch (cmd->prot_op) {\r\ncase TARGET_PROT_DOUT_INSERT:\r\nif (!(cmd->se_sess->sup_prot_ops & TARGET_PROT_DOUT_INSERT))\r\nsbc_dif_generate(cmd);\r\nbreak;\r\ncase TARGET_PROT_DOUT_STRIP:\r\nif (cmd->se_sess->sup_prot_ops & TARGET_PROT_DOUT_STRIP)\r\nbreak;\r\nsectors = cmd->data_length >> ilog2(cmd->se_dev->dev_attrib.block_size);\r\ncmd->pi_err = sbc_dif_verify(cmd, cmd->t_task_lba,\r\nsectors, 0, cmd->t_prot_sg, 0);\r\nif (unlikely(cmd->pi_err)) {\r\nspin_lock_irq(&cmd->t_state_lock);\r\ncmd->transport_state &= ~CMD_T_SENT;\r\nspin_unlock_irq(&cmd->t_state_lock);\r\ntransport_generic_request_failure(cmd, cmd->pi_err);\r\nreturn -1;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool target_handle_task_attr(struct se_cmd *cmd)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nif (dev->transport->transport_flags & TRANSPORT_FLAG_PASSTHROUGH)\r\nreturn false;\r\ncmd->se_cmd_flags |= SCF_TASK_ATTR_SET;\r\nswitch (cmd->sam_task_attr) {\r\ncase TCM_HEAD_TAG:\r\npr_debug("Added HEAD_OF_QUEUE for CDB: 0x%02x\n",\r\ncmd->t_task_cdb[0]);\r\nreturn false;\r\ncase TCM_ORDERED_TAG:\r\natomic_inc_mb(&dev->dev_ordered_sync);\r\npr_debug("Added ORDERED for CDB: 0x%02x to ordered list\n",\r\ncmd->t_task_cdb[0]);\r\nif (!atomic_read(&dev->simple_cmds))\r\nreturn false;\r\nbreak;\r\ndefault:\r\natomic_inc_mb(&dev->simple_cmds);\r\nbreak;\r\n}\r\nif (atomic_read(&dev->dev_ordered_sync) == 0)\r\nreturn false;\r\nspin_lock(&dev->delayed_cmd_lock);\r\nlist_add_tail(&cmd->se_delayed_node, &dev->delayed_cmd_list);\r\nspin_unlock(&dev->delayed_cmd_lock);\r\npr_debug("Added CDB: 0x%02x Task Attr: 0x%02x to delayed CMD listn",\r\ncmd->t_task_cdb[0], cmd->sam_task_attr);\r\nreturn true;\r\n}\r\nvoid target_execute_cmd(struct se_cmd *cmd)\r\n{\r\nspin_lock_irq(&cmd->t_state_lock);\r\nif (__transport_check_aborted_status(cmd, 1)) {\r\nspin_unlock_irq(&cmd->t_state_lock);\r\nreturn;\r\n}\r\nif (cmd->transport_state & CMD_T_STOP) {\r\npr_debug("%s:%d CMD_T_STOP for ITT: 0x%08llx\n",\r\n__func__, __LINE__, cmd->tag);\r\nspin_unlock_irq(&cmd->t_state_lock);\r\ncomplete_all(&cmd->t_transport_stop_comp);\r\nreturn;\r\n}\r\ncmd->t_state = TRANSPORT_PROCESSING;\r\ncmd->transport_state |= CMD_T_ACTIVE | CMD_T_SENT;\r\nspin_unlock_irq(&cmd->t_state_lock);\r\nif (target_write_prot_action(cmd))\r\nreturn;\r\nif (target_handle_task_attr(cmd)) {\r\nspin_lock_irq(&cmd->t_state_lock);\r\ncmd->transport_state &= ~CMD_T_SENT;\r\nspin_unlock_irq(&cmd->t_state_lock);\r\nreturn;\r\n}\r\n__target_execute_cmd(cmd, true);\r\n}\r\nstatic void target_restart_delayed_cmds(struct se_device *dev)\r\n{\r\nfor (;;) {\r\nstruct se_cmd *cmd;\r\nspin_lock(&dev->delayed_cmd_lock);\r\nif (list_empty(&dev->delayed_cmd_list)) {\r\nspin_unlock(&dev->delayed_cmd_lock);\r\nbreak;\r\n}\r\ncmd = list_entry(dev->delayed_cmd_list.next,\r\nstruct se_cmd, se_delayed_node);\r\nlist_del(&cmd->se_delayed_node);\r\nspin_unlock(&dev->delayed_cmd_lock);\r\n__target_execute_cmd(cmd, true);\r\nif (cmd->sam_task_attr == TCM_ORDERED_TAG)\r\nbreak;\r\n}\r\n}\r\nstatic void transport_complete_task_attr(struct se_cmd *cmd)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nif (dev->transport->transport_flags & TRANSPORT_FLAG_PASSTHROUGH)\r\nreturn;\r\nif (!(cmd->se_cmd_flags & SCF_TASK_ATTR_SET))\r\ngoto restart;\r\nif (cmd->sam_task_attr == TCM_SIMPLE_TAG) {\r\natomic_dec_mb(&dev->simple_cmds);\r\ndev->dev_cur_ordered_id++;\r\n} else if (cmd->sam_task_attr == TCM_HEAD_TAG) {\r\ndev->dev_cur_ordered_id++;\r\npr_debug("Incremented dev_cur_ordered_id: %u for HEAD_OF_QUEUE\n",\r\ndev->dev_cur_ordered_id);\r\n} else if (cmd->sam_task_attr == TCM_ORDERED_TAG) {\r\natomic_dec_mb(&dev->dev_ordered_sync);\r\ndev->dev_cur_ordered_id++;\r\npr_debug("Incremented dev_cur_ordered_id: %u for ORDERED\n",\r\ndev->dev_cur_ordered_id);\r\n}\r\nrestart:\r\ntarget_restart_delayed_cmds(dev);\r\n}\r\nstatic void transport_complete_qf(struct se_cmd *cmd)\r\n{\r\nint ret = 0;\r\ntransport_complete_task_attr(cmd);\r\nif (cmd->t_state == TRANSPORT_COMPLETE_QF_ERR) {\r\nif (cmd->scsi_status)\r\ngoto queue_status;\r\ncmd->se_cmd_flags |= SCF_EMULATED_TASK_SENSE;\r\ncmd->scsi_status = SAM_STAT_CHECK_CONDITION;\r\ncmd->scsi_sense_length = TRANSPORT_SENSE_BUFFER;\r\ntranslate_sense_reason(cmd, TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE);\r\ngoto queue_status;\r\n}\r\nif (cmd->se_cmd_flags & SCF_TRANSPORT_TASK_SENSE)\r\ngoto queue_status;\r\nswitch (cmd->data_direction) {\r\ncase DMA_FROM_DEVICE:\r\nif (cmd->scsi_status)\r\ngoto queue_status;\r\ntrace_target_cmd_complete(cmd);\r\nret = cmd->se_tfo->queue_data_in(cmd);\r\nbreak;\r\ncase DMA_TO_DEVICE:\r\nif (cmd->se_cmd_flags & SCF_BIDI) {\r\nret = cmd->se_tfo->queue_data_in(cmd);\r\nbreak;\r\n}\r\ncase DMA_NONE:\r\nqueue_status:\r\ntrace_target_cmd_complete(cmd);\r\nret = cmd->se_tfo->queue_status(cmd);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (ret < 0) {\r\ntransport_handle_queue_full(cmd, cmd->se_dev, ret, false);\r\nreturn;\r\n}\r\ntransport_lun_remove_cmd(cmd);\r\ntransport_cmd_check_stop_to_fabric(cmd);\r\n}\r\nstatic void transport_handle_queue_full(struct se_cmd *cmd, struct se_device *dev,\r\nint err, bool write_pending)\r\n{\r\nif (err == -EAGAIN || err == -ENOMEM) {\r\ncmd->t_state = (write_pending) ? TRANSPORT_COMPLETE_QF_WP :\r\nTRANSPORT_COMPLETE_QF_OK;\r\n} else {\r\npr_warn_ratelimited("Got unknown fabric queue status: %d\n", err);\r\ncmd->t_state = TRANSPORT_COMPLETE_QF_ERR;\r\n}\r\nspin_lock_irq(&dev->qf_cmd_lock);\r\nlist_add_tail(&cmd->se_qf_node, &cmd->se_dev->qf_cmd_list);\r\natomic_inc_mb(&dev->dev_qf_count);\r\nspin_unlock_irq(&cmd->se_dev->qf_cmd_lock);\r\nschedule_work(&cmd->se_dev->qf_work_queue);\r\n}\r\nstatic bool target_read_prot_action(struct se_cmd *cmd)\r\n{\r\nswitch (cmd->prot_op) {\r\ncase TARGET_PROT_DIN_STRIP:\r\nif (!(cmd->se_sess->sup_prot_ops & TARGET_PROT_DIN_STRIP)) {\r\nu32 sectors = cmd->data_length >>\r\nilog2(cmd->se_dev->dev_attrib.block_size);\r\ncmd->pi_err = sbc_dif_verify(cmd, cmd->t_task_lba,\r\nsectors, 0, cmd->t_prot_sg,\r\n0);\r\nif (cmd->pi_err)\r\nreturn true;\r\n}\r\nbreak;\r\ncase TARGET_PROT_DIN_INSERT:\r\nif (cmd->se_sess->sup_prot_ops & TARGET_PROT_DIN_INSERT)\r\nbreak;\r\nsbc_dif_generate(cmd);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn false;\r\n}\r\nstatic void target_complete_ok_work(struct work_struct *work)\r\n{\r\nstruct se_cmd *cmd = container_of(work, struct se_cmd, work);\r\nint ret;\r\ntransport_complete_task_attr(cmd);\r\nif (atomic_read(&cmd->se_dev->dev_qf_count) != 0)\r\nschedule_work(&cmd->se_dev->qf_work_queue);\r\nif (cmd->se_cmd_flags & SCF_TRANSPORT_TASK_SENSE) {\r\nWARN_ON(!cmd->scsi_status);\r\nret = transport_send_check_condition_and_sense(\r\ncmd, 0, 1);\r\nif (ret)\r\ngoto queue_full;\r\ntransport_lun_remove_cmd(cmd);\r\ntransport_cmd_check_stop_to_fabric(cmd);\r\nreturn;\r\n}\r\nif (cmd->transport_complete_callback) {\r\nsense_reason_t rc;\r\nbool caw = (cmd->se_cmd_flags & SCF_COMPARE_AND_WRITE);\r\nbool zero_dl = !(cmd->data_length);\r\nint post_ret = 0;\r\nrc = cmd->transport_complete_callback(cmd, true, &post_ret);\r\nif (!rc && !post_ret) {\r\nif (caw && zero_dl)\r\ngoto queue_rsp;\r\nreturn;\r\n} else if (rc) {\r\nret = transport_send_check_condition_and_sense(cmd,\r\nrc, 0);\r\nif (ret)\r\ngoto queue_full;\r\ntransport_lun_remove_cmd(cmd);\r\ntransport_cmd_check_stop_to_fabric(cmd);\r\nreturn;\r\n}\r\n}\r\nqueue_rsp:\r\nswitch (cmd->data_direction) {\r\ncase DMA_FROM_DEVICE:\r\nif (cmd->scsi_status)\r\ngoto queue_status;\r\natomic_long_add(cmd->data_length,\r\n&cmd->se_lun->lun_stats.tx_data_octets);\r\nif (target_read_prot_action(cmd)) {\r\nret = transport_send_check_condition_and_sense(cmd,\r\ncmd->pi_err, 0);\r\nif (ret)\r\ngoto queue_full;\r\ntransport_lun_remove_cmd(cmd);\r\ntransport_cmd_check_stop_to_fabric(cmd);\r\nreturn;\r\n}\r\ntrace_target_cmd_complete(cmd);\r\nret = cmd->se_tfo->queue_data_in(cmd);\r\nif (ret)\r\ngoto queue_full;\r\nbreak;\r\ncase DMA_TO_DEVICE:\r\natomic_long_add(cmd->data_length,\r\n&cmd->se_lun->lun_stats.rx_data_octets);\r\nif (cmd->se_cmd_flags & SCF_BIDI) {\r\natomic_long_add(cmd->data_length,\r\n&cmd->se_lun->lun_stats.tx_data_octets);\r\nret = cmd->se_tfo->queue_data_in(cmd);\r\nif (ret)\r\ngoto queue_full;\r\nbreak;\r\n}\r\ncase DMA_NONE:\r\nqueue_status:\r\ntrace_target_cmd_complete(cmd);\r\nret = cmd->se_tfo->queue_status(cmd);\r\nif (ret)\r\ngoto queue_full;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ntransport_lun_remove_cmd(cmd);\r\ntransport_cmd_check_stop_to_fabric(cmd);\r\nreturn;\r\nqueue_full:\r\npr_debug("Handling complete_ok QUEUE_FULL: se_cmd: %p,"\r\n" data_direction: %d\n", cmd, cmd->data_direction);\r\ntransport_handle_queue_full(cmd, cmd->se_dev, ret, false);\r\n}\r\nvoid target_free_sgl(struct scatterlist *sgl, int nents)\r\n{\r\nstruct scatterlist *sg;\r\nint count;\r\nfor_each_sg(sgl, sg, nents, count)\r\n__free_page(sg_page(sg));\r\nkfree(sgl);\r\n}\r\nstatic inline void transport_reset_sgl_orig(struct se_cmd *cmd)\r\n{\r\nif (!cmd->t_data_sg_orig)\r\nreturn;\r\nkfree(cmd->t_data_sg);\r\ncmd->t_data_sg = cmd->t_data_sg_orig;\r\ncmd->t_data_sg_orig = NULL;\r\ncmd->t_data_nents = cmd->t_data_nents_orig;\r\ncmd->t_data_nents_orig = 0;\r\n}\r\nstatic inline void transport_free_pages(struct se_cmd *cmd)\r\n{\r\nif (!(cmd->se_cmd_flags & SCF_PASSTHROUGH_PROT_SG_TO_MEM_NOALLOC)) {\r\ntarget_free_sgl(cmd->t_prot_sg, cmd->t_prot_nents);\r\ncmd->t_prot_sg = NULL;\r\ncmd->t_prot_nents = 0;\r\n}\r\nif (cmd->se_cmd_flags & SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC) {\r\nif (cmd->se_cmd_flags & SCF_COMPARE_AND_WRITE) {\r\ntarget_free_sgl(cmd->t_bidi_data_sg,\r\ncmd->t_bidi_data_nents);\r\ncmd->t_bidi_data_sg = NULL;\r\ncmd->t_bidi_data_nents = 0;\r\n}\r\ntransport_reset_sgl_orig(cmd);\r\nreturn;\r\n}\r\ntransport_reset_sgl_orig(cmd);\r\ntarget_free_sgl(cmd->t_data_sg, cmd->t_data_nents);\r\ncmd->t_data_sg = NULL;\r\ncmd->t_data_nents = 0;\r\ntarget_free_sgl(cmd->t_bidi_data_sg, cmd->t_bidi_data_nents);\r\ncmd->t_bidi_data_sg = NULL;\r\ncmd->t_bidi_data_nents = 0;\r\n}\r\nstatic int transport_put_cmd(struct se_cmd *cmd)\r\n{\r\nBUG_ON(!cmd->se_tfo);\r\nreturn target_put_sess_cmd(cmd);\r\n}\r\nvoid *transport_kmap_data_sg(struct se_cmd *cmd)\r\n{\r\nstruct scatterlist *sg = cmd->t_data_sg;\r\nstruct page **pages;\r\nint i;\r\nif (!cmd->t_data_nents)\r\nreturn NULL;\r\nBUG_ON(!sg);\r\nif (cmd->t_data_nents == 1)\r\nreturn kmap(sg_page(sg)) + sg->offset;\r\npages = kmalloc_array(cmd->t_data_nents, sizeof(*pages), GFP_KERNEL);\r\nif (!pages)\r\nreturn NULL;\r\nfor_each_sg(cmd->t_data_sg, sg, cmd->t_data_nents, i) {\r\npages[i] = sg_page(sg);\r\n}\r\ncmd->t_data_vmap = vmap(pages, cmd->t_data_nents, VM_MAP, PAGE_KERNEL);\r\nkfree(pages);\r\nif (!cmd->t_data_vmap)\r\nreturn NULL;\r\nreturn cmd->t_data_vmap + cmd->t_data_sg[0].offset;\r\n}\r\nvoid transport_kunmap_data_sg(struct se_cmd *cmd)\r\n{\r\nif (!cmd->t_data_nents) {\r\nreturn;\r\n} else if (cmd->t_data_nents == 1) {\r\nkunmap(sg_page(cmd->t_data_sg));\r\nreturn;\r\n}\r\nvunmap(cmd->t_data_vmap);\r\ncmd->t_data_vmap = NULL;\r\n}\r\nint\r\ntarget_alloc_sgl(struct scatterlist **sgl, unsigned int *nents, u32 length,\r\nbool zero_page, bool chainable)\r\n{\r\nstruct scatterlist *sg;\r\nstruct page *page;\r\ngfp_t zero_flag = (zero_page) ? __GFP_ZERO : 0;\r\nunsigned int nalloc, nent;\r\nint i = 0;\r\nnalloc = nent = DIV_ROUND_UP(length, PAGE_SIZE);\r\nif (chainable)\r\nnalloc++;\r\nsg = kmalloc_array(nalloc, sizeof(struct scatterlist), GFP_KERNEL);\r\nif (!sg)\r\nreturn -ENOMEM;\r\nsg_init_table(sg, nalloc);\r\nwhile (length) {\r\nu32 page_len = min_t(u32, length, PAGE_SIZE);\r\npage = alloc_page(GFP_KERNEL | zero_flag);\r\nif (!page)\r\ngoto out;\r\nsg_set_page(&sg[i], page, page_len, 0);\r\nlength -= page_len;\r\ni++;\r\n}\r\n*sgl = sg;\r\n*nents = nent;\r\nreturn 0;\r\nout:\r\nwhile (i > 0) {\r\ni--;\r\n__free_page(sg_page(&sg[i]));\r\n}\r\nkfree(sg);\r\nreturn -ENOMEM;\r\n}\r\nsense_reason_t\r\ntransport_generic_new_cmd(struct se_cmd *cmd)\r\n{\r\nunsigned long flags;\r\nint ret = 0;\r\nbool zero_flag = !(cmd->se_cmd_flags & SCF_SCSI_DATA_CDB);\r\nif (cmd->prot_op != TARGET_PROT_NORMAL &&\r\n!(cmd->se_cmd_flags & SCF_PASSTHROUGH_PROT_SG_TO_MEM_NOALLOC)) {\r\nret = target_alloc_sgl(&cmd->t_prot_sg, &cmd->t_prot_nents,\r\ncmd->prot_length, true, false);\r\nif (ret < 0)\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\n}\r\nif (!(cmd->se_cmd_flags & SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC) &&\r\ncmd->data_length) {\r\nif ((cmd->se_cmd_flags & SCF_BIDI) ||\r\n(cmd->se_cmd_flags & SCF_COMPARE_AND_WRITE)) {\r\nu32 bidi_length;\r\nif (cmd->se_cmd_flags & SCF_COMPARE_AND_WRITE)\r\nbidi_length = cmd->t_task_nolb *\r\ncmd->se_dev->dev_attrib.block_size;\r\nelse\r\nbidi_length = cmd->data_length;\r\nret = target_alloc_sgl(&cmd->t_bidi_data_sg,\r\n&cmd->t_bidi_data_nents,\r\nbidi_length, zero_flag, false);\r\nif (ret < 0)\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\n}\r\nret = target_alloc_sgl(&cmd->t_data_sg, &cmd->t_data_nents,\r\ncmd->data_length, zero_flag, false);\r\nif (ret < 0)\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\n} else if ((cmd->se_cmd_flags & SCF_COMPARE_AND_WRITE) &&\r\ncmd->data_length) {\r\nu32 caw_length = cmd->t_task_nolb *\r\ncmd->se_dev->dev_attrib.block_size;\r\nret = target_alloc_sgl(&cmd->t_bidi_data_sg,\r\n&cmd->t_bidi_data_nents,\r\ncaw_length, zero_flag, false);\r\nif (ret < 0)\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\n}\r\ntarget_add_to_state_list(cmd);\r\nif (cmd->data_direction != DMA_TO_DEVICE || cmd->data_length == 0) {\r\ntarget_execute_cmd(cmd);\r\nreturn 0;\r\n}\r\nspin_lock_irqsave(&cmd->t_state_lock, flags);\r\ncmd->t_state = TRANSPORT_WRITE_PENDING;\r\nif (cmd->transport_state & CMD_T_STOP) {\r\npr_debug("%s:%d CMD_T_STOP for ITT: 0x%08llx\n",\r\n__func__, __LINE__, cmd->tag);\r\nspin_unlock_irqrestore(&cmd->t_state_lock, flags);\r\ncomplete_all(&cmd->t_transport_stop_comp);\r\nreturn 0;\r\n}\r\ncmd->transport_state &= ~CMD_T_ACTIVE;\r\nspin_unlock_irqrestore(&cmd->t_state_lock, flags);\r\nret = cmd->se_tfo->write_pending(cmd);\r\nif (ret)\r\ngoto queue_full;\r\nreturn 0;\r\nqueue_full:\r\npr_debug("Handling write_pending QUEUE__FULL: se_cmd: %p\n", cmd);\r\ntransport_handle_queue_full(cmd, cmd->se_dev, ret, true);\r\nreturn 0;\r\n}\r\nstatic void transport_write_pending_qf(struct se_cmd *cmd)\r\n{\r\nint ret;\r\nret = cmd->se_tfo->write_pending(cmd);\r\nif (ret) {\r\npr_debug("Handling write_pending QUEUE__FULL: se_cmd: %p\n",\r\ncmd);\r\ntransport_handle_queue_full(cmd, cmd->se_dev, ret, true);\r\n}\r\n}\r\nstatic void target_wait_free_cmd(struct se_cmd *cmd, bool *aborted, bool *tas)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&cmd->t_state_lock, flags);\r\n__transport_wait_for_tasks(cmd, true, aborted, tas, &flags);\r\nspin_unlock_irqrestore(&cmd->t_state_lock, flags);\r\n}\r\nint transport_generic_free_cmd(struct se_cmd *cmd, int wait_for_tasks)\r\n{\r\nint ret = 0;\r\nbool aborted = false, tas = false;\r\nif (!(cmd->se_cmd_flags & SCF_SE_LUN_CMD)) {\r\nif (wait_for_tasks && (cmd->se_cmd_flags & SCF_SCSI_TMR_CDB))\r\ntarget_wait_free_cmd(cmd, &aborted, &tas);\r\nif (!aborted || tas)\r\nret = transport_put_cmd(cmd);\r\n} else {\r\nif (wait_for_tasks)\r\ntarget_wait_free_cmd(cmd, &aborted, &tas);\r\nif (cmd->state_active)\r\ntarget_remove_from_state_list(cmd);\r\nif (cmd->se_lun)\r\ntransport_lun_remove_cmd(cmd);\r\nif (!aborted || tas)\r\nret = transport_put_cmd(cmd);\r\n}\r\nif (aborted) {\r\npr_debug("Detected CMD_T_ABORTED for ITT: %llu\n", cmd->tag);\r\nwait_for_completion(&cmd->cmd_wait_comp);\r\ncmd->se_tfo->release_cmd(cmd);\r\nret = 1;\r\n}\r\nreturn ret;\r\n}\r\nint target_get_sess_cmd(struct se_cmd *se_cmd, bool ack_kref)\r\n{\r\nstruct se_session *se_sess = se_cmd->se_sess;\r\nunsigned long flags;\r\nint ret = 0;\r\nif (ack_kref) {\r\nif (!kref_get_unless_zero(&se_cmd->cmd_kref))\r\nreturn -EINVAL;\r\nse_cmd->se_cmd_flags |= SCF_ACK_KREF;\r\n}\r\nspin_lock_irqsave(&se_sess->sess_cmd_lock, flags);\r\nif (se_sess->sess_tearing_down) {\r\nret = -ESHUTDOWN;\r\ngoto out;\r\n}\r\nlist_add_tail(&se_cmd->se_cmd_list, &se_sess->sess_cmd_list);\r\nout:\r\nspin_unlock_irqrestore(&se_sess->sess_cmd_lock, flags);\r\nif (ret && ack_kref)\r\ntarget_put_sess_cmd(se_cmd);\r\nreturn ret;\r\n}\r\nstatic void target_free_cmd_mem(struct se_cmd *cmd)\r\n{\r\ntransport_free_pages(cmd);\r\nif (cmd->se_cmd_flags & SCF_SCSI_TMR_CDB)\r\ncore_tmr_release_req(cmd->se_tmr_req);\r\nif (cmd->t_task_cdb != cmd->__t_task_cdb)\r\nkfree(cmd->t_task_cdb);\r\n}\r\nstatic void target_release_cmd_kref(struct kref *kref)\r\n{\r\nstruct se_cmd *se_cmd = container_of(kref, struct se_cmd, cmd_kref);\r\nstruct se_session *se_sess = se_cmd->se_sess;\r\nunsigned long flags;\r\nbool fabric_stop;\r\nif (se_sess) {\r\nspin_lock_irqsave(&se_sess->sess_cmd_lock, flags);\r\nspin_lock(&se_cmd->t_state_lock);\r\nfabric_stop = (se_cmd->transport_state & CMD_T_FABRIC_STOP) &&\r\n(se_cmd->transport_state & CMD_T_ABORTED);\r\nspin_unlock(&se_cmd->t_state_lock);\r\nif (se_cmd->cmd_wait_set || fabric_stop) {\r\nlist_del_init(&se_cmd->se_cmd_list);\r\nspin_unlock_irqrestore(&se_sess->sess_cmd_lock, flags);\r\ntarget_free_cmd_mem(se_cmd);\r\ncomplete(&se_cmd->cmd_wait_comp);\r\nreturn;\r\n}\r\nlist_del_init(&se_cmd->se_cmd_list);\r\nspin_unlock_irqrestore(&se_sess->sess_cmd_lock, flags);\r\n}\r\ntarget_free_cmd_mem(se_cmd);\r\nse_cmd->se_tfo->release_cmd(se_cmd);\r\n}\r\nint target_put_sess_cmd(struct se_cmd *se_cmd)\r\n{\r\nreturn kref_put(&se_cmd->cmd_kref, target_release_cmd_kref);\r\n}\r\nstatic const char *data_dir_name(enum dma_data_direction d)\r\n{\r\nswitch (d) {\r\ncase DMA_BIDIRECTIONAL: return "BIDI";\r\ncase DMA_TO_DEVICE: return "WRITE";\r\ncase DMA_FROM_DEVICE: return "READ";\r\ncase DMA_NONE: return "NONE";\r\n}\r\nreturn "(?)";\r\n}\r\nstatic const char *cmd_state_name(enum transport_state_table t)\r\n{\r\nswitch (t) {\r\ncase TRANSPORT_NO_STATE: return "NO_STATE";\r\ncase TRANSPORT_NEW_CMD: return "NEW_CMD";\r\ncase TRANSPORT_WRITE_PENDING: return "WRITE_PENDING";\r\ncase TRANSPORT_PROCESSING: return "PROCESSING";\r\ncase TRANSPORT_COMPLETE: return "COMPLETE";\r\ncase TRANSPORT_ISTATE_PROCESSING:\r\nreturn "ISTATE_PROCESSING";\r\ncase TRANSPORT_COMPLETE_QF_WP: return "COMPLETE_QF_WP";\r\ncase TRANSPORT_COMPLETE_QF_OK: return "COMPLETE_QF_OK";\r\ncase TRANSPORT_COMPLETE_QF_ERR: return "COMPLETE_QF_ERR";\r\n}\r\nreturn "(?)";\r\n}\r\nstatic void target_append_str(char **str, const char *txt)\r\n{\r\nchar *prev = *str;\r\n*str = *str ? kasprintf(GFP_ATOMIC, "%s,%s", *str, txt) :\r\nkstrdup(txt, GFP_ATOMIC);\r\nkfree(prev);\r\n}\r\nstatic char *target_ts_to_str(u32 ts)\r\n{\r\nchar *str = NULL;\r\nif (ts & CMD_T_ABORTED)\r\ntarget_append_str(&str, "aborted");\r\nif (ts & CMD_T_ACTIVE)\r\ntarget_append_str(&str, "active");\r\nif (ts & CMD_T_COMPLETE)\r\ntarget_append_str(&str, "complete");\r\nif (ts & CMD_T_SENT)\r\ntarget_append_str(&str, "sent");\r\nif (ts & CMD_T_STOP)\r\ntarget_append_str(&str, "stop");\r\nif (ts & CMD_T_FABRIC_STOP)\r\ntarget_append_str(&str, "fabric_stop");\r\nreturn str;\r\n}\r\nstatic const char *target_tmf_name(enum tcm_tmreq_table tmf)\r\n{\r\nswitch (tmf) {\r\ncase TMR_ABORT_TASK: return "ABORT_TASK";\r\ncase TMR_ABORT_TASK_SET: return "ABORT_TASK_SET";\r\ncase TMR_CLEAR_ACA: return "CLEAR_ACA";\r\ncase TMR_CLEAR_TASK_SET: return "CLEAR_TASK_SET";\r\ncase TMR_LUN_RESET: return "LUN_RESET";\r\ncase TMR_TARGET_WARM_RESET: return "TARGET_WARM_RESET";\r\ncase TMR_TARGET_COLD_RESET: return "TARGET_COLD_RESET";\r\ncase TMR_UNKNOWN: break;\r\n}\r\nreturn "(?)";\r\n}\r\nvoid target_show_cmd(const char *pfx, struct se_cmd *cmd)\r\n{\r\nchar *ts_str = target_ts_to_str(cmd->transport_state);\r\nconst u8 *cdb = cmd->t_task_cdb;\r\nstruct se_tmr_req *tmf = cmd->se_tmr_req;\r\nif (!(cmd->se_cmd_flags & SCF_SCSI_TMR_CDB)) {\r\npr_debug("%scmd %#02x:%#02x with tag %#llx dir %s i_state %d t_state %s len %d refcnt %d transport_state %s\n",\r\npfx, cdb[0], cdb[1], cmd->tag,\r\ndata_dir_name(cmd->data_direction),\r\ncmd->se_tfo->get_cmd_state(cmd),\r\ncmd_state_name(cmd->t_state), cmd->data_length,\r\nkref_read(&cmd->cmd_kref), ts_str);\r\n} else {\r\npr_debug("%stmf %s with tag %#llx ref_task_tag %#llx i_state %d t_state %s refcnt %d transport_state %s\n",\r\npfx, target_tmf_name(tmf->function), cmd->tag,\r\ntmf->ref_task_tag, cmd->se_tfo->get_cmd_state(cmd),\r\ncmd_state_name(cmd->t_state),\r\nkref_read(&cmd->cmd_kref), ts_str);\r\n}\r\nkfree(ts_str);\r\n}\r\nvoid target_sess_cmd_list_set_waiting(struct se_session *se_sess)\r\n{\r\nstruct se_cmd *se_cmd, *tmp_cmd;\r\nunsigned long flags;\r\nint rc;\r\nspin_lock_irqsave(&se_sess->sess_cmd_lock, flags);\r\nif (se_sess->sess_tearing_down) {\r\nspin_unlock_irqrestore(&se_sess->sess_cmd_lock, flags);\r\nreturn;\r\n}\r\nse_sess->sess_tearing_down = 1;\r\nlist_splice_init(&se_sess->sess_cmd_list, &se_sess->sess_wait_list);\r\nlist_for_each_entry_safe(se_cmd, tmp_cmd,\r\n&se_sess->sess_wait_list, se_cmd_list) {\r\nrc = kref_get_unless_zero(&se_cmd->cmd_kref);\r\nif (rc) {\r\nse_cmd->cmd_wait_set = 1;\r\nspin_lock(&se_cmd->t_state_lock);\r\nse_cmd->transport_state |= CMD_T_FABRIC_STOP;\r\nspin_unlock(&se_cmd->t_state_lock);\r\n} else\r\nlist_del_init(&se_cmd->se_cmd_list);\r\n}\r\nspin_unlock_irqrestore(&se_sess->sess_cmd_lock, flags);\r\n}\r\nvoid target_wait_for_sess_cmds(struct se_session *se_sess)\r\n{\r\nstruct se_cmd *se_cmd, *tmp_cmd;\r\nunsigned long flags;\r\nbool tas;\r\nlist_for_each_entry_safe(se_cmd, tmp_cmd,\r\n&se_sess->sess_wait_list, se_cmd_list) {\r\npr_debug("Waiting for se_cmd: %p t_state: %d, fabric state:"\r\n" %d\n", se_cmd, se_cmd->t_state,\r\nse_cmd->se_tfo->get_cmd_state(se_cmd));\r\nspin_lock_irqsave(&se_cmd->t_state_lock, flags);\r\ntas = (se_cmd->transport_state & CMD_T_TAS);\r\nspin_unlock_irqrestore(&se_cmd->t_state_lock, flags);\r\nif (!target_put_sess_cmd(se_cmd)) {\r\nif (tas)\r\ntarget_put_sess_cmd(se_cmd);\r\n}\r\nwait_for_completion(&se_cmd->cmd_wait_comp);\r\npr_debug("After cmd_wait_comp: se_cmd: %p t_state: %d"\r\n" fabric state: %d\n", se_cmd, se_cmd->t_state,\r\nse_cmd->se_tfo->get_cmd_state(se_cmd));\r\nse_cmd->se_tfo->release_cmd(se_cmd);\r\n}\r\nspin_lock_irqsave(&se_sess->sess_cmd_lock, flags);\r\nWARN_ON(!list_empty(&se_sess->sess_cmd_list));\r\nspin_unlock_irqrestore(&se_sess->sess_cmd_lock, flags);\r\n}\r\nstatic void target_lun_confirm(struct percpu_ref *ref)\r\n{\r\nstruct se_lun *lun = container_of(ref, struct se_lun, lun_ref);\r\ncomplete(&lun->lun_ref_comp);\r\n}\r\nvoid transport_clear_lun_ref(struct se_lun *lun)\r\n{\r\npercpu_ref_kill_and_confirm(&lun->lun_ref, target_lun_confirm);\r\nwait_for_completion(&lun->lun_ref_comp);\r\nwait_for_completion(&lun->lun_shutdown_comp);\r\n}\r\nstatic bool\r\n__transport_wait_for_tasks(struct se_cmd *cmd, bool fabric_stop,\r\nbool *aborted, bool *tas, unsigned long *flags)\r\n__releases(&cmd->t_state_lock\r\nbool transport_wait_for_tasks(struct se_cmd *cmd)\r\n{\r\nunsigned long flags;\r\nbool ret, aborted = false, tas = false;\r\nspin_lock_irqsave(&cmd->t_state_lock, flags);\r\nret = __transport_wait_for_tasks(cmd, false, &aborted, &tas, &flags);\r\nspin_unlock_irqrestore(&cmd->t_state_lock, flags);\r\nreturn ret;\r\n}\r\nstatic int translate_sense_reason(struct se_cmd *cmd, sense_reason_t reason)\r\n{\r\nconst struct sense_info *si;\r\nu8 *buffer = cmd->sense_buffer;\r\nint r = (__force int)reason;\r\nu8 asc, ascq;\r\nbool desc_format = target_sense_desc_format(cmd->se_dev);\r\nif (r < ARRAY_SIZE(sense_info_table) && sense_info_table[r].key)\r\nsi = &sense_info_table[r];\r\nelse\r\nsi = &sense_info_table[(__force int)\r\nTCM_LOGICAL_UNIT_COMMUNICATION_FAILURE];\r\nif (reason == TCM_CHECK_CONDITION_UNIT_ATTENTION) {\r\ncore_scsi3_ua_for_check_condition(cmd, &asc, &ascq);\r\nWARN_ON_ONCE(asc == 0);\r\n} else if (si->asc == 0) {\r\nWARN_ON_ONCE(cmd->scsi_asc == 0);\r\nasc = cmd->scsi_asc;\r\nascq = cmd->scsi_ascq;\r\n} else {\r\nasc = si->asc;\r\nascq = si->ascq;\r\n}\r\nscsi_build_sense_buffer(desc_format, buffer, si->key, asc, ascq);\r\nif (si->add_sector_info)\r\nreturn scsi_set_sense_information(buffer,\r\ncmd->scsi_sense_length,\r\ncmd->bad_sector);\r\nreturn 0;\r\n}\r\nint\r\ntransport_send_check_condition_and_sense(struct se_cmd *cmd,\r\nsense_reason_t reason, int from_transport)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&cmd->t_state_lock, flags);\r\nif (cmd->se_cmd_flags & SCF_SENT_CHECK_CONDITION) {\r\nspin_unlock_irqrestore(&cmd->t_state_lock, flags);\r\nreturn 0;\r\n}\r\ncmd->se_cmd_flags |= SCF_SENT_CHECK_CONDITION;\r\nspin_unlock_irqrestore(&cmd->t_state_lock, flags);\r\nif (!from_transport) {\r\nint rc;\r\ncmd->se_cmd_flags |= SCF_EMULATED_TASK_SENSE;\r\ncmd->scsi_status = SAM_STAT_CHECK_CONDITION;\r\ncmd->scsi_sense_length = TRANSPORT_SENSE_BUFFER;\r\nrc = translate_sense_reason(cmd, reason);\r\nif (rc)\r\nreturn rc;\r\n}\r\ntrace_target_cmd_complete(cmd);\r\nreturn cmd->se_tfo->queue_status(cmd);\r\n}\r\nstatic int __transport_check_aborted_status(struct se_cmd *cmd, int send_status)\r\n__releases(&cmd->t_state_lock\r\nint transport_check_aborted_status(struct se_cmd *cmd, int send_status)\r\n{\r\nint ret;\r\nspin_lock_irq(&cmd->t_state_lock);\r\nret = __transport_check_aborted_status(cmd, send_status);\r\nspin_unlock_irq(&cmd->t_state_lock);\r\nreturn ret;\r\n}\r\nvoid transport_send_task_abort(struct se_cmd *cmd)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&cmd->t_state_lock, flags);\r\nif (cmd->se_cmd_flags & (SCF_SENT_CHECK_CONDITION)) {\r\nspin_unlock_irqrestore(&cmd->t_state_lock, flags);\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(&cmd->t_state_lock, flags);\r\nif (cmd->data_direction == DMA_TO_DEVICE) {\r\nif (cmd->se_tfo->write_pending_status(cmd) != 0) {\r\nspin_lock_irqsave(&cmd->t_state_lock, flags);\r\nif (cmd->se_cmd_flags & SCF_SEND_DELAYED_TAS) {\r\nspin_unlock_irqrestore(&cmd->t_state_lock, flags);\r\ngoto send_abort;\r\n}\r\ncmd->se_cmd_flags |= SCF_SEND_DELAYED_TAS;\r\nspin_unlock_irqrestore(&cmd->t_state_lock, flags);\r\nreturn;\r\n}\r\n}\r\nsend_abort:\r\ncmd->scsi_status = SAM_STAT_TASK_ABORTED;\r\ntransport_lun_remove_cmd(cmd);\r\npr_debug("Setting SAM_STAT_TASK_ABORTED status for CDB: 0x%02x, ITT: 0x%08llx\n",\r\ncmd->t_task_cdb[0], cmd->tag);\r\ntrace_target_cmd_complete(cmd);\r\nret = cmd->se_tfo->queue_status(cmd);\r\nif (ret)\r\ntransport_handle_queue_full(cmd, cmd->se_dev, ret, false);\r\n}\r\nstatic void target_tmr_work(struct work_struct *work)\r\n{\r\nstruct se_cmd *cmd = container_of(work, struct se_cmd, work);\r\nstruct se_device *dev = cmd->se_dev;\r\nstruct se_tmr_req *tmr = cmd->se_tmr_req;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&cmd->t_state_lock, flags);\r\nif (cmd->transport_state & CMD_T_ABORTED) {\r\ntmr->response = TMR_FUNCTION_REJECTED;\r\nspin_unlock_irqrestore(&cmd->t_state_lock, flags);\r\ngoto check_stop;\r\n}\r\nspin_unlock_irqrestore(&cmd->t_state_lock, flags);\r\nswitch (tmr->function) {\r\ncase TMR_ABORT_TASK:\r\ncore_tmr_abort_task(dev, tmr, cmd->se_sess);\r\nbreak;\r\ncase TMR_ABORT_TASK_SET:\r\ncase TMR_CLEAR_ACA:\r\ncase TMR_CLEAR_TASK_SET:\r\ntmr->response = TMR_TASK_MGMT_FUNCTION_NOT_SUPPORTED;\r\nbreak;\r\ncase TMR_LUN_RESET:\r\nret = core_tmr_lun_reset(dev, tmr, NULL, NULL);\r\ntmr->response = (!ret) ? TMR_FUNCTION_COMPLETE :\r\nTMR_FUNCTION_REJECTED;\r\nif (tmr->response == TMR_FUNCTION_COMPLETE) {\r\ntarget_ua_allocate_lun(cmd->se_sess->se_node_acl,\r\ncmd->orig_fe_lun, 0x29,\r\nASCQ_29H_BUS_DEVICE_RESET_FUNCTION_OCCURRED);\r\n}\r\nbreak;\r\ncase TMR_TARGET_WARM_RESET:\r\ntmr->response = TMR_FUNCTION_REJECTED;\r\nbreak;\r\ncase TMR_TARGET_COLD_RESET:\r\ntmr->response = TMR_FUNCTION_REJECTED;\r\nbreak;\r\ndefault:\r\npr_err("Uknown TMR function: 0x%02x.\n",\r\ntmr->function);\r\ntmr->response = TMR_FUNCTION_REJECTED;\r\nbreak;\r\n}\r\nspin_lock_irqsave(&cmd->t_state_lock, flags);\r\nif (cmd->transport_state & CMD_T_ABORTED) {\r\nspin_unlock_irqrestore(&cmd->t_state_lock, flags);\r\ngoto check_stop;\r\n}\r\nspin_unlock_irqrestore(&cmd->t_state_lock, flags);\r\ncmd->se_tfo->queue_tm_rsp(cmd);\r\ncheck_stop:\r\ntransport_lun_remove_cmd(cmd);\r\ntransport_cmd_check_stop_to_fabric(cmd);\r\n}\r\nint transport_generic_handle_tmr(\r\nstruct se_cmd *cmd)\r\n{\r\nunsigned long flags;\r\nbool aborted = false;\r\nspin_lock_irqsave(&cmd->t_state_lock, flags);\r\nif (cmd->transport_state & CMD_T_ABORTED) {\r\naborted = true;\r\n} else {\r\ncmd->t_state = TRANSPORT_ISTATE_PROCESSING;\r\ncmd->transport_state |= CMD_T_ACTIVE;\r\n}\r\nspin_unlock_irqrestore(&cmd->t_state_lock, flags);\r\nif (aborted) {\r\npr_warn_ratelimited("handle_tmr caught CMD_T_ABORTED TMR %d"\r\n"ref_tag: %llu tag: %llu\n", cmd->se_tmr_req->function,\r\ncmd->se_tmr_req->ref_task_tag, cmd->tag);\r\ntransport_lun_remove_cmd(cmd);\r\ntransport_cmd_check_stop_to_fabric(cmd);\r\nreturn 0;\r\n}\r\nINIT_WORK(&cmd->work, target_tmr_work);\r\nqueue_work(cmd->se_dev->tmr_wq, &cmd->work);\r\nreturn 0;\r\n}\r\nbool\r\ntarget_check_wce(struct se_device *dev)\r\n{\r\nbool wce = false;\r\nif (dev->transport->get_write_cache)\r\nwce = dev->transport->get_write_cache(dev);\r\nelse if (dev->dev_attrib.emulate_write_cache > 0)\r\nwce = true;\r\nreturn wce;\r\n}\r\nbool\r\ntarget_check_fua(struct se_device *dev)\r\n{\r\nreturn target_check_wce(dev) && dev->dev_attrib.emulate_fua_write > 0;\r\n}
