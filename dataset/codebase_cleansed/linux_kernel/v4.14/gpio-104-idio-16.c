static int idio_16_gpio_get_direction(struct gpio_chip *chip, unsigned offset)\r\n{\r\nif (offset > 15)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int idio_16_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nreturn 0;\r\n}\r\nstatic int idio_16_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned offset, int value)\r\n{\r\nchip->set(chip, offset, value);\r\nreturn 0;\r\n}\r\nstatic int idio_16_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct idio_16_gpio *const idio16gpio = gpiochip_get_data(chip);\r\nconst unsigned mask = BIT(offset-16);\r\nif (offset < 16)\r\nreturn -EINVAL;\r\nif (offset < 24)\r\nreturn !!(inb(idio16gpio->base + 1) & mask);\r\nreturn !!(inb(idio16gpio->base + 5) & (mask>>8));\r\n}\r\nstatic void idio_16_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct idio_16_gpio *const idio16gpio = gpiochip_get_data(chip);\r\nconst unsigned mask = BIT(offset);\r\nunsigned long flags;\r\nif (offset > 15)\r\nreturn;\r\nraw_spin_lock_irqsave(&idio16gpio->lock, flags);\r\nif (value)\r\nidio16gpio->out_state |= mask;\r\nelse\r\nidio16gpio->out_state &= ~mask;\r\nif (offset > 7)\r\noutb(idio16gpio->out_state >> 8, idio16gpio->base + 4);\r\nelse\r\noutb(idio16gpio->out_state, idio16gpio->base);\r\nraw_spin_unlock_irqrestore(&idio16gpio->lock, flags);\r\n}\r\nstatic void idio_16_gpio_set_multiple(struct gpio_chip *chip,\r\nunsigned long *mask, unsigned long *bits)\r\n{\r\nstruct idio_16_gpio *const idio16gpio = gpiochip_get_data(chip);\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&idio16gpio->lock, flags);\r\nidio16gpio->out_state &= ~*mask;\r\nidio16gpio->out_state |= *mask & *bits;\r\nif (*mask & 0xFF)\r\noutb(idio16gpio->out_state, idio16gpio->base);\r\nif ((*mask >> 8) & 0xFF)\r\noutb(idio16gpio->out_state >> 8, idio16gpio->base + 4);\r\nraw_spin_unlock_irqrestore(&idio16gpio->lock, flags);\r\n}\r\nstatic void idio_16_irq_ack(struct irq_data *data)\r\n{\r\n}\r\nstatic void idio_16_irq_mask(struct irq_data *data)\r\n{\r\nstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\r\nstruct idio_16_gpio *const idio16gpio = gpiochip_get_data(chip);\r\nconst unsigned long mask = BIT(irqd_to_hwirq(data));\r\nunsigned long flags;\r\nidio16gpio->irq_mask &= ~mask;\r\nif (!idio16gpio->irq_mask) {\r\nraw_spin_lock_irqsave(&idio16gpio->lock, flags);\r\noutb(0, idio16gpio->base + 2);\r\nraw_spin_unlock_irqrestore(&idio16gpio->lock, flags);\r\n}\r\n}\r\nstatic void idio_16_irq_unmask(struct irq_data *data)\r\n{\r\nstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\r\nstruct idio_16_gpio *const idio16gpio = gpiochip_get_data(chip);\r\nconst unsigned long mask = BIT(irqd_to_hwirq(data));\r\nconst unsigned long prev_irq_mask = idio16gpio->irq_mask;\r\nunsigned long flags;\r\nidio16gpio->irq_mask |= mask;\r\nif (!prev_irq_mask) {\r\nraw_spin_lock_irqsave(&idio16gpio->lock, flags);\r\ninb(idio16gpio->base + 2);\r\nraw_spin_unlock_irqrestore(&idio16gpio->lock, flags);\r\n}\r\n}\r\nstatic int idio_16_irq_set_type(struct irq_data *data, unsigned flow_type)\r\n{\r\nif (flow_type != IRQ_TYPE_NONE &&\r\n(flow_type & IRQ_TYPE_EDGE_BOTH) != IRQ_TYPE_EDGE_BOTH)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t idio_16_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct idio_16_gpio *const idio16gpio = dev_id;\r\nstruct gpio_chip *const chip = &idio16gpio->chip;\r\nint gpio;\r\nfor_each_set_bit(gpio, &idio16gpio->irq_mask, chip->ngpio)\r\ngeneric_handle_irq(irq_find_mapping(chip->irqdomain, gpio));\r\nraw_spin_lock(&idio16gpio->lock);\r\noutb(0, idio16gpio->base + 1);\r\nraw_spin_unlock(&idio16gpio->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int idio_16_probe(struct device *dev, unsigned int id)\r\n{\r\nstruct idio_16_gpio *idio16gpio;\r\nconst char *const name = dev_name(dev);\r\nint err;\r\nidio16gpio = devm_kzalloc(dev, sizeof(*idio16gpio), GFP_KERNEL);\r\nif (!idio16gpio)\r\nreturn -ENOMEM;\r\nif (!devm_request_region(dev, base[id], IDIO_16_EXTENT, name)) {\r\ndev_err(dev, "Unable to lock port addresses (0x%X-0x%X)\n",\r\nbase[id], base[id] + IDIO_16_EXTENT);\r\nreturn -EBUSY;\r\n}\r\nidio16gpio->chip.label = name;\r\nidio16gpio->chip.parent = dev;\r\nidio16gpio->chip.owner = THIS_MODULE;\r\nidio16gpio->chip.base = -1;\r\nidio16gpio->chip.ngpio = IDIO_16_NGPIO;\r\nidio16gpio->chip.names = idio_16_names;\r\nidio16gpio->chip.get_direction = idio_16_gpio_get_direction;\r\nidio16gpio->chip.direction_input = idio_16_gpio_direction_input;\r\nidio16gpio->chip.direction_output = idio_16_gpio_direction_output;\r\nidio16gpio->chip.get = idio_16_gpio_get;\r\nidio16gpio->chip.set = idio_16_gpio_set;\r\nidio16gpio->chip.set_multiple = idio_16_gpio_set_multiple;\r\nidio16gpio->base = base[id];\r\nidio16gpio->out_state = 0xFFFF;\r\nraw_spin_lock_init(&idio16gpio->lock);\r\nerr = devm_gpiochip_add_data(dev, &idio16gpio->chip, idio16gpio);\r\nif (err) {\r\ndev_err(dev, "GPIO registering failed (%d)\n", err);\r\nreturn err;\r\n}\r\noutb(0, base[id] + 2);\r\noutb(0, base[id] + 1);\r\nerr = gpiochip_irqchip_add(&idio16gpio->chip, &idio_16_irqchip, 0,\r\nhandle_edge_irq, IRQ_TYPE_NONE);\r\nif (err) {\r\ndev_err(dev, "Could not add irqchip (%d)\n", err);\r\nreturn err;\r\n}\r\nerr = devm_request_irq(dev, irq[id], idio_16_irq_handler, 0, name,\r\nidio16gpio);\r\nif (err) {\r\ndev_err(dev, "IRQ handler registering failed (%d)\n", err);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}
