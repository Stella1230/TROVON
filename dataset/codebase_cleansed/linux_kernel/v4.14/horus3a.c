static void horus3a_i2c_debug(struct horus3a_priv *priv,\r\nu8 reg, u8 write, const u8 *data, u32 len)\r\n{\r\ndev_dbg(&priv->i2c->dev, "horus3a: I2C %s reg 0x%02x size %d\n",\r\n(write == 0 ? "read" : "write"), reg, len);\r\nprint_hex_dump_bytes("horus3a: I2C data: ",\r\nDUMP_PREFIX_OFFSET, data, len);\r\n}\r\nstatic int horus3a_write_regs(struct horus3a_priv *priv,\r\nu8 reg, const u8 *data, u32 len)\r\n{\r\nint ret;\r\nu8 buf[MAX_WRITE_REGSIZE + 1];\r\nstruct i2c_msg msg[1] = {\r\n{\r\n.addr = priv->i2c_address,\r\n.flags = 0,\r\n.len = len + 1,\r\n.buf = buf,\r\n}\r\n};\r\nif (len + 1 > sizeof(buf)) {\r\ndev_warn(&priv->i2c->dev,"wr reg=%04x: len=%d is too big!\n",\r\nreg, len + 1);\r\nreturn -E2BIG;\r\n}\r\nhorus3a_i2c_debug(priv, reg, 1, data, len);\r\nbuf[0] = reg;\r\nmemcpy(&buf[1], data, len);\r\nret = i2c_transfer(priv->i2c, msg, 1);\r\nif (ret >= 0 && ret != 1)\r\nret = -EREMOTEIO;\r\nif (ret < 0) {\r\ndev_warn(&priv->i2c->dev,\r\n"%s: i2c wr failed=%d reg=%02x len=%d\n",\r\nKBUILD_MODNAME, ret, reg, len);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int horus3a_write_reg(struct horus3a_priv *priv, u8 reg, u8 val)\r\n{\r\nreturn horus3a_write_regs(priv, reg, &val, 1);\r\n}\r\nstatic int horus3a_enter_power_save(struct horus3a_priv *priv)\r\n{\r\nu8 data[2];\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nif (priv->state == STATE_SLEEP)\r\nreturn 0;\r\nhorus3a_write_reg(priv, 0x2a, 0x79);\r\nhorus3a_write_reg(priv, 0x29, 0x70);\r\nhorus3a_write_reg(priv, 0x28, 0x3e);\r\nhorus3a_write_reg(priv, 0x2a, 0x19);\r\nhorus3a_write_reg(priv, 0x1c, 0x00);\r\ndata[0] = 0xC0;\r\ndata[1] = 0xA7;\r\nhorus3a_write_regs(priv, 0x11, data, sizeof(data));\r\npriv->state = STATE_SLEEP;\r\nreturn 0;\r\n}\r\nstatic int horus3a_leave_power_save(struct horus3a_priv *priv)\r\n{\r\nu8 data[2];\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nif (priv->state == STATE_ACTIVE)\r\nreturn 0;\r\ndata[0] = 0x00;\r\ndata[1] = 0xa7;\r\nhorus3a_write_regs(priv, 0x11, data, sizeof(data));\r\nhorus3a_write_reg(priv, 0x2a, 0x79);\r\nhorus3a_write_reg(priv, 0x1c, 0xc0);\r\nhorus3a_write_reg(priv, 0x29, 0x71);\r\nusleep_range(5000, 7000);\r\npriv->state = STATE_ACTIVE;\r\nreturn 0;\r\n}\r\nstatic int horus3a_init(struct dvb_frontend *fe)\r\n{\r\nstruct horus3a_priv *priv = fe->tuner_priv;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nreturn 0;\r\n}\r\nstatic void horus3a_release(struct dvb_frontend *fe)\r\n{\r\nstruct horus3a_priv *priv = fe->tuner_priv;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nkfree(fe->tuner_priv);\r\nfe->tuner_priv = NULL;\r\n}\r\nstatic int horus3a_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct horus3a_priv *priv = fe->tuner_priv;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nhorus3a_enter_power_save(priv);\r\nreturn 0;\r\n}\r\nstatic int horus3a_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct horus3a_priv *priv = fe->tuner_priv;\r\nu32 frequency = p->frequency;\r\nu32 symbol_rate = p->symbol_rate/1000;\r\nu8 mixdiv = 0;\r\nu8 mdiv = 0;\r\nu32 ms = 0;\r\nu8 f_ctl = 0;\r\nu8 g_ctl = 0;\r\nu8 fc_lpf = 0;\r\nu8 data[5];\r\ndev_dbg(&priv->i2c->dev, "%s(): frequency %dkHz symbol_rate %dksps\n",\r\n__func__, frequency, symbol_rate);\r\nif (priv->set_tuner)\r\npriv->set_tuner(priv->set_tuner_data, 0);\r\nif (priv->state == STATE_SLEEP)\r\nhorus3a_leave_power_save(priv);\r\nfrequency = DIV_ROUND_CLOSEST(frequency, 1000) * 1000;\r\nif (frequency <= 1155000) {\r\nmixdiv = 4;\r\nmdiv = 1;\r\n} else {\r\nmixdiv = 2;\r\nmdiv = 0;\r\n}\r\nms = DIV_ROUND_CLOSEST((frequency * mixdiv) / 2, 1000);\r\nif (ms > 0x7FFF) {\r\ndev_err(&priv->i2c->dev, "horus3a: invalid frequency %d\n",\r\nfrequency);\r\nreturn -EINVAL;\r\n}\r\nif (frequency < 975000) {\r\nf_ctl = 0x1C;\r\ng_ctl = 0x01;\r\n} else if (frequency < 1050000) {\r\nf_ctl = 0x18;\r\ng_ctl = 0x02;\r\n} else if (frequency < 1150000) {\r\nf_ctl = 0x14;\r\ng_ctl = 0x02;\r\n} else if (frequency < 1250000) {\r\nf_ctl = 0x10;\r\ng_ctl = 0x03;\r\n} else if (frequency < 1350000) {\r\nf_ctl = 0x0C;\r\ng_ctl = 0x04;\r\n} else if (frequency < 1450000) {\r\nf_ctl = 0x0A;\r\ng_ctl = 0x04;\r\n} else if (frequency < 1600000) {\r\nf_ctl = 0x07;\r\ng_ctl = 0x05;\r\n} else if (frequency < 1800000) {\r\nf_ctl = 0x04;\r\ng_ctl = 0x02;\r\n} else if (frequency < 2000000) {\r\nf_ctl = 0x02;\r\ng_ctl = 0x01;\r\n} else {\r\nf_ctl = 0x00;\r\ng_ctl = 0x00;\r\n}\r\nif (p->delivery_system == SYS_DVBS) {\r\nif (symbol_rate <= 4300)\r\nfc_lpf = 5;\r\nelse if (symbol_rate <= 10000)\r\nfc_lpf = (u8)DIV_ROUND_UP(symbol_rate * 47, 40000);\r\nelse\r\nfc_lpf = (u8)DIV_ROUND_UP(symbol_rate * 27, 40000) + 5;\r\nif (fc_lpf > 36)\r\nfc_lpf = 36;\r\n} else if (p->delivery_system == SYS_DVBS2) {\r\nif (symbol_rate <= 4500)\r\nfc_lpf = 5;\r\nelse if (symbol_rate <= 10000)\r\nfc_lpf = (u8)((symbol_rate * 11 + (10000-1)) / 10000);\r\nelse\r\nfc_lpf = (u8)((symbol_rate * 3 + (5000-1)) / 5000 + 5);\r\nif (fc_lpf > 36)\r\nfc_lpf = 36;\r\n} else {\r\ndev_err(&priv->i2c->dev,\r\n"horus3a: invalid delivery system %d\n",\r\np->delivery_system);\r\nreturn -EINVAL;\r\n}\r\ndata[0] = (u8)((ms >> 7) & 0xFF);\r\ndata[1] = (u8)((ms << 1) & 0xFF);\r\ndata[2] = 0x00;\r\ndata[3] = 0x00;\r\ndata[4] = (u8)(mdiv << 7);\r\nhorus3a_write_regs(priv, 0x00, data, sizeof(data));\r\nhorus3a_write_reg(priv, 0x09, (u8)((g_ctl << 5) | f_ctl));\r\nhorus3a_write_reg(priv, 0x37, (u8)(0x80 | (fc_lpf << 1)));\r\nhorus3a_write_reg(priv, 0x05, 0x80);\r\nhorus3a_write_reg(priv, 0x2a, 0x7b);\r\nmsleep(60);\r\npriv->frequency = ms * 2 * 1000 / mixdiv;\r\nreturn 0;\r\n}\r\nstatic int horus3a_get_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\nstruct horus3a_priv *priv = fe->tuner_priv;\r\n*frequency = priv->frequency;\r\nreturn 0;\r\n}\r\nstruct dvb_frontend *horus3a_attach(struct dvb_frontend *fe,\r\nconst struct horus3a_config *config,\r\nstruct i2c_adapter *i2c)\r\n{\r\nu8 buf[3], val;\r\nstruct horus3a_priv *priv = NULL;\r\npriv = kzalloc(sizeof(struct horus3a_priv), GFP_KERNEL);\r\nif (priv == NULL)\r\nreturn NULL;\r\npriv->i2c_address = (config->i2c_address >> 1);\r\npriv->i2c = i2c;\r\npriv->set_tuner_data = config->set_tuner_priv;\r\npriv->set_tuner = config->set_tuner_callback;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nusleep_range(4000, 6000);\r\nhorus3a_write_reg(priv, 0x2a, 0x79);\r\nbuf[0] = config->xtal_freq_mhz;\r\nbuf[1] = config->xtal_freq_mhz;\r\nbuf[2] = 0;\r\nhorus3a_write_regs(priv, 0x6, buf, 3);\r\nhorus3a_write_reg(priv, 0x0a, 0x40);\r\nswitch (config->xtal_freq_mhz) {\r\ncase 27:\r\nval = 0x1f;\r\nbreak;\r\ncase 24:\r\nval = 0x10;\r\nbreak;\r\ncase 16:\r\nval = 0xc;\r\nbreak;\r\ndefault:\r\nval = 0;\r\ndev_warn(&priv->i2c->dev,\r\n"horus3a: invalid xtal frequency %dMHz\n",\r\nconfig->xtal_freq_mhz);\r\nbreak;\r\n}\r\nval <<= 2;\r\nhorus3a_write_reg(priv, 0x0e, val);\r\nhorus3a_enter_power_save(priv);\r\nusleep_range(3000, 5000);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nmemcpy(&fe->ops.tuner_ops, &horus3a_tuner_ops,\r\nsizeof(struct dvb_tuner_ops));\r\nfe->tuner_priv = priv;\r\ndev_info(&priv->i2c->dev,\r\n"Sony HORUS3A attached on addr=%x at I2C adapter %p\n",\r\npriv->i2c_address, priv->i2c);\r\nreturn fe;\r\n}
