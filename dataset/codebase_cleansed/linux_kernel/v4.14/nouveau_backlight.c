static bool\r\nnouveau_get_backlight_name(char backlight_name[BL_NAME_SIZE], struct backlight_connector\r\n*connector)\r\n{\r\nconst int nb = ida_simple_get(&bl_ida, 0, 0, GFP_KERNEL);\r\nif (nb < 0 || nb >= 100)\r\nreturn false;\r\nif (nb > 0)\r\nsnprintf(backlight_name, BL_NAME_SIZE, "nv_backlight%d", nb);\r\nelse\r\nsnprintf(backlight_name, BL_NAME_SIZE, "nv_backlight");\r\nconnector->id = nb;\r\nreturn true;\r\n}\r\nstatic int\r\nnv40_get_intensity(struct backlight_device *bd)\r\n{\r\nstruct nouveau_drm *drm = bl_get_data(bd);\r\nstruct nvif_object *device = &drm->client.device.object;\r\nint val = (nvif_rd32(device, NV40_PMC_BACKLIGHT) &\r\nNV40_PMC_BACKLIGHT_MASK) >> 16;\r\nreturn val;\r\n}\r\nstatic int\r\nnv40_set_intensity(struct backlight_device *bd)\r\n{\r\nstruct nouveau_drm *drm = bl_get_data(bd);\r\nstruct nvif_object *device = &drm->client.device.object;\r\nint val = bd->props.brightness;\r\nint reg = nvif_rd32(device, NV40_PMC_BACKLIGHT);\r\nnvif_wr32(device, NV40_PMC_BACKLIGHT,\r\n(val << 16) | (reg & ~NV40_PMC_BACKLIGHT_MASK));\r\nreturn 0;\r\n}\r\nstatic int\r\nnv40_backlight_init(struct drm_connector *connector)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(connector->dev);\r\nstruct nvif_object *device = &drm->client.device.object;\r\nstruct backlight_properties props;\r\nstruct backlight_device *bd;\r\nstruct backlight_connector bl_connector;\r\nchar backlight_name[BL_NAME_SIZE];\r\nif (!(nvif_rd32(device, NV40_PMC_BACKLIGHT) & NV40_PMC_BACKLIGHT_MASK))\r\nreturn 0;\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.type = BACKLIGHT_RAW;\r\nprops.max_brightness = 31;\r\nif (!nouveau_get_backlight_name(backlight_name, &bl_connector)) {\r\nNV_ERROR(drm, "Failed to retrieve a unique name for the backlight interface\n");\r\nreturn 0;\r\n}\r\nbd = backlight_device_register(backlight_name , connector->kdev, drm,\r\n&nv40_bl_ops, &props);\r\nif (IS_ERR(bd)) {\r\nif (bl_connector.id > 0)\r\nida_simple_remove(&bl_ida, bl_connector.id);\r\nreturn PTR_ERR(bd);\r\n}\r\nlist_add(&bl_connector.head, &drm->bl_connectors);\r\ndrm->backlight = bd;\r\nbd->props.brightness = nv40_get_intensity(bd);\r\nbacklight_update_status(bd);\r\nreturn 0;\r\n}\r\nstatic int\r\nnv50_get_intensity(struct backlight_device *bd)\r\n{\r\nstruct nouveau_encoder *nv_encoder = bl_get_data(bd);\r\nstruct nouveau_drm *drm = nouveau_drm(nv_encoder->base.base.dev);\r\nstruct nvif_object *device = &drm->client.device.object;\r\nint or = nv_encoder->or;\r\nu32 div = 1025;\r\nu32 val;\r\nval = nvif_rd32(device, NV50_PDISP_SOR_PWM_CTL(or));\r\nval &= NV50_PDISP_SOR_PWM_CTL_VAL;\r\nreturn ((val * 100) + (div / 2)) / div;\r\n}\r\nstatic int\r\nnv50_set_intensity(struct backlight_device *bd)\r\n{\r\nstruct nouveau_encoder *nv_encoder = bl_get_data(bd);\r\nstruct nouveau_drm *drm = nouveau_drm(nv_encoder->base.base.dev);\r\nstruct nvif_object *device = &drm->client.device.object;\r\nint or = nv_encoder->or;\r\nu32 div = 1025;\r\nu32 val = (bd->props.brightness * div) / 100;\r\nnvif_wr32(device, NV50_PDISP_SOR_PWM_CTL(or),\r\nNV50_PDISP_SOR_PWM_CTL_NEW | val);\r\nreturn 0;\r\n}\r\nstatic int\r\nnva3_get_intensity(struct backlight_device *bd)\r\n{\r\nstruct nouveau_encoder *nv_encoder = bl_get_data(bd);\r\nstruct nouveau_drm *drm = nouveau_drm(nv_encoder->base.base.dev);\r\nstruct nvif_object *device = &drm->client.device.object;\r\nint or = nv_encoder->or;\r\nu32 div, val;\r\ndiv = nvif_rd32(device, NV50_PDISP_SOR_PWM_DIV(or));\r\nval = nvif_rd32(device, NV50_PDISP_SOR_PWM_CTL(or));\r\nval &= NVA3_PDISP_SOR_PWM_CTL_VAL;\r\nif (div && div >= val)\r\nreturn ((val * 100) + (div / 2)) / div;\r\nreturn 100;\r\n}\r\nstatic int\r\nnva3_set_intensity(struct backlight_device *bd)\r\n{\r\nstruct nouveau_encoder *nv_encoder = bl_get_data(bd);\r\nstruct nouveau_drm *drm = nouveau_drm(nv_encoder->base.base.dev);\r\nstruct nvif_object *device = &drm->client.device.object;\r\nint or = nv_encoder->or;\r\nu32 div, val;\r\ndiv = nvif_rd32(device, NV50_PDISP_SOR_PWM_DIV(or));\r\nval = (bd->props.brightness * div) / 100;\r\nif (div) {\r\nnvif_wr32(device, NV50_PDISP_SOR_PWM_CTL(or), val |\r\nNV50_PDISP_SOR_PWM_CTL_NEW |\r\nNVA3_PDISP_SOR_PWM_CTL_UNK);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\nnv50_backlight_init(struct drm_connector *connector)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(connector->dev);\r\nstruct nvif_object *device = &drm->client.device.object;\r\nstruct nouveau_encoder *nv_encoder;\r\nstruct backlight_properties props;\r\nstruct backlight_device *bd;\r\nconst struct backlight_ops *ops;\r\nstruct backlight_connector bl_connector;\r\nchar backlight_name[BL_NAME_SIZE];\r\nnv_encoder = find_encoder(connector, DCB_OUTPUT_LVDS);\r\nif (!nv_encoder) {\r\nnv_encoder = find_encoder(connector, DCB_OUTPUT_DP);\r\nif (!nv_encoder)\r\nreturn -ENODEV;\r\n}\r\nif (!nvif_rd32(device, NV50_PDISP_SOR_PWM_CTL(nv_encoder->or)))\r\nreturn 0;\r\nif (drm->client.device.info.chipset <= 0xa0 ||\r\ndrm->client.device.info.chipset == 0xaa ||\r\ndrm->client.device.info.chipset == 0xac)\r\nops = &nv50_bl_ops;\r\nelse\r\nops = &nva3_bl_ops;\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.type = BACKLIGHT_RAW;\r\nprops.max_brightness = 100;\r\nif (!nouveau_get_backlight_name(backlight_name, &bl_connector)) {\r\nNV_ERROR(drm, "Failed to retrieve a unique name for the backlight interface\n");\r\nreturn 0;\r\n}\r\nbd = backlight_device_register(backlight_name , connector->kdev,\r\nnv_encoder, ops, &props);\r\nif (IS_ERR(bd)) {\r\nif (bl_connector.id > 0)\r\nida_simple_remove(&bl_ida, bl_connector.id);\r\nreturn PTR_ERR(bd);\r\n}\r\nlist_add(&bl_connector.head, &drm->bl_connectors);\r\ndrm->backlight = bd;\r\nbd->props.brightness = bd->ops->get_brightness(bd);\r\nbacklight_update_status(bd);\r\nreturn 0;\r\n}\r\nint\r\nnouveau_backlight_init(struct drm_device *dev)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nvif_device *device = &drm->client.device;\r\nstruct drm_connector *connector;\r\nif (apple_gmux_present()) {\r\nNV_INFO(drm, "Apple GMUX detected: not registering Nouveau backlight interface\n");\r\nreturn 0;\r\n}\r\nINIT_LIST_HEAD(&drm->bl_connectors);\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\r\nif (connector->connector_type != DRM_MODE_CONNECTOR_LVDS &&\r\nconnector->connector_type != DRM_MODE_CONNECTOR_eDP)\r\ncontinue;\r\nswitch (device->info.family) {\r\ncase NV_DEVICE_INFO_V0_CURIE:\r\nreturn nv40_backlight_init(connector);\r\ncase NV_DEVICE_INFO_V0_TESLA:\r\ncase NV_DEVICE_INFO_V0_FERMI:\r\ncase NV_DEVICE_INFO_V0_KEPLER:\r\ncase NV_DEVICE_INFO_V0_MAXWELL:\r\nreturn nv50_backlight_init(connector);\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nnouveau_backlight_exit(struct drm_device *dev)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct backlight_connector *connector;\r\nlist_for_each_entry(connector, &drm->bl_connectors, head) {\r\nif (connector->id >= 0)\r\nida_simple_remove(&bl_ida, connector->id);\r\n}\r\nif (drm->backlight) {\r\nbacklight_device_unregister(drm->backlight);\r\ndrm->backlight = NULL;\r\n}\r\n}\r\nvoid\r\nnouveau_backlight_ctor(void)\r\n{\r\nida_init(&bl_ida);\r\n}\r\nvoid\r\nnouveau_backlight_dtor(void)\r\n{\r\nida_destroy(&bl_ida);\r\n}
