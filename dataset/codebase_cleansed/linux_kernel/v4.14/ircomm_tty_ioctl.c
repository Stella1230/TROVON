static void ircomm_tty_change_speed(struct ircomm_tty_cb *self,\r\nstruct tty_struct *tty)\r\n{\r\nunsigned int cflag, cval;\r\nint baud;\r\nif (!self->ircomm)\r\nreturn;\r\ncflag = tty->termios.c_cflag;\r\nswitch (cflag & CSIZE) {\r\ncase CS5: cval = IRCOMM_WSIZE_5; break;\r\ncase CS6: cval = IRCOMM_WSIZE_6; break;\r\ncase CS7: cval = IRCOMM_WSIZE_7; break;\r\ncase CS8: cval = IRCOMM_WSIZE_8; break;\r\ndefault: cval = IRCOMM_WSIZE_5; break;\r\n}\r\nif (cflag & CSTOPB)\r\ncval |= IRCOMM_2_STOP_BIT;\r\nif (cflag & PARENB)\r\ncval |= IRCOMM_PARITY_ENABLE;\r\nif (!(cflag & PARODD))\r\ncval |= IRCOMM_PARITY_EVEN;\r\nbaud = tty_get_baud_rate(tty);\r\nif (!baud)\r\nbaud = 9600;\r\nself->settings.data_rate = baud;\r\nircomm_param_request(self, IRCOMM_DATA_RATE, FALSE);\r\ntty_port_set_cts_flow(&self->port, cflag & CRTSCTS);\r\nif (cflag & CRTSCTS) {\r\nself->settings.flow_control |= IRCOMM_RTS_CTS_IN;\r\nif (self->service_type == IRCOMM_3_WIRE_RAW)\r\nnet_warn_ratelimited("%s(), enabling RTS/CTS on link that doesn't support it (3-wire-raw)\n",\r\n__func__);\r\n} else {\r\nself->settings.flow_control &= ~IRCOMM_RTS_CTS_IN;\r\n}\r\ntty_port_set_check_carrier(&self->port, ~cflag & CLOCAL);\r\nself->settings.data_format = cval;\r\nircomm_param_request(self, IRCOMM_DATA_FORMAT, FALSE);\r\nircomm_param_request(self, IRCOMM_FLOW_CONTROL, TRUE);\r\n}\r\nvoid ircomm_tty_set_termios(struct tty_struct *tty,\r\nstruct ktermios *old_termios)\r\n{\r\nstruct ircomm_tty_cb *self = (struct ircomm_tty_cb *) tty->driver_data;\r\nunsigned int cflag = tty->termios.c_cflag;\r\nif ((cflag == old_termios->c_cflag) &&\r\n(RELEVANT_IFLAG(tty->termios.c_iflag) ==\r\nRELEVANT_IFLAG(old_termios->c_iflag)))\r\n{\r\nreturn;\r\n}\r\nircomm_tty_change_speed(self, tty);\r\nif ((old_termios->c_cflag & CBAUD) && !(cflag & CBAUD)) {\r\nself->settings.dte &= ~(IRCOMM_DTR|IRCOMM_RTS);\r\nircomm_param_request(self, IRCOMM_DTE, TRUE);\r\n}\r\nif (!(old_termios->c_cflag & CBAUD) && (cflag & CBAUD)) {\r\nself->settings.dte |= IRCOMM_DTR;\r\nif (!C_CRTSCTS(tty) || !tty_throttled(tty))\r\nself->settings.dte |= IRCOMM_RTS;\r\nircomm_param_request(self, IRCOMM_DTE, TRUE);\r\n}\r\nif ((old_termios->c_cflag & CRTSCTS) && !C_CRTSCTS(tty))\r\n{\r\ntty->hw_stopped = 0;\r\nircomm_tty_start(tty);\r\n}\r\n}\r\nint ircomm_tty_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct ircomm_tty_cb *self = (struct ircomm_tty_cb *) tty->driver_data;\r\nunsigned int result;\r\nif (tty_io_error(tty))\r\nreturn -EIO;\r\nresult = ((self->settings.dte & IRCOMM_RTS) ? TIOCM_RTS : 0)\r\n| ((self->settings.dte & IRCOMM_DTR) ? TIOCM_DTR : 0)\r\n| ((self->settings.dce & IRCOMM_CD) ? TIOCM_CAR : 0)\r\n| ((self->settings.dce & IRCOMM_RI) ? TIOCM_RNG : 0)\r\n| ((self->settings.dce & IRCOMM_DSR) ? TIOCM_DSR : 0)\r\n| ((self->settings.dce & IRCOMM_CTS) ? TIOCM_CTS : 0);\r\nreturn result;\r\n}\r\nint ircomm_tty_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct ircomm_tty_cb *self = (struct ircomm_tty_cb *) tty->driver_data;\r\nif (tty_io_error(tty))\r\nreturn -EIO;\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == IRCOMM_TTY_MAGIC, return -1;);\r\nif (set & TIOCM_RTS)\r\nself->settings.dte |= IRCOMM_RTS;\r\nif (set & TIOCM_DTR)\r\nself->settings.dte |= IRCOMM_DTR;\r\nif (clear & TIOCM_RTS)\r\nself->settings.dte &= ~IRCOMM_RTS;\r\nif (clear & TIOCM_DTR)\r\nself->settings.dte &= ~IRCOMM_DTR;\r\nif ((set|clear) & TIOCM_RTS)\r\nself->settings.dte |= IRCOMM_DELTA_RTS;\r\nif ((set|clear) & TIOCM_DTR)\r\nself->settings.dte |= IRCOMM_DELTA_DTR;\r\nircomm_param_request(self, IRCOMM_DTE, TRUE);\r\nreturn 0;\r\n}\r\nstatic int ircomm_tty_get_serial_info(struct ircomm_tty_cb *self,\r\nstruct serial_struct __user *retinfo)\r\n{\r\nstruct serial_struct info;\r\nmemset(&info, 0, sizeof(info));\r\ninfo.line = self->line;\r\ninfo.flags = self->port.flags;\r\ninfo.baud_base = self->settings.data_rate;\r\ninfo.close_delay = self->port.close_delay;\r\ninfo.closing_wait = self->port.closing_wait;\r\ninfo.type = PORT_16550A;\r\nif (copy_to_user(retinfo, &info, sizeof(*retinfo)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int ircomm_tty_set_serial_info(struct ircomm_tty_cb *self,\r\nstruct serial_struct __user *new_info)\r\n{\r\nreturn 0;\r\n}\r\nint ircomm_tty_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct ircomm_tty_cb *self = (struct ircomm_tty_cb *) tty->driver_data;\r\nint ret = 0;\r\nif ((cmd != TIOCGSERIAL) && (cmd != TIOCSSERIAL) &&\r\n(cmd != TIOCSERCONFIG) && (cmd != TIOCSERGSTRUCT) &&\r\n(cmd != TIOCMIWAIT) && (cmd != TIOCGICOUNT)) {\r\nif (tty_io_error(tty))\r\nreturn -EIO;\r\n}\r\nswitch (cmd) {\r\ncase TIOCGSERIAL:\r\nret = ircomm_tty_get_serial_info(self, (struct serial_struct __user *) arg);\r\nbreak;\r\ncase TIOCSSERIAL:\r\nret = ircomm_tty_set_serial_info(self, (struct serial_struct __user *) arg);\r\nbreak;\r\ncase TIOCMIWAIT:\r\npr_debug("(), TIOCMIWAIT, not impl!\n");\r\nbreak;\r\ncase TIOCGICOUNT:\r\npr_debug("%s(), TIOCGICOUNT not impl!\n", __func__);\r\nreturn 0;\r\ndefault:\r\nret = -ENOIOCTLCMD;\r\n}\r\nreturn ret;\r\n}
