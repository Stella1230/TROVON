static void dm_rx_hw_antena_div_init(struct odm_dm_struct *dm_odm)\r\n{\r\nstruct adapter *adapter = dm_odm->Adapter;\r\nu32 value32;\r\nif (*(dm_odm->mp_mode) == 1) {\r\ndm_odm->AntDivType = CGCS_RX_SW_ANTDIV;\r\nphy_set_bb_reg(adapter, ODM_REG_IGI_A_11N, BIT(7), 0);\r\nphy_set_bb_reg(adapter, ODM_REG_LNA_SWITCH_11N, BIT(31), 1);\r\nreturn;\r\n}\r\nvalue32 = phy_query_bb_reg(adapter, ODM_REG_ANTSEL_PIN_11N, bMaskDWord);\r\nphy_set_bb_reg(adapter, ODM_REG_ANTSEL_PIN_11N, bMaskDWord,\r\nvalue32|(BIT(23) | BIT(25)));\r\nphy_set_bb_reg(adapter, ODM_REG_PIN_CTRL_11N, BIT(9) | BIT(8), 0);\r\nphy_set_bb_reg(adapter, ODM_REG_RX_ANT_CTRL_11N, BIT(10), 0);\r\nphy_set_bb_reg(adapter, ODM_REG_LNA_SWITCH_11N, BIT(22), 1);\r\nphy_set_bb_reg(adapter, ODM_REG_LNA_SWITCH_11N, BIT(31), 1);\r\nphy_set_bb_reg(adapter, ODM_REG_ANTDIV_PARA1_11N, bMaskDWord,\r\n0x000000a0);\r\nphy_set_bb_reg(adapter, ODM_REG_BB_PWR_SAV4_11N, BIT(7), 1);\r\nphy_set_bb_reg(adapter, ODM_REG_CCK_ANTDIV_PARA2_11N, BIT(4), 1);\r\nrtl88eu_dm_update_rx_idle_ant(dm_odm, MAIN_ANT);\r\nphy_set_bb_reg(adapter, ODM_REG_ANT_MAPPING1_11N, 0xFFFF, 0x0201);\r\n}\r\nstatic void dm_trx_hw_antenna_div_init(struct odm_dm_struct *dm_odm)\r\n{\r\nstruct adapter *adapter = dm_odm->Adapter;\r\nu32 value32;\r\nif (*(dm_odm->mp_mode) == 1) {\r\ndm_odm->AntDivType = CGCS_RX_SW_ANTDIV;\r\nphy_set_bb_reg(adapter, ODM_REG_IGI_A_11N, BIT(7), 0);\r\nphy_set_bb_reg(adapter, ODM_REG_RX_ANT_CTRL_11N,\r\nBIT(5) | BIT(4) | BIT(3), 0);\r\nreturn;\r\n}\r\nvalue32 = phy_query_bb_reg(adapter, ODM_REG_ANTSEL_PIN_11N, bMaskDWord);\r\nphy_set_bb_reg(adapter, ODM_REG_ANTSEL_PIN_11N, bMaskDWord,\r\nvalue32|(BIT(23) | BIT(25)));\r\nphy_set_bb_reg(adapter, ODM_REG_PIN_CTRL_11N, BIT(9) | BIT(8), 0);\r\nphy_set_bb_reg(adapter, ODM_REG_RX_ANT_CTRL_11N, BIT(10), 0);\r\nphy_set_bb_reg(adapter, ODM_REG_LNA_SWITCH_11N, BIT(22), 0);\r\nphy_set_bb_reg(adapter, ODM_REG_LNA_SWITCH_11N, BIT(31), 1);\r\nphy_set_bb_reg(adapter, ODM_REG_ANTDIV_PARA1_11N, bMaskDWord,\r\n0x000000a0);\r\nphy_set_bb_reg(adapter, ODM_REG_BB_PWR_SAV4_11N, BIT(7), 1);\r\nphy_set_bb_reg(adapter, ODM_REG_CCK_ANTDIV_PARA2_11N, BIT(4), 1);\r\nphy_set_bb_reg(adapter, ODM_REG_TX_ANT_CTRL_11N, BIT(21), 0);\r\nrtl88eu_dm_update_rx_idle_ant(dm_odm, MAIN_ANT);\r\nif (!dm_odm->bIsMPChip) {\r\nphy_set_bb_reg(adapter, ODM_REG_RX_DEFAULT_A_11N,\r\nBIT(10) | BIT(9) | BIT(8), 1);\r\nphy_set_bb_reg(adapter, ODM_REG_RX_DEFAULT_A_11N,\r\nBIT(13) | BIT(12) | BIT(11), 2);\r\n} else {\r\nphy_set_bb_reg(adapter, ODM_REG_ANT_MAPPING1_11N, bMaskDWord,\r\n0x0201);\r\n}\r\n}\r\nstatic void dm_fast_training_init(struct odm_dm_struct *dm_odm)\r\n{\r\nstruct adapter *adapter = dm_odm->Adapter;\r\nu32 value32, i;\r\nstruct fast_ant_train *dm_fat_tbl = &dm_odm->DM_FatTable;\r\nu32 AntCombination = 2;\r\nif (*(dm_odm->mp_mode) == 1) {\r\nreturn;\r\n}\r\nfor (i = 0; i < 6; i++) {\r\ndm_fat_tbl->Bssid[i] = 0;\r\ndm_fat_tbl->antSumRSSI[i] = 0;\r\ndm_fat_tbl->antRSSIcnt[i] = 0;\r\ndm_fat_tbl->antAveRSSI[i] = 0;\r\n}\r\ndm_fat_tbl->TrainIdx = 0;\r\ndm_fat_tbl->FAT_State = FAT_NORMAL_STATE;\r\nvalue32 = phy_query_bb_reg(adapter, 0x4c, bMaskDWord);\r\nphy_set_bb_reg(adapter, 0x4c, bMaskDWord, value32|(BIT(23) | BIT(25)));\r\nvalue32 = phy_query_bb_reg(adapter, 0x7B4, bMaskDWord);\r\nphy_set_bb_reg(adapter, 0x7b4, bMaskDWord, value32|(BIT(16) | BIT(17)));\r\nphy_set_bb_reg(adapter, 0x7b4, 0xFFFF, 0);\r\nphy_set_bb_reg(adapter, 0x7b0, bMaskDWord, 0);\r\nphy_set_bb_reg(adapter, 0x870, BIT(9) | BIT(8), 0);\r\nphy_set_bb_reg(adapter, 0x864, BIT(10), 0);\r\nphy_set_bb_reg(adapter, 0xb2c, BIT(22), 0);\r\nphy_set_bb_reg(adapter, 0xb2c, BIT(31), 1);\r\nphy_set_bb_reg(adapter, 0xca4, bMaskDWord, 0x000000a0);\r\nif (AntCombination == 2) {\r\nif (!dm_odm->bIsMPChip) {\r\nphy_set_bb_reg(adapter, 0x858, BIT(10) | BIT(9) | BIT(8), 1);\r\nphy_set_bb_reg(adapter, 0x858, BIT(13) | BIT(12) | BIT(11), 2);\r\n} else {\r\nphy_set_bb_reg(adapter, 0x914, bMaskByte0, 1);\r\nphy_set_bb_reg(adapter, 0x914, bMaskByte1, 2);\r\n}\r\n} else if (AntCombination == 7) {\r\nif (!dm_odm->bIsMPChip) {\r\nphy_set_bb_reg(adapter, 0x858, BIT(10) | BIT(9) | BIT(8), 0);\r\nphy_set_bb_reg(adapter, 0x858, BIT(13) | BIT(12) | BIT(11), 1);\r\nphy_set_bb_reg(adapter, 0x878, BIT(16), 0);\r\nphy_set_bb_reg(adapter, 0x858, BIT(15) | BIT(14), 2);\r\nphy_set_bb_reg(adapter, 0x878, BIT(19) | BIT(18) | BIT(17), 3);\r\nphy_set_bb_reg(adapter, 0x878, BIT(22) | BIT(21) | BIT(20), 4);\r\nphy_set_bb_reg(adapter, 0x878, BIT(25) | BIT(24) | BIT(23), 5);\r\nphy_set_bb_reg(adapter, 0x878, BIT(28) | BIT(27) | BIT(26), 6);\r\nphy_set_bb_reg(adapter, 0x878, BIT(31) | BIT(30) | BIT(29), 7);\r\n} else {\r\nphy_set_bb_reg(adapter, 0x914, bMaskByte0, 0);\r\nphy_set_bb_reg(adapter, 0x914, bMaskByte1, 1);\r\nphy_set_bb_reg(adapter, 0x914, bMaskByte2, 2);\r\nphy_set_bb_reg(adapter, 0x914, bMaskByte3, 3);\r\nphy_set_bb_reg(adapter, 0x918, bMaskByte0, 4);\r\nphy_set_bb_reg(adapter, 0x918, bMaskByte1, 5);\r\nphy_set_bb_reg(adapter, 0x918, bMaskByte2, 6);\r\nphy_set_bb_reg(adapter, 0x918, bMaskByte3, 7);\r\n}\r\n}\r\nphy_set_bb_reg(adapter, 0x80c, BIT(21), 1);\r\nphy_set_bb_reg(adapter, 0x864, BIT(5) | BIT(4) | BIT(3), 0);\r\nphy_set_bb_reg(adapter, 0x864, BIT(8) | BIT(7) | BIT(6), 1);\r\nphy_set_bb_reg(adapter, 0x864, BIT(2) | BIT(1) | BIT(0), (AntCombination-1));\r\nphy_set_bb_reg(adapter, 0xc50, BIT(7), 1);\r\n}\r\nvoid rtl88eu_dm_antenna_div_init(struct odm_dm_struct *dm_odm)\r\n{\r\nif (dm_odm->AntDivType == CGCS_RX_HW_ANTDIV)\r\ndm_rx_hw_antena_div_init(dm_odm);\r\nelse if (dm_odm->AntDivType == CG_TRX_HW_ANTDIV)\r\ndm_trx_hw_antenna_div_init(dm_odm);\r\nelse if (dm_odm->AntDivType == CG_TRX_SMART_ANTDIV)\r\ndm_fast_training_init(dm_odm);\r\n}\r\nvoid rtl88eu_dm_update_rx_idle_ant(struct odm_dm_struct *dm_odm, u8 ant)\r\n{\r\nstruct fast_ant_train *dm_fat_tbl = &dm_odm->DM_FatTable;\r\nstruct adapter *adapter = dm_odm->Adapter;\r\nu32 default_ant, optional_ant;\r\nif (dm_fat_tbl->RxIdleAnt != ant) {\r\nif (ant == MAIN_ANT) {\r\ndefault_ant = (dm_odm->AntDivType == CG_TRX_HW_ANTDIV) ?\r\nMAIN_ANT_CG_TRX : MAIN_ANT_CGCS_RX;\r\noptional_ant = (dm_odm->AntDivType == CG_TRX_HW_ANTDIV) ?\r\nAUX_ANT_CG_TRX : AUX_ANT_CGCS_RX;\r\n} else {\r\ndefault_ant = (dm_odm->AntDivType == CG_TRX_HW_ANTDIV) ?\r\nAUX_ANT_CG_TRX : AUX_ANT_CGCS_RX;\r\noptional_ant = (dm_odm->AntDivType == CG_TRX_HW_ANTDIV) ?\r\nMAIN_ANT_CG_TRX : MAIN_ANT_CGCS_RX;\r\n}\r\nif (dm_odm->AntDivType == CG_TRX_HW_ANTDIV) {\r\nphy_set_bb_reg(adapter, ODM_REG_RX_ANT_CTRL_11N,\r\nBIT(5) | BIT(4) | BIT(3), default_ant);\r\nphy_set_bb_reg(adapter, ODM_REG_RX_ANT_CTRL_11N,\r\nBIT(8) | BIT(7) | BIT(6), optional_ant);\r\nphy_set_bb_reg(adapter, ODM_REG_ANTSEL_CTRL_11N,\r\nBIT(14) | BIT(13) | BIT(12), default_ant);\r\nphy_set_bb_reg(adapter, ODM_REG_RESP_TX_11N,\r\nBIT(6) | BIT(7), default_ant);\r\n} else if (dm_odm->AntDivType == CGCS_RX_HW_ANTDIV) {\r\nphy_set_bb_reg(adapter, ODM_REG_RX_ANT_CTRL_11N,\r\nBIT(5) | BIT(4) | BIT(3), default_ant);\r\nphy_set_bb_reg(adapter, ODM_REG_RX_ANT_CTRL_11N,\r\nBIT(8) | BIT(7) | BIT(6), optional_ant);\r\n}\r\n}\r\ndm_fat_tbl->RxIdleAnt = ant;\r\n}\r\nstatic void update_tx_ant_88eu(struct odm_dm_struct *dm_odm, u8 ant, u32 mac_id)\r\n{\r\nstruct fast_ant_train *dm_fat_tbl = &dm_odm->DM_FatTable;\r\nu8 target_ant;\r\nif (ant == MAIN_ANT)\r\ntarget_ant = MAIN_ANT_CG_TRX;\r\nelse\r\ntarget_ant = AUX_ANT_CG_TRX;\r\ndm_fat_tbl->antsel_a[mac_id] = target_ant & BIT(0);\r\ndm_fat_tbl->antsel_b[mac_id] = (target_ant & BIT(1))>>1;\r\ndm_fat_tbl->antsel_c[mac_id] = (target_ant & BIT(2))>>2;\r\n}\r\nvoid rtl88eu_dm_set_tx_ant_by_tx_info(struct odm_dm_struct *dm_odm,\r\nu8 *desc, u8 mac_id)\r\n{\r\nstruct fast_ant_train *dm_fat_tbl = &dm_odm->DM_FatTable;\r\nif ((dm_odm->AntDivType == CG_TRX_HW_ANTDIV) ||\r\n(dm_odm->AntDivType == CG_TRX_SMART_ANTDIV)) {\r\nSET_TX_DESC_ANTSEL_A_88E(desc, dm_fat_tbl->antsel_a[mac_id]);\r\nSET_TX_DESC_ANTSEL_B_88E(desc, dm_fat_tbl->antsel_b[mac_id]);\r\nSET_TX_DESC_ANTSEL_C_88E(desc, dm_fat_tbl->antsel_c[mac_id]);\r\n}\r\n}\r\nvoid rtl88eu_dm_ant_sel_statistics(struct odm_dm_struct *dm_odm,\r\nu8 antsel_tr_mux, u32 mac_id, u8 rx_pwdb_all)\r\n{\r\nstruct fast_ant_train *dm_fat_tbl = &dm_odm->DM_FatTable;\r\nif (dm_odm->AntDivType == CG_TRX_HW_ANTDIV) {\r\nif (antsel_tr_mux == MAIN_ANT_CG_TRX) {\r\ndm_fat_tbl->MainAnt_Sum[mac_id] += rx_pwdb_all;\r\ndm_fat_tbl->MainAnt_Cnt[mac_id]++;\r\n} else {\r\ndm_fat_tbl->AuxAnt_Sum[mac_id] += rx_pwdb_all;\r\ndm_fat_tbl->AuxAnt_Cnt[mac_id]++;\r\n}\r\n} else if (dm_odm->AntDivType == CGCS_RX_HW_ANTDIV) {\r\nif (antsel_tr_mux == MAIN_ANT_CGCS_RX) {\r\ndm_fat_tbl->MainAnt_Sum[mac_id] += rx_pwdb_all;\r\ndm_fat_tbl->MainAnt_Cnt[mac_id]++;\r\n} else {\r\ndm_fat_tbl->AuxAnt_Sum[mac_id] += rx_pwdb_all;\r\ndm_fat_tbl->AuxAnt_Cnt[mac_id]++;\r\n}\r\n}\r\n}\r\nstatic void rtl88eu_dm_hw_ant_div(struct odm_dm_struct *dm_odm)\r\n{\r\nstruct fast_ant_train *dm_fat_tbl = &dm_odm->DM_FatTable;\r\nstruct rtw_dig *dig_table = &dm_odm->DM_DigTable;\r\nstruct sta_info *entry;\r\nu32 i, min_rssi = 0xFF, ant_div_max_rssi = 0, max_rssi = 0;\r\nu32 local_min_rssi, local_max_rssi;\r\nu32 main_rssi, aux_rssi;\r\nu8 RxIdleAnt = 0, target_ant = 7;\r\nfor (i = 0; i < ODM_ASSOCIATE_ENTRY_NUM; i++) {\r\nentry = dm_odm->pODM_StaInfo[i];\r\nif (IS_STA_VALID(entry)) {\r\nmain_rssi = (dm_fat_tbl->MainAnt_Cnt[i] != 0) ?\r\n(dm_fat_tbl->MainAnt_Sum[i]/dm_fat_tbl->MainAnt_Cnt[i]) : 0;\r\naux_rssi = (dm_fat_tbl->AuxAnt_Cnt[i] != 0) ?\r\n(dm_fat_tbl->AuxAnt_Sum[i]/dm_fat_tbl->AuxAnt_Cnt[i]) : 0;\r\ntarget_ant = (main_rssi >= aux_rssi) ? MAIN_ANT : AUX_ANT;\r\nlocal_max_rssi = max(main_rssi, aux_rssi);\r\nif ((local_max_rssi > ant_div_max_rssi) &&\r\n(local_max_rssi < 40))\r\nant_div_max_rssi = local_max_rssi;\r\nif (local_max_rssi > max_rssi)\r\nmax_rssi = local_max_rssi;\r\nif ((dm_fat_tbl->RxIdleAnt == MAIN_ANT) &&\r\n(main_rssi == 0))\r\nmain_rssi = aux_rssi;\r\nelse if ((dm_fat_tbl->RxIdleAnt == AUX_ANT) &&\r\n(aux_rssi == 0))\r\naux_rssi = main_rssi;\r\nlocal_min_rssi = min(main_rssi, aux_rssi);\r\nif (local_min_rssi < min_rssi) {\r\nmin_rssi = local_min_rssi;\r\nRxIdleAnt = target_ant;\r\n}\r\nif (dm_odm->AntDivType == CG_TRX_HW_ANTDIV)\r\nupdate_tx_ant_88eu(dm_odm, target_ant, i);\r\n}\r\ndm_fat_tbl->MainAnt_Sum[i] = 0;\r\ndm_fat_tbl->AuxAnt_Sum[i] = 0;\r\ndm_fat_tbl->MainAnt_Cnt[i] = 0;\r\ndm_fat_tbl->AuxAnt_Cnt[i] = 0;\r\n}\r\nrtl88eu_dm_update_rx_idle_ant(dm_odm, RxIdleAnt);\r\ndig_table->AntDiv_RSSI_max = ant_div_max_rssi;\r\ndig_table->RSSI_max = max_rssi;\r\n}\r\nvoid rtl88eu_dm_antenna_diversity(struct odm_dm_struct *dm_odm)\r\n{\r\nstruct fast_ant_train *dm_fat_tbl = &dm_odm->DM_FatTable;\r\nstruct adapter *adapter = dm_odm->Adapter;\r\nif (!(dm_odm->SupportAbility & ODM_BB_ANT_DIV))\r\nreturn;\r\nif (!dm_odm->bLinked) {\r\nODM_RT_TRACE(dm_odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD,\r\n("ODM_AntennaDiversity_88E(): No Link.\n"));\r\nif (dm_fat_tbl->bBecomeLinked) {\r\nODM_RT_TRACE(dm_odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD,\r\n("Need to Turn off HW AntDiv\n"));\r\nphy_set_bb_reg(adapter, ODM_REG_IGI_A_11N, BIT(7), 0);\r\nphy_set_bb_reg(adapter, ODM_REG_CCK_ANTDIV_PARA1_11N,\r\nBIT(15), 0);\r\nif (dm_odm->AntDivType == CG_TRX_HW_ANTDIV)\r\nphy_set_bb_reg(adapter, ODM_REG_TX_ANT_CTRL_11N,\r\nBIT(21), 0);\r\ndm_fat_tbl->bBecomeLinked = dm_odm->bLinked;\r\n}\r\nreturn;\r\n} else {\r\nif (!dm_fat_tbl->bBecomeLinked) {\r\nODM_RT_TRACE(dm_odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD,\r\n("Need to Turn on HW AntDiv\n"));\r\nphy_set_bb_reg(adapter, ODM_REG_IGI_A_11N, BIT(7), 1);\r\nphy_set_bb_reg(adapter, ODM_REG_CCK_ANTDIV_PARA1_11N,\r\nBIT(15), 1);\r\nif (dm_odm->AntDivType == CG_TRX_HW_ANTDIV)\r\nphy_set_bb_reg(adapter, ODM_REG_TX_ANT_CTRL_11N,\r\nBIT(21), 1);\r\ndm_fat_tbl->bBecomeLinked = dm_odm->bLinked;\r\n}\r\n}\r\nif ((dm_odm->AntDivType == CG_TRX_HW_ANTDIV) ||\r\n(dm_odm->AntDivType == CGCS_RX_HW_ANTDIV))\r\nrtl88eu_dm_hw_ant_div(dm_odm);\r\n}
