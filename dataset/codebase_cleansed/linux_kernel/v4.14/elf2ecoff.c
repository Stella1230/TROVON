static void copy(int out, int in, off_t offset, off_t size)\r\n{\r\nchar ibuf[4096];\r\nint remaining, cur, count;\r\nif (lseek(in, offset, SEEK_SET) < 0) {\r\nperror("copy: lseek");\r\nexit(1);\r\n}\r\nremaining = size;\r\nwhile (remaining) {\r\ncur = remaining;\r\nif (cur > sizeof ibuf)\r\ncur = sizeof ibuf;\r\nremaining -= cur;\r\nif ((count = read(in, ibuf, cur)) != cur) {\r\nfprintf(stderr, "copy: read: %s\n",\r\ncount ? strerror(errno) :\r\n"premature end of file");\r\nexit(1);\r\n}\r\nif ((count = write(out, ibuf, cur)) != cur) {\r\nperror("copy: write");\r\nexit(1);\r\n}\r\n}\r\n}\r\nstatic void combine(struct sect *base, struct sect *new, int pad)\r\n{\r\nif (!base->len)\r\n*base = *new;\r\nelse if (new->len) {\r\nif (base->vaddr + base->len != new->vaddr) {\r\nif (pad)\r\nbase->len = new->vaddr - base->vaddr;\r\nelse {\r\nfprintf(stderr,\r\n"Non-contiguous data can't be converted.\n");\r\nexit(1);\r\n}\r\n}\r\nbase->len += new->len;\r\n}\r\n}\r\nstatic int phcmp(const void *v1, const void *v2)\r\n{\r\nconst Elf32_Phdr *h1 = v1;\r\nconst Elf32_Phdr *h2 = v2;\r\nif (h1->p_vaddr > h2->p_vaddr)\r\nreturn 1;\r\nelse if (h1->p_vaddr < h2->p_vaddr)\r\nreturn -1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic char *saveRead(int file, off_t offset, off_t len, char *name)\r\n{\r\nchar *tmp;\r\nint count;\r\noff_t off;\r\nif ((off = lseek(file, offset, SEEK_SET)) < 0) {\r\nfprintf(stderr, "%s: fseek: %s\n", name, strerror(errno));\r\nexit(1);\r\n}\r\nif (!(tmp = (char *) malloc(len))) {\r\nfprintf(stderr, "%s: Can't allocate %ld bytes.\n", name,\r\nlen);\r\nexit(1);\r\n}\r\ncount = read(file, tmp, len);\r\nif (count != len) {\r\nfprintf(stderr, "%s: read: %s.\n",\r\nname,\r\ncount ? strerror(errno) : "End of file reached");\r\nexit(1);\r\n}\r\nreturn tmp;\r\n}\r\nstatic void convert_elf_hdr(Elf32_Ehdr * e)\r\n{\r\ne->e_type = swab16(e->e_type);\r\ne->e_machine = swab16(e->e_machine);\r\ne->e_version = swab32(e->e_version);\r\ne->e_entry = swab32(e->e_entry);\r\ne->e_phoff = swab32(e->e_phoff);\r\ne->e_shoff = swab32(e->e_shoff);\r\ne->e_flags = swab32(e->e_flags);\r\ne->e_ehsize = swab16(e->e_ehsize);\r\ne->e_phentsize = swab16(e->e_phentsize);\r\ne->e_phnum = swab16(e->e_phnum);\r\ne->e_shentsize = swab16(e->e_shentsize);\r\ne->e_shnum = swab16(e->e_shnum);\r\ne->e_shstrndx = swab16(e->e_shstrndx);\r\n}\r\nstatic void convert_elf_phdrs(Elf32_Phdr * p, int num)\r\n{\r\nint i;\r\nfor (i = 0; i < num; i++, p++) {\r\np->p_type = swab32(p->p_type);\r\np->p_offset = swab32(p->p_offset);\r\np->p_vaddr = swab32(p->p_vaddr);\r\np->p_paddr = swab32(p->p_paddr);\r\np->p_filesz = swab32(p->p_filesz);\r\np->p_memsz = swab32(p->p_memsz);\r\np->p_flags = swab32(p->p_flags);\r\np->p_align = swab32(p->p_align);\r\n}\r\n}\r\nstatic void convert_elf_shdrs(Elf32_Shdr * s, int num)\r\n{\r\nint i;\r\nfor (i = 0; i < num; i++, s++) {\r\ns->sh_name = swab32(s->sh_name);\r\ns->sh_type = swab32(s->sh_type);\r\ns->sh_flags = swab32(s->sh_flags);\r\ns->sh_addr = swab32(s->sh_addr);\r\ns->sh_offset = swab32(s->sh_offset);\r\ns->sh_size = swab32(s->sh_size);\r\ns->sh_link = swab32(s->sh_link);\r\ns->sh_info = swab32(s->sh_info);\r\ns->sh_addralign = swab32(s->sh_addralign);\r\ns->sh_entsize = swab32(s->sh_entsize);\r\n}\r\n}\r\nstatic void convert_ecoff_filehdr(struct filehdr *f)\r\n{\r\nf->f_magic = swab16(f->f_magic);\r\nf->f_nscns = swab16(f->f_nscns);\r\nf->f_timdat = swab32(f->f_timdat);\r\nf->f_symptr = swab32(f->f_symptr);\r\nf->f_nsyms = swab32(f->f_nsyms);\r\nf->f_opthdr = swab16(f->f_opthdr);\r\nf->f_flags = swab16(f->f_flags);\r\n}\r\nstatic void convert_ecoff_aouthdr(struct aouthdr *a)\r\n{\r\na->magic = swab16(a->magic);\r\na->vstamp = swab16(a->vstamp);\r\na->tsize = swab32(a->tsize);\r\na->dsize = swab32(a->dsize);\r\na->bsize = swab32(a->bsize);\r\na->entry = swab32(a->entry);\r\na->text_start = swab32(a->text_start);\r\na->data_start = swab32(a->data_start);\r\na->bss_start = swab32(a->bss_start);\r\na->gprmask = swab32(a->gprmask);\r\na->cprmask[0] = swab32(a->cprmask[0]);\r\na->cprmask[1] = swab32(a->cprmask[1]);\r\na->cprmask[2] = swab32(a->cprmask[2]);\r\na->cprmask[3] = swab32(a->cprmask[3]);\r\na->gp_value = swab32(a->gp_value);\r\n}\r\nstatic void convert_ecoff_esecs(struct scnhdr *s, int num)\r\n{\r\nint i;\r\nfor (i = 0; i < num; i++, s++) {\r\ns->s_paddr = swab32(s->s_paddr);\r\ns->s_vaddr = swab32(s->s_vaddr);\r\ns->s_size = swab32(s->s_size);\r\ns->s_scnptr = swab32(s->s_scnptr);\r\ns->s_relptr = swab32(s->s_relptr);\r\ns->s_lnnoptr = swab32(s->s_lnnoptr);\r\ns->s_nreloc = swab16(s->s_nreloc);\r\ns->s_nlnno = swab16(s->s_nlnno);\r\ns->s_flags = swab32(s->s_flags);\r\n}\r\n}\r\nint main(int argc, char *argv[])\r\n{\r\nElf32_Ehdr ex;\r\nElf32_Phdr *ph;\r\nElf32_Shdr *sh;\r\nint i, pad;\r\nstruct sect text, data, bss;\r\nstruct filehdr efh;\r\nstruct aouthdr eah;\r\nstruct scnhdr esecs[6];\r\nint infile, outfile;\r\nunsigned long cur_vma = ULONG_MAX;\r\nint addflag = 0;\r\nint nosecs;\r\ntext.len = data.len = bss.len = 0;\r\ntext.vaddr = data.vaddr = bss.vaddr = 0;\r\nif (argc < 3 || argc > 4) {\r\nusage:\r\nfprintf(stderr,\r\n"usage: elf2ecoff <elf executable> <ecoff executable> [-a]\n");\r\nexit(1);\r\n}\r\nif (argc == 4) {\r\nif (strcmp(argv[3], "-a"))\r\ngoto usage;\r\naddflag = 1;\r\n}\r\nif ((infile = open(argv[1], O_RDONLY)) < 0) {\r\nfprintf(stderr, "Can't open %s for read: %s\n",\r\nargv[1], strerror(errno));\r\nexit(1);\r\n}\r\ni = read(infile, &ex, sizeof ex);\r\nif (i != sizeof ex) {\r\nfprintf(stderr, "ex: %s: %s.\n",\r\nargv[1],\r\ni ? strerror(errno) : "End of file reached");\r\nexit(1);\r\n}\r\nif (ex.e_ident[EI_DATA] == ELFDATA2MSB)\r\nformat_bigendian = 1;\r\nif (ntohs(0xaa55) == 0xaa55) {\r\nif (!format_bigendian)\r\nmust_convert_endian = 1;\r\n} else {\r\nif (format_bigendian)\r\nmust_convert_endian = 1;\r\n}\r\nif (must_convert_endian)\r\nconvert_elf_hdr(&ex);\r\nph = (Elf32_Phdr *) saveRead(infile, ex.e_phoff,\r\nex.e_phnum * sizeof(Elf32_Phdr),\r\n"ph");\r\nif (must_convert_endian)\r\nconvert_elf_phdrs(ph, ex.e_phnum);\r\nsh = (Elf32_Shdr *) saveRead(infile, ex.e_shoff,\r\nex.e_shnum * sizeof(Elf32_Shdr),\r\n"sh");\r\nif (must_convert_endian)\r\nconvert_elf_shdrs(sh, ex.e_shnum);\r\nqsort(ph, ex.e_phnum, sizeof(Elf32_Phdr), phcmp);\r\nfor (i = 0; i < ex.e_phnum; i++) {\r\nswitch (ph[i].p_type) {\r\ncase PT_NULL:\r\ncase PT_NOTE:\r\ncase PT_PHDR:\r\ncase PT_MIPS_REGINFO:\r\ncase PT_MIPS_ABIFLAGS:\r\ncontinue;\r\ncase PT_LOAD:\r\nif (ph[i].p_flags & PF_W) {\r\nstruct sect ndata, nbss;\r\nndata.vaddr = ph[i].p_vaddr;\r\nndata.len = ph[i].p_filesz;\r\nnbss.vaddr = ph[i].p_vaddr + ph[i].p_filesz;\r\nnbss.len = ph[i].p_memsz - ph[i].p_filesz;\r\ncombine(&data, &ndata, 0);\r\ncombine(&bss, &nbss, 1);\r\n} else {\r\nstruct sect ntxt;\r\nntxt.vaddr = ph[i].p_vaddr;\r\nntxt.len = ph[i].p_filesz;\r\ncombine(&text, &ntxt, 0);\r\n}\r\nif (ph[i].p_vaddr < cur_vma)\r\ncur_vma = ph[i].p_vaddr;\r\nbreak;\r\ndefault:\r\nfprintf(stderr,\r\n"Program header %d type %d can't be converted.\n",\r\nex.e_phnum, ph[i].p_type);\r\nexit(1);\r\n}\r\n}\r\nif (text.vaddr > data.vaddr || data.vaddr > bss.vaddr ||\r\ntext.vaddr + text.len > data.vaddr\r\n|| data.vaddr + data.len > bss.vaddr) {\r\nfprintf(stderr,\r\n"Sections ordering prevents a.out conversion.\n");\r\nexit(1);\r\n}\r\nif (data.len && !text.len) {\r\ntext = data;\r\ndata.vaddr = text.vaddr + text.len;\r\ndata.len = 0;\r\n}\r\nif (text.vaddr + text.len < data.vaddr)\r\ntext.len = data.vaddr - text.vaddr;\r\neah.magic = OMAGIC;\r\neah.vstamp = 200;\r\neah.tsize = text.len;\r\neah.dsize = data.len;\r\neah.bsize = bss.len;\r\neah.entry = ex.e_entry;\r\neah.text_start = text.vaddr;\r\neah.data_start = data.vaddr;\r\neah.bss_start = bss.vaddr;\r\neah.gprmask = 0xf3fffffe;\r\nmemset(&eah.cprmask, '\0', sizeof eah.cprmask);\r\neah.gp_value = 0;\r\nif (format_bigendian)\r\nefh.f_magic = MIPSEBMAGIC;\r\nelse\r\nefh.f_magic = MIPSELMAGIC;\r\nif (addflag)\r\nnosecs = 6;\r\nelse\r\nnosecs = 3;\r\nefh.f_nscns = nosecs;\r\nefh.f_timdat = 0;\r\nefh.f_symptr = 0;\r\nefh.f_nsyms = 0;\r\nefh.f_opthdr = sizeof eah;\r\nefh.f_flags = 0x100f;\r\nmemset(esecs, 0, sizeof esecs);\r\nstrcpy(esecs[0].s_name, ".text");\r\nstrcpy(esecs[1].s_name, ".data");\r\nstrcpy(esecs[2].s_name, ".bss");\r\nif (addflag) {\r\nstrcpy(esecs[3].s_name, ".rdata");\r\nstrcpy(esecs[4].s_name, ".sdata");\r\nstrcpy(esecs[5].s_name, ".sbss");\r\n}\r\nesecs[0].s_paddr = esecs[0].s_vaddr = eah.text_start;\r\nesecs[1].s_paddr = esecs[1].s_vaddr = eah.data_start;\r\nesecs[2].s_paddr = esecs[2].s_vaddr = eah.bss_start;\r\nif (addflag) {\r\nesecs[3].s_paddr = esecs[3].s_vaddr = 0;\r\nesecs[4].s_paddr = esecs[4].s_vaddr = 0;\r\nesecs[5].s_paddr = esecs[5].s_vaddr = 0;\r\n}\r\nesecs[0].s_size = eah.tsize;\r\nesecs[1].s_size = eah.dsize;\r\nesecs[2].s_size = eah.bsize;\r\nif (addflag) {\r\nesecs[3].s_size = 0;\r\nesecs[4].s_size = 0;\r\nesecs[5].s_size = 0;\r\n}\r\nesecs[0].s_scnptr = N_TXTOFF(efh, eah);\r\nesecs[1].s_scnptr = N_DATOFF(efh, eah);\r\n#define ECOFF_SEGMENT_ALIGNMENT(a) 0x10\r\n#define ECOFF_ROUND(s, a) (((s)+(a)-1)&~((a)-1))\r\nesecs[2].s_scnptr = esecs[1].s_scnptr +\r\nECOFF_ROUND(esecs[1].s_size, ECOFF_SEGMENT_ALIGNMENT(&eah));\r\nif (addflag) {\r\nesecs[3].s_scnptr = 0;\r\nesecs[4].s_scnptr = 0;\r\nesecs[5].s_scnptr = 0;\r\n}\r\nesecs[0].s_relptr = esecs[1].s_relptr = esecs[2].s_relptr = 0;\r\nesecs[0].s_lnnoptr = esecs[1].s_lnnoptr = esecs[2].s_lnnoptr = 0;\r\nesecs[0].s_nreloc = esecs[1].s_nreloc = esecs[2].s_nreloc = 0;\r\nesecs[0].s_nlnno = esecs[1].s_nlnno = esecs[2].s_nlnno = 0;\r\nif (addflag) {\r\nesecs[3].s_relptr = esecs[4].s_relptr\r\n= esecs[5].s_relptr = 0;\r\nesecs[3].s_lnnoptr = esecs[4].s_lnnoptr\r\n= esecs[5].s_lnnoptr = 0;\r\nesecs[3].s_nreloc = esecs[4].s_nreloc = esecs[5].s_nreloc =\r\n0;\r\nesecs[3].s_nlnno = esecs[4].s_nlnno = esecs[5].s_nlnno = 0;\r\n}\r\nesecs[0].s_flags = 0x20;\r\nesecs[1].s_flags = 0x40;\r\nesecs[2].s_flags = 0x82;\r\nif (addflag) {\r\nesecs[3].s_flags = 0x100;\r\nesecs[4].s_flags = 0x200;\r\nesecs[5].s_flags = 0x400;\r\n}\r\nif ((outfile = open(argv[2], O_WRONLY | O_CREAT, 0777)) < 0) {\r\nfprintf(stderr, "Unable to create %s: %s\n", argv[2],\r\nstrerror(errno));\r\nexit(1);\r\n}\r\nif (must_convert_endian)\r\nconvert_ecoff_filehdr(&efh);\r\ni = write(outfile, &efh, sizeof efh);\r\nif (i != sizeof efh) {\r\nperror("efh: write");\r\nexit(1);\r\nfor (i = 0; i < nosecs; i++) {\r\nprintf\r\n("Section %d: %s phys %lx size %lx file offset %lx\n",\r\ni, esecs[i].s_name, esecs[i].s_paddr,\r\nesecs[i].s_size, esecs[i].s_scnptr);\r\n}\r\n}\r\nfprintf(stderr, "wrote %d byte file header.\n", i);\r\nif (must_convert_endian)\r\nconvert_ecoff_aouthdr(&eah);\r\ni = write(outfile, &eah, sizeof eah);\r\nif (i != sizeof eah) {\r\nperror("eah: write");\r\nexit(1);\r\n}\r\nfprintf(stderr, "wrote %d byte a.out header.\n", i);\r\nif (must_convert_endian)\r\nconvert_ecoff_esecs(&esecs[0], nosecs);\r\ni = write(outfile, &esecs, nosecs * sizeof(struct scnhdr));\r\nif (i != nosecs * sizeof(struct scnhdr)) {\r\nperror("esecs: write");\r\nexit(1);\r\n}\r\nfprintf(stderr, "wrote %d bytes of section headers.\n", i);\r\npad = (sizeof(efh) + sizeof(eah) + nosecs * sizeof(struct scnhdr)) & 15;\r\nif (pad) {\r\npad = 16 - pad;\r\ni = write(outfile, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0", pad);\r\nif (i < 0) {\r\nperror("ipad: write");\r\nexit(1);\r\n}\r\nfprintf(stderr, "wrote %d byte pad.\n", i);\r\n}\r\nfor (i = 0; i < ex.e_phnum; i++) {\r\nif (ph[i].p_type == PT_LOAD && ph[i].p_filesz) {\r\nif (cur_vma != ph[i].p_vaddr) {\r\nunsigned long gap =\r\nph[i].p_vaddr - cur_vma;\r\nchar obuf[1024];\r\nif (gap > 65536) {\r\nfprintf(stderr,\r\n"Intersegment gap (%ld bytes) too large.\n",\r\ngap);\r\nexit(1);\r\n}\r\nfprintf(stderr,\r\n"Warning: %ld byte intersegment gap.\n",\r\ngap);\r\nmemset(obuf, 0, sizeof obuf);\r\nwhile (gap) {\r\nint count =\r\nwrite(outfile, obuf,\r\n(gap >\r\nsizeof obuf ? sizeof\r\nobuf : gap));\r\nif (count < 0) {\r\nfprintf(stderr,\r\n"Error writing gap: %s\n",\r\nstrerror(errno));\r\nexit(1);\r\n}\r\ngap -= count;\r\n}\r\n}\r\nfprintf(stderr, "writing %d bytes...\n",\r\nph[i].p_filesz);\r\ncopy(outfile, infile, ph[i].p_offset,\r\nph[i].p_filesz);\r\ncur_vma = ph[i].p_vaddr + ph[i].p_filesz;\r\n}\r\n}\r\n{\r\nchar obuf[4096];\r\nmemset(obuf, 0, sizeof obuf);\r\nif (write(outfile, obuf, sizeof(obuf)) != sizeof(obuf)) {\r\nfprintf(stderr, "Error writing PROM padding: %s\n",\r\nstrerror(errno));\r\nexit(1);\r\n}\r\n}\r\nexit(0);\r\n}
