void scif_insert_tcw(struct scif_window *window, struct list_head *head)\r\n{\r\nstruct scif_window *curr = NULL;\r\nstruct scif_window *prev = list_entry(head, struct scif_window, list);\r\nstruct list_head *item;\r\nINIT_LIST_HEAD(&window->list);\r\nif (!list_empty(head)) {\r\ncurr = list_entry(head->prev, struct scif_window, list);\r\nif (curr->va_for_temp < window->va_for_temp) {\r\nlist_add_tail(&window->list, head);\r\nreturn;\r\n}\r\n}\r\nlist_for_each(item, head) {\r\ncurr = list_entry(item, struct scif_window, list);\r\nif (curr->va_for_temp > window->va_for_temp)\r\nbreak;\r\nprev = curr;\r\n}\r\nlist_add(&window->list, &prev->list);\r\n}\r\nvoid scif_insert_window(struct scif_window *window, struct list_head *head)\r\n{\r\nstruct scif_window *curr = NULL, *prev = NULL;\r\nstruct list_head *item;\r\nINIT_LIST_HEAD(&window->list);\r\nlist_for_each(item, head) {\r\ncurr = list_entry(item, struct scif_window, list);\r\nif (curr->offset > window->offset)\r\nbreak;\r\nprev = curr;\r\n}\r\nif (!prev)\r\nlist_add(&window->list, head);\r\nelse\r\nlist_add(&window->list, &prev->list);\r\nscif_set_window_ref(window, window->nr_pages);\r\n}\r\nint scif_query_tcw(struct scif_endpt *ep, struct scif_rma_req *req)\r\n{\r\nstruct list_head *item, *temp, *head = req->head;\r\nstruct scif_window *window;\r\nu64 start_va_window, start_va_req = req->va_for_temp;\r\nu64 end_va_window, end_va_req = start_va_req + req->nr_bytes;\r\nif (!req->nr_bytes)\r\nreturn -EINVAL;\r\nif (!list_empty(head)) {\r\nwindow = list_last_entry(head, struct scif_window, list);\r\nend_va_window = window->va_for_temp +\r\n(window->nr_pages << PAGE_SHIFT);\r\nif (start_va_req > end_va_window)\r\nreturn -ENXIO;\r\n}\r\nlist_for_each_safe(item, temp, head) {\r\nwindow = list_entry(item, struct scif_window, list);\r\nstart_va_window = window->va_for_temp;\r\nend_va_window = window->va_for_temp +\r\n(window->nr_pages << PAGE_SHIFT);\r\nif (start_va_req < start_va_window &&\r\nend_va_req < start_va_window)\r\nbreak;\r\nif (start_va_req >= end_va_window)\r\ncontinue;\r\nif ((window->prot & req->prot) == req->prot) {\r\nif (start_va_req >= start_va_window &&\r\nend_va_req <= end_va_window) {\r\n*req->out_window = window;\r\nreturn 0;\r\n}\r\nif (start_va_req < start_va_window) {\r\nreq->nr_bytes +=\r\nstart_va_window - start_va_req;\r\nreq->va_for_temp = start_va_window;\r\n}\r\nif (end_va_req >= end_va_window)\r\nreq->nr_bytes += end_va_window - end_va_req;\r\n}\r\n__scif_rma_destroy_tcw_helper(window);\r\nbreak;\r\n}\r\nreturn -ENXIO;\r\n}\r\nint scif_query_window(struct scif_rma_req *req)\r\n{\r\nstruct list_head *item;\r\nstruct scif_window *window;\r\ns64 end_offset, offset = req->offset;\r\nu64 tmp_min, nr_bytes_left = req->nr_bytes;\r\nif (!req->nr_bytes)\r\nreturn -EINVAL;\r\nlist_for_each(item, req->head) {\r\nwindow = list_entry(item, struct scif_window, list);\r\nend_offset = window->offset +\r\n(window->nr_pages << PAGE_SHIFT);\r\nif (offset < window->offset)\r\nreturn -ENXIO;\r\nif (offset >= end_offset)\r\ncontinue;\r\nif ((window->prot & req->prot) != req->prot)\r\nreturn -EPERM;\r\nif (nr_bytes_left == req->nr_bytes)\r\n*req->out_window = window;\r\ntmp_min = min((u64)end_offset - offset, nr_bytes_left);\r\nnr_bytes_left -= tmp_min;\r\noffset += tmp_min;\r\nif (!nr_bytes_left) {\r\nif (req->type == SCIF_WINDOW_PARTIAL ||\r\nreq->type == SCIF_WINDOW_SINGLE)\r\nreturn 0;\r\nif (offset == end_offset)\r\nreturn 0;\r\nreturn -ENXIO;\r\n}\r\nif (req->type == SCIF_WINDOW_SINGLE)\r\nbreak;\r\n}\r\ndev_err(scif_info.mdev.this_device,\r\n"%s %d ENXIO\n", __func__, __LINE__);\r\nreturn -ENXIO;\r\n}\r\nint scif_rma_list_unregister(struct scif_window *window,\r\ns64 offset, int nr_pages)\r\n{\r\nstruct scif_endpt *ep = (struct scif_endpt *)window->ep;\r\nstruct list_head *head = &ep->rma_info.reg_list;\r\ns64 end_offset;\r\nint err = 0;\r\nint loop_nr_pages;\r\nstruct scif_window *_window;\r\nlist_for_each_entry_safe_from(window, _window, head, list) {\r\nend_offset = window->offset + (window->nr_pages << PAGE_SHIFT);\r\nloop_nr_pages = min((int)((end_offset - offset) >> PAGE_SHIFT),\r\nnr_pages);\r\nerr = scif_unregister_window(window);\r\nif (err)\r\nreturn err;\r\nnr_pages -= loop_nr_pages;\r\noffset += (loop_nr_pages << PAGE_SHIFT);\r\nif (!nr_pages)\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nvoid scif_unmap_all_windows(scif_epd_t epd)\r\n{\r\nstruct list_head *item, *tmp;\r\nstruct scif_window *window;\r\nstruct scif_endpt *ep = (struct scif_endpt *)epd;\r\nstruct list_head *head = &ep->rma_info.reg_list;\r\nmutex_lock(&ep->rma_info.rma_lock);\r\nlist_for_each_safe(item, tmp, head) {\r\nwindow = list_entry(item, struct scif_window, list);\r\nscif_unmap_window(ep->remote_dev, window);\r\n}\r\nmutex_unlock(&ep->rma_info.rma_lock);\r\n}\r\nint scif_unregister_all_windows(scif_epd_t epd)\r\n{\r\nstruct list_head *item, *tmp;\r\nstruct scif_window *window;\r\nstruct scif_endpt *ep = (struct scif_endpt *)epd;\r\nstruct list_head *head = &ep->rma_info.reg_list;\r\nint err = 0;\r\nmutex_lock(&ep->rma_info.rma_lock);\r\nretry:\r\nitem = NULL;\r\ntmp = NULL;\r\nlist_for_each_safe(item, tmp, head) {\r\nwindow = list_entry(item, struct scif_window, list);\r\nep->rma_info.async_list_del = 0;\r\nerr = scif_unregister_window(window);\r\nif (err)\r\ndev_err(scif_info.mdev.this_device,\r\n"%s %d err %d\n",\r\n__func__, __LINE__, err);\r\nif (ACCESS_ONCE(ep->rma_info.async_list_del))\r\ngoto retry;\r\n}\r\nmutex_unlock(&ep->rma_info.rma_lock);\r\nif (!list_empty(&ep->rma_info.mmn_list)) {\r\nspin_lock(&scif_info.rmalock);\r\nlist_add_tail(&ep->mmu_list, &scif_info.mmu_notif_cleanup);\r\nspin_unlock(&scif_info.rmalock);\r\nschedule_work(&scif_info.mmu_notif_work);\r\n}\r\nreturn err;\r\n}
