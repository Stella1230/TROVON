static int si2157_cmd_execute(struct i2c_client *client, struct si2157_cmd *cmd)\r\n{\r\nstruct si2157_dev *dev = i2c_get_clientdata(client);\r\nint ret;\r\nunsigned long timeout;\r\nmutex_lock(&dev->i2c_mutex);\r\nif (cmd->wlen) {\r\nret = i2c_master_send(client, cmd->args, cmd->wlen);\r\nif (ret < 0) {\r\ngoto err_mutex_unlock;\r\n} else if (ret != cmd->wlen) {\r\nret = -EREMOTEIO;\r\ngoto err_mutex_unlock;\r\n}\r\n}\r\nif (cmd->rlen) {\r\n#define TIMEOUT 80\r\ntimeout = jiffies + msecs_to_jiffies(TIMEOUT);\r\nwhile (!time_after(jiffies, timeout)) {\r\nret = i2c_master_recv(client, cmd->args, cmd->rlen);\r\nif (ret < 0) {\r\ngoto err_mutex_unlock;\r\n} else if (ret != cmd->rlen) {\r\nret = -EREMOTEIO;\r\ngoto err_mutex_unlock;\r\n}\r\nif ((cmd->args[0] >> 7) & 0x01)\r\nbreak;\r\n}\r\ndev_dbg(&client->dev, "cmd execution took %d ms\n",\r\njiffies_to_msecs(jiffies) -\r\n(jiffies_to_msecs(timeout) - TIMEOUT));\r\nif (!((cmd->args[0] >> 7) & 0x01)) {\r\nret = -ETIMEDOUT;\r\ngoto err_mutex_unlock;\r\n}\r\n}\r\nmutex_unlock(&dev->i2c_mutex);\r\nreturn 0;\r\nerr_mutex_unlock:\r\nmutex_unlock(&dev->i2c_mutex);\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int si2157_init(struct dvb_frontend *fe)\r\n{\r\nstruct i2c_client *client = fe->tuner_priv;\r\nstruct si2157_dev *dev = i2c_get_clientdata(client);\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret, len, remaining;\r\nstruct si2157_cmd cmd;\r\nconst struct firmware *fw;\r\nconst char *fw_name;\r\nunsigned int uitmp, chip_id;\r\ndev_dbg(&client->dev, "\n");\r\nmemcpy(cmd.args, "\x15\x00\x06\x07", 4);\r\ncmd.wlen = 4;\r\ncmd.rlen = 4;\r\nret = si2157_cmd_execute(client, &cmd);\r\nif (ret)\r\ngoto err;\r\nuitmp = cmd.args[2] << 0 | cmd.args[3] << 8;\r\ndev_dbg(&client->dev, "if_frequency kHz=%u\n", uitmp);\r\nif (uitmp == dev->if_frequency / 1000)\r\ngoto warm;\r\nif (dev->chiptype == SI2157_CHIPTYPE_SI2146) {\r\nmemcpy(cmd.args, "\xc0\x05\x01\x00\x00\x0b\x00\x00\x01", 9);\r\ncmd.wlen = 9;\r\n} else if (dev->chiptype == SI2157_CHIPTYPE_SI2141) {\r\nmemcpy(cmd.args, "\xc0\x00\x0d\x0e\x00\x01\x01\x01\x01\x03", 10);\r\ncmd.wlen = 10;\r\n} else {\r\nmemcpy(cmd.args, "\xc0\x00\x0c\x00\x00\x01\x01\x01\x01\x01\x01\x02\x00\x00\x01", 15);\r\ncmd.wlen = 15;\r\n}\r\ncmd.rlen = 1;\r\nret = si2157_cmd_execute(client, &cmd);\r\nif (ret)\r\ngoto err;\r\nif (dev->chiptype == SI2157_CHIPTYPE_SI2141) {\r\nmemcpy(cmd.args, "\xc0\x08\x01\x02\x00\x00\x01", 7);\r\ncmd.wlen = 7;\r\nret = si2157_cmd_execute(client, &cmd);\r\nif (ret)\r\ngoto err;\r\n}\r\nmemcpy(cmd.args, "\x02", 1);\r\ncmd.wlen = 1;\r\ncmd.rlen = 13;\r\nret = si2157_cmd_execute(client, &cmd);\r\nif (ret)\r\ngoto err;\r\nchip_id = cmd.args[1] << 24 | cmd.args[2] << 16 | cmd.args[3] << 8 |\r\ncmd.args[4] << 0;\r\n#define SI2158_A20 ('A' << 24 | 58 << 16 | '2' << 8 | '0' << 0)\r\n#define SI2148_A20 ('A' << 24 | 48 << 16 | '2' << 8 | '0' << 0)\r\n#define SI2157_A30 ('A' << 24 | 57 << 16 | '3' << 8 | '0' << 0)\r\n#define SI2147_A30 ('A' << 24 | 47 << 16 | '3' << 8 | '0' << 0)\r\n#define SI2146_A10 ('A' << 24 | 46 << 16 | '1' << 8 | '0' << 0)\r\n#define SI2141_A10 ('A' << 24 | 41 << 16 | '1' << 8 | '0' << 0)\r\nswitch (chip_id) {\r\ncase SI2158_A20:\r\ncase SI2148_A20:\r\nfw_name = SI2158_A20_FIRMWARE;\r\nbreak;\r\ncase SI2141_A10:\r\nfw_name = SI2141_A10_FIRMWARE;\r\nbreak;\r\ncase SI2157_A30:\r\ncase SI2147_A30:\r\ncase SI2146_A10:\r\nfw_name = NULL;\r\nbreak;\r\ndefault:\r\ndev_err(&client->dev, "unknown chip version Si21%d-%c%c%c\n",\r\ncmd.args[2], cmd.args[1],\r\ncmd.args[3], cmd.args[4]);\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\ndev_info(&client->dev, "found a 'Silicon Labs Si21%d-%c%c%c'\n",\r\ncmd.args[2], cmd.args[1], cmd.args[3], cmd.args[4]);\r\nif (fw_name == NULL)\r\ngoto skip_fw_download;\r\nret = request_firmware(&fw, fw_name, &client->dev);\r\nif (ret) {\r\ndev_err(&client->dev, "firmware file '%s' not found\n",\r\nfw_name);\r\ngoto err;\r\n}\r\nif (fw->size % 17 != 0) {\r\ndev_err(&client->dev, "firmware file '%s' is invalid\n",\r\nfw_name);\r\nret = -EINVAL;\r\ngoto err_release_firmware;\r\n}\r\ndev_info(&client->dev, "downloading firmware from file '%s'\n",\r\nfw_name);\r\nfor (remaining = fw->size; remaining > 0; remaining -= 17) {\r\nlen = fw->data[fw->size - remaining];\r\nif (len > SI2157_ARGLEN) {\r\ndev_err(&client->dev, "Bad firmware length\n");\r\nret = -EINVAL;\r\ngoto err_release_firmware;\r\n}\r\nmemcpy(cmd.args, &fw->data[(fw->size - remaining) + 1], len);\r\ncmd.wlen = len;\r\ncmd.rlen = 1;\r\nret = si2157_cmd_execute(client, &cmd);\r\nif (ret) {\r\ndev_err(&client->dev, "firmware download failed %d\n",\r\nret);\r\ngoto err_release_firmware;\r\n}\r\n}\r\nrelease_firmware(fw);\r\nskip_fw_download:\r\nmemcpy(cmd.args, "\x01\x01", 2);\r\ncmd.wlen = 2;\r\ncmd.rlen = 1;\r\nret = si2157_cmd_execute(client, &cmd);\r\nif (ret)\r\ngoto err;\r\nmemcpy(cmd.args, "\x11", 1);\r\ncmd.wlen = 1;\r\ncmd.rlen = 10;\r\nret = si2157_cmd_execute(client, &cmd);\r\nif (ret)\r\ngoto err;\r\ndev_info(&client->dev, "firmware version: %c.%c.%d\n",\r\ncmd.args[6], cmd.args[7], cmd.args[8]);\r\nwarm:\r\nc->strength.len = 1;\r\nc->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nschedule_delayed_work(&dev->stat_work, msecs_to_jiffies(1000));\r\ndev->active = true;\r\nreturn 0;\r\nerr_release_firmware:\r\nrelease_firmware(fw);\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int si2157_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct i2c_client *client = fe->tuner_priv;\r\nstruct si2157_dev *dev = i2c_get_clientdata(client);\r\nint ret;\r\nstruct si2157_cmd cmd;\r\ndev_dbg(&client->dev, "\n");\r\ndev->active = false;\r\ncancel_delayed_work_sync(&dev->stat_work);\r\nmemcpy(cmd.args, "\x16\x00", 2);\r\ncmd.wlen = 2;\r\ncmd.rlen = 1;\r\nret = si2157_cmd_execute(client, &cmd);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int si2157_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct i2c_client *client = fe->tuner_priv;\r\nstruct si2157_dev *dev = i2c_get_clientdata(client);\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret;\r\nstruct si2157_cmd cmd;\r\nu8 bandwidth, delivery_system;\r\nu32 if_frequency = 5000000;\r\ndev_dbg(&client->dev,\r\n"delivery_system=%d frequency=%u bandwidth_hz=%u\n",\r\nc->delivery_system, c->frequency, c->bandwidth_hz);\r\nif (!dev->active) {\r\nret = -EAGAIN;\r\ngoto err;\r\n}\r\nif (c->bandwidth_hz <= 6000000)\r\nbandwidth = 0x06;\r\nelse if (c->bandwidth_hz <= 7000000)\r\nbandwidth = 0x07;\r\nelse if (c->bandwidth_hz <= 8000000)\r\nbandwidth = 0x08;\r\nelse\r\nbandwidth = 0x0f;\r\nswitch (c->delivery_system) {\r\ncase SYS_ATSC:\r\ndelivery_system = 0x00;\r\nif_frequency = 3250000;\r\nbreak;\r\ncase SYS_DVBC_ANNEX_B:\r\ndelivery_system = 0x10;\r\nif_frequency = 4000000;\r\nbreak;\r\ncase SYS_DVBT:\r\ncase SYS_DVBT2:\r\ndelivery_system = 0x20;\r\nbreak;\r\ncase SYS_DVBC_ANNEX_A:\r\ndelivery_system = 0x30;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nmemcpy(cmd.args, "\x14\x00\x03\x07\x00\x00", 6);\r\ncmd.args[4] = delivery_system | bandwidth;\r\nif (dev->inversion)\r\ncmd.args[5] = 0x01;\r\ncmd.wlen = 6;\r\ncmd.rlen = 4;\r\nret = si2157_cmd_execute(client, &cmd);\r\nif (ret)\r\ngoto err;\r\nif (dev->chiptype == SI2157_CHIPTYPE_SI2146)\r\nmemcpy(cmd.args, "\x14\x00\x02\x07\x00\x01", 6);\r\nelse\r\nmemcpy(cmd.args, "\x14\x00\x02\x07\x00\x00", 6);\r\ncmd.args[4] = dev->if_port;\r\ncmd.wlen = 6;\r\ncmd.rlen = 4;\r\nret = si2157_cmd_execute(client, &cmd);\r\nif (ret)\r\ngoto err;\r\nif (if_frequency != dev->if_frequency) {\r\nmemcpy(cmd.args, "\x14\x00\x06\x07", 4);\r\ncmd.args[4] = (if_frequency / 1000) & 0xff;\r\ncmd.args[5] = ((if_frequency / 1000) >> 8) & 0xff;\r\ncmd.wlen = 6;\r\ncmd.rlen = 4;\r\nret = si2157_cmd_execute(client, &cmd);\r\nif (ret)\r\ngoto err;\r\ndev->if_frequency = if_frequency;\r\n}\r\nmemcpy(cmd.args, "\x41\x00\x00\x00\x00\x00\x00\x00", 8);\r\ncmd.args[4] = (c->frequency >> 0) & 0xff;\r\ncmd.args[5] = (c->frequency >> 8) & 0xff;\r\ncmd.args[6] = (c->frequency >> 16) & 0xff;\r\ncmd.args[7] = (c->frequency >> 24) & 0xff;\r\ncmd.wlen = 8;\r\ncmd.rlen = 1;\r\nret = si2157_cmd_execute(client, &cmd);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int si2157_get_if_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\nstruct i2c_client *client = fe->tuner_priv;\r\nstruct si2157_dev *dev = i2c_get_clientdata(client);\r\n*frequency = dev->if_frequency;\r\nreturn 0;\r\n}\r\nstatic void si2157_stat_work(struct work_struct *work)\r\n{\r\nstruct si2157_dev *dev = container_of(work, struct si2157_dev, stat_work.work);\r\nstruct dvb_frontend *fe = dev->fe;\r\nstruct i2c_client *client = fe->tuner_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct si2157_cmd cmd;\r\nint ret;\r\ndev_dbg(&client->dev, "\n");\r\nmemcpy(cmd.args, "\x42\x00", 2);\r\ncmd.wlen = 2;\r\ncmd.rlen = 12;\r\nret = si2157_cmd_execute(client, &cmd);\r\nif (ret)\r\ngoto err;\r\nc->strength.stat[0].scale = FE_SCALE_DECIBEL;\r\nc->strength.stat[0].svalue = (s8) cmd.args[3] * 1000;\r\nschedule_delayed_work(&dev->stat_work, msecs_to_jiffies(2000));\r\nreturn;\r\nerr:\r\nc->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\n}\r\nstatic int si2157_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct si2157_config *cfg = client->dev.platform_data;\r\nstruct dvb_frontend *fe = cfg->fe;\r\nstruct si2157_dev *dev;\r\nstruct si2157_cmd cmd;\r\nint ret;\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev) {\r\nret = -ENOMEM;\r\ndev_err(&client->dev, "kzalloc() failed\n");\r\ngoto err;\r\n}\r\ni2c_set_clientdata(client, dev);\r\ndev->fe = cfg->fe;\r\ndev->inversion = cfg->inversion;\r\ndev->if_port = cfg->if_port;\r\ndev->chiptype = (u8)id->driver_data;\r\ndev->if_frequency = 5000000;\r\nmutex_init(&dev->i2c_mutex);\r\nINIT_DELAYED_WORK(&dev->stat_work, si2157_stat_work);\r\ncmd.wlen = 0;\r\ncmd.rlen = 1;\r\nret = si2157_cmd_execute(client, &cmd);\r\nif (ret)\r\ngoto err_kfree;\r\nmemcpy(&fe->ops.tuner_ops, &si2157_ops, sizeof(struct dvb_tuner_ops));\r\nfe->tuner_priv = client;\r\n#ifdef CONFIG_MEDIA_CONTROLLER\r\nif (cfg->mdev) {\r\ndev->mdev = cfg->mdev;\r\ndev->ent.name = KBUILD_MODNAME;\r\ndev->ent.function = MEDIA_ENT_F_TUNER;\r\ndev->pad[TUNER_PAD_RF_INPUT].flags = MEDIA_PAD_FL_SINK;\r\ndev->pad[TUNER_PAD_OUTPUT].flags = MEDIA_PAD_FL_SOURCE;\r\ndev->pad[TUNER_PAD_AUD_OUT].flags = MEDIA_PAD_FL_SOURCE;\r\nret = media_entity_pads_init(&dev->ent, TUNER_NUM_PADS,\r\n&dev->pad[0]);\r\nif (ret)\r\ngoto err_kfree;\r\nret = media_device_register_entity(cfg->mdev, &dev->ent);\r\nif (ret) {\r\nmedia_entity_cleanup(&dev->ent);\r\ngoto err_kfree;\r\n}\r\n}\r\n#endif\r\ndev_info(&client->dev, "Silicon Labs %s successfully attached\n",\r\ndev->chiptype == SI2157_CHIPTYPE_SI2141 ? "Si2141" :\r\ndev->chiptype == SI2157_CHIPTYPE_SI2146 ?\r\n"Si2146" : "Si2147/2148/2157/2158");\r\nreturn 0;\r\nerr_kfree:\r\nkfree(dev);\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int si2157_remove(struct i2c_client *client)\r\n{\r\nstruct si2157_dev *dev = i2c_get_clientdata(client);\r\nstruct dvb_frontend *fe = dev->fe;\r\ndev_dbg(&client->dev, "\n");\r\ncancel_delayed_work_sync(&dev->stat_work);\r\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\r\nif (dev->mdev)\r\nmedia_device_unregister_entity(&dev->ent);\r\n#endif\r\nmemset(&fe->ops.tuner_ops, 0, sizeof(struct dvb_tuner_ops));\r\nfe->tuner_priv = NULL;\r\nkfree(dev);\r\nreturn 0;\r\n}
