int gb_hd_output(struct gb_host_device *hd, void *req, u16 size, u8 cmd,\r\nbool async)\r\n{\r\nif (!hd || !hd->driver || !hd->driver->output)\r\nreturn -EINVAL;\r\nreturn hd->driver->output(hd, req, size, cmd, async);\r\n}\r\nstatic ssize_t bus_id_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct gb_host_device *hd = to_gb_host_device(dev);\r\nreturn sprintf(buf, "%d\n", hd->bus_id);\r\n}\r\nint gb_hd_cport_reserve(struct gb_host_device *hd, u16 cport_id)\r\n{\r\nstruct ida *id_map = &hd->cport_id_map;\r\nint ret;\r\nret = ida_simple_get(id_map, cport_id, cport_id + 1, GFP_KERNEL);\r\nif (ret < 0) {\r\ndev_err(&hd->dev, "failed to reserve cport %u\n", cport_id);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nvoid gb_hd_cport_release_reserved(struct gb_host_device *hd, u16 cport_id)\r\n{\r\nstruct ida *id_map = &hd->cport_id_map;\r\nida_simple_remove(id_map, cport_id);\r\n}\r\nint gb_hd_cport_allocate(struct gb_host_device *hd, int cport_id,\r\nunsigned long flags)\r\n{\r\nstruct ida *id_map = &hd->cport_id_map;\r\nint ida_start, ida_end;\r\nif (hd->driver->cport_allocate)\r\nreturn hd->driver->cport_allocate(hd, cport_id, flags);\r\nif (cport_id < 0) {\r\nida_start = 0;\r\nida_end = hd->num_cports;\r\n} else if (cport_id < hd->num_cports) {\r\nida_start = cport_id;\r\nida_end = cport_id + 1;\r\n} else {\r\ndev_err(&hd->dev, "cport %d not available\n", cport_id);\r\nreturn -EINVAL;\r\n}\r\nreturn ida_simple_get(id_map, ida_start, ida_end, GFP_KERNEL);\r\n}\r\nvoid gb_hd_cport_release(struct gb_host_device *hd, u16 cport_id)\r\n{\r\nif (hd->driver->cport_release) {\r\nhd->driver->cport_release(hd, cport_id);\r\nreturn;\r\n}\r\nida_simple_remove(&hd->cport_id_map, cport_id);\r\n}\r\nstatic void gb_hd_release(struct device *dev)\r\n{\r\nstruct gb_host_device *hd = to_gb_host_device(dev);\r\ntrace_gb_hd_release(hd);\r\nif (hd->svc)\r\ngb_svc_put(hd->svc);\r\nida_simple_remove(&gb_hd_bus_id_map, hd->bus_id);\r\nida_destroy(&hd->cport_id_map);\r\nkfree(hd);\r\n}\r\nstruct gb_host_device *gb_hd_create(struct gb_hd_driver *driver,\r\nstruct device *parent,\r\nsize_t buffer_size_max,\r\nsize_t num_cports)\r\n{\r\nstruct gb_host_device *hd;\r\nint ret;\r\nif ((!driver->message_send) || (!driver->message_cancel)) {\r\ndev_err(parent, "mandatory hd-callbacks missing\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (buffer_size_max < GB_OPERATION_MESSAGE_SIZE_MIN) {\r\ndev_err(parent, "greybus host-device buffers too small\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (num_cports == 0 || num_cports > CPORT_ID_MAX + 1) {\r\ndev_err(parent, "Invalid number of CPorts: %zu\n", num_cports);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (buffer_size_max > GB_OPERATION_MESSAGE_SIZE_MAX) {\r\ndev_warn(parent, "limiting buffer size to %u\n",\r\nGB_OPERATION_MESSAGE_SIZE_MAX);\r\nbuffer_size_max = GB_OPERATION_MESSAGE_SIZE_MAX;\r\n}\r\nhd = kzalloc(sizeof(*hd) + driver->hd_priv_size, GFP_KERNEL);\r\nif (!hd)\r\nreturn ERR_PTR(-ENOMEM);\r\nret = ida_simple_get(&gb_hd_bus_id_map, 1, 0, GFP_KERNEL);\r\nif (ret < 0) {\r\nkfree(hd);\r\nreturn ERR_PTR(ret);\r\n}\r\nhd->bus_id = ret;\r\nhd->driver = driver;\r\nINIT_LIST_HEAD(&hd->modules);\r\nINIT_LIST_HEAD(&hd->connections);\r\nida_init(&hd->cport_id_map);\r\nhd->buffer_size_max = buffer_size_max;\r\nhd->num_cports = num_cports;\r\nhd->dev.parent = parent;\r\nhd->dev.bus = &greybus_bus_type;\r\nhd->dev.type = &greybus_hd_type;\r\nhd->dev.groups = bus_groups;\r\nhd->dev.dma_mask = hd->dev.parent->dma_mask;\r\ndevice_initialize(&hd->dev);\r\ndev_set_name(&hd->dev, "greybus%d", hd->bus_id);\r\ntrace_gb_hd_create(hd);\r\nhd->svc = gb_svc_create(hd);\r\nif (!hd->svc) {\r\ndev_err(&hd->dev, "failed to create svc\n");\r\nput_device(&hd->dev);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nreturn hd;\r\n}\r\nint gb_hd_add(struct gb_host_device *hd)\r\n{\r\nint ret;\r\nret = device_add(&hd->dev);\r\nif (ret)\r\nreturn ret;\r\nret = gb_svc_add(hd->svc);\r\nif (ret) {\r\ndevice_del(&hd->dev);\r\nreturn ret;\r\n}\r\ntrace_gb_hd_add(hd);\r\nreturn 0;\r\n}\r\nvoid gb_hd_del(struct gb_host_device *hd)\r\n{\r\ntrace_gb_hd_del(hd);\r\ngb_svc_del(hd->svc);\r\ndevice_del(&hd->dev);\r\n}\r\nvoid gb_hd_shutdown(struct gb_host_device *hd)\r\n{\r\ngb_svc_del(hd->svc);\r\n}\r\nvoid gb_hd_put(struct gb_host_device *hd)\r\n{\r\nput_device(&hd->dev);\r\n}\r\nint __init gb_hd_init(void)\r\n{\r\nida_init(&gb_hd_bus_id_map);\r\nreturn 0;\r\n}\r\nvoid gb_hd_exit(void)\r\n{\r\nida_destroy(&gb_hd_bus_id_map);\r\n}
