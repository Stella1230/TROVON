int i2c_transfer_trace_reg(void)\r\n{\r\nstatic_key_slow_inc(&i2c_trace_msg);\r\nreturn 0;\r\n}\r\nvoid i2c_transfer_trace_unreg(void)\r\n{\r\nstatic_key_slow_dec(&i2c_trace_msg);\r\n}\r\nconst struct i2c_device_id *i2c_match_id(const struct i2c_device_id *id,\r\nconst struct i2c_client *client)\r\n{\r\nif (!(id && client))\r\nreturn NULL;\r\nwhile (id->name[0]) {\r\nif (strcmp(client->name, id->name) == 0)\r\nreturn id;\r\nid++;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int i2c_device_match(struct device *dev, struct device_driver *drv)\r\n{\r\nstruct i2c_client *client = i2c_verify_client(dev);\r\nstruct i2c_driver *driver;\r\nif (i2c_of_match_device(drv->of_match_table, client))\r\nreturn 1;\r\nif (acpi_driver_match_device(dev, drv))\r\nreturn 1;\r\ndriver = to_i2c_driver(drv);\r\nif (i2c_match_id(driver->id_table, client))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int i2c_device_uevent(struct device *dev, struct kobj_uevent_env *env)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nint rc;\r\nrc = acpi_device_uevent_modalias(dev, env);\r\nif (rc != -ENODEV)\r\nreturn rc;\r\nreturn add_uevent_var(env, "MODALIAS=%s%s", I2C_MODULE_PREFIX, client->name);\r\n}\r\nstatic int get_scl_gpio_value(struct i2c_adapter *adap)\r\n{\r\nreturn gpio_get_value(adap->bus_recovery_info->scl_gpio);\r\n}\r\nstatic void set_scl_gpio_value(struct i2c_adapter *adap, int val)\r\n{\r\ngpio_set_value(adap->bus_recovery_info->scl_gpio, val);\r\n}\r\nstatic int get_sda_gpio_value(struct i2c_adapter *adap)\r\n{\r\nreturn gpio_get_value(adap->bus_recovery_info->sda_gpio);\r\n}\r\nstatic int i2c_get_gpios_for_recovery(struct i2c_adapter *adap)\r\n{\r\nstruct i2c_bus_recovery_info *bri = adap->bus_recovery_info;\r\nstruct device *dev = &adap->dev;\r\nint ret = 0;\r\nret = gpio_request_one(bri->scl_gpio, GPIOF_OPEN_DRAIN |\r\nGPIOF_OUT_INIT_HIGH, "i2c-scl");\r\nif (ret) {\r\ndev_warn(dev, "Can't get SCL gpio: %d\n", bri->scl_gpio);\r\nreturn ret;\r\n}\r\nif (bri->get_sda) {\r\nif (gpio_request_one(bri->sda_gpio, GPIOF_IN, "i2c-sda")) {\r\ndev_warn(dev, "Can't get SDA gpio: %d. Not using SDA polling\n",\r\nbri->sda_gpio);\r\nbri->get_sda = NULL;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void i2c_put_gpios_for_recovery(struct i2c_adapter *adap)\r\n{\r\nstruct i2c_bus_recovery_info *bri = adap->bus_recovery_info;\r\nif (bri->get_sda)\r\ngpio_free(bri->sda_gpio);\r\ngpio_free(bri->scl_gpio);\r\n}\r\nstatic int i2c_generic_recovery(struct i2c_adapter *adap)\r\n{\r\nstruct i2c_bus_recovery_info *bri = adap->bus_recovery_info;\r\nint i = 0, val = 1, ret = 0;\r\nif (bri->prepare_recovery)\r\nbri->prepare_recovery(adap);\r\nbri->set_scl(adap, val);\r\nndelay(RECOVERY_NDELAY);\r\nwhile (i++ < RECOVERY_CLK_CNT * 2) {\r\nif (val) {\r\nif (bri->get_sda && bri->get_sda(adap))\r\nbreak;\r\nif (!bri->get_scl(adap)) {\r\ndev_err(&adap->dev,\r\n"SCL is stuck low, exit recovery\n");\r\nret = -EBUSY;\r\nbreak;\r\n}\r\n}\r\nval = !val;\r\nbri->set_scl(adap, val);\r\nndelay(RECOVERY_NDELAY);\r\n}\r\nif (bri->unprepare_recovery)\r\nbri->unprepare_recovery(adap);\r\nreturn ret;\r\n}\r\nint i2c_generic_scl_recovery(struct i2c_adapter *adap)\r\n{\r\nreturn i2c_generic_recovery(adap);\r\n}\r\nint i2c_generic_gpio_recovery(struct i2c_adapter *adap)\r\n{\r\nint ret;\r\nret = i2c_get_gpios_for_recovery(adap);\r\nif (ret)\r\nreturn ret;\r\nret = i2c_generic_recovery(adap);\r\ni2c_put_gpios_for_recovery(adap);\r\nreturn ret;\r\n}\r\nint i2c_recover_bus(struct i2c_adapter *adap)\r\n{\r\nif (!adap->bus_recovery_info)\r\nreturn -EOPNOTSUPP;\r\ndev_dbg(&adap->dev, "Trying i2c bus recovery\n");\r\nreturn adap->bus_recovery_info->recover_bus(adap);\r\n}\r\nstatic void i2c_init_recovery(struct i2c_adapter *adap)\r\n{\r\nstruct i2c_bus_recovery_info *bri = adap->bus_recovery_info;\r\nchar *err_str;\r\nif (!bri)\r\nreturn;\r\nif (!bri->recover_bus) {\r\nerr_str = "no recover_bus() found";\r\ngoto err;\r\n}\r\nif (bri->recover_bus == i2c_generic_gpio_recovery) {\r\nif (!gpio_is_valid(bri->scl_gpio)) {\r\nerr_str = "invalid SCL gpio";\r\ngoto err;\r\n}\r\nif (gpio_is_valid(bri->sda_gpio))\r\nbri->get_sda = get_sda_gpio_value;\r\nelse\r\nbri->get_sda = NULL;\r\nbri->get_scl = get_scl_gpio_value;\r\nbri->set_scl = set_scl_gpio_value;\r\n} else if (bri->recover_bus == i2c_generic_scl_recovery) {\r\nif (!bri->set_scl || !bri->get_scl) {\r\nerr_str = "no {get|set}_scl() found";\r\ngoto err;\r\n}\r\n}\r\nreturn;\r\nerr:\r\ndev_err(&adap->dev, "Not using recovery: %s\n", err_str);\r\nadap->bus_recovery_info = NULL;\r\n}\r\nstatic int i2c_smbus_host_notify_to_irq(const struct i2c_client *client)\r\n{\r\nstruct i2c_adapter *adap = client->adapter;\r\nunsigned int irq;\r\nif (!adap->host_notify_domain)\r\nreturn -ENXIO;\r\nif (client->flags & I2C_CLIENT_TEN)\r\nreturn -EINVAL;\r\nirq = irq_find_mapping(adap->host_notify_domain, client->addr);\r\nif (!irq)\r\nirq = irq_create_mapping(adap->host_notify_domain,\r\nclient->addr);\r\nreturn irq > 0 ? irq : -ENXIO;\r\n}\r\nstatic int i2c_device_probe(struct device *dev)\r\n{\r\nstruct i2c_client *client = i2c_verify_client(dev);\r\nstruct i2c_driver *driver;\r\nint status;\r\nif (!client)\r\nreturn 0;\r\ndriver = to_i2c_driver(dev->driver);\r\nif (!client->irq && !driver->disable_i2c_core_irq_mapping) {\r\nint irq = -ENOENT;\r\nif (client->flags & I2C_CLIENT_HOST_NOTIFY) {\r\ndev_dbg(dev, "Using Host Notify IRQ\n");\r\nirq = i2c_smbus_host_notify_to_irq(client);\r\n} else if (dev->of_node) {\r\nirq = of_irq_get_byname(dev->of_node, "irq");\r\nif (irq == -EINVAL || irq == -ENODATA)\r\nirq = of_irq_get(dev->of_node, 0);\r\n} else if (ACPI_COMPANION(dev)) {\r\nirq = acpi_dev_gpio_irq_get(ACPI_COMPANION(dev), 0);\r\n}\r\nif (irq == -EPROBE_DEFER)\r\nreturn irq;\r\nif (irq < 0)\r\nirq = 0;\r\nclient->irq = irq;\r\n}\r\nif (!driver->id_table &&\r\n!i2c_acpi_match_device(dev->driver->acpi_match_table, client) &&\r\n!i2c_of_match_device(dev->driver->of_match_table, client))\r\nreturn -ENODEV;\r\nif (client->flags & I2C_CLIENT_WAKE) {\r\nint wakeirq = -ENOENT;\r\nif (dev->of_node) {\r\nwakeirq = of_irq_get_byname(dev->of_node, "wakeup");\r\nif (wakeirq == -EPROBE_DEFER)\r\nreturn wakeirq;\r\n}\r\ndevice_init_wakeup(&client->dev, true);\r\nif (wakeirq > 0 && wakeirq != client->irq)\r\nstatus = dev_pm_set_dedicated_wake_irq(dev, wakeirq);\r\nelse if (client->irq > 0)\r\nstatus = dev_pm_set_wake_irq(dev, client->irq);\r\nelse\r\nstatus = 0;\r\nif (status)\r\ndev_warn(&client->dev, "failed to set up wakeup irq\n");\r\n}\r\ndev_dbg(dev, "probe\n");\r\nstatus = of_clk_set_defaults(dev->of_node, false);\r\nif (status < 0)\r\ngoto err_clear_wakeup_irq;\r\nstatus = dev_pm_domain_attach(&client->dev, true);\r\nif (status == -EPROBE_DEFER)\r\ngoto err_clear_wakeup_irq;\r\nif (driver->probe_new)\r\nstatus = driver->probe_new(client);\r\nelse if (driver->probe)\r\nstatus = driver->probe(client,\r\ni2c_match_id(driver->id_table, client));\r\nelse\r\nstatus = -EINVAL;\r\nif (status)\r\ngoto err_detach_pm_domain;\r\nreturn 0;\r\nerr_detach_pm_domain:\r\ndev_pm_domain_detach(&client->dev, true);\r\nerr_clear_wakeup_irq:\r\ndev_pm_clear_wake_irq(&client->dev);\r\ndevice_init_wakeup(&client->dev, false);\r\nreturn status;\r\n}\r\nstatic int i2c_device_remove(struct device *dev)\r\n{\r\nstruct i2c_client *client = i2c_verify_client(dev);\r\nstruct i2c_driver *driver;\r\nint status = 0;\r\nif (!client || !dev->driver)\r\nreturn 0;\r\ndriver = to_i2c_driver(dev->driver);\r\nif (driver->remove) {\r\ndev_dbg(dev, "remove\n");\r\nstatus = driver->remove(client);\r\n}\r\ndev_pm_domain_detach(&client->dev, true);\r\ndev_pm_clear_wake_irq(&client->dev);\r\ndevice_init_wakeup(&client->dev, false);\r\nreturn status;\r\n}\r\nstatic void i2c_device_shutdown(struct device *dev)\r\n{\r\nstruct i2c_client *client = i2c_verify_client(dev);\r\nstruct i2c_driver *driver;\r\nif (!client || !dev->driver)\r\nreturn;\r\ndriver = to_i2c_driver(dev->driver);\r\nif (driver->shutdown)\r\ndriver->shutdown(client);\r\n}\r\nstatic void i2c_client_dev_release(struct device *dev)\r\n{\r\nkfree(to_i2c_client(dev));\r\n}\r\nstatic ssize_t\r\nshow_name(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%s\n", dev->type == &i2c_client_type ?\r\nto_i2c_client(dev)->name : to_i2c_adapter(dev)->name);\r\n}\r\nstatic ssize_t\r\nshow_modalias(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nint len;\r\nlen = acpi_device_modalias(dev, buf, PAGE_SIZE -1);\r\nif (len != -ENODEV)\r\nreturn len;\r\nreturn sprintf(buf, "%s%s\n", I2C_MODULE_PREFIX, client->name);\r\n}\r\nstruct i2c_client *i2c_verify_client(struct device *dev)\r\n{\r\nreturn (dev->type == &i2c_client_type)\r\n? to_i2c_client(dev)\r\n: NULL;\r\n}\r\nstatic unsigned short i2c_encode_flags_to_addr(struct i2c_client *client)\r\n{\r\nunsigned short addr = client->addr;\r\nif (client->flags & I2C_CLIENT_TEN)\r\naddr |= I2C_ADDR_OFFSET_TEN_BIT;\r\nif (client->flags & I2C_CLIENT_SLAVE)\r\naddr |= I2C_ADDR_OFFSET_SLAVE;\r\nreturn addr;\r\n}\r\nint i2c_check_addr_validity(unsigned addr, unsigned short flags)\r\n{\r\nif (flags & I2C_CLIENT_TEN) {\r\nif (addr > 0x3ff)\r\nreturn -EINVAL;\r\n} else {\r\nif (addr == 0x00 || addr > 0x7f)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint i2c_check_7bit_addr_validity_strict(unsigned short addr)\r\n{\r\nif (addr < 0x08 || addr > 0x77)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int __i2c_check_addr_busy(struct device *dev, void *addrp)\r\n{\r\nstruct i2c_client *client = i2c_verify_client(dev);\r\nint addr = *(int *)addrp;\r\nif (client && i2c_encode_flags_to_addr(client) == addr)\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic int i2c_check_mux_parents(struct i2c_adapter *adapter, int addr)\r\n{\r\nstruct i2c_adapter *parent = i2c_parent_is_i2c_adapter(adapter);\r\nint result;\r\nresult = device_for_each_child(&adapter->dev, &addr,\r\n__i2c_check_addr_busy);\r\nif (!result && parent)\r\nresult = i2c_check_mux_parents(parent, addr);\r\nreturn result;\r\n}\r\nstatic int i2c_check_mux_children(struct device *dev, void *addrp)\r\n{\r\nint result;\r\nif (dev->type == &i2c_adapter_type)\r\nresult = device_for_each_child(dev, addrp,\r\ni2c_check_mux_children);\r\nelse\r\nresult = __i2c_check_addr_busy(dev, addrp);\r\nreturn result;\r\n}\r\nstatic int i2c_check_addr_busy(struct i2c_adapter *adapter, int addr)\r\n{\r\nstruct i2c_adapter *parent = i2c_parent_is_i2c_adapter(adapter);\r\nint result = 0;\r\nif (parent)\r\nresult = i2c_check_mux_parents(parent, addr);\r\nif (!result)\r\nresult = device_for_each_child(&adapter->dev, &addr,\r\ni2c_check_mux_children);\r\nreturn result;\r\n}\r\nstatic void i2c_adapter_lock_bus(struct i2c_adapter *adapter,\r\nunsigned int flags)\r\n{\r\nrt_mutex_lock(&adapter->bus_lock);\r\n}\r\nstatic int i2c_adapter_trylock_bus(struct i2c_adapter *adapter,\r\nunsigned int flags)\r\n{\r\nreturn rt_mutex_trylock(&adapter->bus_lock);\r\n}\r\nstatic void i2c_adapter_unlock_bus(struct i2c_adapter *adapter,\r\nunsigned int flags)\r\n{\r\nrt_mutex_unlock(&adapter->bus_lock);\r\n}\r\nstatic void i2c_dev_set_name(struct i2c_adapter *adap,\r\nstruct i2c_client *client)\r\n{\r\nstruct acpi_device *adev = ACPI_COMPANION(&client->dev);\r\nif (adev) {\r\ndev_set_name(&client->dev, "i2c-%s", acpi_dev_name(adev));\r\nreturn;\r\n}\r\ndev_set_name(&client->dev, "%d-%04x", i2c_adapter_id(adap),\r\ni2c_encode_flags_to_addr(client));\r\n}\r\nstatic int i2c_dev_irq_from_resources(const struct resource *resources,\r\nunsigned int num_resources)\r\n{\r\nstruct irq_data *irqd;\r\nint i;\r\nfor (i = 0; i < num_resources; i++) {\r\nconst struct resource *r = &resources[i];\r\nif (resource_type(r) != IORESOURCE_IRQ)\r\ncontinue;\r\nif (r->flags & IORESOURCE_BITS) {\r\nirqd = irq_get_irq_data(r->start);\r\nif (!irqd)\r\nbreak;\r\nirqd_set_trigger_type(irqd, r->flags & IORESOURCE_BITS);\r\n}\r\nreturn r->start;\r\n}\r\nreturn 0;\r\n}\r\nstruct i2c_client *\r\ni2c_new_device(struct i2c_adapter *adap, struct i2c_board_info const *info)\r\n{\r\nstruct i2c_client *client;\r\nint status;\r\nclient = kzalloc(sizeof *client, GFP_KERNEL);\r\nif (!client)\r\nreturn NULL;\r\nclient->adapter = adap;\r\nclient->dev.platform_data = info->platform_data;\r\nif (info->archdata)\r\nclient->dev.archdata = *info->archdata;\r\nclient->flags = info->flags;\r\nclient->addr = info->addr;\r\nclient->irq = info->irq;\r\nif (!client->irq)\r\nclient->irq = i2c_dev_irq_from_resources(info->resources,\r\ninfo->num_resources);\r\nstrlcpy(client->name, info->type, sizeof(client->name));\r\nstatus = i2c_check_addr_validity(client->addr, client->flags);\r\nif (status) {\r\ndev_err(&adap->dev, "Invalid %d-bit I2C address 0x%02hx\n",\r\nclient->flags & I2C_CLIENT_TEN ? 10 : 7, client->addr);\r\ngoto out_err_silent;\r\n}\r\nstatus = i2c_check_addr_busy(adap, i2c_encode_flags_to_addr(client));\r\nif (status)\r\ngoto out_err;\r\nclient->dev.parent = &client->adapter->dev;\r\nclient->dev.bus = &i2c_bus_type;\r\nclient->dev.type = &i2c_client_type;\r\nclient->dev.of_node = info->of_node;\r\nclient->dev.fwnode = info->fwnode;\r\ni2c_dev_set_name(adap, client);\r\nif (info->properties) {\r\nstatus = device_add_properties(&client->dev, info->properties);\r\nif (status) {\r\ndev_err(&adap->dev,\r\n"Failed to add properties to client %s: %d\n",\r\nclient->name, status);\r\ngoto out_err;\r\n}\r\n}\r\nstatus = device_register(&client->dev);\r\nif (status)\r\ngoto out_free_props;\r\ndev_dbg(&adap->dev, "client [%s] registered with bus id %s\n",\r\nclient->name, dev_name(&client->dev));\r\nreturn client;\r\nout_free_props:\r\nif (info->properties)\r\ndevice_remove_properties(&client->dev);\r\nout_err:\r\ndev_err(&adap->dev,\r\n"Failed to register i2c client %s at 0x%02x (%d)\n",\r\nclient->name, client->addr, status);\r\nout_err_silent:\r\nkfree(client);\r\nreturn NULL;\r\n}\r\nvoid i2c_unregister_device(struct i2c_client *client)\r\n{\r\nif (client->dev.of_node)\r\nof_node_clear_flag(client->dev.of_node, OF_POPULATED);\r\nif (ACPI_COMPANION(&client->dev))\r\nacpi_device_clear_enumerated(ACPI_COMPANION(&client->dev));\r\ndevice_unregister(&client->dev);\r\n}\r\nstatic int dummy_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nreturn 0;\r\n}\r\nstatic int dummy_remove(struct i2c_client *client)\r\n{\r\nreturn 0;\r\n}\r\nstruct i2c_client *i2c_new_dummy(struct i2c_adapter *adapter, u16 address)\r\n{\r\nstruct i2c_board_info info = {\r\nI2C_BOARD_INFO("dummy", address),\r\n};\r\nreturn i2c_new_device(adapter, &info);\r\n}\r\nstruct i2c_client *i2c_new_secondary_device(struct i2c_client *client,\r\nconst char *name,\r\nu16 default_addr)\r\n{\r\nstruct device_node *np = client->dev.of_node;\r\nu32 addr = default_addr;\r\nint i;\r\nif (np) {\r\ni = of_property_match_string(np, "reg-names", name);\r\nif (i >= 0)\r\nof_property_read_u32_index(np, "reg", i, &addr);\r\n}\r\ndev_dbg(&client->adapter->dev, "Address for %s : 0x%x\n", name, addr);\r\nreturn i2c_new_dummy(client->adapter, addr);\r\n}\r\nstatic void i2c_adapter_dev_release(struct device *dev)\r\n{\r\nstruct i2c_adapter *adap = to_i2c_adapter(dev);\r\ncomplete(&adap->dev_released);\r\n}\r\nunsigned int i2c_adapter_depth(struct i2c_adapter *adapter)\r\n{\r\nunsigned int depth = 0;\r\nwhile ((adapter = i2c_parent_is_i2c_adapter(adapter)))\r\ndepth++;\r\nWARN_ONCE(depth >= MAX_LOCKDEP_SUBCLASSES,\r\n"adapter depth exceeds lockdep subclass limit\n");\r\nreturn depth;\r\n}\r\nstatic ssize_t\r\ni2c_sysfs_new_device(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_adapter *adap = to_i2c_adapter(dev);\r\nstruct i2c_board_info info;\r\nstruct i2c_client *client;\r\nchar *blank, end;\r\nint res;\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\nblank = strchr(buf, ' ');\r\nif (!blank) {\r\ndev_err(dev, "%s: Missing parameters\n", "new_device");\r\nreturn -EINVAL;\r\n}\r\nif (blank - buf > I2C_NAME_SIZE - 1) {\r\ndev_err(dev, "%s: Invalid device name\n", "new_device");\r\nreturn -EINVAL;\r\n}\r\nmemcpy(info.type, buf, blank - buf);\r\nres = sscanf(++blank, "%hi%c", &info.addr, &end);\r\nif (res < 1) {\r\ndev_err(dev, "%s: Can't parse I2C address\n", "new_device");\r\nreturn -EINVAL;\r\n}\r\nif (res > 1 && end != '\n') {\r\ndev_err(dev, "%s: Extra parameters\n", "new_device");\r\nreturn -EINVAL;\r\n}\r\nif ((info.addr & I2C_ADDR_OFFSET_TEN_BIT) == I2C_ADDR_OFFSET_TEN_BIT) {\r\ninfo.addr &= ~I2C_ADDR_OFFSET_TEN_BIT;\r\ninfo.flags |= I2C_CLIENT_TEN;\r\n}\r\nif (info.addr & I2C_ADDR_OFFSET_SLAVE) {\r\ninfo.addr &= ~I2C_ADDR_OFFSET_SLAVE;\r\ninfo.flags |= I2C_CLIENT_SLAVE;\r\n}\r\nclient = i2c_new_device(adap, &info);\r\nif (!client)\r\nreturn -EINVAL;\r\nmutex_lock(&adap->userspace_clients_lock);\r\nlist_add_tail(&client->detected, &adap->userspace_clients);\r\nmutex_unlock(&adap->userspace_clients_lock);\r\ndev_info(dev, "%s: Instantiated device %s at 0x%02hx\n", "new_device",\r\ninfo.type, info.addr);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\ni2c_sysfs_delete_device(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_adapter *adap = to_i2c_adapter(dev);\r\nstruct i2c_client *client, *next;\r\nunsigned short addr;\r\nchar end;\r\nint res;\r\nres = sscanf(buf, "%hi%c", &addr, &end);\r\nif (res < 1) {\r\ndev_err(dev, "%s: Can't parse I2C address\n", "delete_device");\r\nreturn -EINVAL;\r\n}\r\nif (res > 1 && end != '\n') {\r\ndev_err(dev, "%s: Extra parameters\n", "delete_device");\r\nreturn -EINVAL;\r\n}\r\nres = -ENOENT;\r\nmutex_lock_nested(&adap->userspace_clients_lock,\r\ni2c_adapter_depth(adap));\r\nlist_for_each_entry_safe(client, next, &adap->userspace_clients,\r\ndetected) {\r\nif (i2c_encode_flags_to_addr(client) == addr) {\r\ndev_info(dev, "%s: Deleting device %s at 0x%02hx\n",\r\n"delete_device", client->name, client->addr);\r\nlist_del(&client->detected);\r\ni2c_unregister_device(client);\r\nres = count;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&adap->userspace_clients_lock);\r\nif (res < 0)\r\ndev_err(dev, "%s: Can't find device in list\n",\r\n"delete_device");\r\nreturn res;\r\n}\r\nstruct i2c_adapter *i2c_verify_adapter(struct device *dev)\r\n{\r\nreturn (dev->type == &i2c_adapter_type)\r\n? to_i2c_adapter(dev)\r\n: NULL;\r\n}\r\nstatic void i2c_scan_static_board_info(struct i2c_adapter *adapter)\r\n{\r\nstruct i2c_devinfo *devinfo;\r\ndown_read(&__i2c_board_lock);\r\nlist_for_each_entry(devinfo, &__i2c_board_list, list) {\r\nif (devinfo->busnum == adapter->nr\r\n&& !i2c_new_device(adapter,\r\n&devinfo->board_info))\r\ndev_err(&adapter->dev,\r\n"Can't create device at 0x%02x\n",\r\ndevinfo->board_info.addr);\r\n}\r\nup_read(&__i2c_board_lock);\r\n}\r\nstatic int i2c_do_add_adapter(struct i2c_driver *driver,\r\nstruct i2c_adapter *adap)\r\n{\r\ni2c_detect(adap, driver);\r\nif (driver->attach_adapter) {\r\ndev_warn(&adap->dev, "%s: attach_adapter method is deprecated\n",\r\ndriver->driver.name);\r\ndev_warn(&adap->dev,\r\n"Please use another way to instantiate your i2c_client\n");\r\ndriver->attach_adapter(adap);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __process_new_adapter(struct device_driver *d, void *data)\r\n{\r\nreturn i2c_do_add_adapter(to_i2c_driver(d), data);\r\n}\r\nstatic void i2c_host_notify_irq_teardown(struct i2c_adapter *adap)\r\n{\r\nstruct irq_domain *domain = adap->host_notify_domain;\r\nirq_hw_number_t hwirq;\r\nif (!domain)\r\nreturn;\r\nfor (hwirq = 0 ; hwirq < I2C_ADDR_7BITS_COUNT ; hwirq++)\r\nirq_dispose_mapping(irq_find_mapping(domain, hwirq));\r\nirq_domain_remove(domain);\r\nadap->host_notify_domain = NULL;\r\n}\r\nstatic int i2c_host_notify_irq_map(struct irq_domain *h,\r\nunsigned int virq,\r\nirq_hw_number_t hw_irq_num)\r\n{\r\nirq_set_chip_and_handler(virq, &dummy_irq_chip, handle_simple_irq);\r\nreturn 0;\r\n}\r\nstatic int i2c_setup_host_notify_irq_domain(struct i2c_adapter *adap)\r\n{\r\nstruct irq_domain *domain;\r\nif (!i2c_check_functionality(adap, I2C_FUNC_SMBUS_HOST_NOTIFY))\r\nreturn 0;\r\ndomain = irq_domain_create_linear(adap->dev.fwnode,\r\nI2C_ADDR_7BITS_COUNT,\r\n&i2c_host_notify_irq_ops, adap);\r\nif (!domain)\r\nreturn -ENOMEM;\r\nadap->host_notify_domain = domain;\r\nreturn 0;\r\n}\r\nint i2c_handle_smbus_host_notify(struct i2c_adapter *adap, unsigned short addr)\r\n{\r\nint irq;\r\nif (!adap)\r\nreturn -EINVAL;\r\nirq = irq_find_mapping(adap->host_notify_domain, addr);\r\nif (irq <= 0)\r\nreturn -ENXIO;\r\ngeneric_handle_irq(irq);\r\nreturn 0;\r\n}\r\nstatic int i2c_register_adapter(struct i2c_adapter *adap)\r\n{\r\nint res = -EINVAL;\r\nif (WARN_ON(!is_registered)) {\r\nres = -EAGAIN;\r\ngoto out_list;\r\n}\r\nif (WARN(!adap->name[0], "i2c adapter has no name"))\r\ngoto out_list;\r\nif (!adap->algo) {\r\npr_err("adapter '%s': no algo supplied!\n", adap->name);\r\ngoto out_list;\r\n}\r\nif (!adap->lock_ops)\r\nadap->lock_ops = &i2c_adapter_lock_ops;\r\nrt_mutex_init(&adap->bus_lock);\r\nrt_mutex_init(&adap->mux_lock);\r\nmutex_init(&adap->userspace_clients_lock);\r\nINIT_LIST_HEAD(&adap->userspace_clients);\r\nif (adap->timeout == 0)\r\nadap->timeout = HZ;\r\nres = i2c_setup_host_notify_irq_domain(adap);\r\nif (res) {\r\npr_err("adapter '%s': can't create Host Notify IRQs (%d)\n",\r\nadap->name, res);\r\ngoto out_list;\r\n}\r\ndev_set_name(&adap->dev, "i2c-%d", adap->nr);\r\nadap->dev.bus = &i2c_bus_type;\r\nadap->dev.type = &i2c_adapter_type;\r\nres = device_register(&adap->dev);\r\nif (res) {\r\npr_err("adapter '%s': can't register device (%d)\n", adap->name, res);\r\ngoto out_list;\r\n}\r\ndev_dbg(&adap->dev, "adapter [%s] registered\n", adap->name);\r\npm_runtime_no_callbacks(&adap->dev);\r\npm_suspend_ignore_children(&adap->dev, true);\r\npm_runtime_enable(&adap->dev);\r\n#ifdef CONFIG_I2C_COMPAT\r\nres = class_compat_create_link(i2c_adapter_compat_class, &adap->dev,\r\nadap->dev.parent);\r\nif (res)\r\ndev_warn(&adap->dev,\r\n"Failed to create compatibility class link\n");\r\n#endif\r\ni2c_init_recovery(adap);\r\nof_i2c_register_devices(adap);\r\ni2c_acpi_register_devices(adap);\r\ni2c_acpi_install_space_handler(adap);\r\nif (adap->nr < __i2c_first_dynamic_bus_num)\r\ni2c_scan_static_board_info(adap);\r\nmutex_lock(&core_lock);\r\nbus_for_each_drv(&i2c_bus_type, NULL, adap, __process_new_adapter);\r\nmutex_unlock(&core_lock);\r\nreturn 0;\r\nout_list:\r\nmutex_lock(&core_lock);\r\nidr_remove(&i2c_adapter_idr, adap->nr);\r\nmutex_unlock(&core_lock);\r\nreturn res;\r\n}\r\nstatic int __i2c_add_numbered_adapter(struct i2c_adapter *adap)\r\n{\r\nint id;\r\nmutex_lock(&core_lock);\r\nid = idr_alloc(&i2c_adapter_idr, adap, adap->nr, adap->nr + 1, GFP_KERNEL);\r\nmutex_unlock(&core_lock);\r\nif (WARN(id < 0, "couldn't get idr"))\r\nreturn id == -ENOSPC ? -EBUSY : id;\r\nreturn i2c_register_adapter(adap);\r\n}\r\nint i2c_add_adapter(struct i2c_adapter *adapter)\r\n{\r\nstruct device *dev = &adapter->dev;\r\nint id;\r\nif (dev->of_node) {\r\nid = of_alias_get_id(dev->of_node, "i2c");\r\nif (id >= 0) {\r\nadapter->nr = id;\r\nreturn __i2c_add_numbered_adapter(adapter);\r\n}\r\n}\r\nmutex_lock(&core_lock);\r\nid = idr_alloc(&i2c_adapter_idr, adapter,\r\n__i2c_first_dynamic_bus_num, 0, GFP_KERNEL);\r\nmutex_unlock(&core_lock);\r\nif (WARN(id < 0, "couldn't get idr"))\r\nreturn id;\r\nadapter->nr = id;\r\nreturn i2c_register_adapter(adapter);\r\n}\r\nint i2c_add_numbered_adapter(struct i2c_adapter *adap)\r\n{\r\nif (adap->nr == -1)\r\nreturn i2c_add_adapter(adap);\r\nreturn __i2c_add_numbered_adapter(adap);\r\n}\r\nstatic void i2c_do_del_adapter(struct i2c_driver *driver,\r\nstruct i2c_adapter *adapter)\r\n{\r\nstruct i2c_client *client, *_n;\r\nlist_for_each_entry_safe(client, _n, &driver->clients, detected) {\r\nif (client->adapter == adapter) {\r\ndev_dbg(&adapter->dev, "Removing %s at 0x%x\n",\r\nclient->name, client->addr);\r\nlist_del(&client->detected);\r\ni2c_unregister_device(client);\r\n}\r\n}\r\n}\r\nstatic int __unregister_client(struct device *dev, void *dummy)\r\n{\r\nstruct i2c_client *client = i2c_verify_client(dev);\r\nif (client && strcmp(client->name, "dummy"))\r\ni2c_unregister_device(client);\r\nreturn 0;\r\n}\r\nstatic int __unregister_dummy(struct device *dev, void *dummy)\r\n{\r\nstruct i2c_client *client = i2c_verify_client(dev);\r\nif (client)\r\ni2c_unregister_device(client);\r\nreturn 0;\r\n}\r\nstatic int __process_removed_adapter(struct device_driver *d, void *data)\r\n{\r\ni2c_do_del_adapter(to_i2c_driver(d), data);\r\nreturn 0;\r\n}\r\nvoid i2c_del_adapter(struct i2c_adapter *adap)\r\n{\r\nstruct i2c_adapter *found;\r\nstruct i2c_client *client, *next;\r\nmutex_lock(&core_lock);\r\nfound = idr_find(&i2c_adapter_idr, adap->nr);\r\nmutex_unlock(&core_lock);\r\nif (found != adap) {\r\npr_debug("attempting to delete unregistered adapter [%s]\n", adap->name);\r\nreturn;\r\n}\r\ni2c_acpi_remove_space_handler(adap);\r\nmutex_lock(&core_lock);\r\nbus_for_each_drv(&i2c_bus_type, NULL, adap,\r\n__process_removed_adapter);\r\nmutex_unlock(&core_lock);\r\nmutex_lock_nested(&adap->userspace_clients_lock,\r\ni2c_adapter_depth(adap));\r\nlist_for_each_entry_safe(client, next, &adap->userspace_clients,\r\ndetected) {\r\ndev_dbg(&adap->dev, "Removing %s at 0x%x\n", client->name,\r\nclient->addr);\r\nlist_del(&client->detected);\r\ni2c_unregister_device(client);\r\n}\r\nmutex_unlock(&adap->userspace_clients_lock);\r\ndevice_for_each_child(&adap->dev, NULL, __unregister_client);\r\ndevice_for_each_child(&adap->dev, NULL, __unregister_dummy);\r\n#ifdef CONFIG_I2C_COMPAT\r\nclass_compat_remove_link(i2c_adapter_compat_class, &adap->dev,\r\nadap->dev.parent);\r\n#endif\r\ndev_dbg(&adap->dev, "adapter [%s] unregistered\n", adap->name);\r\npm_runtime_disable(&adap->dev);\r\ni2c_host_notify_irq_teardown(adap);\r\ninit_completion(&adap->dev_released);\r\ndevice_unregister(&adap->dev);\r\nwait_for_completion(&adap->dev_released);\r\nmutex_lock(&core_lock);\r\nidr_remove(&i2c_adapter_idr, adap->nr);\r\nmutex_unlock(&core_lock);\r\nmemset(&adap->dev, 0, sizeof(adap->dev));\r\n}\r\nvoid i2c_parse_fw_timings(struct device *dev, struct i2c_timings *t, bool use_defaults)\r\n{\r\nint ret;\r\nmemset(t, 0, sizeof(*t));\r\nret = device_property_read_u32(dev, "clock-frequency", &t->bus_freq_hz);\r\nif (ret && use_defaults)\r\nt->bus_freq_hz = 100000;\r\nret = device_property_read_u32(dev, "i2c-scl-rising-time-ns", &t->scl_rise_ns);\r\nif (ret && use_defaults) {\r\nif (t->bus_freq_hz <= 100000)\r\nt->scl_rise_ns = 1000;\r\nelse if (t->bus_freq_hz <= 400000)\r\nt->scl_rise_ns = 300;\r\nelse\r\nt->scl_rise_ns = 120;\r\n}\r\nret = device_property_read_u32(dev, "i2c-scl-falling-time-ns", &t->scl_fall_ns);\r\nif (ret && use_defaults) {\r\nif (t->bus_freq_hz <= 400000)\r\nt->scl_fall_ns = 300;\r\nelse\r\nt->scl_fall_ns = 120;\r\n}\r\ndevice_property_read_u32(dev, "i2c-scl-internal-delay-ns", &t->scl_int_delay_ns);\r\nret = device_property_read_u32(dev, "i2c-sda-falling-time-ns", &t->sda_fall_ns);\r\nif (ret && use_defaults)\r\nt->sda_fall_ns = t->scl_fall_ns;\r\n}\r\nint i2c_for_each_dev(void *data, int (*fn)(struct device *, void *))\r\n{\r\nint res;\r\nmutex_lock(&core_lock);\r\nres = bus_for_each_dev(&i2c_bus_type, NULL, data, fn);\r\nmutex_unlock(&core_lock);\r\nreturn res;\r\n}\r\nstatic int __process_new_driver(struct device *dev, void *data)\r\n{\r\nif (dev->type != &i2c_adapter_type)\r\nreturn 0;\r\nreturn i2c_do_add_adapter(data, to_i2c_adapter(dev));\r\n}\r\nint i2c_register_driver(struct module *owner, struct i2c_driver *driver)\r\n{\r\nint res;\r\nif (WARN_ON(!is_registered))\r\nreturn -EAGAIN;\r\ndriver->driver.owner = owner;\r\ndriver->driver.bus = &i2c_bus_type;\r\nINIT_LIST_HEAD(&driver->clients);\r\nres = driver_register(&driver->driver);\r\nif (res)\r\nreturn res;\r\npr_debug("driver [%s] registered\n", driver->driver.name);\r\ni2c_for_each_dev(driver, __process_new_driver);\r\nreturn 0;\r\n}\r\nstatic int __process_removed_driver(struct device *dev, void *data)\r\n{\r\nif (dev->type == &i2c_adapter_type)\r\ni2c_do_del_adapter(data, to_i2c_adapter(dev));\r\nreturn 0;\r\n}\r\nvoid i2c_del_driver(struct i2c_driver *driver)\r\n{\r\ni2c_for_each_dev(driver, __process_removed_driver);\r\ndriver_unregister(&driver->driver);\r\npr_debug("driver [%s] unregistered\n", driver->driver.name);\r\n}\r\nstruct i2c_client *i2c_use_client(struct i2c_client *client)\r\n{\r\nif (client && get_device(&client->dev))\r\nreturn client;\r\nreturn NULL;\r\n}\r\nvoid i2c_release_client(struct i2c_client *client)\r\n{\r\nif (client)\r\nput_device(&client->dev);\r\n}\r\nstatic int i2c_cmd(struct device *dev, void *_arg)\r\n{\r\nstruct i2c_client *client = i2c_verify_client(dev);\r\nstruct i2c_cmd_arg *arg = _arg;\r\nstruct i2c_driver *driver;\r\nif (!client || !client->dev.driver)\r\nreturn 0;\r\ndriver = to_i2c_driver(client->dev.driver);\r\nif (driver->command)\r\ndriver->command(client, arg->cmd, arg->arg);\r\nreturn 0;\r\n}\r\nvoid i2c_clients_command(struct i2c_adapter *adap, unsigned int cmd, void *arg)\r\n{\r\nstruct i2c_cmd_arg cmd_arg;\r\ncmd_arg.cmd = cmd;\r\ncmd_arg.arg = arg;\r\ndevice_for_each_child(&adap->dev, &cmd_arg, i2c_cmd);\r\n}\r\nstatic int __init i2c_init(void)\r\n{\r\nint retval;\r\nretval = of_alias_get_highest_id("i2c");\r\ndown_write(&__i2c_board_lock);\r\nif (retval >= __i2c_first_dynamic_bus_num)\r\n__i2c_first_dynamic_bus_num = retval + 1;\r\nup_write(&__i2c_board_lock);\r\nretval = bus_register(&i2c_bus_type);\r\nif (retval)\r\nreturn retval;\r\nis_registered = true;\r\n#ifdef CONFIG_I2C_COMPAT\r\ni2c_adapter_compat_class = class_compat_register("i2c-adapter");\r\nif (!i2c_adapter_compat_class) {\r\nretval = -ENOMEM;\r\ngoto bus_err;\r\n}\r\n#endif\r\nretval = i2c_add_driver(&dummy_driver);\r\nif (retval)\r\ngoto class_err;\r\nif (IS_ENABLED(CONFIG_OF_DYNAMIC))\r\nWARN_ON(of_reconfig_notifier_register(&i2c_of_notifier));\r\nif (IS_ENABLED(CONFIG_ACPI))\r\nWARN_ON(acpi_reconfig_notifier_register(&i2c_acpi_notifier));\r\nreturn 0;\r\nclass_err:\r\n#ifdef CONFIG_I2C_COMPAT\r\nclass_compat_unregister(i2c_adapter_compat_class);\r\nbus_err:\r\n#endif\r\nis_registered = false;\r\nbus_unregister(&i2c_bus_type);\r\nreturn retval;\r\n}\r\nstatic void __exit i2c_exit(void)\r\n{\r\nif (IS_ENABLED(CONFIG_ACPI))\r\nWARN_ON(acpi_reconfig_notifier_unregister(&i2c_acpi_notifier));\r\nif (IS_ENABLED(CONFIG_OF_DYNAMIC))\r\nWARN_ON(of_reconfig_notifier_unregister(&i2c_of_notifier));\r\ni2c_del_driver(&dummy_driver);\r\n#ifdef CONFIG_I2C_COMPAT\r\nclass_compat_unregister(i2c_adapter_compat_class);\r\n#endif\r\nbus_unregister(&i2c_bus_type);\r\ntracepoint_synchronize_unregister();\r\n}\r\nstatic int i2c_quirk_error(struct i2c_adapter *adap, struct i2c_msg *msg, char *err_msg)\r\n{\r\ndev_err_ratelimited(&adap->dev, "adapter quirk: %s (addr 0x%04x, size %u, %s)\n",\r\nerr_msg, msg->addr, msg->len,\r\nmsg->flags & I2C_M_RD ? "read" : "write");\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int i2c_check_for_quirks(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)\r\n{\r\nconst struct i2c_adapter_quirks *q = adap->quirks;\r\nint max_num = q->max_num_msgs, i;\r\nbool do_len_check = true;\r\nif (q->flags & I2C_AQ_COMB) {\r\nmax_num = 2;\r\nif (num == 2) {\r\nif (q->flags & I2C_AQ_COMB_WRITE_FIRST && msgs[0].flags & I2C_M_RD)\r\nreturn i2c_quirk_error(adap, &msgs[0], "1st comb msg must be write");\r\nif (q->flags & I2C_AQ_COMB_READ_SECOND && !(msgs[1].flags & I2C_M_RD))\r\nreturn i2c_quirk_error(adap, &msgs[1], "2nd comb msg must be read");\r\nif (q->flags & I2C_AQ_COMB_SAME_ADDR && msgs[0].addr != msgs[1].addr)\r\nreturn i2c_quirk_error(adap, &msgs[0], "comb msg only to same addr");\r\nif (i2c_quirk_exceeded(msgs[0].len, q->max_comb_1st_msg_len))\r\nreturn i2c_quirk_error(adap, &msgs[0], "msg too long");\r\nif (i2c_quirk_exceeded(msgs[1].len, q->max_comb_2nd_msg_len))\r\nreturn i2c_quirk_error(adap, &msgs[1], "msg too long");\r\ndo_len_check = false;\r\n}\r\n}\r\nif (i2c_quirk_exceeded(num, max_num))\r\nreturn i2c_quirk_error(adap, &msgs[0], "too many messages");\r\nfor (i = 0; i < num; i++) {\r\nu16 len = msgs[i].len;\r\nif (msgs[i].flags & I2C_M_RD) {\r\nif (do_len_check && i2c_quirk_exceeded(len, q->max_read_len))\r\nreturn i2c_quirk_error(adap, &msgs[i], "msg too long");\r\n} else {\r\nif (do_len_check && i2c_quirk_exceeded(len, q->max_write_len))\r\nreturn i2c_quirk_error(adap, &msgs[i], "msg too long");\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint __i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)\r\n{\r\nunsigned long orig_jiffies;\r\nint ret, try;\r\nif (adap->quirks && i2c_check_for_quirks(adap, msgs, num))\r\nreturn -EOPNOTSUPP;\r\nif (static_key_false(&i2c_trace_msg)) {\r\nint i;\r\nfor (i = 0; i < num; i++)\r\nif (msgs[i].flags & I2C_M_RD)\r\ntrace_i2c_read(adap, &msgs[i], i);\r\nelse\r\ntrace_i2c_write(adap, &msgs[i], i);\r\n}\r\norig_jiffies = jiffies;\r\nfor (ret = 0, try = 0; try <= adap->retries; try++) {\r\nret = adap->algo->master_xfer(adap, msgs, num);\r\nif (ret != -EAGAIN)\r\nbreak;\r\nif (time_after(jiffies, orig_jiffies + adap->timeout))\r\nbreak;\r\n}\r\nif (static_key_false(&i2c_trace_msg)) {\r\nint i;\r\nfor (i = 0; i < ret; i++)\r\nif (msgs[i].flags & I2C_M_RD)\r\ntrace_i2c_reply(adap, &msgs[i], i);\r\ntrace_i2c_result(adap, i, ret);\r\n}\r\nreturn ret;\r\n}\r\nint i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)\r\n{\r\nint ret;\r\nif (adap->algo->master_xfer) {\r\n#ifdef DEBUG\r\nfor (ret = 0; ret < num; ret++) {\r\ndev_dbg(&adap->dev,\r\n"master_xfer[%d] %c, addr=0x%02x, len=%d%s\n",\r\nret, (msgs[ret].flags & I2C_M_RD) ? 'R' : 'W',\r\nmsgs[ret].addr, msgs[ret].len,\r\n(msgs[ret].flags & I2C_M_RECV_LEN) ? "+" : "");\r\n}\r\n#endif\r\nif (in_atomic() || irqs_disabled()) {\r\nret = i2c_trylock_bus(adap, I2C_LOCK_SEGMENT);\r\nif (!ret)\r\nreturn -EAGAIN;\r\n} else {\r\ni2c_lock_bus(adap, I2C_LOCK_SEGMENT);\r\n}\r\nret = __i2c_transfer(adap, msgs, num);\r\ni2c_unlock_bus(adap, I2C_LOCK_SEGMENT);\r\nreturn ret;\r\n} else {\r\ndev_dbg(&adap->dev, "I2C level transfers not supported\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nint i2c_master_send(const struct i2c_client *client, const char *buf, int count)\r\n{\r\nint ret;\r\nstruct i2c_adapter *adap = client->adapter;\r\nstruct i2c_msg msg;\r\nmsg.addr = client->addr;\r\nmsg.flags = client->flags & I2C_M_TEN;\r\nmsg.len = count;\r\nmsg.buf = (char *)buf;\r\nret = i2c_transfer(adap, &msg, 1);\r\nreturn (ret == 1) ? count : ret;\r\n}\r\nint i2c_master_recv(const struct i2c_client *client, char *buf, int count)\r\n{\r\nstruct i2c_adapter *adap = client->adapter;\r\nstruct i2c_msg msg;\r\nint ret;\r\nmsg.addr = client->addr;\r\nmsg.flags = client->flags & I2C_M_TEN;\r\nmsg.flags |= I2C_M_RD;\r\nmsg.len = count;\r\nmsg.buf = buf;\r\nret = i2c_transfer(adap, &msg, 1);\r\nreturn (ret == 1) ? count : ret;\r\n}\r\nstatic int i2c_default_probe(struct i2c_adapter *adap, unsigned short addr)\r\n{\r\nint err;\r\nunion i2c_smbus_data dummy;\r\n#ifdef CONFIG_X86\r\nif (addr == 0x73 && (adap->class & I2C_CLASS_HWMON)\r\n&& i2c_check_functionality(adap, I2C_FUNC_SMBUS_READ_BYTE_DATA))\r\nerr = i2c_smbus_xfer(adap, addr, 0, I2C_SMBUS_READ, 0,\r\nI2C_SMBUS_BYTE_DATA, &dummy);\r\nelse\r\n#endif\r\nif (!((addr & ~0x07) == 0x30 || (addr & ~0x0f) == 0x50)\r\n&& i2c_check_functionality(adap, I2C_FUNC_SMBUS_QUICK))\r\nerr = i2c_smbus_xfer(adap, addr, 0, I2C_SMBUS_WRITE, 0,\r\nI2C_SMBUS_QUICK, NULL);\r\nelse if (i2c_check_functionality(adap, I2C_FUNC_SMBUS_READ_BYTE))\r\nerr = i2c_smbus_xfer(adap, addr, 0, I2C_SMBUS_READ, 0,\r\nI2C_SMBUS_BYTE, &dummy);\r\nelse {\r\ndev_warn(&adap->dev, "No suitable probing method supported for address 0x%02X\n",\r\naddr);\r\nerr = -EOPNOTSUPP;\r\n}\r\nreturn err >= 0;\r\n}\r\nstatic int i2c_detect_address(struct i2c_client *temp_client,\r\nstruct i2c_driver *driver)\r\n{\r\nstruct i2c_board_info info;\r\nstruct i2c_adapter *adapter = temp_client->adapter;\r\nint addr = temp_client->addr;\r\nint err;\r\nerr = i2c_check_7bit_addr_validity_strict(addr);\r\nif (err) {\r\ndev_warn(&adapter->dev, "Invalid probe address 0x%02x\n",\r\naddr);\r\nreturn err;\r\n}\r\nif (i2c_check_addr_busy(adapter, addr))\r\nreturn 0;\r\nif (!i2c_default_probe(adapter, addr))\r\nreturn 0;\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\ninfo.addr = addr;\r\nerr = driver->detect(temp_client, &info);\r\nif (err) {\r\nreturn err == -ENODEV ? 0 : err;\r\n}\r\nif (info.type[0] == '\0') {\r\ndev_err(&adapter->dev,\r\n"%s detection function provided no name for 0x%x\n",\r\ndriver->driver.name, addr);\r\n} else {\r\nstruct i2c_client *client;\r\nif (adapter->class & I2C_CLASS_DEPRECATED)\r\ndev_warn(&adapter->dev,\r\n"This adapter will soon drop class based instantiation of devices. "\r\n"Please make sure client 0x%02x gets instantiated by other means. "\r\n"Check 'Documentation/i2c/instantiating-devices' for details.\n",\r\ninfo.addr);\r\ndev_dbg(&adapter->dev, "Creating %s at 0x%02x\n",\r\ninfo.type, info.addr);\r\nclient = i2c_new_device(adapter, &info);\r\nif (client)\r\nlist_add_tail(&client->detected, &driver->clients);\r\nelse\r\ndev_err(&adapter->dev, "Failed creating %s at 0x%02x\n",\r\ninfo.type, info.addr);\r\n}\r\nreturn 0;\r\n}\r\nstatic int i2c_detect(struct i2c_adapter *adapter, struct i2c_driver *driver)\r\n{\r\nconst unsigned short *address_list;\r\nstruct i2c_client *temp_client;\r\nint i, err = 0;\r\nint adap_id = i2c_adapter_id(adapter);\r\naddress_list = driver->address_list;\r\nif (!driver->detect || !address_list)\r\nreturn 0;\r\nif (adapter->class == I2C_CLASS_DEPRECATED) {\r\ndev_dbg(&adapter->dev,\r\n"This adapter dropped support for I2C classes and won't auto-detect %s devices anymore. "\r\n"If you need it, check 'Documentation/i2c/instantiating-devices' for alternatives.\n",\r\ndriver->driver.name);\r\nreturn 0;\r\n}\r\nif (!(adapter->class & driver->class))\r\nreturn 0;\r\ntemp_client = kzalloc(sizeof(struct i2c_client), GFP_KERNEL);\r\nif (!temp_client)\r\nreturn -ENOMEM;\r\ntemp_client->adapter = adapter;\r\nfor (i = 0; address_list[i] != I2C_CLIENT_END; i += 1) {\r\ndev_dbg(&adapter->dev,\r\n"found normal entry for adapter %d, addr 0x%02x\n",\r\nadap_id, address_list[i]);\r\ntemp_client->addr = address_list[i];\r\nerr = i2c_detect_address(temp_client, driver);\r\nif (unlikely(err))\r\nbreak;\r\n}\r\nkfree(temp_client);\r\nreturn err;\r\n}\r\nint i2c_probe_func_quick_read(struct i2c_adapter *adap, unsigned short addr)\r\n{\r\nreturn i2c_smbus_xfer(adap, addr, 0, I2C_SMBUS_READ, 0,\r\nI2C_SMBUS_QUICK, NULL) >= 0;\r\n}\r\nstruct i2c_client *\r\ni2c_new_probed_device(struct i2c_adapter *adap,\r\nstruct i2c_board_info *info,\r\nunsigned short const *addr_list,\r\nint (*probe)(struct i2c_adapter *, unsigned short addr))\r\n{\r\nint i;\r\nif (!probe)\r\nprobe = i2c_default_probe;\r\nfor (i = 0; addr_list[i] != I2C_CLIENT_END; i++) {\r\nif (i2c_check_7bit_addr_validity_strict(addr_list[i]) < 0) {\r\ndev_warn(&adap->dev, "Invalid 7-bit address 0x%02x\n",\r\naddr_list[i]);\r\ncontinue;\r\n}\r\nif (i2c_check_addr_busy(adap, addr_list[i])) {\r\ndev_dbg(&adap->dev,\r\n"Address 0x%02x already in use, not probing\n",\r\naddr_list[i]);\r\ncontinue;\r\n}\r\nif (probe(adap, addr_list[i]))\r\nbreak;\r\n}\r\nif (addr_list[i] == I2C_CLIENT_END) {\r\ndev_dbg(&adap->dev, "Probing failed, no device found\n");\r\nreturn NULL;\r\n}\r\ninfo->addr = addr_list[i];\r\nreturn i2c_new_device(adap, info);\r\n}\r\nstruct i2c_adapter *i2c_get_adapter(int nr)\r\n{\r\nstruct i2c_adapter *adapter;\r\nmutex_lock(&core_lock);\r\nadapter = idr_find(&i2c_adapter_idr, nr);\r\nif (!adapter)\r\ngoto exit;\r\nif (try_module_get(adapter->owner))\r\nget_device(&adapter->dev);\r\nelse\r\nadapter = NULL;\r\nexit:\r\nmutex_unlock(&core_lock);\r\nreturn adapter;\r\n}\r\nvoid i2c_put_adapter(struct i2c_adapter *adap)\r\n{\r\nif (!adap)\r\nreturn;\r\nput_device(&adap->dev);\r\nmodule_put(adap->owner);\r\n}
