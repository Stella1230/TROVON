static unsigned int xt_rateest_hash(const char *name)\r\n{\r\nreturn jhash(name, FIELD_SIZEOF(struct xt_rateest, name), jhash_rnd) &\r\n(RATEEST_HSIZE - 1);\r\n}\r\nstatic void xt_rateest_hash_insert(struct xt_rateest *est)\r\n{\r\nunsigned int h;\r\nh = xt_rateest_hash(est->name);\r\nhlist_add_head(&est->list, &rateest_hash[h]);\r\n}\r\nstruct xt_rateest *xt_rateest_lookup(const char *name)\r\n{\r\nstruct xt_rateest *est;\r\nunsigned int h;\r\nh = xt_rateest_hash(name);\r\nmutex_lock(&xt_rateest_mutex);\r\nhlist_for_each_entry(est, &rateest_hash[h], list) {\r\nif (strcmp(est->name, name) == 0) {\r\nest->refcnt++;\r\nmutex_unlock(&xt_rateest_mutex);\r\nreturn est;\r\n}\r\n}\r\nmutex_unlock(&xt_rateest_mutex);\r\nreturn NULL;\r\n}\r\nvoid xt_rateest_put(struct xt_rateest *est)\r\n{\r\nmutex_lock(&xt_rateest_mutex);\r\nif (--est->refcnt == 0) {\r\nhlist_del(&est->list);\r\ngen_kill_estimator(&est->rate_est);\r\nkfree_rcu(est, rcu);\r\n}\r\nmutex_unlock(&xt_rateest_mutex);\r\n}\r\nstatic unsigned int\r\nxt_rateest_tg(struct sk_buff *skb, const struct xt_action_param *par)\r\n{\r\nconst struct xt_rateest_target_info *info = par->targinfo;\r\nstruct gnet_stats_basic_packed *stats = &info->est->bstats;\r\nspin_lock_bh(&info->est->lock);\r\nstats->bytes += skb->len;\r\nstats->packets++;\r\nspin_unlock_bh(&info->est->lock);\r\nreturn XT_CONTINUE;\r\n}\r\nstatic int xt_rateest_tg_checkentry(const struct xt_tgchk_param *par)\r\n{\r\nstruct xt_rateest_target_info *info = par->targinfo;\r\nstruct xt_rateest *est;\r\nstruct {\r\nstruct nlattr opt;\r\nstruct gnet_estimator est;\r\n} cfg;\r\nint ret;\r\nnet_get_random_once(&jhash_rnd, sizeof(jhash_rnd));\r\nest = xt_rateest_lookup(info->name);\r\nif (est) {\r\nif ((!info->interval && !info->ewma_log) ||\r\n(info->interval != est->params.interval ||\r\ninfo->ewma_log != est->params.ewma_log)) {\r\nxt_rateest_put(est);\r\nreturn -EINVAL;\r\n}\r\ninfo->est = est;\r\nreturn 0;\r\n}\r\nret = -ENOMEM;\r\nest = kzalloc(sizeof(*est), GFP_KERNEL);\r\nif (!est)\r\ngoto err1;\r\nstrlcpy(est->name, info->name, sizeof(est->name));\r\nspin_lock_init(&est->lock);\r\nest->refcnt = 1;\r\nest->params.interval = info->interval;\r\nest->params.ewma_log = info->ewma_log;\r\ncfg.opt.nla_len = nla_attr_size(sizeof(cfg.est));\r\ncfg.opt.nla_type = TCA_STATS_RATE_EST;\r\ncfg.est.interval = info->interval;\r\ncfg.est.ewma_log = info->ewma_log;\r\nret = gen_new_estimator(&est->bstats, NULL, &est->rate_est,\r\n&est->lock, NULL, &cfg.opt);\r\nif (ret < 0)\r\ngoto err2;\r\ninfo->est = est;\r\nxt_rateest_hash_insert(est);\r\nreturn 0;\r\nerr2:\r\nkfree(est);\r\nerr1:\r\nreturn ret;\r\n}\r\nstatic void xt_rateest_tg_destroy(const struct xt_tgdtor_param *par)\r\n{\r\nstruct xt_rateest_target_info *info = par->targinfo;\r\nxt_rateest_put(info->est);\r\n}\r\nstatic int __init xt_rateest_tg_init(void)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(rateest_hash); i++)\r\nINIT_HLIST_HEAD(&rateest_hash[i]);\r\nreturn xt_register_target(&xt_rateest_tg_reg);\r\n}\r\nstatic void __exit xt_rateest_tg_fini(void)\r\n{\r\nxt_unregister_target(&xt_rateest_tg_reg);\r\n}
