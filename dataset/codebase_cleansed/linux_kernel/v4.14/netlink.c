int\r\nbatadv_netlink_get_ifindex(const struct nlmsghdr *nlh, int attrtype)\r\n{\r\nstruct nlattr *attr = nlmsg_find_attr(nlh, GENL_HDRLEN, attrtype);\r\nreturn attr ? nla_get_u32(attr) : 0;\r\n}\r\nstatic int\r\nbatadv_netlink_mesh_info_put(struct sk_buff *msg, struct net_device *soft_iface)\r\n{\r\nstruct batadv_priv *bat_priv = netdev_priv(soft_iface);\r\nstruct batadv_hard_iface *primary_if = NULL;\r\nstruct net_device *hard_iface;\r\nint ret = -ENOBUFS;\r\nif (nla_put_string(msg, BATADV_ATTR_VERSION, BATADV_SOURCE_VERSION) ||\r\nnla_put_string(msg, BATADV_ATTR_ALGO_NAME,\r\nbat_priv->algo_ops->name) ||\r\nnla_put_u32(msg, BATADV_ATTR_MESH_IFINDEX, soft_iface->ifindex) ||\r\nnla_put_string(msg, BATADV_ATTR_MESH_IFNAME, soft_iface->name) ||\r\nnla_put(msg, BATADV_ATTR_MESH_ADDRESS, ETH_ALEN,\r\nsoft_iface->dev_addr) ||\r\nnla_put_u8(msg, BATADV_ATTR_TT_TTVN,\r\n(u8)atomic_read(&bat_priv->tt.vn)))\r\ngoto out;\r\n#ifdef CONFIG_BATMAN_ADV_BLA\r\nif (nla_put_u16(msg, BATADV_ATTR_BLA_CRC,\r\nntohs(bat_priv->bla.claim_dest.group)))\r\ngoto out;\r\n#endif\r\nprimary_if = batadv_primary_if_get_selected(bat_priv);\r\nif (primary_if && primary_if->if_status == BATADV_IF_ACTIVE) {\r\nhard_iface = primary_if->net_dev;\r\nif (nla_put_u32(msg, BATADV_ATTR_HARD_IFINDEX,\r\nhard_iface->ifindex) ||\r\nnla_put_string(msg, BATADV_ATTR_HARD_IFNAME,\r\nhard_iface->name) ||\r\nnla_put(msg, BATADV_ATTR_HARD_ADDRESS, ETH_ALEN,\r\nhard_iface->dev_addr))\r\ngoto out;\r\n}\r\nret = 0;\r\nout:\r\nif (primary_if)\r\nbatadv_hardif_put(primary_if);\r\nreturn ret;\r\n}\r\nstatic int\r\nbatadv_netlink_get_mesh_info(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct net *net = genl_info_net(info);\r\nstruct net_device *soft_iface;\r\nstruct sk_buff *msg = NULL;\r\nvoid *msg_head;\r\nint ifindex;\r\nint ret;\r\nif (!info->attrs[BATADV_ATTR_MESH_IFINDEX])\r\nreturn -EINVAL;\r\nifindex = nla_get_u32(info->attrs[BATADV_ATTR_MESH_IFINDEX]);\r\nif (!ifindex)\r\nreturn -EINVAL;\r\nsoft_iface = dev_get_by_index(net, ifindex);\r\nif (!soft_iface || !batadv_softif_is_valid(soft_iface)) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (!msg) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nmsg_head = genlmsg_put(msg, info->snd_portid, info->snd_seq,\r\n&batadv_netlink_family, 0,\r\nBATADV_CMD_GET_MESH_INFO);\r\nif (!msg_head) {\r\nret = -ENOBUFS;\r\ngoto out;\r\n}\r\nret = batadv_netlink_mesh_info_put(msg, soft_iface);\r\nout:\r\nif (soft_iface)\r\ndev_put(soft_iface);\r\nif (ret) {\r\nif (msg)\r\nnlmsg_free(msg);\r\nreturn ret;\r\n}\r\ngenlmsg_end(msg, msg_head);\r\nreturn genlmsg_reply(msg, info);\r\n}\r\nstatic int\r\nbatadv_netlink_tp_meter_put(struct sk_buff *msg, u32 cookie)\r\n{\r\nif (nla_put_u32(msg, BATADV_ATTR_TPMETER_COOKIE, cookie))\r\nreturn -ENOBUFS;\r\nreturn 0;\r\n}\r\nint batadv_netlink_tpmeter_notify(struct batadv_priv *bat_priv, const u8 *dst,\r\nu8 result, u32 test_time, u64 total_bytes,\r\nu32 cookie)\r\n{\r\nstruct sk_buff *msg;\r\nvoid *hdr;\r\nint ret;\r\nmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nhdr = genlmsg_put(msg, 0, 0, &batadv_netlink_family, 0,\r\nBATADV_CMD_TP_METER);\r\nif (!hdr) {\r\nret = -ENOBUFS;\r\ngoto err_genlmsg;\r\n}\r\nif (nla_put_u32(msg, BATADV_ATTR_TPMETER_COOKIE, cookie))\r\ngoto nla_put_failure;\r\nif (nla_put_u32(msg, BATADV_ATTR_TPMETER_TEST_TIME, test_time))\r\ngoto nla_put_failure;\r\nif (nla_put_u64_64bit(msg, BATADV_ATTR_TPMETER_BYTES, total_bytes,\r\nBATADV_ATTR_PAD))\r\ngoto nla_put_failure;\r\nif (nla_put_u8(msg, BATADV_ATTR_TPMETER_RESULT, result))\r\ngoto nla_put_failure;\r\nif (nla_put(msg, BATADV_ATTR_ORIG_ADDRESS, ETH_ALEN, dst))\r\ngoto nla_put_failure;\r\ngenlmsg_end(msg, hdr);\r\ngenlmsg_multicast_netns(&batadv_netlink_family,\r\ndev_net(bat_priv->soft_iface), msg, 0,\r\nBATADV_NL_MCGRP_TPMETER, GFP_KERNEL);\r\nreturn 0;\r\nnla_put_failure:\r\ngenlmsg_cancel(msg, hdr);\r\nret = -EMSGSIZE;\r\nerr_genlmsg:\r\nnlmsg_free(msg);\r\nreturn ret;\r\n}\r\nstatic int\r\nbatadv_netlink_tp_meter_start(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct net *net = genl_info_net(info);\r\nstruct net_device *soft_iface;\r\nstruct batadv_priv *bat_priv;\r\nstruct sk_buff *msg = NULL;\r\nu32 test_length;\r\nvoid *msg_head;\r\nint ifindex;\r\nu32 cookie;\r\nu8 *dst;\r\nint ret;\r\nif (!info->attrs[BATADV_ATTR_MESH_IFINDEX])\r\nreturn -EINVAL;\r\nif (!info->attrs[BATADV_ATTR_ORIG_ADDRESS])\r\nreturn -EINVAL;\r\nif (!info->attrs[BATADV_ATTR_TPMETER_TEST_TIME])\r\nreturn -EINVAL;\r\nifindex = nla_get_u32(info->attrs[BATADV_ATTR_MESH_IFINDEX]);\r\nif (!ifindex)\r\nreturn -EINVAL;\r\ndst = nla_data(info->attrs[BATADV_ATTR_ORIG_ADDRESS]);\r\ntest_length = nla_get_u32(info->attrs[BATADV_ATTR_TPMETER_TEST_TIME]);\r\nsoft_iface = dev_get_by_index(net, ifindex);\r\nif (!soft_iface || !batadv_softif_is_valid(soft_iface)) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (!msg) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nmsg_head = genlmsg_put(msg, info->snd_portid, info->snd_seq,\r\n&batadv_netlink_family, 0,\r\nBATADV_CMD_TP_METER);\r\nif (!msg_head) {\r\nret = -ENOBUFS;\r\ngoto out;\r\n}\r\nbat_priv = netdev_priv(soft_iface);\r\nbatadv_tp_start(bat_priv, dst, test_length, &cookie);\r\nret = batadv_netlink_tp_meter_put(msg, cookie);\r\nout:\r\nif (soft_iface)\r\ndev_put(soft_iface);\r\nif (ret) {\r\nif (msg)\r\nnlmsg_free(msg);\r\nreturn ret;\r\n}\r\ngenlmsg_end(msg, msg_head);\r\nreturn genlmsg_reply(msg, info);\r\n}\r\nstatic int\r\nbatadv_netlink_tp_meter_cancel(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct net *net = genl_info_net(info);\r\nstruct net_device *soft_iface;\r\nstruct batadv_priv *bat_priv;\r\nint ifindex;\r\nu8 *dst;\r\nint ret = 0;\r\nif (!info->attrs[BATADV_ATTR_MESH_IFINDEX])\r\nreturn -EINVAL;\r\nif (!info->attrs[BATADV_ATTR_ORIG_ADDRESS])\r\nreturn -EINVAL;\r\nifindex = nla_get_u32(info->attrs[BATADV_ATTR_MESH_IFINDEX]);\r\nif (!ifindex)\r\nreturn -EINVAL;\r\ndst = nla_data(info->attrs[BATADV_ATTR_ORIG_ADDRESS]);\r\nsoft_iface = dev_get_by_index(net, ifindex);\r\nif (!soft_iface || !batadv_softif_is_valid(soft_iface)) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nbat_priv = netdev_priv(soft_iface);\r\nbatadv_tp_stop(bat_priv, dst, BATADV_TP_REASON_CANCEL);\r\nout:\r\nif (soft_iface)\r\ndev_put(soft_iface);\r\nreturn ret;\r\n}\r\nstatic int\r\nbatadv_netlink_dump_hardif_entry(struct sk_buff *msg, u32 portid, u32 seq,\r\nstruct batadv_hard_iface *hard_iface)\r\n{\r\nstruct net_device *net_dev = hard_iface->net_dev;\r\nvoid *hdr;\r\nhdr = genlmsg_put(msg, portid, seq, &batadv_netlink_family, NLM_F_MULTI,\r\nBATADV_CMD_GET_HARDIFS);\r\nif (!hdr)\r\nreturn -EMSGSIZE;\r\nif (nla_put_u32(msg, BATADV_ATTR_HARD_IFINDEX,\r\nnet_dev->ifindex) ||\r\nnla_put_string(msg, BATADV_ATTR_HARD_IFNAME,\r\nnet_dev->name) ||\r\nnla_put(msg, BATADV_ATTR_HARD_ADDRESS, ETH_ALEN,\r\nnet_dev->dev_addr))\r\ngoto nla_put_failure;\r\nif (hard_iface->if_status == BATADV_IF_ACTIVE) {\r\nif (nla_put_flag(msg, BATADV_ATTR_ACTIVE))\r\ngoto nla_put_failure;\r\n}\r\ngenlmsg_end(msg, hdr);\r\nreturn 0;\r\nnla_put_failure:\r\ngenlmsg_cancel(msg, hdr);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int\r\nbatadv_netlink_dump_hardifs(struct sk_buff *msg, struct netlink_callback *cb)\r\n{\r\nstruct net *net = sock_net(cb->skb->sk);\r\nstruct net_device *soft_iface;\r\nstruct batadv_hard_iface *hard_iface;\r\nint ifindex;\r\nint portid = NETLINK_CB(cb->skb).portid;\r\nint seq = cb->nlh->nlmsg_seq;\r\nint skip = cb->args[0];\r\nint i = 0;\r\nifindex = batadv_netlink_get_ifindex(cb->nlh,\r\nBATADV_ATTR_MESH_IFINDEX);\r\nif (!ifindex)\r\nreturn -EINVAL;\r\nsoft_iface = dev_get_by_index(net, ifindex);\r\nif (!soft_iface)\r\nreturn -ENODEV;\r\nif (!batadv_softif_is_valid(soft_iface)) {\r\ndev_put(soft_iface);\r\nreturn -ENODEV;\r\n}\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(hard_iface, &batadv_hardif_list, list) {\r\nif (hard_iface->soft_iface != soft_iface)\r\ncontinue;\r\nif (i++ < skip)\r\ncontinue;\r\nif (batadv_netlink_dump_hardif_entry(msg, portid, seq,\r\nhard_iface)) {\r\ni--;\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\ndev_put(soft_iface);\r\ncb->args[0] = i;\r\nreturn msg->len;\r\n}\r\nvoid __init batadv_netlink_register(void)\r\n{\r\nint ret;\r\nret = genl_register_family(&batadv_netlink_family);\r\nif (ret)\r\npr_warn("unable to register netlink family");\r\n}\r\nvoid batadv_netlink_unregister(void)\r\n{\r\ngenl_unregister_family(&batadv_netlink_family);\r\n}
