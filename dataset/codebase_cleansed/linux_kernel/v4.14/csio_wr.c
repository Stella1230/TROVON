static void\r\ncsio_get_flbuf_size(struct csio_hw *hw, struct csio_sge *sge, uint32_t reg)\r\n{\r\nsge->sge_fl_buf_size[reg] = csio_rd_reg32(hw, SGE_FL_BUFFER_SIZE0_A +\r\nreg * sizeof(uint32_t));\r\n}\r\nstatic inline uint32_t\r\ncsio_wr_fl_bufsz(struct csio_sge *sge, struct csio_dma_buf *buf)\r\n{\r\nreturn sge->sge_fl_buf_size[buf->paddr & 0xF];\r\n}\r\nstatic inline uint32_t\r\ncsio_wr_qstat_pgsz(struct csio_hw *hw)\r\n{\r\nreturn (hw->wrm.sge.sge_control & EGRSTATUSPAGESIZE_F) ? 128 : 64;\r\n}\r\nstatic inline void\r\ncsio_wr_ring_fldb(struct csio_hw *hw, struct csio_q *flq)\r\n{\r\nif (flq->inc_idx >= 8) {\r\ncsio_wr_reg32(hw, DBPRIO_F | QID_V(flq->un.fl.flid) |\r\nPIDX_T5_V(flq->inc_idx / 8) | DBTYPE_F,\r\nMYPF_REG(SGE_PF_KDOORBELL_A));\r\nflq->inc_idx &= 7;\r\n}\r\n}\r\nstatic void\r\ncsio_wr_sge_intr_enable(struct csio_hw *hw, uint16_t iqid)\r\n{\r\ncsio_wr_reg32(hw, CIDXINC_V(0) |\r\nINGRESSQID_V(iqid) |\r\nTIMERREG_V(X_TIMERREG_RESTART_COUNTER),\r\nMYPF_REG(SGE_PF_GTS_A));\r\n}\r\nstatic int\r\ncsio_wr_fill_fl(struct csio_hw *hw, struct csio_q *flq)\r\n{\r\nstruct csio_wrm *wrm = csio_hw_to_wrm(hw);\r\nstruct csio_sge *sge = &wrm->sge;\r\n__be64 *d = (__be64 *)(flq->vstart);\r\nstruct csio_dma_buf *buf = &flq->un.fl.bufs[0];\r\nuint64_t paddr;\r\nint sreg = flq->un.fl.sreg;\r\nint n = flq->credits;\r\nwhile (n--) {\r\nbuf->len = sge->sge_fl_buf_size[sreg];\r\nbuf->vaddr = pci_alloc_consistent(hw->pdev, buf->len,\r\n&buf->paddr);\r\nif (!buf->vaddr) {\r\ncsio_err(hw, "Could only fill %d buffers!\n", n + 1);\r\nreturn -ENOMEM;\r\n}\r\npaddr = buf->paddr | (sreg & 0xF);\r\n*d++ = cpu_to_be64(paddr);\r\nbuf++;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void\r\ncsio_wr_update_fl(struct csio_hw *hw, struct csio_q *flq, uint16_t n)\r\n{\r\nflq->inc_idx += n;\r\nflq->pidx += n;\r\nif (unlikely(flq->pidx >= flq->credits))\r\nflq->pidx -= (uint16_t)flq->credits;\r\nCSIO_INC_STATS(flq, n_flq_refill);\r\n}\r\nint\r\ncsio_wr_alloc_q(struct csio_hw *hw, uint32_t qsize, uint32_t wrsize,\r\nuint16_t type, void *owner, uint32_t nflb, int sreg,\r\niq_handler_t iq_intx_handler)\r\n{\r\nstruct csio_wrm *wrm = csio_hw_to_wrm(hw);\r\nstruct csio_q *q, *flq;\r\nint free_idx = wrm->free_qidx;\r\nint ret_idx = free_idx;\r\nuint32_t qsz;\r\nint flq_idx;\r\nif (free_idx >= wrm->num_q) {\r\ncsio_err(hw, "No more free queues.\n");\r\nreturn -1;\r\n}\r\nswitch (type) {\r\ncase CSIO_EGRESS:\r\nqsz = ALIGN(qsize, CSIO_QCREDIT_SZ) + csio_wr_qstat_pgsz(hw);\r\nbreak;\r\ncase CSIO_INGRESS:\r\nswitch (wrsize) {\r\ncase 16:\r\ncase 32:\r\ncase 64:\r\ncase 128:\r\nbreak;\r\ndefault:\r\ncsio_err(hw, "Invalid Ingress queue WR size:%d\n",\r\nwrsize);\r\nreturn -1;\r\n}\r\nqsz = ALIGN(qsize/wrsize, 16) * wrsize;\r\nbreak;\r\ncase CSIO_FREELIST:\r\nqsz = ALIGN(qsize/wrsize, 8) * wrsize + csio_wr_qstat_pgsz(hw);\r\nbreak;\r\ndefault:\r\ncsio_err(hw, "Invalid queue type: 0x%x\n", type);\r\nreturn -1;\r\n}\r\nq = wrm->q_arr[free_idx];\r\nq->vstart = pci_zalloc_consistent(hw->pdev, qsz, &q->pstart);\r\nif (!q->vstart) {\r\ncsio_err(hw,\r\n"Failed to allocate DMA memory for "\r\n"queue at id: %d size: %d\n", free_idx, qsize);\r\nreturn -1;\r\n}\r\nq->type = type;\r\nq->owner = owner;\r\nq->pidx = q->cidx = q->inc_idx = 0;\r\nq->size = qsz;\r\nq->wr_sz = wrsize;\r\nwrm->free_qidx++;\r\nif (type == CSIO_INGRESS) {\r\nq->un.iq.genbit = 1;\r\nq->credits = (qsz - q->wr_sz) / q->wr_sz;\r\nq->vwrap = (void *)((uintptr_t)(q->vstart) + qsz\r\n- q->wr_sz);\r\nif (nflb > 0) {\r\nflq_idx = csio_wr_alloc_q(hw, nflb * sizeof(__be64),\r\nsizeof(__be64), CSIO_FREELIST,\r\nowner, 0, sreg, NULL);\r\nif (flq_idx == -1) {\r\ncsio_err(hw,\r\n"Failed to allocate FL queue"\r\n" for IQ idx:%d\n", free_idx);\r\nreturn -1;\r\n}\r\nq->un.iq.flq_idx = flq_idx;\r\nflq = wrm->q_arr[q->un.iq.flq_idx];\r\nflq->un.fl.bufs = kzalloc(flq->credits *\r\nsizeof(struct csio_dma_buf),\r\nGFP_KERNEL);\r\nif (!flq->un.fl.bufs) {\r\ncsio_err(hw,\r\n"Failed to allocate FL queue bufs"\r\n" for IQ idx:%d\n", free_idx);\r\nreturn -1;\r\n}\r\nflq->un.fl.packen = 0;\r\nflq->un.fl.offset = 0;\r\nflq->un.fl.sreg = sreg;\r\nif (csio_wr_fill_fl(hw, flq))\r\nreturn -1;\r\nflq->pidx = flq->inc_idx = flq->credits - 8;\r\n} else {\r\nq->un.iq.flq_idx = -1;\r\n}\r\nq->un.iq.iq_intx_handler = iq_intx_handler;\r\ncsio_q_iqid(hw, ret_idx) = CSIO_MAX_QID;\r\n} else if (type == CSIO_EGRESS) {\r\nq->credits = (qsz - csio_wr_qstat_pgsz(hw)) / CSIO_QCREDIT_SZ;\r\nq->vwrap = (void *)((uintptr_t)(q->vstart) + qsz\r\n- csio_wr_qstat_pgsz(hw));\r\ncsio_q_eqid(hw, ret_idx) = CSIO_MAX_QID;\r\n} else {\r\nq->credits = (qsz - csio_wr_qstat_pgsz(hw)) / sizeof(__be64);\r\nq->vwrap = (void *)((uintptr_t)(q->vstart) + qsz\r\n- csio_wr_qstat_pgsz(hw));\r\ncsio_q_flid(hw, ret_idx) = CSIO_MAX_QID;\r\n}\r\nreturn ret_idx;\r\n}\r\nstatic int\r\ncsio_wr_iq_create_rsp(struct csio_hw *hw, struct csio_mb *mbp, int iq_idx)\r\n{\r\nstruct csio_iq_params iqp;\r\nenum fw_retval retval;\r\nuint32_t iq_id;\r\nint flq_idx;\r\nmemset(&iqp, 0, sizeof(struct csio_iq_params));\r\ncsio_mb_iq_alloc_write_rsp(hw, mbp, &retval, &iqp);\r\nif (retval != FW_SUCCESS) {\r\ncsio_err(hw, "IQ cmd returned 0x%x!\n", retval);\r\nmempool_free(mbp, hw->mb_mempool);\r\nreturn -EINVAL;\r\n}\r\ncsio_q_iqid(hw, iq_idx) = iqp.iqid;\r\ncsio_q_physiqid(hw, iq_idx) = iqp.physiqid;\r\ncsio_q_pidx(hw, iq_idx) = csio_q_cidx(hw, iq_idx) = 0;\r\ncsio_q_inc_idx(hw, iq_idx) = 0;\r\niq_id = iqp.iqid - hw->wrm.fw_iq_start;\r\nif (iq_id >= CSIO_MAX_IQ) {\r\ncsio_err(hw,\r\n"Exceeding MAX_IQ(%d) supported!"\r\n" iqid:%d rel_iqid:%d FW iq_start:%d\n",\r\nCSIO_MAX_IQ, iq_id, iqp.iqid, hw->wrm.fw_iq_start);\r\nmempool_free(mbp, hw->mb_mempool);\r\nreturn -EINVAL;\r\n}\r\ncsio_q_set_intr_map(hw, iq_idx, iq_id);\r\ncsio_wr_sge_intr_enable(hw, iqp.physiqid);\r\nflq_idx = csio_q_iq_flq_idx(hw, iq_idx);\r\nif (flq_idx != -1) {\r\nstruct csio_q *flq = hw->wrm.q_arr[flq_idx];\r\ncsio_q_flid(hw, flq_idx) = iqp.fl0id;\r\ncsio_q_cidx(hw, flq_idx) = 0;\r\ncsio_q_pidx(hw, flq_idx) = csio_q_credits(hw, flq_idx) - 8;\r\ncsio_q_inc_idx(hw, flq_idx) = csio_q_credits(hw, flq_idx) - 8;\r\ncsio_wr_ring_fldb(hw, flq);\r\n}\r\nmempool_free(mbp, hw->mb_mempool);\r\nreturn 0;\r\n}\r\nint\r\ncsio_wr_iq_create(struct csio_hw *hw, void *priv, int iq_idx,\r\nuint32_t vec, uint8_t portid, bool async,\r\nvoid (*cbfn) (struct csio_hw *, struct csio_mb *))\r\n{\r\nstruct csio_mb *mbp;\r\nstruct csio_iq_params iqp;\r\nint flq_idx;\r\nmemset(&iqp, 0, sizeof(struct csio_iq_params));\r\ncsio_q_portid(hw, iq_idx) = portid;\r\nmbp = mempool_alloc(hw->mb_mempool, GFP_ATOMIC);\r\nif (!mbp) {\r\ncsio_err(hw, "IQ command out of memory!\n");\r\nreturn -ENOMEM;\r\n}\r\nswitch (hw->intr_mode) {\r\ncase CSIO_IM_INTX:\r\ncase CSIO_IM_MSI:\r\nif (hw->intr_iq_idx == iq_idx)\r\niqp.iqandst = X_INTERRUPTDESTINATION_PCIE;\r\nelse\r\niqp.iqandst = X_INTERRUPTDESTINATION_IQ;\r\niqp.iqandstindex =\r\ncsio_q_physiqid(hw, hw->intr_iq_idx);\r\nbreak;\r\ncase CSIO_IM_MSIX:\r\niqp.iqandst = X_INTERRUPTDESTINATION_PCIE;\r\niqp.iqandstindex = (uint16_t)vec;\r\nbreak;\r\ncase CSIO_IM_NONE:\r\nmempool_free(mbp, hw->mb_mempool);\r\nreturn -EINVAL;\r\n}\r\niqp.pfn = hw->pfn;\r\niqp.vfn = 0;\r\niqp.iq_start = 1;\r\niqp.viid = 0;\r\niqp.type = FW_IQ_TYPE_FL_INT_CAP;\r\niqp.iqasynch = async;\r\nif (csio_intr_coalesce_cnt)\r\niqp.iqanus = X_UPDATESCHEDULING_COUNTER_OPTTIMER;\r\nelse\r\niqp.iqanus = X_UPDATESCHEDULING_TIMER;\r\niqp.iqanud = X_UPDATEDELIVERY_INTERRUPT;\r\niqp.iqpciech = portid;\r\niqp.iqintcntthresh = (uint8_t)csio_sge_thresh_reg;\r\nswitch (csio_q_wr_sz(hw, iq_idx)) {\r\ncase 16:\r\niqp.iqesize = 0; break;\r\ncase 32:\r\niqp.iqesize = 1; break;\r\ncase 64:\r\niqp.iqesize = 2; break;\r\ncase 128:\r\niqp.iqesize = 3; break;\r\n}\r\niqp.iqsize = csio_q_size(hw, iq_idx) /\r\ncsio_q_wr_sz(hw, iq_idx);\r\niqp.iqaddr = csio_q_pstart(hw, iq_idx);\r\nflq_idx = csio_q_iq_flq_idx(hw, iq_idx);\r\nif (flq_idx != -1) {\r\nenum chip_type chip = CHELSIO_CHIP_VERSION(hw->chip_id);\r\nstruct csio_q *flq = hw->wrm.q_arr[flq_idx];\r\niqp.fl0paden = 1;\r\niqp.fl0packen = flq->un.fl.packen ? 1 : 0;\r\niqp.fl0fbmin = X_FETCHBURSTMIN_64B;\r\niqp.fl0fbmax = ((chip == CHELSIO_T5) ?\r\nX_FETCHBURSTMAX_512B : X_FETCHBURSTMAX_256B);\r\niqp.fl0size = csio_q_size(hw, flq_idx) / CSIO_QCREDIT_SZ;\r\niqp.fl0addr = csio_q_pstart(hw, flq_idx);\r\n}\r\ncsio_mb_iq_alloc_write(hw, mbp, priv, CSIO_MB_DEFAULT_TMO, &iqp, cbfn);\r\nif (csio_mb_issue(hw, mbp)) {\r\ncsio_err(hw, "Issue of IQ cmd failed!\n");\r\nmempool_free(mbp, hw->mb_mempool);\r\nreturn -EINVAL;\r\n}\r\nif (cbfn != NULL)\r\nreturn 0;\r\nreturn csio_wr_iq_create_rsp(hw, mbp, iq_idx);\r\n}\r\nstatic int\r\ncsio_wr_eq_cfg_rsp(struct csio_hw *hw, struct csio_mb *mbp, int eq_idx)\r\n{\r\nstruct csio_eq_params eqp;\r\nenum fw_retval retval;\r\nmemset(&eqp, 0, sizeof(struct csio_eq_params));\r\ncsio_mb_eq_ofld_alloc_write_rsp(hw, mbp, &retval, &eqp);\r\nif (retval != FW_SUCCESS) {\r\ncsio_err(hw, "EQ OFLD cmd returned 0x%x!\n", retval);\r\nmempool_free(mbp, hw->mb_mempool);\r\nreturn -EINVAL;\r\n}\r\ncsio_q_eqid(hw, eq_idx) = (uint16_t)eqp.eqid;\r\ncsio_q_physeqid(hw, eq_idx) = (uint16_t)eqp.physeqid;\r\ncsio_q_pidx(hw, eq_idx) = csio_q_cidx(hw, eq_idx) = 0;\r\ncsio_q_inc_idx(hw, eq_idx) = 0;\r\nmempool_free(mbp, hw->mb_mempool);\r\nreturn 0;\r\n}\r\nint\r\ncsio_wr_eq_create(struct csio_hw *hw, void *priv, int eq_idx,\r\nint iq_idx, uint8_t portid,\r\nvoid (*cbfn) (struct csio_hw *, struct csio_mb *))\r\n{\r\nstruct csio_mb *mbp;\r\nstruct csio_eq_params eqp;\r\nmemset(&eqp, 0, sizeof(struct csio_eq_params));\r\nmbp = mempool_alloc(hw->mb_mempool, GFP_ATOMIC);\r\nif (!mbp) {\r\ncsio_err(hw, "EQ command out of memory!\n");\r\nreturn -ENOMEM;\r\n}\r\neqp.pfn = hw->pfn;\r\neqp.vfn = 0;\r\neqp.eqstart = 1;\r\neqp.hostfcmode = X_HOSTFCMODE_STATUS_PAGE;\r\neqp.iqid = csio_q_iqid(hw, iq_idx);\r\neqp.fbmin = X_FETCHBURSTMIN_64B;\r\neqp.fbmax = X_FETCHBURSTMAX_512B;\r\neqp.cidxfthresh = 0;\r\neqp.pciechn = portid;\r\neqp.eqsize = csio_q_size(hw, eq_idx) / CSIO_QCREDIT_SZ;\r\neqp.eqaddr = csio_q_pstart(hw, eq_idx);\r\ncsio_mb_eq_ofld_alloc_write(hw, mbp, priv, CSIO_MB_DEFAULT_TMO,\r\n&eqp, cbfn);\r\nif (csio_mb_issue(hw, mbp)) {\r\ncsio_err(hw, "Issue of EQ OFLD cmd failed!\n");\r\nmempool_free(mbp, hw->mb_mempool);\r\nreturn -EINVAL;\r\n}\r\nif (cbfn != NULL)\r\nreturn 0;\r\nreturn csio_wr_eq_cfg_rsp(hw, mbp, eq_idx);\r\n}\r\nstatic int\r\ncsio_wr_iq_destroy_rsp(struct csio_hw *hw, struct csio_mb *mbp, int iq_idx)\r\n{\r\nenum fw_retval retval = csio_mb_fw_retval(mbp);\r\nint rv = 0;\r\nif (retval != FW_SUCCESS)\r\nrv = -EINVAL;\r\nmempool_free(mbp, hw->mb_mempool);\r\nreturn rv;\r\n}\r\nstatic int\r\ncsio_wr_iq_destroy(struct csio_hw *hw, void *priv, int iq_idx,\r\nvoid (*cbfn)(struct csio_hw *, struct csio_mb *))\r\n{\r\nint rv = 0;\r\nstruct csio_mb *mbp;\r\nstruct csio_iq_params iqp;\r\nint flq_idx;\r\nmemset(&iqp, 0, sizeof(struct csio_iq_params));\r\nmbp = mempool_alloc(hw->mb_mempool, GFP_ATOMIC);\r\nif (!mbp)\r\nreturn -ENOMEM;\r\niqp.pfn = hw->pfn;\r\niqp.vfn = 0;\r\niqp.iqid = csio_q_iqid(hw, iq_idx);\r\niqp.type = FW_IQ_TYPE_FL_INT_CAP;\r\nflq_idx = csio_q_iq_flq_idx(hw, iq_idx);\r\nif (flq_idx != -1)\r\niqp.fl0id = csio_q_flid(hw, flq_idx);\r\nelse\r\niqp.fl0id = 0xFFFF;\r\niqp.fl1id = 0xFFFF;\r\ncsio_mb_iq_free(hw, mbp, priv, CSIO_MB_DEFAULT_TMO, &iqp, cbfn);\r\nrv = csio_mb_issue(hw, mbp);\r\nif (rv != 0) {\r\nmempool_free(mbp, hw->mb_mempool);\r\nreturn rv;\r\n}\r\nif (cbfn != NULL)\r\nreturn 0;\r\nreturn csio_wr_iq_destroy_rsp(hw, mbp, iq_idx);\r\n}\r\nstatic int\r\ncsio_wr_eq_destroy_rsp(struct csio_hw *hw, struct csio_mb *mbp, int eq_idx)\r\n{\r\nenum fw_retval retval = csio_mb_fw_retval(mbp);\r\nint rv = 0;\r\nif (retval != FW_SUCCESS)\r\nrv = -EINVAL;\r\nmempool_free(mbp, hw->mb_mempool);\r\nreturn rv;\r\n}\r\nstatic int\r\ncsio_wr_eq_destroy(struct csio_hw *hw, void *priv, int eq_idx,\r\nvoid (*cbfn) (struct csio_hw *, struct csio_mb *))\r\n{\r\nint rv = 0;\r\nstruct csio_mb *mbp;\r\nstruct csio_eq_params eqp;\r\nmemset(&eqp, 0, sizeof(struct csio_eq_params));\r\nmbp = mempool_alloc(hw->mb_mempool, GFP_ATOMIC);\r\nif (!mbp)\r\nreturn -ENOMEM;\r\neqp.pfn = hw->pfn;\r\neqp.vfn = 0;\r\neqp.eqid = csio_q_eqid(hw, eq_idx);\r\ncsio_mb_eq_ofld_free(hw, mbp, priv, CSIO_MB_DEFAULT_TMO, &eqp, cbfn);\r\nrv = csio_mb_issue(hw, mbp);\r\nif (rv != 0) {\r\nmempool_free(mbp, hw->mb_mempool);\r\nreturn rv;\r\n}\r\nif (cbfn != NULL)\r\nreturn 0;\r\nreturn csio_wr_eq_destroy_rsp(hw, mbp, eq_idx);\r\n}\r\nstatic void\r\ncsio_wr_cleanup_eq_stpg(struct csio_hw *hw, int qidx)\r\n{\r\nstruct csio_q *q = csio_hw_to_wrm(hw)->q_arr[qidx];\r\nstruct csio_qstatus_page *stp = (struct csio_qstatus_page *)q->vwrap;\r\nmemset(stp, 0, sizeof(*stp));\r\n}\r\nstatic void\r\ncsio_wr_cleanup_iq_ftr(struct csio_hw *hw, int qidx)\r\n{\r\nstruct csio_wrm *wrm = csio_hw_to_wrm(hw);\r\nstruct csio_q *q = wrm->q_arr[qidx];\r\nvoid *wr;\r\nstruct csio_iqwr_footer *ftr;\r\nuint32_t i = 0;\r\nq->un.iq.genbit = 1;\r\nfor (i = 0; i < q->credits; i++) {\r\nwr = (void *)((uintptr_t)q->vstart +\r\n(i * q->wr_sz));\r\nftr = (struct csio_iqwr_footer *)((uintptr_t)wr +\r\n(q->wr_sz - sizeof(*ftr)));\r\nmemset(ftr, 0, sizeof(*ftr));\r\n}\r\n}\r\nint\r\ncsio_wr_destroy_queues(struct csio_hw *hw, bool cmd)\r\n{\r\nint i, flq_idx;\r\nstruct csio_q *q;\r\nstruct csio_wrm *wrm = csio_hw_to_wrm(hw);\r\nint rv;\r\nfor (i = 0; i < wrm->free_qidx; i++) {\r\nq = wrm->q_arr[i];\r\nswitch (q->type) {\r\ncase CSIO_EGRESS:\r\nif (csio_q_eqid(hw, i) != CSIO_MAX_QID) {\r\ncsio_wr_cleanup_eq_stpg(hw, i);\r\nif (!cmd) {\r\ncsio_q_eqid(hw, i) = CSIO_MAX_QID;\r\ncontinue;\r\n}\r\nrv = csio_wr_eq_destroy(hw, NULL, i, NULL);\r\nif ((rv == -EBUSY) || (rv == -ETIMEDOUT))\r\ncmd = false;\r\ncsio_q_eqid(hw, i) = CSIO_MAX_QID;\r\n}\r\ncase CSIO_INGRESS:\r\nif (csio_q_iqid(hw, i) != CSIO_MAX_QID) {\r\ncsio_wr_cleanup_iq_ftr(hw, i);\r\nif (!cmd) {\r\ncsio_q_iqid(hw, i) = CSIO_MAX_QID;\r\nflq_idx = csio_q_iq_flq_idx(hw, i);\r\nif (flq_idx != -1)\r\ncsio_q_flid(hw, flq_idx) =\r\nCSIO_MAX_QID;\r\ncontinue;\r\n}\r\nrv = csio_wr_iq_destroy(hw, NULL, i, NULL);\r\nif ((rv == -EBUSY) || (rv == -ETIMEDOUT))\r\ncmd = false;\r\ncsio_q_iqid(hw, i) = CSIO_MAX_QID;\r\nflq_idx = csio_q_iq_flq_idx(hw, i);\r\nif (flq_idx != -1)\r\ncsio_q_flid(hw, flq_idx) = CSIO_MAX_QID;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nhw->flags &= ~CSIO_HWF_Q_FW_ALLOCED;\r\nreturn 0;\r\n}\r\nint\r\ncsio_wr_get(struct csio_hw *hw, int qidx, uint32_t size,\r\nstruct csio_wr_pair *wrp)\r\n{\r\nstruct csio_wrm *wrm = csio_hw_to_wrm(hw);\r\nstruct csio_q *q = wrm->q_arr[qidx];\r\nvoid *cwr = (void *)((uintptr_t)(q->vstart) +\r\n(q->pidx * CSIO_QCREDIT_SZ));\r\nstruct csio_qstatus_page *stp = (struct csio_qstatus_page *)q->vwrap;\r\nuint16_t cidx = q->cidx = ntohs(stp->cidx);\r\nuint16_t pidx = q->pidx;\r\nuint32_t req_sz = ALIGN(size, CSIO_QCREDIT_SZ);\r\nint req_credits = req_sz / CSIO_QCREDIT_SZ;\r\nint credits;\r\nCSIO_DB_ASSERT(q->owner != NULL);\r\nCSIO_DB_ASSERT((qidx >= 0) && (qidx < wrm->free_qidx));\r\nCSIO_DB_ASSERT(cidx <= q->credits);\r\nif (pidx > cidx) {\r\ncredits = q->credits - (pidx - cidx) - 1;\r\n} else if (cidx > pidx) {\r\ncredits = cidx - pidx - 1;\r\n} else {\r\ncredits = q->credits;\r\nCSIO_INC_STATS(q, n_qempty);\r\n}\r\nif (!credits || (req_credits > credits)) {\r\nCSIO_INC_STATS(q, n_qfull);\r\nreturn -EBUSY;\r\n}\r\nif (unlikely(((uintptr_t)cwr + req_sz) > (uintptr_t)(q->vwrap))) {\r\nwrp->addr1 = cwr;\r\nwrp->size1 = (uint32_t)((uintptr_t)q->vwrap - (uintptr_t)cwr);\r\nwrp->addr2 = q->vstart;\r\nwrp->size2 = req_sz - wrp->size1;\r\nq->pidx = (uint16_t)(ALIGN(wrp->size2, CSIO_QCREDIT_SZ) /\r\nCSIO_QCREDIT_SZ);\r\nCSIO_INC_STATS(q, n_qwrap);\r\nCSIO_INC_STATS(q, n_eq_wr_split);\r\n} else {\r\nwrp->addr1 = cwr;\r\nwrp->size1 = req_sz;\r\nwrp->addr2 = NULL;\r\nwrp->size2 = 0;\r\nq->pidx += (uint16_t)req_credits;\r\nif (unlikely(q->pidx == q->credits)) {\r\nq->pidx = 0;\r\nCSIO_INC_STATS(q, n_qwrap);\r\n}\r\n}\r\nq->inc_idx = (uint16_t)req_credits;\r\nCSIO_INC_STATS(q, n_tot_reqs);\r\nreturn 0;\r\n}\r\nvoid\r\ncsio_wr_copy_to_wrp(void *data_buf, struct csio_wr_pair *wrp,\r\nuint32_t wr_off, uint32_t data_len)\r\n{\r\nuint32_t nbytes;\r\nnbytes = ((wrp->size1 - wr_off) >= data_len) ?\r\ndata_len : (wrp->size1 - wr_off);\r\nmemcpy((uint8_t *) wrp->addr1 + wr_off, data_buf, nbytes);\r\ndata_len -= nbytes;\r\nif (data_len) {\r\nCSIO_DB_ASSERT(data_len <= wrp->size2);\r\nCSIO_DB_ASSERT(wrp->addr2 != NULL);\r\nmemcpy(wrp->addr2, (uint8_t *) data_buf + nbytes, data_len);\r\n}\r\n}\r\nint\r\ncsio_wr_issue(struct csio_hw *hw, int qidx, bool prio)\r\n{\r\nstruct csio_wrm *wrm = csio_hw_to_wrm(hw);\r\nstruct csio_q *q = wrm->q_arr[qidx];\r\nCSIO_DB_ASSERT((qidx >= 0) && (qidx < wrm->free_qidx));\r\nwmb();\r\ncsio_wr_reg32(hw, DBPRIO_V(prio) | QID_V(q->un.eq.physeqid) |\r\nPIDX_T5_V(q->inc_idx) | DBTYPE_F,\r\nMYPF_REG(SGE_PF_KDOORBELL_A));\r\nq->inc_idx = 0;\r\nreturn 0;\r\n}\r\nstatic inline uint32_t\r\ncsio_wr_avail_qcredits(struct csio_q *q)\r\n{\r\nif (q->pidx > q->cidx)\r\nreturn q->pidx - q->cidx;\r\nelse if (q->cidx > q->pidx)\r\nreturn q->credits - (q->cidx - q->pidx);\r\nelse\r\nreturn 0;\r\n}\r\nstatic inline void\r\ncsio_wr_inval_flq_buf(struct csio_hw *hw, struct csio_q *flq)\r\n{\r\nflq->cidx++;\r\nif (flq->cidx == flq->credits) {\r\nflq->cidx = 0;\r\nCSIO_INC_STATS(flq, n_qwrap);\r\n}\r\n}\r\nstatic inline void\r\ncsio_wr_process_fl(struct csio_hw *hw, struct csio_q *q,\r\nvoid *wr, uint32_t len_to_qid,\r\nvoid (*iq_handler)(struct csio_hw *, void *,\r\nuint32_t, struct csio_fl_dma_buf *,\r\nvoid *),\r\nvoid *priv)\r\n{\r\nstruct csio_wrm *wrm = csio_hw_to_wrm(hw);\r\nstruct csio_sge *sge = &wrm->sge;\r\nstruct csio_fl_dma_buf flb;\r\nstruct csio_dma_buf *buf, *fbuf;\r\nuint32_t bufsz, len, lastlen = 0;\r\nint n;\r\nstruct csio_q *flq = hw->wrm.q_arr[q->un.iq.flq_idx];\r\nCSIO_DB_ASSERT(flq != NULL);\r\nlen = len_to_qid;\r\nif (len & IQWRF_NEWBUF) {\r\nif (flq->un.fl.offset > 0) {\r\ncsio_wr_inval_flq_buf(hw, flq);\r\nflq->un.fl.offset = 0;\r\n}\r\nlen = IQWRF_LEN_GET(len);\r\n}\r\nCSIO_DB_ASSERT(len != 0);\r\nflb.totlen = len;\r\nfor (n = 0, fbuf = flb.flbufs; ; n++, fbuf++) {\r\nbuf = &flq->un.fl.bufs[flq->cidx];\r\nbufsz = csio_wr_fl_bufsz(sge, buf);\r\nfbuf->paddr = buf->paddr;\r\nfbuf->vaddr = buf->vaddr;\r\nflb.offset = flq->un.fl.offset;\r\nlastlen = min(bufsz, len);\r\nfbuf->len = lastlen;\r\nlen -= lastlen;\r\nif (!len)\r\nbreak;\r\ncsio_wr_inval_flq_buf(hw, flq);\r\n}\r\nflb.defer_free = flq->un.fl.packen ? 0 : 1;\r\niq_handler(hw, wr, q->wr_sz - sizeof(struct csio_iqwr_footer),\r\n&flb, priv);\r\nif (flq->un.fl.packen)\r\nflq->un.fl.offset += ALIGN(lastlen, sge->csio_fl_align);\r\nelse\r\ncsio_wr_inval_flq_buf(hw, flq);\r\n}\r\nstatic inline bool\r\ncsio_is_new_iqwr(struct csio_q *q, struct csio_iqwr_footer *ftr)\r\n{\r\nreturn (q->un.iq.genbit == (ftr->u.type_gen >> IQWRF_GEN_SHIFT));\r\n}\r\nint\r\ncsio_wr_process_iq(struct csio_hw *hw, struct csio_q *q,\r\nvoid (*iq_handler)(struct csio_hw *, void *,\r\nuint32_t, struct csio_fl_dma_buf *,\r\nvoid *),\r\nvoid *priv)\r\n{\r\nstruct csio_wrm *wrm = csio_hw_to_wrm(hw);\r\nvoid *wr = (void *)((uintptr_t)q->vstart + (q->cidx * q->wr_sz));\r\nstruct csio_iqwr_footer *ftr;\r\nuint32_t wr_type, fw_qid, qid;\r\nstruct csio_q *q_completed;\r\nstruct csio_q *flq = csio_iq_has_fl(q) ?\r\nwrm->q_arr[q->un.iq.flq_idx] : NULL;\r\nint rv = 0;\r\nftr = (struct csio_iqwr_footer *)((uintptr_t)wr +\r\n(q->wr_sz - sizeof(*ftr)));\r\nwhile (csio_is_new_iqwr(q, ftr)) {\r\nCSIO_DB_ASSERT(((uintptr_t)wr + q->wr_sz) <=\r\n(uintptr_t)q->vwrap);\r\nrmb();\r\nwr_type = IQWRF_TYPE_GET(ftr->u.type_gen);\r\nswitch (wr_type) {\r\ncase X_RSPD_TYPE_CPL:\r\niq_handler(hw, wr, q->wr_sz - sizeof(*ftr), NULL, priv);\r\nbreak;\r\ncase X_RSPD_TYPE_FLBUF:\r\ncsio_wr_process_fl(hw, q, wr,\r\nntohl(ftr->pldbuflen_qid),\r\niq_handler, priv);\r\nbreak;\r\ncase X_RSPD_TYPE_INTR:\r\nfw_qid = ntohl(ftr->pldbuflen_qid);\r\nqid = fw_qid - wrm->fw_iq_start;\r\nq_completed = hw->wrm.intr_map[qid];\r\nif (unlikely(qid ==\r\ncsio_q_physiqid(hw, hw->intr_iq_idx))) {\r\n} else {\r\nCSIO_DB_ASSERT(q_completed);\r\nCSIO_DB_ASSERT(\r\nq_completed->un.iq.iq_intx_handler);\r\nq_completed->un.iq.iq_intx_handler(hw, NULL,\r\n0, NULL, (void *)q_completed);\r\n}\r\nbreak;\r\ndefault:\r\ncsio_warn(hw, "Unknown resp type 0x%x received\n",\r\nwr_type);\r\nCSIO_INC_STATS(q, n_rsp_unknown);\r\nbreak;\r\n}\r\nif (((uintptr_t)wr + q->wr_sz) == (uintptr_t)q->vwrap) {\r\nq->cidx = 0;\r\nwr = q->vstart;\r\nq->un.iq.genbit ^= 0x1;\r\nCSIO_INC_STATS(q, n_qwrap);\r\n} else {\r\nq->cidx++;\r\nwr = (void *)((uintptr_t)(q->vstart) +\r\n(q->cidx * q->wr_sz));\r\n}\r\nftr = (struct csio_iqwr_footer *)((uintptr_t)wr +\r\n(q->wr_sz - sizeof(*ftr)));\r\nq->inc_idx++;\r\n}\r\nif (unlikely(!q->inc_idx)) {\r\nCSIO_INC_STATS(q, n_stray_comp);\r\nrv = -EINVAL;\r\ngoto restart;\r\n}\r\nif (flq) {\r\nuint32_t avail = csio_wr_avail_qcredits(flq);\r\nif (avail <= 16) {\r\ncsio_wr_update_fl(hw, flq, (flq->credits - 8) - avail);\r\ncsio_wr_ring_fldb(hw, flq);\r\n}\r\n}\r\nrestart:\r\ncsio_wr_reg32(hw, CIDXINC_V(q->inc_idx) |\r\nINGRESSQID_V(q->un.iq.physiqid) |\r\nTIMERREG_V(csio_sge_timer_reg),\r\nMYPF_REG(SGE_PF_GTS_A));\r\nq->stats.n_tot_rsps += q->inc_idx;\r\nq->inc_idx = 0;\r\nreturn rv;\r\n}\r\nint\r\ncsio_wr_process_iq_idx(struct csio_hw *hw, int qidx,\r\nvoid (*iq_handler)(struct csio_hw *, void *,\r\nuint32_t, struct csio_fl_dma_buf *,\r\nvoid *),\r\nvoid *priv)\r\n{\r\nstruct csio_wrm *wrm = csio_hw_to_wrm(hw);\r\nstruct csio_q *iq = wrm->q_arr[qidx];\r\nreturn csio_wr_process_iq(hw, iq, iq_handler, priv);\r\n}\r\nstatic int\r\ncsio_closest_timer(struct csio_sge *s, int time)\r\n{\r\nint i, delta, match = 0, min_delta = INT_MAX;\r\nfor (i = 0; i < ARRAY_SIZE(s->timer_val); i++) {\r\ndelta = time - s->timer_val[i];\r\nif (delta < 0)\r\ndelta = -delta;\r\nif (delta < min_delta) {\r\nmin_delta = delta;\r\nmatch = i;\r\n}\r\n}\r\nreturn match;\r\n}\r\nstatic int\r\ncsio_closest_thresh(struct csio_sge *s, int cnt)\r\n{\r\nint i, delta, match = 0, min_delta = INT_MAX;\r\nfor (i = 0; i < ARRAY_SIZE(s->counter_val); i++) {\r\ndelta = cnt - s->counter_val[i];\r\nif (delta < 0)\r\ndelta = -delta;\r\nif (delta < min_delta) {\r\nmin_delta = delta;\r\nmatch = i;\r\n}\r\n}\r\nreturn match;\r\n}\r\nstatic void\r\ncsio_wr_fixup_host_params(struct csio_hw *hw)\r\n{\r\nstruct csio_wrm *wrm = csio_hw_to_wrm(hw);\r\nstruct csio_sge *sge = &wrm->sge;\r\nuint32_t clsz = L1_CACHE_BYTES;\r\nuint32_t s_hps = PAGE_SHIFT - 10;\r\nuint32_t ingpad = 0;\r\nuint32_t stat_len = clsz > 64 ? 128 : 64;\r\ncsio_wr_reg32(hw, HOSTPAGESIZEPF0_V(s_hps) | HOSTPAGESIZEPF1_V(s_hps) |\r\nHOSTPAGESIZEPF2_V(s_hps) | HOSTPAGESIZEPF3_V(s_hps) |\r\nHOSTPAGESIZEPF4_V(s_hps) | HOSTPAGESIZEPF5_V(s_hps) |\r\nHOSTPAGESIZEPF6_V(s_hps) | HOSTPAGESIZEPF7_V(s_hps),\r\nSGE_HOST_PAGE_SIZE_A);\r\nsge->csio_fl_align = clsz < 32 ? 32 : clsz;\r\ningpad = ilog2(sge->csio_fl_align) - 5;\r\ncsio_set_reg_field(hw, SGE_CONTROL_A,\r\nINGPADBOUNDARY_V(INGPADBOUNDARY_M) |\r\nEGRSTATUSPAGESIZE_F,\r\nINGPADBOUNDARY_V(ingpad) |\r\nEGRSTATUSPAGESIZE_V(stat_len != 64));\r\ncsio_wr_reg32(hw, PAGE_SIZE, SGE_FL_BUFFER_SIZE0_A);\r\nif (hw->flags & CSIO_HWF_USING_SOFT_PARAMS) {\r\ncsio_wr_reg32(hw,\r\n(csio_rd_reg32(hw, SGE_FL_BUFFER_SIZE2_A) +\r\nsge->csio_fl_align - 1) & ~(sge->csio_fl_align - 1),\r\nSGE_FL_BUFFER_SIZE2_A);\r\ncsio_wr_reg32(hw,\r\n(csio_rd_reg32(hw, SGE_FL_BUFFER_SIZE3_A) +\r\nsge->csio_fl_align - 1) & ~(sge->csio_fl_align - 1),\r\nSGE_FL_BUFFER_SIZE3_A);\r\n}\r\ncsio_wr_reg32(hw, HPZ0_V(PAGE_SHIFT - 12), ULP_RX_TDDP_PSZ_A);\r\ncsio_set_reg_field(hw, SGE_CONTROL_A,\r\nPKTSHIFT_V(PKTSHIFT_M),\r\nPKTSHIFT_V(CSIO_SGE_RX_DMA_OFFSET));\r\ncsio_hw_tp_wr_bits_indirect(hw, TP_INGRESS_CONFIG_A,\r\nCSUM_HAS_PSEUDO_HDR_F, 0);\r\n}\r\nstatic void\r\ncsio_init_intr_coalesce_parms(struct csio_hw *hw)\r\n{\r\nstruct csio_wrm *wrm = csio_hw_to_wrm(hw);\r\nstruct csio_sge *sge = &wrm->sge;\r\ncsio_sge_thresh_reg = csio_closest_thresh(sge, csio_intr_coalesce_cnt);\r\nif (csio_intr_coalesce_cnt) {\r\ncsio_sge_thresh_reg = 0;\r\ncsio_sge_timer_reg = X_TIMERREG_RESTART_COUNTER;\r\nreturn;\r\n}\r\ncsio_sge_timer_reg = csio_closest_timer(sge, csio_intr_coalesce_time);\r\n}\r\nstatic void\r\ncsio_wr_get_sge(struct csio_hw *hw)\r\n{\r\nstruct csio_wrm *wrm = csio_hw_to_wrm(hw);\r\nstruct csio_sge *sge = &wrm->sge;\r\nuint32_t ingpad;\r\nint i;\r\nu32 timer_value_0_and_1, timer_value_2_and_3, timer_value_4_and_5;\r\nu32 ingress_rx_threshold;\r\nsge->sge_control = csio_rd_reg32(hw, SGE_CONTROL_A);\r\ningpad = INGPADBOUNDARY_G(sge->sge_control);\r\nswitch (ingpad) {\r\ncase X_INGPCIEBOUNDARY_32B:\r\nsge->csio_fl_align = 32; break;\r\ncase X_INGPCIEBOUNDARY_64B:\r\nsge->csio_fl_align = 64; break;\r\ncase X_INGPCIEBOUNDARY_128B:\r\nsge->csio_fl_align = 128; break;\r\ncase X_INGPCIEBOUNDARY_256B:\r\nsge->csio_fl_align = 256; break;\r\ncase X_INGPCIEBOUNDARY_512B:\r\nsge->csio_fl_align = 512; break;\r\ncase X_INGPCIEBOUNDARY_1024B:\r\nsge->csio_fl_align = 1024; break;\r\ncase X_INGPCIEBOUNDARY_2048B:\r\nsge->csio_fl_align = 2048; break;\r\ncase X_INGPCIEBOUNDARY_4096B:\r\nsge->csio_fl_align = 4096; break;\r\n}\r\nfor (i = 0; i < CSIO_SGE_FL_SIZE_REGS; i++)\r\ncsio_get_flbuf_size(hw, sge, i);\r\ntimer_value_0_and_1 = csio_rd_reg32(hw, SGE_TIMER_VALUE_0_AND_1_A);\r\ntimer_value_2_and_3 = csio_rd_reg32(hw, SGE_TIMER_VALUE_2_AND_3_A);\r\ntimer_value_4_and_5 = csio_rd_reg32(hw, SGE_TIMER_VALUE_4_AND_5_A);\r\nsge->timer_val[0] = (uint16_t)csio_core_ticks_to_us(hw,\r\nTIMERVALUE0_G(timer_value_0_and_1));\r\nsge->timer_val[1] = (uint16_t)csio_core_ticks_to_us(hw,\r\nTIMERVALUE1_G(timer_value_0_and_1));\r\nsge->timer_val[2] = (uint16_t)csio_core_ticks_to_us(hw,\r\nTIMERVALUE2_G(timer_value_2_and_3));\r\nsge->timer_val[3] = (uint16_t)csio_core_ticks_to_us(hw,\r\nTIMERVALUE3_G(timer_value_2_and_3));\r\nsge->timer_val[4] = (uint16_t)csio_core_ticks_to_us(hw,\r\nTIMERVALUE4_G(timer_value_4_and_5));\r\nsge->timer_val[5] = (uint16_t)csio_core_ticks_to_us(hw,\r\nTIMERVALUE5_G(timer_value_4_and_5));\r\ningress_rx_threshold = csio_rd_reg32(hw, SGE_INGRESS_RX_THRESHOLD_A);\r\nsge->counter_val[0] = THRESHOLD_0_G(ingress_rx_threshold);\r\nsge->counter_val[1] = THRESHOLD_1_G(ingress_rx_threshold);\r\nsge->counter_val[2] = THRESHOLD_2_G(ingress_rx_threshold);\r\nsge->counter_val[3] = THRESHOLD_3_G(ingress_rx_threshold);\r\ncsio_init_intr_coalesce_parms(hw);\r\n}\r\nstatic void\r\ncsio_wr_set_sge(struct csio_hw *hw)\r\n{\r\nstruct csio_wrm *wrm = csio_hw_to_wrm(hw);\r\nstruct csio_sge *sge = &wrm->sge;\r\nint i;\r\ncsio_set_reg_field(hw, SGE_CONTROL_A, RXPKTCPLMODE_F, RXPKTCPLMODE_F);\r\nsge->sge_control = csio_rd_reg32(hw, SGE_CONTROL_A);\r\ncsio_set_reg_field(hw, SGE_DBFIFO_STATUS_A,\r\nLP_INT_THRESH_T5_V(LP_INT_THRESH_T5_M),\r\nLP_INT_THRESH_T5_V(CSIO_SGE_DBFIFO_INT_THRESH));\r\ncsio_set_reg_field(hw, SGE_DBFIFO_STATUS2_A,\r\nHP_INT_THRESH_T5_V(LP_INT_THRESH_T5_M),\r\nHP_INT_THRESH_T5_V(CSIO_SGE_DBFIFO_INT_THRESH));\r\ncsio_set_reg_field(hw, SGE_DOORBELL_CONTROL_A, ENABLE_DROP_F,\r\nENABLE_DROP_F);\r\nCSIO_SET_FLBUF_SIZE(hw, 1, CSIO_SGE_FLBUF_SIZE1);\r\ncsio_wr_reg32(hw, (CSIO_SGE_FLBUF_SIZE2 + sge->csio_fl_align - 1)\r\n& ~(sge->csio_fl_align - 1), SGE_FL_BUFFER_SIZE2_A);\r\ncsio_wr_reg32(hw, (CSIO_SGE_FLBUF_SIZE3 + sge->csio_fl_align - 1)\r\n& ~(sge->csio_fl_align - 1), SGE_FL_BUFFER_SIZE3_A);\r\nCSIO_SET_FLBUF_SIZE(hw, 4, CSIO_SGE_FLBUF_SIZE4);\r\nCSIO_SET_FLBUF_SIZE(hw, 5, CSIO_SGE_FLBUF_SIZE5);\r\nCSIO_SET_FLBUF_SIZE(hw, 6, CSIO_SGE_FLBUF_SIZE6);\r\nCSIO_SET_FLBUF_SIZE(hw, 7, CSIO_SGE_FLBUF_SIZE7);\r\nCSIO_SET_FLBUF_SIZE(hw, 8, CSIO_SGE_FLBUF_SIZE8);\r\nfor (i = 0; i < CSIO_SGE_FL_SIZE_REGS; i++)\r\ncsio_get_flbuf_size(hw, sge, i);\r\nsge->timer_val[0] = CSIO_SGE_TIMER_VAL_0;\r\nsge->timer_val[1] = CSIO_SGE_TIMER_VAL_1;\r\nsge->timer_val[2] = CSIO_SGE_TIMER_VAL_2;\r\nsge->timer_val[3] = CSIO_SGE_TIMER_VAL_3;\r\nsge->timer_val[4] = CSIO_SGE_TIMER_VAL_4;\r\nsge->timer_val[5] = CSIO_SGE_TIMER_VAL_5;\r\nsge->counter_val[0] = CSIO_SGE_INT_CNT_VAL_0;\r\nsge->counter_val[1] = CSIO_SGE_INT_CNT_VAL_1;\r\nsge->counter_val[2] = CSIO_SGE_INT_CNT_VAL_2;\r\nsge->counter_val[3] = CSIO_SGE_INT_CNT_VAL_3;\r\ncsio_wr_reg32(hw, THRESHOLD_0_V(sge->counter_val[0]) |\r\nTHRESHOLD_1_V(sge->counter_val[1]) |\r\nTHRESHOLD_2_V(sge->counter_val[2]) |\r\nTHRESHOLD_3_V(sge->counter_val[3]),\r\nSGE_INGRESS_RX_THRESHOLD_A);\r\ncsio_wr_reg32(hw,\r\nTIMERVALUE0_V(csio_us_to_core_ticks(hw, sge->timer_val[0])) |\r\nTIMERVALUE1_V(csio_us_to_core_ticks(hw, sge->timer_val[1])),\r\nSGE_TIMER_VALUE_0_AND_1_A);\r\ncsio_wr_reg32(hw,\r\nTIMERVALUE2_V(csio_us_to_core_ticks(hw, sge->timer_val[2])) |\r\nTIMERVALUE3_V(csio_us_to_core_ticks(hw, sge->timer_val[3])),\r\nSGE_TIMER_VALUE_2_AND_3_A);\r\ncsio_wr_reg32(hw,\r\nTIMERVALUE4_V(csio_us_to_core_ticks(hw, sge->timer_val[4])) |\r\nTIMERVALUE5_V(csio_us_to_core_ticks(hw, sge->timer_val[5])),\r\nSGE_TIMER_VALUE_4_AND_5_A);\r\ncsio_init_intr_coalesce_parms(hw);\r\n}\r\nvoid\r\ncsio_wr_sge_init(struct csio_hw *hw)\r\n{\r\nif (csio_is_hw_master(hw)) {\r\nif (hw->fw_state != CSIO_DEV_STATE_INIT)\r\ncsio_wr_fixup_host_params(hw);\r\nif (hw->flags & CSIO_HWF_USING_SOFT_PARAMS)\r\ncsio_wr_get_sge(hw);\r\nelse\r\ncsio_wr_set_sge(hw);\r\n} else\r\ncsio_wr_get_sge(hw);\r\n}\r\nint\r\ncsio_wrm_init(struct csio_wrm *wrm, struct csio_hw *hw)\r\n{\r\nint i;\r\nif (!wrm->num_q) {\r\ncsio_err(hw, "Num queues is not set\n");\r\nreturn -EINVAL;\r\n}\r\nwrm->q_arr = kzalloc(sizeof(struct csio_q *) * wrm->num_q, GFP_KERNEL);\r\nif (!wrm->q_arr)\r\ngoto err;\r\nfor (i = 0; i < wrm->num_q; i++) {\r\nwrm->q_arr[i] = kzalloc(sizeof(struct csio_q), GFP_KERNEL);\r\nif (!wrm->q_arr[i]) {\r\nwhile (--i >= 0)\r\nkfree(wrm->q_arr[i]);\r\ngoto err_free_arr;\r\n}\r\n}\r\nwrm->free_qidx = 0;\r\nreturn 0;\r\nerr_free_arr:\r\nkfree(wrm->q_arr);\r\nerr:\r\nreturn -ENOMEM;\r\n}\r\nvoid\r\ncsio_wrm_exit(struct csio_wrm *wrm, struct csio_hw *hw)\r\n{\r\nint i;\r\nuint32_t j;\r\nstruct csio_q *q;\r\nstruct csio_dma_buf *buf;\r\nfor (i = 0; i < wrm->num_q; i++) {\r\nq = wrm->q_arr[i];\r\nif (wrm->free_qidx && (i < wrm->free_qidx)) {\r\nif (q->type == CSIO_FREELIST) {\r\nif (!q->un.fl.bufs)\r\ncontinue;\r\nfor (j = 0; j < q->credits; j++) {\r\nbuf = &q->un.fl.bufs[j];\r\nif (!buf->vaddr)\r\ncontinue;\r\npci_free_consistent(hw->pdev, buf->len,\r\nbuf->vaddr,\r\nbuf->paddr);\r\n}\r\nkfree(q->un.fl.bufs);\r\n}\r\npci_free_consistent(hw->pdev, q->size,\r\nq->vstart, q->pstart);\r\n}\r\nkfree(q);\r\n}\r\nhw->flags &= ~CSIO_HWF_Q_MEM_ALLOCED;\r\nkfree(wrm->q_arr);\r\n}
