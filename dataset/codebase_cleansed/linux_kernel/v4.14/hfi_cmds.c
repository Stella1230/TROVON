void pkt_sys_init(struct hfi_sys_init_pkt *pkt, u32 arch_type)\r\n{\r\npkt->hdr.size = sizeof(*pkt);\r\npkt->hdr.pkt_type = HFI_CMD_SYS_INIT;\r\npkt->arch_type = arch_type;\r\n}\r\nvoid pkt_sys_pc_prep(struct hfi_sys_pc_prep_pkt *pkt)\r\n{\r\npkt->hdr.size = sizeof(*pkt);\r\npkt->hdr.pkt_type = HFI_CMD_SYS_PC_PREP;\r\n}\r\nvoid pkt_sys_idle_indicator(struct hfi_sys_set_property_pkt *pkt, u32 enable)\r\n{\r\nstruct hfi_enable *hfi = (struct hfi_enable *)&pkt->data[1];\r\npkt->hdr.size = sizeof(*pkt) + sizeof(*hfi) + sizeof(u32);\r\npkt->hdr.pkt_type = HFI_CMD_SYS_SET_PROPERTY;\r\npkt->num_properties = 1;\r\npkt->data[0] = HFI_PROPERTY_SYS_IDLE_INDICATOR;\r\nhfi->enable = enable;\r\n}\r\nvoid pkt_sys_debug_config(struct hfi_sys_set_property_pkt *pkt, u32 mode,\r\nu32 config)\r\n{\r\nstruct hfi_debug_config *hfi;\r\npkt->hdr.size = sizeof(*pkt) + sizeof(*hfi) + sizeof(u32);\r\npkt->hdr.pkt_type = HFI_CMD_SYS_SET_PROPERTY;\r\npkt->num_properties = 1;\r\npkt->data[0] = HFI_PROPERTY_SYS_DEBUG_CONFIG;\r\nhfi = (struct hfi_debug_config *)&pkt->data[1];\r\nhfi->config = config;\r\nhfi->mode = mode;\r\n}\r\nvoid pkt_sys_coverage_config(struct hfi_sys_set_property_pkt *pkt, u32 mode)\r\n{\r\npkt->hdr.size = sizeof(*pkt) + sizeof(u32);\r\npkt->hdr.pkt_type = HFI_CMD_SYS_SET_PROPERTY;\r\npkt->num_properties = 1;\r\npkt->data[0] = HFI_PROPERTY_SYS_CONFIG_COVERAGE;\r\npkt->data[1] = mode;\r\n}\r\nint pkt_sys_set_resource(struct hfi_sys_set_resource_pkt *pkt, u32 id, u32 size,\r\nu32 addr, void *cookie)\r\n{\r\npkt->hdr.size = sizeof(*pkt);\r\npkt->hdr.pkt_type = HFI_CMD_SYS_SET_RESOURCE;\r\npkt->resource_handle = hash32_ptr(cookie);\r\nswitch (id) {\r\ncase VIDC_RESOURCE_OCMEM:\r\ncase VIDC_RESOURCE_VMEM: {\r\nstruct hfi_resource_ocmem *res =\r\n(struct hfi_resource_ocmem *)&pkt->resource_data[0];\r\nres->size = size;\r\nres->mem = addr;\r\npkt->resource_type = HFI_RESOURCE_OCMEM;\r\npkt->hdr.size += sizeof(*res) - sizeof(u32);\r\nbreak;\r\n}\r\ncase VIDC_RESOURCE_NONE:\r\ndefault:\r\nreturn -ENOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nint pkt_sys_unset_resource(struct hfi_sys_release_resource_pkt *pkt, u32 id,\r\nu32 size, void *cookie)\r\n{\r\npkt->hdr.size = sizeof(*pkt);\r\npkt->hdr.pkt_type = HFI_CMD_SYS_RELEASE_RESOURCE;\r\npkt->resource_handle = hash32_ptr(cookie);\r\nswitch (id) {\r\ncase VIDC_RESOURCE_OCMEM:\r\ncase VIDC_RESOURCE_VMEM:\r\npkt->resource_type = HFI_RESOURCE_OCMEM;\r\nbreak;\r\ncase VIDC_RESOURCE_NONE:\r\nbreak;\r\ndefault:\r\nreturn -ENOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nvoid pkt_sys_ping(struct hfi_sys_ping_pkt *pkt, u32 cookie)\r\n{\r\npkt->hdr.size = sizeof(*pkt);\r\npkt->hdr.pkt_type = HFI_CMD_SYS_PING;\r\npkt->client_data = cookie;\r\n}\r\nvoid pkt_sys_power_control(struct hfi_sys_set_property_pkt *pkt, u32 enable)\r\n{\r\nstruct hfi_enable *hfi = (struct hfi_enable *)&pkt->data[1];\r\npkt->hdr.size = sizeof(*pkt) + sizeof(*hfi) + sizeof(u32);\r\npkt->hdr.pkt_type = HFI_CMD_SYS_SET_PROPERTY;\r\npkt->num_properties = 1;\r\npkt->data[0] = HFI_PROPERTY_SYS_CODEC_POWER_PLANE_CTRL;\r\nhfi->enable = enable;\r\n}\r\nint pkt_sys_ssr_cmd(struct hfi_sys_test_ssr_pkt *pkt, u32 trigger_type)\r\n{\r\nswitch (trigger_type) {\r\ncase HFI_TEST_SSR_SW_ERR_FATAL:\r\ncase HFI_TEST_SSR_SW_DIV_BY_ZERO:\r\ncase HFI_TEST_SSR_HW_WDOG_IRQ:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\npkt->hdr.size = sizeof(*pkt);\r\npkt->hdr.pkt_type = HFI_CMD_SYS_TEST_SSR;\r\npkt->trigger_type = trigger_type;\r\nreturn 0;\r\n}\r\nvoid pkt_sys_image_version(struct hfi_sys_get_property_pkt *pkt)\r\n{\r\npkt->hdr.size = sizeof(*pkt);\r\npkt->hdr.pkt_type = HFI_CMD_SYS_GET_PROPERTY;\r\npkt->num_properties = 1;\r\npkt->data[0] = HFI_PROPERTY_SYS_IMAGE_VERSION;\r\n}\r\nint pkt_session_init(struct hfi_session_init_pkt *pkt, void *cookie,\r\nu32 session_type, u32 codec)\r\n{\r\nif (!pkt || !cookie || !codec)\r\nreturn -EINVAL;\r\npkt->shdr.hdr.size = sizeof(*pkt);\r\npkt->shdr.hdr.pkt_type = HFI_CMD_SYS_SESSION_INIT;\r\npkt->shdr.session_id = hash32_ptr(cookie);\r\npkt->session_domain = session_type;\r\npkt->session_codec = codec;\r\nreturn 0;\r\n}\r\nvoid pkt_session_cmd(struct hfi_session_pkt *pkt, u32 pkt_type, void *cookie)\r\n{\r\npkt->shdr.hdr.size = sizeof(*pkt);\r\npkt->shdr.hdr.pkt_type = pkt_type;\r\npkt->shdr.session_id = hash32_ptr(cookie);\r\n}\r\nint pkt_session_set_buffers(struct hfi_session_set_buffers_pkt *pkt,\r\nvoid *cookie, struct hfi_buffer_desc *bd)\r\n{\r\nunsigned int i;\r\nif (!cookie || !pkt || !bd)\r\nreturn -EINVAL;\r\npkt->shdr.hdr.pkt_type = HFI_CMD_SESSION_SET_BUFFERS;\r\npkt->shdr.session_id = hash32_ptr(cookie);\r\npkt->buffer_size = bd->buffer_size;\r\npkt->min_buffer_size = bd->buffer_size;\r\npkt->num_buffers = bd->num_buffers;\r\nif (bd->buffer_type == HFI_BUFFER_OUTPUT ||\r\nbd->buffer_type == HFI_BUFFER_OUTPUT2) {\r\nstruct hfi_buffer_info *bi;\r\npkt->extradata_size = bd->extradata_size;\r\npkt->shdr.hdr.size = sizeof(*pkt) - sizeof(u32) +\r\n(bd->num_buffers * sizeof(*bi));\r\nbi = (struct hfi_buffer_info *)pkt->buffer_info;\r\nfor (i = 0; i < pkt->num_buffers; i++) {\r\nbi->buffer_addr = bd->device_addr;\r\nbi->extradata_addr = bd->extradata_addr;\r\n}\r\n} else {\r\npkt->extradata_size = 0;\r\npkt->shdr.hdr.size = sizeof(*pkt) +\r\n((bd->num_buffers - 1) * sizeof(u32));\r\nfor (i = 0; i < pkt->num_buffers; i++)\r\npkt->buffer_info[i] = bd->device_addr;\r\n}\r\npkt->buffer_type = bd->buffer_type;\r\nreturn 0;\r\n}\r\nint pkt_session_unset_buffers(struct hfi_session_release_buffer_pkt *pkt,\r\nvoid *cookie, struct hfi_buffer_desc *bd)\r\n{\r\nunsigned int i;\r\nif (!cookie || !pkt || !bd)\r\nreturn -EINVAL;\r\npkt->shdr.hdr.pkt_type = HFI_CMD_SESSION_RELEASE_BUFFERS;\r\npkt->shdr.session_id = hash32_ptr(cookie);\r\npkt->buffer_size = bd->buffer_size;\r\npkt->num_buffers = bd->num_buffers;\r\nif (bd->buffer_type == HFI_BUFFER_OUTPUT ||\r\nbd->buffer_type == HFI_BUFFER_OUTPUT2) {\r\nstruct hfi_buffer_info *bi;\r\nbi = (struct hfi_buffer_info *)pkt->buffer_info;\r\nfor (i = 0; i < pkt->num_buffers; i++) {\r\nbi->buffer_addr = bd->device_addr;\r\nbi->extradata_addr = bd->extradata_addr;\r\n}\r\npkt->shdr.hdr.size =\r\nsizeof(struct hfi_session_set_buffers_pkt) -\r\nsizeof(u32) + (bd->num_buffers * sizeof(*bi));\r\n} else {\r\nfor (i = 0; i < pkt->num_buffers; i++)\r\npkt->buffer_info[i] = bd->device_addr;\r\npkt->extradata_size = 0;\r\npkt->shdr.hdr.size =\r\nsizeof(struct hfi_session_set_buffers_pkt) +\r\n((bd->num_buffers - 1) * sizeof(u32));\r\n}\r\npkt->response_req = bd->response_required;\r\npkt->buffer_type = bd->buffer_type;\r\nreturn 0;\r\n}\r\nint pkt_session_etb_decoder(struct hfi_session_empty_buffer_compressed_pkt *pkt,\r\nvoid *cookie, struct hfi_frame_data *in_frame)\r\n{\r\nif (!cookie || !in_frame->device_addr)\r\nreturn -EINVAL;\r\npkt->shdr.hdr.size = sizeof(*pkt);\r\npkt->shdr.hdr.pkt_type = HFI_CMD_SESSION_EMPTY_BUFFER;\r\npkt->shdr.session_id = hash32_ptr(cookie);\r\npkt->time_stamp_hi = upper_32_bits(in_frame->timestamp);\r\npkt->time_stamp_lo = lower_32_bits(in_frame->timestamp);\r\npkt->flags = in_frame->flags;\r\npkt->mark_target = in_frame->mark_target;\r\npkt->mark_data = in_frame->mark_data;\r\npkt->offset = in_frame->offset;\r\npkt->alloc_len = in_frame->alloc_len;\r\npkt->filled_len = in_frame->filled_len;\r\npkt->input_tag = in_frame->clnt_data;\r\npkt->packet_buffer = in_frame->device_addr;\r\nreturn 0;\r\n}\r\nint pkt_session_etb_encoder(\r\nstruct hfi_session_empty_buffer_uncompressed_plane0_pkt *pkt,\r\nvoid *cookie, struct hfi_frame_data *in_frame)\r\n{\r\nif (!cookie || !in_frame->device_addr)\r\nreturn -EINVAL;\r\npkt->shdr.hdr.size = sizeof(*pkt);\r\npkt->shdr.hdr.pkt_type = HFI_CMD_SESSION_EMPTY_BUFFER;\r\npkt->shdr.session_id = hash32_ptr(cookie);\r\npkt->view_id = 0;\r\npkt->time_stamp_hi = upper_32_bits(in_frame->timestamp);\r\npkt->time_stamp_lo = lower_32_bits(in_frame->timestamp);\r\npkt->flags = in_frame->flags;\r\npkt->mark_target = in_frame->mark_target;\r\npkt->mark_data = in_frame->mark_data;\r\npkt->offset = in_frame->offset;\r\npkt->alloc_len = in_frame->alloc_len;\r\npkt->filled_len = in_frame->filled_len;\r\npkt->input_tag = in_frame->clnt_data;\r\npkt->packet_buffer = in_frame->device_addr;\r\npkt->extradata_buffer = in_frame->extradata_addr;\r\nreturn 0;\r\n}\r\nint pkt_session_ftb(struct hfi_session_fill_buffer_pkt *pkt, void *cookie,\r\nstruct hfi_frame_data *out_frame)\r\n{\r\nif (!cookie || !out_frame || !out_frame->device_addr)\r\nreturn -EINVAL;\r\npkt->shdr.hdr.size = sizeof(*pkt);\r\npkt->shdr.hdr.pkt_type = HFI_CMD_SESSION_FILL_BUFFER;\r\npkt->shdr.session_id = hash32_ptr(cookie);\r\nif (out_frame->buffer_type == HFI_BUFFER_OUTPUT)\r\npkt->stream_id = 0;\r\nelse if (out_frame->buffer_type == HFI_BUFFER_OUTPUT2)\r\npkt->stream_id = 1;\r\npkt->output_tag = out_frame->clnt_data;\r\npkt->packet_buffer = out_frame->device_addr;\r\npkt->extradata_buffer = out_frame->extradata_addr;\r\npkt->alloc_len = out_frame->alloc_len;\r\npkt->filled_len = out_frame->filled_len;\r\npkt->offset = out_frame->offset;\r\npkt->data[0] = out_frame->extradata_size;\r\nreturn 0;\r\n}\r\nint pkt_session_parse_seq_header(\r\nstruct hfi_session_parse_sequence_header_pkt *pkt,\r\nvoid *cookie, u32 seq_hdr, u32 seq_hdr_len)\r\n{\r\nif (!cookie || !seq_hdr || !seq_hdr_len)\r\nreturn -EINVAL;\r\npkt->shdr.hdr.size = sizeof(*pkt);\r\npkt->shdr.hdr.pkt_type = HFI_CMD_SESSION_PARSE_SEQUENCE_HEADER;\r\npkt->shdr.session_id = hash32_ptr(cookie);\r\npkt->header_len = seq_hdr_len;\r\npkt->packet_buffer = seq_hdr;\r\nreturn 0;\r\n}\r\nint pkt_session_get_seq_hdr(struct hfi_session_get_sequence_header_pkt *pkt,\r\nvoid *cookie, u32 seq_hdr, u32 seq_hdr_len)\r\n{\r\nif (!cookie || !seq_hdr || !seq_hdr_len)\r\nreturn -EINVAL;\r\npkt->shdr.hdr.size = sizeof(*pkt);\r\npkt->shdr.hdr.pkt_type = HFI_CMD_SESSION_GET_SEQUENCE_HEADER;\r\npkt->shdr.session_id = hash32_ptr(cookie);\r\npkt->buffer_len = seq_hdr_len;\r\npkt->packet_buffer = seq_hdr;\r\nreturn 0;\r\n}\r\nint pkt_session_flush(struct hfi_session_flush_pkt *pkt, void *cookie, u32 type)\r\n{\r\nswitch (type) {\r\ncase HFI_FLUSH_INPUT:\r\ncase HFI_FLUSH_OUTPUT:\r\ncase HFI_FLUSH_OUTPUT2:\r\ncase HFI_FLUSH_ALL:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\npkt->shdr.hdr.size = sizeof(*pkt);\r\npkt->shdr.hdr.pkt_type = HFI_CMD_SESSION_FLUSH;\r\npkt->shdr.session_id = hash32_ptr(cookie);\r\npkt->flush_type = type;\r\nreturn 0;\r\n}\r\nstatic int pkt_session_get_property_1x(struct hfi_session_get_property_pkt *pkt,\r\nvoid *cookie, u32 ptype)\r\n{\r\nswitch (ptype) {\r\ncase HFI_PROPERTY_PARAM_PROFILE_LEVEL_CURRENT:\r\ncase HFI_PROPERTY_CONFIG_BUFFER_REQUIREMENTS:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\npkt->shdr.hdr.size = sizeof(*pkt);\r\npkt->shdr.hdr.pkt_type = HFI_CMD_SESSION_GET_PROPERTY;\r\npkt->shdr.session_id = hash32_ptr(cookie);\r\npkt->num_properties = 1;\r\npkt->data[0] = ptype;\r\nreturn 0;\r\n}\r\nstatic int pkt_session_set_property_1x(struct hfi_session_set_property_pkt *pkt,\r\nvoid *cookie, u32 ptype, void *pdata)\r\n{\r\nvoid *prop_data;\r\nint ret = 0;\r\nif (!pkt || !cookie || !pdata)\r\nreturn -EINVAL;\r\nprop_data = &pkt->data[1];\r\npkt->shdr.hdr.size = sizeof(*pkt);\r\npkt->shdr.hdr.pkt_type = HFI_CMD_SESSION_SET_PROPERTY;\r\npkt->shdr.session_id = hash32_ptr(cookie);\r\npkt->num_properties = 1;\r\nswitch (ptype) {\r\ncase HFI_PROPERTY_CONFIG_FRAME_RATE: {\r\nstruct hfi_framerate *in = pdata, *frate = prop_data;\r\npkt->data[0] = HFI_PROPERTY_CONFIG_FRAME_RATE;\r\nfrate->buffer_type = in->buffer_type;\r\nfrate->framerate = in->framerate;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*frate);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_UNCOMPRESSED_FORMAT_SELECT: {\r\nstruct hfi_uncompressed_format_select *in = pdata;\r\nstruct hfi_uncompressed_format_select *hfi = prop_data;\r\npkt->data[0] = HFI_PROPERTY_PARAM_UNCOMPRESSED_FORMAT_SELECT;\r\nhfi->buffer_type = in->buffer_type;\r\nhfi->format = in->format;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*hfi);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_FRAME_SIZE: {\r\nstruct hfi_framesize *in = pdata, *fsize = prop_data;\r\npkt->data[0] = HFI_PROPERTY_PARAM_FRAME_SIZE;\r\nfsize->buffer_type = in->buffer_type;\r\nfsize->height = in->height;\r\nfsize->width = in->width;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*fsize);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_CONFIG_REALTIME: {\r\nstruct hfi_enable *in = pdata, *en = prop_data;\r\npkt->data[0] = HFI_PROPERTY_CONFIG_REALTIME;\r\nen->enable = in->enable;\r\npkt->shdr.hdr.size += sizeof(u32) * 2;\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_BUFFER_COUNT_ACTUAL: {\r\nstruct hfi_buffer_count_actual *in = pdata, *count = prop_data;\r\npkt->data[0] = HFI_PROPERTY_PARAM_BUFFER_COUNT_ACTUAL;\r\ncount->count_actual = in->count_actual;\r\ncount->type = in->type;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*count);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_BUFFER_SIZE_ACTUAL: {\r\nstruct hfi_buffer_size_actual *in = pdata, *sz = prop_data;\r\npkt->data[0] = HFI_PROPERTY_PARAM_BUFFER_SIZE_ACTUAL;\r\nsz->size = in->size;\r\nsz->type = in->type;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*sz);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_BUFFER_DISPLAY_HOLD_COUNT_ACTUAL: {\r\nstruct hfi_buffer_display_hold_count_actual *in = pdata;\r\nstruct hfi_buffer_display_hold_count_actual *count = prop_data;\r\npkt->data[0] =\r\nHFI_PROPERTY_PARAM_BUFFER_DISPLAY_HOLD_COUNT_ACTUAL;\r\ncount->hold_count = in->hold_count;\r\ncount->type = in->type;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*count);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_NAL_STREAM_FORMAT_SELECT: {\r\nstruct hfi_nal_stream_format_select *in = pdata;\r\nstruct hfi_nal_stream_format_select *fmt = prop_data;\r\npkt->data[0] = HFI_PROPERTY_PARAM_NAL_STREAM_FORMAT_SELECT;\r\nfmt->format = in->format;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*fmt);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_VDEC_OUTPUT_ORDER: {\r\nu32 *in = pdata;\r\nswitch (*in) {\r\ncase HFI_OUTPUT_ORDER_DECODE:\r\ncase HFI_OUTPUT_ORDER_DISPLAY:\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\npkt->data[0] = HFI_PROPERTY_PARAM_VDEC_OUTPUT_ORDER;\r\npkt->data[1] = *in;\r\npkt->shdr.hdr.size += sizeof(u32) * 2;\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_VDEC_PICTURE_TYPE_DECODE: {\r\nstruct hfi_enable_picture *in = pdata, *en = prop_data;\r\npkt->data[0] = HFI_PROPERTY_PARAM_VDEC_PICTURE_TYPE_DECODE;\r\nen->picture_type = in->picture_type;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*en);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_VDEC_OUTPUT2_KEEP_ASPECT_RATIO: {\r\nstruct hfi_enable *in = pdata, *en = prop_data;\r\npkt->data[0] =\r\nHFI_PROPERTY_PARAM_VDEC_OUTPUT2_KEEP_ASPECT_RATIO;\r\nen->enable = in->enable;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*en);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_CONFIG_VDEC_POST_LOOP_DEBLOCKER: {\r\nstruct hfi_enable *in = pdata;\r\nstruct hfi_enable *en = prop_data;\r\npkt->data[0] = HFI_PROPERTY_CONFIG_VDEC_POST_LOOP_DEBLOCKER;\r\nen->enable = in->enable;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*en);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_VDEC_MULTI_STREAM: {\r\nstruct hfi_multi_stream *in = pdata, *multi = prop_data;\r\npkt->data[0] = HFI_PROPERTY_PARAM_VDEC_MULTI_STREAM;\r\nmulti->buffer_type = in->buffer_type;\r\nmulti->enable = in->enable;\r\nmulti->width = in->width;\r\nmulti->height = in->height;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*multi);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_VDEC_DISPLAY_PICTURE_BUFFER_COUNT: {\r\nstruct hfi_display_picture_buffer_count *in = pdata;\r\nstruct hfi_display_picture_buffer_count *count = prop_data;\r\npkt->data[0] =\r\nHFI_PROPERTY_PARAM_VDEC_DISPLAY_PICTURE_BUFFER_COUNT;\r\ncount->count = in->count;\r\ncount->enable = in->enable;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*count);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_DIVX_FORMAT: {\r\nu32 *in = pdata;\r\nswitch (*in) {\r\ncase HFI_DIVX_FORMAT_4:\r\ncase HFI_DIVX_FORMAT_5:\r\ncase HFI_DIVX_FORMAT_6:\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\npkt->data[0] = HFI_PROPERTY_PARAM_DIVX_FORMAT;\r\npkt->data[1] = *in;\r\npkt->shdr.hdr.size += sizeof(u32) * 2;\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_CONFIG_VDEC_MB_ERROR_MAP_REPORTING: {\r\nstruct hfi_enable *in = pdata, *en = prop_data;\r\npkt->data[0] = HFI_PROPERTY_CONFIG_VDEC_MB_ERROR_MAP_REPORTING;\r\nen->enable = in->enable;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*en);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_VDEC_CONTINUE_DATA_TRANSFER: {\r\nstruct hfi_enable *in = pdata, *en = prop_data;\r\npkt->data[0] = HFI_PROPERTY_PARAM_VDEC_CONTINUE_DATA_TRANSFER;\r\nen->enable = in->enable;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*en);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_VDEC_THUMBNAIL_MODE: {\r\nstruct hfi_enable *in = pdata, *en = prop_data;\r\npkt->data[0] = HFI_PROPERTY_PARAM_VDEC_THUMBNAIL_MODE;\r\nen->enable = in->enable;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*en);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_CONFIG_VENC_SYNC_FRAME_SEQUENCE_HEADER: {\r\nstruct hfi_enable *in = pdata, *en = prop_data;\r\npkt->data[0] =\r\nHFI_PROPERTY_CONFIG_VENC_SYNC_FRAME_SEQUENCE_HEADER;\r\nen->enable = in->enable;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*en);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_CONFIG_VENC_REQUEST_SYNC_FRAME:\r\npkt->data[0] = HFI_PROPERTY_CONFIG_VENC_REQUEST_SYNC_FRAME;\r\npkt->shdr.hdr.size += sizeof(u32);\r\nbreak;\r\ncase HFI_PROPERTY_PARAM_VENC_MPEG4_SHORT_HEADER:\r\nbreak;\r\ncase HFI_PROPERTY_PARAM_VENC_MPEG4_AC_PREDICTION:\r\nbreak;\r\ncase HFI_PROPERTY_CONFIG_VENC_TARGET_BITRATE: {\r\nstruct hfi_bitrate *in = pdata, *brate = prop_data;\r\npkt->data[0] = HFI_PROPERTY_CONFIG_VENC_TARGET_BITRATE;\r\nbrate->bitrate = in->bitrate;\r\nbrate->layer_id = in->layer_id;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*brate);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_CONFIG_VENC_MAX_BITRATE: {\r\nstruct hfi_bitrate *in = pdata, *hfi = prop_data;\r\npkt->data[0] = HFI_PROPERTY_CONFIG_VENC_MAX_BITRATE;\r\nhfi->bitrate = in->bitrate;\r\nhfi->layer_id = in->layer_id;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*hfi);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_PROFILE_LEVEL_CURRENT: {\r\nstruct hfi_profile_level *in = pdata, *pl = prop_data;\r\npkt->data[0] = HFI_PROPERTY_PARAM_PROFILE_LEVEL_CURRENT;\r\npl->level = in->level;\r\npl->profile = in->profile;\r\nif (pl->profile <= 0)\r\npl->profile = HFI_H264_PROFILE_HIGH;\r\nif (!pl->level)\r\npl->level = 1;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*pl);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_VENC_H264_ENTROPY_CONTROL: {\r\nstruct hfi_h264_entropy_control *in = pdata, *hfi = prop_data;\r\npkt->data[0] = HFI_PROPERTY_PARAM_VENC_H264_ENTROPY_CONTROL;\r\nhfi->entropy_mode = in->entropy_mode;\r\nif (hfi->entropy_mode == HFI_H264_ENTROPY_CABAC)\r\nhfi->cabac_model = in->cabac_model;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*hfi);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_VENC_RATE_CONTROL: {\r\nu32 *in = pdata;\r\nswitch (*in) {\r\ncase HFI_RATE_CONTROL_OFF:\r\ncase HFI_RATE_CONTROL_CBR_CFR:\r\ncase HFI_RATE_CONTROL_CBR_VFR:\r\ncase HFI_RATE_CONTROL_VBR_CFR:\r\ncase HFI_RATE_CONTROL_VBR_VFR:\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\npkt->data[0] = HFI_PROPERTY_PARAM_VENC_RATE_CONTROL;\r\npkt->data[1] = *in;\r\npkt->shdr.hdr.size += sizeof(u32) * 2;\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_VENC_MPEG4_TIME_RESOLUTION: {\r\nstruct hfi_mpeg4_time_resolution *in = pdata, *res = prop_data;\r\npkt->data[0] = HFI_PROPERTY_PARAM_VENC_MPEG4_TIME_RESOLUTION;\r\nres->time_increment_resolution = in->time_increment_resolution;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*res);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_VENC_MPEG4_HEADER_EXTENSION: {\r\nstruct hfi_mpeg4_header_extension *in = pdata, *ext = prop_data;\r\npkt->data[0] = HFI_PROPERTY_PARAM_VENC_MPEG4_HEADER_EXTENSION;\r\next->header_extension = in->header_extension;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*ext);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_VENC_H264_DEBLOCK_CONTROL: {\r\nstruct hfi_h264_db_control *in = pdata, *db = prop_data;\r\nswitch (in->mode) {\r\ncase HFI_H264_DB_MODE_DISABLE:\r\ncase HFI_H264_DB_MODE_SKIP_SLICE_BOUNDARY:\r\ncase HFI_H264_DB_MODE_ALL_BOUNDARY:\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\npkt->data[0] = HFI_PROPERTY_PARAM_VENC_H264_DEBLOCK_CONTROL;\r\ndb->mode = in->mode;\r\ndb->slice_alpha_offset = in->slice_alpha_offset;\r\ndb->slice_beta_offset = in->slice_beta_offset;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*db);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_VENC_SESSION_QP: {\r\nstruct hfi_quantization *in = pdata, *quant = prop_data;\r\npkt->data[0] = HFI_PROPERTY_PARAM_VENC_SESSION_QP;\r\nquant->qp_i = in->qp_i;\r\nquant->qp_p = in->qp_p;\r\nquant->qp_b = in->qp_b;\r\nquant->layer_id = in->layer_id;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*quant);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_VENC_SESSION_QP_RANGE: {\r\nstruct hfi_quantization_range *in = pdata, *range = prop_data;\r\nu32 min_qp, max_qp;\r\npkt->data[0] = HFI_PROPERTY_PARAM_VENC_SESSION_QP_RANGE;\r\nmin_qp = in->min_qp;\r\nmax_qp = in->max_qp;\r\nif (min_qp > 0xff || max_qp > 0xff) {\r\nret = -ERANGE;\r\nbreak;\r\n}\r\nrange->min_qp = min_qp | min_qp << 8 | min_qp << 16;\r\nrange->max_qp = max_qp | max_qp << 8 | max_qp << 16;\r\nrange->layer_id = in->layer_id;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*range);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_VENC_VC1_PERF_CFG: {\r\nstruct hfi_vc1e_perf_cfg_type *in = pdata, *perf = prop_data;\r\npkt->data[0] = HFI_PROPERTY_PARAM_VENC_VC1_PERF_CFG;\r\nmemcpy(perf->search_range_x_subsampled,\r\nin->search_range_x_subsampled,\r\nsizeof(perf->search_range_x_subsampled));\r\nmemcpy(perf->search_range_y_subsampled,\r\nin->search_range_y_subsampled,\r\nsizeof(perf->search_range_y_subsampled));\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*perf);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_VENC_MAX_NUM_B_FRAMES: {\r\nstruct hfi_max_num_b_frames *bframes = prop_data;\r\nu32 *in = pdata;\r\npkt->data[0] = HFI_PROPERTY_PARAM_VENC_MAX_NUM_B_FRAMES;\r\nbframes->max_num_b_frames = *in;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*bframes);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_CONFIG_VENC_INTRA_PERIOD: {\r\nstruct hfi_intra_period *in = pdata, *intra = prop_data;\r\npkt->data[0] = HFI_PROPERTY_CONFIG_VENC_INTRA_PERIOD;\r\nintra->pframes = in->pframes;\r\nintra->bframes = in->bframes;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*intra);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_CONFIG_VENC_IDR_PERIOD: {\r\nstruct hfi_idr_period *in = pdata, *idr = prop_data;\r\npkt->data[0] = HFI_PROPERTY_CONFIG_VENC_IDR_PERIOD;\r\nidr->idr_period = in->idr_period;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*idr);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_VDEC_CONCEAL_COLOR: {\r\nstruct hfi_conceal_color *color = prop_data;\r\nu32 *in = pdata;\r\npkt->data[0] = HFI_PROPERTY_PARAM_VDEC_CONCEAL_COLOR;\r\ncolor->conceal_color = *in;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*color);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_CONFIG_VPE_OPERATIONS: {\r\nstruct hfi_operations_type *in = pdata, *ops = prop_data;\r\nswitch (in->rotation) {\r\ncase HFI_ROTATE_NONE:\r\ncase HFI_ROTATE_90:\r\ncase HFI_ROTATE_180:\r\ncase HFI_ROTATE_270:\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nswitch (in->flip) {\r\ncase HFI_FLIP_NONE:\r\ncase HFI_FLIP_HORIZONTAL:\r\ncase HFI_FLIP_VERTICAL:\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\npkt->data[0] = HFI_PROPERTY_CONFIG_VPE_OPERATIONS;\r\nops->rotation = in->rotation;\r\nops->flip = in->flip;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*ops);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_VENC_INTRA_REFRESH: {\r\nstruct hfi_intra_refresh *in = pdata, *intra = prop_data;\r\nswitch (in->mode) {\r\ncase HFI_INTRA_REFRESH_NONE:\r\ncase HFI_INTRA_REFRESH_ADAPTIVE:\r\ncase HFI_INTRA_REFRESH_CYCLIC:\r\ncase HFI_INTRA_REFRESH_CYCLIC_ADAPTIVE:\r\ncase HFI_INTRA_REFRESH_RANDOM:\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\npkt->data[0] = HFI_PROPERTY_PARAM_VENC_INTRA_REFRESH;\r\nintra->mode = in->mode;\r\nintra->air_mbs = in->air_mbs;\r\nintra->air_ref = in->air_ref;\r\nintra->cir_mbs = in->cir_mbs;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*intra);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_VENC_MULTI_SLICE_CONTROL: {\r\nstruct hfi_multi_slice_control *in = pdata, *multi = prop_data;\r\nswitch (in->multi_slice) {\r\ncase HFI_MULTI_SLICE_OFF:\r\ncase HFI_MULTI_SLICE_GOB:\r\ncase HFI_MULTI_SLICE_BY_MB_COUNT:\r\ncase HFI_MULTI_SLICE_BY_BYTE_COUNT:\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\npkt->data[0] = HFI_PROPERTY_PARAM_VENC_MULTI_SLICE_CONTROL;\r\nmulti->multi_slice = in->multi_slice;\r\nmulti->slice_size = in->slice_size;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*multi);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_VENC_SLICE_DELIVERY_MODE: {\r\nstruct hfi_enable *in = pdata, *en = prop_data;\r\npkt->data[0] = HFI_PROPERTY_PARAM_VENC_SLICE_DELIVERY_MODE;\r\nen->enable = in->enable;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*en);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_VENC_H264_VUI_TIMING_INFO: {\r\nstruct hfi_h264_vui_timing_info *in = pdata, *vui = prop_data;\r\npkt->data[0] = HFI_PROPERTY_PARAM_VENC_H264_VUI_TIMING_INFO;\r\nvui->enable = in->enable;\r\nvui->fixed_framerate = in->fixed_framerate;\r\nvui->time_scale = in->time_scale;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*vui);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_CONFIG_VPE_DEINTERLACE: {\r\nstruct hfi_enable *in = pdata, *en = prop_data;\r\npkt->data[0] = HFI_PROPERTY_CONFIG_VPE_DEINTERLACE;\r\nen->enable = in->enable;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*en);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_VENC_H264_GENERATE_AUDNAL: {\r\nstruct hfi_enable *in = pdata, *en = prop_data;\r\npkt->data[0] = HFI_PROPERTY_PARAM_VENC_H264_GENERATE_AUDNAL;\r\nen->enable = in->enable;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*en);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_BUFFER_ALLOC_MODE: {\r\nstruct hfi_buffer_alloc_mode *in = pdata, *mode = prop_data;\r\npkt->data[0] = HFI_PROPERTY_PARAM_BUFFER_ALLOC_MODE;\r\nmode->type = in->type;\r\nmode->mode = in->mode;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*mode);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_VDEC_FRAME_ASSEMBLY: {\r\nstruct hfi_enable *in = pdata, *en = prop_data;\r\npkt->data[0] = HFI_PROPERTY_PARAM_VDEC_FRAME_ASSEMBLY;\r\nen->enable = in->enable;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*en);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_VENC_H264_VUI_BITSTREAM_RESTRC: {\r\nstruct hfi_enable *in = pdata, *en = prop_data;\r\npkt->data[0] =\r\nHFI_PROPERTY_PARAM_VENC_H264_VUI_BITSTREAM_RESTRC;\r\nen->enable = in->enable;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*en);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_VENC_PRESERVE_TEXT_QUALITY: {\r\nstruct hfi_enable *in = pdata, *en = prop_data;\r\npkt->data[0] = HFI_PROPERTY_PARAM_VENC_PRESERVE_TEXT_QUALITY;\r\nen->enable = in->enable;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*en);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_VDEC_SCS_THRESHOLD: {\r\nstruct hfi_scs_threshold *thres = prop_data;\r\nu32 *in = pdata;\r\npkt->data[0] = HFI_PROPERTY_PARAM_VDEC_SCS_THRESHOLD;\r\nthres->threshold_value = *in;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*thres);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_MVC_BUFFER_LAYOUT: {\r\nstruct hfi_mvc_buffer_layout_descp_type *in = pdata;\r\nstruct hfi_mvc_buffer_layout_descp_type *mvc = prop_data;\r\nswitch (in->layout_type) {\r\ncase HFI_MVC_BUFFER_LAYOUT_TOP_BOTTOM:\r\ncase HFI_MVC_BUFFER_LAYOUT_SEQ:\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\npkt->data[0] = HFI_PROPERTY_PARAM_MVC_BUFFER_LAYOUT;\r\nmvc->layout_type = in->layout_type;\r\nmvc->bright_view_first = in->bright_view_first;\r\nmvc->ngap = in->ngap;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*mvc);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_VENC_LTRMODE: {\r\nstruct hfi_ltr_mode *in = pdata, *ltr = prop_data;\r\nswitch (in->ltr_mode) {\r\ncase HFI_LTR_MODE_DISABLE:\r\ncase HFI_LTR_MODE_MANUAL:\r\ncase HFI_LTR_MODE_PERIODIC:\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\npkt->data[0] = HFI_PROPERTY_PARAM_VENC_LTRMODE;\r\nltr->ltr_mode = in->ltr_mode;\r\nltr->ltr_count = in->ltr_count;\r\nltr->trust_mode = in->trust_mode;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*ltr);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_CONFIG_VENC_USELTRFRAME: {\r\nstruct hfi_ltr_use *in = pdata, *ltr_use = prop_data;\r\npkt->data[0] = HFI_PROPERTY_CONFIG_VENC_USELTRFRAME;\r\nltr_use->frames = in->frames;\r\nltr_use->ref_ltr = in->ref_ltr;\r\nltr_use->use_constrnt = in->use_constrnt;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*ltr_use);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_CONFIG_VENC_MARKLTRFRAME: {\r\nstruct hfi_ltr_mark *in = pdata, *ltr_mark = prop_data;\r\npkt->data[0] = HFI_PROPERTY_CONFIG_VENC_MARKLTRFRAME;\r\nltr_mark->mark_frame = in->mark_frame;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*ltr_mark);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_VENC_HIER_P_MAX_NUM_ENH_LAYER: {\r\nu32 *in = pdata;\r\npkt->data[0] = HFI_PROPERTY_PARAM_VENC_HIER_P_MAX_NUM_ENH_LAYER;\r\npkt->data[1] = *in;\r\npkt->shdr.hdr.size += sizeof(u32) * 2;\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_CONFIG_VENC_HIER_P_ENH_LAYER: {\r\nu32 *in = pdata;\r\npkt->data[0] = HFI_PROPERTY_CONFIG_VENC_HIER_P_ENH_LAYER;\r\npkt->data[1] = *in;\r\npkt->shdr.hdr.size += sizeof(u32) * 2;\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_VENC_DISABLE_RC_TIMESTAMP: {\r\nstruct hfi_enable *in = pdata, *en = prop_data;\r\npkt->data[0] = HFI_PROPERTY_PARAM_VENC_DISABLE_RC_TIMESTAMP;\r\nen->enable = in->enable;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*en);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_VENC_INITIAL_QP: {\r\nstruct hfi_initial_quantization *in = pdata, *quant = prop_data;\r\npkt->data[0] = HFI_PROPERTY_PARAM_VENC_INITIAL_QP;\r\nquant->init_qp_enable = in->init_qp_enable;\r\nquant->qp_i = in->qp_i;\r\nquant->qp_p = in->qp_p;\r\nquant->qp_b = in->qp_b;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*quant);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_VPE_COLOR_SPACE_CONVERSION: {\r\nstruct hfi_vpe_color_space_conversion *in = pdata;\r\nstruct hfi_vpe_color_space_conversion *csc = prop_data;\r\npkt->data[0] = HFI_PROPERTY_PARAM_VPE_COLOR_SPACE_CONVERSION;\r\nmemcpy(csc->csc_matrix, in->csc_matrix,\r\nsizeof(csc->csc_matrix));\r\nmemcpy(csc->csc_bias, in->csc_bias, sizeof(csc->csc_bias));\r\nmemcpy(csc->csc_limit, in->csc_limit, sizeof(csc->csc_limit));\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*csc);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_VENC_VPX_ERROR_RESILIENCE_MODE: {\r\nstruct hfi_enable *in = pdata, *en = prop_data;\r\npkt->data[0] =\r\nHFI_PROPERTY_PARAM_VENC_VPX_ERROR_RESILIENCE_MODE;\r\nen->enable = in->enable;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*en);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_VENC_H264_NAL_SVC_EXT: {\r\nstruct hfi_enable *in = pdata, *en = prop_data;\r\npkt->data[0] = HFI_PROPERTY_PARAM_VENC_H264_NAL_SVC_EXT;\r\nen->enable = in->enable;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*en);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_CONFIG_VENC_PERF_MODE: {\r\nu32 *in = pdata;\r\npkt->data[0] = HFI_PROPERTY_CONFIG_VENC_PERF_MODE;\r\npkt->data[1] = *in;\r\npkt->shdr.hdr.size += sizeof(u32) * 2;\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_VENC_HIER_B_MAX_NUM_ENH_LAYER: {\r\nu32 *in = pdata;\r\npkt->data[0] = HFI_PROPERTY_PARAM_VENC_HIER_B_MAX_NUM_ENH_LAYER;\r\npkt->data[1] = *in;\r\npkt->shdr.hdr.size += sizeof(u32) * 2;\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_VDEC_NONCP_OUTPUT2: {\r\nstruct hfi_enable *in = pdata, *en = prop_data;\r\npkt->data[0] = HFI_PROPERTY_PARAM_VDEC_NONCP_OUTPUT2;\r\nen->enable = in->enable;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*en);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_VENC_HIER_P_HYBRID_MODE: {\r\nstruct hfi_hybrid_hierp *in = pdata, *hierp = prop_data;\r\npkt->data[0] = HFI_PROPERTY_PARAM_VENC_HIER_P_HYBRID_MODE;\r\nhierp->layers = in->layers;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*hierp);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_CONFIG_BUFFER_REQUIREMENTS:\r\ncase HFI_PROPERTY_CONFIG_PRIORITY:\r\ncase HFI_PROPERTY_CONFIG_BATCH_INFO:\r\ncase HFI_PROPERTY_SYS_IDLE_INDICATOR:\r\ncase HFI_PROPERTY_PARAM_UNCOMPRESSED_FORMAT_SUPPORTED:\r\ncase HFI_PROPERTY_PARAM_INTERLACE_FORMAT_SUPPORTED:\r\ncase HFI_PROPERTY_PARAM_CHROMA_SITE:\r\ncase HFI_PROPERTY_PARAM_PROPERTIES_SUPPORTED:\r\ncase HFI_PROPERTY_PARAM_PROFILE_LEVEL_SUPPORTED:\r\ncase HFI_PROPERTY_PARAM_CAPABILITY_SUPPORTED:\r\ncase HFI_PROPERTY_PARAM_NAL_STREAM_FORMAT_SUPPORTED:\r\ncase HFI_PROPERTY_PARAM_MULTI_VIEW_FORMAT:\r\ncase HFI_PROPERTY_PARAM_MAX_SEQUENCE_HEADER_SIZE:\r\ncase HFI_PROPERTY_PARAM_CODEC_SUPPORTED:\r\ncase HFI_PROPERTY_PARAM_VDEC_MULTI_VIEW_SELECT:\r\ncase HFI_PROPERTY_PARAM_VDEC_MB_QUANTIZATION:\r\ncase HFI_PROPERTY_PARAM_VDEC_NUM_CONCEALED_MB:\r\ncase HFI_PROPERTY_PARAM_VDEC_H264_ENTROPY_SWITCHING:\r\ncase HFI_PROPERTY_PARAM_VENC_MULTI_SLICE_INFO:\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\npkt_session_get_property_3xx(struct hfi_session_get_property_pkt *pkt,\r\nvoid *cookie, u32 ptype)\r\n{\r\nint ret = 0;\r\nif (!pkt || !cookie)\r\nreturn -EINVAL;\r\npkt->shdr.hdr.size = sizeof(struct hfi_session_get_property_pkt);\r\npkt->shdr.hdr.pkt_type = HFI_CMD_SESSION_GET_PROPERTY;\r\npkt->shdr.session_id = hash32_ptr(cookie);\r\npkt->num_properties = 1;\r\nswitch (ptype) {\r\ncase HFI_PROPERTY_CONFIG_VDEC_ENTROPY:\r\npkt->data[0] = HFI_PROPERTY_CONFIG_VDEC_ENTROPY;\r\nbreak;\r\ndefault:\r\nret = pkt_session_get_property_1x(pkt, cookie, ptype);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\npkt_session_set_property_3xx(struct hfi_session_set_property_pkt *pkt,\r\nvoid *cookie, u32 ptype, void *pdata)\r\n{\r\nvoid *prop_data;\r\nint ret = 0;\r\nif (!pkt || !cookie || !pdata)\r\nreturn -EINVAL;\r\nprop_data = &pkt->data[1];\r\npkt->shdr.hdr.size = sizeof(*pkt);\r\npkt->shdr.hdr.pkt_type = HFI_CMD_SESSION_SET_PROPERTY;\r\npkt->shdr.session_id = hash32_ptr(cookie);\r\npkt->num_properties = 1;\r\nswitch (ptype) {\r\ncase HFI_PROPERTY_PARAM_VDEC_MULTI_STREAM: {\r\nstruct hfi_multi_stream *in = pdata;\r\nstruct hfi_multi_stream_3x *multi = prop_data;\r\npkt->data[0] = HFI_PROPERTY_PARAM_VDEC_MULTI_STREAM;\r\nmulti->buffer_type = in->buffer_type;\r\nmulti->enable = in->enable;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*multi);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_VENC_INTRA_REFRESH: {\r\nstruct hfi_intra_refresh *in = pdata;\r\nstruct hfi_intra_refresh_3x *intra = prop_data;\r\nswitch (in->mode) {\r\ncase HFI_INTRA_REFRESH_NONE:\r\ncase HFI_INTRA_REFRESH_ADAPTIVE:\r\ncase HFI_INTRA_REFRESH_CYCLIC:\r\ncase HFI_INTRA_REFRESH_CYCLIC_ADAPTIVE:\r\ncase HFI_INTRA_REFRESH_RANDOM:\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\npkt->data[0] = HFI_PROPERTY_PARAM_VENC_INTRA_REFRESH;\r\nintra->mode = in->mode;\r\nintra->mbs = in->cir_mbs;\r\npkt->shdr.hdr.size += sizeof(u32) + sizeof(*intra);\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_VDEC_CONTINUE_DATA_TRANSFER:\r\nbreak;\r\ndefault:\r\nret = pkt_session_set_property_1x(pkt, cookie, ptype, pdata);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nint pkt_session_get_property(struct hfi_session_get_property_pkt *pkt,\r\nvoid *cookie, u32 ptype)\r\n{\r\nif (hfi_ver == HFI_VERSION_1XX)\r\nreturn pkt_session_get_property_1x(pkt, cookie, ptype);\r\nreturn pkt_session_get_property_3xx(pkt, cookie, ptype);\r\n}\r\nint pkt_session_set_property(struct hfi_session_set_property_pkt *pkt,\r\nvoid *cookie, u32 ptype, void *pdata)\r\n{\r\nif (hfi_ver == HFI_VERSION_1XX)\r\nreturn pkt_session_set_property_1x(pkt, cookie, ptype, pdata);\r\nreturn pkt_session_set_property_3xx(pkt, cookie, ptype, pdata);\r\n}\r\nvoid pkt_set_version(enum hfi_version version)\r\n{\r\nhfi_ver = version;\r\n}
