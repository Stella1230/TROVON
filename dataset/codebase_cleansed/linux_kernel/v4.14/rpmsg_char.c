static int rpmsg_eptdev_destroy(struct device *dev, void *data)\r\n{\r\nstruct rpmsg_eptdev *eptdev = dev_to_eptdev(dev);\r\nmutex_lock(&eptdev->ept_lock);\r\nif (eptdev->ept) {\r\nrpmsg_destroy_ept(eptdev->ept);\r\neptdev->ept = NULL;\r\n}\r\nmutex_unlock(&eptdev->ept_lock);\r\nwake_up_interruptible(&eptdev->readq);\r\ndevice_del(&eptdev->dev);\r\nput_device(&eptdev->dev);\r\nreturn 0;\r\n}\r\nstatic int rpmsg_ept_cb(struct rpmsg_device *rpdev, void *buf, int len,\r\nvoid *priv, u32 addr)\r\n{\r\nstruct rpmsg_eptdev *eptdev = priv;\r\nstruct sk_buff *skb;\r\nskb = alloc_skb(len, GFP_ATOMIC);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nskb_put_data(skb, buf, len);\r\nspin_lock(&eptdev->queue_lock);\r\nskb_queue_tail(&eptdev->queue, skb);\r\nspin_unlock(&eptdev->queue_lock);\r\nwake_up_interruptible(&eptdev->readq);\r\nreturn 0;\r\n}\r\nstatic int rpmsg_eptdev_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct rpmsg_eptdev *eptdev = cdev_to_eptdev(inode->i_cdev);\r\nstruct rpmsg_endpoint *ept;\r\nstruct rpmsg_device *rpdev = eptdev->rpdev;\r\nstruct device *dev = &eptdev->dev;\r\nget_device(dev);\r\nept = rpmsg_create_ept(rpdev, rpmsg_ept_cb, eptdev, eptdev->chinfo);\r\nif (!ept) {\r\ndev_err(dev, "failed to open %s\n", eptdev->chinfo.name);\r\nput_device(dev);\r\nreturn -EINVAL;\r\n}\r\neptdev->ept = ept;\r\nfilp->private_data = eptdev;\r\nreturn 0;\r\n}\r\nstatic int rpmsg_eptdev_release(struct inode *inode, struct file *filp)\r\n{\r\nstruct rpmsg_eptdev *eptdev = cdev_to_eptdev(inode->i_cdev);\r\nstruct device *dev = &eptdev->dev;\r\nstruct sk_buff *skb;\r\nmutex_lock(&eptdev->ept_lock);\r\nif (eptdev->ept) {\r\nrpmsg_destroy_ept(eptdev->ept);\r\neptdev->ept = NULL;\r\n}\r\nmutex_unlock(&eptdev->ept_lock);\r\nwhile (!skb_queue_empty(&eptdev->queue)) {\r\nskb = skb_dequeue(&eptdev->queue);\r\nkfree_skb(skb);\r\n}\r\nput_device(dev);\r\nreturn 0;\r\n}\r\nstatic ssize_t rpmsg_eptdev_read(struct file *filp, char __user *buf,\r\nsize_t len, loff_t *f_pos)\r\n{\r\nstruct rpmsg_eptdev *eptdev = filp->private_data;\r\nunsigned long flags;\r\nstruct sk_buff *skb;\r\nint use;\r\nif (!eptdev->ept)\r\nreturn -EPIPE;\r\nspin_lock_irqsave(&eptdev->queue_lock, flags);\r\nif (skb_queue_empty(&eptdev->queue)) {\r\nspin_unlock_irqrestore(&eptdev->queue_lock, flags);\r\nif (filp->f_flags & O_NONBLOCK)\r\nreturn -EAGAIN;\r\nif (wait_event_interruptible(eptdev->readq,\r\n!skb_queue_empty(&eptdev->queue) ||\r\n!eptdev->ept))\r\nreturn -ERESTARTSYS;\r\nif (!eptdev->ept)\r\nreturn -EPIPE;\r\nspin_lock_irqsave(&eptdev->queue_lock, flags);\r\n}\r\nskb = skb_dequeue(&eptdev->queue);\r\nspin_unlock_irqrestore(&eptdev->queue_lock, flags);\r\nif (!skb)\r\nreturn -EFAULT;\r\nuse = min_t(size_t, len, skb->len);\r\nif (copy_to_user(buf, skb->data, use))\r\nuse = -EFAULT;\r\nkfree_skb(skb);\r\nreturn use;\r\n}\r\nstatic ssize_t rpmsg_eptdev_write(struct file *filp, const char __user *buf,\r\nsize_t len, loff_t *f_pos)\r\n{\r\nstruct rpmsg_eptdev *eptdev = filp->private_data;\r\nvoid *kbuf;\r\nint ret;\r\nkbuf = memdup_user(buf, len);\r\nif (IS_ERR(kbuf))\r\nreturn PTR_ERR(kbuf);\r\nif (mutex_lock_interruptible(&eptdev->ept_lock)) {\r\nret = -ERESTARTSYS;\r\ngoto free_kbuf;\r\n}\r\nif (!eptdev->ept) {\r\nret = -EPIPE;\r\ngoto unlock_eptdev;\r\n}\r\nif (filp->f_flags & O_NONBLOCK)\r\nret = rpmsg_trysend(eptdev->ept, kbuf, len);\r\nelse\r\nret = rpmsg_send(eptdev->ept, kbuf, len);\r\nunlock_eptdev:\r\nmutex_unlock(&eptdev->ept_lock);\r\nfree_kbuf:\r\nkfree(kbuf);\r\nreturn ret < 0 ? ret : len;\r\n}\r\nstatic unsigned int rpmsg_eptdev_poll(struct file *filp, poll_table *wait)\r\n{\r\nstruct rpmsg_eptdev *eptdev = filp->private_data;\r\nunsigned int mask = 0;\r\nif (!eptdev->ept)\r\nreturn POLLERR;\r\npoll_wait(filp, &eptdev->readq, wait);\r\nif (!skb_queue_empty(&eptdev->queue))\r\nmask |= POLLIN | POLLRDNORM;\r\nmask |= rpmsg_poll(eptdev->ept, filp, wait);\r\nreturn mask;\r\n}\r\nstatic long rpmsg_eptdev_ioctl(struct file *fp, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct rpmsg_eptdev *eptdev = fp->private_data;\r\nif (cmd != RPMSG_DESTROY_EPT_IOCTL)\r\nreturn -EINVAL;\r\nreturn rpmsg_eptdev_destroy(&eptdev->dev, NULL);\r\n}\r\nstatic ssize_t name_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct rpmsg_eptdev *eptdev = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%s\n", eptdev->chinfo.name);\r\n}\r\nstatic ssize_t src_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct rpmsg_eptdev *eptdev = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", eptdev->chinfo.src);\r\n}\r\nstatic ssize_t dst_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct rpmsg_eptdev *eptdev = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", eptdev->chinfo.dst);\r\n}\r\nstatic void rpmsg_eptdev_release_device(struct device *dev)\r\n{\r\nstruct rpmsg_eptdev *eptdev = dev_to_eptdev(dev);\r\nida_simple_remove(&rpmsg_ept_ida, dev->id);\r\nida_simple_remove(&rpmsg_minor_ida, MINOR(eptdev->dev.devt));\r\ncdev_del(&eptdev->cdev);\r\nkfree(eptdev);\r\n}\r\nstatic int rpmsg_eptdev_create(struct rpmsg_ctrldev *ctrldev,\r\nstruct rpmsg_channel_info chinfo)\r\n{\r\nstruct rpmsg_device *rpdev = ctrldev->rpdev;\r\nstruct rpmsg_eptdev *eptdev;\r\nstruct device *dev;\r\nint ret;\r\neptdev = kzalloc(sizeof(*eptdev), GFP_KERNEL);\r\nif (!eptdev)\r\nreturn -ENOMEM;\r\ndev = &eptdev->dev;\r\neptdev->rpdev = rpdev;\r\neptdev->chinfo = chinfo;\r\nmutex_init(&eptdev->ept_lock);\r\nspin_lock_init(&eptdev->queue_lock);\r\nskb_queue_head_init(&eptdev->queue);\r\ninit_waitqueue_head(&eptdev->readq);\r\ndevice_initialize(dev);\r\ndev->class = rpmsg_class;\r\ndev->parent = &ctrldev->dev;\r\ndev->groups = rpmsg_eptdev_groups;\r\ndev_set_drvdata(dev, eptdev);\r\ncdev_init(&eptdev->cdev, &rpmsg_eptdev_fops);\r\neptdev->cdev.owner = THIS_MODULE;\r\nret = ida_simple_get(&rpmsg_minor_ida, 0, RPMSG_DEV_MAX, GFP_KERNEL);\r\nif (ret < 0)\r\ngoto free_eptdev;\r\ndev->devt = MKDEV(MAJOR(rpmsg_major), ret);\r\nret = ida_simple_get(&rpmsg_ept_ida, 0, 0, GFP_KERNEL);\r\nif (ret < 0)\r\ngoto free_minor_ida;\r\ndev->id = ret;\r\ndev_set_name(dev, "rpmsg%d", ret);\r\nret = cdev_add(&eptdev->cdev, dev->devt, 1);\r\nif (ret)\r\ngoto free_ept_ida;\r\ndev->release = rpmsg_eptdev_release_device;\r\nret = device_add(dev);\r\nif (ret) {\r\ndev_err(dev, "device_add failed: %d\n", ret);\r\nput_device(dev);\r\n}\r\nreturn ret;\r\nfree_ept_ida:\r\nida_simple_remove(&rpmsg_ept_ida, dev->id);\r\nfree_minor_ida:\r\nida_simple_remove(&rpmsg_minor_ida, MINOR(dev->devt));\r\nfree_eptdev:\r\nput_device(dev);\r\nkfree(eptdev);\r\nreturn ret;\r\n}\r\nstatic int rpmsg_ctrldev_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct rpmsg_ctrldev *ctrldev = cdev_to_ctrldev(inode->i_cdev);\r\nget_device(&ctrldev->dev);\r\nfilp->private_data = ctrldev;\r\nreturn 0;\r\n}\r\nstatic int rpmsg_ctrldev_release(struct inode *inode, struct file *filp)\r\n{\r\nstruct rpmsg_ctrldev *ctrldev = cdev_to_ctrldev(inode->i_cdev);\r\nput_device(&ctrldev->dev);\r\nreturn 0;\r\n}\r\nstatic long rpmsg_ctrldev_ioctl(struct file *fp, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct rpmsg_ctrldev *ctrldev = fp->private_data;\r\nvoid __user *argp = (void __user *)arg;\r\nstruct rpmsg_endpoint_info eptinfo;\r\nstruct rpmsg_channel_info chinfo;\r\nif (cmd != RPMSG_CREATE_EPT_IOCTL)\r\nreturn -EINVAL;\r\nif (copy_from_user(&eptinfo, argp, sizeof(eptinfo)))\r\nreturn -EFAULT;\r\nmemcpy(chinfo.name, eptinfo.name, RPMSG_NAME_SIZE);\r\nchinfo.name[RPMSG_NAME_SIZE-1] = '\0';\r\nchinfo.src = eptinfo.src;\r\nchinfo.dst = eptinfo.dst;\r\nreturn rpmsg_eptdev_create(ctrldev, chinfo);\r\n}\r\nstatic void rpmsg_ctrldev_release_device(struct device *dev)\r\n{\r\nstruct rpmsg_ctrldev *ctrldev = dev_to_ctrldev(dev);\r\nida_simple_remove(&rpmsg_ctrl_ida, dev->id);\r\nida_simple_remove(&rpmsg_minor_ida, MINOR(dev->devt));\r\ncdev_del(&ctrldev->cdev);\r\nkfree(ctrldev);\r\n}\r\nstatic int rpmsg_chrdev_probe(struct rpmsg_device *rpdev)\r\n{\r\nstruct rpmsg_ctrldev *ctrldev;\r\nstruct device *dev;\r\nint ret;\r\nctrldev = kzalloc(sizeof(*ctrldev), GFP_KERNEL);\r\nif (!ctrldev)\r\nreturn -ENOMEM;\r\nctrldev->rpdev = rpdev;\r\ndev = &ctrldev->dev;\r\ndevice_initialize(dev);\r\ndev->parent = &rpdev->dev;\r\ndev->class = rpmsg_class;\r\ncdev_init(&ctrldev->cdev, &rpmsg_ctrldev_fops);\r\nctrldev->cdev.owner = THIS_MODULE;\r\nret = ida_simple_get(&rpmsg_minor_ida, 0, RPMSG_DEV_MAX, GFP_KERNEL);\r\nif (ret < 0)\r\ngoto free_ctrldev;\r\ndev->devt = MKDEV(MAJOR(rpmsg_major), ret);\r\nret = ida_simple_get(&rpmsg_ctrl_ida, 0, 0, GFP_KERNEL);\r\nif (ret < 0)\r\ngoto free_minor_ida;\r\ndev->id = ret;\r\ndev_set_name(&ctrldev->dev, "rpmsg_ctrl%d", ret);\r\nret = cdev_add(&ctrldev->cdev, dev->devt, 1);\r\nif (ret)\r\ngoto free_ctrl_ida;\r\ndev->release = rpmsg_ctrldev_release_device;\r\nret = device_add(dev);\r\nif (ret) {\r\ndev_err(&rpdev->dev, "device_add failed: %d\n", ret);\r\nput_device(dev);\r\n}\r\ndev_set_drvdata(&rpdev->dev, ctrldev);\r\nreturn ret;\r\nfree_ctrl_ida:\r\nida_simple_remove(&rpmsg_ctrl_ida, dev->id);\r\nfree_minor_ida:\r\nida_simple_remove(&rpmsg_minor_ida, MINOR(dev->devt));\r\nfree_ctrldev:\r\nput_device(dev);\r\nkfree(ctrldev);\r\nreturn ret;\r\n}\r\nstatic void rpmsg_chrdev_remove(struct rpmsg_device *rpdev)\r\n{\r\nstruct rpmsg_ctrldev *ctrldev = dev_get_drvdata(&rpdev->dev);\r\nint ret;\r\nret = device_for_each_child(&ctrldev->dev, NULL, rpmsg_eptdev_destroy);\r\nif (ret)\r\ndev_warn(&rpdev->dev, "failed to nuke endpoints: %d\n", ret);\r\ndevice_del(&ctrldev->dev);\r\nput_device(&ctrldev->dev);\r\n}\r\nstatic int rpmsg_char_init(void)\r\n{\r\nint ret;\r\nret = alloc_chrdev_region(&rpmsg_major, 0, RPMSG_DEV_MAX, "rpmsg");\r\nif (ret < 0) {\r\npr_err("rpmsg: failed to allocate char dev region\n");\r\nreturn ret;\r\n}\r\nrpmsg_class = class_create(THIS_MODULE, "rpmsg");\r\nif (IS_ERR(rpmsg_class)) {\r\npr_err("failed to create rpmsg class\n");\r\nunregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);\r\nreturn PTR_ERR(rpmsg_class);\r\n}\r\nret = register_rpmsg_driver(&rpmsg_chrdev_driver);\r\nif (ret < 0) {\r\npr_err("rpmsgchr: failed to register rpmsg driver\n");\r\nclass_destroy(rpmsg_class);\r\nunregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);\r\n}\r\nreturn ret;\r\n}\r\nstatic void rpmsg_chrdev_exit(void)\r\n{\r\nunregister_rpmsg_driver(&rpmsg_chrdev_driver);\r\nclass_destroy(rpmsg_class);\r\nunregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);\r\n}
