static bool hp03_is_writeable_reg(struct device *dev, unsigned int reg)\r\n{\r\nreturn false;\r\n}\r\nstatic bool hp03_is_volatile_reg(struct device *dev, unsigned int reg)\r\n{\r\nreturn false;\r\n}\r\nstatic int hp03_get_temp_pressure(struct hp03_priv *priv, const u8 reg)\r\n{\r\nint ret;\r\nret = i2c_smbus_write_byte_data(priv->client, HP03_ADC_WRITE_REG, reg);\r\nif (ret < 0)\r\nreturn ret;\r\nmsleep(50);\r\nreturn i2c_smbus_read_word_data(priv->client, HP03_ADC_READ_REG);\r\n}\r\nstatic int hp03_update_temp_pressure(struct hp03_priv *priv)\r\n{\r\nstruct device *dev = &priv->client->dev;\r\nu8 coefs[18];\r\nu16 cx_val[7];\r\nint ab_val, d1_val, d2_val, diff_val, dut, off, sens, x;\r\nint i, ret;\r\nret = regmap_bulk_read(priv->eeprom_regmap, HP03_EEPROM_CX_OFFSET,\r\ncoefs, sizeof(coefs));\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to read EEPROM (reg=%02x)\n",\r\nHP03_EEPROM_CX_OFFSET);\r\nreturn ret;\r\n}\r\ngpiod_set_value_cansleep(priv->xclr_gpio, 1);\r\nret = hp03_get_temp_pressure(priv, HP03_ADC_READ_PRESSURE);\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to read pressure\n");\r\ngoto err_adc;\r\n}\r\nd1_val = ret;\r\nret = hp03_get_temp_pressure(priv, HP03_ADC_READ_TEMP);\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to read temperature\n");\r\ngoto err_adc;\r\n}\r\nd2_val = ret;\r\ngpiod_set_value_cansleep(priv->xclr_gpio, 0);\r\nfor (i = 0; i < 7; i++)\r\ncx_val[i] = (coefs[2 * i] << 8) | (coefs[(2 * i) + 1] << 0);\r\nd1_val = ((d1_val >> 8) & 0xff) | ((d1_val & 0xff) << 8);\r\nd2_val = ((d2_val >> 8) & 0xff) | ((d2_val & 0xff) << 8);\r\nif (d2_val >= cx_val[4])\r\nab_val = coefs[14];\r\nelse\r\nab_val = coefs[15];\r\ndiff_val = d2_val - cx_val[4];\r\ndut = (ab_val * (diff_val >> 7) * (diff_val >> 7)) >> coefs[16];\r\ndut = diff_val - dut;\r\noff = (cx_val[1] + (((cx_val[3] - 1024) * dut) >> 14)) * 4;\r\nsens = cx_val[0] + ((cx_val[2] * dut) >> 10);\r\nx = ((sens * (d1_val - 7168)) >> 14) - off;\r\npriv->pressure = ((x * 100) >> 5) + (cx_val[6] * 10);\r\npriv->temp = 250 + ((dut * cx_val[5]) >> 16) - (dut >> coefs[17]);\r\nreturn 0;\r\nerr_adc:\r\ngpiod_set_value_cansleep(priv->xclr_gpio, 0);\r\nreturn ret;\r\n}\r\nstatic int hp03_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2, long mask)\r\n{\r\nstruct hp03_priv *priv = iio_priv(indio_dev);\r\nint ret;\r\nmutex_lock(&priv->lock);\r\nret = hp03_update_temp_pressure(priv);\r\nmutex_unlock(&priv->lock);\r\nif (ret)\r\nreturn ret;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nswitch (chan->type) {\r\ncase IIO_PRESSURE:\r\n*val = priv->pressure;\r\nreturn IIO_VAL_INT;\r\ncase IIO_TEMP:\r\n*val = priv->temp;\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase IIO_CHAN_INFO_SCALE:\r\nswitch (chan->type) {\r\ncase IIO_PRESSURE:\r\n*val = 0;\r\n*val2 = 1000;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ncase IIO_TEMP:\r\n*val = 10;\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int hp03_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &client->dev;\r\nstruct iio_dev *indio_dev;\r\nstruct hp03_priv *priv;\r\nint ret;\r\nindio_dev = devm_iio_device_alloc(dev, sizeof(*priv));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\npriv = iio_priv(indio_dev);\r\npriv->client = client;\r\nmutex_init(&priv->lock);\r\nindio_dev->dev.parent = dev;\r\nindio_dev->name = id->name;\r\nindio_dev->channels = hp03_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(hp03_channels);\r\nindio_dev->info = &hp03_info;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\npriv->xclr_gpio = devm_gpiod_get_index(dev, "xclr", 0, GPIOD_OUT_HIGH);\r\nif (IS_ERR(priv->xclr_gpio)) {\r\ndev_err(dev, "Failed to claim XCLR GPIO\n");\r\nret = PTR_ERR(priv->xclr_gpio);\r\nreturn ret;\r\n}\r\npriv->eeprom_client = i2c_new_dummy(client->adapter, HP03_EEPROM_ADDR);\r\nif (!priv->eeprom_client) {\r\ndev_err(dev, "New EEPROM I2C device failed\n");\r\nreturn -ENODEV;\r\n}\r\npriv->eeprom_regmap = regmap_init_i2c(priv->eeprom_client,\r\n&hp03_regmap_config);\r\nif (IS_ERR(priv->eeprom_regmap)) {\r\ndev_err(dev, "Failed to allocate EEPROM regmap\n");\r\nret = PTR_ERR(priv->eeprom_regmap);\r\ngoto err_cleanup_eeprom_client;\r\n}\r\nret = iio_device_register(indio_dev);\r\nif (ret) {\r\ndev_err(dev, "Failed to register IIO device\n");\r\ngoto err_cleanup_eeprom_regmap;\r\n}\r\ni2c_set_clientdata(client, indio_dev);\r\nreturn 0;\r\nerr_cleanup_eeprom_regmap:\r\nregmap_exit(priv->eeprom_regmap);\r\nerr_cleanup_eeprom_client:\r\ni2c_unregister_device(priv->eeprom_client);\r\nreturn ret;\r\n}\r\nstatic int hp03_remove(struct i2c_client *client)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(client);\r\nstruct hp03_priv *priv = iio_priv(indio_dev);\r\niio_device_unregister(indio_dev);\r\nregmap_exit(priv->eeprom_regmap);\r\ni2c_unregister_device(priv->eeprom_client);\r\nreturn 0;\r\n}
