static ssize_t id_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct dax_region *dax_region = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", dax_region->id);\r\n}\r\nstatic ssize_t region_size_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct dax_region *dax_region = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%llu\n", (unsigned long long)\r\nresource_size(&dax_region->res));\r\n}\r\nstatic ssize_t align_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct dax_region *dax_region = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%u\n", dax_region->align);\r\n}\r\nstatic void dax_region_free(struct kref *kref)\r\n{\r\nstruct dax_region *dax_region;\r\ndax_region = container_of(kref, struct dax_region, kref);\r\nkfree(dax_region);\r\n}\r\nvoid dax_region_put(struct dax_region *dax_region)\r\n{\r\nkref_put(&dax_region->kref, dax_region_free);\r\n}\r\nstatic void dax_region_unregister(void *region)\r\n{\r\nstruct dax_region *dax_region = region;\r\nsysfs_remove_groups(&dax_region->dev->kobj,\r\ndax_region_attribute_groups);\r\ndax_region_put(dax_region);\r\n}\r\nstruct dax_region *alloc_dax_region(struct device *parent, int region_id,\r\nstruct resource *res, unsigned int align, void *addr,\r\nunsigned long pfn_flags)\r\n{\r\nstruct dax_region *dax_region;\r\nif (dev_get_drvdata(parent)) {\r\ndev_WARN(parent, "dax core failed to setup private data\n");\r\nreturn NULL;\r\n}\r\nif (!IS_ALIGNED(res->start, align)\r\n|| !IS_ALIGNED(resource_size(res), align))\r\nreturn NULL;\r\ndax_region = kzalloc(sizeof(*dax_region), GFP_KERNEL);\r\nif (!dax_region)\r\nreturn NULL;\r\ndev_set_drvdata(parent, dax_region);\r\nmemcpy(&dax_region->res, res, sizeof(*res));\r\ndax_region->pfn_flags = pfn_flags;\r\nkref_init(&dax_region->kref);\r\ndax_region->id = region_id;\r\nida_init(&dax_region->ida);\r\ndax_region->align = align;\r\ndax_region->dev = parent;\r\ndax_region->base = addr;\r\nif (sysfs_create_groups(&parent->kobj, dax_region_attribute_groups)) {\r\nkfree(dax_region);\r\nreturn NULL;;\r\n}\r\nkref_get(&dax_region->kref);\r\nif (devm_add_action_or_reset(parent, dax_region_unregister, dax_region))\r\nreturn NULL;\r\nreturn dax_region;\r\n}\r\nstatic struct dev_dax *to_dev_dax(struct device *dev)\r\n{\r\nreturn container_of(dev, struct dev_dax, dev);\r\n}\r\nstatic ssize_t size_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct dev_dax *dev_dax = to_dev_dax(dev);\r\nunsigned long long size = 0;\r\nint i;\r\nfor (i = 0; i < dev_dax->num_resources; i++)\r\nsize += resource_size(&dev_dax->res[i]);\r\nreturn sprintf(buf, "%llu\n", size);\r\n}\r\nstatic int check_vma(struct dev_dax *dev_dax, struct vm_area_struct *vma,\r\nconst char *func)\r\n{\r\nstruct dax_region *dax_region = dev_dax->region;\r\nstruct device *dev = &dev_dax->dev;\r\nunsigned long mask;\r\nif (!dax_alive(dev_dax->dax_dev))\r\nreturn -ENXIO;\r\nif ((vma->vm_flags & VM_MAYSHARE) != VM_MAYSHARE) {\r\ndev_info(dev, "%s: %s: fail, attempted private mapping\n",\r\ncurrent->comm, func);\r\nreturn -EINVAL;\r\n}\r\nmask = dax_region->align - 1;\r\nif (vma->vm_start & mask || vma->vm_end & mask) {\r\ndev_info(dev, "%s: %s: fail, unaligned vma (%#lx - %#lx, %#lx)\n",\r\ncurrent->comm, func, vma->vm_start, vma->vm_end,\r\nmask);\r\nreturn -EINVAL;\r\n}\r\nif ((dax_region->pfn_flags & (PFN_DEV|PFN_MAP)) == PFN_DEV\r\n&& (vma->vm_flags & VM_DONTCOPY) == 0) {\r\ndev_info(dev, "%s: %s: fail, dax range requires MADV_DONTFORK\n",\r\ncurrent->comm, func);\r\nreturn -EINVAL;\r\n}\r\nif (!vma_is_dax(vma)) {\r\ndev_info(dev, "%s: %s: fail, vma is not DAX capable\n",\r\ncurrent->comm, func);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\n__weak phys_addr_t dax_pgoff_to_phys(struct dev_dax *dev_dax, pgoff_t pgoff,\r\nunsigned long size)\r\n{\r\nstruct resource *res;\r\nphys_addr_t phys;\r\nint i;\r\nfor (i = 0; i < dev_dax->num_resources; i++) {\r\nres = &dev_dax->res[i];\r\nphys = pgoff * PAGE_SIZE + res->start;\r\nif (phys >= res->start && phys <= res->end)\r\nbreak;\r\npgoff -= PHYS_PFN(resource_size(res));\r\n}\r\nif (i < dev_dax->num_resources) {\r\nres = &dev_dax->res[i];\r\nif (phys + size - 1 <= res->end)\r\nreturn phys;\r\n}\r\nreturn -1;\r\n}\r\nstatic int __dev_dax_pte_fault(struct dev_dax *dev_dax, struct vm_fault *vmf)\r\n{\r\nstruct device *dev = &dev_dax->dev;\r\nstruct dax_region *dax_region;\r\nint rc = VM_FAULT_SIGBUS;\r\nphys_addr_t phys;\r\npfn_t pfn;\r\nunsigned int fault_size = PAGE_SIZE;\r\nif (check_vma(dev_dax, vmf->vma, __func__))\r\nreturn VM_FAULT_SIGBUS;\r\ndax_region = dev_dax->region;\r\nif (dax_region->align > PAGE_SIZE) {\r\ndev_dbg(dev, "%s: alignment (%#x) > fault size (%#x)\n",\r\n__func__, dax_region->align, fault_size);\r\nreturn VM_FAULT_SIGBUS;\r\n}\r\nif (fault_size != dax_region->align)\r\nreturn VM_FAULT_SIGBUS;\r\nphys = dax_pgoff_to_phys(dev_dax, vmf->pgoff, PAGE_SIZE);\r\nif (phys == -1) {\r\ndev_dbg(dev, "%s: pgoff_to_phys(%#lx) failed\n", __func__,\r\nvmf->pgoff);\r\nreturn VM_FAULT_SIGBUS;\r\n}\r\npfn = phys_to_pfn_t(phys, dax_region->pfn_flags);\r\nrc = vm_insert_mixed(vmf->vma, vmf->address, pfn);\r\nif (rc == -ENOMEM)\r\nreturn VM_FAULT_OOM;\r\nif (rc < 0 && rc != -EBUSY)\r\nreturn VM_FAULT_SIGBUS;\r\nreturn VM_FAULT_NOPAGE;\r\n}\r\nstatic int __dev_dax_pmd_fault(struct dev_dax *dev_dax, struct vm_fault *vmf)\r\n{\r\nunsigned long pmd_addr = vmf->address & PMD_MASK;\r\nstruct device *dev = &dev_dax->dev;\r\nstruct dax_region *dax_region;\r\nphys_addr_t phys;\r\npgoff_t pgoff;\r\npfn_t pfn;\r\nunsigned int fault_size = PMD_SIZE;\r\nif (check_vma(dev_dax, vmf->vma, __func__))\r\nreturn VM_FAULT_SIGBUS;\r\ndax_region = dev_dax->region;\r\nif (dax_region->align > PMD_SIZE) {\r\ndev_dbg(dev, "%s: alignment (%#x) > fault size (%#x)\n",\r\n__func__, dax_region->align, fault_size);\r\nreturn VM_FAULT_SIGBUS;\r\n}\r\nif ((dax_region->pfn_flags & (PFN_DEV|PFN_MAP)) != (PFN_DEV|PFN_MAP)) {\r\ndev_dbg(dev, "%s: region lacks devmap flags\n", __func__);\r\nreturn VM_FAULT_SIGBUS;\r\n}\r\nif (fault_size < dax_region->align)\r\nreturn VM_FAULT_SIGBUS;\r\nelse if (fault_size > dax_region->align)\r\nreturn VM_FAULT_FALLBACK;\r\nif (pmd_addr < vmf->vma->vm_start ||\r\n(pmd_addr + PMD_SIZE) > vmf->vma->vm_end)\r\nreturn VM_FAULT_SIGBUS;\r\npgoff = linear_page_index(vmf->vma, pmd_addr);\r\nphys = dax_pgoff_to_phys(dev_dax, pgoff, PMD_SIZE);\r\nif (phys == -1) {\r\ndev_dbg(dev, "%s: pgoff_to_phys(%#lx) failed\n", __func__,\r\npgoff);\r\nreturn VM_FAULT_SIGBUS;\r\n}\r\npfn = phys_to_pfn_t(phys, dax_region->pfn_flags);\r\nreturn vmf_insert_pfn_pmd(vmf->vma, vmf->address, vmf->pmd, pfn,\r\nvmf->flags & FAULT_FLAG_WRITE);\r\n}\r\nstatic int __dev_dax_pud_fault(struct dev_dax *dev_dax, struct vm_fault *vmf)\r\n{\r\nunsigned long pud_addr = vmf->address & PUD_MASK;\r\nstruct device *dev = &dev_dax->dev;\r\nstruct dax_region *dax_region;\r\nphys_addr_t phys;\r\npgoff_t pgoff;\r\npfn_t pfn;\r\nunsigned int fault_size = PUD_SIZE;\r\nif (check_vma(dev_dax, vmf->vma, __func__))\r\nreturn VM_FAULT_SIGBUS;\r\ndax_region = dev_dax->region;\r\nif (dax_region->align > PUD_SIZE) {\r\ndev_dbg(dev, "%s: alignment (%#x) > fault size (%#x)\n",\r\n__func__, dax_region->align, fault_size);\r\nreturn VM_FAULT_SIGBUS;\r\n}\r\nif ((dax_region->pfn_flags & (PFN_DEV|PFN_MAP)) != (PFN_DEV|PFN_MAP)) {\r\ndev_dbg(dev, "%s: region lacks devmap flags\n", __func__);\r\nreturn VM_FAULT_SIGBUS;\r\n}\r\nif (fault_size < dax_region->align)\r\nreturn VM_FAULT_SIGBUS;\r\nelse if (fault_size > dax_region->align)\r\nreturn VM_FAULT_FALLBACK;\r\nif (pud_addr < vmf->vma->vm_start ||\r\n(pud_addr + PUD_SIZE) > vmf->vma->vm_end)\r\nreturn VM_FAULT_SIGBUS;\r\npgoff = linear_page_index(vmf->vma, pud_addr);\r\nphys = dax_pgoff_to_phys(dev_dax, pgoff, PUD_SIZE);\r\nif (phys == -1) {\r\ndev_dbg(dev, "%s: pgoff_to_phys(%#lx) failed\n", __func__,\r\npgoff);\r\nreturn VM_FAULT_SIGBUS;\r\n}\r\npfn = phys_to_pfn_t(phys, dax_region->pfn_flags);\r\nreturn vmf_insert_pfn_pud(vmf->vma, vmf->address, vmf->pud, pfn,\r\nvmf->flags & FAULT_FLAG_WRITE);\r\n}\r\nstatic int __dev_dax_pud_fault(struct dev_dax *dev_dax, struct vm_fault *vmf)\r\n{\r\nreturn VM_FAULT_FALLBACK;\r\n}\r\nstatic int dev_dax_huge_fault(struct vm_fault *vmf,\r\nenum page_entry_size pe_size)\r\n{\r\nint rc, id;\r\nstruct file *filp = vmf->vma->vm_file;\r\nstruct dev_dax *dev_dax = filp->private_data;\r\ndev_dbg(&dev_dax->dev, "%s: %s: %s (%#lx - %#lx) size = %d\n", __func__,\r\ncurrent->comm, (vmf->flags & FAULT_FLAG_WRITE)\r\n? "write" : "read",\r\nvmf->vma->vm_start, vmf->vma->vm_end, pe_size);\r\nid = dax_read_lock();\r\nswitch (pe_size) {\r\ncase PE_SIZE_PTE:\r\nrc = __dev_dax_pte_fault(dev_dax, vmf);\r\nbreak;\r\ncase PE_SIZE_PMD:\r\nrc = __dev_dax_pmd_fault(dev_dax, vmf);\r\nbreak;\r\ncase PE_SIZE_PUD:\r\nrc = __dev_dax_pud_fault(dev_dax, vmf);\r\nbreak;\r\ndefault:\r\nrc = VM_FAULT_SIGBUS;\r\n}\r\ndax_read_unlock(id);\r\nreturn rc;\r\n}\r\nstatic int dev_dax_fault(struct vm_fault *vmf)\r\n{\r\nreturn dev_dax_huge_fault(vmf, PE_SIZE_PTE);\r\n}\r\nstatic int dax_mmap(struct file *filp, struct vm_area_struct *vma)\r\n{\r\nstruct dev_dax *dev_dax = filp->private_data;\r\nint rc, id;\r\ndev_dbg(&dev_dax->dev, "%s\n", __func__);\r\nid = dax_read_lock();\r\nrc = check_vma(dev_dax, vma, __func__);\r\ndax_read_unlock(id);\r\nif (rc)\r\nreturn rc;\r\nvma->vm_ops = &dax_vm_ops;\r\nvma->vm_flags |= VM_MIXEDMAP | VM_HUGEPAGE;\r\nreturn 0;\r\n}\r\nstatic unsigned long dax_get_unmapped_area(struct file *filp,\r\nunsigned long addr, unsigned long len, unsigned long pgoff,\r\nunsigned long flags)\r\n{\r\nunsigned long off, off_end, off_align, len_align, addr_align, align;\r\nstruct dev_dax *dev_dax = filp ? filp->private_data : NULL;\r\nstruct dax_region *dax_region;\r\nif (!dev_dax || addr)\r\ngoto out;\r\ndax_region = dev_dax->region;\r\nalign = dax_region->align;\r\noff = pgoff << PAGE_SHIFT;\r\noff_end = off + len;\r\noff_align = round_up(off, align);\r\nif ((off_end <= off_align) || ((off_end - off_align) < align))\r\ngoto out;\r\nlen_align = len + align;\r\nif ((off + len_align) < off)\r\ngoto out;\r\naddr_align = current->mm->get_unmapped_area(filp, addr, len_align,\r\npgoff, flags);\r\nif (!IS_ERR_VALUE(addr_align)) {\r\naddr_align += (off - addr_align) & (align - 1);\r\nreturn addr_align;\r\n}\r\nout:\r\nreturn current->mm->get_unmapped_area(filp, addr, len, pgoff, flags);\r\n}\r\nstatic int dax_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct dax_device *dax_dev = inode_dax(inode);\r\nstruct inode *__dax_inode = dax_inode(dax_dev);\r\nstruct dev_dax *dev_dax = dax_get_private(dax_dev);\r\ndev_dbg(&dev_dax->dev, "%s\n", __func__);\r\ninode->i_mapping = __dax_inode->i_mapping;\r\ninode->i_mapping->host = __dax_inode;\r\nfilp->f_mapping = inode->i_mapping;\r\nfilp->f_wb_err = filemap_sample_wb_err(filp->f_mapping);\r\nfilp->private_data = dev_dax;\r\ninode->i_flags = S_DAX;\r\nreturn 0;\r\n}\r\nstatic int dax_release(struct inode *inode, struct file *filp)\r\n{\r\nstruct dev_dax *dev_dax = filp->private_data;\r\ndev_dbg(&dev_dax->dev, "%s\n", __func__);\r\nreturn 0;\r\n}\r\nstatic void dev_dax_release(struct device *dev)\r\n{\r\nstruct dev_dax *dev_dax = to_dev_dax(dev);\r\nstruct dax_region *dax_region = dev_dax->region;\r\nstruct dax_device *dax_dev = dev_dax->dax_dev;\r\nif (dev_dax->id >= 0)\r\nida_simple_remove(&dax_region->ida, dev_dax->id);\r\ndax_region_put(dax_region);\r\nput_dax(dax_dev);\r\nkfree(dev_dax);\r\n}\r\nstatic void kill_dev_dax(struct dev_dax *dev_dax)\r\n{\r\nstruct dax_device *dax_dev = dev_dax->dax_dev;\r\nstruct inode *inode = dax_inode(dax_dev);\r\nkill_dax(dax_dev);\r\nunmap_mapping_range(inode->i_mapping, 0, 0, 1);\r\n}\r\nstatic void unregister_dev_dax(void *dev)\r\n{\r\nstruct dev_dax *dev_dax = to_dev_dax(dev);\r\nstruct dax_device *dax_dev = dev_dax->dax_dev;\r\nstruct inode *inode = dax_inode(dax_dev);\r\nstruct cdev *cdev = inode->i_cdev;\r\ndev_dbg(dev, "%s\n", __func__);\r\nkill_dev_dax(dev_dax);\r\ncdev_device_del(cdev, dev);\r\nput_device(dev);\r\n}\r\nstruct dev_dax *devm_create_dev_dax(struct dax_region *dax_region,\r\nint id, struct resource *res, int count)\r\n{\r\nstruct device *parent = dax_region->dev;\r\nstruct dax_device *dax_dev;\r\nstruct dev_dax *dev_dax;\r\nstruct inode *inode;\r\nstruct device *dev;\r\nstruct cdev *cdev;\r\nint rc, i;\r\nif (!count)\r\nreturn ERR_PTR(-EINVAL);\r\ndev_dax = kzalloc(sizeof(*dev_dax) + sizeof(*res) * count, GFP_KERNEL);\r\nif (!dev_dax)\r\nreturn ERR_PTR(-ENOMEM);\r\nfor (i = 0; i < count; i++) {\r\nif (!IS_ALIGNED(res[i].start, dax_region->align)\r\n|| !IS_ALIGNED(resource_size(&res[i]),\r\ndax_region->align)) {\r\nrc = -EINVAL;\r\nbreak;\r\n}\r\ndev_dax->res[i].start = res[i].start;\r\ndev_dax->res[i].end = res[i].end;\r\n}\r\nif (i < count)\r\ngoto err_id;\r\nif (id < 0) {\r\nid = ida_simple_get(&dax_region->ida, 0, 0, GFP_KERNEL);\r\ndev_dax->id = id;\r\nif (id < 0) {\r\nrc = id;\r\ngoto err_id;\r\n}\r\n} else {\r\ndev_dax->id = -1;\r\n}\r\ndax_dev = alloc_dax(dev_dax, NULL, NULL);\r\nif (!dax_dev) {\r\nrc = -ENOMEM;\r\ngoto err_dax;\r\n}\r\ndev = &dev_dax->dev;\r\ndevice_initialize(dev);\r\ninode = dax_inode(dax_dev);\r\ncdev = inode->i_cdev;\r\ncdev_init(cdev, &dax_fops);\r\ncdev->owner = parent->driver->owner;\r\ndev_dax->num_resources = count;\r\ndev_dax->dax_dev = dax_dev;\r\ndev_dax->region = dax_region;\r\nkref_get(&dax_region->kref);\r\ndev->devt = inode->i_rdev;\r\ndev->class = dax_class;\r\ndev->parent = parent;\r\ndev->groups = dax_attribute_groups;\r\ndev->release = dev_dax_release;\r\ndev_set_name(dev, "dax%d.%d", dax_region->id, id);\r\nrc = cdev_device_add(cdev, dev);\r\nif (rc) {\r\nkill_dev_dax(dev_dax);\r\nput_device(dev);\r\nreturn ERR_PTR(rc);\r\n}\r\nrc = devm_add_action_or_reset(dax_region->dev, unregister_dev_dax, dev);\r\nif (rc)\r\nreturn ERR_PTR(rc);\r\nreturn dev_dax;\r\nerr_dax:\r\nif (dev_dax->id >= 0)\r\nida_simple_remove(&dax_region->ida, dev_dax->id);\r\nerr_id:\r\nkfree(dev_dax);\r\nreturn ERR_PTR(rc);\r\n}\r\nstatic int __init dax_init(void)\r\n{\r\ndax_class = class_create(THIS_MODULE, "dax");\r\nreturn PTR_ERR_OR_ZERO(dax_class);\r\n}\r\nstatic void __exit dax_exit(void)\r\n{\r\nclass_destroy(dax_class);\r\n}
