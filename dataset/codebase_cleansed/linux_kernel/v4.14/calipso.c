static void calipso_cache_entry_free(struct calipso_map_cache_entry *entry)\r\n{\r\nif (entry->lsm_data)\r\nnetlbl_secattr_cache_free(entry->lsm_data);\r\nkfree(entry->key);\r\nkfree(entry);\r\n}\r\nstatic u32 calipso_map_cache_hash(const unsigned char *key, u32 key_len)\r\n{\r\nreturn jhash(key, key_len, 0);\r\n}\r\nstatic int __init calipso_cache_init(void)\r\n{\r\nu32 iter;\r\ncalipso_cache = kcalloc(CALIPSO_CACHE_BUCKETS,\r\nsizeof(struct calipso_map_cache_bkt),\r\nGFP_KERNEL);\r\nif (!calipso_cache)\r\nreturn -ENOMEM;\r\nfor (iter = 0; iter < CALIPSO_CACHE_BUCKETS; iter++) {\r\nspin_lock_init(&calipso_cache[iter].lock);\r\ncalipso_cache[iter].size = 0;\r\nINIT_LIST_HEAD(&calipso_cache[iter].list);\r\n}\r\nreturn 0;\r\n}\r\nstatic void calipso_cache_invalidate(void)\r\n{\r\nstruct calipso_map_cache_entry *entry, *tmp_entry;\r\nu32 iter;\r\nfor (iter = 0; iter < CALIPSO_CACHE_BUCKETS; iter++) {\r\nspin_lock_bh(&calipso_cache[iter].lock);\r\nlist_for_each_entry_safe(entry,\r\ntmp_entry,\r\n&calipso_cache[iter].list, list) {\r\nlist_del(&entry->list);\r\ncalipso_cache_entry_free(entry);\r\n}\r\ncalipso_cache[iter].size = 0;\r\nspin_unlock_bh(&calipso_cache[iter].lock);\r\n}\r\n}\r\nstatic int calipso_cache_check(const unsigned char *key,\r\nu32 key_len,\r\nstruct netlbl_lsm_secattr *secattr)\r\n{\r\nu32 bkt;\r\nstruct calipso_map_cache_entry *entry;\r\nstruct calipso_map_cache_entry *prev_entry = NULL;\r\nu32 hash;\r\nif (!calipso_cache_enabled)\r\nreturn -ENOENT;\r\nhash = calipso_map_cache_hash(key, key_len);\r\nbkt = hash & (CALIPSO_CACHE_BUCKETS - 1);\r\nspin_lock_bh(&calipso_cache[bkt].lock);\r\nlist_for_each_entry(entry, &calipso_cache[bkt].list, list) {\r\nif (entry->hash == hash &&\r\nentry->key_len == key_len &&\r\nmemcmp(entry->key, key, key_len) == 0) {\r\nentry->activity += 1;\r\nrefcount_inc(&entry->lsm_data->refcount);\r\nsecattr->cache = entry->lsm_data;\r\nsecattr->flags |= NETLBL_SECATTR_CACHE;\r\nsecattr->type = NETLBL_NLTYPE_CALIPSO;\r\nif (!prev_entry) {\r\nspin_unlock_bh(&calipso_cache[bkt].lock);\r\nreturn 0;\r\n}\r\nif (prev_entry->activity > 0)\r\nprev_entry->activity -= 1;\r\nif (entry->activity > prev_entry->activity &&\r\nentry->activity - prev_entry->activity >\r\nCALIPSO_CACHE_REORDERLIMIT) {\r\n__list_del(entry->list.prev, entry->list.next);\r\n__list_add(&entry->list,\r\nprev_entry->list.prev,\r\n&prev_entry->list);\r\n}\r\nspin_unlock_bh(&calipso_cache[bkt].lock);\r\nreturn 0;\r\n}\r\nprev_entry = entry;\r\n}\r\nspin_unlock_bh(&calipso_cache[bkt].lock);\r\nreturn -ENOENT;\r\n}\r\nstatic int calipso_cache_add(const unsigned char *calipso_ptr,\r\nconst struct netlbl_lsm_secattr *secattr)\r\n{\r\nint ret_val = -EPERM;\r\nu32 bkt;\r\nstruct calipso_map_cache_entry *entry = NULL;\r\nstruct calipso_map_cache_entry *old_entry = NULL;\r\nu32 calipso_ptr_len;\r\nif (!calipso_cache_enabled || calipso_cache_bucketsize <= 0)\r\nreturn 0;\r\ncalipso_ptr_len = calipso_ptr[1];\r\nentry = kzalloc(sizeof(*entry), GFP_ATOMIC);\r\nif (!entry)\r\nreturn -ENOMEM;\r\nentry->key = kmemdup(calipso_ptr + 2, calipso_ptr_len, GFP_ATOMIC);\r\nif (!entry->key) {\r\nret_val = -ENOMEM;\r\ngoto cache_add_failure;\r\n}\r\nentry->key_len = calipso_ptr_len;\r\nentry->hash = calipso_map_cache_hash(calipso_ptr, calipso_ptr_len);\r\nrefcount_inc(&secattr->cache->refcount);\r\nentry->lsm_data = secattr->cache;\r\nbkt = entry->hash & (CALIPSO_CACHE_BUCKETS - 1);\r\nspin_lock_bh(&calipso_cache[bkt].lock);\r\nif (calipso_cache[bkt].size < calipso_cache_bucketsize) {\r\nlist_add(&entry->list, &calipso_cache[bkt].list);\r\ncalipso_cache[bkt].size += 1;\r\n} else {\r\nold_entry = list_entry(calipso_cache[bkt].list.prev,\r\nstruct calipso_map_cache_entry, list);\r\nlist_del(&old_entry->list);\r\nlist_add(&entry->list, &calipso_cache[bkt].list);\r\ncalipso_cache_entry_free(old_entry);\r\n}\r\nspin_unlock_bh(&calipso_cache[bkt].lock);\r\nreturn 0;\r\ncache_add_failure:\r\nif (entry)\r\ncalipso_cache_entry_free(entry);\r\nreturn ret_val;\r\n}\r\nstatic struct calipso_doi *calipso_doi_search(u32 doi)\r\n{\r\nstruct calipso_doi *iter;\r\nlist_for_each_entry_rcu(iter, &calipso_doi_list, list)\r\nif (iter->doi == doi && refcount_read(&iter->refcount))\r\nreturn iter;\r\nreturn NULL;\r\n}\r\nstatic int calipso_doi_add(struct calipso_doi *doi_def,\r\nstruct netlbl_audit *audit_info)\r\n{\r\nint ret_val = -EINVAL;\r\nu32 doi;\r\nu32 doi_type;\r\nstruct audit_buffer *audit_buf;\r\ndoi = doi_def->doi;\r\ndoi_type = doi_def->type;\r\nif (doi_def->doi == CALIPSO_DOI_UNKNOWN)\r\ngoto doi_add_return;\r\nrefcount_set(&doi_def->refcount, 1);\r\nspin_lock(&calipso_doi_list_lock);\r\nif (calipso_doi_search(doi_def->doi)) {\r\nspin_unlock(&calipso_doi_list_lock);\r\nret_val = -EEXIST;\r\ngoto doi_add_return;\r\n}\r\nlist_add_tail_rcu(&doi_def->list, &calipso_doi_list);\r\nspin_unlock(&calipso_doi_list_lock);\r\nret_val = 0;\r\ndoi_add_return:\r\naudit_buf = netlbl_audit_start(AUDIT_MAC_CALIPSO_ADD, audit_info);\r\nif (audit_buf) {\r\nconst char *type_str;\r\nswitch (doi_type) {\r\ncase CALIPSO_MAP_PASS:\r\ntype_str = "pass";\r\nbreak;\r\ndefault:\r\ntype_str = "(unknown)";\r\n}\r\naudit_log_format(audit_buf,\r\n" calipso_doi=%u calipso_type=%s res=%u",\r\ndoi, type_str, ret_val == 0 ? 1 : 0);\r\naudit_log_end(audit_buf);\r\n}\r\nreturn ret_val;\r\n}\r\nstatic void calipso_doi_free(struct calipso_doi *doi_def)\r\n{\r\nkfree(doi_def);\r\n}\r\nstatic void calipso_doi_free_rcu(struct rcu_head *entry)\r\n{\r\nstruct calipso_doi *doi_def;\r\ndoi_def = container_of(entry, struct calipso_doi, rcu);\r\ncalipso_doi_free(doi_def);\r\n}\r\nstatic int calipso_doi_remove(u32 doi, struct netlbl_audit *audit_info)\r\n{\r\nint ret_val;\r\nstruct calipso_doi *doi_def;\r\nstruct audit_buffer *audit_buf;\r\nspin_lock(&calipso_doi_list_lock);\r\ndoi_def = calipso_doi_search(doi);\r\nif (!doi_def) {\r\nspin_unlock(&calipso_doi_list_lock);\r\nret_val = -ENOENT;\r\ngoto doi_remove_return;\r\n}\r\nif (!refcount_dec_and_test(&doi_def->refcount)) {\r\nspin_unlock(&calipso_doi_list_lock);\r\nret_val = -EBUSY;\r\ngoto doi_remove_return;\r\n}\r\nlist_del_rcu(&doi_def->list);\r\nspin_unlock(&calipso_doi_list_lock);\r\ncall_rcu(&doi_def->rcu, calipso_doi_free_rcu);\r\nret_val = 0;\r\ndoi_remove_return:\r\naudit_buf = netlbl_audit_start(AUDIT_MAC_CALIPSO_DEL, audit_info);\r\nif (audit_buf) {\r\naudit_log_format(audit_buf,\r\n" calipso_doi=%u res=%u",\r\ndoi, ret_val == 0 ? 1 : 0);\r\naudit_log_end(audit_buf);\r\n}\r\nreturn ret_val;\r\n}\r\nstatic struct calipso_doi *calipso_doi_getdef(u32 doi)\r\n{\r\nstruct calipso_doi *doi_def;\r\nrcu_read_lock();\r\ndoi_def = calipso_doi_search(doi);\r\nif (!doi_def)\r\ngoto doi_getdef_return;\r\nif (!refcount_inc_not_zero(&doi_def->refcount))\r\ndoi_def = NULL;\r\ndoi_getdef_return:\r\nrcu_read_unlock();\r\nreturn doi_def;\r\n}\r\nstatic void calipso_doi_putdef(struct calipso_doi *doi_def)\r\n{\r\nif (!doi_def)\r\nreturn;\r\nif (!refcount_dec_and_test(&doi_def->refcount))\r\nreturn;\r\nspin_lock(&calipso_doi_list_lock);\r\nlist_del_rcu(&doi_def->list);\r\nspin_unlock(&calipso_doi_list_lock);\r\ncall_rcu(&doi_def->rcu, calipso_doi_free_rcu);\r\n}\r\nstatic int calipso_doi_walk(u32 *skip_cnt,\r\nint (*callback)(struct calipso_doi *doi_def,\r\nvoid *arg),\r\nvoid *cb_arg)\r\n{\r\nint ret_val = -ENOENT;\r\nu32 doi_cnt = 0;\r\nstruct calipso_doi *iter_doi;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(iter_doi, &calipso_doi_list, list)\r\nif (refcount_read(&iter_doi->refcount) > 0) {\r\nif (doi_cnt++ < *skip_cnt)\r\ncontinue;\r\nret_val = callback(iter_doi, cb_arg);\r\nif (ret_val < 0) {\r\ndoi_cnt--;\r\ngoto doi_walk_return;\r\n}\r\n}\r\ndoi_walk_return:\r\nrcu_read_unlock();\r\n*skip_cnt = doi_cnt;\r\nreturn ret_val;\r\n}\r\nbool calipso_validate(const struct sk_buff *skb, const unsigned char *option)\r\n{\r\nstruct calipso_doi *doi_def;\r\nbool ret_val;\r\nu16 crc, len = option[1] + 2;\r\nstatic const u8 zero[2];\r\ncrc = crc_ccitt(0xffff, option, 8);\r\ncrc = crc_ccitt(crc, zero, sizeof(zero));\r\nif (len > 10)\r\ncrc = crc_ccitt(crc, option + 10, len - 10);\r\ncrc = ~crc;\r\nif (option[8] != (crc & 0xff) || option[9] != ((crc >> 8) & 0xff))\r\nreturn false;\r\nrcu_read_lock();\r\ndoi_def = calipso_doi_search(get_unaligned_be32(option + 2));\r\nret_val = !!doi_def;\r\nrcu_read_unlock();\r\nreturn ret_val;\r\n}\r\nstatic int calipso_map_cat_hton(const struct calipso_doi *doi_def,\r\nconst struct netlbl_lsm_secattr *secattr,\r\nunsigned char *net_cat,\r\nu32 net_cat_len)\r\n{\r\nint spot = -1;\r\nu32 net_spot_max = 0;\r\nu32 net_clen_bits = net_cat_len * 8;\r\nfor (;;) {\r\nspot = netlbl_catmap_walk(secattr->attr.mls.cat,\r\nspot + 1);\r\nif (spot < 0)\r\nbreak;\r\nif (spot >= net_clen_bits)\r\nreturn -ENOSPC;\r\nnetlbl_bitmap_setbit(net_cat, spot, 1);\r\nif (spot > net_spot_max)\r\nnet_spot_max = spot;\r\n}\r\nreturn (net_spot_max / 32 + 1) * 4;\r\n}\r\nstatic int calipso_map_cat_ntoh(const struct calipso_doi *doi_def,\r\nconst unsigned char *net_cat,\r\nu32 net_cat_len,\r\nstruct netlbl_lsm_secattr *secattr)\r\n{\r\nint ret_val;\r\nint spot = -1;\r\nu32 net_clen_bits = net_cat_len * 8;\r\nfor (;;) {\r\nspot = netlbl_bitmap_walk(net_cat,\r\nnet_clen_bits,\r\nspot + 1,\r\n1);\r\nif (spot < 0) {\r\nif (spot == -2)\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nret_val = netlbl_catmap_setbit(&secattr->attr.mls.cat,\r\nspot,\r\nGFP_ATOMIC);\r\nif (ret_val != 0)\r\nreturn ret_val;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int calipso_pad_write(unsigned char *buf, unsigned int offset,\r\nunsigned int count)\r\n{\r\nif (WARN_ON_ONCE(count >= 8))\r\nreturn -EINVAL;\r\nswitch (count) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\nbuf[offset] = IPV6_TLV_PAD1;\r\nbreak;\r\ndefault:\r\nbuf[offset] = IPV6_TLV_PADN;\r\nbuf[offset + 1] = count - 2;\r\nif (count > 2)\r\nmemset(buf + offset + 2, 0, count - 2);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int calipso_genopt(unsigned char *buf, u32 start, u32 buf_len,\r\nconst struct calipso_doi *doi_def,\r\nconst struct netlbl_lsm_secattr *secattr)\r\n{\r\nint ret_val;\r\nu32 len, pad;\r\nu16 crc;\r\nstatic const unsigned char padding[4] = {2, 1, 0, 3};\r\nunsigned char *calipso;\r\npad = padding[start & 3];\r\nif (buf_len <= start + pad + CALIPSO_HDR_LEN)\r\nreturn -ENOSPC;\r\nif ((secattr->flags & NETLBL_SECATTR_MLS_LVL) == 0)\r\nreturn -EPERM;\r\nlen = CALIPSO_HDR_LEN;\r\nif (secattr->flags & NETLBL_SECATTR_MLS_CAT) {\r\nret_val = calipso_map_cat_hton(doi_def,\r\nsecattr,\r\nbuf + start + pad + len,\r\nbuf_len - start - pad - len);\r\nif (ret_val < 0)\r\nreturn ret_val;\r\nlen += ret_val;\r\n}\r\ncalipso_pad_write(buf, start, pad);\r\ncalipso = buf + start + pad;\r\ncalipso[0] = IPV6_TLV_CALIPSO;\r\ncalipso[1] = len - 2;\r\n*(__be32 *)(calipso + 2) = htonl(doi_def->doi);\r\ncalipso[6] = (len - CALIPSO_HDR_LEN) / 4;\r\ncalipso[7] = secattr->attr.mls.lvl,\r\ncrc = ~crc_ccitt(0xffff, calipso, len);\r\ncalipso[8] = crc & 0xff;\r\ncalipso[9] = (crc >> 8) & 0xff;\r\nreturn pad + len;\r\n}\r\nstatic int calipso_opt_update(struct sock *sk, struct ipv6_opt_hdr *hop)\r\n{\r\nstruct ipv6_txoptions *old = txopt_get(inet6_sk(sk)), *txopts;\r\ntxopts = ipv6_renew_options_kern(sk, old, IPV6_HOPOPTS,\r\nhop, hop ? ipv6_optlen(hop) : 0);\r\ntxopt_put(old);\r\nif (IS_ERR(txopts))\r\nreturn PTR_ERR(txopts);\r\ntxopts = ipv6_update_options(sk, txopts);\r\nif (txopts) {\r\natomic_sub(txopts->tot_len, &sk->sk_omem_alloc);\r\ntxopt_put(txopts);\r\n}\r\nreturn 0;\r\n}\r\nstatic int calipso_tlv_len(struct ipv6_opt_hdr *opt, unsigned int offset)\r\n{\r\nunsigned char *tlv = (unsigned char *)opt;\r\nunsigned int opt_len = ipv6_optlen(opt), tlv_len;\r\nif (offset < sizeof(*opt) || offset >= opt_len)\r\nreturn -EINVAL;\r\nif (tlv[offset] == IPV6_TLV_PAD1)\r\nreturn 1;\r\nif (offset + 1 >= opt_len)\r\nreturn -EINVAL;\r\ntlv_len = tlv[offset + 1] + 2;\r\nif (offset + tlv_len > opt_len)\r\nreturn -EINVAL;\r\nreturn tlv_len;\r\n}\r\nstatic int calipso_opt_find(struct ipv6_opt_hdr *hop, unsigned int *start,\r\nunsigned int *end)\r\n{\r\nint ret_val = -ENOENT, tlv_len;\r\nunsigned int opt_len, offset, offset_s = 0, offset_e = 0;\r\nunsigned char *opt = (unsigned char *)hop;\r\nopt_len = ipv6_optlen(hop);\r\noffset = sizeof(*hop);\r\nwhile (offset < opt_len) {\r\ntlv_len = calipso_tlv_len(hop, offset);\r\nif (tlv_len < 0)\r\nreturn tlv_len;\r\nswitch (opt[offset]) {\r\ncase IPV6_TLV_PAD1:\r\ncase IPV6_TLV_PADN:\r\nif (offset_e)\r\noffset_e = offset;\r\nbreak;\r\ncase IPV6_TLV_CALIPSO:\r\nret_val = 0;\r\noffset_e = offset;\r\nbreak;\r\ndefault:\r\nif (offset_e == 0)\r\noffset_s = offset;\r\nelse\r\ngoto out;\r\n}\r\noffset += tlv_len;\r\n}\r\nout:\r\nif (offset_s)\r\n*start = offset_s + calipso_tlv_len(hop, offset_s);\r\nelse\r\n*start = sizeof(*hop);\r\nif (offset_e)\r\n*end = offset_e + calipso_tlv_len(hop, offset_e);\r\nelse\r\n*end = opt_len;\r\nreturn ret_val;\r\n}\r\nstatic struct ipv6_opt_hdr *\r\ncalipso_opt_insert(struct ipv6_opt_hdr *hop,\r\nconst struct calipso_doi *doi_def,\r\nconst struct netlbl_lsm_secattr *secattr)\r\n{\r\nunsigned int start, end, buf_len, pad, hop_len;\r\nstruct ipv6_opt_hdr *new;\r\nint ret_val;\r\nif (hop) {\r\nhop_len = ipv6_optlen(hop);\r\nret_val = calipso_opt_find(hop, &start, &end);\r\nif (ret_val && ret_val != -ENOENT)\r\nreturn ERR_PTR(ret_val);\r\n} else {\r\nhop_len = 0;\r\nstart = sizeof(*hop);\r\nend = 0;\r\n}\r\nbuf_len = hop_len + start - end + CALIPSO_OPT_LEN_MAX_WITH_PAD;\r\nnew = kzalloc(buf_len, GFP_ATOMIC);\r\nif (!new)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (start > sizeof(*hop))\r\nmemcpy(new, hop, start);\r\nret_val = calipso_genopt((unsigned char *)new, start, buf_len, doi_def,\r\nsecattr);\r\nif (ret_val < 0) {\r\nkfree(new);\r\nreturn ERR_PTR(ret_val);\r\n}\r\nbuf_len = start + ret_val;\r\npad = ((buf_len & 4) + (end & 7)) & 7;\r\ncalipso_pad_write((unsigned char *)new, buf_len, pad);\r\nbuf_len += pad;\r\nif (end != hop_len) {\r\nmemcpy((char *)new + buf_len, (char *)hop + end, hop_len - end);\r\nbuf_len += hop_len - end;\r\n}\r\nnew->nexthdr = 0;\r\nnew->hdrlen = buf_len / 8 - 1;\r\nreturn new;\r\n}\r\nstatic int calipso_opt_del(struct ipv6_opt_hdr *hop,\r\nstruct ipv6_opt_hdr **new)\r\n{\r\nint ret_val;\r\nunsigned int start, end, delta, pad, hop_len;\r\nret_val = calipso_opt_find(hop, &start, &end);\r\nif (ret_val)\r\nreturn ret_val;\r\nhop_len = ipv6_optlen(hop);\r\nif (start == sizeof(*hop) && end == hop_len) {\r\n*new = NULL;\r\nreturn 0;\r\n}\r\ndelta = (end - start) & ~7;\r\n*new = kzalloc(hop_len - delta, GFP_ATOMIC);\r\nif (!*new)\r\nreturn -ENOMEM;\r\nmemcpy(*new, hop, start);\r\n(*new)->hdrlen -= delta / 8;\r\npad = (end - start) & 7;\r\ncalipso_pad_write((unsigned char *)*new, start, pad);\r\nif (end != hop_len)\r\nmemcpy((char *)*new + start + pad, (char *)hop + end,\r\nhop_len - end);\r\nreturn 0;\r\n}\r\nstatic int calipso_opt_getattr(const unsigned char *calipso,\r\nstruct netlbl_lsm_secattr *secattr)\r\n{\r\nint ret_val = -ENOMSG;\r\nu32 doi, len = calipso[1], cat_len = calipso[6] * 4;\r\nstruct calipso_doi *doi_def;\r\nif (cat_len + 8 > len)\r\nreturn -EINVAL;\r\nif (calipso_cache_check(calipso + 2, calipso[1], secattr) == 0)\r\nreturn 0;\r\ndoi = get_unaligned_be32(calipso + 2);\r\nrcu_read_lock();\r\ndoi_def = calipso_doi_search(doi);\r\nif (!doi_def)\r\ngoto getattr_return;\r\nsecattr->attr.mls.lvl = calipso[7];\r\nsecattr->flags |= NETLBL_SECATTR_MLS_LVL;\r\nif (cat_len) {\r\nret_val = calipso_map_cat_ntoh(doi_def,\r\ncalipso + 10,\r\ncat_len,\r\nsecattr);\r\nif (ret_val != 0) {\r\nnetlbl_catmap_free(secattr->attr.mls.cat);\r\ngoto getattr_return;\r\n}\r\nsecattr->flags |= NETLBL_SECATTR_MLS_CAT;\r\n}\r\nsecattr->type = NETLBL_NLTYPE_CALIPSO;\r\ngetattr_return:\r\nrcu_read_unlock();\r\nreturn ret_val;\r\n}\r\nstatic int calipso_sock_getattr(struct sock *sk,\r\nstruct netlbl_lsm_secattr *secattr)\r\n{\r\nstruct ipv6_opt_hdr *hop;\r\nint opt_len, len, ret_val = -ENOMSG, offset;\r\nunsigned char *opt;\r\nstruct ipv6_txoptions *txopts = txopt_get(inet6_sk(sk));\r\nif (!txopts || !txopts->hopopt)\r\ngoto done;\r\nhop = txopts->hopopt;\r\nopt = (unsigned char *)hop;\r\nopt_len = ipv6_optlen(hop);\r\noffset = sizeof(*hop);\r\nwhile (offset < opt_len) {\r\nlen = calipso_tlv_len(hop, offset);\r\nif (len < 0) {\r\nret_val = len;\r\ngoto done;\r\n}\r\nswitch (opt[offset]) {\r\ncase IPV6_TLV_CALIPSO:\r\nif (len < CALIPSO_HDR_LEN)\r\nret_val = -EINVAL;\r\nelse\r\nret_val = calipso_opt_getattr(&opt[offset],\r\nsecattr);\r\ngoto done;\r\ndefault:\r\noffset += len;\r\nbreak;\r\n}\r\n}\r\ndone:\r\ntxopt_put(txopts);\r\nreturn ret_val;\r\n}\r\nstatic int calipso_sock_setattr(struct sock *sk,\r\nconst struct calipso_doi *doi_def,\r\nconst struct netlbl_lsm_secattr *secattr)\r\n{\r\nint ret_val;\r\nstruct ipv6_opt_hdr *old, *new;\r\nstruct ipv6_txoptions *txopts = txopt_get(inet6_sk(sk));\r\nold = NULL;\r\nif (txopts)\r\nold = txopts->hopopt;\r\nnew = calipso_opt_insert(old, doi_def, secattr);\r\ntxopt_put(txopts);\r\nif (IS_ERR(new))\r\nreturn PTR_ERR(new);\r\nret_val = calipso_opt_update(sk, new);\r\nkfree(new);\r\nreturn ret_val;\r\n}\r\nstatic void calipso_sock_delattr(struct sock *sk)\r\n{\r\nstruct ipv6_opt_hdr *new_hop;\r\nstruct ipv6_txoptions *txopts = txopt_get(inet6_sk(sk));\r\nif (!txopts || !txopts->hopopt)\r\ngoto done;\r\nif (calipso_opt_del(txopts->hopopt, &new_hop))\r\ngoto done;\r\ncalipso_opt_update(sk, new_hop);\r\nkfree(new_hop);\r\ndone:\r\ntxopt_put(txopts);\r\n}\r\nstatic int calipso_req_setattr(struct request_sock *req,\r\nconst struct calipso_doi *doi_def,\r\nconst struct netlbl_lsm_secattr *secattr)\r\n{\r\nstruct ipv6_txoptions *txopts;\r\nstruct inet_request_sock *req_inet = inet_rsk(req);\r\nstruct ipv6_opt_hdr *old, *new;\r\nstruct sock *sk = sk_to_full_sk(req_to_sk(req));\r\nif (req_inet->ipv6_opt && req_inet->ipv6_opt->hopopt)\r\nold = req_inet->ipv6_opt->hopopt;\r\nelse\r\nold = NULL;\r\nnew = calipso_opt_insert(old, doi_def, secattr);\r\nif (IS_ERR(new))\r\nreturn PTR_ERR(new);\r\ntxopts = ipv6_renew_options_kern(sk, req_inet->ipv6_opt, IPV6_HOPOPTS,\r\nnew, new ? ipv6_optlen(new) : 0);\r\nkfree(new);\r\nif (IS_ERR(txopts))\r\nreturn PTR_ERR(txopts);\r\ntxopts = xchg(&req_inet->ipv6_opt, txopts);\r\nif (txopts) {\r\natomic_sub(txopts->tot_len, &sk->sk_omem_alloc);\r\ntxopt_put(txopts);\r\n}\r\nreturn 0;\r\n}\r\nstatic void calipso_req_delattr(struct request_sock *req)\r\n{\r\nstruct inet_request_sock *req_inet = inet_rsk(req);\r\nstruct ipv6_opt_hdr *new;\r\nstruct ipv6_txoptions *txopts;\r\nstruct sock *sk = sk_to_full_sk(req_to_sk(req));\r\nif (!req_inet->ipv6_opt || !req_inet->ipv6_opt->hopopt)\r\nreturn;\r\nif (calipso_opt_del(req_inet->ipv6_opt->hopopt, &new))\r\nreturn;\r\ntxopts = ipv6_renew_options_kern(sk, req_inet->ipv6_opt, IPV6_HOPOPTS,\r\nnew, new ? ipv6_optlen(new) : 0);\r\nif (!IS_ERR(txopts)) {\r\ntxopts = xchg(&req_inet->ipv6_opt, txopts);\r\nif (txopts) {\r\natomic_sub(txopts->tot_len, &sk->sk_omem_alloc);\r\ntxopt_put(txopts);\r\n}\r\n}\r\nkfree(new);\r\n}\r\nstatic unsigned char *calipso_skbuff_optptr(const struct sk_buff *skb)\r\n{\r\nconst struct ipv6hdr *ip6_hdr = ipv6_hdr(skb);\r\nint offset;\r\nif (ip6_hdr->nexthdr != NEXTHDR_HOP)\r\nreturn NULL;\r\noffset = ipv6_find_tlv(skb, sizeof(*ip6_hdr), IPV6_TLV_CALIPSO);\r\nif (offset >= 0)\r\nreturn (unsigned char *)ip6_hdr + offset;\r\nreturn NULL;\r\n}\r\nstatic int calipso_skbuff_setattr(struct sk_buff *skb,\r\nconst struct calipso_doi *doi_def,\r\nconst struct netlbl_lsm_secattr *secattr)\r\n{\r\nint ret_val;\r\nstruct ipv6hdr *ip6_hdr;\r\nstruct ipv6_opt_hdr *hop;\r\nunsigned char buf[CALIPSO_MAX_BUFFER];\r\nint len_delta, new_end, pad, payload;\r\nunsigned int start, end;\r\nip6_hdr = ipv6_hdr(skb);\r\nif (ip6_hdr->nexthdr == NEXTHDR_HOP) {\r\nhop = (struct ipv6_opt_hdr *)(ip6_hdr + 1);\r\nret_val = calipso_opt_find(hop, &start, &end);\r\nif (ret_val && ret_val != -ENOENT)\r\nreturn ret_val;\r\n} else {\r\nstart = 0;\r\nend = 0;\r\n}\r\nmemset(buf, 0, sizeof(buf));\r\nret_val = calipso_genopt(buf, start & 3, sizeof(buf), doi_def, secattr);\r\nif (ret_val < 0)\r\nreturn ret_val;\r\nnew_end = start + ret_val;\r\npad = ((new_end & 4) + (end & 7)) & 7;\r\nlen_delta = new_end - (int)end + pad;\r\nret_val = skb_cow(skb, skb_headroom(skb) + len_delta);\r\nif (ret_val < 0)\r\nreturn ret_val;\r\nip6_hdr = ipv6_hdr(skb);\r\nif (len_delta) {\r\nif (len_delta > 0)\r\nskb_push(skb, len_delta);\r\nelse\r\nskb_pull(skb, -len_delta);\r\nmemmove((char *)ip6_hdr - len_delta, ip6_hdr,\r\nsizeof(*ip6_hdr) + start);\r\nskb_reset_network_header(skb);\r\nip6_hdr = ipv6_hdr(skb);\r\npayload = ntohs(ip6_hdr->payload_len);\r\nip6_hdr->payload_len = htons(payload + len_delta);\r\n}\r\nhop = (struct ipv6_opt_hdr *)(ip6_hdr + 1);\r\nif (start == 0) {\r\nstruct ipv6_opt_hdr *new_hop = (struct ipv6_opt_hdr *)buf;\r\nnew_hop->nexthdr = ip6_hdr->nexthdr;\r\nnew_hop->hdrlen = len_delta / 8 - 1;\r\nip6_hdr->nexthdr = NEXTHDR_HOP;\r\n} else {\r\nhop->hdrlen += len_delta / 8;\r\n}\r\nmemcpy((char *)hop + start, buf + (start & 3), new_end - start);\r\ncalipso_pad_write((unsigned char *)hop, new_end, pad);\r\nreturn 0;\r\n}\r\nstatic int calipso_skbuff_delattr(struct sk_buff *skb)\r\n{\r\nint ret_val;\r\nstruct ipv6hdr *ip6_hdr;\r\nstruct ipv6_opt_hdr *old_hop;\r\nu32 old_hop_len, start = 0, end = 0, delta, size, pad;\r\nif (!calipso_skbuff_optptr(skb))\r\nreturn 0;\r\nret_val = skb_cow(skb, skb_headroom(skb));\r\nif (ret_val < 0)\r\nreturn ret_val;\r\nip6_hdr = ipv6_hdr(skb);\r\nold_hop = (struct ipv6_opt_hdr *)(ip6_hdr + 1);\r\nold_hop_len = ipv6_optlen(old_hop);\r\nret_val = calipso_opt_find(old_hop, &start, &end);\r\nif (ret_val)\r\nreturn ret_val;\r\nif (start == sizeof(*old_hop) && end == old_hop_len) {\r\ndelta = old_hop_len;\r\nsize = sizeof(*ip6_hdr);\r\nip6_hdr->nexthdr = old_hop->nexthdr;\r\n} else {\r\ndelta = (end - start) & ~7;\r\nif (delta)\r\nold_hop->hdrlen -= delta / 8;\r\npad = (end - start) & 7;\r\nsize = sizeof(*ip6_hdr) + start + pad;\r\ncalipso_pad_write((unsigned char *)old_hop, start, pad);\r\n}\r\nif (delta) {\r\nskb_pull(skb, delta);\r\nmemmove((char *)ip6_hdr + delta, ip6_hdr, size);\r\nskb_reset_network_header(skb);\r\n}\r\nreturn 0;\r\n}\r\nint __init calipso_init(void)\r\n{\r\nint ret_val;\r\nret_val = calipso_cache_init();\r\nif (!ret_val)\r\nnetlbl_calipso_ops_register(&ops);\r\nreturn ret_val;\r\n}\r\nvoid calipso_exit(void)\r\n{\r\nnetlbl_calipso_ops_register(NULL);\r\ncalipso_cache_invalidate();\r\nkfree(calipso_cache);\r\n}
