static inline u32 omap_rng_read(struct omap_rng_dev *priv, u16 reg)\r\n{\r\nreturn __raw_readl(priv->base + priv->pdata->regs[reg]);\r\n}\r\nstatic inline void omap_rng_write(struct omap_rng_dev *priv, u16 reg,\r\nu32 val)\r\n{\r\n__raw_writel(val, priv->base + priv->pdata->regs[reg]);\r\n}\r\nstatic int omap_rng_do_read(struct hwrng *rng, void *data, size_t max,\r\nbool wait)\r\n{\r\nstruct omap_rng_dev *priv;\r\nint i, present;\r\npriv = (struct omap_rng_dev *)rng->priv;\r\nif (max < priv->pdata->data_size)\r\nreturn 0;\r\nfor (i = 0; i < 20; i++) {\r\npresent = priv->pdata->data_present(priv);\r\nif (present || !wait)\r\nbreak;\r\nudelay(10);\r\n}\r\nif (!present)\r\nreturn 0;\r\nmemcpy_fromio(data, priv->base + priv->pdata->regs[RNG_OUTPUT_0_REG],\r\npriv->pdata->data_size);\r\nif (priv->pdata->regs[RNG_INTACK_REG])\r\nomap_rng_write(priv, RNG_INTACK_REG, RNG_REG_INTACK_RDY_MASK);\r\nreturn priv->pdata->data_size;\r\n}\r\nstatic int omap_rng_init(struct hwrng *rng)\r\n{\r\nstruct omap_rng_dev *priv;\r\npriv = (struct omap_rng_dev *)rng->priv;\r\nreturn priv->pdata->init(priv);\r\n}\r\nstatic void omap_rng_cleanup(struct hwrng *rng)\r\n{\r\nstruct omap_rng_dev *priv;\r\npriv = (struct omap_rng_dev *)rng->priv;\r\npriv->pdata->cleanup(priv);\r\n}\r\nstatic inline u32 omap2_rng_data_present(struct omap_rng_dev *priv)\r\n{\r\nreturn omap_rng_read(priv, RNG_STATUS_REG) ? 0 : 1;\r\n}\r\nstatic int omap2_rng_init(struct omap_rng_dev *priv)\r\n{\r\nomap_rng_write(priv, RNG_SYSCONFIG_REG, 0x1);\r\nreturn 0;\r\n}\r\nstatic void omap2_rng_cleanup(struct omap_rng_dev *priv)\r\n{\r\nomap_rng_write(priv, RNG_SYSCONFIG_REG, 0x0);\r\n}\r\nstatic inline u32 omap4_rng_data_present(struct omap_rng_dev *priv)\r\n{\r\nreturn omap_rng_read(priv, RNG_STATUS_REG) & RNG_REG_STATUS_RDY;\r\n}\r\nstatic int eip76_rng_init(struct omap_rng_dev *priv)\r\n{\r\nu32 val;\r\nif (omap_rng_read(priv, RNG_CONTROL_REG) & RNG_CONTROL_ENABLE_TRNG_MASK)\r\nreturn 0;\r\nval = 0x5 << RNG_CONFIG_MIN_REFIL_CYCLES_SHIFT;\r\nval |= RNG_CONFIG_MAX_REFIL_CYCLES << RNG_CONFIG_MAX_REFIL_CYCLES_SHIFT;\r\nomap_rng_write(priv, RNG_CONFIG_REG, val);\r\nomap_rng_write(priv, RNG_FRODETUNE_REG, 0x0);\r\nomap_rng_write(priv, RNG_FROENABLE_REG, RNG_REG_FROENABLE_MASK);\r\nval = RNG_CONTROL_ENABLE_TRNG_MASK;\r\nomap_rng_write(priv, RNG_CONTROL_REG, val);\r\nreturn 0;\r\n}\r\nstatic int omap4_rng_init(struct omap_rng_dev *priv)\r\n{\r\nu32 val;\r\nif (omap_rng_read(priv, RNG_CONTROL_REG) & RNG_CONTROL_ENABLE_TRNG_MASK)\r\nreturn 0;\r\nval = RNG_CONFIG_MIN_REFIL_CYCLES << RNG_CONFIG_MIN_REFIL_CYCLES_SHIFT;\r\nval |= RNG_CONFIG_MAX_REFIL_CYCLES << RNG_CONFIG_MAX_REFIL_CYCLES_SHIFT;\r\nomap_rng_write(priv, RNG_CONFIG_REG, val);\r\nomap_rng_write(priv, RNG_FRODETUNE_REG, 0x0);\r\nomap_rng_write(priv, RNG_FROENABLE_REG, RNG_REG_FROENABLE_MASK);\r\nval = RNG_ALARM_THRESHOLD << RNG_ALARMCNT_ALARM_TH_SHIFT;\r\nval |= RNG_SHUTDOWN_THRESHOLD << RNG_ALARMCNT_SHUTDOWN_TH_SHIFT;\r\nomap_rng_write(priv, RNG_ALARMCNT_REG, val);\r\nval = RNG_CONTROL_STARTUP_CYCLES << RNG_CONTROL_STARTUP_CYCLES_SHIFT;\r\nval |= RNG_CONTROL_ENABLE_TRNG_MASK;\r\nomap_rng_write(priv, RNG_CONTROL_REG, val);\r\nreturn 0;\r\n}\r\nstatic void omap4_rng_cleanup(struct omap_rng_dev *priv)\r\n{\r\nint val;\r\nval = omap_rng_read(priv, RNG_CONTROL_REG);\r\nval &= ~RNG_CONTROL_ENABLE_TRNG_MASK;\r\nomap_rng_write(priv, RNG_CONTROL_REG, val);\r\n}\r\nstatic irqreturn_t omap4_rng_irq(int irq, void *dev_id)\r\n{\r\nstruct omap_rng_dev *priv = dev_id;\r\nu32 fro_detune, fro_enable;\r\nomap_rng_write(priv, RNG_ALARMMASK_REG, 0x0);\r\nomap_rng_write(priv, RNG_ALARMSTOP_REG, 0x0);\r\nfro_enable = omap_rng_read(priv, RNG_FROENABLE_REG);\r\nfro_detune = ~fro_enable & RNG_REG_FRODETUNE_MASK;\r\nfro_detune = fro_detune | omap_rng_read(priv, RNG_FRODETUNE_REG);\r\nfro_enable = RNG_REG_FROENABLE_MASK;\r\nomap_rng_write(priv, RNG_FRODETUNE_REG, fro_detune);\r\nomap_rng_write(priv, RNG_FROENABLE_REG, fro_enable);\r\nomap_rng_write(priv, RNG_INTACK_REG, RNG_REG_INTACK_SHUTDOWN_OFLO_MASK);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int of_get_omap_rng_device_details(struct omap_rng_dev *priv,\r\nstruct platform_device *pdev)\r\n{\r\nconst struct of_device_id *match;\r\nstruct device *dev = &pdev->dev;\r\nint irq, err;\r\nmatch = of_match_device(of_match_ptr(omap_rng_of_match), dev);\r\nif (!match) {\r\ndev_err(dev, "no compatible OF match\n");\r\nreturn -EINVAL;\r\n}\r\npriv->pdata = match->data;\r\nif (of_device_is_compatible(dev->of_node, "ti,omap4-rng") ||\r\nof_device_is_compatible(dev->of_node, "inside-secure,safexcel-eip76")) {\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(dev, "%s: error getting IRQ resource - %d\n",\r\n__func__, irq);\r\nreturn irq;\r\n}\r\nerr = devm_request_irq(dev, irq, omap4_rng_irq,\r\nIRQF_TRIGGER_NONE, dev_name(dev), priv);\r\nif (err) {\r\ndev_err(dev, "unable to request irq %d, err = %d\n",\r\nirq, err);\r\nreturn err;\r\n}\r\nif (priv->pdata->regs[RNG_INTMASK_REG])\r\nomap_rng_write(priv, RNG_INTMASK_REG,\r\nRNG_SHUTDOWN_OFLO_MASK);\r\nelse\r\nomap_rng_write(priv, RNG_CONTROL_REG,\r\nRNG_SHUTDOWN_OFLO_MASK);\r\n}\r\nreturn 0;\r\n}\r\nstatic int of_get_omap_rng_device_details(struct omap_rng_dev *omap_rng,\r\nstruct platform_device *pdev)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int get_omap_rng_device_details(struct omap_rng_dev *omap_rng)\r\n{\r\nomap_rng->pdata = &omap2_rng_pdata;\r\nreturn 0;\r\n}\r\nstatic int omap_rng_probe(struct platform_device *pdev)\r\n{\r\nstruct omap_rng_dev *priv;\r\nstruct resource *res;\r\nstruct device *dev = &pdev->dev;\r\nint ret;\r\npriv = devm_kzalloc(dev, sizeof(struct omap_rng_dev), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->rng.read = omap_rng_do_read;\r\npriv->rng.init = omap_rng_init;\r\npriv->rng.cleanup = omap_rng_cleanup;\r\npriv->rng.priv = (unsigned long)priv;\r\nplatform_set_drvdata(pdev, priv);\r\npriv->dev = dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npriv->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(priv->base)) {\r\nret = PTR_ERR(priv->base);\r\ngoto err_ioremap;\r\n}\r\npriv->rng.name = devm_kstrdup(dev, dev_name(dev), GFP_KERNEL);\r\nif (!priv->rng.name) {\r\nret = -ENOMEM;\r\ngoto err_ioremap;\r\n}\r\npm_runtime_enable(&pdev->dev);\r\nret = pm_runtime_get_sync(&pdev->dev);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed to runtime_get device: %d\n", ret);\r\npm_runtime_put_noidle(&pdev->dev);\r\ngoto err_ioremap;\r\n}\r\npriv->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(priv->clk) && PTR_ERR(priv->clk) == -EPROBE_DEFER)\r\nreturn -EPROBE_DEFER;\r\nif (!IS_ERR(priv->clk)) {\r\nret = clk_prepare_enable(priv->clk);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"Unable to enable the clk: %d\n", ret);\r\ngoto err_register;\r\n}\r\n}\r\nret = (dev->of_node) ? of_get_omap_rng_device_details(priv, pdev) :\r\nget_omap_rng_device_details(priv);\r\nif (ret)\r\ngoto err_register;\r\nret = hwrng_register(&priv->rng);\r\nif (ret)\r\ngoto err_register;\r\ndev_info(&pdev->dev, "Random Number Generator ver. %02x\n",\r\nomap_rng_read(priv, RNG_REV_REG));\r\nreturn 0;\r\nerr_register:\r\npriv->base = NULL;\r\npm_runtime_put_sync(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nif (!IS_ERR(priv->clk))\r\nclk_disable_unprepare(priv->clk);\r\nerr_ioremap:\r\ndev_err(dev, "initialization failed.\n");\r\nreturn ret;\r\n}\r\nstatic int omap_rng_remove(struct platform_device *pdev)\r\n{\r\nstruct omap_rng_dev *priv = platform_get_drvdata(pdev);\r\nhwrng_unregister(&priv->rng);\r\npriv->pdata->cleanup(priv);\r\npm_runtime_put_sync(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nif (!IS_ERR(priv->clk))\r\nclk_disable_unprepare(priv->clk);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused omap_rng_suspend(struct device *dev)\r\n{\r\nstruct omap_rng_dev *priv = dev_get_drvdata(dev);\r\npriv->pdata->cleanup(priv);\r\npm_runtime_put_sync(dev);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused omap_rng_resume(struct device *dev)\r\n{\r\nstruct omap_rng_dev *priv = dev_get_drvdata(dev);\r\nint ret;\r\nret = pm_runtime_get_sync(dev);\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to runtime_get device: %d\n", ret);\r\npm_runtime_put_noidle(dev);\r\nreturn ret;\r\n}\r\npriv->pdata->init(priv);\r\nreturn 0;\r\n}
