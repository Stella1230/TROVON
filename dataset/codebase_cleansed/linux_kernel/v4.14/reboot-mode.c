static unsigned int get_reboot_mode_magic(struct reboot_mode_driver *reboot,\r\nconst char *cmd)\r\n{\r\nconst char *normal = "normal";\r\nint magic = 0;\r\nstruct mode_info *info;\r\nif (!cmd)\r\ncmd = normal;\r\nlist_for_each_entry(info, &reboot->head, list) {\r\nif (!strcmp(info->mode, cmd)) {\r\nmagic = info->magic;\r\nbreak;\r\n}\r\n}\r\nreturn magic;\r\n}\r\nstatic int reboot_mode_notify(struct notifier_block *this,\r\nunsigned long mode, void *cmd)\r\n{\r\nstruct reboot_mode_driver *reboot;\r\nunsigned int magic;\r\nreboot = container_of(this, struct reboot_mode_driver, reboot_notifier);\r\nmagic = get_reboot_mode_magic(reboot, cmd);\r\nif (magic)\r\nreboot->write(reboot, magic);\r\nreturn NOTIFY_DONE;\r\n}\r\nint reboot_mode_register(struct reboot_mode_driver *reboot)\r\n{\r\nstruct mode_info *info;\r\nstruct property *prop;\r\nstruct device_node *np = reboot->dev->of_node;\r\nsize_t len = strlen(PREFIX);\r\nint ret;\r\nINIT_LIST_HEAD(&reboot->head);\r\nfor_each_property_of_node(np, prop) {\r\nif (strncmp(prop->name, PREFIX, len))\r\ncontinue;\r\ninfo = devm_kzalloc(reboot->dev, sizeof(*info), GFP_KERNEL);\r\nif (!info) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nif (of_property_read_u32(np, prop->name, &info->magic)) {\r\ndev_err(reboot->dev, "reboot mode %s without magic number\n",\r\ninfo->mode);\r\ndevm_kfree(reboot->dev, info);\r\ncontinue;\r\n}\r\ninfo->mode = kstrdup_const(prop->name + len, GFP_KERNEL);\r\nif (!info->mode) {\r\nret = -ENOMEM;\r\ngoto error;\r\n} else if (info->mode[0] == '\0') {\r\nkfree_const(info->mode);\r\nret = -EINVAL;\r\ndev_err(reboot->dev, "invalid mode name(%s): too short!\n",\r\nprop->name);\r\ngoto error;\r\n}\r\nlist_add_tail(&info->list, &reboot->head);\r\n}\r\nreboot->reboot_notifier.notifier_call = reboot_mode_notify;\r\nregister_reboot_notifier(&reboot->reboot_notifier);\r\nreturn 0;\r\nerror:\r\nlist_for_each_entry(info, &reboot->head, list)\r\nkfree_const(info->mode);\r\nreturn ret;\r\n}\r\nint reboot_mode_unregister(struct reboot_mode_driver *reboot)\r\n{\r\nstruct mode_info *info;\r\nunregister_reboot_notifier(&reboot->reboot_notifier);\r\nlist_for_each_entry(info, &reboot->head, list)\r\nkfree_const(info->mode);\r\nreturn 0;\r\n}\r\nstatic void devm_reboot_mode_release(struct device *dev, void *res)\r\n{\r\nreboot_mode_unregister(*(struct reboot_mode_driver **)res);\r\n}\r\nint devm_reboot_mode_register(struct device *dev,\r\nstruct reboot_mode_driver *reboot)\r\n{\r\nstruct reboot_mode_driver **dr;\r\nint rc;\r\ndr = devres_alloc(devm_reboot_mode_release, sizeof(*dr), GFP_KERNEL);\r\nif (!dr)\r\nreturn -ENOMEM;\r\nrc = reboot_mode_register(reboot);\r\nif (rc) {\r\ndevres_free(dr);\r\nreturn rc;\r\n}\r\n*dr = reboot;\r\ndevres_add(dev, dr);\r\nreturn 0;\r\n}\r\nstatic int devm_reboot_mode_match(struct device *dev, void *res, void *data)\r\n{\r\nstruct reboot_mode_driver **p = res;\r\nif (WARN_ON(!p || !*p))\r\nreturn 0;\r\nreturn *p == data;\r\n}\r\nvoid devm_reboot_mode_unregister(struct device *dev,\r\nstruct reboot_mode_driver *reboot)\r\n{\r\nWARN_ON(devres_release(dev,\r\ndevm_reboot_mode_release,\r\ndevm_reboot_mode_match, reboot));\r\n}
