static inline u32 fpci_readl(struct tegra_xusb *tegra, unsigned int offset)\r\n{\r\nreturn readl(tegra->fpci_base + offset);\r\n}\r\nstatic inline void fpci_writel(struct tegra_xusb *tegra, u32 value,\r\nunsigned int offset)\r\n{\r\nwritel(value, tegra->fpci_base + offset);\r\n}\r\nstatic inline u32 ipfs_readl(struct tegra_xusb *tegra, unsigned int offset)\r\n{\r\nreturn readl(tegra->ipfs_base + offset);\r\n}\r\nstatic inline void ipfs_writel(struct tegra_xusb *tegra, u32 value,\r\nunsigned int offset)\r\n{\r\nwritel(value, tegra->ipfs_base + offset);\r\n}\r\nstatic u32 csb_readl(struct tegra_xusb *tegra, unsigned int offset)\r\n{\r\nu32 page = CSB_PAGE_SELECT(offset);\r\nu32 ofs = CSB_PAGE_OFFSET(offset);\r\nfpci_writel(tegra, page, XUSB_CFG_ARU_C11_CSBRANGE);\r\nreturn fpci_readl(tegra, XUSB_CFG_CSB_BASE_ADDR + ofs);\r\n}\r\nstatic void csb_writel(struct tegra_xusb *tegra, u32 value,\r\nunsigned int offset)\r\n{\r\nu32 page = CSB_PAGE_SELECT(offset);\r\nu32 ofs = CSB_PAGE_OFFSET(offset);\r\nfpci_writel(tegra, page, XUSB_CFG_ARU_C11_CSBRANGE);\r\nfpci_writel(tegra, value, XUSB_CFG_CSB_BASE_ADDR + ofs);\r\n}\r\nstatic int tegra_xusb_set_ss_clk(struct tegra_xusb *tegra,\r\nunsigned long rate)\r\n{\r\nunsigned long new_parent_rate, old_parent_rate;\r\nstruct clk *clk = tegra->ss_src_clk;\r\nunsigned int div;\r\nint err;\r\nif (clk_get_rate(clk) == rate)\r\nreturn 0;\r\nswitch (rate) {\r\ncase TEGRA_XHCI_SS_HIGH_SPEED:\r\nold_parent_rate = clk_get_rate(clk_get_parent(clk));\r\nnew_parent_rate = clk_get_rate(tegra->pll_u_480m);\r\ndiv = new_parent_rate / rate;\r\nerr = clk_set_rate(clk, old_parent_rate / div);\r\nif (err)\r\nreturn err;\r\nerr = clk_set_parent(clk, tegra->pll_u_480m);\r\nif (err)\r\nreturn err;\r\nerr = clk_set_rate(clk, rate);\r\nif (err)\r\nreturn err;\r\nbreak;\r\ncase TEGRA_XHCI_SS_LOW_SPEED:\r\nerr = clk_set_parent(clk, tegra->clk_m);\r\nif (err)\r\nreturn err;\r\nerr = clk_set_rate(clk, rate);\r\nif (err)\r\nreturn err;\r\nbreak;\r\ndefault:\r\ndev_err(tegra->dev, "Invalid SS rate: %lu Hz\n", rate);\r\nreturn -EINVAL;\r\n}\r\nif (clk_get_rate(clk) != rate) {\r\ndev_err(tegra->dev, "SS clock doesn't match requested rate\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned long extract_field(u32 value, unsigned int start,\r\nunsigned int count)\r\n{\r\nreturn (value >> start) & ((1 << count) - 1);\r\n}\r\nstatic inline u32 tegra_xusb_mbox_pack(const struct tegra_xusb_mbox_msg *msg)\r\n{\r\nreturn (msg->cmd & CMD_TYPE_MASK) << CMD_TYPE_SHIFT |\r\n(msg->data & CMD_DATA_MASK) << CMD_DATA_SHIFT;\r\n}\r\nstatic inline void tegra_xusb_mbox_unpack(struct tegra_xusb_mbox_msg *msg,\r\nu32 value)\r\n{\r\nmsg->cmd = (value >> CMD_TYPE_SHIFT) & CMD_TYPE_MASK;\r\nmsg->data = (value >> CMD_DATA_SHIFT) & CMD_DATA_MASK;\r\n}\r\nstatic bool tegra_xusb_mbox_cmd_requires_ack(enum tegra_xusb_mbox_cmd cmd)\r\n{\r\nswitch (cmd) {\r\ncase MBOX_CMD_SET_BW:\r\ncase MBOX_CMD_ACK:\r\ncase MBOX_CMD_NAK:\r\nreturn false;\r\ndefault:\r\nreturn true;\r\n}\r\n}\r\nstatic int tegra_xusb_mbox_send(struct tegra_xusb *tegra,\r\nconst struct tegra_xusb_mbox_msg *msg)\r\n{\r\nbool wait_for_idle = false;\r\nu32 value;\r\nif (!(msg->cmd == MBOX_CMD_ACK || msg->cmd == MBOX_CMD_NAK)) {\r\nvalue = fpci_readl(tegra, XUSB_CFG_ARU_MBOX_OWNER);\r\nif (value != MBOX_OWNER_NONE) {\r\ndev_err(tegra->dev, "mailbox is busy\n");\r\nreturn -EBUSY;\r\n}\r\nfpci_writel(tegra, MBOX_OWNER_SW, XUSB_CFG_ARU_MBOX_OWNER);\r\nvalue = fpci_readl(tegra, XUSB_CFG_ARU_MBOX_OWNER);\r\nif (value != MBOX_OWNER_SW) {\r\ndev_err(tegra->dev, "failed to acquire mailbox\n");\r\nreturn -EBUSY;\r\n}\r\nwait_for_idle = true;\r\n}\r\nvalue = tegra_xusb_mbox_pack(msg);\r\nfpci_writel(tegra, value, XUSB_CFG_ARU_MBOX_DATA_IN);\r\nvalue = fpci_readl(tegra, XUSB_CFG_ARU_MBOX_CMD);\r\nvalue |= MBOX_INT_EN | MBOX_DEST_FALC;\r\nfpci_writel(tegra, value, XUSB_CFG_ARU_MBOX_CMD);\r\nif (wait_for_idle) {\r\nunsigned long timeout = jiffies + msecs_to_jiffies(250);\r\nwhile (time_before(jiffies, timeout)) {\r\nvalue = fpci_readl(tegra, XUSB_CFG_ARU_MBOX_OWNER);\r\nif (value == MBOX_OWNER_NONE)\r\nbreak;\r\nusleep_range(10, 20);\r\n}\r\nif (time_after(jiffies, timeout))\r\nvalue = fpci_readl(tegra, XUSB_CFG_ARU_MBOX_OWNER);\r\nif (value != MBOX_OWNER_NONE)\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t tegra_xusb_mbox_irq(int irq, void *data)\r\n{\r\nstruct tegra_xusb *tegra = data;\r\nu32 value;\r\nvalue = fpci_readl(tegra, XUSB_CFG_ARU_SMI_INTR);\r\nfpci_writel(tegra, value, XUSB_CFG_ARU_SMI_INTR);\r\nif (value & MBOX_SMI_INTR_FW_HANG)\r\ndev_err(tegra->dev, "controller firmware hang\n");\r\nreturn IRQ_WAKE_THREAD;\r\n}\r\nstatic void tegra_xusb_mbox_handle(struct tegra_xusb *tegra,\r\nconst struct tegra_xusb_mbox_msg *msg)\r\n{\r\nstruct tegra_xusb_padctl *padctl = tegra->padctl;\r\nconst struct tegra_xusb_soc *soc = tegra->soc;\r\nstruct device *dev = tegra->dev;\r\nstruct tegra_xusb_mbox_msg rsp;\r\nunsigned long mask;\r\nunsigned int port;\r\nbool idle, enable;\r\nint err;\r\nmemset(&rsp, 0, sizeof(rsp));\r\nswitch (msg->cmd) {\r\ncase MBOX_CMD_INC_FALC_CLOCK:\r\ncase MBOX_CMD_DEC_FALC_CLOCK:\r\nrsp.data = clk_get_rate(tegra->falcon_clk) / 1000;\r\nif (rsp.data != msg->data)\r\nrsp.cmd = MBOX_CMD_NAK;\r\nelse\r\nrsp.cmd = MBOX_CMD_ACK;\r\nbreak;\r\ncase MBOX_CMD_INC_SSPI_CLOCK:\r\ncase MBOX_CMD_DEC_SSPI_CLOCK:\r\nif (tegra->soc->scale_ss_clock) {\r\nerr = tegra_xusb_set_ss_clk(tegra, msg->data * 1000);\r\nif (err < 0)\r\nrsp.cmd = MBOX_CMD_NAK;\r\nelse\r\nrsp.cmd = MBOX_CMD_ACK;\r\nrsp.data = clk_get_rate(tegra->ss_src_clk) / 1000;\r\n} else {\r\nrsp.cmd = MBOX_CMD_ACK;\r\nrsp.data = msg->data;\r\n}\r\nbreak;\r\ncase MBOX_CMD_SET_BW:\r\nbreak;\r\ncase MBOX_CMD_SAVE_DFE_CTLE_CTX:\r\nerr = tegra_xusb_padctl_usb3_save_context(padctl, msg->data);\r\nif (err < 0) {\r\ndev_err(dev, "failed to save context for USB3#%u: %d\n",\r\nmsg->data, err);\r\nrsp.cmd = MBOX_CMD_NAK;\r\n} else {\r\nrsp.cmd = MBOX_CMD_ACK;\r\n}\r\nrsp.data = msg->data;\r\nbreak;\r\ncase MBOX_CMD_START_HSIC_IDLE:\r\ncase MBOX_CMD_STOP_HSIC_IDLE:\r\nif (msg->cmd == MBOX_CMD_STOP_HSIC_IDLE)\r\nidle = false;\r\nelse\r\nidle = true;\r\nmask = extract_field(msg->data, 1 + soc->ports.hsic.offset,\r\nsoc->ports.hsic.count);\r\nfor_each_set_bit(port, &mask, 32) {\r\nerr = tegra_xusb_padctl_hsic_set_idle(padctl, port,\r\nidle);\r\nif (err < 0)\r\nbreak;\r\n}\r\nif (err < 0) {\r\ndev_err(dev, "failed to set HSIC#%u %s: %d\n", port,\r\nidle ? "idle" : "busy", err);\r\nrsp.cmd = MBOX_CMD_NAK;\r\n} else {\r\nrsp.cmd = MBOX_CMD_ACK;\r\n}\r\nrsp.data = msg->data;\r\nbreak;\r\ncase MBOX_CMD_DISABLE_SS_LFPS_DETECTION:\r\ncase MBOX_CMD_ENABLE_SS_LFPS_DETECTION:\r\nif (msg->cmd == MBOX_CMD_DISABLE_SS_LFPS_DETECTION)\r\nenable = false;\r\nelse\r\nenable = true;\r\nmask = extract_field(msg->data, 1 + soc->ports.usb3.offset,\r\nsoc->ports.usb3.count);\r\nfor_each_set_bit(port, &mask, soc->ports.usb3.count) {\r\nerr = tegra_xusb_padctl_usb3_set_lfps_detect(padctl,\r\nport,\r\nenable);\r\nif (err < 0)\r\nbreak;\r\n}\r\nif (err < 0) {\r\ndev_err(dev,\r\n"failed to %s LFPS detection on USB3#%u: %d\n",\r\nenable ? "enable" : "disable", port, err);\r\nrsp.cmd = MBOX_CMD_NAK;\r\n} else {\r\nrsp.cmd = MBOX_CMD_ACK;\r\n}\r\nrsp.data = msg->data;\r\nbreak;\r\ndefault:\r\ndev_warn(dev, "unknown message: %#x\n", msg->cmd);\r\nbreak;\r\n}\r\nif (rsp.cmd) {\r\nconst char *cmd = (rsp.cmd == MBOX_CMD_ACK) ? "ACK" : "NAK";\r\nerr = tegra_xusb_mbox_send(tegra, &rsp);\r\nif (err < 0)\r\ndev_err(dev, "failed to send %s: %d\n", cmd, err);\r\n}\r\n}\r\nstatic irqreturn_t tegra_xusb_mbox_thread(int irq, void *data)\r\n{\r\nstruct tegra_xusb *tegra = data;\r\nstruct tegra_xusb_mbox_msg msg;\r\nu32 value;\r\nmutex_lock(&tegra->lock);\r\nvalue = fpci_readl(tegra, XUSB_CFG_ARU_MBOX_DATA_OUT);\r\ntegra_xusb_mbox_unpack(&msg, value);\r\nvalue = fpci_readl(tegra, XUSB_CFG_ARU_MBOX_CMD);\r\nvalue &= ~MBOX_DEST_SMI;\r\nfpci_writel(tegra, value, XUSB_CFG_ARU_MBOX_CMD);\r\nif (!tegra_xusb_mbox_cmd_requires_ack(msg.cmd))\r\nfpci_writel(tegra, MBOX_OWNER_NONE, XUSB_CFG_ARU_MBOX_OWNER);\r\ntegra_xusb_mbox_handle(tegra, &msg);\r\nmutex_unlock(&tegra->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void tegra_xusb_ipfs_config(struct tegra_xusb *tegra,\r\nstruct resource *regs)\r\n{\r\nu32 value;\r\nvalue = ipfs_readl(tegra, IPFS_XUSB_HOST_CONFIGURATION_0);\r\nvalue |= IPFS_EN_FPCI;\r\nipfs_writel(tegra, value, IPFS_XUSB_HOST_CONFIGURATION_0);\r\nusleep_range(10, 20);\r\nvalue = fpci_readl(tegra, XUSB_CFG_4);\r\nvalue &= ~(XUSB_BASE_ADDR_MASK << XUSB_BASE_ADDR_SHIFT);\r\nvalue |= regs->start & (XUSB_BASE_ADDR_MASK << XUSB_BASE_ADDR_SHIFT);\r\nfpci_writel(tegra, value, XUSB_CFG_4);\r\nusleep_range(100, 200);\r\nvalue = fpci_readl(tegra, XUSB_CFG_1);\r\nvalue |= XUSB_IO_SPACE_EN | XUSB_MEM_SPACE_EN | XUSB_BUS_MASTER_EN;\r\nfpci_writel(tegra, value, XUSB_CFG_1);\r\nvalue = ipfs_readl(tegra, IPFS_XUSB_HOST_INTR_MASK_0);\r\nvalue |= IPFS_IP_INT_MASK;\r\nipfs_writel(tegra, value, IPFS_XUSB_HOST_INTR_MASK_0);\r\nipfs_writel(tegra, 0x80, IPFS_XUSB_HOST_CLKGATE_HYSTERESIS_0);\r\n}\r\nstatic int tegra_xusb_clk_enable(struct tegra_xusb *tegra)\r\n{\r\nint err;\r\nerr = clk_prepare_enable(tegra->pll_e);\r\nif (err < 0)\r\nreturn err;\r\nerr = clk_prepare_enable(tegra->host_clk);\r\nif (err < 0)\r\ngoto disable_plle;\r\nerr = clk_prepare_enable(tegra->ss_clk);\r\nif (err < 0)\r\ngoto disable_host;\r\nerr = clk_prepare_enable(tegra->falcon_clk);\r\nif (err < 0)\r\ngoto disable_ss;\r\nerr = clk_prepare_enable(tegra->fs_src_clk);\r\nif (err < 0)\r\ngoto disable_falc;\r\nerr = clk_prepare_enable(tegra->hs_src_clk);\r\nif (err < 0)\r\ngoto disable_fs_src;\r\nif (tegra->soc->scale_ss_clock) {\r\nerr = tegra_xusb_set_ss_clk(tegra, TEGRA_XHCI_SS_HIGH_SPEED);\r\nif (err < 0)\r\ngoto disable_hs_src;\r\n}\r\nreturn 0;\r\ndisable_hs_src:\r\nclk_disable_unprepare(tegra->hs_src_clk);\r\ndisable_fs_src:\r\nclk_disable_unprepare(tegra->fs_src_clk);\r\ndisable_falc:\r\nclk_disable_unprepare(tegra->falcon_clk);\r\ndisable_ss:\r\nclk_disable_unprepare(tegra->ss_clk);\r\ndisable_host:\r\nclk_disable_unprepare(tegra->host_clk);\r\ndisable_plle:\r\nclk_disable_unprepare(tegra->pll_e);\r\nreturn err;\r\n}\r\nstatic void tegra_xusb_clk_disable(struct tegra_xusb *tegra)\r\n{\r\nclk_disable_unprepare(tegra->pll_e);\r\nclk_disable_unprepare(tegra->host_clk);\r\nclk_disable_unprepare(tegra->ss_clk);\r\nclk_disable_unprepare(tegra->falcon_clk);\r\nclk_disable_unprepare(tegra->fs_src_clk);\r\nclk_disable_unprepare(tegra->hs_src_clk);\r\n}\r\nstatic int tegra_xusb_phy_enable(struct tegra_xusb *tegra)\r\n{\r\nunsigned int i;\r\nint err;\r\nfor (i = 0; i < tegra->num_phys; i++) {\r\nerr = phy_init(tegra->phys[i]);\r\nif (err)\r\ngoto disable_phy;\r\nerr = phy_power_on(tegra->phys[i]);\r\nif (err) {\r\nphy_exit(tegra->phys[i]);\r\ngoto disable_phy;\r\n}\r\n}\r\nreturn 0;\r\ndisable_phy:\r\nwhile (i--) {\r\nphy_power_off(tegra->phys[i]);\r\nphy_exit(tegra->phys[i]);\r\n}\r\nreturn err;\r\n}\r\nstatic void tegra_xusb_phy_disable(struct tegra_xusb *tegra)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < tegra->num_phys; i++) {\r\nphy_power_off(tegra->phys[i]);\r\nphy_exit(tegra->phys[i]);\r\n}\r\n}\r\nstatic int tegra_xusb_load_firmware(struct tegra_xusb *tegra)\r\n{\r\nunsigned int code_tag_blocks, code_size_blocks, code_blocks;\r\nstruct tegra_xusb_fw_header *header;\r\nstruct device *dev = tegra->dev;\r\nconst struct firmware *fw;\r\nunsigned long timeout;\r\ntime_t timestamp;\r\nstruct tm time;\r\nu64 address;\r\nu32 value;\r\nint err;\r\nerr = request_firmware(&fw, tegra->soc->firmware, tegra->dev);\r\nif (err < 0) {\r\ndev_err(tegra->dev, "failed to request firmware: %d\n", err);\r\nreturn err;\r\n}\r\nheader = (struct tegra_xusb_fw_header *)fw->data;\r\ntegra->fw.size = le32_to_cpu(header->fwimg_len);\r\ntegra->fw.virt = dma_alloc_coherent(tegra->dev, tegra->fw.size,\r\n&tegra->fw.phys, GFP_KERNEL);\r\nif (!tegra->fw.virt) {\r\ndev_err(tegra->dev, "failed to allocate memory for firmware\n");\r\nrelease_firmware(fw);\r\nreturn -ENOMEM;\r\n}\r\nheader = (struct tegra_xusb_fw_header *)tegra->fw.virt;\r\nmemcpy(tegra->fw.virt, fw->data, tegra->fw.size);\r\nrelease_firmware(fw);\r\nif (csb_readl(tegra, XUSB_CSB_MP_ILOAD_BASE_LO) != 0) {\r\ndev_info(dev, "Firmware already loaded, Falcon state %#x\n",\r\ncsb_readl(tegra, XUSB_FALC_CPUCTL));\r\nreturn 0;\r\n}\r\ncsb_writel(tegra, tegra->fw.size, XUSB_CSB_MP_ILOAD_ATTR);\r\naddress = tegra->fw.phys + sizeof(*header);\r\ncsb_writel(tegra, address >> 32, XUSB_CSB_MP_ILOAD_BASE_HI);\r\ncsb_writel(tegra, address, XUSB_CSB_MP_ILOAD_BASE_LO);\r\ncsb_writel(tegra, APMAP_BOOTPATH, XUSB_CSB_MP_APMAP);\r\ncsb_writel(tegra, L2IMEMOP_INVALIDATE_ALL, XUSB_CSB_MP_L2IMEMOP_TRIG);\r\ncode_tag_blocks = DIV_ROUND_UP(le32_to_cpu(header->boot_codetag),\r\nIMEM_BLOCK_SIZE);\r\ncode_size_blocks = DIV_ROUND_UP(le32_to_cpu(header->boot_codesize),\r\nIMEM_BLOCK_SIZE);\r\ncode_blocks = code_tag_blocks + code_size_blocks;\r\nvalue = ((code_tag_blocks & L2IMEMOP_SIZE_SRC_OFFSET_MASK) <<\r\nL2IMEMOP_SIZE_SRC_OFFSET_SHIFT) |\r\n((code_size_blocks & L2IMEMOP_SIZE_SRC_COUNT_MASK) <<\r\nL2IMEMOP_SIZE_SRC_COUNT_SHIFT);\r\ncsb_writel(tegra, value, XUSB_CSB_MP_L2IMEMOP_SIZE);\r\ncsb_writel(tegra, L2IMEMOP_LOAD_LOCKED_RESULT,\r\nXUSB_CSB_MP_L2IMEMOP_TRIG);\r\ncsb_writel(tegra, code_size_blocks, XUSB_FALC_IMFILLCTL);\r\nvalue = ((code_tag_blocks & IMFILLRNG1_TAG_MASK) <<\r\nIMFILLRNG1_TAG_LO_SHIFT) |\r\n((code_blocks & IMFILLRNG1_TAG_MASK) <<\r\nIMFILLRNG1_TAG_HI_SHIFT);\r\ncsb_writel(tegra, value, XUSB_FALC_IMFILLRNG1);\r\ncsb_writel(tegra, 0, XUSB_FALC_DMACTL);\r\nmsleep(50);\r\ncsb_writel(tegra, le32_to_cpu(header->boot_codetag),\r\nXUSB_FALC_BOOTVEC);\r\ntimeout = jiffies + msecs_to_jiffies(5);\r\ncsb_writel(tegra, CPUCTL_STARTCPU, XUSB_FALC_CPUCTL);\r\nwhile (time_before(jiffies, timeout)) {\r\nif (csb_readl(tegra, XUSB_FALC_CPUCTL) == CPUCTL_STATE_STOPPED)\r\nbreak;\r\nusleep_range(100, 200);\r\n}\r\nif (csb_readl(tegra, XUSB_FALC_CPUCTL) != CPUCTL_STATE_STOPPED) {\r\ndev_err(dev, "Falcon failed to start, state: %#x\n",\r\ncsb_readl(tegra, XUSB_FALC_CPUCTL));\r\nreturn -EIO;\r\n}\r\ntimestamp = le32_to_cpu(header->fwimg_created_time);\r\ntime_to_tm(timestamp, 0, &time);\r\ndev_info(dev, "Firmware timestamp: %ld-%02d-%02d %02d:%02d:%02d UTC\n",\r\ntime.tm_year + 1900, time.tm_mon + 1, time.tm_mday,\r\ntime.tm_hour, time.tm_min, time.tm_sec);\r\nreturn 0;\r\n}\r\nstatic int tegra_xusb_probe(struct platform_device *pdev)\r\n{\r\nstruct tegra_xusb_mbox_msg msg;\r\nstruct resource *res, *regs;\r\nstruct tegra_xusb *tegra;\r\nstruct xhci_hcd *xhci;\r\nunsigned int i, j, k;\r\nstruct phy *phy;\r\nint err;\r\nBUILD_BUG_ON(sizeof(struct tegra_xusb_fw_header) != 256);\r\ntegra = devm_kzalloc(&pdev->dev, sizeof(*tegra), GFP_KERNEL);\r\nif (!tegra)\r\nreturn -ENOMEM;\r\ntegra->soc = of_device_get_match_data(&pdev->dev);\r\nmutex_init(&tegra->lock);\r\ntegra->dev = &pdev->dev;\r\nregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ntegra->regs = devm_ioremap_resource(&pdev->dev, regs);\r\nif (IS_ERR(tegra->regs))\r\nreturn PTR_ERR(tegra->regs);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\ntegra->fpci_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(tegra->fpci_base))\r\nreturn PTR_ERR(tegra->fpci_base);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 2);\r\ntegra->ipfs_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(tegra->ipfs_base))\r\nreturn PTR_ERR(tegra->ipfs_base);\r\ntegra->xhci_irq = platform_get_irq(pdev, 0);\r\nif (tegra->xhci_irq < 0)\r\nreturn tegra->xhci_irq;\r\ntegra->mbox_irq = platform_get_irq(pdev, 1);\r\nif (tegra->mbox_irq < 0)\r\nreturn tegra->mbox_irq;\r\ntegra->padctl = tegra_xusb_padctl_get(&pdev->dev);\r\nif (IS_ERR(tegra->padctl))\r\nreturn PTR_ERR(tegra->padctl);\r\ntegra->host_rst = devm_reset_control_get(&pdev->dev, "xusb_host");\r\nif (IS_ERR(tegra->host_rst)) {\r\nerr = PTR_ERR(tegra->host_rst);\r\ndev_err(&pdev->dev, "failed to get xusb_host reset: %d\n", err);\r\ngoto put_padctl;\r\n}\r\ntegra->ss_rst = devm_reset_control_get(&pdev->dev, "xusb_ss");\r\nif (IS_ERR(tegra->ss_rst)) {\r\nerr = PTR_ERR(tegra->ss_rst);\r\ndev_err(&pdev->dev, "failed to get xusb_ss reset: %d\n", err);\r\ngoto put_padctl;\r\n}\r\ntegra->host_clk = devm_clk_get(&pdev->dev, "xusb_host");\r\nif (IS_ERR(tegra->host_clk)) {\r\nerr = PTR_ERR(tegra->host_clk);\r\ndev_err(&pdev->dev, "failed to get xusb_host: %d\n", err);\r\ngoto put_padctl;\r\n}\r\ntegra->falcon_clk = devm_clk_get(&pdev->dev, "xusb_falcon_src");\r\nif (IS_ERR(tegra->falcon_clk)) {\r\nerr = PTR_ERR(tegra->falcon_clk);\r\ndev_err(&pdev->dev, "failed to get xusb_falcon_src: %d\n", err);\r\ngoto put_padctl;\r\n}\r\ntegra->ss_clk = devm_clk_get(&pdev->dev, "xusb_ss");\r\nif (IS_ERR(tegra->ss_clk)) {\r\nerr = PTR_ERR(tegra->ss_clk);\r\ndev_err(&pdev->dev, "failed to get xusb_ss: %d\n", err);\r\ngoto put_padctl;\r\n}\r\ntegra->ss_src_clk = devm_clk_get(&pdev->dev, "xusb_ss_src");\r\nif (IS_ERR(tegra->ss_src_clk)) {\r\nerr = PTR_ERR(tegra->ss_src_clk);\r\ndev_err(&pdev->dev, "failed to get xusb_ss_src: %d\n", err);\r\ngoto put_padctl;\r\n}\r\ntegra->hs_src_clk = devm_clk_get(&pdev->dev, "xusb_hs_src");\r\nif (IS_ERR(tegra->hs_src_clk)) {\r\nerr = PTR_ERR(tegra->hs_src_clk);\r\ndev_err(&pdev->dev, "failed to get xusb_hs_src: %d\n", err);\r\ngoto put_padctl;\r\n}\r\ntegra->fs_src_clk = devm_clk_get(&pdev->dev, "xusb_fs_src");\r\nif (IS_ERR(tegra->fs_src_clk)) {\r\nerr = PTR_ERR(tegra->fs_src_clk);\r\ndev_err(&pdev->dev, "failed to get xusb_fs_src: %d\n", err);\r\ngoto put_padctl;\r\n}\r\ntegra->pll_u_480m = devm_clk_get(&pdev->dev, "pll_u_480m");\r\nif (IS_ERR(tegra->pll_u_480m)) {\r\nerr = PTR_ERR(tegra->pll_u_480m);\r\ndev_err(&pdev->dev, "failed to get pll_u_480m: %d\n", err);\r\ngoto put_padctl;\r\n}\r\ntegra->clk_m = devm_clk_get(&pdev->dev, "clk_m");\r\nif (IS_ERR(tegra->clk_m)) {\r\nerr = PTR_ERR(tegra->clk_m);\r\ndev_err(&pdev->dev, "failed to get clk_m: %d\n", err);\r\ngoto put_padctl;\r\n}\r\ntegra->pll_e = devm_clk_get(&pdev->dev, "pll_e");\r\nif (IS_ERR(tegra->pll_e)) {\r\nerr = PTR_ERR(tegra->pll_e);\r\ndev_err(&pdev->dev, "failed to get pll_e: %d\n", err);\r\ngoto put_padctl;\r\n}\r\ntegra->supplies = devm_kcalloc(&pdev->dev, tegra->soc->num_supplies,\r\nsizeof(*tegra->supplies), GFP_KERNEL);\r\nif (!tegra->supplies) {\r\nerr = -ENOMEM;\r\ngoto put_padctl;\r\n}\r\nfor (i = 0; i < tegra->soc->num_supplies; i++)\r\ntegra->supplies[i].supply = tegra->soc->supply_names[i];\r\nerr = devm_regulator_bulk_get(&pdev->dev, tegra->soc->num_supplies,\r\ntegra->supplies);\r\nif (err) {\r\ndev_err(&pdev->dev, "failed to get regulators: %d\n", err);\r\ngoto put_padctl;\r\n}\r\nfor (i = 0; i < tegra->soc->num_types; i++)\r\ntegra->num_phys += tegra->soc->phy_types[i].num;\r\ntegra->phys = devm_kcalloc(&pdev->dev, tegra->num_phys,\r\nsizeof(*tegra->phys), GFP_KERNEL);\r\nif (!tegra->phys) {\r\nerr = -ENOMEM;\r\ngoto put_padctl;\r\n}\r\nfor (i = 0, k = 0; i < tegra->soc->num_types; i++) {\r\nchar prop[8];\r\nfor (j = 0; j < tegra->soc->phy_types[i].num; j++) {\r\nsnprintf(prop, sizeof(prop), "%s-%d",\r\ntegra->soc->phy_types[i].name, j);\r\nphy = devm_phy_optional_get(&pdev->dev, prop);\r\nif (IS_ERR(phy)) {\r\ndev_err(&pdev->dev,\r\n"failed to get PHY %s: %ld\n", prop,\r\nPTR_ERR(phy));\r\nerr = PTR_ERR(phy);\r\ngoto put_padctl;\r\n}\r\ntegra->phys[k++] = phy;\r\n}\r\n}\r\nerr = tegra_xusb_clk_enable(tegra);\r\nif (err) {\r\ndev_err(&pdev->dev, "failed to enable clocks: %d\n", err);\r\ngoto put_padctl;\r\n}\r\nerr = regulator_bulk_enable(tegra->soc->num_supplies, tegra->supplies);\r\nif (err) {\r\ndev_err(&pdev->dev, "failed to enable regulators: %d\n", err);\r\ngoto disable_clk;\r\n}\r\nerr = tegra_xusb_phy_enable(tegra);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to enable PHYs: %d\n", err);\r\ngoto disable_regulator;\r\n}\r\ntegra_xusb_ipfs_config(tegra, regs);\r\nerr = tegra_xusb_load_firmware(tegra);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to load firmware: %d\n", err);\r\ngoto disable_phy;\r\n}\r\ntegra->hcd = usb_create_hcd(&tegra_xhci_hc_driver, &pdev->dev,\r\ndev_name(&pdev->dev));\r\nif (!tegra->hcd) {\r\nerr = -ENOMEM;\r\ngoto disable_phy;\r\n}\r\nplatform_set_drvdata(pdev, tegra);\r\ntegra->hcd->regs = tegra->regs;\r\ntegra->hcd->rsrc_start = regs->start;\r\ntegra->hcd->rsrc_len = resource_size(regs);\r\nerr = usb_add_hcd(tegra->hcd, tegra->xhci_irq, IRQF_SHARED);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to add USB HCD: %d\n", err);\r\ngoto put_usb2;\r\n}\r\ndevice_wakeup_enable(tegra->hcd->self.controller);\r\nxhci = hcd_to_xhci(tegra->hcd);\r\nxhci->shared_hcd = usb_create_shared_hcd(&tegra_xhci_hc_driver,\r\n&pdev->dev,\r\ndev_name(&pdev->dev),\r\ntegra->hcd);\r\nif (!xhci->shared_hcd) {\r\ndev_err(&pdev->dev, "failed to create shared HCD\n");\r\nerr = -ENOMEM;\r\ngoto remove_usb2;\r\n}\r\nerr = usb_add_hcd(xhci->shared_hcd, tegra->xhci_irq, IRQF_SHARED);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to add shared HCD: %d\n", err);\r\ngoto put_usb3;\r\n}\r\nmutex_lock(&tegra->lock);\r\nmsg.cmd = MBOX_CMD_MSG_ENABLED;\r\nmsg.data = 0;\r\nerr = tegra_xusb_mbox_send(tegra, &msg);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to enable messages: %d\n", err);\r\nmutex_unlock(&tegra->lock);\r\ngoto remove_usb3;\r\n}\r\nmutex_unlock(&tegra->lock);\r\nerr = devm_request_threaded_irq(&pdev->dev, tegra->mbox_irq,\r\ntegra_xusb_mbox_irq,\r\ntegra_xusb_mbox_thread, 0,\r\ndev_name(&pdev->dev), tegra);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to request IRQ: %d\n", err);\r\ngoto remove_usb3;\r\n}\r\nreturn 0;\r\nremove_usb3:\r\nusb_remove_hcd(xhci->shared_hcd);\r\nput_usb3:\r\nusb_put_hcd(xhci->shared_hcd);\r\nremove_usb2:\r\nusb_remove_hcd(tegra->hcd);\r\nput_usb2:\r\nusb_put_hcd(tegra->hcd);\r\ndisable_phy:\r\ntegra_xusb_phy_disable(tegra);\r\ndisable_regulator:\r\nregulator_bulk_disable(tegra->soc->num_supplies, tegra->supplies);\r\ndisable_clk:\r\ntegra_xusb_clk_disable(tegra);\r\nput_padctl:\r\ntegra_xusb_padctl_put(tegra->padctl);\r\nreturn err;\r\n}\r\nstatic int tegra_xusb_remove(struct platform_device *pdev)\r\n{\r\nstruct tegra_xusb *tegra = platform_get_drvdata(pdev);\r\nstruct xhci_hcd *xhci = hcd_to_xhci(tegra->hcd);\r\nusb_remove_hcd(xhci->shared_hcd);\r\nusb_put_hcd(xhci->shared_hcd);\r\nusb_remove_hcd(tegra->hcd);\r\nusb_put_hcd(tegra->hcd);\r\ndma_free_coherent(&pdev->dev, tegra->fw.size, tegra->fw.virt,\r\ntegra->fw.phys);\r\ntegra_xusb_phy_disable(tegra);\r\nregulator_bulk_disable(tegra->soc->num_supplies, tegra->supplies);\r\ntegra_xusb_clk_disable(tegra);\r\ntegra_xusb_padctl_put(tegra->padctl);\r\nreturn 0;\r\n}\r\nstatic int tegra_xusb_suspend(struct device *dev)\r\n{\r\nstruct tegra_xusb *tegra = dev_get_drvdata(dev);\r\nstruct xhci_hcd *xhci = hcd_to_xhci(tegra->hcd);\r\nbool wakeup = device_may_wakeup(dev);\r\nreturn xhci_suspend(xhci, wakeup);\r\n}\r\nstatic int tegra_xusb_resume(struct device *dev)\r\n{\r\nstruct tegra_xusb *tegra = dev_get_drvdata(dev);\r\nstruct xhci_hcd *xhci = hcd_to_xhci(tegra->hcd);\r\nreturn xhci_resume(xhci, 0);\r\n}\r\nstatic void tegra_xhci_quirks(struct device *dev, struct xhci_hcd *xhci)\r\n{\r\nxhci->quirks |= XHCI_PLAT;\r\n}\r\nstatic int tegra_xhci_setup(struct usb_hcd *hcd)\r\n{\r\nreturn xhci_gen_setup(hcd, tegra_xhci_quirks);\r\n}\r\nstatic int __init tegra_xusb_init(void)\r\n{\r\nxhci_init_driver(&tegra_xhci_hc_driver, &tegra_xhci_overrides);\r\nreturn platform_driver_register(&tegra_xusb_driver);\r\n}\r\nstatic void __exit tegra_xusb_exit(void)\r\n{\r\nplatform_driver_unregister(&tegra_xusb_driver);\r\n}
