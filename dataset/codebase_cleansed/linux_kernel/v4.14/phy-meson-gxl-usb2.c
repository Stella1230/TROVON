static int phy_meson_gxl_usb2_reset(struct phy *phy)\r\n{\r\nstruct phy_meson_gxl_usb2_priv *priv = phy_get_drvdata(phy);\r\nif (priv->is_enabled) {\r\nregmap_update_bits(priv->regmap, U2P_R0, U2P_R0_POWER_ON_RESET,\r\nU2P_R0_POWER_ON_RESET);\r\nudelay(RESET_COMPLETE_TIME);\r\nregmap_update_bits(priv->regmap, U2P_R0, U2P_R0_POWER_ON_RESET,\r\n0);\r\nudelay(RESET_COMPLETE_TIME);\r\n}\r\nreturn 0;\r\n}\r\nstatic int phy_meson_gxl_usb2_set_mode(struct phy *phy, enum phy_mode mode)\r\n{\r\nstruct phy_meson_gxl_usb2_priv *priv = phy_get_drvdata(phy);\r\nswitch (mode) {\r\ncase PHY_MODE_USB_HOST:\r\ncase PHY_MODE_USB_OTG:\r\nregmap_update_bits(priv->regmap, U2P_R0, U2P_R0_DM_PULLDOWN,\r\nU2P_R0_DM_PULLDOWN);\r\nregmap_update_bits(priv->regmap, U2P_R0, U2P_R0_DP_PULLDOWN,\r\nU2P_R0_DP_PULLDOWN);\r\nregmap_update_bits(priv->regmap, U2P_R0, U2P_R0_ID_PULLUP, 0);\r\nbreak;\r\ncase PHY_MODE_USB_DEVICE:\r\nregmap_update_bits(priv->regmap, U2P_R0, U2P_R0_DM_PULLDOWN,\r\n0);\r\nregmap_update_bits(priv->regmap, U2P_R0, U2P_R0_DP_PULLDOWN,\r\n0);\r\nregmap_update_bits(priv->regmap, U2P_R0, U2P_R0_ID_PULLUP,\r\nU2P_R0_ID_PULLUP);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nphy_meson_gxl_usb2_reset(phy);\r\npriv->mode = mode;\r\nreturn 0;\r\n}\r\nstatic int phy_meson_gxl_usb2_power_off(struct phy *phy)\r\n{\r\nstruct phy_meson_gxl_usb2_priv *priv = phy_get_drvdata(phy);\r\npriv->is_enabled = 0;\r\nregmap_update_bits(priv->regmap, U2P_R0, U2P_R0_POWER_ON_RESET,\r\nU2P_R0_POWER_ON_RESET);\r\nreturn 0;\r\n}\r\nstatic int phy_meson_gxl_usb2_power_on(struct phy *phy)\r\n{\r\nstruct phy_meson_gxl_usb2_priv *priv = phy_get_drvdata(phy);\r\nint ret;\r\npriv->is_enabled = 1;\r\nregmap_update_bits(priv->regmap, U2P_R0, U2P_R0_POWER_ON_RESET, 0);\r\nret = phy_meson_gxl_usb2_set_mode(phy, priv->mode);\r\nif (ret) {\r\nphy_meson_gxl_usb2_power_off(phy);\r\ndev_err(&phy->dev, "Failed to initialize PHY with mode %d\n",\r\npriv->mode);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int phy_meson_gxl_usb2_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct phy_provider *phy_provider;\r\nstruct resource *res;\r\nstruct phy_meson_gxl_usb2_priv *priv;\r\nstruct phy *phy;\r\nvoid __iomem *base;\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, priv);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\nswitch (of_usb_get_dr_mode_by_phy(dev->of_node, -1)) {\r\ncase USB_DR_MODE_PERIPHERAL:\r\npriv->mode = PHY_MODE_USB_DEVICE;\r\nbreak;\r\ncase USB_DR_MODE_OTG:\r\npriv->mode = PHY_MODE_USB_OTG;\r\nbreak;\r\ncase USB_DR_MODE_HOST:\r\ndefault:\r\npriv->mode = PHY_MODE_USB_HOST;\r\nbreak;\r\n}\r\npriv->regmap = devm_regmap_init_mmio(dev, base,\r\n&phy_meson_gxl_usb2_regmap_conf);\r\nif (IS_ERR(priv->regmap))\r\nreturn PTR_ERR(priv->regmap);\r\nphy = devm_phy_create(dev, NULL, &phy_meson_gxl_usb2_ops);\r\nif (IS_ERR(phy)) {\r\ndev_err(dev, "failed to create PHY\n");\r\nreturn PTR_ERR(phy);\r\n}\r\nphy_set_drvdata(phy, priv);\r\nphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\r\nreturn PTR_ERR_OR_ZERO(phy_provider);\r\n}
