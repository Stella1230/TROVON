const struct atomisp_camera_caps *atomisp_get_default_camera_caps(void)\r\n{\r\nstatic const struct atomisp_camera_caps caps = {\r\n.sensor_num = 1,\r\n.sensor = {\r\n{ .stream_num = 1, },\r\n},\r\n};\r\nreturn &caps;\r\n}\r\nconst struct atomisp_platform_data *atomisp_get_platform_data(void)\r\n{\r\nreturn &pdata;\r\n}\r\nstatic int af_power_ctrl(struct v4l2_subdev *subdev, int flag)\r\n{\r\nstruct gmin_subdev *gs = find_gmin_subdev(subdev);\r\nif (gs && gs->v2p8_vcm_on == flag)\r\nreturn 0;\r\ngs->v2p8_vcm_on = flag;\r\nif (gs->v2p8_vcm_reg) {\r\nif (flag)\r\nreturn regulator_enable(gs->v2p8_vcm_reg);\r\nelse\r\nreturn regulator_disable(gs->v2p8_vcm_reg);\r\n}\r\nreturn 0;\r\n}\r\nconst struct camera_af_platform_data *camera_get_af_platform_data(void)\r\n{\r\nstatic struct camera_af_platform_data afpd = {\r\n.power_ctrl = af_power_ctrl,\r\n};\r\nreturn &afpd;\r\n}\r\nint atomisp_register_i2c_module(struct v4l2_subdev *subdev,\r\nstruct camera_sensor_platform_data *plat_data,\r\nenum intel_v4l2_subdev_type type)\r\n{\r\nint i;\r\nstruct i2c_board_info *bi;\r\nstruct gmin_subdev *gs;\r\nstruct i2c_client *client = v4l2_get_subdevdata(subdev);\r\nstruct acpi_device *adev;\r\ndev_info(&client->dev, "register atomisp i2c module type %d\n", type);\r\nadev = ACPI_COMPANION(&client->dev);\r\nif (adev)\r\nadev->power.flags.power_resources = 0;\r\nfor (i = 0; i < MAX_SUBDEVS; i++)\r\nif (!pdata.subdevs[i].type)\r\nbreak;\r\nif (pdata.subdevs[i].type)\r\nreturn -ENOMEM;\r\ngs = find_gmin_subdev(subdev);\r\npdata.subdevs[i].type = type;\r\npdata.subdevs[i].port = gs->csi_port;\r\npdata.subdevs[i].subdev = subdev;\r\npdata.subdevs[i].v4l2_subdev.i2c_adapter_id = client->adapter->nr;\r\nbi = &pdata.subdevs[i].v4l2_subdev.board_info;\r\nmemcpy(bi->type, client->name, I2C_NAME_SIZE);\r\nbi->flags = client->flags;\r\nbi->addr = client->addr;\r\nbi->irq = client->irq;\r\nbi->platform_data = plat_data;\r\nreturn 0;\r\n}\r\nstruct v4l2_subdev *atomisp_gmin_find_subdev(struct i2c_adapter *adapter,\r\nstruct i2c_board_info *board_info)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_SUBDEVS && pdata.subdevs[i].type; i++) {\r\nstruct intel_v4l2_subdev_table *sd = &pdata.subdevs[i];\r\nif (sd->v4l2_subdev.i2c_adapter_id == adapter->nr &&\r\nsd->v4l2_subdev.board_info.addr == board_info->addr)\r\nreturn sd->subdev;\r\n}\r\nreturn NULL;\r\n}\r\nint atomisp_gmin_remove_subdev(struct v4l2_subdev *sd)\r\n{\r\nint i, j;\r\nif (!sd)\r\nreturn 0;\r\nfor (i = 0; i < MAX_SUBDEVS; i++) {\r\nif (pdata.subdevs[i].subdev == sd) {\r\nfor (j = i + 1; j <= MAX_SUBDEVS; j++)\r\npdata.subdevs[j - 1] = pdata.subdevs[j];\r\n}\r\nif (gmin_subdevs[i].subdev == sd) {\r\nif (gmin_subdevs[i].gpio0)\r\ngpiod_put(gmin_subdevs[i].gpio0);\r\ngmin_subdevs[i].gpio0 = NULL;\r\nif (gmin_subdevs[i].gpio1)\r\ngpiod_put(gmin_subdevs[i].gpio1);\r\ngmin_subdevs[i].gpio1 = NULL;\r\nif (pmic_id == PMIC_REGULATOR) {\r\nregulator_put(gmin_subdevs[i].v1p8_reg);\r\nregulator_put(gmin_subdevs[i].v2p8_reg);\r\nregulator_put(gmin_subdevs[i].v1p2_reg);\r\nregulator_put(gmin_subdevs[i].v2p8_vcm_reg);\r\n}\r\ngmin_subdevs[i].subdev = NULL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int gmin_platform_init(struct i2c_client *client)\r\n{\r\nreturn 0;\r\n}\r\nstatic int gmin_platform_deinit(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic struct gmin_subdev *gmin_subdev_add(struct v4l2_subdev *subdev)\r\n{\r\nint i, ret;\r\nstruct device *dev;\r\nstruct i2c_client *client = v4l2_get_subdevdata(subdev);\r\nif (!pmic_id)\r\npmic_id = PMIC_REGULATOR;\r\nif (!client)\r\nreturn NULL;\r\ndev = &client->dev;\r\nfor (i = 0; i < MAX_SUBDEVS && gmin_subdevs[i].subdev; i++)\r\n;\r\nif (i >= MAX_SUBDEVS)\r\nreturn NULL;\r\ndev_info(dev,\r\n"gmin: initializing atomisp module subdev data.PMIC ID %d\n",\r\npmic_id);\r\ngmin_subdevs[i].subdev = subdev;\r\ngmin_subdevs[i].clock_num = gmin_get_var_int(dev, "CamClk", 0);\r\ngmin_subdevs[i].clock_src = gmin_get_var_int(dev, "ClkSrc",\r\nVLV2_CLK_PLL_19P2MHZ);\r\ngmin_subdevs[i].csi_port = gmin_get_var_int(dev, "CsiPort", 0);\r\ngmin_subdevs[i].csi_lanes = gmin_get_var_int(dev, "CsiLanes", 1);\r\ngmin_subdevs[i].gpio0 = gpiod_get_index(dev, NULL, 0, GPIOD_OUT_LOW);\r\ngmin_subdevs[i].gpio1 = gpiod_get_index(dev, NULL, 1, GPIOD_OUT_LOW);\r\nif (!IS_ERR(gmin_subdevs[i].gpio0)) {\r\nret = gpiod_direction_output(gmin_subdevs[i].gpio0, 0);\r\nif (ret)\r\ndev_err(dev, "gpio0 set output failed: %d\n", ret);\r\n} else {\r\ngmin_subdevs[i].gpio0 = NULL;\r\n}\r\nif (!IS_ERR(gmin_subdevs[i].gpio1)) {\r\nret = gpiod_direction_output(gmin_subdevs[i].gpio1, 0);\r\nif (ret)\r\ndev_err(dev, "gpio1 set output failed: %d\n", ret);\r\n} else {\r\ngmin_subdevs[i].gpio1 = NULL;\r\n}\r\nif (pmic_id == PMIC_REGULATOR) {\r\ngmin_subdevs[i].v1p8_reg = regulator_get(dev, "V1P8SX");\r\ngmin_subdevs[i].v2p8_reg = regulator_get(dev, "V2P8SX");\r\ngmin_subdevs[i].v1p2_reg = regulator_get(dev, "V1P2A");\r\ngmin_subdevs[i].v2p8_vcm_reg = regulator_get(dev, "VPROG4B");\r\n}\r\nreturn &gmin_subdevs[i];\r\n}\r\nstatic struct gmin_subdev *find_gmin_subdev(struct v4l2_subdev *subdev)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_SUBDEVS; i++)\r\nif (gmin_subdevs[i].subdev == subdev)\r\nreturn &gmin_subdevs[i];\r\nreturn gmin_subdev_add(subdev);\r\n}\r\nstatic int gmin_gpio0_ctrl(struct v4l2_subdev *subdev, int on)\r\n{\r\nstruct gmin_subdev *gs = find_gmin_subdev(subdev);\r\nif (gs && gs->gpio0) {\r\ngpiod_set_value(gs->gpio0, on);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int gmin_gpio1_ctrl(struct v4l2_subdev *subdev, int on)\r\n{\r\nstruct gmin_subdev *gs = find_gmin_subdev(subdev);\r\nif (gs && gs->gpio1) {\r\ngpiod_set_value(gs->gpio1, on);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int gmin_v1p2_ctrl(struct v4l2_subdev *subdev, int on)\r\n{\r\nstruct gmin_subdev *gs = find_gmin_subdev(subdev);\r\nif (gs && gs->v1p2_on == on)\r\nreturn 0;\r\ngs->v1p2_on = on;\r\nif (gs->v1p2_reg) {\r\nif (on)\r\nreturn regulator_enable(gs->v1p2_reg);\r\nelse\r\nreturn regulator_disable(gs->v1p2_reg);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int gmin_v1p8_ctrl(struct v4l2_subdev *subdev, int on)\r\n{\r\nstruct gmin_subdev *gs = find_gmin_subdev(subdev);\r\nint ret;\r\nif (v1p8_gpio == V1P8_GPIO_UNSET) {\r\nv1p8_gpio = gmin_get_var_int(NULL, "V1P8GPIO", V1P8_GPIO_NONE);\r\nif (v1p8_gpio != V1P8_GPIO_NONE) {\r\npr_info("atomisp_gmin_platform: 1.8v power on GPIO %d\n",\r\nv1p8_gpio);\r\nret = gpio_request(v1p8_gpio, "camera_v1p8_en");\r\nif (!ret)\r\nret = gpio_direction_output(v1p8_gpio, 0);\r\nif (ret)\r\npr_err("V1P8 GPIO initialization failed\n");\r\n}\r\n}\r\nif (gs && gs->v1p8_on == on)\r\nreturn 0;\r\ngs->v1p8_on = on;\r\nif (v1p8_gpio >= 0)\r\ngpio_set_value(v1p8_gpio, on);\r\nif (gs->v1p8_reg) {\r\nregulator_set_voltage(gs->v1p8_reg, 1800000, 1800000);\r\nif (on)\r\nreturn regulator_enable(gs->v1p8_reg);\r\nelse\r\nreturn regulator_disable(gs->v1p8_reg);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int gmin_v2p8_ctrl(struct v4l2_subdev *subdev, int on)\r\n{\r\nstruct gmin_subdev *gs = find_gmin_subdev(subdev);\r\nint ret;\r\nif (v2p8_gpio == V2P8_GPIO_UNSET) {\r\nv2p8_gpio = gmin_get_var_int(NULL, "V2P8GPIO", V2P8_GPIO_NONE);\r\nif (v2p8_gpio != V2P8_GPIO_NONE) {\r\npr_info("atomisp_gmin_platform: 2.8v power on GPIO %d\n",\r\nv2p8_gpio);\r\nret = gpio_request(v2p8_gpio, "camera_v2p8");\r\nif (!ret)\r\nret = gpio_direction_output(v2p8_gpio, 0);\r\nif (ret)\r\npr_err("V2P8 GPIO initialization failed\n");\r\n}\r\n}\r\nif (gs && gs->v2p8_on == on)\r\nreturn 0;\r\ngs->v2p8_on = on;\r\nif (v2p8_gpio >= 0)\r\ngpio_set_value(v2p8_gpio, on);\r\nif (gs->v2p8_reg) {\r\nregulator_set_voltage(gs->v2p8_reg, 2900000, 2900000);\r\nif (on)\r\nreturn regulator_enable(gs->v2p8_reg);\r\nelse\r\nreturn regulator_disable(gs->v2p8_reg);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int gmin_flisclk_ctrl(struct v4l2_subdev *subdev, int on)\r\n{\r\nint ret = 0;\r\nstruct gmin_subdev *gs = find_gmin_subdev(subdev);\r\nif (on)\r\nret = vlv2_plat_set_clock_freq(gs->clock_num, gs->clock_src);\r\nif (ret)\r\nreturn ret;\r\nreturn vlv2_plat_configure_clock(gs->clock_num,\r\non ? VLV2_CLK_ON : VLV2_CLK_OFF);\r\n}\r\nstatic int gmin_csi_cfg(struct v4l2_subdev *sd, int flag)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct gmin_subdev *gs = find_gmin_subdev(sd);\r\nif (!client || !gs)\r\nreturn -ENODEV;\r\nreturn camera_sensor_csi(sd, gs->csi_port, gs->csi_lanes,\r\ngs->csi_fmt, gs->csi_bayer, flag);\r\n}\r\nstatic struct camera_vcm_control *gmin_get_vcm_ctrl(struct v4l2_subdev *subdev,\r\nchar *camera_module)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(subdev);\r\nstruct gmin_subdev *gs = find_gmin_subdev(subdev);\r\nstruct camera_vcm_control *vcm;\r\nif (client == NULL || gs == NULL)\r\nreturn NULL;\r\nif (!camera_module)\r\nreturn NULL;\r\nmutex_lock(&vcm_lock);\r\nlist_for_each_entry(vcm, &vcm_devices, list) {\r\nif (!strcmp(camera_module, vcm->camera_module)) {\r\nmutex_unlock(&vcm_lock);\r\nreturn vcm;\r\n}\r\n}\r\nmutex_unlock(&vcm_lock);\r\nreturn NULL;\r\n}\r\nstruct camera_sensor_platform_data *gmin_camera_platform_data(\r\nstruct v4l2_subdev *subdev,\r\nenum atomisp_input_format csi_format,\r\nenum atomisp_bayer_order csi_bayer)\r\n{\r\nstruct gmin_subdev *gs = find_gmin_subdev(subdev);\r\ngs->csi_fmt = csi_format;\r\ngs->csi_bayer = csi_bayer;\r\nreturn &gmin_plat;\r\n}\r\nint atomisp_gmin_register_vcm_control(struct camera_vcm_control *vcmCtrl)\r\n{\r\nif (!vcmCtrl)\r\nreturn -EINVAL;\r\nmutex_lock(&vcm_lock);\r\nlist_add_tail(&vcmCtrl->list, &vcm_devices);\r\nmutex_unlock(&vcm_lock);\r\nreturn 0;\r\n}\r\nint gmin_get_config_var(struct device *dev, const char *var, char *out,\r\nsize_t *out_len)\r\n{\r\nchar var8[CFG_VAR_NAME_MAX];\r\nefi_char16_t var16[CFG_VAR_NAME_MAX];\r\nstruct efivar_entry *ev;\r\nint i, j, ret;\r\nif (dev && ACPI_COMPANION(dev))\r\ndev = &ACPI_COMPANION(dev)->dev;\r\nif (dev)\r\nret = snprintf(var8, sizeof(var8), "%s_%s", dev_name(dev), var);\r\nelse\r\nret = snprintf(var8, sizeof(var8), "gmin_%s", var);\r\nif (ret < 0 || ret >= sizeof(var8) - 1)\r\nreturn -EINVAL;\r\nfor (i = 0; i < ARRAY_SIZE(hard_vars); i++) {\r\nif (dmi_match(DMI_BOARD_NAME, hard_vars[i].dmi_board_name)) {\r\nfor (j = 0; hard_vars[i].vars[j].name; j++) {\r\nsize_t vl;\r\nconst struct gmin_cfg_var *gv;\r\ngv = &hard_vars[i].vars[j];\r\nvl = strlen(gv->val);\r\nif (strcmp(var8, gv->name))\r\ncontinue;\r\nif (vl > *out_len - 1)\r\nreturn -ENOSPC;\r\nmemcpy(out, gv->val, min(*out_len, vl+1));\r\nout[*out_len-1] = 0;\r\n*out_len = vl;\r\nreturn 0;\r\n}\r\n}\r\n}\r\nmemset(var16, 0, sizeof(var16));\r\nfor (i = 0; i < sizeof(var8) && var8[i]; i++)\r\nvar16[i] = var8[i];\r\nif (*out_len > ULONG_MAX)\r\nreturn -EINVAL;\r\nev = kzalloc(sizeof(*ev), GFP_KERNEL);\r\nif (!ev)\r\nreturn -ENOMEM;\r\nmemcpy(&ev->var.VariableName, var16, sizeof(var16));\r\nev->var.VendorGuid = GMIN_CFG_VAR_EFI_GUID;\r\nev->var.DataSize = *out_len;\r\nret = efivar_entry_get(ev, &ev->var.Attributes,\r\n&ev->var.DataSize, ev->var.Data);\r\nif (ret == 0) {\r\nmemcpy(out, ev->var.Data, ev->var.DataSize);\r\n*out_len = ev->var.DataSize;\r\n} else if (dev) {\r\ndev_warn(dev, "Failed to find gmin variable %s\n", var8);\r\n}\r\nkfree(ev);\r\nreturn ret;\r\n}\r\nint gmin_get_var_int(struct device *dev, const char *var, int def)\r\n{\r\nchar val[CFG_VAR_NAME_MAX];\r\nsize_t len = sizeof(val);\r\nlong result;\r\nint ret;\r\nret = gmin_get_config_var(dev, var, val, &len);\r\nif (!ret) {\r\nval[len] = 0;\r\nret = kstrtol(val, 0, &result);\r\n}\r\nreturn ret ? def : result;\r\n}\r\nint camera_sensor_csi(struct v4l2_subdev *sd, u32 port,\r\nu32 lanes, u32 format, u32 bayer_order, int flag)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct camera_mipi_info *csi = NULL;\r\nif (flag) {\r\ncsi = kzalloc(sizeof(*csi), GFP_KERNEL);\r\nif (!csi) {\r\ndev_err(&client->dev, "out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\ncsi->port = port;\r\ncsi->num_lanes = lanes;\r\ncsi->input_format = format;\r\ncsi->raw_bayer_order = bayer_order;\r\nv4l2_set_subdev_hostdata(sd, (void *)csi);\r\ncsi->metadata_format = ATOMISP_INPUT_FORMAT_EMBEDDED;\r\ncsi->metadata_effective_width = NULL;\r\ndev_info(&client->dev,\r\n"camera pdata: port: %d lanes: %d order: %8.8x\n",\r\nport, lanes, bayer_order);\r\n} else {\r\ncsi = v4l2_get_subdev_hostdata(sd);\r\nkfree(csi);\r\n}\r\nreturn 0;\r\n}\r\nstatic void isp_pm_cap_fixup(struct pci_dev *dev)\r\n{\r\ndev_info(&dev->dev, "Disabling PCI power management on camera ISP\n");\r\ndev->pm_cap = 0;\r\n}
