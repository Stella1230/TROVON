static ssize_t iio_trigger_read_name(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_trigger *trig = to_iio_trigger(dev);\r\nreturn sprintf(buf, "%s\n", trig->name);\r\n}\r\nint iio_trigger_register(struct iio_trigger *trig_info)\r\n{\r\nint ret;\r\nif (!trig_info->ops)\r\nreturn -EINVAL;\r\ntrig_info->id = ida_simple_get(&iio_trigger_ida, 0, 0, GFP_KERNEL);\r\nif (trig_info->id < 0)\r\nreturn trig_info->id;\r\ndev_set_name(&trig_info->dev, "trigger%ld",\r\n(unsigned long) trig_info->id);\r\nret = device_add(&trig_info->dev);\r\nif (ret)\r\ngoto error_unregister_id;\r\nmutex_lock(&iio_trigger_list_lock);\r\nif (__iio_trigger_find_by_name(trig_info->name)) {\r\npr_err("Duplicate trigger name '%s'\n", trig_info->name);\r\nret = -EEXIST;\r\ngoto error_device_del;\r\n}\r\nlist_add_tail(&trig_info->list, &iio_trigger_list);\r\nmutex_unlock(&iio_trigger_list_lock);\r\nreturn 0;\r\nerror_device_del:\r\nmutex_unlock(&iio_trigger_list_lock);\r\ndevice_del(&trig_info->dev);\r\nerror_unregister_id:\r\nida_simple_remove(&iio_trigger_ida, trig_info->id);\r\nreturn ret;\r\n}\r\nvoid iio_trigger_unregister(struct iio_trigger *trig_info)\r\n{\r\nmutex_lock(&iio_trigger_list_lock);\r\nlist_del(&trig_info->list);\r\nmutex_unlock(&iio_trigger_list_lock);\r\nida_simple_remove(&iio_trigger_ida, trig_info->id);\r\ndevice_del(&trig_info->dev);\r\n}\r\nint iio_trigger_set_immutable(struct iio_dev *indio_dev, struct iio_trigger *trig)\r\n{\r\nif (!indio_dev || !trig)\r\nreturn -EINVAL;\r\nmutex_lock(&indio_dev->mlock);\r\nWARN_ON(indio_dev->trig_readonly);\r\nindio_dev->trig = iio_trigger_get(trig);\r\nindio_dev->trig_readonly = true;\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn 0;\r\n}\r\nstatic struct iio_trigger *__iio_trigger_find_by_name(const char *name)\r\n{\r\nstruct iio_trigger *iter;\r\nlist_for_each_entry(iter, &iio_trigger_list, list)\r\nif (!strcmp(iter->name, name))\r\nreturn iter;\r\nreturn NULL;\r\n}\r\nstatic struct iio_trigger *iio_trigger_acquire_by_name(const char *name)\r\n{\r\nstruct iio_trigger *trig = NULL, *iter;\r\nmutex_lock(&iio_trigger_list_lock);\r\nlist_for_each_entry(iter, &iio_trigger_list, list)\r\nif (sysfs_streq(iter->name, name)) {\r\ntrig = iter;\r\niio_trigger_get(trig);\r\nbreak;\r\n}\r\nmutex_unlock(&iio_trigger_list_lock);\r\nreturn trig;\r\n}\r\nvoid iio_trigger_poll(struct iio_trigger *trig)\r\n{\r\nint i;\r\nif (!atomic_read(&trig->use_count)) {\r\natomic_set(&trig->use_count, CONFIG_IIO_CONSUMERS_PER_TRIGGER);\r\nfor (i = 0; i < CONFIG_IIO_CONSUMERS_PER_TRIGGER; i++) {\r\nif (trig->subirqs[i].enabled)\r\ngeneric_handle_irq(trig->subirq_base + i);\r\nelse\r\niio_trigger_notify_done(trig);\r\n}\r\n}\r\n}\r\nirqreturn_t iio_trigger_generic_data_rdy_poll(int irq, void *private)\r\n{\r\niio_trigger_poll(private);\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid iio_trigger_poll_chained(struct iio_trigger *trig)\r\n{\r\nint i;\r\nif (!atomic_read(&trig->use_count)) {\r\natomic_set(&trig->use_count, CONFIG_IIO_CONSUMERS_PER_TRIGGER);\r\nfor (i = 0; i < CONFIG_IIO_CONSUMERS_PER_TRIGGER; i++) {\r\nif (trig->subirqs[i].enabled)\r\nhandle_nested_irq(trig->subirq_base + i);\r\nelse\r\niio_trigger_notify_done(trig);\r\n}\r\n}\r\n}\r\nvoid iio_trigger_notify_done(struct iio_trigger *trig)\r\n{\r\nif (atomic_dec_and_test(&trig->use_count) && trig->ops->try_reenable)\r\nif (trig->ops->try_reenable(trig))\r\niio_trigger_poll(trig);\r\n}\r\nstatic int iio_trigger_get_irq(struct iio_trigger *trig)\r\n{\r\nint ret;\r\nmutex_lock(&trig->pool_lock);\r\nret = bitmap_find_free_region(trig->pool,\r\nCONFIG_IIO_CONSUMERS_PER_TRIGGER,\r\nilog2(1));\r\nmutex_unlock(&trig->pool_lock);\r\nif (ret >= 0)\r\nret += trig->subirq_base;\r\nreturn ret;\r\n}\r\nstatic void iio_trigger_put_irq(struct iio_trigger *trig, int irq)\r\n{\r\nmutex_lock(&trig->pool_lock);\r\nclear_bit(irq - trig->subirq_base, trig->pool);\r\nmutex_unlock(&trig->pool_lock);\r\n}\r\nstatic int iio_trigger_attach_poll_func(struct iio_trigger *trig,\r\nstruct iio_poll_func *pf)\r\n{\r\nint ret = 0;\r\nbool notinuse\r\n= bitmap_empty(trig->pool, CONFIG_IIO_CONSUMERS_PER_TRIGGER);\r\n__module_get(pf->indio_dev->info->driver_module);\r\npf->irq = iio_trigger_get_irq(trig);\r\nif (pf->irq < 0)\r\ngoto out_put_module;\r\nret = request_threaded_irq(pf->irq, pf->h, pf->thread,\r\npf->type, pf->name,\r\npf);\r\nif (ret < 0)\r\ngoto out_put_irq;\r\nif (trig->ops->set_trigger_state && notinuse) {\r\nret = trig->ops->set_trigger_state(trig, true);\r\nif (ret < 0)\r\ngoto out_free_irq;\r\n}\r\nif (pf->indio_dev->dev.parent == trig->dev.parent)\r\ntrig->attached_own_device = true;\r\nreturn ret;\r\nout_free_irq:\r\nfree_irq(pf->irq, pf);\r\nout_put_irq:\r\niio_trigger_put_irq(trig, pf->irq);\r\nout_put_module:\r\nmodule_put(pf->indio_dev->info->driver_module);\r\nreturn ret;\r\n}\r\nstatic int iio_trigger_detach_poll_func(struct iio_trigger *trig,\r\nstruct iio_poll_func *pf)\r\n{\r\nint ret = 0;\r\nbool no_other_users\r\n= (bitmap_weight(trig->pool,\r\nCONFIG_IIO_CONSUMERS_PER_TRIGGER)\r\n== 1);\r\nif (trig->ops->set_trigger_state && no_other_users) {\r\nret = trig->ops->set_trigger_state(trig, false);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (pf->indio_dev->dev.parent == trig->dev.parent)\r\ntrig->attached_own_device = false;\r\niio_trigger_put_irq(trig, pf->irq);\r\nfree_irq(pf->irq, pf);\r\nmodule_put(pf->indio_dev->info->driver_module);\r\nreturn ret;\r\n}\r\nirqreturn_t iio_pollfunc_store_time(int irq, void *p)\r\n{\r\nstruct iio_poll_func *pf = p;\r\npf->timestamp = iio_get_time_ns(pf->indio_dev);\r\nreturn IRQ_WAKE_THREAD;\r\n}\r\nstruct iio_poll_func\r\n*iio_alloc_pollfunc(irqreturn_t (*h)(int irq, void *p),\r\nirqreturn_t (*thread)(int irq, void *p),\r\nint type,\r\nstruct iio_dev *indio_dev,\r\nconst char *fmt,\r\n...)\r\n{\r\nva_list vargs;\r\nstruct iio_poll_func *pf;\r\npf = kmalloc(sizeof *pf, GFP_KERNEL);\r\nif (pf == NULL)\r\nreturn NULL;\r\nva_start(vargs, fmt);\r\npf->name = kvasprintf(GFP_KERNEL, fmt, vargs);\r\nva_end(vargs);\r\nif (pf->name == NULL) {\r\nkfree(pf);\r\nreturn NULL;\r\n}\r\npf->h = h;\r\npf->thread = thread;\r\npf->type = type;\r\npf->indio_dev = indio_dev;\r\nreturn pf;\r\n}\r\nvoid iio_dealloc_pollfunc(struct iio_poll_func *pf)\r\n{\r\nkfree(pf->name);\r\nkfree(pf);\r\n}\r\nstatic ssize_t iio_trigger_read_current(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nif (indio_dev->trig)\r\nreturn sprintf(buf, "%s\n", indio_dev->trig->name);\r\nreturn 0;\r\n}\r\nstatic ssize_t iio_trigger_write_current(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct iio_trigger *oldtrig = indio_dev->trig;\r\nstruct iio_trigger *trig;\r\nint ret;\r\nmutex_lock(&indio_dev->mlock);\r\nif (indio_dev->currentmode == INDIO_BUFFER_TRIGGERED) {\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn -EBUSY;\r\n}\r\nif (indio_dev->trig_readonly) {\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn -EPERM;\r\n}\r\nmutex_unlock(&indio_dev->mlock);\r\ntrig = iio_trigger_acquire_by_name(buf);\r\nif (oldtrig == trig) {\r\nret = len;\r\ngoto out_trigger_put;\r\n}\r\nif (trig && indio_dev->info->validate_trigger) {\r\nret = indio_dev->info->validate_trigger(indio_dev, trig);\r\nif (ret)\r\ngoto out_trigger_put;\r\n}\r\nif (trig && trig->ops->validate_device) {\r\nret = trig->ops->validate_device(trig, indio_dev);\r\nif (ret)\r\ngoto out_trigger_put;\r\n}\r\nindio_dev->trig = trig;\r\nif (oldtrig) {\r\nif (indio_dev->modes & INDIO_EVENT_TRIGGERED)\r\niio_trigger_detach_poll_func(oldtrig,\r\nindio_dev->pollfunc_event);\r\niio_trigger_put(oldtrig);\r\n}\r\nif (indio_dev->trig) {\r\nif (indio_dev->modes & INDIO_EVENT_TRIGGERED)\r\niio_trigger_attach_poll_func(indio_dev->trig,\r\nindio_dev->pollfunc_event);\r\n}\r\nreturn len;\r\nout_trigger_put:\r\nif (trig)\r\niio_trigger_put(trig);\r\nreturn ret;\r\n}\r\nstatic void iio_trig_release(struct device *device)\r\n{\r\nstruct iio_trigger *trig = to_iio_trigger(device);\r\nint i;\r\nif (trig->subirq_base) {\r\nfor (i = 0; i < CONFIG_IIO_CONSUMERS_PER_TRIGGER; i++) {\r\nirq_modify_status(trig->subirq_base + i,\r\nIRQ_NOAUTOEN,\r\nIRQ_NOREQUEST | IRQ_NOPROBE);\r\nirq_set_chip(trig->subirq_base + i,\r\nNULL);\r\nirq_set_handler(trig->subirq_base + i,\r\nNULL);\r\n}\r\nirq_free_descs(trig->subirq_base,\r\nCONFIG_IIO_CONSUMERS_PER_TRIGGER);\r\n}\r\nkfree(trig->name);\r\nkfree(trig);\r\n}\r\nstatic void iio_trig_subirqmask(struct irq_data *d)\r\n{\r\nstruct irq_chip *chip = irq_data_get_irq_chip(d);\r\nstruct iio_trigger *trig\r\n= container_of(chip,\r\nstruct iio_trigger, subirq_chip);\r\ntrig->subirqs[d->irq - trig->subirq_base].enabled = false;\r\n}\r\nstatic void iio_trig_subirqunmask(struct irq_data *d)\r\n{\r\nstruct irq_chip *chip = irq_data_get_irq_chip(d);\r\nstruct iio_trigger *trig\r\n= container_of(chip,\r\nstruct iio_trigger, subirq_chip);\r\ntrig->subirqs[d->irq - trig->subirq_base].enabled = true;\r\n}\r\nstatic struct iio_trigger *viio_trigger_alloc(const char *fmt, va_list vargs)\r\n{\r\nstruct iio_trigger *trig;\r\nint i;\r\ntrig = kzalloc(sizeof *trig, GFP_KERNEL);\r\nif (!trig)\r\nreturn NULL;\r\ntrig->dev.type = &iio_trig_type;\r\ntrig->dev.bus = &iio_bus_type;\r\ndevice_initialize(&trig->dev);\r\nmutex_init(&trig->pool_lock);\r\ntrig->subirq_base = irq_alloc_descs(-1, 0,\r\nCONFIG_IIO_CONSUMERS_PER_TRIGGER,\r\n0);\r\nif (trig->subirq_base < 0)\r\ngoto free_trig;\r\ntrig->name = kvasprintf(GFP_KERNEL, fmt, vargs);\r\nif (trig->name == NULL)\r\ngoto free_descs;\r\ntrig->subirq_chip.name = trig->name;\r\ntrig->subirq_chip.irq_mask = &iio_trig_subirqmask;\r\ntrig->subirq_chip.irq_unmask = &iio_trig_subirqunmask;\r\nfor (i = 0; i < CONFIG_IIO_CONSUMERS_PER_TRIGGER; i++) {\r\nirq_set_chip(trig->subirq_base + i, &trig->subirq_chip);\r\nirq_set_handler(trig->subirq_base + i, &handle_simple_irq);\r\nirq_modify_status(trig->subirq_base + i,\r\nIRQ_NOREQUEST | IRQ_NOAUTOEN, IRQ_NOPROBE);\r\n}\r\nget_device(&trig->dev);\r\nreturn trig;\r\nfree_descs:\r\nirq_free_descs(trig->subirq_base, CONFIG_IIO_CONSUMERS_PER_TRIGGER);\r\nfree_trig:\r\nkfree(trig);\r\nreturn NULL;\r\n}\r\nstruct iio_trigger *iio_trigger_alloc(const char *fmt, ...)\r\n{\r\nstruct iio_trigger *trig;\r\nva_list vargs;\r\nva_start(vargs, fmt);\r\ntrig = viio_trigger_alloc(fmt, vargs);\r\nva_end(vargs);\r\nreturn trig;\r\n}\r\nvoid iio_trigger_free(struct iio_trigger *trig)\r\n{\r\nif (trig)\r\nput_device(&trig->dev);\r\n}\r\nstatic void devm_iio_trigger_release(struct device *dev, void *res)\r\n{\r\niio_trigger_free(*(struct iio_trigger **)res);\r\n}\r\nstatic int devm_iio_trigger_match(struct device *dev, void *res, void *data)\r\n{\r\nstruct iio_trigger **r = res;\r\nif (!r || !*r) {\r\nWARN_ON(!r || !*r);\r\nreturn 0;\r\n}\r\nreturn *r == data;\r\n}\r\nstruct iio_trigger *devm_iio_trigger_alloc(struct device *dev,\r\nconst char *fmt, ...)\r\n{\r\nstruct iio_trigger **ptr, *trig;\r\nva_list vargs;\r\nptr = devres_alloc(devm_iio_trigger_release, sizeof(*ptr),\r\nGFP_KERNEL);\r\nif (!ptr)\r\nreturn NULL;\r\nva_start(vargs, fmt);\r\ntrig = viio_trigger_alloc(fmt, vargs);\r\nva_end(vargs);\r\nif (trig) {\r\n*ptr = trig;\r\ndevres_add(dev, ptr);\r\n} else {\r\ndevres_free(ptr);\r\n}\r\nreturn trig;\r\n}\r\nvoid devm_iio_trigger_free(struct device *dev, struct iio_trigger *iio_trig)\r\n{\r\nint rc;\r\nrc = devres_release(dev, devm_iio_trigger_release,\r\ndevm_iio_trigger_match, iio_trig);\r\nWARN_ON(rc);\r\n}\r\nstatic void devm_iio_trigger_unreg(struct device *dev, void *res)\r\n{\r\niio_trigger_unregister(*(struct iio_trigger **)res);\r\n}\r\nint devm_iio_trigger_register(struct device *dev, struct iio_trigger *trig_info)\r\n{\r\nstruct iio_trigger **ptr;\r\nint ret;\r\nptr = devres_alloc(devm_iio_trigger_unreg, sizeof(*ptr), GFP_KERNEL);\r\nif (!ptr)\r\nreturn -ENOMEM;\r\n*ptr = trig_info;\r\nret = iio_trigger_register(trig_info);\r\nif (!ret)\r\ndevres_add(dev, ptr);\r\nelse\r\ndevres_free(ptr);\r\nreturn ret;\r\n}\r\nvoid devm_iio_trigger_unregister(struct device *dev,\r\nstruct iio_trigger *trig_info)\r\n{\r\nint rc;\r\nrc = devres_release(dev, devm_iio_trigger_unreg, devm_iio_trigger_match,\r\ntrig_info);\r\nWARN_ON(rc);\r\n}\r\nbool iio_trigger_using_own(struct iio_dev *indio_dev)\r\n{\r\nreturn indio_dev->trig->attached_own_device;\r\n}\r\nint iio_trigger_validate_own_device(struct iio_trigger *trig,\r\nstruct iio_dev *indio_dev)\r\n{\r\nif (indio_dev->dev.parent != trig->dev.parent)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nvoid iio_device_register_trigger_consumer(struct iio_dev *indio_dev)\r\n{\r\nindio_dev->groups[indio_dev->groupcounter++] =\r\n&iio_trigger_consumer_attr_group;\r\n}\r\nvoid iio_device_unregister_trigger_consumer(struct iio_dev *indio_dev)\r\n{\r\nif (indio_dev->trig)\r\niio_trigger_put(indio_dev->trig);\r\n}\r\nint iio_triggered_buffer_postenable(struct iio_dev *indio_dev)\r\n{\r\nreturn iio_trigger_attach_poll_func(indio_dev->trig,\r\nindio_dev->pollfunc);\r\n}\r\nint iio_triggered_buffer_predisable(struct iio_dev *indio_dev)\r\n{\r\nreturn iio_trigger_detach_poll_func(indio_dev->trig,\r\nindio_dev->pollfunc);\r\n}
