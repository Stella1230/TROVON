static bool qlist_empty(struct qlist_head *q)\r\n{\r\nreturn !q->head;\r\n}\r\nstatic void qlist_init(struct qlist_head *q)\r\n{\r\nq->head = q->tail = NULL;\r\nq->bytes = 0;\r\n}\r\nstatic void qlist_put(struct qlist_head *q, struct qlist_node *qlink,\r\nsize_t size)\r\n{\r\nif (unlikely(qlist_empty(q)))\r\nq->head = qlink;\r\nelse\r\nq->tail->next = qlink;\r\nq->tail = qlink;\r\nqlink->next = NULL;\r\nq->bytes += size;\r\n}\r\nstatic void qlist_move_all(struct qlist_head *from, struct qlist_head *to)\r\n{\r\nif (unlikely(qlist_empty(from)))\r\nreturn;\r\nif (qlist_empty(to)) {\r\n*to = *from;\r\nqlist_init(from);\r\nreturn;\r\n}\r\nto->tail->next = from->head;\r\nto->tail = from->tail;\r\nto->bytes += from->bytes;\r\nqlist_init(from);\r\n}\r\nstatic struct kmem_cache *qlink_to_cache(struct qlist_node *qlink)\r\n{\r\nreturn virt_to_head_page(qlink)->slab_cache;\r\n}\r\nstatic void *qlink_to_object(struct qlist_node *qlink, struct kmem_cache *cache)\r\n{\r\nstruct kasan_free_meta *free_info =\r\ncontainer_of(qlink, struct kasan_free_meta,\r\nquarantine_link);\r\nreturn ((void *)free_info) - cache->kasan_info.free_meta_offset;\r\n}\r\nstatic void qlink_free(struct qlist_node *qlink, struct kmem_cache *cache)\r\n{\r\nvoid *object = qlink_to_object(qlink, cache);\r\nunsigned long flags;\r\nif (IS_ENABLED(CONFIG_SLAB))\r\nlocal_irq_save(flags);\r\n___cache_free(cache, object, _THIS_IP_);\r\nif (IS_ENABLED(CONFIG_SLAB))\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void qlist_free_all(struct qlist_head *q, struct kmem_cache *cache)\r\n{\r\nstruct qlist_node *qlink;\r\nif (unlikely(qlist_empty(q)))\r\nreturn;\r\nqlink = q->head;\r\nwhile (qlink) {\r\nstruct kmem_cache *obj_cache =\r\ncache ? cache : qlink_to_cache(qlink);\r\nstruct qlist_node *next = qlink->next;\r\nqlink_free(qlink, obj_cache);\r\nqlink = next;\r\n}\r\nqlist_init(q);\r\n}\r\nvoid quarantine_put(struct kasan_free_meta *info, struct kmem_cache *cache)\r\n{\r\nunsigned long flags;\r\nstruct qlist_head *q;\r\nstruct qlist_head temp = QLIST_INIT;\r\nlocal_irq_save(flags);\r\nq = this_cpu_ptr(&cpu_quarantine);\r\nqlist_put(q, &info->quarantine_link, cache->size);\r\nif (unlikely(q->bytes > QUARANTINE_PERCPU_SIZE)) {\r\nqlist_move_all(q, &temp);\r\nspin_lock(&quarantine_lock);\r\nWRITE_ONCE(quarantine_size, quarantine_size + temp.bytes);\r\nqlist_move_all(&temp, &global_quarantine[quarantine_tail]);\r\nif (global_quarantine[quarantine_tail].bytes >=\r\nREAD_ONCE(quarantine_batch_size)) {\r\nint new_tail;\r\nnew_tail = quarantine_tail + 1;\r\nif (new_tail == QUARANTINE_BATCHES)\r\nnew_tail = 0;\r\nif (new_tail != quarantine_head)\r\nquarantine_tail = new_tail;\r\n}\r\nspin_unlock(&quarantine_lock);\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\nvoid quarantine_reduce(void)\r\n{\r\nsize_t total_size, new_quarantine_size, percpu_quarantines;\r\nunsigned long flags;\r\nint srcu_idx;\r\nstruct qlist_head to_free = QLIST_INIT;\r\nif (likely(READ_ONCE(quarantine_size) <=\r\nREAD_ONCE(quarantine_max_size)))\r\nreturn;\r\nsrcu_idx = srcu_read_lock(&remove_cache_srcu);\r\nspin_lock_irqsave(&quarantine_lock, flags);\r\ntotal_size = (READ_ONCE(totalram_pages) << PAGE_SHIFT) /\r\nQUARANTINE_FRACTION;\r\npercpu_quarantines = QUARANTINE_PERCPU_SIZE * num_online_cpus();\r\nnew_quarantine_size = (total_size < percpu_quarantines) ?\r\n0 : total_size - percpu_quarantines;\r\nWRITE_ONCE(quarantine_max_size, new_quarantine_size);\r\nWRITE_ONCE(quarantine_batch_size, max((size_t)QUARANTINE_PERCPU_SIZE,\r\n2 * total_size / QUARANTINE_BATCHES));\r\nif (likely(quarantine_size > quarantine_max_size)) {\r\nqlist_move_all(&global_quarantine[quarantine_head], &to_free);\r\nWRITE_ONCE(quarantine_size, quarantine_size - to_free.bytes);\r\nquarantine_head++;\r\nif (quarantine_head == QUARANTINE_BATCHES)\r\nquarantine_head = 0;\r\n}\r\nspin_unlock_irqrestore(&quarantine_lock, flags);\r\nqlist_free_all(&to_free, NULL);\r\nsrcu_read_unlock(&remove_cache_srcu, srcu_idx);\r\n}\r\nstatic void qlist_move_cache(struct qlist_head *from,\r\nstruct qlist_head *to,\r\nstruct kmem_cache *cache)\r\n{\r\nstruct qlist_node *curr;\r\nif (unlikely(qlist_empty(from)))\r\nreturn;\r\ncurr = from->head;\r\nqlist_init(from);\r\nwhile (curr) {\r\nstruct qlist_node *next = curr->next;\r\nstruct kmem_cache *obj_cache = qlink_to_cache(curr);\r\nif (obj_cache == cache)\r\nqlist_put(to, curr, obj_cache->size);\r\nelse\r\nqlist_put(from, curr, obj_cache->size);\r\ncurr = next;\r\n}\r\n}\r\nstatic void per_cpu_remove_cache(void *arg)\r\n{\r\nstruct kmem_cache *cache = arg;\r\nstruct qlist_head to_free = QLIST_INIT;\r\nstruct qlist_head *q;\r\nq = this_cpu_ptr(&cpu_quarantine);\r\nqlist_move_cache(q, &to_free, cache);\r\nqlist_free_all(&to_free, cache);\r\n}\r\nvoid quarantine_remove_cache(struct kmem_cache *cache)\r\n{\r\nunsigned long flags, i;\r\nstruct qlist_head to_free = QLIST_INIT;\r\non_each_cpu(per_cpu_remove_cache, cache, 1);\r\nspin_lock_irqsave(&quarantine_lock, flags);\r\nfor (i = 0; i < QUARANTINE_BATCHES; i++) {\r\nif (qlist_empty(&global_quarantine[i]))\r\ncontinue;\r\nqlist_move_cache(&global_quarantine[i], &to_free, cache);\r\nspin_unlock_irqrestore(&quarantine_lock, flags);\r\ncond_resched();\r\nspin_lock_irqsave(&quarantine_lock, flags);\r\n}\r\nspin_unlock_irqrestore(&quarantine_lock, flags);\r\nqlist_free_all(&to_free, cache);\r\nsynchronize_srcu(&remove_cache_srcu);\r\n}
