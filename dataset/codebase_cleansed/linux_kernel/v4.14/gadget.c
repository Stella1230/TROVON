int dwc3_gadget_set_test_mode(struct dwc3 *dwc, int mode)\r\n{\r\nu32 reg;\r\nreg = dwc3_readl(dwc->regs, DWC3_DCTL);\r\nreg &= ~DWC3_DCTL_TSTCTRL_MASK;\r\nswitch (mode) {\r\ncase TEST_J:\r\ncase TEST_K:\r\ncase TEST_SE0_NAK:\r\ncase TEST_PACKET:\r\ncase TEST_FORCE_EN:\r\nreg |= mode << 1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndwc3_writel(dwc->regs, DWC3_DCTL, reg);\r\nreturn 0;\r\n}\r\nint dwc3_gadget_get_link_state(struct dwc3 *dwc)\r\n{\r\nu32 reg;\r\nreg = dwc3_readl(dwc->regs, DWC3_DSTS);\r\nreturn DWC3_DSTS_USBLNKST(reg);\r\n}\r\nint dwc3_gadget_set_link_state(struct dwc3 *dwc, enum dwc3_link_state state)\r\n{\r\nint retries = 10000;\r\nu32 reg;\r\nif (dwc->revision >= DWC3_REVISION_194A) {\r\nwhile (--retries) {\r\nreg = dwc3_readl(dwc->regs, DWC3_DSTS);\r\nif (reg & DWC3_DSTS_DCNRD)\r\nudelay(5);\r\nelse\r\nbreak;\r\n}\r\nif (retries <= 0)\r\nreturn -ETIMEDOUT;\r\n}\r\nreg = dwc3_readl(dwc->regs, DWC3_DCTL);\r\nreg &= ~DWC3_DCTL_ULSTCHNGREQ_MASK;\r\nreg |= DWC3_DCTL_ULSTCHNGREQ(state);\r\ndwc3_writel(dwc->regs, DWC3_DCTL, reg);\r\nif (dwc->revision >= DWC3_REVISION_194A)\r\nreturn 0;\r\nretries = 10000;\r\nwhile (--retries) {\r\nreg = dwc3_readl(dwc->regs, DWC3_DSTS);\r\nif (DWC3_DSTS_USBLNKST(reg) == state)\r\nreturn 0;\r\nudelay(5);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic void dwc3_ep_inc_trb(u8 *index)\r\n{\r\n(*index)++;\r\nif (*index == (DWC3_TRB_NUM - 1))\r\n*index = 0;\r\n}\r\nstatic void dwc3_ep_inc_enq(struct dwc3_ep *dep)\r\n{\r\ndwc3_ep_inc_trb(&dep->trb_enqueue);\r\n}\r\nstatic void dwc3_ep_inc_deq(struct dwc3_ep *dep)\r\n{\r\ndwc3_ep_inc_trb(&dep->trb_dequeue);\r\n}\r\nvoid dwc3_gadget_giveback(struct dwc3_ep *dep, struct dwc3_request *req,\r\nint status)\r\n{\r\nstruct dwc3 *dwc = dep->dwc;\r\nreq->started = false;\r\nlist_del(&req->list);\r\nreq->remaining = 0;\r\nif (req->request.status == -EINPROGRESS)\r\nreq->request.status = status;\r\nif (req->trb)\r\nusb_gadget_unmap_request_by_dev(dwc->sysdev,\r\n&req->request, req->direction);\r\nreq->trb = NULL;\r\ntrace_dwc3_gadget_giveback(req);\r\nspin_unlock(&dwc->lock);\r\nusb_gadget_giveback_request(&dep->endpoint, &req->request);\r\nspin_lock(&dwc->lock);\r\nif (dep->number > 1)\r\npm_runtime_put(dwc->dev);\r\n}\r\nint dwc3_send_gadget_generic_command(struct dwc3 *dwc, unsigned cmd, u32 param)\r\n{\r\nu32 timeout = 500;\r\nint status = 0;\r\nint ret = 0;\r\nu32 reg;\r\ndwc3_writel(dwc->regs, DWC3_DGCMDPAR, param);\r\ndwc3_writel(dwc->regs, DWC3_DGCMD, cmd | DWC3_DGCMD_CMDACT);\r\ndo {\r\nreg = dwc3_readl(dwc->regs, DWC3_DGCMD);\r\nif (!(reg & DWC3_DGCMD_CMDACT)) {\r\nstatus = DWC3_DGCMD_STATUS(reg);\r\nif (status)\r\nret = -EINVAL;\r\nbreak;\r\n}\r\n} while (--timeout);\r\nif (!timeout) {\r\nret = -ETIMEDOUT;\r\nstatus = -ETIMEDOUT;\r\n}\r\ntrace_dwc3_gadget_generic_cmd(cmd, param, status);\r\nreturn ret;\r\n}\r\nint dwc3_send_gadget_ep_cmd(struct dwc3_ep *dep, unsigned cmd,\r\nstruct dwc3_gadget_ep_cmd_params *params)\r\n{\r\nconst struct usb_endpoint_descriptor *desc = dep->endpoint.desc;\r\nstruct dwc3 *dwc = dep->dwc;\r\nu32 timeout = 500;\r\nu32 reg;\r\nint cmd_status = 0;\r\nint susphy = false;\r\nint ret = -EINVAL;\r\nif (dwc->gadget.speed <= USB_SPEED_HIGH) {\r\nreg = dwc3_readl(dwc->regs, DWC3_GUSB2PHYCFG(0));\r\nif (unlikely(reg & DWC3_GUSB2PHYCFG_SUSPHY)) {\r\nsusphy = true;\r\nreg &= ~DWC3_GUSB2PHYCFG_SUSPHY;\r\ndwc3_writel(dwc->regs, DWC3_GUSB2PHYCFG(0), reg);\r\n}\r\n}\r\nif (DWC3_DEPCMD_CMD(cmd) == DWC3_DEPCMD_STARTTRANSFER) {\r\nint needs_wakeup;\r\nneeds_wakeup = (dwc->link_state == DWC3_LINK_STATE_U1 ||\r\ndwc->link_state == DWC3_LINK_STATE_U2 ||\r\ndwc->link_state == DWC3_LINK_STATE_U3);\r\nif (unlikely(needs_wakeup)) {\r\nret = __dwc3_gadget_wakeup(dwc);\r\ndev_WARN_ONCE(dwc->dev, ret, "wakeup failed --> %d\n",\r\nret);\r\n}\r\n}\r\ndwc3_writel(dep->regs, DWC3_DEPCMDPAR0, params->param0);\r\ndwc3_writel(dep->regs, DWC3_DEPCMDPAR1, params->param1);\r\ndwc3_writel(dep->regs, DWC3_DEPCMDPAR2, params->param2);\r\nif (DWC3_DEPCMD_CMD(cmd) == DWC3_DEPCMD_UPDATETRANSFER &&\r\n!usb_endpoint_xfer_isoc(desc))\r\ncmd &= ~(DWC3_DEPCMD_CMDIOC | DWC3_DEPCMD_CMDACT);\r\nelse\r\ncmd |= DWC3_DEPCMD_CMDACT;\r\ndwc3_writel(dep->regs, DWC3_DEPCMD, cmd);\r\ndo {\r\nreg = dwc3_readl(dep->regs, DWC3_DEPCMD);\r\nif (!(reg & DWC3_DEPCMD_CMDACT)) {\r\ncmd_status = DWC3_DEPCMD_STATUS(reg);\r\nswitch (cmd_status) {\r\ncase 0:\r\nret = 0;\r\nbreak;\r\ncase DEPEVT_TRANSFER_NO_RESOURCE:\r\nret = -EINVAL;\r\nbreak;\r\ncase DEPEVT_TRANSFER_BUS_EXPIRY:\r\nret = -EAGAIN;\r\nbreak;\r\ndefault:\r\ndev_WARN(dwc->dev, "UNKNOWN cmd status\n");\r\n}\r\nbreak;\r\n}\r\n} while (--timeout);\r\nif (timeout == 0) {\r\nret = -ETIMEDOUT;\r\ncmd_status = -ETIMEDOUT;\r\n}\r\ntrace_dwc3_gadget_ep_cmd(dep, cmd, params, cmd_status);\r\nif (ret == 0) {\r\nswitch (DWC3_DEPCMD_CMD(cmd)) {\r\ncase DWC3_DEPCMD_STARTTRANSFER:\r\ndep->flags |= DWC3_EP_TRANSFER_STARTED;\r\nbreak;\r\ncase DWC3_DEPCMD_ENDTRANSFER:\r\ndep->flags &= ~DWC3_EP_TRANSFER_STARTED;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nif (unlikely(susphy)) {\r\nreg = dwc3_readl(dwc->regs, DWC3_GUSB2PHYCFG(0));\r\nreg |= DWC3_GUSB2PHYCFG_SUSPHY;\r\ndwc3_writel(dwc->regs, DWC3_GUSB2PHYCFG(0), reg);\r\n}\r\nreturn ret;\r\n}\r\nstatic int dwc3_send_clear_stall_ep_cmd(struct dwc3_ep *dep)\r\n{\r\nstruct dwc3 *dwc = dep->dwc;\r\nstruct dwc3_gadget_ep_cmd_params params;\r\nu32 cmd = DWC3_DEPCMD_CLEARSTALL;\r\nif (dep->direction && (dwc->revision >= DWC3_REVISION_260A) &&\r\n(dwc->gadget.speed >= USB_SPEED_SUPER))\r\ncmd |= DWC3_DEPCMD_CLEARPENDIN;\r\nmemset(&params, 0, sizeof(params));\r\nreturn dwc3_send_gadget_ep_cmd(dep, cmd, &params);\r\n}\r\nstatic dma_addr_t dwc3_trb_dma_offset(struct dwc3_ep *dep,\r\nstruct dwc3_trb *trb)\r\n{\r\nu32 offset = (char *) trb - (char *) dep->trb_pool;\r\nreturn dep->trb_pool_dma + offset;\r\n}\r\nstatic int dwc3_alloc_trb_pool(struct dwc3_ep *dep)\r\n{\r\nstruct dwc3 *dwc = dep->dwc;\r\nif (dep->trb_pool)\r\nreturn 0;\r\ndep->trb_pool = dma_alloc_coherent(dwc->sysdev,\r\nsizeof(struct dwc3_trb) * DWC3_TRB_NUM,\r\n&dep->trb_pool_dma, GFP_KERNEL);\r\nif (!dep->trb_pool) {\r\ndev_err(dep->dwc->dev, "failed to allocate trb pool for %s\n",\r\ndep->name);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void dwc3_free_trb_pool(struct dwc3_ep *dep)\r\n{\r\nstruct dwc3 *dwc = dep->dwc;\r\ndma_free_coherent(dwc->sysdev, sizeof(struct dwc3_trb) * DWC3_TRB_NUM,\r\ndep->trb_pool, dep->trb_pool_dma);\r\ndep->trb_pool = NULL;\r\ndep->trb_pool_dma = 0;\r\n}\r\nstatic int dwc3_gadget_start_config(struct dwc3 *dwc, struct dwc3_ep *dep)\r\n{\r\nstruct dwc3_gadget_ep_cmd_params params;\r\nu32 cmd;\r\nint i;\r\nint ret;\r\nif (dep->number)\r\nreturn 0;\r\nmemset(&params, 0x00, sizeof(params));\r\ncmd = DWC3_DEPCMD_DEPSTARTCFG;\r\nret = dwc3_send_gadget_ep_cmd(dep, cmd, &params);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < DWC3_ENDPOINTS_NUM; i++) {\r\nstruct dwc3_ep *dep = dwc->eps[i];\r\nif (!dep)\r\ncontinue;\r\nret = dwc3_gadget_set_xfer_resource(dwc, dep);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dwc3_gadget_set_ep_config(struct dwc3 *dwc, struct dwc3_ep *dep,\r\nbool modify, bool restore)\r\n{\r\nconst struct usb_ss_ep_comp_descriptor *comp_desc;\r\nconst struct usb_endpoint_descriptor *desc;\r\nstruct dwc3_gadget_ep_cmd_params params;\r\nif (dev_WARN_ONCE(dwc->dev, modify && restore,\r\n"Can't modify and restore\n"))\r\nreturn -EINVAL;\r\ncomp_desc = dep->endpoint.comp_desc;\r\ndesc = dep->endpoint.desc;\r\nmemset(&params, 0x00, sizeof(params));\r\nparams.param0 = DWC3_DEPCFG_EP_TYPE(usb_endpoint_type(desc))\r\n| DWC3_DEPCFG_MAX_PACKET_SIZE(usb_endpoint_maxp(desc));\r\nif (dwc->gadget.speed >= USB_SPEED_SUPER) {\r\nu32 burst = dep->endpoint.maxburst;\r\nparams.param0 |= DWC3_DEPCFG_BURST_SIZE(burst - 1);\r\n}\r\nif (modify) {\r\nparams.param0 |= DWC3_DEPCFG_ACTION_MODIFY;\r\n} else if (restore) {\r\nparams.param0 |= DWC3_DEPCFG_ACTION_RESTORE;\r\nparams.param2 |= dep->saved_state;\r\n} else {\r\nparams.param0 |= DWC3_DEPCFG_ACTION_INIT;\r\n}\r\nif (usb_endpoint_xfer_control(desc))\r\nparams.param1 = DWC3_DEPCFG_XFER_COMPLETE_EN;\r\nif (dep->number <= 1 || usb_endpoint_xfer_isoc(desc))\r\nparams.param1 |= DWC3_DEPCFG_XFER_NOT_READY_EN;\r\nif (usb_ss_max_streams(comp_desc) && usb_endpoint_xfer_bulk(desc)) {\r\nparams.param1 |= DWC3_DEPCFG_STREAM_CAPABLE\r\n| DWC3_DEPCFG_STREAM_EVENT_EN;\r\ndep->stream_capable = true;\r\n}\r\nif (!usb_endpoint_xfer_control(desc))\r\nparams.param1 |= DWC3_DEPCFG_XFER_IN_PROGRESS_EN;\r\nparams.param1 |= DWC3_DEPCFG_EP_NUMBER(dep->number);\r\nif (dep->direction)\r\nparams.param0 |= DWC3_DEPCFG_FIFO_NUMBER(dep->number >> 1);\r\nif (desc->bInterval) {\r\nparams.param1 |= DWC3_DEPCFG_BINTERVAL_M1(desc->bInterval - 1);\r\ndep->interval = 1 << (desc->bInterval - 1);\r\n}\r\nreturn dwc3_send_gadget_ep_cmd(dep, DWC3_DEPCMD_SETEPCONFIG, &params);\r\n}\r\nstatic int dwc3_gadget_set_xfer_resource(struct dwc3 *dwc, struct dwc3_ep *dep)\r\n{\r\nstruct dwc3_gadget_ep_cmd_params params;\r\nmemset(&params, 0x00, sizeof(params));\r\nparams.param0 = DWC3_DEPXFERCFG_NUM_XFER_RES(1);\r\nreturn dwc3_send_gadget_ep_cmd(dep, DWC3_DEPCMD_SETTRANSFRESOURCE,\r\n&params);\r\n}\r\nstatic int __dwc3_gadget_ep_enable(struct dwc3_ep *dep,\r\nbool modify, bool restore)\r\n{\r\nconst struct usb_endpoint_descriptor *desc = dep->endpoint.desc;\r\nstruct dwc3 *dwc = dep->dwc;\r\nu32 reg;\r\nint ret;\r\nif (!(dep->flags & DWC3_EP_ENABLED)) {\r\nret = dwc3_gadget_start_config(dwc, dep);\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = dwc3_gadget_set_ep_config(dwc, dep, modify, restore);\r\nif (ret)\r\nreturn ret;\r\nif (!(dep->flags & DWC3_EP_ENABLED)) {\r\nstruct dwc3_trb *trb_st_hw;\r\nstruct dwc3_trb *trb_link;\r\ndep->type = usb_endpoint_type(desc);\r\ndep->flags |= DWC3_EP_ENABLED;\r\ndep->flags &= ~DWC3_EP_END_TRANSFER_PENDING;\r\nreg = dwc3_readl(dwc->regs, DWC3_DALEPENA);\r\nreg |= DWC3_DALEPENA_EP(dep->number);\r\ndwc3_writel(dwc->regs, DWC3_DALEPENA, reg);\r\ninit_waitqueue_head(&dep->wait_end_transfer);\r\nif (usb_endpoint_xfer_control(desc))\r\ngoto out;\r\ndep->trb_dequeue = 0;\r\ndep->trb_enqueue = 0;\r\nmemset(dep->trb_pool, 0,\r\nsizeof(struct dwc3_trb) * DWC3_TRB_NUM);\r\ntrb_st_hw = &dep->trb_pool[0];\r\ntrb_link = &dep->trb_pool[DWC3_TRB_NUM - 1];\r\ntrb_link->bpl = lower_32_bits(dwc3_trb_dma_offset(dep, trb_st_hw));\r\ntrb_link->bph = upper_32_bits(dwc3_trb_dma_offset(dep, trb_st_hw));\r\ntrb_link->ctrl |= DWC3_TRBCTL_LINK_TRB;\r\ntrb_link->ctrl |= DWC3_TRB_CTRL_HWO;\r\n}\r\nif (usb_endpoint_xfer_bulk(desc)) {\r\nstruct dwc3_gadget_ep_cmd_params params;\r\nstruct dwc3_trb *trb;\r\ndma_addr_t trb_dma;\r\nu32 cmd;\r\nmemset(&params, 0, sizeof(params));\r\ntrb = &dep->trb_pool[0];\r\ntrb_dma = dwc3_trb_dma_offset(dep, trb);\r\nparams.param0 = upper_32_bits(trb_dma);\r\nparams.param1 = lower_32_bits(trb_dma);\r\ncmd = DWC3_DEPCMD_STARTTRANSFER;\r\nret = dwc3_send_gadget_ep_cmd(dep, cmd, &params);\r\nif (ret < 0)\r\nreturn ret;\r\ndep->flags |= DWC3_EP_BUSY;\r\ndep->resource_index = dwc3_gadget_ep_get_transfer_index(dep);\r\nWARN_ON_ONCE(!dep->resource_index);\r\n}\r\nout:\r\ntrace_dwc3_gadget_ep_enable(dep);\r\nreturn 0;\r\n}\r\nstatic void dwc3_remove_requests(struct dwc3 *dwc, struct dwc3_ep *dep)\r\n{\r\nstruct dwc3_request *req;\r\ndwc3_stop_active_transfer(dwc, dep->number, true);\r\nwhile (!list_empty(&dep->started_list)) {\r\nreq = next_request(&dep->started_list);\r\ndwc3_gadget_giveback(dep, req, -ESHUTDOWN);\r\n}\r\nwhile (!list_empty(&dep->pending_list)) {\r\nreq = next_request(&dep->pending_list);\r\ndwc3_gadget_giveback(dep, req, -ESHUTDOWN);\r\n}\r\n}\r\nstatic int __dwc3_gadget_ep_disable(struct dwc3_ep *dep)\r\n{\r\nstruct dwc3 *dwc = dep->dwc;\r\nu32 reg;\r\ntrace_dwc3_gadget_ep_disable(dep);\r\ndwc3_remove_requests(dwc, dep);\r\nif (dep->flags & DWC3_EP_STALL)\r\n__dwc3_gadget_ep_set_halt(dep, 0, false);\r\nreg = dwc3_readl(dwc->regs, DWC3_DALEPENA);\r\nreg &= ~DWC3_DALEPENA_EP(dep->number);\r\ndwc3_writel(dwc->regs, DWC3_DALEPENA, reg);\r\ndep->stream_capable = false;\r\ndep->type = 0;\r\ndep->flags &= DWC3_EP_END_TRANSFER_PENDING;\r\nif (dep->number > 1) {\r\ndep->endpoint.comp_desc = NULL;\r\ndep->endpoint.desc = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dwc3_gadget_ep0_enable(struct usb_ep *ep,\r\nconst struct usb_endpoint_descriptor *desc)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int dwc3_gadget_ep0_disable(struct usb_ep *ep)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int dwc3_gadget_ep_enable(struct usb_ep *ep,\r\nconst struct usb_endpoint_descriptor *desc)\r\n{\r\nstruct dwc3_ep *dep;\r\nstruct dwc3 *dwc;\r\nunsigned long flags;\r\nint ret;\r\nif (!ep || !desc || desc->bDescriptorType != USB_DT_ENDPOINT) {\r\npr_debug("dwc3: invalid parameters\n");\r\nreturn -EINVAL;\r\n}\r\nif (!desc->wMaxPacketSize) {\r\npr_debug("dwc3: missing wMaxPacketSize\n");\r\nreturn -EINVAL;\r\n}\r\ndep = to_dwc3_ep(ep);\r\ndwc = dep->dwc;\r\nif (dev_WARN_ONCE(dwc->dev, dep->flags & DWC3_EP_ENABLED,\r\n"%s is already enabled\n",\r\ndep->name))\r\nreturn 0;\r\nspin_lock_irqsave(&dwc->lock, flags);\r\nret = __dwc3_gadget_ep_enable(dep, false, false);\r\nspin_unlock_irqrestore(&dwc->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int dwc3_gadget_ep_disable(struct usb_ep *ep)\r\n{\r\nstruct dwc3_ep *dep;\r\nstruct dwc3 *dwc;\r\nunsigned long flags;\r\nint ret;\r\nif (!ep) {\r\npr_debug("dwc3: invalid parameters\n");\r\nreturn -EINVAL;\r\n}\r\ndep = to_dwc3_ep(ep);\r\ndwc = dep->dwc;\r\nif (dev_WARN_ONCE(dwc->dev, !(dep->flags & DWC3_EP_ENABLED),\r\n"%s is already disabled\n",\r\ndep->name))\r\nreturn 0;\r\nspin_lock_irqsave(&dwc->lock, flags);\r\nret = __dwc3_gadget_ep_disable(dep);\r\nspin_unlock_irqrestore(&dwc->lock, flags);\r\nreturn ret;\r\n}\r\nstatic struct usb_request *dwc3_gadget_ep_alloc_request(struct usb_ep *ep,\r\ngfp_t gfp_flags)\r\n{\r\nstruct dwc3_request *req;\r\nstruct dwc3_ep *dep = to_dwc3_ep(ep);\r\nreq = kzalloc(sizeof(*req), gfp_flags);\r\nif (!req)\r\nreturn NULL;\r\nreq->epnum = dep->number;\r\nreq->dep = dep;\r\ndep->allocated_requests++;\r\ntrace_dwc3_alloc_request(req);\r\nreturn &req->request;\r\n}\r\nstatic void dwc3_gadget_ep_free_request(struct usb_ep *ep,\r\nstruct usb_request *request)\r\n{\r\nstruct dwc3_request *req = to_dwc3_request(request);\r\nstruct dwc3_ep *dep = to_dwc3_ep(ep);\r\ndep->allocated_requests--;\r\ntrace_dwc3_free_request(req);\r\nkfree(req);\r\n}\r\nstatic void __dwc3_prepare_one_trb(struct dwc3_ep *dep, struct dwc3_trb *trb,\r\ndma_addr_t dma, unsigned length, unsigned chain, unsigned node,\r\nunsigned stream_id, unsigned short_not_ok, unsigned no_interrupt)\r\n{\r\nstruct dwc3 *dwc = dep->dwc;\r\nstruct usb_gadget *gadget = &dwc->gadget;\r\nenum usb_device_speed speed = gadget->speed;\r\ndwc3_ep_inc_enq(dep);\r\ntrb->size = DWC3_TRB_SIZE_LENGTH(length);\r\ntrb->bpl = lower_32_bits(dma);\r\ntrb->bph = upper_32_bits(dma);\r\nswitch (usb_endpoint_type(dep->endpoint.desc)) {\r\ncase USB_ENDPOINT_XFER_CONTROL:\r\ntrb->ctrl = DWC3_TRBCTL_CONTROL_SETUP;\r\nbreak;\r\ncase USB_ENDPOINT_XFER_ISOC:\r\nif (!node) {\r\ntrb->ctrl = DWC3_TRBCTL_ISOCHRONOUS_FIRST;\r\nif (speed == USB_SPEED_HIGH) {\r\nstruct usb_ep *ep = &dep->endpoint;\r\nunsigned int mult = ep->mult - 1;\r\nunsigned int maxp = usb_endpoint_maxp(ep->desc);\r\nif (length <= (2 * maxp))\r\nmult--;\r\nif (length <= maxp)\r\nmult--;\r\ntrb->size |= DWC3_TRB_SIZE_PCM1(mult);\r\n}\r\n} else {\r\ntrb->ctrl = DWC3_TRBCTL_ISOCHRONOUS;\r\n}\r\ntrb->ctrl |= DWC3_TRB_CTRL_ISP_IMI;\r\nbreak;\r\ncase USB_ENDPOINT_XFER_BULK:\r\ncase USB_ENDPOINT_XFER_INT:\r\ntrb->ctrl = DWC3_TRBCTL_NORMAL;\r\nbreak;\r\ndefault:\r\ndev_WARN(dwc->dev, "Unknown endpoint type %d\n",\r\nusb_endpoint_type(dep->endpoint.desc));\r\n}\r\nif (usb_endpoint_dir_out(dep->endpoint.desc)) {\r\ntrb->ctrl |= DWC3_TRB_CTRL_CSP;\r\nif (short_not_ok)\r\ntrb->ctrl |= DWC3_TRB_CTRL_ISP_IMI;\r\n}\r\nif ((!no_interrupt && !chain) ||\r\n(dwc3_calc_trbs_left(dep) == 0))\r\ntrb->ctrl |= DWC3_TRB_CTRL_IOC;\r\nif (chain)\r\ntrb->ctrl |= DWC3_TRB_CTRL_CHN;\r\nif (usb_endpoint_xfer_bulk(dep->endpoint.desc) && dep->stream_capable)\r\ntrb->ctrl |= DWC3_TRB_CTRL_SID_SOFN(stream_id);\r\ntrb->ctrl |= DWC3_TRB_CTRL_HWO;\r\ntrace_dwc3_prepare_trb(dep, trb);\r\n}\r\nstatic void dwc3_prepare_one_trb(struct dwc3_ep *dep,\r\nstruct dwc3_request *req, unsigned chain, unsigned node)\r\n{\r\nstruct dwc3_trb *trb;\r\nunsigned length = req->request.length;\r\nunsigned stream_id = req->request.stream_id;\r\nunsigned short_not_ok = req->request.short_not_ok;\r\nunsigned no_interrupt = req->request.no_interrupt;\r\ndma_addr_t dma = req->request.dma;\r\ntrb = &dep->trb_pool[dep->trb_enqueue];\r\nif (!req->trb) {\r\ndwc3_gadget_move_started_request(req);\r\nreq->trb = trb;\r\nreq->trb_dma = dwc3_trb_dma_offset(dep, trb);\r\ndep->queued_requests++;\r\n}\r\n__dwc3_prepare_one_trb(dep, trb, dma, length, chain, node,\r\nstream_id, short_not_ok, no_interrupt);\r\n}\r\nstatic struct dwc3_trb *dwc3_ep_prev_trb(struct dwc3_ep *dep, u8 index)\r\n{\r\nu8 tmp = index;\r\nif (!tmp)\r\ntmp = DWC3_TRB_NUM - 1;\r\nreturn &dep->trb_pool[tmp - 1];\r\n}\r\nstatic u32 dwc3_calc_trbs_left(struct dwc3_ep *dep)\r\n{\r\nstruct dwc3_trb *tmp;\r\nu8 trbs_left;\r\nif (dep->trb_enqueue == dep->trb_dequeue) {\r\ntmp = dwc3_ep_prev_trb(dep, dep->trb_enqueue);\r\nif (tmp->ctrl & DWC3_TRB_CTRL_HWO)\r\nreturn 0;\r\nreturn DWC3_TRB_NUM - 1;\r\n}\r\ntrbs_left = dep->trb_dequeue - dep->trb_enqueue;\r\ntrbs_left &= (DWC3_TRB_NUM - 1);\r\nif (dep->trb_dequeue < dep->trb_enqueue)\r\ntrbs_left--;\r\nreturn trbs_left;\r\n}\r\nstatic void dwc3_prepare_one_trb_sg(struct dwc3_ep *dep,\r\nstruct dwc3_request *req)\r\n{\r\nstruct scatterlist *sg = req->sg;\r\nstruct scatterlist *s;\r\nint i;\r\nfor_each_sg(sg, s, req->num_pending_sgs, i) {\r\nunsigned int length = req->request.length;\r\nunsigned int maxp = usb_endpoint_maxp(dep->endpoint.desc);\r\nunsigned int rem = length % maxp;\r\nunsigned chain = true;\r\nif (sg_is_last(s))\r\nchain = false;\r\nif (rem && usb_endpoint_dir_out(dep->endpoint.desc) && !chain) {\r\nstruct dwc3 *dwc = dep->dwc;\r\nstruct dwc3_trb *trb;\r\nreq->unaligned = true;\r\ndwc3_prepare_one_trb(dep, req, true, i);\r\ntrb = &dep->trb_pool[dep->trb_enqueue];\r\n__dwc3_prepare_one_trb(dep, trb, dwc->bounce_addr,\r\nmaxp - rem, false, 0,\r\nreq->request.stream_id,\r\nreq->request.short_not_ok,\r\nreq->request.no_interrupt);\r\n} else {\r\ndwc3_prepare_one_trb(dep, req, chain, i);\r\n}\r\nif (!dwc3_calc_trbs_left(dep))\r\nbreak;\r\n}\r\n}\r\nstatic void dwc3_prepare_one_trb_linear(struct dwc3_ep *dep,\r\nstruct dwc3_request *req)\r\n{\r\nunsigned int length = req->request.length;\r\nunsigned int maxp = usb_endpoint_maxp(dep->endpoint.desc);\r\nunsigned int rem = length % maxp;\r\nif (rem && usb_endpoint_dir_out(dep->endpoint.desc)) {\r\nstruct dwc3 *dwc = dep->dwc;\r\nstruct dwc3_trb *trb;\r\nreq->unaligned = true;\r\ndwc3_prepare_one_trb(dep, req, true, 0);\r\ntrb = &dep->trb_pool[dep->trb_enqueue];\r\n__dwc3_prepare_one_trb(dep, trb, dwc->bounce_addr, maxp - rem,\r\nfalse, 0, req->request.stream_id,\r\nreq->request.short_not_ok,\r\nreq->request.no_interrupt);\r\n} else if (req->request.zero && req->request.length &&\r\n(IS_ALIGNED(req->request.length,dep->endpoint.maxpacket))) {\r\nstruct dwc3 *dwc = dep->dwc;\r\nstruct dwc3_trb *trb;\r\nreq->zero = true;\r\ndwc3_prepare_one_trb(dep, req, true, 0);\r\ntrb = &dep->trb_pool[dep->trb_enqueue];\r\n__dwc3_prepare_one_trb(dep, trb, dwc->bounce_addr, 0,\r\nfalse, 0, req->request.stream_id,\r\nreq->request.short_not_ok,\r\nreq->request.no_interrupt);\r\n} else {\r\ndwc3_prepare_one_trb(dep, req, false, 0);\r\n}\r\n}\r\nstatic void dwc3_prepare_trbs(struct dwc3_ep *dep)\r\n{\r\nstruct dwc3_request *req, *n;\r\nBUILD_BUG_ON_NOT_POWER_OF_2(DWC3_TRB_NUM);\r\nif (!dwc3_calc_trbs_left(dep))\r\nreturn;\r\nlist_for_each_entry(req, &dep->started_list, list) {\r\nif (req->num_pending_sgs > 0)\r\ndwc3_prepare_one_trb_sg(dep, req);\r\nif (!dwc3_calc_trbs_left(dep))\r\nreturn;\r\n}\r\nlist_for_each_entry_safe(req, n, &dep->pending_list, list) {\r\nstruct dwc3 *dwc = dep->dwc;\r\nint ret;\r\nret = usb_gadget_map_request_by_dev(dwc->sysdev, &req->request,\r\ndep->direction);\r\nif (ret)\r\nreturn;\r\nreq->sg = req->request.sg;\r\nreq->num_pending_sgs = req->request.num_mapped_sgs;\r\nif (req->num_pending_sgs > 0)\r\ndwc3_prepare_one_trb_sg(dep, req);\r\nelse\r\ndwc3_prepare_one_trb_linear(dep, req);\r\nif (!dwc3_calc_trbs_left(dep))\r\nreturn;\r\n}\r\n}\r\nstatic int __dwc3_gadget_kick_transfer(struct dwc3_ep *dep, u16 cmd_param)\r\n{\r\nstruct dwc3_gadget_ep_cmd_params params;\r\nstruct dwc3_request *req;\r\nint starting;\r\nint ret;\r\nu32 cmd;\r\nstarting = !(dep->flags & DWC3_EP_BUSY);\r\ndwc3_prepare_trbs(dep);\r\nreq = next_request(&dep->started_list);\r\nif (!req) {\r\ndep->flags |= DWC3_EP_PENDING_REQUEST;\r\nreturn 0;\r\n}\r\nmemset(&params, 0, sizeof(params));\r\nif (starting) {\r\nparams.param0 = upper_32_bits(req->trb_dma);\r\nparams.param1 = lower_32_bits(req->trb_dma);\r\ncmd = DWC3_DEPCMD_STARTTRANSFER |\r\nDWC3_DEPCMD_PARAM(cmd_param);\r\n} else {\r\ncmd = DWC3_DEPCMD_UPDATETRANSFER |\r\nDWC3_DEPCMD_PARAM(dep->resource_index);\r\n}\r\nret = dwc3_send_gadget_ep_cmd(dep, cmd, &params);\r\nif (ret < 0) {\r\nif (req->trb)\r\nmemset(req->trb, 0, sizeof(struct dwc3_trb));\r\ndep->queued_requests--;\r\ndwc3_gadget_giveback(dep, req, ret);\r\nreturn ret;\r\n}\r\ndep->flags |= DWC3_EP_BUSY;\r\nif (starting) {\r\ndep->resource_index = dwc3_gadget_ep_get_transfer_index(dep);\r\nWARN_ON_ONCE(!dep->resource_index);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __dwc3_gadget_get_frame(struct dwc3 *dwc)\r\n{\r\nu32 reg;\r\nreg = dwc3_readl(dwc->regs, DWC3_DSTS);\r\nreturn DWC3_DSTS_SOFFN(reg);\r\n}\r\nstatic void __dwc3_gadget_start_isoc(struct dwc3 *dwc,\r\nstruct dwc3_ep *dep, u32 cur_uf)\r\n{\r\nu32 uf;\r\nif (list_empty(&dep->pending_list)) {\r\ndev_info(dwc->dev, "%s: ran out of requests\n",\r\ndep->name);\r\ndep->flags |= DWC3_EP_PENDING_REQUEST;\r\nreturn;\r\n}\r\nuf = cur_uf + max_t(u32, 4, dep->interval);\r\n__dwc3_gadget_kick_transfer(dep, uf);\r\n}\r\nstatic void dwc3_gadget_start_isoc(struct dwc3 *dwc,\r\nstruct dwc3_ep *dep, const struct dwc3_event_depevt *event)\r\n{\r\nu32 cur_uf, mask;\r\nmask = ~(dep->interval - 1);\r\ncur_uf = event->parameters & mask;\r\n__dwc3_gadget_start_isoc(dwc, dep, cur_uf);\r\n}\r\nstatic int __dwc3_gadget_ep_queue(struct dwc3_ep *dep, struct dwc3_request *req)\r\n{\r\nstruct dwc3 *dwc = dep->dwc;\r\nint ret = 0;\r\nif (!dep->endpoint.desc) {\r\ndev_err(dwc->dev, "%s: can't queue to disabled endpoint\n",\r\ndep->name);\r\nreturn -ESHUTDOWN;\r\n}\r\nif (WARN(req->dep != dep, "request %pK belongs to '%s'\n",\r\n&req->request, req->dep->name))\r\nreturn -EINVAL;\r\npm_runtime_get(dwc->dev);\r\nreq->request.actual = 0;\r\nreq->request.status = -EINPROGRESS;\r\nreq->direction = dep->direction;\r\nreq->epnum = dep->number;\r\ntrace_dwc3_ep_queue(req);\r\nlist_add_tail(&req->list, &dep->pending_list);\r\nif (usb_endpoint_xfer_isoc(dep->endpoint.desc)) {\r\nif ((dep->flags & DWC3_EP_PENDING_REQUEST)) {\r\nif (dep->flags & DWC3_EP_TRANSFER_STARTED) {\r\ndwc3_stop_active_transfer(dwc, dep->number, true);\r\ndep->flags = DWC3_EP_ENABLED;\r\n} else {\r\nu32 cur_uf;\r\ncur_uf = __dwc3_gadget_get_frame(dwc);\r\n__dwc3_gadget_start_isoc(dwc, dep, cur_uf);\r\ndep->flags &= ~DWC3_EP_PENDING_REQUEST;\r\n}\r\nreturn 0;\r\n}\r\nif ((dep->flags & DWC3_EP_BUSY) &&\r\n!(dep->flags & DWC3_EP_MISSED_ISOC)) {\r\nWARN_ON_ONCE(!dep->resource_index);\r\nret = __dwc3_gadget_kick_transfer(dep,\r\ndep->resource_index);\r\n}\r\ngoto out;\r\n}\r\nif (!dwc3_calc_trbs_left(dep))\r\nreturn 0;\r\nret = __dwc3_gadget_kick_transfer(dep, 0);\r\nout:\r\nif (ret == -EBUSY)\r\nret = 0;\r\nreturn ret;\r\n}\r\nstatic int dwc3_gadget_ep_queue(struct usb_ep *ep, struct usb_request *request,\r\ngfp_t gfp_flags)\r\n{\r\nstruct dwc3_request *req = to_dwc3_request(request);\r\nstruct dwc3_ep *dep = to_dwc3_ep(ep);\r\nstruct dwc3 *dwc = dep->dwc;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&dwc->lock, flags);\r\nret = __dwc3_gadget_ep_queue(dep, req);\r\nspin_unlock_irqrestore(&dwc->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int dwc3_gadget_ep_dequeue(struct usb_ep *ep,\r\nstruct usb_request *request)\r\n{\r\nstruct dwc3_request *req = to_dwc3_request(request);\r\nstruct dwc3_request *r = NULL;\r\nstruct dwc3_ep *dep = to_dwc3_ep(ep);\r\nstruct dwc3 *dwc = dep->dwc;\r\nunsigned long flags;\r\nint ret = 0;\r\ntrace_dwc3_ep_dequeue(req);\r\nspin_lock_irqsave(&dwc->lock, flags);\r\nlist_for_each_entry(r, &dep->pending_list, list) {\r\nif (r == req)\r\nbreak;\r\n}\r\nif (r != req) {\r\nlist_for_each_entry(r, &dep->started_list, list) {\r\nif (r == req)\r\nbreak;\r\n}\r\nif (r == req) {\r\ndwc3_stop_active_transfer(dwc, dep->number, true);\r\nwait_event_lock_irq(dep->wait_end_transfer,\r\n!(dep->flags & DWC3_EP_END_TRANSFER_PENDING),\r\ndwc->lock);\r\nif (!r->trb)\r\ngoto out1;\r\nif (r->num_pending_sgs) {\r\nstruct dwc3_trb *trb;\r\nint i = 0;\r\nfor (i = 0; i < r->num_pending_sgs; i++) {\r\ntrb = r->trb + i;\r\ntrb->ctrl &= ~DWC3_TRB_CTRL_HWO;\r\ndwc3_ep_inc_deq(dep);\r\n}\r\nif (r->unaligned || r->zero) {\r\ntrb = r->trb + r->num_pending_sgs + 1;\r\ntrb->ctrl &= ~DWC3_TRB_CTRL_HWO;\r\ndwc3_ep_inc_deq(dep);\r\n}\r\n} else {\r\nstruct dwc3_trb *trb = r->trb;\r\ntrb->ctrl &= ~DWC3_TRB_CTRL_HWO;\r\ndwc3_ep_inc_deq(dep);\r\nif (r->unaligned || r->zero) {\r\ntrb = r->trb + 1;\r\ntrb->ctrl &= ~DWC3_TRB_CTRL_HWO;\r\ndwc3_ep_inc_deq(dep);\r\n}\r\n}\r\ngoto out1;\r\n}\r\ndev_err(dwc->dev, "request %pK was not queued to %s\n",\r\nrequest, ep->name);\r\nret = -EINVAL;\r\ngoto out0;\r\n}\r\nout1:\r\ndep->queued_requests--;\r\ndwc3_gadget_giveback(dep, req, -ECONNRESET);\r\nout0:\r\nspin_unlock_irqrestore(&dwc->lock, flags);\r\nreturn ret;\r\n}\r\nint __dwc3_gadget_ep_set_halt(struct dwc3_ep *dep, int value, int protocol)\r\n{\r\nstruct dwc3_gadget_ep_cmd_params params;\r\nstruct dwc3 *dwc = dep->dwc;\r\nint ret;\r\nif (usb_endpoint_xfer_isoc(dep->endpoint.desc)) {\r\ndev_err(dwc->dev, "%s is of Isochronous type\n", dep->name);\r\nreturn -EINVAL;\r\n}\r\nmemset(&params, 0x00, sizeof(params));\r\nif (value) {\r\nstruct dwc3_trb *trb;\r\nunsigned transfer_in_flight;\r\nunsigned started;\r\nif (dep->flags & DWC3_EP_STALL)\r\nreturn 0;\r\nif (dep->number > 1)\r\ntrb = dwc3_ep_prev_trb(dep, dep->trb_enqueue);\r\nelse\r\ntrb = &dwc->ep0_trb[dep->trb_enqueue];\r\ntransfer_in_flight = trb->ctrl & DWC3_TRB_CTRL_HWO;\r\nstarted = !list_empty(&dep->started_list);\r\nif (!protocol && ((dep->direction && transfer_in_flight) ||\r\n(!dep->direction && started))) {\r\nreturn -EAGAIN;\r\n}\r\nret = dwc3_send_gadget_ep_cmd(dep, DWC3_DEPCMD_SETSTALL,\r\n&params);\r\nif (ret)\r\ndev_err(dwc->dev, "failed to set STALL on %s\n",\r\ndep->name);\r\nelse\r\ndep->flags |= DWC3_EP_STALL;\r\n} else {\r\nif (!(dep->flags & DWC3_EP_STALL))\r\nreturn 0;\r\nret = dwc3_send_clear_stall_ep_cmd(dep);\r\nif (ret)\r\ndev_err(dwc->dev, "failed to clear STALL on %s\n",\r\ndep->name);\r\nelse\r\ndep->flags &= ~(DWC3_EP_STALL | DWC3_EP_WEDGE);\r\n}\r\nreturn ret;\r\n}\r\nstatic int dwc3_gadget_ep_set_halt(struct usb_ep *ep, int value)\r\n{\r\nstruct dwc3_ep *dep = to_dwc3_ep(ep);\r\nstruct dwc3 *dwc = dep->dwc;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&dwc->lock, flags);\r\nret = __dwc3_gadget_ep_set_halt(dep, value, false);\r\nspin_unlock_irqrestore(&dwc->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int dwc3_gadget_ep_set_wedge(struct usb_ep *ep)\r\n{\r\nstruct dwc3_ep *dep = to_dwc3_ep(ep);\r\nstruct dwc3 *dwc = dep->dwc;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&dwc->lock, flags);\r\ndep->flags |= DWC3_EP_WEDGE;\r\nif (dep->number == 0 || dep->number == 1)\r\nret = __dwc3_gadget_ep0_set_halt(ep, 1);\r\nelse\r\nret = __dwc3_gadget_ep_set_halt(dep, 1, false);\r\nspin_unlock_irqrestore(&dwc->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int dwc3_gadget_get_frame(struct usb_gadget *g)\r\n{\r\nstruct dwc3 *dwc = gadget_to_dwc(g);\r\nreturn __dwc3_gadget_get_frame(dwc);\r\n}\r\nstatic int __dwc3_gadget_wakeup(struct dwc3 *dwc)\r\n{\r\nint retries;\r\nint ret;\r\nu32 reg;\r\nu8 link_state;\r\nu8 speed;\r\nreg = dwc3_readl(dwc->regs, DWC3_DSTS);\r\nspeed = reg & DWC3_DSTS_CONNECTSPD;\r\nif ((speed == DWC3_DSTS_SUPERSPEED) ||\r\n(speed == DWC3_DSTS_SUPERSPEED_PLUS))\r\nreturn 0;\r\nlink_state = DWC3_DSTS_USBLNKST(reg);\r\nswitch (link_state) {\r\ncase DWC3_LINK_STATE_RX_DET:\r\ncase DWC3_LINK_STATE_U3:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = dwc3_gadget_set_link_state(dwc, DWC3_LINK_STATE_RECOV);\r\nif (ret < 0) {\r\ndev_err(dwc->dev, "failed to put link in Recovery\n");\r\nreturn ret;\r\n}\r\nif (dwc->revision < DWC3_REVISION_194A) {\r\nreg = dwc3_readl(dwc->regs, DWC3_DCTL);\r\nreg &= ~DWC3_DCTL_ULSTCHNGREQ_MASK;\r\ndwc3_writel(dwc->regs, DWC3_DCTL, reg);\r\n}\r\nretries = 20000;\r\nwhile (retries--) {\r\nreg = dwc3_readl(dwc->regs, DWC3_DSTS);\r\nif (DWC3_DSTS_USBLNKST(reg) == DWC3_LINK_STATE_U0)\r\nbreak;\r\n}\r\nif (DWC3_DSTS_USBLNKST(reg) != DWC3_LINK_STATE_U0) {\r\ndev_err(dwc->dev, "failed to send remote wakeup\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dwc3_gadget_wakeup(struct usb_gadget *g)\r\n{\r\nstruct dwc3 *dwc = gadget_to_dwc(g);\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&dwc->lock, flags);\r\nret = __dwc3_gadget_wakeup(dwc);\r\nspin_unlock_irqrestore(&dwc->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int dwc3_gadget_set_selfpowered(struct usb_gadget *g,\r\nint is_selfpowered)\r\n{\r\nstruct dwc3 *dwc = gadget_to_dwc(g);\r\nunsigned long flags;\r\nspin_lock_irqsave(&dwc->lock, flags);\r\ng->is_selfpowered = !!is_selfpowered;\r\nspin_unlock_irqrestore(&dwc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int dwc3_gadget_run_stop(struct dwc3 *dwc, int is_on, int suspend)\r\n{\r\nu32 reg;\r\nu32 timeout = 500;\r\nif (pm_runtime_suspended(dwc->dev))\r\nreturn 0;\r\nreg = dwc3_readl(dwc->regs, DWC3_DCTL);\r\nif (is_on) {\r\nif (dwc->revision <= DWC3_REVISION_187A) {\r\nreg &= ~DWC3_DCTL_TRGTULST_MASK;\r\nreg |= DWC3_DCTL_TRGTULST_RX_DET;\r\n}\r\nif (dwc->revision >= DWC3_REVISION_194A)\r\nreg &= ~DWC3_DCTL_KEEP_CONNECT;\r\nreg |= DWC3_DCTL_RUN_STOP;\r\nif (dwc->has_hibernation)\r\nreg |= DWC3_DCTL_KEEP_CONNECT;\r\ndwc->pullups_connected = true;\r\n} else {\r\nreg &= ~DWC3_DCTL_RUN_STOP;\r\nif (dwc->has_hibernation && !suspend)\r\nreg &= ~DWC3_DCTL_KEEP_CONNECT;\r\ndwc->pullups_connected = false;\r\n}\r\ndwc3_writel(dwc->regs, DWC3_DCTL, reg);\r\ndo {\r\nreg = dwc3_readl(dwc->regs, DWC3_DSTS);\r\nreg &= DWC3_DSTS_DEVCTRLHLT;\r\n} while (--timeout && !(!is_on ^ !reg));\r\nif (!timeout)\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic int dwc3_gadget_pullup(struct usb_gadget *g, int is_on)\r\n{\r\nstruct dwc3 *dwc = gadget_to_dwc(g);\r\nunsigned long flags;\r\nint ret;\r\nis_on = !!is_on;\r\nif (!is_on && dwc->ep0state != EP0_SETUP_PHASE) {\r\nreinit_completion(&dwc->ep0_in_setup);\r\nret = wait_for_completion_timeout(&dwc->ep0_in_setup,\r\nmsecs_to_jiffies(DWC3_PULL_UP_TIMEOUT));\r\nif (ret == 0) {\r\ndev_err(dwc->dev, "timed out waiting for SETUP phase\n");\r\nreturn -ETIMEDOUT;\r\n}\r\n}\r\nspin_lock_irqsave(&dwc->lock, flags);\r\nret = dwc3_gadget_run_stop(dwc, is_on, false);\r\nspin_unlock_irqrestore(&dwc->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void dwc3_gadget_enable_irq(struct dwc3 *dwc)\r\n{\r\nu32 reg;\r\nreg = (DWC3_DEVTEN_VNDRDEVTSTRCVEDEN |\r\nDWC3_DEVTEN_EVNTOVERFLOWEN |\r\nDWC3_DEVTEN_CMDCMPLTEN |\r\nDWC3_DEVTEN_ERRTICERREN |\r\nDWC3_DEVTEN_WKUPEVTEN |\r\nDWC3_DEVTEN_CONNECTDONEEN |\r\nDWC3_DEVTEN_USBRSTEN |\r\nDWC3_DEVTEN_DISCONNEVTEN);\r\nif (dwc->revision < DWC3_REVISION_250A)\r\nreg |= DWC3_DEVTEN_ULSTCNGEN;\r\ndwc3_writel(dwc->regs, DWC3_DEVTEN, reg);\r\n}\r\nstatic void dwc3_gadget_disable_irq(struct dwc3 *dwc)\r\n{\r\ndwc3_writel(dwc->regs, DWC3_DEVTEN, 0x00);\r\n}\r\nstatic void dwc3_gadget_setup_nump(struct dwc3 *dwc)\r\n{\r\nu32 ram2_depth;\r\nu32 mdwidth;\r\nu32 nump;\r\nu32 reg;\r\nram2_depth = DWC3_GHWPARAMS7_RAM2_DEPTH(dwc->hwparams.hwparams7);\r\nmdwidth = DWC3_GHWPARAMS0_MDWIDTH(dwc->hwparams.hwparams0);\r\nnump = ((ram2_depth * mdwidth / 8) - 24 - 16) / 1024;\r\nnump = min_t(u32, nump, 16);\r\nreg = dwc3_readl(dwc->regs, DWC3_DCFG);\r\nreg &= ~DWC3_DCFG_NUMP_MASK;\r\nreg |= nump << DWC3_DCFG_NUMP_SHIFT;\r\ndwc3_writel(dwc->regs, DWC3_DCFG, reg);\r\n}\r\nstatic int __dwc3_gadget_start(struct dwc3 *dwc)\r\n{\r\nstruct dwc3_ep *dep;\r\nint ret = 0;\r\nu32 reg;\r\nif (dwc->imod_interval) {\r\ndwc3_writel(dwc->regs, DWC3_DEV_IMOD(0), dwc->imod_interval);\r\ndwc3_writel(dwc->regs, DWC3_GEVNTCOUNT(0), DWC3_GEVNTCOUNT_EHB);\r\n} else if (dwc3_has_imod(dwc)) {\r\ndwc3_writel(dwc->regs, DWC3_DEV_IMOD(0), 0);\r\n}\r\nreg = dwc3_readl(dwc->regs, DWC3_GRXTHRCFG);\r\nreg &= ~DWC3_GRXTHRCFG_PKTCNTSEL;\r\ndwc3_writel(dwc->regs, DWC3_GRXTHRCFG, reg);\r\ndwc3_gadget_setup_nump(dwc);\r\ndwc3_gadget_ep0_desc.wMaxPacketSize = cpu_to_le16(512);\r\ndep = dwc->eps[0];\r\nret = __dwc3_gadget_ep_enable(dep, false, false);\r\nif (ret) {\r\ndev_err(dwc->dev, "failed to enable %s\n", dep->name);\r\ngoto err0;\r\n}\r\ndep = dwc->eps[1];\r\nret = __dwc3_gadget_ep_enable(dep, false, false);\r\nif (ret) {\r\ndev_err(dwc->dev, "failed to enable %s\n", dep->name);\r\ngoto err1;\r\n}\r\ndwc->ep0state = EP0_SETUP_PHASE;\r\ndwc3_ep0_out_start(dwc);\r\ndwc3_gadget_enable_irq(dwc);\r\nreturn 0;\r\nerr1:\r\n__dwc3_gadget_ep_disable(dwc->eps[0]);\r\nerr0:\r\nreturn ret;\r\n}\r\nstatic int dwc3_gadget_start(struct usb_gadget *g,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct dwc3 *dwc = gadget_to_dwc(g);\r\nunsigned long flags;\r\nint ret = 0;\r\nint irq;\r\nirq = dwc->irq_gadget;\r\nret = request_threaded_irq(irq, dwc3_interrupt, dwc3_thread_interrupt,\r\nIRQF_SHARED, "dwc3", dwc->ev_buf);\r\nif (ret) {\r\ndev_err(dwc->dev, "failed to request irq #%d --> %d\n",\r\nirq, ret);\r\ngoto err0;\r\n}\r\nspin_lock_irqsave(&dwc->lock, flags);\r\nif (dwc->gadget_driver) {\r\ndev_err(dwc->dev, "%s is already bound to %s\n",\r\ndwc->gadget.name,\r\ndwc->gadget_driver->driver.name);\r\nret = -EBUSY;\r\ngoto err1;\r\n}\r\ndwc->gadget_driver = driver;\r\nif (pm_runtime_active(dwc->dev))\r\n__dwc3_gadget_start(dwc);\r\nspin_unlock_irqrestore(&dwc->lock, flags);\r\nreturn 0;\r\nerr1:\r\nspin_unlock_irqrestore(&dwc->lock, flags);\r\nfree_irq(irq, dwc);\r\nerr0:\r\nreturn ret;\r\n}\r\nstatic void __dwc3_gadget_stop(struct dwc3 *dwc)\r\n{\r\ndwc3_gadget_disable_irq(dwc);\r\n__dwc3_gadget_ep_disable(dwc->eps[0]);\r\n__dwc3_gadget_ep_disable(dwc->eps[1]);\r\n}\r\nstatic int dwc3_gadget_stop(struct usb_gadget *g)\r\n{\r\nstruct dwc3 *dwc = gadget_to_dwc(g);\r\nunsigned long flags;\r\nint epnum;\r\nspin_lock_irqsave(&dwc->lock, flags);\r\nif (pm_runtime_suspended(dwc->dev))\r\ngoto out;\r\n__dwc3_gadget_stop(dwc);\r\nfor (epnum = 2; epnum < DWC3_ENDPOINTS_NUM; epnum++) {\r\nstruct dwc3_ep *dep = dwc->eps[epnum];\r\nif (!dep)\r\ncontinue;\r\nif (!(dep->flags & DWC3_EP_END_TRANSFER_PENDING))\r\ncontinue;\r\nwait_event_lock_irq(dep->wait_end_transfer,\r\n!(dep->flags & DWC3_EP_END_TRANSFER_PENDING),\r\ndwc->lock);\r\n}\r\nout:\r\ndwc->gadget_driver = NULL;\r\nspin_unlock_irqrestore(&dwc->lock, flags);\r\nfree_irq(dwc->irq_gadget, dwc->ev_buf);\r\nreturn 0;\r\n}\r\nstatic void dwc3_gadget_set_speed(struct usb_gadget *g,\r\nenum usb_device_speed speed)\r\n{\r\nstruct dwc3 *dwc = gadget_to_dwc(g);\r\nunsigned long flags;\r\nu32 reg;\r\nspin_lock_irqsave(&dwc->lock, flags);\r\nreg = dwc3_readl(dwc->regs, DWC3_DCFG);\r\nreg &= ~(DWC3_DCFG_SPEED_MASK);\r\nif (dwc->revision < DWC3_REVISION_220A) {\r\nreg |= DWC3_DCFG_SUPERSPEED;\r\n} else {\r\nswitch (speed) {\r\ncase USB_SPEED_LOW:\r\nreg |= DWC3_DCFG_LOWSPEED;\r\nbreak;\r\ncase USB_SPEED_FULL:\r\nreg |= DWC3_DCFG_FULLSPEED;\r\nbreak;\r\ncase USB_SPEED_HIGH:\r\nreg |= DWC3_DCFG_HIGHSPEED;\r\nbreak;\r\ncase USB_SPEED_SUPER:\r\nreg |= DWC3_DCFG_SUPERSPEED;\r\nbreak;\r\ncase USB_SPEED_SUPER_PLUS:\r\nreg |= DWC3_DCFG_SUPERSPEED_PLUS;\r\nbreak;\r\ndefault:\r\ndev_err(dwc->dev, "invalid speed (%d)\n", speed);\r\nif (dwc->revision & DWC3_REVISION_IS_DWC31)\r\nreg |= DWC3_DCFG_SUPERSPEED_PLUS;\r\nelse\r\nreg |= DWC3_DCFG_SUPERSPEED;\r\n}\r\n}\r\ndwc3_writel(dwc->regs, DWC3_DCFG, reg);\r\nspin_unlock_irqrestore(&dwc->lock, flags);\r\n}\r\nstatic int dwc3_gadget_init_endpoints(struct dwc3 *dwc, u8 total)\r\n{\r\nstruct dwc3_ep *dep;\r\nu8 epnum;\r\nINIT_LIST_HEAD(&dwc->gadget.ep_list);\r\nfor (epnum = 0; epnum < total; epnum++) {\r\nbool direction = epnum & 1;\r\nu8 num = epnum >> 1;\r\ndep = kzalloc(sizeof(*dep), GFP_KERNEL);\r\nif (!dep)\r\nreturn -ENOMEM;\r\ndep->dwc = dwc;\r\ndep->number = epnum;\r\ndep->direction = direction;\r\ndep->regs = dwc->regs + DWC3_DEP_BASE(epnum);\r\ndwc->eps[epnum] = dep;\r\nsnprintf(dep->name, sizeof(dep->name), "ep%u%s", num,\r\ndirection ? "in" : "out");\r\ndep->endpoint.name = dep->name;\r\nif (!(dep->number > 1)) {\r\ndep->endpoint.desc = &dwc3_gadget_ep0_desc;\r\ndep->endpoint.comp_desc = NULL;\r\n}\r\nspin_lock_init(&dep->lock);\r\nif (num == 0) {\r\nusb_ep_set_maxpacket_limit(&dep->endpoint, 512);\r\ndep->endpoint.maxburst = 1;\r\ndep->endpoint.ops = &dwc3_gadget_ep0_ops;\r\nif (!direction)\r\ndwc->gadget.ep0 = &dep->endpoint;\r\n} else if (direction) {\r\nint mdwidth;\r\nint kbytes;\r\nint size;\r\nint ret;\r\nmdwidth = DWC3_MDWIDTH(dwc->hwparams.hwparams0);\r\nmdwidth /= 8;\r\nsize = dwc3_readl(dwc->regs, DWC3_GTXFIFOSIZ(num));\r\nsize = DWC3_GTXFIFOSIZ_TXFDEF(size);\r\nsize *= mdwidth;\r\nkbytes = size / 1024;\r\nif (kbytes == 0)\r\nkbytes = 1;\r\nsize -= mdwidth * (kbytes + 1);\r\nsize /= kbytes;\r\nusb_ep_set_maxpacket_limit(&dep->endpoint, size);\r\ndep->endpoint.max_streams = 15;\r\ndep->endpoint.ops = &dwc3_gadget_ep_ops;\r\nlist_add_tail(&dep->endpoint.ep_list,\r\n&dwc->gadget.ep_list);\r\nret = dwc3_alloc_trb_pool(dep);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\nint ret;\r\nusb_ep_set_maxpacket_limit(&dep->endpoint, 1024);\r\ndep->endpoint.max_streams = 15;\r\ndep->endpoint.ops = &dwc3_gadget_ep_ops;\r\nlist_add_tail(&dep->endpoint.ep_list,\r\n&dwc->gadget.ep_list);\r\nret = dwc3_alloc_trb_pool(dep);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (num == 0) {\r\ndep->endpoint.caps.type_control = true;\r\n} else {\r\ndep->endpoint.caps.type_iso = true;\r\ndep->endpoint.caps.type_bulk = true;\r\ndep->endpoint.caps.type_int = true;\r\n}\r\ndep->endpoint.caps.dir_in = direction;\r\ndep->endpoint.caps.dir_out = !direction;\r\nINIT_LIST_HEAD(&dep->pending_list);\r\nINIT_LIST_HEAD(&dep->started_list);\r\n}\r\nreturn 0;\r\n}\r\nstatic void dwc3_gadget_free_endpoints(struct dwc3 *dwc)\r\n{\r\nstruct dwc3_ep *dep;\r\nu8 epnum;\r\nfor (epnum = 0; epnum < DWC3_ENDPOINTS_NUM; epnum++) {\r\ndep = dwc->eps[epnum];\r\nif (!dep)\r\ncontinue;\r\nif (epnum != 0 && epnum != 1) {\r\ndwc3_free_trb_pool(dep);\r\nlist_del(&dep->endpoint.ep_list);\r\n}\r\nkfree(dep);\r\n}\r\n}\r\nstatic int __dwc3_cleanup_done_trbs(struct dwc3 *dwc, struct dwc3_ep *dep,\r\nstruct dwc3_request *req, struct dwc3_trb *trb,\r\nconst struct dwc3_event_depevt *event, int status,\r\nint chain)\r\n{\r\nunsigned int count;\r\nunsigned int s_pkt = 0;\r\nunsigned int trb_status;\r\ndwc3_ep_inc_deq(dep);\r\nif (req->trb == trb)\r\ndep->queued_requests--;\r\ntrace_dwc3_complete_trb(dep, trb);\r\nif (chain && (trb->ctrl & DWC3_TRB_CTRL_HWO))\r\ntrb->ctrl &= ~DWC3_TRB_CTRL_HWO;\r\nif ((req->zero || req->unaligned) && (trb->ctrl & DWC3_TRB_CTRL_HWO)) {\r\ntrb->ctrl &= ~DWC3_TRB_CTRL_HWO;\r\nreturn 1;\r\n}\r\ncount = trb->size & DWC3_TRB_SIZE_MASK;\r\nreq->remaining += count;\r\nif ((trb->ctrl & DWC3_TRB_CTRL_HWO) && status != -ESHUTDOWN)\r\nreturn 1;\r\nif (dep->direction) {\r\nif (count) {\r\ntrb_status = DWC3_TRB_SIZE_TRBSTS(trb->size);\r\nif (trb_status == DWC3_TRBSTS_MISSED_ISOC) {\r\ndep->flags |= DWC3_EP_MISSED_ISOC;\r\n} else {\r\ndev_err(dwc->dev, "incomplete IN transfer %s\n",\r\ndep->name);\r\nstatus = -ECONNRESET;\r\n}\r\n} else {\r\ndep->flags &= ~DWC3_EP_MISSED_ISOC;\r\n}\r\n} else {\r\nif (count && (event->status & DEPEVT_STATUS_SHORT))\r\ns_pkt = 1;\r\n}\r\nif (s_pkt && !chain)\r\nreturn 1;\r\nif ((event->status & DEPEVT_STATUS_IOC) &&\r\n(trb->ctrl & DWC3_TRB_CTRL_IOC))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int dwc3_cleanup_done_reqs(struct dwc3 *dwc, struct dwc3_ep *dep,\r\nconst struct dwc3_event_depevt *event, int status)\r\n{\r\nstruct dwc3_request *req, *n;\r\nstruct dwc3_trb *trb;\r\nbool ioc = false;\r\nint ret = 0;\r\nlist_for_each_entry_safe(req, n, &dep->started_list, list) {\r\nunsigned length;\r\nint chain;\r\nlength = req->request.length;\r\nchain = req->num_pending_sgs > 0;\r\nif (chain) {\r\nstruct scatterlist *sg = req->sg;\r\nstruct scatterlist *s;\r\nunsigned int pending = req->num_pending_sgs;\r\nunsigned int i;\r\nfor_each_sg(sg, s, pending, i) {\r\ntrb = &dep->trb_pool[dep->trb_dequeue];\r\nif (trb->ctrl & DWC3_TRB_CTRL_HWO)\r\nbreak;\r\nreq->sg = sg_next(s);\r\nreq->num_pending_sgs--;\r\nret = __dwc3_cleanup_done_trbs(dwc, dep, req, trb,\r\nevent, status, chain);\r\nif (ret)\r\nbreak;\r\n}\r\n} else {\r\ntrb = &dep->trb_pool[dep->trb_dequeue];\r\nret = __dwc3_cleanup_done_trbs(dwc, dep, req, trb,\r\nevent, status, chain);\r\n}\r\nif (req->unaligned || req->zero) {\r\ntrb = &dep->trb_pool[dep->trb_dequeue];\r\nret = __dwc3_cleanup_done_trbs(dwc, dep, req, trb,\r\nevent, status, false);\r\nreq->unaligned = false;\r\nreq->zero = false;\r\n}\r\nreq->request.actual = length - req->remaining;\r\nif ((req->request.actual < length) && req->num_pending_sgs)\r\nreturn __dwc3_gadget_kick_transfer(dep, 0);\r\ndwc3_gadget_giveback(dep, req, status);\r\nif (ret) {\r\nif ((event->status & DEPEVT_STATUS_IOC) &&\r\n(trb->ctrl & DWC3_TRB_CTRL_IOC))\r\nioc = true;\r\nbreak;\r\n}\r\n}\r\nif (!dep->endpoint.desc)\r\nreturn 1;\r\nif (usb_endpoint_xfer_isoc(dep->endpoint.desc) &&\r\nlist_empty(&dep->started_list)) {\r\nif (list_empty(&dep->pending_list)) {\r\ndep->flags = DWC3_EP_PENDING_REQUEST;\r\n} else {\r\ndwc3_stop_active_transfer(dwc, dep->number, true);\r\ndep->flags = DWC3_EP_ENABLED;\r\n}\r\nreturn 1;\r\n}\r\nif (usb_endpoint_xfer_isoc(dep->endpoint.desc) && ioc)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void dwc3_endpoint_transfer_complete(struct dwc3 *dwc,\r\nstruct dwc3_ep *dep, const struct dwc3_event_depevt *event)\r\n{\r\nunsigned status = 0;\r\nint clean_busy;\r\nu32 is_xfer_complete;\r\nis_xfer_complete = (event->endpoint_event == DWC3_DEPEVT_XFERCOMPLETE);\r\nif (event->status & DEPEVT_STATUS_BUSERR)\r\nstatus = -ECONNRESET;\r\nclean_busy = dwc3_cleanup_done_reqs(dwc, dep, event, status);\r\nif (clean_busy && (!dep->endpoint.desc || is_xfer_complete ||\r\nusb_endpoint_xfer_isoc(dep->endpoint.desc)))\r\ndep->flags &= ~DWC3_EP_BUSY;\r\nif (dwc->revision < DWC3_REVISION_183A) {\r\nu32 reg;\r\nint i;\r\nfor (i = 0; i < DWC3_ENDPOINTS_NUM; i++) {\r\ndep = dwc->eps[i];\r\nif (!(dep->flags & DWC3_EP_ENABLED))\r\ncontinue;\r\nif (!list_empty(&dep->started_list))\r\nreturn;\r\n}\r\nreg = dwc3_readl(dwc->regs, DWC3_DCTL);\r\nreg |= dwc->u1u2;\r\ndwc3_writel(dwc->regs, DWC3_DCTL, reg);\r\ndwc->u1u2 = 0;\r\n}\r\nif (!dep->endpoint.desc)\r\nreturn;\r\nif (!usb_endpoint_xfer_isoc(dep->endpoint.desc)) {\r\nint ret;\r\nret = __dwc3_gadget_kick_transfer(dep, 0);\r\nif (!ret || ret == -EBUSY)\r\nreturn;\r\n}\r\n}\r\nstatic void dwc3_endpoint_interrupt(struct dwc3 *dwc,\r\nconst struct dwc3_event_depevt *event)\r\n{\r\nstruct dwc3_ep *dep;\r\nu8 epnum = event->endpoint_number;\r\nu8 cmd;\r\ndep = dwc->eps[epnum];\r\nif (!(dep->flags & DWC3_EP_ENABLED)) {\r\nif (!(dep->flags & DWC3_EP_END_TRANSFER_PENDING))\r\nreturn;\r\nif (event->endpoint_event != DWC3_DEPEVT_EPCMDCMPLT)\r\nreturn;\r\n}\r\nif (epnum == 0 || epnum == 1) {\r\ndwc3_ep0_interrupt(dwc, event);\r\nreturn;\r\n}\r\nswitch (event->endpoint_event) {\r\ncase DWC3_DEPEVT_XFERCOMPLETE:\r\ndep->resource_index = 0;\r\nif (usb_endpoint_xfer_isoc(dep->endpoint.desc)) {\r\ndev_err(dwc->dev, "XferComplete for Isochronous endpoint\n");\r\nreturn;\r\n}\r\ndwc3_endpoint_transfer_complete(dwc, dep, event);\r\nbreak;\r\ncase DWC3_DEPEVT_XFERINPROGRESS:\r\ndwc3_endpoint_transfer_complete(dwc, dep, event);\r\nbreak;\r\ncase DWC3_DEPEVT_XFERNOTREADY:\r\nif (usb_endpoint_xfer_isoc(dep->endpoint.desc)) {\r\ndwc3_gadget_start_isoc(dwc, dep, event);\r\n} else {\r\nint ret;\r\nret = __dwc3_gadget_kick_transfer(dep, 0);\r\nif (!ret || ret == -EBUSY)\r\nreturn;\r\n}\r\nbreak;\r\ncase DWC3_DEPEVT_STREAMEVT:\r\nif (!usb_endpoint_xfer_bulk(dep->endpoint.desc)) {\r\ndev_err(dwc->dev, "Stream event for non-Bulk %s\n",\r\ndep->name);\r\nreturn;\r\n}\r\nbreak;\r\ncase DWC3_DEPEVT_EPCMDCMPLT:\r\ncmd = DEPEVT_PARAMETER_CMD(event->parameters);\r\nif (cmd == DWC3_DEPCMD_ENDTRANSFER) {\r\ndep->flags &= ~DWC3_EP_END_TRANSFER_PENDING;\r\nwake_up(&dep->wait_end_transfer);\r\n}\r\nbreak;\r\ncase DWC3_DEPEVT_RXTXFIFOEVT:\r\nbreak;\r\n}\r\n}\r\nstatic void dwc3_disconnect_gadget(struct dwc3 *dwc)\r\n{\r\nif (dwc->gadget_driver && dwc->gadget_driver->disconnect) {\r\nspin_unlock(&dwc->lock);\r\ndwc->gadget_driver->disconnect(&dwc->gadget);\r\nspin_lock(&dwc->lock);\r\n}\r\n}\r\nstatic void dwc3_suspend_gadget(struct dwc3 *dwc)\r\n{\r\nif (dwc->gadget_driver && dwc->gadget_driver->suspend) {\r\nspin_unlock(&dwc->lock);\r\ndwc->gadget_driver->suspend(&dwc->gadget);\r\nspin_lock(&dwc->lock);\r\n}\r\n}\r\nstatic void dwc3_resume_gadget(struct dwc3 *dwc)\r\n{\r\nif (dwc->gadget_driver && dwc->gadget_driver->resume) {\r\nspin_unlock(&dwc->lock);\r\ndwc->gadget_driver->resume(&dwc->gadget);\r\nspin_lock(&dwc->lock);\r\n}\r\n}\r\nstatic void dwc3_reset_gadget(struct dwc3 *dwc)\r\n{\r\nif (!dwc->gadget_driver)\r\nreturn;\r\nif (dwc->gadget.speed != USB_SPEED_UNKNOWN) {\r\nspin_unlock(&dwc->lock);\r\nusb_gadget_udc_reset(&dwc->gadget, dwc->gadget_driver);\r\nspin_lock(&dwc->lock);\r\n}\r\n}\r\nstatic void dwc3_stop_active_transfer(struct dwc3 *dwc, u32 epnum, bool force)\r\n{\r\nstruct dwc3_ep *dep;\r\nstruct dwc3_gadget_ep_cmd_params params;\r\nu32 cmd;\r\nint ret;\r\ndep = dwc->eps[epnum];\r\nif ((dep->flags & DWC3_EP_END_TRANSFER_PENDING) ||\r\n!dep->resource_index)\r\nreturn;\r\ncmd = DWC3_DEPCMD_ENDTRANSFER;\r\ncmd |= force ? DWC3_DEPCMD_HIPRI_FORCERM : 0;\r\ncmd |= DWC3_DEPCMD_CMDIOC;\r\ncmd |= DWC3_DEPCMD_PARAM(dep->resource_index);\r\nmemset(&params, 0, sizeof(params));\r\nret = dwc3_send_gadget_ep_cmd(dep, cmd, &params);\r\nWARN_ON_ONCE(ret);\r\ndep->resource_index = 0;\r\ndep->flags &= ~DWC3_EP_BUSY;\r\nif (dwc3_is_usb31(dwc) || dwc->revision < DWC3_REVISION_310A) {\r\ndep->flags |= DWC3_EP_END_TRANSFER_PENDING;\r\nudelay(100);\r\n}\r\n}\r\nstatic void dwc3_clear_stall_all_ep(struct dwc3 *dwc)\r\n{\r\nu32 epnum;\r\nfor (epnum = 1; epnum < DWC3_ENDPOINTS_NUM; epnum++) {\r\nstruct dwc3_ep *dep;\r\nint ret;\r\ndep = dwc->eps[epnum];\r\nif (!dep)\r\ncontinue;\r\nif (!(dep->flags & DWC3_EP_STALL))\r\ncontinue;\r\ndep->flags &= ~DWC3_EP_STALL;\r\nret = dwc3_send_clear_stall_ep_cmd(dep);\r\nWARN_ON_ONCE(ret);\r\n}\r\n}\r\nstatic void dwc3_gadget_disconnect_interrupt(struct dwc3 *dwc)\r\n{\r\nint reg;\r\nreg = dwc3_readl(dwc->regs, DWC3_DCTL);\r\nreg &= ~DWC3_DCTL_INITU1ENA;\r\ndwc3_writel(dwc->regs, DWC3_DCTL, reg);\r\nreg &= ~DWC3_DCTL_INITU2ENA;\r\ndwc3_writel(dwc->regs, DWC3_DCTL, reg);\r\ndwc3_disconnect_gadget(dwc);\r\ndwc->gadget.speed = USB_SPEED_UNKNOWN;\r\ndwc->setup_packet_pending = false;\r\nusb_gadget_set_state(&dwc->gadget, USB_STATE_NOTATTACHED);\r\ndwc->connected = false;\r\n}\r\nstatic void dwc3_gadget_reset_interrupt(struct dwc3 *dwc)\r\n{\r\nu32 reg;\r\ndwc->connected = true;\r\nif (dwc->revision < DWC3_REVISION_188A) {\r\nif (dwc->setup_packet_pending)\r\ndwc3_gadget_disconnect_interrupt(dwc);\r\n}\r\ndwc3_reset_gadget(dwc);\r\nreg = dwc3_readl(dwc->regs, DWC3_DCTL);\r\nreg &= ~DWC3_DCTL_TSTCTRL_MASK;\r\ndwc3_writel(dwc->regs, DWC3_DCTL, reg);\r\ndwc->test_mode = false;\r\ndwc3_clear_stall_all_ep(dwc);\r\nreg = dwc3_readl(dwc->regs, DWC3_DCFG);\r\nreg &= ~(DWC3_DCFG_DEVADDR_MASK);\r\ndwc3_writel(dwc->regs, DWC3_DCFG, reg);\r\n}\r\nstatic void dwc3_gadget_conndone_interrupt(struct dwc3 *dwc)\r\n{\r\nstruct dwc3_ep *dep;\r\nint ret;\r\nu32 reg;\r\nu8 speed;\r\nreg = dwc3_readl(dwc->regs, DWC3_DSTS);\r\nspeed = reg & DWC3_DSTS_CONNECTSPD;\r\ndwc->speed = speed;\r\nswitch (speed) {\r\ncase DWC3_DSTS_SUPERSPEED_PLUS:\r\ndwc3_gadget_ep0_desc.wMaxPacketSize = cpu_to_le16(512);\r\ndwc->gadget.ep0->maxpacket = 512;\r\ndwc->gadget.speed = USB_SPEED_SUPER_PLUS;\r\nbreak;\r\ncase DWC3_DSTS_SUPERSPEED:\r\nif (dwc->revision < DWC3_REVISION_190A)\r\ndwc3_gadget_reset_interrupt(dwc);\r\ndwc3_gadget_ep0_desc.wMaxPacketSize = cpu_to_le16(512);\r\ndwc->gadget.ep0->maxpacket = 512;\r\ndwc->gadget.speed = USB_SPEED_SUPER;\r\nbreak;\r\ncase DWC3_DSTS_HIGHSPEED:\r\ndwc3_gadget_ep0_desc.wMaxPacketSize = cpu_to_le16(64);\r\ndwc->gadget.ep0->maxpacket = 64;\r\ndwc->gadget.speed = USB_SPEED_HIGH;\r\nbreak;\r\ncase DWC3_DSTS_FULLSPEED:\r\ndwc3_gadget_ep0_desc.wMaxPacketSize = cpu_to_le16(64);\r\ndwc->gadget.ep0->maxpacket = 64;\r\ndwc->gadget.speed = USB_SPEED_FULL;\r\nbreak;\r\ncase DWC3_DSTS_LOWSPEED:\r\ndwc3_gadget_ep0_desc.wMaxPacketSize = cpu_to_le16(8);\r\ndwc->gadget.ep0->maxpacket = 8;\r\ndwc->gadget.speed = USB_SPEED_LOW;\r\nbreak;\r\n}\r\nif ((dwc->revision > DWC3_REVISION_194A) &&\r\n(speed != DWC3_DSTS_SUPERSPEED) &&\r\n(speed != DWC3_DSTS_SUPERSPEED_PLUS)) {\r\nreg = dwc3_readl(dwc->regs, DWC3_DCFG);\r\nreg |= DWC3_DCFG_LPM_CAP;\r\ndwc3_writel(dwc->regs, DWC3_DCFG, reg);\r\nreg = dwc3_readl(dwc->regs, DWC3_DCTL);\r\nreg &= ~(DWC3_DCTL_HIRD_THRES_MASK | DWC3_DCTL_L1_HIBER_EN);\r\nreg |= DWC3_DCTL_HIRD_THRES(dwc->hird_threshold);\r\nWARN_ONCE(dwc->revision < DWC3_REVISION_240A\r\n&& dwc->has_lpm_erratum,\r\n"LPM Erratum not available on dwc3 revisions < 2.40a\n");\r\nif (dwc->has_lpm_erratum && dwc->revision >= DWC3_REVISION_240A)\r\nreg |= DWC3_DCTL_LPM_ERRATA(dwc->lpm_nyet_threshold);\r\ndwc3_writel(dwc->regs, DWC3_DCTL, reg);\r\n} else {\r\nreg = dwc3_readl(dwc->regs, DWC3_DCTL);\r\nreg &= ~DWC3_DCTL_HIRD_THRES_MASK;\r\ndwc3_writel(dwc->regs, DWC3_DCTL, reg);\r\n}\r\ndep = dwc->eps[0];\r\nret = __dwc3_gadget_ep_enable(dep, true, false);\r\nif (ret) {\r\ndev_err(dwc->dev, "failed to enable %s\n", dep->name);\r\nreturn;\r\n}\r\ndep = dwc->eps[1];\r\nret = __dwc3_gadget_ep_enable(dep, true, false);\r\nif (ret) {\r\ndev_err(dwc->dev, "failed to enable %s\n", dep->name);\r\nreturn;\r\n}\r\n}\r\nstatic void dwc3_gadget_wakeup_interrupt(struct dwc3 *dwc)\r\n{\r\nif (dwc->gadget_driver && dwc->gadget_driver->resume) {\r\nspin_unlock(&dwc->lock);\r\ndwc->gadget_driver->resume(&dwc->gadget);\r\nspin_lock(&dwc->lock);\r\n}\r\n}\r\nstatic void dwc3_gadget_linksts_change_interrupt(struct dwc3 *dwc,\r\nunsigned int evtinfo)\r\n{\r\nenum dwc3_link_state next = evtinfo & DWC3_LINK_STATE_MASK;\r\nunsigned int pwropt;\r\npwropt = DWC3_GHWPARAMS1_EN_PWROPT(dwc->hwparams.hwparams1);\r\nif ((dwc->revision < DWC3_REVISION_250A) &&\r\n(pwropt != DWC3_GHWPARAMS1_EN_PWROPT_HIB)) {\r\nif ((dwc->link_state == DWC3_LINK_STATE_U3) &&\r\n(next == DWC3_LINK_STATE_RESUME)) {\r\nreturn;\r\n}\r\n}\r\nif (dwc->revision < DWC3_REVISION_183A) {\r\nif (next == DWC3_LINK_STATE_U0) {\r\nu32 u1u2;\r\nu32 reg;\r\nswitch (dwc->link_state) {\r\ncase DWC3_LINK_STATE_U1:\r\ncase DWC3_LINK_STATE_U2:\r\nreg = dwc3_readl(dwc->regs, DWC3_DCTL);\r\nu1u2 = reg & (DWC3_DCTL_INITU2ENA\r\n| DWC3_DCTL_ACCEPTU2ENA\r\n| DWC3_DCTL_INITU1ENA\r\n| DWC3_DCTL_ACCEPTU1ENA);\r\nif (!dwc->u1u2)\r\ndwc->u1u2 = reg & u1u2;\r\nreg &= ~u1u2;\r\ndwc3_writel(dwc->regs, DWC3_DCTL, reg);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nswitch (next) {\r\ncase DWC3_LINK_STATE_U1:\r\nif (dwc->speed == USB_SPEED_SUPER)\r\ndwc3_suspend_gadget(dwc);\r\nbreak;\r\ncase DWC3_LINK_STATE_U2:\r\ncase DWC3_LINK_STATE_U3:\r\ndwc3_suspend_gadget(dwc);\r\nbreak;\r\ncase DWC3_LINK_STATE_RESUME:\r\ndwc3_resume_gadget(dwc);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ndwc->link_state = next;\r\n}\r\nstatic void dwc3_gadget_suspend_interrupt(struct dwc3 *dwc,\r\nunsigned int evtinfo)\r\n{\r\nenum dwc3_link_state next = evtinfo & DWC3_LINK_STATE_MASK;\r\nif (dwc->link_state != next && next == DWC3_LINK_STATE_U3)\r\ndwc3_suspend_gadget(dwc);\r\ndwc->link_state = next;\r\n}\r\nstatic void dwc3_gadget_hibernation_interrupt(struct dwc3 *dwc,\r\nunsigned int evtinfo)\r\n{\r\nunsigned int is_ss = evtinfo & BIT(4);\r\nif (is_ss ^ (dwc->speed == USB_SPEED_SUPER))\r\nreturn;\r\n}\r\nstatic void dwc3_gadget_interrupt(struct dwc3 *dwc,\r\nconst struct dwc3_event_devt *event)\r\n{\r\nswitch (event->type) {\r\ncase DWC3_DEVICE_EVENT_DISCONNECT:\r\ndwc3_gadget_disconnect_interrupt(dwc);\r\nbreak;\r\ncase DWC3_DEVICE_EVENT_RESET:\r\ndwc3_gadget_reset_interrupt(dwc);\r\nbreak;\r\ncase DWC3_DEVICE_EVENT_CONNECT_DONE:\r\ndwc3_gadget_conndone_interrupt(dwc);\r\nbreak;\r\ncase DWC3_DEVICE_EVENT_WAKEUP:\r\ndwc3_gadget_wakeup_interrupt(dwc);\r\nbreak;\r\ncase DWC3_DEVICE_EVENT_HIBER_REQ:\r\nif (dev_WARN_ONCE(dwc->dev, !dwc->has_hibernation,\r\n"unexpected hibernation event\n"))\r\nbreak;\r\ndwc3_gadget_hibernation_interrupt(dwc, event->event_info);\r\nbreak;\r\ncase DWC3_DEVICE_EVENT_LINK_STATUS_CHANGE:\r\ndwc3_gadget_linksts_change_interrupt(dwc, event->event_info);\r\nbreak;\r\ncase DWC3_DEVICE_EVENT_EOPF:\r\nif (dwc->revision >= DWC3_REVISION_230A) {\r\nif (dwc->gadget.state >= USB_STATE_CONFIGURED)\r\ndwc3_gadget_suspend_interrupt(dwc,\r\nevent->event_info);\r\n}\r\nbreak;\r\ncase DWC3_DEVICE_EVENT_SOF:\r\ncase DWC3_DEVICE_EVENT_ERRATIC_ERROR:\r\ncase DWC3_DEVICE_EVENT_CMD_CMPL:\r\ncase DWC3_DEVICE_EVENT_OVERFLOW:\r\nbreak;\r\ndefault:\r\ndev_WARN(dwc->dev, "UNKNOWN IRQ %d\n", event->type);\r\n}\r\n}\r\nstatic void dwc3_process_event_entry(struct dwc3 *dwc,\r\nconst union dwc3_event *event)\r\n{\r\ntrace_dwc3_event(event->raw, dwc);\r\nif (!event->type.is_devspec)\r\ndwc3_endpoint_interrupt(dwc, &event->depevt);\r\nelse if (event->type.type == DWC3_EVENT_TYPE_DEV)\r\ndwc3_gadget_interrupt(dwc, &event->devt);\r\nelse\r\ndev_err(dwc->dev, "UNKNOWN IRQ type %d\n", event->raw);\r\n}\r\nstatic irqreturn_t dwc3_process_event_buf(struct dwc3_event_buffer *evt)\r\n{\r\nstruct dwc3 *dwc = evt->dwc;\r\nirqreturn_t ret = IRQ_NONE;\r\nint left;\r\nu32 reg;\r\nleft = evt->count;\r\nif (!(evt->flags & DWC3_EVENT_PENDING))\r\nreturn IRQ_NONE;\r\nwhile (left > 0) {\r\nunion dwc3_event event;\r\nevent.raw = *(u32 *) (evt->cache + evt->lpos);\r\ndwc3_process_event_entry(dwc, &event);\r\nevt->lpos = (evt->lpos + 4) % evt->length;\r\nleft -= 4;\r\n}\r\nevt->count = 0;\r\nevt->flags &= ~DWC3_EVENT_PENDING;\r\nret = IRQ_HANDLED;\r\nreg = dwc3_readl(dwc->regs, DWC3_GEVNTSIZ(0));\r\nreg &= ~DWC3_GEVNTSIZ_INTMASK;\r\ndwc3_writel(dwc->regs, DWC3_GEVNTSIZ(0), reg);\r\nif (dwc->imod_interval) {\r\ndwc3_writel(dwc->regs, DWC3_GEVNTCOUNT(0), DWC3_GEVNTCOUNT_EHB);\r\ndwc3_writel(dwc->regs, DWC3_DEV_IMOD(0), dwc->imod_interval);\r\n}\r\nreturn ret;\r\n}\r\nstatic irqreturn_t dwc3_thread_interrupt(int irq, void *_evt)\r\n{\r\nstruct dwc3_event_buffer *evt = _evt;\r\nstruct dwc3 *dwc = evt->dwc;\r\nunsigned long flags;\r\nirqreturn_t ret = IRQ_NONE;\r\nspin_lock_irqsave(&dwc->lock, flags);\r\nret = dwc3_process_event_buf(evt);\r\nspin_unlock_irqrestore(&dwc->lock, flags);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t dwc3_check_event_buf(struct dwc3_event_buffer *evt)\r\n{\r\nstruct dwc3 *dwc = evt->dwc;\r\nu32 amount;\r\nu32 count;\r\nu32 reg;\r\nif (pm_runtime_suspended(dwc->dev)) {\r\npm_runtime_get(dwc->dev);\r\ndisable_irq_nosync(dwc->irq_gadget);\r\ndwc->pending_events = true;\r\nreturn IRQ_HANDLED;\r\n}\r\nif (evt->flags & DWC3_EVENT_PENDING)\r\nreturn IRQ_HANDLED;\r\ncount = dwc3_readl(dwc->regs, DWC3_GEVNTCOUNT(0));\r\ncount &= DWC3_GEVNTCOUNT_MASK;\r\nif (!count)\r\nreturn IRQ_NONE;\r\nevt->count = count;\r\nevt->flags |= DWC3_EVENT_PENDING;\r\nreg = dwc3_readl(dwc->regs, DWC3_GEVNTSIZ(0));\r\nreg |= DWC3_GEVNTSIZ_INTMASK;\r\ndwc3_writel(dwc->regs, DWC3_GEVNTSIZ(0), reg);\r\namount = min(count, evt->length - evt->lpos);\r\nmemcpy(evt->cache + evt->lpos, evt->buf + evt->lpos, amount);\r\nif (amount < count)\r\nmemcpy(evt->cache, evt->buf, count - amount);\r\ndwc3_writel(dwc->regs, DWC3_GEVNTCOUNT(0), count);\r\nreturn IRQ_WAKE_THREAD;\r\n}\r\nstatic irqreturn_t dwc3_interrupt(int irq, void *_evt)\r\n{\r\nstruct dwc3_event_buffer *evt = _evt;\r\nreturn dwc3_check_event_buf(evt);\r\n}\r\nstatic int dwc3_gadget_get_irq(struct dwc3 *dwc)\r\n{\r\nstruct platform_device *dwc3_pdev = to_platform_device(dwc->dev);\r\nint irq;\r\nirq = platform_get_irq_byname(dwc3_pdev, "peripheral");\r\nif (irq > 0)\r\ngoto out;\r\nif (irq == -EPROBE_DEFER)\r\ngoto out;\r\nirq = platform_get_irq_byname(dwc3_pdev, "dwc_usb3");\r\nif (irq > 0)\r\ngoto out;\r\nif (irq == -EPROBE_DEFER)\r\ngoto out;\r\nirq = platform_get_irq(dwc3_pdev, 0);\r\nif (irq > 0)\r\ngoto out;\r\nif (irq != -EPROBE_DEFER)\r\ndev_err(dwc->dev, "missing peripheral IRQ\n");\r\nif (!irq)\r\nirq = -EINVAL;\r\nout:\r\nreturn irq;\r\n}\r\nint dwc3_gadget_init(struct dwc3 *dwc)\r\n{\r\nint ret;\r\nint irq;\r\nirq = dwc3_gadget_get_irq(dwc);\r\nif (irq < 0) {\r\nret = irq;\r\ngoto err0;\r\n}\r\ndwc->irq_gadget = irq;\r\ndwc->ep0_trb = dma_alloc_coherent(dwc->sysdev,\r\nsizeof(*dwc->ep0_trb) * 2,\r\n&dwc->ep0_trb_addr, GFP_KERNEL);\r\nif (!dwc->ep0_trb) {\r\ndev_err(dwc->dev, "failed to allocate ep0 trb\n");\r\nret = -ENOMEM;\r\ngoto err0;\r\n}\r\ndwc->setup_buf = kzalloc(DWC3_EP0_SETUP_SIZE, GFP_KERNEL);\r\nif (!dwc->setup_buf) {\r\nret = -ENOMEM;\r\ngoto err1;\r\n}\r\ndwc->bounce = dma_alloc_coherent(dwc->sysdev, DWC3_BOUNCE_SIZE,\r\n&dwc->bounce_addr, GFP_KERNEL);\r\nif (!dwc->bounce) {\r\nret = -ENOMEM;\r\ngoto err2;\r\n}\r\ninit_completion(&dwc->ep0_in_setup);\r\ndwc->gadget.ops = &dwc3_gadget_ops;\r\ndwc->gadget.speed = USB_SPEED_UNKNOWN;\r\ndwc->gadget.sg_supported = true;\r\ndwc->gadget.name = "dwc3-gadget";\r\ndwc->gadget.is_otg = dwc->dr_mode == USB_DR_MODE_OTG;\r\nif (dwc->revision < DWC3_REVISION_220A)\r\ndev_info(dwc->dev, "changing max_speed on rev %08x\n",\r\ndwc->revision);\r\ndwc->gadget.max_speed = dwc->maximum_speed;\r\nret = dwc3_gadget_init_endpoints(dwc, dwc->num_eps);\r\nif (ret)\r\ngoto err3;\r\nret = usb_add_gadget_udc(dwc->dev, &dwc->gadget);\r\nif (ret) {\r\ndev_err(dwc->dev, "failed to register udc\n");\r\ngoto err4;\r\n}\r\nreturn 0;\r\nerr4:\r\ndwc3_gadget_free_endpoints(dwc);\r\nerr3:\r\ndma_free_coherent(dwc->sysdev, DWC3_BOUNCE_SIZE, dwc->bounce,\r\ndwc->bounce_addr);\r\nerr2:\r\nkfree(dwc->setup_buf);\r\nerr1:\r\ndma_free_coherent(dwc->sysdev, sizeof(*dwc->ep0_trb) * 2,\r\ndwc->ep0_trb, dwc->ep0_trb_addr);\r\nerr0:\r\nreturn ret;\r\n}\r\nvoid dwc3_gadget_exit(struct dwc3 *dwc)\r\n{\r\nusb_del_gadget_udc(&dwc->gadget);\r\ndwc3_gadget_free_endpoints(dwc);\r\ndma_free_coherent(dwc->sysdev, DWC3_BOUNCE_SIZE, dwc->bounce,\r\ndwc->bounce_addr);\r\nkfree(dwc->setup_buf);\r\ndma_free_coherent(dwc->sysdev, sizeof(*dwc->ep0_trb) * 2,\r\ndwc->ep0_trb, dwc->ep0_trb_addr);\r\n}\r\nint dwc3_gadget_suspend(struct dwc3 *dwc)\r\n{\r\nif (!dwc->gadget_driver)\r\nreturn 0;\r\ndwc3_gadget_run_stop(dwc, false, false);\r\ndwc3_disconnect_gadget(dwc);\r\n__dwc3_gadget_stop(dwc);\r\nreturn 0;\r\n}\r\nint dwc3_gadget_resume(struct dwc3 *dwc)\r\n{\r\nint ret;\r\nif (!dwc->gadget_driver)\r\nreturn 0;\r\nret = __dwc3_gadget_start(dwc);\r\nif (ret < 0)\r\ngoto err0;\r\nret = dwc3_gadget_run_stop(dwc, true, false);\r\nif (ret < 0)\r\ngoto err1;\r\nreturn 0;\r\nerr1:\r\n__dwc3_gadget_stop(dwc);\r\nerr0:\r\nreturn ret;\r\n}\r\nvoid dwc3_gadget_process_pending_events(struct dwc3 *dwc)\r\n{\r\nif (dwc->pending_events) {\r\ndwc3_interrupt(dwc->irq_gadget, dwc->ev_buf);\r\ndwc->pending_events = false;\r\nenable_irq(dwc->irq_gadget);\r\n}\r\n}
