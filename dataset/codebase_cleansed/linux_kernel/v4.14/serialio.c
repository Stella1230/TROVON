const struct old_serial_port *spk_serial_init(int index)\r\n{\r\nint baud = 9600, quot = 0;\r\nunsigned int cval = 0;\r\nint cflag = CREAD | HUPCL | CLOCAL | B9600 | CS8;\r\nconst struct old_serial_port *ser;\r\nint err;\r\nif (index >= ARRAY_SIZE(rs_table)) {\r\npr_info("no port info for ttyS%d\n", index);\r\nreturn NULL;\r\n}\r\nser = rs_table + index;\r\nquot = ser->baud_base / baud;\r\ncval = cflag & (CSIZE | CSTOPB);\r\n#if defined(__powerpc__) || defined(__alpha__)\r\ncval >>= 8;\r\n#else\r\ncval >>= 4;\r\n#endif\r\nif (cflag & PARENB)\r\ncval |= UART_LCR_PARITY;\r\nif (!(cflag & PARODD))\r\ncval |= UART_LCR_EPAR;\r\nif (synth_request_region(ser->port, 8)) {\r\npr_info("Ports not available, trying to steal them\n");\r\n__release_region(&ioport_resource, ser->port, 8);\r\nerr = synth_request_region(ser->port, 8);\r\nif (err) {\r\npr_warn("Unable to allocate port at %x, errno %i",\r\nser->port, err);\r\nreturn NULL;\r\n}\r\n}\r\noutb(cval | UART_LCR_DLAB, ser->port + UART_LCR);\r\noutb(quot & 0xff, ser->port + UART_DLL);\r\noutb(quot >> 8, ser->port + UART_DLM);\r\noutb(cval, ser->port + UART_LCR);\r\noutb(0, ser->port + UART_IER);\r\noutb(UART_MCR_DTR | UART_MCR_RTS, ser->port + UART_MCR);\r\nif (inb(ser->port + UART_LSR) == 0xff) {\r\nsynth_release_region(ser->port, 8);\r\nserstate = NULL;\r\nreturn NULL;\r\n}\r\nmdelay(1);\r\nspeakup_info.port_tts = ser->port;\r\nserstate = ser;\r\nstart_serial_interrupt(ser->irq);\r\nreturn ser;\r\n}\r\nstatic irqreturn_t synth_readbuf_handler(int irq, void *dev_id)\r\n{\r\nunsigned long flags;\r\nint c;\r\nspin_lock_irqsave(&speakup_info.spinlock, flags);\r\nwhile (inb_p(speakup_info.port_tts + UART_LSR) & UART_LSR_DR) {\r\nc = inb_p(speakup_info.port_tts + UART_RX);\r\nsynth->read_buff_add((u_char)c);\r\n}\r\nspin_unlock_irqrestore(&speakup_info.spinlock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void start_serial_interrupt(int irq)\r\n{\r\nint rv;\r\nif (!synth->read_buff_add)\r\nreturn;\r\nrv = request_irq(irq, synth_readbuf_handler, IRQF_SHARED,\r\n"serial", (void *)synth_readbuf_handler);\r\nif (rv)\r\npr_err("Unable to request Speakup serial I R Q\n");\r\noutb(UART_MCR_DTR | UART_MCR_RTS | UART_MCR_OUT2,\r\nspeakup_info.port_tts + UART_MCR);\r\noutb(UART_IER_MSI | UART_IER_RLSI | UART_IER_RDI,\r\nspeakup_info.port_tts + UART_IER);\r\ninb(speakup_info.port_tts + UART_LSR);\r\ninb(speakup_info.port_tts + UART_RX);\r\ninb(speakup_info.port_tts + UART_IIR);\r\ninb(speakup_info.port_tts + UART_MSR);\r\noutb(1, speakup_info.port_tts + UART_FCR);\r\n}\r\nstatic void spk_serial_send_xchar(char ch)\r\n{\r\nint timeout = SPK_XMITR_TIMEOUT;\r\nwhile (spk_serial_tx_busy()) {\r\nif (!--timeout)\r\nbreak;\r\nudelay(1);\r\n}\r\noutb(ch, speakup_info.port_tts);\r\n}\r\nstatic void spk_serial_tiocmset(unsigned int set, unsigned int clear)\r\n{\r\nint old = inb(speakup_info.port_tts + UART_MCR);\r\noutb((old & ~clear) | set, speakup_info.port_tts + UART_MCR);\r\n}\r\nint spk_serial_synth_probe(struct spk_synth *synth)\r\n{\r\nconst struct old_serial_port *ser;\r\nint failed = 0;\r\nif ((synth->ser >= SPK_LO_TTY) && (synth->ser <= SPK_HI_TTY)) {\r\nser = spk_serial_init(synth->ser);\r\nif (!ser) {\r\nfailed = -1;\r\n} else {\r\noutb_p(0, ser->port);\r\nmdelay(1);\r\noutb_p('\r', ser->port);\r\n}\r\n} else {\r\nfailed = -1;\r\npr_warn("ttyS%i is an invalid port\n", synth->ser);\r\n}\r\nif (failed) {\r\npr_info("%s: not found\n", synth->long_name);\r\nreturn -ENODEV;\r\n}\r\npr_info("%s: ttyS%i, Driver Version %s\n",\r\nsynth->long_name, synth->ser, synth->version);\r\nsynth->alive = 1;\r\nreturn 0;\r\n}\r\nvoid spk_stop_serial_interrupt(void)\r\n{\r\nif (speakup_info.port_tts == 0)\r\nreturn;\r\nif (!synth->read_buff_add)\r\nreturn;\r\noutb(0, speakup_info.port_tts + UART_IER);\r\nfree_irq(serstate->irq, (void *)synth_readbuf_handler);\r\n}\r\nint spk_wait_for_xmitr(struct spk_synth *in_synth)\r\n{\r\nint tmout = SPK_XMITR_TIMEOUT;\r\nif ((in_synth->alive) && (timeouts >= NUM_DISABLE_TIMEOUTS)) {\r\npr_warn("%s: too many timeouts, deactivating speakup\n",\r\nin_synth->long_name);\r\nin_synth->alive = 0;\r\nspeakup_start_ttys();\r\ntimeouts = 0;\r\nreturn 0;\r\n}\r\nwhile (spk_serial_tx_busy()) {\r\nif (--tmout == 0) {\r\npr_warn("%s: timed out (tx busy)\n",\r\nin_synth->long_name);\r\ntimeouts++;\r\nreturn 0;\r\n}\r\nudelay(1);\r\n}\r\ntmout = SPK_CTS_TIMEOUT;\r\nwhile (!((inb_p(speakup_info.port_tts + UART_MSR)) & UART_MSR_CTS)) {\r\nif (--tmout == 0) {\r\ntimeouts++;\r\nreturn 0;\r\n}\r\nudelay(1);\r\n}\r\ntimeouts = 0;\r\nreturn 1;\r\n}\r\nstatic unsigned char spk_serial_in(void)\r\n{\r\nint tmout = SPK_SERIAL_TIMEOUT;\r\nwhile (!(inb_p(speakup_info.port_tts + UART_LSR) & UART_LSR_DR)) {\r\nif (--tmout == 0) {\r\npr_warn("time out while waiting for input.\n");\r\nreturn 0xff;\r\n}\r\nudelay(1);\r\n}\r\nreturn inb_p(speakup_info.port_tts + UART_RX);\r\n}\r\nstatic unsigned char spk_serial_in_nowait(void)\r\n{\r\nunsigned char lsr;\r\nlsr = inb_p(speakup_info.port_tts + UART_LSR);\r\nif (!(lsr & UART_LSR_DR))\r\nreturn 0;\r\nreturn inb_p(speakup_info.port_tts + UART_RX);\r\n}\r\nstatic void spk_serial_flush_buffer(void)\r\n{\r\n}\r\nstatic int spk_serial_out(struct spk_synth *in_synth, const char ch)\r\n{\r\nif (in_synth->alive && spk_wait_for_xmitr(in_synth)) {\r\noutb_p(ch, speakup_info.port_tts);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nconst char *spk_serial_synth_immediate(struct spk_synth *synth,\r\nconst char *buff)\r\n{\r\nu_char ch;\r\nwhile ((ch = *buff)) {\r\nif (ch == '\n')\r\nch = synth->procspeech;\r\nif (spk_wait_for_xmitr(synth))\r\noutb(ch, speakup_info.port_tts);\r\nelse\r\nreturn buff;\r\nbuff++;\r\n}\r\nreturn NULL;\r\n}\r\nvoid spk_serial_release(void)\r\n{\r\nspk_stop_serial_interrupt();\r\nif (speakup_info.port_tts == 0)\r\nreturn;\r\nsynth_release_region(speakup_info.port_tts, 8);\r\nspeakup_info.port_tts = 0;\r\n}
