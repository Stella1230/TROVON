void wl1251_enable_interrupts(struct wl1251 *wl)\r\n{\r\nwl->if_ops->enable_irq(wl);\r\n}\r\nvoid wl1251_disable_interrupts(struct wl1251 *wl)\r\n{\r\nwl->if_ops->disable_irq(wl);\r\n}\r\nstatic int wl1251_power_off(struct wl1251 *wl)\r\n{\r\nreturn wl->if_ops->power(wl, false);\r\n}\r\nstatic int wl1251_power_on(struct wl1251 *wl)\r\n{\r\nreturn wl->if_ops->power(wl, true);\r\n}\r\nstatic int wl1251_fetch_firmware(struct wl1251 *wl)\r\n{\r\nconst struct firmware *fw;\r\nstruct device *dev = wiphy_dev(wl->hw->wiphy);\r\nint ret;\r\nret = request_firmware(&fw, WL1251_FW_NAME, dev);\r\nif (ret < 0) {\r\nwl1251_error("could not get firmware: %d", ret);\r\nreturn ret;\r\n}\r\nif (fw->size % 4) {\r\nwl1251_error("firmware size is not multiple of 32 bits: %zu",\r\nfw->size);\r\nret = -EILSEQ;\r\ngoto out;\r\n}\r\nwl->fw_len = fw->size;\r\nwl->fw = vmalloc(wl->fw_len);\r\nif (!wl->fw) {\r\nwl1251_error("could not allocate memory for the firmware");\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nmemcpy(wl->fw, fw->data, wl->fw_len);\r\nret = 0;\r\nout:\r\nrelease_firmware(fw);\r\nreturn ret;\r\n}\r\nstatic int wl1251_fetch_nvs(struct wl1251 *wl)\r\n{\r\nconst struct firmware *fw;\r\nstruct device *dev = wiphy_dev(wl->hw->wiphy);\r\nint ret;\r\nret = request_firmware(&fw, WL1251_NVS_NAME, dev);\r\nif (ret < 0) {\r\nwl1251_error("could not get nvs file: %d", ret);\r\nreturn ret;\r\n}\r\nif (fw->size % 4) {\r\nwl1251_error("nvs size is not multiple of 32 bits: %zu",\r\nfw->size);\r\nret = -EILSEQ;\r\ngoto out;\r\n}\r\nwl->nvs_len = fw->size;\r\nwl->nvs = kmemdup(fw->data, wl->nvs_len, GFP_KERNEL);\r\nif (!wl->nvs) {\r\nwl1251_error("could not allocate memory for the nvs file");\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nret = 0;\r\nout:\r\nrelease_firmware(fw);\r\nreturn ret;\r\n}\r\nstatic void wl1251_fw_wakeup(struct wl1251 *wl)\r\n{\r\nu32 elp_reg;\r\nelp_reg = ELPCTRL_WAKE_UP;\r\nwl1251_write_elp(wl, HW_ACCESS_ELP_CTRL_REG_ADDR, elp_reg);\r\nelp_reg = wl1251_read_elp(wl, HW_ACCESS_ELP_CTRL_REG_ADDR);\r\nif (!(elp_reg & ELPCTRL_WLAN_READY))\r\nwl1251_warning("WLAN not ready");\r\n}\r\nstatic int wl1251_chip_wakeup(struct wl1251 *wl)\r\n{\r\nint ret;\r\nret = wl1251_power_on(wl);\r\nif (ret < 0)\r\nreturn ret;\r\nmsleep(WL1251_POWER_ON_SLEEP);\r\nwl->if_ops->reset(wl);\r\nwl1251_set_partition(wl,\r\n0x00000000,\r\n0x00000000,\r\nREGISTERS_BASE,\r\nREGISTERS_DOWN_SIZE);\r\nwl1251_fw_wakeup(wl);\r\nwl->chip_id = wl1251_reg_read32(wl, CHIP_ID_B);\r\nswitch (wl->chip_id) {\r\ncase CHIP_ID_1251_PG12:\r\nwl1251_debug(DEBUG_BOOT, "chip id 0x%x (1251 PG12)",\r\nwl->chip_id);\r\nbreak;\r\ncase CHIP_ID_1251_PG11:\r\nwl1251_debug(DEBUG_BOOT, "chip id 0x%x (1251 PG11)",\r\nwl->chip_id);\r\nbreak;\r\ncase CHIP_ID_1251_PG10:\r\ndefault:\r\nwl1251_error("unsupported chip id: 0x%x", wl->chip_id);\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nif (wl->fw == NULL) {\r\nret = wl1251_fetch_firmware(wl);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\nif (wl->nvs == NULL && !wl->use_eeprom) {\r\nret = wl1251_fetch_nvs(wl);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic void wl1251_irq_work(struct work_struct *work)\r\n{\r\nu32 intr, ctr = WL1251_IRQ_LOOP_COUNT;\r\nstruct wl1251 *wl =\r\ncontainer_of(work, struct wl1251, irq_work);\r\nint ret;\r\nmutex_lock(&wl->mutex);\r\nwl1251_debug(DEBUG_IRQ, "IRQ work");\r\nif (wl->state == WL1251_STATE_OFF)\r\ngoto out;\r\nret = wl1251_ps_elp_wakeup(wl);\r\nif (ret < 0)\r\ngoto out;\r\nwl1251_reg_write32(wl, ACX_REG_INTERRUPT_MASK, WL1251_ACX_INTR_ALL);\r\nintr = wl1251_reg_read32(wl, ACX_REG_INTERRUPT_CLEAR);\r\nwl1251_debug(DEBUG_IRQ, "intr: 0x%x", intr);\r\ndo {\r\nif (wl->data_path) {\r\nwl->rx_counter = wl1251_mem_read32(\r\nwl, wl->data_path->rx_control_addr);\r\nswitch ((wl->rx_counter - wl->rx_handled) & 0xf) {\r\ncase 0:\r\nwl1251_debug(DEBUG_IRQ,\r\n"RX: FW and host in sync");\r\nintr &= ~WL1251_ACX_INTR_RX0_DATA;\r\nintr &= ~WL1251_ACX_INTR_RX1_DATA;\r\nbreak;\r\ncase 1:\r\nwl1251_debug(DEBUG_IRQ, "RX: FW +1");\r\nintr |= WL1251_ACX_INTR_RX0_DATA;\r\nintr &= ~WL1251_ACX_INTR_RX1_DATA;\r\nbreak;\r\ncase 2:\r\nwl1251_debug(DEBUG_IRQ, "RX: FW +2");\r\nintr |= WL1251_ACX_INTR_RX0_DATA;\r\nintr |= WL1251_ACX_INTR_RX1_DATA;\r\nbreak;\r\ndefault:\r\nwl1251_warning(\r\n"RX: FW and host out of sync: %d",\r\nwl->rx_counter - wl->rx_handled);\r\nbreak;\r\n}\r\nwl->rx_handled = wl->rx_counter;\r\nwl1251_debug(DEBUG_IRQ, "RX counter: %d",\r\nwl->rx_counter);\r\n}\r\nintr &= wl->intr_mask;\r\nif (intr == 0) {\r\nwl1251_debug(DEBUG_IRQ, "INTR is 0");\r\ngoto out_sleep;\r\n}\r\nif (intr & WL1251_ACX_INTR_RX0_DATA) {\r\nwl1251_debug(DEBUG_IRQ, "WL1251_ACX_INTR_RX0_DATA");\r\nwl1251_rx(wl);\r\n}\r\nif (intr & WL1251_ACX_INTR_RX1_DATA) {\r\nwl1251_debug(DEBUG_IRQ, "WL1251_ACX_INTR_RX1_DATA");\r\nwl1251_rx(wl);\r\n}\r\nif (intr & WL1251_ACX_INTR_TX_RESULT) {\r\nwl1251_debug(DEBUG_IRQ, "WL1251_ACX_INTR_TX_RESULT");\r\nwl1251_tx_complete(wl);\r\n}\r\nif (intr & WL1251_ACX_INTR_EVENT_A) {\r\nwl1251_debug(DEBUG_IRQ, "WL1251_ACX_INTR_EVENT_A");\r\nwl1251_event_handle(wl, 0);\r\n}\r\nif (intr & WL1251_ACX_INTR_EVENT_B) {\r\nwl1251_debug(DEBUG_IRQ, "WL1251_ACX_INTR_EVENT_B");\r\nwl1251_event_handle(wl, 1);\r\n}\r\nif (intr & WL1251_ACX_INTR_INIT_COMPLETE)\r\nwl1251_debug(DEBUG_IRQ,\r\n"WL1251_ACX_INTR_INIT_COMPLETE");\r\nif (--ctr == 0)\r\nbreak;\r\nintr = wl1251_reg_read32(wl, ACX_REG_INTERRUPT_CLEAR);\r\n} while (intr);\r\nout_sleep:\r\nwl1251_reg_write32(wl, ACX_REG_INTERRUPT_MASK, ~(wl->intr_mask));\r\nwl1251_ps_elp_sleep(wl);\r\nout:\r\nmutex_unlock(&wl->mutex);\r\n}\r\nstatic int wl1251_join(struct wl1251 *wl, u8 bss_type, u8 channel,\r\nu16 beacon_interval, u8 dtim_period)\r\n{\r\nint ret;\r\nret = wl1251_acx_frame_rates(wl, DEFAULT_HW_GEN_TX_RATE,\r\nDEFAULT_HW_GEN_MODULATION_TYPE,\r\nwl->tx_mgmt_frm_rate,\r\nwl->tx_mgmt_frm_mod);\r\nif (ret < 0)\r\ngoto out;\r\nif (is_zero_ether_addr(wl->bssid))\r\nwl->rx_config &= ~CFG_BSSID_FILTER_EN;\r\nret = wl1251_cmd_join(wl, bss_type, channel, beacon_interval,\r\ndtim_period);\r\nif (ret < 0)\r\ngoto out;\r\nret = wl1251_event_wait(wl, JOIN_EVENT_COMPLETE_ID, 100);\r\nif (ret < 0)\r\nwl1251_warning("join timeout");\r\nout:\r\nreturn ret;\r\n}\r\nstatic void wl1251_op_tx(struct ieee80211_hw *hw,\r\nstruct ieee80211_tx_control *control,\r\nstruct sk_buff *skb)\r\n{\r\nstruct wl1251 *wl = hw->priv;\r\nunsigned long flags;\r\nskb_queue_tail(&wl->tx_queue, skb);\r\nieee80211_queue_work(wl->hw, &wl->tx_work);\r\nif (skb_queue_len(&wl->tx_queue) >= WL1251_TX_QUEUE_HIGH_WATERMARK) {\r\nwl1251_debug(DEBUG_TX, "op_tx: tx_queue full, stop queues");\r\nspin_lock_irqsave(&wl->wl_lock, flags);\r\nieee80211_stop_queues(wl->hw);\r\nwl->tx_queue_stopped = true;\r\nspin_unlock_irqrestore(&wl->wl_lock, flags);\r\n}\r\n}\r\nstatic int wl1251_op_start(struct ieee80211_hw *hw)\r\n{\r\nstruct wl1251 *wl = hw->priv;\r\nstruct wiphy *wiphy = hw->wiphy;\r\nint ret = 0;\r\nwl1251_debug(DEBUG_MAC80211, "mac80211 start");\r\nmutex_lock(&wl->mutex);\r\nif (wl->state != WL1251_STATE_OFF) {\r\nwl1251_error("cannot start because not in off state: %d",\r\nwl->state);\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nret = wl1251_chip_wakeup(wl);\r\nif (ret < 0)\r\ngoto out;\r\nret = wl1251_boot(wl);\r\nif (ret < 0)\r\ngoto out;\r\nret = wl1251_hw_init(wl);\r\nif (ret < 0)\r\ngoto out;\r\nret = wl1251_acx_station_id(wl);\r\nif (ret < 0)\r\ngoto out;\r\nwl->state = WL1251_STATE_ON;\r\nwl1251_info("firmware booted (%s)", wl->fw_ver);\r\nwiphy->hw_version = wl->chip_id;\r\nstrncpy(wiphy->fw_version, wl->fw_ver, sizeof(wiphy->fw_version));\r\nout:\r\nif (ret < 0)\r\nwl1251_power_off(wl);\r\nmutex_unlock(&wl->mutex);\r\nreturn ret;\r\n}\r\nstatic void wl1251_op_stop(struct ieee80211_hw *hw)\r\n{\r\nstruct wl1251 *wl = hw->priv;\r\nwl1251_info("down");\r\nwl1251_debug(DEBUG_MAC80211, "mac80211 stop");\r\nmutex_lock(&wl->mutex);\r\nWARN_ON(wl->state != WL1251_STATE_ON);\r\nif (wl->scanning) {\r\nstruct cfg80211_scan_info info = {\r\n.aborted = true,\r\n};\r\nieee80211_scan_completed(wl->hw, &info);\r\nwl->scanning = false;\r\n}\r\nwl->state = WL1251_STATE_OFF;\r\nwl1251_disable_interrupts(wl);\r\nmutex_unlock(&wl->mutex);\r\ncancel_work_sync(&wl->irq_work);\r\ncancel_work_sync(&wl->tx_work);\r\ncancel_delayed_work_sync(&wl->elp_work);\r\nmutex_lock(&wl->mutex);\r\nwl1251_tx_flush(wl);\r\nwl1251_power_off(wl);\r\neth_zero_addr(wl->bssid);\r\nwl->listen_int = 1;\r\nwl->bss_type = MAX_BSS_TYPE;\r\nwl->data_in_count = 0;\r\nwl->rx_counter = 0;\r\nwl->rx_handled = 0;\r\nwl->rx_current_buffer = 0;\r\nwl->rx_last_id = 0;\r\nwl->next_tx_complete = 0;\r\nwl->elp = false;\r\nwl->station_mode = STATION_ACTIVE_MODE;\r\nwl->psm_entry_retry = 0;\r\nwl->tx_queue_stopped = false;\r\nwl->power_level = WL1251_DEFAULT_POWER_LEVEL;\r\nwl->rssi_thold = 0;\r\nwl->channel = WL1251_DEFAULT_CHANNEL;\r\nwl->monitor_present = false;\r\nwl->joined = false;\r\nwl1251_debugfs_reset(wl);\r\nmutex_unlock(&wl->mutex);\r\n}\r\nstatic int wl1251_op_add_interface(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct wl1251 *wl = hw->priv;\r\nint ret = 0;\r\nvif->driver_flags |= IEEE80211_VIF_BEACON_FILTER |\r\nIEEE80211_VIF_SUPPORTS_UAPSD |\r\nIEEE80211_VIF_SUPPORTS_CQM_RSSI;\r\nwl1251_debug(DEBUG_MAC80211, "mac80211 add interface type %d mac %pM",\r\nvif->type, vif->addr);\r\nmutex_lock(&wl->mutex);\r\nif (wl->vif) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nwl->vif = vif;\r\nswitch (vif->type) {\r\ncase NL80211_IFTYPE_STATION:\r\nwl->bss_type = BSS_TYPE_STA_BSS;\r\nbreak;\r\ncase NL80211_IFTYPE_ADHOC:\r\nwl->bss_type = BSS_TYPE_IBSS;\r\nbreak;\r\ndefault:\r\nret = -EOPNOTSUPP;\r\ngoto out;\r\n}\r\nif (!ether_addr_equal_unaligned(wl->mac_addr, vif->addr)) {\r\nmemcpy(wl->mac_addr, vif->addr, ETH_ALEN);\r\nSET_IEEE80211_PERM_ADDR(wl->hw, wl->mac_addr);\r\nret = wl1251_acx_station_id(wl);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&wl->mutex);\r\nreturn ret;\r\n}\r\nstatic void wl1251_op_remove_interface(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct wl1251 *wl = hw->priv;\r\nmutex_lock(&wl->mutex);\r\nwl1251_debug(DEBUG_MAC80211, "mac80211 remove interface");\r\nwl->vif = NULL;\r\neth_zero_addr(wl->bssid);\r\nmutex_unlock(&wl->mutex);\r\n}\r\nstatic int wl1251_build_null_data(struct wl1251 *wl)\r\n{\r\nstruct sk_buff *skb = NULL;\r\nint size;\r\nvoid *ptr;\r\nint ret = -ENOMEM;\r\nif (wl->bss_type == BSS_TYPE_IBSS) {\r\nsize = sizeof(struct wl12xx_null_data_template);\r\nptr = NULL;\r\n} else {\r\nskb = ieee80211_nullfunc_get(wl->hw, wl->vif);\r\nif (!skb)\r\ngoto out;\r\nsize = skb->len;\r\nptr = skb->data;\r\n}\r\nret = wl1251_cmd_template_set(wl, CMD_NULL_DATA, ptr, size);\r\nout:\r\ndev_kfree_skb(skb);\r\nif (ret)\r\nwl1251_warning("cmd buld null data failed: %d", ret);\r\nreturn ret;\r\n}\r\nstatic int wl1251_build_qos_null_data(struct wl1251 *wl)\r\n{\r\nstruct ieee80211_qos_hdr template;\r\nmemset(&template, 0, sizeof(template));\r\nmemcpy(template.addr1, wl->bssid, ETH_ALEN);\r\nmemcpy(template.addr2, wl->mac_addr, ETH_ALEN);\r\nmemcpy(template.addr3, wl->bssid, ETH_ALEN);\r\ntemplate.frame_control = cpu_to_le16(IEEE80211_FTYPE_DATA |\r\nIEEE80211_STYPE_QOS_NULLFUNC |\r\nIEEE80211_FCTL_TODS);\r\ntemplate.qos_ctrl = cpu_to_le16(0);\r\nreturn wl1251_cmd_template_set(wl, CMD_QOS_NULL_DATA, &template,\r\nsizeof(template));\r\n}\r\nstatic bool wl1251_can_do_pm(struct ieee80211_conf *conf, struct wl1251 *wl)\r\n{\r\nreturn (conf->flags & IEEE80211_CONF_PS) && !wl->monitor_present;\r\n}\r\nstatic int wl1251_op_config(struct ieee80211_hw *hw, u32 changed)\r\n{\r\nstruct wl1251 *wl = hw->priv;\r\nstruct ieee80211_conf *conf = &hw->conf;\r\nint channel, ret = 0;\r\nchannel = ieee80211_frequency_to_channel(\r\nconf->chandef.chan->center_freq);\r\nwl1251_debug(DEBUG_MAC80211,\r\n"mac80211 config ch %d monitor %s psm %s power %d",\r\nchannel,\r\nconf->flags & IEEE80211_CONF_MONITOR ? "on" : "off",\r\nconf->flags & IEEE80211_CONF_PS ? "on" : "off",\r\nconf->power_level);\r\nmutex_lock(&wl->mutex);\r\nret = wl1251_ps_elp_wakeup(wl);\r\nif (ret < 0)\r\ngoto out;\r\nif (changed & IEEE80211_CONF_CHANGE_MONITOR) {\r\nu32 mode;\r\nif (conf->flags & IEEE80211_CONF_MONITOR) {\r\nwl->monitor_present = true;\r\nmode = DF_SNIFF_MODE_ENABLE | DF_ENCRYPTION_DISABLE;\r\n} else {\r\nwl->monitor_present = false;\r\nmode = 0;\r\n}\r\nret = wl1251_acx_feature_cfg(wl, mode);\r\nif (ret < 0)\r\ngoto out_sleep;\r\n}\r\nif (channel != wl->channel) {\r\nwl->channel = channel;\r\nif (wl->vif == NULL) {\r\nwl->joined = false;\r\nret = wl1251_cmd_data_path_rx(wl, wl->channel, 1);\r\n} else {\r\nret = wl1251_join(wl, wl->bss_type, wl->channel,\r\nwl->beacon_int, wl->dtim_period);\r\n}\r\nif (ret < 0)\r\ngoto out_sleep;\r\n}\r\nif (wl1251_can_do_pm(conf, wl) && !wl->psm_requested) {\r\nwl1251_debug(DEBUG_PSM, "psm enabled");\r\nwl->psm_requested = true;\r\nwl->dtim_period = conf->ps_dtim_period;\r\nret = wl1251_acx_wr_tbtt_and_dtim(wl, wl->beacon_int,\r\nwl->dtim_period);\r\nret = wl1251_ps_set_mode(wl, STATION_POWER_SAVE_MODE);\r\nif (ret < 0)\r\ngoto out_sleep;\r\n} else if (!wl1251_can_do_pm(conf, wl) && wl->psm_requested) {\r\nwl1251_debug(DEBUG_PSM, "psm disabled");\r\nwl->psm_requested = false;\r\nif (wl->station_mode != STATION_ACTIVE_MODE) {\r\nret = wl1251_ps_set_mode(wl, STATION_ACTIVE_MODE);\r\nif (ret < 0)\r\ngoto out_sleep;\r\n}\r\n}\r\nif (changed & IEEE80211_CONF_CHANGE_IDLE && !wl->scanning) {\r\nif (conf->flags & IEEE80211_CONF_IDLE) {\r\nret = wl1251_ps_set_mode(wl, STATION_IDLE);\r\nif (ret < 0)\r\ngoto out_sleep;\r\n} else {\r\nret = wl1251_ps_set_mode(wl, STATION_ACTIVE_MODE);\r\nif (ret < 0)\r\ngoto out_sleep;\r\nret = wl1251_join(wl, wl->bss_type, wl->channel,\r\nwl->beacon_int, wl->dtim_period);\r\nif (ret < 0)\r\ngoto out_sleep;\r\n}\r\n}\r\nif (conf->power_level != wl->power_level) {\r\nret = wl1251_acx_tx_power(wl, conf->power_level);\r\nif (ret < 0)\r\ngoto out_sleep;\r\nwl->power_level = conf->power_level;\r\n}\r\nout_sleep:\r\nwl1251_ps_elp_sleep(wl);\r\nout:\r\nmutex_unlock(&wl->mutex);\r\nreturn ret;\r\n}\r\nstatic u64 wl1251_op_prepare_multicast(struct ieee80211_hw *hw,\r\nstruct netdev_hw_addr_list *mc_list)\r\n{\r\nstruct wl1251_filter_params *fp;\r\nstruct netdev_hw_addr *ha;\r\nstruct wl1251 *wl = hw->priv;\r\nif (unlikely(wl->state == WL1251_STATE_OFF))\r\nreturn 0;\r\nfp = kzalloc(sizeof(*fp), GFP_ATOMIC);\r\nif (!fp) {\r\nwl1251_error("Out of memory setting filters.");\r\nreturn 0;\r\n}\r\nfp->mc_list_length = 0;\r\nif (netdev_hw_addr_list_count(mc_list) > ACX_MC_ADDRESS_GROUP_MAX) {\r\nfp->enabled = false;\r\n} else {\r\nfp->enabled = true;\r\nnetdev_hw_addr_list_for_each(ha, mc_list) {\r\nmemcpy(fp->mc_list[fp->mc_list_length],\r\nha->addr, ETH_ALEN);\r\nfp->mc_list_length++;\r\n}\r\n}\r\nreturn (u64)(unsigned long)fp;\r\n}\r\nstatic void wl1251_op_configure_filter(struct ieee80211_hw *hw,\r\nunsigned int changed,\r\nunsigned int *total, u64 multicast)\r\n{\r\nstruct wl1251_filter_params *fp = (void *)(unsigned long)multicast;\r\nstruct wl1251 *wl = hw->priv;\r\nint ret;\r\nwl1251_debug(DEBUG_MAC80211, "mac80211 configure filter");\r\n*total &= WL1251_SUPPORTED_FILTERS;\r\nchanged &= WL1251_SUPPORTED_FILTERS;\r\nif (changed == 0) {\r\nkfree(fp);\r\nreturn;\r\n}\r\nmutex_lock(&wl->mutex);\r\nwl->rx_config = WL1251_DEFAULT_RX_CONFIG;\r\nwl->rx_filter = WL1251_DEFAULT_RX_FILTER;\r\nif (*total & FIF_ALLMULTI)\r\nwl->rx_config &= ~CFG_MC_FILTER_EN;\r\nif (*total & FIF_FCSFAIL)\r\nwl->rx_filter |= CFG_RX_FCS_ERROR;\r\nif (*total & FIF_BCN_PRBRESP_PROMISC) {\r\nwl->rx_config &= ~CFG_BSSID_FILTER_EN;\r\nwl->rx_config &= ~CFG_SSID_FILTER_EN;\r\n}\r\nif (*total & FIF_CONTROL)\r\nwl->rx_filter |= CFG_RX_CTL_EN;\r\nif (*total & FIF_OTHER_BSS || is_zero_ether_addr(wl->bssid))\r\nwl->rx_config &= ~CFG_BSSID_FILTER_EN;\r\nif (*total & FIF_PROBE_REQ)\r\nwl->rx_filter |= CFG_RX_PREQ_EN;\r\nif (wl->state == WL1251_STATE_OFF)\r\ngoto out;\r\nret = wl1251_ps_elp_wakeup(wl);\r\nif (ret < 0)\r\ngoto out;\r\nif (*total & FIF_ALLMULTI)\r\nret = wl1251_acx_group_address_tbl(wl, false, NULL, 0);\r\nelse if (fp)\r\nret = wl1251_acx_group_address_tbl(wl, fp->enabled,\r\nfp->mc_list,\r\nfp->mc_list_length);\r\nif (ret < 0)\r\ngoto out;\r\nwl1251_acx_rx_config(wl, wl->rx_config, wl->rx_filter);\r\nwl1251_ps_elp_sleep(wl);\r\nout:\r\nmutex_unlock(&wl->mutex);\r\nkfree(fp);\r\n}\r\nstatic int wl1251_set_key_type(struct wl1251 *wl,\r\nstruct wl1251_cmd_set_keys *key,\r\nenum set_key_cmd cmd,\r\nstruct ieee80211_key_conf *mac80211_key,\r\nconst u8 *addr)\r\n{\r\nswitch (mac80211_key->cipher) {\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\nif (is_broadcast_ether_addr(addr))\r\nkey->key_type = KEY_WEP_DEFAULT;\r\nelse\r\nkey->key_type = KEY_WEP_ADDR;\r\nmac80211_key->hw_key_idx = mac80211_key->keyidx;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\nif (is_broadcast_ether_addr(addr))\r\nkey->key_type = KEY_TKIP_MIC_GROUP;\r\nelse\r\nkey->key_type = KEY_TKIP_MIC_PAIRWISE;\r\nmac80211_key->hw_key_idx = mac80211_key->keyidx;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\nif (is_broadcast_ether_addr(addr))\r\nkey->key_type = KEY_AES_GROUP;\r\nelse\r\nkey->key_type = KEY_AES_PAIRWISE;\r\nmac80211_key->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;\r\nbreak;\r\ndefault:\r\nwl1251_error("Unknown key cipher 0x%x", mac80211_key->cipher);\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wl1251_op_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,\r\nstruct ieee80211_vif *vif,\r\nstruct ieee80211_sta *sta,\r\nstruct ieee80211_key_conf *key)\r\n{\r\nstruct wl1251 *wl = hw->priv;\r\nstruct wl1251_cmd_set_keys *wl_cmd;\r\nconst u8 *addr;\r\nint ret;\r\nstatic const u8 bcast_addr[ETH_ALEN] =\r\n{ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\r\nwl1251_debug(DEBUG_MAC80211, "mac80211 set key");\r\nwl_cmd = kzalloc(sizeof(*wl_cmd), GFP_KERNEL);\r\nif (!wl_cmd) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\naddr = sta ? sta->addr : bcast_addr;\r\nwl1251_debug(DEBUG_CRYPT, "CMD: 0x%x", cmd);\r\nwl1251_dump(DEBUG_CRYPT, "ADDR: ", addr, ETH_ALEN);\r\nwl1251_debug(DEBUG_CRYPT, "Key: algo:0x%x, id:%d, len:%d flags 0x%x",\r\nkey->cipher, key->keyidx, key->keylen, key->flags);\r\nwl1251_dump(DEBUG_CRYPT, "KEY: ", key->key, key->keylen);\r\nif (is_zero_ether_addr(addr)) {\r\nret = -EOPNOTSUPP;\r\ngoto out;\r\n}\r\nmutex_lock(&wl->mutex);\r\nswitch (cmd) {\r\ncase SET_KEY:\r\nif (wl->monitor_present) {\r\nret = -EOPNOTSUPP;\r\ngoto out_unlock;\r\n}\r\nwl_cmd->key_action = KEY_ADD_OR_REPLACE;\r\nbreak;\r\ncase DISABLE_KEY:\r\nwl_cmd->key_action = KEY_REMOVE;\r\nbreak;\r\ndefault:\r\nwl1251_error("Unsupported key cmd 0x%x", cmd);\r\nbreak;\r\n}\r\nret = wl1251_ps_elp_wakeup(wl);\r\nif (ret < 0)\r\ngoto out_unlock;\r\nret = wl1251_set_key_type(wl, wl_cmd, cmd, key, addr);\r\nif (ret < 0) {\r\nwl1251_error("Set KEY type failed");\r\ngoto out_sleep;\r\n}\r\nif (wl_cmd->key_type != KEY_WEP_DEFAULT)\r\nmemcpy(wl_cmd->addr, addr, ETH_ALEN);\r\nif ((wl_cmd->key_type == KEY_TKIP_MIC_GROUP) ||\r\n(wl_cmd->key_type == KEY_TKIP_MIC_PAIRWISE)) {\r\nmemcpy(wl_cmd->key, key->key, 16);\r\nmemcpy(wl_cmd->key + 16, key->key + 24, 8);\r\nmemcpy(wl_cmd->key + 24, key->key + 16, 8);\r\n} else {\r\nmemcpy(wl_cmd->key, key->key, key->keylen);\r\n}\r\nwl_cmd->key_size = key->keylen;\r\nwl_cmd->id = key->keyidx;\r\nwl_cmd->ssid_profile = 0;\r\nwl1251_dump(DEBUG_CRYPT, "TARGET KEY: ", wl_cmd, sizeof(*wl_cmd));\r\nret = wl1251_cmd_send(wl, CMD_SET_KEYS, wl_cmd, sizeof(*wl_cmd));\r\nif (ret < 0) {\r\nwl1251_warning("could not set keys");\r\ngoto out_sleep;\r\n}\r\nout_sleep:\r\nwl1251_ps_elp_sleep(wl);\r\nout_unlock:\r\nmutex_unlock(&wl->mutex);\r\nout:\r\nkfree(wl_cmd);\r\nreturn ret;\r\n}\r\nstatic int wl1251_op_hw_scan(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nstruct ieee80211_scan_request *hw_req)\r\n{\r\nstruct cfg80211_scan_request *req = &hw_req->req;\r\nstruct wl1251 *wl = hw->priv;\r\nstruct sk_buff *skb;\r\nsize_t ssid_len = 0;\r\nu8 *ssid = NULL;\r\nint ret;\r\nwl1251_debug(DEBUG_MAC80211, "mac80211 hw scan");\r\nif (req->n_ssids) {\r\nssid = req->ssids[0].ssid;\r\nssid_len = req->ssids[0].ssid_len;\r\n}\r\nmutex_lock(&wl->mutex);\r\nif (wl->scanning) {\r\nwl1251_debug(DEBUG_SCAN, "scan already in progress");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = wl1251_ps_elp_wakeup(wl);\r\nif (ret < 0)\r\ngoto out;\r\nif (hw->conf.flags & IEEE80211_CONF_IDLE) {\r\nret = wl1251_ps_set_mode(wl, STATION_ACTIVE_MODE);\r\nif (ret < 0)\r\ngoto out_sleep;\r\nret = wl1251_join(wl, wl->bss_type, wl->channel,\r\nwl->beacon_int, wl->dtim_period);\r\nif (ret < 0)\r\ngoto out_sleep;\r\n}\r\nskb = ieee80211_probereq_get(wl->hw, wl->vif->addr, ssid, ssid_len,\r\nreq->ie_len);\r\nif (!skb) {\r\nret = -ENOMEM;\r\ngoto out_idle;\r\n}\r\nif (req->ie_len)\r\nskb_put_data(skb, req->ie, req->ie_len);\r\nret = wl1251_cmd_template_set(wl, CMD_PROBE_REQ, skb->data,\r\nskb->len);\r\ndev_kfree_skb(skb);\r\nif (ret < 0)\r\ngoto out_idle;\r\nret = wl1251_cmd_trigger_scan_to(wl, 0);\r\nif (ret < 0)\r\ngoto out_idle;\r\nwl->scanning = true;\r\nret = wl1251_cmd_scan(wl, ssid, ssid_len, req->channels,\r\nreq->n_channels, WL1251_SCAN_NUM_PROBES);\r\nif (ret < 0) {\r\nwl1251_debug(DEBUG_SCAN, "scan failed %d", ret);\r\nwl->scanning = false;\r\ngoto out_idle;\r\n}\r\ngoto out_sleep;\r\nout_idle:\r\nif (hw->conf.flags & IEEE80211_CONF_IDLE)\r\nret = wl1251_ps_set_mode(wl, STATION_IDLE);\r\nout_sleep:\r\nwl1251_ps_elp_sleep(wl);\r\nout:\r\nmutex_unlock(&wl->mutex);\r\nreturn ret;\r\n}\r\nstatic int wl1251_op_set_rts_threshold(struct ieee80211_hw *hw, u32 value)\r\n{\r\nstruct wl1251 *wl = hw->priv;\r\nint ret;\r\nmutex_lock(&wl->mutex);\r\nret = wl1251_ps_elp_wakeup(wl);\r\nif (ret < 0)\r\ngoto out;\r\nret = wl1251_acx_rts_threshold(wl, (u16) value);\r\nif (ret < 0)\r\nwl1251_warning("wl1251_op_set_rts_threshold failed: %d", ret);\r\nwl1251_ps_elp_sleep(wl);\r\nout:\r\nmutex_unlock(&wl->mutex);\r\nreturn ret;\r\n}\r\nstatic void wl1251_op_bss_info_changed(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nstruct ieee80211_bss_conf *bss_conf,\r\nu32 changed)\r\n{\r\nstruct wl1251 *wl = hw->priv;\r\nstruct sk_buff *beacon, *skb;\r\nbool enable;\r\nint ret;\r\nwl1251_debug(DEBUG_MAC80211, "mac80211 bss info changed");\r\nmutex_lock(&wl->mutex);\r\nret = wl1251_ps_elp_wakeup(wl);\r\nif (ret < 0)\r\ngoto out;\r\nif (changed & BSS_CHANGED_CQM) {\r\nret = wl1251_acx_low_rssi(wl, bss_conf->cqm_rssi_thold,\r\nWL1251_DEFAULT_LOW_RSSI_WEIGHT,\r\nWL1251_DEFAULT_LOW_RSSI_DEPTH,\r\nWL1251_ACX_LOW_RSSI_TYPE_EDGE);\r\nif (ret < 0)\r\ngoto out;\r\nwl->rssi_thold = bss_conf->cqm_rssi_thold;\r\n}\r\nif ((changed & BSS_CHANGED_BSSID) &&\r\nmemcmp(wl->bssid, bss_conf->bssid, ETH_ALEN)) {\r\nmemcpy(wl->bssid, bss_conf->bssid, ETH_ALEN);\r\nif (!is_zero_ether_addr(wl->bssid)) {\r\nret = wl1251_build_null_data(wl);\r\nif (ret < 0)\r\ngoto out_sleep;\r\nret = wl1251_build_qos_null_data(wl);\r\nif (ret < 0)\r\ngoto out_sleep;\r\nret = wl1251_join(wl, wl->bss_type, wl->channel,\r\nwl->beacon_int, wl->dtim_period);\r\nif (ret < 0)\r\ngoto out_sleep;\r\n}\r\n}\r\nif (changed & BSS_CHANGED_ASSOC) {\r\nif (bss_conf->assoc) {\r\nwl->beacon_int = bss_conf->beacon_int;\r\nskb = ieee80211_pspoll_get(wl->hw, wl->vif);\r\nif (!skb)\r\ngoto out_sleep;\r\nret = wl1251_cmd_template_set(wl, CMD_PS_POLL,\r\nskb->data,\r\nskb->len);\r\ndev_kfree_skb(skb);\r\nif (ret < 0)\r\ngoto out_sleep;\r\nret = wl1251_acx_aid(wl, bss_conf->aid);\r\nif (ret < 0)\r\ngoto out_sleep;\r\n} else {\r\nwl->beacon_int = WL1251_DEFAULT_BEACON_INT;\r\nwl->dtim_period = WL1251_DEFAULT_DTIM_PERIOD;\r\n}\r\n}\r\nif (changed & BSS_CHANGED_ERP_SLOT) {\r\nif (bss_conf->use_short_slot)\r\nret = wl1251_acx_slot(wl, SLOT_TIME_SHORT);\r\nelse\r\nret = wl1251_acx_slot(wl, SLOT_TIME_LONG);\r\nif (ret < 0) {\r\nwl1251_warning("Set slot time failed %d", ret);\r\ngoto out_sleep;\r\n}\r\n}\r\nif (changed & BSS_CHANGED_ERP_PREAMBLE) {\r\nif (bss_conf->use_short_preamble)\r\nwl1251_acx_set_preamble(wl, ACX_PREAMBLE_SHORT);\r\nelse\r\nwl1251_acx_set_preamble(wl, ACX_PREAMBLE_LONG);\r\n}\r\nif (changed & BSS_CHANGED_ERP_CTS_PROT) {\r\nif (bss_conf->use_cts_prot)\r\nret = wl1251_acx_cts_protect(wl, CTSPROTECT_ENABLE);\r\nelse\r\nret = wl1251_acx_cts_protect(wl, CTSPROTECT_DISABLE);\r\nif (ret < 0) {\r\nwl1251_warning("Set ctsprotect failed %d", ret);\r\ngoto out_sleep;\r\n}\r\n}\r\nif (changed & BSS_CHANGED_ARP_FILTER) {\r\n__be32 addr = bss_conf->arp_addr_list[0];\r\nWARN_ON(wl->bss_type != BSS_TYPE_STA_BSS);\r\nenable = bss_conf->arp_addr_cnt == 1 && bss_conf->assoc;\r\nwl1251_acx_arp_ip_filter(wl, enable, addr);\r\nif (ret < 0)\r\ngoto out_sleep;\r\n}\r\nif (changed & BSS_CHANGED_BEACON) {\r\nbeacon = ieee80211_beacon_get(hw, vif);\r\nif (!beacon)\r\ngoto out_sleep;\r\nret = wl1251_cmd_template_set(wl, CMD_BEACON, beacon->data,\r\nbeacon->len);\r\nif (ret < 0) {\r\ndev_kfree_skb(beacon);\r\ngoto out_sleep;\r\n}\r\nret = wl1251_cmd_template_set(wl, CMD_PROBE_RESP, beacon->data,\r\nbeacon->len);\r\ndev_kfree_skb(beacon);\r\nif (ret < 0)\r\ngoto out_sleep;\r\nret = wl1251_join(wl, wl->bss_type, wl->channel,\r\nwl->beacon_int, wl->dtim_period);\r\nif (ret < 0)\r\ngoto out_sleep;\r\n}\r\nout_sleep:\r\nwl1251_ps_elp_sleep(wl);\r\nout:\r\nmutex_unlock(&wl->mutex);\r\n}\r\nstatic int wl1251_op_conf_tx(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif, u16 queue,\r\nconst struct ieee80211_tx_queue_params *params)\r\n{\r\nenum wl1251_acx_ps_scheme ps_scheme;\r\nstruct wl1251 *wl = hw->priv;\r\nint ret;\r\nmutex_lock(&wl->mutex);\r\nwl1251_debug(DEBUG_MAC80211, "mac80211 conf tx %d", queue);\r\nret = wl1251_ps_elp_wakeup(wl);\r\nif (ret < 0)\r\ngoto out;\r\nret = wl1251_acx_ac_cfg(wl, wl1251_tx_get_queue(queue),\r\nparams->cw_min, params->cw_max,\r\nparams->aifs, params->txop * 32);\r\nif (ret < 0)\r\ngoto out_sleep;\r\nif (params->uapsd)\r\nps_scheme = WL1251_ACX_PS_SCHEME_UPSD_TRIGGER;\r\nelse\r\nps_scheme = WL1251_ACX_PS_SCHEME_LEGACY;\r\nret = wl1251_acx_tid_cfg(wl, wl1251_tx_get_queue(queue),\r\nCHANNEL_TYPE_EDCF,\r\nwl1251_tx_get_queue(queue), ps_scheme,\r\nWL1251_ACX_ACK_POLICY_LEGACY);\r\nif (ret < 0)\r\ngoto out_sleep;\r\nout_sleep:\r\nwl1251_ps_elp_sleep(wl);\r\nout:\r\nmutex_unlock(&wl->mutex);\r\nreturn ret;\r\n}\r\nstatic int wl1251_op_get_survey(struct ieee80211_hw *hw, int idx,\r\nstruct survey_info *survey)\r\n{\r\nstruct wl1251 *wl = hw->priv;\r\nstruct ieee80211_conf *conf = &hw->conf;\r\nif (idx != 0)\r\nreturn -ENOENT;\r\nsurvey->channel = conf->chandef.chan;\r\nsurvey->filled = SURVEY_INFO_NOISE_DBM;\r\nsurvey->noise = wl->noise;\r\nreturn 0;\r\n}\r\nstatic int wl1251_read_eeprom_byte(struct wl1251 *wl, off_t offset, u8 *data)\r\n{\r\nunsigned long timeout;\r\nwl1251_reg_write32(wl, EE_ADDR, offset);\r\nwl1251_reg_write32(wl, EE_CTL, EE_CTL_READ);\r\ntimeout = jiffies + msecs_to_jiffies(100);\r\nwhile (1) {\r\nif (!(wl1251_reg_read32(wl, EE_CTL) & EE_CTL_READ))\r\nbreak;\r\nif (time_after(jiffies, timeout))\r\nreturn -ETIMEDOUT;\r\nmsleep(1);\r\n}\r\n*data = wl1251_reg_read32(wl, EE_DATA);\r\nreturn 0;\r\n}\r\nstatic int wl1251_read_eeprom(struct wl1251 *wl, off_t offset,\r\nu8 *data, size_t len)\r\n{\r\nsize_t i;\r\nint ret;\r\nwl1251_reg_write32(wl, EE_START, 0);\r\nfor (i = 0; i < len; i++) {\r\nret = wl1251_read_eeprom_byte(wl, offset + i, &data[i]);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wl1251_read_eeprom_mac(struct wl1251 *wl)\r\n{\r\nu8 mac[ETH_ALEN];\r\nint i, ret;\r\nwl1251_set_partition(wl, 0, 0, REGISTERS_BASE, REGISTERS_DOWN_SIZE);\r\nret = wl1251_read_eeprom(wl, 0x1c, mac, sizeof(mac));\r\nif (ret < 0) {\r\nwl1251_warning("failed to read MAC address from EEPROM");\r\nreturn ret;\r\n}\r\nfor (i = 0; i < ETH_ALEN; i++)\r\nwl->mac_addr[i] = mac[ETH_ALEN - i - 1];\r\nreturn 0;\r\n}\r\nstatic int wl1251_register_hw(struct wl1251 *wl)\r\n{\r\nint ret;\r\nif (wl->mac80211_registered)\r\nreturn 0;\r\nSET_IEEE80211_PERM_ADDR(wl->hw, wl->mac_addr);\r\nret = ieee80211_register_hw(wl->hw);\r\nif (ret < 0) {\r\nwl1251_error("unable to register mac80211 hw: %d", ret);\r\nreturn ret;\r\n}\r\nwl->mac80211_registered = true;\r\nwl1251_notice("loaded");\r\nreturn 0;\r\n}\r\nint wl1251_init_ieee80211(struct wl1251 *wl)\r\n{\r\nint ret;\r\nwl->hw->extra_tx_headroom = sizeof(struct tx_double_buffer_desc)\r\n+ WL1251_TKIP_IV_SPACE;\r\nieee80211_hw_set(wl->hw, SIGNAL_DBM);\r\nieee80211_hw_set(wl->hw, SUPPORTS_PS);\r\nwl->hw->wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |\r\nBIT(NL80211_IFTYPE_ADHOC);\r\nwl->hw->wiphy->max_scan_ssids = 1;\r\nwl->hw->wiphy->bands[NL80211_BAND_2GHZ] = &wl1251_band_2ghz;\r\nwl->hw->queues = 4;\r\nif (wl->use_eeprom)\r\nwl1251_read_eeprom_mac(wl);\r\nret = wl1251_register_hw(wl);\r\nif (ret)\r\ngoto out;\r\nwl1251_debugfs_init(wl);\r\nwl1251_notice("initialized");\r\nret = 0;\r\nout:\r\nreturn ret;\r\n}\r\nstruct ieee80211_hw *wl1251_alloc_hw(void)\r\n{\r\nstruct ieee80211_hw *hw;\r\nstruct wl1251 *wl;\r\nint i;\r\nstatic const u8 nokia_oui[3] = {0x00, 0x1f, 0xdf};\r\nhw = ieee80211_alloc_hw(sizeof(*wl), &wl1251_ops);\r\nif (!hw) {\r\nwl1251_error("could not alloc ieee80211_hw");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nwl = hw->priv;\r\nmemset(wl, 0, sizeof(*wl));\r\nwl->hw = hw;\r\nwl->data_in_count = 0;\r\nskb_queue_head_init(&wl->tx_queue);\r\nINIT_DELAYED_WORK(&wl->elp_work, wl1251_elp_work);\r\nwl->channel = WL1251_DEFAULT_CHANNEL;\r\nwl->monitor_present = false;\r\nwl->joined = false;\r\nwl->scanning = false;\r\nwl->bss_type = MAX_BSS_TYPE;\r\nwl->default_key = 0;\r\nwl->listen_int = 1;\r\nwl->rx_counter = 0;\r\nwl->rx_handled = 0;\r\nwl->rx_current_buffer = 0;\r\nwl->rx_last_id = 0;\r\nwl->rx_config = WL1251_DEFAULT_RX_CONFIG;\r\nwl->rx_filter = WL1251_DEFAULT_RX_FILTER;\r\nwl->elp = false;\r\nwl->station_mode = STATION_ACTIVE_MODE;\r\nwl->psm_requested = false;\r\nwl->psm_entry_retry = 0;\r\nwl->tx_queue_stopped = false;\r\nwl->power_level = WL1251_DEFAULT_POWER_LEVEL;\r\nwl->rssi_thold = 0;\r\nwl->beacon_int = WL1251_DEFAULT_BEACON_INT;\r\nwl->dtim_period = WL1251_DEFAULT_DTIM_PERIOD;\r\nwl->vif = NULL;\r\nfor (i = 0; i < FW_TX_CMPLT_BLOCK_SIZE; i++)\r\nwl->tx_frames[i] = NULL;\r\nwl->next_tx_complete = 0;\r\nINIT_WORK(&wl->irq_work, wl1251_irq_work);\r\nINIT_WORK(&wl->tx_work, wl1251_tx_work);\r\nmemcpy(wl->mac_addr, nokia_oui, 3);\r\nget_random_bytes(wl->mac_addr + 3, 3);\r\nwl->state = WL1251_STATE_OFF;\r\nmutex_init(&wl->mutex);\r\nspin_lock_init(&wl->wl_lock);\r\nwl->tx_mgmt_frm_rate = DEFAULT_HW_GEN_TX_RATE;\r\nwl->tx_mgmt_frm_mod = DEFAULT_HW_GEN_MODULATION_TYPE;\r\nwl->rx_descriptor = kmalloc(sizeof(*wl->rx_descriptor), GFP_KERNEL);\r\nif (!wl->rx_descriptor) {\r\nwl1251_error("could not allocate memory for rx descriptor");\r\nieee80211_free_hw(hw);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nreturn hw;\r\n}\r\nint wl1251_free_hw(struct wl1251 *wl)\r\n{\r\nieee80211_unregister_hw(wl->hw);\r\nwl1251_debugfs_exit(wl);\r\nkfree(wl->target_mem_map);\r\nkfree(wl->data_path);\r\nvfree(wl->fw);\r\nwl->fw = NULL;\r\nkfree(wl->nvs);\r\nwl->nvs = NULL;\r\nkfree(wl->rx_descriptor);\r\nwl->rx_descriptor = NULL;\r\nieee80211_free_hw(wl->hw);\r\nreturn 0;\r\n}
