static acpi_status hp_ccsr_locate(acpi_handle obj, u64 *base, u64 *length)\r\n{\r\nacpi_status status;\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nstruct acpi_resource *resource;\r\nstruct acpi_resource_vendor_typed *vendor;\r\nstatus = acpi_get_vendor_resource(obj, METHOD_NAME__CRS, &hp_ccsr_uuid,\r\n&buffer);\r\nresource = buffer.pointer;\r\nvendor = &resource->data.vendor_typed;\r\nif (ACPI_FAILURE(status) || vendor->byte_length < 16) {\r\nstatus = AE_NOT_FOUND;\r\ngoto exit;\r\n}\r\nmemcpy(base, vendor->byte_data, sizeof(*base));\r\nmemcpy(length, vendor->byte_data + 8, sizeof(*length));\r\nexit:\r\nkfree(buffer.pointer);\r\nreturn status;\r\n}\r\nstatic acpi_status find_csr_space(struct acpi_resource *resource, void *data)\r\n{\r\nstruct csr_space *space = data;\r\nstruct acpi_resource_address64 addr;\r\nacpi_status status;\r\nstatus = acpi_resource_to_address64(resource, &addr);\r\nif (ACPI_SUCCESS(status) &&\r\naddr.resource_type == ACPI_MEMORY_RANGE &&\r\naddr.address.address_length &&\r\naddr.producer_consumer == ACPI_CONSUMER) {\r\nspace->base = addr.address.minimum;\r\nspace->length = addr.address.address_length;\r\nreturn AE_CTRL_TERMINATE;\r\n}\r\nreturn AE_OK;\r\n}\r\nstatic acpi_status hp_crs_locate(acpi_handle obj, u64 *base, u64 *length)\r\n{\r\nstruct csr_space space = { 0, 0 };\r\nacpi_walk_resources(obj, METHOD_NAME__CRS, find_csr_space, &space);\r\nif (!space.length)\r\nreturn AE_NOT_FOUND;\r\n*base = space.base;\r\n*length = space.length;\r\nreturn AE_OK;\r\n}\r\nacpi_status hp_acpi_csr_space(acpi_handle obj, u64 *csr_base, u64 *csr_length)\r\n{\r\nacpi_status status;\r\nstatus = hp_ccsr_locate(obj, csr_base, csr_length);\r\nif (ACPI_SUCCESS(status))\r\nreturn status;\r\nreturn hp_crs_locate(obj, csr_base, csr_length);\r\n}
