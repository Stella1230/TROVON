void\r\nia_css_dvs_config(\r\nstruct sh_css_isp_dvs_isp_config *to,\r\nconst struct ia_css_dvs_configuration *from,\r\nunsigned size)\r\n{\r\n(void)size;\r\nto->num_horizontal_blocks =\r\nDVS_NUM_BLOCKS_X(from->info->res.width);\r\nto->num_vertical_blocks =\r\nDVS_NUM_BLOCKS_Y(from->info->res.height);\r\n}\r\nvoid\r\nia_css_dvs_configure(\r\nconst struct ia_css_binary *binary,\r\nconst struct ia_css_frame_info *info)\r\n{\r\nstruct ia_css_dvs_configuration config = default_config;\r\nconfig.info = info;\r\nia_css_configure_dvs(binary, &config);\r\n}\r\nstatic void\r\nconvert_coords_to_ispparams(\r\nstruct ia_css_host_data *gdc_warp_table,\r\nconst struct ia_css_dvs_6axis_config *config,\r\nunsigned int i_stride,\r\nunsigned int o_width,\r\nunsigned int o_height,\r\nunsigned int uv_flag)\r\n{\r\nunsigned int i, j;\r\n#ifndef ISP2401\r\n#endif\r\ngdc_warp_param_mem_t s = { 0 };\r\nunsigned int x00, x01, x10, x11,\r\ny00, y01, y10, y11;\r\nunsigned int xmin, ymin, xmax, ymax;\r\nunsigned int topleft_x, topleft_y, bottom_x, bottom_y,\r\ntopleft_x_frac, topleft_y_frac;\r\nunsigned int dvs_interp_envelope = (DVS_GDC_INTERP_METHOD == HRT_GDC_BLI_MODE ?\r\nDVS_GDC_BLI_INTERP_ENVELOPE : DVS_GDC_BCI_INTERP_ENVELOPE);\r\nunsigned int num_blocks_y = (uv_flag ? DVS_NUM_BLOCKS_Y_CHROMA(o_height) : DVS_NUM_BLOCKS_Y(o_height) );\r\nunsigned int num_blocks_x = (uv_flag ? DVS_NUM_BLOCKS_X_CHROMA(o_width) : DVS_NUM_BLOCKS_X(o_width) );\r\nunsigned int in_stride = i_stride * DVS_INPUT_BYTES_PER_PIXEL;\r\nunsigned width, height;\r\nunsigned int *xbuff = NULL;\r\nunsigned int *ybuff = NULL;\r\nstruct gdc_warp_param_mem_s *ptr;\r\nassert(config != NULL);\r\nassert(gdc_warp_table != NULL);\r\nassert(gdc_warp_table->address != NULL);\r\nptr = (struct gdc_warp_param_mem_s *)gdc_warp_table->address;\r\nptr += (2 * uv_flag);\r\nif(uv_flag == 0)\r\n{\r\nxbuff = config->xcoords_y;\r\nybuff = config->ycoords_y;\r\nwidth = config->width_y;\r\nheight = config->height_y;\r\n}\r\nelse\r\n{\r\nxbuff = config->xcoords_uv;\r\nybuff = config->ycoords_uv;\r\nwidth = config->width_uv;\r\nheight = config->height_uv;\r\n}\r\nIA_CSS_LOG("blockdim_x %d blockdim_y %d",\r\nDVS_BLOCKDIM_X, DVS_BLOCKDIM_Y_LUMA >> uv_flag);\r\nIA_CSS_LOG("num_blocks_x %d num_blocks_y %d", num_blocks_x,num_blocks_y);\r\nIA_CSS_LOG("width %d height %d", width, height);\r\nassert(width == num_blocks_x + 1);\r\nassert(height == num_blocks_y + 1);\r\nfor (j = 0; j < num_blocks_y; j++) {\r\nfor (i = 0; i < num_blocks_x; i++) {\r\nx00 = xbuff[j * width + i];\r\nx01 = xbuff[j * width + (i+1)];\r\nx10 = xbuff[(j+1) * width + i];\r\nx11 = xbuff[(j+1) * width + (i+1)];\r\ny00 = ybuff[j * width + i];\r\ny01 = ybuff[j * width + (i+1)];\r\ny10 = ybuff[(j+1) * width + i];\r\ny11 = ybuff[(j+1) * width + (i+1)];\r\nxmin = min(x00, x10);\r\nxmax = max(x01, x11);\r\nymin = min(y00, y01);\r\nymax = max(y10, y11);\r\nassert ( x01 >= xmin);\r\nassert ( x11 >= xmin);\r\nassert ( y10 >= ymin);\r\nassert ( y11 >= ymin);\r\ntopleft_y = ymin >> DVS_COORD_FRAC_BITS;\r\ntopleft_x = ((xmin >> DVS_COORD_FRAC_BITS)\r\n>> XMEM_ALIGN_LOG2)\r\n<< (XMEM_ALIGN_LOG2);\r\ns.in_addr_offset = topleft_y * in_stride + topleft_x;\r\nbottom_y = CEIL_DIV(ymax, 1 << DVS_COORD_FRAC_BITS);\r\ns.in_block_height = bottom_y - topleft_y + dvs_interp_envelope;\r\nbottom_x = CEIL_DIV(xmax, 1 << DVS_COORD_FRAC_BITS);\r\ns.in_block_width = bottom_x - topleft_x + dvs_interp_envelope;\r\ntopleft_x_frac = topleft_x << (DVS_COORD_FRAC_BITS);\r\ntopleft_y_frac = topleft_y << (DVS_COORD_FRAC_BITS);\r\ns.p0_x = x00 - topleft_x_frac;\r\ns.p1_x = x01 - topleft_x_frac;\r\ns.p2_x = x10 - topleft_x_frac;\r\ns.p3_x = x11 - topleft_x_frac;\r\ns.p0_y = y00 - topleft_y_frac;\r\ns.p1_y = y01 - topleft_y_frac;\r\ns.p2_y = y10 - topleft_y_frac;\r\ns.p3_y = y11 - topleft_y_frac;\r\nassert(s.p0_x < (s.in_block_width << DVS_COORD_FRAC_BITS));\r\nassert(s.p1_x < (s.in_block_width << DVS_COORD_FRAC_BITS));\r\nassert(s.p2_x < (s.in_block_width << DVS_COORD_FRAC_BITS));\r\nassert(s.p3_x < (s.in_block_width << DVS_COORD_FRAC_BITS));\r\nassert(s.p0_y < (s.in_block_height << DVS_COORD_FRAC_BITS));\r\nassert(s.p1_y < (s.in_block_height << DVS_COORD_FRAC_BITS));\r\nassert(s.p2_y < (s.in_block_height << DVS_COORD_FRAC_BITS));\r\nassert(s.p3_y < (s.in_block_height << DVS_COORD_FRAC_BITS));\r\nassert(s.p0_x < s.p1_x);\r\nassert(s.p2_x < s.p3_x);\r\nassert(s.p0_y < s.p2_y);\r\nassert(s.p1_y < s.p3_y);\r\n#if 0\r\nprintf("j: %d\ti:%d\n", j, i);\r\nprintf("offset: %d\n", s.in_addr_offset);\r\nprintf("p0_x: %d\n", s.p0_x);\r\nprintf("p0_y: %d\n", s.p0_y);\r\nprintf("p1_x: %d\n", s.p1_x);\r\nprintf("p1_y: %d\n", s.p1_y);\r\nprintf("p2_x: %d\n", s.p2_x);\r\nprintf("p2_y: %d\n", s.p2_y);\r\nprintf("p3_x: %d\n", s.p3_x);\r\nprintf("p3_y: %d\n", s.p3_y);\r\nprintf("p0_x_nofrac[0]: %d\n", s.p0_x>>DVS_COORD_FRAC_BITS);\r\nprintf("p0_y_nofrac[1]: %d\n", s.p0_y>>DVS_COORD_FRAC_BITS);\r\nprintf("p1_x_nofrac[2]: %d\n", s.p1_x>>DVS_COORD_FRAC_BITS);\r\nprintf("p1_y_nofrac[3]: %d\n", s.p1_y>>DVS_COORD_FRAC_BITS);\r\nprintf("p2_x_nofrac[0]: %d\n", s.p2_x>>DVS_COORD_FRAC_BITS);\r\nprintf("p2_y_nofrac[1]: %d\n", s.p2_y>>DVS_COORD_FRAC_BITS);\r\nprintf("p3_x_nofrac[2]: %d\n", s.p3_x>>DVS_COORD_FRAC_BITS);\r\nprintf("p3_y_nofrac[3]: %d\n", s.p3_y>>DVS_COORD_FRAC_BITS);\r\nprintf("\n");\r\n#endif\r\n*ptr = s;\r\nif (uv_flag)\r\nptr += 3;\r\nelse\r\nptr += (1 + (i&1));\r\n}\r\n}\r\n}\r\nstruct ia_css_host_data *\r\nconvert_allocate_dvs_6axis_config(\r\nconst struct ia_css_dvs_6axis_config *dvs_6axis_config,\r\nconst struct ia_css_binary *binary,\r\nconst struct ia_css_frame_info *dvs_in_frame_info)\r\n{\r\nunsigned int i_stride;\r\nunsigned int o_width;\r\nunsigned int o_height;\r\nstruct ia_css_host_data *me;\r\nstruct gdc_warp_param_mem_s *isp_data_ptr;\r\nassert(binary != NULL);\r\nassert(dvs_6axis_config != NULL);\r\nassert(dvs_in_frame_info != NULL);\r\nme = ia_css_host_data_allocate((size_t)((DVS_6AXIS_BYTES(binary) / 2) * 3));\r\nif (!me)\r\nreturn NULL;\r\nassert((dvs_in_frame_info->format == IA_CSS_FRAME_FORMAT_NV12)\r\n|| (dvs_in_frame_info->format == IA_CSS_FRAME_FORMAT_YUV420));\r\nisp_data_ptr = (struct gdc_warp_param_mem_s *)me->address;\r\ni_stride = dvs_in_frame_info->padded_width;\r\no_width = binary->out_frame_info[0].res.width;\r\no_height = binary->out_frame_info[0].res.height;\r\nconvert_coords_to_ispparams(me, dvs_6axis_config,\r\ni_stride, o_width, o_height, 0);\r\nif (dvs_in_frame_info->format == IA_CSS_FRAME_FORMAT_YUV420) {\r\ni_stride /=2;\r\n}\r\nconvert_coords_to_ispparams(me, dvs_6axis_config,\r\ni_stride, o_width/2, o_height/2, 1);\r\nreturn me;\r\n}\r\nenum ia_css_err\r\nstore_dvs_6axis_config(\r\nconst struct ia_css_dvs_6axis_config *dvs_6axis_config,\r\nconst struct ia_css_binary *binary,\r\nconst struct ia_css_frame_info *dvs_in_frame_info,\r\nhrt_vaddress ddr_addr_y)\r\n{\r\nstruct ia_css_host_data *me;\r\nassert(dvs_6axis_config != NULL);\r\nassert(ddr_addr_y != mmgr_NULL);\r\nassert(dvs_in_frame_info != NULL);\r\nme = convert_allocate_dvs_6axis_config(dvs_6axis_config,\r\nbinary,\r\ndvs_in_frame_info);\r\nif (!me) {\r\nIA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY);\r\nreturn IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;\r\n}\r\nia_css_params_store_ia_css_host_data(\r\nddr_addr_y,\r\nme);\r\nia_css_host_data_free(me);\r\nreturn IA_CSS_SUCCESS;\r\n}
