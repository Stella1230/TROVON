static nokprobe_inline bool trace_kprobe_is_return(struct trace_kprobe *tk)\r\n{\r\nreturn tk->rp.handler != NULL;\r\n}\r\nstatic nokprobe_inline const char *trace_kprobe_symbol(struct trace_kprobe *tk)\r\n{\r\nreturn tk->symbol ? tk->symbol : "unknown";\r\n}\r\nstatic nokprobe_inline unsigned long trace_kprobe_offset(struct trace_kprobe *tk)\r\n{\r\nreturn tk->rp.kp.offset;\r\n}\r\nstatic nokprobe_inline bool trace_kprobe_has_gone(struct trace_kprobe *tk)\r\n{\r\nreturn !!(kprobe_gone(&tk->rp.kp));\r\n}\r\nstatic nokprobe_inline bool trace_kprobe_within_module(struct trace_kprobe *tk,\r\nstruct module *mod)\r\n{\r\nint len = strlen(mod->name);\r\nconst char *name = trace_kprobe_symbol(tk);\r\nreturn strncmp(mod->name, name, len) == 0 && name[len] == ':';\r\n}\r\nstatic nokprobe_inline bool trace_kprobe_is_on_module(struct trace_kprobe *tk)\r\n{\r\nreturn !!strchr(trace_kprobe_symbol(tk), ':');\r\n}\r\nstatic nokprobe_inline unsigned long trace_kprobe_nhit(struct trace_kprobe *tk)\r\n{\r\nunsigned long nhit = 0;\r\nint cpu;\r\nfor_each_possible_cpu(cpu)\r\nnhit += *per_cpu_ptr(tk->nhit, cpu);\r\nreturn nhit;\r\n}\r\nunsigned long update_symbol_cache(struct symbol_cache *sc)\r\n{\r\nsc->addr = (unsigned long)kallsyms_lookup_name(sc->symbol);\r\nif (sc->addr)\r\nsc->addr += sc->offset;\r\nreturn sc->addr;\r\n}\r\nvoid free_symbol_cache(struct symbol_cache *sc)\r\n{\r\nkfree(sc->symbol);\r\nkfree(sc);\r\n}\r\nstruct symbol_cache *alloc_symbol_cache(const char *sym, long offset)\r\n{\r\nstruct symbol_cache *sc;\r\nif (!sym || strlen(sym) == 0)\r\nreturn NULL;\r\nsc = kzalloc(sizeof(struct symbol_cache), GFP_KERNEL);\r\nif (!sc)\r\nreturn NULL;\r\nsc->symbol = kstrdup(sym, GFP_KERNEL);\r\nif (!sc->symbol) {\r\nkfree(sc);\r\nreturn NULL;\r\n}\r\nsc->offset = offset;\r\nupdate_symbol_cache(sc);\r\nreturn sc;\r\n}\r\nstatic struct trace_kprobe *alloc_trace_kprobe(const char *group,\r\nconst char *event,\r\nvoid *addr,\r\nconst char *symbol,\r\nunsigned long offs,\r\nint maxactive,\r\nint nargs, bool is_return)\r\n{\r\nstruct trace_kprobe *tk;\r\nint ret = -ENOMEM;\r\ntk = kzalloc(SIZEOF_TRACE_KPROBE(nargs), GFP_KERNEL);\r\nif (!tk)\r\nreturn ERR_PTR(ret);\r\ntk->nhit = alloc_percpu(unsigned long);\r\nif (!tk->nhit)\r\ngoto error;\r\nif (symbol) {\r\ntk->symbol = kstrdup(symbol, GFP_KERNEL);\r\nif (!tk->symbol)\r\ngoto error;\r\ntk->rp.kp.symbol_name = tk->symbol;\r\ntk->rp.kp.offset = offs;\r\n} else\r\ntk->rp.kp.addr = addr;\r\nif (is_return)\r\ntk->rp.handler = kretprobe_dispatcher;\r\nelse\r\ntk->rp.kp.pre_handler = kprobe_dispatcher;\r\ntk->rp.maxactive = maxactive;\r\nif (!event || !is_good_name(event)) {\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\ntk->tp.call.class = &tk->tp.class;\r\ntk->tp.call.name = kstrdup(event, GFP_KERNEL);\r\nif (!tk->tp.call.name)\r\ngoto error;\r\nif (!group || !is_good_name(group)) {\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\ntk->tp.class.system = kstrdup(group, GFP_KERNEL);\r\nif (!tk->tp.class.system)\r\ngoto error;\r\nINIT_LIST_HEAD(&tk->list);\r\nINIT_LIST_HEAD(&tk->tp.files);\r\nreturn tk;\r\nerror:\r\nkfree(tk->tp.call.name);\r\nkfree(tk->symbol);\r\nfree_percpu(tk->nhit);\r\nkfree(tk);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic void free_trace_kprobe(struct trace_kprobe *tk)\r\n{\r\nint i;\r\nfor (i = 0; i < tk->tp.nr_args; i++)\r\ntraceprobe_free_probe_arg(&tk->tp.args[i]);\r\nkfree(tk->tp.call.class->system);\r\nkfree(tk->tp.call.name);\r\nkfree(tk->symbol);\r\nfree_percpu(tk->nhit);\r\nkfree(tk);\r\n}\r\nstatic struct trace_kprobe *find_trace_kprobe(const char *event,\r\nconst char *group)\r\n{\r\nstruct trace_kprobe *tk;\r\nlist_for_each_entry(tk, &probe_list, list)\r\nif (strcmp(trace_event_name(&tk->tp.call), event) == 0 &&\r\nstrcmp(tk->tp.call.class->system, group) == 0)\r\nreturn tk;\r\nreturn NULL;\r\n}\r\nstatic int\r\nenable_trace_kprobe(struct trace_kprobe *tk, struct trace_event_file *file)\r\n{\r\nint ret = 0;\r\nif (file) {\r\nstruct event_file_link *link;\r\nlink = kmalloc(sizeof(*link), GFP_KERNEL);\r\nif (!link) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nlink->file = file;\r\nlist_add_tail_rcu(&link->list, &tk->tp.files);\r\ntk->tp.flags |= TP_FLAG_TRACE;\r\n} else\r\ntk->tp.flags |= TP_FLAG_PROFILE;\r\nif (trace_probe_is_registered(&tk->tp) && !trace_kprobe_has_gone(tk)) {\r\nif (trace_kprobe_is_return(tk))\r\nret = enable_kretprobe(&tk->rp);\r\nelse\r\nret = enable_kprobe(&tk->rp.kp);\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int\r\ndisable_trace_kprobe(struct trace_kprobe *tk, struct trace_event_file *file)\r\n{\r\nstruct event_file_link *link = NULL;\r\nint wait = 0;\r\nint ret = 0;\r\nif (file) {\r\nlink = find_event_file_link(&tk->tp, file);\r\nif (!link) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nlist_del_rcu(&link->list);\r\nwait = 1;\r\nif (!list_empty(&tk->tp.files))\r\ngoto out;\r\ntk->tp.flags &= ~TP_FLAG_TRACE;\r\n} else\r\ntk->tp.flags &= ~TP_FLAG_PROFILE;\r\nif (!trace_probe_is_enabled(&tk->tp) && trace_probe_is_registered(&tk->tp)) {\r\nif (trace_kprobe_is_return(tk))\r\ndisable_kretprobe(&tk->rp);\r\nelse\r\ndisable_kprobe(&tk->rp.kp);\r\nwait = 1;\r\n}\r\nout:\r\nif (wait) {\r\nsynchronize_sched();\r\nkfree(link);\r\n}\r\nreturn ret;\r\n}\r\nstatic int __register_trace_kprobe(struct trace_kprobe *tk)\r\n{\r\nint i, ret;\r\nif (trace_probe_is_registered(&tk->tp))\r\nreturn -EINVAL;\r\nfor (i = 0; i < tk->tp.nr_args; i++)\r\ntraceprobe_update_arg(&tk->tp.args[i]);\r\nif (trace_probe_is_enabled(&tk->tp))\r\ntk->rp.kp.flags &= ~KPROBE_FLAG_DISABLED;\r\nelse\r\ntk->rp.kp.flags |= KPROBE_FLAG_DISABLED;\r\nif (trace_kprobe_is_return(tk))\r\nret = register_kretprobe(&tk->rp);\r\nelse\r\nret = register_kprobe(&tk->rp.kp);\r\nif (ret == 0)\r\ntk->tp.flags |= TP_FLAG_REGISTERED;\r\nelse {\r\npr_warn("Could not insert probe at %s+%lu: %d\n",\r\ntrace_kprobe_symbol(tk), trace_kprobe_offset(tk), ret);\r\nif (ret == -ENOENT && trace_kprobe_is_on_module(tk)) {\r\npr_warn("This probe might be able to register after target module is loaded. Continue.\n");\r\nret = 0;\r\n} else if (ret == -EILSEQ) {\r\npr_warn("Probing address(0x%p) is not an instruction boundary.\n",\r\ntk->rp.kp.addr);\r\nret = -EINVAL;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void __unregister_trace_kprobe(struct trace_kprobe *tk)\r\n{\r\nif (trace_probe_is_registered(&tk->tp)) {\r\nif (trace_kprobe_is_return(tk))\r\nunregister_kretprobe(&tk->rp);\r\nelse\r\nunregister_kprobe(&tk->rp.kp);\r\ntk->tp.flags &= ~TP_FLAG_REGISTERED;\r\nif (tk->rp.kp.symbol_name)\r\ntk->rp.kp.addr = NULL;\r\n}\r\n}\r\nstatic int unregister_trace_kprobe(struct trace_kprobe *tk)\r\n{\r\nif (trace_probe_is_enabled(&tk->tp))\r\nreturn -EBUSY;\r\nif (unregister_kprobe_event(tk))\r\nreturn -EBUSY;\r\n__unregister_trace_kprobe(tk);\r\nlist_del(&tk->list);\r\nreturn 0;\r\n}\r\nstatic int register_trace_kprobe(struct trace_kprobe *tk)\r\n{\r\nstruct trace_kprobe *old_tk;\r\nint ret;\r\nmutex_lock(&probe_lock);\r\nold_tk = find_trace_kprobe(trace_event_name(&tk->tp.call),\r\ntk->tp.call.class->system);\r\nif (old_tk) {\r\nret = unregister_trace_kprobe(old_tk);\r\nif (ret < 0)\r\ngoto end;\r\nfree_trace_kprobe(old_tk);\r\n}\r\nret = register_kprobe_event(tk);\r\nif (ret) {\r\npr_warn("Failed to register probe event(%d)\n", ret);\r\ngoto end;\r\n}\r\nret = __register_trace_kprobe(tk);\r\nif (ret < 0)\r\nunregister_kprobe_event(tk);\r\nelse\r\nlist_add_tail(&tk->list, &probe_list);\r\nend:\r\nmutex_unlock(&probe_lock);\r\nreturn ret;\r\n}\r\nstatic int trace_kprobe_module_callback(struct notifier_block *nb,\r\nunsigned long val, void *data)\r\n{\r\nstruct module *mod = data;\r\nstruct trace_kprobe *tk;\r\nint ret;\r\nif (val != MODULE_STATE_COMING)\r\nreturn NOTIFY_DONE;\r\nmutex_lock(&probe_lock);\r\nlist_for_each_entry(tk, &probe_list, list) {\r\nif (trace_kprobe_within_module(tk, mod)) {\r\n__unregister_trace_kprobe(tk);\r\nret = __register_trace_kprobe(tk);\r\nif (ret)\r\npr_warn("Failed to re-register probe %s on %s: %d\n",\r\ntrace_event_name(&tk->tp.call),\r\nmod->name, ret);\r\n}\r\n}\r\nmutex_unlock(&probe_lock);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic inline void sanitize_event_name(char *name)\r\n{\r\nwhile (*name++ != '\0')\r\nif (*name == ':' || *name == '.')\r\n*name = '_';\r\n}\r\nstatic int create_trace_kprobe(int argc, char **argv)\r\n{\r\nstruct trace_kprobe *tk;\r\nint i, ret = 0;\r\nbool is_return = false, is_delete = false;\r\nchar *symbol = NULL, *event = NULL, *group = NULL;\r\nint maxactive = 0;\r\nchar *arg;\r\nunsigned long offset = 0;\r\nvoid *addr = NULL;\r\nchar buf[MAX_EVENT_NAME_LEN];\r\nif (argv[0][0] == 'p')\r\nis_return = false;\r\nelse if (argv[0][0] == 'r')\r\nis_return = true;\r\nelse if (argv[0][0] == '-')\r\nis_delete = true;\r\nelse {\r\npr_info("Probe definition must be started with 'p', 'r' or"\r\n" '-'.\n");\r\nreturn -EINVAL;\r\n}\r\nevent = strchr(&argv[0][1], ':');\r\nif (event) {\r\nevent[0] = '\0';\r\nevent++;\r\n}\r\nif (is_return && isdigit(argv[0][1])) {\r\nret = kstrtouint(&argv[0][1], 0, &maxactive);\r\nif (ret) {\r\npr_info("Failed to parse maxactive.\n");\r\nreturn ret;\r\n}\r\nif (maxactive > KRETPROBE_MAXACTIVE_MAX) {\r\npr_info("Maxactive is too big (%d > %d).\n",\r\nmaxactive, KRETPROBE_MAXACTIVE_MAX);\r\nreturn -E2BIG;\r\n}\r\n}\r\nif (event) {\r\nif (strchr(event, '/')) {\r\ngroup = event;\r\nevent = strchr(group, '/') + 1;\r\nevent[-1] = '\0';\r\nif (strlen(group) == 0) {\r\npr_info("Group name is not specified\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (strlen(event) == 0) {\r\npr_info("Event name is not specified\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (!group)\r\ngroup = KPROBE_EVENT_SYSTEM;\r\nif (is_delete) {\r\nif (!event) {\r\npr_info("Delete command needs an event name.\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&probe_lock);\r\ntk = find_trace_kprobe(event, group);\r\nif (!tk) {\r\nmutex_unlock(&probe_lock);\r\npr_info("Event %s/%s doesn't exist.\n", group, event);\r\nreturn -ENOENT;\r\n}\r\nret = unregister_trace_kprobe(tk);\r\nif (ret == 0)\r\nfree_trace_kprobe(tk);\r\nmutex_unlock(&probe_lock);\r\nreturn ret;\r\n}\r\nif (argc < 2) {\r\npr_info("Probe point is not specified.\n");\r\nreturn -EINVAL;\r\n}\r\nif (kstrtoul(argv[1], 0, (unsigned long *)&addr)) {\r\nsymbol = argv[1];\r\nret = traceprobe_split_symbol_offset(symbol, &offset);\r\nif (ret) {\r\npr_info("Failed to parse either an address or a symbol.\n");\r\nreturn ret;\r\n}\r\nif (offset && is_return &&\r\n!kprobe_on_func_entry(NULL, symbol, offset)) {\r\npr_info("Given offset is not valid for return probe.\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nargc -= 2; argv += 2;\r\nif (!event) {\r\nif (symbol)\r\nsnprintf(buf, MAX_EVENT_NAME_LEN, "%c_%s_%ld",\r\nis_return ? 'r' : 'p', symbol, offset);\r\nelse\r\nsnprintf(buf, MAX_EVENT_NAME_LEN, "%c_0x%p",\r\nis_return ? 'r' : 'p', addr);\r\nsanitize_event_name(buf);\r\nevent = buf;\r\n}\r\ntk = alloc_trace_kprobe(group, event, addr, symbol, offset, maxactive,\r\nargc, is_return);\r\nif (IS_ERR(tk)) {\r\npr_info("Failed to allocate trace_probe.(%d)\n",\r\n(int)PTR_ERR(tk));\r\nreturn PTR_ERR(tk);\r\n}\r\nret = 0;\r\nfor (i = 0; i < argc && i < MAX_TRACE_ARGS; i++) {\r\nstruct probe_arg *parg = &tk->tp.args[i];\r\ntk->tp.nr_args++;\r\narg = strchr(argv[i], '=');\r\nif (arg) {\r\n*arg++ = '\0';\r\nparg->name = kstrdup(argv[i], GFP_KERNEL);\r\n} else {\r\narg = argv[i];\r\nsnprintf(buf, MAX_EVENT_NAME_LEN, "arg%d", i + 1);\r\nparg->name = kstrdup(buf, GFP_KERNEL);\r\n}\r\nif (!parg->name) {\r\npr_info("Failed to allocate argument[%d] name.\n", i);\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nif (!is_good_name(parg->name)) {\r\npr_info("Invalid argument[%d] name: %s\n",\r\ni, parg->name);\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nif (traceprobe_conflict_field_name(parg->name,\r\ntk->tp.args, i)) {\r\npr_info("Argument[%d] name '%s' conflicts with "\r\n"another field.\n", i, argv[i]);\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nret = traceprobe_parse_probe_arg(arg, &tk->tp.size, parg,\r\nis_return, true,\r\nkprobes_fetch_type_table);\r\nif (ret) {\r\npr_info("Parse error at argument[%d]. (%d)\n", i, ret);\r\ngoto error;\r\n}\r\n}\r\nret = register_trace_kprobe(tk);\r\nif (ret)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nfree_trace_kprobe(tk);\r\nreturn ret;\r\n}\r\nstatic int release_all_trace_kprobes(void)\r\n{\r\nstruct trace_kprobe *tk;\r\nint ret = 0;\r\nmutex_lock(&probe_lock);\r\nlist_for_each_entry(tk, &probe_list, list)\r\nif (trace_probe_is_enabled(&tk->tp)) {\r\nret = -EBUSY;\r\ngoto end;\r\n}\r\nwhile (!list_empty(&probe_list)) {\r\ntk = list_entry(probe_list.next, struct trace_kprobe, list);\r\nret = unregister_trace_kprobe(tk);\r\nif (ret)\r\ngoto end;\r\nfree_trace_kprobe(tk);\r\n}\r\nend:\r\nmutex_unlock(&probe_lock);\r\nreturn ret;\r\n}\r\nstatic void *probes_seq_start(struct seq_file *m, loff_t *pos)\r\n{\r\nmutex_lock(&probe_lock);\r\nreturn seq_list_start(&probe_list, *pos);\r\n}\r\nstatic void *probes_seq_next(struct seq_file *m, void *v, loff_t *pos)\r\n{\r\nreturn seq_list_next(v, &probe_list, pos);\r\n}\r\nstatic void probes_seq_stop(struct seq_file *m, void *v)\r\n{\r\nmutex_unlock(&probe_lock);\r\n}\r\nstatic int probes_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct trace_kprobe *tk = v;\r\nint i;\r\nseq_putc(m, trace_kprobe_is_return(tk) ? 'r' : 'p');\r\nseq_printf(m, ":%s/%s", tk->tp.call.class->system,\r\ntrace_event_name(&tk->tp.call));\r\nif (!tk->symbol)\r\nseq_printf(m, " 0x%p", tk->rp.kp.addr);\r\nelse if (tk->rp.kp.offset)\r\nseq_printf(m, " %s+%u", trace_kprobe_symbol(tk),\r\ntk->rp.kp.offset);\r\nelse\r\nseq_printf(m, " %s", trace_kprobe_symbol(tk));\r\nfor (i = 0; i < tk->tp.nr_args; i++)\r\nseq_printf(m, " %s=%s", tk->tp.args[i].name, tk->tp.args[i].comm);\r\nseq_putc(m, '\n');\r\nreturn 0;\r\n}\r\nstatic int probes_open(struct inode *inode, struct file *file)\r\n{\r\nint ret;\r\nif ((file->f_mode & FMODE_WRITE) && (file->f_flags & O_TRUNC)) {\r\nret = release_all_trace_kprobes();\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn seq_open(file, &probes_seq_op);\r\n}\r\nstatic ssize_t probes_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nreturn traceprobe_probes_write(file, buffer, count, ppos,\r\ncreate_trace_kprobe);\r\n}\r\nstatic int probes_profile_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct trace_kprobe *tk = v;\r\nseq_printf(m, " %-44s %15lu %15lu\n",\r\ntrace_event_name(&tk->tp.call),\r\ntrace_kprobe_nhit(tk),\r\ntk->rp.kp.nmissed);\r\nreturn 0;\r\n}\r\nstatic int profile_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &profile_seq_op);\r\n}\r\nstatic nokprobe_inline void\r\n__kprobe_trace_func(struct trace_kprobe *tk, struct pt_regs *regs,\r\nstruct trace_event_file *trace_file)\r\n{\r\nstruct kprobe_trace_entry_head *entry;\r\nstruct ring_buffer_event *event;\r\nstruct ring_buffer *buffer;\r\nint size, dsize, pc;\r\nunsigned long irq_flags;\r\nstruct trace_event_call *call = &tk->tp.call;\r\nWARN_ON(call != trace_file->event_call);\r\nif (trace_trigger_soft_disabled(trace_file))\r\nreturn;\r\nlocal_save_flags(irq_flags);\r\npc = preempt_count();\r\ndsize = __get_data_size(&tk->tp, regs);\r\nsize = sizeof(*entry) + tk->tp.size + dsize;\r\nevent = trace_event_buffer_lock_reserve(&buffer, trace_file,\r\ncall->event.type,\r\nsize, irq_flags, pc);\r\nif (!event)\r\nreturn;\r\nentry = ring_buffer_event_data(event);\r\nentry->ip = (unsigned long)tk->rp.kp.addr;\r\nstore_trace_args(sizeof(*entry), &tk->tp, regs, (u8 *)&entry[1], dsize);\r\nevent_trigger_unlock_commit_regs(trace_file, buffer, event,\r\nentry, irq_flags, pc, regs);\r\n}\r\nstatic void\r\nkprobe_trace_func(struct trace_kprobe *tk, struct pt_regs *regs)\r\n{\r\nstruct event_file_link *link;\r\nlist_for_each_entry_rcu(link, &tk->tp.files, list)\r\n__kprobe_trace_func(tk, regs, link->file);\r\n}\r\nstatic nokprobe_inline void\r\n__kretprobe_trace_func(struct trace_kprobe *tk, struct kretprobe_instance *ri,\r\nstruct pt_regs *regs,\r\nstruct trace_event_file *trace_file)\r\n{\r\nstruct kretprobe_trace_entry_head *entry;\r\nstruct ring_buffer_event *event;\r\nstruct ring_buffer *buffer;\r\nint size, pc, dsize;\r\nunsigned long irq_flags;\r\nstruct trace_event_call *call = &tk->tp.call;\r\nWARN_ON(call != trace_file->event_call);\r\nif (trace_trigger_soft_disabled(trace_file))\r\nreturn;\r\nlocal_save_flags(irq_flags);\r\npc = preempt_count();\r\ndsize = __get_data_size(&tk->tp, regs);\r\nsize = sizeof(*entry) + tk->tp.size + dsize;\r\nevent = trace_event_buffer_lock_reserve(&buffer, trace_file,\r\ncall->event.type,\r\nsize, irq_flags, pc);\r\nif (!event)\r\nreturn;\r\nentry = ring_buffer_event_data(event);\r\nentry->func = (unsigned long)tk->rp.kp.addr;\r\nentry->ret_ip = (unsigned long)ri->ret_addr;\r\nstore_trace_args(sizeof(*entry), &tk->tp, regs, (u8 *)&entry[1], dsize);\r\nevent_trigger_unlock_commit_regs(trace_file, buffer, event,\r\nentry, irq_flags, pc, regs);\r\n}\r\nstatic void\r\nkretprobe_trace_func(struct trace_kprobe *tk, struct kretprobe_instance *ri,\r\nstruct pt_regs *regs)\r\n{\r\nstruct event_file_link *link;\r\nlist_for_each_entry_rcu(link, &tk->tp.files, list)\r\n__kretprobe_trace_func(tk, ri, regs, link->file);\r\n}\r\nstatic enum print_line_t\r\nprint_kprobe_event(struct trace_iterator *iter, int flags,\r\nstruct trace_event *event)\r\n{\r\nstruct kprobe_trace_entry_head *field;\r\nstruct trace_seq *s = &iter->seq;\r\nstruct trace_probe *tp;\r\nu8 *data;\r\nint i;\r\nfield = (struct kprobe_trace_entry_head *)iter->ent;\r\ntp = container_of(event, struct trace_probe, call.event);\r\ntrace_seq_printf(s, "%s: (", trace_event_name(&tp->call));\r\nif (!seq_print_ip_sym(s, field->ip, flags | TRACE_ITER_SYM_OFFSET))\r\ngoto out;\r\ntrace_seq_putc(s, ')');\r\ndata = (u8 *)&field[1];\r\nfor (i = 0; i < tp->nr_args; i++)\r\nif (!tp->args[i].type->print(s, tp->args[i].name,\r\ndata + tp->args[i].offset, field))\r\ngoto out;\r\ntrace_seq_putc(s, '\n');\r\nout:\r\nreturn trace_handle_return(s);\r\n}\r\nstatic enum print_line_t\r\nprint_kretprobe_event(struct trace_iterator *iter, int flags,\r\nstruct trace_event *event)\r\n{\r\nstruct kretprobe_trace_entry_head *field;\r\nstruct trace_seq *s = &iter->seq;\r\nstruct trace_probe *tp;\r\nu8 *data;\r\nint i;\r\nfield = (struct kretprobe_trace_entry_head *)iter->ent;\r\ntp = container_of(event, struct trace_probe, call.event);\r\ntrace_seq_printf(s, "%s: (", trace_event_name(&tp->call));\r\nif (!seq_print_ip_sym(s, field->ret_ip, flags | TRACE_ITER_SYM_OFFSET))\r\ngoto out;\r\ntrace_seq_puts(s, " <- ");\r\nif (!seq_print_ip_sym(s, field->func, flags & ~TRACE_ITER_SYM_OFFSET))\r\ngoto out;\r\ntrace_seq_putc(s, ')');\r\ndata = (u8 *)&field[1];\r\nfor (i = 0; i < tp->nr_args; i++)\r\nif (!tp->args[i].type->print(s, tp->args[i].name,\r\ndata + tp->args[i].offset, field))\r\ngoto out;\r\ntrace_seq_putc(s, '\n');\r\nout:\r\nreturn trace_handle_return(s);\r\n}\r\nstatic int kprobe_event_define_fields(struct trace_event_call *event_call)\r\n{\r\nint ret, i;\r\nstruct kprobe_trace_entry_head field;\r\nstruct trace_kprobe *tk = (struct trace_kprobe *)event_call->data;\r\nDEFINE_FIELD(unsigned long, ip, FIELD_STRING_IP, 0);\r\nfor (i = 0; i < tk->tp.nr_args; i++) {\r\nstruct probe_arg *parg = &tk->tp.args[i];\r\nret = trace_define_field(event_call, parg->type->fmttype,\r\nparg->name,\r\nsizeof(field) + parg->offset,\r\nparg->type->size,\r\nparg->type->is_signed,\r\nFILTER_OTHER);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int kretprobe_event_define_fields(struct trace_event_call *event_call)\r\n{\r\nint ret, i;\r\nstruct kretprobe_trace_entry_head field;\r\nstruct trace_kprobe *tk = (struct trace_kprobe *)event_call->data;\r\nDEFINE_FIELD(unsigned long, func, FIELD_STRING_FUNC, 0);\r\nDEFINE_FIELD(unsigned long, ret_ip, FIELD_STRING_RETIP, 0);\r\nfor (i = 0; i < tk->tp.nr_args; i++) {\r\nstruct probe_arg *parg = &tk->tp.args[i];\r\nret = trace_define_field(event_call, parg->type->fmttype,\r\nparg->name,\r\nsizeof(field) + parg->offset,\r\nparg->type->size,\r\nparg->type->is_signed,\r\nFILTER_OTHER);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nkprobe_perf_func(struct trace_kprobe *tk, struct pt_regs *regs)\r\n{\r\nstruct trace_event_call *call = &tk->tp.call;\r\nstruct bpf_prog *prog = call->prog;\r\nstruct kprobe_trace_entry_head *entry;\r\nstruct hlist_head *head;\r\nint size, __size, dsize;\r\nint rctx;\r\nif (prog && !trace_call_bpf(prog, regs))\r\nreturn;\r\nhead = this_cpu_ptr(call->perf_events);\r\nif (hlist_empty(head))\r\nreturn;\r\ndsize = __get_data_size(&tk->tp, regs);\r\n__size = sizeof(*entry) + tk->tp.size + dsize;\r\nsize = ALIGN(__size + sizeof(u32), sizeof(u64));\r\nsize -= sizeof(u32);\r\nentry = perf_trace_buf_alloc(size, NULL, &rctx);\r\nif (!entry)\r\nreturn;\r\nentry->ip = (unsigned long)tk->rp.kp.addr;\r\nmemset(&entry[1], 0, dsize);\r\nstore_trace_args(sizeof(*entry), &tk->tp, regs, (u8 *)&entry[1], dsize);\r\nperf_trace_buf_submit(entry, size, rctx, call->event.type, 1, regs,\r\nhead, NULL, NULL);\r\n}\r\nstatic void\r\nkretprobe_perf_func(struct trace_kprobe *tk, struct kretprobe_instance *ri,\r\nstruct pt_regs *regs)\r\n{\r\nstruct trace_event_call *call = &tk->tp.call;\r\nstruct bpf_prog *prog = call->prog;\r\nstruct kretprobe_trace_entry_head *entry;\r\nstruct hlist_head *head;\r\nint size, __size, dsize;\r\nint rctx;\r\nif (prog && !trace_call_bpf(prog, regs))\r\nreturn;\r\nhead = this_cpu_ptr(call->perf_events);\r\nif (hlist_empty(head))\r\nreturn;\r\ndsize = __get_data_size(&tk->tp, regs);\r\n__size = sizeof(*entry) + tk->tp.size + dsize;\r\nsize = ALIGN(__size + sizeof(u32), sizeof(u64));\r\nsize -= sizeof(u32);\r\nentry = perf_trace_buf_alloc(size, NULL, &rctx);\r\nif (!entry)\r\nreturn;\r\nentry->func = (unsigned long)tk->rp.kp.addr;\r\nentry->ret_ip = (unsigned long)ri->ret_addr;\r\nstore_trace_args(sizeof(*entry), &tk->tp, regs, (u8 *)&entry[1], dsize);\r\nperf_trace_buf_submit(entry, size, rctx, call->event.type, 1, regs,\r\nhead, NULL, NULL);\r\n}\r\nstatic int kprobe_register(struct trace_event_call *event,\r\nenum trace_reg type, void *data)\r\n{\r\nstruct trace_kprobe *tk = (struct trace_kprobe *)event->data;\r\nstruct trace_event_file *file = data;\r\nswitch (type) {\r\ncase TRACE_REG_REGISTER:\r\nreturn enable_trace_kprobe(tk, file);\r\ncase TRACE_REG_UNREGISTER:\r\nreturn disable_trace_kprobe(tk, file);\r\n#ifdef CONFIG_PERF_EVENTS\r\ncase TRACE_REG_PERF_REGISTER:\r\nreturn enable_trace_kprobe(tk, NULL);\r\ncase TRACE_REG_PERF_UNREGISTER:\r\nreturn disable_trace_kprobe(tk, NULL);\r\ncase TRACE_REG_PERF_OPEN:\r\ncase TRACE_REG_PERF_CLOSE:\r\ncase TRACE_REG_PERF_ADD:\r\ncase TRACE_REG_PERF_DEL:\r\nreturn 0;\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nstatic int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs)\r\n{\r\nstruct trace_kprobe *tk = container_of(kp, struct trace_kprobe, rp.kp);\r\nraw_cpu_inc(*tk->nhit);\r\nif (tk->tp.flags & TP_FLAG_TRACE)\r\nkprobe_trace_func(tk, regs);\r\n#ifdef CONFIG_PERF_EVENTS\r\nif (tk->tp.flags & TP_FLAG_PROFILE)\r\nkprobe_perf_func(tk, regs);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int\r\nkretprobe_dispatcher(struct kretprobe_instance *ri, struct pt_regs *regs)\r\n{\r\nstruct trace_kprobe *tk = container_of(ri->rp, struct trace_kprobe, rp);\r\nraw_cpu_inc(*tk->nhit);\r\nif (tk->tp.flags & TP_FLAG_TRACE)\r\nkretprobe_trace_func(tk, ri, regs);\r\n#ifdef CONFIG_PERF_EVENTS\r\nif (tk->tp.flags & TP_FLAG_PROFILE)\r\nkretprobe_perf_func(tk, ri, regs);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int register_kprobe_event(struct trace_kprobe *tk)\r\n{\r\nstruct trace_event_call *call = &tk->tp.call;\r\nint ret;\r\nINIT_LIST_HEAD(&call->class->fields);\r\nif (trace_kprobe_is_return(tk)) {\r\ncall->event.funcs = &kretprobe_funcs;\r\ncall->class->define_fields = kretprobe_event_define_fields;\r\n} else {\r\ncall->event.funcs = &kprobe_funcs;\r\ncall->class->define_fields = kprobe_event_define_fields;\r\n}\r\nif (set_print_fmt(&tk->tp, trace_kprobe_is_return(tk)) < 0)\r\nreturn -ENOMEM;\r\nret = register_trace_event(&call->event);\r\nif (!ret) {\r\nkfree(call->print_fmt);\r\nreturn -ENODEV;\r\n}\r\ncall->flags = TRACE_EVENT_FL_KPROBE;\r\ncall->class->reg = kprobe_register;\r\ncall->data = tk;\r\nret = trace_add_event_call(call);\r\nif (ret) {\r\npr_info("Failed to register kprobe event: %s\n",\r\ntrace_event_name(call));\r\nkfree(call->print_fmt);\r\nunregister_trace_event(&call->event);\r\n}\r\nreturn ret;\r\n}\r\nstatic int unregister_kprobe_event(struct trace_kprobe *tk)\r\n{\r\nint ret;\r\nret = trace_remove_event_call(&tk->tp.call);\r\nif (!ret)\r\nkfree(tk->tp.call.print_fmt);\r\nreturn ret;\r\n}\r\nstatic __init int init_kprobe_trace(void)\r\n{\r\nstruct dentry *d_tracer;\r\nstruct dentry *entry;\r\nif (register_module_notifier(&trace_kprobe_module_nb))\r\nreturn -EINVAL;\r\nd_tracer = tracing_init_dentry();\r\nif (IS_ERR(d_tracer))\r\nreturn 0;\r\nentry = tracefs_create_file("kprobe_events", 0644, d_tracer,\r\nNULL, &kprobe_events_ops);\r\nif (!entry)\r\npr_warn("Could not create tracefs 'kprobe_events' entry\n");\r\nentry = tracefs_create_file("kprobe_profile", 0444, d_tracer,\r\nNULL, &kprobe_profile_ops);\r\nif (!entry)\r\npr_warn("Could not create tracefs 'kprobe_profile' entry\n");\r\nreturn 0;\r\n}\r\nstatic __used __init noinline int\r\nkprobe_trace_selftest_target(int a1, int a2, int a3, int a4, int a5, int a6)\r\n{\r\nreturn a1 + a2 + a3 + a4 + a5 + a6;\r\n}\r\n__init int kprobe_trace_self_tests_init(void)\r\n{\r\nint ret, warn = 0;\r\nint (*target)(int, int, int, int, int, int);\r\nstruct trace_kprobe *tk;\r\nstruct trace_event_file *file;\r\nif (tracing_is_disabled())\r\nreturn -ENODEV;\r\ntarget = kprobe_trace_selftest_target;\r\npr_info("Testing kprobe tracing: ");\r\nret = traceprobe_command("p:testprobe kprobe_trace_selftest_target "\r\n"$stack $stack0 +0($stack)",\r\ncreate_trace_kprobe);\r\nif (WARN_ON_ONCE(ret)) {\r\npr_warn("error on probing function entry.\n");\r\nwarn++;\r\n} else {\r\ntk = find_trace_kprobe("testprobe", KPROBE_EVENT_SYSTEM);\r\nif (WARN_ON_ONCE(tk == NULL)) {\r\npr_warn("error on getting new probe.\n");\r\nwarn++;\r\n} else {\r\nfile = find_trace_probe_file(tk, top_trace_array());\r\nif (WARN_ON_ONCE(file == NULL)) {\r\npr_warn("error on getting probe file.\n");\r\nwarn++;\r\n} else\r\nenable_trace_kprobe(tk, file);\r\n}\r\n}\r\nret = traceprobe_command("r:testprobe2 kprobe_trace_selftest_target "\r\n"$retval", create_trace_kprobe);\r\nif (WARN_ON_ONCE(ret)) {\r\npr_warn("error on probing function return.\n");\r\nwarn++;\r\n} else {\r\ntk = find_trace_kprobe("testprobe2", KPROBE_EVENT_SYSTEM);\r\nif (WARN_ON_ONCE(tk == NULL)) {\r\npr_warn("error on getting 2nd new probe.\n");\r\nwarn++;\r\n} else {\r\nfile = find_trace_probe_file(tk, top_trace_array());\r\nif (WARN_ON_ONCE(file == NULL)) {\r\npr_warn("error on getting probe file.\n");\r\nwarn++;\r\n} else\r\nenable_trace_kprobe(tk, file);\r\n}\r\n}\r\nif (warn)\r\ngoto end;\r\nret = target(1, 2, 3, 4, 5, 6);\r\nif (ret != 21)\r\nwarn++;\r\ntk = find_trace_kprobe("testprobe", KPROBE_EVENT_SYSTEM);\r\nif (WARN_ON_ONCE(tk == NULL)) {\r\npr_warn("error on getting test probe.\n");\r\nwarn++;\r\n} else {\r\nif (trace_kprobe_nhit(tk) != 1) {\r\npr_warn("incorrect number of testprobe hits\n");\r\nwarn++;\r\n}\r\nfile = find_trace_probe_file(tk, top_trace_array());\r\nif (WARN_ON_ONCE(file == NULL)) {\r\npr_warn("error on getting probe file.\n");\r\nwarn++;\r\n} else\r\ndisable_trace_kprobe(tk, file);\r\n}\r\ntk = find_trace_kprobe("testprobe2", KPROBE_EVENT_SYSTEM);\r\nif (WARN_ON_ONCE(tk == NULL)) {\r\npr_warn("error on getting 2nd test probe.\n");\r\nwarn++;\r\n} else {\r\nif (trace_kprobe_nhit(tk) != 1) {\r\npr_warn("incorrect number of testprobe2 hits\n");\r\nwarn++;\r\n}\r\nfile = find_trace_probe_file(tk, top_trace_array());\r\nif (WARN_ON_ONCE(file == NULL)) {\r\npr_warn("error on getting probe file.\n");\r\nwarn++;\r\n} else\r\ndisable_trace_kprobe(tk, file);\r\n}\r\nret = traceprobe_command("-:testprobe", create_trace_kprobe);\r\nif (WARN_ON_ONCE(ret)) {\r\npr_warn("error on deleting a probe.\n");\r\nwarn++;\r\n}\r\nret = traceprobe_command("-:testprobe2", create_trace_kprobe);\r\nif (WARN_ON_ONCE(ret)) {\r\npr_warn("error on deleting a probe.\n");\r\nwarn++;\r\n}\r\nend:\r\nrelease_all_trace_kprobes();\r\nwait_for_kprobe_optimizer();\r\nif (warn)\r\npr_cont("NG: Some tests are failed. Please check them.\n");\r\nelse\r\npr_cont("OK\n");\r\nreturn 0;\r\n}
