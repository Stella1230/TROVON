static void axp288_extcon_log_rsi(struct axp288_extcon_info *info)\r\n{\r\nchar **rsi;\r\nunsigned int val, i, clear_mask = 0;\r\nint ret;\r\nret = regmap_read(info->regmap, AXP288_PS_BOOT_REASON_REG, &val);\r\nfor (i = 0, rsi = axp288_pwr_up_down_info; *rsi; rsi++, i++) {\r\nif (val & BIT(i)) {\r\ndev_dbg(info->dev, "%s\n", *rsi);\r\nclear_mask |= BIT(i);\r\n}\r\n}\r\nregmap_write(info->regmap, AXP288_PS_BOOT_REASON_REG, clear_mask);\r\n}\r\nstatic int axp288_handle_chrg_det_event(struct axp288_extcon_info *info)\r\n{\r\nint ret, stat, cfg, pwr_stat;\r\nu8 chrg_type;\r\nunsigned int cable = info->previous_cable;\r\nbool vbus_attach = false;\r\nret = regmap_read(info->regmap, AXP288_PS_STAT_REG, &pwr_stat);\r\nif (ret < 0) {\r\ndev_err(info->dev, "failed to read vbus status\n");\r\nreturn ret;\r\n}\r\nvbus_attach = (pwr_stat & PS_STAT_VBUS_VALID);\r\nif (!vbus_attach)\r\ngoto no_vbus;\r\nret = regmap_read(info->regmap, AXP288_BC_GLOBAL_REG, &cfg);\r\nif (ret < 0)\r\ngoto dev_det_ret;\r\nif (cfg & BC_GLOBAL_DET_STAT) {\r\ndev_dbg(info->dev, "can't complete the charger detection\n");\r\ngoto dev_det_ret;\r\n}\r\nret = regmap_read(info->regmap, AXP288_BC_DET_STAT_REG, &stat);\r\nif (ret < 0)\r\ngoto dev_det_ret;\r\nchrg_type = (stat & DET_STAT_MASK) >> DET_STAT_SHIFT;\r\nswitch (chrg_type) {\r\ncase DET_STAT_SDP:\r\ndev_dbg(info->dev, "sdp cable is connected\n");\r\ncable = EXTCON_CHG_USB_SDP;\r\nbreak;\r\ncase DET_STAT_CDP:\r\ndev_dbg(info->dev, "cdp cable is connected\n");\r\ncable = EXTCON_CHG_USB_CDP;\r\nbreak;\r\ncase DET_STAT_DCP:\r\ndev_dbg(info->dev, "dcp cable is connected\n");\r\ncable = EXTCON_CHG_USB_DCP;\r\nbreak;\r\ndefault:\r\ndev_warn(info->dev,\r\n"disconnect or unknown or ID event\n");\r\n}\r\nno_vbus:\r\nif (info->gpio_mux_cntl)\r\ngpiod_set_value(info->gpio_mux_cntl,\r\nvbus_attach ? EXTCON_GPIO_MUX_SEL_SOC\r\n: EXTCON_GPIO_MUX_SEL_PMIC);\r\nextcon_set_state_sync(info->edev, info->previous_cable, false);\r\nif (info->previous_cable == EXTCON_CHG_USB_SDP)\r\nextcon_set_state_sync(info->edev, EXTCON_USB, false);\r\nif (vbus_attach) {\r\nextcon_set_state_sync(info->edev, cable, vbus_attach);\r\nif (cable == EXTCON_CHG_USB_SDP)\r\nextcon_set_state_sync(info->edev, EXTCON_USB,\r\nvbus_attach);\r\ninfo->previous_cable = cable;\r\n}\r\nreturn 0;\r\ndev_det_ret:\r\nif (ret < 0)\r\ndev_err(info->dev, "failed to detect BC Mod\n");\r\nreturn ret;\r\n}\r\nstatic irqreturn_t axp288_extcon_isr(int irq, void *data)\r\n{\r\nstruct axp288_extcon_info *info = data;\r\nint ret;\r\nret = axp288_handle_chrg_det_event(info);\r\nif (ret < 0)\r\ndev_err(info->dev, "failed to handle the interrupt\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void axp288_extcon_enable(struct axp288_extcon_info *info)\r\n{\r\nregmap_update_bits(info->regmap, AXP288_BC_GLOBAL_REG,\r\nBC_GLOBAL_RUN, 0);\r\nregmap_update_bits(info->regmap, AXP288_BC_GLOBAL_REG,\r\nBC_GLOBAL_RUN, BC_GLOBAL_RUN);\r\n}\r\nstatic int axp288_extcon_probe(struct platform_device *pdev)\r\n{\r\nstruct axp288_extcon_info *info;\r\nstruct axp20x_dev *axp20x = dev_get_drvdata(pdev->dev.parent);\r\nstruct axp288_extcon_pdata *pdata = pdev->dev.platform_data;\r\nint ret, i, pirq, gpio;\r\ninfo = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\ninfo->dev = &pdev->dev;\r\ninfo->regmap = axp20x->regmap;\r\ninfo->regmap_irqc = axp20x->regmap_irqc;\r\ninfo->previous_cable = EXTCON_NONE;\r\nif (pdata)\r\ninfo->gpio_mux_cntl = pdata->gpio_mux_cntl;\r\nplatform_set_drvdata(pdev, info);\r\naxp288_extcon_log_rsi(info);\r\ninfo->edev = devm_extcon_dev_allocate(&pdev->dev,\r\naxp288_extcon_cables);\r\nif (IS_ERR(info->edev)) {\r\ndev_err(&pdev->dev, "failed to allocate memory for extcon\n");\r\nreturn PTR_ERR(info->edev);\r\n}\r\nret = devm_extcon_dev_register(&pdev->dev, info->edev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register extcon device\n");\r\nreturn ret;\r\n}\r\nif (info->gpio_mux_cntl) {\r\ngpio = desc_to_gpio(info->gpio_mux_cntl);\r\nret = devm_gpio_request(&pdev->dev, gpio, "USB_MUX");\r\nif (ret < 0) {\r\ndev_err(&pdev->dev,\r\n"failed to request the gpio=%d\n", gpio);\r\nreturn ret;\r\n}\r\ngpiod_direction_output(info->gpio_mux_cntl,\r\nEXTCON_GPIO_MUX_SEL_PMIC);\r\n}\r\nfor (i = 0; i < EXTCON_IRQ_END; i++) {\r\npirq = platform_get_irq(pdev, i);\r\ninfo->irq[i] = regmap_irq_get_virq(info->regmap_irqc, pirq);\r\nif (info->irq[i] < 0) {\r\ndev_err(&pdev->dev,\r\n"failed to get virtual interrupt=%d\n", pirq);\r\nret = info->irq[i];\r\nreturn ret;\r\n}\r\nret = devm_request_threaded_irq(&pdev->dev, info->irq[i],\r\nNULL, axp288_extcon_isr,\r\nIRQF_ONESHOT | IRQF_NO_SUSPEND,\r\npdev->name, info);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to request interrupt=%d\n",\r\ninfo->irq[i]);\r\nreturn ret;\r\n}\r\n}\r\naxp288_extcon_enable(info);\r\nreturn 0;\r\n}
