int edac_get_report_status(void)\r\n{\r\nreturn edac_report;\r\n}\r\nvoid edac_set_report_status(int new)\r\n{\r\nif (new == EDAC_REPORTING_ENABLED ||\r\nnew == EDAC_REPORTING_DISABLED ||\r\nnew == EDAC_REPORTING_FORCE)\r\nedac_report = new;\r\n}\r\nstatic int edac_report_set(const char *str, const struct kernel_param *kp)\r\n{\r\nif (!str)\r\nreturn -EINVAL;\r\nif (!strncmp(str, "on", 2))\r\nedac_report = EDAC_REPORTING_ENABLED;\r\nelse if (!strncmp(str, "off", 3))\r\nedac_report = EDAC_REPORTING_DISABLED;\r\nelse if (!strncmp(str, "force", 5))\r\nedac_report = EDAC_REPORTING_FORCE;\r\nreturn 0;\r\n}\r\nstatic int edac_report_get(char *buffer, const struct kernel_param *kp)\r\n{\r\nint ret = 0;\r\nswitch (edac_report) {\r\ncase EDAC_REPORTING_ENABLED:\r\nret = sprintf(buffer, "on");\r\nbreak;\r\ncase EDAC_REPORTING_DISABLED:\r\nret = sprintf(buffer, "off");\r\nbreak;\r\ncase EDAC_REPORTING_FORCE:\r\nret = sprintf(buffer, "force");\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nunsigned edac_dimm_info_location(struct dimm_info *dimm, char *buf,\r\nunsigned len)\r\n{\r\nstruct mem_ctl_info *mci = dimm->mci;\r\nint i, n, count = 0;\r\nchar *p = buf;\r\nfor (i = 0; i < mci->n_layers; i++) {\r\nn = snprintf(p, len, "%s %d ",\r\nedac_layer_name[mci->layers[i].type],\r\ndimm->location[i]);\r\np += n;\r\nlen -= n;\r\ncount += n;\r\nif (!len)\r\nbreak;\r\n}\r\nreturn count;\r\n}\r\nstatic void edac_mc_dump_channel(struct rank_info *chan)\r\n{\r\nedac_dbg(4, " channel->chan_idx = %d\n", chan->chan_idx);\r\nedac_dbg(4, " channel = %p\n", chan);\r\nedac_dbg(4, " channel->csrow = %p\n", chan->csrow);\r\nedac_dbg(4, " channel->dimm = %p\n", chan->dimm);\r\n}\r\nstatic void edac_mc_dump_dimm(struct dimm_info *dimm, int number)\r\n{\r\nchar location[80];\r\nedac_dimm_info_location(dimm, location, sizeof(location));\r\nedac_dbg(4, "%s%i: %smapped as virtual row %d, chan %d\n",\r\ndimm->mci->csbased ? "rank" : "dimm",\r\nnumber, location, dimm->csrow, dimm->cschannel);\r\nedac_dbg(4, " dimm = %p\n", dimm);\r\nedac_dbg(4, " dimm->label = '%s'\n", dimm->label);\r\nedac_dbg(4, " dimm->nr_pages = 0x%x\n", dimm->nr_pages);\r\nedac_dbg(4, " dimm->grain = %d\n", dimm->grain);\r\nedac_dbg(4, " dimm->nr_pages = 0x%x\n", dimm->nr_pages);\r\n}\r\nstatic void edac_mc_dump_csrow(struct csrow_info *csrow)\r\n{\r\nedac_dbg(4, "csrow->csrow_idx = %d\n", csrow->csrow_idx);\r\nedac_dbg(4, " csrow = %p\n", csrow);\r\nedac_dbg(4, " csrow->first_page = 0x%lx\n", csrow->first_page);\r\nedac_dbg(4, " csrow->last_page = 0x%lx\n", csrow->last_page);\r\nedac_dbg(4, " csrow->page_mask = 0x%lx\n", csrow->page_mask);\r\nedac_dbg(4, " csrow->nr_channels = %d\n", csrow->nr_channels);\r\nedac_dbg(4, " csrow->channels = %p\n", csrow->channels);\r\nedac_dbg(4, " csrow->mci = %p\n", csrow->mci);\r\n}\r\nstatic void edac_mc_dump_mci(struct mem_ctl_info *mci)\r\n{\r\nedac_dbg(3, "\tmci = %p\n", mci);\r\nedac_dbg(3, "\tmci->mtype_cap = %lx\n", mci->mtype_cap);\r\nedac_dbg(3, "\tmci->edac_ctl_cap = %lx\n", mci->edac_ctl_cap);\r\nedac_dbg(3, "\tmci->edac_cap = %lx\n", mci->edac_cap);\r\nedac_dbg(4, "\tmci->edac_check = %p\n", mci->edac_check);\r\nedac_dbg(3, "\tmci->nr_csrows = %d, csrows = %p\n",\r\nmci->nr_csrows, mci->csrows);\r\nedac_dbg(3, "\tmci->nr_dimms = %d, dimms = %p\n",\r\nmci->tot_dimms, mci->dimms);\r\nedac_dbg(3, "\tdev = %p\n", mci->pdev);\r\nedac_dbg(3, "\tmod_name:ctl_name = %s:%s\n",\r\nmci->mod_name, mci->ctl_name);\r\nedac_dbg(3, "\tpvt_info = %p\n\n", mci->pvt_info);\r\n}\r\nvoid *edac_align_ptr(void **p, unsigned size, int n_elems)\r\n{\r\nunsigned align, r;\r\nvoid *ptr = *p;\r\n*p += size * n_elems;\r\nif (size > sizeof(long))\r\nalign = sizeof(long long);\r\nelse if (size > sizeof(int))\r\nalign = sizeof(long);\r\nelse if (size > sizeof(short))\r\nalign = sizeof(int);\r\nelse if (size > sizeof(char))\r\nalign = sizeof(short);\r\nelse\r\nreturn (char *)ptr;\r\nr = (unsigned long)p % align;\r\nif (r == 0)\r\nreturn (char *)ptr;\r\n*p += align - r;\r\nreturn (void *)(((unsigned long)ptr) + align - r);\r\n}\r\nstatic void _edac_mc_free(struct mem_ctl_info *mci)\r\n{\r\nint i, chn, row;\r\nstruct csrow_info *csr;\r\nconst unsigned int tot_dimms = mci->tot_dimms;\r\nconst unsigned int tot_channels = mci->num_cschannel;\r\nconst unsigned int tot_csrows = mci->nr_csrows;\r\nif (mci->dimms) {\r\nfor (i = 0; i < tot_dimms; i++)\r\nkfree(mci->dimms[i]);\r\nkfree(mci->dimms);\r\n}\r\nif (mci->csrows) {\r\nfor (row = 0; row < tot_csrows; row++) {\r\ncsr = mci->csrows[row];\r\nif (csr) {\r\nif (csr->channels) {\r\nfor (chn = 0; chn < tot_channels; chn++)\r\nkfree(csr->channels[chn]);\r\nkfree(csr->channels);\r\n}\r\nkfree(csr);\r\n}\r\n}\r\nkfree(mci->csrows);\r\n}\r\nkfree(mci);\r\n}\r\nstruct mem_ctl_info *edac_mc_alloc(unsigned mc_num,\r\nunsigned n_layers,\r\nstruct edac_mc_layer *layers,\r\nunsigned sz_pvt)\r\n{\r\nstruct mem_ctl_info *mci;\r\nstruct edac_mc_layer *layer;\r\nstruct csrow_info *csr;\r\nstruct rank_info *chan;\r\nstruct dimm_info *dimm;\r\nu32 *ce_per_layer[EDAC_MAX_LAYERS], *ue_per_layer[EDAC_MAX_LAYERS];\r\nunsigned pos[EDAC_MAX_LAYERS];\r\nunsigned size, tot_dimms = 1, count = 1;\r\nunsigned tot_csrows = 1, tot_channels = 1, tot_errcount = 0;\r\nvoid *pvt, *p, *ptr = NULL;\r\nint i, j, row, chn, n, len, off;\r\nbool per_rank = false;\r\nBUG_ON(n_layers > EDAC_MAX_LAYERS || n_layers == 0);\r\nfor (i = 0; i < n_layers; i++) {\r\ntot_dimms *= layers[i].size;\r\nif (layers[i].is_virt_csrow)\r\ntot_csrows *= layers[i].size;\r\nelse\r\ntot_channels *= layers[i].size;\r\nif (layers[i].type == EDAC_MC_LAYER_CHIP_SELECT)\r\nper_rank = true;\r\n}\r\nmci = edac_align_ptr(&ptr, sizeof(*mci), 1);\r\nlayer = edac_align_ptr(&ptr, sizeof(*layer), n_layers);\r\nfor (i = 0; i < n_layers; i++) {\r\ncount *= layers[i].size;\r\nedac_dbg(4, "errcount layer %d size %d\n", i, count);\r\nce_per_layer[i] = edac_align_ptr(&ptr, sizeof(u32), count);\r\nue_per_layer[i] = edac_align_ptr(&ptr, sizeof(u32), count);\r\ntot_errcount += 2 * count;\r\n}\r\nedac_dbg(4, "allocating %d error counters\n", tot_errcount);\r\npvt = edac_align_ptr(&ptr, sz_pvt, 1);\r\nsize = ((unsigned long)pvt) + sz_pvt;\r\nedac_dbg(1, "allocating %u bytes for mci data (%d %s, %d csrows/channels)\n",\r\nsize,\r\ntot_dimms,\r\nper_rank ? "ranks" : "dimms",\r\ntot_csrows * tot_channels);\r\nmci = kzalloc(size, GFP_KERNEL);\r\nif (mci == NULL)\r\nreturn NULL;\r\nlayer = (struct edac_mc_layer *)(((char *)mci) + ((unsigned long)layer));\r\nfor (i = 0; i < n_layers; i++) {\r\nmci->ce_per_layer[i] = (u32 *)((char *)mci + ((unsigned long)ce_per_layer[i]));\r\nmci->ue_per_layer[i] = (u32 *)((char *)mci + ((unsigned long)ue_per_layer[i]));\r\n}\r\npvt = sz_pvt ? (((char *)mci) + ((unsigned long)pvt)) : NULL;\r\nmci->mc_idx = mc_num;\r\nmci->tot_dimms = tot_dimms;\r\nmci->pvt_info = pvt;\r\nmci->n_layers = n_layers;\r\nmci->layers = layer;\r\nmemcpy(mci->layers, layers, sizeof(*layer) * n_layers);\r\nmci->nr_csrows = tot_csrows;\r\nmci->num_cschannel = tot_channels;\r\nmci->csbased = per_rank;\r\nmci->csrows = kcalloc(tot_csrows, sizeof(*mci->csrows), GFP_KERNEL);\r\nif (!mci->csrows)\r\ngoto error;\r\nfor (row = 0; row < tot_csrows; row++) {\r\ncsr = kzalloc(sizeof(**mci->csrows), GFP_KERNEL);\r\nif (!csr)\r\ngoto error;\r\nmci->csrows[row] = csr;\r\ncsr->csrow_idx = row;\r\ncsr->mci = mci;\r\ncsr->nr_channels = tot_channels;\r\ncsr->channels = kcalloc(tot_channels, sizeof(*csr->channels),\r\nGFP_KERNEL);\r\nif (!csr->channels)\r\ngoto error;\r\nfor (chn = 0; chn < tot_channels; chn++) {\r\nchan = kzalloc(sizeof(**csr->channels), GFP_KERNEL);\r\nif (!chan)\r\ngoto error;\r\ncsr->channels[chn] = chan;\r\nchan->chan_idx = chn;\r\nchan->csrow = csr;\r\n}\r\n}\r\nmci->dimms = kcalloc(tot_dimms, sizeof(*mci->dimms), GFP_KERNEL);\r\nif (!mci->dimms)\r\ngoto error;\r\nmemset(&pos, 0, sizeof(pos));\r\nrow = 0;\r\nchn = 0;\r\nfor (i = 0; i < tot_dimms; i++) {\r\nchan = mci->csrows[row]->channels[chn];\r\noff = EDAC_DIMM_OFF(layer, n_layers, pos[0], pos[1], pos[2]);\r\nif (off < 0 || off >= tot_dimms) {\r\nedac_mc_printk(mci, KERN_ERR, "EDAC core bug: EDAC_DIMM_OFF is trying to do an illegal data access\n");\r\ngoto error;\r\n}\r\ndimm = kzalloc(sizeof(**mci->dimms), GFP_KERNEL);\r\nif (!dimm)\r\ngoto error;\r\nmci->dimms[off] = dimm;\r\ndimm->mci = mci;\r\nlen = sizeof(dimm->label);\r\np = dimm->label;\r\nn = snprintf(p, len, "mc#%u", mc_num);\r\np += n;\r\nlen -= n;\r\nfor (j = 0; j < n_layers; j++) {\r\nn = snprintf(p, len, "%s#%u",\r\nedac_layer_name[layers[j].type],\r\npos[j]);\r\np += n;\r\nlen -= n;\r\ndimm->location[j] = pos[j];\r\nif (len <= 0)\r\nbreak;\r\n}\r\nchan->dimm = dimm;\r\ndimm->csrow = row;\r\ndimm->cschannel = chn;\r\nif (layers[0].is_virt_csrow) {\r\nchn++;\r\nif (chn == tot_channels) {\r\nchn = 0;\r\nrow++;\r\n}\r\n} else {\r\nrow++;\r\nif (row == tot_csrows) {\r\nrow = 0;\r\nchn++;\r\n}\r\n}\r\nfor (j = n_layers - 1; j >= 0; j--) {\r\npos[j]++;\r\nif (pos[j] < layers[j].size)\r\nbreak;\r\npos[j] = 0;\r\n}\r\n}\r\nmci->op_state = OP_ALLOC;\r\nreturn mci;\r\nerror:\r\n_edac_mc_free(mci);\r\nreturn NULL;\r\n}\r\nvoid edac_mc_free(struct mem_ctl_info *mci)\r\n{\r\nedac_dbg(1, "\n");\r\nif (!device_is_registered(&mci->dev)) {\r\n_edac_mc_free(mci);\r\nreturn;\r\n}\r\nedac_unregister_sysfs(mci);\r\n}\r\nbool edac_has_mcs(void)\r\n{\r\nbool ret;\r\nmutex_lock(&mem_ctls_mutex);\r\nret = list_empty(&mc_devices);\r\nmutex_unlock(&mem_ctls_mutex);\r\nreturn !ret;\r\n}\r\nstatic struct mem_ctl_info *__find_mci_by_dev(struct device *dev)\r\n{\r\nstruct mem_ctl_info *mci;\r\nstruct list_head *item;\r\nedac_dbg(3, "\n");\r\nlist_for_each(item, &mc_devices) {\r\nmci = list_entry(item, struct mem_ctl_info, link);\r\nif (mci->pdev == dev)\r\nreturn mci;\r\n}\r\nreturn NULL;\r\n}\r\nstruct mem_ctl_info *find_mci_by_dev(struct device *dev)\r\n{\r\nstruct mem_ctl_info *ret;\r\nmutex_lock(&mem_ctls_mutex);\r\nret = __find_mci_by_dev(dev);\r\nmutex_unlock(&mem_ctls_mutex);\r\nreturn ret;\r\n}\r\nstatic void edac_mc_workq_function(struct work_struct *work_req)\r\n{\r\nstruct delayed_work *d_work = to_delayed_work(work_req);\r\nstruct mem_ctl_info *mci = to_edac_mem_ctl_work(d_work);\r\nmutex_lock(&mem_ctls_mutex);\r\nif (mci->op_state != OP_RUNNING_POLL) {\r\nmutex_unlock(&mem_ctls_mutex);\r\nreturn;\r\n}\r\nif (edac_op_state == EDAC_OPSTATE_POLL)\r\nmci->edac_check(mci);\r\nmutex_unlock(&mem_ctls_mutex);\r\nedac_queue_work(&mci->work, msecs_to_jiffies(edac_mc_get_poll_msec()));\r\n}\r\nvoid edac_mc_reset_delay_period(unsigned long value)\r\n{\r\nstruct mem_ctl_info *mci;\r\nstruct list_head *item;\r\nmutex_lock(&mem_ctls_mutex);\r\nlist_for_each(item, &mc_devices) {\r\nmci = list_entry(item, struct mem_ctl_info, link);\r\nif (mci->op_state == OP_RUNNING_POLL)\r\nedac_mod_work(&mci->work, value);\r\n}\r\nmutex_unlock(&mem_ctls_mutex);\r\n}\r\nstatic int add_mc_to_global_list(struct mem_ctl_info *mci)\r\n{\r\nstruct list_head *item, *insert_before;\r\nstruct mem_ctl_info *p;\r\ninsert_before = &mc_devices;\r\np = __find_mci_by_dev(mci->pdev);\r\nif (unlikely(p != NULL))\r\ngoto fail0;\r\nlist_for_each(item, &mc_devices) {\r\np = list_entry(item, struct mem_ctl_info, link);\r\nif (p->mc_idx >= mci->mc_idx) {\r\nif (unlikely(p->mc_idx == mci->mc_idx))\r\ngoto fail1;\r\ninsert_before = item;\r\nbreak;\r\n}\r\n}\r\nlist_add_tail_rcu(&mci->link, insert_before);\r\nreturn 0;\r\nfail0:\r\nedac_printk(KERN_WARNING, EDAC_MC,\r\n"%s (%s) %s %s already assigned %d\n", dev_name(p->pdev),\r\nedac_dev_name(mci), p->mod_name, p->ctl_name, p->mc_idx);\r\nreturn 1;\r\nfail1:\r\nedac_printk(KERN_WARNING, EDAC_MC,\r\n"bug in low-level driver: attempt to assign\n"\r\n" duplicate mc_idx %d in %s()\n", p->mc_idx, __func__);\r\nreturn 1;\r\n}\r\nstatic int del_mc_from_global_list(struct mem_ctl_info *mci)\r\n{\r\nlist_del_rcu(&mci->link);\r\nsynchronize_rcu();\r\nINIT_LIST_HEAD(&mci->link);\r\nreturn list_empty(&mc_devices);\r\n}\r\nstruct mem_ctl_info *edac_mc_find(int idx)\r\n{\r\nstruct mem_ctl_info *mci = NULL;\r\nstruct list_head *item;\r\nmutex_lock(&mem_ctls_mutex);\r\nlist_for_each(item, &mc_devices) {\r\nmci = list_entry(item, struct mem_ctl_info, link);\r\nif (mci->mc_idx >= idx) {\r\nif (mci->mc_idx == idx) {\r\ngoto unlock;\r\n}\r\nbreak;\r\n}\r\n}\r\nunlock:\r\nmutex_unlock(&mem_ctls_mutex);\r\nreturn mci;\r\n}\r\nint edac_mc_add_mc_with_groups(struct mem_ctl_info *mci,\r\nconst struct attribute_group **groups)\r\n{\r\nint ret = -EINVAL;\r\nedac_dbg(0, "\n");\r\nif (mci->mc_idx >= EDAC_MAX_MCS) {\r\npr_warn_once("Too many memory controllers: %d\n", mci->mc_idx);\r\nreturn -ENODEV;\r\n}\r\n#ifdef CONFIG_EDAC_DEBUG\r\nif (edac_debug_level >= 3)\r\nedac_mc_dump_mci(mci);\r\nif (edac_debug_level >= 4) {\r\nint i;\r\nfor (i = 0; i < mci->nr_csrows; i++) {\r\nstruct csrow_info *csrow = mci->csrows[i];\r\nu32 nr_pages = 0;\r\nint j;\r\nfor (j = 0; j < csrow->nr_channels; j++)\r\nnr_pages += csrow->channels[j]->dimm->nr_pages;\r\nif (!nr_pages)\r\ncontinue;\r\nedac_mc_dump_csrow(csrow);\r\nfor (j = 0; j < csrow->nr_channels; j++)\r\nif (csrow->channels[j]->dimm->nr_pages)\r\nedac_mc_dump_channel(csrow->channels[j]);\r\n}\r\nfor (i = 0; i < mci->tot_dimms; i++)\r\nif (mci->dimms[i]->nr_pages)\r\nedac_mc_dump_dimm(mci->dimms[i], i);\r\n}\r\n#endif\r\nmutex_lock(&mem_ctls_mutex);\r\nif (edac_mc_owner && edac_mc_owner != mci->mod_name) {\r\nret = -EPERM;\r\ngoto fail0;\r\n}\r\nif (add_mc_to_global_list(mci))\r\ngoto fail0;\r\nmci->start_time = jiffies;\r\nmci->bus = &mc_bus[mci->mc_idx];\r\nif (edac_create_sysfs_mci_device(mci, groups)) {\r\nedac_mc_printk(mci, KERN_WARNING,\r\n"failed to create sysfs device\n");\r\ngoto fail1;\r\n}\r\nif (mci->edac_check) {\r\nmci->op_state = OP_RUNNING_POLL;\r\nINIT_DELAYED_WORK(&mci->work, edac_mc_workq_function);\r\nedac_queue_work(&mci->work, msecs_to_jiffies(edac_mc_get_poll_msec()));\r\n} else {\r\nmci->op_state = OP_RUNNING_INTERRUPT;\r\n}\r\nedac_mc_printk(mci, KERN_INFO,\r\n"Giving out device to module %s controller %s: DEV %s (%s)\n",\r\nmci->mod_name, mci->ctl_name, mci->dev_name,\r\nedac_op_state_to_string(mci->op_state));\r\nedac_mc_owner = mci->mod_name;\r\nmutex_unlock(&mem_ctls_mutex);\r\nreturn 0;\r\nfail1:\r\ndel_mc_from_global_list(mci);\r\nfail0:\r\nmutex_unlock(&mem_ctls_mutex);\r\nreturn ret;\r\n}\r\nstruct mem_ctl_info *edac_mc_del_mc(struct device *dev)\r\n{\r\nstruct mem_ctl_info *mci;\r\nedac_dbg(0, "\n");\r\nmutex_lock(&mem_ctls_mutex);\r\nmci = __find_mci_by_dev(dev);\r\nif (mci == NULL) {\r\nmutex_unlock(&mem_ctls_mutex);\r\nreturn NULL;\r\n}\r\nmci->op_state = OP_OFFLINE;\r\nif (del_mc_from_global_list(mci))\r\nedac_mc_owner = NULL;\r\nmutex_unlock(&mem_ctls_mutex);\r\nif (mci->edac_check)\r\nedac_stop_work(&mci->work);\r\nedac_remove_sysfs_mci_device(mci);\r\nedac_printk(KERN_INFO, EDAC_MC,\r\n"Removed device %d for %s %s: DEV %s\n", mci->mc_idx,\r\nmci->mod_name, mci->ctl_name, edac_dev_name(mci));\r\nreturn mci;\r\n}\r\nstatic void edac_mc_scrub_block(unsigned long page, unsigned long offset,\r\nu32 size)\r\n{\r\nstruct page *pg;\r\nvoid *virt_addr;\r\nunsigned long flags = 0;\r\nedac_dbg(3, "\n");\r\nif (!pfn_valid(page))\r\nreturn;\r\npg = pfn_to_page(page);\r\nif (PageHighMem(pg))\r\nlocal_irq_save(flags);\r\nvirt_addr = kmap_atomic(pg);\r\nedac_atomic_scrub(virt_addr + offset, size);\r\nkunmap_atomic(virt_addr);\r\nif (PageHighMem(pg))\r\nlocal_irq_restore(flags);\r\n}\r\nint edac_mc_find_csrow_by_page(struct mem_ctl_info *mci, unsigned long page)\r\n{\r\nstruct csrow_info **csrows = mci->csrows;\r\nint row, i, j, n;\r\nedac_dbg(1, "MC%d: 0x%lx\n", mci->mc_idx, page);\r\nrow = -1;\r\nfor (i = 0; i < mci->nr_csrows; i++) {\r\nstruct csrow_info *csrow = csrows[i];\r\nn = 0;\r\nfor (j = 0; j < csrow->nr_channels; j++) {\r\nstruct dimm_info *dimm = csrow->channels[j]->dimm;\r\nn += dimm->nr_pages;\r\n}\r\nif (n == 0)\r\ncontinue;\r\nedac_dbg(3, "MC%d: first(0x%lx) page(0x%lx) last(0x%lx) mask(0x%lx)\n",\r\nmci->mc_idx,\r\ncsrow->first_page, page, csrow->last_page,\r\ncsrow->page_mask);\r\nif ((page >= csrow->first_page) &&\r\n(page <= csrow->last_page) &&\r\n((page & csrow->page_mask) ==\r\n(csrow->first_page & csrow->page_mask))) {\r\nrow = i;\r\nbreak;\r\n}\r\n}\r\nif (row == -1)\r\nedac_mc_printk(mci, KERN_ERR,\r\n"could not look up page error address %lx\n",\r\n(unsigned long)page);\r\nreturn row;\r\n}\r\nstatic void edac_inc_ce_error(struct mem_ctl_info *mci,\r\nbool enable_per_layer_report,\r\nconst int pos[EDAC_MAX_LAYERS],\r\nconst u16 count)\r\n{\r\nint i, index = 0;\r\nmci->ce_mc += count;\r\nif (!enable_per_layer_report) {\r\nmci->ce_noinfo_count += count;\r\nreturn;\r\n}\r\nfor (i = 0; i < mci->n_layers; i++) {\r\nif (pos[i] < 0)\r\nbreak;\r\nindex += pos[i];\r\nmci->ce_per_layer[i][index] += count;\r\nif (i < mci->n_layers - 1)\r\nindex *= mci->layers[i + 1].size;\r\n}\r\n}\r\nstatic void edac_inc_ue_error(struct mem_ctl_info *mci,\r\nbool enable_per_layer_report,\r\nconst int pos[EDAC_MAX_LAYERS],\r\nconst u16 count)\r\n{\r\nint i, index = 0;\r\nmci->ue_mc += count;\r\nif (!enable_per_layer_report) {\r\nmci->ue_noinfo_count += count;\r\nreturn;\r\n}\r\nfor (i = 0; i < mci->n_layers; i++) {\r\nif (pos[i] < 0)\r\nbreak;\r\nindex += pos[i];\r\nmci->ue_per_layer[i][index] += count;\r\nif (i < mci->n_layers - 1)\r\nindex *= mci->layers[i + 1].size;\r\n}\r\n}\r\nstatic void edac_ce_error(struct mem_ctl_info *mci,\r\nconst u16 error_count,\r\nconst int pos[EDAC_MAX_LAYERS],\r\nconst char *msg,\r\nconst char *location,\r\nconst char *label,\r\nconst char *detail,\r\nconst char *other_detail,\r\nconst bool enable_per_layer_report,\r\nconst unsigned long page_frame_number,\r\nconst unsigned long offset_in_page,\r\nlong grain)\r\n{\r\nunsigned long remapped_page;\r\nchar *msg_aux = "";\r\nif (*msg)\r\nmsg_aux = " ";\r\nif (edac_mc_get_log_ce()) {\r\nif (other_detail && *other_detail)\r\nedac_mc_printk(mci, KERN_WARNING,\r\n"%d CE %s%son %s (%s %s - %s)\n",\r\nerror_count, msg, msg_aux, label,\r\nlocation, detail, other_detail);\r\nelse\r\nedac_mc_printk(mci, KERN_WARNING,\r\n"%d CE %s%son %s (%s %s)\n",\r\nerror_count, msg, msg_aux, label,\r\nlocation, detail);\r\n}\r\nedac_inc_ce_error(mci, enable_per_layer_report, pos, error_count);\r\nif (mci->scrub_mode == SCRUB_SW_SRC) {\r\nremapped_page = mci->ctl_page_to_phys ?\r\nmci->ctl_page_to_phys(mci, page_frame_number) :\r\npage_frame_number;\r\nedac_mc_scrub_block(remapped_page,\r\noffset_in_page, grain);\r\n}\r\n}\r\nstatic void edac_ue_error(struct mem_ctl_info *mci,\r\nconst u16 error_count,\r\nconst int pos[EDAC_MAX_LAYERS],\r\nconst char *msg,\r\nconst char *location,\r\nconst char *label,\r\nconst char *detail,\r\nconst char *other_detail,\r\nconst bool enable_per_layer_report)\r\n{\r\nchar *msg_aux = "";\r\nif (*msg)\r\nmsg_aux = " ";\r\nif (edac_mc_get_log_ue()) {\r\nif (other_detail && *other_detail)\r\nedac_mc_printk(mci, KERN_WARNING,\r\n"%d UE %s%son %s (%s %s - %s)\n",\r\nerror_count, msg, msg_aux, label,\r\nlocation, detail, other_detail);\r\nelse\r\nedac_mc_printk(mci, KERN_WARNING,\r\n"%d UE %s%son %s (%s %s)\n",\r\nerror_count, msg, msg_aux, label,\r\nlocation, detail);\r\n}\r\nif (edac_mc_get_panic_on_ue()) {\r\nif (other_detail && *other_detail)\r\npanic("UE %s%son %s (%s%s - %s)\n",\r\nmsg, msg_aux, label, location, detail, other_detail);\r\nelse\r\npanic("UE %s%son %s (%s%s)\n",\r\nmsg, msg_aux, label, location, detail);\r\n}\r\nedac_inc_ue_error(mci, enable_per_layer_report, pos, error_count);\r\n}\r\nvoid edac_raw_mc_handle_error(const enum hw_event_mc_err_type type,\r\nstruct mem_ctl_info *mci,\r\nstruct edac_raw_error_desc *e)\r\n{\r\nchar detail[80];\r\nint pos[EDAC_MAX_LAYERS] = { e->top_layer, e->mid_layer, e->low_layer };\r\nif (type == HW_EVENT_ERR_CORRECTED) {\r\nsnprintf(detail, sizeof(detail),\r\n"page:0x%lx offset:0x%lx grain:%ld syndrome:0x%lx",\r\ne->page_frame_number, e->offset_in_page,\r\ne->grain, e->syndrome);\r\nedac_ce_error(mci, e->error_count, pos, e->msg, e->location, e->label,\r\ndetail, e->other_detail, e->enable_per_layer_report,\r\ne->page_frame_number, e->offset_in_page, e->grain);\r\n} else {\r\nsnprintf(detail, sizeof(detail),\r\n"page:0x%lx offset:0x%lx grain:%ld",\r\ne->page_frame_number, e->offset_in_page, e->grain);\r\nedac_ue_error(mci, e->error_count, pos, e->msg, e->location, e->label,\r\ndetail, e->other_detail, e->enable_per_layer_report);\r\n}\r\n}\r\nvoid edac_mc_handle_error(const enum hw_event_mc_err_type type,\r\nstruct mem_ctl_info *mci,\r\nconst u16 error_count,\r\nconst unsigned long page_frame_number,\r\nconst unsigned long offset_in_page,\r\nconst unsigned long syndrome,\r\nconst int top_layer,\r\nconst int mid_layer,\r\nconst int low_layer,\r\nconst char *msg,\r\nconst char *other_detail)\r\n{\r\nchar *p;\r\nint row = -1, chan = -1;\r\nint pos[EDAC_MAX_LAYERS] = { top_layer, mid_layer, low_layer };\r\nint i, n_labels = 0;\r\nu8 grain_bits;\r\nstruct edac_raw_error_desc *e = &mci->error_desc;\r\nedac_dbg(3, "MC%d\n", mci->mc_idx);\r\nmemset(e, 0, sizeof (*e));\r\ne->error_count = error_count;\r\ne->top_layer = top_layer;\r\ne->mid_layer = mid_layer;\r\ne->low_layer = low_layer;\r\ne->page_frame_number = page_frame_number;\r\ne->offset_in_page = offset_in_page;\r\ne->syndrome = syndrome;\r\ne->msg = msg;\r\ne->other_detail = other_detail;\r\nfor (i = 0; i < mci->n_layers; i++) {\r\nif (pos[i] >= (int)mci->layers[i].size) {\r\nedac_mc_printk(mci, KERN_ERR,\r\n"INTERNAL ERROR: %s value is out of range (%d >= %d)\n",\r\nedac_layer_name[mci->layers[i].type],\r\npos[i], mci->layers[i].size);\r\npos[i] = -1;\r\n}\r\nif (pos[i] >= 0)\r\ne->enable_per_layer_report = true;\r\n}\r\np = e->label;\r\n*p = '\0';\r\nfor (i = 0; i < mci->tot_dimms; i++) {\r\nstruct dimm_info *dimm = mci->dimms[i];\r\nif (top_layer >= 0 && top_layer != dimm->location[0])\r\ncontinue;\r\nif (mid_layer >= 0 && mid_layer != dimm->location[1])\r\ncontinue;\r\nif (low_layer >= 0 && low_layer != dimm->location[2])\r\ncontinue;\r\nif (dimm->grain > e->grain)\r\ne->grain = dimm->grain;\r\nif (e->enable_per_layer_report && dimm->nr_pages) {\r\nif (n_labels >= EDAC_MAX_LABELS) {\r\ne->enable_per_layer_report = false;\r\nbreak;\r\n}\r\nn_labels++;\r\nif (p != e->label) {\r\nstrcpy(p, OTHER_LABEL);\r\np += strlen(OTHER_LABEL);\r\n}\r\nstrcpy(p, dimm->label);\r\np += strlen(p);\r\n*p = '\0';\r\nedac_dbg(4, "%s csrows map: (%d,%d)\n",\r\nmci->csbased ? "rank" : "dimm",\r\ndimm->csrow, dimm->cschannel);\r\nif (row == -1)\r\nrow = dimm->csrow;\r\nelse if (row >= 0 && row != dimm->csrow)\r\nrow = -2;\r\nif (chan == -1)\r\nchan = dimm->cschannel;\r\nelse if (chan >= 0 && chan != dimm->cschannel)\r\nchan = -2;\r\n}\r\n}\r\nif (!e->enable_per_layer_report) {\r\nstrcpy(e->label, "any memory");\r\n} else {\r\nedac_dbg(4, "csrow/channel to increment: (%d,%d)\n", row, chan);\r\nif (p == e->label)\r\nstrcpy(e->label, "unknown memory");\r\nif (type == HW_EVENT_ERR_CORRECTED) {\r\nif (row >= 0) {\r\nmci->csrows[row]->ce_count += error_count;\r\nif (chan >= 0)\r\nmci->csrows[row]->channels[chan]->ce_count += error_count;\r\n}\r\n} else\r\nif (row >= 0)\r\nmci->csrows[row]->ue_count += error_count;\r\n}\r\np = e->location;\r\nfor (i = 0; i < mci->n_layers; i++) {\r\nif (pos[i] < 0)\r\ncontinue;\r\np += sprintf(p, "%s:%d ",\r\nedac_layer_name[mci->layers[i].type],\r\npos[i]);\r\n}\r\nif (p > e->location)\r\n*(p - 1) = '\0';\r\ngrain_bits = fls_long(e->grain) + 1;\r\nif (IS_ENABLED(CONFIG_RAS))\r\ntrace_mc_event(type, e->msg, e->label, e->error_count,\r\nmci->mc_idx, e->top_layer, e->mid_layer,\r\ne->low_layer,\r\n(e->page_frame_number << PAGE_SHIFT) | e->offset_in_page,\r\ngrain_bits, e->syndrome, e->other_detail);\r\nedac_raw_mc_handle_error(type, mci, e);\r\n}
