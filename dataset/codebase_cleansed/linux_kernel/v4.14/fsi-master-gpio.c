static void clock_toggle(struct fsi_master_gpio *master, int count)\r\n{\r\nint i;\r\nfor (i = 0; i < count; i++) {\r\nndelay(FSI_GPIO_STD_DLY);\r\ngpiod_set_value(master->gpio_clk, 0);\r\nndelay(FSI_GPIO_STD_DLY);\r\ngpiod_set_value(master->gpio_clk, 1);\r\n}\r\n}\r\nstatic int sda_in(struct fsi_master_gpio *master)\r\n{\r\nint in;\r\nndelay(FSI_GPIO_STD_DLY);\r\nin = gpiod_get_value(master->gpio_data);\r\nreturn in ? 1 : 0;\r\n}\r\nstatic void sda_out(struct fsi_master_gpio *master, int value)\r\n{\r\ngpiod_set_value(master->gpio_data, value);\r\n}\r\nstatic void set_sda_input(struct fsi_master_gpio *master)\r\n{\r\ngpiod_direction_input(master->gpio_data);\r\ngpiod_set_value(master->gpio_trans, 0);\r\n}\r\nstatic void set_sda_output(struct fsi_master_gpio *master, int value)\r\n{\r\ngpiod_set_value(master->gpio_trans, 1);\r\ngpiod_direction_output(master->gpio_data, value);\r\n}\r\nstatic void clock_zeros(struct fsi_master_gpio *master, int count)\r\n{\r\nset_sda_output(master, 1);\r\nclock_toggle(master, count);\r\n}\r\nstatic void serial_in(struct fsi_master_gpio *master, struct fsi_gpio_msg *msg,\r\nuint8_t num_bits)\r\n{\r\nuint8_t bit, in_bit;\r\nset_sda_input(master);\r\nfor (bit = 0; bit < num_bits; bit++) {\r\nclock_toggle(master, 1);\r\nin_bit = sda_in(master);\r\nmsg->msg <<= 1;\r\nmsg->msg |= ~in_bit & 0x1;\r\n}\r\nmsg->bits += num_bits;\r\ntrace_fsi_master_gpio_in(master, num_bits, msg->msg);\r\n}\r\nstatic void serial_out(struct fsi_master_gpio *master,\r\nconst struct fsi_gpio_msg *cmd)\r\n{\r\nuint8_t bit;\r\nuint64_t msg = ~cmd->msg;\r\nuint64_t sda_mask = 0x1ULL << (cmd->bits - 1);\r\nuint64_t last_bit = ~0;\r\nint next_bit;\r\ntrace_fsi_master_gpio_out(master, cmd->bits, cmd->msg);\r\nif (!cmd->bits) {\r\ndev_warn(master->dev, "trying to output 0 bits\n");\r\nreturn;\r\n}\r\nset_sda_output(master, 0);\r\nsda_out(master, 0);\r\nclock_toggle(master, 1);\r\nfor (bit = 0; bit < cmd->bits; bit++) {\r\nnext_bit = (msg & sda_mask) >> (cmd->bits - 1);\r\nif (last_bit ^ next_bit) {\r\nsda_out(master, next_bit);\r\nlast_bit = next_bit;\r\n}\r\nclock_toggle(master, 1);\r\nmsg <<= 1;\r\n}\r\n}\r\nstatic void msg_push_bits(struct fsi_gpio_msg *msg, uint64_t data, int bits)\r\n{\r\nmsg->msg <<= bits;\r\nmsg->msg |= data & ((1ull << bits) - 1);\r\nmsg->bits += bits;\r\n}\r\nstatic void msg_push_crc(struct fsi_gpio_msg *msg)\r\n{\r\nuint8_t crc;\r\nint top;\r\ntop = msg->bits & 0x3;\r\ncrc = crc4(0, 1 << top | msg->msg >> (msg->bits - top), top + 1);\r\ncrc = crc4(crc, msg->msg, msg->bits - top);\r\nmsg_push_bits(msg, crc, 4);\r\n}\r\nstatic void build_abs_ar_command(struct fsi_gpio_msg *cmd,\r\nuint8_t id, uint32_t addr, size_t size, const void *data)\r\n{\r\nbool write = !!data;\r\nuint8_t ds;\r\nint i;\r\ncmd->bits = 0;\r\ncmd->msg = 0;\r\nmsg_push_bits(cmd, id, 2);\r\nmsg_push_bits(cmd, FSI_GPIO_CMD_ABS_AR, 3);\r\nmsg_push_bits(cmd, write ? 0 : 1, 1);\r\nds = size > 1 ? 1 : 0;\r\naddr &= ~(size - 1);\r\nif (size == 4)\r\naddr |= 1;\r\nmsg_push_bits(cmd, addr & ((1 << 21) - 1), 21);\r\nmsg_push_bits(cmd, ds, 1);\r\nfor (i = 0; write && i < size; i++)\r\nmsg_push_bits(cmd, ((uint8_t *)data)[i], 8);\r\nmsg_push_crc(cmd);\r\n}\r\nstatic void build_dpoll_command(struct fsi_gpio_msg *cmd, uint8_t slave_id)\r\n{\r\ncmd->bits = 0;\r\ncmd->msg = 0;\r\nmsg_push_bits(cmd, slave_id, 2);\r\nmsg_push_bits(cmd, FSI_GPIO_CMD_DPOLL, 3);\r\nmsg_push_crc(cmd);\r\n}\r\nstatic void echo_delay(struct fsi_master_gpio *master)\r\n{\r\nset_sda_output(master, 1);\r\nclock_toggle(master, FSI_ECHO_DELAY_CLOCKS);\r\n}\r\nstatic void build_term_command(struct fsi_gpio_msg *cmd, uint8_t slave_id)\r\n{\r\ncmd->bits = 0;\r\ncmd->msg = 0;\r\nmsg_push_bits(cmd, slave_id, 2);\r\nmsg_push_bits(cmd, FSI_GPIO_CMD_TERM, 6);\r\nmsg_push_crc(cmd);\r\n}\r\nstatic void fsi_master_gpio_error(struct fsi_master_gpio *master, int error)\r\n{\r\n}\r\nstatic int read_one_response(struct fsi_master_gpio *master,\r\nuint8_t data_size, struct fsi_gpio_msg *msgp, uint8_t *tagp)\r\n{\r\nstruct fsi_gpio_msg msg;\r\nuint8_t id, tag;\r\nuint32_t crc;\r\nint i;\r\nfor (i = 0; i < FSI_GPIO_MTOE_COUNT; i++) {\r\nmsg.bits = 0;\r\nmsg.msg = 0;\r\nserial_in(master, &msg, 1);\r\nif (msg.msg)\r\nbreak;\r\n}\r\nif (i == FSI_GPIO_MTOE_COUNT) {\r\ndev_dbg(master->dev,\r\n"Master time out waiting for response\n");\r\nfsi_master_gpio_error(master, FSI_GPIO_MTOE);\r\nreturn -EIO;\r\n}\r\nmsg.bits = 0;\r\nmsg.msg = 0;\r\nserial_in(master, &msg, 4);\r\nid = (msg.msg >> FSI_GPIO_MSG_RESPID_SIZE) & 0x3;\r\ntag = msg.msg & 0x3;\r\nif (tag == FSI_GPIO_RESP_ACK && data_size)\r\nserial_in(master, &msg, data_size * 8);\r\nserial_in(master, &msg, FSI_GPIO_CRC_SIZE);\r\ncrc = crc4(0, 1, 1);\r\ncrc = crc4(crc, msg.msg, msg.bits);\r\nif (crc) {\r\ndev_dbg(master->dev, "ERR response CRC\n");\r\nfsi_master_gpio_error(master, FSI_GPIO_CRC_INVAL);\r\nreturn -EIO;\r\n}\r\nif (msgp)\r\n*msgp = msg;\r\nif (tagp)\r\n*tagp = tag;\r\nreturn 0;\r\n}\r\nstatic int issue_term(struct fsi_master_gpio *master, uint8_t slave)\r\n{\r\nstruct fsi_gpio_msg cmd;\r\nuint8_t tag;\r\nint rc;\r\nbuild_term_command(&cmd, slave);\r\nserial_out(master, &cmd);\r\necho_delay(master);\r\nrc = read_one_response(master, 0, NULL, &tag);\r\nif (rc < 0) {\r\ndev_err(master->dev,\r\n"TERM failed; lost communication with slave\n");\r\nreturn -EIO;\r\n} else if (tag != FSI_GPIO_RESP_ACK) {\r\ndev_err(master->dev, "TERM failed; response %d\n", tag);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int poll_for_response(struct fsi_master_gpio *master,\r\nuint8_t slave, uint8_t size, void *data)\r\n{\r\nstruct fsi_gpio_msg response, cmd;\r\nint busy_count = 0, rc, i;\r\nuint8_t tag;\r\nuint8_t *data_byte = data;\r\nretry:\r\nrc = read_one_response(master, size, &response, &tag);\r\nif (rc)\r\nreturn rc;\r\nswitch (tag) {\r\ncase FSI_GPIO_RESP_ACK:\r\nif (size && data) {\r\nuint64_t val = response.msg;\r\nval >>= 4;\r\nval &= (1ull << (size * 8)) - 1;\r\nfor (i = 0; i < size; i++) {\r\ndata_byte[size-i-1] = val;\r\nval >>= 8;\r\n}\r\n}\r\nbreak;\r\ncase FSI_GPIO_RESP_BUSY:\r\nclock_zeros(master, FSI_GPIO_DPOLL_CLOCKS);\r\nif (busy_count++ < FSI_GPIO_MAX_BUSY) {\r\nbuild_dpoll_command(&cmd, slave);\r\nserial_out(master, &cmd);\r\necho_delay(master);\r\ngoto retry;\r\n}\r\ndev_warn(master->dev,\r\n"ERR slave is stuck in busy state, issuing TERM\n");\r\nissue_term(master, slave);\r\nrc = -EIO;\r\nbreak;\r\ncase FSI_GPIO_RESP_ERRA:\r\ncase FSI_GPIO_RESP_ERRC:\r\ndev_dbg(master->dev, "ERR%c received: 0x%x\n",\r\ntag == FSI_GPIO_RESP_ERRA ? 'A' : 'C',\r\n(int)response.msg);\r\nfsi_master_gpio_error(master, response.msg);\r\nrc = -EIO;\r\nbreak;\r\n}\r\nclock_zeros(master, FSI_GPIO_PRIME_SLAVE_CLOCKS);\r\nreturn rc;\r\n}\r\nstatic int fsi_master_gpio_xfer(struct fsi_master_gpio *master, uint8_t slave,\r\nstruct fsi_gpio_msg *cmd, size_t resp_len, void *resp)\r\n{\r\nunsigned long flags;\r\nint rc;\r\nspin_lock_irqsave(&master->cmd_lock, flags);\r\nserial_out(master, cmd);\r\necho_delay(master);\r\nrc = poll_for_response(master, slave, resp_len, resp);\r\nspin_unlock_irqrestore(&master->cmd_lock, flags);\r\nreturn rc;\r\n}\r\nstatic int fsi_master_gpio_read(struct fsi_master *_master, int link,\r\nuint8_t id, uint32_t addr, void *val, size_t size)\r\n{\r\nstruct fsi_master_gpio *master = to_fsi_master_gpio(_master);\r\nstruct fsi_gpio_msg cmd;\r\nif (link != 0)\r\nreturn -ENODEV;\r\nbuild_abs_ar_command(&cmd, id, addr, size, NULL);\r\nreturn fsi_master_gpio_xfer(master, id, &cmd, size, val);\r\n}\r\nstatic int fsi_master_gpio_write(struct fsi_master *_master, int link,\r\nuint8_t id, uint32_t addr, const void *val, size_t size)\r\n{\r\nstruct fsi_master_gpio *master = to_fsi_master_gpio(_master);\r\nstruct fsi_gpio_msg cmd;\r\nif (link != 0)\r\nreturn -ENODEV;\r\nbuild_abs_ar_command(&cmd, id, addr, size, val);\r\nreturn fsi_master_gpio_xfer(master, id, &cmd, 0, NULL);\r\n}\r\nstatic int fsi_master_gpio_term(struct fsi_master *_master,\r\nint link, uint8_t id)\r\n{\r\nstruct fsi_master_gpio *master = to_fsi_master_gpio(_master);\r\nstruct fsi_gpio_msg cmd;\r\nif (link != 0)\r\nreturn -ENODEV;\r\nbuild_term_command(&cmd, id);\r\nreturn fsi_master_gpio_xfer(master, id, &cmd, 0, NULL);\r\n}\r\nstatic int fsi_master_gpio_break(struct fsi_master *_master, int link)\r\n{\r\nstruct fsi_master_gpio *master = to_fsi_master_gpio(_master);\r\nif (link != 0)\r\nreturn -ENODEV;\r\ntrace_fsi_master_gpio_break(master);\r\nset_sda_output(master, 1);\r\nsda_out(master, 1);\r\nclock_toggle(master, FSI_PRE_BREAK_CLOCKS);\r\nsda_out(master, 0);\r\nclock_toggle(master, FSI_BREAK_CLOCKS);\r\necho_delay(master);\r\nsda_out(master, 1);\r\nclock_toggle(master, FSI_POST_BREAK_CLOCKS);\r\nudelay(200);\r\nreturn 0;\r\n}\r\nstatic void fsi_master_gpio_init(struct fsi_master_gpio *master)\r\n{\r\ngpiod_direction_output(master->gpio_mux, 1);\r\ngpiod_direction_output(master->gpio_trans, 1);\r\ngpiod_direction_output(master->gpio_enable, 1);\r\ngpiod_direction_output(master->gpio_clk, 1);\r\ngpiod_direction_output(master->gpio_data, 1);\r\nclock_zeros(master, FSI_INIT_CLOCKS);\r\n}\r\nstatic int fsi_master_gpio_link_enable(struct fsi_master *_master, int link)\r\n{\r\nstruct fsi_master_gpio *master = to_fsi_master_gpio(_master);\r\nif (link != 0)\r\nreturn -ENODEV;\r\ngpiod_set_value(master->gpio_enable, 1);\r\nreturn 0;\r\n}\r\nstatic int fsi_master_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct fsi_master_gpio *master;\r\nstruct gpio_desc *gpio;\r\nmaster = devm_kzalloc(&pdev->dev, sizeof(*master), GFP_KERNEL);\r\nif (!master)\r\nreturn -ENOMEM;\r\nmaster->dev = &pdev->dev;\r\nmaster->master.dev.parent = master->dev;\r\ngpio = devm_gpiod_get(&pdev->dev, "clock", 0);\r\nif (IS_ERR(gpio)) {\r\ndev_err(&pdev->dev, "failed to get clock gpio\n");\r\nreturn PTR_ERR(gpio);\r\n}\r\nmaster->gpio_clk = gpio;\r\ngpio = devm_gpiod_get(&pdev->dev, "data", 0);\r\nif (IS_ERR(gpio)) {\r\ndev_err(&pdev->dev, "failed to get data gpio\n");\r\nreturn PTR_ERR(gpio);\r\n}\r\nmaster->gpio_data = gpio;\r\ngpio = devm_gpiod_get_optional(&pdev->dev, "trans", 0);\r\nif (IS_ERR(gpio)) {\r\ndev_err(&pdev->dev, "failed to get trans gpio\n");\r\nreturn PTR_ERR(gpio);\r\n}\r\nmaster->gpio_trans = gpio;\r\ngpio = devm_gpiod_get_optional(&pdev->dev, "enable", 0);\r\nif (IS_ERR(gpio)) {\r\ndev_err(&pdev->dev, "failed to get enable gpio\n");\r\nreturn PTR_ERR(gpio);\r\n}\r\nmaster->gpio_enable = gpio;\r\ngpio = devm_gpiod_get_optional(&pdev->dev, "mux", 0);\r\nif (IS_ERR(gpio)) {\r\ndev_err(&pdev->dev, "failed to get mux gpio\n");\r\nreturn PTR_ERR(gpio);\r\n}\r\nmaster->gpio_mux = gpio;\r\nmaster->master.n_links = 1;\r\nmaster->master.flags = FSI_MASTER_FLAG_SWCLOCK;\r\nmaster->master.read = fsi_master_gpio_read;\r\nmaster->master.write = fsi_master_gpio_write;\r\nmaster->master.term = fsi_master_gpio_term;\r\nmaster->master.send_break = fsi_master_gpio_break;\r\nmaster->master.link_enable = fsi_master_gpio_link_enable;\r\nplatform_set_drvdata(pdev, master);\r\nspin_lock_init(&master->cmd_lock);\r\nfsi_master_gpio_init(master);\r\nreturn fsi_master_register(&master->master);\r\n}\r\nstatic int fsi_master_gpio_remove(struct platform_device *pdev)\r\n{\r\nstruct fsi_master_gpio *master = platform_get_drvdata(pdev);\r\ndevm_gpiod_put(&pdev->dev, master->gpio_clk);\r\ndevm_gpiod_put(&pdev->dev, master->gpio_data);\r\nif (master->gpio_trans)\r\ndevm_gpiod_put(&pdev->dev, master->gpio_trans);\r\nif (master->gpio_enable)\r\ndevm_gpiod_put(&pdev->dev, master->gpio_enable);\r\nif (master->gpio_mux)\r\ndevm_gpiod_put(&pdev->dev, master->gpio_mux);\r\nfsi_master_unregister(&master->master);\r\nreturn 0;\r\n}
