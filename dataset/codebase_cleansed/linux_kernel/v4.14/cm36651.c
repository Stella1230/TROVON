static int cm36651_setup_reg(struct cm36651_data *cm36651)\r\n{\r\nstruct i2c_client *client = cm36651->client;\r\nstruct i2c_client *ps_client = cm36651->ps_client;\r\nint i, ret;\r\ncm36651->cs_ctrl_regs[CM36651_CS_CONF1] = CM36651_ALS_ENABLE |\r\nCM36651_ALS_THRES;\r\ncm36651->cs_ctrl_regs[CM36651_CS_CONF2] = CM36651_CS_CONF2_DEFAULT_BIT;\r\nfor (i = 0; i < CM36651_CS_CONF_REG_NUM; i++) {\r\nret = i2c_smbus_write_byte_data(client, cm36651_cs_reg[i],\r\ncm36651->cs_ctrl_regs[i]);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\ncm36651->ps_ctrl_regs[CM36651_PS_CONF1] = CM36651_PS_ENABLE |\r\nCM36651_PS_IT2;\r\ncm36651->ps_ctrl_regs[CM36651_PS_THD] = CM36651_PS_INITIAL_THD;\r\ncm36651->ps_ctrl_regs[CM36651_PS_CANC] = CM36651_PS_CANC_DEFAULT;\r\ncm36651->ps_ctrl_regs[CM36651_PS_CONF2] = CM36651_PS_HYS2 |\r\nCM36651_PS_DIR_INT | CM36651_PS_SMART_PERS_EN;\r\nfor (i = 0; i < CM36651_PS_REG_NUM; i++) {\r\nret = i2c_smbus_write_byte_data(ps_client, cm36651_ps_reg[i],\r\ncm36651->ps_ctrl_regs[i]);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nret = i2c_smbus_write_byte_data(client, CM36651_CS_CONF1,\r\nCM36651_ALS_DISABLE);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_smbus_write_byte_data(cm36651->ps_client,\r\nCM36651_PS_CONF1, CM36651_PS_DISABLE);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int cm36651_read_output(struct cm36651_data *cm36651,\r\nstruct iio_chan_spec const *chan, int *val)\r\n{\r\nstruct i2c_client *client = cm36651->client;\r\nint ret = -EINVAL;\r\nswitch (chan->type) {\r\ncase IIO_LIGHT:\r\n*val = i2c_smbus_read_word_data(client, chan->address);\r\nif (*val < 0)\r\nreturn ret;\r\nret = i2c_smbus_write_byte_data(client, CM36651_CS_CONF1,\r\nCM36651_ALS_DISABLE);\r\nif (ret < 0)\r\nreturn ret;\r\nret = IIO_VAL_INT;\r\nbreak;\r\ncase IIO_PROXIMITY:\r\n*val = i2c_smbus_read_byte(cm36651->ps_client);\r\nif (*val < 0)\r\nreturn ret;\r\nif (!test_bit(CM36651_PROXIMITY_EV_EN, &cm36651->flags)) {\r\nret = i2c_smbus_write_byte_data(cm36651->ps_client,\r\nCM36651_PS_CONF1, CM36651_PS_DISABLE);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nret = IIO_VAL_INT;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic irqreturn_t cm36651_irq_handler(int irq, void *data)\r\n{\r\nstruct iio_dev *indio_dev = data;\r\nstruct cm36651_data *cm36651 = iio_priv(indio_dev);\r\nstruct i2c_client *client = cm36651->client;\r\nint ev_dir, ret;\r\nu64 ev_code;\r\nret = i2c_smbus_read_byte(cm36651->ara_client);\r\nif (ret < 0) {\r\ndev_err(&client->dev,\r\n"%s: Data read failed: %d\n", __func__, ret);\r\nreturn IRQ_HANDLED;\r\n}\r\nswitch (ret) {\r\ncase CM36651_CLOSE_PROXIMITY:\r\nev_dir = IIO_EV_DIR_RISING;\r\nbreak;\r\ncase CM36651_FAR_PROXIMITY:\r\nev_dir = IIO_EV_DIR_FALLING;\r\nbreak;\r\ndefault:\r\ndev_err(&client->dev,\r\n"%s: Data read wrong: %d\n", __func__, ret);\r\nreturn IRQ_HANDLED;\r\n}\r\nev_code = IIO_UNMOD_EVENT_CODE(IIO_PROXIMITY,\r\nCM36651_CMD_READ_RAW_PROXIMITY,\r\nIIO_EV_TYPE_THRESH, ev_dir);\r\niio_push_event(indio_dev, ev_code, iio_get_time_ns(indio_dev));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int cm36651_set_operation_mode(struct cm36651_data *cm36651, int cmd)\r\n{\r\nstruct i2c_client *client = cm36651->client;\r\nstruct i2c_client *ps_client = cm36651->ps_client;\r\nint ret = -EINVAL;\r\nswitch (cmd) {\r\ncase CM36651_CMD_READ_RAW_LIGHT:\r\nret = i2c_smbus_write_byte_data(client, CM36651_CS_CONF1,\r\ncm36651->cs_ctrl_regs[CM36651_CS_CONF1]);\r\nbreak;\r\ncase CM36651_CMD_READ_RAW_PROXIMITY:\r\nif (test_bit(CM36651_PROXIMITY_EV_EN, &cm36651->flags))\r\nreturn CM36651_PROXIMITY_EV_EN;\r\nret = i2c_smbus_write_byte_data(ps_client, CM36651_PS_CONF1,\r\ncm36651->ps_ctrl_regs[CM36651_PS_CONF1]);\r\nbreak;\r\ncase CM36651_CMD_PROX_EV_EN:\r\nif (test_bit(CM36651_PROXIMITY_EV_EN, &cm36651->flags)) {\r\ndev_err(&client->dev,\r\n"Already proximity event enable state\n");\r\nreturn ret;\r\n}\r\nset_bit(CM36651_PROXIMITY_EV_EN, &cm36651->flags);\r\nret = i2c_smbus_write_byte_data(ps_client,\r\ncm36651_ps_reg[CM36651_PS_CONF1],\r\nCM36651_PS_INT_EN | CM36651_PS_PERS2 | CM36651_PS_IT2);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Proximity enable event failed\n");\r\nreturn ret;\r\n}\r\nbreak;\r\ncase CM36651_CMD_PROX_EV_DIS:\r\nif (!test_bit(CM36651_PROXIMITY_EV_EN, &cm36651->flags)) {\r\ndev_err(&client->dev,\r\n"Already proximity event disable state\n");\r\nreturn ret;\r\n}\r\nclear_bit(CM36651_PROXIMITY_EV_EN, &cm36651->flags);\r\nret = i2c_smbus_write_byte_data(ps_client,\r\nCM36651_PS_CONF1, CM36651_PS_DISABLE);\r\nbreak;\r\n}\r\nif (ret < 0)\r\ndev_err(&client->dev, "Write register failed\n");\r\nreturn ret;\r\n}\r\nstatic int cm36651_read_channel(struct cm36651_data *cm36651,\r\nstruct iio_chan_spec const *chan, int *val)\r\n{\r\nstruct i2c_client *client = cm36651->client;\r\nint cmd, ret;\r\nif (chan->type == IIO_LIGHT)\r\ncmd = CM36651_CMD_READ_RAW_LIGHT;\r\nelse if (chan->type == IIO_PROXIMITY)\r\ncmd = CM36651_CMD_READ_RAW_PROXIMITY;\r\nelse\r\nreturn -EINVAL;\r\nret = cm36651_set_operation_mode(cm36651, cmd);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "CM36651 set operation mode failed\n");\r\nreturn ret;\r\n}\r\nmsleep(50);\r\nret = cm36651_read_output(cm36651, chan, val);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "CM36651 read output failed\n");\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic int cm36651_read_int_time(struct cm36651_data *cm36651,\r\nstruct iio_chan_spec const *chan, int *val2)\r\n{\r\nswitch (chan->type) {\r\ncase IIO_LIGHT:\r\nif (cm36651->cs_int_time[chan->address] == CM36651_CS_IT1)\r\n*val2 = 80000;\r\nelse if (cm36651->cs_int_time[chan->address] == CM36651_CS_IT2)\r\n*val2 = 160000;\r\nelse if (cm36651->cs_int_time[chan->address] == CM36651_CS_IT3)\r\n*val2 = 320000;\r\nelse if (cm36651->cs_int_time[chan->address] == CM36651_CS_IT4)\r\n*val2 = 640000;\r\nelse\r\nreturn -EINVAL;\r\nbreak;\r\ncase IIO_PROXIMITY:\r\nif (cm36651->ps_int_time == CM36651_PS_IT1)\r\n*val2 = 320;\r\nelse if (cm36651->ps_int_time == CM36651_PS_IT2)\r\n*val2 = 420;\r\nelse if (cm36651->ps_int_time == CM36651_PS_IT3)\r\n*val2 = 520;\r\nelse if (cm36651->ps_int_time == CM36651_PS_IT4)\r\n*val2 = 640;\r\nelse\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\n}\r\nstatic int cm36651_write_int_time(struct cm36651_data *cm36651,\r\nstruct iio_chan_spec const *chan, int val)\r\n{\r\nstruct i2c_client *client = cm36651->client;\r\nstruct i2c_client *ps_client = cm36651->ps_client;\r\nint int_time, ret;\r\nswitch (chan->type) {\r\ncase IIO_LIGHT:\r\nif (val == 80000)\r\nint_time = CM36651_CS_IT1;\r\nelse if (val == 160000)\r\nint_time = CM36651_CS_IT2;\r\nelse if (val == 320000)\r\nint_time = CM36651_CS_IT3;\r\nelse if (val == 640000)\r\nint_time = CM36651_CS_IT4;\r\nelse\r\nreturn -EINVAL;\r\nret = i2c_smbus_write_byte_data(client, CM36651_CS_CONF3,\r\nint_time >> 2 * (chan->address));\r\nif (ret < 0) {\r\ndev_err(&client->dev, "CS integration time write failed\n");\r\nreturn ret;\r\n}\r\ncm36651->cs_int_time[chan->address] = int_time;\r\nbreak;\r\ncase IIO_PROXIMITY:\r\nif (val == 320)\r\nint_time = CM36651_PS_IT1;\r\nelse if (val == 420)\r\nint_time = CM36651_PS_IT2;\r\nelse if (val == 520)\r\nint_time = CM36651_PS_IT3;\r\nelse if (val == 640)\r\nint_time = CM36651_PS_IT4;\r\nelse\r\nreturn -EINVAL;\r\nret = i2c_smbus_write_byte_data(ps_client,\r\nCM36651_PS_CONF1, int_time);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "PS integration time write failed\n");\r\nreturn ret;\r\n}\r\ncm36651->ps_int_time = int_time;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int cm36651_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2, long mask)\r\n{\r\nstruct cm36651_data *cm36651 = iio_priv(indio_dev);\r\nint ret;\r\nmutex_lock(&cm36651->lock);\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nret = cm36651_read_channel(cm36651, chan, val);\r\nbreak;\r\ncase IIO_CHAN_INFO_INT_TIME:\r\n*val = 0;\r\nret = cm36651_read_int_time(cm36651, chan, val2);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nmutex_unlock(&cm36651->lock);\r\nreturn ret;\r\n}\r\nstatic int cm36651_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint val, int val2, long mask)\r\n{\r\nstruct cm36651_data *cm36651 = iio_priv(indio_dev);\r\nstruct i2c_client *client = cm36651->client;\r\nint ret = -EINVAL;\r\nif (mask == IIO_CHAN_INFO_INT_TIME) {\r\nret = cm36651_write_int_time(cm36651, chan, val2);\r\nif (ret < 0)\r\ndev_err(&client->dev, "Integration time write failed\n");\r\n}\r\nreturn ret;\r\n}\r\nstatic int cm36651_read_prox_thresh(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan,\r\nenum iio_event_type type,\r\nenum iio_event_direction dir,\r\nenum iio_event_info info,\r\nint *val, int *val2)\r\n{\r\nstruct cm36651_data *cm36651 = iio_priv(indio_dev);\r\n*val = cm36651->ps_ctrl_regs[CM36651_PS_THD];\r\nreturn 0;\r\n}\r\nstatic int cm36651_write_prox_thresh(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan,\r\nenum iio_event_type type,\r\nenum iio_event_direction dir,\r\nenum iio_event_info info,\r\nint val, int val2)\r\n{\r\nstruct cm36651_data *cm36651 = iio_priv(indio_dev);\r\nstruct i2c_client *client = cm36651->client;\r\nint ret;\r\nif (val < 3 || val > 255)\r\nreturn -EINVAL;\r\ncm36651->ps_ctrl_regs[CM36651_PS_THD] = val;\r\nret = i2c_smbus_write_byte_data(cm36651->ps_client, CM36651_PS_THD,\r\ncm36651->ps_ctrl_regs[CM36651_PS_THD]);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "PS threshold write failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cm36651_write_prox_event_config(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan,\r\nenum iio_event_type type,\r\nenum iio_event_direction dir,\r\nint state)\r\n{\r\nstruct cm36651_data *cm36651 = iio_priv(indio_dev);\r\nint cmd, ret = -EINVAL;\r\nmutex_lock(&cm36651->lock);\r\ncmd = state ? CM36651_CMD_PROX_EV_EN : CM36651_CMD_PROX_EV_DIS;\r\nret = cm36651_set_operation_mode(cm36651, cmd);\r\nmutex_unlock(&cm36651->lock);\r\nreturn ret;\r\n}\r\nstatic int cm36651_read_prox_event_config(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan,\r\nenum iio_event_type type,\r\nenum iio_event_direction dir)\r\n{\r\nstruct cm36651_data *cm36651 = iio_priv(indio_dev);\r\nint event_en;\r\nmutex_lock(&cm36651->lock);\r\nevent_en = test_bit(CM36651_PROXIMITY_EV_EN, &cm36651->flags);\r\nmutex_unlock(&cm36651->lock);\r\nreturn event_en;\r\n}\r\nstatic int cm36651_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct cm36651_data *cm36651;\r\nstruct iio_dev *indio_dev;\r\nint ret;\r\nindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*cm36651));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\ncm36651 = iio_priv(indio_dev);\r\ncm36651->vled_reg = devm_regulator_get(&client->dev, "vled");\r\nif (IS_ERR(cm36651->vled_reg)) {\r\ndev_err(&client->dev, "get regulator vled failed\n");\r\nreturn PTR_ERR(cm36651->vled_reg);\r\n}\r\nret = regulator_enable(cm36651->vled_reg);\r\nif (ret) {\r\ndev_err(&client->dev, "enable regulator vled failed\n");\r\nreturn ret;\r\n}\r\ni2c_set_clientdata(client, indio_dev);\r\ncm36651->client = client;\r\ncm36651->ps_client = i2c_new_dummy(client->adapter,\r\nCM36651_I2C_ADDR_PS);\r\nif (!cm36651->ps_client) {\r\ndev_err(&client->dev, "%s: new i2c device failed\n", __func__);\r\nret = -ENODEV;\r\ngoto error_disable_reg;\r\n}\r\ncm36651->ara_client = i2c_new_dummy(client->adapter, CM36651_ARA);\r\nif (!cm36651->ara_client) {\r\ndev_err(&client->dev, "%s: new i2c device failed\n", __func__);\r\nret = -ENODEV;\r\ngoto error_i2c_unregister_ps;\r\n}\r\nmutex_init(&cm36651->lock);\r\nindio_dev->dev.parent = &client->dev;\r\nindio_dev->channels = cm36651_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(cm36651_channels);\r\nindio_dev->info = &cm36651_info;\r\nindio_dev->name = id->name;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nret = cm36651_setup_reg(cm36651);\r\nif (ret) {\r\ndev_err(&client->dev, "%s: register setup failed\n", __func__);\r\ngoto error_i2c_unregister_ara;\r\n}\r\nret = request_threaded_irq(client->irq, NULL, cm36651_irq_handler,\r\nIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\r\n"cm36651", indio_dev);\r\nif (ret) {\r\ndev_err(&client->dev, "%s: request irq failed\n", __func__);\r\ngoto error_i2c_unregister_ara;\r\n}\r\nret = iio_device_register(indio_dev);\r\nif (ret) {\r\ndev_err(&client->dev, "%s: regist device failed\n", __func__);\r\ngoto error_free_irq;\r\n}\r\nreturn 0;\r\nerror_free_irq:\r\nfree_irq(client->irq, indio_dev);\r\nerror_i2c_unregister_ara:\r\ni2c_unregister_device(cm36651->ara_client);\r\nerror_i2c_unregister_ps:\r\ni2c_unregister_device(cm36651->ps_client);\r\nerror_disable_reg:\r\nregulator_disable(cm36651->vled_reg);\r\nreturn ret;\r\n}\r\nstatic int cm36651_remove(struct i2c_client *client)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(client);\r\nstruct cm36651_data *cm36651 = iio_priv(indio_dev);\r\niio_device_unregister(indio_dev);\r\nregulator_disable(cm36651->vled_reg);\r\nfree_irq(client->irq, indio_dev);\r\ni2c_unregister_device(cm36651->ps_client);\r\ni2c_unregister_device(cm36651->ara_client);\r\nreturn 0;\r\n}
