static void idt_nt_write(struct idt_ntb_dev *ndev,\r\nconst unsigned int reg, const u32 data)\r\n{\r\nif (WARN_ON(reg > IDT_REG_PCI_MAX || !IS_ALIGNED(reg, IDT_REG_ALIGN)))\r\nreturn;\r\niowrite32(data, ndev->cfgspc + (ptrdiff_t)reg);\r\n}\r\nstatic u32 idt_nt_read(struct idt_ntb_dev *ndev, const unsigned int reg)\r\n{\r\nif (WARN_ON(reg > IDT_REG_PCI_MAX || !IS_ALIGNED(reg, IDT_REG_ALIGN)))\r\nreturn ~0;\r\nreturn ioread32(ndev->cfgspc + (ptrdiff_t)reg);\r\n}\r\nstatic void idt_sw_write(struct idt_ntb_dev *ndev,\r\nconst unsigned int reg, const u32 data)\r\n{\r\nunsigned long irqflags;\r\nif (WARN_ON(reg > IDT_REG_SW_MAX || !IS_ALIGNED(reg, IDT_REG_ALIGN)))\r\nreturn;\r\nspin_lock_irqsave(&ndev->gasa_lock, irqflags);\r\niowrite32((u32)reg, ndev->cfgspc + (ptrdiff_t)IDT_NT_GASAADDR);\r\niowrite32(data, ndev->cfgspc + (ptrdiff_t)IDT_NT_GASADATA);\r\nmmiowb();\r\nspin_unlock_irqrestore(&ndev->gasa_lock, irqflags);\r\n}\r\nstatic u32 idt_sw_read(struct idt_ntb_dev *ndev, const unsigned int reg)\r\n{\r\nunsigned long irqflags;\r\nu32 data;\r\nif (WARN_ON(reg > IDT_REG_SW_MAX || !IS_ALIGNED(reg, IDT_REG_ALIGN)))\r\nreturn ~0;\r\nspin_lock_irqsave(&ndev->gasa_lock, irqflags);\r\niowrite32((u32)reg, ndev->cfgspc + (ptrdiff_t)IDT_NT_GASAADDR);\r\ndata = ioread32(ndev->cfgspc + (ptrdiff_t)IDT_NT_GASADATA);\r\nspin_unlock_irqrestore(&ndev->gasa_lock, irqflags);\r\nreturn data;\r\n}\r\nstatic inline int idt_reg_set_bits(struct idt_ntb_dev *ndev, unsigned int reg,\r\nspinlock_t *reg_lock,\r\nu64 valid_mask, u64 set_bits)\r\n{\r\nunsigned long irqflags;\r\nu32 data;\r\nif (set_bits & ~(u64)valid_mask)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(reg_lock, irqflags);\r\ndata = idt_nt_read(ndev, reg) | (u32)set_bits;\r\nidt_nt_write(ndev, reg, data);\r\nspin_unlock_irqrestore(reg_lock, irqflags);\r\nreturn 0;\r\n}\r\nstatic inline void idt_reg_clear_bits(struct idt_ntb_dev *ndev,\r\nunsigned int reg, spinlock_t *reg_lock,\r\nu64 clear_bits)\r\n{\r\nunsigned long irqflags;\r\nu32 data;\r\nspin_lock_irqsave(reg_lock, irqflags);\r\ndata = idt_nt_read(ndev, reg) & ~(u32)clear_bits;\r\nidt_nt_write(ndev, reg, data);\r\nspin_unlock_irqrestore(reg_lock, irqflags);\r\n}\r\nstatic int idt_scan_ports(struct idt_ntb_dev *ndev)\r\n{\r\nunsigned char pidx, port, part;\r\nu32 data, portsts, partsts;\r\ndata = idt_nt_read(ndev, IDT_NT_PCIELCAP);\r\nndev->port = GET_FIELD(PCIELCAP_PORTNUM, data);\r\nportsts = idt_sw_read(ndev, portdata_tbl[ndev->port].sts);\r\nndev->part = GET_FIELD(SWPORTxSTS_SWPART, portsts);\r\nmemset(ndev->port_idx_map, -EINVAL, sizeof(ndev->port_idx_map));\r\nmemset(ndev->part_idx_map, -EINVAL, sizeof(ndev->part_idx_map));\r\nndev->peer_cnt = 0;\r\nfor (pidx = 0; pidx < ndev->swcfg->port_cnt; pidx++) {\r\nport = ndev->swcfg->ports[pidx];\r\nif (port == ndev->port)\r\ncontinue;\r\nportsts = idt_sw_read(ndev, portdata_tbl[port].sts);\r\npart = GET_FIELD(SWPORTxSTS_SWPART, portsts);\r\npartsts = idt_sw_read(ndev, partdata_tbl[part].sts);\r\nif (IS_FLD_SET(SWPARTxSTS_STATE, partsts, ACT) &&\r\n(IS_FLD_SET(SWPORTxSTS_MODE, portsts, NT) ||\r\nIS_FLD_SET(SWPORTxSTS_MODE, portsts, USNT) ||\r\nIS_FLD_SET(SWPORTxSTS_MODE, portsts, USNTDMA) ||\r\nIS_FLD_SET(SWPORTxSTS_MODE, portsts, NTDMA))) {\r\nndev->peers[ndev->peer_cnt].port = port;\r\nndev->peers[ndev->peer_cnt].part = part;\r\nndev->port_idx_map[port] = ndev->peer_cnt;\r\nndev->part_idx_map[part] = ndev->peer_cnt;\r\nndev->peer_cnt++;\r\n}\r\n}\r\ndev_dbg(&ndev->ntb.pdev->dev, "Local port: %hhu, num of peers: %hhu\n",\r\nndev->port, ndev->peer_cnt);\r\nif (ndev->peer_cnt == 0) {\r\ndev_warn(&ndev->ntb.pdev->dev, "No active peer found\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int idt_ntb_port_number(struct ntb_dev *ntb)\r\n{\r\nstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\r\nreturn ndev->port;\r\n}\r\nstatic int idt_ntb_peer_port_count(struct ntb_dev *ntb)\r\n{\r\nstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\r\nreturn ndev->peer_cnt;\r\n}\r\nstatic int idt_ntb_peer_port_number(struct ntb_dev *ntb, int pidx)\r\n{\r\nstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\r\nif (pidx < 0 || ndev->peer_cnt <= pidx)\r\nreturn -EINVAL;\r\nreturn ndev->peers[pidx].port;\r\n}\r\nstatic int idt_ntb_peer_port_idx(struct ntb_dev *ntb, int port)\r\n{\r\nstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\r\nif (port < 0 || IDT_MAX_NR_PORTS <= port)\r\nreturn -EINVAL;\r\nreturn ndev->port_idx_map[port];\r\n}\r\nstatic void idt_init_link(struct idt_ntb_dev *ndev)\r\n{\r\nu32 part_mask, port_mask, se_mask;\r\nunsigned char pidx;\r\nspin_lock_init(&ndev->mtbl_lock);\r\nport_mask = ~BIT(ndev->port);\r\npart_mask = ~BIT(ndev->part);\r\nfor (pidx = 0; pidx < ndev->peer_cnt; pidx++) {\r\nport_mask &= ~BIT(ndev->peers[pidx].port);\r\npart_mask &= ~BIT(ndev->peers[pidx].part);\r\n}\r\nidt_sw_write(ndev, IDT_SW_SELINKUPSTS, (u32)-1);\r\nidt_sw_write(ndev, IDT_SW_SELINKDNSTS, (u32)-1);\r\nidt_sw_write(ndev, IDT_SW_SEGSIGSTS, (u32)-1);\r\nidt_sw_write(ndev, IDT_SW_SEPMSK, part_mask);\r\nidt_sw_write(ndev, IDT_SW_SELINKUPMSK, port_mask);\r\nidt_sw_write(ndev, IDT_SW_SELINKDNMSK, port_mask);\r\nidt_sw_write(ndev, IDT_SW_SEGSIGMSK, part_mask);\r\nse_mask = ~(IDT_SEMSK_LINKUP | IDT_SEMSK_LINKDN | IDT_SEMSK_GSIGNAL);\r\nidt_sw_write(ndev, IDT_SW_SEMSK, se_mask);\r\ndev_dbg(&ndev->ntb.pdev->dev, "NTB link status events initialized");\r\n}\r\nstatic void idt_deinit_link(struct idt_ntb_dev *ndev)\r\n{\r\nidt_ntb_local_link_disable(ndev);\r\ndev_dbg(&ndev->ntb.pdev->dev, "NTB link status events deinitialized");\r\n}\r\nstatic void idt_se_isr(struct idt_ntb_dev *ndev, u32 ntint_sts)\r\n{\r\nu32 sests;\r\nsests = idt_sw_read(ndev, IDT_SW_SESTS);\r\nidt_sw_write(ndev, IDT_SW_SELINKUPSTS, (u32)-1);\r\nidt_sw_write(ndev, IDT_SW_SELINKDNSTS, (u32)-1);\r\nidt_sw_write(ndev, IDT_SW_SEGSIGSTS, (u32)-1);\r\nidt_nt_write(ndev, IDT_NT_NTINTSTS, IDT_NTINTSTS_SEVENT);\r\ndev_dbg(&ndev->ntb.pdev->dev, "SE IRQ detected %#08x (SESTS %#08x)",\r\nntint_sts, sests);\r\nntb_link_event(&ndev->ntb);\r\n}\r\nstatic void idt_ntb_local_link_enable(struct idt_ntb_dev *ndev)\r\n{\r\nu32 reqid, mtbldata = 0;\r\nunsigned long irqflags;\r\nidt_nt_write(ndev, IDT_NT_NTCTL, IDT_NTCTL_CPEN);\r\nreqid = idt_nt_read(ndev, IDT_NT_REQIDCAP);\r\nmtbldata = SET_FIELD(NTMTBLDATA_REQID, 0, reqid) |\r\nSET_FIELD(NTMTBLDATA_PART, 0, ndev->part) |\r\nIDT_NTMTBLDATA_VALID;\r\nspin_lock_irqsave(&ndev->mtbl_lock, irqflags);\r\nidt_nt_write(ndev, IDT_NT_NTMTBLADDR, ndev->part);\r\nidt_nt_write(ndev, IDT_NT_NTMTBLDATA, mtbldata);\r\nmmiowb();\r\nspin_unlock_irqrestore(&ndev->mtbl_lock, irqflags);\r\nidt_nt_write(ndev, IDT_NT_NTGSIGNAL, IDT_NTGSIGNAL_SET);\r\nidt_sw_write(ndev, IDT_SW_SEGSIGSTS, (u32)1 << ndev->part);\r\n}\r\nstatic void idt_ntb_local_link_disable(struct idt_ntb_dev *ndev)\r\n{\r\nunsigned long irqflags;\r\nidt_nt_write(ndev, IDT_NT_NTCTL, 0);\r\nspin_lock_irqsave(&ndev->mtbl_lock, irqflags);\r\nidt_nt_write(ndev, IDT_NT_NTMTBLADDR, ndev->part);\r\nidt_nt_write(ndev, IDT_NT_NTMTBLDATA, 0);\r\nmmiowb();\r\nspin_unlock_irqrestore(&ndev->mtbl_lock, irqflags);\r\nidt_nt_write(ndev, IDT_NT_NTGSIGNAL, IDT_NTGSIGNAL_SET);\r\nidt_sw_write(ndev, IDT_SW_SEGSIGSTS, (u32)1 << ndev->part);\r\n}\r\nstatic bool idt_ntb_local_link_is_up(struct idt_ntb_dev *ndev)\r\n{\r\nunsigned long irqflags;\r\nu32 data;\r\ndata = idt_nt_read(ndev, IDT_NT_PCICMDSTS);\r\nif (!(data & IDT_PCICMDSTS_BME))\r\nreturn false;\r\ndata = idt_nt_read(ndev, IDT_NT_NTCTL);\r\nif (!(data & IDT_NTCTL_CPEN))\r\nreturn false;\r\nspin_lock_irqsave(&ndev->mtbl_lock, irqflags);\r\nidt_nt_write(ndev, IDT_NT_NTMTBLADDR, ndev->part);\r\ndata = idt_nt_read(ndev, IDT_NT_NTMTBLDATA);\r\nspin_unlock_irqrestore(&ndev->mtbl_lock, irqflags);\r\nreturn !!(data & IDT_NTMTBLDATA_VALID);\r\n}\r\nstatic bool idt_ntb_peer_link_is_up(struct idt_ntb_dev *ndev, int pidx)\r\n{\r\nunsigned long irqflags;\r\nunsigned char port;\r\nu32 data;\r\nport = ndev->peers[pidx].port;\r\ndata = idt_sw_read(ndev, portdata_tbl[port].sts);\r\nif (!(data & IDT_SWPORTxSTS_LINKUP))\r\nreturn false;\r\ndata = idt_sw_read(ndev, portdata_tbl[port].pcicmdsts);\r\nif (!(data & IDT_PCICMDSTS_BME))\r\nreturn false;\r\ndata = idt_sw_read(ndev, portdata_tbl[port].ntctl);\r\nif (!(data & IDT_NTCTL_CPEN))\r\nreturn false;\r\nspin_lock_irqsave(&ndev->mtbl_lock, irqflags);\r\nidt_nt_write(ndev, IDT_NT_NTMTBLADDR, ndev->peers[pidx].part);\r\ndata = idt_nt_read(ndev, IDT_NT_NTMTBLDATA);\r\nspin_unlock_irqrestore(&ndev->mtbl_lock, irqflags);\r\nreturn !!(data & IDT_NTMTBLDATA_VALID);\r\n}\r\nstatic u64 idt_ntb_link_is_up(struct ntb_dev *ntb,\r\nenum ntb_speed *speed, enum ntb_width *width)\r\n{\r\nstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\r\nunsigned char pidx;\r\nu64 status;\r\nu32 data;\r\nif (speed != NULL || width != NULL) {\r\ndata = idt_nt_read(ndev, IDT_NT_PCIELCTLSTS);\r\nif (speed != NULL)\r\n*speed = GET_FIELD(PCIELCTLSTS_CLS, data);\r\nif (width != NULL)\r\n*width = GET_FIELD(PCIELCTLSTS_NLW, data);\r\n}\r\nif (!idt_ntb_local_link_is_up(ndev))\r\nreturn 0;\r\nstatus = 0;\r\nfor (pidx = 0; pidx < ndev->peer_cnt; pidx++) {\r\nif (idt_ntb_peer_link_is_up(ndev, pidx))\r\nstatus |= ((u64)1 << pidx);\r\n}\r\nreturn status;\r\n}\r\nstatic int idt_ntb_link_enable(struct ntb_dev *ntb, enum ntb_speed speed,\r\nenum ntb_width width)\r\n{\r\nstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\r\nidt_ntb_local_link_enable(ndev);\r\ndev_dbg(&ndev->ntb.pdev->dev, "Local NTB link enabled");\r\nreturn 0;\r\n}\r\nstatic int idt_ntb_link_disable(struct ntb_dev *ntb)\r\n{\r\nstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\r\nidt_ntb_local_link_disable(ndev);\r\ndev_dbg(&ndev->ntb.pdev->dev, "Local NTB link disabled");\r\nreturn 0;\r\n}\r\nstatic inline unsigned char idt_get_mw_count(enum idt_mw_type mw_type)\r\n{\r\nswitch (mw_type) {\r\ncase IDT_MW_DIR:\r\nreturn 1;\r\ncase IDT_MW_LUT12:\r\nreturn 12;\r\ncase IDT_MW_LUT24:\r\nreturn 24;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline char *idt_get_mw_name(enum idt_mw_type mw_type)\r\n{\r\nswitch (mw_type) {\r\ncase IDT_MW_DIR:\r\nreturn "DIR ";\r\ncase IDT_MW_LUT12:\r\nreturn "LUT12";\r\ncase IDT_MW_LUT24:\r\nreturn "LUT24";\r\ndefault:\r\nbreak;\r\n}\r\nreturn "unknown";\r\n}\r\nstatic struct idt_mw_cfg *idt_scan_mws(struct idt_ntb_dev *ndev, int port,\r\nunsigned char *mw_cnt)\r\n{\r\nstruct idt_mw_cfg mws[IDT_MAX_NR_MWS], *ret_mws;\r\nconst struct idt_ntb_bar *bars;\r\nenum idt_mw_type mw_type;\r\nunsigned char widx, bidx, en_cnt;\r\nbool bar_64bit = false;\r\nint aprt_size;\r\nu32 data;\r\nbars = portdata_tbl[port].bars;\r\n*mw_cnt = 0;\r\nfor (bidx = 0; bidx < IDT_BAR_CNT; bidx += 1 + bar_64bit) {\r\ndata = idt_sw_read(ndev, bars[bidx].setup);\r\nif (!(data & IDT_BARSETUP_EN)) {\r\nbar_64bit = false;\r\ncontinue;\r\n}\r\nbar_64bit = IS_FLD_SET(BARSETUP_TYPE, data, 64);\r\nif (data & IDT_BARSETUP_MODE_CFG)\r\ncontinue;\r\nmw_type = GET_FIELD(BARSETUP_ATRAN, data);\r\nen_cnt = idt_get_mw_count(mw_type);\r\naprt_size = (u64)1 << GET_FIELD(BARSETUP_SIZE, data);\r\nfor (widx = 0; widx < en_cnt; widx++, (*mw_cnt)++) {\r\nif (*mw_cnt >= IDT_MAX_NR_MWS)\r\nreturn ERR_PTR(-EINVAL);\r\nmws[*mw_cnt].type = mw_type;\r\nmws[*mw_cnt].bar = bidx;\r\nmws[*mw_cnt].idx = widx;\r\nmws[*mw_cnt].addr_align = IDT_TRANS_ALIGN;\r\nif (mw_type == IDT_MW_DIR)\r\nmws[*mw_cnt].size_max = aprt_size;\r\nelse if (mw_type == IDT_MW_LUT12)\r\nmws[*mw_cnt].size_max = aprt_size / 16;\r\nelse\r\nmws[*mw_cnt].size_max = aprt_size / 32;\r\nmws[*mw_cnt].size_align = (mw_type == IDT_MW_DIR) ?\r\nIDT_DIR_SIZE_ALIGN : mws[*mw_cnt].size_max;\r\n}\r\n}\r\nret_mws = devm_kcalloc(&ndev->ntb.pdev->dev, *mw_cnt,\r\nsizeof(*ret_mws), GFP_KERNEL);\r\nif (IS_ERR_OR_NULL(ret_mws))\r\nreturn ERR_PTR(-ENOMEM);\r\nmemcpy(ret_mws, mws, (*mw_cnt)*sizeof(*ret_mws));\r\nreturn ret_mws;\r\n}\r\nstatic int idt_init_mws(struct idt_ntb_dev *ndev)\r\n{\r\nstruct idt_ntb_peer *peer;\r\nunsigned char pidx;\r\nndev->mws = idt_scan_mws(ndev, ndev->port, &ndev->mw_cnt);\r\nif (IS_ERR(ndev->mws)) {\r\ndev_err(&ndev->ntb.pdev->dev,\r\n"Failed to scan mws of local port %hhu", ndev->port);\r\nreturn PTR_ERR(ndev->mws);\r\n}\r\nfor (pidx = 0; pidx < ndev->peer_cnt; pidx++) {\r\npeer = &ndev->peers[pidx];\r\npeer->mws = idt_scan_mws(ndev, peer->port, &peer->mw_cnt);\r\nif (IS_ERR(peer->mws)) {\r\ndev_err(&ndev->ntb.pdev->dev,\r\n"Failed to scan mws of port %hhu", peer->port);\r\nreturn PTR_ERR(peer->mws);\r\n}\r\n}\r\nspin_lock_init(&ndev->lut_lock);\r\ndev_dbg(&ndev->ntb.pdev->dev, "Outbound and inbound MWs initialized");\r\nreturn 0;\r\n}\r\nstatic int idt_ntb_mw_count(struct ntb_dev *ntb, int pidx)\r\n{\r\nstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\r\nif (pidx < 0 || ndev->peer_cnt <= pidx)\r\nreturn -EINVAL;\r\nreturn ndev->peers[pidx].mw_cnt;\r\n}\r\nstatic int idt_ntb_mw_get_align(struct ntb_dev *ntb, int pidx, int widx,\r\nresource_size_t *addr_align,\r\nresource_size_t *size_align,\r\nresource_size_t *size_max)\r\n{\r\nstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\r\nstruct idt_ntb_peer *peer;\r\nif (pidx < 0 || ndev->peer_cnt <= pidx)\r\nreturn -EINVAL;\r\npeer = &ndev->peers[pidx];\r\nif (widx < 0 || peer->mw_cnt <= widx)\r\nreturn -EINVAL;\r\nif (addr_align != NULL)\r\n*addr_align = peer->mws[widx].addr_align;\r\nif (size_align != NULL)\r\n*size_align = peer->mws[widx].size_align;\r\nif (size_max != NULL)\r\n*size_max = peer->mws[widx].size_max;\r\nreturn 0;\r\n}\r\nstatic int idt_ntb_peer_mw_count(struct ntb_dev *ntb)\r\n{\r\nstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\r\nreturn ndev->mw_cnt;\r\n}\r\nstatic int idt_ntb_peer_mw_get_addr(struct ntb_dev *ntb, int widx,\r\nphys_addr_t *base, resource_size_t *size)\r\n{\r\nstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\r\nif (widx < 0 || ndev->mw_cnt <= widx)\r\nreturn -EINVAL;\r\nif (base != NULL)\r\n*base = pci_resource_start(ntb->pdev, ndev->mws[widx].bar) +\r\nndev->mws[widx].idx * ndev->mws[widx].size_max;\r\nif (size != NULL)\r\n*size = ndev->mws[widx].size_max;\r\nreturn 0;\r\n}\r\nstatic int idt_ntb_peer_mw_set_trans(struct ntb_dev *ntb, int pidx, int widx,\r\nu64 addr, resource_size_t size)\r\n{\r\nstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\r\nstruct idt_mw_cfg *mw_cfg;\r\nu32 data = 0, lutoff = 0;\r\nif (pidx < 0 || ndev->peer_cnt <= pidx)\r\nreturn -EINVAL;\r\nif (widx < 0 || ndev->mw_cnt <= widx)\r\nreturn -EINVAL;\r\nmw_cfg = &ndev->mws[widx];\r\nif (!IS_ALIGNED(addr, mw_cfg->addr_align))\r\nreturn -EINVAL;\r\nif (!IS_ALIGNED(size, mw_cfg->size_align) || size > mw_cfg->size_max)\r\nreturn -EINVAL;\r\nif (mw_cfg->type == IDT_MW_DIR) {\r\nconst struct idt_ntb_bar *bar = &ntdata_tbl.bars[mw_cfg->bar];\r\nu64 limit;\r\ndata = idt_nt_read(ndev, bar->setup);\r\ndata = SET_FIELD(BARSETUP_TPART, data, ndev->peers[pidx].part);\r\nidt_nt_write(ndev, bar->setup, data);\r\nidt_nt_write(ndev, bar->ltbase, (u32)addr);\r\nidt_nt_write(ndev, bar->utbase, (u32)(addr >> 32));\r\nlimit = pci_resource_start(ntb->pdev, mw_cfg->bar) + size;\r\nidt_nt_write(ndev, bar->limit, (u32)limit);\r\nif (IS_FLD_SET(BARSETUP_TYPE, data, 64))\r\nidt_nt_write(ndev, (bar + 1)->limit, (limit >> 32));\r\n} else {\r\nunsigned long irqflags;\r\nlutoff = SET_FIELD(LUTOFFSET_INDEX, 0, mw_cfg->idx) |\r\nSET_FIELD(LUTOFFSET_BAR, 0, mw_cfg->bar);\r\ndata = SET_FIELD(LUTUDATA_PART, 0, ndev->peers[pidx].part) |\r\nIDT_LUTUDATA_VALID;\r\nspin_lock_irqsave(&ndev->lut_lock, irqflags);\r\nidt_nt_write(ndev, IDT_NT_LUTOFFSET, lutoff);\r\nidt_nt_write(ndev, IDT_NT_LUTLDATA, (u32)addr);\r\nidt_nt_write(ndev, IDT_NT_LUTMDATA, (u32)(addr >> 32));\r\nidt_nt_write(ndev, IDT_NT_LUTUDATA, data);\r\nmmiowb();\r\nspin_unlock_irqrestore(&ndev->lut_lock, irqflags);\r\n}\r\nreturn 0;\r\n}\r\nstatic int idt_ntb_peer_mw_clear_trans(struct ntb_dev *ntb, int pidx,\r\nint widx)\r\n{\r\nstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\r\nstruct idt_mw_cfg *mw_cfg;\r\nif (pidx < 0 || ndev->peer_cnt <= pidx)\r\nreturn -EINVAL;\r\nif (widx < 0 || ndev->mw_cnt <= widx)\r\nreturn -EINVAL;\r\nmw_cfg = &ndev->mws[widx];\r\nif (mw_cfg->type == IDT_MW_DIR) {\r\nconst struct idt_ntb_bar *bar = &ntdata_tbl.bars[mw_cfg->bar];\r\nu32 data;\r\ndata = idt_nt_read(ndev, bar->setup);\r\nidt_nt_write(ndev, bar->limit, 0);\r\nif (IS_FLD_SET(BARSETUP_TYPE, data, 64))\r\nidt_nt_write(ndev, (bar + 1)->limit, 0);\r\n} else {\r\nunsigned long irqflags;\r\nu32 lutoff;\r\nlutoff = SET_FIELD(LUTOFFSET_INDEX, 0, mw_cfg->idx) |\r\nSET_FIELD(LUTOFFSET_BAR, 0, mw_cfg->bar);\r\nspin_lock_irqsave(&ndev->lut_lock, irqflags);\r\nidt_nt_write(ndev, IDT_NT_LUTOFFSET, lutoff);\r\nidt_nt_write(ndev, IDT_NT_LUTLDATA, 0);\r\nidt_nt_write(ndev, IDT_NT_LUTMDATA, 0);\r\nidt_nt_write(ndev, IDT_NT_LUTUDATA, 0);\r\nmmiowb();\r\nspin_unlock_irqrestore(&ndev->lut_lock, irqflags);\r\n}\r\nreturn 0;\r\n}\r\nstatic void idt_db_isr(struct idt_ntb_dev *ndev, u32 ntint_sts)\r\n{\r\ndev_dbg(&ndev->ntb.pdev->dev, "DB IRQ detected %#08x", ntint_sts);\r\nntb_db_event(&ndev->ntb, 0);\r\n}\r\nstatic u64 idt_ntb_db_valid_mask(struct ntb_dev *ntb)\r\n{\r\nreturn IDT_DBELL_MASK;\r\n}\r\nstatic u64 idt_ntb_db_read(struct ntb_dev *ntb)\r\n{\r\nstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\r\nreturn idt_nt_read(ndev, IDT_NT_INDBELLSTS);\r\n}\r\nstatic int idt_ntb_db_clear(struct ntb_dev *ntb, u64 db_bits)\r\n{\r\nstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\r\nidt_nt_write(ndev, IDT_NT_INDBELLSTS, (u32)db_bits);\r\nreturn 0;\r\n}\r\nstatic u64 idt_ntb_db_read_mask(struct ntb_dev *ntb)\r\n{\r\nstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\r\nreturn idt_nt_read(ndev, IDT_NT_INDBELLMSK);\r\n}\r\nstatic int idt_ntb_db_set_mask(struct ntb_dev *ntb, u64 db_bits)\r\n{\r\nstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\r\nreturn idt_reg_set_bits(ndev, IDT_NT_INDBELLMSK, &ndev->db_mask_lock,\r\nIDT_DBELL_MASK, db_bits);\r\n}\r\nstatic int idt_ntb_db_clear_mask(struct ntb_dev *ntb, u64 db_bits)\r\n{\r\nstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\r\nidt_reg_clear_bits(ndev, IDT_NT_INDBELLMSK, &ndev->db_mask_lock,\r\ndb_bits);\r\nreturn 0;\r\n}\r\nstatic int idt_ntb_peer_db_set(struct ntb_dev *ntb, u64 db_bits)\r\n{\r\nstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\r\nif (db_bits & ~(u64)IDT_DBELL_MASK)\r\nreturn -EINVAL;\r\nidt_nt_write(ndev, IDT_NT_OUTDBELLSET, (u32)db_bits);\r\nreturn 0;\r\n}\r\nstatic void idt_init_msg(struct idt_ntb_dev *ndev)\r\n{\r\nunsigned char midx;\r\nfor (midx = 0; midx < IDT_MSG_CNT; midx++)\r\nspin_lock_init(&ndev->msg_locks[midx]);\r\ndev_dbg(&ndev->ntb.pdev->dev, "NTB Messaging initialized");\r\n}\r\nstatic void idt_msg_isr(struct idt_ntb_dev *ndev, u32 ntint_sts)\r\n{\r\ndev_dbg(&ndev->ntb.pdev->dev, "Message IRQ detected %#08x", ntint_sts);\r\nntb_msg_event(&ndev->ntb);\r\n}\r\nstatic int idt_ntb_msg_count(struct ntb_dev *ntb)\r\n{\r\nreturn IDT_MSG_CNT;\r\n}\r\nstatic u64 idt_ntb_msg_inbits(struct ntb_dev *ntb)\r\n{\r\nreturn (u64)IDT_INMSG_MASK;\r\n}\r\nstatic u64 idt_ntb_msg_outbits(struct ntb_dev *ntb)\r\n{\r\nreturn (u64)IDT_OUTMSG_MASK;\r\n}\r\nstatic u64 idt_ntb_msg_read_sts(struct ntb_dev *ntb)\r\n{\r\nstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\r\nreturn idt_nt_read(ndev, IDT_NT_MSGSTS);\r\n}\r\nstatic int idt_ntb_msg_clear_sts(struct ntb_dev *ntb, u64 sts_bits)\r\n{\r\nstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\r\nidt_nt_write(ndev, IDT_NT_MSGSTS, sts_bits);\r\nreturn 0;\r\n}\r\nstatic int idt_ntb_msg_set_mask(struct ntb_dev *ntb, u64 mask_bits)\r\n{\r\nstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\r\nreturn idt_reg_set_bits(ndev, IDT_NT_MSGSTSMSK, &ndev->msg_mask_lock,\r\nIDT_MSG_MASK, mask_bits);\r\n}\r\nstatic int idt_ntb_msg_clear_mask(struct ntb_dev *ntb, u64 mask_bits)\r\n{\r\nstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\r\nidt_reg_clear_bits(ndev, IDT_NT_MSGSTSMSK, &ndev->msg_mask_lock,\r\nmask_bits);\r\nreturn 0;\r\n}\r\nstatic int idt_ntb_msg_read(struct ntb_dev *ntb, int midx, int *pidx, u32 *msg)\r\n{\r\nstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\r\nif (midx < 0 || IDT_MSG_CNT <= midx)\r\nreturn -EINVAL;\r\nif (pidx != NULL) {\r\nu32 srcpart;\r\nsrcpart = idt_nt_read(ndev, ntdata_tbl.msgs[midx].src);\r\n*pidx = ndev->part_idx_map[srcpart];\r\nif (*pidx == -EINVAL)\r\n*pidx = 0;\r\n}\r\nif (msg != NULL)\r\n*msg = idt_nt_read(ndev, ntdata_tbl.msgs[midx].in);\r\nreturn 0;\r\n}\r\nstatic int idt_ntb_msg_write(struct ntb_dev *ntb, int midx, int pidx, u32 msg)\r\n{\r\nstruct idt_ntb_dev *ndev = to_ndev_ntb(ntb);\r\nunsigned long irqflags;\r\nu32 swpmsgctl = 0;\r\nif (midx < 0 || IDT_MSG_CNT <= midx)\r\nreturn -EINVAL;\r\nif (pidx < 0 || ndev->peer_cnt <= pidx)\r\nreturn -EINVAL;\r\nswpmsgctl = SET_FIELD(SWPxMSGCTL_REG, 0, midx) |\r\nSET_FIELD(SWPxMSGCTL_PART, 0, ndev->peers[pidx].part);\r\nspin_lock_irqsave(&ndev->msg_locks[midx], irqflags);\r\nidt_sw_write(ndev, partdata_tbl[ndev->part].msgctl[midx], swpmsgctl);\r\nidt_nt_write(ndev, ntdata_tbl.msgs[midx].out, msg);\r\nmmiowb();\r\nspin_unlock_irqrestore(&ndev->msg_locks[midx], irqflags);\r\nreturn 0;\r\n}\r\nstatic void idt_read_temp(struct idt_ntb_dev *ndev, unsigned char *val,\r\nunsigned char *frac)\r\n{\r\nu32 data;\r\ndata = idt_sw_read(ndev, IDT_SW_TMPSTS);\r\ndata = GET_FIELD(TMPSTS_TEMP, data);\r\n*val = data >> 1;\r\n*frac = ((data & 0x1) ? 5 : 0);\r\n}\r\nstatic void idt_temp_isr(struct idt_ntb_dev *ndev, u32 ntint_sts)\r\n{\r\nunsigned char val, frac;\r\nidt_read_temp(ndev, &val, &frac);\r\nidt_nt_write(ndev, IDT_NT_NTINTSTS, IDT_NTINTSTS_TMPSENSOR);\r\ndev_dbg(&ndev->ntb.pdev->dev,\r\n"Temp sensor IRQ detected %#08x", ntint_sts);\r\ndev_warn(&ndev->ntb.pdev->dev, "Temperature %hhu.%hhu", val, frac);\r\n}\r\nstatic int idt_init_isr(struct idt_ntb_dev *ndev)\r\n{\r\nstruct pci_dev *pdev = ndev->ntb.pdev;\r\nu32 ntint_mask;\r\nint ret;\r\nret = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_MSI | PCI_IRQ_LEGACY);\r\nif (ret != 1) {\r\ndev_err(&pdev->dev, "Failed to allocate IRQ vector");\r\nreturn ret;\r\n}\r\nret = pci_irq_vector(pdev, 0);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed to get IRQ vector");\r\ngoto err_free_vectors;\r\n}\r\nret = devm_request_threaded_irq(&pdev->dev, ret, NULL, idt_thread_isr,\r\nIRQF_ONESHOT, NTB_IRQNAME, ndev);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev, "Failed to set MSI IRQ handler, %d", ret);\r\ngoto err_free_vectors;\r\n}\r\nntint_mask = idt_nt_read(ndev, IDT_NT_NTINTMSK) & ~IDT_NTINTMSK_ALL;\r\nidt_nt_write(ndev, IDT_NT_NTINTMSK, ntint_mask);\r\ndev_dbg(&pdev->dev, "NTB interrupts initialized");\r\nreturn 0;\r\nerr_free_vectors:\r\npci_free_irq_vectors(pdev);\r\nreturn ret;\r\n}\r\nstatic void idt_deinit_isr(struct idt_ntb_dev *ndev)\r\n{\r\nstruct pci_dev *pdev = ndev->ntb.pdev;\r\nu32 ntint_mask;\r\nntint_mask = idt_nt_read(ndev, IDT_NT_NTINTMSK) | IDT_NTINTMSK_ALL;\r\nidt_nt_write(ndev, IDT_NT_NTINTMSK, ntint_mask);\r\ndevm_free_irq(&pdev->dev, pci_irq_vector(pdev, 0), ndev);\r\npci_free_irq_vectors(pdev);\r\ndev_dbg(&pdev->dev, "NTB interrupts deinitialized");\r\n}\r\nstatic irqreturn_t idt_thread_isr(int irq, void *devid)\r\n{\r\nstruct idt_ntb_dev *ndev = devid;\r\nbool handled = false;\r\nu32 ntint_sts;\r\nntint_sts = idt_nt_read(ndev, IDT_NT_NTINTSTS);\r\nif (ntint_sts & IDT_NTINTSTS_MSG) {\r\nidt_msg_isr(ndev, ntint_sts);\r\nhandled = true;\r\n}\r\nif (ntint_sts & IDT_NTINTSTS_DBELL) {\r\nidt_db_isr(ndev, ntint_sts);\r\nhandled = true;\r\n}\r\nif (ntint_sts & IDT_NTINTSTS_SEVENT) {\r\nidt_se_isr(ndev, ntint_sts);\r\nhandled = true;\r\n}\r\nif (ntint_sts & IDT_NTINTSTS_TMPSENSOR) {\r\nidt_temp_isr(ndev, ntint_sts);\r\nhandled = true;\r\n}\r\ndev_dbg(&ndev->ntb.pdev->dev, "IDT IRQs 0x%08x handled", ntint_sts);\r\nreturn handled ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic int idt_register_device(struct idt_ntb_dev *ndev)\r\n{\r\nint ret;\r\nndev->ntb.ops = &idt_ntb_ops;\r\nndev->ntb.topo = NTB_TOPO_PRI;\r\nret = ntb_register_device(&ndev->ntb);\r\nif (ret != 0) {\r\ndev_err(&ndev->ntb.pdev->dev, "Failed to register NTB device");\r\nreturn ret;\r\n}\r\ndev_dbg(&ndev->ntb.pdev->dev, "NTB device successfully registered");\r\nreturn 0;\r\n}\r\nstatic void idt_unregister_device(struct idt_ntb_dev *ndev)\r\n{\r\nntb_unregister_device(&ndev->ntb);\r\ndev_dbg(&ndev->ntb.pdev->dev, "NTB device unregistered");\r\n}\r\nstatic ssize_t idt_dbgfs_info_read(struct file *filp, char __user *ubuf,\r\nsize_t count, loff_t *offp)\r\n{\r\nstruct idt_ntb_dev *ndev = filp->private_data;\r\nunsigned char temp, frac, idx, pidx, cnt;\r\nssize_t ret = 0, off = 0;\r\nunsigned long irqflags;\r\nenum ntb_speed speed;\r\nenum ntb_width width;\r\nchar *strbuf;\r\nsize_t size;\r\nu32 data;\r\nsize = min_t(size_t, count, 0x1000U);\r\nstrbuf = kmalloc(size, GFP_KERNEL);\r\nif (strbuf == NULL)\r\nreturn -ENOMEM;\r\noff += scnprintf(strbuf + off, size - off,\r\n"\n\t\tIDT NTB device Information:\n\n");\r\noff += scnprintf(strbuf + off, size - off,\r\n"Local Port %hhu, Partition %hhu\n", ndev->port, ndev->part);\r\noff += scnprintf(strbuf + off, size - off, "Peers:\n");\r\nfor (idx = 0; idx < ndev->peer_cnt; idx++) {\r\noff += scnprintf(strbuf + off, size - off,\r\n"\t%hhu. Port %hhu, Partition %hhu\n",\r\nidx, ndev->peers[idx].port, ndev->peers[idx].part);\r\n}\r\ndata = idt_ntb_link_is_up(&ndev->ntb, &speed, &width);\r\noff += scnprintf(strbuf + off, size - off,\r\n"NTB link status\t- 0x%08x, ", data);\r\noff += scnprintf(strbuf + off, size - off, "PCIe Gen %d x%d lanes\n",\r\nspeed, width);\r\noff += scnprintf(strbuf + off, size - off, "NTB Mapping Table:\n");\r\nfor (idx = 0; idx < IDT_MTBL_ENTRY_CNT; idx++) {\r\nspin_lock_irqsave(&ndev->mtbl_lock, irqflags);\r\nidt_nt_write(ndev, IDT_NT_NTMTBLADDR, idx);\r\ndata = idt_nt_read(ndev, IDT_NT_NTMTBLDATA);\r\nspin_unlock_irqrestore(&ndev->mtbl_lock, irqflags);\r\nif (data & IDT_NTMTBLDATA_VALID) {\r\noff += scnprintf(strbuf + off, size - off,\r\n"\t%hhu. Partition %d, Requester ID 0x%04x\n",\r\nidx, GET_FIELD(NTMTBLDATA_PART, data),\r\nGET_FIELD(NTMTBLDATA_REQID, data));\r\n}\r\n}\r\noff += scnprintf(strbuf + off, size - off, "\n");\r\noff += scnprintf(strbuf + off, size - off,\r\n"Outbound Memory Windows:\n");\r\nfor (idx = 0; idx < ndev->mw_cnt; idx += cnt) {\r\ndata = ndev->mws[idx].type;\r\ncnt = idt_get_mw_count(data);\r\nif (data == IDT_MW_DIR)\r\noff += scnprintf(strbuf + off, size - off,\r\n"\t%hhu.\t", idx);\r\nelse\r\noff += scnprintf(strbuf + off, size - off,\r\n"\t%hhu-%hhu.\t", idx, idx + cnt - 1);\r\noff += scnprintf(strbuf + off, size - off, "%s BAR%hhu, ",\r\nidt_get_mw_name(data), ndev->mws[idx].bar);\r\noff += scnprintf(strbuf + off, size - off,\r\n"Address align 0x%08llx, ", ndev->mws[idx].addr_align);\r\noff += scnprintf(strbuf + off, size - off,\r\n"Size align 0x%08llx, Size max %llu\n",\r\nndev->mws[idx].size_align, ndev->mws[idx].size_max);\r\n}\r\nfor (pidx = 0; pidx < ndev->peer_cnt; pidx++) {\r\noff += scnprintf(strbuf + off, size - off,\r\n"Inbound Memory Windows for peer %hhu (Port %hhu):\n",\r\npidx, ndev->peers[pidx].port);\r\nfor (idx = 0; idx < ndev->peers[pidx].mw_cnt; idx += cnt) {\r\ndata = ndev->peers[pidx].mws[idx].type;\r\ncnt = idt_get_mw_count(data);\r\nif (data == IDT_MW_DIR)\r\noff += scnprintf(strbuf + off, size - off,\r\n"\t%hhu.\t", idx);\r\nelse\r\noff += scnprintf(strbuf + off, size - off,\r\n"\t%hhu-%hhu.\t", idx, idx + cnt - 1);\r\noff += scnprintf(strbuf + off, size - off,\r\n"%s BAR%hhu, ", idt_get_mw_name(data),\r\nndev->peers[pidx].mws[idx].bar);\r\noff += scnprintf(strbuf + off, size - off,\r\n"Address align 0x%08llx, ",\r\nndev->peers[pidx].mws[idx].addr_align);\r\noff += scnprintf(strbuf + off, size - off,\r\n"Size align 0x%08llx, Size max %llu\n",\r\nndev->peers[pidx].mws[idx].size_align,\r\nndev->peers[pidx].mws[idx].size_max);\r\n}\r\n}\r\noff += scnprintf(strbuf + off, size - off, "\n");\r\ndata = idt_sw_read(ndev, IDT_SW_GDBELLSTS);\r\noff += scnprintf(strbuf + off, size - off,\r\n"Global Doorbell state\t- 0x%08x\n", data);\r\ndata = idt_ntb_db_read(&ndev->ntb);\r\noff += scnprintf(strbuf + off, size - off,\r\n"Local Doorbell state\t- 0x%08x\n", data);\r\ndata = idt_nt_read(ndev, IDT_NT_INDBELLMSK);\r\noff += scnprintf(strbuf + off, size - off,\r\n"Local Doorbell mask\t- 0x%08x\n", data);\r\noff += scnprintf(strbuf + off, size - off, "\n");\r\noff += scnprintf(strbuf + off, size - off,\r\n"Message event valid\t- 0x%08x\n", IDT_MSG_MASK);\r\ndata = idt_ntb_msg_read_sts(&ndev->ntb);\r\noff += scnprintf(strbuf + off, size - off,\r\n"Message event status\t- 0x%08x\n", data);\r\ndata = idt_nt_read(ndev, IDT_NT_MSGSTSMSK);\r\noff += scnprintf(strbuf + off, size - off,\r\n"Message event mask\t- 0x%08x\n", data);\r\noff += scnprintf(strbuf + off, size - off,\r\n"Message data:\n");\r\nfor (idx = 0; idx < IDT_MSG_CNT; idx++) {\r\nint src;\r\n(void)idt_ntb_msg_read(&ndev->ntb, idx, &src, &data);\r\noff += scnprintf(strbuf + off, size - off,\r\n"\t%hhu. 0x%08x from peer %hhu (Port %hhu)\n",\r\nidx, data, src, ndev->peers[src].port);\r\n}\r\noff += scnprintf(strbuf + off, size - off, "\n");\r\nidt_read_temp(ndev, &temp, &frac);\r\noff += scnprintf(strbuf + off, size - off,\r\n"Switch temperature\t\t- %hhu.%hhuC\n", temp, frac);\r\nret = simple_read_from_buffer(ubuf, count, offp, strbuf, off);\r\nkfree(strbuf);\r\nreturn ret;\r\n}\r\nstatic int idt_init_dbgfs(struct idt_ntb_dev *ndev)\r\n{\r\nchar devname[64];\r\nif (IS_ERR_OR_NULL(dbgfs_topdir)) {\r\ndev_info(&ndev->ntb.pdev->dev, "Top DebugFS directory absent");\r\nreturn PTR_ERR(dbgfs_topdir);\r\n}\r\nsnprintf(devname, 64, "info:%s", pci_name(ndev->ntb.pdev));\r\nndev->dbgfs_info = debugfs_create_file(devname, 0400, dbgfs_topdir,\r\nndev, &idt_dbgfs_info_ops);\r\nif (IS_ERR(ndev->dbgfs_info)) {\r\ndev_dbg(&ndev->ntb.pdev->dev, "Failed to create DebugFS node");\r\nreturn PTR_ERR(ndev->dbgfs_info);\r\n}\r\ndev_dbg(&ndev->ntb.pdev->dev, "NTB device DebugFS node created");\r\nreturn 0;\r\n}\r\nstatic void idt_deinit_dbgfs(struct idt_ntb_dev *ndev)\r\n{\r\ndebugfs_remove(ndev->dbgfs_info);\r\ndev_dbg(&ndev->ntb.pdev->dev, "NTB device DebugFS node discarded");\r\n}\r\nstatic int idt_check_setup(struct pci_dev *pdev)\r\n{\r\nu32 data;\r\nint ret;\r\nret = pci_read_config_dword(pdev, IDT_NT_BARSETUP0, &data);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev,\r\n"Failed to read BARSETUP0 config register");\r\nreturn ret;\r\n}\r\nif (!(data & IDT_BARSETUP_EN) || !(data & IDT_BARSETUP_MODE_CFG)) {\r\ndev_err(&pdev->dev, "BAR0 doesn't map config space");\r\nreturn -EINVAL;\r\n}\r\nif ((data & IDT_BARSETUP_SIZE_MASK) != IDT_BARSETUP_SIZE_CFG) {\r\ndev_err(&pdev->dev, "Invalid size of config space");\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(&pdev->dev, "NTB device pre-initialized correctly");\r\nreturn 0;\r\n}\r\nstatic struct idt_ntb_dev *idt_create_dev(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nstruct idt_ntb_dev *ndev;\r\nndev = devm_kzalloc(&pdev->dev, sizeof(*ndev), GFP_KERNEL);\r\nif (IS_ERR_OR_NULL(ndev)) {\r\ndev_err(&pdev->dev, "Memory allocation failed for descriptor");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nndev->swcfg = (struct idt_89hpes_cfg *)id->driver_data;\r\nndev->ntb.pdev = pdev;\r\nspin_lock_init(&ndev->db_mask_lock);\r\nspin_lock_init(&ndev->msg_mask_lock);\r\nspin_lock_init(&ndev->gasa_lock);\r\ndev_info(&pdev->dev, "IDT %s discovered", ndev->swcfg->name);\r\ndev_dbg(&pdev->dev, "NTB device descriptor created");\r\nreturn ndev;\r\n}\r\nstatic int idt_init_pci(struct idt_ntb_dev *ndev)\r\n{\r\nstruct pci_dev *pdev = ndev->ntb.pdev;\r\nint ret;\r\nret = pci_set_dma_mask(pdev, DMA_BIT_MASK(64));\r\nif (ret != 0) {\r\nret = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (ret != 0) {\r\ndev_err(&pdev->dev, "Failed to set DMA bit mask\n");\r\nreturn ret;\r\n}\r\ndev_warn(&pdev->dev, "Cannot set DMA highmem bit mask\n");\r\n}\r\nret = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(64));\r\nif (ret != 0) {\r\nret = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (ret != 0) {\r\ndev_err(&pdev->dev,\r\n"Failed to set consistent DMA bit mask\n");\r\nreturn ret;\r\n}\r\ndev_warn(&pdev->dev,\r\n"Cannot set consistent DMA highmem bit mask\n");\r\n}\r\nret = pci_enable_pcie_error_reporting(pdev);\r\nif (ret != 0)\r\ndev_warn(&pdev->dev, "PCIe AER capability disabled\n");\r\nelse\r\npci_cleanup_aer_uncorrect_error_status(pdev);\r\nret = pcim_enable_device(pdev);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev, "Failed to enable PCIe device\n");\r\ngoto err_disable_aer;\r\n}\r\npci_set_master(pdev);\r\nret = pcim_iomap_regions_request_all(pdev, 1, NTB_NAME);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev, "Failed to request resources\n");\r\ngoto err_clear_master;\r\n}\r\nndev->cfgspc = pcim_iomap_table(pdev)[0];\r\npci_set_drvdata(pdev, ndev);\r\ndev_dbg(&pdev->dev, "NT-function PCIe interface initialized");\r\nreturn 0;\r\nerr_clear_master:\r\npci_clear_master(pdev);\r\nerr_disable_aer:\r\n(void)pci_disable_pcie_error_reporting(pdev);\r\nreturn ret;\r\n}\r\nstatic void idt_deinit_pci(struct idt_ntb_dev *ndev)\r\n{\r\nstruct pci_dev *pdev = ndev->ntb.pdev;\r\npci_set_drvdata(pdev, NULL);\r\npci_clear_master(pdev);\r\n(void)pci_disable_pcie_error_reporting(pdev);\r\ndev_dbg(&pdev->dev, "NT-function PCIe interface cleared");\r\n}\r\nstatic int idt_pci_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nstruct idt_ntb_dev *ndev;\r\nint ret;\r\nret = idt_check_setup(pdev);\r\nif (ret != 0)\r\nreturn ret;\r\nndev = idt_create_dev(pdev, id);\r\nif (IS_ERR_OR_NULL(ndev))\r\nreturn PTR_ERR(ndev);\r\nret = idt_init_pci(ndev);\r\nif (ret != 0)\r\nreturn ret;\r\n(void)idt_scan_ports(ndev);\r\nidt_init_link(ndev);\r\nret = idt_init_mws(ndev);\r\nif (ret != 0)\r\ngoto err_deinit_link;\r\nidt_init_msg(ndev);\r\nret = idt_init_isr(ndev);\r\nif (ret != 0)\r\ngoto err_deinit_link;\r\nret = idt_register_device(ndev);\r\nif (ret != 0)\r\ngoto err_deinit_isr;\r\n(void)idt_init_dbgfs(ndev);\r\ndev_info(&pdev->dev, "IDT NTB device is ready");\r\nreturn 0;\r\nerr_deinit_isr:\r\nidt_deinit_isr(ndev);\r\nerr_deinit_link:\r\nidt_deinit_link(ndev);\r\nidt_deinit_pci(ndev);\r\nreturn ret;\r\n}\r\nstatic void idt_pci_remove(struct pci_dev *pdev)\r\n{\r\nstruct idt_ntb_dev *ndev = pci_get_drvdata(pdev);\r\nidt_deinit_dbgfs(ndev);\r\nidt_unregister_device(ndev);\r\nidt_deinit_isr(ndev);\r\nidt_deinit_link(ndev);\r\nidt_deinit_pci(ndev);\r\ndev_info(&pdev->dev, "IDT NTB device is removed");\r\n}\r\nstatic int __init idt_pci_driver_init(void)\r\n{\r\npr_info("%s %s\n", NTB_DESC, NTB_VER);\r\nif (debugfs_initialized())\r\ndbgfs_topdir = debugfs_create_dir(KBUILD_MODNAME, NULL);\r\nreturn pci_register_driver(&idt_pci_driver);\r\n}\r\nstatic void __exit idt_pci_driver_exit(void)\r\n{\r\npci_unregister_driver(&idt_pci_driver);\r\ndebugfs_remove_recursive(dbgfs_topdir);\r\n}
