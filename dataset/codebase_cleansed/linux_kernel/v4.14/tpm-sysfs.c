static ssize_t pubek_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nu8 *data;\r\nstruct tpm_cmd_t tpm_cmd;\r\nssize_t err;\r\nint i, rc;\r\nchar *str = buf;\r\nstruct tpm_chip *chip = to_tpm_chip(dev);\r\nmemset(&tpm_cmd, 0, sizeof(tpm_cmd));\r\ntpm_cmd.header.in = tpm_readpubek_header;\r\nerr = tpm_transmit_cmd(chip, NULL, &tpm_cmd, READ_PUBEK_RESULT_SIZE,\r\nREAD_PUBEK_RESULT_MIN_BODY_SIZE, 0,\r\n"attempting to read the PUBEK");\r\nif (err)\r\ngoto out;\r\ndata = tpm_cmd.params.readpubek_out_buffer;\r\nstr +=\r\nsprintf(str,\r\n"Algorithm: %02X %02X %02X %02X\n"\r\n"Encscheme: %02X %02X\n"\r\n"Sigscheme: %02X %02X\n"\r\n"Parameters: %02X %02X %02X %02X "\r\n"%02X %02X %02X %02X "\r\n"%02X %02X %02X %02X\n"\r\n"Modulus length: %d\n"\r\n"Modulus:\n",\r\ndata[0], data[1], data[2], data[3],\r\ndata[4], data[5],\r\ndata[6], data[7],\r\ndata[12], data[13], data[14], data[15],\r\ndata[16], data[17], data[18], data[19],\r\ndata[20], data[21], data[22], data[23],\r\nbe32_to_cpu(*((__be32 *) (data + 24))));\r\nfor (i = 0; i < 256; i++) {\r\nstr += sprintf(str, "%02X ", data[i + 28]);\r\nif ((i + 1) % 16 == 0)\r\nstr += sprintf(str, "\n");\r\n}\r\nout:\r\nrc = str - buf;\r\nreturn rc;\r\n}\r\nstatic ssize_t pcrs_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\ncap_t cap;\r\nu8 digest[TPM_DIGEST_SIZE];\r\nssize_t rc;\r\nint i, j, num_pcrs;\r\nchar *str = buf;\r\nstruct tpm_chip *chip = to_tpm_chip(dev);\r\nrc = tpm_getcap(chip, TPM_CAP_PROP_PCR, &cap,\r\n"attempting to determine the number of PCRS",\r\nsizeof(cap.num_pcrs));\r\nif (rc)\r\nreturn 0;\r\nnum_pcrs = be32_to_cpu(cap.num_pcrs);\r\nfor (i = 0; i < num_pcrs; i++) {\r\nrc = tpm_pcr_read_dev(chip, i, digest);\r\nif (rc)\r\nbreak;\r\nstr += sprintf(str, "PCR-%02d: ", i);\r\nfor (j = 0; j < TPM_DIGEST_SIZE; j++)\r\nstr += sprintf(str, "%02X ", digest[j]);\r\nstr += sprintf(str, "\n");\r\n}\r\nreturn str - buf;\r\n}\r\nstatic ssize_t enabled_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\ncap_t cap;\r\nssize_t rc;\r\nrc = tpm_getcap(to_tpm_chip(dev), TPM_CAP_FLAG_PERM, &cap,\r\n"attempting to determine the permanent enabled state",\r\nsizeof(cap.perm_flags));\r\nif (rc)\r\nreturn 0;\r\nrc = sprintf(buf, "%d\n", !cap.perm_flags.disable);\r\nreturn rc;\r\n}\r\nstatic ssize_t active_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\ncap_t cap;\r\nssize_t rc;\r\nrc = tpm_getcap(to_tpm_chip(dev), TPM_CAP_FLAG_PERM, &cap,\r\n"attempting to determine the permanent active state",\r\nsizeof(cap.perm_flags));\r\nif (rc)\r\nreturn 0;\r\nrc = sprintf(buf, "%d\n", !cap.perm_flags.deactivated);\r\nreturn rc;\r\n}\r\nstatic ssize_t owned_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\ncap_t cap;\r\nssize_t rc;\r\nrc = tpm_getcap(to_tpm_chip(dev), TPM_CAP_PROP_OWNER, &cap,\r\n"attempting to determine the owner state",\r\nsizeof(cap.owned));\r\nif (rc)\r\nreturn 0;\r\nrc = sprintf(buf, "%d\n", cap.owned);\r\nreturn rc;\r\n}\r\nstatic ssize_t temp_deactivated_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\ncap_t cap;\r\nssize_t rc;\r\nrc = tpm_getcap(to_tpm_chip(dev), TPM_CAP_FLAG_VOL, &cap,\r\n"attempting to determine the temporary state",\r\nsizeof(cap.stclear_flags));\r\nif (rc)\r\nreturn 0;\r\nrc = sprintf(buf, "%d\n", cap.stclear_flags.deactivated);\r\nreturn rc;\r\n}\r\nstatic ssize_t caps_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct tpm_chip *chip = to_tpm_chip(dev);\r\ncap_t cap;\r\nssize_t rc;\r\nchar *str = buf;\r\nrc = tpm_getcap(chip, TPM_CAP_PROP_MANUFACTURER, &cap,\r\n"attempting to determine the manufacturer",\r\nsizeof(cap.manufacturer_id));\r\nif (rc)\r\nreturn 0;\r\nstr += sprintf(str, "Manufacturer: 0x%x\n",\r\nbe32_to_cpu(cap.manufacturer_id));\r\nrc = tpm_getcap(chip, TPM_CAP_VERSION_1_2, &cap,\r\n"attempting to determine the 1.2 version",\r\nsizeof(cap.tpm_version_1_2));\r\nif (!rc) {\r\nstr += sprintf(str,\r\n"TCG version: %d.%d\nFirmware version: %d.%d\n",\r\ncap.tpm_version_1_2.Major,\r\ncap.tpm_version_1_2.Minor,\r\ncap.tpm_version_1_2.revMajor,\r\ncap.tpm_version_1_2.revMinor);\r\n} else {\r\nrc = tpm_getcap(chip, TPM_CAP_VERSION_1_1, &cap,\r\n"attempting to determine the 1.1 version",\r\nsizeof(cap.tpm_version));\r\nif (rc)\r\nreturn 0;\r\nstr += sprintf(str,\r\n"TCG version: %d.%d\nFirmware version: %d.%d\n",\r\ncap.tpm_version.Major,\r\ncap.tpm_version.Minor,\r\ncap.tpm_version.revMajor,\r\ncap.tpm_version.revMinor);\r\n}\r\nreturn str - buf;\r\n}\r\nstatic ssize_t cancel_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct tpm_chip *chip = to_tpm_chip(dev);\r\nif (chip == NULL)\r\nreturn 0;\r\nchip->ops->cancel(chip);\r\nreturn count;\r\n}\r\nstatic ssize_t durations_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct tpm_chip *chip = to_tpm_chip(dev);\r\nif (chip->duration[TPM_LONG] == 0)\r\nreturn 0;\r\nreturn sprintf(buf, "%d %d %d [%s]\n",\r\njiffies_to_usecs(chip->duration[TPM_SHORT]),\r\njiffies_to_usecs(chip->duration[TPM_MEDIUM]),\r\njiffies_to_usecs(chip->duration[TPM_LONG]),\r\nchip->duration_adjusted\r\n? "adjusted" : "original");\r\n}\r\nstatic ssize_t timeouts_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct tpm_chip *chip = to_tpm_chip(dev);\r\nreturn sprintf(buf, "%d %d %d %d [%s]\n",\r\njiffies_to_usecs(chip->timeout_a),\r\njiffies_to_usecs(chip->timeout_b),\r\njiffies_to_usecs(chip->timeout_c),\r\njiffies_to_usecs(chip->timeout_d),\r\nchip->timeout_adjusted\r\n? "adjusted" : "original");\r\n}\r\nvoid tpm_sysfs_add_device(struct tpm_chip *chip)\r\n{\r\nif (chip->flags & TPM_CHIP_FLAG_TPM2)\r\nreturn;\r\nWARN_ON(chip->groups_cnt != 0);\r\nchip->groups[chip->groups_cnt++] = &tpm_dev_group;\r\n}
