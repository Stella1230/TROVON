static inline struct mtk_ref2usb_tx *to_mtk_ref2usb_tx(struct clk_hw *hw)\r\n{\r\nreturn container_of(hw, struct mtk_ref2usb_tx, hw);\r\n}\r\nstatic int mtk_ref2usb_tx_is_prepared(struct clk_hw *hw)\r\n{\r\nstruct mtk_ref2usb_tx *tx = to_mtk_ref2usb_tx(hw);\r\nreturn (readl(tx->base_addr) & REF2USB_EN_MASK) == REF2USB_EN_MASK;\r\n}\r\nstatic int mtk_ref2usb_tx_prepare(struct clk_hw *hw)\r\n{\r\nstruct mtk_ref2usb_tx *tx = to_mtk_ref2usb_tx(hw);\r\nu32 val;\r\nval = readl(tx->base_addr);\r\nval |= REF2USB_TX_EN;\r\nwritel(val, tx->base_addr);\r\nudelay(100);\r\nval |= REF2USB_TX_LPF_EN;\r\nwritel(val, tx->base_addr);\r\nval |= REF2USB_TX_OUT_EN;\r\nwritel(val, tx->base_addr);\r\nreturn 0;\r\n}\r\nstatic void mtk_ref2usb_tx_unprepare(struct clk_hw *hw)\r\n{\r\nstruct mtk_ref2usb_tx *tx = to_mtk_ref2usb_tx(hw);\r\nu32 val;\r\nval = readl(tx->base_addr);\r\nval &= ~REF2USB_EN_MASK;\r\nwritel(val, tx->base_addr);\r\n}\r\nstruct clk * __init mtk_clk_register_ref2usb_tx(const char *name,\r\nconst char *parent_name, void __iomem *reg)\r\n{\r\nstruct mtk_ref2usb_tx *tx;\r\nstruct clk_init_data init = {};\r\nstruct clk *clk;\r\ntx = kzalloc(sizeof(*tx), GFP_KERNEL);\r\nif (!tx)\r\nreturn ERR_PTR(-ENOMEM);\r\ntx->base_addr = reg;\r\ntx->hw.init = &init;\r\ninit.name = name;\r\ninit.ops = &mtk_ref2usb_tx_ops;\r\ninit.parent_names = &parent_name;\r\ninit.num_parents = 1;\r\nclk = clk_register(NULL, &tx->hw);\r\nif (IS_ERR(clk)) {\r\npr_err("Failed to register clk %s: %ld\n", name, PTR_ERR(clk));\r\nkfree(tx);\r\n}\r\nreturn clk;\r\n}
