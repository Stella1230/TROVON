static int msm_fault_handler(struct iommu_domain *domain, struct device *dev,\r\nunsigned long iova, int flags, void *arg)\r\n{\r\nstruct msm_iommu *iommu = arg;\r\nif (iommu->base.handler)\r\nreturn iommu->base.handler(iommu->base.arg, iova, flags);\r\npr_warn_ratelimited("*** fault: iova=%08lx, flags=%d\n", iova, flags);\r\nreturn 0;\r\n}\r\nstatic int msm_iommu_attach(struct msm_mmu *mmu, const char * const *names,\r\nint cnt)\r\n{\r\nstruct msm_iommu *iommu = to_msm_iommu(mmu);\r\nint ret;\r\npm_runtime_get_sync(mmu->dev);\r\nret = iommu_attach_device(iommu->domain, mmu->dev);\r\npm_runtime_put_sync(mmu->dev);\r\nreturn ret;\r\n}\r\nstatic void msm_iommu_detach(struct msm_mmu *mmu, const char * const *names,\r\nint cnt)\r\n{\r\nstruct msm_iommu *iommu = to_msm_iommu(mmu);\r\npm_runtime_get_sync(mmu->dev);\r\niommu_detach_device(iommu->domain, mmu->dev);\r\npm_runtime_put_sync(mmu->dev);\r\n}\r\nstatic int msm_iommu_map(struct msm_mmu *mmu, uint64_t iova,\r\nstruct sg_table *sgt, unsigned len, int prot)\r\n{\r\nstruct msm_iommu *iommu = to_msm_iommu(mmu);\r\nsize_t ret;\r\nret = iommu_map_sg(iommu->domain, iova, sgt->sgl, sgt->nents, prot);\r\nWARN_ON(ret < 0);\r\nreturn (ret == len) ? 0 : -EINVAL;\r\n}\r\nstatic int msm_iommu_unmap(struct msm_mmu *mmu, uint64_t iova,\r\nstruct sg_table *sgt, unsigned len)\r\n{\r\nstruct msm_iommu *iommu = to_msm_iommu(mmu);\r\npm_runtime_get_sync(mmu->dev);\r\niommu_unmap(iommu->domain, iova, len);\r\npm_runtime_put_sync(mmu->dev);\r\nreturn 0;\r\n}\r\nstatic void msm_iommu_destroy(struct msm_mmu *mmu)\r\n{\r\nstruct msm_iommu *iommu = to_msm_iommu(mmu);\r\niommu_domain_free(iommu->domain);\r\nkfree(iommu);\r\n}\r\nstruct msm_mmu *msm_iommu_new(struct device *dev, struct iommu_domain *domain)\r\n{\r\nstruct msm_iommu *iommu;\r\niommu = kzalloc(sizeof(*iommu), GFP_KERNEL);\r\nif (!iommu)\r\nreturn ERR_PTR(-ENOMEM);\r\niommu->domain = domain;\r\nmsm_mmu_init(&iommu->base, dev, &funcs);\r\niommu_set_fault_handler(domain, msm_fault_handler, iommu);\r\nreturn &iommu->base;\r\n}
