union acpi_parse_object *acpi_ps_get_parent_scope(struct acpi_parse_state\r\n*parser_state)\r\n{\r\nreturn (parser_state->scope->parse_scope.op);\r\n}\r\nu8 acpi_ps_has_completed_scope(struct acpi_parse_state * parser_state)\r\n{\r\nreturn ((u8)\r\n((parser_state->aml >= parser_state->scope->parse_scope.arg_end\r\n|| !parser_state->scope->parse_scope.arg_count)));\r\n}\r\nacpi_status\r\nacpi_ps_init_scope(struct acpi_parse_state * parser_state,\r\nunion acpi_parse_object * root_op)\r\n{\r\nunion acpi_generic_state *scope;\r\nACPI_FUNCTION_TRACE_PTR(ps_init_scope, root_op);\r\nscope = acpi_ut_create_generic_state();\r\nif (!scope) {\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\nscope->common.descriptor_type = ACPI_DESC_TYPE_STATE_RPSCOPE;\r\nscope->parse_scope.op = root_op;\r\nscope->parse_scope.arg_count = ACPI_VAR_ARGS;\r\nscope->parse_scope.arg_end = parser_state->aml_end;\r\nscope->parse_scope.pkg_end = parser_state->aml_end;\r\nparser_state->scope = scope;\r\nparser_state->start_op = root_op;\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nacpi_status\r\nacpi_ps_push_scope(struct acpi_parse_state *parser_state,\r\nunion acpi_parse_object *op,\r\nu32 remaining_args, u32 arg_count)\r\n{\r\nunion acpi_generic_state *scope;\r\nACPI_FUNCTION_TRACE_PTR(ps_push_scope, op);\r\nscope = acpi_ut_create_generic_state();\r\nif (!scope) {\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\nscope->common.descriptor_type = ACPI_DESC_TYPE_STATE_PSCOPE;\r\nscope->parse_scope.op = op;\r\nscope->parse_scope.arg_list = remaining_args;\r\nscope->parse_scope.arg_count = arg_count;\r\nscope->parse_scope.pkg_end = parser_state->pkg_end;\r\nacpi_ut_push_generic_state(&parser_state->scope, scope);\r\nif (arg_count == ACPI_VAR_ARGS) {\r\nscope->parse_scope.arg_end = parser_state->pkg_end;\r\n} else {\r\nscope->parse_scope.arg_end = ACPI_TO_POINTER(ACPI_MAX_PTR);\r\n}\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nvoid\r\nacpi_ps_pop_scope(struct acpi_parse_state *parser_state,\r\nunion acpi_parse_object **op, u32 * arg_list, u32 * arg_count)\r\n{\r\nunion acpi_generic_state *scope = parser_state->scope;\r\nACPI_FUNCTION_TRACE(ps_pop_scope);\r\nif (scope->common.next) {\r\nscope = acpi_ut_pop_generic_state(&parser_state->scope);\r\n*op = scope->parse_scope.op;\r\n*arg_list = scope->parse_scope.arg_list;\r\n*arg_count = scope->parse_scope.arg_count;\r\nparser_state->pkg_end = scope->parse_scope.pkg_end;\r\nacpi_ut_delete_generic_state(scope);\r\n} else {\r\n*op = NULL;\r\n*arg_list = 0;\r\n*arg_count = 0;\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_PARSE,\r\n"Popped Op %p Args %X\n", *op, *arg_count));\r\nreturn_VOID;\r\n}\r\nvoid acpi_ps_cleanup_scope(struct acpi_parse_state *parser_state)\r\n{\r\nunion acpi_generic_state *scope;\r\nACPI_FUNCTION_TRACE_PTR(ps_cleanup_scope, parser_state);\r\nif (!parser_state) {\r\nreturn_VOID;\r\n}\r\nwhile (parser_state->scope) {\r\nscope = acpi_ut_pop_generic_state(&parser_state->scope);\r\nacpi_ut_delete_generic_state(scope);\r\n}\r\nreturn_VOID;\r\n}
