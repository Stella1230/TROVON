static void vtg_register(struct sti_vtg *vtg)\r\n{\r\nlist_add_tail(&vtg->link, &vtg_lookup);\r\n}\r\nstruct sti_vtg *of_vtg_find(struct device_node *np)\r\n{\r\nstruct sti_vtg *vtg;\r\nlist_for_each_entry(vtg, &vtg_lookup, link) {\r\nif (vtg->np == np)\r\nreturn vtg;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void vtg_reset(struct sti_vtg *vtg)\r\n{\r\nwritel(1, vtg->regs + VTG_DRST_AUTOC);\r\n}\r\nstatic void vtg_set_output_window(void __iomem *regs,\r\nconst struct drm_display_mode *mode)\r\n{\r\nu32 video_top_field_start;\r\nu32 video_top_field_stop;\r\nu32 video_bottom_field_start;\r\nu32 video_bottom_field_stop;\r\nu32 xstart = sti_vtg_get_pixel_number(*mode, 0);\r\nu32 ystart = sti_vtg_get_line_number(*mode, 0);\r\nu32 xstop = sti_vtg_get_pixel_number(*mode, mode->hdisplay - 1);\r\nu32 ystop = sti_vtg_get_line_number(*mode, mode->vdisplay - 1);\r\nvideo_top_field_start = (ystart << 16) | xstart;\r\nvideo_top_field_stop = (ystop << 16) | xstop;\r\nvideo_bottom_field_start = video_top_field_start;\r\nvideo_bottom_field_stop = video_top_field_stop;\r\nwritel(video_top_field_start, regs + VTG_VID_TFO);\r\nwritel(video_top_field_stop, regs + VTG_VID_TFS);\r\nwritel(video_bottom_field_start, regs + VTG_VID_BFO);\r\nwritel(video_bottom_field_stop, regs + VTG_VID_BFS);\r\n}\r\nstatic void vtg_set_hsync_vsync_pos(struct sti_vtg_sync_params *sync,\r\nint delay,\r\nconst struct drm_display_mode *mode)\r\n{\r\nlong clocksperline, start, stop;\r\nu32 risesync_top, fallsync_top;\r\nu32 risesync_offs_top, fallsync_offs_top;\r\nclocksperline = mode->htotal;\r\nstart = 0;\r\nstop = mode->hsync_end - mode->hsync_start;\r\nstart += delay;\r\nstop += delay;\r\nif (start < 0)\r\nstart += clocksperline;\r\nelse if (start >= clocksperline)\r\nstart -= clocksperline;\r\nif (stop < 0)\r\nstop += clocksperline;\r\nelse if (stop >= clocksperline)\r\nstop -= clocksperline;\r\nsync->hsync = (stop << 16) | start;\r\nif (delay >= 0) {\r\nrisesync_top = 1;\r\nfallsync_top = risesync_top;\r\nfallsync_top += mode->vsync_end - mode->vsync_start;\r\nfallsync_offs_top = (u32)delay;\r\nrisesync_offs_top = (u32)delay;\r\n} else {\r\nrisesync_top = mode->vtotal;\r\nfallsync_top = mode->vsync_end - mode->vsync_start;\r\nfallsync_offs_top = clocksperline + delay;\r\nrisesync_offs_top = clocksperline + delay;\r\n}\r\nsync->vsync_line_top = (fallsync_top << 16) | risesync_top;\r\nsync->vsync_off_top = (fallsync_offs_top << 16) | risesync_offs_top;\r\nsync->vsync_line_bot = sync->vsync_line_top;\r\nsync->vsync_off_bot = sync->vsync_off_top;\r\n}\r\nstatic void vtg_set_mode(struct sti_vtg *vtg,\r\nint type,\r\nstruct sti_vtg_sync_params *sync,\r\nconst struct drm_display_mode *mode)\r\n{\r\nunsigned int i;\r\nwritel(mode->htotal, vtg->regs + VTG_CLKLN);\r\nwritel(mode->vtotal * 2, vtg->regs + VTG_HLFLN);\r\nvtg_set_output_window(vtg->regs, mode);\r\nvtg_set_hsync_vsync_pos(&sync[VTG_SYNC_ID_HDMI - 1], HDMI_DELAY, mode);\r\nvtg_set_hsync_vsync_pos(&sync[VTG_SYNC_ID_HDDCS - 1], 0, mode);\r\nvtg_set_hsync_vsync_pos(&sync[VTG_SYNC_ID_HDF - 1], AWG_DELAY_HD, mode);\r\nvtg_set_hsync_vsync_pos(&sync[VTG_SYNC_ID_DVO - 1], DVO_DELAY, mode);\r\nfor (i = 0; i < VTG_MAX_SYNC_OUTPUT ; i++) {\r\nwritel(sync[i].hsync,\r\nvtg->regs + vtg_regs_offs[i].h_hd);\r\nwritel(sync[i].vsync_line_top,\r\nvtg->regs + vtg_regs_offs[i].top_v_vd);\r\nwritel(sync[i].vsync_line_bot,\r\nvtg->regs + vtg_regs_offs[i].bot_v_vd);\r\nwritel(sync[i].vsync_off_top,\r\nvtg->regs + vtg_regs_offs[i].top_v_hd);\r\nwritel(sync[i].vsync_off_bot,\r\nvtg->regs + vtg_regs_offs[i].bot_v_hd);\r\n}\r\nwritel(type, vtg->regs + VTG_MODE);\r\n}\r\nstatic void vtg_enable_irq(struct sti_vtg *vtg)\r\n{\r\nwritel(0xFFFF, vtg->regs + VTG_HOST_ITS_BCLR);\r\nwritel(0xFFFF, vtg->regs + VTG_HOST_ITM_BCLR);\r\nwritel(VTG_IRQ_MASK, vtg->regs + VTG_HOST_ITM_BSET);\r\n}\r\nvoid sti_vtg_set_config(struct sti_vtg *vtg,\r\nconst struct drm_display_mode *mode)\r\n{\r\nvtg_set_mode(vtg, VTG_MODE_MASTER, vtg->sync_params, mode);\r\nvtg_reset(vtg);\r\nvtg_enable_irq(vtg);\r\n}\r\nu32 sti_vtg_get_line_number(struct drm_display_mode mode, int y)\r\n{\r\nu32 start_line = mode.vtotal - mode.vsync_start + 1;\r\nif (mode.flags & DRM_MODE_FLAG_INTERLACE)\r\nstart_line *= 2;\r\nreturn start_line + y;\r\n}\r\nu32 sti_vtg_get_pixel_number(struct drm_display_mode mode, int x)\r\n{\r\nreturn mode.htotal - mode.hsync_start + x;\r\n}\r\nint sti_vtg_register_client(struct sti_vtg *vtg, struct notifier_block *nb,\r\nstruct drm_crtc *crtc)\r\n{\r\nvtg->crtc = crtc;\r\nreturn raw_notifier_chain_register(&vtg->notifier_list, nb);\r\n}\r\nint sti_vtg_unregister_client(struct sti_vtg *vtg, struct notifier_block *nb)\r\n{\r\nreturn raw_notifier_chain_unregister(&vtg->notifier_list, nb);\r\n}\r\nstatic irqreturn_t vtg_irq_thread(int irq, void *arg)\r\n{\r\nstruct sti_vtg *vtg = arg;\r\nu32 event;\r\nevent = (vtg->irq_status & VTG_IRQ_TOP) ?\r\nVTG_TOP_FIELD_EVENT : VTG_BOTTOM_FIELD_EVENT;\r\nraw_notifier_call_chain(&vtg->notifier_list, event, vtg->crtc);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t vtg_irq(int irq, void *arg)\r\n{\r\nstruct sti_vtg *vtg = arg;\r\nvtg->irq_status = readl(vtg->regs + VTG_HOST_ITS);\r\nwritel(vtg->irq_status, vtg->regs + VTG_HOST_ITS_BCLR);\r\nreadl(vtg->regs + VTG_HOST_ITS);\r\nreturn IRQ_WAKE_THREAD;\r\n}\r\nstatic int vtg_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct sti_vtg *vtg;\r\nstruct resource *res;\r\nint ret;\r\nvtg = devm_kzalloc(dev, sizeof(*vtg), GFP_KERNEL);\r\nif (!vtg)\r\nreturn -ENOMEM;\r\nvtg->dev = dev;\r\nvtg->np = pdev->dev.of_node;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nDRM_ERROR("Get memory resource failed\n");\r\nreturn -ENOMEM;\r\n}\r\nvtg->regs = devm_ioremap_nocache(dev, res->start, resource_size(res));\r\nif (!vtg->regs) {\r\nDRM_ERROR("failed to remap I/O memory\n");\r\nreturn -ENOMEM;\r\n}\r\nvtg->irq = platform_get_irq(pdev, 0);\r\nif (vtg->irq < 0) {\r\nDRM_ERROR("Failed to get VTG interrupt\n");\r\nreturn vtg->irq;\r\n}\r\nRAW_INIT_NOTIFIER_HEAD(&vtg->notifier_list);\r\nret = devm_request_threaded_irq(dev, vtg->irq, vtg_irq,\r\nvtg_irq_thread, IRQF_ONESHOT,\r\ndev_name(dev), vtg);\r\nif (ret < 0) {\r\nDRM_ERROR("Failed to register VTG interrupt\n");\r\nreturn ret;\r\n}\r\nvtg_register(vtg);\r\nplatform_set_drvdata(pdev, vtg);\r\nDRM_INFO("%s %s\n", __func__, dev_name(vtg->dev));\r\nreturn 0;\r\n}\r\nstatic int vtg_remove(struct platform_device *pdev)\r\n{\r\nreturn 0;\r\n}
