void qla4xxx_queue_mbox_cmd(struct scsi_qla_host *ha, uint32_t *mbx_cmd,\r\nint in_count)\r\n{\r\nint i;\r\nfor (i = 1; i < in_count; i++)\r\nwritel(mbx_cmd[i], &ha->reg->mailbox[i]);\r\nwritel(mbx_cmd[0], &ha->reg->mailbox[0]);\r\nreadl(&ha->reg->mailbox[0]);\r\nwritel(set_rmask(CSR_INTR_RISC), &ha->reg->ctrl_status);\r\nreadl(&ha->reg->ctrl_status);\r\n}\r\nvoid qla4xxx_process_mbox_intr(struct scsi_qla_host *ha, int out_count)\r\n{\r\nint intr_status;\r\nintr_status = readl(&ha->reg->ctrl_status);\r\nif (intr_status & INTR_PENDING) {\r\nha->mbox_status_count = out_count;\r\nha->isp_ops->interrupt_service_routine(ha, intr_status);\r\n}\r\n}\r\nstatic int qla4xxx_is_intr_poll_mode(struct scsi_qla_host *ha)\r\n{\r\nint rval = 1;\r\nif (is_qla8032(ha) || is_qla8042(ha)) {\r\nif (test_bit(AF_IRQ_ATTACHED, &ha->flags) &&\r\ntest_bit(AF_83XX_MBOX_INTR_ON, &ha->flags))\r\nrval = 0;\r\n} else {\r\nif (test_bit(AF_IRQ_ATTACHED, &ha->flags) &&\r\ntest_bit(AF_INTERRUPTS_ON, &ha->flags) &&\r\ntest_bit(AF_ONLINE, &ha->flags) &&\r\n!test_bit(AF_HA_REMOVAL, &ha->flags))\r\nrval = 0;\r\n}\r\nreturn rval;\r\n}\r\nint qla4xxx_mailbox_command(struct scsi_qla_host *ha, uint8_t inCount,\r\nuint8_t outCount, uint32_t *mbx_cmd,\r\nuint32_t *mbx_sts)\r\n{\r\nint status = QLA_ERROR;\r\nuint8_t i;\r\nu_long wait_count;\r\nunsigned long flags = 0;\r\nuint32_t dev_state;\r\nif (!mbx_cmd || !mbx_sts) {\r\nDEBUG2(printk("scsi%ld: %s: Invalid mbx_cmd or mbx_sts "\r\n"pointer\n", ha->host_no, __func__));\r\nreturn status;\r\n}\r\nif (is_qla40XX(ha)) {\r\nif (test_bit(AF_HA_REMOVAL, &ha->flags)) {\r\nDEBUG2(ql4_printk(KERN_WARNING, ha, "scsi%ld: %s: "\r\n"prematurely completing mbx cmd as "\r\n"adapter removal detected\n",\r\nha->host_no, __func__));\r\nreturn status;\r\n}\r\n}\r\nif ((is_aer_supported(ha)) &&\r\n(test_bit(AF_PCI_CHANNEL_IO_PERM_FAILURE, &ha->flags))) {\r\nDEBUG2(printk(KERN_WARNING "scsi%ld: %s: Perm failure on EEH, "\r\n"timeout MBX Exiting.\n", ha->host_no, __func__));\r\nreturn status;\r\n}\r\nwait_count = MBOX_TOV * 100;\r\nwhile (wait_count--) {\r\nmutex_lock(&ha->mbox_sem);\r\nif (!test_bit(AF_MBOX_COMMAND, &ha->flags)) {\r\nset_bit(AF_MBOX_COMMAND, &ha->flags);\r\nmutex_unlock(&ha->mbox_sem);\r\nbreak;\r\n}\r\nmutex_unlock(&ha->mbox_sem);\r\nif (!wait_count) {\r\nDEBUG2(printk("scsi%ld: %s: mbox_sem failed\n",\r\nha->host_no, __func__));\r\nreturn status;\r\n}\r\nmsleep(10);\r\n}\r\nif (is_qla80XX(ha)) {\r\nif (test_bit(AF_FW_RECOVERY, &ha->flags)) {\r\nDEBUG2(ql4_printk(KERN_WARNING, ha,\r\n"scsi%ld: %s: prematurely completing mbx cmd as firmware recovery detected\n",\r\nha->host_no, __func__));\r\ngoto mbox_exit;\r\n}\r\nha->isp_ops->idc_lock(ha);\r\ndev_state = qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_DEV_STATE);\r\nha->isp_ops->idc_unlock(ha);\r\nif (dev_state == QLA8XXX_DEV_FAILED) {\r\nql4_printk(KERN_WARNING, ha,\r\n"scsi%ld: %s: H/W is in failed state, do not send any mailbox commands\n",\r\nha->host_no, __func__);\r\ngoto mbox_exit;\r\n}\r\n}\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nha->mbox_status_count = outCount;\r\nfor (i = 0; i < outCount; i++)\r\nha->mbox_status[i] = 0;\r\nha->isp_ops->queue_mailbox_command(ha, mbx_cmd, inCount);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nif (outCount == 0) {\r\nstatus = QLA_SUCCESS;\r\ngoto mbox_exit;\r\n}\r\nif (qla4xxx_is_intr_poll_mode(ha)) {\r\nwait_count = jiffies + MBOX_TOV * HZ;\r\nwhile (test_bit(AF_MBOX_COMMAND_DONE, &ha->flags) == 0) {\r\nif (time_after_eq(jiffies, wait_count))\r\nbreak;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nha->isp_ops->process_mailbox_interrupt(ha, outCount);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nmsleep(10);\r\n}\r\n} else {\r\nset_bit(AF_MBOX_COMMAND_NOPOLL, &ha->flags);\r\nwait_for_completion_timeout(&ha->mbx_intr_comp, MBOX_TOV * HZ);\r\nclear_bit(AF_MBOX_COMMAND_NOPOLL, &ha->flags);\r\n}\r\nif (!test_bit(AF_MBOX_COMMAND_DONE, &ha->flags)) {\r\nif (is_qla80XX(ha) &&\r\ntest_bit(AF_FW_RECOVERY, &ha->flags)) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"scsi%ld: %s: prematurely completing mbx cmd as "\r\n"firmware recovery detected\n",\r\nha->host_no, __func__));\r\ngoto mbox_exit;\r\n}\r\nql4_printk(KERN_WARNING, ha, "scsi%ld: Mailbox Cmd 0x%08X timed out, Scheduling Adapter Reset\n",\r\nha->host_no, mbx_cmd[0]);\r\nha->mailbox_timeout_count++;\r\nmbx_sts[0] = (-1);\r\nset_bit(DPC_RESET_HA, &ha->dpc_flags);\r\nif (is_qla8022(ha)) {\r\nql4_printk(KERN_INFO, ha,\r\n"disabling pause transmit on port 0 & 1.\n");\r\nqla4_82xx_wr_32(ha, QLA82XX_CRB_NIU + 0x98,\r\nCRB_NIU_XG_PAUSE_CTL_P0 |\r\nCRB_NIU_XG_PAUSE_CTL_P1);\r\n} else if (is_qla8032(ha) || is_qla8042(ha)) {\r\nql4_printk(KERN_INFO, ha, " %s: disabling pause transmit on port 0 & 1.\n",\r\n__func__);\r\nqla4_83xx_disable_pause(ha);\r\n}\r\ngoto mbox_exit;\r\n}\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nfor (i = 0; i < outCount; i++)\r\nmbx_sts[i] = ha->mbox_status[i];\r\nswitch (ha->mbox_status[0]) {\r\ncase MBOX_STS_COMMAND_COMPLETE:\r\nstatus = QLA_SUCCESS;\r\nbreak;\r\ncase MBOX_STS_INTERMEDIATE_COMPLETION:\r\nstatus = QLA_SUCCESS;\r\nbreak;\r\ncase MBOX_STS_BUSY:\r\nql4_printk(KERN_WARNING, ha, "scsi%ld: %s: Cmd = %08X, ISP BUSY\n",\r\nha->host_no, __func__, mbx_cmd[0]);\r\nha->mailbox_timeout_count++;\r\nbreak;\r\ndefault:\r\nql4_printk(KERN_WARNING, ha, "scsi%ld: %s: FAILED, MBOX CMD = %08X, MBOX STS = %08X %08X %08X %08X %08X %08X %08X %08X\n",\r\nha->host_no, __func__, mbx_cmd[0], mbx_sts[0],\r\nmbx_sts[1], mbx_sts[2], mbx_sts[3], mbx_sts[4],\r\nmbx_sts[5], mbx_sts[6], mbx_sts[7]);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nmbox_exit:\r\nmutex_lock(&ha->mbox_sem);\r\nclear_bit(AF_MBOX_COMMAND, &ha->flags);\r\nmutex_unlock(&ha->mbox_sem);\r\nclear_bit(AF_MBOX_COMMAND_DONE, &ha->flags);\r\nreturn status;\r\n}\r\nint qla4xxx_get_minidump_template(struct scsi_qla_host *ha,\r\ndma_addr_t phys_addr)\r\n{\r\nuint32_t mbox_cmd[MBOX_REG_COUNT];\r\nuint32_t mbox_sts[MBOX_REG_COUNT];\r\nint status;\r\nmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\r\nmemset(&mbox_sts, 0, sizeof(mbox_sts));\r\nmbox_cmd[0] = MBOX_CMD_MINIDUMP;\r\nmbox_cmd[1] = MINIDUMP_GET_TMPLT_SUBCOMMAND;\r\nmbox_cmd[2] = LSDW(phys_addr);\r\nmbox_cmd[3] = MSDW(phys_addr);\r\nmbox_cmd[4] = ha->fw_dump_tmplt_size;\r\nmbox_cmd[5] = 0;\r\nstatus = qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 2, &mbox_cmd[0],\r\n&mbox_sts[0]);\r\nif (status != QLA_SUCCESS) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"scsi%ld: %s: Cmd = %08X, mbx[0] = 0x%04x, mbx[1] = 0x%04x\n",\r\nha->host_no, __func__, mbox_cmd[0],\r\nmbox_sts[0], mbox_sts[1]));\r\n}\r\nreturn status;\r\n}\r\nint qla4xxx_req_template_size(struct scsi_qla_host *ha)\r\n{\r\nuint32_t mbox_cmd[MBOX_REG_COUNT];\r\nuint32_t mbox_sts[MBOX_REG_COUNT];\r\nint status;\r\nmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\r\nmemset(&mbox_sts, 0, sizeof(mbox_sts));\r\nmbox_cmd[0] = MBOX_CMD_MINIDUMP;\r\nmbox_cmd[1] = MINIDUMP_GET_SIZE_SUBCOMMAND;\r\nstatus = qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 8, &mbox_cmd[0],\r\n&mbox_sts[0]);\r\nif (status == QLA_SUCCESS) {\r\nha->fw_dump_tmplt_size = mbox_sts[1];\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"%s: sts[0]=0x%04x, template size=0x%04x, size_cm_02=0x%04x, size_cm_04=0x%04x, size_cm_08=0x%04x, size_cm_10=0x%04x, size_cm_FF=0x%04x, version=0x%04x\n",\r\n__func__, mbox_sts[0], mbox_sts[1],\r\nmbox_sts[2], mbox_sts[3], mbox_sts[4],\r\nmbox_sts[5], mbox_sts[6], mbox_sts[7]));\r\nif (ha->fw_dump_tmplt_size == 0)\r\nstatus = QLA_ERROR;\r\n} else {\r\nql4_printk(KERN_WARNING, ha,\r\n"%s: Error sts[0]=0x%04x, mbx[1]=0x%04x\n",\r\n__func__, mbox_sts[0], mbox_sts[1]);\r\nstatus = QLA_ERROR;\r\n}\r\nreturn status;\r\n}\r\nvoid qla4xxx_mailbox_premature_completion(struct scsi_qla_host *ha)\r\n{\r\nset_bit(AF_FW_RECOVERY, &ha->flags);\r\nql4_printk(KERN_INFO, ha, "scsi%ld: %s: set FW RECOVERY!\n",\r\nha->host_no, __func__);\r\nif (test_bit(AF_MBOX_COMMAND, &ha->flags)) {\r\nif (test_bit(AF_MBOX_COMMAND_NOPOLL, &ha->flags)) {\r\ncomplete(&ha->mbx_intr_comp);\r\nql4_printk(KERN_INFO, ha, "scsi%ld: %s: Due to fw "\r\n"recovery, doing premature completion of "\r\n"mbx cmd\n", ha->host_no, __func__);\r\n} else {\r\nset_bit(AF_MBOX_COMMAND_DONE, &ha->flags);\r\nql4_printk(KERN_INFO, ha, "scsi%ld: %s: Due to fw "\r\n"recovery, doing premature completion of "\r\n"polling mbx cmd\n", ha->host_no, __func__);\r\n}\r\n}\r\n}\r\nstatic uint8_t\r\nqla4xxx_set_ifcb(struct scsi_qla_host *ha, uint32_t *mbox_cmd,\r\nuint32_t *mbox_sts, dma_addr_t init_fw_cb_dma)\r\n{\r\nmemset(mbox_cmd, 0, sizeof(mbox_cmd[0]) * MBOX_REG_COUNT);\r\nmemset(mbox_sts, 0, sizeof(mbox_sts[0]) * MBOX_REG_COUNT);\r\nif (is_qla8022(ha))\r\nqla4_82xx_wr_32(ha, ha->nx_db_wr_ptr, 0);\r\nmbox_cmd[0] = MBOX_CMD_INITIALIZE_FIRMWARE;\r\nmbox_cmd[1] = 0;\r\nmbox_cmd[2] = LSDW(init_fw_cb_dma);\r\nmbox_cmd[3] = MSDW(init_fw_cb_dma);\r\nmbox_cmd[4] = sizeof(struct addr_ctrl_blk);\r\nif (qla4xxx_mailbox_command(ha, 6, 6, mbox_cmd, mbox_sts) !=\r\nQLA_SUCCESS) {\r\nDEBUG2(printk(KERN_WARNING "scsi%ld: %s: "\r\n"MBOX_CMD_INITIALIZE_FIRMWARE"\r\n" failed w/ status %04X\n",\r\nha->host_no, __func__, mbox_sts[0]));\r\nreturn QLA_ERROR;\r\n}\r\nreturn QLA_SUCCESS;\r\n}\r\nuint8_t\r\nqla4xxx_get_ifcb(struct scsi_qla_host *ha, uint32_t *mbox_cmd,\r\nuint32_t *mbox_sts, dma_addr_t init_fw_cb_dma)\r\n{\r\nmemset(mbox_cmd, 0, sizeof(mbox_cmd[0]) * MBOX_REG_COUNT);\r\nmemset(mbox_sts, 0, sizeof(mbox_sts[0]) * MBOX_REG_COUNT);\r\nmbox_cmd[0] = MBOX_CMD_GET_INIT_FW_CTRL_BLOCK;\r\nmbox_cmd[2] = LSDW(init_fw_cb_dma);\r\nmbox_cmd[3] = MSDW(init_fw_cb_dma);\r\nmbox_cmd[4] = sizeof(struct addr_ctrl_blk);\r\nif (qla4xxx_mailbox_command(ha, 5, 5, mbox_cmd, mbox_sts) !=\r\nQLA_SUCCESS) {\r\nDEBUG2(printk(KERN_WARNING "scsi%ld: %s: "\r\n"MBOX_CMD_GET_INIT_FW_CTRL_BLOCK"\r\n" failed w/ status %04X\n",\r\nha->host_no, __func__, mbox_sts[0]));\r\nreturn QLA_ERROR;\r\n}\r\nreturn QLA_SUCCESS;\r\n}\r\nuint8_t qla4xxx_set_ipaddr_state(uint8_t fw_ipaddr_state)\r\n{\r\nuint8_t ipaddr_state;\r\nswitch (fw_ipaddr_state) {\r\ncase IP_ADDRSTATE_UNCONFIGURED:\r\nipaddr_state = ISCSI_IPDDRESS_STATE_UNCONFIGURED;\r\nbreak;\r\ncase IP_ADDRSTATE_INVALID:\r\nipaddr_state = ISCSI_IPDDRESS_STATE_INVALID;\r\nbreak;\r\ncase IP_ADDRSTATE_ACQUIRING:\r\nipaddr_state = ISCSI_IPDDRESS_STATE_ACQUIRING;\r\nbreak;\r\ncase IP_ADDRSTATE_TENTATIVE:\r\nipaddr_state = ISCSI_IPDDRESS_STATE_TENTATIVE;\r\nbreak;\r\ncase IP_ADDRSTATE_DEPRICATED:\r\nipaddr_state = ISCSI_IPDDRESS_STATE_DEPRECATED;\r\nbreak;\r\ncase IP_ADDRSTATE_PREFERRED:\r\nipaddr_state = ISCSI_IPDDRESS_STATE_VALID;\r\nbreak;\r\ncase IP_ADDRSTATE_DISABLING:\r\nipaddr_state = ISCSI_IPDDRESS_STATE_DISABLING;\r\nbreak;\r\ndefault:\r\nipaddr_state = ISCSI_IPDDRESS_STATE_UNCONFIGURED;\r\n}\r\nreturn ipaddr_state;\r\n}\r\nstatic void\r\nqla4xxx_update_local_ip(struct scsi_qla_host *ha,\r\nstruct addr_ctrl_blk *init_fw_cb)\r\n{\r\nha->ip_config.tcp_options = le16_to_cpu(init_fw_cb->ipv4_tcp_opts);\r\nha->ip_config.ipv4_options = le16_to_cpu(init_fw_cb->ipv4_ip_opts);\r\nha->ip_config.ipv4_addr_state =\r\nqla4xxx_set_ipaddr_state(init_fw_cb->ipv4_addr_state);\r\nha->ip_config.eth_mtu_size =\r\nle16_to_cpu(init_fw_cb->eth_mtu_size);\r\nha->ip_config.ipv4_port = le16_to_cpu(init_fw_cb->ipv4_port);\r\nif (ha->acb_version == ACB_SUPPORTED) {\r\nha->ip_config.ipv6_options = le16_to_cpu(init_fw_cb->ipv6_opts);\r\nha->ip_config.ipv6_addl_options =\r\nle16_to_cpu(init_fw_cb->ipv6_addtl_opts);\r\nha->ip_config.ipv6_tcp_options =\r\nle16_to_cpu(init_fw_cb->ipv6_tcp_opts);\r\n}\r\nmemcpy(ha->ip_config.ip_address, init_fw_cb->ipv4_addr,\r\nmin(sizeof(ha->ip_config.ip_address),\r\nsizeof(init_fw_cb->ipv4_addr)));\r\nmemcpy(ha->ip_config.subnet_mask, init_fw_cb->ipv4_subnet,\r\nmin(sizeof(ha->ip_config.subnet_mask),\r\nsizeof(init_fw_cb->ipv4_subnet)));\r\nmemcpy(ha->ip_config.gateway, init_fw_cb->ipv4_gw_addr,\r\nmin(sizeof(ha->ip_config.gateway),\r\nsizeof(init_fw_cb->ipv4_gw_addr)));\r\nha->ip_config.ipv4_vlan_tag = be16_to_cpu(init_fw_cb->ipv4_vlan_tag);\r\nha->ip_config.control = init_fw_cb->control;\r\nha->ip_config.tcp_wsf = init_fw_cb->ipv4_tcp_wsf;\r\nha->ip_config.ipv4_tos = init_fw_cb->ipv4_tos;\r\nha->ip_config.ipv4_cache_id = init_fw_cb->ipv4_cacheid;\r\nha->ip_config.ipv4_alt_cid_len = init_fw_cb->ipv4_dhcp_alt_cid_len;\r\nmemcpy(ha->ip_config.ipv4_alt_cid, init_fw_cb->ipv4_dhcp_alt_cid,\r\nmin(sizeof(ha->ip_config.ipv4_alt_cid),\r\nsizeof(init_fw_cb->ipv4_dhcp_alt_cid)));\r\nha->ip_config.ipv4_vid_len = init_fw_cb->ipv4_dhcp_vid_len;\r\nmemcpy(ha->ip_config.ipv4_vid, init_fw_cb->ipv4_dhcp_vid,\r\nmin(sizeof(ha->ip_config.ipv4_vid),\r\nsizeof(init_fw_cb->ipv4_dhcp_vid)));\r\nha->ip_config.ipv4_ttl = init_fw_cb->ipv4_ttl;\r\nha->ip_config.def_timeout = le16_to_cpu(init_fw_cb->def_timeout);\r\nha->ip_config.abort_timer = init_fw_cb->abort_timer;\r\nha->ip_config.iscsi_options = le16_to_cpu(init_fw_cb->iscsi_opts);\r\nha->ip_config.iscsi_max_pdu_size =\r\nle16_to_cpu(init_fw_cb->iscsi_max_pdu_size);\r\nha->ip_config.iscsi_first_burst_len =\r\nle16_to_cpu(init_fw_cb->iscsi_fburst_len);\r\nha->ip_config.iscsi_max_outstnd_r2t =\r\nle16_to_cpu(init_fw_cb->iscsi_max_outstnd_r2t);\r\nha->ip_config.iscsi_max_burst_len =\r\nle16_to_cpu(init_fw_cb->iscsi_max_burst_len);\r\nmemcpy(ha->ip_config.iscsi_name, init_fw_cb->iscsi_name,\r\nmin(sizeof(ha->ip_config.iscsi_name),\r\nsizeof(init_fw_cb->iscsi_name)));\r\nif (is_ipv6_enabled(ha)) {\r\nha->ip_config.ipv6_link_local_state =\r\nqla4xxx_set_ipaddr_state(init_fw_cb->ipv6_lnk_lcl_addr_state);\r\nha->ip_config.ipv6_addr0_state =\r\nqla4xxx_set_ipaddr_state(init_fw_cb->ipv6_addr0_state);\r\nha->ip_config.ipv6_addr1_state =\r\nqla4xxx_set_ipaddr_state(init_fw_cb->ipv6_addr1_state);\r\nswitch (le16_to_cpu(init_fw_cb->ipv6_dflt_rtr_state)) {\r\ncase IPV6_RTRSTATE_UNKNOWN:\r\nha->ip_config.ipv6_default_router_state =\r\nISCSI_ROUTER_STATE_UNKNOWN;\r\nbreak;\r\ncase IPV6_RTRSTATE_MANUAL:\r\nha->ip_config.ipv6_default_router_state =\r\nISCSI_ROUTER_STATE_MANUAL;\r\nbreak;\r\ncase IPV6_RTRSTATE_ADVERTISED:\r\nha->ip_config.ipv6_default_router_state =\r\nISCSI_ROUTER_STATE_ADVERTISED;\r\nbreak;\r\ncase IPV6_RTRSTATE_STALE:\r\nha->ip_config.ipv6_default_router_state =\r\nISCSI_ROUTER_STATE_STALE;\r\nbreak;\r\ndefault:\r\nha->ip_config.ipv6_default_router_state =\r\nISCSI_ROUTER_STATE_UNKNOWN;\r\n}\r\nha->ip_config.ipv6_link_local_addr.in6_u.u6_addr8[0] = 0xFE;\r\nha->ip_config.ipv6_link_local_addr.in6_u.u6_addr8[1] = 0x80;\r\nmemcpy(&ha->ip_config.ipv6_link_local_addr.in6_u.u6_addr8[8],\r\ninit_fw_cb->ipv6_if_id,\r\nmin(sizeof(ha->ip_config.ipv6_link_local_addr)/2,\r\nsizeof(init_fw_cb->ipv6_if_id)));\r\nmemcpy(&ha->ip_config.ipv6_addr0, init_fw_cb->ipv6_addr0,\r\nmin(sizeof(ha->ip_config.ipv6_addr0),\r\nsizeof(init_fw_cb->ipv6_addr0)));\r\nmemcpy(&ha->ip_config.ipv6_addr1, init_fw_cb->ipv6_addr1,\r\nmin(sizeof(ha->ip_config.ipv6_addr1),\r\nsizeof(init_fw_cb->ipv6_addr1)));\r\nmemcpy(&ha->ip_config.ipv6_default_router_addr,\r\ninit_fw_cb->ipv6_dflt_rtr_addr,\r\nmin(sizeof(ha->ip_config.ipv6_default_router_addr),\r\nsizeof(init_fw_cb->ipv6_dflt_rtr_addr)));\r\nha->ip_config.ipv6_vlan_tag =\r\nbe16_to_cpu(init_fw_cb->ipv6_vlan_tag);\r\nha->ip_config.ipv6_port = le16_to_cpu(init_fw_cb->ipv6_port);\r\nha->ip_config.ipv6_cache_id = init_fw_cb->ipv6_cache_id;\r\nha->ip_config.ipv6_flow_lbl =\r\nle16_to_cpu(init_fw_cb->ipv6_flow_lbl);\r\nha->ip_config.ipv6_traffic_class =\r\ninit_fw_cb->ipv6_traffic_class;\r\nha->ip_config.ipv6_hop_limit = init_fw_cb->ipv6_hop_limit;\r\nha->ip_config.ipv6_nd_reach_time =\r\nle32_to_cpu(init_fw_cb->ipv6_nd_reach_time);\r\nha->ip_config.ipv6_nd_rexmit_timer =\r\nle32_to_cpu(init_fw_cb->ipv6_nd_rexmit_timer);\r\nha->ip_config.ipv6_nd_stale_timeout =\r\nle32_to_cpu(init_fw_cb->ipv6_nd_stale_timeout);\r\nha->ip_config.ipv6_dup_addr_detect_count =\r\ninit_fw_cb->ipv6_dup_addr_detect_count;\r\nha->ip_config.ipv6_gw_advrt_mtu =\r\nle32_to_cpu(init_fw_cb->ipv6_gw_advrt_mtu);\r\nha->ip_config.ipv6_tcp_wsf = init_fw_cb->ipv6_tcp_wsf;\r\n}\r\n}\r\nuint8_t\r\nqla4xxx_update_local_ifcb(struct scsi_qla_host *ha,\r\nuint32_t *mbox_cmd,\r\nuint32_t *mbox_sts,\r\nstruct addr_ctrl_blk *init_fw_cb,\r\ndma_addr_t init_fw_cb_dma)\r\n{\r\nif (qla4xxx_get_ifcb(ha, mbox_cmd, mbox_sts, init_fw_cb_dma)\r\n!= QLA_SUCCESS) {\r\nDEBUG2(printk(KERN_WARNING\r\n"scsi%ld: %s: Failed to get init_fw_ctrl_blk\n",\r\nha->host_no, __func__));\r\nreturn QLA_ERROR;\r\n}\r\nDEBUG2(qla4xxx_dump_buffer(init_fw_cb, sizeof(struct addr_ctrl_blk)));\r\nha->acb_version = init_fw_cb->acb_version;\r\nha->firmware_options = le16_to_cpu(init_fw_cb->fw_options);\r\nha->heartbeat_interval = init_fw_cb->hb_interval;\r\nmemcpy(ha->name_string, init_fw_cb->iscsi_name,\r\nmin(sizeof(ha->name_string),\r\nsizeof(init_fw_cb->iscsi_name)));\r\nha->def_timeout = le16_to_cpu(init_fw_cb->def_timeout);\r\nqla4xxx_update_local_ip(ha, init_fw_cb);\r\nreturn QLA_SUCCESS;\r\n}\r\nint qla4xxx_initialize_fw_cb(struct scsi_qla_host * ha)\r\n{\r\nstruct addr_ctrl_blk *init_fw_cb;\r\ndma_addr_t init_fw_cb_dma;\r\nuint32_t mbox_cmd[MBOX_REG_COUNT];\r\nuint32_t mbox_sts[MBOX_REG_COUNT];\r\nint status = QLA_ERROR;\r\ninit_fw_cb = dma_alloc_coherent(&ha->pdev->dev,\r\nsizeof(struct addr_ctrl_blk),\r\n&init_fw_cb_dma, GFP_KERNEL);\r\nif (init_fw_cb == NULL) {\r\nDEBUG2(printk("scsi%ld: %s: Unable to alloc init_cb\n",\r\nha->host_no, __func__));\r\ngoto exit_init_fw_cb_no_free;\r\n}\r\nmemset(init_fw_cb, 0, sizeof(struct addr_ctrl_blk));\r\nmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\r\nmemset(&mbox_sts, 0, sizeof(mbox_sts));\r\nif (qla4xxx_get_ifcb(ha, &mbox_cmd[0], &mbox_sts[0], init_fw_cb_dma) !=\r\nQLA_SUCCESS) {\r\ndma_free_coherent(&ha->pdev->dev,\r\nsizeof(struct addr_ctrl_blk),\r\ninit_fw_cb, init_fw_cb_dma);\r\ngoto exit_init_fw_cb;\r\n}\r\ninit_fw_cb->rqq_consumer_idx = cpu_to_le16(ha->request_out);\r\ninit_fw_cb->compq_producer_idx = cpu_to_le16(ha->response_in);\r\ninit_fw_cb->rqq_len = __constant_cpu_to_le16(REQUEST_QUEUE_DEPTH);\r\ninit_fw_cb->compq_len = __constant_cpu_to_le16(RESPONSE_QUEUE_DEPTH);\r\ninit_fw_cb->rqq_addr_lo = cpu_to_le32(LSDW(ha->request_dma));\r\ninit_fw_cb->rqq_addr_hi = cpu_to_le32(MSDW(ha->request_dma));\r\ninit_fw_cb->compq_addr_lo = cpu_to_le32(LSDW(ha->response_dma));\r\ninit_fw_cb->compq_addr_hi = cpu_to_le32(MSDW(ha->response_dma));\r\ninit_fw_cb->shdwreg_addr_lo = cpu_to_le32(LSDW(ha->shadow_regs_dma));\r\ninit_fw_cb->shdwreg_addr_hi = cpu_to_le32(MSDW(ha->shadow_regs_dma));\r\ninit_fw_cb->fw_options |=\r\n__constant_cpu_to_le16(FWOPT_SESSION_MODE |\r\nFWOPT_INITIATOR_MODE);\r\nif (is_qla80XX(ha))\r\ninit_fw_cb->fw_options |=\r\n__constant_cpu_to_le16(FWOPT_ENABLE_CRBDB);\r\ninit_fw_cb->fw_options &= __constant_cpu_to_le16(~FWOPT_TARGET_MODE);\r\ninit_fw_cb->add_fw_options = 0;\r\ninit_fw_cb->add_fw_options |=\r\n__constant_cpu_to_le16(ADFWOPT_SERIALIZE_TASK_MGMT);\r\ninit_fw_cb->add_fw_options |=\r\n__constant_cpu_to_le16(ADFWOPT_AUTOCONN_DISABLE);\r\nif (qla4xxx_set_ifcb(ha, &mbox_cmd[0], &mbox_sts[0], init_fw_cb_dma)\r\n!= QLA_SUCCESS) {\r\nDEBUG2(printk(KERN_WARNING\r\n"scsi%ld: %s: Failed to set init_fw_ctrl_blk\n",\r\nha->host_no, __func__));\r\ngoto exit_init_fw_cb;\r\n}\r\nif (qla4xxx_update_local_ifcb(ha, &mbox_cmd[0], &mbox_sts[0],\r\ninit_fw_cb, init_fw_cb_dma) != QLA_SUCCESS) {\r\nDEBUG2(printk("scsi%ld: %s: Failed to update local ifcb\n",\r\nha->host_no, __func__));\r\ngoto exit_init_fw_cb;\r\n}\r\nstatus = QLA_SUCCESS;\r\nexit_init_fw_cb:\r\ndma_free_coherent(&ha->pdev->dev, sizeof(struct addr_ctrl_blk),\r\ninit_fw_cb, init_fw_cb_dma);\r\nexit_init_fw_cb_no_free:\r\nreturn status;\r\n}\r\nint qla4xxx_get_dhcp_ip_address(struct scsi_qla_host * ha)\r\n{\r\nstruct addr_ctrl_blk *init_fw_cb;\r\ndma_addr_t init_fw_cb_dma;\r\nuint32_t mbox_cmd[MBOX_REG_COUNT];\r\nuint32_t mbox_sts[MBOX_REG_COUNT];\r\ninit_fw_cb = dma_alloc_coherent(&ha->pdev->dev,\r\nsizeof(struct addr_ctrl_blk),\r\n&init_fw_cb_dma, GFP_KERNEL);\r\nif (init_fw_cb == NULL) {\r\nprintk("scsi%ld: %s: Unable to alloc init_cb\n", ha->host_no,\r\n__func__);\r\nreturn QLA_ERROR;\r\n}\r\nmemset(init_fw_cb, 0, sizeof(struct addr_ctrl_blk));\r\nif (qla4xxx_get_ifcb(ha, &mbox_cmd[0], &mbox_sts[0], init_fw_cb_dma) !=\r\nQLA_SUCCESS) {\r\nDEBUG2(printk("scsi%ld: %s: Failed to get init_fw_ctrl_blk\n",\r\nha->host_no, __func__));\r\ndma_free_coherent(&ha->pdev->dev,\r\nsizeof(struct addr_ctrl_blk),\r\ninit_fw_cb, init_fw_cb_dma);\r\nreturn QLA_ERROR;\r\n}\r\nqla4xxx_update_local_ip(ha, init_fw_cb);\r\ndma_free_coherent(&ha->pdev->dev, sizeof(struct addr_ctrl_blk),\r\ninit_fw_cb, init_fw_cb_dma);\r\nreturn QLA_SUCCESS;\r\n}\r\nint qla4xxx_get_firmware_state(struct scsi_qla_host * ha)\r\n{\r\nuint32_t mbox_cmd[MBOX_REG_COUNT];\r\nuint32_t mbox_sts[MBOX_REG_COUNT];\r\nmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\r\nmemset(&mbox_sts, 0, sizeof(mbox_sts));\r\nmbox_cmd[0] = MBOX_CMD_GET_FW_STATE;\r\nif (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 4, &mbox_cmd[0], &mbox_sts[0]) !=\r\nQLA_SUCCESS) {\r\nDEBUG2(printk("scsi%ld: %s: MBOX_CMD_GET_FW_STATE failed w/ "\r\n"status %04X\n", ha->host_no, __func__,\r\nmbox_sts[0]));\r\nreturn QLA_ERROR;\r\n}\r\nha->firmware_state = mbox_sts[1];\r\nha->board_id = mbox_sts[2];\r\nha->addl_fw_state = mbox_sts[3];\r\nDEBUG2(printk("scsi%ld: %s firmware_state=0x%x\n",\r\nha->host_no, __func__, ha->firmware_state);)\r\nreturn QLA_SUCCESS;\r\n}\r\nint qla4xxx_get_firmware_status(struct scsi_qla_host * ha)\r\n{\r\nuint32_t mbox_cmd[MBOX_REG_COUNT];\r\nuint32_t mbox_sts[MBOX_REG_COUNT];\r\nmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\r\nmemset(&mbox_sts, 0, sizeof(mbox_sts));\r\nmbox_cmd[0] = MBOX_CMD_GET_FW_STATUS;\r\nif (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 3, &mbox_cmd[0], &mbox_sts[0]) !=\r\nQLA_SUCCESS) {\r\nDEBUG2(printk("scsi%ld: %s: MBOX_CMD_GET_FW_STATUS failed w/ "\r\n"status %04X\n", ha->host_no, __func__,\r\nmbox_sts[0]));\r\nreturn QLA_ERROR;\r\n}\r\nha->iocb_hiwat = mbox_sts[2];\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"%s: firmware IOCBs available = %d\n", __func__,\r\nha->iocb_hiwat));\r\nif (ha->iocb_hiwat > IOCB_HIWAT_CUSHION)\r\nha->iocb_hiwat -= IOCB_HIWAT_CUSHION;\r\nif (ha->iocb_hiwat == 0) {\r\nha->iocb_hiwat = REQUEST_QUEUE_DEPTH / 4;\r\nDEBUG2(ql4_printk(KERN_WARNING, ha,\r\n"%s: Setting IOCB's to = %d\n", __func__,\r\nha->iocb_hiwat));\r\n}\r\nreturn QLA_SUCCESS;\r\n}\r\nint qla4xxx_get_fwddb_entry(struct scsi_qla_host *ha,\r\nuint16_t fw_ddb_index,\r\nstruct dev_db_entry *fw_ddb_entry,\r\ndma_addr_t fw_ddb_entry_dma,\r\nuint32_t *num_valid_ddb_entries,\r\nuint32_t *next_ddb_index,\r\nuint32_t *fw_ddb_device_state,\r\nuint32_t *conn_err_detail,\r\nuint16_t *tcp_source_port_num,\r\nuint16_t *connection_id)\r\n{\r\nint status = QLA_ERROR;\r\nuint16_t options;\r\nuint32_t mbox_cmd[MBOX_REG_COUNT];\r\nuint32_t mbox_sts[MBOX_REG_COUNT];\r\nif (fw_ddb_index >= MAX_DDB_ENTRIES) {\r\nDEBUG2(printk("scsi%ld: %s: ddb [%d] out of range.\n",\r\nha->host_no, __func__, fw_ddb_index));\r\ngoto exit_get_fwddb;\r\n}\r\nmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\r\nmemset(&mbox_sts, 0, sizeof(mbox_sts));\r\nif (fw_ddb_entry)\r\nmemset(fw_ddb_entry, 0, sizeof(struct dev_db_entry));\r\nmbox_cmd[0] = MBOX_CMD_GET_DATABASE_ENTRY;\r\nmbox_cmd[1] = (uint32_t) fw_ddb_index;\r\nmbox_cmd[2] = LSDW(fw_ddb_entry_dma);\r\nmbox_cmd[3] = MSDW(fw_ddb_entry_dma);\r\nmbox_cmd[4] = sizeof(struct dev_db_entry);\r\nif (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 7, &mbox_cmd[0], &mbox_sts[0]) ==\r\nQLA_ERROR) {\r\nDEBUG2(printk("scsi%ld: %s: MBOX_CMD_GET_DATABASE_ENTRY failed"\r\n" with status 0x%04X\n", ha->host_no, __func__,\r\nmbox_sts[0]));\r\ngoto exit_get_fwddb;\r\n}\r\nif (fw_ddb_index != mbox_sts[1]) {\r\nDEBUG2(printk("scsi%ld: %s: ddb mismatch [%d] != [%d].\n",\r\nha->host_no, __func__, fw_ddb_index,\r\nmbox_sts[1]));\r\ngoto exit_get_fwddb;\r\n}\r\nif (fw_ddb_entry) {\r\noptions = le16_to_cpu(fw_ddb_entry->options);\r\nif (options & DDB_OPT_IPV6_DEVICE) {\r\nql4_printk(KERN_INFO, ha, "%s: DDB[%d] MB0 %04x Tot %d "\r\n"Next %d State %04x ConnErr %08x %pI6 "\r\n":%04d \"%s\"\n", __func__, fw_ddb_index,\r\nmbox_sts[0], mbox_sts[2], mbox_sts[3],\r\nmbox_sts[4], mbox_sts[5],\r\nfw_ddb_entry->ip_addr,\r\nle16_to_cpu(fw_ddb_entry->port),\r\nfw_ddb_entry->iscsi_name);\r\n} else {\r\nql4_printk(KERN_INFO, ha, "%s: DDB[%d] MB0 %04x Tot %d "\r\n"Next %d State %04x ConnErr %08x %pI4 "\r\n":%04d \"%s\"\n", __func__, fw_ddb_index,\r\nmbox_sts[0], mbox_sts[2], mbox_sts[3],\r\nmbox_sts[4], mbox_sts[5],\r\nfw_ddb_entry->ip_addr,\r\nle16_to_cpu(fw_ddb_entry->port),\r\nfw_ddb_entry->iscsi_name);\r\n}\r\n}\r\nif (num_valid_ddb_entries)\r\n*num_valid_ddb_entries = mbox_sts[2];\r\nif (next_ddb_index)\r\n*next_ddb_index = mbox_sts[3];\r\nif (fw_ddb_device_state)\r\n*fw_ddb_device_state = mbox_sts[4];\r\nif (conn_err_detail)\r\n*conn_err_detail = mbox_sts[5];\r\nif (tcp_source_port_num)\r\n*tcp_source_port_num = (uint16_t) (mbox_sts[6] >> 16);\r\nif (connection_id)\r\n*connection_id = (uint16_t) mbox_sts[6] & 0x00FF;\r\nstatus = QLA_SUCCESS;\r\nexit_get_fwddb:\r\nreturn status;\r\n}\r\nint qla4xxx_conn_open(struct scsi_qla_host *ha, uint16_t fw_ddb_index)\r\n{\r\nuint32_t mbox_cmd[MBOX_REG_COUNT];\r\nuint32_t mbox_sts[MBOX_REG_COUNT];\r\nint status;\r\nmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\r\nmemset(&mbox_sts, 0, sizeof(mbox_sts));\r\nmbox_cmd[0] = MBOX_CMD_CONN_OPEN;\r\nmbox_cmd[1] = fw_ddb_index;\r\nstatus = qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 2, &mbox_cmd[0],\r\n&mbox_sts[0]);\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"%s: status = %d mbx0 = 0x%x mbx1 = 0x%x\n",\r\n__func__, status, mbox_sts[0], mbox_sts[1]));\r\nreturn status;\r\n}\r\nint qla4xxx_set_ddb_entry(struct scsi_qla_host * ha, uint16_t fw_ddb_index,\r\ndma_addr_t fw_ddb_entry_dma, uint32_t *mbx_sts)\r\n{\r\nuint32_t mbox_cmd[MBOX_REG_COUNT];\r\nuint32_t mbox_sts[MBOX_REG_COUNT];\r\nint status;\r\nmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\r\nmemset(&mbox_sts, 0, sizeof(mbox_sts));\r\nmbox_cmd[0] = MBOX_CMD_SET_DATABASE_ENTRY;\r\nmbox_cmd[1] = (uint32_t) fw_ddb_index;\r\nmbox_cmd[2] = LSDW(fw_ddb_entry_dma);\r\nmbox_cmd[3] = MSDW(fw_ddb_entry_dma);\r\nmbox_cmd[4] = sizeof(struct dev_db_entry);\r\nstatus = qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 5, &mbox_cmd[0],\r\n&mbox_sts[0]);\r\nif (mbx_sts)\r\n*mbx_sts = mbox_sts[0];\r\nDEBUG2(printk("scsi%ld: %s: status=%d mbx0=0x%x mbx4=0x%x\n",\r\nha->host_no, __func__, status, mbox_sts[0], mbox_sts[4]);)\r\nreturn status;\r\n}\r\nint qla4xxx_session_logout_ddb(struct scsi_qla_host *ha,\r\nstruct ddb_entry *ddb_entry, int options)\r\n{\r\nint status;\r\nuint32_t mbox_cmd[MBOX_REG_COUNT];\r\nuint32_t mbox_sts[MBOX_REG_COUNT];\r\nmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\r\nmemset(&mbox_sts, 0, sizeof(mbox_sts));\r\nmbox_cmd[0] = MBOX_CMD_CONN_CLOSE_SESS_LOGOUT;\r\nmbox_cmd[1] = ddb_entry->fw_ddb_index;\r\nmbox_cmd[3] = options;\r\nstatus = qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 2, &mbox_cmd[0],\r\n&mbox_sts[0]);\r\nif (status != QLA_SUCCESS) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"%s: MBOX_CMD_CONN_CLOSE_SESS_LOGOUT "\r\n"failed sts %04X %04X", __func__,\r\nmbox_sts[0], mbox_sts[1]));\r\nif ((mbox_sts[0] == MBOX_STS_COMMAND_ERROR) &&\r\n(mbox_sts[1] == DDB_NOT_LOGGED_IN)) {\r\nset_bit(DDB_CONN_CLOSE_FAILURE, &ddb_entry->flags);\r\n}\r\n}\r\nreturn status;\r\n}\r\nvoid qla4xxx_get_crash_record(struct scsi_qla_host * ha)\r\n{\r\nuint32_t mbox_cmd[MBOX_REG_COUNT];\r\nuint32_t mbox_sts[MBOX_REG_COUNT];\r\nstruct crash_record *crash_record = NULL;\r\ndma_addr_t crash_record_dma = 0;\r\nuint32_t crash_record_size = 0;\r\nmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\r\nmemset(&mbox_sts, 0, sizeof(mbox_cmd));\r\nmbox_cmd[0] = MBOX_CMD_GET_CRASH_RECORD;\r\nif (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 5, &mbox_cmd[0], &mbox_sts[0]) !=\r\nQLA_SUCCESS) {\r\nDEBUG2(printk("scsi%ld: %s: ERROR: Unable to retrieve size!\n",\r\nha->host_no, __func__));\r\ngoto exit_get_crash_record;\r\n}\r\ncrash_record_size = mbox_sts[4];\r\nif (crash_record_size == 0) {\r\nDEBUG2(printk("scsi%ld: %s: ERROR: Crash record size is 0!\n",\r\nha->host_no, __func__));\r\ngoto exit_get_crash_record;\r\n}\r\ncrash_record = dma_alloc_coherent(&ha->pdev->dev, crash_record_size,\r\n&crash_record_dma, GFP_KERNEL);\r\nif (crash_record == NULL)\r\ngoto exit_get_crash_record;\r\nmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\r\nmemset(&mbox_sts, 0, sizeof(mbox_cmd));\r\nmbox_cmd[0] = MBOX_CMD_GET_CRASH_RECORD;\r\nmbox_cmd[2] = LSDW(crash_record_dma);\r\nmbox_cmd[3] = MSDW(crash_record_dma);\r\nmbox_cmd[4] = crash_record_size;\r\nif (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 5, &mbox_cmd[0], &mbox_sts[0]) !=\r\nQLA_SUCCESS)\r\ngoto exit_get_crash_record;\r\nexit_get_crash_record:\r\nif (crash_record)\r\ndma_free_coherent(&ha->pdev->dev, crash_record_size,\r\ncrash_record, crash_record_dma);\r\n}\r\nvoid qla4xxx_get_conn_event_log(struct scsi_qla_host * ha)\r\n{\r\nuint32_t mbox_cmd[MBOX_REG_COUNT];\r\nuint32_t mbox_sts[MBOX_REG_COUNT];\r\nstruct conn_event_log_entry *event_log = NULL;\r\ndma_addr_t event_log_dma = 0;\r\nuint32_t event_log_size = 0;\r\nuint32_t num_valid_entries;\r\nuint32_t oldest_entry = 0;\r\nuint32_t max_event_log_entries;\r\nuint8_t i;\r\nmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\r\nmemset(&mbox_sts, 0, sizeof(mbox_cmd));\r\nmbox_cmd[0] = MBOX_CMD_GET_CONN_EVENT_LOG;\r\nif (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 5, &mbox_cmd[0], &mbox_sts[0]) !=\r\nQLA_SUCCESS)\r\ngoto exit_get_event_log;\r\nevent_log_size = mbox_sts[4];\r\nif (event_log_size == 0)\r\ngoto exit_get_event_log;\r\nevent_log = dma_alloc_coherent(&ha->pdev->dev, event_log_size,\r\n&event_log_dma, GFP_KERNEL);\r\nif (event_log == NULL)\r\ngoto exit_get_event_log;\r\nmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\r\nmemset(&mbox_sts, 0, sizeof(mbox_cmd));\r\nmbox_cmd[0] = MBOX_CMD_GET_CONN_EVENT_LOG;\r\nmbox_cmd[2] = LSDW(event_log_dma);\r\nmbox_cmd[3] = MSDW(event_log_dma);\r\nif (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 5, &mbox_cmd[0], &mbox_sts[0]) !=\r\nQLA_SUCCESS) {\r\nDEBUG2(printk("scsi%ld: %s: ERROR: Unable to retrieve event "\r\n"log!\n", ha->host_no, __func__));\r\ngoto exit_get_event_log;\r\n}\r\nnum_valid_entries = mbox_sts[1];\r\nmax_event_log_entries = event_log_size /\r\nsizeof(struct conn_event_log_entry);\r\nif (num_valid_entries > max_event_log_entries)\r\noldest_entry = num_valid_entries % max_event_log_entries;\r\nDEBUG3(printk("scsi%ld: Connection Event Log Dump (%d entries):\n",\r\nha->host_no, num_valid_entries));\r\nif (ql4xextended_error_logging == 3) {\r\nif (oldest_entry == 0) {\r\nfor (i=0; i < num_valid_entries; i++) {\r\nqla4xxx_dump_buffer((uint8_t *)event_log+\r\n(i*sizeof(*event_log)),\r\nsizeof(*event_log));\r\n}\r\n}\r\nelse {\r\nfor (i=oldest_entry; i < max_event_log_entries; i++) {\r\nqla4xxx_dump_buffer((uint8_t *)event_log+\r\n(i*sizeof(*event_log)),\r\nsizeof(*event_log));\r\n}\r\nfor (i=0; i < oldest_entry; i++) {\r\nqla4xxx_dump_buffer((uint8_t *)event_log+\r\n(i*sizeof(*event_log)),\r\nsizeof(*event_log));\r\n}\r\n}\r\n}\r\nexit_get_event_log:\r\nif (event_log)\r\ndma_free_coherent(&ha->pdev->dev, event_log_size, event_log,\r\nevent_log_dma);\r\n}\r\nint qla4xxx_abort_task(struct scsi_qla_host *ha, struct srb *srb)\r\n{\r\nuint32_t mbox_cmd[MBOX_REG_COUNT];\r\nuint32_t mbox_sts[MBOX_REG_COUNT];\r\nstruct scsi_cmnd *cmd = srb->cmd;\r\nint status = QLA_SUCCESS;\r\nunsigned long flags = 0;\r\nuint32_t index;\r\nmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\r\nmemset(&mbox_sts, 0, sizeof(mbox_sts));\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nindex = (unsigned long)(unsigned char *)cmd->host_scribble;\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nif (index == MAX_SRBS)\r\nreturn status;\r\nmbox_cmd[0] = MBOX_CMD_ABORT_TASK;\r\nmbox_cmd[1] = srb->ddb->fw_ddb_index;\r\nmbox_cmd[2] = index;\r\nmbox_cmd[5] = 0x01;\r\nqla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 5, &mbox_cmd[0],\r\n&mbox_sts[0]);\r\nif (mbox_sts[0] != MBOX_STS_COMMAND_COMPLETE) {\r\nstatus = QLA_ERROR;\r\nDEBUG2(printk(KERN_WARNING "scsi%ld:%d:%llu: abort task FAILED: "\r\n"mbx0=%04X, mb1=%04X, mb2=%04X, mb3=%04X, mb4=%04X\n",\r\nha->host_no, cmd->device->id, cmd->device->lun, mbox_sts[0],\r\nmbox_sts[1], mbox_sts[2], mbox_sts[3], mbox_sts[4]));\r\n}\r\nreturn status;\r\n}\r\nint qla4xxx_reset_lun(struct scsi_qla_host * ha, struct ddb_entry * ddb_entry,\r\nuint64_t lun)\r\n{\r\nuint32_t mbox_cmd[MBOX_REG_COUNT];\r\nuint32_t mbox_sts[MBOX_REG_COUNT];\r\nuint32_t scsi_lun[2];\r\nint status = QLA_SUCCESS;\r\nDEBUG2(printk("scsi%ld:%d:%llu: lun reset issued\n", ha->host_no,\r\nddb_entry->fw_ddb_index, lun));\r\nmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\r\nmemset(&mbox_sts, 0, sizeof(mbox_sts));\r\nint_to_scsilun(lun, (struct scsi_lun *) scsi_lun);\r\nmbox_cmd[0] = MBOX_CMD_LUN_RESET;\r\nmbox_cmd[1] = ddb_entry->fw_ddb_index;\r\nmbox_cmd[2] = cpu_to_le32(scsi_lun[0]);\r\nmbox_cmd[3] = cpu_to_le32(scsi_lun[1]);\r\nmbox_cmd[5] = 0x01;\r\nqla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 1, &mbox_cmd[0], &mbox_sts[0]);\r\nif (mbox_sts[0] != MBOX_STS_COMMAND_COMPLETE &&\r\nmbox_sts[0] != MBOX_STS_COMMAND_ERROR)\r\nstatus = QLA_ERROR;\r\nreturn status;\r\n}\r\nint qla4xxx_reset_target(struct scsi_qla_host *ha,\r\nstruct ddb_entry *ddb_entry)\r\n{\r\nuint32_t mbox_cmd[MBOX_REG_COUNT];\r\nuint32_t mbox_sts[MBOX_REG_COUNT];\r\nint status = QLA_SUCCESS;\r\nDEBUG2(printk("scsi%ld:%d: target reset issued\n", ha->host_no,\r\nddb_entry->fw_ddb_index));\r\nmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\r\nmemset(&mbox_sts, 0, sizeof(mbox_sts));\r\nmbox_cmd[0] = MBOX_CMD_TARGET_WARM_RESET;\r\nmbox_cmd[1] = ddb_entry->fw_ddb_index;\r\nmbox_cmd[5] = 0x01;\r\nqla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 1, &mbox_cmd[0],\r\n&mbox_sts[0]);\r\nif (mbox_sts[0] != MBOX_STS_COMMAND_COMPLETE &&\r\nmbox_sts[0] != MBOX_STS_COMMAND_ERROR)\r\nstatus = QLA_ERROR;\r\nreturn status;\r\n}\r\nint qla4xxx_get_flash(struct scsi_qla_host * ha, dma_addr_t dma_addr,\r\nuint32_t offset, uint32_t len)\r\n{\r\nuint32_t mbox_cmd[MBOX_REG_COUNT];\r\nuint32_t mbox_sts[MBOX_REG_COUNT];\r\nmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\r\nmemset(&mbox_sts, 0, sizeof(mbox_sts));\r\nmbox_cmd[0] = MBOX_CMD_READ_FLASH;\r\nmbox_cmd[1] = LSDW(dma_addr);\r\nmbox_cmd[2] = MSDW(dma_addr);\r\nmbox_cmd[3] = offset;\r\nmbox_cmd[4] = len;\r\nif (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 2, &mbox_cmd[0], &mbox_sts[0]) !=\r\nQLA_SUCCESS) {\r\nDEBUG2(printk("scsi%ld: %s: MBOX_CMD_READ_FLASH, failed w/ "\r\n"status %04X %04X, offset %08x, len %08x\n", ha->host_no,\r\n__func__, mbox_sts[0], mbox_sts[1], offset, len));\r\nreturn QLA_ERROR;\r\n}\r\nreturn QLA_SUCCESS;\r\n}\r\nint qla4xxx_about_firmware(struct scsi_qla_host *ha)\r\n{\r\nstruct about_fw_info *about_fw = NULL;\r\ndma_addr_t about_fw_dma;\r\nuint32_t mbox_cmd[MBOX_REG_COUNT];\r\nuint32_t mbox_sts[MBOX_REG_COUNT];\r\nint status = QLA_ERROR;\r\nabout_fw = dma_alloc_coherent(&ha->pdev->dev,\r\nsizeof(struct about_fw_info),\r\n&about_fw_dma, GFP_KERNEL);\r\nif (!about_fw) {\r\nDEBUG2(ql4_printk(KERN_ERR, ha, "%s: Unable to alloc memory "\r\n"for about_fw\n", __func__));\r\nreturn status;\r\n}\r\nmemset(about_fw, 0, sizeof(struct about_fw_info));\r\nmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\r\nmemset(&mbox_sts, 0, sizeof(mbox_sts));\r\nmbox_cmd[0] = MBOX_CMD_ABOUT_FW;\r\nmbox_cmd[2] = LSDW(about_fw_dma);\r\nmbox_cmd[3] = MSDW(about_fw_dma);\r\nmbox_cmd[4] = sizeof(struct about_fw_info);\r\nstatus = qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, MBOX_REG_COUNT,\r\n&mbox_cmd[0], &mbox_sts[0]);\r\nif (status != QLA_SUCCESS) {\r\nDEBUG2(ql4_printk(KERN_WARNING, ha, "%s: MBOX_CMD_ABOUT_FW "\r\n"failed w/ status %04X\n", __func__,\r\nmbox_sts[0]));\r\ngoto exit_about_fw;\r\n}\r\nha->fw_info.fw_major = le16_to_cpu(about_fw->fw_major);\r\nha->fw_info.fw_minor = le16_to_cpu(about_fw->fw_minor);\r\nha->fw_info.fw_patch = le16_to_cpu(about_fw->fw_patch);\r\nha->fw_info.fw_build = le16_to_cpu(about_fw->fw_build);\r\nmemcpy(ha->fw_info.fw_build_date, about_fw->fw_build_date,\r\nsizeof(about_fw->fw_build_date));\r\nmemcpy(ha->fw_info.fw_build_time, about_fw->fw_build_time,\r\nsizeof(about_fw->fw_build_time));\r\nstrcpy((char *)ha->fw_info.fw_build_user,\r\nskip_spaces((char *)about_fw->fw_build_user));\r\nha->fw_info.fw_load_source = le16_to_cpu(about_fw->fw_load_source);\r\nha->fw_info.iscsi_major = le16_to_cpu(about_fw->iscsi_major);\r\nha->fw_info.iscsi_minor = le16_to_cpu(about_fw->iscsi_minor);\r\nha->fw_info.bootload_major = le16_to_cpu(about_fw->bootload_major);\r\nha->fw_info.bootload_minor = le16_to_cpu(about_fw->bootload_minor);\r\nha->fw_info.bootload_patch = le16_to_cpu(about_fw->bootload_patch);\r\nha->fw_info.bootload_build = le16_to_cpu(about_fw->bootload_build);\r\nstrcpy((char *)ha->fw_info.extended_timestamp,\r\nskip_spaces((char *)about_fw->extended_timestamp));\r\nha->fw_uptime_secs = le32_to_cpu(mbox_sts[5]);\r\nha->fw_uptime_msecs = le32_to_cpu(mbox_sts[6]);\r\nstatus = QLA_SUCCESS;\r\nexit_about_fw:\r\ndma_free_coherent(&ha->pdev->dev, sizeof(struct about_fw_info),\r\nabout_fw, about_fw_dma);\r\nreturn status;\r\n}\r\nint qla4xxx_get_default_ddb(struct scsi_qla_host *ha, uint32_t options,\r\ndma_addr_t dma_addr)\r\n{\r\nuint32_t mbox_cmd[MBOX_REG_COUNT];\r\nuint32_t mbox_sts[MBOX_REG_COUNT];\r\nmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\r\nmemset(&mbox_sts, 0, sizeof(mbox_sts));\r\nmbox_cmd[0] = MBOX_CMD_GET_DATABASE_ENTRY_DEFAULTS;\r\nmbox_cmd[1] = options;\r\nmbox_cmd[2] = LSDW(dma_addr);\r\nmbox_cmd[3] = MSDW(dma_addr);\r\nif (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 1, &mbox_cmd[0], &mbox_sts[0]) !=\r\nQLA_SUCCESS) {\r\nDEBUG2(printk("scsi%ld: %s: failed status %04X\n",\r\nha->host_no, __func__, mbox_sts[0]));\r\nreturn QLA_ERROR;\r\n}\r\nreturn QLA_SUCCESS;\r\n}\r\nint qla4xxx_req_ddb_entry(struct scsi_qla_host *ha, uint32_t ddb_index,\r\nuint32_t *mbx_sts)\r\n{\r\nint status;\r\nuint32_t mbox_cmd[MBOX_REG_COUNT];\r\nuint32_t mbox_sts[MBOX_REG_COUNT];\r\nmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\r\nmemset(&mbox_sts, 0, sizeof(mbox_sts));\r\nmbox_cmd[0] = MBOX_CMD_REQUEST_DATABASE_ENTRY;\r\nmbox_cmd[1] = ddb_index;\r\nstatus = qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 1, &mbox_cmd[0],\r\n&mbox_sts[0]);\r\nif (status != QLA_SUCCESS) {\r\nDEBUG2(ql4_printk(KERN_ERR, ha, "%s: failed status %04X\n",\r\n__func__, mbox_sts[0]));\r\n}\r\n*mbx_sts = mbox_sts[0];\r\nreturn status;\r\n}\r\nint qla4xxx_clear_ddb_entry(struct scsi_qla_host *ha, uint32_t ddb_index)\r\n{\r\nint status;\r\nuint32_t mbox_cmd[MBOX_REG_COUNT];\r\nuint32_t mbox_sts[MBOX_REG_COUNT];\r\nmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\r\nmemset(&mbox_sts, 0, sizeof(mbox_sts));\r\nmbox_cmd[0] = MBOX_CMD_CLEAR_DATABASE_ENTRY;\r\nmbox_cmd[1] = ddb_index;\r\nstatus = qla4xxx_mailbox_command(ha, 2, 1, &mbox_cmd[0],\r\n&mbox_sts[0]);\r\nif (status != QLA_SUCCESS) {\r\nDEBUG2(ql4_printk(KERN_ERR, ha, "%s: failed status %04X\n",\r\n__func__, mbox_sts[0]));\r\n}\r\nreturn status;\r\n}\r\nint qla4xxx_set_flash(struct scsi_qla_host *ha, dma_addr_t dma_addr,\r\nuint32_t offset, uint32_t length, uint32_t options)\r\n{\r\nuint32_t mbox_cmd[MBOX_REG_COUNT];\r\nuint32_t mbox_sts[MBOX_REG_COUNT];\r\nint status = QLA_SUCCESS;\r\nmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\r\nmemset(&mbox_sts, 0, sizeof(mbox_sts));\r\nmbox_cmd[0] = MBOX_CMD_WRITE_FLASH;\r\nmbox_cmd[1] = LSDW(dma_addr);\r\nmbox_cmd[2] = MSDW(dma_addr);\r\nmbox_cmd[3] = offset;\r\nmbox_cmd[4] = length;\r\nmbox_cmd[5] = options;\r\nstatus = qla4xxx_mailbox_command(ha, 6, 2, &mbox_cmd[0], &mbox_sts[0]);\r\nif (status != QLA_SUCCESS) {\r\nDEBUG2(ql4_printk(KERN_WARNING, ha, "%s: MBOX_CMD_WRITE_FLASH "\r\n"failed w/ status %04X, mbx1 %04X\n",\r\n__func__, mbox_sts[0], mbox_sts[1]));\r\n}\r\nreturn status;\r\n}\r\nint qla4xxx_bootdb_by_index(struct scsi_qla_host *ha,\r\nstruct dev_db_entry *fw_ddb_entry,\r\ndma_addr_t fw_ddb_entry_dma, uint16_t ddb_index)\r\n{\r\nuint32_t dev_db_start_offset = FLASH_OFFSET_DB_INFO;\r\nuint32_t dev_db_end_offset;\r\nint status = QLA_ERROR;\r\nmemset(fw_ddb_entry, 0, sizeof(*fw_ddb_entry));\r\ndev_db_start_offset += (ddb_index * sizeof(*fw_ddb_entry));\r\ndev_db_end_offset = FLASH_OFFSET_DB_END;\r\nif (dev_db_start_offset > dev_db_end_offset) {\r\nDEBUG2(ql4_printk(KERN_ERR, ha,\r\n"%s:Invalid DDB index %d", __func__,\r\nddb_index));\r\ngoto exit_bootdb_failed;\r\n}\r\nif (qla4xxx_get_flash(ha, fw_ddb_entry_dma, dev_db_start_offset,\r\nsizeof(*fw_ddb_entry)) != QLA_SUCCESS) {\r\nql4_printk(KERN_ERR, ha, "scsi%ld: %s: Get Flash"\r\n"failed\n", ha->host_no, __func__);\r\ngoto exit_bootdb_failed;\r\n}\r\nif (fw_ddb_entry->cookie == DDB_VALID_COOKIE)\r\nstatus = QLA_SUCCESS;\r\nexit_bootdb_failed:\r\nreturn status;\r\n}\r\nint qla4xxx_flashdb_by_index(struct scsi_qla_host *ha,\r\nstruct dev_db_entry *fw_ddb_entry,\r\ndma_addr_t fw_ddb_entry_dma, uint16_t ddb_index)\r\n{\r\nuint32_t dev_db_start_offset;\r\nuint32_t dev_db_end_offset;\r\nint status = QLA_ERROR;\r\nmemset(fw_ddb_entry, 0, sizeof(*fw_ddb_entry));\r\nif (is_qla40XX(ha)) {\r\ndev_db_start_offset = FLASH_OFFSET_DB_INFO;\r\ndev_db_end_offset = FLASH_OFFSET_DB_END;\r\n} else {\r\ndev_db_start_offset = FLASH_RAW_ACCESS_ADDR +\r\n(ha->hw.flt_region_ddb << 2);\r\nif (ha->port_num == 1)\r\ndev_db_start_offset += (ha->hw.flt_ddb_size / 2);\r\ndev_db_end_offset = dev_db_start_offset +\r\n(ha->hw.flt_ddb_size / 2);\r\n}\r\ndev_db_start_offset += (ddb_index * sizeof(*fw_ddb_entry));\r\nif (dev_db_start_offset > dev_db_end_offset) {\r\nDEBUG2(ql4_printk(KERN_ERR, ha,\r\n"%s:Invalid DDB index %d", __func__,\r\nddb_index));\r\ngoto exit_fdb_failed;\r\n}\r\nif (qla4xxx_get_flash(ha, fw_ddb_entry_dma, dev_db_start_offset,\r\nsizeof(*fw_ddb_entry)) != QLA_SUCCESS) {\r\nql4_printk(KERN_ERR, ha, "scsi%ld: %s: Get Flash failed\n",\r\nha->host_no, __func__);\r\ngoto exit_fdb_failed;\r\n}\r\nif (fw_ddb_entry->cookie == DDB_VALID_COOKIE)\r\nstatus = QLA_SUCCESS;\r\nexit_fdb_failed:\r\nreturn status;\r\n}\r\nint qla4xxx_get_chap(struct scsi_qla_host *ha, char *username, char *password,\r\nuint16_t idx)\r\n{\r\nint ret = 0;\r\nint rval = QLA_ERROR;\r\nuint32_t offset = 0, chap_size;\r\nstruct ql4_chap_table *chap_table;\r\ndma_addr_t chap_dma;\r\nchap_table = dma_pool_alloc(ha->chap_dma_pool, GFP_KERNEL, &chap_dma);\r\nif (chap_table == NULL)\r\nreturn -ENOMEM;\r\nchap_size = sizeof(struct ql4_chap_table);\r\nmemset(chap_table, 0, chap_size);\r\nif (is_qla40XX(ha))\r\noffset = FLASH_CHAP_OFFSET | (idx * chap_size);\r\nelse {\r\noffset = FLASH_RAW_ACCESS_ADDR + (ha->hw.flt_region_chap << 2);\r\nif (ha->port_num == 1)\r\noffset += (ha->hw.flt_chap_size / 2);\r\noffset += (idx * chap_size);\r\n}\r\nrval = qla4xxx_get_flash(ha, chap_dma, offset, chap_size);\r\nif (rval != QLA_SUCCESS) {\r\nret = -EINVAL;\r\ngoto exit_get_chap;\r\n}\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "Chap Cookie: x%x\n",\r\n__le16_to_cpu(chap_table->cookie)));\r\nif (__le16_to_cpu(chap_table->cookie) != CHAP_VALID_COOKIE) {\r\nql4_printk(KERN_ERR, ha, "No valid chap entry found\n");\r\ngoto exit_get_chap;\r\n}\r\nstrlcpy(password, chap_table->secret, QL4_CHAP_MAX_SECRET_LEN);\r\nstrlcpy(username, chap_table->name, QL4_CHAP_MAX_NAME_LEN);\r\nchap_table->cookie = __constant_cpu_to_le16(CHAP_VALID_COOKIE);\r\nexit_get_chap:\r\ndma_pool_free(ha->chap_dma_pool, chap_table, chap_dma);\r\nreturn ret;\r\n}\r\nint qla4xxx_set_chap(struct scsi_qla_host *ha, char *username, char *password,\r\nuint16_t idx, int bidi)\r\n{\r\nint ret = 0;\r\nint rval = QLA_ERROR;\r\nuint32_t offset = 0;\r\nstruct ql4_chap_table *chap_table;\r\nuint32_t chap_size = 0;\r\ndma_addr_t chap_dma;\r\nchap_table = dma_pool_alloc(ha->chap_dma_pool, GFP_KERNEL, &chap_dma);\r\nif (chap_table == NULL) {\r\nret = -ENOMEM;\r\ngoto exit_set_chap;\r\n}\r\nmemset(chap_table, 0, sizeof(struct ql4_chap_table));\r\nif (bidi)\r\nchap_table->flags |= BIT_6;\r\nelse\r\nchap_table->flags |= BIT_7;\r\nchap_table->secret_len = strlen(password);\r\nstrncpy(chap_table->secret, password, MAX_CHAP_SECRET_LEN - 1);\r\nstrncpy(chap_table->name, username, MAX_CHAP_NAME_LEN - 1);\r\nchap_table->cookie = __constant_cpu_to_le16(CHAP_VALID_COOKIE);\r\nif (is_qla40XX(ha)) {\r\nchap_size = MAX_CHAP_ENTRIES_40XX * sizeof(*chap_table);\r\noffset = FLASH_CHAP_OFFSET;\r\n} else {\r\nchap_size = ha->hw.flt_chap_size / 2;\r\noffset = FLASH_RAW_ACCESS_ADDR + (ha->hw.flt_region_chap << 2);\r\nif (ha->port_num == 1)\r\noffset += chap_size;\r\n}\r\noffset += (idx * sizeof(struct ql4_chap_table));\r\nrval = qla4xxx_set_flash(ha, chap_dma, offset,\r\nsizeof(struct ql4_chap_table),\r\nFLASH_OPT_RMW_COMMIT);\r\nif (rval == QLA_SUCCESS && ha->chap_list) {\r\nmemcpy((struct ql4_chap_table *)ha->chap_list + idx,\r\nchap_table, sizeof(struct ql4_chap_table));\r\n}\r\ndma_pool_free(ha->chap_dma_pool, chap_table, chap_dma);\r\nif (rval != QLA_SUCCESS)\r\nret = -EINVAL;\r\nexit_set_chap:\r\nreturn ret;\r\n}\r\nint qla4xxx_get_uni_chap_at_index(struct scsi_qla_host *ha, char *username,\r\nchar *password, uint16_t chap_index)\r\n{\r\nint rval = QLA_ERROR;\r\nstruct ql4_chap_table *chap_table = NULL;\r\nint max_chap_entries;\r\nif (!ha->chap_list) {\r\nql4_printk(KERN_ERR, ha, "Do not have CHAP table cache\n");\r\nrval = QLA_ERROR;\r\ngoto exit_uni_chap;\r\n}\r\nif (!username || !password) {\r\nql4_printk(KERN_ERR, ha, "No memory for username & secret\n");\r\nrval = QLA_ERROR;\r\ngoto exit_uni_chap;\r\n}\r\nif (is_qla80XX(ha))\r\nmax_chap_entries = (ha->hw.flt_chap_size / 2) /\r\nsizeof(struct ql4_chap_table);\r\nelse\r\nmax_chap_entries = MAX_CHAP_ENTRIES_40XX;\r\nif (chap_index > max_chap_entries) {\r\nql4_printk(KERN_ERR, ha, "Invalid Chap index\n");\r\nrval = QLA_ERROR;\r\ngoto exit_uni_chap;\r\n}\r\nmutex_lock(&ha->chap_sem);\r\nchap_table = (struct ql4_chap_table *)ha->chap_list + chap_index;\r\nif (chap_table->cookie != __constant_cpu_to_le16(CHAP_VALID_COOKIE)) {\r\nrval = QLA_ERROR;\r\ngoto exit_unlock_uni_chap;\r\n}\r\nif (!(chap_table->flags & BIT_7)) {\r\nql4_printk(KERN_ERR, ha, "Unidirectional entry not set\n");\r\nrval = QLA_ERROR;\r\ngoto exit_unlock_uni_chap;\r\n}\r\nstrlcpy(password, chap_table->secret, MAX_CHAP_SECRET_LEN);\r\nstrlcpy(username, chap_table->name, MAX_CHAP_NAME_LEN);\r\nrval = QLA_SUCCESS;\r\nexit_unlock_uni_chap:\r\nmutex_unlock(&ha->chap_sem);\r\nexit_uni_chap:\r\nreturn rval;\r\n}\r\nint qla4xxx_get_chap_index(struct scsi_qla_host *ha, char *username,\r\nchar *password, int bidi, uint16_t *chap_index)\r\n{\r\nint i, rval;\r\nint free_index = -1;\r\nint found_index = 0;\r\nint max_chap_entries = 0;\r\nstruct ql4_chap_table *chap_table;\r\nif (is_qla80XX(ha))\r\nmax_chap_entries = (ha->hw.flt_chap_size / 2) /\r\nsizeof(struct ql4_chap_table);\r\nelse\r\nmax_chap_entries = MAX_CHAP_ENTRIES_40XX;\r\nif (!ha->chap_list) {\r\nql4_printk(KERN_ERR, ha, "Do not have CHAP table cache\n");\r\nreturn QLA_ERROR;\r\n}\r\nif (!username || !password) {\r\nql4_printk(KERN_ERR, ha, "Do not have username and psw\n");\r\nreturn QLA_ERROR;\r\n}\r\nmutex_lock(&ha->chap_sem);\r\nfor (i = 0; i < max_chap_entries; i++) {\r\nchap_table = (struct ql4_chap_table *)ha->chap_list + i;\r\nif (chap_table->cookie !=\r\n__constant_cpu_to_le16(CHAP_VALID_COOKIE)) {\r\nif (i > MAX_RESRV_CHAP_IDX && free_index == -1)\r\nfree_index = i;\r\ncontinue;\r\n}\r\nif (bidi) {\r\nif (chap_table->flags & BIT_7)\r\ncontinue;\r\n} else {\r\nif (chap_table->flags & BIT_6)\r\ncontinue;\r\n}\r\nif (!strncmp(chap_table->secret, password,\r\nMAX_CHAP_SECRET_LEN) &&\r\n!strncmp(chap_table->name, username,\r\nMAX_CHAP_NAME_LEN)) {\r\n*chap_index = i;\r\nfound_index = 1;\r\nbreak;\r\n}\r\n}\r\nif (!found_index && free_index != -1) {\r\nrval = qla4xxx_set_chap(ha, username, password,\r\nfree_index, bidi);\r\nif (!rval) {\r\n*chap_index = free_index;\r\nfound_index = 1;\r\n}\r\n}\r\nmutex_unlock(&ha->chap_sem);\r\nif (found_index)\r\nreturn QLA_SUCCESS;\r\nreturn QLA_ERROR;\r\n}\r\nint qla4xxx_conn_close_sess_logout(struct scsi_qla_host *ha,\r\nuint16_t fw_ddb_index,\r\nuint16_t connection_id,\r\nuint16_t option)\r\n{\r\nuint32_t mbox_cmd[MBOX_REG_COUNT];\r\nuint32_t mbox_sts[MBOX_REG_COUNT];\r\nint status = QLA_SUCCESS;\r\nmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\r\nmemset(&mbox_sts, 0, sizeof(mbox_sts));\r\nmbox_cmd[0] = MBOX_CMD_CONN_CLOSE_SESS_LOGOUT;\r\nmbox_cmd[1] = fw_ddb_index;\r\nmbox_cmd[2] = connection_id;\r\nmbox_cmd[3] = option;\r\nstatus = qla4xxx_mailbox_command(ha, 4, 2, &mbox_cmd[0], &mbox_sts[0]);\r\nif (status != QLA_SUCCESS) {\r\nDEBUG2(ql4_printk(KERN_WARNING, ha, "%s: MBOX_CMD_CONN_CLOSE "\r\n"option %04x failed w/ status %04X %04X\n",\r\n__func__, option, mbox_sts[0], mbox_sts[1]));\r\n}\r\nreturn status;\r\n}\r\nstatic int qla4_84xx_extend_idc_tmo(struct scsi_qla_host *ha, uint32_t ext_tmo)\r\n{\r\nuint32_t mbox_cmd[MBOX_REG_COUNT];\r\nuint32_t mbox_sts[MBOX_REG_COUNT];\r\nint status;\r\nmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\r\nmemset(&mbox_sts, 0, sizeof(mbox_sts));\r\next_tmo &= 0xf;\r\nmbox_cmd[0] = MBOX_CMD_IDC_TIME_EXTEND;\r\nmbox_cmd[1] = ((ha->idc_info.request_desc & 0xfffff0ff) |\r\n(ext_tmo << 8));\r\nmbox_cmd[2] = ha->idc_info.info1;\r\nmbox_cmd[3] = ha->idc_info.info2;\r\nmbox_cmd[4] = ha->idc_info.info3;\r\nstatus = qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, MBOX_REG_COUNT,\r\nmbox_cmd, mbox_sts);\r\nif (status != QLA_SUCCESS) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"scsi%ld: %s: failed status %04X\n",\r\nha->host_no, __func__, mbox_sts[0]));\r\nreturn QLA_ERROR;\r\n} else {\r\nql4_printk(KERN_INFO, ha, "%s: IDC timeout extended by %d secs\n",\r\n__func__, ext_tmo);\r\n}\r\nreturn QLA_SUCCESS;\r\n}\r\nint qla4xxx_disable_acb(struct scsi_qla_host *ha)\r\n{\r\nuint32_t mbox_cmd[MBOX_REG_COUNT];\r\nuint32_t mbox_sts[MBOX_REG_COUNT];\r\nint status = QLA_SUCCESS;\r\nmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\r\nmemset(&mbox_sts, 0, sizeof(mbox_sts));\r\nmbox_cmd[0] = MBOX_CMD_DISABLE_ACB;\r\nstatus = qla4xxx_mailbox_command(ha, 8, 5, &mbox_cmd[0], &mbox_sts[0]);\r\nif (status != QLA_SUCCESS) {\r\nDEBUG2(ql4_printk(KERN_WARNING, ha, "%s: MBOX_CMD_DISABLE_ACB "\r\n"failed w/ status %04X %04X %04X", __func__,\r\nmbox_sts[0], mbox_sts[1], mbox_sts[2]));\r\n} else {\r\nif (is_qla8042(ha) &&\r\ntest_bit(DPC_POST_IDC_ACK, &ha->dpc_flags) &&\r\n(mbox_sts[0] != MBOX_STS_COMMAND_COMPLETE)) {\r\nqla4_84xx_extend_idc_tmo(ha, IDC_EXTEND_TOV);\r\nif (!wait_for_completion_timeout(&ha->disable_acb_comp,\r\nIDC_EXTEND_TOV * HZ)) {\r\nql4_printk(KERN_WARNING, ha, "%s: Disable ACB Completion not received\n",\r\n__func__);\r\n}\r\n}\r\n}\r\nreturn status;\r\n}\r\nint qla4xxx_get_acb(struct scsi_qla_host *ha, dma_addr_t acb_dma,\r\nuint32_t acb_type, uint32_t len)\r\n{\r\nuint32_t mbox_cmd[MBOX_REG_COUNT];\r\nuint32_t mbox_sts[MBOX_REG_COUNT];\r\nint status = QLA_SUCCESS;\r\nmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\r\nmemset(&mbox_sts, 0, sizeof(mbox_sts));\r\nmbox_cmd[0] = MBOX_CMD_GET_ACB;\r\nmbox_cmd[1] = acb_type;\r\nmbox_cmd[2] = LSDW(acb_dma);\r\nmbox_cmd[3] = MSDW(acb_dma);\r\nmbox_cmd[4] = len;\r\nstatus = qla4xxx_mailbox_command(ha, 5, 5, &mbox_cmd[0], &mbox_sts[0]);\r\nif (status != QLA_SUCCESS) {\r\nDEBUG2(ql4_printk(KERN_WARNING, ha, "%s: MBOX_CMD_GET_ACB "\r\n"failed w/ status %04X\n", __func__,\r\nmbox_sts[0]));\r\n}\r\nreturn status;\r\n}\r\nint qla4xxx_set_acb(struct scsi_qla_host *ha, uint32_t *mbox_cmd,\r\nuint32_t *mbox_sts, dma_addr_t acb_dma)\r\n{\r\nint status = QLA_SUCCESS;\r\nmemset(mbox_cmd, 0, sizeof(mbox_cmd[0]) * MBOX_REG_COUNT);\r\nmemset(mbox_sts, 0, sizeof(mbox_sts[0]) * MBOX_REG_COUNT);\r\nmbox_cmd[0] = MBOX_CMD_SET_ACB;\r\nmbox_cmd[1] = 0;\r\nmbox_cmd[2] = LSDW(acb_dma);\r\nmbox_cmd[3] = MSDW(acb_dma);\r\nmbox_cmd[4] = sizeof(struct addr_ctrl_blk);\r\nstatus = qla4xxx_mailbox_command(ha, 5, 5, &mbox_cmd[0], &mbox_sts[0]);\r\nif (status != QLA_SUCCESS) {\r\nDEBUG2(ql4_printk(KERN_WARNING, ha, "%s: MBOX_CMD_SET_ACB "\r\n"failed w/ status %04X\n", __func__,\r\nmbox_sts[0]));\r\n}\r\nreturn status;\r\n}\r\nint qla4xxx_set_param_ddbentry(struct scsi_qla_host *ha,\r\nstruct ddb_entry *ddb_entry,\r\nstruct iscsi_cls_conn *cls_conn,\r\nuint32_t *mbx_sts)\r\n{\r\nstruct dev_db_entry *fw_ddb_entry;\r\nstruct iscsi_conn *conn;\r\nstruct iscsi_session *sess;\r\nstruct qla_conn *qla_conn;\r\nstruct sockaddr *dst_addr;\r\ndma_addr_t fw_ddb_entry_dma;\r\nint status = QLA_SUCCESS;\r\nint rval = 0;\r\nstruct sockaddr_in *addr;\r\nstruct sockaddr_in6 *addr6;\r\nchar *ip;\r\nuint16_t iscsi_opts = 0;\r\nuint32_t options = 0;\r\nuint16_t idx, *ptid;\r\nfw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\r\n&fw_ddb_entry_dma, GFP_KERNEL);\r\nif (!fw_ddb_entry) {\r\nDEBUG2(ql4_printk(KERN_ERR, ha,\r\n"%s: Unable to allocate dma buffer.\n",\r\n__func__));\r\nrval = -ENOMEM;\r\ngoto exit_set_param_no_free;\r\n}\r\nconn = cls_conn->dd_data;\r\nqla_conn = conn->dd_data;\r\nsess = conn->session;\r\ndst_addr = (struct sockaddr *)&qla_conn->qla_ep->dst_addr;\r\nif (dst_addr->sa_family == AF_INET6)\r\noptions |= IPV6_DEFAULT_DDB_ENTRY;\r\nstatus = qla4xxx_get_default_ddb(ha, options, fw_ddb_entry_dma);\r\nif (status == QLA_ERROR) {\r\nrval = -EINVAL;\r\ngoto exit_set_param;\r\n}\r\nptid = (uint16_t *)&fw_ddb_entry->isid[1];\r\n*ptid = cpu_to_le16((uint16_t)ddb_entry->sess->target_id);\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "ISID [%pmR]\n", fw_ddb_entry->isid));\r\niscsi_opts = le16_to_cpu(fw_ddb_entry->iscsi_options);\r\nmemset(fw_ddb_entry->iscsi_alias, 0, sizeof(fw_ddb_entry->iscsi_alias));\r\nmemset(fw_ddb_entry->iscsi_name, 0, sizeof(fw_ddb_entry->iscsi_name));\r\nif (sess->targetname != NULL) {\r\nmemcpy(fw_ddb_entry->iscsi_name, sess->targetname,\r\nmin(strlen(sess->targetname),\r\nsizeof(fw_ddb_entry->iscsi_name)));\r\n}\r\nmemset(fw_ddb_entry->ip_addr, 0, sizeof(fw_ddb_entry->ip_addr));\r\nmemset(fw_ddb_entry->tgt_addr, 0, sizeof(fw_ddb_entry->tgt_addr));\r\nfw_ddb_entry->options = DDB_OPT_TARGET | DDB_OPT_AUTO_SENDTGTS_DISABLE;\r\nif (dst_addr->sa_family == AF_INET) {\r\naddr = (struct sockaddr_in *)dst_addr;\r\nip = (char *)&addr->sin_addr;\r\nmemcpy(fw_ddb_entry->ip_addr, ip, IP_ADDR_LEN);\r\nfw_ddb_entry->port = cpu_to_le16(ntohs(addr->sin_port));\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"%s: Destination Address [%pI4]: index [%d]\n",\r\n__func__, fw_ddb_entry->ip_addr,\r\nddb_entry->fw_ddb_index));\r\n} else if (dst_addr->sa_family == AF_INET6) {\r\naddr6 = (struct sockaddr_in6 *)dst_addr;\r\nip = (char *)&addr6->sin6_addr;\r\nmemcpy(fw_ddb_entry->ip_addr, ip, IPv6_ADDR_LEN);\r\nfw_ddb_entry->port = cpu_to_le16(ntohs(addr6->sin6_port));\r\nfw_ddb_entry->options |= DDB_OPT_IPV6_DEVICE;\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"%s: Destination Address [%pI6]: index [%d]\n",\r\n__func__, fw_ddb_entry->ip_addr,\r\nddb_entry->fw_ddb_index));\r\n} else {\r\nql4_printk(KERN_ERR, ha,\r\n"%s: Failed to get IP Address\n",\r\n__func__);\r\nrval = -EINVAL;\r\ngoto exit_set_param;\r\n}\r\nif (sess->username != NULL && sess->password != NULL) {\r\nif (strlen(sess->username) && strlen(sess->password)) {\r\niscsi_opts |= BIT_7;\r\nrval = qla4xxx_get_chap_index(ha, sess->username,\r\nsess->password,\r\nLOCAL_CHAP, &idx);\r\nif (rval)\r\ngoto exit_set_param;\r\nfw_ddb_entry->chap_tbl_idx = cpu_to_le16(idx);\r\n}\r\n}\r\nif (sess->username_in != NULL && sess->password_in != NULL) {\r\nif (strlen(sess->username_in) && strlen(sess->password_in)) {\r\niscsi_opts |= BIT_4;\r\nrval = qla4xxx_get_chap_index(ha, sess->username_in,\r\nsess->password_in,\r\nBIDI_CHAP, &idx);\r\nif (rval)\r\ngoto exit_set_param;\r\n}\r\n}\r\nif (sess->initial_r2t_en)\r\niscsi_opts |= BIT_10;\r\nif (sess->imm_data_en)\r\niscsi_opts |= BIT_11;\r\nfw_ddb_entry->iscsi_options = cpu_to_le16(iscsi_opts);\r\nif (conn->max_recv_dlength)\r\nfw_ddb_entry->iscsi_max_rcv_data_seg_len =\r\n__constant_cpu_to_le16((conn->max_recv_dlength / BYTE_UNITS));\r\nif (sess->max_r2t)\r\nfw_ddb_entry->iscsi_max_outsnd_r2t = cpu_to_le16(sess->max_r2t);\r\nif (sess->first_burst)\r\nfw_ddb_entry->iscsi_first_burst_len =\r\n__constant_cpu_to_le16((sess->first_burst / BYTE_UNITS));\r\nif (sess->max_burst)\r\nfw_ddb_entry->iscsi_max_burst_len =\r\n__constant_cpu_to_le16((sess->max_burst / BYTE_UNITS));\r\nif (sess->time2wait)\r\nfw_ddb_entry->iscsi_def_time2wait =\r\ncpu_to_le16(sess->time2wait);\r\nif (sess->time2retain)\r\nfw_ddb_entry->iscsi_def_time2retain =\r\ncpu_to_le16(sess->time2retain);\r\nstatus = qla4xxx_set_ddb_entry(ha, ddb_entry->fw_ddb_index,\r\nfw_ddb_entry_dma, mbx_sts);\r\nif (status != QLA_SUCCESS)\r\nrval = -EINVAL;\r\nexit_set_param:\r\ndma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\r\nfw_ddb_entry, fw_ddb_entry_dma);\r\nexit_set_param_no_free:\r\nreturn rval;\r\n}\r\nint qla4xxx_get_mgmt_data(struct scsi_qla_host *ha, uint16_t fw_ddb_index,\r\nuint16_t stats_size, dma_addr_t stats_dma)\r\n{\r\nint status = QLA_SUCCESS;\r\nuint32_t mbox_cmd[MBOX_REG_COUNT];\r\nuint32_t mbox_sts[MBOX_REG_COUNT];\r\nmemset(mbox_cmd, 0, sizeof(mbox_cmd[0]) * MBOX_REG_COUNT);\r\nmemset(mbox_sts, 0, sizeof(mbox_sts[0]) * MBOX_REG_COUNT);\r\nmbox_cmd[0] = MBOX_CMD_GET_MANAGEMENT_DATA;\r\nmbox_cmd[1] = fw_ddb_index;\r\nmbox_cmd[2] = LSDW(stats_dma);\r\nmbox_cmd[3] = MSDW(stats_dma);\r\nmbox_cmd[4] = stats_size;\r\nstatus = qla4xxx_mailbox_command(ha, 5, 1, &mbox_cmd[0], &mbox_sts[0]);\r\nif (status != QLA_SUCCESS) {\r\nDEBUG2(ql4_printk(KERN_WARNING, ha,\r\n"%s: MBOX_CMD_GET_MANAGEMENT_DATA "\r\n"failed w/ status %04X\n", __func__,\r\nmbox_sts[0]));\r\n}\r\nreturn status;\r\n}\r\nint qla4xxx_get_ip_state(struct scsi_qla_host *ha, uint32_t acb_idx,\r\nuint32_t ip_idx, uint32_t *sts)\r\n{\r\nuint32_t mbox_cmd[MBOX_REG_COUNT];\r\nuint32_t mbox_sts[MBOX_REG_COUNT];\r\nint status = QLA_SUCCESS;\r\nmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\r\nmemset(&mbox_sts, 0, sizeof(mbox_sts));\r\nmbox_cmd[0] = MBOX_CMD_GET_IP_ADDR_STATE;\r\nmbox_cmd[1] = acb_idx;\r\nmbox_cmd[2] = ip_idx;\r\nstatus = qla4xxx_mailbox_command(ha, 3, 8, &mbox_cmd[0], &mbox_sts[0]);\r\nif (status != QLA_SUCCESS) {\r\nDEBUG2(ql4_printk(KERN_WARNING, ha, "%s: "\r\n"MBOX_CMD_GET_IP_ADDR_STATE failed w/ "\r\n"status %04X\n", __func__, mbox_sts[0]));\r\n}\r\nmemcpy(sts, mbox_sts, sizeof(mbox_sts));\r\nreturn status;\r\n}\r\nint qla4xxx_get_nvram(struct scsi_qla_host *ha, dma_addr_t nvram_dma,\r\nuint32_t offset, uint32_t size)\r\n{\r\nint status = QLA_SUCCESS;\r\nuint32_t mbox_cmd[MBOX_REG_COUNT];\r\nuint32_t mbox_sts[MBOX_REG_COUNT];\r\nmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\r\nmemset(&mbox_sts, 0, sizeof(mbox_sts));\r\nmbox_cmd[0] = MBOX_CMD_GET_NVRAM;\r\nmbox_cmd[1] = LSDW(nvram_dma);\r\nmbox_cmd[2] = MSDW(nvram_dma);\r\nmbox_cmd[3] = offset;\r\nmbox_cmd[4] = size;\r\nstatus = qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 1, &mbox_cmd[0],\r\n&mbox_sts[0]);\r\nif (status != QLA_SUCCESS) {\r\nDEBUG2(ql4_printk(KERN_ERR, ha, "scsi%ld: %s: failed "\r\n"status %04X\n", ha->host_no, __func__,\r\nmbox_sts[0]));\r\n}\r\nreturn status;\r\n}\r\nint qla4xxx_set_nvram(struct scsi_qla_host *ha, dma_addr_t nvram_dma,\r\nuint32_t offset, uint32_t size)\r\n{\r\nint status = QLA_SUCCESS;\r\nuint32_t mbox_cmd[MBOX_REG_COUNT];\r\nuint32_t mbox_sts[MBOX_REG_COUNT];\r\nmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\r\nmemset(&mbox_sts, 0, sizeof(mbox_sts));\r\nmbox_cmd[0] = MBOX_CMD_SET_NVRAM;\r\nmbox_cmd[1] = LSDW(nvram_dma);\r\nmbox_cmd[2] = MSDW(nvram_dma);\r\nmbox_cmd[3] = offset;\r\nmbox_cmd[4] = size;\r\nstatus = qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 1, &mbox_cmd[0],\r\n&mbox_sts[0]);\r\nif (status != QLA_SUCCESS) {\r\nDEBUG2(ql4_printk(KERN_ERR, ha, "scsi%ld: %s: failed "\r\n"status %04X\n", ha->host_no, __func__,\r\nmbox_sts[0]));\r\n}\r\nreturn status;\r\n}\r\nint qla4xxx_restore_factory_defaults(struct scsi_qla_host *ha,\r\nuint32_t region, uint32_t field0,\r\nuint32_t field1)\r\n{\r\nint status = QLA_SUCCESS;\r\nuint32_t mbox_cmd[MBOX_REG_COUNT];\r\nuint32_t mbox_sts[MBOX_REG_COUNT];\r\nmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\r\nmemset(&mbox_sts, 0, sizeof(mbox_sts));\r\nmbox_cmd[0] = MBOX_CMD_RESTORE_FACTORY_DEFAULTS;\r\nmbox_cmd[3] = region;\r\nmbox_cmd[4] = field0;\r\nmbox_cmd[5] = field1;\r\nstatus = qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 3, &mbox_cmd[0],\r\n&mbox_sts[0]);\r\nif (status != QLA_SUCCESS) {\r\nDEBUG2(ql4_printk(KERN_ERR, ha, "scsi%ld: %s: failed "\r\n"status %04X\n", ha->host_no, __func__,\r\nmbox_sts[0]));\r\n}\r\nreturn status;\r\n}\r\nint qla4_8xxx_set_param(struct scsi_qla_host *ha, int param)\r\n{\r\nuint32_t mbox_cmd[MBOX_REG_COUNT];\r\nuint32_t mbox_sts[MBOX_REG_COUNT];\r\nuint32_t status;\r\nmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\r\nmemset(&mbox_sts, 0, sizeof(mbox_sts));\r\nmbox_cmd[0] = MBOX_CMD_SET_PARAM;\r\nif (param == SET_DRVR_VERSION) {\r\nmbox_cmd[1] = SET_DRVR_VERSION;\r\nstrncpy((char *)&mbox_cmd[2], QLA4XXX_DRIVER_VERSION,\r\nMAX_DRVR_VER_LEN - 1);\r\n} else {\r\nql4_printk(KERN_ERR, ha, "%s: invalid parameter 0x%x\n",\r\n__func__, param);\r\nstatus = QLA_ERROR;\r\ngoto exit_set_param;\r\n}\r\nstatus = qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 2, mbox_cmd,\r\nmbox_sts);\r\nif (status == QLA_ERROR)\r\nql4_printk(KERN_ERR, ha, "%s: failed status %04X\n",\r\n__func__, mbox_sts[0]);\r\nexit_set_param:\r\nreturn status;\r\n}\r\nint qla4_83xx_post_idc_ack(struct scsi_qla_host *ha)\r\n{\r\nuint32_t mbox_cmd[MBOX_REG_COUNT];\r\nuint32_t mbox_sts[MBOX_REG_COUNT];\r\nint status;\r\nmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\r\nmemset(&mbox_sts, 0, sizeof(mbox_sts));\r\nmbox_cmd[0] = MBOX_CMD_IDC_ACK;\r\nmbox_cmd[1] = ha->idc_info.request_desc;\r\nmbox_cmd[2] = ha->idc_info.info1;\r\nmbox_cmd[3] = ha->idc_info.info2;\r\nmbox_cmd[4] = ha->idc_info.info3;\r\nstatus = qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, MBOX_REG_COUNT,\r\nmbox_cmd, mbox_sts);\r\nif (status == QLA_ERROR)\r\nql4_printk(KERN_ERR, ha, "%s: failed status %04X\n", __func__,\r\nmbox_sts[0]);\r\nelse\r\nql4_printk(KERN_INFO, ha, "%s: IDC ACK posted\n", __func__);\r\nreturn status;\r\n}\r\nint qla4_84xx_config_acb(struct scsi_qla_host *ha, int acb_config)\r\n{\r\nuint32_t mbox_cmd[MBOX_REG_COUNT];\r\nuint32_t mbox_sts[MBOX_REG_COUNT];\r\nstruct addr_ctrl_blk *acb = NULL;\r\nuint32_t acb_len = sizeof(struct addr_ctrl_blk);\r\nint rval = QLA_SUCCESS;\r\ndma_addr_t acb_dma;\r\nacb = dma_alloc_coherent(&ha->pdev->dev,\r\nsizeof(struct addr_ctrl_blk),\r\n&acb_dma, GFP_KERNEL);\r\nif (!acb) {\r\nql4_printk(KERN_ERR, ha, "%s: Unable to alloc acb\n", __func__);\r\nrval = QLA_ERROR;\r\ngoto exit_config_acb;\r\n}\r\nmemset(acb, 0, acb_len);\r\nswitch (acb_config) {\r\ncase ACB_CONFIG_DISABLE:\r\nrval = qla4xxx_get_acb(ha, acb_dma, 0, acb_len);\r\nif (rval != QLA_SUCCESS)\r\ngoto exit_free_acb;\r\nrval = qla4xxx_disable_acb(ha);\r\nif (rval != QLA_SUCCESS)\r\ngoto exit_free_acb;\r\nif (!ha->saved_acb)\r\nha->saved_acb = kzalloc(acb_len, GFP_KERNEL);\r\nif (!ha->saved_acb) {\r\nql4_printk(KERN_ERR, ha, "%s: Unable to alloc acb\n",\r\n__func__);\r\nrval = QLA_ERROR;\r\ngoto exit_free_acb;\r\n}\r\nmemcpy(ha->saved_acb, acb, acb_len);\r\nbreak;\r\ncase ACB_CONFIG_SET:\r\nif (!ha->saved_acb) {\r\nql4_printk(KERN_ERR, ha, "%s: Can't set ACB, Saved ACB not available\n",\r\n__func__);\r\nrval = QLA_ERROR;\r\ngoto exit_free_acb;\r\n}\r\nmemcpy(acb, ha->saved_acb, acb_len);\r\nrval = qla4xxx_set_acb(ha, &mbox_cmd[0], &mbox_sts[0], acb_dma);\r\nif (rval != QLA_SUCCESS)\r\ngoto exit_free_acb;\r\nbreak;\r\ndefault:\r\nql4_printk(KERN_ERR, ha, "%s: Invalid ACB Configuration\n",\r\n__func__);\r\n}\r\nexit_free_acb:\r\ndma_free_coherent(&ha->pdev->dev, sizeof(struct addr_ctrl_blk), acb,\r\nacb_dma);\r\nexit_config_acb:\r\nif ((acb_config == ACB_CONFIG_SET) && ha->saved_acb) {\r\nkfree(ha->saved_acb);\r\nha->saved_acb = NULL;\r\n}\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"%s %s\n", __func__,\r\nrval == QLA_SUCCESS ? "SUCCEEDED" : "FAILED"));\r\nreturn rval;\r\n}\r\nint qla4_83xx_get_port_config(struct scsi_qla_host *ha, uint32_t *config)\r\n{\r\nuint32_t mbox_cmd[MBOX_REG_COUNT];\r\nuint32_t mbox_sts[MBOX_REG_COUNT];\r\nint status;\r\nmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\r\nmemset(&mbox_sts, 0, sizeof(mbox_sts));\r\nmbox_cmd[0] = MBOX_CMD_GET_PORT_CONFIG;\r\nstatus = qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, MBOX_REG_COUNT,\r\nmbox_cmd, mbox_sts);\r\nif (status == QLA_SUCCESS)\r\n*config = mbox_sts[1];\r\nelse\r\nql4_printk(KERN_ERR, ha, "%s: failed status %04X\n", __func__,\r\nmbox_sts[0]);\r\nreturn status;\r\n}\r\nint qla4_83xx_set_port_config(struct scsi_qla_host *ha, uint32_t *config)\r\n{\r\nuint32_t mbox_cmd[MBOX_REG_COUNT];\r\nuint32_t mbox_sts[MBOX_REG_COUNT];\r\nint status;\r\nmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\r\nmemset(&mbox_sts, 0, sizeof(mbox_sts));\r\nmbox_cmd[0] = MBOX_CMD_SET_PORT_CONFIG;\r\nmbox_cmd[1] = *config;\r\nstatus = qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, MBOX_REG_COUNT,\r\nmbox_cmd, mbox_sts);\r\nif (status != QLA_SUCCESS)\r\nql4_printk(KERN_ERR, ha, "%s: failed status %04X\n", __func__,\r\nmbox_sts[0]);\r\nreturn status;\r\n}
