void usage(void)\r\n{\r\nfprintf(stderr, "%s [options] [scope][field value]\n", progname);\r\nfprintf(stderr, "scope: --cpu cpu-list [--hwp-use-pkg #] | --pkg pkg-list\n");\r\nfprintf(stderr, "field: --all | --epb | --hwp-epp | --hwp-min | --hwp-max | --hwp-desired\n");\r\nfprintf(stderr, "other: --hwp-enable | --turbo-enable (0 | 1) | --help | --force\n");\r\nfprintf(stderr,\r\n"value: ( # | \"normal\" | \"performance\" | \"balance-performance\" | \"balance-power\"| \"power\")\n");\r\nfprintf(stderr, "--hwp-window usec\n");\r\nfprintf(stderr, "Specify only Energy Performance BIAS (legacy usage):\n");\r\nfprintf(stderr, "%s: [-c cpu] [-v] (-r | policy-value )\n", progname);\r\nexit(1);\r\n}\r\nint ratio_2_msr_perf(int ratio)\r\n{\r\nint msr_perf;\r\nif (!bdx_highest_ratio)\r\nreturn ratio;\r\nmsr_perf = ratio * 255 / bdx_highest_ratio;\r\nif (debug)\r\nfprintf(stderr, "%d = ratio_to_msr_perf(%d)\n", msr_perf, ratio);\r\nreturn msr_perf;\r\n}\r\nint msr_perf_2_ratio(int msr_perf)\r\n{\r\nint ratio;\r\ndouble d;\r\nif (!bdx_highest_ratio)\r\nreturn msr_perf;\r\nd = (double)msr_perf * (double) bdx_highest_ratio / 255.0;\r\nd = d + 0.5;\r\nratio = (int)d;\r\nif (debug)\r\nfprintf(stderr, "%d = msr_perf_ratio(%d) {%f}\n", ratio, msr_perf, d);\r\nreturn ratio;\r\n}\r\nint parse_cmdline_epb(int i)\r\n{\r\nif (!has_epb)\r\nerrx(1, "EPB not enabled on this platform");\r\nupdate_epb = 1;\r\nswitch (i) {\r\ncase OPTARG_POWER:\r\nreturn ENERGY_PERF_BIAS_POWERSAVE;\r\ncase OPTARG_BALANCE_POWER:\r\nreturn ENERGY_PERF_BIAS_BALANCE_POWERSAVE;\r\ncase OPTARG_NORMAL:\r\nreturn ENERGY_PERF_BIAS_NORMAL;\r\ncase OPTARG_BALANCE_PERFORMANCE:\r\nreturn ENERGY_PERF_BIAS_BALANCE_PERFORMANCE;\r\ncase OPTARG_PERFORMANCE:\r\nreturn ENERGY_PERF_BIAS_PERFORMANCE;\r\n}\r\nif (i < 0 || i > ENERGY_PERF_BIAS_POWERSAVE)\r\nerrx(1, "--epb must be from 0 to 15");\r\nreturn i;\r\n}\r\nint parse_cmdline_hwp_min(int i)\r\n{\r\nupdate_hwp_min = 1;\r\nswitch (i) {\r\ncase OPTARG_POWER:\r\ncase OPTARG_BALANCE_POWER:\r\ncase OPTARG_NORMAL:\r\ncase OPTARG_BALANCE_PERFORMANCE:\r\nreturn HWP_CAP_LOWEST;\r\ncase OPTARG_PERFORMANCE:\r\nreturn HWP_CAP_HIGHEST;\r\n}\r\nreturn i;\r\n}\r\nint parse_cmdline_hwp_max(int i)\r\n{\r\nupdate_hwp_max = 1;\r\nswitch (i) {\r\ncase OPTARG_POWER:\r\nreturn HWP_CAP_LOWEST;\r\ncase OPTARG_NORMAL:\r\ncase OPTARG_BALANCE_POWER:\r\ncase OPTARG_BALANCE_PERFORMANCE:\r\ncase OPTARG_PERFORMANCE:\r\nreturn HWP_CAP_HIGHEST;\r\n}\r\nreturn i;\r\n}\r\nint parse_cmdline_hwp_desired(int i)\r\n{\r\nupdate_hwp_desired = 1;\r\nswitch (i) {\r\ncase OPTARG_POWER:\r\ncase OPTARG_BALANCE_POWER:\r\ncase OPTARG_BALANCE_PERFORMANCE:\r\ncase OPTARG_NORMAL:\r\ncase OPTARG_PERFORMANCE:\r\nreturn 0;\r\n}\r\nreturn i;\r\n}\r\nint parse_cmdline_hwp_window(int i)\r\n{\r\nunsigned int exponent;\r\nupdate_hwp_window = 1;\r\nswitch (i) {\r\ncase OPTARG_POWER:\r\ncase OPTARG_BALANCE_POWER:\r\ncase OPTARG_NORMAL:\r\ncase OPTARG_BALANCE_PERFORMANCE:\r\ncase OPTARG_PERFORMANCE:\r\nreturn 0;\r\n}\r\nif (i < 0 || i > 1270000000) {\r\nfprintf(stderr, "--hwp-window: 0 for auto; 1 - 1270000000 usec for window duration\n");\r\nusage();\r\n}\r\nfor (exponent = 0; ; ++exponent) {\r\nif (debug)\r\nprintf("%d 10^%d\n", i, exponent);\r\nif (i <= 127)\r\nbreak;\r\ni = i / 10;\r\n}\r\nif (debug)\r\nfprintf(stderr, "%d*10^%d: 0x%x\n", i, exponent, (exponent << 7) | i);\r\nreturn (exponent << 7) | i;\r\n}\r\nint parse_cmdline_hwp_epp(int i)\r\n{\r\nupdate_hwp_epp = 1;\r\nswitch (i) {\r\ncase OPTARG_POWER:\r\nreturn HWP_EPP_POWERSAVE;\r\ncase OPTARG_BALANCE_POWER:\r\nreturn HWP_EPP_BALANCE_POWERSAVE;\r\ncase OPTARG_NORMAL:\r\ncase OPTARG_BALANCE_PERFORMANCE:\r\nreturn HWP_EPP_BALANCE_PERFORMANCE;\r\ncase OPTARG_PERFORMANCE:\r\nreturn HWP_EPP_PERFORMANCE;\r\n}\r\nif (i < 0 || i > 0xff) {\r\nfprintf(stderr, "--hwp-epp must be from 0 to 0xff\n");\r\nusage();\r\n}\r\nreturn i;\r\n}\r\nint parse_cmdline_turbo(int i)\r\n{\r\nupdate_turbo = 1;\r\nswitch (i) {\r\ncase OPTARG_POWER:\r\nreturn 0;\r\ncase OPTARG_NORMAL:\r\ncase OPTARG_BALANCE_POWER:\r\ncase OPTARG_BALANCE_PERFORMANCE:\r\ncase OPTARG_PERFORMANCE:\r\nreturn 1;\r\n}\r\nif (i < 0 || i > 1) {\r\nfprintf(stderr, "--turbo-enable: 1 to enable, 0 to disable\n");\r\nusage();\r\n}\r\nreturn i;\r\n}\r\nint parse_optarg_string(char *s)\r\n{\r\nint i;\r\nchar *endptr;\r\nif (!strncmp(s, "default", 7))\r\nreturn OPTARG_NORMAL;\r\nif (!strncmp(s, "normal", 6))\r\nreturn OPTARG_NORMAL;\r\nif (!strncmp(s, "power", 9))\r\nreturn OPTARG_POWER;\r\nif (!strncmp(s, "balance-power", 17))\r\nreturn OPTARG_BALANCE_POWER;\r\nif (!strncmp(s, "balance-performance", 19))\r\nreturn OPTARG_BALANCE_PERFORMANCE;\r\nif (!strncmp(s, "performance", 11))\r\nreturn OPTARG_PERFORMANCE;\r\ni = strtol(s, &endptr, 0);\r\nif (s == endptr) {\r\nfprintf(stderr, "no digits in \"%s\"\n", s);\r\nusage();\r\n}\r\nif (i == LONG_MIN || i == LONG_MAX)\r\nerrx(-1, "%s", s);\r\nif (i > 0xFF)\r\nerrx(-1, "%d (0x%x) must be < 256", i, i);\r\nif (i < 0)\r\nerrx(-1, "%d (0x%x) must be >= 0", i, i);\r\nreturn i;\r\n}\r\nvoid parse_cmdline_all(char *s)\r\n{\r\nforce++;\r\nupdate_hwp_enable = 1;\r\nreq_update.hwp_min = parse_cmdline_hwp_min(parse_optarg_string(s));\r\nreq_update.hwp_max = parse_cmdline_hwp_max(parse_optarg_string(s));\r\nreq_update.hwp_epp = parse_cmdline_hwp_epp(parse_optarg_string(s));\r\nif (has_epb)\r\nnew_epb = parse_cmdline_epb(parse_optarg_string(s));\r\nturbo_update_value = parse_cmdline_turbo(parse_optarg_string(s));\r\nreq_update.hwp_desired = parse_cmdline_hwp_desired(parse_optarg_string(s));\r\nreq_update.hwp_window = parse_cmdline_hwp_window(parse_optarg_string(s));\r\n}\r\nvoid validate_cpu_selected_set(void)\r\n{\r\nint cpu;\r\nif (CPU_COUNT_S(cpu_setsize, cpu_selected_set) == 0)\r\nerrx(0, "no CPUs requested");\r\nfor (cpu = 0; cpu <= max_cpu_num; ++cpu) {\r\nif (CPU_ISSET_S(cpu, cpu_setsize, cpu_selected_set))\r\nif (!CPU_ISSET_S(cpu, cpu_setsize, cpu_present_set))\r\nerrx(1, "Requested cpu% is not present", cpu);\r\n}\r\n}\r\nvoid parse_cmdline_cpu(char *s)\r\n{\r\nchar *startp, *endp;\r\nint cpu = 0;\r\nif (pkg_selected_set) {\r\nusage();\r\nerrx(1, "--cpu | --pkg");\r\n}\r\ncpu_selected_set = CPU_ALLOC((max_cpu_num + 1));\r\nif (cpu_selected_set == NULL)\r\nerr(1, "cpu_selected_set");\r\nCPU_ZERO_S(cpu_setsize, cpu_selected_set);\r\nfor (startp = s; startp && *startp;) {\r\nif (*startp == ',') {\r\nstartp++;\r\ncontinue;\r\n}\r\nif (*startp == '-') {\r\nint end_cpu;\r\nstartp++;\r\nend_cpu = strtol(startp, &endp, 10);\r\nif (startp == endp)\r\ncontinue;\r\nwhile (cpu <= end_cpu) {\r\nif (cpu > max_cpu_num)\r\nerrx(1, "Requested cpu%d exceeds max cpu%d", cpu, max_cpu_num);\r\nCPU_SET_S(cpu, cpu_setsize, cpu_selected_set);\r\ncpu++;\r\n}\r\nstartp = endp;\r\ncontinue;\r\n}\r\nif (strncmp(startp, "all", 3) == 0) {\r\nfor (cpu = 0; cpu <= max_cpu_num; cpu += 1) {\r\nif (CPU_ISSET_S(cpu, cpu_setsize, cpu_present_set))\r\nCPU_SET_S(cpu, cpu_setsize, cpu_selected_set);\r\n}\r\nstartp += 3;\r\nif (*startp == 0)\r\nbreak;\r\n}\r\nif (strncmp(startp, "even", 4) == 0) {\r\nfor (cpu = 0; cpu <= max_cpu_num; cpu += 2) {\r\nif (CPU_ISSET_S(cpu, cpu_setsize, cpu_present_set))\r\nCPU_SET_S(cpu, cpu_setsize, cpu_selected_set);\r\n}\r\nstartp += 4;\r\nif (*startp == 0)\r\nbreak;\r\n}\r\nif (strncmp(startp, "odd", 3) == 0) {\r\nfor (cpu = 1; cpu <= max_cpu_num; cpu += 2) {\r\nif (CPU_ISSET_S(cpu, cpu_setsize, cpu_present_set))\r\nCPU_SET_S(cpu, cpu_setsize, cpu_selected_set);\r\n}\r\nstartp += 3;\r\nif (*startp == 0)\r\nbreak;\r\n}\r\ncpu = strtol(startp, &endp, 10);\r\nif (startp == endp)\r\nerrx(1, "--cpu cpu-set: confused by '%s'", startp);\r\nif (cpu > max_cpu_num)\r\nerrx(1, "Requested cpu%d exceeds max cpu%d", cpu, max_cpu_num);\r\nCPU_SET_S(cpu, cpu_setsize, cpu_selected_set);\r\nstartp = endp;\r\n}\r\nvalidate_cpu_selected_set();\r\n}\r\nvoid parse_cmdline_pkg(char *s)\r\n{\r\nchar *startp, *endp;\r\nint pkg = 0;\r\nif (cpu_selected_set) {\r\nusage();\r\nerrx(1, "--pkg | --cpu");\r\n}\r\npkg_selected_set = 0;\r\nfor (startp = s; startp && *startp;) {\r\nif (*startp == ',') {\r\nstartp++;\r\ncontinue;\r\n}\r\nif (*startp == '-') {\r\nint end_pkg;\r\nstartp++;\r\nend_pkg = strtol(startp, &endp, 10);\r\nif (startp == endp)\r\ncontinue;\r\nwhile (pkg <= end_pkg) {\r\nif (pkg > max_pkg_num)\r\nerrx(1, "Requested pkg%d exceeds max pkg%d", pkg, max_pkg_num);\r\npkg_selected_set |= 1 << pkg;\r\npkg++;\r\n}\r\nstartp = endp;\r\ncontinue;\r\n}\r\nif (strncmp(startp, "all", 3) == 0) {\r\npkg_selected_set = pkg_present_set;\r\nreturn;\r\n}\r\npkg = strtol(startp, &endp, 10);\r\nif (pkg > max_pkg_num)\r\nerrx(1, "Requested pkg%d Exceeds max pkg%d", pkg, max_pkg_num);\r\npkg_selected_set |= 1 << pkg;\r\nstartp = endp;\r\n}\r\n}\r\nvoid for_packages(unsigned long long pkg_set, int (func)(int))\r\n{\r\nint pkg_num;\r\nfor (pkg_num = 0; pkg_num <= max_pkg_num; ++pkg_num) {\r\nif (pkg_set & (1UL << pkg_num))\r\nfunc(pkg_num);\r\n}\r\n}\r\nvoid print_version(void)\r\n{\r\nprintf("x86_energy_perf_policy 17.05.11 (C) Len Brown <len.brown@intel.com>\n");\r\n}\r\nvoid cmdline(int argc, char **argv)\r\n{\r\nint opt;\r\nint option_index = 0;\r\nstatic struct option long_options[] = {\r\n{"all", required_argument, 0, 'a'},\r\n{"cpu", required_argument, 0, 'c'},\r\n{"pkg", required_argument, 0, 'p'},\r\n{"debug", no_argument, 0, 'd'},\r\n{"hwp-desired", required_argument, 0, 'D'},\r\n{"epb", required_argument, 0, 'B'},\r\n{"force", no_argument, 0, 'f'},\r\n{"hwp-enable", no_argument, 0, 'e'},\r\n{"help", no_argument, 0, 'h'},\r\n{"hwp-epp", required_argument, 0, 'P'},\r\n{"hwp-min", required_argument, 0, 'm'},\r\n{"hwp-max", required_argument, 0, 'M'},\r\n{"read", no_argument, 0, 'r'},\r\n{"turbo-enable", required_argument, 0, 't'},\r\n{"hwp-use-pkg", required_argument, 0, 'u'},\r\n{"version", no_argument, 0, 'v'},\r\n{"hwp-window", required_argument, 0, 'w'},\r\n{0, 0, 0, 0 }\r\n};\r\nprogname = argv[0];\r\nwhile ((opt = getopt_long_only(argc, argv, "+a:c:dD:E:e:f:m:M:rt:u:vw",\r\nlong_options, &option_index)) != -1) {\r\nswitch (opt) {\r\ncase 'a':\r\nparse_cmdline_all(optarg);\r\nbreak;\r\ncase 'B':\r\nnew_epb = parse_cmdline_epb(parse_optarg_string(optarg));\r\nbreak;\r\ncase 'c':\r\nparse_cmdline_cpu(optarg);\r\nbreak;\r\ncase 'e':\r\nupdate_hwp_enable = 1;\r\nbreak;\r\ncase 'h':\r\nusage();\r\nbreak;\r\ncase 'd':\r\ndebug++;\r\nverbose++;\r\nbreak;\r\ncase 'f':\r\nforce++;\r\nbreak;\r\ncase 'D':\r\nreq_update.hwp_desired = parse_cmdline_hwp_desired(parse_optarg_string(optarg));\r\nbreak;\r\ncase 'm':\r\nreq_update.hwp_min = parse_cmdline_hwp_min(parse_optarg_string(optarg));\r\nbreak;\r\ncase 'M':\r\nreq_update.hwp_max = parse_cmdline_hwp_max(parse_optarg_string(optarg));\r\nbreak;\r\ncase 'p':\r\nparse_cmdline_pkg(optarg);\r\nbreak;\r\ncase 'P':\r\nreq_update.hwp_epp = parse_cmdline_hwp_epp(parse_optarg_string(optarg));\r\nbreak;\r\ncase 'r':\r\nbreak;\r\ncase 't':\r\nturbo_update_value = parse_cmdline_turbo(parse_optarg_string(optarg));\r\nbreak;\r\ncase 'u':\r\nupdate_hwp_use_pkg++;\r\nif (atoi(optarg) == 0)\r\nreq_update.hwp_use_pkg = 0;\r\nelse\r\nreq_update.hwp_use_pkg = 1;\r\nbreak;\r\ncase 'v':\r\nprint_version();\r\nexit(0);\r\nbreak;\r\ncase 'w':\r\nreq_update.hwp_window = parse_cmdline_hwp_window(parse_optarg_string(optarg));\r\nbreak;\r\ndefault:\r\nusage();\r\n}\r\n}\r\nif (argc == optind + 1)\r\nnew_epb = parse_cmdline_epb(parse_optarg_string(argv[optind]));\r\nif (argc > optind + 1) {\r\nfprintf(stderr, "stray parameter '%s'\n", argv[optind + 1]);\r\nusage();\r\n}\r\n}\r\nint get_msr(int cpu, int offset, unsigned long long *msr)\r\n{\r\nint retval;\r\nchar pathname[32];\r\nint fd;\r\nsprintf(pathname, "/dev/cpu/%d/msr", cpu);\r\nfd = open(pathname, O_RDONLY);\r\nif (fd < 0)\r\nerr(-1, "%s open failed, try chown or chmod +r /dev/cpu/*/msr, or run as root", pathname);\r\nretval = pread(fd, msr, sizeof(*msr), offset);\r\nif (retval != sizeof(*msr))\r\nerr(-1, "%s offset 0x%llx read failed", pathname, (unsigned long long)offset);\r\nif (debug > 1)\r\nfprintf(stderr, "get_msr(cpu%d, 0x%X, 0x%llX)\n", cpu, offset, *msr);\r\nclose(fd);\r\nreturn 0;\r\n}\r\nint put_msr(int cpu, int offset, unsigned long long new_msr)\r\n{\r\nchar pathname[32];\r\nint retval;\r\nint fd;\r\nsprintf(pathname, "/dev/cpu/%d/msr", cpu);\r\nfd = open(pathname, O_RDWR);\r\nif (fd < 0)\r\nerr(-1, "%s open failed, try chown or chmod +r /dev/cpu/*/msr, or run as root", pathname);\r\nretval = pwrite(fd, &new_msr, sizeof(new_msr), offset);\r\nif (retval != sizeof(new_msr))\r\nerr(-2, "pwrite(cpu%d, offset 0x%x, 0x%llx) = %d", cpu, offset, new_msr, retval);\r\nclose(fd);\r\nif (debug > 1)\r\nfprintf(stderr, "put_msr(cpu%d, 0x%X, 0x%llX)\n", cpu, offset, new_msr);\r\nreturn 0;\r\n}\r\nvoid print_hwp_cap(int cpu, struct msr_hwp_cap *cap, char *str)\r\n{\r\nif (cpu != -1)\r\nprintf("cpu%d: ", cpu);\r\nprintf("HWP_CAP: low %d eff %d guar %d high %d\n",\r\ncap->lowest, cap->efficient, cap->guaranteed, cap->highest);\r\n}\r\nvoid read_hwp_cap(int cpu, struct msr_hwp_cap *cap, unsigned int msr_offset)\r\n{\r\nunsigned long long msr;\r\nget_msr(cpu, msr_offset, &msr);\r\ncap->highest = msr_perf_2_ratio(HWP_HIGHEST_PERF(msr));\r\ncap->guaranteed = msr_perf_2_ratio(HWP_GUARANTEED_PERF(msr));\r\ncap->efficient = msr_perf_2_ratio(HWP_MOSTEFFICIENT_PERF(msr));\r\ncap->lowest = msr_perf_2_ratio(HWP_LOWEST_PERF(msr));\r\n}\r\nvoid print_hwp_request(int cpu, struct msr_hwp_request *h, char *str)\r\n{\r\nif (cpu != -1)\r\nprintf("cpu%d: ", cpu);\r\nif (str)\r\nprintf("%s", str);\r\nprintf("HWP_REQ: min %d max %d des %d epp %d window 0x%x (%d*10^%dus) use_pkg %d\n",\r\nh->hwp_min, h->hwp_max, h->hwp_desired, h->hwp_epp,\r\nh->hwp_window, h->hwp_window & 0x7F, (h->hwp_window >> 7) & 0x7, h->hwp_use_pkg);\r\n}\r\nvoid print_hwp_request_pkg(int pkg, struct msr_hwp_request *h, char *str)\r\n{\r\nprintf("pkg%d: ", pkg);\r\nif (str)\r\nprintf("%s", str);\r\nprintf("HWP_REQ_PKG: min %d max %d des %d epp %d window 0x%x (%d*10^%dus)\n",\r\nh->hwp_min, h->hwp_max, h->hwp_desired, h->hwp_epp,\r\nh->hwp_window, h->hwp_window & 0x7F, (h->hwp_window >> 7) & 0x7);\r\n}\r\nvoid read_hwp_request(int cpu, struct msr_hwp_request *hwp_req, unsigned int msr_offset)\r\n{\r\nunsigned long long msr;\r\nget_msr(cpu, msr_offset, &msr);\r\nhwp_req->hwp_min = msr_perf_2_ratio((((msr) >> 0) & 0xff));\r\nhwp_req->hwp_max = msr_perf_2_ratio((((msr) >> 8) & 0xff));\r\nhwp_req->hwp_desired = msr_perf_2_ratio((((msr) >> 16) & 0xff));\r\nhwp_req->hwp_epp = (((msr) >> 24) & 0xff);\r\nhwp_req->hwp_window = (((msr) >> 32) & 0x3ff);\r\nhwp_req->hwp_use_pkg = (((msr) >> 42) & 0x1);\r\n}\r\nvoid write_hwp_request(int cpu, struct msr_hwp_request *hwp_req, unsigned int msr_offset)\r\n{\r\nunsigned long long msr = 0;\r\nif (debug > 1)\r\nprintf("cpu%d: requesting min %d max %d des %d epp %d window 0x%0x use_pkg %d\n",\r\ncpu, hwp_req->hwp_min, hwp_req->hwp_max,\r\nhwp_req->hwp_desired, hwp_req->hwp_epp,\r\nhwp_req->hwp_window, hwp_req->hwp_use_pkg);\r\nmsr |= HWP_MIN_PERF(ratio_2_msr_perf(hwp_req->hwp_min));\r\nmsr |= HWP_MAX_PERF(ratio_2_msr_perf(hwp_req->hwp_max));\r\nmsr |= HWP_DESIRED_PERF(ratio_2_msr_perf(hwp_req->hwp_desired));\r\nmsr |= HWP_ENERGY_PERF_PREFERENCE(hwp_req->hwp_epp);\r\nmsr |= HWP_ACTIVITY_WINDOW(hwp_req->hwp_window);\r\nmsr |= HWP_PACKAGE_CONTROL(hwp_req->hwp_use_pkg);\r\nput_msr(cpu, msr_offset, msr);\r\n}\r\nint print_cpu_msrs(int cpu)\r\n{\r\nunsigned long long msr;\r\nstruct msr_hwp_request req;\r\nstruct msr_hwp_cap cap;\r\nif (has_epb) {\r\nget_msr(cpu, MSR_IA32_ENERGY_PERF_BIAS, &msr);\r\nprintf("cpu%d: EPB %u\n", cpu, (unsigned int) msr);\r\n}\r\nif (!has_hwp)\r\nreturn 0;\r\nread_hwp_request(cpu, &req, MSR_HWP_REQUEST);\r\nprint_hwp_request(cpu, &req, "");\r\nread_hwp_cap(cpu, &cap, MSR_HWP_CAPABILITIES);\r\nprint_hwp_cap(cpu, &cap, "");\r\nreturn 0;\r\n}\r\nint print_pkg_msrs(int pkg)\r\n{\r\nstruct msr_hwp_request req;\r\nunsigned long long msr;\r\nif (!has_hwp)\r\nreturn 0;\r\nread_hwp_request(first_cpu_in_pkg[pkg], &req, MSR_HWP_REQUEST_PKG);\r\nprint_hwp_request_pkg(pkg, &req, "");\r\nif (has_hwp_notify) {\r\nget_msr(first_cpu_in_pkg[pkg], MSR_HWP_INTERRUPT, &msr);\r\nfprintf(stderr,\r\n"pkg%d: MSR_HWP_INTERRUPT: 0x%08llx (Excursion_Min-%sabled, Guaranteed_Perf_Change-%sabled)\n",\r\npkg, msr,\r\n((msr) & 0x2) ? "EN" : "Dis",\r\n((msr) & 0x1) ? "EN" : "Dis");\r\n}\r\nget_msr(first_cpu_in_pkg[pkg], MSR_HWP_STATUS, &msr);\r\nfprintf(stderr,\r\n"pkg%d: MSR_HWP_STATUS: 0x%08llx (%sExcursion_Min, %sGuaranteed_Perf_Change)\n",\r\npkg, msr,\r\n((msr) & 0x4) ? "" : "No-",\r\n((msr) & 0x1) ? "" : "No-");\r\nreturn 0;\r\n}\r\nint ratio_2_sysfs_khz(int ratio)\r\n{\r\nint bclk_khz = 100 * 1000;\r\nreturn ratio * bclk_khz;\r\n}\r\nvoid update_cpufreq_scaling_freq(int is_max, int cpu, unsigned int ratio)\r\n{\r\nchar pathname[64];\r\nFILE *fp;\r\nint retval;\r\nint khz;\r\nsprintf(pathname, "/sys/devices/system/cpu/cpu%d/cpufreq/scaling_%s_freq",\r\ncpu, is_max ? "max" : "min");\r\nfp = fopen(pathname, "w");\r\nif (!fp) {\r\nif (debug)\r\nperror(pathname);\r\nreturn;\r\n}\r\nkhz = ratio_2_sysfs_khz(ratio);\r\nretval = fprintf(fp, "%d", khz);\r\nif (retval < 0)\r\nif (debug)\r\nperror("fprintf");\r\nif (debug)\r\nprintf("echo %d > %s\n", khz, pathname);\r\nfclose(fp);\r\n}\r\nint update_sysfs(int cpu)\r\n{\r\nif (!has_hwp)\r\nreturn 0;\r\nif (!hwp_update_enabled())\r\nreturn 0;\r\nif (access("/sys/devices/system/cpu/cpu0/cpufreq", F_OK))\r\nreturn 0;\r\nif (update_hwp_min)\r\nupdate_cpufreq_scaling_freq(0, cpu, req_update.hwp_min);\r\nif (update_hwp_max)\r\nupdate_cpufreq_scaling_freq(1, cpu, req_update.hwp_max);\r\nreturn 0;\r\n}\r\nint verify_hwp_req_self_consistency(int cpu, struct msr_hwp_request *req)\r\n{\r\nif (req->hwp_min > req->hwp_max) {\r\nerrx(1, "cpu%d: requested hwp-min %d > hwp_max %d",\r\ncpu, req->hwp_min, req->hwp_max);\r\n}\r\nif (req->hwp_desired && (req->hwp_desired > req->hwp_max)) {\r\nerrx(1, "cpu%d: requested hwp-desired %d > hwp_max %d",\r\ncpu, req->hwp_desired, req->hwp_max);\r\n}\r\nif (req->hwp_desired && (req->hwp_desired < req->hwp_min)) {\r\nerrx(1, "cpu%d: requested hwp-desired %d < requested hwp_min %d",\r\ncpu, req->hwp_desired, req->hwp_min);\r\n}\r\nreturn 0;\r\n}\r\nint check_hwp_request_v_hwp_capabilities(int cpu, struct msr_hwp_request *req, struct msr_hwp_cap *cap)\r\n{\r\nif (update_hwp_max) {\r\nif (req->hwp_max > cap->highest)\r\nerrx(1, "cpu%d: requested max %d > capabilities highest %d, use --force?",\r\ncpu, req->hwp_max, cap->highest);\r\nif (req->hwp_max < cap->lowest)\r\nerrx(1, "cpu%d: requested max %d < capabilities lowest %d, use --force?",\r\ncpu, req->hwp_max, cap->lowest);\r\n}\r\nif (update_hwp_min) {\r\nif (req->hwp_min > cap->highest)\r\nerrx(1, "cpu%d: requested min %d > capabilities highest %d, use --force?",\r\ncpu, req->hwp_min, cap->highest);\r\nif (req->hwp_min < cap->lowest)\r\nerrx(1, "cpu%d: requested min %d < capabilities lowest %d, use --force?",\r\ncpu, req->hwp_min, cap->lowest);\r\n}\r\nif (update_hwp_min && update_hwp_max && (req->hwp_min > req->hwp_max))\r\nerrx(1, "cpu%d: requested min %d > requested max %d",\r\ncpu, req->hwp_min, req->hwp_max);\r\nif (update_hwp_desired && req->hwp_desired) {\r\nif (req->hwp_desired > req->hwp_max)\r\nerrx(1, "cpu%d: requested desired %d > requested max %d, use --force?",\r\ncpu, req->hwp_desired, req->hwp_max);\r\nif (req->hwp_desired < req->hwp_min)\r\nerrx(1, "cpu%d: requested desired %d < requested min %d, use --force?",\r\ncpu, req->hwp_desired, req->hwp_min);\r\nif (req->hwp_desired < cap->lowest)\r\nerrx(1, "cpu%d: requested desired %d < capabilities lowest %d, use --force?",\r\ncpu, req->hwp_desired, cap->lowest);\r\nif (req->hwp_desired > cap->highest)\r\nerrx(1, "cpu%d: requested desired %d > capabilities highest %d, use --force?",\r\ncpu, req->hwp_desired, cap->highest);\r\n}\r\nreturn 0;\r\n}\r\nint update_hwp_request(int cpu)\r\n{\r\nstruct msr_hwp_request req;\r\nstruct msr_hwp_cap cap;\r\nint msr_offset = MSR_HWP_REQUEST;\r\nread_hwp_request(cpu, &req, msr_offset);\r\nif (debug)\r\nprint_hwp_request(cpu, &req, "old: ");\r\nif (update_hwp_min)\r\nreq.hwp_min = req_update.hwp_min;\r\nif (update_hwp_max)\r\nreq.hwp_max = req_update.hwp_max;\r\nif (update_hwp_desired)\r\nreq.hwp_desired = req_update.hwp_desired;\r\nif (update_hwp_window)\r\nreq.hwp_window = req_update.hwp_window;\r\nif (update_hwp_epp)\r\nreq.hwp_epp = req_update.hwp_epp;\r\nreq.hwp_use_pkg = req_update.hwp_use_pkg;\r\nread_hwp_cap(cpu, &cap, MSR_HWP_CAPABILITIES);\r\nif (debug)\r\nprint_hwp_cap(cpu, &cap, "");\r\nif (!force)\r\ncheck_hwp_request_v_hwp_capabilities(cpu, &req, &cap);\r\nverify_hwp_req_self_consistency(cpu, &req);\r\nwrite_hwp_request(cpu, &req, msr_offset);\r\nif (debug) {\r\nread_hwp_request(cpu, &req, msr_offset);\r\nprint_hwp_request(cpu, &req, "new: ");\r\n}\r\nreturn 0;\r\n}\r\nint update_hwp_request_pkg(int pkg)\r\n{\r\nstruct msr_hwp_request req;\r\nstruct msr_hwp_cap cap;\r\nint cpu = first_cpu_in_pkg[pkg];\r\nint msr_offset = MSR_HWP_REQUEST_PKG;\r\nread_hwp_request(cpu, &req, msr_offset);\r\nif (debug)\r\nprint_hwp_request_pkg(pkg, &req, "old: ");\r\nif (update_hwp_min)\r\nreq.hwp_min = req_update.hwp_min;\r\nif (update_hwp_max)\r\nreq.hwp_max = req_update.hwp_max;\r\nif (update_hwp_desired)\r\nreq.hwp_desired = req_update.hwp_desired;\r\nif (update_hwp_window)\r\nreq.hwp_window = req_update.hwp_window;\r\nif (update_hwp_epp)\r\nreq.hwp_epp = req_update.hwp_epp;\r\nread_hwp_cap(cpu, &cap, MSR_HWP_CAPABILITIES);\r\nif (debug)\r\nprint_hwp_cap(cpu, &cap, "");\r\nif (!force)\r\ncheck_hwp_request_v_hwp_capabilities(cpu, &req, &cap);\r\nverify_hwp_req_self_consistency(cpu, &req);\r\nwrite_hwp_request(cpu, &req, msr_offset);\r\nif (debug) {\r\nread_hwp_request(cpu, &req, msr_offset);\r\nprint_hwp_request_pkg(pkg, &req, "new: ");\r\n}\r\nreturn 0;\r\n}\r\nint enable_hwp_on_cpu(int cpu)\r\n{\r\nunsigned long long msr;\r\nget_msr(cpu, MSR_PM_ENABLE, &msr);\r\nput_msr(cpu, MSR_PM_ENABLE, 1);\r\nif (verbose)\r\nprintf("cpu%d: MSR_PM_ENABLE old: %d new: %d\n", cpu, (unsigned int) msr, 1);\r\nreturn 0;\r\n}\r\nint update_cpu_msrs(int cpu)\r\n{\r\nunsigned long long msr;\r\nif (update_epb) {\r\nget_msr(cpu, MSR_IA32_ENERGY_PERF_BIAS, &msr);\r\nput_msr(cpu, MSR_IA32_ENERGY_PERF_BIAS, new_epb);\r\nif (verbose)\r\nprintf("cpu%d: ENERGY_PERF_BIAS old: %d new: %d\n",\r\ncpu, (unsigned int) msr, (unsigned int) new_epb);\r\n}\r\nif (update_turbo) {\r\nint turbo_is_present_and_disabled;\r\nget_msr(cpu, MSR_IA32_MISC_ENABLE, &msr);\r\nturbo_is_present_and_disabled = ((msr & MSR_IA32_MISC_ENABLE_TURBO_DISABLE) != 0);\r\nif (turbo_update_value == 1) {\r\nif (turbo_is_present_and_disabled) {\r\nmsr &= ~MSR_IA32_MISC_ENABLE_TURBO_DISABLE;\r\nput_msr(cpu, MSR_IA32_MISC_ENABLE, msr);\r\nif (verbose)\r\nprintf("cpu%d: turbo ENABLE\n", cpu);\r\n}\r\n} else {\r\nmsr |= MSR_IA32_MISC_ENABLE_TURBO_DISABLE;\r\nput_msr(cpu, MSR_IA32_MISC_ENABLE, msr);\r\nif (verbose)\r\nprintf("cpu%d: turbo DISABLE\n", cpu);\r\n}\r\n}\r\nif (!has_hwp)\r\nreturn 0;\r\nif (!hwp_update_enabled())\r\nreturn 0;\r\nupdate_hwp_request(cpu);\r\nreturn 0;\r\n}\r\nFILE *fopen_or_die(const char *path, const char *mode)\r\n{\r\nFILE *filep = fopen(path, "r");\r\nif (!filep)\r\nerr(1, "%s: open failed", path);\r\nreturn filep;\r\n}\r\nunsigned int get_pkg_num(int cpu)\r\n{\r\nFILE *fp;\r\nchar pathname[128];\r\nunsigned int pkg;\r\nint retval;\r\nsprintf(pathname, "/sys/devices/system/cpu/cpu%d/topology/physical_package_id", cpu);\r\nfp = fopen_or_die(pathname, "r");\r\nretval = fscanf(fp, "%d\n", &pkg);\r\nif (retval != 1)\r\nerrx(1, "%s: failed to parse", pathname);\r\nreturn pkg;\r\n}\r\nint set_max_cpu_pkg_num(int cpu)\r\n{\r\nunsigned int pkg;\r\nif (max_cpu_num < cpu)\r\nmax_cpu_num = cpu;\r\npkg = get_pkg_num(cpu);\r\nif (pkg >= MAX_PACKAGES)\r\nerrx(1, "cpu%d: %d >= MAX_PACKAGES (%d)", cpu, pkg, MAX_PACKAGES);\r\nif (pkg > max_pkg_num)\r\nmax_pkg_num = pkg;\r\nif ((pkg_present_set & (1ULL << pkg)) == 0) {\r\npkg_present_set |= (1ULL << pkg);\r\nfirst_cpu_in_pkg[pkg] = cpu;\r\n}\r\nreturn 0;\r\n}\r\nint mark_cpu_present(int cpu)\r\n{\r\nCPU_SET_S(cpu, cpu_setsize, cpu_present_set);\r\nreturn 0;\r\n}\r\nint for_all_proc_cpus(int (func)(int))\r\n{\r\nFILE *fp;\r\nint cpu_num;\r\nint retval;\r\nfp = fopen_or_die(proc_stat, "r");\r\nretval = fscanf(fp, "cpu %*d %*d %*d %*d %*d %*d %*d %*d %*d %*d\n");\r\nif (retval != 0)\r\nerr(1, "%s: failed to parse format", proc_stat);\r\nwhile (1) {\r\nretval = fscanf(fp, "cpu%u %*d %*d %*d %*d %*d %*d %*d %*d %*d %*d\n", &cpu_num);\r\nif (retval != 1)\r\nbreak;\r\nretval = func(cpu_num);\r\nif (retval) {\r\nfclose(fp);\r\nreturn retval;\r\n}\r\n}\r\nfclose(fp);\r\nreturn 0;\r\n}\r\nvoid for_all_cpus_in_set(size_t set_size, cpu_set_t *cpu_set, int (func)(int))\r\n{\r\nint cpu_num;\r\nfor (cpu_num = 0; cpu_num <= max_cpu_num; ++cpu_num)\r\nif (CPU_ISSET_S(cpu_num, set_size, cpu_set))\r\nfunc(cpu_num);\r\n}\r\nvoid init_data_structures(void)\r\n{\r\nfor_all_proc_cpus(set_max_cpu_pkg_num);\r\ncpu_setsize = CPU_ALLOC_SIZE((max_cpu_num + 1));\r\ncpu_present_set = CPU_ALLOC((max_cpu_num + 1));\r\nif (cpu_present_set == NULL)\r\nerr(3, "CPU_ALLOC");\r\nCPU_ZERO_S(cpu_setsize, cpu_present_set);\r\nfor_all_proc_cpus(mark_cpu_present);\r\n}\r\nvoid verify_hwp_is_enabled(void)\r\n{\r\nunsigned long long msr;\r\nif (!has_hwp)\r\nreturn;\r\nget_msr(base_cpu, MSR_PM_ENABLE, &msr);\r\nif ((msr & 1) == 0) {\r\nfprintf(stderr, "HWP can be enabled using '--hwp-enable'\n");\r\nhas_hwp = 0;\r\nreturn;\r\n}\r\n}\r\nint req_update_bounds_check(void)\r\n{\r\nif (!hwp_update_enabled())\r\nreturn 0;\r\nif ((update_hwp_max && update_hwp_min) &&\r\n(req_update.hwp_min > req_update.hwp_max)) {\r\nprintf("hwp-min %d > hwp_max %d\n", req_update.hwp_min, req_update.hwp_max);\r\nreturn -EINVAL;\r\n}\r\nif (req_update.hwp_desired && update_hwp_max &&\r\n(req_update.hwp_desired > req_update.hwp_max)) {\r\nprintf("hwp-desired cannot be greater than hwp_max\n");\r\nreturn -EINVAL;\r\n}\r\nif (req_update.hwp_desired && update_hwp_min &&\r\n(req_update.hwp_desired < req_update.hwp_min)) {\r\nprintf("hwp-desired cannot be less than hwp_min\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nvoid set_base_cpu(void)\r\n{\r\nbase_cpu = sched_getcpu();\r\nif (base_cpu < 0)\r\nerr(-ENODEV, "No valid cpus found");\r\n}\r\nvoid probe_dev_msr(void)\r\n{\r\nstruct stat sb;\r\nchar pathname[32];\r\nsprintf(pathname, "/dev/cpu/%d/msr", base_cpu);\r\nif (stat(pathname, &sb))\r\nif (system("/sbin/modprobe msr > /dev/null 2>&1"))\r\nerr(-5, "no /dev/cpu/0/msr, Try \"# modprobe msr\" ");\r\n}\r\nvoid early_cpuid(void)\r\n{\r\nunsigned int eax, ebx, ecx, edx, max_level;\r\nunsigned int fms, family, model;\r\n__get_cpuid(0, &max_level, &ebx, &ecx, &edx);\r\nif (max_level < 6)\r\nerrx(1, "Processor not supported\n");\r\n__get_cpuid(1, &fms, &ebx, &ecx, &edx);\r\nfamily = (fms >> 8) & 0xf;\r\nmodel = (fms >> 4) & 0xf;\r\nif (family == 6 || family == 0xf)\r\nmodel += ((fms >> 16) & 0xf) << 4;\r\nif (model == 0x4F) {\r\nunsigned long long msr;\r\nget_msr(base_cpu, MSR_TURBO_RATIO_LIMIT, &msr);\r\nbdx_highest_ratio = msr & 0xFF;\r\n}\r\n__get_cpuid(0x6, &eax, &ebx, &ecx, &edx);\r\nturbo_is_enabled = (eax >> 1) & 1;\r\nhas_hwp = (eax >> 7) & 1;\r\nhas_epb = (ecx >> 3) & 1;\r\n}\r\nvoid parse_cpuid(void)\r\n{\r\nunsigned int eax, ebx, ecx, edx, max_level;\r\nunsigned int fms, family, model, stepping;\r\neax = ebx = ecx = edx = 0;\r\n__get_cpuid(0, &max_level, &ebx, &ecx, &edx);\r\nif (ebx == 0x756e6547 && edx == 0x49656e69 && ecx == 0x6c65746e)\r\ngenuine_intel = 1;\r\nif (debug)\r\nfprintf(stderr, "CPUID(0): %.4s%.4s%.4s ",\r\n(char *)&ebx, (char *)&edx, (char *)&ecx);\r\n__get_cpuid(1, &fms, &ebx, &ecx, &edx);\r\nfamily = (fms >> 8) & 0xf;\r\nmodel = (fms >> 4) & 0xf;\r\nstepping = fms & 0xf;\r\nif (family == 6 || family == 0xf)\r\nmodel += ((fms >> 16) & 0xf) << 4;\r\nif (debug) {\r\nfprintf(stderr, "%d CPUID levels; family:model:stepping 0x%x:%x:%x (%d:%d:%d)\n",\r\nmax_level, family, model, stepping, family, model, stepping);\r\nfprintf(stderr, "CPUID(1): %s %s %s %s %s %s %s %s\n",\r\necx & (1 << 0) ? "SSE3" : "-",\r\necx & (1 << 3) ? "MONITOR" : "-",\r\necx & (1 << 7) ? "EIST" : "-",\r\necx & (1 << 8) ? "TM2" : "-",\r\nedx & (1 << 4) ? "TSC" : "-",\r\nedx & (1 << 5) ? "MSR" : "-",\r\nedx & (1 << 22) ? "ACPI-TM" : "-",\r\nedx & (1 << 29) ? "TM" : "-");\r\n}\r\nif (!(edx & (1 << 5)))\r\nerrx(1, "CPUID: no MSR");\r\n__get_cpuid(0x6, &eax, &ebx, &ecx, &edx);\r\nhas_hwp_notify = eax & (1 << 8);\r\nhas_hwp_activity_window = eax & (1 << 9);\r\nhas_hwp_epp = eax & (1 << 10);\r\nhas_hwp_request_pkg = eax & (1 << 11);\r\nif (!has_hwp_request_pkg && update_hwp_use_pkg)\r\nerrx(1, "--hwp-use-pkg is not available on this hardware");\r\nif (debug)\r\nfprintf(stderr,\r\n"CPUID(6): %sTURBO, %sHWP, %sHWPnotify, %sHWPwindow, %sHWPepp, %sHWPpkg, %sEPB\n",\r\nturbo_is_enabled ? "" : "No-",\r\nhas_hwp ? "" : "No-",\r\nhas_hwp_notify ? "" : "No-",\r\nhas_hwp_activity_window ? "" : "No-",\r\nhas_hwp_epp ? "" : "No-",\r\nhas_hwp_request_pkg ? "" : "No-",\r\nhas_epb ? "" : "No-");\r\nreturn;\r\n}\r\nint main(int argc, char **argv)\r\n{\r\nset_base_cpu();\r\nprobe_dev_msr();\r\ninit_data_structures();\r\nearly_cpuid();\r\ncmdline(argc, argv);\r\nif (debug)\r\nprint_version();\r\nparse_cpuid();\r\nif ((cpu_selected_set == 0) && (pkg_selected_set == 0))\r\ncpu_selected_set = cpu_present_set;\r\nif (update_hwp_enable)\r\nfor_all_cpus_in_set(cpu_setsize, cpu_selected_set, enable_hwp_on_cpu);\r\nverify_hwp_is_enabled();\r\nif (req_update_bounds_check())\r\nreturn -EINVAL;\r\nif (!update_epb && !update_turbo && !hwp_update_enabled()) {\r\nif (cpu_selected_set)\r\nfor_all_cpus_in_set(cpu_setsize, cpu_selected_set, print_cpu_msrs);\r\nif (has_hwp_request_pkg) {\r\nif (pkg_selected_set == 0)\r\npkg_selected_set = pkg_present_set;\r\nfor_packages(pkg_selected_set, print_pkg_msrs);\r\n}\r\nreturn 0;\r\n}\r\nif (cpu_selected_set) {\r\nfor_all_cpus_in_set(cpu_setsize, cpu_selected_set, update_sysfs);\r\nfor_all_cpus_in_set(cpu_setsize, cpu_selected_set, update_cpu_msrs);\r\n} else if (pkg_selected_set)\r\nfor_packages(pkg_selected_set, update_hwp_request_pkg);\r\nreturn 0;\r\n}
