static inline struct platram_info *to_platram_info(struct platform_device *dev)\r\n{\r\nreturn platform_get_drvdata(dev);\r\n}\r\nstatic inline void platram_setrw(struct platram_info *info, int to)\r\n{\r\nif (info->pdata == NULL)\r\nreturn;\r\nif (info->pdata->set_rw != NULL)\r\n(info->pdata->set_rw)(info->dev, to);\r\n}\r\nstatic int platram_remove(struct platform_device *pdev)\r\n{\r\nstruct platram_info *info = to_platram_info(pdev);\r\ndev_dbg(&pdev->dev, "removing device\n");\r\nif (info == NULL)\r\nreturn 0;\r\nif (info->mtd) {\r\nmtd_device_unregister(info->mtd);\r\nmap_destroy(info->mtd);\r\n}\r\nplatram_setrw(info, PLATRAM_RO);\r\nif (info->area) {\r\nrelease_resource(info->area);\r\nkfree(info->area);\r\n}\r\nif (info->map.virt != NULL)\r\niounmap(info->map.virt);\r\nkfree(info);\r\nreturn 0;\r\n}\r\nstatic int platram_probe(struct platform_device *pdev)\r\n{\r\nstruct platdata_mtd_ram *pdata;\r\nstruct platram_info *info;\r\nstruct resource *res;\r\nint err = 0;\r\ndev_dbg(&pdev->dev, "probe entered\n");\r\nif (dev_get_platdata(&pdev->dev) == NULL) {\r\ndev_err(&pdev->dev, "no platform data supplied\n");\r\nerr = -ENOENT;\r\ngoto exit_error;\r\n}\r\npdata = dev_get_platdata(&pdev->dev);\r\ninfo = kzalloc(sizeof(*info), GFP_KERNEL);\r\nif (info == NULL) {\r\nerr = -ENOMEM;\r\ngoto exit_error;\r\n}\r\nplatform_set_drvdata(pdev, info);\r\ninfo->dev = &pdev->dev;\r\ninfo->pdata = pdata;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "no memory resource specified\n");\r\nerr = -ENOENT;\r\ngoto exit_free;\r\n}\r\ndev_dbg(&pdev->dev, "got platform resource %p (0x%llx)\n", res,\r\n(unsigned long long)res->start);\r\ninfo->map.phys = res->start;\r\ninfo->map.size = resource_size(res);\r\ninfo->map.name = pdata->mapname != NULL ?\r\n(char *)pdata->mapname : (char *)pdev->name;\r\ninfo->map.bankwidth = pdata->bankwidth;\r\ninfo->area = request_mem_region(res->start, info->map.size, pdev->name);\r\nif (info->area == NULL) {\r\ndev_err(&pdev->dev, "failed to request memory region\n");\r\nerr = -EIO;\r\ngoto exit_free;\r\n}\r\ninfo->map.virt = ioremap(res->start, info->map.size);\r\ndev_dbg(&pdev->dev, "virt %p, %lu bytes\n", info->map.virt, info->map.size);\r\nif (info->map.virt == NULL) {\r\ndev_err(&pdev->dev, "failed to ioremap() region\n");\r\nerr = -EIO;\r\ngoto exit_free;\r\n}\r\nsimple_map_init(&info->map);\r\ndev_dbg(&pdev->dev, "initialised map, probing for mtd\n");\r\nif (pdata->map_probes) {\r\nconst char * const *map_probes = pdata->map_probes;\r\nfor ( ; !info->mtd && *map_probes; map_probes++)\r\ninfo->mtd = do_map_probe(*map_probes , &info->map);\r\n}\r\nelse\r\ninfo->mtd = do_map_probe("map_ram", &info->map);\r\nif (info->mtd == NULL) {\r\ndev_err(&pdev->dev, "failed to probe for map_ram\n");\r\nerr = -ENOMEM;\r\ngoto exit_free;\r\n}\r\ninfo->mtd->dev.parent = &pdev->dev;\r\nplatram_setrw(info, PLATRAM_RW);\r\nerr = mtd_device_parse_register(info->mtd, pdata->probes, NULL,\r\npdata->partitions,\r\npdata->nr_partitions);\r\nif (!err)\r\ndev_info(&pdev->dev, "registered mtd device\n");\r\nif (pdata->nr_partitions) {\r\nerr = mtd_device_register(info->mtd, NULL, 0);\r\nif (err) {\r\ndev_err(&pdev->dev,\r\n"failed to register the entire device\n");\r\n}\r\n}\r\nreturn err;\r\nexit_free:\r\nplatram_remove(pdev);\r\nexit_error:\r\nreturn err;\r\n}
