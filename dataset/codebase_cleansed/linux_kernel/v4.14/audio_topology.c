static struct gbaudio_module_info *find_gb_module(\r\nstruct gbaudio_codec_info *codec,\r\nchar const *name)\r\n{\r\nint dev_id, ret;\r\nchar begin[NAME_SIZE];\r\nstruct gbaudio_module_info *module;\r\nif (!name)\r\nreturn NULL;\r\nret = sscanf(name, "%s %d", begin, &dev_id);\r\ndev_dbg(codec->dev, "%s:Find module#%d\n", __func__, dev_id);\r\nmutex_lock(&codec->lock);\r\nlist_for_each_entry(module, &codec->module_list, list) {\r\nif (module->dev_id == dev_id) {\r\nmutex_unlock(&codec->lock);\r\nreturn module;\r\n}\r\n}\r\nmutex_unlock(&codec->lock);\r\ndev_warn(codec->dev, "%s: module#%d missing in codec list\n", name,\r\ndev_id);\r\nreturn NULL;\r\n}\r\nstatic const char *gbaudio_map_controlid(struct gbaudio_module_info *module,\r\n__u8 control_id, __u8 index)\r\n{\r\nstruct gbaudio_control *control;\r\nif (control_id == GBAUDIO_INVALID_ID)\r\nreturn NULL;\r\nlist_for_each_entry(control, &module->ctl_list, list) {\r\nif (control->id == control_id) {\r\nif (index == GBAUDIO_INVALID_ID)\r\nreturn control->name;\r\nif (index >= control->items)\r\nreturn NULL;\r\nreturn control->texts[index];\r\n}\r\n}\r\nlist_for_each_entry(control, &module->widget_ctl_list, list) {\r\nif (control->id == control_id) {\r\nif (index == GBAUDIO_INVALID_ID)\r\nreturn control->name;\r\nif (index >= control->items)\r\nreturn NULL;\r\nreturn control->texts[index];\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic int gbaudio_map_controlname(struct gbaudio_module_info *module,\r\nconst char *name)\r\n{\r\nstruct gbaudio_control *control;\r\nlist_for_each_entry(control, &module->ctl_list, list) {\r\nif (!strncmp(control->name, name, NAME_SIZE))\r\nreturn control->id;\r\n}\r\ndev_warn(module->dev, "%s: missing in modules controls list\n", name);\r\nreturn -EINVAL;\r\n}\r\nstatic int gbaudio_map_wcontrolname(struct gbaudio_module_info *module,\r\nconst char *name)\r\n{\r\nstruct gbaudio_control *control;\r\nlist_for_each_entry(control, &module->widget_ctl_list, list) {\r\nif (!strncmp(control->wname, name, NAME_SIZE))\r\nreturn control->id;\r\n}\r\ndev_warn(module->dev, "%s: missing in modules controls list\n", name);\r\nreturn -EINVAL;\r\n}\r\nstatic int gbaudio_map_widgetname(struct gbaudio_module_info *module,\r\nconst char *name)\r\n{\r\nstruct gbaudio_widget *widget;\r\nlist_for_each_entry(widget, &module->widget_list, list) {\r\nif (!strncmp(widget->name, name, NAME_SIZE))\r\nreturn widget->id;\r\n}\r\ndev_warn(module->dev, "%s: missing in modules widgets list\n", name);\r\nreturn -EINVAL;\r\n}\r\nstatic const char *gbaudio_map_widgetid(struct gbaudio_module_info *module,\r\n__u8 widget_id)\r\n{\r\nstruct gbaudio_widget *widget;\r\nlist_for_each_entry(widget, &module->widget_list, list) {\r\nif (widget->id == widget_id)\r\nreturn widget->name;\r\n}\r\nreturn NULL;\r\n}\r\nstatic const char **gb_generate_enum_strings(struct gbaudio_module_info *gb,\r\nstruct gb_audio_enumerated *gbenum)\r\n{\r\nconst char **strings;\r\nint i;\r\nunsigned int items;\r\n__u8 *data;\r\nitems = le32_to_cpu(gbenum->items);\r\nstrings = devm_kzalloc(gb->dev, sizeof(char *) * items, GFP_KERNEL);\r\ndata = gbenum->names;\r\nfor (i = 0; i < items; i++) {\r\nstrings[i] = (const char *)data;\r\nwhile (*data != '\0')\r\ndata++;\r\ndata++;\r\n}\r\nreturn strings;\r\n}\r\nstatic int gbcodec_mixer_ctl_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nunsigned int max;\r\nconst char *name;\r\nstruct gbaudio_ctl_pvt *data;\r\nstruct gb_audio_ctl_elem_info *info;\r\nstruct gbaudio_module_info *module;\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct gbaudio_codec_info *gbcodec = snd_soc_codec_get_drvdata(codec);\r\ndev_dbg(codec->dev, "Entered %s:%s\n", __func__, kcontrol->id.name);\r\ndata = (struct gbaudio_ctl_pvt *)kcontrol->private_value;\r\ninfo = (struct gb_audio_ctl_elem_info *)data->info;\r\nif (!info) {\r\ndev_err(codec->dev, "NULL info for %s\n", uinfo->id.name);\r\nreturn -EINVAL;\r\n}\r\nuinfo->access = data->access;\r\nuinfo->count = data->vcount;\r\nuinfo->type = (snd_ctl_elem_type_t)info->type;\r\nswitch (info->type) {\r\ncase GB_AUDIO_CTL_ELEM_TYPE_BOOLEAN:\r\ncase GB_AUDIO_CTL_ELEM_TYPE_INTEGER:\r\nuinfo->value.integer.min = le32_to_cpu(info->value.integer.min);\r\nuinfo->value.integer.max = le32_to_cpu(info->value.integer.max);\r\nbreak;\r\ncase GB_AUDIO_CTL_ELEM_TYPE_ENUMERATED:\r\nmax = le32_to_cpu(info->value.enumerated.items);\r\nuinfo->value.enumerated.items = max;\r\nif (uinfo->value.enumerated.item > max - 1)\r\nuinfo->value.enumerated.item = max - 1;\r\nmodule = find_gb_module(gbcodec, kcontrol->id.name);\r\nif (!module)\r\nreturn -EINVAL;\r\nname = gbaudio_map_controlid(module, data->ctl_id,\r\nuinfo->value.enumerated.item);\r\nstrlcpy(uinfo->value.enumerated.name, name, NAME_SIZE);\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Invalid type: %d for %s:kcontrol\n",\r\ninfo->type, kcontrol->id.name);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int gbcodec_mixer_ctl_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nint ret;\r\nstruct gb_audio_ctl_elem_info *info;\r\nstruct gbaudio_ctl_pvt *data;\r\nstruct gb_audio_ctl_elem_value gbvalue;\r\nstruct gbaudio_module_info *module;\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct gbaudio_codec_info *gb = snd_soc_codec_get_drvdata(codec);\r\nstruct gb_bundle *bundle;\r\ndev_dbg(codec->dev, "Entered %s:%s\n", __func__, kcontrol->id.name);\r\nmodule = find_gb_module(gb, kcontrol->id.name);\r\nif (!module)\r\nreturn -EINVAL;\r\ndata = (struct gbaudio_ctl_pvt *)kcontrol->private_value;\r\ninfo = (struct gb_audio_ctl_elem_info *)data->info;\r\nbundle = to_gb_bundle(module->dev);\r\nret = gb_pm_runtime_get_sync(bundle);\r\nif (ret)\r\nreturn ret;\r\nret = gb_audio_gb_get_control(module->mgmt_connection, data->ctl_id,\r\nGB_AUDIO_INVALID_INDEX, &gbvalue);\r\ngb_pm_runtime_put_autosuspend(bundle);\r\nif (ret) {\r\ndev_err_ratelimited(codec->dev, "%d:Error in %s for %s\n", ret,\r\n__func__, kcontrol->id.name);\r\nreturn ret;\r\n}\r\nswitch (info->type) {\r\ncase GB_AUDIO_CTL_ELEM_TYPE_BOOLEAN:\r\ncase GB_AUDIO_CTL_ELEM_TYPE_INTEGER:\r\nucontrol->value.integer.value[0] =\r\nle32_to_cpu(gbvalue.value.integer_value[0]);\r\nif (data->vcount == 2)\r\nucontrol->value.integer.value[1] =\r\nle32_to_cpu(gbvalue.value.integer_value[1]);\r\nbreak;\r\ncase GB_AUDIO_CTL_ELEM_TYPE_ENUMERATED:\r\nucontrol->value.enumerated.item[0] =\r\nle32_to_cpu(gbvalue.value.enumerated_item[0]);\r\nif (data->vcount == 2)\r\nucontrol->value.enumerated.item[1] =\r\nle32_to_cpu(gbvalue.value.enumerated_item[1]);\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Invalid type: %d for %s:kcontrol\n",\r\ninfo->type, kcontrol->id.name);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int gbcodec_mixer_ctl_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nint ret = 0;\r\nstruct gb_audio_ctl_elem_info *info;\r\nstruct gbaudio_ctl_pvt *data;\r\nstruct gb_audio_ctl_elem_value gbvalue;\r\nstruct gbaudio_module_info *module;\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct gbaudio_codec_info *gb = snd_soc_codec_get_drvdata(codec);\r\nstruct gb_bundle *bundle;\r\ndev_dbg(codec->dev, "Entered %s:%s\n", __func__, kcontrol->id.name);\r\nmodule = find_gb_module(gb, kcontrol->id.name);\r\nif (!module)\r\nreturn -EINVAL;\r\ndata = (struct gbaudio_ctl_pvt *)kcontrol->private_value;\r\ninfo = (struct gb_audio_ctl_elem_info *)data->info;\r\nbundle = to_gb_bundle(module->dev);\r\nswitch (info->type) {\r\ncase GB_AUDIO_CTL_ELEM_TYPE_BOOLEAN:\r\ncase GB_AUDIO_CTL_ELEM_TYPE_INTEGER:\r\ngbvalue.value.integer_value[0] =\r\ncpu_to_le32(ucontrol->value.integer.value[0]);\r\nif (data->vcount == 2)\r\ngbvalue.value.integer_value[1] =\r\ncpu_to_le32(ucontrol->value.integer.value[1]);\r\nbreak;\r\ncase GB_AUDIO_CTL_ELEM_TYPE_ENUMERATED:\r\ngbvalue.value.enumerated_item[0] =\r\ncpu_to_le32(ucontrol->value.enumerated.item[0]);\r\nif (data->vcount == 2)\r\ngbvalue.value.enumerated_item[1] =\r\ncpu_to_le32(ucontrol->value.enumerated.item[1]);\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Invalid type: %d for %s:kcontrol\n",\r\ninfo->type, kcontrol->id.name);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (ret)\r\nreturn ret;\r\nret = gb_pm_runtime_get_sync(bundle);\r\nif (ret)\r\nreturn ret;\r\nret = gb_audio_gb_set_control(module->mgmt_connection, data->ctl_id,\r\nGB_AUDIO_INVALID_INDEX, &gbvalue);\r\ngb_pm_runtime_put_autosuspend(bundle);\r\nif (ret) {\r\ndev_err_ratelimited(codec->dev, "%d:Error in %s for %s\n", ret,\r\n__func__, kcontrol->id.name);\r\n}\r\nreturn ret;\r\n}\r\nstatic int gbcodec_mixer_dapm_ctl_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nint platform_max, platform_min;\r\nstruct gbaudio_ctl_pvt *data;\r\nstruct gb_audio_ctl_elem_info *info;\r\nstruct snd_soc_dapm_widget_list *wlist = snd_kcontrol_chip(kcontrol);\r\nstruct snd_soc_dapm_widget *widget = wlist->widgets[0];\r\nstruct snd_soc_codec *codec = widget->codec;\r\ndev_dbg(codec->dev, "Entered %s:%s\n", __func__, kcontrol->id.name);\r\ndata = (struct gbaudio_ctl_pvt *)kcontrol->private_value;\r\ninfo = (struct gb_audio_ctl_elem_info *)data->info;\r\nplatform_max = le32_to_cpu(info->value.integer.max);\r\nplatform_min = le32_to_cpu(info->value.integer.min);\r\nif (platform_max == 1 &&\r\n!strnstr(kcontrol->id.name, " Volume", NAME_SIZE))\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\r\nelse\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = data->vcount;\r\nuinfo->value.integer.min = platform_min;\r\nuinfo->value.integer.max = platform_max;\r\nreturn 0;\r\n}\r\nstatic int gbcodec_mixer_dapm_ctl_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nint ret;\r\nstruct gb_audio_ctl_elem_info *info;\r\nstruct gbaudio_ctl_pvt *data;\r\nstruct gb_audio_ctl_elem_value gbvalue;\r\nstruct gbaudio_module_info *module;\r\nstruct snd_soc_dapm_widget_list *wlist = snd_kcontrol_chip(kcontrol);\r\nstruct snd_soc_dapm_widget *widget = wlist->widgets[0];\r\nstruct snd_soc_codec *codec = widget->codec;\r\nstruct gbaudio_codec_info *gb = snd_soc_codec_get_drvdata(codec);\r\nstruct gb_bundle *bundle;\r\ndev_dbg(codec->dev, "Entered %s:%s\n", __func__, kcontrol->id.name);\r\nmodule = find_gb_module(gb, kcontrol->id.name);\r\nif (!module)\r\nreturn -EINVAL;\r\ndata = (struct gbaudio_ctl_pvt *)kcontrol->private_value;\r\ninfo = (struct gb_audio_ctl_elem_info *)data->info;\r\nbundle = to_gb_bundle(module->dev);\r\nif (data->vcount == 2)\r\ndev_warn(widget->dapm->dev,\r\n"GB: Control '%s' is stereo, which is not supported\n",\r\nkcontrol->id.name);\r\nret = gb_pm_runtime_get_sync(bundle);\r\nif (ret)\r\nreturn ret;\r\nret = gb_audio_gb_get_control(module->mgmt_connection, data->ctl_id,\r\nGB_AUDIO_INVALID_INDEX, &gbvalue);\r\ngb_pm_runtime_put_autosuspend(bundle);\r\nif (ret) {\r\ndev_err_ratelimited(codec->dev, "%d:Error in %s for %s\n", ret,\r\n__func__, kcontrol->id.name);\r\nreturn ret;\r\n}\r\nucontrol->value.integer.value[0] =\r\nle32_to_cpu(gbvalue.value.integer_value[0]);\r\nreturn ret;\r\n}\r\nstatic int gbcodec_mixer_dapm_ctl_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nint ret, wi, max, connect;\r\nunsigned int mask, val;\r\nstruct gb_audio_ctl_elem_info *info;\r\nstruct gbaudio_ctl_pvt *data;\r\nstruct gb_audio_ctl_elem_value gbvalue;\r\nstruct gbaudio_module_info *module;\r\nstruct snd_soc_dapm_widget_list *wlist = snd_kcontrol_chip(kcontrol);\r\nstruct snd_soc_dapm_widget *widget = wlist->widgets[0];\r\nstruct snd_soc_codec *codec = widget->codec;\r\nstruct gbaudio_codec_info *gb = snd_soc_codec_get_drvdata(codec);\r\nstruct gb_bundle *bundle;\r\ndev_dbg(codec->dev, "Entered %s:%s\n", __func__, kcontrol->id.name);\r\nmodule = find_gb_module(gb, kcontrol->id.name);\r\nif (!module)\r\nreturn -EINVAL;\r\ndata = (struct gbaudio_ctl_pvt *)kcontrol->private_value;\r\ninfo = (struct gb_audio_ctl_elem_info *)data->info;\r\nbundle = to_gb_bundle(module->dev);\r\nif (data->vcount == 2)\r\ndev_warn(widget->dapm->dev,\r\n"GB: Control '%s' is stereo, which is not supported\n",\r\nkcontrol->id.name);\r\nmax = le32_to_cpu(info->value.integer.max);\r\nmask = (1 << fls(max)) - 1;\r\nval = ucontrol->value.integer.value[0] & mask;\r\nconnect = !!val;\r\nif (gbvalue.value.integer_value[0] != val) {\r\nfor (wi = 0; wi < wlist->num_widgets; wi++) {\r\nwidget = wlist->widgets[wi];\r\nwidget->value = val;\r\nwidget->dapm->update = NULL;\r\nsnd_soc_dapm_mixer_update_power(widget, kcontrol,\r\nconnect);\r\n}\r\ngbvalue.value.integer_value[0] =\r\ncpu_to_le32(ucontrol->value.integer.value[0]);\r\nret = gb_pm_runtime_get_sync(bundle);\r\nif (ret)\r\nreturn ret;\r\nret = gb_audio_gb_set_control(module->mgmt_connection,\r\ndata->ctl_id,\r\nGB_AUDIO_INVALID_INDEX, &gbvalue);\r\ngb_pm_runtime_put_autosuspend(bundle);\r\nif (ret) {\r\ndev_err_ratelimited(codec->dev,\r\n"%d:Error in %s for %s\n", ret,\r\n__func__, kcontrol->id.name);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int gbcodec_event_spk(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *k, int event)\r\n{\r\nreturn 0;\r\n}\r\nstatic int gbcodec_event_hp(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *k, int event)\r\n{\r\nreturn 0;\r\n}\r\nstatic int gbcodec_event_int_mic(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *k, int event)\r\n{\r\nreturn 0;\r\n}\r\nstatic int gbaudio_validate_kcontrol_count(struct gb_audio_widget *w)\r\n{\r\nint ret = 0;\r\nswitch (w->type) {\r\ncase snd_soc_dapm_spk:\r\ncase snd_soc_dapm_hp:\r\ncase snd_soc_dapm_mic:\r\ncase snd_soc_dapm_output:\r\ncase snd_soc_dapm_input:\r\nif (w->ncontrols)\r\nret = -EINVAL;\r\nbreak;\r\ncase snd_soc_dapm_switch:\r\ncase snd_soc_dapm_mux:\r\nif (w->ncontrols != 1)\r\nret = -EINVAL;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int gbcodec_enum_ctl_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nint ret, ctl_id;\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\r\nstruct gb_audio_ctl_elem_value gbvalue;\r\nstruct gbaudio_module_info *module;\r\nstruct gbaudio_codec_info *gb = snd_soc_codec_get_drvdata(codec);\r\nstruct gb_bundle *bundle;\r\nmodule = find_gb_module(gb, kcontrol->id.name);\r\nif (!module)\r\nreturn -EINVAL;\r\nctl_id = gbaudio_map_controlname(module, kcontrol->id.name);\r\nif (ctl_id < 0)\r\nreturn -EINVAL;\r\nbundle = to_gb_bundle(module->dev);\r\nret = gb_pm_runtime_get_sync(bundle);\r\nif (ret)\r\nreturn ret;\r\nret = gb_audio_gb_get_control(module->mgmt_connection, ctl_id,\r\nGB_AUDIO_INVALID_INDEX, &gbvalue);\r\ngb_pm_runtime_put_autosuspend(bundle);\r\nif (ret) {\r\ndev_err_ratelimited(codec->dev, "%d:Error in %s for %s\n", ret,\r\n__func__, kcontrol->id.name);\r\nreturn ret;\r\n}\r\nucontrol->value.enumerated.item[0] =\r\nle32_to_cpu(gbvalue.value.enumerated_item[0]);\r\nif (e->shift_l != e->shift_r)\r\nucontrol->value.enumerated.item[1] =\r\nle32_to_cpu(gbvalue.value.enumerated_item[1]);\r\nreturn 0;\r\n}\r\nstatic int gbcodec_enum_ctl_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nint ret, ctl_id;\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\r\nstruct gb_audio_ctl_elem_value gbvalue;\r\nstruct gbaudio_module_info *module;\r\nstruct gbaudio_codec_info *gb = snd_soc_codec_get_drvdata(codec);\r\nstruct gb_bundle *bundle;\r\nmodule = find_gb_module(gb, kcontrol->id.name);\r\nif (!module)\r\nreturn -EINVAL;\r\nctl_id = gbaudio_map_controlname(module, kcontrol->id.name);\r\nif (ctl_id < 0)\r\nreturn -EINVAL;\r\nif (ucontrol->value.enumerated.item[0] > e->max - 1)\r\nreturn -EINVAL;\r\ngbvalue.value.enumerated_item[0] =\r\ncpu_to_le32(ucontrol->value.enumerated.item[0]);\r\nif (e->shift_l != e->shift_r) {\r\nif (ucontrol->value.enumerated.item[1] > e->max - 1)\r\nreturn -EINVAL;\r\ngbvalue.value.enumerated_item[1] =\r\ncpu_to_le32(ucontrol->value.enumerated.item[1]);\r\n}\r\nbundle = to_gb_bundle(module->dev);\r\nret = gb_pm_runtime_get_sync(bundle);\r\nif (ret)\r\nreturn ret;\r\nret = gb_audio_gb_set_control(module->mgmt_connection, ctl_id,\r\nGB_AUDIO_INVALID_INDEX, &gbvalue);\r\ngb_pm_runtime_put_autosuspend(bundle);\r\nif (ret) {\r\ndev_err_ratelimited(codec->dev, "%d:Error in %s for %s\n", ret,\r\n__func__, kcontrol->id.name);\r\n}\r\nreturn ret;\r\n}\r\nstatic int gbaudio_tplg_create_enum_kctl(struct gbaudio_module_info *gb,\r\nstruct snd_kcontrol_new *kctl,\r\nstruct gb_audio_control *ctl)\r\n{\r\nstruct soc_enum *gbe;\r\nstruct gb_audio_enumerated *gb_enum;\r\nint i;\r\ngbe = devm_kzalloc(gb->dev, sizeof(*gbe), GFP_KERNEL);\r\nif (!gbe)\r\nreturn -ENOMEM;\r\ngb_enum = &ctl->info.value.enumerated;\r\ngbe->max = le32_to_cpu(gb_enum->items);\r\ngbe->texts = gb_generate_enum_strings(gb, gb_enum);\r\ndev_dbg(gb->dev, "Max:%d, name_length:%d\n", gbe->max,\r\nle16_to_cpu(gb_enum->names_length));\r\nfor (i = 0; i < gbe->max; i++)\r\ndev_dbg(gb->dev, "src[%d]: %s\n", i, gbe->texts[i]);\r\n*kctl = (struct snd_kcontrol_new)\r\nSOC_ENUM_EXT(ctl->name, *gbe, gbcodec_enum_ctl_get,\r\ngbcodec_enum_ctl_put);\r\nreturn 0;\r\n}\r\nstatic int gbaudio_tplg_create_kcontrol(struct gbaudio_module_info *gb,\r\nstruct snd_kcontrol_new *kctl,\r\nstruct gb_audio_control *ctl)\r\n{\r\nint ret = 0;\r\nstruct gbaudio_ctl_pvt *ctldata;\r\nswitch (ctl->iface) {\r\ncase SNDRV_CTL_ELEM_IFACE_MIXER:\r\nswitch (ctl->info.type) {\r\ncase GB_AUDIO_CTL_ELEM_TYPE_ENUMERATED:\r\nret = gbaudio_tplg_create_enum_kctl(gb, kctl, ctl);\r\nbreak;\r\ndefault:\r\nctldata = devm_kzalloc(gb->dev,\r\nsizeof(struct gbaudio_ctl_pvt),\r\nGFP_KERNEL);\r\nif (!ctldata)\r\nreturn -ENOMEM;\r\nctldata->ctl_id = ctl->id;\r\nctldata->data_cport = le16_to_cpu(ctl->data_cport);\r\nctldata->access = ctl->access;\r\nctldata->vcount = ctl->count_values;\r\nctldata->info = &ctl->info;\r\n*kctl = (struct snd_kcontrol_new)\r\nSOC_MIXER_GB(ctl->name, ctl->count, ctldata);\r\nctldata = NULL;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(gb->dev, "%s:%d control created\n", ctl->name, ctl->id);\r\nreturn ret;\r\n}\r\nstatic int gbcodec_enum_dapm_ctl_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nint ret, ctl_id;\r\nstruct snd_soc_dapm_widget_list *wlist = snd_kcontrol_chip(kcontrol);\r\nstruct snd_soc_dapm_widget *widget = wlist->widgets[0];\r\nstruct gbaudio_module_info *module;\r\nstruct gb_audio_ctl_elem_value gbvalue;\r\nstruct snd_soc_codec *codec = widget->codec;\r\nstruct gbaudio_codec_info *gb = snd_soc_codec_get_drvdata(codec);\r\nstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\r\nstruct gb_bundle *bundle;\r\nmodule = find_gb_module(gb, kcontrol->id.name);\r\nif (!module)\r\nreturn -EINVAL;\r\nctl_id = gbaudio_map_wcontrolname(module, kcontrol->id.name);\r\nif (ctl_id < 0)\r\nreturn -EINVAL;\r\nbundle = to_gb_bundle(module->dev);\r\nret = gb_pm_runtime_get_sync(bundle);\r\nif (ret)\r\nreturn ret;\r\nret = gb_audio_gb_get_control(module->mgmt_connection, ctl_id,\r\nGB_AUDIO_INVALID_INDEX, &gbvalue);\r\ngb_pm_runtime_put_autosuspend(bundle);\r\nif (ret) {\r\ndev_err_ratelimited(codec->dev, "%d:Error in %s for %s\n", ret,\r\n__func__, kcontrol->id.name);\r\nreturn ret;\r\n}\r\nucontrol->value.enumerated.item[0] = gbvalue.value.enumerated_item[0];\r\nif (e->shift_l != e->shift_r)\r\nucontrol->value.enumerated.item[1] =\r\ngbvalue.value.enumerated_item[1];\r\nreturn 0;\r\n}\r\nstatic int gbcodec_enum_dapm_ctl_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nint ret, wi, ctl_id;\r\nunsigned int val, mux, change;\r\nunsigned int mask;\r\nstruct snd_soc_dapm_widget_list *wlist = snd_kcontrol_chip(kcontrol);\r\nstruct snd_soc_dapm_widget *widget = wlist->widgets[0];\r\nstruct gb_audio_ctl_elem_value gbvalue;\r\nstruct gbaudio_module_info *module;\r\nstruct snd_soc_codec *codec = widget->codec;\r\nstruct gbaudio_codec_info *gb = snd_soc_codec_get_drvdata(codec);\r\nstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\r\nstruct gb_bundle *bundle;\r\nif (ucontrol->value.enumerated.item[0] > e->max - 1)\r\nreturn -EINVAL;\r\nmodule = find_gb_module(gb, kcontrol->id.name);\r\nif (!module)\r\nreturn -EINVAL;\r\nctl_id = gbaudio_map_wcontrolname(module, kcontrol->id.name);\r\nif (ctl_id < 0)\r\nreturn -EINVAL;\r\nchange = 0;\r\nbundle = to_gb_bundle(module->dev);\r\nret = gb_pm_runtime_get_sync(bundle);\r\nif (ret)\r\nreturn ret;\r\nret = gb_audio_gb_get_control(module->mgmt_connection, ctl_id,\r\nGB_AUDIO_INVALID_INDEX, &gbvalue);\r\ngb_pm_runtime_put_autosuspend(bundle);\r\nif (ret) {\r\ndev_err_ratelimited(codec->dev, "%d:Error in %s for %s\n", ret,\r\n__func__, kcontrol->id.name);\r\nreturn ret;\r\n}\r\nmux = ucontrol->value.enumerated.item[0];\r\nval = mux << e->shift_l;\r\nmask = e->mask << e->shift_l;\r\nif (gbvalue.value.enumerated_item[0] !=\r\nucontrol->value.enumerated.item[0]) {\r\nchange = 1;\r\ngbvalue.value.enumerated_item[0] =\r\nucontrol->value.enumerated.item[0];\r\n}\r\nif (e->shift_l != e->shift_r) {\r\nif (ucontrol->value.enumerated.item[1] > e->max - 1)\r\nreturn -EINVAL;\r\nval |= ucontrol->value.enumerated.item[1] << e->shift_r;\r\nmask |= e->mask << e->shift_r;\r\nif (gbvalue.value.enumerated_item[1] !=\r\nucontrol->value.enumerated.item[1]) {\r\nchange = 1;\r\ngbvalue.value.enumerated_item[1] =\r\nucontrol->value.enumerated.item[1];\r\n}\r\n}\r\nif (change) {\r\nret = gb_pm_runtime_get_sync(bundle);\r\nif (ret)\r\nreturn ret;\r\nret = gb_audio_gb_set_control(module->mgmt_connection, ctl_id,\r\nGB_AUDIO_INVALID_INDEX, &gbvalue);\r\ngb_pm_runtime_put_autosuspend(bundle);\r\nif (ret) {\r\ndev_err_ratelimited(codec->dev,\r\n"%d:Error in %s for %s\n", ret,\r\n__func__, kcontrol->id.name);\r\n}\r\nfor (wi = 0; wi < wlist->num_widgets; wi++) {\r\nwidget = wlist->widgets[wi];\r\nwidget->value = val;\r\nwidget->dapm->update = NULL;\r\nsnd_soc_dapm_mux_update_power(widget, kcontrol, mux, e);\r\n}\r\n}\r\nreturn change;\r\n}\r\nstatic int gbaudio_tplg_create_enum_ctl(struct gbaudio_module_info *gb,\r\nstruct snd_kcontrol_new *kctl,\r\nstruct gb_audio_control *ctl)\r\n{\r\nstruct soc_enum *gbe;\r\nstruct gb_audio_enumerated *gb_enum;\r\nint i;\r\ngbe = devm_kzalloc(gb->dev, sizeof(*gbe), GFP_KERNEL);\r\nif (!gbe)\r\nreturn -ENOMEM;\r\ngb_enum = &ctl->info.value.enumerated;\r\ngbe->max = le32_to_cpu(gb_enum->items);\r\ngbe->texts = gb_generate_enum_strings(gb, gb_enum);\r\ndev_dbg(gb->dev, "Max:%d, name_length:%d\n", gbe->max,\r\nle16_to_cpu(gb_enum->names_length));\r\nfor (i = 0; i < gbe->max; i++)\r\ndev_dbg(gb->dev, "src[%d]: %s\n", i, gbe->texts[i]);\r\n*kctl = (struct snd_kcontrol_new)\r\nSOC_DAPM_ENUM_EXT(ctl->name, *gbe, gbcodec_enum_dapm_ctl_get,\r\ngbcodec_enum_dapm_ctl_put);\r\nreturn 0;\r\n}\r\nstatic int gbaudio_tplg_create_mixer_ctl(struct gbaudio_module_info *gb,\r\nstruct snd_kcontrol_new *kctl,\r\nstruct gb_audio_control *ctl)\r\n{\r\nstruct gbaudio_ctl_pvt *ctldata;\r\nctldata = devm_kzalloc(gb->dev, sizeof(struct gbaudio_ctl_pvt),\r\nGFP_KERNEL);\r\nif (!ctldata)\r\nreturn -ENOMEM;\r\nctldata->ctl_id = ctl->id;\r\nctldata->data_cport = le16_to_cpu(ctl->data_cport);\r\nctldata->access = ctl->access;\r\nctldata->vcount = ctl->count_values;\r\nctldata->info = &ctl->info;\r\n*kctl = (struct snd_kcontrol_new)\r\nSOC_DAPM_MIXER_GB(ctl->name, ctl->count, ctldata);\r\nreturn 0;\r\n}\r\nstatic int gbaudio_tplg_create_wcontrol(struct gbaudio_module_info *gb,\r\nstruct snd_kcontrol_new *kctl,\r\nstruct gb_audio_control *ctl)\r\n{\r\nint ret;\r\nswitch (ctl->iface) {\r\ncase SNDRV_CTL_ELEM_IFACE_MIXER:\r\nswitch (ctl->info.type) {\r\ncase GB_AUDIO_CTL_ELEM_TYPE_ENUMERATED:\r\nret = gbaudio_tplg_create_enum_ctl(gb, kctl, ctl);\r\nbreak;\r\ndefault:\r\nret = gbaudio_tplg_create_mixer_ctl(gb, kctl, ctl);\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(gb->dev, "%s:%d DAPM control created, ret:%d\n", ctl->name,\r\nctl->id, ret);\r\nreturn ret;\r\n}\r\nstatic int gbaudio_widget_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nint wid;\r\nint ret;\r\nstruct snd_soc_codec *codec = w->codec;\r\nstruct gbaudio_codec_info *gbcodec = snd_soc_codec_get_drvdata(codec);\r\nstruct gbaudio_module_info *module;\r\nstruct gb_bundle *bundle;\r\ndev_dbg(codec->dev, "%s %s %d\n", __func__, w->name, event);\r\nmodule = find_gb_module(gbcodec, w->name);\r\nif (!module)\r\nreturn -EINVAL;\r\nwid = gbaudio_map_widgetname(module, w->name);\r\nif (wid < 0) {\r\ndev_err(codec->dev, "Invalid widget name:%s\n", w->name);\r\nreturn -EINVAL;\r\n}\r\nbundle = to_gb_bundle(module->dev);\r\nret = gb_pm_runtime_get_sync(bundle);\r\nif (ret)\r\nreturn ret;\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nret = gb_audio_gb_enable_widget(module->mgmt_connection, wid);\r\nif (!ret)\r\nret = gbaudio_module_update(gbcodec, w, module, 1);\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nret = gb_audio_gb_disable_widget(module->mgmt_connection, wid);\r\nif (!ret)\r\nret = gbaudio_module_update(gbcodec, w, module, 0);\r\nbreak;\r\n}\r\nif (ret)\r\ndev_err_ratelimited(codec->dev,\r\n"%d: widget, event:%d failed:%d\n", wid,\r\nevent, ret);\r\ngb_pm_runtime_put_autosuspend(bundle);\r\nreturn ret;\r\n}\r\nstatic int gbaudio_tplg_create_widget(struct gbaudio_module_info *module,\r\nstruct snd_soc_dapm_widget *dw,\r\nstruct gb_audio_widget *w, int *w_size)\r\n{\r\nint i, ret, csize;\r\nstruct snd_kcontrol_new *widget_kctls;\r\nstruct gb_audio_control *curr;\r\nstruct gbaudio_control *control, *_control;\r\nsize_t size;\r\nchar temp_name[NAME_SIZE];\r\nret = gbaudio_validate_kcontrol_count(w);\r\nif (ret) {\r\ndev_err(module->dev, "Inavlid kcontrol count=%d for %s\n",\r\nw->ncontrols, w->name);\r\nreturn ret;\r\n}\r\nif (w->ncontrols) {\r\nsize = sizeof(struct snd_kcontrol_new) * w->ncontrols;\r\nwidget_kctls = devm_kzalloc(module->dev, size, GFP_KERNEL);\r\nif (!widget_kctls)\r\nreturn -ENOMEM;\r\n}\r\n*w_size = sizeof(struct gb_audio_widget);\r\ncurr = w->ctl;\r\nfor (i = 0; i < w->ncontrols; i++) {\r\nret = gbaudio_tplg_create_wcontrol(module, &widget_kctls[i],\r\ncurr);\r\nif (ret) {\r\ndev_err(module->dev,\r\n"%s:%d type widget_ctl not supported\n",\r\ncurr->name, curr->iface);\r\ngoto error;\r\n}\r\ncontrol = devm_kzalloc(module->dev,\r\nsizeof(struct gbaudio_control),\r\nGFP_KERNEL);\r\nif (!control) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\ncontrol->id = curr->id;\r\ncontrol->name = curr->name;\r\ncontrol->wname = w->name;\r\nif (curr->info.type == GB_AUDIO_CTL_ELEM_TYPE_ENUMERATED) {\r\nstruct gb_audio_enumerated *gbenum =\r\n&curr->info.value.enumerated;\r\ncsize = offsetof(struct gb_audio_control, info);\r\ncsize += offsetof(struct gb_audio_ctl_elem_info, value);\r\ncsize += offsetof(struct gb_audio_enumerated, names);\r\ncsize += le16_to_cpu(gbenum->names_length);\r\ncontrol->texts = (const char * const *)\r\ngb_generate_enum_strings(module, gbenum);\r\ncontrol->items = le32_to_cpu(gbenum->items);\r\n} else {\r\ncsize = sizeof(struct gb_audio_control);\r\n}\r\n*w_size += csize;\r\ncurr = (void *)curr + csize;\r\nlist_add(&control->list, &module->widget_ctl_list);\r\ndev_dbg(module->dev, "%s: control of type %d created\n",\r\nwidget_kctls[i].name, widget_kctls[i].iface);\r\n}\r\nstrlcpy(temp_name, w->name, NAME_SIZE);\r\nsnprintf(w->name, NAME_SIZE, "GB %d %s", module->dev_id, temp_name);\r\nswitch (w->type) {\r\ncase snd_soc_dapm_spk:\r\n*dw = (struct snd_soc_dapm_widget)\r\nSND_SOC_DAPM_SPK(w->name, gbcodec_event_spk);\r\nmodule->op_devices |= GBAUDIO_DEVICE_OUT_SPEAKER;\r\nbreak;\r\ncase snd_soc_dapm_hp:\r\n*dw = (struct snd_soc_dapm_widget)\r\nSND_SOC_DAPM_HP(w->name, gbcodec_event_hp);\r\nmodule->op_devices |= (GBAUDIO_DEVICE_OUT_WIRED_HEADSET\r\n| GBAUDIO_DEVICE_OUT_WIRED_HEADPHONE);\r\nmodule->ip_devices |= GBAUDIO_DEVICE_IN_WIRED_HEADSET;\r\nbreak;\r\ncase snd_soc_dapm_mic:\r\n*dw = (struct snd_soc_dapm_widget)\r\nSND_SOC_DAPM_MIC(w->name, gbcodec_event_int_mic);\r\nmodule->ip_devices |= GBAUDIO_DEVICE_IN_BUILTIN_MIC;\r\nbreak;\r\ncase snd_soc_dapm_output:\r\n*dw = (struct snd_soc_dapm_widget)SND_SOC_DAPM_OUTPUT(w->name);\r\nbreak;\r\ncase snd_soc_dapm_input:\r\n*dw = (struct snd_soc_dapm_widget)SND_SOC_DAPM_INPUT(w->name);\r\nbreak;\r\ncase snd_soc_dapm_switch:\r\n*dw = (struct snd_soc_dapm_widget)\r\nSND_SOC_DAPM_SWITCH_E(w->name, SND_SOC_NOPM, 0, 0,\r\nwidget_kctls, gbaudio_widget_event,\r\nSND_SOC_DAPM_PRE_PMU |\r\nSND_SOC_DAPM_POST_PMD);\r\nbreak;\r\ncase snd_soc_dapm_pga:\r\n*dw = (struct snd_soc_dapm_widget)\r\nSND_SOC_DAPM_PGA_E(w->name, SND_SOC_NOPM, 0, 0, NULL, 0,\r\ngbaudio_widget_event,\r\nSND_SOC_DAPM_PRE_PMU |\r\nSND_SOC_DAPM_POST_PMD);\r\nbreak;\r\ncase snd_soc_dapm_mixer:\r\n*dw = (struct snd_soc_dapm_widget)\r\nSND_SOC_DAPM_MIXER_E(w->name, SND_SOC_NOPM, 0, 0, NULL,\r\n0, gbaudio_widget_event,\r\nSND_SOC_DAPM_PRE_PMU |\r\nSND_SOC_DAPM_POST_PMD);\r\nbreak;\r\ncase snd_soc_dapm_mux:\r\n*dw = (struct snd_soc_dapm_widget)\r\nSND_SOC_DAPM_MUX_E(w->name, SND_SOC_NOPM, 0, 0,\r\nwidget_kctls, gbaudio_widget_event,\r\nSND_SOC_DAPM_PRE_PMU |\r\nSND_SOC_DAPM_POST_PMD);\r\nbreak;\r\ncase snd_soc_dapm_aif_in:\r\n*dw = (struct snd_soc_dapm_widget)\r\nSND_SOC_DAPM_AIF_IN_E(w->name, w->sname, 0,\r\nSND_SOC_NOPM,\r\n0, 0, gbaudio_widget_event,\r\nSND_SOC_DAPM_PRE_PMU |\r\nSND_SOC_DAPM_POST_PMD);\r\nbreak;\r\ncase snd_soc_dapm_aif_out:\r\n*dw = (struct snd_soc_dapm_widget)\r\nSND_SOC_DAPM_AIF_OUT_E(w->name, w->sname, 0,\r\nSND_SOC_NOPM,\r\n0, 0, gbaudio_widget_event,\r\nSND_SOC_DAPM_PRE_PMU |\r\nSND_SOC_DAPM_POST_PMD);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\ndev_dbg(module->dev, "%s: widget of type %d created\n", dw->name,\r\ndw->id);\r\nreturn 0;\r\nerror:\r\nlist_for_each_entry_safe(control, _control, &module->widget_ctl_list,\r\nlist) {\r\nlist_del(&control->list);\r\ndevm_kfree(module->dev, control);\r\n}\r\nreturn ret;\r\n}\r\nstatic int gbaudio_tplg_process_kcontrols(struct gbaudio_module_info *module,\r\nstruct gb_audio_control *controls)\r\n{\r\nint i, csize, ret;\r\nstruct snd_kcontrol_new *dapm_kctls;\r\nstruct gb_audio_control *curr;\r\nstruct gbaudio_control *control, *_control;\r\nsize_t size;\r\nchar temp_name[NAME_SIZE];\r\nsize = sizeof(struct snd_kcontrol_new) * module->num_controls;\r\ndapm_kctls = devm_kzalloc(module->dev, size, GFP_KERNEL);\r\nif (!dapm_kctls)\r\nreturn -ENOMEM;\r\ncurr = controls;\r\nfor (i = 0; i < module->num_controls; i++) {\r\nret = gbaudio_tplg_create_kcontrol(module, &dapm_kctls[i],\r\ncurr);\r\nif (ret) {\r\ndev_err(module->dev, "%s:%d type not supported\n",\r\ncurr->name, curr->iface);\r\ngoto error;\r\n}\r\ncontrol = devm_kzalloc(module->dev, sizeof(struct\r\ngbaudio_control),\r\nGFP_KERNEL);\r\nif (!control) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\ncontrol->id = curr->id;\r\nstrlcpy(temp_name, curr->name, NAME_SIZE);\r\nsnprintf(curr->name, NAME_SIZE, "GB %d %s", module->dev_id,\r\ntemp_name);\r\ncontrol->name = curr->name;\r\nif (curr->info.type == GB_AUDIO_CTL_ELEM_TYPE_ENUMERATED) {\r\nstruct gb_audio_enumerated *gbenum =\r\n&curr->info.value.enumerated;\r\ncsize = offsetof(struct gb_audio_control, info);\r\ncsize += offsetof(struct gb_audio_ctl_elem_info, value);\r\ncsize += offsetof(struct gb_audio_enumerated, names);\r\ncsize += le16_to_cpu(gbenum->names_length);\r\ncontrol->texts = (const char * const *)\r\ngb_generate_enum_strings(module, gbenum);\r\ncontrol->items = le32_to_cpu(gbenum->items);\r\n} else {\r\ncsize = sizeof(struct gb_audio_control);\r\n}\r\nlist_add(&control->list, &module->ctl_list);\r\ndev_dbg(module->dev, "%d:%s created of type %d\n", curr->id,\r\ncurr->name, curr->info.type);\r\ncurr = (void *)curr + csize;\r\n}\r\nmodule->controls = dapm_kctls;\r\nreturn 0;\r\nerror:\r\nlist_for_each_entry_safe(control, _control, &module->ctl_list,\r\nlist) {\r\nlist_del(&control->list);\r\ndevm_kfree(module->dev, control);\r\n}\r\ndevm_kfree(module->dev, dapm_kctls);\r\nreturn ret;\r\n}\r\nstatic int gbaudio_tplg_process_widgets(struct gbaudio_module_info *module,\r\nstruct gb_audio_widget *widgets)\r\n{\r\nint i, ret, w_size;\r\nstruct snd_soc_dapm_widget *dapm_widgets;\r\nstruct gb_audio_widget *curr;\r\nstruct gbaudio_widget *widget, *_widget;\r\nsize_t size;\r\nsize = sizeof(struct snd_soc_dapm_widget) * module->num_dapm_widgets;\r\ndapm_widgets = devm_kzalloc(module->dev, size, GFP_KERNEL);\r\nif (!dapm_widgets)\r\nreturn -ENOMEM;\r\ncurr = widgets;\r\nfor (i = 0; i < module->num_dapm_widgets; i++) {\r\nret = gbaudio_tplg_create_widget(module, &dapm_widgets[i],\r\ncurr, &w_size);\r\nif (ret) {\r\ndev_err(module->dev, "%s:%d type not supported\n",\r\ncurr->name, curr->type);\r\ngoto error;\r\n}\r\nwidget = devm_kzalloc(module->dev, sizeof(struct\r\ngbaudio_widget),\r\nGFP_KERNEL);\r\nif (!widget) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nwidget->id = curr->id;\r\nwidget->name = curr->name;\r\nlist_add(&widget->list, &module->widget_list);\r\ncurr = (void *)curr + w_size;\r\n}\r\nmodule->dapm_widgets = dapm_widgets;\r\nreturn 0;\r\nerror:\r\nlist_for_each_entry_safe(widget, _widget, &module->widget_list,\r\nlist) {\r\nlist_del(&widget->list);\r\ndevm_kfree(module->dev, widget);\r\n}\r\ndevm_kfree(module->dev, dapm_widgets);\r\nreturn ret;\r\n}\r\nstatic int gbaudio_tplg_process_routes(struct gbaudio_module_info *module,\r\nstruct gb_audio_route *routes)\r\n{\r\nint i, ret;\r\nstruct snd_soc_dapm_route *dapm_routes;\r\nstruct gb_audio_route *curr;\r\nsize_t size;\r\nsize = sizeof(struct snd_soc_dapm_route) * module->num_dapm_routes;\r\ndapm_routes = devm_kzalloc(module->dev, size, GFP_KERNEL);\r\nif (!dapm_routes)\r\nreturn -ENOMEM;\r\nmodule->dapm_routes = dapm_routes;\r\ncurr = routes;\r\nfor (i = 0; i < module->num_dapm_routes; i++) {\r\ndapm_routes->sink =\r\ngbaudio_map_widgetid(module, curr->destination_id);\r\nif (!dapm_routes->sink) {\r\ndev_err(module->dev, "%d:%d:%d:%d - Invalid sink\n",\r\ncurr->source_id, curr->destination_id,\r\ncurr->control_id, curr->index);\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\ndapm_routes->source =\r\ngbaudio_map_widgetid(module, curr->source_id);\r\nif (!dapm_routes->source) {\r\ndev_err(module->dev, "%d:%d:%d:%d - Invalid source\n",\r\ncurr->source_id, curr->destination_id,\r\ncurr->control_id, curr->index);\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\ndapm_routes->control =\r\ngbaudio_map_controlid(module,\r\ncurr->control_id,\r\ncurr->index);\r\nif ((curr->control_id != GBAUDIO_INVALID_ID) &&\r\n!dapm_routes->control) {\r\ndev_err(module->dev, "%d:%d:%d:%d - Invalid control\n",\r\ncurr->source_id, curr->destination_id,\r\ncurr->control_id, curr->index);\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\ndev_dbg(module->dev, "Route {%s, %s, %s}\n", dapm_routes->sink,\r\n(dapm_routes->control) ? dapm_routes->control : "NULL",\r\ndapm_routes->source);\r\ndapm_routes++;\r\ncurr++;\r\n}\r\nreturn 0;\r\nerror:\r\ndevm_kfree(module->dev, module->dapm_routes);\r\nreturn ret;\r\n}\r\nstatic int gbaudio_tplg_process_header(struct gbaudio_module_info *module,\r\nstruct gb_audio_topology *tplg_data)\r\n{\r\nmodule->num_controls = tplg_data->num_controls;\r\nmodule->num_dapm_widgets = tplg_data->num_widgets;\r\nmodule->num_dapm_routes = tplg_data->num_routes;\r\nmodule->dai_offset = (unsigned long)&tplg_data->data;\r\nmodule->control_offset = module->dai_offset +\r\nle32_to_cpu(tplg_data->size_dais);\r\nmodule->widget_offset = module->control_offset +\r\nle32_to_cpu(tplg_data->size_controls);\r\nmodule->route_offset = module->widget_offset +\r\nle32_to_cpu(tplg_data->size_widgets);\r\ndev_dbg(module->dev, "DAI offset is 0x%lx\n", module->dai_offset);\r\ndev_dbg(module->dev, "control offset is %lx\n",\r\nmodule->control_offset);\r\ndev_dbg(module->dev, "widget offset is %lx\n", module->widget_offset);\r\ndev_dbg(module->dev, "route offset is %lx\n", module->route_offset);\r\nreturn 0;\r\n}\r\nint gbaudio_tplg_parse_data(struct gbaudio_module_info *module,\r\nstruct gb_audio_topology *tplg_data)\r\n{\r\nint ret;\r\nstruct gb_audio_control *controls;\r\nstruct gb_audio_widget *widgets;\r\nstruct gb_audio_route *routes;\r\nunsigned int jack_type;\r\nif (!tplg_data)\r\nreturn -EINVAL;\r\nret = gbaudio_tplg_process_header(module, tplg_data);\r\nif (ret) {\r\ndev_err(module->dev, "%d: Error in parsing topology header\n",\r\nret);\r\nreturn ret;\r\n}\r\ncontrols = (struct gb_audio_control *)module->control_offset;\r\nret = gbaudio_tplg_process_kcontrols(module, controls);\r\nif (ret) {\r\ndev_err(module->dev,\r\n"%d: Error in parsing controls data\n", ret);\r\nreturn ret;\r\n}\r\ndev_dbg(module->dev, "Control parsing finished\n");\r\nwidgets = (struct gb_audio_widget *)module->widget_offset;\r\nret = gbaudio_tplg_process_widgets(module, widgets);\r\nif (ret) {\r\ndev_err(module->dev,\r\n"%d: Error in parsing widgets data\n", ret);\r\nreturn ret;\r\n}\r\ndev_dbg(module->dev, "Widget parsing finished\n");\r\nroutes = (struct gb_audio_route *)module->route_offset;\r\nret = gbaudio_tplg_process_routes(module, routes);\r\nif (ret) {\r\ndev_err(module->dev,\r\n"%d: Error in parsing routes data\n", ret);\r\nreturn ret;\r\n}\r\ndev_dbg(module->dev, "Route parsing finished\n");\r\njack_type = le32_to_cpu(tplg_data->jack_type);\r\nif (jack_type) {\r\nmodule->jack_mask = jack_type & GBCODEC_JACK_MASK;\r\nmodule->button_mask = jack_type & GBCODEC_JACK_BUTTON_MASK;\r\n}\r\nreturn ret;\r\n}\r\nvoid gbaudio_tplg_release(struct gbaudio_module_info *module)\r\n{\r\nstruct gbaudio_control *control, *_control;\r\nstruct gbaudio_widget *widget, *_widget;\r\nif (!module->topology)\r\nreturn;\r\nlist_for_each_entry_safe(control, _control, &module->ctl_list,\r\nlist) {\r\nlist_del(&control->list);\r\ndevm_kfree(module->dev, control);\r\n}\r\nif (module->controls)\r\ndevm_kfree(module->dev, module->controls);\r\nlist_for_each_entry_safe(control, _control, &module->widget_ctl_list,\r\nlist) {\r\nlist_del(&control->list);\r\ndevm_kfree(module->dev, control);\r\n}\r\nlist_for_each_entry_safe(widget, _widget, &module->widget_list,\r\nlist) {\r\nlist_del(&widget->list);\r\ndevm_kfree(module->dev, widget);\r\n}\r\nif (module->dapm_widgets)\r\ndevm_kfree(module->dev, module->dapm_widgets);\r\nif (module->dapm_routes)\r\ndevm_kfree(module->dev, module->dapm_routes);\r\n}
