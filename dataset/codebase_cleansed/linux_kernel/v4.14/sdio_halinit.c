static u8 CardEnable(struct adapter *padapter)\r\n{\r\nu8 bMacPwrCtrlOn;\r\nu8 ret = _FAIL;\r\nrtw_hal_get_hwreg(padapter, HW_VAR_APFM_ON_MAC, &bMacPwrCtrlOn);\r\nif (bMacPwrCtrlOn == false) {\r\nrtw_write8(padapter, REG_RSV_CTRL, 0x0);\r\nret = HalPwrSeqCmdParsing(padapter, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, rtl8723B_card_enable_flow);\r\nif (ret == _SUCCESS) {\r\nu8 bMacPwrCtrlOn = true;\r\nrtw_hal_set_hwreg(padapter, HW_VAR_APFM_ON_MAC, &bMacPwrCtrlOn);\r\n}\r\n} else\r\nret = _SUCCESS;\r\nreturn ret;\r\n}\r\nvoid HostWakeUpGpioClear(struct adapter *Adapter)\r\n{\r\nu32 value32;\r\nvalue32 = rtw_read32(Adapter, REG_GPIO_PIN_CTRL_2);\r\nvalue32 |= BIT(12);\r\nvalue32 |= BIT(20);\r\nrtw_write32(Adapter, REG_GPIO_PIN_CTRL_2, value32);\r\n}\r\nvoid HalSetOutPutGPIO(struct adapter *padapter, u8 index, u8 OutPutValue)\r\n{\r\nif (index <= 7) {\r\nrtw_write8(padapter, REG_GPIO_PIN_CTRL + 3, rtw_read8(padapter, REG_GPIO_PIN_CTRL + 3) & ~BIT(index));\r\nrtw_write8(padapter, REG_GPIO_PIN_CTRL + 2, rtw_read8(padapter, REG_GPIO_PIN_CTRL + 2) | BIT(index));\r\nif (OutPutValue)\r\nrtw_write8(padapter, REG_GPIO_PIN_CTRL + 1, rtw_read8(padapter, REG_GPIO_PIN_CTRL + 1) | BIT(index));\r\nelse\r\nrtw_write8(padapter, REG_GPIO_PIN_CTRL + 1, rtw_read8(padapter, REG_GPIO_PIN_CTRL + 1) & ~BIT(index));\r\n} else {\r\nindex -= 8;\r\nrtw_write8(padapter, REG_GPIO_PIN_CTRL_2 + 3, rtw_read8(padapter, REG_GPIO_PIN_CTRL_2 + 3) & ~BIT(index));\r\nrtw_write8(padapter, REG_GPIO_PIN_CTRL_2 + 2, rtw_read8(padapter, REG_GPIO_PIN_CTRL_2 + 2) | BIT(index));\r\nif (OutPutValue)\r\nrtw_write8(padapter, REG_GPIO_PIN_CTRL_2 + 1, rtw_read8(padapter, REG_GPIO_PIN_CTRL_2 + 1) | BIT(index));\r\nelse\r\nrtw_write8(padapter, REG_GPIO_PIN_CTRL_2 + 1, rtw_read8(padapter, REG_GPIO_PIN_CTRL_2 + 1) & ~BIT(index));\r\n}\r\n}\r\nstatic\r\nu8 _InitPowerOn_8723BS(struct adapter *padapter)\r\n{\r\nu8 value8;\r\nu16 value16;\r\nu32 value32;\r\nu8 ret;\r\n#ifdef CONFIG_EXT_CLK\r\nvalue8 = rtw_read8(padapter, REG_PAD_CTRL1_8723B+2);\r\nvalue8 |= BIT(7);\r\nrtw_write8(padapter, REG_PAD_CTRL1_8723B+2, value8);\r\nvalue8 = rtw_read8(padapter, REG_MULTI_FUNC_CTRL+1);\r\nvalue8 |= BIT(5);\r\nrtw_write8(padapter, REG_MULTI_FUNC_CTRL+1, value8);\r\n#endif\r\nret = CardEnable(padapter);\r\nif (ret == false) {\r\nRT_TRACE(\r\n_module_hci_hal_init_c_,\r\n_drv_emerg_,\r\n("%s: run power on flow fail\n", __func__)\r\n);\r\nreturn _FAIL;\r\n}\r\nvalue8 = rtw_read8(padapter, REG_GPIO_INTM+1);\r\nvalue8 |= BIT(1);\r\nrtw_write8(padapter, REG_GPIO_INTM+1, value8);\r\nvalue8 = rtw_read8(padapter, REG_GPIO_IO_SEL_2+1);\r\nvalue8 |= BIT(1);\r\nrtw_write8(padapter, REG_GPIO_IO_SEL_2+1, value8);\r\nvalue16 = rtw_read16(padapter, REG_APS_FSMCO);\r\nvalue16 |= EnPDN;\r\nrtw_write16(padapter, REG_APS_FSMCO, value16);\r\nrtw_write8(padapter, REG_CR, 0x00);\r\nvalue16 = rtw_read16(padapter, REG_CR);\r\nvalue16 |= (\r\nHCI_TXDMA_EN |\r\nHCI_RXDMA_EN |\r\nTXDMA_EN |\r\nRXDMA_EN |\r\nPROTOCOL_EN |\r\nSCHEDULE_EN |\r\nENSEC |\r\nCALTMR_EN\r\n);\r\nrtw_write16(padapter, REG_CR, value16);\r\nrtw_btcoex_PowerOnSetting(padapter);\r\nvalue16 = rtw_read16(padapter, REG_PWR_DATA);\r\nvalue16 |= BIT(11);\r\nrtw_write16(padapter, REG_PWR_DATA, value16);\r\nvalue32 = rtw_read32(padapter, REG_LEDCFG0);\r\nvalue32 |= BIT(23);\r\nrtw_write32(padapter, REG_LEDCFG0, value32);\r\nvalue8 = rtw_read8(padapter, REG_PAD_CTRL1_8723B);\r\nvalue8 &= ~BIT(0);\r\nrtw_write8(padapter, REG_PAD_CTRL1_8723B, value8);\r\n#ifdef CONFIG_GPIO_WAKEUP\r\nHostWakeUpGpioClear(padapter);\r\n#endif\r\nreturn _SUCCESS;\r\n}\r\nstatic void _init_available_page_threshold(struct adapter *padapter, u8 numHQ, u8 numNQ, u8 numLQ, u8 numPubQ)\r\n{\r\nu16 HQ_threshold, NQ_threshold, LQ_threshold;\r\nHQ_threshold = (numPubQ + numHQ + 1) >> 1;\r\nHQ_threshold |= (HQ_threshold<<8);\r\nNQ_threshold = (numPubQ + numNQ + 1) >> 1;\r\nNQ_threshold |= (NQ_threshold<<8);\r\nLQ_threshold = (numPubQ + numLQ + 1) >> 1;\r\nLQ_threshold |= (LQ_threshold<<8);\r\nrtw_write16(padapter, 0x218, HQ_threshold);\r\nrtw_write16(padapter, 0x21A, NQ_threshold);\r\nrtw_write16(padapter, 0x21C, LQ_threshold);\r\nDBG_8192C("%s(): Enable Tx FIFO Page Threshold H:0x%x, N:0x%x, L:0x%x\n", __func__, HQ_threshold, NQ_threshold, LQ_threshold);\r\n}\r\nstatic void _InitQueueReservedPage(struct adapter *padapter)\r\n{\r\nstruct hal_com_data *pHalData = GET_HAL_DATA(padapter);\r\nstruct registry_priv *pregistrypriv = &padapter->registrypriv;\r\nu32 numHQ = 0;\r\nu32 numLQ = 0;\r\nu32 numNQ = 0;\r\nu32 numPubQ;\r\nu32 value32;\r\nu8 value8;\r\nbool bWiFiConfig = pregistrypriv->wifi_spec;\r\nif (pHalData->OutEpQueueSel & TX_SELE_HQ)\r\nnumHQ = bWiFiConfig ? WMM_NORMAL_PAGE_NUM_HPQ_8723B : NORMAL_PAGE_NUM_HPQ_8723B;\r\nif (pHalData->OutEpQueueSel & TX_SELE_LQ)\r\nnumLQ = bWiFiConfig ? WMM_NORMAL_PAGE_NUM_LPQ_8723B : NORMAL_PAGE_NUM_LPQ_8723B;\r\nif (pHalData->OutEpQueueSel & TX_SELE_NQ)\r\nnumNQ = bWiFiConfig ? WMM_NORMAL_PAGE_NUM_NPQ_8723B : NORMAL_PAGE_NUM_NPQ_8723B;\r\nnumPubQ = TX_TOTAL_PAGE_NUMBER_8723B - numHQ - numLQ - numNQ;\r\nvalue8 = (u8)_NPQ(numNQ);\r\nrtw_write8(padapter, REG_RQPN_NPQ, value8);\r\nvalue32 = _HPQ(numHQ) | _LPQ(numLQ) | _PUBQ(numPubQ) | LD_RQPN;\r\nrtw_write32(padapter, REG_RQPN, value32);\r\nrtw_hal_set_sdio_tx_max_length(padapter, numHQ, numNQ, numLQ, numPubQ);\r\n_init_available_page_threshold(padapter, numHQ, numNQ, numLQ, numPubQ);\r\n}\r\nstatic void _InitTxBufferBoundary(struct adapter *padapter)\r\n{\r\nstruct registry_priv *pregistrypriv = &padapter->registrypriv;\r\nu8 txpktbuf_bndy;\r\nif (!pregistrypriv->wifi_spec) {\r\ntxpktbuf_bndy = TX_PAGE_BOUNDARY_8723B;\r\n} else {\r\ntxpktbuf_bndy = WMM_NORMAL_TX_PAGE_BOUNDARY_8723B;\r\n}\r\nrtw_write8(padapter, REG_TXPKTBUF_BCNQ_BDNY_8723B, txpktbuf_bndy);\r\nrtw_write8(padapter, REG_TXPKTBUF_MGQ_BDNY_8723B, txpktbuf_bndy);\r\nrtw_write8(padapter, REG_TXPKTBUF_WMAC_LBK_BF_HD_8723B, txpktbuf_bndy);\r\nrtw_write8(padapter, REG_TRXFF_BNDY, txpktbuf_bndy);\r\nrtw_write8(padapter, REG_TDECTRL+1, txpktbuf_bndy);\r\n}\r\nstatic void _InitNormalChipRegPriority(\r\nstruct adapter *Adapter,\r\nu16 beQ,\r\nu16 bkQ,\r\nu16 viQ,\r\nu16 voQ,\r\nu16 mgtQ,\r\nu16 hiQ\r\n)\r\n{\r\nu16 value16 = (rtw_read16(Adapter, REG_TRXDMA_CTRL) & 0x7);\r\nvalue16 |=\r\n_TXDMA_BEQ_MAP(beQ) |\r\n_TXDMA_BKQ_MAP(bkQ) |\r\n_TXDMA_VIQ_MAP(viQ) |\r\n_TXDMA_VOQ_MAP(voQ) |\r\n_TXDMA_MGQ_MAP(mgtQ) |\r\n_TXDMA_HIQ_MAP(hiQ);\r\nrtw_write16(Adapter, REG_TRXDMA_CTRL, value16);\r\n}\r\nstatic void _InitNormalChipOneOutEpPriority(struct adapter *Adapter)\r\n{\r\nstruct hal_com_data *pHalData = GET_HAL_DATA(Adapter);\r\nu16 value = 0;\r\nswitch (pHalData->OutEpQueueSel) {\r\ncase TX_SELE_HQ:\r\nvalue = QUEUE_HIGH;\r\nbreak;\r\ncase TX_SELE_LQ:\r\nvalue = QUEUE_LOW;\r\nbreak;\r\ncase TX_SELE_NQ:\r\nvalue = QUEUE_NORMAL;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n_InitNormalChipRegPriority(\r\nAdapter, value, value, value, value, value, value\r\n);\r\n}\r\nstatic void _InitNormalChipTwoOutEpPriority(struct adapter *Adapter)\r\n{\r\nstruct hal_com_data *pHalData = GET_HAL_DATA(Adapter);\r\nstruct registry_priv *pregistrypriv = &Adapter->registrypriv;\r\nu16 beQ, bkQ, viQ, voQ, mgtQ, hiQ;\r\nu16 valueHi = 0;\r\nu16 valueLow = 0;\r\nswitch (pHalData->OutEpQueueSel) {\r\ncase (TX_SELE_HQ | TX_SELE_LQ):\r\nvalueHi = QUEUE_HIGH;\r\nvalueLow = QUEUE_LOW;\r\nbreak;\r\ncase (TX_SELE_NQ | TX_SELE_LQ):\r\nvalueHi = QUEUE_NORMAL;\r\nvalueLow = QUEUE_LOW;\r\nbreak;\r\ncase (TX_SELE_HQ | TX_SELE_NQ):\r\nvalueHi = QUEUE_HIGH;\r\nvalueLow = QUEUE_NORMAL;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (!pregistrypriv->wifi_spec) {\r\nbeQ = valueLow;\r\nbkQ = valueLow;\r\nviQ = valueHi;\r\nvoQ = valueHi;\r\nmgtQ = valueHi;\r\nhiQ = valueHi;\r\n} else {\r\nbeQ = valueLow;\r\nbkQ = valueHi;\r\nviQ = valueHi;\r\nvoQ = valueLow;\r\nmgtQ = valueHi;\r\nhiQ = valueHi;\r\n}\r\n_InitNormalChipRegPriority(Adapter, beQ, bkQ, viQ, voQ, mgtQ, hiQ);\r\n}\r\nstatic void _InitNormalChipThreeOutEpPriority(struct adapter *padapter)\r\n{\r\nstruct registry_priv *pregistrypriv = &padapter->registrypriv;\r\nu16 beQ, bkQ, viQ, voQ, mgtQ, hiQ;\r\nif (!pregistrypriv->wifi_spec) {\r\nbeQ = QUEUE_LOW;\r\nbkQ = QUEUE_LOW;\r\nviQ = QUEUE_NORMAL;\r\nvoQ = QUEUE_HIGH;\r\nmgtQ = QUEUE_HIGH;\r\nhiQ = QUEUE_HIGH;\r\n} else {\r\nbeQ = QUEUE_LOW;\r\nbkQ = QUEUE_NORMAL;\r\nviQ = QUEUE_NORMAL;\r\nvoQ = QUEUE_HIGH;\r\nmgtQ = QUEUE_HIGH;\r\nhiQ = QUEUE_HIGH;\r\n}\r\n_InitNormalChipRegPriority(padapter, beQ, bkQ, viQ, voQ, mgtQ, hiQ);\r\n}\r\nstatic void _InitNormalChipQueuePriority(struct adapter *Adapter)\r\n{\r\nstruct hal_com_data *pHalData = GET_HAL_DATA(Adapter);\r\nswitch (pHalData->OutEpNumber) {\r\ncase 1:\r\n_InitNormalChipOneOutEpPriority(Adapter);\r\nbreak;\r\ncase 2:\r\n_InitNormalChipTwoOutEpPriority(Adapter);\r\nbreak;\r\ncase 3:\r\n_InitNormalChipThreeOutEpPriority(Adapter);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void _InitQueuePriority(struct adapter *padapter)\r\n{\r\n_InitNormalChipQueuePriority(padapter);\r\n}\r\nstatic void _InitPageBoundary(struct adapter *padapter)\r\n{\r\nu16 rxff_bndy = RX_DMA_BOUNDARY_8723B;\r\nrtw_write16(padapter, (REG_TRXFF_BNDY + 2), rxff_bndy);\r\n}\r\nstatic void _InitTransferPageSize(struct adapter *padapter)\r\n{\r\nu8 value8;\r\nvalue8 = _PSRX(PBP_128) | _PSTX(PBP_128);\r\nrtw_write8(padapter, REG_PBP, value8);\r\n}\r\nstatic void _InitDriverInfoSize(struct adapter *padapter, u8 drvInfoSize)\r\n{\r\nrtw_write8(padapter, REG_RX_DRVINFO_SZ, drvInfoSize);\r\n}\r\nstatic void _InitNetworkType(struct adapter *padapter)\r\n{\r\nu32 value32;\r\nvalue32 = rtw_read32(padapter, REG_CR);\r\nvalue32 = (value32 & ~MASK_NETTYPE) | _NETTYPE(NT_LINK_AP);\r\nrtw_write32(padapter, REG_CR, value32);\r\n}\r\nstatic void _InitWMACSetting(struct adapter *padapter)\r\n{\r\nstruct hal_com_data *pHalData;\r\nu16 value16;\r\npHalData = GET_HAL_DATA(padapter);\r\npHalData->ReceiveConfig = 0;\r\npHalData->ReceiveConfig |= RCR_APM | RCR_AM | RCR_AB;\r\npHalData->ReceiveConfig |= RCR_CBSSID_DATA | RCR_CBSSID_BCN | RCR_AMF;\r\npHalData->ReceiveConfig |= RCR_HTC_LOC_CTRL;\r\npHalData->ReceiveConfig |= RCR_APP_PHYST_RXFF | RCR_APP_ICV | RCR_APP_MIC;\r\nrtw_write32(padapter, REG_RCR, pHalData->ReceiveConfig);\r\nrtw_write32(padapter, REG_MAR, 0xFFFFFFFF);\r\nrtw_write32(padapter, REG_MAR + 4, 0xFFFFFFFF);\r\nvalue16 = 0xFFFF;\r\nrtw_write16(padapter, REG_RXFLTMAP2, value16);\r\nvalue16 = 0x400;\r\nrtw_write16(padapter, REG_RXFLTMAP1, value16);\r\nvalue16 = 0xFFFF;\r\nrtw_write16(padapter, REG_RXFLTMAP0, value16);\r\n}\r\nstatic void _InitAdaptiveCtrl(struct adapter *padapter)\r\n{\r\nu16 value16;\r\nu32 value32;\r\nvalue32 = rtw_read32(padapter, REG_RRSR);\r\nvalue32 &= ~RATE_BITMAP_ALL;\r\nvalue32 |= RATE_RRSR_CCK_ONLY_1M;\r\nrtw_write32(padapter, REG_RRSR, value32);\r\nvalue16 = _SPEC_SIFS_CCK(0x10) | _SPEC_SIFS_OFDM(0x10);\r\nrtw_write16(padapter, REG_SPEC_SIFS, value16);\r\nvalue16 = _LRL(0x30) | _SRL(0x30);\r\nrtw_write16(padapter, REG_RL, value16);\r\n}\r\nstatic void _InitEDCA(struct adapter *padapter)\r\n{\r\nrtw_write16(padapter, REG_SPEC_SIFS, 0x100a);\r\nrtw_write16(padapter, REG_MAC_SPEC_SIFS, 0x100a);\r\nrtw_write16(padapter, REG_SIFS_CTX, 0x100a);\r\nrtw_write16(padapter, REG_SIFS_TRX, 0x100a);\r\nrtw_write32(padapter, REG_EDCA_BE_PARAM, 0x005EA42B);\r\nrtw_write32(padapter, REG_EDCA_BK_PARAM, 0x0000A44F);\r\nrtw_write32(padapter, REG_EDCA_VI_PARAM, 0x005EA324);\r\nrtw_write32(padapter, REG_EDCA_VO_PARAM, 0x002FA226);\r\n}\r\nstatic void _InitRetryFunction(struct adapter *padapter)\r\n{\r\nu8 value8;\r\nvalue8 = rtw_read8(padapter, REG_FWHW_TXQ_CTRL);\r\nvalue8 |= EN_AMPDU_RTY_NEW;\r\nrtw_write8(padapter, REG_FWHW_TXQ_CTRL, value8);\r\nrtw_write8(padapter, REG_ACKTO, 0x40);\r\n}\r\nstatic void HalRxAggr8723BSdio(struct adapter *padapter)\r\n{\r\nstruct registry_priv *pregistrypriv;\r\nu8 valueDMATimeout;\r\nu8 valueDMAPageCount;\r\npregistrypriv = &padapter->registrypriv;\r\nif (pregistrypriv->wifi_spec) {\r\nvalueDMATimeout = 0x06;\r\nvalueDMAPageCount = 0x06;\r\n} else {\r\nvalueDMATimeout = 0x06;\r\nvalueDMAPageCount = 0x06;\r\n}\r\nrtw_write8(padapter, REG_RXDMA_AGG_PG_TH+1, valueDMATimeout);\r\nrtw_write8(padapter, REG_RXDMA_AGG_PG_TH, valueDMAPageCount);\r\n}\r\nstatic void sdio_AggSettingRxUpdate(struct adapter *padapter)\r\n{\r\nstruct hal_com_data *pHalData;\r\nu8 valueDMA;\r\nu8 valueRxAggCtrl = 0;\r\nu8 aggBurstNum = 3;\r\nu8 aggBurstSize = 0;\r\npHalData = GET_HAL_DATA(padapter);\r\nvalueDMA = rtw_read8(padapter, REG_TRXDMA_CTRL);\r\nvalueDMA |= RXDMA_AGG_EN;\r\nrtw_write8(padapter, REG_TRXDMA_CTRL, valueDMA);\r\nvalueRxAggCtrl |= RXDMA_AGG_MODE_EN;\r\nvalueRxAggCtrl |= ((aggBurstNum<<2) & 0x0C);\r\nvalueRxAggCtrl |= ((aggBurstSize<<4) & 0x30);\r\nrtw_write8(padapter, REG_RXDMA_MODE_CTRL_8723B, valueRxAggCtrl);\r\n}\r\nstatic void _initSdioAggregationSetting(struct adapter *padapter)\r\n{\r\nstruct hal_com_data *pHalData = GET_HAL_DATA(padapter);\r\nHalRxAggr8723BSdio(padapter);\r\nsdio_AggSettingRxUpdate(padapter);\r\npHalData->UsbRxHighSpeedMode = false;\r\n}\r\nstatic void _InitOperationMode(struct adapter *padapter)\r\n{\r\nstruct hal_com_data *pHalData;\r\nstruct mlme_ext_priv *pmlmeext;\r\nu8 regBwOpMode = 0;\r\nu32 regRATR = 0, regRRSR = 0;\r\npHalData = GET_HAL_DATA(padapter);\r\npmlmeext = &padapter->mlmeextpriv;\r\nswitch (pmlmeext->cur_wireless_mode) {\r\ncase WIRELESS_MODE_B:\r\nregBwOpMode = BW_OPMODE_20MHZ;\r\nregRATR = RATE_ALL_CCK;\r\nregRRSR = RATE_ALL_CCK;\r\nbreak;\r\ncase WIRELESS_MODE_A:\r\nbreak;\r\ncase WIRELESS_MODE_G:\r\nregBwOpMode = BW_OPMODE_20MHZ;\r\nregRATR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;\r\nregRRSR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;\r\nbreak;\r\ncase WIRELESS_MODE_AUTO:\r\nregBwOpMode = BW_OPMODE_20MHZ;\r\nregRATR = RATE_ALL_CCK | RATE_ALL_OFDM_AG | RATE_ALL_OFDM_1SS | RATE_ALL_OFDM_2SS;\r\nregRRSR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;\r\nbreak;\r\ncase WIRELESS_MODE_N_24G:\r\nregBwOpMode = BW_OPMODE_20MHZ;\r\nregRATR = RATE_ALL_CCK | RATE_ALL_OFDM_AG | RATE_ALL_OFDM_1SS | RATE_ALL_OFDM_2SS;\r\nregRRSR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;\r\nbreak;\r\ncase WIRELESS_MODE_N_5G:\r\nregBwOpMode = BW_OPMODE_5G;\r\nregRATR = RATE_ALL_OFDM_AG | RATE_ALL_OFDM_1SS | RATE_ALL_OFDM_2SS;\r\nregRRSR = RATE_ALL_OFDM_AG;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nrtw_write8(padapter, REG_BWOPMODE, regBwOpMode);\r\n}\r\nstatic void _InitInterrupt(struct adapter *padapter)\r\n{\r\nrtw_write32(padapter, REG_HISR, 0);\r\nrtw_write32(padapter, REG_HIMR, 0);\r\nInitInterrupt8723BSdio(padapter);\r\nInitSysInterrupt8723BSdio(padapter);\r\n}\r\nstatic void _InitRFType(struct adapter *padapter)\r\n{\r\nstruct hal_com_data *pHalData = GET_HAL_DATA(padapter);\r\n#if DISABLE_BB_RF\r\npHalData->rf_chip = RF_PSEUDO_11N;\r\nreturn;\r\n#endif\r\npHalData->rf_chip = RF_6052;\r\npHalData->rf_type = RF_1T1R;\r\nDBG_8192C("Set RF Chip ID to RF_6052 and RF type to 1T1R.\n");\r\n}\r\nstatic void _RfPowerSave(struct adapter *padapter)\r\n{\r\n}\r\nstatic bool HalDetectPwrDownMode(struct adapter *Adapter)\r\n{\r\nu8 tmpvalue;\r\nstruct hal_com_data *pHalData = GET_HAL_DATA(Adapter);\r\nstruct pwrctrl_priv *pwrctrlpriv = adapter_to_pwrctl(Adapter);\r\nEFUSE_ShadowRead(Adapter, 1, 0x7B, (u32 *)&tmpvalue);\r\nif (tmpvalue & BIT4 && pwrctrlpriv->reg_pdnmode)\r\npHalData->pwrdown = true;\r\nelse\r\npHalData->pwrdown = false;\r\nDBG_8192C("HalDetectPwrDownMode(): PDN =%d\n", pHalData->pwrdown);\r\nreturn pHalData->pwrdown;\r\n}\r\nstatic u32 rtl8723bs_hal_init(struct adapter *padapter)\r\n{\r\ns32 ret;\r\nstruct hal_com_data *pHalData;\r\nstruct pwrctrl_priv *pwrctrlpriv;\r\nstruct registry_priv *pregistrypriv;\r\nu32 NavUpper = WiFiNavUpperUs;\r\nu8 u1bTmp;\r\npHalData = GET_HAL_DATA(padapter);\r\npwrctrlpriv = adapter_to_pwrctl(padapter);\r\npregistrypriv = &padapter->registrypriv;\r\nif (\r\nadapter_to_pwrctl(padapter)->bips_processing == true &&\r\nadapter_to_pwrctl(padapter)->pre_ips_type == 0\r\n) {\r\nunsigned long start_time;\r\nu8 cpwm_orig, cpwm_now;\r\nu8 val8, bMacPwrCtrlOn = true;\r\nDBG_871X("%s: Leaving IPS in FWLPS state\n", __func__);\r\ncpwm_orig = 0;\r\nrtw_hal_get_hwreg(padapter, HW_VAR_CPWM, &cpwm_orig);\r\nval8 = rtw_read8(padapter, SDIO_LOCAL_BASE|SDIO_REG_HRPWM1);\r\nval8 &= 0x80;\r\nval8 += 0x80;\r\nval8 |= BIT(6);\r\nrtw_write8(padapter, SDIO_LOCAL_BASE|SDIO_REG_HRPWM1, val8);\r\nDBG_871X("%s: write rpwm =%02x\n", __func__, val8);\r\nadapter_to_pwrctl(padapter)->tog = (val8 + 0x80) & 0x80;\r\nstart_time = jiffies;\r\ndo {\r\nmdelay(1);\r\nrtw_hal_get_hwreg(padapter, HW_VAR_CPWM, &cpwm_now);\r\nif ((cpwm_orig ^ cpwm_now) & 0x80)\r\nbreak;\r\nif (jiffies_to_msecs(jiffies - start_time) > 100) {\r\nDBG_871X("%s: polling cpwm timeout when leaving IPS in FWLPS state\n", __func__);\r\nbreak;\r\n}\r\n} while (1);\r\nrtl8723b_set_FwPwrModeInIPS_cmd(padapter, 0);\r\nrtw_hal_set_hwreg(padapter, HW_VAR_APFM_ON_MAC, &bMacPwrCtrlOn);\r\nrtw_btcoex_HAL_Initialize(padapter, false);\r\nreturn _SUCCESS;\r\n}\r\n#ifdef CONFIG_WOWLAN\r\nif (rtw_read8(padapter, REG_MCUFWDL)&BIT7) {\r\nu8 reg_val = 0;\r\nDBG_871X("+Reset Entry+\n");\r\nrtw_write8(padapter, REG_MCUFWDL, 0x00);\r\n_8051Reset8723(padapter);\r\nreg_val = rtw_read8(padapter, REG_SYS_FUNC_EN);\r\nreg_val &= ~(BIT(0) | BIT(1));\r\nrtw_write8(padapter, REG_SYS_FUNC_EN, reg_val);\r\nrtw_write8(padapter, REG_RF_CTRL, 0);\r\nrtw_write16(padapter, REG_CR, 0);\r\nreg_val = rtw_read8(padapter, REG_SYS_FUNC_EN+1);\r\nreg_val &= ~(BIT(4) | BIT(7));\r\nrtw_write8(padapter, REG_SYS_FUNC_EN+1, reg_val);\r\nreg_val = rtw_read8(padapter, REG_SYS_FUNC_EN+1);\r\nreg_val |= BIT(4) | BIT(7);\r\nrtw_write8(padapter, REG_SYS_FUNC_EN+1, reg_val);\r\nDBG_871X("-Reset Entry-\n");\r\n}\r\n#endif\r\nret = _InitPowerOn_8723BS(padapter);\r\nif (_FAIL == ret) {\r\nRT_TRACE(_module_hci_hal_init_c_, _drv_err_, ("Failed to init Power On!\n"));\r\nreturn _FAIL;\r\n}\r\nrtw_write8(padapter, REG_EARLY_MODE_CONTROL, 0);\r\nret = rtl8723b_FirmwareDownload(padapter, false);\r\nif (ret != _SUCCESS) {\r\nRT_TRACE(_module_hci_hal_init_c_, _drv_err_, ("%s: Download Firmware failed!!\n", __func__));\r\npadapter->bFWReady = false;\r\npHalData->fw_ractrl = false;\r\nreturn ret;\r\n} else {\r\nRT_TRACE(_module_hci_hal_init_c_, _drv_notice_, ("rtl8723bs_hal_init(): Download Firmware Success!!\n"));\r\npadapter->bFWReady = true;\r\npHalData->fw_ractrl = true;\r\n}\r\nrtl8723b_InitializeFirmwareVars(padapter);\r\nif (pwrctrlpriv->reg_rfoff == true)\r\npwrctrlpriv->rf_pwrstate = rf_off;\r\nHalDetectPwrDownMode(padapter);\r\n_InitRFType(padapter);\r\npHalData->CurrentChannel = 6;\r\n#if (HAL_MAC_ENABLE == 1)\r\nret = PHY_MACConfig8723B(padapter);\r\nif (ret != _SUCCESS) {\r\nRT_TRACE(_module_hci_hal_init_c_, _drv_info_, ("Initializepadapter8192CSdio(): Fail to configure MAC!!\n"));\r\nreturn ret;\r\n}\r\n#endif\r\n#if (HAL_BB_ENABLE == 1)\r\nret = PHY_BBConfig8723B(padapter);\r\nif (ret != _SUCCESS) {\r\nRT_TRACE(_module_hci_hal_init_c_, _drv_info_, ("Initializepadapter8192CSdio(): Fail to configure BB!!\n"));\r\nreturn ret;\r\n}\r\n#endif\r\n{\r\n#if (HAL_RF_ENABLE == 1)\r\nret = PHY_RFConfig8723B(padapter);\r\nif (ret != _SUCCESS) {\r\nRT_TRACE(_module_hci_hal_init_c_, _drv_info_, ("Initializepadapter8192CSdio(): Fail to configure RF!!\n"));\r\nreturn ret;\r\n}\r\n#endif\r\n}\r\npHalData->RfRegChnlVal[0] =\r\nPHY_QueryRFReg(padapter, (enum RF_PATH)0, RF_CHNLBW, bRFRegOffsetMask);\r\npHalData->RfRegChnlVal[1] =\r\nPHY_QueryRFReg(padapter, (enum RF_PATH)1, RF_CHNLBW, bRFRegOffsetMask);\r\n_InitQueueReservedPage(padapter);\r\n_InitTxBufferBoundary(padapter);\r\nret = rtl8723b_InitLLTTable(padapter);\r\nif (_SUCCESS != ret) {\r\nDBG_8192C("%s: Failed to init LLT Table!\n", __func__);\r\nreturn _FAIL;\r\n}\r\n_InitQueuePriority(padapter);\r\n_InitPageBoundary(padapter);\r\n_InitTransferPageSize(padapter);\r\n_InitDriverInfoSize(padapter, DRVINFO_SZ);\r\nhal_init_macaddr(padapter);\r\n_InitNetworkType(padapter);\r\n_InitWMACSetting(padapter);\r\n_InitAdaptiveCtrl(padapter);\r\n_InitEDCA(padapter);\r\n_InitRetryFunction(padapter);\r\n_initSdioAggregationSetting(padapter);\r\n_InitOperationMode(padapter);\r\nrtl8723b_InitBeaconParameters(padapter);\r\n_InitInterrupt(padapter);\r\n_InitBurstPktLen_8723BS(padapter);\r\nrtw_write8(padapter, REG_SECONDARY_CCA_CTRL_8723B, 0x3);\r\nrtw_write8(padapter, 0x976, 0);\r\nrtw_write16(padapter, REG_PKT_VO_VI_LIFE_TIME, 0x0400);\r\nrtw_write16(padapter, REG_PKT_BE_BK_LIFE_TIME, 0x0400);\r\ninvalidate_cam_all(padapter);\r\nrtw_hal_set_chnl_bw(padapter, padapter->registrypriv.channel,\r\nCHANNEL_WIDTH_20, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HAL_PRIME_CHNL_OFFSET_DONT_CARE);\r\nrtl8723b_InitAntenna_Selection(padapter);\r\nrtw_write32(padapter, REG_BAR_MODE_CTRL, 0x0201ffff);\r\nrtw_write8(padapter, REG_HWSEQ_CTRL, 0xFF);\r\nrtw_write32(padapter, SDIO_LOCAL_BASE|SDIO_REG_TX_CTRL, 0);\r\n_RfPowerSave(padapter);\r\nrtl8723b_InitHalDm(padapter);\r\nHalQueryTxBufferStatus8723BSdio(padapter);\r\nHalQueryTxOQTBufferStatus8723BSdio(padapter);\r\npHalData->SdioTxOQTMaxFreeSpace = pHalData->SdioTxOQTFreeSpace;\r\nu1bTmp = rtw_read8(padapter, REG_CR);\r\nu1bTmp |= (MACTXEN | MACRXEN);\r\nrtw_write8(padapter, REG_CR, u1bTmp);\r\nrtw_hal_set_hwreg(padapter, HW_VAR_NAV_UPPER, (u8 *)&NavUpper);\r\nrtw_write32(padapter, REG_FWHW_TXQ_CTRL, rtw_read32(padapter, REG_FWHW_TXQ_CTRL)|BIT(12));\r\n{\r\npwrctrlpriv->rf_pwrstate = rf_on;\r\nif (pwrctrlpriv->rf_pwrstate == rf_on) {\r\nstruct pwrctrl_priv *pwrpriv;\r\nunsigned long start_time;\r\nu8 restore_iqk_rst;\r\nu8 b2Ant;\r\nu8 h2cCmdBuf;\r\npwrpriv = adapter_to_pwrctl(padapter);\r\nPHY_LCCalibrate_8723B(&pHalData->odmpriv);\r\nh2cCmdBuf = 1;\r\nFillH2CCmd8723B(padapter, H2C_8723B_BT_WLAN_CALIBRATION, 1, &h2cCmdBuf);\r\nstart_time = jiffies;\r\ndo {\r\nif (rtw_read8(padapter, 0x1e7) & 0x01)\r\nbreak;\r\nmsleep(50);\r\n} while (jiffies_to_msecs(jiffies - start_time) <= 400);\r\nrtw_btcoex_IQKNotify(padapter, true);\r\nrestore_iqk_rst = (pwrpriv->bips_processing == true) ? true : false;\r\nb2Ant = pHalData->EEPROMBluetoothAntNum == Ant_x2 ? true : false;\r\nPHY_IQCalibrate_8723B(padapter, false, restore_iqk_rst, b2Ant, pHalData->ant_path);\r\npHalData->odmpriv.RFCalibrateInfo.bIQKInitialized = true;\r\nrtw_btcoex_IQKNotify(padapter, false);\r\nh2cCmdBuf = 0;\r\nFillH2CCmd8723B(padapter, H2C_8723B_BT_WLAN_CALIBRATION, 1, &h2cCmdBuf);\r\nODM_TXPowerTrackingCheck(&pHalData->odmpriv);\r\n}\r\n}\r\nrtw_btcoex_HAL_Initialize(padapter, false);\r\nRT_TRACE(_module_hci_hal_init_c_, _drv_info_, ("-%s\n", __func__));\r\nreturn _SUCCESS;\r\n}\r\nstatic void CardDisableRTL8723BSdio(struct adapter *padapter)\r\n{\r\nu8 u1bTmp;\r\nu8 bMacPwrCtrlOn;\r\nu8 ret = _FAIL;\r\nret = HalPwrSeqCmdParsing(padapter, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, rtl8723B_enter_lps_flow);\r\nif (ret == _FAIL) {\r\nDBG_8192C(KERN_ERR "%s: run RF OFF flow fail!\n", __func__);\r\n}\r\nu1bTmp = rtw_read8(padapter, REG_MCUFWDL);\r\nif ((u1bTmp & RAM_DL_SEL) && padapter->bFWReady)\r\nrtl8723b_FirmwareSelfReset(padapter);\r\nu1bTmp = rtw_read8(padapter, REG_SYS_FUNC_EN+1);\r\nu1bTmp &= ~BIT(2);\r\nrtw_write8(padapter, REG_SYS_FUNC_EN+1, u1bTmp);\r\nrtw_write8(padapter, REG_MCUFWDL, 0);\r\nu1bTmp = rtw_read8(padapter, REG_RSV_CTRL+1);\r\nu1bTmp &= ~BIT(0);\r\nrtw_write8(padapter, REG_RSV_CTRL+1, u1bTmp);\r\nu1bTmp = rtw_read8(padapter, REG_RSV_CTRL+1);\r\nu1bTmp |= BIT(0);\r\nrtw_write8(padapter, REG_RSV_CTRL+1, u1bTmp);\r\nbMacPwrCtrlOn = false;\r\nret = false;\r\nrtw_hal_set_hwreg(padapter, HW_VAR_APFM_ON_MAC, &bMacPwrCtrlOn);\r\nret = HalPwrSeqCmdParsing(padapter, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, rtl8723B_card_disable_flow);\r\nif (ret == false) {\r\nDBG_8192C(KERN_ERR "%s: run CARD DISABLE flow fail!\n", __func__);\r\n}\r\n}\r\nstatic u32 rtl8723bs_hal_deinit(struct adapter *padapter)\r\n{\r\nstruct dvobj_priv *psdpriv = padapter->dvobj;\r\nstruct debug_priv *pdbgpriv = &psdpriv->drv_dbg;\r\nif (padapter->hw_init_completed == true) {\r\nif (adapter_to_pwrctl(padapter)->bips_processing == true) {\r\nif (padapter->netif_up == true) {\r\nint cnt = 0;\r\nu8 val8 = 0;\r\nDBG_871X("%s: issue H2C to FW when entering IPS\n", __func__);\r\nrtl8723b_set_FwPwrModeInIPS_cmd(padapter, 0x3);\r\ndo {\r\nval8 = rtw_read8(padapter, REG_HMETFR);\r\ncnt++;\r\nDBG_871X("%s polling REG_HMETFR = 0x%x, cnt =%d\n", __func__, val8, cnt);\r\nmdelay(10);\r\n} while (cnt < 100 && (val8 != 0));\r\nif (val8 == 0) {\r\nval8 = rtw_read8(padapter, SDIO_LOCAL_BASE|SDIO_REG_HRPWM1);\r\nval8 += 0x80;\r\nval8 |= BIT(0);\r\nrtw_write8(padapter, SDIO_LOCAL_BASE|SDIO_REG_HRPWM1, val8);\r\nDBG_871X("%s: write rpwm =%02x\n", __func__, val8);\r\nadapter_to_pwrctl(padapter)->tog = (val8 + 0x80) & 0x80;\r\ncnt = val8 = 0;\r\ndo {\r\nval8 = rtw_read8(padapter, REG_CR);\r\ncnt++;\r\nDBG_871X("%s polling 0x100 = 0x%x, cnt =%d\n", __func__, val8, cnt);\r\nmdelay(10);\r\n} while (cnt < 100 && (val8 != 0xEA));\r\n} else {\r\nDBG_871X(\r\n"MAC_1C0 =%08x, MAC_1C4 =%08x, MAC_1C8 =%08x, MAC_1CC =%08x\n",\r\nrtw_read32(padapter, 0x1c0),\r\nrtw_read32(padapter, 0x1c4),\r\nrtw_read32(padapter, 0x1c8),\r\nrtw_read32(padapter, 0x1cc)\r\n);\r\n}\r\nDBG_871X(\r\n"polling done when entering IPS, check result : 0x100 = 0x%x, cnt =%d, MAC_1cc = 0x%02x\n",\r\nrtw_read8(padapter, REG_CR),\r\ncnt,\r\nrtw_read8(padapter, REG_HMETFR)\r\n);\r\nadapter_to_pwrctl(padapter)->pre_ips_type = 0;\r\n} else {\r\npdbgpriv->dbg_carddisable_cnt++;\r\nCardDisableRTL8723BSdio(padapter);\r\nadapter_to_pwrctl(padapter)->pre_ips_type = 1;\r\n}\r\n} else {\r\npdbgpriv->dbg_carddisable_cnt++;\r\nCardDisableRTL8723BSdio(padapter);\r\n}\r\n} else\r\npdbgpriv->dbg_deinit_fail_cnt++;\r\nreturn _SUCCESS;\r\n}\r\nstatic u32 rtl8723bs_inirp_init(struct adapter *padapter)\r\n{\r\nreturn _SUCCESS;\r\n}\r\nstatic u32 rtl8723bs_inirp_deinit(struct adapter *padapter)\r\n{\r\nRT_TRACE(_module_hci_hal_init_c_, _drv_info_, ("+rtl8723bs_inirp_deinit\n"));\r\nRT_TRACE(_module_hci_hal_init_c_, _drv_info_, ("-rtl8723bs_inirp_deinit\n"));\r\nreturn _SUCCESS;\r\n}\r\nstatic void rtl8723bs_init_default_value(struct adapter *padapter)\r\n{\r\nstruct hal_com_data *pHalData;\r\npHalData = GET_HAL_DATA(padapter);\r\nrtl8723b_init_default_value(padapter);\r\npHalData->SdioRxFIFOCnt = 0;\r\n}\r\nstatic void rtl8723bs_interface_configure(struct adapter *padapter)\r\n{\r\nstruct hal_com_data *pHalData = GET_HAL_DATA(padapter);\r\nstruct dvobj_priv *pdvobjpriv = adapter_to_dvobj(padapter);\r\nstruct registry_priv *pregistrypriv = &padapter->registrypriv;\r\nbool bWiFiConfig = pregistrypriv->wifi_spec;\r\npdvobjpriv->RtOutPipe[0] = WLAN_TX_HIQ_DEVICE_ID;\r\npdvobjpriv->RtOutPipe[1] = WLAN_TX_MIQ_DEVICE_ID;\r\npdvobjpriv->RtOutPipe[2] = WLAN_TX_LOQ_DEVICE_ID;\r\nif (bWiFiConfig)\r\npHalData->OutEpNumber = 2;\r\nelse\r\npHalData->OutEpNumber = SDIO_MAX_TX_QUEUE;\r\nswitch (pHalData->OutEpNumber) {\r\ncase 3:\r\npHalData->OutEpQueueSel = TX_SELE_HQ | TX_SELE_LQ|TX_SELE_NQ;\r\nbreak;\r\ncase 2:\r\npHalData->OutEpQueueSel = TX_SELE_HQ | TX_SELE_NQ;\r\nbreak;\r\ncase 1:\r\npHalData->OutEpQueueSel = TX_SELE_HQ;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nHal_MappingOutPipe(padapter, pHalData->OutEpNumber);\r\n}\r\nstatic void _EfuseCellSel(struct adapter *padapter)\r\n{\r\nu32 value32;\r\nvalue32 = rtw_read32(padapter, EFUSE_TEST);\r\nvalue32 = (value32 & ~EFUSE_SEL_MASK) | EFUSE_SEL(EFUSE_WIFI_SEL_0);\r\nrtw_write32(padapter, EFUSE_TEST, value32);\r\n}\r\nstatic void _ReadRFType(struct adapter *Adapter)\r\n{\r\nstruct hal_com_data *pHalData = GET_HAL_DATA(Adapter);\r\n#if DISABLE_BB_RF\r\npHalData->rf_chip = RF_PSEUDO_11N;\r\n#else\r\npHalData->rf_chip = RF_6052;\r\n#endif\r\n}\r\nstatic void Hal_EfuseParseMACAddr_8723BS(\r\nstruct adapter *padapter, u8 *hwinfo, bool AutoLoadFail\r\n)\r\n{\r\nu16 i;\r\nu8 sMacAddr[6] = {0x00, 0xE0, 0x4C, 0xb7, 0x23, 0x00};\r\nstruct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(padapter);\r\nif (AutoLoadFail) {\r\nfor (i = 0; i < 6; i++)\r\npEEPROM->mac_addr[i] = sMacAddr[i];\r\n} else {\r\nmemcpy(pEEPROM->mac_addr, &hwinfo[EEPROM_MAC_ADDR_8723BS], ETH_ALEN);\r\n}\r\nRT_TRACE(\r\n_module_hci_hal_init_c_,\r\n_drv_notice_,\r\n(\r\n"Hal_EfuseParseMACAddr_8723BS: Permanent Address = %02x-%02x-%02x-%02x-%02x-%02x\n",\r\npEEPROM->mac_addr[0],\r\npEEPROM->mac_addr[1],\r\npEEPROM->mac_addr[2],\r\npEEPROM->mac_addr[3],\r\npEEPROM->mac_addr[4],\r\npEEPROM->mac_addr[5]\r\n)\r\n);\r\n}\r\nstatic void Hal_EfuseParseBoardType_8723BS(\r\nstruct adapter *padapter, u8 *hwinfo, bool AutoLoadFail\r\n)\r\n{\r\nstruct hal_com_data *pHalData = GET_HAL_DATA(padapter);\r\nif (!AutoLoadFail) {\r\npHalData->BoardType = (hwinfo[EEPROM_RF_BOARD_OPTION_8723B] & 0xE0) >> 5;\r\nif (pHalData->BoardType == 0xFF)\r\npHalData->BoardType = (EEPROM_DEFAULT_BOARD_OPTION&0xE0)>>5;\r\n} else\r\npHalData->BoardType = 0;\r\nRT_TRACE(_module_hci_hal_init_c_, _drv_info_, ("Board Type: 0x%2x\n", pHalData->BoardType));\r\n}\r\nstatic void _ReadEfuseInfo8723BS(struct adapter *padapter)\r\n{\r\nstruct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(padapter);\r\nu8 *hwinfo = NULL;\r\nRT_TRACE(_module_hci_hal_init_c_, _drv_info_, ("====>_ReadEfuseInfo8723BS()\n"));\r\nif (sizeof(pEEPROM->efuse_eeprom_data) < HWSET_MAX_SIZE_8723B)\r\nDBG_871X("[WARNING] size of efuse_eeprom_data is less than HWSET_MAX_SIZE_8723B!\n");\r\nhwinfo = pEEPROM->efuse_eeprom_data;\r\nHal_InitPGData(padapter, hwinfo);\r\nHal_EfuseParseIDCode(padapter, hwinfo);\r\nHal_EfuseParseEEPROMVer_8723B(padapter, hwinfo, pEEPROM->bautoload_fail_flag);\r\nHal_EfuseParseMACAddr_8723BS(padapter, hwinfo, pEEPROM->bautoload_fail_flag);\r\nHal_EfuseParseTxPowerInfo_8723B(padapter, hwinfo, pEEPROM->bautoload_fail_flag);\r\nHal_EfuseParseBoardType_8723BS(padapter, hwinfo, pEEPROM->bautoload_fail_flag);\r\nHal_EfuseParsePackageType_8723B(padapter, hwinfo, pEEPROM->bautoload_fail_flag);\r\nHal_EfuseParseBTCoexistInfo_8723B(padapter, hwinfo, pEEPROM->bautoload_fail_flag);\r\nHal_EfuseParseChnlPlan_8723B(padapter, hwinfo, pEEPROM->bautoload_fail_flag);\r\nHal_EfuseParseXtal_8723B(padapter, hwinfo, pEEPROM->bautoload_fail_flag);\r\nHal_EfuseParseThermalMeter_8723B(padapter, hwinfo, pEEPROM->bautoload_fail_flag);\r\nHal_EfuseParseAntennaDiversity_8723B(padapter, hwinfo, pEEPROM->bautoload_fail_flag);\r\nHal_EfuseParseCustomerID_8723B(padapter, hwinfo, pEEPROM->bautoload_fail_flag);\r\nHal_EfuseParseVoltage_8723B(padapter, hwinfo, pEEPROM->bautoload_fail_flag);\r\n#ifdef CONFIG_WOWLAN\r\nHal_DetectWoWMode(padapter);\r\n#endif\r\nHal_ReadRFGainOffset(padapter, hwinfo, pEEPROM->bautoload_fail_flag);\r\nRT_TRACE(_module_hci_hal_init_c_, _drv_info_, ("<==== _ReadEfuseInfo8723BS()\n"));\r\n}\r\nstatic void _ReadPROMContent(struct adapter *padapter)\r\n{\r\nstruct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(padapter);\r\nu8 eeValue;\r\neeValue = rtw_read8(padapter, REG_9346CR);\r\npEEPROM->EepromOrEfuse = (eeValue & BOOT_FROM_EEPROM) ? true : false;\r\npEEPROM->bautoload_fail_flag = (eeValue & EEPROM_EN) ? false : true;\r\nRT_TRACE(_module_hci_hal_init_c_, _drv_info_,\r\n("%s: 9346CR = 0x%02X, Boot from %s, Autoload %s\n",\r\n__func__, eeValue,\r\n(pEEPROM->EepromOrEfuse ? "EEPROM" : "EFUSE"),\r\n(pEEPROM->bautoload_fail_flag ? "Fail" : "OK")));\r\n_ReadEfuseInfo8723BS(padapter);\r\n}\r\nstatic void _InitOtherVariable(struct adapter *Adapter)\r\n{\r\n}\r\nstatic s32 _ReadAdapterInfo8723BS(struct adapter *padapter)\r\n{\r\nu8 val8;\r\nunsigned long start;\r\nRT_TRACE(_module_hci_hal_init_c_, _drv_info_, ("+_ReadAdapterInfo8723BS\n"));\r\nif (padapter->hw_init_completed == false)\r\n_InitPowerOn_8723BS(padapter);\r\nval8 = rtw_read8(padapter, 0x4e);\r\nMSG_8192C("%s, 0x4e = 0x%x\n", __func__, val8);\r\nval8 |= BIT(6);\r\nrtw_write8(padapter, 0x4e, val8);\r\nstart = jiffies;\r\n_EfuseCellSel(padapter);\r\n_ReadRFType(padapter);\r\n_ReadPROMContent(padapter);\r\n_InitOtherVariable(padapter);\r\nif (padapter->hw_init_completed == false) {\r\nrtw_write8(padapter, 0x67, 0x00);\r\nCardDisableRTL8723BSdio(padapter);\r\n}\r\nMSG_8192C("<==== _ReadAdapterInfo8723BS in %d ms\n", jiffies_to_msecs(jiffies - start));\r\nreturn _SUCCESS;\r\n}\r\nstatic void ReadAdapterInfo8723BS(struct adapter *padapter)\r\n{\r\npadapter->EepromAddressSize = GetEEPROMSize8723B(padapter);\r\n_ReadAdapterInfo8723BS(padapter);\r\n}\r\nstatic void SetHwReg8723BS(struct adapter *padapter, u8 variable, u8 *val)\r\n{\r\nstruct hal_com_data *pHalData;\r\nu8 val8;\r\n#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)\r\nstruct wowlan_ioctl_param *poidparam;\r\nstruct pwrctrl_priv *pwrctl = adapter_to_pwrctl(padapter);\r\nint res;\r\nu32 tmp;\r\nu16 len = 0;\r\nu8 trycnt = 100;\r\nu32 himr = 0;\r\n#if defined(CONFIG_WOWLAN)\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct sta_info *psta = NULL;\r\nu64 iv_low = 0, iv_high = 0;\r\nu8 mstatus = (*(u8 *)val);\r\n#endif\r\n#endif\r\npHalData = GET_HAL_DATA(padapter);\r\nswitch (variable) {\r\ncase HW_VAR_SET_RPWM:\r\n{\r\nval8 = *val;\r\nval8 &= 0xC1;\r\nrtw_write8(padapter, SDIO_LOCAL_BASE|SDIO_REG_HRPWM1, val8);\r\n}\r\nbreak;\r\ncase HW_VAR_SET_REQ_FW_PS:\r\n{\r\nu8 req_fw_ps = 0;\r\nreq_fw_ps = rtw_read8(padapter, 0x8f);\r\nreq_fw_ps |= 0x10;\r\nrtw_write8(padapter, 0x8f, req_fw_ps);\r\n}\r\nbreak;\r\ncase HW_VAR_RXDMA_AGG_PG_TH:\r\nval8 = *val;\r\nbreak;\r\n#ifdef CONFIG_WOWLAN\r\ncase HW_VAR_WOWLAN:\r\n{\r\npoidparam = (struct wowlan_ioctl_param *)val;\r\nswitch (poidparam->subcode) {\r\ncase WOWLAN_ENABLE:\r\nDBG_871X_LEVEL(_drv_always_, "WOWLAN_ENABLE\n");\r\nrtw_write8(padapter, 0x8d, 1);\r\nrtw_write8(padapter, 0x8c, 0);\r\nrtw_write8(padapter, 0x8f, 0x40);\r\nrtw_write8(padapter, 0x8b,\r\nrtw_read8(padapter, 0x2f0));\r\nDBG_871X_LEVEL(_drv_always_, "Re-download WoWlan FW!\n");\r\nSetFwRelatedForWoWLAN8723b(padapter, true);\r\nDBG_871X_LEVEL(_drv_always_, "Pause DMA\n");\r\nrtw_write32(padapter, REG_RXPKT_NUM, (rtw_read32(padapter, REG_RXPKT_NUM)|RW_RELEASE_EN));\r\ndo {\r\nif ((rtw_read32(padapter, REG_RXPKT_NUM)&RXDMA_IDLE)) {\r\nDBG_871X_LEVEL(_drv_always_, "RX_DMA_IDLE is true\n");\r\nbreak;\r\n} else {\r\nres = sdio_local_read(padapter, SDIO_REG_RX0_REQ_LEN, 4, (u8 *)&tmp);\r\nlen = le16_to_cpu(tmp);\r\nDBG_871X_LEVEL(_drv_always_, "RX len:%d\n", len);\r\nif (len > 0)\r\nres = RecvOnePkt(padapter, len);\r\nelse\r\nDBG_871X_LEVEL(_drv_always_, "read length fail %d\n", len);\r\nDBG_871X_LEVEL(_drv_always_, "RecvOnePkt Result: %d\n", res);\r\n}\r\n} while (trycnt--);\r\nif (trycnt == 0)\r\nDBG_871X_LEVEL(_drv_always_, "Stop RX DMA failed......\n");\r\nDBG_871X_LEVEL(_drv_always_, "Clear IMR and ISR\n");\r\ntmp = 0;\r\nsdio_local_write(padapter, SDIO_REG_HIMR_ON, 4, (u8 *)&tmp);\r\nsdio_local_write(padapter, SDIO_REG_HIMR, 4, (u8 *)&tmp);\r\nsdio_local_read(padapter, SDIO_REG_HISR, 4, (u8 *)&tmp);\r\nsdio_local_write(padapter, SDIO_REG_HISR, 4, (u8 *)&tmp);\r\nDBG_871X_LEVEL(_drv_always_, "Enable only CPWM2\n");\r\nsdio_local_read(padapter, SDIO_REG_HIMR, 4, (u8 *)&tmp);\r\nDBG_871X("DisableInterruptButCpwm28723BSdio(): Read SDIO_REG_HIMR: 0x%08x\n", tmp);\r\nhimr = cpu_to_le32(SDIO_HIMR_DISABLED)|SDIO_HIMR_CPWM2_MSK;\r\nsdio_local_write(padapter, SDIO_REG_HIMR, 4, (u8 *)&himr);\r\nsdio_local_read(padapter, SDIO_REG_HIMR, 4, (u8 *)&tmp);\r\nDBG_871X("DisableInterruptButCpwm28723BSdio(): Read again SDIO_REG_HIMR: 0x%08x\n", tmp);\r\nDBG_871X_LEVEL(_drv_always_, "Set Enable WOWLan cmd\n");\r\nrtl8723b_set_wowlan_cmd(padapter, 1);\r\nif (!pwrctl->wowlan_pno_enable) {\r\nDBG_871X_LEVEL(_drv_always_, "Check EnableWoWlan CMD is ready\n");\r\nmstatus = rtw_read8(padapter, REG_WOW_CTRL);\r\ntrycnt = 10;\r\nwhile (!(mstatus&BIT1) && trycnt > 1) {\r\nmstatus = rtw_read8(padapter, REG_WOW_CTRL);\r\nDBG_871X("Loop index: %d :0x%02x\n", trycnt, mstatus);\r\ntrycnt--;\r\nmsleep(2);\r\n}\r\n}\r\nbreak;\r\ncase WOWLAN_DISABLE:\r\nDBG_871X_LEVEL(_drv_always_, "WOWLAN_DISABLE\n");\r\npsta = rtw_get_stainfo(&padapter->stapriv, get_bssid(pmlmepriv));\r\nif (psta != NULL)\r\nrtl8723b_set_FwMediaStatusRpt_cmd(padapter, RT_MEDIA_DISCONNECT, psta->mac_id);\r\nelse\r\nDBG_871X("psta is null\n");\r\npwrctl->wowlan_wake_reason = rtw_read8(padapter, REG_WOWLAN_WAKE_REASON);\r\nDBG_871X_LEVEL(\r\n_drv_always_,\r\n"wakeup_reason: 0x%02x, mac_630 = 0x%08x, mac_634 = 0x%08x, mac_1c0 = 0x%08x, mac_1c4 = 0x%08x"\r\n", mac_494 = 0x%08x, , mac_498 = 0x%08x, mac_49c = 0x%08x, mac_608 = 0x%08x, mac_4a0 = 0x%08x, mac_4a4 = 0x%08x\n"\r\n", mac_1cc = 0x%08x, mac_2f0 = 0x%08x, mac_2f4 = 0x%08x, mac_2f8 = 0x%08x, mac_2fc = 0x%08x, mac_8c = 0x%08x",\r\npwrctl->wowlan_wake_reason,\r\nrtw_read32(padapter, REG_WOWLAN_GTK_DBG1),\r\nrtw_read32(padapter, REG_WOWLAN_GTK_DBG2),\r\nrtw_read32(padapter, 0x1c0),\r\nrtw_read32(padapter, 0x1c4),\r\nrtw_read32(padapter, 0x494),\r\nrtw_read32(padapter, 0x498),\r\nrtw_read32(padapter, 0x49c),\r\nrtw_read32(padapter, 0x608),\r\nrtw_read32(padapter, 0x4a0),\r\nrtw_read32(padapter, 0x4a4),\r\nrtw_read32(padapter, 0x1cc),\r\nrtw_read32(padapter, 0x2f0),\r\nrtw_read32(padapter, 0x2f4),\r\nrtw_read32(padapter, 0x2f8),\r\nrtw_read32(padapter, 0x2fc),\r\nrtw_read32(padapter, 0x8c)\r\n);\r\n#ifdef CONFIG_PNO_SET_DEBUG\r\nDBG_871X("0x1b9: 0x%02x, 0x632: 0x%02x\n", rtw_read8(padapter, 0x1b9), rtw_read8(padapter, 0x632));\r\nDBG_871X("0x4fc: 0x%02x, 0x4fd: 0x%02x\n", rtw_read8(padapter, 0x4fc), rtw_read8(padapter, 0x4fd));\r\nDBG_871X("TXDMA STATUS: 0x%08x\n", rtw_read32(padapter, REG_TXDMA_STATUS));\r\n#endif\r\n{\r\nDBG_871X_LEVEL(_drv_always_, "Set Disable WOWLan cmd\n");\r\nrtl8723b_set_wowlan_cmd(padapter, 0);\r\nDBG_871X_LEVEL(_drv_always_, "Check DisableWoWlan CMD is ready\n");\r\nmstatus = rtw_read8(padapter, REG_WOW_CTRL);\r\ntrycnt = 50;\r\nwhile (mstatus&BIT1 && trycnt > 1) {\r\nmstatus = rtw_read8(padapter, REG_WOW_CTRL);\r\nDBG_871X_LEVEL(_drv_always_, "Loop index: %d :0x%02x\n", trycnt, mstatus);\r\ntrycnt--;\r\nmsleep(10);\r\n}\r\nif (mstatus & BIT1) {\r\nDBG_871X_LEVEL(_drv_always_, "Disable WOW mode fail!!\n");\r\nDBG_871X("Set 0x690 = 0x00\n");\r\nrtw_write8(padapter, REG_WOW_CTRL, (rtw_read8(padapter, REG_WOW_CTRL)&0xf0));\r\nDBG_871X_LEVEL(_drv_always_, "Release RXDMA\n");\r\nrtw_write32(padapter, REG_RXPKT_NUM, (rtw_read32(padapter, REG_RXPKT_NUM)&(~RW_RELEASE_EN)));\r\n}\r\niv_low = rtw_read32(padapter, REG_TXPKTBUF_IV_LOW);\r\niv_low &= 0xffff;\r\niv_high = rtw_read32(padapter, REG_TXPKTBUF_IV_HIGH);\r\npwrctl->wowlan_fw_iv = iv_high << 16 | iv_low;\r\nDBG_871X_LEVEL(_drv_always_, "fw_iv: 0x%016llx\n", pwrctl->wowlan_fw_iv);\r\nrtw_set_sec_pn(padapter);\r\nif (\r\npsecuritypriv->binstallKCK_KEK == true &&\r\npsecuritypriv->dot11PrivacyAlgrthm == _AES_\r\n) {\r\nu8 gtk_keyindex = 0;\r\nu8 get_key[16];\r\ngtk_keyindex = rtw_read8(padapter, 0x48c);\r\nif (gtk_keyindex < 4) {\r\npsecuritypriv->dot118021XGrpKeyid = gtk_keyindex;\r\nread_cam(padapter, gtk_keyindex, get_key);\r\nmemcpy(psecuritypriv->dot118021XGrpKey[psecuritypriv->dot118021XGrpKeyid].skey, get_key, 16);\r\nDBG_871X_LEVEL(\r\n_drv_always_,\r\n"GTK (%d) = 0x%08x, 0x%08x, 0x%08x, 0x%08x\n",\r\ngtk_keyindex,\r\npsecuritypriv->dot118021XGrpKey[psecuritypriv->dot118021XGrpKeyid].lkey[0],\r\npsecuritypriv->dot118021XGrpKey[psecuritypriv->dot118021XGrpKeyid].lkey[1],\r\npsecuritypriv->dot118021XGrpKey[psecuritypriv->dot118021XGrpKeyid].lkey[2],\r\npsecuritypriv->dot118021XGrpKey[psecuritypriv->dot118021XGrpKeyid].lkey[3]\r\n);\r\n} else\r\nDBG_871X_LEVEL(_drv_always_, "GTK index =%d\n", gtk_keyindex);\r\n}\r\nDBG_871X_LEVEL(_drv_always_, "Re-download Normal FW!\n");\r\nSetFwRelatedForWoWLAN8723b(padapter, false);\r\n}\r\n#ifdef CONFIG_GPIO_WAKEUP\r\nDBG_871X_LEVEL(_drv_always_, "Set Wake GPIO to high for default.\n");\r\nHalSetOutPutGPIO(padapter, WAKEUP_GPIO_IDX, 1);\r\n#endif\r\nif (\r\n(pwrctl->wowlan_wake_reason != FWDecisionDisconnect) &&\r\n(pwrctl->wowlan_wake_reason != Rx_Pairwisekey) &&\r\n(pwrctl->wowlan_wake_reason != Rx_DisAssoc) &&\r\n(pwrctl->wowlan_wake_reason != Rx_DeAuth)\r\n) {\r\nrtl8723b_set_FwJoinBssRpt_cmd(padapter, RT_MEDIA_CONNECT);\r\nif (psta != NULL)\r\nrtl8723b_set_FwMediaStatusRpt_cmd(padapter, RT_MEDIA_CONNECT, psta->mac_id);\r\n}\r\n#ifdef CONFIG_PNO_SUPPORT\r\nrtw_write8(padapter, 0x1b8, 0);\r\nDBG_871X("reset 0x1b8: %d\n", rtw_read8(padapter, 0x1b8));\r\nrtw_write8(padapter, 0x1b9, 0);\r\nDBG_871X("reset 0x1b9: %d\n", rtw_read8(padapter, 0x1b9));\r\nrtw_write8(padapter, REG_PNO_STATUS, 0);\r\nDBG_871X("reset REG_PNO_STATUS: %d\n", rtw_read8(padapter, REG_PNO_STATUS));\r\n#endif\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_AP_WOWLAN\r\ncase HW_VAR_AP_WOWLAN:\r\n{\r\npoidparam = (struct wowlan_ioctl_param *)val;\r\nswitch (poidparam->subcode) {\r\ncase WOWLAN_AP_ENABLE:\r\nDBG_871X("%s, WOWLAN_AP_ENABLE\n", __func__);\r\nDBG_871X_LEVEL(_drv_always_, "Re-download WoWlan FW!\n");\r\nSetFwRelatedForWoWLAN8723b(padapter, true);\r\nDBG_871X_LEVEL(_drv_always_, "Pause DMA\n");\r\nrtw_write32(padapter, REG_RXPKT_NUM,\r\n(rtw_read32(padapter, REG_RXPKT_NUM)|RW_RELEASE_EN));\r\ndo {\r\nif ((rtw_read32(padapter, REG_RXPKT_NUM)&RXDMA_IDLE)) {\r\nDBG_871X_LEVEL(_drv_always_, "RX_DMA_IDLE is true\n");\r\nbreak;\r\n} else {\r\nres = sdio_local_read(padapter, SDIO_REG_RX0_REQ_LEN, 4, (u8 *)&tmp);\r\nlen = le16_to_cpu(tmp);\r\nDBG_871X_LEVEL(_drv_always_, "RX len:%d\n", len);\r\nif (len > 0)\r\nres = RecvOnePkt(padapter, len);\r\nelse\r\nDBG_871X_LEVEL(_drv_always_, "read length fail %d\n", len);\r\nDBG_871X_LEVEL(_drv_always_, "RecvOnePkt Result: %d\n", res);\r\n}\r\n} while (trycnt--);\r\nif (trycnt == 0)\r\nDBG_871X_LEVEL(_drv_always_, "Stop RX DMA failed......\n");\r\nDBG_871X_LEVEL(_drv_always_, "Clear IMR and ISR\n");\r\ntmp = 0;\r\nsdio_local_write(padapter, SDIO_REG_HIMR_ON, 4, (u8 *)&tmp);\r\nsdio_local_write(padapter, SDIO_REG_HIMR, 4, (u8 *)&tmp);\r\nsdio_local_read(padapter, SDIO_REG_HISR, 4, (u8 *)&tmp);\r\nsdio_local_write(padapter, SDIO_REG_HISR, 4, (u8 *)&tmp);\r\nDBG_871X_LEVEL(_drv_always_, "Enable only CPWM2\n");\r\nsdio_local_read(padapter, SDIO_REG_HIMR, 4, (u8 *)&tmp);\r\nDBG_871X("DisableInterruptButCpwm28723BSdio(): Read SDIO_REG_HIMR: 0x%08x\n", tmp);\r\nhimr = cpu_to_le32(SDIO_HIMR_DISABLED)|SDIO_HIMR_CPWM2_MSK;\r\nsdio_local_write(padapter, SDIO_REG_HIMR, 4, (u8 *)&himr);\r\nsdio_local_read(padapter, SDIO_REG_HIMR, 4, (u8 *)&tmp);\r\nDBG_871X("DisableInterruptButCpwm28723BSdio(): Read again SDIO_REG_HIMR: 0x%08x\n", tmp);\r\nDBG_871X_LEVEL(_drv_always_, "Set Enable AP WOWLan cmd\n");\r\nrtl8723b_set_ap_wowlan_cmd(padapter, 1);\r\nmsleep(10);\r\nrtw_write8(padapter, REG_WOWLAN_WAKE_REASON, 0);\r\nbreak;\r\ncase WOWLAN_AP_DISABLE:\r\nDBG_871X("%s, WOWLAN_AP_DISABLE\n", __func__);\r\npwrctl->wowlan_wake_reason =\r\nrtw_read8(padapter, REG_WOWLAN_WAKE_REASON);\r\nDBG_871X_LEVEL(_drv_always_, "wakeup_reason: 0x%02x\n",\r\npwrctl->wowlan_wake_reason);\r\nDBG_871X_LEVEL(_drv_always_, "Set Disable WOWLan cmd\n");\r\nrtl8723b_set_ap_wowlan_cmd(padapter, 0);\r\nmsleep(2);\r\nDBG_871X_LEVEL(_drv_always_, "Release RXDMA\n");\r\nrtw_write32(padapter, REG_RXPKT_NUM,\r\n(rtw_read32(padapter, REG_RXPKT_NUM) & (~RW_RELEASE_EN)));\r\nSetFwRelatedForWoWLAN8723b(padapter, false);\r\n#ifdef CONFIG_GPIO_WAKEUP\r\nDBG_871X_LEVEL(_drv_always_, "Set Wake GPIO to high for default.\n");\r\nHalSetOutPutGPIO(padapter, WAKEUP_GPIO_IDX, 1);\r\n#endif\r\nrtl8723b_set_FwJoinBssRpt_cmd(padapter, RT_MEDIA_CONNECT);\r\nissue_beacon(padapter, 0);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nbreak;\r\n#endif\r\ncase HW_VAR_DM_IN_LPS:\r\nrtl8723b_hal_dm_in_lps(padapter);\r\nbreak;\r\ndefault:\r\nSetHwReg8723B(padapter, variable, val);\r\nbreak;\r\n}\r\n}\r\nstatic void GetHwReg8723BS(struct adapter *padapter, u8 variable, u8 *val)\r\n{\r\nswitch (variable) {\r\ncase HW_VAR_CPWM:\r\n*val = rtw_read8(padapter, SDIO_LOCAL_BASE|SDIO_REG_HCPWM1_8723B);\r\nbreak;\r\ncase HW_VAR_FW_PS_STATE:\r\n{\r\n*((u16 *)val) = rtw_read16(padapter, 0x88);\r\n}\r\nbreak;\r\ndefault:\r\nGetHwReg8723B(padapter, variable, val);\r\nbreak;\r\n}\r\n}\r\nstatic void SetHwRegWithBuf8723B(struct adapter *padapter, u8 variable, u8 *pbuf, int len)\r\n{\r\nswitch (variable) {\r\ncase HW_VAR_C2H_HANDLE:\r\nC2HPacketHandler_8723B(padapter, pbuf, len);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic u8 GetHalDefVar8723BSDIO(\r\nstruct adapter *Adapter, enum HAL_DEF_VARIABLE eVariable, void *pValue\r\n)\r\n{\r\nu8 bResult = _SUCCESS;\r\nswitch (eVariable) {\r\ncase HAL_DEF_IS_SUPPORT_ANT_DIV:\r\nbreak;\r\ncase HAL_DEF_CURRENT_ANTENNA:\r\nbreak;\r\ncase HW_VAR_MAX_RX_AMPDU_FACTOR:\r\n*(u32 *)pValue = MAX_AMPDU_FACTOR_16K;\r\nbreak;\r\ndefault:\r\nbResult = GetHalDefVar8723B(Adapter, eVariable, pValue);\r\nbreak;\r\n}\r\nreturn bResult;\r\n}\r\nstatic u8 SetHalDefVar8723BSDIO(struct adapter *Adapter,\r\nenum HAL_DEF_VARIABLE eVariable, void *pValue)\r\n{\r\nreturn SetHalDefVar8723B(Adapter, eVariable, pValue);\r\n}\r\nvoid rtl8723bs_set_hal_ops(struct adapter *padapter)\r\n{\r\nstruct hal_ops *pHalFunc = &padapter->HalFunc;\r\nrtl8723b_set_hal_ops(pHalFunc);\r\npHalFunc->hal_init = &rtl8723bs_hal_init;\r\npHalFunc->hal_deinit = &rtl8723bs_hal_deinit;\r\npHalFunc->inirp_init = &rtl8723bs_inirp_init;\r\npHalFunc->inirp_deinit = &rtl8723bs_inirp_deinit;\r\npHalFunc->init_xmit_priv = &rtl8723bs_init_xmit_priv;\r\npHalFunc->free_xmit_priv = &rtl8723bs_free_xmit_priv;\r\npHalFunc->init_recv_priv = &rtl8723bs_init_recv_priv;\r\npHalFunc->free_recv_priv = &rtl8723bs_free_recv_priv;\r\npHalFunc->init_default_value = &rtl8723bs_init_default_value;\r\npHalFunc->intf_chip_configure = &rtl8723bs_interface_configure;\r\npHalFunc->read_adapter_info = &ReadAdapterInfo8723BS;\r\npHalFunc->enable_interrupt = &EnableInterrupt8723BSdio;\r\npHalFunc->disable_interrupt = &DisableInterrupt8723BSdio;\r\npHalFunc->check_ips_status = &CheckIPSStatus;\r\n#ifdef CONFIG_WOWLAN\r\npHalFunc->clear_interrupt = &ClearInterrupt8723BSdio;\r\n#endif\r\npHalFunc->SetHwRegHandler = &SetHwReg8723BS;\r\npHalFunc->GetHwRegHandler = &GetHwReg8723BS;\r\npHalFunc->SetHwRegHandlerWithBuf = &SetHwRegWithBuf8723B;\r\npHalFunc->GetHalDefVarHandler = &GetHalDefVar8723BSDIO;\r\npHalFunc->SetHalDefVarHandler = &SetHalDefVar8723BSDIO;\r\npHalFunc->hal_xmit = &rtl8723bs_hal_xmit;\r\npHalFunc->mgnt_xmit = &rtl8723bs_mgnt_xmit;\r\npHalFunc->hal_xmitframe_enqueue = &rtl8723bs_hal_xmitframe_enqueue;\r\n#if defined(CONFIG_CHECK_BT_HANG)\r\npHalFunc->hal_init_checkbthang_workqueue = &rtl8723bs_init_checkbthang_workqueue;\r\npHalFunc->hal_free_checkbthang_workqueue = &rtl8723bs_free_checkbthang_workqueue;\r\npHalFunc->hal_cancle_checkbthang_workqueue = &rtl8723bs_cancle_checkbthang_workqueue;\r\npHalFunc->hal_checke_bt_hang = &rtl8723bs_hal_check_bt_hang;\r\n#endif\r\n}
