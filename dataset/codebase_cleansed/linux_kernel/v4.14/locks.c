void __spin_yield(arch_spinlock_t *lock)\r\n{\r\nunsigned int lock_value, holder_cpu, yield_count;\r\nlock_value = lock->slock;\r\nif (lock_value == 0)\r\nreturn;\r\nholder_cpu = lock_value & 0xffff;\r\nBUG_ON(holder_cpu >= NR_CPUS);\r\nyield_count = be32_to_cpu(lppaca_of(holder_cpu).yield_count);\r\nif ((yield_count & 1) == 0)\r\nreturn;\r\nrmb();\r\nif (lock->slock != lock_value)\r\nreturn;\r\nplpar_hcall_norets(H_CONFER,\r\nget_hard_smp_processor_id(holder_cpu), yield_count);\r\n}\r\nvoid __rw_yield(arch_rwlock_t *rw)\r\n{\r\nint lock_value;\r\nunsigned int holder_cpu, yield_count;\r\nlock_value = rw->lock;\r\nif (lock_value >= 0)\r\nreturn;\r\nholder_cpu = lock_value & 0xffff;\r\nBUG_ON(holder_cpu >= NR_CPUS);\r\nyield_count = be32_to_cpu(lppaca_of(holder_cpu).yield_count);\r\nif ((yield_count & 1) == 0)\r\nreturn;\r\nrmb();\r\nif (rw->lock != lock_value)\r\nreturn;\r\nplpar_hcall_norets(H_CONFER,\r\nget_hard_smp_processor_id(holder_cpu), yield_count);\r\n}
