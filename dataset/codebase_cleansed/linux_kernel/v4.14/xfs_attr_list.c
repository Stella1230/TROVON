STATIC int\r\nxfs_attr_shortform_compare(const void *a, const void *b)\r\n{\r\nxfs_attr_sf_sort_t *sa, *sb;\r\nsa = (xfs_attr_sf_sort_t *)a;\r\nsb = (xfs_attr_sf_sort_t *)b;\r\nif (sa->hash < sb->hash) {\r\nreturn -1;\r\n} else if (sa->hash > sb->hash) {\r\nreturn 1;\r\n} else {\r\nreturn sa->entno - sb->entno;\r\n}\r\n}\r\nstatic int\r\nxfs_attr_shortform_list(xfs_attr_list_context_t *context)\r\n{\r\nattrlist_cursor_kern_t *cursor;\r\nxfs_attr_sf_sort_t *sbuf, *sbp;\r\nxfs_attr_shortform_t *sf;\r\nxfs_attr_sf_entry_t *sfe;\r\nxfs_inode_t *dp;\r\nint sbsize, nsbuf, count, i;\r\nASSERT(context != NULL);\r\ndp = context->dp;\r\nASSERT(dp != NULL);\r\nASSERT(dp->i_afp != NULL);\r\nsf = (xfs_attr_shortform_t *)dp->i_afp->if_u1.if_data;\r\nASSERT(sf != NULL);\r\nif (!sf->hdr.count)\r\nreturn 0;\r\ncursor = context->cursor;\r\nASSERT(cursor != NULL);\r\ntrace_xfs_attr_list_sf(context);\r\nif (context->bufsize == 0 ||\r\n(XFS_ISRESET_CURSOR(cursor) &&\r\n(dp->i_afp->if_bytes + sf->hdr.count * 16) < context->bufsize)) {\r\nfor (i = 0, sfe = &sf->list[0]; i < sf->hdr.count; i++) {\r\ncontext->put_listent(context,\r\nsfe->flags,\r\nsfe->nameval,\r\n(int)sfe->namelen,\r\n(int)sfe->valuelen);\r\nif (context->seen_enough)\r\nbreak;\r\nsfe = XFS_ATTR_SF_NEXTENTRY(sfe);\r\n}\r\ntrace_xfs_attr_list_sf_all(context);\r\nreturn 0;\r\n}\r\nif (context->bufsize == 0)\r\nreturn 0;\r\nsbsize = sf->hdr.count * sizeof(*sbuf);\r\nsbp = sbuf = kmem_alloc(sbsize, KM_SLEEP | KM_NOFS);\r\nnsbuf = 0;\r\nfor (i = 0, sfe = &sf->list[0]; i < sf->hdr.count; i++) {\r\nif (unlikely(\r\n((char *)sfe < (char *)sf) ||\r\n((char *)sfe >= ((char *)sf + dp->i_afp->if_bytes)))) {\r\nXFS_CORRUPTION_ERROR("xfs_attr_shortform_list",\r\nXFS_ERRLEVEL_LOW,\r\ncontext->dp->i_mount, sfe);\r\nkmem_free(sbuf);\r\nreturn -EFSCORRUPTED;\r\n}\r\nsbp->entno = i;\r\nsbp->hash = xfs_da_hashname(sfe->nameval, sfe->namelen);\r\nsbp->name = sfe->nameval;\r\nsbp->namelen = sfe->namelen;\r\nsbp->valuelen = sfe->valuelen;\r\nsbp->flags = sfe->flags;\r\nsfe = XFS_ATTR_SF_NEXTENTRY(sfe);\r\nsbp++;\r\nnsbuf++;\r\n}\r\nxfs_sort(sbuf, nsbuf, sizeof(*sbuf), xfs_attr_shortform_compare);\r\ncount = 0;\r\ncursor->initted = 1;\r\ncursor->blkno = 0;\r\nfor (sbp = sbuf, i = 0; i < nsbuf; i++, sbp++) {\r\nif (sbp->hash == cursor->hashval) {\r\nif (cursor->offset == count) {\r\nbreak;\r\n}\r\ncount++;\r\n} else if (sbp->hash > cursor->hashval) {\r\nbreak;\r\n}\r\n}\r\nif (i == nsbuf) {\r\nkmem_free(sbuf);\r\nreturn 0;\r\n}\r\nfor ( ; i < nsbuf; i++, sbp++) {\r\nif (cursor->hashval != sbp->hash) {\r\ncursor->hashval = sbp->hash;\r\ncursor->offset = 0;\r\n}\r\ncontext->put_listent(context,\r\nsbp->flags,\r\nsbp->name,\r\nsbp->namelen,\r\nsbp->valuelen);\r\nif (context->seen_enough)\r\nbreak;\r\ncursor->offset++;\r\n}\r\nkmem_free(sbuf);\r\nreturn 0;\r\n}\r\nSTATIC int\r\nxfs_attr_node_list(xfs_attr_list_context_t *context)\r\n{\r\nattrlist_cursor_kern_t *cursor;\r\nxfs_attr_leafblock_t *leaf;\r\nxfs_da_intnode_t *node;\r\nstruct xfs_attr3_icleaf_hdr leafhdr;\r\nstruct xfs_da3_icnode_hdr nodehdr;\r\nstruct xfs_da_node_entry *btree;\r\nint error, i;\r\nstruct xfs_buf *bp;\r\nstruct xfs_inode *dp = context->dp;\r\nstruct xfs_mount *mp = dp->i_mount;\r\ntrace_xfs_attr_node_list(context);\r\ncursor = context->cursor;\r\ncursor->initted = 1;\r\nbp = NULL;\r\nif (cursor->blkno > 0) {\r\nerror = xfs_da3_node_read(context->tp, dp, cursor->blkno, -1,\r\n&bp, XFS_ATTR_FORK);\r\nif ((error != 0) && (error != -EFSCORRUPTED))\r\nreturn error;\r\nif (bp) {\r\nstruct xfs_attr_leaf_entry *entries;\r\nnode = bp->b_addr;\r\nswitch (be16_to_cpu(node->hdr.info.magic)) {\r\ncase XFS_DA_NODE_MAGIC:\r\ncase XFS_DA3_NODE_MAGIC:\r\ntrace_xfs_attr_list_wrong_blk(context);\r\nxfs_trans_brelse(context->tp, bp);\r\nbp = NULL;\r\nbreak;\r\ncase XFS_ATTR_LEAF_MAGIC:\r\ncase XFS_ATTR3_LEAF_MAGIC:\r\nleaf = bp->b_addr;\r\nxfs_attr3_leaf_hdr_from_disk(mp->m_attr_geo,\r\n&leafhdr, leaf);\r\nentries = xfs_attr3_leaf_entryp(leaf);\r\nif (cursor->hashval > be32_to_cpu(\r\nentries[leafhdr.count - 1].hashval)) {\r\ntrace_xfs_attr_list_wrong_blk(context);\r\nxfs_trans_brelse(context->tp, bp);\r\nbp = NULL;\r\n} else if (cursor->hashval <= be32_to_cpu(\r\nentries[0].hashval)) {\r\ntrace_xfs_attr_list_wrong_blk(context);\r\nxfs_trans_brelse(context->tp, bp);\r\nbp = NULL;\r\n}\r\nbreak;\r\ndefault:\r\ntrace_xfs_attr_list_wrong_blk(context);\r\nxfs_trans_brelse(context->tp, bp);\r\nbp = NULL;\r\n}\r\n}\r\n}\r\nif (bp == NULL) {\r\ncursor->blkno = 0;\r\nfor (;;) {\r\nuint16_t magic;\r\nerror = xfs_da3_node_read(context->tp, dp,\r\ncursor->blkno, -1, &bp,\r\nXFS_ATTR_FORK);\r\nif (error)\r\nreturn error;\r\nnode = bp->b_addr;\r\nmagic = be16_to_cpu(node->hdr.info.magic);\r\nif (magic == XFS_ATTR_LEAF_MAGIC ||\r\nmagic == XFS_ATTR3_LEAF_MAGIC)\r\nbreak;\r\nif (magic != XFS_DA_NODE_MAGIC &&\r\nmagic != XFS_DA3_NODE_MAGIC) {\r\nXFS_CORRUPTION_ERROR("xfs_attr_node_list(3)",\r\nXFS_ERRLEVEL_LOW,\r\ncontext->dp->i_mount,\r\nnode);\r\nxfs_trans_brelse(context->tp, bp);\r\nreturn -EFSCORRUPTED;\r\n}\r\ndp->d_ops->node_hdr_from_disk(&nodehdr, node);\r\nbtree = dp->d_ops->node_tree_p(node);\r\nfor (i = 0; i < nodehdr.count; btree++, i++) {\r\nif (cursor->hashval\r\n<= be32_to_cpu(btree->hashval)) {\r\ncursor->blkno = be32_to_cpu(btree->before);\r\ntrace_xfs_attr_list_node_descend(context,\r\nbtree);\r\nbreak;\r\n}\r\n}\r\nif (i == nodehdr.count) {\r\nxfs_trans_brelse(context->tp, bp);\r\nreturn 0;\r\n}\r\nxfs_trans_brelse(context->tp, bp);\r\n}\r\n}\r\nASSERT(bp != NULL);\r\nfor (;;) {\r\nleaf = bp->b_addr;\r\nxfs_attr3_leaf_list_int(bp, context);\r\nxfs_attr3_leaf_hdr_from_disk(mp->m_attr_geo, &leafhdr, leaf);\r\nif (context->seen_enough || leafhdr.forw == 0)\r\nbreak;\r\ncursor->blkno = leafhdr.forw;\r\nxfs_trans_brelse(context->tp, bp);\r\nerror = xfs_attr3_leaf_read(context->tp, dp, cursor->blkno, -1, &bp);\r\nif (error)\r\nreturn error;\r\n}\r\nxfs_trans_brelse(context->tp, bp);\r\nreturn 0;\r\n}\r\nvoid\r\nxfs_attr3_leaf_list_int(\r\nstruct xfs_buf *bp,\r\nstruct xfs_attr_list_context *context)\r\n{\r\nstruct attrlist_cursor_kern *cursor;\r\nstruct xfs_attr_leafblock *leaf;\r\nstruct xfs_attr3_icleaf_hdr ichdr;\r\nstruct xfs_attr_leaf_entry *entries;\r\nstruct xfs_attr_leaf_entry *entry;\r\nint i;\r\nstruct xfs_mount *mp = context->dp->i_mount;\r\ntrace_xfs_attr_list_leaf(context);\r\nleaf = bp->b_addr;\r\nxfs_attr3_leaf_hdr_from_disk(mp->m_attr_geo, &ichdr, leaf);\r\nentries = xfs_attr3_leaf_entryp(leaf);\r\ncursor = context->cursor;\r\ncursor->initted = 1;\r\nif (context->resynch) {\r\nentry = &entries[0];\r\nfor (i = 0; i < ichdr.count; entry++, i++) {\r\nif (be32_to_cpu(entry->hashval) == cursor->hashval) {\r\nif (cursor->offset == context->dupcnt) {\r\ncontext->dupcnt = 0;\r\nbreak;\r\n}\r\ncontext->dupcnt++;\r\n} else if (be32_to_cpu(entry->hashval) >\r\ncursor->hashval) {\r\ncontext->dupcnt = 0;\r\nbreak;\r\n}\r\n}\r\nif (i == ichdr.count) {\r\ntrace_xfs_attr_list_notfound(context);\r\nreturn;\r\n}\r\n} else {\r\nentry = &entries[0];\r\ni = 0;\r\n}\r\ncontext->resynch = 0;\r\nfor (; i < ichdr.count; entry++, i++) {\r\nchar *name;\r\nint namelen, valuelen;\r\nif (be32_to_cpu(entry->hashval) != cursor->hashval) {\r\ncursor->hashval = be32_to_cpu(entry->hashval);\r\ncursor->offset = 0;\r\n}\r\nif (entry->flags & XFS_ATTR_INCOMPLETE)\r\ncontinue;\r\nif (entry->flags & XFS_ATTR_LOCAL) {\r\nxfs_attr_leaf_name_local_t *name_loc;\r\nname_loc = xfs_attr3_leaf_name_local(leaf, i);\r\nname = name_loc->nameval;\r\nnamelen = name_loc->namelen;\r\nvaluelen = be16_to_cpu(name_loc->valuelen);\r\n} else {\r\nxfs_attr_leaf_name_remote_t *name_rmt;\r\nname_rmt = xfs_attr3_leaf_name_remote(leaf, i);\r\nname = name_rmt->name;\r\nnamelen = name_rmt->namelen;\r\nvaluelen = be32_to_cpu(name_rmt->valuelen);\r\n}\r\ncontext->put_listent(context, entry->flags,\r\nname, namelen, valuelen);\r\nif (context->seen_enough)\r\nbreak;\r\ncursor->offset++;\r\n}\r\ntrace_xfs_attr_list_leaf_end(context);\r\nreturn;\r\n}\r\nSTATIC int\r\nxfs_attr_leaf_list(xfs_attr_list_context_t *context)\r\n{\r\nint error;\r\nstruct xfs_buf *bp;\r\ntrace_xfs_attr_leaf_list(context);\r\ncontext->cursor->blkno = 0;\r\nerror = xfs_attr3_leaf_read(context->tp, context->dp, 0, -1, &bp);\r\nif (error)\r\nreturn error;\r\nxfs_attr3_leaf_list_int(bp, context);\r\nxfs_trans_brelse(context->tp, bp);\r\nreturn 0;\r\n}\r\nint\r\nxfs_attr_list_int_ilocked(\r\nstruct xfs_attr_list_context *context)\r\n{\r\nstruct xfs_inode *dp = context->dp;\r\nASSERT(xfs_isilocked(dp, XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\r\nif (!xfs_inode_hasattr(dp))\r\nreturn 0;\r\nelse if (dp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL)\r\nreturn xfs_attr_shortform_list(context);\r\nelse if (xfs_bmap_one_block(dp, XFS_ATTR_FORK))\r\nreturn xfs_attr_leaf_list(context);\r\nreturn xfs_attr_node_list(context);\r\n}\r\nint\r\nxfs_attr_list_int(\r\nxfs_attr_list_context_t *context)\r\n{\r\nint error;\r\nxfs_inode_t *dp = context->dp;\r\nuint lock_mode;\r\nXFS_STATS_INC(dp->i_mount, xs_attr_list);\r\nif (XFS_FORCED_SHUTDOWN(dp->i_mount))\r\nreturn -EIO;\r\nlock_mode = xfs_ilock_attr_map_shared(dp);\r\nerror = xfs_attr_list_int_ilocked(context);\r\nxfs_iunlock(dp, lock_mode);\r\nreturn error;\r\n}\r\nSTATIC void\r\nxfs_attr_put_listent(\r\nxfs_attr_list_context_t *context,\r\nint flags,\r\nunsigned char *name,\r\nint namelen,\r\nint valuelen)\r\n{\r\nstruct attrlist *alist = (struct attrlist *)context->alist;\r\nattrlist_ent_t *aep;\r\nint arraytop;\r\nASSERT(!(context->flags & ATTR_KERNOVAL));\r\nASSERT(context->count >= 0);\r\nASSERT(context->count < (ATTR_MAX_VALUELEN/8));\r\nASSERT(context->firstu >= sizeof(*alist));\r\nASSERT(context->firstu <= context->bufsize);\r\nif (((context->flags & ATTR_SECURE) == 0) !=\r\n((flags & XFS_ATTR_SECURE) == 0))\r\nreturn;\r\nif (((context->flags & ATTR_ROOT) == 0) !=\r\n((flags & XFS_ATTR_ROOT) == 0))\r\nreturn;\r\narraytop = sizeof(*alist) +\r\ncontext->count * sizeof(alist->al_offset[0]);\r\ncontext->firstu -= ATTR_ENTSIZE(namelen);\r\nif (context->firstu < arraytop) {\r\ntrace_xfs_attr_list_full(context);\r\nalist->al_more = 1;\r\ncontext->seen_enough = 1;\r\nreturn;\r\n}\r\naep = (attrlist_ent_t *)&context->alist[context->firstu];\r\naep->a_valuelen = valuelen;\r\nmemcpy(aep->a_name, name, namelen);\r\naep->a_name[namelen] = 0;\r\nalist->al_offset[context->count++] = context->firstu;\r\nalist->al_count = context->count;\r\ntrace_xfs_attr_list_add(context);\r\nreturn;\r\n}\r\nint\r\nxfs_attr_list(\r\nxfs_inode_t *dp,\r\nchar *buffer,\r\nint bufsize,\r\nint flags,\r\nattrlist_cursor_kern_t *cursor)\r\n{\r\nxfs_attr_list_context_t context;\r\nstruct attrlist *alist;\r\nint error;\r\nif (cursor->pad1 || cursor->pad2)\r\nreturn -EINVAL;\r\nif ((cursor->initted == 0) &&\r\n(cursor->hashval || cursor->blkno || cursor->offset))\r\nreturn -EINVAL;\r\nif (((long)buffer) & (sizeof(int)-1))\r\nreturn -EFAULT;\r\nif (flags & ATTR_KERNOVAL)\r\nbufsize = 0;\r\nmemset(&context, 0, sizeof(context));\r\ncontext.dp = dp;\r\ncontext.cursor = cursor;\r\ncontext.resynch = 1;\r\ncontext.flags = flags;\r\ncontext.alist = buffer;\r\ncontext.bufsize = (bufsize & ~(sizeof(int)-1));\r\ncontext.firstu = context.bufsize;\r\ncontext.put_listent = xfs_attr_put_listent;\r\nalist = (struct attrlist *)context.alist;\r\nalist->al_count = 0;\r\nalist->al_more = 0;\r\nalist->al_offset[0] = context.bufsize;\r\nerror = xfs_attr_list_int(&context);\r\nASSERT(error <= 0);\r\nreturn error;\r\n}
