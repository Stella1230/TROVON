static inline struct atmel_hlcdc_pwm *to_atmel_hlcdc_pwm(struct pwm_chip *chip)\r\n{\r\nreturn container_of(chip, struct atmel_hlcdc_pwm, chip);\r\n}\r\nstatic int atmel_hlcdc_pwm_apply(struct pwm_chip *c, struct pwm_device *pwm,\r\nstruct pwm_state *state)\r\n{\r\nstruct atmel_hlcdc_pwm *chip = to_atmel_hlcdc_pwm(c);\r\nstruct atmel_hlcdc *hlcdc = chip->hlcdc;\r\nunsigned int status;\r\nint ret;\r\nif (state->enabled) {\r\nstruct clk *new_clk = hlcdc->slow_clk;\r\nu64 pwmcval = state->duty_cycle * 256;\r\nunsigned long clk_freq;\r\nu64 clk_period_ns;\r\nu32 pwmcfg;\r\nint pres;\r\nif (!chip->errata || !chip->errata->slow_clk_erratum) {\r\nclk_freq = clk_get_rate(new_clk);\r\nif (!clk_freq)\r\nreturn -EINVAL;\r\nclk_period_ns = (u64)NSEC_PER_SEC * 256;\r\ndo_div(clk_period_ns, clk_freq);\r\n}\r\nif ((chip->errata && chip->errata->slow_clk_erratum) ||\r\nclk_period_ns > state->period) {\r\nnew_clk = hlcdc->sys_clk;\r\nclk_freq = clk_get_rate(new_clk);\r\nif (!clk_freq)\r\nreturn -EINVAL;\r\nclk_period_ns = (u64)NSEC_PER_SEC * 256;\r\ndo_div(clk_period_ns, clk_freq);\r\n}\r\nfor (pres = 0; pres <= ATMEL_HLCDC_PWMPS_MAX; pres++) {\r\nif (!pres && chip->errata &&\r\nchip->errata->div1_clk_erratum)\r\ncontinue;\r\nif ((clk_period_ns << pres) >= state->period)\r\nbreak;\r\n}\r\nif (pres > ATMEL_HLCDC_PWMPS_MAX)\r\nreturn -EINVAL;\r\npwmcfg = ATMEL_HLCDC_PWMPS(pres);\r\nif (new_clk != chip->cur_clk) {\r\nu32 gencfg = 0;\r\nint ret;\r\nret = clk_prepare_enable(new_clk);\r\nif (ret)\r\nreturn ret;\r\nclk_disable_unprepare(chip->cur_clk);\r\nchip->cur_clk = new_clk;\r\nif (new_clk == hlcdc->sys_clk)\r\ngencfg = ATMEL_HLCDC_CLKPWMSEL;\r\nret = regmap_update_bits(hlcdc->regmap,\r\nATMEL_HLCDC_CFG(0),\r\nATMEL_HLCDC_CLKPWMSEL,\r\ngencfg);\r\nif (ret)\r\nreturn ret;\r\n}\r\ndo_div(pwmcval, state->period);\r\nif (pwmcval > 255)\r\npwmcval = 255;\r\npwmcfg |= ATMEL_HLCDC_PWMCVAL(pwmcval);\r\nif (state->polarity == PWM_POLARITY_NORMAL)\r\npwmcfg |= ATMEL_HLCDC_PWMPOL;\r\nret = regmap_update_bits(hlcdc->regmap, ATMEL_HLCDC_CFG(6),\r\nATMEL_HLCDC_PWMCVAL_MASK |\r\nATMEL_HLCDC_PWMPS_MASK |\r\nATMEL_HLCDC_PWMPOL,\r\npwmcfg);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_write(hlcdc->regmap, ATMEL_HLCDC_EN,\r\nATMEL_HLCDC_PWM);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_read_poll_timeout(hlcdc->regmap, ATMEL_HLCDC_SR,\r\nstatus,\r\nstatus & ATMEL_HLCDC_PWM,\r\n10, 0);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\nret = regmap_write(hlcdc->regmap, ATMEL_HLCDC_DIS,\r\nATMEL_HLCDC_PWM);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_read_poll_timeout(hlcdc->regmap, ATMEL_HLCDC_SR,\r\nstatus,\r\n!(status & ATMEL_HLCDC_PWM),\r\n10, 0);\r\nif (ret)\r\nreturn ret;\r\nclk_disable_unprepare(chip->cur_clk);\r\nchip->cur_clk = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int atmel_hlcdc_pwm_suspend(struct device *dev)\r\n{\r\nstruct atmel_hlcdc_pwm *chip = dev_get_drvdata(dev);\r\nif (pwm_is_enabled(&chip->chip.pwms[0]))\r\nclk_disable_unprepare(chip->hlcdc->periph_clk);\r\nreturn 0;\r\n}\r\nstatic int atmel_hlcdc_pwm_resume(struct device *dev)\r\n{\r\nstruct atmel_hlcdc_pwm *chip = dev_get_drvdata(dev);\r\nstruct pwm_state state;\r\nint ret;\r\npwm_get_state(&chip->chip.pwms[0], &state);\r\nif (!state.enabled) {\r\nret = clk_prepare_enable(chip->hlcdc->periph_clk);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn atmel_hlcdc_pwm_apply(&chip->chip, &chip->chip.pwms[0], &state);\r\n}\r\nstatic int atmel_hlcdc_pwm_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *match;\r\nstruct device *dev = &pdev->dev;\r\nstruct atmel_hlcdc_pwm *chip;\r\nstruct atmel_hlcdc *hlcdc;\r\nint ret;\r\nhlcdc = dev_get_drvdata(dev->parent);\r\nchip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\nret = clk_prepare_enable(hlcdc->periph_clk);\r\nif (ret)\r\nreturn ret;\r\nmatch = of_match_node(atmel_hlcdc_dt_ids, dev->parent->of_node);\r\nif (match)\r\nchip->errata = match->data;\r\nchip->hlcdc = hlcdc;\r\nchip->chip.ops = &atmel_hlcdc_pwm_ops;\r\nchip->chip.dev = dev;\r\nchip->chip.base = -1;\r\nchip->chip.npwm = 1;\r\nchip->chip.of_xlate = of_pwm_xlate_with_flags;\r\nchip->chip.of_pwm_n_cells = 3;\r\nret = pwmchip_add_with_polarity(&chip->chip, PWM_POLARITY_INVERSED);\r\nif (ret) {\r\nclk_disable_unprepare(hlcdc->periph_clk);\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, chip);\r\nreturn 0;\r\n}\r\nstatic int atmel_hlcdc_pwm_remove(struct platform_device *pdev)\r\n{\r\nstruct atmel_hlcdc_pwm *chip = platform_get_drvdata(pdev);\r\nint ret;\r\nret = pwmchip_remove(&chip->chip);\r\nif (ret)\r\nreturn ret;\r\nclk_disable_unprepare(chip->hlcdc->periph_clk);\r\nreturn 0;\r\n}
