static void init_mbus_colorimetry(struct v4l2_mbus_framefmt *mbus,\r\nconst struct imx_media_pixfmt *fmt)\r\n{\r\nmbus->colorspace = (fmt->cs == IPUV3_COLORSPACE_RGB) ?\r\nV4L2_COLORSPACE_SRGB : V4L2_COLORSPACE_SMPTE170M;\r\nmbus->xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(mbus->colorspace);\r\nmbus->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(mbus->colorspace);\r\nmbus->quantization =\r\nV4L2_MAP_QUANTIZATION_DEFAULT(fmt->cs == IPUV3_COLORSPACE_RGB,\r\nmbus->colorspace,\r\nmbus->ycbcr_enc);\r\n}\r\nstatic const struct imx_media_pixfmt *find_format(u32 fourcc,\r\nu32 code,\r\nenum codespace_sel cs_sel,\r\nbool allow_non_mbus,\r\nbool allow_bayer)\r\n{\r\nconst struct imx_media_pixfmt *array, *fmt, *ret = NULL;\r\nu32 array_size;\r\nint i, j;\r\nswitch (cs_sel) {\r\ncase CS_SEL_YUV:\r\narray_size = NUM_YUV_FORMATS;\r\narray = yuv_formats;\r\nbreak;\r\ncase CS_SEL_RGB:\r\narray_size = NUM_RGB_FORMATS;\r\narray = rgb_formats;\r\nbreak;\r\ncase CS_SEL_ANY:\r\narray_size = NUM_YUV_FORMATS + NUM_RGB_FORMATS;\r\narray = yuv_formats;\r\nbreak;\r\ndefault:\r\nreturn NULL;\r\n}\r\nfor (i = 0; i < array_size; i++) {\r\nif (cs_sel == CS_SEL_ANY && i >= NUM_YUV_FORMATS)\r\nfmt = &rgb_formats[i - NUM_YUV_FORMATS];\r\nelse\r\nfmt = &array[i];\r\nif ((!allow_non_mbus && fmt->codes[0] == 0) ||\r\n(!allow_bayer && fmt->bayer))\r\ncontinue;\r\nif (fourcc && fmt->fourcc == fourcc) {\r\nret = fmt;\r\ngoto out;\r\n}\r\nfor (j = 0; code && fmt->codes[j]; j++) {\r\nif (code == fmt->codes[j]) {\r\nret = fmt;\r\ngoto out;\r\n}\r\n}\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int enum_format(u32 *fourcc, u32 *code, u32 index,\r\nenum codespace_sel cs_sel,\r\nbool allow_non_mbus,\r\nbool allow_bayer)\r\n{\r\nconst struct imx_media_pixfmt *fmt;\r\nu32 mbus_yuv_sz = NUM_MBUS_YUV_FORMATS;\r\nu32 mbus_rgb_sz = NUM_MBUS_RGB_FORMATS;\r\nu32 yuv_sz = NUM_YUV_FORMATS;\r\nu32 rgb_sz = NUM_RGB_FORMATS;\r\nswitch (cs_sel) {\r\ncase CS_SEL_YUV:\r\nif (index >= yuv_sz ||\r\n(!allow_non_mbus && index >= mbus_yuv_sz))\r\nreturn -EINVAL;\r\nfmt = &yuv_formats[index];\r\nbreak;\r\ncase CS_SEL_RGB:\r\nif (index >= rgb_sz ||\r\n(!allow_non_mbus && index >= mbus_rgb_sz))\r\nreturn -EINVAL;\r\nfmt = &rgb_formats[index];\r\nif (!allow_bayer && fmt->bayer)\r\nreturn -EINVAL;\r\nbreak;\r\ncase CS_SEL_ANY:\r\nif (!allow_non_mbus) {\r\nif (index >= mbus_yuv_sz) {\r\nindex -= mbus_yuv_sz;\r\nif (index >= mbus_rgb_sz)\r\nreturn -EINVAL;\r\nfmt = &rgb_formats[index];\r\nif (!allow_bayer && fmt->bayer)\r\nreturn -EINVAL;\r\n} else {\r\nfmt = &yuv_formats[index];\r\n}\r\n} else {\r\nif (index >= yuv_sz + rgb_sz)\r\nreturn -EINVAL;\r\nif (index >= yuv_sz) {\r\nfmt = &rgb_formats[index - yuv_sz];\r\nif (!allow_bayer && fmt->bayer)\r\nreturn -EINVAL;\r\n} else {\r\nfmt = &yuv_formats[index];\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (fourcc)\r\n*fourcc = fmt->fourcc;\r\nif (code)\r\n*code = fmt->codes[0];\r\nreturn 0;\r\n}\r\nconst struct imx_media_pixfmt *\r\nimx_media_find_format(u32 fourcc, enum codespace_sel cs_sel, bool allow_bayer)\r\n{\r\nreturn find_format(fourcc, 0, cs_sel, true, allow_bayer);\r\n}\r\nint imx_media_enum_format(u32 *fourcc, u32 index, enum codespace_sel cs_sel)\r\n{\r\nreturn enum_format(fourcc, NULL, index, cs_sel, true, false);\r\n}\r\nconst struct imx_media_pixfmt *\r\nimx_media_find_mbus_format(u32 code, enum codespace_sel cs_sel,\r\nbool allow_bayer)\r\n{\r\nreturn find_format(0, code, cs_sel, false, allow_bayer);\r\n}\r\nint imx_media_enum_mbus_format(u32 *code, u32 index, enum codespace_sel cs_sel,\r\nbool allow_bayer)\r\n{\r\nreturn enum_format(NULL, code, index, cs_sel, false, allow_bayer);\r\n}\r\nconst struct imx_media_pixfmt *\r\nimx_media_find_ipu_format(u32 code, enum codespace_sel cs_sel)\r\n{\r\nconst struct imx_media_pixfmt *array, *fmt, *ret = NULL;\r\nu32 array_size;\r\nint i, j;\r\nswitch (cs_sel) {\r\ncase CS_SEL_YUV:\r\narray_size = NUM_IPU_YUV_FORMATS;\r\narray = ipu_yuv_formats;\r\nbreak;\r\ncase CS_SEL_RGB:\r\narray_size = NUM_IPU_RGB_FORMATS;\r\narray = ipu_rgb_formats;\r\nbreak;\r\ncase CS_SEL_ANY:\r\narray_size = NUM_IPU_YUV_FORMATS + NUM_IPU_RGB_FORMATS;\r\narray = ipu_yuv_formats;\r\nbreak;\r\ndefault:\r\nreturn NULL;\r\n}\r\nfor (i = 0; i < array_size; i++) {\r\nif (cs_sel == CS_SEL_ANY && i >= NUM_IPU_YUV_FORMATS)\r\nfmt = &ipu_rgb_formats[i - NUM_IPU_YUV_FORMATS];\r\nelse\r\nfmt = &array[i];\r\nfor (j = 0; code && fmt->codes[j]; j++) {\r\nif (code == fmt->codes[j]) {\r\nret = fmt;\r\ngoto out;\r\n}\r\n}\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nint imx_media_enum_ipu_format(u32 *code, u32 index, enum codespace_sel cs_sel)\r\n{\r\nswitch (cs_sel) {\r\ncase CS_SEL_YUV:\r\nif (index >= NUM_IPU_YUV_FORMATS)\r\nreturn -EINVAL;\r\n*code = ipu_yuv_formats[index].codes[0];\r\nbreak;\r\ncase CS_SEL_RGB:\r\nif (index >= NUM_IPU_RGB_FORMATS)\r\nreturn -EINVAL;\r\n*code = ipu_rgb_formats[index].codes[0];\r\nbreak;\r\ncase CS_SEL_ANY:\r\nif (index >= NUM_IPU_YUV_FORMATS + NUM_IPU_RGB_FORMATS)\r\nreturn -EINVAL;\r\nif (index >= NUM_IPU_YUV_FORMATS) {\r\nindex -= NUM_IPU_YUV_FORMATS;\r\n*code = ipu_rgb_formats[index].codes[0];\r\n} else {\r\n*code = ipu_yuv_formats[index].codes[0];\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint imx_media_init_mbus_fmt(struct v4l2_mbus_framefmt *mbus,\r\nu32 width, u32 height, u32 code, u32 field,\r\nconst struct imx_media_pixfmt **cc)\r\n{\r\nconst struct imx_media_pixfmt *lcc;\r\nmbus->width = width;\r\nmbus->height = height;\r\nmbus->field = field;\r\nif (code == 0)\r\nimx_media_enum_mbus_format(&code, 0, CS_SEL_YUV, false);\r\nlcc = imx_media_find_mbus_format(code, CS_SEL_ANY, false);\r\nif (!lcc) {\r\nlcc = imx_media_find_ipu_format(code, CS_SEL_ANY);\r\nif (!lcc)\r\nreturn -EINVAL;\r\n}\r\nmbus->code = code;\r\ninit_mbus_colorimetry(mbus, lcc);\r\nif (cc)\r\n*cc = lcc;\r\nreturn 0;\r\n}\r\nvoid imx_media_fill_default_mbus_fields(struct v4l2_mbus_framefmt *tryfmt,\r\nstruct v4l2_mbus_framefmt *fmt,\r\nbool ic_route)\r\n{\r\nconst struct imx_media_pixfmt *cc;\r\nbool is_rgb = false;\r\ncc = imx_media_find_mbus_format(tryfmt->code, CS_SEL_ANY, true);\r\nif (!cc)\r\ncc = imx_media_find_ipu_format(tryfmt->code, CS_SEL_ANY);\r\nif (cc && cc->cs != IPUV3_COLORSPACE_YUV)\r\nis_rgb = true;\r\nif (tryfmt->field == V4L2_FIELD_ANY)\r\ntryfmt->field = fmt->field;\r\nif (tryfmt->colorspace == V4L2_COLORSPACE_DEFAULT) {\r\ntryfmt->colorspace = fmt->colorspace;\r\ntryfmt->xfer_func = fmt->xfer_func;\r\ntryfmt->ycbcr_enc = fmt->ycbcr_enc;\r\ntryfmt->quantization = fmt->quantization;\r\n} else {\r\nif (tryfmt->xfer_func == V4L2_XFER_FUNC_DEFAULT) {\r\ntryfmt->xfer_func =\r\nV4L2_MAP_XFER_FUNC_DEFAULT(tryfmt->colorspace);\r\n}\r\nif (tryfmt->ycbcr_enc == V4L2_YCBCR_ENC_DEFAULT) {\r\ntryfmt->ycbcr_enc =\r\nV4L2_MAP_YCBCR_ENC_DEFAULT(tryfmt->colorspace);\r\n}\r\nif (tryfmt->quantization == V4L2_QUANTIZATION_DEFAULT) {\r\ntryfmt->quantization =\r\nV4L2_MAP_QUANTIZATION_DEFAULT(\r\nis_rgb, tryfmt->colorspace,\r\ntryfmt->ycbcr_enc);\r\n}\r\n}\r\nif (ic_route) {\r\ntryfmt->quantization = is_rgb ?\r\nV4L2_QUANTIZATION_FULL_RANGE :\r\nV4L2_QUANTIZATION_LIM_RANGE;\r\ntryfmt->ycbcr_enc = V4L2_YCBCR_ENC_601;\r\n}\r\n}\r\nint imx_media_mbus_fmt_to_pix_fmt(struct v4l2_pix_format *pix,\r\nstruct v4l2_mbus_framefmt *mbus,\r\nconst struct imx_media_pixfmt *cc)\r\n{\r\nu32 stride;\r\nif (!cc) {\r\ncc = imx_media_find_ipu_format(mbus->code, CS_SEL_ANY);\r\nif (!cc)\r\ncc = imx_media_find_mbus_format(mbus->code, CS_SEL_ANY,\r\ntrue);\r\nif (!cc)\r\nreturn -EINVAL;\r\n}\r\nif (cc->ipufmt && cc->cs == IPUV3_COLORSPACE_YUV) {\r\nu32 code;\r\nimx_media_enum_mbus_format(&code, 0, CS_SEL_YUV, false);\r\ncc = imx_media_find_mbus_format(code, CS_SEL_YUV, false);\r\n}\r\nstride = cc->planar ? mbus->width : (mbus->width * cc->bpp) >> 3;\r\npix->width = mbus->width;\r\npix->height = mbus->height;\r\npix->pixelformat = cc->fourcc;\r\npix->colorspace = mbus->colorspace;\r\npix->xfer_func = mbus->xfer_func;\r\npix->ycbcr_enc = mbus->ycbcr_enc;\r\npix->quantization = mbus->quantization;\r\npix->field = mbus->field;\r\npix->bytesperline = stride;\r\npix->sizeimage = (pix->width * pix->height * cc->bpp) >> 3;\r\nreturn 0;\r\n}\r\nint imx_media_mbus_fmt_to_ipu_image(struct ipu_image *image,\r\nstruct v4l2_mbus_framefmt *mbus)\r\n{\r\nint ret;\r\nmemset(image, 0, sizeof(*image));\r\nret = imx_media_mbus_fmt_to_pix_fmt(&image->pix, mbus, NULL);\r\nif (ret)\r\nreturn ret;\r\nimage->rect.width = mbus->width;\r\nimage->rect.height = mbus->height;\r\nreturn 0;\r\n}\r\nint imx_media_ipu_image_to_mbus_fmt(struct v4l2_mbus_framefmt *mbus,\r\nstruct ipu_image *image)\r\n{\r\nconst struct imx_media_pixfmt *fmt;\r\nfmt = imx_media_find_format(image->pix.pixelformat, CS_SEL_ANY, true);\r\nif (!fmt)\r\nreturn -EINVAL;\r\nmemset(mbus, 0, sizeof(*mbus));\r\nmbus->width = image->pix.width;\r\nmbus->height = image->pix.height;\r\nmbus->code = fmt->codes[0];\r\nmbus->field = image->pix.field;\r\nmbus->colorspace = image->pix.colorspace;\r\nmbus->xfer_func = image->pix.xfer_func;\r\nmbus->ycbcr_enc = image->pix.ycbcr_enc;\r\nmbus->quantization = image->pix.quantization;\r\nreturn 0;\r\n}\r\nvoid imx_media_free_dma_buf(struct imx_media_dev *imxmd,\r\nstruct imx_media_dma_buf *buf)\r\n{\r\nif (buf->virt)\r\ndma_free_coherent(imxmd->md.dev, buf->len,\r\nbuf->virt, buf->phys);\r\nbuf->virt = NULL;\r\nbuf->phys = 0;\r\n}\r\nint imx_media_alloc_dma_buf(struct imx_media_dev *imxmd,\r\nstruct imx_media_dma_buf *buf,\r\nint size)\r\n{\r\nimx_media_free_dma_buf(imxmd, buf);\r\nbuf->len = PAGE_ALIGN(size);\r\nbuf->virt = dma_alloc_coherent(imxmd->md.dev, buf->len, &buf->phys,\r\nGFP_DMA | GFP_KERNEL);\r\nif (!buf->virt) {\r\ndev_err(imxmd->md.dev, "failed to alloc dma buffer\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nvoid imx_media_grp_id_to_sd_name(char *sd_name, int sz, u32 grp_id, int ipu_id)\r\n{\r\nint id;\r\nswitch (grp_id) {\r\ncase IMX_MEDIA_GRP_ID_CSI0...IMX_MEDIA_GRP_ID_CSI1:\r\nid = (grp_id >> IMX_MEDIA_GRP_ID_CSI_BIT) - 1;\r\nsnprintf(sd_name, sz, "ipu%d_csi%d", ipu_id + 1, id);\r\nbreak;\r\ncase IMX_MEDIA_GRP_ID_VDIC:\r\nsnprintf(sd_name, sz, "ipu%d_vdic", ipu_id + 1);\r\nbreak;\r\ncase IMX_MEDIA_GRP_ID_IC_PRP:\r\nsnprintf(sd_name, sz, "ipu%d_ic_prp", ipu_id + 1);\r\nbreak;\r\ncase IMX_MEDIA_GRP_ID_IC_PRPENC:\r\nsnprintf(sd_name, sz, "ipu%d_ic_prpenc", ipu_id + 1);\r\nbreak;\r\ncase IMX_MEDIA_GRP_ID_IC_PRPVF:\r\nsnprintf(sd_name, sz, "ipu%d_ic_prpvf", ipu_id + 1);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstruct imx_media_subdev *\r\nimx_media_find_subdev_by_sd(struct imx_media_dev *imxmd,\r\nstruct v4l2_subdev *sd)\r\n{\r\nstruct imx_media_subdev *imxsd;\r\nint i;\r\nfor (i = 0; i < imxmd->num_subdevs; i++) {\r\nimxsd = &imxmd->subdev[i];\r\nif (sd == imxsd->sd)\r\nreturn imxsd;\r\n}\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nstruct imx_media_subdev *\r\nimx_media_find_subdev_by_id(struct imx_media_dev *imxmd, u32 grp_id)\r\n{\r\nstruct imx_media_subdev *imxsd;\r\nint i;\r\nfor (i = 0; i < imxmd->num_subdevs; i++) {\r\nimxsd = &imxmd->subdev[i];\r\nif (imxsd->sd && imxsd->sd->grp_id == grp_id)\r\nreturn imxsd;\r\n}\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nint imx_media_add_video_device(struct imx_media_dev *imxmd,\r\nstruct imx_media_video_dev *vdev)\r\n{\r\nint vdev_idx, ret = 0;\r\nmutex_lock(&imxmd->mutex);\r\nvdev_idx = imxmd->num_vdevs;\r\nif (vdev_idx >= IMX_MEDIA_MAX_VDEVS) {\r\ndev_err(imxmd->md.dev,\r\n"%s: too many video devices! can't add %s\n",\r\n__func__, vdev->vfd->name);\r\nret = -ENOSPC;\r\ngoto out;\r\n}\r\nimxmd->vdev[vdev_idx] = vdev;\r\nimxmd->num_vdevs++;\r\nout:\r\nmutex_unlock(&imxmd->mutex);\r\nreturn ret;\r\n}\r\nstatic struct media_pad *\r\nfind_pipeline_pad(struct imx_media_dev *imxmd,\r\nstruct media_entity *start_entity,\r\nu32 grp_id, bool upstream)\r\n{\r\nstruct media_entity *me = start_entity;\r\nstruct media_pad *pad = NULL;\r\nstruct v4l2_subdev *sd;\r\nint i;\r\nfor (i = 0; i < me->num_pads; i++) {\r\nstruct media_pad *spad = &me->pads[i];\r\nif ((upstream && !(spad->flags & MEDIA_PAD_FL_SINK)) ||\r\n(!upstream && !(spad->flags & MEDIA_PAD_FL_SOURCE)))\r\ncontinue;\r\npad = media_entity_remote_pad(spad);\r\nif (!pad || !is_media_entity_v4l2_subdev(pad->entity))\r\ncontinue;\r\nsd = media_entity_to_v4l2_subdev(pad->entity);\r\nif (sd->grp_id & grp_id)\r\nreturn pad;\r\nreturn find_pipeline_pad(imxmd, pad->entity, grp_id, upstream);\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct v4l2_subdev *\r\nfind_upstream_subdev(struct imx_media_dev *imxmd,\r\nstruct media_entity *start_entity,\r\nu32 grp_id)\r\n{\r\nstruct v4l2_subdev *sd;\r\nstruct media_pad *pad;\r\nif (is_media_entity_v4l2_subdev(start_entity)) {\r\nsd = media_entity_to_v4l2_subdev(start_entity);\r\nif (sd->grp_id & grp_id)\r\nreturn sd;\r\n}\r\npad = find_pipeline_pad(imxmd, start_entity, grp_id, true);\r\nreturn pad ? media_entity_to_v4l2_subdev(pad->entity) : NULL;\r\n}\r\nint imx_media_find_mipi_csi2_channel(struct imx_media_dev *imxmd,\r\nstruct media_entity *start_entity)\r\n{\r\nstruct media_pad *pad;\r\nint ret = -EPIPE;\r\npad = find_pipeline_pad(imxmd, start_entity, IMX_MEDIA_GRP_ID_CSI2,\r\ntrue);\r\nif (pad) {\r\nret = pad->index - 1;\r\ndev_dbg(imxmd->md.dev, "found vc%d from %s\n",\r\nret, start_entity->name);\r\n}\r\nreturn ret;\r\n}\r\nstruct imx_media_subdev *\r\nimx_media_find_upstream_subdev(struct imx_media_dev *imxmd,\r\nstruct media_entity *start_entity,\r\nu32 grp_id)\r\n{\r\nstruct v4l2_subdev *sd;\r\nsd = find_upstream_subdev(imxmd, start_entity, grp_id);\r\nif (!sd)\r\nreturn ERR_PTR(-ENODEV);\r\nreturn imx_media_find_subdev_by_sd(imxmd, sd);\r\n}\r\nstruct imx_media_subdev *\r\n__imx_media_find_sensor(struct imx_media_dev *imxmd,\r\nstruct media_entity *start_entity)\r\n{\r\nreturn imx_media_find_upstream_subdev(imxmd, start_entity,\r\nIMX_MEDIA_GRP_ID_SENSOR);\r\n}\r\nstruct imx_media_subdev *\r\nimx_media_find_sensor(struct imx_media_dev *imxmd,\r\nstruct media_entity *start_entity)\r\n{\r\nstruct imx_media_subdev *sensor;\r\nmutex_lock(&imxmd->md.graph_mutex);\r\nsensor = __imx_media_find_sensor(imxmd, start_entity);\r\nmutex_unlock(&imxmd->md.graph_mutex);\r\nreturn sensor;\r\n}\r\nint imx_media_pipeline_set_stream(struct imx_media_dev *imxmd,\r\nstruct media_entity *entity,\r\nbool on)\r\n{\r\nstruct v4l2_subdev *sd;\r\nint ret = 0;\r\nif (!is_media_entity_v4l2_subdev(entity))\r\nreturn -EINVAL;\r\nsd = media_entity_to_v4l2_subdev(entity);\r\nmutex_lock(&imxmd->md.graph_mutex);\r\nif (on) {\r\nret = __media_pipeline_start(entity, &imxmd->pipe);\r\nif (ret)\r\ngoto out;\r\nret = v4l2_subdev_call(sd, video, s_stream, 1);\r\nif (ret)\r\n__media_pipeline_stop(entity);\r\n} else {\r\nv4l2_subdev_call(sd, video, s_stream, 0);\r\nif (entity->pipe)\r\n__media_pipeline_stop(entity);\r\n}\r\nout:\r\nmutex_unlock(&imxmd->md.graph_mutex);\r\nreturn ret;\r\n}
