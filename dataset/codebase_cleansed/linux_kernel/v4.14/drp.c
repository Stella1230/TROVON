static void uwb_rc_set_drp_cmd_done(struct uwb_rc *rc, void *arg,\r\nstruct uwb_rceb *reply, ssize_t reply_size)\r\n{\r\nstruct uwb_rc_evt_set_drp_ie *r = (struct uwb_rc_evt_set_drp_ie *)reply;\r\nunsigned long flags;\r\nif (r != NULL) {\r\nif (r->bResultCode != UWB_RC_RES_SUCCESS)\r\ndev_err(&rc->uwb_dev.dev, "SET-DRP-IE failed: %s (%d)\n",\r\nuwb_rc_strerror(r->bResultCode), r->bResultCode);\r\n} else\r\ndev_err(&rc->uwb_dev.dev, "SET-DRP-IE: timeout\n");\r\nspin_lock_irqsave(&rc->rsvs_lock, flags);\r\nif (rc->set_drp_ie_pending > 1) {\r\nrc->set_drp_ie_pending = 0;\r\nuwb_rsv_queue_update(rc);\r\n} else {\r\nrc->set_drp_ie_pending = 0;\r\n}\r\nspin_unlock_irqrestore(&rc->rsvs_lock, flags);\r\n}\r\nint uwb_rc_send_all_drp_ie(struct uwb_rc *rc)\r\n{\r\nint result;\r\nstruct uwb_rc_cmd_set_drp_ie *cmd;\r\nstruct uwb_rsv *rsv;\r\nstruct uwb_rsv_move *mv;\r\nint num_bytes = 0;\r\nu8 *IEDataptr;\r\nresult = -ENOMEM;\r\nlist_for_each_entry(rsv, &rc->reservations, rc_node) {\r\nif (rsv->drp_ie != NULL) {\r\nnum_bytes += rsv->drp_ie->hdr.length + 2;\r\nif (uwb_rsv_has_two_drp_ies(rsv) &&\r\n(rsv->mv.companion_drp_ie != NULL)) {\r\nmv = &rsv->mv;\r\nnum_bytes +=\r\nmv->companion_drp_ie->hdr.length + 2;\r\n}\r\n}\r\n}\r\nnum_bytes += sizeof(rc->drp_avail.ie);\r\ncmd = kzalloc(sizeof(*cmd) + num_bytes, GFP_KERNEL);\r\nif (cmd == NULL)\r\ngoto error;\r\ncmd->rccb.bCommandType = UWB_RC_CET_GENERAL;\r\ncmd->rccb.wCommand = cpu_to_le16(UWB_RC_CMD_SET_DRP_IE);\r\ncmd->wIELength = num_bytes;\r\nIEDataptr = (u8 *)&cmd->IEData[0];\r\nmemcpy(IEDataptr, &rc->drp_avail.ie, sizeof(rc->drp_avail.ie));\r\nIEDataptr += sizeof(struct uwb_ie_drp_avail);\r\nlist_for_each_entry(rsv, &rc->reservations, rc_node) {\r\nif (rsv->drp_ie != NULL) {\r\nmemcpy(IEDataptr, rsv->drp_ie,\r\nrsv->drp_ie->hdr.length + 2);\r\nIEDataptr += rsv->drp_ie->hdr.length + 2;\r\nif (uwb_rsv_has_two_drp_ies(rsv) &&\r\n(rsv->mv.companion_drp_ie != NULL)) {\r\nmv = &rsv->mv;\r\nmemcpy(IEDataptr, mv->companion_drp_ie,\r\nmv->companion_drp_ie->hdr.length + 2);\r\nIEDataptr +=\r\nmv->companion_drp_ie->hdr.length + 2;\r\n}\r\n}\r\n}\r\nresult = uwb_rc_cmd_async(rc, "SET-DRP-IE",\r\n&cmd->rccb, sizeof(*cmd) + num_bytes,\r\nUWB_RC_CET_GENERAL, UWB_RC_CMD_SET_DRP_IE,\r\nuwb_rc_set_drp_cmd_done, NULL);\r\nrc->set_drp_ie_pending = 1;\r\nkfree(cmd);\r\nerror:\r\nreturn result;\r\n}\r\nstatic int evaluate_conflict_action(struct uwb_ie_drp *ext_drp_ie, int ext_beacon_slot,\r\nstruct uwb_rsv *rsv, int our_status)\r\n{\r\nint our_tie_breaker = rsv->tiebreaker;\r\nint our_type = rsv->type;\r\nint our_beacon_slot = rsv->rc->uwb_dev.beacon_slot;\r\nint ext_tie_breaker = uwb_ie_drp_tiebreaker(ext_drp_ie);\r\nint ext_status = uwb_ie_drp_status(ext_drp_ie);\r\nint ext_type = uwb_ie_drp_type(ext_drp_ie);\r\nif (ext_type == UWB_DRP_TYPE_PCA && our_type == UWB_DRP_TYPE_PCA) {\r\nreturn UWB_DRP_CONFLICT_MANTAIN;\r\n}\r\nif (our_type == UWB_DRP_TYPE_ALIEN_BP) {\r\nreturn UWB_DRP_CONFLICT_MANTAIN;\r\n}\r\nif (ext_type == UWB_DRP_TYPE_ALIEN_BP) {\r\nreturn UWB_DRP_CONFLICT_ACT1;\r\n}\r\nif (our_status == 0 && ext_status == 1) {\r\nreturn UWB_DRP_CONFLICT_ACT2;\r\n}\r\nif (our_status == 1 && ext_status == 0) {\r\nreturn UWB_DRP_CONFLICT_MANTAIN;\r\n}\r\nif (our_tie_breaker == ext_tie_breaker &&\r\nour_beacon_slot < ext_beacon_slot) {\r\nreturn UWB_DRP_CONFLICT_MANTAIN;\r\n}\r\nif (our_tie_breaker != ext_tie_breaker &&\r\nour_beacon_slot > ext_beacon_slot) {\r\nreturn UWB_DRP_CONFLICT_MANTAIN;\r\n}\r\nif (our_status == 0) {\r\nif (our_tie_breaker == ext_tie_breaker) {\r\nif (our_beacon_slot > ext_beacon_slot) {\r\nreturn UWB_DRP_CONFLICT_ACT2;\r\n}\r\n} else {\r\nif (our_beacon_slot < ext_beacon_slot) {\r\nreturn UWB_DRP_CONFLICT_ACT2;\r\n}\r\n}\r\n} else {\r\nif (our_tie_breaker == ext_tie_breaker) {\r\nif (our_beacon_slot > ext_beacon_slot) {\r\nreturn UWB_DRP_CONFLICT_ACT3;\r\n}\r\n} else {\r\nif (our_beacon_slot < ext_beacon_slot) {\r\nreturn UWB_DRP_CONFLICT_ACT3;\r\n}\r\n}\r\n}\r\nreturn UWB_DRP_CONFLICT_MANTAIN;\r\n}\r\nstatic void handle_conflict_normal(struct uwb_ie_drp *drp_ie,\r\nint ext_beacon_slot,\r\nstruct uwb_rsv *rsv,\r\nstruct uwb_mas_bm *conflicting_mas)\r\n{\r\nstruct uwb_rc *rc = rsv->rc;\r\nstruct uwb_rsv_move *mv = &rsv->mv;\r\nstruct uwb_drp_backoff_win *bow = &rc->bow;\r\nint action;\r\naction = evaluate_conflict_action(drp_ie, ext_beacon_slot, rsv, uwb_rsv_status(rsv));\r\nif (uwb_rsv_is_owner(rsv)) {\r\nswitch(action) {\r\ncase UWB_DRP_CONFLICT_ACT2:\r\nuwb_rsv_set_state(rsv, UWB_RSV_STATE_O_TO_BE_MOVED);\r\nif (bow->can_reserve_extra_mases == false)\r\nuwb_rsv_backoff_win_increment(rc);\r\nbreak;\r\ncase UWB_DRP_CONFLICT_ACT3:\r\nuwb_rsv_backoff_win_increment(rc);\r\nbitmap_and(mv->companion_mas.bm, rsv->mas.bm, conflicting_mas->bm, UWB_NUM_MAS);\r\nuwb_rsv_set_state(rsv, UWB_RSV_STATE_O_MODIFIED);\r\ndefault:\r\nbreak;\r\n}\r\n} else {\r\nswitch(action) {\r\ncase UWB_DRP_CONFLICT_ACT2:\r\ncase UWB_DRP_CONFLICT_ACT3:\r\nuwb_rsv_set_state(rsv, UWB_RSV_STATE_T_CONFLICT);\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void handle_conflict_expanding(struct uwb_ie_drp *drp_ie, int ext_beacon_slot,\r\nstruct uwb_rsv *rsv, bool companion_only,\r\nstruct uwb_mas_bm *conflicting_mas)\r\n{\r\nstruct uwb_rc *rc = rsv->rc;\r\nstruct uwb_drp_backoff_win *bow = &rc->bow;\r\nstruct uwb_rsv_move *mv = &rsv->mv;\r\nint action;\r\nif (companion_only) {\r\naction = evaluate_conflict_action(drp_ie, ext_beacon_slot, rsv, 0);\r\nif (uwb_rsv_is_owner(rsv)) {\r\nswitch(action) {\r\ncase UWB_DRP_CONFLICT_ACT2:\r\ncase UWB_DRP_CONFLICT_ACT3:\r\nuwb_rsv_set_state(rsv,\r\nUWB_RSV_STATE_O_ESTABLISHED);\r\nrsv->needs_release_companion_mas = false;\r\nif (bow->can_reserve_extra_mases == false)\r\nuwb_rsv_backoff_win_increment(rc);\r\nuwb_drp_avail_release(rsv->rc,\r\n&rsv->mv.companion_mas);\r\n}\r\n} else {\r\nswitch(action) {\r\ncase UWB_DRP_CONFLICT_ACT2:\r\ncase UWB_DRP_CONFLICT_ACT3:\r\nuwb_rsv_set_state(rsv,\r\nUWB_RSV_STATE_T_EXPANDING_CONFLICT);\r\n}\r\n}\r\n} else {\r\nif (uwb_rsv_is_owner(rsv)) {\r\nuwb_rsv_backoff_win_increment(rc);\r\nuwb_drp_avail_release(rsv->rc, &rsv->mv.companion_mas);\r\nbitmap_andnot(mv->companion_mas.bm, rsv->mas.bm,\r\nconflicting_mas->bm, UWB_NUM_MAS);\r\nuwb_rsv_set_state(rsv, UWB_RSV_STATE_O_MODIFIED);\r\n} else {\r\nuwb_rsv_set_state(rsv, UWB_RSV_STATE_T_CONFLICT);\r\n}\r\n}\r\n}\r\nstatic void uwb_drp_handle_conflict_rsv(struct uwb_rc *rc, struct uwb_rsv *rsv,\r\nstruct uwb_rc_evt_drp *drp_evt,\r\nstruct uwb_ie_drp *drp_ie,\r\nstruct uwb_mas_bm *conflicting_mas)\r\n{\r\nstruct uwb_rsv_move *mv;\r\nif (uwb_rsv_has_two_drp_ies(rsv)) {\r\nmv = &rsv->mv;\r\nif (bitmap_intersects(rsv->mas.bm, conflicting_mas->bm,\r\nUWB_NUM_MAS)) {\r\nhandle_conflict_expanding(drp_ie,\r\ndrp_evt->beacon_slot_number,\r\nrsv, false, conflicting_mas);\r\n} else {\r\nif (bitmap_intersects(mv->companion_mas.bm,\r\nconflicting_mas->bm, UWB_NUM_MAS)) {\r\nhandle_conflict_expanding(\r\ndrp_ie, drp_evt->beacon_slot_number,\r\nrsv, true, conflicting_mas);\r\n}\r\n}\r\n} else if (bitmap_intersects(rsv->mas.bm, conflicting_mas->bm,\r\nUWB_NUM_MAS)) {\r\nhandle_conflict_normal(drp_ie, drp_evt->beacon_slot_number,\r\nrsv, conflicting_mas);\r\n}\r\n}\r\nstatic void uwb_drp_handle_all_conflict_rsv(struct uwb_rc *rc,\r\nstruct uwb_rc_evt_drp *drp_evt,\r\nstruct uwb_ie_drp *drp_ie,\r\nstruct uwb_mas_bm *conflicting_mas)\r\n{\r\nstruct uwb_rsv *rsv;\r\nlist_for_each_entry(rsv, &rc->reservations, rc_node) {\r\nuwb_drp_handle_conflict_rsv(rc, rsv, drp_evt, drp_ie,\r\nconflicting_mas);\r\n}\r\n}\r\nstatic void uwb_drp_process_target_accepted(struct uwb_rc *rc,\r\nstruct uwb_rsv *rsv, struct uwb_rc_evt_drp *drp_evt,\r\nstruct uwb_ie_drp *drp_ie, struct uwb_mas_bm *mas)\r\n{\r\nstruct uwb_rsv_move *mv = &rsv->mv;\r\nint status;\r\nstatus = uwb_ie_drp_status(drp_ie);\r\nif (rsv->state == UWB_RSV_STATE_T_CONFLICT) {\r\nuwb_rsv_set_state(rsv, UWB_RSV_STATE_T_CONFLICT);\r\nreturn;\r\n}\r\nif (rsv->state == UWB_RSV_STATE_T_EXPANDING_ACCEPTED) {\r\nif (!bitmap_equal(rsv->mas.bm, mas->bm, UWB_NUM_MAS)) {\r\nuwb_rsv_set_state(rsv,\r\nUWB_RSV_STATE_T_EXPANDING_ACCEPTED);\r\n}\r\n} else {\r\nif (!bitmap_equal(rsv->mas.bm, mas->bm, UWB_NUM_MAS)) {\r\nif (uwb_drp_avail_reserve_pending(rc, mas) == -EBUSY) {\r\nuwb_drp_handle_all_conflict_rsv(rc, drp_evt,\r\ndrp_ie, mas);\r\n} else {\r\nbitmap_copy(mv->companion_mas.bm, mas->bm,\r\nUWB_NUM_MAS);\r\nuwb_rsv_set_state(rsv,\r\nUWB_RSV_STATE_T_EXPANDING_ACCEPTED);\r\n}\r\n} else {\r\nif (status) {\r\nuwb_rsv_set_state(rsv,\r\nUWB_RSV_STATE_T_ACCEPTED);\r\n}\r\n}\r\n}\r\n}\r\nstatic void uwb_drp_process_target(struct uwb_rc *rc, struct uwb_rsv *rsv,\r\nstruct uwb_ie_drp *drp_ie, struct uwb_rc_evt_drp *drp_evt)\r\n{\r\nstruct device *dev = &rc->uwb_dev.dev;\r\nstruct uwb_rsv_move *mv = &rsv->mv;\r\nint status;\r\nenum uwb_drp_reason reason_code;\r\nstruct uwb_mas_bm mas;\r\nstatus = uwb_ie_drp_status(drp_ie);\r\nreason_code = uwb_ie_drp_reason_code(drp_ie);\r\nuwb_drp_ie_to_bm(&mas, drp_ie);\r\nswitch (reason_code) {\r\ncase UWB_DRP_REASON_ACCEPTED:\r\nuwb_drp_process_target_accepted(rc, rsv, drp_evt, drp_ie, &mas);\r\nbreak;\r\ncase UWB_DRP_REASON_MODIFIED:\r\nif (bitmap_equal(rsv->mas.bm, mas.bm, UWB_NUM_MAS)) {\r\nuwb_rsv_set_state(rsv, UWB_RSV_STATE_T_ACCEPTED);\r\nbreak;\r\n}\r\nif (bitmap_subset(mas.bm, rsv->mas.bm, UWB_NUM_MAS)) {\r\nbitmap_andnot(mv->companion_mas.bm, rsv->mas.bm, mas.bm,\r\nUWB_NUM_MAS);\r\nuwb_drp_avail_release(rsv->rc, &mv->companion_mas);\r\n}\r\nbitmap_copy(rsv->mas.bm, mas.bm, UWB_NUM_MAS);\r\nuwb_rsv_set_state(rsv, UWB_RSV_STATE_T_RESIZED);\r\nbreak;\r\ndefault:\r\ndev_warn(dev, "ignoring invalid DRP IE state (%d/%d)\n",\r\nreason_code, status);\r\n}\r\n}\r\nstatic void uwb_drp_process_owner_accepted(struct uwb_rsv *rsv,\r\nstruct uwb_mas_bm *mas)\r\n{\r\nstruct uwb_rsv_move *mv = &rsv->mv;\r\nswitch (rsv->state) {\r\ncase UWB_RSV_STATE_O_PENDING:\r\ncase UWB_RSV_STATE_O_INITIATED:\r\ncase UWB_RSV_STATE_O_ESTABLISHED:\r\nuwb_rsv_set_state(rsv, UWB_RSV_STATE_O_ESTABLISHED);\r\nbreak;\r\ncase UWB_RSV_STATE_O_MODIFIED:\r\nif (bitmap_equal(mas->bm, rsv->mas.bm, UWB_NUM_MAS))\r\nuwb_rsv_set_state(rsv, UWB_RSV_STATE_O_ESTABLISHED);\r\nelse\r\nuwb_rsv_set_state(rsv, UWB_RSV_STATE_O_MODIFIED);\r\nbreak;\r\ncase UWB_RSV_STATE_O_MOVE_REDUCING:\r\nif (bitmap_equal(mas->bm, rsv->mas.bm, UWB_NUM_MAS))\r\nuwb_rsv_set_state(rsv, UWB_RSV_STATE_O_ESTABLISHED);\r\nelse\r\nuwb_rsv_set_state(rsv, UWB_RSV_STATE_O_MOVE_REDUCING);\r\nbreak;\r\ncase UWB_RSV_STATE_O_MOVE_EXPANDING:\r\nif (bitmap_equal(mas->bm, mv->companion_mas.bm, UWB_NUM_MAS)) {\r\nuwb_rsv_set_state(rsv, UWB_RSV_STATE_O_MOVE_COMBINING);\r\n} else {\r\nuwb_rsv_set_state(rsv, UWB_RSV_STATE_O_MOVE_EXPANDING);\r\n}\r\nbreak;\r\ncase UWB_RSV_STATE_O_MOVE_COMBINING:\r\nif (bitmap_equal(mas->bm, rsv->mas.bm, UWB_NUM_MAS))\r\nuwb_rsv_set_state(rsv, UWB_RSV_STATE_O_MOVE_REDUCING);\r\nelse\r\nuwb_rsv_set_state(rsv, UWB_RSV_STATE_O_MOVE_COMBINING);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void uwb_drp_process_owner(struct uwb_rc *rc, struct uwb_rsv *rsv,\r\nstruct uwb_dev *src, struct uwb_ie_drp *drp_ie,\r\nstruct uwb_rc_evt_drp *drp_evt)\r\n{\r\nstruct device *dev = &rc->uwb_dev.dev;\r\nint status;\r\nenum uwb_drp_reason reason_code;\r\nstruct uwb_mas_bm mas;\r\nstatus = uwb_ie_drp_status(drp_ie);\r\nreason_code = uwb_ie_drp_reason_code(drp_ie);\r\nuwb_drp_ie_to_bm(&mas, drp_ie);\r\nif (status) {\r\nswitch (reason_code) {\r\ncase UWB_DRP_REASON_ACCEPTED:\r\nuwb_drp_process_owner_accepted(rsv, &mas);\r\nbreak;\r\ndefault:\r\ndev_warn(dev, "ignoring invalid DRP IE state (%d/%d)\n",\r\nreason_code, status);\r\n}\r\n} else {\r\nswitch (reason_code) {\r\ncase UWB_DRP_REASON_PENDING:\r\nuwb_rsv_set_state(rsv, UWB_RSV_STATE_O_PENDING);\r\nbreak;\r\ncase UWB_DRP_REASON_DENIED:\r\nuwb_rsv_set_state(rsv, UWB_RSV_STATE_NONE);\r\nbreak;\r\ncase UWB_DRP_REASON_CONFLICT:\r\nbitmap_complement(mas.bm, src->last_availability_bm,\r\nUWB_NUM_MAS);\r\nuwb_drp_handle_conflict_rsv(rc, rsv, drp_evt, drp_ie, &mas);\r\nbreak;\r\ndefault:\r\ndev_warn(dev, "ignoring invalid DRP IE state (%d/%d)\n",\r\nreason_code, status);\r\n}\r\n}\r\n}\r\nstatic void uwb_cnflt_alien_stroke_timer(struct uwb_cnflt_alien *cnflt)\r\n{\r\nunsigned timeout_us = UWB_MAX_LOST_BEACONS * UWB_SUPERFRAME_LENGTH_US;\r\nmod_timer(&cnflt->timer, jiffies + usecs_to_jiffies(timeout_us));\r\n}\r\nstatic void uwb_cnflt_update_work(struct work_struct *work)\r\n{\r\nstruct uwb_cnflt_alien *cnflt = container_of(work,\r\nstruct uwb_cnflt_alien,\r\ncnflt_update_work);\r\nstruct uwb_cnflt_alien *c;\r\nstruct uwb_rc *rc = cnflt->rc;\r\nunsigned long delay_us = UWB_MAS_LENGTH_US * UWB_MAS_PER_ZONE;\r\nmutex_lock(&rc->rsvs_mutex);\r\nlist_del(&cnflt->rc_node);\r\nbitmap_zero(rc->cnflt_alien_bitmap.bm, UWB_NUM_MAS);\r\nlist_for_each_entry(c, &rc->cnflt_alien_list, rc_node) {\r\nbitmap_or(rc->cnflt_alien_bitmap.bm, rc->cnflt_alien_bitmap.bm,\r\nc->mas.bm, UWB_NUM_MAS);\r\n}\r\nqueue_delayed_work(rc->rsv_workq, &rc->rsv_alien_bp_work,\r\nusecs_to_jiffies(delay_us));\r\nkfree(cnflt);\r\nmutex_unlock(&rc->rsvs_mutex);\r\n}\r\nstatic void uwb_cnflt_timer(unsigned long arg)\r\n{\r\nstruct uwb_cnflt_alien *cnflt = (struct uwb_cnflt_alien *)arg;\r\nqueue_work(cnflt->rc->rsv_workq, &cnflt->cnflt_update_work);\r\n}\r\nstatic void uwb_drp_handle_alien_drp(struct uwb_rc *rc, struct uwb_ie_drp *drp_ie)\r\n{\r\nstruct device *dev = &rc->uwb_dev.dev;\r\nstruct uwb_mas_bm mas;\r\nstruct uwb_cnflt_alien *cnflt;\r\nunsigned long delay_us = UWB_MAS_LENGTH_US * UWB_MAS_PER_ZONE;\r\nuwb_drp_ie_to_bm(&mas, drp_ie);\r\nlist_for_each_entry(cnflt, &rc->cnflt_alien_list, rc_node) {\r\nif (bitmap_equal(cnflt->mas.bm, mas.bm, UWB_NUM_MAS)) {\r\nuwb_cnflt_alien_stroke_timer(cnflt);\r\nreturn;\r\n}\r\n}\r\ncnflt = kzalloc(sizeof(struct uwb_cnflt_alien), GFP_KERNEL);\r\nif (!cnflt) {\r\ndev_err(dev, "failed to alloc uwb_cnflt_alien struct\n");\r\nreturn;\r\n}\r\nINIT_LIST_HEAD(&cnflt->rc_node);\r\nsetup_timer(&cnflt->timer, uwb_cnflt_timer, (unsigned long)cnflt);\r\ncnflt->rc = rc;\r\nINIT_WORK(&cnflt->cnflt_update_work, uwb_cnflt_update_work);\r\nbitmap_copy(cnflt->mas.bm, mas.bm, UWB_NUM_MAS);\r\nlist_add_tail(&cnflt->rc_node, &rc->cnflt_alien_list);\r\nbitmap_or(rc->cnflt_alien_bitmap.bm, rc->cnflt_alien_bitmap.bm, mas.bm, UWB_NUM_MAS);\r\nqueue_delayed_work(rc->rsv_workq, &rc->rsv_alien_bp_work, usecs_to_jiffies(delay_us));\r\nuwb_cnflt_alien_stroke_timer(cnflt);\r\n}\r\nstatic void uwb_drp_process_not_involved(struct uwb_rc *rc,\r\nstruct uwb_rc_evt_drp *drp_evt,\r\nstruct uwb_ie_drp *drp_ie)\r\n{\r\nstruct uwb_mas_bm mas;\r\nuwb_drp_ie_to_bm(&mas, drp_ie);\r\nuwb_drp_handle_all_conflict_rsv(rc, drp_evt, drp_ie, &mas);\r\n}\r\nstatic void uwb_drp_process_involved(struct uwb_rc *rc, struct uwb_dev *src,\r\nstruct uwb_rc_evt_drp *drp_evt,\r\nstruct uwb_ie_drp *drp_ie)\r\n{\r\nstruct uwb_rsv *rsv;\r\nrsv = uwb_rsv_find(rc, src, drp_ie);\r\nif (!rsv) {\r\nreturn;\r\n}\r\nif (rsv->state == UWB_RSV_STATE_NONE) {\r\nuwb_rsv_set_state(rsv, UWB_RSV_STATE_NONE);\r\nreturn;\r\n}\r\nif (uwb_ie_drp_owner(drp_ie))\r\nuwb_drp_process_target(rc, rsv, drp_ie, drp_evt);\r\nelse\r\nuwb_drp_process_owner(rc, rsv, src, drp_ie, drp_evt);\r\n}\r\nstatic bool uwb_drp_involves_us(struct uwb_rc *rc, struct uwb_ie_drp *drp_ie)\r\n{\r\nreturn uwb_dev_addr_cmp(&rc->uwb_dev.dev_addr, &drp_ie->dev_addr) == 0;\r\n}\r\nstatic void uwb_drp_process(struct uwb_rc *rc, struct uwb_rc_evt_drp *drp_evt,\r\nstruct uwb_dev *src, struct uwb_ie_drp *drp_ie)\r\n{\r\nif (uwb_ie_drp_type(drp_ie) == UWB_DRP_TYPE_ALIEN_BP)\r\nuwb_drp_handle_alien_drp(rc, drp_ie);\r\nelse if (uwb_drp_involves_us(rc, drp_ie))\r\nuwb_drp_process_involved(rc, src, drp_evt, drp_ie);\r\nelse\r\nuwb_drp_process_not_involved(rc, drp_evt, drp_ie);\r\n}\r\nstatic void uwb_drp_availability_process(struct uwb_rc *rc, struct uwb_dev *src,\r\nstruct uwb_ie_drp_avail *drp_availability_ie)\r\n{\r\nbitmap_copy(src->last_availability_bm,\r\ndrp_availability_ie->bmp, UWB_NUM_MAS);\r\n}\r\nstatic\r\nvoid uwb_drp_process_all(struct uwb_rc *rc, struct uwb_rc_evt_drp *drp_evt,\r\nsize_t ielen, struct uwb_dev *src_dev)\r\n{\r\nstruct device *dev = &rc->uwb_dev.dev;\r\nstruct uwb_ie_hdr *ie_hdr;\r\nvoid *ptr;\r\nptr = drp_evt->ie_data;\r\nfor (;;) {\r\nie_hdr = uwb_ie_next(&ptr, &ielen);\r\nif (!ie_hdr)\r\nbreak;\r\nswitch (ie_hdr->element_id) {\r\ncase UWB_IE_DRP_AVAILABILITY:\r\nuwb_drp_availability_process(rc, src_dev, (struct uwb_ie_drp_avail *)ie_hdr);\r\nbreak;\r\ncase UWB_IE_DRP:\r\nuwb_drp_process(rc, drp_evt, src_dev, (struct uwb_ie_drp *)ie_hdr);\r\nbreak;\r\ndefault:\r\ndev_warn(dev, "unexpected IE in DRP notification\n");\r\nbreak;\r\n}\r\n}\r\nif (ielen > 0)\r\ndev_warn(dev, "%d octets remaining in DRP notification\n",\r\n(int)ielen);\r\n}\r\nint uwbd_evt_handle_rc_drp(struct uwb_event *evt)\r\n{\r\nstruct device *dev = &evt->rc->uwb_dev.dev;\r\nstruct uwb_rc *rc = evt->rc;\r\nstruct uwb_rc_evt_drp *drp_evt;\r\nsize_t ielength, bytes_left;\r\nstruct uwb_dev_addr src_addr;\r\nstruct uwb_dev *src_dev;\r\nif (evt->notif.size < sizeof(*drp_evt)) {\r\ndev_err(dev, "DRP event: Not enough data to decode event "\r\n"[%zu bytes left, %zu needed]\n",\r\nevt->notif.size, sizeof(*drp_evt));\r\nreturn 0;\r\n}\r\nbytes_left = evt->notif.size - sizeof(*drp_evt);\r\ndrp_evt = container_of(evt->notif.rceb, struct uwb_rc_evt_drp, rceb);\r\nielength = le16_to_cpu(drp_evt->ie_length);\r\nif (bytes_left != ielength) {\r\ndev_err(dev, "DRP event: Not enough data in payload [%zu"\r\n"bytes left, %zu declared in the event]\n",\r\nbytes_left, ielength);\r\nreturn 0;\r\n}\r\nmemcpy(src_addr.data, &drp_evt->src_addr, sizeof(src_addr));\r\nsrc_dev = uwb_dev_get_by_devaddr(rc, &src_addr);\r\nif (!src_dev) {\r\nreturn 0;\r\n}\r\nmutex_lock(&rc->rsvs_mutex);\r\nuwb_drp_process_all(rc, drp_evt, ielength, src_dev);\r\nmutex_unlock(&rc->rsvs_mutex);\r\nuwb_dev_put(src_dev);\r\nreturn 0;\r\n}
