static void leaf_copy_dir_entries(struct buffer_info *dest_bi,\r\nstruct buffer_head *source, int last_first,\r\nint item_num, int from, int copy_count)\r\n{\r\nstruct buffer_head *dest = dest_bi->bi_bh;\r\nint item_num_in_dest;\r\nstruct item_head *ih;\r\nstruct reiserfs_de_head *deh;\r\nint copy_records_len;\r\nchar *records;\r\nih = item_head(source, item_num);\r\nRFALSE(!is_direntry_le_ih(ih), "vs-10000: item must be directory item");\r\ndeh = B_I_DEH(source, ih);\r\nif (copy_count) {\r\ncopy_records_len = (from ? deh_location(&deh[from - 1]) :\r\nih_item_len(ih)) -\r\ndeh_location(&deh[from + copy_count - 1]);\r\nrecords =\r\nsource->b_data + ih_location(ih) +\r\ndeh_location(&deh[from + copy_count - 1]);\r\n} else {\r\ncopy_records_len = 0;\r\nrecords = NULL;\r\n}\r\nitem_num_in_dest =\r\n(last_first ==\r\nLAST_TO_FIRST) ? ((B_NR_ITEMS(dest)) ? 0 : -1) : (B_NR_ITEMS(dest)\r\n- 1);\r\nif ((item_num_in_dest == -1) ||\r\n(last_first == FIRST_TO_LAST && le_ih_k_offset(ih) == DOT_OFFSET) ||\r\n(last_first == LAST_TO_FIRST\r\n&& comp_short_le_keys (&ih->ih_key,\r\nleaf_key(dest,\r\nitem_num_in_dest))))\r\n{\r\nstruct item_head new_ih;\r\nmemcpy(&new_ih.ih_key, &ih->ih_key, KEY_SIZE);\r\nput_ih_version(&new_ih, KEY_FORMAT_3_5);\r\nput_ih_item_len(&new_ih,\r\nDEH_SIZE * copy_count + copy_records_len);\r\nput_ih_entry_count(&new_ih, 0);\r\nif (last_first == LAST_TO_FIRST) {\r\nif (from < ih_entry_count(ih)) {\r\nset_le_ih_k_offset(&new_ih,\r\ndeh_offset(&deh[from]));\r\n} else {\r\nset_le_ih_k_offset(&new_ih, U32_MAX);\r\n}\r\nset_le_key_k_type(KEY_FORMAT_3_5, &new_ih.ih_key,\r\nTYPE_DIRENTRY);\r\n}\r\nleaf_insert_into_buf(dest_bi,\r\n(last_first ==\r\nLAST_TO_FIRST) ? 0 : B_NR_ITEMS(dest),\r\n&new_ih, NULL, 0);\r\n} else {\r\nleaf_paste_in_buffer(dest_bi,\r\n(last_first ==\r\nFIRST_TO_LAST) ? (B_NR_ITEMS(dest) -\r\n1) : 0, MAX_US_INT,\r\nDEH_SIZE * copy_count + copy_records_len,\r\nrecords, 0);\r\n}\r\nitem_num_in_dest =\r\n(last_first == FIRST_TO_LAST) ? (B_NR_ITEMS(dest) - 1) : 0;\r\nleaf_paste_entries(dest_bi, item_num_in_dest,\r\n(last_first ==\r\nFIRST_TO_LAST) ? ih_entry_count(item_head(dest,\r\nitem_num_in_dest))\r\n: 0, copy_count, deh + from, records,\r\nDEH_SIZE * copy_count + copy_records_len);\r\n}\r\nstatic int leaf_copy_boundary_item(struct buffer_info *dest_bi,\r\nstruct buffer_head *src, int last_first,\r\nint bytes_or_entries)\r\n{\r\nstruct buffer_head *dest = dest_bi->bi_bh;\r\nint dest_nr_item, src_nr_item;\r\nstruct item_head *ih;\r\nstruct item_head *dih;\r\ndest_nr_item = B_NR_ITEMS(dest);\r\nif (last_first == FIRST_TO_LAST) {\r\nih = item_head(src, 0);\r\ndih = item_head(dest, dest_nr_item - 1);\r\nif (!dest_nr_item\r\n|| (!op_is_left_mergeable(&ih->ih_key, src->b_size)))\r\nreturn 0;\r\nRFALSE(!ih_item_len(ih),\r\n"vs-10010: item can not have empty length");\r\nif (is_direntry_le_ih(ih)) {\r\nif (bytes_or_entries == -1)\r\nbytes_or_entries = ih_entry_count(ih);\r\nleaf_copy_dir_entries(dest_bi, src, FIRST_TO_LAST, 0, 0,\r\nbytes_or_entries);\r\nreturn 1;\r\n}\r\nif (bytes_or_entries == -1)\r\nbytes_or_entries = ih_item_len(ih);\r\n#ifdef CONFIG_REISERFS_CHECK\r\nelse {\r\nif (bytes_or_entries == ih_item_len(ih)\r\n&& is_indirect_le_ih(ih))\r\nif (get_ih_free_space(ih))\r\nreiserfs_panic(sb_from_bi(dest_bi),\r\n"vs-10020",\r\n"last unformatted node "\r\n"must be filled "\r\n"entirely (%h)", ih);\r\n}\r\n#endif\r\nleaf_paste_in_buffer(dest_bi,\r\ndest_nr_item - 1, ih_item_len(dih),\r\nbytes_or_entries, ih_item_body(src, ih), 0);\r\nif (is_indirect_le_ih(dih)) {\r\nRFALSE(get_ih_free_space(dih),\r\n"vs-10030: merge to left: last unformatted node of non-last indirect item %h must have zerto free space",\r\nih);\r\nif (bytes_or_entries == ih_item_len(ih))\r\nset_ih_free_space(dih, get_ih_free_space(ih));\r\n}\r\nreturn 1;\r\n}\r\nsrc_nr_item = B_NR_ITEMS(src);\r\nih = item_head(src, src_nr_item - 1);\r\ndih = item_head(dest, 0);\r\nif (!dest_nr_item || !op_is_left_mergeable(&dih->ih_key, src->b_size))\r\nreturn 0;\r\nif (is_direntry_le_ih(ih)) {\r\nif (bytes_or_entries == -1)\r\nbytes_or_entries = ih_entry_count(ih);\r\nleaf_copy_dir_entries(dest_bi, src, LAST_TO_FIRST,\r\nsrc_nr_item - 1,\r\nih_entry_count(ih) - bytes_or_entries,\r\nbytes_or_entries);\r\nreturn 1;\r\n}\r\nRFALSE(is_indirect_le_ih(ih) && get_ih_free_space(ih),\r\n"vs-10040: merge to right: last unformatted node of non-last indirect item must be filled entirely (%h)",\r\nih);\r\nif (bytes_or_entries == -1) {\r\nbytes_or_entries = ih_item_len(ih);\r\nRFALSE(le_ih_k_offset(dih) !=\r\nle_ih_k_offset(ih) + op_bytes_number(ih, src->b_size),\r\n"vs-10050: items %h and %h do not match", ih, dih);\r\nset_le_ih_k_offset(dih, le_ih_k_offset(ih));\r\nset_le_ih_k_type(dih, le_ih_k_type(ih));\r\n} else {\r\nRFALSE(ih_item_len(ih) <= bytes_or_entries,\r\n"vs-10060: no so much bytes %lu (needed %lu)",\r\n(unsigned long)ih_item_len(ih),\r\n(unsigned long)bytes_or_entries);\r\nif (is_direct_le_ih(dih)) {\r\nRFALSE(le_ih_k_offset(dih) <=\r\n(unsigned long)bytes_or_entries,\r\n"vs-10070: dih %h, bytes_or_entries(%d)", dih,\r\nbytes_or_entries);\r\nset_le_ih_k_offset(dih,\r\nle_ih_k_offset(dih) -\r\nbytes_or_entries);\r\n} else {\r\nRFALSE(le_ih_k_offset(dih) <=\r\n(bytes_or_entries / UNFM_P_SIZE) * dest->b_size,\r\n"vs-10080: dih %h, bytes_or_entries(%d)",\r\ndih,\r\n(bytes_or_entries / UNFM_P_SIZE) * dest->b_size);\r\nset_le_ih_k_offset(dih,\r\nle_ih_k_offset(dih) -\r\n((bytes_or_entries / UNFM_P_SIZE) *\r\ndest->b_size));\r\n}\r\n}\r\nleaf_paste_in_buffer(dest_bi, 0, 0, bytes_or_entries,\r\nih_item_body(src,\r\nih) + ih_item_len(ih) - bytes_or_entries,\r\n0);\r\nreturn 1;\r\n}\r\nstatic void leaf_copy_items_entirely(struct buffer_info *dest_bi,\r\nstruct buffer_head *src, int last_first,\r\nint first, int cpy_num)\r\n{\r\nstruct buffer_head *dest;\r\nint nr, free_space;\r\nint dest_before;\r\nint last_loc, last_inserted_loc, location;\r\nint i, j;\r\nstruct block_head *blkh;\r\nstruct item_head *ih;\r\nRFALSE(last_first != LAST_TO_FIRST && last_first != FIRST_TO_LAST,\r\n"vs-10090: bad last_first parameter %d", last_first);\r\nRFALSE(B_NR_ITEMS(src) - first < cpy_num,\r\n"vs-10100: too few items in source %d, required %d from %d",\r\nB_NR_ITEMS(src), cpy_num, first);\r\nRFALSE(cpy_num < 0, "vs-10110: can not copy negative amount of items");\r\nRFALSE(!dest_bi, "vs-10120: can not copy negative amount of items");\r\ndest = dest_bi->bi_bh;\r\nRFALSE(!dest, "vs-10130: can not copy negative amount of items");\r\nif (cpy_num == 0)\r\nreturn;\r\nblkh = B_BLK_HEAD(dest);\r\nnr = blkh_nr_item(blkh);\r\nfree_space = blkh_free_space(blkh);\r\ndest_before = (last_first == LAST_TO_FIRST) ? 0 : nr;\r\nih = item_head(dest, dest_before);\r\nRFALSE(blkh_free_space(blkh) < cpy_num * IH_SIZE,\r\n"vs-10140: not enough free space for headers %d (needed %d)",\r\nB_FREE_SPACE(dest), cpy_num * IH_SIZE);\r\nmemmove(ih + cpy_num, ih, (nr - dest_before) * IH_SIZE);\r\nmemcpy(ih, item_head(src, first), cpy_num * IH_SIZE);\r\nfree_space -= (IH_SIZE * cpy_num);\r\nset_blkh_free_space(blkh, free_space);\r\nj = location = (dest_before == 0) ? dest->b_size : ih_location(ih - 1);\r\nfor (i = dest_before; i < nr + cpy_num; i++) {\r\nlocation -= ih_item_len(ih + i - dest_before);\r\nput_ih_location(ih + i - dest_before, location);\r\n}\r\nlast_loc = ih_location(&ih[nr + cpy_num - 1 - dest_before]);\r\nlast_inserted_loc = ih_location(&ih[cpy_num - 1]);\r\nRFALSE(free_space < j - last_inserted_loc,\r\n"vs-10150: not enough free space for items %d (needed %d)",\r\nfree_space, j - last_inserted_loc);\r\nmemmove(dest->b_data + last_loc,\r\ndest->b_data + last_loc + j - last_inserted_loc,\r\nlast_inserted_loc - last_loc);\r\nmemcpy(dest->b_data + last_inserted_loc,\r\nitem_body(src, (first + cpy_num - 1)),\r\nj - last_inserted_loc);\r\nset_blkh_nr_item(blkh, nr + cpy_num);\r\nset_blkh_free_space(blkh, free_space - (j - last_inserted_loc));\r\ndo_balance_mark_leaf_dirty(dest_bi->tb, dest, 0);\r\nif (dest_bi->bi_parent) {\r\nstruct disk_child *t_dc;\r\nt_dc = B_N_CHILD(dest_bi->bi_parent, dest_bi->bi_position);\r\nRFALSE(dc_block_number(t_dc) != dest->b_blocknr,\r\n"vs-10160: block number in bh does not match to field in disk_child structure %lu and %lu",\r\n(long unsigned)dest->b_blocknr,\r\n(long unsigned)dc_block_number(t_dc));\r\nput_dc_size(t_dc,\r\ndc_size(t_dc) + (j - last_inserted_loc +\r\nIH_SIZE * cpy_num));\r\ndo_balance_mark_internal_dirty(dest_bi->tb, dest_bi->bi_parent,\r\n0);\r\n}\r\n}\r\nstatic void leaf_item_bottle(struct buffer_info *dest_bi,\r\nstruct buffer_head *src, int last_first,\r\nint item_num, int cpy_bytes)\r\n{\r\nstruct buffer_head *dest = dest_bi->bi_bh;\r\nstruct item_head *ih;\r\nRFALSE(cpy_bytes == -1,\r\n"vs-10170: bytes == - 1 means: do not split item");\r\nif (last_first == FIRST_TO_LAST) {\r\nih = item_head(src, item_num);\r\nif (is_direntry_le_ih(ih))\r\nleaf_copy_dir_entries(dest_bi, src, FIRST_TO_LAST,\r\nitem_num, 0, cpy_bytes);\r\nelse {\r\nstruct item_head n_ih;\r\nmemcpy(&n_ih, ih, IH_SIZE);\r\nput_ih_item_len(&n_ih, cpy_bytes);\r\nif (is_indirect_le_ih(ih)) {\r\nRFALSE(cpy_bytes == ih_item_len(ih)\r\n&& get_ih_free_space(ih),\r\n"vs-10180: when whole indirect item is bottle to left neighbor, it must have free_space==0 (not %lu)",\r\n(long unsigned)get_ih_free_space(ih));\r\nset_ih_free_space(&n_ih, 0);\r\n}\r\nRFALSE(op_is_left_mergeable(&ih->ih_key, src->b_size),\r\n"vs-10190: bad mergeability of item %h", ih);\r\nn_ih.ih_version = ih->ih_version;\r\nleaf_insert_into_buf(dest_bi, B_NR_ITEMS(dest), &n_ih,\r\nitem_body(src, item_num), 0);\r\n}\r\n} else {\r\nih = item_head(src, item_num);\r\nif (is_direntry_le_ih(ih))\r\nleaf_copy_dir_entries(dest_bi, src, LAST_TO_FIRST,\r\nitem_num,\r\nih_entry_count(ih) - cpy_bytes,\r\ncpy_bytes);\r\nelse {\r\nstruct item_head n_ih;\r\nmemcpy(&n_ih.ih_key, &ih->ih_key, KEY_SIZE);\r\nn_ih.ih_version = ih->ih_version;\r\nif (is_direct_le_ih(ih)) {\r\nset_le_ih_k_offset(&n_ih,\r\nle_ih_k_offset(ih) +\r\nih_item_len(ih) - cpy_bytes);\r\nset_le_ih_k_type(&n_ih, TYPE_DIRECT);\r\nset_ih_free_space(&n_ih, MAX_US_INT);\r\n} else {\r\nRFALSE(!cpy_bytes && get_ih_free_space(ih),\r\n"vs-10200: ih->ih_free_space must be 0 when indirect item will be appended");\r\nset_le_ih_k_offset(&n_ih,\r\nle_ih_k_offset(ih) +\r\n(ih_item_len(ih) -\r\ncpy_bytes) / UNFM_P_SIZE *\r\ndest->b_size);\r\nset_le_ih_k_type(&n_ih, TYPE_INDIRECT);\r\nset_ih_free_space(&n_ih, get_ih_free_space(ih));\r\n}\r\nput_ih_item_len(&n_ih, cpy_bytes);\r\nn_ih.ih_version = ih->ih_version;\r\nleaf_insert_into_buf(dest_bi, 0, &n_ih,\r\nitem_body(src, item_num) +\r\nih_item_len(ih) - cpy_bytes, 0);\r\n}\r\n}\r\n}\r\nstatic int leaf_copy_items(struct buffer_info *dest_bi, struct buffer_head *src,\r\nint last_first, int cpy_num, int cpy_bytes)\r\n{\r\nstruct buffer_head *dest;\r\nint pos, i, src_nr_item, bytes;\r\ndest = dest_bi->bi_bh;\r\nRFALSE(!dest || !src, "vs-10210: !dest || !src");\r\nRFALSE(last_first != FIRST_TO_LAST && last_first != LAST_TO_FIRST,\r\n"vs-10220:last_first != FIRST_TO_LAST && last_first != LAST_TO_FIRST");\r\nRFALSE(B_NR_ITEMS(src) < cpy_num,\r\n"vs-10230: No enough items: %d, req. %d", B_NR_ITEMS(src),\r\ncpy_num);\r\nRFALSE(cpy_num < 0, "vs-10240: cpy_num < 0 (%d)", cpy_num);\r\nif (cpy_num == 0)\r\nreturn 0;\r\nif (last_first == FIRST_TO_LAST) {\r\npos = 0;\r\nif (cpy_num == 1)\r\nbytes = cpy_bytes;\r\nelse\r\nbytes = -1;\r\ni = leaf_copy_boundary_item(dest_bi, src, FIRST_TO_LAST, bytes);\r\ncpy_num -= i;\r\nif (cpy_num == 0)\r\nreturn i;\r\npos += i;\r\nif (cpy_bytes == -1)\r\nleaf_copy_items_entirely(dest_bi, src, FIRST_TO_LAST,\r\npos, cpy_num);\r\nelse {\r\nleaf_copy_items_entirely(dest_bi, src, FIRST_TO_LAST,\r\npos, cpy_num - 1);\r\nleaf_item_bottle(dest_bi, src, FIRST_TO_LAST,\r\ncpy_num + pos - 1, cpy_bytes);\r\n}\r\n} else {\r\nsrc_nr_item = B_NR_ITEMS(src);\r\nif (cpy_num == 1)\r\nbytes = cpy_bytes;\r\nelse\r\nbytes = -1;\r\ni = leaf_copy_boundary_item(dest_bi, src, LAST_TO_FIRST, bytes);\r\ncpy_num -= i;\r\nif (cpy_num == 0)\r\nreturn i;\r\npos = src_nr_item - cpy_num - i;\r\nif (cpy_bytes == -1) {\r\nleaf_copy_items_entirely(dest_bi, src, LAST_TO_FIRST,\r\npos, cpy_num);\r\n} else {\r\nleaf_copy_items_entirely(dest_bi, src, LAST_TO_FIRST,\r\npos + 1, cpy_num - 1);\r\nleaf_item_bottle(dest_bi, src, LAST_TO_FIRST, pos,\r\ncpy_bytes);\r\n}\r\n}\r\nreturn i;\r\n}\r\nstatic void leaf_define_dest_src_infos(int shift_mode, struct tree_balance *tb,\r\nstruct buffer_info *dest_bi,\r\nstruct buffer_info *src_bi,\r\nint *first_last,\r\nstruct buffer_head *Snew)\r\n{\r\nmemset(dest_bi, 0, sizeof(struct buffer_info));\r\nmemset(src_bi, 0, sizeof(struct buffer_info));\r\nswitch (shift_mode) {\r\ncase LEAF_FROM_S_TO_L:\r\nsrc_bi->tb = tb;\r\nsrc_bi->bi_bh = PATH_PLAST_BUFFER(tb->tb_path);\r\nsrc_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, 0);\r\nsrc_bi->bi_position = PATH_H_B_ITEM_ORDER(tb->tb_path, 0);\r\ndest_bi->tb = tb;\r\ndest_bi->bi_bh = tb->L[0];\r\ndest_bi->bi_parent = tb->FL[0];\r\ndest_bi->bi_position = get_left_neighbor_position(tb, 0);\r\n*first_last = FIRST_TO_LAST;\r\nbreak;\r\ncase LEAF_FROM_S_TO_R:\r\nsrc_bi->tb = tb;\r\nsrc_bi->bi_bh = PATH_PLAST_BUFFER(tb->tb_path);\r\nsrc_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, 0);\r\nsrc_bi->bi_position = PATH_H_B_ITEM_ORDER(tb->tb_path, 0);\r\ndest_bi->tb = tb;\r\ndest_bi->bi_bh = tb->R[0];\r\ndest_bi->bi_parent = tb->FR[0];\r\ndest_bi->bi_position = get_right_neighbor_position(tb, 0);\r\n*first_last = LAST_TO_FIRST;\r\nbreak;\r\ncase LEAF_FROM_R_TO_L:\r\nsrc_bi->tb = tb;\r\nsrc_bi->bi_bh = tb->R[0];\r\nsrc_bi->bi_parent = tb->FR[0];\r\nsrc_bi->bi_position = get_right_neighbor_position(tb, 0);\r\ndest_bi->tb = tb;\r\ndest_bi->bi_bh = tb->L[0];\r\ndest_bi->bi_parent = tb->FL[0];\r\ndest_bi->bi_position = get_left_neighbor_position(tb, 0);\r\n*first_last = FIRST_TO_LAST;\r\nbreak;\r\ncase LEAF_FROM_L_TO_R:\r\nsrc_bi->tb = tb;\r\nsrc_bi->bi_bh = tb->L[0];\r\nsrc_bi->bi_parent = tb->FL[0];\r\nsrc_bi->bi_position = get_left_neighbor_position(tb, 0);\r\ndest_bi->tb = tb;\r\ndest_bi->bi_bh = tb->R[0];\r\ndest_bi->bi_parent = tb->FR[0];\r\ndest_bi->bi_position = get_right_neighbor_position(tb, 0);\r\n*first_last = LAST_TO_FIRST;\r\nbreak;\r\ncase LEAF_FROM_S_TO_SNEW:\r\nsrc_bi->tb = tb;\r\nsrc_bi->bi_bh = PATH_PLAST_BUFFER(tb->tb_path);\r\nsrc_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, 0);\r\nsrc_bi->bi_position = PATH_H_B_ITEM_ORDER(tb->tb_path, 0);\r\ndest_bi->tb = tb;\r\ndest_bi->bi_bh = Snew;\r\ndest_bi->bi_parent = NULL;\r\ndest_bi->bi_position = 0;\r\n*first_last = LAST_TO_FIRST;\r\nbreak;\r\ndefault:\r\nreiserfs_panic(sb_from_bi(src_bi), "vs-10250",\r\n"shift type is unknown (%d)", shift_mode);\r\n}\r\nRFALSE(!src_bi->bi_bh || !dest_bi->bi_bh,\r\n"vs-10260: mode==%d, source (%p) or dest (%p) buffer is initialized incorrectly",\r\nshift_mode, src_bi->bi_bh, dest_bi->bi_bh);\r\n}\r\nint leaf_move_items(int shift_mode, struct tree_balance *tb, int mov_num,\r\nint mov_bytes, struct buffer_head *Snew)\r\n{\r\nint ret_value;\r\nstruct buffer_info dest_bi, src_bi;\r\nint first_last;\r\nleaf_define_dest_src_infos(shift_mode, tb, &dest_bi, &src_bi,\r\n&first_last, Snew);\r\nret_value =\r\nleaf_copy_items(&dest_bi, src_bi.bi_bh, first_last, mov_num,\r\nmov_bytes);\r\nleaf_delete_items(&src_bi, first_last,\r\n(first_last ==\r\nFIRST_TO_LAST) ? 0 : (B_NR_ITEMS(src_bi.bi_bh) -\r\nmov_num), mov_num, mov_bytes);\r\nreturn ret_value;\r\n}\r\nint leaf_shift_left(struct tree_balance *tb, int shift_num, int shift_bytes)\r\n{\r\nstruct buffer_head *S0 = PATH_PLAST_BUFFER(tb->tb_path);\r\nint i;\r\ni = leaf_move_items(LEAF_FROM_S_TO_L, tb, shift_num, shift_bytes, NULL);\r\nif (shift_num) {\r\nif (B_NR_ITEMS(S0) == 0) {\r\nRFALSE(shift_bytes != -1,\r\n"vs-10270: S0 is empty now, but shift_bytes != -1 (%d)",\r\nshift_bytes);\r\n#ifdef CONFIG_REISERFS_CHECK\r\nif (tb->tb_mode == M_PASTE || tb->tb_mode == M_INSERT) {\r\nprint_cur_tb("vs-10275");\r\nreiserfs_panic(tb->tb_sb, "vs-10275",\r\n"balance condition corrupted "\r\n"(%c)", tb->tb_mode);\r\n}\r\n#endif\r\nif (PATH_H_POSITION(tb->tb_path, 1) == 0)\r\nreplace_key(tb, tb->CFL[0], tb->lkey[0],\r\nPATH_H_PPARENT(tb->tb_path, 0), 0);\r\n} else {\r\nreplace_key(tb, tb->CFL[0], tb->lkey[0], S0, 0);\r\nRFALSE((shift_bytes != -1 &&\r\n!(is_direntry_le_ih(item_head(S0, 0))\r\n&& !ih_entry_count(item_head(S0, 0)))) &&\r\n(!op_is_left_mergeable\r\n(leaf_key(S0, 0), S0->b_size)),\r\n"vs-10280: item must be mergeable");\r\n}\r\n}\r\nreturn i;\r\n}\r\nint leaf_shift_right(struct tree_balance *tb, int shift_num, int shift_bytes)\r\n{\r\nint ret_value;\r\nret_value =\r\nleaf_move_items(LEAF_FROM_S_TO_R, tb, shift_num, shift_bytes, NULL);\r\nif (shift_num) {\r\nreplace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);\r\n}\r\nreturn ret_value;\r\n}\r\nvoid leaf_delete_items(struct buffer_info *cur_bi, int last_first,\r\nint first, int del_num, int del_bytes)\r\n{\r\nstruct buffer_head *bh;\r\nint item_amount = B_NR_ITEMS(bh = cur_bi->bi_bh);\r\nRFALSE(!bh, "10155: bh is not defined");\r\nRFALSE(del_num < 0, "10160: del_num can not be < 0. del_num==%d",\r\ndel_num);\r\nRFALSE(first < 0\r\n|| first + del_num > item_amount,\r\n"10165: invalid number of first item to be deleted (%d) or "\r\n"no so much items (%d) to delete (only %d)", first,\r\nfirst + del_num, item_amount);\r\nif (del_num == 0)\r\nreturn;\r\nif (first == 0 && del_num == item_amount && del_bytes == -1) {\r\nmake_empty_node(cur_bi);\r\ndo_balance_mark_leaf_dirty(cur_bi->tb, bh, 0);\r\nreturn;\r\n}\r\nif (del_bytes == -1)\r\nleaf_delete_items_entirely(cur_bi, first, del_num);\r\nelse {\r\nif (last_first == FIRST_TO_LAST) {\r\nleaf_delete_items_entirely(cur_bi, first, del_num - 1);\r\nleaf_cut_from_buffer(cur_bi, 0, 0, del_bytes);\r\n} else {\r\nstruct item_head *ih;\r\nint len;\r\nleaf_delete_items_entirely(cur_bi, first + 1,\r\ndel_num - 1);\r\nih = item_head(bh, B_NR_ITEMS(bh) - 1);\r\nif (is_direntry_le_ih(ih))\r\nlen = ih_entry_count(ih);\r\nelse\r\nlen = ih_item_len(ih);\r\nleaf_cut_from_buffer(cur_bi, B_NR_ITEMS(bh) - 1,\r\nlen - del_bytes, del_bytes);\r\n}\r\n}\r\n}\r\nvoid leaf_insert_into_buf(struct buffer_info *bi, int before,\r\nstruct item_head * const inserted_item_ih,\r\nconst char * const inserted_item_body,\r\nint zeros_number)\r\n{\r\nstruct buffer_head *bh = bi->bi_bh;\r\nint nr, free_space;\r\nstruct block_head *blkh;\r\nstruct item_head *ih;\r\nint i;\r\nint last_loc, unmoved_loc;\r\nchar *to;\r\nblkh = B_BLK_HEAD(bh);\r\nnr = blkh_nr_item(blkh);\r\nfree_space = blkh_free_space(blkh);\r\nRFALSE(free_space < ih_item_len(inserted_item_ih) + IH_SIZE,\r\n"vs-10170: not enough free space in block %z, new item %h",\r\nbh, inserted_item_ih);\r\nRFALSE(zeros_number > ih_item_len(inserted_item_ih),\r\n"vs-10172: zero number == %d, item length == %d",\r\nzeros_number, ih_item_len(inserted_item_ih));\r\nih = item_head(bh, before);\r\nlast_loc = nr ? ih_location(&ih[nr - before - 1]) : bh->b_size;\r\nunmoved_loc = before ? ih_location(ih - 1) : bh->b_size;\r\nmemmove(bh->b_data + last_loc - ih_item_len(inserted_item_ih),\r\nbh->b_data + last_loc, unmoved_loc - last_loc);\r\nto = bh->b_data + unmoved_loc - ih_item_len(inserted_item_ih);\r\nmemset(to, 0, zeros_number);\r\nto += zeros_number;\r\nif (inserted_item_body)\r\nmemmove(to, inserted_item_body,\r\nih_item_len(inserted_item_ih) - zeros_number);\r\nelse\r\nmemset(to, '\0', ih_item_len(inserted_item_ih) - zeros_number);\r\nmemmove(ih + 1, ih, IH_SIZE * (nr - before));\r\nmemmove(ih, inserted_item_ih, IH_SIZE);\r\nfor (i = before; i < nr + 1; i++) {\r\nunmoved_loc -= ih_item_len(&ih[i - before]);\r\nput_ih_location(&ih[i - before], unmoved_loc);\r\n}\r\nset_blkh_nr_item(blkh, blkh_nr_item(blkh) + 1);\r\nset_blkh_free_space(blkh,\r\nfree_space - (IH_SIZE +\r\nih_item_len(inserted_item_ih)));\r\ndo_balance_mark_leaf_dirty(bi->tb, bh, 1);\r\nif (bi->bi_parent) {\r\nstruct disk_child *t_dc;\r\nt_dc = B_N_CHILD(bi->bi_parent, bi->bi_position);\r\nput_dc_size(t_dc,\r\ndc_size(t_dc) + (IH_SIZE +\r\nih_item_len(inserted_item_ih)));\r\ndo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\r\n}\r\n}\r\nvoid leaf_paste_in_buffer(struct buffer_info *bi, int affected_item_num,\r\nint pos_in_item, int paste_size,\r\nconst char *body, int zeros_number)\r\n{\r\nstruct buffer_head *bh = bi->bi_bh;\r\nint nr, free_space;\r\nstruct block_head *blkh;\r\nstruct item_head *ih;\r\nint i;\r\nint last_loc, unmoved_loc;\r\nblkh = B_BLK_HEAD(bh);\r\nnr = blkh_nr_item(blkh);\r\nfree_space = blkh_free_space(blkh);\r\nRFALSE(free_space < paste_size,\r\n"vs-10175: not enough free space: needed %d, available %d",\r\npaste_size, free_space);\r\n#ifdef CONFIG_REISERFS_CHECK\r\nif (zeros_number > paste_size) {\r\nstruct super_block *sb = NULL;\r\nif (bi && bi->tb)\r\nsb = bi->tb->tb_sb;\r\nprint_cur_tb("10177");\r\nreiserfs_panic(sb, "vs-10177",\r\n"zeros_number == %d, paste_size == %d",\r\nzeros_number, paste_size);\r\n}\r\n#endif\r\nih = item_head(bh, affected_item_num);\r\nlast_loc = ih_location(&ih[nr - affected_item_num - 1]);\r\nunmoved_loc = affected_item_num ? ih_location(ih - 1) : bh->b_size;\r\nmemmove(bh->b_data + last_loc - paste_size, bh->b_data + last_loc,\r\nunmoved_loc - last_loc);\r\nfor (i = affected_item_num; i < nr; i++)\r\nput_ih_location(&ih[i - affected_item_num],\r\nih_location(&ih[i - affected_item_num]) -\r\npaste_size);\r\nif (body) {\r\nif (!is_direntry_le_ih(ih)) {\r\nif (!pos_in_item) {\r\nmemmove(bh->b_data + ih_location(ih) +\r\npaste_size,\r\nbh->b_data + ih_location(ih),\r\nih_item_len(ih));\r\nmemset(bh->b_data + ih_location(ih), 0,\r\nzeros_number);\r\nmemcpy(bh->b_data + ih_location(ih) +\r\nzeros_number, body,\r\npaste_size - zeros_number);\r\n} else {\r\nmemset(bh->b_data + unmoved_loc - paste_size, 0,\r\nzeros_number);\r\nmemcpy(bh->b_data + unmoved_loc - paste_size +\r\nzeros_number, body,\r\npaste_size - zeros_number);\r\n}\r\n}\r\n} else\r\nmemset(bh->b_data + unmoved_loc - paste_size, '\0', paste_size);\r\nput_ih_item_len(ih, ih_item_len(ih) + paste_size);\r\nset_blkh_free_space(blkh, free_space - paste_size);\r\ndo_balance_mark_leaf_dirty(bi->tb, bh, 0);\r\nif (bi->bi_parent) {\r\nstruct disk_child *t_dc =\r\nB_N_CHILD(bi->bi_parent, bi->bi_position);\r\nput_dc_size(t_dc, dc_size(t_dc) + paste_size);\r\ndo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\r\n}\r\n}\r\nstatic int leaf_cut_entries(struct buffer_head *bh,\r\nstruct item_head *ih, int from, int del_count)\r\n{\r\nchar *item;\r\nstruct reiserfs_de_head *deh;\r\nint prev_record_offset;\r\nchar *prev_record;\r\nint cut_records_len;\r\nint i;\r\nRFALSE(!is_direntry_le_ih(ih), "10180: item is not directory item");\r\nRFALSE(ih_entry_count(ih) < from + del_count,\r\n"10185: item contains not enough entries: entry_count = %d, from = %d, to delete = %d",\r\nih_entry_count(ih), from, del_count);\r\nif (del_count == 0)\r\nreturn 0;\r\nitem = bh->b_data + ih_location(ih);\r\ndeh = B_I_DEH(bh, ih);\r\nprev_record_offset =\r\n(from ? deh_location(&deh[from - 1]) : ih_item_len(ih));\r\ncut_records_len = prev_record_offset -\r\ndeh_location(&deh[from + del_count - 1]);\r\nprev_record = item + prev_record_offset;\r\nfor (i = ih_entry_count(ih) - 1; i > from + del_count - 1; i--)\r\nput_deh_location(&deh[i],\r\ndeh_location(&deh[i]) -\r\n(DEH_SIZE * del_count));\r\nfor (i = 0; i < from; i++)\r\nput_deh_location(&deh[i],\r\ndeh_location(&deh[i]) - (DEH_SIZE * del_count +\r\ncut_records_len));\r\nput_ih_entry_count(ih, ih_entry_count(ih) - del_count);\r\nmemmove((char *)(deh + from),\r\ndeh + from + del_count,\r\nprev_record - cut_records_len - (char *)(deh + from +\r\ndel_count));\r\nmemmove(prev_record - cut_records_len - DEH_SIZE * del_count,\r\nprev_record, item + ih_item_len(ih) - prev_record);\r\nreturn DEH_SIZE * del_count + cut_records_len;\r\n}\r\nvoid leaf_cut_from_buffer(struct buffer_info *bi, int cut_item_num,\r\nint pos_in_item, int cut_size)\r\n{\r\nint nr;\r\nstruct buffer_head *bh = bi->bi_bh;\r\nstruct block_head *blkh;\r\nstruct item_head *ih;\r\nint last_loc, unmoved_loc;\r\nint i;\r\nblkh = B_BLK_HEAD(bh);\r\nnr = blkh_nr_item(blkh);\r\nih = item_head(bh, cut_item_num);\r\nif (is_direntry_le_ih(ih)) {\r\ncut_size = leaf_cut_entries(bh, ih, pos_in_item, cut_size);\r\nif (pos_in_item == 0) {\r\nRFALSE(cut_item_num,\r\n"when 0-th enrty of item is cut, that item must be first in the node, not %d-th",\r\ncut_item_num);\r\nset_le_ih_k_offset(ih, deh_offset(B_I_DEH(bh, ih)));\r\n}\r\n} else {\r\nRFALSE(is_statdata_le_ih(ih), "10195: item is stat data");\r\nRFALSE(pos_in_item && pos_in_item + cut_size != ih_item_len(ih),\r\n"10200: invalid offset (%lu) or trunc_size (%lu) or ih_item_len (%lu)",\r\n(long unsigned)pos_in_item, (long unsigned)cut_size,\r\n(long unsigned)ih_item_len(ih));\r\nif (pos_in_item == 0) {\r\nmemmove(bh->b_data + ih_location(ih),\r\nbh->b_data + ih_location(ih) + cut_size,\r\nih_item_len(ih) - cut_size);\r\nif (is_direct_le_ih(ih))\r\nset_le_ih_k_offset(ih,\r\nle_ih_k_offset(ih) +\r\ncut_size);\r\nelse {\r\nset_le_ih_k_offset(ih,\r\nle_ih_k_offset(ih) +\r\n(cut_size / UNFM_P_SIZE) *\r\nbh->b_size);\r\nRFALSE(ih_item_len(ih) == cut_size\r\n&& get_ih_free_space(ih),\r\n"10205: invalid ih_free_space (%h)", ih);\r\n}\r\n}\r\n}\r\nlast_loc = ih_location(&ih[nr - cut_item_num - 1]);\r\nunmoved_loc = cut_item_num ? ih_location(ih - 1) : bh->b_size;\r\nmemmove(bh->b_data + last_loc + cut_size, bh->b_data + last_loc,\r\nunmoved_loc - last_loc - cut_size);\r\nput_ih_item_len(ih, ih_item_len(ih) - cut_size);\r\nif (is_indirect_le_ih(ih)) {\r\nif (pos_in_item)\r\nset_ih_free_space(ih, 0);\r\n}\r\nfor (i = cut_item_num; i < nr; i++)\r\nput_ih_location(&ih[i - cut_item_num],\r\nih_location(&ih[i - cut_item_num]) + cut_size);\r\nset_blkh_free_space(blkh, blkh_free_space(blkh) + cut_size);\r\ndo_balance_mark_leaf_dirty(bi->tb, bh, 0);\r\nif (bi->bi_parent) {\r\nstruct disk_child *t_dc;\r\nt_dc = B_N_CHILD(bi->bi_parent, bi->bi_position);\r\nput_dc_size(t_dc, dc_size(t_dc) - cut_size);\r\ndo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\r\n}\r\n}\r\nstatic void leaf_delete_items_entirely(struct buffer_info *bi,\r\nint first, int del_num)\r\n{\r\nstruct buffer_head *bh = bi->bi_bh;\r\nint nr;\r\nint i, j;\r\nint last_loc, last_removed_loc;\r\nstruct block_head *blkh;\r\nstruct item_head *ih;\r\nRFALSE(bh == NULL, "10210: buffer is 0");\r\nRFALSE(del_num < 0, "10215: del_num less than 0 (%d)", del_num);\r\nif (del_num == 0)\r\nreturn;\r\nblkh = B_BLK_HEAD(bh);\r\nnr = blkh_nr_item(blkh);\r\nRFALSE(first < 0 || first + del_num > nr,\r\n"10220: first=%d, number=%d, there is %d items", first, del_num,\r\nnr);\r\nif (first == 0 && del_num == nr) {\r\nmake_empty_node(bi);\r\ndo_balance_mark_leaf_dirty(bi->tb, bh, 0);\r\nreturn;\r\n}\r\nih = item_head(bh, first);\r\nj = (first == 0) ? bh->b_size : ih_location(ih - 1);\r\nlast_loc = ih_location(&ih[nr - 1 - first]);\r\nlast_removed_loc = ih_location(&ih[del_num - 1]);\r\nmemmove(bh->b_data + last_loc + j - last_removed_loc,\r\nbh->b_data + last_loc, last_removed_loc - last_loc);\r\nmemmove(ih, ih + del_num, (nr - first - del_num) * IH_SIZE);\r\nfor (i = first; i < nr - del_num; i++)\r\nput_ih_location(&ih[i - first],\r\nih_location(&ih[i - first]) + (j -\r\nlast_removed_loc));\r\nset_blkh_nr_item(blkh, blkh_nr_item(blkh) - del_num);\r\nset_blkh_free_space(blkh,\r\nblkh_free_space(blkh) + (j - last_removed_loc +\r\nIH_SIZE * del_num));\r\ndo_balance_mark_leaf_dirty(bi->tb, bh, 0);\r\nif (bi->bi_parent) {\r\nstruct disk_child *t_dc =\r\nB_N_CHILD(bi->bi_parent, bi->bi_position);\r\nput_dc_size(t_dc,\r\ndc_size(t_dc) - (j - last_removed_loc +\r\nIH_SIZE * del_num));\r\ndo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\r\n}\r\n}\r\nvoid leaf_paste_entries(struct buffer_info *bi,\r\nint item_num,\r\nint before,\r\nint new_entry_count,\r\nstruct reiserfs_de_head *new_dehs,\r\nconst char *records, int paste_size)\r\n{\r\nstruct item_head *ih;\r\nchar *item;\r\nstruct reiserfs_de_head *deh;\r\nchar *insert_point;\r\nint i, old_entry_num;\r\nstruct buffer_head *bh = bi->bi_bh;\r\nif (new_entry_count == 0)\r\nreturn;\r\nih = item_head(bh, item_num);\r\nRFALSE(!is_direntry_le_ih(ih), "10225: item is not directory item");\r\nRFALSE(ih_entry_count(ih) < before,\r\n"10230: there are no entry we paste entries before. entry_count = %d, before = %d",\r\nih_entry_count(ih), before);\r\nitem = bh->b_data + ih_location(ih);\r\ndeh = B_I_DEH(bh, ih);\r\ninsert_point =\r\nitem +\r\n(before ? deh_location(&deh[before - 1])\r\n: (ih_item_len(ih) - paste_size));\r\nfor (i = ih_entry_count(ih) - 1; i >= before; i--)\r\nput_deh_location(&deh[i],\r\ndeh_location(&deh[i]) +\r\n(DEH_SIZE * new_entry_count));\r\nfor (i = 0; i < before; i++)\r\nput_deh_location(&deh[i],\r\ndeh_location(&deh[i]) + paste_size);\r\nold_entry_num = ih_entry_count(ih);\r\nput_ih_entry_count(ih, ih_entry_count(ih) + new_entry_count);\r\nmemmove(insert_point + paste_size, insert_point,\r\nitem + (ih_item_len(ih) - paste_size) - insert_point);\r\nmemcpy(insert_point + DEH_SIZE * new_entry_count, records,\r\npaste_size - DEH_SIZE * new_entry_count);\r\ndeh += before;\r\nmemmove((char *)(deh + new_entry_count), deh,\r\ninsert_point - (char *)deh);\r\ndeh = (struct reiserfs_de_head *)((char *)deh);\r\nmemcpy(deh, new_dehs, DEH_SIZE * new_entry_count);\r\nfor (i = 0; i < new_entry_count; i++) {\r\nput_deh_location(&deh[i],\r\ndeh_location(&deh[i]) +\r\n(-deh_location\r\n(&new_dehs[new_entry_count - 1]) +\r\ninsert_point + DEH_SIZE * new_entry_count -\r\nitem));\r\n}\r\nif (!before) {\r\nset_le_ih_k_offset(ih, deh_offset(new_dehs));\r\n}\r\n#ifdef CONFIG_REISERFS_CHECK\r\n{\r\nint prev, next;\r\ndeh = B_I_DEH(bh, ih);\r\nfor (i = 0; i < ih_entry_count(ih); i++) {\r\nnext =\r\n(i <\r\nih_entry_count(ih) -\r\n1) ? deh_location(&deh[i + 1]) : 0;\r\nprev = (i != 0) ? deh_location(&deh[i - 1]) : 0;\r\nif (prev && prev <= deh_location(&deh[i]))\r\nreiserfs_error(sb_from_bi(bi), "vs-10240",\r\n"directory item (%h) "\r\n"corrupted (prev %a, "\r\n"cur(%d) %a)",\r\nih, deh + i - 1, i, deh + i);\r\nif (next && next >= deh_location(&deh[i]))\r\nreiserfs_error(sb_from_bi(bi), "vs-10250",\r\n"directory item (%h) "\r\n"corrupted (cur(%d) %a, "\r\n"next %a)",\r\nih, i, deh + i, deh + i + 1);\r\n}\r\n}\r\n#endif\r\n}
