static u32 get_bus_freq(void)\r\n{\r\nstruct device_node *soc;\r\nu32 sysfreq;\r\nstruct clk *pltclk;\r\nint ret;\r\nsoc = of_find_node_by_type(NULL, "soc");\r\nif (soc) {\r\nret = of_property_read_u32(soc, "bus-frequency", &sysfreq);\r\nof_node_put(soc);\r\nif (!ret)\r\nreturn sysfreq;\r\n}\r\npltclk = clk_get(NULL, "cg-pll0-div1");\r\nif (IS_ERR(pltclk)) {\r\npr_err("%s: can't get bus frequency %ld\n",\r\n__func__, PTR_ERR(pltclk));\r\nreturn PTR_ERR(pltclk);\r\n}\r\nreturn clk_get_rate(pltclk);\r\n}\r\nstatic struct clk *cpu_to_clk(int cpu)\r\n{\r\nstruct device_node *np;\r\nstruct clk *clk;\r\nif (!cpu_present(cpu))\r\nreturn NULL;\r\nnp = of_get_cpu_node(cpu, NULL);\r\nif (!np)\r\nreturn NULL;\r\nclk = of_clk_get(np, 0);\r\nof_node_put(np);\r\nreturn clk;\r\n}\r\nstatic void set_affected_cpus(struct cpufreq_policy *policy)\r\n{\r\nstruct cpumask *dstp = policy->cpus;\r\nstruct clk *clk;\r\nint i;\r\nfor_each_present_cpu(i) {\r\nclk = cpu_to_clk(i);\r\nif (IS_ERR(clk)) {\r\npr_err("%s: no clock for cpu %d\n", __func__, i);\r\ncontinue;\r\n}\r\nif (clk_is_match(policy->clk, clk))\r\ncpumask_set_cpu(i, dstp);\r\n}\r\n}\r\nstatic void freq_table_redup(struct cpufreq_frequency_table *freq_table,\r\nint count)\r\n{\r\nint i, j;\r\nfor (i = 1; i < count; i++) {\r\nfor (j = 0; j < i; j++) {\r\nif (freq_table[j].frequency == CPUFREQ_ENTRY_INVALID ||\r\nfreq_table[j].frequency !=\r\nfreq_table[i].frequency)\r\ncontinue;\r\nfreq_table[i].frequency = CPUFREQ_ENTRY_INVALID;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void freq_table_sort(struct cpufreq_frequency_table *freq_table,\r\nint count)\r\n{\r\nint i, j, ind;\r\nunsigned int freq, max_freq;\r\nstruct cpufreq_frequency_table table;\r\nfor (i = 0; i < count - 1; i++) {\r\nmax_freq = freq_table[i].frequency;\r\nind = i;\r\nfor (j = i + 1; j < count; j++) {\r\nfreq = freq_table[j].frequency;\r\nif (freq == CPUFREQ_ENTRY_INVALID ||\r\nfreq <= max_freq)\r\ncontinue;\r\nind = j;\r\nmax_freq = freq;\r\n}\r\nif (ind != i) {\r\ntable.driver_data = freq_table[i].driver_data;\r\ntable.frequency = freq_table[i].frequency;\r\nfreq_table[i].driver_data = freq_table[ind].driver_data;\r\nfreq_table[i].frequency = freq_table[ind].frequency;\r\nfreq_table[ind].driver_data = table.driver_data;\r\nfreq_table[ind].frequency = table.frequency;\r\n}\r\n}\r\n}\r\nstatic int qoriq_cpufreq_cpu_init(struct cpufreq_policy *policy)\r\n{\r\nstruct device_node *np;\r\nint i, count, ret;\r\nu32 freq;\r\nstruct clk *clk;\r\nconst struct clk_hw *hwclk;\r\nstruct cpufreq_frequency_table *table;\r\nstruct cpu_data *data;\r\nunsigned int cpu = policy->cpu;\r\nu64 u64temp;\r\nnp = of_get_cpu_node(cpu, NULL);\r\nif (!np)\r\nreturn -ENODEV;\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\ngoto err_np;\r\npolicy->clk = of_clk_get(np, 0);\r\nif (IS_ERR(policy->clk)) {\r\npr_err("%s: no clock information\n", __func__);\r\ngoto err_nomem2;\r\n}\r\nhwclk = __clk_get_hw(policy->clk);\r\ncount = clk_hw_get_num_parents(hwclk);\r\ndata->pclk = kcalloc(count, sizeof(struct clk *), GFP_KERNEL);\r\nif (!data->pclk) {\r\npr_err("%s: no memory\n", __func__);\r\ngoto err_nomem2;\r\n}\r\ntable = kcalloc(count + 1, sizeof(*table), GFP_KERNEL);\r\nif (!table) {\r\npr_err("%s: no memory\n", __func__);\r\ngoto err_pclk;\r\n}\r\nfor (i = 0; i < count; i++) {\r\nclk = clk_hw_get_parent_by_index(hwclk, i)->clk;\r\ndata->pclk[i] = clk;\r\nfreq = clk_get_rate(clk);\r\ntable[i].frequency = freq / 1000;\r\ntable[i].driver_data = i;\r\n}\r\nfreq_table_redup(table, count);\r\nfreq_table_sort(table, count);\r\ntable[i].frequency = CPUFREQ_TABLE_END;\r\nret = cpufreq_table_validate_and_show(policy, table);\r\nif (ret) {\r\npr_err("invalid frequency table: %d\n", ret);\r\ngoto err_nomem1;\r\n}\r\ndata->table = table;\r\nset_affected_cpus(policy);\r\npolicy->driver_data = data;\r\nu64temp = 12ULL * NSEC_PER_SEC;\r\ndo_div(u64temp, get_bus_freq());\r\npolicy->cpuinfo.transition_latency = u64temp + 1;\r\nof_node_put(np);\r\nreturn 0;\r\nerr_nomem1:\r\nkfree(table);\r\nerr_pclk:\r\nkfree(data->pclk);\r\nerr_nomem2:\r\nkfree(data);\r\nerr_np:\r\nof_node_put(np);\r\nreturn -ENODEV;\r\n}\r\nstatic int qoriq_cpufreq_cpu_exit(struct cpufreq_policy *policy)\r\n{\r\nstruct cpu_data *data = policy->driver_data;\r\ncpufreq_cooling_unregister(data->cdev);\r\nkfree(data->pclk);\r\nkfree(data->table);\r\nkfree(data);\r\npolicy->driver_data = NULL;\r\nreturn 0;\r\n}\r\nstatic int qoriq_cpufreq_target(struct cpufreq_policy *policy,\r\nunsigned int index)\r\n{\r\nstruct clk *parent;\r\nstruct cpu_data *data = policy->driver_data;\r\nparent = data->pclk[data->table[index].driver_data];\r\nreturn clk_set_parent(policy->clk, parent);\r\n}\r\nstatic void qoriq_cpufreq_ready(struct cpufreq_policy *policy)\r\n{\r\nstruct cpu_data *cpud = policy->driver_data;\r\nstruct device_node *np = of_get_cpu_node(policy->cpu, NULL);\r\nif (of_find_property(np, "#cooling-cells", NULL)) {\r\ncpud->cdev = of_cpufreq_cooling_register(np, policy);\r\nif (IS_ERR(cpud->cdev) && PTR_ERR(cpud->cdev) != -ENOSYS) {\r\npr_err("cpu%d is not running as cooling device: %ld\n",\r\npolicy->cpu, PTR_ERR(cpud->cdev));\r\ncpud->cdev = NULL;\r\n}\r\n}\r\nof_node_put(np);\r\n}\r\nstatic int __init qoriq_cpufreq_init(void)\r\n{\r\nint ret;\r\nstruct device_node *np;\r\nconst struct of_device_id *match;\r\nconst struct soc_data *data;\r\nnp = of_find_matching_node(NULL, node_matches);\r\nif (!np)\r\nreturn -ENODEV;\r\nmatch = of_match_node(node_matches, np);\r\ndata = match->data;\r\nof_node_put(np);\r\nif (data && data->flags & SOC_BLACKLIST)\r\nreturn -ENODEV;\r\nret = cpufreq_register_driver(&qoriq_cpufreq_driver);\r\nif (!ret)\r\npr_info("Freescale QorIQ CPU frequency scaling driver\n");\r\nreturn ret;\r\n}\r\nstatic void __exit qoriq_cpufreq_exit(void)\r\n{\r\ncpufreq_unregister_driver(&qoriq_cpufreq_driver);\r\n}
