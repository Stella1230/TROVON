int msp_reset(struct i2c_client *client)\r\n{\r\nstatic u8 reset_off[3] = { I2C_MSP_CONTROL, 0x80, 0x00 };\r\nstatic u8 reset_on[3] = { I2C_MSP_CONTROL, 0x00, 0x00 };\r\nstatic u8 write[3] = { I2C_MSP_DSP + 1, 0x00, 0x1e };\r\nu8 read[2];\r\nstruct i2c_msg reset[2] = {\r\n{\r\n.addr = client->addr,\r\n.flags = I2C_M_IGNORE_NAK,\r\n.len = 3,\r\n.buf = reset_off\r\n},\r\n{\r\n.addr = client->addr,\r\n.flags = I2C_M_IGNORE_NAK,\r\n.len = 3,\r\n.buf = reset_on\r\n},\r\n};\r\nstruct i2c_msg test[2] = {\r\n{\r\n.addr = client->addr,\r\n.len = 3,\r\n.buf = write\r\n},\r\n{\r\n.addr = client->addr,\r\n.flags = I2C_M_RD,\r\n.len = 2,\r\n.buf = read\r\n},\r\n};\r\ndev_dbg_lvl(&client->dev, 3, msp_debug, "msp_reset\n");\r\nif (i2c_transfer(client->adapter, &reset[0], 1) != 1 ||\r\ni2c_transfer(client->adapter, &reset[1], 1) != 1 ||\r\ni2c_transfer(client->adapter, test, 2) != 2) {\r\ndev_err(&client->dev, "chip reset failed\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int msp_read(struct i2c_client *client, int dev, int addr)\r\n{\r\nint err, retval;\r\nu8 write[3];\r\nu8 read[2];\r\nstruct i2c_msg msgs[2] = {\r\n{\r\n.addr = client->addr,\r\n.len = 3,\r\n.buf = write\r\n},\r\n{\r\n.addr = client->addr,\r\n.flags = I2C_M_RD,\r\n.len = 2,\r\n.buf = read\r\n}\r\n};\r\nwrite[0] = dev + 1;\r\nwrite[1] = addr >> 8;\r\nwrite[2] = addr & 0xff;\r\nfor (err = 0; err < 3; err++) {\r\nif (i2c_transfer(client->adapter, msgs, 2) == 2)\r\nbreak;\r\ndev_warn(&client->dev, "I/O error #%d (read 0x%02x/0x%02x)\n", err,\r\ndev, addr);\r\nschedule_timeout_interruptible(msecs_to_jiffies(10));\r\n}\r\nif (err == 3) {\r\ndev_warn(&client->dev, "resetting chip, sound will go off.\n");\r\nmsp_reset(client);\r\nreturn -1;\r\n}\r\nretval = read[0] << 8 | read[1];\r\ndev_dbg_lvl(&client->dev, 3, msp_debug, "msp_read(0x%x, 0x%x): 0x%x\n",\r\ndev, addr, retval);\r\nreturn retval;\r\n}\r\nint msp_read_dem(struct i2c_client *client, int addr)\r\n{\r\nreturn msp_read(client, I2C_MSP_DEM, addr);\r\n}\r\nint msp_read_dsp(struct i2c_client *client, int addr)\r\n{\r\nreturn msp_read(client, I2C_MSP_DSP, addr);\r\n}\r\nstatic int msp_write(struct i2c_client *client, int dev, int addr, int val)\r\n{\r\nint err;\r\nu8 buffer[5];\r\nbuffer[0] = dev;\r\nbuffer[1] = addr >> 8;\r\nbuffer[2] = addr & 0xff;\r\nbuffer[3] = val >> 8;\r\nbuffer[4] = val & 0xff;\r\ndev_dbg_lvl(&client->dev, 3, msp_debug, "msp_write(0x%x, 0x%x, 0x%x)\n",\r\ndev, addr, val);\r\nfor (err = 0; err < 3; err++) {\r\nif (i2c_master_send(client, buffer, 5) == 5)\r\nbreak;\r\ndev_warn(&client->dev, "I/O error #%d (write 0x%02x/0x%02x)\n", err,\r\ndev, addr);\r\nschedule_timeout_interruptible(msecs_to_jiffies(10));\r\n}\r\nif (err == 3) {\r\ndev_warn(&client->dev, "resetting chip, sound will go off.\n");\r\nmsp_reset(client);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nint msp_write_dem(struct i2c_client *client, int addr, int val)\r\n{\r\nreturn msp_write(client, I2C_MSP_DEM, addr, val);\r\n}\r\nint msp_write_dsp(struct i2c_client *client, int addr, int val)\r\n{\r\nreturn msp_write(client, I2C_MSP_DSP, addr, val);\r\n}\r\nvoid msp_set_scart(struct i2c_client *client, int in, int out)\r\n{\r\nstruct msp_state *state = to_state(i2c_get_clientdata(client));\r\nstate->in_scart = in;\r\nif (in >= 0 && in <= 7 && out >= 0 && out <= 2) {\r\nif (-1 == scarts[out][in + 1])\r\nreturn;\r\nstate->acb &= ~scarts[out][0];\r\nstate->acb |= scarts[out][in + 1];\r\n} else\r\nstate->acb = 0xf60;\r\ndev_dbg_lvl(&client->dev, 1, msp_debug, "scart switch: %s => %d (ACB=0x%04x)\n",\r\nscart_names[in], out, state->acb);\r\nmsp_write_dsp(client, 0x13, state->acb);\r\nif (state->has_i2s_conf)\r\nmsp_write_dem(client, 0x40, state->i2s_mode);\r\n}\r\nstatic void msp_wake_thread(struct i2c_client *client)\r\n{\r\nstruct msp_state *state = to_state(i2c_get_clientdata(client));\r\nif (NULL == state->kthread)\r\nreturn;\r\nstate->watch_stereo = 0;\r\nstate->restart = 1;\r\nwake_up_interruptible(&state->wq);\r\n}\r\nint msp_sleep(struct msp_state *state, int timeout)\r\n{\r\nDECLARE_WAITQUEUE(wait, current);\r\nadd_wait_queue(&state->wq, &wait);\r\nif (!kthread_should_stop()) {\r\nif (timeout < 0) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nschedule();\r\n} else {\r\nschedule_timeout_interruptible\r\n(msecs_to_jiffies(timeout));\r\n}\r\n}\r\nremove_wait_queue(&state->wq, &wait);\r\ntry_to_freeze();\r\nreturn state->restart;\r\n}\r\nstatic int msp_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct msp_state *state = ctrl_to_state(ctrl);\r\nstruct i2c_client *client = v4l2_get_subdevdata(&state->sd);\r\nint val = ctrl->val;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUDIO_VOLUME: {\r\nint reallymuted = state->muted->val | state->scan_in_progress;\r\nif (!reallymuted)\r\nval = (val * 0x7f / 65535) << 8;\r\ndev_dbg_lvl(&client->dev, 1, msp_debug, "mute=%s scanning=%s volume=%d\n",\r\nstate->muted->val ? "on" : "off",\r\nstate->scan_in_progress ? "yes" : "no",\r\nstate->volume->val);\r\nmsp_write_dsp(client, 0x0000, val);\r\nmsp_write_dsp(client, 0x0007, reallymuted ? 0x1 : (val | 0x1));\r\nif (state->has_scart2_out_volume)\r\nmsp_write_dsp(client, 0x0040, reallymuted ? 0x1 : (val | 0x1));\r\nif (state->has_headphones)\r\nmsp_write_dsp(client, 0x0006, val);\r\nbreak;\r\n}\r\ncase V4L2_CID_AUDIO_BASS:\r\nval = ((val - 32768) * 0x60 / 65535) << 8;\r\nmsp_write_dsp(client, 0x0002, val);\r\nif (state->has_headphones)\r\nmsp_write_dsp(client, 0x0031, val);\r\nbreak;\r\ncase V4L2_CID_AUDIO_TREBLE:\r\nval = ((val - 32768) * 0x60 / 65535) << 8;\r\nmsp_write_dsp(client, 0x0003, val);\r\nif (state->has_headphones)\r\nmsp_write_dsp(client, 0x0032, val);\r\nbreak;\r\ncase V4L2_CID_AUDIO_LOUDNESS:\r\nval = val ? ((5 * 4) << 8) : 0;\r\nmsp_write_dsp(client, 0x0004, val);\r\nif (state->has_headphones)\r\nmsp_write_dsp(client, 0x0033, val);\r\nbreak;\r\ncase V4L2_CID_AUDIO_BALANCE:\r\nval = (u8)((val / 256) - 128);\r\nmsp_write_dsp(client, 0x0001, val << 8);\r\nif (state->has_headphones)\r\nmsp_write_dsp(client, 0x0030, val << 8);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nvoid msp_update_volume(struct msp_state *state)\r\n{\r\nv4l2_ctrl_lock(state->volume);\r\nstate->volume->val = state->volume->cur.val;\r\nstate->muted->val = state->muted->cur.val;\r\nmsp_s_ctrl(state->volume);\r\nv4l2_ctrl_unlock(state->volume);\r\n}\r\nstatic int msp_s_radio(struct v4l2_subdev *sd)\r\n{\r\nstruct msp_state *state = to_state(sd);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (state->radio)\r\nreturn 0;\r\nstate->radio = 1;\r\ndev_dbg_lvl(&client->dev, 1, msp_debug, "switching to radio mode\n");\r\nstate->watch_stereo = 0;\r\nswitch (state->opmode) {\r\ncase OPMODE_MANUAL:\r\nmsp3400c_set_mode(client, MSP_MODE_FM_RADIO);\r\nmsp3400c_set_carrier(client, MSP_CARRIER(10.7),\r\nMSP_CARRIER(10.7));\r\nmsp_update_volume(state);\r\nbreak;\r\ncase OPMODE_AUTODETECT:\r\ncase OPMODE_AUTOSELECT:\r\nmsp_wake_thread(client);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int msp_s_frequency(struct v4l2_subdev *sd, const struct v4l2_frequency *freq)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nmsp_wake_thread(client);\r\nreturn 0;\r\n}\r\nstatic int msp_querystd(struct v4l2_subdev *sd, v4l2_std_id *id)\r\n{\r\nstruct msp_state *state = to_state(sd);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\n*id &= state->detected_std;\r\ndev_dbg_lvl(&client->dev, 2, msp_debug,\r\n"detected standard: %s(0x%08Lx)\n",\r\nmsp_standard_std_name(state->std), state->detected_std);\r\nreturn 0;\r\n}\r\nstatic int msp_s_std(struct v4l2_subdev *sd, v4l2_std_id id)\r\n{\r\nstruct msp_state *state = to_state(sd);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint update = state->radio || state->v4l2_std != id;\r\nstate->v4l2_std = id;\r\nstate->radio = 0;\r\nif (update)\r\nmsp_wake_thread(client);\r\nreturn 0;\r\n}\r\nstatic int msp_s_routing(struct v4l2_subdev *sd,\r\nu32 input, u32 output, u32 config)\r\n{\r\nstruct msp_state *state = to_state(sd);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint tuner = (input >> 3) & 1;\r\nint sc_in = input & 0x7;\r\nint sc1_out = output & 0xf;\r\nint sc2_out = (output >> 4) & 0xf;\r\nu16 val, reg;\r\nint i;\r\nint extern_input = 1;\r\nif (state->route_in == input && state->route_out == output)\r\nreturn 0;\r\nstate->route_in = input;\r\nstate->route_out = output;\r\nfor (i = 0; i < 5; i++) {\r\nif (((input >> (4 + i * 4)) & 0xf) == 0)\r\nextern_input = 0;\r\n}\r\nstate->mode = extern_input ? MSP_MODE_EXTERN : MSP_MODE_AM_DETECT;\r\nstate->rxsubchans = V4L2_TUNER_SUB_STEREO;\r\nmsp_set_scart(client, sc_in, 0);\r\nmsp_set_scart(client, sc1_out, 1);\r\nmsp_set_scart(client, sc2_out, 2);\r\nmsp_set_audmode(client);\r\nreg = (state->opmode == OPMODE_AUTOSELECT) ? 0x30 : 0xbb;\r\nval = msp_read_dem(client, reg);\r\nmsp_write_dem(client, reg, (val & ~0x100) | (tuner << 8));\r\nmsp_wake_thread(client);\r\nreturn 0;\r\n}\r\nstatic int msp_g_tuner(struct v4l2_subdev *sd, struct v4l2_tuner *vt)\r\n{\r\nstruct msp_state *state = to_state(sd);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (vt->type != V4L2_TUNER_ANALOG_TV)\r\nreturn 0;\r\nif (!state->radio) {\r\nif (state->opmode == OPMODE_AUTOSELECT)\r\nmsp_detect_stereo(client);\r\nvt->rxsubchans = state->rxsubchans;\r\n}\r\nvt->audmode = state->audmode;\r\nvt->capability |= V4L2_TUNER_CAP_STEREO |\r\nV4L2_TUNER_CAP_LANG1 | V4L2_TUNER_CAP_LANG2;\r\nreturn 0;\r\n}\r\nstatic int msp_s_tuner(struct v4l2_subdev *sd, const struct v4l2_tuner *vt)\r\n{\r\nstruct msp_state *state = to_state(sd);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (state->radio)\r\nreturn 0;\r\nif (state->audmode == vt->audmode)\r\nreturn 0;\r\nstate->audmode = vt->audmode;\r\nmsp_set_audmode(client);\r\nreturn 0;\r\n}\r\nstatic int msp_s_i2s_clock_freq(struct v4l2_subdev *sd, u32 freq)\r\n{\r\nstruct msp_state *state = to_state(sd);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\ndev_dbg_lvl(&client->dev, 1, msp_debug, "Setting I2S speed to %d\n", freq);\r\nswitch (freq) {\r\ncase 1024000:\r\nstate->i2s_mode = 0;\r\nbreak;\r\ncase 2048000:\r\nstate->i2s_mode = 1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int msp_log_status(struct v4l2_subdev *sd)\r\n{\r\nstruct msp_state *state = to_state(sd);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nconst char *p;\r\nchar prefix[V4L2_SUBDEV_NAME_SIZE + 20];\r\nif (state->opmode == OPMODE_AUTOSELECT)\r\nmsp_detect_stereo(client);\r\ndev_info(&client->dev, "%s rev1 = 0x%04x rev2 = 0x%04x\n",\r\nclient->name, state->rev1, state->rev2);\r\nsnprintf(prefix, sizeof(prefix), "%s: Audio: ", sd->name);\r\nv4l2_ctrl_handler_log_status(&state->hdl, prefix);\r\nswitch (state->mode) {\r\ncase MSP_MODE_AM_DETECT: p = "AM (for carrier detect)"; break;\r\ncase MSP_MODE_FM_RADIO: p = "FM Radio"; break;\r\ncase MSP_MODE_FM_TERRA: p = "Terrestrial FM-mono/stereo"; break;\r\ncase MSP_MODE_FM_SAT: p = "Satellite FM-mono"; break;\r\ncase MSP_MODE_FM_NICAM1: p = "NICAM/FM (B/G, D/K)"; break;\r\ncase MSP_MODE_FM_NICAM2: p = "NICAM/FM (I)"; break;\r\ncase MSP_MODE_AM_NICAM: p = "NICAM/AM (L)"; break;\r\ncase MSP_MODE_BTSC: p = "BTSC"; break;\r\ncase MSP_MODE_EXTERN: p = "External input"; break;\r\ndefault: p = "unknown"; break;\r\n}\r\nif (state->mode == MSP_MODE_EXTERN) {\r\ndev_info(&client->dev, "Mode: %s\n", p);\r\n} else if (state->opmode == OPMODE_MANUAL) {\r\ndev_info(&client->dev, "Mode: %s (%s%s)\n", p,\r\n(state->rxsubchans & V4L2_TUNER_SUB_STEREO) ? "stereo" : "mono",\r\n(state->rxsubchans & V4L2_TUNER_SUB_LANG2) ? ", dual" : "");\r\n} else {\r\nif (state->opmode == OPMODE_AUTODETECT)\r\ndev_info(&client->dev, "Mode: %s\n", p);\r\ndev_info(&client->dev, "Standard: %s (%s%s)\n",\r\nmsp_standard_std_name(state->std),\r\n(state->rxsubchans & V4L2_TUNER_SUB_STEREO) ? "stereo" : "mono",\r\n(state->rxsubchans & V4L2_TUNER_SUB_LANG2) ? ", dual" : "");\r\n}\r\ndev_info(&client->dev, "Audmode: 0x%04x\n", state->audmode);\r\ndev_info(&client->dev, "Routing: 0x%08x (input) 0x%08x (output)\n",\r\nstate->route_in, state->route_out);\r\ndev_info(&client->dev, "ACB: 0x%04x\n", state->acb);\r\nreturn 0;\r\n}\r\nstatic int msp_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\ndev_dbg_lvl(&client->dev, 1, msp_debug, "suspend\n");\r\nmsp_reset(client);\r\nreturn 0;\r\n}\r\nstatic int msp_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\ndev_dbg_lvl(&client->dev, 1, msp_debug, "resume\n");\r\nmsp_wake_thread(client);\r\nreturn 0;\r\n}\r\nstatic int msp_probe(struct i2c_client *client, const struct i2c_device_id *id)\r\n{\r\nstruct msp_state *state;\r\nstruct v4l2_subdev *sd;\r\nstruct v4l2_ctrl_handler *hdl;\r\nint (*thread_func)(void *data) = NULL;\r\nint msp_hard;\r\nint msp_family;\r\nint msp_revision;\r\nint msp_product, msp_prod_hi, msp_prod_lo;\r\nint msp_rom;\r\n#if defined(CONFIG_MEDIA_CONTROLLER)\r\nint ret;\r\n#endif\r\nif (!id)\r\nstrlcpy(client->name, "msp3400", sizeof(client->name));\r\nif (msp_reset(client) == -1) {\r\ndev_dbg_lvl(&client->dev, 1, msp_debug, "msp3400 not found\n");\r\nreturn -ENODEV;\r\n}\r\nstate = devm_kzalloc(&client->dev, sizeof(*state), GFP_KERNEL);\r\nif (!state)\r\nreturn -ENOMEM;\r\nsd = &state->sd;\r\nv4l2_i2c_subdev_init(sd, client, &msp_ops);\r\n#if defined(CONFIG_MEDIA_CONTROLLER)\r\nstate->pads[IF_AUD_DEC_PAD_IF_INPUT].flags = MEDIA_PAD_FL_SINK;\r\nstate->pads[IF_AUD_DEC_PAD_OUT].flags = MEDIA_PAD_FL_SOURCE;\r\nsd->entity.function = MEDIA_ENT_F_IF_AUD_DECODER;\r\nret = media_entity_pads_init(&sd->entity, 2, state->pads);\r\nif (ret < 0)\r\nreturn ret;\r\n#endif\r\nstate->v4l2_std = V4L2_STD_NTSC;\r\nstate->detected_std = V4L2_STD_ALL;\r\nstate->audmode = V4L2_TUNER_MODE_STEREO;\r\nstate->input = -1;\r\nstate->i2s_mode = 0;\r\ninit_waitqueue_head(&state->wq);\r\nstate->route_in = MSP_INPUT_DEFAULT;\r\nstate->route_out = MSP_OUTPUT_DEFAULT;\r\nstate->rev1 = msp_read_dsp(client, 0x1e);\r\nif (state->rev1 != -1)\r\nstate->rev2 = msp_read_dsp(client, 0x1f);\r\ndev_dbg_lvl(&client->dev, 1, msp_debug, "rev1=0x%04x, rev2=0x%04x\n",\r\nstate->rev1, state->rev2);\r\nif (state->rev1 == -1 || (state->rev1 == 0 && state->rev2 == 0)) {\r\ndev_dbg_lvl(&client->dev, 1, msp_debug,\r\n"not an msp3400 (cannot read chip version)\n");\r\nreturn -ENODEV;\r\n}\r\nmsp_family = ((state->rev1 >> 4) & 0x0f) + 3;\r\nmsp_product = (state->rev2 >> 8) & 0xff;\r\nmsp_prod_hi = msp_product / 10;\r\nmsp_prod_lo = msp_product % 10;\r\nmsp_revision = (state->rev1 & 0x0f) + '@';\r\nmsp_hard = ((state->rev1 >> 8) & 0xff) + '@';\r\nmsp_rom = state->rev2 & 0x1f;\r\nstate->ident = msp_family * 10000 + 4000 + msp_product * 10 +\r\nmsp_revision - '@';\r\nstate->has_nicam =\r\nmsp_prod_hi == 1 || msp_prod_hi == 5;\r\nstate->has_radio =\r\nmsp_revision >= 'G';\r\nstate->has_headphones =\r\nmsp_prod_lo < 5;\r\nstate->has_scart2 =\r\nmsp_family >= 4 || msp_prod_lo < 7;\r\nstate->has_scart3 =\r\nmsp_family >= 4 || msp_prod_lo < 5;\r\nstate->has_scart4 =\r\nmsp_family >= 4 || (msp_revision >= 'D' && msp_prod_lo < 5);\r\nstate->has_scart2_out =\r\nmsp_family >= 4 || msp_prod_lo < 5;\r\nstate->has_scart2_out_volume =\r\nmsp_revision > 'C' && state->has_scart2_out;\r\nstate->has_i2s_conf =\r\nmsp_revision >= 'G' && msp_prod_lo < 7;\r\nstate->has_subwoofer =\r\nmsp_revision >= 'D' && msp_prod_lo < 5;\r\nstate->has_sound_processing =\r\nmsp_prod_lo < 7;\r\nstate->has_virtual_dolby_surround =\r\nmsp_revision == 'G' && msp_prod_lo == 1;\r\nstate->has_dolby_pro_logic =\r\nmsp_revision == 'G' && msp_prod_lo == 2;\r\nstate->force_btsc =\r\nmsp_family == 3 && msp_revision == 'G' && msp_prod_hi == 3;\r\nstate->opmode = opmode;\r\nif (state->opmode < OPMODE_MANUAL\r\n|| state->opmode > OPMODE_AUTOSELECT) {\r\nif (msp_revision >= 'G')\r\nstate->opmode = OPMODE_AUTOSELECT;\r\nelse if (msp_revision >= 'D')\r\nstate->opmode = OPMODE_AUTODETECT;\r\nelse\r\nstate->opmode = OPMODE_MANUAL;\r\n}\r\nhdl = &state->hdl;\r\nv4l2_ctrl_handler_init(hdl, 6);\r\nif (state->has_sound_processing) {\r\nv4l2_ctrl_new_std(hdl, &msp_ctrl_ops,\r\nV4L2_CID_AUDIO_BASS, 0, 65535, 65535 / 100, 32768);\r\nv4l2_ctrl_new_std(hdl, &msp_ctrl_ops,\r\nV4L2_CID_AUDIO_TREBLE, 0, 65535, 65535 / 100, 32768);\r\nv4l2_ctrl_new_std(hdl, &msp_ctrl_ops,\r\nV4L2_CID_AUDIO_LOUDNESS, 0, 1, 1, 0);\r\n}\r\nstate->volume = v4l2_ctrl_new_std(hdl, &msp_ctrl_ops,\r\nV4L2_CID_AUDIO_VOLUME, 0, 65535, 65535 / 100, 58880);\r\nv4l2_ctrl_new_std(hdl, &msp_ctrl_ops,\r\nV4L2_CID_AUDIO_BALANCE, 0, 65535, 65535 / 100, 32768);\r\nstate->muted = v4l2_ctrl_new_std(hdl, &msp_ctrl_ops,\r\nV4L2_CID_AUDIO_MUTE, 0, 1, 1, 0);\r\nsd->ctrl_handler = hdl;\r\nif (hdl->error) {\r\nint err = hdl->error;\r\nv4l2_ctrl_handler_free(hdl);\r\nreturn err;\r\n}\r\nv4l2_ctrl_cluster(2, &state->volume);\r\nv4l2_ctrl_handler_setup(hdl);\r\ndev_info(&client->dev,\r\n"MSP%d4%02d%c-%c%d found on %s: supports %s%s%s, mode is %s\n",\r\nmsp_family, msp_product,\r\nmsp_revision, msp_hard, msp_rom,\r\nclient->adapter->name,\r\n(state->has_nicam) ? "nicam" : "",\r\n(state->has_nicam && state->has_radio) ? " and " : "",\r\n(state->has_radio) ? "radio" : "",\r\nopmode_str[state->opmode]);\r\nswitch (state->opmode) {\r\ncase OPMODE_MANUAL:\r\nthread_func = msp3400c_thread;\r\nbreak;\r\ncase OPMODE_AUTODETECT:\r\nthread_func = msp3410d_thread;\r\nbreak;\r\ncase OPMODE_AUTOSELECT:\r\nthread_func = msp34xxg_thread;\r\nbreak;\r\n}\r\nif (thread_func) {\r\nstate->kthread = kthread_run(thread_func, client, "msp34xx");\r\nif (IS_ERR(state->kthread))\r\ndev_warn(&client->dev, "kernel_thread() failed\n");\r\nmsp_wake_thread(client);\r\n}\r\nreturn 0;\r\n}\r\nstatic int msp_remove(struct i2c_client *client)\r\n{\r\nstruct msp_state *state = to_state(i2c_get_clientdata(client));\r\nv4l2_device_unregister_subdev(&state->sd);\r\nif (state->kthread) {\r\nstate->restart = 1;\r\nkthread_stop(state->kthread);\r\n}\r\nmsp_reset(client);\r\nv4l2_ctrl_handler_free(&state->hdl);\r\nreturn 0;\r\n}
