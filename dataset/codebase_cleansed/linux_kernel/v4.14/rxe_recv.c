static int check_type_state(struct rxe_dev *rxe, struct rxe_pkt_info *pkt,\r\nstruct rxe_qp *qp)\r\n{\r\nif (unlikely(!qp->valid))\r\ngoto err1;\r\nswitch (qp_type(qp)) {\r\ncase IB_QPT_RC:\r\nif (unlikely((pkt->opcode & IB_OPCODE_RC) != 0)) {\r\npr_warn_ratelimited("bad qp type\n");\r\ngoto err1;\r\n}\r\nbreak;\r\ncase IB_QPT_UC:\r\nif (unlikely(!(pkt->opcode & IB_OPCODE_UC))) {\r\npr_warn_ratelimited("bad qp type\n");\r\ngoto err1;\r\n}\r\nbreak;\r\ncase IB_QPT_UD:\r\ncase IB_QPT_SMI:\r\ncase IB_QPT_GSI:\r\nif (unlikely(!(pkt->opcode & IB_OPCODE_UD))) {\r\npr_warn_ratelimited("bad qp type\n");\r\ngoto err1;\r\n}\r\nbreak;\r\ndefault:\r\npr_warn_ratelimited("unsupported qp type\n");\r\ngoto err1;\r\n}\r\nif (pkt->mask & RXE_REQ_MASK) {\r\nif (unlikely(qp->resp.state != QP_STATE_READY))\r\ngoto err1;\r\n} else if (unlikely(qp->req.state < QP_STATE_READY ||\r\nqp->req.state > QP_STATE_DRAINED)) {\r\ngoto err1;\r\n}\r\nreturn 0;\r\nerr1:\r\nreturn -EINVAL;\r\n}\r\nstatic void set_bad_pkey_cntr(struct rxe_port *port)\r\n{\r\nspin_lock_bh(&port->port_lock);\r\nport->attr.bad_pkey_cntr = min((u32)0xffff,\r\nport->attr.bad_pkey_cntr + 1);\r\nspin_unlock_bh(&port->port_lock);\r\n}\r\nstatic void set_qkey_viol_cntr(struct rxe_port *port)\r\n{\r\nspin_lock_bh(&port->port_lock);\r\nport->attr.qkey_viol_cntr = min((u32)0xffff,\r\nport->attr.qkey_viol_cntr + 1);\r\nspin_unlock_bh(&port->port_lock);\r\n}\r\nstatic int check_keys(struct rxe_dev *rxe, struct rxe_pkt_info *pkt,\r\nu32 qpn, struct rxe_qp *qp)\r\n{\r\nint i;\r\nint found_pkey = 0;\r\nstruct rxe_port *port = &rxe->port;\r\nu16 pkey = bth_pkey(pkt);\r\npkt->pkey_index = 0;\r\nif (qpn == 1) {\r\nfor (i = 0; i < port->attr.pkey_tbl_len; i++) {\r\nif (pkey_match(pkey, port->pkey_tbl[i])) {\r\npkt->pkey_index = i;\r\nfound_pkey = 1;\r\nbreak;\r\n}\r\n}\r\nif (!found_pkey) {\r\npr_warn_ratelimited("bad pkey = 0x%x\n", pkey);\r\nset_bad_pkey_cntr(port);\r\ngoto err1;\r\n}\r\n} else if (qpn != 0) {\r\nif (unlikely(!pkey_match(pkey,\r\nport->pkey_tbl[qp->attr.pkey_index]\r\n))) {\r\npr_warn_ratelimited("bad pkey = 0x%0x\n", pkey);\r\nset_bad_pkey_cntr(port);\r\ngoto err1;\r\n}\r\npkt->pkey_index = qp->attr.pkey_index;\r\n}\r\nif ((qp_type(qp) == IB_QPT_UD || qp_type(qp) == IB_QPT_GSI) &&\r\nqpn != 0 && pkt->mask) {\r\nu32 qkey = (qpn == 1) ? GSI_QKEY : qp->attr.qkey;\r\nif (unlikely(deth_qkey(pkt) != qkey)) {\r\npr_warn_ratelimited("bad qkey, got 0x%x expected 0x%x for qpn 0x%x\n",\r\ndeth_qkey(pkt), qkey, qpn);\r\nset_qkey_viol_cntr(port);\r\ngoto err1;\r\n}\r\n}\r\nreturn 0;\r\nerr1:\r\nreturn -EINVAL;\r\n}\r\nstatic int check_addr(struct rxe_dev *rxe, struct rxe_pkt_info *pkt,\r\nstruct rxe_qp *qp)\r\n{\r\nstruct sk_buff *skb = PKT_TO_SKB(pkt);\r\nif (qp_type(qp) != IB_QPT_RC && qp_type(qp) != IB_QPT_UC)\r\ngoto done;\r\nif (unlikely(pkt->port_num != qp->attr.port_num)) {\r\npr_warn_ratelimited("port %d != qp port %d\n",\r\npkt->port_num, qp->attr.port_num);\r\ngoto err1;\r\n}\r\nif (skb->protocol == htons(ETH_P_IP)) {\r\nstruct in_addr *saddr =\r\n&qp->pri_av.sgid_addr._sockaddr_in.sin_addr;\r\nstruct in_addr *daddr =\r\n&qp->pri_av.dgid_addr._sockaddr_in.sin_addr;\r\nif (ip_hdr(skb)->daddr != saddr->s_addr) {\r\npr_warn_ratelimited("dst addr %pI4 != qp source addr %pI4\n",\r\n&ip_hdr(skb)->daddr,\r\n&saddr->s_addr);\r\ngoto err1;\r\n}\r\nif (ip_hdr(skb)->saddr != daddr->s_addr) {\r\npr_warn_ratelimited("source addr %pI4 != qp dst addr %pI4\n",\r\n&ip_hdr(skb)->saddr,\r\n&daddr->s_addr);\r\ngoto err1;\r\n}\r\n} else if (skb->protocol == htons(ETH_P_IPV6)) {\r\nstruct in6_addr *saddr =\r\n&qp->pri_av.sgid_addr._sockaddr_in6.sin6_addr;\r\nstruct in6_addr *daddr =\r\n&qp->pri_av.dgid_addr._sockaddr_in6.sin6_addr;\r\nif (memcmp(&ipv6_hdr(skb)->daddr, saddr, sizeof(*saddr))) {\r\npr_warn_ratelimited("dst addr %pI6 != qp source addr %pI6\n",\r\n&ipv6_hdr(skb)->daddr, saddr);\r\ngoto err1;\r\n}\r\nif (memcmp(&ipv6_hdr(skb)->saddr, daddr, sizeof(*daddr))) {\r\npr_warn_ratelimited("source addr %pI6 != qp dst addr %pI6\n",\r\n&ipv6_hdr(skb)->saddr, daddr);\r\ngoto err1;\r\n}\r\n}\r\ndone:\r\nreturn 0;\r\nerr1:\r\nreturn -EINVAL;\r\n}\r\nstatic int hdr_check(struct rxe_pkt_info *pkt)\r\n{\r\nstruct rxe_dev *rxe = pkt->rxe;\r\nstruct rxe_port *port = &rxe->port;\r\nstruct rxe_qp *qp = NULL;\r\nu32 qpn = bth_qpn(pkt);\r\nint index;\r\nint err;\r\nif (unlikely(bth_tver(pkt) != BTH_TVER)) {\r\npr_warn_ratelimited("bad tver\n");\r\ngoto err1;\r\n}\r\nif (qpn != IB_MULTICAST_QPN) {\r\nindex = (qpn == 0) ? port->qp_smi_index :\r\n((qpn == 1) ? port->qp_gsi_index : qpn);\r\nqp = rxe_pool_get_index(&rxe->qp_pool, index);\r\nif (unlikely(!qp)) {\r\npr_warn_ratelimited("no qp matches qpn 0x%x\n", qpn);\r\ngoto err1;\r\n}\r\nerr = check_type_state(rxe, pkt, qp);\r\nif (unlikely(err))\r\ngoto err2;\r\nerr = check_addr(rxe, pkt, qp);\r\nif (unlikely(err))\r\ngoto err2;\r\nerr = check_keys(rxe, pkt, qpn, qp);\r\nif (unlikely(err))\r\ngoto err2;\r\n} else {\r\nif (unlikely((pkt->mask & RXE_GRH_MASK) == 0)) {\r\npr_warn_ratelimited("no grh for mcast qpn\n");\r\ngoto err1;\r\n}\r\n}\r\npkt->qp = qp;\r\nreturn 0;\r\nerr2:\r\nif (qp)\r\nrxe_drop_ref(qp);\r\nerr1:\r\nreturn -EINVAL;\r\n}\r\nstatic inline void rxe_rcv_pkt(struct rxe_dev *rxe,\r\nstruct rxe_pkt_info *pkt,\r\nstruct sk_buff *skb)\r\n{\r\nif (pkt->mask & RXE_REQ_MASK)\r\nrxe_resp_queue_pkt(rxe, pkt->qp, skb);\r\nelse\r\nrxe_comp_queue_pkt(rxe, pkt->qp, skb);\r\n}\r\nstatic void rxe_rcv_mcast_pkt(struct rxe_dev *rxe, struct sk_buff *skb)\r\n{\r\nstruct rxe_pkt_info *pkt = SKB_TO_PKT(skb);\r\nstruct rxe_mc_grp *mcg;\r\nstruct sk_buff *skb_copy;\r\nstruct rxe_mc_elem *mce;\r\nstruct rxe_qp *qp;\r\nunion ib_gid dgid;\r\nint err;\r\nif (skb->protocol == htons(ETH_P_IP))\r\nipv6_addr_set_v4mapped(ip_hdr(skb)->daddr,\r\n(struct in6_addr *)&dgid);\r\nelse if (skb->protocol == htons(ETH_P_IPV6))\r\nmemcpy(&dgid, &ipv6_hdr(skb)->daddr, sizeof(dgid));\r\nmcg = rxe_pool_get_key(&rxe->mc_grp_pool, &dgid);\r\nif (!mcg)\r\ngoto err1;\r\nspin_lock_bh(&mcg->mcg_lock);\r\nlist_for_each_entry(mce, &mcg->qp_list, qp_list) {\r\nqp = mce->qp;\r\npkt = SKB_TO_PKT(skb);\r\nerr = check_type_state(rxe, pkt, qp);\r\nif (err)\r\ncontinue;\r\nerr = check_keys(rxe, pkt, bth_qpn(pkt), qp);\r\nif (err)\r\ncontinue;\r\nskb_copy = (mce->qp_list.next != &mcg->qp_list) ?\r\nskb_clone(skb, GFP_ATOMIC) : NULL;\r\npkt->qp = qp;\r\nrxe_add_ref(qp);\r\nrxe_rcv_pkt(rxe, pkt, skb);\r\nskb = skb_copy;\r\nif (!skb)\r\nbreak;\r\n}\r\nspin_unlock_bh(&mcg->mcg_lock);\r\nrxe_drop_ref(mcg);\r\nerr1:\r\nif (skb)\r\nkfree_skb(skb);\r\n}\r\nstatic int rxe_match_dgid(struct rxe_dev *rxe, struct sk_buff *skb)\r\n{\r\nunion ib_gid dgid;\r\nunion ib_gid *pdgid;\r\nu16 index;\r\nif (skb->protocol == htons(ETH_P_IP)) {\r\nipv6_addr_set_v4mapped(ip_hdr(skb)->daddr,\r\n(struct in6_addr *)&dgid);\r\npdgid = &dgid;\r\n} else {\r\npdgid = (union ib_gid *)&ipv6_hdr(skb)->daddr;\r\n}\r\nreturn ib_find_cached_gid_by_port(&rxe->ib_dev, pdgid,\r\nIB_GID_TYPE_ROCE_UDP_ENCAP,\r\n1, rxe->ndev, &index);\r\n}\r\nint rxe_rcv(struct sk_buff *skb)\r\n{\r\nint err;\r\nstruct rxe_pkt_info *pkt = SKB_TO_PKT(skb);\r\nstruct rxe_dev *rxe = pkt->rxe;\r\n__be32 *icrcp;\r\nu32 calc_icrc, pack_icrc;\r\npkt->offset = 0;\r\nif (unlikely(skb->len < pkt->offset + RXE_BTH_BYTES))\r\ngoto drop;\r\nif (unlikely(rxe_match_dgid(rxe, skb) < 0)) {\r\npr_warn_ratelimited("failed matching dgid\n");\r\ngoto drop;\r\n}\r\npkt->opcode = bth_opcode(pkt);\r\npkt->psn = bth_psn(pkt);\r\npkt->qp = NULL;\r\npkt->mask |= rxe_opcode[pkt->opcode].mask;\r\nif (unlikely(skb->len < header_size(pkt)))\r\ngoto drop;\r\nerr = hdr_check(pkt);\r\nif (unlikely(err))\r\ngoto drop;\r\nicrcp = (__be32 *)(pkt->hdr + pkt->paylen - RXE_ICRC_SIZE);\r\npack_icrc = be32_to_cpu(*icrcp);\r\ncalc_icrc = rxe_icrc_hdr(pkt, skb);\r\ncalc_icrc = rxe_crc32(rxe, calc_icrc, (u8 *)payload_addr(pkt),\r\npayload_size(pkt));\r\ncalc_icrc = (__force u32)cpu_to_be32(~calc_icrc);\r\nif (unlikely(calc_icrc != pack_icrc)) {\r\nif (skb->protocol == htons(ETH_P_IPV6))\r\npr_warn_ratelimited("bad ICRC from %pI6c\n",\r\n&ipv6_hdr(skb)->saddr);\r\nelse if (skb->protocol == htons(ETH_P_IP))\r\npr_warn_ratelimited("bad ICRC from %pI4\n",\r\n&ip_hdr(skb)->saddr);\r\nelse\r\npr_warn_ratelimited("bad ICRC from unknown\n");\r\ngoto drop;\r\n}\r\nrxe_counter_inc(rxe, RXE_CNT_RCVD_PKTS);\r\nif (unlikely(bth_qpn(pkt) == IB_MULTICAST_QPN))\r\nrxe_rcv_mcast_pkt(rxe, skb);\r\nelse\r\nrxe_rcv_pkt(rxe, pkt, skb);\r\nreturn 0;\r\ndrop:\r\nif (pkt->qp)\r\nrxe_drop_ref(pkt->qp);\r\nkfree_skb(skb);\r\nreturn 0;\r\n}
