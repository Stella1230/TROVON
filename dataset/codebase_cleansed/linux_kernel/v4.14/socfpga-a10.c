static bool socfpga_a10_fpga_writeable_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase A10_FPGAMGR_DCLKCNT_OFST:\r\ncase A10_FPGAMGR_DCLKSTAT_OFST:\r\ncase A10_FPGAMGR_IMGCFG_CTL_00_OFST:\r\ncase A10_FPGAMGR_IMGCFG_CTL_01_OFST:\r\ncase A10_FPGAMGR_IMGCFG_CTL_02_OFST:\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool socfpga_a10_fpga_readable_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase A10_FPGAMGR_DCLKCNT_OFST:\r\ncase A10_FPGAMGR_DCLKSTAT_OFST:\r\ncase A10_FPGAMGR_IMGCFG_CTL_00_OFST:\r\ncase A10_FPGAMGR_IMGCFG_CTL_01_OFST:\r\ncase A10_FPGAMGR_IMGCFG_CTL_02_OFST:\r\ncase A10_FPGAMGR_IMGCFG_STAT_OFST:\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void socfpga_a10_fpga_set_cfg_width(struct a10_fpga_priv *priv,\r\nint width)\r\n{\r\nwidth <<= A10_FPGAMGR_IMGCFG_CTL_02_CFGWIDTH_SHIFT;\r\nregmap_update_bits(priv->regmap, A10_FPGAMGR_IMGCFG_CTL_02_OFST,\r\nA10_FPGAMGR_IMGCFG_CTL_02_CFGWIDTH, width);\r\n}\r\nstatic void socfpga_a10_fpga_generate_dclks(struct a10_fpga_priv *priv,\r\nu32 count)\r\n{\r\nu32 val;\r\nregmap_write(priv->regmap, A10_FPGAMGR_DCLKSTAT_OFST,\r\nA10_FPGAMGR_DCLKSTAT_DCLKDONE);\r\nregmap_write(priv->regmap, A10_FPGAMGR_DCLKCNT_OFST, count);\r\nregmap_read_poll_timeout(priv->regmap, A10_FPGAMGR_DCLKSTAT_OFST, val,\r\nval, 1, 100);\r\nregmap_write(priv->regmap, A10_FPGAMGR_DCLKSTAT_OFST,\r\nA10_FPGAMGR_DCLKSTAT_DCLKDONE);\r\n}\r\nstatic int socfpga_a10_fpga_encrypted(u32 *buf32, size_t buf32_size)\r\n{\r\nif (buf32_size < RBF_ENCRYPTION_MODE_OFFSET + 1)\r\nreturn -EINVAL;\r\nreturn ((buf32[RBF_ENCRYPTION_MODE_OFFSET] >> 2) & 3) != 0;\r\n}\r\nstatic int socfpga_a10_fpga_compressed(u32 *buf32, size_t buf32_size)\r\n{\r\nif (buf32_size < RBF_DECOMPRESS_OFFSET + 1)\r\nreturn -EINVAL;\r\nreturn !((buf32[RBF_DECOMPRESS_OFFSET] >> 1) & 1);\r\n}\r\nstatic unsigned int socfpga_a10_fpga_get_cd_ratio(unsigned int cfg_width,\r\nbool encrypt, bool compress)\r\n{\r\nunsigned int cd_ratio;\r\nif (!compress && !encrypt)\r\nreturn CDRATIO_x1;\r\nif (compress)\r\ncd_ratio = CDRATIO_x4;\r\nelse\r\ncd_ratio = CDRATIO_x2;\r\nif (cfg_width == CFGWDTH_32)\r\ncd_ratio += 1;\r\nreturn cd_ratio;\r\n}\r\nstatic int socfpga_a10_fpga_set_cdratio(struct fpga_manager *mgr,\r\nunsigned int cfg_width,\r\nconst char *buf, size_t count)\r\n{\r\nstruct a10_fpga_priv *priv = mgr->priv;\r\nunsigned int cd_ratio;\r\nint encrypt, compress;\r\nencrypt = socfpga_a10_fpga_encrypted((u32 *)buf, count / 4);\r\nif (encrypt < 0)\r\nreturn -EINVAL;\r\ncompress = socfpga_a10_fpga_compressed((u32 *)buf, count / 4);\r\nif (compress < 0)\r\nreturn -EINVAL;\r\ncd_ratio = socfpga_a10_fpga_get_cd_ratio(cfg_width, encrypt, compress);\r\nregmap_update_bits(priv->regmap, A10_FPGAMGR_IMGCFG_CTL_02_OFST,\r\nA10_FPGAMGR_IMGCFG_CTL_02_CDRATIO_MASK,\r\ncd_ratio << A10_FPGAMGR_IMGCFG_CTL_02_CDRATIO_SHIFT);\r\nreturn 0;\r\n}\r\nstatic u32 socfpga_a10_fpga_read_stat(struct a10_fpga_priv *priv)\r\n{\r\nu32 val;\r\nregmap_read(priv->regmap, A10_FPGAMGR_IMGCFG_STAT_OFST, &val);\r\nreturn val;\r\n}\r\nstatic int socfpga_a10_fpga_wait_for_pr_ready(struct a10_fpga_priv *priv)\r\n{\r\nu32 reg, i;\r\nfor (i = 0; i < 10 ; i++) {\r\nreg = socfpga_a10_fpga_read_stat(priv);\r\nif (reg & A10_FPGAMGR_IMGCFG_STAT_F2S_PR_ERROR)\r\nreturn -EINVAL;\r\nif (reg & A10_FPGAMGR_IMGCFG_STAT_F2S_PR_READY)\r\nreturn 0;\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int socfpga_a10_fpga_wait_for_pr_done(struct a10_fpga_priv *priv)\r\n{\r\nu32 reg, i;\r\nfor (i = 0; i < 10 ; i++) {\r\nreg = socfpga_a10_fpga_read_stat(priv);\r\nif (reg & A10_FPGAMGR_IMGCFG_STAT_F2S_PR_ERROR)\r\nreturn -EINVAL;\r\nif (reg & A10_FPGAMGR_IMGCFG_STAT_F2S_PR_DONE)\r\nreturn 0;\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int socfpga_a10_fpga_write_init(struct fpga_manager *mgr,\r\nstruct fpga_image_info *info,\r\nconst char *buf, size_t count)\r\n{\r\nstruct a10_fpga_priv *priv = mgr->priv;\r\nunsigned int cfg_width;\r\nu32 msel, stat, mask;\r\nint ret;\r\nif (info->flags & FPGA_MGR_PARTIAL_RECONFIG)\r\ncfg_width = CFGWDTH_16;\r\nelse\r\nreturn -EINVAL;\r\nmsel = socfpga_a10_fpga_read_stat(priv);\r\nmsel &= A10_FPGAMGR_IMGCFG_STAT_F2S_MSEL_MASK;\r\nmsel >>= A10_FPGAMGR_IMGCFG_STAT_F2S_MSEL_SHIFT;\r\nif ((msel != 0) && (msel != 1)) {\r\ndev_dbg(&mgr->dev, "Fail: invalid msel=%d\n", msel);\r\nreturn -EINVAL;\r\n}\r\nstat = socfpga_a10_fpga_read_stat(priv);\r\nmask = A10_FPGAMGR_IMGCFG_STAT_F2S_NCONFIG_PIN |\r\nA10_FPGAMGR_IMGCFG_STAT_F2S_NSTATUS_PIN;\r\nif ((stat & mask) != mask)\r\nreturn -EINVAL;\r\nsocfpga_a10_fpga_set_cfg_width(priv, cfg_width);\r\nret = socfpga_a10_fpga_set_cdratio(mgr, cfg_width, buf, count);\r\nif (ret)\r\nreturn ret;\r\nregmap_write(priv->regmap, A10_FPGAMGR_IMGCFG_CTL_01_OFST,\r\nA10_FPGAMGR_IMGCFG_CTL_01_S2F_NENABLE_CONFIG);\r\nregmap_update_bits(priv->regmap, A10_FPGAMGR_IMGCFG_CTL_02_OFST,\r\nA10_FPGAMGR_IMGCFG_CTL_02_EN_CFG_CTRL,\r\nA10_FPGAMGR_IMGCFG_CTL_02_EN_CFG_CTRL);\r\nregmap_write(priv->regmap, A10_FPGAMGR_IMGCFG_CTL_00_OFST,\r\nA10_FPGAMGR_IMGCFG_CTL_00_S2F_NENABLE_NCONFIG |\r\nA10_FPGAMGR_IMGCFG_CTL_00_S2F_NENABLE_NSTATUS |\r\nA10_FPGAMGR_IMGCFG_CTL_00_S2F_NENABLE_CONDONE |\r\nA10_FPGAMGR_IMGCFG_CTL_00_S2F_NCONFIG);\r\nregmap_update_bits(priv->regmap, A10_FPGAMGR_IMGCFG_CTL_01_OFST,\r\nA10_FPGAMGR_IMGCFG_CTL_01_S2F_NENABLE_CONFIG, 0);\r\nsocfpga_a10_fpga_generate_dclks(priv, 256);\r\nregmap_update_bits(priv->regmap, A10_FPGAMGR_IMGCFG_CTL_01_OFST,\r\nA10_FPGAMGR_IMGCFG_CTL_01_S2F_PR_REQUEST,\r\nA10_FPGAMGR_IMGCFG_CTL_01_S2F_PR_REQUEST);\r\nsocfpga_a10_fpga_generate_dclks(priv, 0x7ff);\r\nreturn socfpga_a10_fpga_wait_for_pr_ready(priv);\r\n}\r\nstatic int socfpga_a10_fpga_write(struct fpga_manager *mgr, const char *buf,\r\nsize_t count)\r\n{\r\nstruct a10_fpga_priv *priv = mgr->priv;\r\nu32 *buffer_32 = (u32 *)buf;\r\nsize_t i = 0;\r\nif (count <= 0)\r\nreturn -EINVAL;\r\nwhile (count >= sizeof(u32)) {\r\nwritel(buffer_32[i++], priv->fpga_data_addr);\r\ncount -= sizeof(u32);\r\n}\r\nswitch (count) {\r\ncase 3:\r\nwritel(buffer_32[i++] & 0x00ffffff, priv->fpga_data_addr);\r\nbreak;\r\ncase 2:\r\nwritel(buffer_32[i++] & 0x0000ffff, priv->fpga_data_addr);\r\nbreak;\r\ncase 1:\r\nwritel(buffer_32[i++] & 0x000000ff, priv->fpga_data_addr);\r\nbreak;\r\ncase 0:\r\nbreak;\r\ndefault:\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int socfpga_a10_fpga_write_complete(struct fpga_manager *mgr,\r\nstruct fpga_image_info *info)\r\n{\r\nstruct a10_fpga_priv *priv = mgr->priv;\r\nu32 reg;\r\nint ret;\r\nret = socfpga_a10_fpga_wait_for_pr_done(priv);\r\nregmap_update_bits(priv->regmap, A10_FPGAMGR_IMGCFG_CTL_01_OFST,\r\nA10_FPGAMGR_IMGCFG_CTL_01_S2F_PR_REQUEST, 0);\r\nsocfpga_a10_fpga_generate_dclks(priv, 256);\r\nregmap_update_bits(priv->regmap, A10_FPGAMGR_IMGCFG_CTL_02_OFST,\r\nA10_FPGAMGR_IMGCFG_CTL_02_EN_CFG_CTRL, 0);\r\nregmap_update_bits(priv->regmap, A10_FPGAMGR_IMGCFG_CTL_01_OFST,\r\nA10_FPGAMGR_IMGCFG_CTL_01_S2F_NCE,\r\nA10_FPGAMGR_IMGCFG_CTL_01_S2F_NCE);\r\nregmap_update_bits(priv->regmap, A10_FPGAMGR_IMGCFG_CTL_01_OFST,\r\nA10_FPGAMGR_IMGCFG_CTL_01_S2F_NENABLE_CONFIG,\r\nA10_FPGAMGR_IMGCFG_CTL_01_S2F_NENABLE_CONFIG);\r\nif (ret)\r\nreturn ret;\r\nreg = socfpga_a10_fpga_read_stat(priv);\r\nif (((reg & A10_FPGAMGR_IMGCFG_STAT_F2S_USERMODE) == 0) ||\r\n((reg & A10_FPGAMGR_IMGCFG_STAT_F2S_CONDONE_PIN) == 0) ||\r\n((reg & A10_FPGAMGR_IMGCFG_STAT_F2S_NSTATUS_PIN) == 0)) {\r\ndev_dbg(&mgr->dev,\r\n"Timeout in final check. Status=%08xf\n", reg);\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic enum fpga_mgr_states socfpga_a10_fpga_state(struct fpga_manager *mgr)\r\n{\r\nstruct a10_fpga_priv *priv = mgr->priv;\r\nu32 reg = socfpga_a10_fpga_read_stat(priv);\r\nif (reg & A10_FPGAMGR_IMGCFG_STAT_F2S_USERMODE)\r\nreturn FPGA_MGR_STATE_OPERATING;\r\nif (reg & A10_FPGAMGR_IMGCFG_STAT_F2S_PR_READY)\r\nreturn FPGA_MGR_STATE_WRITE;\r\nif (reg & A10_FPGAMGR_IMGCFG_STAT_F2S_CRC_ERROR)\r\nreturn FPGA_MGR_STATE_WRITE_COMPLETE_ERR;\r\nif ((reg & A10_FPGAMGR_IMGCFG_STAT_F2S_NSTATUS_PIN) == 0)\r\nreturn FPGA_MGR_STATE_RESET;\r\nreturn FPGA_MGR_STATE_UNKNOWN;\r\n}\r\nstatic int socfpga_a10_fpga_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct a10_fpga_priv *priv;\r\nvoid __iomem *reg_base;\r\nstruct resource *res;\r\nint ret;\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nreg_base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(reg_base))\r\nreturn PTR_ERR(reg_base);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\npriv->fpga_data_addr = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(priv->fpga_data_addr))\r\nreturn PTR_ERR(priv->fpga_data_addr);\r\npriv->regmap = devm_regmap_init_mmio(dev, reg_base,\r\n&socfpga_a10_fpga_regmap_config);\r\nif (IS_ERR(priv->regmap))\r\nreturn -ENODEV;\r\npriv->clk = devm_clk_get(dev, NULL);\r\nif (IS_ERR(priv->clk)) {\r\ndev_err(dev, "no clock specified\n");\r\nreturn PTR_ERR(priv->clk);\r\n}\r\nret = clk_prepare_enable(priv->clk);\r\nif (ret) {\r\ndev_err(dev, "could not enable clock\n");\r\nreturn -EBUSY;\r\n}\r\nreturn fpga_mgr_register(dev, "SoCFPGA Arria10 FPGA Manager",\r\n&socfpga_a10_fpga_mgr_ops, priv);\r\n}\r\nstatic int socfpga_a10_fpga_remove(struct platform_device *pdev)\r\n{\r\nstruct fpga_manager *mgr = platform_get_drvdata(pdev);\r\nstruct a10_fpga_priv *priv = mgr->priv;\r\nfpga_mgr_unregister(&pdev->dev);\r\nclk_disable_unprepare(priv->clk);\r\nreturn 0;\r\n}
