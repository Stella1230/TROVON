static int send_init_client(struct pmac_keywest *i2c, unsigned int *regs)\r\n{\r\nwhile (*regs > 0) {\r\nint err, count = 10;\r\ndo {\r\nerr = i2c_smbus_write_byte_data(i2c->client,\r\nregs[0], regs[1]);\r\nif (err >= 0)\r\nbreak;\r\nDBG("(W) i2c error %d\n", err);\r\nmdelay(10);\r\n} while (count--);\r\nif (err < 0)\r\nreturn -ENXIO;\r\nregs += 2;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tumbler_init_client(struct pmac_keywest *i2c)\r\n{\r\nstatic unsigned int regs[] = {\r\nTAS_REG_MCS, (1<<6)|(2<<4)|(2<<2)|0,\r\n0,\r\n};\r\nDBG("(I) tumbler init client\n");\r\nreturn send_init_client(i2c, regs);\r\n}\r\nstatic int snapper_init_client(struct pmac_keywest *i2c)\r\n{\r\nstatic unsigned int regs[] = {\r\nTAS_REG_MCS, (1<<6)|(2<<4)|0,\r\nTAS_REG_MCS2, (1<<1),\r\nTAS_REG_ACS, 0,\r\n0,\r\n};\r\nDBG("(I) snapper init client\n");\r\nreturn send_init_client(i2c, regs);\r\n}\r\nstatic void write_audio_gpio(struct pmac_gpio *gp, int active)\r\n{\r\nif (! gp->addr)\r\nreturn;\r\nactive = active ? gp->active_val : gp->inactive_val;\r\ndo_gpio_write(gp, active);\r\nDBG("(I) gpio %x write %d\n", gp->addr, active);\r\n}\r\nstatic int check_audio_gpio(struct pmac_gpio *gp)\r\n{\r\nint ret;\r\nif (! gp->addr)\r\nreturn 0;\r\nret = do_gpio_read(gp);\r\nreturn (ret & 0x1) == (gp->active_val & 0x1);\r\n}\r\nstatic int read_audio_gpio(struct pmac_gpio *gp)\r\n{\r\nint ret;\r\nif (! gp->addr)\r\nreturn 0;\r\nret = do_gpio_read(gp);\r\nret = (ret & 0x02) !=0;\r\nreturn ret == gp->active_state;\r\n}\r\nstatic int tumbler_set_master_volume(struct pmac_tumbler *mix)\r\n{\r\nunsigned char block[6];\r\nunsigned int left_vol, right_vol;\r\nif (! mix->i2c.client)\r\nreturn -ENODEV;\r\nif (! mix->master_switch[0])\r\nleft_vol = 0;\r\nelse {\r\nleft_vol = mix->master_vol[0];\r\nif (left_vol >= ARRAY_SIZE(master_volume_table))\r\nleft_vol = ARRAY_SIZE(master_volume_table) - 1;\r\nleft_vol = master_volume_table[left_vol];\r\n}\r\nif (! mix->master_switch[1])\r\nright_vol = 0;\r\nelse {\r\nright_vol = mix->master_vol[1];\r\nif (right_vol >= ARRAY_SIZE(master_volume_table))\r\nright_vol = ARRAY_SIZE(master_volume_table) - 1;\r\nright_vol = master_volume_table[right_vol];\r\n}\r\nblock[0] = (left_vol >> 16) & 0xff;\r\nblock[1] = (left_vol >> 8) & 0xff;\r\nblock[2] = (left_vol >> 0) & 0xff;\r\nblock[3] = (right_vol >> 16) & 0xff;\r\nblock[4] = (right_vol >> 8) & 0xff;\r\nblock[5] = (right_vol >> 0) & 0xff;\r\nif (i2c_smbus_write_i2c_block_data(mix->i2c.client, TAS_REG_VOL, 6,\r\nblock) < 0) {\r\nsnd_printk(KERN_ERR "failed to set volume \n");\r\nreturn -EINVAL;\r\n}\r\nDBG("(I) succeeded to set volume (%u, %u)\n", left_vol, right_vol);\r\nreturn 0;\r\n}\r\nstatic int tumbler_info_master_volume(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = ARRAY_SIZE(master_volume_table) - 1;\r\nreturn 0;\r\n}\r\nstatic int tumbler_get_master_volume(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nstruct pmac_tumbler *mix = chip->mixer_data;\r\nucontrol->value.integer.value[0] = mix->master_vol[0];\r\nucontrol->value.integer.value[1] = mix->master_vol[1];\r\nreturn 0;\r\n}\r\nstatic int tumbler_put_master_volume(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nstruct pmac_tumbler *mix = chip->mixer_data;\r\nunsigned int vol[2];\r\nint change;\r\nvol[0] = ucontrol->value.integer.value[0];\r\nvol[1] = ucontrol->value.integer.value[1];\r\nif (vol[0] >= ARRAY_SIZE(master_volume_table) ||\r\nvol[1] >= ARRAY_SIZE(master_volume_table))\r\nreturn -EINVAL;\r\nchange = mix->master_vol[0] != vol[0] ||\r\nmix->master_vol[1] != vol[1];\r\nif (change) {\r\nmix->master_vol[0] = vol[0];\r\nmix->master_vol[1] = vol[1];\r\ntumbler_set_master_volume(mix);\r\n}\r\nreturn change;\r\n}\r\nstatic int tumbler_get_master_switch(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nstruct pmac_tumbler *mix = chip->mixer_data;\r\nucontrol->value.integer.value[0] = mix->master_switch[0];\r\nucontrol->value.integer.value[1] = mix->master_switch[1];\r\nreturn 0;\r\n}\r\nstatic int tumbler_put_master_switch(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nstruct pmac_tumbler *mix = chip->mixer_data;\r\nint change;\r\nchange = mix->master_switch[0] != ucontrol->value.integer.value[0] ||\r\nmix->master_switch[1] != ucontrol->value.integer.value[1];\r\nif (change) {\r\nmix->master_switch[0] = !!ucontrol->value.integer.value[0];\r\nmix->master_switch[1] = !!ucontrol->value.integer.value[1];\r\ntumbler_set_master_volume(mix);\r\n}\r\nreturn change;\r\n}\r\nstatic int tumbler_set_drc(struct pmac_tumbler *mix)\r\n{\r\nunsigned char val[2];\r\nif (! mix->i2c.client)\r\nreturn -ENODEV;\r\nif (mix->drc_enable) {\r\nval[0] = 0xc1;\r\nif (mix->drc_range > TAS3001_DRC_MAX)\r\nval[1] = 0xf0;\r\nelse if (mix->drc_range < 0)\r\nval[1] = 0x91;\r\nelse\r\nval[1] = mix->drc_range + 0x91;\r\n} else {\r\nval[0] = 0;\r\nval[1] = 0;\r\n}\r\nif (i2c_smbus_write_i2c_block_data(mix->i2c.client, TAS_REG_DRC,\r\n2, val) < 0) {\r\nsnd_printk(KERN_ERR "failed to set DRC\n");\r\nreturn -EINVAL;\r\n}\r\nDBG("(I) succeeded to set DRC (%u, %u)\n", val[0], val[1]);\r\nreturn 0;\r\n}\r\nstatic int snapper_set_drc(struct pmac_tumbler *mix)\r\n{\r\nunsigned char val[6];\r\nif (! mix->i2c.client)\r\nreturn -ENODEV;\r\nif (mix->drc_enable)\r\nval[0] = 0x50;\r\nelse\r\nval[0] = 0x51;\r\nval[1] = 0x02;\r\nif (mix->drc_range > 0xef)\r\nval[2] = 0xef;\r\nelse if (mix->drc_range < 0)\r\nval[2] = 0x00;\r\nelse\r\nval[2] = mix->drc_range;\r\nval[3] = 0xb0;\r\nval[4] = 0x60;\r\nval[5] = 0xa0;\r\nif (i2c_smbus_write_i2c_block_data(mix->i2c.client, TAS_REG_DRC,\r\n6, val) < 0) {\r\nsnd_printk(KERN_ERR "failed to set DRC\n");\r\nreturn -EINVAL;\r\n}\r\nDBG("(I) succeeded to set DRC (%u, %u)\n", val[0], val[1]);\r\nreturn 0;\r\n}\r\nstatic int tumbler_info_drc_value(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max =\r\nchip->model == PMAC_TUMBLER ? TAS3001_DRC_MAX : TAS3004_DRC_MAX;\r\nreturn 0;\r\n}\r\nstatic int tumbler_get_drc_value(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nstruct pmac_tumbler *mix;\r\nif (! (mix = chip->mixer_data))\r\nreturn -ENODEV;\r\nucontrol->value.integer.value[0] = mix->drc_range;\r\nreturn 0;\r\n}\r\nstatic int tumbler_put_drc_value(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nstruct pmac_tumbler *mix;\r\nunsigned int val;\r\nint change;\r\nif (! (mix = chip->mixer_data))\r\nreturn -ENODEV;\r\nval = ucontrol->value.integer.value[0];\r\nif (chip->model == PMAC_TUMBLER) {\r\nif (val > TAS3001_DRC_MAX)\r\nreturn -EINVAL;\r\n} else {\r\nif (val > TAS3004_DRC_MAX)\r\nreturn -EINVAL;\r\n}\r\nchange = mix->drc_range != val;\r\nif (change) {\r\nmix->drc_range = val;\r\nif (chip->model == PMAC_TUMBLER)\r\ntumbler_set_drc(mix);\r\nelse\r\nsnapper_set_drc(mix);\r\n}\r\nreturn change;\r\n}\r\nstatic int tumbler_get_drc_switch(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nstruct pmac_tumbler *mix;\r\nif (! (mix = chip->mixer_data))\r\nreturn -ENODEV;\r\nucontrol->value.integer.value[0] = mix->drc_enable;\r\nreturn 0;\r\n}\r\nstatic int tumbler_put_drc_switch(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nstruct pmac_tumbler *mix;\r\nint change;\r\nif (! (mix = chip->mixer_data))\r\nreturn -ENODEV;\r\nchange = mix->drc_enable != ucontrol->value.integer.value[0];\r\nif (change) {\r\nmix->drc_enable = !!ucontrol->value.integer.value[0];\r\nif (chip->model == PMAC_TUMBLER)\r\ntumbler_set_drc(mix);\r\nelse\r\nsnapper_set_drc(mix);\r\n}\r\nreturn change;\r\n}\r\nstatic int tumbler_set_mono_volume(struct pmac_tumbler *mix,\r\nstruct tumbler_mono_vol *info)\r\n{\r\nunsigned char block[4];\r\nunsigned int vol;\r\nint i;\r\nif (! mix->i2c.client)\r\nreturn -ENODEV;\r\nvol = mix->mono_vol[info->index];\r\nif (vol >= info->max)\r\nvol = info->max - 1;\r\nvol = info->table[vol];\r\nfor (i = 0; i < info->bytes; i++)\r\nblock[i] = (vol >> ((info->bytes - i - 1) * 8)) & 0xff;\r\nif (i2c_smbus_write_i2c_block_data(mix->i2c.client, info->reg,\r\ninfo->bytes, block) < 0) {\r\nsnd_printk(KERN_ERR "failed to set mono volume %d\n",\r\ninfo->index);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tumbler_info_mono(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct tumbler_mono_vol *info = (struct tumbler_mono_vol *)kcontrol->private_value;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = info->max - 1;\r\nreturn 0;\r\n}\r\nstatic int tumbler_get_mono(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct tumbler_mono_vol *info = (struct tumbler_mono_vol *)kcontrol->private_value;\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nstruct pmac_tumbler *mix;\r\nif (! (mix = chip->mixer_data))\r\nreturn -ENODEV;\r\nucontrol->value.integer.value[0] = mix->mono_vol[info->index];\r\nreturn 0;\r\n}\r\nstatic int tumbler_put_mono(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct tumbler_mono_vol *info = (struct tumbler_mono_vol *)kcontrol->private_value;\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nstruct pmac_tumbler *mix;\r\nunsigned int vol;\r\nint change;\r\nif (! (mix = chip->mixer_data))\r\nreturn -ENODEV;\r\nvol = ucontrol->value.integer.value[0];\r\nif (vol >= info->max)\r\nreturn -EINVAL;\r\nchange = mix->mono_vol[info->index] != vol;\r\nif (change) {\r\nmix->mono_vol[info->index] = vol;\r\ntumbler_set_mono_volume(mix, info);\r\n}\r\nreturn change;\r\n}\r\nstatic int snapper_set_mix_vol1(struct pmac_tumbler *mix, int idx, int ch, int reg)\r\n{\r\nint i, j, vol;\r\nunsigned char block[9];\r\nvol = mix->mix_vol[idx][ch];\r\nif (vol >= ARRAY_SIZE(mixer_volume_table)) {\r\nvol = ARRAY_SIZE(mixer_volume_table) - 1;\r\nmix->mix_vol[idx][ch] = vol;\r\n}\r\nfor (i = 0; i < 3; i++) {\r\nvol = mix->mix_vol[i][ch];\r\nvol = mixer_volume_table[vol];\r\nfor (j = 0; j < 3; j++)\r\nblock[i * 3 + j] = (vol >> ((2 - j) * 8)) & 0xff;\r\n}\r\nif (i2c_smbus_write_i2c_block_data(mix->i2c.client, reg,\r\n9, block) < 0) {\r\nsnd_printk(KERN_ERR "failed to set mono volume %d\n", reg);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snapper_set_mix_vol(struct pmac_tumbler *mix, int idx)\r\n{\r\nif (! mix->i2c.client)\r\nreturn -ENODEV;\r\nif (snapper_set_mix_vol1(mix, idx, 0, TAS_REG_LMIX) < 0 ||\r\nsnapper_set_mix_vol1(mix, idx, 1, TAS_REG_RMIX) < 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int snapper_info_mix(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = ARRAY_SIZE(mixer_volume_table) - 1;\r\nreturn 0;\r\n}\r\nstatic int snapper_get_mix(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nint idx = (int)kcontrol->private_value;\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nstruct pmac_tumbler *mix;\r\nif (! (mix = chip->mixer_data))\r\nreturn -ENODEV;\r\nucontrol->value.integer.value[0] = mix->mix_vol[idx][0];\r\nucontrol->value.integer.value[1] = mix->mix_vol[idx][1];\r\nreturn 0;\r\n}\r\nstatic int snapper_put_mix(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nint idx = (int)kcontrol->private_value;\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nstruct pmac_tumbler *mix;\r\nunsigned int vol[2];\r\nint change;\r\nif (! (mix = chip->mixer_data))\r\nreturn -ENODEV;\r\nvol[0] = ucontrol->value.integer.value[0];\r\nvol[1] = ucontrol->value.integer.value[1];\r\nif (vol[0] >= ARRAY_SIZE(mixer_volume_table) ||\r\nvol[1] >= ARRAY_SIZE(mixer_volume_table))\r\nreturn -EINVAL;\r\nchange = mix->mix_vol[idx][0] != vol[0] ||\r\nmix->mix_vol[idx][1] != vol[1];\r\nif (change) {\r\nmix->mix_vol[idx][0] = vol[0];\r\nmix->mix_vol[idx][1] = vol[1];\r\nsnapper_set_mix_vol(mix, idx);\r\n}\r\nreturn change;\r\n}\r\nstatic int tumbler_get_mute_switch(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nstruct pmac_tumbler *mix;\r\nstruct pmac_gpio *gp;\r\nif (! (mix = chip->mixer_data))\r\nreturn -ENODEV;\r\nswitch(kcontrol->private_value) {\r\ncase TUMBLER_MUTE_HP:\r\ngp = &mix->hp_mute; break;\r\ncase TUMBLER_MUTE_AMP:\r\ngp = &mix->amp_mute; break;\r\ncase TUMBLER_MUTE_LINE:\r\ngp = &mix->line_mute; break;\r\ndefault:\r\ngp = NULL;\r\n}\r\nif (gp == NULL)\r\nreturn -EINVAL;\r\nucontrol->value.integer.value[0] = !check_audio_gpio(gp);\r\nreturn 0;\r\n}\r\nstatic int tumbler_put_mute_switch(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nstruct pmac_tumbler *mix;\r\nstruct pmac_gpio *gp;\r\nint val;\r\n#ifdef PMAC_SUPPORT_AUTOMUTE\r\nif (chip->update_automute && chip->auto_mute)\r\nreturn 0;\r\n#endif\r\nif (! (mix = chip->mixer_data))\r\nreturn -ENODEV;\r\nswitch(kcontrol->private_value) {\r\ncase TUMBLER_MUTE_HP:\r\ngp = &mix->hp_mute; break;\r\ncase TUMBLER_MUTE_AMP:\r\ngp = &mix->amp_mute; break;\r\ncase TUMBLER_MUTE_LINE:\r\ngp = &mix->line_mute; break;\r\ndefault:\r\ngp = NULL;\r\n}\r\nif (gp == NULL)\r\nreturn -EINVAL;\r\nval = ! check_audio_gpio(gp);\r\nif (val != ucontrol->value.integer.value[0]) {\r\nwrite_audio_gpio(gp, ! ucontrol->value.integer.value[0]);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snapper_set_capture_source(struct pmac_tumbler *mix)\r\n{\r\nif (! mix->i2c.client)\r\nreturn -ENODEV;\r\nif (mix->capture_source)\r\nmix->acs |= 2;\r\nelse\r\nmix->acs &= ~2;\r\nreturn i2c_smbus_write_byte_data(mix->i2c.client, TAS_REG_ACS, mix->acs);\r\n}\r\nstatic int snapper_info_capture_source(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic const char * const texts[2] = {\r\n"Line", "Mic"\r\n};\r\nreturn snd_ctl_enum_info(uinfo, 1, 2, texts);\r\n}\r\nstatic int snapper_get_capture_source(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nstruct pmac_tumbler *mix = chip->mixer_data;\r\nucontrol->value.enumerated.item[0] = mix->capture_source;\r\nreturn 0;\r\n}\r\nstatic int snapper_put_capture_source(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nstruct pmac_tumbler *mix = chip->mixer_data;\r\nint change;\r\nchange = ucontrol->value.enumerated.item[0] != mix->capture_source;\r\nif (change) {\r\nmix->capture_source = !!ucontrol->value.enumerated.item[0];\r\nsnapper_set_capture_source(mix);\r\n}\r\nreturn change;\r\n}\r\nstatic int tumbler_detect_headphone(struct snd_pmac *chip)\r\n{\r\nstruct pmac_tumbler *mix = chip->mixer_data;\r\nint detect = 0;\r\nif (mix->hp_detect.addr)\r\ndetect |= read_audio_gpio(&mix->hp_detect);\r\nreturn detect;\r\n}\r\nstatic int tumbler_detect_lineout(struct snd_pmac *chip)\r\n{\r\nstruct pmac_tumbler *mix = chip->mixer_data;\r\nint detect = 0;\r\nif (mix->line_detect.addr)\r\ndetect |= read_audio_gpio(&mix->line_detect);\r\nreturn detect;\r\n}\r\nstatic void check_mute(struct snd_pmac *chip, struct pmac_gpio *gp, int val, int do_notify,\r\nstruct snd_kcontrol *sw)\r\n{\r\nif (check_audio_gpio(gp) != val) {\r\nwrite_audio_gpio(gp, val);\r\nif (do_notify)\r\nsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&sw->id);\r\n}\r\n}\r\nstatic void device_change_handler(struct work_struct *work)\r\n{\r\nstruct snd_pmac *chip = device_change_chip;\r\nstruct pmac_tumbler *mix;\r\nint headphone, lineout;\r\nif (!chip)\r\nreturn;\r\nmix = chip->mixer_data;\r\nif (snd_BUG_ON(!mix))\r\nreturn;\r\nheadphone = tumbler_detect_headphone(chip);\r\nlineout = tumbler_detect_lineout(chip);\r\nDBG("headphone: %d, lineout: %d\n", headphone, lineout);\r\nif (headphone || lineout) {\r\nif (headphone)\r\ncheck_mute(chip, &mix->hp_mute, 0, mix->auto_mute_notify,\r\nchip->master_sw_ctl);\r\nif (lineout && mix->line_mute.addr != 0)\r\ncheck_mute(chip, &mix->line_mute, 0, mix->auto_mute_notify,\r\nchip->lineout_sw_ctl);\r\nif (mix->anded_reset)\r\nmsleep(10);\r\ncheck_mute(chip, &mix->amp_mute, !IS_G4DA, mix->auto_mute_notify,\r\nchip->speaker_sw_ctl);\r\n} else {\r\ncheck_mute(chip, &mix->amp_mute, 0, mix->auto_mute_notify,\r\nchip->speaker_sw_ctl);\r\nif (mix->anded_reset)\r\nmsleep(10);\r\ncheck_mute(chip, &mix->hp_mute, 1, mix->auto_mute_notify,\r\nchip->master_sw_ctl);\r\nif (mix->line_mute.addr != 0)\r\ncheck_mute(chip, &mix->line_mute, 1, mix->auto_mute_notify,\r\nchip->lineout_sw_ctl);\r\n}\r\nif (mix->auto_mute_notify)\r\nsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&chip->hp_detect_ctl->id);\r\n#ifdef CONFIG_SND_POWERMAC_AUTO_DRC\r\nmix->drc_enable = ! (headphone || lineout);\r\nif (mix->auto_mute_notify)\r\nsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&chip->drc_sw_ctl->id);\r\nif (chip->model == PMAC_TUMBLER)\r\ntumbler_set_drc(mix);\r\nelse\r\nsnapper_set_drc(mix);\r\n#endif\r\ntumbler_set_master_volume(mix);\r\n}\r\nstatic void tumbler_update_automute(struct snd_pmac *chip, int do_notify)\r\n{\r\nif (chip->auto_mute) {\r\nstruct pmac_tumbler *mix;\r\nmix = chip->mixer_data;\r\nif (snd_BUG_ON(!mix))\r\nreturn;\r\nmix->auto_mute_notify = do_notify;\r\nschedule_work(&device_change);\r\n}\r\n}\r\nstatic irqreturn_t headphone_intr(int irq, void *devid)\r\n{\r\nstruct snd_pmac *chip = devid;\r\nif (chip->update_automute && chip->initialized) {\r\nchip->update_automute(chip, 1);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic struct device_node *find_audio_device(const char *name)\r\n{\r\nstruct device_node *gpiop;\r\nstruct device_node *np;\r\ngpiop = of_find_node_by_name(NULL, "gpio");\r\nif (! gpiop)\r\nreturn NULL;\r\nfor (np = of_get_next_child(gpiop, NULL); np;\r\nnp = of_get_next_child(gpiop, np)) {\r\nconst char *property = of_get_property(np, "audio-gpio", NULL);\r\nif (property && strcmp(property, name) == 0)\r\nbreak;\r\n}\r\nof_node_put(gpiop);\r\nreturn np;\r\n}\r\nstatic struct device_node *find_compatible_audio_device(const char *name)\r\n{\r\nstruct device_node *gpiop;\r\nstruct device_node *np;\r\ngpiop = of_find_node_by_name(NULL, "gpio");\r\nif (!gpiop)\r\nreturn NULL;\r\nfor (np = of_get_next_child(gpiop, NULL); np;\r\nnp = of_get_next_child(gpiop, np)) {\r\nif (of_device_is_compatible(np, name))\r\nbreak;\r\n}\r\nof_node_put(gpiop);\r\nreturn np;\r\n}\r\nstatic long tumbler_find_device(const char *device, const char *platform,\r\nstruct pmac_gpio *gp, int is_compatible)\r\n{\r\nstruct device_node *node;\r\nconst u32 *base;\r\nu32 addr;\r\nlong ret;\r\nif (is_compatible)\r\nnode = find_compatible_audio_device(device);\r\nelse\r\nnode = find_audio_device(device);\r\nif (! node) {\r\nDBG("(W) cannot find audio device %s !\n", device);\r\nsnd_printdd("cannot find device %s\n", device);\r\nreturn -ENODEV;\r\n}\r\nbase = of_get_property(node, "AAPL,address", NULL);\r\nif (! base) {\r\nbase = of_get_property(node, "reg", NULL);\r\nif (!base) {\r\nDBG("(E) cannot find address for device %s !\n", device);\r\nsnd_printd("cannot find address for device %s\n", device);\r\nof_node_put(node);\r\nreturn -ENODEV;\r\n}\r\naddr = *base;\r\nif (addr < 0x50)\r\naddr += 0x50;\r\n} else\r\naddr = *base;\r\ngp->addr = addr & 0x0000ffff;\r\nbase = of_get_property(node, "audio-gpio-active-state", NULL);\r\nif (base) {\r\ngp->active_state = *base;\r\ngp->active_val = (*base) ? 0x5 : 0x4;\r\ngp->inactive_val = (*base) ? 0x4 : 0x5;\r\n} else {\r\nconst u32 *prop = NULL;\r\ngp->active_state = IS_G4DA\r\n&& !strncmp(device, "keywest-gpio1", 13);\r\ngp->active_val = 0x4;\r\ngp->inactive_val = 0x5;\r\nif (platform)\r\nprop = of_get_property(node, platform, NULL);\r\nif (prop) {\r\nif (prop[3] == 0x9 && prop[4] == 0x9) {\r\ngp->active_val = 0xd;\r\ngp->inactive_val = 0xc;\r\n}\r\nif (prop[3] == 0x1 && prop[4] == 0x1) {\r\ngp->active_val = 0x5;\r\ngp->inactive_val = 0x4;\r\n}\r\n}\r\n}\r\nDBG("(I) GPIO device %s found, offset: %x, active state: %d !\n",\r\ndevice, gp->addr, gp->active_state);\r\nret = irq_of_parse_and_map(node, 0);\r\nof_node_put(node);\r\nreturn ret;\r\n}\r\nstatic void tumbler_reset_audio(struct snd_pmac *chip)\r\n{\r\nstruct pmac_tumbler *mix = chip->mixer_data;\r\nif (mix->anded_reset) {\r\nDBG("(I) codec anded reset !\n");\r\nwrite_audio_gpio(&mix->hp_mute, 0);\r\nwrite_audio_gpio(&mix->amp_mute, 0);\r\nmsleep(200);\r\nwrite_audio_gpio(&mix->hp_mute, 1);\r\nwrite_audio_gpio(&mix->amp_mute, 1);\r\nmsleep(100);\r\nwrite_audio_gpio(&mix->hp_mute, 0);\r\nwrite_audio_gpio(&mix->amp_mute, 0);\r\nmsleep(100);\r\n} else {\r\nDBG("(I) codec normal reset !\n");\r\nwrite_audio_gpio(&mix->audio_reset, 0);\r\nmsleep(200);\r\nwrite_audio_gpio(&mix->audio_reset, 1);\r\nmsleep(100);\r\nwrite_audio_gpio(&mix->audio_reset, 0);\r\nmsleep(100);\r\n}\r\n}\r\nstatic void tumbler_suspend(struct snd_pmac *chip)\r\n{\r\nstruct pmac_tumbler *mix = chip->mixer_data;\r\nif (mix->headphone_irq >= 0)\r\ndisable_irq(mix->headphone_irq);\r\nif (mix->lineout_irq >= 0)\r\ndisable_irq(mix->lineout_irq);\r\nmix->save_master_switch[0] = mix->master_switch[0];\r\nmix->save_master_switch[1] = mix->master_switch[1];\r\nmix->save_master_vol[0] = mix->master_vol[0];\r\nmix->save_master_vol[1] = mix->master_vol[1];\r\nmix->master_switch[0] = mix->master_switch[1] = 0;\r\ntumbler_set_master_volume(mix);\r\nif (!mix->anded_reset) {\r\nwrite_audio_gpio(&mix->amp_mute, 1);\r\nwrite_audio_gpio(&mix->hp_mute, 1);\r\n}\r\nif (chip->model == PMAC_SNAPPER) {\r\nmix->acs |= 1;\r\ni2c_smbus_write_byte_data(mix->i2c.client, TAS_REG_ACS, mix->acs);\r\n}\r\nif (mix->anded_reset) {\r\nwrite_audio_gpio(&mix->amp_mute, 1);\r\nwrite_audio_gpio(&mix->hp_mute, 1);\r\n} else\r\nwrite_audio_gpio(&mix->audio_reset, 1);\r\n}\r\nstatic void tumbler_resume(struct snd_pmac *chip)\r\n{\r\nstruct pmac_tumbler *mix = chip->mixer_data;\r\nmix->acs &= ~1;\r\nmix->master_switch[0] = mix->save_master_switch[0];\r\nmix->master_switch[1] = mix->save_master_switch[1];\r\nmix->master_vol[0] = mix->save_master_vol[0];\r\nmix->master_vol[1] = mix->save_master_vol[1];\r\ntumbler_reset_audio(chip);\r\nif (mix->i2c.client && mix->i2c.init_client) {\r\nif (mix->i2c.init_client(&mix->i2c) < 0)\r\nprintk(KERN_ERR "tumbler_init_client error\n");\r\n} else\r\nprintk(KERN_ERR "tumbler: i2c is not initialized\n");\r\nif (chip->model == PMAC_TUMBLER) {\r\ntumbler_set_mono_volume(mix, &tumbler_pcm_vol_info);\r\ntumbler_set_mono_volume(mix, &tumbler_bass_vol_info);\r\ntumbler_set_mono_volume(mix, &tumbler_treble_vol_info);\r\ntumbler_set_drc(mix);\r\n} else {\r\nsnapper_set_mix_vol(mix, VOL_IDX_PCM);\r\nsnapper_set_mix_vol(mix, VOL_IDX_PCM2);\r\nsnapper_set_mix_vol(mix, VOL_IDX_ADC);\r\ntumbler_set_mono_volume(mix, &snapper_bass_vol_info);\r\ntumbler_set_mono_volume(mix, &snapper_treble_vol_info);\r\nsnapper_set_drc(mix);\r\nsnapper_set_capture_source(mix);\r\n}\r\ntumbler_set_master_volume(mix);\r\nif (chip->update_automute)\r\nchip->update_automute(chip, 0);\r\nif (mix->headphone_irq >= 0) {\r\nunsigned char val;\r\nenable_irq(mix->headphone_irq);\r\nval = do_gpio_read(&mix->hp_detect);\r\ndo_gpio_write(&mix->hp_detect, val | 0x80);\r\n}\r\nif (mix->lineout_irq >= 0)\r\nenable_irq(mix->lineout_irq);\r\n}\r\nstatic int tumbler_init(struct snd_pmac *chip)\r\n{\r\nint irq;\r\nstruct pmac_tumbler *mix = chip->mixer_data;\r\nif (tumbler_find_device("audio-hw-reset",\r\n"platform-do-hw-reset",\r\n&mix->audio_reset, 0) < 0)\r\ntumbler_find_device("hw-reset",\r\n"platform-do-hw-reset",\r\n&mix->audio_reset, 1);\r\nif (tumbler_find_device("amp-mute",\r\n"platform-do-amp-mute",\r\n&mix->amp_mute, 0) < 0)\r\ntumbler_find_device("amp-mute",\r\n"platform-do-amp-mute",\r\n&mix->amp_mute, 1);\r\nif (tumbler_find_device("headphone-mute",\r\n"platform-do-headphone-mute",\r\n&mix->hp_mute, 0) < 0)\r\ntumbler_find_device("headphone-mute",\r\n"platform-do-headphone-mute",\r\n&mix->hp_mute, 1);\r\nif (tumbler_find_device("line-output-mute",\r\n"platform-do-lineout-mute",\r\n&mix->line_mute, 0) < 0)\r\ntumbler_find_device("line-output-mute",\r\n"platform-do-lineout-mute",\r\n&mix->line_mute, 1);\r\nirq = tumbler_find_device("headphone-detect",\r\nNULL, &mix->hp_detect, 0);\r\nif (irq <= 0)\r\nirq = tumbler_find_device("headphone-detect",\r\nNULL, &mix->hp_detect, 1);\r\nif (irq <= 0)\r\nirq = tumbler_find_device("keywest-gpio15",\r\nNULL, &mix->hp_detect, 1);\r\nmix->headphone_irq = irq;\r\nirq = tumbler_find_device("line-output-detect",\r\nNULL, &mix->line_detect, 0);\r\nif (irq <= 0)\r\nirq = tumbler_find_device("line-output-detect",\r\nNULL, &mix->line_detect, 1);\r\nif (IS_G4DA && irq <= 0)\r\nirq = tumbler_find_device("keywest-gpio16",\r\nNULL, &mix->line_detect, 1);\r\nmix->lineout_irq = irq;\r\ntumbler_reset_audio(chip);\r\nreturn 0;\r\n}\r\nstatic void tumbler_cleanup(struct snd_pmac *chip)\r\n{\r\nstruct pmac_tumbler *mix = chip->mixer_data;\r\nif (! mix)\r\nreturn;\r\nif (mix->headphone_irq >= 0)\r\nfree_irq(mix->headphone_irq, chip);\r\nif (mix->lineout_irq >= 0)\r\nfree_irq(mix->lineout_irq, chip);\r\ntumbler_gpio_free(&mix->audio_reset);\r\ntumbler_gpio_free(&mix->amp_mute);\r\ntumbler_gpio_free(&mix->hp_mute);\r\ntumbler_gpio_free(&mix->hp_detect);\r\nsnd_pmac_keywest_cleanup(&mix->i2c);\r\nkfree(mix);\r\nchip->mixer_data = NULL;\r\n}\r\nint snd_pmac_tumbler_init(struct snd_pmac *chip)\r\n{\r\nint i, err;\r\nstruct pmac_tumbler *mix;\r\nconst u32 *paddr;\r\nstruct device_node *tas_node, *np;\r\nchar *chipname;\r\nrequest_module("i2c-powermac");\r\nmix = kzalloc(sizeof(*mix), GFP_KERNEL);\r\nif (! mix)\r\nreturn -ENOMEM;\r\nmix->headphone_irq = -1;\r\nchip->mixer_data = mix;\r\nchip->mixer_free = tumbler_cleanup;\r\nmix->anded_reset = 0;\r\nmix->reset_on_sleep = 1;\r\nfor (np = chip->node->child; np; np = np->sibling) {\r\nif (!strcmp(np->name, "sound")) {\r\nif (of_get_property(np, "has-anded-reset", NULL))\r\nmix->anded_reset = 1;\r\nif (of_get_property(np, "layout-id", NULL))\r\nmix->reset_on_sleep = 0;\r\nbreak;\r\n}\r\n}\r\nif ((err = tumbler_init(chip)) < 0)\r\nreturn err;\r\ntas_node = of_find_node_by_name(NULL, "deq");\r\nif (tas_node == NULL)\r\ntas_node = of_find_node_by_name(NULL, "codec");\r\nif (tas_node == NULL)\r\nreturn -ENODEV;\r\npaddr = of_get_property(tas_node, "i2c-address", NULL);\r\nif (paddr == NULL)\r\npaddr = of_get_property(tas_node, "reg", NULL);\r\nif (paddr)\r\nmix->i2c.addr = (*paddr) >> 1;\r\nelse\r\nmix->i2c.addr = TAS_I2C_ADDR;\r\nof_node_put(tas_node);\r\nDBG("(I) TAS i2c address is: %x\n", mix->i2c.addr);\r\nif (chip->model == PMAC_TUMBLER) {\r\nmix->i2c.init_client = tumbler_init_client;\r\nmix->i2c.name = "TAS3001c";\r\nchipname = "Tumbler";\r\n} else {\r\nmix->i2c.init_client = snapper_init_client;\r\nmix->i2c.name = "TAS3004";\r\nchipname = "Snapper";\r\n}\r\nif ((err = snd_pmac_keywest_init(&mix->i2c)) < 0)\r\nreturn err;\r\nsprintf(chip->card->mixername, "PowerMac %s", chipname);\r\nif (chip->model == PMAC_TUMBLER) {\r\nfor (i = 0; i < ARRAY_SIZE(tumbler_mixers); i++) {\r\nif ((err = snd_ctl_add(chip->card, snd_ctl_new1(&tumbler_mixers[i], chip))) < 0)\r\nreturn err;\r\n}\r\n} else {\r\nfor (i = 0; i < ARRAY_SIZE(snapper_mixers); i++) {\r\nif ((err = snd_ctl_add(chip->card, snd_ctl_new1(&snapper_mixers[i], chip))) < 0)\r\nreturn err;\r\n}\r\n}\r\nchip->master_sw_ctl = snd_ctl_new1(&tumbler_hp_sw, chip);\r\nif ((err = snd_ctl_add(chip->card, chip->master_sw_ctl)) < 0)\r\nreturn err;\r\nchip->speaker_sw_ctl = snd_ctl_new1(&tumbler_speaker_sw, chip);\r\nif ((err = snd_ctl_add(chip->card, chip->speaker_sw_ctl)) < 0)\r\nreturn err;\r\nif (mix->line_mute.addr != 0) {\r\nchip->lineout_sw_ctl = snd_ctl_new1(&tumbler_lineout_sw, chip);\r\nif ((err = snd_ctl_add(chip->card, chip->lineout_sw_ctl)) < 0)\r\nreturn err;\r\n}\r\nchip->drc_sw_ctl = snd_ctl_new1(&tumbler_drc_sw, chip);\r\nif ((err = snd_ctl_add(chip->card, chip->drc_sw_ctl)) < 0)\r\nreturn err;\r\nif (chip->model == PMAC_TUMBLER)\r\nmix->drc_range = (TAS3001_DRC_MAX * 6) / 10;\r\nelse\r\nmix->drc_range = (TAS3004_DRC_MAX * 6) / 10;\r\nmix->drc_enable = 1;\r\nif (chip->model == PMAC_TUMBLER)\r\ntumbler_set_drc(mix);\r\nelse\r\nsnapper_set_drc(mix);\r\n#ifdef CONFIG_PM\r\nchip->suspend = tumbler_suspend;\r\nchip->resume = tumbler_resume;\r\n#endif\r\nINIT_WORK(&device_change, device_change_handler);\r\ndevice_change_chip = chip;\r\n#ifdef PMAC_SUPPORT_AUTOMUTE\r\nif ((mix->headphone_irq >=0 || mix->lineout_irq >= 0)\r\n&& (err = snd_pmac_add_automute(chip)) < 0)\r\nreturn err;\r\nchip->detect_headphone = tumbler_detect_headphone;\r\nchip->update_automute = tumbler_update_automute;\r\ntumbler_update_automute(chip, 0);\r\nif (mix->headphone_irq >= 0) {\r\nunsigned char val;\r\nif ((err = request_irq(mix->headphone_irq, headphone_intr, 0,\r\n"Sound Headphone Detection", chip)) < 0)\r\nreturn 0;\r\nval = do_gpio_read(&mix->hp_detect);\r\ndo_gpio_write(&mix->hp_detect, val | 0x80);\r\n}\r\nif (mix->lineout_irq >= 0) {\r\nunsigned char val;\r\nif ((err = request_irq(mix->lineout_irq, headphone_intr, 0,\r\n"Sound Lineout Detection", chip)) < 0)\r\nreturn 0;\r\nval = do_gpio_read(&mix->line_detect);\r\ndo_gpio_write(&mix->line_detect, val | 0x80);\r\n}\r\n#endif\r\nreturn 0;\r\n}
