void\r\nqedf_dbg_host_init(struct qedf_dbg_ctx *qedf,\r\nstruct qedf_debugfs_ops *dops,\r\nstruct file_operations *fops)\r\n{\r\nchar host_dirname[32];\r\nstruct dentry *file_dentry = NULL;\r\nQEDF_INFO(qedf, QEDF_LOG_DEBUGFS, "Creating debugfs host node\n");\r\nsprintf(host_dirname, "host%u", qedf->host_no);\r\nqedf->bdf_dentry = debugfs_create_dir(host_dirname, qedf_dbg_root);\r\nif (!qedf->bdf_dentry)\r\nreturn;\r\nwhile (dops) {\r\nif (!(dops->name))\r\nbreak;\r\nfile_dentry = debugfs_create_file(dops->name, 0600,\r\nqedf->bdf_dentry, qedf,\r\nfops);\r\nif (!file_dentry) {\r\nQEDF_INFO(qedf, QEDF_LOG_DEBUGFS,\r\n"Debugfs entry %s creation failed\n",\r\ndops->name);\r\ndebugfs_remove_recursive(qedf->bdf_dentry);\r\nreturn;\r\n}\r\ndops++;\r\nfops++;\r\n}\r\n}\r\nvoid\r\nqedf_dbg_host_exit(struct qedf_dbg_ctx *qedf)\r\n{\r\nQEDF_INFO(qedf, QEDF_LOG_DEBUGFS, "Destroying debugfs host "\r\n"entry\n");\r\ndebugfs_remove_recursive(qedf->bdf_dentry);\r\nqedf->bdf_dentry = NULL;\r\n}\r\nvoid\r\nqedf_dbg_init(char *drv_name)\r\n{\r\nQEDF_INFO(NULL, QEDF_LOG_DEBUGFS, "Creating debugfs root node\n");\r\nqedf_dbg_root = debugfs_create_dir(drv_name, NULL);\r\nif (!qedf_dbg_root)\r\nQEDF_INFO(NULL, QEDF_LOG_DEBUGFS, "Init of debugfs "\r\n"failed\n");\r\n}\r\nvoid\r\nqedf_dbg_exit(void)\r\n{\r\nQEDF_INFO(NULL, QEDF_LOG_DEBUGFS, "Destroying debugfs root "\r\n"entry\n");\r\ndebugfs_remove_recursive(qedf_dbg_root);\r\nqedf_dbg_root = NULL;\r\n}\r\nstatic ssize_t\r\nqedf_dbg_fp_int_cmd_read(struct file *filp, char __user *buffer, size_t count,\r\nloff_t *ppos)\r\n{\r\nsize_t cnt = 0;\r\nint id;\r\nstruct qedf_fastpath *fp = NULL;\r\nstruct qedf_dbg_ctx *qedf_dbg =\r\n(struct qedf_dbg_ctx *)filp->private_data;\r\nstruct qedf_ctx *qedf = container_of(qedf_dbg,\r\nstruct qedf_ctx, dbg_ctx);\r\nQEDF_INFO(qedf_dbg, QEDF_LOG_DEBUGFS, "entered\n");\r\ncnt = sprintf(buffer, "\nFastpath I/O completions\n\n");\r\nfor (id = 0; id < qedf->num_queues; id++) {\r\nfp = &(qedf->fp_array[id]);\r\nif (fp->sb_id == QEDF_SB_ID_NULL)\r\ncontinue;\r\ncnt += sprintf((buffer + cnt), "#%d: %lu\n", id,\r\nfp->completions);\r\n}\r\ncnt = min_t(int, count, cnt - *ppos);\r\n*ppos += cnt;\r\nreturn cnt;\r\n}\r\nstatic ssize_t\r\nqedf_dbg_fp_int_cmd_write(struct file *filp, const char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nif (!count || *ppos)\r\nreturn 0;\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nqedf_dbg_debug_cmd_read(struct file *filp, char __user *buffer, size_t count,\r\nloff_t *ppos)\r\n{\r\nint cnt;\r\nstruct qedf_dbg_ctx *qedf =\r\n(struct qedf_dbg_ctx *)filp->private_data;\r\nQEDF_INFO(qedf, QEDF_LOG_DEBUGFS, "entered\n");\r\ncnt = sprintf(buffer, "debug mask = 0x%x\n", qedf_debug);\r\ncnt = min_t(int, count, cnt - *ppos);\r\n*ppos += cnt;\r\nreturn cnt;\r\n}\r\nstatic ssize_t\r\nqedf_dbg_debug_cmd_write(struct file *filp, const char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nuint32_t val;\r\nvoid *kern_buf;\r\nint rval;\r\nstruct qedf_dbg_ctx *qedf =\r\n(struct qedf_dbg_ctx *)filp->private_data;\r\nif (!count || *ppos)\r\nreturn 0;\r\nkern_buf = memdup_user(buffer, count);\r\nif (IS_ERR(kern_buf))\r\nreturn PTR_ERR(kern_buf);\r\nrval = kstrtouint(kern_buf, 10, &val);\r\nkfree(kern_buf);\r\nif (rval)\r\nreturn rval;\r\nif (val == 1)\r\nqedf_debug = QEDF_DEFAULT_LOG_MASK;\r\nelse\r\nqedf_debug = val;\r\nQEDF_INFO(qedf, QEDF_LOG_DEBUGFS, "Setting debug=0x%x.\n", val);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nqedf_dbg_stop_io_on_error_cmd_read(struct file *filp, char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nint cnt;\r\nstruct qedf_dbg_ctx *qedf_dbg =\r\n(struct qedf_dbg_ctx *)filp->private_data;\r\nstruct qedf_ctx *qedf = container_of(qedf_dbg,\r\nstruct qedf_ctx, dbg_ctx);\r\nQEDF_INFO(qedf_dbg, QEDF_LOG_DEBUGFS, "entered\n");\r\ncnt = sprintf(buffer, "%s\n",\r\nqedf->stop_io_on_error ? "true" : "false");\r\ncnt = min_t(int, count, cnt - *ppos);\r\n*ppos += cnt;\r\nreturn cnt;\r\n}\r\nstatic ssize_t\r\nqedf_dbg_stop_io_on_error_cmd_write(struct file *filp,\r\nconst char __user *buffer, size_t count,\r\nloff_t *ppos)\r\n{\r\nvoid *kern_buf;\r\nstruct qedf_dbg_ctx *qedf_dbg =\r\n(struct qedf_dbg_ctx *)filp->private_data;\r\nstruct qedf_ctx *qedf = container_of(qedf_dbg, struct qedf_ctx,\r\ndbg_ctx);\r\nQEDF_INFO(qedf_dbg, QEDF_LOG_DEBUGFS, "entered\n");\r\nif (!count || *ppos)\r\nreturn 0;\r\nkern_buf = memdup_user(buffer, 6);\r\nif (IS_ERR(kern_buf))\r\nreturn PTR_ERR(kern_buf);\r\nif (strncmp(kern_buf, "false", 5) == 0)\r\nqedf->stop_io_on_error = false;\r\nelse if (strncmp(kern_buf, "true", 4) == 0)\r\nqedf->stop_io_on_error = true;\r\nelse if (strncmp(kern_buf, "now", 3) == 0)\r\nset_bit(QEDF_DBG_STOP_IO, &qedf->flags);\r\nkfree(kern_buf);\r\nreturn count;\r\n}\r\nstatic int\r\nqedf_io_trace_show(struct seq_file *s, void *unused)\r\n{\r\nint i, idx = 0;\r\nstruct qedf_ctx *qedf = s->private;\r\nstruct qedf_dbg_ctx *qedf_dbg = &qedf->dbg_ctx;\r\nstruct qedf_io_log *io_log;\r\nunsigned long flags;\r\nif (!qedf_io_tracing) {\r\nseq_puts(s, "I/O tracing not enabled.\n");\r\ngoto out;\r\n}\r\nQEDF_INFO(qedf_dbg, QEDF_LOG_DEBUGFS, "entered\n");\r\nspin_lock_irqsave(&qedf->io_trace_lock, flags);\r\nidx = qedf->io_trace_idx;\r\nfor (i = 0; i < QEDF_IO_TRACE_SIZE; i++) {\r\nio_log = &qedf->io_trace_buf[idx];\r\nseq_printf(s, "%d:", io_log->direction);\r\nseq_printf(s, "0x%x:", io_log->task_id);\r\nseq_printf(s, "0x%06x:", io_log->port_id);\r\nseq_printf(s, "%d:", io_log->lun);\r\nseq_printf(s, "0x%02x:", io_log->op);\r\nseq_printf(s, "0x%02x%02x%02x%02x:", io_log->lba[0],\r\nio_log->lba[1], io_log->lba[2], io_log->lba[3]);\r\nseq_printf(s, "%d:", io_log->bufflen);\r\nseq_printf(s, "%d:", io_log->sg_count);\r\nseq_printf(s, "0x%08x:", io_log->result);\r\nseq_printf(s, "%lu:", io_log->jiffies);\r\nseq_printf(s, "%d:", io_log->refcount);\r\nseq_printf(s, "%d:", io_log->req_cpu);\r\nseq_printf(s, "%d:", io_log->int_cpu);\r\nseq_printf(s, "%d:", io_log->rsp_cpu);\r\nseq_printf(s, "%d\n", io_log->sge_type);\r\nidx++;\r\nif (idx == QEDF_IO_TRACE_SIZE)\r\nidx = 0;\r\n}\r\nspin_unlock_irqrestore(&qedf->io_trace_lock, flags);\r\nout:\r\nreturn 0;\r\n}\r\nstatic int\r\nqedf_dbg_io_trace_open(struct inode *inode, struct file *file)\r\n{\r\nstruct qedf_dbg_ctx *qedf_dbg = inode->i_private;\r\nstruct qedf_ctx *qedf = container_of(qedf_dbg,\r\nstruct qedf_ctx, dbg_ctx);\r\nreturn single_open(file, qedf_io_trace_show, qedf);\r\n}\r\nstatic int\r\nqedf_driver_stats_show(struct seq_file *s, void *unused)\r\n{\r\nstruct qedf_ctx *qedf = s->private;\r\nstruct qedf_rport *fcport;\r\nstruct fc_rport_priv *rdata;\r\nseq_printf(s, "cmg_mgr free io_reqs: %d\n",\r\natomic_read(&qedf->cmd_mgr->free_list_cnt));\r\nseq_printf(s, "slow SGEs: %d\n", qedf->slow_sge_ios);\r\nseq_printf(s, "single SGEs: %d\n", qedf->single_sge_ios);\r\nseq_printf(s, "fast SGEs: %d\n\n", qedf->fast_sge_ios);\r\nseq_puts(s, "Offloaded ports:\n\n");\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(fcport, &qedf->fcports, peers) {\r\nrdata = fcport->rdata;\r\nif (rdata == NULL)\r\ncontinue;\r\nseq_printf(s, "%06x: free_sqes: %d, num_active_ios: %d\n",\r\nrdata->ids.port_id, atomic_read(&fcport->free_sqes),\r\natomic_read(&fcport->num_active_ios));\r\n}\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nstatic int\r\nqedf_dbg_driver_stats_open(struct inode *inode, struct file *file)\r\n{\r\nstruct qedf_dbg_ctx *qedf_dbg = inode->i_private;\r\nstruct qedf_ctx *qedf = container_of(qedf_dbg,\r\nstruct qedf_ctx, dbg_ctx);\r\nreturn single_open(file, qedf_driver_stats_show, qedf);\r\n}\r\nstatic ssize_t\r\nqedf_dbg_clear_stats_cmd_read(struct file *filp, char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nint cnt = 0;\r\ncnt = min_t(int, count, cnt - *ppos);\r\n*ppos += cnt;\r\nreturn cnt;\r\n}\r\nstatic ssize_t\r\nqedf_dbg_clear_stats_cmd_write(struct file *filp,\r\nconst char __user *buffer, size_t count,\r\nloff_t *ppos)\r\n{\r\nstruct qedf_dbg_ctx *qedf_dbg =\r\n(struct qedf_dbg_ctx *)filp->private_data;\r\nstruct qedf_ctx *qedf = container_of(qedf_dbg, struct qedf_ctx,\r\ndbg_ctx);\r\nQEDF_INFO(qedf_dbg, QEDF_LOG_DEBUGFS, "Clearing stat counters.\n");\r\nif (!count || *ppos)\r\nreturn 0;\r\nqedf->slow_sge_ios = 0;\r\nqedf->single_sge_ios = 0;\r\nqedf->fast_sge_ios = 0;\r\nreturn count;\r\n}\r\nstatic int\r\nqedf_offload_stats_show(struct seq_file *s, void *unused)\r\n{\r\nstruct qedf_ctx *qedf = s->private;\r\nstruct qed_fcoe_stats *fw_fcoe_stats;\r\nfw_fcoe_stats = kmalloc(sizeof(struct qed_fcoe_stats), GFP_KERNEL);\r\nif (!fw_fcoe_stats) {\r\nQEDF_ERR(&(qedf->dbg_ctx), "Could not allocate memory for "\r\n"fw_fcoe_stats.\n");\r\ngoto out;\r\n}\r\nqed_ops->get_stats(qedf->cdev, fw_fcoe_stats);\r\nseq_printf(s, "fcoe_rx_byte_cnt=%llu\n"\r\n"fcoe_rx_data_pkt_cnt=%llu\n"\r\n"fcoe_rx_xfer_pkt_cnt=%llu\n"\r\n"fcoe_rx_other_pkt_cnt=%llu\n"\r\n"fcoe_silent_drop_pkt_cmdq_full_cnt=%u\n"\r\n"fcoe_silent_drop_pkt_crc_error_cnt=%u\n"\r\n"fcoe_silent_drop_pkt_task_invalid_cnt=%u\n"\r\n"fcoe_silent_drop_total_pkt_cnt=%u\n"\r\n"fcoe_silent_drop_pkt_rq_full_cnt=%u\n"\r\n"fcoe_tx_byte_cnt=%llu\n"\r\n"fcoe_tx_data_pkt_cnt=%llu\n"\r\n"fcoe_tx_xfer_pkt_cnt=%llu\n"\r\n"fcoe_tx_other_pkt_cnt=%llu\n",\r\nfw_fcoe_stats->fcoe_rx_byte_cnt,\r\nfw_fcoe_stats->fcoe_rx_data_pkt_cnt,\r\nfw_fcoe_stats->fcoe_rx_xfer_pkt_cnt,\r\nfw_fcoe_stats->fcoe_rx_other_pkt_cnt,\r\nfw_fcoe_stats->fcoe_silent_drop_pkt_cmdq_full_cnt,\r\nfw_fcoe_stats->fcoe_silent_drop_pkt_crc_error_cnt,\r\nfw_fcoe_stats->fcoe_silent_drop_pkt_task_invalid_cnt,\r\nfw_fcoe_stats->fcoe_silent_drop_total_pkt_cnt,\r\nfw_fcoe_stats->fcoe_silent_drop_pkt_rq_full_cnt,\r\nfw_fcoe_stats->fcoe_tx_byte_cnt,\r\nfw_fcoe_stats->fcoe_tx_data_pkt_cnt,\r\nfw_fcoe_stats->fcoe_tx_xfer_pkt_cnt,\r\nfw_fcoe_stats->fcoe_tx_other_pkt_cnt);\r\nkfree(fw_fcoe_stats);\r\nout:\r\nreturn 0;\r\n}\r\nstatic int\r\nqedf_dbg_offload_stats_open(struct inode *inode, struct file *file)\r\n{\r\nstruct qedf_dbg_ctx *qedf_dbg = inode->i_private;\r\nstruct qedf_ctx *qedf = container_of(qedf_dbg,\r\nstruct qedf_ctx, dbg_ctx);\r\nreturn single_open(file, qedf_offload_stats_show, qedf);\r\n}
