static int snd_opl3_oss_event_input(struct snd_seq_event *ev, int direct,\r\nvoid *private_data, int atomic, int hop)\r\n{\r\nstruct snd_opl3 *opl3 = private_data;\r\nif (ev->type != SNDRV_SEQ_EVENT_OSS)\r\nsnd_midi_process_event(&opl3_ops, ev, opl3->oss_chset);\r\nreturn 0;\r\n}\r\nstatic void snd_opl3_oss_free_port(void *private_data)\r\n{\r\nstruct snd_opl3 *opl3 = private_data;\r\nsnd_midi_channel_free_set(opl3->oss_chset);\r\n}\r\nstatic int snd_opl3_oss_create_port(struct snd_opl3 * opl3)\r\n{\r\nstruct snd_seq_port_callback callbacks;\r\nchar name[32];\r\nint voices, opl_ver;\r\nvoices = (opl3->hardware < OPL3_HW_OPL3) ?\r\nMAX_OPL2_VOICES : MAX_OPL3_VOICES;\r\nopl3->oss_chset = snd_midi_channel_alloc_set(voices);\r\nif (opl3->oss_chset == NULL)\r\nreturn -ENOMEM;\r\nopl3->oss_chset->private_data = opl3;\r\nmemset(&callbacks, 0, sizeof(callbacks));\r\ncallbacks.owner = THIS_MODULE;\r\ncallbacks.event_input = snd_opl3_oss_event_input;\r\ncallbacks.private_free = snd_opl3_oss_free_port;\r\ncallbacks.private_data = opl3;\r\nopl_ver = (opl3->hardware & OPL3_HW_MASK) >> 8;\r\nsprintf(name, "OPL%i OSS Port", opl_ver);\r\nopl3->oss_chset->client = opl3->seq_client;\r\nopl3->oss_chset->port = snd_seq_event_port_attach(opl3->seq_client, &callbacks,\r\nSNDRV_SEQ_PORT_CAP_WRITE,\r\nSNDRV_SEQ_PORT_TYPE_MIDI_GENERIC |\r\nSNDRV_SEQ_PORT_TYPE_MIDI_GM |\r\nSNDRV_SEQ_PORT_TYPE_HARDWARE |\r\nSNDRV_SEQ_PORT_TYPE_SYNTHESIZER,\r\nvoices, voices,\r\nname);\r\nif (opl3->oss_chset->port < 0) {\r\nint port;\r\nport = opl3->oss_chset->port;\r\nsnd_midi_channel_free_set(opl3->oss_chset);\r\nreturn port;\r\n}\r\nreturn 0;\r\n}\r\nvoid snd_opl3_init_seq_oss(struct snd_opl3 *opl3, char *name)\r\n{\r\nstruct snd_seq_oss_reg *arg;\r\nstruct snd_seq_device *dev;\r\nif (snd_seq_device_new(opl3->card, 0, SNDRV_SEQ_DEV_ID_OSS,\r\nsizeof(struct snd_seq_oss_reg), &dev) < 0)\r\nreturn;\r\nopl3->oss_seq_dev = dev;\r\nstrlcpy(dev->name, name, sizeof(dev->name));\r\narg = SNDRV_SEQ_DEVICE_ARGPTR(dev);\r\narg->type = SYNTH_TYPE_FM;\r\nif (opl3->hardware < OPL3_HW_OPL3) {\r\narg->subtype = FM_TYPE_ADLIB;\r\narg->nvoices = MAX_OPL2_VOICES;\r\n} else {\r\narg->subtype = FM_TYPE_OPL3;\r\narg->nvoices = MAX_OPL3_VOICES;\r\n}\r\narg->oper = oss_callback;\r\narg->private_data = opl3;\r\nif (snd_opl3_oss_create_port(opl3)) {\r\nsnd_device_register(opl3->card, dev);\r\n}\r\n}\r\nvoid snd_opl3_free_seq_oss(struct snd_opl3 *opl3)\r\n{\r\nif (opl3->oss_seq_dev) {\r\nopl3->oss_seq_dev = NULL;\r\n}\r\n}\r\nstatic int snd_opl3_open_seq_oss(struct snd_seq_oss_arg *arg, void *closure)\r\n{\r\nstruct snd_opl3 *opl3 = closure;\r\nint err;\r\nif (snd_BUG_ON(!arg))\r\nreturn -ENXIO;\r\nif ((err = snd_opl3_synth_setup(opl3)) < 0)\r\nreturn err;\r\narg->private_data = opl3;\r\narg->addr.client = opl3->oss_chset->client;\r\narg->addr.port = opl3->oss_chset->port;\r\nif ((err = snd_opl3_synth_use_inc(opl3)) < 0)\r\nreturn err;\r\nopl3->synth_mode = SNDRV_OPL3_MODE_SYNTH;\r\nreturn 0;\r\n}\r\nstatic int snd_opl3_close_seq_oss(struct snd_seq_oss_arg *arg)\r\n{\r\nstruct snd_opl3 *opl3;\r\nif (snd_BUG_ON(!arg))\r\nreturn -ENXIO;\r\nopl3 = arg->private_data;\r\nsnd_opl3_synth_cleanup(opl3);\r\nsnd_opl3_synth_use_dec(opl3);\r\nreturn 0;\r\n}\r\nstatic int snd_opl3_load_patch_seq_oss(struct snd_seq_oss_arg *arg, int format,\r\nconst char __user *buf, int offs, int count)\r\n{\r\nstruct snd_opl3 *opl3;\r\nstruct sbi_instrument sbi;\r\nchar name[32];\r\nint err, type;\r\nif (snd_BUG_ON(!arg))\r\nreturn -ENXIO;\r\nopl3 = arg->private_data;\r\nif (format == FM_PATCH)\r\ntype = FM_PATCH_OPL2;\r\nelse if (format == OPL3_PATCH)\r\ntype = FM_PATCH_OPL3;\r\nelse\r\nreturn -EINVAL;\r\nif (count < (int)sizeof(sbi)) {\r\nsnd_printk(KERN_ERR "FM Error: Patch record too short\n");\r\nreturn -EINVAL;\r\n}\r\nif (copy_from_user(&sbi, buf, sizeof(sbi)))\r\nreturn -EFAULT;\r\nif (sbi.channel < 0 || sbi.channel >= SBFM_MAXINSTR) {\r\nsnd_printk(KERN_ERR "FM Error: Invalid instrument number %d\n",\r\nsbi.channel);\r\nreturn -EINVAL;\r\n}\r\nmemset(name, 0, sizeof(name));\r\nsprintf(name, "Chan%d", sbi.channel);\r\nerr = snd_opl3_load_patch(opl3, sbi.channel, 127, type, name, NULL,\r\nsbi.operators);\r\nif (err < 0)\r\nreturn err;\r\nreturn sizeof(sbi);\r\n}\r\nstatic int snd_opl3_ioctl_seq_oss(struct snd_seq_oss_arg *arg, unsigned int cmd,\r\nunsigned long ioarg)\r\n{\r\nstruct snd_opl3 *opl3;\r\nif (snd_BUG_ON(!arg))\r\nreturn -ENXIO;\r\nopl3 = arg->private_data;\r\nswitch (cmd) {\r\ncase SNDCTL_FM_LOAD_INSTR:\r\nsnd_printk(KERN_ERR "OPL3: "\r\n"Obsolete ioctl(SNDCTL_FM_LOAD_INSTR) used. "\r\n"Fix the program.\n");\r\nreturn -EINVAL;\r\ncase SNDCTL_SYNTH_MEMAVL:\r\nreturn 0x7fffffff;\r\ncase SNDCTL_FM_4OP_ENABLE:\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_opl3_reset_seq_oss(struct snd_seq_oss_arg *arg)\r\n{\r\nstruct snd_opl3 *opl3;\r\nif (snd_BUG_ON(!arg))\r\nreturn -ENXIO;\r\nopl3 = arg->private_data;\r\nreturn 0;\r\n}
