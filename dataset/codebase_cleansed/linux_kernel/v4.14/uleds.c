static void uleds_brightness_set(struct led_classdev *led_cdev,\r\nenum led_brightness brightness)\r\n{\r\nstruct uleds_device *udev = container_of(led_cdev, struct uleds_device,\r\nled_cdev);\r\nif (udev->brightness != brightness) {\r\nudev->brightness = brightness;\r\nudev->new_data = true;\r\nwake_up_interruptible(&udev->waitq);\r\n}\r\n}\r\nstatic int uleds_open(struct inode *inode, struct file *file)\r\n{\r\nstruct uleds_device *udev;\r\nudev = kzalloc(sizeof(*udev), GFP_KERNEL);\r\nif (!udev)\r\nreturn -ENOMEM;\r\nudev->led_cdev.name = udev->user_dev.name;\r\nudev->led_cdev.brightness_set = uleds_brightness_set;\r\nmutex_init(&udev->mutex);\r\ninit_waitqueue_head(&udev->waitq);\r\nudev->state = ULEDS_STATE_UNKNOWN;\r\nfile->private_data = udev;\r\nnonseekable_open(inode, file);\r\nreturn 0;\r\n}\r\nstatic ssize_t uleds_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct uleds_device *udev = file->private_data;\r\nconst char *name;\r\nint ret;\r\nif (count == 0)\r\nreturn 0;\r\nret = mutex_lock_interruptible(&udev->mutex);\r\nif (ret)\r\nreturn ret;\r\nif (udev->state == ULEDS_STATE_REGISTERED) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nif (count != sizeof(struct uleds_user_dev)) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (copy_from_user(&udev->user_dev, buffer,\r\nsizeof(struct uleds_user_dev))) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nname = udev->user_dev.name;\r\nif (!name[0] || !strcmp(name, ".") || !strcmp(name, "..") ||\r\nstrchr(name, '/')) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (udev->user_dev.max_brightness <= 0) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nudev->led_cdev.max_brightness = udev->user_dev.max_brightness;\r\nret = devm_led_classdev_register(uleds_misc.this_device,\r\n&udev->led_cdev);\r\nif (ret < 0)\r\ngoto out;\r\nudev->new_data = true;\r\nudev->state = ULEDS_STATE_REGISTERED;\r\nret = count;\r\nout:\r\nmutex_unlock(&udev->mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t uleds_read(struct file *file, char __user *buffer, size_t count,\r\nloff_t *ppos)\r\n{\r\nstruct uleds_device *udev = file->private_data;\r\nssize_t retval;\r\nif (count < sizeof(udev->brightness))\r\nreturn 0;\r\ndo {\r\nretval = mutex_lock_interruptible(&udev->mutex);\r\nif (retval)\r\nreturn retval;\r\nif (udev->state != ULEDS_STATE_REGISTERED) {\r\nretval = -ENODEV;\r\n} else if (!udev->new_data && (file->f_flags & O_NONBLOCK)) {\r\nretval = -EAGAIN;\r\n} else if (udev->new_data) {\r\nretval = copy_to_user(buffer, &udev->brightness,\r\nsizeof(udev->brightness));\r\nudev->new_data = false;\r\nretval = sizeof(udev->brightness);\r\n}\r\nmutex_unlock(&udev->mutex);\r\nif (retval)\r\nbreak;\r\nif (!(file->f_flags & O_NONBLOCK))\r\nretval = wait_event_interruptible(udev->waitq,\r\nudev->new_data ||\r\nudev->state != ULEDS_STATE_REGISTERED);\r\n} while (retval == 0);\r\nreturn retval;\r\n}\r\nstatic unsigned int uleds_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct uleds_device *udev = file->private_data;\r\npoll_wait(file, &udev->waitq, wait);\r\nif (udev->new_data)\r\nreturn POLLIN | POLLRDNORM;\r\nreturn 0;\r\n}\r\nstatic int uleds_release(struct inode *inode, struct file *file)\r\n{\r\nstruct uleds_device *udev = file->private_data;\r\nif (udev->state == ULEDS_STATE_REGISTERED) {\r\nudev->state = ULEDS_STATE_UNKNOWN;\r\ndevm_led_classdev_unregister(uleds_misc.this_device,\r\n&udev->led_cdev);\r\n}\r\nkfree(udev);\r\nreturn 0;\r\n}\r\nstatic int __init uleds_init(void)\r\n{\r\nreturn misc_register(&uleds_misc);\r\n}\r\nstatic void __exit uleds_exit(void)\r\n{\r\nmisc_deregister(&uleds_misc);\r\n}
