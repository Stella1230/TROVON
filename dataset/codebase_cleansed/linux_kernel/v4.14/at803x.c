static int at803x_debug_reg_read(struct phy_device *phydev, u16 reg)\r\n{\r\nint ret;\r\nret = phy_write(phydev, AT803X_DEBUG_ADDR, reg);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn phy_read(phydev, AT803X_DEBUG_DATA);\r\n}\r\nstatic int at803x_debug_reg_mask(struct phy_device *phydev, u16 reg,\r\nu16 clear, u16 set)\r\n{\r\nu16 val;\r\nint ret;\r\nret = at803x_debug_reg_read(phydev, reg);\r\nif (ret < 0)\r\nreturn ret;\r\nval = ret & 0xffff;\r\nval &= ~clear;\r\nval |= set;\r\nreturn phy_write(phydev, AT803X_DEBUG_DATA, val);\r\n}\r\nstatic inline int at803x_enable_rx_delay(struct phy_device *phydev)\r\n{\r\nreturn at803x_debug_reg_mask(phydev, AT803X_DEBUG_REG_0, 0,\r\nAT803X_DEBUG_RX_CLK_DLY_EN);\r\n}\r\nstatic inline int at803x_enable_tx_delay(struct phy_device *phydev)\r\n{\r\nreturn at803x_debug_reg_mask(phydev, AT803X_DEBUG_REG_5, 0,\r\nAT803X_DEBUG_TX_CLK_DLY_EN);\r\n}\r\nstatic void at803x_context_save(struct phy_device *phydev,\r\nstruct at803x_context *context)\r\n{\r\ncontext->bmcr = phy_read(phydev, MII_BMCR);\r\ncontext->advertise = phy_read(phydev, MII_ADVERTISE);\r\ncontext->control1000 = phy_read(phydev, MII_CTRL1000);\r\ncontext->int_enable = phy_read(phydev, AT803X_INTR_ENABLE);\r\ncontext->smart_speed = phy_read(phydev, AT803X_SMART_SPEED);\r\ncontext->led_control = phy_read(phydev, AT803X_LED_CONTROL);\r\n}\r\nstatic void at803x_context_restore(struct phy_device *phydev,\r\nconst struct at803x_context *context)\r\n{\r\nphy_write(phydev, MII_BMCR, context->bmcr);\r\nphy_write(phydev, MII_ADVERTISE, context->advertise);\r\nphy_write(phydev, MII_CTRL1000, context->control1000);\r\nphy_write(phydev, AT803X_INTR_ENABLE, context->int_enable);\r\nphy_write(phydev, AT803X_SMART_SPEED, context->smart_speed);\r\nphy_write(phydev, AT803X_LED_CONTROL, context->led_control);\r\n}\r\nstatic int at803x_set_wol(struct phy_device *phydev,\r\nstruct ethtool_wolinfo *wol)\r\n{\r\nstruct net_device *ndev = phydev->attached_dev;\r\nconst u8 *mac;\r\nint ret;\r\nu32 value;\r\nunsigned int i, offsets[] = {\r\nAT803X_LOC_MAC_ADDR_32_47_OFFSET,\r\nAT803X_LOC_MAC_ADDR_16_31_OFFSET,\r\nAT803X_LOC_MAC_ADDR_0_15_OFFSET,\r\n};\r\nif (!ndev)\r\nreturn -ENODEV;\r\nif (wol->wolopts & WAKE_MAGIC) {\r\nmac = (const u8 *) ndev->dev_addr;\r\nif (!is_valid_ether_addr(mac))\r\nreturn -EFAULT;\r\nfor (i = 0; i < 3; i++) {\r\nphy_write(phydev, AT803X_MMD_ACCESS_CONTROL,\r\nAT803X_DEVICE_ADDR);\r\nphy_write(phydev, AT803X_MMD_ACCESS_CONTROL_DATA,\r\noffsets[i]);\r\nphy_write(phydev, AT803X_MMD_ACCESS_CONTROL,\r\nAT803X_FUNC_DATA);\r\nphy_write(phydev, AT803X_MMD_ACCESS_CONTROL_DATA,\r\nmac[(i * 2) + 1] | (mac[(i * 2)] << 8));\r\n}\r\nvalue = phy_read(phydev, AT803X_INTR_ENABLE);\r\nvalue |= AT803X_INTR_ENABLE_WOL;\r\nret = phy_write(phydev, AT803X_INTR_ENABLE, value);\r\nif (ret)\r\nreturn ret;\r\nvalue = phy_read(phydev, AT803X_INTR_STATUS);\r\n} else {\r\nvalue = phy_read(phydev, AT803X_INTR_ENABLE);\r\nvalue &= (~AT803X_INTR_ENABLE_WOL);\r\nret = phy_write(phydev, AT803X_INTR_ENABLE, value);\r\nif (ret)\r\nreturn ret;\r\nvalue = phy_read(phydev, AT803X_INTR_STATUS);\r\n}\r\nreturn ret;\r\n}\r\nstatic void at803x_get_wol(struct phy_device *phydev,\r\nstruct ethtool_wolinfo *wol)\r\n{\r\nu32 value;\r\nwol->supported = WAKE_MAGIC;\r\nwol->wolopts = 0;\r\nvalue = phy_read(phydev, AT803X_INTR_ENABLE);\r\nif (value & AT803X_INTR_ENABLE_WOL)\r\nwol->wolopts |= WAKE_MAGIC;\r\n}\r\nstatic int at803x_suspend(struct phy_device *phydev)\r\n{\r\nint value;\r\nint wol_enabled;\r\nmutex_lock(&phydev->lock);\r\nvalue = phy_read(phydev, AT803X_INTR_ENABLE);\r\nwol_enabled = value & AT803X_INTR_ENABLE_WOL;\r\nvalue = phy_read(phydev, MII_BMCR);\r\nif (wol_enabled)\r\nvalue |= BMCR_ISOLATE;\r\nelse\r\nvalue |= BMCR_PDOWN;\r\nphy_write(phydev, MII_BMCR, value);\r\nmutex_unlock(&phydev->lock);\r\nreturn 0;\r\n}\r\nstatic int at803x_resume(struct phy_device *phydev)\r\n{\r\nint value;\r\nmutex_lock(&phydev->lock);\r\nvalue = phy_read(phydev, MII_BMCR);\r\nvalue &= ~(BMCR_PDOWN | BMCR_ISOLATE);\r\nphy_write(phydev, MII_BMCR, value);\r\nmutex_unlock(&phydev->lock);\r\nreturn 0;\r\n}\r\nstatic int at803x_probe(struct phy_device *phydev)\r\n{\r\nstruct device *dev = &phydev->mdio.dev;\r\nstruct at803x_priv *priv;\r\nstruct gpio_desc *gpiod_reset;\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nif (phydev->drv->phy_id != ATH8030_PHY_ID)\r\ngoto does_not_require_reset_workaround;\r\ngpiod_reset = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_LOW);\r\nif (IS_ERR(gpiod_reset))\r\nreturn PTR_ERR(gpiod_reset);\r\npriv->gpiod_reset = gpiod_reset;\r\ndoes_not_require_reset_workaround:\r\nphydev->priv = priv;\r\nreturn 0;\r\n}\r\nstatic int at803x_config_init(struct phy_device *phydev)\r\n{\r\nint ret;\r\nret = genphy_config_init(phydev);\r\nif (ret < 0)\r\nreturn ret;\r\nif (phydev->interface == PHY_INTERFACE_MODE_RGMII_RXID ||\r\nphydev->interface == PHY_INTERFACE_MODE_RGMII_ID) {\r\nret = at803x_enable_rx_delay(phydev);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (phydev->interface == PHY_INTERFACE_MODE_RGMII_TXID ||\r\nphydev->interface == PHY_INTERFACE_MODE_RGMII_ID) {\r\nret = at803x_enable_tx_delay(phydev);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int at803x_ack_interrupt(struct phy_device *phydev)\r\n{\r\nint err;\r\nerr = phy_read(phydev, AT803X_INTR_STATUS);\r\nreturn (err < 0) ? err : 0;\r\n}\r\nstatic int at803x_config_intr(struct phy_device *phydev)\r\n{\r\nint err;\r\nint value;\r\nvalue = phy_read(phydev, AT803X_INTR_ENABLE);\r\nif (phydev->interrupts == PHY_INTERRUPT_ENABLED) {\r\nvalue |= AT803X_INTR_ENABLE_AUTONEG_ERR;\r\nvalue |= AT803X_INTR_ENABLE_SPEED_CHANGED;\r\nvalue |= AT803X_INTR_ENABLE_DUPLEX_CHANGED;\r\nvalue |= AT803X_INTR_ENABLE_LINK_FAIL;\r\nvalue |= AT803X_INTR_ENABLE_LINK_SUCCESS;\r\nerr = phy_write(phydev, AT803X_INTR_ENABLE, value);\r\n}\r\nelse\r\nerr = phy_write(phydev, AT803X_INTR_ENABLE, 0);\r\nreturn err;\r\n}\r\nstatic void at803x_link_change_notify(struct phy_device *phydev)\r\n{\r\nstruct at803x_priv *priv = phydev->priv;\r\nif (phydev->state == PHY_NOLINK) {\r\nif (priv->gpiod_reset && !priv->phy_reset) {\r\nstruct at803x_context context;\r\nat803x_context_save(phydev, &context);\r\ngpiod_set_value(priv->gpiod_reset, 1);\r\nmsleep(1);\r\ngpiod_set_value(priv->gpiod_reset, 0);\r\nmsleep(1);\r\nat803x_context_restore(phydev, &context);\r\nphydev_dbg(phydev, "%s(): phy was reset\n",\r\n__func__);\r\npriv->phy_reset = true;\r\n}\r\n} else {\r\npriv->phy_reset = false;\r\n}\r\n}\r\nstatic int at803x_aneg_done(struct phy_device *phydev)\r\n{\r\nint ccr;\r\nint aneg_done = genphy_aneg_done(phydev);\r\nif (aneg_done != BMSR_ANEGCOMPLETE)\r\nreturn aneg_done;\r\nccr = phy_read(phydev, AT803X_REG_CHIP_CONFIG);\r\nif ((ccr & AT803X_MODE_CFG_MASK) != AT803X_MODE_CFG_SGMII)\r\nreturn aneg_done;\r\nphy_write(phydev, AT803X_REG_CHIP_CONFIG, ccr & ~AT803X_BT_BX_REG_SEL);\r\nif (!(phy_read(phydev, AT803X_PSSR) & AT803X_PSSR_MR_AN_COMPLETE)) {\r\npr_warn("803x_aneg_done: SGMII link is not ok\n");\r\naneg_done = 0;\r\n}\r\nphy_write(phydev, AT803X_REG_CHIP_CONFIG, ccr | AT803X_BT_BX_REG_SEL);\r\nreturn aneg_done;\r\n}
