static void xs_suspend_enter(void)\r\n{\r\nspin_lock(&xs_state_lock);\r\nxs_suspend_active++;\r\nspin_unlock(&xs_state_lock);\r\nwait_event(xs_state_exit_wq, xs_state_users == 0);\r\n}\r\nstatic void xs_suspend_exit(void)\r\n{\r\nspin_lock(&xs_state_lock);\r\nxs_suspend_active--;\r\nspin_unlock(&xs_state_lock);\r\nwake_up_all(&xs_state_enter_wq);\r\n}\r\nstatic uint32_t xs_request_enter(struct xb_req_data *req)\r\n{\r\nuint32_t rq_id;\r\nreq->type = req->msg.type;\r\nspin_lock(&xs_state_lock);\r\nwhile (!xs_state_users && xs_suspend_active) {\r\nspin_unlock(&xs_state_lock);\r\nwait_event(xs_state_enter_wq, xs_suspend_active == 0);\r\nspin_lock(&xs_state_lock);\r\n}\r\nif (req->type == XS_TRANSACTION_START)\r\nxs_state_users++;\r\nxs_state_users++;\r\nrq_id = xs_request_id++;\r\nspin_unlock(&xs_state_lock);\r\nreturn rq_id;\r\n}\r\nvoid xs_request_exit(struct xb_req_data *req)\r\n{\r\nspin_lock(&xs_state_lock);\r\nxs_state_users--;\r\nif ((req->type == XS_TRANSACTION_START && req->msg.type == XS_ERROR) ||\r\nreq->type == XS_TRANSACTION_END)\r\nxs_state_users--;\r\nspin_unlock(&xs_state_lock);\r\nif (xs_suspend_active && !xs_state_users)\r\nwake_up(&xs_state_exit_wq);\r\n}\r\nstatic int get_error(const char *errorstring)\r\n{\r\nunsigned int i;\r\nfor (i = 0; strcmp(errorstring, xsd_errors[i].errstring) != 0; i++) {\r\nif (i == ARRAY_SIZE(xsd_errors) - 1) {\r\npr_warn("xen store gave: unknown error %s\n",\r\nerrorstring);\r\nreturn EINVAL;\r\n}\r\n}\r\nreturn xsd_errors[i].errnum;\r\n}\r\nstatic bool xenbus_ok(void)\r\n{\r\nswitch (xen_store_domain_type) {\r\ncase XS_LOCAL:\r\nswitch (system_state) {\r\ncase SYSTEM_POWER_OFF:\r\ncase SYSTEM_RESTART:\r\ncase SYSTEM_HALT:\r\nreturn false;\r\ndefault:\r\nbreak;\r\n}\r\nreturn true;\r\ncase XS_PV:\r\ncase XS_HVM:\r\nreturn true;\r\ndefault:\r\nbreak;\r\n}\r\nreturn false;\r\n}\r\nstatic bool test_reply(struct xb_req_data *req)\r\n{\r\nif (req->state == xb_req_state_got_reply || !xenbus_ok())\r\nreturn true;\r\nbarrier();\r\nreturn false;\r\n}\r\nstatic void *read_reply(struct xb_req_data *req)\r\n{\r\nwhile (req->state != xb_req_state_got_reply) {\r\nwait_event(req->wq, test_reply(req));\r\nif (!xenbus_ok())\r\nreturn ERR_PTR(-EIO);\r\nif (req->err)\r\nreturn ERR_PTR(req->err);\r\n}\r\nreturn req->body;\r\n}\r\nstatic void xs_send(struct xb_req_data *req, struct xsd_sockmsg *msg)\r\n{\r\nbool notify;\r\nreq->msg = *msg;\r\nreq->err = 0;\r\nreq->state = xb_req_state_queued;\r\ninit_waitqueue_head(&req->wq);\r\nreq->msg.req_id = xs_request_enter(req);\r\nmutex_lock(&xb_write_mutex);\r\nlist_add_tail(&req->list, &xb_write_list);\r\nnotify = list_is_singular(&xb_write_list);\r\nmutex_unlock(&xb_write_mutex);\r\nif (notify)\r\nwake_up(&xb_waitq);\r\n}\r\nstatic void *xs_wait_for_reply(struct xb_req_data *req, struct xsd_sockmsg *msg)\r\n{\r\nvoid *ret;\r\nret = read_reply(req);\r\nxs_request_exit(req);\r\nmsg->type = req->msg.type;\r\nmsg->len = req->msg.len;\r\nmutex_lock(&xb_write_mutex);\r\nif (req->state == xb_req_state_queued ||\r\nreq->state == xb_req_state_wait_reply)\r\nreq->state = xb_req_state_aborted;\r\nelse\r\nkfree(req);\r\nmutex_unlock(&xb_write_mutex);\r\nreturn ret;\r\n}\r\nstatic void xs_wake_up(struct xb_req_data *req)\r\n{\r\nwake_up(&req->wq);\r\n}\r\nint xenbus_dev_request_and_reply(struct xsd_sockmsg *msg, void *par)\r\n{\r\nstruct xb_req_data *req;\r\nstruct kvec *vec;\r\nreq = kmalloc(sizeof(*req) + sizeof(*vec), GFP_KERNEL);\r\nif (!req)\r\nreturn -ENOMEM;\r\nvec = (struct kvec *)(req + 1);\r\nvec->iov_len = msg->len;\r\nvec->iov_base = msg + 1;\r\nreq->vec = vec;\r\nreq->num_vecs = 1;\r\nreq->cb = xenbus_dev_queue_reply;\r\nreq->par = par;\r\nxs_send(req, msg);\r\nreturn 0;\r\n}\r\nstatic void *xs_talkv(struct xenbus_transaction t,\r\nenum xsd_sockmsg_type type,\r\nconst struct kvec *iovec,\r\nunsigned int num_vecs,\r\nunsigned int *len)\r\n{\r\nstruct xb_req_data *req;\r\nstruct xsd_sockmsg msg;\r\nvoid *ret = NULL;\r\nunsigned int i;\r\nint err;\r\nreq = kmalloc(sizeof(*req), GFP_NOIO | __GFP_HIGH);\r\nif (!req)\r\nreturn ERR_PTR(-ENOMEM);\r\nreq->vec = iovec;\r\nreq->num_vecs = num_vecs;\r\nreq->cb = xs_wake_up;\r\nmsg.tx_id = t.id;\r\nmsg.type = type;\r\nmsg.len = 0;\r\nfor (i = 0; i < num_vecs; i++)\r\nmsg.len += iovec[i].iov_len;\r\nxs_send(req, &msg);\r\nret = xs_wait_for_reply(req, &msg);\r\nif (len)\r\n*len = msg.len;\r\nif (IS_ERR(ret))\r\nreturn ret;\r\nif (msg.type == XS_ERROR) {\r\nerr = get_error(ret);\r\nkfree(ret);\r\nreturn ERR_PTR(-err);\r\n}\r\nif (msg.type != type) {\r\npr_warn_ratelimited("unexpected type [%d], expected [%d]\n",\r\nmsg.type, type);\r\nkfree(ret);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nreturn ret;\r\n}\r\nstatic void *xs_single(struct xenbus_transaction t,\r\nenum xsd_sockmsg_type type,\r\nconst char *string,\r\nunsigned int *len)\r\n{\r\nstruct kvec iovec;\r\niovec.iov_base = (void *)string;\r\niovec.iov_len = strlen(string) + 1;\r\nreturn xs_talkv(t, type, &iovec, 1, len);\r\n}\r\nstatic int xs_error(char *reply)\r\n{\r\nif (IS_ERR(reply))\r\nreturn PTR_ERR(reply);\r\nkfree(reply);\r\nreturn 0;\r\n}\r\nstatic unsigned int count_strings(const char *strings, unsigned int len)\r\n{\r\nunsigned int num;\r\nconst char *p;\r\nfor (p = strings, num = 0; p < strings + len; p += strlen(p) + 1)\r\nnum++;\r\nreturn num;\r\n}\r\nstatic char *join(const char *dir, const char *name)\r\n{\r\nchar *buffer;\r\nif (strlen(name) == 0)\r\nbuffer = kasprintf(GFP_NOIO | __GFP_HIGH, "%s", dir);\r\nelse\r\nbuffer = kasprintf(GFP_NOIO | __GFP_HIGH, "%s/%s", dir, name);\r\nreturn (!buffer) ? ERR_PTR(-ENOMEM) : buffer;\r\n}\r\nstatic char **split(char *strings, unsigned int len, unsigned int *num)\r\n{\r\nchar *p, **ret;\r\n*num = count_strings(strings, len);\r\nret = kmalloc(*num * sizeof(char *) + len, GFP_NOIO | __GFP_HIGH);\r\nif (!ret) {\r\nkfree(strings);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nmemcpy(&ret[*num], strings, len);\r\nkfree(strings);\r\nstrings = (char *)&ret[*num];\r\nfor (p = strings, *num = 0; p < strings + len; p += strlen(p) + 1)\r\nret[(*num)++] = p;\r\nreturn ret;\r\n}\r\nchar **xenbus_directory(struct xenbus_transaction t,\r\nconst char *dir, const char *node, unsigned int *num)\r\n{\r\nchar *strings, *path;\r\nunsigned int len;\r\npath = join(dir, node);\r\nif (IS_ERR(path))\r\nreturn (char **)path;\r\nstrings = xs_single(t, XS_DIRECTORY, path, &len);\r\nkfree(path);\r\nif (IS_ERR(strings))\r\nreturn (char **)strings;\r\nreturn split(strings, len, num);\r\n}\r\nint xenbus_exists(struct xenbus_transaction t,\r\nconst char *dir, const char *node)\r\n{\r\nchar **d;\r\nint dir_n;\r\nd = xenbus_directory(t, dir, node, &dir_n);\r\nif (IS_ERR(d))\r\nreturn 0;\r\nkfree(d);\r\nreturn 1;\r\n}\r\nvoid *xenbus_read(struct xenbus_transaction t,\r\nconst char *dir, const char *node, unsigned int *len)\r\n{\r\nchar *path;\r\nvoid *ret;\r\npath = join(dir, node);\r\nif (IS_ERR(path))\r\nreturn (void *)path;\r\nret = xs_single(t, XS_READ, path, len);\r\nkfree(path);\r\nreturn ret;\r\n}\r\nint xenbus_write(struct xenbus_transaction t,\r\nconst char *dir, const char *node, const char *string)\r\n{\r\nconst char *path;\r\nstruct kvec iovec[2];\r\nint ret;\r\npath = join(dir, node);\r\nif (IS_ERR(path))\r\nreturn PTR_ERR(path);\r\niovec[0].iov_base = (void *)path;\r\niovec[0].iov_len = strlen(path) + 1;\r\niovec[1].iov_base = (void *)string;\r\niovec[1].iov_len = strlen(string);\r\nret = xs_error(xs_talkv(t, XS_WRITE, iovec, ARRAY_SIZE(iovec), NULL));\r\nkfree(path);\r\nreturn ret;\r\n}\r\nint xenbus_mkdir(struct xenbus_transaction t,\r\nconst char *dir, const char *node)\r\n{\r\nchar *path;\r\nint ret;\r\npath = join(dir, node);\r\nif (IS_ERR(path))\r\nreturn PTR_ERR(path);\r\nret = xs_error(xs_single(t, XS_MKDIR, path, NULL));\r\nkfree(path);\r\nreturn ret;\r\n}\r\nint xenbus_rm(struct xenbus_transaction t, const char *dir, const char *node)\r\n{\r\nchar *path;\r\nint ret;\r\npath = join(dir, node);\r\nif (IS_ERR(path))\r\nreturn PTR_ERR(path);\r\nret = xs_error(xs_single(t, XS_RM, path, NULL));\r\nkfree(path);\r\nreturn ret;\r\n}\r\nint xenbus_transaction_start(struct xenbus_transaction *t)\r\n{\r\nchar *id_str;\r\nid_str = xs_single(XBT_NIL, XS_TRANSACTION_START, "", NULL);\r\nif (IS_ERR(id_str))\r\nreturn PTR_ERR(id_str);\r\nt->id = simple_strtoul(id_str, NULL, 0);\r\nkfree(id_str);\r\nreturn 0;\r\n}\r\nint xenbus_transaction_end(struct xenbus_transaction t, int abort)\r\n{\r\nchar abortstr[2];\r\nif (abort)\r\nstrcpy(abortstr, "F");\r\nelse\r\nstrcpy(abortstr, "T");\r\nreturn xs_error(xs_single(t, XS_TRANSACTION_END, abortstr, NULL));\r\n}\r\nint xenbus_scanf(struct xenbus_transaction t,\r\nconst char *dir, const char *node, const char *fmt, ...)\r\n{\r\nva_list ap;\r\nint ret;\r\nchar *val;\r\nval = xenbus_read(t, dir, node, NULL);\r\nif (IS_ERR(val))\r\nreturn PTR_ERR(val);\r\nva_start(ap, fmt);\r\nret = vsscanf(val, fmt, ap);\r\nva_end(ap);\r\nkfree(val);\r\nif (ret == 0)\r\nreturn -ERANGE;\r\nreturn ret;\r\n}\r\nunsigned int xenbus_read_unsigned(const char *dir, const char *node,\r\nunsigned int default_val)\r\n{\r\nunsigned int val;\r\nint ret;\r\nret = xenbus_scanf(XBT_NIL, dir, node, "%u", &val);\r\nif (ret <= 0)\r\nval = default_val;\r\nreturn val;\r\n}\r\nint xenbus_printf(struct xenbus_transaction t,\r\nconst char *dir, const char *node, const char *fmt, ...)\r\n{\r\nva_list ap;\r\nint ret;\r\nchar *buf;\r\nva_start(ap, fmt);\r\nbuf = kvasprintf(GFP_NOIO | __GFP_HIGH, fmt, ap);\r\nva_end(ap);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nret = xenbus_write(t, dir, node, buf);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nint xenbus_gather(struct xenbus_transaction t, const char *dir, ...)\r\n{\r\nva_list ap;\r\nconst char *name;\r\nint ret = 0;\r\nva_start(ap, dir);\r\nwhile (ret == 0 && (name = va_arg(ap, char *)) != NULL) {\r\nconst char *fmt = va_arg(ap, char *);\r\nvoid *result = va_arg(ap, void *);\r\nchar *p;\r\np = xenbus_read(t, dir, name, NULL);\r\nif (IS_ERR(p)) {\r\nret = PTR_ERR(p);\r\nbreak;\r\n}\r\nif (fmt) {\r\nif (sscanf(p, fmt, result) == 0)\r\nret = -EINVAL;\r\nkfree(p);\r\n} else\r\n*(char **)result = p;\r\n}\r\nva_end(ap);\r\nreturn ret;\r\n}\r\nstatic int xs_watch(const char *path, const char *token)\r\n{\r\nstruct kvec iov[2];\r\niov[0].iov_base = (void *)path;\r\niov[0].iov_len = strlen(path) + 1;\r\niov[1].iov_base = (void *)token;\r\niov[1].iov_len = strlen(token) + 1;\r\nreturn xs_error(xs_talkv(XBT_NIL, XS_WATCH, iov,\r\nARRAY_SIZE(iov), NULL));\r\n}\r\nstatic int xs_unwatch(const char *path, const char *token)\r\n{\r\nstruct kvec iov[2];\r\niov[0].iov_base = (char *)path;\r\niov[0].iov_len = strlen(path) + 1;\r\niov[1].iov_base = (char *)token;\r\niov[1].iov_len = strlen(token) + 1;\r\nreturn xs_error(xs_talkv(XBT_NIL, XS_UNWATCH, iov,\r\nARRAY_SIZE(iov), NULL));\r\n}\r\nstatic struct xenbus_watch *find_watch(const char *token)\r\n{\r\nstruct xenbus_watch *i, *cmp;\r\ncmp = (void *)simple_strtoul(token, NULL, 16);\r\nlist_for_each_entry(i, &watches, list)\r\nif (i == cmp)\r\nreturn i;\r\nreturn NULL;\r\n}\r\nint xs_watch_msg(struct xs_watch_event *event)\r\n{\r\nif (count_strings(event->body, event->len) != 2) {\r\nkfree(event);\r\nreturn -EINVAL;\r\n}\r\nevent->path = (const char *)event->body;\r\nevent->token = (const char *)strchr(event->body, '\0') + 1;\r\nspin_lock(&watches_lock);\r\nevent->handle = find_watch(event->token);\r\nif (event->handle != NULL) {\r\nspin_lock(&watch_events_lock);\r\nlist_add_tail(&event->list, &watch_events);\r\nwake_up(&watch_events_waitq);\r\nspin_unlock(&watch_events_lock);\r\n} else\r\nkfree(event);\r\nspin_unlock(&watches_lock);\r\nreturn 0;\r\n}\r\nstatic bool xen_strict_xenbus_quirk(void)\r\n{\r\n#ifdef CONFIG_X86\r\nuint32_t eax, ebx, ecx, edx, base;\r\nbase = xen_cpuid_base();\r\ncpuid(base + 1, &eax, &ebx, &ecx, &edx);\r\nif ((eax >> 16) < 4)\r\nreturn true;\r\n#endif\r\nreturn false;\r\n}\r\nstatic void xs_reset_watches(void)\r\n{\r\nint err;\r\nif (!xen_hvm_domain() || xen_initial_domain())\r\nreturn;\r\nif (xen_strict_xenbus_quirk())\r\nreturn;\r\nif (!xenbus_read_unsigned("control",\r\n"platform-feature-xs_reset_watches", 0))\r\nreturn;\r\nerr = xs_error(xs_single(XBT_NIL, XS_RESET_WATCHES, "", NULL));\r\nif (err && err != -EEXIST)\r\npr_warn("xs_reset_watches failed: %d\n", err);\r\n}\r\nint register_xenbus_watch(struct xenbus_watch *watch)\r\n{\r\nchar token[sizeof(watch) * 2 + 1];\r\nint err;\r\nsprintf(token, "%lX", (long)watch);\r\ndown_read(&xs_watch_rwsem);\r\nspin_lock(&watches_lock);\r\nBUG_ON(find_watch(token));\r\nlist_add(&watch->list, &watches);\r\nspin_unlock(&watches_lock);\r\nerr = xs_watch(watch->node, token);\r\nif (err) {\r\nspin_lock(&watches_lock);\r\nlist_del(&watch->list);\r\nspin_unlock(&watches_lock);\r\n}\r\nup_read(&xs_watch_rwsem);\r\nreturn err;\r\n}\r\nvoid unregister_xenbus_watch(struct xenbus_watch *watch)\r\n{\r\nstruct xs_watch_event *event, *tmp;\r\nchar token[sizeof(watch) * 2 + 1];\r\nint err;\r\nsprintf(token, "%lX", (long)watch);\r\ndown_read(&xs_watch_rwsem);\r\nspin_lock(&watches_lock);\r\nBUG_ON(!find_watch(token));\r\nlist_del(&watch->list);\r\nspin_unlock(&watches_lock);\r\nerr = xs_unwatch(watch->node, token);\r\nif (err)\r\npr_warn("Failed to release watch %s: %i\n", watch->node, err);\r\nup_read(&xs_watch_rwsem);\r\nif (current->pid != xenwatch_pid)\r\nmutex_lock(&xenwatch_mutex);\r\nspin_lock(&watch_events_lock);\r\nlist_for_each_entry_safe(event, tmp, &watch_events, list) {\r\nif (event->handle != watch)\r\ncontinue;\r\nlist_del(&event->list);\r\nkfree(event);\r\n}\r\nspin_unlock(&watch_events_lock);\r\nif (current->pid != xenwatch_pid)\r\nmutex_unlock(&xenwatch_mutex);\r\n}\r\nvoid xs_suspend(void)\r\n{\r\nxs_suspend_enter();\r\ndown_write(&xs_watch_rwsem);\r\nmutex_lock(&xs_response_mutex);\r\n}\r\nvoid xs_resume(void)\r\n{\r\nstruct xenbus_watch *watch;\r\nchar token[sizeof(watch) * 2 + 1];\r\nxb_init_comms();\r\nmutex_unlock(&xs_response_mutex);\r\nxs_suspend_exit();\r\nlist_for_each_entry(watch, &watches, list) {\r\nsprintf(token, "%lX", (long)watch);\r\nxs_watch(watch->node, token);\r\n}\r\nup_write(&xs_watch_rwsem);\r\n}\r\nvoid xs_suspend_cancel(void)\r\n{\r\nmutex_unlock(&xs_response_mutex);\r\nup_write(&xs_watch_rwsem);\r\nxs_suspend_exit();\r\n}\r\nstatic int xenwatch_thread(void *unused)\r\n{\r\nstruct list_head *ent;\r\nstruct xs_watch_event *event;\r\nxenwatch_pid = current->pid;\r\nfor (;;) {\r\nwait_event_interruptible(watch_events_waitq,\r\n!list_empty(&watch_events));\r\nif (kthread_should_stop())\r\nbreak;\r\nmutex_lock(&xenwatch_mutex);\r\nspin_lock(&watch_events_lock);\r\nent = watch_events.next;\r\nif (ent != &watch_events)\r\nlist_del(ent);\r\nspin_unlock(&watch_events_lock);\r\nif (ent != &watch_events) {\r\nevent = list_entry(ent, struct xs_watch_event, list);\r\nevent->handle->callback(event->handle, event->path,\r\nevent->token);\r\nkfree(event);\r\n}\r\nmutex_unlock(&xenwatch_mutex);\r\n}\r\nreturn 0;\r\n}\r\nstatic int xs_reboot_notify(struct notifier_block *nb,\r\nunsigned long code, void *unused)\r\n{\r\nstruct xb_req_data *req;\r\nmutex_lock(&xb_write_mutex);\r\nlist_for_each_entry(req, &xs_reply_list, list)\r\nwake_up(&req->wq);\r\nlist_for_each_entry(req, &xb_write_list, list)\r\nwake_up(&req->wq);\r\nmutex_unlock(&xb_write_mutex);\r\nreturn NOTIFY_DONE;\r\n}\r\nint xs_init(void)\r\n{\r\nint err;\r\nstruct task_struct *task;\r\nregister_reboot_notifier(&xs_reboot_nb);\r\nerr = xb_init_comms();\r\nif (err)\r\nreturn err;\r\ntask = kthread_run(xenwatch_thread, NULL, "xenwatch");\r\nif (IS_ERR(task))\r\nreturn PTR_ERR(task);\r\nxs_reset_watches();\r\nreturn 0;\r\n}
