static void pblk_rl_kick_u_timer(struct pblk_rl *rl)\r\n{\r\nmod_timer(&rl->u_timer, jiffies + msecs_to_jiffies(5000));\r\n}\r\nint pblk_rl_is_limit(struct pblk_rl *rl)\r\n{\r\nint rb_space;\r\nrb_space = atomic_read(&rl->rb_space);\r\nreturn (rb_space == 0);\r\n}\r\nint pblk_rl_user_may_insert(struct pblk_rl *rl, int nr_entries)\r\n{\r\nint rb_user_cnt = atomic_read(&rl->rb_user_cnt);\r\nint rb_space = atomic_read(&rl->rb_space);\r\nif (unlikely(rb_space >= 0) && (rb_space - nr_entries < 0))\r\nreturn NVM_IO_ERR;\r\nif (rb_user_cnt >= rl->rb_user_max)\r\nreturn NVM_IO_REQUEUE;\r\nreturn NVM_IO_OK;\r\n}\r\nvoid pblk_rl_inserted(struct pblk_rl *rl, int nr_entries)\r\n{\r\nint rb_space = atomic_read(&rl->rb_space);\r\nif (unlikely(rb_space >= 0))\r\natomic_sub(nr_entries, &rl->rb_space);\r\n}\r\nint pblk_rl_gc_may_insert(struct pblk_rl *rl, int nr_entries)\r\n{\r\nint rb_gc_cnt = atomic_read(&rl->rb_gc_cnt);\r\nint rb_user_active;\r\nrb_user_active = READ_ONCE(rl->rb_user_active);\r\nreturn (!(rb_gc_cnt >= rl->rb_gc_max && rb_user_active));\r\n}\r\nvoid pblk_rl_user_in(struct pblk_rl *rl, int nr_entries)\r\n{\r\natomic_add(nr_entries, &rl->rb_user_cnt);\r\nsmp_store_release(&rl->rb_user_active, 1);\r\npblk_rl_kick_u_timer(rl);\r\n}\r\nvoid pblk_rl_gc_in(struct pblk_rl *rl, int nr_entries)\r\n{\r\natomic_add(nr_entries, &rl->rb_gc_cnt);\r\n}\r\nvoid pblk_rl_out(struct pblk_rl *rl, int nr_user, int nr_gc)\r\n{\r\natomic_sub(nr_user, &rl->rb_user_cnt);\r\natomic_sub(nr_gc, &rl->rb_gc_cnt);\r\n}\r\nunsigned long pblk_rl_nr_free_blks(struct pblk_rl *rl)\r\n{\r\nreturn atomic_read(&rl->free_blocks);\r\n}\r\nstatic int pblk_rl_update_rates(struct pblk_rl *rl, unsigned long max)\r\n{\r\nunsigned long free_blocks = pblk_rl_nr_free_blks(rl);\r\nif (free_blocks >= rl->high) {\r\nrl->rb_user_max = max;\r\nrl->rb_gc_max = 0;\r\nrl->rb_state = PBLK_RL_HIGH;\r\n} else if (free_blocks < rl->high) {\r\nint shift = rl->high_pw - rl->rb_windows_pw;\r\nint user_windows = free_blocks >> shift;\r\nint user_max = user_windows << PBLK_MAX_REQ_ADDRS_PW;\r\nrl->rb_user_max = user_max;\r\nrl->rb_gc_max = max - user_max;\r\nif (free_blocks <= rl->rsv_blocks) {\r\nrl->rb_user_max = 0;\r\nrl->rb_gc_max = max;\r\n}\r\nrl->rb_state = PBLK_RL_LOW;\r\n}\r\nreturn rl->rb_state;\r\n}\r\nvoid pblk_rl_free_lines_inc(struct pblk_rl *rl, struct pblk_line *line)\r\n{\r\nstruct pblk *pblk = container_of(rl, struct pblk, rl);\r\nint blk_in_line = atomic_read(&line->blk_in_line);\r\nint ret;\r\natomic_add(blk_in_line, &rl->free_blocks);\r\nret = pblk_rl_update_rates(rl, rl->rb_budget);\r\nif (ret == (PBLK_RL_MID | PBLK_RL_LOW))\r\npblk_gc_should_start(pblk);\r\nelse\r\npblk_gc_should_stop(pblk);\r\n}\r\nvoid pblk_rl_free_lines_dec(struct pblk_rl *rl, struct pblk_line *line)\r\n{\r\nint blk_in_line = atomic_read(&line->blk_in_line);\r\natomic_sub(blk_in_line, &rl->free_blocks);\r\n}\r\nvoid pblk_gc_should_kick(struct pblk *pblk)\r\n{\r\nstruct pblk_rl *rl = &pblk->rl;\r\nint ret;\r\nret = pblk_rl_update_rates(rl, rl->rb_budget);\r\nif (ret == (PBLK_RL_MID | PBLK_RL_LOW))\r\npblk_gc_should_start(pblk);\r\nelse\r\npblk_gc_should_stop(pblk);\r\n}\r\nint pblk_rl_high_thrs(struct pblk_rl *rl)\r\n{\r\nreturn rl->high;\r\n}\r\nint pblk_rl_low_thrs(struct pblk_rl *rl)\r\n{\r\nreturn rl->low;\r\n}\r\nint pblk_rl_sysfs_rate_show(struct pblk_rl *rl)\r\n{\r\nreturn rl->rb_user_max;\r\n}\r\nstatic void pblk_rl_u_timer(unsigned long data)\r\n{\r\nstruct pblk_rl *rl = (struct pblk_rl *)data;\r\nsmp_store_release(&rl->rb_user_active, 0);\r\n}\r\nvoid pblk_rl_free(struct pblk_rl *rl)\r\n{\r\ndel_timer(&rl->u_timer);\r\n}\r\nvoid pblk_rl_init(struct pblk_rl *rl, int budget)\r\n{\r\nstruct pblk *pblk = container_of(rl, struct pblk, rl);\r\nstruct pblk_line_meta *lm = &pblk->lm;\r\nint min_blocks = lm->blk_per_line * PBLK_GC_RSV_LINE;\r\nunsigned int rb_windows;\r\nrl->high = rl->total_blocks / PBLK_USER_HIGH_THRS;\r\nrl->high_pw = get_count_order(rl->high);\r\nrl->low = rl->total_blocks / PBLK_USER_LOW_THRS;\r\nif (rl->low < min_blocks)\r\nrl->low = min_blocks;\r\nrl->rsv_blocks = min_blocks;\r\nrb_windows = budget / PBLK_MAX_REQ_ADDRS;\r\nrl->rb_windows_pw = get_count_order(rb_windows);\r\nrl->rb_budget = budget;\r\nrl->rb_user_max = budget;\r\nrl->rb_gc_max = 0;\r\nrl->rb_state = PBLK_RL_HIGH;\r\natomic_set(&rl->rb_user_cnt, 0);\r\natomic_set(&rl->rb_gc_cnt, 0);\r\natomic_set(&rl->rb_space, -1);\r\nsetup_timer(&rl->u_timer, pblk_rl_u_timer, (unsigned long)rl);\r\nrl->rb_user_active = 0;\r\nrl->rb_gc_active = 0;\r\n}
