static int pn544_hci_open(struct nfc_hci_dev *hdev)\r\n{\r\nstruct pn544_hci_info *info = nfc_hci_get_clientdata(hdev);\r\nint r = 0;\r\nmutex_lock(&info->info_lock);\r\nif (info->state != PN544_ST_COLD) {\r\nr = -EBUSY;\r\ngoto out;\r\n}\r\nr = info->phy_ops->enable(info->phy_id);\r\nif (r == 0)\r\ninfo->state = PN544_ST_READY;\r\nout:\r\nmutex_unlock(&info->info_lock);\r\nreturn r;\r\n}\r\nstatic void pn544_hci_close(struct nfc_hci_dev *hdev)\r\n{\r\nstruct pn544_hci_info *info = nfc_hci_get_clientdata(hdev);\r\nmutex_lock(&info->info_lock);\r\nif (info->state == PN544_ST_COLD)\r\ngoto out;\r\ninfo->phy_ops->disable(info->phy_id);\r\ninfo->state = PN544_ST_COLD;\r\nout:\r\nmutex_unlock(&info->info_lock);\r\n}\r\nstatic int pn544_hci_ready(struct nfc_hci_dev *hdev)\r\n{\r\nstruct sk_buff *skb;\r\nstatic struct hw_config {\r\nu8 adr[2];\r\nu8 value;\r\n} hw_config[] = {\r\n{{0x9f, 0x9a}, 0x00},\r\n{{0x98, 0x10}, 0xbc},\r\n{{0x9e, 0x71}, 0x00},\r\n{{0x98, 0x09}, 0x00},\r\n{{0x9e, 0xb4}, 0x00},\r\n{{0x9c, 0x01}, 0x08},\r\n{{0x9e, 0xaa}, 0x01},\r\n{{0x9b, 0xd1}, 0x17},\r\n{{0x9b, 0xd2}, 0x58},\r\n{{0x9b, 0xd3}, 0x10},\r\n{{0x9b, 0xd4}, 0x47},\r\n{{0x9b, 0xd5}, 0x0c},\r\n{{0x9b, 0xd6}, 0x37},\r\n{{0x9b, 0xdd}, 0x33},\r\n{{0x9b, 0x84}, 0x00},\r\n{{0x99, 0x81}, 0x79},\r\n{{0x99, 0x31}, 0x79},\r\n{{0x98, 0x00}, 0x3f},\r\n{{0x9f, 0x09}, 0x02},\r\n{{0x9f, 0x0a}, 0x05},\r\n{{0x9e, 0xd1}, 0xa1},\r\n{{0x99, 0x23}, 0x01},\r\n{{0x9e, 0x74}, 0x00},\r\n{{0x9e, 0x90}, 0x00},\r\n{{0x9f, 0x28}, 0x10},\r\n{{0x9f, 0x35}, 0x04},\r\n{{0x9f, 0x36}, 0x11},\r\n{{0x9c, 0x31}, 0x00},\r\n{{0x9c, 0x32}, 0x00},\r\n{{0x9c, 0x19}, 0x0a},\r\n{{0x9c, 0x1a}, 0x0a},\r\n{{0x9c, 0x0c}, 0x00},\r\n{{0x9c, 0x0d}, 0x00},\r\n{{0x9c, 0x12}, 0x00},\r\n{{0x9c, 0x13}, 0x00},\r\n{{0x98, 0xa2}, 0x09},\r\n{{0x98, 0x93}, 0x00},\r\n{{0x98, 0x7d}, 0x08},\r\n{{0x98, 0x7e}, 0x00},\r\n{{0x9f, 0xc8}, 0x00},\r\n};\r\nstruct hw_config *p = hw_config;\r\nint count = ARRAY_SIZE(hw_config);\r\nstruct sk_buff *res_skb;\r\nu8 param[4];\r\nint r;\r\nparam[0] = 0;\r\nwhile (count--) {\r\nparam[1] = p->adr[0];\r\nparam[2] = p->adr[1];\r\nparam[3] = p->value;\r\nr = nfc_hci_send_cmd(hdev, PN544_SYS_MGMT_GATE, PN544_WRITE,\r\nparam, 4, &res_skb);\r\nif (r < 0)\r\nreturn r;\r\nif (res_skb->len != 1) {\r\nkfree_skb(res_skb);\r\nreturn -EPROTO;\r\n}\r\nif (res_skb->data[0] != p->value) {\r\nkfree_skb(res_skb);\r\nreturn -EIO;\r\n}\r\nkfree_skb(res_skb);\r\np++;\r\n}\r\nparam[0] = NFC_HCI_UICC_HOST_ID;\r\nr = nfc_hci_set_param(hdev, NFC_HCI_ADMIN_GATE,\r\nNFC_HCI_ADMIN_WHITELIST, param, 1);\r\nif (r < 0)\r\nreturn r;\r\nparam[0] = 0x3d;\r\nr = nfc_hci_set_param(hdev, PN544_SYS_MGMT_GATE,\r\nPN544_SYS_MGMT_INFO_NOTIFICATION, param, 1);\r\nif (r < 0)\r\nreturn r;\r\nparam[0] = 0x0;\r\nr = nfc_hci_set_param(hdev, NFC_HCI_RF_READER_A_GATE,\r\nPN544_RF_READER_A_AUTO_ACTIVATION, param, 1);\r\nif (r < 0)\r\nreturn r;\r\nr = nfc_hci_send_event(hdev, NFC_HCI_RF_READER_A_GATE,\r\nNFC_HCI_EVT_END_OPERATION, NULL, 0);\r\nif (r < 0)\r\nreturn r;\r\nparam[0] = 0x1;\r\nr = nfc_hci_set_param(hdev, PN544_POLLING_LOOP_MGMT_GATE,\r\nPN544_PL_NFCT_DEACTIVATED, param, 1);\r\nif (r < 0)\r\nreturn r;\r\nparam[0] = 0x0;\r\nr = nfc_hci_set_param(hdev, PN544_POLLING_LOOP_MGMT_GATE,\r\nPN544_PL_RDPHASES, param, 1);\r\nif (r < 0)\r\nreturn r;\r\nr = nfc_hci_get_param(hdev, NFC_HCI_ID_MGMT_GATE,\r\nPN544_ID_MGMT_FULL_VERSION_SW, &skb);\r\nif (r < 0)\r\nreturn r;\r\nif (skb->len != FULL_VERSION_LEN) {\r\nkfree_skb(skb);\r\nreturn -EINVAL;\r\n}\r\nprint_hex_dump(KERN_DEBUG, "FULL VERSION SOFTWARE INFO: ",\r\nDUMP_PREFIX_NONE, 16, 1,\r\nskb->data, FULL_VERSION_LEN, false);\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int pn544_hci_xmit(struct nfc_hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct pn544_hci_info *info = nfc_hci_get_clientdata(hdev);\r\nreturn info->phy_ops->write(info->phy_id, skb);\r\n}\r\nstatic int pn544_hci_start_poll(struct nfc_hci_dev *hdev,\r\nu32 im_protocols, u32 tm_protocols)\r\n{\r\nu8 phases = 0;\r\nint r;\r\nu8 duration[2];\r\nu8 activated;\r\nu8 i_mode = 0x3f;\r\nu8 t_mode = 0x0f;\r\nu8 t_merge = 0x01;\r\npr_info(DRIVER_DESC ": %s protocols 0x%x 0x%x\n",\r\n__func__, im_protocols, tm_protocols);\r\nr = nfc_hci_send_event(hdev, NFC_HCI_RF_READER_A_GATE,\r\nNFC_HCI_EVT_END_OPERATION, NULL, 0);\r\nif (r < 0)\r\nreturn r;\r\nduration[0] = 0x18;\r\nduration[1] = 0x6a;\r\nr = nfc_hci_set_param(hdev, PN544_POLLING_LOOP_MGMT_GATE,\r\nPN544_PL_EMULATION, duration, 2);\r\nif (r < 0)\r\nreturn r;\r\nactivated = 0;\r\nr = nfc_hci_set_param(hdev, PN544_POLLING_LOOP_MGMT_GATE,\r\nPN544_PL_NFCT_DEACTIVATED, &activated, 1);\r\nif (r < 0)\r\nreturn r;\r\nif (im_protocols & (NFC_PROTO_ISO14443_MASK | NFC_PROTO_MIFARE_MASK |\r\nNFC_PROTO_JEWEL_MASK))\r\nphases |= 1;\r\nif (im_protocols & NFC_PROTO_FELICA_MASK) {\r\nphases |= (1 << 2);\r\nphases |= (1 << 3);\r\n}\r\nphases |= (1 << 5);\r\nr = nfc_hci_set_param(hdev, PN544_POLLING_LOOP_MGMT_GATE,\r\nPN544_PL_RDPHASES, &phases, 1);\r\nif (r < 0)\r\nreturn r;\r\nif ((im_protocols | tm_protocols) & NFC_PROTO_NFC_DEP_MASK) {\r\nhdev->gb = nfc_get_local_general_bytes(hdev->ndev,\r\n&hdev->gb_len);\r\npr_debug("generate local bytes %p\n", hdev->gb);\r\nif (hdev->gb == NULL || hdev->gb_len == 0) {\r\nim_protocols &= ~NFC_PROTO_NFC_DEP_MASK;\r\ntm_protocols &= ~NFC_PROTO_NFC_DEP_MASK;\r\n}\r\n}\r\nif (im_protocols & NFC_PROTO_NFC_DEP_MASK) {\r\nr = nfc_hci_send_event(hdev,\r\nPN544_RF_READER_NFCIP1_INITIATOR_GATE,\r\nNFC_HCI_EVT_END_OPERATION, NULL, 0);\r\nif (r < 0)\r\nreturn r;\r\nr = nfc_hci_set_param(hdev,\r\nPN544_RF_READER_NFCIP1_INITIATOR_GATE,\r\nPN544_DEP_MODE, &i_mode, 1);\r\nif (r < 0)\r\nreturn r;\r\nr = nfc_hci_set_param(hdev,\r\nPN544_RF_READER_NFCIP1_INITIATOR_GATE,\r\nPN544_DEP_ATR_REQ, hdev->gb, hdev->gb_len);\r\nif (r < 0)\r\nreturn r;\r\nr = nfc_hci_send_event(hdev,\r\nPN544_RF_READER_NFCIP1_INITIATOR_GATE,\r\nNFC_HCI_EVT_READER_REQUESTED, NULL, 0);\r\nif (r < 0)\r\nnfc_hci_send_event(hdev,\r\nPN544_RF_READER_NFCIP1_INITIATOR_GATE,\r\nNFC_HCI_EVT_END_OPERATION, NULL, 0);\r\n}\r\nif (tm_protocols & NFC_PROTO_NFC_DEP_MASK) {\r\nr = nfc_hci_set_param(hdev, PN544_RF_READER_NFCIP1_TARGET_GATE,\r\nPN544_DEP_MODE, &t_mode, 1);\r\nif (r < 0)\r\nreturn r;\r\nr = nfc_hci_set_param(hdev, PN544_RF_READER_NFCIP1_TARGET_GATE,\r\nPN544_DEP_ATR_RES, hdev->gb, hdev->gb_len);\r\nif (r < 0)\r\nreturn r;\r\nr = nfc_hci_set_param(hdev, PN544_RF_READER_NFCIP1_TARGET_GATE,\r\nPN544_DEP_MERGE, &t_merge, 1);\r\nif (r < 0)\r\nreturn r;\r\n}\r\nr = nfc_hci_send_event(hdev, NFC_HCI_RF_READER_A_GATE,\r\nNFC_HCI_EVT_READER_REQUESTED, NULL, 0);\r\nif (r < 0)\r\nnfc_hci_send_event(hdev, NFC_HCI_RF_READER_A_GATE,\r\nNFC_HCI_EVT_END_OPERATION, NULL, 0);\r\nreturn r;\r\n}\r\nstatic int pn544_hci_dep_link_up(struct nfc_hci_dev *hdev,\r\nstruct nfc_target *target, u8 comm_mode,\r\nu8 *gb, size_t gb_len)\r\n{\r\nstruct sk_buff *rgb_skb = NULL;\r\nint r;\r\nr = nfc_hci_get_param(hdev, target->hci_reader_gate,\r\nPN544_DEP_ATR_RES, &rgb_skb);\r\nif (r < 0)\r\nreturn r;\r\nif (rgb_skb->len == 0 || rgb_skb->len > NFC_GB_MAXSIZE) {\r\nr = -EPROTO;\r\ngoto exit;\r\n}\r\nprint_hex_dump(KERN_DEBUG, "remote gb: ", DUMP_PREFIX_OFFSET,\r\n16, 1, rgb_skb->data, rgb_skb->len, true);\r\nr = nfc_set_remote_general_bytes(hdev->ndev, rgb_skb->data,\r\nrgb_skb->len);\r\nif (r == 0)\r\nr = nfc_dep_link_is_up(hdev->ndev, target->idx, comm_mode,\r\nNFC_RF_INITIATOR);\r\nexit:\r\nkfree_skb(rgb_skb);\r\nreturn r;\r\n}\r\nstatic int pn544_hci_dep_link_down(struct nfc_hci_dev *hdev)\r\n{\r\nreturn nfc_hci_send_event(hdev, PN544_RF_READER_NFCIP1_INITIATOR_GATE,\r\nNFC_HCI_EVT_END_OPERATION, NULL, 0);\r\n}\r\nstatic int pn544_hci_target_from_gate(struct nfc_hci_dev *hdev, u8 gate,\r\nstruct nfc_target *target)\r\n{\r\nswitch (gate) {\r\ncase PN544_RF_READER_F_GATE:\r\ntarget->supported_protocols = NFC_PROTO_FELICA_MASK;\r\nbreak;\r\ncase PN544_RF_READER_JEWEL_GATE:\r\ntarget->supported_protocols = NFC_PROTO_JEWEL_MASK;\r\ntarget->sens_res = 0x0c00;\r\nbreak;\r\ncase PN544_RF_READER_NFCIP1_INITIATOR_GATE:\r\ntarget->supported_protocols = NFC_PROTO_NFC_DEP_MASK;\r\nbreak;\r\ndefault:\r\nreturn -EPROTO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pn544_hci_complete_target_discovered(struct nfc_hci_dev *hdev,\r\nu8 gate,\r\nstruct nfc_target *target)\r\n{\r\nstruct sk_buff *uid_skb;\r\nint r = 0;\r\nif (gate == PN544_RF_READER_NFCIP1_INITIATOR_GATE)\r\nreturn r;\r\nif (target->supported_protocols & NFC_PROTO_NFC_DEP_MASK) {\r\nr = nfc_hci_send_cmd(hdev,\r\nPN544_RF_READER_NFCIP1_INITIATOR_GATE,\r\nPN544_HCI_CMD_CONTINUE_ACTIVATION, NULL, 0, NULL);\r\nif (r < 0)\r\nreturn r;\r\ntarget->hci_reader_gate = PN544_RF_READER_NFCIP1_INITIATOR_GATE;\r\n} else if (target->supported_protocols & NFC_PROTO_MIFARE_MASK) {\r\nif (target->nfcid1_len != 4 && target->nfcid1_len != 7 &&\r\ntarget->nfcid1_len != 10)\r\nreturn -EPROTO;\r\nr = nfc_hci_send_cmd(hdev, NFC_HCI_RF_READER_A_GATE,\r\nPN544_RF_READER_CMD_ACTIVATE_NEXT,\r\ntarget->nfcid1, target->nfcid1_len, NULL);\r\n} else if (target->supported_protocols & NFC_PROTO_FELICA_MASK) {\r\nr = nfc_hci_get_param(hdev, PN544_RF_READER_F_GATE,\r\nPN544_FELICA_ID, &uid_skb);\r\nif (r < 0)\r\nreturn r;\r\nif (uid_skb->len != 8) {\r\nkfree_skb(uid_skb);\r\nreturn -EPROTO;\r\n}\r\nif ((uid_skb->data[0] == 0x01) && (uid_skb->data[1] == 0xfe)) {\r\nkfree_skb(uid_skb);\r\nr = nfc_hci_send_cmd(hdev,\r\nPN544_RF_READER_NFCIP1_INITIATOR_GATE,\r\nPN544_HCI_CMD_CONTINUE_ACTIVATION,\r\nNULL, 0, NULL);\r\nif (r < 0)\r\nreturn r;\r\ntarget->supported_protocols = NFC_PROTO_NFC_DEP_MASK;\r\ntarget->hci_reader_gate =\r\nPN544_RF_READER_NFCIP1_INITIATOR_GATE;\r\n} else {\r\nr = nfc_hci_send_cmd(hdev, PN544_RF_READER_F_GATE,\r\nPN544_RF_READER_CMD_ACTIVATE_NEXT,\r\nuid_skb->data, uid_skb->len, NULL);\r\nkfree_skb(uid_skb);\r\n}\r\n} else if (target->supported_protocols & NFC_PROTO_ISO14443_MASK) {\r\nif (target->sens_res == 0x4403)\r\nr = nfc_hci_send_cmd(hdev, NFC_HCI_RF_READER_A_GATE,\r\nPN544_RF_READER_A_CMD_CONTINUE_ACTIVATION,\r\nNULL, 0, NULL);\r\n}\r\nreturn r;\r\n}\r\nstatic void pn544_hci_data_exchange_cb(void *context, struct sk_buff *skb,\r\nint err)\r\n{\r\nstruct pn544_hci_info *info = context;\r\nswitch (info->async_cb_type) {\r\ncase PN544_CB_TYPE_READER_F:\r\nif (err == 0)\r\nskb_pull(skb, 1);\r\ninfo->async_cb(info->async_cb_context, skb, err);\r\nbreak;\r\ndefault:\r\nif (err == 0)\r\nkfree_skb(skb);\r\nbreak;\r\n}\r\n}\r\nstatic int pn544_hci_im_transceive(struct nfc_hci_dev *hdev,\r\nstruct nfc_target *target,\r\nstruct sk_buff *skb, data_exchange_cb_t cb,\r\nvoid *cb_context)\r\n{\r\nstruct pn544_hci_info *info = nfc_hci_get_clientdata(hdev);\r\npr_info(DRIVER_DESC ": %s for gate=%d\n", __func__,\r\ntarget->hci_reader_gate);\r\nswitch (target->hci_reader_gate) {\r\ncase NFC_HCI_RF_READER_A_GATE:\r\nif (target->supported_protocols & NFC_PROTO_MIFARE_MASK) {\r\nif (skb->len == MIFARE_CMD_LEN &&\r\n(skb->data[0] == MIFARE_CMD_AUTH_KEY_A ||\r\nskb->data[0] == MIFARE_CMD_AUTH_KEY_B)) {\r\nu8 uid[MIFARE_UID_LEN];\r\nu8 *data = skb->data + MIFARE_CMD_HEADER;\r\nmemcpy(uid, data + MIFARE_KEY_LEN,\r\nMIFARE_UID_LEN);\r\nmemmove(data + MIFARE_UID_LEN, data,\r\nMIFARE_KEY_LEN);\r\nmemcpy(data, uid, MIFARE_UID_LEN);\r\n}\r\nreturn nfc_hci_send_cmd_async(hdev,\r\ntarget->hci_reader_gate,\r\nPN544_MIFARE_CMD,\r\nskb->data, skb->len,\r\ncb, cb_context);\r\n} else\r\nreturn 1;\r\ncase PN544_RF_READER_F_GATE:\r\n*(u8 *)skb_push(skb, 1) = 0;\r\n*(u8 *)skb_push(skb, 1) = 0;\r\ninfo->async_cb_type = PN544_CB_TYPE_READER_F;\r\ninfo->async_cb = cb;\r\ninfo->async_cb_context = cb_context;\r\nreturn nfc_hci_send_cmd_async(hdev, target->hci_reader_gate,\r\nPN544_FELICA_RAW, skb->data,\r\nskb->len,\r\npn544_hci_data_exchange_cb, info);\r\ncase PN544_RF_READER_JEWEL_GATE:\r\nreturn nfc_hci_send_cmd_async(hdev, target->hci_reader_gate,\r\nPN544_JEWEL_RAW_CMD, skb->data,\r\nskb->len, cb, cb_context);\r\ncase PN544_RF_READER_NFCIP1_INITIATOR_GATE:\r\n*(u8 *)skb_push(skb, 1) = 0;\r\nreturn nfc_hci_send_event(hdev, target->hci_reader_gate,\r\nPN544_HCI_EVT_SND_DATA, skb->data,\r\nskb->len);\r\ndefault:\r\nreturn 1;\r\n}\r\n}\r\nstatic int pn544_hci_tm_send(struct nfc_hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nint r;\r\n*(u8 *)skb_push(skb, 1) = 0;\r\nr = nfc_hci_send_event(hdev, PN544_RF_READER_NFCIP1_TARGET_GATE,\r\nPN544_HCI_EVT_SND_DATA, skb->data, skb->len);\r\nkfree_skb(skb);\r\nreturn r;\r\n}\r\nstatic int pn544_hci_check_presence(struct nfc_hci_dev *hdev,\r\nstruct nfc_target *target)\r\n{\r\npr_debug("supported protocol %d\b", target->supported_protocols);\r\nif (target->supported_protocols & (NFC_PROTO_ISO14443_MASK |\r\nNFC_PROTO_ISO14443_B_MASK)) {\r\nreturn nfc_hci_send_cmd(hdev, target->hci_reader_gate,\r\nPN544_RF_READER_CMD_PRESENCE_CHECK,\r\nNULL, 0, NULL);\r\n} else if (target->supported_protocols & NFC_PROTO_MIFARE_MASK) {\r\nif (target->nfcid1_len != 4 && target->nfcid1_len != 7 &&\r\ntarget->nfcid1_len != 10)\r\nreturn -EOPNOTSUPP;\r\nreturn nfc_hci_send_cmd(hdev, NFC_HCI_RF_READER_A_GATE,\r\nPN544_RF_READER_CMD_ACTIVATE_NEXT,\r\ntarget->nfcid1, target->nfcid1_len, NULL);\r\n} else if (target->supported_protocols & (NFC_PROTO_JEWEL_MASK |\r\nNFC_PROTO_FELICA_MASK)) {\r\nreturn -EOPNOTSUPP;\r\n} else if (target->supported_protocols & NFC_PROTO_NFC_DEP_MASK) {\r\nreturn nfc_hci_send_cmd(hdev, target->hci_reader_gate,\r\nPN544_HCI_CMD_ATTREQUEST,\r\nNULL, 0, NULL);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pn544_hci_event_received(struct nfc_hci_dev *hdev, u8 pipe, u8 event,\r\nstruct sk_buff *skb)\r\n{\r\nstruct sk_buff *rgb_skb = NULL;\r\nu8 gate = hdev->pipes[pipe].gate;\r\nint r;\r\npr_debug("hci event %d\n", event);\r\nswitch (event) {\r\ncase PN544_HCI_EVT_ACTIVATED:\r\nif (gate == PN544_RF_READER_NFCIP1_INITIATOR_GATE) {\r\nr = nfc_hci_target_discovered(hdev, gate);\r\n} else if (gate == PN544_RF_READER_NFCIP1_TARGET_GATE) {\r\nr = nfc_hci_get_param(hdev, gate, PN544_DEP_ATR_REQ,\r\n&rgb_skb);\r\nif (r < 0)\r\ngoto exit;\r\nr = nfc_tm_activated(hdev->ndev, NFC_PROTO_NFC_DEP_MASK,\r\nNFC_COMM_PASSIVE, rgb_skb->data,\r\nrgb_skb->len);\r\nkfree_skb(rgb_skb);\r\n} else {\r\nr = -EINVAL;\r\n}\r\nbreak;\r\ncase PN544_HCI_EVT_DEACTIVATED:\r\nr = nfc_hci_send_event(hdev, gate, NFC_HCI_EVT_END_OPERATION,\r\nNULL, 0);\r\nbreak;\r\ncase PN544_HCI_EVT_RCV_DATA:\r\nif (skb->len < 2) {\r\nr = -EPROTO;\r\ngoto exit;\r\n}\r\nif (skb->data[0] != 0) {\r\npr_debug("data0 %d\n", skb->data[0]);\r\nr = -EPROTO;\r\ngoto exit;\r\n}\r\nskb_pull(skb, 2);\r\nreturn nfc_tm_data_received(hdev->ndev, skb);\r\ndefault:\r\nreturn 1;\r\n}\r\nexit:\r\nkfree_skb(skb);\r\nreturn r;\r\n}\r\nstatic int pn544_hci_fw_download(struct nfc_hci_dev *hdev,\r\nconst char *firmware_name)\r\n{\r\nstruct pn544_hci_info *info = nfc_hci_get_clientdata(hdev);\r\nif (info->fw_download == NULL)\r\nreturn -ENOTSUPP;\r\nreturn info->fw_download(info->phy_id, firmware_name, hdev->sw_romlib);\r\n}\r\nstatic int pn544_hci_discover_se(struct nfc_hci_dev *hdev)\r\n{\r\nu32 se_idx = 0;\r\nu8 ese_mode = 0x01;\r\nstruct sk_buff *res_skb;\r\nint r;\r\nr = nfc_hci_send_cmd(hdev, PN544_SYS_MGMT_GATE, PN544_TEST_SWP,\r\nNULL, 0, &res_skb);\r\nif (r == 0) {\r\nif (res_skb->len == 2 && res_skb->data[0] == 0x00)\r\nnfc_add_se(hdev->ndev, se_idx++, NFC_SE_UICC);\r\nkfree_skb(res_skb);\r\n}\r\nr = nfc_hci_send_event(hdev, PN544_NFC_WI_MGMT_GATE,\r\nPN544_HCI_EVT_SWITCH_MODE,\r\n&ese_mode, 1);\r\nif (r == 0)\r\nnfc_add_se(hdev->ndev, se_idx++, NFC_SE_EMBEDDED);\r\nreturn !se_idx;\r\n}\r\nstatic int pn544_hci_enable_se(struct nfc_hci_dev *hdev, u32 se_idx)\r\n{\r\nstruct nfc_se *se;\r\nu8 enable = PN544_SE_MODE_ON;\r\nstatic struct uicc_gatelist {\r\nu8 head;\r\nu8 adr[2];\r\nu8 value;\r\n} uicc_gatelist[] = {\r\n{0x00, {0x9e, 0xd9}, 0x23},\r\n{0x00, {0x9e, 0xda}, 0x21},\r\n{0x00, {0x9e, 0xdb}, 0x22},\r\n{0x00, {0x9e, 0xdc}, 0x24},\r\n};\r\nstruct uicc_gatelist *p = uicc_gatelist;\r\nint count = ARRAY_SIZE(uicc_gatelist);\r\nstruct sk_buff *res_skb;\r\nint r;\r\nse = nfc_find_se(hdev->ndev, se_idx);\r\nswitch (se->type) {\r\ncase NFC_SE_UICC:\r\nwhile (count--) {\r\nr = nfc_hci_send_cmd(hdev, PN544_SYS_MGMT_GATE,\r\nPN544_WRITE, (u8 *)p, 4, &res_skb);\r\nif (r < 0)\r\nreturn r;\r\nif (res_skb->len != 1) {\r\nkfree_skb(res_skb);\r\nreturn -EPROTO;\r\n}\r\nif (res_skb->data[0] != p->value) {\r\nkfree_skb(res_skb);\r\nreturn -EIO;\r\n}\r\nkfree_skb(res_skb);\r\np++;\r\n}\r\nreturn nfc_hci_set_param(hdev, PN544_SWP_MGMT_GATE,\r\nPN544_SWP_DEFAULT_MODE, &enable, 1);\r\ncase NFC_SE_EMBEDDED:\r\nreturn nfc_hci_set_param(hdev, PN544_NFC_WI_MGMT_GATE,\r\nPN544_NFC_ESE_DEFAULT_MODE, &enable, 1);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int pn544_hci_disable_se(struct nfc_hci_dev *hdev, u32 se_idx)\r\n{\r\nstruct nfc_se *se;\r\nu8 disable = PN544_SE_MODE_OFF;\r\nse = nfc_find_se(hdev->ndev, se_idx);\r\nswitch (se->type) {\r\ncase NFC_SE_UICC:\r\nreturn nfc_hci_set_param(hdev, PN544_SWP_MGMT_GATE,\r\nPN544_SWP_DEFAULT_MODE, &disable, 1);\r\ncase NFC_SE_EMBEDDED:\r\nreturn nfc_hci_set_param(hdev, PN544_NFC_WI_MGMT_GATE,\r\nPN544_NFC_ESE_DEFAULT_MODE, &disable, 1);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nint pn544_hci_probe(void *phy_id, struct nfc_phy_ops *phy_ops, char *llc_name,\r\nint phy_headroom, int phy_tailroom, int phy_payload,\r\nfw_download_t fw_download, struct nfc_hci_dev **hdev)\r\n{\r\nstruct pn544_hci_info *info;\r\nu32 protocols;\r\nstruct nfc_hci_init_data init_data;\r\nint r;\r\ninfo = kzalloc(sizeof(struct pn544_hci_info), GFP_KERNEL);\r\nif (!info) {\r\nr = -ENOMEM;\r\ngoto err_info_alloc;\r\n}\r\ninfo->phy_ops = phy_ops;\r\ninfo->phy_id = phy_id;\r\ninfo->fw_download = fw_download;\r\ninfo->state = PN544_ST_COLD;\r\nmutex_init(&info->info_lock);\r\ninit_data.gate_count = ARRAY_SIZE(pn544_gates);\r\nmemcpy(init_data.gates, pn544_gates, sizeof(pn544_gates));\r\nstrcpy(init_data.session_id, "ID544HCI");\r\nprotocols = NFC_PROTO_JEWEL_MASK |\r\nNFC_PROTO_MIFARE_MASK |\r\nNFC_PROTO_FELICA_MASK |\r\nNFC_PROTO_ISO14443_MASK |\r\nNFC_PROTO_ISO14443_B_MASK |\r\nNFC_PROTO_NFC_DEP_MASK;\r\ninfo->hdev = nfc_hci_allocate_device(&pn544_hci_ops, &init_data, 0,\r\nprotocols, llc_name,\r\nphy_headroom + PN544_CMDS_HEADROOM,\r\nphy_tailroom, phy_payload);\r\nif (!info->hdev) {\r\npr_err("Cannot allocate nfc hdev\n");\r\nr = -ENOMEM;\r\ngoto err_alloc_hdev;\r\n}\r\nnfc_hci_set_clientdata(info->hdev, info);\r\nr = nfc_hci_register_device(info->hdev);\r\nif (r)\r\ngoto err_regdev;\r\n*hdev = info->hdev;\r\nreturn 0;\r\nerr_regdev:\r\nnfc_hci_free_device(info->hdev);\r\nerr_alloc_hdev:\r\nkfree(info);\r\nerr_info_alloc:\r\nreturn r;\r\n}\r\nvoid pn544_hci_remove(struct nfc_hci_dev *hdev)\r\n{\r\nstruct pn544_hci_info *info = nfc_hci_get_clientdata(hdev);\r\nnfc_hci_unregister_device(hdev);\r\nnfc_hci_free_device(hdev);\r\nkfree(info);\r\n}
