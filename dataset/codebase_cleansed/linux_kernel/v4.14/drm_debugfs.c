static int drm_debugfs_open(struct inode *inode, struct file *file)\r\n{\r\nstruct drm_info_node *node = inode->i_private;\r\nreturn single_open(file, node->info_ent->show, node);\r\n}\r\nint drm_debugfs_create_files(const struct drm_info_list *files, int count,\r\nstruct dentry *root, struct drm_minor *minor)\r\n{\r\nstruct drm_device *dev = minor->dev;\r\nstruct dentry *ent;\r\nstruct drm_info_node *tmp;\r\nint i, ret;\r\nfor (i = 0; i < count; i++) {\r\nu32 features = files[i].driver_features;\r\nif (features != 0 &&\r\n(dev->driver->driver_features & features) != features)\r\ncontinue;\r\ntmp = kmalloc(sizeof(struct drm_info_node), GFP_KERNEL);\r\nif (tmp == NULL) {\r\nret = -1;\r\ngoto fail;\r\n}\r\nent = debugfs_create_file(files[i].name, S_IFREG | S_IRUGO,\r\nroot, tmp, &drm_debugfs_fops);\r\nif (!ent) {\r\nDRM_ERROR("Cannot create /sys/kernel/debug/dri/%pd/%s\n",\r\nroot, files[i].name);\r\nkfree(tmp);\r\nret = -1;\r\ngoto fail;\r\n}\r\ntmp->minor = minor;\r\ntmp->dent = ent;\r\ntmp->info_ent = &files[i];\r\nmutex_lock(&minor->debugfs_lock);\r\nlist_add(&tmp->list, &minor->debugfs_list);\r\nmutex_unlock(&minor->debugfs_lock);\r\n}\r\nreturn 0;\r\nfail:\r\ndrm_debugfs_remove_files(files, count, minor);\r\nreturn ret;\r\n}\r\nint drm_debugfs_init(struct drm_minor *minor, int minor_id,\r\nstruct dentry *root)\r\n{\r\nstruct drm_device *dev = minor->dev;\r\nchar name[64];\r\nint ret;\r\nINIT_LIST_HEAD(&minor->debugfs_list);\r\nmutex_init(&minor->debugfs_lock);\r\nsprintf(name, "%d", minor_id);\r\nminor->debugfs_root = debugfs_create_dir(name, root);\r\nif (!minor->debugfs_root) {\r\nDRM_ERROR("Cannot create /sys/kernel/debug/dri/%s\n", name);\r\nreturn -1;\r\n}\r\nret = drm_debugfs_create_files(drm_debugfs_list, DRM_DEBUGFS_ENTRIES,\r\nminor->debugfs_root, minor);\r\nif (ret) {\r\ndebugfs_remove(minor->debugfs_root);\r\nminor->debugfs_root = NULL;\r\nDRM_ERROR("Failed to create core drm debugfs files\n");\r\nreturn ret;\r\n}\r\nif (drm_core_check_feature(dev, DRIVER_ATOMIC)) {\r\nret = drm_atomic_debugfs_init(minor);\r\nif (ret) {\r\nDRM_ERROR("Failed to create atomic debugfs files\n");\r\nreturn ret;\r\n}\r\n}\r\nif (dev->driver->debugfs_init) {\r\nret = dev->driver->debugfs_init(minor);\r\nif (ret) {\r\nDRM_ERROR("DRM: Driver failed to initialize "\r\n"/sys/kernel/debug/dri.\n");\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint drm_debugfs_remove_files(const struct drm_info_list *files, int count,\r\nstruct drm_minor *minor)\r\n{\r\nstruct list_head *pos, *q;\r\nstruct drm_info_node *tmp;\r\nint i;\r\nmutex_lock(&minor->debugfs_lock);\r\nfor (i = 0; i < count; i++) {\r\nlist_for_each_safe(pos, q, &minor->debugfs_list) {\r\ntmp = list_entry(pos, struct drm_info_node, list);\r\nif (tmp->info_ent == &files[i]) {\r\ndebugfs_remove(tmp->dent);\r\nlist_del(pos);\r\nkfree(tmp);\r\n}\r\n}\r\n}\r\nmutex_unlock(&minor->debugfs_lock);\r\nreturn 0;\r\n}\r\nstatic void drm_debugfs_remove_all_files(struct drm_minor *minor)\r\n{\r\nstruct drm_info_node *node, *tmp;\r\nmutex_lock(&minor->debugfs_lock);\r\nlist_for_each_entry_safe(node, tmp, &minor->debugfs_list, list) {\r\ndebugfs_remove(node->dent);\r\nlist_del(&node->list);\r\nkfree(node);\r\n}\r\nmutex_unlock(&minor->debugfs_lock);\r\n}\r\nint drm_debugfs_cleanup(struct drm_minor *minor)\r\n{\r\nif (!minor->debugfs_root)\r\nreturn 0;\r\ndrm_debugfs_remove_all_files(minor);\r\ndebugfs_remove_recursive(minor->debugfs_root);\r\nminor->debugfs_root = NULL;\r\nreturn 0;\r\n}\r\nstatic int connector_show(struct seq_file *m, void *data)\r\n{\r\nstruct drm_connector *connector = m->private;\r\nseq_printf(m, "%s\n", drm_get_connector_force_name(connector->force));\r\nreturn 0;\r\n}\r\nstatic int connector_open(struct inode *inode, struct file *file)\r\n{\r\nstruct drm_connector *dev = inode->i_private;\r\nreturn single_open(file, connector_show, dev);\r\n}\r\nstatic ssize_t connector_write(struct file *file, const char __user *ubuf,\r\nsize_t len, loff_t *offp)\r\n{\r\nstruct seq_file *m = file->private_data;\r\nstruct drm_connector *connector = m->private;\r\nchar buf[12];\r\nif (len > sizeof(buf) - 1)\r\nreturn -EINVAL;\r\nif (copy_from_user(buf, ubuf, len))\r\nreturn -EFAULT;\r\nbuf[len] = '\0';\r\nif (!strcmp(buf, "on"))\r\nconnector->force = DRM_FORCE_ON;\r\nelse if (!strcmp(buf, "digital"))\r\nconnector->force = DRM_FORCE_ON_DIGITAL;\r\nelse if (!strcmp(buf, "off"))\r\nconnector->force = DRM_FORCE_OFF;\r\nelse if (!strcmp(buf, "unspecified"))\r\nconnector->force = DRM_FORCE_UNSPECIFIED;\r\nelse\r\nreturn -EINVAL;\r\nreturn len;\r\n}\r\nstatic int edid_show(struct seq_file *m, void *data)\r\n{\r\nstruct drm_connector *connector = m->private;\r\nstruct drm_property_blob *edid = connector->edid_blob_ptr;\r\nif (connector->override_edid && edid)\r\nseq_write(m, edid->data, edid->length);\r\nreturn 0;\r\n}\r\nstatic int edid_open(struct inode *inode, struct file *file)\r\n{\r\nstruct drm_connector *dev = inode->i_private;\r\nreturn single_open(file, edid_show, dev);\r\n}\r\nstatic ssize_t edid_write(struct file *file, const char __user *ubuf,\r\nsize_t len, loff_t *offp)\r\n{\r\nstruct seq_file *m = file->private_data;\r\nstruct drm_connector *connector = m->private;\r\nchar *buf;\r\nstruct edid *edid;\r\nint ret;\r\nbuf = memdup_user(ubuf, len);\r\nif (IS_ERR(buf))\r\nreturn PTR_ERR(buf);\r\nedid = (struct edid *) buf;\r\nif (len == 5 && !strncmp(buf, "reset", 5)) {\r\nconnector->override_edid = false;\r\nret = drm_mode_connector_update_edid_property(connector, NULL);\r\n} else if (len < EDID_LENGTH ||\r\nEDID_LENGTH * (1 + edid->extensions) > len)\r\nret = -EINVAL;\r\nelse {\r\nconnector->override_edid = false;\r\nret = drm_mode_connector_update_edid_property(connector, edid);\r\nif (!ret)\r\nconnector->override_edid = true;\r\n}\r\nkfree(buf);\r\nreturn (ret) ? ret : len;\r\n}\r\nint drm_debugfs_connector_add(struct drm_connector *connector)\r\n{\r\nstruct drm_minor *minor = connector->dev->primary;\r\nstruct dentry *root, *ent;\r\nif (!minor->debugfs_root)\r\nreturn -1;\r\nroot = debugfs_create_dir(connector->name, minor->debugfs_root);\r\nif (!root)\r\nreturn -ENOMEM;\r\nconnector->debugfs_entry = root;\r\nent = debugfs_create_file("force", S_IRUGO | S_IWUSR, root, connector,\r\n&drm_connector_fops);\r\nif (!ent)\r\ngoto error;\r\nent = debugfs_create_file("edid_override", S_IRUGO | S_IWUSR, root,\r\nconnector, &drm_edid_fops);\r\nif (!ent)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\ndebugfs_remove_recursive(connector->debugfs_entry);\r\nconnector->debugfs_entry = NULL;\r\nreturn -ENOMEM;\r\n}\r\nvoid drm_debugfs_connector_remove(struct drm_connector *connector)\r\n{\r\nif (!connector->debugfs_entry)\r\nreturn;\r\ndebugfs_remove_recursive(connector->debugfs_entry);\r\nconnector->debugfs_entry = NULL;\r\n}\r\nint drm_debugfs_crtc_add(struct drm_crtc *crtc)\r\n{\r\nstruct drm_minor *minor = crtc->dev->primary;\r\nstruct dentry *root;\r\nchar *name;\r\nname = kasprintf(GFP_KERNEL, "crtc-%d", crtc->index);\r\nif (!name)\r\nreturn -ENOMEM;\r\nroot = debugfs_create_dir(name, minor->debugfs_root);\r\nkfree(name);\r\nif (!root)\r\nreturn -ENOMEM;\r\ncrtc->debugfs_entry = root;\r\nif (drm_debugfs_crtc_crc_add(crtc))\r\ngoto error;\r\nreturn 0;\r\nerror:\r\ndrm_debugfs_crtc_remove(crtc);\r\nreturn -ENOMEM;\r\n}\r\nvoid drm_debugfs_crtc_remove(struct drm_crtc *crtc)\r\n{\r\ndebugfs_remove_recursive(crtc->debugfs_entry);\r\ncrtc->debugfs_entry = NULL;\r\n}
