static inline grant_ref_t *__gnttab_entry(grant_ref_t entry)\r\n{\r\nreturn &gnttab_list[(entry) / RPP][(entry) % RPP];\r\n}\r\nstatic int get_free_entries(unsigned count)\r\n{\r\nunsigned long flags;\r\nint ref, rc = 0;\r\ngrant_ref_t head;\r\nspin_lock_irqsave(&gnttab_list_lock, flags);\r\nif ((gnttab_free_count < count) &&\r\n((rc = gnttab_expand(count - gnttab_free_count)) < 0)) {\r\nspin_unlock_irqrestore(&gnttab_list_lock, flags);\r\nreturn rc;\r\n}\r\nref = head = gnttab_free_head;\r\ngnttab_free_count -= count;\r\nwhile (count-- > 1)\r\nhead = gnttab_entry(head);\r\ngnttab_free_head = gnttab_entry(head);\r\ngnttab_entry(head) = GNTTAB_LIST_END;\r\nspin_unlock_irqrestore(&gnttab_list_lock, flags);\r\nreturn ref;\r\n}\r\nstatic void do_free_callbacks(void)\r\n{\r\nstruct gnttab_free_callback *callback, *next;\r\ncallback = gnttab_free_callback_list;\r\ngnttab_free_callback_list = NULL;\r\nwhile (callback != NULL) {\r\nnext = callback->next;\r\nif (gnttab_free_count >= callback->count) {\r\ncallback->next = NULL;\r\ncallback->fn(callback->arg);\r\n} else {\r\ncallback->next = gnttab_free_callback_list;\r\ngnttab_free_callback_list = callback;\r\n}\r\ncallback = next;\r\n}\r\n}\r\nstatic inline void check_free_callbacks(void)\r\n{\r\nif (unlikely(gnttab_free_callback_list))\r\ndo_free_callbacks();\r\n}\r\nstatic void put_free_entry(grant_ref_t ref)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&gnttab_list_lock, flags);\r\ngnttab_entry(ref) = gnttab_free_head;\r\ngnttab_free_head = ref;\r\ngnttab_free_count++;\r\ncheck_free_callbacks();\r\nspin_unlock_irqrestore(&gnttab_list_lock, flags);\r\n}\r\nstatic void gnttab_update_entry_v1(grant_ref_t ref, domid_t domid,\r\nunsigned long frame, unsigned flags)\r\n{\r\ngnttab_shared.v1[ref].domid = domid;\r\ngnttab_shared.v1[ref].frame = frame;\r\nwmb();\r\ngnttab_shared.v1[ref].flags = flags;\r\n}\r\nvoid gnttab_grant_foreign_access_ref(grant_ref_t ref, domid_t domid,\r\nunsigned long frame, int readonly)\r\n{\r\ngnttab_interface->update_entry(ref, domid, frame,\r\nGTF_permit_access | (readonly ? GTF_readonly : 0));\r\n}\r\nint gnttab_grant_foreign_access(domid_t domid, unsigned long frame,\r\nint readonly)\r\n{\r\nint ref;\r\nref = get_free_entries(1);\r\nif (unlikely(ref < 0))\r\nreturn -ENOSPC;\r\ngnttab_grant_foreign_access_ref(ref, domid, frame, readonly);\r\nreturn ref;\r\n}\r\nstatic int gnttab_query_foreign_access_v1(grant_ref_t ref)\r\n{\r\nreturn gnttab_shared.v1[ref].flags & (GTF_reading|GTF_writing);\r\n}\r\nint gnttab_query_foreign_access(grant_ref_t ref)\r\n{\r\nreturn gnttab_interface->query_foreign_access(ref);\r\n}\r\nstatic int gnttab_end_foreign_access_ref_v1(grant_ref_t ref, int readonly)\r\n{\r\nu16 flags, nflags;\r\nu16 *pflags;\r\npflags = &gnttab_shared.v1[ref].flags;\r\nnflags = *pflags;\r\ndo {\r\nflags = nflags;\r\nif (flags & (GTF_reading|GTF_writing))\r\nreturn 0;\r\n} while ((nflags = sync_cmpxchg(pflags, flags, 0)) != flags);\r\nreturn 1;\r\n}\r\nstatic inline int _gnttab_end_foreign_access_ref(grant_ref_t ref, int readonly)\r\n{\r\nreturn gnttab_interface->end_foreign_access_ref(ref, readonly);\r\n}\r\nint gnttab_end_foreign_access_ref(grant_ref_t ref, int readonly)\r\n{\r\nif (_gnttab_end_foreign_access_ref(ref, readonly))\r\nreturn 1;\r\npr_warn("WARNING: g.e. %#x still in use!\n", ref);\r\nreturn 0;\r\n}\r\nstatic void gnttab_handle_deferred(unsigned long unused)\r\n{\r\nunsigned int nr = 10;\r\nstruct deferred_entry *first = NULL;\r\nunsigned long flags;\r\nspin_lock_irqsave(&gnttab_list_lock, flags);\r\nwhile (nr--) {\r\nstruct deferred_entry *entry\r\n= list_first_entry(&deferred_list,\r\nstruct deferred_entry, list);\r\nif (entry == first)\r\nbreak;\r\nlist_del(&entry->list);\r\nspin_unlock_irqrestore(&gnttab_list_lock, flags);\r\nif (_gnttab_end_foreign_access_ref(entry->ref, entry->ro)) {\r\nput_free_entry(entry->ref);\r\nif (entry->page) {\r\npr_debug("freeing g.e. %#x (pfn %#lx)\n",\r\nentry->ref, page_to_pfn(entry->page));\r\n__free_page(entry->page);\r\n} else\r\npr_info("freeing g.e. %#x\n", entry->ref);\r\nkfree(entry);\r\nentry = NULL;\r\n} else {\r\nif (!--entry->warn_delay)\r\npr_info("g.e. %#x still pending\n", entry->ref);\r\nif (!first)\r\nfirst = entry;\r\n}\r\nspin_lock_irqsave(&gnttab_list_lock, flags);\r\nif (entry)\r\nlist_add_tail(&entry->list, &deferred_list);\r\nelse if (list_empty(&deferred_list))\r\nbreak;\r\n}\r\nif (!list_empty(&deferred_list) && !timer_pending(&deferred_timer)) {\r\ndeferred_timer.expires = jiffies + HZ;\r\nadd_timer(&deferred_timer);\r\n}\r\nspin_unlock_irqrestore(&gnttab_list_lock, flags);\r\n}\r\nstatic void gnttab_add_deferred(grant_ref_t ref, bool readonly,\r\nstruct page *page)\r\n{\r\nstruct deferred_entry *entry = kmalloc(sizeof(*entry), GFP_ATOMIC);\r\nconst char *what = KERN_WARNING "leaking";\r\nif (entry) {\r\nunsigned long flags;\r\nentry->ref = ref;\r\nentry->ro = readonly;\r\nentry->page = page;\r\nentry->warn_delay = 60;\r\nspin_lock_irqsave(&gnttab_list_lock, flags);\r\nlist_add_tail(&entry->list, &deferred_list);\r\nif (!timer_pending(&deferred_timer)) {\r\ndeferred_timer.expires = jiffies + HZ;\r\nadd_timer(&deferred_timer);\r\n}\r\nspin_unlock_irqrestore(&gnttab_list_lock, flags);\r\nwhat = KERN_DEBUG "deferring";\r\n}\r\nprintk("%s g.e. %#x (pfn %#lx)\n",\r\nwhat, ref, page ? page_to_pfn(page) : -1);\r\n}\r\nvoid gnttab_end_foreign_access(grant_ref_t ref, int readonly,\r\nunsigned long page)\r\n{\r\nif (gnttab_end_foreign_access_ref(ref, readonly)) {\r\nput_free_entry(ref);\r\nif (page != 0)\r\nfree_page(page);\r\n} else\r\ngnttab_add_deferred(ref, readonly,\r\npage ? virt_to_page(page) : NULL);\r\n}\r\nint gnttab_grant_foreign_transfer(domid_t domid, unsigned long pfn)\r\n{\r\nint ref;\r\nref = get_free_entries(1);\r\nif (unlikely(ref < 0))\r\nreturn -ENOSPC;\r\ngnttab_grant_foreign_transfer_ref(ref, domid, pfn);\r\nreturn ref;\r\n}\r\nvoid gnttab_grant_foreign_transfer_ref(grant_ref_t ref, domid_t domid,\r\nunsigned long pfn)\r\n{\r\ngnttab_interface->update_entry(ref, domid, pfn, GTF_accept_transfer);\r\n}\r\nstatic unsigned long gnttab_end_foreign_transfer_ref_v1(grant_ref_t ref)\r\n{\r\nunsigned long frame;\r\nu16 flags;\r\nu16 *pflags;\r\npflags = &gnttab_shared.v1[ref].flags;\r\nwhile (!((flags = *pflags) & GTF_transfer_committed)) {\r\nif (sync_cmpxchg(pflags, flags, 0) == flags)\r\nreturn 0;\r\ncpu_relax();\r\n}\r\nwhile (!(flags & GTF_transfer_completed)) {\r\nflags = *pflags;\r\ncpu_relax();\r\n}\r\nrmb();\r\nframe = gnttab_shared.v1[ref].frame;\r\nBUG_ON(frame == 0);\r\nreturn frame;\r\n}\r\nunsigned long gnttab_end_foreign_transfer_ref(grant_ref_t ref)\r\n{\r\nreturn gnttab_interface->end_foreign_transfer_ref(ref);\r\n}\r\nunsigned long gnttab_end_foreign_transfer(grant_ref_t ref)\r\n{\r\nunsigned long frame = gnttab_end_foreign_transfer_ref(ref);\r\nput_free_entry(ref);\r\nreturn frame;\r\n}\r\nvoid gnttab_free_grant_reference(grant_ref_t ref)\r\n{\r\nput_free_entry(ref);\r\n}\r\nvoid gnttab_free_grant_references(grant_ref_t head)\r\n{\r\ngrant_ref_t ref;\r\nunsigned long flags;\r\nint count = 1;\r\nif (head == GNTTAB_LIST_END)\r\nreturn;\r\nspin_lock_irqsave(&gnttab_list_lock, flags);\r\nref = head;\r\nwhile (gnttab_entry(ref) != GNTTAB_LIST_END) {\r\nref = gnttab_entry(ref);\r\ncount++;\r\n}\r\ngnttab_entry(ref) = gnttab_free_head;\r\ngnttab_free_head = head;\r\ngnttab_free_count += count;\r\ncheck_free_callbacks();\r\nspin_unlock_irqrestore(&gnttab_list_lock, flags);\r\n}\r\nint gnttab_alloc_grant_references(u16 count, grant_ref_t *head)\r\n{\r\nint h = get_free_entries(count);\r\nif (h < 0)\r\nreturn -ENOSPC;\r\n*head = h;\r\nreturn 0;\r\n}\r\nint gnttab_empty_grant_references(const grant_ref_t *private_head)\r\n{\r\nreturn (*private_head == GNTTAB_LIST_END);\r\n}\r\nint gnttab_claim_grant_reference(grant_ref_t *private_head)\r\n{\r\ngrant_ref_t g = *private_head;\r\nif (unlikely(g == GNTTAB_LIST_END))\r\nreturn -ENOSPC;\r\n*private_head = gnttab_entry(g);\r\nreturn g;\r\n}\r\nvoid gnttab_release_grant_reference(grant_ref_t *private_head,\r\ngrant_ref_t release)\r\n{\r\ngnttab_entry(release) = *private_head;\r\n*private_head = release;\r\n}\r\nvoid gnttab_request_free_callback(struct gnttab_free_callback *callback,\r\nvoid (*fn)(void *), void *arg, u16 count)\r\n{\r\nunsigned long flags;\r\nstruct gnttab_free_callback *cb;\r\nspin_lock_irqsave(&gnttab_list_lock, flags);\r\ncb = gnttab_free_callback_list;\r\nwhile (cb) {\r\nif (cb == callback)\r\ngoto out;\r\ncb = cb->next;\r\n}\r\ncallback->fn = fn;\r\ncallback->arg = arg;\r\ncallback->count = count;\r\ncallback->next = gnttab_free_callback_list;\r\ngnttab_free_callback_list = callback;\r\ncheck_free_callbacks();\r\nout:\r\nspin_unlock_irqrestore(&gnttab_list_lock, flags);\r\n}\r\nvoid gnttab_cancel_free_callback(struct gnttab_free_callback *callback)\r\n{\r\nstruct gnttab_free_callback **pcb;\r\nunsigned long flags;\r\nspin_lock_irqsave(&gnttab_list_lock, flags);\r\nfor (pcb = &gnttab_free_callback_list; *pcb; pcb = &(*pcb)->next) {\r\nif (*pcb == callback) {\r\n*pcb = callback->next;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&gnttab_list_lock, flags);\r\n}\r\nstatic int grow_gnttab_list(unsigned int more_frames)\r\n{\r\nunsigned int new_nr_grant_frames, extra_entries, i;\r\nunsigned int nr_glist_frames, new_nr_glist_frames;\r\nBUG_ON(grefs_per_grant_frame == 0);\r\nnew_nr_grant_frames = nr_grant_frames + more_frames;\r\nextra_entries = more_frames * grefs_per_grant_frame;\r\nnr_glist_frames = (nr_grant_frames * grefs_per_grant_frame + RPP - 1) / RPP;\r\nnew_nr_glist_frames =\r\n(new_nr_grant_frames * grefs_per_grant_frame + RPP - 1) / RPP;\r\nfor (i = nr_glist_frames; i < new_nr_glist_frames; i++) {\r\ngnttab_list[i] = (grant_ref_t *)__get_free_page(GFP_ATOMIC);\r\nif (!gnttab_list[i])\r\ngoto grow_nomem;\r\n}\r\nfor (i = grefs_per_grant_frame * nr_grant_frames;\r\ni < grefs_per_grant_frame * new_nr_grant_frames - 1; i++)\r\ngnttab_entry(i) = i + 1;\r\ngnttab_entry(i) = gnttab_free_head;\r\ngnttab_free_head = grefs_per_grant_frame * nr_grant_frames;\r\ngnttab_free_count += extra_entries;\r\nnr_grant_frames = new_nr_grant_frames;\r\ncheck_free_callbacks();\r\nreturn 0;\r\ngrow_nomem:\r\nwhile (i-- > nr_glist_frames)\r\nfree_page((unsigned long) gnttab_list[i]);\r\nreturn -ENOMEM;\r\n}\r\nstatic unsigned int __max_nr_grant_frames(void)\r\n{\r\nstruct gnttab_query_size query;\r\nint rc;\r\nquery.dom = DOMID_SELF;\r\nrc = HYPERVISOR_grant_table_op(GNTTABOP_query_size, &query, 1);\r\nif ((rc < 0) || (query.status != GNTST_okay))\r\nreturn 4;\r\nreturn query.max_nr_frames;\r\n}\r\nunsigned int gnttab_max_grant_frames(void)\r\n{\r\nunsigned int xen_max = __max_nr_grant_frames();\r\nstatic unsigned int boot_max_nr_grant_frames;\r\nif (!boot_max_nr_grant_frames)\r\nboot_max_nr_grant_frames = __max_nr_grant_frames();\r\nif (xen_max > boot_max_nr_grant_frames)\r\nreturn boot_max_nr_grant_frames;\r\nreturn xen_max;\r\n}\r\nint gnttab_setup_auto_xlat_frames(phys_addr_t addr)\r\n{\r\nxen_pfn_t *pfn;\r\nunsigned int max_nr_gframes = __max_nr_grant_frames();\r\nunsigned int i;\r\nvoid *vaddr;\r\nif (xen_auto_xlat_grant_frames.count)\r\nreturn -EINVAL;\r\nvaddr = xen_remap(addr, XEN_PAGE_SIZE * max_nr_gframes);\r\nif (vaddr == NULL) {\r\npr_warn("Failed to ioremap gnttab share frames (addr=%pa)!\n",\r\n&addr);\r\nreturn -ENOMEM;\r\n}\r\npfn = kcalloc(max_nr_gframes, sizeof(pfn[0]), GFP_KERNEL);\r\nif (!pfn) {\r\nxen_unmap(vaddr);\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < max_nr_gframes; i++)\r\npfn[i] = XEN_PFN_DOWN(addr) + i;\r\nxen_auto_xlat_grant_frames.vaddr = vaddr;\r\nxen_auto_xlat_grant_frames.pfn = pfn;\r\nxen_auto_xlat_grant_frames.count = max_nr_gframes;\r\nreturn 0;\r\n}\r\nvoid gnttab_free_auto_xlat_frames(void)\r\n{\r\nif (!xen_auto_xlat_grant_frames.count)\r\nreturn;\r\nkfree(xen_auto_xlat_grant_frames.pfn);\r\nxen_unmap(xen_auto_xlat_grant_frames.vaddr);\r\nxen_auto_xlat_grant_frames.pfn = NULL;\r\nxen_auto_xlat_grant_frames.count = 0;\r\nxen_auto_xlat_grant_frames.vaddr = NULL;\r\n}\r\nint gnttab_alloc_pages(int nr_pages, struct page **pages)\r\n{\r\nint i;\r\nint ret;\r\nret = alloc_xenballooned_pages(nr_pages, pages);\r\nif (ret < 0)\r\nreturn ret;\r\nfor (i = 0; i < nr_pages; i++) {\r\n#if BITS_PER_LONG < 64\r\nstruct xen_page_foreign *foreign;\r\nforeign = kzalloc(sizeof(*foreign), GFP_KERNEL);\r\nif (!foreign) {\r\ngnttab_free_pages(nr_pages, pages);\r\nreturn -ENOMEM;\r\n}\r\nset_page_private(pages[i], (unsigned long)foreign);\r\n#endif\r\nSetPagePrivate(pages[i]);\r\n}\r\nreturn 0;\r\n}\r\nvoid gnttab_free_pages(int nr_pages, struct page **pages)\r\n{\r\nint i;\r\nfor (i = 0; i < nr_pages; i++) {\r\nif (PagePrivate(pages[i])) {\r\n#if BITS_PER_LONG < 64\r\nkfree((void *)page_private(pages[i]));\r\n#endif\r\nClearPagePrivate(pages[i]);\r\n}\r\n}\r\nfree_xenballooned_pages(nr_pages, pages);\r\n}\r\nstatic inline void\r\ngnttab_retry_eagain_gop(unsigned int cmd, void *gop, int16_t *status,\r\nconst char *func)\r\n{\r\nunsigned delay = 1;\r\ndo {\r\nBUG_ON(HYPERVISOR_grant_table_op(cmd, gop, 1));\r\nif (*status == GNTST_eagain)\r\nmsleep(delay++);\r\n} while ((*status == GNTST_eagain) && (delay < MAX_DELAY));\r\nif (delay >= MAX_DELAY) {\r\npr_err("%s: %s eagain grant\n", func, current->comm);\r\n*status = GNTST_bad_page;\r\n}\r\n}\r\nvoid gnttab_batch_map(struct gnttab_map_grant_ref *batch, unsigned count)\r\n{\r\nstruct gnttab_map_grant_ref *op;\r\nif (HYPERVISOR_grant_table_op(GNTTABOP_map_grant_ref, batch, count))\r\nBUG();\r\nfor (op = batch; op < batch + count; op++)\r\nif (op->status == GNTST_eagain)\r\ngnttab_retry_eagain_gop(GNTTABOP_map_grant_ref, op,\r\n&op->status, __func__);\r\n}\r\nvoid gnttab_batch_copy(struct gnttab_copy *batch, unsigned count)\r\n{\r\nstruct gnttab_copy *op;\r\nif (HYPERVISOR_grant_table_op(GNTTABOP_copy, batch, count))\r\nBUG();\r\nfor (op = batch; op < batch + count; op++)\r\nif (op->status == GNTST_eagain)\r\ngnttab_retry_eagain_gop(GNTTABOP_copy, op,\r\n&op->status, __func__);\r\n}\r\nvoid gnttab_foreach_grant_in_range(struct page *page,\r\nunsigned int offset,\r\nunsigned int len,\r\nxen_grant_fn_t fn,\r\nvoid *data)\r\n{\r\nunsigned int goffset;\r\nunsigned int glen;\r\nunsigned long xen_pfn;\r\nlen = min_t(unsigned int, PAGE_SIZE - offset, len);\r\ngoffset = xen_offset_in_page(offset);\r\nxen_pfn = page_to_xen_pfn(page) + XEN_PFN_DOWN(offset);\r\nwhile (len) {\r\nglen = min_t(unsigned int, XEN_PAGE_SIZE - goffset, len);\r\nfn(pfn_to_gfn(xen_pfn), goffset, glen, data);\r\ngoffset = 0;\r\nxen_pfn++;\r\nlen -= glen;\r\n}\r\n}\r\nvoid gnttab_foreach_grant(struct page **pages,\r\nunsigned int nr_grefs,\r\nxen_grant_fn_t fn,\r\nvoid *data)\r\n{\r\nunsigned int goffset = 0;\r\nunsigned long xen_pfn = 0;\r\nunsigned int i;\r\nfor (i = 0; i < nr_grefs; i++) {\r\nif ((i % XEN_PFN_PER_PAGE) == 0) {\r\nxen_pfn = page_to_xen_pfn(pages[i / XEN_PFN_PER_PAGE]);\r\ngoffset = 0;\r\n}\r\nfn(pfn_to_gfn(xen_pfn), goffset, XEN_PAGE_SIZE, data);\r\ngoffset += XEN_PAGE_SIZE;\r\nxen_pfn++;\r\n}\r\n}\r\nint gnttab_map_refs(struct gnttab_map_grant_ref *map_ops,\r\nstruct gnttab_map_grant_ref *kmap_ops,\r\nstruct page **pages, unsigned int count)\r\n{\r\nint i, ret;\r\nret = HYPERVISOR_grant_table_op(GNTTABOP_map_grant_ref, map_ops, count);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < count; i++) {\r\nif (map_ops[i].status == GNTST_eagain)\r\ngnttab_retry_eagain_gop(GNTTABOP_map_grant_ref, map_ops + i,\r\n&map_ops[i].status, __func__);\r\nif (map_ops[i].status == GNTST_okay) {\r\nstruct xen_page_foreign *foreign;\r\nSetPageForeign(pages[i]);\r\nforeign = xen_page_foreign(pages[i]);\r\nforeign->domid = map_ops[i].dom;\r\nforeign->gref = map_ops[i].ref;\r\n}\r\n}\r\nreturn set_foreign_p2m_mapping(map_ops, kmap_ops, pages, count);\r\n}\r\nint gnttab_unmap_refs(struct gnttab_unmap_grant_ref *unmap_ops,\r\nstruct gnttab_unmap_grant_ref *kunmap_ops,\r\nstruct page **pages, unsigned int count)\r\n{\r\nunsigned int i;\r\nint ret;\r\nret = HYPERVISOR_grant_table_op(GNTTABOP_unmap_grant_ref, unmap_ops, count);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < count; i++)\r\nClearPageForeign(pages[i]);\r\nreturn clear_foreign_p2m_mapping(unmap_ops, kunmap_ops, pages, count);\r\n}\r\nstatic void gnttab_unmap_work(struct work_struct *work)\r\n{\r\nstruct gntab_unmap_queue_data\r\n*unmap_data = container_of(work,\r\nstruct gntab_unmap_queue_data,\r\ngnttab_work.work);\r\nif (unmap_data->age != UINT_MAX)\r\nunmap_data->age++;\r\n__gnttab_unmap_refs_async(unmap_data);\r\n}\r\nstatic void __gnttab_unmap_refs_async(struct gntab_unmap_queue_data* item)\r\n{\r\nint ret;\r\nint pc;\r\nfor (pc = 0; pc < item->count; pc++) {\r\nif (page_count(item->pages[pc]) > 1) {\r\nunsigned long delay = GNTTAB_UNMAP_REFS_DELAY * (item->age + 1);\r\nschedule_delayed_work(&item->gnttab_work,\r\nmsecs_to_jiffies(delay));\r\nreturn;\r\n}\r\n}\r\nret = gnttab_unmap_refs(item->unmap_ops, item->kunmap_ops,\r\nitem->pages, item->count);\r\nitem->done(ret, item);\r\n}\r\nvoid gnttab_unmap_refs_async(struct gntab_unmap_queue_data* item)\r\n{\r\nINIT_DELAYED_WORK(&item->gnttab_work, gnttab_unmap_work);\r\nitem->age = 0;\r\n__gnttab_unmap_refs_async(item);\r\n}\r\nstatic void unmap_refs_callback(int result,\r\nstruct gntab_unmap_queue_data *data)\r\n{\r\nstruct unmap_refs_callback_data *d = data->data;\r\nd->result = result;\r\ncomplete(&d->completion);\r\n}\r\nint gnttab_unmap_refs_sync(struct gntab_unmap_queue_data *item)\r\n{\r\nstruct unmap_refs_callback_data data;\r\ninit_completion(&data.completion);\r\nitem->data = &data;\r\nitem->done = &unmap_refs_callback;\r\ngnttab_unmap_refs_async(item);\r\nwait_for_completion(&data.completion);\r\nreturn data.result;\r\n}\r\nstatic int gnttab_map_frames_v1(xen_pfn_t *frames, unsigned int nr_gframes)\r\n{\r\nint rc;\r\nrc = arch_gnttab_map_shared(frames, nr_gframes,\r\ngnttab_max_grant_frames(),\r\n&gnttab_shared.addr);\r\nBUG_ON(rc);\r\nreturn 0;\r\n}\r\nstatic void gnttab_unmap_frames_v1(void)\r\n{\r\narch_gnttab_unmap(gnttab_shared.addr, nr_grant_frames);\r\n}\r\nstatic int gnttab_map(unsigned int start_idx, unsigned int end_idx)\r\n{\r\nstruct gnttab_setup_table setup;\r\nxen_pfn_t *frames;\r\nunsigned int nr_gframes = end_idx + 1;\r\nint rc;\r\nif (xen_feature(XENFEAT_auto_translated_physmap)) {\r\nstruct xen_add_to_physmap xatp;\r\nunsigned int i = end_idx;\r\nrc = 0;\r\nBUG_ON(xen_auto_xlat_grant_frames.count < nr_gframes);\r\ndo {\r\nxatp.domid = DOMID_SELF;\r\nxatp.idx = i;\r\nxatp.space = XENMAPSPACE_grant_table;\r\nxatp.gpfn = xen_auto_xlat_grant_frames.pfn[i];\r\nrc = HYPERVISOR_memory_op(XENMEM_add_to_physmap, &xatp);\r\nif (rc != 0) {\r\npr_warn("grant table add_to_physmap failed, err=%d\n",\r\nrc);\r\nbreak;\r\n}\r\n} while (i-- > start_idx);\r\nreturn rc;\r\n}\r\nframes = kmalloc(nr_gframes * sizeof(unsigned long), GFP_ATOMIC);\r\nif (!frames)\r\nreturn -ENOMEM;\r\nsetup.dom = DOMID_SELF;\r\nsetup.nr_frames = nr_gframes;\r\nset_xen_guest_handle(setup.frame_list, frames);\r\nrc = HYPERVISOR_grant_table_op(GNTTABOP_setup_table, &setup, 1);\r\nif (rc == -ENOSYS) {\r\nkfree(frames);\r\nreturn -ENOSYS;\r\n}\r\nBUG_ON(rc || setup.status);\r\nrc = gnttab_interface->map_frames(frames, nr_gframes);\r\nkfree(frames);\r\nreturn rc;\r\n}\r\nstatic void gnttab_request_version(void)\r\n{\r\ngrant_table_version = 1;\r\ngrefs_per_grant_frame = XEN_PAGE_SIZE / sizeof(struct grant_entry_v1);\r\ngnttab_interface = &gnttab_v1_ops;\r\npr_info("Grant tables using version %d layout\n", grant_table_version);\r\n}\r\nstatic int gnttab_setup(void)\r\n{\r\nunsigned int max_nr_gframes;\r\nmax_nr_gframes = gnttab_max_grant_frames();\r\nif (max_nr_gframes < nr_grant_frames)\r\nreturn -ENOSYS;\r\nif (xen_feature(XENFEAT_auto_translated_physmap) && gnttab_shared.addr == NULL) {\r\ngnttab_shared.addr = xen_auto_xlat_grant_frames.vaddr;\r\nif (gnttab_shared.addr == NULL) {\r\npr_warn("gnttab share frames (addr=0x%08lx) is not mapped!\n",\r\n(unsigned long)xen_auto_xlat_grant_frames.vaddr);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nreturn gnttab_map(0, nr_grant_frames - 1);\r\n}\r\nint gnttab_resume(void)\r\n{\r\ngnttab_request_version();\r\nreturn gnttab_setup();\r\n}\r\nint gnttab_suspend(void)\r\n{\r\nif (!xen_feature(XENFEAT_auto_translated_physmap))\r\ngnttab_interface->unmap_frames();\r\nreturn 0;\r\n}\r\nstatic int gnttab_expand(unsigned int req_entries)\r\n{\r\nint rc;\r\nunsigned int cur, extra;\r\nBUG_ON(grefs_per_grant_frame == 0);\r\ncur = nr_grant_frames;\r\nextra = ((req_entries + (grefs_per_grant_frame-1)) /\r\ngrefs_per_grant_frame);\r\nif (cur + extra > gnttab_max_grant_frames()) {\r\npr_warn_ratelimited("xen/grant-table: max_grant_frames reached"\r\n" cur=%u extra=%u limit=%u"\r\n" gnttab_free_count=%u req_entries=%u\n",\r\ncur, extra, gnttab_max_grant_frames(),\r\ngnttab_free_count, req_entries);\r\nreturn -ENOSPC;\r\n}\r\nrc = gnttab_map(cur, cur + extra - 1);\r\nif (rc == 0)\r\nrc = grow_gnttab_list(extra);\r\nreturn rc;\r\n}\r\nint gnttab_init(void)\r\n{\r\nint i;\r\nunsigned long max_nr_grant_frames;\r\nunsigned int max_nr_glist_frames, nr_glist_frames;\r\nunsigned int nr_init_grefs;\r\nint ret;\r\ngnttab_request_version();\r\nmax_nr_grant_frames = gnttab_max_grant_frames();\r\nnr_grant_frames = 1;\r\nBUG_ON(grefs_per_grant_frame == 0);\r\nmax_nr_glist_frames = (max_nr_grant_frames *\r\ngrefs_per_grant_frame / RPP);\r\ngnttab_list = kmalloc(max_nr_glist_frames * sizeof(grant_ref_t *),\r\nGFP_KERNEL);\r\nif (gnttab_list == NULL)\r\nreturn -ENOMEM;\r\nnr_glist_frames = (nr_grant_frames * grefs_per_grant_frame + RPP - 1) / RPP;\r\nfor (i = 0; i < nr_glist_frames; i++) {\r\ngnttab_list[i] = (grant_ref_t *)__get_free_page(GFP_KERNEL);\r\nif (gnttab_list[i] == NULL) {\r\nret = -ENOMEM;\r\ngoto ini_nomem;\r\n}\r\n}\r\nret = arch_gnttab_init(max_nr_grant_frames);\r\nif (ret < 0)\r\ngoto ini_nomem;\r\nif (gnttab_setup() < 0) {\r\nret = -ENODEV;\r\ngoto ini_nomem;\r\n}\r\nnr_init_grefs = nr_grant_frames * grefs_per_grant_frame;\r\nfor (i = NR_RESERVED_ENTRIES; i < nr_init_grefs - 1; i++)\r\ngnttab_entry(i) = i + 1;\r\ngnttab_entry(nr_init_grefs - 1) = GNTTAB_LIST_END;\r\ngnttab_free_count = nr_init_grefs - NR_RESERVED_ENTRIES;\r\ngnttab_free_head = NR_RESERVED_ENTRIES;\r\nprintk("Grant table initialized\n");\r\nreturn 0;\r\nini_nomem:\r\nfor (i--; i >= 0; i--)\r\nfree_page((unsigned long)gnttab_list[i]);\r\nkfree(gnttab_list);\r\nreturn ret;\r\n}\r\nstatic int __gnttab_init(void)\r\n{\r\nif (!xen_domain())\r\nreturn -ENODEV;\r\nif (xen_hvm_domain() && !xen_pvh_domain())\r\nreturn 0;\r\nreturn gnttab_init();\r\n}
