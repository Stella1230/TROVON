static inline void ipip6_ecn_decapsulate(struct sk_buff *skb)\r\n{\r\nstruct ipv6hdr *inner_iph = ipipv6_hdr(skb);\r\nif (INET_ECN_is_ce(XFRM_MODE_SKB_CB(skb)->tos))\r\nIP6_ECN_set_ce(skb, inner_iph);\r\n}\r\nstatic int xfrm6_mode_tunnel_output(struct xfrm_state *x, struct sk_buff *skb)\r\n{\r\nstruct dst_entry *dst = skb_dst(skb);\r\nstruct ipv6hdr *top_iph;\r\nint dsfield;\r\nskb_set_inner_network_header(skb, skb_network_offset(skb));\r\nskb_set_inner_transport_header(skb, skb_transport_offset(skb));\r\nskb_set_network_header(skb, -x->props.header_len);\r\nskb->mac_header = skb->network_header +\r\noffsetof(struct ipv6hdr, nexthdr);\r\nskb->transport_header = skb->network_header + sizeof(*top_iph);\r\ntop_iph = ipv6_hdr(skb);\r\ntop_iph->version = 6;\r\nmemcpy(top_iph->flow_lbl, XFRM_MODE_SKB_CB(skb)->flow_lbl,\r\nsizeof(top_iph->flow_lbl));\r\ntop_iph->nexthdr = xfrm_af2proto(skb_dst(skb)->ops->family);\r\nif (x->props.extra_flags & XFRM_SA_XFLAG_DONT_ENCAP_DSCP)\r\ndsfield = 0;\r\nelse\r\ndsfield = XFRM_MODE_SKB_CB(skb)->tos;\r\ndsfield = INET_ECN_encapsulate(dsfield, XFRM_MODE_SKB_CB(skb)->tos);\r\nif (x->props.flags & XFRM_STATE_NOECN)\r\ndsfield &= ~INET_ECN_MASK;\r\nipv6_change_dsfield(top_iph, 0, dsfield);\r\ntop_iph->hop_limit = ip6_dst_hoplimit(dst->child);\r\ntop_iph->saddr = *(struct in6_addr *)&x->props.saddr;\r\ntop_iph->daddr = *(struct in6_addr *)&x->id.daddr;\r\nreturn 0;\r\n}\r\nstatic int xfrm6_mode_tunnel_input(struct xfrm_state *x, struct sk_buff *skb)\r\n{\r\nint err = -EINVAL;\r\nif (XFRM_MODE_SKB_CB(skb)->protocol != IPPROTO_IPV6)\r\ngoto out;\r\nif (!pskb_may_pull(skb, sizeof(struct ipv6hdr)))\r\ngoto out;\r\nerr = skb_unclone(skb, GFP_ATOMIC);\r\nif (err)\r\ngoto out;\r\nif (x->props.flags & XFRM_STATE_DECAP_DSCP)\r\nipv6_copy_dscp(ipv6_get_dsfield(ipv6_hdr(skb)),\r\nipipv6_hdr(skb));\r\nif (!(x->props.flags & XFRM_STATE_NOECN))\r\nipip6_ecn_decapsulate(skb);\r\nskb_reset_network_header(skb);\r\nskb_mac_header_rebuild(skb);\r\nerr = 0;\r\nout:\r\nreturn err;\r\n}\r\nstatic struct sk_buff *xfrm6_mode_tunnel_gso_segment(struct xfrm_state *x,\r\nstruct sk_buff *skb,\r\nnetdev_features_t features)\r\n{\r\n__skb_push(skb, skb->mac_len);\r\nreturn skb_mac_gso_segment(skb, features);\r\n}\r\nstatic void xfrm6_mode_tunnel_xmit(struct xfrm_state *x, struct sk_buff *skb)\r\n{\r\nstruct xfrm_offload *xo = xfrm_offload(skb);\r\nif (xo->flags & XFRM_GSO_SEGMENT) {\r\nskb->network_header = skb->network_header - x->props.header_len;\r\nskb->transport_header = skb->network_header + sizeof(struct ipv6hdr);\r\n}\r\nskb_reset_mac_len(skb);\r\npskb_pull(skb, skb->mac_len + x->props.header_len);\r\n}\r\nstatic int __init xfrm6_mode_tunnel_init(void)\r\n{\r\nreturn xfrm_register_mode(&xfrm6_tunnel_mode, AF_INET6);\r\n}\r\nstatic void __exit xfrm6_mode_tunnel_exit(void)\r\n{\r\nint err;\r\nerr = xfrm_unregister_mode(&xfrm6_tunnel_mode, AF_INET6);\r\nBUG_ON(err);\r\n}
