void spum_dump_msg_hdr(u8 *buf, unsigned int buf_len)\r\n{\r\nu8 *ptr = buf;\r\nstruct SPUHEADER *spuh = (struct SPUHEADER *)buf;\r\nunsigned int hash_key_len = 0;\r\nunsigned int hash_state_len = 0;\r\nunsigned int cipher_key_len = 0;\r\nunsigned int iv_len;\r\nu32 pflags;\r\nu32 cflags;\r\nu32 ecf;\r\nu32 cipher_alg;\r\nu32 cipher_mode;\r\nu32 cipher_type;\r\nu32 hash_alg;\r\nu32 hash_mode;\r\nu32 hash_type;\r\nu32 sctx_size;\r\nu32 sctx_pl_len;\r\npacket_log("\n");\r\npacket_log("SPU Message header %p len: %u\n", buf, buf_len);\r\npacket_log(" MH 0x%08x\n", be32_to_cpu(*((u32 *)ptr)));\r\nif (spuh->mh.flags & MH_SCTX_PRES)\r\npacket_log(" SCTX present\n");\r\nif (spuh->mh.flags & MH_BDESC_PRES)\r\npacket_log(" BDESC present\n");\r\nif (spuh->mh.flags & MH_MFM_PRES)\r\npacket_log(" MFM present\n");\r\nif (spuh->mh.flags & MH_BD_PRES)\r\npacket_log(" BD present\n");\r\nif (spuh->mh.flags & MH_HASH_PRES)\r\npacket_log(" HASH present\n");\r\nif (spuh->mh.flags & MH_SUPDT_PRES)\r\npacket_log(" SUPDT present\n");\r\npacket_log(" Opcode 0x%02x\n", spuh->mh.op_code);\r\nptr += sizeof(spuh->mh) + sizeof(spuh->emh);\r\nif (spuh->mh.flags & MH_SCTX_PRES) {\r\npflags = be32_to_cpu(spuh->sa.proto_flags);\r\npacket_log(" SCTX[0] 0x%08x\n", pflags);\r\nsctx_size = pflags & SCTX_SIZE;\r\npacket_log(" Size %u words\n", sctx_size);\r\ncflags = be32_to_cpu(spuh->sa.cipher_flags);\r\npacket_log(" SCTX[1] 0x%08x\n", cflags);\r\npacket_log(" Inbound:%lu (1:decrypt/vrfy 0:encrypt/auth)\n",\r\n(cflags & CIPHER_INBOUND) >> CIPHER_INBOUND_SHIFT);\r\npacket_log(" Order:%lu (1:AuthFirst 0:EncFirst)\n",\r\n(cflags & CIPHER_ORDER) >> CIPHER_ORDER_SHIFT);\r\npacket_log(" ICV_IS_512:%lx\n",\r\n(cflags & ICV_IS_512) >> ICV_IS_512_SHIFT);\r\ncipher_alg = (cflags & CIPHER_ALG) >> CIPHER_ALG_SHIFT;\r\ncipher_mode = (cflags & CIPHER_MODE) >> CIPHER_MODE_SHIFT;\r\ncipher_type = (cflags & CIPHER_TYPE) >> CIPHER_TYPE_SHIFT;\r\npacket_log(" Crypto Alg:%u Mode:%u Type:%u\n",\r\ncipher_alg, cipher_mode, cipher_type);\r\nhash_alg = (cflags & HASH_ALG) >> HASH_ALG_SHIFT;\r\nhash_mode = (cflags & HASH_MODE) >> HASH_MODE_SHIFT;\r\nhash_type = (cflags & HASH_TYPE) >> HASH_TYPE_SHIFT;\r\npacket_log(" Hash Alg:%x Mode:%x Type:%x\n",\r\nhash_alg, hash_mode, hash_type);\r\npacket_log(" UPDT_Offset:%u\n", cflags & UPDT_OFST);\r\necf = be32_to_cpu(spuh->sa.ecf);\r\npacket_log(" SCTX[2] 0x%08x\n", ecf);\r\npacket_log(" WriteICV:%lu CheckICV:%lu ICV_SIZE:%u ",\r\n(ecf & INSERT_ICV) >> INSERT_ICV_SHIFT,\r\n(ecf & CHECK_ICV) >> CHECK_ICV_SHIFT,\r\n(ecf & ICV_SIZE) >> ICV_SIZE_SHIFT);\r\npacket_log("BD_SUPPRESS:%lu\n",\r\n(ecf & BD_SUPPRESS) >> BD_SUPPRESS_SHIFT);\r\npacket_log(" SCTX_IV:%lu ExplicitIV:%lu GenIV:%lu ",\r\n(ecf & SCTX_IV) >> SCTX_IV_SHIFT,\r\n(ecf & EXPLICIT_IV) >> EXPLICIT_IV_SHIFT,\r\n(ecf & GEN_IV) >> GEN_IV_SHIFT);\r\npacket_log("IV_OV_OFST:%lu EXP_IV_SIZE:%u\n",\r\n(ecf & IV_OFFSET) >> IV_OFFSET_SHIFT,\r\necf & EXP_IV_SIZE);\r\nptr += sizeof(struct SCTX);\r\nif (hash_alg && hash_mode) {\r\nchar *name = "NONE";\r\nswitch (hash_alg) {\r\ncase HASH_ALG_MD5:\r\nhash_key_len = 16;\r\nname = "MD5";\r\nbreak;\r\ncase HASH_ALG_SHA1:\r\nhash_key_len = 20;\r\nname = "SHA1";\r\nbreak;\r\ncase HASH_ALG_SHA224:\r\nhash_key_len = 28;\r\nname = "SHA224";\r\nbreak;\r\ncase HASH_ALG_SHA256:\r\nhash_key_len = 32;\r\nname = "SHA256";\r\nbreak;\r\ncase HASH_ALG_SHA384:\r\nhash_key_len = 48;\r\nname = "SHA384";\r\nbreak;\r\ncase HASH_ALG_SHA512:\r\nhash_key_len = 64;\r\nname = "SHA512";\r\nbreak;\r\ncase HASH_ALG_AES:\r\nhash_key_len = 0;\r\nname = "AES";\r\nbreak;\r\ncase HASH_ALG_NONE:\r\nbreak;\r\n}\r\npacket_log(" Auth Key Type:%s Length:%u Bytes\n",\r\nname, hash_key_len);\r\npacket_dump(" KEY: ", ptr, hash_key_len);\r\nptr += hash_key_len;\r\n} else if ((hash_alg == HASH_ALG_AES) &&\r\n(hash_mode == HASH_MODE_XCBC)) {\r\nchar *name = "NONE";\r\nswitch (cipher_type) {\r\ncase CIPHER_TYPE_AES128:\r\nhash_key_len = 16;\r\nname = "AES128-XCBC";\r\nbreak;\r\ncase CIPHER_TYPE_AES192:\r\nhash_key_len = 24;\r\nname = "AES192-XCBC";\r\nbreak;\r\ncase CIPHER_TYPE_AES256:\r\nhash_key_len = 32;\r\nname = "AES256-XCBC";\r\nbreak;\r\n}\r\npacket_log(" Auth Key Type:%s Length:%u Bytes\n",\r\nname, hash_key_len);\r\npacket_dump(" KEY: ", ptr, hash_key_len);\r\nptr += hash_key_len;\r\n}\r\nif (hash_alg && (hash_mode == HASH_MODE_NONE) &&\r\n(hash_type == HASH_TYPE_UPDT)) {\r\nchar *name = "NONE";\r\nswitch (hash_alg) {\r\ncase HASH_ALG_MD5:\r\nhash_state_len = 16;\r\nname = "MD5";\r\nbreak;\r\ncase HASH_ALG_SHA1:\r\nhash_state_len = 20;\r\nname = "SHA1";\r\nbreak;\r\ncase HASH_ALG_SHA224:\r\nhash_state_len = 32;\r\nname = "SHA224";\r\nbreak;\r\ncase HASH_ALG_SHA256:\r\nhash_state_len = 32;\r\nname = "SHA256";\r\nbreak;\r\ncase HASH_ALG_SHA384:\r\nhash_state_len = 48;\r\nname = "SHA384";\r\nbreak;\r\ncase HASH_ALG_SHA512:\r\nhash_state_len = 64;\r\nname = "SHA512";\r\nbreak;\r\ncase HASH_ALG_AES:\r\nhash_state_len = 0;\r\nname = "AES";\r\nbreak;\r\ncase HASH_ALG_NONE:\r\nbreak;\r\n}\r\npacket_log(" Auth State Type:%s Length:%u Bytes\n",\r\nname, hash_state_len);\r\npacket_dump(" State: ", ptr, hash_state_len);\r\nptr += hash_state_len;\r\n}\r\nif (cipher_alg) {\r\nchar *name = "NONE";\r\nswitch (cipher_alg) {\r\ncase CIPHER_ALG_DES:\r\ncipher_key_len = 8;\r\nname = "DES";\r\nbreak;\r\ncase CIPHER_ALG_3DES:\r\ncipher_key_len = 24;\r\nname = "3DES";\r\nbreak;\r\ncase CIPHER_ALG_RC4:\r\ncipher_key_len = 260;\r\nname = "ARC4";\r\nbreak;\r\ncase CIPHER_ALG_AES:\r\nswitch (cipher_type) {\r\ncase CIPHER_TYPE_AES128:\r\ncipher_key_len = 16;\r\nname = "AES128";\r\nbreak;\r\ncase CIPHER_TYPE_AES192:\r\ncipher_key_len = 24;\r\nname = "AES192";\r\nbreak;\r\ncase CIPHER_TYPE_AES256:\r\ncipher_key_len = 32;\r\nname = "AES256";\r\nbreak;\r\n}\r\nbreak;\r\ncase CIPHER_ALG_NONE:\r\nbreak;\r\n}\r\npacket_log(" Cipher Key Type:%s Length:%u Bytes\n",\r\nname, cipher_key_len);\r\nif (cipher_mode == CIPHER_MODE_XTS) {\r\npacket_dump(" KEY2: ", ptr, cipher_key_len);\r\nptr += cipher_key_len;\r\npacket_dump(" KEY1: ", ptr, cipher_key_len);\r\nptr += cipher_key_len;\r\ncipher_key_len *= 2;\r\n} else {\r\npacket_dump(" KEY: ", ptr, cipher_key_len);\r\nptr += cipher_key_len;\r\n}\r\nif (ecf & SCTX_IV) {\r\nsctx_pl_len = sctx_size * sizeof(u32) -\r\nsizeof(struct SCTX);\r\niv_len = sctx_pl_len -\r\n(hash_key_len + hash_state_len +\r\ncipher_key_len);\r\npacket_log(" IV Length:%u Bytes\n", iv_len);\r\npacket_dump(" IV: ", ptr, iv_len);\r\nptr += iv_len;\r\n}\r\n}\r\n}\r\nif (spuh->mh.flags & MH_BDESC_PRES) {\r\n#ifdef DEBUG\r\nstruct BDESC_HEADER *bdesc = (struct BDESC_HEADER *)ptr;\r\n#endif\r\npacket_log(" BDESC[0] 0x%08x\n", be32_to_cpu(*((u32 *)ptr)));\r\npacket_log(" OffsetMAC:%u LengthMAC:%u\n",\r\nbe16_to_cpu(bdesc->offset_mac),\r\nbe16_to_cpu(bdesc->length_mac));\r\nptr += sizeof(u32);\r\npacket_log(" BDESC[1] 0x%08x\n", be32_to_cpu(*((u32 *)ptr)));\r\npacket_log(" OffsetCrypto:%u LengthCrypto:%u\n",\r\nbe16_to_cpu(bdesc->offset_crypto),\r\nbe16_to_cpu(bdesc->length_crypto));\r\nptr += sizeof(u32);\r\npacket_log(" BDESC[2] 0x%08x\n", be32_to_cpu(*((u32 *)ptr)));\r\npacket_log(" OffsetICV:%u OffsetIV:%u\n",\r\nbe16_to_cpu(bdesc->offset_icv),\r\nbe16_to_cpu(bdesc->offset_iv));\r\nptr += sizeof(u32);\r\n}\r\nif (spuh->mh.flags & MH_BD_PRES) {\r\n#ifdef DEBUG\r\nstruct BD_HEADER *bd = (struct BD_HEADER *)ptr;\r\n#endif\r\npacket_log(" BD[0] 0x%08x\n", be32_to_cpu(*((u32 *)ptr)));\r\npacket_log(" Size:%ubytes PrevLength:%u\n",\r\nbe16_to_cpu(bd->size), be16_to_cpu(bd->prev_length));\r\nptr += 4;\r\n}\r\nif (buf + buf_len != ptr) {\r\npacket_log(" Packet parsed incorrectly. ");\r\npacket_log("buf:%p buf_len:%u buf+buf_len:%p ptr:%p\n",\r\nbuf, buf_len, buf + buf_len, ptr);\r\n}\r\npacket_log("\n");\r\n}\r\nu32 spum_ns2_ctx_max_payload(enum spu_cipher_alg cipher_alg,\r\nenum spu_cipher_mode cipher_mode,\r\nunsigned int blocksize)\r\n{\r\nu32 max_payload = SPUM_NS2_MAX_PAYLOAD;\r\nu32 excess;\r\nif (cipher_mode == CIPHER_MODE_XTS)\r\nmax_payload -= SPU_XTS_TWEAK_SIZE;\r\nexcess = max_payload % blocksize;\r\nreturn max_payload - excess;\r\n}\r\nu32 spum_nsp_ctx_max_payload(enum spu_cipher_alg cipher_alg,\r\nenum spu_cipher_mode cipher_mode,\r\nunsigned int blocksize)\r\n{\r\nu32 max_payload = SPUM_NSP_MAX_PAYLOAD;\r\nu32 excess;\r\nif (cipher_mode == CIPHER_MODE_XTS)\r\nmax_payload -= SPU_XTS_TWEAK_SIZE;\r\nexcess = max_payload % blocksize;\r\nreturn max_payload - excess;\r\n}\r\nu32 spum_payload_length(u8 *spu_hdr)\r\n{\r\nstruct BD_HEADER *bd;\r\nu32 pl_len;\r\nbd = (struct BD_HEADER *)(spu_hdr + 8);\r\npl_len = be16_to_cpu(bd->size);\r\nreturn pl_len;\r\n}\r\nu16 spum_response_hdr_len(u16 auth_key_len, u16 enc_key_len, bool is_hash)\r\n{\r\nif (is_hash)\r\nreturn SPU_HASH_RESP_HDR_LEN;\r\nelse\r\nreturn SPU_RESP_HDR_LEN;\r\n}\r\nu16 spum_hash_pad_len(enum hash_alg hash_alg, enum hash_mode hash_mode,\r\nu32 chunksize, u16 hash_block_size)\r\n{\r\nunsigned int length_len;\r\nunsigned int used_space_last_block;\r\nint hash_pad_len;\r\nif ((hash_alg == HASH_ALG_AES) && (hash_mode == HASH_MODE_XCBC)) {\r\nused_space_last_block = chunksize % hash_block_size;\r\nhash_pad_len = hash_block_size - used_space_last_block;\r\nif (hash_pad_len >= hash_block_size)\r\nhash_pad_len -= hash_block_size;\r\nreturn hash_pad_len;\r\n}\r\nused_space_last_block = chunksize % hash_block_size + 1;\r\nif ((hash_alg == HASH_ALG_SHA384) || (hash_alg == HASH_ALG_SHA512))\r\nlength_len = 2 * sizeof(u64);\r\nelse\r\nlength_len = sizeof(u64);\r\nused_space_last_block += length_len;\r\nhash_pad_len = hash_block_size - used_space_last_block;\r\nif (hash_pad_len < 0)\r\nhash_pad_len += hash_block_size;\r\nhash_pad_len += 1 + length_len;\r\nreturn hash_pad_len;\r\n}\r\nu32 spum_gcm_ccm_pad_len(enum spu_cipher_mode cipher_mode,\r\nunsigned int data_size)\r\n{\r\nu32 pad_len = 0;\r\nu32 m1 = SPU_GCM_CCM_ALIGN - 1;\r\nif ((cipher_mode == CIPHER_MODE_GCM) ||\r\n(cipher_mode == CIPHER_MODE_CCM))\r\npad_len = ((data_size + m1) & ~m1) - data_size;\r\nreturn pad_len;\r\n}\r\nu32 spum_assoc_resp_len(enum spu_cipher_mode cipher_mode,\r\nunsigned int assoc_len, unsigned int iv_len,\r\nbool is_encrypt)\r\n{\r\nu32 buflen = 0;\r\nu32 pad;\r\nif (assoc_len)\r\nbuflen = assoc_len;\r\nif (cipher_mode == CIPHER_MODE_GCM) {\r\npad = spum_gcm_ccm_pad_len(cipher_mode, buflen);\r\nbuflen += pad;\r\n}\r\nif (cipher_mode == CIPHER_MODE_CCM) {\r\npad = spum_gcm_ccm_pad_len(cipher_mode, buflen + 2);\r\nbuflen += pad;\r\n}\r\nreturn buflen;\r\n}\r\nu8 spum_aead_ivlen(enum spu_cipher_mode cipher_mode, u16 iv_len)\r\n{\r\nreturn 0;\r\n}\r\nenum hash_type spum_hash_type(u32 src_sent)\r\n{\r\nreturn src_sent ? HASH_TYPE_UPDT : HASH_TYPE_INIT;\r\n}\r\nu32 spum_digest_size(u32 alg_digest_size, enum hash_alg alg,\r\nenum hash_type htype)\r\n{\r\nu32 digestsize = alg_digest_size;\r\nif ((htype == HASH_TYPE_INIT) || (htype == HASH_TYPE_UPDT)) {\r\nif (alg == HASH_ALG_SHA224)\r\ndigestsize = SHA256_DIGEST_SIZE;\r\nelse if (alg == HASH_ALG_SHA384)\r\ndigestsize = SHA512_DIGEST_SIZE;\r\n}\r\nreturn digestsize;\r\n}\r\nu32 spum_create_request(u8 *spu_hdr,\r\nstruct spu_request_opts *req_opts,\r\nstruct spu_cipher_parms *cipher_parms,\r\nstruct spu_hash_parms *hash_parms,\r\nstruct spu_aead_parms *aead_parms,\r\nunsigned int data_size)\r\n{\r\nstruct SPUHEADER *spuh;\r\nstruct BDESC_HEADER *bdesc;\r\nstruct BD_HEADER *bd;\r\nu8 *ptr;\r\nu32 protocol_bits = 0;\r\nu32 cipher_bits = 0;\r\nu32 ecf_bits = 0;\r\nu8 sctx_words = 0;\r\nunsigned int buf_len = 0;\r\nunsigned int cipher_len = hash_parms->prebuf_len + data_size +\r\nhash_parms->pad_len;\r\nunsigned int cipher_offset = aead_parms->assoc_size +\r\naead_parms->iv_len + aead_parms->aad_pad_len;\r\nunsigned int real_db_size = spu_real_db_size(aead_parms->assoc_size,\r\naead_parms->iv_len,\r\nhash_parms->prebuf_len,\r\ndata_size,\r\naead_parms->aad_pad_len,\r\naead_parms->data_pad_len,\r\nhash_parms->pad_len);\r\nunsigned int auth_offset = 0;\r\nunsigned int offset_iv = 0;\r\nunsigned int auth_len;\r\nauth_len = real_db_size;\r\nif (req_opts->is_aead && req_opts->is_inbound)\r\ncipher_len -= hash_parms->digestsize;\r\nif (req_opts->is_aead && req_opts->is_inbound)\r\nauth_len -= hash_parms->digestsize;\r\nif ((hash_parms->alg == HASH_ALG_AES) &&\r\n(hash_parms->mode == HASH_MODE_XCBC)) {\r\nauth_len -= hash_parms->pad_len;\r\ncipher_len -= hash_parms->pad_len;\r\n}\r\nflow_log("%s()\n", __func__);\r\nflow_log(" in:%u authFirst:%u\n",\r\nreq_opts->is_inbound, req_opts->auth_first);\r\nflow_log(" %s. cipher alg:%u mode:%u type %u\n",\r\nspu_alg_name(cipher_parms->alg, cipher_parms->mode),\r\ncipher_parms->alg, cipher_parms->mode, cipher_parms->type);\r\nflow_log(" key: %d\n", cipher_parms->key_len);\r\nflow_dump(" key: ", cipher_parms->key_buf, cipher_parms->key_len);\r\nflow_log(" iv: %d\n", cipher_parms->iv_len);\r\nflow_dump(" iv: ", cipher_parms->iv_buf, cipher_parms->iv_len);\r\nflow_log(" auth alg:%u mode:%u type %u\n",\r\nhash_parms->alg, hash_parms->mode, hash_parms->type);\r\nflow_log(" digestsize: %u\n", hash_parms->digestsize);\r\nflow_log(" authkey: %d\n", hash_parms->key_len);\r\nflow_dump(" authkey: ", hash_parms->key_buf, hash_parms->key_len);\r\nflow_log(" assoc_size:%u\n", aead_parms->assoc_size);\r\nflow_log(" prebuf_len:%u\n", hash_parms->prebuf_len);\r\nflow_log(" data_size:%u\n", data_size);\r\nflow_log(" hash_pad_len:%u\n", hash_parms->pad_len);\r\nflow_log(" real_db_size:%u\n", real_db_size);\r\nflow_log(" auth_offset:%u auth_len:%u cipher_offset:%u cipher_len:%u\n",\r\nauth_offset, auth_len, cipher_offset, cipher_len);\r\nflow_log(" aead_iv: %u\n", aead_parms->iv_len);\r\nptr = spu_hdr;\r\nmemset(ptr, 0, sizeof(struct SPUHEADER));\r\nspuh = (struct SPUHEADER *)ptr;\r\nptr += sizeof(struct SPUHEADER);\r\nbuf_len += sizeof(struct SPUHEADER);\r\nspuh->mh.op_code = SPU_CRYPTO_OPERATION_GENERIC;\r\nspuh->mh.flags |= (MH_SCTX_PRES | MH_BDESC_PRES | MH_BD_PRES);\r\nsctx_words = 3;\r\nif (req_opts->is_inbound)\r\ncipher_bits |= CIPHER_INBOUND;\r\nif (req_opts->auth_first)\r\ncipher_bits |= CIPHER_ORDER;\r\ncipher_bits |= cipher_parms->alg << CIPHER_ALG_SHIFT;\r\ncipher_bits |= cipher_parms->mode << CIPHER_MODE_SHIFT;\r\ncipher_bits |= cipher_parms->type << CIPHER_TYPE_SHIFT;\r\ncipher_bits |= hash_parms->alg << HASH_ALG_SHIFT;\r\ncipher_bits |= hash_parms->mode << HASH_MODE_SHIFT;\r\ncipher_bits |= hash_parms->type << HASH_TYPE_SHIFT;\r\nif (hash_parms->alg) {\r\nif (hash_parms->key_len) {\r\nmemcpy(ptr, hash_parms->key_buf, hash_parms->key_len);\r\nptr += hash_parms->key_len;\r\nbuf_len += hash_parms->key_len;\r\nsctx_words += hash_parms->key_len / 4;\r\n}\r\nif ((cipher_parms->mode == CIPHER_MODE_GCM) ||\r\n(cipher_parms->mode == CIPHER_MODE_CCM))\r\noffset_iv = aead_parms->assoc_size;\r\nif (!req_opts->is_inbound) {\r\nif ((cipher_parms->mode == CIPHER_MODE_GCM) ||\r\n(cipher_parms->mode == CIPHER_MODE_CCM))\r\necf_bits |= 1 << INSERT_ICV_SHIFT;\r\n} else {\r\necf_bits |= CHECK_ICV;\r\n}\r\nif (hash_parms->digestsize == 64)\r\ncipher_bits |= ICV_IS_512;\r\nelse\r\necf_bits |=\r\n(hash_parms->digestsize / 4) << ICV_SIZE_SHIFT;\r\n}\r\nif (req_opts->bd_suppress)\r\necf_bits |= BD_SUPPRESS;\r\nif (cipher_parms->alg) {\r\nif (cipher_parms->key_len) {\r\nmemcpy(ptr, cipher_parms->key_buf,\r\ncipher_parms->key_len);\r\nptr += cipher_parms->key_len;\r\nbuf_len += cipher_parms->key_len;\r\nsctx_words += cipher_parms->key_len / 4;\r\n}\r\nif (cipher_parms->iv_buf && cipher_parms->iv_len) {\r\necf_bits |= SCTX_IV;\r\nmemcpy(ptr, cipher_parms->iv_buf, cipher_parms->iv_len);\r\nptr += cipher_parms->iv_len;\r\nbuf_len += cipher_parms->iv_len;\r\nsctx_words += cipher_parms->iv_len / 4;\r\n}\r\n}\r\nif (req_opts->is_rfc4543) {\r\nif (req_opts->is_inbound)\r\ndata_size -= hash_parms->digestsize;\r\noffset_iv = aead_parms->assoc_size + data_size;\r\ncipher_len = 0;\r\ncipher_offset = offset_iv;\r\nauth_len = cipher_offset + aead_parms->data_pad_len;\r\n}\r\nprotocol_bits |= sctx_words;\r\nspuh->sa.proto_flags = cpu_to_be32(protocol_bits);\r\nspuh->sa.cipher_flags = cpu_to_be32(cipher_bits);\r\nspuh->sa.ecf = cpu_to_be32(ecf_bits);\r\nbdesc = (struct BDESC_HEADER *)ptr;\r\nbdesc->offset_mac = cpu_to_be16(auth_offset);\r\nbdesc->length_mac = cpu_to_be16(auth_len);\r\nbdesc->offset_crypto = cpu_to_be16(cipher_offset);\r\nbdesc->length_crypto = cpu_to_be16(cipher_len);\r\nif (cipher_parms->mode == CIPHER_MODE_CCM)\r\nauth_len += spum_wordalign_padlen(auth_len);\r\nbdesc->offset_icv = cpu_to_be16(auth_len);\r\nbdesc->offset_iv = cpu_to_be16(offset_iv);\r\nptr += sizeof(struct BDESC_HEADER);\r\nbuf_len += sizeof(struct BDESC_HEADER);\r\nbd = (struct BD_HEADER *)ptr;\r\nbd->size = cpu_to_be16(real_db_size);\r\nbd->prev_length = 0;\r\nptr += sizeof(struct BD_HEADER);\r\nbuf_len += sizeof(struct BD_HEADER);\r\npacket_dump(" SPU request header: ", spu_hdr, buf_len);\r\nreturn buf_len;\r\n}\r\nu16 spum_cipher_req_init(u8 *spu_hdr, struct spu_cipher_parms *cipher_parms)\r\n{\r\nstruct SPUHEADER *spuh;\r\nu32 protocol_bits = 0;\r\nu32 cipher_bits = 0;\r\nu32 ecf_bits = 0;\r\nu8 sctx_words = 0;\r\nu8 *ptr = spu_hdr;\r\nflow_log("%s()\n", __func__);\r\nflow_log(" cipher alg:%u mode:%u type %u\n", cipher_parms->alg,\r\ncipher_parms->mode, cipher_parms->type);\r\nflow_log(" cipher_iv_len: %u\n", cipher_parms->iv_len);\r\nflow_log(" key: %d\n", cipher_parms->key_len);\r\nflow_dump(" key: ", cipher_parms->key_buf, cipher_parms->key_len);\r\nmemset(spu_hdr, 0, sizeof(struct SPUHEADER));\r\nptr += sizeof(struct SPUHEADER);\r\nspuh = (struct SPUHEADER *)spu_hdr;\r\nspuh->mh.op_code = SPU_CRYPTO_OPERATION_GENERIC;\r\nspuh->mh.flags |= (MH_SCTX_PRES | MH_BDESC_PRES | MH_BD_PRES);\r\nsctx_words = 3;\r\nif (cipher_parms->alg) {\r\nif (cipher_parms->key_len) {\r\nptr += cipher_parms->key_len;\r\nsctx_words += cipher_parms->key_len / 4;\r\n}\r\nif (cipher_parms->iv_len) {\r\necf_bits |= SCTX_IV;\r\nptr += cipher_parms->iv_len;\r\nsctx_words += cipher_parms->iv_len / 4;\r\n}\r\n}\r\ncipher_bits |= cipher_parms->alg << CIPHER_ALG_SHIFT;\r\ncipher_bits |= cipher_parms->mode << CIPHER_MODE_SHIFT;\r\ncipher_bits |= cipher_parms->type << CIPHER_TYPE_SHIFT;\r\nif (cipher_parms->alg && cipher_parms->key_len)\r\nmemcpy(spuh + 1, cipher_parms->key_buf, cipher_parms->key_len);\r\nprotocol_bits |= sctx_words;\r\nspuh->sa.proto_flags = cpu_to_be32(protocol_bits);\r\nspuh->sa.cipher_flags = cpu_to_be32(cipher_bits);\r\nspuh->sa.ecf = cpu_to_be32(ecf_bits);\r\npacket_dump(" SPU request header: ", spu_hdr,\r\nsizeof(struct SPUHEADER));\r\nreturn sizeof(struct SPUHEADER) + cipher_parms->key_len +\r\ncipher_parms->iv_len + sizeof(struct BDESC_HEADER) +\r\nsizeof(struct BD_HEADER);\r\n}\r\nvoid spum_cipher_req_finish(u8 *spu_hdr,\r\nu16 spu_req_hdr_len,\r\nunsigned int is_inbound,\r\nstruct spu_cipher_parms *cipher_parms,\r\nbool update_key,\r\nunsigned int data_size)\r\n{\r\nstruct SPUHEADER *spuh;\r\nstruct BDESC_HEADER *bdesc;\r\nstruct BD_HEADER *bd;\r\nu8 *bdesc_ptr = spu_hdr + spu_req_hdr_len -\r\n(sizeof(struct BD_HEADER) + sizeof(struct BDESC_HEADER));\r\nu32 cipher_bits;\r\nflow_log("%s()\n", __func__);\r\nflow_log(" in: %u\n", is_inbound);\r\nflow_log(" cipher alg: %u, cipher_type: %u\n", cipher_parms->alg,\r\ncipher_parms->type);\r\nif (update_key) {\r\nflow_log(" cipher key len: %u\n", cipher_parms->key_len);\r\nflow_dump(" key: ", cipher_parms->key_buf,\r\ncipher_parms->key_len);\r\n}\r\nif (cipher_parms->mode == CIPHER_MODE_XTS)\r\nmemset(cipher_parms->iv_buf, 0, cipher_parms->iv_len);\r\nflow_log(" iv len: %d\n", cipher_parms->iv_len);\r\nflow_dump(" iv: ", cipher_parms->iv_buf, cipher_parms->iv_len);\r\nflow_log(" data_size: %u\n", data_size);\r\nspuh = (struct SPUHEADER *)spu_hdr;\r\ncipher_bits = be32_to_cpu(spuh->sa.cipher_flags);\r\nif (is_inbound)\r\ncipher_bits |= CIPHER_INBOUND;\r\nelse\r\ncipher_bits &= ~CIPHER_INBOUND;\r\nif (update_key) {\r\nspuh->sa.cipher_flags |=\r\ncipher_parms->type << CIPHER_TYPE_SHIFT;\r\nmemcpy(spuh + 1, cipher_parms->key_buf, cipher_parms->key_len);\r\n}\r\nif (cipher_parms->alg && cipher_parms->iv_buf && cipher_parms->iv_len)\r\nmemcpy(bdesc_ptr - cipher_parms->iv_len, cipher_parms->iv_buf,\r\ncipher_parms->iv_len);\r\nspuh->sa.cipher_flags = cpu_to_be32(cipher_bits);\r\nbdesc = (struct BDESC_HEADER *)bdesc_ptr;\r\nbdesc->offset_mac = 0;\r\nbdesc->length_mac = 0;\r\nbdesc->offset_crypto = 0;\r\nif (cipher_parms->mode == CIPHER_MODE_XTS)\r\nbdesc->length_crypto = cpu_to_be16(data_size +\r\nSPU_XTS_TWEAK_SIZE);\r\nelse\r\nbdesc->length_crypto = cpu_to_be16(data_size);\r\nbdesc->offset_icv = 0;\r\nbdesc->offset_iv = 0;\r\nbd = (struct BD_HEADER *)(bdesc_ptr + sizeof(struct BDESC_HEADER));\r\nbd->size = cpu_to_be16(data_size);\r\nif (cipher_parms->mode == CIPHER_MODE_XTS)\r\nbd->size = cpu_to_be16(data_size + SPU_XTS_TWEAK_SIZE);\r\nelse\r\nbd->size = cpu_to_be16(data_size);\r\nbd->prev_length = 0;\r\npacket_dump(" SPU request header: ", spu_hdr, spu_req_hdr_len);\r\n}\r\nvoid spum_request_pad(u8 *pad_start,\r\nu32 gcm_ccm_padding,\r\nu32 hash_pad_len,\r\nenum hash_alg auth_alg,\r\nenum hash_mode auth_mode,\r\nunsigned int total_sent, u32 status_padding)\r\n{\r\nu8 *ptr = pad_start;\r\nif (gcm_ccm_padding > 0) {\r\nflow_log(" GCM: padding to 16 byte alignment: %u bytes\n",\r\ngcm_ccm_padding);\r\nmemset(ptr, 0, gcm_ccm_padding);\r\nptr += gcm_ccm_padding;\r\n}\r\nif (hash_pad_len > 0) {\r\nmemset(ptr, 0, hash_pad_len);\r\nif ((auth_alg == HASH_ALG_AES) &&\r\n(auth_mode == HASH_MODE_XCBC)) {\r\nptr += hash_pad_len;\r\n} else {\r\n*ptr = 0x80;\r\nptr += (hash_pad_len - sizeof(u64));\r\nif (auth_alg == HASH_ALG_MD5)\r\n*(u64 *)ptr = cpu_to_le64((u64)total_sent * 8);\r\nelse\r\n*(u64 *)ptr = cpu_to_be64((u64)total_sent * 8);\r\nptr += sizeof(u64);\r\n}\r\n}\r\nif (status_padding > 0) {\r\nflow_log(" STAT: padding to 4 byte alignment: %u bytes\n",\r\nstatus_padding);\r\nmemset(ptr, 0, status_padding);\r\nptr += status_padding;\r\n}\r\n}\r\nu8 spum_xts_tweak_in_payload(void)\r\n{\r\nreturn 1;\r\n}\r\nu8 spum_tx_status_len(void)\r\n{\r\nreturn SPU_TX_STATUS_LEN;\r\n}\r\nu8 spum_rx_status_len(void)\r\n{\r\nreturn SPU_RX_STATUS_LEN;\r\n}\r\nint spum_status_process(u8 *statp)\r\n{\r\nu32 status;\r\nstatus = __be32_to_cpu(*(__be32 *)statp);\r\nflow_log("SPU response STATUS %#08x\n", status);\r\nif (status & SPU_STATUS_ERROR_FLAG) {\r\npr_err("%s() Warning: Error result from SPU: %#08x\n",\r\n__func__, status);\r\nif (status & SPU_STATUS_INVALID_ICV)\r\nreturn SPU_INVALID_ICV;\r\nreturn -EBADMSG;\r\n}\r\nreturn 0;\r\n}\r\nvoid spum_ccm_update_iv(unsigned int digestsize,\r\nstruct spu_cipher_parms *cipher_parms,\r\nunsigned int assoclen,\r\nunsigned int chunksize,\r\nbool is_encrypt,\r\nbool is_esp)\r\n{\r\nu8 L;\r\nu8 mprime;\r\nu8 adata;\r\nif (cipher_parms->iv_len != CCM_AES_IV_SIZE) {\r\npr_err("%s(): Invalid IV len %d for CCM mode, should be %d\n",\r\n__func__, cipher_parms->iv_len, CCM_AES_IV_SIZE);\r\nreturn;\r\n}\r\nif (is_esp) {\r\nL = CCM_ESP_L_VALUE;\r\n} else {\r\nL = ((cipher_parms->iv_buf[0] & CCM_B0_L_PRIME) >>\r\nCCM_B0_L_PRIME_SHIFT) + 1;\r\n}\r\nmprime = (digestsize - 2) >> 1;\r\nadata = (assoclen > 0);\r\ncipher_parms->iv_buf[0] = (adata << CCM_B0_ADATA_SHIFT) |\r\n(mprime << CCM_B0_M_PRIME_SHIFT) |\r\n((L - 1) << CCM_B0_L_PRIME_SHIFT);\r\nif (!is_encrypt)\r\nchunksize -= digestsize;\r\nformat_value_ccm(chunksize, &cipher_parms->iv_buf[15 - L + 1], L);\r\n}\r\nu32 spum_wordalign_padlen(u32 data_size)\r\n{\r\nreturn ((data_size + 3) & ~3) - data_size;\r\n}
