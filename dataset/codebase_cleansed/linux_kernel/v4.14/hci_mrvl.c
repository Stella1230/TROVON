static int mrvl_open(struct hci_uart *hu)\r\n{\r\nstruct mrvl_data *mrvl;\r\nBT_DBG("hu %p", hu);\r\nmrvl = kzalloc(sizeof(*mrvl), GFP_KERNEL);\r\nif (!mrvl)\r\nreturn -ENOMEM;\r\nskb_queue_head_init(&mrvl->txq);\r\nskb_queue_head_init(&mrvl->rawq);\r\nset_bit(STATE_CHIP_VER_PENDING, &mrvl->flags);\r\nhu->priv = mrvl;\r\nreturn 0;\r\n}\r\nstatic int mrvl_close(struct hci_uart *hu)\r\n{\r\nstruct mrvl_data *mrvl = hu->priv;\r\nBT_DBG("hu %p", hu);\r\nskb_queue_purge(&mrvl->txq);\r\nskb_queue_purge(&mrvl->rawq);\r\nkfree_skb(mrvl->rx_skb);\r\nkfree(mrvl);\r\nhu->priv = NULL;\r\nreturn 0;\r\n}\r\nstatic int mrvl_flush(struct hci_uart *hu)\r\n{\r\nstruct mrvl_data *mrvl = hu->priv;\r\nBT_DBG("hu %p", hu);\r\nskb_queue_purge(&mrvl->txq);\r\nskb_queue_purge(&mrvl->rawq);\r\nreturn 0;\r\n}\r\nstatic struct sk_buff *mrvl_dequeue(struct hci_uart *hu)\r\n{\r\nstruct mrvl_data *mrvl = hu->priv;\r\nstruct sk_buff *skb;\r\nskb = skb_dequeue(&mrvl->txq);\r\nif (!skb) {\r\nskb = skb_dequeue(&mrvl->rawq);\r\n} else {\r\nmemcpy(skb_push(skb, 1), &bt_cb(skb)->pkt_type, 1);\r\n}\r\nreturn skb;\r\n}\r\nstatic int mrvl_enqueue(struct hci_uart *hu, struct sk_buff *skb)\r\n{\r\nstruct mrvl_data *mrvl = hu->priv;\r\nskb_queue_tail(&mrvl->txq, skb);\r\nreturn 0;\r\n}\r\nstatic void mrvl_send_ack(struct hci_uart *hu, unsigned char type)\r\n{\r\nstruct mrvl_data *mrvl = hu->priv;\r\nstruct sk_buff *skb;\r\nskb = bt_skb_alloc(0, GFP_ATOMIC);\r\nif (!skb) {\r\nbt_dev_err(hu->hdev, "Unable to alloc ack/nak packet");\r\nreturn;\r\n}\r\nhci_skb_pkt_type(skb) = type;\r\nskb_queue_tail(&mrvl->txq, skb);\r\nhci_uart_tx_wakeup(hu);\r\n}\r\nstatic int mrvl_recv_fw_req(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_mrvl_pkt *pkt = (void *)skb->data;\r\nstruct hci_uart *hu = hci_get_drvdata(hdev);\r\nstruct mrvl_data *mrvl = hu->priv;\r\nint ret = 0;\r\nif ((pkt->lhs ^ pkt->rhs) != 0xffff) {\r\nbt_dev_err(hdev, "Corrupted mrvl header");\r\nmrvl_send_ack(hu, MRVL_NAK);\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nmrvl_send_ack(hu, MRVL_ACK);\r\nif (!test_bit(STATE_FW_REQ_PENDING, &mrvl->flags)) {\r\nbt_dev_err(hdev, "Received unexpected firmware request");\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nmrvl->tx_len = le16_to_cpu(pkt->lhs);\r\nclear_bit(STATE_FW_REQ_PENDING, &mrvl->flags);\r\nsmp_mb__after_atomic();\r\nwake_up_bit(&mrvl->flags, STATE_FW_REQ_PENDING);\r\ndone:\r\nkfree_skb(skb);\r\nreturn ret;\r\n}\r\nstatic int mrvl_recv_chip_ver(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_mrvl_pkt *pkt = (void *)skb->data;\r\nstruct hci_uart *hu = hci_get_drvdata(hdev);\r\nstruct mrvl_data *mrvl = hu->priv;\r\nu16 version = le16_to_cpu(pkt->lhs);\r\nint ret = 0;\r\nif ((pkt->lhs ^ pkt->rhs) != 0xffff) {\r\nbt_dev_err(hdev, "Corrupted mrvl header");\r\nmrvl_send_ack(hu, MRVL_NAK);\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nmrvl_send_ack(hu, MRVL_ACK);\r\nif (!test_bit(STATE_CHIP_VER_PENDING, &mrvl->flags)) {\r\nbt_dev_err(hdev, "Received unexpected chip version");\r\ngoto done;\r\n}\r\nmrvl->id = version;\r\nmrvl->rev = version >> 8;\r\nbt_dev_info(hdev, "Controller id = %x, rev = %x", mrvl->id, mrvl->rev);\r\nclear_bit(STATE_CHIP_VER_PENDING, &mrvl->flags);\r\nsmp_mb__after_atomic();\r\nwake_up_bit(&mrvl->flags, STATE_CHIP_VER_PENDING);\r\ndone:\r\nkfree_skb(skb);\r\nreturn ret;\r\n}\r\nstatic int mrvl_recv(struct hci_uart *hu, const void *data, int count)\r\n{\r\nstruct mrvl_data *mrvl = hu->priv;\r\nif (!test_bit(HCI_UART_REGISTERED, &hu->flags))\r\nreturn -EUNATCH;\r\nmrvl->rx_skb = h4_recv_buf(hu->hdev, mrvl->rx_skb, data, count,\r\nmrvl_recv_pkts,\r\nARRAY_SIZE(mrvl_recv_pkts));\r\nif (IS_ERR(mrvl->rx_skb)) {\r\nint err = PTR_ERR(mrvl->rx_skb);\r\nbt_dev_err(hu->hdev, "Frame reassembly failed (%d)", err);\r\nmrvl->rx_skb = NULL;\r\nreturn err;\r\n}\r\nreturn count;\r\n}\r\nstatic int mrvl_load_firmware(struct hci_dev *hdev, const char *name)\r\n{\r\nstruct hci_uart *hu = hci_get_drvdata(hdev);\r\nstruct mrvl_data *mrvl = hu->priv;\r\nconst struct firmware *fw = NULL;\r\nconst u8 *fw_ptr, *fw_max;\r\nint err;\r\nerr = request_firmware(&fw, name, &hdev->dev);\r\nif (err < 0) {\r\nbt_dev_err(hdev, "Failed to load firmware file %s", name);\r\nreturn err;\r\n}\r\nfw_ptr = fw->data;\r\nfw_max = fw->data + fw->size;\r\nbt_dev_info(hdev, "Loading %s", name);\r\nset_bit(STATE_FW_REQ_PENDING, &mrvl->flags);\r\nwhile (fw_ptr <= fw_max) {\r\nstruct sk_buff *skb;\r\nerr = wait_on_bit_timeout(&mrvl->flags, STATE_FW_REQ_PENDING,\r\nTASK_INTERRUPTIBLE,\r\nmsecs_to_jiffies(2000));\r\nif (err == 1) {\r\nbt_dev_err(hdev, "Firmware load interrupted");\r\nerr = -EINTR;\r\nbreak;\r\n} else if (err) {\r\nbt_dev_err(hdev, "Firmware request timeout");\r\nerr = -ETIMEDOUT;\r\nbreak;\r\n}\r\nbt_dev_dbg(hdev, "Firmware request, expecting %d bytes",\r\nmrvl->tx_len);\r\nif (fw_ptr == fw_max) {\r\nif (!mrvl->tx_len) {\r\nbt_dev_info(hdev, "Firmware loading complete");\r\n} else {\r\nbt_dev_err(hdev, "Firmware loading failure");\r\nerr = -EINVAL;\r\n}\r\nbreak;\r\n}\r\nif (fw_ptr + mrvl->tx_len > fw_max) {\r\nmrvl->tx_len = fw_max - fw_ptr;\r\nbt_dev_dbg(hdev, "Adjusting tx_len to %d",\r\nmrvl->tx_len);\r\n}\r\nskb = bt_skb_alloc(mrvl->tx_len, GFP_KERNEL);\r\nif (!skb) {\r\nbt_dev_err(hdev, "Failed to alloc mem for FW packet");\r\nerr = -ENOMEM;\r\nbreak;\r\n}\r\nbt_cb(skb)->pkt_type = MRVL_RAW_DATA;\r\nskb_put_data(skb, fw_ptr, mrvl->tx_len);\r\nfw_ptr += mrvl->tx_len;\r\nset_bit(STATE_FW_REQ_PENDING, &mrvl->flags);\r\nskb_queue_tail(&mrvl->rawq, skb);\r\nhci_uart_tx_wakeup(hu);\r\n}\r\nrelease_firmware(fw);\r\nreturn err;\r\n}\r\nstatic int mrvl_setup(struct hci_uart *hu)\r\n{\r\nint err;\r\nhci_uart_set_flow_control(hu, true);\r\nerr = mrvl_load_firmware(hu->hdev, "mrvl/helper_uart_3000000.bin");\r\nif (err) {\r\nbt_dev_err(hu->hdev, "Unable to download firmware helper");\r\nreturn -EINVAL;\r\n}\r\nhci_uart_set_baudrate(hu, 3000000);\r\nhci_uart_set_flow_control(hu, false);\r\nerr = mrvl_load_firmware(hu->hdev, "mrvl/uart8897_bt.bin");\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nint __init mrvl_init(void)\r\n{\r\nreturn hci_uart_register_proto(&mrvl_proto);\r\n}\r\nint __exit mrvl_deinit(void)\r\n{\r\nreturn hci_uart_unregister_proto(&mrvl_proto);\r\n}
