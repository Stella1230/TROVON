static void am35x_musb_enable(struct musb *musb)\r\n{\r\nvoid __iomem *reg_base = musb->ctrl_base;\r\nu32 epmask;\r\nepmask = ((musb->epmask & AM35X_TX_EP_MASK) << AM35X_INTR_TX_SHIFT) |\r\n((musb->epmask & AM35X_RX_EP_MASK) << AM35X_INTR_RX_SHIFT);\r\nmusb_writel(reg_base, EP_INTR_MASK_SET_REG, epmask);\r\nmusb_writel(reg_base, CORE_INTR_MASK_SET_REG, AM35X_INTR_USB_MASK);\r\nmusb_writel(reg_base, CORE_INTR_SRC_SET_REG,\r\nAM35X_INTR_DRVVBUS << AM35X_INTR_USB_SHIFT);\r\n}\r\nstatic void am35x_musb_disable(struct musb *musb)\r\n{\r\nvoid __iomem *reg_base = musb->ctrl_base;\r\nmusb_writel(reg_base, CORE_INTR_MASK_CLEAR_REG, AM35X_INTR_USB_MASK);\r\nmusb_writel(reg_base, EP_INTR_MASK_CLEAR_REG,\r\nAM35X_TX_INTR_MASK | AM35X_RX_INTR_MASK);\r\nmusb_writel(reg_base, USB_END_OF_INTR_REG, 0);\r\n}\r\nstatic void am35x_musb_set_vbus(struct musb *musb, int is_on)\r\n{\r\nWARN_ON(is_on && is_peripheral_active(musb));\r\n}\r\nstatic void otg_timer(unsigned long _musb)\r\n{\r\nstruct musb *musb = (void *)_musb;\r\nvoid __iomem *mregs = musb->mregs;\r\nu8 devctl;\r\nunsigned long flags;\r\ndevctl = musb_readb(mregs, MUSB_DEVCTL);\r\ndev_dbg(musb->controller, "Poll devctl %02x (%s)\n", devctl,\r\nusb_otg_state_string(musb->xceiv->otg->state));\r\nspin_lock_irqsave(&musb->lock, flags);\r\nswitch (musb->xceiv->otg->state) {\r\ncase OTG_STATE_A_WAIT_BCON:\r\ndevctl &= ~MUSB_DEVCTL_SESSION;\r\nmusb_writeb(musb->mregs, MUSB_DEVCTL, devctl);\r\ndevctl = musb_readb(musb->mregs, MUSB_DEVCTL);\r\nif (devctl & MUSB_DEVCTL_BDEVICE) {\r\nmusb->xceiv->otg->state = OTG_STATE_B_IDLE;\r\nMUSB_DEV_MODE(musb);\r\n} else {\r\nmusb->xceiv->otg->state = OTG_STATE_A_IDLE;\r\nMUSB_HST_MODE(musb);\r\n}\r\nbreak;\r\ncase OTG_STATE_A_WAIT_VFALL:\r\nmusb->xceiv->otg->state = OTG_STATE_A_WAIT_VRISE;\r\nmusb_writel(musb->ctrl_base, CORE_INTR_SRC_SET_REG,\r\nMUSB_INTR_VBUSERROR << AM35X_INTR_USB_SHIFT);\r\nbreak;\r\ncase OTG_STATE_B_IDLE:\r\ndevctl = musb_readb(mregs, MUSB_DEVCTL);\r\nif (devctl & MUSB_DEVCTL_BDEVICE)\r\nmod_timer(&otg_workaround, jiffies + POLL_SECONDS * HZ);\r\nelse\r\nmusb->xceiv->otg->state = OTG_STATE_A_IDLE;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\n}\r\nstatic void am35x_musb_try_idle(struct musb *musb, unsigned long timeout)\r\n{\r\nstatic unsigned long last_timer;\r\nif (timeout == 0)\r\ntimeout = jiffies + msecs_to_jiffies(3);\r\nif (musb->is_active || (musb->a_wait_bcon == 0 &&\r\nmusb->xceiv->otg->state == OTG_STATE_A_WAIT_BCON)) {\r\ndev_dbg(musb->controller, "%s active, deleting timer\n",\r\nusb_otg_state_string(musb->xceiv->otg->state));\r\ndel_timer(&otg_workaround);\r\nlast_timer = jiffies;\r\nreturn;\r\n}\r\nif (time_after(last_timer, timeout) && timer_pending(&otg_workaround)) {\r\ndev_dbg(musb->controller, "Longer idle timer already pending, ignoring...\n");\r\nreturn;\r\n}\r\nlast_timer = timeout;\r\ndev_dbg(musb->controller, "%s inactive, starting idle timer for %u ms\n",\r\nusb_otg_state_string(musb->xceiv->otg->state),\r\njiffies_to_msecs(timeout - jiffies));\r\nmod_timer(&otg_workaround, timeout);\r\n}\r\nstatic irqreturn_t am35x_musb_interrupt(int irq, void *hci)\r\n{\r\nstruct musb *musb = hci;\r\nvoid __iomem *reg_base = musb->ctrl_base;\r\nstruct device *dev = musb->controller;\r\nstruct musb_hdrc_platform_data *plat = dev_get_platdata(dev);\r\nstruct omap_musb_board_data *data = plat->board_data;\r\nstruct usb_otg *otg = musb->xceiv->otg;\r\nunsigned long flags;\r\nirqreturn_t ret = IRQ_NONE;\r\nu32 epintr, usbintr;\r\nspin_lock_irqsave(&musb->lock, flags);\r\nepintr = musb_readl(reg_base, EP_INTR_SRC_MASKED_REG);\r\nif (epintr) {\r\nmusb_writel(reg_base, EP_INTR_SRC_CLEAR_REG, epintr);\r\nmusb->int_rx =\r\n(epintr & AM35X_RX_INTR_MASK) >> AM35X_INTR_RX_SHIFT;\r\nmusb->int_tx =\r\n(epintr & AM35X_TX_INTR_MASK) >> AM35X_INTR_TX_SHIFT;\r\n}\r\nusbintr = musb_readl(reg_base, CORE_INTR_SRC_MASKED_REG);\r\nif (!usbintr && !epintr)\r\ngoto eoi;\r\nif (usbintr) {\r\nmusb_writel(reg_base, CORE_INTR_SRC_CLEAR_REG, usbintr);\r\nmusb->int_usb =\r\n(usbintr & AM35X_INTR_USB_MASK) >> AM35X_INTR_USB_SHIFT;\r\n}\r\nif (usbintr & (AM35X_INTR_DRVVBUS << AM35X_INTR_USB_SHIFT)) {\r\nint drvvbus = musb_readl(reg_base, USB_STAT_REG);\r\nvoid __iomem *mregs = musb->mregs;\r\nu8 devctl = musb_readb(mregs, MUSB_DEVCTL);\r\nint err;\r\nerr = musb->int_usb & MUSB_INTR_VBUSERROR;\r\nif (err) {\r\nmusb->int_usb &= ~MUSB_INTR_VBUSERROR;\r\nmusb->xceiv->otg->state = OTG_STATE_A_WAIT_VFALL;\r\nmod_timer(&otg_workaround, jiffies + POLL_SECONDS * HZ);\r\nWARNING("VBUS error workaround (delay coming)\n");\r\n} else if (drvvbus) {\r\nMUSB_HST_MODE(musb);\r\notg->default_a = 1;\r\nmusb->xceiv->otg->state = OTG_STATE_A_WAIT_VRISE;\r\nportstate(musb->port1_status |= USB_PORT_STAT_POWER);\r\ndel_timer(&otg_workaround);\r\n} else {\r\nmusb->is_active = 0;\r\nMUSB_DEV_MODE(musb);\r\notg->default_a = 0;\r\nmusb->xceiv->otg->state = OTG_STATE_B_IDLE;\r\nportstate(musb->port1_status &= ~USB_PORT_STAT_POWER);\r\n}\r\ndev_dbg(musb->controller, "VBUS %s (%s)%s, devctl %02x\n",\r\ndrvvbus ? "on" : "off",\r\nusb_otg_state_string(musb->xceiv->otg->state),\r\nerr ? " ERROR" : "",\r\ndevctl);\r\nret = IRQ_HANDLED;\r\n}\r\nif (musb->int_usb & MUSB_INTR_DISCONNECT) {\r\nmusb->int_tx = 0;\r\nmusb->int_rx = 0;\r\n}\r\nif (musb->int_tx || musb->int_rx || musb->int_usb)\r\nret |= musb_interrupt(musb);\r\neoi:\r\nif (ret == IRQ_HANDLED || epintr || usbintr) {\r\nif (data->clear_irq)\r\ndata->clear_irq();\r\nmusb_writel(reg_base, USB_END_OF_INTR_REG, 0);\r\n}\r\nif (musb->xceiv->otg->state == OTG_STATE_B_IDLE)\r\nmod_timer(&otg_workaround, jiffies + POLL_SECONDS * HZ);\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int am35x_musb_set_mode(struct musb *musb, u8 musb_mode)\r\n{\r\nstruct device *dev = musb->controller;\r\nstruct musb_hdrc_platform_data *plat = dev_get_platdata(dev);\r\nstruct omap_musb_board_data *data = plat->board_data;\r\nint retval = 0;\r\nif (data->set_mode)\r\ndata->set_mode(musb_mode);\r\nelse\r\nretval = -EIO;\r\nreturn retval;\r\n}\r\nstatic int am35x_musb_init(struct musb *musb)\r\n{\r\nstruct device *dev = musb->controller;\r\nstruct musb_hdrc_platform_data *plat = dev_get_platdata(dev);\r\nstruct omap_musb_board_data *data = plat->board_data;\r\nvoid __iomem *reg_base = musb->ctrl_base;\r\nu32 rev;\r\nmusb->mregs += USB_MENTOR_CORE_OFFSET;\r\nrev = musb_readl(reg_base, USB_REVISION_REG);\r\nif (!rev)\r\nreturn -ENODEV;\r\nmusb->xceiv = usb_get_phy(USB_PHY_TYPE_USB2);\r\nif (IS_ERR_OR_NULL(musb->xceiv))\r\nreturn -EPROBE_DEFER;\r\nsetup_timer(&otg_workaround, otg_timer, (unsigned long) musb);\r\nif (data->reset)\r\ndata->reset();\r\nmusb_writel(reg_base, USB_CTRL_REG, AM35X_SOFT_RESET_MASK);\r\nif (data->set_phy_power)\r\ndata->set_phy_power(1);\r\nmsleep(5);\r\nmusb->isr = am35x_musb_interrupt;\r\nif (data->clear_irq)\r\ndata->clear_irq();\r\nreturn 0;\r\n}\r\nstatic int am35x_musb_exit(struct musb *musb)\r\n{\r\nstruct device *dev = musb->controller;\r\nstruct musb_hdrc_platform_data *plat = dev_get_platdata(dev);\r\nstruct omap_musb_board_data *data = plat->board_data;\r\ndel_timer_sync(&otg_workaround);\r\nif (data->set_phy_power)\r\ndata->set_phy_power(0);\r\nusb_put_phy(musb->xceiv);\r\nreturn 0;\r\n}\r\nstatic void am35x_read_fifo(struct musb_hw_ep *hw_ep, u16 len, u8 *dst)\r\n{\r\nvoid __iomem *fifo = hw_ep->fifo;\r\nu32 val;\r\nint i;\r\nif (likely((0x03 & (unsigned long) dst) == 0) && len >= 4) {\r\nreadsl(fifo, dst, len >> 2);\r\ndst += len & ~0x03;\r\nlen &= 0x03;\r\n}\r\nif (len > 4) {\r\nfor (i = 0; i < (len >> 2); i++) {\r\n*(u32 *) dst = musb_readl(fifo, 0);\r\ndst += 4;\r\n}\r\nlen &= 0x03;\r\n}\r\nif (len > 0) {\r\nval = musb_readl(fifo, 0);\r\nmemcpy(dst, &val, len);\r\n}\r\n}\r\nstatic int am35x_probe(struct platform_device *pdev)\r\n{\r\nstruct musb_hdrc_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct platform_device *musb;\r\nstruct am35x_glue *glue;\r\nstruct platform_device_info pinfo;\r\nstruct clk *phy_clk;\r\nstruct clk *clk;\r\nint ret = -ENOMEM;\r\nglue = kzalloc(sizeof(*glue), GFP_KERNEL);\r\nif (!glue)\r\ngoto err0;\r\nphy_clk = clk_get(&pdev->dev, "fck");\r\nif (IS_ERR(phy_clk)) {\r\ndev_err(&pdev->dev, "failed to get PHY clock\n");\r\nret = PTR_ERR(phy_clk);\r\ngoto err3;\r\n}\r\nclk = clk_get(&pdev->dev, "ick");\r\nif (IS_ERR(clk)) {\r\ndev_err(&pdev->dev, "failed to get clock\n");\r\nret = PTR_ERR(clk);\r\ngoto err4;\r\n}\r\nret = clk_enable(phy_clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to enable PHY clock\n");\r\ngoto err5;\r\n}\r\nret = clk_enable(clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to enable clock\n");\r\ngoto err6;\r\n}\r\nglue->dev = &pdev->dev;\r\nglue->phy_clk = phy_clk;\r\nglue->clk = clk;\r\npdata->platform_ops = &am35x_ops;\r\nglue->phy = usb_phy_generic_register();\r\nif (IS_ERR(glue->phy)) {\r\nret = PTR_ERR(glue->phy);\r\ngoto err7;\r\n}\r\nplatform_set_drvdata(pdev, glue);\r\npinfo = am35x_dev_info;\r\npinfo.parent = &pdev->dev;\r\npinfo.res = pdev->resource;\r\npinfo.num_res = pdev->num_resources;\r\npinfo.data = pdata;\r\npinfo.size_data = sizeof(*pdata);\r\nglue->musb = musb = platform_device_register_full(&pinfo);\r\nif (IS_ERR(musb)) {\r\nret = PTR_ERR(musb);\r\ndev_err(&pdev->dev, "failed to register musb device: %d\n", ret);\r\ngoto err8;\r\n}\r\nreturn 0;\r\nerr8:\r\nusb_phy_generic_unregister(glue->phy);\r\nerr7:\r\nclk_disable(clk);\r\nerr6:\r\nclk_disable(phy_clk);\r\nerr5:\r\nclk_put(clk);\r\nerr4:\r\nclk_put(phy_clk);\r\nerr3:\r\nkfree(glue);\r\nerr0:\r\nreturn ret;\r\n}\r\nstatic int am35x_remove(struct platform_device *pdev)\r\n{\r\nstruct am35x_glue *glue = platform_get_drvdata(pdev);\r\nplatform_device_unregister(glue->musb);\r\nusb_phy_generic_unregister(glue->phy);\r\nclk_disable(glue->clk);\r\nclk_disable(glue->phy_clk);\r\nclk_put(glue->clk);\r\nclk_put(glue->phy_clk);\r\nkfree(glue);\r\nreturn 0;\r\n}\r\nstatic int am35x_suspend(struct device *dev)\r\n{\r\nstruct am35x_glue *glue = dev_get_drvdata(dev);\r\nstruct musb_hdrc_platform_data *plat = dev_get_platdata(dev);\r\nstruct omap_musb_board_data *data = plat->board_data;\r\nif (data->set_phy_power)\r\ndata->set_phy_power(0);\r\nclk_disable(glue->phy_clk);\r\nclk_disable(glue->clk);\r\nreturn 0;\r\n}\r\nstatic int am35x_resume(struct device *dev)\r\n{\r\nstruct am35x_glue *glue = dev_get_drvdata(dev);\r\nstruct musb_hdrc_platform_data *plat = dev_get_platdata(dev);\r\nstruct omap_musb_board_data *data = plat->board_data;\r\nint ret;\r\nif (data->set_phy_power)\r\ndata->set_phy_power(1);\r\nret = clk_enable(glue->phy_clk);\r\nif (ret) {\r\ndev_err(dev, "failed to enable PHY clock\n");\r\nreturn ret;\r\n}\r\nret = clk_enable(glue->clk);\r\nif (ret) {\r\ndev_err(dev, "failed to enable clock\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
