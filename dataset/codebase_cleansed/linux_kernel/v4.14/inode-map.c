static int caching_kthread(void *data)\r\n{\r\nstruct btrfs_root *root = data;\r\nstruct btrfs_fs_info *fs_info = root->fs_info;\r\nstruct btrfs_free_space_ctl *ctl = root->free_ino_ctl;\r\nstruct btrfs_key key;\r\nstruct btrfs_path *path;\r\nstruct extent_buffer *leaf;\r\nu64 last = (u64)-1;\r\nint slot;\r\nint ret;\r\nif (!btrfs_test_opt(fs_info, INODE_MAP_CACHE))\r\nreturn 0;\r\npath = btrfs_alloc_path();\r\nif (!path)\r\nreturn -ENOMEM;\r\npath->skip_locking = 1;\r\npath->search_commit_root = 1;\r\npath->reada = READA_FORWARD;\r\nkey.objectid = BTRFS_FIRST_FREE_OBJECTID;\r\nkey.offset = 0;\r\nkey.type = BTRFS_INODE_ITEM_KEY;\r\nagain:\r\ndown_read(&fs_info->commit_root_sem);\r\nret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\r\nif (ret < 0)\r\ngoto out;\r\nwhile (1) {\r\nif (btrfs_fs_closing(fs_info))\r\ngoto out;\r\nleaf = path->nodes[0];\r\nslot = path->slots[0];\r\nif (slot >= btrfs_header_nritems(leaf)) {\r\nret = btrfs_next_leaf(root, path);\r\nif (ret < 0)\r\ngoto out;\r\nelse if (ret > 0)\r\nbreak;\r\nif (need_resched() ||\r\nbtrfs_transaction_in_commit(fs_info)) {\r\nleaf = path->nodes[0];\r\nif (WARN_ON(btrfs_header_nritems(leaf) == 0))\r\nbreak;\r\nbtrfs_item_key_to_cpu(leaf, &key, 0);\r\nbtrfs_release_path(path);\r\nroot->ino_cache_progress = last;\r\nup_read(&fs_info->commit_root_sem);\r\nschedule_timeout(1);\r\ngoto again;\r\n} else\r\ncontinue;\r\n}\r\nbtrfs_item_key_to_cpu(leaf, &key, slot);\r\nif (key.type != BTRFS_INODE_ITEM_KEY)\r\ngoto next;\r\nif (key.objectid >= root->highest_objectid)\r\nbreak;\r\nif (last != (u64)-1 && last + 1 != key.objectid) {\r\n__btrfs_add_free_space(fs_info, ctl, last + 1,\r\nkey.objectid - last - 1);\r\nwake_up(&root->ino_cache_wait);\r\n}\r\nlast = key.objectid;\r\nnext:\r\npath->slots[0]++;\r\n}\r\nif (last < root->highest_objectid - 1) {\r\n__btrfs_add_free_space(fs_info, ctl, last + 1,\r\nroot->highest_objectid - last - 1);\r\n}\r\nspin_lock(&root->ino_cache_lock);\r\nroot->ino_cache_state = BTRFS_CACHE_FINISHED;\r\nspin_unlock(&root->ino_cache_lock);\r\nroot->ino_cache_progress = (u64)-1;\r\nbtrfs_unpin_free_ino(root);\r\nout:\r\nwake_up(&root->ino_cache_wait);\r\nup_read(&fs_info->commit_root_sem);\r\nbtrfs_free_path(path);\r\nreturn ret;\r\n}\r\nstatic void start_caching(struct btrfs_root *root)\r\n{\r\nstruct btrfs_fs_info *fs_info = root->fs_info;\r\nstruct btrfs_free_space_ctl *ctl = root->free_ino_ctl;\r\nstruct task_struct *tsk;\r\nint ret;\r\nu64 objectid;\r\nif (!btrfs_test_opt(fs_info, INODE_MAP_CACHE))\r\nreturn;\r\nspin_lock(&root->ino_cache_lock);\r\nif (root->ino_cache_state != BTRFS_CACHE_NO) {\r\nspin_unlock(&root->ino_cache_lock);\r\nreturn;\r\n}\r\nroot->ino_cache_state = BTRFS_CACHE_STARTED;\r\nspin_unlock(&root->ino_cache_lock);\r\nret = load_free_ino_cache(fs_info, root);\r\nif (ret == 1) {\r\nspin_lock(&root->ino_cache_lock);\r\nroot->ino_cache_state = BTRFS_CACHE_FINISHED;\r\nspin_unlock(&root->ino_cache_lock);\r\nreturn;\r\n}\r\nret = btrfs_find_free_objectid(root, &objectid);\r\nif (!ret && objectid <= BTRFS_LAST_FREE_OBJECTID) {\r\n__btrfs_add_free_space(fs_info, ctl, objectid,\r\nBTRFS_LAST_FREE_OBJECTID - objectid + 1);\r\n}\r\ntsk = kthread_run(caching_kthread, root, "btrfs-ino-cache-%llu",\r\nroot->root_key.objectid);\r\nif (IS_ERR(tsk)) {\r\nbtrfs_warn(fs_info, "failed to start inode caching task");\r\nbtrfs_clear_pending_and_info(fs_info, INODE_MAP_CACHE,\r\n"disabling inode map caching");\r\n}\r\n}\r\nint btrfs_find_free_ino(struct btrfs_root *root, u64 *objectid)\r\n{\r\nif (!btrfs_test_opt(root->fs_info, INODE_MAP_CACHE))\r\nreturn btrfs_find_free_objectid(root, objectid);\r\nagain:\r\n*objectid = btrfs_find_ino_for_alloc(root);\r\nif (*objectid != 0)\r\nreturn 0;\r\nstart_caching(root);\r\nwait_event(root->ino_cache_wait,\r\nroot->ino_cache_state == BTRFS_CACHE_FINISHED ||\r\nroot->free_ino_ctl->free_space > 0);\r\nif (root->ino_cache_state == BTRFS_CACHE_FINISHED &&\r\nroot->free_ino_ctl->free_space == 0)\r\nreturn -ENOSPC;\r\nelse\r\ngoto again;\r\n}\r\nvoid btrfs_return_ino(struct btrfs_root *root, u64 objectid)\r\n{\r\nstruct btrfs_fs_info *fs_info = root->fs_info;\r\nstruct btrfs_free_space_ctl *pinned = root->free_ino_pinned;\r\nif (!btrfs_test_opt(fs_info, INODE_MAP_CACHE))\r\nreturn;\r\nagain:\r\nif (root->ino_cache_state == BTRFS_CACHE_FINISHED) {\r\n__btrfs_add_free_space(fs_info, pinned, objectid, 1);\r\n} else {\r\ndown_write(&fs_info->commit_root_sem);\r\nspin_lock(&root->ino_cache_lock);\r\nif (root->ino_cache_state == BTRFS_CACHE_FINISHED) {\r\nspin_unlock(&root->ino_cache_lock);\r\nup_write(&fs_info->commit_root_sem);\r\ngoto again;\r\n}\r\nspin_unlock(&root->ino_cache_lock);\r\nstart_caching(root);\r\n__btrfs_add_free_space(fs_info, pinned, objectid, 1);\r\nup_write(&fs_info->commit_root_sem);\r\n}\r\n}\r\nvoid btrfs_unpin_free_ino(struct btrfs_root *root)\r\n{\r\nstruct btrfs_free_space_ctl *ctl = root->free_ino_ctl;\r\nstruct rb_root *rbroot = &root->free_ino_pinned->free_space_offset;\r\nspinlock_t *rbroot_lock = &root->free_ino_pinned->tree_lock;\r\nstruct btrfs_free_space *info;\r\nstruct rb_node *n;\r\nu64 count;\r\nif (!btrfs_test_opt(root->fs_info, INODE_MAP_CACHE))\r\nreturn;\r\nwhile (1) {\r\nbool add_to_ctl = true;\r\nspin_lock(rbroot_lock);\r\nn = rb_first(rbroot);\r\nif (!n) {\r\nspin_unlock(rbroot_lock);\r\nbreak;\r\n}\r\ninfo = rb_entry(n, struct btrfs_free_space, offset_index);\r\nBUG_ON(info->bitmap);\r\nif (info->offset > root->ino_cache_progress)\r\nadd_to_ctl = false;\r\nelse if (info->offset + info->bytes > root->ino_cache_progress)\r\ncount = root->ino_cache_progress - info->offset + 1;\r\nelse\r\ncount = info->bytes;\r\nrb_erase(&info->offset_index, rbroot);\r\nspin_unlock(rbroot_lock);\r\nif (add_to_ctl)\r\n__btrfs_add_free_space(root->fs_info, ctl,\r\ninfo->offset, count);\r\nkmem_cache_free(btrfs_free_space_cachep, info);\r\n}\r\n}\r\nstatic void recalculate_thresholds(struct btrfs_free_space_ctl *ctl)\r\n{\r\nstruct btrfs_free_space *info;\r\nstruct rb_node *n;\r\nint max_ino;\r\nint max_bitmaps;\r\nn = rb_last(&ctl->free_space_offset);\r\nif (!n) {\r\nctl->extents_thresh = INIT_THRESHOLD;\r\nreturn;\r\n}\r\ninfo = rb_entry(n, struct btrfs_free_space, offset_index);\r\nmax_ino = info->bytes - 1;\r\nmax_bitmaps = ALIGN(max_ino, INODES_PER_BITMAP) / INODES_PER_BITMAP;\r\nif (max_bitmaps <= ctl->total_bitmaps) {\r\nctl->extents_thresh = 0;\r\nreturn;\r\n}\r\nctl->extents_thresh = (max_bitmaps - ctl->total_bitmaps) *\r\nPAGE_SIZE / sizeof(*info);\r\n}\r\nstatic bool use_bitmap(struct btrfs_free_space_ctl *ctl,\r\nstruct btrfs_free_space *info)\r\n{\r\nif (ctl->free_extents < ctl->extents_thresh ||\r\ninfo->bytes > INODES_PER_BITMAP / 10)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic void pinned_recalc_thresholds(struct btrfs_free_space_ctl *ctl)\r\n{\r\n}\r\nstatic bool pinned_use_bitmap(struct btrfs_free_space_ctl *ctl,\r\nstruct btrfs_free_space *info)\r\n{\r\nreturn false;\r\n}\r\nvoid btrfs_init_free_ino_ctl(struct btrfs_root *root)\r\n{\r\nstruct btrfs_free_space_ctl *ctl = root->free_ino_ctl;\r\nstruct btrfs_free_space_ctl *pinned = root->free_ino_pinned;\r\nspin_lock_init(&ctl->tree_lock);\r\nctl->unit = 1;\r\nctl->start = 0;\r\nctl->private = NULL;\r\nctl->op = &free_ino_op;\r\nINIT_LIST_HEAD(&ctl->trimming_ranges);\r\nmutex_init(&ctl->cache_writeout_mutex);\r\nctl->extents_thresh = INIT_THRESHOLD;\r\nspin_lock_init(&pinned->tree_lock);\r\npinned->unit = 1;\r\npinned->start = 0;\r\npinned->private = NULL;\r\npinned->extents_thresh = 0;\r\npinned->op = &pinned_free_ino_op;\r\n}\r\nint btrfs_save_ino_cache(struct btrfs_root *root,\r\nstruct btrfs_trans_handle *trans)\r\n{\r\nstruct btrfs_fs_info *fs_info = root->fs_info;\r\nstruct btrfs_free_space_ctl *ctl = root->free_ino_ctl;\r\nstruct btrfs_path *path;\r\nstruct inode *inode;\r\nstruct btrfs_block_rsv *rsv;\r\nstruct extent_changeset *data_reserved = NULL;\r\nu64 num_bytes;\r\nu64 alloc_hint = 0;\r\nint ret;\r\nint prealloc;\r\nbool retry = false;\r\nif (root->root_key.objectid != BTRFS_FS_TREE_OBJECTID &&\r\n(root->root_key.objectid < BTRFS_FIRST_FREE_OBJECTID ||\r\nroot->root_key.objectid > BTRFS_LAST_FREE_OBJECTID))\r\nreturn 0;\r\nif (btrfs_root_refs(&root->root_item) == 0)\r\nreturn 0;\r\nif (!btrfs_test_opt(fs_info, INODE_MAP_CACHE))\r\nreturn 0;\r\npath = btrfs_alloc_path();\r\nif (!path)\r\nreturn -ENOMEM;\r\nrsv = trans->block_rsv;\r\ntrans->block_rsv = &fs_info->trans_block_rsv;\r\nnum_bytes = trans->bytes_reserved;\r\ntrans->bytes_reserved = btrfs_calc_trans_metadata_size(fs_info, 10);\r\nret = btrfs_block_rsv_add(root, trans->block_rsv,\r\ntrans->bytes_reserved,\r\nBTRFS_RESERVE_NO_FLUSH);\r\nif (ret)\r\ngoto out;\r\ntrace_btrfs_space_reservation(fs_info, "ino_cache", trans->transid,\r\ntrans->bytes_reserved, 1);\r\nagain:\r\ninode = lookup_free_ino_inode(root, path);\r\nif (IS_ERR(inode) && (PTR_ERR(inode) != -ENOENT || retry)) {\r\nret = PTR_ERR(inode);\r\ngoto out_release;\r\n}\r\nif (IS_ERR(inode)) {\r\nBUG_ON(retry);\r\nretry = true;\r\nret = create_free_ino_inode(root, trans, path);\r\nif (ret)\r\ngoto out_release;\r\ngoto again;\r\n}\r\nBTRFS_I(inode)->generation = 0;\r\nret = btrfs_update_inode(trans, root, inode);\r\nif (ret) {\r\nbtrfs_abort_transaction(trans, ret);\r\ngoto out_put;\r\n}\r\nif (i_size_read(inode) > 0) {\r\nret = btrfs_truncate_free_space_cache(trans, NULL, inode);\r\nif (ret) {\r\nif (ret != -ENOSPC)\r\nbtrfs_abort_transaction(trans, ret);\r\ngoto out_put;\r\n}\r\n}\r\nspin_lock(&root->ino_cache_lock);\r\nif (root->ino_cache_state != BTRFS_CACHE_FINISHED) {\r\nret = -1;\r\nspin_unlock(&root->ino_cache_lock);\r\ngoto out_put;\r\n}\r\nspin_unlock(&root->ino_cache_lock);\r\nspin_lock(&ctl->tree_lock);\r\nprealloc = sizeof(struct btrfs_free_space) * ctl->free_extents;\r\nprealloc = ALIGN(prealloc, PAGE_SIZE);\r\nprealloc += ctl->total_bitmaps * PAGE_SIZE;\r\nspin_unlock(&ctl->tree_lock);\r\nprealloc += 8 * PAGE_SIZE;\r\nret = btrfs_delalloc_reserve_space(inode, &data_reserved, 0, prealloc);\r\nif (ret)\r\ngoto out_put;\r\nret = btrfs_prealloc_file_range_trans(inode, trans, 0, 0, prealloc,\r\nprealloc, prealloc, &alloc_hint);\r\nif (ret) {\r\nbtrfs_delalloc_release_metadata(BTRFS_I(inode), prealloc);\r\ngoto out_put;\r\n}\r\nret = btrfs_write_out_ino_cache(root, trans, path, inode);\r\nout_put:\r\niput(inode);\r\nout_release:\r\ntrace_btrfs_space_reservation(fs_info, "ino_cache", trans->transid,\r\ntrans->bytes_reserved, 0);\r\nbtrfs_block_rsv_release(fs_info, trans->block_rsv,\r\ntrans->bytes_reserved);\r\nout:\r\ntrans->block_rsv = rsv;\r\ntrans->bytes_reserved = num_bytes;\r\nbtrfs_free_path(path);\r\nextent_changeset_free(data_reserved);\r\nreturn ret;\r\n}\r\nint btrfs_find_highest_objectid(struct btrfs_root *root, u64 *objectid)\r\n{\r\nstruct btrfs_path *path;\r\nint ret;\r\nstruct extent_buffer *l;\r\nstruct btrfs_key search_key;\r\nstruct btrfs_key found_key;\r\nint slot;\r\npath = btrfs_alloc_path();\r\nif (!path)\r\nreturn -ENOMEM;\r\nsearch_key.objectid = BTRFS_LAST_FREE_OBJECTID;\r\nsearch_key.type = -1;\r\nsearch_key.offset = (u64)-1;\r\nret = btrfs_search_slot(NULL, root, &search_key, path, 0, 0);\r\nif (ret < 0)\r\ngoto error;\r\nBUG_ON(ret == 0);\r\nif (path->slots[0] > 0) {\r\nslot = path->slots[0] - 1;\r\nl = path->nodes[0];\r\nbtrfs_item_key_to_cpu(l, &found_key, slot);\r\n*objectid = max_t(u64, found_key.objectid,\r\nBTRFS_FIRST_FREE_OBJECTID - 1);\r\n} else {\r\n*objectid = BTRFS_FIRST_FREE_OBJECTID - 1;\r\n}\r\nret = 0;\r\nerror:\r\nbtrfs_free_path(path);\r\nreturn ret;\r\n}\r\nint btrfs_find_free_objectid(struct btrfs_root *root, u64 *objectid)\r\n{\r\nint ret;\r\nmutex_lock(&root->objectid_mutex);\r\nif (unlikely(root->highest_objectid >= BTRFS_LAST_FREE_OBJECTID)) {\r\nbtrfs_warn(root->fs_info,\r\n"the objectid of root %llu reaches its highest value",\r\nroot->root_key.objectid);\r\nret = -ENOSPC;\r\ngoto out;\r\n}\r\n*objectid = ++root->highest_objectid;\r\nret = 0;\r\nout:\r\nmutex_unlock(&root->objectid_mutex);\r\nreturn ret;\r\n}
