static u32 dsi_clk_from_pclk(u32 pclk, enum mipi_dsi_pixel_format fmt,\r\nint lane_count)\r\n{\r\nu32 dsi_clk_khz;\r\nu32 bpp = mipi_dsi_pixel_format_to_bpp(fmt);\r\ndsi_clk_khz = DIV_ROUND_CLOSEST(pclk * bpp, lane_count);\r\nreturn dsi_clk_khz;\r\n}\r\nstatic int dsi_calc_mnp(struct drm_i915_private *dev_priv,\r\nstruct intel_crtc_state *config,\r\nint target_dsi_clk)\r\n{\r\nunsigned int m_min, m_max, p_min = 2, p_max = 6;\r\nunsigned int m, n, p;\r\nunsigned int calc_m, calc_p;\r\nint delta, ref_clk;\r\nif (target_dsi_clk < 300000 || target_dsi_clk > 1150000) {\r\nDRM_ERROR("DSI CLK Out of Range\n");\r\nreturn -ECHRNG;\r\n}\r\nif (IS_CHERRYVIEW(dev_priv)) {\r\nref_clk = 100000;\r\nn = 4;\r\nm_min = 70;\r\nm_max = 96;\r\n} else {\r\nref_clk = 25000;\r\nn = 1;\r\nm_min = 62;\r\nm_max = 92;\r\n}\r\ncalc_p = p_min;\r\ncalc_m = m_min;\r\ndelta = abs(target_dsi_clk - (m_min * ref_clk) / (p_min * n));\r\nfor (m = m_min; m <= m_max && delta; m++) {\r\nfor (p = p_min; p <= p_max && delta; p++) {\r\nint calc_dsi_clk = (m * ref_clk) / (p * n);\r\nint d = abs(target_dsi_clk - calc_dsi_clk);\r\nif (d < delta) {\r\ndelta = d;\r\ncalc_m = m;\r\ncalc_p = p;\r\n}\r\n}\r\n}\r\nconfig->dsi_pll.ctrl = 1 << (DSI_PLL_P1_POST_DIV_SHIFT + calc_p - 2);\r\nconfig->dsi_pll.div =\r\n(ffs(n) - 1) << DSI_PLL_N1_DIV_SHIFT |\r\n(u32)lfsr_converts[calc_m - 62] << DSI_PLL_M1_DIV_SHIFT;\r\nreturn 0;\r\n}\r\nstatic int vlv_compute_dsi_pll(struct intel_encoder *encoder,\r\nstruct intel_crtc_state *config)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\r\nstruct intel_dsi *intel_dsi = enc_to_intel_dsi(&encoder->base);\r\nint ret;\r\nu32 dsi_clk;\r\ndsi_clk = dsi_clk_from_pclk(intel_dsi->pclk, intel_dsi->pixel_format,\r\nintel_dsi->lane_count);\r\nret = dsi_calc_mnp(dev_priv, config, dsi_clk);\r\nif (ret) {\r\nDRM_DEBUG_KMS("dsi_calc_mnp failed\n");\r\nreturn ret;\r\n}\r\nif (intel_dsi->ports & (1 << PORT_A))\r\nconfig->dsi_pll.ctrl |= DSI_PLL_CLK_GATE_DSI0_DSIPLL;\r\nif (intel_dsi->ports & (1 << PORT_C))\r\nconfig->dsi_pll.ctrl |= DSI_PLL_CLK_GATE_DSI1_DSIPLL;\r\nconfig->dsi_pll.ctrl |= DSI_PLL_VCO_EN;\r\nDRM_DEBUG_KMS("dsi pll div %08x, ctrl %08x\n",\r\nconfig->dsi_pll.div, config->dsi_pll.ctrl);\r\nreturn 0;\r\n}\r\nstatic void vlv_enable_dsi_pll(struct intel_encoder *encoder,\r\nconst struct intel_crtc_state *config)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\r\nDRM_DEBUG_KMS("\n");\r\nmutex_lock(&dev_priv->sb_lock);\r\nvlv_cck_write(dev_priv, CCK_REG_DSI_PLL_CONTROL, 0);\r\nvlv_cck_write(dev_priv, CCK_REG_DSI_PLL_DIVIDER, config->dsi_pll.div);\r\nvlv_cck_write(dev_priv, CCK_REG_DSI_PLL_CONTROL,\r\nconfig->dsi_pll.ctrl & ~DSI_PLL_VCO_EN);\r\nusleep_range(10, 50);\r\nvlv_cck_write(dev_priv, CCK_REG_DSI_PLL_CONTROL, config->dsi_pll.ctrl);\r\nif (wait_for(vlv_cck_read(dev_priv, CCK_REG_DSI_PLL_CONTROL) &\r\nDSI_PLL_LOCK, 20)) {\r\nmutex_unlock(&dev_priv->sb_lock);\r\nDRM_ERROR("DSI PLL lock failed\n");\r\nreturn;\r\n}\r\nmutex_unlock(&dev_priv->sb_lock);\r\nDRM_DEBUG_KMS("DSI PLL locked\n");\r\n}\r\nstatic void vlv_disable_dsi_pll(struct intel_encoder *encoder)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\r\nu32 tmp;\r\nDRM_DEBUG_KMS("\n");\r\nmutex_lock(&dev_priv->sb_lock);\r\ntmp = vlv_cck_read(dev_priv, CCK_REG_DSI_PLL_CONTROL);\r\ntmp &= ~DSI_PLL_VCO_EN;\r\ntmp |= DSI_PLL_LDO_GATE;\r\nvlv_cck_write(dev_priv, CCK_REG_DSI_PLL_CONTROL, tmp);\r\nmutex_unlock(&dev_priv->sb_lock);\r\n}\r\nstatic bool bxt_dsi_pll_is_enabled(struct drm_i915_private *dev_priv)\r\n{\r\nbool enabled;\r\nu32 val;\r\nu32 mask;\r\nmask = BXT_DSI_PLL_DO_ENABLE | BXT_DSI_PLL_LOCKED;\r\nval = I915_READ(BXT_DSI_PLL_ENABLE);\r\nenabled = (val & mask) == mask;\r\nif (!enabled)\r\nreturn false;\r\nval = I915_READ(BXT_DSI_PLL_CTL);\r\nif (IS_GEMINILAKE(dev_priv)) {\r\nif (!(val & BXT_DSIA_16X_MASK)) {\r\nDRM_DEBUG_DRIVER("Invalid PLL divider (%08x)\n", val);\r\nenabled = false;\r\n}\r\n} else {\r\nif (!(val & BXT_DSIA_16X_MASK) || !(val & BXT_DSIC_16X_MASK)) {\r\nDRM_DEBUG_DRIVER("Invalid PLL divider (%08x)\n", val);\r\nenabled = false;\r\n}\r\n}\r\nreturn enabled;\r\n}\r\nstatic void bxt_disable_dsi_pll(struct intel_encoder *encoder)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\r\nu32 val;\r\nDRM_DEBUG_KMS("\n");\r\nval = I915_READ(BXT_DSI_PLL_ENABLE);\r\nval &= ~BXT_DSI_PLL_DO_ENABLE;\r\nI915_WRITE(BXT_DSI_PLL_ENABLE, val);\r\nif (intel_wait_for_register(dev_priv,\r\nBXT_DSI_PLL_ENABLE,\r\nBXT_DSI_PLL_LOCKED,\r\n0,\r\n1))\r\nDRM_ERROR("Timeout waiting for PLL lock deassertion\n");\r\n}\r\nstatic void assert_bpp_mismatch(enum mipi_dsi_pixel_format fmt, int pipe_bpp)\r\n{\r\nint bpp = mipi_dsi_pixel_format_to_bpp(fmt);\r\nWARN(bpp != pipe_bpp,\r\n"bpp match assertion failure (expected %d, current %d)\n",\r\nbpp, pipe_bpp);\r\n}\r\nstatic u32 vlv_dsi_get_pclk(struct intel_encoder *encoder, int pipe_bpp,\r\nstruct intel_crtc_state *config)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\r\nstruct intel_dsi *intel_dsi = enc_to_intel_dsi(&encoder->base);\r\nu32 dsi_clock, pclk;\r\nu32 pll_ctl, pll_div;\r\nu32 m = 0, p = 0, n;\r\nint refclk = IS_CHERRYVIEW(dev_priv) ? 100000 : 25000;\r\nint i;\r\nDRM_DEBUG_KMS("\n");\r\nmutex_lock(&dev_priv->sb_lock);\r\npll_ctl = vlv_cck_read(dev_priv, CCK_REG_DSI_PLL_CONTROL);\r\npll_div = vlv_cck_read(dev_priv, CCK_REG_DSI_PLL_DIVIDER);\r\nmutex_unlock(&dev_priv->sb_lock);\r\nconfig->dsi_pll.ctrl = pll_ctl & ~DSI_PLL_LOCK;\r\nconfig->dsi_pll.div = pll_div;\r\npll_ctl &= DSI_PLL_P1_POST_DIV_MASK;\r\npll_ctl = pll_ctl >> (DSI_PLL_P1_POST_DIV_SHIFT - 2);\r\nn = (pll_div & DSI_PLL_N1_DIV_MASK) >> DSI_PLL_N1_DIV_SHIFT;\r\nn = 1 << n;\r\npll_div &= DSI_PLL_M1_DIV_MASK;\r\npll_div = pll_div >> DSI_PLL_M1_DIV_SHIFT;\r\nwhile (pll_ctl) {\r\npll_ctl = pll_ctl >> 1;\r\np++;\r\n}\r\np--;\r\nif (!p) {\r\nDRM_ERROR("wrong P1 divisor\n");\r\nreturn 0;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(lfsr_converts); i++) {\r\nif (lfsr_converts[i] == pll_div)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(lfsr_converts)) {\r\nDRM_ERROR("wrong m_seed programmed\n");\r\nreturn 0;\r\n}\r\nm = i + 62;\r\ndsi_clock = (m * refclk) / (p * n);\r\nassert_bpp_mismatch(intel_dsi->pixel_format, pipe_bpp);\r\npclk = DIV_ROUND_CLOSEST(dsi_clock * intel_dsi->lane_count, pipe_bpp);\r\nreturn pclk;\r\n}\r\nstatic u32 bxt_dsi_get_pclk(struct intel_encoder *encoder, int pipe_bpp,\r\nstruct intel_crtc_state *config)\r\n{\r\nu32 pclk;\r\nu32 dsi_clk;\r\nu32 dsi_ratio;\r\nstruct intel_dsi *intel_dsi = enc_to_intel_dsi(&encoder->base);\r\nstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\r\nif (!pipe_bpp) {\r\nDRM_ERROR("Invalid BPP(0)\n");\r\nreturn 0;\r\n}\r\nconfig->dsi_pll.ctrl = I915_READ(BXT_DSI_PLL_CTL);\r\ndsi_ratio = config->dsi_pll.ctrl & BXT_DSI_PLL_RATIO_MASK;\r\ndsi_clk = (dsi_ratio * BXT_REF_CLOCK_KHZ) / 2;\r\nassert_bpp_mismatch(intel_dsi->pixel_format, pipe_bpp);\r\npclk = DIV_ROUND_CLOSEST(dsi_clk * intel_dsi->lane_count, pipe_bpp);\r\nDRM_DEBUG_DRIVER("Calculated pclk=%u\n", pclk);\r\nreturn pclk;\r\n}\r\nu32 intel_dsi_get_pclk(struct intel_encoder *encoder, int pipe_bpp,\r\nstruct intel_crtc_state *config)\r\n{\r\nif (IS_GEN9_LP(to_i915(encoder->base.dev)))\r\nreturn bxt_dsi_get_pclk(encoder, pipe_bpp, config);\r\nelse\r\nreturn vlv_dsi_get_pclk(encoder, pipe_bpp, config);\r\n}\r\nstatic void vlv_dsi_reset_clocks(struct intel_encoder *encoder, enum port port)\r\n{\r\nu32 temp;\r\nstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\r\nstruct intel_dsi *intel_dsi = enc_to_intel_dsi(&encoder->base);\r\ntemp = I915_READ(MIPI_CTRL(port));\r\ntemp &= ~ESCAPE_CLOCK_DIVIDER_MASK;\r\nI915_WRITE(MIPI_CTRL(port), temp |\r\nintel_dsi->escape_clk_div <<\r\nESCAPE_CLOCK_DIVIDER_SHIFT);\r\n}\r\nstatic void glk_dsi_program_esc_clock(struct drm_device *dev,\r\nconst struct intel_crtc_state *config)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(dev);\r\nu32 dsi_rate = 0;\r\nu32 pll_ratio = 0;\r\nu32 ddr_clk = 0;\r\nu32 div1_value = 0;\r\nu32 div2_value = 0;\r\nu32 txesc1_div = 0;\r\nu32 txesc2_div = 0;\r\npll_ratio = config->dsi_pll.ctrl & BXT_DSI_PLL_RATIO_MASK;\r\ndsi_rate = (BXT_REF_CLOCK_KHZ * pll_ratio) / 2;\r\nddr_clk = dsi_rate / 2;\r\ndiv1_value = DIV_ROUND_CLOSEST(ddr_clk, 20000);\r\nif (div1_value <= 10)\r\ntxesc1_div = div1_value;\r\nelse if ((div1_value > 10) && (div1_value <= 20))\r\ntxesc1_div = DIV_ROUND_UP(div1_value, 2);\r\nelse if ((div1_value > 20) && (div1_value <= 30))\r\ntxesc1_div = DIV_ROUND_UP(div1_value, 4);\r\nelse if ((div1_value > 30) && (div1_value <= 40))\r\ntxesc1_div = DIV_ROUND_UP(div1_value, 6);\r\nelse if ((div1_value > 40) && (div1_value <= 50))\r\ntxesc1_div = DIV_ROUND_UP(div1_value, 8);\r\nelse\r\ntxesc1_div = 10;\r\ndiv2_value = DIV_ROUND_UP(div1_value, txesc1_div);\r\nif (div2_value < 10)\r\ntxesc2_div = div2_value;\r\nelse\r\ntxesc2_div = 10;\r\nI915_WRITE(MIPIO_TXESC_CLK_DIV1, txesc1_div & GLK_TX_ESC_CLK_DIV1_MASK);\r\nI915_WRITE(MIPIO_TXESC_CLK_DIV2, txesc2_div & GLK_TX_ESC_CLK_DIV2_MASK);\r\n}\r\nstatic void bxt_dsi_program_clocks(struct drm_device *dev, enum port port,\r\nconst struct intel_crtc_state *config)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(dev);\r\nu32 tmp;\r\nu32 dsi_rate = 0;\r\nu32 pll_ratio = 0;\r\nu32 rx_div;\r\nu32 tx_div;\r\nu32 rx_div_upper;\r\nu32 rx_div_lower;\r\nu32 mipi_8by3_divider;\r\ntmp = I915_READ(BXT_MIPI_CLOCK_CTL);\r\ntmp &= ~(BXT_MIPI_TX_ESCLK_FIXDIV_MASK(port));\r\ntmp &= ~(BXT_MIPI_RX_ESCLK_UPPER_FIXDIV_MASK(port));\r\ntmp &= ~(BXT_MIPI_8X_BY3_DIVIDER_MASK(port));\r\ntmp &= ~(BXT_MIPI_RX_ESCLK_LOWER_FIXDIV_MASK(port));\r\npll_ratio = config->dsi_pll.ctrl & BXT_DSI_PLL_RATIO_MASK;\r\ndsi_rate = (BXT_REF_CLOCK_KHZ * pll_ratio) / 2;\r\ntx_div = DIV_ROUND_UP(dsi_rate, 20000) - 1;\r\nrx_div = DIV_ROUND_UP(dsi_rate, 150000) - 1;\r\nrx_div_lower = rx_div & RX_DIVIDER_BIT_1_2;\r\nrx_div_upper = (rx_div & RX_DIVIDER_BIT_3_4) >> 2;\r\nmipi_8by3_divider = 0x2;\r\ntmp |= BXT_MIPI_8X_BY3_DIVIDER(port, mipi_8by3_divider);\r\ntmp |= BXT_MIPI_TX_ESCLK_DIVIDER(port, tx_div);\r\ntmp |= BXT_MIPI_RX_ESCLK_LOWER_DIVIDER(port, rx_div_lower);\r\ntmp |= BXT_MIPI_RX_ESCLK_UPPER_DIVIDER(port, rx_div_upper);\r\nI915_WRITE(BXT_MIPI_CLOCK_CTL, tmp);\r\n}\r\nstatic int gen9lp_compute_dsi_pll(struct intel_encoder *encoder,\r\nstruct intel_crtc_state *config)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\r\nstruct intel_dsi *intel_dsi = enc_to_intel_dsi(&encoder->base);\r\nu8 dsi_ratio, dsi_ratio_min, dsi_ratio_max;\r\nu32 dsi_clk;\r\ndsi_clk = dsi_clk_from_pclk(intel_dsi->pclk, intel_dsi->pixel_format,\r\nintel_dsi->lane_count);\r\ndsi_ratio = DIV_ROUND_UP(dsi_clk * 2, BXT_REF_CLOCK_KHZ);\r\nif (IS_BROXTON(dev_priv)) {\r\ndsi_ratio_min = BXT_DSI_PLL_RATIO_MIN;\r\ndsi_ratio_max = BXT_DSI_PLL_RATIO_MAX;\r\n} else {\r\ndsi_ratio_min = GLK_DSI_PLL_RATIO_MIN;\r\ndsi_ratio_max = GLK_DSI_PLL_RATIO_MAX;\r\n}\r\nif (dsi_ratio < dsi_ratio_min || dsi_ratio > dsi_ratio_max) {\r\nDRM_ERROR("Cant get a suitable ratio from DSI PLL ratios\n");\r\nreturn -ECHRNG;\r\n} else\r\nDRM_DEBUG_KMS("DSI PLL calculation is Done!!\n");\r\nconfig->dsi_pll.ctrl = dsi_ratio | BXT_DSIA_16X_BY2 | BXT_DSIC_16X_BY2;\r\nif (IS_BROXTON(dev_priv) && dsi_ratio <= 50)\r\nconfig->dsi_pll.ctrl |= BXT_DSI_PLL_PVD_RATIO_1;\r\nreturn 0;\r\n}\r\nstatic void gen9lp_enable_dsi_pll(struct intel_encoder *encoder,\r\nconst struct intel_crtc_state *config)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\r\nstruct intel_dsi *intel_dsi = enc_to_intel_dsi(&encoder->base);\r\nenum port port;\r\nu32 val;\r\nDRM_DEBUG_KMS("\n");\r\nI915_WRITE(BXT_DSI_PLL_CTL, config->dsi_pll.ctrl);\r\nPOSTING_READ(BXT_DSI_PLL_CTL);\r\nif (IS_BROXTON(dev_priv)) {\r\nfor_each_dsi_port(port, intel_dsi->ports)\r\nbxt_dsi_program_clocks(encoder->base.dev, port, config);\r\n} else {\r\nglk_dsi_program_esc_clock(encoder->base.dev, config);\r\n}\r\nval = I915_READ(BXT_DSI_PLL_ENABLE);\r\nval |= BXT_DSI_PLL_DO_ENABLE;\r\nI915_WRITE(BXT_DSI_PLL_ENABLE, val);\r\nif (intel_wait_for_register(dev_priv,\r\nBXT_DSI_PLL_ENABLE,\r\nBXT_DSI_PLL_LOCKED,\r\nBXT_DSI_PLL_LOCKED,\r\n1)) {\r\nDRM_ERROR("Timed out waiting for DSI PLL to lock\n");\r\nreturn;\r\n}\r\nDRM_DEBUG_KMS("DSI PLL locked\n");\r\n}\r\nbool intel_dsi_pll_is_enabled(struct drm_i915_private *dev_priv)\r\n{\r\nif (IS_GEN9_LP(dev_priv))\r\nreturn bxt_dsi_pll_is_enabled(dev_priv);\r\nMISSING_CASE(INTEL_DEVID(dev_priv));\r\nreturn false;\r\n}\r\nint intel_compute_dsi_pll(struct intel_encoder *encoder,\r\nstruct intel_crtc_state *config)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\r\nif (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))\r\nreturn vlv_compute_dsi_pll(encoder, config);\r\nelse if (IS_GEN9_LP(dev_priv))\r\nreturn gen9lp_compute_dsi_pll(encoder, config);\r\nreturn -ENODEV;\r\n}\r\nvoid intel_enable_dsi_pll(struct intel_encoder *encoder,\r\nconst struct intel_crtc_state *config)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\r\nif (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))\r\nvlv_enable_dsi_pll(encoder, config);\r\nelse if (IS_GEN9_LP(dev_priv))\r\ngen9lp_enable_dsi_pll(encoder, config);\r\n}\r\nvoid intel_disable_dsi_pll(struct intel_encoder *encoder)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\r\nif (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))\r\nvlv_disable_dsi_pll(encoder);\r\nelse if (IS_GEN9_LP(dev_priv))\r\nbxt_disable_dsi_pll(encoder);\r\n}\r\nstatic void gen9lp_dsi_reset_clocks(struct intel_encoder *encoder,\r\nenum port port)\r\n{\r\nu32 tmp;\r\nstruct drm_device *dev = encoder->base.dev;\r\nstruct drm_i915_private *dev_priv = to_i915(dev);\r\nif (IS_BROXTON(dev_priv)) {\r\ntmp = I915_READ(BXT_MIPI_CLOCK_CTL);\r\ntmp &= ~(BXT_MIPI_TX_ESCLK_FIXDIV_MASK(port));\r\ntmp &= ~(BXT_MIPI_RX_ESCLK_UPPER_FIXDIV_MASK(port));\r\ntmp &= ~(BXT_MIPI_8X_BY3_DIVIDER_MASK(port));\r\ntmp &= ~(BXT_MIPI_RX_ESCLK_LOWER_FIXDIV_MASK(port));\r\nI915_WRITE(BXT_MIPI_CLOCK_CTL, tmp);\r\n} else {\r\ntmp = I915_READ(MIPIO_TXESC_CLK_DIV1);\r\ntmp &= ~GLK_TX_ESC_CLK_DIV1_MASK;\r\nI915_WRITE(MIPIO_TXESC_CLK_DIV1, tmp);\r\ntmp = I915_READ(MIPIO_TXESC_CLK_DIV2);\r\ntmp &= ~GLK_TX_ESC_CLK_DIV2_MASK;\r\nI915_WRITE(MIPIO_TXESC_CLK_DIV2, tmp);\r\n}\r\nI915_WRITE(MIPI_EOT_DISABLE(port), CLOCKSTOP);\r\n}\r\nvoid intel_dsi_reset_clocks(struct intel_encoder *encoder, enum port port)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\r\nif (IS_GEN9_LP(dev_priv))\r\ngen9lp_dsi_reset_clocks(encoder, port);\r\nelse if (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))\r\nvlv_dsi_reset_clocks(encoder, port);\r\n}
