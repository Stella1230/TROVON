static void mrp_attrvalue_inc(void *value, u8 len)\r\n{\r\nu8 *v = (u8 *)value;\r\nwhile (len > 0 && !++v[--len])\r\n;\r\n}\r\nstatic int mrp_attr_cmp(const struct mrp_attr *attr,\r\nconst void *value, u8 len, u8 type)\r\n{\r\nif (attr->type != type)\r\nreturn attr->type - type;\r\nif (attr->len != len)\r\nreturn attr->len - len;\r\nreturn memcmp(attr->value, value, len);\r\n}\r\nstatic struct mrp_attr *mrp_attr_lookup(const struct mrp_applicant *app,\r\nconst void *value, u8 len, u8 type)\r\n{\r\nstruct rb_node *parent = app->mad.rb_node;\r\nstruct mrp_attr *attr;\r\nint d;\r\nwhile (parent) {\r\nattr = rb_entry(parent, struct mrp_attr, node);\r\nd = mrp_attr_cmp(attr, value, len, type);\r\nif (d > 0)\r\nparent = parent->rb_left;\r\nelse if (d < 0)\r\nparent = parent->rb_right;\r\nelse\r\nreturn attr;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct mrp_attr *mrp_attr_create(struct mrp_applicant *app,\r\nconst void *value, u8 len, u8 type)\r\n{\r\nstruct rb_node *parent = NULL, **p = &app->mad.rb_node;\r\nstruct mrp_attr *attr;\r\nint d;\r\nwhile (*p) {\r\nparent = *p;\r\nattr = rb_entry(parent, struct mrp_attr, node);\r\nd = mrp_attr_cmp(attr, value, len, type);\r\nif (d > 0)\r\np = &parent->rb_left;\r\nelse if (d < 0)\r\np = &parent->rb_right;\r\nelse {\r\nreturn attr;\r\n}\r\n}\r\nattr = kmalloc(sizeof(*attr) + len, GFP_ATOMIC);\r\nif (!attr)\r\nreturn attr;\r\nattr->state = MRP_APPLICANT_VO;\r\nattr->type = type;\r\nattr->len = len;\r\nmemcpy(attr->value, value, len);\r\nrb_link_node(&attr->node, parent, p);\r\nrb_insert_color(&attr->node, &app->mad);\r\nreturn attr;\r\n}\r\nstatic void mrp_attr_destroy(struct mrp_applicant *app, struct mrp_attr *attr)\r\n{\r\nrb_erase(&attr->node, &app->mad);\r\nkfree(attr);\r\n}\r\nstatic int mrp_pdu_init(struct mrp_applicant *app)\r\n{\r\nstruct sk_buff *skb;\r\nstruct mrp_pdu_hdr *ph;\r\nskb = alloc_skb(app->dev->mtu + LL_RESERVED_SPACE(app->dev),\r\nGFP_ATOMIC);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nskb->dev = app->dev;\r\nskb->protocol = app->app->pkttype.type;\r\nskb_reserve(skb, LL_RESERVED_SPACE(app->dev));\r\nskb_reset_network_header(skb);\r\nskb_reset_transport_header(skb);\r\nph = __skb_put(skb, sizeof(*ph));\r\nph->version = app->app->version;\r\napp->pdu = skb;\r\nreturn 0;\r\n}\r\nstatic int mrp_pdu_append_end_mark(struct mrp_applicant *app)\r\n{\r\n__be16 *endmark;\r\nif (skb_tailroom(app->pdu) < sizeof(*endmark))\r\nreturn -1;\r\nendmark = __skb_put(app->pdu, sizeof(*endmark));\r\nput_unaligned(MRP_END_MARK, endmark);\r\nreturn 0;\r\n}\r\nstatic void mrp_pdu_queue(struct mrp_applicant *app)\r\n{\r\nif (!app->pdu)\r\nreturn;\r\nif (mrp_cb(app->pdu)->mh)\r\nmrp_pdu_append_end_mark(app);\r\nmrp_pdu_append_end_mark(app);\r\ndev_hard_header(app->pdu, app->dev, ntohs(app->app->pkttype.type),\r\napp->app->group_address, app->dev->dev_addr,\r\napp->pdu->len);\r\nskb_queue_tail(&app->queue, app->pdu);\r\napp->pdu = NULL;\r\n}\r\nstatic void mrp_queue_xmit(struct mrp_applicant *app)\r\n{\r\nstruct sk_buff *skb;\r\nwhile ((skb = skb_dequeue(&app->queue)))\r\ndev_queue_xmit(skb);\r\n}\r\nstatic int mrp_pdu_append_msg_hdr(struct mrp_applicant *app,\r\nu8 attrtype, u8 attrlen)\r\n{\r\nstruct mrp_msg_hdr *mh;\r\nif (mrp_cb(app->pdu)->mh) {\r\nif (mrp_pdu_append_end_mark(app) < 0)\r\nreturn -1;\r\nmrp_cb(app->pdu)->mh = NULL;\r\nmrp_cb(app->pdu)->vah = NULL;\r\n}\r\nif (skb_tailroom(app->pdu) < sizeof(*mh))\r\nreturn -1;\r\nmh = __skb_put(app->pdu, sizeof(*mh));\r\nmh->attrtype = attrtype;\r\nmh->attrlen = attrlen;\r\nmrp_cb(app->pdu)->mh = mh;\r\nreturn 0;\r\n}\r\nstatic int mrp_pdu_append_vecattr_hdr(struct mrp_applicant *app,\r\nconst void *firstattrvalue, u8 attrlen)\r\n{\r\nstruct mrp_vecattr_hdr *vah;\r\nif (skb_tailroom(app->pdu) < sizeof(*vah) + attrlen)\r\nreturn -1;\r\nvah = __skb_put(app->pdu, sizeof(*vah) + attrlen);\r\nput_unaligned(0, &vah->lenflags);\r\nmemcpy(vah->firstattrvalue, firstattrvalue, attrlen);\r\nmrp_cb(app->pdu)->vah = vah;\r\nmemcpy(mrp_cb(app->pdu)->attrvalue, firstattrvalue, attrlen);\r\nreturn 0;\r\n}\r\nstatic int mrp_pdu_append_vecattr_event(struct mrp_applicant *app,\r\nconst struct mrp_attr *attr,\r\nenum mrp_vecattr_event vaevent)\r\n{\r\nu16 len, pos;\r\nu8 *vaevents;\r\nint err;\r\nagain:\r\nif (!app->pdu) {\r\nerr = mrp_pdu_init(app);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (!mrp_cb(app->pdu)->mh ||\r\nmrp_cb(app->pdu)->mh->attrtype != attr->type ||\r\nmrp_cb(app->pdu)->mh->attrlen != attr->len) {\r\nif (mrp_pdu_append_msg_hdr(app, attr->type, attr->len) < 0)\r\ngoto queue;\r\n}\r\nif (!mrp_cb(app->pdu)->vah ||\r\nmemcmp(mrp_cb(app->pdu)->attrvalue, attr->value, attr->len)) {\r\nif (mrp_pdu_append_vecattr_hdr(app, attr->value, attr->len) < 0)\r\ngoto queue;\r\n}\r\nlen = be16_to_cpu(get_unaligned(&mrp_cb(app->pdu)->vah->lenflags));\r\npos = len % 3;\r\nif (!pos) {\r\nif (skb_tailroom(app->pdu) < sizeof(u8))\r\ngoto queue;\r\nvaevents = __skb_put(app->pdu, sizeof(u8));\r\n} else {\r\nvaevents = (u8 *)(skb_tail_pointer(app->pdu) - sizeof(u8));\r\n}\r\nswitch (pos) {\r\ncase 0:\r\n*vaevents = vaevent * (__MRP_VECATTR_EVENT_MAX *\r\n__MRP_VECATTR_EVENT_MAX);\r\nbreak;\r\ncase 1:\r\n*vaevents += vaevent * __MRP_VECATTR_EVENT_MAX;\r\nbreak;\r\ncase 2:\r\n*vaevents += vaevent;\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\n}\r\nput_unaligned(cpu_to_be16(++len), &mrp_cb(app->pdu)->vah->lenflags);\r\nmrp_attrvalue_inc(mrp_cb(app->pdu)->attrvalue, attr->len);\r\nreturn 0;\r\nqueue:\r\nmrp_pdu_queue(app);\r\ngoto again;\r\n}\r\nstatic void mrp_attr_event(struct mrp_applicant *app,\r\nstruct mrp_attr *attr, enum mrp_event event)\r\n{\r\nenum mrp_applicant_state state;\r\nstate = mrp_applicant_state_table[attr->state][event];\r\nif (state == MRP_APPLICANT_INVALID) {\r\nWARN_ON(1);\r\nreturn;\r\n}\r\nif (event == MRP_EVENT_TX) {\r\nswitch (mrp_tx_action_table[attr->state]) {\r\ncase MRP_TX_ACTION_NONE:\r\ncase MRP_TX_ACTION_S_JOIN_IN_OPTIONAL:\r\ncase MRP_TX_ACTION_S_IN_OPTIONAL:\r\nbreak;\r\ncase MRP_TX_ACTION_S_NEW:\r\nif (mrp_pdu_append_vecattr_event(\r\napp, attr, MRP_VECATTR_EVENT_NEW) < 0)\r\nreturn;\r\nbreak;\r\ncase MRP_TX_ACTION_S_JOIN_IN:\r\nif (mrp_pdu_append_vecattr_event(\r\napp, attr, MRP_VECATTR_EVENT_JOIN_IN) < 0)\r\nreturn;\r\nbreak;\r\ncase MRP_TX_ACTION_S_LV:\r\nif (mrp_pdu_append_vecattr_event(\r\napp, attr, MRP_VECATTR_EVENT_LV) < 0)\r\nreturn;\r\nmrp_attr_destroy(app, attr);\r\nreturn;\r\ndefault:\r\nWARN_ON(1);\r\n}\r\n}\r\nattr->state = state;\r\n}\r\nint mrp_request_join(const struct net_device *dev,\r\nconst struct mrp_application *appl,\r\nconst void *value, u8 len, u8 type)\r\n{\r\nstruct mrp_port *port = rtnl_dereference(dev->mrp_port);\r\nstruct mrp_applicant *app = rtnl_dereference(\r\nport->applicants[appl->type]);\r\nstruct mrp_attr *attr;\r\nif (sizeof(struct mrp_skb_cb) + len >\r\nFIELD_SIZEOF(struct sk_buff, cb))\r\nreturn -ENOMEM;\r\nspin_lock_bh(&app->lock);\r\nattr = mrp_attr_create(app, value, len, type);\r\nif (!attr) {\r\nspin_unlock_bh(&app->lock);\r\nreturn -ENOMEM;\r\n}\r\nmrp_attr_event(app, attr, MRP_EVENT_JOIN);\r\nspin_unlock_bh(&app->lock);\r\nreturn 0;\r\n}\r\nvoid mrp_request_leave(const struct net_device *dev,\r\nconst struct mrp_application *appl,\r\nconst void *value, u8 len, u8 type)\r\n{\r\nstruct mrp_port *port = rtnl_dereference(dev->mrp_port);\r\nstruct mrp_applicant *app = rtnl_dereference(\r\nport->applicants[appl->type]);\r\nstruct mrp_attr *attr;\r\nif (sizeof(struct mrp_skb_cb) + len >\r\nFIELD_SIZEOF(struct sk_buff, cb))\r\nreturn;\r\nspin_lock_bh(&app->lock);\r\nattr = mrp_attr_lookup(app, value, len, type);\r\nif (!attr) {\r\nspin_unlock_bh(&app->lock);\r\nreturn;\r\n}\r\nmrp_attr_event(app, attr, MRP_EVENT_LV);\r\nspin_unlock_bh(&app->lock);\r\n}\r\nstatic void mrp_mad_event(struct mrp_applicant *app, enum mrp_event event)\r\n{\r\nstruct rb_node *node, *next;\r\nstruct mrp_attr *attr;\r\nfor (node = rb_first(&app->mad);\r\nnext = node ? rb_next(node) : NULL, node != NULL;\r\nnode = next) {\r\nattr = rb_entry(node, struct mrp_attr, node);\r\nmrp_attr_event(app, attr, event);\r\n}\r\n}\r\nstatic void mrp_join_timer_arm(struct mrp_applicant *app)\r\n{\r\nunsigned long delay;\r\ndelay = (u64)msecs_to_jiffies(mrp_join_time) * prandom_u32() >> 32;\r\nmod_timer(&app->join_timer, jiffies + delay);\r\n}\r\nstatic void mrp_join_timer(unsigned long data)\r\n{\r\nstruct mrp_applicant *app = (struct mrp_applicant *)data;\r\nspin_lock(&app->lock);\r\nmrp_mad_event(app, MRP_EVENT_TX);\r\nmrp_pdu_queue(app);\r\nspin_unlock(&app->lock);\r\nmrp_queue_xmit(app);\r\nmrp_join_timer_arm(app);\r\n}\r\nstatic void mrp_periodic_timer_arm(struct mrp_applicant *app)\r\n{\r\nmod_timer(&app->periodic_timer,\r\njiffies + msecs_to_jiffies(mrp_periodic_time));\r\n}\r\nstatic void mrp_periodic_timer(unsigned long data)\r\n{\r\nstruct mrp_applicant *app = (struct mrp_applicant *)data;\r\nspin_lock(&app->lock);\r\nmrp_mad_event(app, MRP_EVENT_PERIODIC);\r\nmrp_pdu_queue(app);\r\nspin_unlock(&app->lock);\r\nmrp_periodic_timer_arm(app);\r\n}\r\nstatic int mrp_pdu_parse_end_mark(struct sk_buff *skb, int *offset)\r\n{\r\n__be16 endmark;\r\nif (skb_copy_bits(skb, *offset, &endmark, sizeof(endmark)) < 0)\r\nreturn -1;\r\nif (endmark == MRP_END_MARK) {\r\n*offset += sizeof(endmark);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mrp_pdu_parse_vecattr_event(struct mrp_applicant *app,\r\nstruct sk_buff *skb,\r\nenum mrp_vecattr_event vaevent)\r\n{\r\nstruct mrp_attr *attr;\r\nenum mrp_event event;\r\nattr = mrp_attr_lookup(app, mrp_cb(skb)->attrvalue,\r\nmrp_cb(skb)->mh->attrlen,\r\nmrp_cb(skb)->mh->attrtype);\r\nif (attr == NULL)\r\nreturn;\r\nswitch (vaevent) {\r\ncase MRP_VECATTR_EVENT_NEW:\r\nevent = MRP_EVENT_R_NEW;\r\nbreak;\r\ncase MRP_VECATTR_EVENT_JOIN_IN:\r\nevent = MRP_EVENT_R_JOIN_IN;\r\nbreak;\r\ncase MRP_VECATTR_EVENT_IN:\r\nevent = MRP_EVENT_R_IN;\r\nbreak;\r\ncase MRP_VECATTR_EVENT_JOIN_MT:\r\nevent = MRP_EVENT_R_JOIN_MT;\r\nbreak;\r\ncase MRP_VECATTR_EVENT_MT:\r\nevent = MRP_EVENT_R_MT;\r\nbreak;\r\ncase MRP_VECATTR_EVENT_LV:\r\nevent = MRP_EVENT_R_LV;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nmrp_attr_event(app, attr, event);\r\n}\r\nstatic int mrp_pdu_parse_vecattr(struct mrp_applicant *app,\r\nstruct sk_buff *skb, int *offset)\r\n{\r\nstruct mrp_vecattr_hdr _vah;\r\nu16 valen;\r\nu8 vaevents, vaevent;\r\nmrp_cb(skb)->vah = skb_header_pointer(skb, *offset, sizeof(_vah),\r\n&_vah);\r\nif (!mrp_cb(skb)->vah)\r\nreturn -1;\r\n*offset += sizeof(_vah);\r\nif (get_unaligned(&mrp_cb(skb)->vah->lenflags) &\r\nMRP_VECATTR_HDR_FLAG_LA)\r\nmrp_mad_event(app, MRP_EVENT_R_LA);\r\nvalen = be16_to_cpu(get_unaligned(&mrp_cb(skb)->vah->lenflags) &\r\nMRP_VECATTR_HDR_LEN_MASK);\r\nif (sizeof(struct mrp_skb_cb) + mrp_cb(skb)->mh->attrlen >\r\nFIELD_SIZEOF(struct sk_buff, cb))\r\nreturn -1;\r\nif (skb_copy_bits(skb, *offset, mrp_cb(skb)->attrvalue,\r\nmrp_cb(skb)->mh->attrlen) < 0)\r\nreturn -1;\r\n*offset += mrp_cb(skb)->mh->attrlen;\r\nwhile (valen > 0) {\r\nif (skb_copy_bits(skb, *offset, &vaevents,\r\nsizeof(vaevents)) < 0)\r\nreturn -1;\r\n*offset += sizeof(vaevents);\r\nvaevent = vaevents / (__MRP_VECATTR_EVENT_MAX *\r\n__MRP_VECATTR_EVENT_MAX);\r\nif (vaevent >= __MRP_VECATTR_EVENT_MAX) {\r\nreturn -1;\r\n}\r\nmrp_pdu_parse_vecattr_event(app, skb, vaevent);\r\nif (!--valen)\r\nbreak;\r\nmrp_attrvalue_inc(mrp_cb(skb)->attrvalue,\r\nmrp_cb(skb)->mh->attrlen);\r\nvaevents %= (__MRP_VECATTR_EVENT_MAX *\r\n__MRP_VECATTR_EVENT_MAX);\r\nvaevent = vaevents / __MRP_VECATTR_EVENT_MAX;\r\nmrp_pdu_parse_vecattr_event(app, skb, vaevent);\r\nif (!--valen)\r\nbreak;\r\nmrp_attrvalue_inc(mrp_cb(skb)->attrvalue,\r\nmrp_cb(skb)->mh->attrlen);\r\nvaevents %= __MRP_VECATTR_EVENT_MAX;\r\nvaevent = vaevents;\r\nmrp_pdu_parse_vecattr_event(app, skb, vaevent);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mrp_pdu_parse_msg(struct mrp_applicant *app, struct sk_buff *skb,\r\nint *offset)\r\n{\r\nstruct mrp_msg_hdr _mh;\r\nmrp_cb(skb)->mh = skb_header_pointer(skb, *offset, sizeof(_mh), &_mh);\r\nif (!mrp_cb(skb)->mh)\r\nreturn -1;\r\n*offset += sizeof(_mh);\r\nif (mrp_cb(skb)->mh->attrtype == 0 ||\r\nmrp_cb(skb)->mh->attrtype > app->app->maxattr ||\r\nmrp_cb(skb)->mh->attrlen == 0)\r\nreturn -1;\r\nwhile (skb->len > *offset) {\r\nif (mrp_pdu_parse_end_mark(skb, offset) < 0)\r\nbreak;\r\nif (mrp_pdu_parse_vecattr(app, skb, offset) < 0)\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mrp_rcv(struct sk_buff *skb, struct net_device *dev,\r\nstruct packet_type *pt, struct net_device *orig_dev)\r\n{\r\nstruct mrp_application *appl = container_of(pt, struct mrp_application,\r\npkttype);\r\nstruct mrp_port *port;\r\nstruct mrp_applicant *app;\r\nstruct mrp_pdu_hdr _ph;\r\nconst struct mrp_pdu_hdr *ph;\r\nint offset = skb_network_offset(skb);\r\nif (unlikely(skb->pkt_type == PACKET_OTHERHOST))\r\ngoto out;\r\nskb = skb_share_check(skb, GFP_ATOMIC);\r\nif (unlikely(!skb))\r\ngoto out;\r\nport = rcu_dereference(dev->mrp_port);\r\nif (unlikely(!port))\r\ngoto out;\r\napp = rcu_dereference(port->applicants[appl->type]);\r\nif (unlikely(!app))\r\ngoto out;\r\nph = skb_header_pointer(skb, offset, sizeof(_ph), &_ph);\r\nif (!ph)\r\ngoto out;\r\noffset += sizeof(_ph);\r\nif (ph->version != app->app->version)\r\ngoto out;\r\nspin_lock(&app->lock);\r\nwhile (skb->len > offset) {\r\nif (mrp_pdu_parse_end_mark(skb, &offset) < 0)\r\nbreak;\r\nif (mrp_pdu_parse_msg(app, skb, &offset) < 0)\r\nbreak;\r\n}\r\nspin_unlock(&app->lock);\r\nout:\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int mrp_init_port(struct net_device *dev)\r\n{\r\nstruct mrp_port *port;\r\nport = kzalloc(sizeof(*port), GFP_KERNEL);\r\nif (!port)\r\nreturn -ENOMEM;\r\nrcu_assign_pointer(dev->mrp_port, port);\r\nreturn 0;\r\n}\r\nstatic void mrp_release_port(struct net_device *dev)\r\n{\r\nstruct mrp_port *port = rtnl_dereference(dev->mrp_port);\r\nunsigned int i;\r\nfor (i = 0; i <= MRP_APPLICATION_MAX; i++) {\r\nif (rtnl_dereference(port->applicants[i]))\r\nreturn;\r\n}\r\nRCU_INIT_POINTER(dev->mrp_port, NULL);\r\nkfree_rcu(port, rcu);\r\n}\r\nint mrp_init_applicant(struct net_device *dev, struct mrp_application *appl)\r\n{\r\nstruct mrp_applicant *app;\r\nint err;\r\nASSERT_RTNL();\r\nif (!rtnl_dereference(dev->mrp_port)) {\r\nerr = mrp_init_port(dev);\r\nif (err < 0)\r\ngoto err1;\r\n}\r\nerr = -ENOMEM;\r\napp = kzalloc(sizeof(*app), GFP_KERNEL);\r\nif (!app)\r\ngoto err2;\r\nerr = dev_mc_add(dev, appl->group_address);\r\nif (err < 0)\r\ngoto err3;\r\napp->dev = dev;\r\napp->app = appl;\r\napp->mad = RB_ROOT;\r\nspin_lock_init(&app->lock);\r\nskb_queue_head_init(&app->queue);\r\nrcu_assign_pointer(dev->mrp_port->applicants[appl->type], app);\r\nsetup_timer(&app->join_timer, mrp_join_timer, (unsigned long)app);\r\nmrp_join_timer_arm(app);\r\nsetup_timer(&app->periodic_timer, mrp_periodic_timer,\r\n(unsigned long)app);\r\nmrp_periodic_timer_arm(app);\r\nreturn 0;\r\nerr3:\r\nkfree(app);\r\nerr2:\r\nmrp_release_port(dev);\r\nerr1:\r\nreturn err;\r\n}\r\nvoid mrp_uninit_applicant(struct net_device *dev, struct mrp_application *appl)\r\n{\r\nstruct mrp_port *port = rtnl_dereference(dev->mrp_port);\r\nstruct mrp_applicant *app = rtnl_dereference(\r\nport->applicants[appl->type]);\r\nASSERT_RTNL();\r\nRCU_INIT_POINTER(port->applicants[appl->type], NULL);\r\ndel_timer_sync(&app->join_timer);\r\ndel_timer_sync(&app->periodic_timer);\r\nspin_lock_bh(&app->lock);\r\nmrp_mad_event(app, MRP_EVENT_TX);\r\nmrp_pdu_queue(app);\r\nspin_unlock_bh(&app->lock);\r\nmrp_queue_xmit(app);\r\ndev_mc_del(dev, appl->group_address);\r\nkfree_rcu(app, rcu);\r\nmrp_release_port(dev);\r\n}\r\nint mrp_register_application(struct mrp_application *appl)\r\n{\r\nappl->pkttype.func = mrp_rcv;\r\ndev_add_pack(&appl->pkttype);\r\nreturn 0;\r\n}\r\nvoid mrp_unregister_application(struct mrp_application *appl)\r\n{\r\ndev_remove_pack(&appl->pkttype);\r\n}
