static void event_seq_changed(struct venus_core *core, struct venus_inst *inst,\r\nstruct hfi_msg_event_notify_pkt *pkt)\r\n{\r\nstruct hfi_event_data event = {0};\r\nint num_properties_changed;\r\nstruct hfi_framesize *frame_sz;\r\nstruct hfi_profile_level *profile_level;\r\nu8 *data_ptr;\r\nu32 ptype;\r\ninst->error = HFI_ERR_NONE;\r\nswitch (pkt->event_data1) {\r\ncase HFI_EVENT_DATA_SEQUENCE_CHANGED_SUFFICIENT_BUF_RESOURCES:\r\ncase HFI_EVENT_DATA_SEQUENCE_CHANGED_INSUFFICIENT_BUF_RESOURCES:\r\nbreak;\r\ndefault:\r\ninst->error = HFI_ERR_SESSION_INVALID_PARAMETER;\r\ngoto done;\r\n}\r\nevent.event_type = pkt->event_data1;\r\nnum_properties_changed = pkt->event_data2;\r\nif (!num_properties_changed) {\r\ninst->error = HFI_ERR_SESSION_INSUFFICIENT_RESOURCES;\r\ngoto done;\r\n}\r\ndata_ptr = (u8 *)&pkt->ext_event_data[0];\r\ndo {\r\nptype = *((u32 *)data_ptr);\r\nswitch (ptype) {\r\ncase HFI_PROPERTY_PARAM_FRAME_SIZE:\r\ndata_ptr += sizeof(u32);\r\nframe_sz = (struct hfi_framesize *)data_ptr;\r\nevent.width = frame_sz->width;\r\nevent.height = frame_sz->height;\r\ndata_ptr += sizeof(frame_sz);\r\nbreak;\r\ncase HFI_PROPERTY_PARAM_PROFILE_LEVEL_CURRENT:\r\ndata_ptr += sizeof(u32);\r\nprofile_level = (struct hfi_profile_level *)data_ptr;\r\nevent.profile = profile_level->profile;\r\nevent.level = profile_level->level;\r\ndata_ptr += sizeof(profile_level);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nnum_properties_changed--;\r\n} while (num_properties_changed > 0);\r\ndone:\r\ninst->ops->event_notify(inst, EVT_SYS_EVENT_CHANGE, &event);\r\n}\r\nstatic void event_release_buffer_ref(struct venus_core *core,\r\nstruct venus_inst *inst,\r\nstruct hfi_msg_event_notify_pkt *pkt)\r\n{\r\nstruct hfi_event_data event = {0};\r\nstruct hfi_msg_event_release_buffer_ref_pkt *data;\r\ndata = (struct hfi_msg_event_release_buffer_ref_pkt *)\r\npkt->ext_event_data;\r\nevent.event_type = HFI_EVENT_RELEASE_BUFFER_REFERENCE;\r\nevent.packet_buffer = data->packet_buffer;\r\nevent.extradata_buffer = data->extradata_buffer;\r\nevent.tag = data->output_tag;\r\ninst->error = HFI_ERR_NONE;\r\ninst->ops->event_notify(inst, EVT_SYS_EVENT_CHANGE, &event);\r\n}\r\nstatic void event_sys_error(struct venus_core *core, u32 event,\r\nstruct hfi_msg_event_notify_pkt *pkt)\r\n{\r\nif (pkt)\r\ndev_dbg(core->dev,\r\n"sys error (session id:%x, data1:%x, data2:%x)\n",\r\npkt->shdr.session_id, pkt->event_data1,\r\npkt->event_data2);\r\ncore->core_ops->event_notify(core, event);\r\n}\r\nstatic void\r\nevent_session_error(struct venus_core *core, struct venus_inst *inst,\r\nstruct hfi_msg_event_notify_pkt *pkt)\r\n{\r\nstruct device *dev = core->dev;\r\ndev_dbg(dev, "session error: event id:%x, session id:%x\n",\r\npkt->event_data1, pkt->shdr.session_id);\r\nif (!inst)\r\nreturn;\r\nswitch (pkt->event_data1) {\r\ncase HFI_ERR_SESSION_INVALID_SCALE_FACTOR:\r\ncase HFI_ERR_SESSION_UNSUPPORT_BUFFERTYPE:\r\ncase HFI_ERR_SESSION_UNSUPPORTED_SETTING:\r\ncase HFI_ERR_SESSION_UPSCALE_NOT_SUPPORTED:\r\ninst->error = HFI_ERR_NONE;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "session error: event id:%x (%x), session id:%x\n",\r\npkt->event_data1, pkt->event_data2,\r\npkt->shdr.session_id);\r\ninst->error = pkt->event_data1;\r\ninst->ops->event_notify(inst, EVT_SESSION_ERROR, NULL);\r\nbreak;\r\n}\r\n}\r\nstatic void hfi_event_notify(struct venus_core *core, struct venus_inst *inst,\r\nvoid *packet)\r\n{\r\nstruct hfi_msg_event_notify_pkt *pkt = packet;\r\nif (!packet)\r\nreturn;\r\nswitch (pkt->event_id) {\r\ncase HFI_EVENT_SYS_ERROR:\r\nevent_sys_error(core, EVT_SYS_ERROR, pkt);\r\nbreak;\r\ncase HFI_EVENT_SESSION_ERROR:\r\nevent_session_error(core, inst, pkt);\r\nbreak;\r\ncase HFI_EVENT_SESSION_SEQUENCE_CHANGED:\r\nevent_seq_changed(core, inst, pkt);\r\nbreak;\r\ncase HFI_EVENT_RELEASE_BUFFER_REFERENCE:\r\nevent_release_buffer_ref(core, inst, pkt);\r\nbreak;\r\ncase HFI_EVENT_SESSION_PROPERTY_CHANGED:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void hfi_sys_init_done(struct venus_core *core, struct venus_inst *inst,\r\nvoid *packet)\r\n{\r\nstruct hfi_msg_sys_init_done_pkt *pkt = packet;\r\nu32 rem_bytes, read_bytes = 0, num_properties;\r\nu32 error, ptype;\r\nu8 *data;\r\nerror = pkt->error_type;\r\nif (error != HFI_ERR_NONE)\r\ngoto err_no_prop;\r\nnum_properties = pkt->num_properties;\r\nif (!num_properties) {\r\nerror = HFI_ERR_SYS_INVALID_PARAMETER;\r\ngoto err_no_prop;\r\n}\r\nrem_bytes = pkt->hdr.size - sizeof(*pkt) + sizeof(u32);\r\nif (!rem_bytes) {\r\nerror = HFI_ERR_SYS_INSUFFICIENT_RESOURCES;\r\ngoto err_no_prop;\r\n}\r\ndata = (u8 *)&pkt->data[0];\r\nif (core->res->hfi_version == HFI_VERSION_3XX)\r\ngoto err_no_prop;\r\nwhile (num_properties && rem_bytes >= sizeof(u32)) {\r\nptype = *((u32 *)data);\r\ndata += sizeof(u32);\r\nswitch (ptype) {\r\ncase HFI_PROPERTY_PARAM_CODEC_SUPPORTED: {\r\nstruct hfi_codec_supported *prop;\r\nprop = (struct hfi_codec_supported *)data;\r\nif (rem_bytes < sizeof(*prop)) {\r\nerror = HFI_ERR_SYS_INSUFFICIENT_RESOURCES;\r\nbreak;\r\n}\r\nread_bytes += sizeof(*prop) + sizeof(u32);\r\ncore->dec_codecs = prop->dec_codecs;\r\ncore->enc_codecs = prop->enc_codecs;\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_MAX_SESSIONS_SUPPORTED: {\r\nstruct hfi_max_sessions_supported *prop;\r\nif (rem_bytes < sizeof(*prop)) {\r\nerror = HFI_ERR_SYS_INSUFFICIENT_RESOURCES;\r\nbreak;\r\n}\r\nprop = (struct hfi_max_sessions_supported *)data;\r\nread_bytes += sizeof(*prop) + sizeof(u32);\r\ncore->max_sessions_supported = prop->max_sessions;\r\nbreak;\r\n}\r\ndefault:\r\nerror = HFI_ERR_SYS_INVALID_PARAMETER;\r\nbreak;\r\n}\r\nif (error)\r\nbreak;\r\nrem_bytes -= read_bytes;\r\ndata += read_bytes;\r\nnum_properties--;\r\n}\r\nerr_no_prop:\r\ncore->error = error;\r\ncomplete(&core->done);\r\n}\r\nstatic void\r\nsys_get_prop_image_version(struct device *dev,\r\nstruct hfi_msg_sys_property_info_pkt *pkt)\r\n{\r\nint req_bytes;\r\nreq_bytes = pkt->hdr.size - sizeof(*pkt);\r\nif (req_bytes < 128 || !pkt->data[1] || pkt->num_properties > 1)\r\nreturn;\r\ndev_dbg(dev, "F/W version: %s\n", (u8 *)&pkt->data[1]);\r\n}\r\nstatic void hfi_sys_property_info(struct venus_core *core,\r\nstruct venus_inst *inst, void *packet)\r\n{\r\nstruct hfi_msg_sys_property_info_pkt *pkt = packet;\r\nstruct device *dev = core->dev;\r\nif (!pkt->num_properties) {\r\ndev_dbg(dev, "%s: no properties\n", __func__);\r\nreturn;\r\n}\r\nswitch (pkt->data[0]) {\r\ncase HFI_PROPERTY_SYS_IMAGE_VERSION:\r\nsys_get_prop_image_version(dev, pkt);\r\nbreak;\r\ndefault:\r\ndev_dbg(dev, "%s: unknown property data\n", __func__);\r\nbreak;\r\n}\r\n}\r\nstatic void hfi_sys_rel_resource_done(struct venus_core *core,\r\nstruct venus_inst *inst,\r\nvoid *packet)\r\n{\r\nstruct hfi_msg_sys_release_resource_done_pkt *pkt = packet;\r\ncore->error = pkt->error_type;\r\ncomplete(&core->done);\r\n}\r\nstatic void hfi_sys_ping_done(struct venus_core *core, struct venus_inst *inst,\r\nvoid *packet)\r\n{\r\nstruct hfi_msg_sys_ping_ack_pkt *pkt = packet;\r\ncore->error = HFI_ERR_NONE;\r\nif (pkt->client_data != 0xbeef)\r\ncore->error = HFI_ERR_SYS_FATAL;\r\ncomplete(&core->done);\r\n}\r\nstatic void hfi_sys_idle_done(struct venus_core *core, struct venus_inst *inst,\r\nvoid *packet)\r\n{\r\ndev_dbg(core->dev, "sys idle\n");\r\n}\r\nstatic void hfi_sys_pc_prepare_done(struct venus_core *core,\r\nstruct venus_inst *inst, void *packet)\r\n{\r\nstruct hfi_msg_sys_pc_prep_done_pkt *pkt = packet;\r\ndev_dbg(core->dev, "pc prepare done (error %x)\n", pkt->error_type);\r\n}\r\nstatic void\r\nhfi_copy_cap_prop(struct hfi_capability *in, struct venus_inst *inst)\r\n{\r\nif (!in || !inst)\r\nreturn;\r\nswitch (in->capability_type) {\r\ncase HFI_CAPABILITY_FRAME_WIDTH:\r\ninst->cap_width = *in;\r\nbreak;\r\ncase HFI_CAPABILITY_FRAME_HEIGHT:\r\ninst->cap_height = *in;\r\nbreak;\r\ncase HFI_CAPABILITY_MBS_PER_FRAME:\r\ninst->cap_mbs_per_frame = *in;\r\nbreak;\r\ncase HFI_CAPABILITY_MBS_PER_SECOND:\r\ninst->cap_mbs_per_sec = *in;\r\nbreak;\r\ncase HFI_CAPABILITY_FRAMERATE:\r\ninst->cap_framerate = *in;\r\nbreak;\r\ncase HFI_CAPABILITY_SCALE_X:\r\ninst->cap_scale_x = *in;\r\nbreak;\r\ncase HFI_CAPABILITY_SCALE_Y:\r\ninst->cap_scale_y = *in;\r\nbreak;\r\ncase HFI_CAPABILITY_BITRATE:\r\ninst->cap_bitrate = *in;\r\nbreak;\r\ncase HFI_CAPABILITY_HIER_P_NUM_ENH_LAYERS:\r\ninst->cap_hier_p = *in;\r\nbreak;\r\ncase HFI_CAPABILITY_ENC_LTR_COUNT:\r\ninst->cap_ltr_count = *in;\r\nbreak;\r\ncase HFI_CAPABILITY_CP_OUTPUT2_THRESH:\r\ninst->cap_secure_output2_threshold = *in;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic unsigned int\r\nsession_get_prop_profile_level(struct hfi_msg_session_property_info_pkt *pkt,\r\nstruct hfi_profile_level *profile_level)\r\n{\r\nstruct hfi_profile_level *hfi;\r\nu32 req_bytes;\r\nreq_bytes = pkt->shdr.hdr.size - sizeof(*pkt);\r\nif (!req_bytes || req_bytes % sizeof(struct hfi_profile_level))\r\nreturn HFI_ERR_SESSION_INVALID_PARAMETER;\r\nhfi = (struct hfi_profile_level *)&pkt->data[1];\r\nprofile_level->profile = hfi->profile;\r\nprofile_level->level = hfi->level;\r\nreturn HFI_ERR_NONE;\r\n}\r\nstatic unsigned int\r\nsession_get_prop_buf_req(struct hfi_msg_session_property_info_pkt *pkt,\r\nstruct hfi_buffer_requirements *bufreq)\r\n{\r\nstruct hfi_buffer_requirements *buf_req;\r\nu32 req_bytes;\r\nunsigned int idx = 0;\r\nreq_bytes = pkt->shdr.hdr.size - sizeof(*pkt);\r\nif (!req_bytes || req_bytes % sizeof(*buf_req) || !pkt->data[1])\r\nreturn HFI_ERR_SESSION_INVALID_PARAMETER;\r\nbuf_req = (struct hfi_buffer_requirements *)&pkt->data[1];\r\nif (!buf_req)\r\nreturn HFI_ERR_SESSION_INVALID_PARAMETER;\r\nwhile (req_bytes) {\r\nmemcpy(&bufreq[idx], buf_req, sizeof(*bufreq));\r\nidx++;\r\nif (idx > HFI_BUFFER_TYPE_MAX)\r\nreturn HFI_ERR_SESSION_INVALID_PARAMETER;\r\nreq_bytes -= sizeof(struct hfi_buffer_requirements);\r\nbuf_req++;\r\n}\r\nreturn HFI_ERR_NONE;\r\n}\r\nstatic void hfi_session_prop_info(struct venus_core *core,\r\nstruct venus_inst *inst, void *packet)\r\n{\r\nstruct hfi_msg_session_property_info_pkt *pkt = packet;\r\nstruct device *dev = core->dev;\r\nunion hfi_get_property *hprop = &inst->hprop;\r\nunsigned int error = HFI_ERR_NONE;\r\nif (!pkt->num_properties) {\r\nerror = HFI_ERR_SESSION_INVALID_PARAMETER;\r\ndev_err(dev, "%s: no properties\n", __func__);\r\ngoto done;\r\n}\r\nswitch (pkt->data[0]) {\r\ncase HFI_PROPERTY_CONFIG_BUFFER_REQUIREMENTS:\r\nmemset(hprop->bufreq, 0, sizeof(hprop->bufreq));\r\nerror = session_get_prop_buf_req(pkt, hprop->bufreq);\r\nbreak;\r\ncase HFI_PROPERTY_PARAM_PROFILE_LEVEL_CURRENT:\r\nmemset(&hprop->profile_level, 0, sizeof(hprop->profile_level));\r\nerror = session_get_prop_profile_level(pkt,\r\n&hprop->profile_level);\r\nbreak;\r\ncase HFI_PROPERTY_CONFIG_VDEC_ENTROPY:\r\nbreak;\r\ndefault:\r\ndev_dbg(dev, "%s: unknown property id:%x\n", __func__,\r\npkt->data[0]);\r\nreturn;\r\n}\r\ndone:\r\ninst->error = error;\r\ncomplete(&inst->done);\r\n}\r\nstatic u32 init_done_read_prop(struct venus_core *core, struct venus_inst *inst,\r\nstruct hfi_msg_session_init_done_pkt *pkt)\r\n{\r\nstruct device *dev = core->dev;\r\nu32 rem_bytes, num_props;\r\nu32 ptype, next_offset = 0;\r\nu32 err;\r\nu8 *data;\r\nrem_bytes = pkt->shdr.hdr.size - sizeof(*pkt) + sizeof(u32);\r\nif (!rem_bytes) {\r\ndev_err(dev, "%s: missing property info\n", __func__);\r\nreturn HFI_ERR_SESSION_INSUFFICIENT_RESOURCES;\r\n}\r\nerr = pkt->error_type;\r\nif (err)\r\nreturn err;\r\ndata = (u8 *)&pkt->data[0];\r\nnum_props = pkt->num_properties;\r\nwhile (err == HFI_ERR_NONE && num_props && rem_bytes >= sizeof(u32)) {\r\nptype = *((u32 *)data);\r\nnext_offset = sizeof(u32);\r\nswitch (ptype) {\r\ncase HFI_PROPERTY_PARAM_CODEC_MASK_SUPPORTED: {\r\nstruct hfi_codec_mask_supported *masks =\r\n(struct hfi_codec_mask_supported *)\r\n(data + next_offset);\r\nnext_offset += sizeof(*masks);\r\nnum_props--;\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_CAPABILITY_SUPPORTED: {\r\nstruct hfi_capabilities *caps;\r\nstruct hfi_capability *cap;\r\nu32 num_caps;\r\nif ((rem_bytes - next_offset) < sizeof(*cap)) {\r\nerr = HFI_ERR_SESSION_INVALID_PARAMETER;\r\nbreak;\r\n}\r\ncaps = (struct hfi_capabilities *)(data + next_offset);\r\nnum_caps = caps->num_capabilities;\r\ncap = &caps->data[0];\r\nnext_offset += sizeof(u32);\r\nwhile (num_caps &&\r\n(rem_bytes - next_offset) >= sizeof(u32)) {\r\nhfi_copy_cap_prop(cap, inst);\r\ncap++;\r\nnext_offset += sizeof(*cap);\r\nnum_caps--;\r\n}\r\nnum_props--;\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_UNCOMPRESSED_FORMAT_SUPPORTED: {\r\nstruct hfi_uncompressed_format_supported *prop =\r\n(struct hfi_uncompressed_format_supported *)\r\n(data + next_offset);\r\nu32 num_fmt_entries;\r\nu8 *fmt;\r\nstruct hfi_uncompressed_plane_info *inf;\r\nif ((rem_bytes - next_offset) < sizeof(*prop)) {\r\nerr = HFI_ERR_SESSION_INVALID_PARAMETER;\r\nbreak;\r\n}\r\nnum_fmt_entries = prop->format_entries;\r\nnext_offset = sizeof(*prop) - sizeof(u32);\r\nfmt = (u8 *)&prop->format_info[0];\r\ndev_dbg(dev, "uncomm format support num entries:%u\n",\r\nnum_fmt_entries);\r\nwhile (num_fmt_entries) {\r\nstruct hfi_uncompressed_plane_constraints *cnts;\r\nu32 bytes_to_skip;\r\ninf = (struct hfi_uncompressed_plane_info *)fmt;\r\nif ((rem_bytes - next_offset) < sizeof(*inf)) {\r\nerr = HFI_ERR_SESSION_INVALID_PARAMETER;\r\nbreak;\r\n}\r\ndev_dbg(dev, "plane info: fmt:%x, planes:%x\n",\r\ninf->format, inf->num_planes);\r\ncnts = &inf->plane_format[0];\r\ndev_dbg(dev, "%u %u %u %u\n",\r\ncnts->stride_multiples,\r\ncnts->max_stride,\r\ncnts->min_plane_buffer_height_multiple,\r\ncnts->buffer_alignment);\r\nbytes_to_skip = sizeof(*inf) - sizeof(*cnts) +\r\ninf->num_planes * sizeof(*cnts);\r\nfmt += bytes_to_skip;\r\nnext_offset += bytes_to_skip;\r\nnum_fmt_entries--;\r\n}\r\nnum_props--;\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_PROPERTIES_SUPPORTED: {\r\nstruct hfi_properties_supported *prop =\r\n(struct hfi_properties_supported *)\r\n(data + next_offset);\r\nnext_offset += sizeof(*prop) - sizeof(u32)\r\n+ prop->num_properties * sizeof(u32);\r\nnum_props--;\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_PROFILE_LEVEL_SUPPORTED: {\r\nstruct hfi_profile_level_supported *prop =\r\n(struct hfi_profile_level_supported *)\r\n(data + next_offset);\r\nstruct hfi_profile_level *pl;\r\nunsigned int prop_count = 0;\r\nunsigned int count = 0;\r\nu8 *ptr;\r\nptr = (u8 *)&prop->profile_level[0];\r\nprop_count = prop->profile_count;\r\nif (prop_count > HFI_MAX_PROFILE_COUNT)\r\nprop_count = HFI_MAX_PROFILE_COUNT;\r\nwhile (prop_count) {\r\nptr++;\r\npl = (struct hfi_profile_level *)ptr;\r\ninst->pl[count].profile = pl->profile;\r\ninst->pl[count].level = pl->level;\r\nprop_count--;\r\ncount++;\r\nptr += sizeof(*pl) / sizeof(u32);\r\n}\r\ninst->pl_count = count;\r\nnext_offset += sizeof(*prop) - sizeof(*pl) +\r\nprop->profile_count * sizeof(*pl);\r\nnum_props--;\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_INTERLACE_FORMAT_SUPPORTED: {\r\nnext_offset +=\r\nsizeof(struct hfi_interlace_format_supported);\r\nnum_props--;\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_NAL_STREAM_FORMAT_SUPPORTED: {\r\nstruct hfi_nal_stream_format *nal =\r\n(struct hfi_nal_stream_format *)\r\n(data + next_offset);\r\ndev_dbg(dev, "NAL format: %x\n", nal->format);\r\nnext_offset += sizeof(*nal);\r\nnum_props--;\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_NAL_STREAM_FORMAT_SELECT: {\r\nnext_offset += sizeof(u32);\r\nnum_props--;\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_MAX_SEQUENCE_HEADER_SIZE: {\r\nu32 *max_seq_sz = (u32 *)(data + next_offset);\r\ndev_dbg(dev, "max seq header sz: %x\n", *max_seq_sz);\r\nnext_offset += sizeof(u32);\r\nnum_props--;\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_VENC_INTRA_REFRESH: {\r\nnext_offset += sizeof(struct hfi_intra_refresh);\r\nnum_props--;\r\nbreak;\r\n}\r\ncase HFI_PROPERTY_PARAM_BUFFER_ALLOC_MODE_SUPPORTED: {\r\nstruct hfi_buffer_alloc_mode_supported *prop =\r\n(struct hfi_buffer_alloc_mode_supported *)\r\n(data + next_offset);\r\nunsigned int i;\r\nfor (i = 0; i < prop->num_entries; i++) {\r\nif (prop->buffer_type == HFI_BUFFER_OUTPUT ||\r\nprop->buffer_type == HFI_BUFFER_OUTPUT2) {\r\nswitch (prop->data[i]) {\r\ncase HFI_BUFFER_MODE_STATIC:\r\ninst->cap_bufs_mode_static = 1;\r\nbreak;\r\ncase HFI_BUFFER_MODE_DYNAMIC:\r\ninst->cap_bufs_mode_dynamic = 1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nnext_offset += sizeof(*prop) -\r\nsizeof(u32) + prop->num_entries * sizeof(u32);\r\nnum_props--;\r\nbreak;\r\n}\r\ndefault:\r\ndev_dbg(dev, "%s: default case %#x\n", __func__, ptype);\r\nbreak;\r\n}\r\nrem_bytes -= next_offset;\r\ndata += next_offset;\r\n}\r\nreturn err;\r\n}\r\nstatic void hfi_session_init_done(struct venus_core *core,\r\nstruct venus_inst *inst, void *packet)\r\n{\r\nstruct hfi_msg_session_init_done_pkt *pkt = packet;\r\nunsigned int error;\r\nerror = pkt->error_type;\r\nif (error != HFI_ERR_NONE)\r\ngoto done;\r\nif (core->res->hfi_version != HFI_VERSION_1XX)\r\ngoto done;\r\nerror = init_done_read_prop(core, inst, pkt);\r\ndone:\r\ninst->error = error;\r\ncomplete(&inst->done);\r\n}\r\nstatic void hfi_session_load_res_done(struct venus_core *core,\r\nstruct venus_inst *inst, void *packet)\r\n{\r\nstruct hfi_msg_session_load_resources_done_pkt *pkt = packet;\r\ninst->error = pkt->error_type;\r\ncomplete(&inst->done);\r\n}\r\nstatic void hfi_session_flush_done(struct venus_core *core,\r\nstruct venus_inst *inst, void *packet)\r\n{\r\nstruct hfi_msg_session_flush_done_pkt *pkt = packet;\r\ninst->error = pkt->error_type;\r\ncomplete(&inst->done);\r\n}\r\nstatic void hfi_session_etb_done(struct venus_core *core,\r\nstruct venus_inst *inst, void *packet)\r\n{\r\nstruct hfi_msg_session_empty_buffer_done_pkt *pkt = packet;\r\ninst->error = pkt->error_type;\r\ninst->ops->buf_done(inst, HFI_BUFFER_INPUT, pkt->input_tag,\r\npkt->filled_len, pkt->offset, 0, 0, 0);\r\n}\r\nstatic void hfi_session_ftb_done(struct venus_core *core,\r\nstruct venus_inst *inst, void *packet)\r\n{\r\nu32 session_type = inst->session_type;\r\nu64 timestamp_us = 0;\r\nu32 timestamp_hi = 0, timestamp_lo = 0;\r\nunsigned int error;\r\nu32 flags = 0, hfi_flags = 0, offset = 0, filled_len = 0;\r\nu32 pic_type = 0, buffer_type = 0, output_tag = -1;\r\nif (session_type == VIDC_SESSION_TYPE_ENC) {\r\nstruct hfi_msg_session_fbd_compressed_pkt *pkt = packet;\r\ntimestamp_hi = pkt->time_stamp_hi;\r\ntimestamp_lo = pkt->time_stamp_lo;\r\nhfi_flags = pkt->flags;\r\noffset = pkt->offset;\r\nfilled_len = pkt->filled_len;\r\npic_type = pkt->picture_type;\r\noutput_tag = pkt->output_tag;\r\nbuffer_type = HFI_BUFFER_OUTPUT;\r\nerror = pkt->error_type;\r\n} else if (session_type == VIDC_SESSION_TYPE_DEC) {\r\nstruct hfi_msg_session_fbd_uncompressed_plane0_pkt *pkt =\r\npacket;\r\ntimestamp_hi = pkt->time_stamp_hi;\r\ntimestamp_lo = pkt->time_stamp_lo;\r\nhfi_flags = pkt->flags;\r\noffset = pkt->offset;\r\nfilled_len = pkt->filled_len;\r\npic_type = pkt->picture_type;\r\noutput_tag = pkt->output_tag;\r\nif (pkt->stream_id == 0)\r\nbuffer_type = HFI_BUFFER_OUTPUT;\r\nelse if (pkt->stream_id == 1)\r\nbuffer_type = HFI_BUFFER_OUTPUT2;\r\nerror = pkt->error_type;\r\n} else {\r\nerror = HFI_ERR_SESSION_INVALID_PARAMETER;\r\n}\r\nif (buffer_type != HFI_BUFFER_OUTPUT)\r\ngoto done;\r\nif (hfi_flags & HFI_BUFFERFLAG_EOS)\r\nflags |= V4L2_BUF_FLAG_LAST;\r\nswitch (pic_type) {\r\ncase HFI_PICTURE_IDR:\r\ncase HFI_PICTURE_I:\r\nflags |= V4L2_BUF_FLAG_KEYFRAME;\r\nbreak;\r\ncase HFI_PICTURE_P:\r\nflags |= V4L2_BUF_FLAG_PFRAME;\r\nbreak;\r\ncase HFI_PICTURE_B:\r\nflags |= V4L2_BUF_FLAG_BFRAME;\r\nbreak;\r\ncase HFI_FRAME_NOTCODED:\r\ncase HFI_UNUSED_PICT:\r\ncase HFI_FRAME_YUV:\r\ndefault:\r\nbreak;\r\n}\r\nif (!(hfi_flags & HFI_BUFFERFLAG_TIMESTAMPINVALID) && filled_len) {\r\ntimestamp_us = timestamp_hi;\r\ntimestamp_us = (timestamp_us << 32) | timestamp_lo;\r\n}\r\ndone:\r\ninst->error = error;\r\ninst->ops->buf_done(inst, buffer_type, output_tag, filled_len,\r\noffset, flags, hfi_flags, timestamp_us);\r\n}\r\nstatic void hfi_session_start_done(struct venus_core *core,\r\nstruct venus_inst *inst, void *packet)\r\n{\r\nstruct hfi_msg_session_start_done_pkt *pkt = packet;\r\ninst->error = pkt->error_type;\r\ncomplete(&inst->done);\r\n}\r\nstatic void hfi_session_stop_done(struct venus_core *core,\r\nstruct venus_inst *inst, void *packet)\r\n{\r\nstruct hfi_msg_session_stop_done_pkt *pkt = packet;\r\ninst->error = pkt->error_type;\r\ncomplete(&inst->done);\r\n}\r\nstatic void hfi_session_rel_res_done(struct venus_core *core,\r\nstruct venus_inst *inst, void *packet)\r\n{\r\nstruct hfi_msg_session_release_resources_done_pkt *pkt = packet;\r\ninst->error = pkt->error_type;\r\ncomplete(&inst->done);\r\n}\r\nstatic void hfi_session_rel_buf_done(struct venus_core *core,\r\nstruct venus_inst *inst, void *packet)\r\n{\r\nstruct hfi_msg_session_release_buffers_done_pkt *pkt = packet;\r\ninst->error = pkt->error_type;\r\ncomplete(&inst->done);\r\n}\r\nstatic void hfi_session_end_done(struct venus_core *core,\r\nstruct venus_inst *inst, void *packet)\r\n{\r\nstruct hfi_msg_session_end_done_pkt *pkt = packet;\r\ninst->error = pkt->error_type;\r\ncomplete(&inst->done);\r\n}\r\nstatic void hfi_session_abort_done(struct venus_core *core,\r\nstruct venus_inst *inst, void *packet)\r\n{\r\nstruct hfi_msg_sys_session_abort_done_pkt *pkt = packet;\r\ninst->error = pkt->error_type;\r\ncomplete(&inst->done);\r\n}\r\nstatic void hfi_session_get_seq_hdr_done(struct venus_core *core,\r\nstruct venus_inst *inst, void *packet)\r\n{\r\nstruct hfi_msg_session_get_sequence_hdr_done_pkt *pkt = packet;\r\ninst->error = pkt->error_type;\r\ncomplete(&inst->done);\r\n}\r\nvoid hfi_process_watchdog_timeout(struct venus_core *core)\r\n{\r\nevent_sys_error(core, EVT_SYS_WATCHDOG_TIMEOUT, NULL);\r\n}\r\nstatic struct venus_inst *to_instance(struct venus_core *core, u32 session_id)\r\n{\r\nstruct venus_inst *inst;\r\nmutex_lock(&core->lock);\r\nlist_for_each_entry(inst, &core->instances, list)\r\nif (hash32_ptr(inst) == session_id) {\r\nmutex_unlock(&core->lock);\r\nreturn inst;\r\n}\r\nmutex_unlock(&core->lock);\r\nreturn NULL;\r\n}\r\nu32 hfi_process_msg_packet(struct venus_core *core, struct hfi_pkt_hdr *hdr)\r\n{\r\nconst struct hfi_done_handler *handler;\r\nstruct device *dev = core->dev;\r\nstruct venus_inst *inst;\r\nbool found = false;\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(handlers); i++) {\r\nhandler = &handlers[i];\r\nif (handler->pkt != hdr->pkt_type)\r\ncontinue;\r\nfound = true;\r\nbreak;\r\n}\r\nif (!found)\r\nreturn hdr->pkt_type;\r\nif (hdr->size && hdr->size < handler->pkt_sz &&\r\nhdr->size < handler->pkt_sz2) {\r\ndev_err(dev, "bad packet size (%d should be %d, pkt type:%x)\n",\r\nhdr->size, handler->pkt_sz, hdr->pkt_type);\r\nreturn hdr->pkt_type;\r\n}\r\nif (handler->is_sys_pkt) {\r\ninst = NULL;\r\n} else {\r\nstruct hfi_session_pkt *pkt;\r\npkt = (struct hfi_session_pkt *)hdr;\r\ninst = to_instance(core, pkt->shdr.session_id);\r\nif (!inst)\r\ndev_warn(dev, "no valid instance(pkt session_id:%x, pkt:%x)\n",\r\npkt->shdr.session_id,\r\nhandler ? handler->pkt : 0);\r\nif (!inst && hdr->pkt_type != HFI_MSG_EVENT_NOTIFY) {\r\ndev_err(dev, "got invalid session id:%x\n",\r\npkt->shdr.session_id);\r\ngoto invalid_session;\r\n}\r\n}\r\nhandler->done(core, inst, hdr);\r\ninvalid_session:\r\nreturn hdr->pkt_type;\r\n}
