static int clkgen_pll_is_locked(struct clk_hw *hw)\r\n{\r\nstruct clkgen_pll *pll = to_clkgen_pll(hw);\r\nu32 locked = CLKGEN_READ(pll, locked_status);\r\nreturn !!locked;\r\n}\r\nstatic int clkgen_pll_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct clkgen_pll *pll = to_clkgen_pll(hw);\r\nu32 poweroff = CLKGEN_READ(pll, pdn_status);\r\nreturn !poweroff;\r\n}\r\nstatic int __clkgen_pll_enable(struct clk_hw *hw)\r\n{\r\nstruct clkgen_pll *pll = to_clkgen_pll(hw);\r\nvoid __iomem *base = pll->regs_base;\r\nstruct clkgen_field *field = &pll->data->locked_status;\r\nint ret = 0;\r\nu32 reg;\r\nif (clkgen_pll_is_enabled(hw))\r\nreturn 0;\r\nCLKGEN_WRITE(pll, pdn_ctrl, 0);\r\nret = readl_relaxed_poll_timeout(base + field->offset, reg,\r\n!!((reg >> field->shift) & field->mask), 0, 10000);\r\nif (!ret) {\r\nif (pll->data->switch2pll_en)\r\nCLKGEN_WRITE(pll, switch2pll, 0);\r\npr_debug("%s:%s enabled\n", __clk_get_name(hw->clk), __func__);\r\n}\r\nreturn ret;\r\n}\r\nstatic int clkgen_pll_enable(struct clk_hw *hw)\r\n{\r\nstruct clkgen_pll *pll = to_clkgen_pll(hw);\r\nunsigned long flags = 0;\r\nint ret = 0;\r\nif (pll->lock)\r\nspin_lock_irqsave(pll->lock, flags);\r\nret = __clkgen_pll_enable(hw);\r\nif (pll->lock)\r\nspin_unlock_irqrestore(pll->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void __clkgen_pll_disable(struct clk_hw *hw)\r\n{\r\nstruct clkgen_pll *pll = to_clkgen_pll(hw);\r\nif (!clkgen_pll_is_enabled(hw))\r\nreturn;\r\nif (pll->data->switch2pll_en)\r\nCLKGEN_WRITE(pll, switch2pll, 1);\r\nCLKGEN_WRITE(pll, pdn_ctrl, 1);\r\npr_debug("%s:%s disabled\n", __clk_get_name(hw->clk), __func__);\r\n}\r\nstatic void clkgen_pll_disable(struct clk_hw *hw)\r\n{\r\nstruct clkgen_pll *pll = to_clkgen_pll(hw);\r\nunsigned long flags = 0;\r\nif (pll->lock)\r\nspin_lock_irqsave(pll->lock, flags);\r\n__clkgen_pll_disable(hw);\r\nif (pll->lock)\r\nspin_unlock_irqrestore(pll->lock, flags);\r\n}\r\nstatic int clk_pll3200c32_get_params(unsigned long input, unsigned long output,\r\nstruct stm_pll *pll)\r\n{\r\nunsigned long i, n;\r\nunsigned long deviation = ~0;\r\nunsigned long new_freq;\r\nlong new_deviation;\r\nstatic const unsigned char cp_table[] = {\r\n48, 56, 64, 72, 80, 88, 96, 104, 112, 120,\r\n128, 136, 144, 152, 160, 168, 176, 184, 192\r\n};\r\nif (output < 800000000 || output > 1600000000)\r\nreturn -EINVAL;\r\ninput /= 1000;\r\noutput /= 1000;\r\nfor (i = 1; i <= 7 && deviation; i++) {\r\nn = i * output / (2 * input);\r\nif (n < 8)\r\ncontinue;\r\nif (n > 200)\r\nbreak;\r\nnew_freq = (input * 2 * n) / i;\r\nnew_deviation = abs(new_freq - output);\r\nif (!new_deviation || new_deviation < deviation) {\r\npll->idf = i;\r\npll->ndiv = n;\r\ndeviation = new_deviation;\r\n}\r\n}\r\nif (deviation == ~0)\r\nreturn -EINVAL;\r\nfor (pll->cp = 6; pll->ndiv > cp_table[pll->cp-6]; (pll->cp)++)\r\n;\r\nreturn 0;\r\n}\r\nstatic int clk_pll3200c32_get_rate(unsigned long input, struct stm_pll *pll,\r\nunsigned long *rate)\r\n{\r\nif (!pll->idf)\r\npll->idf = 1;\r\n*rate = ((2 * (input / 1000) * pll->ndiv) / pll->idf) * 1000;\r\nreturn 0;\r\n}\r\nstatic unsigned long recalc_stm_pll3200c32(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clkgen_pll *pll = to_clkgen_pll(hw);\r\nunsigned long ndiv, idf;\r\nunsigned long rate = 0;\r\nif (!clkgen_pll_is_enabled(hw) || !clkgen_pll_is_locked(hw))\r\nreturn 0;\r\nndiv = CLKGEN_READ(pll, ndiv);\r\nidf = CLKGEN_READ(pll, idf);\r\nif (idf)\r\nrate = ((2 * (parent_rate/1000) * ndiv) / idf) * 1000;\r\npr_debug("%s:%s rate %lu\n", clk_hw_get_name(hw), __func__, rate);\r\nreturn rate;\r\n}\r\nstatic long round_rate_stm_pll3200c32(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nstruct stm_pll params;\r\nif (!clk_pll3200c32_get_params(*prate, rate, &params))\r\nclk_pll3200c32_get_rate(*prate, &params, &rate);\r\nelse {\r\npr_debug("%s: %s rate %ld Invalid\n", __func__,\r\n__clk_get_name(hw->clk), rate);\r\nreturn 0;\r\n}\r\npr_debug("%s: %s new rate %ld [ndiv=%u] [idf=%u]\n",\r\n__func__, __clk_get_name(hw->clk),\r\nrate, (unsigned int)params.ndiv,\r\n(unsigned int)params.idf);\r\nreturn rate;\r\n}\r\nstatic int set_rate_stm_pll3200c32(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clkgen_pll *pll = to_clkgen_pll(hw);\r\nstruct stm_pll params;\r\nlong hwrate = 0;\r\nunsigned long flags = 0;\r\nif (!rate || !parent_rate)\r\nreturn -EINVAL;\r\nif (!clk_pll3200c32_get_params(parent_rate, rate, &params))\r\nclk_pll3200c32_get_rate(parent_rate, &params, &hwrate);\r\npr_debug("%s: %s new rate %ld [ndiv=0x%x] [idf=0x%x]\n",\r\n__func__, __clk_get_name(hw->clk),\r\nhwrate, (unsigned int)params.ndiv,\r\n(unsigned int)params.idf);\r\nif (!hwrate)\r\nreturn -EINVAL;\r\npll->ndiv = params.ndiv;\r\npll->idf = params.idf;\r\npll->cp = params.cp;\r\n__clkgen_pll_disable(hw);\r\nif (pll->lock)\r\nspin_lock_irqsave(pll->lock, flags);\r\nCLKGEN_WRITE(pll, ndiv, pll->ndiv);\r\nCLKGEN_WRITE(pll, idf, pll->idf);\r\nCLKGEN_WRITE(pll, cp, pll->cp);\r\nif (pll->lock)\r\nspin_unlock_irqrestore(pll->lock, flags);\r\n__clkgen_pll_enable(hw);\r\nreturn 0;\r\n}\r\nstatic int clk_pll4600c28_get_params(unsigned long input, unsigned long output,\r\nstruct stm_pll *pll)\r\n{\r\nunsigned long i, infin, n;\r\nunsigned long deviation = ~0;\r\nunsigned long new_freq, new_deviation;\r\nif (output < 19000000 || output > 3000000000u)\r\nreturn -EINVAL;\r\nfor (i = 1; i <= 7 && deviation; i++) {\r\ninfin = input / i;\r\nif (infin < 4000000 || infin > 50000000)\r\ncontinue;\r\nn = output / (infin * 2);\r\nif (n < 8 || n > 246)\r\ncontinue;\r\nif (n < 246)\r\nn++;\r\nfor (; n >= 8 && deviation; n--) {\r\nnew_freq = infin * 2 * n;\r\nif (new_freq < output)\r\nbreak;\r\nnew_deviation = new_freq - output;\r\nif (!new_deviation || new_deviation < deviation) {\r\npll->idf = i;\r\npll->ndiv = n;\r\ndeviation = new_deviation;\r\n}\r\n}\r\n}\r\nif (deviation == ~0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int clk_pll4600c28_get_rate(unsigned long input, struct stm_pll *pll,\r\nunsigned long *rate)\r\n{\r\nif (!pll->idf)\r\npll->idf = 1;\r\n*rate = (input / pll->idf) * 2 * pll->ndiv;\r\nreturn 0;\r\n}\r\nstatic unsigned long recalc_stm_pll4600c28(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clkgen_pll *pll = to_clkgen_pll(hw);\r\nstruct stm_pll params;\r\nunsigned long rate;\r\nif (!clkgen_pll_is_enabled(hw) || !clkgen_pll_is_locked(hw))\r\nreturn 0;\r\nparams.ndiv = CLKGEN_READ(pll, ndiv);\r\nparams.idf = CLKGEN_READ(pll, idf);\r\nclk_pll4600c28_get_rate(parent_rate, &params, &rate);\r\npr_debug("%s:%s rate %lu\n", __clk_get_name(hw->clk), __func__, rate);\r\nreturn rate;\r\n}\r\nstatic long round_rate_stm_pll4600c28(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nstruct stm_pll params;\r\nif (!clk_pll4600c28_get_params(*prate, rate, &params)) {\r\nclk_pll4600c28_get_rate(*prate, &params, &rate);\r\n} else {\r\npr_debug("%s: %s rate %ld Invalid\n", __func__,\r\n__clk_get_name(hw->clk), rate);\r\nreturn 0;\r\n}\r\npr_debug("%s: %s new rate %ld [ndiv=%u] [idf=%u]\n",\r\n__func__, __clk_get_name(hw->clk),\r\nrate, (unsigned int)params.ndiv,\r\n(unsigned int)params.idf);\r\nreturn rate;\r\n}\r\nstatic int set_rate_stm_pll4600c28(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clkgen_pll *pll = to_clkgen_pll(hw);\r\nstruct stm_pll params;\r\nlong hwrate;\r\nunsigned long flags = 0;\r\nif (!rate || !parent_rate)\r\nreturn -EINVAL;\r\nif (!clk_pll4600c28_get_params(parent_rate, rate, &params)) {\r\nclk_pll4600c28_get_rate(parent_rate, &params, &hwrate);\r\n} else {\r\npr_debug("%s: %s rate %ld Invalid\n", __func__,\r\n__clk_get_name(hw->clk), rate);\r\nreturn -EINVAL;\r\n}\r\npr_debug("%s: %s new rate %ld [ndiv=0x%x] [idf=0x%x]\n",\r\n__func__, __clk_get_name(hw->clk),\r\nhwrate, (unsigned int)params.ndiv,\r\n(unsigned int)params.idf);\r\nif (!hwrate)\r\nreturn -EINVAL;\r\npll->ndiv = params.ndiv;\r\npll->idf = params.idf;\r\n__clkgen_pll_disable(hw);\r\nif (pll->lock)\r\nspin_lock_irqsave(pll->lock, flags);\r\nCLKGEN_WRITE(pll, ndiv, pll->ndiv);\r\nCLKGEN_WRITE(pll, idf, pll->idf);\r\nif (pll->lock)\r\nspin_unlock_irqrestore(pll->lock, flags);\r\n__clkgen_pll_enable(hw);\r\nreturn 0;\r\n}\r\nstatic struct clk * __init clkgen_pll_register(const char *parent_name,\r\nstruct clkgen_pll_data *pll_data,\r\nvoid __iomem *reg, unsigned long pll_flags,\r\nconst char *clk_name, spinlock_t *lock)\r\n{\r\nstruct clkgen_pll *pll;\r\nstruct clk *clk;\r\nstruct clk_init_data init;\r\npll = kzalloc(sizeof(*pll), GFP_KERNEL);\r\nif (!pll)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = clk_name;\r\ninit.ops = pll_data->ops;\r\ninit.flags = pll_flags | CLK_IS_BASIC | CLK_GET_RATE_NOCACHE;\r\ninit.parent_names = &parent_name;\r\ninit.num_parents = 1;\r\npll->data = pll_data;\r\npll->regs_base = reg;\r\npll->hw.init = &init;\r\npll->lock = lock;\r\nclk = clk_register(NULL, &pll->hw);\r\nif (IS_ERR(clk)) {\r\nkfree(pll);\r\nreturn clk;\r\n}\r\npr_debug("%s: parent %s rate %lu\n",\r\n__clk_get_name(clk),\r\n__clk_get_name(clk_get_parent(clk)),\r\nclk_get_rate(clk));\r\nreturn clk;\r\n}\r\nstatic void __iomem * __init clkgen_get_register_base(\r\nstruct device_node *np)\r\n{\r\nstruct device_node *pnode;\r\nvoid __iomem *reg = NULL;\r\npnode = of_get_parent(np);\r\nif (!pnode)\r\nreturn NULL;\r\nreg = of_iomap(pnode, 0);\r\nof_node_put(pnode);\r\nreturn reg;\r\n}\r\nstatic struct clk * __init clkgen_odf_register(const char *parent_name,\r\nvoid __iomem *reg,\r\nstruct clkgen_pll_data *pll_data,\r\nunsigned long pll_flags, int odf,\r\nspinlock_t *odf_lock,\r\nconst char *odf_name)\r\n{\r\nstruct clk *clk;\r\nunsigned long flags;\r\nstruct clk_gate *gate;\r\nstruct clk_divider *div;\r\nflags = pll_flags | CLK_GET_RATE_NOCACHE | CLK_SET_RATE_PARENT;\r\ngate = kzalloc(sizeof(*gate), GFP_KERNEL);\r\nif (!gate)\r\nreturn ERR_PTR(-ENOMEM);\r\ngate->flags = CLK_GATE_SET_TO_DISABLE;\r\ngate->reg = reg + pll_data->odf_gate[odf].offset;\r\ngate->bit_idx = pll_data->odf_gate[odf].shift;\r\ngate->lock = odf_lock;\r\ndiv = kzalloc(sizeof(*div), GFP_KERNEL);\r\nif (!div) {\r\nkfree(gate);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ndiv->flags = CLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ALLOW_ZERO;\r\ndiv->reg = reg + pll_data->odf[odf].offset;\r\ndiv->shift = pll_data->odf[odf].shift;\r\ndiv->width = fls(pll_data->odf[odf].mask);\r\ndiv->lock = odf_lock;\r\nclk = clk_register_composite(NULL, odf_name, &parent_name, 1,\r\nNULL, NULL,\r\n&div->hw, &clk_divider_ops,\r\n&gate->hw, &clk_gate_ops,\r\nflags);\r\nif (IS_ERR(clk))\r\nreturn clk;\r\npr_debug("%s: parent %s rate %lu\n",\r\n__clk_get_name(clk),\r\n__clk_get_name(clk_get_parent(clk)),\r\nclk_get_rate(clk));\r\nreturn clk;\r\n}\r\nstatic void __init clkgen_c32_pll_setup(struct device_node *np,\r\nstruct clkgen_pll_data *data)\r\n{\r\nstruct clk *clk;\r\nconst char *parent_name, *pll_name;\r\nvoid __iomem *pll_base;\r\nint num_odfs, odf;\r\nstruct clk_onecell_data *clk_data;\r\nunsigned long pll_flags = 0;\r\nparent_name = of_clk_get_parent_name(np, 0);\r\nif (!parent_name)\r\nreturn;\r\npll_base = clkgen_get_register_base(np);\r\nif (!pll_base)\r\nreturn;\r\nof_clk_detect_critical(np, 0, &pll_flags);\r\nclk = clkgen_pll_register(parent_name, data, pll_base, pll_flags,\r\nnp->name, data->lock);\r\nif (IS_ERR(clk))\r\nreturn;\r\npll_name = __clk_get_name(clk);\r\nnum_odfs = data->num_odfs;\r\nclk_data = kzalloc(sizeof(*clk_data), GFP_KERNEL);\r\nif (!clk_data)\r\nreturn;\r\nclk_data->clk_num = num_odfs;\r\nclk_data->clks = kzalloc(clk_data->clk_num * sizeof(struct clk *),\r\nGFP_KERNEL);\r\nif (!clk_data->clks)\r\ngoto err;\r\nfor (odf = 0; odf < num_odfs; odf++) {\r\nstruct clk *clk;\r\nconst char *clk_name;\r\nunsigned long odf_flags = 0;\r\nif (of_property_read_string_index(np, "clock-output-names",\r\nodf, &clk_name))\r\nreturn;\r\nof_clk_detect_critical(np, odf, &odf_flags);\r\nclk = clkgen_odf_register(pll_name, pll_base, data, odf_flags,\r\nodf, &clkgena_c32_odf_lock, clk_name);\r\nif (IS_ERR(clk))\r\ngoto err;\r\nclk_data->clks[odf] = clk;\r\n}\r\nof_clk_add_provider(np, of_clk_src_onecell_get, clk_data);\r\nreturn;\r\nerr:\r\nkfree(pll_name);\r\nkfree(clk_data->clks);\r\nkfree(clk_data);\r\n}\r\nstatic void __init clkgen_c32_pll0_setup(struct device_node *np)\r\n{\r\nclkgen_c32_pll_setup(np,\r\n(struct clkgen_pll_data *) &st_pll3200c32_cx_0);\r\n}\r\nstatic void __init clkgen_c32_pll1_setup(struct device_node *np)\r\n{\r\nclkgen_c32_pll_setup(np,\r\n(struct clkgen_pll_data *) &st_pll3200c32_cx_1);\r\n}\r\nstatic void __init clkgen_c32_plla9_setup(struct device_node *np)\r\n{\r\nclkgen_c32_pll_setup(np,\r\n(struct clkgen_pll_data *) &st_pll3200c32_407_a9);\r\n}\r\nstatic void __init clkgen_c28_plla9_setup(struct device_node *np)\r\n{\r\nclkgen_c32_pll_setup(np,\r\n(struct clkgen_pll_data *) &st_pll4600c28_418_a9);\r\n}
