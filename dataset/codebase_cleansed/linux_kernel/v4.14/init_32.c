static pmd_t * __init one_md_table_init(pgd_t *pgd)\r\n{\r\np4d_t *p4d;\r\npud_t *pud;\r\npmd_t *pmd_table;\r\n#ifdef CONFIG_X86_PAE\r\nif (!(pgd_val(*pgd) & _PAGE_PRESENT)) {\r\npmd_table = (pmd_t *)alloc_low_page();\r\nparavirt_alloc_pmd(&init_mm, __pa(pmd_table) >> PAGE_SHIFT);\r\nset_pgd(pgd, __pgd(__pa(pmd_table) | _PAGE_PRESENT));\r\np4d = p4d_offset(pgd, 0);\r\npud = pud_offset(p4d, 0);\r\nBUG_ON(pmd_table != pmd_offset(pud, 0));\r\nreturn pmd_table;\r\n}\r\n#endif\r\np4d = p4d_offset(pgd, 0);\r\npud = pud_offset(p4d, 0);\r\npmd_table = pmd_offset(pud, 0);\r\nreturn pmd_table;\r\n}\r\nstatic pte_t * __init one_page_table_init(pmd_t *pmd)\r\n{\r\nif (!(pmd_val(*pmd) & _PAGE_PRESENT)) {\r\npte_t *page_table = (pte_t *)alloc_low_page();\r\nparavirt_alloc_pte(&init_mm, __pa(page_table) >> PAGE_SHIFT);\r\nset_pmd(pmd, __pmd(__pa(page_table) | _PAGE_TABLE));\r\nBUG_ON(page_table != pte_offset_kernel(pmd, 0));\r\n}\r\nreturn pte_offset_kernel(pmd, 0);\r\n}\r\npmd_t * __init populate_extra_pmd(unsigned long vaddr)\r\n{\r\nint pgd_idx = pgd_index(vaddr);\r\nint pmd_idx = pmd_index(vaddr);\r\nreturn one_md_table_init(swapper_pg_dir + pgd_idx) + pmd_idx;\r\n}\r\npte_t * __init populate_extra_pte(unsigned long vaddr)\r\n{\r\nint pte_idx = pte_index(vaddr);\r\npmd_t *pmd;\r\npmd = populate_extra_pmd(vaddr);\r\nreturn one_page_table_init(pmd) + pte_idx;\r\n}\r\nstatic unsigned long __init\r\npage_table_range_init_count(unsigned long start, unsigned long end)\r\n{\r\nunsigned long count = 0;\r\n#ifdef CONFIG_HIGHMEM\r\nint pmd_idx_kmap_begin = fix_to_virt(FIX_KMAP_END) >> PMD_SHIFT;\r\nint pmd_idx_kmap_end = fix_to_virt(FIX_KMAP_BEGIN) >> PMD_SHIFT;\r\nint pgd_idx, pmd_idx;\r\nunsigned long vaddr;\r\nif (pmd_idx_kmap_begin == pmd_idx_kmap_end)\r\nreturn 0;\r\nvaddr = start;\r\npgd_idx = pgd_index(vaddr);\r\npmd_idx = pmd_index(vaddr);\r\nfor ( ; (pgd_idx < PTRS_PER_PGD) && (vaddr != end); pgd_idx++) {\r\nfor (; (pmd_idx < PTRS_PER_PMD) && (vaddr != end);\r\npmd_idx++) {\r\nif ((vaddr >> PMD_SHIFT) >= pmd_idx_kmap_begin &&\r\n(vaddr >> PMD_SHIFT) <= pmd_idx_kmap_end)\r\ncount++;\r\nvaddr += PMD_SIZE;\r\n}\r\npmd_idx = 0;\r\n}\r\n#endif\r\nreturn count;\r\n}\r\nstatic pte_t *__init page_table_kmap_check(pte_t *pte, pmd_t *pmd,\r\nunsigned long vaddr, pte_t *lastpte,\r\nvoid **adr)\r\n{\r\n#ifdef CONFIG_HIGHMEM\r\nint pmd_idx_kmap_begin = fix_to_virt(FIX_KMAP_END) >> PMD_SHIFT;\r\nint pmd_idx_kmap_end = fix_to_virt(FIX_KMAP_BEGIN) >> PMD_SHIFT;\r\nif (pmd_idx_kmap_begin != pmd_idx_kmap_end\r\n&& (vaddr >> PMD_SHIFT) >= pmd_idx_kmap_begin\r\n&& (vaddr >> PMD_SHIFT) <= pmd_idx_kmap_end) {\r\npte_t *newpte;\r\nint i;\r\nBUG_ON(after_bootmem);\r\nnewpte = *adr;\r\nfor (i = 0; i < PTRS_PER_PTE; i++)\r\nset_pte(newpte + i, pte[i]);\r\n*adr = (void *)(((unsigned long)(*adr)) + PAGE_SIZE);\r\nparavirt_alloc_pte(&init_mm, __pa(newpte) >> PAGE_SHIFT);\r\nset_pmd(pmd, __pmd(__pa(newpte)|_PAGE_TABLE));\r\nBUG_ON(newpte != pte_offset_kernel(pmd, 0));\r\n__flush_tlb_all();\r\nparavirt_release_pte(__pa(pte) >> PAGE_SHIFT);\r\npte = newpte;\r\n}\r\nBUG_ON(vaddr < fix_to_virt(FIX_KMAP_BEGIN - 1)\r\n&& vaddr > fix_to_virt(FIX_KMAP_END)\r\n&& lastpte && lastpte + PTRS_PER_PTE != pte);\r\n#endif\r\nreturn pte;\r\n}\r\nstatic void __init\r\npage_table_range_init(unsigned long start, unsigned long end, pgd_t *pgd_base)\r\n{\r\nint pgd_idx, pmd_idx;\r\nunsigned long vaddr;\r\npgd_t *pgd;\r\npmd_t *pmd;\r\npte_t *pte = NULL;\r\nunsigned long count = page_table_range_init_count(start, end);\r\nvoid *adr = NULL;\r\nif (count)\r\nadr = alloc_low_pages(count);\r\nvaddr = start;\r\npgd_idx = pgd_index(vaddr);\r\npmd_idx = pmd_index(vaddr);\r\npgd = pgd_base + pgd_idx;\r\nfor ( ; (pgd_idx < PTRS_PER_PGD) && (vaddr != end); pgd++, pgd_idx++) {\r\npmd = one_md_table_init(pgd);\r\npmd = pmd + pmd_index(vaddr);\r\nfor (; (pmd_idx < PTRS_PER_PMD) && (vaddr != end);\r\npmd++, pmd_idx++) {\r\npte = page_table_kmap_check(one_page_table_init(pmd),\r\npmd, vaddr, pte, &adr);\r\nvaddr += PMD_SIZE;\r\n}\r\npmd_idx = 0;\r\n}\r\n}\r\nstatic inline int is_kernel_text(unsigned long addr)\r\n{\r\nif (addr >= (unsigned long)_text && addr <= (unsigned long)__init_end)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nunsigned long __init\r\nkernel_physical_mapping_init(unsigned long start,\r\nunsigned long end,\r\nunsigned long page_size_mask)\r\n{\r\nint use_pse = page_size_mask == (1<<PG_LEVEL_2M);\r\nunsigned long last_map_addr = end;\r\nunsigned long start_pfn, end_pfn;\r\npgd_t *pgd_base = swapper_pg_dir;\r\nint pgd_idx, pmd_idx, pte_ofs;\r\nunsigned long pfn;\r\npgd_t *pgd;\r\npmd_t *pmd;\r\npte_t *pte;\r\nunsigned pages_2m, pages_4k;\r\nint mapping_iter;\r\nstart_pfn = start >> PAGE_SHIFT;\r\nend_pfn = end >> PAGE_SHIFT;\r\nmapping_iter = 1;\r\nif (!boot_cpu_has(X86_FEATURE_PSE))\r\nuse_pse = 0;\r\nrepeat:\r\npages_2m = pages_4k = 0;\r\npfn = start_pfn;\r\npgd_idx = pgd_index((pfn<<PAGE_SHIFT) + PAGE_OFFSET);\r\npgd = pgd_base + pgd_idx;\r\nfor (; pgd_idx < PTRS_PER_PGD; pgd++, pgd_idx++) {\r\npmd = one_md_table_init(pgd);\r\nif (pfn >= end_pfn)\r\ncontinue;\r\n#ifdef CONFIG_X86_PAE\r\npmd_idx = pmd_index((pfn<<PAGE_SHIFT) + PAGE_OFFSET);\r\npmd += pmd_idx;\r\n#else\r\npmd_idx = 0;\r\n#endif\r\nfor (; pmd_idx < PTRS_PER_PMD && pfn < end_pfn;\r\npmd++, pmd_idx++) {\r\nunsigned int addr = pfn * PAGE_SIZE + PAGE_OFFSET;\r\nif (use_pse) {\r\nunsigned int addr2;\r\npgprot_t prot = PAGE_KERNEL_LARGE;\r\npgprot_t init_prot =\r\n__pgprot(PTE_IDENT_ATTR |\r\n_PAGE_PSE);\r\npfn &= PMD_MASK >> PAGE_SHIFT;\r\naddr2 = (pfn + PTRS_PER_PTE-1) * PAGE_SIZE +\r\nPAGE_OFFSET + PAGE_SIZE-1;\r\nif (is_kernel_text(addr) ||\r\nis_kernel_text(addr2))\r\nprot = PAGE_KERNEL_LARGE_EXEC;\r\npages_2m++;\r\nif (mapping_iter == 1)\r\nset_pmd(pmd, pfn_pmd(pfn, init_prot));\r\nelse\r\nset_pmd(pmd, pfn_pmd(pfn, prot));\r\npfn += PTRS_PER_PTE;\r\ncontinue;\r\n}\r\npte = one_page_table_init(pmd);\r\npte_ofs = pte_index((pfn<<PAGE_SHIFT) + PAGE_OFFSET);\r\npte += pte_ofs;\r\nfor (; pte_ofs < PTRS_PER_PTE && pfn < end_pfn;\r\npte++, pfn++, pte_ofs++, addr += PAGE_SIZE) {\r\npgprot_t prot = PAGE_KERNEL;\r\npgprot_t init_prot = __pgprot(PTE_IDENT_ATTR);\r\nif (is_kernel_text(addr))\r\nprot = PAGE_KERNEL_EXEC;\r\npages_4k++;\r\nif (mapping_iter == 1) {\r\nset_pte(pte, pfn_pte(pfn, init_prot));\r\nlast_map_addr = (pfn << PAGE_SHIFT) + PAGE_SIZE;\r\n} else\r\nset_pte(pte, pfn_pte(pfn, prot));\r\n}\r\n}\r\n}\r\nif (mapping_iter == 1) {\r\nupdate_page_count(PG_LEVEL_2M, pages_2m);\r\nupdate_page_count(PG_LEVEL_4K, pages_4k);\r\n__flush_tlb_all();\r\nmapping_iter = 2;\r\ngoto repeat;\r\n}\r\nreturn last_map_addr;\r\n}\r\nstatic inline pte_t *kmap_get_fixmap_pte(unsigned long vaddr)\r\n{\r\npgd_t *pgd = pgd_offset_k(vaddr);\r\np4d_t *p4d = p4d_offset(pgd, vaddr);\r\npud_t *pud = pud_offset(p4d, vaddr);\r\npmd_t *pmd = pmd_offset(pud, vaddr);\r\nreturn pte_offset_kernel(pmd, vaddr);\r\n}\r\nstatic void __init kmap_init(void)\r\n{\r\nunsigned long kmap_vstart;\r\nkmap_vstart = __fix_to_virt(FIX_KMAP_BEGIN);\r\nkmap_pte = kmap_get_fixmap_pte(kmap_vstart);\r\n}\r\nstatic void __init permanent_kmaps_init(pgd_t *pgd_base)\r\n{\r\nunsigned long vaddr;\r\npgd_t *pgd;\r\np4d_t *p4d;\r\npud_t *pud;\r\npmd_t *pmd;\r\npte_t *pte;\r\nvaddr = PKMAP_BASE;\r\npage_table_range_init(vaddr, vaddr + PAGE_SIZE*LAST_PKMAP, pgd_base);\r\npgd = swapper_pg_dir + pgd_index(vaddr);\r\np4d = p4d_offset(pgd, vaddr);\r\npud = pud_offset(p4d, vaddr);\r\npmd = pmd_offset(pud, vaddr);\r\npte = pte_offset_kernel(pmd, vaddr);\r\npkmap_page_table = pte;\r\n}\r\nvoid __init add_highpages_with_active_regions(int nid,\r\nunsigned long start_pfn, unsigned long end_pfn)\r\n{\r\nphys_addr_t start, end;\r\nu64 i;\r\nfor_each_free_mem_range(i, nid, MEMBLOCK_NONE, &start, &end, NULL) {\r\nunsigned long pfn = clamp_t(unsigned long, PFN_UP(start),\r\nstart_pfn, end_pfn);\r\nunsigned long e_pfn = clamp_t(unsigned long, PFN_DOWN(end),\r\nstart_pfn, end_pfn);\r\nfor ( ; pfn < e_pfn; pfn++)\r\nif (pfn_valid(pfn))\r\nfree_highmem_page(pfn_to_page(pfn));\r\n}\r\n}\r\nstatic inline void permanent_kmaps_init(pgd_t *pgd_base)\r\n{\r\n}\r\nvoid __init native_pagetable_init(void)\r\n{\r\nunsigned long pfn, va;\r\npgd_t *pgd, *base = swapper_pg_dir;\r\np4d_t *p4d;\r\npud_t *pud;\r\npmd_t *pmd;\r\npte_t *pte;\r\nfor (pfn = max_low_pfn; pfn < 1<<(32-PAGE_SHIFT); pfn++) {\r\nva = PAGE_OFFSET + (pfn<<PAGE_SHIFT);\r\npgd = base + pgd_index(va);\r\nif (!pgd_present(*pgd))\r\nbreak;\r\np4d = p4d_offset(pgd, va);\r\npud = pud_offset(p4d, va);\r\npmd = pmd_offset(pud, va);\r\nif (!pmd_present(*pmd))\r\nbreak;\r\nif (pmd_large(*pmd)) {\r\npr_warn("try to clear pte for ram above max_low_pfn: pfn: %lx pmd: %p pmd phys: %lx, but pmd is big page and is not using pte !\n",\r\npfn, pmd, __pa(pmd));\r\nBUG_ON(1);\r\n}\r\npte = pte_offset_kernel(pmd, va);\r\nif (!pte_present(*pte))\r\nbreak;\r\nprintk(KERN_DEBUG "clearing pte for ram above max_low_pfn: pfn: %lx pmd: %p pmd phys: %lx pte: %p pte phys: %lx\n",\r\npfn, pmd, __pa(pmd), pte, __pa(pte));\r\npte_clear(NULL, va, pte);\r\n}\r\nparavirt_alloc_pmd(&init_mm, __pa(base) >> PAGE_SHIFT);\r\npaging_init();\r\n}\r\nvoid __init early_ioremap_page_table_range_init(void)\r\n{\r\npgd_t *pgd_base = swapper_pg_dir;\r\nunsigned long vaddr, end;\r\nvaddr = __fix_to_virt(__end_of_fixed_addresses - 1) & PMD_MASK;\r\nend = (FIXADDR_TOP + PMD_SIZE - 1) & PMD_MASK;\r\npage_table_range_init(vaddr, end, pgd_base);\r\nearly_ioremap_reset();\r\n}\r\nstatic void __init pagetable_init(void)\r\n{\r\npgd_t *pgd_base = swapper_pg_dir;\r\npermanent_kmaps_init(pgd_base);\r\n}\r\nstatic int __init parse_highmem(char *arg)\r\n{\r\nif (!arg)\r\nreturn -EINVAL;\r\nhighmem_pages = memparse(arg, &arg) >> PAGE_SHIFT;\r\nreturn 0;\r\n}\r\nstatic void __init lowmem_pfn_init(void)\r\n{\r\nmax_low_pfn = max_pfn;\r\nif (highmem_pages == -1)\r\nhighmem_pages = 0;\r\n#ifdef CONFIG_HIGHMEM\r\nif (highmem_pages >= max_pfn) {\r\nprintk(KERN_ERR MSG_HIGHMEM_TOO_BIG,\r\npages_to_mb(highmem_pages), pages_to_mb(max_pfn));\r\nhighmem_pages = 0;\r\n}\r\nif (highmem_pages) {\r\nif (max_low_pfn - highmem_pages < 64*1024*1024/PAGE_SIZE) {\r\nprintk(KERN_ERR MSG_LOWMEM_TOO_SMALL,\r\npages_to_mb(highmem_pages));\r\nhighmem_pages = 0;\r\n}\r\nmax_low_pfn -= highmem_pages;\r\n}\r\n#else\r\nif (highmem_pages)\r\nprintk(KERN_ERR "ignoring highmem size on non-highmem kernel!\n");\r\n#endif\r\n}\r\nstatic void __init highmem_pfn_init(void)\r\n{\r\nmax_low_pfn = MAXMEM_PFN;\r\nif (highmem_pages == -1)\r\nhighmem_pages = max_pfn - MAXMEM_PFN;\r\nif (highmem_pages + MAXMEM_PFN < max_pfn)\r\nmax_pfn = MAXMEM_PFN + highmem_pages;\r\nif (highmem_pages + MAXMEM_PFN > max_pfn) {\r\nprintk(KERN_WARNING MSG_HIGHMEM_TOO_SMALL,\r\npages_to_mb(max_pfn - MAXMEM_PFN),\r\npages_to_mb(highmem_pages));\r\nhighmem_pages = 0;\r\n}\r\n#ifndef CONFIG_HIGHMEM\r\nprintk(KERN_WARNING "Warning only %ldMB will be used.\n", MAXMEM>>20);\r\nif (max_pfn > MAX_NONPAE_PFN)\r\nprintk(KERN_WARNING "Use a HIGHMEM64G enabled kernel.\n");\r\nelse\r\nprintk(KERN_WARNING "Use a HIGHMEM enabled kernel.\n");\r\nmax_pfn = MAXMEM_PFN;\r\n#else\r\n#ifndef CONFIG_HIGHMEM64G\r\nif (max_pfn > MAX_NONPAE_PFN) {\r\nmax_pfn = MAX_NONPAE_PFN;\r\nprintk(KERN_WARNING MSG_HIGHMEM_TRIMMED);\r\n}\r\n#endif\r\n#endif\r\n}\r\nvoid __init find_low_pfn_range(void)\r\n{\r\nif (max_pfn <= MAXMEM_PFN)\r\nlowmem_pfn_init();\r\nelse\r\nhighmem_pfn_init();\r\n}\r\nvoid __init initmem_init(void)\r\n{\r\n#ifdef CONFIG_HIGHMEM\r\nhighstart_pfn = highend_pfn = max_pfn;\r\nif (max_pfn > max_low_pfn)\r\nhighstart_pfn = max_low_pfn;\r\nprintk(KERN_NOTICE "%ldMB HIGHMEM available.\n",\r\npages_to_mb(highend_pfn - highstart_pfn));\r\nhigh_memory = (void *) __va(highstart_pfn * PAGE_SIZE - 1) + 1;\r\n#else\r\nhigh_memory = (void *) __va(max_low_pfn * PAGE_SIZE - 1) + 1;\r\n#endif\r\nmemblock_set_node(0, (phys_addr_t)ULLONG_MAX, &memblock.memory, 0);\r\nsparse_memory_present_with_active_regions(0);\r\n#ifdef CONFIG_FLATMEM\r\nmax_mapnr = IS_ENABLED(CONFIG_HIGHMEM) ? highend_pfn : max_low_pfn;\r\n#endif\r\n__vmalloc_start_set = true;\r\nprintk(KERN_NOTICE "%ldMB LOWMEM available.\n",\r\npages_to_mb(max_low_pfn));\r\nsetup_bootmem_allocator();\r\n}\r\nvoid __init setup_bootmem_allocator(void)\r\n{\r\nprintk(KERN_INFO " mapped low ram: 0 - %08lx\n",\r\nmax_pfn_mapped<<PAGE_SHIFT);\r\nprintk(KERN_INFO " low ram: 0 - %08lx\n", max_low_pfn<<PAGE_SHIFT);\r\n}\r\nvoid __init paging_init(void)\r\n{\r\npagetable_init();\r\n__flush_tlb_all();\r\nkmap_init();\r\nolpc_dt_build_devicetree();\r\nsparse_memory_present_with_active_regions(MAX_NUMNODES);\r\nsparse_init();\r\nzone_sizes_init();\r\n}\r\nstatic void __init test_wp_bit(void)\r\n{\r\nchar z = 0;\r\nprintk(KERN_INFO "Checking if this processor honours the WP bit even in supervisor mode...");\r\n__set_fixmap(FIX_WP_TEST, __pa_symbol(empty_zero_page), PAGE_KERNEL_RO);\r\nif (probe_kernel_write((char *)fix_to_virt(FIX_WP_TEST), &z, 1)) {\r\nclear_fixmap(FIX_WP_TEST);\r\nprintk(KERN_CONT "Ok.\n");\r\nreturn;\r\n}\r\nprintk(KERN_CONT "No.\n");\r\npanic("Linux doesn't support CPUs with broken WP.");\r\n}\r\nvoid __init mem_init(void)\r\n{\r\npci_iommu_alloc();\r\n#ifdef CONFIG_FLATMEM\r\nBUG_ON(!mem_map);\r\n#endif\r\nset_highmem_pages_init();\r\nfree_all_bootmem();\r\nafter_bootmem = 1;\r\nmem_init_print_info(NULL);\r\nprintk(KERN_INFO "virtual kernel memory layout:\n"\r\n" fixmap : 0x%08lx - 0x%08lx (%4ld kB)\n"\r\n#ifdef CONFIG_HIGHMEM\r\n" pkmap : 0x%08lx - 0x%08lx (%4ld kB)\n"\r\n#endif\r\n" vmalloc : 0x%08lx - 0x%08lx (%4ld MB)\n"\r\n" lowmem : 0x%08lx - 0x%08lx (%4ld MB)\n"\r\n" .init : 0x%08lx - 0x%08lx (%4ld kB)\n"\r\n" .data : 0x%08lx - 0x%08lx (%4ld kB)\n"\r\n" .text : 0x%08lx - 0x%08lx (%4ld kB)\n",\r\nFIXADDR_START, FIXADDR_TOP,\r\n(FIXADDR_TOP - FIXADDR_START) >> 10,\r\n#ifdef CONFIG_HIGHMEM\r\nPKMAP_BASE, PKMAP_BASE+LAST_PKMAP*PAGE_SIZE,\r\n(LAST_PKMAP*PAGE_SIZE) >> 10,\r\n#endif\r\nVMALLOC_START, VMALLOC_END,\r\n(VMALLOC_END - VMALLOC_START) >> 20,\r\n(unsigned long)__va(0), (unsigned long)high_memory,\r\n((unsigned long)high_memory - (unsigned long)__va(0)) >> 20,\r\n(unsigned long)&__init_begin, (unsigned long)&__init_end,\r\n((unsigned long)&__init_end -\r\n(unsigned long)&__init_begin) >> 10,\r\n(unsigned long)&_etext, (unsigned long)&_edata,\r\n((unsigned long)&_edata - (unsigned long)&_etext) >> 10,\r\n(unsigned long)&_text, (unsigned long)&_etext,\r\n((unsigned long)&_etext - (unsigned long)&_text) >> 10);\r\n#define __FIXADDR_TOP (-PAGE_SIZE)\r\n#ifdef CONFIG_HIGHMEM\r\nBUILD_BUG_ON(PKMAP_BASE + LAST_PKMAP*PAGE_SIZE > FIXADDR_START);\r\nBUILD_BUG_ON(VMALLOC_END > PKMAP_BASE);\r\n#endif\r\n#define high_memory (-128UL << 20)\r\nBUILD_BUG_ON(VMALLOC_START >= VMALLOC_END);\r\n#undef high_memory\r\n#undef __FIXADDR_TOP\r\n#ifdef CONFIG_HIGHMEM\r\nBUG_ON(PKMAP_BASE + LAST_PKMAP*PAGE_SIZE > FIXADDR_START);\r\nBUG_ON(VMALLOC_END > PKMAP_BASE);\r\n#endif\r\nBUG_ON(VMALLOC_START >= VMALLOC_END);\r\nBUG_ON((unsigned long)high_memory > VMALLOC_START);\r\ntest_wp_bit();\r\n}\r\nint arch_add_memory(int nid, u64 start, u64 size, bool want_memblock)\r\n{\r\nunsigned long start_pfn = start >> PAGE_SHIFT;\r\nunsigned long nr_pages = size >> PAGE_SHIFT;\r\nreturn __add_pages(nid, start_pfn, nr_pages, want_memblock);\r\n}\r\nint arch_remove_memory(u64 start, u64 size)\r\n{\r\nunsigned long start_pfn = start >> PAGE_SHIFT;\r\nunsigned long nr_pages = size >> PAGE_SHIFT;\r\nstruct zone *zone;\r\nzone = page_zone(pfn_to_page(start_pfn));\r\nreturn __remove_pages(zone, start_pfn, nr_pages);\r\n}\r\nvoid set_kernel_text_rw(void)\r\n{\r\nunsigned long start = PFN_ALIGN(_text);\r\nunsigned long size = PFN_ALIGN(_etext) - start;\r\nif (!kernel_set_to_readonly)\r\nreturn;\r\npr_debug("Set kernel text: %lx - %lx for read write\n",\r\nstart, start+size);\r\nset_pages_rw(virt_to_page(start), size >> PAGE_SHIFT);\r\n}\r\nvoid set_kernel_text_ro(void)\r\n{\r\nunsigned long start = PFN_ALIGN(_text);\r\nunsigned long size = PFN_ALIGN(_etext) - start;\r\nif (!kernel_set_to_readonly)\r\nreturn;\r\npr_debug("Set kernel text: %lx - %lx for read only\n",\r\nstart, start+size);\r\nset_pages_ro(virt_to_page(start), size >> PAGE_SHIFT);\r\n}\r\nstatic void mark_nxdata_nx(void)\r\n{\r\nunsigned long start = PFN_ALIGN(_etext);\r\nunsigned long size = (((unsigned long)__init_end + HPAGE_SIZE) & HPAGE_MASK) - start;\r\nif (__supported_pte_mask & _PAGE_NX)\r\nprintk(KERN_INFO "NX-protecting the kernel data: %luk\n", size >> 10);\r\nset_pages_nx(virt_to_page(start), size >> PAGE_SHIFT);\r\n}\r\nvoid mark_rodata_ro(void)\r\n{\r\nunsigned long start = PFN_ALIGN(_text);\r\nunsigned long size = PFN_ALIGN(_etext) - start;\r\nset_pages_ro(virt_to_page(start), size >> PAGE_SHIFT);\r\nprintk(KERN_INFO "Write protecting the kernel text: %luk\n",\r\nsize >> 10);\r\nkernel_set_to_readonly = 1;\r\n#ifdef CONFIG_CPA_DEBUG\r\nprintk(KERN_INFO "Testing CPA: Reverting %lx-%lx\n",\r\nstart, start+size);\r\nset_pages_rw(virt_to_page(start), size>>PAGE_SHIFT);\r\nprintk(KERN_INFO "Testing CPA: write protecting again\n");\r\nset_pages_ro(virt_to_page(start), size>>PAGE_SHIFT);\r\n#endif\r\nstart += size;\r\nsize = (unsigned long)__end_rodata - start;\r\nset_pages_ro(virt_to_page(start), size >> PAGE_SHIFT);\r\nprintk(KERN_INFO "Write protecting the kernel read-only data: %luk\n",\r\nsize >> 10);\r\n#ifdef CONFIG_CPA_DEBUG\r\nprintk(KERN_INFO "Testing CPA: undo %lx-%lx\n", start, start + size);\r\nset_pages_rw(virt_to_page(start), size >> PAGE_SHIFT);\r\nprintk(KERN_INFO "Testing CPA: write protecting again\n");\r\nset_pages_ro(virt_to_page(start), size >> PAGE_SHIFT);\r\n#endif\r\nmark_nxdata_nx();\r\nif (__supported_pte_mask & _PAGE_NX)\r\ndebug_checkwx();\r\n}
