static inline bool clk_main_osc_ready(struct regmap *regmap)\r\n{\r\nunsigned int status;\r\nregmap_read(regmap, AT91_PMC_SR, &status);\r\nreturn status & AT91_PMC_MOSCS;\r\n}\r\nstatic int clk_main_osc_prepare(struct clk_hw *hw)\r\n{\r\nstruct clk_main_osc *osc = to_clk_main_osc(hw);\r\nstruct regmap *regmap = osc->regmap;\r\nu32 tmp;\r\nregmap_read(regmap, AT91_CKGR_MOR, &tmp);\r\ntmp &= ~MOR_KEY_MASK;\r\nif (tmp & AT91_PMC_OSCBYPASS)\r\nreturn 0;\r\nif (!(tmp & AT91_PMC_MOSCEN)) {\r\ntmp |= AT91_PMC_MOSCEN | AT91_PMC_KEY;\r\nregmap_write(regmap, AT91_CKGR_MOR, tmp);\r\n}\r\nwhile (!clk_main_osc_ready(regmap))\r\ncpu_relax();\r\nreturn 0;\r\n}\r\nstatic void clk_main_osc_unprepare(struct clk_hw *hw)\r\n{\r\nstruct clk_main_osc *osc = to_clk_main_osc(hw);\r\nstruct regmap *regmap = osc->regmap;\r\nu32 tmp;\r\nregmap_read(regmap, AT91_CKGR_MOR, &tmp);\r\nif (tmp & AT91_PMC_OSCBYPASS)\r\nreturn;\r\nif (!(tmp & AT91_PMC_MOSCEN))\r\nreturn;\r\ntmp &= ~(AT91_PMC_KEY | AT91_PMC_MOSCEN);\r\nregmap_write(regmap, AT91_CKGR_MOR, tmp | AT91_PMC_KEY);\r\n}\r\nstatic int clk_main_osc_is_prepared(struct clk_hw *hw)\r\n{\r\nstruct clk_main_osc *osc = to_clk_main_osc(hw);\r\nstruct regmap *regmap = osc->regmap;\r\nu32 tmp, status;\r\nregmap_read(regmap, AT91_CKGR_MOR, &tmp);\r\nif (tmp & AT91_PMC_OSCBYPASS)\r\nreturn 1;\r\nregmap_read(regmap, AT91_PMC_SR, &status);\r\nreturn (status & AT91_PMC_MOSCS) && (tmp & AT91_PMC_MOSCEN);\r\n}\r\nstatic struct clk_hw * __init\r\nat91_clk_register_main_osc(struct regmap *regmap,\r\nconst char *name,\r\nconst char *parent_name,\r\nbool bypass)\r\n{\r\nstruct clk_main_osc *osc;\r\nstruct clk_init_data init;\r\nstruct clk_hw *hw;\r\nint ret;\r\nif (!name || !parent_name)\r\nreturn ERR_PTR(-EINVAL);\r\nosc = kzalloc(sizeof(*osc), GFP_KERNEL);\r\nif (!osc)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = name;\r\ninit.ops = &main_osc_ops;\r\ninit.parent_names = &parent_name;\r\ninit.num_parents = 1;\r\ninit.flags = CLK_IGNORE_UNUSED;\r\nosc->hw.init = &init;\r\nosc->regmap = regmap;\r\nif (bypass)\r\nregmap_update_bits(regmap,\r\nAT91_CKGR_MOR, MOR_KEY_MASK |\r\nAT91_PMC_MOSCEN,\r\nAT91_PMC_OSCBYPASS | AT91_PMC_KEY);\r\nhw = &osc->hw;\r\nret = clk_hw_register(NULL, &osc->hw);\r\nif (ret) {\r\nkfree(osc);\r\nhw = ERR_PTR(ret);\r\n}\r\nreturn hw;\r\n}\r\nstatic void __init of_at91rm9200_clk_main_osc_setup(struct device_node *np)\r\n{\r\nstruct clk_hw *hw;\r\nconst char *name = np->name;\r\nconst char *parent_name;\r\nstruct regmap *regmap;\r\nbool bypass;\r\nof_property_read_string(np, "clock-output-names", &name);\r\nbypass = of_property_read_bool(np, "atmel,osc-bypass");\r\nparent_name = of_clk_get_parent_name(np, 0);\r\nregmap = syscon_node_to_regmap(of_get_parent(np));\r\nif (IS_ERR(regmap))\r\nreturn;\r\nhw = at91_clk_register_main_osc(regmap, name, parent_name, bypass);\r\nif (IS_ERR(hw))\r\nreturn;\r\nof_clk_add_hw_provider(np, of_clk_hw_simple_get, hw);\r\n}\r\nstatic bool clk_main_rc_osc_ready(struct regmap *regmap)\r\n{\r\nunsigned int status;\r\nregmap_read(regmap, AT91_PMC_SR, &status);\r\nreturn status & AT91_PMC_MOSCRCS;\r\n}\r\nstatic int clk_main_rc_osc_prepare(struct clk_hw *hw)\r\n{\r\nstruct clk_main_rc_osc *osc = to_clk_main_rc_osc(hw);\r\nstruct regmap *regmap = osc->regmap;\r\nunsigned int mor;\r\nregmap_read(regmap, AT91_CKGR_MOR, &mor);\r\nif (!(mor & AT91_PMC_MOSCRCEN))\r\nregmap_update_bits(regmap, AT91_CKGR_MOR,\r\nMOR_KEY_MASK | AT91_PMC_MOSCRCEN,\r\nAT91_PMC_MOSCRCEN | AT91_PMC_KEY);\r\nwhile (!clk_main_rc_osc_ready(regmap))\r\ncpu_relax();\r\nreturn 0;\r\n}\r\nstatic void clk_main_rc_osc_unprepare(struct clk_hw *hw)\r\n{\r\nstruct clk_main_rc_osc *osc = to_clk_main_rc_osc(hw);\r\nstruct regmap *regmap = osc->regmap;\r\nunsigned int mor;\r\nregmap_read(regmap, AT91_CKGR_MOR, &mor);\r\nif (!(mor & AT91_PMC_MOSCRCEN))\r\nreturn;\r\nregmap_update_bits(regmap, AT91_CKGR_MOR,\r\nMOR_KEY_MASK | AT91_PMC_MOSCRCEN, AT91_PMC_KEY);\r\n}\r\nstatic int clk_main_rc_osc_is_prepared(struct clk_hw *hw)\r\n{\r\nstruct clk_main_rc_osc *osc = to_clk_main_rc_osc(hw);\r\nstruct regmap *regmap = osc->regmap;\r\nunsigned int mor, status;\r\nregmap_read(regmap, AT91_CKGR_MOR, &mor);\r\nregmap_read(regmap, AT91_PMC_SR, &status);\r\nreturn (mor & AT91_PMC_MOSCRCEN) && (status & AT91_PMC_MOSCRCS);\r\n}\r\nstatic unsigned long clk_main_rc_osc_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_main_rc_osc *osc = to_clk_main_rc_osc(hw);\r\nreturn osc->frequency;\r\n}\r\nstatic unsigned long clk_main_rc_osc_recalc_accuracy(struct clk_hw *hw,\r\nunsigned long parent_acc)\r\n{\r\nstruct clk_main_rc_osc *osc = to_clk_main_rc_osc(hw);\r\nreturn osc->accuracy;\r\n}\r\nstatic struct clk_hw * __init\r\nat91_clk_register_main_rc_osc(struct regmap *regmap,\r\nconst char *name,\r\nu32 frequency, u32 accuracy)\r\n{\r\nstruct clk_main_rc_osc *osc;\r\nstruct clk_init_data init;\r\nstruct clk_hw *hw;\r\nint ret;\r\nif (!name || !frequency)\r\nreturn ERR_PTR(-EINVAL);\r\nosc = kzalloc(sizeof(*osc), GFP_KERNEL);\r\nif (!osc)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = name;\r\ninit.ops = &main_rc_osc_ops;\r\ninit.parent_names = NULL;\r\ninit.num_parents = 0;\r\ninit.flags = CLK_IGNORE_UNUSED;\r\nosc->hw.init = &init;\r\nosc->regmap = regmap;\r\nosc->frequency = frequency;\r\nosc->accuracy = accuracy;\r\nhw = &osc->hw;\r\nret = clk_hw_register(NULL, hw);\r\nif (ret) {\r\nkfree(osc);\r\nhw = ERR_PTR(ret);\r\n}\r\nreturn hw;\r\n}\r\nstatic void __init of_at91sam9x5_clk_main_rc_osc_setup(struct device_node *np)\r\n{\r\nstruct clk_hw *hw;\r\nu32 frequency = 0;\r\nu32 accuracy = 0;\r\nconst char *name = np->name;\r\nstruct regmap *regmap;\r\nof_property_read_string(np, "clock-output-names", &name);\r\nof_property_read_u32(np, "clock-frequency", &frequency);\r\nof_property_read_u32(np, "clock-accuracy", &accuracy);\r\nregmap = syscon_node_to_regmap(of_get_parent(np));\r\nif (IS_ERR(regmap))\r\nreturn;\r\nhw = at91_clk_register_main_rc_osc(regmap, name, frequency, accuracy);\r\nif (IS_ERR(hw))\r\nreturn;\r\nof_clk_add_hw_provider(np, of_clk_hw_simple_get, hw);\r\n}\r\nstatic int clk_main_probe_frequency(struct regmap *regmap)\r\n{\r\nunsigned long prep_time, timeout;\r\nunsigned int mcfr;\r\ntimeout = jiffies + usecs_to_jiffies(MAINFRDY_TIMEOUT);\r\ndo {\r\nprep_time = jiffies;\r\nregmap_read(regmap, AT91_CKGR_MCFR, &mcfr);\r\nif (mcfr & AT91_PMC_MAINRDY)\r\nreturn 0;\r\nusleep_range(MAINF_LOOP_MIN_WAIT, MAINF_LOOP_MAX_WAIT);\r\n} while (time_before(prep_time, timeout));\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic unsigned long clk_main_recalc_rate(struct regmap *regmap,\r\nunsigned long parent_rate)\r\n{\r\nunsigned int mcfr;\r\nif (parent_rate)\r\nreturn parent_rate;\r\npr_warn("Main crystal frequency not set, using approximate value\n");\r\nregmap_read(regmap, AT91_CKGR_MCFR, &mcfr);\r\nif (!(mcfr & AT91_PMC_MAINRDY))\r\nreturn 0;\r\nreturn ((mcfr & AT91_PMC_MAINF) * SLOW_CLOCK_FREQ) / MAINF_DIV;\r\n}\r\nstatic int clk_rm9200_main_prepare(struct clk_hw *hw)\r\n{\r\nstruct clk_rm9200_main *clkmain = to_clk_rm9200_main(hw);\r\nreturn clk_main_probe_frequency(clkmain->regmap);\r\n}\r\nstatic int clk_rm9200_main_is_prepared(struct clk_hw *hw)\r\n{\r\nstruct clk_rm9200_main *clkmain = to_clk_rm9200_main(hw);\r\nunsigned int status;\r\nregmap_read(clkmain->regmap, AT91_CKGR_MCFR, &status);\r\nreturn status & AT91_PMC_MAINRDY ? 1 : 0;\r\n}\r\nstatic unsigned long clk_rm9200_main_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_rm9200_main *clkmain = to_clk_rm9200_main(hw);\r\nreturn clk_main_recalc_rate(clkmain->regmap, parent_rate);\r\n}\r\nstatic struct clk_hw * __init\r\nat91_clk_register_rm9200_main(struct regmap *regmap,\r\nconst char *name,\r\nconst char *parent_name)\r\n{\r\nstruct clk_rm9200_main *clkmain;\r\nstruct clk_init_data init;\r\nstruct clk_hw *hw;\r\nint ret;\r\nif (!name)\r\nreturn ERR_PTR(-EINVAL);\r\nif (!parent_name)\r\nreturn ERR_PTR(-EINVAL);\r\nclkmain = kzalloc(sizeof(*clkmain), GFP_KERNEL);\r\nif (!clkmain)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = name;\r\ninit.ops = &rm9200_main_ops;\r\ninit.parent_names = &parent_name;\r\ninit.num_parents = 1;\r\ninit.flags = 0;\r\nclkmain->hw.init = &init;\r\nclkmain->regmap = regmap;\r\nhw = &clkmain->hw;\r\nret = clk_hw_register(NULL, &clkmain->hw);\r\nif (ret) {\r\nkfree(clkmain);\r\nhw = ERR_PTR(ret);\r\n}\r\nreturn hw;\r\n}\r\nstatic void __init of_at91rm9200_clk_main_setup(struct device_node *np)\r\n{\r\nstruct clk_hw *hw;\r\nconst char *parent_name;\r\nconst char *name = np->name;\r\nstruct regmap *regmap;\r\nparent_name = of_clk_get_parent_name(np, 0);\r\nof_property_read_string(np, "clock-output-names", &name);\r\nregmap = syscon_node_to_regmap(of_get_parent(np));\r\nif (IS_ERR(regmap))\r\nreturn;\r\nhw = at91_clk_register_rm9200_main(regmap, name, parent_name);\r\nif (IS_ERR(hw))\r\nreturn;\r\nof_clk_add_hw_provider(np, of_clk_hw_simple_get, hw);\r\n}\r\nstatic inline bool clk_sam9x5_main_ready(struct regmap *regmap)\r\n{\r\nunsigned int status;\r\nregmap_read(regmap, AT91_PMC_SR, &status);\r\nreturn status & AT91_PMC_MOSCSELS ? 1 : 0;\r\n}\r\nstatic int clk_sam9x5_main_prepare(struct clk_hw *hw)\r\n{\r\nstruct clk_sam9x5_main *clkmain = to_clk_sam9x5_main(hw);\r\nstruct regmap *regmap = clkmain->regmap;\r\nwhile (!clk_sam9x5_main_ready(regmap))\r\ncpu_relax();\r\nreturn clk_main_probe_frequency(regmap);\r\n}\r\nstatic int clk_sam9x5_main_is_prepared(struct clk_hw *hw)\r\n{\r\nstruct clk_sam9x5_main *clkmain = to_clk_sam9x5_main(hw);\r\nreturn clk_sam9x5_main_ready(clkmain->regmap);\r\n}\r\nstatic unsigned long clk_sam9x5_main_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_sam9x5_main *clkmain = to_clk_sam9x5_main(hw);\r\nreturn clk_main_recalc_rate(clkmain->regmap, parent_rate);\r\n}\r\nstatic int clk_sam9x5_main_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct clk_sam9x5_main *clkmain = to_clk_sam9x5_main(hw);\r\nstruct regmap *regmap = clkmain->regmap;\r\nunsigned int tmp;\r\nif (index > 1)\r\nreturn -EINVAL;\r\nregmap_read(regmap, AT91_CKGR_MOR, &tmp);\r\ntmp &= ~MOR_KEY_MASK;\r\nif (index && !(tmp & AT91_PMC_MOSCSEL))\r\nregmap_write(regmap, AT91_CKGR_MOR, tmp | AT91_PMC_MOSCSEL);\r\nelse if (!index && (tmp & AT91_PMC_MOSCSEL))\r\nregmap_write(regmap, AT91_CKGR_MOR, tmp & ~AT91_PMC_MOSCSEL);\r\nwhile (!clk_sam9x5_main_ready(regmap))\r\ncpu_relax();\r\nreturn 0;\r\n}\r\nstatic u8 clk_sam9x5_main_get_parent(struct clk_hw *hw)\r\n{\r\nstruct clk_sam9x5_main *clkmain = to_clk_sam9x5_main(hw);\r\nunsigned int status;\r\nregmap_read(clkmain->regmap, AT91_CKGR_MOR, &status);\r\nreturn status & AT91_PMC_MOSCEN ? 1 : 0;\r\n}\r\nstatic struct clk_hw * __init\r\nat91_clk_register_sam9x5_main(struct regmap *regmap,\r\nconst char *name,\r\nconst char **parent_names,\r\nint num_parents)\r\n{\r\nstruct clk_sam9x5_main *clkmain;\r\nstruct clk_init_data init;\r\nunsigned int status;\r\nstruct clk_hw *hw;\r\nint ret;\r\nif (!name)\r\nreturn ERR_PTR(-EINVAL);\r\nif (!parent_names || !num_parents)\r\nreturn ERR_PTR(-EINVAL);\r\nclkmain = kzalloc(sizeof(*clkmain), GFP_KERNEL);\r\nif (!clkmain)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = name;\r\ninit.ops = &sam9x5_main_ops;\r\ninit.parent_names = parent_names;\r\ninit.num_parents = num_parents;\r\ninit.flags = CLK_SET_PARENT_GATE;\r\nclkmain->hw.init = &init;\r\nclkmain->regmap = regmap;\r\nregmap_read(clkmain->regmap, AT91_CKGR_MOR, &status);\r\nclkmain->parent = status & AT91_PMC_MOSCEN ? 1 : 0;\r\nhw = &clkmain->hw;\r\nret = clk_hw_register(NULL, &clkmain->hw);\r\nif (ret) {\r\nkfree(clkmain);\r\nhw = ERR_PTR(ret);\r\n}\r\nreturn hw;\r\n}\r\nstatic void __init of_at91sam9x5_clk_main_setup(struct device_node *np)\r\n{\r\nstruct clk_hw *hw;\r\nconst char *parent_names[2];\r\nunsigned int num_parents;\r\nconst char *name = np->name;\r\nstruct regmap *regmap;\r\nnum_parents = of_clk_get_parent_count(np);\r\nif (num_parents == 0 || num_parents > 2)\r\nreturn;\r\nof_clk_parent_fill(np, parent_names, num_parents);\r\nregmap = syscon_node_to_regmap(of_get_parent(np));\r\nif (IS_ERR(regmap))\r\nreturn;\r\nof_property_read_string(np, "clock-output-names", &name);\r\nhw = at91_clk_register_sam9x5_main(regmap, name, parent_names,\r\nnum_parents);\r\nif (IS_ERR(hw))\r\nreturn;\r\nof_clk_add_hw_provider(np, of_clk_hw_simple_get, hw);\r\n}
