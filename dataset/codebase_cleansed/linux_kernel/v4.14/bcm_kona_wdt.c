static int secure_register_read(struct bcm_kona_wdt *wdt, uint32_t offset)\r\n{\r\nuint32_t val;\r\nunsigned count = 0;\r\ndo {\r\nif (unlikely(count > 1))\r\nudelay(5);\r\nval = readl_relaxed(wdt->base + offset);\r\ncount++;\r\n} while ((val & SECWDOG_WD_LOAD_FLAG) && count < SECWDOG_MAX_TRY);\r\n#ifdef CONFIG_BCM_KONA_WDT_DEBUG\r\nif (count > wdt->busy_count)\r\nwdt->busy_count = count;\r\n#endif\r\nif (val & SECWDOG_WD_LOAD_FLAG)\r\nreturn -ETIMEDOUT;\r\nval &= SECWDOG_RESERVED_MASK;\r\nreturn val;\r\n}\r\nstatic int bcm_kona_wdt_dbg_show(struct seq_file *s, void *data)\r\n{\r\nint ctl_val, cur_val;\r\nunsigned long flags;\r\nstruct bcm_kona_wdt *wdt = s->private;\r\nif (!wdt) {\r\nseq_puts(s, "No device pointer\n");\r\nreturn 0;\r\n}\r\nspin_lock_irqsave(&wdt->lock, flags);\r\nctl_val = secure_register_read(wdt, SECWDOG_CTRL_REG);\r\ncur_val = secure_register_read(wdt, SECWDOG_COUNT_REG);\r\nspin_unlock_irqrestore(&wdt->lock, flags);\r\nif (ctl_val < 0 || cur_val < 0) {\r\nseq_puts(s, "Error accessing hardware\n");\r\n} else {\r\nint ctl, cur, ctl_sec, cur_sec, res;\r\nctl = ctl_val & SECWDOG_COUNT_MASK;\r\nres = (ctl_val & SECWDOG_RES_MASK) >> SECWDOG_CLKS_SHIFT;\r\ncur = cur_val & SECWDOG_COUNT_MASK;\r\nctl_sec = TICKS_TO_SECS(ctl, wdt);\r\ncur_sec = TICKS_TO_SECS(cur, wdt);\r\nseq_printf(s,\r\n"Resolution: %d / %d\n"\r\n"Control: %d s / %d (%#x) ticks\n"\r\n"Current: %d s / %d (%#x) ticks\n"\r\n"Busy count: %lu\n",\r\nres, wdt->resolution,\r\nctl_sec, ctl, ctl,\r\ncur_sec, cur, cur,\r\nwdt->busy_count);\r\n}\r\nreturn 0;\r\n}\r\nstatic int bcm_kona_dbg_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, bcm_kona_wdt_dbg_show, inode->i_private);\r\n}\r\nstatic void bcm_kona_wdt_debug_init(struct platform_device *pdev)\r\n{\r\nstruct dentry *dir;\r\nstruct bcm_kona_wdt *wdt = platform_get_drvdata(pdev);\r\nif (!wdt)\r\nreturn;\r\nwdt->debugfs = NULL;\r\ndir = debugfs_create_dir(BCM_KONA_WDT_NAME, NULL);\r\nif (IS_ERR_OR_NULL(dir))\r\nreturn;\r\nif (debugfs_create_file("info", S_IFREG | S_IRUGO, dir, wdt,\r\n&bcm_kona_dbg_operations))\r\nwdt->debugfs = dir;\r\nelse\r\ndebugfs_remove_recursive(dir);\r\n}\r\nstatic void bcm_kona_wdt_debug_exit(struct platform_device *pdev)\r\n{\r\nstruct bcm_kona_wdt *wdt = platform_get_drvdata(pdev);\r\nif (wdt && wdt->debugfs) {\r\ndebugfs_remove_recursive(wdt->debugfs);\r\nwdt->debugfs = NULL;\r\n}\r\n}\r\nstatic void bcm_kona_wdt_debug_init(struct platform_device *pdev) {}\r\nstatic void bcm_kona_wdt_debug_exit(struct platform_device *pdev) {}\r\nstatic int bcm_kona_wdt_ctrl_reg_modify(struct bcm_kona_wdt *wdt,\r\nunsigned mask, unsigned newval)\r\n{\r\nint val;\r\nunsigned long flags;\r\nint ret = 0;\r\nspin_lock_irqsave(&wdt->lock, flags);\r\nval = secure_register_read(wdt, SECWDOG_CTRL_REG);\r\nif (val < 0) {\r\nret = val;\r\n} else {\r\nval &= ~mask;\r\nval |= newval;\r\nwritel_relaxed(val, wdt->base + SECWDOG_CTRL_REG);\r\n}\r\nspin_unlock_irqrestore(&wdt->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int bcm_kona_wdt_set_resolution_reg(struct bcm_kona_wdt *wdt)\r\n{\r\nif (wdt->resolution > SECWDOG_MAX_RES)\r\nreturn -EINVAL;\r\nreturn bcm_kona_wdt_ctrl_reg_modify(wdt, SECWDOG_RES_MASK,\r\nwdt->resolution << SECWDOG_CLKS_SHIFT);\r\n}\r\nstatic int bcm_kona_wdt_set_timeout_reg(struct watchdog_device *wdog,\r\nunsigned watchdog_flags)\r\n{\r\nstruct bcm_kona_wdt *wdt = watchdog_get_drvdata(wdog);\r\nreturn bcm_kona_wdt_ctrl_reg_modify(wdt, SECWDOG_COUNT_MASK,\r\nSECS_TO_TICKS(wdog->timeout, wdt) |\r\nwatchdog_flags);\r\n}\r\nstatic int bcm_kona_wdt_set_timeout(struct watchdog_device *wdog,\r\nunsigned int t)\r\n{\r\nwdog->timeout = t;\r\nreturn 0;\r\n}\r\nstatic unsigned int bcm_kona_wdt_get_timeleft(struct watchdog_device *wdog)\r\n{\r\nstruct bcm_kona_wdt *wdt = watchdog_get_drvdata(wdog);\r\nint val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&wdt->lock, flags);\r\nval = secure_register_read(wdt, SECWDOG_COUNT_REG);\r\nspin_unlock_irqrestore(&wdt->lock, flags);\r\nif (val < 0)\r\nreturn val;\r\nreturn TICKS_TO_SECS(val & SECWDOG_COUNT_MASK, wdt);\r\n}\r\nstatic int bcm_kona_wdt_start(struct watchdog_device *wdog)\r\n{\r\nreturn bcm_kona_wdt_set_timeout_reg(wdog,\r\nSECWDOG_EN_MASK | SECWDOG_SRSTEN_MASK);\r\n}\r\nstatic int bcm_kona_wdt_stop(struct watchdog_device *wdog)\r\n{\r\nstruct bcm_kona_wdt *wdt = watchdog_get_drvdata(wdog);\r\nreturn bcm_kona_wdt_ctrl_reg_modify(wdt, SECWDOG_EN_MASK |\r\nSECWDOG_SRSTEN_MASK, 0);\r\n}\r\nstatic void bcm_kona_wdt_shutdown(struct platform_device *pdev)\r\n{\r\nbcm_kona_wdt_stop(&bcm_kona_wdt_wdd);\r\n}\r\nstatic int bcm_kona_wdt_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct bcm_kona_wdt *wdt;\r\nstruct resource *res;\r\nint ret;\r\nwdt = devm_kzalloc(dev, sizeof(*wdt), GFP_KERNEL);\r\nif (!wdt)\r\nreturn -ENOMEM;\r\nspin_lock_init(&wdt->lock);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nwdt->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(wdt->base))\r\nreturn -ENODEV;\r\nwdt->resolution = SECWDOG_DEFAULT_RESOLUTION;\r\nret = bcm_kona_wdt_set_resolution_reg(wdt);\r\nif (ret) {\r\ndev_err(dev, "Failed to set resolution (error: %d)", ret);\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, wdt);\r\nwatchdog_set_drvdata(&bcm_kona_wdt_wdd, wdt);\r\nbcm_kona_wdt_wdd.parent = &pdev->dev;\r\nret = bcm_kona_wdt_set_timeout_reg(&bcm_kona_wdt_wdd, 0);\r\nif (ret) {\r\ndev_err(dev, "Failed set watchdog timeout");\r\nreturn ret;\r\n}\r\nret = watchdog_register_device(&bcm_kona_wdt_wdd);\r\nif (ret) {\r\ndev_err(dev, "Failed to register watchdog device");\r\nreturn ret;\r\n}\r\nbcm_kona_wdt_debug_init(pdev);\r\ndev_dbg(dev, "Broadcom Kona Watchdog Timer");\r\nreturn 0;\r\n}\r\nstatic int bcm_kona_wdt_remove(struct platform_device *pdev)\r\n{\r\nbcm_kona_wdt_debug_exit(pdev);\r\nbcm_kona_wdt_shutdown(pdev);\r\nwatchdog_unregister_device(&bcm_kona_wdt_wdd);\r\ndev_dbg(&pdev->dev, "Watchdog driver disabled");\r\nreturn 0;\r\n}
