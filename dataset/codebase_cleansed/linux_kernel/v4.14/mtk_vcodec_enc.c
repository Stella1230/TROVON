static int vidioc_venc_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct mtk_vcodec_ctx *ctx = ctrl_to_ctx(ctrl);\r\nstruct mtk_enc_params *p = &ctx->enc_params;\r\nint ret = 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_MPEG_VIDEO_BITRATE:\r\nmtk_v4l2_debug(2, "V4L2_CID_MPEG_VIDEO_BITRATE val = %d",\r\nctrl->val);\r\np->bitrate = ctrl->val;\r\nctx->param_change |= MTK_ENCODE_PARAM_BITRATE;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_B_FRAMES:\r\nmtk_v4l2_debug(2, "V4L2_CID_MPEG_VIDEO_B_FRAMES val = %d",\r\nctrl->val);\r\np->num_b_frame = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_FRAME_RC_ENABLE:\r\nmtk_v4l2_debug(2, "V4L2_CID_MPEG_VIDEO_FRAME_RC_ENABLE val = %d",\r\nctrl->val);\r\np->rc_frame = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_H264_MAX_QP:\r\nmtk_v4l2_debug(2, "V4L2_CID_MPEG_VIDEO_H264_MAX_QP val = %d",\r\nctrl->val);\r\np->h264_max_qp = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_HEADER_MODE:\r\nmtk_v4l2_debug(2, "V4L2_CID_MPEG_VIDEO_HEADER_MODE val = %d",\r\nctrl->val);\r\np->seq_hdr_mode = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_MB_RC_ENABLE:\r\nmtk_v4l2_debug(2, "V4L2_CID_MPEG_VIDEO_MB_RC_ENABLE val = %d",\r\nctrl->val);\r\np->rc_mb = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_H264_PROFILE:\r\nmtk_v4l2_debug(2, "V4L2_CID_MPEG_VIDEO_H264_PROFILE val = %d",\r\nctrl->val);\r\np->h264_profile = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_H264_LEVEL:\r\nmtk_v4l2_debug(2, "V4L2_CID_MPEG_VIDEO_H264_LEVEL val = %d",\r\nctrl->val);\r\np->h264_level = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_H264_I_PERIOD:\r\nmtk_v4l2_debug(2, "V4L2_CID_MPEG_VIDEO_H264_I_PERIOD val = %d",\r\nctrl->val);\r\np->intra_period = ctrl->val;\r\nctx->param_change |= MTK_ENCODE_PARAM_INTRA_PERIOD;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_GOP_SIZE:\r\nmtk_v4l2_debug(2, "V4L2_CID_MPEG_VIDEO_GOP_SIZE val = %d",\r\nctrl->val);\r\np->gop_size = ctrl->val;\r\nctx->param_change |= MTK_ENCODE_PARAM_GOP_SIZE;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_FORCE_KEY_FRAME:\r\nmtk_v4l2_debug(2, "V4L2_CID_MPEG_VIDEO_FORCE_KEY_FRAME");\r\np->force_intra = 1;\r\nctx->param_change |= MTK_ENCODE_PARAM_FORCE_INTRA;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int vidioc_enum_fmt(struct v4l2_fmtdesc *f, bool output_queue)\r\n{\r\nstruct mtk_video_fmt *fmt;\r\nint i, j = 0;\r\nfor (i = 0; i < NUM_FORMATS; ++i) {\r\nif (output_queue && mtk_video_formats[i].type != MTK_FMT_FRAME)\r\ncontinue;\r\nif (!output_queue && mtk_video_formats[i].type != MTK_FMT_ENC)\r\ncontinue;\r\nif (j == f->index) {\r\nfmt = &mtk_video_formats[i];\r\nf->pixelformat = fmt->fourcc;\r\nmemset(f->reserved, 0, sizeof(f->reserved));\r\nreturn 0;\r\n}\r\n++j;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_enum_framesizes(struct file *file, void *fh,\r\nstruct v4l2_frmsizeenum *fsize)\r\n{\r\nint i = 0;\r\nif (fsize->index != 0)\r\nreturn -EINVAL;\r\nfor (i = 0; i < NUM_SUPPORTED_FRAMESIZE; ++i) {\r\nif (fsize->pixel_format != mtk_venc_framesizes[i].fourcc)\r\ncontinue;\r\nfsize->type = V4L2_FRMSIZE_TYPE_STEPWISE;\r\nfsize->stepwise = mtk_venc_framesizes[i].stepwise;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_enum_fmt_vid_cap_mplane(struct file *file, void *pirv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nreturn vidioc_enum_fmt(f, false);\r\n}\r\nstatic int vidioc_enum_fmt_vid_out_mplane(struct file *file, void *prov,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nreturn vidioc_enum_fmt(f, true);\r\n}\r\nstatic int vidioc_venc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstrlcpy(cap->driver, MTK_VCODEC_ENC_NAME, sizeof(cap->driver));\r\nstrlcpy(cap->bus_info, MTK_PLATFORM_STR, sizeof(cap->bus_info));\r\nstrlcpy(cap->card, MTK_PLATFORM_STR, sizeof(cap->card));\r\nreturn 0;\r\n}\r\nstatic int vidioc_venc_s_parm(struct file *file, void *priv,\r\nstruct v4l2_streamparm *a)\r\n{\r\nstruct mtk_vcodec_ctx *ctx = fh_to_ctx(priv);\r\nif (a->type != V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\r\nreturn -EINVAL;\r\nctx->enc_params.framerate_num =\r\na->parm.output.timeperframe.denominator;\r\nctx->enc_params.framerate_denom =\r\na->parm.output.timeperframe.numerator;\r\nctx->param_change |= MTK_ENCODE_PARAM_FRAMERATE;\r\na->parm.output.capability = V4L2_CAP_TIMEPERFRAME;\r\nreturn 0;\r\n}\r\nstatic int vidioc_venc_g_parm(struct file *file, void *priv,\r\nstruct v4l2_streamparm *a)\r\n{\r\nstruct mtk_vcodec_ctx *ctx = fh_to_ctx(priv);\r\nif (a->type != V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\r\nreturn -EINVAL;\r\na->parm.output.capability = V4L2_CAP_TIMEPERFRAME;\r\na->parm.output.timeperframe.denominator =\r\nctx->enc_params.framerate_num;\r\na->parm.output.timeperframe.numerator =\r\nctx->enc_params.framerate_denom;\r\nreturn 0;\r\n}\r\nstatic struct mtk_q_data *mtk_venc_get_q_data(struct mtk_vcodec_ctx *ctx,\r\nenum v4l2_buf_type type)\r\n{\r\nif (V4L2_TYPE_IS_OUTPUT(type))\r\nreturn &ctx->q_data[MTK_Q_DATA_SRC];\r\nreturn &ctx->q_data[MTK_Q_DATA_DST];\r\n}\r\nstatic struct mtk_video_fmt *mtk_venc_find_format(struct v4l2_format *f)\r\n{\r\nstruct mtk_video_fmt *fmt;\r\nunsigned int k;\r\nfor (k = 0; k < NUM_FORMATS; k++) {\r\nfmt = &mtk_video_formats[k];\r\nif (fmt->fourcc == f->fmt.pix.pixelformat)\r\nreturn fmt;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int vidioc_try_fmt(struct v4l2_format *f, struct mtk_video_fmt *fmt)\r\n{\r\nstruct v4l2_pix_format_mplane *pix_fmt_mp = &f->fmt.pix_mp;\r\nint i;\r\npix_fmt_mp->field = V4L2_FIELD_NONE;\r\nif (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\r\npix_fmt_mp->num_planes = 1;\r\npix_fmt_mp->plane_fmt[0].bytesperline = 0;\r\n} else if (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\r\nint tmp_w, tmp_h;\r\npix_fmt_mp->height = clamp(pix_fmt_mp->height,\r\nMTK_VENC_MIN_H,\r\nMTK_VENC_MAX_H);\r\npix_fmt_mp->width = clamp(pix_fmt_mp->width,\r\nMTK_VENC_MIN_W,\r\nMTK_VENC_MAX_W);\r\ntmp_w = pix_fmt_mp->width;\r\ntmp_h = pix_fmt_mp->height;\r\nv4l_bound_align_image(&pix_fmt_mp->width,\r\nMTK_VENC_MIN_W,\r\nMTK_VENC_MAX_W, 4,\r\n&pix_fmt_mp->height,\r\nMTK_VENC_MIN_H,\r\nMTK_VENC_MAX_H, 5, 6);\r\nif (pix_fmt_mp->width < tmp_w &&\r\n(pix_fmt_mp->width + 16) <= MTK_VENC_MAX_W)\r\npix_fmt_mp->width += 16;\r\nif (pix_fmt_mp->height < tmp_h &&\r\n(pix_fmt_mp->height + 32) <= MTK_VENC_MAX_H)\r\npix_fmt_mp->height += 32;\r\nmtk_v4l2_debug(0,\r\n"before resize width=%d, height=%d, after resize width=%d, height=%d, sizeimage=%d %d",\r\ntmp_w, tmp_h, pix_fmt_mp->width,\r\npix_fmt_mp->height,\r\npix_fmt_mp->plane_fmt[0].sizeimage,\r\npix_fmt_mp->plane_fmt[1].sizeimage);\r\npix_fmt_mp->num_planes = fmt->num_planes;\r\npix_fmt_mp->plane_fmt[0].sizeimage =\r\npix_fmt_mp->width * pix_fmt_mp->height +\r\n((ALIGN(pix_fmt_mp->width, 16) * 2) * 16);\r\npix_fmt_mp->plane_fmt[0].bytesperline = pix_fmt_mp->width;\r\nif (pix_fmt_mp->num_planes == 2) {\r\npix_fmt_mp->plane_fmt[1].sizeimage =\r\n(pix_fmt_mp->width * pix_fmt_mp->height) / 2 +\r\n(ALIGN(pix_fmt_mp->width, 16) * 16);\r\npix_fmt_mp->plane_fmt[2].sizeimage = 0;\r\npix_fmt_mp->plane_fmt[1].bytesperline =\r\npix_fmt_mp->width;\r\npix_fmt_mp->plane_fmt[2].bytesperline = 0;\r\n} else if (pix_fmt_mp->num_planes == 3) {\r\npix_fmt_mp->plane_fmt[1].sizeimage =\r\npix_fmt_mp->plane_fmt[2].sizeimage =\r\n(pix_fmt_mp->width * pix_fmt_mp->height) / 4 +\r\n((ALIGN(pix_fmt_mp->width, 16) / 2) * 16);\r\npix_fmt_mp->plane_fmt[1].bytesperline =\r\npix_fmt_mp->plane_fmt[2].bytesperline =\r\npix_fmt_mp->width / 2;\r\n}\r\n}\r\nfor (i = 0; i < pix_fmt_mp->num_planes; i++)\r\nmemset(&(pix_fmt_mp->plane_fmt[i].reserved[0]), 0x0,\r\nsizeof(pix_fmt_mp->plane_fmt[0].reserved));\r\npix_fmt_mp->flags = 0;\r\nmemset(&pix_fmt_mp->reserved, 0x0,\r\nsizeof(pix_fmt_mp->reserved));\r\nreturn 0;\r\n}\r\nstatic void mtk_venc_set_param(struct mtk_vcodec_ctx *ctx,\r\nstruct venc_enc_param *param)\r\n{\r\nstruct mtk_q_data *q_data_src = &ctx->q_data[MTK_Q_DATA_SRC];\r\nstruct mtk_enc_params *enc_params = &ctx->enc_params;\r\nswitch (q_data_src->fmt->fourcc) {\r\ncase V4L2_PIX_FMT_YUV420M:\r\nparam->input_yuv_fmt = VENC_YUV_FORMAT_I420;\r\nbreak;\r\ncase V4L2_PIX_FMT_YVU420M:\r\nparam->input_yuv_fmt = VENC_YUV_FORMAT_YV12;\r\nbreak;\r\ncase V4L2_PIX_FMT_NV12M:\r\nparam->input_yuv_fmt = VENC_YUV_FORMAT_NV12;\r\nbreak;\r\ncase V4L2_PIX_FMT_NV21M:\r\nparam->input_yuv_fmt = VENC_YUV_FORMAT_NV21;\r\nbreak;\r\ndefault:\r\nmtk_v4l2_err("Unsupport fourcc =%d", q_data_src->fmt->fourcc);\r\nbreak;\r\n}\r\nparam->h264_profile = enc_params->h264_profile;\r\nparam->h264_level = enc_params->h264_level;\r\nparam->width = q_data_src->visible_width;\r\nparam->height = q_data_src->visible_height;\r\nparam->buf_width = q_data_src->coded_width;\r\nparam->buf_height = q_data_src->coded_height;\r\nparam->frm_rate = enc_params->framerate_num /\r\nenc_params->framerate_denom;\r\nparam->intra_period = enc_params->intra_period;\r\nparam->gop_size = enc_params->gop_size;\r\nparam->bitrate = enc_params->bitrate;\r\nmtk_v4l2_debug(0,\r\n"fmt 0x%x, P/L %d/%d, w/h %d/%d, buf %d/%d, fps/bps %d/%d, gop %d, i_period %d",\r\nparam->input_yuv_fmt, param->h264_profile,\r\nparam->h264_level, param->width, param->height,\r\nparam->buf_width, param->buf_height,\r\nparam->frm_rate, param->bitrate,\r\nparam->gop_size, param->intra_period);\r\n}\r\nstatic int vidioc_venc_s_fmt_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct mtk_vcodec_ctx *ctx = fh_to_ctx(priv);\r\nstruct vb2_queue *vq;\r\nstruct mtk_q_data *q_data;\r\nint i, ret;\r\nstruct mtk_video_fmt *fmt;\r\nvq = v4l2_m2m_get_vq(ctx->m2m_ctx, f->type);\r\nif (!vq) {\r\nmtk_v4l2_err("fail to get vq");\r\nreturn -EINVAL;\r\n}\r\nif (vb2_is_busy(vq)) {\r\nmtk_v4l2_err("queue busy");\r\nreturn -EBUSY;\r\n}\r\nq_data = mtk_venc_get_q_data(ctx, f->type);\r\nif (!q_data) {\r\nmtk_v4l2_err("fail to get q data");\r\nreturn -EINVAL;\r\n}\r\nfmt = mtk_venc_find_format(f);\r\nif (!fmt) {\r\nf->fmt.pix.pixelformat = mtk_video_formats[CAP_FMT_IDX].fourcc;\r\nfmt = mtk_venc_find_format(f);\r\n}\r\nq_data->fmt = fmt;\r\nret = vidioc_try_fmt(f, q_data->fmt);\r\nif (ret)\r\nreturn ret;\r\nq_data->coded_width = f->fmt.pix_mp.width;\r\nq_data->coded_height = f->fmt.pix_mp.height;\r\nq_data->field = f->fmt.pix_mp.field;\r\nfor (i = 0; i < f->fmt.pix_mp.num_planes; i++) {\r\nstruct v4l2_plane_pix_format *plane_fmt;\r\nplane_fmt = &f->fmt.pix_mp.plane_fmt[i];\r\nq_data->bytesperline[i] = plane_fmt->bytesperline;\r\nq_data->sizeimage[i] = plane_fmt->sizeimage;\r\n}\r\nif (ctx->state == MTK_STATE_FREE) {\r\nret = venc_if_init(ctx, q_data->fmt->fourcc);\r\nif (ret) {\r\nmtk_v4l2_err("venc_if_init failed=%d, codec type=%x",\r\nret, q_data->fmt->fourcc);\r\nreturn -EBUSY;\r\n}\r\nctx->state = MTK_STATE_INIT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_venc_s_fmt_out(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct mtk_vcodec_ctx *ctx = fh_to_ctx(priv);\r\nstruct vb2_queue *vq;\r\nstruct mtk_q_data *q_data;\r\nint ret, i;\r\nstruct mtk_video_fmt *fmt;\r\nstruct v4l2_pix_format_mplane *pix_fmt_mp = &f->fmt.pix_mp;\r\nvq = v4l2_m2m_get_vq(ctx->m2m_ctx, f->type);\r\nif (!vq) {\r\nmtk_v4l2_err("fail to get vq");\r\nreturn -EINVAL;\r\n}\r\nif (vb2_is_busy(vq)) {\r\nmtk_v4l2_err("queue busy");\r\nreturn -EBUSY;\r\n}\r\nq_data = mtk_venc_get_q_data(ctx, f->type);\r\nif (!q_data) {\r\nmtk_v4l2_err("fail to get q data");\r\nreturn -EINVAL;\r\n}\r\nfmt = mtk_venc_find_format(f);\r\nif (!fmt) {\r\nf->fmt.pix.pixelformat = mtk_video_formats[OUT_FMT_IDX].fourcc;\r\nfmt = mtk_venc_find_format(f);\r\n}\r\npix_fmt_mp->height = clamp(pix_fmt_mp->height,\r\nMTK_VENC_MIN_H,\r\nMTK_VENC_MAX_H);\r\npix_fmt_mp->width = clamp(pix_fmt_mp->width,\r\nMTK_VENC_MIN_W,\r\nMTK_VENC_MAX_W);\r\nq_data->visible_width = f->fmt.pix_mp.width;\r\nq_data->visible_height = f->fmt.pix_mp.height;\r\nq_data->fmt = fmt;\r\nret = vidioc_try_fmt(f, q_data->fmt);\r\nif (ret)\r\nreturn ret;\r\nq_data->coded_width = f->fmt.pix_mp.width;\r\nq_data->coded_height = f->fmt.pix_mp.height;\r\nq_data->field = f->fmt.pix_mp.field;\r\nctx->colorspace = f->fmt.pix_mp.colorspace;\r\nctx->ycbcr_enc = f->fmt.pix_mp.ycbcr_enc;\r\nctx->quantization = f->fmt.pix_mp.quantization;\r\nctx->xfer_func = f->fmt.pix_mp.xfer_func;\r\nfor (i = 0; i < f->fmt.pix_mp.num_planes; i++) {\r\nstruct v4l2_plane_pix_format *plane_fmt;\r\nplane_fmt = &f->fmt.pix_mp.plane_fmt[i];\r\nq_data->bytesperline[i] = plane_fmt->bytesperline;\r\nq_data->sizeimage[i] = plane_fmt->sizeimage;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_venc_g_fmt(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct v4l2_pix_format_mplane *pix = &f->fmt.pix_mp;\r\nstruct mtk_vcodec_ctx *ctx = fh_to_ctx(priv);\r\nstruct vb2_queue *vq;\r\nstruct mtk_q_data *q_data;\r\nint i;\r\nvq = v4l2_m2m_get_vq(ctx->m2m_ctx, f->type);\r\nif (!vq)\r\nreturn -EINVAL;\r\nq_data = mtk_venc_get_q_data(ctx, f->type);\r\npix->width = q_data->coded_width;\r\npix->height = q_data->coded_height;\r\npix->pixelformat = q_data->fmt->fourcc;\r\npix->field = q_data->field;\r\npix->num_planes = q_data->fmt->num_planes;\r\nfor (i = 0; i < pix->num_planes; i++) {\r\npix->plane_fmt[i].bytesperline = q_data->bytesperline[i];\r\npix->plane_fmt[i].sizeimage = q_data->sizeimage[i];\r\nmemset(&(pix->plane_fmt[i].reserved[0]), 0x0,\r\nsizeof(pix->plane_fmt[i].reserved));\r\n}\r\npix->flags = 0;\r\npix->colorspace = ctx->colorspace;\r\npix->ycbcr_enc = ctx->ycbcr_enc;\r\npix->quantization = ctx->quantization;\r\npix->xfer_func = ctx->xfer_func;\r\nreturn 0;\r\n}\r\nstatic int vidioc_try_fmt_vid_cap_mplane(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct mtk_video_fmt *fmt;\r\nstruct mtk_vcodec_ctx *ctx = fh_to_ctx(priv);\r\nfmt = mtk_venc_find_format(f);\r\nif (!fmt) {\r\nf->fmt.pix.pixelformat = mtk_video_formats[CAP_FMT_IDX].fourcc;\r\nfmt = mtk_venc_find_format(f);\r\n}\r\nf->fmt.pix_mp.colorspace = ctx->colorspace;\r\nf->fmt.pix_mp.ycbcr_enc = ctx->ycbcr_enc;\r\nf->fmt.pix_mp.quantization = ctx->quantization;\r\nf->fmt.pix_mp.xfer_func = ctx->xfer_func;\r\nreturn vidioc_try_fmt(f, fmt);\r\n}\r\nstatic int vidioc_try_fmt_vid_out_mplane(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct mtk_video_fmt *fmt;\r\nfmt = mtk_venc_find_format(f);\r\nif (!fmt) {\r\nf->fmt.pix.pixelformat = mtk_video_formats[OUT_FMT_IDX].fourcc;\r\nfmt = mtk_venc_find_format(f);\r\n}\r\nif (!f->fmt.pix_mp.colorspace) {\r\nf->fmt.pix_mp.colorspace = V4L2_COLORSPACE_REC709;\r\nf->fmt.pix_mp.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;\r\nf->fmt.pix_mp.quantization = V4L2_QUANTIZATION_DEFAULT;\r\nf->fmt.pix_mp.xfer_func = V4L2_XFER_FUNC_DEFAULT;\r\n}\r\nreturn vidioc_try_fmt(f, fmt);\r\n}\r\nstatic int vidioc_venc_g_selection(struct file *file, void *priv,\r\nstruct v4l2_selection *s)\r\n{\r\nstruct mtk_vcodec_ctx *ctx = fh_to_ctx(priv);\r\nstruct mtk_q_data *q_data;\r\nif (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\r\nreturn -EINVAL;\r\nq_data = mtk_venc_get_q_data(ctx, s->type);\r\nif (!q_data)\r\nreturn -EINVAL;\r\nswitch (s->target) {\r\ncase V4L2_SEL_TGT_CROP_DEFAULT:\r\ncase V4L2_SEL_TGT_CROP_BOUNDS:\r\ns->r.top = 0;\r\ns->r.left = 0;\r\ns->r.width = q_data->coded_width;\r\ns->r.height = q_data->coded_height;\r\nbreak;\r\ncase V4L2_SEL_TGT_CROP:\r\ns->r.top = 0;\r\ns->r.left = 0;\r\ns->r.width = q_data->visible_width;\r\ns->r.height = q_data->visible_height;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_venc_s_selection(struct file *file, void *priv,\r\nstruct v4l2_selection *s)\r\n{\r\nstruct mtk_vcodec_ctx *ctx = fh_to_ctx(priv);\r\nstruct mtk_q_data *q_data;\r\nif (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\r\nreturn -EINVAL;\r\nq_data = mtk_venc_get_q_data(ctx, s->type);\r\nif (!q_data)\r\nreturn -EINVAL;\r\nswitch (s->target) {\r\ncase V4L2_SEL_TGT_CROP:\r\ns->r.top = 0;\r\ns->r.left = 0;\r\ns->r.width = min(s->r.width, q_data->coded_width);\r\ns->r.height = min(s->r.height, q_data->coded_height);\r\nq_data->visible_width = s->r.width;\r\nq_data->visible_height = s->r.height;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_venc_qbuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *buf)\r\n{\r\nstruct mtk_vcodec_ctx *ctx = fh_to_ctx(priv);\r\nif (ctx->state == MTK_STATE_ABORT) {\r\nmtk_v4l2_err("[%d] Call on QBUF after unrecoverable error",\r\nctx->id);\r\nreturn -EIO;\r\n}\r\nreturn v4l2_m2m_qbuf(file, ctx->m2m_ctx, buf);\r\n}\r\nstatic int vidioc_venc_dqbuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *buf)\r\n{\r\nstruct mtk_vcodec_ctx *ctx = fh_to_ctx(priv);\r\nif (ctx->state == MTK_STATE_ABORT) {\r\nmtk_v4l2_err("[%d] Call on QBUF after unrecoverable error",\r\nctx->id);\r\nreturn -EIO;\r\n}\r\nreturn v4l2_m2m_dqbuf(file, ctx->m2m_ctx, buf);\r\n}\r\nstatic int vb2ops_venc_queue_setup(struct vb2_queue *vq,\r\nunsigned int *nbuffers,\r\nunsigned int *nplanes,\r\nunsigned int sizes[],\r\nstruct device *alloc_devs[])\r\n{\r\nstruct mtk_vcodec_ctx *ctx = vb2_get_drv_priv(vq);\r\nstruct mtk_q_data *q_data;\r\nunsigned int i;\r\nq_data = mtk_venc_get_q_data(ctx, vq->type);\r\nif (q_data == NULL)\r\nreturn -EINVAL;\r\nif (*nplanes) {\r\nfor (i = 0; i < *nplanes; i++)\r\nif (sizes[i] < q_data->sizeimage[i])\r\nreturn -EINVAL;\r\n} else {\r\n*nplanes = q_data->fmt->num_planes;\r\nfor (i = 0; i < *nplanes; i++)\r\nsizes[i] = q_data->sizeimage[i];\r\n}\r\nreturn 0;\r\n}\r\nstatic int vb2ops_venc_buf_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct mtk_vcodec_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct mtk_q_data *q_data;\r\nint i;\r\nq_data = mtk_venc_get_q_data(ctx, vb->vb2_queue->type);\r\nfor (i = 0; i < q_data->fmt->num_planes; i++) {\r\nif (vb2_plane_size(vb, i) < q_data->sizeimage[i]) {\r\nmtk_v4l2_err("data will not fit into plane %d (%lu < %d)",\r\ni, vb2_plane_size(vb, i),\r\nq_data->sizeimage[i]);\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void vb2ops_venc_buf_queue(struct vb2_buffer *vb)\r\n{\r\nstruct mtk_vcodec_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct vb2_v4l2_buffer *vb2_v4l2 =\r\ncontainer_of(vb, struct vb2_v4l2_buffer, vb2_buf);\r\nstruct mtk_video_enc_buf *mtk_buf =\r\ncontainer_of(vb2_v4l2, struct mtk_video_enc_buf, vb);\r\nif ((vb->vb2_queue->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) &&\r\n(ctx->param_change != MTK_ENCODE_PARAM_NONE)) {\r\nmtk_v4l2_debug(1, "[%d] Before id=%d encode parameter change %x",\r\nctx->id,\r\nmtk_buf->vb.vb2_buf.index,\r\nctx->param_change);\r\nmtk_buf->param_change = ctx->param_change;\r\nmtk_buf->enc_params = ctx->enc_params;\r\nctx->param_change = MTK_ENCODE_PARAM_NONE;\r\n}\r\nv4l2_m2m_buf_queue(ctx->m2m_ctx, to_vb2_v4l2_buffer(vb));\r\n}\r\nstatic int vb2ops_venc_start_streaming(struct vb2_queue *q, unsigned int count)\r\n{\r\nstruct mtk_vcodec_ctx *ctx = vb2_get_drv_priv(q);\r\nstruct venc_enc_param param;\r\nint ret;\r\nint i;\r\nif ((ctx->state == MTK_STATE_ABORT) || (ctx->state == MTK_STATE_FREE)) {\r\nret = -EIO;\r\ngoto err_set_param;\r\n}\r\nif (V4L2_TYPE_IS_OUTPUT(q->type)) {\r\nif (!vb2_start_streaming_called(&ctx->m2m_ctx->cap_q_ctx.q))\r\nreturn 0;\r\n} else {\r\nif (!vb2_start_streaming_called(&ctx->m2m_ctx->out_q_ctx.q))\r\nreturn 0;\r\n}\r\nmtk_venc_set_param(ctx, &param);\r\nret = venc_if_set_param(ctx, VENC_SET_PARAM_ENC, &param);\r\nif (ret) {\r\nmtk_v4l2_err("venc_if_set_param failed=%d", ret);\r\nctx->state = MTK_STATE_ABORT;\r\ngoto err_set_param;\r\n}\r\nctx->param_change = MTK_ENCODE_PARAM_NONE;\r\nif ((ctx->q_data[MTK_Q_DATA_DST].fmt->fourcc == V4L2_PIX_FMT_H264) &&\r\n(ctx->enc_params.seq_hdr_mode !=\r\nV4L2_MPEG_VIDEO_HEADER_MODE_SEPARATE)) {\r\nret = venc_if_set_param(ctx,\r\nVENC_SET_PARAM_PREPEND_HEADER,\r\nNULL);\r\nif (ret) {\r\nmtk_v4l2_err("venc_if_set_param failed=%d", ret);\r\nctx->state = MTK_STATE_ABORT;\r\ngoto err_set_param;\r\n}\r\nctx->state = MTK_STATE_HEADER;\r\n}\r\nreturn 0;\r\nerr_set_param:\r\nfor (i = 0; i < q->num_buffers; ++i) {\r\nif (q->bufs[i]->state == VB2_BUF_STATE_ACTIVE) {\r\nmtk_v4l2_debug(0, "[%d] id=%d, type=%d, %d -> VB2_BUF_STATE_QUEUED",\r\nctx->id, i, q->type,\r\n(int)q->bufs[i]->state);\r\nv4l2_m2m_buf_done(to_vb2_v4l2_buffer(q->bufs[i]),\r\nVB2_BUF_STATE_QUEUED);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void vb2ops_venc_stop_streaming(struct vb2_queue *q)\r\n{\r\nstruct mtk_vcodec_ctx *ctx = vb2_get_drv_priv(q);\r\nstruct vb2_buffer *src_buf, *dst_buf;\r\nint ret;\r\nmtk_v4l2_debug(2, "[%d]-> type=%d", ctx->id, q->type);\r\nif (q->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\r\nwhile ((dst_buf = v4l2_m2m_dst_buf_remove(ctx->m2m_ctx))) {\r\ndst_buf->planes[0].bytesused = 0;\r\nv4l2_m2m_buf_done(to_vb2_v4l2_buffer(dst_buf),\r\nVB2_BUF_STATE_ERROR);\r\n}\r\n} else {\r\nwhile ((src_buf = v4l2_m2m_src_buf_remove(ctx->m2m_ctx)))\r\nv4l2_m2m_buf_done(to_vb2_v4l2_buffer(src_buf),\r\nVB2_BUF_STATE_ERROR);\r\n}\r\nif ((q->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE &&\r\nvb2_is_streaming(&ctx->m2m_ctx->out_q_ctx.q)) ||\r\n(q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE &&\r\nvb2_is_streaming(&ctx->m2m_ctx->cap_q_ctx.q))) {\r\nmtk_v4l2_debug(1, "[%d]-> q type %d out=%d cap=%d",\r\nctx->id, q->type,\r\nvb2_is_streaming(&ctx->m2m_ctx->out_q_ctx.q),\r\nvb2_is_streaming(&ctx->m2m_ctx->cap_q_ctx.q));\r\nreturn;\r\n}\r\nret = venc_if_deinit(ctx);\r\nif (ret)\r\nmtk_v4l2_err("venc_if_deinit failed=%d", ret);\r\nctx->state = MTK_STATE_FREE;\r\n}\r\nstatic int mtk_venc_encode_header(void *priv)\r\n{\r\nstruct mtk_vcodec_ctx *ctx = priv;\r\nint ret;\r\nstruct vb2_buffer *src_buf, *dst_buf;\r\nstruct vb2_v4l2_buffer *dst_vb2_v4l2, *src_vb2_v4l2;\r\nstruct mtk_vcodec_mem bs_buf;\r\nstruct venc_done_result enc_result;\r\ndst_buf = v4l2_m2m_dst_buf_remove(ctx->m2m_ctx);\r\nif (!dst_buf) {\r\nmtk_v4l2_debug(1, "No dst buffer");\r\nreturn -EINVAL;\r\n}\r\nbs_buf.va = vb2_plane_vaddr(dst_buf, 0);\r\nbs_buf.dma_addr = vb2_dma_contig_plane_dma_addr(dst_buf, 0);\r\nbs_buf.size = (size_t)dst_buf->planes[0].length;\r\nmtk_v4l2_debug(1,\r\n"[%d] buf id=%d va=0x%p dma_addr=0x%llx size=%zu",\r\nctx->id,\r\ndst_buf->index, bs_buf.va,\r\n(u64)bs_buf.dma_addr,\r\nbs_buf.size);\r\nret = venc_if_encode(ctx,\r\nVENC_START_OPT_ENCODE_SEQUENCE_HEADER,\r\nNULL, &bs_buf, &enc_result);\r\nif (ret) {\r\ndst_buf->planes[0].bytesused = 0;\r\nctx->state = MTK_STATE_ABORT;\r\nv4l2_m2m_buf_done(to_vb2_v4l2_buffer(dst_buf),\r\nVB2_BUF_STATE_ERROR);\r\nmtk_v4l2_err("venc_if_encode failed=%d", ret);\r\nreturn -EINVAL;\r\n}\r\nsrc_buf = v4l2_m2m_next_src_buf(ctx->m2m_ctx);\r\nif (src_buf) {\r\nsrc_vb2_v4l2 = to_vb2_v4l2_buffer(src_buf);\r\ndst_vb2_v4l2 = to_vb2_v4l2_buffer(dst_buf);\r\ndst_buf->timestamp = src_buf->timestamp;\r\ndst_vb2_v4l2->timecode = src_vb2_v4l2->timecode;\r\n} else {\r\nmtk_v4l2_err("No timestamp for the header buffer.");\r\n}\r\nctx->state = MTK_STATE_HEADER;\r\ndst_buf->planes[0].bytesused = enc_result.bs_size;\r\nv4l2_m2m_buf_done(to_vb2_v4l2_buffer(dst_buf), VB2_BUF_STATE_DONE);\r\nreturn 0;\r\n}\r\nstatic int mtk_venc_param_change(struct mtk_vcodec_ctx *ctx)\r\n{\r\nstruct venc_enc_param enc_prm;\r\nstruct vb2_buffer *vb = v4l2_m2m_next_src_buf(ctx->m2m_ctx);\r\nstruct vb2_v4l2_buffer *vb2_v4l2 =\r\ncontainer_of(vb, struct vb2_v4l2_buffer, vb2_buf);\r\nstruct mtk_video_enc_buf *mtk_buf =\r\ncontainer_of(vb2_v4l2, struct mtk_video_enc_buf, vb);\r\nint ret = 0;\r\nmemset(&enc_prm, 0, sizeof(enc_prm));\r\nif (mtk_buf->param_change == MTK_ENCODE_PARAM_NONE)\r\nreturn 0;\r\nif (mtk_buf->param_change & MTK_ENCODE_PARAM_BITRATE) {\r\nenc_prm.bitrate = mtk_buf->enc_params.bitrate;\r\nmtk_v4l2_debug(1, "[%d] id=%d, change param br=%d",\r\nctx->id,\r\nmtk_buf->vb.vb2_buf.index,\r\nenc_prm.bitrate);\r\nret |= venc_if_set_param(ctx,\r\nVENC_SET_PARAM_ADJUST_BITRATE,\r\n&enc_prm);\r\n}\r\nif (!ret && mtk_buf->param_change & MTK_ENCODE_PARAM_FRAMERATE) {\r\nenc_prm.frm_rate = mtk_buf->enc_params.framerate_num /\r\nmtk_buf->enc_params.framerate_denom;\r\nmtk_v4l2_debug(1, "[%d] id=%d, change param fr=%d",\r\nctx->id,\r\nmtk_buf->vb.vb2_buf.index,\r\nenc_prm.frm_rate);\r\nret |= venc_if_set_param(ctx,\r\nVENC_SET_PARAM_ADJUST_FRAMERATE,\r\n&enc_prm);\r\n}\r\nif (!ret && mtk_buf->param_change & MTK_ENCODE_PARAM_GOP_SIZE) {\r\nenc_prm.gop_size = mtk_buf->enc_params.gop_size;\r\nmtk_v4l2_debug(1, "change param intra period=%d",\r\nenc_prm.gop_size);\r\nret |= venc_if_set_param(ctx,\r\nVENC_SET_PARAM_GOP_SIZE,\r\n&enc_prm);\r\n}\r\nif (!ret && mtk_buf->param_change & MTK_ENCODE_PARAM_FORCE_INTRA) {\r\nmtk_v4l2_debug(1, "[%d] id=%d, change param force I=%d",\r\nctx->id,\r\nmtk_buf->vb.vb2_buf.index,\r\nmtk_buf->enc_params.force_intra);\r\nif (mtk_buf->enc_params.force_intra)\r\nret |= venc_if_set_param(ctx,\r\nVENC_SET_PARAM_FORCE_INTRA,\r\nNULL);\r\n}\r\nmtk_buf->param_change = MTK_ENCODE_PARAM_NONE;\r\nif (ret) {\r\nctx->state = MTK_STATE_ABORT;\r\nmtk_v4l2_err("venc_if_set_param %d failed=%d",\r\nmtk_buf->param_change, ret);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mtk_venc_worker(struct work_struct *work)\r\n{\r\nstruct mtk_vcodec_ctx *ctx = container_of(work, struct mtk_vcodec_ctx,\r\nencode_work);\r\nstruct vb2_buffer *src_buf, *dst_buf;\r\nstruct venc_frm_buf frm_buf;\r\nstruct mtk_vcodec_mem bs_buf;\r\nstruct venc_done_result enc_result;\r\nint ret, i;\r\nstruct vb2_v4l2_buffer *dst_vb2_v4l2, *src_vb2_v4l2;\r\ndst_buf = v4l2_m2m_dst_buf_remove(ctx->m2m_ctx);\r\nif (!dst_buf) {\r\nv4l2_m2m_job_finish(ctx->dev->m2m_dev_enc, ctx->m2m_ctx);\r\nreturn;\r\n}\r\nsrc_buf = v4l2_m2m_src_buf_remove(ctx->m2m_ctx);\r\nmemset(&frm_buf, 0, sizeof(frm_buf));\r\nfor (i = 0; i < src_buf->num_planes ; i++) {\r\nfrm_buf.fb_addr[i].va = vb2_plane_vaddr(src_buf, i);\r\nfrm_buf.fb_addr[i].dma_addr =\r\nvb2_dma_contig_plane_dma_addr(src_buf, i);\r\nfrm_buf.fb_addr[i].size =\r\n(size_t)src_buf->planes[i].length;\r\n}\r\nbs_buf.va = vb2_plane_vaddr(dst_buf, 0);\r\nbs_buf.dma_addr = vb2_dma_contig_plane_dma_addr(dst_buf, 0);\r\nbs_buf.size = (size_t)dst_buf->planes[0].length;\r\nmtk_v4l2_debug(2,\r\n"Framebuf VA=%p PA=%llx Size=0x%zx;VA=%p PA=0x%llx Size=0x%zx;VA=%p PA=0x%llx Size=%zu",\r\nfrm_buf.fb_addr[0].va,\r\n(u64)frm_buf.fb_addr[0].dma_addr,\r\nfrm_buf.fb_addr[0].size,\r\nfrm_buf.fb_addr[1].va,\r\n(u64)frm_buf.fb_addr[1].dma_addr,\r\nfrm_buf.fb_addr[1].size,\r\nfrm_buf.fb_addr[2].va,\r\n(u64)frm_buf.fb_addr[2].dma_addr,\r\nfrm_buf.fb_addr[2].size);\r\nret = venc_if_encode(ctx, VENC_START_OPT_ENCODE_FRAME,\r\n&frm_buf, &bs_buf, &enc_result);\r\nsrc_vb2_v4l2 = to_vb2_v4l2_buffer(src_buf);\r\ndst_vb2_v4l2 = to_vb2_v4l2_buffer(dst_buf);\r\ndst_buf->timestamp = src_buf->timestamp;\r\ndst_vb2_v4l2->timecode = src_vb2_v4l2->timecode;\r\nif (enc_result.is_key_frm)\r\ndst_vb2_v4l2->flags |= V4L2_BUF_FLAG_KEYFRAME;\r\nif (ret) {\r\nv4l2_m2m_buf_done(to_vb2_v4l2_buffer(src_buf),\r\nVB2_BUF_STATE_ERROR);\r\ndst_buf->planes[0].bytesused = 0;\r\nv4l2_m2m_buf_done(to_vb2_v4l2_buffer(dst_buf),\r\nVB2_BUF_STATE_ERROR);\r\nmtk_v4l2_err("venc_if_encode failed=%d", ret);\r\n} else {\r\nv4l2_m2m_buf_done(to_vb2_v4l2_buffer(src_buf),\r\nVB2_BUF_STATE_DONE);\r\ndst_buf->planes[0].bytesused = enc_result.bs_size;\r\nv4l2_m2m_buf_done(to_vb2_v4l2_buffer(dst_buf),\r\nVB2_BUF_STATE_DONE);\r\nmtk_v4l2_debug(2, "venc_if_encode bs size=%d",\r\nenc_result.bs_size);\r\n}\r\nv4l2_m2m_job_finish(ctx->dev->m2m_dev_enc, ctx->m2m_ctx);\r\nmtk_v4l2_debug(1, "<=== src_buf[%d] dst_buf[%d] venc_if_encode ret=%d Size=%u===>",\r\nsrc_buf->index, dst_buf->index, ret,\r\nenc_result.bs_size);\r\n}\r\nstatic void m2mops_venc_device_run(void *priv)\r\n{\r\nstruct mtk_vcodec_ctx *ctx = priv;\r\nif ((ctx->q_data[MTK_Q_DATA_DST].fmt->fourcc == V4L2_PIX_FMT_H264) &&\r\n(ctx->state != MTK_STATE_HEADER)) {\r\nmtk_venc_encode_header(ctx);\r\nqueue_work(ctx->dev->encode_workqueue, &ctx->encode_work);\r\nreturn;\r\n}\r\nmtk_venc_param_change(ctx);\r\nqueue_work(ctx->dev->encode_workqueue, &ctx->encode_work);\r\n}\r\nstatic int m2mops_venc_job_ready(void *m2m_priv)\r\n{\r\nstruct mtk_vcodec_ctx *ctx = m2m_priv;\r\nif (ctx->state == MTK_STATE_ABORT || ctx->state == MTK_STATE_FREE) {\r\nmtk_v4l2_debug(3, "[%d]Not ready: state=0x%x.",\r\nctx->id, ctx->state);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic void m2mops_venc_job_abort(void *priv)\r\n{\r\nstruct mtk_vcodec_ctx *ctx = priv;\r\nctx->state = MTK_STATE_ABORT;\r\n}\r\nstatic void m2mops_venc_lock(void *m2m_priv)\r\n{\r\nstruct mtk_vcodec_ctx *ctx = m2m_priv;\r\nmutex_lock(&ctx->dev->dev_mutex);\r\n}\r\nstatic void m2mops_venc_unlock(void *m2m_priv)\r\n{\r\nstruct mtk_vcodec_ctx *ctx = m2m_priv;\r\nmutex_unlock(&ctx->dev->dev_mutex);\r\n}\r\nvoid mtk_vcodec_enc_set_default_params(struct mtk_vcodec_ctx *ctx)\r\n{\r\nstruct mtk_q_data *q_data;\r\nctx->m2m_ctx->q_lock = &ctx->dev->dev_mutex;\r\nctx->fh.m2m_ctx = ctx->m2m_ctx;\r\nctx->fh.ctrl_handler = &ctx->ctrl_hdl;\r\nINIT_WORK(&ctx->encode_work, mtk_venc_worker);\r\nctx->colorspace = V4L2_COLORSPACE_REC709;\r\nctx->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;\r\nctx->quantization = V4L2_QUANTIZATION_DEFAULT;\r\nctx->xfer_func = V4L2_XFER_FUNC_DEFAULT;\r\nq_data = &ctx->q_data[MTK_Q_DATA_SRC];\r\nmemset(q_data, 0, sizeof(struct mtk_q_data));\r\nq_data->visible_width = DFT_CFG_WIDTH;\r\nq_data->visible_height = DFT_CFG_HEIGHT;\r\nq_data->coded_width = DFT_CFG_WIDTH;\r\nq_data->coded_height = DFT_CFG_HEIGHT;\r\nq_data->field = V4L2_FIELD_NONE;\r\nq_data->fmt = &mtk_video_formats[OUT_FMT_IDX];\r\nv4l_bound_align_image(&q_data->coded_width,\r\nMTK_VENC_MIN_W,\r\nMTK_VENC_MAX_W, 4,\r\n&q_data->coded_height,\r\nMTK_VENC_MIN_H,\r\nMTK_VENC_MAX_H, 5, 6);\r\nif (q_data->coded_width < DFT_CFG_WIDTH &&\r\n(q_data->coded_width + 16) <= MTK_VENC_MAX_W)\r\nq_data->coded_width += 16;\r\nif (q_data->coded_height < DFT_CFG_HEIGHT &&\r\n(q_data->coded_height + 32) <= MTK_VENC_MAX_H)\r\nq_data->coded_height += 32;\r\nq_data->sizeimage[0] =\r\nq_data->coded_width * q_data->coded_height+\r\n((ALIGN(q_data->coded_width, 16) * 2) * 16);\r\nq_data->bytesperline[0] = q_data->coded_width;\r\nq_data->sizeimage[1] =\r\n(q_data->coded_width * q_data->coded_height) / 2 +\r\n(ALIGN(q_data->coded_width, 16) * 16);\r\nq_data->bytesperline[1] = q_data->coded_width;\r\nq_data = &ctx->q_data[MTK_Q_DATA_DST];\r\nmemset(q_data, 0, sizeof(struct mtk_q_data));\r\nq_data->coded_width = DFT_CFG_WIDTH;\r\nq_data->coded_height = DFT_CFG_HEIGHT;\r\nq_data->fmt = &mtk_video_formats[CAP_FMT_IDX];\r\nq_data->field = V4L2_FIELD_NONE;\r\nctx->q_data[MTK_Q_DATA_DST].sizeimage[0] =\r\nDFT_CFG_WIDTH * DFT_CFG_HEIGHT;\r\nctx->q_data[MTK_Q_DATA_DST].bytesperline[0] = 0;\r\n}\r\nint mtk_vcodec_enc_ctrls_setup(struct mtk_vcodec_ctx *ctx)\r\n{\r\nconst struct v4l2_ctrl_ops *ops = &mtk_vcodec_enc_ctrl_ops;\r\nstruct v4l2_ctrl_handler *handler = &ctx->ctrl_hdl;\r\nv4l2_ctrl_handler_init(handler, MTK_MAX_CTRLS_HINT);\r\nv4l2_ctrl_new_std(handler, ops, V4L2_CID_MPEG_VIDEO_BITRATE,\r\n1, 4000000, 1, 4000000);\r\nv4l2_ctrl_new_std(handler, ops, V4L2_CID_MPEG_VIDEO_B_FRAMES,\r\n0, 2, 1, 0);\r\nv4l2_ctrl_new_std(handler, ops, V4L2_CID_MPEG_VIDEO_FRAME_RC_ENABLE,\r\n0, 1, 1, 1);\r\nv4l2_ctrl_new_std(handler, ops, V4L2_CID_MPEG_VIDEO_H264_MAX_QP,\r\n0, 51, 1, 51);\r\nv4l2_ctrl_new_std(handler, ops, V4L2_CID_MPEG_VIDEO_H264_I_PERIOD,\r\n0, 65535, 1, 0);\r\nv4l2_ctrl_new_std(handler, ops, V4L2_CID_MPEG_VIDEO_GOP_SIZE,\r\n0, 65535, 1, 0);\r\nv4l2_ctrl_new_std(handler, ops, V4L2_CID_MPEG_VIDEO_MB_RC_ENABLE,\r\n0, 1, 1, 0);\r\nv4l2_ctrl_new_std(handler, ops, V4L2_CID_MPEG_VIDEO_FORCE_KEY_FRAME,\r\n0, 0, 0, 0);\r\nv4l2_ctrl_new_std_menu(handler, ops,\r\nV4L2_CID_MPEG_VIDEO_HEADER_MODE,\r\nV4L2_MPEG_VIDEO_HEADER_MODE_JOINED_WITH_1ST_FRAME,\r\n0, V4L2_MPEG_VIDEO_HEADER_MODE_SEPARATE);\r\nv4l2_ctrl_new_std_menu(handler, ops, V4L2_CID_MPEG_VIDEO_H264_PROFILE,\r\nV4L2_MPEG_VIDEO_H264_PROFILE_HIGH,\r\n0, V4L2_MPEG_VIDEO_H264_PROFILE_HIGH);\r\nv4l2_ctrl_new_std_menu(handler, ops, V4L2_CID_MPEG_VIDEO_H264_LEVEL,\r\nV4L2_MPEG_VIDEO_H264_LEVEL_4_2,\r\n0, V4L2_MPEG_VIDEO_H264_LEVEL_4_0);\r\nif (handler->error) {\r\nmtk_v4l2_err("Init control handler fail %d",\r\nhandler->error);\r\nreturn handler->error;\r\n}\r\nv4l2_ctrl_handler_setup(&ctx->ctrl_hdl);\r\nreturn 0;\r\n}\r\nint mtk_vcodec_enc_queue_init(void *priv, struct vb2_queue *src_vq,\r\nstruct vb2_queue *dst_vq)\r\n{\r\nstruct mtk_vcodec_ctx *ctx = priv;\r\nint ret;\r\nsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\r\nsrc_vq->io_modes = VB2_DMABUF | VB2_MMAP | VB2_USERPTR;\r\nsrc_vq->drv_priv = ctx;\r\nsrc_vq->buf_struct_size = sizeof(struct mtk_video_enc_buf);\r\nsrc_vq->ops = &mtk_venc_vb2_ops;\r\nsrc_vq->mem_ops = &vb2_dma_contig_memops;\r\nsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\r\nsrc_vq->lock = &ctx->dev->dev_mutex;\r\nsrc_vq->dev = &ctx->dev->plat_dev->dev;\r\nret = vb2_queue_init(src_vq);\r\nif (ret)\r\nreturn ret;\r\ndst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\r\ndst_vq->io_modes = VB2_DMABUF | VB2_MMAP | VB2_USERPTR;\r\ndst_vq->drv_priv = ctx;\r\ndst_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\r\ndst_vq->ops = &mtk_venc_vb2_ops;\r\ndst_vq->mem_ops = &vb2_dma_contig_memops;\r\ndst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\r\ndst_vq->lock = &ctx->dev->dev_mutex;\r\ndst_vq->dev = &ctx->dev->plat_dev->dev;\r\nreturn vb2_queue_init(dst_vq);\r\n}\r\nint mtk_venc_unlock(struct mtk_vcodec_ctx *ctx)\r\n{\r\nstruct mtk_vcodec_dev *dev = ctx->dev;\r\nmutex_unlock(&dev->enc_mutex);\r\nreturn 0;\r\n}\r\nint mtk_venc_lock(struct mtk_vcodec_ctx *ctx)\r\n{\r\nstruct mtk_vcodec_dev *dev = ctx->dev;\r\nmutex_lock(&dev->enc_mutex);\r\nreturn 0;\r\n}\r\nvoid mtk_vcodec_enc_release(struct mtk_vcodec_ctx *ctx)\r\n{\r\nint ret = venc_if_deinit(ctx);\r\nif (ret)\r\nmtk_v4l2_err("venc_if_deinit failed=%d", ret);\r\nctx->state = MTK_STATE_FREE;\r\n}
