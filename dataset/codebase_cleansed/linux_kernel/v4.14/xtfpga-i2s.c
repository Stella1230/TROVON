static bool xtfpga_i2s_wr_reg(struct device *dev, unsigned int reg)\r\n{\r\nreturn reg >= XTFPGA_I2S_CONFIG;\r\n}\r\nstatic bool xtfpga_i2s_rd_reg(struct device *dev, unsigned int reg)\r\n{\r\nreturn reg < XTFPGA_I2S_CHAN0_DATA;\r\n}\r\nstatic bool xtfpga_i2s_volatile_reg(struct device *dev, unsigned int reg)\r\n{\r\nreturn reg == XTFPGA_I2S_INT_STATUS;\r\n}\r\nstatic bool xtfpga_pcm_push_tx(struct xtfpga_i2s *i2s)\r\n{\r\nstruct snd_pcm_substream *tx_substream;\r\nbool tx_active;\r\nrcu_read_lock();\r\ntx_substream = rcu_dereference(i2s->tx_substream);\r\ntx_active = tx_substream && snd_pcm_running(tx_substream);\r\nif (tx_active) {\r\nunsigned tx_ptr = ACCESS_ONCE(i2s->tx_ptr);\r\nunsigned new_tx_ptr = i2s->tx_fn(i2s, tx_substream->runtime,\r\ntx_ptr);\r\ncmpxchg(&i2s->tx_ptr, tx_ptr, new_tx_ptr);\r\n}\r\nrcu_read_unlock();\r\nreturn tx_active;\r\n}\r\nstatic void xtfpga_pcm_refill_fifo(struct xtfpga_i2s *i2s)\r\n{\r\nunsigned int_status;\r\nunsigned i;\r\nregmap_read(i2s->regmap, XTFPGA_I2S_INT_STATUS,\r\n&int_status);\r\nfor (i = 0; i < 2; ++i) {\r\nbool tx_active = xtfpga_pcm_push_tx(i2s);\r\nregmap_write(i2s->regmap, XTFPGA_I2S_INT_STATUS,\r\nXTFPGA_I2S_INT_VALID);\r\nif (tx_active)\r\nregmap_read(i2s->regmap, XTFPGA_I2S_INT_STATUS,\r\n&int_status);\r\nif (!tx_active ||\r\n!(int_status & XTFPGA_I2S_INT_LEVEL))\r\nbreak;\r\ni2s->tx_fifo_level = i2s->tx_fifo_low;\r\n}\r\nif (!(int_status & XTFPGA_I2S_INT_LEVEL))\r\nregmap_write(i2s->regmap, XTFPGA_I2S_INT_MASK,\r\nXTFPGA_I2S_INT_VALID);\r\nelse if (!(int_status & XTFPGA_I2S_INT_UNDERRUN))\r\nregmap_write(i2s->regmap, XTFPGA_I2S_INT_MASK,\r\nXTFPGA_I2S_INT_UNDERRUN);\r\nif (!(int_status & XTFPGA_I2S_INT_UNDERRUN))\r\nregmap_update_bits(i2s->regmap, XTFPGA_I2S_CONFIG,\r\nXTFPGA_I2S_CONFIG_INT_ENABLE |\r\nXTFPGA_I2S_CONFIG_TX_ENABLE,\r\nXTFPGA_I2S_CONFIG_INT_ENABLE |\r\nXTFPGA_I2S_CONFIG_TX_ENABLE);\r\nelse\r\nregmap_update_bits(i2s->regmap, XTFPGA_I2S_CONFIG,\r\nXTFPGA_I2S_CONFIG_INT_ENABLE |\r\nXTFPGA_I2S_CONFIG_TX_ENABLE, 0);\r\n}\r\nstatic irqreturn_t xtfpga_i2s_threaded_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct xtfpga_i2s *i2s = dev_id;\r\nstruct snd_pcm_substream *tx_substream;\r\nunsigned config, int_status, int_mask;\r\nregmap_read(i2s->regmap, XTFPGA_I2S_CONFIG, &config);\r\nregmap_read(i2s->regmap, XTFPGA_I2S_INT_MASK, &int_mask);\r\nregmap_read(i2s->regmap, XTFPGA_I2S_INT_STATUS, &int_status);\r\nif (!(config & XTFPGA_I2S_CONFIG_INT_ENABLE) ||\r\n!(int_status & int_mask & XTFPGA_I2S_INT_VALID))\r\nreturn IRQ_NONE;\r\nif (int_status & XTFPGA_I2S_INT_UNDERRUN) {\r\ni2s->tx_fifo_level = 0;\r\nregmap_update_bits(i2s->regmap, XTFPGA_I2S_CONFIG,\r\nXTFPGA_I2S_CONFIG_TX_ENABLE, 0);\r\n} else {\r\ni2s->tx_fifo_level = i2s->tx_fifo_low;\r\n}\r\nrcu_read_lock();\r\ntx_substream = rcu_dereference(i2s->tx_substream);\r\nif (tx_substream && snd_pcm_running(tx_substream)) {\r\nsnd_pcm_period_elapsed(tx_substream);\r\nif (int_status & XTFPGA_I2S_INT_UNDERRUN)\r\ndev_dbg_ratelimited(i2s->dev, "%s: underrun\n",\r\n__func__);\r\n}\r\nrcu_read_unlock();\r\nxtfpga_pcm_refill_fifo(i2s);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int xtfpga_i2s_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct xtfpga_i2s *i2s = snd_soc_dai_get_drvdata(dai);\r\nsnd_soc_dai_set_dma_data(dai, substream, i2s);\r\nreturn 0;\r\n}\r\nstatic int xtfpga_i2s_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct xtfpga_i2s *i2s = snd_soc_dai_get_drvdata(dai);\r\nunsigned srate = params_rate(params);\r\nunsigned channels = params_channels(params);\r\nunsigned period_size = params_period_size(params);\r\nunsigned sample_size = snd_pcm_format_width(params_format(params));\r\nunsigned freq, ratio, level;\r\nint err;\r\nregmap_update_bits(i2s->regmap, XTFPGA_I2S_CONFIG,\r\nXTFPGA_I2S_CONFIG_RES_MASK,\r\nsample_size << XTFPGA_I2S_CONFIG_RES_BASE);\r\nfreq = 256 * srate;\r\nerr = clk_set_rate(i2s->clk, freq);\r\nif (err < 0)\r\nreturn err;\r\nratio = (freq - (srate * sample_size * 8)) /\r\n(srate * sample_size * 4);\r\nregmap_update_bits(i2s->regmap, XTFPGA_I2S_CONFIG,\r\nXTFPGA_I2S_CONFIG_RATIO_MASK,\r\nratio << XTFPGA_I2S_CONFIG_RATIO_BASE);\r\ni2s->tx_fifo_low = XTFPGA_I2S_FIFO_SIZE / 2;\r\nfor (level = 1;\r\ni2s->tx_fifo_low / 2 >= period_size * 2 &&\r\nlevel < (XTFPGA_I2S_CONFIG_LEVEL_MASK >>\r\nXTFPGA_I2S_CONFIG_LEVEL_BASE); ++level)\r\ni2s->tx_fifo_low /= 2;\r\ni2s->tx_fifo_high = 2 * i2s->tx_fifo_low;\r\nregmap_update_bits(i2s->regmap, XTFPGA_I2S_CONFIG,\r\nXTFPGA_I2S_CONFIG_LEVEL_MASK,\r\nlevel << XTFPGA_I2S_CONFIG_LEVEL_BASE);\r\ndev_dbg(i2s->dev,\r\n"%s srate: %u, channels: %u, sample_size: %u, period_size: %u\n",\r\n__func__, srate, channels, sample_size, period_size);\r\ndev_dbg(i2s->dev, "%s freq: %u, ratio: %u, level: %u\n",\r\n__func__, freq, ratio, level);\r\nreturn 0;\r\n}\r\nstatic int xtfpga_i2s_set_fmt(struct snd_soc_dai *cpu_dai,\r\nunsigned int fmt)\r\n{\r\nif ((fmt & SND_SOC_DAIFMT_INV_MASK) != SND_SOC_DAIFMT_NB_NF)\r\nreturn -EINVAL;\r\nif ((fmt & SND_SOC_DAIFMT_MASTER_MASK) != SND_SOC_DAIFMT_CBS_CFS)\r\nreturn -EINVAL;\r\nif ((fmt & SND_SOC_DAIFMT_FORMAT_MASK) != SND_SOC_DAIFMT_I2S)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int xtfpga_pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nvoid *p;\r\nsnd_soc_set_runtime_hwparams(substream, &xtfpga_pcm_hardware);\r\np = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);\r\nruntime->private_data = p;\r\nreturn 0;\r\n}\r\nstatic int xtfpga_pcm_close(struct snd_pcm_substream *substream)\r\n{\r\nsynchronize_rcu();\r\nreturn 0;\r\n}\r\nstatic int xtfpga_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nint ret;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct xtfpga_i2s *i2s = runtime->private_data;\r\nunsigned channels = params_channels(hw_params);\r\nswitch (channels) {\r\ncase 1:\r\ncase 2:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (params_format(hw_params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\ni2s->tx_fn = (channels == 1) ?\r\nxtfpga_pcm_tx_1x16 :\r\nxtfpga_pcm_tx_2x16;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\ni2s->tx_fn = (channels == 1) ?\r\nxtfpga_pcm_tx_1x32 :\r\nxtfpga_pcm_tx_2x32;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = snd_pcm_lib_malloc_pages(substream,\r\nparams_buffer_bytes(hw_params));\r\nreturn ret;\r\n}\r\nstatic int xtfpga_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nint ret = 0;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct xtfpga_i2s *i2s = runtime->private_data;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nACCESS_ONCE(i2s->tx_ptr) = 0;\r\nrcu_assign_pointer(i2s->tx_substream, substream);\r\nxtfpga_pcm_refill_fifo(i2s);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nrcu_assign_pointer(i2s->tx_substream, NULL);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic snd_pcm_uframes_t xtfpga_pcm_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct xtfpga_i2s *i2s = runtime->private_data;\r\nsnd_pcm_uframes_t pos = ACCESS_ONCE(i2s->tx_ptr);\r\nreturn pos < runtime->buffer_size ? pos : 0;\r\n}\r\nstatic int xtfpga_pcm_new(struct snd_soc_pcm_runtime *rtd)\r\n{\r\nstruct snd_card *card = rtd->card->snd_card;\r\nsize_t size = xtfpga_pcm_hardware.buffer_bytes_max;\r\nreturn snd_pcm_lib_preallocate_pages_for_all(rtd->pcm,\r\nSNDRV_DMA_TYPE_DEV,\r\ncard->dev, size, size);\r\n}\r\nstatic int xtfpga_i2s_runtime_suspend(struct device *dev)\r\n{\r\nstruct xtfpga_i2s *i2s = dev_get_drvdata(dev);\r\nclk_disable_unprepare(i2s->clk);\r\nreturn 0;\r\n}\r\nstatic int xtfpga_i2s_runtime_resume(struct device *dev)\r\n{\r\nstruct xtfpga_i2s *i2s = dev_get_drvdata(dev);\r\nint ret;\r\nret = clk_prepare_enable(i2s->clk);\r\nif (ret) {\r\ndev_err(dev, "clk_prepare_enable failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int xtfpga_i2s_probe(struct platform_device *pdev)\r\n{\r\nstruct xtfpga_i2s *i2s;\r\nstruct resource *mem;\r\nint err, irq;\r\ni2s = devm_kzalloc(&pdev->dev, sizeof(*i2s), GFP_KERNEL);\r\nif (!i2s) {\r\nerr = -ENOMEM;\r\ngoto err;\r\n}\r\nplatform_set_drvdata(pdev, i2s);\r\ni2s->dev = &pdev->dev;\r\ndev_dbg(&pdev->dev, "dev: %p, i2s: %p\n", &pdev->dev, i2s);\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ni2s->regs = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(i2s->regs)) {\r\nerr = PTR_ERR(i2s->regs);\r\ngoto err;\r\n}\r\ni2s->regmap = devm_regmap_init_mmio(&pdev->dev, i2s->regs,\r\n&xtfpga_i2s_regmap_config);\r\nif (IS_ERR(i2s->regmap)) {\r\ndev_err(&pdev->dev, "regmap init failed\n");\r\nerr = PTR_ERR(i2s->regmap);\r\ngoto err;\r\n}\r\ni2s->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(i2s->clk)) {\r\ndev_err(&pdev->dev, "couldn't get clock\n");\r\nerr = PTR_ERR(i2s->clk);\r\ngoto err;\r\n}\r\nregmap_write(i2s->regmap, XTFPGA_I2S_CONFIG,\r\n(0x1 << XTFPGA_I2S_CONFIG_CHANNEL_BASE));\r\nregmap_write(i2s->regmap, XTFPGA_I2S_INT_STATUS, XTFPGA_I2S_INT_VALID);\r\nregmap_write(i2s->regmap, XTFPGA_I2S_INT_MASK, XTFPGA_I2S_INT_UNDERRUN);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "No IRQ resource\n");\r\nerr = irq;\r\ngoto err;\r\n}\r\nerr = devm_request_threaded_irq(&pdev->dev, irq, NULL,\r\nxtfpga_i2s_threaded_irq_handler,\r\nIRQF_SHARED | IRQF_ONESHOT,\r\npdev->name, i2s);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "request_irq failed\n");\r\ngoto err;\r\n}\r\nerr = snd_soc_register_platform(&pdev->dev, &xtfpga_soc_platform);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "couldn't register platform\n");\r\ngoto err;\r\n}\r\nerr = devm_snd_soc_register_component(&pdev->dev,\r\n&xtfpga_i2s_component,\r\nxtfpga_i2s_dai,\r\nARRAY_SIZE(xtfpga_i2s_dai));\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "couldn't register component\n");\r\ngoto err_unregister_platform;\r\n}\r\npm_runtime_enable(&pdev->dev);\r\nif (!pm_runtime_enabled(&pdev->dev)) {\r\nerr = xtfpga_i2s_runtime_resume(&pdev->dev);\r\nif (err)\r\ngoto err_pm_disable;\r\n}\r\nreturn 0;\r\nerr_pm_disable:\r\npm_runtime_disable(&pdev->dev);\r\nerr_unregister_platform:\r\nsnd_soc_unregister_platform(&pdev->dev);\r\nerr:\r\ndev_err(&pdev->dev, "%s: err = %d\n", __func__, err);\r\nreturn err;\r\n}\r\nstatic int xtfpga_i2s_remove(struct platform_device *pdev)\r\n{\r\nstruct xtfpga_i2s *i2s = dev_get_drvdata(&pdev->dev);\r\nsnd_soc_unregister_platform(&pdev->dev);\r\nif (i2s->regmap && !IS_ERR(i2s->regmap)) {\r\nregmap_write(i2s->regmap, XTFPGA_I2S_CONFIG, 0);\r\nregmap_write(i2s->regmap, XTFPGA_I2S_INT_MASK, 0);\r\nregmap_write(i2s->regmap, XTFPGA_I2S_INT_STATUS,\r\nXTFPGA_I2S_INT_VALID);\r\n}\r\npm_runtime_disable(&pdev->dev);\r\nif (!pm_runtime_status_suspended(&pdev->dev))\r\nxtfpga_i2s_runtime_suspend(&pdev->dev);\r\nreturn 0;\r\n}
