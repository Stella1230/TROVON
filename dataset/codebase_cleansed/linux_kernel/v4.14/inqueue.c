void sctp_inq_init(struct sctp_inq *queue)\r\n{\r\nINIT_LIST_HEAD(&queue->in_chunk_list);\r\nqueue->in_progress = NULL;\r\nINIT_WORK(&queue->immediate, NULL);\r\n}\r\nvoid sctp_inq_free(struct sctp_inq *queue)\r\n{\r\nstruct sctp_chunk *chunk, *tmp;\r\nlist_for_each_entry_safe(chunk, tmp, &queue->in_chunk_list, list) {\r\nlist_del_init(&chunk->list);\r\nsctp_chunk_free(chunk);\r\n}\r\nif (queue->in_progress) {\r\nsctp_chunk_free(queue->in_progress);\r\nqueue->in_progress = NULL;\r\n}\r\n}\r\nvoid sctp_inq_push(struct sctp_inq *q, struct sctp_chunk *chunk)\r\n{\r\nif (chunk->rcvr->dead) {\r\nsctp_chunk_free(chunk);\r\nreturn;\r\n}\r\nlist_add_tail(&chunk->list, &q->in_chunk_list);\r\nif (chunk->asoc)\r\nchunk->asoc->stats.ipackets++;\r\nq->immediate.func(&q->immediate);\r\n}\r\nstruct sctp_chunkhdr *sctp_inq_peek(struct sctp_inq *queue)\r\n{\r\nstruct sctp_chunk *chunk;\r\nstruct sctp_chunkhdr *ch = NULL;\r\nchunk = queue->in_progress;\r\nif (chunk->singleton ||\r\nchunk->end_of_packet ||\r\nchunk->pdiscard)\r\nreturn NULL;\r\nch = (struct sctp_chunkhdr *)chunk->chunk_end;\r\nreturn ch;\r\n}\r\nstruct sctp_chunk *sctp_inq_pop(struct sctp_inq *queue)\r\n{\r\nstruct sctp_chunk *chunk;\r\nstruct sctp_chunkhdr *ch = NULL;\r\nchunk = queue->in_progress;\r\nif (chunk) {\r\nif (chunk->singleton ||\r\nchunk->end_of_packet ||\r\nchunk->pdiscard) {\r\nif (chunk->head_skb == chunk->skb) {\r\nchunk->skb = skb_shinfo(chunk->skb)->frag_list;\r\ngoto new_skb;\r\n}\r\nif (chunk->skb->next) {\r\nchunk->skb = chunk->skb->next;\r\ngoto new_skb;\r\n}\r\nif (chunk->head_skb)\r\nchunk->skb = chunk->head_skb;\r\nsctp_chunk_free(chunk);\r\nchunk = queue->in_progress = NULL;\r\n} else {\r\nch = (struct sctp_chunkhdr *)chunk->chunk_end;\r\nskb_pull(chunk->skb, chunk->chunk_end - chunk->skb->data);\r\n}\r\n}\r\nif (!chunk) {\r\nstruct list_head *entry;\r\nnext_chunk:\r\nentry = sctp_list_dequeue(&queue->in_chunk_list);\r\nif (!entry)\r\nreturn NULL;\r\nchunk = list_entry(entry, struct sctp_chunk, list);\r\nif ((skb_shinfo(chunk->skb)->gso_type & SKB_GSO_SCTP) == SKB_GSO_SCTP) {\r\nif (skb_shinfo(chunk->skb)->frag_list)\r\nchunk->head_skb = chunk->skb;\r\nif (chunk->head_skb && chunk->skb->data_len == chunk->skb->len)\r\nchunk->skb = skb_shinfo(chunk->skb)->frag_list;\r\nif (WARN_ON(!chunk->skb)) {\r\n__SCTP_INC_STATS(dev_net(chunk->skb->dev), SCTP_MIB_IN_PKT_DISCARDS);\r\nsctp_chunk_free(chunk);\r\ngoto next_chunk;\r\n}\r\n}\r\nif (chunk->asoc)\r\nsock_rps_save_rxhash(chunk->asoc->base.sk, chunk->skb);\r\nqueue->in_progress = chunk;\r\nnew_skb:\r\nch = (struct sctp_chunkhdr *)chunk->skb->data;\r\nchunk->singleton = 1;\r\nchunk->data_accepted = 0;\r\nchunk->pdiscard = 0;\r\nchunk->auth = 0;\r\nchunk->has_asconf = 0;\r\nchunk->end_of_packet = 0;\r\nif (chunk->head_skb) {\r\nstruct sctp_input_cb\r\n*cb = SCTP_INPUT_CB(chunk->skb),\r\n*head_cb = SCTP_INPUT_CB(chunk->head_skb);\r\ncb->chunk = head_cb->chunk;\r\ncb->af = head_cb->af;\r\n}\r\n}\r\nchunk->chunk_hdr = ch;\r\nchunk->chunk_end = ((__u8 *)ch) + SCTP_PAD4(ntohs(ch->length));\r\nskb_pull(chunk->skb, sizeof(*ch));\r\nchunk->subh.v = NULL;\r\nif (chunk->chunk_end + sizeof(*ch) < skb_tail_pointer(chunk->skb)) {\r\nchunk->singleton = 0;\r\n} else if (chunk->chunk_end > skb_tail_pointer(chunk->skb)) {\r\nchunk->pdiscard = 1;\r\nchunk->chunk_end = skb_tail_pointer(chunk->skb);\r\n} else {\r\nchunk->end_of_packet = 1;\r\n}\r\npr_debug("+++sctp_inq_pop+++ chunk:%p[%s], length:%d, skb->len:%d\n",\r\nchunk, sctp_cname(SCTP_ST_CHUNK(chunk->chunk_hdr->type)),\r\nntohs(chunk->chunk_hdr->length), chunk->skb->len);\r\nreturn chunk;\r\n}\r\nvoid sctp_inq_set_th_handler(struct sctp_inq *q, work_func_t callback)\r\n{\r\nINIT_WORK(&q->immediate, callback);\r\n}
