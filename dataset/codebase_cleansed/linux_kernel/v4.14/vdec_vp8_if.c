static void get_hw_reg_base(struct vdec_vp8_inst *inst)\r\n{\r\ninst->reg_base.top = mtk_vcodec_get_reg_addr(inst->ctx, VDEC_TOP);\r\ninst->reg_base.cm = mtk_vcodec_get_reg_addr(inst->ctx, VDEC_CM);\r\ninst->reg_base.hwd = mtk_vcodec_get_reg_addr(inst->ctx, VDEC_HWD);\r\ninst->reg_base.sys = mtk_vcodec_get_reg_addr(inst->ctx, VDEC_SYS);\r\ninst->reg_base.misc = mtk_vcodec_get_reg_addr(inst->ctx, VDEC_MISC);\r\ninst->reg_base.ld = mtk_vcodec_get_reg_addr(inst->ctx, VDEC_LD);\r\ninst->reg_base.hwb = mtk_vcodec_get_reg_addr(inst->ctx, VDEC_HWB);\r\n}\r\nstatic void write_hw_segmentation_data(struct vdec_vp8_inst *inst)\r\n{\r\nint i, j;\r\nu32 seg_id_addr;\r\nu32 val;\r\nvoid __iomem *cm = inst->reg_base.cm;\r\nstruct vdec_vp8_vsi *vsi = inst->vsi;\r\nseg_id_addr = readl(inst->reg_base.top + VP8_SEGID_DRAM_ADDR) >> 4;\r\nfor (i = 0; i < ARRAY_SIZE(vsi->segment_buf); i++) {\r\nfor (j = ARRAY_SIZE(vsi->segment_buf[i]) - 1; j >= 0; j--) {\r\nval = (1 << 16) + ((seg_id_addr + i) << 2) + j;\r\nwritel(val, cm + VP8_HW_VLD_ADDR);\r\nval = vsi->segment_buf[i][j];\r\nwritel(val, cm + VP8_HW_VLD_VALUE);\r\n}\r\n}\r\n}\r\nstatic void read_hw_segmentation_data(struct vdec_vp8_inst *inst)\r\n{\r\nint i, j;\r\nu32 seg_id_addr;\r\nu32 val;\r\nvoid __iomem *cm = inst->reg_base.cm;\r\nstruct vdec_vp8_vsi *vsi = inst->vsi;\r\nseg_id_addr = readl(inst->reg_base.top + VP8_SEGID_DRAM_ADDR) >> 4;\r\nfor (i = 0; i < ARRAY_SIZE(vsi->segment_buf); i++) {\r\nfor (j = ARRAY_SIZE(vsi->segment_buf[i]) - 1; j >= 0; j--) {\r\nval = ((seg_id_addr + i) << 2) + j;\r\nwritel(val, cm + VP8_HW_VLD_ADDR);\r\nval = readl(cm + VP8_HW_VLD_VALUE);\r\nvsi->segment_buf[i][j] = val;\r\n}\r\n}\r\n}\r\nstatic void enable_hw_rw_function(struct vdec_vp8_inst *inst)\r\n{\r\nu32 val = 0;\r\nvoid __iomem *sys = inst->reg_base.sys;\r\nvoid __iomem *misc = inst->reg_base.misc;\r\nvoid __iomem *ld = inst->reg_base.ld;\r\nvoid __iomem *hwb = inst->reg_base.hwb;\r\nvoid __iomem *hwd = inst->reg_base.hwd;\r\nwritel(0x1, sys + VP8_RW_CKEN_SET);\r\nwritel(0x101, ld + VP8_WO_VLD_SRST);\r\nwritel(0x101, hwb + VP8_WO_VLD_SRST);\r\nwritel(1, sys);\r\nval = readl(misc + VP8_RW_MISC_SRST);\r\nwritel((val & 0xFFFFFFFE), misc + VP8_RW_MISC_SRST);\r\nwritel(0x1, misc + VP8_RW_MISC_SYS_SEL);\r\nwritel(0x17F, misc + VP8_RW_MISC_SPEC_CON);\r\nwritel(0x71201100, misc + VP8_RW_MISC_FUNC_CON);\r\nwritel(0x0, ld + VP8_WO_VLD_SRST);\r\nwritel(0x0, hwb + VP8_WO_VLD_SRST);\r\nwritel(0x1, sys + VP8_RW_DCM_CON);\r\nwritel(0x1, misc + VP8_RW_MISC_DCM_CON);\r\nwritel(0x1, hwd + VP8_RW_VP8_CTRL);\r\n}\r\nstatic void store_dec_table(struct vdec_vp8_inst *inst)\r\n{\r\nint i, j;\r\nu32 addr = 0, val = 0;\r\nvoid __iomem *hwd = inst->reg_base.hwd;\r\nu32 *p = &inst->vsi->dec_table[VP8_DEC_TABLE_OFFSET];\r\nfor (i = 0; i < VP8_DEC_TABLE_PROC_LOOP; i++) {\r\nwritel(addr, hwd + VP8_BSASET);\r\nfor (j = 0; j < VP8_DEC_TABLE_UNIT ; j++) {\r\nval = *p++;\r\nwritel(val, hwd + VP8_BSDSET);\r\n}\r\naddr += VP8_DEC_TABLE_RW_UNIT;\r\n}\r\n}\r\nstatic void load_dec_table(struct vdec_vp8_inst *inst)\r\n{\r\nint i;\r\nu32 addr = 0;\r\nu32 *p = &inst->vsi->dec_table[VP8_DEC_TABLE_OFFSET];\r\nvoid __iomem *hwd = inst->reg_base.hwd;\r\nfor (i = 0; i < VP8_DEC_TABLE_PROC_LOOP; i++) {\r\nwritel(addr, hwd + VP8_BSASET);\r\n*p++ = readl(hwd + VP8_BSDSET);\r\n*p++ = readl(hwd + VP8_BSDSET);\r\n*p++ = readl(hwd + VP8_BSDSET) & 0xFFFFFF;\r\naddr += VP8_DEC_TABLE_RW_UNIT;\r\n}\r\n}\r\nstatic void get_pic_info(struct vdec_vp8_inst *inst, struct vdec_pic_info *pic)\r\n{\r\n*pic = inst->vsi->pic;\r\nmtk_vcodec_debug(inst, "pic(%d, %d), buf(%d, %d)",\r\npic->pic_w, pic->pic_h, pic->buf_w, pic->buf_h);\r\nmtk_vcodec_debug(inst, "Y(%d, %d), C(%d, %d)", pic->y_bs_sz,\r\npic->y_len_sz, pic->c_bs_sz, pic->c_len_sz);\r\n}\r\nstatic void vp8_dec_finish(struct vdec_vp8_inst *inst)\r\n{\r\nstruct vdec_fb_node *node;\r\nuint64_t prev_y_dma = inst->vsi->dec.prev_y_dma;\r\nmtk_vcodec_debug(inst, "prev fb base dma=%llx", prev_y_dma);\r\nif (prev_y_dma != 0) {\r\nlist_for_each_entry(node, &inst->fb_use_list, list) {\r\nstruct vdec_fb *fb = (struct vdec_fb *)node->fb;\r\nif (prev_y_dma == (uint64_t)fb->base_y.dma_addr) {\r\nlist_move_tail(&node->list,\r\n&inst->fb_free_list);\r\nbreak;\r\n}\r\n}\r\n}\r\nnode = list_first_entry(&inst->available_fb_node_list,\r\nstruct vdec_fb_node, list);\r\nnode->fb = inst->cur_fb;\r\nlist_move_tail(&node->list, &inst->fb_use_list);\r\nif (inst->vsi->dec.show_frame) {\r\nnode = list_first_entry(&inst->available_fb_node_list,\r\nstruct vdec_fb_node, list);\r\nnode->fb = inst->cur_fb;\r\nlist_move_tail(&node->list, &inst->fb_disp_list);\r\n}\r\n}\r\nstatic void move_fb_list_use_to_free(struct vdec_vp8_inst *inst)\r\n{\r\nstruct vdec_fb_node *node, *tmp;\r\nlist_for_each_entry_safe(node, tmp, &inst->fb_use_list, list)\r\nlist_move_tail(&node->list, &inst->fb_free_list);\r\n}\r\nstatic void init_list(struct vdec_vp8_inst *inst)\r\n{\r\nint i;\r\nINIT_LIST_HEAD(&inst->available_fb_node_list);\r\nINIT_LIST_HEAD(&inst->fb_use_list);\r\nINIT_LIST_HEAD(&inst->fb_free_list);\r\nINIT_LIST_HEAD(&inst->fb_disp_list);\r\nfor (i = 0; i < ARRAY_SIZE(inst->dec_fb); i++) {\r\nINIT_LIST_HEAD(&inst->dec_fb[i].list);\r\ninst->dec_fb[i].fb = NULL;\r\nlist_add_tail(&inst->dec_fb[i].list,\r\n&inst->available_fb_node_list);\r\n}\r\n}\r\nstatic void add_fb_to_free_list(struct vdec_vp8_inst *inst, void *fb)\r\n{\r\nstruct vdec_fb_node *node;\r\nif (fb) {\r\nnode = list_first_entry(&inst->available_fb_node_list,\r\nstruct vdec_fb_node, list);\r\nnode->fb = fb;\r\nlist_move_tail(&node->list, &inst->fb_free_list);\r\n}\r\n}\r\nstatic int alloc_working_buf(struct vdec_vp8_inst *inst)\r\n{\r\nint err;\r\nstruct mtk_vcodec_mem *mem = &inst->working_buf;\r\nmem->size = VP8_WORKING_BUF_SZ;\r\nerr = mtk_vcodec_mem_alloc(inst->ctx, mem);\r\nif (err) {\r\nmtk_vcodec_err(inst, "Cannot allocate working buffer");\r\nreturn err;\r\n}\r\ninst->vsi->dec.working_buf_dma = (uint64_t)mem->dma_addr;\r\nreturn 0;\r\n}\r\nstatic void free_working_buf(struct vdec_vp8_inst *inst)\r\n{\r\nstruct mtk_vcodec_mem *mem = &inst->working_buf;\r\nif (mem->va)\r\nmtk_vcodec_mem_free(inst->ctx, mem);\r\ninst->vsi->dec.working_buf_dma = 0;\r\n}\r\nstatic int vdec_vp8_init(struct mtk_vcodec_ctx *ctx, unsigned long *h_vdec)\r\n{\r\nstruct vdec_vp8_inst *inst;\r\nint err;\r\ninst = kzalloc(sizeof(*inst), GFP_KERNEL);\r\nif (!inst)\r\nreturn -ENOMEM;\r\ninst->ctx = ctx;\r\ninst->vpu.id = IPI_VDEC_VP8;\r\ninst->vpu.dev = ctx->dev->vpu_plat_dev;\r\ninst->vpu.ctx = ctx;\r\ninst->vpu.handler = vpu_dec_ipi_handler;\r\nerr = vpu_dec_init(&inst->vpu);\r\nif (err) {\r\nmtk_vcodec_err(inst, "vdec_vp8 init err=%d", err);\r\ngoto error_free_inst;\r\n}\r\ninst->vsi = (struct vdec_vp8_vsi *)inst->vpu.vsi;\r\ninit_list(inst);\r\nerr = alloc_working_buf(inst);\r\nif (err)\r\ngoto error_deinit;\r\nget_hw_reg_base(inst);\r\nmtk_vcodec_debug(inst, "VP8 Instance >> %p", inst);\r\n*h_vdec = (unsigned long)inst;\r\nreturn 0;\r\nerror_deinit:\r\nvpu_dec_deinit(&inst->vpu);\r\nerror_free_inst:\r\nkfree(inst);\r\nreturn err;\r\n}\r\nstatic int vdec_vp8_decode(unsigned long h_vdec, struct mtk_vcodec_mem *bs,\r\nstruct vdec_fb *fb, bool *res_chg)\r\n{\r\nstruct vdec_vp8_inst *inst = (struct vdec_vp8_inst *)h_vdec;\r\nstruct vdec_vp8_dec_info *dec = &inst->vsi->dec;\r\nstruct vdec_vpu_inst *vpu = &inst->vpu;\r\nunsigned char *bs_va;\r\nunsigned int data;\r\nint err = 0;\r\nuint64_t y_fb_dma;\r\nuint64_t c_fb_dma;\r\nif (bs == NULL) {\r\nmove_fb_list_use_to_free(inst);\r\nreturn vpu_dec_reset(vpu);\r\n}\r\ny_fb_dma = fb ? (u64)fb->base_y.dma_addr : 0;\r\nc_fb_dma = fb ? (u64)fb->base_c.dma_addr : 0;\r\nmtk_vcodec_debug(inst, "+ [%d] FB y_dma=%llx c_dma=%llx fb=%p",\r\ninst->frm_cnt, y_fb_dma, c_fb_dma, fb);\r\ninst->cur_fb = fb;\r\ndec->bs_dma = (unsigned long)bs->dma_addr;\r\ndec->bs_sz = bs->size;\r\ndec->cur_y_fb_dma = y_fb_dma;\r\ndec->cur_c_fb_dma = c_fb_dma;\r\nmtk_vcodec_debug(inst, "\n + FRAME[%d] +\n", inst->frm_cnt);\r\nwrite_hw_segmentation_data(inst);\r\nenable_hw_rw_function(inst);\r\nstore_dec_table(inst);\r\nbs_va = (unsigned char *)bs->va;\r\ndata = (*(bs_va + 9) << 24) | (*(bs_va + 8) << 16) |\r\n(*(bs_va + 7) << 8) | *(bs_va + 6);\r\nerr = vpu_dec_start(vpu, &data, 1);\r\nif (err) {\r\nadd_fb_to_free_list(inst, fb);\r\nif (dec->wait_key_frame) {\r\nmtk_vcodec_debug(inst, "wait key frame !");\r\nreturn 0;\r\n}\r\ngoto error;\r\n}\r\nif (dec->resolution_changed) {\r\nmtk_vcodec_debug(inst, "- resolution_changed -");\r\n*res_chg = true;\r\nadd_fb_to_free_list(inst, fb);\r\nreturn 0;\r\n}\r\nmtk_vcodec_wait_for_done_ctx(inst->ctx, MTK_INST_IRQ_RECEIVED,\r\nWAIT_INTR_TIMEOUT_MS);\r\nif (inst->vsi->load_data)\r\nload_dec_table(inst);\r\nvp8_dec_finish(inst);\r\nread_hw_segmentation_data(inst);\r\nerr = vpu_dec_end(vpu);\r\nif (err)\r\ngoto error;\r\nmtk_vcodec_debug(inst, "\n - FRAME[%d] - show=%d\n", inst->frm_cnt,\r\ndec->show_frame);\r\ninst->frm_cnt++;\r\n*res_chg = false;\r\nreturn 0;\r\nerror:\r\nmtk_vcodec_err(inst, "\n - FRAME[%d] - err=%d\n", inst->frm_cnt, err);\r\nreturn err;\r\n}\r\nstatic void get_disp_fb(struct vdec_vp8_inst *inst, struct vdec_fb **out_fb)\r\n{\r\nstruct vdec_fb_node *node;\r\nstruct vdec_fb *fb;\r\nnode = list_first_entry_or_null(&inst->fb_disp_list,\r\nstruct vdec_fb_node, list);\r\nif (node) {\r\nlist_move_tail(&node->list, &inst->available_fb_node_list);\r\nfb = (struct vdec_fb *)node->fb;\r\nfb->status |= FB_ST_DISPLAY;\r\nmtk_vcodec_debug(inst, "[FB] get disp fb %p st=%d",\r\nnode->fb, fb->status);\r\n} else {\r\nfb = NULL;\r\nmtk_vcodec_debug(inst, "[FB] there is no disp fb");\r\n}\r\n*out_fb = fb;\r\n}\r\nstatic void get_free_fb(struct vdec_vp8_inst *inst, struct vdec_fb **out_fb)\r\n{\r\nstruct vdec_fb_node *node;\r\nstruct vdec_fb *fb;\r\nnode = list_first_entry_or_null(&inst->fb_free_list,\r\nstruct vdec_fb_node, list);\r\nif (node) {\r\nlist_move_tail(&node->list, &inst->available_fb_node_list);\r\nfb = (struct vdec_fb *)node->fb;\r\nfb->status |= FB_ST_FREE;\r\nmtk_vcodec_debug(inst, "[FB] get free fb %p st=%d",\r\nnode->fb, fb->status);\r\n} else {\r\nfb = NULL;\r\nmtk_vcodec_debug(inst, "[FB] there is no free fb");\r\n}\r\n*out_fb = fb;\r\n}\r\nstatic void get_crop_info(struct vdec_vp8_inst *inst, struct v4l2_rect *cr)\r\n{\r\ncr->left = 0;\r\ncr->top = 0;\r\ncr->width = inst->vsi->pic.pic_w;\r\ncr->height = inst->vsi->pic.pic_h;\r\nmtk_vcodec_debug(inst, "get crop info l=%d, t=%d, w=%d, h=%d",\r\ncr->left, cr->top, cr->width, cr->height);\r\n}\r\nstatic int vdec_vp8_get_param(unsigned long h_vdec,\r\nenum vdec_get_param_type type, void *out)\r\n{\r\nstruct vdec_vp8_inst *inst = (struct vdec_vp8_inst *)h_vdec;\r\nswitch (type) {\r\ncase GET_PARAM_DISP_FRAME_BUFFER:\r\nget_disp_fb(inst, out);\r\nbreak;\r\ncase GET_PARAM_FREE_FRAME_BUFFER:\r\nget_free_fb(inst, out);\r\nbreak;\r\ncase GET_PARAM_PIC_INFO:\r\nget_pic_info(inst, out);\r\nbreak;\r\ncase GET_PARAM_CROP_INFO:\r\nget_crop_info(inst, out);\r\nbreak;\r\ncase GET_PARAM_DPB_SIZE:\r\n*((unsigned int *)out) = VP8_DPB_SIZE;\r\nbreak;\r\ndefault:\r\nmtk_vcodec_err(inst, "invalid get parameter type=%d", type);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void vdec_vp8_deinit(unsigned long h_vdec)\r\n{\r\nstruct vdec_vp8_inst *inst = (struct vdec_vp8_inst *)h_vdec;\r\nmtk_vcodec_debug_enter(inst);\r\nvpu_dec_deinit(&inst->vpu);\r\nfree_working_buf(inst);\r\nkfree(inst);\r\n}\r\nstruct vdec_common_if *get_vp8_dec_comm_if(void)\r\n{\r\nreturn &vdec_vp8_if;\r\n}
