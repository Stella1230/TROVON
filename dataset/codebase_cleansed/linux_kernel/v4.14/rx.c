static int lowpan_give_skb_to_device(struct sk_buff *skb)\r\n{\r\nskb->protocol = htons(ETH_P_IPV6);\r\nskb->dev->stats.rx_packets++;\r\nskb->dev->stats.rx_bytes += skb->len;\r\nreturn netif_rx(skb);\r\n}\r\nstatic int lowpan_rx_handlers_result(struct sk_buff *skb, lowpan_rx_result res)\r\n{\r\nswitch (res) {\r\ncase RX_CONTINUE:\r\nnet_warn_ratelimited("%s: received unknown dispatch\n",\r\n__func__);\r\ncase RX_DROP_UNUSABLE:\r\nkfree_skb(skb);\r\ncase RX_DROP:\r\nreturn NET_RX_DROP;\r\ncase RX_QUEUED:\r\nreturn lowpan_give_skb_to_device(skb);\r\ndefault:\r\nbreak;\r\n}\r\nreturn NET_RX_DROP;\r\n}\r\nstatic inline bool lowpan_is_frag1(u8 dispatch)\r\n{\r\nreturn (dispatch & LOWPAN_DISPATCH_FRAG_MASK) == LOWPAN_DISPATCH_FRAG1;\r\n}\r\nstatic inline bool lowpan_is_fragn(u8 dispatch)\r\n{\r\nreturn (dispatch & LOWPAN_DISPATCH_FRAG_MASK) == LOWPAN_DISPATCH_FRAGN;\r\n}\r\nstatic lowpan_rx_result lowpan_rx_h_frag(struct sk_buff *skb)\r\n{\r\nint ret;\r\nif (!(lowpan_is_frag1(*skb_network_header(skb)) ||\r\nlowpan_is_fragn(*skb_network_header(skb))))\r\nreturn RX_CONTINUE;\r\nret = lowpan_frag_rcv(skb, *skb_network_header(skb) &\r\nLOWPAN_DISPATCH_FRAG_MASK);\r\nif (ret == 1)\r\nreturn RX_QUEUED;\r\nreturn RX_DROP;\r\n}\r\nint lowpan_iphc_decompress(struct sk_buff *skb)\r\n{\r\nstruct ieee802154_hdr hdr;\r\nif (ieee802154_hdr_peek_addrs(skb, &hdr) < 0)\r\nreturn -EINVAL;\r\nreturn lowpan_header_decompress(skb, skb->dev, &hdr.dest, &hdr.source);\r\n}\r\nstatic lowpan_rx_result lowpan_rx_h_iphc(struct sk_buff *skb)\r\n{\r\nint ret;\r\nif (!lowpan_is_iphc(*skb_network_header(skb)))\r\nreturn RX_CONTINUE;\r\nlowpan_802154_cb(skb)->d_size = 0;\r\nret = lowpan_iphc_decompress(skb);\r\nif (ret < 0)\r\nreturn RX_DROP_UNUSABLE;\r\nreturn RX_QUEUED;\r\n}\r\nlowpan_rx_result lowpan_rx_h_ipv6(struct sk_buff *skb)\r\n{\r\nif (!lowpan_is_ipv6(*skb_network_header(skb)))\r\nreturn RX_CONTINUE;\r\nskb_pull(skb, 1);\r\nreturn RX_QUEUED;\r\n}\r\nstatic inline bool lowpan_is_esc(u8 dispatch)\r\n{\r\nreturn dispatch == LOWPAN_DISPATCH_ESC;\r\n}\r\nstatic lowpan_rx_result lowpan_rx_h_esc(struct sk_buff *skb)\r\n{\r\nif (!lowpan_is_esc(*skb_network_header(skb)))\r\nreturn RX_CONTINUE;\r\nnet_warn_ratelimited("%s: %s\n", skb->dev->name,\r\n"6LoWPAN ESC not supported\n");\r\nreturn RX_DROP_UNUSABLE;\r\n}\r\nstatic inline bool lowpan_is_hc1(u8 dispatch)\r\n{\r\nreturn dispatch == LOWPAN_DISPATCH_HC1;\r\n}\r\nstatic lowpan_rx_result lowpan_rx_h_hc1(struct sk_buff *skb)\r\n{\r\nif (!lowpan_is_hc1(*skb_network_header(skb)))\r\nreturn RX_CONTINUE;\r\nnet_warn_ratelimited("%s: %s\n", skb->dev->name,\r\n"6LoWPAN HC1 not supported\n");\r\nreturn RX_DROP_UNUSABLE;\r\n}\r\nstatic inline bool lowpan_is_dff(u8 dispatch)\r\n{\r\nreturn dispatch == LOWPAN_DISPATCH_DFF;\r\n}\r\nstatic lowpan_rx_result lowpan_rx_h_dff(struct sk_buff *skb)\r\n{\r\nif (!lowpan_is_dff(*skb_network_header(skb)))\r\nreturn RX_CONTINUE;\r\nnet_warn_ratelimited("%s: %s\n", skb->dev->name,\r\n"6LoWPAN DFF not supported\n");\r\nreturn RX_DROP_UNUSABLE;\r\n}\r\nstatic inline bool lowpan_is_bc0(u8 dispatch)\r\n{\r\nreturn dispatch == LOWPAN_DISPATCH_BC0;\r\n}\r\nstatic lowpan_rx_result lowpan_rx_h_bc0(struct sk_buff *skb)\r\n{\r\nif (!lowpan_is_bc0(*skb_network_header(skb)))\r\nreturn RX_CONTINUE;\r\nnet_warn_ratelimited("%s: %s\n", skb->dev->name,\r\n"6LoWPAN BC0 not supported\n");\r\nreturn RX_DROP_UNUSABLE;\r\n}\r\nstatic inline bool lowpan_is_mesh(u8 dispatch)\r\n{\r\nreturn (dispatch & LOWPAN_DISPATCH_FIRST) == LOWPAN_DISPATCH_MESH;\r\n}\r\nstatic lowpan_rx_result lowpan_rx_h_mesh(struct sk_buff *skb)\r\n{\r\nif (!lowpan_is_mesh(*skb_network_header(skb)))\r\nreturn RX_CONTINUE;\r\nnet_warn_ratelimited("%s: %s\n", skb->dev->name,\r\n"6LoWPAN MESH not supported\n");\r\nreturn RX_DROP_UNUSABLE;\r\n}\r\nstatic int lowpan_invoke_rx_handlers(struct sk_buff *skb)\r\n{\r\nlowpan_rx_result res;\r\n#define CALL_RXH(rxh) \\r\ndo { \\r\nres = rxh(skb); \\r\nif (res != RX_CONTINUE) \\r\ngoto rxh_next; \\r\n} while (0)\r\nCALL_RXH(lowpan_rx_h_iphc);\r\nCALL_RXH(lowpan_rx_h_frag);\r\nCALL_RXH(lowpan_rx_h_ipv6);\r\nCALL_RXH(lowpan_rx_h_esc);\r\nCALL_RXH(lowpan_rx_h_hc1);\r\nCALL_RXH(lowpan_rx_h_dff);\r\nCALL_RXH(lowpan_rx_h_bc0);\r\nCALL_RXH(lowpan_rx_h_mesh);\r\nrxh_next:\r\nreturn lowpan_rx_handlers_result(skb, res);\r\n#undef CALL_RXH\r\n}\r\nstatic inline bool lowpan_is_nalp(u8 dispatch)\r\n{\r\nreturn (dispatch & LOWPAN_DISPATCH_FIRST) == LOWPAN_DISPATCH_NALP;\r\n}\r\nstatic inline bool lowpan_is_reserved(u8 dispatch)\r\n{\r\nreturn ((dispatch >= 0x44 && dispatch <= 0x4F) ||\r\n(dispatch >= 0x51 && dispatch <= 0x5F) ||\r\n(dispatch >= 0xc8 && dispatch <= 0xdf) ||\r\n(dispatch >= 0xe8 && dispatch <= 0xff));\r\n}\r\nstatic inline bool lowpan_rx_h_check(struct sk_buff *skb)\r\n{\r\n__le16 fc = ieee802154_get_fc_from_skb(skb);\r\nif (!ieee802154_is_data(fc) ||\r\n!ieee802154_skb_is_intra_pan_addressing(fc, skb))\r\nreturn false;\r\nif (unlikely(!skb->len))\r\nreturn false;\r\nif (lowpan_is_nalp(*skb_network_header(skb)) ||\r\nlowpan_is_reserved(*skb_network_header(skb)))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int lowpan_rcv(struct sk_buff *skb, struct net_device *wdev,\r\nstruct packet_type *pt, struct net_device *orig_wdev)\r\n{\r\nstruct net_device *ldev;\r\nif (wdev->type != ARPHRD_IEEE802154 ||\r\nskb->pkt_type == PACKET_OTHERHOST ||\r\n!lowpan_rx_h_check(skb))\r\ngoto drop;\r\nldev = wdev->ieee802154_ptr->lowpan_dev;\r\nif (!ldev || !netif_running(ldev))\r\ngoto drop;\r\nskb = skb_share_check(skb, GFP_ATOMIC);\r\nif (!skb)\r\ngoto out;\r\nskb->dev = ldev;\r\nif (lowpan_is_frag1(*skb_network_header(skb)) ||\r\nlowpan_is_iphc(*skb_network_header(skb))) {\r\nskb = skb_unshare(skb, GFP_ATOMIC);\r\nif (!skb)\r\ngoto out;\r\n}\r\nreturn lowpan_invoke_rx_handlers(skb);\r\ndrop:\r\nkfree_skb(skb);\r\nout:\r\nreturn NET_RX_DROP;\r\n}\r\nvoid lowpan_rx_init(void)\r\n{\r\ndev_add_pack(&lowpan_packet_type);\r\n}\r\nvoid lowpan_rx_exit(void)\r\n{\r\ndev_remove_pack(&lowpan_packet_type);\r\n}
