struct mlxsw_afa *mlxsw_afa_create(unsigned int max_acts_per_set,\r\nconst struct mlxsw_afa_ops *ops,\r\nvoid *ops_priv)\r\n{\r\nstruct mlxsw_afa *mlxsw_afa;\r\nint err;\r\nmlxsw_afa = kzalloc(sizeof(*mlxsw_afa), GFP_KERNEL);\r\nif (!mlxsw_afa)\r\nreturn ERR_PTR(-ENOMEM);\r\nerr = rhashtable_init(&mlxsw_afa->set_ht, &mlxsw_afa_set_ht_params);\r\nif (err)\r\ngoto err_set_rhashtable_init;\r\nerr = rhashtable_init(&mlxsw_afa->fwd_entry_ht,\r\n&mlxsw_afa_fwd_entry_ht_params);\r\nif (err)\r\ngoto err_fwd_entry_rhashtable_init;\r\nmlxsw_afa->max_acts_per_set = max_acts_per_set;\r\nmlxsw_afa->ops = ops;\r\nmlxsw_afa->ops_priv = ops_priv;\r\nreturn mlxsw_afa;\r\nerr_fwd_entry_rhashtable_init:\r\nrhashtable_destroy(&mlxsw_afa->set_ht);\r\nerr_set_rhashtable_init:\r\nkfree(mlxsw_afa);\r\nreturn ERR_PTR(err);\r\n}\r\nvoid mlxsw_afa_destroy(struct mlxsw_afa *mlxsw_afa)\r\n{\r\nrhashtable_destroy(&mlxsw_afa->fwd_entry_ht);\r\nrhashtable_destroy(&mlxsw_afa->set_ht);\r\nkfree(mlxsw_afa);\r\n}\r\nstatic void mlxsw_afa_set_goto_set(struct mlxsw_afa_set *set,\r\nenum mlxsw_afa_set_goto_binding_cmd cmd,\r\nu16 group_id)\r\n{\r\nchar *actions = set->ht_key.enc_actions;\r\nmlxsw_afa_set_type_set(actions, MLXSW_AFA_SET_TYPE_GOTO);\r\nmlxsw_afa_set_goto_g_set(actions, true);\r\nmlxsw_afa_set_goto_binding_cmd_set(actions, cmd);\r\nmlxsw_afa_set_goto_next_binding_set(actions, group_id);\r\n}\r\nstatic void mlxsw_afa_set_next_set(struct mlxsw_afa_set *set,\r\nu32 next_set_kvdl_index)\r\n{\r\nchar *actions = set->ht_key.enc_actions;\r\nmlxsw_afa_set_type_set(actions, MLXSW_AFA_SET_TYPE_NEXT);\r\nmlxsw_afa_set_next_action_set_ptr_set(actions, next_set_kvdl_index);\r\n}\r\nstatic struct mlxsw_afa_set *mlxsw_afa_set_create(bool is_first)\r\n{\r\nstruct mlxsw_afa_set *set;\r\nset = kzalloc(sizeof(*set), GFP_KERNEL);\r\nif (!set)\r\nreturn NULL;\r\nmlxsw_afa_set_goto_set(set, MLXSW_AFA_SET_GOTO_BINDING_CMD_TERM, 0);\r\nset->ht_key.is_first = is_first;\r\nset->ref_count = 1;\r\nreturn set;\r\n}\r\nstatic void mlxsw_afa_set_destroy(struct mlxsw_afa_set *set)\r\n{\r\nkfree(set);\r\n}\r\nstatic int mlxsw_afa_set_share(struct mlxsw_afa *mlxsw_afa,\r\nstruct mlxsw_afa_set *set)\r\n{\r\nint err;\r\nerr = rhashtable_insert_fast(&mlxsw_afa->set_ht, &set->ht_node,\r\nmlxsw_afa_set_ht_params);\r\nif (err)\r\nreturn err;\r\nerr = mlxsw_afa->ops->kvdl_set_add(mlxsw_afa->ops_priv,\r\n&set->kvdl_index,\r\nset->ht_key.enc_actions,\r\nset->ht_key.is_first);\r\nif (err)\r\ngoto err_kvdl_set_add;\r\nset->shared = true;\r\nset->prev = NULL;\r\nreturn 0;\r\nerr_kvdl_set_add:\r\nrhashtable_remove_fast(&mlxsw_afa->set_ht, &set->ht_node,\r\nmlxsw_afa_set_ht_params);\r\nreturn err;\r\n}\r\nstatic void mlxsw_afa_set_unshare(struct mlxsw_afa *mlxsw_afa,\r\nstruct mlxsw_afa_set *set)\r\n{\r\nmlxsw_afa->ops->kvdl_set_del(mlxsw_afa->ops_priv,\r\nset->kvdl_index,\r\nset->ht_key.is_first);\r\nrhashtable_remove_fast(&mlxsw_afa->set_ht, &set->ht_node,\r\nmlxsw_afa_set_ht_params);\r\nset->shared = false;\r\n}\r\nstatic void mlxsw_afa_set_put(struct mlxsw_afa *mlxsw_afa,\r\nstruct mlxsw_afa_set *set)\r\n{\r\nif (--set->ref_count)\r\nreturn;\r\nif (set->shared)\r\nmlxsw_afa_set_unshare(mlxsw_afa, set);\r\nmlxsw_afa_set_destroy(set);\r\n}\r\nstatic struct mlxsw_afa_set *mlxsw_afa_set_get(struct mlxsw_afa *mlxsw_afa,\r\nstruct mlxsw_afa_set *orig_set)\r\n{\r\nstruct mlxsw_afa_set *set;\r\nint err;\r\nset = rhashtable_lookup_fast(&mlxsw_afa->set_ht, &orig_set->ht_key,\r\nmlxsw_afa_set_ht_params);\r\nif (set) {\r\nset->ref_count++;\r\nmlxsw_afa_set_put(mlxsw_afa, orig_set);\r\n} else {\r\nset = orig_set;\r\nerr = mlxsw_afa_set_share(mlxsw_afa, set);\r\nif (err)\r\nreturn ERR_PTR(err);\r\n}\r\nreturn set;\r\n}\r\nstruct mlxsw_afa_block *mlxsw_afa_block_create(struct mlxsw_afa *mlxsw_afa)\r\n{\r\nstruct mlxsw_afa_block *block;\r\nblock = kzalloc(sizeof(*block), GFP_KERNEL);\r\nif (!block)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&block->fwd_entry_ref_list);\r\nblock->afa = mlxsw_afa;\r\nblock->first_set = mlxsw_afa_set_create(true);\r\nif (!block->first_set)\r\ngoto err_first_set_create;\r\nblock->cur_set = block->first_set;\r\nreturn block;\r\nerr_first_set_create:\r\nkfree(block);\r\nreturn NULL;\r\n}\r\nvoid mlxsw_afa_block_destroy(struct mlxsw_afa_block *block)\r\n{\r\nstruct mlxsw_afa_set *set = block->first_set;\r\nstruct mlxsw_afa_set *next_set;\r\ndo {\r\nnext_set = set->next;\r\nmlxsw_afa_set_put(block->afa, set);\r\nset = next_set;\r\n} while (set);\r\nmlxsw_afa_fwd_entry_refs_destroy(block);\r\nkfree(block);\r\n}\r\nint mlxsw_afa_block_commit(struct mlxsw_afa_block *block)\r\n{\r\nstruct mlxsw_afa_set *set = block->cur_set;\r\nstruct mlxsw_afa_set *prev_set;\r\nblock->cur_set = NULL;\r\nblock->finished = true;\r\ndo {\r\nprev_set = set->prev;\r\nset = mlxsw_afa_set_get(block->afa, set);\r\nif (IS_ERR(set))\r\nreturn PTR_ERR(set);\r\nif (prev_set) {\r\nprev_set->next = set;\r\nmlxsw_afa_set_next_set(prev_set, set->kvdl_index);\r\nset = prev_set;\r\n}\r\n} while (prev_set);\r\nblock->first_set = set;\r\nreturn 0;\r\n}\r\nchar *mlxsw_afa_block_first_set(struct mlxsw_afa_block *block)\r\n{\r\nreturn block->first_set->ht_key.enc_actions;\r\n}\r\nu32 mlxsw_afa_block_first_set_kvdl_index(struct mlxsw_afa_block *block)\r\n{\r\nreturn block->first_set->kvdl_index;\r\n}\r\nvoid mlxsw_afa_block_continue(struct mlxsw_afa_block *block)\r\n{\r\nif (WARN_ON(block->finished))\r\nreturn;\r\nmlxsw_afa_set_goto_set(block->cur_set,\r\nMLXSW_AFA_SET_GOTO_BINDING_CMD_NONE, 0);\r\nblock->finished = true;\r\n}\r\nvoid mlxsw_afa_block_jump(struct mlxsw_afa_block *block, u16 group_id)\r\n{\r\nif (WARN_ON(block->finished))\r\nreturn;\r\nmlxsw_afa_set_goto_set(block->cur_set,\r\nMLXSW_AFA_SET_GOTO_BINDING_CMD_JUMP, group_id);\r\nblock->finished = true;\r\n}\r\nstatic struct mlxsw_afa_fwd_entry *\r\nmlxsw_afa_fwd_entry_create(struct mlxsw_afa *mlxsw_afa, u8 local_port)\r\n{\r\nstruct mlxsw_afa_fwd_entry *fwd_entry;\r\nint err;\r\nfwd_entry = kzalloc(sizeof(*fwd_entry), GFP_KERNEL);\r\nif (!fwd_entry)\r\nreturn ERR_PTR(-ENOMEM);\r\nfwd_entry->ht_key.local_port = local_port;\r\nfwd_entry->ref_count = 1;\r\nerr = rhashtable_insert_fast(&mlxsw_afa->fwd_entry_ht,\r\n&fwd_entry->ht_node,\r\nmlxsw_afa_fwd_entry_ht_params);\r\nif (err)\r\ngoto err_rhashtable_insert;\r\nerr = mlxsw_afa->ops->kvdl_fwd_entry_add(mlxsw_afa->ops_priv,\r\n&fwd_entry->kvdl_index,\r\nlocal_port);\r\nif (err)\r\ngoto err_kvdl_fwd_entry_add;\r\nreturn fwd_entry;\r\nerr_kvdl_fwd_entry_add:\r\nrhashtable_remove_fast(&mlxsw_afa->fwd_entry_ht, &fwd_entry->ht_node,\r\nmlxsw_afa_fwd_entry_ht_params);\r\nerr_rhashtable_insert:\r\nkfree(fwd_entry);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void mlxsw_afa_fwd_entry_destroy(struct mlxsw_afa *mlxsw_afa,\r\nstruct mlxsw_afa_fwd_entry *fwd_entry)\r\n{\r\nmlxsw_afa->ops->kvdl_fwd_entry_del(mlxsw_afa->ops_priv,\r\nfwd_entry->kvdl_index);\r\nrhashtable_remove_fast(&mlxsw_afa->fwd_entry_ht, &fwd_entry->ht_node,\r\nmlxsw_afa_fwd_entry_ht_params);\r\nkfree(fwd_entry);\r\n}\r\nstatic struct mlxsw_afa_fwd_entry *\r\nmlxsw_afa_fwd_entry_get(struct mlxsw_afa *mlxsw_afa, u8 local_port)\r\n{\r\nstruct mlxsw_afa_fwd_entry_ht_key ht_key = {0};\r\nstruct mlxsw_afa_fwd_entry *fwd_entry;\r\nht_key.local_port = local_port;\r\nfwd_entry = rhashtable_lookup_fast(&mlxsw_afa->fwd_entry_ht, &ht_key,\r\nmlxsw_afa_fwd_entry_ht_params);\r\nif (fwd_entry) {\r\nfwd_entry->ref_count++;\r\nreturn fwd_entry;\r\n}\r\nreturn mlxsw_afa_fwd_entry_create(mlxsw_afa, local_port);\r\n}\r\nstatic void mlxsw_afa_fwd_entry_put(struct mlxsw_afa *mlxsw_afa,\r\nstruct mlxsw_afa_fwd_entry *fwd_entry)\r\n{\r\nif (--fwd_entry->ref_count)\r\nreturn;\r\nmlxsw_afa_fwd_entry_destroy(mlxsw_afa, fwd_entry);\r\n}\r\nstatic struct mlxsw_afa_fwd_entry_ref *\r\nmlxsw_afa_fwd_entry_ref_create(struct mlxsw_afa_block *block, u8 local_port)\r\n{\r\nstruct mlxsw_afa_fwd_entry_ref *fwd_entry_ref;\r\nstruct mlxsw_afa_fwd_entry *fwd_entry;\r\nint err;\r\nfwd_entry_ref = kzalloc(sizeof(*fwd_entry_ref), GFP_KERNEL);\r\nif (!fwd_entry_ref)\r\nreturn ERR_PTR(-ENOMEM);\r\nfwd_entry = mlxsw_afa_fwd_entry_get(block->afa, local_port);\r\nif (IS_ERR(fwd_entry)) {\r\nerr = PTR_ERR(fwd_entry);\r\ngoto err_fwd_entry_get;\r\n}\r\nfwd_entry_ref->fwd_entry = fwd_entry;\r\nlist_add(&fwd_entry_ref->list, &block->fwd_entry_ref_list);\r\nreturn fwd_entry_ref;\r\nerr_fwd_entry_get:\r\nkfree(fwd_entry_ref);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void\r\nmlxsw_afa_fwd_entry_ref_destroy(struct mlxsw_afa_block *block,\r\nstruct mlxsw_afa_fwd_entry_ref *fwd_entry_ref)\r\n{\r\nlist_del(&fwd_entry_ref->list);\r\nmlxsw_afa_fwd_entry_put(block->afa, fwd_entry_ref->fwd_entry);\r\nkfree(fwd_entry_ref);\r\n}\r\nstatic void mlxsw_afa_fwd_entry_refs_destroy(struct mlxsw_afa_block *block)\r\n{\r\nstruct mlxsw_afa_fwd_entry_ref *fwd_entry_ref;\r\nstruct mlxsw_afa_fwd_entry_ref *tmp;\r\nlist_for_each_entry_safe(fwd_entry_ref, tmp,\r\n&block->fwd_entry_ref_list, list)\r\nmlxsw_afa_fwd_entry_ref_destroy(block, fwd_entry_ref);\r\n}\r\nstatic char *mlxsw_afa_block_append_action(struct mlxsw_afa_block *block,\r\nu8 action_code, u8 action_size)\r\n{\r\nchar *oneact;\r\nchar *actions;\r\nif (WARN_ON(block->finished))\r\nreturn NULL;\r\nif (block->cur_act_index + action_size >\r\nblock->afa->max_acts_per_set) {\r\nstruct mlxsw_afa_set *set;\r\nset = mlxsw_afa_set_create(false);\r\nif (!set)\r\nreturn NULL;\r\nset->prev = block->cur_set;\r\nblock->cur_act_index = 0;\r\nblock->cur_set->next = set;\r\nblock->cur_set = set;\r\n}\r\nactions = block->cur_set->ht_key.enc_actions;\r\noneact = actions + block->cur_act_index * MLXSW_AFA_ONE_ACTION_LEN;\r\nblock->cur_act_index += action_size;\r\nmlxsw_afa_all_action_type_set(oneact, action_code);\r\nreturn oneact + MLXSW_AFA_PAYLOAD_OFFSET;\r\n}\r\nstatic inline void\r\nmlxsw_afa_vlan_pack(char *payload,\r\nenum mlxsw_afa_vlan_vlan_tag_cmd vlan_tag_cmd,\r\nenum mlxsw_afa_vlan_cmd vid_cmd, u16 vid,\r\nenum mlxsw_afa_vlan_cmd pcp_cmd, u8 pcp,\r\nenum mlxsw_afa_vlan_cmd ethertype_cmd, u8 ethertype)\r\n{\r\nmlxsw_afa_vlan_vlan_tag_cmd_set(payload, vlan_tag_cmd);\r\nmlxsw_afa_vlan_vid_cmd_set(payload, vid_cmd);\r\nmlxsw_afa_vlan_vid_set(payload, vid);\r\nmlxsw_afa_vlan_pcp_cmd_set(payload, pcp_cmd);\r\nmlxsw_afa_vlan_pcp_set(payload, pcp);\r\nmlxsw_afa_vlan_ethertype_cmd_set(payload, ethertype_cmd);\r\nmlxsw_afa_vlan_ethertype_set(payload, ethertype);\r\n}\r\nint mlxsw_afa_block_append_vlan_modify(struct mlxsw_afa_block *block,\r\nu16 vid, u8 pcp, u8 et)\r\n{\r\nchar *act = mlxsw_afa_block_append_action(block,\r\nMLXSW_AFA_VLAN_CODE,\r\nMLXSW_AFA_VLAN_SIZE);\r\nif (!act)\r\nreturn -ENOBUFS;\r\nmlxsw_afa_vlan_pack(act, MLXSW_AFA_VLAN_VLAN_TAG_CMD_NOP,\r\nMLXSW_AFA_VLAN_CMD_SET_OUTER, vid,\r\nMLXSW_AFA_VLAN_CMD_SET_OUTER, pcp,\r\nMLXSW_AFA_VLAN_CMD_SET_OUTER, et);\r\nreturn 0;\r\n}\r\nstatic inline void\r\nmlxsw_afa_trapdisc_pack(char *payload,\r\nenum mlxsw_afa_trapdisc_trap_action trap_action,\r\nenum mlxsw_afa_trapdisc_forward_action forward_action,\r\nu16 trap_id)\r\n{\r\nmlxsw_afa_trapdisc_trap_action_set(payload, trap_action);\r\nmlxsw_afa_trapdisc_forward_action_set(payload, forward_action);\r\nmlxsw_afa_trapdisc_trap_id_set(payload, trap_id);\r\n}\r\nint mlxsw_afa_block_append_drop(struct mlxsw_afa_block *block)\r\n{\r\nchar *act = mlxsw_afa_block_append_action(block,\r\nMLXSW_AFA_TRAPDISC_CODE,\r\nMLXSW_AFA_TRAPDISC_SIZE);\r\nif (!act)\r\nreturn -ENOBUFS;\r\nmlxsw_afa_trapdisc_pack(act, MLXSW_AFA_TRAPDISC_TRAP_ACTION_NOP,\r\nMLXSW_AFA_TRAPDISC_FORWARD_ACTION_DISCARD, 0);\r\nreturn 0;\r\n}\r\nint mlxsw_afa_block_append_trap(struct mlxsw_afa_block *block)\r\n{\r\nchar *act = mlxsw_afa_block_append_action(block,\r\nMLXSW_AFA_TRAPDISC_CODE,\r\nMLXSW_AFA_TRAPDISC_SIZE);\r\nif (!act)\r\nreturn -ENOBUFS;\r\nmlxsw_afa_trapdisc_pack(act, MLXSW_AFA_TRAPDISC_TRAP_ACTION_TRAP,\r\nMLXSW_AFA_TRAPDISC_FORWARD_ACTION_DISCARD,\r\nMLXSW_TRAP_ID_ACL0);\r\nreturn 0;\r\n}\r\nstatic inline void\r\nmlxsw_afa_forward_pack(char *payload, enum mlxsw_afa_forward_type type,\r\nu32 pbs_ptr, bool in_port)\r\n{\r\nmlxsw_afa_forward_type_set(payload, type);\r\nmlxsw_afa_forward_pbs_ptr_set(payload, pbs_ptr);\r\nmlxsw_afa_forward_in_port_set(payload, in_port);\r\n}\r\nint mlxsw_afa_block_append_fwd(struct mlxsw_afa_block *block,\r\nu8 local_port, bool in_port)\r\n{\r\nstruct mlxsw_afa_fwd_entry_ref *fwd_entry_ref;\r\nu32 kvdl_index;\r\nchar *act;\r\nint err;\r\nif (in_port)\r\nreturn -EOPNOTSUPP;\r\nfwd_entry_ref = mlxsw_afa_fwd_entry_ref_create(block, local_port);\r\nif (IS_ERR(fwd_entry_ref))\r\nreturn PTR_ERR(fwd_entry_ref);\r\nkvdl_index = fwd_entry_ref->fwd_entry->kvdl_index;\r\nact = mlxsw_afa_block_append_action(block, MLXSW_AFA_FORWARD_CODE,\r\nMLXSW_AFA_FORWARD_SIZE);\r\nif (!act) {\r\nerr = -ENOBUFS;\r\ngoto err_append_action;\r\n}\r\nmlxsw_afa_forward_pack(act, MLXSW_AFA_FORWARD_TYPE_PBS,\r\nkvdl_index, in_port);\r\nreturn 0;\r\nerr_append_action:\r\nmlxsw_afa_fwd_entry_ref_destroy(block, fwd_entry_ref);\r\nreturn err;\r\n}\r\nstatic inline void\r\nmlxsw_afa_polcnt_pack(char *payload,\r\nenum mlxsw_afa_polcnt_counter_set_type set_type,\r\nu32 counter_index)\r\n{\r\nmlxsw_afa_polcnt_counter_set_type_set(payload, set_type);\r\nmlxsw_afa_polcnt_counter_index_set(payload, counter_index);\r\n}\r\nint mlxsw_afa_block_append_counter(struct mlxsw_afa_block *block,\r\nu32 counter_index)\r\n{\r\nchar *act = mlxsw_afa_block_append_action(block,\r\nMLXSW_AFA_POLCNT_CODE,\r\nMLXSW_AFA_POLCNT_SIZE);\r\nif (!act)\r\nreturn -ENOBUFS;\r\nmlxsw_afa_polcnt_pack(act, MLXSW_AFA_POLCNT_COUNTER_SET_TYPE_PACKETS_BYTES,\r\ncounter_index);\r\nreturn 0;\r\n}\r\nstatic inline void mlxsw_afa_virfwd_pack(char *payload,\r\nenum mlxsw_afa_virfwd_fid_cmd fid_cmd,\r\nu16 fid)\r\n{\r\nmlxsw_afa_virfwd_fid_cmd_set(payload, fid_cmd);\r\nmlxsw_afa_virfwd_fid_set(payload, fid);\r\n}\r\nint mlxsw_afa_block_append_fid_set(struct mlxsw_afa_block *block, u16 fid)\r\n{\r\nchar *act = mlxsw_afa_block_append_action(block,\r\nMLXSW_AFA_VIRFWD_CODE,\r\nMLXSW_AFA_VIRFWD_SIZE);\r\nif (!act)\r\nreturn -ENOBUFS;\r\nmlxsw_afa_virfwd_pack(act, MLXSW_AFA_VIRFWD_FID_CMD_SET, fid);\r\nreturn 0;\r\n}
