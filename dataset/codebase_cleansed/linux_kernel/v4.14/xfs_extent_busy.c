void\r\nxfs_extent_busy_insert(\r\nstruct xfs_trans *tp,\r\nxfs_agnumber_t agno,\r\nxfs_agblock_t bno,\r\nxfs_extlen_t len,\r\nunsigned int flags)\r\n{\r\nstruct xfs_extent_busy *new;\r\nstruct xfs_extent_busy *busyp;\r\nstruct xfs_perag *pag;\r\nstruct rb_node **rbp;\r\nstruct rb_node *parent = NULL;\r\nnew = kmem_zalloc(sizeof(struct xfs_extent_busy), KM_SLEEP);\r\nnew->agno = agno;\r\nnew->bno = bno;\r\nnew->length = len;\r\nINIT_LIST_HEAD(&new->list);\r\nnew->flags = flags;\r\ntrace_xfs_extent_busy(tp->t_mountp, agno, bno, len);\r\npag = xfs_perag_get(tp->t_mountp, new->agno);\r\nspin_lock(&pag->pagb_lock);\r\nrbp = &pag->pagb_tree.rb_node;\r\nwhile (*rbp) {\r\nparent = *rbp;\r\nbusyp = rb_entry(parent, struct xfs_extent_busy, rb_node);\r\nif (new->bno < busyp->bno) {\r\nrbp = &(*rbp)->rb_left;\r\nASSERT(new->bno + new->length <= busyp->bno);\r\n} else if (new->bno > busyp->bno) {\r\nrbp = &(*rbp)->rb_right;\r\nASSERT(bno >= busyp->bno + busyp->length);\r\n} else {\r\nASSERT(0);\r\n}\r\n}\r\nrb_link_node(&new->rb_node, parent, rbp);\r\nrb_insert_color(&new->rb_node, &pag->pagb_tree);\r\nlist_add(&new->list, &tp->t_busy);\r\nspin_unlock(&pag->pagb_lock);\r\nxfs_perag_put(pag);\r\n}\r\nint\r\nxfs_extent_busy_search(\r\nstruct xfs_mount *mp,\r\nxfs_agnumber_t agno,\r\nxfs_agblock_t bno,\r\nxfs_extlen_t len)\r\n{\r\nstruct xfs_perag *pag;\r\nstruct rb_node *rbp;\r\nstruct xfs_extent_busy *busyp;\r\nint match = 0;\r\npag = xfs_perag_get(mp, agno);\r\nspin_lock(&pag->pagb_lock);\r\nrbp = pag->pagb_tree.rb_node;\r\nwhile (rbp) {\r\nbusyp = rb_entry(rbp, struct xfs_extent_busy, rb_node);\r\nif (bno < busyp->bno) {\r\nif (bno + len > busyp->bno)\r\nmatch = -1;\r\nrbp = rbp->rb_left;\r\n} else if (bno > busyp->bno) {\r\nif (bno < busyp->bno + busyp->length)\r\nmatch = -1;\r\nrbp = rbp->rb_right;\r\n} else {\r\nmatch = (busyp->length == len) ? 1 : -1;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&pag->pagb_lock);\r\nxfs_perag_put(pag);\r\nreturn match;\r\n}\r\nSTATIC bool\r\nxfs_extent_busy_update_extent(\r\nstruct xfs_mount *mp,\r\nstruct xfs_perag *pag,\r\nstruct xfs_extent_busy *busyp,\r\nxfs_agblock_t fbno,\r\nxfs_extlen_t flen,\r\nbool userdata) __releases(&pag->pagb_lock\r\nvoid\r\nxfs_extent_busy_reuse(\r\nstruct xfs_mount *mp,\r\nxfs_agnumber_t agno,\r\nxfs_agblock_t fbno,\r\nxfs_extlen_t flen,\r\nbool userdata)\r\n{\r\nstruct xfs_perag *pag;\r\nstruct rb_node *rbp;\r\nASSERT(flen > 0);\r\npag = xfs_perag_get(mp, agno);\r\nspin_lock(&pag->pagb_lock);\r\nrestart:\r\nrbp = pag->pagb_tree.rb_node;\r\nwhile (rbp) {\r\nstruct xfs_extent_busy *busyp =\r\nrb_entry(rbp, struct xfs_extent_busy, rb_node);\r\nxfs_agblock_t bbno = busyp->bno;\r\nxfs_agblock_t bend = bbno + busyp->length;\r\nif (fbno + flen <= bbno) {\r\nrbp = rbp->rb_left;\r\ncontinue;\r\n} else if (fbno >= bend) {\r\nrbp = rbp->rb_right;\r\ncontinue;\r\n}\r\nif (!xfs_extent_busy_update_extent(mp, pag, busyp, fbno, flen,\r\nuserdata))\r\ngoto restart;\r\n}\r\nspin_unlock(&pag->pagb_lock);\r\nxfs_perag_put(pag);\r\n}\r\nbool\r\nxfs_extent_busy_trim(\r\nstruct xfs_alloc_arg *args,\r\nxfs_agblock_t *bno,\r\nxfs_extlen_t *len,\r\nunsigned *busy_gen)\r\n{\r\nxfs_agblock_t fbno;\r\nxfs_extlen_t flen;\r\nstruct rb_node *rbp;\r\nbool ret = false;\r\nASSERT(*len > 0);\r\nspin_lock(&args->pag->pagb_lock);\r\nrestart:\r\nfbno = *bno;\r\nflen = *len;\r\nrbp = args->pag->pagb_tree.rb_node;\r\nwhile (rbp && flen >= args->minlen) {\r\nstruct xfs_extent_busy *busyp =\r\nrb_entry(rbp, struct xfs_extent_busy, rb_node);\r\nxfs_agblock_t fend = fbno + flen;\r\nxfs_agblock_t bbno = busyp->bno;\r\nxfs_agblock_t bend = bbno + busyp->length;\r\nif (fend <= bbno) {\r\nrbp = rbp->rb_left;\r\ncontinue;\r\n} else if (fbno >= bend) {\r\nrbp = rbp->rb_right;\r\ncontinue;\r\n}\r\nif (!xfs_alloc_is_userdata(args->datatype) &&\r\n!(busyp->flags & XFS_EXTENT_BUSY_DISCARDED)) {\r\nif (!xfs_extent_busy_update_extent(args->mp, args->pag,\r\nbusyp, fbno, flen,\r\nfalse))\r\ngoto restart;\r\ncontinue;\r\n}\r\nif (bbno <= fbno) {\r\nif (fend <= bend)\r\ngoto fail;\r\nfbno = bend;\r\n} else if (bend >= fend) {\r\nfend = bbno;\r\n} else {\r\nif (bbno - fbno >= args->maxlen) {\r\nfend = bbno;\r\n} else if (fend - bend >= args->maxlen * 4) {\r\nfbno = bend;\r\n} else if (bbno - fbno >= args->minlen) {\r\nfend = bbno;\r\n} else {\r\ngoto fail;\r\n}\r\n}\r\nflen = fend - fbno;\r\n}\r\nout:\r\nif (fbno != *bno || flen != *len) {\r\ntrace_xfs_extent_busy_trim(args->mp, args->agno, *bno, *len,\r\nfbno, flen);\r\n*bno = fbno;\r\n*len = flen;\r\n*busy_gen = args->pag->pagb_gen;\r\nret = true;\r\n}\r\nspin_unlock(&args->pag->pagb_lock);\r\nreturn ret;\r\nfail:\r\nflen = 0;\r\ngoto out;\r\n}\r\nSTATIC void\r\nxfs_extent_busy_clear_one(\r\nstruct xfs_mount *mp,\r\nstruct xfs_perag *pag,\r\nstruct xfs_extent_busy *busyp)\r\n{\r\nif (busyp->length) {\r\ntrace_xfs_extent_busy_clear(mp, busyp->agno, busyp->bno,\r\nbusyp->length);\r\nrb_erase(&busyp->rb_node, &pag->pagb_tree);\r\n}\r\nlist_del_init(&busyp->list);\r\nkmem_free(busyp);\r\n}\r\nstatic void\r\nxfs_extent_busy_put_pag(\r\nstruct xfs_perag *pag,\r\nbool wakeup)\r\n__releases(pag->pagb_lock)\r\n{\r\nif (wakeup) {\r\npag->pagb_gen++;\r\nwake_up_all(&pag->pagb_wait);\r\n}\r\nspin_unlock(&pag->pagb_lock);\r\nxfs_perag_put(pag);\r\n}\r\nvoid\r\nxfs_extent_busy_clear(\r\nstruct xfs_mount *mp,\r\nstruct list_head *list,\r\nbool do_discard)\r\n{\r\nstruct xfs_extent_busy *busyp, *n;\r\nstruct xfs_perag *pag = NULL;\r\nxfs_agnumber_t agno = NULLAGNUMBER;\r\nbool wakeup = false;\r\nlist_for_each_entry_safe(busyp, n, list, list) {\r\nif (busyp->agno != agno) {\r\nif (pag)\r\nxfs_extent_busy_put_pag(pag, wakeup);\r\nagno = busyp->agno;\r\npag = xfs_perag_get(mp, agno);\r\nspin_lock(&pag->pagb_lock);\r\nwakeup = false;\r\n}\r\nif (do_discard && busyp->length &&\r\n!(busyp->flags & XFS_EXTENT_BUSY_SKIP_DISCARD)) {\r\nbusyp->flags = XFS_EXTENT_BUSY_DISCARDED;\r\n} else {\r\nxfs_extent_busy_clear_one(mp, pag, busyp);\r\nwakeup = true;\r\n}\r\n}\r\nif (pag)\r\nxfs_extent_busy_put_pag(pag, wakeup);\r\n}\r\nvoid\r\nxfs_extent_busy_flush(\r\nstruct xfs_mount *mp,\r\nstruct xfs_perag *pag,\r\nunsigned busy_gen)\r\n{\r\nDEFINE_WAIT (wait);\r\nint log_flushed = 0, error;\r\ntrace_xfs_log_force(mp, 0, _THIS_IP_);\r\nerror = _xfs_log_force(mp, XFS_LOG_SYNC, &log_flushed);\r\nif (error)\r\nreturn;\r\ndo {\r\nprepare_to_wait(&pag->pagb_wait, &wait, TASK_KILLABLE);\r\nif (busy_gen != READ_ONCE(pag->pagb_gen))\r\nbreak;\r\nschedule();\r\n} while (1);\r\nfinish_wait(&pag->pagb_wait, &wait);\r\n}\r\nvoid\r\nxfs_extent_busy_wait_all(\r\nstruct xfs_mount *mp)\r\n{\r\nDEFINE_WAIT (wait);\r\nxfs_agnumber_t agno;\r\nfor (agno = 0; agno < mp->m_sb.sb_agcount; agno++) {\r\nstruct xfs_perag *pag = xfs_perag_get(mp, agno);\r\ndo {\r\nprepare_to_wait(&pag->pagb_wait, &wait, TASK_KILLABLE);\r\nif (RB_EMPTY_ROOT(&pag->pagb_tree))\r\nbreak;\r\nschedule();\r\n} while (1);\r\nfinish_wait(&pag->pagb_wait, &wait);\r\nxfs_perag_put(pag);\r\n}\r\n}\r\nint\r\nxfs_extent_busy_ag_cmp(\r\nvoid *priv,\r\nstruct list_head *l1,\r\nstruct list_head *l2)\r\n{\r\nstruct xfs_extent_busy *b1 =\r\ncontainer_of(l1, struct xfs_extent_busy, list);\r\nstruct xfs_extent_busy *b2 =\r\ncontainer_of(l2, struct xfs_extent_busy, list);\r\ns32 diff;\r\ndiff = b1->agno - b2->agno;\r\nif (!diff)\r\ndiff = b1->bno - b2->bno;\r\nreturn diff;\r\n}
