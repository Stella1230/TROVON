void optee_supp_init(struct optee_supp *supp)\r\n{\r\nmemset(supp, 0, sizeof(*supp));\r\nmutex_init(&supp->ctx_mutex);\r\nmutex_init(&supp->thrd_mutex);\r\nmutex_init(&supp->supp_mutex);\r\ninit_completion(&supp->data_to_supp);\r\ninit_completion(&supp->data_from_supp);\r\n}\r\nvoid optee_supp_uninit(struct optee_supp *supp)\r\n{\r\nmutex_destroy(&supp->ctx_mutex);\r\nmutex_destroy(&supp->thrd_mutex);\r\nmutex_destroy(&supp->supp_mutex);\r\n}\r\nu32 optee_supp_thrd_req(struct tee_context *ctx, u32 func, size_t num_params,\r\nstruct tee_param *param)\r\n{\r\nbool interruptable;\r\nstruct optee *optee = tee_get_drvdata(ctx->teedev);\r\nstruct optee_supp *supp = &optee->supp;\r\nu32 ret;\r\nwhile (mutex_lock_interruptible(&supp->thrd_mutex)) {\r\nmutex_lock(&supp->ctx_mutex);\r\ninterruptable = !supp->ctx;\r\nmutex_unlock(&supp->ctx_mutex);\r\nif (interruptable)\r\nreturn TEEC_ERROR_COMMUNICATION;\r\n}\r\nsupp->func = func;\r\nsupp->num_params = num_params;\r\nsupp->param = param;\r\nsupp->req_posted = true;\r\ncomplete(&supp->data_to_supp);\r\nwhile (wait_for_completion_interruptible(&supp->data_from_supp)) {\r\nmutex_lock(&supp->ctx_mutex);\r\ninterruptable = !supp->ctx;\r\nif (interruptable) {\r\nsupp->ret = TEEC_ERROR_COMMUNICATION;\r\ninit_completion(&supp->data_to_supp);\r\n}\r\nmutex_unlock(&supp->ctx_mutex);\r\nif (interruptable)\r\nbreak;\r\n}\r\nret = supp->ret;\r\nsupp->param = NULL;\r\nsupp->req_posted = false;\r\nmutex_unlock(&supp->thrd_mutex);\r\nreturn ret;\r\n}\r\nint optee_supp_recv(struct tee_context *ctx, u32 *func, u32 *num_params,\r\nstruct tee_param *param)\r\n{\r\nstruct tee_device *teedev = ctx->teedev;\r\nstruct optee *optee = tee_get_drvdata(teedev);\r\nstruct optee_supp *supp = &optee->supp;\r\nint rc;\r\nmutex_lock(&supp->supp_mutex);\r\nif (supp->supp_next_send) {\r\nif (supp->req_posted) {\r\nsupp->ret = TEEC_ERROR_COMMUNICATION;\r\nsupp->supp_next_send = false;\r\ncomplete(&supp->data_from_supp);\r\n}\r\n}\r\nif (wait_for_completion_interruptible(&supp->data_to_supp)) {\r\nrc = -ERESTARTSYS;\r\ngoto out;\r\n}\r\nif (*num_params < supp->num_params) {\r\nsupp->ret = TEEC_ERROR_COMMUNICATION;\r\nrc = -EINVAL;\r\ncomplete(&supp->data_from_supp);\r\ngoto out;\r\n}\r\n*func = supp->func;\r\n*num_params = supp->num_params;\r\nmemcpy(param, supp->param,\r\nsizeof(struct tee_param) * supp->num_params);\r\nsupp->supp_next_send = true;\r\nrc = 0;\r\nout:\r\nmutex_unlock(&supp->supp_mutex);\r\nreturn rc;\r\n}\r\nint optee_supp_send(struct tee_context *ctx, u32 ret, u32 num_params,\r\nstruct tee_param *param)\r\n{\r\nstruct tee_device *teedev = ctx->teedev;\r\nstruct optee *optee = tee_get_drvdata(teedev);\r\nstruct optee_supp *supp = &optee->supp;\r\nsize_t n;\r\nint rc = 0;\r\nmutex_lock(&supp->supp_mutex);\r\nif (!supp->supp_next_send) {\r\nrc = -ENOENT;\r\ngoto out;\r\n}\r\nif (num_params != supp->num_params) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nfor (n = 0; n < num_params; n++) {\r\nstruct tee_param *p = supp->param + n;\r\nswitch (p->attr) {\r\ncase TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_OUTPUT:\r\ncase TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INOUT:\r\np->u.value.a = param[n].u.value.a;\r\np->u.value.b = param[n].u.value.b;\r\np->u.value.c = param[n].u.value.c;\r\nbreak;\r\ncase TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT:\r\ncase TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT:\r\np->u.memref.size = param[n].u.memref.size;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nsupp->ret = ret;\r\nsupp->supp_next_send = false;\r\ncomplete(&supp->data_from_supp);\r\nout:\r\nmutex_unlock(&supp->supp_mutex);\r\nreturn rc;\r\n}
