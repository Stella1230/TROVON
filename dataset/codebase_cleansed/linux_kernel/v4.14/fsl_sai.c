static irqreturn_t fsl_sai_isr(int irq, void *devid)\r\n{\r\nstruct fsl_sai *sai = (struct fsl_sai *)devid;\r\nstruct device *dev = &sai->pdev->dev;\r\nu32 flags, xcsr, mask;\r\nbool irq_none = true;\r\nmask = (FSL_SAI_FLAGS >> FSL_SAI_CSR_xIE_SHIFT) << FSL_SAI_CSR_xF_SHIFT;\r\nregmap_read(sai->regmap, FSL_SAI_TCSR, &xcsr);\r\nflags = xcsr & mask;\r\nif (flags)\r\nirq_none = false;\r\nelse\r\ngoto irq_rx;\r\nif (flags & FSL_SAI_CSR_WSF)\r\ndev_dbg(dev, "isr: Start of Tx word detected\n");\r\nif (flags & FSL_SAI_CSR_SEF)\r\ndev_warn(dev, "isr: Tx Frame sync error detected\n");\r\nif (flags & FSL_SAI_CSR_FEF) {\r\ndev_warn(dev, "isr: Transmit underrun detected\n");\r\nxcsr |= FSL_SAI_CSR_FR;\r\n}\r\nif (flags & FSL_SAI_CSR_FWF)\r\ndev_dbg(dev, "isr: Enabled transmit FIFO is empty\n");\r\nif (flags & FSL_SAI_CSR_FRF)\r\ndev_dbg(dev, "isr: Transmit FIFO watermark has been reached\n");\r\nflags &= FSL_SAI_CSR_xF_W_MASK;\r\nxcsr &= ~FSL_SAI_CSR_xF_MASK;\r\nif (flags)\r\nregmap_write(sai->regmap, FSL_SAI_TCSR, flags | xcsr);\r\nirq_rx:\r\nregmap_read(sai->regmap, FSL_SAI_RCSR, &xcsr);\r\nflags = xcsr & mask;\r\nif (flags)\r\nirq_none = false;\r\nelse\r\ngoto out;\r\nif (flags & FSL_SAI_CSR_WSF)\r\ndev_dbg(dev, "isr: Start of Rx word detected\n");\r\nif (flags & FSL_SAI_CSR_SEF)\r\ndev_warn(dev, "isr: Rx Frame sync error detected\n");\r\nif (flags & FSL_SAI_CSR_FEF) {\r\ndev_warn(dev, "isr: Receive overflow detected\n");\r\nxcsr |= FSL_SAI_CSR_FR;\r\n}\r\nif (flags & FSL_SAI_CSR_FWF)\r\ndev_dbg(dev, "isr: Enabled receive FIFO is full\n");\r\nif (flags & FSL_SAI_CSR_FRF)\r\ndev_dbg(dev, "isr: Receive FIFO watermark has been reached\n");\r\nflags &= FSL_SAI_CSR_xF_W_MASK;\r\nxcsr &= ~FSL_SAI_CSR_xF_MASK;\r\nif (flags)\r\nregmap_write(sai->regmap, FSL_SAI_RCSR, flags | xcsr);\r\nout:\r\nif (irq_none)\r\nreturn IRQ_NONE;\r\nelse\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int fsl_sai_set_dai_tdm_slot(struct snd_soc_dai *cpu_dai, u32 tx_mask,\r\nu32 rx_mask, int slots, int slot_width)\r\n{\r\nstruct fsl_sai *sai = snd_soc_dai_get_drvdata(cpu_dai);\r\nsai->slots = slots;\r\nsai->slot_width = slot_width;\r\nreturn 0;\r\n}\r\nstatic int fsl_sai_set_dai_sysclk_tr(struct snd_soc_dai *cpu_dai,\r\nint clk_id, unsigned int freq, int fsl_dir)\r\n{\r\nstruct fsl_sai *sai = snd_soc_dai_get_drvdata(cpu_dai);\r\nbool tx = fsl_dir == FSL_FMT_TRANSMITTER;\r\nu32 val_cr2 = 0;\r\nswitch (clk_id) {\r\ncase FSL_SAI_CLK_BUS:\r\nval_cr2 |= FSL_SAI_CR2_MSEL_BUS;\r\nbreak;\r\ncase FSL_SAI_CLK_MAST1:\r\nval_cr2 |= FSL_SAI_CR2_MSEL_MCLK1;\r\nbreak;\r\ncase FSL_SAI_CLK_MAST2:\r\nval_cr2 |= FSL_SAI_CR2_MSEL_MCLK2;\r\nbreak;\r\ncase FSL_SAI_CLK_MAST3:\r\nval_cr2 |= FSL_SAI_CR2_MSEL_MCLK3;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nregmap_update_bits(sai->regmap, FSL_SAI_xCR2(tx),\r\nFSL_SAI_CR2_MSEL_MASK, val_cr2);\r\nreturn 0;\r\n}\r\nstatic int fsl_sai_set_dai_sysclk(struct snd_soc_dai *cpu_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nint ret;\r\nif (dir == SND_SOC_CLOCK_IN)\r\nreturn 0;\r\nret = fsl_sai_set_dai_sysclk_tr(cpu_dai, clk_id, freq,\r\nFSL_FMT_TRANSMITTER);\r\nif (ret) {\r\ndev_err(cpu_dai->dev, "Cannot set tx sysclk: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = fsl_sai_set_dai_sysclk_tr(cpu_dai, clk_id, freq,\r\nFSL_FMT_RECEIVER);\r\nif (ret)\r\ndev_err(cpu_dai->dev, "Cannot set rx sysclk: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int fsl_sai_set_dai_fmt_tr(struct snd_soc_dai *cpu_dai,\r\nunsigned int fmt, int fsl_dir)\r\n{\r\nstruct fsl_sai *sai = snd_soc_dai_get_drvdata(cpu_dai);\r\nbool tx = fsl_dir == FSL_FMT_TRANSMITTER;\r\nu32 val_cr2 = 0, val_cr4 = 0;\r\nif (!sai->is_lsb_first)\r\nval_cr4 |= FSL_SAI_CR4_MF;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nval_cr2 |= FSL_SAI_CR2_BCP;\r\nval_cr4 |= FSL_SAI_CR4_FSE | FSL_SAI_CR4_FSP;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nval_cr2 |= FSL_SAI_CR2_BCP;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\nval_cr2 |= FSL_SAI_CR2_BCP;\r\nval_cr4 |= FSL_SAI_CR4_FSE;\r\nsai->is_dsp_mode = true;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nval_cr2 |= FSL_SAI_CR2_BCP;\r\nsai->is_dsp_mode = true;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nval_cr2 ^= FSL_SAI_CR2_BCP;\r\nval_cr4 ^= FSL_SAI_CR4_FSP;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nval_cr2 ^= FSL_SAI_CR2_BCP;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nval_cr4 ^= FSL_SAI_CR4_FSP;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nval_cr2 |= FSL_SAI_CR2_BCD_MSTR;\r\nval_cr4 |= FSL_SAI_CR4_FSD_MSTR;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nsai->is_slave_mode = true;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFM:\r\nval_cr2 |= FSL_SAI_CR2_BCD_MSTR;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFS:\r\nval_cr4 |= FSL_SAI_CR4_FSD_MSTR;\r\nsai->is_slave_mode = true;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nregmap_update_bits(sai->regmap, FSL_SAI_xCR2(tx),\r\nFSL_SAI_CR2_BCP | FSL_SAI_CR2_BCD_MSTR, val_cr2);\r\nregmap_update_bits(sai->regmap, FSL_SAI_xCR4(tx),\r\nFSL_SAI_CR4_MF | FSL_SAI_CR4_FSE |\r\nFSL_SAI_CR4_FSP | FSL_SAI_CR4_FSD_MSTR, val_cr4);\r\nreturn 0;\r\n}\r\nstatic int fsl_sai_set_dai_fmt(struct snd_soc_dai *cpu_dai, unsigned int fmt)\r\n{\r\nint ret;\r\nret = fsl_sai_set_dai_fmt_tr(cpu_dai, fmt, FSL_FMT_TRANSMITTER);\r\nif (ret) {\r\ndev_err(cpu_dai->dev, "Cannot set tx format: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = fsl_sai_set_dai_fmt_tr(cpu_dai, fmt, FSL_FMT_RECEIVER);\r\nif (ret)\r\ndev_err(cpu_dai->dev, "Cannot set rx format: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int fsl_sai_set_bclk(struct snd_soc_dai *dai, bool tx, u32 freq)\r\n{\r\nstruct fsl_sai *sai = snd_soc_dai_get_drvdata(dai);\r\nunsigned long clk_rate;\r\nu32 savediv = 0, ratio, savesub = freq;\r\nu32 id;\r\nint ret = 0;\r\nif (sai->is_slave_mode)\r\nreturn 0;\r\nfor (id = 0; id < FSL_SAI_MCLK_MAX; id++) {\r\nclk_rate = clk_get_rate(sai->mclk_clk[id]);\r\nif (!clk_rate)\r\ncontinue;\r\nratio = clk_rate / freq;\r\nret = clk_rate - ratio * freq;\r\nif (ret != 0 && clk_rate / ret < 1000)\r\ncontinue;\r\ndev_dbg(dai->dev,\r\n"ratio %d for freq %dHz based on clock %ldHz\n",\r\nratio, freq, clk_rate);\r\nif (ratio % 2 == 0 && ratio >= 2 && ratio <= 512)\r\nratio /= 2;\r\nelse\r\ncontinue;\r\nif (ret < savesub) {\r\nsavediv = ratio;\r\nsai->mclk_id[tx] = id;\r\nsavesub = ret;\r\n}\r\nif (ret == 0)\r\nbreak;\r\n}\r\nif (savediv == 0) {\r\ndev_err(dai->dev, "failed to derive required %cx rate: %d\n",\r\ntx ? 'T' : 'R', freq);\r\nreturn -EINVAL;\r\n}\r\nif ((sai->synchronous[TX] && !sai->synchronous[RX]) ||\r\n(!tx && !sai->synchronous[RX])) {\r\nregmap_update_bits(sai->regmap, FSL_SAI_RCR2,\r\nFSL_SAI_CR2_MSEL_MASK,\r\nFSL_SAI_CR2_MSEL(sai->mclk_id[tx]));\r\nregmap_update_bits(sai->regmap, FSL_SAI_RCR2,\r\nFSL_SAI_CR2_DIV_MASK, savediv - 1);\r\n} else if ((sai->synchronous[RX] && !sai->synchronous[TX]) ||\r\n(tx && !sai->synchronous[TX])) {\r\nregmap_update_bits(sai->regmap, FSL_SAI_TCR2,\r\nFSL_SAI_CR2_MSEL_MASK,\r\nFSL_SAI_CR2_MSEL(sai->mclk_id[tx]));\r\nregmap_update_bits(sai->regmap, FSL_SAI_TCR2,\r\nFSL_SAI_CR2_DIV_MASK, savediv - 1);\r\n}\r\ndev_dbg(dai->dev, "best fit: clock id=%d, div=%d, deviation =%d\n",\r\nsai->mclk_id[tx], savediv, savesub);\r\nreturn 0;\r\n}\r\nstatic int fsl_sai_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *cpu_dai)\r\n{\r\nstruct fsl_sai *sai = snd_soc_dai_get_drvdata(cpu_dai);\r\nbool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\r\nunsigned int channels = params_channels(params);\r\nu32 word_width = params_width(params);\r\nu32 val_cr4 = 0, val_cr5 = 0;\r\nu32 slots = (channels == 1) ? 2 : channels;\r\nu32 slot_width = word_width;\r\nint ret;\r\nif (sai->slots)\r\nslots = sai->slots;\r\nif (sai->slot_width)\r\nslot_width = sai->slot_width;\r\nif (!sai->is_slave_mode) {\r\nret = fsl_sai_set_bclk(cpu_dai, tx,\r\nslots * slot_width * params_rate(params));\r\nif (ret)\r\nreturn ret;\r\nif (!(sai->mclk_streams & BIT(substream->stream))) {\r\nret = clk_prepare_enable(sai->mclk_clk[sai->mclk_id[tx]]);\r\nif (ret)\r\nreturn ret;\r\nsai->mclk_streams |= BIT(substream->stream);\r\n}\r\n}\r\nif (!sai->is_dsp_mode)\r\nval_cr4 |= FSL_SAI_CR4_SYWD(slot_width);\r\nval_cr5 |= FSL_SAI_CR5_WNW(slot_width);\r\nval_cr5 |= FSL_SAI_CR5_W0W(slot_width);\r\nif (sai->is_lsb_first)\r\nval_cr5 |= FSL_SAI_CR5_FBT(0);\r\nelse\r\nval_cr5 |= FSL_SAI_CR5_FBT(word_width - 1);\r\nval_cr4 |= FSL_SAI_CR4_FRSZ(slots);\r\nif (!sai->is_slave_mode) {\r\nif (!sai->synchronous[TX] && sai->synchronous[RX] && !tx) {\r\nregmap_update_bits(sai->regmap, FSL_SAI_TCR4,\r\nFSL_SAI_CR4_SYWD_MASK | FSL_SAI_CR4_FRSZ_MASK,\r\nval_cr4);\r\nregmap_update_bits(sai->regmap, FSL_SAI_TCR5,\r\nFSL_SAI_CR5_WNW_MASK | FSL_SAI_CR5_W0W_MASK |\r\nFSL_SAI_CR5_FBT_MASK, val_cr5);\r\nregmap_write(sai->regmap, FSL_SAI_TMR,\r\n~0UL - ((1 << channels) - 1));\r\n} else if (!sai->synchronous[RX] && sai->synchronous[TX] && tx) {\r\nregmap_update_bits(sai->regmap, FSL_SAI_RCR4,\r\nFSL_SAI_CR4_SYWD_MASK | FSL_SAI_CR4_FRSZ_MASK,\r\nval_cr4);\r\nregmap_update_bits(sai->regmap, FSL_SAI_RCR5,\r\nFSL_SAI_CR5_WNW_MASK | FSL_SAI_CR5_W0W_MASK |\r\nFSL_SAI_CR5_FBT_MASK, val_cr5);\r\nregmap_write(sai->regmap, FSL_SAI_RMR,\r\n~0UL - ((1 << channels) - 1));\r\n}\r\n}\r\nregmap_update_bits(sai->regmap, FSL_SAI_xCR4(tx),\r\nFSL_SAI_CR4_SYWD_MASK | FSL_SAI_CR4_FRSZ_MASK,\r\nval_cr4);\r\nregmap_update_bits(sai->regmap, FSL_SAI_xCR5(tx),\r\nFSL_SAI_CR5_WNW_MASK | FSL_SAI_CR5_W0W_MASK |\r\nFSL_SAI_CR5_FBT_MASK, val_cr5);\r\nregmap_write(sai->regmap, FSL_SAI_xMR(tx), ~0UL - ((1 << channels) - 1));\r\nreturn 0;\r\n}\r\nstatic int fsl_sai_hw_free(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *cpu_dai)\r\n{\r\nstruct fsl_sai *sai = snd_soc_dai_get_drvdata(cpu_dai);\r\nbool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\r\nif (!sai->is_slave_mode &&\r\nsai->mclk_streams & BIT(substream->stream)) {\r\nclk_disable_unprepare(sai->mclk_clk[sai->mclk_id[tx]]);\r\nsai->mclk_streams &= ~BIT(substream->stream);\r\n}\r\nreturn 0;\r\n}\r\nstatic int fsl_sai_trigger(struct snd_pcm_substream *substream, int cmd,\r\nstruct snd_soc_dai *cpu_dai)\r\n{\r\nstruct fsl_sai *sai = snd_soc_dai_get_drvdata(cpu_dai);\r\nbool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\r\nu32 xcsr, count = 100;\r\nregmap_update_bits(sai->regmap, FSL_SAI_TCR2, FSL_SAI_CR2_SYNC,\r\nsai->synchronous[TX] ? FSL_SAI_CR2_SYNC : 0);\r\nregmap_update_bits(sai->regmap, FSL_SAI_RCR2, FSL_SAI_CR2_SYNC,\r\nsai->synchronous[RX] ? FSL_SAI_CR2_SYNC : 0);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nregmap_update_bits(sai->regmap, FSL_SAI_xCSR(tx),\r\nFSL_SAI_CSR_FRDE, FSL_SAI_CSR_FRDE);\r\nregmap_update_bits(sai->regmap, FSL_SAI_RCSR,\r\nFSL_SAI_CSR_TERE, FSL_SAI_CSR_TERE);\r\nregmap_update_bits(sai->regmap, FSL_SAI_TCSR,\r\nFSL_SAI_CSR_TERE, FSL_SAI_CSR_TERE);\r\nregmap_update_bits(sai->regmap, FSL_SAI_xCSR(tx),\r\nFSL_SAI_CSR_xIE_MASK, FSL_SAI_FLAGS);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nregmap_update_bits(sai->regmap, FSL_SAI_xCSR(tx),\r\nFSL_SAI_CSR_FRDE, 0);\r\nregmap_update_bits(sai->regmap, FSL_SAI_xCSR(tx),\r\nFSL_SAI_CSR_xIE_MASK, 0);\r\nregmap_read(sai->regmap, FSL_SAI_xCSR(!tx), &xcsr);\r\nif (!(xcsr & FSL_SAI_CSR_FRDE)) {\r\nregmap_update_bits(sai->regmap, FSL_SAI_TCSR,\r\nFSL_SAI_CSR_TERE, 0);\r\nregmap_update_bits(sai->regmap, FSL_SAI_RCSR,\r\nFSL_SAI_CSR_TERE, 0);\r\ndo {\r\nudelay(10);\r\nregmap_read(sai->regmap, FSL_SAI_xCSR(tx), &xcsr);\r\n} while (--count && xcsr & FSL_SAI_CSR_TERE);\r\nregmap_update_bits(sai->regmap, FSL_SAI_TCSR,\r\nFSL_SAI_CSR_FR, FSL_SAI_CSR_FR);\r\nregmap_update_bits(sai->regmap, FSL_SAI_RCSR,\r\nFSL_SAI_CSR_FR, FSL_SAI_CSR_FR);\r\nif (!sai->is_slave_mode) {\r\nregmap_write(sai->regmap,\r\nFSL_SAI_TCSR, FSL_SAI_CSR_SR);\r\nregmap_write(sai->regmap,\r\nFSL_SAI_RCSR, FSL_SAI_CSR_SR);\r\nregmap_write(sai->regmap, FSL_SAI_TCSR, 0);\r\nregmap_write(sai->regmap, FSL_SAI_RCSR, 0);\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fsl_sai_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *cpu_dai)\r\n{\r\nstruct fsl_sai *sai = snd_soc_dai_get_drvdata(cpu_dai);\r\nbool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\r\nstruct device *dev = &sai->pdev->dev;\r\nint ret;\r\nret = clk_prepare_enable(sai->bus_clk);\r\nif (ret) {\r\ndev_err(dev, "failed to enable bus clock: %d\n", ret);\r\nreturn ret;\r\n}\r\nregmap_update_bits(sai->regmap, FSL_SAI_xCR3(tx), FSL_SAI_CR3_TRCE,\r\nFSL_SAI_CR3_TRCE);\r\nret = snd_pcm_hw_constraint_list(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_RATE, &fsl_sai_rate_constraints);\r\nreturn ret;\r\n}\r\nstatic void fsl_sai_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *cpu_dai)\r\n{\r\nstruct fsl_sai *sai = snd_soc_dai_get_drvdata(cpu_dai);\r\nbool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\r\nregmap_update_bits(sai->regmap, FSL_SAI_xCR3(tx), FSL_SAI_CR3_TRCE, 0);\r\nclk_disable_unprepare(sai->bus_clk);\r\n}\r\nstatic int fsl_sai_dai_probe(struct snd_soc_dai *cpu_dai)\r\n{\r\nstruct fsl_sai *sai = dev_get_drvdata(cpu_dai->dev);\r\nregmap_write(sai->regmap, FSL_SAI_TCSR, FSL_SAI_CSR_SR);\r\nregmap_write(sai->regmap, FSL_SAI_RCSR, FSL_SAI_CSR_SR);\r\nregmap_write(sai->regmap, FSL_SAI_TCSR, 0);\r\nregmap_write(sai->regmap, FSL_SAI_RCSR, 0);\r\nregmap_update_bits(sai->regmap, FSL_SAI_TCR1, FSL_SAI_CR1_RFW_MASK,\r\nFSL_SAI_MAXBURST_TX * 2);\r\nregmap_update_bits(sai->regmap, FSL_SAI_RCR1, FSL_SAI_CR1_RFW_MASK,\r\nFSL_SAI_MAXBURST_RX - 1);\r\nsnd_soc_dai_init_dma_data(cpu_dai, &sai->dma_params_tx,\r\n&sai->dma_params_rx);\r\nsnd_soc_dai_set_drvdata(cpu_dai, sai);\r\nreturn 0;\r\n}\r\nstatic bool fsl_sai_readable_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase FSL_SAI_TCSR:\r\ncase FSL_SAI_TCR1:\r\ncase FSL_SAI_TCR2:\r\ncase FSL_SAI_TCR3:\r\ncase FSL_SAI_TCR4:\r\ncase FSL_SAI_TCR5:\r\ncase FSL_SAI_TFR:\r\ncase FSL_SAI_TMR:\r\ncase FSL_SAI_RCSR:\r\ncase FSL_SAI_RCR1:\r\ncase FSL_SAI_RCR2:\r\ncase FSL_SAI_RCR3:\r\ncase FSL_SAI_RCR4:\r\ncase FSL_SAI_RCR5:\r\ncase FSL_SAI_RDR:\r\ncase FSL_SAI_RFR:\r\ncase FSL_SAI_RMR:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool fsl_sai_volatile_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase FSL_SAI_TCSR:\r\ncase FSL_SAI_RCSR:\r\ncase FSL_SAI_TFR:\r\ncase FSL_SAI_RFR:\r\ncase FSL_SAI_RDR:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool fsl_sai_writeable_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase FSL_SAI_TCSR:\r\ncase FSL_SAI_TCR1:\r\ncase FSL_SAI_TCR2:\r\ncase FSL_SAI_TCR3:\r\ncase FSL_SAI_TCR4:\r\ncase FSL_SAI_TCR5:\r\ncase FSL_SAI_TDR:\r\ncase FSL_SAI_TMR:\r\ncase FSL_SAI_RCSR:\r\ncase FSL_SAI_RCR1:\r\ncase FSL_SAI_RCR2:\r\ncase FSL_SAI_RCR3:\r\ncase FSL_SAI_RCR4:\r\ncase FSL_SAI_RCR5:\r\ncase FSL_SAI_RMR:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int fsl_sai_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct fsl_sai *sai;\r\nstruct regmap *gpr;\r\nstruct resource *res;\r\nvoid __iomem *base;\r\nchar tmp[8];\r\nint irq, ret, i;\r\nint index;\r\nsai = devm_kzalloc(&pdev->dev, sizeof(*sai), GFP_KERNEL);\r\nif (!sai)\r\nreturn -ENOMEM;\r\nsai->pdev = pdev;\r\nif (of_device_is_compatible(np, "fsl,imx6sx-sai") ||\r\nof_device_is_compatible(np, "fsl,imx6ul-sai"))\r\nsai->sai_on_imx = true;\r\nsai->is_lsb_first = of_property_read_bool(np, "lsb-first");\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\nsai->regmap = devm_regmap_init_mmio_clk(&pdev->dev,\r\n"bus", base, &fsl_sai_regmap_config);\r\nif (IS_ERR(sai->regmap))\r\nsai->regmap = devm_regmap_init_mmio_clk(&pdev->dev,\r\n"sai", base, &fsl_sai_regmap_config);\r\nif (IS_ERR(sai->regmap)) {\r\ndev_err(&pdev->dev, "regmap init failed\n");\r\nreturn PTR_ERR(sai->regmap);\r\n}\r\nsai->bus_clk = devm_clk_get(&pdev->dev, "bus");\r\nif (IS_ERR(sai->bus_clk)) {\r\ndev_err(&pdev->dev, "failed to get bus clock: %ld\n",\r\nPTR_ERR(sai->bus_clk));\r\nsai->bus_clk = NULL;\r\n}\r\nsai->mclk_clk[0] = sai->bus_clk;\r\nfor (i = 1; i < FSL_SAI_MCLK_MAX; i++) {\r\nsprintf(tmp, "mclk%d", i);\r\nsai->mclk_clk[i] = devm_clk_get(&pdev->dev, tmp);\r\nif (IS_ERR(sai->mclk_clk[i])) {\r\ndev_err(&pdev->dev, "failed to get mclk%d clock: %ld\n",\r\ni + 1, PTR_ERR(sai->mclk_clk[i]));\r\nsai->mclk_clk[i] = NULL;\r\n}\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "no irq for node %s\n", pdev->name);\r\nreturn irq;\r\n}\r\nret = devm_request_irq(&pdev->dev, irq, fsl_sai_isr, 0, np->name, sai);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to claim irq %u\n", irq);\r\nreturn ret;\r\n}\r\nsai->synchronous[RX] = true;\r\nsai->synchronous[TX] = false;\r\nfsl_sai_dai.symmetric_rates = 1;\r\nfsl_sai_dai.symmetric_channels = 1;\r\nfsl_sai_dai.symmetric_samplebits = 1;\r\nif (of_find_property(np, "fsl,sai-synchronous-rx", NULL) &&\r\nof_find_property(np, "fsl,sai-asynchronous", NULL)) {\r\ndev_err(&pdev->dev, "invalid binding for synchronous mode\n");\r\nreturn -EINVAL;\r\n}\r\nif (of_find_property(np, "fsl,sai-synchronous-rx", NULL)) {\r\nsai->synchronous[RX] = false;\r\nsai->synchronous[TX] = true;\r\n} else if (of_find_property(np, "fsl,sai-asynchronous", NULL)) {\r\nsai->synchronous[RX] = false;\r\nsai->synchronous[TX] = false;\r\nfsl_sai_dai.symmetric_rates = 0;\r\nfsl_sai_dai.symmetric_channels = 0;\r\nfsl_sai_dai.symmetric_samplebits = 0;\r\n}\r\nif (of_find_property(np, "fsl,sai-mclk-direction-output", NULL) &&\r\nof_device_is_compatible(np, "fsl,imx6ul-sai")) {\r\ngpr = syscon_regmap_lookup_by_compatible("fsl,imx6ul-iomuxc-gpr");\r\nif (IS_ERR(gpr)) {\r\ndev_err(&pdev->dev, "cannot find iomuxc registers\n");\r\nreturn PTR_ERR(gpr);\r\n}\r\nindex = of_alias_get_id(np, "sai");\r\nif (index < 0)\r\nreturn index;\r\nregmap_update_bits(gpr, IOMUXC_GPR1, MCLK_DIR(index),\r\nMCLK_DIR(index));\r\n}\r\nsai->dma_params_rx.addr = res->start + FSL_SAI_RDR;\r\nsai->dma_params_tx.addr = res->start + FSL_SAI_TDR;\r\nsai->dma_params_rx.maxburst = FSL_SAI_MAXBURST_RX;\r\nsai->dma_params_tx.maxburst = FSL_SAI_MAXBURST_TX;\r\nplatform_set_drvdata(pdev, sai);\r\nret = devm_snd_soc_register_component(&pdev->dev, &fsl_component,\r\n&fsl_sai_dai, 1);\r\nif (ret)\r\nreturn ret;\r\nif (sai->sai_on_imx)\r\nreturn imx_pcm_dma_init(pdev, IMX_SAI_DMABUF_SIZE);\r\nelse\r\nreturn devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);\r\n}\r\nstatic int fsl_sai_suspend(struct device *dev)\r\n{\r\nstruct fsl_sai *sai = dev_get_drvdata(dev);\r\nregcache_cache_only(sai->regmap, true);\r\nregcache_mark_dirty(sai->regmap);\r\nreturn 0;\r\n}\r\nstatic int fsl_sai_resume(struct device *dev)\r\n{\r\nstruct fsl_sai *sai = dev_get_drvdata(dev);\r\nregcache_cache_only(sai->regmap, false);\r\nregmap_write(sai->regmap, FSL_SAI_TCSR, FSL_SAI_CSR_SR);\r\nregmap_write(sai->regmap, FSL_SAI_RCSR, FSL_SAI_CSR_SR);\r\nusleep_range(1000, 2000);\r\nregmap_write(sai->regmap, FSL_SAI_TCSR, 0);\r\nregmap_write(sai->regmap, FSL_SAI_RCSR, 0);\r\nreturn regcache_sync(sai->regmap);\r\n}
