static inline struct snd_soc_dai *get_codec_dai(struct snd_soc_card *card)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd;\r\nlist_for_each_entry(rtd, &card->rtd_list, list) {\r\nif (!strncmp(rtd->codec_dai->name, CODEC_DAI1,\r\nstrlen(CODEC_DAI1)))\r\nreturn rtd->codec_dai;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int byt_cht_es8316_init(struct snd_soc_pcm_runtime *runtime)\r\n{\r\nstruct snd_soc_card *card = runtime->card;\r\nstruct byt_cht_es8316_private *priv = snd_soc_card_get_drvdata(card);\r\nint ret;\r\ncard->dapm.idle_bias_off = true;\r\nret = clk_prepare_enable(priv->mclk);\r\nif (!ret)\r\nclk_disable_unprepare(priv->mclk);\r\nret = clk_set_rate(priv->mclk, 19200000);\r\nif (ret)\r\ndev_err(card->dev, "unable to set MCLK rate\n");\r\nret = clk_prepare_enable(priv->mclk);\r\nif (ret)\r\ndev_err(card->dev, "unable to enable MCLK\n");\r\nret = snd_soc_dai_set_sysclk(runtime->codec_dai, 0, 19200000,\r\nSND_SOC_CLOCK_IN);\r\nif (ret < 0) {\r\ndev_err(card->dev, "can't set codec clock %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int byt_cht_es8316_codec_fixup(struct snd_soc_pcm_runtime *rtd,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct snd_interval *rate = hw_param_interval(params,\r\nSNDRV_PCM_HW_PARAM_RATE);\r\nstruct snd_interval *channels = hw_param_interval(params,\r\nSNDRV_PCM_HW_PARAM_CHANNELS);\r\nint ret;\r\nrate->min = rate->max = 48000;\r\nchannels->min = channels->max = 2;\r\nparams_set_format(params, SNDRV_PCM_FORMAT_S24_LE);\r\nret = snd_soc_dai_set_fmt(rtd->cpu_dai,\r\nSND_SOC_DAIFMT_I2S |\r\nSND_SOC_DAIFMT_NB_NF |\r\nSND_SOC_DAIFMT_CBS_CFS\r\n);\r\nif (ret < 0) {\r\ndev_err(rtd->dev, "can't set format to I2S, err %d\n", ret);\r\nreturn ret;\r\n}\r\nret = snd_soc_dai_set_tdm_slot(rtd->cpu_dai, 0x3, 0x3, 2, 24);\r\nif (ret < 0) {\r\ndev_err(rtd->dev, "can't set I2S config, err %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int byt_cht_es8316_aif1_startup(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_pcm_hw_constraint_single(substream->runtime,\r\nSNDRV_PCM_HW_PARAM_RATE, 48000);\r\n}\r\nstatic int snd_byt_cht_es8316_mc_probe(struct platform_device *pdev)\r\n{\r\nint ret = 0;\r\nstruct byt_cht_es8316_private *priv;\r\npriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_ATOMIC);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nbyt_cht_es8316_card.dev = &pdev->dev;\r\nsnd_soc_card_set_drvdata(&byt_cht_es8316_card, priv);\r\npriv->mclk = devm_clk_get(&pdev->dev, "pmc_plt_clk_3");\r\nif (IS_ERR(priv->mclk)) {\r\nret = PTR_ERR(priv->mclk);\r\ndev_err(&pdev->dev,\r\n"Failed to get MCLK from pmc_plt_clk_3: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nret = devm_snd_soc_register_card(&pdev->dev, &byt_cht_es8316_card);\r\nif (ret) {\r\ndev_err(&pdev->dev, "snd_soc_register_card failed %d\n", ret);\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, &byt_cht_es8316_card);\r\nreturn ret;\r\n}
