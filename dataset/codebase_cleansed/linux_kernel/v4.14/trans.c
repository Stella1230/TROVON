int qtnf_trans_send_cmd_with_resp(struct qtnf_bus *bus, struct sk_buff *cmd_skb,\r\nstruct sk_buff **response_skb)\r\n{\r\nstruct qtnf_cmd_ctl_node *ctl_node = &bus->trans.curr_cmd;\r\nstruct qlink_cmd *cmd = (void *)cmd_skb->data;\r\nint ret = 0;\r\nlong status;\r\nbool resp_not_handled = true;\r\nstruct sk_buff *resp_skb = NULL;\r\nif (unlikely(!response_skb))\r\nreturn -EFAULT;\r\nspin_lock(&ctl_node->resp_lock);\r\nctl_node->seq_num++;\r\ncmd->seq_num = cpu_to_le16(ctl_node->seq_num);\r\nWARN(ctl_node->resp_skb, "qtnfmac: response skb not empty\n");\r\nctl_node->waiting_for_resp = true;\r\nspin_unlock(&ctl_node->resp_lock);\r\nret = qtnf_bus_control_tx(bus, cmd_skb);\r\ndev_kfree_skb(cmd_skb);\r\nif (unlikely(ret))\r\ngoto out;\r\nstatus = wait_for_completion_interruptible_timeout(\r\n&ctl_node->cmd_resp_completion,\r\nQTNF_DEF_SYNC_CMD_TIMEOUT);\r\nspin_lock(&ctl_node->resp_lock);\r\nresp_not_handled = ctl_node->waiting_for_resp;\r\nresp_skb = ctl_node->resp_skb;\r\nctl_node->resp_skb = NULL;\r\nctl_node->waiting_for_resp = false;\r\nspin_unlock(&ctl_node->resp_lock);\r\nif (unlikely(status <= 0)) {\r\nif (status == 0) {\r\nret = -ETIMEDOUT;\r\npr_err("response timeout\n");\r\n} else {\r\nret = -EINTR;\r\npr_debug("interrupted\n");\r\n}\r\n}\r\nif (unlikely(!resp_skb || resp_not_handled)) {\r\nif (!ret)\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nret = 0;\r\n*response_skb = resp_skb;\r\nout:\r\nif (unlikely(resp_skb && resp_not_handled))\r\ndev_kfree_skb(resp_skb);\r\nreturn ret;\r\n}\r\nstatic void qtnf_trans_signal_cmdresp(struct qtnf_bus *bus, struct sk_buff *skb)\r\n{\r\nstruct qtnf_cmd_ctl_node *ctl_node = &bus->trans.curr_cmd;\r\nconst struct qlink_resp *resp = (const struct qlink_resp *)skb->data;\r\nconst u16 recvd_seq_num = le16_to_cpu(resp->seq_num);\r\nspin_lock(&ctl_node->resp_lock);\r\nif (unlikely(!ctl_node->waiting_for_resp)) {\r\npr_err("unexpected response\n");\r\ngoto out_err;\r\n}\r\nif (unlikely(recvd_seq_num != ctl_node->seq_num)) {\r\npr_err("seq num mismatch\n");\r\ngoto out_err;\r\n}\r\nctl_node->resp_skb = skb;\r\nctl_node->waiting_for_resp = false;\r\nspin_unlock(&ctl_node->resp_lock);\r\ncomplete(&ctl_node->cmd_resp_completion);\r\nreturn;\r\nout_err:\r\nspin_unlock(&ctl_node->resp_lock);\r\ndev_kfree_skb(skb);\r\n}\r\nstatic int qtnf_trans_event_enqueue(struct qtnf_bus *bus, struct sk_buff *skb)\r\n{\r\nstruct qtnf_qlink_transport *trans = &bus->trans;\r\nif (likely(skb_queue_len(&trans->event_queue) <\r\ntrans->event_queue_max_len)) {\r\nskb_queue_tail(&trans->event_queue, skb);\r\nqueue_work(bus->workqueue, &bus->event_work);\r\n} else {\r\npr_warn("event dropped due to queue overflow\n");\r\ndev_kfree_skb(skb);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nvoid qtnf_trans_init(struct qtnf_bus *bus)\r\n{\r\nstruct qtnf_qlink_transport *trans = &bus->trans;\r\ninit_completion(&trans->curr_cmd.cmd_resp_completion);\r\nspin_lock_init(&trans->curr_cmd.resp_lock);\r\nspin_lock(&trans->curr_cmd.resp_lock);\r\ntrans->curr_cmd.seq_num = 0;\r\ntrans->curr_cmd.waiting_for_resp = false;\r\ntrans->curr_cmd.resp_skb = NULL;\r\nspin_unlock(&trans->curr_cmd.resp_lock);\r\nskb_queue_head_init(&trans->event_queue);\r\ntrans->event_queue_max_len = QTNF_MAX_EVENT_QUEUE_LEN;\r\n}\r\nstatic void qtnf_trans_free_events(struct qtnf_bus *bus)\r\n{\r\nstruct sk_buff_head *event_queue = &bus->trans.event_queue;\r\nstruct sk_buff *current_event_skb = skb_dequeue(event_queue);\r\nwhile (current_event_skb) {\r\ndev_kfree_skb_any(current_event_skb);\r\ncurrent_event_skb = skb_dequeue(event_queue);\r\n}\r\n}\r\nvoid qtnf_trans_free(struct qtnf_bus *bus)\r\n{\r\nif (!bus) {\r\npr_err("invalid bus pointer\n");\r\nreturn;\r\n}\r\nqtnf_trans_free_events(bus);\r\n}\r\nint qtnf_trans_handle_rx_ctl_packet(struct qtnf_bus *bus, struct sk_buff *skb)\r\n{\r\nconst struct qlink_msg_header *header = (void *)skb->data;\r\nint ret = -1;\r\nif (unlikely(skb->len < sizeof(*header))) {\r\npr_warn("packet is too small: %u\n", skb->len);\r\ndev_kfree_skb(skb);\r\nreturn -EINVAL;\r\n}\r\nif (unlikely(skb->len != le16_to_cpu(header->len))) {\r\npr_warn("cmd reply length mismatch: %u != %u\n",\r\nskb->len, le16_to_cpu(header->len));\r\ndev_kfree_skb(skb);\r\nreturn -EFAULT;\r\n}\r\nswitch (le16_to_cpu(header->type)) {\r\ncase QLINK_MSG_TYPE_CMDRSP:\r\nif (unlikely(skb->len < sizeof(struct qlink_cmd))) {\r\npr_warn("cmd reply too short: %u\n", skb->len);\r\ndev_kfree_skb(skb);\r\nbreak;\r\n}\r\nqtnf_trans_signal_cmdresp(bus, skb);\r\nbreak;\r\ncase QLINK_MSG_TYPE_EVENT:\r\nif (unlikely(skb->len < sizeof(struct qlink_event))) {\r\npr_warn("event too short: %u\n", skb->len);\r\ndev_kfree_skb(skb);\r\nbreak;\r\n}\r\nret = qtnf_trans_event_enqueue(bus, skb);\r\nbreak;\r\ndefault:\r\npr_warn("unknown packet type: %x\n", le16_to_cpu(header->type));\r\ndev_kfree_skb(skb);\r\nbreak;\r\n}\r\nreturn ret;\r\n}
