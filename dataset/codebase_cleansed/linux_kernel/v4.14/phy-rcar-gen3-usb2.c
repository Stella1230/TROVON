static void rcar_gen3_phy_usb2_work(struct work_struct *work)\r\n{\r\nstruct rcar_gen3_chan *ch = container_of(work, struct rcar_gen3_chan,\r\nwork);\r\nif (ch->extcon_host) {\r\nextcon_set_state_sync(ch->extcon, EXTCON_USB_HOST, true);\r\nextcon_set_state_sync(ch->extcon, EXTCON_USB, false);\r\n} else {\r\nextcon_set_state_sync(ch->extcon, EXTCON_USB_HOST, false);\r\nextcon_set_state_sync(ch->extcon, EXTCON_USB, true);\r\n}\r\n}\r\nstatic void rcar_gen3_set_host_mode(struct rcar_gen3_chan *ch, int host)\r\n{\r\nvoid __iomem *usb2_base = ch->base;\r\nu32 val = readl(usb2_base + USB2_COMMCTRL);\r\ndev_vdbg(&ch->phy->dev, "%s: %08x, %d\n", __func__, val, host);\r\nif (host)\r\nval &= ~USB2_COMMCTRL_OTG_PERI;\r\nelse\r\nval |= USB2_COMMCTRL_OTG_PERI;\r\nwritel(val, usb2_base + USB2_COMMCTRL);\r\n}\r\nstatic void rcar_gen3_set_linectrl(struct rcar_gen3_chan *ch, int dp, int dm)\r\n{\r\nvoid __iomem *usb2_base = ch->base;\r\nu32 val = readl(usb2_base + USB2_LINECTRL1);\r\ndev_vdbg(&ch->phy->dev, "%s: %08x, %d, %d\n", __func__, val, dp, dm);\r\nval &= ~(USB2_LINECTRL1_DP_RPD | USB2_LINECTRL1_DM_RPD);\r\nif (dp)\r\nval |= USB2_LINECTRL1_DP_RPD;\r\nif (dm)\r\nval |= USB2_LINECTRL1_DM_RPD;\r\nwritel(val, usb2_base + USB2_LINECTRL1);\r\n}\r\nstatic void rcar_gen3_enable_vbus_ctrl(struct rcar_gen3_chan *ch, int vbus)\r\n{\r\nvoid __iomem *usb2_base = ch->base;\r\nu32 val = readl(usb2_base + USB2_ADPCTRL);\r\ndev_vdbg(&ch->phy->dev, "%s: %08x, %d\n", __func__, val, vbus);\r\nif (vbus)\r\nval |= USB2_ADPCTRL_DRVVBUS;\r\nelse\r\nval &= ~USB2_ADPCTRL_DRVVBUS;\r\nwritel(val, usb2_base + USB2_ADPCTRL);\r\n}\r\nstatic void rcar_gen3_init_for_host(struct rcar_gen3_chan *ch)\r\n{\r\nrcar_gen3_set_linectrl(ch, 1, 1);\r\nrcar_gen3_set_host_mode(ch, 1);\r\nrcar_gen3_enable_vbus_ctrl(ch, 1);\r\nch->extcon_host = true;\r\nschedule_work(&ch->work);\r\n}\r\nstatic void rcar_gen3_init_for_peri(struct rcar_gen3_chan *ch)\r\n{\r\nrcar_gen3_set_linectrl(ch, 0, 1);\r\nrcar_gen3_set_host_mode(ch, 0);\r\nrcar_gen3_enable_vbus_ctrl(ch, 0);\r\nch->extcon_host = false;\r\nschedule_work(&ch->work);\r\n}\r\nstatic void rcar_gen3_init_for_b_host(struct rcar_gen3_chan *ch)\r\n{\r\nvoid __iomem *usb2_base = ch->base;\r\nu32 val;\r\nval = readl(usb2_base + USB2_LINECTRL1);\r\nwritel(val | USB2_LINECTRL1_OPMODE_NODRV, usb2_base + USB2_LINECTRL1);\r\nrcar_gen3_set_linectrl(ch, 1, 1);\r\nrcar_gen3_set_host_mode(ch, 1);\r\nrcar_gen3_enable_vbus_ctrl(ch, 0);\r\nval = readl(usb2_base + USB2_LINECTRL1);\r\nwritel(val & ~USB2_LINECTRL1_OPMODE_NODRV, usb2_base + USB2_LINECTRL1);\r\n}\r\nstatic void rcar_gen3_init_for_a_peri(struct rcar_gen3_chan *ch)\r\n{\r\nrcar_gen3_set_linectrl(ch, 0, 1);\r\nrcar_gen3_set_host_mode(ch, 0);\r\nrcar_gen3_enable_vbus_ctrl(ch, 1);\r\n}\r\nstatic void rcar_gen3_init_from_a_peri_to_a_host(struct rcar_gen3_chan *ch)\r\n{\r\nvoid __iomem *usb2_base = ch->base;\r\nu32 val;\r\nval = readl(usb2_base + USB2_OBINTEN);\r\nwritel(val & ~USB2_OBINT_BITS, usb2_base + USB2_OBINTEN);\r\nrcar_gen3_enable_vbus_ctrl(ch, 0);\r\nrcar_gen3_init_for_host(ch);\r\nwritel(val | USB2_OBINT_BITS, usb2_base + USB2_OBINTEN);\r\n}\r\nstatic bool rcar_gen3_check_id(struct rcar_gen3_chan *ch)\r\n{\r\nreturn !!(readl(ch->base + USB2_ADPCTRL) & USB2_ADPCTRL_IDDIG);\r\n}\r\nstatic void rcar_gen3_device_recognition(struct rcar_gen3_chan *ch)\r\n{\r\nif (!rcar_gen3_check_id(ch))\r\nrcar_gen3_init_for_host(ch);\r\nelse\r\nrcar_gen3_init_for_peri(ch);\r\n}\r\nstatic bool rcar_gen3_is_host(struct rcar_gen3_chan *ch)\r\n{\r\nreturn !(readl(ch->base + USB2_COMMCTRL) & USB2_COMMCTRL_OTG_PERI);\r\n}\r\nstatic ssize_t role_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct rcar_gen3_chan *ch = dev_get_drvdata(dev);\r\nbool is_b_device, is_host, new_mode_is_host;\r\nif (!ch->has_otg || !ch->phy->init_count)\r\nreturn -EIO;\r\nis_b_device = rcar_gen3_check_id(ch);\r\nis_host = rcar_gen3_is_host(ch);\r\nif (!strncmp(buf, "host", strlen("host")))\r\nnew_mode_is_host = true;\r\nelse if (!strncmp(buf, "peripheral", strlen("peripheral")))\r\nnew_mode_is_host = false;\r\nelse\r\nreturn -EINVAL;\r\nif (is_host == new_mode_is_host)\r\nreturn -EINVAL;\r\nif (new_mode_is_host) {\r\nif (!is_b_device)\r\nrcar_gen3_init_from_a_peri_to_a_host(ch);\r\nelse\r\nrcar_gen3_init_for_b_host(ch);\r\n} else {\r\nif (!is_b_device)\r\nrcar_gen3_init_for_a_peri(ch);\r\nelse\r\nrcar_gen3_init_for_peri(ch);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t role_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct rcar_gen3_chan *ch = dev_get_drvdata(dev);\r\nif (!ch->has_otg || !ch->phy->init_count)\r\nreturn -EIO;\r\nreturn sprintf(buf, "%s\n", rcar_gen3_is_host(ch) ? "host" :\r\n"peripheral");\r\n}\r\nstatic void rcar_gen3_init_otg(struct rcar_gen3_chan *ch)\r\n{\r\nvoid __iomem *usb2_base = ch->base;\r\nu32 val;\r\nval = readl(usb2_base + USB2_VBCTRL);\r\nwritel(val | USB2_VBCTRL_DRVVBUSSEL, usb2_base + USB2_VBCTRL);\r\nwritel(USB2_OBINT_BITS, usb2_base + USB2_OBINTSTA);\r\nval = readl(usb2_base + USB2_OBINTEN);\r\nwritel(val | USB2_OBINT_BITS, usb2_base + USB2_OBINTEN);\r\nval = readl(usb2_base + USB2_ADPCTRL);\r\nwritel(val | USB2_ADPCTRL_IDPULLUP, usb2_base + USB2_ADPCTRL);\r\nval = readl(usb2_base + USB2_LINECTRL1);\r\nrcar_gen3_set_linectrl(ch, 0, 0);\r\nwritel(val | USB2_LINECTRL1_DPRPD_EN | USB2_LINECTRL1_DMRPD_EN,\r\nusb2_base + USB2_LINECTRL1);\r\nrcar_gen3_device_recognition(ch);\r\n}\r\nstatic int rcar_gen3_phy_usb2_init(struct phy *p)\r\n{\r\nstruct rcar_gen3_chan *channel = phy_get_drvdata(p);\r\nvoid __iomem *usb2_base = channel->base;\r\nwritel(USB2_INT_ENABLE_INIT, usb2_base + USB2_INT_ENABLE);\r\nwritel(USB2_SPD_RSM_TIMSET_INIT, usb2_base + USB2_SPD_RSM_TIMSET);\r\nwritel(USB2_OC_TIMSET_INIT, usb2_base + USB2_OC_TIMSET);\r\nif (channel->has_otg)\r\nrcar_gen3_init_otg(channel);\r\nreturn 0;\r\n}\r\nstatic int rcar_gen3_phy_usb2_exit(struct phy *p)\r\n{\r\nstruct rcar_gen3_chan *channel = phy_get_drvdata(p);\r\nwritel(0, channel->base + USB2_INT_ENABLE);\r\nreturn 0;\r\n}\r\nstatic int rcar_gen3_phy_usb2_power_on(struct phy *p)\r\n{\r\nstruct rcar_gen3_chan *channel = phy_get_drvdata(p);\r\nvoid __iomem *usb2_base = channel->base;\r\nu32 val;\r\nint ret;\r\nif (channel->vbus) {\r\nret = regulator_enable(channel->vbus);\r\nif (ret)\r\nreturn ret;\r\n}\r\nval = readl(usb2_base + USB2_USBCTR);\r\nval |= USB2_USBCTR_PLL_RST;\r\nwritel(val, usb2_base + USB2_USBCTR);\r\nval &= ~USB2_USBCTR_PLL_RST;\r\nwritel(val, usb2_base + USB2_USBCTR);\r\nreturn 0;\r\n}\r\nstatic int rcar_gen3_phy_usb2_power_off(struct phy *p)\r\n{\r\nstruct rcar_gen3_chan *channel = phy_get_drvdata(p);\r\nint ret = 0;\r\nif (channel->vbus)\r\nret = regulator_disable(channel->vbus);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t rcar_gen3_phy_usb2_irq(int irq, void *_ch)\r\n{\r\nstruct rcar_gen3_chan *ch = _ch;\r\nvoid __iomem *usb2_base = ch->base;\r\nu32 status = readl(usb2_base + USB2_OBINTSTA);\r\nirqreturn_t ret = IRQ_NONE;\r\nif (status & USB2_OBINT_BITS) {\r\ndev_vdbg(&ch->phy->dev, "%s: %08x\n", __func__, status);\r\nwritel(USB2_OBINT_BITS, usb2_base + USB2_OBINTSTA);\r\nrcar_gen3_device_recognition(ch);\r\nret = IRQ_HANDLED;\r\n}\r\nreturn ret;\r\n}\r\nstatic int rcar_gen3_phy_usb2_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct rcar_gen3_chan *channel;\r\nstruct phy_provider *provider;\r\nstruct resource *res;\r\nint irq, ret = 0;\r\nif (!dev->of_node) {\r\ndev_err(dev, "This driver needs device tree\n");\r\nreturn -EINVAL;\r\n}\r\nchannel = devm_kzalloc(dev, sizeof(*channel), GFP_KERNEL);\r\nif (!channel)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nchannel->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(channel->base))\r\nreturn PTR_ERR(channel->base);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq >= 0) {\r\nint ret;\r\nINIT_WORK(&channel->work, rcar_gen3_phy_usb2_work);\r\nirq = devm_request_irq(dev, irq, rcar_gen3_phy_usb2_irq,\r\nIRQF_SHARED, dev_name(dev), channel);\r\nif (irq < 0)\r\ndev_err(dev, "No irq handler (%d)\n", irq);\r\nchannel->has_otg = true;\r\nchannel->extcon = devm_extcon_dev_allocate(dev,\r\nrcar_gen3_phy_cable);\r\nif (IS_ERR(channel->extcon))\r\nreturn PTR_ERR(channel->extcon);\r\nret = devm_extcon_dev_register(dev, channel->extcon);\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to register extcon\n");\r\nreturn ret;\r\n}\r\n}\r\npm_runtime_enable(dev);\r\nchannel->phy = devm_phy_create(dev, NULL, &rcar_gen3_phy_usb2_ops);\r\nif (IS_ERR(channel->phy)) {\r\ndev_err(dev, "Failed to create USB2 PHY\n");\r\nret = PTR_ERR(channel->phy);\r\ngoto error;\r\n}\r\nchannel->vbus = devm_regulator_get_optional(dev, "vbus");\r\nif (IS_ERR(channel->vbus)) {\r\nif (PTR_ERR(channel->vbus) == -EPROBE_DEFER) {\r\nret = PTR_ERR(channel->vbus);\r\ngoto error;\r\n}\r\nchannel->vbus = NULL;\r\n}\r\nplatform_set_drvdata(pdev, channel);\r\nphy_set_drvdata(channel->phy, channel);\r\nprovider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\r\nif (IS_ERR(provider)) {\r\ndev_err(dev, "Failed to register PHY provider\n");\r\nret = PTR_ERR(provider);\r\ngoto error;\r\n} else if (channel->has_otg) {\r\nint ret;\r\nret = device_create_file(dev, &dev_attr_role);\r\nif (ret < 0)\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\npm_runtime_disable(dev);\r\nreturn ret;\r\n}\r\nstatic int rcar_gen3_phy_usb2_remove(struct platform_device *pdev)\r\n{\r\nstruct rcar_gen3_chan *channel = platform_get_drvdata(pdev);\r\nif (channel->has_otg)\r\ndevice_remove_file(&pdev->dev, &dev_attr_role);\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}
