void scif_recv_munmap(struct scif_dev *scifdev, struct scifmsg *msg)\r\n{\r\nstruct scif_rma_req req;\r\nstruct scif_window *window = NULL;\r\nstruct scif_window *recv_window =\r\n(struct scif_window *)msg->payload[0];\r\nstruct scif_endpt *ep;\r\nep = (struct scif_endpt *)recv_window->ep;\r\nreq.out_window = &window;\r\nreq.offset = recv_window->offset;\r\nreq.prot = recv_window->prot;\r\nreq.nr_bytes = recv_window->nr_pages << PAGE_SHIFT;\r\nreq.type = SCIF_WINDOW_FULL;\r\nreq.head = &ep->rma_info.reg_list;\r\nmsg->payload[0] = ep->remote_ep;\r\nmutex_lock(&ep->rma_info.rma_lock);\r\nif (scif_query_window(&req)) {\r\ndev_err(&scifdev->sdev->dev,\r\n"%s %d -ENXIO\n", __func__, __LINE__);\r\nmsg->uop = SCIF_UNREGISTER_ACK;\r\ngoto error;\r\n}\r\nscif_put_window(window, window->nr_pages);\r\nif (!window->ref_count) {\r\natomic_inc(&ep->rma_info.tw_refcount);\r\nep->rma_info.async_list_del = 1;\r\nlist_del_init(&window->list);\r\nscif_free_window_offset(ep, window, window->offset);\r\n}\r\nerror:\r\nmutex_unlock(&ep->rma_info.rma_lock);\r\nif (window && !window->ref_count)\r\nscif_queue_for_cleanup(window, &scif_info.rma);\r\n}\r\nstatic void __scif_zap_mmaps(struct scif_endpt *ep)\r\n{\r\nstruct list_head *item;\r\nstruct scif_vma_info *info;\r\nstruct vm_area_struct *vma;\r\nunsigned long size;\r\nspin_lock(&ep->lock);\r\nlist_for_each(item, &ep->rma_info.vma_list) {\r\ninfo = list_entry(item, struct scif_vma_info, list);\r\nvma = info->vma;\r\nsize = vma->vm_end - vma->vm_start;\r\nzap_vma_ptes(vma, vma->vm_start, size);\r\ndev_dbg(scif_info.mdev.this_device,\r\n"%s ep %p zap vma %p size 0x%lx\n",\r\n__func__, ep, info->vma, size);\r\n}\r\nspin_unlock(&ep->lock);\r\n}\r\nstatic void _scif_zap_mmaps(int node, struct list_head *head)\r\n{\r\nstruct scif_endpt *ep;\r\nstruct list_head *item;\r\nmutex_lock(&scif_info.connlock);\r\nlist_for_each(item, head) {\r\nep = list_entry(item, struct scif_endpt, list);\r\nif (ep->remote_dev->node == node)\r\n__scif_zap_mmaps(ep);\r\n}\r\nmutex_unlock(&scif_info.connlock);\r\n}\r\nvoid scif_zap_mmaps(int node)\r\n{\r\n_scif_zap_mmaps(node, &scif_info.connected);\r\n_scif_zap_mmaps(node, &scif_info.disconnected);\r\n}\r\nstatic void __scif_cleanup_rma_for_zombies(struct scif_endpt *ep)\r\n{\r\nstruct list_head *pos, *tmp;\r\nstruct scif_window *window;\r\nlist_for_each_safe(pos, tmp, &ep->rma_info.remote_reg_list) {\r\nwindow = list_entry(pos, struct scif_window, list);\r\nif (window->ref_count)\r\nscif_put_window(window, window->nr_pages);\r\nelse\r\ndev_err(scif_info.mdev.this_device,\r\n"%s %d unexpected\n",\r\n__func__, __LINE__);\r\nif (!window->ref_count) {\r\natomic_inc(&ep->rma_info.tw_refcount);\r\nlist_del_init(&window->list);\r\nscif_queue_for_cleanup(window, &scif_info.rma);\r\n}\r\n}\r\n}\r\nvoid scif_cleanup_rma_for_zombies(int node)\r\n{\r\nstruct scif_endpt *ep;\r\nstruct list_head *item;\r\nmutex_lock(&scif_info.eplock);\r\nlist_for_each(item, &scif_info.zombie) {\r\nep = list_entry(item, struct scif_endpt, list);\r\nif (ep->remote_dev && ep->remote_dev->node == node)\r\n__scif_cleanup_rma_for_zombies(ep);\r\n}\r\nmutex_unlock(&scif_info.eplock);\r\nflush_work(&scif_info.misc_work);\r\n}\r\nstatic int scif_insert_vma(struct scif_endpt *ep, struct vm_area_struct *vma)\r\n{\r\nstruct scif_vma_info *info;\r\nint err = 0;\r\ninfo = kzalloc(sizeof(*info), GFP_KERNEL);\r\nif (!info) {\r\nerr = -ENOMEM;\r\ngoto done;\r\n}\r\ninfo->vma = vma;\r\nspin_lock(&ep->lock);\r\nlist_add_tail(&info->list, &ep->rma_info.vma_list);\r\nspin_unlock(&ep->lock);\r\ndone:\r\nreturn err;\r\n}\r\nstatic void scif_delete_vma(struct scif_endpt *ep, struct vm_area_struct *vma)\r\n{\r\nstruct list_head *item;\r\nstruct scif_vma_info *info;\r\nspin_lock(&ep->lock);\r\nlist_for_each(item, &ep->rma_info.vma_list) {\r\ninfo = list_entry(item, struct scif_vma_info, list);\r\nif (info->vma == vma) {\r\nlist_del(&info->list);\r\nkfree(info);\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&ep->lock);\r\n}\r\nstatic phys_addr_t scif_get_phys(phys_addr_t phys, struct scif_endpt *ep)\r\n{\r\nstruct scif_dev *scifdev = (struct scif_dev *)ep->remote_dev;\r\nstruct scif_hw_dev *sdev = scifdev->sdev;\r\nphys_addr_t out_phys, apt_base = 0;\r\nif (!scifdev_self(scifdev) && sdev->aper && sdev->card_rel_da)\r\napt_base = sdev->aper->pa;\r\nout_phys = apt_base + phys;\r\nreturn out_phys;\r\n}\r\nint scif_get_pages(scif_epd_t epd, off_t offset, size_t len,\r\nstruct scif_range **pages)\r\n{\r\nstruct scif_endpt *ep = (struct scif_endpt *)epd;\r\nstruct scif_rma_req req;\r\nstruct scif_window *window = NULL;\r\nint nr_pages, err, i;\r\ndev_dbg(scif_info.mdev.this_device,\r\n"SCIFAPI get_pinned_pages: ep %p offset 0x%lx len 0x%lx\n",\r\nep, offset, len);\r\nerr = scif_verify_epd(ep);\r\nif (err)\r\nreturn err;\r\nif (!len || (offset < 0) ||\r\n(offset + len < offset) ||\r\n(ALIGN(offset, PAGE_SIZE) != offset) ||\r\n(ALIGN(len, PAGE_SIZE) != len))\r\nreturn -EINVAL;\r\nnr_pages = len >> PAGE_SHIFT;\r\nreq.out_window = &window;\r\nreq.offset = offset;\r\nreq.prot = 0;\r\nreq.nr_bytes = len;\r\nreq.type = SCIF_WINDOW_SINGLE;\r\nreq.head = &ep->rma_info.remote_reg_list;\r\nmutex_lock(&ep->rma_info.rma_lock);\r\nerr = scif_query_window(&req);\r\nif (err) {\r\ndev_err(&ep->remote_dev->sdev->dev,\r\n"%s %d err %d\n", __func__, __LINE__, err);\r\ngoto error;\r\n}\r\n*pages = kzalloc(sizeof(**pages), GFP_KERNEL);\r\nif (!*pages) {\r\nerr = -ENOMEM;\r\ngoto error;\r\n}\r\n(*pages)->phys_addr = scif_zalloc(nr_pages * sizeof(dma_addr_t));\r\nif (!((*pages)->phys_addr)) {\r\nerr = -ENOMEM;\r\ngoto error;\r\n}\r\nif (scif_is_mgmt_node() && !scifdev_self(ep->remote_dev)) {\r\n((*pages)->va = scif_zalloc(nr_pages * sizeof(void *)));\r\nif (!(*pages)->va) {\r\nerr = -ENOMEM;\r\ngoto error;\r\n}\r\n}\r\n(*pages)->cookie = window;\r\n(*pages)->nr_pages = nr_pages;\r\n(*pages)->prot_flags = window->prot;\r\nfor (i = 0; i < nr_pages; i++) {\r\n(*pages)->phys_addr[i] =\r\n__scif_off_to_dma_addr(window, offset +\r\n(i * PAGE_SIZE));\r\n(*pages)->phys_addr[i] = scif_get_phys((*pages)->phys_addr[i],\r\nep);\r\nif (scif_is_mgmt_node() && !scifdev_self(ep->remote_dev))\r\n(*pages)->va[i] =\r\nep->remote_dev->sdev->aper->va +\r\n(*pages)->phys_addr[i] -\r\nep->remote_dev->sdev->aper->pa;\r\n}\r\nscif_get_window(window, nr_pages);\r\nerror:\r\nmutex_unlock(&ep->rma_info.rma_lock);\r\nif (err) {\r\nif (*pages) {\r\nscif_free((*pages)->phys_addr,\r\nnr_pages * sizeof(dma_addr_t));\r\nscif_free((*pages)->va,\r\nnr_pages * sizeof(void *));\r\nkfree(*pages);\r\n*pages = NULL;\r\n}\r\ndev_err(&ep->remote_dev->sdev->dev,\r\n"%s %d err %d\n", __func__, __LINE__, err);\r\n}\r\nreturn err;\r\n}\r\nint scif_put_pages(struct scif_range *pages)\r\n{\r\nstruct scif_endpt *ep;\r\nstruct scif_window *window;\r\nstruct scifmsg msg;\r\nif (!pages || !pages->cookie)\r\nreturn -EINVAL;\r\nwindow = pages->cookie;\r\nif (!window || window->magic != SCIFEP_MAGIC)\r\nreturn -EINVAL;\r\nep = (struct scif_endpt *)window->ep;\r\nif (ep->state != SCIFEP_CONNECTED && ep->state != SCIFEP_DISCONNECTED)\r\nreturn -ENOTCONN;\r\nmutex_lock(&ep->rma_info.rma_lock);\r\nscif_put_window(window, pages->nr_pages);\r\nif (!window->ref_count) {\r\nlist_del(&window->list);\r\nmutex_unlock(&ep->rma_info.rma_lock);\r\nscif_drain_dma_intr(ep->remote_dev->sdev,\r\nep->rma_info.dma_chan);\r\nmsg.uop = SCIF_MUNMAP;\r\nmsg.src = ep->port;\r\nmsg.payload[0] = window->peer_window;\r\nscif_nodeqp_send(ep->remote_dev, &msg);\r\nscif_destroy_remote_window(window);\r\n} else {\r\nmutex_unlock(&ep->rma_info.rma_lock);\r\n}\r\nscif_free(pages->phys_addr, pages->nr_pages * sizeof(dma_addr_t));\r\nscif_free(pages->va, pages->nr_pages * sizeof(void *));\r\nkfree(pages);\r\nreturn 0;\r\n}\r\nstatic int scif_rma_list_mmap(struct scif_window *start_window, s64 offset,\r\nint nr_pages, struct vm_area_struct *vma)\r\n{\r\ns64 end_offset, loop_offset = offset;\r\nstruct scif_window *window = start_window;\r\nint loop_nr_pages, nr_pages_left = nr_pages;\r\nstruct scif_endpt *ep = (struct scif_endpt *)start_window->ep;\r\nstruct list_head *head = &ep->rma_info.remote_reg_list;\r\nint i, err = 0;\r\ndma_addr_t phys_addr;\r\nstruct scif_window_iter src_win_iter;\r\nsize_t contig_bytes = 0;\r\nmight_sleep();\r\nlist_for_each_entry_from(window, head, list) {\r\nend_offset = window->offset +\r\n(window->nr_pages << PAGE_SHIFT);\r\nloop_nr_pages = min_t(int,\r\n(end_offset - loop_offset) >> PAGE_SHIFT,\r\nnr_pages_left);\r\nscif_init_window_iter(window, &src_win_iter);\r\nfor (i = 0; i < loop_nr_pages; i++) {\r\nphys_addr = scif_off_to_dma_addr(window, loop_offset,\r\n&contig_bytes,\r\n&src_win_iter);\r\nphys_addr = scif_get_phys(phys_addr, ep);\r\nerr = remap_pfn_range(vma,\r\nvma->vm_start +\r\nloop_offset - offset,\r\nphys_addr >> PAGE_SHIFT,\r\nPAGE_SIZE,\r\nvma->vm_page_prot);\r\nif (err)\r\ngoto error;\r\nloop_offset += PAGE_SIZE;\r\n}\r\nnr_pages_left -= loop_nr_pages;\r\nif (!nr_pages_left)\r\nbreak;\r\n}\r\nloop_offset = offset;\r\nnr_pages_left = nr_pages;\r\nwindow = start_window;\r\nhead = &ep->rma_info.remote_reg_list;\r\nlist_for_each_entry_from(window, head, list) {\r\nend_offset = window->offset +\r\n(window->nr_pages << PAGE_SHIFT);\r\nloop_nr_pages = min_t(int,\r\n(end_offset - loop_offset) >> PAGE_SHIFT,\r\nnr_pages_left);\r\nscif_get_window(window, loop_nr_pages);\r\nnr_pages_left -= loop_nr_pages;\r\nloop_offset += (loop_nr_pages << PAGE_SHIFT);\r\nif (!nr_pages_left)\r\nbreak;\r\n}\r\nerror:\r\nif (err)\r\ndev_err(scif_info.mdev.this_device,\r\n"%s %d err %d\n", __func__, __LINE__, err);\r\nreturn err;\r\n}\r\nstatic void scif_rma_list_munmap(struct scif_window *start_window,\r\ns64 offset, int nr_pages)\r\n{\r\nstruct scifmsg msg;\r\ns64 loop_offset = offset, end_offset;\r\nint loop_nr_pages, nr_pages_left = nr_pages;\r\nstruct scif_endpt *ep = (struct scif_endpt *)start_window->ep;\r\nstruct list_head *head = &ep->rma_info.remote_reg_list;\r\nstruct scif_window *window = start_window, *_window;\r\nmsg.uop = SCIF_MUNMAP;\r\nmsg.src = ep->port;\r\nloop_offset = offset;\r\nnr_pages_left = nr_pages;\r\nlist_for_each_entry_safe_from(window, _window, head, list) {\r\nend_offset = window->offset +\r\n(window->nr_pages << PAGE_SHIFT);\r\nloop_nr_pages = min_t(int,\r\n(end_offset - loop_offset) >> PAGE_SHIFT,\r\nnr_pages_left);\r\nscif_put_window(window, loop_nr_pages);\r\nif (!window->ref_count) {\r\nstruct scif_dev *rdev = ep->remote_dev;\r\nscif_drain_dma_intr(rdev->sdev,\r\nep->rma_info.dma_chan);\r\nmsg.payload[0] = window->peer_window;\r\nscif_nodeqp_send(ep->remote_dev, &msg);\r\nlist_del(&window->list);\r\nscif_destroy_remote_window(window);\r\n}\r\nnr_pages_left -= loop_nr_pages;\r\nloop_offset += (loop_nr_pages << PAGE_SHIFT);\r\nif (!nr_pages_left)\r\nbreak;\r\n}\r\n}\r\nstatic void vma_pvt_release(struct kref *ref)\r\n{\r\nstruct vma_pvt *vmapvt = container_of(ref, struct vma_pvt, ref);\r\nkfree(vmapvt);\r\n}\r\nstatic void scif_vma_open(struct vm_area_struct *vma)\r\n{\r\nstruct vma_pvt *vmapvt = vma->vm_private_data;\r\ndev_dbg(scif_info.mdev.this_device,\r\n"SCIFAPI vma open: vma_start 0x%lx vma_end 0x%lx\n",\r\nvma->vm_start, vma->vm_end);\r\nscif_insert_vma(vmapvt->ep, vma);\r\nkref_get(&vmapvt->ref);\r\n}\r\nstatic void scif_munmap(struct vm_area_struct *vma)\r\n{\r\nstruct scif_endpt *ep;\r\nstruct vma_pvt *vmapvt = vma->vm_private_data;\r\nint nr_pages = vma_pages(vma);\r\ns64 offset;\r\nstruct scif_rma_req req;\r\nstruct scif_window *window = NULL;\r\nint err;\r\nmight_sleep();\r\ndev_dbg(scif_info.mdev.this_device,\r\n"SCIFAPI munmap: vma_start 0x%lx vma_end 0x%lx\n",\r\nvma->vm_start, vma->vm_end);\r\nep = vmapvt->ep;\r\noffset = vmapvt->valid_offset ? vmapvt->offset :\r\n(vma->vm_pgoff) << PAGE_SHIFT;\r\ndev_dbg(scif_info.mdev.this_device,\r\n"SCIFAPI munmap: ep %p nr_pages 0x%x offset 0x%llx\n",\r\nep, nr_pages, offset);\r\nreq.out_window = &window;\r\nreq.offset = offset;\r\nreq.nr_bytes = vma->vm_end - vma->vm_start;\r\nreq.prot = vma->vm_flags & (VM_READ | VM_WRITE);\r\nreq.type = SCIF_WINDOW_PARTIAL;\r\nreq.head = &ep->rma_info.remote_reg_list;\r\nmutex_lock(&ep->rma_info.rma_lock);\r\nerr = scif_query_window(&req);\r\nif (err)\r\ndev_err(scif_info.mdev.this_device,\r\n"%s %d err %d\n", __func__, __LINE__, err);\r\nelse\r\nscif_rma_list_munmap(window, offset, nr_pages);\r\nmutex_unlock(&ep->rma_info.rma_lock);\r\nvma->vm_ops = NULL;\r\nvma->vm_private_data = NULL;\r\nkref_put(&vmapvt->ref, vma_pvt_release);\r\nscif_delete_vma(ep, vma);\r\n}\r\nint scif_mmap(struct vm_area_struct *vma, scif_epd_t epd)\r\n{\r\nstruct scif_rma_req req;\r\nstruct scif_window *window = NULL;\r\nstruct scif_endpt *ep = (struct scif_endpt *)epd;\r\ns64 start_offset = vma->vm_pgoff << PAGE_SHIFT;\r\nint nr_pages = vma_pages(vma);\r\nint err;\r\nstruct vma_pvt *vmapvt;\r\ndev_dbg(scif_info.mdev.this_device,\r\n"SCIFAPI mmap: ep %p start_offset 0x%llx nr_pages 0x%x\n",\r\nep, start_offset, nr_pages);\r\nerr = scif_verify_epd(ep);\r\nif (err)\r\nreturn err;\r\nmight_sleep();\r\nerr = scif_insert_vma(ep, vma);\r\nif (err)\r\nreturn err;\r\nvmapvt = kzalloc(sizeof(*vmapvt), GFP_KERNEL);\r\nif (!vmapvt) {\r\nscif_delete_vma(ep, vma);\r\nreturn -ENOMEM;\r\n}\r\nvmapvt->ep = ep;\r\nkref_init(&vmapvt->ref);\r\nreq.out_window = &window;\r\nreq.offset = start_offset;\r\nreq.nr_bytes = vma->vm_end - vma->vm_start;\r\nreq.prot = vma->vm_flags & (VM_READ | VM_WRITE);\r\nreq.type = SCIF_WINDOW_PARTIAL;\r\nreq.head = &ep->rma_info.remote_reg_list;\r\nmutex_lock(&ep->rma_info.rma_lock);\r\nerr = scif_query_window(&req);\r\nif (err) {\r\ndev_err(&ep->remote_dev->sdev->dev,\r\n"%s %d err %d\n", __func__, __LINE__, err);\r\ngoto error_unlock;\r\n}\r\nif (!scifdev_self(ep->remote_dev))\r\nvma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);\r\nvma->vm_flags |= VM_DONTCOPY | VM_DONTEXPAND | VM_DONTDUMP;\r\nif (!scifdev_self(ep->remote_dev))\r\nvma->vm_flags |= VM_IO | VM_PFNMAP;\r\nerr = scif_rma_list_mmap(window, start_offset, nr_pages, vma);\r\nif (err) {\r\ndev_err(&ep->remote_dev->sdev->dev,\r\n"%s %d err %d\n", __func__, __LINE__, err);\r\ngoto error_unlock;\r\n}\r\nvma->vm_ops = &scif_vm_ops;\r\nvma->vm_private_data = vmapvt;\r\nerror_unlock:\r\nmutex_unlock(&ep->rma_info.rma_lock);\r\nif (err) {\r\nkfree(vmapvt);\r\ndev_err(&ep->remote_dev->sdev->dev,\r\n"%s %d err %d\n", __func__, __LINE__, err);\r\nscif_delete_vma(ep, vma);\r\n}\r\nreturn err;\r\n}
