static int __init parse_crashkernel_mem(char *cmdline,\r\nunsigned long long system_ram,\r\nunsigned long long *crash_size,\r\nunsigned long long *crash_base)\r\n{\r\nchar *cur = cmdline, *tmp;\r\ndo {\r\nunsigned long long start, end = ULLONG_MAX, size;\r\nstart = memparse(cur, &tmp);\r\nif (cur == tmp) {\r\npr_warn("crashkernel: Memory value expected\n");\r\nreturn -EINVAL;\r\n}\r\ncur = tmp;\r\nif (*cur != '-') {\r\npr_warn("crashkernel: '-' expected\n");\r\nreturn -EINVAL;\r\n}\r\ncur++;\r\nif (*cur != ':') {\r\nend = memparse(cur, &tmp);\r\nif (cur == tmp) {\r\npr_warn("crashkernel: Memory value expected\n");\r\nreturn -EINVAL;\r\n}\r\ncur = tmp;\r\nif (end <= start) {\r\npr_warn("crashkernel: end <= start\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (*cur != ':') {\r\npr_warn("crashkernel: ':' expected\n");\r\nreturn -EINVAL;\r\n}\r\ncur++;\r\nsize = memparse(cur, &tmp);\r\nif (cur == tmp) {\r\npr_warn("Memory value expected\n");\r\nreturn -EINVAL;\r\n}\r\ncur = tmp;\r\nif (size >= system_ram) {\r\npr_warn("crashkernel: invalid size\n");\r\nreturn -EINVAL;\r\n}\r\nif (system_ram >= start && system_ram < end) {\r\n*crash_size = size;\r\nbreak;\r\n}\r\n} while (*cur++ == ',');\r\nif (*crash_size > 0) {\r\nwhile (*cur && *cur != ' ' && *cur != '@')\r\ncur++;\r\nif (*cur == '@') {\r\ncur++;\r\n*crash_base = memparse(cur, &tmp);\r\nif (cur == tmp) {\r\npr_warn("Memory value expected after '@'\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init parse_crashkernel_simple(char *cmdline,\r\nunsigned long long *crash_size,\r\nunsigned long long *crash_base)\r\n{\r\nchar *cur = cmdline;\r\n*crash_size = memparse(cmdline, &cur);\r\nif (cmdline == cur) {\r\npr_warn("crashkernel: memory value expected\n");\r\nreturn -EINVAL;\r\n}\r\nif (*cur == '@')\r\n*crash_base = memparse(cur+1, &cur);\r\nelse if (*cur != ' ' && *cur != '\0') {\r\npr_warn("crashkernel: unrecognized char: %c\n", *cur);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init parse_crashkernel_suffix(char *cmdline,\r\nunsigned long long *crash_size,\r\nconst char *suffix)\r\n{\r\nchar *cur = cmdline;\r\n*crash_size = memparse(cmdline, &cur);\r\nif (cmdline == cur) {\r\npr_warn("crashkernel: memory value expected\n");\r\nreturn -EINVAL;\r\n}\r\nif (strncmp(cur, suffix, strlen(suffix))) {\r\npr_warn("crashkernel: unrecognized char: %c\n", *cur);\r\nreturn -EINVAL;\r\n}\r\ncur += strlen(suffix);\r\nif (*cur != ' ' && *cur != '\0') {\r\npr_warn("crashkernel: unrecognized char: %c\n", *cur);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic __init char *get_last_crashkernel(char *cmdline,\r\nconst char *name,\r\nconst char *suffix)\r\n{\r\nchar *p = cmdline, *ck_cmdline = NULL;\r\np = strstr(p, name);\r\nwhile (p) {\r\nchar *end_p = strchr(p, ' ');\r\nchar *q;\r\nif (!end_p)\r\nend_p = p + strlen(p);\r\nif (!suffix) {\r\nint i;\r\nfor (i = 0; suffix_tbl[i]; i++) {\r\nq = end_p - strlen(suffix_tbl[i]);\r\nif (!strncmp(q, suffix_tbl[i],\r\nstrlen(suffix_tbl[i])))\r\ngoto next;\r\n}\r\nck_cmdline = p;\r\n} else {\r\nq = end_p - strlen(suffix);\r\nif (!strncmp(q, suffix, strlen(suffix)))\r\nck_cmdline = p;\r\n}\r\nnext:\r\np = strstr(p+1, name);\r\n}\r\nif (!ck_cmdline)\r\nreturn NULL;\r\nreturn ck_cmdline;\r\n}\r\nstatic int __init __parse_crashkernel(char *cmdline,\r\nunsigned long long system_ram,\r\nunsigned long long *crash_size,\r\nunsigned long long *crash_base,\r\nconst char *name,\r\nconst char *suffix)\r\n{\r\nchar *first_colon, *first_space;\r\nchar *ck_cmdline;\r\nBUG_ON(!crash_size || !crash_base);\r\n*crash_size = 0;\r\n*crash_base = 0;\r\nck_cmdline = get_last_crashkernel(cmdline, name, suffix);\r\nif (!ck_cmdline)\r\nreturn -EINVAL;\r\nck_cmdline += strlen(name);\r\nif (suffix)\r\nreturn parse_crashkernel_suffix(ck_cmdline, crash_size,\r\nsuffix);\r\nfirst_colon = strchr(ck_cmdline, ':');\r\nfirst_space = strchr(ck_cmdline, ' ');\r\nif (first_colon && (!first_space || first_colon < first_space))\r\nreturn parse_crashkernel_mem(ck_cmdline, system_ram,\r\ncrash_size, crash_base);\r\nreturn parse_crashkernel_simple(ck_cmdline, crash_size, crash_base);\r\n}\r\nint __init parse_crashkernel(char *cmdline,\r\nunsigned long long system_ram,\r\nunsigned long long *crash_size,\r\nunsigned long long *crash_base)\r\n{\r\nreturn __parse_crashkernel(cmdline, system_ram, crash_size, crash_base,\r\n"crashkernel=", NULL);\r\n}\r\nint __init parse_crashkernel_high(char *cmdline,\r\nunsigned long long system_ram,\r\nunsigned long long *crash_size,\r\nunsigned long long *crash_base)\r\n{\r\nreturn __parse_crashkernel(cmdline, system_ram, crash_size, crash_base,\r\n"crashkernel=", suffix_tbl[SUFFIX_HIGH]);\r\n}\r\nint __init parse_crashkernel_low(char *cmdline,\r\nunsigned long long system_ram,\r\nunsigned long long *crash_size,\r\nunsigned long long *crash_base)\r\n{\r\nreturn __parse_crashkernel(cmdline, system_ram, crash_size, crash_base,\r\n"crashkernel=", suffix_tbl[SUFFIX_LOW]);\r\n}\r\nElf_Word *append_elf_note(Elf_Word *buf, char *name, unsigned int type,\r\nvoid *data, size_t data_len)\r\n{\r\nstruct elf_note *note = (struct elf_note *)buf;\r\nnote->n_namesz = strlen(name) + 1;\r\nnote->n_descsz = data_len;\r\nnote->n_type = type;\r\nbuf += DIV_ROUND_UP(sizeof(*note), sizeof(Elf_Word));\r\nmemcpy(buf, name, note->n_namesz);\r\nbuf += DIV_ROUND_UP(note->n_namesz, sizeof(Elf_Word));\r\nmemcpy(buf, data, data_len);\r\nbuf += DIV_ROUND_UP(data_len, sizeof(Elf_Word));\r\nreturn buf;\r\n}\r\nvoid final_note(Elf_Word *buf)\r\n{\r\nmemset(buf, 0, sizeof(struct elf_note));\r\n}\r\nstatic void update_vmcoreinfo_note(void)\r\n{\r\nu32 *buf = vmcoreinfo_note;\r\nif (!vmcoreinfo_size)\r\nreturn;\r\nbuf = append_elf_note(buf, VMCOREINFO_NOTE_NAME, 0, vmcoreinfo_data,\r\nvmcoreinfo_size);\r\nfinal_note(buf);\r\n}\r\nvoid crash_update_vmcoreinfo_safecopy(void *ptr)\r\n{\r\nif (ptr)\r\nmemcpy(ptr, vmcoreinfo_data, vmcoreinfo_size);\r\nvmcoreinfo_data_safecopy = ptr;\r\n}\r\nvoid crash_save_vmcoreinfo(void)\r\n{\r\nif (!vmcoreinfo_note)\r\nreturn;\r\nif (vmcoreinfo_data_safecopy)\r\nvmcoreinfo_data = vmcoreinfo_data_safecopy;\r\nvmcoreinfo_append_str("CRASHTIME=%ld\n", get_seconds());\r\nupdate_vmcoreinfo_note();\r\n}\r\nvoid vmcoreinfo_append_str(const char *fmt, ...)\r\n{\r\nva_list args;\r\nchar buf[0x50];\r\nsize_t r;\r\nva_start(args, fmt);\r\nr = vscnprintf(buf, sizeof(buf), fmt, args);\r\nva_end(args);\r\nr = min(r, (size_t)VMCOREINFO_BYTES - vmcoreinfo_size);\r\nmemcpy(&vmcoreinfo_data[vmcoreinfo_size], buf, r);\r\nvmcoreinfo_size += r;\r\n}\r\nvoid __weak arch_crash_save_vmcoreinfo(void)\r\n{}\r\nphys_addr_t __weak paddr_vmcoreinfo_note(void)\r\n{\r\nreturn __pa(vmcoreinfo_note);\r\n}\r\nstatic int __init crash_save_vmcoreinfo_init(void)\r\n{\r\nvmcoreinfo_data = (unsigned char *)get_zeroed_page(GFP_KERNEL);\r\nif (!vmcoreinfo_data) {\r\npr_warn("Memory allocation for vmcoreinfo_data failed\n");\r\nreturn -ENOMEM;\r\n}\r\nvmcoreinfo_note = alloc_pages_exact(VMCOREINFO_NOTE_SIZE,\r\nGFP_KERNEL | __GFP_ZERO);\r\nif (!vmcoreinfo_note) {\r\nfree_page((unsigned long)vmcoreinfo_data);\r\nvmcoreinfo_data = NULL;\r\npr_warn("Memory allocation for vmcoreinfo_note failed\n");\r\nreturn -ENOMEM;\r\n}\r\nVMCOREINFO_OSRELEASE(init_uts_ns.name.release);\r\nVMCOREINFO_PAGESIZE(PAGE_SIZE);\r\nVMCOREINFO_SYMBOL(init_uts_ns);\r\nVMCOREINFO_SYMBOL(node_online_map);\r\n#ifdef CONFIG_MMU\r\nVMCOREINFO_SYMBOL(swapper_pg_dir);\r\n#endif\r\nVMCOREINFO_SYMBOL(_stext);\r\nVMCOREINFO_SYMBOL(vmap_area_list);\r\n#ifndef CONFIG_NEED_MULTIPLE_NODES\r\nVMCOREINFO_SYMBOL(mem_map);\r\nVMCOREINFO_SYMBOL(contig_page_data);\r\n#endif\r\n#ifdef CONFIG_SPARSEMEM\r\nVMCOREINFO_SYMBOL(mem_section);\r\nVMCOREINFO_LENGTH(mem_section, NR_SECTION_ROOTS);\r\nVMCOREINFO_STRUCT_SIZE(mem_section);\r\nVMCOREINFO_OFFSET(mem_section, section_mem_map);\r\n#endif\r\nVMCOREINFO_STRUCT_SIZE(page);\r\nVMCOREINFO_STRUCT_SIZE(pglist_data);\r\nVMCOREINFO_STRUCT_SIZE(zone);\r\nVMCOREINFO_STRUCT_SIZE(free_area);\r\nVMCOREINFO_STRUCT_SIZE(list_head);\r\nVMCOREINFO_SIZE(nodemask_t);\r\nVMCOREINFO_OFFSET(page, flags);\r\nVMCOREINFO_OFFSET(page, _refcount);\r\nVMCOREINFO_OFFSET(page, mapping);\r\nVMCOREINFO_OFFSET(page, lru);\r\nVMCOREINFO_OFFSET(page, _mapcount);\r\nVMCOREINFO_OFFSET(page, private);\r\nVMCOREINFO_OFFSET(page, compound_dtor);\r\nVMCOREINFO_OFFSET(page, compound_order);\r\nVMCOREINFO_OFFSET(page, compound_head);\r\nVMCOREINFO_OFFSET(pglist_data, node_zones);\r\nVMCOREINFO_OFFSET(pglist_data, nr_zones);\r\n#ifdef CONFIG_FLAT_NODE_MEM_MAP\r\nVMCOREINFO_OFFSET(pglist_data, node_mem_map);\r\n#endif\r\nVMCOREINFO_OFFSET(pglist_data, node_start_pfn);\r\nVMCOREINFO_OFFSET(pglist_data, node_spanned_pages);\r\nVMCOREINFO_OFFSET(pglist_data, node_id);\r\nVMCOREINFO_OFFSET(zone, free_area);\r\nVMCOREINFO_OFFSET(zone, vm_stat);\r\nVMCOREINFO_OFFSET(zone, spanned_pages);\r\nVMCOREINFO_OFFSET(free_area, free_list);\r\nVMCOREINFO_OFFSET(list_head, next);\r\nVMCOREINFO_OFFSET(list_head, prev);\r\nVMCOREINFO_OFFSET(vmap_area, va_start);\r\nVMCOREINFO_OFFSET(vmap_area, list);\r\nVMCOREINFO_LENGTH(zone.free_area, MAX_ORDER);\r\nlog_buf_vmcoreinfo_setup();\r\nVMCOREINFO_LENGTH(free_area.free_list, MIGRATE_TYPES);\r\nVMCOREINFO_NUMBER(NR_FREE_PAGES);\r\nVMCOREINFO_NUMBER(PG_lru);\r\nVMCOREINFO_NUMBER(PG_private);\r\nVMCOREINFO_NUMBER(PG_swapcache);\r\nVMCOREINFO_NUMBER(PG_slab);\r\n#ifdef CONFIG_MEMORY_FAILURE\r\nVMCOREINFO_NUMBER(PG_hwpoison);\r\n#endif\r\nVMCOREINFO_NUMBER(PG_head_mask);\r\nVMCOREINFO_NUMBER(PAGE_BUDDY_MAPCOUNT_VALUE);\r\n#ifdef CONFIG_HUGETLB_PAGE\r\nVMCOREINFO_NUMBER(HUGETLB_PAGE_DTOR);\r\n#endif\r\narch_crash_save_vmcoreinfo();\r\nupdate_vmcoreinfo_note();\r\nreturn 0;\r\n}
