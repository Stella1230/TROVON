const VCHI_MESSAGE_DRIVER_T *\r\nvchi_mphi_message_driver_func_table(void)\r\n{\r\nreturn NULL;\r\n}\r\nconst VCHI_CONNECTION_API_T *\r\nsingle_get_func_table(void)\r\n{\r\nreturn NULL;\r\n}\r\nVCHI_CONNECTION_T *vchi_create_connection(\r\nconst VCHI_CONNECTION_API_T *function_table,\r\nconst VCHI_MESSAGE_DRIVER_T *low_level)\r\n{\r\n(void)function_table;\r\n(void)low_level;\r\nreturn NULL;\r\n}\r\nint32_t vchi_msg_peek(VCHI_SERVICE_HANDLE_T handle,\r\nvoid **data,\r\nuint32_t *msg_size,\r\nVCHI_FLAGS_T flags)\r\n{\r\nSHIM_SERVICE_T *service = (SHIM_SERVICE_T *)handle;\r\nVCHIQ_HEADER_T *header;\r\nWARN_ON((flags != VCHI_FLAGS_NONE) &&\r\n(flags != VCHI_FLAGS_BLOCK_UNTIL_OP_COMPLETE));\r\nif (flags == VCHI_FLAGS_NONE)\r\nif (vchiu_queue_is_empty(&service->queue))\r\nreturn -1;\r\nheader = vchiu_queue_peek(&service->queue);\r\n*data = header->data;\r\n*msg_size = header->size;\r\nreturn 0;\r\n}\r\nint32_t vchi_msg_remove(VCHI_SERVICE_HANDLE_T handle)\r\n{\r\nSHIM_SERVICE_T *service = (SHIM_SERVICE_T *)handle;\r\nVCHIQ_HEADER_T *header;\r\nheader = vchiu_queue_pop(&service->queue);\r\nvchiq_release_message(service->handle, header);\r\nreturn 0;\r\n}\r\nstatic\r\nint32_t vchi_msg_queue(VCHI_SERVICE_HANDLE_T handle,\r\nssize_t (*copy_callback)(void *context, void *dest,\r\nsize_t offset, size_t maxsize),\r\nvoid *context,\r\nuint32_t data_size)\r\n{\r\nSHIM_SERVICE_T *service = (SHIM_SERVICE_T *)handle;\r\nVCHIQ_STATUS_T status;\r\nwhile (1) {\r\nstatus = vchiq_queue_message(service->handle,\r\ncopy_callback,\r\ncontext,\r\ndata_size);\r\nif (status != VCHIQ_RETRY)\r\nbreak;\r\nmsleep(1);\r\n}\r\nreturn vchiq_status_to_vchi(status);\r\n}\r\nstatic ssize_t\r\nvchi_queue_kernel_message_callback(void *context,\r\nvoid *dest,\r\nsize_t offset,\r\nsize_t maxsize)\r\n{\r\nmemcpy(dest, context + offset, maxsize);\r\nreturn maxsize;\r\n}\r\nint\r\nvchi_queue_kernel_message(VCHI_SERVICE_HANDLE_T handle,\r\nvoid *data,\r\nunsigned int size)\r\n{\r\nreturn vchi_msg_queue(handle,\r\nvchi_queue_kernel_message_callback,\r\ndata,\r\nsize);\r\n}\r\nstatic ssize_t\r\nvchi_queue_user_message_callback(void *context,\r\nvoid *dest,\r\nsize_t offset,\r\nsize_t maxsize)\r\n{\r\nstruct vchi_queue_user_message_context *copycontext = context;\r\nif (copy_from_user(dest, copycontext->data + offset, maxsize))\r\nreturn -EFAULT;\r\nreturn maxsize;\r\n}\r\nint\r\nvchi_queue_user_message(VCHI_SERVICE_HANDLE_T handle,\r\nvoid __user *data,\r\nunsigned int size)\r\n{\r\nstruct vchi_queue_user_message_context copycontext = {\r\n.data = data\r\n};\r\nreturn vchi_msg_queue(handle,\r\nvchi_queue_user_message_callback,\r\n&copycontext,\r\nsize);\r\n}\r\nint32_t vchi_bulk_queue_receive(VCHI_SERVICE_HANDLE_T handle,\r\nvoid *data_dst,\r\nuint32_t data_size,\r\nVCHI_FLAGS_T flags,\r\nvoid *bulk_handle)\r\n{\r\nSHIM_SERVICE_T *service = (SHIM_SERVICE_T *)handle;\r\nVCHIQ_BULK_MODE_T mode;\r\nVCHIQ_STATUS_T status;\r\nswitch ((int)flags) {\r\ncase VCHI_FLAGS_CALLBACK_WHEN_OP_COMPLETE\r\n| VCHI_FLAGS_BLOCK_UNTIL_QUEUED:\r\nWARN_ON(!service->callback);\r\nmode = VCHIQ_BULK_MODE_CALLBACK;\r\nbreak;\r\ncase VCHI_FLAGS_BLOCK_UNTIL_OP_COMPLETE:\r\nmode = VCHIQ_BULK_MODE_BLOCKING;\r\nbreak;\r\ncase VCHI_FLAGS_BLOCK_UNTIL_QUEUED:\r\ncase VCHI_FLAGS_NONE:\r\nmode = VCHIQ_BULK_MODE_NOCALLBACK;\r\nbreak;\r\ndefault:\r\nWARN(1, "unsupported message\n");\r\nreturn vchiq_status_to_vchi(VCHIQ_ERROR);\r\n}\r\nwhile (1) {\r\nstatus = vchiq_bulk_receive(service->handle, data_dst,\r\ndata_size, bulk_handle, mode);\r\nif (status != VCHIQ_RETRY)\r\nbreak;\r\nmsleep(1);\r\n}\r\nreturn vchiq_status_to_vchi(status);\r\n}\r\nint32_t vchi_bulk_queue_transmit(VCHI_SERVICE_HANDLE_T handle,\r\nconst void *data_src,\r\nuint32_t data_size,\r\nVCHI_FLAGS_T flags,\r\nvoid *bulk_handle)\r\n{\r\nSHIM_SERVICE_T *service = (SHIM_SERVICE_T *)handle;\r\nVCHIQ_BULK_MODE_T mode;\r\nVCHIQ_STATUS_T status;\r\nswitch ((int)flags) {\r\ncase VCHI_FLAGS_CALLBACK_WHEN_OP_COMPLETE\r\n| VCHI_FLAGS_BLOCK_UNTIL_QUEUED:\r\nWARN_ON(!service->callback);\r\nmode = VCHIQ_BULK_MODE_CALLBACK;\r\nbreak;\r\ncase VCHI_FLAGS_BLOCK_UNTIL_DATA_READ:\r\ncase VCHI_FLAGS_BLOCK_UNTIL_OP_COMPLETE:\r\nmode = VCHIQ_BULK_MODE_BLOCKING;\r\nbreak;\r\ncase VCHI_FLAGS_BLOCK_UNTIL_QUEUED:\r\ncase VCHI_FLAGS_NONE:\r\nmode = VCHIQ_BULK_MODE_NOCALLBACK;\r\nbreak;\r\ndefault:\r\nWARN(1, "unsupported message\n");\r\nreturn vchiq_status_to_vchi(VCHIQ_ERROR);\r\n}\r\nwhile (1) {\r\nstatus = vchiq_bulk_transmit(service->handle, data_src,\r\ndata_size, bulk_handle, mode);\r\nif (status != VCHIQ_RETRY)\r\nbreak;\r\nmsleep(1);\r\n}\r\nreturn vchiq_status_to_vchi(status);\r\n}\r\nint32_t vchi_msg_dequeue(VCHI_SERVICE_HANDLE_T handle,\r\nvoid *data,\r\nuint32_t max_data_size_to_read,\r\nuint32_t *actual_msg_size,\r\nVCHI_FLAGS_T flags)\r\n{\r\nSHIM_SERVICE_T *service = (SHIM_SERVICE_T *)handle;\r\nVCHIQ_HEADER_T *header;\r\nWARN_ON((flags != VCHI_FLAGS_NONE) &&\r\n(flags != VCHI_FLAGS_BLOCK_UNTIL_OP_COMPLETE));\r\nif (flags == VCHI_FLAGS_NONE)\r\nif (vchiu_queue_is_empty(&service->queue))\r\nreturn -1;\r\nheader = vchiu_queue_pop(&service->queue);\r\nmemcpy(data, header->data, header->size < max_data_size_to_read ?\r\nheader->size : max_data_size_to_read);\r\n*actual_msg_size = header->size;\r\nvchiq_release_message(service->handle, header);\r\nreturn 0;\r\n}\r\nint32_t vchi_held_msg_release(VCHI_HELD_MSG_T *message)\r\n{\r\nvchiq_release_message((VCHIQ_SERVICE_HANDLE_T)(long)message->service,\r\n(VCHIQ_HEADER_T *)message->message);\r\nreturn 0;\r\n}\r\nint32_t vchi_msg_hold(VCHI_SERVICE_HANDLE_T handle,\r\nvoid **data,\r\nuint32_t *msg_size,\r\nVCHI_FLAGS_T flags,\r\nVCHI_HELD_MSG_T *message_handle)\r\n{\r\nSHIM_SERVICE_T *service = (SHIM_SERVICE_T *)handle;\r\nVCHIQ_HEADER_T *header;\r\nWARN_ON((flags != VCHI_FLAGS_NONE) &&\r\n(flags != VCHI_FLAGS_BLOCK_UNTIL_OP_COMPLETE));\r\nif (flags == VCHI_FLAGS_NONE)\r\nif (vchiu_queue_is_empty(&service->queue))\r\nreturn -1;\r\nheader = vchiu_queue_pop(&service->queue);\r\n*data = header->data;\r\n*msg_size = header->size;\r\nmessage_handle->service =\r\n(struct opaque_vchi_service_t *)(long)service->handle;\r\nmessage_handle->message = header;\r\nreturn 0;\r\n}\r\nint32_t vchi_initialise(VCHI_INSTANCE_T *instance_handle)\r\n{\r\nVCHIQ_INSTANCE_T instance;\r\nVCHIQ_STATUS_T status;\r\nstatus = vchiq_initialise(&instance);\r\n*instance_handle = (VCHI_INSTANCE_T)instance;\r\nreturn vchiq_status_to_vchi(status);\r\n}\r\nint32_t vchi_connect(VCHI_CONNECTION_T **connections,\r\nconst uint32_t num_connections,\r\nVCHI_INSTANCE_T instance_handle)\r\n{\r\nVCHIQ_INSTANCE_T instance = (VCHIQ_INSTANCE_T)instance_handle;\r\n(void)connections;\r\n(void)num_connections;\r\nreturn vchiq_connect(instance);\r\n}\r\nint32_t vchi_disconnect(VCHI_INSTANCE_T instance_handle)\r\n{\r\nVCHIQ_INSTANCE_T instance = (VCHIQ_INSTANCE_T)instance_handle;\r\nreturn vchiq_status_to_vchi(vchiq_shutdown(instance));\r\n}\r\nstatic VCHIQ_STATUS_T shim_callback(VCHIQ_REASON_T reason,\r\nVCHIQ_HEADER_T *header, VCHIQ_SERVICE_HANDLE_T handle, void *bulk_user)\r\n{\r\nSHIM_SERVICE_T *service =\r\n(SHIM_SERVICE_T *)VCHIQ_GET_SERVICE_USERDATA(handle);\r\nif (!service->callback)\r\ngoto release;\r\nswitch (reason) {\r\ncase VCHIQ_MESSAGE_AVAILABLE:\r\nvchiu_queue_push(&service->queue, header);\r\nservice->callback(service->callback_param,\r\nVCHI_CALLBACK_MSG_AVAILABLE, NULL);\r\ngoto done;\r\nbreak;\r\ncase VCHIQ_BULK_TRANSMIT_DONE:\r\nservice->callback(service->callback_param,\r\nVCHI_CALLBACK_BULK_SENT, bulk_user);\r\nbreak;\r\ncase VCHIQ_BULK_RECEIVE_DONE:\r\nservice->callback(service->callback_param,\r\nVCHI_CALLBACK_BULK_RECEIVED, bulk_user);\r\nbreak;\r\ncase VCHIQ_SERVICE_CLOSED:\r\nservice->callback(service->callback_param,\r\nVCHI_CALLBACK_SERVICE_CLOSED, NULL);\r\nbreak;\r\ncase VCHIQ_SERVICE_OPENED:\r\nbreak;\r\ncase VCHIQ_BULK_TRANSMIT_ABORTED:\r\nservice->callback(service->callback_param,\r\nVCHI_CALLBACK_BULK_TRANSMIT_ABORTED,\r\nbulk_user);\r\nbreak;\r\ncase VCHIQ_BULK_RECEIVE_ABORTED:\r\nservice->callback(service->callback_param,\r\nVCHI_CALLBACK_BULK_RECEIVE_ABORTED,\r\nbulk_user);\r\nbreak;\r\ndefault:\r\nWARN(1, "not supported\n");\r\nbreak;\r\n}\r\nrelease:\r\nvchiq_release_message(service->handle, header);\r\ndone:\r\nreturn VCHIQ_SUCCESS;\r\n}\r\nstatic SHIM_SERVICE_T *service_alloc(VCHIQ_INSTANCE_T instance,\r\nSERVICE_CREATION_T *setup)\r\n{\r\nSHIM_SERVICE_T *service = kzalloc(sizeof(SHIM_SERVICE_T), GFP_KERNEL);\r\n(void)instance;\r\nif (service) {\r\nif (vchiu_queue_init(&service->queue, 64)) {\r\nservice->callback = setup->callback;\r\nservice->callback_param = setup->callback_param;\r\n} else {\r\nkfree(service);\r\nservice = NULL;\r\n}\r\n}\r\nreturn service;\r\n}\r\nstatic void service_free(SHIM_SERVICE_T *service)\r\n{\r\nif (service) {\r\nvchiu_queue_delete(&service->queue);\r\nkfree(service);\r\n}\r\n}\r\nint32_t vchi_service_open(VCHI_INSTANCE_T instance_handle,\r\nSERVICE_CREATION_T *setup,\r\nVCHI_SERVICE_HANDLE_T *handle)\r\n{\r\nVCHIQ_INSTANCE_T instance = (VCHIQ_INSTANCE_T)instance_handle;\r\nSHIM_SERVICE_T *service = service_alloc(instance, setup);\r\n*handle = (VCHI_SERVICE_HANDLE_T)service;\r\nif (service) {\r\nVCHIQ_SERVICE_PARAMS_T params;\r\nVCHIQ_STATUS_T status;\r\nmemset(&params, 0, sizeof(params));\r\nparams.fourcc = setup->service_id;\r\nparams.callback = shim_callback;\r\nparams.userdata = service;\r\nparams.version = setup->version.version;\r\nparams.version_min = setup->version.version_min;\r\nstatus = vchiq_open_service(instance, &params,\r\n&service->handle);\r\nif (status != VCHIQ_SUCCESS) {\r\nservice_free(service);\r\nservice = NULL;\r\n*handle = NULL;\r\n}\r\n}\r\nreturn (service != NULL) ? 0 : -1;\r\n}\r\nint32_t vchi_service_create(VCHI_INSTANCE_T instance_handle,\r\nSERVICE_CREATION_T *setup,\r\nVCHI_SERVICE_HANDLE_T *handle)\r\n{\r\nVCHIQ_INSTANCE_T instance = (VCHIQ_INSTANCE_T)instance_handle;\r\nSHIM_SERVICE_T *service = service_alloc(instance, setup);\r\n*handle = (VCHI_SERVICE_HANDLE_T)service;\r\nif (service) {\r\nVCHIQ_SERVICE_PARAMS_T params;\r\nVCHIQ_STATUS_T status;\r\nmemset(&params, 0, sizeof(params));\r\nparams.fourcc = setup->service_id;\r\nparams.callback = shim_callback;\r\nparams.userdata = service;\r\nparams.version = setup->version.version;\r\nparams.version_min = setup->version.version_min;\r\nstatus = vchiq_add_service(instance, &params, &service->handle);\r\nif (status != VCHIQ_SUCCESS) {\r\nservice_free(service);\r\nservice = NULL;\r\n*handle = NULL;\r\n}\r\n}\r\nreturn (service != NULL) ? 0 : -1;\r\n}\r\nint32_t vchi_service_close(const VCHI_SERVICE_HANDLE_T handle)\r\n{\r\nint32_t ret = -1;\r\nSHIM_SERVICE_T *service = (SHIM_SERVICE_T *)handle;\r\nif (service) {\r\nVCHIQ_STATUS_T status = vchiq_close_service(service->handle);\r\nif (status == VCHIQ_SUCCESS) {\r\nservice_free(service);\r\nservice = NULL;\r\n}\r\nret = vchiq_status_to_vchi(status);\r\n}\r\nreturn ret;\r\n}\r\nint32_t vchi_service_destroy(const VCHI_SERVICE_HANDLE_T handle)\r\n{\r\nint32_t ret = -1;\r\nSHIM_SERVICE_T *service = (SHIM_SERVICE_T *)handle;\r\nif (service) {\r\nVCHIQ_STATUS_T status = vchiq_remove_service(service->handle);\r\nif (status == VCHIQ_SUCCESS) {\r\nservice_free(service);\r\nservice = NULL;\r\n}\r\nret = vchiq_status_to_vchi(status);\r\n}\r\nreturn ret;\r\n}\r\nint32_t vchi_service_set_option(const VCHI_SERVICE_HANDLE_T handle,\r\nVCHI_SERVICE_OPTION_T option,\r\nint value)\r\n{\r\nint32_t ret = -1;\r\nSHIM_SERVICE_T *service = (SHIM_SERVICE_T *)handle;\r\nVCHIQ_SERVICE_OPTION_T vchiq_option;\r\nswitch (option) {\r\ncase VCHI_SERVICE_OPTION_TRACE:\r\nvchiq_option = VCHIQ_SERVICE_OPTION_TRACE;\r\nbreak;\r\ncase VCHI_SERVICE_OPTION_SYNCHRONOUS:\r\nvchiq_option = VCHIQ_SERVICE_OPTION_SYNCHRONOUS;\r\nbreak;\r\ndefault:\r\nservice = NULL;\r\nbreak;\r\n}\r\nif (service) {\r\nVCHIQ_STATUS_T status =\r\nvchiq_set_service_option(service->handle,\r\nvchiq_option,\r\nvalue);\r\nret = vchiq_status_to_vchi(status);\r\n}\r\nreturn ret;\r\n}\r\nint32_t vchi_get_peer_version(const VCHI_SERVICE_HANDLE_T handle, short *peer_version)\r\n{\r\nint32_t ret = -1;\r\nSHIM_SERVICE_T *service = (SHIM_SERVICE_T *)handle;\r\nif (service)\r\n{\r\nVCHIQ_STATUS_T status;\r\nstatus = vchiq_get_peer_version(service->handle, peer_version);\r\nret = vchiq_status_to_vchi(status);\r\n}\r\nreturn ret;\r\n}\r\nint32_t vchi_service_use(const VCHI_SERVICE_HANDLE_T handle)\r\n{\r\nint32_t ret = -1;\r\nSHIM_SERVICE_T *service = (SHIM_SERVICE_T *)handle;\r\nif (service)\r\nret = vchiq_status_to_vchi(vchiq_use_service(service->handle));\r\nreturn ret;\r\n}\r\nint32_t vchi_service_release(const VCHI_SERVICE_HANDLE_T handle)\r\n{\r\nint32_t ret = -1;\r\nSHIM_SERVICE_T *service = (SHIM_SERVICE_T *)handle;\r\nif (service)\r\nret = vchiq_status_to_vchi(\r\nvchiq_release_service(service->handle));\r\nreturn ret;\r\n}
