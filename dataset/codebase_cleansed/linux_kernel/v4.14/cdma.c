static void host1x_pushbuffer_destroy(struct push_buffer *pb)\r\n{\r\nstruct host1x_cdma *cdma = pb_to_cdma(pb);\r\nstruct host1x *host1x = cdma_to_host1x(cdma);\r\nif (!pb->phys)\r\nreturn;\r\nif (host1x->domain) {\r\niommu_unmap(host1x->domain, pb->dma, pb->alloc_size);\r\nfree_iova(&host1x->iova, iova_pfn(&host1x->iova, pb->dma));\r\n}\r\ndma_free_wc(host1x->dev, pb->alloc_size, pb->mapped, pb->phys);\r\npb->mapped = NULL;\r\npb->phys = 0;\r\n}\r\nstatic int host1x_pushbuffer_init(struct push_buffer *pb)\r\n{\r\nstruct host1x_cdma *cdma = pb_to_cdma(pb);\r\nstruct host1x *host1x = cdma_to_host1x(cdma);\r\nstruct iova *alloc;\r\nu32 size;\r\nint err;\r\npb->mapped = NULL;\r\npb->phys = 0;\r\npb->size = HOST1X_PUSHBUFFER_SLOTS * 8;\r\nsize = pb->size + 4;\r\npb->fence = pb->size - 8;\r\npb->pos = 0;\r\nif (host1x->domain) {\r\nunsigned long shift;\r\nsize = iova_align(&host1x->iova, size);\r\npb->mapped = dma_alloc_wc(host1x->dev, size, &pb->phys,\r\nGFP_KERNEL);\r\nif (!pb->mapped)\r\nreturn -ENOMEM;\r\nshift = iova_shift(&host1x->iova);\r\nalloc = alloc_iova(&host1x->iova, size >> shift,\r\nhost1x->iova_end >> shift, true);\r\nif (!alloc) {\r\nerr = -ENOMEM;\r\ngoto iommu_free_mem;\r\n}\r\npb->dma = iova_dma_addr(&host1x->iova, alloc);\r\nerr = iommu_map(host1x->domain, pb->dma, pb->phys, size,\r\nIOMMU_READ);\r\nif (err)\r\ngoto iommu_free_iova;\r\n} else {\r\npb->mapped = dma_alloc_wc(host1x->dev, size, &pb->phys,\r\nGFP_KERNEL);\r\nif (!pb->mapped)\r\nreturn -ENOMEM;\r\npb->dma = pb->phys;\r\n}\r\npb->alloc_size = size;\r\nhost1x_hw_pushbuffer_init(host1x, pb);\r\nreturn 0;\r\niommu_free_iova:\r\n__free_iova(&host1x->iova, alloc);\r\niommu_free_mem:\r\ndma_free_wc(host1x->dev, pb->alloc_size, pb->mapped, pb->phys);\r\nreturn err;\r\n}\r\nstatic void host1x_pushbuffer_push(struct push_buffer *pb, u32 op1, u32 op2)\r\n{\r\nu32 *p = (u32 *)((void *)pb->mapped + pb->pos);\r\nWARN_ON(pb->pos == pb->fence);\r\n*(p++) = op1;\r\n*(p++) = op2;\r\npb->pos = (pb->pos + 8) & (pb->size - 1);\r\n}\r\nstatic void host1x_pushbuffer_pop(struct push_buffer *pb, unsigned int slots)\r\n{\r\npb->fence = (pb->fence + slots * 8) & (pb->size - 1);\r\n}\r\nstatic u32 host1x_pushbuffer_space(struct push_buffer *pb)\r\n{\r\nreturn ((pb->fence - pb->pos) & (pb->size - 1)) / 8;\r\n}\r\nunsigned int host1x_cdma_wait_locked(struct host1x_cdma *cdma,\r\nenum cdma_event event)\r\n{\r\nfor (;;) {\r\nstruct push_buffer *pb = &cdma->push_buffer;\r\nunsigned int space;\r\nswitch (event) {\r\ncase CDMA_EVENT_SYNC_QUEUE_EMPTY:\r\nspace = list_empty(&cdma->sync_queue) ? 1 : 0;\r\nbreak;\r\ncase CDMA_EVENT_PUSH_BUFFER_SPACE:\r\nspace = host1x_pushbuffer_space(pb);\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nif (space)\r\nreturn space;\r\ntrace_host1x_wait_cdma(dev_name(cdma_to_channel(cdma)->dev),\r\nevent);\r\nif (cdma->event != CDMA_EVENT_NONE) {\r\nmutex_unlock(&cdma->lock);\r\nschedule();\r\nmutex_lock(&cdma->lock);\r\ncontinue;\r\n}\r\ncdma->event = event;\r\nmutex_unlock(&cdma->lock);\r\ndown(&cdma->sem);\r\nmutex_lock(&cdma->lock);\r\n}\r\nreturn 0;\r\n}\r\nstatic void cdma_start_timer_locked(struct host1x_cdma *cdma,\r\nstruct host1x_job *job)\r\n{\r\nstruct host1x *host = cdma_to_host1x(cdma);\r\nif (cdma->timeout.client) {\r\nreturn;\r\n}\r\ncdma->timeout.client = job->client;\r\ncdma->timeout.syncpt = host1x_syncpt_get(host, job->syncpt_id);\r\ncdma->timeout.syncpt_val = job->syncpt_end;\r\ncdma->timeout.start_ktime = ktime_get();\r\nschedule_delayed_work(&cdma->timeout.wq,\r\nmsecs_to_jiffies(job->timeout));\r\n}\r\nstatic void stop_cdma_timer_locked(struct host1x_cdma *cdma)\r\n{\r\ncancel_delayed_work(&cdma->timeout.wq);\r\ncdma->timeout.client = 0;\r\n}\r\nstatic void update_cdma_locked(struct host1x_cdma *cdma)\r\n{\r\nbool signal = false;\r\nstruct host1x *host1x = cdma_to_host1x(cdma);\r\nstruct host1x_job *job, *n;\r\nif (!cdma->running)\r\nreturn;\r\nlist_for_each_entry_safe(job, n, &cdma->sync_queue, list) {\r\nstruct host1x_syncpt *sp =\r\nhost1x_syncpt_get(host1x, job->syncpt_id);\r\nif (!host1x_syncpt_is_expired(sp, job->syncpt_end)) {\r\nif (job->timeout)\r\ncdma_start_timer_locked(cdma, job);\r\nbreak;\r\n}\r\nif (cdma->timeout.client)\r\nstop_cdma_timer_locked(cdma);\r\nhost1x_job_unpin(job);\r\nif (job->num_slots) {\r\nstruct push_buffer *pb = &cdma->push_buffer;\r\nhost1x_pushbuffer_pop(pb, job->num_slots);\r\nif (cdma->event == CDMA_EVENT_PUSH_BUFFER_SPACE)\r\nsignal = true;\r\n}\r\nlist_del(&job->list);\r\nhost1x_job_put(job);\r\n}\r\nif (cdma->event == CDMA_EVENT_SYNC_QUEUE_EMPTY &&\r\nlist_empty(&cdma->sync_queue))\r\nsignal = true;\r\nif (signal) {\r\ncdma->event = CDMA_EVENT_NONE;\r\nup(&cdma->sem);\r\n}\r\n}\r\nvoid host1x_cdma_update_sync_queue(struct host1x_cdma *cdma,\r\nstruct device *dev)\r\n{\r\nstruct host1x *host1x = cdma_to_host1x(cdma);\r\nu32 restart_addr, syncpt_incrs, syncpt_val;\r\nstruct host1x_job *job = NULL;\r\nsyncpt_val = host1x_syncpt_load(cdma->timeout.syncpt);\r\ndev_dbg(dev, "%s: starting cleanup (thresh %d)\n",\r\n__func__, syncpt_val);\r\ndev_dbg(dev, "%s: skip completed buffers still in sync_queue\n",\r\n__func__);\r\nlist_for_each_entry(job, &cdma->sync_queue, list) {\r\nif (syncpt_val < job->syncpt_end)\r\nbreak;\r\nhost1x_job_dump(dev, job);\r\n}\r\ndev_dbg(dev, "%s: perform CPU incr on pending same ctx buffers\n",\r\n__func__);\r\nif (!list_empty(&cdma->sync_queue))\r\nrestart_addr = job->first_get;\r\nelse\r\nrestart_addr = cdma->last_pos;\r\nlist_for_each_entry_from(job, &cdma->sync_queue, list) {\r\nif (job->client != cdma->timeout.client)\r\nbreak;\r\njob->timeout = 0;\r\nsyncpt_incrs = job->syncpt_end - syncpt_val;\r\ndev_dbg(dev, "%s: CPU incr (%d)\n", __func__, syncpt_incrs);\r\nhost1x_job_dump(dev, job);\r\nhost1x_hw_cdma_timeout_cpu_incr(host1x, cdma, job->first_get,\r\nsyncpt_incrs, job->syncpt_end,\r\njob->num_slots);\r\nsyncpt_val += syncpt_incrs;\r\n}\r\nlist_for_each_entry_from(job, &cdma->sync_queue, list)\r\nif (job->client == cdma->timeout.client)\r\njob->timeout = min_t(unsigned int, job->timeout, 500);\r\ndev_dbg(dev, "%s: finished sync_queue modification\n", __func__);\r\nhost1x_hw_cdma_resume(host1x, cdma, restart_addr);\r\n}\r\nint host1x_cdma_init(struct host1x_cdma *cdma)\r\n{\r\nint err;\r\nmutex_init(&cdma->lock);\r\nsema_init(&cdma->sem, 0);\r\nINIT_LIST_HEAD(&cdma->sync_queue);\r\ncdma->event = CDMA_EVENT_NONE;\r\ncdma->running = false;\r\ncdma->torndown = false;\r\nerr = host1x_pushbuffer_init(&cdma->push_buffer);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nint host1x_cdma_deinit(struct host1x_cdma *cdma)\r\n{\r\nstruct push_buffer *pb = &cdma->push_buffer;\r\nstruct host1x *host1x = cdma_to_host1x(cdma);\r\nif (cdma->running) {\r\npr_warn("%s: CDMA still running\n", __func__);\r\nreturn -EBUSY;\r\n}\r\nhost1x_pushbuffer_destroy(pb);\r\nhost1x_hw_cdma_timeout_destroy(host1x, cdma);\r\nreturn 0;\r\n}\r\nint host1x_cdma_begin(struct host1x_cdma *cdma, struct host1x_job *job)\r\n{\r\nstruct host1x *host1x = cdma_to_host1x(cdma);\r\nmutex_lock(&cdma->lock);\r\nif (job->timeout) {\r\nif (!cdma->timeout.initialized) {\r\nint err;\r\nerr = host1x_hw_cdma_timeout_init(host1x, cdma,\r\njob->syncpt_id);\r\nif (err) {\r\nmutex_unlock(&cdma->lock);\r\nreturn err;\r\n}\r\n}\r\n}\r\nif (!cdma->running)\r\nhost1x_hw_cdma_start(host1x, cdma);\r\ncdma->slots_free = 0;\r\ncdma->slots_used = 0;\r\ncdma->first_get = cdma->push_buffer.pos;\r\ntrace_host1x_cdma_begin(dev_name(job->channel->dev));\r\nreturn 0;\r\n}\r\nvoid host1x_cdma_push(struct host1x_cdma *cdma, u32 op1, u32 op2)\r\n{\r\nstruct host1x *host1x = cdma_to_host1x(cdma);\r\nstruct push_buffer *pb = &cdma->push_buffer;\r\nu32 slots_free = cdma->slots_free;\r\nif (host1x_debug_trace_cmdbuf)\r\ntrace_host1x_cdma_push(dev_name(cdma_to_channel(cdma)->dev),\r\nop1, op2);\r\nif (slots_free == 0) {\r\nhost1x_hw_cdma_flush(host1x, cdma);\r\nslots_free = host1x_cdma_wait_locked(cdma,\r\nCDMA_EVENT_PUSH_BUFFER_SPACE);\r\n}\r\ncdma->slots_free = slots_free - 1;\r\ncdma->slots_used++;\r\nhost1x_pushbuffer_push(pb, op1, op2);\r\n}\r\nvoid host1x_cdma_end(struct host1x_cdma *cdma,\r\nstruct host1x_job *job)\r\n{\r\nstruct host1x *host1x = cdma_to_host1x(cdma);\r\nbool idle = list_empty(&cdma->sync_queue);\r\nhost1x_hw_cdma_flush(host1x, cdma);\r\njob->first_get = cdma->first_get;\r\njob->num_slots = cdma->slots_used;\r\nhost1x_job_get(job);\r\nlist_add_tail(&job->list, &cdma->sync_queue);\r\nif (job->timeout && idle)\r\ncdma_start_timer_locked(cdma, job);\r\ntrace_host1x_cdma_end(dev_name(job->channel->dev));\r\nmutex_unlock(&cdma->lock);\r\n}\r\nvoid host1x_cdma_update(struct host1x_cdma *cdma)\r\n{\r\nmutex_lock(&cdma->lock);\r\nupdate_cdma_locked(cdma);\r\nmutex_unlock(&cdma->lock);\r\n}
