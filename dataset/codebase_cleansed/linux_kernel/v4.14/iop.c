static __inline__ void iop_loadaddr(volatile struct mac_iop *iop, __u16 addr)\r\n{\r\niop->ram_addr_lo = addr;\r\niop->ram_addr_hi = addr >> 8;\r\n}\r\nstatic __inline__ __u8 iop_readb(volatile struct mac_iop *iop, __u16 addr)\r\n{\r\niop->ram_addr_lo = addr;\r\niop->ram_addr_hi = addr >> 8;\r\nreturn iop->ram_data;\r\n}\r\nstatic __inline__ void iop_writeb(volatile struct mac_iop *iop, __u16 addr, __u8 data)\r\n{\r\niop->ram_addr_lo = addr;\r\niop->ram_addr_hi = addr >> 8;\r\niop->ram_data = data;\r\n}\r\nstatic __inline__ void iop_stop(volatile struct mac_iop *iop)\r\n{\r\niop->status_ctrl &= ~IOP_RUN;\r\n}\r\nstatic __inline__ void iop_start(volatile struct mac_iop *iop)\r\n{\r\niop->status_ctrl = IOP_RUN | IOP_AUTOINC;\r\n}\r\nstatic __inline__ void iop_bypass(volatile struct mac_iop *iop)\r\n{\r\niop->status_ctrl |= IOP_BYPASS;\r\n}\r\nstatic __inline__ void iop_interrupt(volatile struct mac_iop *iop)\r\n{\r\niop->status_ctrl |= IOP_IRQ;\r\n}\r\nstatic int iop_alive(volatile struct mac_iop *iop)\r\n{\r\nint retval;\r\nretval = (iop_readb(iop, IOP_ADDR_ALIVE) == 0xFF);\r\niop_writeb(iop, IOP_ADDR_ALIVE, 0);\r\nreturn retval;\r\n}\r\nstatic struct iop_msg *iop_get_unused_msg(void)\r\n{\r\nint i;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nfor (i = 0 ; i < NUM_IOP_MSGS ; i++) {\r\nif (iop_msg_pool[i].status == IOP_MSGSTATUS_UNUSED) {\r\niop_msg_pool[i].status = IOP_MSGSTATUS_WAITING;\r\nlocal_irq_restore(flags);\r\nreturn &iop_msg_pool[i];\r\n}\r\n}\r\nlocal_irq_restore(flags);\r\nreturn NULL;\r\n}\r\nvoid __init iop_preinit(void)\r\n{\r\nif (macintosh_config->scc_type == MAC_SCC_IOP) {\r\nif (macintosh_config->ident == MAC_MODEL_IIFX) {\r\niop_base[IOP_NUM_SCC] = (struct mac_iop *) SCC_IOP_BASE_IIFX;\r\n} else {\r\niop_base[IOP_NUM_SCC] = (struct mac_iop *) SCC_IOP_BASE_QUADRA;\r\n}\r\niop_base[IOP_NUM_SCC]->status_ctrl = 0x87;\r\niop_scc_present = 1;\r\n} else {\r\niop_base[IOP_NUM_SCC] = NULL;\r\niop_scc_present = 0;\r\n}\r\nif (macintosh_config->adb_type == MAC_ADB_IOP) {\r\nif (macintosh_config->ident == MAC_MODEL_IIFX) {\r\niop_base[IOP_NUM_ISM] = (struct mac_iop *) ISM_IOP_BASE_IIFX;\r\n} else {\r\niop_base[IOP_NUM_ISM] = (struct mac_iop *) ISM_IOP_BASE_QUADRA;\r\n}\r\niop_base[IOP_NUM_ISM]->status_ctrl = 0;\r\niop_ism_present = 1;\r\n} else {\r\niop_base[IOP_NUM_ISM] = NULL;\r\niop_ism_present = 0;\r\n}\r\n}\r\nvoid __init iop_init(void)\r\n{\r\nint i;\r\nif (iop_scc_present) {\r\npr_info("IOP: detected SCC IOP at %p\n", iop_base[IOP_NUM_SCC]);\r\n}\r\nif (iop_ism_present) {\r\npr_info("IOP: detected ISM IOP at %p\n", iop_base[IOP_NUM_ISM]);\r\niop_start(iop_base[IOP_NUM_ISM]);\r\niop_alive(iop_base[IOP_NUM_ISM]);\r\n}\r\nfor (i = 0 ; i < NUM_IOP_MSGS ; i++) {\r\niop_msg_pool[i].status = IOP_MSGSTATUS_UNUSED;\r\n}\r\nfor (i = 0 ; i < NUM_IOP_CHAN ; i++) {\r\niop_send_queue[IOP_NUM_SCC][i] = NULL;\r\niop_send_queue[IOP_NUM_ISM][i] = NULL;\r\niop_listeners[IOP_NUM_SCC][i].devname = NULL;\r\niop_listeners[IOP_NUM_SCC][i].handler = NULL;\r\niop_listeners[IOP_NUM_ISM][i].devname = NULL;\r\niop_listeners[IOP_NUM_ISM][i].handler = NULL;\r\n}\r\n}\r\nvoid __init iop_register_interrupts(void)\r\n{\r\nif (iop_ism_present) {\r\nif (macintosh_config->ident == MAC_MODEL_IIFX) {\r\nif (request_irq(IRQ_MAC_ADB, iop_ism_irq, 0,\r\n"ISM IOP", (void *)IOP_NUM_ISM))\r\npr_err("Couldn't register ISM IOP interrupt\n");\r\n} else {\r\nif (request_irq(IRQ_VIA2_0, iop_ism_irq, 0, "ISM IOP",\r\n(void *)IOP_NUM_ISM))\r\npr_err("Couldn't register ISM IOP interrupt\n");\r\n}\r\nif (!iop_alive(iop_base[IOP_NUM_ISM])) {\r\npr_warn("IOP: oh my god, they killed the ISM IOP!\n");\r\n} else {\r\npr_warn("IOP: the ISM IOP seems to be alive.\n");\r\n}\r\n}\r\n}\r\nint iop_listen(uint iop_num, uint chan,\r\nvoid (*handler)(struct iop_msg *),\r\nconst char *devname)\r\n{\r\nif ((iop_num >= NUM_IOPS) || !iop_base[iop_num]) return -EINVAL;\r\nif (chan >= NUM_IOP_CHAN) return -EINVAL;\r\nif (iop_listeners[iop_num][chan].handler && handler) return -EINVAL;\r\niop_listeners[iop_num][chan].devname = devname;\r\niop_listeners[iop_num][chan].handler = handler;\r\nreturn 0;\r\n}\r\nvoid iop_complete_message(struct iop_msg *msg)\r\n{\r\nint iop_num = msg->iop_num;\r\nint chan = msg->channel;\r\nint i,offset;\r\niop_pr_debug("msg %p iop_num %d channel %d\n", msg, msg->iop_num,\r\nmsg->channel);\r\noffset = IOP_ADDR_RECV_MSG + (msg->channel * IOP_MSG_LEN);\r\nfor (i = 0 ; i < IOP_MSG_LEN ; i++, offset++) {\r\niop_writeb(iop_base[iop_num], offset, msg->reply[i]);\r\n}\r\niop_writeb(iop_base[iop_num],\r\nIOP_ADDR_RECV_STATE + chan, IOP_MSG_COMPLETE);\r\niop_interrupt(iop_base[msg->iop_num]);\r\nmsg->status = IOP_MSGSTATUS_UNUSED;\r\n}\r\nstatic void iop_do_send(struct iop_msg *msg)\r\n{\r\nvolatile struct mac_iop *iop = iop_base[msg->iop_num];\r\nint i,offset;\r\noffset = IOP_ADDR_SEND_MSG + (msg->channel * IOP_MSG_LEN);\r\nfor (i = 0 ; i < IOP_MSG_LEN ; i++, offset++) {\r\niop_writeb(iop, offset, msg->message[i]);\r\n}\r\niop_writeb(iop, IOP_ADDR_SEND_STATE + msg->channel, IOP_MSG_NEW);\r\niop_interrupt(iop);\r\n}\r\nstatic void iop_handle_send(uint iop_num, uint chan)\r\n{\r\nvolatile struct mac_iop *iop = iop_base[iop_num];\r\nstruct iop_msg *msg;\r\nint i,offset;\r\niop_pr_debug("iop_num %d chan %d\n", iop_num, chan);\r\niop_writeb(iop, IOP_ADDR_SEND_STATE + chan, IOP_MSG_IDLE);\r\nif (!(msg = iop_send_queue[iop_num][chan])) return;\r\nmsg->status = IOP_MSGSTATUS_COMPLETE;\r\noffset = IOP_ADDR_SEND_MSG + (chan * IOP_MSG_LEN);\r\nfor (i = 0 ; i < IOP_MSG_LEN ; i++, offset++) {\r\nmsg->reply[i] = iop_readb(iop, offset);\r\n}\r\nif (msg->handler) (*msg->handler)(msg);\r\nmsg->status = IOP_MSGSTATUS_UNUSED;\r\nmsg = msg->next;\r\niop_send_queue[iop_num][chan] = msg;\r\nif (msg) iop_do_send(msg);\r\n}\r\nstatic void iop_handle_recv(uint iop_num, uint chan)\r\n{\r\nvolatile struct mac_iop *iop = iop_base[iop_num];\r\nint i,offset;\r\nstruct iop_msg *msg;\r\niop_pr_debug("iop_num %d chan %d\n", iop_num, chan);\r\nmsg = iop_get_unused_msg();\r\nmsg->iop_num = iop_num;\r\nmsg->channel = chan;\r\nmsg->status = IOP_MSGSTATUS_UNSOL;\r\nmsg->handler = iop_listeners[iop_num][chan].handler;\r\noffset = IOP_ADDR_RECV_MSG + (chan * IOP_MSG_LEN);\r\nfor (i = 0 ; i < IOP_MSG_LEN ; i++, offset++) {\r\nmsg->message[i] = iop_readb(iop, offset);\r\n}\r\niop_writeb(iop, IOP_ADDR_RECV_STATE + chan, IOP_MSG_RCVD);\r\nif (msg->handler) {\r\n(*msg->handler)(msg);\r\n} else {\r\niop_pr_debug("unclaimed message on iop_num %d chan %d\n",\r\niop_num, chan);\r\niop_pr_debug("%*ph\n", IOP_MSG_LEN, msg->message);\r\niop_complete_message(msg);\r\n}\r\n}\r\nint iop_send_message(uint iop_num, uint chan, void *privdata,\r\nuint msg_len, __u8 *msg_data,\r\nvoid (*handler)(struct iop_msg *))\r\n{\r\nstruct iop_msg *msg, *q;\r\nif ((iop_num >= NUM_IOPS) || !iop_base[iop_num]) return -EINVAL;\r\nif (chan >= NUM_IOP_CHAN) return -EINVAL;\r\nif (msg_len > IOP_MSG_LEN) return -EINVAL;\r\nmsg = iop_get_unused_msg();\r\nif (!msg) return -ENOMEM;\r\nmsg->next = NULL;\r\nmsg->status = IOP_MSGSTATUS_WAITING;\r\nmsg->iop_num = iop_num;\r\nmsg->channel = chan;\r\nmsg->caller_priv = privdata;\r\nmemcpy(msg->message, msg_data, msg_len);\r\nmsg->handler = handler;\r\nif (!(q = iop_send_queue[iop_num][chan])) {\r\niop_send_queue[iop_num][chan] = msg;\r\n} else {\r\nwhile (q->next) q = q->next;\r\nq->next = msg;\r\n}\r\nif (iop_readb(iop_base[iop_num],\r\nIOP_ADDR_SEND_STATE + chan) == IOP_MSG_IDLE) {\r\niop_do_send(msg);\r\n}\r\nreturn 0;\r\n}\r\nvoid iop_upload_code(uint iop_num, __u8 *code_start,\r\nuint code_len, __u16 shared_ram_start)\r\n{\r\nif ((iop_num >= NUM_IOPS) || !iop_base[iop_num]) return;\r\niop_loadaddr(iop_base[iop_num], shared_ram_start);\r\nwhile (code_len--) {\r\niop_base[iop_num]->ram_data = *code_start++;\r\n}\r\n}\r\nvoid iop_download_code(uint iop_num, __u8 *code_start,\r\nuint code_len, __u16 shared_ram_start)\r\n{\r\nif ((iop_num >= NUM_IOPS) || !iop_base[iop_num]) return;\r\niop_loadaddr(iop_base[iop_num], shared_ram_start);\r\nwhile (code_len--) {\r\n*code_start++ = iop_base[iop_num]->ram_data;\r\n}\r\n}\r\n__u8 *iop_compare_code(uint iop_num, __u8 *code_start,\r\nuint code_len, __u16 shared_ram_start)\r\n{\r\nif ((iop_num >= NUM_IOPS) || !iop_base[iop_num]) return code_start;\r\niop_loadaddr(iop_base[iop_num], shared_ram_start);\r\nwhile (code_len--) {\r\nif (*code_start != iop_base[iop_num]->ram_data) {\r\nreturn code_start;\r\n}\r\ncode_start++;\r\n}\r\nreturn (__u8 *) 0;\r\n}\r\nirqreturn_t iop_ism_irq(int irq, void *dev_id)\r\n{\r\nuint iop_num = (uint) dev_id;\r\nvolatile struct mac_iop *iop = iop_base[iop_num];\r\nint i,state;\r\niop_pr_debug("status %02X\n", iop->status_ctrl);\r\nif (iop->status_ctrl & IOP_INT0) {\r\niop->status_ctrl = IOP_INT0 | IOP_RUN | IOP_AUTOINC;\r\niop_pr_debug("new status %02X, send states", iop->status_ctrl);\r\nfor (i = 0 ; i < NUM_IOP_CHAN ; i++) {\r\nstate = iop_readb(iop, IOP_ADDR_SEND_STATE + i);\r\niop_pr_cont(" %02X", state);\r\nif (state == IOP_MSG_COMPLETE) {\r\niop_handle_send(iop_num, i);\r\n}\r\n}\r\niop_pr_cont("\n");\r\n}\r\nif (iop->status_ctrl & IOP_INT1) {\r\niop->status_ctrl = IOP_INT1 | IOP_RUN | IOP_AUTOINC;\r\niop_pr_debug("new status %02X, recv states", iop->status_ctrl);\r\nfor (i = 0 ; i < NUM_IOP_CHAN ; i++) {\r\nstate = iop_readb(iop, IOP_ADDR_RECV_STATE + i);\r\niop_pr_cont(" %02X", state);\r\nif (state == IOP_MSG_NEW) {\r\niop_handle_recv(iop_num, i);\r\n}\r\n}\r\niop_pr_cont("\n");\r\n}\r\nreturn IRQ_HANDLED;\r\n}
