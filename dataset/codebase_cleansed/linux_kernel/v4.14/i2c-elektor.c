static void pcf_isa_setbyte(void *data, int ctl, int val)\r\n{\r\nu8 __iomem *address = ctl ? (base_iomem + 1) : base_iomem;\r\nif (ctl && irq && (val & I2C_PCF_ESO)) {\r\nval |= I2C_PCF_ENI;\r\n}\r\npr_debug("%s: Write %p 0x%02X\n", pcf_isa_ops.name, address, val);\r\niowrite8(val, address);\r\n#ifdef __alpha__\r\niowrite8(val, address);\r\n#endif\r\n}\r\nstatic int pcf_isa_getbyte(void *data, int ctl)\r\n{\r\nu8 __iomem *address = ctl ? (base_iomem + 1) : base_iomem;\r\nint val = ioread8(address);\r\npr_debug("%s: Read %p 0x%02X\n", pcf_isa_ops.name, address, val);\r\nreturn (val);\r\n}\r\nstatic int pcf_isa_getown(void *data)\r\n{\r\nreturn (own);\r\n}\r\nstatic int pcf_isa_getclock(void *data)\r\n{\r\nreturn (clock);\r\n}\r\nstatic void pcf_isa_waitforpin(void *data)\r\n{\r\nDEFINE_WAIT(wait);\r\nint timeout = 2;\r\nunsigned long flags;\r\nif (irq > 0) {\r\nspin_lock_irqsave(&lock, flags);\r\nif (pcf_pending == 0) {\r\nspin_unlock_irqrestore(&lock, flags);\r\nprepare_to_wait(&pcf_wait, &wait, TASK_INTERRUPTIBLE);\r\nif (schedule_timeout(timeout*HZ)) {\r\nspin_lock_irqsave(&lock, flags);\r\nif (pcf_pending == 1) {\r\npcf_pending = 0;\r\n}\r\nspin_unlock_irqrestore(&lock, flags);\r\n}\r\nfinish_wait(&pcf_wait, &wait);\r\n} else {\r\npcf_pending = 0;\r\nspin_unlock_irqrestore(&lock, flags);\r\n}\r\n} else {\r\nudelay(100);\r\n}\r\n}\r\nstatic irqreturn_t pcf_isa_handler(int this_irq, void *dev_id) {\r\nspin_lock(&lock);\r\npcf_pending = 1;\r\nspin_unlock(&lock);\r\nwake_up_interruptible(&pcf_wait);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int pcf_isa_init(void)\r\n{\r\nspin_lock_init(&lock);\r\nif (!mmapped) {\r\nif (!request_region(base, 2, pcf_isa_ops.name)) {\r\nprintk(KERN_ERR "%s: requested I/O region (%#x:2) is "\r\n"in use\n", pcf_isa_ops.name, base);\r\nreturn -ENODEV;\r\n}\r\nbase_iomem = ioport_map(base, 2);\r\nif (!base_iomem) {\r\nprintk(KERN_ERR "%s: remap of I/O region %#x failed\n",\r\npcf_isa_ops.name, base);\r\nrelease_region(base, 2);\r\nreturn -ENODEV;\r\n}\r\n} else {\r\nif (!request_mem_region(base, 2, pcf_isa_ops.name)) {\r\nprintk(KERN_ERR "%s: requested memory region (%#x:2) "\r\n"is in use\n", pcf_isa_ops.name, base);\r\nreturn -ENODEV;\r\n}\r\nbase_iomem = ioremap(base, 2);\r\nif (base_iomem == NULL) {\r\nprintk(KERN_ERR "%s: remap of memory region %#x "\r\n"failed\n", pcf_isa_ops.name, base);\r\nrelease_mem_region(base, 2);\r\nreturn -ENODEV;\r\n}\r\n}\r\npr_debug("%s: registers %#x remapped to %p\n", pcf_isa_ops.name, base,\r\nbase_iomem);\r\nif (irq > 0) {\r\nif (request_irq(irq, pcf_isa_handler, 0, pcf_isa_ops.name,\r\nNULL) < 0) {\r\nprintk(KERN_ERR "%s: Request irq%d failed\n",\r\npcf_isa_ops.name, irq);\r\nirq = 0;\r\n} else\r\nenable_irq(irq);\r\n}\r\nreturn 0;\r\n}\r\nstatic int elektor_match(struct device *dev, unsigned int id)\r\n{\r\n#ifdef __alpha__\r\nif (base == 0) {\r\nstruct pci_dev *cy693_dev;\r\ncy693_dev = pci_get_device(PCI_VENDOR_ID_CONTAQ,\r\nPCI_DEVICE_ID_CONTAQ_82C693, NULL);\r\nif (cy693_dev) {\r\nunsigned char config;\r\nif (!pci_read_config_byte(cy693_dev, 0x47, &config)) {\r\ndev_dbg(dev, "found cy82c693, config "\r\n"register 0x47 = 0x%02x\n", config);\r\nif ((config & 0x7f) == 0x61) {\r\nbase = 0xe0000;\r\nmmapped = 1;\r\nclock = I2C_PCF_CLK | I2C_PCF_TRNS90;\r\ndev_info(dev, "found API UP2000 like "\r\n"board, will probe PCF8584 "\r\n"later\n");\r\n}\r\n}\r\npci_dev_put(cy693_dev);\r\n}\r\n}\r\n#endif\r\nif (mmapped && base < 0xc8000) {\r\ndev_err(dev, "incorrect base address (%#x) specified "\r\n"for mmapped I/O\n", base);\r\nreturn 0;\r\n}\r\nif (base == 0) {\r\nbase = DEFAULT_BASE;\r\n}\r\nreturn 1;\r\n}\r\nstatic int elektor_probe(struct device *dev, unsigned int id)\r\n{\r\ninit_waitqueue_head(&pcf_wait);\r\nif (pcf_isa_init())\r\nreturn -ENODEV;\r\npcf_isa_ops.dev.parent = dev;\r\nif (i2c_pcf_add_bus(&pcf_isa_ops) < 0)\r\ngoto fail;\r\ndev_info(dev, "found device at %#x\n", base);\r\nreturn 0;\r\nfail:\r\nif (irq > 0) {\r\ndisable_irq(irq);\r\nfree_irq(irq, NULL);\r\n}\r\nif (!mmapped) {\r\nioport_unmap(base_iomem);\r\nrelease_region(base, 2);\r\n} else {\r\niounmap(base_iomem);\r\nrelease_mem_region(base, 2);\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int elektor_remove(struct device *dev, unsigned int id)\r\n{\r\ni2c_del_adapter(&pcf_isa_ops);\r\nif (irq > 0) {\r\ndisable_irq(irq);\r\nfree_irq(irq, NULL);\r\n}\r\nif (!mmapped) {\r\nioport_unmap(base_iomem);\r\nrelease_region(base, 2);\r\n} else {\r\niounmap(base_iomem);\r\nrelease_mem_region(base, 2);\r\n}\r\nreturn 0;\r\n}
