static int ccu_phase_get_phase(struct clk_hw *hw)\r\n{\r\nstruct ccu_phase *phase = hw_to_ccu_phase(hw);\r\nstruct clk_hw *parent, *grandparent;\r\nunsigned int parent_rate, grandparent_rate;\r\nu16 step, parent_div;\r\nu32 reg;\r\nu8 delay;\r\nreg = readl(phase->common.base + phase->common.reg);\r\ndelay = (reg >> phase->shift);\r\ndelay &= (1 << phase->width) - 1;\r\nif (!delay)\r\nreturn 180;\r\nparent = clk_hw_get_parent(hw);\r\nif (!parent)\r\nreturn -EINVAL;\r\nparent_rate = clk_hw_get_rate(parent);\r\nif (!parent_rate)\r\nreturn -EINVAL;\r\ngrandparent = clk_hw_get_parent(parent);\r\nif (!grandparent)\r\nreturn -EINVAL;\r\ngrandparent_rate = clk_hw_get_rate(grandparent);\r\nif (!grandparent_rate)\r\nreturn -EINVAL;\r\nparent_div = grandparent_rate / parent_rate;\r\nstep = DIV_ROUND_CLOSEST(360, parent_div);\r\nreturn delay * step;\r\n}\r\nstatic int ccu_phase_set_phase(struct clk_hw *hw, int degrees)\r\n{\r\nstruct ccu_phase *phase = hw_to_ccu_phase(hw);\r\nstruct clk_hw *parent, *grandparent;\r\nunsigned int parent_rate, grandparent_rate;\r\nunsigned long flags;\r\nu32 reg;\r\nu8 delay;\r\nparent = clk_hw_get_parent(hw);\r\nif (!parent)\r\nreturn -EINVAL;\r\nparent_rate = clk_hw_get_rate(parent);\r\nif (!parent_rate)\r\nreturn -EINVAL;\r\ngrandparent = clk_hw_get_parent(parent);\r\nif (!grandparent)\r\nreturn -EINVAL;\r\ngrandparent_rate = clk_hw_get_rate(grandparent);\r\nif (!grandparent_rate)\r\nreturn -EINVAL;\r\nif (degrees != 180) {\r\nu16 step, parent_div;\r\nparent_div = grandparent_rate / parent_rate;\r\nstep = DIV_ROUND_CLOSEST(360, parent_div);\r\ndelay = DIV_ROUND_CLOSEST(degrees, step);\r\n} else {\r\ndelay = 0;\r\n}\r\nspin_lock_irqsave(phase->common.lock, flags);\r\nreg = readl(phase->common.base + phase->common.reg);\r\nreg &= ~GENMASK(phase->width + phase->shift - 1, phase->shift);\r\nwritel(reg | (delay << phase->shift),\r\nphase->common.base + phase->common.reg);\r\nspin_unlock_irqrestore(phase->common.lock, flags);\r\nreturn 0;\r\n}
