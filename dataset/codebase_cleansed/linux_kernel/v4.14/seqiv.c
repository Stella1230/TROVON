static void seqiv_aead_encrypt_complete2(struct aead_request *req, int err)\r\n{\r\nstruct aead_request *subreq = aead_request_ctx(req);\r\nstruct crypto_aead *geniv;\r\nif (err == -EINPROGRESS)\r\nreturn;\r\nif (err)\r\ngoto out;\r\ngeniv = crypto_aead_reqtfm(req);\r\nmemcpy(req->iv, subreq->iv, crypto_aead_ivsize(geniv));\r\nout:\r\nkzfree(subreq->iv);\r\n}\r\nstatic void seqiv_aead_encrypt_complete(struct crypto_async_request *base,\r\nint err)\r\n{\r\nstruct aead_request *req = base->data;\r\nseqiv_aead_encrypt_complete2(req, err);\r\naead_request_complete(req, err);\r\n}\r\nstatic int seqiv_aead_encrypt(struct aead_request *req)\r\n{\r\nstruct crypto_aead *geniv = crypto_aead_reqtfm(req);\r\nstruct aead_geniv_ctx *ctx = crypto_aead_ctx(geniv);\r\nstruct aead_request *subreq = aead_request_ctx(req);\r\ncrypto_completion_t compl;\r\nvoid *data;\r\nu8 *info;\r\nunsigned int ivsize = 8;\r\nint err;\r\nif (req->cryptlen < ivsize)\r\nreturn -EINVAL;\r\naead_request_set_tfm(subreq, ctx->child);\r\ncompl = req->base.complete;\r\ndata = req->base.data;\r\ninfo = req->iv;\r\nif (req->src != req->dst) {\r\nSKCIPHER_REQUEST_ON_STACK(nreq, ctx->sknull);\r\nskcipher_request_set_tfm(nreq, ctx->sknull);\r\nskcipher_request_set_callback(nreq, req->base.flags,\r\nNULL, NULL);\r\nskcipher_request_set_crypt(nreq, req->src, req->dst,\r\nreq->assoclen + req->cryptlen,\r\nNULL);\r\nerr = crypto_skcipher_encrypt(nreq);\r\nif (err)\r\nreturn err;\r\n}\r\nif (unlikely(!IS_ALIGNED((unsigned long)info,\r\ncrypto_aead_alignmask(geniv) + 1))) {\r\ninfo = kmalloc(ivsize, req->base.flags &\r\nCRYPTO_TFM_REQ_MAY_SLEEP ? GFP_KERNEL:\r\nGFP_ATOMIC);\r\nif (!info)\r\nreturn -ENOMEM;\r\nmemcpy(info, req->iv, ivsize);\r\ncompl = seqiv_aead_encrypt_complete;\r\ndata = req;\r\n}\r\naead_request_set_callback(subreq, req->base.flags, compl, data);\r\naead_request_set_crypt(subreq, req->dst, req->dst,\r\nreq->cryptlen - ivsize, info);\r\naead_request_set_ad(subreq, req->assoclen + ivsize);\r\ncrypto_xor(info, ctx->salt, ivsize);\r\nscatterwalk_map_and_copy(info, req->dst, req->assoclen, ivsize, 1);\r\nerr = crypto_aead_encrypt(subreq);\r\nif (unlikely(info != req->iv))\r\nseqiv_aead_encrypt_complete2(req, err);\r\nreturn err;\r\n}\r\nstatic int seqiv_aead_decrypt(struct aead_request *req)\r\n{\r\nstruct crypto_aead *geniv = crypto_aead_reqtfm(req);\r\nstruct aead_geniv_ctx *ctx = crypto_aead_ctx(geniv);\r\nstruct aead_request *subreq = aead_request_ctx(req);\r\ncrypto_completion_t compl;\r\nvoid *data;\r\nunsigned int ivsize = 8;\r\nif (req->cryptlen < ivsize + crypto_aead_authsize(geniv))\r\nreturn -EINVAL;\r\naead_request_set_tfm(subreq, ctx->child);\r\ncompl = req->base.complete;\r\ndata = req->base.data;\r\naead_request_set_callback(subreq, req->base.flags, compl, data);\r\naead_request_set_crypt(subreq, req->src, req->dst,\r\nreq->cryptlen - ivsize, req->iv);\r\naead_request_set_ad(subreq, req->assoclen + ivsize);\r\nscatterwalk_map_and_copy(req->iv, req->src, req->assoclen, ivsize, 0);\r\nreturn crypto_aead_decrypt(subreq);\r\n}\r\nstatic int seqiv_aead_create(struct crypto_template *tmpl, struct rtattr **tb)\r\n{\r\nstruct aead_instance *inst;\r\nstruct crypto_aead_spawn *spawn;\r\nstruct aead_alg *alg;\r\nint err;\r\ninst = aead_geniv_alloc(tmpl, tb, 0, 0);\r\nif (IS_ERR(inst))\r\nreturn PTR_ERR(inst);\r\nspawn = aead_instance_ctx(inst);\r\nalg = crypto_spawn_aead_alg(spawn);\r\nerr = -EINVAL;\r\nif (inst->alg.ivsize != sizeof(u64))\r\ngoto free_inst;\r\ninst->alg.encrypt = seqiv_aead_encrypt;\r\ninst->alg.decrypt = seqiv_aead_decrypt;\r\ninst->alg.init = aead_init_geniv;\r\ninst->alg.exit = aead_exit_geniv;\r\ninst->alg.base.cra_ctxsize = sizeof(struct aead_geniv_ctx);\r\ninst->alg.base.cra_ctxsize += inst->alg.ivsize;\r\nerr = aead_register_instance(tmpl, inst);\r\nif (err)\r\ngoto free_inst;\r\nout:\r\nreturn err;\r\nfree_inst:\r\naead_geniv_free(inst);\r\ngoto out;\r\n}\r\nstatic int seqiv_create(struct crypto_template *tmpl, struct rtattr **tb)\r\n{\r\nstruct crypto_attr_type *algt;\r\nalgt = crypto_get_attr_type(tb);\r\nif (IS_ERR(algt))\r\nreturn PTR_ERR(algt);\r\nif ((algt->type ^ CRYPTO_ALG_TYPE_AEAD) & CRYPTO_ALG_TYPE_MASK)\r\nreturn -EINVAL;\r\nreturn seqiv_aead_create(tmpl, tb);\r\n}\r\nstatic void seqiv_free(struct crypto_instance *inst)\r\n{\r\naead_geniv_free(aead_instance(inst));\r\n}\r\nstatic int __init seqiv_module_init(void)\r\n{\r\nreturn crypto_register_template(&seqiv_tmpl);\r\n}\r\nstatic void __exit seqiv_module_exit(void)\r\n{\r\ncrypto_unregister_template(&seqiv_tmpl);\r\n}
