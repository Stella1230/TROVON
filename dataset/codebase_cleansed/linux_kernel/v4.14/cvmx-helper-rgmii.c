int __cvmx_helper_rgmii_probe(int interface)\r\n{\r\nint num_ports = 0;\r\nunion cvmx_gmxx_inf_mode mode;\r\nmode.u64 = cvmx_read_csr(CVMX_GMXX_INF_MODE(interface));\r\nif (mode.s.type) {\r\nif (OCTEON_IS_MODEL(OCTEON_CN38XX)\r\n|| OCTEON_IS_MODEL(OCTEON_CN58XX)) {\r\ncvmx_dprintf("ERROR: RGMII initialize called in "\r\n"SPI interface\n");\r\n} else if (OCTEON_IS_MODEL(OCTEON_CN31XX)\r\n|| OCTEON_IS_MODEL(OCTEON_CN30XX)\r\n|| OCTEON_IS_MODEL(OCTEON_CN50XX)) {\r\nnum_ports = 2;\r\n} else {\r\ncvmx_dprintf("ERROR: Unsupported Octeon model in %s\n",\r\n__func__);\r\n}\r\n} else {\r\nif (OCTEON_IS_MODEL(OCTEON_CN38XX)\r\n|| OCTEON_IS_MODEL(OCTEON_CN58XX)) {\r\nnum_ports = 4;\r\n} else if (OCTEON_IS_MODEL(OCTEON_CN31XX)\r\n|| OCTEON_IS_MODEL(OCTEON_CN30XX)\r\n|| OCTEON_IS_MODEL(OCTEON_CN50XX)) {\r\nnum_ports = 3;\r\n} else {\r\ncvmx_dprintf("ERROR: Unsupported Octeon model in %s\n",\r\n__func__);\r\n}\r\n}\r\nreturn num_ports;\r\n}\r\nvoid cvmx_helper_rgmii_internal_loopback(int port)\r\n{\r\nint interface = (port >> 4) & 1;\r\nint index = port & 0xf;\r\nuint64_t tmp;\r\nunion cvmx_gmxx_prtx_cfg gmx_cfg;\r\ngmx_cfg.u64 = 0;\r\ngmx_cfg.s.duplex = 1;\r\ngmx_cfg.s.slottime = 1;\r\ngmx_cfg.s.speed = 1;\r\ncvmx_write_csr(CVMX_GMXX_TXX_CLK(index, interface), 1);\r\ncvmx_write_csr(CVMX_GMXX_TXX_SLOT(index, interface), 0x200);\r\ncvmx_write_csr(CVMX_GMXX_TXX_BURST(index, interface), 0x2000);\r\ncvmx_write_csr(CVMX_GMXX_PRTX_CFG(index, interface), gmx_cfg.u64);\r\ntmp = cvmx_read_csr(CVMX_ASXX_PRT_LOOP(interface));\r\ncvmx_write_csr(CVMX_ASXX_PRT_LOOP(interface), (1 << index) | tmp);\r\ntmp = cvmx_read_csr(CVMX_ASXX_TX_PRT_EN(interface));\r\ncvmx_write_csr(CVMX_ASXX_TX_PRT_EN(interface), (1 << index) | tmp);\r\ntmp = cvmx_read_csr(CVMX_ASXX_RX_PRT_EN(interface));\r\ncvmx_write_csr(CVMX_ASXX_RX_PRT_EN(interface), (1 << index) | tmp);\r\ngmx_cfg.s.en = 1;\r\ncvmx_write_csr(CVMX_GMXX_PRTX_CFG(index, interface), gmx_cfg.u64);\r\n}\r\nstatic int __cvmx_helper_errata_asx_pass1(int interface, int port,\r\nint cpu_clock_hz)\r\n{\r\nif (cpu_clock_hz >= 325000000 && cpu_clock_hz < 375000000)\r\ncvmx_write_csr(CVMX_ASXX_TX_HI_WATERX(port, interface), 12);\r\nelse if (cpu_clock_hz >= 375000000 && cpu_clock_hz < 437000000)\r\ncvmx_write_csr(CVMX_ASXX_TX_HI_WATERX(port, interface), 11);\r\nelse if (cpu_clock_hz >= 437000000 && cpu_clock_hz < 550000000)\r\ncvmx_write_csr(CVMX_ASXX_TX_HI_WATERX(port, interface), 10);\r\nelse if (cpu_clock_hz >= 550000000 && cpu_clock_hz < 687000000)\r\ncvmx_write_csr(CVMX_ASXX_TX_HI_WATERX(port, interface), 9);\r\nelse\r\ncvmx_dprintf("Illegal clock frequency (%d). "\r\n"CVMX_ASXX_TX_HI_WATERX not set\n", cpu_clock_hz);\r\nreturn 0;\r\n}\r\nint __cvmx_helper_rgmii_enable(int interface)\r\n{\r\nint num_ports = cvmx_helper_ports_on_interface(interface);\r\nint port;\r\nstruct cvmx_sysinfo *sys_info_ptr = cvmx_sysinfo_get();\r\nunion cvmx_gmxx_inf_mode mode;\r\nunion cvmx_asxx_tx_prt_en asx_tx;\r\nunion cvmx_asxx_rx_prt_en asx_rx;\r\nmode.u64 = cvmx_read_csr(CVMX_GMXX_INF_MODE(interface));\r\nif (mode.s.en == 0)\r\nreturn -1;\r\nif ((OCTEON_IS_MODEL(OCTEON_CN38XX) ||\r\nOCTEON_IS_MODEL(OCTEON_CN58XX)) && mode.s.type == 1)\r\nreturn -1;\r\nasx_tx.u64 = 0;\r\nasx_tx.s.prt_en = cvmx_build_mask(num_ports);\r\ncvmx_write_csr(CVMX_ASXX_TX_PRT_EN(interface), asx_tx.u64);\r\nasx_rx.u64 = 0;\r\nasx_rx.s.prt_en = cvmx_build_mask(num_ports);\r\ncvmx_write_csr(CVMX_ASXX_RX_PRT_EN(interface), asx_rx.u64);\r\nfor (port = 0; port < num_ports; port++) {\r\nif (cvmx_octeon_is_pass1())\r\n__cvmx_helper_errata_asx_pass1(interface, port,\r\nsys_info_ptr->\r\ncpu_clock_hz);\r\nelse {\r\nunion cvmx_gmxx_rxx_frm_ctl frm_ctl;\r\nfrm_ctl.u64 =\r\ncvmx_read_csr(CVMX_GMXX_RXX_FRM_CTL\r\n(port, interface));\r\nfrm_ctl.s.pre_free = 1;\r\ncvmx_write_csr(CVMX_GMXX_RXX_FRM_CTL(port, interface),\r\nfrm_ctl.u64);\r\n}\r\ncvmx_write_csr(CVMX_GMXX_TXX_PAUSE_PKT_TIME(port, interface),\r\n20000);\r\ncvmx_write_csr(CVMX_GMXX_TXX_PAUSE_PKT_INTERVAL\r\n(port, interface), 19000);\r\nif (OCTEON_IS_MODEL(OCTEON_CN50XX)) {\r\ncvmx_write_csr(CVMX_ASXX_TX_CLK_SETX(port, interface),\r\n16);\r\ncvmx_write_csr(CVMX_ASXX_RX_CLK_SETX(port, interface),\r\n16);\r\n} else {\r\ncvmx_write_csr(CVMX_ASXX_TX_CLK_SETX(port, interface),\r\n24);\r\ncvmx_write_csr(CVMX_ASXX_RX_CLK_SETX(port, interface),\r\n24);\r\n}\r\n}\r\n__cvmx_helper_setup_gmx(interface, num_ports);\r\nfor (port = 0; port < num_ports; port++) {\r\nunion cvmx_gmxx_prtx_cfg gmx_cfg;\r\ngmx_cfg.u64 =\r\ncvmx_read_csr(CVMX_GMXX_PRTX_CFG(port, interface));\r\ngmx_cfg.s.en = 1;\r\ncvmx_write_csr(CVMX_GMXX_PRTX_CFG(port, interface),\r\ngmx_cfg.u64);\r\n}\r\n__cvmx_interrupt_asxx_enable(interface);\r\n__cvmx_interrupt_gmxx_enable(interface);\r\nreturn 0;\r\n}\r\ncvmx_helper_link_info_t __cvmx_helper_rgmii_link_get(int ipd_port)\r\n{\r\nint interface = cvmx_helper_get_interface_num(ipd_port);\r\nint index = cvmx_helper_get_interface_index_num(ipd_port);\r\nunion cvmx_asxx_prt_loop asxx_prt_loop;\r\nasxx_prt_loop.u64 = cvmx_read_csr(CVMX_ASXX_PRT_LOOP(interface));\r\nif (asxx_prt_loop.s.int_loop & (1 << index)) {\r\ncvmx_helper_link_info_t result;\r\nresult.u64 = 0;\r\nresult.s.full_duplex = 1;\r\nresult.s.link_up = 1;\r\nresult.s.speed = 1000;\r\nreturn result;\r\n} else\r\nreturn __cvmx_helper_board_link_get(ipd_port);\r\n}\r\nint __cvmx_helper_rgmii_link_set(int ipd_port,\r\ncvmx_helper_link_info_t link_info)\r\n{\r\nint result = 0;\r\nint interface = cvmx_helper_get_interface_num(ipd_port);\r\nint index = cvmx_helper_get_interface_index_num(ipd_port);\r\nunion cvmx_gmxx_prtx_cfg original_gmx_cfg;\r\nunion cvmx_gmxx_prtx_cfg new_gmx_cfg;\r\nunion cvmx_pko_mem_queue_qos pko_mem_queue_qos;\r\nunion cvmx_pko_mem_queue_qos pko_mem_queue_qos_save[16];\r\nunion cvmx_gmxx_tx_ovr_bp gmx_tx_ovr_bp;\r\nunion cvmx_gmxx_tx_ovr_bp gmx_tx_ovr_bp_save;\r\nint i;\r\nif (cvmx_sysinfo_get()->board_type == CVMX_BOARD_TYPE_SIM)\r\nreturn 0;\r\noriginal_gmx_cfg.u64 =\r\ncvmx_read_csr(CVMX_GMXX_PRTX_CFG(index, interface));\r\nnew_gmx_cfg = original_gmx_cfg;\r\ncvmx_write_csr(CVMX_ASXX_RX_PRT_EN(interface),\r\ncvmx_read_csr(CVMX_ASXX_RX_PRT_EN(interface)) &\r\n~(1 << index));\r\nmemset(pko_mem_queue_qos_save, 0, sizeof(pko_mem_queue_qos_save));\r\nfor (i = 0; i < cvmx_pko_get_num_queues(ipd_port); i++) {\r\nint queue = cvmx_pko_get_base_queue(ipd_port) + i;\r\ncvmx_write_csr(CVMX_PKO_REG_READ_IDX, queue);\r\npko_mem_queue_qos.u64 = cvmx_read_csr(CVMX_PKO_MEM_QUEUE_QOS);\r\npko_mem_queue_qos.s.pid = ipd_port;\r\npko_mem_queue_qos.s.qid = queue;\r\npko_mem_queue_qos_save[i] = pko_mem_queue_qos;\r\npko_mem_queue_qos.s.qos_mask = 0;\r\ncvmx_write_csr(CVMX_PKO_MEM_QUEUE_QOS, pko_mem_queue_qos.u64);\r\n}\r\ngmx_tx_ovr_bp.u64 = cvmx_read_csr(CVMX_GMXX_TX_OVR_BP(interface));\r\ngmx_tx_ovr_bp_save = gmx_tx_ovr_bp;\r\ngmx_tx_ovr_bp.s.bp &= ~(1 << index);\r\ngmx_tx_ovr_bp.s.en |= 1 << index;\r\ncvmx_write_csr(CVMX_GMXX_TX_OVR_BP(interface), gmx_tx_ovr_bp.u64);\r\ncvmx_read_csr(CVMX_GMXX_TX_OVR_BP(interface));\r\ncvmx_write_csr(CVMX_NPI_DBG_SELECT,\r\ninterface * 0x800 + index * 0x100 + 0x880);\r\nCVMX_WAIT_FOR_FIELD64(CVMX_DBG_DATA, union cvmx_dbg_data, data & 7,\r\n==, 0, 10000);\r\nCVMX_WAIT_FOR_FIELD64(CVMX_DBG_DATA, union cvmx_dbg_data, data & 0xf,\r\n==, 0, 10000);\r\nnew_gmx_cfg.s.en = 0;\r\ncvmx_write_csr(CVMX_GMXX_PRTX_CFG(index, interface), new_gmx_cfg.u64);\r\ncvmx_read_csr(CVMX_GMXX_PRTX_CFG(index, interface));\r\nif (cvmx_octeon_is_pass1())\r\nnew_gmx_cfg.s.duplex = 1;\r\nelse if (!link_info.s.link_up)\r\nnew_gmx_cfg.s.duplex = 1;\r\nelse\r\nnew_gmx_cfg.s.duplex = link_info.s.full_duplex;\r\nif (link_info.s.speed == 10) {\r\nnew_gmx_cfg.s.slottime = 0;\r\nnew_gmx_cfg.s.speed = 0;\r\n} else if (link_info.s.speed == 100) {\r\nnew_gmx_cfg.s.slottime = 0;\r\nnew_gmx_cfg.s.speed = 0;\r\n} else {\r\nnew_gmx_cfg.s.slottime = 1;\r\nnew_gmx_cfg.s.speed = 1;\r\n}\r\nif (link_info.s.speed == 10) {\r\ncvmx_write_csr(CVMX_GMXX_TXX_CLK(index, interface), 50);\r\ncvmx_write_csr(CVMX_GMXX_TXX_SLOT(index, interface), 0x40);\r\ncvmx_write_csr(CVMX_GMXX_TXX_BURST(index, interface), 0);\r\n} else if (link_info.s.speed == 100) {\r\ncvmx_write_csr(CVMX_GMXX_TXX_CLK(index, interface), 5);\r\ncvmx_write_csr(CVMX_GMXX_TXX_SLOT(index, interface), 0x40);\r\ncvmx_write_csr(CVMX_GMXX_TXX_BURST(index, interface), 0);\r\n} else {\r\ncvmx_write_csr(CVMX_GMXX_TXX_CLK(index, interface), 1);\r\ncvmx_write_csr(CVMX_GMXX_TXX_SLOT(index, interface), 0x200);\r\ncvmx_write_csr(CVMX_GMXX_TXX_BURST(index, interface), 0x2000);\r\n}\r\nif (OCTEON_IS_MODEL(OCTEON_CN30XX) || OCTEON_IS_MODEL(OCTEON_CN50XX)) {\r\nif ((link_info.s.speed == 10) || (link_info.s.speed == 100)) {\r\nunion cvmx_gmxx_inf_mode mode;\r\nmode.u64 = cvmx_read_csr(CVMX_GMXX_INF_MODE(interface));\r\nif (((index == 0) && (mode.s.p0mii == 1))\r\n|| ((index != 0) && (mode.s.type == 1))) {\r\ncvmx_write_csr(CVMX_GMXX_TXX_CLK\r\n(index, interface), 1);\r\n}\r\n}\r\n}\r\ncvmx_read_csr(CVMX_GMXX_PRTX_CFG(index, interface));\r\ncvmx_write_csr(CVMX_GMXX_PRTX_CFG(index, interface), new_gmx_cfg.u64);\r\ncvmx_write_csr(CVMX_ASXX_RX_PRT_EN(interface),\r\ncvmx_read_csr(CVMX_ASXX_RX_PRT_EN(interface)) | (1 <<\r\nindex));\r\nfor (i = 0; i < cvmx_pko_get_num_queues(ipd_port); i++) {\r\nint queue = cvmx_pko_get_base_queue(ipd_port) + i;\r\ncvmx_write_csr(CVMX_PKO_REG_READ_IDX, queue);\r\ncvmx_write_csr(CVMX_PKO_MEM_QUEUE_QOS,\r\npko_mem_queue_qos_save[i].u64);\r\n}\r\ncvmx_write_csr(CVMX_GMXX_TX_OVR_BP(interface), gmx_tx_ovr_bp_save.u64);\r\nnew_gmx_cfg.s.en = original_gmx_cfg.s.en;\r\ncvmx_write_csr(CVMX_GMXX_PRTX_CFG(index, interface), new_gmx_cfg.u64);\r\nreturn result;\r\n}\r\nint __cvmx_helper_rgmii_configure_loopback(int ipd_port, int enable_internal,\r\nint enable_external)\r\n{\r\nint interface = cvmx_helper_get_interface_num(ipd_port);\r\nint index = cvmx_helper_get_interface_index_num(ipd_port);\r\nint original_enable;\r\nunion cvmx_gmxx_prtx_cfg gmx_cfg;\r\nunion cvmx_asxx_prt_loop asxx_prt_loop;\r\ngmx_cfg.u64 = cvmx_read_csr(CVMX_GMXX_PRTX_CFG(index, interface));\r\noriginal_enable = gmx_cfg.s.en;\r\ngmx_cfg.s.en = 0;\r\nif (enable_internal) {\r\ngmx_cfg.s.duplex = 1;\r\ngmx_cfg.s.slottime = 1;\r\ngmx_cfg.s.speed = 1;\r\ncvmx_write_csr(CVMX_GMXX_TXX_CLK(index, interface), 1);\r\ncvmx_write_csr(CVMX_GMXX_TXX_SLOT(index, interface), 0x200);\r\ncvmx_write_csr(CVMX_GMXX_TXX_BURST(index, interface), 0x2000);\r\n}\r\ncvmx_write_csr(CVMX_GMXX_PRTX_CFG(index, interface), gmx_cfg.u64);\r\nasxx_prt_loop.u64 = cvmx_read_csr(CVMX_ASXX_PRT_LOOP(interface));\r\nif (enable_internal)\r\nasxx_prt_loop.s.int_loop |= 1 << index;\r\nelse\r\nasxx_prt_loop.s.int_loop &= ~(1 << index);\r\nif (enable_external)\r\nasxx_prt_loop.s.ext_loop |= 1 << index;\r\nelse\r\nasxx_prt_loop.s.ext_loop &= ~(1 << index);\r\ncvmx_write_csr(CVMX_ASXX_PRT_LOOP(interface), asxx_prt_loop.u64);\r\nif (enable_internal) {\r\nuint64_t tmp;\r\ntmp = cvmx_read_csr(CVMX_ASXX_TX_PRT_EN(interface));\r\ncvmx_write_csr(CVMX_ASXX_TX_PRT_EN(interface),\r\n(1 << index) | tmp);\r\ntmp = cvmx_read_csr(CVMX_ASXX_RX_PRT_EN(interface));\r\ncvmx_write_csr(CVMX_ASXX_RX_PRT_EN(interface),\r\n(1 << index) | tmp);\r\noriginal_enable = 1;\r\n}\r\ngmx_cfg.s.en = original_enable;\r\ncvmx_write_csr(CVMX_GMXX_PRTX_CFG(index, interface), gmx_cfg.u64);\r\nreturn 0;\r\n}
