static void update_fim_nominal(struct imx_media_fim *fim,\r\nconst struct v4l2_fract *fi)\r\n{\r\nif (fi->denominator == 0) {\r\ndev_dbg(fim->sd->dev, "no frame interval, FIM disabled\n");\r\nfim->enabled = false;\r\nreturn;\r\n}\r\nfim->nominal = DIV_ROUND_CLOSEST_ULL(1000000ULL * (u64)fi->numerator,\r\nfi->denominator);\r\ndev_dbg(fim->sd->dev, "FI=%lu usec\n", fim->nominal);\r\n}\r\nstatic void reset_fim(struct imx_media_fim *fim, bool curval)\r\n{\r\nstruct v4l2_ctrl *icap_chan = fim->icap_ctrl[FIM_CL_ICAP_CHANNEL];\r\nstruct v4l2_ctrl *icap_edge = fim->icap_ctrl[FIM_CL_ICAP_EDGE];\r\nstruct v4l2_ctrl *en = fim->ctrl[FIM_CL_ENABLE];\r\nstruct v4l2_ctrl *num = fim->ctrl[FIM_CL_NUM];\r\nstruct v4l2_ctrl *skip = fim->ctrl[FIM_CL_NUM_SKIP];\r\nstruct v4l2_ctrl *tol_min = fim->ctrl[FIM_CL_TOLERANCE_MIN];\r\nstruct v4l2_ctrl *tol_max = fim->ctrl[FIM_CL_TOLERANCE_MAX];\r\nif (curval) {\r\nfim->enabled = en->cur.val;\r\nfim->icap_flags = icap_edge->cur.val;\r\nfim->icap_channel = icap_chan->cur.val;\r\nfim->num_avg = num->cur.val;\r\nfim->num_skip = skip->cur.val;\r\nfim->tolerance_min = tol_min->cur.val;\r\nfim->tolerance_max = tol_max->cur.val;\r\n} else {\r\nfim->enabled = en->val;\r\nfim->icap_flags = icap_edge->val;\r\nfim->icap_channel = icap_chan->val;\r\nfim->num_avg = num->val;\r\nfim->num_skip = skip->val;\r\nfim->tolerance_min = tol_min->val;\r\nfim->tolerance_max = tol_max->val;\r\n}\r\nif (fim->tolerance_max <= fim->tolerance_min)\r\nfim->tolerance_max = 0;\r\nif (!icap_enabled(fim))\r\nfim->num_skip = max_t(int, fim->num_skip, 1);\r\nfim->counter = -fim->num_skip;\r\nfim->sum = 0;\r\n}\r\nstatic void send_fim_event(struct imx_media_fim *fim, unsigned long error)\r\n{\r\nstatic const struct v4l2_event ev = {\r\n.type = V4L2_EVENT_IMX_FRAME_INTERVAL_ERROR,\r\n};\r\nv4l2_subdev_notify_event(fim->sd, &ev);\r\n}\r\nstatic void frame_interval_monitor(struct imx_media_fim *fim,\r\nstruct timespec *ts)\r\n{\r\nunsigned long interval, error, error_avg;\r\nbool send_event = false;\r\nstruct timespec diff;\r\nif (!fim->enabled || ++fim->counter <= 0)\r\ngoto out_update_ts;\r\ndiff = timespec_sub(*ts, fim->last_ts);\r\ninterval = diff.tv_sec * 1000 * 1000 + diff.tv_nsec / 1000;\r\nerror = abs(interval - fim->nominal);\r\nif (fim->tolerance_max && error >= fim->tolerance_max) {\r\ndev_dbg(fim->sd->dev,\r\n"FIM: %lu ignored, out of tolerance bounds\n",\r\nerror);\r\nfim->counter--;\r\ngoto out_update_ts;\r\n}\r\nfim->sum += error;\r\nif (fim->counter == fim->num_avg) {\r\nerror_avg = DIV_ROUND_CLOSEST(fim->sum, fim->num_avg);\r\nif (error_avg > fim->tolerance_min)\r\nsend_event = true;\r\ndev_dbg(fim->sd->dev, "FIM: error: %lu usec%s\n",\r\nerror_avg, send_event ? " (!!!)" : "");\r\nfim->counter = 0;\r\nfim->sum = 0;\r\n}\r\nout_update_ts:\r\nfim->last_ts = *ts;\r\nif (send_event)\r\nsend_fim_event(fim, error_avg);\r\n}\r\nstatic void fim_input_capture_handler(int channel, void *dev_id,\r\nstruct timespec *ts)\r\n{\r\nstruct imx_media_fim *fim = dev_id;\r\nunsigned long flags;\r\nspin_lock_irqsave(&fim->lock, flags);\r\nframe_interval_monitor(fim, ts);\r\nif (!completion_done(&fim->icap_first_event))\r\ncomplete(&fim->icap_first_event);\r\nspin_unlock_irqrestore(&fim->lock, flags);\r\n}\r\nstatic int fim_request_input_capture(struct imx_media_fim *fim)\r\n{\r\ninit_completion(&fim->icap_first_event);\r\nreturn mxc_request_input_capture(fim->icap_channel,\r\nfim_input_capture_handler,\r\nfim->icap_flags, fim);\r\n}\r\nstatic void fim_free_input_capture(struct imx_media_fim *fim)\r\n{\r\nmxc_free_input_capture(fim->icap_channel, fim);\r\n}\r\nstatic int fim_request_input_capture(struct imx_media_fim *fim)\r\n{\r\nreturn 0;\r\n}\r\nstatic void fim_free_input_capture(struct imx_media_fim *fim)\r\n{\r\n}\r\nstatic void fim_acquire_first_ts(struct imx_media_fim *fim)\r\n{\r\nunsigned long ret;\r\nif (!fim->enabled || fim->num_skip > 0)\r\nreturn;\r\nret = wait_for_completion_timeout(\r\n&fim->icap_first_event,\r\nmsecs_to_jiffies(IMX_MEDIA_EOF_TIMEOUT));\r\nif (ret == 0)\r\nv4l2_warn(fim->sd, "wait first icap event timeout\n");\r\n}\r\nstatic int fim_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct imx_media_fim *fim = container_of(ctrl->handler,\r\nstruct imx_media_fim,\r\nctrl_handler);\r\nunsigned long flags;\r\nint ret = 0;\r\nspin_lock_irqsave(&fim->lock, flags);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_IMX_FIM_ENABLE:\r\nbreak;\r\ncase V4L2_CID_IMX_FIM_ICAP_EDGE:\r\nif (fim->stream_on)\r\nret = -EBUSY;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nif (!ret)\r\nreset_fim(fim, false);\r\nspin_unlock_irqrestore(&fim->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int init_fim_controls(struct imx_media_fim *fim)\r\n{\r\nstruct v4l2_ctrl_handler *hdlr = &fim->ctrl_handler;\r\nint i, ret;\r\nv4l2_ctrl_handler_init(hdlr, FIM_NUM_CONTROLS + FIM_NUM_ICAP_CONTROLS);\r\nfor (i = 0; i < FIM_NUM_CONTROLS; i++)\r\nfim->ctrl[i] = v4l2_ctrl_new_custom(hdlr,\r\n&fim_ctrl[i],\r\nNULL);\r\nfor (i = 0; i < FIM_NUM_ICAP_CONTROLS; i++)\r\nfim->icap_ctrl[i] = v4l2_ctrl_new_custom(hdlr,\r\n&fim_icap_ctrl[i],\r\nNULL);\r\nif (hdlr->error) {\r\nret = hdlr->error;\r\ngoto err_free;\r\n}\r\nv4l2_ctrl_cluster(FIM_NUM_CONTROLS, fim->ctrl);\r\nv4l2_ctrl_cluster(FIM_NUM_ICAP_CONTROLS, fim->icap_ctrl);\r\nreturn 0;\r\nerr_free:\r\nv4l2_ctrl_handler_free(hdlr);\r\nreturn ret;\r\n}\r\nvoid imx_media_fim_eof_monitor(struct imx_media_fim *fim, struct timespec *ts)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&fim->lock, flags);\r\nif (!icap_enabled(fim))\r\nframe_interval_monitor(fim, ts);\r\nspin_unlock_irqrestore(&fim->lock, flags);\r\n}\r\nint imx_media_fim_set_stream(struct imx_media_fim *fim,\r\nconst struct v4l2_fract *fi,\r\nbool on)\r\n{\r\nunsigned long flags;\r\nint ret = 0;\r\nv4l2_ctrl_lock(fim->ctrl[FIM_CL_ENABLE]);\r\nif (fim->stream_on == on)\r\ngoto out;\r\nif (on) {\r\nspin_lock_irqsave(&fim->lock, flags);\r\nreset_fim(fim, true);\r\nupdate_fim_nominal(fim, fi);\r\nspin_unlock_irqrestore(&fim->lock, flags);\r\nif (icap_enabled(fim)) {\r\nret = fim_request_input_capture(fim);\r\nif (ret)\r\ngoto out;\r\nfim_acquire_first_ts(fim);\r\n}\r\n} else {\r\nif (icap_enabled(fim))\r\nfim_free_input_capture(fim);\r\n}\r\nfim->stream_on = on;\r\nout:\r\nv4l2_ctrl_unlock(fim->ctrl[FIM_CL_ENABLE]);\r\nreturn ret;\r\n}\r\nint imx_media_fim_add_controls(struct imx_media_fim *fim)\r\n{\r\nreturn v4l2_ctrl_add_handler(fim->sd->ctrl_handler,\r\n&fim->ctrl_handler, NULL);\r\n}\r\nstruct imx_media_fim *imx_media_fim_init(struct v4l2_subdev *sd)\r\n{\r\nstruct imx_media_fim *fim;\r\nint ret;\r\nfim = devm_kzalloc(sd->dev, sizeof(*fim), GFP_KERNEL);\r\nif (!fim)\r\nreturn ERR_PTR(-ENOMEM);\r\nfim->md = dev_get_drvdata(sd->v4l2_dev->dev);\r\nfim->sd = sd;\r\nspin_lock_init(&fim->lock);\r\nret = init_fim_controls(fim);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\nreturn fim;\r\n}\r\nvoid imx_media_fim_free(struct imx_media_fim *fim)\r\n{\r\nv4l2_ctrl_handler_free(&fim->ctrl_handler);\r\n}
