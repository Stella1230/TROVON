static long\r\nuctrl_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nswitch (cmd) {\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nuctrl_open(struct inode *inode, struct file *file)\r\n{\r\nmutex_lock(&uctrl_mutex);\r\nuctrl_get_event_status(global_driver);\r\nuctrl_get_external_status(global_driver);\r\nmutex_unlock(&uctrl_mutex);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t uctrl_interrupt(int irq, void *dev_id)\r\n{\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void uctrl_do_txn(struct uctrl_driver *driver, struct uctrl_txn *txn)\r\n{\r\nint stat, incnt, outcnt, bytecnt, intr;\r\nu32 byte;\r\nstat = sbus_readl(&driver->regs->uctrl_stat);\r\nintr = sbus_readl(&driver->regs->uctrl_intr);\r\nsbus_writel(stat, &driver->regs->uctrl_stat);\r\ndprintk(("interrupt stat 0x%x int 0x%x\n", stat, intr));\r\nincnt = txn->inbits;\r\noutcnt = txn->outbits;\r\nbyte = (txn->opcode << 8);\r\nWRITEUCTLDATA(byte);\r\nbytecnt = 0;\r\nwhile (incnt > 0) {\r\nbyte = (txn->inbuf[bytecnt] << 8);\r\nWRITEUCTLDATA(byte);\r\nincnt--;\r\nbytecnt++;\r\n}\r\nREADUCTLDATA(byte);\r\ndprintk(("ack was %x\n", (byte >> 8)));\r\nbytecnt = 0;\r\nwhile (outcnt > 0) {\r\nREADUCTLDATA(byte);\r\ntxn->outbuf[bytecnt] = (byte >> 8);\r\ndprintk(("set byte to %02x\n", byte));\r\noutcnt--;\r\nbytecnt++;\r\n}\r\n}\r\nstatic void uctrl_get_event_status(struct uctrl_driver *driver)\r\n{\r\nstruct uctrl_txn txn;\r\nu8 outbits[2];\r\ntxn.opcode = READ_EVENT_STATUS;\r\ntxn.inbits = 0;\r\ntxn.outbits = 2;\r\ntxn.inbuf = NULL;\r\ntxn.outbuf = outbits;\r\nuctrl_do_txn(driver, &txn);\r\ndprintk(("bytes %x %x\n", (outbits[0] & 0xff), (outbits[1] & 0xff)));\r\ndriver->status.event_status =\r\n((outbits[0] & 0xff) << 8) | (outbits[1] & 0xff);\r\ndprintk(("ev is %x\n", driver->status.event_status));\r\n}\r\nstatic void uctrl_get_external_status(struct uctrl_driver *driver)\r\n{\r\nstruct uctrl_txn txn;\r\nu8 outbits[2];\r\nint i, v;\r\ntxn.opcode = READ_EXTERNAL_STATUS;\r\ntxn.inbits = 0;\r\ntxn.outbits = 2;\r\ntxn.inbuf = NULL;\r\ntxn.outbuf = outbits;\r\nuctrl_do_txn(driver, &txn);\r\ndprintk(("bytes %x %x\n", (outbits[0] & 0xff), (outbits[1] & 0xff)));\r\ndriver->status.external_status =\r\n((outbits[0] * 256) + (outbits[1]));\r\ndprintk(("ex is %x\n", driver->status.external_status));\r\nv = driver->status.external_status;\r\nfor (i = 0; v != 0; i++, v >>= 1) {\r\nif (v & 1) {\r\ndprintk(("%s%s", " ", uctrl_extstatus[i]));\r\n}\r\n}\r\ndprintk(("\n"));\r\n}\r\nstatic int uctrl_probe(struct platform_device *op)\r\n{\r\nstruct uctrl_driver *p;\r\nint err = -ENOMEM;\r\np = kzalloc(sizeof(*p), GFP_KERNEL);\r\nif (!p) {\r\nprintk(KERN_ERR "uctrl: Unable to allocate device struct.\n");\r\ngoto out;\r\n}\r\np->regs = of_ioremap(&op->resource[0], 0,\r\nresource_size(&op->resource[0]),\r\n"uctrl");\r\nif (!p->regs) {\r\nprintk(KERN_ERR "uctrl: Unable to map registers.\n");\r\ngoto out_free;\r\n}\r\np->irq = op->archdata.irqs[0];\r\nerr = request_irq(p->irq, uctrl_interrupt, 0, "uctrl", p);\r\nif (err) {\r\nprintk(KERN_ERR "uctrl: Unable to register irq.\n");\r\ngoto out_iounmap;\r\n}\r\nerr = misc_register(&uctrl_dev);\r\nif (err) {\r\nprintk(KERN_ERR "uctrl: Unable to register misc device.\n");\r\ngoto out_free_irq;\r\n}\r\nsbus_writel(UCTRL_INTR_RXNE_REQ|UCTRL_INTR_RXNE_MSK, &p->regs->uctrl_intr);\r\nprintk(KERN_INFO "%pOF: uctrl regs[0x%p] (irq %d)\n",\r\nop->dev.of_node, p->regs, p->irq);\r\nuctrl_get_event_status(p);\r\nuctrl_get_external_status(p);\r\ndev_set_drvdata(&op->dev, p);\r\nglobal_driver = p;\r\nout:\r\nreturn err;\r\nout_free_irq:\r\nfree_irq(p->irq, p);\r\nout_iounmap:\r\nof_iounmap(&op->resource[0], p->regs, resource_size(&op->resource[0]));\r\nout_free:\r\nkfree(p);\r\ngoto out;\r\n}\r\nstatic int uctrl_remove(struct platform_device *op)\r\n{\r\nstruct uctrl_driver *p = dev_get_drvdata(&op->dev);\r\nif (p) {\r\nmisc_deregister(&uctrl_dev);\r\nfree_irq(p->irq, p);\r\nof_iounmap(&op->resource[0], p->regs, resource_size(&op->resource[0]));\r\nkfree(p);\r\n}\r\nreturn 0;\r\n}
