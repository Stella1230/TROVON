static int ipipe_validate_lutdpc_params(struct vpfe_ipipe_lutdpc *lutdpc)\r\n{\r\nint i;\r\nif (lutdpc->en > 1 || lutdpc->repl_white > 1 ||\r\nlutdpc->dpc_size > LUT_DPC_MAX_SIZE)\r\nreturn -EINVAL;\r\nif (lutdpc->en && !lutdpc->table)\r\nreturn -EINVAL;\r\nfor (i = 0; i < lutdpc->dpc_size; i++)\r\nif (lutdpc->table[i].horz_pos > LUT_DPC_H_POS_MASK ||\r\nlutdpc->table[i].vert_pos > LUT_DPC_V_POS_MASK)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int ipipe_set_lutdpc_params(struct vpfe_ipipe_device *ipipe, void *param)\r\n{\r\nstruct vpfe_ipipe_lutdpc *lutdpc = &ipipe->config.lutdpc;\r\nstruct vpfe_ipipe_lutdpc *dpc_param;\r\nstruct device *dev;\r\nif (!param) {\r\nmemset((void *)lutdpc, 0, sizeof(struct vpfe_ipipe_lutdpc));\r\ngoto success;\r\n}\r\ndev = ipipe->subdev.v4l2_dev->dev;\r\ndpc_param = param;\r\nlutdpc->en = dpc_param->en;\r\nlutdpc->repl_white = dpc_param->repl_white;\r\nlutdpc->dpc_size = dpc_param->dpc_size;\r\nmemcpy(&lutdpc->table, &dpc_param->table,\r\n(dpc_param->dpc_size * sizeof(struct vpfe_ipipe_lutdpc_entry)));\r\nif (ipipe_validate_lutdpc_params(lutdpc) < 0)\r\nreturn -EINVAL;\r\nsuccess:\r\nipipe_set_lutdpc_regs(ipipe->base_addr, ipipe->isp5_base_addr, lutdpc);\r\nreturn 0;\r\n}\r\nstatic int ipipe_get_lutdpc_params(struct vpfe_ipipe_device *ipipe, void *param)\r\n{\r\nstruct vpfe_ipipe_lutdpc *lut_param = param;\r\nstruct vpfe_ipipe_lutdpc *lutdpc = &ipipe->config.lutdpc;\r\nlut_param->en = lutdpc->en;\r\nlut_param->repl_white = lutdpc->repl_white;\r\nlut_param->dpc_size = lutdpc->dpc_size;\r\nmemcpy(&lut_param->table, &lutdpc->table,\r\n(lutdpc->dpc_size * sizeof(struct vpfe_ipipe_lutdpc_entry)));\r\nreturn 0;\r\n}\r\nstatic int ipipe_set_input_config(struct vpfe_ipipe_device *ipipe, void *param)\r\n{\r\nstruct vpfe_ipipe_input_config *config = &ipipe->config.input_config;\r\nif (!param)\r\nmemset(config, 0, sizeof(struct vpfe_ipipe_input_config));\r\nelse\r\nmemcpy(config, param, sizeof(struct vpfe_ipipe_input_config));\r\nreturn 0;\r\n}\r\nstatic int ipipe_get_input_config(struct vpfe_ipipe_device *ipipe, void *param)\r\n{\r\nstruct vpfe_ipipe_input_config *config = &ipipe->config.input_config;\r\nif (!param)\r\nreturn -EINVAL;\r\nmemcpy(param, config, sizeof(struct vpfe_ipipe_input_config));\r\nreturn 0;\r\n}\r\nstatic int ipipe_validate_otfdpc_params(struct vpfe_ipipe_otfdpc *dpc_param)\r\n{\r\nstruct vpfe_ipipe_otfdpc_2_0_cfg *dpc_2_0;\r\nstruct vpfe_ipipe_otfdpc_3_0_cfg *dpc_3_0;\r\nif (dpc_param->en > 1)\r\nreturn -EINVAL;\r\nif (dpc_param->alg == VPFE_IPIPE_OTFDPC_2_0) {\r\ndpc_2_0 = &dpc_param->alg_cfg.dpc_2_0;\r\nif (dpc_2_0->det_thr.r > OTFDPC_DPC2_THR_MASK ||\r\ndpc_2_0->det_thr.gr > OTFDPC_DPC2_THR_MASK ||\r\ndpc_2_0->det_thr.gb > OTFDPC_DPC2_THR_MASK ||\r\ndpc_2_0->det_thr.b > OTFDPC_DPC2_THR_MASK ||\r\ndpc_2_0->corr_thr.r > OTFDPC_DPC2_THR_MASK ||\r\ndpc_2_0->corr_thr.gr > OTFDPC_DPC2_THR_MASK ||\r\ndpc_2_0->corr_thr.gb > OTFDPC_DPC2_THR_MASK ||\r\ndpc_2_0->corr_thr.b > OTFDPC_DPC2_THR_MASK)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\ndpc_3_0 = &dpc_param->alg_cfg.dpc_3_0;\r\nif (dpc_3_0->act_adj_shf > OTF_DPC3_0_SHF_MASK ||\r\ndpc_3_0->det_thr > OTF_DPC3_0_DET_MASK ||\r\ndpc_3_0->det_slp > OTF_DPC3_0_SLP_MASK ||\r\ndpc_3_0->det_thr_min > OTF_DPC3_0_DET_MASK ||\r\ndpc_3_0->det_thr_max > OTF_DPC3_0_DET_MASK ||\r\ndpc_3_0->corr_thr > OTF_DPC3_0_CORR_MASK ||\r\ndpc_3_0->corr_slp > OTF_DPC3_0_SLP_MASK ||\r\ndpc_3_0->corr_thr_min > OTF_DPC3_0_CORR_MASK ||\r\ndpc_3_0->corr_thr_max > OTF_DPC3_0_CORR_MASK)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int ipipe_set_otfdpc_params(struct vpfe_ipipe_device *ipipe, void *param)\r\n{\r\nstruct vpfe_ipipe_otfdpc *dpc_param = param;\r\nstruct vpfe_ipipe_otfdpc *otfdpc = &ipipe->config.otfdpc;\r\nstruct device *dev;\r\nif (!param) {\r\nmemset((void *)otfdpc, 0, sizeof(struct ipipe_otfdpc_2_0));\r\ngoto success;\r\n}\r\ndev = ipipe->subdev.v4l2_dev->dev;\r\nmemcpy(otfdpc, dpc_param, sizeof(struct vpfe_ipipe_otfdpc));\r\nif (ipipe_validate_otfdpc_params(otfdpc) < 0) {\r\ndev_err(dev, "Invalid otfdpc params\n");\r\nreturn -EINVAL;\r\n}\r\nsuccess:\r\nipipe_set_otfdpc_regs(ipipe->base_addr, otfdpc);\r\nreturn 0;\r\n}\r\nstatic int ipipe_get_otfdpc_params(struct vpfe_ipipe_device *ipipe, void *param)\r\n{\r\nstruct vpfe_ipipe_otfdpc *dpc_param = param;\r\nstruct vpfe_ipipe_otfdpc *otfdpc = &ipipe->config.otfdpc;\r\nmemcpy(dpc_param, otfdpc, sizeof(struct vpfe_ipipe_otfdpc));\r\nreturn 0;\r\n}\r\nstatic int ipipe_validate_nf_params(struct vpfe_ipipe_nf *nf_param)\r\n{\r\nint i;\r\nif (nf_param->en > 1 || nf_param->shft_val > D2F_SHFT_VAL_MASK ||\r\nnf_param->spread_val > D2F_SPR_VAL_MASK ||\r\nnf_param->apply_lsc_gain > 1 ||\r\nnf_param->edge_det_min_thr > D2F_EDGE_DET_THR_MASK ||\r\nnf_param->edge_det_max_thr > D2F_EDGE_DET_THR_MASK)\r\nreturn -EINVAL;\r\nfor (i = 0; i < VPFE_IPIPE_NF_THR_TABLE_SIZE; i++)\r\nif (nf_param->thr[i] > D2F_THR_VAL_MASK)\r\nreturn -EINVAL;\r\nfor (i = 0; i < VPFE_IPIPE_NF_STR_TABLE_SIZE; i++)\r\nif (nf_param->str[i] > D2F_STR_VAL_MASK)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int ipipe_set_nf_params(struct vpfe_ipipe_device *ipipe,\r\nunsigned int id, void *param)\r\n{\r\nstruct vpfe_ipipe_nf *nf_param = param;\r\nstruct vpfe_ipipe_nf *nf = &ipipe->config.nf1;\r\nstruct device *dev;\r\nif (id == IPIPE_D2F_2ND)\r\nnf = &ipipe->config.nf2;\r\nif (!nf_param) {\r\nmemset((void *)nf, 0, sizeof(struct vpfe_ipipe_nf));\r\ngoto success;\r\n}\r\ndev = ipipe->subdev.v4l2_dev->dev;\r\nmemcpy(nf, nf_param, sizeof(struct vpfe_ipipe_nf));\r\nif (ipipe_validate_nf_params(nf) < 0) {\r\ndev_err(dev, "Invalid nf params\n");\r\nreturn -EINVAL;\r\n}\r\nsuccess:\r\nipipe_set_d2f_regs(ipipe->base_addr, id, nf);\r\nreturn 0;\r\n}\r\nstatic int ipipe_set_nf1_params(struct vpfe_ipipe_device *ipipe, void *param)\r\n{\r\nreturn ipipe_set_nf_params(ipipe, IPIPE_D2F_1ST, param);\r\n}\r\nstatic int ipipe_set_nf2_params(struct vpfe_ipipe_device *ipipe, void *param)\r\n{\r\nreturn ipipe_set_nf_params(ipipe, IPIPE_D2F_2ND, param);\r\n}\r\nstatic int ipipe_get_nf_params(struct vpfe_ipipe_device *ipipe,\r\nunsigned int id, void *param)\r\n{\r\nstruct vpfe_ipipe_nf *nf_param = param;\r\nstruct vpfe_ipipe_nf *nf = &ipipe->config.nf1;\r\nif (id == IPIPE_D2F_2ND)\r\nnf = &ipipe->config.nf2;\r\nmemcpy(nf_param, nf, sizeof(struct vpfe_ipipe_nf));\r\nreturn 0;\r\n}\r\nstatic int ipipe_get_nf1_params(struct vpfe_ipipe_device *ipipe, void *param)\r\n{\r\nreturn ipipe_get_nf_params(ipipe, IPIPE_D2F_1ST, param);\r\n}\r\nstatic int ipipe_get_nf2_params(struct vpfe_ipipe_device *ipipe, void *param)\r\n{\r\nreturn ipipe_get_nf_params(ipipe, IPIPE_D2F_2ND, param);\r\n}\r\nstatic int ipipe_validate_gic_params(struct vpfe_ipipe_gic *gic)\r\n{\r\nif (gic->en > 1 || gic->gain > GIC_GAIN_MASK ||\r\ngic->thr > GIC_THR_MASK || gic->slope > GIC_SLOPE_MASK ||\r\ngic->apply_lsc_gain > 1 ||\r\ngic->nf2_thr_gain.integer > GIC_NFGAN_INT_MASK ||\r\ngic->nf2_thr_gain.decimal > GIC_NFGAN_DECI_MASK)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int ipipe_set_gic_params(struct vpfe_ipipe_device *ipipe, void *param)\r\n{\r\nstruct vpfe_ipipe_gic *gic_param = param;\r\nstruct device *dev = ipipe->subdev.v4l2_dev->dev;\r\nstruct vpfe_ipipe_gic *gic = &ipipe->config.gic;\r\nif (!gic_param) {\r\nmemset((void *)gic, 0, sizeof(struct vpfe_ipipe_gic));\r\ngoto success;\r\n}\r\nmemcpy(gic, gic_param, sizeof(struct vpfe_ipipe_gic));\r\nif (ipipe_validate_gic_params(gic) < 0) {\r\ndev_err(dev, "Invalid gic params\n");\r\nreturn -EINVAL;\r\n}\r\nsuccess:\r\nipipe_set_gic_regs(ipipe->base_addr, gic);\r\nreturn 0;\r\n}\r\nstatic int ipipe_get_gic_params(struct vpfe_ipipe_device *ipipe, void *param)\r\n{\r\nstruct vpfe_ipipe_gic *gic_param = param;\r\nstruct vpfe_ipipe_gic *gic = &ipipe->config.gic;\r\nmemcpy(gic_param, gic, sizeof(struct vpfe_ipipe_gic));\r\nreturn 0;\r\n}\r\nstatic int ipipe_validate_wb_params(struct vpfe_ipipe_wb *wbal)\r\n{\r\nif (wbal->ofst_r > WB_OFFSET_MASK ||\r\nwbal->ofst_gr > WB_OFFSET_MASK ||\r\nwbal->ofst_gb > WB_OFFSET_MASK ||\r\nwbal->ofst_b > WB_OFFSET_MASK ||\r\nwbal->gain_r.integer > WB_GAIN_INT_MASK ||\r\nwbal->gain_r.decimal > WB_GAIN_DECI_MASK ||\r\nwbal->gain_gr.integer > WB_GAIN_INT_MASK ||\r\nwbal->gain_gr.decimal > WB_GAIN_DECI_MASK ||\r\nwbal->gain_gb.integer > WB_GAIN_INT_MASK ||\r\nwbal->gain_gb.decimal > WB_GAIN_DECI_MASK ||\r\nwbal->gain_b.integer > WB_GAIN_INT_MASK ||\r\nwbal->gain_b.decimal > WB_GAIN_DECI_MASK)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int ipipe_set_wb_params(struct vpfe_ipipe_device *ipipe, void *param)\r\n{\r\nstruct vpfe_ipipe_wb *wb_param = param;\r\nstruct vpfe_ipipe_wb *wbal = &ipipe->config.wbal;\r\nif (!wb_param) {\r\nconst struct vpfe_ipipe_wb wb_defaults = {\r\n.gain_r = {2, 0x0},\r\n.gain_gr = {2, 0x0},\r\n.gain_gb = {2, 0x0},\r\n.gain_b = {2, 0x0}\r\n};\r\nmemcpy(wbal, &wb_defaults, sizeof(struct vpfe_ipipe_wb));\r\ngoto success;\r\n}\r\nmemcpy(wbal, wb_param, sizeof(struct vpfe_ipipe_wb));\r\nif (ipipe_validate_wb_params(wbal) < 0)\r\nreturn -EINVAL;\r\nsuccess:\r\nipipe_set_wb_regs(ipipe->base_addr, wbal);\r\nreturn 0;\r\n}\r\nstatic int ipipe_get_wb_params(struct vpfe_ipipe_device *ipipe, void *param)\r\n{\r\nstruct vpfe_ipipe_wb *wb_param = param;\r\nstruct vpfe_ipipe_wb *wbal = &ipipe->config.wbal;\r\nmemcpy(wb_param, wbal, sizeof(struct vpfe_ipipe_wb));\r\nreturn 0;\r\n}\r\nstatic int ipipe_validate_cfa_params(struct vpfe_ipipe_cfa *cfa)\r\n{\r\nif (cfa->hpf_thr_2dir > CFA_HPF_THR_2DIR_MASK ||\r\ncfa->hpf_slp_2dir > CFA_HPF_SLOPE_2DIR_MASK ||\r\ncfa->hp_mix_thr_2dir > CFA_HPF_MIX_THR_2DIR_MASK ||\r\ncfa->hp_mix_slope_2dir > CFA_HPF_MIX_SLP_2DIR_MASK ||\r\ncfa->dir_thr_2dir > CFA_DIR_THR_2DIR_MASK ||\r\ncfa->dir_slope_2dir > CFA_DIR_SLP_2DIR_MASK ||\r\ncfa->nd_wt_2dir > CFA_ND_WT_2DIR_MASK ||\r\ncfa->hue_fract_daa > CFA_DAA_HUE_FRA_MASK ||\r\ncfa->edge_thr_daa > CFA_DAA_EDG_THR_MASK ||\r\ncfa->thr_min_daa > CFA_DAA_THR_MIN_MASK ||\r\ncfa->thr_slope_daa > CFA_DAA_THR_SLP_MASK ||\r\ncfa->slope_min_daa > CFA_DAA_SLP_MIN_MASK ||\r\ncfa->slope_slope_daa > CFA_DAA_SLP_SLP_MASK ||\r\ncfa->lp_wt_daa > CFA_DAA_LP_WT_MASK)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int ipipe_set_cfa_params(struct vpfe_ipipe_device *ipipe, void *param)\r\n{\r\nstruct vpfe_ipipe_cfa *cfa_param = param;\r\nstruct vpfe_ipipe_cfa *cfa = &ipipe->config.cfa;\r\nif (!cfa_param) {\r\nmemset(cfa, 0, sizeof(struct vpfe_ipipe_cfa));\r\ncfa->alg = VPFE_IPIPE_CFA_ALG_2DIRAC;\r\ngoto success;\r\n}\r\nmemcpy(cfa, cfa_param, sizeof(struct vpfe_ipipe_cfa));\r\nif (ipipe_validate_cfa_params(cfa) < 0)\r\nreturn -EINVAL;\r\nsuccess:\r\nipipe_set_cfa_regs(ipipe->base_addr, cfa);\r\nreturn 0;\r\n}\r\nstatic int ipipe_get_cfa_params(struct vpfe_ipipe_device *ipipe, void *param)\r\n{\r\nstruct vpfe_ipipe_cfa *cfa_param = param;\r\nstruct vpfe_ipipe_cfa *cfa = &ipipe->config.cfa;\r\nmemcpy(cfa_param, cfa, sizeof(struct vpfe_ipipe_cfa));\r\nreturn 0;\r\n}\r\nstatic int\r\nipipe_validate_rgb2rgb_params(struct vpfe_ipipe_rgb2rgb *rgb2rgb,\r\nunsigned int id)\r\n{\r\nu32 gain_int_upper = RGB2RGB_1_GAIN_INT_MASK;\r\nu32 offset_upper = RGB2RGB_1_OFST_MASK;\r\nif (id == IPIPE_RGB2RGB_2) {\r\noffset_upper = RGB2RGB_2_OFST_MASK;\r\ngain_int_upper = RGB2RGB_2_GAIN_INT_MASK;\r\n}\r\nif (rgb2rgb->coef_rr.decimal > RGB2RGB_GAIN_DECI_MASK ||\r\nrgb2rgb->coef_rr.integer > gain_int_upper)\r\nreturn -EINVAL;\r\nif (rgb2rgb->coef_gr.decimal > RGB2RGB_GAIN_DECI_MASK ||\r\nrgb2rgb->coef_gr.integer > gain_int_upper)\r\nreturn -EINVAL;\r\nif (rgb2rgb->coef_br.decimal > RGB2RGB_GAIN_DECI_MASK ||\r\nrgb2rgb->coef_br.integer > gain_int_upper)\r\nreturn -EINVAL;\r\nif (rgb2rgb->coef_rg.decimal > RGB2RGB_GAIN_DECI_MASK ||\r\nrgb2rgb->coef_rg.integer > gain_int_upper)\r\nreturn -EINVAL;\r\nif (rgb2rgb->coef_gg.decimal > RGB2RGB_GAIN_DECI_MASK ||\r\nrgb2rgb->coef_gg.integer > gain_int_upper)\r\nreturn -EINVAL;\r\nif (rgb2rgb->coef_bg.decimal > RGB2RGB_GAIN_DECI_MASK ||\r\nrgb2rgb->coef_bg.integer > gain_int_upper)\r\nreturn -EINVAL;\r\nif (rgb2rgb->coef_rb.decimal > RGB2RGB_GAIN_DECI_MASK ||\r\nrgb2rgb->coef_rb.integer > gain_int_upper)\r\nreturn -EINVAL;\r\nif (rgb2rgb->coef_gb.decimal > RGB2RGB_GAIN_DECI_MASK ||\r\nrgb2rgb->coef_gb.integer > gain_int_upper)\r\nreturn -EINVAL;\r\nif (rgb2rgb->coef_bb.decimal > RGB2RGB_GAIN_DECI_MASK ||\r\nrgb2rgb->coef_bb.integer > gain_int_upper)\r\nreturn -EINVAL;\r\nif (rgb2rgb->out_ofst_r > offset_upper ||\r\nrgb2rgb->out_ofst_g > offset_upper ||\r\nrgb2rgb->out_ofst_b > offset_upper)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int ipipe_set_rgb2rgb_params(struct vpfe_ipipe_device *ipipe,\r\nunsigned int id, void *param)\r\n{\r\nstruct vpfe_ipipe_rgb2rgb *rgb2rgb = &ipipe->config.rgb2rgb1;\r\nstruct device *dev = ipipe->subdev.v4l2_dev->dev;\r\nstruct vpfe_ipipe_rgb2rgb *rgb2rgb_param;\r\nrgb2rgb_param = param;\r\nif (id == IPIPE_RGB2RGB_2)\r\nrgb2rgb = &ipipe->config.rgb2rgb2;\r\nif (!rgb2rgb_param) {\r\nconst struct vpfe_ipipe_rgb2rgb rgb2rgb_defaults = {\r\n.coef_rr = {1, 0},\r\n.coef_gr = {0, 0},\r\n.coef_br = {0, 0},\r\n.coef_rg = {0, 0},\r\n.coef_gg = {1, 0},\r\n.coef_bg = {0, 0},\r\n.coef_rb = {0, 0},\r\n.coef_gb = {0, 0},\r\n.coef_bb = {1, 0},\r\n};\r\nmemcpy(rgb2rgb, &rgb2rgb_defaults,\r\nsizeof(struct vpfe_ipipe_rgb2rgb));\r\ngoto success;\r\n}\r\nmemcpy(rgb2rgb, rgb2rgb_param, sizeof(struct vpfe_ipipe_rgb2rgb));\r\nif (ipipe_validate_rgb2rgb_params(rgb2rgb, id) < 0) {\r\ndev_err(dev, "Invalid rgb2rgb params\n");\r\nreturn -EINVAL;\r\n}\r\nsuccess:\r\nipipe_set_rgb2rgb_regs(ipipe->base_addr, id, rgb2rgb);\r\nreturn 0;\r\n}\r\nstatic int\r\nipipe_set_rgb2rgb_1_params(struct vpfe_ipipe_device *ipipe, void *param)\r\n{\r\nreturn ipipe_set_rgb2rgb_params(ipipe, IPIPE_RGB2RGB_1, param);\r\n}\r\nstatic int\r\nipipe_set_rgb2rgb_2_params(struct vpfe_ipipe_device *ipipe, void *param)\r\n{\r\nreturn ipipe_set_rgb2rgb_params(ipipe, IPIPE_RGB2RGB_2, param);\r\n}\r\nstatic int ipipe_get_rgb2rgb_params(struct vpfe_ipipe_device *ipipe,\r\nunsigned int id, void *param)\r\n{\r\nstruct vpfe_ipipe_rgb2rgb *rgb2rgb = &ipipe->config.rgb2rgb1;\r\nstruct vpfe_ipipe_rgb2rgb *rgb2rgb_param;\r\nrgb2rgb_param = param;\r\nif (id == IPIPE_RGB2RGB_2)\r\nrgb2rgb = &ipipe->config.rgb2rgb2;\r\nmemcpy(rgb2rgb_param, rgb2rgb, sizeof(struct vpfe_ipipe_rgb2rgb));\r\nreturn 0;\r\n}\r\nstatic int\r\nipipe_get_rgb2rgb_1_params(struct vpfe_ipipe_device *ipipe, void *param)\r\n{\r\nreturn ipipe_get_rgb2rgb_params(ipipe, IPIPE_RGB2RGB_1, param);\r\n}\r\nstatic int\r\nipipe_get_rgb2rgb_2_params(struct vpfe_ipipe_device *ipipe, void *param)\r\n{\r\nreturn ipipe_get_rgb2rgb_params(ipipe, IPIPE_RGB2RGB_2, param);\r\n}\r\nstatic int\r\nipipe_validate_gamma_entry(struct vpfe_ipipe_gamma_entry *table, int size)\r\n{\r\nint i;\r\nif (!table)\r\nreturn -EINVAL;\r\nfor (i = 0; i < size; i++)\r\nif (table[i].slope > GAMMA_MASK ||\r\ntable[i].offset > GAMMA_MASK)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int\r\nipipe_validate_gamma_params(struct vpfe_ipipe_gamma *gamma, struct device *dev)\r\n{\r\nint table_size;\r\nint err;\r\nif (gamma->bypass_r > 1 ||\r\ngamma->bypass_b > 1 ||\r\ngamma->bypass_g > 1)\r\nreturn -EINVAL;\r\nif (gamma->tbl_sel != VPFE_IPIPE_GAMMA_TBL_RAM)\r\nreturn 0;\r\ntable_size = gamma->tbl_size;\r\nif (!gamma->bypass_r) {\r\nerr = ipipe_validate_gamma_entry(gamma->table_r, table_size);\r\nif (err) {\r\ndev_err(dev, "GAMMA R - table entry invalid\n");\r\nreturn err;\r\n}\r\n}\r\nif (!gamma->bypass_b) {\r\nerr = ipipe_validate_gamma_entry(gamma->table_b, table_size);\r\nif (err) {\r\ndev_err(dev, "GAMMA B - table entry invalid\n");\r\nreturn err;\r\n}\r\n}\r\nif (!gamma->bypass_g) {\r\nerr = ipipe_validate_gamma_entry(gamma->table_g, table_size);\r\nif (err) {\r\ndev_err(dev, "GAMMA G - table entry invalid\n");\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nipipe_set_gamma_params(struct vpfe_ipipe_device *ipipe, void *param)\r\n{\r\nstruct vpfe_ipipe_gamma *gamma_param = param;\r\nstruct vpfe_ipipe_gamma *gamma = &ipipe->config.gamma;\r\nstruct device *dev = ipipe->subdev.v4l2_dev->dev;\r\nint table_size;\r\nif (!gamma_param) {\r\nmemset(gamma, 0, sizeof(struct vpfe_ipipe_gamma));\r\ngamma->tbl_sel = VPFE_IPIPE_GAMMA_TBL_ROM;\r\ngoto success;\r\n}\r\ngamma->bypass_r = gamma_param->bypass_r;\r\ngamma->bypass_b = gamma_param->bypass_b;\r\ngamma->bypass_g = gamma_param->bypass_g;\r\ngamma->tbl_sel = gamma_param->tbl_sel;\r\ngamma->tbl_size = gamma_param->tbl_size;\r\nif (ipipe_validate_gamma_params(gamma, dev) < 0)\r\nreturn -EINVAL;\r\nif (gamma_param->tbl_sel != VPFE_IPIPE_GAMMA_TBL_RAM)\r\ngoto success;\r\ntable_size = gamma->tbl_size;\r\nif (!gamma_param->bypass_r)\r\nmemcpy(&gamma->table_r, &gamma_param->table_r,\r\n(table_size * sizeof(struct vpfe_ipipe_gamma_entry)));\r\nif (!gamma_param->bypass_b)\r\nmemcpy(&gamma->table_b, &gamma_param->table_b,\r\n(table_size * sizeof(struct vpfe_ipipe_gamma_entry)));\r\nif (!gamma_param->bypass_g)\r\nmemcpy(&gamma->table_g, &gamma_param->table_g,\r\n(table_size * sizeof(struct vpfe_ipipe_gamma_entry)));\r\nsuccess:\r\nipipe_set_gamma_regs(ipipe->base_addr, ipipe->isp5_base_addr, gamma);\r\nreturn 0;\r\n}\r\nstatic int ipipe_get_gamma_params(struct vpfe_ipipe_device *ipipe, void *param)\r\n{\r\nstruct vpfe_ipipe_gamma *gamma_param = param;\r\nstruct vpfe_ipipe_gamma *gamma = &ipipe->config.gamma;\r\nstruct device *dev = ipipe->subdev.v4l2_dev->dev;\r\nint table_size;\r\ngamma_param->bypass_r = gamma->bypass_r;\r\ngamma_param->bypass_g = gamma->bypass_g;\r\ngamma_param->bypass_b = gamma->bypass_b;\r\ngamma_param->tbl_sel = gamma->tbl_sel;\r\ngamma_param->tbl_size = gamma->tbl_size;\r\nif (gamma->tbl_sel != VPFE_IPIPE_GAMMA_TBL_RAM)\r\nreturn 0;\r\ntable_size = gamma->tbl_size;\r\nif (!gamma->bypass_r && !gamma_param->table_r) {\r\ndev_err(dev,\r\n"ipipe_get_gamma_params: table ptr empty for R\n");\r\nreturn -EINVAL;\r\n}\r\nmemcpy(gamma_param->table_r, gamma->table_r,\r\n(table_size * sizeof(struct vpfe_ipipe_gamma_entry)));\r\nif (!gamma->bypass_g && !gamma_param->table_g) {\r\ndev_err(dev, "ipipe_get_gamma_params: table ptr empty for G\n");\r\nreturn -EINVAL;\r\n}\r\nmemcpy(gamma_param->table_g, gamma->table_g,\r\n(table_size * sizeof(struct vpfe_ipipe_gamma_entry)));\r\nif (!gamma->bypass_b && !gamma_param->table_b) {\r\ndev_err(dev, "ipipe_get_gamma_params: table ptr empty for B\n");\r\nreturn -EINVAL;\r\n}\r\nmemcpy(gamma_param->table_b, gamma->table_b,\r\n(table_size * sizeof(struct vpfe_ipipe_gamma_entry)));\r\nreturn 0;\r\n}\r\nstatic int ipipe_validate_3d_lut_params(struct vpfe_ipipe_3d_lut *lut)\r\n{\r\nint i;\r\nif (!lut->en)\r\nreturn 0;\r\nfor (i = 0; i < VPFE_IPIPE_MAX_SIZE_3D_LUT; i++)\r\nif (lut->table[i].r > D3_LUT_ENTRY_MASK ||\r\nlut->table[i].g > D3_LUT_ENTRY_MASK ||\r\nlut->table[i].b > D3_LUT_ENTRY_MASK)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int ipipe_get_3d_lut_params(struct vpfe_ipipe_device *ipipe, void *param)\r\n{\r\nstruct vpfe_ipipe_3d_lut *lut_param = param;\r\nstruct vpfe_ipipe_3d_lut *lut = &ipipe->config.lut;\r\nstruct device *dev = ipipe->subdev.v4l2_dev->dev;\r\nlut_param->en = lut->en;\r\nif (!lut_param->table) {\r\ndev_err(dev, "ipipe_get_3d_lut_params: Invalid table ptr\n");\r\nreturn -EINVAL;\r\n}\r\nmemcpy(lut_param->table, &lut->table,\r\n(VPFE_IPIPE_MAX_SIZE_3D_LUT *\r\nsizeof(struct vpfe_ipipe_3d_lut_entry)));\r\nreturn 0;\r\n}\r\nstatic int\r\nipipe_set_3d_lut_params(struct vpfe_ipipe_device *ipipe, void *param)\r\n{\r\nstruct vpfe_ipipe_3d_lut *lut_param = param;\r\nstruct vpfe_ipipe_3d_lut *lut = &ipipe->config.lut;\r\nstruct device *dev = ipipe->subdev.v4l2_dev->dev;\r\nif (!lut_param) {\r\nmemset(lut, 0, sizeof(struct vpfe_ipipe_3d_lut));\r\ngoto success;\r\n}\r\nmemcpy(lut, lut_param, sizeof(struct vpfe_ipipe_3d_lut));\r\nif (ipipe_validate_3d_lut_params(lut) < 0) {\r\ndev_err(dev, "Invalid 3D-LUT Params\n");\r\nreturn -EINVAL;\r\n}\r\nsuccess:\r\nipipe_set_3d_lut_regs(ipipe->base_addr, ipipe->isp5_base_addr, lut);\r\nreturn 0;\r\n}\r\nstatic int ipipe_validate_rgb2yuv_params(struct vpfe_ipipe_rgb2yuv *rgb2yuv)\r\n{\r\nif (rgb2yuv->coef_ry.decimal > RGB2YCBCR_COEF_DECI_MASK ||\r\nrgb2yuv->coef_ry.integer > RGB2YCBCR_COEF_INT_MASK)\r\nreturn -EINVAL;\r\nif (rgb2yuv->coef_gy.decimal > RGB2YCBCR_COEF_DECI_MASK ||\r\nrgb2yuv->coef_gy.integer > RGB2YCBCR_COEF_INT_MASK)\r\nreturn -EINVAL;\r\nif (rgb2yuv->coef_by.decimal > RGB2YCBCR_COEF_DECI_MASK ||\r\nrgb2yuv->coef_by.integer > RGB2YCBCR_COEF_INT_MASK)\r\nreturn -EINVAL;\r\nif (rgb2yuv->coef_rcb.decimal > RGB2YCBCR_COEF_DECI_MASK ||\r\nrgb2yuv->coef_rcb.integer > RGB2YCBCR_COEF_INT_MASK)\r\nreturn -EINVAL;\r\nif (rgb2yuv->coef_gcb.decimal > RGB2YCBCR_COEF_DECI_MASK ||\r\nrgb2yuv->coef_gcb.integer > RGB2YCBCR_COEF_INT_MASK)\r\nreturn -EINVAL;\r\nif (rgb2yuv->coef_bcb.decimal > RGB2YCBCR_COEF_DECI_MASK ||\r\nrgb2yuv->coef_bcb.integer > RGB2YCBCR_COEF_INT_MASK)\r\nreturn -EINVAL;\r\nif (rgb2yuv->coef_rcr.decimal > RGB2YCBCR_COEF_DECI_MASK ||\r\nrgb2yuv->coef_rcr.integer > RGB2YCBCR_COEF_INT_MASK)\r\nreturn -EINVAL;\r\nif (rgb2yuv->coef_gcr.decimal > RGB2YCBCR_COEF_DECI_MASK ||\r\nrgb2yuv->coef_gcr.integer > RGB2YCBCR_COEF_INT_MASK)\r\nreturn -EINVAL;\r\nif (rgb2yuv->coef_bcr.decimal > RGB2YCBCR_COEF_DECI_MASK ||\r\nrgb2yuv->coef_bcr.integer > RGB2YCBCR_COEF_INT_MASK)\r\nreturn -EINVAL;\r\nif (rgb2yuv->out_ofst_y > RGB2YCBCR_OFST_MASK ||\r\nrgb2yuv->out_ofst_cb > RGB2YCBCR_OFST_MASK ||\r\nrgb2yuv->out_ofst_cr > RGB2YCBCR_OFST_MASK)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int\r\nipipe_set_rgb2yuv_params(struct vpfe_ipipe_device *ipipe, void *param)\r\n{\r\nstruct vpfe_ipipe_rgb2yuv *rgb2yuv = &ipipe->config.rgb2yuv;\r\nstruct device *dev = ipipe->subdev.v4l2_dev->dev;\r\nstruct vpfe_ipipe_rgb2yuv *rgb2yuv_param;\r\nrgb2yuv_param = param;\r\nif (!rgb2yuv_param) {\r\nconst struct vpfe_ipipe_rgb2yuv rgb2yuv_defaults = {\r\n.coef_ry = {0, 0x4d},\r\n.coef_gy = {0, 0x96},\r\n.coef_by = {0, 0x1d},\r\n.coef_rcb = {0xf, 0xd5},\r\n.coef_gcb = {0xf, 0xab},\r\n.coef_bcb = {0, 0x80},\r\n.coef_rcr = {0, 0x80},\r\n.coef_gcr = {0xf, 0x95},\r\n.coef_bcr = {0xf, 0xeb},\r\n.out_ofst_cb = 0x80,\r\n.out_ofst_cr = 0x80,\r\n};\r\nmemcpy(rgb2yuv, &rgb2yuv_defaults,\r\nsizeof(struct vpfe_ipipe_rgb2yuv));\r\ngoto success;\r\n}\r\nmemcpy(rgb2yuv, rgb2yuv_param, sizeof(struct vpfe_ipipe_rgb2yuv));\r\nif (ipipe_validate_rgb2yuv_params(rgb2yuv) < 0) {\r\ndev_err(dev, "Invalid rgb2yuv params\n");\r\nreturn -EINVAL;\r\n}\r\nsuccess:\r\nipipe_set_rgb2ycbcr_regs(ipipe->base_addr, rgb2yuv);\r\nreturn 0;\r\n}\r\nstatic int\r\nipipe_get_rgb2yuv_params(struct vpfe_ipipe_device *ipipe, void *param)\r\n{\r\nstruct vpfe_ipipe_rgb2yuv *rgb2yuv = &ipipe->config.rgb2yuv;\r\nstruct vpfe_ipipe_rgb2yuv *rgb2yuv_param;\r\nrgb2yuv_param = param;\r\nmemcpy(rgb2yuv_param, rgb2yuv, sizeof(struct vpfe_ipipe_rgb2yuv));\r\nreturn 0;\r\n}\r\nstatic int ipipe_validate_gbce_params(struct vpfe_ipipe_gbce *gbce)\r\n{\r\nu32 max = GBCE_Y_VAL_MASK;\r\nint i;\r\nif (!gbce->en)\r\nreturn 0;\r\nif (gbce->type == VPFE_IPIPE_GBCE_GAIN_TBL)\r\nmax = GBCE_GAIN_VAL_MASK;\r\nfor (i = 0; i < VPFE_IPIPE_MAX_SIZE_GBCE_LUT; i++)\r\nif (gbce->table[i] > max)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int ipipe_set_gbce_params(struct vpfe_ipipe_device *ipipe, void *param)\r\n{\r\nstruct vpfe_ipipe_gbce *gbce_param = param;\r\nstruct vpfe_ipipe_gbce *gbce = &ipipe->config.gbce;\r\nstruct device *dev = ipipe->subdev.v4l2_dev->dev;\r\nif (!gbce_param) {\r\nmemset(gbce, 0, sizeof(struct vpfe_ipipe_gbce));\r\n} else {\r\nmemcpy(gbce, gbce_param, sizeof(struct vpfe_ipipe_gbce));\r\nif (ipipe_validate_gbce_params(gbce) < 0) {\r\ndev_err(dev, "Invalid gbce params\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nipipe_set_gbce_regs(ipipe->base_addr, ipipe->isp5_base_addr, gbce);\r\nreturn 0;\r\n}\r\nstatic int ipipe_get_gbce_params(struct vpfe_ipipe_device *ipipe, void *param)\r\n{\r\nstruct vpfe_ipipe_gbce *gbce_param = param;\r\nstruct vpfe_ipipe_gbce *gbce = &ipipe->config.gbce;\r\nstruct device *dev = ipipe->subdev.v4l2_dev->dev;\r\ngbce_param->en = gbce->en;\r\ngbce_param->type = gbce->type;\r\nif (!gbce_param->table) {\r\ndev_err(dev, "ipipe_get_gbce_params: Invalid table ptr\n");\r\nreturn -EINVAL;\r\n}\r\nmemcpy(gbce_param->table, gbce->table,\r\n(VPFE_IPIPE_MAX_SIZE_GBCE_LUT * sizeof(unsigned short)));\r\nreturn 0;\r\n}\r\nstatic int\r\nipipe_validate_yuv422_conv_params(struct vpfe_ipipe_yuv422_conv *yuv422_conv)\r\n{\r\nif (yuv422_conv->en_chrom_lpf > 1)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int\r\nipipe_set_yuv422_conv_params(struct vpfe_ipipe_device *ipipe, void *param)\r\n{\r\nstruct vpfe_ipipe_yuv422_conv *yuv422_conv = &ipipe->config.yuv422_conv;\r\nstruct vpfe_ipipe_yuv422_conv *yuv422_conv_param;\r\nstruct device *dev = ipipe->subdev.v4l2_dev->dev;\r\nyuv422_conv_param = param;\r\nif (!yuv422_conv_param) {\r\nmemset(yuv422_conv, 0, sizeof(struct vpfe_ipipe_yuv422_conv));\r\nyuv422_conv->chrom_pos = VPFE_IPIPE_YUV422_CHR_POS_COSITE;\r\n} else {\r\nmemcpy(yuv422_conv, yuv422_conv_param,\r\nsizeof(struct vpfe_ipipe_yuv422_conv));\r\nif (ipipe_validate_yuv422_conv_params(yuv422_conv) < 0) {\r\ndev_err(dev, "Invalid yuv422 params\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nipipe_set_yuv422_conv_regs(ipipe->base_addr, yuv422_conv);\r\nreturn 0;\r\n}\r\nstatic int\r\nipipe_get_yuv422_conv_params(struct vpfe_ipipe_device *ipipe, void *param)\r\n{\r\nstruct vpfe_ipipe_yuv422_conv *yuv422_conv = &ipipe->config.yuv422_conv;\r\nstruct vpfe_ipipe_yuv422_conv *yuv422_conv_param;\r\nyuv422_conv_param = param;\r\nmemcpy(yuv422_conv_param, yuv422_conv,\r\nsizeof(struct vpfe_ipipe_yuv422_conv));\r\nreturn 0;\r\n}\r\nstatic int ipipe_validate_yee_params(struct vpfe_ipipe_yee *yee)\r\n{\r\nint i;\r\nif (yee->en > 1 ||\r\nyee->en_halo_red > 1 ||\r\nyee->hpf_shft > YEE_HPF_SHIFT_MASK)\r\nreturn -EINVAL;\r\nif (yee->hpf_coef_00 > YEE_COEF_MASK ||\r\nyee->hpf_coef_01 > YEE_COEF_MASK ||\r\nyee->hpf_coef_02 > YEE_COEF_MASK ||\r\nyee->hpf_coef_10 > YEE_COEF_MASK ||\r\nyee->hpf_coef_11 > YEE_COEF_MASK ||\r\nyee->hpf_coef_12 > YEE_COEF_MASK ||\r\nyee->hpf_coef_20 > YEE_COEF_MASK ||\r\nyee->hpf_coef_21 > YEE_COEF_MASK ||\r\nyee->hpf_coef_22 > YEE_COEF_MASK)\r\nreturn -EINVAL;\r\nif (yee->yee_thr > YEE_THR_MASK ||\r\nyee->es_gain > YEE_ES_GAIN_MASK ||\r\nyee->es_thr1 > YEE_ES_THR1_MASK ||\r\nyee->es_thr2 > YEE_THR_MASK ||\r\nyee->es_gain_grad > YEE_THR_MASK ||\r\nyee->es_ofst_grad > YEE_THR_MASK)\r\nreturn -EINVAL;\r\nfor (i = 0; i < VPFE_IPIPE_MAX_SIZE_YEE_LUT; i++)\r\nif (yee->table[i] > YEE_ENTRY_MASK)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int ipipe_set_yee_params(struct vpfe_ipipe_device *ipipe, void *param)\r\n{\r\nstruct vpfe_ipipe_yee *yee_param = param;\r\nstruct device *dev = ipipe->subdev.v4l2_dev->dev;\r\nstruct vpfe_ipipe_yee *yee = &ipipe->config.yee;\r\nif (!yee_param) {\r\nmemset(yee, 0, sizeof(struct vpfe_ipipe_yee));\r\n} else {\r\nmemcpy(yee, yee_param, sizeof(struct vpfe_ipipe_yee));\r\nif (ipipe_validate_yee_params(yee) < 0) {\r\ndev_err(dev, "Invalid yee params\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nipipe_set_ee_regs(ipipe->base_addr, ipipe->isp5_base_addr, yee);\r\nreturn 0;\r\n}\r\nstatic int ipipe_get_yee_params(struct vpfe_ipipe_device *ipipe, void *param)\r\n{\r\nstruct vpfe_ipipe_yee *yee_param = param;\r\nstruct vpfe_ipipe_yee *yee = &ipipe->config.yee;\r\nyee_param->en = yee->en;\r\nyee_param->en_halo_red = yee->en_halo_red;\r\nyee_param->merge_meth = yee->merge_meth;\r\nyee_param->hpf_shft = yee->hpf_shft;\r\nyee_param->hpf_coef_00 = yee->hpf_coef_00;\r\nyee_param->hpf_coef_01 = yee->hpf_coef_01;\r\nyee_param->hpf_coef_02 = yee->hpf_coef_02;\r\nyee_param->hpf_coef_10 = yee->hpf_coef_10;\r\nyee_param->hpf_coef_11 = yee->hpf_coef_11;\r\nyee_param->hpf_coef_12 = yee->hpf_coef_12;\r\nyee_param->hpf_coef_20 = yee->hpf_coef_20;\r\nyee_param->hpf_coef_21 = yee->hpf_coef_21;\r\nyee_param->hpf_coef_22 = yee->hpf_coef_22;\r\nyee_param->yee_thr = yee->yee_thr;\r\nyee_param->es_gain = yee->es_gain;\r\nyee_param->es_thr1 = yee->es_thr1;\r\nyee_param->es_thr2 = yee->es_thr2;\r\nyee_param->es_gain_grad = yee->es_gain_grad;\r\nyee_param->es_ofst_grad = yee->es_ofst_grad;\r\nmemcpy(yee_param->table, &yee->table,\r\n(VPFE_IPIPE_MAX_SIZE_YEE_LUT * sizeof(short)));\r\nreturn 0;\r\n}\r\nstatic int ipipe_validate_car_params(struct vpfe_ipipe_car *car)\r\n{\r\nif (car->en > 1 || car->hpf_shft > CAR_HPF_SHIFT_MASK ||\r\ncar->gain1.shft > CAR_GAIN1_SHFT_MASK ||\r\ncar->gain1.gain_min > CAR_GAIN_MIN_MASK ||\r\ncar->gain2.shft > CAR_GAIN2_SHFT_MASK ||\r\ncar->gain2.gain_min > CAR_GAIN_MIN_MASK)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int ipipe_set_car_params(struct vpfe_ipipe_device *ipipe, void *param)\r\n{\r\nstruct vpfe_ipipe_car *car_param = param;\r\nstruct device *dev = ipipe->subdev.v4l2_dev->dev;\r\nstruct vpfe_ipipe_car *car = &ipipe->config.car;\r\nif (!car_param) {\r\nmemset(car, 0, sizeof(struct vpfe_ipipe_car));\r\n} else {\r\nmemcpy(car, car_param, sizeof(struct vpfe_ipipe_car));\r\nif (ipipe_validate_car_params(car) < 0) {\r\ndev_err(dev, "Invalid car params\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nipipe_set_car_regs(ipipe->base_addr, car);\r\nreturn 0;\r\n}\r\nstatic int ipipe_get_car_params(struct vpfe_ipipe_device *ipipe, void *param)\r\n{\r\nstruct vpfe_ipipe_car *car_param = param;\r\nstruct vpfe_ipipe_car *car = &ipipe->config.car;\r\nmemcpy(car_param, car, sizeof(struct vpfe_ipipe_car));\r\nreturn 0;\r\n}\r\nstatic int ipipe_validate_cgs_params(struct vpfe_ipipe_cgs *cgs)\r\n{\r\nif (cgs->en > 1 || cgs->h_shft > CAR_SHIFT_MASK)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int ipipe_set_cgs_params(struct vpfe_ipipe_device *ipipe, void *param)\r\n{\r\nstruct vpfe_ipipe_cgs *cgs_param = param;\r\nstruct device *dev = ipipe->subdev.v4l2_dev->dev;\r\nstruct vpfe_ipipe_cgs *cgs = &ipipe->config.cgs;\r\nif (!cgs_param) {\r\nmemset(cgs, 0, sizeof(struct vpfe_ipipe_cgs));\r\n} else {\r\nmemcpy(cgs, cgs_param, sizeof(struct vpfe_ipipe_cgs));\r\nif (ipipe_validate_cgs_params(cgs) < 0) {\r\ndev_err(dev, "Invalid cgs params\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nipipe_set_cgs_regs(ipipe->base_addr, cgs);\r\nreturn 0;\r\n}\r\nstatic int ipipe_get_cgs_params(struct vpfe_ipipe_device *ipipe, void *param)\r\n{\r\nstruct vpfe_ipipe_cgs *cgs_param = param;\r\nstruct vpfe_ipipe_cgs *cgs = &ipipe->config.cgs;\r\nmemcpy(cgs_param, cgs, sizeof(struct vpfe_ipipe_cgs));\r\nreturn 0;\r\n}\r\nstatic int ipipe_s_config(struct v4l2_subdev *sd, struct vpfe_ipipe_config *cfg)\r\n{\r\nstruct vpfe_ipipe_device *ipipe = v4l2_get_subdevdata(sd);\r\nunsigned int i;\r\nint rval = 0;\r\nfor (i = 0; i < ARRAY_SIZE(ipipe_modules); i++) {\r\nunsigned int bit = 1 << i;\r\nif (cfg->flag & bit) {\r\nconst struct ipipe_module_if *module_if =\r\n&ipipe_modules[i];\r\nstruct ipipe_module_params *params;\r\nvoid __user *from = *(void * __user *)\r\n((void *)cfg + module_if->config_offset);\r\nsize_t size;\r\nvoid *to;\r\nparams = kmalloc(sizeof(struct ipipe_module_params),\r\nGFP_KERNEL);\r\nto = (void *)params + module_if->param_offset;\r\nsize = module_if->param_size;\r\nif (to && from && size) {\r\nif (copy_from_user(to, from, size)) {\r\nrval = -EFAULT;\r\nbreak;\r\n}\r\nrval = module_if->set(ipipe, to);\r\nif (rval)\r\ngoto error;\r\n} else if (to && !from && size) {\r\nrval = module_if->set(ipipe, NULL);\r\nif (rval)\r\ngoto error;\r\n}\r\nkfree(params);\r\n}\r\n}\r\nerror:\r\nreturn rval;\r\n}\r\nstatic int ipipe_g_config(struct v4l2_subdev *sd, struct vpfe_ipipe_config *cfg)\r\n{\r\nstruct vpfe_ipipe_device *ipipe = v4l2_get_subdevdata(sd);\r\nunsigned int i;\r\nint rval = 0;\r\nfor (i = 1; i < ARRAY_SIZE(ipipe_modules); i++) {\r\nunsigned int bit = 1 << i;\r\nif (cfg->flag & bit) {\r\nconst struct ipipe_module_if *module_if =\r\n&ipipe_modules[i];\r\nstruct ipipe_module_params *params;\r\nvoid __user *to = *(void * __user *)\r\n((void *)cfg + module_if->config_offset);\r\nsize_t size;\r\nvoid *from;\r\nparams = kmalloc(sizeof(struct ipipe_module_params),\r\nGFP_KERNEL);\r\nfrom = (void *)params + module_if->param_offset;\r\nsize = module_if->param_size;\r\nif (to && from && size) {\r\nrval = module_if->get(ipipe, from);\r\nif (rval)\r\ngoto error;\r\nif (copy_to_user(to, from, size)) {\r\nrval = -EFAULT;\r\nbreak;\r\n}\r\n}\r\nkfree(params);\r\n}\r\n}\r\nerror:\r\nreturn rval;\r\n}\r\nstatic long ipipe_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)\r\n{\r\nswitch (cmd) {\r\ncase VIDIOC_VPFE_IPIPE_S_CONFIG:\r\nreturn ipipe_s_config(sd, arg);\r\ncase VIDIOC_VPFE_IPIPE_G_CONFIG:\r\nreturn ipipe_g_config(sd, arg);\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\n}\r\nvoid vpfe_ipipe_enable(struct vpfe_device *vpfe_dev, int en)\r\n{\r\nstruct vpfe_ipipeif_device *ipipeif = &vpfe_dev->vpfe_ipipeif;\r\nstruct vpfe_ipipe_device *ipipe = &vpfe_dev->vpfe_ipipe;\r\nunsigned char val;\r\nif (ipipe->input == IPIPE_INPUT_NONE)\r\nreturn;\r\nif (ipipeif->input == IPIPEIF_INPUT_MEMORY && en) {\r\ndo {\r\nval = regr_ip(vpfe_dev->vpfe_ipipe.base_addr,\r\nIPIPE_SRC_EN);\r\n} while (val);\r\n}\r\nregw_ip(vpfe_dev->vpfe_ipipe.base_addr, en, IPIPE_SRC_EN);\r\n}\r\nstatic int ipipe_set_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct vpfe_ipipe_device *ipipe = v4l2_get_subdevdata(sd);\r\nstruct vpfe_device *vpfe_dev = to_vpfe_device(ipipe);\r\nif (enable && ipipe->input != IPIPE_INPUT_NONE &&\r\nipipe->output != IPIPE_OUTPUT_NONE) {\r\nif (config_ipipe_hw(ipipe) < 0)\r\nreturn -EINVAL;\r\n}\r\nvpfe_ipipe_enable(vpfe_dev, enable);\r\nreturn 0;\r\n}\r\nstatic struct v4l2_mbus_framefmt *\r\n__ipipe_get_format(struct vpfe_ipipe_device *ipipe,\r\nstruct v4l2_subdev_pad_config *cfg, unsigned int pad,\r\nenum v4l2_subdev_format_whence which)\r\n{\r\nif (which == V4L2_SUBDEV_FORMAT_TRY)\r\nreturn v4l2_subdev_get_try_format(&ipipe->subdev, cfg, pad);\r\nreturn &ipipe->formats[pad];\r\n}\r\nstatic void\r\nipipe_try_format(struct vpfe_ipipe_device *ipipe,\r\nstruct v4l2_subdev_pad_config *cfg, unsigned int pad,\r\nstruct v4l2_mbus_framefmt *fmt,\r\nenum v4l2_subdev_format_whence which)\r\n{\r\nunsigned int max_out_height;\r\nunsigned int max_out_width;\r\nunsigned int i;\r\nmax_out_width = IPIPE_MAX_OUTPUT_WIDTH_A;\r\nmax_out_height = IPIPE_MAX_OUTPUT_HEIGHT_A;\r\nif (pad == IPIPE_PAD_SINK) {\r\nfor (i = 0; i < ARRAY_SIZE(ipipe_input_fmts); i++)\r\nif (fmt->code == ipipe_input_fmts[i])\r\nbreak;\r\nif (i >= ARRAY_SIZE(ipipe_input_fmts))\r\nfmt->code = MEDIA_BUS_FMT_SGRBG12_1X12;\r\n} else if (pad == IPIPE_PAD_SOURCE) {\r\nfor (i = 0; i < ARRAY_SIZE(ipipe_output_fmts); i++)\r\nif (fmt->code == ipipe_output_fmts[i])\r\nbreak;\r\nif (i >= ARRAY_SIZE(ipipe_output_fmts))\r\nfmt->code = MEDIA_BUS_FMT_UYVY8_2X8;\r\n}\r\nfmt->width = clamp_t(u32, fmt->width, MIN_OUT_HEIGHT, max_out_width);\r\nfmt->height = clamp_t(u32, fmt->height, MIN_OUT_WIDTH, max_out_height);\r\n}\r\nstatic int\r\nipipe_set_format(struct v4l2_subdev *sd, struct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct vpfe_ipipe_device *ipipe = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt *format;\r\nformat = __ipipe_get_format(ipipe, cfg, fmt->pad, fmt->which);\r\nif (format == NULL)\r\nreturn -EINVAL;\r\nipipe_try_format(ipipe, cfg, fmt->pad, &fmt->format, fmt->which);\r\n*format = fmt->format;\r\nif (fmt->which == V4L2_SUBDEV_FORMAT_TRY)\r\nreturn 0;\r\nif (fmt->pad == IPIPE_PAD_SINK &&\r\n(ipipe->input == IPIPE_INPUT_CCDC ||\r\nipipe->input == IPIPE_INPUT_MEMORY))\r\nipipe->formats[fmt->pad] = fmt->format;\r\nelse if (fmt->pad == IPIPE_PAD_SOURCE &&\r\nipipe->output == IPIPE_OUTPUT_RESIZER)\r\nipipe->formats[fmt->pad] = fmt->format;\r\nelse\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int\r\nipipe_get_format(struct v4l2_subdev *sd, struct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct vpfe_ipipe_device *ipipe = v4l2_get_subdevdata(sd);\r\nif (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)\r\nfmt->format = ipipe->formats[fmt->pad];\r\nelse\r\nfmt->format = *(v4l2_subdev_get_try_format(sd, cfg, fmt->pad));\r\nreturn 0;\r\n}\r\nstatic int\r\nipipe_enum_frame_size(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_frame_size_enum *fse)\r\n{\r\nstruct vpfe_ipipe_device *ipipe = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt format;\r\nif (fse->index != 0)\r\nreturn -EINVAL;\r\nformat.code = fse->code;\r\nformat.width = 1;\r\nformat.height = 1;\r\nipipe_try_format(ipipe, cfg, fse->pad, &format, fse->which);\r\nfse->min_width = format.width;\r\nfse->min_height = format.height;\r\nif (format.code != fse->code)\r\nreturn -EINVAL;\r\nformat.code = fse->code;\r\nformat.width = -1;\r\nformat.height = -1;\r\nipipe_try_format(ipipe, cfg, fse->pad, &format, fse->which);\r\nfse->max_width = format.width;\r\nfse->max_height = format.height;\r\nreturn 0;\r\n}\r\nstatic int\r\nipipe_enum_mbus_code(struct v4l2_subdev *sd, struct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nswitch (code->pad) {\r\ncase IPIPE_PAD_SINK:\r\nif (code->index >= ARRAY_SIZE(ipipe_input_fmts))\r\nreturn -EINVAL;\r\ncode->code = ipipe_input_fmts[code->index];\r\nbreak;\r\ncase IPIPE_PAD_SOURCE:\r\nif (code->index >= ARRAY_SIZE(ipipe_output_fmts))\r\nreturn -EINVAL;\r\ncode->code = ipipe_output_fmts[code->index];\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ipipe_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct vpfe_ipipe_device *ipipe =\r\ncontainer_of(ctrl->handler, struct vpfe_ipipe_device, ctrls);\r\nstruct ipipe_lum_adj *lum_adj = &ipipe->config.lum_adj;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nlum_adj->brightness = ctrl->val;\r\nipipe_set_lum_adj_regs(ipipe->base_addr, lum_adj);\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nlum_adj->contrast = ctrl->val;\r\nipipe_set_lum_adj_regs(ipipe->base_addr, lum_adj);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nipipe_init_formats(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\r\n{\r\nstruct v4l2_subdev_format format;\r\nmemset(&format, 0, sizeof(format));\r\nformat.pad = IPIPE_PAD_SINK;\r\nformat.which = V4L2_SUBDEV_FORMAT_TRY;\r\nformat.format.code = MEDIA_BUS_FMT_SGRBG12_1X12;\r\nformat.format.width = IPIPE_MAX_OUTPUT_WIDTH_A;\r\nformat.format.height = IPIPE_MAX_OUTPUT_HEIGHT_A;\r\nipipe_set_format(sd, fh->pad, &format);\r\nmemset(&format, 0, sizeof(format));\r\nformat.pad = IPIPE_PAD_SOURCE;\r\nformat.which = V4L2_SUBDEV_FORMAT_TRY;\r\nformat.format.code = MEDIA_BUS_FMT_UYVY8_2X8;\r\nformat.format.width = IPIPE_MAX_OUTPUT_WIDTH_A;\r\nformat.format.height = IPIPE_MAX_OUTPUT_HEIGHT_A;\r\nipipe_set_format(sd, fh->pad, &format);\r\nreturn 0;\r\n}\r\nstatic int\r\nipipe_link_setup(struct media_entity *entity, const struct media_pad *local,\r\nconst struct media_pad *remote, u32 flags)\r\n{\r\nstruct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);\r\nstruct vpfe_ipipe_device *ipipe = v4l2_get_subdevdata(sd);\r\nstruct vpfe_device *vpfe_dev = to_vpfe_device(ipipe);\r\nu16 ipipeif_sink = vpfe_dev->vpfe_ipipeif.input;\r\nif (!is_media_entity_v4l2_subdev(remote->entity))\r\nreturn -EINVAL;\r\nswitch (local->index) {\r\ncase IPIPE_PAD_SINK:\r\nif (!(flags & MEDIA_LNK_FL_ENABLED)) {\r\nipipe->input = IPIPE_INPUT_NONE;\r\nbreak;\r\n}\r\nif (ipipe->input != IPIPE_INPUT_NONE)\r\nreturn -EBUSY;\r\nif (ipipeif_sink == IPIPEIF_INPUT_MEMORY)\r\nipipe->input = IPIPE_INPUT_MEMORY;\r\nelse\r\nipipe->input = IPIPE_INPUT_CCDC;\r\nbreak;\r\ncase IPIPE_PAD_SOURCE:\r\nif (flags & MEDIA_LNK_FL_ENABLED)\r\nipipe->output = IPIPE_OUTPUT_RESIZER;\r\nelse\r\nipipe->output = IPIPE_OUTPUT_NONE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nvoid vpfe_ipipe_unregister_entities(struct vpfe_ipipe_device *vpfe_ipipe)\r\n{\r\nv4l2_device_unregister_subdev(&vpfe_ipipe->subdev);\r\nmedia_entity_cleanup(&vpfe_ipipe->subdev.entity);\r\n}\r\nint\r\nvpfe_ipipe_register_entities(struct vpfe_ipipe_device *ipipe,\r\nstruct v4l2_device *vdev)\r\n{\r\nint ret;\r\nret = v4l2_device_register_subdev(vdev, &ipipe->subdev);\r\nif (ret) {\r\npr_err("Failed to register ipipe as v4l2 subdevice\n");\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nint\r\nvpfe_ipipe_init(struct vpfe_ipipe_device *ipipe, struct platform_device *pdev)\r\n{\r\nstruct media_pad *pads = &ipipe->pads[0];\r\nstruct v4l2_subdev *sd = &ipipe->subdev;\r\nstruct media_entity *me = &sd->entity;\r\nstatic resource_size_t res_len;\r\nstruct resource *res;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 4);\r\nif (!res)\r\nreturn -ENOENT;\r\nres_len = resource_size(res);\r\nres = request_mem_region(res->start, res_len, res->name);\r\nif (!res)\r\nreturn -EBUSY;\r\nipipe->base_addr = ioremap_nocache(res->start, res_len);\r\nif (!ipipe->base_addr)\r\ngoto error_release;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 6);\r\nif (!res)\r\ngoto error_unmap;\r\nipipe->isp5_base_addr = ioremap_nocache(res->start, res_len);\r\nif (!ipipe->isp5_base_addr)\r\ngoto error_unmap;\r\nv4l2_subdev_init(sd, &ipipe_v4l2_ops);\r\nsd->internal_ops = &ipipe_v4l2_internal_ops;\r\nstrlcpy(sd->name, "DAVINCI IPIPE", sizeof(sd->name));\r\nsd->grp_id = 1 << 16;\r\nv4l2_set_subdevdata(sd, ipipe);\r\nsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\npads[IPIPE_PAD_SINK].flags = MEDIA_PAD_FL_SINK;\r\npads[IPIPE_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;\r\nipipe->input = IPIPE_INPUT_NONE;\r\nipipe->output = IPIPE_OUTPUT_NONE;\r\nme->ops = &ipipe_media_ops;\r\nv4l2_ctrl_handler_init(&ipipe->ctrls, 2);\r\nv4l2_ctrl_new_std(&ipipe->ctrls, &ipipe_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, 0,\r\nIPIPE_BRIGHT_HIGH, 1, 16);\r\nv4l2_ctrl_new_std(&ipipe->ctrls, &ipipe_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0,\r\nIPIPE_CONTRAST_HIGH, 1, 16);\r\nv4l2_ctrl_handler_setup(&ipipe->ctrls);\r\nsd->ctrl_handler = &ipipe->ctrls;\r\nreturn media_entity_pads_init(me, IPIPE_PADS_NUM, pads);\r\nerror_unmap:\r\niounmap(ipipe->base_addr);\r\nerror_release:\r\nrelease_mem_region(res->start, res_len);\r\nreturn -ENOMEM;\r\n}\r\nvoid vpfe_ipipe_cleanup(struct vpfe_ipipe_device *ipipe,\r\nstruct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nv4l2_ctrl_handler_free(&ipipe->ctrls);\r\niounmap(ipipe->base_addr);\r\niounmap(ipipe->isp5_base_addr);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 4);\r\nif (res)\r\nrelease_mem_region(res->start, resource_size(res));\r\n}
