bool cyapa_is_pip_bl_mode(struct cyapa *cyapa)\r\n{\r\nif (cyapa->gen == CYAPA_GEN6 && cyapa->state == CYAPA_STATE_GEN6_BL)\r\nreturn true;\r\nif (cyapa->gen == CYAPA_GEN5 && cyapa->state == CYAPA_STATE_GEN5_BL)\r\nreturn true;\r\nreturn false;\r\n}\r\nbool cyapa_is_pip_app_mode(struct cyapa *cyapa)\r\n{\r\nif (cyapa->gen == CYAPA_GEN6 && cyapa->state == CYAPA_STATE_GEN6_APP)\r\nreturn true;\r\nif (cyapa->gen == CYAPA_GEN5 && cyapa->state == CYAPA_STATE_GEN5_APP)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic bool cyapa_is_bootloader_mode(struct cyapa *cyapa)\r\n{\r\nif (cyapa_is_pip_bl_mode(cyapa))\r\nreturn true;\r\nif (cyapa->gen == CYAPA_GEN3 &&\r\ncyapa->state >= CYAPA_STATE_BL_BUSY &&\r\ncyapa->state <= CYAPA_STATE_BL_ACTIVE)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic inline bool cyapa_is_operational_mode(struct cyapa *cyapa)\r\n{\r\nif (cyapa_is_pip_app_mode(cyapa))\r\nreturn true;\r\nif (cyapa->gen == CYAPA_GEN3 && cyapa->state == CYAPA_STATE_OP)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic ssize_t cyapa_i2c_read(struct cyapa *cyapa, u8 reg, size_t len,\r\nu8 *values)\r\n{\r\nstruct i2c_client *client = cyapa->client;\r\nstruct i2c_msg msgs[] = {\r\n{\r\n.addr = client->addr,\r\n.flags = 0,\r\n.len = 1,\r\n.buf = &reg,\r\n},\r\n{\r\n.addr = client->addr,\r\n.flags = I2C_M_RD,\r\n.len = len,\r\n.buf = values,\r\n},\r\n};\r\nint ret;\r\nret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\r\nif (ret != ARRAY_SIZE(msgs))\r\nreturn ret < 0 ? ret : -EIO;\r\nreturn 0;\r\n}\r\nstatic int cyapa_i2c_write(struct cyapa *cyapa, u8 reg,\r\nsize_t len, const void *values)\r\n{\r\nstruct i2c_client *client = cyapa->client;\r\nchar buf[32];\r\nint ret;\r\nif (len > sizeof(buf) - 1)\r\nreturn -ENOMEM;\r\nbuf[0] = reg;\r\nmemcpy(&buf[1], values, len);\r\nret = i2c_master_send(client, buf, len + 1);\r\nif (ret != len + 1)\r\nreturn ret < 0 ? ret : -EIO;\r\nreturn 0;\r\n}\r\nstatic u8 cyapa_check_adapter_functionality(struct i2c_client *client)\r\n{\r\nu8 ret = CYAPA_ADAPTER_FUNC_NONE;\r\nif (i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\r\nret |= CYAPA_ADAPTER_FUNC_I2C;\r\nif (i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA |\r\nI2C_FUNC_SMBUS_BLOCK_DATA |\r\nI2C_FUNC_SMBUS_I2C_BLOCK))\r\nret |= CYAPA_ADAPTER_FUNC_SMBUS;\r\nreturn ret;\r\n}\r\nstatic int cyapa_get_state(struct cyapa *cyapa)\r\n{\r\nu8 status[BL_STATUS_SIZE];\r\nu8 cmd[32];\r\nbool even_addr = ((cyapa->client->addr & 0x0001) == 0);\r\nbool smbus = false;\r\nint retries = 2;\r\nint error;\r\ncyapa->state = CYAPA_STATE_NO_DEVICE;\r\nerror = cyapa_i2c_reg_read_block(cyapa, BL_HEAD_OFFSET, BL_STATUS_SIZE,\r\nstatus);\r\nif (cyapa->smbus && (error == -ETIMEDOUT || error == -ENXIO)) {\r\nif (!even_addr)\r\nerror = cyapa_read_block(cyapa,\r\nCYAPA_CMD_BL_STATUS, status);\r\nsmbus = true;\r\n}\r\nif (error != BL_STATUS_SIZE)\r\ngoto error;\r\ndo {\r\ncyapa->status[REG_OP_STATUS] = status[REG_OP_STATUS];\r\ncyapa->status[REG_BL_STATUS] = status[REG_BL_STATUS];\r\ncyapa->status[REG_BL_ERROR] = status[REG_BL_ERROR];\r\nif (cyapa->gen == CYAPA_GEN_UNKNOWN ||\r\ncyapa->gen == CYAPA_GEN3) {\r\nerror = cyapa_gen3_ops.state_parse(cyapa,\r\nstatus, BL_STATUS_SIZE);\r\nif (!error)\r\ngoto out_detected;\r\n}\r\nif (cyapa->gen == CYAPA_GEN_UNKNOWN ||\r\ncyapa->gen == CYAPA_GEN6 ||\r\ncyapa->gen == CYAPA_GEN5) {\r\nerror = cyapa_pip_state_parse(cyapa,\r\nstatus, BL_STATUS_SIZE);\r\nif (!error)\r\ngoto out_detected;\r\n}\r\nif ((cyapa->gen == CYAPA_GEN_UNKNOWN ||\r\ncyapa->gen == CYAPA_GEN5) &&\r\n!smbus && even_addr) {\r\nerror = cyapa_gen5_ops.state_parse(cyapa,\r\nstatus, BL_STATUS_SIZE);\r\nif (!error)\r\ngoto out_detected;\r\n}\r\nif (!smbus) {\r\ncmd[0] = 0x00;\r\ncmd[1] = 0x00;\r\nerror = cyapa_i2c_write(cyapa, 0, 2, cmd);\r\nif (error)\r\ngoto error;\r\nmsleep(50);\r\nerror = cyapa_i2c_read(cyapa, BL_HEAD_OFFSET,\r\nBL_STATUS_SIZE, status);\r\nif (error)\r\ngoto error;\r\n}\r\n} while (--retries > 0 && !smbus);\r\ngoto error;\r\nout_detected:\r\nif (cyapa->state <= CYAPA_STATE_BL_BUSY)\r\nreturn -EAGAIN;\r\nreturn 0;\r\nerror:\r\nreturn (error < 0) ? error : -EAGAIN;\r\n}\r\nint cyapa_poll_state(struct cyapa *cyapa, unsigned int timeout)\r\n{\r\nint error;\r\nint tries = timeout / 100;\r\ndo {\r\nerror = cyapa_get_state(cyapa);\r\nif (!error && cyapa->state > CYAPA_STATE_BL_BUSY)\r\nreturn 0;\r\nmsleep(100);\r\n} while (tries--);\r\nreturn (error == -EAGAIN || error == -ETIMEDOUT) ? -ETIMEDOUT : error;\r\n}\r\nstatic int cyapa_check_is_operational(struct cyapa *cyapa)\r\n{\r\nint error;\r\nerror = cyapa_poll_state(cyapa, 4000);\r\nif (error)\r\nreturn error;\r\nswitch (cyapa->gen) {\r\ncase CYAPA_GEN6:\r\ncyapa->ops = &cyapa_gen6_ops;\r\nbreak;\r\ncase CYAPA_GEN5:\r\ncyapa->ops = &cyapa_gen5_ops;\r\nbreak;\r\ncase CYAPA_GEN3:\r\ncyapa->ops = &cyapa_gen3_ops;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nerror = cyapa->ops->operational_check(cyapa);\r\nif (!error && cyapa_is_operational_mode(cyapa))\r\ncyapa->operational = true;\r\nelse\r\ncyapa->operational = false;\r\nreturn error;\r\n}\r\nstatic int cyapa_detect(struct cyapa *cyapa)\r\n{\r\nstruct device *dev = &cyapa->client->dev;\r\nint error;\r\nerror = cyapa_check_is_operational(cyapa);\r\nif (error) {\r\nif (error != -ETIMEDOUT && error != -ENODEV &&\r\ncyapa_is_bootloader_mode(cyapa)) {\r\ndev_warn(dev, "device detected but not operational\n");\r\nreturn 0;\r\n}\r\ndev_err(dev, "no device detected: %d\n", error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cyapa_open(struct input_dev *input)\r\n{\r\nstruct cyapa *cyapa = input_get_drvdata(input);\r\nstruct i2c_client *client = cyapa->client;\r\nstruct device *dev = &client->dev;\r\nint error;\r\nerror = mutex_lock_interruptible(&cyapa->state_sync_lock);\r\nif (error)\r\nreturn error;\r\nif (cyapa->operational) {\r\nerror = cyapa->ops->set_power_mode(cyapa,\r\nPWR_MODE_FULL_ACTIVE, 0, CYAPA_PM_ACTIVE);\r\nif (error) {\r\ndev_warn(dev, "set active power failed: %d\n", error);\r\ngoto out;\r\n}\r\n} else {\r\nerror = cyapa_reinitialize(cyapa);\r\nif (error || !cyapa->operational) {\r\nerror = error ? error : -EAGAIN;\r\ngoto out;\r\n}\r\n}\r\nenable_irq(client->irq);\r\nif (!pm_runtime_enabled(dev)) {\r\npm_runtime_set_active(dev);\r\npm_runtime_enable(dev);\r\n}\r\npm_runtime_get_sync(dev);\r\npm_runtime_mark_last_busy(dev);\r\npm_runtime_put_sync_autosuspend(dev);\r\nout:\r\nmutex_unlock(&cyapa->state_sync_lock);\r\nreturn error;\r\n}\r\nstatic void cyapa_close(struct input_dev *input)\r\n{\r\nstruct cyapa *cyapa = input_get_drvdata(input);\r\nstruct i2c_client *client = cyapa->client;\r\nstruct device *dev = &cyapa->client->dev;\r\nmutex_lock(&cyapa->state_sync_lock);\r\ndisable_irq(client->irq);\r\nif (pm_runtime_enabled(dev))\r\npm_runtime_disable(dev);\r\npm_runtime_set_suspended(dev);\r\nif (cyapa->operational)\r\ncyapa->ops->set_power_mode(cyapa,\r\nPWR_MODE_OFF, 0, CYAPA_PM_DEACTIVE);\r\nmutex_unlock(&cyapa->state_sync_lock);\r\n}\r\nstatic int cyapa_create_input_dev(struct cyapa *cyapa)\r\n{\r\nstruct device *dev = &cyapa->client->dev;\r\nstruct input_dev *input;\r\nint error;\r\nif (!cyapa->physical_size_x || !cyapa->physical_size_y)\r\nreturn -EINVAL;\r\ninput = devm_input_allocate_device(dev);\r\nif (!input) {\r\ndev_err(dev, "failed to allocate memory for input device.\n");\r\nreturn -ENOMEM;\r\n}\r\ninput->name = CYAPA_NAME;\r\ninput->phys = cyapa->phys;\r\ninput->id.bustype = BUS_I2C;\r\ninput->id.version = 1;\r\ninput->id.product = 0;\r\ninput->dev.parent = &cyapa->client->dev;\r\ninput->open = cyapa_open;\r\ninput->close = cyapa_close;\r\ninput_set_drvdata(input, cyapa);\r\n__set_bit(EV_ABS, input->evbit);\r\ninput_set_abs_params(input, ABS_MT_POSITION_X, 0, cyapa->max_abs_x, 0,\r\n0);\r\ninput_set_abs_params(input, ABS_MT_POSITION_Y, 0, cyapa->max_abs_y, 0,\r\n0);\r\ninput_set_abs_params(input, ABS_MT_PRESSURE, 0, cyapa->max_z, 0, 0);\r\nif (cyapa->gen > CYAPA_GEN3) {\r\ninput_set_abs_params(input, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);\r\ninput_set_abs_params(input, ABS_MT_TOUCH_MINOR, 0, 255, 0, 0);\r\ninput_set_abs_params(input, ABS_MT_ORIENTATION,\r\n-127, 127, 0, 0);\r\n}\r\nif (cyapa->gen >= CYAPA_GEN5) {\r\ninput_set_abs_params(input, ABS_MT_WIDTH_MAJOR, 0, 255, 0, 0);\r\ninput_set_abs_params(input, ABS_MT_WIDTH_MINOR, 0, 255, 0, 0);\r\ninput_set_abs_params(input, ABS_DISTANCE, 0, 1, 0, 0);\r\n}\r\ninput_abs_set_res(input, ABS_MT_POSITION_X,\r\ncyapa->max_abs_x / cyapa->physical_size_x);\r\ninput_abs_set_res(input, ABS_MT_POSITION_Y,\r\ncyapa->max_abs_y / cyapa->physical_size_y);\r\nif (cyapa->btn_capability & CAPABILITY_LEFT_BTN_MASK)\r\n__set_bit(BTN_LEFT, input->keybit);\r\nif (cyapa->btn_capability & CAPABILITY_MIDDLE_BTN_MASK)\r\n__set_bit(BTN_MIDDLE, input->keybit);\r\nif (cyapa->btn_capability & CAPABILITY_RIGHT_BTN_MASK)\r\n__set_bit(BTN_RIGHT, input->keybit);\r\nif (cyapa->btn_capability == CAPABILITY_LEFT_BTN_MASK)\r\n__set_bit(INPUT_PROP_BUTTONPAD, input->propbit);\r\nerror = input_mt_init_slots(input, CYAPA_MAX_MT_SLOTS,\r\nINPUT_MT_POINTER | INPUT_MT_DROP_UNUSED);\r\nif (error) {\r\ndev_err(dev, "failed to initialize MT slots: %d\n", error);\r\nreturn error;\r\n}\r\nerror = input_register_device(input);\r\nif (error) {\r\ndev_err(dev, "failed to register input device: %d\n", error);\r\nreturn error;\r\n}\r\ncyapa->input = input;\r\nreturn 0;\r\n}\r\nstatic void cyapa_enable_irq_for_cmd(struct cyapa *cyapa)\r\n{\r\nstruct input_dev *input = cyapa->input;\r\nif (!input || !input->users) {\r\nif (!input || cyapa->operational)\r\ncyapa->ops->set_power_mode(cyapa,\r\nPWR_MODE_FULL_ACTIVE, 0, CYAPA_PM_ACTIVE);\r\nif (cyapa->gen >= CYAPA_GEN5)\r\nenable_irq(cyapa->client->irq);\r\n}\r\n}\r\nstatic void cyapa_disable_irq_for_cmd(struct cyapa *cyapa)\r\n{\r\nstruct input_dev *input = cyapa->input;\r\nif (!input || !input->users) {\r\nif (cyapa->gen >= CYAPA_GEN5)\r\ndisable_irq(cyapa->client->irq);\r\nif (!input || cyapa->operational)\r\ncyapa->ops->set_power_mode(cyapa,\r\nPWR_MODE_OFF, 0, CYAPA_PM_ACTIVE);\r\n}\r\n}\r\nu8 cyapa_sleep_time_to_pwr_cmd(u16 sleep_time)\r\n{\r\nu16 encoded_time;\r\nsleep_time = clamp_val(sleep_time, 20, 1000);\r\nencoded_time = sleep_time < 100 ? sleep_time / 10 : sleep_time / 20 + 5;\r\nreturn (encoded_time << 2) & PWR_MODE_MASK;\r\n}\r\nu16 cyapa_pwr_cmd_to_sleep_time(u8 pwr_mode)\r\n{\r\nu8 encoded_time = pwr_mode >> 2;\r\nreturn (encoded_time < 10) ? encoded_time * 10\r\n: (encoded_time - 5) * 20;\r\n}\r\nstatic int cyapa_initialize(struct cyapa *cyapa)\r\n{\r\nint error = 0;\r\ncyapa->state = CYAPA_STATE_NO_DEVICE;\r\ncyapa->gen = CYAPA_GEN_UNKNOWN;\r\nmutex_init(&cyapa->state_sync_lock);\r\ncyapa->suspend_power_mode = PWR_MODE_SLEEP;\r\ncyapa->suspend_sleep_time =\r\ncyapa_pwr_cmd_to_sleep_time(cyapa->suspend_power_mode);\r\nerror = cyapa_gen3_ops.initialize(cyapa);\r\nif (!error)\r\nerror = cyapa_gen5_ops.initialize(cyapa);\r\nif (!error)\r\nerror = cyapa_gen6_ops.initialize(cyapa);\r\nif (error)\r\nreturn error;\r\nerror = cyapa_detect(cyapa);\r\nif (error)\r\nreturn error;\r\nif (cyapa->operational)\r\ncyapa->ops->set_power_mode(cyapa,\r\nPWR_MODE_OFF, 0, CYAPA_PM_ACTIVE);\r\nreturn 0;\r\n}\r\nstatic int cyapa_reinitialize(struct cyapa *cyapa)\r\n{\r\nstruct device *dev = &cyapa->client->dev;\r\nstruct input_dev *input = cyapa->input;\r\nint error;\r\nif (pm_runtime_enabled(dev))\r\npm_runtime_disable(dev);\r\nif (cyapa->operational)\r\ncyapa->ops->set_power_mode(cyapa,\r\nPWR_MODE_FULL_ACTIVE, 0, CYAPA_PM_ACTIVE);\r\nerror = cyapa_detect(cyapa);\r\nif (error)\r\ngoto out;\r\nif (!input && cyapa->operational) {\r\nerror = cyapa_create_input_dev(cyapa);\r\nif (error) {\r\ndev_err(dev, "create input_dev instance failed: %d\n",\r\nerror);\r\ngoto out;\r\n}\r\n}\r\nout:\r\nif (!input || !input->users) {\r\nif (cyapa->operational)\r\ncyapa->ops->set_power_mode(cyapa,\r\nPWR_MODE_OFF, 0, CYAPA_PM_DEACTIVE);\r\n} else if (!error && cyapa->operational) {\r\npm_runtime_set_active(dev);\r\npm_runtime_enable(dev);\r\npm_runtime_get_sync(dev);\r\npm_runtime_mark_last_busy(dev);\r\npm_runtime_put_sync_autosuspend(dev);\r\n}\r\nreturn error;\r\n}\r\nstatic irqreturn_t cyapa_irq(int irq, void *dev_id)\r\n{\r\nstruct cyapa *cyapa = dev_id;\r\nstruct device *dev = &cyapa->client->dev;\r\nint error;\r\nif (device_may_wakeup(dev))\r\npm_wakeup_event(dev, 0);\r\nif (cyapa->ops->irq_cmd_handler(cyapa)) {\r\nif (!cyapa->input) {\r\ncyapa->ops->sort_empty_output_data(cyapa,\r\nNULL, NULL, NULL);\r\ngoto out;\r\n}\r\nif (cyapa->operational) {\r\nerror = cyapa->ops->irq_handler(cyapa);\r\npm_runtime_get_sync(dev);\r\npm_runtime_mark_last_busy(dev);\r\npm_runtime_put_sync_autosuspend(dev);\r\n}\r\nif (!cyapa->operational || error) {\r\nif (!mutex_trylock(&cyapa->state_sync_lock)) {\r\ncyapa->ops->sort_empty_output_data(cyapa,\r\nNULL, NULL, NULL);\r\ngoto out;\r\n}\r\ncyapa_reinitialize(cyapa);\r\nmutex_unlock(&cyapa->state_sync_lock);\r\n}\r\n}\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic ssize_t cyapa_show_suspend_scanrate(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct cyapa *cyapa = dev_get_drvdata(dev);\r\nu8 pwr_cmd = cyapa->suspend_power_mode;\r\nu16 sleep_time;\r\nint len;\r\nint error;\r\nerror = mutex_lock_interruptible(&cyapa->state_sync_lock);\r\nif (error)\r\nreturn error;\r\npwr_cmd = cyapa->suspend_power_mode;\r\nsleep_time = cyapa->suspend_sleep_time;\r\nmutex_unlock(&cyapa->state_sync_lock);\r\nswitch (pwr_cmd) {\r\ncase PWR_MODE_BTN_ONLY:\r\nlen = scnprintf(buf, PAGE_SIZE, "%s\n", BTN_ONLY_MODE_NAME);\r\nbreak;\r\ncase PWR_MODE_OFF:\r\nlen = scnprintf(buf, PAGE_SIZE, "%s\n", OFF_MODE_NAME);\r\nbreak;\r\ndefault:\r\nlen = scnprintf(buf, PAGE_SIZE, "%u\n",\r\ncyapa->gen == CYAPA_GEN3 ?\r\ncyapa_pwr_cmd_to_sleep_time(pwr_cmd) :\r\nsleep_time);\r\nbreak;\r\n}\r\nreturn len;\r\n}\r\nstatic ssize_t cyapa_update_suspend_scanrate(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct cyapa *cyapa = dev_get_drvdata(dev);\r\nu16 sleep_time;\r\nint error;\r\nerror = mutex_lock_interruptible(&cyapa->state_sync_lock);\r\nif (error)\r\nreturn error;\r\nif (sysfs_streq(buf, BTN_ONLY_MODE_NAME)) {\r\ncyapa->suspend_power_mode = PWR_MODE_BTN_ONLY;\r\n} else if (sysfs_streq(buf, OFF_MODE_NAME)) {\r\ncyapa->suspend_power_mode = PWR_MODE_OFF;\r\n} else if (!kstrtou16(buf, 10, &sleep_time)) {\r\ncyapa->suspend_sleep_time = min_t(u16, sleep_time, 1000);\r\ncyapa->suspend_power_mode =\r\ncyapa_sleep_time_to_pwr_cmd(cyapa->suspend_sleep_time);\r\n} else {\r\ncount = -EINVAL;\r\n}\r\nmutex_unlock(&cyapa->state_sync_lock);\r\nreturn count;\r\n}\r\nstatic void cyapa_remove_power_wakeup_group(void *data)\r\n{\r\nstruct cyapa *cyapa = data;\r\nsysfs_unmerge_group(&cyapa->client->dev.kobj,\r\n&cyapa_power_wakeup_group);\r\n}\r\nstatic int cyapa_prepare_wakeup_controls(struct cyapa *cyapa)\r\n{\r\nstruct i2c_client *client = cyapa->client;\r\nstruct device *dev = &client->dev;\r\nint error;\r\nif (device_can_wakeup(dev)) {\r\nerror = sysfs_merge_group(&dev->kobj,\r\n&cyapa_power_wakeup_group);\r\nif (error) {\r\ndev_err(dev, "failed to add power wakeup group: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nerror = devm_add_action(dev,\r\ncyapa_remove_power_wakeup_group, cyapa);\r\nif (error) {\r\ncyapa_remove_power_wakeup_group(cyapa);\r\ndev_err(dev, "failed to add power cleanup action: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int cyapa_prepare_wakeup_controls(struct cyapa *cyapa)\r\n{\r\nreturn 0;\r\n}\r\nstatic ssize_t cyapa_show_rt_suspend_scanrate(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct cyapa *cyapa = dev_get_drvdata(dev);\r\nu8 pwr_cmd;\r\nu16 sleep_time;\r\nint error;\r\nerror = mutex_lock_interruptible(&cyapa->state_sync_lock);\r\nif (error)\r\nreturn error;\r\npwr_cmd = cyapa->runtime_suspend_power_mode;\r\nsleep_time = cyapa->runtime_suspend_sleep_time;\r\nmutex_unlock(&cyapa->state_sync_lock);\r\nreturn scnprintf(buf, PAGE_SIZE, "%u\n",\r\ncyapa->gen == CYAPA_GEN3 ?\r\ncyapa_pwr_cmd_to_sleep_time(pwr_cmd) :\r\nsleep_time);\r\n}\r\nstatic ssize_t cyapa_update_rt_suspend_scanrate(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct cyapa *cyapa = dev_get_drvdata(dev);\r\nu16 time;\r\nint error;\r\nif (buf == NULL || count == 0 || kstrtou16(buf, 10, &time)) {\r\ndev_err(dev, "invalid runtime suspend scanrate ms parameter\n");\r\nreturn -EINVAL;\r\n}\r\npm_runtime_get_sync(dev);\r\nerror = mutex_lock_interruptible(&cyapa->state_sync_lock);\r\nif (error)\r\nreturn error;\r\ncyapa->runtime_suspend_sleep_time = min_t(u16, time, 1000);\r\ncyapa->runtime_suspend_power_mode =\r\ncyapa_sleep_time_to_pwr_cmd(cyapa->runtime_suspend_sleep_time);\r\nmutex_unlock(&cyapa->state_sync_lock);\r\npm_runtime_put_sync_autosuspend(dev);\r\nreturn count;\r\n}\r\nstatic void cyapa_remove_power_runtime_group(void *data)\r\n{\r\nstruct cyapa *cyapa = data;\r\nsysfs_unmerge_group(&cyapa->client->dev.kobj,\r\n&cyapa_power_runtime_group);\r\n}\r\nstatic int cyapa_start_runtime(struct cyapa *cyapa)\r\n{\r\nstruct device *dev = &cyapa->client->dev;\r\nint error;\r\ncyapa->runtime_suspend_power_mode = PWR_MODE_IDLE;\r\ncyapa->runtime_suspend_sleep_time =\r\ncyapa_pwr_cmd_to_sleep_time(cyapa->runtime_suspend_power_mode);\r\nerror = sysfs_merge_group(&dev->kobj, &cyapa_power_runtime_group);\r\nif (error) {\r\ndev_err(dev,\r\n"failed to create power runtime group: %d\n", error);\r\nreturn error;\r\n}\r\nerror = devm_add_action(dev, cyapa_remove_power_runtime_group, cyapa);\r\nif (error) {\r\ncyapa_remove_power_runtime_group(cyapa);\r\ndev_err(dev,\r\n"failed to add power runtime cleanup action: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\npm_runtime_set_suspended(dev);\r\npm_runtime_use_autosuspend(dev);\r\npm_runtime_set_autosuspend_delay(dev, AUTOSUSPEND_DELAY);\r\nreturn 0;\r\n}\r\nstatic inline int cyapa_start_runtime(struct cyapa *cyapa)\r\n{\r\nreturn 0;\r\n}\r\nstatic ssize_t cyapa_show_fm_ver(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint error;\r\nstruct cyapa *cyapa = dev_get_drvdata(dev);\r\nerror = mutex_lock_interruptible(&cyapa->state_sync_lock);\r\nif (error)\r\nreturn error;\r\nerror = scnprintf(buf, PAGE_SIZE, "%d.%d\n", cyapa->fw_maj_ver,\r\ncyapa->fw_min_ver);\r\nmutex_unlock(&cyapa->state_sync_lock);\r\nreturn error;\r\n}\r\nstatic ssize_t cyapa_show_product_id(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct cyapa *cyapa = dev_get_drvdata(dev);\r\nint size;\r\nint error;\r\nerror = mutex_lock_interruptible(&cyapa->state_sync_lock);\r\nif (error)\r\nreturn error;\r\nsize = scnprintf(buf, PAGE_SIZE, "%s\n", cyapa->product_id);\r\nmutex_unlock(&cyapa->state_sync_lock);\r\nreturn size;\r\n}\r\nstatic int cyapa_firmware(struct cyapa *cyapa, const char *fw_name)\r\n{\r\nstruct device *dev = &cyapa->client->dev;\r\nconst struct firmware *fw;\r\nint error;\r\nerror = request_firmware(&fw, fw_name, dev);\r\nif (error) {\r\ndev_err(dev, "Could not load firmware from %s: %d\n",\r\nfw_name, error);\r\nreturn error;\r\n}\r\nerror = cyapa->ops->check_fw(cyapa, fw);\r\nif (error) {\r\ndev_err(dev, "Invalid CYAPA firmware image: %s\n",\r\nfw_name);\r\ngoto done;\r\n}\r\npm_runtime_get_sync(dev);\r\ncyapa_enable_irq_for_cmd(cyapa);\r\nerror = cyapa->ops->bl_enter(cyapa);\r\nif (error) {\r\ndev_err(dev, "bl_enter failed, %d\n", error);\r\ngoto err_detect;\r\n}\r\nerror = cyapa->ops->bl_activate(cyapa);\r\nif (error) {\r\ndev_err(dev, "bl_activate failed, %d\n", error);\r\ngoto err_detect;\r\n}\r\nerror = cyapa->ops->bl_initiate(cyapa, fw);\r\nif (error) {\r\ndev_err(dev, "bl_initiate failed, %d\n", error);\r\ngoto err_detect;\r\n}\r\nerror = cyapa->ops->update_fw(cyapa, fw);\r\nif (error) {\r\ndev_err(dev, "update_fw failed, %d\n", error);\r\ngoto err_detect;\r\n}\r\nerr_detect:\r\ncyapa_disable_irq_for_cmd(cyapa);\r\npm_runtime_put_noidle(dev);\r\ndone:\r\nrelease_firmware(fw);\r\nreturn error;\r\n}\r\nstatic ssize_t cyapa_update_fw_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct cyapa *cyapa = dev_get_drvdata(dev);\r\nchar fw_name[NAME_MAX];\r\nint ret, error;\r\nif (count >= NAME_MAX) {\r\ndev_err(dev, "File name too long\n");\r\nreturn -EINVAL;\r\n}\r\nmemcpy(fw_name, buf, count);\r\nif (fw_name[count - 1] == '\n')\r\nfw_name[count - 1] = '\0';\r\nelse\r\nfw_name[count] = '\0';\r\nif (cyapa->input) {\r\ninput_unregister_device(cyapa->input);\r\ncyapa->input = NULL;\r\n}\r\nerror = mutex_lock_interruptible(&cyapa->state_sync_lock);\r\nif (error) {\r\ncyapa_reinitialize(cyapa);\r\nreturn error;\r\n}\r\nerror = cyapa_firmware(cyapa, fw_name);\r\nif (error)\r\ndev_err(dev, "firmware update failed: %d\n", error);\r\nelse\r\ndev_dbg(dev, "firmware update successfully done.\n");\r\nret = cyapa_reinitialize(cyapa);\r\nif (ret) {\r\ndev_err(dev, "failed to re-detect after updated: %d\n", ret);\r\nerror = error ? error : ret;\r\n}\r\nmutex_unlock(&cyapa->state_sync_lock);\r\nreturn error ? error : count;\r\n}\r\nstatic ssize_t cyapa_calibrate_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct cyapa *cyapa = dev_get_drvdata(dev);\r\nint error;\r\nerror = mutex_lock_interruptible(&cyapa->state_sync_lock);\r\nif (error)\r\nreturn error;\r\nif (cyapa->operational) {\r\ncyapa_enable_irq_for_cmd(cyapa);\r\nerror = cyapa->ops->calibrate_store(dev, attr, buf, count);\r\ncyapa_disable_irq_for_cmd(cyapa);\r\n} else {\r\nerror = -EBUSY;\r\n}\r\nmutex_unlock(&cyapa->state_sync_lock);\r\nreturn error < 0 ? error : count;\r\n}\r\nstatic ssize_t cyapa_show_baseline(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct cyapa *cyapa = dev_get_drvdata(dev);\r\nssize_t error;\r\nerror = mutex_lock_interruptible(&cyapa->state_sync_lock);\r\nif (error)\r\nreturn error;\r\nif (cyapa->operational) {\r\ncyapa_enable_irq_for_cmd(cyapa);\r\nerror = cyapa->ops->show_baseline(dev, attr, buf);\r\ncyapa_disable_irq_for_cmd(cyapa);\r\n} else {\r\nerror = -EBUSY;\r\n}\r\nmutex_unlock(&cyapa->state_sync_lock);\r\nreturn error;\r\n}\r\nstatic char *cyapa_state_to_string(struct cyapa *cyapa)\r\n{\r\nswitch (cyapa->state) {\r\ncase CYAPA_STATE_BL_BUSY:\r\nreturn "bootloader busy";\r\ncase CYAPA_STATE_BL_IDLE:\r\nreturn "bootloader idle";\r\ncase CYAPA_STATE_BL_ACTIVE:\r\nreturn "bootloader active";\r\ncase CYAPA_STATE_GEN5_BL:\r\ncase CYAPA_STATE_GEN6_BL:\r\nreturn "bootloader";\r\ncase CYAPA_STATE_OP:\r\ncase CYAPA_STATE_GEN5_APP:\r\ncase CYAPA_STATE_GEN6_APP:\r\nreturn "operational";\r\ndefault:\r\nreturn "invalid mode";\r\n}\r\n}\r\nstatic ssize_t cyapa_show_mode(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct cyapa *cyapa = dev_get_drvdata(dev);\r\nint size;\r\nint error;\r\nerror = mutex_lock_interruptible(&cyapa->state_sync_lock);\r\nif (error)\r\nreturn error;\r\nsize = scnprintf(buf, PAGE_SIZE, "gen%d %s\n",\r\ncyapa->gen, cyapa_state_to_string(cyapa));\r\nmutex_unlock(&cyapa->state_sync_lock);\r\nreturn size;\r\n}\r\nstatic void cyapa_remove_sysfs_group(void *data)\r\n{\r\nstruct cyapa *cyapa = data;\r\nsysfs_remove_group(&cyapa->client->dev.kobj, &cyapa_sysfs_group);\r\n}\r\nstatic void cyapa_disable_regulator(void *data)\r\n{\r\nstruct cyapa *cyapa = data;\r\nregulator_disable(cyapa->vcc);\r\n}\r\nstatic int cyapa_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *dev_id)\r\n{\r\nstruct device *dev = &client->dev;\r\nstruct cyapa *cyapa;\r\nu8 adapter_func;\r\nunion i2c_smbus_data dummy;\r\nint error;\r\nadapter_func = cyapa_check_adapter_functionality(client);\r\nif (adapter_func == CYAPA_ADAPTER_FUNC_NONE) {\r\ndev_err(dev, "not a supported I2C/SMBus adapter\n");\r\nreturn -EIO;\r\n}\r\nif (i2c_smbus_xfer(client->adapter, client->addr, 0,\r\nI2C_SMBUS_READ, 0, I2C_SMBUS_BYTE, &dummy) < 0)\r\nreturn -ENODEV;\r\ncyapa = devm_kzalloc(dev, sizeof(struct cyapa), GFP_KERNEL);\r\nif (!cyapa)\r\nreturn -ENOMEM;\r\nif (adapter_func == CYAPA_ADAPTER_FUNC_SMBUS)\r\ncyapa->smbus = true;\r\ncyapa->client = client;\r\ni2c_set_clientdata(client, cyapa);\r\nsprintf(cyapa->phys, "i2c-%d-%04x/input0", client->adapter->nr,\r\nclient->addr);\r\ncyapa->vcc = devm_regulator_get(dev, "vcc");\r\nif (IS_ERR(cyapa->vcc)) {\r\nerror = PTR_ERR(cyapa->vcc);\r\ndev_err(dev, "failed to get vcc regulator: %d\n", error);\r\nreturn error;\r\n}\r\nerror = regulator_enable(cyapa->vcc);\r\nif (error) {\r\ndev_err(dev, "failed to enable regulator: %d\n", error);\r\nreturn error;\r\n}\r\nerror = devm_add_action(dev, cyapa_disable_regulator, cyapa);\r\nif (error) {\r\ncyapa_disable_regulator(cyapa);\r\ndev_err(dev, "failed to add disable regulator action: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nerror = cyapa_initialize(cyapa);\r\nif (error) {\r\ndev_err(dev, "failed to detect and initialize tp device.\n");\r\nreturn error;\r\n}\r\nerror = sysfs_create_group(&dev->kobj, &cyapa_sysfs_group);\r\nif (error) {\r\ndev_err(dev, "failed to create sysfs entries: %d\n", error);\r\nreturn error;\r\n}\r\nerror = devm_add_action(dev, cyapa_remove_sysfs_group, cyapa);\r\nif (error) {\r\ncyapa_remove_sysfs_group(cyapa);\r\ndev_err(dev, "failed to add sysfs cleanup action: %d\n", error);\r\nreturn error;\r\n}\r\nerror = cyapa_prepare_wakeup_controls(cyapa);\r\nif (error) {\r\ndev_err(dev, "failed to prepare wakeup controls: %d\n", error);\r\nreturn error;\r\n}\r\nerror = cyapa_start_runtime(cyapa);\r\nif (error) {\r\ndev_err(dev, "failed to start pm_runtime: %d\n", error);\r\nreturn error;\r\n}\r\nerror = devm_request_threaded_irq(dev, client->irq,\r\nNULL, cyapa_irq,\r\nIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\r\n"cyapa", cyapa);\r\nif (error) {\r\ndev_err(dev, "failed to request threaded irq: %d\n", error);\r\nreturn error;\r\n}\r\ndisable_irq(client->irq);\r\nif (cyapa->operational) {\r\nerror = cyapa_create_input_dev(cyapa);\r\nif (error) {\r\ndev_err(dev, "create input_dev instance failed: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused cyapa_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct cyapa *cyapa = i2c_get_clientdata(client);\r\nu8 power_mode;\r\nint error;\r\nerror = mutex_lock_interruptible(&cyapa->state_sync_lock);\r\nif (error)\r\nreturn error;\r\nif (pm_runtime_enabled(dev))\r\npm_runtime_disable(dev);\r\ndisable_irq(client->irq);\r\nif (cyapa->operational) {\r\npower_mode = device_may_wakeup(dev) ? cyapa->suspend_power_mode\r\n: PWR_MODE_OFF;\r\nerror = cyapa->ops->set_power_mode(cyapa, power_mode,\r\ncyapa->suspend_sleep_time, CYAPA_PM_SUSPEND);\r\nif (error)\r\ndev_err(dev, "suspend set power mode failed: %d\n",\r\nerror);\r\n}\r\nif (cyapa->dev_pwr_mode != PWR_MODE_OFF)\r\ncyapa->ops->set_proximity(cyapa, false);\r\nif (device_may_wakeup(dev))\r\ncyapa->irq_wake = (enable_irq_wake(client->irq) == 0);\r\nmutex_unlock(&cyapa->state_sync_lock);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused cyapa_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct cyapa *cyapa = i2c_get_clientdata(client);\r\nint error;\r\nmutex_lock(&cyapa->state_sync_lock);\r\nif (device_may_wakeup(dev) && cyapa->irq_wake) {\r\ndisable_irq_wake(client->irq);\r\ncyapa->irq_wake = false;\r\n}\r\nerror = cyapa_reinitialize(cyapa);\r\nif (error)\r\ndev_warn(dev, "failed to reinitialize TP device: %d\n", error);\r\nenable_irq(client->irq);\r\nmutex_unlock(&cyapa->state_sync_lock);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused cyapa_runtime_suspend(struct device *dev)\r\n{\r\nstruct cyapa *cyapa = dev_get_drvdata(dev);\r\nint error;\r\nerror = cyapa->ops->set_power_mode(cyapa,\r\ncyapa->runtime_suspend_power_mode,\r\ncyapa->runtime_suspend_sleep_time,\r\nCYAPA_PM_RUNTIME_SUSPEND);\r\nif (error)\r\ndev_warn(dev, "runtime suspend failed: %d\n", error);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused cyapa_runtime_resume(struct device *dev)\r\n{\r\nstruct cyapa *cyapa = dev_get_drvdata(dev);\r\nint error;\r\nerror = cyapa->ops->set_power_mode(cyapa,\r\nPWR_MODE_FULL_ACTIVE, 0, CYAPA_PM_RUNTIME_RESUME);\r\nif (error)\r\ndev_warn(dev, "runtime resume failed: %d\n", error);\r\nreturn 0;\r\n}
