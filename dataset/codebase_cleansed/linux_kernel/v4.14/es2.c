static inline struct es2_ap_dev *hd_to_es2(struct gb_host_device *hd)\r\n{\r\nreturn (struct es2_ap_dev *)&hd->hd_priv;\r\n}\r\nstatic int output_sync(struct es2_ap_dev *es2, void *req, u16 size, u8 cmd)\r\n{\r\nstruct usb_device *udev = es2->usb_dev;\r\nu8 *data;\r\nint retval;\r\ndata = kmemdup(req, size, GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nretval = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\r\ncmd,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR |\r\nUSB_RECIP_INTERFACE,\r\n0, 0, data, size, ES2_USB_CTRL_TIMEOUT);\r\nif (retval < 0)\r\ndev_err(&udev->dev, "%s: return error %d\n", __func__, retval);\r\nelse\r\nretval = 0;\r\nkfree(data);\r\nreturn retval;\r\n}\r\nstatic void ap_urb_complete(struct urb *urb)\r\n{\r\nstruct usb_ctrlrequest *dr = urb->context;\r\nkfree(dr);\r\nusb_free_urb(urb);\r\n}\r\nstatic int output_async(struct es2_ap_dev *es2, void *req, u16 size, u8 cmd)\r\n{\r\nstruct usb_device *udev = es2->usb_dev;\r\nstruct urb *urb;\r\nstruct usb_ctrlrequest *dr;\r\nu8 *buf;\r\nint retval;\r\nurb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (!urb)\r\nreturn -ENOMEM;\r\ndr = kmalloc(sizeof(*dr) + size, GFP_ATOMIC);\r\nif (!dr) {\r\nusb_free_urb(urb);\r\nreturn -ENOMEM;\r\n}\r\nbuf = (u8 *)dr + sizeof(*dr);\r\nmemcpy(buf, req, size);\r\ndr->bRequest = cmd;\r\ndr->bRequestType = USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE;\r\ndr->wValue = 0;\r\ndr->wIndex = 0;\r\ndr->wLength = cpu_to_le16(size);\r\nusb_fill_control_urb(urb, udev, usb_sndctrlpipe(udev, 0),\r\n(unsigned char *)dr, buf, size,\r\nap_urb_complete, dr);\r\nretval = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (retval) {\r\nusb_free_urb(urb);\r\nkfree(dr);\r\n}\r\nreturn retval;\r\n}\r\nstatic int output(struct gb_host_device *hd, void *req, u16 size, u8 cmd,\r\nbool async)\r\n{\r\nstruct es2_ap_dev *es2 = hd_to_es2(hd);\r\nif (async)\r\nreturn output_async(es2, req, size, cmd);\r\nreturn output_sync(es2, req, size, cmd);\r\n}\r\nstatic int es2_cport_in_enable(struct es2_ap_dev *es2,\r\nstruct es2_cport_in *cport_in)\r\n{\r\nstruct urb *urb;\r\nint ret;\r\nint i;\r\nfor (i = 0; i < NUM_CPORT_IN_URB; ++i) {\r\nurb = cport_in->urb[i];\r\nret = usb_submit_urb(urb, GFP_KERNEL);\r\nif (ret) {\r\ndev_err(&es2->usb_dev->dev,\r\n"failed to submit in-urb: %d\n", ret);\r\ngoto err_kill_urbs;\r\n}\r\n}\r\nreturn 0;\r\nerr_kill_urbs:\r\nfor (--i; i >= 0; --i) {\r\nurb = cport_in->urb[i];\r\nusb_kill_urb(urb);\r\n}\r\nreturn ret;\r\n}\r\nstatic void es2_cport_in_disable(struct es2_ap_dev *es2,\r\nstruct es2_cport_in *cport_in)\r\n{\r\nstruct urb *urb;\r\nint i;\r\nfor (i = 0; i < NUM_CPORT_IN_URB; ++i) {\r\nurb = cport_in->urb[i];\r\nusb_kill_urb(urb);\r\n}\r\n}\r\nstatic int es2_arpc_in_enable(struct es2_ap_dev *es2)\r\n{\r\nstruct urb *urb;\r\nint ret;\r\nint i;\r\nfor (i = 0; i < NUM_ARPC_IN_URB; ++i) {\r\nurb = es2->arpc_urb[i];\r\nret = usb_submit_urb(urb, GFP_KERNEL);\r\nif (ret) {\r\ndev_err(&es2->usb_dev->dev,\r\n"failed to submit arpc in-urb: %d\n", ret);\r\ngoto err_kill_urbs;\r\n}\r\n}\r\nreturn 0;\r\nerr_kill_urbs:\r\nfor (--i; i >= 0; --i) {\r\nurb = es2->arpc_urb[i];\r\nusb_kill_urb(urb);\r\n}\r\nreturn ret;\r\n}\r\nstatic void es2_arpc_in_disable(struct es2_ap_dev *es2)\r\n{\r\nstruct urb *urb;\r\nint i;\r\nfor (i = 0; i < NUM_ARPC_IN_URB; ++i) {\r\nurb = es2->arpc_urb[i];\r\nusb_kill_urb(urb);\r\n}\r\n}\r\nstatic struct urb *next_free_urb(struct es2_ap_dev *es2, gfp_t gfp_mask)\r\n{\r\nstruct urb *urb = NULL;\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&es2->cport_out_urb_lock, flags);\r\nfor (i = 0; i < NUM_CPORT_OUT_URB; ++i) {\r\nif (es2->cport_out_urb_busy[i] == false &&\r\nes2->cport_out_urb_cancelled[i] == false) {\r\nes2->cport_out_urb_busy[i] = true;\r\nurb = es2->cport_out_urb[i];\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&es2->cport_out_urb_lock, flags);\r\nif (urb)\r\nreturn urb;\r\ndev_dbg(&es2->usb_dev->dev,\r\n"No free CPort OUT urbs, having to dynamically allocate one!\n");\r\nreturn usb_alloc_urb(0, gfp_mask);\r\n}\r\nstatic void free_urb(struct es2_ap_dev *es2, struct urb *urb)\r\n{\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&es2->cport_out_urb_lock, flags);\r\nfor (i = 0; i < NUM_CPORT_OUT_URB; ++i) {\r\nif (urb == es2->cport_out_urb[i]) {\r\nes2->cport_out_urb_busy[i] = false;\r\nurb = NULL;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&es2->cport_out_urb_lock, flags);\r\nusb_free_urb(urb);\r\n}\r\nstatic void\r\ngb_message_cport_pack(struct gb_operation_msg_hdr *header, u16 cport_id)\r\n{\r\nheader->pad[0] = cport_id;\r\n}\r\nstatic void gb_message_cport_clear(struct gb_operation_msg_hdr *header)\r\n{\r\nheader->pad[0] = 0;\r\n}\r\nstatic u16 gb_message_cport_unpack(struct gb_operation_msg_hdr *header)\r\n{\r\nu16 cport_id = header->pad[0];\r\ngb_message_cport_clear(header);\r\nreturn cport_id;\r\n}\r\nstatic int message_send(struct gb_host_device *hd, u16 cport_id,\r\nstruct gb_message *message, gfp_t gfp_mask)\r\n{\r\nstruct es2_ap_dev *es2 = hd_to_es2(hd);\r\nstruct usb_device *udev = es2->usb_dev;\r\nsize_t buffer_size;\r\nint retval;\r\nstruct urb *urb;\r\nunsigned long flags;\r\nif (!cport_id_valid(hd, cport_id)) {\r\ndev_err(&udev->dev, "invalid cport %u\n", cport_id);\r\nreturn -EINVAL;\r\n}\r\nurb = next_free_urb(es2, gfp_mask);\r\nif (!urb)\r\nreturn -ENOMEM;\r\nspin_lock_irqsave(&es2->cport_out_urb_lock, flags);\r\nmessage->hcpriv = urb;\r\nspin_unlock_irqrestore(&es2->cport_out_urb_lock, flags);\r\ngb_message_cport_pack(message->header, cport_id);\r\nbuffer_size = sizeof(*message->header) + message->payload_size;\r\nusb_fill_bulk_urb(urb, udev,\r\nusb_sndbulkpipe(udev,\r\nes2->cport_out_endpoint),\r\nmessage->buffer, buffer_size,\r\ncport_out_callback, message);\r\nurb->transfer_flags |= URB_ZERO_PACKET;\r\ntrace_gb_message_submit(message);\r\nretval = usb_submit_urb(urb, gfp_mask);\r\nif (retval) {\r\ndev_err(&udev->dev, "failed to submit out-urb: %d\n", retval);\r\nspin_lock_irqsave(&es2->cport_out_urb_lock, flags);\r\nmessage->hcpriv = NULL;\r\nspin_unlock_irqrestore(&es2->cport_out_urb_lock, flags);\r\nfree_urb(es2, urb);\r\ngb_message_cport_clear(message->header);\r\nreturn retval;\r\n}\r\nreturn 0;\r\n}\r\nstatic void message_cancel(struct gb_message *message)\r\n{\r\nstruct gb_host_device *hd = message->operation->connection->hd;\r\nstruct es2_ap_dev *es2 = hd_to_es2(hd);\r\nstruct urb *urb;\r\nint i;\r\nmight_sleep();\r\nspin_lock_irq(&es2->cport_out_urb_lock);\r\nurb = message->hcpriv;\r\nusb_get_urb(urb);\r\nfor (i = 0; i < NUM_CPORT_OUT_URB; ++i) {\r\nif (urb == es2->cport_out_urb[i]) {\r\nes2->cport_out_urb_cancelled[i] = true;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irq(&es2->cport_out_urb_lock);\r\nusb_kill_urb(urb);\r\nif (i < NUM_CPORT_OUT_URB) {\r\nspin_lock_irq(&es2->cport_out_urb_lock);\r\nes2->cport_out_urb_cancelled[i] = false;\r\nspin_unlock_irq(&es2->cport_out_urb_lock);\r\n}\r\nusb_free_urb(urb);\r\n}\r\nstatic int es2_cport_allocate(struct gb_host_device *hd, int cport_id,\r\nunsigned long flags)\r\n{\r\nstruct es2_ap_dev *es2 = hd_to_es2(hd);\r\nstruct ida *id_map = &hd->cport_id_map;\r\nint ida_start, ida_end;\r\nswitch (cport_id) {\r\ncase ES2_CPORT_CDSI0:\r\ncase ES2_CPORT_CDSI1:\r\ndev_err(&hd->dev, "cport %d not available\n", cport_id);\r\nreturn -EBUSY;\r\n}\r\nif (flags & GB_CONNECTION_FLAG_OFFLOADED &&\r\nflags & GB_CONNECTION_FLAG_CDSI1) {\r\nif (es2->cdsi1_in_use) {\r\ndev_err(&hd->dev, "CDSI1 already in use\n");\r\nreturn -EBUSY;\r\n}\r\nes2->cdsi1_in_use = true;\r\nreturn ES2_CPORT_CDSI1;\r\n}\r\nif (cport_id < 0) {\r\nida_start = 0;\r\nida_end = hd->num_cports;\r\n} else if (cport_id < hd->num_cports) {\r\nida_start = cport_id;\r\nida_end = cport_id + 1;\r\n} else {\r\ndev_err(&hd->dev, "cport %d not available\n", cport_id);\r\nreturn -EINVAL;\r\n}\r\nreturn ida_simple_get(id_map, ida_start, ida_end, GFP_KERNEL);\r\n}\r\nstatic void es2_cport_release(struct gb_host_device *hd, u16 cport_id)\r\n{\r\nstruct es2_ap_dev *es2 = hd_to_es2(hd);\r\nswitch (cport_id) {\r\ncase ES2_CPORT_CDSI1:\r\nes2->cdsi1_in_use = false;\r\nreturn;\r\n}\r\nida_simple_remove(&hd->cport_id_map, cport_id);\r\n}\r\nstatic int cport_enable(struct gb_host_device *hd, u16 cport_id,\r\nunsigned long flags)\r\n{\r\nstruct es2_ap_dev *es2 = hd_to_es2(hd);\r\nstruct usb_device *udev = es2->usb_dev;\r\nstruct gb_apb_request_cport_flags *req;\r\nu32 connection_flags;\r\nint ret;\r\nreq = kzalloc(sizeof(*req), GFP_KERNEL);\r\nif (!req)\r\nreturn -ENOMEM;\r\nconnection_flags = 0;\r\nif (flags & GB_CONNECTION_FLAG_CONTROL)\r\nconnection_flags |= GB_APB_CPORT_FLAG_CONTROL;\r\nif (flags & GB_CONNECTION_FLAG_HIGH_PRIO)\r\nconnection_flags |= GB_APB_CPORT_FLAG_HIGH_PRIO;\r\nreq->flags = cpu_to_le32(connection_flags);\r\ndev_dbg(&hd->dev, "%s - cport = %u, flags = %02x\n", __func__,\r\ncport_id, connection_flags);\r\nret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\r\nGB_APB_REQUEST_CPORT_FLAGS,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR |\r\nUSB_RECIP_INTERFACE, cport_id, 0,\r\nreq, sizeof(*req), ES2_USB_CTRL_TIMEOUT);\r\nif (ret != sizeof(*req)) {\r\ndev_err(&udev->dev, "failed to set cport flags for port %d\n",\r\ncport_id);\r\nif (ret >= 0)\r\nret = -EIO;\r\ngoto out;\r\n}\r\nret = 0;\r\nout:\r\nkfree(req);\r\nreturn ret;\r\n}\r\nstatic int es2_cport_connected(struct gb_host_device *hd, u16 cport_id)\r\n{\r\nstruct es2_ap_dev *es2 = hd_to_es2(hd);\r\nstruct device *dev = &es2->usb_dev->dev;\r\nstruct arpc_cport_connected_req req;\r\nint ret;\r\nreq.cport_id = cpu_to_le16(cport_id);\r\nret = arpc_sync(es2, ARPC_TYPE_CPORT_CONNECTED, &req, sizeof(req),\r\nNULL, ES2_ARPC_CPORT_TIMEOUT);\r\nif (ret) {\r\ndev_err(dev, "failed to set connected state for cport %u: %d\n",\r\ncport_id, ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int es2_cport_flush(struct gb_host_device *hd, u16 cport_id)\r\n{\r\nstruct es2_ap_dev *es2 = hd_to_es2(hd);\r\nstruct device *dev = &es2->usb_dev->dev;\r\nstruct arpc_cport_flush_req req;\r\nint ret;\r\nreq.cport_id = cpu_to_le16(cport_id);\r\nret = arpc_sync(es2, ARPC_TYPE_CPORT_FLUSH, &req, sizeof(req),\r\nNULL, ES2_ARPC_CPORT_TIMEOUT);\r\nif (ret) {\r\ndev_err(dev, "failed to flush cport %u: %d\n", cport_id, ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int es2_cport_shutdown(struct gb_host_device *hd, u16 cport_id,\r\nu8 phase, unsigned int timeout)\r\n{\r\nstruct es2_ap_dev *es2 = hd_to_es2(hd);\r\nstruct device *dev = &es2->usb_dev->dev;\r\nstruct arpc_cport_shutdown_req req;\r\nint result;\r\nint ret;\r\nif (timeout > U16_MAX)\r\nreturn -EINVAL;\r\nreq.cport_id = cpu_to_le16(cport_id);\r\nreq.timeout = cpu_to_le16(timeout);\r\nreq.phase = phase;\r\nret = arpc_sync(es2, ARPC_TYPE_CPORT_SHUTDOWN, &req, sizeof(req),\r\n&result, ES2_ARPC_CPORT_TIMEOUT + timeout);\r\nif (ret) {\r\ndev_err(dev, "failed to send shutdown over cport %u: %d (%d)\n",\r\ncport_id, ret, result);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int es2_cport_quiesce(struct gb_host_device *hd, u16 cport_id,\r\nsize_t peer_space, unsigned int timeout)\r\n{\r\nstruct es2_ap_dev *es2 = hd_to_es2(hd);\r\nstruct device *dev = &es2->usb_dev->dev;\r\nstruct arpc_cport_quiesce_req req;\r\nint result;\r\nint ret;\r\nif (peer_space > U16_MAX)\r\nreturn -EINVAL;\r\nif (timeout > U16_MAX)\r\nreturn -EINVAL;\r\nreq.cport_id = cpu_to_le16(cport_id);\r\nreq.peer_space = cpu_to_le16(peer_space);\r\nreq.timeout = cpu_to_le16(timeout);\r\nret = arpc_sync(es2, ARPC_TYPE_CPORT_QUIESCE, &req, sizeof(req),\r\n&result, ES2_ARPC_CPORT_TIMEOUT + timeout);\r\nif (ret) {\r\ndev_err(dev, "failed to quiesce cport %u: %d (%d)\n",\r\ncport_id, ret, result);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int es2_cport_clear(struct gb_host_device *hd, u16 cport_id)\r\n{\r\nstruct es2_ap_dev *es2 = hd_to_es2(hd);\r\nstruct device *dev = &es2->usb_dev->dev;\r\nstruct arpc_cport_clear_req req;\r\nint ret;\r\nreq.cport_id = cpu_to_le16(cport_id);\r\nret = arpc_sync(es2, ARPC_TYPE_CPORT_CLEAR, &req, sizeof(req),\r\nNULL, ES2_ARPC_CPORT_TIMEOUT);\r\nif (ret) {\r\ndev_err(dev, "failed to clear cport %u: %d\n", cport_id, ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int latency_tag_enable(struct gb_host_device *hd, u16 cport_id)\r\n{\r\nint retval;\r\nstruct es2_ap_dev *es2 = hd_to_es2(hd);\r\nstruct usb_device *udev = es2->usb_dev;\r\nretval = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\r\nGB_APB_REQUEST_LATENCY_TAG_EN,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR |\r\nUSB_RECIP_INTERFACE, cport_id, 0, NULL,\r\n0, ES2_USB_CTRL_TIMEOUT);\r\nif (retval < 0)\r\ndev_err(&udev->dev, "Cannot enable latency tag for cport %d\n",\r\ncport_id);\r\nreturn retval;\r\n}\r\nstatic int latency_tag_disable(struct gb_host_device *hd, u16 cport_id)\r\n{\r\nint retval;\r\nstruct es2_ap_dev *es2 = hd_to_es2(hd);\r\nstruct usb_device *udev = es2->usb_dev;\r\nretval = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\r\nGB_APB_REQUEST_LATENCY_TAG_DIS,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR |\r\nUSB_RECIP_INTERFACE, cport_id, 0, NULL,\r\n0, ES2_USB_CTRL_TIMEOUT);\r\nif (retval < 0)\r\ndev_err(&udev->dev, "Cannot disable latency tag for cport %d\n",\r\ncport_id);\r\nreturn retval;\r\n}\r\nstatic int check_urb_status(struct urb *urb)\r\n{\r\nstruct device *dev = &urb->dev->dev;\r\nint status = urb->status;\r\nswitch (status) {\r\ncase 0:\r\nreturn 0;\r\ncase -EOVERFLOW:\r\ndev_err(dev, "%s: overflow actual length is %d\n",\r\n__func__, urb->actual_length);\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ncase -EILSEQ:\r\ncase -EPROTO:\r\nreturn status;\r\n}\r\ndev_err(dev, "%s: unknown status %d\n", __func__, status);\r\nreturn -EAGAIN;\r\n}\r\nstatic void es2_destroy(struct es2_ap_dev *es2)\r\n{\r\nstruct usb_device *udev;\r\nstruct urb *urb;\r\nint i;\r\ndebugfs_remove(es2->apb_log_enable_dentry);\r\nusb_log_disable(es2);\r\nfor (i = 0; i < NUM_CPORT_OUT_URB; ++i) {\r\nurb = es2->cport_out_urb[i];\r\nusb_kill_urb(urb);\r\nusb_free_urb(urb);\r\nes2->cport_out_urb[i] = NULL;\r\nes2->cport_out_urb_busy[i] = false;\r\n}\r\nfor (i = 0; i < NUM_ARPC_IN_URB; ++i) {\r\nusb_free_urb(es2->arpc_urb[i]);\r\nkfree(es2->arpc_buffer[i]);\r\nes2->arpc_buffer[i] = NULL;\r\n}\r\nfor (i = 0; i < NUM_CPORT_IN_URB; ++i) {\r\nusb_free_urb(es2->cport_in.urb[i]);\r\nkfree(es2->cport_in.buffer[i]);\r\nes2->cport_in.buffer[i] = NULL;\r\n}\r\ngb_hd_cport_release_reserved(es2->hd, ES2_CPORT_CDSI1);\r\ngb_hd_cport_release_reserved(es2->hd, ES2_CPORT_CDSI0);\r\nudev = es2->usb_dev;\r\ngb_hd_put(es2->hd);\r\nusb_put_dev(udev);\r\n}\r\nstatic void cport_in_callback(struct urb *urb)\r\n{\r\nstruct gb_host_device *hd = urb->context;\r\nstruct device *dev = &urb->dev->dev;\r\nstruct gb_operation_msg_hdr *header;\r\nint status = check_urb_status(urb);\r\nint retval;\r\nu16 cport_id;\r\nif (status) {\r\nif ((status == -EAGAIN) || (status == -EPROTO))\r\ngoto exit;\r\nif (status == -ENOENT || status == -ESHUTDOWN)\r\nreturn;\r\ndev_err(dev, "urb cport in error %d (dropped)\n", status);\r\nreturn;\r\n}\r\nif (urb->actual_length < sizeof(*header)) {\r\ndev_err(dev, "short message received\n");\r\ngoto exit;\r\n}\r\nheader = urb->transfer_buffer;\r\ncport_id = gb_message_cport_unpack(header);\r\nif (cport_id_valid(hd, cport_id)) {\r\ngreybus_data_rcvd(hd, cport_id, urb->transfer_buffer,\r\nurb->actual_length);\r\n} else {\r\ndev_err(dev, "invalid cport id %u received\n", cport_id);\r\n}\r\nexit:\r\nretval = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (retval)\r\ndev_err(dev, "failed to resubmit in-urb: %d\n", retval);\r\n}\r\nstatic void cport_out_callback(struct urb *urb)\r\n{\r\nstruct gb_message *message = urb->context;\r\nstruct gb_host_device *hd = message->operation->connection->hd;\r\nstruct es2_ap_dev *es2 = hd_to_es2(hd);\r\nint status = check_urb_status(urb);\r\nunsigned long flags;\r\ngb_message_cport_clear(message->header);\r\nspin_lock_irqsave(&es2->cport_out_urb_lock, flags);\r\nmessage->hcpriv = NULL;\r\nspin_unlock_irqrestore(&es2->cport_out_urb_lock, flags);\r\ngreybus_message_sent(hd, message, status);\r\nfree_urb(es2, urb);\r\n}\r\nstatic struct arpc *arpc_alloc(void *payload, u16 size, u8 type)\r\n{\r\nstruct arpc *rpc;\r\nif (size + sizeof(*rpc->req) > ARPC_OUT_SIZE_MAX)\r\nreturn NULL;\r\nrpc = kzalloc(sizeof(*rpc), GFP_KERNEL);\r\nif (!rpc)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&rpc->list);\r\nrpc->req = kzalloc(sizeof(*rpc->req) + size, GFP_KERNEL);\r\nif (!rpc->req)\r\ngoto err_free_rpc;\r\nrpc->resp = kzalloc(sizeof(*rpc->resp), GFP_KERNEL);\r\nif (!rpc->resp)\r\ngoto err_free_req;\r\nrpc->req->type = type;\r\nrpc->req->size = cpu_to_le16(sizeof(*rpc->req) + size);\r\nmemcpy(rpc->req->data, payload, size);\r\ninit_completion(&rpc->response_received);\r\nreturn rpc;\r\nerr_free_req:\r\nkfree(rpc->req);\r\nerr_free_rpc:\r\nkfree(rpc);\r\nreturn NULL;\r\n}\r\nstatic void arpc_free(struct arpc *rpc)\r\n{\r\nkfree(rpc->req);\r\nkfree(rpc->resp);\r\nkfree(rpc);\r\n}\r\nstatic struct arpc *arpc_find(struct es2_ap_dev *es2, __le16 id)\r\n{\r\nstruct arpc *rpc;\r\nlist_for_each_entry(rpc, &es2->arpcs, list) {\r\nif (rpc->req->id == id)\r\nreturn rpc;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void arpc_add(struct es2_ap_dev *es2, struct arpc *rpc)\r\n{\r\nrpc->active = true;\r\nrpc->req->id = cpu_to_le16(es2->arpc_id_cycle++);\r\nlist_add_tail(&rpc->list, &es2->arpcs);\r\n}\r\nstatic void arpc_del(struct es2_ap_dev *es2, struct arpc *rpc)\r\n{\r\nif (rpc->active) {\r\nrpc->active = false;\r\nlist_del(&rpc->list);\r\n}\r\n}\r\nstatic int arpc_send(struct es2_ap_dev *es2, struct arpc *rpc, int timeout)\r\n{\r\nstruct usb_device *udev = es2->usb_dev;\r\nint retval;\r\nretval = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\r\nGB_APB_REQUEST_ARPC_RUN,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR |\r\nUSB_RECIP_INTERFACE,\r\n0, 0,\r\nrpc->req, le16_to_cpu(rpc->req->size),\r\nES2_USB_CTRL_TIMEOUT);\r\nif (retval != le16_to_cpu(rpc->req->size)) {\r\ndev_err(&udev->dev,\r\n"failed to send ARPC request %d: %d\n",\r\nrpc->req->type, retval);\r\nif (retval > 0)\r\nretval = -EIO;\r\nreturn retval;\r\n}\r\nreturn 0;\r\n}\r\nstatic int arpc_sync(struct es2_ap_dev *es2, u8 type, void *payload,\r\nsize_t size, int *result, unsigned int timeout)\r\n{\r\nstruct arpc *rpc;\r\nunsigned long flags;\r\nint retval;\r\nif (result)\r\n*result = 0;\r\nrpc = arpc_alloc(payload, size, type);\r\nif (!rpc)\r\nreturn -ENOMEM;\r\nspin_lock_irqsave(&es2->arpc_lock, flags);\r\narpc_add(es2, rpc);\r\nspin_unlock_irqrestore(&es2->arpc_lock, flags);\r\nretval = arpc_send(es2, rpc, timeout);\r\nif (retval)\r\ngoto out_arpc_del;\r\nretval = wait_for_completion_interruptible_timeout(\r\n&rpc->response_received,\r\nmsecs_to_jiffies(timeout));\r\nif (retval <= 0) {\r\nif (!retval)\r\nretval = -ETIMEDOUT;\r\ngoto out_arpc_del;\r\n}\r\nif (rpc->resp->result) {\r\nretval = -EREMOTEIO;\r\nif (result)\r\n*result = rpc->resp->result;\r\n} else {\r\nretval = 0;\r\n}\r\nout_arpc_del:\r\nspin_lock_irqsave(&es2->arpc_lock, flags);\r\narpc_del(es2, rpc);\r\nspin_unlock_irqrestore(&es2->arpc_lock, flags);\r\narpc_free(rpc);\r\nif (retval < 0 && retval != -EREMOTEIO) {\r\ndev_err(&es2->usb_dev->dev,\r\n"failed to execute ARPC: %d\n", retval);\r\n}\r\nreturn retval;\r\n}\r\nstatic void arpc_in_callback(struct urb *urb)\r\n{\r\nstruct es2_ap_dev *es2 = urb->context;\r\nstruct device *dev = &urb->dev->dev;\r\nint status = check_urb_status(urb);\r\nstruct arpc *rpc;\r\nstruct arpc_response_message *resp;\r\nunsigned long flags;\r\nint retval;\r\nif (status) {\r\nif ((status == -EAGAIN) || (status == -EPROTO))\r\ngoto exit;\r\nif (status == -ENOENT || status == -ESHUTDOWN)\r\nreturn;\r\ndev_err(dev, "arpc in-urb error %d (dropped)\n", status);\r\nreturn;\r\n}\r\nif (urb->actual_length < sizeof(*resp)) {\r\ndev_err(dev, "short aprc response received\n");\r\ngoto exit;\r\n}\r\nresp = urb->transfer_buffer;\r\nspin_lock_irqsave(&es2->arpc_lock, flags);\r\nrpc = arpc_find(es2, resp->id);\r\nif (!rpc) {\r\ndev_err(dev, "invalid arpc response id received: %u\n",\r\nle16_to_cpu(resp->id));\r\nspin_unlock_irqrestore(&es2->arpc_lock, flags);\r\ngoto exit;\r\n}\r\narpc_del(es2, rpc);\r\nmemcpy(rpc->resp, resp, sizeof(*resp));\r\ncomplete(&rpc->response_received);\r\nspin_unlock_irqrestore(&es2->arpc_lock, flags);\r\nexit:\r\nretval = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (retval)\r\ndev_err(dev, "failed to resubmit arpc in-urb: %d\n", retval);\r\n}\r\nstatic void apb_log_get(struct es2_ap_dev *es2, char *buf)\r\n{\r\nint retval;\r\ndo {\r\nretval = usb_control_msg(es2->usb_dev,\r\nusb_rcvctrlpipe(es2->usb_dev, 0),\r\nGB_APB_REQUEST_LOG,\r\nUSB_DIR_IN | USB_TYPE_VENDOR |\r\nUSB_RECIP_INTERFACE,\r\n0x00, 0x00,\r\nbuf,\r\nAPB1_LOG_MSG_SIZE,\r\nES2_USB_CTRL_TIMEOUT);\r\nif (retval > 0)\r\nkfifo_in(&es2->apb_log_fifo, buf, retval);\r\n} while (retval > 0);\r\n}\r\nstatic int apb_log_poll(void *data)\r\n{\r\nstruct es2_ap_dev *es2 = data;\r\nchar *buf;\r\nbuf = kmalloc(APB1_LOG_MSG_SIZE, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nwhile (!kthread_should_stop()) {\r\nmsleep(1000);\r\napb_log_get(es2, buf);\r\n}\r\nkfree(buf);\r\nreturn 0;\r\n}\r\nstatic ssize_t apb_log_read(struct file *f, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct es2_ap_dev *es2 = file_inode(f)->i_private;\r\nssize_t ret;\r\nsize_t copied;\r\nchar *tmp_buf;\r\nif (count > APB1_LOG_SIZE)\r\ncount = APB1_LOG_SIZE;\r\ntmp_buf = kmalloc(count, GFP_KERNEL);\r\nif (!tmp_buf)\r\nreturn -ENOMEM;\r\ncopied = kfifo_out(&es2->apb_log_fifo, tmp_buf, count);\r\nret = simple_read_from_buffer(buf, count, ppos, tmp_buf, copied);\r\nkfree(tmp_buf);\r\nreturn ret;\r\n}\r\nstatic void usb_log_enable(struct es2_ap_dev *es2)\r\n{\r\nif (!IS_ERR_OR_NULL(es2->apb_log_task))\r\nreturn;\r\nes2->apb_log_task = kthread_run(apb_log_poll, es2, "apb_log");\r\nif (IS_ERR(es2->apb_log_task))\r\nreturn;\r\nes2->apb_log_dentry = debugfs_create_file("apb_log", 0444,\r\ngb_debugfs_get(), es2,\r\n&apb_log_fops);\r\n}\r\nstatic void usb_log_disable(struct es2_ap_dev *es2)\r\n{\r\nif (IS_ERR_OR_NULL(es2->apb_log_task))\r\nreturn;\r\ndebugfs_remove(es2->apb_log_dentry);\r\nes2->apb_log_dentry = NULL;\r\nkthread_stop(es2->apb_log_task);\r\nes2->apb_log_task = NULL;\r\n}\r\nstatic ssize_t apb_log_enable_read(struct file *f, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct es2_ap_dev *es2 = file_inode(f)->i_private;\r\nint enable = !IS_ERR_OR_NULL(es2->apb_log_task);\r\nchar tmp_buf[3];\r\nsprintf(tmp_buf, "%d\n", enable);\r\nreturn simple_read_from_buffer(buf, count, ppos, tmp_buf, 3);\r\n}\r\nstatic ssize_t apb_log_enable_write(struct file *f, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nint enable;\r\nssize_t retval;\r\nstruct es2_ap_dev *es2 = file_inode(f)->i_private;\r\nretval = kstrtoint_from_user(buf, count, 10, &enable);\r\nif (retval)\r\nreturn retval;\r\nif (enable)\r\nusb_log_enable(es2);\r\nelse\r\nusb_log_disable(es2);\r\nreturn count;\r\n}\r\nstatic int apb_get_cport_count(struct usb_device *udev)\r\n{\r\nint retval;\r\n__le16 *cport_count;\r\ncport_count = kzalloc(sizeof(*cport_count), GFP_KERNEL);\r\nif (!cport_count)\r\nreturn -ENOMEM;\r\nretval = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\r\nGB_APB_REQUEST_CPORT_COUNT,\r\nUSB_DIR_IN | USB_TYPE_VENDOR |\r\nUSB_RECIP_INTERFACE, 0, 0, cport_count,\r\nsizeof(*cport_count), ES2_USB_CTRL_TIMEOUT);\r\nif (retval != sizeof(*cport_count)) {\r\ndev_err(&udev->dev, "Cannot retrieve CPort count: %d\n",\r\nretval);\r\nif (retval >= 0)\r\nretval = -EIO;\r\ngoto out;\r\n}\r\nretval = le16_to_cpu(*cport_count);\r\nif (retval > U8_MAX) {\r\nretval = U8_MAX;\r\ndev_warn(&udev->dev, "Limiting number of CPorts to U8_MAX\n");\r\n}\r\nout:\r\nkfree(cport_count);\r\nreturn retval;\r\n}\r\nstatic int ap_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct es2_ap_dev *es2;\r\nstruct gb_host_device *hd;\r\nstruct usb_device *udev;\r\nstruct usb_host_interface *iface_desc;\r\nstruct usb_endpoint_descriptor *endpoint;\r\n__u8 ep_addr;\r\nint retval;\r\nint i;\r\nint num_cports;\r\nbool bulk_out_found = false;\r\nbool bulk_in_found = false;\r\nbool arpc_in_found = false;\r\nudev = usb_get_dev(interface_to_usbdev(interface));\r\nnum_cports = apb_get_cport_count(udev);\r\nif (num_cports < 0) {\r\nusb_put_dev(udev);\r\ndev_err(&udev->dev, "Cannot retrieve CPort count: %d\n",\r\nnum_cports);\r\nreturn num_cports;\r\n}\r\nhd = gb_hd_create(&es2_driver, &udev->dev, ES2_GBUF_MSG_SIZE_MAX,\r\nnum_cports);\r\nif (IS_ERR(hd)) {\r\nusb_put_dev(udev);\r\nreturn PTR_ERR(hd);\r\n}\r\nes2 = hd_to_es2(hd);\r\nes2->hd = hd;\r\nes2->usb_intf = interface;\r\nes2->usb_dev = udev;\r\nspin_lock_init(&es2->cport_out_urb_lock);\r\nINIT_KFIFO(es2->apb_log_fifo);\r\nusb_set_intfdata(interface, es2);\r\nretval = gb_hd_cport_reserve(hd, ES2_CPORT_CDSI0);\r\nif (retval)\r\ngoto error;\r\nretval = gb_hd_cport_reserve(hd, ES2_CPORT_CDSI1);\r\nif (retval)\r\ngoto error;\r\niface_desc = interface->cur_altsetting;\r\nfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\r\nendpoint = &iface_desc->endpoint[i].desc;\r\nep_addr = endpoint->bEndpointAddress;\r\nif (usb_endpoint_is_bulk_in(endpoint)) {\r\nif (!bulk_in_found) {\r\nes2->cport_in.endpoint = ep_addr;\r\nbulk_in_found = true;\r\n} else if (!arpc_in_found) {\r\nes2->arpc_endpoint_in = ep_addr;\r\narpc_in_found = true;\r\n} else {\r\ndev_warn(&udev->dev,\r\n"Unused bulk IN endpoint found: 0x%02x\n",\r\nep_addr);\r\n}\r\ncontinue;\r\n}\r\nif (usb_endpoint_is_bulk_out(endpoint)) {\r\nif (!bulk_out_found) {\r\nes2->cport_out_endpoint = ep_addr;\r\nbulk_out_found = true;\r\n} else {\r\ndev_warn(&udev->dev,\r\n"Unused bulk OUT endpoint found: 0x%02x\n",\r\nep_addr);\r\n}\r\ncontinue;\r\n}\r\ndev_warn(&udev->dev,\r\n"Unknown endpoint type found, address 0x%02x\n",\r\nep_addr);\r\n}\r\nif (!bulk_in_found || !arpc_in_found || !bulk_out_found) {\r\ndev_err(&udev->dev, "Not enough endpoints found in device, aborting!\n");\r\nretval = -ENODEV;\r\ngoto error;\r\n}\r\nfor (i = 0; i < NUM_CPORT_IN_URB; ++i) {\r\nstruct urb *urb;\r\nu8 *buffer;\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb) {\r\nretval = -ENOMEM;\r\ngoto error;\r\n}\r\nes2->cport_in.urb[i] = urb;\r\nbuffer = kmalloc(ES2_GBUF_MSG_SIZE_MAX, GFP_KERNEL);\r\nif (!buffer) {\r\nretval = -ENOMEM;\r\ngoto error;\r\n}\r\nusb_fill_bulk_urb(urb, udev,\r\nusb_rcvbulkpipe(udev, es2->cport_in.endpoint),\r\nbuffer, ES2_GBUF_MSG_SIZE_MAX,\r\ncport_in_callback, hd);\r\nes2->cport_in.buffer[i] = buffer;\r\n}\r\nfor (i = 0; i < NUM_ARPC_IN_URB; ++i) {\r\nstruct urb *urb;\r\nu8 *buffer;\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb) {\r\nretval = -ENOMEM;\r\ngoto error;\r\n}\r\nes2->arpc_urb[i] = urb;\r\nbuffer = kmalloc(ARPC_IN_SIZE_MAX, GFP_KERNEL);\r\nif (!buffer) {\r\nretval = -ENOMEM;\r\ngoto error;\r\n}\r\nusb_fill_bulk_urb(urb, udev,\r\nusb_rcvbulkpipe(udev,\r\nes2->arpc_endpoint_in),\r\nbuffer, ARPC_IN_SIZE_MAX,\r\narpc_in_callback, es2);\r\nes2->arpc_buffer[i] = buffer;\r\n}\r\nfor (i = 0; i < NUM_CPORT_OUT_URB; ++i) {\r\nstruct urb *urb;\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb) {\r\nretval = -ENOMEM;\r\ngoto error;\r\n}\r\nes2->cport_out_urb[i] = urb;\r\nes2->cport_out_urb_busy[i] = false;\r\n}\r\nes2->apb_log_enable_dentry = debugfs_create_file("apb_log_enable",\r\n0644,\r\ngb_debugfs_get(), es2,\r\n&apb_log_enable_fops);\r\nINIT_LIST_HEAD(&es2->arpcs);\r\nspin_lock_init(&es2->arpc_lock);\r\nretval = es2_arpc_in_enable(es2);\r\nif (retval)\r\ngoto error;\r\nretval = gb_hd_add(hd);\r\nif (retval)\r\ngoto err_disable_arpc_in;\r\nretval = es2_cport_in_enable(es2, &es2->cport_in);\r\nif (retval)\r\ngoto err_hd_del;\r\nreturn 0;\r\nerr_hd_del:\r\ngb_hd_del(hd);\r\nerr_disable_arpc_in:\r\nes2_arpc_in_disable(es2);\r\nerror:\r\nes2_destroy(es2);\r\nreturn retval;\r\n}\r\nstatic void ap_disconnect(struct usb_interface *interface)\r\n{\r\nstruct es2_ap_dev *es2 = usb_get_intfdata(interface);\r\ngb_hd_del(es2->hd);\r\nes2_cport_in_disable(es2, &es2->cport_in);\r\nes2_arpc_in_disable(es2);\r\nes2_destroy(es2);\r\n}
