static void o2net_init_nst(struct o2net_send_tracking *nst, u32 msgtype,\r\nu32 msgkey, struct task_struct *task, u8 node)\r\n{\r\nINIT_LIST_HEAD(&nst->st_net_debug_item);\r\nnst->st_task = task;\r\nnst->st_msg_type = msgtype;\r\nnst->st_msg_key = msgkey;\r\nnst->st_node = node;\r\n}\r\nstatic inline void o2net_set_nst_sock_time(struct o2net_send_tracking *nst)\r\n{\r\nnst->st_sock_time = ktime_get();\r\n}\r\nstatic inline void o2net_set_nst_send_time(struct o2net_send_tracking *nst)\r\n{\r\nnst->st_send_time = ktime_get();\r\n}\r\nstatic inline void o2net_set_nst_status_time(struct o2net_send_tracking *nst)\r\n{\r\nnst->st_status_time = ktime_get();\r\n}\r\nstatic inline void o2net_set_nst_sock_container(struct o2net_send_tracking *nst,\r\nstruct o2net_sock_container *sc)\r\n{\r\nnst->st_sc = sc;\r\n}\r\nstatic inline void o2net_set_nst_msg_id(struct o2net_send_tracking *nst,\r\nu32 msg_id)\r\n{\r\nnst->st_id = msg_id;\r\n}\r\nstatic inline void o2net_set_sock_timer(struct o2net_sock_container *sc)\r\n{\r\nsc->sc_tv_timer = ktime_get();\r\n}\r\nstatic inline void o2net_set_data_ready_time(struct o2net_sock_container *sc)\r\n{\r\nsc->sc_tv_data_ready = ktime_get();\r\n}\r\nstatic inline void o2net_set_advance_start_time(struct o2net_sock_container *sc)\r\n{\r\nsc->sc_tv_advance_start = ktime_get();\r\n}\r\nstatic inline void o2net_set_advance_stop_time(struct o2net_sock_container *sc)\r\n{\r\nsc->sc_tv_advance_stop = ktime_get();\r\n}\r\nstatic inline void o2net_set_func_start_time(struct o2net_sock_container *sc)\r\n{\r\nsc->sc_tv_func_start = ktime_get();\r\n}\r\nstatic inline void o2net_set_func_stop_time(struct o2net_sock_container *sc)\r\n{\r\nsc->sc_tv_func_stop = ktime_get();\r\n}\r\nstatic ktime_t o2net_get_func_run_time(struct o2net_sock_container *sc)\r\n{\r\nreturn ktime_sub(sc->sc_tv_func_stop, sc->sc_tv_func_start);\r\n}\r\nstatic void o2net_update_send_stats(struct o2net_send_tracking *nst,\r\nstruct o2net_sock_container *sc)\r\n{\r\nsc->sc_tv_status_total = ktime_add(sc->sc_tv_status_total,\r\nktime_sub(ktime_get(),\r\nnst->st_status_time));\r\nsc->sc_tv_send_total = ktime_add(sc->sc_tv_send_total,\r\nktime_sub(nst->st_status_time,\r\nnst->st_send_time));\r\nsc->sc_tv_acquiry_total = ktime_add(sc->sc_tv_acquiry_total,\r\nktime_sub(nst->st_send_time,\r\nnst->st_sock_time));\r\nsc->sc_send_count++;\r\n}\r\nstatic void o2net_update_recv_stats(struct o2net_sock_container *sc)\r\n{\r\nsc->sc_tv_process_total = ktime_add(sc->sc_tv_process_total,\r\no2net_get_func_run_time(sc));\r\nsc->sc_recv_count++;\r\n}\r\nstatic inline unsigned int o2net_reconnect_delay(void)\r\n{\r\nreturn o2nm_single_cluster->cl_reconnect_delay_ms;\r\n}\r\nstatic inline unsigned int o2net_keepalive_delay(void)\r\n{\r\nreturn o2nm_single_cluster->cl_keepalive_delay_ms;\r\n}\r\nstatic inline unsigned int o2net_idle_timeout(void)\r\n{\r\nreturn o2nm_single_cluster->cl_idle_timeout_ms;\r\n}\r\nstatic inline int o2net_sys_err_to_errno(enum o2net_system_error err)\r\n{\r\nint trans;\r\nBUG_ON(err >= O2NET_ERR_MAX);\r\ntrans = o2net_sys_err_translations[err];\r\nBUG_ON(err != O2NET_ERR_NONE && trans == 0);\r\nreturn trans;\r\n}\r\nstatic struct o2net_node * o2net_nn_from_num(u8 node_num)\r\n{\r\nBUG_ON(node_num >= ARRAY_SIZE(o2net_nodes));\r\nreturn &o2net_nodes[node_num];\r\n}\r\nstatic u8 o2net_num_from_nn(struct o2net_node *nn)\r\n{\r\nBUG_ON(nn == NULL);\r\nreturn nn - o2net_nodes;\r\n}\r\nstatic int o2net_prep_nsw(struct o2net_node *nn, struct o2net_status_wait *nsw)\r\n{\r\nint ret;\r\nspin_lock(&nn->nn_lock);\r\nret = idr_alloc(&nn->nn_status_idr, nsw, 0, 0, GFP_ATOMIC);\r\nif (ret >= 0) {\r\nnsw->ns_id = ret;\r\nlist_add_tail(&nsw->ns_node_item, &nn->nn_status_list);\r\n}\r\nspin_unlock(&nn->nn_lock);\r\nif (ret < 0)\r\nreturn ret;\r\ninit_waitqueue_head(&nsw->ns_wq);\r\nnsw->ns_sys_status = O2NET_ERR_NONE;\r\nnsw->ns_status = 0;\r\nreturn 0;\r\n}\r\nstatic void o2net_complete_nsw_locked(struct o2net_node *nn,\r\nstruct o2net_status_wait *nsw,\r\nenum o2net_system_error sys_status,\r\ns32 status)\r\n{\r\nassert_spin_locked(&nn->nn_lock);\r\nif (!list_empty(&nsw->ns_node_item)) {\r\nlist_del_init(&nsw->ns_node_item);\r\nnsw->ns_sys_status = sys_status;\r\nnsw->ns_status = status;\r\nidr_remove(&nn->nn_status_idr, nsw->ns_id);\r\nwake_up(&nsw->ns_wq);\r\n}\r\n}\r\nstatic void o2net_complete_nsw(struct o2net_node *nn,\r\nstruct o2net_status_wait *nsw,\r\nu64 id, enum o2net_system_error sys_status,\r\ns32 status)\r\n{\r\nspin_lock(&nn->nn_lock);\r\nif (nsw == NULL) {\r\nif (id > INT_MAX)\r\ngoto out;\r\nnsw = idr_find(&nn->nn_status_idr, id);\r\nif (nsw == NULL)\r\ngoto out;\r\n}\r\no2net_complete_nsw_locked(nn, nsw, sys_status, status);\r\nout:\r\nspin_unlock(&nn->nn_lock);\r\nreturn;\r\n}\r\nstatic void o2net_complete_nodes_nsw(struct o2net_node *nn)\r\n{\r\nstruct o2net_status_wait *nsw, *tmp;\r\nunsigned int num_kills = 0;\r\nassert_spin_locked(&nn->nn_lock);\r\nlist_for_each_entry_safe(nsw, tmp, &nn->nn_status_list, ns_node_item) {\r\no2net_complete_nsw_locked(nn, nsw, O2NET_ERR_DIED, 0);\r\nnum_kills++;\r\n}\r\nmlog(0, "completed %d messages for node %u\n", num_kills,\r\no2net_num_from_nn(nn));\r\n}\r\nstatic int o2net_nsw_completed(struct o2net_node *nn,\r\nstruct o2net_status_wait *nsw)\r\n{\r\nint completed;\r\nspin_lock(&nn->nn_lock);\r\ncompleted = list_empty(&nsw->ns_node_item);\r\nspin_unlock(&nn->nn_lock);\r\nreturn completed;\r\n}\r\nstatic void sc_kref_release(struct kref *kref)\r\n{\r\nstruct o2net_sock_container *sc = container_of(kref,\r\nstruct o2net_sock_container, sc_kref);\r\nBUG_ON(timer_pending(&sc->sc_idle_timeout));\r\nsclog(sc, "releasing\n");\r\nif (sc->sc_sock) {\r\nsock_release(sc->sc_sock);\r\nsc->sc_sock = NULL;\r\n}\r\no2nm_undepend_item(&sc->sc_node->nd_item);\r\no2nm_node_put(sc->sc_node);\r\nsc->sc_node = NULL;\r\no2net_debug_del_sc(sc);\r\nif (sc->sc_page)\r\n__free_page(sc->sc_page);\r\nkfree(sc);\r\n}\r\nstatic void sc_put(struct o2net_sock_container *sc)\r\n{\r\nsclog(sc, "put\n");\r\nkref_put(&sc->sc_kref, sc_kref_release);\r\n}\r\nstatic void sc_get(struct o2net_sock_container *sc)\r\n{\r\nsclog(sc, "get\n");\r\nkref_get(&sc->sc_kref);\r\n}\r\nstatic struct o2net_sock_container *sc_alloc(struct o2nm_node *node)\r\n{\r\nstruct o2net_sock_container *sc, *ret = NULL;\r\nstruct page *page = NULL;\r\nint status = 0;\r\npage = alloc_page(GFP_NOFS);\r\nsc = kzalloc(sizeof(*sc), GFP_NOFS);\r\nif (sc == NULL || page == NULL)\r\ngoto out;\r\nkref_init(&sc->sc_kref);\r\no2nm_node_get(node);\r\nsc->sc_node = node;\r\nstatus = o2nm_depend_item(&node->nd_item);\r\nif (status) {\r\nmlog_errno(status);\r\no2nm_node_put(node);\r\ngoto out;\r\n}\r\nINIT_WORK(&sc->sc_connect_work, o2net_sc_connect_completed);\r\nINIT_WORK(&sc->sc_rx_work, o2net_rx_until_empty);\r\nINIT_WORK(&sc->sc_shutdown_work, o2net_shutdown_sc);\r\nINIT_DELAYED_WORK(&sc->sc_keepalive_work, o2net_sc_send_keep_req);\r\nsetup_timer(&sc->sc_idle_timeout, o2net_idle_timer,\r\n(unsigned long)sc);\r\nsclog(sc, "alloced\n");\r\nret = sc;\r\nsc->sc_page = page;\r\no2net_debug_add_sc(sc);\r\nsc = NULL;\r\npage = NULL;\r\nout:\r\nif (page)\r\n__free_page(page);\r\nkfree(sc);\r\nreturn ret;\r\n}\r\nstatic void o2net_sc_queue_work(struct o2net_sock_container *sc,\r\nstruct work_struct *work)\r\n{\r\nsc_get(sc);\r\nif (!queue_work(o2net_wq, work))\r\nsc_put(sc);\r\n}\r\nstatic void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\r\nstruct delayed_work *work,\r\nint delay)\r\n{\r\nsc_get(sc);\r\nif (!queue_delayed_work(o2net_wq, work, delay))\r\nsc_put(sc);\r\n}\r\nstatic void o2net_sc_cancel_delayed_work(struct o2net_sock_container *sc,\r\nstruct delayed_work *work)\r\n{\r\nif (cancel_delayed_work(work))\r\nsc_put(sc);\r\n}\r\nint o2net_num_connected_peers(void)\r\n{\r\nreturn atomic_read(&o2net_connected_peers);\r\n}\r\nstatic void o2net_set_nn_state(struct o2net_node *nn,\r\nstruct o2net_sock_container *sc,\r\nunsigned valid, int err)\r\n{\r\nint was_valid = nn->nn_sc_valid;\r\nint was_err = nn->nn_persistent_error;\r\nstruct o2net_sock_container *old_sc = nn->nn_sc;\r\nassert_spin_locked(&nn->nn_lock);\r\nif (old_sc && !sc)\r\natomic_dec(&o2net_connected_peers);\r\nelse if (!old_sc && sc)\r\natomic_inc(&o2net_connected_peers);\r\nBUG_ON(sc && nn->nn_sc && nn->nn_sc != sc);\r\nmlog_bug_on_msg(err && valid, "err %d valid %u\n", err, valid);\r\nmlog_bug_on_msg(valid && !sc, "valid %u sc %p\n", valid, sc);\r\nif (was_valid && !valid && err == 0)\r\nerr = -ENOTCONN;\r\nmlog(ML_CONN, "node %u sc: %p -> %p, valid %u -> %u, err %d -> %d\n",\r\no2net_num_from_nn(nn), nn->nn_sc, sc, nn->nn_sc_valid, valid,\r\nnn->nn_persistent_error, err);\r\nnn->nn_sc = sc;\r\nnn->nn_sc_valid = valid ? 1 : 0;\r\nnn->nn_persistent_error = err;\r\nif (nn->nn_persistent_error || nn->nn_sc_valid)\r\nwake_up(&nn->nn_sc_wq);\r\nif (was_valid && !was_err && nn->nn_persistent_error) {\r\no2quo_conn_err(o2net_num_from_nn(nn));\r\nqueue_delayed_work(o2net_wq, &nn->nn_still_up,\r\nmsecs_to_jiffies(O2NET_QUORUM_DELAY_MS));\r\n}\r\nif (was_valid && !valid) {\r\nif (old_sc)\r\nprintk(KERN_NOTICE "o2net: No longer connected to "\r\nSC_NODEF_FMT "\n", SC_NODEF_ARGS(old_sc));\r\no2net_complete_nodes_nsw(nn);\r\n}\r\nif (!was_valid && valid) {\r\no2quo_conn_up(o2net_num_from_nn(nn));\r\ncancel_delayed_work(&nn->nn_connect_expired);\r\nprintk(KERN_NOTICE "o2net: %s " SC_NODEF_FMT "\n",\r\no2nm_this_node() > sc->sc_node->nd_num ?\r\n"Connected to" : "Accepted connection from",\r\nSC_NODEF_ARGS(sc));\r\n}\r\nif (!valid && o2net_wq) {\r\nunsigned long delay;\r\ndelay = (nn->nn_last_connect_attempt +\r\nmsecs_to_jiffies(o2net_reconnect_delay()))\r\n- jiffies;\r\nif (delay > msecs_to_jiffies(o2net_reconnect_delay()))\r\ndelay = 0;\r\nmlog(ML_CONN, "queueing conn attempt in %lu jiffies\n", delay);\r\nqueue_delayed_work(o2net_wq, &nn->nn_connect_work, delay);\r\ndelay += msecs_to_jiffies(o2net_idle_timeout());\r\nqueue_delayed_work(o2net_wq, &nn->nn_connect_expired, delay);\r\n}\r\nif ((old_sc == NULL) && sc)\r\nsc_get(sc);\r\nif (old_sc && (old_sc != sc)) {\r\no2net_sc_queue_work(old_sc, &old_sc->sc_shutdown_work);\r\nsc_put(old_sc);\r\n}\r\n}\r\nstatic void o2net_data_ready(struct sock *sk)\r\n{\r\nvoid (*ready)(struct sock *sk);\r\nstruct o2net_sock_container *sc;\r\nread_lock_bh(&sk->sk_callback_lock);\r\nsc = sk->sk_user_data;\r\nif (sc) {\r\nsclog(sc, "data_ready hit\n");\r\no2net_set_data_ready_time(sc);\r\no2net_sc_queue_work(sc, &sc->sc_rx_work);\r\nready = sc->sc_data_ready;\r\n} else {\r\nready = sk->sk_data_ready;\r\n}\r\nread_unlock_bh(&sk->sk_callback_lock);\r\nready(sk);\r\n}\r\nstatic void o2net_state_change(struct sock *sk)\r\n{\r\nvoid (*state_change)(struct sock *sk);\r\nstruct o2net_sock_container *sc;\r\nread_lock_bh(&sk->sk_callback_lock);\r\nsc = sk->sk_user_data;\r\nif (sc == NULL) {\r\nstate_change = sk->sk_state_change;\r\ngoto out;\r\n}\r\nsclog(sc, "state_change to %d\n", sk->sk_state);\r\nstate_change = sc->sc_state_change;\r\nswitch(sk->sk_state) {\r\ncase TCP_SYN_SENT:\r\ncase TCP_SYN_RECV:\r\nbreak;\r\ncase TCP_ESTABLISHED:\r\no2net_sc_queue_work(sc, &sc->sc_connect_work);\r\nbreak;\r\ndefault:\r\nprintk(KERN_INFO "o2net: Connection to " SC_NODEF_FMT\r\n" shutdown, state %d\n",\r\nSC_NODEF_ARGS(sc), sk->sk_state);\r\no2net_sc_queue_work(sc, &sc->sc_shutdown_work);\r\nbreak;\r\n}\r\nout:\r\nread_unlock_bh(&sk->sk_callback_lock);\r\nstate_change(sk);\r\n}\r\nstatic void o2net_register_callbacks(struct sock *sk,\r\nstruct o2net_sock_container *sc)\r\n{\r\nwrite_lock_bh(&sk->sk_callback_lock);\r\nif (sk->sk_data_ready == o2net_listen_data_ready) {\r\nsk->sk_data_ready = sk->sk_user_data;\r\nsk->sk_user_data = NULL;\r\n}\r\nBUG_ON(sk->sk_user_data != NULL);\r\nsk->sk_user_data = sc;\r\nsc_get(sc);\r\nsc->sc_data_ready = sk->sk_data_ready;\r\nsc->sc_state_change = sk->sk_state_change;\r\nsk->sk_data_ready = o2net_data_ready;\r\nsk->sk_state_change = o2net_state_change;\r\nmutex_init(&sc->sc_send_lock);\r\nwrite_unlock_bh(&sk->sk_callback_lock);\r\n}\r\nstatic int o2net_unregister_callbacks(struct sock *sk,\r\nstruct o2net_sock_container *sc)\r\n{\r\nint ret = 0;\r\nwrite_lock_bh(&sk->sk_callback_lock);\r\nif (sk->sk_user_data == sc) {\r\nret = 1;\r\nsk->sk_user_data = NULL;\r\nsk->sk_data_ready = sc->sc_data_ready;\r\nsk->sk_state_change = sc->sc_state_change;\r\n}\r\nwrite_unlock_bh(&sk->sk_callback_lock);\r\nreturn ret;\r\n}\r\nstatic void o2net_ensure_shutdown(struct o2net_node *nn,\r\nstruct o2net_sock_container *sc,\r\nint err)\r\n{\r\nspin_lock(&nn->nn_lock);\r\nif (nn->nn_sc == sc)\r\no2net_set_nn_state(nn, NULL, 0, err);\r\nspin_unlock(&nn->nn_lock);\r\n}\r\nstatic void o2net_shutdown_sc(struct work_struct *work)\r\n{\r\nstruct o2net_sock_container *sc =\r\ncontainer_of(work, struct o2net_sock_container,\r\nsc_shutdown_work);\r\nstruct o2net_node *nn = o2net_nn_from_num(sc->sc_node->nd_num);\r\nsclog(sc, "shutting down\n");\r\nif (o2net_unregister_callbacks(sc->sc_sock->sk, sc)) {\r\ndel_timer_sync(&sc->sc_idle_timeout);\r\no2net_sc_cancel_delayed_work(sc, &sc->sc_keepalive_work);\r\nsc_put(sc);\r\nkernel_sock_shutdown(sc->sc_sock, SHUT_RDWR);\r\n}\r\no2net_ensure_shutdown(nn, sc, 0);\r\nsc_put(sc);\r\n}\r\nstatic int o2net_handler_cmp(struct o2net_msg_handler *nmh, u32 msg_type,\r\nu32 key)\r\n{\r\nint ret = memcmp(&nmh->nh_key, &key, sizeof(key));\r\nif (ret == 0)\r\nret = memcmp(&nmh->nh_msg_type, &msg_type, sizeof(msg_type));\r\nreturn ret;\r\n}\r\nstatic struct o2net_msg_handler *\r\no2net_handler_tree_lookup(u32 msg_type, u32 key, struct rb_node ***ret_p,\r\nstruct rb_node **ret_parent)\r\n{\r\nstruct rb_node **p = &o2net_handler_tree.rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct o2net_msg_handler *nmh, *ret = NULL;\r\nint cmp;\r\nwhile (*p) {\r\nparent = *p;\r\nnmh = rb_entry(parent, struct o2net_msg_handler, nh_node);\r\ncmp = o2net_handler_cmp(nmh, msg_type, key);\r\nif (cmp < 0)\r\np = &(*p)->rb_left;\r\nelse if (cmp > 0)\r\np = &(*p)->rb_right;\r\nelse {\r\nret = nmh;\r\nbreak;\r\n}\r\n}\r\nif (ret_p != NULL)\r\n*ret_p = p;\r\nif (ret_parent != NULL)\r\n*ret_parent = parent;\r\nreturn ret;\r\n}\r\nstatic void o2net_handler_kref_release(struct kref *kref)\r\n{\r\nstruct o2net_msg_handler *nmh;\r\nnmh = container_of(kref, struct o2net_msg_handler, nh_kref);\r\nkfree(nmh);\r\n}\r\nstatic void o2net_handler_put(struct o2net_msg_handler *nmh)\r\n{\r\nkref_put(&nmh->nh_kref, o2net_handler_kref_release);\r\n}\r\nint o2net_register_handler(u32 msg_type, u32 key, u32 max_len,\r\no2net_msg_handler_func *func, void *data,\r\no2net_post_msg_handler_func *post_func,\r\nstruct list_head *unreg_list)\r\n{\r\nstruct o2net_msg_handler *nmh = NULL;\r\nstruct rb_node **p, *parent;\r\nint ret = 0;\r\nif (max_len > O2NET_MAX_PAYLOAD_BYTES) {\r\nmlog(0, "max_len for message handler out of range: %u\n",\r\nmax_len);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (!msg_type) {\r\nmlog(0, "no message type provided: %u, %p\n", msg_type, func);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (!func) {\r\nmlog(0, "no message handler provided: %u, %p\n",\r\nmsg_type, func);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nnmh = kzalloc(sizeof(struct o2net_msg_handler), GFP_NOFS);\r\nif (nmh == NULL) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nnmh->nh_func = func;\r\nnmh->nh_func_data = data;\r\nnmh->nh_post_func = post_func;\r\nnmh->nh_msg_type = msg_type;\r\nnmh->nh_max_len = max_len;\r\nnmh->nh_key = key;\r\nkref_init(&nmh->nh_kref);\r\nINIT_LIST_HEAD(&nmh->nh_unregister_item);\r\nwrite_lock(&o2net_handler_lock);\r\nif (o2net_handler_tree_lookup(msg_type, key, &p, &parent))\r\nret = -EEXIST;\r\nelse {\r\nrb_link_node(&nmh->nh_node, parent, p);\r\nrb_insert_color(&nmh->nh_node, &o2net_handler_tree);\r\nlist_add_tail(&nmh->nh_unregister_item, unreg_list);\r\nmlog(ML_TCP, "registered handler func %p type %u key %08x\n",\r\nfunc, msg_type, key);\r\nmlog_bug_on_msg(o2net_handler_tree_lookup(msg_type, key, &p,\r\n&parent) == NULL,\r\n"couldn't find handler we *just* registered "\r\n"for type %u key %08x\n", msg_type, key);\r\n}\r\nwrite_unlock(&o2net_handler_lock);\r\nif (ret)\r\ngoto out;\r\nout:\r\nif (ret)\r\nkfree(nmh);\r\nreturn ret;\r\n}\r\nvoid o2net_unregister_handler_list(struct list_head *list)\r\n{\r\nstruct o2net_msg_handler *nmh, *n;\r\nwrite_lock(&o2net_handler_lock);\r\nlist_for_each_entry_safe(nmh, n, list, nh_unregister_item) {\r\nmlog(ML_TCP, "unregistering handler func %p type %u key %08x\n",\r\nnmh->nh_func, nmh->nh_msg_type, nmh->nh_key);\r\nrb_erase(&nmh->nh_node, &o2net_handler_tree);\r\nlist_del_init(&nmh->nh_unregister_item);\r\nkref_put(&nmh->nh_kref, o2net_handler_kref_release);\r\n}\r\nwrite_unlock(&o2net_handler_lock);\r\n}\r\nstatic struct o2net_msg_handler *o2net_handler_get(u32 msg_type, u32 key)\r\n{\r\nstruct o2net_msg_handler *nmh;\r\nread_lock(&o2net_handler_lock);\r\nnmh = o2net_handler_tree_lookup(msg_type, key, NULL, NULL);\r\nif (nmh)\r\nkref_get(&nmh->nh_kref);\r\nread_unlock(&o2net_handler_lock);\r\nreturn nmh;\r\n}\r\nstatic int o2net_recv_tcp_msg(struct socket *sock, void *data, size_t len)\r\n{\r\nstruct kvec vec = { .iov_len = len, .iov_base = data, };\r\nstruct msghdr msg = { .msg_flags = MSG_DONTWAIT, };\r\nreturn kernel_recvmsg(sock, &msg, &vec, 1, len, msg.msg_flags);\r\n}\r\nstatic int o2net_send_tcp_msg(struct socket *sock, struct kvec *vec,\r\nsize_t veclen, size_t total)\r\n{\r\nint ret;\r\nstruct msghdr msg = {.msg_flags = 0,};\r\nif (sock == NULL) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = kernel_sendmsg(sock, &msg, vec, veclen, total);\r\nif (likely(ret == total))\r\nreturn 0;\r\nmlog(ML_ERROR, "sendmsg returned %d instead of %zu\n", ret, total);\r\nif (ret >= 0)\r\nret = -EPIPE;\r\nout:\r\nmlog(0, "returning error: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic void o2net_sendpage(struct o2net_sock_container *sc,\r\nvoid *kmalloced_virt,\r\nsize_t size)\r\n{\r\nstruct o2net_node *nn = o2net_nn_from_num(sc->sc_node->nd_num);\r\nssize_t ret;\r\nwhile (1) {\r\nmutex_lock(&sc->sc_send_lock);\r\nret = sc->sc_sock->ops->sendpage(sc->sc_sock,\r\nvirt_to_page(kmalloced_virt),\r\noffset_in_page(kmalloced_virt),\r\nsize, MSG_DONTWAIT);\r\nmutex_unlock(&sc->sc_send_lock);\r\nif (ret == size)\r\nbreak;\r\nif (ret == (ssize_t)-EAGAIN) {\r\nmlog(0, "sendpage of size %zu to " SC_NODEF_FMT\r\n" returned EAGAIN\n", size, SC_NODEF_ARGS(sc));\r\ncond_resched();\r\ncontinue;\r\n}\r\nmlog(ML_ERROR, "sendpage of size %zu to " SC_NODEF_FMT\r\n" failed with %zd\n", size, SC_NODEF_ARGS(sc), ret);\r\no2net_ensure_shutdown(nn, sc, 0);\r\nbreak;\r\n}\r\n}\r\nstatic void o2net_init_msg(struct o2net_msg *msg, u16 data_len, u16 msg_type, u32 key)\r\n{\r\nmemset(msg, 0, sizeof(struct o2net_msg));\r\nmsg->magic = cpu_to_be16(O2NET_MSG_MAGIC);\r\nmsg->data_len = cpu_to_be16(data_len);\r\nmsg->msg_type = cpu_to_be16(msg_type);\r\nmsg->sys_status = cpu_to_be32(O2NET_ERR_NONE);\r\nmsg->status = 0;\r\nmsg->key = cpu_to_be32(key);\r\n}\r\nstatic int o2net_tx_can_proceed(struct o2net_node *nn,\r\nstruct o2net_sock_container **sc_ret,\r\nint *error)\r\n{\r\nint ret = 0;\r\nspin_lock(&nn->nn_lock);\r\nif (nn->nn_persistent_error) {\r\nret = 1;\r\n*sc_ret = NULL;\r\n*error = nn->nn_persistent_error;\r\n} else if (nn->nn_sc_valid) {\r\nkref_get(&nn->nn_sc->sc_kref);\r\nret = 1;\r\n*sc_ret = nn->nn_sc;\r\n*error = 0;\r\n}\r\nspin_unlock(&nn->nn_lock);\r\nreturn ret;\r\n}\r\nvoid o2net_fill_node_map(unsigned long *map, unsigned bytes)\r\n{\r\nstruct o2net_sock_container *sc;\r\nint node, ret;\r\nBUG_ON(bytes < (BITS_TO_LONGS(O2NM_MAX_NODES) * sizeof(unsigned long)));\r\nmemset(map, 0, bytes);\r\nfor (node = 0; node < O2NM_MAX_NODES; ++node) {\r\nif (!o2net_tx_can_proceed(o2net_nn_from_num(node), &sc, &ret))\r\ncontinue;\r\nif (!ret) {\r\nset_bit(node, map);\r\nsc_put(sc);\r\n}\r\n}\r\n}\r\nint o2net_send_message_vec(u32 msg_type, u32 key, struct kvec *caller_vec,\r\nsize_t caller_veclen, u8 target_node, int *status)\r\n{\r\nint ret = 0;\r\nstruct o2net_msg *msg = NULL;\r\nsize_t veclen, caller_bytes = 0;\r\nstruct kvec *vec = NULL;\r\nstruct o2net_sock_container *sc = NULL;\r\nstruct o2net_node *nn = o2net_nn_from_num(target_node);\r\nstruct o2net_status_wait nsw = {\r\n.ns_node_item = LIST_HEAD_INIT(nsw.ns_node_item),\r\n};\r\nstruct o2net_send_tracking nst;\r\no2net_init_nst(&nst, msg_type, key, current, target_node);\r\nif (o2net_wq == NULL) {\r\nmlog(0, "attempt to tx without o2netd running\n");\r\nret = -ESRCH;\r\ngoto out;\r\n}\r\nif (caller_veclen == 0) {\r\nmlog(0, "bad kvec array length\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\ncaller_bytes = iov_length((struct iovec *)caller_vec, caller_veclen);\r\nif (caller_bytes > O2NET_MAX_PAYLOAD_BYTES) {\r\nmlog(0, "total payload len %zu too large\n", caller_bytes);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (target_node == o2nm_this_node()) {\r\nret = -ELOOP;\r\ngoto out;\r\n}\r\no2net_debug_add_nst(&nst);\r\no2net_set_nst_sock_time(&nst);\r\nwait_event(nn->nn_sc_wq, o2net_tx_can_proceed(nn, &sc, &ret));\r\nif (ret)\r\ngoto out;\r\no2net_set_nst_sock_container(&nst, sc);\r\nveclen = caller_veclen + 1;\r\nvec = kmalloc(sizeof(struct kvec) * veclen, GFP_ATOMIC);\r\nif (vec == NULL) {\r\nmlog(0, "failed to %zu element kvec!\n", veclen);\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nmsg = kmalloc(sizeof(struct o2net_msg), GFP_ATOMIC);\r\nif (!msg) {\r\nmlog(0, "failed to allocate a o2net_msg!\n");\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\no2net_init_msg(msg, caller_bytes, msg_type, key);\r\nvec[0].iov_len = sizeof(struct o2net_msg);\r\nvec[0].iov_base = msg;\r\nmemcpy(&vec[1], caller_vec, caller_veclen * sizeof(struct kvec));\r\nret = o2net_prep_nsw(nn, &nsw);\r\nif (ret)\r\ngoto out;\r\nmsg->msg_num = cpu_to_be32(nsw.ns_id);\r\no2net_set_nst_msg_id(&nst, nsw.ns_id);\r\no2net_set_nst_send_time(&nst);\r\nmutex_lock(&sc->sc_send_lock);\r\nret = o2net_send_tcp_msg(sc->sc_sock, vec, veclen,\r\nsizeof(struct o2net_msg) + caller_bytes);\r\nmutex_unlock(&sc->sc_send_lock);\r\nmsglog(msg, "sending returned %d\n", ret);\r\nif (ret < 0) {\r\nmlog(0, "error returned from o2net_send_tcp_msg=%d\n", ret);\r\ngoto out;\r\n}\r\no2net_set_nst_status_time(&nst);\r\nwait_event(nsw.ns_wq, o2net_nsw_completed(nn, &nsw));\r\no2net_update_send_stats(&nst, sc);\r\nret = o2net_sys_err_to_errno(nsw.ns_sys_status);\r\nif (status && !ret)\r\n*status = nsw.ns_status;\r\nmlog(0, "woken, returning system status %d, user status %d\n",\r\nret, nsw.ns_status);\r\nout:\r\no2net_debug_del_nst(&nst);\r\nif (sc)\r\nsc_put(sc);\r\nkfree(vec);\r\nkfree(msg);\r\no2net_complete_nsw(nn, &nsw, 0, 0, 0);\r\nreturn ret;\r\n}\r\nint o2net_send_message(u32 msg_type, u32 key, void *data, u32 len,\r\nu8 target_node, int *status)\r\n{\r\nstruct kvec vec = {\r\n.iov_base = data,\r\n.iov_len = len,\r\n};\r\nreturn o2net_send_message_vec(msg_type, key, &vec, 1,\r\ntarget_node, status);\r\n}\r\nstatic int o2net_send_status_magic(struct socket *sock, struct o2net_msg *hdr,\r\nenum o2net_system_error syserr, int err)\r\n{\r\nstruct kvec vec = {\r\n.iov_base = hdr,\r\n.iov_len = sizeof(struct o2net_msg),\r\n};\r\nBUG_ON(syserr >= O2NET_ERR_MAX);\r\nhdr->sys_status = cpu_to_be32(syserr);\r\nhdr->status = cpu_to_be32(err);\r\nhdr->magic = cpu_to_be16(O2NET_MSG_STATUS_MAGIC);\r\nhdr->data_len = 0;\r\nmsglog(hdr, "about to send status magic %d\n", err);\r\nreturn o2net_send_tcp_msg(sock, &vec, 1, sizeof(struct o2net_msg));\r\n}\r\nstatic int o2net_process_message(struct o2net_sock_container *sc,\r\nstruct o2net_msg *hdr)\r\n{\r\nstruct o2net_node *nn = o2net_nn_from_num(sc->sc_node->nd_num);\r\nint ret = 0, handler_status;\r\nenum o2net_system_error syserr;\r\nstruct o2net_msg_handler *nmh = NULL;\r\nvoid *ret_data = NULL;\r\nmsglog(hdr, "processing message\n");\r\no2net_sc_postpone_idle(sc);\r\nswitch(be16_to_cpu(hdr->magic)) {\r\ncase O2NET_MSG_STATUS_MAGIC:\r\no2net_complete_nsw(nn, NULL,\r\nbe32_to_cpu(hdr->msg_num),\r\nbe32_to_cpu(hdr->sys_status),\r\nbe32_to_cpu(hdr->status));\r\ngoto out;\r\ncase O2NET_MSG_KEEP_REQ_MAGIC:\r\no2net_sendpage(sc, o2net_keep_resp,\r\nsizeof(*o2net_keep_resp));\r\ngoto out;\r\ncase O2NET_MSG_KEEP_RESP_MAGIC:\r\ngoto out;\r\ncase O2NET_MSG_MAGIC:\r\nbreak;\r\ndefault:\r\nmsglog(hdr, "bad magic\n");\r\nret = -EINVAL;\r\ngoto out;\r\nbreak;\r\n}\r\nhandler_status = 0;\r\nnmh = o2net_handler_get(be16_to_cpu(hdr->msg_type),\r\nbe32_to_cpu(hdr->key));\r\nif (!nmh) {\r\nmlog(ML_TCP, "couldn't find handler for type %u key %08x\n",\r\nbe16_to_cpu(hdr->msg_type), be32_to_cpu(hdr->key));\r\nsyserr = O2NET_ERR_NO_HNDLR;\r\ngoto out_respond;\r\n}\r\nsyserr = O2NET_ERR_NONE;\r\nif (be16_to_cpu(hdr->data_len) > nmh->nh_max_len)\r\nsyserr = O2NET_ERR_OVERFLOW;\r\nif (syserr != O2NET_ERR_NONE)\r\ngoto out_respond;\r\no2net_set_func_start_time(sc);\r\nsc->sc_msg_key = be32_to_cpu(hdr->key);\r\nsc->sc_msg_type = be16_to_cpu(hdr->msg_type);\r\nhandler_status = (nmh->nh_func)(hdr, sizeof(struct o2net_msg) +\r\nbe16_to_cpu(hdr->data_len),\r\nnmh->nh_func_data, &ret_data);\r\no2net_set_func_stop_time(sc);\r\no2net_update_recv_stats(sc);\r\nout_respond:\r\nmutex_lock(&sc->sc_send_lock);\r\nret = o2net_send_status_magic(sc->sc_sock, hdr, syserr,\r\nhandler_status);\r\nmutex_unlock(&sc->sc_send_lock);\r\nhdr = NULL;\r\nmlog(0, "sending handler status %d, syserr %d returned %d\n",\r\nhandler_status, syserr, ret);\r\nif (nmh) {\r\nBUG_ON(ret_data != NULL && nmh->nh_post_func == NULL);\r\nif (nmh->nh_post_func)\r\n(nmh->nh_post_func)(handler_status, nmh->nh_func_data,\r\nret_data);\r\n}\r\nout:\r\nif (nmh)\r\no2net_handler_put(nmh);\r\nreturn ret;\r\n}\r\nstatic int o2net_check_handshake(struct o2net_sock_container *sc)\r\n{\r\nstruct o2net_handshake *hand = page_address(sc->sc_page);\r\nstruct o2net_node *nn = o2net_nn_from_num(sc->sc_node->nd_num);\r\nif (hand->protocol_version != cpu_to_be64(O2NET_PROTOCOL_VERSION)) {\r\nprintk(KERN_NOTICE "o2net: " SC_NODEF_FMT " Advertised net "\r\n"protocol version %llu but %llu is required. "\r\n"Disconnecting.\n", SC_NODEF_ARGS(sc),\r\n(unsigned long long)be64_to_cpu(hand->protocol_version),\r\nO2NET_PROTOCOL_VERSION);\r\no2net_ensure_shutdown(nn, sc, -ENOTCONN);\r\nreturn -1;\r\n}\r\nif (be32_to_cpu(hand->o2net_idle_timeout_ms) !=\r\no2net_idle_timeout()) {\r\nprintk(KERN_NOTICE "o2net: " SC_NODEF_FMT " uses a network "\r\n"idle timeout of %u ms, but we use %u ms locally. "\r\n"Disconnecting.\n", SC_NODEF_ARGS(sc),\r\nbe32_to_cpu(hand->o2net_idle_timeout_ms),\r\no2net_idle_timeout());\r\no2net_ensure_shutdown(nn, sc, -ENOTCONN);\r\nreturn -1;\r\n}\r\nif (be32_to_cpu(hand->o2net_keepalive_delay_ms) !=\r\no2net_keepalive_delay()) {\r\nprintk(KERN_NOTICE "o2net: " SC_NODEF_FMT " uses a keepalive "\r\n"delay of %u ms, but we use %u ms locally. "\r\n"Disconnecting.\n", SC_NODEF_ARGS(sc),\r\nbe32_to_cpu(hand->o2net_keepalive_delay_ms),\r\no2net_keepalive_delay());\r\no2net_ensure_shutdown(nn, sc, -ENOTCONN);\r\nreturn -1;\r\n}\r\nif (be32_to_cpu(hand->o2hb_heartbeat_timeout_ms) !=\r\nO2HB_MAX_WRITE_TIMEOUT_MS) {\r\nprintk(KERN_NOTICE "o2net: " SC_NODEF_FMT " uses a heartbeat "\r\n"timeout of %u ms, but we use %u ms locally. "\r\n"Disconnecting.\n", SC_NODEF_ARGS(sc),\r\nbe32_to_cpu(hand->o2hb_heartbeat_timeout_ms),\r\nO2HB_MAX_WRITE_TIMEOUT_MS);\r\no2net_ensure_shutdown(nn, sc, -ENOTCONN);\r\nreturn -1;\r\n}\r\nsc->sc_handshake_ok = 1;\r\nspin_lock(&nn->nn_lock);\r\nif (nn->nn_sc == sc) {\r\no2net_sc_reset_idle_timer(sc);\r\natomic_set(&nn->nn_timeout, 0);\r\no2net_set_nn_state(nn, sc, 1, 0);\r\n}\r\nspin_unlock(&nn->nn_lock);\r\nsc->sc_page_off -= sizeof(struct o2net_handshake);\r\nif (sc->sc_page_off)\r\nmemmove(hand, hand + 1, sc->sc_page_off);\r\nreturn 0;\r\n}\r\nstatic int o2net_advance_rx(struct o2net_sock_container *sc)\r\n{\r\nstruct o2net_msg *hdr;\r\nint ret = 0;\r\nvoid *data;\r\nsize_t datalen;\r\nsclog(sc, "receiving\n");\r\no2net_set_advance_start_time(sc);\r\nif (unlikely(sc->sc_handshake_ok == 0)) {\r\nif(sc->sc_page_off < sizeof(struct o2net_handshake)) {\r\ndata = page_address(sc->sc_page) + sc->sc_page_off;\r\ndatalen = sizeof(struct o2net_handshake) - sc->sc_page_off;\r\nret = o2net_recv_tcp_msg(sc->sc_sock, data, datalen);\r\nif (ret > 0)\r\nsc->sc_page_off += ret;\r\n}\r\nif (sc->sc_page_off == sizeof(struct o2net_handshake)) {\r\no2net_check_handshake(sc);\r\nif (unlikely(sc->sc_handshake_ok == 0))\r\nret = -EPROTO;\r\n}\r\ngoto out;\r\n}\r\nif (sc->sc_page_off < sizeof(struct o2net_msg)) {\r\ndata = page_address(sc->sc_page) + sc->sc_page_off;\r\ndatalen = sizeof(struct o2net_msg) - sc->sc_page_off;\r\nret = o2net_recv_tcp_msg(sc->sc_sock, data, datalen);\r\nif (ret > 0) {\r\nsc->sc_page_off += ret;\r\nif (sc->sc_page_off == sizeof(struct o2net_msg)) {\r\nhdr = page_address(sc->sc_page);\r\nif (be16_to_cpu(hdr->data_len) >\r\nO2NET_MAX_PAYLOAD_BYTES)\r\nret = -EOVERFLOW;\r\n}\r\n}\r\nif (ret <= 0)\r\ngoto out;\r\n}\r\nif (sc->sc_page_off < sizeof(struct o2net_msg)) {\r\ngoto out;\r\n}\r\nhdr = page_address(sc->sc_page);\r\nmsglog(hdr, "at page_off %zu\n", sc->sc_page_off);\r\nif (sc->sc_page_off - sizeof(struct o2net_msg) < be16_to_cpu(hdr->data_len)) {\r\ndata = page_address(sc->sc_page) + sc->sc_page_off;\r\ndatalen = (sizeof(struct o2net_msg) + be16_to_cpu(hdr->data_len)) -\r\nsc->sc_page_off;\r\nret = o2net_recv_tcp_msg(sc->sc_sock, data, datalen);\r\nif (ret > 0)\r\nsc->sc_page_off += ret;\r\nif (ret <= 0)\r\ngoto out;\r\n}\r\nif (sc->sc_page_off - sizeof(struct o2net_msg) == be16_to_cpu(hdr->data_len)) {\r\nret = o2net_process_message(sc, hdr);\r\nif (ret == 0)\r\nret = 1;\r\nsc->sc_page_off = 0;\r\n}\r\nout:\r\nsclog(sc, "ret = %d\n", ret);\r\no2net_set_advance_stop_time(sc);\r\nreturn ret;\r\n}\r\nstatic void o2net_rx_until_empty(struct work_struct *work)\r\n{\r\nstruct o2net_sock_container *sc =\r\ncontainer_of(work, struct o2net_sock_container, sc_rx_work);\r\nint ret;\r\ndo {\r\nret = o2net_advance_rx(sc);\r\n} while (ret > 0);\r\nif (ret <= 0 && ret != -EAGAIN) {\r\nstruct o2net_node *nn = o2net_nn_from_num(sc->sc_node->nd_num);\r\nsclog(sc, "saw error %d, closing\n", ret);\r\no2net_ensure_shutdown(nn, sc, 0);\r\n}\r\nsc_put(sc);\r\n}\r\nstatic int o2net_set_nodelay(struct socket *sock)\r\n{\r\nint val = 1;\r\nreturn kernel_setsockopt(sock, SOL_TCP, TCP_NODELAY,\r\n(void *)&val, sizeof(val));\r\n}\r\nstatic int o2net_set_usertimeout(struct socket *sock)\r\n{\r\nint user_timeout = O2NET_TCP_USER_TIMEOUT;\r\nreturn kernel_setsockopt(sock, SOL_TCP, TCP_USER_TIMEOUT,\r\n(void *)&user_timeout, sizeof(user_timeout));\r\n}\r\nstatic void o2net_initialize_handshake(void)\r\n{\r\no2net_hand->o2hb_heartbeat_timeout_ms = cpu_to_be32(\r\nO2HB_MAX_WRITE_TIMEOUT_MS);\r\no2net_hand->o2net_idle_timeout_ms = cpu_to_be32(o2net_idle_timeout());\r\no2net_hand->o2net_keepalive_delay_ms = cpu_to_be32(\r\no2net_keepalive_delay());\r\no2net_hand->o2net_reconnect_delay_ms = cpu_to_be32(\r\no2net_reconnect_delay());\r\n}\r\nstatic void o2net_sc_connect_completed(struct work_struct *work)\r\n{\r\nstruct o2net_sock_container *sc =\r\ncontainer_of(work, struct o2net_sock_container,\r\nsc_connect_work);\r\nmlog(ML_MSG, "sc sending handshake with ver %llu id %llx\n",\r\n(unsigned long long)O2NET_PROTOCOL_VERSION,\r\n(unsigned long long)be64_to_cpu(o2net_hand->connector_id));\r\no2net_initialize_handshake();\r\no2net_sendpage(sc, o2net_hand, sizeof(*o2net_hand));\r\nsc_put(sc);\r\n}\r\nstatic void o2net_sc_send_keep_req(struct work_struct *work)\r\n{\r\nstruct o2net_sock_container *sc =\r\ncontainer_of(work, struct o2net_sock_container,\r\nsc_keepalive_work.work);\r\no2net_sendpage(sc, o2net_keep_req, sizeof(*o2net_keep_req));\r\nsc_put(sc);\r\n}\r\nstatic void o2net_idle_timer(unsigned long data)\r\n{\r\nstruct o2net_sock_container *sc = (struct o2net_sock_container *)data;\r\nstruct o2net_node *nn = o2net_nn_from_num(sc->sc_node->nd_num);\r\n#ifdef CONFIG_DEBUG_FS\r\nunsigned long msecs = ktime_to_ms(ktime_get()) -\r\nktime_to_ms(sc->sc_tv_timer);\r\n#else\r\nunsigned long msecs = o2net_idle_timeout();\r\n#endif\r\nprintk(KERN_NOTICE "o2net: Connection to " SC_NODEF_FMT " has been "\r\n"idle for %lu.%lu secs.\n",\r\nSC_NODEF_ARGS(sc), msecs / 1000, msecs % 1000);\r\natomic_set(&nn->nn_timeout, 1);\r\no2quo_conn_err(o2net_num_from_nn(nn));\r\nqueue_delayed_work(o2net_wq, &nn->nn_still_up,\r\nmsecs_to_jiffies(O2NET_QUORUM_DELAY_MS));\r\no2net_sc_reset_idle_timer(sc);\r\n}\r\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc)\r\n{\r\no2net_sc_cancel_delayed_work(sc, &sc->sc_keepalive_work);\r\no2net_sc_queue_delayed_work(sc, &sc->sc_keepalive_work,\r\nmsecs_to_jiffies(o2net_keepalive_delay()));\r\no2net_set_sock_timer(sc);\r\nmod_timer(&sc->sc_idle_timeout,\r\njiffies + msecs_to_jiffies(o2net_idle_timeout()));\r\n}\r\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc)\r\n{\r\nstruct o2net_node *nn = o2net_nn_from_num(sc->sc_node->nd_num);\r\nif (atomic_read(&nn->nn_timeout)) {\r\no2quo_conn_up(o2net_num_from_nn(nn));\r\ncancel_delayed_work(&nn->nn_still_up);\r\natomic_set(&nn->nn_timeout, 0);\r\n}\r\nif (timer_pending(&sc->sc_idle_timeout))\r\no2net_sc_reset_idle_timer(sc);\r\n}\r\nstatic void o2net_start_connect(struct work_struct *work)\r\n{\r\nstruct o2net_node *nn =\r\ncontainer_of(work, struct o2net_node, nn_connect_work.work);\r\nstruct o2net_sock_container *sc = NULL;\r\nstruct o2nm_node *node = NULL, *mynode = NULL;\r\nstruct socket *sock = NULL;\r\nstruct sockaddr_in myaddr = {0, }, remoteaddr = {0, };\r\nint ret = 0, stop;\r\nunsigned int timeout;\r\nunsigned int noio_flag;\r\nnoio_flag = memalloc_noio_save();\r\nif (o2nm_this_node() <= o2net_num_from_nn(nn))\r\ngoto out;\r\nnode = o2nm_get_node_by_num(o2net_num_from_nn(nn));\r\nif (node == NULL)\r\ngoto out;\r\nmynode = o2nm_get_node_by_num(o2nm_this_node());\r\nif (mynode == NULL)\r\ngoto out;\r\nspin_lock(&nn->nn_lock);\r\ntimeout = atomic_read(&nn->nn_timeout);\r\nstop = (nn->nn_sc ||\r\n(nn->nn_persistent_error &&\r\n(nn->nn_persistent_error != -ENOTCONN || timeout == 0)));\r\nspin_unlock(&nn->nn_lock);\r\nif (stop)\r\ngoto out;\r\nnn->nn_last_connect_attempt = jiffies;\r\nsc = sc_alloc(node);\r\nif (sc == NULL) {\r\nmlog(0, "couldn't allocate sc\n");\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nret = sock_create(PF_INET, SOCK_STREAM, IPPROTO_TCP, &sock);\r\nif (ret < 0) {\r\nmlog(0, "can't create socket: %d\n", ret);\r\ngoto out;\r\n}\r\nsc->sc_sock = sock;\r\nsock->sk->sk_allocation = GFP_ATOMIC;\r\nmyaddr.sin_family = AF_INET;\r\nmyaddr.sin_addr.s_addr = mynode->nd_ipv4_address;\r\nmyaddr.sin_port = htons(0);\r\nret = sock->ops->bind(sock, (struct sockaddr *)&myaddr,\r\nsizeof(myaddr));\r\nif (ret) {\r\nmlog(ML_ERROR, "bind failed with %d at address %pI4\n",\r\nret, &mynode->nd_ipv4_address);\r\ngoto out;\r\n}\r\nret = o2net_set_nodelay(sc->sc_sock);\r\nif (ret) {\r\nmlog(ML_ERROR, "setting TCP_NODELAY failed with %d\n", ret);\r\ngoto out;\r\n}\r\nret = o2net_set_usertimeout(sock);\r\nif (ret) {\r\nmlog(ML_ERROR, "set TCP_USER_TIMEOUT failed with %d\n", ret);\r\ngoto out;\r\n}\r\no2net_register_callbacks(sc->sc_sock->sk, sc);\r\nspin_lock(&nn->nn_lock);\r\no2net_set_nn_state(nn, sc, 0, 0);\r\nspin_unlock(&nn->nn_lock);\r\nremoteaddr.sin_family = AF_INET;\r\nremoteaddr.sin_addr.s_addr = node->nd_ipv4_address;\r\nremoteaddr.sin_port = node->nd_ipv4_port;\r\nret = sc->sc_sock->ops->connect(sc->sc_sock,\r\n(struct sockaddr *)&remoteaddr,\r\nsizeof(remoteaddr),\r\nO_NONBLOCK);\r\nif (ret == -EINPROGRESS)\r\nret = 0;\r\nout:\r\nif (ret && sc) {\r\nprintk(KERN_NOTICE "o2net: Connect attempt to " SC_NODEF_FMT\r\n" failed with errno %d\n", SC_NODEF_ARGS(sc), ret);\r\no2net_ensure_shutdown(nn, sc, 0);\r\n}\r\nif (sc)\r\nsc_put(sc);\r\nif (node)\r\no2nm_node_put(node);\r\nif (mynode)\r\no2nm_node_put(mynode);\r\nmemalloc_noio_restore(noio_flag);\r\nreturn;\r\n}\r\nstatic void o2net_connect_expired(struct work_struct *work)\r\n{\r\nstruct o2net_node *nn =\r\ncontainer_of(work, struct o2net_node, nn_connect_expired.work);\r\nspin_lock(&nn->nn_lock);\r\nif (!nn->nn_sc_valid) {\r\nprintk(KERN_NOTICE "o2net: No connection established with "\r\n"node %u after %u.%u seconds, check network and"\r\n" cluster configuration.\n",\r\no2net_num_from_nn(nn),\r\no2net_idle_timeout() / 1000,\r\no2net_idle_timeout() % 1000);\r\no2net_set_nn_state(nn, NULL, 0, 0);\r\n}\r\nspin_unlock(&nn->nn_lock);\r\n}\r\nstatic void o2net_still_up(struct work_struct *work)\r\n{\r\nstruct o2net_node *nn =\r\ncontainer_of(work, struct o2net_node, nn_still_up.work);\r\no2quo_hb_still_up(o2net_num_from_nn(nn));\r\n}\r\nvoid o2net_disconnect_node(struct o2nm_node *node)\r\n{\r\nstruct o2net_node *nn = o2net_nn_from_num(node->nd_num);\r\nspin_lock(&nn->nn_lock);\r\natomic_set(&nn->nn_timeout, 0);\r\no2net_set_nn_state(nn, NULL, 0, -ENOTCONN);\r\nspin_unlock(&nn->nn_lock);\r\nif (o2net_wq) {\r\ncancel_delayed_work(&nn->nn_connect_expired);\r\ncancel_delayed_work(&nn->nn_connect_work);\r\ncancel_delayed_work(&nn->nn_still_up);\r\nflush_workqueue(o2net_wq);\r\n}\r\n}\r\nstatic void o2net_hb_node_down_cb(struct o2nm_node *node, int node_num,\r\nvoid *data)\r\n{\r\no2quo_hb_down(node_num);\r\nif (!node)\r\nreturn;\r\nif (node_num != o2nm_this_node())\r\no2net_disconnect_node(node);\r\nBUG_ON(atomic_read(&o2net_connected_peers) < 0);\r\n}\r\nstatic void o2net_hb_node_up_cb(struct o2nm_node *node, int node_num,\r\nvoid *data)\r\n{\r\nstruct o2net_node *nn = o2net_nn_from_num(node_num);\r\no2quo_hb_up(node_num);\r\nBUG_ON(!node);\r\nnn->nn_last_connect_attempt = jiffies -\r\n(msecs_to_jiffies(o2net_reconnect_delay()) + 1);\r\nif (node_num != o2nm_this_node()) {\r\nspin_lock(&nn->nn_lock);\r\natomic_set(&nn->nn_timeout, 0);\r\nif (nn->nn_persistent_error)\r\no2net_set_nn_state(nn, NULL, 0, 0);\r\nspin_unlock(&nn->nn_lock);\r\n}\r\n}\r\nvoid o2net_unregister_hb_callbacks(void)\r\n{\r\no2hb_unregister_callback(NULL, &o2net_hb_up);\r\no2hb_unregister_callback(NULL, &o2net_hb_down);\r\n}\r\nint o2net_register_hb_callbacks(void)\r\n{\r\nint ret;\r\no2hb_setup_callback(&o2net_hb_down, O2HB_NODE_DOWN_CB,\r\no2net_hb_node_down_cb, NULL, O2NET_HB_PRI);\r\no2hb_setup_callback(&o2net_hb_up, O2HB_NODE_UP_CB,\r\no2net_hb_node_up_cb, NULL, O2NET_HB_PRI);\r\nret = o2hb_register_callback(NULL, &o2net_hb_up);\r\nif (ret == 0)\r\nret = o2hb_register_callback(NULL, &o2net_hb_down);\r\nif (ret)\r\no2net_unregister_hb_callbacks();\r\nreturn ret;\r\n}\r\nstatic int o2net_accept_one(struct socket *sock, int *more)\r\n{\r\nint ret, slen;\r\nstruct sockaddr_in sin;\r\nstruct socket *new_sock = NULL;\r\nstruct o2nm_node *node = NULL;\r\nstruct o2nm_node *local_node = NULL;\r\nstruct o2net_sock_container *sc = NULL;\r\nstruct o2net_node *nn;\r\nunsigned int noio_flag;\r\nnoio_flag = memalloc_noio_save();\r\nBUG_ON(sock == NULL);\r\n*more = 0;\r\nret = sock_create_lite(sock->sk->sk_family, sock->sk->sk_type,\r\nsock->sk->sk_protocol, &new_sock);\r\nif (ret)\r\ngoto out;\r\nnew_sock->type = sock->type;\r\nnew_sock->ops = sock->ops;\r\nret = sock->ops->accept(sock, new_sock, O_NONBLOCK, false);\r\nif (ret < 0)\r\ngoto out;\r\n*more = 1;\r\nnew_sock->sk->sk_allocation = GFP_ATOMIC;\r\nret = o2net_set_nodelay(new_sock);\r\nif (ret) {\r\nmlog(ML_ERROR, "setting TCP_NODELAY failed with %d\n", ret);\r\ngoto out;\r\n}\r\nret = o2net_set_usertimeout(new_sock);\r\nif (ret) {\r\nmlog(ML_ERROR, "set TCP_USER_TIMEOUT failed with %d\n", ret);\r\ngoto out;\r\n}\r\nslen = sizeof(sin);\r\nret = new_sock->ops->getname(new_sock, (struct sockaddr *) &sin,\r\n&slen, 1);\r\nif (ret < 0)\r\ngoto out;\r\nnode = o2nm_get_node_by_ip(sin.sin_addr.s_addr);\r\nif (node == NULL) {\r\nprintk(KERN_NOTICE "o2net: Attempt to connect from unknown "\r\n"node at %pI4:%d\n", &sin.sin_addr.s_addr,\r\nntohs(sin.sin_port));\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (o2nm_this_node() >= node->nd_num) {\r\nlocal_node = o2nm_get_node_by_num(o2nm_this_node());\r\nif (local_node)\r\nprintk(KERN_NOTICE "o2net: Unexpected connect attempt "\r\n"seen at node '%s' (%u, %pI4:%d) from "\r\n"node '%s' (%u, %pI4:%d)\n",\r\nlocal_node->nd_name, local_node->nd_num,\r\n&(local_node->nd_ipv4_address),\r\nntohs(local_node->nd_ipv4_port),\r\nnode->nd_name,\r\nnode->nd_num, &sin.sin_addr.s_addr,\r\nntohs(sin.sin_port));\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (!o2hb_check_node_heartbeating_from_callback(node->nd_num)) {\r\nmlog(ML_CONN, "attempt to connect from node '%s' at "\r\n"%pI4:%d but it isn't heartbeating\n",\r\nnode->nd_name, &sin.sin_addr.s_addr,\r\nntohs(sin.sin_port));\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nnn = o2net_nn_from_num(node->nd_num);\r\nspin_lock(&nn->nn_lock);\r\nif (nn->nn_sc)\r\nret = -EBUSY;\r\nelse\r\nret = 0;\r\nspin_unlock(&nn->nn_lock);\r\nif (ret) {\r\nprintk(KERN_NOTICE "o2net: Attempt to connect from node '%s' "\r\n"at %pI4:%d but it already has an open connection\n",\r\nnode->nd_name, &sin.sin_addr.s_addr,\r\nntohs(sin.sin_port));\r\ngoto out;\r\n}\r\nsc = sc_alloc(node);\r\nif (sc == NULL) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nsc->sc_sock = new_sock;\r\nnew_sock = NULL;\r\nspin_lock(&nn->nn_lock);\r\natomic_set(&nn->nn_timeout, 0);\r\no2net_set_nn_state(nn, sc, 0, 0);\r\nspin_unlock(&nn->nn_lock);\r\no2net_register_callbacks(sc->sc_sock->sk, sc);\r\no2net_sc_queue_work(sc, &sc->sc_rx_work);\r\no2net_initialize_handshake();\r\no2net_sendpage(sc, o2net_hand, sizeof(*o2net_hand));\r\nout:\r\nif (new_sock)\r\nsock_release(new_sock);\r\nif (node)\r\no2nm_node_put(node);\r\nif (local_node)\r\no2nm_node_put(local_node);\r\nif (sc)\r\nsc_put(sc);\r\nmemalloc_noio_restore(noio_flag);\r\nreturn ret;\r\n}\r\nstatic void o2net_accept_many(struct work_struct *work)\r\n{\r\nstruct socket *sock = o2net_listen_sock;\r\nint more;\r\nint err;\r\nfor (;;) {\r\nerr = o2net_accept_one(sock, &more);\r\nif (!more)\r\nbreak;\r\ncond_resched();\r\n}\r\n}\r\nstatic void o2net_listen_data_ready(struct sock *sk)\r\n{\r\nvoid (*ready)(struct sock *sk);\r\nread_lock_bh(&sk->sk_callback_lock);\r\nready = sk->sk_user_data;\r\nif (ready == NULL) {\r\nready = sk->sk_data_ready;\r\ngoto out;\r\n}\r\nif (sk->sk_state == TCP_LISTEN) {\r\nqueue_work(o2net_wq, &o2net_listen_work);\r\n} else {\r\nready = NULL;\r\n}\r\nout:\r\nread_unlock_bh(&sk->sk_callback_lock);\r\nif (ready != NULL)\r\nready(sk);\r\n}\r\nstatic int o2net_open_listening_sock(__be32 addr, __be16 port)\r\n{\r\nstruct socket *sock = NULL;\r\nint ret;\r\nstruct sockaddr_in sin = {\r\n.sin_family = PF_INET,\r\n.sin_addr = { .s_addr = addr },\r\n.sin_port = port,\r\n};\r\nret = sock_create(PF_INET, SOCK_STREAM, IPPROTO_TCP, &sock);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "o2net: Error %d while creating socket\n", ret);\r\ngoto out;\r\n}\r\nsock->sk->sk_allocation = GFP_ATOMIC;\r\nwrite_lock_bh(&sock->sk->sk_callback_lock);\r\nsock->sk->sk_user_data = sock->sk->sk_data_ready;\r\nsock->sk->sk_data_ready = o2net_listen_data_ready;\r\nwrite_unlock_bh(&sock->sk->sk_callback_lock);\r\no2net_listen_sock = sock;\r\nINIT_WORK(&o2net_listen_work, o2net_accept_many);\r\nsock->sk->sk_reuse = SK_CAN_REUSE;\r\nret = sock->ops->bind(sock, (struct sockaddr *)&sin, sizeof(sin));\r\nif (ret < 0) {\r\nprintk(KERN_ERR "o2net: Error %d while binding socket at "\r\n"%pI4:%u\n", ret, &addr, ntohs(port));\r\ngoto out;\r\n}\r\nret = sock->ops->listen(sock, 64);\r\nif (ret < 0)\r\nprintk(KERN_ERR "o2net: Error %d while listening on %pI4:%u\n",\r\nret, &addr, ntohs(port));\r\nout:\r\nif (ret) {\r\no2net_listen_sock = NULL;\r\nif (sock)\r\nsock_release(sock);\r\n}\r\nreturn ret;\r\n}\r\nint o2net_start_listening(struct o2nm_node *node)\r\n{\r\nint ret = 0;\r\nBUG_ON(o2net_wq != NULL);\r\nBUG_ON(o2net_listen_sock != NULL);\r\nmlog(ML_KTHREAD, "starting o2net thread...\n");\r\no2net_wq = alloc_ordered_workqueue("o2net", WQ_MEM_RECLAIM);\r\nif (o2net_wq == NULL) {\r\nmlog(ML_ERROR, "unable to launch o2net thread\n");\r\nreturn -ENOMEM;\r\n}\r\nret = o2net_open_listening_sock(node->nd_ipv4_address,\r\nnode->nd_ipv4_port);\r\nif (ret) {\r\ndestroy_workqueue(o2net_wq);\r\no2net_wq = NULL;\r\n} else\r\no2quo_conn_up(node->nd_num);\r\nreturn ret;\r\n}\r\nvoid o2net_stop_listening(struct o2nm_node *node)\r\n{\r\nstruct socket *sock = o2net_listen_sock;\r\nsize_t i;\r\nBUG_ON(o2net_wq == NULL);\r\nBUG_ON(o2net_listen_sock == NULL);\r\nwrite_lock_bh(&sock->sk->sk_callback_lock);\r\nsock->sk->sk_data_ready = sock->sk->sk_user_data;\r\nsock->sk->sk_user_data = NULL;\r\nwrite_unlock_bh(&sock->sk->sk_callback_lock);\r\nfor (i = 0; i < ARRAY_SIZE(o2net_nodes); i++) {\r\nstruct o2nm_node *node = o2nm_get_node_by_num(i);\r\nif (node) {\r\no2net_disconnect_node(node);\r\no2nm_node_put(node);\r\n}\r\n}\r\nmlog(ML_KTHREAD, "waiting for o2net thread to exit....\n");\r\ndestroy_workqueue(o2net_wq);\r\no2net_wq = NULL;\r\nsock_release(o2net_listen_sock);\r\no2net_listen_sock = NULL;\r\no2quo_conn_err(node->nd_num);\r\n}\r\nint o2net_init(void)\r\n{\r\nunsigned long i;\r\no2quo_init();\r\nif (o2net_debugfs_init())\r\ngoto out;\r\no2net_hand = kzalloc(sizeof(struct o2net_handshake), GFP_KERNEL);\r\no2net_keep_req = kzalloc(sizeof(struct o2net_msg), GFP_KERNEL);\r\no2net_keep_resp = kzalloc(sizeof(struct o2net_msg), GFP_KERNEL);\r\nif (!o2net_hand || !o2net_keep_req || !o2net_keep_resp)\r\ngoto out;\r\no2net_hand->protocol_version = cpu_to_be64(O2NET_PROTOCOL_VERSION);\r\no2net_hand->connector_id = cpu_to_be64(1);\r\no2net_keep_req->magic = cpu_to_be16(O2NET_MSG_KEEP_REQ_MAGIC);\r\no2net_keep_resp->magic = cpu_to_be16(O2NET_MSG_KEEP_RESP_MAGIC);\r\nfor (i = 0; i < ARRAY_SIZE(o2net_nodes); i++) {\r\nstruct o2net_node *nn = o2net_nn_from_num(i);\r\natomic_set(&nn->nn_timeout, 0);\r\nspin_lock_init(&nn->nn_lock);\r\nINIT_DELAYED_WORK(&nn->nn_connect_work, o2net_start_connect);\r\nINIT_DELAYED_WORK(&nn->nn_connect_expired,\r\no2net_connect_expired);\r\nINIT_DELAYED_WORK(&nn->nn_still_up, o2net_still_up);\r\nnn->nn_persistent_error = -ENOTCONN;\r\ninit_waitqueue_head(&nn->nn_sc_wq);\r\nidr_init(&nn->nn_status_idr);\r\nINIT_LIST_HEAD(&nn->nn_status_list);\r\n}\r\nreturn 0;\r\nout:\r\nkfree(o2net_hand);\r\nkfree(o2net_keep_req);\r\nkfree(o2net_keep_resp);\r\no2net_debugfs_exit();\r\no2quo_exit();\r\nreturn -ENOMEM;\r\n}\r\nvoid o2net_exit(void)\r\n{\r\no2quo_exit();\r\nkfree(o2net_hand);\r\nkfree(o2net_keep_req);\r\nkfree(o2net_keep_resp);\r\no2net_debugfs_exit();\r\n}
