static int iceland_start_smc(struct pp_smumgr *smumgr)\r\n{\r\nSMUM_WRITE_INDIRECT_FIELD(smumgr->device, CGS_IND_REG__SMC,\r\nSMC_SYSCON_RESET_CNTL, rst_reg, 0);\r\nreturn 0;\r\n}\r\nstatic void iceland_reset_smc(struct pp_smumgr *smumgr)\r\n{\r\nSMUM_WRITE_INDIRECT_FIELD(smumgr->device, CGS_IND_REG__SMC,\r\nSMC_SYSCON_RESET_CNTL,\r\nrst_reg, 1);\r\n}\r\nstatic void iceland_stop_smc_clock(struct pp_smumgr *smumgr)\r\n{\r\nSMUM_WRITE_INDIRECT_FIELD(smumgr->device, CGS_IND_REG__SMC,\r\nSMC_SYSCON_CLOCK_CNTL_0,\r\nck_disable, 1);\r\n}\r\nstatic void iceland_start_smc_clock(struct pp_smumgr *smumgr)\r\n{\r\nSMUM_WRITE_INDIRECT_FIELD(smumgr->device, CGS_IND_REG__SMC,\r\nSMC_SYSCON_CLOCK_CNTL_0,\r\nck_disable, 0);\r\n}\r\nstatic int iceland_smu_start_smc(struct pp_smumgr *smumgr)\r\n{\r\nsmu7_program_jump_on_start(smumgr);\r\niceland_start_smc_clock(smumgr);\r\niceland_start_smc(smumgr);\r\nSMUM_WAIT_INDIRECT_FIELD(smumgr, SMC_IND, FIRMWARE_FLAGS,\r\nINTERRUPTS_ENABLED, 1);\r\nreturn 0;\r\n}\r\nstatic int iceland_upload_smc_firmware_data(struct pp_smumgr *smumgr,\r\nuint32_t length, const uint8_t *src,\r\nuint32_t limit, uint32_t start_addr)\r\n{\r\nuint32_t byte_count = length;\r\nuint32_t data;\r\nPP_ASSERT_WITH_CODE((limit >= byte_count), "SMC address is beyond the SMC RAM area.", return -EINVAL);\r\ncgs_write_register(smumgr->device, mmSMC_IND_INDEX_0, start_addr);\r\nSMUM_WRITE_FIELD(smumgr->device, SMC_IND_ACCESS_CNTL, AUTO_INCREMENT_IND_0, 1);\r\nwhile (byte_count >= 4) {\r\ndata = src[0] * 0x1000000 + src[1] * 0x10000 + src[2] * 0x100 + src[3];\r\ncgs_write_register(smumgr->device, mmSMC_IND_DATA_0, data);\r\nsrc += 4;\r\nbyte_count -= 4;\r\n}\r\nSMUM_WRITE_FIELD(smumgr->device, SMC_IND_ACCESS_CNTL, AUTO_INCREMENT_IND_0, 0);\r\nPP_ASSERT_WITH_CODE((0 == byte_count), "SMC size must be dividable by 4.", return -EINVAL);\r\nreturn 0;\r\n}\r\nstatic int iceland_smu_upload_firmware_image(struct pp_smumgr *smumgr)\r\n{\r\nuint32_t val;\r\nstruct cgs_firmware_info info = {0};\r\nif (smumgr == NULL || smumgr->device == NULL)\r\nreturn -EINVAL;\r\ncgs_get_firmware_info(smumgr->device,\r\nsmu7_convert_fw_type_to_cgs(UCODE_ID_SMU), &info);\r\nif (info.image_size & 3) {\r\npr_err("[ powerplay ] SMC ucode is not 4 bytes aligned\n");\r\nreturn -EINVAL;\r\n}\r\nif (info.image_size > ICELAND_SMC_SIZE) {\r\npr_err("[ powerplay ] SMC address is beyond the SMC RAM area\n");\r\nreturn -EINVAL;\r\n}\r\nSMUM_WAIT_INDIRECT_FIELD_UNEQUAL(smumgr, SMC_IND,\r\nRCU_UC_EVENTS, boot_seq_done, 0);\r\nval = cgs_read_ind_register(smumgr->device, CGS_IND_REG__SMC,\r\nixSMC_SYSCON_MISC_CNTL);\r\ncgs_write_ind_register(smumgr->device, CGS_IND_REG__SMC,\r\nixSMC_SYSCON_MISC_CNTL, val | 1);\r\niceland_stop_smc_clock(smumgr);\r\niceland_reset_smc(smumgr);\r\niceland_upload_smc_firmware_data(smumgr, info.image_size,\r\n(uint8_t *)info.kptr, ICELAND_SMC_SIZE,\r\ninfo.ucode_start_address);\r\nreturn 0;\r\n}\r\nstatic int iceland_request_smu_load_specific_fw(struct pp_smumgr *smumgr,\r\nuint32_t firmwareType)\r\n{\r\nreturn 0;\r\n}\r\nstatic int iceland_start_smu(struct pp_smumgr *smumgr)\r\n{\r\nint result;\r\nresult = iceland_smu_upload_firmware_image(smumgr);\r\nif (result)\r\nreturn result;\r\nresult = iceland_smu_start_smc(smumgr);\r\nif (result)\r\nreturn result;\r\nif (!smu7_is_smc_ram_running(smumgr)) {\r\npr_info("smu not running, upload firmware again \n");\r\nresult = iceland_smu_upload_firmware_image(smumgr);\r\nif (result)\r\nreturn result;\r\nresult = iceland_smu_start_smc(smumgr);\r\nif (result)\r\nreturn result;\r\n}\r\nresult = smu7_request_smu_load_fw(smumgr);\r\nreturn result;\r\n}\r\nstatic int iceland_smu_init(struct pp_smumgr *smumgr)\r\n{\r\nint i;\r\nstruct iceland_smumgr *iceland_priv = NULL;\r\niceland_priv = kzalloc(sizeof(struct iceland_smumgr), GFP_KERNEL);\r\nif (iceland_priv == NULL)\r\nreturn -ENOMEM;\r\nsmumgr->backend = iceland_priv;\r\nif (smu7_init(smumgr))\r\nreturn -EINVAL;\r\nfor (i = 0; i < SMU71_MAX_LEVELS_GRAPHICS; i++)\r\niceland_priv->activity_target[i] = 30;\r\nreturn 0;\r\n}
