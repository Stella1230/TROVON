static void os_enter_line_edit_mode(void)\r\n{\r\nstruct termios local_term_attributes;\r\nterm_attributes_were_set = 0;\r\nif (!isatty(STDIN_FILENO)) {\r\nreturn;\r\n}\r\nif (tcgetattr(STDIN_FILENO, &original_term_attributes)) {\r\nfprintf(stderr, "Could not get terminal attributes!\n");\r\nreturn;\r\n}\r\nmemcpy(&local_term_attributes, &original_term_attributes,\r\nsizeof(struct termios));\r\nlocal_term_attributes.c_lflag &= ~(ICANON | ECHO);\r\nlocal_term_attributes.c_cc[VMIN] = 1;\r\nlocal_term_attributes.c_cc[VTIME] = 0;\r\nif (tcsetattr(STDIN_FILENO, TCSANOW, &local_term_attributes)) {\r\nfprintf(stderr, "Could not set terminal attributes!\n");\r\nreturn;\r\n}\r\nterm_attributes_were_set = 1;\r\n}\r\nstatic void os_exit_line_edit_mode(void)\r\n{\r\nif (!term_attributes_were_set) {\r\nreturn;\r\n}\r\nif (tcsetattr(STDIN_FILENO, TCSANOW, &original_term_attributes)) {\r\nfprintf(stderr, "Could not restore terminal attributes!\n");\r\n}\r\n}\r\nacpi_status acpi_os_initialize(void)\r\n{\r\nacpi_status status;\r\nacpi_gbl_output_file = stdout;\r\nos_enter_line_edit_mode();\r\nstatus = acpi_os_create_lock(&acpi_gbl_print_lock);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nreturn (AE_OK);\r\n}\r\nacpi_status acpi_os_terminate(void)\r\n{\r\nos_exit_line_edit_mode();\r\nreturn (AE_OK);\r\n}\r\nacpi_physical_address acpi_os_get_root_pointer(void)\r\n{\r\nreturn (0);\r\n}\r\nacpi_status\r\nacpi_os_predefined_override(const struct acpi_predefined_names *init_val,\r\nacpi_string *new_val)\r\n{\r\nif (!init_val || !new_val) {\r\nreturn (AE_BAD_PARAMETER);\r\n}\r\n*new_val = NULL;\r\nreturn (AE_OK);\r\n}\r\nacpi_status\r\nacpi_os_table_override(struct acpi_table_header *existing_table,\r\nstruct acpi_table_header **new_table)\r\n{\r\nif (!existing_table || !new_table) {\r\nreturn (AE_BAD_PARAMETER);\r\n}\r\n*new_table = NULL;\r\n#ifdef ACPI_EXEC_APP\r\nae_table_override(existing_table, new_table);\r\nreturn (AE_OK);\r\n#else\r\nreturn (AE_NO_ACPI_TABLES);\r\n#endif\r\n}\r\nacpi_status\r\nacpi_os_physical_table_override(struct acpi_table_header *existing_table,\r\nacpi_physical_address *new_address,\r\nu32 *new_table_length)\r\n{\r\nreturn (AE_SUPPORT);\r\n}\r\nacpi_status acpi_os_enter_sleep(u8 sleep_state, u32 rega_value, u32 regb_value)\r\n{\r\nreturn (AE_OK);\r\n}\r\nvoid acpi_os_redirect_output(void *destination)\r\n{\r\nacpi_gbl_output_file = destination;\r\n}\r\nvoid ACPI_INTERNAL_VAR_XFACE acpi_os_printf(const char *fmt, ...)\r\n{\r\nva_list args;\r\nu8 flags;\r\nflags = acpi_gbl_db_output_flags;\r\nif (flags & ACPI_DB_REDIRECTABLE_OUTPUT) {\r\nif (acpi_gbl_debug_file) {\r\nva_start(args, fmt);\r\nvfprintf(acpi_gbl_debug_file, fmt, args);\r\nva_end(args);\r\n} else {\r\nflags |= ACPI_DB_CONSOLE_OUTPUT;\r\n}\r\n}\r\nif (flags & ACPI_DB_CONSOLE_OUTPUT) {\r\nva_start(args, fmt);\r\nvfprintf(acpi_gbl_output_file, fmt, args);\r\nva_end(args);\r\n}\r\n}\r\nvoid acpi_os_vprintf(const char *fmt, va_list args)\r\n{\r\nu8 flags;\r\nchar buffer[ACPI_VPRINTF_BUFFER_SIZE];\r\nvsnprintf(buffer, ACPI_VPRINTF_BUFFER_SIZE, fmt, args);\r\nflags = acpi_gbl_db_output_flags;\r\nif (flags & ACPI_DB_REDIRECTABLE_OUTPUT) {\r\nif (acpi_gbl_debug_file) {\r\nfputs(buffer, acpi_gbl_debug_file);\r\n} else {\r\nflags |= ACPI_DB_CONSOLE_OUTPUT;\r\n}\r\n}\r\nif (flags & ACPI_DB_CONSOLE_OUTPUT) {\r\nfputs(buffer, acpi_gbl_output_file);\r\n}\r\n}\r\nacpi_status acpi_os_get_line(char *buffer, u32 buffer_length, u32 *bytes_read)\r\n{\r\nint input_char;\r\nu32 end_of_line;\r\nfor (end_of_line = 0;; end_of_line++) {\r\nif (end_of_line >= buffer_length) {\r\nreturn (AE_BUFFER_OVERFLOW);\r\n}\r\nif ((input_char = getchar()) == EOF) {\r\nreturn (AE_ERROR);\r\n}\r\nif (!input_char || input_char == _ASCII_NEWLINE) {\r\nbreak;\r\n}\r\nbuffer[end_of_line] = (char)input_char;\r\n}\r\nbuffer[end_of_line] = 0;\r\nif (bytes_read) {\r\n*bytes_read = end_of_line;\r\n}\r\nreturn (AE_OK);\r\n}\r\nvoid *acpi_os_map_memory(acpi_physical_address where, acpi_size length)\r\n{\r\nreturn (ACPI_TO_POINTER((acpi_size)where));\r\n}\r\nvoid acpi_os_unmap_memory(void *where, acpi_size length)\r\n{\r\nreturn;\r\n}\r\nvoid *acpi_os_allocate(acpi_size size)\r\n{\r\nvoid *mem;\r\nmem = (void *)malloc((size_t) size);\r\nreturn (mem);\r\n}\r\nvoid *acpi_os_allocate_zeroed(acpi_size size)\r\n{\r\nvoid *mem;\r\nmem = (void *)calloc(1, (size_t) size);\r\nreturn (mem);\r\n}\r\nvoid acpi_os_free(void *mem)\r\n{\r\nfree(mem);\r\n}\r\nacpi_status\r\nacpi_os_create_semaphore(u32 max_units,\r\nu32 initial_units, acpi_handle *out_handle)\r\n{\r\n*out_handle = (acpi_handle)1;\r\nreturn (AE_OK);\r\n}\r\nacpi_status acpi_os_delete_semaphore(acpi_handle handle)\r\n{\r\nreturn (AE_OK);\r\n}\r\nacpi_status acpi_os_wait_semaphore(acpi_handle handle, u32 units, u16 timeout)\r\n{\r\nreturn (AE_OK);\r\n}\r\nacpi_status acpi_os_signal_semaphore(acpi_handle handle, u32 units)\r\n{\r\nreturn (AE_OK);\r\n}\r\nacpi_status\r\nacpi_os_create_semaphore(u32 max_units,\r\nu32 initial_units, acpi_handle *out_handle)\r\n{\r\nsem_t *sem;\r\nif (!out_handle) {\r\nreturn (AE_BAD_PARAMETER);\r\n}\r\n#ifdef __APPLE__\r\n{\r\nstatic int semaphore_count = 0;\r\nchar semaphore_name[32];\r\nsnprintf(semaphore_name, sizeof(semaphore_name), "acpi_sem_%d",\r\nsemaphore_count++);\r\nprintf("%s\n", semaphore_name);\r\nsem =\r\nsem_open(semaphore_name, O_EXCL | O_CREAT, 0755,\r\ninitial_units);\r\nif (!sem) {\r\nreturn (AE_NO_MEMORY);\r\n}\r\nsem_unlink(semaphore_name);\r\n}\r\n#else\r\nsem = acpi_os_allocate(sizeof(sem_t));\r\nif (!sem) {\r\nreturn (AE_NO_MEMORY);\r\n}\r\nif (sem_init(sem, 0, initial_units) == -1) {\r\nacpi_os_free(sem);\r\nreturn (AE_BAD_PARAMETER);\r\n}\r\n#endif\r\n*out_handle = (acpi_handle)sem;\r\nreturn (AE_OK);\r\n}\r\nacpi_status acpi_os_delete_semaphore(acpi_handle handle)\r\n{\r\nsem_t *sem = (sem_t *) handle;\r\nif (!sem) {\r\nreturn (AE_BAD_PARAMETER);\r\n}\r\n#ifdef __APPLE__\r\nif (sem_close(sem) == -1) {\r\nreturn (AE_BAD_PARAMETER);\r\n}\r\n#else\r\nif (sem_destroy(sem) == -1) {\r\nreturn (AE_BAD_PARAMETER);\r\n}\r\n#endif\r\nreturn (AE_OK);\r\n}\r\nacpi_status\r\nacpi_os_wait_semaphore(acpi_handle handle, u32 units, u16 msec_timeout)\r\n{\r\nacpi_status status = AE_OK;\r\nsem_t *sem = (sem_t *) handle;\r\nint ret_val;\r\n#ifndef ACPI_USE_ALTERNATE_TIMEOUT\r\nstruct timespec time;\r\n#endif\r\nif (!sem) {\r\nreturn (AE_BAD_PARAMETER);\r\n}\r\nswitch (msec_timeout) {\r\ncase 0:\r\nif (sem_trywait(sem) == -1) {\r\nstatus = (AE_TIME);\r\n}\r\nbreak;\r\ncase ACPI_WAIT_FOREVER:\r\nwhile (((ret_val = sem_wait(sem)) == -1) && (errno == EINTR)) {\r\ncontinue;\r\n}\r\nif (ret_val != 0) {\r\nstatus = (AE_TIME);\r\n}\r\nbreak;\r\ndefault:\r\n#ifdef ACPI_USE_ALTERNATE_TIMEOUT\r\nwhile (msec_timeout) {\r\nif (sem_trywait(sem) == 0) {\r\nreturn (AE_OK);\r\n}\r\nif (msec_timeout >= 10) {\r\nmsec_timeout -= 10;\r\nusleep(10 * ACPI_USEC_PER_MSEC);\r\n} else {\r\nmsec_timeout--;\r\nusleep(ACPI_USEC_PER_MSEC);\r\n}\r\n}\r\nstatus = (AE_TIME);\r\n#else\r\nif (clock_gettime(CLOCK_REALTIME, &time) == -1) {\r\nperror("clock_gettime");\r\nreturn (AE_TIME);\r\n}\r\ntime.tv_sec += (msec_timeout / ACPI_MSEC_PER_SEC);\r\ntime.tv_nsec +=\r\n((msec_timeout % ACPI_MSEC_PER_SEC) * ACPI_NSEC_PER_MSEC);\r\nif (time.tv_nsec >= ACPI_NSEC_PER_SEC) {\r\ntime.tv_sec += (time.tv_nsec / ACPI_NSEC_PER_SEC);\r\ntime.tv_nsec = (time.tv_nsec % ACPI_NSEC_PER_SEC);\r\n}\r\nwhile (((ret_val = sem_timedwait(sem, &time)) == -1)\r\n&& (errno == EINTR)) {\r\ncontinue;\r\n}\r\nif (ret_val != 0) {\r\nif (errno != ETIMEDOUT) {\r\nperror("sem_timedwait");\r\n}\r\nstatus = (AE_TIME);\r\n}\r\n#endif\r\nbreak;\r\n}\r\nreturn (status);\r\n}\r\nacpi_status acpi_os_signal_semaphore(acpi_handle handle, u32 units)\r\n{\r\nsem_t *sem = (sem_t *) handle;\r\nif (!sem) {\r\nreturn (AE_BAD_PARAMETER);\r\n}\r\nif (sem_post(sem) == -1) {\r\nreturn (AE_LIMIT);\r\n}\r\nreturn (AE_OK);\r\n}\r\nacpi_status acpi_os_create_lock(acpi_spinlock * out_handle)\r\n{\r\nreturn (acpi_os_create_semaphore(1, 1, out_handle));\r\n}\r\nvoid acpi_os_delete_lock(acpi_spinlock handle)\r\n{\r\nacpi_os_delete_semaphore(handle);\r\n}\r\nacpi_cpu_flags acpi_os_acquire_lock(acpi_handle handle)\r\n{\r\nacpi_os_wait_semaphore(handle, 1, 0xFFFF);\r\nreturn (0);\r\n}\r\nvoid acpi_os_release_lock(acpi_spinlock handle, acpi_cpu_flags flags)\r\n{\r\nacpi_os_signal_semaphore(handle, 1);\r\n}\r\nu32\r\nacpi_os_install_interrupt_handler(u32 interrupt_number,\r\nacpi_osd_handler service_routine,\r\nvoid *context)\r\n{\r\nreturn (AE_OK);\r\n}\r\nacpi_status\r\nacpi_os_remove_interrupt_handler(u32 interrupt_number,\r\nacpi_osd_handler service_routine)\r\n{\r\nreturn (AE_OK);\r\n}\r\nvoid acpi_os_stall(u32 microseconds)\r\n{\r\nif (microseconds) {\r\nusleep(microseconds);\r\n}\r\n}\r\nvoid acpi_os_sleep(u64 milliseconds)\r\n{\r\nsleep(milliseconds / ACPI_MSEC_PER_SEC);\r\nusleep((milliseconds % ACPI_MSEC_PER_SEC) * ACPI_USEC_PER_MSEC);\r\n}\r\nu64 acpi_os_get_timer(void)\r\n{\r\nstruct timeval time;\r\ngettimeofday(&time, NULL);\r\nreturn (((u64)time.tv_sec * ACPI_100NSEC_PER_SEC) +\r\n((u64)time.tv_usec * ACPI_100NSEC_PER_USEC));\r\n}\r\nacpi_status\r\nacpi_os_read_pci_configuration(struct acpi_pci_id *pci_id,\r\nu32 pci_register, u64 *value, u32 width)\r\n{\r\n*value = 0;\r\nreturn (AE_OK);\r\n}\r\nacpi_status\r\nacpi_os_write_pci_configuration(struct acpi_pci_id *pci_id,\r\nu32 pci_register, u64 value, u32 width)\r\n{\r\nreturn (AE_OK);\r\n}\r\nacpi_status acpi_os_read_port(acpi_io_address address, u32 *value, u32 width)\r\n{\r\nswitch (width) {\r\ncase 8:\r\n*value = 0xFF;\r\nbreak;\r\ncase 16:\r\n*value = 0xFFFF;\r\nbreak;\r\ncase 32:\r\n*value = 0xFFFFFFFF;\r\nbreak;\r\ndefault:\r\nreturn (AE_BAD_PARAMETER);\r\n}\r\nreturn (AE_OK);\r\n}\r\nacpi_status acpi_os_write_port(acpi_io_address address, u32 value, u32 width)\r\n{\r\nreturn (AE_OK);\r\n}\r\nacpi_status\r\nacpi_os_read_memory(acpi_physical_address address, u64 *value, u32 width)\r\n{\r\nswitch (width) {\r\ncase 8:\r\ncase 16:\r\ncase 32:\r\ncase 64:\r\n*value = 0;\r\nbreak;\r\ndefault:\r\nreturn (AE_BAD_PARAMETER);\r\n}\r\nreturn (AE_OK);\r\n}\r\nacpi_status\r\nacpi_os_write_memory(acpi_physical_address address, u64 value, u32 width)\r\n{\r\nreturn (AE_OK);\r\n}\r\nu8 acpi_os_readable(void *pointer, acpi_size length)\r\n{\r\nreturn (TRUE);\r\n}\r\nu8 acpi_os_writable(void *pointer, acpi_size length)\r\n{\r\nreturn (TRUE);\r\n}\r\nacpi_status acpi_os_signal(u32 function, void *info)\r\n{\r\nswitch (function) {\r\ncase ACPI_SIGNAL_FATAL:\r\nbreak;\r\ncase ACPI_SIGNAL_BREAKPOINT:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn (AE_OK);\r\n}\r\nacpi_thread_id acpi_os_get_thread_id(void)\r\n{\r\npthread_t thread;\r\nthread = pthread_self();\r\nreturn (ACPI_CAST_PTHREAD_T(thread));\r\n}\r\nacpi_status\r\nacpi_os_execute(acpi_execute_type type,\r\nacpi_osd_exec_callback function, void *context)\r\n{\r\npthread_t thread;\r\nint ret;\r\nret =\r\npthread_create(&thread, NULL, (PTHREAD_CALLBACK) function, context);\r\nif (ret) {\r\nacpi_os_printf("Create thread failed");\r\n}\r\nreturn (0);\r\n}\r\nacpi_thread_id acpi_os_get_thread_id(void)\r\n{\r\nreturn (1);\r\n}\r\nacpi_status\r\nacpi_os_execute(acpi_execute_type type,\r\nacpi_osd_exec_callback function, void *context)\r\n{\r\nfunction(context);\r\nreturn (AE_OK);\r\n}\r\nvoid acpi_os_wait_events_complete(void)\r\n{\r\nreturn;\r\n}
