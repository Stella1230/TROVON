static inline void xdbc_trace(const char *fmt, ...) { }\r\nstatic void __iomem * __init xdbc_map_pci_mmio(u32 bus, u32 dev, u32 func)\r\n{\r\nu64 val64, sz64, mask64;\r\nvoid __iomem *base;\r\nu32 val, sz;\r\nu8 byte;\r\nval = read_pci_config(bus, dev, func, PCI_BASE_ADDRESS_0);\r\nwrite_pci_config(bus, dev, func, PCI_BASE_ADDRESS_0, ~0);\r\nsz = read_pci_config(bus, dev, func, PCI_BASE_ADDRESS_0);\r\nwrite_pci_config(bus, dev, func, PCI_BASE_ADDRESS_0, val);\r\nif (val == 0xffffffff || sz == 0xffffffff) {\r\npr_notice("invalid mmio bar\n");\r\nreturn NULL;\r\n}\r\nval64 = val & PCI_BASE_ADDRESS_MEM_MASK;\r\nsz64 = sz & PCI_BASE_ADDRESS_MEM_MASK;\r\nmask64 = PCI_BASE_ADDRESS_MEM_MASK;\r\nif ((val & PCI_BASE_ADDRESS_MEM_TYPE_MASK) == PCI_BASE_ADDRESS_MEM_TYPE_64) {\r\nval = read_pci_config(bus, dev, func, PCI_BASE_ADDRESS_0 + 4);\r\nwrite_pci_config(bus, dev, func, PCI_BASE_ADDRESS_0 + 4, ~0);\r\nsz = read_pci_config(bus, dev, func, PCI_BASE_ADDRESS_0 + 4);\r\nwrite_pci_config(bus, dev, func, PCI_BASE_ADDRESS_0 + 4, val);\r\nval64 |= (u64)val << 32;\r\nsz64 |= (u64)sz << 32;\r\nmask64 |= ~0ULL << 32;\r\n}\r\nsz64 &= mask64;\r\nif (!sz64) {\r\npr_notice("invalid mmio address\n");\r\nreturn NULL;\r\n}\r\nsz64 = 1ULL << __ffs64(sz64);\r\nbyte = read_pci_config_byte(bus, dev, func, PCI_COMMAND);\r\nif (!(byte & PCI_COMMAND_MEMORY)) {\r\nbyte |= PCI_COMMAND_MEMORY;\r\nwrite_pci_config_byte(bus, dev, func, PCI_COMMAND, byte);\r\n}\r\nxdbc.xhci_start = val64;\r\nxdbc.xhci_length = sz64;\r\nbase = early_ioremap(val64, sz64);\r\nreturn base;\r\n}\r\nstatic void * __init xdbc_get_page(dma_addr_t *dma_addr)\r\n{\r\nvoid *virt;\r\nvirt = alloc_bootmem_pages_nopanic(PAGE_SIZE);\r\nif (!virt)\r\nreturn NULL;\r\nif (dma_addr)\r\n*dma_addr = (dma_addr_t)__pa(virt);\r\nreturn virt;\r\n}\r\nstatic u32 __init xdbc_find_dbgp(int xdbc_num, u32 *b, u32 *d, u32 *f)\r\n{\r\nu32 bus, dev, func, class;\r\nfor (bus = 0; bus < XDBC_PCI_MAX_BUSES; bus++) {\r\nfor (dev = 0; dev < XDBC_PCI_MAX_DEVICES; dev++) {\r\nfor (func = 0; func < XDBC_PCI_MAX_FUNCTION; func++) {\r\nclass = read_pci_config(bus, dev, func, PCI_CLASS_REVISION);\r\nif ((class >> 8) != PCI_CLASS_SERIAL_USB_XHCI)\r\ncontinue;\r\nif (xdbc_num-- != 0)\r\ncontinue;\r\n*b = bus;\r\n*d = dev;\r\n*f = func;\r\nreturn 0;\r\n}\r\n}\r\n}\r\nreturn -1;\r\n}\r\nstatic int handshake(void __iomem *ptr, u32 mask, u32 done, int wait, int delay)\r\n{\r\nu32 result;\r\ndo {\r\nresult = readl(ptr);\r\nresult &= mask;\r\nif (result == done)\r\nreturn 0;\r\nudelay(delay);\r\nwait -= delay;\r\n} while (wait > 0);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic void __init xdbc_bios_handoff(void)\r\n{\r\nint offset, timeout;\r\nu32 val;\r\noffset = xhci_find_next_ext_cap(xdbc.xhci_base, 0, XHCI_EXT_CAPS_LEGACY);\r\nval = readl(xdbc.xhci_base + offset);\r\nif (val & XHCI_HC_BIOS_OWNED) {\r\nwritel(val | XHCI_HC_OS_OWNED, xdbc.xhci_base + offset);\r\ntimeout = handshake(xdbc.xhci_base + offset, XHCI_HC_BIOS_OWNED, 0, 5000, 10);\r\nif (timeout) {\r\npr_notice("failed to hand over xHCI control from BIOS\n");\r\nwritel(val & ~XHCI_HC_BIOS_OWNED, xdbc.xhci_base + offset);\r\n}\r\n}\r\nval = readl(xdbc.xhci_base + offset + XHCI_LEGACY_CONTROL_OFFSET);\r\nval &= XHCI_LEGACY_DISABLE_SMI;\r\nval |= XHCI_LEGACY_SMI_EVENTS;\r\nwritel(val, xdbc.xhci_base + offset + XHCI_LEGACY_CONTROL_OFFSET);\r\n}\r\nstatic int __init\r\nxdbc_alloc_ring(struct xdbc_segment *seg, struct xdbc_ring *ring)\r\n{\r\nseg->trbs = xdbc_get_page(&seg->dma);\r\nif (!seg->trbs)\r\nreturn -ENOMEM;\r\nring->segment = seg;\r\nreturn 0;\r\n}\r\nstatic void __init xdbc_free_ring(struct xdbc_ring *ring)\r\n{\r\nstruct xdbc_segment *seg = ring->segment;\r\nif (!seg)\r\nreturn;\r\nfree_bootmem(seg->dma, PAGE_SIZE);\r\nring->segment = NULL;\r\n}\r\nstatic void xdbc_reset_ring(struct xdbc_ring *ring)\r\n{\r\nstruct xdbc_segment *seg = ring->segment;\r\nstruct xdbc_trb *link_trb;\r\nmemset(seg->trbs, 0, PAGE_SIZE);\r\nring->enqueue = seg->trbs;\r\nring->dequeue = seg->trbs;\r\nring->cycle_state = 1;\r\nif (ring != &xdbc.evt_ring) {\r\nlink_trb = &seg->trbs[XDBC_TRBS_PER_SEGMENT - 1];\r\nlink_trb->field[0] = cpu_to_le32(lower_32_bits(seg->dma));\r\nlink_trb->field[1] = cpu_to_le32(upper_32_bits(seg->dma));\r\nlink_trb->field[3] = cpu_to_le32(TRB_TYPE(TRB_LINK)) | cpu_to_le32(LINK_TOGGLE);\r\n}\r\n}\r\nstatic inline void xdbc_put_utf16(u16 *s, const char *c, size_t size)\r\n{\r\nint i;\r\nfor (i = 0; i < size; i++)\r\ns[i] = cpu_to_le16(c[i]);\r\n}\r\nstatic void xdbc_mem_init(void)\r\n{\r\nstruct xdbc_ep_context *ep_in, *ep_out;\r\nstruct usb_string_descriptor *s_desc;\r\nstruct xdbc_erst_entry *entry;\r\nstruct xdbc_strings *strings;\r\nstruct xdbc_context *ctx;\r\nunsigned int max_burst;\r\nu32 string_length;\r\nint index = 0;\r\nu32 dev_info;\r\nxdbc_reset_ring(&xdbc.evt_ring);\r\nxdbc_reset_ring(&xdbc.in_ring);\r\nxdbc_reset_ring(&xdbc.out_ring);\r\nmemset(xdbc.table_base, 0, PAGE_SIZE);\r\nmemset(xdbc.out_buf, 0, PAGE_SIZE);\r\nxdbc.erst_size = 16;\r\nxdbc.erst_base = xdbc.table_base + index * XDBC_TABLE_ENTRY_SIZE;\r\nxdbc.erst_dma = xdbc.table_dma + index * XDBC_TABLE_ENTRY_SIZE;\r\nindex += XDBC_ERST_ENTRY_NUM;\r\nentry = (struct xdbc_erst_entry *)xdbc.erst_base;\r\nentry->seg_addr = cpu_to_le64(xdbc.evt_seg.dma);\r\nentry->seg_size = cpu_to_le32(XDBC_TRBS_PER_SEGMENT);\r\nentry->__reserved_0 = 0;\r\nwritel(1, &xdbc.xdbc_reg->ersts);\r\nxdbc_write64(xdbc.erst_dma, &xdbc.xdbc_reg->erstba);\r\nxdbc_write64(xdbc.evt_seg.dma, &xdbc.xdbc_reg->erdp);\r\nxdbc.dbcc_size = 64 * 3;\r\nxdbc.dbcc_base = xdbc.table_base + index * XDBC_TABLE_ENTRY_SIZE;\r\nxdbc.dbcc_dma = xdbc.table_dma + index * XDBC_TABLE_ENTRY_SIZE;\r\nindex += XDBC_DBCC_ENTRY_NUM;\r\nxdbc.string_size = sizeof(struct xdbc_strings);\r\nxdbc.string_base = xdbc.table_base + index * XDBC_TABLE_ENTRY_SIZE;\r\nxdbc.string_dma = xdbc.table_dma + index * XDBC_TABLE_ENTRY_SIZE;\r\nstrings = (struct xdbc_strings *)xdbc.string_base;\r\nindex += XDBC_STRING_ENTRY_NUM;\r\ns_desc = (struct usb_string_descriptor *)strings->serial;\r\ns_desc->bLength = (strlen(XDBC_STRING_SERIAL) + 1) * 2;\r\ns_desc->bDescriptorType = USB_DT_STRING;\r\nxdbc_put_utf16(s_desc->wData, XDBC_STRING_SERIAL, strlen(XDBC_STRING_SERIAL));\r\nstring_length = s_desc->bLength;\r\nstring_length <<= 8;\r\ns_desc = (struct usb_string_descriptor *)strings->product;\r\ns_desc->bLength = (strlen(XDBC_STRING_PRODUCT) + 1) * 2;\r\ns_desc->bDescriptorType = USB_DT_STRING;\r\nxdbc_put_utf16(s_desc->wData, XDBC_STRING_PRODUCT, strlen(XDBC_STRING_PRODUCT));\r\nstring_length += s_desc->bLength;\r\nstring_length <<= 8;\r\ns_desc = (struct usb_string_descriptor *)strings->manufacturer;\r\ns_desc->bLength = (strlen(XDBC_STRING_MANUFACTURER) + 1) * 2;\r\ns_desc->bDescriptorType = USB_DT_STRING;\r\nxdbc_put_utf16(s_desc->wData, XDBC_STRING_MANUFACTURER, strlen(XDBC_STRING_MANUFACTURER));\r\nstring_length += s_desc->bLength;\r\nstring_length <<= 8;\r\nstrings->string0[0] = 4;\r\nstrings->string0[1] = USB_DT_STRING;\r\nstrings->string0[2] = 0x09;\r\nstrings->string0[3] = 0x04;\r\nstring_length += 4;\r\nctx = (struct xdbc_context *)xdbc.dbcc_base;\r\nctx->info.string0 = cpu_to_le64(xdbc.string_dma);\r\nctx->info.manufacturer = cpu_to_le64(xdbc.string_dma + XDBC_MAX_STRING_LENGTH);\r\nctx->info.product = cpu_to_le64(xdbc.string_dma + XDBC_MAX_STRING_LENGTH * 2);\r\nctx->info.serial = cpu_to_le64(xdbc.string_dma + XDBC_MAX_STRING_LENGTH * 3);\r\nctx->info.length = cpu_to_le32(string_length);\r\nmax_burst = DEBUG_MAX_BURST(readl(&xdbc.xdbc_reg->control));\r\nep_out = (struct xdbc_ep_context *)&ctx->out;\r\nep_out->ep_info1 = 0;\r\nep_out->ep_info2 = cpu_to_le32(EP_TYPE(BULK_OUT_EP) | MAX_PACKET(1024) | MAX_BURST(max_burst));\r\nep_out->deq = cpu_to_le64(xdbc.out_seg.dma | xdbc.out_ring.cycle_state);\r\nep_in = (struct xdbc_ep_context *)&ctx->in;\r\nep_in->ep_info1 = 0;\r\nep_in->ep_info2 = cpu_to_le32(EP_TYPE(BULK_OUT_EP) | MAX_PACKET(1024) | MAX_BURST(max_burst));\r\nep_in->deq = cpu_to_le64(xdbc.in_seg.dma | xdbc.in_ring.cycle_state);\r\nxdbc_write64(xdbc.dbcc_dma, &xdbc.xdbc_reg->dccp);\r\ndev_info = cpu_to_le32((XDBC_VENDOR_ID << 16) | XDBC_PROTOCOL);\r\nwritel(dev_info, &xdbc.xdbc_reg->devinfo1);\r\ndev_info = cpu_to_le32((XDBC_DEVICE_REV << 16) | XDBC_PRODUCT_ID);\r\nwritel(dev_info, &xdbc.xdbc_reg->devinfo2);\r\nxdbc.in_buf = xdbc.out_buf + XDBC_MAX_PACKET;\r\nxdbc.in_dma = xdbc.out_dma + XDBC_MAX_PACKET;\r\n}\r\nstatic void xdbc_do_reset_debug_port(u32 id, u32 count)\r\n{\r\nvoid __iomem *ops_reg;\r\nvoid __iomem *portsc;\r\nu32 val, cap_length;\r\nint i;\r\ncap_length = readl(xdbc.xhci_base) & 0xff;\r\nops_reg = xdbc.xhci_base + cap_length;\r\nid--;\r\nfor (i = id; i < (id + count); i++) {\r\nportsc = ops_reg + 0x400 + i * 0x10;\r\nval = readl(portsc);\r\nif (!(val & PORT_CONNECT))\r\nwritel(val | PORT_RESET, portsc);\r\n}\r\n}\r\nstatic void xdbc_reset_debug_port(void)\r\n{\r\nu32 val, port_offset, port_count;\r\nint offset = 0;\r\ndo {\r\noffset = xhci_find_next_ext_cap(xdbc.xhci_base, offset, XHCI_EXT_CAPS_PROTOCOL);\r\nif (!offset)\r\nbreak;\r\nval = readl(xdbc.xhci_base + offset);\r\nif (XHCI_EXT_PORT_MAJOR(val) != 0x3)\r\ncontinue;\r\nval = readl(xdbc.xhci_base + offset + 8);\r\nport_offset = XHCI_EXT_PORT_OFF(val);\r\nport_count = XHCI_EXT_PORT_COUNT(val);\r\nxdbc_do_reset_debug_port(port_offset, port_count);\r\n} while (1);\r\n}\r\nstatic void\r\nxdbc_queue_trb(struct xdbc_ring *ring, u32 field1, u32 field2, u32 field3, u32 field4)\r\n{\r\nstruct xdbc_trb *trb, *link_trb;\r\ntrb = ring->enqueue;\r\ntrb->field[0] = cpu_to_le32(field1);\r\ntrb->field[1] = cpu_to_le32(field2);\r\ntrb->field[2] = cpu_to_le32(field3);\r\ntrb->field[3] = cpu_to_le32(field4);\r\n++(ring->enqueue);\r\nif (ring->enqueue >= &ring->segment->trbs[TRBS_PER_SEGMENT - 1]) {\r\nlink_trb = ring->enqueue;\r\nif (ring->cycle_state)\r\nlink_trb->field[3] |= cpu_to_le32(TRB_CYCLE);\r\nelse\r\nlink_trb->field[3] &= cpu_to_le32(~TRB_CYCLE);\r\nring->enqueue = ring->segment->trbs;\r\nring->cycle_state ^= 1;\r\n}\r\n}\r\nstatic void xdbc_ring_doorbell(int target)\r\n{\r\nwritel(DOOR_BELL_TARGET(target), &xdbc.xdbc_reg->doorbell);\r\n}\r\nstatic int xdbc_start(void)\r\n{\r\nu32 ctrl, status;\r\nint ret;\r\nctrl = readl(&xdbc.xdbc_reg->control);\r\nwritel(ctrl | CTRL_DBC_ENABLE | CTRL_PORT_ENABLE, &xdbc.xdbc_reg->control);\r\nret = handshake(&xdbc.xdbc_reg->control, CTRL_DBC_ENABLE, CTRL_DBC_ENABLE, 100000, 100);\r\nif (ret) {\r\nxdbc_trace("failed to initialize hardware\n");\r\nreturn ret;\r\n}\r\nif (xdbc.vendor == PCI_VENDOR_ID_INTEL)\r\nxdbc_reset_debug_port();\r\nret = handshake(&xdbc.xdbc_reg->portsc, PORTSC_CONN_STATUS, PORTSC_CONN_STATUS, 5000000, 100);\r\nif (ret) {\r\nxdbc_trace("waiting for connection timed out\n");\r\nreturn ret;\r\n}\r\nret = handshake(&xdbc.xdbc_reg->control, CTRL_DBC_RUN, CTRL_DBC_RUN, 5000000, 100);\r\nif (ret) {\r\nxdbc_trace("waiting for device configuration timed out\n");\r\nreturn ret;\r\n}\r\nstatus = readl(&xdbc.xdbc_reg->status);\r\nif (!DCST_DEBUG_PORT(status)) {\r\nxdbc_trace("invalid root hub port number\n");\r\nreturn -ENODEV;\r\n}\r\nxdbc.port_number = DCST_DEBUG_PORT(status);\r\nxdbc_trace("DbC is running now, control 0x%08x port ID %d\n",\r\nreadl(&xdbc.xdbc_reg->control), xdbc.port_number);\r\nreturn 0;\r\n}\r\nstatic int xdbc_bulk_transfer(void *data, int size, bool read)\r\n{\r\nstruct xdbc_ring *ring;\r\nstruct xdbc_trb *trb;\r\nu32 length, control;\r\nu32 cycle;\r\nu64 addr;\r\nif (size > XDBC_MAX_PACKET) {\r\nxdbc_trace("bad parameter, size %d\n", size);\r\nreturn -EINVAL;\r\n}\r\nif (!(xdbc.flags & XDBC_FLAGS_INITIALIZED) ||\r\n!(xdbc.flags & XDBC_FLAGS_CONFIGURED) ||\r\n(!read && (xdbc.flags & XDBC_FLAGS_OUT_STALL)) ||\r\n(read && (xdbc.flags & XDBC_FLAGS_IN_STALL))) {\r\nxdbc_trace("connection not ready, flags %08x\n", xdbc.flags);\r\nreturn -EIO;\r\n}\r\nring = (read ? &xdbc.in_ring : &xdbc.out_ring);\r\ntrb = ring->enqueue;\r\ncycle = ring->cycle_state;\r\nlength = TRB_LEN(size);\r\ncontrol = TRB_TYPE(TRB_NORMAL) | TRB_IOC;\r\nif (cycle)\r\ncontrol &= cpu_to_le32(~TRB_CYCLE);\r\nelse\r\ncontrol |= cpu_to_le32(TRB_CYCLE);\r\nif (read) {\r\nmemset(xdbc.in_buf, 0, XDBC_MAX_PACKET);\r\naddr = xdbc.in_dma;\r\nxdbc.flags |= XDBC_FLAGS_IN_PROCESS;\r\n} else {\r\nmemset(xdbc.out_buf, 0, XDBC_MAX_PACKET);\r\nmemcpy(xdbc.out_buf, data, size);\r\naddr = xdbc.out_dma;\r\nxdbc.flags |= XDBC_FLAGS_OUT_PROCESS;\r\n}\r\nxdbc_queue_trb(ring, lower_32_bits(addr), upper_32_bits(addr), length, control);\r\nwmb();\r\nif (cycle)\r\ntrb->field[3] |= cpu_to_le32(cycle);\r\nelse\r\ntrb->field[3] &= cpu_to_le32(~TRB_CYCLE);\r\nxdbc_ring_doorbell(read ? IN_EP_DOORBELL : OUT_EP_DOORBELL);\r\nreturn size;\r\n}\r\nstatic int xdbc_handle_external_reset(void)\r\n{\r\nint ret = 0;\r\nxdbc.flags = 0;\r\nwritel(0, &xdbc.xdbc_reg->control);\r\nret = handshake(&xdbc.xdbc_reg->control, CTRL_DBC_ENABLE, 0, 100000, 10);\r\nif (ret)\r\ngoto reset_out;\r\nxdbc_mem_init();\r\nmmiowb();\r\nret = xdbc_start();\r\nif (ret < 0)\r\ngoto reset_out;\r\nxdbc_trace("dbc recovered\n");\r\nxdbc.flags |= XDBC_FLAGS_INITIALIZED | XDBC_FLAGS_CONFIGURED;\r\nxdbc_bulk_transfer(NULL, XDBC_MAX_PACKET, true);\r\nreturn 0;\r\nreset_out:\r\nxdbc_trace("failed to recover from external reset\n");\r\nreturn ret;\r\n}\r\nstatic int __init xdbc_early_setup(void)\r\n{\r\nint ret;\r\nwritel(0, &xdbc.xdbc_reg->control);\r\nret = handshake(&xdbc.xdbc_reg->control, CTRL_DBC_ENABLE, 0, 100000, 100);\r\nif (ret)\r\nreturn ret;\r\nxdbc.table_base = xdbc_get_page(&xdbc.table_dma);\r\nif (!xdbc.table_base)\r\nreturn -ENOMEM;\r\nxdbc.out_buf = xdbc_get_page(&xdbc.out_dma);\r\nif (!xdbc.out_buf)\r\nreturn -ENOMEM;\r\nret = xdbc_alloc_ring(&xdbc.evt_seg, &xdbc.evt_ring);\r\nif (ret < 0)\r\nreturn ret;\r\nret = xdbc_alloc_ring(&xdbc.in_seg, &xdbc.in_ring);\r\nif (ret < 0)\r\nreturn ret;\r\nret = xdbc_alloc_ring(&xdbc.out_seg, &xdbc.out_ring);\r\nif (ret < 0)\r\nreturn ret;\r\nxdbc_mem_init();\r\nmmiowb();\r\nret = xdbc_start();\r\nif (ret < 0) {\r\nwritel(0, &xdbc.xdbc_reg->control);\r\nreturn ret;\r\n}\r\nxdbc.flags |= XDBC_FLAGS_INITIALIZED | XDBC_FLAGS_CONFIGURED;\r\nxdbc_bulk_transfer(NULL, XDBC_MAX_PACKET, true);\r\nreturn 0;\r\n}\r\nint __init early_xdbc_parse_parameter(char *s)\r\n{\r\nunsigned long dbgp_num = 0;\r\nu32 bus, dev, func, offset;\r\nint ret;\r\nif (!early_pci_allowed())\r\nreturn -EPERM;\r\nif (strstr(s, "keep"))\r\nearly_console_keep = true;\r\nif (xdbc.xdbc_reg)\r\nreturn 0;\r\nif (*s && kstrtoul(s, 0, &dbgp_num))\r\ndbgp_num = 0;\r\npr_notice("dbgp_num: %lu\n", dbgp_num);\r\nret = xdbc_find_dbgp(dbgp_num, &bus, &dev, &func);\r\nif (ret) {\r\npr_notice("failed to locate xhci host\n");\r\nreturn -ENODEV;\r\n}\r\nxdbc.vendor = read_pci_config_16(bus, dev, func, PCI_VENDOR_ID);\r\nxdbc.device = read_pci_config_16(bus, dev, func, PCI_DEVICE_ID);\r\nxdbc.bus = bus;\r\nxdbc.dev = dev;\r\nxdbc.func = func;\r\nxdbc.xhci_base = xdbc_map_pci_mmio(bus, dev, func);\r\nif (!xdbc.xhci_base)\r\nreturn -EINVAL;\r\noffset = xhci_find_next_ext_cap(xdbc.xhci_base, 0, XHCI_EXT_CAPS_DEBUG);\r\nif (!offset) {\r\npr_notice("xhci host doesn't support debug capability\n");\r\nearly_iounmap(xdbc.xhci_base, xdbc.xhci_length);\r\nxdbc.xhci_base = NULL;\r\nxdbc.xhci_length = 0;\r\nreturn -ENODEV;\r\n}\r\nxdbc.xdbc_reg = (struct xdbc_regs __iomem *)(xdbc.xhci_base + offset);\r\nreturn 0;\r\n}\r\nint __init early_xdbc_setup_hardware(void)\r\n{\r\nint ret;\r\nif (!xdbc.xdbc_reg)\r\nreturn -ENODEV;\r\nxdbc_bios_handoff();\r\nraw_spin_lock_init(&xdbc.lock);\r\nret = xdbc_early_setup();\r\nif (ret) {\r\npr_notice("failed to setup the connection to host\n");\r\nxdbc_free_ring(&xdbc.evt_ring);\r\nxdbc_free_ring(&xdbc.out_ring);\r\nxdbc_free_ring(&xdbc.in_ring);\r\nif (xdbc.table_dma)\r\nfree_bootmem(xdbc.table_dma, PAGE_SIZE);\r\nif (xdbc.out_dma)\r\nfree_bootmem(xdbc.out_dma, PAGE_SIZE);\r\nxdbc.table_base = NULL;\r\nxdbc.out_buf = NULL;\r\n}\r\nreturn ret;\r\n}\r\nstatic void xdbc_handle_port_status(struct xdbc_trb *evt_trb)\r\n{\r\nu32 port_reg;\r\nport_reg = readl(&xdbc.xdbc_reg->portsc);\r\nif (port_reg & PORTSC_CONN_CHANGE) {\r\nxdbc_trace("connect status change event\n");\r\nif (!(port_reg & PORTSC_CONN_STATUS)) {\r\nxdbc.flags = 0;\r\nxdbc_trace("cable unplugged\n");\r\n}\r\n}\r\nif (port_reg & PORTSC_RESET_CHANGE)\r\nxdbc_trace("port reset change event\n");\r\nif (port_reg & PORTSC_LINK_CHANGE)\r\nxdbc_trace("port link status change event\n");\r\nif (port_reg & PORTSC_CONFIG_CHANGE)\r\nxdbc_trace("config error change\n");\r\nwritel(port_reg, &xdbc.xdbc_reg->portsc);\r\n}\r\nstatic void xdbc_handle_tx_event(struct xdbc_trb *evt_trb)\r\n{\r\nsize_t remain_length;\r\nu32 comp_code;\r\nint ep_id;\r\ncomp_code = GET_COMP_CODE(le32_to_cpu(evt_trb->field[2]));\r\nremain_length = EVENT_TRB_LEN(le32_to_cpu(evt_trb->field[2]));\r\nep_id = TRB_TO_EP_ID(le32_to_cpu(evt_trb->field[3]));\r\nswitch (comp_code) {\r\ncase COMP_SUCCESS:\r\nremain_length = 0;\r\ncase COMP_SHORT_PACKET:\r\nbreak;\r\ncase COMP_TRB_ERROR:\r\ncase COMP_BABBLE_DETECTED_ERROR:\r\ncase COMP_USB_TRANSACTION_ERROR:\r\ncase COMP_STALL_ERROR:\r\ndefault:\r\nif (ep_id == XDBC_EPID_OUT)\r\nxdbc.flags |= XDBC_FLAGS_OUT_STALL;\r\nif (ep_id == XDBC_EPID_IN)\r\nxdbc.flags |= XDBC_FLAGS_IN_STALL;\r\nxdbc_trace("endpoint %d stalled\n", ep_id);\r\nbreak;\r\n}\r\nif (ep_id == XDBC_EPID_IN) {\r\nxdbc.flags &= ~XDBC_FLAGS_IN_PROCESS;\r\nxdbc_bulk_transfer(NULL, XDBC_MAX_PACKET, true);\r\n} else if (ep_id == XDBC_EPID_OUT) {\r\nxdbc.flags &= ~XDBC_FLAGS_OUT_PROCESS;\r\n} else {\r\nxdbc_trace("invalid endpoint id %d\n", ep_id);\r\n}\r\n}\r\nstatic void xdbc_handle_events(void)\r\n{\r\nstruct xdbc_trb *evt_trb;\r\nbool update_erdp = false;\r\nu32 reg;\r\nu8 cmd;\r\ncmd = read_pci_config_byte(xdbc.bus, xdbc.dev, xdbc.func, PCI_COMMAND);\r\nif (!(cmd & PCI_COMMAND_MASTER)) {\r\ncmd |= PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY;\r\nwrite_pci_config_byte(xdbc.bus, xdbc.dev, xdbc.func, PCI_COMMAND, cmd);\r\n}\r\nif (!(xdbc.flags & XDBC_FLAGS_INITIALIZED))\r\nreturn;\r\nreg = readl(&xdbc.xdbc_reg->control);\r\nif (!(reg & CTRL_DBC_ENABLE)) {\r\nif (xdbc_handle_external_reset()) {\r\nxdbc_trace("failed to recover connection\n");\r\nreturn;\r\n}\r\n}\r\nreg = readl(&xdbc.xdbc_reg->control);\r\nif (reg & CTRL_DBC_RUN_CHANGE) {\r\nwritel(reg, &xdbc.xdbc_reg->control);\r\nif (reg & CTRL_DBC_RUN)\r\nxdbc.flags |= XDBC_FLAGS_CONFIGURED;\r\nelse\r\nxdbc.flags &= ~XDBC_FLAGS_CONFIGURED;\r\n}\r\nreg = readl(&xdbc.xdbc_reg->control);\r\nif (reg & CTRL_HALT_IN_TR) {\r\nxdbc.flags |= XDBC_FLAGS_IN_STALL;\r\n} else {\r\nxdbc.flags &= ~XDBC_FLAGS_IN_STALL;\r\nif (!(xdbc.flags & XDBC_FLAGS_IN_PROCESS))\r\nxdbc_bulk_transfer(NULL, XDBC_MAX_PACKET, true);\r\n}\r\nif (reg & CTRL_HALT_OUT_TR)\r\nxdbc.flags |= XDBC_FLAGS_OUT_STALL;\r\nelse\r\nxdbc.flags &= ~XDBC_FLAGS_OUT_STALL;\r\nevt_trb = xdbc.evt_ring.dequeue;\r\nwhile ((le32_to_cpu(evt_trb->field[3]) & TRB_CYCLE) == xdbc.evt_ring.cycle_state) {\r\nrmb();\r\nswitch ((le32_to_cpu(evt_trb->field[3]) & TRB_TYPE_BITMASK)) {\r\ncase TRB_TYPE(TRB_PORT_STATUS):\r\nxdbc_handle_port_status(evt_trb);\r\nbreak;\r\ncase TRB_TYPE(TRB_TRANSFER):\r\nxdbc_handle_tx_event(evt_trb);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n++(xdbc.evt_ring.dequeue);\r\nif (xdbc.evt_ring.dequeue == &xdbc.evt_seg.trbs[TRBS_PER_SEGMENT]) {\r\nxdbc.evt_ring.dequeue = xdbc.evt_seg.trbs;\r\nxdbc.evt_ring.cycle_state ^= 1;\r\n}\r\nevt_trb = xdbc.evt_ring.dequeue;\r\nupdate_erdp = true;\r\n}\r\nif (update_erdp)\r\nxdbc_write64(__pa(xdbc.evt_ring.dequeue), &xdbc.xdbc_reg->erdp);\r\n}\r\nstatic int xdbc_bulk_write(const char *bytes, int size)\r\n{\r\nint ret, timeout = 0;\r\nunsigned long flags;\r\nretry:\r\nif (in_nmi()) {\r\nif (!raw_spin_trylock_irqsave(&xdbc.lock, flags))\r\nreturn -EAGAIN;\r\n} else {\r\nraw_spin_lock_irqsave(&xdbc.lock, flags);\r\n}\r\nxdbc_handle_events();\r\nif ((xdbc.flags & XDBC_FLAGS_OUT_PROCESS) && (timeout < 2000000)) {\r\nraw_spin_unlock_irqrestore(&xdbc.lock, flags);\r\nudelay(100);\r\ntimeout += 100;\r\ngoto retry;\r\n}\r\nif (xdbc.flags & XDBC_FLAGS_OUT_PROCESS) {\r\nraw_spin_unlock_irqrestore(&xdbc.lock, flags);\r\nxdbc_trace("previous transfer not completed yet\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nret = xdbc_bulk_transfer((void *)bytes, size, false);\r\nraw_spin_unlock_irqrestore(&xdbc.lock, flags);\r\nreturn ret;\r\n}\r\nstatic void early_xdbc_write(struct console *con, const char *str, u32 n)\r\n{\r\nstatic char buf[XDBC_MAX_PACKET];\r\nint chunk, ret;\r\nint use_cr = 0;\r\nif (!xdbc.xdbc_reg)\r\nreturn;\r\nmemset(buf, 0, XDBC_MAX_PACKET);\r\nwhile (n > 0) {\r\nfor (chunk = 0; chunk < XDBC_MAX_PACKET && n > 0; str++, chunk++, n--) {\r\nif (!use_cr && *str == '\n') {\r\nuse_cr = 1;\r\nbuf[chunk] = '\r';\r\nstr--;\r\nn++;\r\ncontinue;\r\n}\r\nif (use_cr)\r\nuse_cr = 0;\r\nbuf[chunk] = *str;\r\n}\r\nif (chunk > 0) {\r\nret = xdbc_bulk_write(buf, chunk);\r\nif (ret < 0)\r\nxdbc_trace("missed message {%s}\n", buf);\r\n}\r\n}\r\n}\r\nvoid __init early_xdbc_register_console(void)\r\n{\r\nif (early_console)\r\nreturn;\r\nearly_console = &early_xdbc_console;\r\nif (early_console_keep)\r\nearly_console->flags &= ~CON_BOOT;\r\nelse\r\nearly_console->flags |= CON_BOOT;\r\nregister_console(early_console);\r\n}\r\nstatic void xdbc_unregister_console(void)\r\n{\r\nif (early_xdbc_console.flags & CON_ENABLED)\r\nunregister_console(&early_xdbc_console);\r\n}\r\nstatic int xdbc_scrub_function(void *ptr)\r\n{\r\nunsigned long flags;\r\nwhile (true) {\r\nraw_spin_lock_irqsave(&xdbc.lock, flags);\r\nxdbc_handle_events();\r\nif (!(xdbc.flags & XDBC_FLAGS_INITIALIZED)) {\r\nraw_spin_unlock_irqrestore(&xdbc.lock, flags);\r\nbreak;\r\n}\r\nraw_spin_unlock_irqrestore(&xdbc.lock, flags);\r\nschedule_timeout_interruptible(1);\r\n}\r\nxdbc_unregister_console();\r\nwritel(0, &xdbc.xdbc_reg->control);\r\nxdbc_trace("dbc scrub function exits\n");\r\nreturn 0;\r\n}\r\nstatic int __init xdbc_init(void)\r\n{\r\nunsigned long flags;\r\nvoid __iomem *base;\r\nint ret = 0;\r\nu32 offset;\r\nif (!(xdbc.flags & XDBC_FLAGS_INITIALIZED))\r\nreturn 0;\r\nif (early_xdbc_console.index == -1 ||\r\n(early_xdbc_console.flags & CON_BOOT)) {\r\nxdbc_trace("hardware not used anymore\n");\r\ngoto free_and_quit;\r\n}\r\nbase = ioremap_nocache(xdbc.xhci_start, xdbc.xhci_length);\r\nif (!base) {\r\nxdbc_trace("failed to remap the io address\n");\r\nret = -ENOMEM;\r\ngoto free_and_quit;\r\n}\r\nraw_spin_lock_irqsave(&xdbc.lock, flags);\r\nearly_iounmap(xdbc.xhci_base, xdbc.xhci_length);\r\nxdbc.xhci_base = base;\r\noffset = xhci_find_next_ext_cap(xdbc.xhci_base, 0, XHCI_EXT_CAPS_DEBUG);\r\nxdbc.xdbc_reg = (struct xdbc_regs __iomem *)(xdbc.xhci_base + offset);\r\nraw_spin_unlock_irqrestore(&xdbc.lock, flags);\r\nkthread_run(xdbc_scrub_function, NULL, "%s", "xdbc");\r\nreturn 0;\r\nfree_and_quit:\r\nxdbc_free_ring(&xdbc.evt_ring);\r\nxdbc_free_ring(&xdbc.out_ring);\r\nxdbc_free_ring(&xdbc.in_ring);\r\nfree_bootmem(xdbc.table_dma, PAGE_SIZE);\r\nfree_bootmem(xdbc.out_dma, PAGE_SIZE);\r\nwritel(0, &xdbc.xdbc_reg->control);\r\nearly_iounmap(xdbc.xhci_base, xdbc.xhci_length);\r\nreturn ret;\r\n}
