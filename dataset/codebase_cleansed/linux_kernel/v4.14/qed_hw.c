int qed_ptt_pool_alloc(struct qed_hwfn *p_hwfn)\r\n{\r\nstruct qed_ptt_pool *p_pool = kmalloc(sizeof(*p_pool), GFP_KERNEL);\r\nint i;\r\nif (!p_pool)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&p_pool->free_list);\r\nfor (i = 0; i < PXP_EXTERNAL_BAR_PF_WINDOW_NUM; i++) {\r\np_pool->ptts[i].idx = i;\r\np_pool->ptts[i].pxp.offset = QED_BAR_INVALID_OFFSET;\r\np_pool->ptts[i].pxp.pretend.control = 0;\r\np_pool->ptts[i].hwfn_id = p_hwfn->my_id;\r\nif (i >= RESERVED_PTT_MAX)\r\nlist_add(&p_pool->ptts[i].list_entry,\r\n&p_pool->free_list);\r\n}\r\np_hwfn->p_ptt_pool = p_pool;\r\nspin_lock_init(&p_pool->lock);\r\nreturn 0;\r\n}\r\nvoid qed_ptt_invalidate(struct qed_hwfn *p_hwfn)\r\n{\r\nstruct qed_ptt *p_ptt;\r\nint i;\r\nfor (i = 0; i < PXP_EXTERNAL_BAR_PF_WINDOW_NUM; i++) {\r\np_ptt = &p_hwfn->p_ptt_pool->ptts[i];\r\np_ptt->pxp.offset = QED_BAR_INVALID_OFFSET;\r\n}\r\n}\r\nvoid qed_ptt_pool_free(struct qed_hwfn *p_hwfn)\r\n{\r\nkfree(p_hwfn->p_ptt_pool);\r\np_hwfn->p_ptt_pool = NULL;\r\n}\r\nstruct qed_ptt *qed_ptt_acquire(struct qed_hwfn *p_hwfn)\r\n{\r\nstruct qed_ptt *p_ptt;\r\nunsigned int i;\r\nfor (i = 0; i < QED_BAR_ACQUIRE_TIMEOUT; i++) {\r\nspin_lock_bh(&p_hwfn->p_ptt_pool->lock);\r\nif (!list_empty(&p_hwfn->p_ptt_pool->free_list)) {\r\np_ptt = list_first_entry(&p_hwfn->p_ptt_pool->free_list,\r\nstruct qed_ptt, list_entry);\r\nlist_del(&p_ptt->list_entry);\r\nspin_unlock_bh(&p_hwfn->p_ptt_pool->lock);\r\nDP_VERBOSE(p_hwfn, NETIF_MSG_HW,\r\n"allocated ptt %d\n", p_ptt->idx);\r\nreturn p_ptt;\r\n}\r\nspin_unlock_bh(&p_hwfn->p_ptt_pool->lock);\r\nusleep_range(1000, 2000);\r\n}\r\nDP_NOTICE(p_hwfn, "PTT acquire timeout - failed to allocate PTT\n");\r\nreturn NULL;\r\n}\r\nvoid qed_ptt_release(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt)\r\n{\r\nspin_lock_bh(&p_hwfn->p_ptt_pool->lock);\r\nlist_add(&p_ptt->list_entry, &p_hwfn->p_ptt_pool->free_list);\r\nspin_unlock_bh(&p_hwfn->p_ptt_pool->lock);\r\n}\r\nu32 qed_ptt_get_hw_addr(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt)\r\n{\r\nreturn le32_to_cpu(p_ptt->pxp.offset) << 2;\r\n}\r\nstatic u32 qed_ptt_config_addr(struct qed_ptt *p_ptt)\r\n{\r\nreturn PXP_PF_WINDOW_ADMIN_PER_PF_START +\r\np_ptt->idx * sizeof(struct pxp_ptt_entry);\r\n}\r\nu32 qed_ptt_get_bar_addr(struct qed_ptt *p_ptt)\r\n{\r\nreturn PXP_EXTERNAL_BAR_PF_WINDOW_START +\r\np_ptt->idx * PXP_EXTERNAL_BAR_PF_WINDOW_SINGLE_SIZE;\r\n}\r\nvoid qed_ptt_set_win(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt, u32 new_hw_addr)\r\n{\r\nu32 prev_hw_addr;\r\nprev_hw_addr = qed_ptt_get_hw_addr(p_hwfn, p_ptt);\r\nif (new_hw_addr == prev_hw_addr)\r\nreturn;\r\nDP_VERBOSE(p_hwfn, NETIF_MSG_HW,\r\n"Updating PTT entry %d to offset 0x%x\n",\r\np_ptt->idx, new_hw_addr);\r\np_ptt->pxp.offset = cpu_to_le32(new_hw_addr >> 2);\r\nREG_WR(p_hwfn,\r\nqed_ptt_config_addr(p_ptt) +\r\noffsetof(struct pxp_ptt_entry, offset),\r\nle32_to_cpu(p_ptt->pxp.offset));\r\n}\r\nstatic u32 qed_set_ptt(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt, u32 hw_addr)\r\n{\r\nu32 win_hw_addr = qed_ptt_get_hw_addr(p_hwfn, p_ptt);\r\nu32 offset;\r\noffset = hw_addr - win_hw_addr;\r\nif (p_ptt->hwfn_id != p_hwfn->my_id)\r\nDP_NOTICE(p_hwfn,\r\n"ptt[%d] of hwfn[%02x] is used by hwfn[%02x]!\n",\r\np_ptt->idx, p_ptt->hwfn_id, p_hwfn->my_id);\r\nif (hw_addr < win_hw_addr ||\r\noffset >= PXP_EXTERNAL_BAR_PF_WINDOW_SINGLE_SIZE) {\r\nqed_ptt_set_win(p_hwfn, p_ptt, hw_addr);\r\noffset = 0;\r\n}\r\nreturn qed_ptt_get_bar_addr(p_ptt) + offset;\r\n}\r\nstruct qed_ptt *qed_get_reserved_ptt(struct qed_hwfn *p_hwfn,\r\nenum reserved_ptts ptt_idx)\r\n{\r\nif (ptt_idx >= RESERVED_PTT_MAX) {\r\nDP_NOTICE(p_hwfn,\r\n"Requested PTT %d is out of range\n", ptt_idx);\r\nreturn NULL;\r\n}\r\nreturn &p_hwfn->p_ptt_pool->ptts[ptt_idx];\r\n}\r\nvoid qed_wr(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 hw_addr, u32 val)\r\n{\r\nu32 bar_addr = qed_set_ptt(p_hwfn, p_ptt, hw_addr);\r\nREG_WR(p_hwfn, bar_addr, val);\r\nDP_VERBOSE(p_hwfn, NETIF_MSG_HW,\r\n"bar_addr 0x%x, hw_addr 0x%x, val 0x%x\n",\r\nbar_addr, hw_addr, val);\r\n}\r\nu32 qed_rd(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 hw_addr)\r\n{\r\nu32 bar_addr = qed_set_ptt(p_hwfn, p_ptt, hw_addr);\r\nu32 val = REG_RD(p_hwfn, bar_addr);\r\nDP_VERBOSE(p_hwfn, NETIF_MSG_HW,\r\n"bar_addr 0x%x, hw_addr 0x%x, val 0x%x\n",\r\nbar_addr, hw_addr, val);\r\nreturn val;\r\n}\r\nstatic void qed_memcpy_hw(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nvoid *addr, u32 hw_addr, size_t n, bool to_device)\r\n{\r\nu32 dw_count, *host_addr, hw_offset;\r\nsize_t quota, done = 0;\r\nu32 __iomem *reg_addr;\r\nwhile (done < n) {\r\nquota = min_t(size_t, n - done,\r\nPXP_EXTERNAL_BAR_PF_WINDOW_SINGLE_SIZE);\r\nif (IS_PF(p_hwfn->cdev)) {\r\nqed_ptt_set_win(p_hwfn, p_ptt, hw_addr + done);\r\nhw_offset = qed_ptt_get_bar_addr(p_ptt);\r\n} else {\r\nhw_offset = hw_addr + done;\r\n}\r\ndw_count = quota / 4;\r\nhost_addr = (u32 *)((u8 *)addr + done);\r\nreg_addr = (u32 __iomem *)REG_ADDR(p_hwfn, hw_offset);\r\nif (to_device)\r\nwhile (dw_count--)\r\nDIRECT_REG_WR(reg_addr++, *host_addr++);\r\nelse\r\nwhile (dw_count--)\r\n*host_addr++ = DIRECT_REG_RD(reg_addr++);\r\ndone += quota;\r\n}\r\n}\r\nvoid qed_memcpy_from(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt, void *dest, u32 hw_addr, size_t n)\r\n{\r\nDP_VERBOSE(p_hwfn, NETIF_MSG_HW,\r\n"hw_addr 0x%x, dest %p hw_addr 0x%x, size %lu\n",\r\nhw_addr, dest, hw_addr, (unsigned long)n);\r\nqed_memcpy_hw(p_hwfn, p_ptt, dest, hw_addr, n, false);\r\n}\r\nvoid qed_memcpy_to(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt, u32 hw_addr, void *src, size_t n)\r\n{\r\nDP_VERBOSE(p_hwfn, NETIF_MSG_HW,\r\n"hw_addr 0x%x, hw_addr 0x%x, src %p size %lu\n",\r\nhw_addr, hw_addr, src, (unsigned long)n);\r\nqed_memcpy_hw(p_hwfn, p_ptt, src, hw_addr, n, true);\r\n}\r\nvoid qed_fid_pretend(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt, u16 fid)\r\n{\r\nu16 control = 0;\r\nSET_FIELD(control, PXP_PRETEND_CMD_IS_CONCRETE, 1);\r\nSET_FIELD(control, PXP_PRETEND_CMD_PRETEND_FUNCTION, 1);\r\nSET_FIELD(control, PXP_PRETEND_CMD_PORT, 0);\r\nSET_FIELD(control, PXP_PRETEND_CMD_USE_PORT, 0);\r\nSET_FIELD(control, PXP_PRETEND_CMD_PRETEND_PORT, 1);\r\nif (!GET_FIELD(fid, PXP_CONCRETE_FID_VFVALID))\r\nfid = GET_FIELD(fid, PXP_CONCRETE_FID_PFID);\r\np_ptt->pxp.pretend.control = cpu_to_le16(control);\r\np_ptt->pxp.pretend.fid.concrete_fid.fid = cpu_to_le16(fid);\r\nREG_WR(p_hwfn,\r\nqed_ptt_config_addr(p_ptt) +\r\noffsetof(struct pxp_ptt_entry, pretend),\r\n*(u32 *)&p_ptt->pxp.pretend);\r\n}\r\nvoid qed_port_pretend(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt, u8 port_id)\r\n{\r\nu16 control = 0;\r\nSET_FIELD(control, PXP_PRETEND_CMD_PORT, port_id);\r\nSET_FIELD(control, PXP_PRETEND_CMD_USE_PORT, 1);\r\nSET_FIELD(control, PXP_PRETEND_CMD_PRETEND_PORT, 1);\r\np_ptt->pxp.pretend.control = cpu_to_le16(control);\r\nREG_WR(p_hwfn,\r\nqed_ptt_config_addr(p_ptt) +\r\noffsetof(struct pxp_ptt_entry, pretend),\r\n*(u32 *)&p_ptt->pxp.pretend);\r\n}\r\nvoid qed_port_unpretend(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt)\r\n{\r\nu16 control = 0;\r\nSET_FIELD(control, PXP_PRETEND_CMD_PORT, 0);\r\nSET_FIELD(control, PXP_PRETEND_CMD_USE_PORT, 0);\r\nSET_FIELD(control, PXP_PRETEND_CMD_PRETEND_PORT, 1);\r\np_ptt->pxp.pretend.control = cpu_to_le16(control);\r\nREG_WR(p_hwfn,\r\nqed_ptt_config_addr(p_ptt) +\r\noffsetof(struct pxp_ptt_entry, pretend),\r\n*(u32 *)&p_ptt->pxp.pretend);\r\n}\r\nu32 qed_vfid_to_concrete(struct qed_hwfn *p_hwfn, u8 vfid)\r\n{\r\nu32 concrete_fid = 0;\r\nSET_FIELD(concrete_fid, PXP_CONCRETE_FID_PFID, p_hwfn->rel_pf_id);\r\nSET_FIELD(concrete_fid, PXP_CONCRETE_FID_VFID, vfid);\r\nSET_FIELD(concrete_fid, PXP_CONCRETE_FID_VFVALID, 1);\r\nreturn concrete_fid;\r\n}\r\nstatic void qed_dmae_opcode(struct qed_hwfn *p_hwfn,\r\nconst u8 is_src_type_grc,\r\nconst u8 is_dst_type_grc,\r\nstruct qed_dmae_params *p_params)\r\n{\r\nu16 opcode_b = 0;\r\nu32 opcode = 0;\r\nopcode |= (is_src_type_grc ? DMAE_CMD_SRC_MASK_GRC\r\n: DMAE_CMD_SRC_MASK_PCIE) <<\r\nDMAE_CMD_SRC_SHIFT;\r\nopcode |= ((p_hwfn->rel_pf_id & DMAE_CMD_SRC_PF_ID_MASK) <<\r\nDMAE_CMD_SRC_PF_ID_SHIFT);\r\nopcode |= (is_dst_type_grc ? DMAE_CMD_DST_MASK_GRC\r\n: DMAE_CMD_DST_MASK_PCIE) <<\r\nDMAE_CMD_DST_SHIFT;\r\nopcode |= ((p_hwfn->rel_pf_id & DMAE_CMD_DST_PF_ID_MASK) <<\r\nDMAE_CMD_DST_PF_ID_SHIFT);\r\nopcode |= (DMAE_CMD_COMP_WORD_EN_MASK << DMAE_CMD_COMP_WORD_EN_SHIFT);\r\nopcode |= (DMAE_CMD_SRC_ADDR_RESET_MASK <<\r\nDMAE_CMD_SRC_ADDR_RESET_SHIFT);\r\nif (p_params->flags & QED_DMAE_FLAG_COMPLETION_DST)\r\nopcode |= (1 << DMAE_CMD_COMP_FUNC_SHIFT);\r\nopcode |= (DMAE_CMD_ENDIANITY << DMAE_CMD_ENDIANITY_MODE_SHIFT);\r\nopcode |= ((p_hwfn->port_id) << DMAE_CMD_PORT_ID_SHIFT);\r\nopcode |= (DMAE_CMD_SRC_ADDR_RESET_MASK <<\r\nDMAE_CMD_SRC_ADDR_RESET_SHIFT);\r\nopcode |= (DMAE_CMD_DST_ADDR_RESET_MASK <<\r\nDMAE_CMD_DST_ADDR_RESET_SHIFT);\r\nif (p_params->flags & QED_DMAE_FLAG_VF_SRC) {\r\nopcode |= 1 << DMAE_CMD_SRC_VF_ID_VALID_SHIFT;\r\nopcode_b |= p_params->src_vfid << DMAE_CMD_SRC_VF_ID_SHIFT;\r\n} else {\r\nopcode_b |= DMAE_CMD_SRC_VF_ID_MASK <<\r\nDMAE_CMD_SRC_VF_ID_SHIFT;\r\n}\r\nif (p_params->flags & QED_DMAE_FLAG_VF_DST) {\r\nopcode |= 1 << DMAE_CMD_DST_VF_ID_VALID_SHIFT;\r\nopcode_b |= p_params->dst_vfid << DMAE_CMD_DST_VF_ID_SHIFT;\r\n} else {\r\nopcode_b |= DMAE_CMD_DST_VF_ID_MASK << DMAE_CMD_DST_VF_ID_SHIFT;\r\n}\r\np_hwfn->dmae_info.p_dmae_cmd->opcode = cpu_to_le32(opcode);\r\np_hwfn->dmae_info.p_dmae_cmd->opcode_b = cpu_to_le16(opcode_b);\r\n}\r\nu32 qed_dmae_idx_to_go_cmd(u8 idx)\r\n{\r\nreturn DMAE_REG_GO_C0 + (idx << 2);\r\n}\r\nstatic int qed_dmae_post_command(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt)\r\n{\r\nstruct dmae_cmd *p_command = p_hwfn->dmae_info.p_dmae_cmd;\r\nu8 idx_cmd = p_hwfn->dmae_info.channel, i;\r\nint qed_status = 0;\r\nif ((((!p_command->dst_addr_lo) && (!p_command->dst_addr_hi)) ||\r\n((!p_command->src_addr_lo) && (!p_command->src_addr_hi)))) {\r\nDP_NOTICE(p_hwfn,\r\n"source or destination address 0 idx_cmd=%d\n"\r\n"opcode = [0x%08x,0x%04x] len=0x%x src=0x%x:%x dst=0x%x:%x\n",\r\nidx_cmd,\r\nle32_to_cpu(p_command->opcode),\r\nle16_to_cpu(p_command->opcode_b),\r\nle16_to_cpu(p_command->length_dw),\r\nle32_to_cpu(p_command->src_addr_hi),\r\nle32_to_cpu(p_command->src_addr_lo),\r\nle32_to_cpu(p_command->dst_addr_hi),\r\nle32_to_cpu(p_command->dst_addr_lo));\r\nreturn -EINVAL;\r\n}\r\nDP_VERBOSE(p_hwfn,\r\nNETIF_MSG_HW,\r\n"Posting DMAE command [idx %d]: opcode = [0x%08x,0x%04x] len=0x%x src=0x%x:%x dst=0x%x:%x\n",\r\nidx_cmd,\r\nle32_to_cpu(p_command->opcode),\r\nle16_to_cpu(p_command->opcode_b),\r\nle16_to_cpu(p_command->length_dw),\r\nle32_to_cpu(p_command->src_addr_hi),\r\nle32_to_cpu(p_command->src_addr_lo),\r\nle32_to_cpu(p_command->dst_addr_hi),\r\nle32_to_cpu(p_command->dst_addr_lo));\r\nfor (i = 0; i < DMAE_CMD_SIZE; i++) {\r\nu32 data = (i < DMAE_CMD_SIZE_TO_FILL) ?\r\n*(((u32 *)p_command) + i) : 0;\r\nqed_wr(p_hwfn, p_ptt,\r\nDMAE_REG_CMD_MEM +\r\n(idx_cmd * DMAE_CMD_SIZE * sizeof(u32)) +\r\n(i * sizeof(u32)), data);\r\n}\r\nqed_wr(p_hwfn, p_ptt, qed_dmae_idx_to_go_cmd(idx_cmd), DMAE_GO_VALUE);\r\nreturn qed_status;\r\n}\r\nint qed_dmae_info_alloc(struct qed_hwfn *p_hwfn)\r\n{\r\ndma_addr_t *p_addr = &p_hwfn->dmae_info.completion_word_phys_addr;\r\nstruct dmae_cmd **p_cmd = &p_hwfn->dmae_info.p_dmae_cmd;\r\nu32 **p_buff = &p_hwfn->dmae_info.p_intermediate_buffer;\r\nu32 **p_comp = &p_hwfn->dmae_info.p_completion_word;\r\n*p_comp = dma_alloc_coherent(&p_hwfn->cdev->pdev->dev,\r\nsizeof(u32), p_addr, GFP_KERNEL);\r\nif (!*p_comp)\r\ngoto err;\r\np_addr = &p_hwfn->dmae_info.dmae_cmd_phys_addr;\r\n*p_cmd = dma_alloc_coherent(&p_hwfn->cdev->pdev->dev,\r\nsizeof(struct dmae_cmd),\r\np_addr, GFP_KERNEL);\r\nif (!*p_cmd)\r\ngoto err;\r\np_addr = &p_hwfn->dmae_info.intermediate_buffer_phys_addr;\r\n*p_buff = dma_alloc_coherent(&p_hwfn->cdev->pdev->dev,\r\nsizeof(u32) * DMAE_MAX_RW_SIZE,\r\np_addr, GFP_KERNEL);\r\nif (!*p_buff)\r\ngoto err;\r\np_hwfn->dmae_info.channel = p_hwfn->rel_pf_id;\r\nreturn 0;\r\nerr:\r\nqed_dmae_info_free(p_hwfn);\r\nreturn -ENOMEM;\r\n}\r\nvoid qed_dmae_info_free(struct qed_hwfn *p_hwfn)\r\n{\r\ndma_addr_t p_phys;\r\nmutex_lock(&p_hwfn->dmae_info.mutex);\r\nif (p_hwfn->dmae_info.p_completion_word) {\r\np_phys = p_hwfn->dmae_info.completion_word_phys_addr;\r\ndma_free_coherent(&p_hwfn->cdev->pdev->dev,\r\nsizeof(u32),\r\np_hwfn->dmae_info.p_completion_word, p_phys);\r\np_hwfn->dmae_info.p_completion_word = NULL;\r\n}\r\nif (p_hwfn->dmae_info.p_dmae_cmd) {\r\np_phys = p_hwfn->dmae_info.dmae_cmd_phys_addr;\r\ndma_free_coherent(&p_hwfn->cdev->pdev->dev,\r\nsizeof(struct dmae_cmd),\r\np_hwfn->dmae_info.p_dmae_cmd, p_phys);\r\np_hwfn->dmae_info.p_dmae_cmd = NULL;\r\n}\r\nif (p_hwfn->dmae_info.p_intermediate_buffer) {\r\np_phys = p_hwfn->dmae_info.intermediate_buffer_phys_addr;\r\ndma_free_coherent(&p_hwfn->cdev->pdev->dev,\r\nsizeof(u32) * DMAE_MAX_RW_SIZE,\r\np_hwfn->dmae_info.p_intermediate_buffer,\r\np_phys);\r\np_hwfn->dmae_info.p_intermediate_buffer = NULL;\r\n}\r\nmutex_unlock(&p_hwfn->dmae_info.mutex);\r\n}\r\nstatic int qed_dmae_operation_wait(struct qed_hwfn *p_hwfn)\r\n{\r\nu32 wait_cnt_limit = 10000, wait_cnt = 0;\r\nint qed_status = 0;\r\nbarrier();\r\nwhile (*p_hwfn->dmae_info.p_completion_word != DMAE_COMPLETION_VAL) {\r\nudelay(DMAE_MIN_WAIT_TIME);\r\nif (++wait_cnt > wait_cnt_limit) {\r\nDP_NOTICE(p_hwfn->cdev,\r\n"Timed-out waiting for operation to complete. Completion word is 0x%08x expected 0x%08x.\n",\r\n*p_hwfn->dmae_info.p_completion_word,\r\nDMAE_COMPLETION_VAL);\r\nqed_status = -EBUSY;\r\nbreak;\r\n}\r\nbarrier();\r\n}\r\nif (qed_status == 0)\r\n*p_hwfn->dmae_info.p_completion_word = 0;\r\nreturn qed_status;\r\n}\r\nstatic int qed_dmae_execute_sub_operation(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu64 src_addr,\r\nu64 dst_addr,\r\nu8 src_type,\r\nu8 dst_type,\r\nu32 length_dw)\r\n{\r\ndma_addr_t phys = p_hwfn->dmae_info.intermediate_buffer_phys_addr;\r\nstruct dmae_cmd *cmd = p_hwfn->dmae_info.p_dmae_cmd;\r\nint qed_status = 0;\r\nswitch (src_type) {\r\ncase QED_DMAE_ADDRESS_GRC:\r\ncase QED_DMAE_ADDRESS_HOST_PHYS:\r\ncmd->src_addr_hi = cpu_to_le32(upper_32_bits(src_addr));\r\ncmd->src_addr_lo = cpu_to_le32(lower_32_bits(src_addr));\r\nbreak;\r\ncase QED_DMAE_ADDRESS_HOST_VIRT:\r\ncmd->src_addr_hi = cpu_to_le32(upper_32_bits(phys));\r\ncmd->src_addr_lo = cpu_to_le32(lower_32_bits(phys));\r\nmemcpy(&p_hwfn->dmae_info.p_intermediate_buffer[0],\r\n(void *)(uintptr_t)src_addr,\r\nlength_dw * sizeof(u32));\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (dst_type) {\r\ncase QED_DMAE_ADDRESS_GRC:\r\ncase QED_DMAE_ADDRESS_HOST_PHYS:\r\ncmd->dst_addr_hi = cpu_to_le32(upper_32_bits(dst_addr));\r\ncmd->dst_addr_lo = cpu_to_le32(lower_32_bits(dst_addr));\r\nbreak;\r\ncase QED_DMAE_ADDRESS_HOST_VIRT:\r\ncmd->dst_addr_hi = cpu_to_le32(upper_32_bits(phys));\r\ncmd->dst_addr_lo = cpu_to_le32(lower_32_bits(phys));\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncmd->length_dw = cpu_to_le16((u16)length_dw);\r\nqed_dmae_post_command(p_hwfn, p_ptt);\r\nqed_status = qed_dmae_operation_wait(p_hwfn);\r\nif (qed_status) {\r\nDP_NOTICE(p_hwfn,\r\n"qed_dmae_host2grc: Wait Failed. source_addr 0x%llx, grc_addr 0x%llx, size_in_dwords 0x%x\n",\r\nsrc_addr, dst_addr, length_dw);\r\nreturn qed_status;\r\n}\r\nif (dst_type == QED_DMAE_ADDRESS_HOST_VIRT)\r\nmemcpy((void *)(uintptr_t)(dst_addr),\r\n&p_hwfn->dmae_info.p_intermediate_buffer[0],\r\nlength_dw * sizeof(u32));\r\nreturn 0;\r\n}\r\nstatic int qed_dmae_execute_command(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu64 src_addr, u64 dst_addr,\r\nu8 src_type, u8 dst_type,\r\nu32 size_in_dwords,\r\nstruct qed_dmae_params *p_params)\r\n{\r\ndma_addr_t phys = p_hwfn->dmae_info.completion_word_phys_addr;\r\nu16 length_cur = 0, i = 0, cnt_split = 0, length_mod = 0;\r\nstruct dmae_cmd *cmd = p_hwfn->dmae_info.p_dmae_cmd;\r\nu64 src_addr_split = 0, dst_addr_split = 0;\r\nu16 length_limit = DMAE_MAX_RW_SIZE;\r\nint qed_status = 0;\r\nu32 offset = 0;\r\nqed_dmae_opcode(p_hwfn,\r\n(src_type == QED_DMAE_ADDRESS_GRC),\r\n(dst_type == QED_DMAE_ADDRESS_GRC),\r\np_params);\r\ncmd->comp_addr_lo = cpu_to_le32(lower_32_bits(phys));\r\ncmd->comp_addr_hi = cpu_to_le32(upper_32_bits(phys));\r\ncmd->comp_val = cpu_to_le32(DMAE_COMPLETION_VAL);\r\ncnt_split = size_in_dwords / length_limit;\r\nlength_mod = size_in_dwords % length_limit;\r\nsrc_addr_split = src_addr;\r\ndst_addr_split = dst_addr;\r\nfor (i = 0; i <= cnt_split; i++) {\r\noffset = length_limit * i;\r\nif (!(p_params->flags & QED_DMAE_FLAG_RW_REPL_SRC)) {\r\nif (src_type == QED_DMAE_ADDRESS_GRC)\r\nsrc_addr_split = src_addr + offset;\r\nelse\r\nsrc_addr_split = src_addr + (offset * 4);\r\n}\r\nif (dst_type == QED_DMAE_ADDRESS_GRC)\r\ndst_addr_split = dst_addr + offset;\r\nelse\r\ndst_addr_split = dst_addr + (offset * 4);\r\nlength_cur = (cnt_split == i) ? length_mod : length_limit;\r\nif (!length_cur)\r\ncontinue;\r\nqed_status = qed_dmae_execute_sub_operation(p_hwfn,\r\np_ptt,\r\nsrc_addr_split,\r\ndst_addr_split,\r\nsrc_type,\r\ndst_type,\r\nlength_cur);\r\nif (qed_status) {\r\nDP_NOTICE(p_hwfn,\r\n"qed_dmae_execute_sub_operation Failed with error 0x%x. source_addr 0x%llx, destination addr 0x%llx, size_in_dwords 0x%x\n",\r\nqed_status, src_addr, dst_addr, length_cur);\r\nbreak;\r\n}\r\n}\r\nreturn qed_status;\r\n}\r\nint qed_dmae_host2grc(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu64 source_addr, u32 grc_addr, u32 size_in_dwords, u32 flags)\r\n{\r\nu32 grc_addr_in_dw = grc_addr / sizeof(u32);\r\nstruct qed_dmae_params params;\r\nint rc;\r\nmemset(&params, 0, sizeof(struct qed_dmae_params));\r\nparams.flags = flags;\r\nmutex_lock(&p_hwfn->dmae_info.mutex);\r\nrc = qed_dmae_execute_command(p_hwfn, p_ptt, source_addr,\r\ngrc_addr_in_dw,\r\nQED_DMAE_ADDRESS_HOST_VIRT,\r\nQED_DMAE_ADDRESS_GRC,\r\nsize_in_dwords, &params);\r\nmutex_unlock(&p_hwfn->dmae_info.mutex);\r\nreturn rc;\r\n}\r\nint qed_dmae_grc2host(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 grc_addr,\r\ndma_addr_t dest_addr, u32 size_in_dwords, u32 flags)\r\n{\r\nu32 grc_addr_in_dw = grc_addr / sizeof(u32);\r\nstruct qed_dmae_params params;\r\nint rc;\r\nmemset(&params, 0, sizeof(struct qed_dmae_params));\r\nparams.flags = flags;\r\nmutex_lock(&p_hwfn->dmae_info.mutex);\r\nrc = qed_dmae_execute_command(p_hwfn, p_ptt, grc_addr_in_dw,\r\ndest_addr, QED_DMAE_ADDRESS_GRC,\r\nQED_DMAE_ADDRESS_HOST_VIRT,\r\nsize_in_dwords, &params);\r\nmutex_unlock(&p_hwfn->dmae_info.mutex);\r\nreturn rc;\r\n}\r\nint qed_dmae_host2host(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\ndma_addr_t source_addr,\r\ndma_addr_t dest_addr,\r\nu32 size_in_dwords, struct qed_dmae_params *p_params)\r\n{\r\nint rc;\r\nmutex_lock(&(p_hwfn->dmae_info.mutex));\r\nrc = qed_dmae_execute_command(p_hwfn, p_ptt, source_addr,\r\ndest_addr,\r\nQED_DMAE_ADDRESS_HOST_PHYS,\r\nQED_DMAE_ADDRESS_HOST_PHYS,\r\nsize_in_dwords, p_params);\r\nmutex_unlock(&(p_hwfn->dmae_info.mutex));\r\nreturn rc;\r\n}
