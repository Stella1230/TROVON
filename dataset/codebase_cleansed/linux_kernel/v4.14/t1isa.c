static int t1_detectandinit(unsigned int base, unsigned irq, int cardnr)\r\n{\r\nunsigned char cregs[8];\r\nunsigned char reverse_cardnr;\r\nunsigned char dummy;\r\nint i;\r\nreverse_cardnr = ((cardnr & 0x01) << 3) | ((cardnr & 0x02) << 1)\r\n| ((cardnr & 0x04) >> 1) | ((cardnr & 0x08) >> 3);\r\ncregs[0] = (HEMA_VERSION_ID << 4) | (reverse_cardnr & 0xf);\r\ncregs[1] = 0x00;\r\ncregs[2] = 0x05;\r\ncregs[3] = 0;\r\ncregs[4] = 0x11;\r\ncregs[5] = hema_irq_table[irq & 0xf];\r\ncregs[6] = 0;\r\ncregs[7] = 0;\r\nt1outp(base, T1_RESETBOARD, 0xf);\r\nmdelay(100);\r\ndummy = t1inp(base, T1_FASTLINK + T1_OUTSTAT);\r\ndummy = (base >> 4) & 0xff;\r\nfor (i = 1; i <= 0xf; i++) t1outp(base, i, dummy);\r\nt1outp(base, HEMA_PAL_ID & 0xf, dummy);\r\nt1outp(base, HEMA_PAL_ID >> 4, cregs[0]);\r\nfor (i = 1; i < 7; i++) t1outp(base, 0, cregs[i]);\r\nt1outp(base, ((base >> 4)) & 0x3, cregs[7]);\r\nmdelay(100);\r\nt1outp(base, T1_FASTLINK + T1_RESETLINK, 0);\r\nt1outp(base, T1_SLOWLINK + T1_RESETLINK, 0);\r\nmdelay(10);\r\nt1outp(base, T1_FASTLINK + T1_RESETLINK, 1);\r\nt1outp(base, T1_SLOWLINK + T1_RESETLINK, 1);\r\nmdelay(100);\r\nt1outp(base, T1_FASTLINK + T1_RESETLINK, 0);\r\nt1outp(base, T1_SLOWLINK + T1_RESETLINK, 0);\r\nmdelay(10);\r\nt1outp(base, T1_FASTLINK + T1_ANALYSE, 0);\r\nmdelay(5);\r\nt1outp(base, T1_SLOWLINK + T1_ANALYSE, 0);\r\nif (t1inp(base, T1_FASTLINK + T1_OUTSTAT) != 0x1)\r\nreturn 1;\r\nif (t1inp(base, T1_FASTLINK + T1_INSTAT) != 0x0)\r\nreturn 2;\r\nif (t1inp(base, T1_FASTLINK + T1_IRQENABLE) != 0x0)\r\nreturn 3;\r\nif ((t1inp(base, T1_FASTLINK + T1_FIFOSTAT) & 0xf0) != 0x70)\r\nreturn 4;\r\nif ((t1inp(base, T1_FASTLINK + T1_IRQMASTER) & 0x0e) != 0)\r\nreturn 5;\r\nif ((t1inp(base, T1_FASTLINK + T1_IDENT) & 0x7d) != 1)\r\nreturn 6;\r\nif (t1inp(base, T1_SLOWLINK + T1_OUTSTAT) != 0x1)\r\nreturn 7;\r\nif ((t1inp(base, T1_SLOWLINK + T1_IRQMASTER) & 0x0e) != 0)\r\nreturn 8;\r\nif ((t1inp(base, T1_SLOWLINK + T1_IDENT) & 0x7d) != 0)\r\nreturn 9;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t t1isa_interrupt(int interrupt, void *devptr)\r\n{\r\navmcard *card = devptr;\r\navmctrl_info *cinfo = &card->ctrlinfo[0];\r\nstruct capi_ctr *ctrl = &cinfo->capi_ctrl;\r\nunsigned char b1cmd;\r\nstruct sk_buff *skb;\r\nunsigned ApplId;\r\nunsigned MsgLen;\r\nunsigned DataB3Len;\r\nunsigned NCCI;\r\nunsigned WindowSize;\r\nunsigned long flags;\r\nspin_lock_irqsave(&card->lock, flags);\r\nwhile (b1_rx_full(card->port)) {\r\nb1cmd = b1_get_byte(card->port);\r\nswitch (b1cmd) {\r\ncase RECEIVE_DATA_B3_IND:\r\nApplId = (unsigned) b1_get_word(card->port);\r\nMsgLen = t1_get_slice(card->port, card->msgbuf);\r\nDataB3Len = t1_get_slice(card->port, card->databuf);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nif (MsgLen < 30) {\r\nmemset(card->msgbuf + MsgLen, 0, 30 - MsgLen);\r\nMsgLen = 30;\r\nCAPIMSG_SETLEN(card->msgbuf, 30);\r\n}\r\nif (!(skb = alloc_skb(DataB3Len + MsgLen, GFP_ATOMIC))) {\r\nprintk(KERN_ERR "%s: incoming packet dropped\n",\r\ncard->name);\r\n} else {\r\nskb_put_data(skb, card->msgbuf, MsgLen);\r\nskb_put_data(skb, card->databuf, DataB3Len);\r\ncapi_ctr_handle_message(ctrl, ApplId, skb);\r\n}\r\nbreak;\r\ncase RECEIVE_MESSAGE:\r\nApplId = (unsigned) b1_get_word(card->port);\r\nMsgLen = t1_get_slice(card->port, card->msgbuf);\r\nif (!(skb = alloc_skb(MsgLen, GFP_ATOMIC))) {\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nprintk(KERN_ERR "%s: incoming packet dropped\n",\r\ncard->name);\r\n} else {\r\nskb_put_data(skb, card->msgbuf, MsgLen);\r\nif (CAPIMSG_CMD(skb->data) == CAPI_DATA_B3)\r\ncapilib_data_b3_conf(&cinfo->ncci_head, ApplId,\r\nCAPIMSG_NCCI(skb->data),\r\nCAPIMSG_MSGID(skb->data));\r\nspin_unlock_irqrestore(&card->lock, flags);\r\ncapi_ctr_handle_message(ctrl, ApplId, skb);\r\n}\r\nbreak;\r\ncase RECEIVE_NEW_NCCI:\r\nApplId = b1_get_word(card->port);\r\nNCCI = b1_get_word(card->port);\r\nWindowSize = b1_get_word(card->port);\r\ncapilib_new_ncci(&cinfo->ncci_head, ApplId, NCCI, WindowSize);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nbreak;\r\ncase RECEIVE_FREE_NCCI:\r\nApplId = b1_get_word(card->port);\r\nNCCI = b1_get_word(card->port);\r\nif (NCCI != 0xffffffff)\r\ncapilib_free_ncci(&cinfo->ncci_head, ApplId, NCCI);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nbreak;\r\ncase RECEIVE_START:\r\nb1_put_byte(card->port, SEND_POLLACK);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\ncapi_ctr_resume_output(ctrl);\r\nbreak;\r\ncase RECEIVE_STOP:\r\nspin_unlock_irqrestore(&card->lock, flags);\r\ncapi_ctr_suspend_output(ctrl);\r\nbreak;\r\ncase RECEIVE_INIT:\r\ncinfo->versionlen = t1_get_slice(card->port, cinfo->versionbuf);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nb1_parse_version(cinfo);\r\nprintk(KERN_INFO "%s: %s-card (%s) now active\n",\r\ncard->name,\r\ncinfo->version[VER_CARDTYPE],\r\ncinfo->version[VER_DRIVER]);\r\ncapi_ctr_ready(ctrl);\r\nbreak;\r\ncase RECEIVE_TASK_READY:\r\nApplId = (unsigned) b1_get_word(card->port);\r\nMsgLen = t1_get_slice(card->port, card->msgbuf);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\ncard->msgbuf[MsgLen] = 0;\r\nwhile (MsgLen > 0\r\n&& (card->msgbuf[MsgLen - 1] == '\n'\r\n|| card->msgbuf[MsgLen - 1] == '\r')) {\r\ncard->msgbuf[MsgLen - 1] = 0;\r\nMsgLen--;\r\n}\r\nprintk(KERN_INFO "%s: task %d \"%s\" ready.\n",\r\ncard->name, ApplId, card->msgbuf);\r\nbreak;\r\ncase RECEIVE_DEBUGMSG:\r\nMsgLen = t1_get_slice(card->port, card->msgbuf);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\ncard->msgbuf[MsgLen] = 0;\r\nwhile (MsgLen > 0\r\n&& (card->msgbuf[MsgLen - 1] == '\n'\r\n|| card->msgbuf[MsgLen - 1] == '\r')) {\r\ncard->msgbuf[MsgLen - 1] = 0;\r\nMsgLen--;\r\n}\r\nprintk(KERN_INFO "%s: DEBUG: %s\n", card->name, card->msgbuf);\r\nbreak;\r\ncase 0xff:\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nprintk(KERN_ERR "%s: card reseted ?\n", card->name);\r\nreturn IRQ_HANDLED;\r\ndefault:\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nprintk(KERN_ERR "%s: b1_interrupt: 0x%x ???\n",\r\ncard->name, b1cmd);\r\nreturn IRQ_NONE;\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int t1isa_load_firmware(struct capi_ctr *ctrl, capiloaddata *data)\r\n{\r\navmctrl_info *cinfo = (avmctrl_info *)(ctrl->driverdata);\r\navmcard *card = cinfo->card;\r\nunsigned int port = card->port;\r\nunsigned long flags;\r\nint retval;\r\nt1_disable_irq(port);\r\nb1_reset(port);\r\nif ((retval = b1_load_t4file(card, &data->firmware))) {\r\nb1_reset(port);\r\nprintk(KERN_ERR "%s: failed to load t4file!!\n",\r\ncard->name);\r\nreturn retval;\r\n}\r\nif (data->configuration.len > 0 && data->configuration.data) {\r\nif ((retval = b1_load_config(card, &data->configuration))) {\r\nb1_reset(port);\r\nprintk(KERN_ERR "%s: failed to load config!!\n",\r\ncard->name);\r\nreturn retval;\r\n}\r\n}\r\nif (!b1_loaded(card)) {\r\nprintk(KERN_ERR "%s: failed to load t4file.\n", card->name);\r\nreturn -EIO;\r\n}\r\nspin_lock_irqsave(&card->lock, flags);\r\nb1_setinterrupt(port, card->irq, card->cardtype);\r\nb1_put_byte(port, SEND_INIT);\r\nb1_put_word(port, CAPI_MAXAPPL);\r\nb1_put_word(port, AVM_NCCI_PER_CHANNEL * 30);\r\nb1_put_word(port, ctrl->cnr - 1);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void t1isa_reset_ctr(struct capi_ctr *ctrl)\r\n{\r\navmctrl_info *cinfo = (avmctrl_info *)(ctrl->driverdata);\r\navmcard *card = cinfo->card;\r\nunsigned int port = card->port;\r\nunsigned long flags;\r\nt1_disable_irq(port);\r\nb1_reset(port);\r\nb1_reset(port);\r\nmemset(cinfo->version, 0, sizeof(cinfo->version));\r\nspin_lock_irqsave(&card->lock, flags);\r\ncapilib_release(&cinfo->ncci_head);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\ncapi_ctr_down(ctrl);\r\n}\r\nstatic void t1isa_remove(struct pci_dev *pdev)\r\n{\r\navmctrl_info *cinfo = pci_get_drvdata(pdev);\r\navmcard *card;\r\nif (!cinfo)\r\nreturn;\r\ncard = cinfo->card;\r\nt1_disable_irq(card->port);\r\nb1_reset(card->port);\r\nb1_reset(card->port);\r\nt1_reset(card->port);\r\ndetach_capi_ctr(&cinfo->capi_ctrl);\r\nfree_irq(card->irq, card);\r\nrelease_region(card->port, AVMB1_PORTLEN);\r\nb1_free_card(card);\r\n}\r\nstatic int t1isa_probe(struct pci_dev *pdev, int cardnr)\r\n{\r\navmctrl_info *cinfo;\r\navmcard *card;\r\nint retval;\r\ncard = b1_alloc_card(1);\r\nif (!card) {\r\nprintk(KERN_WARNING "t1isa: no memory.\n");\r\nretval = -ENOMEM;\r\ngoto err;\r\n}\r\ncinfo = card->ctrlinfo;\r\ncard->port = pci_resource_start(pdev, 0);\r\ncard->irq = pdev->irq;\r\ncard->cardtype = avm_t1isa;\r\ncard->cardnr = cardnr;\r\nsprintf(card->name, "t1isa-%x", card->port);\r\nif (!(((card->port & 0x7) == 0) && ((card->port & 0x30) != 0x30))) {\r\nprintk(KERN_WARNING "t1isa: invalid port 0x%x.\n", card->port);\r\nretval = -EINVAL;\r\ngoto err_free;\r\n}\r\nif (hema_irq_table[card->irq & 0xf] == 0) {\r\nprintk(KERN_WARNING "t1isa: irq %d not valid.\n", card->irq);\r\nretval = -EINVAL;\r\ngoto err_free;\r\n}\r\nif (!request_region(card->port, AVMB1_PORTLEN, card->name)) {\r\nprintk(KERN_INFO "t1isa: ports 0x%03x-0x%03x in use.\n",\r\ncard->port, card->port + AVMB1_PORTLEN);\r\nretval = -EBUSY;\r\ngoto err_free;\r\n}\r\nretval = request_irq(card->irq, t1isa_interrupt, 0, card->name, card);\r\nif (retval) {\r\nprintk(KERN_INFO "t1isa: unable to get IRQ %d.\n", card->irq);\r\nretval = -EBUSY;\r\ngoto err_release_region;\r\n}\r\nif ((retval = t1_detectandinit(card->port, card->irq, card->cardnr)) != 0) {\r\nprintk(KERN_INFO "t1isa: NO card at 0x%x (%d)\n",\r\ncard->port, retval);\r\nretval = -ENODEV;\r\ngoto err_free_irq;\r\n}\r\nt1_disable_irq(card->port);\r\nb1_reset(card->port);\r\ncinfo->capi_ctrl.owner = THIS_MODULE;\r\ncinfo->capi_ctrl.driver_name = "t1isa";\r\ncinfo->capi_ctrl.driverdata = cinfo;\r\ncinfo->capi_ctrl.register_appl = b1_register_appl;\r\ncinfo->capi_ctrl.release_appl = b1_release_appl;\r\ncinfo->capi_ctrl.send_message = t1isa_send_message;\r\ncinfo->capi_ctrl.load_firmware = t1isa_load_firmware;\r\ncinfo->capi_ctrl.reset_ctr = t1isa_reset_ctr;\r\ncinfo->capi_ctrl.procinfo = t1isa_procinfo;\r\ncinfo->capi_ctrl.proc_fops = &b1ctl_proc_fops;\r\nstrcpy(cinfo->capi_ctrl.name, card->name);\r\nretval = attach_capi_ctr(&cinfo->capi_ctrl);\r\nif (retval) {\r\nprintk(KERN_INFO "t1isa: attach controller failed.\n");\r\ngoto err_free_irq;\r\n}\r\nprintk(KERN_INFO "t1isa: AVM T1 ISA at i/o %#x, irq %d, card %d\n",\r\ncard->port, card->irq, card->cardnr);\r\npci_set_drvdata(pdev, cinfo);\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(card->irq, card);\r\nerr_release_region:\r\nrelease_region(card->port, AVMB1_PORTLEN);\r\nerr_free:\r\nb1_free_card(card);\r\nerr:\r\nreturn retval;\r\n}\r\nstatic u16 t1isa_send_message(struct capi_ctr *ctrl, struct sk_buff *skb)\r\n{\r\navmctrl_info *cinfo = (avmctrl_info *)(ctrl->driverdata);\r\navmcard *card = cinfo->card;\r\nunsigned int port = card->port;\r\nunsigned long flags;\r\nu16 len = CAPIMSG_LEN(skb->data);\r\nu8 cmd = CAPIMSG_COMMAND(skb->data);\r\nu8 subcmd = CAPIMSG_SUBCOMMAND(skb->data);\r\nu16 dlen, retval;\r\nspin_lock_irqsave(&card->lock, flags);\r\nif (CAPICMD(cmd, subcmd) == CAPI_DATA_B3_REQ) {\r\nretval = capilib_data_b3_req(&cinfo->ncci_head,\r\nCAPIMSG_APPID(skb->data),\r\nCAPIMSG_NCCI(skb->data),\r\nCAPIMSG_MSGID(skb->data));\r\nif (retval != CAPI_NOERROR) {\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nreturn retval;\r\n}\r\ndlen = CAPIMSG_DATALEN(skb->data);\r\nb1_put_byte(port, SEND_DATA_B3_REQ);\r\nt1_put_slice(port, skb->data, len);\r\nt1_put_slice(port, skb->data + len, dlen);\r\n} else {\r\nb1_put_byte(port, SEND_MESSAGE);\r\nt1_put_slice(port, skb->data, len);\r\n}\r\nspin_unlock_irqrestore(&card->lock, flags);\r\ndev_kfree_skb_any(skb);\r\nreturn CAPI_NOERROR;\r\n}\r\nstatic char *t1isa_procinfo(struct capi_ctr *ctrl)\r\n{\r\navmctrl_info *cinfo = (avmctrl_info *)(ctrl->driverdata);\r\nif (!cinfo)\r\nreturn "";\r\nsprintf(cinfo->infobuf, "%s %s 0x%x %d %d",\r\ncinfo->cardname[0] ? cinfo->cardname : "-",\r\ncinfo->version[VER_DRIVER] ? cinfo->version[VER_DRIVER] : "-",\r\ncinfo->card ? cinfo->card->port : 0x0,\r\ncinfo->card ? cinfo->card->irq : 0,\r\ncinfo->card ? cinfo->card->cardnr : 0\r\n);\r\nreturn cinfo->infobuf;\r\n}\r\nstatic int t1isa_add_card(struct capi_driver *driver, capicardparams *data)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_CARDS; i++) {\r\nif (isa_dev[i].resource[0].start)\r\ncontinue;\r\nisa_dev[i].resource[0].start = data->port;\r\nisa_dev[i].irq = data->irq;\r\nif (t1isa_probe(&isa_dev[i], data->cardnr) == 0)\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int __init t1isa_init(void)\r\n{\r\nchar rev[32];\r\nchar *p;\r\nint i;\r\nif ((p = strchr(revision, ':')) != NULL && p[1]) {\r\nstrlcpy(rev, p + 2, 32);\r\nif ((p = strchr(rev, '$')) != NULL && p > rev)\r\n*(p - 1) = 0;\r\n} else\r\nstrcpy(rev, "1.0");\r\nfor (i = 0; i < MAX_CARDS; i++) {\r\nif (!io[i])\r\nbreak;\r\nisa_dev[i].resource[0].start = io[i];\r\nisa_dev[i].irq = irq[i];\r\nif (t1isa_probe(&isa_dev[i], cardnr[i]) != 0)\r\nreturn -ENODEV;\r\n}\r\nstrlcpy(capi_driver_t1isa.revision, rev, 32);\r\nregister_capi_driver(&capi_driver_t1isa);\r\nprintk(KERN_INFO "t1isa: revision %s\n", rev);\r\nreturn 0;\r\n}\r\nstatic void __exit t1isa_exit(void)\r\n{\r\nint i;\r\nunregister_capi_driver(&capi_driver_t1isa);\r\nfor (i = 0; i < MAX_CARDS; i++) {\r\nif (!io[i])\r\nbreak;\r\nt1isa_remove(&isa_dev[i]);\r\n}\r\n}
