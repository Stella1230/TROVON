static int isl29028_find_prox_sleep_index(int sampling_int, int sampling_fract)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(isl29028_prox_data); ++i) {\r\nif (isl29028_prox_data[i].sampling_int == sampling_int &&\r\nisl29028_prox_data[i].sampling_fract == sampling_fract)\r\nreturn i;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int isl29028_set_proxim_sampling(struct isl29028_chip *chip,\r\nint sampling_int, int sampling_fract)\r\n{\r\nstruct device *dev = regmap_get_device(chip->regmap);\r\nint sleep_index, ret;\r\nsleep_index = isl29028_find_prox_sleep_index(sampling_int,\r\nsampling_fract);\r\nif (sleep_index < 0)\r\nreturn sleep_index;\r\nret = regmap_update_bits(chip->regmap, ISL29028_REG_CONFIGURE,\r\nISL29028_CONF_PROX_SLP_MASK,\r\nsleep_index << ISL29028_CONF_PROX_SLP_SH);\r\nif (ret < 0) {\r\ndev_err(dev, "%s(): Error %d setting the proximity sampling\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nchip->prox_sampling_int = sampling_int;\r\nchip->prox_sampling_frac = sampling_fract;\r\nreturn ret;\r\n}\r\nstatic int isl29028_enable_proximity(struct isl29028_chip *chip)\r\n{\r\nint prox_index, ret;\r\nret = isl29028_set_proxim_sampling(chip, chip->prox_sampling_int,\r\nchip->prox_sampling_frac);\r\nif (ret < 0)\r\nreturn ret;\r\nret = regmap_update_bits(chip->regmap, ISL29028_REG_CONFIGURE,\r\nISL29028_CONF_PROX_EN_MASK,\r\nISL29028_CONF_PROX_EN);\r\nif (ret < 0)\r\nreturn ret;\r\nprox_index = isl29028_find_prox_sleep_index(chip->prox_sampling_int,\r\nchip->prox_sampling_frac);\r\nif (prox_index < 0)\r\nreturn prox_index;\r\nmsleep(isl29028_prox_data[prox_index].sleep_time);\r\nreturn 0;\r\n}\r\nstatic int isl29028_set_als_scale(struct isl29028_chip *chip, int lux_scale)\r\n{\r\nstruct device *dev = regmap_get_device(chip->regmap);\r\nint val = (lux_scale == 2000) ? ISL29028_CONF_ALS_RANGE_HIGH_LUX :\r\nISL29028_CONF_ALS_RANGE_LOW_LUX;\r\nint ret;\r\nret = regmap_update_bits(chip->regmap, ISL29028_REG_CONFIGURE,\r\nISL29028_CONF_ALS_RANGE_MASK, val);\r\nif (ret < 0) {\r\ndev_err(dev, "%s(): Error %d setting the ALS scale\n", __func__,\r\nret);\r\nreturn ret;\r\n}\r\nchip->lux_scale = lux_scale;\r\nreturn ret;\r\n}\r\nstatic int isl29028_set_als_ir_mode(struct isl29028_chip *chip,\r\nenum isl29028_als_ir_mode mode)\r\n{\r\nint ret;\r\nif (chip->als_ir_mode == mode)\r\nreturn 0;\r\nret = isl29028_set_als_scale(chip, chip->lux_scale);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (mode) {\r\ncase ISL29028_MODE_ALS:\r\nret = regmap_update_bits(chip->regmap, ISL29028_REG_CONFIGURE,\r\nISL29028_CONF_ALS_IR_MODE_MASK,\r\nISL29028_CONF_ALS_IR_MODE_ALS);\r\nif (ret < 0)\r\nreturn ret;\r\nret = regmap_update_bits(chip->regmap, ISL29028_REG_CONFIGURE,\r\nISL29028_CONF_ALS_RANGE_MASK,\r\nISL29028_CONF_ALS_RANGE_HIGH_LUX);\r\nbreak;\r\ncase ISL29028_MODE_IR:\r\nret = regmap_update_bits(chip->regmap, ISL29028_REG_CONFIGURE,\r\nISL29028_CONF_ALS_IR_MODE_MASK,\r\nISL29028_CONF_ALS_IR_MODE_IR);\r\nbreak;\r\ncase ISL29028_MODE_NONE:\r\nreturn regmap_update_bits(chip->regmap, ISL29028_REG_CONFIGURE,\r\nISL29028_CONF_ALS_EN_MASK,\r\nISL29028_CONF_ALS_DIS);\r\n}\r\nif (ret < 0)\r\nreturn ret;\r\nret = regmap_update_bits(chip->regmap, ISL29028_REG_CONFIGURE,\r\nISL29028_CONF_ALS_EN_MASK,\r\nISL29028_CONF_ALS_EN);\r\nif (ret < 0)\r\nreturn ret;\r\nmsleep(ISL29028_CONV_TIME_MS);\r\nchip->als_ir_mode = mode;\r\nreturn 0;\r\n}\r\nstatic int isl29028_read_als_ir(struct isl29028_chip *chip, int *als_ir)\r\n{\r\nstruct device *dev = regmap_get_device(chip->regmap);\r\nunsigned int lsb;\r\nunsigned int msb;\r\nint ret;\r\nret = regmap_read(chip->regmap, ISL29028_REG_ALSIR_L, &lsb);\r\nif (ret < 0) {\r\ndev_err(dev,\r\n"%s(): Error %d reading register ALSIR_L\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nret = regmap_read(chip->regmap, ISL29028_REG_ALSIR_U, &msb);\r\nif (ret < 0) {\r\ndev_err(dev,\r\n"%s(): Error %d reading register ALSIR_U\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\n*als_ir = ((msb & 0xF) << 8) | (lsb & 0xFF);\r\nreturn 0;\r\n}\r\nstatic int isl29028_read_proxim(struct isl29028_chip *chip, int *prox)\r\n{\r\nstruct device *dev = regmap_get_device(chip->regmap);\r\nunsigned int data;\r\nint ret;\r\nif (!chip->enable_prox) {\r\nret = isl29028_enable_proximity(chip);\r\nif (ret < 0)\r\nreturn ret;\r\nchip->enable_prox = true;\r\n}\r\nret = regmap_read(chip->regmap, ISL29028_REG_PROX_DATA, &data);\r\nif (ret < 0) {\r\ndev_err(dev, "%s(): Error %d reading register PROX_DATA\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\n*prox = data;\r\nreturn 0;\r\n}\r\nstatic int isl29028_als_get(struct isl29028_chip *chip, int *als_data)\r\n{\r\nstruct device *dev = regmap_get_device(chip->regmap);\r\nint ret;\r\nint als_ir_data;\r\nret = isl29028_set_als_ir_mode(chip, ISL29028_MODE_ALS);\r\nif (ret < 0) {\r\ndev_err(dev, "%s(): Error %d enabling ALS mode\n", __func__,\r\nret);\r\nreturn ret;\r\n}\r\nret = isl29028_read_als_ir(chip, &als_ir_data);\r\nif (ret < 0)\r\nreturn ret;\r\nif (chip->lux_scale == 125)\r\nals_ir_data = (als_ir_data * 31) / 1000;\r\nelse\r\nals_ir_data = (als_ir_data * 49) / 100;\r\n*als_data = als_ir_data;\r\nreturn 0;\r\n}\r\nstatic int isl29028_ir_get(struct isl29028_chip *chip, int *ir_data)\r\n{\r\nstruct device *dev = regmap_get_device(chip->regmap);\r\nint ret;\r\nret = isl29028_set_als_ir_mode(chip, ISL29028_MODE_IR);\r\nif (ret < 0) {\r\ndev_err(dev, "%s(): Error %d enabling IR mode\n", __func__,\r\nret);\r\nreturn ret;\r\n}\r\nreturn isl29028_read_als_ir(chip, ir_data);\r\n}\r\nstatic int isl29028_set_pm_runtime_busy(struct isl29028_chip *chip, bool on)\r\n{\r\nstruct device *dev = regmap_get_device(chip->regmap);\r\nint ret;\r\nif (on) {\r\nret = pm_runtime_get_sync(dev);\r\nif (ret < 0)\r\npm_runtime_put_noidle(dev);\r\n} else {\r\npm_runtime_mark_last_busy(dev);\r\nret = pm_runtime_put_autosuspend(dev);\r\n}\r\nreturn ret;\r\n}\r\nstatic int isl29028_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint val, int val2, long mask)\r\n{\r\nstruct isl29028_chip *chip = iio_priv(indio_dev);\r\nstruct device *dev = regmap_get_device(chip->regmap);\r\nint ret;\r\nret = isl29028_set_pm_runtime_busy(chip, true);\r\nif (ret < 0)\r\nreturn ret;\r\nmutex_lock(&chip->lock);\r\nret = -EINVAL;\r\nswitch (chan->type) {\r\ncase IIO_PROXIMITY:\r\nif (mask != IIO_CHAN_INFO_SAMP_FREQ) {\r\ndev_err(dev,\r\n"%s(): proximity: Mask value 0x%08lx is not supported\n",\r\n__func__, mask);\r\nbreak;\r\n}\r\nif (val < 1 || val > 100) {\r\ndev_err(dev,\r\n"%s(): proximity: Sampling frequency %d is not in the range [1:100]\n",\r\n__func__, val);\r\nbreak;\r\n}\r\nret = isl29028_set_proxim_sampling(chip, val, val2);\r\nbreak;\r\ncase IIO_LIGHT:\r\nif (mask != IIO_CHAN_INFO_SCALE) {\r\ndev_err(dev,\r\n"%s(): light: Mask value 0x%08lx is not supported\n",\r\n__func__, mask);\r\nbreak;\r\n}\r\nif (val != 125 && val != 2000) {\r\ndev_err(dev,\r\n"%s(): light: Lux scale %d is not in the set {125, 2000}\n",\r\n__func__, val);\r\nbreak;\r\n}\r\nret = isl29028_set_als_scale(chip, val);\r\nbreak;\r\ndefault:\r\ndev_err(dev, "%s(): Unsupported channel type %x\n",\r\n__func__, chan->type);\r\nbreak;\r\n}\r\nmutex_unlock(&chip->lock);\r\nif (ret < 0)\r\nreturn ret;\r\nret = isl29028_set_pm_runtime_busy(chip, false);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn ret;\r\n}\r\nstatic int isl29028_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2, long mask)\r\n{\r\nstruct isl29028_chip *chip = iio_priv(indio_dev);\r\nstruct device *dev = regmap_get_device(chip->regmap);\r\nint ret, pm_ret;\r\nret = isl29028_set_pm_runtime_busy(chip, true);\r\nif (ret < 0)\r\nreturn ret;\r\nmutex_lock(&chip->lock);\r\nret = -EINVAL;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\ncase IIO_CHAN_INFO_PROCESSED:\r\nswitch (chan->type) {\r\ncase IIO_LIGHT:\r\nret = isl29028_als_get(chip, val);\r\nbreak;\r\ncase IIO_INTENSITY:\r\nret = isl29028_ir_get(chip, val);\r\nbreak;\r\ncase IIO_PROXIMITY:\r\nret = isl29028_read_proxim(chip, val);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (ret < 0)\r\nbreak;\r\nret = IIO_VAL_INT;\r\nbreak;\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\nif (chan->type != IIO_PROXIMITY)\r\nbreak;\r\n*val = chip->prox_sampling_int;\r\n*val2 = chip->prox_sampling_frac;\r\nret = IIO_VAL_INT;\r\nbreak;\r\ncase IIO_CHAN_INFO_SCALE:\r\nif (chan->type != IIO_LIGHT)\r\nbreak;\r\n*val = chip->lux_scale;\r\nret = IIO_VAL_INT;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "%s(): mask value 0x%08lx is not supported\n",\r\n__func__, mask);\r\nbreak;\r\n}\r\nmutex_unlock(&chip->lock);\r\nif (ret < 0)\r\nreturn ret;\r\npm_ret = isl29028_set_pm_runtime_busy(chip, false);\r\nif (pm_ret < 0)\r\nreturn pm_ret;\r\nreturn ret;\r\n}\r\nstatic int isl29028_clear_configure_reg(struct isl29028_chip *chip)\r\n{\r\nstruct device *dev = regmap_get_device(chip->regmap);\r\nint ret;\r\nret = regmap_write(chip->regmap, ISL29028_REG_CONFIGURE, 0x0);\r\nif (ret < 0)\r\ndev_err(dev, "%s(): Error %d clearing the CONFIGURE register\n",\r\n__func__, ret);\r\nchip->als_ir_mode = ISL29028_MODE_NONE;\r\nchip->enable_prox = false;\r\nreturn ret;\r\n}\r\nstatic bool isl29028_is_volatile_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase ISL29028_REG_INTERRUPT:\r\ncase ISL29028_REG_PROX_DATA:\r\ncase ISL29028_REG_ALSIR_L:\r\ncase ISL29028_REG_ALSIR_U:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int isl29028_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct isl29028_chip *chip;\r\nstruct iio_dev *indio_dev;\r\nint ret;\r\nindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*chip));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\nchip = iio_priv(indio_dev);\r\ni2c_set_clientdata(client, indio_dev);\r\nmutex_init(&chip->lock);\r\nchip->regmap = devm_regmap_init_i2c(client, &isl29028_regmap_config);\r\nif (IS_ERR(chip->regmap)) {\r\nret = PTR_ERR(chip->regmap);\r\ndev_err(&client->dev, "%s: Error %d initializing regmap\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nchip->enable_prox = false;\r\nchip->prox_sampling_int = 20;\r\nchip->prox_sampling_frac = 0;\r\nchip->lux_scale = 2000;\r\nret = regmap_write(chip->regmap, ISL29028_REG_TEST1_MODE, 0x0);\r\nif (ret < 0) {\r\ndev_err(&client->dev,\r\n"%s(): Error %d writing to TEST1_MODE register\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nret = regmap_write(chip->regmap, ISL29028_REG_TEST2_MODE, 0x0);\r\nif (ret < 0) {\r\ndev_err(&client->dev,\r\n"%s(): Error %d writing to TEST2_MODE register\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nret = isl29028_clear_configure_reg(chip);\r\nif (ret < 0)\r\nreturn ret;\r\nindio_dev->info = &isl29028_info;\r\nindio_dev->channels = isl29028_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(isl29028_channels);\r\nindio_dev->name = id->name;\r\nindio_dev->dev.parent = &client->dev;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\npm_runtime_enable(&client->dev);\r\npm_runtime_set_autosuspend_delay(&client->dev,\r\nISL29028_POWER_OFF_DELAY_MS);\r\npm_runtime_use_autosuspend(&client->dev);\r\nret = devm_iio_device_register(indio_dev->dev.parent, indio_dev);\r\nif (ret < 0) {\r\ndev_err(&client->dev,\r\n"%s(): iio registration failed with error %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int isl29028_remove(struct i2c_client *client)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(client);\r\nstruct isl29028_chip *chip = iio_priv(indio_dev);\r\niio_device_unregister(indio_dev);\r\npm_runtime_disable(&client->dev);\r\npm_runtime_set_suspended(&client->dev);\r\npm_runtime_put_noidle(&client->dev);\r\nreturn isl29028_clear_configure_reg(chip);\r\n}\r\nstatic int __maybe_unused isl29028_suspend(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct isl29028_chip *chip = iio_priv(indio_dev);\r\nint ret;\r\nmutex_lock(&chip->lock);\r\nret = isl29028_clear_configure_reg(chip);\r\nmutex_unlock(&chip->lock);\r\nreturn ret;\r\n}\r\nstatic int __maybe_unused isl29028_resume(struct device *dev)\r\n{\r\nreturn 0;\r\n}
