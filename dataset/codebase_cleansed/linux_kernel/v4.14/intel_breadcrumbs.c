static unsigned int __intel_breadcrumbs_wakeup(struct intel_breadcrumbs *b)\r\n{\r\nstruct intel_wait *wait;\r\nunsigned int result = 0;\r\nlockdep_assert_held(&b->irq_lock);\r\nwait = b->irq_wait;\r\nif (wait) {\r\nresult = ENGINE_WAKEUP_WAITER;\r\nif (wake_up_process(wait->tsk))\r\nresult |= ENGINE_WAKEUP_ASLEEP;\r\n}\r\nreturn result;\r\n}\r\nunsigned int intel_engine_wakeup(struct intel_engine_cs *engine)\r\n{\r\nstruct intel_breadcrumbs *b = &engine->breadcrumbs;\r\nunsigned long flags;\r\nunsigned int result;\r\nspin_lock_irqsave(&b->irq_lock, flags);\r\nresult = __intel_breadcrumbs_wakeup(b);\r\nspin_unlock_irqrestore(&b->irq_lock, flags);\r\nreturn result;\r\n}\r\nstatic unsigned long wait_timeout(void)\r\n{\r\nreturn round_jiffies_up(jiffies + DRM_I915_HANGCHECK_JIFFIES);\r\n}\r\nstatic noinline void missed_breadcrumb(struct intel_engine_cs *engine)\r\n{\r\nDRM_DEBUG_DRIVER("%s missed breadcrumb at %pF, irq posted? %s, current seqno=%x, last=%x\n",\r\nengine->name, __builtin_return_address(0),\r\nyesno(test_bit(ENGINE_IRQ_BREADCRUMB,\r\n&engine->irq_posted)),\r\nintel_engine_get_seqno(engine),\r\nintel_engine_last_submit(engine));\r\nset_bit(engine->id, &engine->i915->gpu_error.missed_irq_rings);\r\n}\r\nstatic void intel_breadcrumbs_hangcheck(unsigned long data)\r\n{\r\nstruct intel_engine_cs *engine = (struct intel_engine_cs *)data;\r\nstruct intel_breadcrumbs *b = &engine->breadcrumbs;\r\nif (!b->irq_armed)\r\nreturn;\r\nif (b->hangcheck_interrupts != atomic_read(&engine->irq_count)) {\r\nb->hangcheck_interrupts = atomic_read(&engine->irq_count);\r\nmod_timer(&b->hangcheck, wait_timeout());\r\nreturn;\r\n}\r\nif (intel_engine_wakeup(engine) & ENGINE_WAKEUP_ASLEEP) {\r\nmissed_breadcrumb(engine);\r\nmod_timer(&engine->breadcrumbs.fake_irq, jiffies + 1);\r\n} else {\r\nmod_timer(&b->hangcheck, wait_timeout());\r\n}\r\n}\r\nstatic void intel_breadcrumbs_fake_irq(unsigned long data)\r\n{\r\nstruct intel_engine_cs *engine = (struct intel_engine_cs *)data;\r\nstruct intel_breadcrumbs *b = &engine->breadcrumbs;\r\nspin_lock_irq(&b->irq_lock);\r\nif (!__intel_breadcrumbs_wakeup(b))\r\n__intel_engine_disarm_breadcrumbs(engine);\r\nspin_unlock_irq(&b->irq_lock);\r\nif (!b->irq_armed)\r\nreturn;\r\nmod_timer(&b->fake_irq, jiffies + 1);\r\ni915_queue_hangcheck(engine->i915);\r\n}\r\nstatic void irq_enable(struct intel_engine_cs *engine)\r\n{\r\nset_bit(ENGINE_IRQ_BREADCRUMB, &engine->irq_posted);\r\nspin_lock(&engine->i915->irq_lock);\r\nengine->irq_enable(engine);\r\nspin_unlock(&engine->i915->irq_lock);\r\n}\r\nstatic void irq_disable(struct intel_engine_cs *engine)\r\n{\r\nspin_lock(&engine->i915->irq_lock);\r\nengine->irq_disable(engine);\r\nspin_unlock(&engine->i915->irq_lock);\r\n}\r\nvoid __intel_engine_disarm_breadcrumbs(struct intel_engine_cs *engine)\r\n{\r\nstruct intel_breadcrumbs *b = &engine->breadcrumbs;\r\nlockdep_assert_held(&b->irq_lock);\r\nGEM_BUG_ON(b->irq_wait);\r\nif (b->irq_enabled) {\r\nirq_disable(engine);\r\nb->irq_enabled = false;\r\n}\r\nb->irq_armed = false;\r\n}\r\nvoid intel_engine_disarm_breadcrumbs(struct intel_engine_cs *engine)\r\n{\r\nstruct intel_breadcrumbs *b = &engine->breadcrumbs;\r\nstruct intel_wait *wait, *n, *first;\r\nif (!b->irq_armed)\r\nreturn;\r\nspin_lock_irq(&b->rb_lock);\r\nspin_lock(&b->irq_lock);\r\nfirst = fetch_and_zero(&b->irq_wait);\r\n__intel_engine_disarm_breadcrumbs(engine);\r\nspin_unlock(&b->irq_lock);\r\nrbtree_postorder_for_each_entry_safe(wait, n, &b->waiters, node) {\r\nRB_CLEAR_NODE(&wait->node);\r\nif (wake_up_process(wait->tsk) && wait == first)\r\nmissed_breadcrumb(engine);\r\n}\r\nb->waiters = RB_ROOT;\r\nspin_unlock_irq(&b->rb_lock);\r\n}\r\nstatic bool use_fake_irq(const struct intel_breadcrumbs *b)\r\n{\r\nconst struct intel_engine_cs *engine =\r\ncontainer_of(b, struct intel_engine_cs, breadcrumbs);\r\nif (!test_bit(engine->id, &engine->i915->gpu_error.missed_irq_rings))\r\nreturn false;\r\nreturn atomic_read(&engine->irq_count) == b->hangcheck_interrupts;\r\n}\r\nstatic void enable_fake_irq(struct intel_breadcrumbs *b)\r\n{\r\nif (!b->irq_enabled || use_fake_irq(b))\r\nmod_timer(&b->fake_irq, jiffies + 1);\r\nelse\r\nmod_timer(&b->hangcheck, wait_timeout());\r\n}\r\nstatic bool __intel_breadcrumbs_enable_irq(struct intel_breadcrumbs *b)\r\n{\r\nstruct intel_engine_cs *engine =\r\ncontainer_of(b, struct intel_engine_cs, breadcrumbs);\r\nstruct drm_i915_private *i915 = engine->i915;\r\nlockdep_assert_held(&b->irq_lock);\r\nif (b->irq_armed)\r\nreturn false;\r\nb->irq_armed = true;\r\nGEM_BUG_ON(b->irq_enabled);\r\nif (I915_SELFTEST_ONLY(b->mock)) {\r\nreturn true;\r\n}\r\nif (intel_irqs_enabled(i915)) {\r\nif (!test_bit(engine->id, &i915->gpu_error.test_irq_rings))\r\nirq_enable(engine);\r\nb->irq_enabled = true;\r\n}\r\nenable_fake_irq(b);\r\nreturn true;\r\n}\r\nstatic inline struct intel_wait *to_wait(struct rb_node *node)\r\n{\r\nreturn rb_entry(node, struct intel_wait, node);\r\n}\r\nstatic inline void __intel_breadcrumbs_finish(struct intel_breadcrumbs *b,\r\nstruct intel_wait *wait)\r\n{\r\nlockdep_assert_held(&b->rb_lock);\r\nGEM_BUG_ON(b->irq_wait == wait);\r\nrb_erase(&wait->node, &b->waiters);\r\nRB_CLEAR_NODE(&wait->node);\r\nwake_up_process(wait->tsk);\r\n}\r\nstatic inline void __intel_breadcrumbs_next(struct intel_engine_cs *engine,\r\nstruct rb_node *next)\r\n{\r\nstruct intel_breadcrumbs *b = &engine->breadcrumbs;\r\nspin_lock(&b->irq_lock);\r\nGEM_BUG_ON(!b->irq_armed);\r\nGEM_BUG_ON(!b->irq_wait);\r\nb->irq_wait = to_wait(next);\r\nspin_unlock(&b->irq_lock);\r\nif (next)\r\nwake_up_process(to_wait(next)->tsk);\r\n}\r\nstatic bool __intel_engine_add_wait(struct intel_engine_cs *engine,\r\nstruct intel_wait *wait)\r\n{\r\nstruct intel_breadcrumbs *b = &engine->breadcrumbs;\r\nstruct rb_node **p, *parent, *completed;\r\nbool first, armed;\r\nu32 seqno;\r\narmed = false;\r\nfirst = true;\r\nparent = NULL;\r\ncompleted = NULL;\r\nseqno = intel_engine_get_seqno(engine);\r\nif (i915_seqno_passed(seqno, wait->seqno)) {\r\nRB_CLEAR_NODE(&wait->node);\r\nreturn first;\r\n}\r\np = &b->waiters.rb_node;\r\nwhile (*p) {\r\nparent = *p;\r\nif (wait->seqno == to_wait(parent)->seqno) {\r\nif (wait->tsk->prio > to_wait(parent)->tsk->prio) {\r\np = &parent->rb_right;\r\nfirst = false;\r\n} else {\r\np = &parent->rb_left;\r\n}\r\n} else if (i915_seqno_passed(wait->seqno,\r\nto_wait(parent)->seqno)) {\r\np = &parent->rb_right;\r\nif (i915_seqno_passed(seqno, to_wait(parent)->seqno))\r\ncompleted = parent;\r\nelse\r\nfirst = false;\r\n} else {\r\np = &parent->rb_left;\r\n}\r\n}\r\nrb_link_node(&wait->node, parent, p);\r\nrb_insert_color(&wait->node, &b->waiters);\r\nif (first) {\r\nspin_lock(&b->irq_lock);\r\nb->irq_wait = wait;\r\narmed = __intel_breadcrumbs_enable_irq(b);\r\nspin_unlock(&b->irq_lock);\r\n}\r\nif (completed) {\r\nif (!first) {\r\nstruct rb_node *next = rb_next(completed);\r\nGEM_BUG_ON(next == &wait->node);\r\n__intel_breadcrumbs_next(engine, next);\r\n}\r\ndo {\r\nstruct intel_wait *crumb = to_wait(completed);\r\ncompleted = rb_prev(completed);\r\n__intel_breadcrumbs_finish(b, crumb);\r\n} while (completed);\r\n}\r\nGEM_BUG_ON(!b->irq_wait);\r\nGEM_BUG_ON(!b->irq_armed);\r\nGEM_BUG_ON(rb_first(&b->waiters) != &b->irq_wait->node);\r\nreturn armed;\r\n}\r\nbool intel_engine_add_wait(struct intel_engine_cs *engine,\r\nstruct intel_wait *wait)\r\n{\r\nstruct intel_breadcrumbs *b = &engine->breadcrumbs;\r\nbool armed;\r\nspin_lock_irq(&b->rb_lock);\r\narmed = __intel_engine_add_wait(engine, wait);\r\nspin_unlock_irq(&b->rb_lock);\r\nif (armed)\r\nreturn armed;\r\nreturn i915_seqno_passed(intel_engine_get_seqno(engine),\r\nwait->seqno - 1);\r\n}\r\nstatic inline bool chain_wakeup(struct rb_node *rb, int priority)\r\n{\r\nreturn rb && to_wait(rb)->tsk->prio <= priority;\r\n}\r\nstatic inline int wakeup_priority(struct intel_breadcrumbs *b,\r\nstruct task_struct *tsk)\r\n{\r\nif (tsk == b->signaler)\r\nreturn INT_MIN;\r\nelse\r\nreturn tsk->prio;\r\n}\r\nstatic void __intel_engine_remove_wait(struct intel_engine_cs *engine,\r\nstruct intel_wait *wait)\r\n{\r\nstruct intel_breadcrumbs *b = &engine->breadcrumbs;\r\nlockdep_assert_held(&b->rb_lock);\r\nif (RB_EMPTY_NODE(&wait->node))\r\ngoto out;\r\nif (b->irq_wait == wait) {\r\nconst int priority = wakeup_priority(b, wait->tsk);\r\nstruct rb_node *next;\r\nnext = rb_next(&wait->node);\r\nif (chain_wakeup(next, priority)) {\r\nu32 seqno = intel_engine_get_seqno(engine);\r\nwhile (i915_seqno_passed(seqno, to_wait(next)->seqno)) {\r\nstruct rb_node *n = rb_next(next);\r\n__intel_breadcrumbs_finish(b, to_wait(next));\r\nnext = n;\r\nif (!chain_wakeup(next, priority))\r\nbreak;\r\n}\r\n}\r\n__intel_breadcrumbs_next(engine, next);\r\n} else {\r\nGEM_BUG_ON(rb_first(&b->waiters) == &wait->node);\r\n}\r\nGEM_BUG_ON(RB_EMPTY_NODE(&wait->node));\r\nrb_erase(&wait->node, &b->waiters);\r\nout:\r\nGEM_BUG_ON(b->irq_wait == wait);\r\nGEM_BUG_ON(rb_first(&b->waiters) !=\r\n(b->irq_wait ? &b->irq_wait->node : NULL));\r\n}\r\nvoid intel_engine_remove_wait(struct intel_engine_cs *engine,\r\nstruct intel_wait *wait)\r\n{\r\nstruct intel_breadcrumbs *b = &engine->breadcrumbs;\r\nif (RB_EMPTY_NODE(&wait->node)) {\r\nGEM_BUG_ON(READ_ONCE(b->irq_wait) == wait);\r\nreturn;\r\n}\r\nspin_lock_irq(&b->rb_lock);\r\n__intel_engine_remove_wait(engine, wait);\r\nspin_unlock_irq(&b->rb_lock);\r\n}\r\nstatic bool signal_valid(const struct drm_i915_gem_request *request)\r\n{\r\nreturn intel_wait_check_request(&request->signaling.wait, request);\r\n}\r\nstatic bool signal_complete(const struct drm_i915_gem_request *request)\r\n{\r\nif (!request)\r\nreturn false;\r\nif (intel_wait_complete(&request->signaling.wait))\r\nreturn signal_valid(request);\r\nif (__i915_request_irq_complete(request))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic struct drm_i915_gem_request *to_signaler(struct rb_node *rb)\r\n{\r\nreturn rb_entry(rb, struct drm_i915_gem_request, signaling.node);\r\n}\r\nstatic void signaler_set_rtpriority(void)\r\n{\r\nstruct sched_param param = { .sched_priority = 1 };\r\nsched_setscheduler_nocheck(current, SCHED_FIFO, &param);\r\n}\r\nstatic int intel_breadcrumbs_signaler(void *arg)\r\n{\r\nstruct intel_engine_cs *engine = arg;\r\nstruct intel_breadcrumbs *b = &engine->breadcrumbs;\r\nstruct drm_i915_gem_request *request;\r\nsignaler_set_rtpriority();\r\ndo {\r\nbool do_schedule = true;\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nrcu_read_lock();\r\nrequest = rcu_dereference(b->first_signal);\r\nif (request)\r\nrequest = i915_gem_request_get_rcu(request);\r\nrcu_read_unlock();\r\nif (signal_complete(request)) {\r\nlocal_bh_disable();\r\ndma_fence_signal(&request->fence);\r\nlocal_bh_enable();\r\nspin_lock_irq(&b->rb_lock);\r\n__intel_engine_remove_wait(engine,\r\n&request->signaling.wait);\r\nif (request == rcu_access_pointer(b->first_signal)) {\r\nstruct rb_node *rb =\r\nrb_next(&request->signaling.node);\r\nrcu_assign_pointer(b->first_signal,\r\nrb ? to_signaler(rb) : NULL);\r\n}\r\nrb_erase(&request->signaling.node, &b->signals);\r\nRB_CLEAR_NODE(&request->signaling.node);\r\nspin_unlock_irq(&b->rb_lock);\r\ni915_gem_request_put(request);\r\ndo_schedule = need_resched();\r\n}\r\nif (unlikely(do_schedule)) {\r\nDEFINE_WAIT(exec);\r\nif (kthread_should_park())\r\nkthread_parkme();\r\nif (kthread_should_stop()) {\r\nGEM_BUG_ON(request);\r\nbreak;\r\n}\r\nif (request)\r\nadd_wait_queue(&request->execute, &exec);\r\nschedule();\r\nif (request)\r\nremove_wait_queue(&request->execute, &exec);\r\n}\r\ni915_gem_request_put(request);\r\n} while (1);\r\n__set_current_state(TASK_RUNNING);\r\nreturn 0;\r\n}\r\nvoid intel_engine_enable_signaling(struct drm_i915_gem_request *request,\r\nbool wakeup)\r\n{\r\nstruct intel_engine_cs *engine = request->engine;\r\nstruct intel_breadcrumbs *b = &engine->breadcrumbs;\r\nu32 seqno;\r\nGEM_BUG_ON(!irqs_disabled());\r\nlockdep_assert_held(&request->lock);\r\nseqno = i915_gem_request_global_seqno(request);\r\nif (!seqno)\r\nreturn;\r\nrequest->signaling.wait.tsk = b->signaler;\r\nrequest->signaling.wait.request = request;\r\nrequest->signaling.wait.seqno = seqno;\r\ni915_gem_request_get(request);\r\nspin_lock(&b->rb_lock);\r\nwakeup &= __intel_engine_add_wait(engine, &request->signaling.wait);\r\nif (!__i915_gem_request_completed(request, seqno)) {\r\nstruct rb_node *parent, **p;\r\nbool first;\r\nparent = NULL;\r\nfirst = true;\r\np = &b->signals.rb_node;\r\nwhile (*p) {\r\nparent = *p;\r\nif (i915_seqno_passed(seqno,\r\nto_signaler(parent)->signaling.wait.seqno)) {\r\np = &parent->rb_right;\r\nfirst = false;\r\n} else {\r\np = &parent->rb_left;\r\n}\r\n}\r\nrb_link_node(&request->signaling.node, parent, p);\r\nrb_insert_color(&request->signaling.node, &b->signals);\r\nif (first)\r\nrcu_assign_pointer(b->first_signal, request);\r\n} else {\r\n__intel_engine_remove_wait(engine, &request->signaling.wait);\r\ni915_gem_request_put(request);\r\nwakeup = false;\r\n}\r\nspin_unlock(&b->rb_lock);\r\nif (wakeup)\r\nwake_up_process(b->signaler);\r\n}\r\nvoid intel_engine_cancel_signaling(struct drm_i915_gem_request *request)\r\n{\r\nstruct intel_engine_cs *engine = request->engine;\r\nstruct intel_breadcrumbs *b = &engine->breadcrumbs;\r\nGEM_BUG_ON(!irqs_disabled());\r\nlockdep_assert_held(&request->lock);\r\nGEM_BUG_ON(!request->signaling.wait.seqno);\r\nspin_lock(&b->rb_lock);\r\nif (!RB_EMPTY_NODE(&request->signaling.node)) {\r\nif (request == rcu_access_pointer(b->first_signal)) {\r\nstruct rb_node *rb =\r\nrb_next(&request->signaling.node);\r\nrcu_assign_pointer(b->first_signal,\r\nrb ? to_signaler(rb) : NULL);\r\n}\r\nrb_erase(&request->signaling.node, &b->signals);\r\nRB_CLEAR_NODE(&request->signaling.node);\r\ni915_gem_request_put(request);\r\n}\r\n__intel_engine_remove_wait(engine, &request->signaling.wait);\r\nspin_unlock(&b->rb_lock);\r\nrequest->signaling.wait.seqno = 0;\r\n}\r\nint intel_engine_init_breadcrumbs(struct intel_engine_cs *engine)\r\n{\r\nstruct intel_breadcrumbs *b = &engine->breadcrumbs;\r\nstruct task_struct *tsk;\r\nspin_lock_init(&b->rb_lock);\r\nspin_lock_init(&b->irq_lock);\r\nsetup_timer(&b->fake_irq,\r\nintel_breadcrumbs_fake_irq,\r\n(unsigned long)engine);\r\nsetup_timer(&b->hangcheck,\r\nintel_breadcrumbs_hangcheck,\r\n(unsigned long)engine);\r\ntsk = kthread_run(intel_breadcrumbs_signaler, engine,\r\n"i915/signal:%d", engine->id);\r\nif (IS_ERR(tsk))\r\nreturn PTR_ERR(tsk);\r\nb->signaler = tsk;\r\nreturn 0;\r\n}\r\nstatic void cancel_fake_irq(struct intel_engine_cs *engine)\r\n{\r\nstruct intel_breadcrumbs *b = &engine->breadcrumbs;\r\ndel_timer_sync(&b->hangcheck);\r\ndel_timer_sync(&b->fake_irq);\r\nclear_bit(engine->id, &engine->i915->gpu_error.missed_irq_rings);\r\n}\r\nvoid intel_engine_reset_breadcrumbs(struct intel_engine_cs *engine)\r\n{\r\nstruct intel_breadcrumbs *b = &engine->breadcrumbs;\r\ncancel_fake_irq(engine);\r\nspin_lock_irq(&b->irq_lock);\r\nif (b->irq_enabled)\r\nirq_enable(engine);\r\nelse\r\nirq_disable(engine);\r\nclear_bit(ENGINE_IRQ_BREADCRUMB, &engine->irq_posted);\r\nif (b->irq_armed)\r\nenable_fake_irq(b);\r\nspin_unlock_irq(&b->irq_lock);\r\n}\r\nvoid intel_engine_fini_breadcrumbs(struct intel_engine_cs *engine)\r\n{\r\nstruct intel_breadcrumbs *b = &engine->breadcrumbs;\r\nWARN_ON(READ_ONCE(b->irq_wait));\r\nWARN_ON(!RB_EMPTY_ROOT(&b->waiters));\r\nWARN_ON(rcu_access_pointer(b->first_signal));\r\nWARN_ON(!RB_EMPTY_ROOT(&b->signals));\r\nif (!IS_ERR_OR_NULL(b->signaler))\r\nkthread_stop(b->signaler);\r\ncancel_fake_irq(engine);\r\n}\r\nbool intel_breadcrumbs_busy(struct intel_engine_cs *engine)\r\n{\r\nstruct intel_breadcrumbs *b = &engine->breadcrumbs;\r\nbool busy = false;\r\nspin_lock_irq(&b->rb_lock);\r\nif (b->irq_wait) {\r\nwake_up_process(b->irq_wait->tsk);\r\nbusy = true;\r\n}\r\nif (rcu_access_pointer(b->first_signal)) {\r\nwake_up_process(b->signaler);\r\nbusy = true;\r\n}\r\nspin_unlock_irq(&b->rb_lock);\r\nreturn busy;\r\n}
