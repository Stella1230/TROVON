void\r\ngf119_sor_dp_watermark(struct nvkm_ior *sor, int head, u8 watermark)\r\n{\r\nstruct nvkm_device *device = sor->disp->engine.subdev.device;\r\nconst u32 hoff = head * 0x800;\r\nnvkm_mask(device, 0x616610 + hoff, 0x0800003f, 0x08000000 | watermark);\r\n}\r\nvoid\r\ngf119_sor_dp_audio_sym(struct nvkm_ior *sor, int head, u16 h, u32 v)\r\n{\r\nstruct nvkm_device *device = sor->disp->engine.subdev.device;\r\nconst u32 hoff = head * 0x800;\r\nnvkm_mask(device, 0x616620 + hoff, 0x0000ffff, h);\r\nnvkm_mask(device, 0x616624 + hoff, 0x00ffffff, v);\r\n}\r\nvoid\r\ngf119_sor_dp_audio(struct nvkm_ior *sor, int head, bool enable)\r\n{\r\nstruct nvkm_device *device = sor->disp->engine.subdev.device;\r\nconst u32 hoff = 0x800 * head;\r\nconst u32 data = 0x80000000 | (0x00000001 * enable);\r\nconst u32 mask = 0x8000000d;\r\nnvkm_mask(device, 0x616618 + hoff, mask, data);\r\nnvkm_msec(device, 2000,\r\nif (!(nvkm_rd32(device, 0x616618 + hoff) & 0x80000000))\r\nbreak;\r\n);\r\n}\r\nvoid\r\ngf119_sor_dp_vcpi(struct nvkm_ior *sor, int head,\r\nu8 slot, u8 slot_nr, u16 pbn, u16 aligned)\r\n{\r\nstruct nvkm_device *device = sor->disp->engine.subdev.device;\r\nconst u32 hoff = head * 0x800;\r\nnvkm_mask(device, 0x616588 + hoff, 0x00003f3f, (slot_nr << 8) | slot);\r\nnvkm_mask(device, 0x61658c + hoff, 0xffffffff, (aligned << 16) | pbn);\r\n}\r\nvoid\r\ngf119_sor_dp_drive(struct nvkm_ior *sor, int ln, int pc, int dc, int pe, int pu)\r\n{\r\nstruct nvkm_device *device = sor->disp->engine.subdev.device;\r\nconst u32 loff = nv50_sor_link(sor);\r\nconst u32 shift = sor->func->dp.lanes[ln] * 8;\r\nu32 data[4];\r\ndata[0] = nvkm_rd32(device, 0x61c118 + loff) & ~(0x000000ff << shift);\r\ndata[1] = nvkm_rd32(device, 0x61c120 + loff) & ~(0x000000ff << shift);\r\ndata[2] = nvkm_rd32(device, 0x61c130 + loff);\r\nif ((data[2] & 0x0000ff00) < (pu << 8) || ln == 0)\r\ndata[2] = (data[2] & ~0x0000ff00) | (pu << 8);\r\nnvkm_wr32(device, 0x61c118 + loff, data[0] | (dc << shift));\r\nnvkm_wr32(device, 0x61c120 + loff, data[1] | (pe << shift));\r\nnvkm_wr32(device, 0x61c130 + loff, data[2]);\r\ndata[3] = nvkm_rd32(device, 0x61c13c + loff) & ~(0x000000ff << shift);\r\nnvkm_wr32(device, 0x61c13c + loff, data[3] | (pc << shift));\r\n}\r\nvoid\r\ngf119_sor_dp_pattern(struct nvkm_ior *sor, int pattern)\r\n{\r\nstruct nvkm_device *device = sor->disp->engine.subdev.device;\r\nconst u32 soff = nv50_ior_base(sor);\r\nnvkm_mask(device, 0x61c110 + soff, 0x0f0f0f0f, 0x01010101 * pattern);\r\n}\r\nint\r\ngf119_sor_dp_links(struct nvkm_ior *sor, struct nvkm_i2c_aux *aux)\r\n{\r\nstruct nvkm_device *device = sor->disp->engine.subdev.device;\r\nconst u32 soff = nv50_ior_base(sor);\r\nconst u32 loff = nv50_sor_link(sor);\r\nu32 dpctrl = 0x00000000;\r\nu32 clksor = 0x00000000;\r\nclksor |= sor->dp.bw << 18;\r\ndpctrl |= ((1 << sor->dp.nr) - 1) << 16;\r\nif (sor->dp.mst)\r\ndpctrl |= 0x40000000;\r\nif (sor->dp.ef)\r\ndpctrl |= 0x00004000;\r\nnvkm_mask(device, 0x612300 + soff, 0x007c0000, clksor);\r\nnvkm_mask(device, 0x61c10c + loff, 0x401f4000, dpctrl);\r\nreturn 0;\r\n}\r\nvoid\r\ngf119_sor_clock(struct nvkm_ior *sor)\r\n{\r\nstruct nvkm_device *device = sor->disp->engine.subdev.device;\r\nconst int div = sor->asy.link == 3;\r\nconst u32 soff = nv50_ior_base(sor);\r\nif (sor->asy.proto == TMDS) {\r\nnvkm_mask(device, 0x612300 + soff, 0x007c0000, 0x0a << 18);\r\n}\r\nnvkm_mask(device, 0x612300 + soff, 0x00000707, (div << 8) | div);\r\n}\r\nvoid\r\ngf119_sor_state(struct nvkm_ior *sor, struct nvkm_ior_state *state)\r\n{\r\nstruct nvkm_device *device = sor->disp->engine.subdev.device;\r\nconst u32 coff = (state == &sor->asy) * 0x20000 + sor->id * 0x20;\r\nu32 ctrl = nvkm_rd32(device, 0x640200 + coff);\r\nstate->proto_evo = (ctrl & 0x00000f00) >> 8;\r\nswitch (state->proto_evo) {\r\ncase 0: state->proto = LVDS; state->link = 1; break;\r\ncase 1: state->proto = TMDS; state->link = 1; break;\r\ncase 2: state->proto = TMDS; state->link = 2; break;\r\ncase 5: state->proto = TMDS; state->link = 3; break;\r\ncase 8: state->proto = DP; state->link = 1; break;\r\ncase 9: state->proto = DP; state->link = 2; break;\r\ndefault:\r\nstate->proto = UNKNOWN;\r\nbreak;\r\n}\r\nstate->head = ctrl & 0x0000000f;\r\n}\r\nint\r\ngf119_sor_new_(const struct nvkm_ior_func *func, struct nvkm_disp *disp, int id)\r\n{\r\nstruct nvkm_device *device = disp->engine.subdev.device;\r\nif (!(nvkm_rd32(device, 0x612004) & (0x00000100 << id)))\r\nreturn 0;\r\nreturn nvkm_ior_new_(func, disp, SOR, id);\r\n}\r\nint\r\ngf119_sor_new(struct nvkm_disp *disp, int id)\r\n{\r\nreturn gf119_sor_new_(&gf119_sor, disp, id);\r\n}
