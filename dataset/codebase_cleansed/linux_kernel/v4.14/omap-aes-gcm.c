static void omap_aes_gcm_finish_req(struct omap_aes_dev *dd, int ret)\r\n{\r\nstruct aead_request *req = dd->aead_req;\r\ndd->flags &= ~FLAGS_BUSY;\r\ndd->in_sg = NULL;\r\ndd->out_sg = NULL;\r\nreq->base.complete(&req->base, ret);\r\n}\r\nstatic void omap_aes_gcm_done_task(struct omap_aes_dev *dd)\r\n{\r\nu8 *tag;\r\nint alen, clen, i, ret = 0, nsg;\r\nstruct omap_aes_reqctx *rctx;\r\nalen = ALIGN(dd->assoc_len, AES_BLOCK_SIZE);\r\nclen = ALIGN(dd->total, AES_BLOCK_SIZE);\r\nrctx = aead_request_ctx(dd->aead_req);\r\nnsg = !!(dd->assoc_len && dd->total);\r\ndma_sync_sg_for_device(dd->dev, dd->out_sg, dd->out_sg_len,\r\nDMA_FROM_DEVICE);\r\ndma_unmap_sg(dd->dev, dd->in_sg, dd->in_sg_len, DMA_TO_DEVICE);\r\ndma_unmap_sg(dd->dev, dd->out_sg, dd->out_sg_len, DMA_FROM_DEVICE);\r\nomap_aes_crypt_dma_stop(dd);\r\nomap_crypto_cleanup(dd->out_sg, dd->orig_out,\r\ndd->aead_req->assoclen, dd->total,\r\nFLAGS_OUT_DATA_ST_SHIFT, dd->flags);\r\nif (dd->flags & FLAGS_ENCRYPT)\r\nscatterwalk_map_and_copy(rctx->auth_tag,\r\ndd->aead_req->dst,\r\ndd->total + dd->aead_req->assoclen,\r\ndd->authsize, 1);\r\nomap_crypto_cleanup(&dd->in_sgl[0], NULL, 0, alen,\r\nFLAGS_ASSOC_DATA_ST_SHIFT, dd->flags);\r\nomap_crypto_cleanup(&dd->in_sgl[nsg], NULL, 0, clen,\r\nFLAGS_IN_DATA_ST_SHIFT, dd->flags);\r\nif (!(dd->flags & FLAGS_ENCRYPT)) {\r\ntag = (u8 *)rctx->auth_tag;\r\nfor (i = 0; i < dd->authsize; i++) {\r\nif (tag[i]) {\r\ndev_err(dd->dev, "GCM decryption: Tag Message is wrong\n");\r\nret = -EBADMSG;\r\n}\r\n}\r\n}\r\nomap_aes_gcm_finish_req(dd, ret);\r\nomap_aes_gcm_handle_queue(dd, NULL);\r\n}\r\nstatic int omap_aes_gcm_copy_buffers(struct omap_aes_dev *dd,\r\nstruct aead_request *req)\r\n{\r\nint alen, clen, cryptlen, assoclen, ret;\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nunsigned int authlen = crypto_aead_authsize(aead);\r\nstruct scatterlist *tmp, sg_arr[2];\r\nint nsg;\r\nu16 flags;\r\nassoclen = req->assoclen;\r\ncryptlen = req->cryptlen;\r\nif (dd->flags & FLAGS_RFC4106_GCM)\r\nassoclen -= 8;\r\nif (!(dd->flags & FLAGS_ENCRYPT))\r\ncryptlen -= authlen;\r\nalen = ALIGN(assoclen, AES_BLOCK_SIZE);\r\nclen = ALIGN(cryptlen, AES_BLOCK_SIZE);\r\nnsg = !!(assoclen && cryptlen);\r\nomap_aes_clear_copy_flags(dd);\r\nsg_init_table(dd->in_sgl, nsg + 1);\r\nif (assoclen) {\r\ntmp = req->src;\r\nret = omap_crypto_align_sg(&tmp, assoclen,\r\nAES_BLOCK_SIZE, dd->in_sgl,\r\nOMAP_CRYPTO_COPY_DATA |\r\nOMAP_CRYPTO_ZERO_BUF |\r\nOMAP_CRYPTO_FORCE_SINGLE_ENTRY,\r\nFLAGS_ASSOC_DATA_ST_SHIFT,\r\n&dd->flags);\r\n}\r\nif (cryptlen) {\r\ntmp = scatterwalk_ffwd(sg_arr, req->src, req->assoclen);\r\nret = omap_crypto_align_sg(&tmp, cryptlen,\r\nAES_BLOCK_SIZE, &dd->in_sgl[nsg],\r\nOMAP_CRYPTO_COPY_DATA |\r\nOMAP_CRYPTO_ZERO_BUF |\r\nOMAP_CRYPTO_FORCE_SINGLE_ENTRY,\r\nFLAGS_IN_DATA_ST_SHIFT,\r\n&dd->flags);\r\n}\r\ndd->in_sg = dd->in_sgl;\r\ndd->total = cryptlen;\r\ndd->assoc_len = assoclen;\r\ndd->authsize = authlen;\r\ndd->out_sg = req->dst;\r\ndd->orig_out = req->dst;\r\ndd->out_sg = scatterwalk_ffwd(sg_arr, req->dst, assoclen);\r\nflags = 0;\r\nif (req->src == req->dst || dd->out_sg == sg_arr)\r\nflags |= OMAP_CRYPTO_FORCE_COPY;\r\nret = omap_crypto_align_sg(&dd->out_sg, cryptlen,\r\nAES_BLOCK_SIZE, &dd->out_sgl,\r\nflags,\r\nFLAGS_OUT_DATA_ST_SHIFT, &dd->flags);\r\nif (ret)\r\nreturn ret;\r\ndd->in_sg_len = sg_nents_for_len(dd->in_sg, alen + clen);\r\ndd->out_sg_len = sg_nents_for_len(dd->out_sg, clen);\r\nreturn 0;\r\n}\r\nstatic void omap_aes_gcm_complete(struct crypto_async_request *req, int err)\r\n{\r\nstruct omap_aes_gcm_result *res = req->data;\r\nif (err == -EINPROGRESS)\r\nreturn;\r\nres->err = err;\r\ncomplete(&res->completion);\r\n}\r\nstatic int do_encrypt_iv(struct aead_request *req, u32 *tag, u32 *iv)\r\n{\r\nstruct scatterlist iv_sg, tag_sg;\r\nstruct skcipher_request *sk_req;\r\nstruct omap_aes_gcm_result result;\r\nstruct omap_aes_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));\r\nint ret = 0;\r\nsk_req = skcipher_request_alloc(ctx->ctr, GFP_KERNEL);\r\nif (!sk_req) {\r\npr_err("skcipher: Failed to allocate request\n");\r\nreturn -1;\r\n}\r\ninit_completion(&result.completion);\r\nsg_init_one(&iv_sg, iv, AES_BLOCK_SIZE);\r\nsg_init_one(&tag_sg, tag, AES_BLOCK_SIZE);\r\nskcipher_request_set_callback(sk_req, CRYPTO_TFM_REQ_MAY_BACKLOG,\r\nomap_aes_gcm_complete, &result);\r\nret = crypto_skcipher_setkey(ctx->ctr, (u8 *)ctx->key, ctx->keylen);\r\nskcipher_request_set_crypt(sk_req, &iv_sg, &tag_sg, AES_BLOCK_SIZE,\r\nNULL);\r\nret = crypto_skcipher_encrypt(sk_req);\r\nswitch (ret) {\r\ncase 0:\r\nbreak;\r\ncase -EINPROGRESS:\r\ncase -EBUSY:\r\nret = wait_for_completion_interruptible(&result.completion);\r\nif (!ret) {\r\nret = result.err;\r\nif (!ret) {\r\nreinit_completion(&result.completion);\r\nbreak;\r\n}\r\n}\r\ndefault:\r\npr_err("Encryption of IV failed for GCM mode");\r\nbreak;\r\n}\r\nskcipher_request_free(sk_req);\r\nreturn ret;\r\n}\r\nvoid omap_aes_gcm_dma_out_callback(void *data)\r\n{\r\nstruct omap_aes_dev *dd = data;\r\nstruct omap_aes_reqctx *rctx;\r\nint i, val;\r\nu32 *auth_tag, tag[4];\r\nif (!(dd->flags & FLAGS_ENCRYPT))\r\nscatterwalk_map_and_copy(tag, dd->aead_req->src,\r\ndd->total + dd->aead_req->assoclen,\r\ndd->authsize, 0);\r\nrctx = aead_request_ctx(dd->aead_req);\r\nauth_tag = (u32 *)rctx->auth_tag;\r\nfor (i = 0; i < 4; i++) {\r\nval = omap_aes_read(dd, AES_REG_TAG_N(dd, i));\r\nauth_tag[i] = val ^ auth_tag[i];\r\nif (!(dd->flags & FLAGS_ENCRYPT))\r\nauth_tag[i] = auth_tag[i] ^ tag[i];\r\n}\r\nomap_aes_gcm_done_task(dd);\r\n}\r\nstatic int omap_aes_gcm_handle_queue(struct omap_aes_dev *dd,\r\nstruct aead_request *req)\r\n{\r\nstruct omap_aes_ctx *ctx;\r\nstruct aead_request *backlog;\r\nstruct omap_aes_reqctx *rctx;\r\nunsigned long flags;\r\nint err, ret = 0;\r\nspin_lock_irqsave(&dd->lock, flags);\r\nif (req)\r\nret = aead_enqueue_request(&dd->aead_queue, req);\r\nif (dd->flags & FLAGS_BUSY) {\r\nspin_unlock_irqrestore(&dd->lock, flags);\r\nreturn ret;\r\n}\r\nbacklog = aead_get_backlog(&dd->aead_queue);\r\nreq = aead_dequeue_request(&dd->aead_queue);\r\nif (req)\r\ndd->flags |= FLAGS_BUSY;\r\nspin_unlock_irqrestore(&dd->lock, flags);\r\nif (!req)\r\nreturn ret;\r\nif (backlog)\r\nbacklog->base.complete(&backlog->base, -EINPROGRESS);\r\nctx = crypto_aead_ctx(crypto_aead_reqtfm(req));\r\nrctx = aead_request_ctx(req);\r\ndd->ctx = ctx;\r\nrctx->dd = dd;\r\ndd->aead_req = req;\r\nrctx->mode &= FLAGS_MODE_MASK;\r\ndd->flags = (dd->flags & ~FLAGS_MODE_MASK) | rctx->mode;\r\nerr = omap_aes_gcm_copy_buffers(dd, req);\r\nif (err)\r\nreturn err;\r\nerr = omap_aes_write_ctrl(dd);\r\nif (!err)\r\nerr = omap_aes_crypt_dma_start(dd);\r\nif (err) {\r\nomap_aes_gcm_finish_req(dd, err);\r\nomap_aes_gcm_handle_queue(dd, NULL);\r\n}\r\nreturn ret;\r\n}\r\nstatic int omap_aes_gcm_crypt(struct aead_request *req, unsigned long mode)\r\n{\r\nstruct omap_aes_reqctx *rctx = aead_request_ctx(req);\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nunsigned int authlen = crypto_aead_authsize(aead);\r\nstruct omap_aes_dev *dd;\r\n__be32 counter = cpu_to_be32(1);\r\nint err, assoclen;\r\nmemset(rctx->auth_tag, 0, sizeof(rctx->auth_tag));\r\nmemcpy(rctx->iv + 12, &counter, 4);\r\nerr = do_encrypt_iv(req, (u32 *)rctx->auth_tag, (u32 *)rctx->iv);\r\nif (err)\r\nreturn err;\r\nif (mode & FLAGS_RFC4106_GCM)\r\nassoclen = req->assoclen - 8;\r\nelse\r\nassoclen = req->assoclen;\r\nif (assoclen + req->cryptlen == 0) {\r\nscatterwalk_map_and_copy(rctx->auth_tag, req->dst, 0, authlen,\r\n1);\r\nreturn 0;\r\n}\r\ndd = omap_aes_find_dev(rctx);\r\nif (!dd)\r\nreturn -ENODEV;\r\nrctx->mode = mode;\r\nreturn omap_aes_gcm_handle_queue(dd, req);\r\n}\r\nint omap_aes_gcm_encrypt(struct aead_request *req)\r\n{\r\nstruct omap_aes_reqctx *rctx = aead_request_ctx(req);\r\nmemcpy(rctx->iv, req->iv, 12);\r\nreturn omap_aes_gcm_crypt(req, FLAGS_ENCRYPT | FLAGS_GCM);\r\n}\r\nint omap_aes_gcm_decrypt(struct aead_request *req)\r\n{\r\nstruct omap_aes_reqctx *rctx = aead_request_ctx(req);\r\nmemcpy(rctx->iv, req->iv, 12);\r\nreturn omap_aes_gcm_crypt(req, FLAGS_GCM);\r\n}\r\nint omap_aes_4106gcm_encrypt(struct aead_request *req)\r\n{\r\nstruct omap_aes_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));\r\nstruct omap_aes_reqctx *rctx = aead_request_ctx(req);\r\nmemcpy(rctx->iv, ctx->nonce, 4);\r\nmemcpy(rctx->iv + 4, req->iv, 8);\r\nreturn omap_aes_gcm_crypt(req, FLAGS_ENCRYPT | FLAGS_GCM |\r\nFLAGS_RFC4106_GCM);\r\n}\r\nint omap_aes_4106gcm_decrypt(struct aead_request *req)\r\n{\r\nstruct omap_aes_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));\r\nstruct omap_aes_reqctx *rctx = aead_request_ctx(req);\r\nmemcpy(rctx->iv, ctx->nonce, 4);\r\nmemcpy(rctx->iv + 4, req->iv, 8);\r\nreturn omap_aes_gcm_crypt(req, FLAGS_GCM | FLAGS_RFC4106_GCM);\r\n}\r\nint omap_aes_gcm_setkey(struct crypto_aead *tfm, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct omap_aes_ctx *ctx = crypto_aead_ctx(tfm);\r\nif (keylen != AES_KEYSIZE_128 && keylen != AES_KEYSIZE_192 &&\r\nkeylen != AES_KEYSIZE_256)\r\nreturn -EINVAL;\r\nmemcpy(ctx->key, key, keylen);\r\nctx->keylen = keylen;\r\nreturn 0;\r\n}\r\nint omap_aes_4106gcm_setkey(struct crypto_aead *tfm, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct omap_aes_ctx *ctx = crypto_aead_ctx(tfm);\r\nif (keylen < 4)\r\nreturn -EINVAL;\r\nkeylen -= 4;\r\nif (keylen != AES_KEYSIZE_128 && keylen != AES_KEYSIZE_192 &&\r\nkeylen != AES_KEYSIZE_256)\r\nreturn -EINVAL;\r\nmemcpy(ctx->key, key, keylen);\r\nmemcpy(ctx->nonce, key + keylen, 4);\r\nctx->keylen = keylen;\r\nreturn 0;\r\n}
