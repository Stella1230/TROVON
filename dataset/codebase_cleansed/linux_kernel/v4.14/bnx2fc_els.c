static void bnx2fc_rrq_compl(struct bnx2fc_els_cb_arg *cb_arg)\r\n{\r\nstruct bnx2fc_cmd *orig_io_req;\r\nstruct bnx2fc_cmd *rrq_req;\r\nint rc = 0;\r\nBUG_ON(!cb_arg);\r\nrrq_req = cb_arg->io_req;\r\norig_io_req = cb_arg->aborted_io_req;\r\nBUG_ON(!orig_io_req);\r\nBNX2FC_ELS_DBG("rrq_compl: orig xid = 0x%x, rrq_xid = 0x%x\n",\r\norig_io_req->xid, rrq_req->xid);\r\nkref_put(&orig_io_req->refcount, bnx2fc_cmd_release);\r\nif (test_and_clear_bit(BNX2FC_FLAG_ELS_TIMEOUT, &rrq_req->req_flags)) {\r\nBNX2FC_ELS_DBG("rrq xid - 0x%x timed out, clean it up\n",\r\nrrq_req->xid);\r\nif (rrq_req->on_active_queue) {\r\nlist_del_init(&rrq_req->link);\r\nrrq_req->on_active_queue = 0;\r\nrc = bnx2fc_initiate_cleanup(rrq_req);\r\nBUG_ON(rc);\r\n}\r\n}\r\nkfree(cb_arg);\r\n}\r\nint bnx2fc_send_rrq(struct bnx2fc_cmd *aborted_io_req)\r\n{\r\nstruct fc_els_rrq rrq;\r\nstruct bnx2fc_rport *tgt = aborted_io_req->tgt;\r\nstruct fc_lport *lport = NULL;\r\nstruct bnx2fc_els_cb_arg *cb_arg = NULL;\r\nu32 sid = 0;\r\nu32 r_a_tov = 0;\r\nunsigned long start = jiffies;\r\nint rc;\r\nif (!test_bit(BNX2FC_FLAG_SESSION_READY, &tgt->flags))\r\nreturn -EINVAL;\r\nlport = tgt->rdata->local_port;\r\nsid = tgt->sid;\r\nr_a_tov = lport->r_a_tov;\r\nBNX2FC_ELS_DBG("Sending RRQ orig_xid = 0x%x\n",\r\naborted_io_req->xid);\r\nmemset(&rrq, 0, sizeof(rrq));\r\ncb_arg = kzalloc(sizeof(struct bnx2fc_els_cb_arg), GFP_NOIO);\r\nif (!cb_arg) {\r\nprintk(KERN_ERR PFX "Unable to allocate cb_arg for RRQ\n");\r\nrc = -ENOMEM;\r\ngoto rrq_err;\r\n}\r\ncb_arg->aborted_io_req = aborted_io_req;\r\nrrq.rrq_cmd = ELS_RRQ;\r\nhton24(rrq.rrq_s_id, sid);\r\nrrq.rrq_ox_id = htons(aborted_io_req->xid);\r\nrrq.rrq_rx_id = htons(aborted_io_req->task->rxwr_txrd.var_ctx.rx_id);\r\nretry_rrq:\r\nrc = bnx2fc_initiate_els(tgt, ELS_RRQ, &rrq, sizeof(rrq),\r\nbnx2fc_rrq_compl, cb_arg,\r\nr_a_tov);\r\nif (rc == -ENOMEM) {\r\nif (time_after(jiffies, start + (10 * HZ))) {\r\nBNX2FC_ELS_DBG("rrq Failed\n");\r\nrc = FAILED;\r\ngoto rrq_err;\r\n}\r\nmsleep(20);\r\ngoto retry_rrq;\r\n}\r\nrrq_err:\r\nif (rc) {\r\nBNX2FC_ELS_DBG("RRQ failed - release orig io req 0x%x\n",\r\naborted_io_req->xid);\r\nkfree(cb_arg);\r\nspin_lock_bh(&tgt->tgt_lock);\r\nkref_put(&aborted_io_req->refcount, bnx2fc_cmd_release);\r\nspin_unlock_bh(&tgt->tgt_lock);\r\n}\r\nreturn rc;\r\n}\r\nstatic void bnx2fc_l2_els_compl(struct bnx2fc_els_cb_arg *cb_arg)\r\n{\r\nstruct bnx2fc_cmd *els_req;\r\nstruct bnx2fc_rport *tgt;\r\nstruct bnx2fc_mp_req *mp_req;\r\nstruct fc_frame_header *fc_hdr;\r\nunsigned char *buf;\r\nvoid *resp_buf;\r\nu32 resp_len, hdr_len;\r\nu16 l2_oxid;\r\nint frame_len;\r\nint rc = 0;\r\nl2_oxid = cb_arg->l2_oxid;\r\nBNX2FC_ELS_DBG("ELS COMPL - l2_oxid = 0x%x\n", l2_oxid);\r\nels_req = cb_arg->io_req;\r\nif (test_and_clear_bit(BNX2FC_FLAG_ELS_TIMEOUT, &els_req->req_flags)) {\r\nif (els_req->on_active_queue) {\r\nlist_del_init(&els_req->link);\r\nels_req->on_active_queue = 0;\r\nrc = bnx2fc_initiate_cleanup(els_req);\r\nBUG_ON(rc);\r\n}\r\ngoto free_arg;\r\n}\r\ntgt = els_req->tgt;\r\nmp_req = &(els_req->mp_req);\r\nfc_hdr = &(mp_req->resp_fc_hdr);\r\nresp_len = mp_req->resp_len;\r\nresp_buf = mp_req->resp_buf;\r\nbuf = kzalloc(PAGE_SIZE, GFP_ATOMIC);\r\nif (!buf) {\r\nprintk(KERN_ERR PFX "Unable to alloc mp buf\n");\r\ngoto free_arg;\r\n}\r\nhdr_len = sizeof(*fc_hdr);\r\nif (hdr_len + resp_len > PAGE_SIZE) {\r\nprintk(KERN_ERR PFX "l2_els_compl: resp len is "\r\n"beyond page size\n");\r\ngoto free_buf;\r\n}\r\nmemcpy(buf, fc_hdr, hdr_len);\r\nmemcpy(buf + hdr_len, resp_buf, resp_len);\r\nframe_len = hdr_len + resp_len;\r\nbnx2fc_process_l2_frame_compl(tgt, buf, frame_len, l2_oxid);\r\nfree_buf:\r\nkfree(buf);\r\nfree_arg:\r\nkfree(cb_arg);\r\n}\r\nint bnx2fc_send_adisc(struct bnx2fc_rport *tgt, struct fc_frame *fp)\r\n{\r\nstruct fc_els_adisc *adisc;\r\nstruct fc_frame_header *fh;\r\nstruct bnx2fc_els_cb_arg *cb_arg;\r\nstruct fc_lport *lport = tgt->rdata->local_port;\r\nu32 r_a_tov = lport->r_a_tov;\r\nint rc;\r\nfh = fc_frame_header_get(fp);\r\ncb_arg = kzalloc(sizeof(struct bnx2fc_els_cb_arg), GFP_ATOMIC);\r\nif (!cb_arg) {\r\nprintk(KERN_ERR PFX "Unable to allocate cb_arg for ADISC\n");\r\nreturn -ENOMEM;\r\n}\r\ncb_arg->l2_oxid = ntohs(fh->fh_ox_id);\r\nBNX2FC_ELS_DBG("send ADISC: l2_oxid = 0x%x\n", cb_arg->l2_oxid);\r\nadisc = fc_frame_payload_get(fp, sizeof(*adisc));\r\nrc = bnx2fc_initiate_els(tgt, ELS_ADISC, adisc, sizeof(*adisc),\r\nbnx2fc_l2_els_compl, cb_arg, 2 * r_a_tov);\r\nif (rc)\r\nkfree(cb_arg);\r\nreturn rc;\r\n}\r\nint bnx2fc_send_logo(struct bnx2fc_rport *tgt, struct fc_frame *fp)\r\n{\r\nstruct fc_els_logo *logo;\r\nstruct fc_frame_header *fh;\r\nstruct bnx2fc_els_cb_arg *cb_arg;\r\nstruct fc_lport *lport = tgt->rdata->local_port;\r\nu32 r_a_tov = lport->r_a_tov;\r\nint rc;\r\nfh = fc_frame_header_get(fp);\r\ncb_arg = kzalloc(sizeof(struct bnx2fc_els_cb_arg), GFP_ATOMIC);\r\nif (!cb_arg) {\r\nprintk(KERN_ERR PFX "Unable to allocate cb_arg for LOGO\n");\r\nreturn -ENOMEM;\r\n}\r\ncb_arg->l2_oxid = ntohs(fh->fh_ox_id);\r\nBNX2FC_ELS_DBG("Send LOGO: l2_oxid = 0x%x\n", cb_arg->l2_oxid);\r\nlogo = fc_frame_payload_get(fp, sizeof(*logo));\r\nrc = bnx2fc_initiate_els(tgt, ELS_LOGO, logo, sizeof(*logo),\r\nbnx2fc_l2_els_compl, cb_arg, 2 * r_a_tov);\r\nif (rc)\r\nkfree(cb_arg);\r\nreturn rc;\r\n}\r\nint bnx2fc_send_rls(struct bnx2fc_rport *tgt, struct fc_frame *fp)\r\n{\r\nstruct fc_els_rls *rls;\r\nstruct fc_frame_header *fh;\r\nstruct bnx2fc_els_cb_arg *cb_arg;\r\nstruct fc_lport *lport = tgt->rdata->local_port;\r\nu32 r_a_tov = lport->r_a_tov;\r\nint rc;\r\nfh = fc_frame_header_get(fp);\r\ncb_arg = kzalloc(sizeof(struct bnx2fc_els_cb_arg), GFP_ATOMIC);\r\nif (!cb_arg) {\r\nprintk(KERN_ERR PFX "Unable to allocate cb_arg for LOGO\n");\r\nreturn -ENOMEM;\r\n}\r\ncb_arg->l2_oxid = ntohs(fh->fh_ox_id);\r\nrls = fc_frame_payload_get(fp, sizeof(*rls));\r\nrc = bnx2fc_initiate_els(tgt, ELS_RLS, rls, sizeof(*rls),\r\nbnx2fc_l2_els_compl, cb_arg, 2 * r_a_tov);\r\nif (rc)\r\nkfree(cb_arg);\r\nreturn rc;\r\n}\r\nstatic void bnx2fc_srr_compl(struct bnx2fc_els_cb_arg *cb_arg)\r\n{\r\nstruct bnx2fc_mp_req *mp_req;\r\nstruct fc_frame_header *fc_hdr, *fh;\r\nstruct bnx2fc_cmd *srr_req;\r\nstruct bnx2fc_cmd *orig_io_req;\r\nstruct fc_frame *fp;\r\nunsigned char *buf;\r\nvoid *resp_buf;\r\nu32 resp_len, hdr_len;\r\nu8 opcode;\r\nint rc = 0;\r\norig_io_req = cb_arg->aborted_io_req;\r\nsrr_req = cb_arg->io_req;\r\nif (test_and_clear_bit(BNX2FC_FLAG_ELS_TIMEOUT, &srr_req->req_flags)) {\r\nBNX2FC_IO_DBG(srr_req, "srr timed out, abort "\r\n"orig_io - 0x%x\n",\r\norig_io_req->xid);\r\nrc = bnx2fc_initiate_abts(srr_req);\r\nif (rc != SUCCESS) {\r\nBNX2FC_IO_DBG(srr_req, "srr_compl: initiate_abts "\r\n"failed. issue cleanup\n");\r\nbnx2fc_initiate_cleanup(srr_req);\r\n}\r\nif (test_bit(BNX2FC_FLAG_IO_COMPL, &orig_io_req->req_flags) ||\r\ntest_bit(BNX2FC_FLAG_ISSUE_ABTS, &orig_io_req->req_flags)) {\r\nBNX2FC_IO_DBG(srr_req, "srr_compl:xid 0x%x flags = %lx",\r\norig_io_req->xid, orig_io_req->req_flags);\r\ngoto srr_compl_done;\r\n}\r\norig_io_req->srr_retry++;\r\nif (orig_io_req->srr_retry <= SRR_RETRY_COUNT) {\r\nstruct bnx2fc_rport *tgt = orig_io_req->tgt;\r\nspin_unlock_bh(&tgt->tgt_lock);\r\nrc = bnx2fc_send_srr(orig_io_req,\r\norig_io_req->srr_offset,\r\norig_io_req->srr_rctl);\r\nspin_lock_bh(&tgt->tgt_lock);\r\nif (!rc)\r\ngoto srr_compl_done;\r\n}\r\nrc = bnx2fc_initiate_abts(orig_io_req);\r\nif (rc != SUCCESS) {\r\nBNX2FC_IO_DBG(srr_req, "srr_compl: initiate_abts "\r\n"failed xid = 0x%x. issue cleanup\n",\r\norig_io_req->xid);\r\nbnx2fc_initiate_cleanup(orig_io_req);\r\n}\r\ngoto srr_compl_done;\r\n}\r\nif (test_bit(BNX2FC_FLAG_IO_COMPL, &orig_io_req->req_flags) ||\r\ntest_bit(BNX2FC_FLAG_ISSUE_ABTS, &orig_io_req->req_flags)) {\r\nBNX2FC_IO_DBG(srr_req, "srr_compl:xid - 0x%x flags = %lx",\r\norig_io_req->xid, orig_io_req->req_flags);\r\ngoto srr_compl_done;\r\n}\r\nmp_req = &(srr_req->mp_req);\r\nfc_hdr = &(mp_req->resp_fc_hdr);\r\nresp_len = mp_req->resp_len;\r\nresp_buf = mp_req->resp_buf;\r\nhdr_len = sizeof(*fc_hdr);\r\nbuf = kzalloc(PAGE_SIZE, GFP_ATOMIC);\r\nif (!buf) {\r\nprintk(KERN_ERR PFX "srr buf: mem alloc failure\n");\r\ngoto srr_compl_done;\r\n}\r\nmemcpy(buf, fc_hdr, hdr_len);\r\nmemcpy(buf + hdr_len, resp_buf, resp_len);\r\nfp = fc_frame_alloc(NULL, resp_len);\r\nif (!fp) {\r\nprintk(KERN_ERR PFX "fc_frame_alloc failure\n");\r\ngoto free_buf;\r\n}\r\nfh = (struct fc_frame_header *) fc_frame_header_get(fp);\r\nmemcpy(fh, buf, hdr_len + resp_len);\r\nopcode = fc_frame_payload_op(fp);\r\nswitch (opcode) {\r\ncase ELS_LS_ACC:\r\nBNX2FC_IO_DBG(srr_req, "SRR success\n");\r\nbreak;\r\ncase ELS_LS_RJT:\r\nBNX2FC_IO_DBG(srr_req, "SRR rejected\n");\r\nrc = bnx2fc_initiate_abts(orig_io_req);\r\nif (rc != SUCCESS) {\r\nBNX2FC_IO_DBG(srr_req, "srr_compl: initiate_abts "\r\n"failed xid = 0x%x. issue cleanup\n",\r\norig_io_req->xid);\r\nbnx2fc_initiate_cleanup(orig_io_req);\r\n}\r\nbreak;\r\ndefault:\r\nBNX2FC_IO_DBG(srr_req, "srr compl - invalid opcode = %d\n",\r\nopcode);\r\nbreak;\r\n}\r\nfc_frame_free(fp);\r\nfree_buf:\r\nkfree(buf);\r\nsrr_compl_done:\r\nkref_put(&orig_io_req->refcount, bnx2fc_cmd_release);\r\n}\r\nstatic void bnx2fc_rec_compl(struct bnx2fc_els_cb_arg *cb_arg)\r\n{\r\nstruct bnx2fc_cmd *orig_io_req, *new_io_req;\r\nstruct bnx2fc_cmd *rec_req;\r\nstruct bnx2fc_mp_req *mp_req;\r\nstruct fc_frame_header *fc_hdr, *fh;\r\nstruct fc_els_ls_rjt *rjt;\r\nstruct fc_els_rec_acc *acc;\r\nstruct bnx2fc_rport *tgt;\r\nstruct fcoe_err_report_entry *err_entry;\r\nstruct scsi_cmnd *sc_cmd;\r\nenum fc_rctl r_ctl;\r\nunsigned char *buf;\r\nvoid *resp_buf;\r\nstruct fc_frame *fp;\r\nu8 opcode;\r\nu32 offset;\r\nu32 e_stat;\r\nu32 resp_len, hdr_len;\r\nint rc = 0;\r\nbool send_seq_clnp = false;\r\nbool abort_io = false;\r\nBNX2FC_MISC_DBG("Entered rec_compl callback\n");\r\nrec_req = cb_arg->io_req;\r\norig_io_req = cb_arg->aborted_io_req;\r\nBNX2FC_IO_DBG(rec_req, "rec_compl: orig xid = 0x%x", orig_io_req->xid);\r\ntgt = orig_io_req->tgt;\r\nif (test_and_clear_bit(BNX2FC_FLAG_ELS_TIMEOUT, &rec_req->req_flags)) {\r\nBNX2FC_IO_DBG(rec_req, "timed out, abort "\r\n"orig_io - 0x%x\n",\r\norig_io_req->xid);\r\nrc = bnx2fc_initiate_abts(rec_req);\r\nif (rc != SUCCESS) {\r\nBNX2FC_IO_DBG(rec_req, "rec_compl: initiate_abts "\r\n"failed. issue cleanup\n");\r\nbnx2fc_initiate_cleanup(rec_req);\r\n}\r\norig_io_req->rec_retry++;\r\nif (orig_io_req->rec_retry <= REC_RETRY_COUNT) {\r\nspin_unlock_bh(&tgt->tgt_lock);\r\nrc = bnx2fc_send_rec(orig_io_req);\r\nspin_lock_bh(&tgt->tgt_lock);\r\nif (!rc)\r\ngoto rec_compl_done;\r\n}\r\nrc = bnx2fc_initiate_abts(orig_io_req);\r\nif (rc != SUCCESS) {\r\nBNX2FC_IO_DBG(rec_req, "rec_compl: initiate_abts "\r\n"failed xid = 0x%x. issue cleanup\n",\r\norig_io_req->xid);\r\nbnx2fc_initiate_cleanup(orig_io_req);\r\n}\r\ngoto rec_compl_done;\r\n}\r\nif (test_bit(BNX2FC_FLAG_IO_COMPL, &orig_io_req->req_flags)) {\r\nBNX2FC_IO_DBG(rec_req, "completed"\r\n"orig_io - 0x%x\n",\r\norig_io_req->xid);\r\ngoto rec_compl_done;\r\n}\r\nif (test_bit(BNX2FC_FLAG_ISSUE_ABTS, &orig_io_req->req_flags)) {\r\nBNX2FC_IO_DBG(rec_req, "abts in prog "\r\n"orig_io - 0x%x\n",\r\norig_io_req->xid);\r\ngoto rec_compl_done;\r\n}\r\nmp_req = &(rec_req->mp_req);\r\nfc_hdr = &(mp_req->resp_fc_hdr);\r\nresp_len = mp_req->resp_len;\r\nacc = resp_buf = mp_req->resp_buf;\r\nhdr_len = sizeof(*fc_hdr);\r\nbuf = kzalloc(PAGE_SIZE, GFP_ATOMIC);\r\nif (!buf) {\r\nprintk(KERN_ERR PFX "rec buf: mem alloc failure\n");\r\ngoto rec_compl_done;\r\n}\r\nmemcpy(buf, fc_hdr, hdr_len);\r\nmemcpy(buf + hdr_len, resp_buf, resp_len);\r\nfp = fc_frame_alloc(NULL, resp_len);\r\nif (!fp) {\r\nprintk(KERN_ERR PFX "fc_frame_alloc failure\n");\r\ngoto free_buf;\r\n}\r\nfh = (struct fc_frame_header *) fc_frame_header_get(fp);\r\nmemcpy(fh, buf, hdr_len + resp_len);\r\nopcode = fc_frame_payload_op(fp);\r\nif (opcode == ELS_LS_RJT) {\r\nBNX2FC_IO_DBG(rec_req, "opcode is RJT\n");\r\nrjt = fc_frame_payload_get(fp, sizeof(*rjt));\r\nif ((rjt->er_reason == ELS_RJT_LOGIC ||\r\nrjt->er_reason == ELS_RJT_UNAB) &&\r\nrjt->er_explan == ELS_EXPL_OXID_RXID) {\r\nBNX2FC_IO_DBG(rec_req, "handle CMD LOST case\n");\r\nnew_io_req = bnx2fc_cmd_alloc(tgt);\r\nif (!new_io_req)\r\ngoto abort_io;\r\nnew_io_req->sc_cmd = orig_io_req->sc_cmd;\r\nset_bit(BNX2FC_FLAG_CMD_LOST,\r\n&orig_io_req->req_flags);\r\nbnx2fc_initiate_cleanup(orig_io_req);\r\nBNX2FC_IO_DBG(rec_req, "Post IO request again\n");\r\nrc = bnx2fc_post_io_req(tgt, new_io_req);\r\nif (!rc)\r\ngoto free_frame;\r\nBNX2FC_IO_DBG(rec_req, "REC: io post err\n");\r\n}\r\nabort_io:\r\nrc = bnx2fc_initiate_abts(orig_io_req);\r\nif (rc != SUCCESS) {\r\nBNX2FC_IO_DBG(rec_req, "rec_compl: initiate_abts "\r\n"failed. issue cleanup\n");\r\nbnx2fc_initiate_cleanup(orig_io_req);\r\n}\r\n} else if (opcode == ELS_LS_ACC) {\r\noffset = ntohl(acc->reca_fc4value);\r\ne_stat = ntohl(acc->reca_e_stat);\r\nif (e_stat & ESB_ST_SEQ_INIT) {\r\nBNX2FC_IO_DBG(rec_req, "target has the seq init\n");\r\ngoto free_frame;\r\n}\r\nBNX2FC_IO_DBG(rec_req, "e_stat = 0x%x, offset = 0x%x\n",\r\ne_stat, offset);\r\nerr_entry = (struct fcoe_err_report_entry *)\r\n&orig_io_req->err_entry;\r\nsc_cmd = orig_io_req->sc_cmd;\r\nif (sc_cmd->sc_data_direction == DMA_TO_DEVICE) {\r\nif (offset == orig_io_req->data_xfer_len) {\r\nBNX2FC_IO_DBG(rec_req, "WRITE - resp lost\n");\r\nr_ctl = FC_RCTL_DD_CMD_STATUS;\r\noffset = 0;\r\n} else {\r\nBNX2FC_IO_DBG(rec_req, "XFER_RDY/DATA lost\n");\r\nsend_seq_clnp = true;\r\nr_ctl = FC_RCTL_DD_DATA_DESC;\r\nif (bnx2fc_initiate_seq_cleanup(orig_io_req,\r\noffset, r_ctl))\r\nabort_io = true;\r\n}\r\n} else {\r\nif (err_entry->data.rx_buf_off ==\r\norig_io_req->data_xfer_len) {\r\nBNX2FC_IO_DBG(rec_req, "READ - resp lost\n");\r\nr_ctl = FC_RCTL_DD_CMD_STATUS;\r\noffset = 0;\r\n} else {\r\nsend_seq_clnp = true;\r\noffset = err_entry->data.rx_buf_off;\r\nBNX2FC_IO_DBG(rec_req, "RD DATA lost\n");\r\nr_ctl = FC_RCTL_DD_SOL_DATA;\r\nif (bnx2fc_initiate_seq_cleanup(orig_io_req,\r\noffset, r_ctl))\r\nabort_io = true;\r\n}\r\n}\r\nif (abort_io) {\r\nrc = bnx2fc_initiate_abts(orig_io_req);\r\nif (rc != SUCCESS) {\r\nBNX2FC_IO_DBG(rec_req, "rec_compl:initiate_abts"\r\n" failed. issue cleanup\n");\r\nbnx2fc_initiate_cleanup(orig_io_req);\r\n}\r\n} else if (!send_seq_clnp) {\r\nBNX2FC_IO_DBG(rec_req, "Send SRR - FCP_RSP\n");\r\nspin_unlock_bh(&tgt->tgt_lock);\r\nrc = bnx2fc_send_srr(orig_io_req, offset, r_ctl);\r\nspin_lock_bh(&tgt->tgt_lock);\r\nif (rc) {\r\nBNX2FC_IO_DBG(rec_req, "Unable to send SRR"\r\n" IO will abort\n");\r\n}\r\n}\r\n}\r\nfree_frame:\r\nfc_frame_free(fp);\r\nfree_buf:\r\nkfree(buf);\r\nrec_compl_done:\r\nkref_put(&orig_io_req->refcount, bnx2fc_cmd_release);\r\nkfree(cb_arg);\r\n}\r\nint bnx2fc_send_rec(struct bnx2fc_cmd *orig_io_req)\r\n{\r\nstruct fc_els_rec rec;\r\nstruct bnx2fc_rport *tgt = orig_io_req->tgt;\r\nstruct fc_lport *lport = tgt->rdata->local_port;\r\nstruct bnx2fc_els_cb_arg *cb_arg = NULL;\r\nu32 sid = tgt->sid;\r\nu32 r_a_tov = lport->r_a_tov;\r\nint rc;\r\nBNX2FC_IO_DBG(orig_io_req, "Sending REC\n");\r\nmemset(&rec, 0, sizeof(rec));\r\ncb_arg = kzalloc(sizeof(struct bnx2fc_els_cb_arg), GFP_ATOMIC);\r\nif (!cb_arg) {\r\nprintk(KERN_ERR PFX "Unable to allocate cb_arg for REC\n");\r\nrc = -ENOMEM;\r\ngoto rec_err;\r\n}\r\nkref_get(&orig_io_req->refcount);\r\ncb_arg->aborted_io_req = orig_io_req;\r\nrec.rec_cmd = ELS_REC;\r\nhton24(rec.rec_s_id, sid);\r\nrec.rec_ox_id = htons(orig_io_req->xid);\r\nrec.rec_rx_id = htons(orig_io_req->task->rxwr_txrd.var_ctx.rx_id);\r\nrc = bnx2fc_initiate_els(tgt, ELS_REC, &rec, sizeof(rec),\r\nbnx2fc_rec_compl, cb_arg,\r\nr_a_tov);\r\nrec_err:\r\nif (rc) {\r\nBNX2FC_IO_DBG(orig_io_req, "REC failed - release\n");\r\nspin_lock_bh(&tgt->tgt_lock);\r\nkref_put(&orig_io_req->refcount, bnx2fc_cmd_release);\r\nspin_unlock_bh(&tgt->tgt_lock);\r\nkfree(cb_arg);\r\n}\r\nreturn rc;\r\n}\r\nint bnx2fc_send_srr(struct bnx2fc_cmd *orig_io_req, u32 offset, u8 r_ctl)\r\n{\r\nstruct fcp_srr srr;\r\nstruct bnx2fc_rport *tgt = orig_io_req->tgt;\r\nstruct fc_lport *lport = tgt->rdata->local_port;\r\nstruct bnx2fc_els_cb_arg *cb_arg = NULL;\r\nu32 r_a_tov = lport->r_a_tov;\r\nint rc;\r\nBNX2FC_IO_DBG(orig_io_req, "Sending SRR\n");\r\nmemset(&srr, 0, sizeof(srr));\r\ncb_arg = kzalloc(sizeof(struct bnx2fc_els_cb_arg), GFP_ATOMIC);\r\nif (!cb_arg) {\r\nprintk(KERN_ERR PFX "Unable to allocate cb_arg for SRR\n");\r\nrc = -ENOMEM;\r\ngoto srr_err;\r\n}\r\nkref_get(&orig_io_req->refcount);\r\ncb_arg->aborted_io_req = orig_io_req;\r\nsrr.srr_op = ELS_SRR;\r\nsrr.srr_ox_id = htons(orig_io_req->xid);\r\nsrr.srr_rx_id = htons(orig_io_req->task->rxwr_txrd.var_ctx.rx_id);\r\nsrr.srr_rel_off = htonl(offset);\r\nsrr.srr_r_ctl = r_ctl;\r\norig_io_req->srr_offset = offset;\r\norig_io_req->srr_rctl = r_ctl;\r\nrc = bnx2fc_initiate_els(tgt, ELS_SRR, &srr, sizeof(srr),\r\nbnx2fc_srr_compl, cb_arg,\r\nr_a_tov);\r\nsrr_err:\r\nif (rc) {\r\nBNX2FC_IO_DBG(orig_io_req, "SRR failed - release\n");\r\nspin_lock_bh(&tgt->tgt_lock);\r\nkref_put(&orig_io_req->refcount, bnx2fc_cmd_release);\r\nspin_unlock_bh(&tgt->tgt_lock);\r\nkfree(cb_arg);\r\n} else\r\nset_bit(BNX2FC_FLAG_SRR_SENT, &orig_io_req->req_flags);\r\nreturn rc;\r\n}\r\nstatic int bnx2fc_initiate_els(struct bnx2fc_rport *tgt, unsigned int op,\r\nvoid *data, u32 data_len,\r\nvoid (*cb_func)(struct bnx2fc_els_cb_arg *cb_arg),\r\nstruct bnx2fc_els_cb_arg *cb_arg, u32 timer_msec)\r\n{\r\nstruct fcoe_port *port = tgt->port;\r\nstruct bnx2fc_interface *interface = port->priv;\r\nstruct fc_rport *rport = tgt->rport;\r\nstruct fc_lport *lport = port->lport;\r\nstruct bnx2fc_cmd *els_req;\r\nstruct bnx2fc_mp_req *mp_req;\r\nstruct fc_frame_header *fc_hdr;\r\nstruct fcoe_task_ctx_entry *task;\r\nstruct fcoe_task_ctx_entry *task_page;\r\nint rc = 0;\r\nint task_idx, index;\r\nu32 did, sid;\r\nu16 xid;\r\nrc = fc_remote_port_chkready(rport);\r\nif (rc) {\r\nprintk(KERN_ERR PFX "els 0x%x: rport not ready\n", op);\r\nrc = -EINVAL;\r\ngoto els_err;\r\n}\r\nif (lport->state != LPORT_ST_READY || !(lport->link_up)) {\r\nprintk(KERN_ERR PFX "els 0x%x: link is not ready\n", op);\r\nrc = -EINVAL;\r\ngoto els_err;\r\n}\r\nif (!(test_bit(BNX2FC_FLAG_SESSION_READY, &tgt->flags))) {\r\nprintk(KERN_ERR PFX "els 0x%x: tgt not ready\n", op);\r\nrc = -EINVAL;\r\ngoto els_err;\r\n}\r\nels_req = bnx2fc_elstm_alloc(tgt, BNX2FC_ELS);\r\nif (!els_req) {\r\nrc = -ENOMEM;\r\ngoto els_err;\r\n}\r\nels_req->sc_cmd = NULL;\r\nels_req->port = port;\r\nels_req->tgt = tgt;\r\nels_req->cb_func = cb_func;\r\ncb_arg->io_req = els_req;\r\nels_req->cb_arg = cb_arg;\r\nels_req->data_xfer_len = data_len;\r\nmp_req = (struct bnx2fc_mp_req *)&(els_req->mp_req);\r\nrc = bnx2fc_init_mp_req(els_req);\r\nif (rc == FAILED) {\r\nprintk(KERN_ERR PFX "ELS MP request init failed\n");\r\nspin_lock_bh(&tgt->tgt_lock);\r\nkref_put(&els_req->refcount, bnx2fc_cmd_release);\r\nspin_unlock_bh(&tgt->tgt_lock);\r\nrc = -ENOMEM;\r\ngoto els_err;\r\n} else {\r\nrc = 0;\r\n}\r\nmp_req->req_len = data_len;\r\nels_req->data_xfer_len = mp_req->req_len;\r\nif ((op >= ELS_LS_RJT) && (op <= ELS_AUTH_ELS)) {\r\nmemcpy(mp_req->req_buf, data, data_len);\r\n} else {\r\nprintk(KERN_ERR PFX "Invalid ELS op 0x%x\n", op);\r\nels_req->cb_func = NULL;\r\nels_req->cb_arg = NULL;\r\nspin_lock_bh(&tgt->tgt_lock);\r\nkref_put(&els_req->refcount, bnx2fc_cmd_release);\r\nspin_unlock_bh(&tgt->tgt_lock);\r\nrc = -EINVAL;\r\n}\r\nif (rc)\r\ngoto els_err;\r\nfc_hdr = &(mp_req->req_fc_hdr);\r\ndid = tgt->rport->port_id;\r\nsid = tgt->sid;\r\nif (op == ELS_SRR)\r\n__fc_fill_fc_hdr(fc_hdr, FC_RCTL_ELS4_REQ, did, sid,\r\nFC_TYPE_FCP, FC_FC_FIRST_SEQ |\r\nFC_FC_END_SEQ | FC_FC_SEQ_INIT, 0);\r\nelse\r\n__fc_fill_fc_hdr(fc_hdr, FC_RCTL_ELS_REQ, did, sid,\r\nFC_TYPE_ELS, FC_FC_FIRST_SEQ |\r\nFC_FC_END_SEQ | FC_FC_SEQ_INIT, 0);\r\nxid = els_req->xid;\r\ntask_idx = xid/BNX2FC_TASKS_PER_PAGE;\r\nindex = xid % BNX2FC_TASKS_PER_PAGE;\r\ntask_page = (struct fcoe_task_ctx_entry *)\r\ninterface->hba->task_ctx[task_idx];\r\ntask = &(task_page[index]);\r\nbnx2fc_init_mp_task(els_req, task);\r\nspin_lock_bh(&tgt->tgt_lock);\r\nif (!test_bit(BNX2FC_FLAG_SESSION_READY, &tgt->flags)) {\r\nprintk(KERN_ERR PFX "initiate_els.. session not ready\n");\r\nels_req->cb_func = NULL;\r\nels_req->cb_arg = NULL;\r\nkref_put(&els_req->refcount, bnx2fc_cmd_release);\r\nspin_unlock_bh(&tgt->tgt_lock);\r\nreturn -EINVAL;\r\n}\r\nif (timer_msec)\r\nbnx2fc_cmd_timer_set(els_req, timer_msec);\r\nbnx2fc_add_2_sq(tgt, xid);\r\nels_req->on_active_queue = 1;\r\nlist_add_tail(&els_req->link, &tgt->els_queue);\r\nbnx2fc_ring_doorbell(tgt);\r\nspin_unlock_bh(&tgt->tgt_lock);\r\nels_err:\r\nreturn rc;\r\n}\r\nvoid bnx2fc_process_els_compl(struct bnx2fc_cmd *els_req,\r\nstruct fcoe_task_ctx_entry *task, u8 num_rq)\r\n{\r\nstruct bnx2fc_mp_req *mp_req;\r\nstruct fc_frame_header *fc_hdr;\r\nu64 *hdr;\r\nu64 *temp_hdr;\r\nBNX2FC_ELS_DBG("Entered process_els_compl xid = 0x%x"\r\n"cmd_type = %d\n", els_req->xid, els_req->cmd_type);\r\nif (test_and_set_bit(BNX2FC_FLAG_ELS_DONE,\r\n&els_req->req_flags)) {\r\nBNX2FC_ELS_DBG("Timer context finished processing this "\r\n"els - 0x%x\n", els_req->xid);\r\nkref_put(&els_req->refcount, bnx2fc_cmd_release);\r\nreturn;\r\n}\r\nif (cancel_delayed_work(&els_req->timeout_work))\r\nkref_put(&els_req->refcount,\r\nbnx2fc_cmd_release);\r\nif (els_req->on_active_queue) {\r\nlist_del_init(&els_req->link);\r\nels_req->on_active_queue = 0;\r\n}\r\nmp_req = &(els_req->mp_req);\r\nfc_hdr = &(mp_req->resp_fc_hdr);\r\nhdr = (u64 *)fc_hdr;\r\ntemp_hdr = (u64 *)\r\n&task->rxwr_only.union_ctx.comp_info.mp_rsp.fc_hdr;\r\nhdr[0] = cpu_to_be64(temp_hdr[0]);\r\nhdr[1] = cpu_to_be64(temp_hdr[1]);\r\nhdr[2] = cpu_to_be64(temp_hdr[2]);\r\nmp_req->resp_len =\r\ntask->rxwr_only.union_ctx.comp_info.mp_rsp.mp_payload_len;\r\nif ((els_req->cb_func) && (els_req->cb_arg)) {\r\nels_req->cb_func(els_req->cb_arg);\r\nels_req->cb_arg = NULL;\r\n}\r\nkref_put(&els_req->refcount, bnx2fc_cmd_release);\r\n}\r\nstatic void bnx2fc_flogi_resp(struct fc_seq *seq, struct fc_frame *fp,\r\nvoid *arg)\r\n{\r\nstruct fcoe_ctlr *fip = arg;\r\nstruct fc_exch *exch = fc_seq_exch(seq);\r\nstruct fc_lport *lport = exch->lp;\r\nu8 *mac;\r\nu8 op;\r\nif (IS_ERR(fp))\r\ngoto done;\r\nmac = fr_cb(fp)->granted_mac;\r\nif (is_zero_ether_addr(mac)) {\r\nop = fc_frame_payload_op(fp);\r\nif (lport->vport) {\r\nif (op == ELS_LS_RJT) {\r\nprintk(KERN_ERR PFX "bnx2fc_flogi_resp is LS_RJT\n");\r\nfc_vport_terminate(lport->vport);\r\nfc_frame_free(fp);\r\nreturn;\r\n}\r\n}\r\nfcoe_ctlr_recv_flogi(fip, lport, fp);\r\n}\r\nif (!is_zero_ether_addr(mac))\r\nfip->update_mac(lport, mac);\r\ndone:\r\nfc_lport_flogi_resp(seq, fp, lport);\r\n}\r\nstatic void bnx2fc_logo_resp(struct fc_seq *seq, struct fc_frame *fp,\r\nvoid *arg)\r\n{\r\nstruct fcoe_ctlr *fip = arg;\r\nstruct fc_exch *exch = fc_seq_exch(seq);\r\nstruct fc_lport *lport = exch->lp;\r\nstatic u8 zero_mac[ETH_ALEN] = { 0 };\r\nif (!IS_ERR(fp))\r\nfip->update_mac(lport, zero_mac);\r\nfc_lport_logo_resp(seq, fp, lport);\r\n}\r\nstruct fc_seq *bnx2fc_elsct_send(struct fc_lport *lport, u32 did,\r\nstruct fc_frame *fp, unsigned int op,\r\nvoid (*resp)(struct fc_seq *,\r\nstruct fc_frame *,\r\nvoid *),\r\nvoid *arg, u32 timeout)\r\n{\r\nstruct fcoe_port *port = lport_priv(lport);\r\nstruct bnx2fc_interface *interface = port->priv;\r\nstruct fcoe_ctlr *fip = bnx2fc_to_ctlr(interface);\r\nstruct fc_frame_header *fh = fc_frame_header_get(fp);\r\nswitch (op) {\r\ncase ELS_FLOGI:\r\ncase ELS_FDISC:\r\nreturn fc_elsct_send(lport, did, fp, op, bnx2fc_flogi_resp,\r\nfip, timeout);\r\ncase ELS_LOGO:\r\nif (ntoh24(fh->fh_d_id) != FC_FID_FLOGI)\r\nbreak;\r\nreturn fc_elsct_send(lport, did, fp, op, bnx2fc_logo_resp,\r\nfip, timeout);\r\n}\r\nreturn fc_elsct_send(lport, did, fp, op, resp, arg, timeout);\r\n}
