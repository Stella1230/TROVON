static inline void cls_set_cts_flow_control(struct channel_t *ch)\r\n{\r\nunsigned char lcrb = readb(&ch->ch_cls_uart->lcr);\r\nunsigned char ier = readb(&ch->ch_cls_uart->ier);\r\nunsigned char isr_fcr = 0;\r\nwriteb(UART_EXAR654_ENHANCED_REGISTER_SET, &ch->ch_cls_uart->lcr);\r\nisr_fcr = readb(&ch->ch_cls_uart->isr_fcr);\r\nisr_fcr |= (UART_EXAR654_EFR_ECB | UART_EXAR654_EFR_CTSDSR);\r\nisr_fcr &= ~(UART_EXAR654_EFR_IXON);\r\nwriteb(isr_fcr, &ch->ch_cls_uart->isr_fcr);\r\nwriteb(lcrb, &ch->ch_cls_uart->lcr);\r\nier |= (UART_EXAR654_IER_CTSDSR);\r\nier &= ~(UART_EXAR654_IER_XOFF);\r\nwriteb(ier, &ch->ch_cls_uart->ier);\r\nwriteb((UART_FCR_ENABLE_FIFO), &ch->ch_cls_uart->isr_fcr);\r\nwriteb((UART_FCR_ENABLE_FIFO | UART_16654_FCR_RXTRIGGER_56 |\r\nUART_16654_FCR_TXTRIGGER_16 | UART_FCR_CLEAR_RCVR),\r\n&ch->ch_cls_uart->isr_fcr);\r\nch->ch_t_tlevel = 16;\r\n}\r\nstatic inline void cls_set_ixon_flow_control(struct channel_t *ch)\r\n{\r\nunsigned char lcrb = readb(&ch->ch_cls_uart->lcr);\r\nunsigned char ier = readb(&ch->ch_cls_uart->ier);\r\nunsigned char isr_fcr = 0;\r\nwriteb(UART_EXAR654_ENHANCED_REGISTER_SET, &ch->ch_cls_uart->lcr);\r\nisr_fcr = readb(&ch->ch_cls_uart->isr_fcr);\r\nisr_fcr |= (UART_EXAR654_EFR_ECB | UART_EXAR654_EFR_IXON);\r\nisr_fcr &= ~(UART_EXAR654_EFR_CTSDSR);\r\nwriteb(isr_fcr, &ch->ch_cls_uart->isr_fcr);\r\nwriteb(ch->ch_startc, &ch->ch_cls_uart->mcr);\r\nwriteb(0, &ch->ch_cls_uart->lsr);\r\nwriteb(ch->ch_stopc, &ch->ch_cls_uart->msr);\r\nwriteb(0, &ch->ch_cls_uart->spr);\r\nwriteb(lcrb, &ch->ch_cls_uart->lcr);\r\nier &= ~(UART_EXAR654_IER_CTSDSR);\r\nier |= (UART_EXAR654_IER_XOFF);\r\nwriteb(ier, &ch->ch_cls_uart->ier);\r\nwriteb((UART_FCR_ENABLE_FIFO), &ch->ch_cls_uart->isr_fcr);\r\nwriteb((UART_FCR_ENABLE_FIFO | UART_16654_FCR_RXTRIGGER_16 |\r\nUART_16654_FCR_TXTRIGGER_16 | UART_FCR_CLEAR_RCVR),\r\n&ch->ch_cls_uart->isr_fcr);\r\n}\r\nstatic inline void cls_set_no_output_flow_control(struct channel_t *ch)\r\n{\r\nunsigned char lcrb = readb(&ch->ch_cls_uart->lcr);\r\nunsigned char ier = readb(&ch->ch_cls_uart->ier);\r\nunsigned char isr_fcr = 0;\r\nwriteb(UART_EXAR654_ENHANCED_REGISTER_SET, &ch->ch_cls_uart->lcr);\r\nisr_fcr = readb(&ch->ch_cls_uart->isr_fcr);\r\nisr_fcr |= (UART_EXAR654_EFR_ECB);\r\nisr_fcr &= ~(UART_EXAR654_EFR_CTSDSR | UART_EXAR654_EFR_IXON);\r\nwriteb(isr_fcr, &ch->ch_cls_uart->isr_fcr);\r\nwriteb(lcrb, &ch->ch_cls_uart->lcr);\r\nier &= ~(UART_EXAR654_IER_CTSDSR);\r\nier &= ~(UART_EXAR654_IER_XOFF);\r\nwriteb(ier, &ch->ch_cls_uart->ier);\r\nwriteb((UART_FCR_ENABLE_FIFO), &ch->ch_cls_uart->isr_fcr);\r\nwriteb((UART_FCR_ENABLE_FIFO | UART_16654_FCR_RXTRIGGER_16 |\r\nUART_16654_FCR_TXTRIGGER_16 | UART_FCR_CLEAR_RCVR),\r\n&ch->ch_cls_uart->isr_fcr);\r\nch->ch_r_watermark = 0;\r\nch->ch_t_tlevel = 16;\r\nch->ch_r_tlevel = 16;\r\n}\r\nstatic inline void cls_set_rts_flow_control(struct channel_t *ch)\r\n{\r\nunsigned char lcrb = readb(&ch->ch_cls_uart->lcr);\r\nunsigned char ier = readb(&ch->ch_cls_uart->ier);\r\nunsigned char isr_fcr = 0;\r\nwriteb(UART_EXAR654_ENHANCED_REGISTER_SET, &ch->ch_cls_uart->lcr);\r\nisr_fcr = readb(&ch->ch_cls_uart->isr_fcr);\r\nisr_fcr |= (UART_EXAR654_EFR_ECB | UART_EXAR654_EFR_RTSDTR);\r\nisr_fcr &= ~(UART_EXAR654_EFR_IXOFF);\r\nwriteb(isr_fcr, &ch->ch_cls_uart->isr_fcr);\r\nwriteb(lcrb, &ch->ch_cls_uart->lcr);\r\nier |= (UART_EXAR654_IER_RTSDTR);\r\nwriteb(ier, &ch->ch_cls_uart->ier);\r\nwriteb((UART_FCR_ENABLE_FIFO), &ch->ch_cls_uart->isr_fcr);\r\nwriteb((UART_FCR_ENABLE_FIFO | UART_16654_FCR_RXTRIGGER_56 |\r\nUART_16654_FCR_TXTRIGGER_16 | UART_FCR_CLEAR_RCVR),\r\n&ch->ch_cls_uart->isr_fcr);\r\nch->ch_r_watermark = 4;\r\nch->ch_r_tlevel = 8;\r\n}\r\nstatic inline void cls_set_ixoff_flow_control(struct channel_t *ch)\r\n{\r\nunsigned char lcrb = readb(&ch->ch_cls_uart->lcr);\r\nunsigned char ier = readb(&ch->ch_cls_uart->ier);\r\nunsigned char isr_fcr = 0;\r\nwriteb(UART_EXAR654_ENHANCED_REGISTER_SET, &ch->ch_cls_uart->lcr);\r\nisr_fcr = readb(&ch->ch_cls_uart->isr_fcr);\r\nisr_fcr |= (UART_EXAR654_EFR_ECB | UART_EXAR654_EFR_IXOFF);\r\nisr_fcr &= ~(UART_EXAR654_EFR_RTSDTR);\r\nwriteb(isr_fcr, &ch->ch_cls_uart->isr_fcr);\r\nwriteb(ch->ch_startc, &ch->ch_cls_uart->mcr);\r\nwriteb(0, &ch->ch_cls_uart->lsr);\r\nwriteb(ch->ch_stopc, &ch->ch_cls_uart->msr);\r\nwriteb(0, &ch->ch_cls_uart->spr);\r\nwriteb(lcrb, &ch->ch_cls_uart->lcr);\r\nier &= ~(UART_EXAR654_IER_RTSDTR);\r\nwriteb(ier, &ch->ch_cls_uart->ier);\r\nwriteb((UART_FCR_ENABLE_FIFO), &ch->ch_cls_uart->isr_fcr);\r\nwriteb((UART_FCR_ENABLE_FIFO | UART_16654_FCR_RXTRIGGER_16 |\r\nUART_16654_FCR_TXTRIGGER_16 | UART_FCR_CLEAR_RCVR),\r\n&ch->ch_cls_uart->isr_fcr);\r\n}\r\nstatic inline void cls_set_no_input_flow_control(struct channel_t *ch)\r\n{\r\nunsigned char lcrb = readb(&ch->ch_cls_uart->lcr);\r\nunsigned char ier = readb(&ch->ch_cls_uart->ier);\r\nunsigned char isr_fcr = 0;\r\nwriteb(UART_EXAR654_ENHANCED_REGISTER_SET, &ch->ch_cls_uart->lcr);\r\nisr_fcr = readb(&ch->ch_cls_uart->isr_fcr);\r\nisr_fcr |= (UART_EXAR654_EFR_ECB);\r\nisr_fcr &= ~(UART_EXAR654_EFR_RTSDTR | UART_EXAR654_EFR_IXOFF);\r\nwriteb(isr_fcr, &ch->ch_cls_uart->isr_fcr);\r\nwriteb(lcrb, &ch->ch_cls_uart->lcr);\r\nier &= ~(UART_EXAR654_IER_RTSDTR);\r\nwriteb(ier, &ch->ch_cls_uart->ier);\r\nwriteb((UART_FCR_ENABLE_FIFO), &ch->ch_cls_uart->isr_fcr);\r\nwriteb((UART_FCR_ENABLE_FIFO | UART_16654_FCR_RXTRIGGER_16 |\r\nUART_16654_FCR_TXTRIGGER_16 | UART_FCR_CLEAR_RCVR),\r\n&ch->ch_cls_uart->isr_fcr);\r\nch->ch_t_tlevel = 16;\r\nch->ch_r_tlevel = 16;\r\n}\r\nstatic inline void cls_clear_break(struct channel_t *ch, int force)\r\n{\r\nunsigned long flags;\r\nif (!ch)\r\nreturn;\r\nspin_lock_irqsave(&ch->ch_lock, flags);\r\nif (!ch->ch_stop_sending_break) {\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nreturn;\r\n}\r\nif (ch->ch_flags & CH_BREAK_SENDING) {\r\nif (time_after(jiffies, ch->ch_stop_sending_break) || force) {\r\nunsigned char temp = readb(&ch->ch_cls_uart->lcr);\r\nwriteb((temp & ~UART_LCR_SBC), &ch->ch_cls_uart->lcr);\r\nch->ch_flags &= ~(CH_BREAK_SENDING);\r\nch->ch_stop_sending_break = 0;\r\n}\r\n}\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\n}\r\nstatic void cls_copy_data_from_uart_to_queue(struct channel_t *ch)\r\n{\r\nint qleft = 0;\r\nunsigned char linestatus = 0;\r\nunsigned char error_mask = 0;\r\nushort head;\r\nushort tail;\r\nunsigned long flags;\r\nif (!ch)\r\nreturn;\r\nspin_lock_irqsave(&ch->ch_lock, flags);\r\nhead = ch->ch_r_head;\r\ntail = ch->ch_r_tail;\r\nqleft = tail - head - 1;\r\nif (qleft < 0)\r\nqleft += RQUEUEMASK + 1;\r\nif (ch->ch_c_iflag & IGNBRK)\r\nerror_mask |= UART_LSR_BI;\r\nwhile (1) {\r\nlinestatus = readb(&ch->ch_cls_uart->lsr);\r\nif (!(linestatus & (UART_LSR_DR)))\r\nbreak;\r\nif (linestatus & error_mask) {\r\nlinestatus = 0;\r\nreadb(&ch->ch_cls_uart->txrx);\r\ncontinue;\r\n}\r\nwhile (qleft < 1) {\r\ntail = (tail + 1) & RQUEUEMASK;\r\nch->ch_r_tail = tail;\r\nch->ch_err_overrun++;\r\nqleft++;\r\n}\r\nch->ch_equeue[head] = linestatus & (UART_LSR_BI | UART_LSR_PE\r\n| UART_LSR_FE);\r\nch->ch_rqueue[head] = readb(&ch->ch_cls_uart->txrx);\r\nqleft--;\r\nif (ch->ch_equeue[head] & UART_LSR_PE)\r\nch->ch_err_parity++;\r\nif (ch->ch_equeue[head] & UART_LSR_BI)\r\nch->ch_err_break++;\r\nif (ch->ch_equeue[head] & UART_LSR_FE)\r\nch->ch_err_frame++;\r\nhead = (head + 1) & RQUEUEMASK;\r\nch->ch_rxcount++;\r\n}\r\nch->ch_r_head = head & RQUEUEMASK;\r\nch->ch_e_head = head & EQUEUEMASK;\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\n}\r\nstatic void cls_assert_modem_signals(struct channel_t *ch)\r\n{\r\nunsigned char out;\r\nif (!ch)\r\nreturn;\r\nout = ch->ch_mostat;\r\nif (ch->ch_flags & CH_LOOPBACK)\r\nout |= UART_MCR_LOOP;\r\nwriteb(out, &ch->ch_cls_uart->mcr);\r\nudelay(10);\r\n}\r\nstatic void cls_copy_data_from_queue_to_uart(struct channel_t *ch)\r\n{\r\nushort head;\r\nushort tail;\r\nint n;\r\nint qlen;\r\nuint len_written = 0;\r\nunsigned long flags;\r\nif (!ch)\r\nreturn;\r\nspin_lock_irqsave(&ch->ch_lock, flags);\r\nif (ch->ch_w_tail == ch->ch_w_head)\r\ngoto exit_unlock;\r\nif ((ch->ch_flags & CH_FORCED_STOP) ||\r\n(ch->ch_flags & CH_BREAK_SENDING))\r\ngoto exit_unlock;\r\nif (!(ch->ch_flags & (CH_TX_FIFO_EMPTY | CH_TX_FIFO_LWM)))\r\ngoto exit_unlock;\r\nn = 32;\r\nhead = ch->ch_w_head & WQUEUEMASK;\r\ntail = ch->ch_w_tail & WQUEUEMASK;\r\nqlen = (head - tail) & WQUEUEMASK;\r\nn = min(n, qlen);\r\nwhile (n > 0) {\r\nif (ch->ch_digi.digi_flags & DIGI_RTS_TOGGLE) {\r\nif (!(ch->ch_mostat & UART_MCR_RTS)) {\r\nch->ch_mostat |= (UART_MCR_RTS);\r\ncls_assert_modem_signals(ch);\r\n}\r\nch->ch_tun.un_flags |= (UN_EMPTY);\r\n}\r\nif (ch->ch_digi.digi_flags & DIGI_DTR_TOGGLE) {\r\nif (!(ch->ch_mostat & UART_MCR_DTR)) {\r\nch->ch_mostat |= (UART_MCR_DTR);\r\ncls_assert_modem_signals(ch);\r\n}\r\nch->ch_tun.un_flags |= (UN_EMPTY);\r\n}\r\nwriteb(ch->ch_wqueue[ch->ch_w_tail], &ch->ch_cls_uart->txrx);\r\nch->ch_w_tail++;\r\nch->ch_w_tail &= WQUEUEMASK;\r\nch->ch_txcount++;\r\nlen_written++;\r\nn--;\r\n}\r\nif (len_written > 0)\r\nch->ch_flags &= ~(CH_TX_FIFO_EMPTY | CH_TX_FIFO_LWM);\r\nexit_unlock:\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\n}\r\nstatic void cls_parse_modem(struct channel_t *ch, unsigned char signals)\r\n{\r\nunsigned char msignals = signals;\r\nunsigned long flags;\r\nif (!ch)\r\nreturn;\r\nspin_lock_irqsave(&ch->ch_lock, flags);\r\nif (ch->ch_digi.digi_flags & DIGI_ALTPIN) {\r\nunsigned char mswap = signals;\r\nif (mswap & UART_MSR_DDCD) {\r\nmsignals &= ~UART_MSR_DDCD;\r\nmsignals |= UART_MSR_DDSR;\r\n}\r\nif (mswap & UART_MSR_DDSR) {\r\nmsignals &= ~UART_MSR_DDSR;\r\nmsignals |= UART_MSR_DDCD;\r\n}\r\nif (mswap & UART_MSR_DCD) {\r\nmsignals &= ~UART_MSR_DCD;\r\nmsignals |= UART_MSR_DSR;\r\n}\r\nif (mswap & UART_MSR_DSR) {\r\nmsignals &= ~UART_MSR_DSR;\r\nmsignals |= UART_MSR_DCD;\r\n}\r\n}\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nsignals &= 0xf0;\r\nspin_lock_irqsave(&ch->ch_lock, flags);\r\nif (msignals & UART_MSR_DCD)\r\nch->ch_mistat |= UART_MSR_DCD;\r\nelse\r\nch->ch_mistat &= ~UART_MSR_DCD;\r\nif (msignals & UART_MSR_DSR)\r\nch->ch_mistat |= UART_MSR_DSR;\r\nelse\r\nch->ch_mistat &= ~UART_MSR_DSR;\r\nif (msignals & UART_MSR_RI)\r\nch->ch_mistat |= UART_MSR_RI;\r\nelse\r\nch->ch_mistat &= ~UART_MSR_RI;\r\nif (msignals & UART_MSR_CTS)\r\nch->ch_mistat |= UART_MSR_CTS;\r\nelse\r\nch->ch_mistat &= ~UART_MSR_CTS;\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\n}\r\nstatic inline void cls_parse_isr(struct dgnc_board *brd, uint port)\r\n{\r\nstruct channel_t *ch;\r\nunsigned char isr = 0;\r\nunsigned long flags;\r\nif (port >= brd->nasync)\r\nreturn;\r\nch = brd->channels[port];\r\nwhile (1) {\r\nisr = readb(&ch->ch_cls_uart->isr_fcr);\r\nif (isr & UART_IIR_NO_INT)\r\nbreak;\r\nif (isr & (UART_IIR_RDI | UART_IIR_RDI_TIMEOUT)) {\r\ncls_copy_data_from_uart_to_queue(ch);\r\ndgnc_check_queue_flow_control(ch);\r\n}\r\nif (isr & UART_IIR_THRI) {\r\nspin_lock_irqsave(&ch->ch_lock, flags);\r\nch->ch_flags |= (CH_TX_FIFO_EMPTY | CH_TX_FIFO_LWM);\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\ncls_copy_data_from_queue_to_uart(ch);\r\n}\r\ncls_parse_modem(ch, readb(&ch->ch_cls_uart->msr));\r\n}\r\n}\r\nstatic void cls_flush_uart_write(struct channel_t *ch)\r\n{\r\nif (!ch)\r\nreturn;\r\nwriteb((UART_FCR_ENABLE_FIFO | UART_FCR_CLEAR_XMIT),\r\n&ch->ch_cls_uart->isr_fcr);\r\nudelay(10);\r\nch->ch_flags |= (CH_TX_FIFO_EMPTY | CH_TX_FIFO_LWM);\r\n}\r\nstatic void cls_flush_uart_read(struct channel_t *ch)\r\n{\r\nif (!ch)\r\nreturn;\r\nudelay(10);\r\n}\r\nstatic void cls_param(struct tty_struct *tty)\r\n{\r\nunsigned char lcr = 0;\r\nunsigned char uart_lcr = 0;\r\nunsigned char ier = 0;\r\nunsigned char uart_ier = 0;\r\nuint baud = 9600;\r\nint quot = 0;\r\nstruct dgnc_board *bd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nif (!tty)\r\nreturn;\r\nun = (struct un_t *)tty->driver_data;\r\nif (!un)\r\nreturn;\r\nch = un->un_ch;\r\nif (!ch)\r\nreturn;\r\nbd = ch->ch_bd;\r\nif (!bd)\r\nreturn;\r\nif ((ch->ch_c_cflag & (CBAUD)) == 0) {\r\nch->ch_r_head = 0;\r\nch->ch_r_tail = 0;\r\nch->ch_e_head = 0;\r\nch->ch_e_tail = 0;\r\nch->ch_w_head = 0;\r\nch->ch_w_tail = 0;\r\ncls_flush_uart_write(ch);\r\ncls_flush_uart_read(ch);\r\nch->ch_flags |= (CH_BAUD0);\r\nch->ch_mostat &= ~(UART_MCR_RTS | UART_MCR_DTR);\r\ncls_assert_modem_signals(ch);\r\nch->ch_old_baud = 0;\r\nreturn;\r\n} else if (ch->ch_custom_speed) {\r\nbaud = ch->ch_custom_speed;\r\nif (ch->ch_flags & CH_BAUD0) {\r\nch->ch_flags &= ~(CH_BAUD0);\r\nif (!(ch->ch_digi.digi_flags & DIGI_RTS_TOGGLE))\r\nch->ch_mostat |= (UART_MCR_RTS);\r\nif (!(ch->ch_digi.digi_flags & DIGI_DTR_TOGGLE))\r\nch->ch_mostat |= (UART_MCR_DTR);\r\n}\r\n} else {\r\nint iindex = 0;\r\nint jindex = 0;\r\nulong bauds[4][16] = {\r\n{\r\n0, 50, 75, 110,\r\n134, 150, 200, 300,\r\n600, 1200, 1800, 2400,\r\n4800, 9600, 19200, 38400 },\r\n{\r\n0, 57600, 115200, 230400,\r\n460800, 150, 200, 921600,\r\n600, 1200, 1800, 2400,\r\n4800, 9600, 19200, 38400 },\r\n{\r\n0, 57600, 76800, 115200,\r\n131657, 153600, 230400, 460800,\r\n921600, 1200, 1800, 2400,\r\n4800, 9600, 19200, 38400 },\r\n{\r\n0, 57600, 115200, 230400,\r\n460800, 150, 200, 921600,\r\n600, 1200, 1800, 2400,\r\n4800, 9600, 19200, 38400 }\r\n};\r\nif (!(ch->ch_tun.un_flags & UN_ISOPEN) &&\r\n(un->un_type == DGNC_PRINT))\r\nbaud = C_BAUD(ch->ch_pun.un_tty) & 0xff;\r\nelse\r\nbaud = C_BAUD(ch->ch_tun.un_tty) & 0xff;\r\nif (ch->ch_c_cflag & CBAUDEX)\r\niindex = 1;\r\nif (ch->ch_digi.digi_flags & DIGI_FAST)\r\niindex += 2;\r\njindex = baud;\r\nif ((iindex >= 0) && (iindex < 4) && (jindex >= 0) &&\r\n(jindex < 16)) {\r\nbaud = bauds[iindex][jindex];\r\n} else {\r\nbaud = 0;\r\n}\r\nif (baud == 0)\r\nbaud = 9600;\r\nif (ch->ch_flags & CH_BAUD0) {\r\nch->ch_flags &= ~(CH_BAUD0);\r\nif (!(ch->ch_digi.digi_flags & DIGI_RTS_TOGGLE))\r\nch->ch_mostat |= (UART_MCR_RTS);\r\nif (!(ch->ch_digi.digi_flags & DIGI_DTR_TOGGLE))\r\nch->ch_mostat |= (UART_MCR_DTR);\r\n}\r\n}\r\nif (ch->ch_c_cflag & PARENB)\r\nlcr |= UART_LCR_PARITY;\r\nif (!(ch->ch_c_cflag & PARODD))\r\nlcr |= UART_LCR_EPAR;\r\n#ifdef CMSPAR\r\nif (ch->ch_c_cflag & CMSPAR)\r\nlcr |= UART_LCR_SPAR;\r\n#endif\r\nif (ch->ch_c_cflag & CSTOPB)\r\nlcr |= UART_LCR_STOP;\r\nswitch (ch->ch_c_cflag & CSIZE) {\r\ncase CS5:\r\nlcr |= UART_LCR_WLEN5;\r\nbreak;\r\ncase CS6:\r\nlcr |= UART_LCR_WLEN6;\r\nbreak;\r\ncase CS7:\r\nlcr |= UART_LCR_WLEN7;\r\nbreak;\r\ncase CS8:\r\ndefault:\r\nlcr |= UART_LCR_WLEN8;\r\nbreak;\r\n}\r\nuart_ier = readb(&ch->ch_cls_uart->ier);\r\nier = uart_ier;\r\nuart_lcr = readb(&ch->ch_cls_uart->lcr);\r\nif (baud == 0)\r\nbaud = 9600;\r\nquot = ch->ch_bd->bd_dividend / baud;\r\nif (quot != 0 && ch->ch_old_baud != baud) {\r\nch->ch_old_baud = baud;\r\nwriteb(UART_LCR_DLAB, &ch->ch_cls_uart->lcr);\r\nwriteb((quot & 0xff), &ch->ch_cls_uart->txrx);\r\nwriteb((quot >> 8), &ch->ch_cls_uart->ier);\r\nwriteb(lcr, &ch->ch_cls_uart->lcr);\r\n}\r\nif (uart_lcr != lcr)\r\nwriteb(lcr, &ch->ch_cls_uart->lcr);\r\nif (ch->ch_c_cflag & CREAD)\r\nier |= (UART_IER_RDI | UART_IER_RLSI);\r\nelse\r\nier &= ~(UART_IER_RDI | UART_IER_RLSI);\r\nif ((ch->ch_digi.digi_flags & CTSPACE) ||\r\n(ch->ch_digi.digi_flags & RTSPACE) ||\r\n(ch->ch_c_cflag & CRTSCTS) ||\r\n!(ch->ch_digi.digi_flags & DIGI_FORCEDCD) ||\r\n!(ch->ch_c_cflag & CLOCAL))\r\nier |= UART_IER_MSI;\r\nelse\r\nier &= ~UART_IER_MSI;\r\nier |= UART_IER_THRI;\r\nif (ier != uart_ier)\r\nwriteb(ier, &ch->ch_cls_uart->ier);\r\nif (ch->ch_digi.digi_flags & CTSPACE || ch->ch_c_cflag & CRTSCTS) {\r\ncls_set_cts_flow_control(ch);\r\n} else if (ch->ch_c_iflag & IXON) {\r\nif ((ch->ch_startc == _POSIX_VDISABLE) ||\r\n(ch->ch_stopc == _POSIX_VDISABLE))\r\ncls_set_no_output_flow_control(ch);\r\nelse\r\ncls_set_ixon_flow_control(ch);\r\n} else {\r\ncls_set_no_output_flow_control(ch);\r\n}\r\nif (ch->ch_digi.digi_flags & RTSPACE || ch->ch_c_cflag & CRTSCTS) {\r\ncls_set_rts_flow_control(ch);\r\n} else if (ch->ch_c_iflag & IXOFF) {\r\nif ((ch->ch_startc == _POSIX_VDISABLE) ||\r\n(ch->ch_stopc == _POSIX_VDISABLE))\r\ncls_set_no_input_flow_control(ch);\r\nelse\r\ncls_set_ixoff_flow_control(ch);\r\n} else {\r\ncls_set_no_input_flow_control(ch);\r\n}\r\ncls_assert_modem_signals(ch);\r\ncls_parse_modem(ch, readb(&ch->ch_cls_uart->msr));\r\n}\r\nstatic void cls_tasklet(unsigned long data)\r\n{\r\nstruct dgnc_board *bd = (struct dgnc_board *)data;\r\nstruct channel_t *ch;\r\nunsigned long flags;\r\nint i;\r\nint state = 0;\r\nint ports = 0;\r\nif (!bd)\r\nreturn;\r\nspin_lock_irqsave(&bd->bd_lock, flags);\r\nstate = bd->state;\r\nports = bd->nasync;\r\nspin_unlock_irqrestore(&bd->bd_lock, flags);\r\nspin_lock_irqsave(&bd->bd_intr_lock, flags);\r\nif ((state == BOARD_READY) && (ports > 0)) {\r\nfor (i = 0; i < ports; i++) {\r\nch = bd->channels[i];\r\ndgnc_input(ch);\r\ncls_copy_data_from_queue_to_uart(ch);\r\ndgnc_wakeup_writes(ch);\r\ndgnc_carrier(ch);\r\nif (ch->ch_stop_sending_break)\r\ncls_clear_break(ch, 0);\r\n}\r\n}\r\nspin_unlock_irqrestore(&bd->bd_intr_lock, flags);\r\n}\r\nstatic irqreturn_t cls_intr(int irq, void *voidbrd)\r\n{\r\nstruct dgnc_board *brd = voidbrd;\r\nuint i = 0;\r\nunsigned char poll_reg;\r\nunsigned long flags;\r\nif (!brd)\r\nreturn IRQ_NONE;\r\nspin_lock_irqsave(&brd->bd_intr_lock, flags);\r\npoll_reg = readb(brd->re_map_membase + UART_CLASSIC_POLL_ADDR_OFFSET);\r\nif (!poll_reg) {\r\nspin_unlock_irqrestore(&brd->bd_intr_lock, flags);\r\nreturn IRQ_NONE;\r\n}\r\nfor (i = 0; i < brd->nasync; i++)\r\ncls_parse_isr(brd, i);\r\ntasklet_schedule(&brd->helper_tasklet);\r\nspin_unlock_irqrestore(&brd->bd_intr_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void cls_disable_receiver(struct channel_t *ch)\r\n{\r\nunsigned char tmp = readb(&ch->ch_cls_uart->ier);\r\ntmp &= ~(UART_IER_RDI);\r\nwriteb(tmp, &ch->ch_cls_uart->ier);\r\n}\r\nstatic void cls_enable_receiver(struct channel_t *ch)\r\n{\r\nunsigned char tmp = readb(&ch->ch_cls_uart->ier);\r\ntmp |= (UART_IER_RDI);\r\nwriteb(tmp, &ch->ch_cls_uart->ier);\r\n}\r\nstatic int cls_drain(struct tty_struct *tty, uint seconds)\r\n{\r\nunsigned long flags;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nif (!tty)\r\nreturn -ENXIO;\r\nun = (struct un_t *)tty->driver_data;\r\nif (!un)\r\nreturn -ENXIO;\r\nch = un->un_ch;\r\nif (!ch)\r\nreturn -ENXIO;\r\nspin_lock_irqsave(&ch->ch_lock, flags);\r\nun->un_flags |= UN_EMPTY;\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nreturn wait_event_interruptible(un->un_flags_wait,\r\n((un->un_flags & UN_EMPTY) == 0));\r\n}\r\nstatic void cls_send_start_character(struct channel_t *ch)\r\n{\r\nif (!ch)\r\nreturn;\r\nif (ch->ch_startc != _POSIX_VDISABLE) {\r\nch->ch_xon_sends++;\r\nwriteb(ch->ch_startc, &ch->ch_cls_uart->txrx);\r\n}\r\n}\r\nstatic void cls_send_stop_character(struct channel_t *ch)\r\n{\r\nif (!ch)\r\nreturn;\r\nif (ch->ch_stopc != _POSIX_VDISABLE) {\r\nch->ch_xoff_sends++;\r\nwriteb(ch->ch_stopc, &ch->ch_cls_uart->txrx);\r\n}\r\n}\r\nstatic void cls_uart_init(struct channel_t *ch)\r\n{\r\nunsigned char lcrb = readb(&ch->ch_cls_uart->lcr);\r\nunsigned char isr_fcr = 0;\r\nwriteb(0, &ch->ch_cls_uart->ier);\r\nwriteb(UART_EXAR654_ENHANCED_REGISTER_SET, &ch->ch_cls_uart->lcr);\r\nisr_fcr = readb(&ch->ch_cls_uart->isr_fcr);\r\nisr_fcr |= (UART_EXAR654_EFR_ECB);\r\nwriteb(isr_fcr, &ch->ch_cls_uart->isr_fcr);\r\nwriteb(lcrb, &ch->ch_cls_uart->lcr);\r\nreadb(&ch->ch_cls_uart->txrx);\r\nwriteb(UART_FCR_ENABLE_FIFO | UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT,\r\n&ch->ch_cls_uart->isr_fcr);\r\nusleep_range(10, 20);\r\nch->ch_flags |= (CH_FIFO_ENABLED | CH_TX_FIFO_EMPTY | CH_TX_FIFO_LWM);\r\nreadb(&ch->ch_cls_uart->lsr);\r\nreadb(&ch->ch_cls_uart->msr);\r\n}\r\nstatic void cls_uart_off(struct channel_t *ch)\r\n{\r\nwriteb(0, &ch->ch_cls_uart->ier);\r\n}\r\nstatic uint cls_get_uart_bytes_left(struct channel_t *ch)\r\n{\r\nunsigned char left = 0;\r\nunsigned char lsr = 0;\r\nif (!ch)\r\nreturn 0;\r\nlsr = readb(&ch->ch_cls_uart->lsr);\r\nif (!(lsr & UART_LSR_TEMT)) {\r\nif (ch->ch_flags & CH_TX_FIFO_EMPTY)\r\ntasklet_schedule(&ch->ch_bd->helper_tasklet);\r\nleft = 1;\r\n} else {\r\nch->ch_flags |= (CH_TX_FIFO_EMPTY | CH_TX_FIFO_LWM);\r\nleft = 0;\r\n}\r\nreturn left;\r\n}\r\nstatic void cls_send_break(struct channel_t *ch, int msecs)\r\n{\r\nif (!ch)\r\nreturn;\r\nif (msecs == 0) {\r\nif (ch->ch_flags & CH_BREAK_SENDING) {\r\nunsigned char temp = readb(&ch->ch_cls_uart->lcr);\r\nwriteb((temp & ~UART_LCR_SBC), &ch->ch_cls_uart->lcr);\r\nch->ch_flags &= ~(CH_BREAK_SENDING);\r\nch->ch_stop_sending_break = 0;\r\n}\r\nreturn;\r\n}\r\nch->ch_stop_sending_break = jiffies + dgnc_jiffies_from_ms(msecs);\r\nif (!(ch->ch_flags & CH_BREAK_SENDING)) {\r\nunsigned char temp = readb(&ch->ch_cls_uart->lcr);\r\nwriteb((temp | UART_LCR_SBC), &ch->ch_cls_uart->lcr);\r\nch->ch_flags |= (CH_BREAK_SENDING);\r\n}\r\n}\r\nstatic void cls_send_immediate_char(struct channel_t *ch, unsigned char c)\r\n{\r\nif (!ch)\r\nreturn;\r\nwriteb(c, &ch->ch_cls_uart->txrx);\r\n}\r\nstatic void cls_vpd(struct dgnc_board *brd)\r\n{\r\nulong vpdbase;\r\nu8 __iomem *re_map_vpdbase;\r\nint i = 0;\r\nvpdbase = pci_resource_start(brd->pdev, 3);\r\nif (!vpdbase)\r\nreturn;\r\nre_map_vpdbase = ioremap(vpdbase, 0x400);\r\nif (!re_map_vpdbase)\r\nreturn;\r\nfor (i = 0; i < 0x40; i++) {\r\nbrd->vpd[i] = readb(re_map_vpdbase + i);\r\npr_info("%x ", brd->vpd[i]);\r\n}\r\npr_info("\n");\r\niounmap(re_map_vpdbase);\r\n}
