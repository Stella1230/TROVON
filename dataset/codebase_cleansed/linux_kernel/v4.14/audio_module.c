static int gbaudio_request_jack(struct gbaudio_module_info *module,\r\nstruct gb_audio_jack_event_request *req)\r\n{\r\nint report;\r\nstruct snd_jack *jack = module->headset_jack.jack;\r\nstruct snd_jack *btn_jack = module->button_jack.jack;\r\nif (!jack) {\r\ndev_err_ratelimited(module->dev,\r\n"Invalid jack event received:type: %u, event: %u\n",\r\nreq->jack_attribute, req->event);\r\nreturn -EINVAL;\r\n}\r\ndev_warn_ratelimited(module->dev,\r\n"Jack Event received: type: %u, event: %u\n",\r\nreq->jack_attribute, req->event);\r\nif (req->event == GB_AUDIO_JACK_EVENT_REMOVAL) {\r\nmodule->jack_type = 0;\r\nif (btn_jack && module->button_status) {\r\nsnd_soc_jack_report(&module->button_jack, 0,\r\nmodule->button_mask);\r\nmodule->button_status = 0;\r\n}\r\nsnd_soc_jack_report(&module->headset_jack, 0,\r\nmodule->jack_mask);\r\nreturn 0;\r\n}\r\nreport = req->jack_attribute & module->jack_mask;\r\nif (!report) {\r\ndev_err_ratelimited(module->dev,\r\n"Invalid jack event received:type: %u, event: %u\n",\r\nreq->jack_attribute, req->event);\r\nreturn -EINVAL;\r\n}\r\nif (module->jack_type)\r\ndev_warn_ratelimited(module->dev,\r\n"Modifying jack from %d to %d\n",\r\nmodule->jack_type, report);\r\nmodule->jack_type = report;\r\nsnd_soc_jack_report(&module->headset_jack, report, module->jack_mask);\r\nreturn 0;\r\n}\r\nstatic int gbaudio_request_button(struct gbaudio_module_info *module,\r\nstruct gb_audio_button_event_request *req)\r\n{\r\nint soc_button_id, report;\r\nstruct snd_jack *btn_jack = module->button_jack.jack;\r\nif (!btn_jack) {\r\ndev_err_ratelimited(module->dev,\r\n"Invalid button event received:type: %u, event: %u\n",\r\nreq->button_id, req->event);\r\nreturn -EINVAL;\r\n}\r\ndev_warn_ratelimited(module->dev,\r\n"Button Event received: id: %u, event: %u\n",\r\nreq->button_id, req->event);\r\nif (!module->jack_type) {\r\ndev_err_ratelimited(module->dev,\r\n"Jack not present. Bogus event!!\n");\r\nreturn -EINVAL;\r\n}\r\nreport = module->button_status & module->button_mask;\r\nsoc_button_id = 0;\r\nswitch (req->button_id) {\r\ncase 1:\r\nsoc_button_id = SND_JACK_BTN_0 & module->button_mask;\r\nbreak;\r\ncase 2:\r\nsoc_button_id = SND_JACK_BTN_1 & module->button_mask;\r\nbreak;\r\ncase 3:\r\nsoc_button_id = SND_JACK_BTN_2 & module->button_mask;\r\nbreak;\r\ncase 4:\r\nsoc_button_id = SND_JACK_BTN_3 & module->button_mask;\r\nbreak;\r\n}\r\nif (!soc_button_id) {\r\ndev_err_ratelimited(module->dev,\r\n"Invalid button request received\n");\r\nreturn -EINVAL;\r\n}\r\nif (req->event == GB_AUDIO_BUTTON_EVENT_PRESS)\r\nreport = report | soc_button_id;\r\nelse\r\nreport = report & ~soc_button_id;\r\nmodule->button_status = report;\r\nsnd_soc_jack_report(&module->button_jack, report, module->button_mask);\r\nreturn 0;\r\n}\r\nstatic int gbaudio_request_stream(struct gbaudio_module_info *module,\r\nstruct gb_audio_streaming_event_request *req)\r\n{\r\ndev_warn(module->dev, "Audio Event received: cport: %u, event: %u\n",\r\nle16_to_cpu(req->data_cport), req->event);\r\nreturn 0;\r\n}\r\nstatic int gbaudio_codec_request_handler(struct gb_operation *op)\r\n{\r\nstruct gb_connection *connection = op->connection;\r\nstruct gbaudio_module_info *module =\r\ngreybus_get_drvdata(connection->bundle);\r\nstruct gb_operation_msg_hdr *header = op->request->header;\r\nstruct gb_audio_streaming_event_request *stream_req;\r\nstruct gb_audio_jack_event_request *jack_req;\r\nstruct gb_audio_button_event_request *button_req;\r\nint ret;\r\nswitch (header->type) {\r\ncase GB_AUDIO_TYPE_STREAMING_EVENT:\r\nstream_req = op->request->payload;\r\nret = gbaudio_request_stream(module, stream_req);\r\nbreak;\r\ncase GB_AUDIO_TYPE_JACK_EVENT:\r\njack_req = op->request->payload;\r\nret = gbaudio_request_jack(module, jack_req);\r\nbreak;\r\ncase GB_AUDIO_TYPE_BUTTON_EVENT:\r\nbutton_req = op->request->payload;\r\nret = gbaudio_request_button(module, button_req);\r\nbreak;\r\ndefault:\r\ndev_err_ratelimited(&connection->bundle->dev,\r\n"Invalid Audio Event received\n");\r\nreturn -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int gb_audio_add_mgmt_connection(struct gbaudio_module_info *gbmodule,\r\nstruct greybus_descriptor_cport *cport_desc,\r\nstruct gb_bundle *bundle)\r\n{\r\nstruct gb_connection *connection;\r\nif (gbmodule->mgmt_connection) {\r\ndev_err(&bundle->dev,\r\n"Can't have multiple Management connections\n");\r\nreturn -ENODEV;\r\n}\r\nconnection = gb_connection_create(bundle, le16_to_cpu(cport_desc->id),\r\ngbaudio_codec_request_handler);\r\nif (IS_ERR(connection))\r\nreturn PTR_ERR(connection);\r\ngreybus_set_drvdata(bundle, gbmodule);\r\ngbmodule->mgmt_connection = connection;\r\nreturn 0;\r\n}\r\nstatic int gb_audio_add_data_connection(struct gbaudio_module_info *gbmodule,\r\nstruct greybus_descriptor_cport *cport_desc,\r\nstruct gb_bundle *bundle)\r\n{\r\nstruct gb_connection *connection;\r\nstruct gbaudio_data_connection *dai;\r\ndai = devm_kzalloc(gbmodule->dev, sizeof(*dai), GFP_KERNEL);\r\nif (!dai)\r\nreturn -ENOMEM;\r\nconnection = gb_connection_create_offloaded(bundle,\r\nle16_to_cpu(cport_desc->id),\r\nGB_CONNECTION_FLAG_CSD);\r\nif (IS_ERR(connection)) {\r\ndevm_kfree(gbmodule->dev, dai);\r\nreturn PTR_ERR(connection);\r\n}\r\ngreybus_set_drvdata(bundle, gbmodule);\r\ndai->id = 0;\r\ndai->data_cport = connection->intf_cport_id;\r\ndai->connection = connection;\r\nlist_add(&dai->list, &gbmodule->data_list);\r\nreturn 0;\r\n}\r\nstatic int gb_audio_probe(struct gb_bundle *bundle,\r\nconst struct greybus_bundle_id *id)\r\n{\r\nstruct device *dev = &bundle->dev;\r\nstruct gbaudio_module_info *gbmodule;\r\nstruct greybus_descriptor_cport *cport_desc;\r\nstruct gb_audio_manager_module_descriptor desc;\r\nstruct gbaudio_data_connection *dai, *_dai;\r\nint ret, i;\r\nstruct gb_audio_topology *topology;\r\nif (bundle->num_cports < 2)\r\nreturn -ENODEV;\r\ngbmodule = devm_kzalloc(dev, sizeof(*gbmodule), GFP_KERNEL);\r\nif (!gbmodule)\r\nreturn -ENOMEM;\r\ngbmodule->num_data_connections = bundle->num_cports - 1;\r\nINIT_LIST_HEAD(&gbmodule->data_list);\r\nINIT_LIST_HEAD(&gbmodule->widget_list);\r\nINIT_LIST_HEAD(&gbmodule->ctl_list);\r\nINIT_LIST_HEAD(&gbmodule->widget_ctl_list);\r\ngbmodule->dev = dev;\r\nsnprintf(gbmodule->name, NAME_SIZE, "%s.%s", dev->driver->name,\r\ndev_name(dev));\r\ngreybus_set_drvdata(bundle, gbmodule);\r\nfor (i = 0; i < bundle->num_cports; i++) {\r\ncport_desc = &bundle->cport_desc[i];\r\nswitch (cport_desc->protocol_id) {\r\ncase GREYBUS_PROTOCOL_AUDIO_MGMT:\r\nret = gb_audio_add_mgmt_connection(gbmodule, cport_desc,\r\nbundle);\r\nif (ret)\r\ngoto destroy_connections;\r\nbreak;\r\ncase GREYBUS_PROTOCOL_AUDIO_DATA:\r\nret = gb_audio_add_data_connection(gbmodule, cport_desc,\r\nbundle);\r\nif (ret)\r\ngoto destroy_connections;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "Unsupported protocol: 0x%02x\n",\r\ncport_desc->protocol_id);\r\nret = -ENODEV;\r\ngoto destroy_connections;\r\n}\r\n}\r\nif (!gbmodule->mgmt_connection) {\r\nret = -EINVAL;\r\ndev_err(dev, "Missing management connection\n");\r\ngoto destroy_connections;\r\n}\r\nret = gb_connection_enable(gbmodule->mgmt_connection);\r\nif (ret) {\r\ndev_err(dev, "%d: Error while enabling mgmt connection\n", ret);\r\ngoto destroy_connections;\r\n}\r\ngbmodule->dev_id = gbmodule->mgmt_connection->intf->interface_id;\r\nret = gb_audio_gb_get_topology(gbmodule->mgmt_connection, &topology);\r\nif (ret) {\r\ndev_err(dev, "%d:Error while fetching topology\n", ret);\r\ngoto disable_connection;\r\n}\r\nret = gbaudio_tplg_parse_data(gbmodule, topology);\r\nif (ret) {\r\ndev_err(dev, "%d:Error while parsing topology data\n",\r\nret);\r\ngoto free_topology;\r\n}\r\ngbmodule->topology = topology;\r\nlist_for_each_entry(dai, &gbmodule->data_list, list) {\r\nret = gb_connection_enable(dai->connection);\r\nif (ret) {\r\ndev_err(dev,\r\n"%d:Error while enabling %d:data connection\n",\r\nret, dai->data_cport);\r\ngoto disable_data_connection;\r\n}\r\n}\r\nret = gbaudio_register_module(gbmodule);\r\nif (ret)\r\ngoto disable_data_connection;\r\ndev_dbg(dev, "Inform set_event:%d to above layer\n", 1);\r\nstrlcpy(desc.name, gbmodule->name, GB_AUDIO_MANAGER_MODULE_NAME_LEN);\r\ndesc.vid = 2;\r\ndesc.pid = 3;\r\ndesc.intf_id = gbmodule->dev_id;\r\ndesc.op_devices = gbmodule->op_devices;\r\ndesc.ip_devices = gbmodule->ip_devices;\r\ngbmodule->manager_id = gb_audio_manager_add(&desc);\r\ndev_dbg(dev, "Add GB Audio device:%s\n", gbmodule->name);\r\ngb_pm_runtime_put_autosuspend(bundle);\r\nreturn 0;\r\ndisable_data_connection:\r\nlist_for_each_entry_safe(dai, _dai, &gbmodule->data_list, list)\r\ngb_connection_disable(dai->connection);\r\ngbaudio_tplg_release(gbmodule);\r\ngbmodule->topology = NULL;\r\nfree_topology:\r\nkfree(topology);\r\ndisable_connection:\r\ngb_connection_disable(gbmodule->mgmt_connection);\r\ndestroy_connections:\r\nlist_for_each_entry_safe(dai, _dai, &gbmodule->data_list, list) {\r\ngb_connection_destroy(dai->connection);\r\nlist_del(&dai->list);\r\ndevm_kfree(dev, dai);\r\n}\r\nif (gbmodule->mgmt_connection)\r\ngb_connection_destroy(gbmodule->mgmt_connection);\r\ndevm_kfree(dev, gbmodule);\r\nreturn ret;\r\n}\r\nstatic void gb_audio_disconnect(struct gb_bundle *bundle)\r\n{\r\nstruct gbaudio_module_info *gbmodule = greybus_get_drvdata(bundle);\r\nstruct gbaudio_data_connection *dai, *_dai;\r\ngb_pm_runtime_get_sync(bundle);\r\ngbaudio_unregister_module(gbmodule);\r\ngb_audio_manager_remove(gbmodule->manager_id);\r\ngbaudio_tplg_release(gbmodule);\r\nkfree(gbmodule->topology);\r\ngbmodule->topology = NULL;\r\ngb_connection_disable(gbmodule->mgmt_connection);\r\nlist_for_each_entry_safe(dai, _dai, &gbmodule->data_list, list) {\r\ngb_connection_disable(dai->connection);\r\ngb_connection_destroy(dai->connection);\r\nlist_del(&dai->list);\r\ndevm_kfree(gbmodule->dev, dai);\r\n}\r\ngb_connection_destroy(gbmodule->mgmt_connection);\r\ngbmodule->mgmt_connection = NULL;\r\ndevm_kfree(&bundle->dev, gbmodule);\r\n}\r\nstatic int gb_audio_suspend(struct device *dev)\r\n{\r\nstruct gb_bundle *bundle = to_gb_bundle(dev);\r\nstruct gbaudio_module_info *gbmodule = greybus_get_drvdata(bundle);\r\nstruct gbaudio_data_connection *dai;\r\nlist_for_each_entry(dai, &gbmodule->data_list, list)\r\ngb_connection_disable(dai->connection);\r\ngb_connection_disable(gbmodule->mgmt_connection);\r\nreturn 0;\r\n}\r\nstatic int gb_audio_resume(struct device *dev)\r\n{\r\nstruct gb_bundle *bundle = to_gb_bundle(dev);\r\nstruct gbaudio_module_info *gbmodule = greybus_get_drvdata(bundle);\r\nstruct gbaudio_data_connection *dai;\r\nint ret;\r\nret = gb_connection_enable(gbmodule->mgmt_connection);\r\nif (ret) {\r\ndev_err(dev, "%d:Error while enabling mgmt connection\n", ret);\r\nreturn ret;\r\n}\r\nlist_for_each_entry(dai, &gbmodule->data_list, list) {\r\nret = gb_connection_enable(dai->connection);\r\nif (ret) {\r\ndev_err(dev,\r\n"%d:Error while enabling %d:data connection\n",\r\nret, dai->data_cport);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}
