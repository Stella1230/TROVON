static s32 abssub(s32 a, s32 b)\r\n{\r\nif (a > b)\r\nreturn a - b;\r\nelse\r\nreturn b - a;\r\n}\r\nstatic void stv6110_release(struct dvb_frontend *fe)\r\n{\r\nkfree(fe->tuner_priv);\r\nfe->tuner_priv = NULL;\r\n}\r\nstatic int stv6110_write_regs(struct dvb_frontend *fe, u8 buf[],\r\nint start, int len)\r\n{\r\nstruct stv6110_priv *priv = fe->tuner_priv;\r\nint rc;\r\nu8 cmdbuf[MAX_XFER_SIZE];\r\nstruct i2c_msg msg = {\r\n.addr = priv->i2c_address,\r\n.flags = 0,\r\n.buf = cmdbuf,\r\n.len = len + 1\r\n};\r\ndprintk("%s\n", __func__);\r\nif (1 + len > sizeof(cmdbuf)) {\r\nprintk(KERN_WARNING\r\n"%s: i2c wr: len=%d is too big!\n",\r\nKBUILD_MODNAME, len);\r\nreturn -EINVAL;\r\n}\r\nif (start + len > 8)\r\nreturn -EINVAL;\r\nmemcpy(&cmdbuf[1], buf, len);\r\ncmdbuf[0] = start;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nrc = i2c_transfer(priv->i2c, &msg, 1);\r\nif (rc != 1)\r\ndprintk("%s: i2c error\n", __func__);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nreturn 0;\r\n}\r\nstatic int stv6110_read_regs(struct dvb_frontend *fe, u8 regs[],\r\nint start, int len)\r\n{\r\nstruct stv6110_priv *priv = fe->tuner_priv;\r\nint rc;\r\nu8 reg[] = { start };\r\nstruct i2c_msg msg[] = {\r\n{\r\n.addr = priv->i2c_address,\r\n.flags = 0,\r\n.buf = reg,\r\n.len = 1,\r\n}, {\r\n.addr = priv->i2c_address,\r\n.flags = I2C_M_RD,\r\n.buf = regs,\r\n.len = len,\r\n},\r\n};\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nrc = i2c_transfer(priv->i2c, msg, 2);\r\nif (rc != 2)\r\ndprintk("%s: i2c error\n", __func__);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nmemcpy(&priv->regs[start], regs, len);\r\nreturn 0;\r\n}\r\nstatic int stv6110_read_reg(struct dvb_frontend *fe, int start)\r\n{\r\nu8 buf[] = { 0 };\r\nstv6110_read_regs(fe, buf, start, 1);\r\nreturn buf[0];\r\n}\r\nstatic int stv6110_sleep(struct dvb_frontend *fe)\r\n{\r\nu8 reg[] = { 0 };\r\nstv6110_write_regs(fe, reg, 0, 1);\r\nreturn 0;\r\n}\r\nstatic u32 carrier_width(u32 symbol_rate, enum fe_rolloff rolloff)\r\n{\r\nu32 rlf;\r\nswitch (rolloff) {\r\ncase ROLLOFF_20:\r\nrlf = 20;\r\nbreak;\r\ncase ROLLOFF_25:\r\nrlf = 25;\r\nbreak;\r\ndefault:\r\nrlf = 35;\r\nbreak;\r\n}\r\nreturn symbol_rate + ((symbol_rate * rlf) / 100);\r\n}\r\nstatic int stv6110_set_bandwidth(struct dvb_frontend *fe, u32 bandwidth)\r\n{\r\nstruct stv6110_priv *priv = fe->tuner_priv;\r\nu8 r8, ret = 0x04;\r\nint i;\r\nif ((bandwidth / 2) > 36000000)\r\nr8 = 31;\r\nelse if ((bandwidth / 2) < 5000000)\r\nr8 = 0;\r\nelse\r\nr8 = (bandwidth / 2) / 1000000 - 5;\r\npriv->regs[RSTV6110_CTRL3] &= ~((1 << 6) | 0x1f);\r\npriv->regs[RSTV6110_CTRL3] |= (r8 & 0x1f);\r\nstv6110_write_regs(fe, &priv->regs[RSTV6110_CTRL3], RSTV6110_CTRL3, 1);\r\npriv->regs[RSTV6110_STAT1] |= 0x02;\r\nstv6110_write_regs(fe, &priv->regs[RSTV6110_STAT1], RSTV6110_STAT1, 1);\r\ni = 0;\r\nwhile ((i < 10) && (ret != 0)) {\r\nret = ((stv6110_read_reg(fe, RSTV6110_STAT1)) & 0x02);\r\nmdelay(1);\r\ni++;\r\n}\r\npriv->regs[RSTV6110_CTRL3] |= (1 << 6);\r\nstv6110_write_regs(fe, &priv->regs[RSTV6110_CTRL3], RSTV6110_CTRL3, 1);\r\nreturn 0;\r\n}\r\nstatic int stv6110_init(struct dvb_frontend *fe)\r\n{\r\nstruct stv6110_priv *priv = fe->tuner_priv;\r\nu8 buf0[] = { 0x07, 0x11, 0xdc, 0x85, 0x17, 0x01, 0xe6, 0x1e };\r\nmemcpy(priv->regs, buf0, 8);\r\npriv->regs[RSTV6110_CTRL1] &= ~(0x1f << 3);\r\npriv->regs[RSTV6110_CTRL1] |=\r\n((((priv->mclk / 1000000) - 16) & 0x1f) << 3);\r\npriv->regs[RSTV6110_CTRL2] &= ~0xc0;\r\npriv->regs[RSTV6110_CTRL2] |= (priv->clk_div << 6);\r\nstv6110_write_regs(fe, &priv->regs[RSTV6110_CTRL1], RSTV6110_CTRL1, 8);\r\nmsleep(1);\r\nstv6110_set_bandwidth(fe, 72000000);\r\nreturn 0;\r\n}\r\nstatic int stv6110_get_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\nstruct stv6110_priv *priv = fe->tuner_priv;\r\nu32 nbsteps, divider, psd2, freq;\r\nu8 regs[] = { 0, 0, 0, 0, 0, 0, 0, 0 };\r\nstv6110_read_regs(fe, regs, 0, 8);\r\ndivider = (priv->regs[RSTV6110_TUNING2] & 0x0f) << 8;\r\ndivider += priv->regs[RSTV6110_TUNING1];\r\nnbsteps = (priv->regs[RSTV6110_TUNING2] >> 6) & 3;\r\npsd2 = (priv->regs[RSTV6110_TUNING2] >> 4) & 1;\r\nfreq = divider * (priv->mclk / 1000);\r\nfreq /= (1 << (nbsteps + psd2));\r\nfreq /= 4;\r\n*frequency = freq;\r\nreturn 0;\r\n}\r\nstatic int stv6110_set_frequency(struct dvb_frontend *fe, u32 frequency)\r\n{\r\nstruct stv6110_priv *priv = fe->tuner_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nu8 ret = 0x04;\r\nu32 divider, ref, p, presc, i, result_freq, vco_freq;\r\ns32 p_calc, p_calc_opt = 1000, r_div, r_div_opt = 0, p_val;\r\ns32 srate;\r\ndprintk("%s, freq=%d kHz, mclk=%d Hz\n", __func__,\r\nfrequency, priv->mclk);\r\npriv->regs[RSTV6110_CTRL1] &= ~(0x1f << 3);\r\npriv->regs[RSTV6110_CTRL1] |=\r\n((((priv->mclk / 1000000) - 16) & 0x1f) << 3);\r\nif (fe->ops.set_property && fe->ops.get_property) {\r\nsrate = c->symbol_rate;\r\ndprintk("%s: Get Frontend parameters: srate=%d\n",\r\n__func__, srate);\r\n} else\r\nsrate = 15000000;\r\npriv->regs[RSTV6110_CTRL2] &= ~0x0f;\r\npriv->regs[RSTV6110_CTRL2] |= (priv->gain & 0x0f);\r\nif (frequency <= 1023000) {\r\np = 1;\r\npresc = 0;\r\n} else if (frequency <= 1300000) {\r\np = 1;\r\npresc = 1;\r\n} else if (frequency <= 2046000) {\r\np = 0;\r\npresc = 0;\r\n} else {\r\np = 0;\r\npresc = 1;\r\n}\r\npriv->regs[RSTV6110_TUNING2] &= ~(1 << 4);\r\npriv->regs[RSTV6110_TUNING2] |= (p << 4);\r\npriv->regs[RSTV6110_TUNING2] &= ~(1 << 5);\r\npriv->regs[RSTV6110_TUNING2] |= (presc << 5);\r\np_val = (int)(1 << (p + 1)) * 10;\r\nfor (r_div = 0; r_div <= 3; r_div++) {\r\np_calc = (priv->mclk / 100000);\r\np_calc /= (1 << (r_div + 1));\r\nif ((abssub(p_calc, p_val)) < (abssub(p_calc_opt, p_val)))\r\nr_div_opt = r_div;\r\np_calc_opt = (priv->mclk / 100000);\r\np_calc_opt /= (1 << (r_div_opt + 1));\r\n}\r\nref = priv->mclk / ((1 << (r_div_opt + 1)) * (1 << (p + 1)));\r\ndivider = (((frequency * 1000) + (ref >> 1)) / ref);\r\npriv->regs[RSTV6110_TUNING2] &= ~(3 << 6);\r\npriv->regs[RSTV6110_TUNING2] |= (((r_div_opt) & 3) << 6);\r\npriv->regs[RSTV6110_TUNING2] &= ~0x0f;\r\npriv->regs[RSTV6110_TUNING2] |= (((divider) >> 8) & 0x0f);\r\npriv->regs[RSTV6110_TUNING1] = (divider & 0xff);\r\npriv->regs[RSTV6110_STAT1] |= 0x04;\r\nstv6110_write_regs(fe, &priv->regs[RSTV6110_CTRL1],\r\nRSTV6110_CTRL1, 8);\r\ni = 0;\r\nwhile ((i < 10) && (ret != 0)) {\r\nret = ((stv6110_read_reg(fe, RSTV6110_STAT1)) & 0x04);\r\nmsleep(1);\r\ni++;\r\n}\r\nret = stv6110_read_reg(fe, RSTV6110_STAT1);\r\nstv6110_get_frequency(fe, &result_freq);\r\nvco_freq = divider * ((priv->mclk / 1000) / ((1 << (r_div_opt + 1))));\r\ndprintk("%s, stat1=%x, lo_freq=%d kHz, vco_frec=%d kHz\n", __func__,\r\nret, result_freq, vco_freq);\r\nreturn 0;\r\n}\r\nstatic int stv6110_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nu32 bandwidth = carrier_width(c->symbol_rate, c->rolloff);\r\nstv6110_set_frequency(fe, c->frequency);\r\nstv6110_set_bandwidth(fe, bandwidth);\r\nreturn 0;\r\n}\r\nstatic int stv6110_get_bandwidth(struct dvb_frontend *fe, u32 *bandwidth)\r\n{\r\nstruct stv6110_priv *priv = fe->tuner_priv;\r\nu8 r8 = 0;\r\nu8 regs[] = { 0, 0, 0, 0, 0, 0, 0, 0 };\r\nstv6110_read_regs(fe, regs, 0, 8);\r\nr8 = priv->regs[RSTV6110_CTRL3] & 0x1f;\r\n*bandwidth = (r8 + 5) * 2000000;\r\nreturn 0;\r\n}\r\nstruct dvb_frontend *stv6110_attach(struct dvb_frontend *fe,\r\nconst struct stv6110_config *config,\r\nstruct i2c_adapter *i2c)\r\n{\r\nstruct stv6110_priv *priv = NULL;\r\nu8 reg0[] = { 0x00, 0x07, 0x11, 0xdc, 0x85, 0x17, 0x01, 0xe6, 0x1e };\r\nstruct i2c_msg msg[] = {\r\n{\r\n.addr = config->i2c_address,\r\n.flags = 0,\r\n.buf = reg0,\r\n.len = 9\r\n}\r\n};\r\nint ret;\r\nreg0[2] &= ~0xc0;\r\nreg0[2] |= (config->clk_div << 6);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nret = i2c_transfer(i2c, msg, 1);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nif (ret != 1)\r\nreturn NULL;\r\npriv = kzalloc(sizeof(struct stv6110_priv), GFP_KERNEL);\r\nif (priv == NULL)\r\nreturn NULL;\r\npriv->i2c_address = config->i2c_address;\r\npriv->i2c = i2c;\r\npriv->mclk = config->mclk;\r\npriv->clk_div = config->clk_div;\r\npriv->gain = config->gain;\r\nmemcpy(&priv->regs, &reg0[1], 8);\r\nmemcpy(&fe->ops.tuner_ops, &stv6110_tuner_ops,\r\nsizeof(struct dvb_tuner_ops));\r\nfe->tuner_priv = priv;\r\nprintk(KERN_INFO "STV6110 attached on addr=%x!\n", priv->i2c_address);\r\nreturn fe;\r\n}
