static size_t vfio_pci_igd_rw(struct vfio_pci_device *vdev, char __user *buf,\r\nsize_t count, loff_t *ppos, bool iswrite)\r\n{\r\nunsigned int i = VFIO_PCI_OFFSET_TO_INDEX(*ppos) - VFIO_PCI_NUM_REGIONS;\r\nvoid *base = vdev->region[i].data;\r\nloff_t pos = *ppos & VFIO_PCI_OFFSET_MASK;\r\nif (pos >= vdev->region[i].size || iswrite)\r\nreturn -EINVAL;\r\ncount = min(count, (size_t)(vdev->region[i].size - pos));\r\nif (copy_to_user(buf, base + pos, count))\r\nreturn -EFAULT;\r\n*ppos += count;\r\nreturn count;\r\n}\r\nstatic void vfio_pci_igd_release(struct vfio_pci_device *vdev,\r\nstruct vfio_pci_region *region)\r\n{\r\nmemunmap(region->data);\r\n}\r\nstatic int vfio_pci_igd_opregion_init(struct vfio_pci_device *vdev)\r\n{\r\n__le32 *dwordp = (__le32 *)(vdev->vconfig + OPREGION_PCI_ADDR);\r\nu32 addr, size;\r\nvoid *base;\r\nint ret;\r\nret = pci_read_config_dword(vdev->pdev, OPREGION_PCI_ADDR, &addr);\r\nif (ret)\r\nreturn ret;\r\nif (!addr || !(~addr))\r\nreturn -ENODEV;\r\nbase = memremap(addr, OPREGION_SIZE, MEMREMAP_WB);\r\nif (!base)\r\nreturn -ENOMEM;\r\nif (memcmp(base, OPREGION_SIGNATURE, 16)) {\r\nmemunmap(base);\r\nreturn -EINVAL;\r\n}\r\nsize = le32_to_cpu(*(__le32 *)(base + 16));\r\nif (!size) {\r\nmemunmap(base);\r\nreturn -EINVAL;\r\n}\r\nsize *= 1024;\r\nif (size != OPREGION_SIZE) {\r\nmemunmap(base);\r\nbase = memremap(addr, size, MEMREMAP_WB);\r\nif (!base)\r\nreturn -ENOMEM;\r\n}\r\nret = vfio_pci_register_dev_region(vdev,\r\nPCI_VENDOR_ID_INTEL | VFIO_REGION_TYPE_PCI_VENDOR_TYPE,\r\nVFIO_REGION_SUBTYPE_INTEL_IGD_OPREGION,\r\n&vfio_pci_igd_regops, size, VFIO_REGION_INFO_FLAG_READ, base);\r\nif (ret) {\r\nmemunmap(base);\r\nreturn ret;\r\n}\r\n*dwordp = cpu_to_le32(addr);\r\nmemset(vdev->pci_config_map + OPREGION_PCI_ADDR,\r\nPCI_CAP_ID_INVALID_VIRT, 4);\r\nreturn ret;\r\n}\r\nstatic size_t vfio_pci_igd_cfg_rw(struct vfio_pci_device *vdev,\r\nchar __user *buf, size_t count, loff_t *ppos,\r\nbool iswrite)\r\n{\r\nunsigned int i = VFIO_PCI_OFFSET_TO_INDEX(*ppos) - VFIO_PCI_NUM_REGIONS;\r\nstruct pci_dev *pdev = vdev->region[i].data;\r\nloff_t pos = *ppos & VFIO_PCI_OFFSET_MASK;\r\nsize_t size;\r\nint ret;\r\nif (pos >= vdev->region[i].size || iswrite)\r\nreturn -EINVAL;\r\nsize = count = min(count, (size_t)(vdev->region[i].size - pos));\r\nif ((pos & 1) && size) {\r\nu8 val;\r\nret = pci_user_read_config_byte(pdev, pos, &val);\r\nif (ret)\r\nreturn pcibios_err_to_errno(ret);\r\nif (copy_to_user(buf + count - size, &val, 1))\r\nreturn -EFAULT;\r\npos++;\r\nsize--;\r\n}\r\nif ((pos & 3) && size > 2) {\r\nu16 val;\r\nret = pci_user_read_config_word(pdev, pos, &val);\r\nif (ret)\r\nreturn pcibios_err_to_errno(ret);\r\nval = cpu_to_le16(val);\r\nif (copy_to_user(buf + count - size, &val, 2))\r\nreturn -EFAULT;\r\npos += 2;\r\nsize -= 2;\r\n}\r\nwhile (size > 3) {\r\nu32 val;\r\nret = pci_user_read_config_dword(pdev, pos, &val);\r\nif (ret)\r\nreturn pcibios_err_to_errno(ret);\r\nval = cpu_to_le32(val);\r\nif (copy_to_user(buf + count - size, &val, 4))\r\nreturn -EFAULT;\r\npos += 4;\r\nsize -= 4;\r\n}\r\nwhile (size >= 2) {\r\nu16 val;\r\nret = pci_user_read_config_word(pdev, pos, &val);\r\nif (ret)\r\nreturn pcibios_err_to_errno(ret);\r\nval = cpu_to_le16(val);\r\nif (copy_to_user(buf + count - size, &val, 2))\r\nreturn -EFAULT;\r\npos += 2;\r\nsize -= 2;\r\n}\r\nwhile (size) {\r\nu8 val;\r\nret = pci_user_read_config_byte(pdev, pos, &val);\r\nif (ret)\r\nreturn pcibios_err_to_errno(ret);\r\nif (copy_to_user(buf + count - size, &val, 1))\r\nreturn -EFAULT;\r\npos++;\r\nsize--;\r\n}\r\n*ppos += count;\r\nreturn count;\r\n}\r\nstatic void vfio_pci_igd_cfg_release(struct vfio_pci_device *vdev,\r\nstruct vfio_pci_region *region)\r\n{\r\nstruct pci_dev *pdev = region->data;\r\npci_dev_put(pdev);\r\n}\r\nstatic int vfio_pci_igd_cfg_init(struct vfio_pci_device *vdev)\r\n{\r\nstruct pci_dev *host_bridge, *lpc_bridge;\r\nint ret;\r\nhost_bridge = pci_get_domain_bus_and_slot(0, 0, PCI_DEVFN(0, 0));\r\nif (!host_bridge)\r\nreturn -ENODEV;\r\nif (host_bridge->vendor != PCI_VENDOR_ID_INTEL ||\r\nhost_bridge->class != (PCI_CLASS_BRIDGE_HOST << 8)) {\r\npci_dev_put(host_bridge);\r\nreturn -EINVAL;\r\n}\r\nret = vfio_pci_register_dev_region(vdev,\r\nPCI_VENDOR_ID_INTEL | VFIO_REGION_TYPE_PCI_VENDOR_TYPE,\r\nVFIO_REGION_SUBTYPE_INTEL_IGD_HOST_CFG,\r\n&vfio_pci_igd_cfg_regops, host_bridge->cfg_size,\r\nVFIO_REGION_INFO_FLAG_READ, host_bridge);\r\nif (ret) {\r\npci_dev_put(host_bridge);\r\nreturn ret;\r\n}\r\nlpc_bridge = pci_get_domain_bus_and_slot(0, 0, PCI_DEVFN(0x1f, 0));\r\nif (!lpc_bridge)\r\nreturn -ENODEV;\r\nif (lpc_bridge->vendor != PCI_VENDOR_ID_INTEL ||\r\nlpc_bridge->class != (PCI_CLASS_BRIDGE_ISA << 8)) {\r\npci_dev_put(lpc_bridge);\r\nreturn -EINVAL;\r\n}\r\nret = vfio_pci_register_dev_region(vdev,\r\nPCI_VENDOR_ID_INTEL | VFIO_REGION_TYPE_PCI_VENDOR_TYPE,\r\nVFIO_REGION_SUBTYPE_INTEL_IGD_LPC_CFG,\r\n&vfio_pci_igd_cfg_regops, lpc_bridge->cfg_size,\r\nVFIO_REGION_INFO_FLAG_READ, lpc_bridge);\r\nif (ret) {\r\npci_dev_put(lpc_bridge);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint vfio_pci_igd_init(struct vfio_pci_device *vdev)\r\n{\r\nint ret;\r\nret = vfio_pci_igd_opregion_init(vdev);\r\nif (ret)\r\nreturn ret;\r\nret = vfio_pci_igd_cfg_init(vdev);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}
