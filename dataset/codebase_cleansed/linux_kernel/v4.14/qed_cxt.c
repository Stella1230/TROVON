static bool src_proto(enum protocol_type type)\r\n{\r\nreturn type == PROTOCOLID_ISCSI ||\r\ntype == PROTOCOLID_FCOE ||\r\ntype == PROTOCOLID_IWARP;\r\n}\r\nstatic bool tm_cid_proto(enum protocol_type type)\r\n{\r\nreturn type == PROTOCOLID_ISCSI ||\r\ntype == PROTOCOLID_FCOE ||\r\ntype == PROTOCOLID_ROCE ||\r\ntype == PROTOCOLID_IWARP;\r\n}\r\nstatic bool tm_tid_proto(enum protocol_type type)\r\n{\r\nreturn type == PROTOCOLID_FCOE;\r\n}\r\nstatic void qed_cxt_cdu_iids(struct qed_cxt_mngr *p_mngr,\r\nstruct qed_cdu_iids *iids)\r\n{\r\nu32 type;\r\nfor (type = 0; type < MAX_CONN_TYPES; type++) {\r\niids->pf_cids += p_mngr->conn_cfg[type].cid_count;\r\niids->per_vf_cids += p_mngr->conn_cfg[type].cids_per_vf;\r\n}\r\n}\r\nstatic void qed_cxt_src_iids(struct qed_cxt_mngr *p_mngr,\r\nstruct qed_src_iids *iids)\r\n{\r\nu32 i;\r\nfor (i = 0; i < MAX_CONN_TYPES; i++) {\r\nif (!src_proto(i))\r\ncontinue;\r\niids->pf_cids += p_mngr->conn_cfg[i].cid_count;\r\niids->per_vf_cids += p_mngr->conn_cfg[i].cids_per_vf;\r\n}\r\niids->pf_cids += p_mngr->arfs_count;\r\n}\r\nstatic void qed_cxt_tm_iids(struct qed_hwfn *p_hwfn,\r\nstruct qed_cxt_mngr *p_mngr,\r\nstruct qed_tm_iids *iids)\r\n{\r\nbool tm_vf_required = false;\r\nbool tm_required = false;\r\nint i, j;\r\nfor (i = MAX_CONN_TYPES - 1; i >= 0; i--) {\r\nstruct qed_conn_type_cfg *p_cfg = &p_mngr->conn_cfg[i];\r\nif (tm_cid_proto(i) || tm_required) {\r\nif (p_cfg->cid_count)\r\ntm_required = true;\r\niids->pf_cids += p_cfg->cid_count;\r\n}\r\nif (tm_cid_proto(i) || tm_vf_required) {\r\nif (p_cfg->cids_per_vf)\r\ntm_vf_required = true;\r\niids->per_vf_cids += p_cfg->cids_per_vf;\r\n}\r\nif (tm_tid_proto(i)) {\r\nstruct qed_tid_seg *segs = p_cfg->tid_seg;\r\nfor (j = 0; j < NUM_TASK_PF_SEGMENTS; j++)\r\niids->pf_tids[j] += segs[j].count;\r\niids->per_vf_tids += segs[NUM_TASK_PF_SEGMENTS].count;\r\n}\r\n}\r\niids->pf_cids = roundup(iids->pf_cids, TM_ALIGN);\r\niids->per_vf_cids = roundup(iids->per_vf_cids, TM_ALIGN);\r\niids->per_vf_tids = roundup(iids->per_vf_tids, TM_ALIGN);\r\nfor (iids->pf_tids_total = 0, j = 0; j < NUM_TASK_PF_SEGMENTS; j++) {\r\niids->pf_tids[j] = roundup(iids->pf_tids[j], TM_ALIGN);\r\niids->pf_tids_total += iids->pf_tids[j];\r\n}\r\n}\r\nstatic void qed_cxt_qm_iids(struct qed_hwfn *p_hwfn,\r\nstruct qed_qm_iids *iids)\r\n{\r\nstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\r\nstruct qed_tid_seg *segs;\r\nu32 vf_cids = 0, type, j;\r\nu32 vf_tids = 0;\r\nfor (type = 0; type < MAX_CONN_TYPES; type++) {\r\niids->cids += p_mngr->conn_cfg[type].cid_count;\r\nvf_cids += p_mngr->conn_cfg[type].cids_per_vf;\r\nsegs = p_mngr->conn_cfg[type].tid_seg;\r\nfor (j = 0; j < NUM_TASK_PF_SEGMENTS; j++)\r\niids->tids += segs[j].count;\r\nvf_tids += segs[NUM_TASK_PF_SEGMENTS].count;\r\n}\r\niids->vf_cids += vf_cids * p_mngr->vf_count;\r\niids->tids += vf_tids * p_mngr->vf_count;\r\nDP_VERBOSE(p_hwfn, QED_MSG_ILT,\r\n"iids: CIDS %08x vf_cids %08x tids %08x vf_tids %08x\n",\r\niids->cids, iids->vf_cids, iids->tids, vf_tids);\r\n}\r\nstatic struct qed_tid_seg *qed_cxt_tid_seg_info(struct qed_hwfn *p_hwfn,\r\nu32 seg)\r\n{\r\nstruct qed_cxt_mngr *p_cfg = p_hwfn->p_cxt_mngr;\r\nu32 i;\r\nfor (i = 0; i < MAX_CONN_TYPES; i++)\r\nif (p_cfg->conn_cfg[i].tid_seg[seg].count)\r\nreturn &p_cfg->conn_cfg[i].tid_seg[seg];\r\nreturn NULL;\r\n}\r\nstatic void qed_cxt_set_srq_count(struct qed_hwfn *p_hwfn, u32 num_srqs)\r\n{\r\nstruct qed_cxt_mngr *p_mgr = p_hwfn->p_cxt_mngr;\r\np_mgr->srq_count = num_srqs;\r\n}\r\nstatic u32 qed_cxt_get_srq_count(struct qed_hwfn *p_hwfn)\r\n{\r\nstruct qed_cxt_mngr *p_mgr = p_hwfn->p_cxt_mngr;\r\nreturn p_mgr->srq_count;\r\n}\r\nstatic void qed_cxt_set_proto_cid_count(struct qed_hwfn *p_hwfn,\r\nenum protocol_type type,\r\nu32 cid_count, u32 vf_cid_cnt)\r\n{\r\nstruct qed_cxt_mngr *p_mgr = p_hwfn->p_cxt_mngr;\r\nstruct qed_conn_type_cfg *p_conn = &p_mgr->conn_cfg[type];\r\np_conn->cid_count = roundup(cid_count, DQ_RANGE_ALIGN);\r\np_conn->cids_per_vf = roundup(vf_cid_cnt, DQ_RANGE_ALIGN);\r\nif (type == PROTOCOLID_ROCE) {\r\nu32 page_sz = p_mgr->clients[ILT_CLI_CDUC].p_size.val;\r\nu32 cxt_size = CONN_CXT_SIZE(p_hwfn);\r\nu32 elems_per_page = ILT_PAGE_IN_BYTES(page_sz) / cxt_size;\r\nu32 align = elems_per_page * DQ_RANGE_ALIGN;\r\np_conn->cid_count = roundup(p_conn->cid_count, align);\r\n}\r\n}\r\nu32 qed_cxt_get_proto_cid_count(struct qed_hwfn *p_hwfn,\r\nenum protocol_type type, u32 *vf_cid)\r\n{\r\nif (vf_cid)\r\n*vf_cid = p_hwfn->p_cxt_mngr->conn_cfg[type].cids_per_vf;\r\nreturn p_hwfn->p_cxt_mngr->conn_cfg[type].cid_count;\r\n}\r\nu32 qed_cxt_get_proto_cid_start(struct qed_hwfn *p_hwfn,\r\nenum protocol_type type)\r\n{\r\nreturn p_hwfn->p_cxt_mngr->acquired[type].start_cid;\r\n}\r\nu32 qed_cxt_get_proto_tid_count(struct qed_hwfn *p_hwfn,\r\nenum protocol_type type)\r\n{\r\nu32 cnt = 0;\r\nint i;\r\nfor (i = 0; i < TASK_SEGMENTS; i++)\r\ncnt += p_hwfn->p_cxt_mngr->conn_cfg[type].tid_seg[i].count;\r\nreturn cnt;\r\n}\r\nstatic void qed_cxt_set_proto_tid_count(struct qed_hwfn *p_hwfn,\r\nenum protocol_type proto,\r\nu8 seg,\r\nu8 seg_type, u32 count, bool has_fl)\r\n{\r\nstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\r\nstruct qed_tid_seg *p_seg = &p_mngr->conn_cfg[proto].tid_seg[seg];\r\np_seg->count = count;\r\np_seg->has_fl_mem = has_fl;\r\np_seg->type = seg_type;\r\n}\r\nstatic void qed_ilt_cli_blk_fill(struct qed_ilt_client_cfg *p_cli,\r\nstruct qed_ilt_cli_blk *p_blk,\r\nu32 start_line, u32 total_size, u32 elem_size)\r\n{\r\nu32 ilt_size = ILT_PAGE_IN_BYTES(p_cli->p_size.val);\r\nif (p_blk->total_size)\r\nreturn;\r\np_blk->total_size = total_size;\r\np_blk->real_size_in_page = 0;\r\nif (elem_size)\r\np_blk->real_size_in_page = (ilt_size / elem_size) * elem_size;\r\np_blk->start_line = start_line;\r\n}\r\nstatic void qed_ilt_cli_adv_line(struct qed_hwfn *p_hwfn,\r\nstruct qed_ilt_client_cfg *p_cli,\r\nstruct qed_ilt_cli_blk *p_blk,\r\nu32 *p_line, enum ilt_clients client_id)\r\n{\r\nif (!p_blk->total_size)\r\nreturn;\r\nif (!p_cli->active)\r\np_cli->first.val = *p_line;\r\np_cli->active = true;\r\n*p_line += DIV_ROUND_UP(p_blk->total_size, p_blk->real_size_in_page);\r\np_cli->last.val = *p_line - 1;\r\nDP_VERBOSE(p_hwfn, QED_MSG_ILT,\r\n"ILT[Client %d] - Lines: [%08x - %08x]. Block - Size %08x [Real %08x] Start line %d\n",\r\nclient_id, p_cli->first.val,\r\np_cli->last.val, p_blk->total_size,\r\np_blk->real_size_in_page, p_blk->start_line);\r\n}\r\nstatic u32 qed_ilt_get_dynamic_line_cnt(struct qed_hwfn *p_hwfn,\r\nenum ilt_clients ilt_client)\r\n{\r\nu32 cid_count = p_hwfn->p_cxt_mngr->conn_cfg[PROTOCOLID_ROCE].cid_count;\r\nstruct qed_ilt_client_cfg *p_cli;\r\nu32 lines_to_skip = 0;\r\nu32 cxts_per_p;\r\nif (ilt_client == ILT_CLI_CDUC) {\r\np_cli = &p_hwfn->p_cxt_mngr->clients[ILT_CLI_CDUC];\r\ncxts_per_p = ILT_PAGE_IN_BYTES(p_cli->p_size.val) /\r\n(u32) CONN_CXT_SIZE(p_hwfn);\r\nlines_to_skip = cid_count / cxts_per_p;\r\n}\r\nreturn lines_to_skip;\r\n}\r\nstatic struct qed_ilt_client_cfg *qed_cxt_set_cli(struct qed_ilt_client_cfg\r\n*p_cli)\r\n{\r\np_cli->active = false;\r\np_cli->first.val = 0;\r\np_cli->last.val = 0;\r\nreturn p_cli;\r\n}\r\nstatic struct qed_ilt_cli_blk *qed_cxt_set_blk(struct qed_ilt_cli_blk *p_blk)\r\n{\r\np_blk->total_size = 0;\r\nreturn p_blk;\r\n}\r\nint qed_cxt_cfg_ilt_compute(struct qed_hwfn *p_hwfn, u32 *line_count)\r\n{\r\nstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\r\nu32 curr_line, total, i, task_size, line;\r\nstruct qed_ilt_client_cfg *p_cli;\r\nstruct qed_ilt_cli_blk *p_blk;\r\nstruct qed_cdu_iids cdu_iids;\r\nstruct qed_src_iids src_iids;\r\nstruct qed_qm_iids qm_iids;\r\nstruct qed_tm_iids tm_iids;\r\nstruct qed_tid_seg *p_seg;\r\nmemset(&qm_iids, 0, sizeof(qm_iids));\r\nmemset(&cdu_iids, 0, sizeof(cdu_iids));\r\nmemset(&src_iids, 0, sizeof(src_iids));\r\nmemset(&tm_iids, 0, sizeof(tm_iids));\r\np_mngr->pf_start_line = RESC_START(p_hwfn, QED_ILT);\r\nDP_VERBOSE(p_hwfn, QED_MSG_ILT,\r\n"hwfn [%d] - Set context manager starting line to be 0x%08x\n",\r\np_hwfn->my_id, p_hwfn->p_cxt_mngr->pf_start_line);\r\np_cli = qed_cxt_set_cli(&p_mngr->clients[ILT_CLI_CDUC]);\r\ncurr_line = p_mngr->pf_start_line;\r\np_cli->pf_total_lines = 0;\r\nqed_cxt_cdu_iids(p_mngr, &cdu_iids);\r\np_blk = qed_cxt_set_blk(&p_cli->pf_blks[CDUC_BLK]);\r\ntotal = cdu_iids.pf_cids * CONN_CXT_SIZE(p_hwfn);\r\nqed_ilt_cli_blk_fill(p_cli, p_blk, curr_line,\r\ntotal, CONN_CXT_SIZE(p_hwfn));\r\nqed_ilt_cli_adv_line(p_hwfn, p_cli, p_blk, &curr_line, ILT_CLI_CDUC);\r\np_cli->pf_total_lines = curr_line - p_blk->start_line;\r\np_blk->dynamic_line_cnt = qed_ilt_get_dynamic_line_cnt(p_hwfn,\r\nILT_CLI_CDUC);\r\np_blk = qed_cxt_set_blk(&p_cli->vf_blks[CDUC_BLK]);\r\ntotal = cdu_iids.per_vf_cids * CONN_CXT_SIZE(p_hwfn);\r\nqed_ilt_cli_blk_fill(p_cli, p_blk, curr_line,\r\ntotal, CONN_CXT_SIZE(p_hwfn));\r\nqed_ilt_cli_adv_line(p_hwfn, p_cli, p_blk, &curr_line, ILT_CLI_CDUC);\r\np_cli->vf_total_lines = curr_line - p_blk->start_line;\r\nfor (i = 1; i < p_mngr->vf_count; i++)\r\nqed_ilt_cli_adv_line(p_hwfn, p_cli, p_blk, &curr_line,\r\nILT_CLI_CDUC);\r\np_cli = qed_cxt_set_cli(&p_mngr->clients[ILT_CLI_CDUT]);\r\np_cli->first.val = curr_line;\r\nfor (i = 0; i < NUM_TASK_PF_SEGMENTS; i++) {\r\np_seg = qed_cxt_tid_seg_info(p_hwfn, i);\r\nif (!p_seg || p_seg->count == 0)\r\ncontinue;\r\np_blk = qed_cxt_set_blk(&p_cli->pf_blks[CDUT_SEG_BLK(i)]);\r\ntotal = p_seg->count * p_mngr->task_type_size[p_seg->type];\r\nqed_ilt_cli_blk_fill(p_cli, p_blk, curr_line, total,\r\np_mngr->task_type_size[p_seg->type]);\r\nqed_ilt_cli_adv_line(p_hwfn, p_cli, p_blk, &curr_line,\r\nILT_CLI_CDUT);\r\n}\r\nfor (i = 0; i < NUM_TASK_PF_SEGMENTS; i++) {\r\np_seg = qed_cxt_tid_seg_info(p_hwfn, i);\r\nif (!p_seg || p_seg->count == 0)\r\ncontinue;\r\np_blk =\r\nqed_cxt_set_blk(&p_cli->pf_blks[CDUT_FL_SEG_BLK(i, PF)]);\r\nif (!p_seg->has_fl_mem) {\r\nline = p_cli->pf_blks[CDUT_SEG_BLK(i)].start_line;\r\nqed_ilt_cli_blk_fill(p_cli, p_blk, line, 0, 0);\r\ncontinue;\r\n}\r\ntotal = p_seg->count * p_mngr->task_type_size[p_seg->type];\r\nqed_ilt_cli_blk_fill(p_cli, p_blk,\r\ncurr_line, total,\r\np_mngr->task_type_size[p_seg->type]);\r\nqed_ilt_cli_adv_line(p_hwfn, p_cli, p_blk, &curr_line,\r\nILT_CLI_CDUT);\r\n}\r\np_cli->pf_total_lines = curr_line - p_cli->pf_blks[0].start_line;\r\np_seg = qed_cxt_tid_seg_info(p_hwfn, TASK_SEGMENT_VF);\r\nif (p_seg && p_seg->count) {\r\ntotal = p_seg->count * p_mngr->task_type_size[p_seg->type];\r\np_blk = qed_cxt_set_blk(&p_cli->vf_blks[CDUT_SEG_BLK(0)]);\r\nqed_ilt_cli_blk_fill(p_cli, p_blk,\r\ncurr_line, total,\r\np_mngr->task_type_size[p_seg->type]);\r\nqed_ilt_cli_adv_line(p_hwfn, p_cli, p_blk, &curr_line,\r\nILT_CLI_CDUT);\r\np_blk =\r\nqed_cxt_set_blk(&p_cli->vf_blks[CDUT_FL_SEG_BLK(0, VF)]);\r\nif (!p_seg->has_fl_mem) {\r\nline = p_cli->vf_blks[CDUT_SEG_BLK(0)].start_line;\r\nqed_ilt_cli_blk_fill(p_cli, p_blk, line, 0, 0);\r\n} else {\r\ntask_size = p_mngr->task_type_size[p_seg->type];\r\nqed_ilt_cli_blk_fill(p_cli, p_blk,\r\ncurr_line, total, task_size);\r\nqed_ilt_cli_adv_line(p_hwfn, p_cli, p_blk, &curr_line,\r\nILT_CLI_CDUT);\r\n}\r\np_cli->vf_total_lines = curr_line -\r\np_cli->vf_blks[0].start_line;\r\nfor (i = 1; i < p_mngr->vf_count; i++) {\r\np_blk = &p_cli->vf_blks[CDUT_SEG_BLK(0)];\r\nqed_ilt_cli_adv_line(p_hwfn, p_cli, p_blk, &curr_line,\r\nILT_CLI_CDUT);\r\np_blk = &p_cli->vf_blks[CDUT_FL_SEG_BLK(0, VF)];\r\nqed_ilt_cli_adv_line(p_hwfn, p_cli, p_blk, &curr_line,\r\nILT_CLI_CDUT);\r\n}\r\n}\r\np_cli = qed_cxt_set_cli(&p_mngr->clients[ILT_CLI_QM]);\r\np_blk = qed_cxt_set_blk(&p_cli->pf_blks[0]);\r\nqed_cxt_qm_iids(p_hwfn, &qm_iids);\r\ntotal = qed_qm_pf_mem_size(p_hwfn->rel_pf_id, qm_iids.cids,\r\nqm_iids.vf_cids, qm_iids.tids,\r\np_hwfn->qm_info.num_pqs,\r\np_hwfn->qm_info.num_vf_pqs);\r\nDP_VERBOSE(p_hwfn,\r\nQED_MSG_ILT,\r\n"QM ILT Info, (cids=%d, vf_cids=%d, tids=%d, num_pqs=%d, num_vf_pqs=%d, memory_size=%d)\n",\r\nqm_iids.cids,\r\nqm_iids.vf_cids,\r\nqm_iids.tids,\r\np_hwfn->qm_info.num_pqs, p_hwfn->qm_info.num_vf_pqs, total);\r\nqed_ilt_cli_blk_fill(p_cli, p_blk,\r\ncurr_line, total * 0x1000,\r\nQM_PQ_ELEMENT_SIZE);\r\nqed_ilt_cli_adv_line(p_hwfn, p_cli, p_blk, &curr_line, ILT_CLI_QM);\r\np_cli->pf_total_lines = curr_line - p_blk->start_line;\r\np_cli = qed_cxt_set_cli(&p_mngr->clients[ILT_CLI_SRC]);\r\nqed_cxt_src_iids(p_mngr, &src_iids);\r\ntotal = src_iids.pf_cids + src_iids.per_vf_cids * p_mngr->vf_count;\r\nif (total) {\r\nu32 local_max = max_t(u32, total,\r\nSRC_MIN_NUM_ELEMS);\r\ntotal = roundup_pow_of_two(local_max);\r\np_blk = qed_cxt_set_blk(&p_cli->pf_blks[0]);\r\nqed_ilt_cli_blk_fill(p_cli, p_blk, curr_line,\r\ntotal * sizeof(struct src_ent),\r\nsizeof(struct src_ent));\r\nqed_ilt_cli_adv_line(p_hwfn, p_cli, p_blk, &curr_line,\r\nILT_CLI_SRC);\r\np_cli->pf_total_lines = curr_line - p_blk->start_line;\r\n}\r\np_cli = qed_cxt_set_cli(&p_mngr->clients[ILT_CLI_TM]);\r\nqed_cxt_tm_iids(p_hwfn, p_mngr, &tm_iids);\r\ntotal = tm_iids.pf_cids + tm_iids.pf_tids_total;\r\nif (total) {\r\np_blk = qed_cxt_set_blk(&p_cli->pf_blks[0]);\r\nqed_ilt_cli_blk_fill(p_cli, p_blk, curr_line,\r\ntotal * TM_ELEM_SIZE, TM_ELEM_SIZE);\r\nqed_ilt_cli_adv_line(p_hwfn, p_cli, p_blk, &curr_line,\r\nILT_CLI_TM);\r\np_cli->pf_total_lines = curr_line - p_blk->start_line;\r\n}\r\ntotal = tm_iids.per_vf_cids + tm_iids.per_vf_tids;\r\nif (total) {\r\np_blk = qed_cxt_set_blk(&p_cli->vf_blks[0]);\r\nqed_ilt_cli_blk_fill(p_cli, p_blk, curr_line,\r\ntotal * TM_ELEM_SIZE, TM_ELEM_SIZE);\r\nqed_ilt_cli_adv_line(p_hwfn, p_cli, p_blk, &curr_line,\r\nILT_CLI_TM);\r\np_cli->vf_total_lines = curr_line - p_blk->start_line;\r\nfor (i = 1; i < p_mngr->vf_count; i++)\r\nqed_ilt_cli_adv_line(p_hwfn, p_cli, p_blk, &curr_line,\r\nILT_CLI_TM);\r\n}\r\ntotal = qed_cxt_get_srq_count(p_hwfn);\r\nif (total) {\r\np_cli = qed_cxt_set_cli(&p_mngr->clients[ILT_CLI_TSDM]);\r\np_blk = qed_cxt_set_blk(&p_cli->pf_blks[SRQ_BLK]);\r\nqed_ilt_cli_blk_fill(p_cli, p_blk, curr_line,\r\ntotal * SRQ_CXT_SIZE, SRQ_CXT_SIZE);\r\nqed_ilt_cli_adv_line(p_hwfn, p_cli, p_blk, &curr_line,\r\nILT_CLI_TSDM);\r\np_cli->pf_total_lines = curr_line - p_blk->start_line;\r\n}\r\n*line_count = curr_line - p_hwfn->p_cxt_mngr->pf_start_line;\r\nif (curr_line - p_hwfn->p_cxt_mngr->pf_start_line >\r\nRESC_NUM(p_hwfn, QED_ILT))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nu32 qed_cxt_cfg_ilt_compute_excess(struct qed_hwfn *p_hwfn, u32 used_lines)\r\n{\r\nstruct qed_ilt_client_cfg *p_cli;\r\nu32 excess_lines, available_lines;\r\nstruct qed_cxt_mngr *p_mngr;\r\nu32 ilt_page_size, elem_size;\r\nstruct qed_tid_seg *p_seg;\r\nint i;\r\navailable_lines = RESC_NUM(p_hwfn, QED_ILT);\r\nexcess_lines = used_lines - available_lines;\r\nif (!excess_lines)\r\nreturn 0;\r\nif (!QED_IS_RDMA_PERSONALITY(p_hwfn))\r\nreturn 0;\r\np_mngr = p_hwfn->p_cxt_mngr;\r\np_cli = &p_mngr->clients[ILT_CLI_CDUT];\r\nilt_page_size = ILT_PAGE_IN_BYTES(p_cli->p_size.val);\r\nfor (i = 0; i < NUM_TASK_PF_SEGMENTS; i++) {\r\np_seg = qed_cxt_tid_seg_info(p_hwfn, i);\r\nif (!p_seg || p_seg->count == 0)\r\ncontinue;\r\nelem_size = p_mngr->task_type_size[p_seg->type];\r\nif (!elem_size)\r\ncontinue;\r\nreturn (ilt_page_size / elem_size) * excess_lines;\r\n}\r\nDP_NOTICE(p_hwfn, "failed computing excess ILT lines\n");\r\nreturn 0;\r\n}\r\nstatic void qed_cxt_src_t2_free(struct qed_hwfn *p_hwfn)\r\n{\r\nstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\r\nu32 i;\r\nif (!p_mngr->t2)\r\nreturn;\r\nfor (i = 0; i < p_mngr->t2_num_pages; i++)\r\nif (p_mngr->t2[i].p_virt)\r\ndma_free_coherent(&p_hwfn->cdev->pdev->dev,\r\np_mngr->t2[i].size,\r\np_mngr->t2[i].p_virt,\r\np_mngr->t2[i].p_phys);\r\nkfree(p_mngr->t2);\r\np_mngr->t2 = NULL;\r\n}\r\nstatic int qed_cxt_src_t2_alloc(struct qed_hwfn *p_hwfn)\r\n{\r\nstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\r\nu32 conn_num, total_size, ent_per_page, psz, i;\r\nstruct qed_ilt_client_cfg *p_src;\r\nstruct qed_src_iids src_iids;\r\nstruct qed_dma_mem *p_t2;\r\nint rc;\r\nmemset(&src_iids, 0, sizeof(src_iids));\r\np_src = &p_hwfn->p_cxt_mngr->clients[ILT_CLI_SRC];\r\nif (!p_src->active)\r\nreturn 0;\r\nqed_cxt_src_iids(p_mngr, &src_iids);\r\nconn_num = src_iids.pf_cids + src_iids.per_vf_cids * p_mngr->vf_count;\r\ntotal_size = conn_num * sizeof(struct src_ent);\r\npsz = ILT_PAGE_IN_BYTES(p_src->p_size.val);\r\np_mngr->t2_num_pages = DIV_ROUND_UP(total_size, psz);\r\np_mngr->t2 = kcalloc(p_mngr->t2_num_pages, sizeof(struct qed_dma_mem),\r\nGFP_KERNEL);\r\nif (!p_mngr->t2) {\r\nrc = -ENOMEM;\r\ngoto t2_fail;\r\n}\r\nfor (i = 0; i < p_mngr->t2_num_pages; i++) {\r\nu32 size = min_t(u32, total_size, psz);\r\nvoid **p_virt = &p_mngr->t2[i].p_virt;\r\n*p_virt = dma_alloc_coherent(&p_hwfn->cdev->pdev->dev,\r\nsize,\r\n&p_mngr->t2[i].p_phys, GFP_KERNEL);\r\nif (!p_mngr->t2[i].p_virt) {\r\nrc = -ENOMEM;\r\ngoto t2_fail;\r\n}\r\nmemset(*p_virt, 0, size);\r\np_mngr->t2[i].size = size;\r\ntotal_size -= size;\r\n}\r\nent_per_page = psz / sizeof(struct src_ent);\r\np_mngr->first_free = (u64) p_mngr->t2[0].p_phys;\r\np_t2 = &p_mngr->t2[(conn_num - 1) / ent_per_page];\r\np_mngr->last_free = (u64) p_t2->p_phys +\r\n((conn_num - 1) & (ent_per_page - 1)) * sizeof(struct src_ent);\r\nfor (i = 0; i < p_mngr->t2_num_pages; i++) {\r\nu32 ent_num = min_t(u32,\r\nent_per_page,\r\nconn_num);\r\nstruct src_ent *entries = p_mngr->t2[i].p_virt;\r\nu64 p_ent_phys = (u64) p_mngr->t2[i].p_phys, val;\r\nu32 j;\r\nfor (j = 0; j < ent_num - 1; j++) {\r\nval = p_ent_phys + (j + 1) * sizeof(struct src_ent);\r\nentries[j].next = cpu_to_be64(val);\r\n}\r\nif (i < p_mngr->t2_num_pages - 1)\r\nval = (u64) p_mngr->t2[i + 1].p_phys;\r\nelse\r\nval = 0;\r\nentries[j].next = cpu_to_be64(val);\r\nconn_num -= ent_num;\r\n}\r\nreturn 0;\r\nt2_fail:\r\nqed_cxt_src_t2_free(p_hwfn);\r\nreturn rc;\r\n}\r\nstatic u32 qed_cxt_ilt_shadow_size(struct qed_ilt_client_cfg *ilt_clients)\r\n{\r\nu32 size = 0;\r\nu32 i;\r\nfor_each_ilt_valid_client(i, ilt_clients)\r\nsize += (ilt_clients[i].last.val - ilt_clients[i].first.val + 1);\r\nreturn size;\r\n}\r\nstatic void qed_ilt_shadow_free(struct qed_hwfn *p_hwfn)\r\n{\r\nstruct qed_ilt_client_cfg *p_cli = p_hwfn->p_cxt_mngr->clients;\r\nstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\r\nu32 ilt_size, i;\r\nilt_size = qed_cxt_ilt_shadow_size(p_cli);\r\nfor (i = 0; p_mngr->ilt_shadow && i < ilt_size; i++) {\r\nstruct qed_dma_mem *p_dma = &p_mngr->ilt_shadow[i];\r\nif (p_dma->p_virt)\r\ndma_free_coherent(&p_hwfn->cdev->pdev->dev,\r\np_dma->size, p_dma->p_virt,\r\np_dma->p_phys);\r\np_dma->p_virt = NULL;\r\n}\r\nkfree(p_mngr->ilt_shadow);\r\n}\r\nstatic int qed_ilt_blk_alloc(struct qed_hwfn *p_hwfn,\r\nstruct qed_ilt_cli_blk *p_blk,\r\nenum ilt_clients ilt_client,\r\nu32 start_line_offset)\r\n{\r\nstruct qed_dma_mem *ilt_shadow = p_hwfn->p_cxt_mngr->ilt_shadow;\r\nu32 lines, line, sz_left, lines_to_skip = 0;\r\nif (QED_IS_RDMA_PERSONALITY(p_hwfn) &&\r\n((ilt_client == ILT_CLI_CDUT) || ilt_client == ILT_CLI_TSDM))\r\nreturn 0;\r\nlines_to_skip = p_blk->dynamic_line_cnt;\r\nif (!p_blk->total_size)\r\nreturn 0;\r\nsz_left = p_blk->total_size;\r\nlines = DIV_ROUND_UP(sz_left, p_blk->real_size_in_page) - lines_to_skip;\r\nline = p_blk->start_line + start_line_offset -\r\np_hwfn->p_cxt_mngr->pf_start_line + lines_to_skip;\r\nfor (; lines; lines--) {\r\ndma_addr_t p_phys;\r\nvoid *p_virt;\r\nu32 size;\r\nsize = min_t(u32, sz_left, p_blk->real_size_in_page);\r\np_virt = dma_alloc_coherent(&p_hwfn->cdev->pdev->dev,\r\nsize, &p_phys, GFP_KERNEL);\r\nif (!p_virt)\r\nreturn -ENOMEM;\r\nmemset(p_virt, 0, size);\r\nilt_shadow[line].p_phys = p_phys;\r\nilt_shadow[line].p_virt = p_virt;\r\nilt_shadow[line].size = size;\r\nDP_VERBOSE(p_hwfn, QED_MSG_ILT,\r\n"ILT shadow: Line [%d] Physical 0x%llx Virtual %p Size %d\n",\r\nline, (u64)p_phys, p_virt, size);\r\nsz_left -= size;\r\nline++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qed_ilt_shadow_alloc(struct qed_hwfn *p_hwfn)\r\n{\r\nstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\r\nstruct qed_ilt_client_cfg *clients = p_mngr->clients;\r\nstruct qed_ilt_cli_blk *p_blk;\r\nu32 size, i, j, k;\r\nint rc;\r\nsize = qed_cxt_ilt_shadow_size(clients);\r\np_mngr->ilt_shadow = kcalloc(size, sizeof(struct qed_dma_mem),\r\nGFP_KERNEL);\r\nif (!p_mngr->ilt_shadow) {\r\nrc = -ENOMEM;\r\ngoto ilt_shadow_fail;\r\n}\r\nDP_VERBOSE(p_hwfn, QED_MSG_ILT,\r\n"Allocated 0x%x bytes for ilt shadow\n",\r\n(u32)(size * sizeof(struct qed_dma_mem)));\r\nfor_each_ilt_valid_client(i, clients) {\r\nfor (j = 0; j < ILT_CLI_PF_BLOCKS; j++) {\r\np_blk = &clients[i].pf_blks[j];\r\nrc = qed_ilt_blk_alloc(p_hwfn, p_blk, i, 0);\r\nif (rc)\r\ngoto ilt_shadow_fail;\r\n}\r\nfor (k = 0; k < p_mngr->vf_count; k++) {\r\nfor (j = 0; j < ILT_CLI_VF_BLOCKS; j++) {\r\nu32 lines = clients[i].vf_total_lines * k;\r\np_blk = &clients[i].vf_blks[j];\r\nrc = qed_ilt_blk_alloc(p_hwfn, p_blk, i, lines);\r\nif (rc)\r\ngoto ilt_shadow_fail;\r\n}\r\n}\r\n}\r\nreturn 0;\r\nilt_shadow_fail:\r\nqed_ilt_shadow_free(p_hwfn);\r\nreturn rc;\r\n}\r\nstatic void qed_cid_map_free(struct qed_hwfn *p_hwfn)\r\n{\r\nstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\r\nu32 type, vf;\r\nfor (type = 0; type < MAX_CONN_TYPES; type++) {\r\nkfree(p_mngr->acquired[type].cid_map);\r\np_mngr->acquired[type].max_count = 0;\r\np_mngr->acquired[type].start_cid = 0;\r\nfor (vf = 0; vf < MAX_NUM_VFS; vf++) {\r\nkfree(p_mngr->acquired_vf[type][vf].cid_map);\r\np_mngr->acquired_vf[type][vf].max_count = 0;\r\np_mngr->acquired_vf[type][vf].start_cid = 0;\r\n}\r\n}\r\n}\r\nstatic int\r\nqed_cid_map_alloc_single(struct qed_hwfn *p_hwfn,\r\nu32 type,\r\nu32 cid_start,\r\nu32 cid_count, struct qed_cid_acquired_map *p_map)\r\n{\r\nu32 size;\r\nif (!cid_count)\r\nreturn 0;\r\nsize = DIV_ROUND_UP(cid_count,\r\nsizeof(unsigned long) * BITS_PER_BYTE) *\r\nsizeof(unsigned long);\r\np_map->cid_map = kzalloc(size, GFP_KERNEL);\r\nif (!p_map->cid_map)\r\nreturn -ENOMEM;\r\np_map->max_count = cid_count;\r\np_map->start_cid = cid_start;\r\nDP_VERBOSE(p_hwfn, QED_MSG_CXT,\r\n"Type %08x start: %08x count %08x\n",\r\ntype, p_map->start_cid, p_map->max_count);\r\nreturn 0;\r\n}\r\nstatic int qed_cid_map_alloc(struct qed_hwfn *p_hwfn)\r\n{\r\nstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\r\nu32 start_cid = 0, vf_start_cid = 0;\r\nu32 type, vf;\r\nfor (type = 0; type < MAX_CONN_TYPES; type++) {\r\nstruct qed_conn_type_cfg *p_cfg = &p_mngr->conn_cfg[type];\r\nstruct qed_cid_acquired_map *p_map;\r\np_map = &p_mngr->acquired[type];\r\nif (qed_cid_map_alloc_single(p_hwfn, type, start_cid,\r\np_cfg->cid_count, p_map))\r\ngoto cid_map_fail;\r\nfor (vf = 0; vf < MAX_NUM_VFS; vf++) {\r\np_map = &p_mngr->acquired_vf[type][vf];\r\nif (qed_cid_map_alloc_single(p_hwfn, type,\r\nvf_start_cid,\r\np_cfg->cids_per_vf, p_map))\r\ngoto cid_map_fail;\r\n}\r\nstart_cid += p_cfg->cid_count;\r\nvf_start_cid += p_cfg->cids_per_vf;\r\n}\r\nreturn 0;\r\ncid_map_fail:\r\nqed_cid_map_free(p_hwfn);\r\nreturn -ENOMEM;\r\n}\r\nint qed_cxt_mngr_alloc(struct qed_hwfn *p_hwfn)\r\n{\r\nstruct qed_ilt_client_cfg *clients;\r\nstruct qed_cxt_mngr *p_mngr;\r\nu32 i;\r\np_mngr = kzalloc(sizeof(*p_mngr), GFP_KERNEL);\r\nif (!p_mngr)\r\nreturn -ENOMEM;\r\nclients = p_mngr->clients;\r\nclients[ILT_CLI_CDUC].first.reg = ILT_CFG_REG(CDUC, FIRST_ILT);\r\nclients[ILT_CLI_CDUC].last.reg = ILT_CFG_REG(CDUC, LAST_ILT);\r\nclients[ILT_CLI_CDUC].p_size.reg = ILT_CFG_REG(CDUC, P_SIZE);\r\nclients[ILT_CLI_QM].first.reg = ILT_CFG_REG(QM, FIRST_ILT);\r\nclients[ILT_CLI_QM].last.reg = ILT_CFG_REG(QM, LAST_ILT);\r\nclients[ILT_CLI_QM].p_size.reg = ILT_CFG_REG(QM, P_SIZE);\r\nclients[ILT_CLI_TM].first.reg = ILT_CFG_REG(TM, FIRST_ILT);\r\nclients[ILT_CLI_TM].last.reg = ILT_CFG_REG(TM, LAST_ILT);\r\nclients[ILT_CLI_TM].p_size.reg = ILT_CFG_REG(TM, P_SIZE);\r\nclients[ILT_CLI_SRC].first.reg = ILT_CFG_REG(SRC, FIRST_ILT);\r\nclients[ILT_CLI_SRC].last.reg = ILT_CFG_REG(SRC, LAST_ILT);\r\nclients[ILT_CLI_SRC].p_size.reg = ILT_CFG_REG(SRC, P_SIZE);\r\nclients[ILT_CLI_CDUT].first.reg = ILT_CFG_REG(CDUT, FIRST_ILT);\r\nclients[ILT_CLI_CDUT].last.reg = ILT_CFG_REG(CDUT, LAST_ILT);\r\nclients[ILT_CLI_CDUT].p_size.reg = ILT_CFG_REG(CDUT, P_SIZE);\r\nclients[ILT_CLI_TSDM].first.reg = ILT_CFG_REG(TSDM, FIRST_ILT);\r\nclients[ILT_CLI_TSDM].last.reg = ILT_CFG_REG(TSDM, LAST_ILT);\r\nclients[ILT_CLI_TSDM].p_size.reg = ILT_CFG_REG(TSDM, P_SIZE);\r\nfor (i = 0; i < ILT_CLI_MAX; i++)\r\np_mngr->clients[i].p_size.val = ILT_DEFAULT_HW_P_SIZE;\r\np_mngr->task_type_size[0] = TYPE0_TASK_CXT_SIZE(p_hwfn);\r\np_mngr->task_type_size[1] = TYPE1_TASK_CXT_SIZE(p_hwfn);\r\nif (p_hwfn->cdev->p_iov_info)\r\np_mngr->vf_count = p_hwfn->cdev->p_iov_info->total_vfs;\r\nmutex_init(&p_mngr->mutex);\r\np_hwfn->p_cxt_mngr = p_mngr;\r\nreturn 0;\r\n}\r\nint qed_cxt_tables_alloc(struct qed_hwfn *p_hwfn)\r\n{\r\nint rc;\r\nrc = qed_ilt_shadow_alloc(p_hwfn);\r\nif (rc)\r\ngoto tables_alloc_fail;\r\nrc = qed_cxt_src_t2_alloc(p_hwfn);\r\nif (rc)\r\ngoto tables_alloc_fail;\r\nrc = qed_cid_map_alloc(p_hwfn);\r\nif (rc)\r\ngoto tables_alloc_fail;\r\nreturn 0;\r\ntables_alloc_fail:\r\nqed_cxt_mngr_free(p_hwfn);\r\nreturn rc;\r\n}\r\nvoid qed_cxt_mngr_free(struct qed_hwfn *p_hwfn)\r\n{\r\nif (!p_hwfn->p_cxt_mngr)\r\nreturn;\r\nqed_cid_map_free(p_hwfn);\r\nqed_cxt_src_t2_free(p_hwfn);\r\nqed_ilt_shadow_free(p_hwfn);\r\nkfree(p_hwfn->p_cxt_mngr);\r\np_hwfn->p_cxt_mngr = NULL;\r\n}\r\nvoid qed_cxt_mngr_setup(struct qed_hwfn *p_hwfn)\r\n{\r\nstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\r\nstruct qed_cid_acquired_map *p_map;\r\nstruct qed_conn_type_cfg *p_cfg;\r\nint type;\r\nu32 len;\r\nfor (type = 0; type < MAX_CONN_TYPES; type++) {\r\nu32 vf;\r\np_cfg = &p_mngr->conn_cfg[type];\r\nif (p_cfg->cid_count) {\r\np_map = &p_mngr->acquired[type];\r\nlen = DIV_ROUND_UP(p_map->max_count,\r\nsizeof(unsigned long) *\r\nBITS_PER_BYTE) *\r\nsizeof(unsigned long);\r\nmemset(p_map->cid_map, 0, len);\r\n}\r\nif (!p_cfg->cids_per_vf)\r\ncontinue;\r\nfor (vf = 0; vf < MAX_NUM_VFS; vf++) {\r\np_map = &p_mngr->acquired_vf[type][vf];\r\nlen = DIV_ROUND_UP(p_map->max_count,\r\nsizeof(unsigned long) *\r\nBITS_PER_BYTE) *\r\nsizeof(unsigned long);\r\nmemset(p_map->cid_map, 0, len);\r\n}\r\n}\r\n}\r\nstatic void qed_cdu_init_common(struct qed_hwfn *p_hwfn)\r\n{\r\nu32 page_sz, elems_per_page, block_waste, cxt_size, cdu_params = 0;\r\npage_sz = p_hwfn->p_cxt_mngr->clients[ILT_CLI_CDUC].p_size.val;\r\ncxt_size = CONN_CXT_SIZE(p_hwfn);\r\nelems_per_page = ILT_PAGE_IN_BYTES(page_sz) / cxt_size;\r\nblock_waste = ILT_PAGE_IN_BYTES(page_sz) - elems_per_page * cxt_size;\r\nSET_FIELD(cdu_params, CDUC_CXT_SIZE, cxt_size);\r\nSET_FIELD(cdu_params, CDUC_BLOCK_WASTE, block_waste);\r\nSET_FIELD(cdu_params, CDUC_NCIB, elems_per_page);\r\nSTORE_RT_REG(p_hwfn, CDU_REG_CID_ADDR_PARAMS_RT_OFFSET, cdu_params);\r\npage_sz = p_hwfn->p_cxt_mngr->clients[ILT_CLI_CDUT].p_size.val;\r\ncxt_size = p_hwfn->p_cxt_mngr->task_type_size[0];\r\nelems_per_page = ILT_PAGE_IN_BYTES(page_sz) / cxt_size;\r\nblock_waste = ILT_PAGE_IN_BYTES(page_sz) - elems_per_page * cxt_size;\r\ncdu_params = 0;\r\nSET_FIELD(cdu_params, CDUT_TYPE0_CXT_SIZE, (cxt_size >> 3));\r\nSET_FIELD(cdu_params, CDUT_TYPE0_BLOCK_WASTE, (block_waste >> 3));\r\nSET_FIELD(cdu_params, CDUT_TYPE0_NCIB, elems_per_page);\r\nSTORE_RT_REG(p_hwfn, CDU_REG_SEGMENT0_PARAMS_RT_OFFSET, cdu_params);\r\ncxt_size = p_hwfn->p_cxt_mngr->task_type_size[1];\r\nelems_per_page = ILT_PAGE_IN_BYTES(page_sz) / cxt_size;\r\nblock_waste = ILT_PAGE_IN_BYTES(page_sz) - elems_per_page * cxt_size;\r\ncdu_params = 0;\r\nSET_FIELD(cdu_params, CDUT_TYPE1_CXT_SIZE, (cxt_size >> 3));\r\nSET_FIELD(cdu_params, CDUT_TYPE1_BLOCK_WASTE, (block_waste >> 3));\r\nSET_FIELD(cdu_params, CDUT_TYPE1_NCIB, elems_per_page);\r\nSTORE_RT_REG(p_hwfn, CDU_REG_SEGMENT1_PARAMS_RT_OFFSET, cdu_params);\r\n}\r\nstatic void qed_cdu_init_pf(struct qed_hwfn *p_hwfn)\r\n{\r\nstruct qed_ilt_client_cfg *p_cli;\r\nstruct qed_tid_seg *p_seg;\r\nu32 cdu_seg_params, offset;\r\nint i;\r\nstatic const u32 rt_type_offset_arr[] = {\r\nCDU_REG_PF_SEG0_TYPE_OFFSET_RT_OFFSET,\r\nCDU_REG_PF_SEG1_TYPE_OFFSET_RT_OFFSET,\r\nCDU_REG_PF_SEG2_TYPE_OFFSET_RT_OFFSET,\r\nCDU_REG_PF_SEG3_TYPE_OFFSET_RT_OFFSET\r\n};\r\nstatic const u32 rt_type_offset_fl_arr[] = {\r\nCDU_REG_PF_FL_SEG0_TYPE_OFFSET_RT_OFFSET,\r\nCDU_REG_PF_FL_SEG1_TYPE_OFFSET_RT_OFFSET,\r\nCDU_REG_PF_FL_SEG2_TYPE_OFFSET_RT_OFFSET,\r\nCDU_REG_PF_FL_SEG3_TYPE_OFFSET_RT_OFFSET\r\n};\r\np_cli = &p_hwfn->p_cxt_mngr->clients[ILT_CLI_CDUT];\r\nfor (i = 0; i < NUM_TASK_PF_SEGMENTS; i++) {\r\np_seg = qed_cxt_tid_seg_info(p_hwfn, i);\r\nif (!p_seg)\r\ncontinue;\r\noffset = (ILT_PAGE_IN_BYTES(p_cli->p_size.val) *\r\n(p_cli->pf_blks[CDUT_SEG_BLK(i)].start_line -\r\np_cli->first.val)) / CDUT_SEG_ALIGNMET_IN_BYTES;\r\ncdu_seg_params = 0;\r\nSET_FIELD(cdu_seg_params, CDU_SEG_REG_TYPE, p_seg->type);\r\nSET_FIELD(cdu_seg_params, CDU_SEG_REG_OFFSET, offset);\r\nSTORE_RT_REG(p_hwfn, rt_type_offset_arr[i], cdu_seg_params);\r\noffset = (ILT_PAGE_IN_BYTES(p_cli->p_size.val) *\r\n(p_cli->pf_blks[CDUT_FL_SEG_BLK(i, PF)].start_line -\r\np_cli->first.val)) / CDUT_SEG_ALIGNMET_IN_BYTES;\r\ncdu_seg_params = 0;\r\nSET_FIELD(cdu_seg_params, CDU_SEG_REG_TYPE, p_seg->type);\r\nSET_FIELD(cdu_seg_params, CDU_SEG_REG_OFFSET, offset);\r\nSTORE_RT_REG(p_hwfn, rt_type_offset_fl_arr[i], cdu_seg_params);\r\n}\r\n}\r\nvoid qed_qm_init_pf(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt)\r\n{\r\nstruct qed_qm_pf_rt_init_params params;\r\nstruct qed_qm_info *qm_info = &p_hwfn->qm_info;\r\nstruct qed_qm_iids iids;\r\nmemset(&iids, 0, sizeof(iids));\r\nqed_cxt_qm_iids(p_hwfn, &iids);\r\nmemset(&params, 0, sizeof(params));\r\nparams.port_id = p_hwfn->port_id;\r\nparams.pf_id = p_hwfn->rel_pf_id;\r\nparams.max_phys_tcs_per_port = qm_info->max_phys_tcs_per_port;\r\nparams.is_first_pf = p_hwfn->first_on_engine;\r\nparams.num_pf_cids = iids.cids;\r\nparams.num_vf_cids = iids.vf_cids;\r\nparams.num_tids = iids.tids;\r\nparams.start_pq = qm_info->start_pq;\r\nparams.num_pf_pqs = qm_info->num_pqs - qm_info->num_vf_pqs;\r\nparams.num_vf_pqs = qm_info->num_vf_pqs;\r\nparams.start_vport = qm_info->start_vport;\r\nparams.num_vports = qm_info->num_vports;\r\nparams.pf_wfq = qm_info->pf_wfq;\r\nparams.pf_rl = qm_info->pf_rl;\r\nparams.pq_params = qm_info->qm_pq_params;\r\nparams.vport_params = qm_info->qm_vport_params;\r\nqed_qm_pf_rt_init(p_hwfn, p_ptt, &params);\r\n}\r\nvoid qed_cm_init_pf(struct qed_hwfn *p_hwfn)\r\n{\r\nSTORE_RT_REG(p_hwfn, XCM_REG_CON_PHY_Q3_RT_OFFSET,\r\nqed_get_cm_pq_idx(p_hwfn, PQ_FLAGS_LB));\r\n}\r\nstatic void qed_dq_init_pf(struct qed_hwfn *p_hwfn)\r\n{\r\nstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\r\nu32 dq_pf_max_cid = 0, dq_vf_max_cid = 0;\r\ndq_pf_max_cid += (p_mngr->conn_cfg[0].cid_count >> DQ_RANGE_SHIFT);\r\nSTORE_RT_REG(p_hwfn, DORQ_REG_PF_MAX_ICID_0_RT_OFFSET, dq_pf_max_cid);\r\ndq_vf_max_cid += (p_mngr->conn_cfg[0].cids_per_vf >> DQ_RANGE_SHIFT);\r\nSTORE_RT_REG(p_hwfn, DORQ_REG_VF_MAX_ICID_0_RT_OFFSET, dq_vf_max_cid);\r\ndq_pf_max_cid += (p_mngr->conn_cfg[1].cid_count >> DQ_RANGE_SHIFT);\r\nSTORE_RT_REG(p_hwfn, DORQ_REG_PF_MAX_ICID_1_RT_OFFSET, dq_pf_max_cid);\r\ndq_vf_max_cid += (p_mngr->conn_cfg[1].cids_per_vf >> DQ_RANGE_SHIFT);\r\nSTORE_RT_REG(p_hwfn, DORQ_REG_VF_MAX_ICID_1_RT_OFFSET, dq_vf_max_cid);\r\ndq_pf_max_cid += (p_mngr->conn_cfg[2].cid_count >> DQ_RANGE_SHIFT);\r\nSTORE_RT_REG(p_hwfn, DORQ_REG_PF_MAX_ICID_2_RT_OFFSET, dq_pf_max_cid);\r\ndq_vf_max_cid += (p_mngr->conn_cfg[2].cids_per_vf >> DQ_RANGE_SHIFT);\r\nSTORE_RT_REG(p_hwfn, DORQ_REG_VF_MAX_ICID_2_RT_OFFSET, dq_vf_max_cid);\r\ndq_pf_max_cid += (p_mngr->conn_cfg[3].cid_count >> DQ_RANGE_SHIFT);\r\nSTORE_RT_REG(p_hwfn, DORQ_REG_PF_MAX_ICID_3_RT_OFFSET, dq_pf_max_cid);\r\ndq_vf_max_cid += (p_mngr->conn_cfg[3].cids_per_vf >> DQ_RANGE_SHIFT);\r\nSTORE_RT_REG(p_hwfn, DORQ_REG_VF_MAX_ICID_3_RT_OFFSET, dq_vf_max_cid);\r\ndq_pf_max_cid += (p_mngr->conn_cfg[4].cid_count >> DQ_RANGE_SHIFT);\r\nSTORE_RT_REG(p_hwfn, DORQ_REG_PF_MAX_ICID_4_RT_OFFSET, dq_pf_max_cid);\r\ndq_vf_max_cid += (p_mngr->conn_cfg[4].cids_per_vf >> DQ_RANGE_SHIFT);\r\nSTORE_RT_REG(p_hwfn, DORQ_REG_VF_MAX_ICID_4_RT_OFFSET, dq_vf_max_cid);\r\ndq_pf_max_cid += (p_mngr->conn_cfg[5].cid_count >> DQ_RANGE_SHIFT);\r\nSTORE_RT_REG(p_hwfn, DORQ_REG_PF_MAX_ICID_5_RT_OFFSET, dq_pf_max_cid);\r\ndq_vf_max_cid += (p_mngr->conn_cfg[5].cids_per_vf >> DQ_RANGE_SHIFT);\r\nSTORE_RT_REG(p_hwfn, DORQ_REG_VF_MAX_ICID_5_RT_OFFSET, dq_vf_max_cid);\r\nSTORE_RT_REG(p_hwfn, DORQ_REG_PF_MAX_ICID_6_RT_OFFSET, dq_pf_max_cid);\r\nSTORE_RT_REG(p_hwfn, DORQ_REG_VF_MAX_ICID_6_RT_OFFSET, dq_vf_max_cid);\r\nSTORE_RT_REG(p_hwfn, DORQ_REG_PF_MAX_ICID_7_RT_OFFSET, dq_pf_max_cid);\r\nSTORE_RT_REG(p_hwfn, DORQ_REG_VF_MAX_ICID_7_RT_OFFSET, dq_vf_max_cid);\r\n}\r\nstatic void qed_ilt_bounds_init(struct qed_hwfn *p_hwfn)\r\n{\r\nstruct qed_ilt_client_cfg *ilt_clients;\r\nint i;\r\nilt_clients = p_hwfn->p_cxt_mngr->clients;\r\nfor_each_ilt_valid_client(i, ilt_clients) {\r\nSTORE_RT_REG(p_hwfn,\r\nilt_clients[i].first.reg,\r\nilt_clients[i].first.val);\r\nSTORE_RT_REG(p_hwfn,\r\nilt_clients[i].last.reg, ilt_clients[i].last.val);\r\nSTORE_RT_REG(p_hwfn,\r\nilt_clients[i].p_size.reg,\r\nilt_clients[i].p_size.val);\r\n}\r\n}\r\nstatic void qed_ilt_vf_bounds_init(struct qed_hwfn *p_hwfn)\r\n{\r\nstruct qed_ilt_client_cfg *p_cli;\r\nu32 blk_factor;\r\nif (p_hwfn->cdev->p_iov_info) {\r\nstruct qed_hw_sriov_info *p_iov = p_hwfn->cdev->p_iov_info;\r\nSTORE_RT_REG(p_hwfn,\r\nPSWRQ2_REG_VF_BASE_RT_OFFSET,\r\np_iov->first_vf_in_pf);\r\nSTORE_RT_REG(p_hwfn,\r\nPSWRQ2_REG_VF_LAST_ILT_RT_OFFSET,\r\np_iov->first_vf_in_pf + p_iov->total_vfs);\r\n}\r\np_cli = &p_hwfn->p_cxt_mngr->clients[ILT_CLI_CDUC];\r\nblk_factor = ilog2(ILT_PAGE_IN_BYTES(p_cli->p_size.val) >> 10);\r\nif (p_cli->active) {\r\nSTORE_RT_REG(p_hwfn,\r\nPSWRQ2_REG_CDUC_BLOCKS_FACTOR_RT_OFFSET,\r\nblk_factor);\r\nSTORE_RT_REG(p_hwfn,\r\nPSWRQ2_REG_CDUC_NUMBER_OF_PF_BLOCKS_RT_OFFSET,\r\np_cli->pf_total_lines);\r\nSTORE_RT_REG(p_hwfn,\r\nPSWRQ2_REG_CDUC_VF_BLOCKS_RT_OFFSET,\r\np_cli->vf_total_lines);\r\n}\r\np_cli = &p_hwfn->p_cxt_mngr->clients[ILT_CLI_CDUT];\r\nblk_factor = ilog2(ILT_PAGE_IN_BYTES(p_cli->p_size.val) >> 10);\r\nif (p_cli->active) {\r\nSTORE_RT_REG(p_hwfn,\r\nPSWRQ2_REG_CDUT_BLOCKS_FACTOR_RT_OFFSET,\r\nblk_factor);\r\nSTORE_RT_REG(p_hwfn,\r\nPSWRQ2_REG_CDUT_NUMBER_OF_PF_BLOCKS_RT_OFFSET,\r\np_cli->pf_total_lines);\r\nSTORE_RT_REG(p_hwfn,\r\nPSWRQ2_REG_CDUT_VF_BLOCKS_RT_OFFSET,\r\np_cli->vf_total_lines);\r\n}\r\np_cli = &p_hwfn->p_cxt_mngr->clients[ILT_CLI_TM];\r\nblk_factor = ilog2(ILT_PAGE_IN_BYTES(p_cli->p_size.val) >> 10);\r\nif (p_cli->active) {\r\nSTORE_RT_REG(p_hwfn,\r\nPSWRQ2_REG_TM_BLOCKS_FACTOR_RT_OFFSET, blk_factor);\r\nSTORE_RT_REG(p_hwfn,\r\nPSWRQ2_REG_TM_NUMBER_OF_PF_BLOCKS_RT_OFFSET,\r\np_cli->pf_total_lines);\r\nSTORE_RT_REG(p_hwfn,\r\nPSWRQ2_REG_TM_VF_BLOCKS_RT_OFFSET,\r\np_cli->vf_total_lines);\r\n}\r\n}\r\nstatic void qed_ilt_init_pf(struct qed_hwfn *p_hwfn)\r\n{\r\nstruct qed_ilt_client_cfg *clients;\r\nstruct qed_cxt_mngr *p_mngr;\r\nstruct qed_dma_mem *p_shdw;\r\nu32 line, rt_offst, i;\r\nqed_ilt_bounds_init(p_hwfn);\r\nqed_ilt_vf_bounds_init(p_hwfn);\r\np_mngr = p_hwfn->p_cxt_mngr;\r\np_shdw = p_mngr->ilt_shadow;\r\nclients = p_hwfn->p_cxt_mngr->clients;\r\nfor_each_ilt_valid_client(i, clients) {\r\nline = clients[i].first.val - p_mngr->pf_start_line;\r\nrt_offst = PSWRQ2_REG_ILT_MEMORY_RT_OFFSET +\r\nclients[i].first.val * ILT_ENTRY_IN_REGS;\r\nfor (; line <= clients[i].last.val - p_mngr->pf_start_line;\r\nline++, rt_offst += ILT_ENTRY_IN_REGS) {\r\nu64 ilt_hw_entry = 0;\r\nif (p_shdw[line].p_virt) {\r\nSET_FIELD(ilt_hw_entry, ILT_ENTRY_VALID, 1ULL);\r\nSET_FIELD(ilt_hw_entry, ILT_ENTRY_PHY_ADDR,\r\n(p_shdw[line].p_phys >> 12));\r\nDP_VERBOSE(p_hwfn, QED_MSG_ILT,\r\n"Setting RT[0x%08x] from ILT[0x%08x] [Client is %d] to Physical addr: 0x%llx\n",\r\nrt_offst, line, i,\r\n(u64)(p_shdw[line].p_phys >> 12));\r\n}\r\nSTORE_RT_REG_AGG(p_hwfn, rt_offst, ilt_hw_entry);\r\n}\r\n}\r\n}\r\nstatic void qed_src_init_pf(struct qed_hwfn *p_hwfn)\r\n{\r\nstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\r\nu32 rounded_conn_num, conn_num, conn_max;\r\nstruct qed_src_iids src_iids;\r\nmemset(&src_iids, 0, sizeof(src_iids));\r\nqed_cxt_src_iids(p_mngr, &src_iids);\r\nconn_num = src_iids.pf_cids + src_iids.per_vf_cids * p_mngr->vf_count;\r\nif (!conn_num)\r\nreturn;\r\nconn_max = max_t(u32, conn_num, SRC_MIN_NUM_ELEMS);\r\nrounded_conn_num = roundup_pow_of_two(conn_max);\r\nSTORE_RT_REG(p_hwfn, SRC_REG_COUNTFREE_RT_OFFSET, conn_num);\r\nSTORE_RT_REG(p_hwfn, SRC_REG_NUMBER_HASH_BITS_RT_OFFSET,\r\nilog2(rounded_conn_num));\r\nSTORE_RT_REG_AGG(p_hwfn, SRC_REG_FIRSTFREE_RT_OFFSET,\r\np_hwfn->p_cxt_mngr->first_free);\r\nSTORE_RT_REG_AGG(p_hwfn, SRC_REG_LASTFREE_RT_OFFSET,\r\np_hwfn->p_cxt_mngr->last_free);\r\n}\r\nstatic void qed_tm_init_pf(struct qed_hwfn *p_hwfn)\r\n{\r\nstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\r\nu32 active_seg_mask = 0, tm_offset, rt_reg;\r\nstruct qed_tm_iids tm_iids;\r\nu64 cfg_word;\r\nu8 i;\r\nmemset(&tm_iids, 0, sizeof(tm_iids));\r\nqed_cxt_tm_iids(p_hwfn, p_mngr, &tm_iids);\r\nfor (i = 0; i < p_mngr->vf_count; i++) {\r\ncfg_word = 0;\r\nSET_FIELD(cfg_word, TM_CFG_NUM_IDS, tm_iids.per_vf_cids);\r\nSET_FIELD(cfg_word, TM_CFG_PRE_SCAN_OFFSET, 0);\r\nSET_FIELD(cfg_word, TM_CFG_PARENT_PF, p_hwfn->rel_pf_id);\r\nSET_FIELD(cfg_word, TM_CFG_CID_PRE_SCAN_ROWS, 0);\r\nrt_reg = TM_REG_CONFIG_CONN_MEM_RT_OFFSET +\r\n(sizeof(cfg_word) / sizeof(u32)) *\r\n(p_hwfn->cdev->p_iov_info->first_vf_in_pf + i);\r\nSTORE_RT_REG_AGG(p_hwfn, rt_reg, cfg_word);\r\n}\r\ncfg_word = 0;\r\nSET_FIELD(cfg_word, TM_CFG_NUM_IDS, tm_iids.pf_cids);\r\nSET_FIELD(cfg_word, TM_CFG_PRE_SCAN_OFFSET, 0);\r\nSET_FIELD(cfg_word, TM_CFG_PARENT_PF, 0);\r\nSET_FIELD(cfg_word, TM_CFG_CID_PRE_SCAN_ROWS, 0);\r\nrt_reg = TM_REG_CONFIG_CONN_MEM_RT_OFFSET +\r\n(sizeof(cfg_word) / sizeof(u32)) *\r\n(NUM_OF_VFS(p_hwfn->cdev) + p_hwfn->rel_pf_id);\r\nSTORE_RT_REG_AGG(p_hwfn, rt_reg, cfg_word);\r\nSTORE_RT_REG(p_hwfn, TM_REG_PF_ENABLE_CONN_RT_OFFSET,\r\ntm_iids.pf_cids ? 0x1 : 0x0);\r\ntm_offset = tm_iids.per_vf_cids;\r\nfor (i = 0; i < p_mngr->vf_count; i++) {\r\ncfg_word = 0;\r\nSET_FIELD(cfg_word, TM_CFG_NUM_IDS, tm_iids.per_vf_tids);\r\nSET_FIELD(cfg_word, TM_CFG_PRE_SCAN_OFFSET, 0);\r\nSET_FIELD(cfg_word, TM_CFG_PARENT_PF, p_hwfn->rel_pf_id);\r\nSET_FIELD(cfg_word, TM_CFG_TID_OFFSET, tm_offset);\r\nSET_FIELD(cfg_word, TM_CFG_TID_PRE_SCAN_ROWS, (u64) 0);\r\nrt_reg = TM_REG_CONFIG_TASK_MEM_RT_OFFSET +\r\n(sizeof(cfg_word) / sizeof(u32)) *\r\n(p_hwfn->cdev->p_iov_info->first_vf_in_pf + i);\r\nSTORE_RT_REG_AGG(p_hwfn, rt_reg, cfg_word);\r\n}\r\ntm_offset = tm_iids.pf_cids;\r\nfor (i = 0; i < NUM_TASK_PF_SEGMENTS; i++) {\r\ncfg_word = 0;\r\nSET_FIELD(cfg_word, TM_CFG_NUM_IDS, tm_iids.pf_tids[i]);\r\nSET_FIELD(cfg_word, TM_CFG_PRE_SCAN_OFFSET, 0);\r\nSET_FIELD(cfg_word, TM_CFG_PARENT_PF, 0);\r\nSET_FIELD(cfg_word, TM_CFG_TID_OFFSET, tm_offset);\r\nSET_FIELD(cfg_word, TM_CFG_TID_PRE_SCAN_ROWS, (u64) 0);\r\nrt_reg = TM_REG_CONFIG_TASK_MEM_RT_OFFSET +\r\n(sizeof(cfg_word) / sizeof(u32)) *\r\n(NUM_OF_VFS(p_hwfn->cdev) +\r\np_hwfn->rel_pf_id * NUM_TASK_PF_SEGMENTS + i);\r\nSTORE_RT_REG_AGG(p_hwfn, rt_reg, cfg_word);\r\nactive_seg_mask |= (tm_iids.pf_tids[i] ? BIT(i) : 0);\r\ntm_offset += tm_iids.pf_tids[i];\r\n}\r\nif (QED_IS_RDMA_PERSONALITY(p_hwfn))\r\nactive_seg_mask = 0;\r\nSTORE_RT_REG(p_hwfn, TM_REG_PF_ENABLE_TASK_RT_OFFSET, active_seg_mask);\r\n}\r\nstatic void qed_prs_init_common(struct qed_hwfn *p_hwfn)\r\n{\r\nif ((p_hwfn->hw_info.personality == QED_PCI_FCOE) &&\r\np_hwfn->pf_params.fcoe_pf_params.is_target)\r\nSTORE_RT_REG(p_hwfn,\r\nPRS_REG_SEARCH_RESP_INITIATOR_TYPE_RT_OFFSET, 0);\r\n}\r\nstatic void qed_prs_init_pf(struct qed_hwfn *p_hwfn)\r\n{\r\nstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\r\nstruct qed_conn_type_cfg *p_fcoe;\r\nstruct qed_tid_seg *p_tid;\r\np_fcoe = &p_mngr->conn_cfg[PROTOCOLID_FCOE];\r\nif (!p_fcoe->cid_count)\r\nreturn;\r\np_tid = &p_fcoe->tid_seg[QED_CXT_FCOE_TID_SEG];\r\nif (p_hwfn->pf_params.fcoe_pf_params.is_target) {\r\nSTORE_RT_REG_AGG(p_hwfn,\r\nPRS_REG_TASK_ID_MAX_TARGET_PF_RT_OFFSET,\r\np_tid->count);\r\n} else {\r\nSTORE_RT_REG_AGG(p_hwfn,\r\nPRS_REG_TASK_ID_MAX_INITIATOR_PF_RT_OFFSET,\r\np_tid->count);\r\n}\r\n}\r\nvoid qed_cxt_hw_init_common(struct qed_hwfn *p_hwfn)\r\n{\r\nqed_cdu_init_common(p_hwfn);\r\nqed_prs_init_common(p_hwfn);\r\n}\r\nvoid qed_cxt_hw_init_pf(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt)\r\n{\r\nqed_qm_init_pf(p_hwfn, p_ptt);\r\nqed_cm_init_pf(p_hwfn);\r\nqed_dq_init_pf(p_hwfn);\r\nqed_cdu_init_pf(p_hwfn);\r\nqed_ilt_init_pf(p_hwfn);\r\nqed_src_init_pf(p_hwfn);\r\nqed_tm_init_pf(p_hwfn);\r\nqed_prs_init_pf(p_hwfn);\r\n}\r\nint _qed_cxt_acquire_cid(struct qed_hwfn *p_hwfn,\r\nenum protocol_type type, u32 *p_cid, u8 vfid)\r\n{\r\nstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\r\nstruct qed_cid_acquired_map *p_map;\r\nu32 rel_cid;\r\nif (type >= MAX_CONN_TYPES) {\r\nDP_NOTICE(p_hwfn, "Invalid protocol type %d", type);\r\nreturn -EINVAL;\r\n}\r\nif (vfid >= MAX_NUM_VFS && vfid != QED_CXT_PF_CID) {\r\nDP_NOTICE(p_hwfn, "VF [%02x] is out of range\n", vfid);\r\nreturn -EINVAL;\r\n}\r\nif (vfid == QED_CXT_PF_CID)\r\np_map = &p_mngr->acquired[type];\r\nelse\r\np_map = &p_mngr->acquired_vf[type][vfid];\r\nif (!p_map->cid_map) {\r\nDP_NOTICE(p_hwfn, "Invalid protocol type %d", type);\r\nreturn -EINVAL;\r\n}\r\nrel_cid = find_first_zero_bit(p_map->cid_map, p_map->max_count);\r\nif (rel_cid >= p_map->max_count) {\r\nDP_NOTICE(p_hwfn, "no CID available for protocol %d\n", type);\r\nreturn -EINVAL;\r\n}\r\n__set_bit(rel_cid, p_map->cid_map);\r\n*p_cid = rel_cid + p_map->start_cid;\r\nDP_VERBOSE(p_hwfn, QED_MSG_CXT,\r\n"Acquired cid 0x%08x [rel. %08x] vfid %02x type %d\n",\r\n*p_cid, rel_cid, vfid, type);\r\nreturn 0;\r\n}\r\nint qed_cxt_acquire_cid(struct qed_hwfn *p_hwfn,\r\nenum protocol_type type, u32 *p_cid)\r\n{\r\nreturn _qed_cxt_acquire_cid(p_hwfn, type, p_cid, QED_CXT_PF_CID);\r\n}\r\nstatic bool qed_cxt_test_cid_acquired(struct qed_hwfn *p_hwfn,\r\nu32 cid,\r\nu8 vfid,\r\nenum protocol_type *p_type,\r\nstruct qed_cid_acquired_map **pp_map)\r\n{\r\nstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\r\nu32 rel_cid;\r\nfor (*p_type = 0; *p_type < MAX_CONN_TYPES; (*p_type)++) {\r\nif (vfid == QED_CXT_PF_CID)\r\n*pp_map = &p_mngr->acquired[*p_type];\r\nelse\r\n*pp_map = &p_mngr->acquired_vf[*p_type][vfid];\r\nif (!((*pp_map)->cid_map))\r\ncontinue;\r\nif (cid >= (*pp_map)->start_cid &&\r\ncid < (*pp_map)->start_cid + (*pp_map)->max_count)\r\nbreak;\r\n}\r\nif (*p_type == MAX_CONN_TYPES) {\r\nDP_NOTICE(p_hwfn, "Invalid CID %d vfid %02x", cid, vfid);\r\ngoto fail;\r\n}\r\nrel_cid = cid - (*pp_map)->start_cid;\r\nif (!test_bit(rel_cid, (*pp_map)->cid_map)) {\r\nDP_NOTICE(p_hwfn, "CID %d [vifd %02x] not acquired",\r\ncid, vfid);\r\ngoto fail;\r\n}\r\nreturn true;\r\nfail:\r\n*p_type = MAX_CONN_TYPES;\r\n*pp_map = NULL;\r\nreturn false;\r\n}\r\nvoid _qed_cxt_release_cid(struct qed_hwfn *p_hwfn, u32 cid, u8 vfid)\r\n{\r\nstruct qed_cid_acquired_map *p_map = NULL;\r\nenum protocol_type type;\r\nbool b_acquired;\r\nu32 rel_cid;\r\nif (vfid != QED_CXT_PF_CID && vfid > MAX_NUM_VFS) {\r\nDP_NOTICE(p_hwfn,\r\n"Trying to return incorrect CID belonging to VF %02x\n",\r\nvfid);\r\nreturn;\r\n}\r\nb_acquired = qed_cxt_test_cid_acquired(p_hwfn, cid, vfid,\r\n&type, &p_map);\r\nif (!b_acquired)\r\nreturn;\r\nrel_cid = cid - p_map->start_cid;\r\nclear_bit(rel_cid, p_map->cid_map);\r\nDP_VERBOSE(p_hwfn, QED_MSG_CXT,\r\n"Released CID 0x%08x [rel. %08x] vfid %02x type %d\n",\r\ncid, rel_cid, vfid, type);\r\n}\r\nvoid qed_cxt_release_cid(struct qed_hwfn *p_hwfn, u32 cid)\r\n{\r\n_qed_cxt_release_cid(p_hwfn, cid, QED_CXT_PF_CID);\r\n}\r\nint qed_cxt_get_cid_info(struct qed_hwfn *p_hwfn, struct qed_cxt_info *p_info)\r\n{\r\nstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\r\nstruct qed_cid_acquired_map *p_map = NULL;\r\nu32 conn_cxt_size, hw_p_size, cxts_per_p, line;\r\nenum protocol_type type;\r\nbool b_acquired;\r\nb_acquired = qed_cxt_test_cid_acquired(p_hwfn, p_info->iid,\r\nQED_CXT_PF_CID, &type, &p_map);\r\nif (!b_acquired)\r\nreturn -EINVAL;\r\np_info->type = type;\r\nhw_p_size = p_hwfn->p_cxt_mngr->clients[ILT_CLI_CDUC].p_size.val;\r\nconn_cxt_size = CONN_CXT_SIZE(p_hwfn);\r\ncxts_per_p = ILT_PAGE_IN_BYTES(hw_p_size) / conn_cxt_size;\r\nline = p_info->iid / cxts_per_p;\r\nif (!p_mngr->ilt_shadow[line].p_virt)\r\nreturn -EINVAL;\r\np_info->p_cxt = p_mngr->ilt_shadow[line].p_virt +\r\np_info->iid % cxts_per_p * conn_cxt_size;\r\nDP_VERBOSE(p_hwfn, (QED_MSG_ILT | QED_MSG_CXT),\r\n"Accessing ILT shadow[%d]: CXT pointer is at %p (for iid %d)\n",\r\np_info->iid / cxts_per_p, p_info->p_cxt, p_info->iid);\r\nreturn 0;\r\n}\r\nstatic void qed_rdma_set_pf_params(struct qed_hwfn *p_hwfn,\r\nstruct qed_rdma_pf_params *p_params,\r\nu32 num_tasks)\r\n{\r\nu32 num_cons, num_qps, num_srqs;\r\nenum protocol_type proto;\r\nnum_srqs = min_t(u32, 32 * 1024, p_params->num_srqs);\r\nswitch (p_hwfn->hw_info.personality) {\r\ncase QED_PCI_ETH_IWARP:\r\nnum_cons = min_t(u32, IWARP_MAX_QPS, p_params->num_qps);\r\nproto = PROTOCOLID_IWARP;\r\nbreak;\r\ncase QED_PCI_ETH_ROCE:\r\nnum_qps = min_t(u32, ROCE_MAX_QPS, p_params->num_qps);\r\nnum_cons = num_qps * 2;\r\nproto = PROTOCOLID_ROCE;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nif (num_cons && num_tasks) {\r\nqed_cxt_set_proto_cid_count(p_hwfn, proto, num_cons, 0);\r\nqed_cxt_set_proto_tid_count(p_hwfn, PROTOCOLID_ROCE,\r\nQED_CXT_ROCE_TID_SEG, 1,\r\nnum_tasks, false);\r\nqed_cxt_set_srq_count(p_hwfn, num_srqs);\r\n} else {\r\nDP_INFO(p_hwfn->cdev,\r\n"RDMA personality used without setting params!\n");\r\n}\r\n}\r\nint qed_cxt_set_pf_params(struct qed_hwfn *p_hwfn, u32 rdma_tasks)\r\n{\r\nu32 core_cids = 1;\r\nif (p_hwfn->using_ll2)\r\ncore_cids += 4;\r\nqed_cxt_set_proto_cid_count(p_hwfn, PROTOCOLID_CORE, core_cids, 0);\r\nswitch (p_hwfn->hw_info.personality) {\r\ncase QED_PCI_ETH_RDMA:\r\ncase QED_PCI_ETH_IWARP:\r\ncase QED_PCI_ETH_ROCE:\r\n{\r\nqed_rdma_set_pf_params(p_hwfn,\r\n&p_hwfn->\r\npf_params.rdma_pf_params,\r\nrdma_tasks);\r\n}\r\ncase QED_PCI_ETH:\r\n{\r\nstruct qed_eth_pf_params *p_params =\r\n&p_hwfn->pf_params.eth_pf_params;\r\nif (!p_params->num_vf_cons)\r\np_params->num_vf_cons =\r\nETH_PF_PARAMS_VF_CONS_DEFAULT;\r\nqed_cxt_set_proto_cid_count(p_hwfn, PROTOCOLID_ETH,\r\np_params->num_cons,\r\np_params->num_vf_cons);\r\np_hwfn->p_cxt_mngr->arfs_count = p_params->num_arfs_filters;\r\nbreak;\r\n}\r\ncase QED_PCI_FCOE:\r\n{\r\nstruct qed_fcoe_pf_params *p_params;\r\np_params = &p_hwfn->pf_params.fcoe_pf_params;\r\nif (p_params->num_cons && p_params->num_tasks) {\r\nqed_cxt_set_proto_cid_count(p_hwfn,\r\nPROTOCOLID_FCOE,\r\np_params->num_cons,\r\n0);\r\nqed_cxt_set_proto_tid_count(p_hwfn, PROTOCOLID_FCOE,\r\nQED_CXT_FCOE_TID_SEG, 0,\r\np_params->num_tasks, true);\r\n} else {\r\nDP_INFO(p_hwfn->cdev,\r\n"Fcoe personality used without setting params!\n");\r\n}\r\nbreak;\r\n}\r\ncase QED_PCI_ISCSI:\r\n{\r\nstruct qed_iscsi_pf_params *p_params;\r\np_params = &p_hwfn->pf_params.iscsi_pf_params;\r\nif (p_params->num_cons && p_params->num_tasks) {\r\nqed_cxt_set_proto_cid_count(p_hwfn,\r\nPROTOCOLID_ISCSI,\r\np_params->num_cons,\r\n0);\r\nqed_cxt_set_proto_tid_count(p_hwfn,\r\nPROTOCOLID_ISCSI,\r\nQED_CXT_ISCSI_TID_SEG,\r\n0,\r\np_params->num_tasks,\r\ntrue);\r\n} else {\r\nDP_INFO(p_hwfn->cdev,\r\n"Iscsi personality used without setting params!\n");\r\n}\r\nbreak;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint qed_cxt_get_tid_mem_info(struct qed_hwfn *p_hwfn,\r\nstruct qed_tid_mem *p_info)\r\n{\r\nstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\r\nu32 proto, seg, total_lines, i, shadow_line;\r\nstruct qed_ilt_client_cfg *p_cli;\r\nstruct qed_ilt_cli_blk *p_fl_seg;\r\nstruct qed_tid_seg *p_seg_info;\r\nswitch (p_hwfn->hw_info.personality) {\r\ncase QED_PCI_FCOE:\r\nproto = PROTOCOLID_FCOE;\r\nseg = QED_CXT_FCOE_TID_SEG;\r\nbreak;\r\ncase QED_PCI_ISCSI:\r\nproto = PROTOCOLID_ISCSI;\r\nseg = QED_CXT_ISCSI_TID_SEG;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\np_cli = &p_mngr->clients[ILT_CLI_CDUT];\r\nif (!p_cli->active)\r\nreturn -EINVAL;\r\np_seg_info = &p_mngr->conn_cfg[proto].tid_seg[seg];\r\nif (!p_seg_info->has_fl_mem)\r\nreturn -EINVAL;\r\np_fl_seg = &p_cli->pf_blks[CDUT_FL_SEG_BLK(seg, PF)];\r\ntotal_lines = DIV_ROUND_UP(p_fl_seg->total_size,\r\np_fl_seg->real_size_in_page);\r\nfor (i = 0; i < total_lines; i++) {\r\nshadow_line = i + p_fl_seg->start_line -\r\np_hwfn->p_cxt_mngr->pf_start_line;\r\np_info->blocks[i] = p_mngr->ilt_shadow[shadow_line].p_virt;\r\n}\r\np_info->waste = ILT_PAGE_IN_BYTES(p_cli->p_size.val) -\r\np_fl_seg->real_size_in_page;\r\np_info->tid_size = p_mngr->task_type_size[p_seg_info->type];\r\np_info->num_tids_per_block = p_fl_seg->real_size_in_page /\r\np_info->tid_size;\r\nreturn 0;\r\n}\r\nint\r\nqed_cxt_dynamic_ilt_alloc(struct qed_hwfn *p_hwfn,\r\nenum qed_cxt_elem_type elem_type, u32 iid)\r\n{\r\nu32 reg_offset, shadow_line, elem_size, hw_p_size, elems_per_p, line;\r\nstruct qed_ilt_client_cfg *p_cli;\r\nstruct qed_ilt_cli_blk *p_blk;\r\nstruct qed_ptt *p_ptt;\r\ndma_addr_t p_phys;\r\nu64 ilt_hw_entry;\r\nvoid *p_virt;\r\nint rc = 0;\r\nswitch (elem_type) {\r\ncase QED_ELEM_CXT:\r\np_cli = &p_hwfn->p_cxt_mngr->clients[ILT_CLI_CDUC];\r\nelem_size = CONN_CXT_SIZE(p_hwfn);\r\np_blk = &p_cli->pf_blks[CDUC_BLK];\r\nbreak;\r\ncase QED_ELEM_SRQ:\r\np_cli = &p_hwfn->p_cxt_mngr->clients[ILT_CLI_TSDM];\r\nelem_size = SRQ_CXT_SIZE;\r\np_blk = &p_cli->pf_blks[SRQ_BLK];\r\nbreak;\r\ncase QED_ELEM_TASK:\r\np_cli = &p_hwfn->p_cxt_mngr->clients[ILT_CLI_CDUT];\r\nelem_size = TYPE1_TASK_CXT_SIZE(p_hwfn);\r\np_blk = &p_cli->pf_blks[CDUT_SEG_BLK(QED_CXT_ROCE_TID_SEG)];\r\nbreak;\r\ndefault:\r\nDP_NOTICE(p_hwfn, "-EINVALID elem type = %d", elem_type);\r\nreturn -EINVAL;\r\n}\r\nhw_p_size = p_cli->p_size.val;\r\nelems_per_p = ILT_PAGE_IN_BYTES(hw_p_size) / elem_size;\r\nline = p_blk->start_line + (iid / elems_per_p);\r\nshadow_line = line - p_hwfn->p_cxt_mngr->pf_start_line;\r\nmutex_lock(&p_hwfn->p_cxt_mngr->mutex);\r\nif (p_hwfn->p_cxt_mngr->ilt_shadow[shadow_line].p_virt)\r\ngoto out0;\r\np_ptt = qed_ptt_acquire(p_hwfn);\r\nif (!p_ptt) {\r\nDP_NOTICE(p_hwfn,\r\n"QED_TIME_OUT on ptt acquire - dynamic allocation");\r\nrc = -EBUSY;\r\ngoto out0;\r\n}\r\np_virt = dma_alloc_coherent(&p_hwfn->cdev->pdev->dev,\r\np_blk->real_size_in_page,\r\n&p_phys, GFP_KERNEL);\r\nif (!p_virt) {\r\nrc = -ENOMEM;\r\ngoto out1;\r\n}\r\nmemset(p_virt, 0, p_blk->real_size_in_page);\r\nif (elem_type == QED_ELEM_TASK) {\r\nu32 elem_i;\r\nu8 *elem_start = (u8 *)p_virt;\r\nunion type1_task_context *elem;\r\nfor (elem_i = 0; elem_i < elems_per_p; elem_i++) {\r\nelem = (union type1_task_context *)elem_start;\r\nSET_FIELD(elem->roce_ctx.tdif_context.flags1,\r\nTDIF_TASK_CONTEXT_REFTAGMASK, 0xf);\r\nelem_start += TYPE1_TASK_CXT_SIZE(p_hwfn);\r\n}\r\n}\r\np_hwfn->p_cxt_mngr->ilt_shadow[shadow_line].p_virt = p_virt;\r\np_hwfn->p_cxt_mngr->ilt_shadow[shadow_line].p_phys = p_phys;\r\np_hwfn->p_cxt_mngr->ilt_shadow[shadow_line].size =\r\np_blk->real_size_in_page;\r\nreg_offset = PSWRQ2_REG_ILT_MEMORY +\r\n(line * ILT_REG_SIZE_IN_BYTES * ILT_ENTRY_IN_REGS);\r\nilt_hw_entry = 0;\r\nSET_FIELD(ilt_hw_entry, ILT_ENTRY_VALID, 1ULL);\r\nSET_FIELD(ilt_hw_entry,\r\nILT_ENTRY_PHY_ADDR,\r\n(p_hwfn->p_cxt_mngr->ilt_shadow[shadow_line].p_phys >> 12));\r\nqed_dmae_host2grc(p_hwfn, p_ptt, (u64) (uintptr_t)&ilt_hw_entry,\r\nreg_offset, sizeof(ilt_hw_entry) / sizeof(u32), 0);\r\nif (elem_type == QED_ELEM_CXT) {\r\nu32 last_cid_allocated = (1 + (iid / elems_per_p)) *\r\nelems_per_p;\r\nqed_wr(p_hwfn, p_ptt, PRS_REG_ROCE_DEST_QP_MAX_PF,\r\nlast_cid_allocated - 1);\r\nif (!p_hwfn->b_rdma_enabled_in_prs) {\r\nqed_wr(p_hwfn, p_ptt, p_hwfn->rdma_prs_search_reg, 1);\r\np_hwfn->b_rdma_enabled_in_prs = true;\r\n}\r\n}\r\nout1:\r\nqed_ptt_release(p_hwfn, p_ptt);\r\nout0:\r\nmutex_unlock(&p_hwfn->p_cxt_mngr->mutex);\r\nreturn rc;\r\n}\r\nstatic int\r\nqed_cxt_free_ilt_range(struct qed_hwfn *p_hwfn,\r\nenum qed_cxt_elem_type elem_type,\r\nu32 start_iid, u32 count)\r\n{\r\nu32 start_line, end_line, shadow_start_line, shadow_end_line;\r\nu32 reg_offset, elem_size, hw_p_size, elems_per_p;\r\nstruct qed_ilt_client_cfg *p_cli;\r\nstruct qed_ilt_cli_blk *p_blk;\r\nu32 end_iid = start_iid + count;\r\nstruct qed_ptt *p_ptt;\r\nu64 ilt_hw_entry = 0;\r\nu32 i;\r\nswitch (elem_type) {\r\ncase QED_ELEM_CXT:\r\np_cli = &p_hwfn->p_cxt_mngr->clients[ILT_CLI_CDUC];\r\nelem_size = CONN_CXT_SIZE(p_hwfn);\r\np_blk = &p_cli->pf_blks[CDUC_BLK];\r\nbreak;\r\ncase QED_ELEM_SRQ:\r\np_cli = &p_hwfn->p_cxt_mngr->clients[ILT_CLI_TSDM];\r\nelem_size = SRQ_CXT_SIZE;\r\np_blk = &p_cli->pf_blks[SRQ_BLK];\r\nbreak;\r\ncase QED_ELEM_TASK:\r\np_cli = &p_hwfn->p_cxt_mngr->clients[ILT_CLI_CDUT];\r\nelem_size = TYPE1_TASK_CXT_SIZE(p_hwfn);\r\np_blk = &p_cli->pf_blks[CDUT_SEG_BLK(QED_CXT_ROCE_TID_SEG)];\r\nbreak;\r\ndefault:\r\nDP_NOTICE(p_hwfn, "-EINVALID elem type = %d", elem_type);\r\nreturn -EINVAL;\r\n}\r\nhw_p_size = p_cli->p_size.val;\r\nelems_per_p = ILT_PAGE_IN_BYTES(hw_p_size) / elem_size;\r\nstart_line = p_blk->start_line + (start_iid / elems_per_p);\r\nend_line = p_blk->start_line + (end_iid / elems_per_p);\r\nif (((end_iid + 1) / elems_per_p) != (end_iid / elems_per_p))\r\nend_line--;\r\nshadow_start_line = start_line - p_hwfn->p_cxt_mngr->pf_start_line;\r\nshadow_end_line = end_line - p_hwfn->p_cxt_mngr->pf_start_line;\r\np_ptt = qed_ptt_acquire(p_hwfn);\r\nif (!p_ptt) {\r\nDP_NOTICE(p_hwfn,\r\n"QED_TIME_OUT on ptt acquire - dynamic allocation");\r\nreturn -EBUSY;\r\n}\r\nfor (i = shadow_start_line; i < shadow_end_line; i++) {\r\nif (!p_hwfn->p_cxt_mngr->ilt_shadow[i].p_virt)\r\ncontinue;\r\ndma_free_coherent(&p_hwfn->cdev->pdev->dev,\r\np_hwfn->p_cxt_mngr->ilt_shadow[i].size,\r\np_hwfn->p_cxt_mngr->ilt_shadow[i].p_virt,\r\np_hwfn->p_cxt_mngr->ilt_shadow[i].p_phys);\r\np_hwfn->p_cxt_mngr->ilt_shadow[i].p_virt = NULL;\r\np_hwfn->p_cxt_mngr->ilt_shadow[i].p_phys = 0;\r\np_hwfn->p_cxt_mngr->ilt_shadow[i].size = 0;\r\nreg_offset = PSWRQ2_REG_ILT_MEMORY +\r\n((start_line++) * ILT_REG_SIZE_IN_BYTES *\r\nILT_ENTRY_IN_REGS);\r\nqed_dmae_host2grc(p_hwfn, p_ptt,\r\n(u64) (uintptr_t) &ilt_hw_entry,\r\nreg_offset,\r\nsizeof(ilt_hw_entry) / sizeof(u32),\r\n0);\r\n}\r\nqed_ptt_release(p_hwfn, p_ptt);\r\nreturn 0;\r\n}\r\nint qed_cxt_free_proto_ilt(struct qed_hwfn *p_hwfn, enum protocol_type proto)\r\n{\r\nint rc;\r\nu32 cid;\r\nrc = qed_cxt_free_ilt_range(p_hwfn, QED_ELEM_CXT,\r\nqed_cxt_get_proto_cid_start(p_hwfn,\r\nproto),\r\nqed_cxt_get_proto_cid_count(p_hwfn,\r\nproto, &cid));\r\nif (rc)\r\nreturn rc;\r\nrc = qed_cxt_free_ilt_range(p_hwfn, QED_ELEM_TASK, 0,\r\nqed_cxt_get_proto_tid_count(p_hwfn, proto));\r\nif (rc)\r\nreturn rc;\r\nrc = qed_cxt_free_ilt_range(p_hwfn, QED_ELEM_SRQ, 0,\r\nqed_cxt_get_srq_count(p_hwfn));\r\nreturn rc;\r\n}\r\nint qed_cxt_get_task_ctx(struct qed_hwfn *p_hwfn,\r\nu32 tid, u8 ctx_type, void **pp_task_ctx)\r\n{\r\nstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\r\nstruct qed_ilt_client_cfg *p_cli;\r\nstruct qed_tid_seg *p_seg_info;\r\nstruct qed_ilt_cli_blk *p_seg;\r\nu32 num_tids_per_block;\r\nu32 tid_size, ilt_idx;\r\nu32 total_lines;\r\nu32 proto, seg;\r\nswitch (p_hwfn->hw_info.personality) {\r\ncase QED_PCI_FCOE:\r\nproto = PROTOCOLID_FCOE;\r\nseg = QED_CXT_FCOE_TID_SEG;\r\nbreak;\r\ncase QED_PCI_ISCSI:\r\nproto = PROTOCOLID_ISCSI;\r\nseg = QED_CXT_ISCSI_TID_SEG;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\np_cli = &p_mngr->clients[ILT_CLI_CDUT];\r\nif (!p_cli->active)\r\nreturn -EINVAL;\r\np_seg_info = &p_mngr->conn_cfg[proto].tid_seg[seg];\r\nif (ctx_type == QED_CTX_WORKING_MEM) {\r\np_seg = &p_cli->pf_blks[CDUT_SEG_BLK(seg)];\r\n} else if (ctx_type == QED_CTX_FL_MEM) {\r\nif (!p_seg_info->has_fl_mem)\r\nreturn -EINVAL;\r\np_seg = &p_cli->pf_blks[CDUT_FL_SEG_BLK(seg, PF)];\r\n} else {\r\nreturn -EINVAL;\r\n}\r\ntotal_lines = DIV_ROUND_UP(p_seg->total_size, p_seg->real_size_in_page);\r\ntid_size = p_mngr->task_type_size[p_seg_info->type];\r\nnum_tids_per_block = p_seg->real_size_in_page / tid_size;\r\nif (total_lines < tid / num_tids_per_block)\r\nreturn -EINVAL;\r\nilt_idx = tid / num_tids_per_block + p_seg->start_line -\r\np_mngr->pf_start_line;\r\n*pp_task_ctx = (u8 *)p_mngr->ilt_shadow[ilt_idx].p_virt +\r\n(tid % num_tids_per_block) * tid_size;\r\nreturn 0;\r\n}
