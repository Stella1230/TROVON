static irqreturn_t oxnas_rps_timer_irq(int irq, void *dev_id)\r\n{\r\nstruct oxnas_rps_timer *rps = dev_id;\r\nwritel_relaxed(0, rps->clkevt_base + TIMER_CLRINT_REG);\r\nrps->clkevent.event_handler(&rps->clkevent);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void oxnas_rps_timer_config(struct oxnas_rps_timer *rps,\r\nunsigned long period,\r\nunsigned int periodic)\r\n{\r\nuint32_t cfg = rps->timer_prescaler;\r\nif (period)\r\ncfg |= TIMER_ENABLE;\r\nif (periodic)\r\ncfg |= TIMER_PERIODIC;\r\nwritel_relaxed(period, rps->clkevt_base + TIMER_LOAD_REG);\r\nwritel_relaxed(cfg, rps->clkevt_base + TIMER_CTRL_REG);\r\n}\r\nstatic int oxnas_rps_timer_shutdown(struct clock_event_device *evt)\r\n{\r\nstruct oxnas_rps_timer *rps =\r\ncontainer_of(evt, struct oxnas_rps_timer, clkevent);\r\noxnas_rps_timer_config(rps, 0, 0);\r\nreturn 0;\r\n}\r\nstatic int oxnas_rps_timer_set_periodic(struct clock_event_device *evt)\r\n{\r\nstruct oxnas_rps_timer *rps =\r\ncontainer_of(evt, struct oxnas_rps_timer, clkevent);\r\noxnas_rps_timer_config(rps, rps->timer_period, 1);\r\nreturn 0;\r\n}\r\nstatic int oxnas_rps_timer_set_oneshot(struct clock_event_device *evt)\r\n{\r\nstruct oxnas_rps_timer *rps =\r\ncontainer_of(evt, struct oxnas_rps_timer, clkevent);\r\noxnas_rps_timer_config(rps, rps->timer_period, 0);\r\nreturn 0;\r\n}\r\nstatic int oxnas_rps_timer_next_event(unsigned long delta,\r\nstruct clock_event_device *evt)\r\n{\r\nstruct oxnas_rps_timer *rps =\r\ncontainer_of(evt, struct oxnas_rps_timer, clkevent);\r\noxnas_rps_timer_config(rps, delta, 0);\r\nreturn 0;\r\n}\r\nstatic int __init oxnas_rps_clockevent_init(struct oxnas_rps_timer *rps)\r\n{\r\nulong clk_rate = clk_get_rate(rps->clk);\r\nulong timer_rate;\r\nrps->timer_prescaler = TIMER_DIV1;\r\nrps->timer_period = DIV_ROUND_UP(clk_rate, HZ);\r\ntimer_rate = clk_rate;\r\nif (rps->timer_period > TIMER_MAX_VAL) {\r\nrps->timer_prescaler = TIMER_DIV16;\r\ntimer_rate = clk_rate / 16;\r\nrps->timer_period = DIV_ROUND_UP(timer_rate, HZ);\r\n}\r\nif (rps->timer_period > TIMER_MAX_VAL) {\r\nrps->timer_prescaler = TIMER_DIV256;\r\ntimer_rate = clk_rate / 256;\r\nrps->timer_period = DIV_ROUND_UP(timer_rate, HZ);\r\n}\r\nrps->clkevent.name = "oxnas-rps";\r\nrps->clkevent.features = CLOCK_EVT_FEAT_PERIODIC |\r\nCLOCK_EVT_FEAT_ONESHOT |\r\nCLOCK_EVT_FEAT_DYNIRQ;\r\nrps->clkevent.tick_resume = oxnas_rps_timer_shutdown;\r\nrps->clkevent.set_state_shutdown = oxnas_rps_timer_shutdown;\r\nrps->clkevent.set_state_periodic = oxnas_rps_timer_set_periodic;\r\nrps->clkevent.set_state_oneshot = oxnas_rps_timer_set_oneshot;\r\nrps->clkevent.set_next_event = oxnas_rps_timer_next_event;\r\nrps->clkevent.rating = 200;\r\nrps->clkevent.cpumask = cpu_possible_mask;\r\nrps->clkevent.irq = rps->irq;\r\nclockevents_config_and_register(&rps->clkevent,\r\ntimer_rate,\r\n1,\r\nTIMER_MAX_VAL);\r\npr_info("Registered clock event rate %luHz prescaler %x period %lu\n",\r\nclk_rate,\r\nrps->timer_prescaler,\r\nrps->timer_period);\r\nreturn 0;\r\n}\r\nstatic u64 notrace oxnas_rps_read_sched_clock(void)\r\n{\r\nreturn ~readl_relaxed(timer_sched_base);\r\n}\r\nstatic int __init oxnas_rps_clocksource_init(struct oxnas_rps_timer *rps)\r\n{\r\nulong clk_rate = clk_get_rate(rps->clk);\r\nint ret;\r\nclk_rate = clk_rate / 16;\r\nwritel_relaxed(TIMER_MAX_VAL, rps->clksrc_base + TIMER_LOAD_REG);\r\nwritel_relaxed(TIMER_PERIODIC | TIMER_ENABLE | TIMER_DIV16,\r\nrps->clksrc_base + TIMER_CTRL_REG);\r\ntimer_sched_base = rps->clksrc_base + TIMER_CURR_REG;\r\nsched_clock_register(oxnas_rps_read_sched_clock,\r\nTIMER_BITS, clk_rate);\r\nret = clocksource_mmio_init(timer_sched_base,\r\n"oxnas_rps_clocksource_timer",\r\nclk_rate, 250, TIMER_BITS,\r\nclocksource_mmio_readl_down);\r\nif (WARN_ON(ret)) {\r\npr_err("can't register clocksource\n");\r\nreturn ret;\r\n}\r\npr_info("Registered clocksource rate %luHz\n", clk_rate);\r\nreturn 0;\r\n}\r\nstatic int __init oxnas_rps_timer_init(struct device_node *np)\r\n{\r\nstruct oxnas_rps_timer *rps;\r\nvoid __iomem *base;\r\nint ret;\r\nrps = kzalloc(sizeof(*rps), GFP_KERNEL);\r\nif (!rps)\r\nreturn -ENOMEM;\r\nrps->clk = of_clk_get(np, 0);\r\nif (IS_ERR(rps->clk)) {\r\nret = PTR_ERR(rps->clk);\r\ngoto err_alloc;\r\n}\r\nret = clk_prepare_enable(rps->clk);\r\nif (ret)\r\ngoto err_clk;\r\nbase = of_iomap(np, 0);\r\nif (!base) {\r\nret = -ENXIO;\r\ngoto err_clk_prepare;\r\n}\r\nrps->irq = irq_of_parse_and_map(np, 0);\r\nif (rps->irq < 0) {\r\nret = -EINVAL;\r\ngoto err_iomap;\r\n}\r\nrps->clkevt_base = base + TIMER1_REG_OFFSET;\r\nrps->clksrc_base = base + TIMER2_REG_OFFSET;\r\nwritel_relaxed(0, rps->clkevt_base + TIMER_CTRL_REG);\r\nwritel_relaxed(0, rps->clksrc_base + TIMER_CTRL_REG);\r\nwritel_relaxed(0, rps->clkevt_base + TIMER_LOAD_REG);\r\nwritel_relaxed(0, rps->clksrc_base + TIMER_LOAD_REG);\r\nwritel_relaxed(0, rps->clkevt_base + TIMER_CLRINT_REG);\r\nwritel_relaxed(0, rps->clksrc_base + TIMER_CLRINT_REG);\r\nret = request_irq(rps->irq, oxnas_rps_timer_irq,\r\nIRQF_TIMER | IRQF_IRQPOLL,\r\n"rps-timer", rps);\r\nif (ret)\r\ngoto err_iomap;\r\nret = oxnas_rps_clocksource_init(rps);\r\nif (ret)\r\ngoto err_irqreq;\r\nret = oxnas_rps_clockevent_init(rps);\r\nif (ret)\r\ngoto err_irqreq;\r\nreturn 0;\r\nerr_irqreq:\r\nfree_irq(rps->irq, rps);\r\nerr_iomap:\r\niounmap(base);\r\nerr_clk_prepare:\r\nclk_disable_unprepare(rps->clk);\r\nerr_clk:\r\nclk_put(rps->clk);\r\nerr_alloc:\r\nkfree(rps);\r\nreturn ret;\r\n}
