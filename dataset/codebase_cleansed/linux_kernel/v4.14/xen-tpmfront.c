static u8 vtpm_status(struct tpm_chip *chip)\r\n{\r\nstruct tpm_private *priv = dev_get_drvdata(&chip->dev);\r\nswitch (priv->shr->state) {\r\ncase VTPM_STATE_IDLE:\r\nreturn VTPM_STATUS_IDLE | VTPM_STATUS_CANCELED;\r\ncase VTPM_STATE_FINISH:\r\nreturn VTPM_STATUS_IDLE | VTPM_STATUS_RESULT;\r\ncase VTPM_STATE_SUBMIT:\r\ncase VTPM_STATE_CANCEL:\r\nreturn VTPM_STATUS_RUNNING;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic bool vtpm_req_canceled(struct tpm_chip *chip, u8 status)\r\n{\r\nreturn status & VTPM_STATUS_CANCELED;\r\n}\r\nstatic void vtpm_cancel(struct tpm_chip *chip)\r\n{\r\nstruct tpm_private *priv = dev_get_drvdata(&chip->dev);\r\npriv->shr->state = VTPM_STATE_CANCEL;\r\nwmb();\r\nnotify_remote_via_evtchn(priv->evtchn);\r\n}\r\nstatic unsigned int shr_data_offset(struct vtpm_shared_page *shr)\r\n{\r\nreturn sizeof(*shr) + sizeof(u32) * shr->nr_extra_pages;\r\n}\r\nstatic int vtpm_send(struct tpm_chip *chip, u8 *buf, size_t count)\r\n{\r\nstruct tpm_private *priv = dev_get_drvdata(&chip->dev);\r\nstruct vtpm_shared_page *shr = priv->shr;\r\nunsigned int offset = shr_data_offset(shr);\r\nu32 ordinal;\r\nunsigned long duration;\r\nif (offset > PAGE_SIZE)\r\nreturn -EINVAL;\r\nif (offset + count > PAGE_SIZE)\r\nreturn -EINVAL;\r\nif (wait_for_tpm_stat(chip, VTPM_STATUS_IDLE, chip->timeout_c,\r\n&priv->read_queue, true) < 0) {\r\nvtpm_cancel(chip);\r\nreturn -ETIME;\r\n}\r\nmemcpy(offset + (u8 *)shr, buf, count);\r\nshr->length = count;\r\nbarrier();\r\nshr->state = VTPM_STATE_SUBMIT;\r\nwmb();\r\nnotify_remote_via_evtchn(priv->evtchn);\r\nordinal = be32_to_cpu(((struct tpm_input_header*)buf)->ordinal);\r\nduration = tpm_calc_ordinal_duration(chip, ordinal);\r\nif (wait_for_tpm_stat(chip, VTPM_STATUS_IDLE, duration,\r\n&priv->read_queue, true) < 0) {\r\nvtpm_cancel(chip);\r\nreturn -ETIME;\r\n}\r\nreturn count;\r\n}\r\nstatic int vtpm_recv(struct tpm_chip *chip, u8 *buf, size_t count)\r\n{\r\nstruct tpm_private *priv = dev_get_drvdata(&chip->dev);\r\nstruct vtpm_shared_page *shr = priv->shr;\r\nunsigned int offset = shr_data_offset(shr);\r\nsize_t length = shr->length;\r\nif (shr->state == VTPM_STATE_IDLE)\r\nreturn -ECANCELED;\r\nif (wait_for_tpm_stat(chip, VTPM_STATUS_RESULT, chip->timeout_c,\r\n&priv->read_queue, true) < 0) {\r\nvtpm_cancel(chip);\r\nreturn -ETIME;\r\n}\r\nif (offset > PAGE_SIZE)\r\nreturn -EIO;\r\nif (offset + length > PAGE_SIZE)\r\nlength = PAGE_SIZE - offset;\r\nif (length > count)\r\nlength = count;\r\nmemcpy(buf, offset + (u8 *)shr, length);\r\nreturn length;\r\n}\r\nstatic irqreturn_t tpmif_interrupt(int dummy, void *dev_id)\r\n{\r\nstruct tpm_private *priv = dev_id;\r\nswitch (priv->shr->state) {\r\ncase VTPM_STATE_IDLE:\r\ncase VTPM_STATE_FINISH:\r\nwake_up_interruptible(&priv->read_queue);\r\nbreak;\r\ncase VTPM_STATE_SUBMIT:\r\ncase VTPM_STATE_CANCEL:\r\ndefault:\r\nbreak;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int setup_chip(struct device *dev, struct tpm_private *priv)\r\n{\r\nstruct tpm_chip *chip;\r\nchip = tpmm_chip_alloc(dev, &tpm_vtpm);\r\nif (IS_ERR(chip))\r\nreturn PTR_ERR(chip);\r\ninit_waitqueue_head(&priv->read_queue);\r\npriv->chip = chip;\r\ndev_set_drvdata(&chip->dev, priv);\r\nreturn 0;\r\n}\r\nstatic int setup_ring(struct xenbus_device *dev, struct tpm_private *priv)\r\n{\r\nstruct xenbus_transaction xbt;\r\nconst char *message = NULL;\r\nint rv;\r\ngrant_ref_t gref;\r\npriv->shr = (void *)__get_free_page(GFP_KERNEL|__GFP_ZERO);\r\nif (!priv->shr) {\r\nxenbus_dev_fatal(dev, -ENOMEM, "allocating shared ring");\r\nreturn -ENOMEM;\r\n}\r\nrv = xenbus_grant_ring(dev, &priv->shr, 1, &gref);\r\nif (rv < 0)\r\nreturn rv;\r\npriv->ring_ref = gref;\r\nrv = xenbus_alloc_evtchn(dev, &priv->evtchn);\r\nif (rv)\r\nreturn rv;\r\nrv = bind_evtchn_to_irqhandler(priv->evtchn, tpmif_interrupt, 0,\r\n"tpmif", priv);\r\nif (rv <= 0) {\r\nxenbus_dev_fatal(dev, rv, "allocating TPM irq");\r\nreturn rv;\r\n}\r\npriv->irq = rv;\r\nagain:\r\nrv = xenbus_transaction_start(&xbt);\r\nif (rv) {\r\nxenbus_dev_fatal(dev, rv, "starting transaction");\r\nreturn rv;\r\n}\r\nrv = xenbus_printf(xbt, dev->nodename,\r\n"ring-ref", "%u", priv->ring_ref);\r\nif (rv) {\r\nmessage = "writing ring-ref";\r\ngoto abort_transaction;\r\n}\r\nrv = xenbus_printf(xbt, dev->nodename, "event-channel", "%u",\r\npriv->evtchn);\r\nif (rv) {\r\nmessage = "writing event-channel";\r\ngoto abort_transaction;\r\n}\r\nrv = xenbus_printf(xbt, dev->nodename, "feature-protocol-v2", "1");\r\nif (rv) {\r\nmessage = "writing feature-protocol-v2";\r\ngoto abort_transaction;\r\n}\r\nrv = xenbus_transaction_end(xbt, 0);\r\nif (rv == -EAGAIN)\r\ngoto again;\r\nif (rv) {\r\nxenbus_dev_fatal(dev, rv, "completing transaction");\r\nreturn rv;\r\n}\r\nxenbus_switch_state(dev, XenbusStateInitialised);\r\nreturn 0;\r\nabort_transaction:\r\nxenbus_transaction_end(xbt, 1);\r\nif (message)\r\nxenbus_dev_error(dev, rv, "%s", message);\r\nreturn rv;\r\n}\r\nstatic void ring_free(struct tpm_private *priv)\r\n{\r\nif (!priv)\r\nreturn;\r\nif (priv->ring_ref)\r\ngnttab_end_foreign_access(priv->ring_ref, 0,\r\n(unsigned long)priv->shr);\r\nelse\r\nfree_page((unsigned long)priv->shr);\r\nif (priv->irq)\r\nunbind_from_irqhandler(priv->irq, priv);\r\nkfree(priv);\r\n}\r\nstatic int tpmfront_probe(struct xenbus_device *dev,\r\nconst struct xenbus_device_id *id)\r\n{\r\nstruct tpm_private *priv;\r\nint rv;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv) {\r\nxenbus_dev_fatal(dev, -ENOMEM, "allocating priv structure");\r\nreturn -ENOMEM;\r\n}\r\nrv = setup_chip(&dev->dev, priv);\r\nif (rv) {\r\nkfree(priv);\r\nreturn rv;\r\n}\r\nrv = setup_ring(dev, priv);\r\nif (rv) {\r\nring_free(priv);\r\nreturn rv;\r\n}\r\ntpm_get_timeouts(priv->chip);\r\nreturn tpm_chip_register(priv->chip);\r\n}\r\nstatic int tpmfront_remove(struct xenbus_device *dev)\r\n{\r\nstruct tpm_chip *chip = dev_get_drvdata(&dev->dev);\r\nstruct tpm_private *priv = dev_get_drvdata(&chip->dev);\r\ntpm_chip_unregister(chip);\r\nring_free(priv);\r\ndev_set_drvdata(&chip->dev, NULL);\r\nreturn 0;\r\n}\r\nstatic int tpmfront_resume(struct xenbus_device *dev)\r\n{\r\ntpmfront_remove(dev);\r\nreturn tpmfront_probe(dev, NULL);\r\n}\r\nstatic void backend_changed(struct xenbus_device *dev,\r\nenum xenbus_state backend_state)\r\n{\r\nswitch (backend_state) {\r\ncase XenbusStateInitialised:\r\ncase XenbusStateConnected:\r\nif (dev->state == XenbusStateConnected)\r\nbreak;\r\nif (!xenbus_read_unsigned(dev->otherend, "feature-protocol-v2",\r\n0)) {\r\nxenbus_dev_fatal(dev, -EINVAL,\r\n"vTPM protocol 2 required");\r\nreturn;\r\n}\r\nxenbus_switch_state(dev, XenbusStateConnected);\r\nbreak;\r\ncase XenbusStateClosing:\r\ncase XenbusStateClosed:\r\ndevice_unregister(&dev->dev);\r\nxenbus_frontend_closed(dev);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int __init xen_tpmfront_init(void)\r\n{\r\nif (!xen_domain())\r\nreturn -ENODEV;\r\nif (!xen_has_pv_devices())\r\nreturn -ENODEV;\r\nreturn xenbus_register_frontend(&tpmfront_driver);\r\n}\r\nstatic void __exit xen_tpmfront_exit(void)\r\n{\r\nxenbus_unregister_driver(&tpmfront_driver);\r\n}
