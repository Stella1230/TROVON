static void tgfx_timer(unsigned long private)\r\n{\r\nstruct tgfx *tgfx = (void *) private;\r\nstruct input_dev *dev;\r\nint data1, data2, i;\r\nfor (i = 0; i < 7; i++)\r\nif (tgfx->sticks & (1 << i)) {\r\ndev = tgfx->dev[i];\r\nparport_write_data(tgfx->pd->port, ~(1 << i));\r\ndata1 = parport_read_status(tgfx->pd->port) ^ 0x7f;\r\ndata2 = parport_read_control(tgfx->pd->port) ^ 0x04;\r\ninput_report_abs(dev, ABS_X, !!(data1 & TGFX_RIGHT) - !!(data1 & TGFX_LEFT));\r\ninput_report_abs(dev, ABS_Y, !!(data1 & TGFX_DOWN ) - !!(data1 & TGFX_UP ));\r\ninput_report_key(dev, BTN_TRIGGER, (data1 & TGFX_TRIGGER));\r\ninput_report_key(dev, BTN_THUMB, (data2 & TGFX_THUMB ));\r\ninput_report_key(dev, BTN_THUMB2, (data2 & TGFX_THUMB2 ));\r\ninput_report_key(dev, BTN_TOP, (data2 & TGFX_TOP ));\r\ninput_report_key(dev, BTN_TOP2, (data2 & TGFX_TOP2 ));\r\ninput_sync(dev);\r\n}\r\nmod_timer(&tgfx->timer, jiffies + TGFX_REFRESH_TIME);\r\n}\r\nstatic int tgfx_open(struct input_dev *dev)\r\n{\r\nstruct tgfx *tgfx = input_get_drvdata(dev);\r\nint err;\r\nerr = mutex_lock_interruptible(&tgfx->sem);\r\nif (err)\r\nreturn err;\r\nif (!tgfx->used++) {\r\nparport_claim(tgfx->pd);\r\nparport_write_control(tgfx->pd->port, 0x04);\r\nmod_timer(&tgfx->timer, jiffies + TGFX_REFRESH_TIME);\r\n}\r\nmutex_unlock(&tgfx->sem);\r\nreturn 0;\r\n}\r\nstatic void tgfx_close(struct input_dev *dev)\r\n{\r\nstruct tgfx *tgfx = input_get_drvdata(dev);\r\nmutex_lock(&tgfx->sem);\r\nif (!--tgfx->used) {\r\ndel_timer_sync(&tgfx->timer);\r\nparport_write_control(tgfx->pd->port, 0x00);\r\nparport_release(tgfx->pd);\r\n}\r\nmutex_unlock(&tgfx->sem);\r\n}\r\nstatic void tgfx_attach(struct parport *pp)\r\n{\r\nstruct tgfx *tgfx;\r\nstruct input_dev *input_dev;\r\nstruct pardevice *pd;\r\nint i, j, port_idx;\r\nint *n_buttons, n_devs;\r\nstruct pardev_cb tgfx_parport_cb;\r\nfor (port_idx = 0; port_idx < TGFX_MAX_PORTS; port_idx++) {\r\nif (tgfx_cfg[port_idx].nargs == 0 ||\r\ntgfx_cfg[port_idx].args[0] < 0)\r\ncontinue;\r\nif (tgfx_cfg[port_idx].args[0] == pp->number)\r\nbreak;\r\n}\r\nif (port_idx == TGFX_MAX_PORTS) {\r\npr_debug("Not using parport%d.\n", pp->number);\r\nreturn;\r\n}\r\nn_buttons = tgfx_cfg[port_idx].args + 1;\r\nn_devs = tgfx_cfg[port_idx].nargs - 1;\r\nmemset(&tgfx_parport_cb, 0, sizeof(tgfx_parport_cb));\r\ntgfx_parport_cb.flags = PARPORT_FLAG_EXCL;\r\npd = parport_register_dev_model(pp, "turbografx", &tgfx_parport_cb,\r\nport_idx);\r\nif (!pd) {\r\npr_err("parport busy already - lp.o loaded?\n");\r\nreturn;\r\n}\r\ntgfx = kzalloc(sizeof(struct tgfx), GFP_KERNEL);\r\nif (!tgfx) {\r\nprintk(KERN_ERR "turbografx.c: Not enough memory\n");\r\ngoto err_unreg_pardev;\r\n}\r\nmutex_init(&tgfx->sem);\r\ntgfx->pd = pd;\r\ntgfx->parportno = pp->number;\r\nsetup_timer(&tgfx->timer, tgfx_timer, (long)tgfx);\r\nfor (i = 0; i < n_devs; i++) {\r\nif (n_buttons[i] < 1)\r\ncontinue;\r\nif (n_buttons[i] > ARRAY_SIZE(tgfx_buttons)) {\r\nprintk(KERN_ERR "turbografx.c: Invalid number of buttons %d\n", n_buttons[i]);\r\ngoto err_unreg_devs;\r\n}\r\ntgfx->dev[i] = input_dev = input_allocate_device();\r\nif (!input_dev) {\r\nprintk(KERN_ERR "turbografx.c: Not enough memory for input device\n");\r\ngoto err_unreg_devs;\r\n}\r\ntgfx->sticks |= (1 << i);\r\nsnprintf(tgfx->name[i], sizeof(tgfx->name[i]),\r\n"TurboGraFX %d-button Multisystem joystick", n_buttons[i]);\r\nsnprintf(tgfx->phys[i], sizeof(tgfx->phys[i]),\r\n"%s/input%d", tgfx->pd->port->name, i);\r\ninput_dev->name = tgfx->name[i];\r\ninput_dev->phys = tgfx->phys[i];\r\ninput_dev->id.bustype = BUS_PARPORT;\r\ninput_dev->id.vendor = 0x0003;\r\ninput_dev->id.product = n_buttons[i];\r\ninput_dev->id.version = 0x0100;\r\ninput_set_drvdata(input_dev, tgfx);\r\ninput_dev->open = tgfx_open;\r\ninput_dev->close = tgfx_close;\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\ninput_set_abs_params(input_dev, ABS_X, -1, 1, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_Y, -1, 1, 0, 0);\r\nfor (j = 0; j < n_buttons[i]; j++)\r\nset_bit(tgfx_buttons[j], input_dev->keybit);\r\nif (input_register_device(tgfx->dev[i]))\r\ngoto err_free_dev;\r\n}\r\nif (!tgfx->sticks) {\r\nprintk(KERN_ERR "turbografx.c: No valid devices specified\n");\r\ngoto err_free_tgfx;\r\n}\r\ntgfx_base[port_idx] = tgfx;\r\nreturn;\r\nerr_free_dev:\r\ninput_free_device(tgfx->dev[i]);\r\nerr_unreg_devs:\r\nwhile (--i >= 0)\r\nif (tgfx->dev[i])\r\ninput_unregister_device(tgfx->dev[i]);\r\nerr_free_tgfx:\r\nkfree(tgfx);\r\nerr_unreg_pardev:\r\nparport_unregister_device(pd);\r\n}\r\nstatic void tgfx_detach(struct parport *port)\r\n{\r\nint i;\r\nstruct tgfx *tgfx;\r\nfor (i = 0; i < TGFX_MAX_PORTS; i++) {\r\nif (tgfx_base[i] && tgfx_base[i]->parportno == port->number)\r\nbreak;\r\n}\r\nif (i == TGFX_MAX_PORTS)\r\nreturn;\r\ntgfx = tgfx_base[i];\r\ntgfx_base[i] = NULL;\r\nfor (i = 0; i < TGFX_MAX_DEVICES; i++)\r\nif (tgfx->dev[i])\r\ninput_unregister_device(tgfx->dev[i]);\r\nparport_unregister_device(tgfx->pd);\r\nkfree(tgfx);\r\n}\r\nstatic int __init tgfx_init(void)\r\n{\r\nint i;\r\nint have_dev = 0;\r\nfor (i = 0; i < TGFX_MAX_PORTS; i++) {\r\nif (tgfx_cfg[i].nargs == 0 || tgfx_cfg[i].args[0] < 0)\r\ncontinue;\r\nif (tgfx_cfg[i].nargs < 2) {\r\nprintk(KERN_ERR "turbografx.c: at least one joystick must be specified\n");\r\nreturn -EINVAL;\r\n}\r\nhave_dev = 1;\r\n}\r\nif (!have_dev)\r\nreturn -ENODEV;\r\nreturn parport_register_driver(&tgfx_parport_driver);\r\n}\r\nstatic void __exit tgfx_exit(void)\r\n{\r\nparport_unregister_driver(&tgfx_parport_driver);\r\n}
