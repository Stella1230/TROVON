static inline u64 omap3_l3_readll(void __iomem *base, u16 reg)\r\n{\r\nreturn __raw_readll(base + reg);\r\n}\r\nstatic inline void omap3_l3_writell(void __iomem *base, u16 reg, u64 value)\r\n{\r\n__raw_writell(value, base + reg);\r\n}\r\nstatic inline enum omap3_l3_code omap3_l3_decode_error_code(u64 error)\r\n{\r\nreturn (error & 0x0f000000) >> L3_ERROR_LOG_CODE;\r\n}\r\nstatic inline u32 omap3_l3_decode_addr(u64 error_addr)\r\n{\r\nreturn error_addr & 0xffffffff;\r\n}\r\nstatic inline unsigned omap3_l3_decode_cmd(u64 error)\r\n{\r\nreturn (error & 0x07) >> L3_ERROR_LOG_CMD;\r\n}\r\nstatic inline enum omap3_l3_initiator_id omap3_l3_decode_initid(u64 error)\r\n{\r\nreturn (error & 0xff00) >> L3_ERROR_LOG_INITID;\r\n}\r\nstatic inline unsigned omap3_l3_decode_req_info(u64 error)\r\n{\r\nreturn (error >> 32) & 0xffff;\r\n}\r\nstatic char *omap3_l3_code_string(u8 code)\r\n{\r\nswitch (code) {\r\ncase OMAP_L3_CODE_NOERROR:\r\nreturn "No Error";\r\ncase OMAP_L3_CODE_UNSUP_CMD:\r\nreturn "Unsupported Command";\r\ncase OMAP_L3_CODE_ADDR_HOLE:\r\nreturn "Address Hole";\r\ncase OMAP_L3_CODE_PROTECT_VIOLATION:\r\nreturn "Protection Violation";\r\ncase OMAP_L3_CODE_IN_BAND_ERR:\r\nreturn "In-band Error";\r\ncase OMAP_L3_CODE_REQ_TOUT_NOT_ACCEPT:\r\nreturn "Request Timeout Not Accepted";\r\ncase OMAP_L3_CODE_REQ_TOUT_NO_RESP:\r\nreturn "Request Timeout, no response";\r\ndefault:\r\nreturn "UNKNOWN error";\r\n}\r\n}\r\nstatic char *omap3_l3_initiator_string(u8 initid)\r\n{\r\nswitch (initid) {\r\ncase OMAP_L3_LCD:\r\nreturn "LCD";\r\ncase OMAP_L3_SAD2D:\r\nreturn "SAD2D";\r\ncase OMAP_L3_IA_MPU_SS_1:\r\ncase OMAP_L3_IA_MPU_SS_2:\r\ncase OMAP_L3_IA_MPU_SS_3:\r\ncase OMAP_L3_IA_MPU_SS_4:\r\ncase OMAP_L3_IA_MPU_SS_5:\r\nreturn "MPU";\r\ncase OMAP_L3_IA_IVA_SS_1:\r\ncase OMAP_L3_IA_IVA_SS_2:\r\ncase OMAP_L3_IA_IVA_SS_3:\r\nreturn "IVA_SS";\r\ncase OMAP_L3_IA_IVA_SS_DMA_1:\r\ncase OMAP_L3_IA_IVA_SS_DMA_2:\r\ncase OMAP_L3_IA_IVA_SS_DMA_3:\r\ncase OMAP_L3_IA_IVA_SS_DMA_4:\r\ncase OMAP_L3_IA_IVA_SS_DMA_5:\r\ncase OMAP_L3_IA_IVA_SS_DMA_6:\r\nreturn "IVA_SS_DMA";\r\ncase OMAP_L3_IA_SGX:\r\nreturn "SGX";\r\ncase OMAP_L3_IA_CAM_1:\r\ncase OMAP_L3_IA_CAM_2:\r\ncase OMAP_L3_IA_CAM_3:\r\nreturn "CAM";\r\ncase OMAP_L3_IA_DAP:\r\nreturn "DAP";\r\ncase OMAP_L3_SDMA_WR_1:\r\ncase OMAP_L3_SDMA_WR_2:\r\nreturn "SDMA_WR";\r\ncase OMAP_L3_SDMA_RD_1:\r\ncase OMAP_L3_SDMA_RD_2:\r\ncase OMAP_L3_SDMA_RD_3:\r\ncase OMAP_L3_SDMA_RD_4:\r\nreturn "SDMA_RD";\r\ncase OMAP_L3_USBOTG:\r\nreturn "USB_OTG";\r\ncase OMAP_L3_USBHOST:\r\nreturn "USB_HOST";\r\ndefault:\r\nreturn "UNKNOWN Initiator";\r\n}\r\n}\r\nstatic irqreturn_t omap3_l3_block_irq(struct omap3_l3 *l3,\r\nu64 error, int error_addr)\r\n{\r\nu8 code = omap3_l3_decode_error_code(error);\r\nu8 initid = omap3_l3_decode_initid(error);\r\nu8 multi = error & L3_ERROR_LOG_MULTI;\r\nu32 address = omap3_l3_decode_addr(error_addr);\r\npr_err("%s seen by %s %s at address %x\n",\r\nomap3_l3_code_string(code),\r\nomap3_l3_initiator_string(initid),\r\nmulti ? "Multiple Errors" : "", address);\r\nWARN_ON(1);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t omap3_l3_app_irq(int irq, void *_l3)\r\n{\r\nstruct omap3_l3 *l3 = _l3;\r\nu64 status, clear;\r\nu64 error;\r\nu64 error_addr;\r\nu64 err_source = 0;\r\nvoid __iomem *base;\r\nint int_type;\r\nirqreturn_t ret = IRQ_NONE;\r\nint_type = irq == l3->app_irq ? L3_APPLICATION_ERROR : L3_DEBUG_ERROR;\r\nif (!int_type) {\r\nstatus = omap3_l3_readll(l3->rt, L3_SI_FLAG_STATUS_0);\r\nBUG_ON(status & L3_STATUS_0_TIMEOUT_MASK);\r\n} else {\r\nstatus = omap3_l3_readll(l3->rt, L3_SI_FLAG_STATUS_1);\r\n}\r\nerr_source = __ffs(status);\r\nbase = l3->rt + omap3_l3_bases[int_type][err_source];\r\nerror = omap3_l3_readll(base, L3_ERROR_LOG);\r\nif (error) {\r\nerror_addr = omap3_l3_readll(base, L3_ERROR_LOG_ADDR);\r\nret |= omap3_l3_block_irq(l3, error, error_addr);\r\n}\r\nclear = (L3_AGENT_STATUS_CLEAR_IA << int_type) |\r\nL3_AGENT_STATUS_CLEAR_TA;\r\nomap3_l3_writell(base, L3_AGENT_STATUS, clear);\r\nomap3_l3_writell(base, L3_ERROR_LOG, error);\r\nreturn ret;\r\n}\r\nstatic int omap3_l3_probe(struct platform_device *pdev)\r\n{\r\nstruct omap3_l3 *l3;\r\nstruct resource *res;\r\nint ret;\r\nl3 = kzalloc(sizeof(*l3), GFP_KERNEL);\r\nif (!l3)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, l3);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "couldn't find resource\n");\r\nret = -ENODEV;\r\ngoto err0;\r\n}\r\nl3->rt = ioremap(res->start, resource_size(res));\r\nif (!l3->rt) {\r\ndev_err(&pdev->dev, "ioremap failed\n");\r\nret = -ENOMEM;\r\ngoto err0;\r\n}\r\nl3->debug_irq = platform_get_irq(pdev, 0);\r\nret = request_irq(l3->debug_irq, omap3_l3_app_irq, IRQF_TRIGGER_RISING,\r\n"l3-debug-irq", l3);\r\nif (ret) {\r\ndev_err(&pdev->dev, "couldn't request debug irq\n");\r\ngoto err1;\r\n}\r\nl3->app_irq = platform_get_irq(pdev, 1);\r\nret = request_irq(l3->app_irq, omap3_l3_app_irq, IRQF_TRIGGER_RISING,\r\n"l3-app-irq", l3);\r\nif (ret) {\r\ndev_err(&pdev->dev, "couldn't request app irq\n");\r\ngoto err2;\r\n}\r\nreturn 0;\r\nerr2:\r\nfree_irq(l3->debug_irq, l3);\r\nerr1:\r\niounmap(l3->rt);\r\nerr0:\r\nkfree(l3);\r\nreturn ret;\r\n}\r\nstatic int omap3_l3_remove(struct platform_device *pdev)\r\n{\r\nstruct omap3_l3 *l3 = platform_get_drvdata(pdev);\r\nfree_irq(l3->app_irq, l3);\r\nfree_irq(l3->debug_irq, l3);\r\niounmap(l3->rt);\r\nkfree(l3);\r\nreturn 0;\r\n}\r\nstatic int __init omap3_l3_init(void)\r\n{\r\nreturn platform_driver_register(&omap3_l3_driver);\r\n}\r\nstatic void __exit omap3_l3_exit(void)\r\n{\r\nplatform_driver_unregister(&omap3_l3_driver);\r\n}
