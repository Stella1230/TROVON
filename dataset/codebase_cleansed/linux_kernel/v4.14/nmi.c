static void s390_handle_damage(void)\r\n{\r\nsmp_send_stop();\r\ndisabled_wait((unsigned long) __builtin_return_address(0));\r\nwhile (1);\r\n}\r\nvoid s390_handle_mcck(void)\r\n{\r\nunsigned long flags;\r\nstruct mcck_struct mcck;\r\nlocal_irq_save(flags);\r\nlocal_mcck_disable();\r\nmcck = *this_cpu_ptr(&cpu_mcck);\r\nmemset(this_cpu_ptr(&cpu_mcck), 0, sizeof(mcck));\r\nclear_cpu_flag(CIF_MCCK_PENDING);\r\nlocal_mcck_enable();\r\nlocal_irq_restore(flags);\r\nif (mcck.channel_report)\r\ncrw_handle_channel_report();\r\nif (mcck.warning) {\r\nstatic int mchchk_wng_posted = 0;\r\n__ctl_clear_bit(14, 24);\r\nif (xchg(&mchchk_wng_posted, 1) == 0)\r\nkill_cad_pid(SIGPWR, 1);\r\n}\r\nif (mcck.stp_queue)\r\nstp_queue_work();\r\nif (mcck.kill_task) {\r\nlocal_irq_enable();\r\nprintk(KERN_EMERG "mcck: Terminating task because of machine "\r\n"malfunction (code 0x%016lx).\n", mcck.mcck_code);\r\nprintk(KERN_EMERG "mcck: task: %s, pid: %d.\n",\r\ncurrent->comm, current->pid);\r\ndo_exit(SIGSEGV);\r\n}\r\n}\r\nstatic int notrace s390_validate_registers(union mci mci, int umode)\r\n{\r\nint kill_task;\r\nu64 zero;\r\nvoid *fpt_save_area;\r\nstruct mcesa *mcesa;\r\nkill_task = 0;\r\nzero = 0;\r\nif (!mci.gr) {\r\nif (!umode)\r\ns390_handle_damage();\r\nkill_task = 1;\r\n}\r\nif (!mci.cr) {\r\ns390_handle_damage();\r\n} else {\r\nasm volatile(\r\n" lctlg 0,15,0(%0)\n"\r\n" ptlb\n"\r\n: : "a" (&S390_lowcore.cregs_save_area) : "memory");\r\n}\r\nif (!mci.fp) {\r\nif (S390_lowcore.fpu_flags & KERNEL_VXR_V0V7)\r\ns390_handle_damage();\r\nif (!test_cpu_flag(CIF_FPU))\r\nkill_task = 1;\r\n}\r\nfpt_save_area = &S390_lowcore.floating_pt_save_area;\r\nif (!mci.fc) {\r\nif (S390_lowcore.fpu_flags & KERNEL_FPC)\r\ns390_handle_damage();\r\nasm volatile("lfpc %0" : : "Q" (zero));\r\nif (!test_cpu_flag(CIF_FPU))\r\nkill_task = 1;\r\n} else {\r\nasm volatile("lfpc %0"\r\n: : "Q" (S390_lowcore.fpt_creg_save_area));\r\n}\r\nmcesa = (struct mcesa *)(S390_lowcore.mcesad & MCESA_ORIGIN_MASK);\r\nif (!MACHINE_HAS_VX) {\r\nasm volatile(\r\n" ld 0,0(%0)\n"\r\n" ld 1,8(%0)\n"\r\n" ld 2,16(%0)\n"\r\n" ld 3,24(%0)\n"\r\n" ld 4,32(%0)\n"\r\n" ld 5,40(%0)\n"\r\n" ld 6,48(%0)\n"\r\n" ld 7,56(%0)\n"\r\n" ld 8,64(%0)\n"\r\n" ld 9,72(%0)\n"\r\n" ld 10,80(%0)\n"\r\n" ld 11,88(%0)\n"\r\n" ld 12,96(%0)\n"\r\n" ld 13,104(%0)\n"\r\n" ld 14,112(%0)\n"\r\n" ld 15,120(%0)\n"\r\n: : "a" (fpt_save_area) : "memory");\r\n} else {\r\nunion ctlreg0 cr0;\r\nif (!mci.vr) {\r\nif (S390_lowcore.fpu_flags & KERNEL_VXR)\r\ns390_handle_damage();\r\nif (!test_cpu_flag(CIF_FPU))\r\nkill_task = 1;\r\n}\r\ncr0.val = S390_lowcore.cregs_save_area[0];\r\ncr0.afp = cr0.vx = 1;\r\n__ctl_load(cr0.val, 0, 0);\r\nasm volatile(\r\n" la 1,%0\n"\r\n" .word 0xe70f,0x1000,0x0036\n"\r\n" .word 0xe70f,0x1100,0x0c36\n"\r\n: : "Q" (*(struct vx_array *) mcesa->vector_save_area)\r\n: "1");\r\n__ctl_load(S390_lowcore.cregs_save_area[0], 0, 0);\r\n}\r\nasm volatile(\r\n" lam 0,15,0(%0)"\r\n: : "a" (&S390_lowcore.access_regs_save_area));\r\nif (!mci.ar) {\r\nkill_task = 1;\r\n}\r\nif (MACHINE_HAS_GS && (S390_lowcore.cregs_save_area[2] & (1UL << 4))) {\r\nif (!mci.gs)\r\nkill_task = 1;\r\nelse\r\nload_gs_cb((struct gs_cb *)\r\nmcesa->guarded_storage_save_area);\r\n}\r\nif (!mci.pr)\r\nasm volatile(\r\n" sr 0,0\n"\r\n" sckpf"\r\n: : : "0", "cc");\r\nelse\r\nasm volatile(\r\n" l 0,%0\n"\r\n" sckpf"\r\n: : "Q" (S390_lowcore.tod_progreg_save_area)\r\n: "0", "cc");\r\nset_clock_comparator(S390_lowcore.clock_comparator);\r\nif (!mci.wp)\r\ns390_handle_damage();\r\nif (!mci.ms || !mci.pm || !mci.ia)\r\nkill_task = 1;\r\nreturn kill_task;\r\n}\r\nstatic void notrace s390_backup_mcck_info(struct pt_regs *regs)\r\n{\r\nstruct mcck_volatile_info *mcck_backup;\r\nstruct sie_page *sie_page;\r\nstruct kvm_s390_sie_block *sie_block =\r\n(struct kvm_s390_sie_block *) regs->gprs[14];\r\nif (sie_block == NULL)\r\ns390_handle_damage();\r\nsie_page = container_of(sie_block, struct sie_page, sie_block);\r\nmcck_backup = &sie_page->mcck_info;\r\nmcck_backup->mcic = S390_lowcore.mcck_interruption_code &\r\n~(MCCK_CODE_CP | MCCK_CODE_EXT_DAMAGE);\r\nmcck_backup->ext_damage_code = S390_lowcore.external_damage_code;\r\nmcck_backup->failing_storage_address\r\n= S390_lowcore.failing_storage_address;\r\n}\r\nvoid notrace s390_do_machine_check(struct pt_regs *regs)\r\n{\r\nstatic int ipd_count;\r\nstatic DEFINE_SPINLOCK(ipd_lock);\r\nstatic unsigned long long last_ipd;\r\nstruct mcck_struct *mcck;\r\nunsigned long long tmp;\r\nunion mci mci;\r\nunsigned long mcck_dam_code;\r\nnmi_enter();\r\ninc_irq_stat(NMI_NMI);\r\nmci.val = S390_lowcore.mcck_interruption_code;\r\nmcck = this_cpu_ptr(&cpu_mcck);\r\nif (mci.sd) {\r\ns390_handle_damage();\r\n}\r\nif (mci.pd && !test_cpu_flag(CIF_MCCK_GUEST)) {\r\nif (mci.b) {\r\nu64 z_mcic, o_mcic, t_mcic;\r\nz_mcic = (1ULL<<63 | 1ULL<<59 | 1ULL<<29);\r\no_mcic = (1ULL<<43 | 1ULL<<42 | 1ULL<<41 | 1ULL<<40 |\r\n1ULL<<36 | 1ULL<<35 | 1ULL<<34 | 1ULL<<32 |\r\n1ULL<<30 | 1ULL<<21 | 1ULL<<20 | 1ULL<<17 |\r\n1ULL<<16);\r\nt_mcic = mci.val;\r\nif (((t_mcic & z_mcic) != 0) ||\r\n((t_mcic & o_mcic) != o_mcic)) {\r\ns390_handle_damage();\r\n}\r\nspin_lock(&ipd_lock);\r\ntmp = get_tod_clock();\r\nif (((tmp - last_ipd) >> 12) < MAX_IPD_TIME)\r\nipd_count++;\r\nelse\r\nipd_count = 1;\r\nlast_ipd = tmp;\r\nif (ipd_count == MAX_IPD_COUNT)\r\ns390_handle_damage();\r\nspin_unlock(&ipd_lock);\r\n} else {\r\ns390_handle_damage();\r\n}\r\n}\r\nif (s390_validate_registers(mci, user_mode(regs))) {\r\nmcck->kill_task = 1;\r\nmcck->mcck_code = mci.val;\r\nset_cpu_flag(CIF_MCCK_PENDING);\r\n}\r\nif (test_cpu_flag(CIF_MCCK_GUEST))\r\ns390_backup_mcck_info(regs);\r\nif (mci.cd) {\r\ns390_handle_damage();\r\n}\r\nif (mci.ed && mci.ec) {\r\nif (S390_lowcore.external_damage_code & (1U << ED_STP_SYNC))\r\nmcck->stp_queue |= stp_sync_check();\r\nif (S390_lowcore.external_damage_code & (1U << ED_STP_ISLAND))\r\nmcck->stp_queue |= stp_island_check();\r\nif (mcck->stp_queue)\r\nset_cpu_flag(CIF_MCCK_PENDING);\r\n}\r\nif (!test_cpu_flag(CIF_MCCK_GUEST)) {\r\nif (mci.se)\r\ns390_handle_damage();\r\nif (mci.ke)\r\ns390_handle_damage();\r\nif (mci.ds && mci.fa)\r\ns390_handle_damage();\r\n}\r\nif (mci.cp) {\r\nmcck->channel_report = 1;\r\nset_cpu_flag(CIF_MCCK_PENDING);\r\n}\r\nif (mci.w) {\r\nmcck->warning = 1;\r\nset_cpu_flag(CIF_MCCK_PENDING);\r\n}\r\nmcck_dam_code = (mci.val & MCIC_SUBCLASS_MASK);\r\nif (test_cpu_flag(CIF_MCCK_GUEST) &&\r\n(mcck_dam_code & MCCK_CODE_NO_GUEST) != mcck_dam_code) {\r\n*((long *)(regs->gprs[15] + __SF_SIE_REASON)) = -EINTR;\r\n}\r\nclear_cpu_flag(CIF_MCCK_GUEST);\r\nnmi_exit();\r\n}\r\nstatic int __init machine_check_init(void)\r\n{\r\nctl_set_bit(14, 25);\r\nctl_set_bit(14, 27);\r\nctl_set_bit(14, 24);\r\nreturn 0;\r\n}
