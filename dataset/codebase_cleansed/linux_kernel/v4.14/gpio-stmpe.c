static int stmpe_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct stmpe_gpio *stmpe_gpio = gpiochip_get_data(chip);\r\nstruct stmpe *stmpe = stmpe_gpio->stmpe;\r\nu8 reg = stmpe->regs[STMPE_IDX_GPMR_LSB + (offset / 8)];\r\nu8 mask = BIT(offset % 8);\r\nint ret;\r\nret = stmpe_reg_read(stmpe, reg);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn !!(ret & mask);\r\n}\r\nstatic void stmpe_gpio_set(struct gpio_chip *chip, unsigned offset, int val)\r\n{\r\nstruct stmpe_gpio *stmpe_gpio = gpiochip_get_data(chip);\r\nstruct stmpe *stmpe = stmpe_gpio->stmpe;\r\nint which = val ? STMPE_IDX_GPSR_LSB : STMPE_IDX_GPCR_LSB;\r\nu8 reg = stmpe->regs[which + (offset / 8)];\r\nu8 mask = BIT(offset % 8);\r\nif (stmpe->regs[STMPE_IDX_GPSR_LSB] == stmpe->regs[STMPE_IDX_GPCR_LSB])\r\nstmpe_set_bits(stmpe, reg, mask, val ? mask : 0);\r\nelse\r\nstmpe_reg_write(stmpe, reg, mask);\r\n}\r\nstatic int stmpe_gpio_get_direction(struct gpio_chip *chip,\r\nunsigned offset)\r\n{\r\nstruct stmpe_gpio *stmpe_gpio = gpiochip_get_data(chip);\r\nstruct stmpe *stmpe = stmpe_gpio->stmpe;\r\nu8 reg = stmpe->regs[STMPE_IDX_GPDR_LSB] - (offset / 8);\r\nu8 mask = BIT(offset % 8);\r\nint ret;\r\nret = stmpe_reg_read(stmpe, reg);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn !(ret & mask);\r\n}\r\nstatic int stmpe_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned offset, int val)\r\n{\r\nstruct stmpe_gpio *stmpe_gpio = gpiochip_get_data(chip);\r\nstruct stmpe *stmpe = stmpe_gpio->stmpe;\r\nu8 reg = stmpe->regs[STMPE_IDX_GPDR_LSB + (offset / 8)];\r\nu8 mask = BIT(offset % 8);\r\nstmpe_gpio_set(chip, offset, val);\r\nreturn stmpe_set_bits(stmpe, reg, mask, mask);\r\n}\r\nstatic int stmpe_gpio_direction_input(struct gpio_chip *chip,\r\nunsigned offset)\r\n{\r\nstruct stmpe_gpio *stmpe_gpio = gpiochip_get_data(chip);\r\nstruct stmpe *stmpe = stmpe_gpio->stmpe;\r\nu8 reg = stmpe->regs[STMPE_IDX_GPDR_LSB + (offset / 8)];\r\nu8 mask = BIT(offset % 8);\r\nreturn stmpe_set_bits(stmpe, reg, mask, 0);\r\n}\r\nstatic int stmpe_gpio_request(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct stmpe_gpio *stmpe_gpio = gpiochip_get_data(chip);\r\nstruct stmpe *stmpe = stmpe_gpio->stmpe;\r\nif (stmpe_gpio->norequest_mask & BIT(offset))\r\nreturn -EINVAL;\r\nreturn stmpe_set_altfunc(stmpe, BIT(offset), STMPE_BLOCK_GPIO);\r\n}\r\nstatic int stmpe_gpio_irq_set_type(struct irq_data *d, unsigned int type)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct stmpe_gpio *stmpe_gpio = gpiochip_get_data(gc);\r\nint offset = d->hwirq;\r\nint regoffset = offset / 8;\r\nint mask = BIT(offset % 8);\r\nif (type & IRQ_TYPE_LEVEL_LOW || type & IRQ_TYPE_LEVEL_HIGH)\r\nreturn -EINVAL;\r\nif (stmpe_gpio->stmpe->partnum == STMPE801 ||\r\nstmpe_gpio->stmpe->partnum == STMPE1600)\r\nreturn 0;\r\nif (type & IRQ_TYPE_EDGE_RISING)\r\nstmpe_gpio->regs[REG_RE][regoffset] |= mask;\r\nelse\r\nstmpe_gpio->regs[REG_RE][regoffset] &= ~mask;\r\nif (type & IRQ_TYPE_EDGE_FALLING)\r\nstmpe_gpio->regs[REG_FE][regoffset] |= mask;\r\nelse\r\nstmpe_gpio->regs[REG_FE][regoffset] &= ~mask;\r\nreturn 0;\r\n}\r\nstatic void stmpe_gpio_irq_lock(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct stmpe_gpio *stmpe_gpio = gpiochip_get_data(gc);\r\nmutex_lock(&stmpe_gpio->irq_lock);\r\n}\r\nstatic void stmpe_gpio_irq_sync_unlock(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct stmpe_gpio *stmpe_gpio = gpiochip_get_data(gc);\r\nstruct stmpe *stmpe = stmpe_gpio->stmpe;\r\nint num_banks = DIV_ROUND_UP(stmpe->num_gpios, 8);\r\nstatic const u8 regmap[CACHE_NR_REGS][CACHE_NR_BANKS] = {\r\n[REG_RE][LSB] = STMPE_IDX_GPRER_LSB,\r\n[REG_RE][CSB] = STMPE_IDX_GPRER_CSB,\r\n[REG_RE][MSB] = STMPE_IDX_GPRER_MSB,\r\n[REG_FE][LSB] = STMPE_IDX_GPFER_LSB,\r\n[REG_FE][CSB] = STMPE_IDX_GPFER_CSB,\r\n[REG_FE][MSB] = STMPE_IDX_GPFER_MSB,\r\n[REG_IE][LSB] = STMPE_IDX_IEGPIOR_LSB,\r\n[REG_IE][CSB] = STMPE_IDX_IEGPIOR_CSB,\r\n[REG_IE][MSB] = STMPE_IDX_IEGPIOR_MSB,\r\n};\r\nint i, j;\r\nfor (i = 0; i < CACHE_NR_REGS; i++) {\r\nif ((stmpe->partnum == STMPE801 ||\r\nstmpe->partnum == STMPE1600) &&\r\n(i != REG_IE))\r\ncontinue;\r\nfor (j = 0; j < num_banks; j++) {\r\nu8 old = stmpe_gpio->oldregs[i][j];\r\nu8 new = stmpe_gpio->regs[i][j];\r\nif (new == old)\r\ncontinue;\r\nstmpe_gpio->oldregs[i][j] = new;\r\nstmpe_reg_write(stmpe, stmpe->regs[regmap[i][j]], new);\r\n}\r\n}\r\nmutex_unlock(&stmpe_gpio->irq_lock);\r\n}\r\nstatic void stmpe_gpio_irq_mask(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct stmpe_gpio *stmpe_gpio = gpiochip_get_data(gc);\r\nint offset = d->hwirq;\r\nint regoffset = offset / 8;\r\nint mask = BIT(offset % 8);\r\nstmpe_gpio->regs[REG_IE][regoffset] &= ~mask;\r\n}\r\nstatic void stmpe_gpio_irq_unmask(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct stmpe_gpio *stmpe_gpio = gpiochip_get_data(gc);\r\nstruct stmpe *stmpe = stmpe_gpio->stmpe;\r\nint offset = d->hwirq;\r\nint regoffset = offset / 8;\r\nint mask = BIT(offset % 8);\r\nstmpe_gpio->regs[REG_IE][regoffset] |= mask;\r\nif (stmpe->partnum == STMPE1600)\r\nstmpe_reg_read(stmpe,\r\nstmpe->regs[STMPE_IDX_GPMR_LSB + regoffset]);\r\n}\r\nstatic void stmpe_dbg_show_one(struct seq_file *s,\r\nstruct gpio_chip *gc,\r\nunsigned offset, unsigned gpio)\r\n{\r\nstruct stmpe_gpio *stmpe_gpio = gpiochip_get_data(gc);\r\nstruct stmpe *stmpe = stmpe_gpio->stmpe;\r\nconst char *label = gpiochip_is_requested(gc, offset);\r\nbool val = !!stmpe_gpio_get(gc, offset);\r\nu8 bank = offset / 8;\r\nu8 dir_reg = stmpe->regs[STMPE_IDX_GPDR_LSB + bank];\r\nu8 mask = BIT(offset % 8);\r\nint ret;\r\nu8 dir;\r\nret = stmpe_reg_read(stmpe, dir_reg);\r\nif (ret < 0)\r\nreturn;\r\ndir = !!(ret & mask);\r\nif (dir) {\r\nseq_printf(s, " gpio-%-3d (%-20.20s) out %s",\r\ngpio, label ?: "(none)",\r\nval ? "hi" : "lo");\r\n} else {\r\nu8 edge_det_reg;\r\nu8 rise_reg;\r\nu8 fall_reg;\r\nu8 irqen_reg;\r\nchar *edge_det_values[] = {"edge-inactive",\r\n"edge-asserted",\r\n"not-supported"};\r\nchar *rise_values[] = {"no-rising-edge-detection",\r\n"rising-edge-detection",\r\n"not-supported"};\r\nchar *fall_values[] = {"no-falling-edge-detection",\r\n"falling-edge-detection",\r\n"not-supported"};\r\n#define NOT_SUPPORTED_IDX 2\r\nu8 edge_det = NOT_SUPPORTED_IDX;\r\nu8 rise = NOT_SUPPORTED_IDX;\r\nu8 fall = NOT_SUPPORTED_IDX;\r\nbool irqen;\r\nswitch (stmpe->partnum) {\r\ncase STMPE610:\r\ncase STMPE811:\r\ncase STMPE1601:\r\ncase STMPE2401:\r\ncase STMPE2403:\r\nedge_det_reg = stmpe->regs[STMPE_IDX_GPEDR_LSB + bank];\r\nret = stmpe_reg_read(stmpe, edge_det_reg);\r\nif (ret < 0)\r\nreturn;\r\nedge_det = !!(ret & mask);\r\ncase STMPE1801:\r\nrise_reg = stmpe->regs[STMPE_IDX_GPRER_LSB + bank];\r\nfall_reg = stmpe->regs[STMPE_IDX_GPFER_LSB + bank];\r\nret = stmpe_reg_read(stmpe, rise_reg);\r\nif (ret < 0)\r\nreturn;\r\nrise = !!(ret & mask);\r\nret = stmpe_reg_read(stmpe, fall_reg);\r\nif (ret < 0)\r\nreturn;\r\nfall = !!(ret & mask);\r\ncase STMPE801:\r\ncase STMPE1600:\r\nirqen_reg = stmpe->regs[STMPE_IDX_IEGPIOR_LSB + bank];\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nret = stmpe_reg_read(stmpe, irqen_reg);\r\nif (ret < 0)\r\nreturn;\r\nirqen = !!(ret & mask);\r\nseq_printf(s, " gpio-%-3d (%-20.20s) in %s %13s %13s %25s %25s",\r\ngpio, label ?: "(none)",\r\nval ? "hi" : "lo",\r\nedge_det_values[edge_det],\r\nirqen ? "IRQ-enabled" : "IRQ-disabled",\r\nrise_values[rise],\r\nfall_values[fall]);\r\n}\r\n}\r\nstatic void stmpe_dbg_show(struct seq_file *s, struct gpio_chip *gc)\r\n{\r\nunsigned i;\r\nunsigned gpio = gc->base;\r\nfor (i = 0; i < gc->ngpio; i++, gpio++) {\r\nstmpe_dbg_show_one(s, gc, i, gpio);\r\nseq_printf(s, "\n");\r\n}\r\n}\r\nstatic irqreturn_t stmpe_gpio_irq(int irq, void *dev)\r\n{\r\nstruct stmpe_gpio *stmpe_gpio = dev;\r\nstruct stmpe *stmpe = stmpe_gpio->stmpe;\r\nu8 statmsbreg;\r\nint num_banks = DIV_ROUND_UP(stmpe->num_gpios, 8);\r\nu8 status[num_banks];\r\nint ret;\r\nint i;\r\nif (stmpe->partnum == STMPE1600)\r\nstatmsbreg = stmpe->regs[STMPE_IDX_ISGPIOR_LSB];\r\nelse\r\nstatmsbreg = stmpe->regs[STMPE_IDX_ISGPIOR_MSB];\r\nret = stmpe_block_read(stmpe, statmsbreg, num_banks, status);\r\nif (ret < 0)\r\nreturn IRQ_NONE;\r\nfor (i = 0; i < num_banks; i++) {\r\nint bank = (stmpe_gpio->stmpe->partnum == STMPE1600) ? i :\r\nnum_banks - i - 1;\r\nunsigned int enabled = stmpe_gpio->regs[REG_IE][bank];\r\nunsigned int stat = status[i];\r\nstat &= enabled;\r\nif (!stat)\r\ncontinue;\r\nwhile (stat) {\r\nint bit = __ffs(stat);\r\nint line = bank * 8 + bit;\r\nint child_irq = irq_find_mapping(stmpe_gpio->chip.irqdomain,\r\nline);\r\nhandle_nested_irq(child_irq);\r\nstat &= ~BIT(bit);\r\n}\r\nif (stmpe->partnum != STMPE801 && stmpe->partnum != STMPE1600 &&\r\nstmpe->partnum != STMPE1801) {\r\nstmpe_reg_write(stmpe, statmsbreg + i, status[i]);\r\nstmpe_reg_write(stmpe,\r\nstmpe->regs[STMPE_IDX_GPEDR_MSB] + i,\r\nstatus[i]);\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int stmpe_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct stmpe *stmpe = dev_get_drvdata(pdev->dev.parent);\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct stmpe_gpio *stmpe_gpio;\r\nint ret;\r\nint irq = 0;\r\nirq = platform_get_irq(pdev, 0);\r\nstmpe_gpio = kzalloc(sizeof(struct stmpe_gpio), GFP_KERNEL);\r\nif (!stmpe_gpio)\r\nreturn -ENOMEM;\r\nmutex_init(&stmpe_gpio->irq_lock);\r\nstmpe_gpio->dev = &pdev->dev;\r\nstmpe_gpio->stmpe = stmpe;\r\nstmpe_gpio->chip = template_chip;\r\nstmpe_gpio->chip.ngpio = stmpe->num_gpios;\r\nstmpe_gpio->chip.parent = &pdev->dev;\r\nstmpe_gpio->chip.of_node = np;\r\nstmpe_gpio->chip.base = -1;\r\nif (IS_ENABLED(CONFIG_DEBUG_FS))\r\nstmpe_gpio->chip.dbg_show = stmpe_dbg_show;\r\nof_property_read_u32(np, "st,norequest-mask",\r\n&stmpe_gpio->norequest_mask);\r\nif (stmpe_gpio->norequest_mask)\r\nstmpe_gpio->chip.irq_need_valid_mask = true;\r\nif (irq < 0)\r\ndev_info(&pdev->dev,\r\n"device configured in no-irq mode: "\r\n"irqs are not available\n");\r\nret = stmpe_enable(stmpe, STMPE_BLOCK_GPIO);\r\nif (ret)\r\ngoto out_free;\r\nret = gpiochip_add_data(&stmpe_gpio->chip, stmpe_gpio);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to add gpiochip: %d\n", ret);\r\ngoto out_disable;\r\n}\r\nif (irq > 0) {\r\nret = devm_request_threaded_irq(&pdev->dev, irq, NULL,\r\nstmpe_gpio_irq, IRQF_ONESHOT,\r\n"stmpe-gpio", stmpe_gpio);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to get irq: %d\n", ret);\r\ngoto out_disable;\r\n}\r\nif (stmpe_gpio->norequest_mask) {\r\nint i;\r\nfor (i = 0; i < sizeof(u32); i++)\r\nif (stmpe_gpio->norequest_mask & BIT(i))\r\nclear_bit(i, stmpe_gpio->chip.irq_valid_mask);\r\n}\r\nret = gpiochip_irqchip_add_nested(&stmpe_gpio->chip,\r\n&stmpe_gpio_irq_chip,\r\n0,\r\nhandle_simple_irq,\r\nIRQ_TYPE_NONE);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"could not connect irqchip to gpiochip\n");\r\ngoto out_disable;\r\n}\r\ngpiochip_set_nested_irqchip(&stmpe_gpio->chip,\r\n&stmpe_gpio_irq_chip,\r\nirq);\r\n}\r\nplatform_set_drvdata(pdev, stmpe_gpio);\r\nreturn 0;\r\nout_disable:\r\nstmpe_disable(stmpe, STMPE_BLOCK_GPIO);\r\ngpiochip_remove(&stmpe_gpio->chip);\r\nout_free:\r\nkfree(stmpe_gpio);\r\nreturn ret;\r\n}\r\nstatic int __init stmpe_gpio_init(void)\r\n{\r\nreturn platform_driver_register(&stmpe_gpio_driver);\r\n}
