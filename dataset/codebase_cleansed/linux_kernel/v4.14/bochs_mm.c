static inline struct bochs_device *bochs_bdev(struct ttm_bo_device *bd)\r\n{\r\nreturn container_of(bd, struct bochs_device, ttm.bdev);\r\n}\r\nstatic int bochs_ttm_mem_global_init(struct drm_global_reference *ref)\r\n{\r\nreturn ttm_mem_global_init(ref->object);\r\n}\r\nstatic void bochs_ttm_mem_global_release(struct drm_global_reference *ref)\r\n{\r\nttm_mem_global_release(ref->object);\r\n}\r\nstatic int bochs_ttm_global_init(struct bochs_device *bochs)\r\n{\r\nstruct drm_global_reference *global_ref;\r\nint r;\r\nglobal_ref = &bochs->ttm.mem_global_ref;\r\nglobal_ref->global_type = DRM_GLOBAL_TTM_MEM;\r\nglobal_ref->size = sizeof(struct ttm_mem_global);\r\nglobal_ref->init = &bochs_ttm_mem_global_init;\r\nglobal_ref->release = &bochs_ttm_mem_global_release;\r\nr = drm_global_item_ref(global_ref);\r\nif (r != 0) {\r\nDRM_ERROR("Failed setting up TTM memory accounting "\r\n"subsystem.\n");\r\nreturn r;\r\n}\r\nbochs->ttm.bo_global_ref.mem_glob =\r\nbochs->ttm.mem_global_ref.object;\r\nglobal_ref = &bochs->ttm.bo_global_ref.ref;\r\nglobal_ref->global_type = DRM_GLOBAL_TTM_BO;\r\nglobal_ref->size = sizeof(struct ttm_bo_global);\r\nglobal_ref->init = &ttm_bo_global_init;\r\nglobal_ref->release = &ttm_bo_global_release;\r\nr = drm_global_item_ref(global_ref);\r\nif (r != 0) {\r\nDRM_ERROR("Failed setting up TTM BO subsystem.\n");\r\ndrm_global_item_unref(&bochs->ttm.mem_global_ref);\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nstatic void bochs_ttm_global_release(struct bochs_device *bochs)\r\n{\r\nif (bochs->ttm.mem_global_ref.release == NULL)\r\nreturn;\r\ndrm_global_item_unref(&bochs->ttm.bo_global_ref.ref);\r\ndrm_global_item_unref(&bochs->ttm.mem_global_ref);\r\nbochs->ttm.mem_global_ref.release = NULL;\r\n}\r\nstatic void bochs_bo_ttm_destroy(struct ttm_buffer_object *tbo)\r\n{\r\nstruct bochs_bo *bo;\r\nbo = container_of(tbo, struct bochs_bo, bo);\r\ndrm_gem_object_release(&bo->gem);\r\nkfree(bo);\r\n}\r\nstatic bool bochs_ttm_bo_is_bochs_bo(struct ttm_buffer_object *bo)\r\n{\r\nif (bo->destroy == &bochs_bo_ttm_destroy)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int bochs_bo_init_mem_type(struct ttm_bo_device *bdev, uint32_t type,\r\nstruct ttm_mem_type_manager *man)\r\n{\r\nswitch (type) {\r\ncase TTM_PL_SYSTEM:\r\nman->flags = TTM_MEMTYPE_FLAG_MAPPABLE;\r\nman->available_caching = TTM_PL_MASK_CACHING;\r\nman->default_caching = TTM_PL_FLAG_CACHED;\r\nbreak;\r\ncase TTM_PL_VRAM:\r\nman->func = &ttm_bo_manager_func;\r\nman->flags = TTM_MEMTYPE_FLAG_FIXED |\r\nTTM_MEMTYPE_FLAG_MAPPABLE;\r\nman->available_caching = TTM_PL_FLAG_UNCACHED |\r\nTTM_PL_FLAG_WC;\r\nman->default_caching = TTM_PL_FLAG_WC;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unsupported memory type %u\n", (unsigned)type);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nbochs_bo_evict_flags(struct ttm_buffer_object *bo, struct ttm_placement *pl)\r\n{\r\nstruct bochs_bo *bochsbo = bochs_bo(bo);\r\nif (!bochs_ttm_bo_is_bochs_bo(bo))\r\nreturn;\r\nbochs_ttm_placement(bochsbo, TTM_PL_FLAG_SYSTEM);\r\n*pl = bochsbo->placement;\r\n}\r\nstatic int bochs_bo_verify_access(struct ttm_buffer_object *bo,\r\nstruct file *filp)\r\n{\r\nstruct bochs_bo *bochsbo = bochs_bo(bo);\r\nreturn drm_vma_node_verify_access(&bochsbo->gem.vma_node,\r\nfilp->private_data);\r\n}\r\nstatic int bochs_ttm_io_mem_reserve(struct ttm_bo_device *bdev,\r\nstruct ttm_mem_reg *mem)\r\n{\r\nstruct ttm_mem_type_manager *man = &bdev->man[mem->mem_type];\r\nstruct bochs_device *bochs = bochs_bdev(bdev);\r\nmem->bus.addr = NULL;\r\nmem->bus.offset = 0;\r\nmem->bus.size = mem->num_pages << PAGE_SHIFT;\r\nmem->bus.base = 0;\r\nmem->bus.is_iomem = false;\r\nif (!(man->flags & TTM_MEMTYPE_FLAG_MAPPABLE))\r\nreturn -EINVAL;\r\nswitch (mem->mem_type) {\r\ncase TTM_PL_SYSTEM:\r\nreturn 0;\r\ncase TTM_PL_VRAM:\r\nmem->bus.offset = mem->start << PAGE_SHIFT;\r\nmem->bus.base = bochs->fb_base;\r\nmem->bus.is_iomem = true;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void bochs_ttm_io_mem_free(struct ttm_bo_device *bdev,\r\nstruct ttm_mem_reg *mem)\r\n{\r\n}\r\nstatic void bochs_ttm_backend_destroy(struct ttm_tt *tt)\r\n{\r\nttm_tt_fini(tt);\r\nkfree(tt);\r\n}\r\nstatic struct ttm_tt *bochs_ttm_tt_create(struct ttm_bo_device *bdev,\r\nunsigned long size,\r\nuint32_t page_flags,\r\nstruct page *dummy_read_page)\r\n{\r\nstruct ttm_tt *tt;\r\ntt = kzalloc(sizeof(struct ttm_tt), GFP_KERNEL);\r\nif (tt == NULL)\r\nreturn NULL;\r\ntt->func = &bochs_tt_backend_func;\r\nif (ttm_tt_init(tt, bdev, size, page_flags, dummy_read_page)) {\r\nkfree(tt);\r\nreturn NULL;\r\n}\r\nreturn tt;\r\n}\r\nint bochs_mm_init(struct bochs_device *bochs)\r\n{\r\nstruct ttm_bo_device *bdev = &bochs->ttm.bdev;\r\nint ret;\r\nret = bochs_ttm_global_init(bochs);\r\nif (ret)\r\nreturn ret;\r\nret = ttm_bo_device_init(&bochs->ttm.bdev,\r\nbochs->ttm.bo_global_ref.ref.object,\r\n&bochs_bo_driver,\r\nbochs->dev->anon_inode->i_mapping,\r\nDRM_FILE_PAGE_OFFSET,\r\ntrue);\r\nif (ret) {\r\nDRM_ERROR("Error initialising bo driver; %d\n", ret);\r\nreturn ret;\r\n}\r\nret = ttm_bo_init_mm(bdev, TTM_PL_VRAM,\r\nbochs->fb_size >> PAGE_SHIFT);\r\nif (ret) {\r\nDRM_ERROR("Failed ttm VRAM init: %d\n", ret);\r\nreturn ret;\r\n}\r\nbochs->ttm.initialized = true;\r\nreturn 0;\r\n}\r\nvoid bochs_mm_fini(struct bochs_device *bochs)\r\n{\r\nif (!bochs->ttm.initialized)\r\nreturn;\r\nttm_bo_device_release(&bochs->ttm.bdev);\r\nbochs_ttm_global_release(bochs);\r\nbochs->ttm.initialized = false;\r\n}\r\nstatic void bochs_ttm_placement(struct bochs_bo *bo, int domain)\r\n{\r\nunsigned i;\r\nu32 c = 0;\r\nbo->placement.placement = bo->placements;\r\nbo->placement.busy_placement = bo->placements;\r\nif (domain & TTM_PL_FLAG_VRAM) {\r\nbo->placements[c++].flags = TTM_PL_FLAG_WC\r\n| TTM_PL_FLAG_UNCACHED\r\n| TTM_PL_FLAG_VRAM;\r\n}\r\nif (domain & TTM_PL_FLAG_SYSTEM) {\r\nbo->placements[c++].flags = TTM_PL_MASK_CACHING\r\n| TTM_PL_FLAG_SYSTEM;\r\n}\r\nif (!c) {\r\nbo->placements[c++].flags = TTM_PL_MASK_CACHING\r\n| TTM_PL_FLAG_SYSTEM;\r\n}\r\nfor (i = 0; i < c; ++i) {\r\nbo->placements[i].fpfn = 0;\r\nbo->placements[i].lpfn = 0;\r\n}\r\nbo->placement.num_placement = c;\r\nbo->placement.num_busy_placement = c;\r\n}\r\nstatic inline u64 bochs_bo_gpu_offset(struct bochs_bo *bo)\r\n{\r\nreturn bo->bo.offset;\r\n}\r\nint bochs_bo_pin(struct bochs_bo *bo, u32 pl_flag, u64 *gpu_addr)\r\n{\r\nint i, ret;\r\nif (bo->pin_count) {\r\nbo->pin_count++;\r\nif (gpu_addr)\r\n*gpu_addr = bochs_bo_gpu_offset(bo);\r\nreturn 0;\r\n}\r\nbochs_ttm_placement(bo, pl_flag);\r\nfor (i = 0; i < bo->placement.num_placement; i++)\r\nbo->placements[i].flags |= TTM_PL_FLAG_NO_EVICT;\r\nret = ttm_bo_validate(&bo->bo, &bo->placement, false, false);\r\nif (ret)\r\nreturn ret;\r\nbo->pin_count = 1;\r\nif (gpu_addr)\r\n*gpu_addr = bochs_bo_gpu_offset(bo);\r\nreturn 0;\r\n}\r\nint bochs_bo_unpin(struct bochs_bo *bo)\r\n{\r\nint i, ret;\r\nif (!bo->pin_count) {\r\nDRM_ERROR("unpin bad %p\n", bo);\r\nreturn 0;\r\n}\r\nbo->pin_count--;\r\nif (bo->pin_count)\r\nreturn 0;\r\nfor (i = 0; i < bo->placement.num_placement; i++)\r\nbo->placements[i].flags &= ~TTM_PL_FLAG_NO_EVICT;\r\nret = ttm_bo_validate(&bo->bo, &bo->placement, false, false);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nint bochs_mmap(struct file *filp, struct vm_area_struct *vma)\r\n{\r\nstruct drm_file *file_priv;\r\nstruct bochs_device *bochs;\r\nif (unlikely(vma->vm_pgoff < DRM_FILE_PAGE_OFFSET))\r\nreturn -EINVAL;\r\nfile_priv = filp->private_data;\r\nbochs = file_priv->minor->dev->dev_private;\r\nreturn ttm_bo_mmap(filp, vma, &bochs->ttm.bdev);\r\n}\r\nstatic int bochs_bo_create(struct drm_device *dev, int size, int align,\r\nuint32_t flags, struct bochs_bo **pbochsbo)\r\n{\r\nstruct bochs_device *bochs = dev->dev_private;\r\nstruct bochs_bo *bochsbo;\r\nsize_t acc_size;\r\nint ret;\r\nbochsbo = kzalloc(sizeof(struct bochs_bo), GFP_KERNEL);\r\nif (!bochsbo)\r\nreturn -ENOMEM;\r\nret = drm_gem_object_init(dev, &bochsbo->gem, size);\r\nif (ret) {\r\nkfree(bochsbo);\r\nreturn ret;\r\n}\r\nbochsbo->bo.bdev = &bochs->ttm.bdev;\r\nbochsbo->bo.bdev->dev_mapping = dev->anon_inode->i_mapping;\r\nbochs_ttm_placement(bochsbo, TTM_PL_FLAG_VRAM | TTM_PL_FLAG_SYSTEM);\r\nacc_size = ttm_bo_dma_acc_size(&bochs->ttm.bdev, size,\r\nsizeof(struct bochs_bo));\r\nret = ttm_bo_init(&bochs->ttm.bdev, &bochsbo->bo, size,\r\nttm_bo_type_device, &bochsbo->placement,\r\nalign >> PAGE_SHIFT, false, NULL, acc_size,\r\nNULL, NULL, bochs_bo_ttm_destroy);\r\nif (ret)\r\nreturn ret;\r\n*pbochsbo = bochsbo;\r\nreturn 0;\r\n}\r\nint bochs_gem_create(struct drm_device *dev, u32 size, bool iskernel,\r\nstruct drm_gem_object **obj)\r\n{\r\nstruct bochs_bo *bochsbo;\r\nint ret;\r\n*obj = NULL;\r\nsize = PAGE_ALIGN(size);\r\nif (size == 0)\r\nreturn -EINVAL;\r\nret = bochs_bo_create(dev, size, 0, 0, &bochsbo);\r\nif (ret) {\r\nif (ret != -ERESTARTSYS)\r\nDRM_ERROR("failed to allocate GEM object\n");\r\nreturn ret;\r\n}\r\n*obj = &bochsbo->gem;\r\nreturn 0;\r\n}\r\nint bochs_dumb_create(struct drm_file *file, struct drm_device *dev,\r\nstruct drm_mode_create_dumb *args)\r\n{\r\nstruct drm_gem_object *gobj;\r\nu32 handle;\r\nint ret;\r\nargs->pitch = args->width * ((args->bpp + 7) / 8);\r\nargs->size = args->pitch * args->height;\r\nret = bochs_gem_create(dev, args->size, false,\r\n&gobj);\r\nif (ret)\r\nreturn ret;\r\nret = drm_gem_handle_create(file, gobj, &handle);\r\ndrm_gem_object_unreference_unlocked(gobj);\r\nif (ret)\r\nreturn ret;\r\nargs->handle = handle;\r\nreturn 0;\r\n}\r\nstatic void bochs_bo_unref(struct bochs_bo **bo)\r\n{\r\nstruct ttm_buffer_object *tbo;\r\nif ((*bo) == NULL)\r\nreturn;\r\ntbo = &((*bo)->bo);\r\nttm_bo_unref(&tbo);\r\n*bo = NULL;\r\n}\r\nvoid bochs_gem_free_object(struct drm_gem_object *obj)\r\n{\r\nstruct bochs_bo *bochs_bo = gem_to_bochs_bo(obj);\r\nbochs_bo_unref(&bochs_bo);\r\n}\r\nint bochs_dumb_mmap_offset(struct drm_file *file, struct drm_device *dev,\r\nuint32_t handle, uint64_t *offset)\r\n{\r\nstruct drm_gem_object *obj;\r\nstruct bochs_bo *bo;\r\nobj = drm_gem_object_lookup(file, handle);\r\nif (obj == NULL)\r\nreturn -ENOENT;\r\nbo = gem_to_bochs_bo(obj);\r\n*offset = bochs_bo_mmap_offset(bo);\r\ndrm_gem_object_unreference_unlocked(obj);\r\nreturn 0;\r\n}\r\nstatic void bochs_user_framebuffer_destroy(struct drm_framebuffer *fb)\r\n{\r\nstruct bochs_framebuffer *bochs_fb = to_bochs_framebuffer(fb);\r\ndrm_gem_object_unreference_unlocked(bochs_fb->obj);\r\ndrm_framebuffer_cleanup(fb);\r\nkfree(fb);\r\n}\r\nint bochs_framebuffer_init(struct drm_device *dev,\r\nstruct bochs_framebuffer *gfb,\r\nconst struct drm_mode_fb_cmd2 *mode_cmd,\r\nstruct drm_gem_object *obj)\r\n{\r\nint ret;\r\ndrm_helper_mode_fill_fb_struct(dev, &gfb->base, mode_cmd);\r\ngfb->obj = obj;\r\nret = drm_framebuffer_init(dev, &gfb->base, &bochs_fb_funcs);\r\nif (ret) {\r\nDRM_ERROR("drm_framebuffer_init failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct drm_framebuffer *\r\nbochs_user_framebuffer_create(struct drm_device *dev,\r\nstruct drm_file *filp,\r\nconst struct drm_mode_fb_cmd2 *mode_cmd)\r\n{\r\nstruct drm_gem_object *obj;\r\nstruct bochs_framebuffer *bochs_fb;\r\nint ret;\r\nDRM_DEBUG_DRIVER("%dx%d, format %c%c%c%c\n",\r\nmode_cmd->width, mode_cmd->height,\r\n(mode_cmd->pixel_format) & 0xff,\r\n(mode_cmd->pixel_format >> 8) & 0xff,\r\n(mode_cmd->pixel_format >> 16) & 0xff,\r\n(mode_cmd->pixel_format >> 24) & 0xff);\r\nif (mode_cmd->pixel_format != DRM_FORMAT_XRGB8888)\r\nreturn ERR_PTR(-ENOENT);\r\nobj = drm_gem_object_lookup(filp, mode_cmd->handles[0]);\r\nif (obj == NULL)\r\nreturn ERR_PTR(-ENOENT);\r\nbochs_fb = kzalloc(sizeof(*bochs_fb), GFP_KERNEL);\r\nif (!bochs_fb) {\r\ndrm_gem_object_unreference_unlocked(obj);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nret = bochs_framebuffer_init(dev, bochs_fb, mode_cmd, obj);\r\nif (ret) {\r\ndrm_gem_object_unreference_unlocked(obj);\r\nkfree(bochs_fb);\r\nreturn ERR_PTR(ret);\r\n}\r\nreturn &bochs_fb->base;\r\n}
