static void rsa_io_unmap(struct device *dev, struct rsa_edesc *edesc,\r\nstruct akcipher_request *req)\r\n{\r\ndma_unmap_sg(dev, req->dst, edesc->dst_nents, DMA_FROM_DEVICE);\r\ndma_unmap_sg(dev, req->src, edesc->src_nents, DMA_TO_DEVICE);\r\nif (edesc->sec4_sg_bytes)\r\ndma_unmap_single(dev, edesc->sec4_sg_dma, edesc->sec4_sg_bytes,\r\nDMA_TO_DEVICE);\r\n}\r\nstatic void rsa_pub_unmap(struct device *dev, struct rsa_edesc *edesc,\r\nstruct akcipher_request *req)\r\n{\r\nstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\r\nstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx(tfm);\r\nstruct caam_rsa_key *key = &ctx->key;\r\nstruct rsa_pub_pdb *pdb = &edesc->pdb.pub;\r\ndma_unmap_single(dev, pdb->n_dma, key->n_sz, DMA_TO_DEVICE);\r\ndma_unmap_single(dev, pdb->e_dma, key->e_sz, DMA_TO_DEVICE);\r\n}\r\nstatic void rsa_priv_f1_unmap(struct device *dev, struct rsa_edesc *edesc,\r\nstruct akcipher_request *req)\r\n{\r\nstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\r\nstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx(tfm);\r\nstruct caam_rsa_key *key = &ctx->key;\r\nstruct rsa_priv_f1_pdb *pdb = &edesc->pdb.priv_f1;\r\ndma_unmap_single(dev, pdb->n_dma, key->n_sz, DMA_TO_DEVICE);\r\ndma_unmap_single(dev, pdb->d_dma, key->d_sz, DMA_TO_DEVICE);\r\n}\r\nstatic void rsa_priv_f2_unmap(struct device *dev, struct rsa_edesc *edesc,\r\nstruct akcipher_request *req)\r\n{\r\nstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\r\nstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx(tfm);\r\nstruct caam_rsa_key *key = &ctx->key;\r\nstruct rsa_priv_f2_pdb *pdb = &edesc->pdb.priv_f2;\r\nsize_t p_sz = key->p_sz;\r\nsize_t q_sz = key->p_sz;\r\ndma_unmap_single(dev, pdb->d_dma, key->d_sz, DMA_TO_DEVICE);\r\ndma_unmap_single(dev, pdb->p_dma, p_sz, DMA_TO_DEVICE);\r\ndma_unmap_single(dev, pdb->q_dma, q_sz, DMA_TO_DEVICE);\r\ndma_unmap_single(dev, pdb->tmp1_dma, p_sz, DMA_TO_DEVICE);\r\ndma_unmap_single(dev, pdb->tmp2_dma, q_sz, DMA_TO_DEVICE);\r\n}\r\nstatic void rsa_priv_f3_unmap(struct device *dev, struct rsa_edesc *edesc,\r\nstruct akcipher_request *req)\r\n{\r\nstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\r\nstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx(tfm);\r\nstruct caam_rsa_key *key = &ctx->key;\r\nstruct rsa_priv_f3_pdb *pdb = &edesc->pdb.priv_f3;\r\nsize_t p_sz = key->p_sz;\r\nsize_t q_sz = key->p_sz;\r\ndma_unmap_single(dev, pdb->p_dma, p_sz, DMA_TO_DEVICE);\r\ndma_unmap_single(dev, pdb->q_dma, q_sz, DMA_TO_DEVICE);\r\ndma_unmap_single(dev, pdb->dp_dma, p_sz, DMA_TO_DEVICE);\r\ndma_unmap_single(dev, pdb->dq_dma, q_sz, DMA_TO_DEVICE);\r\ndma_unmap_single(dev, pdb->c_dma, p_sz, DMA_TO_DEVICE);\r\ndma_unmap_single(dev, pdb->tmp1_dma, p_sz, DMA_TO_DEVICE);\r\ndma_unmap_single(dev, pdb->tmp2_dma, q_sz, DMA_TO_DEVICE);\r\n}\r\nstatic void rsa_pub_done(struct device *dev, u32 *desc, u32 err, void *context)\r\n{\r\nstruct akcipher_request *req = context;\r\nstruct rsa_edesc *edesc;\r\nif (err)\r\ncaam_jr_strstatus(dev, err);\r\nedesc = container_of(desc, struct rsa_edesc, hw_desc[0]);\r\nrsa_pub_unmap(dev, edesc, req);\r\nrsa_io_unmap(dev, edesc, req);\r\nkfree(edesc);\r\nakcipher_request_complete(req, err);\r\n}\r\nstatic void rsa_priv_f1_done(struct device *dev, u32 *desc, u32 err,\r\nvoid *context)\r\n{\r\nstruct akcipher_request *req = context;\r\nstruct rsa_edesc *edesc;\r\nif (err)\r\ncaam_jr_strstatus(dev, err);\r\nedesc = container_of(desc, struct rsa_edesc, hw_desc[0]);\r\nrsa_priv_f1_unmap(dev, edesc, req);\r\nrsa_io_unmap(dev, edesc, req);\r\nkfree(edesc);\r\nakcipher_request_complete(req, err);\r\n}\r\nstatic void rsa_priv_f2_done(struct device *dev, u32 *desc, u32 err,\r\nvoid *context)\r\n{\r\nstruct akcipher_request *req = context;\r\nstruct rsa_edesc *edesc;\r\nif (err)\r\ncaam_jr_strstatus(dev, err);\r\nedesc = container_of(desc, struct rsa_edesc, hw_desc[0]);\r\nrsa_priv_f2_unmap(dev, edesc, req);\r\nrsa_io_unmap(dev, edesc, req);\r\nkfree(edesc);\r\nakcipher_request_complete(req, err);\r\n}\r\nstatic void rsa_priv_f3_done(struct device *dev, u32 *desc, u32 err,\r\nvoid *context)\r\n{\r\nstruct akcipher_request *req = context;\r\nstruct rsa_edesc *edesc;\r\nif (err)\r\ncaam_jr_strstatus(dev, err);\r\nedesc = container_of(desc, struct rsa_edesc, hw_desc[0]);\r\nrsa_priv_f3_unmap(dev, edesc, req);\r\nrsa_io_unmap(dev, edesc, req);\r\nkfree(edesc);\r\nakcipher_request_complete(req, err);\r\n}\r\nstatic struct rsa_edesc *rsa_edesc_alloc(struct akcipher_request *req,\r\nsize_t desclen)\r\n{\r\nstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\r\nstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx(tfm);\r\nstruct device *dev = ctx->dev;\r\nstruct rsa_edesc *edesc;\r\ngfp_t flags = (req->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP) ?\r\nGFP_KERNEL : GFP_ATOMIC;\r\nint sgc;\r\nint sec4_sg_index, sec4_sg_len = 0, sec4_sg_bytes;\r\nint src_nents, dst_nents;\r\nsrc_nents = sg_nents_for_len(req->src, req->src_len);\r\ndst_nents = sg_nents_for_len(req->dst, req->dst_len);\r\nif (src_nents > 1)\r\nsec4_sg_len = src_nents;\r\nif (dst_nents > 1)\r\nsec4_sg_len += dst_nents;\r\nsec4_sg_bytes = sec4_sg_len * sizeof(struct sec4_sg_entry);\r\nedesc = kzalloc(sizeof(*edesc) + desclen + sec4_sg_bytes,\r\nGFP_DMA | flags);\r\nif (!edesc)\r\nreturn ERR_PTR(-ENOMEM);\r\nsgc = dma_map_sg(dev, req->src, src_nents, DMA_TO_DEVICE);\r\nif (unlikely(!sgc)) {\r\ndev_err(dev, "unable to map source\n");\r\ngoto src_fail;\r\n}\r\nsgc = dma_map_sg(dev, req->dst, dst_nents, DMA_FROM_DEVICE);\r\nif (unlikely(!sgc)) {\r\ndev_err(dev, "unable to map destination\n");\r\ngoto dst_fail;\r\n}\r\nedesc->sec4_sg = (void *)edesc + sizeof(*edesc) + desclen;\r\nsec4_sg_index = 0;\r\nif (src_nents > 1) {\r\nsg_to_sec4_sg_last(req->src, src_nents, edesc->sec4_sg, 0);\r\nsec4_sg_index += src_nents;\r\n}\r\nif (dst_nents > 1)\r\nsg_to_sec4_sg_last(req->dst, dst_nents,\r\nedesc->sec4_sg + sec4_sg_index, 0);\r\nedesc->src_nents = src_nents;\r\nedesc->dst_nents = dst_nents;\r\nif (!sec4_sg_bytes)\r\nreturn edesc;\r\nedesc->sec4_sg_dma = dma_map_single(dev, edesc->sec4_sg,\r\nsec4_sg_bytes, DMA_TO_DEVICE);\r\nif (dma_mapping_error(dev, edesc->sec4_sg_dma)) {\r\ndev_err(dev, "unable to map S/G table\n");\r\ngoto sec4_sg_fail;\r\n}\r\nedesc->sec4_sg_bytes = sec4_sg_bytes;\r\nreturn edesc;\r\nsec4_sg_fail:\r\ndma_unmap_sg(dev, req->dst, dst_nents, DMA_FROM_DEVICE);\r\ndst_fail:\r\ndma_unmap_sg(dev, req->src, src_nents, DMA_TO_DEVICE);\r\nsrc_fail:\r\nkfree(edesc);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nstatic int set_rsa_pub_pdb(struct akcipher_request *req,\r\nstruct rsa_edesc *edesc)\r\n{\r\nstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\r\nstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx(tfm);\r\nstruct caam_rsa_key *key = &ctx->key;\r\nstruct device *dev = ctx->dev;\r\nstruct rsa_pub_pdb *pdb = &edesc->pdb.pub;\r\nint sec4_sg_index = 0;\r\npdb->n_dma = dma_map_single(dev, key->n, key->n_sz, DMA_TO_DEVICE);\r\nif (dma_mapping_error(dev, pdb->n_dma)) {\r\ndev_err(dev, "Unable to map RSA modulus memory\n");\r\nreturn -ENOMEM;\r\n}\r\npdb->e_dma = dma_map_single(dev, key->e, key->e_sz, DMA_TO_DEVICE);\r\nif (dma_mapping_error(dev, pdb->e_dma)) {\r\ndev_err(dev, "Unable to map RSA public exponent memory\n");\r\ndma_unmap_single(dev, pdb->n_dma, key->n_sz, DMA_TO_DEVICE);\r\nreturn -ENOMEM;\r\n}\r\nif (edesc->src_nents > 1) {\r\npdb->sgf |= RSA_PDB_SGF_F;\r\npdb->f_dma = edesc->sec4_sg_dma;\r\nsec4_sg_index += edesc->src_nents;\r\n} else {\r\npdb->f_dma = sg_dma_address(req->src);\r\n}\r\nif (edesc->dst_nents > 1) {\r\npdb->sgf |= RSA_PDB_SGF_G;\r\npdb->g_dma = edesc->sec4_sg_dma +\r\nsec4_sg_index * sizeof(struct sec4_sg_entry);\r\n} else {\r\npdb->g_dma = sg_dma_address(req->dst);\r\n}\r\npdb->sgf |= (key->e_sz << RSA_PDB_E_SHIFT) | key->n_sz;\r\npdb->f_len = req->src_len;\r\nreturn 0;\r\n}\r\nstatic int set_rsa_priv_f1_pdb(struct akcipher_request *req,\r\nstruct rsa_edesc *edesc)\r\n{\r\nstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\r\nstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx(tfm);\r\nstruct caam_rsa_key *key = &ctx->key;\r\nstruct device *dev = ctx->dev;\r\nstruct rsa_priv_f1_pdb *pdb = &edesc->pdb.priv_f1;\r\nint sec4_sg_index = 0;\r\npdb->n_dma = dma_map_single(dev, key->n, key->n_sz, DMA_TO_DEVICE);\r\nif (dma_mapping_error(dev, pdb->n_dma)) {\r\ndev_err(dev, "Unable to map modulus memory\n");\r\nreturn -ENOMEM;\r\n}\r\npdb->d_dma = dma_map_single(dev, key->d, key->d_sz, DMA_TO_DEVICE);\r\nif (dma_mapping_error(dev, pdb->d_dma)) {\r\ndev_err(dev, "Unable to map RSA private exponent memory\n");\r\ndma_unmap_single(dev, pdb->n_dma, key->n_sz, DMA_TO_DEVICE);\r\nreturn -ENOMEM;\r\n}\r\nif (edesc->src_nents > 1) {\r\npdb->sgf |= RSA_PRIV_PDB_SGF_G;\r\npdb->g_dma = edesc->sec4_sg_dma;\r\nsec4_sg_index += edesc->src_nents;\r\n} else {\r\npdb->g_dma = sg_dma_address(req->src);\r\n}\r\nif (edesc->dst_nents > 1) {\r\npdb->sgf |= RSA_PRIV_PDB_SGF_F;\r\npdb->f_dma = edesc->sec4_sg_dma +\r\nsec4_sg_index * sizeof(struct sec4_sg_entry);\r\n} else {\r\npdb->f_dma = sg_dma_address(req->dst);\r\n}\r\npdb->sgf |= (key->d_sz << RSA_PDB_D_SHIFT) | key->n_sz;\r\nreturn 0;\r\n}\r\nstatic int set_rsa_priv_f2_pdb(struct akcipher_request *req,\r\nstruct rsa_edesc *edesc)\r\n{\r\nstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\r\nstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx(tfm);\r\nstruct caam_rsa_key *key = &ctx->key;\r\nstruct device *dev = ctx->dev;\r\nstruct rsa_priv_f2_pdb *pdb = &edesc->pdb.priv_f2;\r\nint sec4_sg_index = 0;\r\nsize_t p_sz = key->p_sz;\r\nsize_t q_sz = key->p_sz;\r\npdb->d_dma = dma_map_single(dev, key->d, key->d_sz, DMA_TO_DEVICE);\r\nif (dma_mapping_error(dev, pdb->d_dma)) {\r\ndev_err(dev, "Unable to map RSA private exponent memory\n");\r\nreturn -ENOMEM;\r\n}\r\npdb->p_dma = dma_map_single(dev, key->p, p_sz, DMA_TO_DEVICE);\r\nif (dma_mapping_error(dev, pdb->p_dma)) {\r\ndev_err(dev, "Unable to map RSA prime factor p memory\n");\r\ngoto unmap_d;\r\n}\r\npdb->q_dma = dma_map_single(dev, key->q, q_sz, DMA_TO_DEVICE);\r\nif (dma_mapping_error(dev, pdb->q_dma)) {\r\ndev_err(dev, "Unable to map RSA prime factor q memory\n");\r\ngoto unmap_p;\r\n}\r\npdb->tmp1_dma = dma_map_single(dev, key->tmp1, p_sz, DMA_TO_DEVICE);\r\nif (dma_mapping_error(dev, pdb->tmp1_dma)) {\r\ndev_err(dev, "Unable to map RSA tmp1 memory\n");\r\ngoto unmap_q;\r\n}\r\npdb->tmp2_dma = dma_map_single(dev, key->tmp2, q_sz, DMA_TO_DEVICE);\r\nif (dma_mapping_error(dev, pdb->tmp2_dma)) {\r\ndev_err(dev, "Unable to map RSA tmp2 memory\n");\r\ngoto unmap_tmp1;\r\n}\r\nif (edesc->src_nents > 1) {\r\npdb->sgf |= RSA_PRIV_PDB_SGF_G;\r\npdb->g_dma = edesc->sec4_sg_dma;\r\nsec4_sg_index += edesc->src_nents;\r\n} else {\r\npdb->g_dma = sg_dma_address(req->src);\r\n}\r\nif (edesc->dst_nents > 1) {\r\npdb->sgf |= RSA_PRIV_PDB_SGF_F;\r\npdb->f_dma = edesc->sec4_sg_dma +\r\nsec4_sg_index * sizeof(struct sec4_sg_entry);\r\n} else {\r\npdb->f_dma = sg_dma_address(req->dst);\r\n}\r\npdb->sgf |= (key->d_sz << RSA_PDB_D_SHIFT) | key->n_sz;\r\npdb->p_q_len = (q_sz << RSA_PDB_Q_SHIFT) | p_sz;\r\nreturn 0;\r\nunmap_tmp1:\r\ndma_unmap_single(dev, pdb->tmp1_dma, p_sz, DMA_TO_DEVICE);\r\nunmap_q:\r\ndma_unmap_single(dev, pdb->q_dma, q_sz, DMA_TO_DEVICE);\r\nunmap_p:\r\ndma_unmap_single(dev, pdb->p_dma, p_sz, DMA_TO_DEVICE);\r\nunmap_d:\r\ndma_unmap_single(dev, pdb->d_dma, key->d_sz, DMA_TO_DEVICE);\r\nreturn -ENOMEM;\r\n}\r\nstatic int set_rsa_priv_f3_pdb(struct akcipher_request *req,\r\nstruct rsa_edesc *edesc)\r\n{\r\nstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\r\nstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx(tfm);\r\nstruct caam_rsa_key *key = &ctx->key;\r\nstruct device *dev = ctx->dev;\r\nstruct rsa_priv_f3_pdb *pdb = &edesc->pdb.priv_f3;\r\nint sec4_sg_index = 0;\r\nsize_t p_sz = key->p_sz;\r\nsize_t q_sz = key->p_sz;\r\npdb->p_dma = dma_map_single(dev, key->p, p_sz, DMA_TO_DEVICE);\r\nif (dma_mapping_error(dev, pdb->p_dma)) {\r\ndev_err(dev, "Unable to map RSA prime factor p memory\n");\r\nreturn -ENOMEM;\r\n}\r\npdb->q_dma = dma_map_single(dev, key->q, q_sz, DMA_TO_DEVICE);\r\nif (dma_mapping_error(dev, pdb->q_dma)) {\r\ndev_err(dev, "Unable to map RSA prime factor q memory\n");\r\ngoto unmap_p;\r\n}\r\npdb->dp_dma = dma_map_single(dev, key->dp, p_sz, DMA_TO_DEVICE);\r\nif (dma_mapping_error(dev, pdb->dp_dma)) {\r\ndev_err(dev, "Unable to map RSA exponent dp memory\n");\r\ngoto unmap_q;\r\n}\r\npdb->dq_dma = dma_map_single(dev, key->dq, q_sz, DMA_TO_DEVICE);\r\nif (dma_mapping_error(dev, pdb->dq_dma)) {\r\ndev_err(dev, "Unable to map RSA exponent dq memory\n");\r\ngoto unmap_dp;\r\n}\r\npdb->c_dma = dma_map_single(dev, key->qinv, p_sz, DMA_TO_DEVICE);\r\nif (dma_mapping_error(dev, pdb->c_dma)) {\r\ndev_err(dev, "Unable to map RSA CRT coefficient qinv memory\n");\r\ngoto unmap_dq;\r\n}\r\npdb->tmp1_dma = dma_map_single(dev, key->tmp1, p_sz, DMA_TO_DEVICE);\r\nif (dma_mapping_error(dev, pdb->tmp1_dma)) {\r\ndev_err(dev, "Unable to map RSA tmp1 memory\n");\r\ngoto unmap_qinv;\r\n}\r\npdb->tmp2_dma = dma_map_single(dev, key->tmp2, q_sz, DMA_TO_DEVICE);\r\nif (dma_mapping_error(dev, pdb->tmp2_dma)) {\r\ndev_err(dev, "Unable to map RSA tmp2 memory\n");\r\ngoto unmap_tmp1;\r\n}\r\nif (edesc->src_nents > 1) {\r\npdb->sgf |= RSA_PRIV_PDB_SGF_G;\r\npdb->g_dma = edesc->sec4_sg_dma;\r\nsec4_sg_index += edesc->src_nents;\r\n} else {\r\npdb->g_dma = sg_dma_address(req->src);\r\n}\r\nif (edesc->dst_nents > 1) {\r\npdb->sgf |= RSA_PRIV_PDB_SGF_F;\r\npdb->f_dma = edesc->sec4_sg_dma +\r\nsec4_sg_index * sizeof(struct sec4_sg_entry);\r\n} else {\r\npdb->f_dma = sg_dma_address(req->dst);\r\n}\r\npdb->sgf |= key->n_sz;\r\npdb->p_q_len = (q_sz << RSA_PDB_Q_SHIFT) | p_sz;\r\nreturn 0;\r\nunmap_tmp1:\r\ndma_unmap_single(dev, pdb->tmp1_dma, p_sz, DMA_TO_DEVICE);\r\nunmap_qinv:\r\ndma_unmap_single(dev, pdb->c_dma, p_sz, DMA_TO_DEVICE);\r\nunmap_dq:\r\ndma_unmap_single(dev, pdb->dq_dma, q_sz, DMA_TO_DEVICE);\r\nunmap_dp:\r\ndma_unmap_single(dev, pdb->dp_dma, p_sz, DMA_TO_DEVICE);\r\nunmap_q:\r\ndma_unmap_single(dev, pdb->q_dma, q_sz, DMA_TO_DEVICE);\r\nunmap_p:\r\ndma_unmap_single(dev, pdb->p_dma, p_sz, DMA_TO_DEVICE);\r\nreturn -ENOMEM;\r\n}\r\nstatic int caam_rsa_enc(struct akcipher_request *req)\r\n{\r\nstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\r\nstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx(tfm);\r\nstruct caam_rsa_key *key = &ctx->key;\r\nstruct device *jrdev = ctx->dev;\r\nstruct rsa_edesc *edesc;\r\nint ret;\r\nif (unlikely(!key->n || !key->e))\r\nreturn -EINVAL;\r\nif (req->dst_len < key->n_sz) {\r\nreq->dst_len = key->n_sz;\r\ndev_err(jrdev, "Output buffer length less than parameter n\n");\r\nreturn -EOVERFLOW;\r\n}\r\nedesc = rsa_edesc_alloc(req, DESC_RSA_PUB_LEN);\r\nif (IS_ERR(edesc))\r\nreturn PTR_ERR(edesc);\r\nret = set_rsa_pub_pdb(req, edesc);\r\nif (ret)\r\ngoto init_fail;\r\ninit_rsa_pub_desc(edesc->hw_desc, &edesc->pdb.pub);\r\nret = caam_jr_enqueue(jrdev, edesc->hw_desc, rsa_pub_done, req);\r\nif (!ret)\r\nreturn -EINPROGRESS;\r\nrsa_pub_unmap(jrdev, edesc, req);\r\ninit_fail:\r\nrsa_io_unmap(jrdev, edesc, req);\r\nkfree(edesc);\r\nreturn ret;\r\n}\r\nstatic int caam_rsa_dec_priv_f1(struct akcipher_request *req)\r\n{\r\nstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\r\nstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx(tfm);\r\nstruct device *jrdev = ctx->dev;\r\nstruct rsa_edesc *edesc;\r\nint ret;\r\nedesc = rsa_edesc_alloc(req, DESC_RSA_PRIV_F1_LEN);\r\nif (IS_ERR(edesc))\r\nreturn PTR_ERR(edesc);\r\nret = set_rsa_priv_f1_pdb(req, edesc);\r\nif (ret)\r\ngoto init_fail;\r\ninit_rsa_priv_f1_desc(edesc->hw_desc, &edesc->pdb.priv_f1);\r\nret = caam_jr_enqueue(jrdev, edesc->hw_desc, rsa_priv_f1_done, req);\r\nif (!ret)\r\nreturn -EINPROGRESS;\r\nrsa_priv_f1_unmap(jrdev, edesc, req);\r\ninit_fail:\r\nrsa_io_unmap(jrdev, edesc, req);\r\nkfree(edesc);\r\nreturn ret;\r\n}\r\nstatic int caam_rsa_dec_priv_f2(struct akcipher_request *req)\r\n{\r\nstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\r\nstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx(tfm);\r\nstruct device *jrdev = ctx->dev;\r\nstruct rsa_edesc *edesc;\r\nint ret;\r\nedesc = rsa_edesc_alloc(req, DESC_RSA_PRIV_F2_LEN);\r\nif (IS_ERR(edesc))\r\nreturn PTR_ERR(edesc);\r\nret = set_rsa_priv_f2_pdb(req, edesc);\r\nif (ret)\r\ngoto init_fail;\r\ninit_rsa_priv_f2_desc(edesc->hw_desc, &edesc->pdb.priv_f2);\r\nret = caam_jr_enqueue(jrdev, edesc->hw_desc, rsa_priv_f2_done, req);\r\nif (!ret)\r\nreturn -EINPROGRESS;\r\nrsa_priv_f2_unmap(jrdev, edesc, req);\r\ninit_fail:\r\nrsa_io_unmap(jrdev, edesc, req);\r\nkfree(edesc);\r\nreturn ret;\r\n}\r\nstatic int caam_rsa_dec_priv_f3(struct akcipher_request *req)\r\n{\r\nstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\r\nstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx(tfm);\r\nstruct device *jrdev = ctx->dev;\r\nstruct rsa_edesc *edesc;\r\nint ret;\r\nedesc = rsa_edesc_alloc(req, DESC_RSA_PRIV_F3_LEN);\r\nif (IS_ERR(edesc))\r\nreturn PTR_ERR(edesc);\r\nret = set_rsa_priv_f3_pdb(req, edesc);\r\nif (ret)\r\ngoto init_fail;\r\ninit_rsa_priv_f3_desc(edesc->hw_desc, &edesc->pdb.priv_f3);\r\nret = caam_jr_enqueue(jrdev, edesc->hw_desc, rsa_priv_f3_done, req);\r\nif (!ret)\r\nreturn -EINPROGRESS;\r\nrsa_priv_f3_unmap(jrdev, edesc, req);\r\ninit_fail:\r\nrsa_io_unmap(jrdev, edesc, req);\r\nkfree(edesc);\r\nreturn ret;\r\n}\r\nstatic int caam_rsa_dec(struct akcipher_request *req)\r\n{\r\nstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\r\nstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx(tfm);\r\nstruct caam_rsa_key *key = &ctx->key;\r\nint ret;\r\nif (unlikely(!key->n || !key->d))\r\nreturn -EINVAL;\r\nif (req->dst_len < key->n_sz) {\r\nreq->dst_len = key->n_sz;\r\ndev_err(ctx->dev, "Output buffer length less than parameter n\n");\r\nreturn -EOVERFLOW;\r\n}\r\nif (key->priv_form == FORM3)\r\nret = caam_rsa_dec_priv_f3(req);\r\nelse if (key->priv_form == FORM2)\r\nret = caam_rsa_dec_priv_f2(req);\r\nelse\r\nret = caam_rsa_dec_priv_f1(req);\r\nreturn ret;\r\n}\r\nstatic void caam_rsa_free_key(struct caam_rsa_key *key)\r\n{\r\nkzfree(key->d);\r\nkzfree(key->p);\r\nkzfree(key->q);\r\nkzfree(key->dp);\r\nkzfree(key->dq);\r\nkzfree(key->qinv);\r\nkzfree(key->tmp1);\r\nkzfree(key->tmp2);\r\nkfree(key->e);\r\nkfree(key->n);\r\nmemset(key, 0, sizeof(*key));\r\n}\r\nstatic void caam_rsa_drop_leading_zeros(const u8 **ptr, size_t *nbytes)\r\n{\r\nwhile (!**ptr && *nbytes) {\r\n(*ptr)++;\r\n(*nbytes)--;\r\n}\r\n}\r\nstatic u8 *caam_read_rsa_crt(const u8 *ptr, size_t nbytes, size_t dstlen)\r\n{\r\nu8 *dst;\r\ncaam_rsa_drop_leading_zeros(&ptr, &nbytes);\r\nif (!nbytes)\r\nreturn NULL;\r\ndst = kzalloc(dstlen, GFP_DMA | GFP_KERNEL);\r\nif (!dst)\r\nreturn NULL;\r\nmemcpy(dst + (dstlen - nbytes), ptr, nbytes);\r\nreturn dst;\r\n}\r\nstatic inline u8 *caam_read_raw_data(const u8 *buf, size_t *nbytes)\r\n{\r\nu8 *val;\r\ncaam_rsa_drop_leading_zeros(&buf, nbytes);\r\nif (!*nbytes)\r\nreturn NULL;\r\nval = kzalloc(*nbytes, GFP_DMA | GFP_KERNEL);\r\nif (!val)\r\nreturn NULL;\r\nmemcpy(val, buf, *nbytes);\r\nreturn val;\r\n}\r\nstatic int caam_rsa_check_key_length(unsigned int len)\r\n{\r\nif (len > 4096)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int caam_rsa_set_pub_key(struct crypto_akcipher *tfm, const void *key,\r\nunsigned int keylen)\r\n{\r\nstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx(tfm);\r\nstruct rsa_key raw_key = {NULL};\r\nstruct caam_rsa_key *rsa_key = &ctx->key;\r\nint ret;\r\ncaam_rsa_free_key(rsa_key);\r\nret = rsa_parse_pub_key(&raw_key, key, keylen);\r\nif (ret)\r\nreturn ret;\r\nrsa_key->e = kzalloc(raw_key.e_sz, GFP_DMA | GFP_KERNEL);\r\nif (!rsa_key->e)\r\ngoto err;\r\nrsa_key->n = caam_read_raw_data(raw_key.n, &raw_key.n_sz);\r\nif (!rsa_key->n)\r\ngoto err;\r\nif (caam_rsa_check_key_length(raw_key.n_sz << 3)) {\r\ncaam_rsa_free_key(rsa_key);\r\nreturn -EINVAL;\r\n}\r\nrsa_key->e_sz = raw_key.e_sz;\r\nrsa_key->n_sz = raw_key.n_sz;\r\nmemcpy(rsa_key->e, raw_key.e, raw_key.e_sz);\r\nreturn 0;\r\nerr:\r\ncaam_rsa_free_key(rsa_key);\r\nreturn -ENOMEM;\r\n}\r\nstatic void caam_rsa_set_priv_key_form(struct caam_rsa_ctx *ctx,\r\nstruct rsa_key *raw_key)\r\n{\r\nstruct caam_rsa_key *rsa_key = &ctx->key;\r\nsize_t p_sz = raw_key->p_sz;\r\nsize_t q_sz = raw_key->q_sz;\r\nrsa_key->p = caam_read_raw_data(raw_key->p, &p_sz);\r\nif (!rsa_key->p)\r\nreturn;\r\nrsa_key->p_sz = p_sz;\r\nrsa_key->q = caam_read_raw_data(raw_key->q, &q_sz);\r\nif (!rsa_key->q)\r\ngoto free_p;\r\nrsa_key->q_sz = q_sz;\r\nrsa_key->tmp1 = kzalloc(raw_key->p_sz, GFP_DMA | GFP_KERNEL);\r\nif (!rsa_key->tmp1)\r\ngoto free_q;\r\nrsa_key->tmp2 = kzalloc(raw_key->q_sz, GFP_DMA | GFP_KERNEL);\r\nif (!rsa_key->tmp2)\r\ngoto free_tmp1;\r\nrsa_key->priv_form = FORM2;\r\nrsa_key->dp = caam_read_rsa_crt(raw_key->dp, raw_key->dp_sz, p_sz);\r\nif (!rsa_key->dp)\r\ngoto free_tmp2;\r\nrsa_key->dq = caam_read_rsa_crt(raw_key->dq, raw_key->dq_sz, q_sz);\r\nif (!rsa_key->dq)\r\ngoto free_dp;\r\nrsa_key->qinv = caam_read_rsa_crt(raw_key->qinv, raw_key->qinv_sz,\r\nq_sz);\r\nif (!rsa_key->qinv)\r\ngoto free_dq;\r\nrsa_key->priv_form = FORM3;\r\nreturn;\r\nfree_dq:\r\nkzfree(rsa_key->dq);\r\nfree_dp:\r\nkzfree(rsa_key->dp);\r\nfree_tmp2:\r\nkzfree(rsa_key->tmp2);\r\nfree_tmp1:\r\nkzfree(rsa_key->tmp1);\r\nfree_q:\r\nkzfree(rsa_key->q);\r\nfree_p:\r\nkzfree(rsa_key->p);\r\n}\r\nstatic int caam_rsa_set_priv_key(struct crypto_akcipher *tfm, const void *key,\r\nunsigned int keylen)\r\n{\r\nstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx(tfm);\r\nstruct rsa_key raw_key = {NULL};\r\nstruct caam_rsa_key *rsa_key = &ctx->key;\r\nint ret;\r\ncaam_rsa_free_key(rsa_key);\r\nret = rsa_parse_priv_key(&raw_key, key, keylen);\r\nif (ret)\r\nreturn ret;\r\nrsa_key->d = kzalloc(raw_key.d_sz, GFP_DMA | GFP_KERNEL);\r\nif (!rsa_key->d)\r\ngoto err;\r\nrsa_key->e = kzalloc(raw_key.e_sz, GFP_DMA | GFP_KERNEL);\r\nif (!rsa_key->e)\r\ngoto err;\r\nrsa_key->n = caam_read_raw_data(raw_key.n, &raw_key.n_sz);\r\nif (!rsa_key->n)\r\ngoto err;\r\nif (caam_rsa_check_key_length(raw_key.n_sz << 3)) {\r\ncaam_rsa_free_key(rsa_key);\r\nreturn -EINVAL;\r\n}\r\nrsa_key->d_sz = raw_key.d_sz;\r\nrsa_key->e_sz = raw_key.e_sz;\r\nrsa_key->n_sz = raw_key.n_sz;\r\nmemcpy(rsa_key->d, raw_key.d, raw_key.d_sz);\r\nmemcpy(rsa_key->e, raw_key.e, raw_key.e_sz);\r\ncaam_rsa_set_priv_key_form(ctx, &raw_key);\r\nreturn 0;\r\nerr:\r\ncaam_rsa_free_key(rsa_key);\r\nreturn -ENOMEM;\r\n}\r\nstatic unsigned int caam_rsa_max_size(struct crypto_akcipher *tfm)\r\n{\r\nstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx(tfm);\r\nreturn ctx->key.n_sz;\r\n}\r\nstatic int caam_rsa_init_tfm(struct crypto_akcipher *tfm)\r\n{\r\nstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx(tfm);\r\nctx->dev = caam_jr_alloc();\r\nif (IS_ERR(ctx->dev)) {\r\npr_err("Job Ring Device allocation for transform failed\n");\r\nreturn PTR_ERR(ctx->dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic void caam_rsa_exit_tfm(struct crypto_akcipher *tfm)\r\n{\r\nstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx(tfm);\r\nstruct caam_rsa_key *key = &ctx->key;\r\ncaam_rsa_free_key(key);\r\ncaam_jr_free(ctx->dev);\r\n}\r\nstatic int __init caam_pkc_init(void)\r\n{\r\nstruct device_node *dev_node;\r\nstruct platform_device *pdev;\r\nstruct device *ctrldev;\r\nstruct caam_drv_private *priv;\r\nu32 cha_inst, pk_inst;\r\nint err;\r\ndev_node = of_find_compatible_node(NULL, NULL, "fsl,sec-v4.0");\r\nif (!dev_node) {\r\ndev_node = of_find_compatible_node(NULL, NULL, "fsl,sec4.0");\r\nif (!dev_node)\r\nreturn -ENODEV;\r\n}\r\npdev = of_find_device_by_node(dev_node);\r\nif (!pdev) {\r\nof_node_put(dev_node);\r\nreturn -ENODEV;\r\n}\r\nctrldev = &pdev->dev;\r\npriv = dev_get_drvdata(ctrldev);\r\nof_node_put(dev_node);\r\nif (!priv)\r\nreturn -ENODEV;\r\ncha_inst = rd_reg32(&priv->ctrl->perfmon.cha_num_ls);\r\npk_inst = (cha_inst & CHA_ID_LS_PK_MASK) >> CHA_ID_LS_PK_SHIFT;\r\nif (!pk_inst)\r\nreturn -ENODEV;\r\nerr = crypto_register_akcipher(&caam_rsa);\r\nif (err)\r\ndev_warn(ctrldev, "%s alg registration failed\n",\r\ncaam_rsa.base.cra_driver_name);\r\nelse\r\ndev_info(ctrldev, "caam pkc algorithms registered in /proc/crypto\n");\r\nreturn err;\r\n}\r\nstatic void __exit caam_pkc_exit(void)\r\n{\r\ncrypto_unregister_akcipher(&caam_rsa);\r\n}
