static int e1000e_phc_adjfreq(struct ptp_clock_info *ptp, s32 delta)\r\n{\r\nstruct e1000_adapter *adapter = container_of(ptp, struct e1000_adapter,\r\nptp_clock_info);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nbool neg_adj = false;\r\nunsigned long flags;\r\nu64 adjustment;\r\nu32 timinca, incvalue;\r\ns32 ret_val;\r\nif ((delta > ptp->max_adj) || (delta <= -1000000000))\r\nreturn -EINVAL;\r\nif (delta < 0) {\r\nneg_adj = true;\r\ndelta = -delta;\r\n}\r\nret_val = e1000e_get_base_timinca(adapter, &timinca);\r\nif (ret_val)\r\nreturn ret_val;\r\nspin_lock_irqsave(&adapter->systim_lock, flags);\r\nincvalue = timinca & E1000_TIMINCA_INCVALUE_MASK;\r\nadjustment = incvalue;\r\nadjustment *= delta;\r\nadjustment = div_u64(adjustment, 1000000000);\r\nincvalue = neg_adj ? (incvalue - adjustment) : (incvalue + adjustment);\r\ntiminca &= ~E1000_TIMINCA_INCVALUE_MASK;\r\ntiminca |= incvalue;\r\new32(TIMINCA, timinca);\r\nadapter->ptp_delta = delta;\r\nspin_unlock_irqrestore(&adapter->systim_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int e1000e_phc_adjtime(struct ptp_clock_info *ptp, s64 delta)\r\n{\r\nstruct e1000_adapter *adapter = container_of(ptp, struct e1000_adapter,\r\nptp_clock_info);\r\nunsigned long flags;\r\nspin_lock_irqsave(&adapter->systim_lock, flags);\r\ntimecounter_adjtime(&adapter->tc, delta);\r\nspin_unlock_irqrestore(&adapter->systim_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int e1000e_phc_get_syncdevicetime(ktime_t *device,\r\nstruct system_counterval_t *system,\r\nvoid *ctx)\r\n{\r\nstruct e1000_adapter *adapter = (struct e1000_adapter *)ctx;\r\nstruct e1000_hw *hw = &adapter->hw;\r\nunsigned long flags;\r\nint i;\r\nu32 tsync_ctrl;\r\nu64 dev_cycles;\r\nu64 sys_cycles;\r\ntsync_ctrl = er32(TSYNCTXCTL);\r\ntsync_ctrl |= E1000_TSYNCTXCTL_START_SYNC |\r\nE1000_TSYNCTXCTL_MAX_ALLOWED_DLY_MASK;\r\new32(TSYNCTXCTL, tsync_ctrl);\r\nfor (i = 0; i < MAX_HW_WAIT_COUNT; ++i) {\r\nudelay(1);\r\ntsync_ctrl = er32(TSYNCTXCTL);\r\nif (tsync_ctrl & E1000_TSYNCTXCTL_SYNC_COMP)\r\nbreak;\r\n}\r\nif (i == MAX_HW_WAIT_COUNT)\r\nreturn -ETIMEDOUT;\r\ndev_cycles = er32(SYSSTMPH);\r\ndev_cycles <<= 32;\r\ndev_cycles |= er32(SYSSTMPL);\r\nspin_lock_irqsave(&adapter->systim_lock, flags);\r\n*device = ns_to_ktime(timecounter_cyc2time(&adapter->tc, dev_cycles));\r\nspin_unlock_irqrestore(&adapter->systim_lock, flags);\r\nsys_cycles = er32(PLTSTMPH);\r\nsys_cycles <<= 32;\r\nsys_cycles |= er32(PLTSTMPL);\r\n*system = convert_art_to_tsc(sys_cycles);\r\nreturn 0;\r\n}\r\nstatic int e1000e_phc_getcrosststamp(struct ptp_clock_info *ptp,\r\nstruct system_device_crosststamp *xtstamp)\r\n{\r\nstruct e1000_adapter *adapter = container_of(ptp, struct e1000_adapter,\r\nptp_clock_info);\r\nreturn get_device_system_crosststamp(e1000e_phc_get_syncdevicetime,\r\nadapter, NULL, xtstamp);\r\n}\r\nstatic int e1000e_phc_gettime(struct ptp_clock_info *ptp, struct timespec64 *ts)\r\n{\r\nstruct e1000_adapter *adapter = container_of(ptp, struct e1000_adapter,\r\nptp_clock_info);\r\nunsigned long flags;\r\nu64 ns;\r\nspin_lock_irqsave(&adapter->systim_lock, flags);\r\nns = timecounter_read(&adapter->tc);\r\nspin_unlock_irqrestore(&adapter->systim_lock, flags);\r\n*ts = ns_to_timespec64(ns);\r\nreturn 0;\r\n}\r\nstatic int e1000e_phc_settime(struct ptp_clock_info *ptp,\r\nconst struct timespec64 *ts)\r\n{\r\nstruct e1000_adapter *adapter = container_of(ptp, struct e1000_adapter,\r\nptp_clock_info);\r\nunsigned long flags;\r\nu64 ns;\r\nns = timespec64_to_ns(ts);\r\nspin_lock_irqsave(&adapter->systim_lock, flags);\r\ntimecounter_init(&adapter->tc, &adapter->cc, ns);\r\nspin_unlock_irqrestore(&adapter->systim_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int e1000e_phc_enable(struct ptp_clock_info __always_unused *ptp,\r\nstruct ptp_clock_request __always_unused *request,\r\nint __always_unused on)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic void e1000e_systim_overflow_work(struct work_struct *work)\r\n{\r\nstruct e1000_adapter *adapter = container_of(work, struct e1000_adapter,\r\nsystim_overflow_work.work);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nstruct timespec64 ts;\r\nadapter->ptp_clock_info.gettime64(&adapter->ptp_clock_info, &ts);\r\ne_dbg("SYSTIM overflow check at %lld.%09lu\n",\r\n(long long) ts.tv_sec, ts.tv_nsec);\r\nschedule_delayed_work(&adapter->systim_overflow_work,\r\nE1000_SYSTIM_OVERFLOW_PERIOD);\r\n}\r\nvoid e1000e_ptp_init(struct e1000_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nadapter->ptp_clock = NULL;\r\nif (!(adapter->flags & FLAG_HAS_HW_TIMESTAMP))\r\nreturn;\r\nadapter->ptp_clock_info = e1000e_ptp_clock_info;\r\nsnprintf(adapter->ptp_clock_info.name,\r\nsizeof(adapter->ptp_clock_info.name), "%pm",\r\nadapter->netdev->perm_addr);\r\nswitch (hw->mac.type) {\r\ncase e1000_pch2lan:\r\ncase e1000_pch_lpt:\r\ncase e1000_pch_spt:\r\ncase e1000_pch_cnp:\r\nif ((hw->mac.type < e1000_pch_lpt) ||\r\n(er32(TSYNCRXCTL) & E1000_TSYNCRXCTL_SYSCFI)) {\r\nadapter->ptp_clock_info.max_adj = 24000000 - 1;\r\nbreak;\r\n}\r\ncase e1000_82574:\r\ncase e1000_82583:\r\nadapter->ptp_clock_info.max_adj = 600000000 - 1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n#ifdef CONFIG_E1000E_HWTS\r\nif (hw->mac.type >= e1000_pch_spt && boot_cpu_has(X86_FEATURE_ART))\r\nadapter->ptp_clock_info.getcrosststamp =\r\ne1000e_phc_getcrosststamp;\r\n#endif\r\nINIT_DELAYED_WORK(&adapter->systim_overflow_work,\r\ne1000e_systim_overflow_work);\r\nschedule_delayed_work(&adapter->systim_overflow_work,\r\nE1000_SYSTIM_OVERFLOW_PERIOD);\r\nadapter->ptp_clock = ptp_clock_register(&adapter->ptp_clock_info,\r\n&adapter->pdev->dev);\r\nif (IS_ERR(adapter->ptp_clock)) {\r\nadapter->ptp_clock = NULL;\r\ne_err("ptp_clock_register failed\n");\r\n} else if (adapter->ptp_clock) {\r\ne_info("registered PHC clock\n");\r\n}\r\n}\r\nvoid e1000e_ptp_remove(struct e1000_adapter *adapter)\r\n{\r\nif (!(adapter->flags & FLAG_HAS_HW_TIMESTAMP))\r\nreturn;\r\ncancel_delayed_work_sync(&adapter->systim_overflow_work);\r\nif (adapter->ptp_clock) {\r\nptp_clock_unregister(adapter->ptp_clock);\r\nadapter->ptp_clock = NULL;\r\ne_info("removed PHC\n");\r\n}\r\n}
