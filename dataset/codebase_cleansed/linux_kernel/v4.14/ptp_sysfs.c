static ssize_t clock_name_show(struct device *dev,\r\nstruct device_attribute *attr, char *page)\r\n{\r\nstruct ptp_clock *ptp = dev_get_drvdata(dev);\r\nreturn snprintf(page, PAGE_SIZE-1, "%s\n", ptp->info->name);\r\n}\r\nstatic ssize_t extts_enable_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ptp_clock *ptp = dev_get_drvdata(dev);\r\nstruct ptp_clock_info *ops = ptp->info;\r\nstruct ptp_clock_request req = { .type = PTP_CLK_REQ_EXTTS };\r\nint cnt, enable;\r\nint err = -EINVAL;\r\ncnt = sscanf(buf, "%u %d", &req.extts.index, &enable);\r\nif (cnt != 2)\r\ngoto out;\r\nif (req.extts.index >= ops->n_ext_ts)\r\ngoto out;\r\nerr = ops->enable(ops, &req, enable ? 1 : 0);\r\nif (err)\r\ngoto out;\r\nreturn count;\r\nout:\r\nreturn err;\r\n}\r\nstatic ssize_t extts_fifo_show(struct device *dev,\r\nstruct device_attribute *attr, char *page)\r\n{\r\nstruct ptp_clock *ptp = dev_get_drvdata(dev);\r\nstruct timestamp_event_queue *queue = &ptp->tsevq;\r\nstruct ptp_extts_event event;\r\nunsigned long flags;\r\nsize_t qcnt;\r\nint cnt = 0;\r\nmemset(&event, 0, sizeof(event));\r\nif (mutex_lock_interruptible(&ptp->tsevq_mux))\r\nreturn -ERESTARTSYS;\r\nspin_lock_irqsave(&queue->lock, flags);\r\nqcnt = queue_cnt(queue);\r\nif (qcnt) {\r\nevent = queue->buf[queue->head];\r\nqueue->head = (queue->head + 1) % PTP_MAX_TIMESTAMPS;\r\n}\r\nspin_unlock_irqrestore(&queue->lock, flags);\r\nif (!qcnt)\r\ngoto out;\r\ncnt = snprintf(page, PAGE_SIZE, "%u %lld %u\n",\r\nevent.index, event.t.sec, event.t.nsec);\r\nout:\r\nmutex_unlock(&ptp->tsevq_mux);\r\nreturn cnt;\r\n}\r\nstatic ssize_t period_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ptp_clock *ptp = dev_get_drvdata(dev);\r\nstruct ptp_clock_info *ops = ptp->info;\r\nstruct ptp_clock_request req = { .type = PTP_CLK_REQ_PEROUT };\r\nint cnt, enable, err = -EINVAL;\r\ncnt = sscanf(buf, "%u %lld %u %lld %u", &req.perout.index,\r\n&req.perout.start.sec, &req.perout.start.nsec,\r\n&req.perout.period.sec, &req.perout.period.nsec);\r\nif (cnt != 5)\r\ngoto out;\r\nif (req.perout.index >= ops->n_per_out)\r\ngoto out;\r\nenable = req.perout.period.sec || req.perout.period.nsec;\r\nerr = ops->enable(ops, &req, enable);\r\nif (err)\r\ngoto out;\r\nreturn count;\r\nout:\r\nreturn err;\r\n}\r\nstatic ssize_t pps_enable_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ptp_clock *ptp = dev_get_drvdata(dev);\r\nstruct ptp_clock_info *ops = ptp->info;\r\nstruct ptp_clock_request req = { .type = PTP_CLK_REQ_PPS };\r\nint cnt, enable;\r\nint err = -EINVAL;\r\nif (!capable(CAP_SYS_TIME))\r\nreturn -EPERM;\r\ncnt = sscanf(buf, "%d", &enable);\r\nif (cnt != 1)\r\ngoto out;\r\nerr = ops->enable(ops, &req, enable ? 1 : 0);\r\nif (err)\r\ngoto out;\r\nreturn count;\r\nout:\r\nreturn err;\r\n}\r\nstatic umode_t ptp_is_attribute_visible(struct kobject *kobj,\r\nstruct attribute *attr, int n)\r\n{\r\nstruct device *dev = kobj_to_dev(kobj);\r\nstruct ptp_clock *ptp = dev_get_drvdata(dev);\r\nstruct ptp_clock_info *info = ptp->info;\r\numode_t mode = attr->mode;\r\nif (attr == &dev_attr_extts_enable.attr ||\r\nattr == &dev_attr_fifo.attr) {\r\nif (!info->n_ext_ts)\r\nmode = 0;\r\n} else if (attr == &dev_attr_period.attr) {\r\nif (!info->n_per_out)\r\nmode = 0;\r\n} else if (attr == &dev_attr_pps_enable.attr) {\r\nif (!info->pps)\r\nmode = 0;\r\n}\r\nreturn mode;\r\n}\r\nstatic int ptp_pin_name2index(struct ptp_clock *ptp, const char *name)\r\n{\r\nint i;\r\nfor (i = 0; i < ptp->info->n_pins; i++) {\r\nif (!strcmp(ptp->info->pin_config[i].name, name))\r\nreturn i;\r\n}\r\nreturn -1;\r\n}\r\nstatic ssize_t ptp_pin_show(struct device *dev, struct device_attribute *attr,\r\nchar *page)\r\n{\r\nstruct ptp_clock *ptp = dev_get_drvdata(dev);\r\nunsigned int func, chan;\r\nint index;\r\nindex = ptp_pin_name2index(ptp, attr->attr.name);\r\nif (index < 0)\r\nreturn -EINVAL;\r\nif (mutex_lock_interruptible(&ptp->pincfg_mux))\r\nreturn -ERESTARTSYS;\r\nfunc = ptp->info->pin_config[index].func;\r\nchan = ptp->info->pin_config[index].chan;\r\nmutex_unlock(&ptp->pincfg_mux);\r\nreturn snprintf(page, PAGE_SIZE, "%u %u\n", func, chan);\r\n}\r\nstatic ssize_t ptp_pin_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ptp_clock *ptp = dev_get_drvdata(dev);\r\nunsigned int func, chan;\r\nint cnt, err, index;\r\ncnt = sscanf(buf, "%u %u", &func, &chan);\r\nif (cnt != 2)\r\nreturn -EINVAL;\r\nindex = ptp_pin_name2index(ptp, attr->attr.name);\r\nif (index < 0)\r\nreturn -EINVAL;\r\nif (mutex_lock_interruptible(&ptp->pincfg_mux))\r\nreturn -ERESTARTSYS;\r\nerr = ptp_set_pinfunc(ptp, index, func, chan);\r\nmutex_unlock(&ptp->pincfg_mux);\r\nif (err)\r\nreturn err;\r\nreturn count;\r\n}\r\nint ptp_populate_pin_groups(struct ptp_clock *ptp)\r\n{\r\nstruct ptp_clock_info *info = ptp->info;\r\nint err = -ENOMEM, i, n_pins = info->n_pins;\r\nif (!n_pins)\r\nreturn 0;\r\nptp->pin_dev_attr = kcalloc(n_pins, sizeof(*ptp->pin_dev_attr),\r\nGFP_KERNEL);\r\nif (!ptp->pin_dev_attr)\r\ngoto no_dev_attr;\r\nptp->pin_attr = kcalloc(1 + n_pins, sizeof(*ptp->pin_attr), GFP_KERNEL);\r\nif (!ptp->pin_attr)\r\ngoto no_pin_attr;\r\nfor (i = 0; i < n_pins; i++) {\r\nstruct device_attribute *da = &ptp->pin_dev_attr[i];\r\nsysfs_attr_init(&da->attr);\r\nda->attr.name = info->pin_config[i].name;\r\nda->attr.mode = 0644;\r\nda->show = ptp_pin_show;\r\nda->store = ptp_pin_store;\r\nptp->pin_attr[i] = &da->attr;\r\n}\r\nptp->pin_attr_group.name = "pins";\r\nptp->pin_attr_group.attrs = ptp->pin_attr;\r\nptp->pin_attr_groups[0] = &ptp->pin_attr_group;\r\nreturn 0;\r\nno_pin_attr:\r\nkfree(ptp->pin_dev_attr);\r\nno_dev_attr:\r\nreturn err;\r\n}\r\nvoid ptp_cleanup_pin_groups(struct ptp_clock *ptp)\r\n{\r\nkfree(ptp->pin_attr);\r\nkfree(ptp->pin_dev_attr);\r\n}
