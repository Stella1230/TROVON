static bool bcm2835_wdt_is_running(struct bcm2835_wdt *wdt)\r\n{\r\nuint32_t cur;\r\ncur = readl(wdt->base + PM_RSTC);\r\nreturn !!(cur & PM_RSTC_WRCFG_FULL_RESET);\r\n}\r\nstatic int bcm2835_wdt_start(struct watchdog_device *wdog)\r\n{\r\nstruct bcm2835_wdt *wdt = watchdog_get_drvdata(wdog);\r\nuint32_t cur;\r\nunsigned long flags;\r\nspin_lock_irqsave(&wdt->lock, flags);\r\nwritel_relaxed(PM_PASSWORD | (SECS_TO_WDOG_TICKS(wdog->timeout) &\r\nPM_WDOG_TIME_SET), wdt->base + PM_WDOG);\r\ncur = readl_relaxed(wdt->base + PM_RSTC);\r\nwritel_relaxed(PM_PASSWORD | (cur & PM_RSTC_WRCFG_CLR) |\r\nPM_RSTC_WRCFG_FULL_RESET, wdt->base + PM_RSTC);\r\nspin_unlock_irqrestore(&wdt->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int bcm2835_wdt_stop(struct watchdog_device *wdog)\r\n{\r\nstruct bcm2835_wdt *wdt = watchdog_get_drvdata(wdog);\r\nwritel_relaxed(PM_PASSWORD | PM_RSTC_RESET, wdt->base + PM_RSTC);\r\nreturn 0;\r\n}\r\nstatic unsigned int bcm2835_wdt_get_timeleft(struct watchdog_device *wdog)\r\n{\r\nstruct bcm2835_wdt *wdt = watchdog_get_drvdata(wdog);\r\nuint32_t ret = readl_relaxed(wdt->base + PM_WDOG);\r\nreturn WDOG_TICKS_TO_SECS(ret & PM_WDOG_TIME_SET);\r\n}\r\nstatic void __bcm2835_restart(struct bcm2835_wdt *wdt)\r\n{\r\nu32 val;\r\nwritel_relaxed(10 | PM_PASSWORD, wdt->base + PM_WDOG);\r\nval = readl_relaxed(wdt->base + PM_RSTC);\r\nval &= PM_RSTC_WRCFG_CLR;\r\nval |= PM_PASSWORD | PM_RSTC_WRCFG_FULL_RESET;\r\nwritel_relaxed(val, wdt->base + PM_RSTC);\r\nmdelay(1);\r\n}\r\nstatic int bcm2835_restart(struct watchdog_device *wdog,\r\nunsigned long action, void *data)\r\n{\r\nstruct bcm2835_wdt *wdt = watchdog_get_drvdata(wdog);\r\n__bcm2835_restart(wdt);\r\nreturn 0;\r\n}\r\nstatic void bcm2835_power_off(void)\r\n{\r\nstruct device_node *np =\r\nof_find_compatible_node(NULL, NULL, "brcm,bcm2835-pm-wdt");\r\nstruct platform_device *pdev = of_find_device_by_node(np);\r\nstruct bcm2835_wdt *wdt = platform_get_drvdata(pdev);\r\nu32 val;\r\nval = readl_relaxed(wdt->base + PM_RSTS);\r\nval |= PM_PASSWORD | PM_RSTS_RASPBERRYPI_HALT;\r\nwritel_relaxed(val, wdt->base + PM_RSTS);\r\n__bcm2835_restart(wdt);\r\n}\r\nstatic int bcm2835_wdt_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct device *dev = &pdev->dev;\r\nstruct bcm2835_wdt *wdt;\r\nint err;\r\nwdt = devm_kzalloc(dev, sizeof(struct bcm2835_wdt), GFP_KERNEL);\r\nif (!wdt)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, wdt);\r\nspin_lock_init(&wdt->lock);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nwdt->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(wdt->base))\r\nreturn PTR_ERR(wdt->base);\r\nwatchdog_set_drvdata(&bcm2835_wdt_wdd, wdt);\r\nwatchdog_init_timeout(&bcm2835_wdt_wdd, heartbeat, dev);\r\nwatchdog_set_nowayout(&bcm2835_wdt_wdd, nowayout);\r\nbcm2835_wdt_wdd.parent = dev;\r\nif (bcm2835_wdt_is_running(wdt)) {\r\nset_bit(WDOG_HW_RUNNING, &bcm2835_wdt_wdd.status);\r\n}\r\nwatchdog_set_restart_priority(&bcm2835_wdt_wdd, 128);\r\nwatchdog_stop_on_reboot(&bcm2835_wdt_wdd);\r\nerr = devm_watchdog_register_device(dev, &bcm2835_wdt_wdd);\r\nif (err) {\r\ndev_err(dev, "Failed to register watchdog device");\r\nreturn err;\r\n}\r\nif (pm_power_off == NULL)\r\npm_power_off = bcm2835_power_off;\r\ndev_info(dev, "Broadcom BCM2835 watchdog timer");\r\nreturn 0;\r\n}\r\nstatic int bcm2835_wdt_remove(struct platform_device *pdev)\r\n{\r\nif (pm_power_off == bcm2835_power_off)\r\npm_power_off = NULL;\r\nreturn 0;\r\n}
