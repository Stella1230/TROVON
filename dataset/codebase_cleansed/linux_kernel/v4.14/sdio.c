static int sdio_read_fbr(struct sdio_func *func)\r\n{\r\nint ret;\r\nunsigned char data;\r\nif (mmc_card_nonstd_func_interface(func->card)) {\r\nfunc->class = SDIO_CLASS_NONE;\r\nreturn 0;\r\n}\r\nret = mmc_io_rw_direct(func->card, 0, 0,\r\nSDIO_FBR_BASE(func->num) + SDIO_FBR_STD_IF, 0, &data);\r\nif (ret)\r\ngoto out;\r\ndata &= 0x0f;\r\nif (data == 0x0f) {\r\nret = mmc_io_rw_direct(func->card, 0, 0,\r\nSDIO_FBR_BASE(func->num) + SDIO_FBR_STD_IF_EXT, 0, &data);\r\nif (ret)\r\ngoto out;\r\n}\r\nfunc->class = data;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int sdio_init_func(struct mmc_card *card, unsigned int fn)\r\n{\r\nint ret;\r\nstruct sdio_func *func;\r\nif (WARN_ON(fn > SDIO_MAX_FUNCS))\r\nreturn -EINVAL;\r\nfunc = sdio_alloc_func(card);\r\nif (IS_ERR(func))\r\nreturn PTR_ERR(func);\r\nfunc->num = fn;\r\nif (!(card->quirks & MMC_QUIRK_NONSTD_SDIO)) {\r\nret = sdio_read_fbr(func);\r\nif (ret)\r\ngoto fail;\r\nret = sdio_read_func_cis(func);\r\nif (ret)\r\ngoto fail;\r\n} else {\r\nfunc->vendor = func->card->cis.vendor;\r\nfunc->device = func->card->cis.device;\r\nfunc->max_blksize = func->card->cis.blksize;\r\n}\r\ncard->sdio_func[fn - 1] = func;\r\nreturn 0;\r\nfail:\r\nsdio_remove_func(func);\r\nreturn ret;\r\n}\r\nstatic int sdio_read_cccr(struct mmc_card *card, u32 ocr)\r\n{\r\nint ret;\r\nint cccr_vsn;\r\nint uhs = ocr & R4_18V_PRESENT;\r\nunsigned char data;\r\nunsigned char speed;\r\nret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_CCCR, 0, &data);\r\nif (ret)\r\ngoto out;\r\ncccr_vsn = data & 0x0f;\r\nif (cccr_vsn > SDIO_CCCR_REV_3_00) {\r\npr_err("%s: unrecognised CCCR structure version %d\n",\r\nmmc_hostname(card->host), cccr_vsn);\r\nreturn -EINVAL;\r\n}\r\ncard->cccr.sdio_vsn = (data & 0xf0) >> 4;\r\nret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_CAPS, 0, &data);\r\nif (ret)\r\ngoto out;\r\nif (data & SDIO_CCCR_CAP_SMB)\r\ncard->cccr.multi_block = 1;\r\nif (data & SDIO_CCCR_CAP_LSC)\r\ncard->cccr.low_speed = 1;\r\nif (data & SDIO_CCCR_CAP_4BLS)\r\ncard->cccr.wide_bus = 1;\r\nif (cccr_vsn >= SDIO_CCCR_REV_1_10) {\r\nret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_POWER, 0, &data);\r\nif (ret)\r\ngoto out;\r\nif (data & SDIO_POWER_SMPC)\r\ncard->cccr.high_power = 1;\r\n}\r\nif (cccr_vsn >= SDIO_CCCR_REV_1_20) {\r\nret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_SPEED, 0, &speed);\r\nif (ret)\r\ngoto out;\r\ncard->scr.sda_spec3 = 0;\r\ncard->sw_caps.sd3_bus_mode = 0;\r\ncard->sw_caps.sd3_drv_type = 0;\r\nif (cccr_vsn >= SDIO_CCCR_REV_3_00 && uhs) {\r\ncard->scr.sda_spec3 = 1;\r\nret = mmc_io_rw_direct(card, 0, 0,\r\nSDIO_CCCR_UHS, 0, &data);\r\nif (ret)\r\ngoto out;\r\nif (mmc_host_uhs(card->host)) {\r\nif (data & SDIO_UHS_DDR50)\r\ncard->sw_caps.sd3_bus_mode\r\n|= SD_MODE_UHS_DDR50;\r\nif (data & SDIO_UHS_SDR50)\r\ncard->sw_caps.sd3_bus_mode\r\n|= SD_MODE_UHS_SDR50;\r\nif (data & SDIO_UHS_SDR104)\r\ncard->sw_caps.sd3_bus_mode\r\n|= SD_MODE_UHS_SDR104;\r\n}\r\nret = mmc_io_rw_direct(card, 0, 0,\r\nSDIO_CCCR_DRIVE_STRENGTH, 0, &data);\r\nif (ret)\r\ngoto out;\r\nif (data & SDIO_DRIVE_SDTA)\r\ncard->sw_caps.sd3_drv_type |= SD_DRIVER_TYPE_A;\r\nif (data & SDIO_DRIVE_SDTC)\r\ncard->sw_caps.sd3_drv_type |= SD_DRIVER_TYPE_C;\r\nif (data & SDIO_DRIVE_SDTD)\r\ncard->sw_caps.sd3_drv_type |= SD_DRIVER_TYPE_D;\r\n}\r\nif (!card->sw_caps.sd3_bus_mode) {\r\nif (speed & SDIO_SPEED_SHS) {\r\ncard->cccr.high_speed = 1;\r\ncard->sw_caps.hs_max_dtr = 50000000;\r\n} else {\r\ncard->cccr.high_speed = 0;\r\ncard->sw_caps.hs_max_dtr = 25000000;\r\n}\r\n}\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int sdio_enable_wide(struct mmc_card *card)\r\n{\r\nint ret;\r\nu8 ctrl;\r\nif (!(card->host->caps & MMC_CAP_4_BIT_DATA))\r\nreturn 0;\r\nif (card->cccr.low_speed && !card->cccr.wide_bus)\r\nreturn 0;\r\nret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_IF, 0, &ctrl);\r\nif (ret)\r\nreturn ret;\r\nif ((ctrl & SDIO_BUS_WIDTH_MASK) == SDIO_BUS_WIDTH_RESERVED)\r\npr_warn("%s: SDIO_CCCR_IF is invalid: 0x%02x\n",\r\nmmc_hostname(card->host), ctrl);\r\nctrl &= ~SDIO_BUS_WIDTH_MASK;\r\nctrl |= SDIO_BUS_WIDTH_4BIT;\r\nret = mmc_io_rw_direct(card, 1, 0, SDIO_CCCR_IF, ctrl, NULL);\r\nif (ret)\r\nreturn ret;\r\nreturn 1;\r\n}\r\nstatic int sdio_disable_cd(struct mmc_card *card)\r\n{\r\nint ret;\r\nu8 ctrl;\r\nif (!mmc_card_disable_cd(card))\r\nreturn 0;\r\nret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_IF, 0, &ctrl);\r\nif (ret)\r\nreturn ret;\r\nctrl |= SDIO_BUS_CD_DISABLE;\r\nreturn mmc_io_rw_direct(card, 1, 0, SDIO_CCCR_IF, ctrl, NULL);\r\n}\r\nstatic int sdio_disable_wide(struct mmc_card *card)\r\n{\r\nint ret;\r\nu8 ctrl;\r\nif (!(card->host->caps & MMC_CAP_4_BIT_DATA))\r\nreturn 0;\r\nif (card->cccr.low_speed && !card->cccr.wide_bus)\r\nreturn 0;\r\nret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_IF, 0, &ctrl);\r\nif (ret)\r\nreturn ret;\r\nif (!(ctrl & SDIO_BUS_WIDTH_4BIT))\r\nreturn 0;\r\nctrl &= ~SDIO_BUS_WIDTH_4BIT;\r\nctrl |= SDIO_BUS_ASYNC_INT;\r\nret = mmc_io_rw_direct(card, 1, 0, SDIO_CCCR_IF, ctrl, NULL);\r\nif (ret)\r\nreturn ret;\r\nmmc_set_bus_width(card->host, MMC_BUS_WIDTH_1);\r\nreturn 0;\r\n}\r\nstatic int sdio_enable_4bit_bus(struct mmc_card *card)\r\n{\r\nint err;\r\nif (card->type == MMC_TYPE_SDIO)\r\nerr = sdio_enable_wide(card);\r\nelse if ((card->host->caps & MMC_CAP_4_BIT_DATA) &&\r\n(card->scr.bus_widths & SD_SCR_BUS_WIDTH_4)) {\r\nerr = mmc_app_set_bus_width(card, MMC_BUS_WIDTH_4);\r\nif (err)\r\nreturn err;\r\nerr = sdio_enable_wide(card);\r\nif (err <= 0)\r\nmmc_app_set_bus_width(card, MMC_BUS_WIDTH_1);\r\n} else\r\nreturn 0;\r\nif (err > 0) {\r\nmmc_set_bus_width(card->host, MMC_BUS_WIDTH_4);\r\nerr = 0;\r\n}\r\nreturn err;\r\n}\r\nstatic int mmc_sdio_switch_hs(struct mmc_card *card, int enable)\r\n{\r\nint ret;\r\nu8 speed;\r\nif (!(card->host->caps & MMC_CAP_SD_HIGHSPEED))\r\nreturn 0;\r\nif (!card->cccr.high_speed)\r\nreturn 0;\r\nret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_SPEED, 0, &speed);\r\nif (ret)\r\nreturn ret;\r\nif (enable)\r\nspeed |= SDIO_SPEED_EHS;\r\nelse\r\nspeed &= ~SDIO_SPEED_EHS;\r\nret = mmc_io_rw_direct(card, 1, 0, SDIO_CCCR_SPEED, speed, NULL);\r\nif (ret)\r\nreturn ret;\r\nreturn 1;\r\n}\r\nstatic int sdio_enable_hs(struct mmc_card *card)\r\n{\r\nint ret;\r\nret = mmc_sdio_switch_hs(card, true);\r\nif (ret <= 0 || card->type == MMC_TYPE_SDIO)\r\nreturn ret;\r\nret = mmc_sd_switch_hs(card);\r\nif (ret <= 0)\r\nmmc_sdio_switch_hs(card, false);\r\nreturn ret;\r\n}\r\nstatic unsigned mmc_sdio_get_max_clock(struct mmc_card *card)\r\n{\r\nunsigned max_dtr;\r\nif (mmc_card_hs(card)) {\r\nmax_dtr = 50000000;\r\n} else {\r\nmax_dtr = card->cis.max_dtr;\r\n}\r\nif (card->type == MMC_TYPE_SD_COMBO)\r\nmax_dtr = min(max_dtr, mmc_sd_get_max_clock(card));\r\nreturn max_dtr;\r\n}\r\nstatic unsigned char host_drive_to_sdio_drive(int host_strength)\r\n{\r\nswitch (host_strength) {\r\ncase MMC_SET_DRIVER_TYPE_A:\r\nreturn SDIO_DTSx_SET_TYPE_A;\r\ncase MMC_SET_DRIVER_TYPE_B:\r\nreturn SDIO_DTSx_SET_TYPE_B;\r\ncase MMC_SET_DRIVER_TYPE_C:\r\nreturn SDIO_DTSx_SET_TYPE_C;\r\ncase MMC_SET_DRIVER_TYPE_D:\r\nreturn SDIO_DTSx_SET_TYPE_D;\r\ndefault:\r\nreturn SDIO_DTSx_SET_TYPE_B;\r\n}\r\n}\r\nstatic void sdio_select_driver_type(struct mmc_card *card)\r\n{\r\nint card_drv_type, drive_strength, drv_type;\r\nunsigned char card_strength;\r\nint err;\r\ncard->drive_strength = 0;\r\ncard_drv_type = card->sw_caps.sd3_drv_type | SD_DRIVER_TYPE_B;\r\ndrive_strength = mmc_select_drive_strength(card,\r\ncard->sw_caps.uhs_max_dtr,\r\ncard_drv_type, &drv_type);\r\nif (drive_strength) {\r\nerr = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_DRIVE_STRENGTH, 0,\r\n&card_strength);\r\nif (err)\r\nreturn;\r\ncard_strength &= ~(SDIO_DRIVE_DTSx_MASK<<SDIO_DRIVE_DTSx_SHIFT);\r\ncard_strength |= host_drive_to_sdio_drive(drive_strength);\r\nerr = mmc_io_rw_direct(card, 1, 0, SDIO_CCCR_DRIVE_STRENGTH,\r\ncard_strength, NULL);\r\nif (err)\r\nreturn;\r\ncard->drive_strength = drive_strength;\r\n}\r\nif (drv_type)\r\nmmc_set_driver_type(card->host, drv_type);\r\n}\r\nstatic int sdio_set_bus_speed_mode(struct mmc_card *card)\r\n{\r\nunsigned int bus_speed, timing;\r\nint err;\r\nunsigned char speed;\r\nif (!mmc_host_uhs(card->host))\r\nreturn 0;\r\nbus_speed = SDIO_SPEED_SDR12;\r\ntiming = MMC_TIMING_UHS_SDR12;\r\nif ((card->host->caps & MMC_CAP_UHS_SDR104) &&\r\n(card->sw_caps.sd3_bus_mode & SD_MODE_UHS_SDR104)) {\r\nbus_speed = SDIO_SPEED_SDR104;\r\ntiming = MMC_TIMING_UHS_SDR104;\r\ncard->sw_caps.uhs_max_dtr = UHS_SDR104_MAX_DTR;\r\ncard->sd_bus_speed = UHS_SDR104_BUS_SPEED;\r\n} else if ((card->host->caps & MMC_CAP_UHS_DDR50) &&\r\n(card->sw_caps.sd3_bus_mode & SD_MODE_UHS_DDR50)) {\r\nbus_speed = SDIO_SPEED_DDR50;\r\ntiming = MMC_TIMING_UHS_DDR50;\r\ncard->sw_caps.uhs_max_dtr = UHS_DDR50_MAX_DTR;\r\ncard->sd_bus_speed = UHS_DDR50_BUS_SPEED;\r\n} else if ((card->host->caps & (MMC_CAP_UHS_SDR104 |\r\nMMC_CAP_UHS_SDR50)) && (card->sw_caps.sd3_bus_mode &\r\nSD_MODE_UHS_SDR50)) {\r\nbus_speed = SDIO_SPEED_SDR50;\r\ntiming = MMC_TIMING_UHS_SDR50;\r\ncard->sw_caps.uhs_max_dtr = UHS_SDR50_MAX_DTR;\r\ncard->sd_bus_speed = UHS_SDR50_BUS_SPEED;\r\n} else if ((card->host->caps & (MMC_CAP_UHS_SDR104 |\r\nMMC_CAP_UHS_SDR50 | MMC_CAP_UHS_SDR25)) &&\r\n(card->sw_caps.sd3_bus_mode & SD_MODE_UHS_SDR25)) {\r\nbus_speed = SDIO_SPEED_SDR25;\r\ntiming = MMC_TIMING_UHS_SDR25;\r\ncard->sw_caps.uhs_max_dtr = UHS_SDR25_MAX_DTR;\r\ncard->sd_bus_speed = UHS_SDR25_BUS_SPEED;\r\n} else if ((card->host->caps & (MMC_CAP_UHS_SDR104 |\r\nMMC_CAP_UHS_SDR50 | MMC_CAP_UHS_SDR25 |\r\nMMC_CAP_UHS_SDR12)) && (card->sw_caps.sd3_bus_mode &\r\nSD_MODE_UHS_SDR12)) {\r\nbus_speed = SDIO_SPEED_SDR12;\r\ntiming = MMC_TIMING_UHS_SDR12;\r\ncard->sw_caps.uhs_max_dtr = UHS_SDR12_MAX_DTR;\r\ncard->sd_bus_speed = UHS_SDR12_BUS_SPEED;\r\n}\r\nerr = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_SPEED, 0, &speed);\r\nif (err)\r\nreturn err;\r\nspeed &= ~SDIO_SPEED_BSS_MASK;\r\nspeed |= bus_speed;\r\nerr = mmc_io_rw_direct(card, 1, 0, SDIO_CCCR_SPEED, speed, NULL);\r\nif (err)\r\nreturn err;\r\nif (bus_speed) {\r\nmmc_set_timing(card->host, timing);\r\nmmc_set_clock(card->host, card->sw_caps.uhs_max_dtr);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mmc_sdio_init_uhs_card(struct mmc_card *card)\r\n{\r\nint err;\r\nif (!card->scr.sda_spec3)\r\nreturn 0;\r\nif (card->host->caps & MMC_CAP_4_BIT_DATA)\r\nerr = sdio_enable_4bit_bus(card);\r\nsdio_select_driver_type(card);\r\nerr = sdio_set_bus_speed_mode(card);\r\nif (err)\r\ngoto out;\r\nif (!mmc_host_is_spi(card->host) &&\r\n((card->host->ios.timing == MMC_TIMING_UHS_SDR50) ||\r\n(card->host->ios.timing == MMC_TIMING_UHS_SDR104)))\r\nerr = mmc_execute_tuning(card);\r\nout:\r\nreturn err;\r\n}\r\nstatic void mmc_sdio_resend_if_cond(struct mmc_host *host,\r\nstruct mmc_card *card)\r\n{\r\nsdio_reset(host);\r\nmmc_go_idle(host);\r\nmmc_send_if_cond(host, host->ocr_avail);\r\nmmc_remove_card(card);\r\n}\r\nstatic int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,\r\nstruct mmc_card *oldcard, int powered_resume)\r\n{\r\nstruct mmc_card *card;\r\nint err;\r\nint retries = 10;\r\nu32 rocr = 0;\r\nu32 ocr_card = ocr;\r\nWARN_ON(!host->claimed);\r\nif (mmc_host_uhs(host))\r\nocr |= R4_18V_PRESENT;\r\ntry_again:\r\nif (!retries) {\r\npr_warn("%s: Skipping voltage switch\n", mmc_hostname(host));\r\nocr &= ~R4_18V_PRESENT;\r\n}\r\nif (!powered_resume) {\r\nerr = mmc_send_io_op_cond(host, ocr, &rocr);\r\nif (err)\r\ngoto err;\r\n}\r\nif (mmc_host_is_spi(host)) {\r\nerr = mmc_spi_set_crc(host, use_spi_crc);\r\nif (err)\r\ngoto err;\r\n}\r\ncard = mmc_alloc_card(host, NULL);\r\nif (IS_ERR(card)) {\r\nerr = PTR_ERR(card);\r\ngoto err;\r\n}\r\nif ((rocr & R4_MEMORY_PRESENT) &&\r\nmmc_sd_get_cid(host, ocr & rocr, card->raw_cid, NULL) == 0) {\r\ncard->type = MMC_TYPE_SD_COMBO;\r\nif (oldcard && (oldcard->type != MMC_TYPE_SD_COMBO ||\r\nmemcmp(card->raw_cid, oldcard->raw_cid, sizeof(card->raw_cid)) != 0)) {\r\nmmc_remove_card(card);\r\nreturn -ENOENT;\r\n}\r\n} else {\r\ncard->type = MMC_TYPE_SDIO;\r\nif (oldcard && oldcard->type != MMC_TYPE_SDIO) {\r\nmmc_remove_card(card);\r\nreturn -ENOENT;\r\n}\r\n}\r\nif (host->ops->init_card)\r\nhost->ops->init_card(host, card);\r\nif (!powered_resume && (rocr & ocr & R4_18V_PRESENT)) {\r\nerr = mmc_set_uhs_voltage(host, ocr_card);\r\nif (err == -EAGAIN) {\r\nmmc_sdio_resend_if_cond(host, card);\r\nretries--;\r\ngoto try_again;\r\n} else if (err) {\r\nocr &= ~R4_18V_PRESENT;\r\n}\r\n}\r\nif (!powered_resume && !mmc_host_is_spi(host)) {\r\nerr = mmc_send_relative_addr(host, &card->rca);\r\nif (err)\r\ngoto remove;\r\nif (oldcard)\r\noldcard->rca = card->rca;\r\n}\r\nif (!oldcard && card->type == MMC_TYPE_SD_COMBO) {\r\nerr = mmc_sd_get_csd(host, card);\r\nif (err)\r\nreturn err;\r\nmmc_decode_cid(card);\r\n}\r\nif (!powered_resume && !mmc_host_is_spi(host)) {\r\nerr = mmc_select_card(card);\r\nif (err)\r\ngoto remove;\r\n}\r\nif (card->quirks & MMC_QUIRK_NONSTD_SDIO) {\r\nmmc_set_clock(host, card->cis.max_dtr);\r\nif (card->cccr.high_speed) {\r\nmmc_set_timing(card->host, MMC_TIMING_SD_HS);\r\n}\r\ngoto finish;\r\n}\r\nerr = sdio_read_cccr(card, ocr);\r\nif (err) {\r\nmmc_sdio_resend_if_cond(host, card);\r\nif (ocr & R4_18V_PRESENT) {\r\nretries = 0;\r\ngoto try_again;\r\n} else {\r\ngoto remove;\r\n}\r\n}\r\nerr = sdio_read_common_cis(card);\r\nif (err)\r\ngoto remove;\r\nif (oldcard) {\r\nint same = (card->cis.vendor == oldcard->cis.vendor &&\r\ncard->cis.device == oldcard->cis.device);\r\nmmc_remove_card(card);\r\nif (!same)\r\nreturn -ENOENT;\r\ncard = oldcard;\r\n}\r\ncard->ocr = ocr_card;\r\nmmc_fixup_device(card, sdio_fixup_methods);\r\nif (card->type == MMC_TYPE_SD_COMBO) {\r\nerr = mmc_sd_setup_card(host, card, oldcard != NULL);\r\nif (err) {\r\nmmc_go_idle(host);\r\nif (mmc_host_is_spi(host))\r\nmmc_spi_set_crc(host, use_spi_crc);\r\ncard->type = MMC_TYPE_SDIO;\r\n} else\r\ncard->dev.type = &sd_type;\r\n}\r\nerr = sdio_disable_cd(card);\r\nif (err)\r\ngoto remove;\r\nif ((ocr & R4_18V_PRESENT) && card->sw_caps.sd3_bus_mode) {\r\nerr = mmc_sdio_init_uhs_card(card);\r\nif (err)\r\ngoto remove;\r\n} else {\r\nerr = sdio_enable_hs(card);\r\nif (err > 0)\r\nmmc_set_timing(card->host, MMC_TIMING_SD_HS);\r\nelse if (err)\r\ngoto remove;\r\nmmc_set_clock(host, mmc_sdio_get_max_clock(card));\r\nerr = sdio_enable_4bit_bus(card);\r\nif (err)\r\ngoto remove;\r\n}\r\nfinish:\r\nif (!oldcard)\r\nhost->card = card;\r\nreturn 0;\r\nremove:\r\nif (!oldcard)\r\nmmc_remove_card(card);\r\nerr:\r\nreturn err;\r\n}\r\nstatic void mmc_sdio_remove(struct mmc_host *host)\r\n{\r\nint i;\r\nfor (i = 0;i < host->card->sdio_funcs;i++) {\r\nif (host->card->sdio_func[i]) {\r\nsdio_remove_func(host->card->sdio_func[i]);\r\nhost->card->sdio_func[i] = NULL;\r\n}\r\n}\r\nmmc_remove_card(host->card);\r\nhost->card = NULL;\r\n}\r\nstatic int mmc_sdio_alive(struct mmc_host *host)\r\n{\r\nreturn mmc_select_card(host->card);\r\n}\r\nstatic void mmc_sdio_detect(struct mmc_host *host)\r\n{\r\nint err;\r\nif (host->caps & MMC_CAP_POWER_OFF_CARD) {\r\nerr = pm_runtime_get_sync(&host->card->dev);\r\nif (err < 0) {\r\npm_runtime_put_noidle(&host->card->dev);\r\ngoto out;\r\n}\r\n}\r\nmmc_claim_host(host);\r\nerr = _mmc_detect_card_removed(host);\r\nmmc_release_host(host);\r\nif (host->caps & MMC_CAP_POWER_OFF_CARD)\r\npm_runtime_put_sync(&host->card->dev);\r\nout:\r\nif (err) {\r\nmmc_sdio_remove(host);\r\nmmc_claim_host(host);\r\nmmc_detach_bus(host);\r\nmmc_power_off(host);\r\nmmc_release_host(host);\r\n}\r\n}\r\nstatic int mmc_sdio_pre_suspend(struct mmc_host *host)\r\n{\r\nint i, err = 0;\r\nfor (i = 0; i < host->card->sdio_funcs; i++) {\r\nstruct sdio_func *func = host->card->sdio_func[i];\r\nif (func && sdio_func_present(func) && func->dev.driver) {\r\nconst struct dev_pm_ops *pmops = func->dev.driver->pm;\r\nif (!pmops || !pmops->suspend || !pmops->resume) {\r\nerr = -ENOSYS;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic int mmc_sdio_suspend(struct mmc_host *host)\r\n{\r\nmmc_claim_host(host);\r\nif (mmc_card_keep_power(host) && mmc_card_wake_sdio_irq(host))\r\nsdio_disable_wide(host->card);\r\nif (!mmc_card_keep_power(host)) {\r\nmmc_power_off(host);\r\n} else if (host->retune_period) {\r\nmmc_retune_timer_stop(host);\r\nmmc_retune_needed(host);\r\n}\r\nmmc_release_host(host);\r\nreturn 0;\r\n}\r\nstatic int mmc_sdio_resume(struct mmc_host *host)\r\n{\r\nint err = 0;\r\nmmc_claim_host(host);\r\nif (!mmc_card_keep_power(host)) {\r\nmmc_power_up(host, host->card->ocr);\r\nif (host->caps & MMC_CAP_POWER_OFF_CARD) {\r\npm_runtime_disable(&host->card->dev);\r\npm_runtime_set_active(&host->card->dev);\r\npm_runtime_enable(&host->card->dev);\r\n}\r\n}\r\nif (mmc_card_is_removable(host) || !mmc_card_keep_power(host)) {\r\nsdio_reset(host);\r\nmmc_go_idle(host);\r\nmmc_send_if_cond(host, host->card->ocr);\r\nerr = mmc_send_io_op_cond(host, 0, NULL);\r\nif (!err)\r\nerr = mmc_sdio_init_card(host, host->card->ocr,\r\nhost->card,\r\nmmc_card_keep_power(host));\r\n} else if (mmc_card_keep_power(host) && mmc_card_wake_sdio_irq(host)) {\r\nerr = sdio_enable_4bit_bus(host->card);\r\n}\r\nif (!err && host->sdio_irqs) {\r\nif (!(host->caps2 & MMC_CAP2_SDIO_IRQ_NOTHREAD))\r\nwake_up_process(host->sdio_irq_thread);\r\nelse if (host->caps & MMC_CAP_SDIO_IRQ)\r\nhost->ops->enable_sdio_irq(host, 1);\r\n}\r\nmmc_release_host(host);\r\nhost->pm_flags &= ~MMC_PM_KEEP_POWER;\r\nreturn err;\r\n}\r\nstatic int mmc_sdio_power_restore(struct mmc_host *host)\r\n{\r\nint ret;\r\nmmc_claim_host(host);\r\nsdio_reset(host);\r\nmmc_go_idle(host);\r\nmmc_send_if_cond(host, host->card->ocr);\r\nret = mmc_send_io_op_cond(host, 0, NULL);\r\nif (ret)\r\ngoto out;\r\nret = mmc_sdio_init_card(host, host->card->ocr, host->card,\r\nmmc_card_keep_power(host));\r\nif (!ret && host->sdio_irqs)\r\nmmc_signal_sdio_irq(host);\r\nout:\r\nmmc_release_host(host);\r\nreturn ret;\r\n}\r\nstatic int mmc_sdio_runtime_suspend(struct mmc_host *host)\r\n{\r\nmmc_claim_host(host);\r\nmmc_power_off(host);\r\nmmc_release_host(host);\r\nreturn 0;\r\n}\r\nstatic int mmc_sdio_runtime_resume(struct mmc_host *host)\r\n{\r\nint ret;\r\nmmc_claim_host(host);\r\nmmc_power_up(host, host->card->ocr);\r\nret = mmc_sdio_power_restore(host);\r\nmmc_release_host(host);\r\nreturn ret;\r\n}\r\nstatic int mmc_sdio_reset(struct mmc_host *host)\r\n{\r\nmmc_power_cycle(host, host->card->ocr);\r\nreturn mmc_sdio_power_restore(host);\r\n}\r\nint mmc_attach_sdio(struct mmc_host *host)\r\n{\r\nint err, i, funcs;\r\nu32 ocr, rocr;\r\nstruct mmc_card *card;\r\nWARN_ON(!host->claimed);\r\nerr = mmc_send_io_op_cond(host, 0, &ocr);\r\nif (err)\r\nreturn err;\r\nmmc_attach_bus(host, &mmc_sdio_ops);\r\nif (host->ocr_avail_sdio)\r\nhost->ocr_avail = host->ocr_avail_sdio;\r\nrocr = mmc_select_voltage(host, ocr);\r\nif (!rocr) {\r\nerr = -EINVAL;\r\ngoto err;\r\n}\r\nerr = mmc_sdio_init_card(host, rocr, NULL, 0);\r\nif (err)\r\ngoto err;\r\ncard = host->card;\r\nif (host->caps & MMC_CAP_POWER_OFF_CARD) {\r\npm_runtime_get_noresume(&card->dev);\r\nerr = pm_runtime_set_active(&card->dev);\r\nif (err)\r\ngoto remove;\r\npm_runtime_enable(&card->dev);\r\n}\r\nfuncs = (ocr & 0x70000000) >> 28;\r\ncard->sdio_funcs = 0;\r\nfor (i = 0; i < funcs; i++, card->sdio_funcs++) {\r\nerr = sdio_init_func(host->card, i + 1);\r\nif (err)\r\ngoto remove;\r\nif (host->caps & MMC_CAP_POWER_OFF_CARD)\r\npm_runtime_enable(&card->sdio_func[i]->dev);\r\n}\r\nmmc_release_host(host);\r\nerr = mmc_add_card(host->card);\r\nif (err)\r\ngoto remove_added;\r\nfor (i = 0;i < funcs;i++) {\r\nerr = sdio_add_func(host->card->sdio_func[i]);\r\nif (err)\r\ngoto remove_added;\r\n}\r\nif (host->caps & MMC_CAP_POWER_OFF_CARD)\r\npm_runtime_put(&card->dev);\r\nmmc_claim_host(host);\r\nreturn 0;\r\nremove:\r\nmmc_release_host(host);\r\nremove_added:\r\nmmc_sdio_remove(host);\r\nmmc_claim_host(host);\r\nerr:\r\nmmc_detach_bus(host);\r\npr_err("%s: error %d whilst initialising SDIO card\n",\r\nmmc_hostname(host), err);\r\nreturn err;\r\n}
