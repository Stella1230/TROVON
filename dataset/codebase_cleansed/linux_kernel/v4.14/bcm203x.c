static void bcm203x_complete(struct urb *urb)\r\n{\r\nstruct bcm203x_data *data = urb->context;\r\nstruct usb_device *udev = urb->dev;\r\nint len;\r\nBT_DBG("udev %p urb %p", udev, urb);\r\nif (urb->status) {\r\nBT_ERR("URB failed with status %d", urb->status);\r\ndata->state = BCM203X_ERROR;\r\nreturn;\r\n}\r\nswitch (data->state) {\r\ncase BCM203X_LOAD_MINIDRV:\r\nmemcpy(data->buffer, "#", 1);\r\nusb_fill_bulk_urb(urb, udev, usb_sndbulkpipe(udev, BCM203X_OUT_EP),\r\ndata->buffer, 1, bcm203x_complete, data);\r\ndata->state = BCM203X_SELECT_MEMORY;\r\nschedule_work(&data->work);\r\nbreak;\r\ncase BCM203X_SELECT_MEMORY:\r\nusb_fill_int_urb(urb, udev, usb_rcvintpipe(udev, BCM203X_IN_EP),\r\ndata->buffer, 32, bcm203x_complete, data, 1);\r\ndata->state = BCM203X_CHECK_MEMORY;\r\nif (usb_submit_urb(data->urb, GFP_ATOMIC) < 0)\r\nBT_ERR("Can't submit URB");\r\nbreak;\r\ncase BCM203X_CHECK_MEMORY:\r\nif (data->buffer[0] != '#') {\r\nBT_ERR("Memory select failed");\r\ndata->state = BCM203X_ERROR;\r\nbreak;\r\n}\r\ndata->state = BCM203X_LOAD_FIRMWARE;\r\ncase BCM203X_LOAD_FIRMWARE:\r\nif (data->fw_sent == data->fw_size) {\r\nusb_fill_int_urb(urb, udev, usb_rcvintpipe(udev, BCM203X_IN_EP),\r\ndata->buffer, 32, bcm203x_complete, data, 1);\r\ndata->state = BCM203X_CHECK_FIRMWARE;\r\n} else {\r\nlen = min_t(uint, data->fw_size - data->fw_sent, 4096);\r\nusb_fill_bulk_urb(urb, udev, usb_sndbulkpipe(udev, BCM203X_OUT_EP),\r\ndata->fw_data + data->fw_sent, len, bcm203x_complete, data);\r\ndata->fw_sent += len;\r\n}\r\nif (usb_submit_urb(data->urb, GFP_ATOMIC) < 0)\r\nBT_ERR("Can't submit URB");\r\nbreak;\r\ncase BCM203X_CHECK_FIRMWARE:\r\nif (data->buffer[0] != '.') {\r\nBT_ERR("Firmware loading failed");\r\ndata->state = BCM203X_ERROR;\r\nbreak;\r\n}\r\ndata->state = BCM203X_RESET;\r\nbreak;\r\n}\r\n}\r\nstatic void bcm203x_work(struct work_struct *work)\r\n{\r\nstruct bcm203x_data *data =\r\ncontainer_of(work, struct bcm203x_data, work);\r\nif (atomic_read(&data->shutdown))\r\nreturn;\r\nif (usb_submit_urb(data->urb, GFP_KERNEL) < 0)\r\nBT_ERR("Can't submit URB");\r\n}\r\nstatic int bcm203x_probe(struct usb_interface *intf, const struct usb_device_id *id)\r\n{\r\nconst struct firmware *firmware;\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nstruct bcm203x_data *data;\r\nint size;\r\nBT_DBG("intf %p id %p", intf, id);\r\nif (intf->cur_altsetting->desc.bInterfaceNumber != 0)\r\nreturn -ENODEV;\r\ndata = devm_kzalloc(&intf->dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->udev = udev;\r\ndata->state = BCM203X_LOAD_MINIDRV;\r\ndata->urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!data->urb)\r\nreturn -ENOMEM;\r\nif (request_firmware(&firmware, "BCM2033-MD.hex", &udev->dev) < 0) {\r\nBT_ERR("Mini driver request failed");\r\nusb_free_urb(data->urb);\r\nreturn -EIO;\r\n}\r\nBT_DBG("minidrv data %p size %zu", firmware->data, firmware->size);\r\nsize = max_t(uint, firmware->size, 4096);\r\ndata->buffer = kmalloc(size, GFP_KERNEL);\r\nif (!data->buffer) {\r\nBT_ERR("Can't allocate memory for mini driver");\r\nrelease_firmware(firmware);\r\nusb_free_urb(data->urb);\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(data->buffer, firmware->data, firmware->size);\r\nusb_fill_bulk_urb(data->urb, udev, usb_sndbulkpipe(udev, BCM203X_OUT_EP),\r\ndata->buffer, firmware->size, bcm203x_complete, data);\r\nrelease_firmware(firmware);\r\nif (request_firmware(&firmware, "BCM2033-FW.bin", &udev->dev) < 0) {\r\nBT_ERR("Firmware request failed");\r\nusb_free_urb(data->urb);\r\nkfree(data->buffer);\r\nreturn -EIO;\r\n}\r\nBT_DBG("firmware data %p size %zu", firmware->data, firmware->size);\r\ndata->fw_data = kmemdup(firmware->data, firmware->size, GFP_KERNEL);\r\nif (!data->fw_data) {\r\nBT_ERR("Can't allocate memory for firmware image");\r\nrelease_firmware(firmware);\r\nusb_free_urb(data->urb);\r\nkfree(data->buffer);\r\nreturn -ENOMEM;\r\n}\r\ndata->fw_size = firmware->size;\r\ndata->fw_sent = 0;\r\nrelease_firmware(firmware);\r\nINIT_WORK(&data->work, bcm203x_work);\r\nusb_set_intfdata(intf, data);\r\nschedule_work(&data->work);\r\nreturn 0;\r\n}\r\nstatic void bcm203x_disconnect(struct usb_interface *intf)\r\n{\r\nstruct bcm203x_data *data = usb_get_intfdata(intf);\r\nBT_DBG("intf %p", intf);\r\natomic_inc(&data->shutdown);\r\ncancel_work_sync(&data->work);\r\nusb_kill_urb(data->urb);\r\nusb_set_intfdata(intf, NULL);\r\nusb_free_urb(data->urb);\r\nkfree(data->fw_data);\r\nkfree(data->buffer);\r\n}
