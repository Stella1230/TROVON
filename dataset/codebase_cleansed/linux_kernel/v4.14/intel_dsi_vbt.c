static inline enum port intel_dsi_seq_port_to_port(u8 port)\r\n{\r\nreturn port ? PORT_C : PORT_A;\r\n}\r\nstatic const u8 *mipi_exec_send_packet(struct intel_dsi *intel_dsi,\r\nconst u8 *data)\r\n{\r\nstruct mipi_dsi_device *dsi_device;\r\nu8 type, flags, seq_port;\r\nu16 len;\r\nenum port port;\r\nDRM_DEBUG_KMS("\n");\r\nflags = *data++;\r\ntype = *data++;\r\nlen = *((u16 *) data);\r\ndata += 2;\r\nseq_port = (flags >> MIPI_PORT_SHIFT) & 3;\r\nif (intel_dsi->ports == (1 << PORT_C))\r\nport = PORT_C;\r\nelse\r\nport = intel_dsi_seq_port_to_port(seq_port);\r\ndsi_device = intel_dsi->dsi_hosts[port]->device;\r\nif (!dsi_device) {\r\nDRM_DEBUG_KMS("no dsi device for port %c\n", port_name(port));\r\ngoto out;\r\n}\r\nif ((flags >> MIPI_TRANSFER_MODE_SHIFT) & 1)\r\ndsi_device->mode_flags &= ~MIPI_DSI_MODE_LPM;\r\nelse\r\ndsi_device->mode_flags |= MIPI_DSI_MODE_LPM;\r\ndsi_device->channel = (flags >> MIPI_VIRTUAL_CHANNEL_SHIFT) & 3;\r\nswitch (type) {\r\ncase MIPI_DSI_GENERIC_SHORT_WRITE_0_PARAM:\r\nmipi_dsi_generic_write(dsi_device, NULL, 0);\r\nbreak;\r\ncase MIPI_DSI_GENERIC_SHORT_WRITE_1_PARAM:\r\nmipi_dsi_generic_write(dsi_device, data, 1);\r\nbreak;\r\ncase MIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM:\r\nmipi_dsi_generic_write(dsi_device, data, 2);\r\nbreak;\r\ncase MIPI_DSI_GENERIC_READ_REQUEST_0_PARAM:\r\ncase MIPI_DSI_GENERIC_READ_REQUEST_1_PARAM:\r\ncase MIPI_DSI_GENERIC_READ_REQUEST_2_PARAM:\r\nDRM_DEBUG_DRIVER("Generic Read not yet implemented or used\n");\r\nbreak;\r\ncase MIPI_DSI_GENERIC_LONG_WRITE:\r\nmipi_dsi_generic_write(dsi_device, data, len);\r\nbreak;\r\ncase MIPI_DSI_DCS_SHORT_WRITE:\r\nmipi_dsi_dcs_write_buffer(dsi_device, data, 1);\r\nbreak;\r\ncase MIPI_DSI_DCS_SHORT_WRITE_PARAM:\r\nmipi_dsi_dcs_write_buffer(dsi_device, data, 2);\r\nbreak;\r\ncase MIPI_DSI_DCS_READ:\r\nDRM_DEBUG_DRIVER("DCS Read not yet implemented or used\n");\r\nbreak;\r\ncase MIPI_DSI_DCS_LONG_WRITE:\r\nmipi_dsi_dcs_write_buffer(dsi_device, data, len);\r\nbreak;\r\n}\r\nwait_for_dsi_fifo_empty(intel_dsi, port);\r\nout:\r\ndata += len;\r\nreturn data;\r\n}\r\nstatic const u8 *mipi_exec_delay(struct intel_dsi *intel_dsi, const u8 *data)\r\n{\r\nu32 delay = *((const u32 *) data);\r\nDRM_DEBUG_KMS("\n");\r\nusleep_range(delay, delay + 10);\r\ndata += 4;\r\nreturn data;\r\n}\r\nstatic void vlv_exec_gpio(struct drm_i915_private *dev_priv,\r\nu8 gpio_source, u8 gpio_index, bool value)\r\n{\r\nstruct gpio_map *map;\r\nu16 pconf0, padval;\r\nu32 tmp;\r\nu8 port;\r\nif (gpio_index >= ARRAY_SIZE(vlv_gpio_table)) {\r\nDRM_DEBUG_KMS("unknown gpio index %u\n", gpio_index);\r\nreturn;\r\n}\r\nmap = &vlv_gpio_table[gpio_index];\r\nif (dev_priv->vbt.dsi.seq_version >= 3) {\r\nport = IOSF_PORT_GPIO_NC;\r\n} else {\r\nif (gpio_source == 0) {\r\nport = IOSF_PORT_GPIO_NC;\r\n} else if (gpio_source == 1) {\r\nDRM_DEBUG_KMS("SC gpio not supported\n");\r\nreturn;\r\n} else {\r\nDRM_DEBUG_KMS("unknown gpio source %u\n", gpio_source);\r\nreturn;\r\n}\r\n}\r\npconf0 = VLV_GPIO_PCONF0(map->base_offset);\r\npadval = VLV_GPIO_PAD_VAL(map->base_offset);\r\nmutex_lock(&dev_priv->sb_lock);\r\nif (!map->init) {\r\nvlv_iosf_sb_write(dev_priv, port, pconf0, 0x2000CC00);\r\nmap->init = true;\r\n}\r\ntmp = 0x4 | value;\r\nvlv_iosf_sb_write(dev_priv, port, padval, tmp);\r\nmutex_unlock(&dev_priv->sb_lock);\r\n}\r\nstatic void chv_exec_gpio(struct drm_i915_private *dev_priv,\r\nu8 gpio_source, u8 gpio_index, bool value)\r\n{\r\nu16 cfg0, cfg1;\r\nu16 family_num;\r\nu8 port;\r\nif (dev_priv->vbt.dsi.seq_version >= 3) {\r\nif (gpio_index >= CHV_GPIO_IDX_START_SE) {\r\ngpio_index -= CHV_GPIO_IDX_START_SE;\r\nport = CHV_IOSF_PORT_GPIO_SE;\r\n} else if (gpio_index >= CHV_GPIO_IDX_START_SW) {\r\ngpio_index -= CHV_GPIO_IDX_START_SW;\r\nport = CHV_IOSF_PORT_GPIO_SW;\r\n} else if (gpio_index >= CHV_GPIO_IDX_START_E) {\r\ngpio_index -= CHV_GPIO_IDX_START_E;\r\nport = CHV_IOSF_PORT_GPIO_E;\r\n} else {\r\nport = CHV_IOSF_PORT_GPIO_N;\r\n}\r\n} else {\r\nif (gpio_source != 0) {\r\nDRM_DEBUG_KMS("unknown gpio source %u\n", gpio_source);\r\nreturn;\r\n}\r\nif (gpio_index >= CHV_GPIO_IDX_START_E) {\r\nDRM_DEBUG_KMS("invalid gpio index %u for GPIO N\n",\r\ngpio_index);\r\nreturn;\r\n}\r\nport = CHV_IOSF_PORT_GPIO_N;\r\n}\r\nfamily_num = gpio_index / CHV_VBT_MAX_PINS_PER_FMLY;\r\ngpio_index = gpio_index % CHV_VBT_MAX_PINS_PER_FMLY;\r\ncfg0 = CHV_GPIO_PAD_CFG0(family_num, gpio_index);\r\ncfg1 = CHV_GPIO_PAD_CFG1(family_num, gpio_index);\r\nmutex_lock(&dev_priv->sb_lock);\r\nvlv_iosf_sb_write(dev_priv, port, cfg1, 0);\r\nvlv_iosf_sb_write(dev_priv, port, cfg0,\r\nCHV_GPIO_GPIOEN | CHV_GPIO_GPIOCFG_GPO |\r\nCHV_GPIO_GPIOTXSTATE(value));\r\nmutex_unlock(&dev_priv->sb_lock);\r\n}\r\nstatic void bxt_exec_gpio(struct drm_i915_private *dev_priv,\r\nu8 gpio_source, u8 gpio_index, bool value)\r\n{\r\nstatic struct gpio_desc *bxt_gpio_table[U8_MAX + 1];\r\nstruct gpio_desc *gpio_desc = bxt_gpio_table[gpio_index];\r\nif (!gpio_desc) {\r\ngpio_desc = devm_gpiod_get_index(dev_priv->drm.dev,\r\nNULL, gpio_index,\r\nvalue ? GPIOD_OUT_LOW :\r\nGPIOD_OUT_HIGH);\r\nif (IS_ERR_OR_NULL(gpio_desc)) {\r\nDRM_ERROR("GPIO index %u request failed (%ld)\n",\r\ngpio_index, PTR_ERR(gpio_desc));\r\nreturn;\r\n}\r\nbxt_gpio_table[gpio_index] = gpio_desc;\r\n}\r\ngpiod_set_value(gpio_desc, value);\r\n}\r\nstatic const u8 *mipi_exec_gpio(struct intel_dsi *intel_dsi, const u8 *data)\r\n{\r\nstruct drm_device *dev = intel_dsi->base.base.dev;\r\nstruct drm_i915_private *dev_priv = to_i915(dev);\r\nu8 gpio_source, gpio_index = 0, gpio_number;\r\nbool value;\r\nDRM_DEBUG_KMS("\n");\r\nif (dev_priv->vbt.dsi.seq_version >= 3)\r\ngpio_index = *data++;\r\ngpio_number = *data++;\r\nif (dev_priv->vbt.dsi.seq_version == 2)\r\ngpio_source = (*data >> 1) & 3;\r\nelse\r\ngpio_source = 0;\r\nvalue = *data++ & 1;\r\nif (IS_VALLEYVIEW(dev_priv))\r\nvlv_exec_gpio(dev_priv, gpio_source, gpio_number, value);\r\nelse if (IS_CHERRYVIEW(dev_priv))\r\nchv_exec_gpio(dev_priv, gpio_source, gpio_number, value);\r\nelse\r\nbxt_exec_gpio(dev_priv, gpio_source, gpio_index, value);\r\nreturn data;\r\n}\r\nstatic const u8 *mipi_exec_i2c(struct intel_dsi *intel_dsi, const u8 *data)\r\n{\r\nDRM_DEBUG_KMS("Skipping I2C element execution\n");\r\nreturn data + *(data + 6) + 7;\r\n}\r\nstatic const u8 *mipi_exec_spi(struct intel_dsi *intel_dsi, const u8 *data)\r\n{\r\nDRM_DEBUG_KMS("Skipping SPI element execution\n");\r\nreturn data + *(data + 5) + 6;\r\n}\r\nstatic const u8 *mipi_exec_pmic(struct intel_dsi *intel_dsi, const u8 *data)\r\n{\r\nDRM_DEBUG_KMS("Skipping PMIC element execution\n");\r\nreturn data + 15;\r\n}\r\nstatic const char *sequence_name(enum mipi_seq seq_id)\r\n{\r\nif (seq_id < ARRAY_SIZE(seq_name) && seq_name[seq_id])\r\nreturn seq_name[seq_id];\r\nelse\r\nreturn "(unknown)";\r\n}\r\nvoid intel_dsi_vbt_exec_sequence(struct intel_dsi *intel_dsi,\r\nenum mipi_seq seq_id)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(intel_dsi->base.base.dev);\r\nconst u8 *data;\r\nfn_mipi_elem_exec mipi_elem_exec;\r\nif (WARN_ON(seq_id >= ARRAY_SIZE(dev_priv->vbt.dsi.sequence)))\r\nreturn;\r\ndata = dev_priv->vbt.dsi.sequence[seq_id];\r\nif (!data)\r\nreturn;\r\nWARN_ON(*data != seq_id);\r\nDRM_DEBUG_KMS("Starting MIPI sequence %d - %s\n",\r\nseq_id, sequence_name(seq_id));\r\ndata++;\r\nif (dev_priv->vbt.dsi.seq_version >= 3)\r\ndata += 4;\r\nwhile (1) {\r\nu8 operation_byte = *data++;\r\nu8 operation_size = 0;\r\nif (operation_byte == MIPI_SEQ_ELEM_END)\r\nbreak;\r\nif (operation_byte < ARRAY_SIZE(exec_elem))\r\nmipi_elem_exec = exec_elem[operation_byte];\r\nelse\r\nmipi_elem_exec = NULL;\r\nif (dev_priv->vbt.dsi.seq_version >= 3)\r\noperation_size = *data++;\r\nif (mipi_elem_exec) {\r\nconst u8 *next = data + operation_size;\r\ndata = mipi_elem_exec(intel_dsi, data);\r\nif (operation_size && data != next) {\r\nDRM_ERROR("Inconsistent operation size\n");\r\nreturn;\r\n}\r\n} else if (operation_size) {\r\nDRM_DEBUG_KMS("Unsupported MIPI operation byte %u\n",\r\noperation_byte);\r\ndata += operation_size;\r\n} else {\r\nDRM_ERROR("Unsupported MIPI operation byte %u\n",\r\noperation_byte);\r\nreturn;\r\n}\r\n}\r\n}\r\nint intel_dsi_vbt_get_modes(struct intel_dsi *intel_dsi)\r\n{\r\nstruct intel_connector *connector = intel_dsi->attached_connector;\r\nstruct drm_device *dev = intel_dsi->base.base.dev;\r\nstruct drm_i915_private *dev_priv = to_i915(dev);\r\nstruct drm_display_mode *mode;\r\nmode = drm_mode_duplicate(dev, dev_priv->vbt.lfp_lvds_vbt_mode);\r\nif (!mode)\r\nreturn 0;\r\nmode->type |= DRM_MODE_TYPE_PREFERRED;\r\ndrm_mode_probed_add(&connector->base, mode);\r\nreturn 1;\r\n}\r\nbool intel_dsi_vbt_init(struct intel_dsi *intel_dsi, u16 panel_id)\r\n{\r\nstruct drm_device *dev = intel_dsi->base.base.dev;\r\nstruct drm_i915_private *dev_priv = to_i915(dev);\r\nstruct mipi_config *mipi_config = dev_priv->vbt.dsi.config;\r\nstruct mipi_pps_data *pps = dev_priv->vbt.dsi.pps;\r\nstruct drm_display_mode *mode = dev_priv->vbt.lfp_lvds_vbt_mode;\r\nu32 bpp;\r\nu32 tlpx_ns, extra_byte_count, bitrate, tlpx_ui;\r\nu32 ui_num, ui_den;\r\nu32 prepare_cnt, exit_zero_cnt, clk_zero_cnt, trail_cnt;\r\nu32 ths_prepare_ns, tclk_trail_ns;\r\nu32 tclk_prepare_clkzero, ths_prepare_hszero;\r\nu32 lp_to_hs_switch, hs_to_lp_switch;\r\nu32 pclk, computed_ddr;\r\nu32 mul;\r\nu16 burst_mode_ratio;\r\nenum port port;\r\nDRM_DEBUG_KMS("\n");\r\nintel_dsi->eotp_pkt = mipi_config->eot_pkt_disabled ? 0 : 1;\r\nintel_dsi->clock_stop = mipi_config->enable_clk_stop ? 1 : 0;\r\nintel_dsi->lane_count = mipi_config->lane_cnt + 1;\r\nintel_dsi->pixel_format =\r\npixel_format_from_register_bits(\r\nmipi_config->videomode_color_format << 7);\r\nbpp = mipi_dsi_pixel_format_to_bpp(intel_dsi->pixel_format);\r\nintel_dsi->dual_link = mipi_config->dual_link;\r\nintel_dsi->pixel_overlap = mipi_config->pixel_overlap;\r\nintel_dsi->operation_mode = mipi_config->is_cmd_mode;\r\nintel_dsi->video_mode_format = mipi_config->video_transfer_mode;\r\nintel_dsi->escape_clk_div = mipi_config->byte_clk_sel;\r\nintel_dsi->lp_rx_timeout = mipi_config->lp_rx_timeout;\r\nintel_dsi->turn_arnd_val = mipi_config->turn_around_timeout;\r\nintel_dsi->rst_timer_val = mipi_config->device_reset_timer;\r\nintel_dsi->init_count = mipi_config->master_init_timer;\r\nintel_dsi->bw_timer = mipi_config->dbi_bw_timer;\r\nintel_dsi->video_frmt_cfg_bits =\r\nmipi_config->bta_enabled ? DISABLE_VIDEO_BTA : 0;\r\npclk = mode->clock;\r\nif (intel_dsi->dual_link) {\r\npclk = pclk / 2;\r\nif (intel_dsi->dual_link == DSI_DUAL_LINK_FRONT_BACK) {\r\npclk += DIV_ROUND_UP(mode->vtotal *\r\nintel_dsi->pixel_overlap *\r\n60, 1000);\r\n}\r\n}\r\nif (intel_dsi->video_mode_format == VIDEO_MODE_BURST) {\r\nif (mipi_config->target_burst_mode_freq) {\r\ncomputed_ddr = (pclk * bpp) / intel_dsi->lane_count;\r\nif (mipi_config->target_burst_mode_freq <\r\ncomputed_ddr) {\r\nDRM_ERROR("Burst mode freq is less than computed\n");\r\nreturn false;\r\n}\r\nburst_mode_ratio = DIV_ROUND_UP(\r\nmipi_config->target_burst_mode_freq * 100,\r\ncomputed_ddr);\r\npclk = DIV_ROUND_UP(pclk * burst_mode_ratio, 100);\r\n} else {\r\nDRM_ERROR("Burst mode target is not set\n");\r\nreturn false;\r\n}\r\n} else\r\nburst_mode_ratio = 100;\r\nintel_dsi->burst_mode_ratio = burst_mode_ratio;\r\nintel_dsi->pclk = pclk;\r\nbitrate = (pclk * bpp) / intel_dsi->lane_count;\r\nswitch (intel_dsi->escape_clk_div) {\r\ncase 0:\r\ntlpx_ns = 50;\r\nbreak;\r\ncase 1:\r\ntlpx_ns = 100;\r\nbreak;\r\ncase 2:\r\ntlpx_ns = 200;\r\nbreak;\r\ndefault:\r\ntlpx_ns = 50;\r\nbreak;\r\n}\r\nswitch (intel_dsi->lane_count) {\r\ncase 1:\r\ncase 2:\r\nextra_byte_count = 2;\r\nbreak;\r\ncase 3:\r\nextra_byte_count = 4;\r\nbreak;\r\ncase 4:\r\ndefault:\r\nextra_byte_count = 3;\r\nbreak;\r\n}\r\nui_num = NS_KHZ_RATIO;\r\nui_den = bitrate;\r\ntclk_prepare_clkzero = mipi_config->tclk_prepare_clkzero;\r\nths_prepare_hszero = mipi_config->ths_prepare_hszero;\r\nintel_dsi->lp_byte_clk = DIV_ROUND_UP(tlpx_ns * ui_den, 8 * ui_num);\r\nmul = IS_GEMINILAKE(dev_priv) ? 8 : 2;\r\nths_prepare_ns = max(mipi_config->ths_prepare,\r\nmipi_config->tclk_prepare);\r\nprepare_cnt = DIV_ROUND_UP(ths_prepare_ns * ui_den, ui_num * mul);\r\nexit_zero_cnt = DIV_ROUND_UP(\r\n(ths_prepare_hszero - ths_prepare_ns) * ui_den,\r\nui_num * mul\r\n);\r\nif (exit_zero_cnt < (55 * ui_den / ui_num) && (55 * ui_den) % ui_num)\r\nexit_zero_cnt += 1;\r\nclk_zero_cnt = DIV_ROUND_UP(\r\n(tclk_prepare_clkzero - ths_prepare_ns)\r\n* ui_den, ui_num * mul);\r\ntclk_trail_ns = max(mipi_config->tclk_trail, mipi_config->ths_trail);\r\ntrail_cnt = DIV_ROUND_UP(tclk_trail_ns * ui_den, ui_num * mul);\r\nif (prepare_cnt > PREPARE_CNT_MAX ||\r\nexit_zero_cnt > EXIT_ZERO_CNT_MAX ||\r\nclk_zero_cnt > CLK_ZERO_CNT_MAX ||\r\ntrail_cnt > TRAIL_CNT_MAX)\r\nDRM_DEBUG_DRIVER("Values crossing maximum limits, restricting to max values\n");\r\nif (prepare_cnt > PREPARE_CNT_MAX)\r\nprepare_cnt = PREPARE_CNT_MAX;\r\nif (exit_zero_cnt > EXIT_ZERO_CNT_MAX)\r\nexit_zero_cnt = EXIT_ZERO_CNT_MAX;\r\nif (clk_zero_cnt > CLK_ZERO_CNT_MAX)\r\nclk_zero_cnt = CLK_ZERO_CNT_MAX;\r\nif (trail_cnt > TRAIL_CNT_MAX)\r\ntrail_cnt = TRAIL_CNT_MAX;\r\nintel_dsi->dphy_reg = exit_zero_cnt << 24 | trail_cnt << 16 |\r\nclk_zero_cnt << 8 | prepare_cnt;\r\ntlpx_ui = DIV_ROUND_UP(tlpx_ns * ui_den, ui_num);\r\nlp_to_hs_switch = DIV_ROUND_UP(4 * tlpx_ui + prepare_cnt * mul +\r\nexit_zero_cnt * mul + 10, 8);\r\nhs_to_lp_switch = DIV_ROUND_UP(mipi_config->ths_trail + 2 * tlpx_ui, 8);\r\nintel_dsi->hs_to_lp_count = max(lp_to_hs_switch, hs_to_lp_switch);\r\nintel_dsi->hs_to_lp_count += extra_byte_count;\r\nintel_dsi->clk_lp_to_hs_count =\r\nDIV_ROUND_UP(\r\n4 * tlpx_ui + prepare_cnt * 2 +\r\nclk_zero_cnt * 2,\r\n8);\r\nintel_dsi->clk_lp_to_hs_count += extra_byte_count;\r\nintel_dsi->clk_hs_to_lp_count =\r\nDIV_ROUND_UP(2 * tlpx_ui + trail_cnt * 2 + 8,\r\n8);\r\nintel_dsi->clk_hs_to_lp_count += extra_byte_count;\r\nDRM_DEBUG_KMS("Pclk %d\n", intel_dsi->pclk);\r\nDRM_DEBUG_KMS("Pixel overlap %d\n", intel_dsi->pixel_overlap);\r\nDRM_DEBUG_KMS("Lane count %d\n", intel_dsi->lane_count);\r\nDRM_DEBUG_KMS("DPHY param reg 0x%x\n", intel_dsi->dphy_reg);\r\nDRM_DEBUG_KMS("Video mode format %s\n",\r\nintel_dsi->video_mode_format == VIDEO_MODE_NON_BURST_WITH_SYNC_PULSE ?\r\n"non-burst with sync pulse" :\r\nintel_dsi->video_mode_format == VIDEO_MODE_NON_BURST_WITH_SYNC_EVENTS ?\r\n"non-burst with sync events" :\r\nintel_dsi->video_mode_format == VIDEO_MODE_BURST ?\r\n"burst" : "<unknown>");\r\nDRM_DEBUG_KMS("Burst mode ratio %d\n", intel_dsi->burst_mode_ratio);\r\nDRM_DEBUG_KMS("Reset timer %d\n", intel_dsi->rst_timer_val);\r\nDRM_DEBUG_KMS("Eot %s\n", enableddisabled(intel_dsi->eotp_pkt));\r\nDRM_DEBUG_KMS("Clockstop %s\n", enableddisabled(!intel_dsi->clock_stop));\r\nDRM_DEBUG_KMS("Mode %s\n", intel_dsi->operation_mode ? "command" : "video");\r\nif (intel_dsi->dual_link == DSI_DUAL_LINK_FRONT_BACK)\r\nDRM_DEBUG_KMS("Dual link: DSI_DUAL_LINK_FRONT_BACK\n");\r\nelse if (intel_dsi->dual_link == DSI_DUAL_LINK_PIXEL_ALT)\r\nDRM_DEBUG_KMS("Dual link: DSI_DUAL_LINK_PIXEL_ALT\n");\r\nelse\r\nDRM_DEBUG_KMS("Dual link: NONE\n");\r\nDRM_DEBUG_KMS("Pixel Format %d\n", intel_dsi->pixel_format);\r\nDRM_DEBUG_KMS("TLPX %d\n", intel_dsi->escape_clk_div);\r\nDRM_DEBUG_KMS("LP RX Timeout 0x%x\n", intel_dsi->lp_rx_timeout);\r\nDRM_DEBUG_KMS("Turnaround Timeout 0x%x\n", intel_dsi->turn_arnd_val);\r\nDRM_DEBUG_KMS("Init Count 0x%x\n", intel_dsi->init_count);\r\nDRM_DEBUG_KMS("HS to LP Count 0x%x\n", intel_dsi->hs_to_lp_count);\r\nDRM_DEBUG_KMS("LP Byte Clock %d\n", intel_dsi->lp_byte_clk);\r\nDRM_DEBUG_KMS("DBI BW Timer 0x%x\n", intel_dsi->bw_timer);\r\nDRM_DEBUG_KMS("LP to HS Clock Count 0x%x\n", intel_dsi->clk_lp_to_hs_count);\r\nDRM_DEBUG_KMS("HS to LP Clock Count 0x%x\n", intel_dsi->clk_hs_to_lp_count);\r\nDRM_DEBUG_KMS("BTA %s\n",\r\nenableddisabled(!(intel_dsi->video_frmt_cfg_bits & DISABLE_VIDEO_BTA)));\r\nintel_dsi->backlight_off_delay = pps->bl_disable_delay / 10;\r\nintel_dsi->backlight_on_delay = pps->bl_enable_delay / 10;\r\nintel_dsi->panel_on_delay = pps->panel_on_delay / 10;\r\nintel_dsi->panel_off_delay = pps->panel_off_delay / 10;\r\nintel_dsi->panel_pwr_cycle_delay = pps->panel_power_cycle_delay / 10;\r\nfor_each_dsi_port(port, intel_dsi->ports) {\r\nmipi_dsi_attach(intel_dsi->dsi_hosts[port]->device);\r\n}\r\nreturn true;\r\n}
