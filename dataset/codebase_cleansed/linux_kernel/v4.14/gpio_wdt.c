static void gpio_wdt_disable(struct gpio_wdt_priv *priv)\r\n{\r\ngpio_set_value_cansleep(priv->gpio, !priv->active_low);\r\nif (priv->hw_algo == HW_ALGO_TOGGLE)\r\ngpio_direction_input(priv->gpio);\r\n}\r\nstatic int gpio_wdt_ping(struct watchdog_device *wdd)\r\n{\r\nstruct gpio_wdt_priv *priv = watchdog_get_drvdata(wdd);\r\nswitch (priv->hw_algo) {\r\ncase HW_ALGO_TOGGLE:\r\npriv->state = !priv->state;\r\ngpio_set_value_cansleep(priv->gpio, priv->state);\r\nbreak;\r\ncase HW_ALGO_LEVEL:\r\ngpio_set_value_cansleep(priv->gpio, !priv->active_low);\r\nudelay(1);\r\ngpio_set_value_cansleep(priv->gpio, priv->active_low);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int gpio_wdt_start(struct watchdog_device *wdd)\r\n{\r\nstruct gpio_wdt_priv *priv = watchdog_get_drvdata(wdd);\r\npriv->state = priv->active_low;\r\ngpio_direction_output(priv->gpio, priv->state);\r\nset_bit(WDOG_HW_RUNNING, &wdd->status);\r\nreturn gpio_wdt_ping(wdd);\r\n}\r\nstatic int gpio_wdt_stop(struct watchdog_device *wdd)\r\n{\r\nstruct gpio_wdt_priv *priv = watchdog_get_drvdata(wdd);\r\nif (!priv->always_running) {\r\ngpio_wdt_disable(priv);\r\nclear_bit(WDOG_HW_RUNNING, &wdd->status);\r\n}\r\nreturn 0;\r\n}\r\nstatic int gpio_wdt_probe(struct platform_device *pdev)\r\n{\r\nstruct gpio_wdt_priv *priv;\r\nenum of_gpio_flags flags;\r\nunsigned int hw_margin;\r\nunsigned long f = 0;\r\nconst char *algo;\r\nint ret;\r\npriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, priv);\r\npriv->gpio = of_get_gpio_flags(pdev->dev.of_node, 0, &flags);\r\nif (!gpio_is_valid(priv->gpio))\r\nreturn priv->gpio;\r\npriv->active_low = flags & OF_GPIO_ACTIVE_LOW;\r\nret = of_property_read_string(pdev->dev.of_node, "hw_algo", &algo);\r\nif (ret)\r\nreturn ret;\r\nif (!strcmp(algo, "toggle")) {\r\npriv->hw_algo = HW_ALGO_TOGGLE;\r\nf = GPIOF_IN;\r\n} else if (!strcmp(algo, "level")) {\r\npriv->hw_algo = HW_ALGO_LEVEL;\r\nf = priv->active_low ? GPIOF_OUT_INIT_HIGH : GPIOF_OUT_INIT_LOW;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nret = devm_gpio_request_one(&pdev->dev, priv->gpio, f,\r\ndev_name(&pdev->dev));\r\nif (ret)\r\nreturn ret;\r\nret = of_property_read_u32(pdev->dev.of_node,\r\n"hw_margin_ms", &hw_margin);\r\nif (ret)\r\nreturn ret;\r\nif (hw_margin < 2 || hw_margin > 65535)\r\nreturn -EINVAL;\r\npriv->always_running = of_property_read_bool(pdev->dev.of_node,\r\n"always-running");\r\nwatchdog_set_drvdata(&priv->wdd, priv);\r\npriv->wdd.info = &gpio_wdt_ident;\r\npriv->wdd.ops = &gpio_wdt_ops;\r\npriv->wdd.min_timeout = SOFT_TIMEOUT_MIN;\r\npriv->wdd.max_hw_heartbeat_ms = hw_margin;\r\npriv->wdd.parent = &pdev->dev;\r\nif (watchdog_init_timeout(&priv->wdd, 0, &pdev->dev) < 0)\r\npriv->wdd.timeout = SOFT_TIMEOUT_DEF;\r\nwatchdog_stop_on_reboot(&priv->wdd);\r\nif (priv->always_running)\r\ngpio_wdt_start(&priv->wdd);\r\nret = watchdog_register_device(&priv->wdd);\r\nreturn ret;\r\n}\r\nstatic int gpio_wdt_remove(struct platform_device *pdev)\r\n{\r\nstruct gpio_wdt_priv *priv = platform_get_drvdata(pdev);\r\nwatchdog_unregister_device(&priv->wdd);\r\nreturn 0;\r\n}\r\nstatic int __init gpio_wdt_init(void)\r\n{\r\nreturn platform_driver_register(&gpio_wdt_driver);\r\n}
