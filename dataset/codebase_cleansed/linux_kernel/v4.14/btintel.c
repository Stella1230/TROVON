int btintel_check_bdaddr(struct hci_dev *hdev)\r\n{\r\nstruct hci_rp_read_bd_addr *bda;\r\nstruct sk_buff *skb;\r\nskb = __hci_cmd_sync(hdev, HCI_OP_READ_BD_ADDR, 0, NULL,\r\nHCI_INIT_TIMEOUT);\r\nif (IS_ERR(skb)) {\r\nint err = PTR_ERR(skb);\r\nBT_ERR("%s: Reading Intel device address failed (%d)",\r\nhdev->name, err);\r\nreturn err;\r\n}\r\nif (skb->len != sizeof(*bda)) {\r\nBT_ERR("%s: Intel device address length mismatch", hdev->name);\r\nkfree_skb(skb);\r\nreturn -EIO;\r\n}\r\nbda = (struct hci_rp_read_bd_addr *)skb->data;\r\nif (!bacmp(&bda->bdaddr, BDADDR_INTEL)) {\r\nBT_ERR("%s: Found Intel default device address (%pMR)",\r\nhdev->name, &bda->bdaddr);\r\nset_bit(HCI_QUIRK_INVALID_BDADDR, &hdev->quirks);\r\n}\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nint btintel_enter_mfg(struct hci_dev *hdev)\r\n{\r\nconst u8 param[] = { 0x01, 0x00 };\r\nstruct sk_buff *skb;\r\nskb = __hci_cmd_sync(hdev, 0xfc11, 2, param, HCI_CMD_TIMEOUT);\r\nif (IS_ERR(skb)) {\r\nbt_dev_err(hdev, "Entering manufacturer mode failed (%ld)",\r\nPTR_ERR(skb));\r\nreturn PTR_ERR(skb);\r\n}\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nint btintel_exit_mfg(struct hci_dev *hdev, bool reset, bool patched)\r\n{\r\nu8 param[] = { 0x00, 0x00 };\r\nstruct sk_buff *skb;\r\nif (reset)\r\nparam[1] |= patched ? 0x02 : 0x01;\r\nskb = __hci_cmd_sync(hdev, 0xfc11, 2, param, HCI_CMD_TIMEOUT);\r\nif (IS_ERR(skb)) {\r\nbt_dev_err(hdev, "Exiting manufacturer mode failed (%ld)",\r\nPTR_ERR(skb));\r\nreturn PTR_ERR(skb);\r\n}\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nint btintel_set_bdaddr(struct hci_dev *hdev, const bdaddr_t *bdaddr)\r\n{\r\nstruct sk_buff *skb;\r\nint err;\r\nskb = __hci_cmd_sync(hdev, 0xfc31, 6, bdaddr, HCI_INIT_TIMEOUT);\r\nif (IS_ERR(skb)) {\r\nerr = PTR_ERR(skb);\r\nBT_ERR("%s: Changing Intel device address failed (%d)",\r\nhdev->name, err);\r\nreturn err;\r\n}\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nint btintel_set_diag(struct hci_dev *hdev, bool enable)\r\n{\r\nstruct sk_buff *skb;\r\nu8 param[3];\r\nint err;\r\nif (enable) {\r\nparam[0] = 0x03;\r\nparam[1] = 0x03;\r\nparam[2] = 0x03;\r\n} else {\r\nparam[0] = 0x00;\r\nparam[1] = 0x00;\r\nparam[2] = 0x00;\r\n}\r\nskb = __hci_cmd_sync(hdev, 0xfc43, 3, param, HCI_INIT_TIMEOUT);\r\nif (IS_ERR(skb)) {\r\nerr = PTR_ERR(skb);\r\nif (err == -ENODATA)\r\ngoto done;\r\nBT_ERR("%s: Changing Intel diagnostic mode failed (%d)",\r\nhdev->name, err);\r\nreturn err;\r\n}\r\nkfree_skb(skb);\r\ndone:\r\nbtintel_set_event_mask(hdev, enable);\r\nreturn 0;\r\n}\r\nint btintel_set_diag_mfg(struct hci_dev *hdev, bool enable)\r\n{\r\nint err, ret;\r\nerr = btintel_enter_mfg(hdev);\r\nif (err)\r\nreturn err;\r\nret = btintel_set_diag(hdev, enable);\r\nerr = btintel_exit_mfg(hdev, false, false);\r\nif (err)\r\nreturn err;\r\nreturn ret;\r\n}\r\nvoid btintel_hw_error(struct hci_dev *hdev, u8 code)\r\n{\r\nstruct sk_buff *skb;\r\nu8 type = 0x00;\r\nBT_ERR("%s: Hardware error 0x%2.2x", hdev->name, code);\r\nskb = __hci_cmd_sync(hdev, HCI_OP_RESET, 0, NULL, HCI_INIT_TIMEOUT);\r\nif (IS_ERR(skb)) {\r\nBT_ERR("%s: Reset after hardware error failed (%ld)",\r\nhdev->name, PTR_ERR(skb));\r\nreturn;\r\n}\r\nkfree_skb(skb);\r\nskb = __hci_cmd_sync(hdev, 0xfc22, 1, &type, HCI_INIT_TIMEOUT);\r\nif (IS_ERR(skb)) {\r\nBT_ERR("%s: Retrieving Intel exception info failed (%ld)",\r\nhdev->name, PTR_ERR(skb));\r\nreturn;\r\n}\r\nif (skb->len != 13) {\r\nBT_ERR("%s: Exception info size mismatch", hdev->name);\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nBT_ERR("%s: Exception info %s", hdev->name, (char *)(skb->data + 1));\r\nkfree_skb(skb);\r\n}\r\nvoid btintel_version_info(struct hci_dev *hdev, struct intel_version *ver)\r\n{\r\nconst char *variant;\r\nswitch (ver->fw_variant) {\r\ncase 0x06:\r\nvariant = "Bootloader";\r\nbreak;\r\ncase 0x23:\r\nvariant = "Firmware";\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nBT_INFO("%s: %s revision %u.%u build %u week %u %u", hdev->name,\r\nvariant, ver->fw_revision >> 4, ver->fw_revision & 0x0f,\r\nver->fw_build_num, ver->fw_build_ww, 2000 + ver->fw_build_yy);\r\n}\r\nint btintel_secure_send(struct hci_dev *hdev, u8 fragment_type, u32 plen,\r\nconst void *param)\r\n{\r\nwhile (plen > 0) {\r\nstruct sk_buff *skb;\r\nu8 cmd_param[253], fragment_len = (plen > 252) ? 252 : plen;\r\ncmd_param[0] = fragment_type;\r\nmemcpy(cmd_param + 1, param, fragment_len);\r\nskb = __hci_cmd_sync(hdev, 0xfc09, fragment_len + 1,\r\ncmd_param, HCI_INIT_TIMEOUT);\r\nif (IS_ERR(skb))\r\nreturn PTR_ERR(skb);\r\nkfree_skb(skb);\r\nplen -= fragment_len;\r\nparam += fragment_len;\r\n}\r\nreturn 0;\r\n}\r\nint btintel_load_ddc_config(struct hci_dev *hdev, const char *ddc_name)\r\n{\r\nconst struct firmware *fw;\r\nstruct sk_buff *skb;\r\nconst u8 *fw_ptr;\r\nint err;\r\nerr = request_firmware_direct(&fw, ddc_name, &hdev->dev);\r\nif (err < 0) {\r\nbt_dev_err(hdev, "Failed to load Intel DDC file %s (%d)",\r\nddc_name, err);\r\nreturn err;\r\n}\r\nbt_dev_info(hdev, "Found Intel DDC parameters: %s", ddc_name);\r\nfw_ptr = fw->data;\r\nwhile (fw->size > fw_ptr - fw->data) {\r\nu8 cmd_plen = fw_ptr[0] + sizeof(u8);\r\nskb = __hci_cmd_sync(hdev, 0xfc8b, cmd_plen, fw_ptr,\r\nHCI_INIT_TIMEOUT);\r\nif (IS_ERR(skb)) {\r\nbt_dev_err(hdev, "Failed to send Intel_Write_DDC (%ld)",\r\nPTR_ERR(skb));\r\nrelease_firmware(fw);\r\nreturn PTR_ERR(skb);\r\n}\r\nfw_ptr += cmd_plen;\r\nkfree_skb(skb);\r\n}\r\nrelease_firmware(fw);\r\nbt_dev_info(hdev, "Applying Intel DDC parameters completed");\r\nreturn 0;\r\n}\r\nint btintel_set_event_mask(struct hci_dev *hdev, bool debug)\r\n{\r\nu8 mask[8] = { 0x87, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\r\nstruct sk_buff *skb;\r\nint err;\r\nif (debug)\r\nmask[1] |= 0x62;\r\nskb = __hci_cmd_sync(hdev, 0xfc52, 8, mask, HCI_INIT_TIMEOUT);\r\nif (IS_ERR(skb)) {\r\nerr = PTR_ERR(skb);\r\nBT_ERR("%s: Setting Intel event mask failed (%d)",\r\nhdev->name, err);\r\nreturn err;\r\n}\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nint btintel_set_event_mask_mfg(struct hci_dev *hdev, bool debug)\r\n{\r\nint err, ret;\r\nerr = btintel_enter_mfg(hdev);\r\nif (err)\r\nreturn err;\r\nret = btintel_set_event_mask(hdev, debug);\r\nerr = btintel_exit_mfg(hdev, false, false);\r\nif (err)\r\nreturn err;\r\nreturn ret;\r\n}\r\nint btintel_read_version(struct hci_dev *hdev, struct intel_version *ver)\r\n{\r\nstruct sk_buff *skb;\r\nskb = __hci_cmd_sync(hdev, 0xfc05, 0, NULL, HCI_CMD_TIMEOUT);\r\nif (IS_ERR(skb)) {\r\nbt_dev_err(hdev, "Reading Intel version information failed (%ld)",\r\nPTR_ERR(skb));\r\nreturn PTR_ERR(skb);\r\n}\r\nif (skb->len != sizeof(*ver)) {\r\nbt_dev_err(hdev, "Intel version event size mismatch");\r\nkfree_skb(skb);\r\nreturn -EILSEQ;\r\n}\r\nmemcpy(ver, skb->data, sizeof(*ver));\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int regmap_ibt_read(void *context, const void *addr, size_t reg_size,\r\nvoid *val, size_t val_size)\r\n{\r\nstruct regmap_ibt_context *ctx = context;\r\nstruct ibt_cp_reg_access cp;\r\nstruct ibt_rp_reg_access *rp;\r\nstruct sk_buff *skb;\r\nint err = 0;\r\nif (reg_size != sizeof(__le32))\r\nreturn -EINVAL;\r\nswitch (val_size) {\r\ncase 1:\r\ncp.mode = IBT_REG_MODE_8BIT;\r\nbreak;\r\ncase 2:\r\ncp.mode = IBT_REG_MODE_16BIT;\r\nbreak;\r\ncase 4:\r\ncp.mode = IBT_REG_MODE_32BIT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncp.addr = *(__le32 *)addr;\r\ncp.len = val_size;\r\nbt_dev_dbg(ctx->hdev, "Register (0x%x) read", le32_to_cpu(cp.addr));\r\nskb = hci_cmd_sync(ctx->hdev, ctx->op_read, sizeof(cp), &cp,\r\nHCI_CMD_TIMEOUT);\r\nif (IS_ERR(skb)) {\r\nerr = PTR_ERR(skb);\r\nbt_dev_err(ctx->hdev, "regmap: Register (0x%x) read error (%d)",\r\nle32_to_cpu(cp.addr), err);\r\nreturn err;\r\n}\r\nif (skb->len != sizeof(*rp) + val_size) {\r\nbt_dev_err(ctx->hdev, "regmap: Register (0x%x) read error, bad len",\r\nle32_to_cpu(cp.addr));\r\nerr = -EINVAL;\r\ngoto done;\r\n}\r\nrp = (struct ibt_rp_reg_access *)skb->data;\r\nif (rp->addr != cp.addr) {\r\nbt_dev_err(ctx->hdev, "regmap: Register (0x%x) read error, bad addr",\r\nle32_to_cpu(rp->addr));\r\nerr = -EINVAL;\r\ngoto done;\r\n}\r\nmemcpy(val, rp->data, val_size);\r\ndone:\r\nkfree_skb(skb);\r\nreturn err;\r\n}\r\nstatic int regmap_ibt_gather_write(void *context,\r\nconst void *addr, size_t reg_size,\r\nconst void *val, size_t val_size)\r\n{\r\nstruct regmap_ibt_context *ctx = context;\r\nstruct ibt_cp_reg_access *cp;\r\nstruct sk_buff *skb;\r\nint plen = sizeof(*cp) + val_size;\r\nu8 mode;\r\nint err = 0;\r\nif (reg_size != sizeof(__le32))\r\nreturn -EINVAL;\r\nswitch (val_size) {\r\ncase 1:\r\nmode = IBT_REG_MODE_8BIT;\r\nbreak;\r\ncase 2:\r\nmode = IBT_REG_MODE_16BIT;\r\nbreak;\r\ncase 4:\r\nmode = IBT_REG_MODE_32BIT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncp = kmalloc(plen, GFP_KERNEL);\r\nif (!cp)\r\nreturn -ENOMEM;\r\ncp->addr = *(__le32 *)addr;\r\ncp->mode = mode;\r\ncp->len = val_size;\r\nmemcpy(&cp->data, val, val_size);\r\nbt_dev_dbg(ctx->hdev, "Register (0x%x) write", le32_to_cpu(cp->addr));\r\nskb = hci_cmd_sync(ctx->hdev, ctx->op_write, plen, cp, HCI_CMD_TIMEOUT);\r\nif (IS_ERR(skb)) {\r\nerr = PTR_ERR(skb);\r\nbt_dev_err(ctx->hdev, "regmap: Register (0x%x) write error (%d)",\r\nle32_to_cpu(cp->addr), err);\r\ngoto done;\r\n}\r\nkfree_skb(skb);\r\ndone:\r\nkfree(cp);\r\nreturn err;\r\n}\r\nstatic int regmap_ibt_write(void *context, const void *data, size_t count)\r\n{\r\nif (WARN_ONCE(count < 4, "Invalid register access"))\r\nreturn -EINVAL;\r\nreturn regmap_ibt_gather_write(context, data, 4, data + 4, count - 4);\r\n}\r\nstatic void regmap_ibt_free_context(void *context)\r\n{\r\nkfree(context);\r\n}\r\nstruct regmap *btintel_regmap_init(struct hci_dev *hdev, u16 opcode_read,\r\nu16 opcode_write)\r\n{\r\nstruct regmap_ibt_context *ctx;\r\nbt_dev_info(hdev, "regmap: Init R%x-W%x region", opcode_read,\r\nopcode_write);\r\nctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx)\r\nreturn ERR_PTR(-ENOMEM);\r\nctx->op_read = opcode_read;\r\nctx->op_write = opcode_write;\r\nctx->hdev = hdev;\r\nreturn regmap_init(&hdev->dev, &regmap_ibt, ctx, &regmap_ibt_cfg);\r\n}
