static int us5182d_oneshot_en(struct us5182d_data *data)\r\n{\r\nint ret;\r\nret = i2c_smbus_read_byte_data(data->client, US5182D_REG_CFG0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ret | US5182D_CFG0_ONESHOT_EN;\r\nreturn i2c_smbus_write_byte_data(data->client, US5182D_REG_CFG0, ret);\r\n}\r\nstatic int us5182d_set_opmode(struct us5182d_data *data, u8 mode)\r\n{\r\nint ret;\r\nif (mode == data->opmode)\r\nreturn 0;\r\nret = i2c_smbus_read_byte_data(data->client, US5182D_REG_CFG0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ret & ~US5182D_OPMODE_MASK;\r\nret = ret | (mode << US5182D_OPMODE_SHIFT);\r\nret = i2c_smbus_write_byte_data(data->client, US5182D_REG_CFG0, ret);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_smbus_write_byte_data(data->client, US5182D_REG_MODE_STORE,\r\nUS5182D_STORE_MODE);\r\nif (ret < 0)\r\nreturn ret;\r\ndata->opmode = mode;\r\nmsleep(US5182D_OPSTORE_SLEEP_TIME);\r\nreturn 0;\r\n}\r\nstatic int us5182d_als_enable(struct us5182d_data *data)\r\n{\r\nint ret;\r\nu8 mode;\r\nif (data->power_mode == US5182D_ONESHOT) {\r\nret = us5182d_set_opmode(data, US5182D_ALS_ONLY);\r\nif (ret < 0)\r\nreturn ret;\r\ndata->px_enabled = false;\r\n}\r\nif (data->als_enabled)\r\nreturn 0;\r\nmode = data->px_enabled ? US5182D_ALS_PX : US5182D_ALS_ONLY;\r\nret = us5182d_set_opmode(data, mode);\r\nif (ret < 0)\r\nreturn ret;\r\ndata->als_enabled = true;\r\nreturn 0;\r\n}\r\nstatic int us5182d_px_enable(struct us5182d_data *data)\r\n{\r\nint ret;\r\nu8 mode;\r\nif (data->power_mode == US5182D_ONESHOT) {\r\nret = us5182d_set_opmode(data, US5182D_PX_ONLY);\r\nif (ret < 0)\r\nreturn ret;\r\ndata->als_enabled = false;\r\n}\r\nif (data->px_enabled)\r\nreturn 0;\r\nmode = data->als_enabled ? US5182D_ALS_PX : US5182D_PX_ONLY;\r\nret = us5182d_set_opmode(data, mode);\r\nif (ret < 0)\r\nreturn ret;\r\ndata->px_enabled = true;\r\nreturn 0;\r\n}\r\nstatic int us5182d_get_als(struct us5182d_data *data)\r\n{\r\nint ret;\r\nunsigned long result;\r\nret = us5182d_als_enable(data);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_smbus_read_word_data(data->client,\r\nUS5182D_REG_ADL);\r\nif (ret < 0)\r\nreturn ret;\r\nresult = ret * data->ga / US5182D_GA_RESOLUTION;\r\nif (result > 0xffff)\r\nresult = 0xffff;\r\nreturn result;\r\n}\r\nstatic int us5182d_get_px(struct us5182d_data *data)\r\n{\r\nint ret;\r\nret = us5182d_px_enable(data);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn i2c_smbus_read_word_data(data->client,\r\nUS5182D_REG_PDL);\r\n}\r\nstatic int us5182d_shutdown_en(struct us5182d_data *data, u8 state)\r\n{\r\nint ret;\r\nif (data->power_mode == US5182D_ONESHOT)\r\nreturn 0;\r\nret = i2c_smbus_read_byte_data(data->client, US5182D_REG_CFG0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ret & ~US5182D_CFG0_SHUTDOWN_EN;\r\nret = ret | state;\r\nret = i2c_smbus_write_byte_data(data->client, US5182D_REG_CFG0, ret);\r\nif (ret < 0)\r\nreturn ret;\r\nif (state & US5182D_CFG0_SHUTDOWN_EN) {\r\ndata->als_enabled = false;\r\ndata->px_enabled = false;\r\n}\r\nreturn ret;\r\n}\r\nstatic int us5182d_set_power_state(struct us5182d_data *data, bool on)\r\n{\r\nint ret;\r\nif (data->power_mode == US5182D_ONESHOT)\r\nreturn 0;\r\nif (on) {\r\nret = pm_runtime_get_sync(&data->client->dev);\r\nif (ret < 0)\r\npm_runtime_put_noidle(&data->client->dev);\r\n} else {\r\npm_runtime_mark_last_busy(&data->client->dev);\r\nret = pm_runtime_put_autosuspend(&data->client->dev);\r\n}\r\nreturn ret;\r\n}\r\nstatic int us5182d_read_value(struct us5182d_data *data,\r\nstruct iio_chan_spec const *chan)\r\n{\r\nint ret, value;\r\nmutex_lock(&data->lock);\r\nif (data->power_mode == US5182D_ONESHOT) {\r\nret = us5182d_oneshot_en(data);\r\nif (ret < 0)\r\ngoto out_err;\r\n}\r\nret = us5182d_set_power_state(data, true);\r\nif (ret < 0)\r\ngoto out_err;\r\nif (chan->type == IIO_LIGHT)\r\nret = us5182d_get_als(data);\r\nelse\r\nret = us5182d_get_px(data);\r\nif (ret < 0)\r\ngoto out_poweroff;\r\nvalue = ret;\r\nret = us5182d_set_power_state(data, false);\r\nif (ret < 0)\r\ngoto out_err;\r\nmutex_unlock(&data->lock);\r\nreturn value;\r\nout_poweroff:\r\nus5182d_set_power_state(data, false);\r\nout_err:\r\nmutex_unlock(&data->lock);\r\nreturn ret;\r\n}\r\nstatic int us5182d_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan, int *val,\r\nint *val2, long mask)\r\n{\r\nstruct us5182d_data *data = iio_priv(indio_dev);\r\nint ret;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nret = us5182d_read_value(data, chan);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = ret;\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_SCALE:\r\nret = i2c_smbus_read_byte_data(data->client, US5182D_REG_CFG1);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = 0;\r\n*val2 = us5182d_scales[ret & US5182D_AGAIN_MASK];\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int us5182d_update_dark_th(struct us5182d_data *data, int index)\r\n{\r\n__be16 dark_th = cpu_to_be16(data->us5182d_dark_ths[index]);\r\nint ret;\r\nret = i2c_smbus_write_byte_data(data->client, US5182D_REG_UDARK_TH,\r\n((u8 *)&dark_th)[0]);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn i2c_smbus_write_byte_data(data->client, US5182D_REG_UDARK_TH + 1,\r\n((u8 *)&dark_th)[1]);\r\n}\r\nstatic int us5182d_apply_scale(struct us5182d_data *data, int index)\r\n{\r\nint ret;\r\nret = i2c_smbus_read_byte_data(data->client, US5182D_REG_CFG1);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ret & (~US5182D_AGAIN_MASK);\r\nret |= index;\r\nret = i2c_smbus_write_byte_data(data->client, US5182D_REG_CFG1, ret);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn us5182d_update_dark_th(data, index);\r\n}\r\nstatic int us5182d_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan, int val,\r\nint val2, long mask)\r\n{\r\nstruct us5182d_data *data = iio_priv(indio_dev);\r\nint ret, i;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_SCALE:\r\nif (val != 0)\r\nreturn -EINVAL;\r\nfor (i = 0; i < ARRAY_SIZE(us5182d_scales); i++)\r\nif (val2 == us5182d_scales[i]) {\r\nmutex_lock(&data->lock);\r\nret = us5182d_apply_scale(data, i);\r\nmutex_unlock(&data->lock);\r\nreturn ret;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int us5182d_setup_prox(struct iio_dev *indio_dev,\r\nenum iio_event_direction dir, u16 val)\r\n{\r\nstruct us5182d_data *data = iio_priv(indio_dev);\r\nif (dir == IIO_EV_DIR_FALLING)\r\nreturn i2c_smbus_write_word_data(data->client,\r\nUS5182D_REG_PXL_TH, val);\r\nelse if (dir == IIO_EV_DIR_RISING)\r\nreturn i2c_smbus_write_word_data(data->client,\r\nUS5182D_REG_PXH_TH, val);\r\nreturn 0;\r\n}\r\nstatic int us5182d_read_thresh(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan, enum iio_event_type type,\r\nenum iio_event_direction dir, enum iio_event_info info, int *val,\r\nint *val2)\r\n{\r\nstruct us5182d_data *data = iio_priv(indio_dev);\r\nswitch (dir) {\r\ncase IIO_EV_DIR_RISING:\r\nmutex_lock(&data->lock);\r\n*val = data->px_high_th;\r\nmutex_unlock(&data->lock);\r\nbreak;\r\ncase IIO_EV_DIR_FALLING:\r\nmutex_lock(&data->lock);\r\n*val = data->px_low_th;\r\nmutex_unlock(&data->lock);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn IIO_VAL_INT;\r\n}\r\nstatic int us5182d_write_thresh(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan, enum iio_event_type type,\r\nenum iio_event_direction dir, enum iio_event_info info, int val,\r\nint val2)\r\n{\r\nstruct us5182d_data *data = iio_priv(indio_dev);\r\nint ret;\r\nif (val < 0 || val > USHRT_MAX || val2 != 0)\r\nreturn -EINVAL;\r\nswitch (dir) {\r\ncase IIO_EV_DIR_RISING:\r\nmutex_lock(&data->lock);\r\nif (data->rising_en) {\r\nret = us5182d_setup_prox(indio_dev, dir, val);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\ndata->px_high_th = val;\r\nmutex_unlock(&data->lock);\r\nbreak;\r\ncase IIO_EV_DIR_FALLING:\r\nmutex_lock(&data->lock);\r\nif (data->falling_en) {\r\nret = us5182d_setup_prox(indio_dev, dir, val);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\ndata->px_low_th = val;\r\nmutex_unlock(&data->lock);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\nerr:\r\nmutex_unlock(&data->lock);\r\nreturn ret;\r\n}\r\nstatic int us5182d_read_event_config(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan, enum iio_event_type type,\r\nenum iio_event_direction dir)\r\n{\r\nstruct us5182d_data *data = iio_priv(indio_dev);\r\nint ret;\r\nswitch (dir) {\r\ncase IIO_EV_DIR_RISING:\r\nmutex_lock(&data->lock);\r\nret = data->rising_en;\r\nmutex_unlock(&data->lock);\r\nbreak;\r\ncase IIO_EV_DIR_FALLING:\r\nmutex_lock(&data->lock);\r\nret = data->falling_en;\r\nmutex_unlock(&data->lock);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int us5182d_write_event_config(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan, enum iio_event_type type,\r\nenum iio_event_direction dir, int state)\r\n{\r\nstruct us5182d_data *data = iio_priv(indio_dev);\r\nint ret;\r\nu16 new_th;\r\nmutex_lock(&data->lock);\r\nswitch (dir) {\r\ncase IIO_EV_DIR_RISING:\r\nif (data->rising_en == state) {\r\nmutex_unlock(&data->lock);\r\nreturn 0;\r\n}\r\nnew_th = US5182D_PXH_TH_DISABLE;\r\nif (state) {\r\ndata->power_mode = US5182D_CONTINUOUS;\r\nret = us5182d_set_power_state(data, true);\r\nif (ret < 0)\r\ngoto err;\r\nret = us5182d_px_enable(data);\r\nif (ret < 0)\r\ngoto err_poweroff;\r\nnew_th = data->px_high_th;\r\n}\r\nret = us5182d_setup_prox(indio_dev, dir, new_th);\r\nif (ret < 0)\r\ngoto err_poweroff;\r\ndata->rising_en = state;\r\nbreak;\r\ncase IIO_EV_DIR_FALLING:\r\nif (data->falling_en == state) {\r\nmutex_unlock(&data->lock);\r\nreturn 0;\r\n}\r\nnew_th = US5182D_PXL_TH_DISABLE;\r\nif (state) {\r\ndata->power_mode = US5182D_CONTINUOUS;\r\nret = us5182d_set_power_state(data, true);\r\nif (ret < 0)\r\ngoto err;\r\nret = us5182d_px_enable(data);\r\nif (ret < 0)\r\ngoto err_poweroff;\r\nnew_th = data->px_low_th;\r\n}\r\nret = us5182d_setup_prox(indio_dev, dir, new_th);\r\nif (ret < 0)\r\ngoto err_poweroff;\r\ndata->falling_en = state;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nif (!state) {\r\nret = us5182d_set_power_state(data, false);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nif (!data->falling_en && !data->rising_en && !data->default_continuous)\r\ndata->power_mode = US5182D_ONESHOT;\r\nmutex_unlock(&data->lock);\r\nreturn 0;\r\nerr_poweroff:\r\nif (state)\r\nus5182d_set_power_state(data, false);\r\nerr:\r\nmutex_unlock(&data->lock);\r\nreturn ret;\r\n}\r\nstatic int us5182d_reset(struct iio_dev *indio_dev)\r\n{\r\nstruct us5182d_data *data = iio_priv(indio_dev);\r\nreturn i2c_smbus_write_byte_data(data->client, US5182D_REG_CFG3,\r\nUS5182D_RESET_CHIP);\r\n}\r\nstatic int us5182d_init(struct iio_dev *indio_dev)\r\n{\r\nstruct us5182d_data *data = iio_priv(indio_dev);\r\nint i, ret;\r\nret = us5182d_reset(indio_dev);\r\nif (ret < 0)\r\nreturn ret;\r\ndata->opmode = 0;\r\ndata->power_mode = US5182D_CONTINUOUS;\r\ndata->px_low_th = US5182D_REG_PXL_TH_DEFAULT;\r\ndata->px_high_th = US5182D_REG_PXH_TH_DEFAULT;\r\nfor (i = 0; i < ARRAY_SIZE(us5182d_regvals); i++) {\r\nret = i2c_smbus_write_byte_data(data->client,\r\nus5182d_regvals[i].reg,\r\nus5182d_regvals[i].val);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\ndata->als_enabled = true;\r\ndata->px_enabled = true;\r\nif (!data->default_continuous) {\r\nret = us5182d_shutdown_en(data, US5182D_CFG0_SHUTDOWN_EN);\r\nif (ret < 0)\r\nreturn ret;\r\ndata->power_mode = US5182D_ONESHOT;\r\n}\r\nreturn ret;\r\n}\r\nstatic void us5182d_get_platform_data(struct iio_dev *indio_dev)\r\n{\r\nstruct us5182d_data *data = iio_priv(indio_dev);\r\nif (device_property_read_u32(&data->client->dev, "upisemi,glass-coef",\r\n&data->ga))\r\ndata->ga = US5182D_GA_RESOLUTION;\r\nif (device_property_read_u16_array(&data->client->dev,\r\n"upisemi,dark-ths",\r\ndata->us5182d_dark_ths,\r\nARRAY_SIZE(us5182d_dark_ths_vals)))\r\ndata->us5182d_dark_ths = us5182d_dark_ths_vals;\r\nif (device_property_read_u8(&data->client->dev,\r\n"upisemi,upper-dark-gain",\r\n&data->upper_dark_gain))\r\ndata->upper_dark_gain = US5182D_REG_AUTO_HDARK_GAIN_DEFAULT;\r\nif (device_property_read_u8(&data->client->dev,\r\n"upisemi,lower-dark-gain",\r\n&data->lower_dark_gain))\r\ndata->lower_dark_gain = US5182D_REG_AUTO_LDARK_GAIN_DEFAULT;\r\ndata->default_continuous = device_property_read_bool(&data->client->dev,\r\n"upisemi,continuous");\r\n}\r\nstatic int us5182d_dark_gain_config(struct iio_dev *indio_dev)\r\n{\r\nstruct us5182d_data *data = iio_priv(indio_dev);\r\nint ret;\r\nret = us5182d_update_dark_th(data, US5182D_CFG1_AGAIN_DEFAULT);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_smbus_write_byte_data(data->client,\r\nUS5182D_REG_AUTO_LDARK_GAIN,\r\ndata->lower_dark_gain);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_smbus_write_byte_data(data->client,\r\nUS5182D_REG_AUTO_HDARK_GAIN,\r\ndata->upper_dark_gain);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn i2c_smbus_write_byte_data(data->client, US5182D_REG_DARK_AUTO_EN,\r\nUS5182D_REG_DARK_AUTO_EN_DEFAULT);\r\n}\r\nstatic irqreturn_t us5182d_irq_thread_handler(int irq, void *private)\r\n{\r\nstruct iio_dev *indio_dev = private;\r\nstruct us5182d_data *data = iio_priv(indio_dev);\r\nenum iio_event_direction dir;\r\nint ret;\r\nu64 ev;\r\nret = i2c_smbus_read_byte_data(data->client, US5182D_REG_CFG0);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "i2c transfer error in irq\n");\r\nreturn IRQ_HANDLED;\r\n}\r\ndir = ret & US5182D_CFG0_PROX ? IIO_EV_DIR_RISING : IIO_EV_DIR_FALLING;\r\nev = IIO_UNMOD_EVENT_CODE(IIO_PROXIMITY, 1, IIO_EV_TYPE_THRESH, dir);\r\niio_push_event(indio_dev, ev, iio_get_time_ns(indio_dev));\r\nret = i2c_smbus_write_byte_data(data->client, US5182D_REG_CFG0,\r\nret & ~US5182D_CFG0_PX_IRQ);\r\nif (ret < 0)\r\ndev_err(&data->client->dev, "i2c transfer error in irq\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int us5182d_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct us5182d_data *data;\r\nstruct iio_dev *indio_dev;\r\nint ret;\r\nindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\ndata = iio_priv(indio_dev);\r\ni2c_set_clientdata(client, indio_dev);\r\ndata->client = client;\r\nmutex_init(&data->lock);\r\nindio_dev->dev.parent = &client->dev;\r\nindio_dev->info = &us5182d_info;\r\nindio_dev->name = US5182D_DRV_NAME;\r\nindio_dev->channels = us5182d_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(us5182d_channels);\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nret = i2c_smbus_read_byte_data(data->client, US5182D_REG_CHIPID);\r\nif (ret != US5182D_CHIPID) {\r\ndev_err(&data->client->dev,\r\n"Failed to detect US5182 light chip\n");\r\nreturn (ret < 0) ? ret : -ENODEV;\r\n}\r\nif (client->irq > 0) {\r\nret = devm_request_threaded_irq(&client->dev, client->irq, NULL,\r\nus5182d_irq_thread_handler,\r\nIRQF_TRIGGER_LOW | IRQF_ONESHOT,\r\n"us5182d-irq", indio_dev);\r\nif (ret < 0)\r\nreturn ret;\r\n} else\r\ndev_warn(&client->dev, "no valid irq found\n");\r\nus5182d_get_platform_data(indio_dev);\r\nret = us5182d_init(indio_dev);\r\nif (ret < 0)\r\nreturn ret;\r\nret = us5182d_dark_gain_config(indio_dev);\r\nif (ret < 0)\r\ngoto out_err;\r\nif (data->default_continuous) {\r\nret = pm_runtime_set_active(&client->dev);\r\nif (ret < 0)\r\ngoto out_err;\r\n}\r\npm_runtime_enable(&client->dev);\r\npm_runtime_set_autosuspend_delay(&client->dev,\r\nUS5182D_SLEEP_MS);\r\npm_runtime_use_autosuspend(&client->dev);\r\nret = iio_device_register(indio_dev);\r\nif (ret < 0)\r\ngoto out_err;\r\nreturn 0;\r\nout_err:\r\nus5182d_shutdown_en(data, US5182D_CFG0_SHUTDOWN_EN);\r\nreturn ret;\r\n}\r\nstatic int us5182d_remove(struct i2c_client *client)\r\n{\r\nstruct us5182d_data *data = iio_priv(i2c_get_clientdata(client));\r\niio_device_unregister(i2c_get_clientdata(client));\r\npm_runtime_disable(&client->dev);\r\npm_runtime_set_suspended(&client->dev);\r\nreturn us5182d_shutdown_en(data, US5182D_CFG0_SHUTDOWN_EN);\r\n}\r\nstatic int us5182d_suspend(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct us5182d_data *data = iio_priv(indio_dev);\r\nif (data->power_mode == US5182D_CONTINUOUS)\r\nreturn us5182d_shutdown_en(data, US5182D_CFG0_SHUTDOWN_EN);\r\nreturn 0;\r\n}\r\nstatic int us5182d_resume(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct us5182d_data *data = iio_priv(indio_dev);\r\nif (data->power_mode == US5182D_CONTINUOUS)\r\nreturn us5182d_shutdown_en(data,\r\n~US5182D_CFG0_SHUTDOWN_EN & 0xff);\r\nreturn 0;\r\n}
