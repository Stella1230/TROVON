bool omapdss_is_initialized(void)\r\n{\r\nreturn dss_initialized;\r\n}\r\nstatic inline void dss_write_reg(const struct dss_reg idx, u32 val)\r\n{\r\n__raw_writel(val, dss.base + idx.idx);\r\n}\r\nstatic inline u32 dss_read_reg(const struct dss_reg idx)\r\n{\r\nreturn __raw_readl(dss.base + idx.idx);\r\n}\r\nstatic void dss_save_context(void)\r\n{\r\nDSSDBG("dss_save_context\n");\r\nSR(CONTROL);\r\nif (dss_feat_get_supported_displays(OMAP_DSS_CHANNEL_LCD) &\r\nOMAP_DISPLAY_TYPE_SDI) {\r\nSR(SDI_CONTROL);\r\nSR(PLL_CONTROL);\r\n}\r\ndss.ctx_valid = true;\r\nDSSDBG("context saved\n");\r\n}\r\nstatic void dss_restore_context(void)\r\n{\r\nDSSDBG("dss_restore_context\n");\r\nif (!dss.ctx_valid)\r\nreturn;\r\nRR(CONTROL);\r\nif (dss_feat_get_supported_displays(OMAP_DSS_CHANNEL_LCD) &\r\nOMAP_DISPLAY_TYPE_SDI) {\r\nRR(SDI_CONTROL);\r\nRR(PLL_CONTROL);\r\n}\r\nDSSDBG("context restored\n");\r\n}\r\nvoid dss_ctrl_pll_enable(enum dss_pll_id pll_id, bool enable)\r\n{\r\nunsigned shift;\r\nunsigned val;\r\nif (!dss.syscon_pll_ctrl)\r\nreturn;\r\nval = !enable;\r\nswitch (pll_id) {\r\ncase DSS_PLL_VIDEO1:\r\nshift = 0;\r\nbreak;\r\ncase DSS_PLL_VIDEO2:\r\nshift = 1;\r\nbreak;\r\ncase DSS_PLL_HDMI:\r\nshift = 2;\r\nbreak;\r\ndefault:\r\nDSSERR("illegal DSS PLL ID %d\n", pll_id);\r\nreturn;\r\n}\r\nregmap_update_bits(dss.syscon_pll_ctrl, dss.syscon_pll_ctrl_offset,\r\n1 << shift, val << shift);\r\n}\r\nvoid dss_ctrl_pll_set_control_mux(enum dss_pll_id pll_id,\r\nenum omap_channel channel)\r\n{\r\nunsigned shift, val;\r\nif (!dss.syscon_pll_ctrl)\r\nreturn;\r\nswitch (channel) {\r\ncase OMAP_DSS_CHANNEL_LCD:\r\nshift = 3;\r\nswitch (pll_id) {\r\ncase DSS_PLL_VIDEO1:\r\nval = 0; break;\r\ncase DSS_PLL_HDMI:\r\nval = 1; break;\r\ndefault:\r\nDSSERR("error in PLL mux config for LCD\n");\r\nreturn;\r\n}\r\nbreak;\r\ncase OMAP_DSS_CHANNEL_LCD2:\r\nshift = 5;\r\nswitch (pll_id) {\r\ncase DSS_PLL_VIDEO1:\r\nval = 0; break;\r\ncase DSS_PLL_VIDEO2:\r\nval = 1; break;\r\ncase DSS_PLL_HDMI:\r\nval = 2; break;\r\ndefault:\r\nDSSERR("error in PLL mux config for LCD2\n");\r\nreturn;\r\n}\r\nbreak;\r\ncase OMAP_DSS_CHANNEL_LCD3:\r\nshift = 7;\r\nswitch (pll_id) {\r\ncase DSS_PLL_VIDEO1:\r\nval = 1; break;\r\ncase DSS_PLL_VIDEO2:\r\nval = 0; break;\r\ncase DSS_PLL_HDMI:\r\nval = 2; break;\r\ndefault:\r\nDSSERR("error in PLL mux config for LCD3\n");\r\nreturn;\r\n}\r\nbreak;\r\ndefault:\r\nDSSERR("error in PLL mux config\n");\r\nreturn;\r\n}\r\nregmap_update_bits(dss.syscon_pll_ctrl, dss.syscon_pll_ctrl_offset,\r\n0x3 << shift, val << shift);\r\n}\r\nvoid dss_sdi_init(int datapairs)\r\n{\r\nu32 l;\r\nBUG_ON(datapairs > 3 || datapairs < 1);\r\nl = dss_read_reg(DSS_SDI_CONTROL);\r\nl = FLD_MOD(l, 0xf, 19, 15);\r\nl = FLD_MOD(l, datapairs-1, 3, 2);\r\nl = FLD_MOD(l, 2, 1, 0);\r\ndss_write_reg(DSS_SDI_CONTROL, l);\r\nl = dss_read_reg(DSS_PLL_CONTROL);\r\nl = FLD_MOD(l, 0x7, 25, 22);\r\nl = FLD_MOD(l, 0xb, 16, 11);\r\nl = FLD_MOD(l, 0xb4, 10, 1);\r\ndss_write_reg(DSS_PLL_CONTROL, l);\r\n}\r\nint dss_sdi_enable(void)\r\n{\r\nunsigned long timeout;\r\ndispc_pck_free_enable(1);\r\nREG_FLD_MOD(DSS_PLL_CONTROL, 1, 18, 18);\r\nudelay(1);\r\nREG_FLD_MOD(DSS_PLL_CONTROL, 1, 28, 28);\r\ntimeout = jiffies + msecs_to_jiffies(500);\r\nwhile (dss_read_reg(DSS_SDI_STATUS) & (1 << 6)) {\r\nif (time_after_eq(jiffies, timeout)) {\r\nDSSERR("PLL lock request timed out\n");\r\ngoto err1;\r\n}\r\n}\r\nREG_FLD_MOD(DSS_PLL_CONTROL, 0, 28, 28);\r\ntimeout = jiffies + msecs_to_jiffies(500);\r\nwhile (!(dss_read_reg(DSS_SDI_STATUS) & (1 << 5))) {\r\nif (time_after_eq(jiffies, timeout)) {\r\nDSSERR("PLL lock timed out\n");\r\ngoto err1;\r\n}\r\n}\r\ndispc_lcd_enable_signal(1);\r\ntimeout = jiffies + msecs_to_jiffies(500);\r\nwhile (!(dss_read_reg(DSS_SDI_STATUS) & (1 << 2))) {\r\nif (time_after_eq(jiffies, timeout)) {\r\nDSSERR("SDI reset timed out\n");\r\ngoto err2;\r\n}\r\n}\r\nreturn 0;\r\nerr2:\r\ndispc_lcd_enable_signal(0);\r\nerr1:\r\nREG_FLD_MOD(DSS_PLL_CONTROL, 0, 18, 18);\r\ndispc_pck_free_enable(0);\r\nreturn -ETIMEDOUT;\r\n}\r\nvoid dss_sdi_disable(void)\r\n{\r\ndispc_lcd_enable_signal(0);\r\ndispc_pck_free_enable(0);\r\nREG_FLD_MOD(DSS_PLL_CONTROL, 0, 18, 18);\r\n}\r\nconst char *dss_get_generic_clk_source_name(enum omap_dss_clk_source clk_src)\r\n{\r\nreturn dss_generic_clk_source_names[clk_src];\r\n}\r\nvoid dss_dump_clocks(struct seq_file *s)\r\n{\r\nconst char *fclk_name, *fclk_real_name;\r\nunsigned long fclk_rate;\r\nif (dss_runtime_get())\r\nreturn;\r\nseq_printf(s, "- DSS -\n");\r\nfclk_name = dss_get_generic_clk_source_name(OMAP_DSS_CLK_SRC_FCK);\r\nfclk_real_name = dss_feat_get_clk_source_name(OMAP_DSS_CLK_SRC_FCK);\r\nfclk_rate = clk_get_rate(dss.dss_clk);\r\nseq_printf(s, "%s (%s) = %lu\n",\r\nfclk_name, fclk_real_name,\r\nfclk_rate);\r\ndss_runtime_put();\r\n}\r\nstatic void dss_dump_regs(struct seq_file *s)\r\n{\r\n#define DUMPREG(r) seq_printf(s, "%-35s %08x\n", #r, dss_read_reg(r))\r\nif (dss_runtime_get())\r\nreturn;\r\nDUMPREG(DSS_REVISION);\r\nDUMPREG(DSS_SYSCONFIG);\r\nDUMPREG(DSS_SYSSTATUS);\r\nDUMPREG(DSS_CONTROL);\r\nif (dss_feat_get_supported_displays(OMAP_DSS_CHANNEL_LCD) &\r\nOMAP_DISPLAY_TYPE_SDI) {\r\nDUMPREG(DSS_SDI_CONTROL);\r\nDUMPREG(DSS_PLL_CONTROL);\r\nDUMPREG(DSS_SDI_STATUS);\r\n}\r\ndss_runtime_put();\r\n#undef DUMPREG\r\n}\r\nstatic void dss_select_dispc_clk_source(enum omap_dss_clk_source clk_src)\r\n{\r\nint b;\r\nu8 start, end;\r\nswitch (clk_src) {\r\ncase OMAP_DSS_CLK_SRC_FCK:\r\nb = 0;\r\nbreak;\r\ncase OMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DISPC:\r\nb = 1;\r\nbreak;\r\ncase OMAP_DSS_CLK_SRC_DSI2_PLL_HSDIV_DISPC:\r\nb = 2;\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn;\r\n}\r\ndss_feat_get_reg_field(FEAT_REG_DISPC_CLK_SWITCH, &start, &end);\r\nREG_FLD_MOD(DSS_CONTROL, b, start, end);\r\ndss.dispc_clk_source = clk_src;\r\n}\r\nvoid dss_select_dsi_clk_source(int dsi_module,\r\nenum omap_dss_clk_source clk_src)\r\n{\r\nint b, pos;\r\nswitch (clk_src) {\r\ncase OMAP_DSS_CLK_SRC_FCK:\r\nb = 0;\r\nbreak;\r\ncase OMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DSI:\r\nBUG_ON(dsi_module != 0);\r\nb = 1;\r\nbreak;\r\ncase OMAP_DSS_CLK_SRC_DSI2_PLL_HSDIV_DSI:\r\nBUG_ON(dsi_module != 1);\r\nb = 1;\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn;\r\n}\r\npos = dsi_module == 0 ? 1 : 10;\r\nREG_FLD_MOD(DSS_CONTROL, b, pos, pos);\r\ndss.dsi_clk_source[dsi_module] = clk_src;\r\n}\r\nvoid dss_select_lcd_clk_source(enum omap_channel channel,\r\nenum omap_dss_clk_source clk_src)\r\n{\r\nint b, ix, pos;\r\nif (!dss_has_feature(FEAT_LCD_CLK_SRC)) {\r\ndss_select_dispc_clk_source(clk_src);\r\nreturn;\r\n}\r\nswitch (clk_src) {\r\ncase OMAP_DSS_CLK_SRC_FCK:\r\nb = 0;\r\nbreak;\r\ncase OMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DISPC:\r\nBUG_ON(channel != OMAP_DSS_CHANNEL_LCD);\r\nb = 1;\r\nbreak;\r\ncase OMAP_DSS_CLK_SRC_DSI2_PLL_HSDIV_DISPC:\r\nBUG_ON(channel != OMAP_DSS_CHANNEL_LCD2 &&\r\nchannel != OMAP_DSS_CHANNEL_LCD3);\r\nb = 1;\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn;\r\n}\r\npos = channel == OMAP_DSS_CHANNEL_LCD ? 0 :\r\n(channel == OMAP_DSS_CHANNEL_LCD2 ? 12 : 19);\r\nREG_FLD_MOD(DSS_CONTROL, b, pos, pos);\r\nix = channel == OMAP_DSS_CHANNEL_LCD ? 0 :\r\n(channel == OMAP_DSS_CHANNEL_LCD2 ? 1 : 2);\r\ndss.lcd_clk_source[ix] = clk_src;\r\n}\r\nenum omap_dss_clk_source dss_get_dispc_clk_source(void)\r\n{\r\nreturn dss.dispc_clk_source;\r\n}\r\nenum omap_dss_clk_source dss_get_dsi_clk_source(int dsi_module)\r\n{\r\nreturn dss.dsi_clk_source[dsi_module];\r\n}\r\nenum omap_dss_clk_source dss_get_lcd_clk_source(enum omap_channel channel)\r\n{\r\nif (dss_has_feature(FEAT_LCD_CLK_SRC)) {\r\nint ix = channel == OMAP_DSS_CHANNEL_LCD ? 0 :\r\n(channel == OMAP_DSS_CHANNEL_LCD2 ? 1 : 2);\r\nreturn dss.lcd_clk_source[ix];\r\n} else {\r\nreturn dss.dispc_clk_source;\r\n}\r\n}\r\nbool dss_div_calc(unsigned long pck, unsigned long fck_min,\r\ndss_div_calc_func func, void *data)\r\n{\r\nint fckd, fckd_start, fckd_stop;\r\nunsigned long fck;\r\nunsigned long fck_hw_max;\r\nunsigned long fckd_hw_max;\r\nunsigned long prate;\r\nunsigned m;\r\nfck_hw_max = dss_feat_get_param_max(FEAT_PARAM_DSS_FCK);\r\nif (dss.parent_clk == NULL) {\r\nunsigned pckd;\r\npckd = fck_hw_max / pck;\r\nfck = pck * pckd;\r\nfck = clk_round_rate(dss.dss_clk, fck);\r\nreturn func(fck, data);\r\n}\r\nfckd_hw_max = dss.feat->fck_div_max;\r\nm = dss.feat->dss_fck_multiplier;\r\nprate = clk_get_rate(dss.parent_clk);\r\nfck_min = fck_min ? fck_min : 1;\r\nfckd_start = min(prate * m / fck_min, fckd_hw_max);\r\nfckd_stop = max(DIV_ROUND_UP(prate * m, fck_hw_max), 1ul);\r\nfor (fckd = fckd_start; fckd >= fckd_stop; --fckd) {\r\nfck = DIV_ROUND_UP(prate, fckd) * m;\r\nif (func(fck, data))\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nint dss_set_fck_rate(unsigned long rate)\r\n{\r\nint r;\r\nDSSDBG("set fck to %lu\n", rate);\r\nr = clk_set_rate(dss.dss_clk, rate);\r\nif (r)\r\nreturn r;\r\ndss.dss_clk_rate = clk_get_rate(dss.dss_clk);\r\nWARN_ONCE(dss.dss_clk_rate != rate,\r\n"clk rate mismatch: %lu != %lu", dss.dss_clk_rate,\r\nrate);\r\nreturn 0;\r\n}\r\nunsigned long dss_get_dispc_clk_rate(void)\r\n{\r\nreturn dss.dss_clk_rate;\r\n}\r\nstatic int dss_setup_default_clock(void)\r\n{\r\nunsigned long max_dss_fck, prate;\r\nunsigned long fck;\r\nunsigned fck_div;\r\nint r;\r\nmax_dss_fck = dss_feat_get_param_max(FEAT_PARAM_DSS_FCK);\r\nif (dss.parent_clk == NULL) {\r\nfck = clk_round_rate(dss.dss_clk, max_dss_fck);\r\n} else {\r\nprate = clk_get_rate(dss.parent_clk);\r\nfck_div = DIV_ROUND_UP(prate * dss.feat->dss_fck_multiplier,\r\nmax_dss_fck);\r\nfck = DIV_ROUND_UP(prate, fck_div) * dss.feat->dss_fck_multiplier;\r\n}\r\nr = dss_set_fck_rate(fck);\r\nif (r)\r\nreturn r;\r\nreturn 0;\r\n}\r\nvoid dss_set_venc_output(enum omap_dss_venc_type type)\r\n{\r\nint l = 0;\r\nif (type == OMAP_DSS_VENC_TYPE_COMPOSITE)\r\nl = 0;\r\nelse if (type == OMAP_DSS_VENC_TYPE_SVIDEO)\r\nl = 1;\r\nelse\r\nBUG();\r\nREG_FLD_MOD(DSS_CONTROL, l, 6, 6);\r\n}\r\nvoid dss_set_dac_pwrdn_bgz(bool enable)\r\n{\r\nREG_FLD_MOD(DSS_CONTROL, enable, 5, 5);\r\n}\r\nvoid dss_select_hdmi_venc_clk_source(enum dss_hdmi_venc_clk_source_select src)\r\n{\r\nenum omap_display_type dp;\r\ndp = dss_feat_get_supported_displays(OMAP_DSS_CHANNEL_DIGIT);\r\nWARN_ON((src == DSS_VENC_TV_CLK) && !(dp & OMAP_DISPLAY_TYPE_VENC));\r\nWARN_ON((src == DSS_HDMI_M_PCLK) && !(dp & OMAP_DISPLAY_TYPE_HDMI));\r\nif ((dp & OMAP_DISPLAY_TYPE_VENC) && (dp & OMAP_DISPLAY_TYPE_HDMI))\r\nREG_FLD_MOD(DSS_CONTROL, src, 15, 15);\r\n}\r\nenum dss_hdmi_venc_clk_source_select dss_get_hdmi_venc_clk_source(void)\r\n{\r\nenum omap_display_type displays;\r\ndisplays = dss_feat_get_supported_displays(OMAP_DSS_CHANNEL_DIGIT);\r\nif ((displays & OMAP_DISPLAY_TYPE_HDMI) == 0)\r\nreturn DSS_VENC_TV_CLK;\r\nif ((displays & OMAP_DISPLAY_TYPE_VENC) == 0)\r\nreturn DSS_HDMI_M_PCLK;\r\nreturn REG_GET(DSS_CONTROL, 15, 15);\r\n}\r\nstatic int dss_dpi_select_source_omap2_omap3(int port, enum omap_channel channel)\r\n{\r\nif (channel != OMAP_DSS_CHANNEL_LCD)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int dss_dpi_select_source_omap4(int port, enum omap_channel channel)\r\n{\r\nint val;\r\nswitch (channel) {\r\ncase OMAP_DSS_CHANNEL_LCD2:\r\nval = 0;\r\nbreak;\r\ncase OMAP_DSS_CHANNEL_DIGIT:\r\nval = 1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nREG_FLD_MOD(DSS_CONTROL, val, 17, 17);\r\nreturn 0;\r\n}\r\nstatic int dss_dpi_select_source_omap5(int port, enum omap_channel channel)\r\n{\r\nint val;\r\nswitch (channel) {\r\ncase OMAP_DSS_CHANNEL_LCD:\r\nval = 1;\r\nbreak;\r\ncase OMAP_DSS_CHANNEL_LCD2:\r\nval = 2;\r\nbreak;\r\ncase OMAP_DSS_CHANNEL_LCD3:\r\nval = 3;\r\nbreak;\r\ncase OMAP_DSS_CHANNEL_DIGIT:\r\nval = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nREG_FLD_MOD(DSS_CONTROL, val, 17, 16);\r\nreturn 0;\r\n}\r\nstatic int dss_dpi_select_source_dra7xx(int port, enum omap_channel channel)\r\n{\r\nswitch (port) {\r\ncase 0:\r\nreturn dss_dpi_select_source_omap5(port, channel);\r\ncase 1:\r\nif (channel != OMAP_DSS_CHANNEL_LCD2)\r\nreturn -EINVAL;\r\nbreak;\r\ncase 2:\r\nif (channel != OMAP_DSS_CHANNEL_LCD3)\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint dss_dpi_select_source(int port, enum omap_channel channel)\r\n{\r\nreturn dss.feat->dpi_select_source(port, channel);\r\n}\r\nstatic int dss_get_clocks(void)\r\n{\r\nstruct clk *clk;\r\nclk = devm_clk_get(&dss.pdev->dev, "fck");\r\nif (IS_ERR(clk)) {\r\nDSSERR("can't get clock fck\n");\r\nreturn PTR_ERR(clk);\r\n}\r\ndss.dss_clk = clk;\r\nif (dss.feat->parent_clk_name) {\r\nclk = clk_get(NULL, dss.feat->parent_clk_name);\r\nif (IS_ERR(clk)) {\r\nDSSERR("Failed to get %s\n", dss.feat->parent_clk_name);\r\nreturn PTR_ERR(clk);\r\n}\r\n} else {\r\nclk = NULL;\r\n}\r\ndss.parent_clk = clk;\r\nreturn 0;\r\n}\r\nstatic void dss_put_clocks(void)\r\n{\r\nif (dss.parent_clk)\r\nclk_put(dss.parent_clk);\r\n}\r\nint dss_runtime_get(void)\r\n{\r\nint r;\r\nDSSDBG("dss_runtime_get\n");\r\nr = pm_runtime_get_sync(&dss.pdev->dev);\r\nWARN_ON(r < 0);\r\nreturn r < 0 ? r : 0;\r\n}\r\nvoid dss_runtime_put(void)\r\n{\r\nint r;\r\nDSSDBG("dss_runtime_put\n");\r\nr = pm_runtime_put_sync(&dss.pdev->dev);\r\nWARN_ON(r < 0 && r != -ENOSYS && r != -EBUSY);\r\n}\r\nvoid dss_debug_dump_clocks(struct seq_file *s)\r\n{\r\ndss_dump_clocks(s);\r\ndispc_dump_clocks(s);\r\n#ifdef CONFIG_FB_OMAP2_DSS_DSI\r\ndsi_dump_clocks(s);\r\n#endif\r\n}\r\nstatic int dss_init_features(struct platform_device *pdev)\r\n{\r\nconst struct dss_features *src;\r\nstruct dss_features *dst;\r\ndst = devm_kzalloc(&pdev->dev, sizeof(*dst), GFP_KERNEL);\r\nif (!dst) {\r\ndev_err(&pdev->dev, "Failed to allocate local DSS Features\n");\r\nreturn -ENOMEM;\r\n}\r\nswitch (omapdss_get_version()) {\r\ncase OMAPDSS_VER_OMAP24xx:\r\nsrc = &omap24xx_dss_feats;\r\nbreak;\r\ncase OMAPDSS_VER_OMAP34xx_ES1:\r\ncase OMAPDSS_VER_OMAP34xx_ES3:\r\ncase OMAPDSS_VER_AM35xx:\r\nsrc = &omap34xx_dss_feats;\r\nbreak;\r\ncase OMAPDSS_VER_OMAP3630:\r\nsrc = &omap3630_dss_feats;\r\nbreak;\r\ncase OMAPDSS_VER_OMAP4430_ES1:\r\ncase OMAPDSS_VER_OMAP4430_ES2:\r\ncase OMAPDSS_VER_OMAP4:\r\nsrc = &omap44xx_dss_feats;\r\nbreak;\r\ncase OMAPDSS_VER_OMAP5:\r\nsrc = &omap54xx_dss_feats;\r\nbreak;\r\ncase OMAPDSS_VER_AM43xx:\r\nsrc = &am43xx_dss_feats;\r\nbreak;\r\ncase OMAPDSS_VER_DRA7xx:\r\nsrc = &dra7xx_dss_feats;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nmemcpy(dst, src, sizeof(*dst));\r\ndss.feat = dst;\r\nreturn 0;\r\n}\r\nstatic int dss_init_ports(struct platform_device *pdev)\r\n{\r\nstruct device_node *parent = pdev->dev.of_node;\r\nstruct device_node *port;\r\nint r, ret = 0;\r\nif (parent == NULL)\r\nreturn 0;\r\nport = omapdss_of_get_next_port(parent, NULL);\r\nif (!port)\r\nreturn 0;\r\nif (dss.feat->num_ports == 0)\r\nreturn 0;\r\ndo {\r\nenum omap_display_type port_type;\r\nu32 reg;\r\nr = of_property_read_u32(port, "reg", &reg);\r\nif (r)\r\nreg = 0;\r\nif (reg >= dss.feat->num_ports)\r\ncontinue;\r\nport_type = dss.feat->ports[reg];\r\nswitch (port_type) {\r\ncase OMAP_DISPLAY_TYPE_DPI:\r\nret = dpi_init_port(pdev, port);\r\nbreak;\r\ncase OMAP_DISPLAY_TYPE_SDI:\r\nret = sdi_init_port(pdev, port);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} while (!ret &&\r\n(port = omapdss_of_get_next_port(parent, port)) != NULL);\r\nif (ret)\r\ndss_uninit_ports(pdev);\r\nreturn ret;\r\n}\r\nstatic void dss_uninit_ports(struct platform_device *pdev)\r\n{\r\nstruct device_node *parent = pdev->dev.of_node;\r\nstruct device_node *port;\r\nif (parent == NULL)\r\nreturn;\r\nport = omapdss_of_get_next_port(parent, NULL);\r\nif (!port)\r\nreturn;\r\nif (dss.feat->num_ports == 0)\r\nreturn;\r\ndo {\r\nenum omap_display_type port_type;\r\nu32 reg;\r\nint r;\r\nr = of_property_read_u32(port, "reg", &reg);\r\nif (r)\r\nreg = 0;\r\nif (reg >= dss.feat->num_ports)\r\ncontinue;\r\nport_type = dss.feat->ports[reg];\r\nswitch (port_type) {\r\ncase OMAP_DISPLAY_TYPE_DPI:\r\ndpi_uninit_port(port);\r\nbreak;\r\ncase OMAP_DISPLAY_TYPE_SDI:\r\nsdi_uninit_port(port);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} while ((port = omapdss_of_get_next_port(parent, port)) != NULL);\r\n}\r\nstatic int dss_video_pll_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct regulator *pll_regulator;\r\nint r;\r\nif (!np)\r\nreturn 0;\r\nif (of_property_read_bool(np, "syscon-pll-ctrl")) {\r\ndss.syscon_pll_ctrl = syscon_regmap_lookup_by_phandle(np,\r\n"syscon-pll-ctrl");\r\nif (IS_ERR(dss.syscon_pll_ctrl)) {\r\ndev_err(&pdev->dev,\r\n"failed to get syscon-pll-ctrl regmap\n");\r\nreturn PTR_ERR(dss.syscon_pll_ctrl);\r\n}\r\nif (of_property_read_u32_index(np, "syscon-pll-ctrl", 1,\r\n&dss.syscon_pll_ctrl_offset)) {\r\ndev_err(&pdev->dev,\r\n"failed to get syscon-pll-ctrl offset\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\npll_regulator = devm_regulator_get(&pdev->dev, "vdda_video");\r\nif (IS_ERR(pll_regulator)) {\r\nr = PTR_ERR(pll_regulator);\r\nswitch (r) {\r\ncase -ENOENT:\r\npll_regulator = NULL;\r\nbreak;\r\ncase -EPROBE_DEFER:\r\nreturn -EPROBE_DEFER;\r\ndefault:\r\nDSSERR("can't get DPLL VDDA regulator\n");\r\nreturn r;\r\n}\r\n}\r\nif (of_property_match_string(np, "reg-names", "pll1") >= 0) {\r\ndss.video1_pll = dss_video_pll_init(pdev, 0, pll_regulator);\r\nif (IS_ERR(dss.video1_pll))\r\nreturn PTR_ERR(dss.video1_pll);\r\n}\r\nif (of_property_match_string(np, "reg-names", "pll2") >= 0) {\r\ndss.video2_pll = dss_video_pll_init(pdev, 1, pll_regulator);\r\nif (IS_ERR(dss.video2_pll)) {\r\ndss_video_pll_uninit(dss.video1_pll);\r\nreturn PTR_ERR(dss.video2_pll);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int dss_bind(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct resource *dss_mem;\r\nu32 rev;\r\nint r;\r\ndss.pdev = pdev;\r\nr = dss_init_features(dss.pdev);\r\nif (r)\r\nreturn r;\r\ndss_mem = platform_get_resource(dss.pdev, IORESOURCE_MEM, 0);\r\nif (!dss_mem) {\r\nDSSERR("can't get IORESOURCE_MEM DSS\n");\r\nreturn -EINVAL;\r\n}\r\ndss.base = devm_ioremap(&pdev->dev, dss_mem->start,\r\nresource_size(dss_mem));\r\nif (!dss.base) {\r\nDSSERR("can't ioremap DSS\n");\r\nreturn -ENOMEM;\r\n}\r\nr = dss_get_clocks();\r\nif (r)\r\nreturn r;\r\nr = dss_setup_default_clock();\r\nif (r)\r\ngoto err_setup_clocks;\r\nr = dss_video_pll_probe(pdev);\r\nif (r)\r\ngoto err_pll_init;\r\nr = dss_init_ports(pdev);\r\nif (r)\r\ngoto err_init_ports;\r\npm_runtime_enable(&pdev->dev);\r\nr = dss_runtime_get();\r\nif (r)\r\ngoto err_runtime_get;\r\ndss.dss_clk_rate = clk_get_rate(dss.dss_clk);\r\nREG_FLD_MOD(DSS_CONTROL, 0, 0, 0);\r\ndss_select_dispc_clk_source(OMAP_DSS_CLK_SRC_FCK);\r\n#ifdef CONFIG_FB_OMAP2_DSS_VENC\r\nREG_FLD_MOD(DSS_CONTROL, 1, 4, 4);\r\nREG_FLD_MOD(DSS_CONTROL, 1, 3, 3);\r\nREG_FLD_MOD(DSS_CONTROL, 0, 2, 2);\r\n#endif\r\ndss.dsi_clk_source[0] = OMAP_DSS_CLK_SRC_FCK;\r\ndss.dsi_clk_source[1] = OMAP_DSS_CLK_SRC_FCK;\r\ndss.dispc_clk_source = OMAP_DSS_CLK_SRC_FCK;\r\ndss.lcd_clk_source[0] = OMAP_DSS_CLK_SRC_FCK;\r\ndss.lcd_clk_source[1] = OMAP_DSS_CLK_SRC_FCK;\r\nrev = dss_read_reg(DSS_REVISION);\r\nprintk(KERN_INFO "OMAP DSS rev %d.%d\n",\r\nFLD_GET(rev, 7, 4), FLD_GET(rev, 3, 0));\r\ndss_runtime_put();\r\nr = component_bind_all(&pdev->dev, NULL);\r\nif (r)\r\ngoto err_component;\r\ndss_debugfs_create_file("dss", dss_dump_regs);\r\npm_set_vt_switch(0);\r\ndss_initialized = true;\r\nreturn 0;\r\nerr_component:\r\nerr_runtime_get:\r\npm_runtime_disable(&pdev->dev);\r\ndss_uninit_ports(pdev);\r\nerr_init_ports:\r\nif (dss.video1_pll)\r\ndss_video_pll_uninit(dss.video1_pll);\r\nif (dss.video2_pll)\r\ndss_video_pll_uninit(dss.video2_pll);\r\nerr_pll_init:\r\nerr_setup_clocks:\r\ndss_put_clocks();\r\nreturn r;\r\n}\r\nstatic void dss_unbind(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\ndss_initialized = false;\r\ncomponent_unbind_all(&pdev->dev, NULL);\r\nif (dss.video1_pll)\r\ndss_video_pll_uninit(dss.video1_pll);\r\nif (dss.video2_pll)\r\ndss_video_pll_uninit(dss.video2_pll);\r\ndss_uninit_ports(pdev);\r\npm_runtime_disable(&pdev->dev);\r\ndss_put_clocks();\r\n}\r\nstatic int dss_component_compare(struct device *dev, void *data)\r\n{\r\nstruct device *child = data;\r\nreturn dev == child;\r\n}\r\nstatic int dss_add_child_component(struct device *dev, void *data)\r\n{\r\nstruct component_match **match = data;\r\nif (strstr(dev_name(dev), "rfbi"))\r\nreturn 0;\r\ncomponent_match_add(dev->parent, match, dss_component_compare, dev);\r\nreturn 0;\r\n}\r\nstatic int dss_probe(struct platform_device *pdev)\r\n{\r\nstruct component_match *match = NULL;\r\nint r;\r\ndevice_for_each_child(&pdev->dev, &match, dss_add_child_component);\r\nr = component_master_add_with_match(&pdev->dev, &dss_component_ops, match);\r\nif (r)\r\nreturn r;\r\nreturn 0;\r\n}\r\nstatic int dss_remove(struct platform_device *pdev)\r\n{\r\ncomponent_master_del(&pdev->dev, &dss_component_ops);\r\nreturn 0;\r\n}\r\nstatic int dss_runtime_suspend(struct device *dev)\r\n{\r\ndss_save_context();\r\ndss_set_min_bus_tput(dev, 0);\r\npinctrl_pm_select_sleep_state(dev);\r\nreturn 0;\r\n}\r\nstatic int dss_runtime_resume(struct device *dev)\r\n{\r\nint r;\r\npinctrl_pm_select_default_state(dev);\r\nr = dss_set_min_bus_tput(dev, 1000000000);\r\nif (r)\r\nreturn r;\r\ndss_restore_context();\r\nreturn 0;\r\n}\r\nint __init dss_init_platform_driver(void)\r\n{\r\nreturn platform_driver_register(&omap_dsshw_driver);\r\n}\r\nvoid dss_uninit_platform_driver(void)\r\n{\r\nplatform_driver_unregister(&omap_dsshw_driver);\r\n}
