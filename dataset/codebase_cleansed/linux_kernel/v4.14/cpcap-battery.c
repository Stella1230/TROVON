static struct cpcap_battery_state_data *\r\ncpcap_battery_get_state(struct cpcap_battery_ddata *ddata,\r\nenum cpcap_battery_state state)\r\n{\r\nif (state >= CPCAP_BATTERY_STATE_NR)\r\nreturn NULL;\r\nreturn &ddata->state[state];\r\n}\r\nstatic struct cpcap_battery_state_data *\r\ncpcap_battery_latest(struct cpcap_battery_ddata *ddata)\r\n{\r\nreturn cpcap_battery_get_state(ddata, CPCAP_BATTERY_STATE_LATEST);\r\n}\r\nstatic struct cpcap_battery_state_data *\r\ncpcap_battery_previous(struct cpcap_battery_ddata *ddata)\r\n{\r\nreturn cpcap_battery_get_state(ddata, CPCAP_BATTERY_STATE_PREVIOUS);\r\n}\r\nstatic int cpcap_charger_battery_temperature(struct cpcap_battery_ddata *ddata,\r\nint *value)\r\n{\r\nstruct iio_channel *channel;\r\nint error;\r\nchannel = ddata->channels[CPCAP_BATTERY_IIO_BATTDET];\r\nerror = iio_read_channel_processed(channel, value);\r\nif (error < 0) {\r\ndev_warn(ddata->dev, "%s failed: %i\n", __func__, error);\r\n*value = CPCAP_NO_BATTERY;\r\nreturn error;\r\n}\r\n*value /= 100;\r\nreturn 0;\r\n}\r\nstatic int cpcap_battery_get_voltage(struct cpcap_battery_ddata *ddata)\r\n{\r\nstruct iio_channel *channel;\r\nint error, value = 0;\r\nchannel = ddata->channels[CPCAP_BATTERY_IIO_VOLTAGE];\r\nerror = iio_read_channel_processed(channel, &value);\r\nif (error < 0) {\r\ndev_warn(ddata->dev, "%s failed: %i\n", __func__, error);\r\nreturn 0;\r\n}\r\nreturn value * 1000;\r\n}\r\nstatic int cpcap_battery_get_current(struct cpcap_battery_ddata *ddata)\r\n{\r\nstruct iio_channel *channel;\r\nint error, value = 0;\r\nchannel = ddata->channels[CPCAP_BATTERY_IIO_BATT_CURRENT];\r\nerror = iio_read_channel_processed(channel, &value);\r\nif (error < 0) {\r\ndev_warn(ddata->dev, "%s failed: %i\n", __func__, error);\r\nreturn 0;\r\n}\r\nreturn value * 1000;\r\n}\r\nstatic int cpcap_battery_cc_raw_div(struct cpcap_battery_ddata *ddata,\r\nu32 sample, s32 accumulator,\r\ns16 offset, u32 divider)\r\n{\r\ns64 acc;\r\nu64 tmp;\r\nint avg_current;\r\nu32 cc_lsb;\r\nsample &= 0xffffff;\r\noffset &= 0x7ff;\r\nswitch (ddata->vendor) {\r\ncase CPCAP_VENDOR_ST:\r\ncc_lsb = 95374;\r\nbreak;\r\ncase CPCAP_VENDOR_TI:\r\ncc_lsb = 91501;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nacc = accumulator;\r\nacc = acc - ((s64)sample * offset);\r\ncc_lsb = (cc_lsb * ddata->config.cd_factor) / 1000;\r\nif (acc >= 0)\r\ntmp = acc;\r\nelse\r\ntmp = acc * -1;\r\ntmp = tmp * cc_lsb;\r\ndo_div(tmp, divider);\r\navg_current = tmp;\r\nif (acc >= 0)\r\nreturn -avg_current;\r\nelse\r\nreturn avg_current;\r\n}\r\nstatic int cpcap_battery_cc_to_uah(struct cpcap_battery_ddata *ddata,\r\nu32 sample, s32 accumulator,\r\ns16 offset)\r\n{\r\nreturn cpcap_battery_cc_raw_div(ddata, sample,\r\naccumulator, offset,\r\n3600000);\r\n}\r\nstatic int cpcap_battery_cc_to_ua(struct cpcap_battery_ddata *ddata,\r\nu32 sample, s32 accumulator,\r\ns16 offset)\r\n{\r\nreturn cpcap_battery_cc_raw_div(ddata, sample,\r\naccumulator, offset,\r\nsample *\r\nCPCAP_BATTERY_CC_SAMPLE_PERIOD_MS);\r\n}\r\nstatic int\r\ncpcap_battery_read_accumulated(struct cpcap_battery_ddata *ddata,\r\nstruct cpcap_coulomb_counter_data *ccd)\r\n{\r\nu16 buf[7];\r\nint error;\r\nccd->sample = 0;\r\nccd->accumulator = 0;\r\nccd->offset = 0;\r\nerror = regmap_bulk_read(ddata->reg, CPCAP_REG_CCS1,\r\nbuf, ARRAY_SIZE(buf));\r\nif (error)\r\nreturn 0;\r\nccd->sample = (buf[1] & 0x0fff) << 16;\r\nccd->sample |= buf[0];\r\nccd->accumulator = ((s16)buf[3]) << 16;\r\nccd->accumulator |= buf[2];\r\nccd->offset = buf[5];\r\nif (buf[4] >= 0x200)\r\nccd->offset |= 0xfc00;\r\nreturn cpcap_battery_cc_to_uah(ddata,\r\nccd->sample,\r\nccd->accumulator,\r\nccd->offset);\r\n}\r\nstatic int cpcap_battery_cc_get_avg_current(struct cpcap_battery_ddata *ddata)\r\n{\r\nint value, acc, error;\r\ns32 sample = 1;\r\ns16 offset;\r\nif (ddata->vendor == CPCAP_VENDOR_ST)\r\nsample = 4;\r\nerror = regmap_read(ddata->reg, CPCAP_REG_CCI, &value);\r\nif (error)\r\nreturn error;\r\nif ((ddata->vendor == CPCAP_VENDOR_TI) && (value > 0x2000))\r\nvalue = value | 0xc000;\r\nacc = (s16)value;\r\nerror = regmap_read(ddata->reg, CPCAP_REG_CCM, &value);\r\nif (error)\r\nreturn error;\r\nif (value < 0x200)\r\noffset = value;\r\nelse\r\noffset = value | 0xfc00;\r\nreturn cpcap_battery_cc_to_ua(ddata, sample, acc, offset);\r\n}\r\nstatic bool cpcap_battery_full(struct cpcap_battery_ddata *ddata)\r\n{\r\nstruct cpcap_battery_state_data *state = cpcap_battery_latest(ddata);\r\nif (state->voltage >= (ddata->config.info.voltage_max_design - 4000))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int cpcap_battery_update_status(struct cpcap_battery_ddata *ddata)\r\n{\r\nstruct cpcap_battery_state_data state, *latest, *previous;\r\nktime_t now;\r\nint error;\r\nmemset(&state, 0, sizeof(state));\r\nnow = ktime_get();\r\nlatest = cpcap_battery_latest(ddata);\r\nif (latest) {\r\ns64 delta_ms = ktime_to_ms(ktime_sub(now, latest->time));\r\nif (delta_ms < CPCAP_BATTERY_CC_SAMPLE_PERIOD_MS)\r\nreturn delta_ms;\r\n}\r\nstate.time = now;\r\nstate.voltage = cpcap_battery_get_voltage(ddata);\r\nstate.current_ua = cpcap_battery_get_current(ddata);\r\nstate.counter_uah = cpcap_battery_read_accumulated(ddata, &state.cc);\r\nerror = cpcap_charger_battery_temperature(ddata,\r\n&state.temperature);\r\nif (error)\r\nreturn error;\r\nprevious = cpcap_battery_previous(ddata);\r\nmemcpy(previous, latest, sizeof(*previous));\r\nmemcpy(latest, &state, sizeof(*latest));\r\nreturn 0;\r\n}\r\nstatic int cpcap_battery_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct cpcap_battery_ddata *ddata = power_supply_get_drvdata(psy);\r\nstruct cpcap_battery_state_data *latest, *previous;\r\nu32 sample;\r\ns32 accumulator;\r\nint cached;\r\ns64 tmp;\r\ncached = cpcap_battery_update_status(ddata);\r\nif (cached < 0)\r\nreturn cached;\r\nlatest = cpcap_battery_latest(ddata);\r\nprevious = cpcap_battery_previous(ddata);\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_PRESENT:\r\nif (latest->temperature > CPCAP_NO_BATTERY)\r\nval->intval = 1;\r\nelse\r\nval->intval = 0;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_STATUS:\r\nif (cpcap_battery_full(ddata)) {\r\nval->intval = POWER_SUPPLY_STATUS_FULL;\r\nbreak;\r\n}\r\nif (cpcap_battery_cc_get_avg_current(ddata) < 0)\r\nval->intval = POWER_SUPPLY_STATUS_CHARGING;\r\nelse\r\nval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TECHNOLOGY:\r\nval->intval = ddata->config.info.technology;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_NOW:\r\nval->intval = cpcap_battery_get_voltage(ddata);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:\r\nval->intval = ddata->config.info.voltage_max_design;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:\r\nval->intval = ddata->config.info.voltage_min_design;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CURRENT_AVG:\r\nif (cached) {\r\nval->intval = cpcap_battery_cc_get_avg_current(ddata);\r\nbreak;\r\n}\r\nsample = latest->cc.sample - previous->cc.sample;\r\naccumulator = latest->cc.accumulator - previous->cc.accumulator;\r\nval->intval = cpcap_battery_cc_to_ua(ddata, sample,\r\naccumulator,\r\nlatest->cc.offset);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CURRENT_NOW:\r\nval->intval = latest->current_ua;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_COUNTER:\r\nval->intval = latest->counter_uah;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_POWER_NOW:\r\ntmp = (latest->voltage / 10000) * latest->current_ua;\r\nval->intval = div64_s64(tmp, 100);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_POWER_AVG:\r\nif (cached) {\r\ntmp = cpcap_battery_cc_get_avg_current(ddata);\r\ntmp *= (latest->voltage / 10000);\r\nval->intval = div64_s64(tmp, 100);\r\nbreak;\r\n}\r\nsample = latest->cc.sample - previous->cc.sample;\r\naccumulator = latest->cc.accumulator - previous->cc.accumulator;\r\ntmp = cpcap_battery_cc_to_ua(ddata, sample, accumulator,\r\nlatest->cc.offset);\r\ntmp *= ((latest->voltage + previous->voltage) / 20000);\r\nval->intval = div64_s64(tmp, 100);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CAPACITY_LEVEL:\r\nif (cpcap_battery_full(ddata))\r\nval->intval = POWER_SUPPLY_CAPACITY_LEVEL_FULL;\r\nelse if (latest->voltage >= 3750000)\r\nval->intval = POWER_SUPPLY_CAPACITY_LEVEL_HIGH;\r\nelse if (latest->voltage >= 3300000)\r\nval->intval = POWER_SUPPLY_CAPACITY_LEVEL_NORMAL;\r\nelse if (latest->voltage > 3100000)\r\nval->intval = POWER_SUPPLY_CAPACITY_LEVEL_LOW;\r\nelse if (latest->voltage <= 3100000)\r\nval->intval = POWER_SUPPLY_CAPACITY_LEVEL_CRITICAL;\r\nelse\r\nval->intval = POWER_SUPPLY_CAPACITY_LEVEL_UNKNOWN;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:\r\nval->intval = ddata->config.info.charge_full_design;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_SCOPE:\r\nval->intval = POWER_SUPPLY_SCOPE_SYSTEM;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TEMP:\r\nval->intval = latest->temperature;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t cpcap_battery_irq_thread(int irq, void *data)\r\n{\r\nstruct cpcap_battery_ddata *ddata = data;\r\nstruct cpcap_battery_state_data *latest;\r\nstruct cpcap_interrupt_desc *d;\r\nif (!atomic_read(&ddata->active))\r\nreturn IRQ_NONE;\r\nlist_for_each_entry(d, &ddata->irq_list, node) {\r\nif (irq == d->irq)\r\nbreak;\r\n}\r\nif (!d)\r\nreturn IRQ_NONE;\r\nlatest = cpcap_battery_latest(ddata);\r\nswitch (d->action) {\r\ncase CPCAP_BATTERY_IRQ_ACTION_BATTERY_LOW:\r\nif (latest->counter_uah >= 0)\r\ndev_warn(ddata->dev, "Battery low at 3.3V!\n");\r\nbreak;\r\ncase CPCAP_BATTERY_IRQ_ACTION_POWEROFF:\r\nif (latest->counter_uah >= 0) {\r\ndev_emerg(ddata->dev,\r\n"Battery empty at 3.1V, powering off\n");\r\norderly_poweroff(true);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\npower_supply_changed(ddata->psy);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int cpcap_battery_init_irq(struct platform_device *pdev,\r\nstruct cpcap_battery_ddata *ddata,\r\nconst char *name)\r\n{\r\nstruct cpcap_interrupt_desc *d;\r\nint irq, error;\r\nirq = platform_get_irq_byname(pdev, name);\r\nif (!irq)\r\nreturn -ENODEV;\r\nerror = devm_request_threaded_irq(ddata->dev, irq, NULL,\r\ncpcap_battery_irq_thread,\r\nIRQF_SHARED,\r\nname, ddata);\r\nif (error) {\r\ndev_err(ddata->dev, "could not get irq %s: %i\n",\r\nname, error);\r\nreturn error;\r\n}\r\nd = devm_kzalloc(ddata->dev, sizeof(*d), GFP_KERNEL);\r\nif (!d)\r\nreturn -ENOMEM;\r\nd->name = name;\r\nd->irq = irq;\r\nif (!strncmp(name, "lowbph", 6))\r\nd->action = CPCAP_BATTERY_IRQ_ACTION_BATTERY_LOW;\r\nelse if (!strncmp(name, "lowbpl", 6))\r\nd->action = CPCAP_BATTERY_IRQ_ACTION_POWEROFF;\r\nlist_add(&d->node, &ddata->irq_list);\r\nreturn 0;\r\n}\r\nstatic int cpcap_battery_init_interrupts(struct platform_device *pdev,\r\nstruct cpcap_battery_ddata *ddata)\r\n{\r\nconst char * const cpcap_battery_irqs[] = {\r\n"eol", "lowbph", "lowbpl",\r\n"chrgcurr1", "battdetb"\r\n};\r\nint i, error;\r\nfor (i = 0; i < ARRAY_SIZE(cpcap_battery_irqs); i++) {\r\nerror = cpcap_battery_init_irq(pdev, ddata,\r\ncpcap_battery_irqs[i]);\r\nif (error)\r\nreturn error;\r\n}\r\nerror = regmap_update_bits(ddata->reg, CPCAP_REG_BPEOL,\r\n0xffff,\r\nCPCAP_REG_BPEOL_BIT_BATTDETEN);\r\nif (error)\r\nreturn error;\r\nreturn 0;\r\n}\r\nstatic int cpcap_battery_init_iio(struct cpcap_battery_ddata *ddata)\r\n{\r\nconst char * const names[CPCAP_BATTERY_IIO_NR] = {\r\n"battdetb", "battp", "chg_isense", "batti",\r\n};\r\nint error, i;\r\nfor (i = 0; i < CPCAP_BATTERY_IIO_NR; i++) {\r\nddata->channels[i] = devm_iio_channel_get(ddata->dev,\r\nnames[i]);\r\nif (IS_ERR(ddata->channels[i])) {\r\nerror = PTR_ERR(ddata->channels[i]);\r\ngoto out_err;\r\n}\r\nif (!ddata->channels[i]->indio_dev) {\r\nerror = -ENXIO;\r\ngoto out_err;\r\n}\r\n}\r\nreturn 0;\r\nout_err:\r\ndev_err(ddata->dev, "could not initialize VBUS or ID IIO: %i\n",\r\nerror);\r\nreturn error;\r\n}\r\nstatic int cpcap_battery_probe(struct platform_device *pdev)\r\n{\r\nstruct power_supply_desc *psy_desc;\r\nstruct cpcap_battery_ddata *ddata;\r\nconst struct of_device_id *match;\r\nstruct power_supply_config psy_cfg = {};\r\nint error;\r\nmatch = of_match_device(of_match_ptr(cpcap_battery_id_table),\r\n&pdev->dev);\r\nif (!match)\r\nreturn -EINVAL;\r\nif (!match->data) {\r\ndev_err(&pdev->dev, "no configuration data found\n");\r\nreturn -ENODEV;\r\n}\r\nddata = devm_kzalloc(&pdev->dev, sizeof(*ddata), GFP_KERNEL);\r\nif (!ddata)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&ddata->irq_list);\r\nddata->dev = &pdev->dev;\r\nmemcpy(&ddata->config, match->data, sizeof(ddata->config));\r\nddata->reg = dev_get_regmap(ddata->dev->parent, NULL);\r\nif (!ddata->reg)\r\nreturn -ENODEV;\r\nerror = cpcap_get_vendor(ddata->dev, ddata->reg, &ddata->vendor);\r\nif (error)\r\nreturn error;\r\nplatform_set_drvdata(pdev, ddata);\r\nerror = regmap_update_bits(ddata->reg, CPCAP_REG_CCM,\r\n0xffff, ddata->config.ccm);\r\nif (error)\r\nreturn error;\r\nerror = cpcap_battery_init_interrupts(pdev, ddata);\r\nif (error)\r\nreturn error;\r\nerror = cpcap_battery_init_iio(ddata);\r\nif (error)\r\nreturn error;\r\npsy_desc = devm_kzalloc(ddata->dev, sizeof(*psy_desc), GFP_KERNEL);\r\nif (!psy_desc)\r\nreturn -ENOMEM;\r\npsy_desc->name = "battery",\r\npsy_desc->type = POWER_SUPPLY_TYPE_BATTERY,\r\npsy_desc->properties = cpcap_battery_props,\r\npsy_desc->num_properties = ARRAY_SIZE(cpcap_battery_props),\r\npsy_desc->get_property = cpcap_battery_get_property,\r\npsy_cfg.of_node = pdev->dev.of_node;\r\npsy_cfg.drv_data = ddata;\r\nddata->psy = devm_power_supply_register(ddata->dev, psy_desc,\r\n&psy_cfg);\r\nerror = PTR_ERR_OR_ZERO(ddata->psy);\r\nif (error) {\r\ndev_err(ddata->dev, "failed to register power supply\n");\r\nreturn error;\r\n}\r\natomic_set(&ddata->active, 1);\r\nreturn 0;\r\n}\r\nstatic int cpcap_battery_remove(struct platform_device *pdev)\r\n{\r\nstruct cpcap_battery_ddata *ddata = platform_get_drvdata(pdev);\r\nint error;\r\natomic_set(&ddata->active, 0);\r\nerror = regmap_update_bits(ddata->reg, CPCAP_REG_BPEOL,\r\n0xffff, 0);\r\nif (error)\r\ndev_err(&pdev->dev, "could not disable: %i\n", error);\r\nreturn 0;\r\n}
