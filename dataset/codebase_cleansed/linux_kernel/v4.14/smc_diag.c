static void smc_gid_be16_convert(__u8 *buf, u8 *gid_raw)\r\n{\r\nsprintf(buf, "%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x",\r\nbe16_to_cpu(((__be16 *)gid_raw)[0]),\r\nbe16_to_cpu(((__be16 *)gid_raw)[1]),\r\nbe16_to_cpu(((__be16 *)gid_raw)[2]),\r\nbe16_to_cpu(((__be16 *)gid_raw)[3]),\r\nbe16_to_cpu(((__be16 *)gid_raw)[4]),\r\nbe16_to_cpu(((__be16 *)gid_raw)[5]),\r\nbe16_to_cpu(((__be16 *)gid_raw)[6]),\r\nbe16_to_cpu(((__be16 *)gid_raw)[7]));\r\n}\r\nstatic void smc_diag_msg_common_fill(struct smc_diag_msg *r, struct sock *sk)\r\n{\r\nstruct smc_sock *smc = smc_sk(sk);\r\nr->diag_family = sk->sk_family;\r\nif (!smc->clcsock)\r\nreturn;\r\nr->id.idiag_sport = htons(smc->clcsock->sk->sk_num);\r\nr->id.idiag_dport = smc->clcsock->sk->sk_dport;\r\nr->id.idiag_if = smc->clcsock->sk->sk_bound_dev_if;\r\nsock_diag_save_cookie(sk, r->id.idiag_cookie);\r\nmemset(&r->id.idiag_src, 0, sizeof(r->id.idiag_src));\r\nmemset(&r->id.idiag_dst, 0, sizeof(r->id.idiag_dst));\r\nr->id.idiag_src[0] = smc->clcsock->sk->sk_rcv_saddr;\r\nr->id.idiag_dst[0] = smc->clcsock->sk->sk_daddr;\r\n}\r\nstatic int smc_diag_msg_attrs_fill(struct sock *sk, struct sk_buff *skb,\r\nstruct smc_diag_msg *r,\r\nstruct user_namespace *user_ns)\r\n{\r\nif (nla_put_u8(skb, SMC_DIAG_SHUTDOWN, sk->sk_shutdown))\r\nreturn 1;\r\nr->diag_uid = from_kuid_munged(user_ns, sock_i_uid(sk));\r\nr->diag_inode = sock_i_ino(sk);\r\nreturn 0;\r\n}\r\nstatic int __smc_diag_dump(struct sock *sk, struct sk_buff *skb,\r\nstruct netlink_callback *cb,\r\nconst struct smc_diag_req *req,\r\nstruct nlattr *bc)\r\n{\r\nstruct smc_sock *smc = smc_sk(sk);\r\nstruct user_namespace *user_ns;\r\nstruct smc_diag_msg *r;\r\nstruct nlmsghdr *nlh;\r\nnlh = nlmsg_put(skb, NETLINK_CB(cb->skb).portid, cb->nlh->nlmsg_seq,\r\ncb->nlh->nlmsg_type, sizeof(*r), NLM_F_MULTI);\r\nif (!nlh)\r\nreturn -EMSGSIZE;\r\nr = nlmsg_data(nlh);\r\nsmc_diag_msg_common_fill(r, sk);\r\nr->diag_state = sk->sk_state;\r\nr->diag_fallback = smc->use_fallback;\r\nuser_ns = sk_user_ns(NETLINK_CB(cb->skb).sk);\r\nif (smc_diag_msg_attrs_fill(sk, skb, r, user_ns))\r\ngoto errout;\r\nif ((req->diag_ext & (1 << (SMC_DIAG_CONNINFO - 1))) && smc->conn.lgr) {\r\nstruct smc_connection *conn = &smc->conn;\r\nstruct smc_diag_conninfo cinfo = {\r\n.token = conn->alert_token_local,\r\n.sndbuf_size = conn->sndbuf_size,\r\n.rmbe_size = conn->rmbe_size,\r\n.peer_rmbe_size = conn->peer_rmbe_size,\r\n.rx_prod.wrap = conn->local_rx_ctrl.prod.wrap,\r\n.rx_prod.count = conn->local_rx_ctrl.prod.count,\r\n.rx_cons.wrap = conn->local_rx_ctrl.cons.wrap,\r\n.rx_cons.count = conn->local_rx_ctrl.cons.count,\r\n.tx_prod.wrap = conn->local_tx_ctrl.prod.wrap,\r\n.tx_prod.count = conn->local_tx_ctrl.prod.count,\r\n.tx_cons.wrap = conn->local_tx_ctrl.cons.wrap,\r\n.tx_cons.count = conn->local_tx_ctrl.cons.count,\r\n.tx_prod_flags =\r\n*(u8 *)&conn->local_tx_ctrl.prod_flags,\r\n.tx_conn_state_flags =\r\n*(u8 *)&conn->local_tx_ctrl.conn_state_flags,\r\n.rx_prod_flags = *(u8 *)&conn->local_rx_ctrl.prod_flags,\r\n.rx_conn_state_flags =\r\n*(u8 *)&conn->local_rx_ctrl.conn_state_flags,\r\n.tx_prep.wrap = conn->tx_curs_prep.wrap,\r\n.tx_prep.count = conn->tx_curs_prep.count,\r\n.tx_sent.wrap = conn->tx_curs_sent.wrap,\r\n.tx_sent.count = conn->tx_curs_sent.count,\r\n.tx_fin.wrap = conn->tx_curs_fin.wrap,\r\n.tx_fin.count = conn->tx_curs_fin.count,\r\n};\r\nif (nla_put(skb, SMC_DIAG_CONNINFO, sizeof(cinfo), &cinfo) < 0)\r\ngoto errout;\r\n}\r\nif ((req->diag_ext & (1 << (SMC_DIAG_LGRINFO - 1))) && smc->conn.lgr) {\r\nstruct smc_diag_lgrinfo linfo = {\r\n.role = smc->conn.lgr->role,\r\n.lnk[0].ibport = smc->conn.lgr->lnk[0].ibport,\r\n.lnk[0].link_id = smc->conn.lgr->lnk[0].link_id,\r\n};\r\nmemcpy(linfo.lnk[0].ibname,\r\nsmc->conn.lgr->lnk[0].smcibdev->ibdev->name,\r\nsizeof(smc->conn.lgr->lnk[0].smcibdev->ibdev->name));\r\nsmc_gid_be16_convert(linfo.lnk[0].gid,\r\nsmc->conn.lgr->lnk[0].gid.raw);\r\nsmc_gid_be16_convert(linfo.lnk[0].peer_gid,\r\nsmc->conn.lgr->lnk[0].peer_gid);\r\nif (nla_put(skb, SMC_DIAG_LGRINFO, sizeof(linfo), &linfo) < 0)\r\ngoto errout;\r\n}\r\nnlmsg_end(skb, nlh);\r\nreturn 0;\r\nerrout:\r\nnlmsg_cancel(skb, nlh);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int smc_diag_dump(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct nlattr *bc = NULL;\r\nstruct hlist_head *head;\r\nstruct sock *sk;\r\nint rc = 0;\r\nread_lock(&smc_proto.h.smc_hash->lock);\r\nhead = &smc_proto.h.smc_hash->ht;\r\nif (hlist_empty(head))\r\ngoto out;\r\nsk_for_each(sk, head) {\r\nif (!net_eq(sock_net(sk), net))\r\ncontinue;\r\nrc = __smc_diag_dump(sk, skb, cb, nlmsg_data(cb->nlh), bc);\r\nif (rc)\r\nbreak;\r\n}\r\nout:\r\nread_unlock(&smc_proto.h.smc_hash->lock);\r\nreturn rc;\r\n}\r\nstatic int smc_diag_handler_dump(struct sk_buff *skb, struct nlmsghdr *h)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nif (h->nlmsg_type == SOCK_DIAG_BY_FAMILY &&\r\nh->nlmsg_flags & NLM_F_DUMP) {\r\n{\r\nstruct netlink_dump_control c = {\r\n.dump = smc_diag_dump,\r\n.min_dump_alloc = SKB_WITH_OVERHEAD(32768),\r\n};\r\nreturn netlink_dump_start(net->diag_nlsk, skb, h, &c);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init smc_diag_init(void)\r\n{\r\nreturn sock_diag_register(&smc_diag_handler);\r\n}\r\nstatic void __exit smc_diag_exit(void)\r\n{\r\nsock_diag_unregister(&smc_diag_handler);\r\n}
