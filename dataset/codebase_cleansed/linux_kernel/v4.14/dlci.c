static int dlci_header(struct sk_buff *skb, struct net_device *dev,\r\nunsigned short type, const void *daddr,\r\nconst void *saddr, unsigned len)\r\n{\r\nstruct frhdr hdr;\r\nunsigned int hlen;\r\nchar *dest;\r\nhdr.control = FRAD_I_UI;\r\nswitch (type)\r\n{\r\ncase ETH_P_IP:\r\nhdr.IP_NLPID = FRAD_P_IP;\r\nhlen = sizeof(hdr.control) + sizeof(hdr.IP_NLPID);\r\nbreak;\r\ndefault:\r\nhdr.pad = FRAD_P_PADDING;\r\nhdr.NLPID = FRAD_P_SNAP;\r\nmemset(hdr.OUI, 0, sizeof(hdr.OUI));\r\nhdr.PID = htons(type);\r\nhlen = sizeof(hdr);\r\nbreak;\r\n}\r\ndest = skb_push(skb, hlen);\r\nif (!dest)\r\nreturn 0;\r\nmemcpy(dest, &hdr, hlen);\r\nreturn hlen;\r\n}\r\nstatic void dlci_receive(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct frhdr *hdr;\r\nint process, header;\r\nif (!pskb_may_pull(skb, sizeof(*hdr))) {\r\nnetdev_notice(dev, "invalid data no header\n");\r\ndev->stats.rx_errors++;\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nhdr = (struct frhdr *) skb->data;\r\nprocess = 0;\r\nheader = 0;\r\nskb->dev = dev;\r\nif (hdr->control != FRAD_I_UI)\r\n{\r\nnetdev_notice(dev, "Invalid header flag 0x%02X\n",\r\nhdr->control);\r\ndev->stats.rx_errors++;\r\n}\r\nelse\r\nswitch (hdr->IP_NLPID)\r\n{\r\ncase FRAD_P_PADDING:\r\nif (hdr->NLPID != FRAD_P_SNAP)\r\n{\r\nnetdev_notice(dev, "Unsupported NLPID 0x%02X\n",\r\nhdr->NLPID);\r\ndev->stats.rx_errors++;\r\nbreak;\r\n}\r\nif (hdr->OUI[0] + hdr->OUI[1] + hdr->OUI[2] != 0)\r\n{\r\nnetdev_notice(dev, "Unsupported organizationally unique identifier 0x%02X-%02X-%02X\n",\r\nhdr->OUI[0],\r\nhdr->OUI[1],\r\nhdr->OUI[2]);\r\ndev->stats.rx_errors++;\r\nbreak;\r\n}\r\nheader = sizeof(struct frhdr);\r\nskb->protocol = hdr->PID;\r\nprocess = 1;\r\nbreak;\r\ncase FRAD_P_IP:\r\nheader = sizeof(hdr->control) + sizeof(hdr->IP_NLPID);\r\nskb->protocol = htons(ETH_P_IP);\r\nprocess = 1;\r\nbreak;\r\ncase FRAD_P_SNAP:\r\ncase FRAD_P_Q933:\r\ncase FRAD_P_CLNP:\r\nnetdev_notice(dev, "Unsupported NLPID 0x%02X\n",\r\nhdr->pad);\r\ndev->stats.rx_errors++;\r\nbreak;\r\ndefault:\r\nnetdev_notice(dev, "Invalid pad byte 0x%02X\n",\r\nhdr->pad);\r\ndev->stats.rx_errors++;\r\nbreak;\r\n}\r\nif (process)\r\n{\r\nskb_reset_mac_header(skb);\r\nskb_pull(skb, header);\r\ndev->stats.rx_bytes += skb->len;\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\n}\r\nelse\r\ndev_kfree_skb(skb);\r\n}\r\nstatic netdev_tx_t dlci_transmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct dlci_local *dlp = netdev_priv(dev);\r\nif (skb) {\r\nstruct netdev_queue *txq = skb_get_tx_queue(dev, skb);\r\nnetdev_start_xmit(skb, dlp->slave, txq, false);\r\n}\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int dlci_config(struct net_device *dev, struct dlci_conf __user *conf, int get)\r\n{\r\nstruct dlci_conf config;\r\nstruct dlci_local *dlp;\r\nstruct frad_local *flp;\r\nint err;\r\ndlp = netdev_priv(dev);\r\nflp = netdev_priv(dlp->slave);\r\nif (!get)\r\n{\r\nif (copy_from_user(&config, conf, sizeof(struct dlci_conf)))\r\nreturn -EFAULT;\r\nif (config.flags & ~DLCI_VALID_FLAGS)\r\nreturn -EINVAL;\r\nmemcpy(&dlp->config, &config, sizeof(struct dlci_conf));\r\ndlp->configured = 1;\r\n}\r\nerr = (*flp->dlci_conf)(dlp->slave, dev, get);\r\nif (err)\r\nreturn err;\r\nif (get)\r\n{\r\nif (copy_to_user(conf, &dlp->config, sizeof(struct dlci_conf)))\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dlci_dev_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nstruct dlci_local *dlp;\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\ndlp = netdev_priv(dev);\r\nswitch (cmd)\r\n{\r\ncase DLCI_GET_SLAVE:\r\nif (!*(short *)(dev->dev_addr))\r\nreturn -EINVAL;\r\nstrncpy(ifr->ifr_slave, dlp->slave->name, sizeof(ifr->ifr_slave));\r\nbreak;\r\ncase DLCI_GET_CONF:\r\ncase DLCI_SET_CONF:\r\nif (!*(short *)(dev->dev_addr))\r\nreturn -EINVAL;\r\nreturn dlci_config(dev, ifr->ifr_data, cmd == DLCI_GET_CONF);\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dlci_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nstruct dlci_local *dlp = netdev_priv(dev);\r\nreturn dev_set_mtu(dlp->slave, new_mtu);\r\n}\r\nstatic int dlci_open(struct net_device *dev)\r\n{\r\nstruct dlci_local *dlp;\r\nstruct frad_local *flp;\r\nint err;\r\ndlp = netdev_priv(dev);\r\nif (!*(short *)(dev->dev_addr))\r\nreturn -EINVAL;\r\nif (!netif_running(dlp->slave))\r\nreturn -ENOTCONN;\r\nflp = netdev_priv(dlp->slave);\r\nerr = (*flp->activate)(dlp->slave, dev);\r\nif (err)\r\nreturn err;\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int dlci_close(struct net_device *dev)\r\n{\r\nstruct dlci_local *dlp;\r\nstruct frad_local *flp;\r\nint err;\r\nnetif_stop_queue(dev);\r\ndlp = netdev_priv(dev);\r\nflp = netdev_priv(dlp->slave);\r\nerr = (*flp->deactivate)(dlp->slave, dev);\r\nreturn 0;\r\n}\r\nstatic int dlci_add(struct dlci_add *dlci)\r\n{\r\nstruct net_device *master, *slave;\r\nstruct dlci_local *dlp;\r\nstruct frad_local *flp;\r\nint err = -EINVAL;\r\nslave = dev_get_by_name(&init_net, dlci->devname);\r\nif (!slave)\r\nreturn -ENODEV;\r\nif (slave->type != ARPHRD_FRAD || netdev_priv(slave) == NULL)\r\ngoto err1;\r\nmaster = alloc_netdev(sizeof(struct dlci_local), "dlci%d",\r\nNET_NAME_UNKNOWN, dlci_setup);\r\nif (!master) {\r\nerr = -ENOMEM;\r\ngoto err1;\r\n}\r\nrtnl_lock();\r\nlist_for_each_entry(dlp, &dlci_devs, list) {\r\nif (dlp->slave == slave) {\r\nerr = -EBUSY;\r\ngoto err2;\r\n}\r\n}\r\n*(short *)(master->dev_addr) = dlci->dlci;\r\ndlp = netdev_priv(master);\r\ndlp->slave = slave;\r\ndlp->master = master;\r\nflp = netdev_priv(slave);\r\nerr = (*flp->assoc)(slave, master);\r\nif (err < 0)\r\ngoto err2;\r\nerr = register_netdevice(master);\r\nif (err < 0)\r\ngoto err2;\r\nstrcpy(dlci->devname, master->name);\r\nlist_add(&dlp->list, &dlci_devs);\r\nrtnl_unlock();\r\nreturn 0;\r\nerr2:\r\nrtnl_unlock();\r\nfree_netdev(master);\r\nerr1:\r\ndev_put(slave);\r\nreturn err;\r\n}\r\nstatic int dlci_del(struct dlci_add *dlci)\r\n{\r\nstruct dlci_local *dlp;\r\nstruct frad_local *flp;\r\nstruct net_device *master, *slave;\r\nint err;\r\nbool found = false;\r\nrtnl_lock();\r\nmaster = __dev_get_by_name(&init_net, dlci->devname);\r\nif (!master) {\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\nlist_for_each_entry(dlp, &dlci_devs, list) {\r\nif (dlp->master == master) {\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\nif (netif_running(master)) {\r\nerr = -EBUSY;\r\ngoto out;\r\n}\r\ndlp = netdev_priv(master);\r\nslave = dlp->slave;\r\nflp = netdev_priv(slave);\r\nerr = (*flp->deassoc)(slave, master);\r\nif (!err) {\r\nlist_del(&dlp->list);\r\nunregister_netdevice(master);\r\ndev_put(slave);\r\n}\r\nout:\r\nrtnl_unlock();\r\nreturn err;\r\n}\r\nstatic int dlci_ioctl(unsigned int cmd, void __user *arg)\r\n{\r\nstruct dlci_add add;\r\nint err;\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (copy_from_user(&add, arg, sizeof(struct dlci_add)))\r\nreturn -EFAULT;\r\nswitch (cmd)\r\n{\r\ncase SIOCADDDLCI:\r\nerr = dlci_add(&add);\r\nif (!err)\r\nif (copy_to_user(arg, &add, sizeof(struct dlci_add)))\r\nreturn -EFAULT;\r\nbreak;\r\ncase SIOCDELDLCI:\r\nerr = dlci_del(&add);\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\n}\r\nreturn err;\r\n}\r\nstatic void dlci_setup(struct net_device *dev)\r\n{\r\nstruct dlci_local *dlp = netdev_priv(dev);\r\ndev->flags = 0;\r\ndev->header_ops = &dlci_header_ops;\r\ndev->netdev_ops = &dlci_netdev_ops;\r\ndev->needs_free_netdev = true;\r\ndlp->receive = dlci_receive;\r\ndev->type = ARPHRD_DLCI;\r\ndev->hard_header_len = sizeof(struct frhdr);\r\ndev->addr_len = sizeof(short);\r\n}\r\nstatic int dlci_dev_event(struct notifier_block *unused,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\r\nif (dev_net(dev) != &init_net)\r\nreturn NOTIFY_DONE;\r\nif (event == NETDEV_UNREGISTER) {\r\nstruct dlci_local *dlp;\r\nlist_for_each_entry(dlp, &dlci_devs, list) {\r\nif (dlp->slave == dev) {\r\nlist_del(&dlp->list);\r\nunregister_netdevice(dlp->master);\r\ndev_put(dlp->slave);\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int __init init_dlci(void)\r\n{\r\ndlci_ioctl_set(dlci_ioctl);\r\nregister_netdevice_notifier(&dlci_notifier);\r\nprintk("%s.\n", version);\r\nreturn 0;\r\n}\r\nstatic void __exit dlci_exit(void)\r\n{\r\nstruct dlci_local *dlp, *nxt;\r\ndlci_ioctl_set(NULL);\r\nunregister_netdevice_notifier(&dlci_notifier);\r\nrtnl_lock();\r\nlist_for_each_entry_safe(dlp, nxt, &dlci_devs, list) {\r\nunregister_netdevice(dlp->master);\r\ndev_put(dlp->slave);\r\n}\r\nrtnl_unlock();\r\n}
