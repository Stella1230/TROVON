static int fpga_mgr_write_init_buf(struct fpga_manager *mgr,\r\nstruct fpga_image_info *info,\r\nconst char *buf, size_t count)\r\n{\r\nint ret;\r\nmgr->state = FPGA_MGR_STATE_WRITE_INIT;\r\nif (!mgr->mops->initial_header_size)\r\nret = mgr->mops->write_init(mgr, info, NULL, 0);\r\nelse\r\nret = mgr->mops->write_init(\r\nmgr, info, buf, min(mgr->mops->initial_header_size, count));\r\nif (ret) {\r\ndev_err(&mgr->dev, "Error preparing FPGA for writing\n");\r\nmgr->state = FPGA_MGR_STATE_WRITE_INIT_ERR;\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fpga_mgr_write_init_sg(struct fpga_manager *mgr,\r\nstruct fpga_image_info *info,\r\nstruct sg_table *sgt)\r\n{\r\nstruct sg_mapping_iter miter;\r\nsize_t len;\r\nchar *buf;\r\nint ret;\r\nif (!mgr->mops->initial_header_size)\r\nreturn fpga_mgr_write_init_buf(mgr, info, NULL, 0);\r\nsg_miter_start(&miter, sgt->sgl, sgt->nents, SG_MITER_FROM_SG);\r\nif (sg_miter_next(&miter) &&\r\nmiter.length >= mgr->mops->initial_header_size) {\r\nret = fpga_mgr_write_init_buf(mgr, info, miter.addr,\r\nmiter.length);\r\nsg_miter_stop(&miter);\r\nreturn ret;\r\n}\r\nsg_miter_stop(&miter);\r\nbuf = kmalloc(mgr->mops->initial_header_size, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nlen = sg_copy_to_buffer(sgt->sgl, sgt->nents, buf,\r\nmgr->mops->initial_header_size);\r\nret = fpga_mgr_write_init_buf(mgr, info, buf, len);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int fpga_mgr_write_complete(struct fpga_manager *mgr,\r\nstruct fpga_image_info *info)\r\n{\r\nint ret;\r\nmgr->state = FPGA_MGR_STATE_WRITE_COMPLETE;\r\nret = mgr->mops->write_complete(mgr, info);\r\nif (ret) {\r\ndev_err(&mgr->dev, "Error after writing image data to FPGA\n");\r\nmgr->state = FPGA_MGR_STATE_WRITE_COMPLETE_ERR;\r\nreturn ret;\r\n}\r\nmgr->state = FPGA_MGR_STATE_OPERATING;\r\nreturn 0;\r\n}\r\nint fpga_mgr_buf_load_sg(struct fpga_manager *mgr, struct fpga_image_info *info,\r\nstruct sg_table *sgt)\r\n{\r\nint ret;\r\nret = fpga_mgr_write_init_sg(mgr, info, sgt);\r\nif (ret)\r\nreturn ret;\r\nmgr->state = FPGA_MGR_STATE_WRITE;\r\nif (mgr->mops->write_sg) {\r\nret = mgr->mops->write_sg(mgr, sgt);\r\n} else {\r\nstruct sg_mapping_iter miter;\r\nsg_miter_start(&miter, sgt->sgl, sgt->nents, SG_MITER_FROM_SG);\r\nwhile (sg_miter_next(&miter)) {\r\nret = mgr->mops->write(mgr, miter.addr, miter.length);\r\nif (ret)\r\nbreak;\r\n}\r\nsg_miter_stop(&miter);\r\n}\r\nif (ret) {\r\ndev_err(&mgr->dev, "Error while writing image data to FPGA\n");\r\nmgr->state = FPGA_MGR_STATE_WRITE_ERR;\r\nreturn ret;\r\n}\r\nreturn fpga_mgr_write_complete(mgr, info);\r\n}\r\nstatic int fpga_mgr_buf_load_mapped(struct fpga_manager *mgr,\r\nstruct fpga_image_info *info,\r\nconst char *buf, size_t count)\r\n{\r\nint ret;\r\nret = fpga_mgr_write_init_buf(mgr, info, buf, count);\r\nif (ret)\r\nreturn ret;\r\nmgr->state = FPGA_MGR_STATE_WRITE;\r\nret = mgr->mops->write(mgr, buf, count);\r\nif (ret) {\r\ndev_err(&mgr->dev, "Error while writing image data to FPGA\n");\r\nmgr->state = FPGA_MGR_STATE_WRITE_ERR;\r\nreturn ret;\r\n}\r\nreturn fpga_mgr_write_complete(mgr, info);\r\n}\r\nint fpga_mgr_buf_load(struct fpga_manager *mgr, struct fpga_image_info *info,\r\nconst char *buf, size_t count)\r\n{\r\nstruct page **pages;\r\nstruct sg_table sgt;\r\nconst void *p;\r\nint nr_pages;\r\nint index;\r\nint rc;\r\nif (mgr->mops->write)\r\nreturn fpga_mgr_buf_load_mapped(mgr, info, buf, count);\r\nnr_pages = DIV_ROUND_UP((unsigned long)buf + count, PAGE_SIZE) -\r\n(unsigned long)buf / PAGE_SIZE;\r\npages = kmalloc_array(nr_pages, sizeof(struct page *), GFP_KERNEL);\r\nif (!pages)\r\nreturn -ENOMEM;\r\np = buf - offset_in_page(buf);\r\nfor (index = 0; index < nr_pages; index++) {\r\nif (is_vmalloc_addr(p))\r\npages[index] = vmalloc_to_page(p);\r\nelse\r\npages[index] = kmap_to_page((void *)p);\r\nif (!pages[index]) {\r\nkfree(pages);\r\nreturn -EFAULT;\r\n}\r\np += PAGE_SIZE;\r\n}\r\nrc = sg_alloc_table_from_pages(&sgt, pages, index, offset_in_page(buf),\r\ncount, GFP_KERNEL);\r\nkfree(pages);\r\nif (rc)\r\nreturn rc;\r\nrc = fpga_mgr_buf_load_sg(mgr, info, &sgt);\r\nsg_free_table(&sgt);\r\nreturn rc;\r\n}\r\nint fpga_mgr_firmware_load(struct fpga_manager *mgr,\r\nstruct fpga_image_info *info,\r\nconst char *image_name)\r\n{\r\nstruct device *dev = &mgr->dev;\r\nconst struct firmware *fw;\r\nint ret;\r\ndev_info(dev, "writing %s to %s\n", image_name, mgr->name);\r\nmgr->state = FPGA_MGR_STATE_FIRMWARE_REQ;\r\nret = request_firmware(&fw, image_name, dev);\r\nif (ret) {\r\nmgr->state = FPGA_MGR_STATE_FIRMWARE_REQ_ERR;\r\ndev_err(dev, "Error requesting firmware %s\n", image_name);\r\nreturn ret;\r\n}\r\nret = fpga_mgr_buf_load(mgr, info, fw->data, fw->size);\r\nrelease_firmware(fw);\r\nreturn ret;\r\n}\r\nstatic ssize_t name_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct fpga_manager *mgr = to_fpga_manager(dev);\r\nreturn sprintf(buf, "%s\n", mgr->name);\r\n}\r\nstatic ssize_t state_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct fpga_manager *mgr = to_fpga_manager(dev);\r\nreturn sprintf(buf, "%s\n", state_str[mgr->state]);\r\n}\r\nstatic struct fpga_manager *__fpga_mgr_get(struct device *dev)\r\n{\r\nstruct fpga_manager *mgr;\r\nint ret = -ENODEV;\r\nmgr = to_fpga_manager(dev);\r\nif (!mgr)\r\ngoto err_dev;\r\nif (!mutex_trylock(&mgr->ref_mutex)) {\r\nret = -EBUSY;\r\ngoto err_dev;\r\n}\r\nif (!try_module_get(dev->parent->driver->owner))\r\ngoto err_ll_mod;\r\nreturn mgr;\r\nerr_ll_mod:\r\nmutex_unlock(&mgr->ref_mutex);\r\nerr_dev:\r\nput_device(dev);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic int fpga_mgr_dev_match(struct device *dev, const void *data)\r\n{\r\nreturn dev->parent == data;\r\n}\r\nstruct fpga_manager *fpga_mgr_get(struct device *dev)\r\n{\r\nstruct device *mgr_dev = class_find_device(fpga_mgr_class, NULL, dev,\r\nfpga_mgr_dev_match);\r\nif (!mgr_dev)\r\nreturn ERR_PTR(-ENODEV);\r\nreturn __fpga_mgr_get(mgr_dev);\r\n}\r\nstatic int fpga_mgr_of_node_match(struct device *dev, const void *data)\r\n{\r\nreturn dev->of_node == data;\r\n}\r\nstruct fpga_manager *of_fpga_mgr_get(struct device_node *node)\r\n{\r\nstruct device *dev;\r\ndev = class_find_device(fpga_mgr_class, NULL, node,\r\nfpga_mgr_of_node_match);\r\nif (!dev)\r\nreturn ERR_PTR(-ENODEV);\r\nreturn __fpga_mgr_get(dev);\r\n}\r\nvoid fpga_mgr_put(struct fpga_manager *mgr)\r\n{\r\nmodule_put(mgr->dev.parent->driver->owner);\r\nmutex_unlock(&mgr->ref_mutex);\r\nput_device(&mgr->dev);\r\n}\r\nint fpga_mgr_register(struct device *dev, const char *name,\r\nconst struct fpga_manager_ops *mops,\r\nvoid *priv)\r\n{\r\nstruct fpga_manager *mgr;\r\nint id, ret;\r\nif (!mops || !mops->write_complete || !mops->state ||\r\n!mops->write_init || (!mops->write && !mops->write_sg) ||\r\n(mops->write && mops->write_sg)) {\r\ndev_err(dev, "Attempt to register without fpga_manager_ops\n");\r\nreturn -EINVAL;\r\n}\r\nif (!name || !strlen(name)) {\r\ndev_err(dev, "Attempt to register with no name!\n");\r\nreturn -EINVAL;\r\n}\r\nmgr = kzalloc(sizeof(*mgr), GFP_KERNEL);\r\nif (!mgr)\r\nreturn -ENOMEM;\r\nid = ida_simple_get(&fpga_mgr_ida, 0, 0, GFP_KERNEL);\r\nif (id < 0) {\r\nret = id;\r\ngoto error_kfree;\r\n}\r\nmutex_init(&mgr->ref_mutex);\r\nmgr->name = name;\r\nmgr->mops = mops;\r\nmgr->priv = priv;\r\nmgr->state = mgr->mops->state(mgr);\r\ndevice_initialize(&mgr->dev);\r\nmgr->dev.class = fpga_mgr_class;\r\nmgr->dev.parent = dev;\r\nmgr->dev.of_node = dev->of_node;\r\nmgr->dev.id = id;\r\ndev_set_drvdata(dev, mgr);\r\nret = dev_set_name(&mgr->dev, "fpga%d", id);\r\nif (ret)\r\ngoto error_device;\r\nret = device_add(&mgr->dev);\r\nif (ret)\r\ngoto error_device;\r\ndev_info(&mgr->dev, "%s registered\n", mgr->name);\r\nreturn 0;\r\nerror_device:\r\nida_simple_remove(&fpga_mgr_ida, id);\r\nerror_kfree:\r\nkfree(mgr);\r\nreturn ret;\r\n}\r\nvoid fpga_mgr_unregister(struct device *dev)\r\n{\r\nstruct fpga_manager *mgr = dev_get_drvdata(dev);\r\ndev_info(&mgr->dev, "%s %s\n", __func__, mgr->name);\r\nif (mgr->mops->fpga_remove)\r\nmgr->mops->fpga_remove(mgr);\r\ndevice_unregister(&mgr->dev);\r\n}\r\nstatic void fpga_mgr_dev_release(struct device *dev)\r\n{\r\nstruct fpga_manager *mgr = to_fpga_manager(dev);\r\nida_simple_remove(&fpga_mgr_ida, mgr->dev.id);\r\nkfree(mgr);\r\n}\r\nstatic int __init fpga_mgr_class_init(void)\r\n{\r\npr_info("FPGA manager framework\n");\r\nfpga_mgr_class = class_create(THIS_MODULE, "fpga_manager");\r\nif (IS_ERR(fpga_mgr_class))\r\nreturn PTR_ERR(fpga_mgr_class);\r\nfpga_mgr_class->dev_groups = fpga_mgr_groups;\r\nfpga_mgr_class->dev_release = fpga_mgr_dev_release;\r\nreturn 0;\r\n}\r\nstatic void __exit fpga_mgr_class_exit(void)\r\n{\r\nclass_destroy(fpga_mgr_class);\r\nida_destroy(&fpga_mgr_ida);\r\n}
