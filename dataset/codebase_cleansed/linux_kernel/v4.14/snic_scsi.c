const char *\r\nsnic_state_to_str(unsigned int state)\r\n{\r\nif (state >= ARRAY_SIZE(snic_state_str) || !snic_state_str[state])\r\nreturn "Unknown";\r\nreturn snic_state_str[state];\r\n}\r\nstatic const char *\r\nsnic_io_status_to_str(unsigned int state)\r\n{\r\nif ((state >= ARRAY_SIZE(snic_io_status_str)) ||\r\n(!snic_io_status_str[state]))\r\nreturn "Unknown";\r\nreturn snic_io_status_str[state];\r\n}\r\nstatic const char *\r\nsnic_ioreq_state_to_str(unsigned int state)\r\n{\r\nif (state >= ARRAY_SIZE(snic_req_state_str) ||\r\n!snic_req_state_str[state])\r\nreturn "Unknown";\r\nreturn snic_req_state_str[state];\r\n}\r\nstatic inline spinlock_t *\r\nsnic_io_lock_hash(struct snic *snic, struct scsi_cmnd *sc)\r\n{\r\nu32 hash = snic_cmd_tag(sc) & (SNIC_IO_LOCKS - 1);\r\nreturn &snic->io_req_lock[hash];\r\n}\r\nstatic inline spinlock_t *\r\nsnic_io_lock_tag(struct snic *snic, int tag)\r\n{\r\nreturn &snic->io_req_lock[tag & (SNIC_IO_LOCKS - 1)];\r\n}\r\nstatic void\r\nsnic_release_req_buf(struct snic *snic,\r\nstruct snic_req_info *rqi,\r\nstruct scsi_cmnd *sc)\r\n{\r\nstruct snic_host_req *req = rqi_to_req(rqi);\r\nSNIC_BUG_ON(!((CMD_STATE(sc) == SNIC_IOREQ_COMPLETE) ||\r\n(CMD_STATE(sc) == SNIC_IOREQ_ABTS_COMPLETE) ||\r\n(CMD_FLAGS(sc) & SNIC_DEV_RST_NOTSUP) ||\r\n(CMD_FLAGS(sc) & SNIC_IO_INTERNAL_TERM_ISSUED) ||\r\n(CMD_FLAGS(sc) & SNIC_DEV_RST_TERM_ISSUED) ||\r\n(CMD_FLAGS(sc) & SNIC_SCSI_CLEANUP) ||\r\n(CMD_STATE(sc) == SNIC_IOREQ_LR_COMPLETE)));\r\nSNIC_SCSI_DBG(snic->shost,\r\n"Rel_req:sc %p:tag %x:rqi %p:ioreq %p:abt %p:dr %p: state %s:flags 0x%llx\n",\r\nsc, snic_cmd_tag(sc), rqi, rqi->req, rqi->abort_req,\r\nrqi->dr_req, snic_ioreq_state_to_str(CMD_STATE(sc)),\r\nCMD_FLAGS(sc));\r\nif (req->u.icmnd.sense_addr)\r\npci_unmap_single(snic->pdev,\r\nle64_to_cpu(req->u.icmnd.sense_addr),\r\nSCSI_SENSE_BUFFERSIZE,\r\nPCI_DMA_FROMDEVICE);\r\nscsi_dma_unmap(sc);\r\nsnic_req_free(snic, rqi);\r\n}\r\nstatic int\r\nsnic_queue_icmnd_req(struct snic *snic,\r\nstruct snic_req_info *rqi,\r\nstruct scsi_cmnd *sc,\r\nint sg_cnt)\r\n{\r\nstruct scatterlist *sg;\r\nstruct snic_sg_desc *sgd;\r\ndma_addr_t pa = 0;\r\nstruct scsi_lun lun;\r\nu16 flags = 0;\r\nint ret = 0;\r\nunsigned int i;\r\nif (sg_cnt) {\r\nflags = SNIC_ICMND_ESGL;\r\nsgd = (struct snic_sg_desc *) req_to_sgl(rqi->req);\r\nfor_each_sg(scsi_sglist(sc), sg, sg_cnt, i) {\r\nsgd->addr = cpu_to_le64(sg_dma_address(sg));\r\nsgd->len = cpu_to_le32(sg_dma_len(sg));\r\nsgd->_resvd = 0;\r\nsgd++;\r\n}\r\n}\r\npa = pci_map_single(snic->pdev,\r\nsc->sense_buffer,\r\nSCSI_SENSE_BUFFERSIZE,\r\nPCI_DMA_FROMDEVICE);\r\nif (pci_dma_mapping_error(snic->pdev, pa)) {\r\nSNIC_HOST_ERR(snic->shost,\r\n"QIcmnd:PCI Map Failed for sns buf %p tag %x\n",\r\nsc->sense_buffer, snic_cmd_tag(sc));\r\nret = -ENOMEM;\r\nreturn ret;\r\n}\r\nint_to_scsilun(sc->device->lun, &lun);\r\nif (sc->sc_data_direction == DMA_FROM_DEVICE)\r\nflags |= SNIC_ICMND_RD;\r\nif (sc->sc_data_direction == DMA_TO_DEVICE)\r\nflags |= SNIC_ICMND_WR;\r\nsnic_icmnd_init(rqi->req,\r\nsnic_cmd_tag(sc),\r\nsnic->config.hid,\r\n(ulong) rqi,\r\nflags,\r\nrqi->tgt_id,\r\nlun.scsi_lun,\r\nsc->cmnd,\r\nsc->cmd_len,\r\nscsi_bufflen(sc),\r\nsg_cnt,\r\n(ulong) req_to_sgl(rqi->req),\r\npa,\r\nSCSI_SENSE_BUFFERSIZE);\r\natomic64_inc(&snic->s_stats.io.active);\r\nret = snic_queue_wq_desc(snic, rqi->req, rqi->req_len);\r\nif (ret) {\r\natomic64_dec(&snic->s_stats.io.active);\r\nSNIC_HOST_ERR(snic->shost,\r\n"QIcmnd: Queuing Icmnd Failed. ret = %d\n",\r\nret);\r\n} else\r\nsnic_stats_update_active_ios(&snic->s_stats);\r\nreturn ret;\r\n}\r\nstatic int\r\nsnic_issue_scsi_req(struct snic *snic,\r\nstruct snic_tgt *tgt,\r\nstruct scsi_cmnd *sc)\r\n{\r\nstruct snic_req_info *rqi = NULL;\r\nint sg_cnt = 0;\r\nint ret = 0;\r\nu32 tag = snic_cmd_tag(sc);\r\nu64 cmd_trc = 0, cmd_st_flags = 0;\r\nspinlock_t *io_lock = NULL;\r\nunsigned long flags;\r\nCMD_STATE(sc) = SNIC_IOREQ_NOT_INITED;\r\nCMD_FLAGS(sc) = SNIC_NO_FLAGS;\r\nsg_cnt = scsi_dma_map(sc);\r\nif (sg_cnt < 0) {\r\nSNIC_TRC((u16)snic->shost->host_no, tag, (ulong) sc, 0,\r\nsc->cmnd[0], sg_cnt, CMD_STATE(sc));\r\nSNIC_HOST_ERR(snic->shost, "issue_sc:Failed to map SG List.\n");\r\nret = -ENOMEM;\r\ngoto issue_sc_end;\r\n}\r\nrqi = snic_req_init(snic, sg_cnt);\r\nif (!rqi) {\r\nscsi_dma_unmap(sc);\r\nret = -ENOMEM;\r\ngoto issue_sc_end;\r\n}\r\nrqi->tgt_id = tgt->id;\r\nrqi->sc = sc;\r\nCMD_STATE(sc) = SNIC_IOREQ_PENDING;\r\nCMD_SP(sc) = (char *) rqi;\r\ncmd_trc = SNIC_TRC_CMD(sc);\r\nCMD_FLAGS(sc) |= (SNIC_IO_INITIALIZED | SNIC_IO_ISSUED);\r\ncmd_st_flags = SNIC_TRC_CMD_STATE_FLAGS(sc);\r\nio_lock = snic_io_lock_hash(snic, sc);\r\nret = snic_queue_icmnd_req(snic, rqi, sc, sg_cnt);\r\nif (ret) {\r\nSNIC_HOST_ERR(snic->shost,\r\n"issue_sc: icmnd qing Failed for sc %p, err %d\n",\r\nsc, ret);\r\nspin_lock_irqsave(io_lock, flags);\r\nrqi = (struct snic_req_info *) CMD_SP(sc);\r\nCMD_SP(sc) = NULL;\r\nCMD_STATE(sc) = SNIC_IOREQ_COMPLETE;\r\nCMD_FLAGS(sc) &= ~SNIC_IO_ISSUED;\r\nspin_unlock_irqrestore(io_lock, flags);\r\nif (rqi)\r\nsnic_release_req_buf(snic, rqi, sc);\r\nSNIC_TRC(snic->shost->host_no, tag, (ulong) sc, 0, 0, 0,\r\nSNIC_TRC_CMD_STATE_FLAGS(sc));\r\n} else {\r\nu32 io_sz = scsi_bufflen(sc) >> 9;\r\nu32 qtime = jiffies - rqi->start_time;\r\nstruct snic_io_stats *iostats = &snic->s_stats.io;\r\nif (io_sz > atomic64_read(&iostats->max_io_sz))\r\natomic64_set(&iostats->max_io_sz, io_sz);\r\nif (qtime > atomic64_read(&iostats->max_qtime))\r\natomic64_set(&iostats->max_qtime, qtime);\r\nSNIC_SCSI_DBG(snic->shost,\r\n"issue_sc:sc %p, tag %d queued to WQ.\n",\r\nsc, tag);\r\nSNIC_TRC(snic->shost->host_no, tag, (ulong) sc, (ulong) rqi,\r\nsg_cnt, cmd_trc, cmd_st_flags);\r\n}\r\nissue_sc_end:\r\nreturn ret;\r\n}\r\nint\r\nsnic_queuecommand(struct Scsi_Host *shost, struct scsi_cmnd *sc)\r\n{\r\nstruct snic_tgt *tgt = NULL;\r\nstruct snic *snic = shost_priv(shost);\r\nint ret;\r\ntgt = starget_to_tgt(scsi_target(sc->device));\r\nret = snic_tgt_chkready(tgt);\r\nif (ret) {\r\nSNIC_HOST_ERR(shost, "Tgt %p id %d Not Ready.\n", tgt, tgt->id);\r\natomic64_inc(&snic->s_stats.misc.tgt_not_rdy);\r\nsc->result = ret;\r\nsc->scsi_done(sc);\r\nreturn 0;\r\n}\r\nif (snic_get_state(snic) != SNIC_ONLINE) {\r\nSNIC_HOST_ERR(shost, "snic state is %s\n",\r\nsnic_state_str[snic_get_state(snic)]);\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\n}\r\natomic_inc(&snic->ios_inflight);\r\nSNIC_SCSI_DBG(shost, "sc %p Tag %d (sc %0x) lun %lld in snic_qcmd\n",\r\nsc, snic_cmd_tag(sc), sc->cmnd[0], sc->device->lun);\r\nret = snic_issue_scsi_req(snic, tgt, sc);\r\nif (ret) {\r\nSNIC_HOST_ERR(shost, "Failed to Q, Scsi Req w/ err %d.\n", ret);\r\nret = SCSI_MLQUEUE_HOST_BUSY;\r\n}\r\natomic_dec(&snic->ios_inflight);\r\nreturn ret;\r\n}\r\nstatic void\r\nsnic_proc_tmreq_pending_state(struct snic *snic,\r\nstruct scsi_cmnd *sc,\r\nu8 cmpl_status)\r\n{\r\nint state = CMD_STATE(sc);\r\nif (state == SNIC_IOREQ_ABTS_PENDING)\r\nCMD_FLAGS(sc) |= SNIC_IO_ABTS_PENDING;\r\nelse if (state == SNIC_IOREQ_LR_PENDING)\r\nCMD_FLAGS(sc) |= SNIC_DEV_RST_PENDING;\r\nelse\r\nSNIC_BUG_ON(1);\r\nswitch (cmpl_status) {\r\ncase SNIC_STAT_IO_SUCCESS:\r\nCMD_FLAGS(sc) |= SNIC_IO_DONE;\r\nbreak;\r\ncase SNIC_STAT_ABORTED:\r\nCMD_FLAGS(sc) |= SNIC_IO_ABORTED;\r\nbreak;\r\ndefault:\r\nSNIC_BUG_ON(1);\r\n}\r\n}\r\nstatic void\r\nsnic_process_io_failed_state(struct snic *snic,\r\nstruct snic_icmnd_cmpl *icmnd_cmpl,\r\nstruct scsi_cmnd *sc,\r\nu8 cmpl_stat)\r\n{\r\nint res = 0;\r\nswitch (cmpl_stat) {\r\ncase SNIC_STAT_TIMEOUT:\r\natomic64_inc(&snic->s_stats.misc.io_tmo);\r\nres = DID_TIME_OUT;\r\nbreak;\r\ncase SNIC_STAT_ABORTED:\r\natomic64_inc(&snic->s_stats.misc.io_aborted);\r\nres = DID_ABORT;\r\nbreak;\r\ncase SNIC_STAT_DATA_CNT_MISMATCH:\r\natomic64_inc(&snic->s_stats.misc.data_cnt_mismat);\r\nscsi_set_resid(sc, le32_to_cpu(icmnd_cmpl->resid));\r\nres = DID_ERROR;\r\nbreak;\r\ncase SNIC_STAT_OUT_OF_RES:\r\natomic64_inc(&snic->s_stats.fw.out_of_res);\r\nres = DID_REQUEUE;\r\nbreak;\r\ncase SNIC_STAT_IO_NOT_FOUND:\r\natomic64_inc(&snic->s_stats.io.io_not_found);\r\nres = DID_ERROR;\r\nbreak;\r\ncase SNIC_STAT_SGL_INVALID:\r\natomic64_inc(&snic->s_stats.misc.sgl_inval);\r\nres = DID_ERROR;\r\nbreak;\r\ncase SNIC_STAT_FW_ERR:\r\natomic64_inc(&snic->s_stats.fw.io_errs);\r\nres = DID_ERROR;\r\nbreak;\r\ncase SNIC_STAT_SCSI_ERR:\r\natomic64_inc(&snic->s_stats.fw.scsi_errs);\r\nbreak;\r\ncase SNIC_STAT_NOT_READY:\r\ncase SNIC_STAT_DEV_OFFLINE:\r\nres = DID_NO_CONNECT;\r\nbreak;\r\ncase SNIC_STAT_INVALID_HDR:\r\ncase SNIC_STAT_INVALID_PARM:\r\ncase SNIC_STAT_REQ_NOT_SUP:\r\ncase SNIC_STAT_CMND_REJECT:\r\ncase SNIC_STAT_FATAL_ERROR:\r\ndefault:\r\nSNIC_SCSI_DBG(snic->shost,\r\n"Invalid Hdr/Param or Req Not Supported or Cmnd Rejected or Device Offline. or Unknown\n");\r\nres = DID_ERROR;\r\nbreak;\r\n}\r\nSNIC_HOST_ERR(snic->shost, "fw returns failed status %s flags 0x%llx\n",\r\nsnic_io_status_to_str(cmpl_stat), CMD_FLAGS(sc));\r\nsc->result = (res << 16) | icmnd_cmpl->scsi_status;\r\n}\r\nstatic int\r\nsnic_tmreq_pending(struct scsi_cmnd *sc)\r\n{\r\nint state = CMD_STATE(sc);\r\nreturn ((state == SNIC_IOREQ_ABTS_PENDING) ||\r\n(state == SNIC_IOREQ_LR_PENDING));\r\n}\r\nstatic int\r\nsnic_process_icmnd_cmpl_status(struct snic *snic,\r\nstruct snic_icmnd_cmpl *icmnd_cmpl,\r\nu8 cmpl_stat,\r\nstruct scsi_cmnd *sc)\r\n{\r\nu8 scsi_stat = icmnd_cmpl->scsi_status;\r\nu64 xfer_len = 0;\r\nint ret = 0;\r\nCMD_STATE(sc) = SNIC_IOREQ_COMPLETE;\r\nif (likely(cmpl_stat == SNIC_STAT_IO_SUCCESS)) {\r\nsc->result = (DID_OK << 16) | scsi_stat;\r\nxfer_len = scsi_bufflen(sc);\r\nscsi_set_resid(sc, le32_to_cpu(icmnd_cmpl->resid));\r\nif (icmnd_cmpl->flags & SNIC_ICMND_CMPL_UNDR_RUN) {\r\nxfer_len -= le32_to_cpu(icmnd_cmpl->resid);\r\natomic64_inc(&snic->s_stats.misc.io_under_run);\r\n}\r\nif (icmnd_cmpl->scsi_status == SAM_STAT_TASK_SET_FULL)\r\natomic64_inc(&snic->s_stats.misc.qfull);\r\nret = 0;\r\n} else {\r\nsnic_process_io_failed_state(snic, icmnd_cmpl, sc, cmpl_stat);\r\natomic64_inc(&snic->s_stats.io.fail);\r\nSNIC_HOST_ERR(snic->shost,\r\n"icmnd_cmpl: IO Failed : Hdr Status %s flags 0x%llx\n",\r\nsnic_io_status_to_str(cmpl_stat), CMD_FLAGS(sc));\r\nret = 1;\r\n}\r\nreturn ret;\r\n}\r\nstatic void\r\nsnic_icmnd_cmpl_handler(struct snic *snic, struct snic_fw_req *fwreq)\r\n{\r\nu8 typ, hdr_stat;\r\nu32 cmnd_id, hid;\r\nulong ctx;\r\nstruct scsi_cmnd *sc = NULL;\r\nstruct snic_icmnd_cmpl *icmnd_cmpl = NULL;\r\nstruct snic_host_req *req = NULL;\r\nstruct snic_req_info *rqi = NULL;\r\nunsigned long flags, start_time;\r\nspinlock_t *io_lock;\r\nu8 sc_stat = 0;\r\nsnic_io_hdr_dec(&fwreq->hdr, &typ, &hdr_stat, &cmnd_id, &hid, &ctx);\r\nicmnd_cmpl = &fwreq->u.icmnd_cmpl;\r\nsc_stat = icmnd_cmpl->scsi_status;\r\nSNIC_SCSI_DBG(snic->shost,\r\n"Icmnd_cmpl: type = %x, hdr_stat = %x, cmnd_id = %x, hid = %x,i ctx = %lx\n",\r\ntyp, hdr_stat, cmnd_id, hid, ctx);\r\nif (cmnd_id >= snic->max_tag_id) {\r\nSNIC_HOST_ERR(snic->shost,\r\n"Icmnd_cmpl:Tag Error:Out of Range Tag %d, hdr status = %s\n",\r\ncmnd_id, snic_io_status_to_str(hdr_stat));\r\nreturn;\r\n}\r\nsc = scsi_host_find_tag(snic->shost, cmnd_id);\r\nWARN_ON_ONCE(!sc);\r\nif (!sc) {\r\natomic64_inc(&snic->s_stats.io.sc_null);\r\nSNIC_HOST_ERR(snic->shost,\r\n"Icmnd_cmpl: Scsi Cmnd Not found, sc = NULL Hdr Status = %s tag = 0x%x fwreq = 0x%p\n",\r\nsnic_io_status_to_str(hdr_stat),\r\ncmnd_id,\r\nfwreq);\r\nSNIC_TRC(snic->shost->host_no, cmnd_id, 0,\r\n((u64)hdr_stat << 16 |\r\n(u64)sc_stat << 8 | (u64)icmnd_cmpl->flags),\r\n(ulong) fwreq, le32_to_cpu(icmnd_cmpl->resid), ctx);\r\nreturn;\r\n}\r\nio_lock = snic_io_lock_hash(snic, sc);\r\nspin_lock_irqsave(io_lock, flags);\r\nrqi = (struct snic_req_info *) CMD_SP(sc);\r\nSNIC_SCSI_DBG(snic->shost,\r\n"Icmnd_cmpl:lun %lld sc %p cmd %xtag %d flags 0x%llx rqi %p\n",\r\nsc->device->lun, sc, sc->cmnd[0], snic_cmd_tag(sc),\r\nCMD_FLAGS(sc), rqi);\r\nif (CMD_FLAGS(sc) & SNIC_HOST_RESET_CMD_TERM) {\r\nspin_unlock_irqrestore(io_lock, flags);\r\nreturn;\r\n}\r\nSNIC_BUG_ON(rqi != (struct snic_req_info *)ctx);\r\nWARN_ON_ONCE(req);\r\nif (!rqi) {\r\natomic64_inc(&snic->s_stats.io.req_null);\r\nCMD_FLAGS(sc) |= SNIC_IO_REQ_NULL;\r\nspin_unlock_irqrestore(io_lock, flags);\r\nSNIC_HOST_ERR(snic->shost,\r\n"Icmnd_cmpl:Host Req Not Found(null), Hdr Status %s, Tag 0x%x, sc 0x%p flags 0x%llx\n",\r\nsnic_io_status_to_str(hdr_stat),\r\ncmnd_id, sc, CMD_FLAGS(sc));\r\nreturn;\r\n}\r\nrqi = (struct snic_req_info *) ctx;\r\nstart_time = rqi->start_time;\r\nrqi->io_cmpl = 1;\r\nif (unlikely(snic_tmreq_pending(sc))) {\r\nsnic_proc_tmreq_pending_state(snic, sc, hdr_stat);\r\nspin_unlock_irqrestore(io_lock, flags);\r\nsnic_stats_update_io_cmpl(&snic->s_stats);\r\nif (likely(hdr_stat == SNIC_STAT_ABORTED))\r\nreturn;\r\nSNIC_SCSI_DBG(snic->shost,\r\n"icmnd_cmpl:TM Req Pending(%s), Hdr Status %s sc 0x%p scsi status %x resid %d flags 0x%llx\n",\r\nsnic_ioreq_state_to_str(CMD_STATE(sc)),\r\nsnic_io_status_to_str(hdr_stat),\r\nsc, sc_stat, le32_to_cpu(icmnd_cmpl->resid),\r\nCMD_FLAGS(sc));\r\nSNIC_TRC(snic->shost->host_no, cmnd_id, (ulong) sc,\r\njiffies_to_msecs(jiffies - start_time), (ulong) fwreq,\r\nSNIC_TRC_CMD(sc), SNIC_TRC_CMD_STATE_FLAGS(sc));\r\nreturn;\r\n}\r\nif (snic_process_icmnd_cmpl_status(snic, icmnd_cmpl, hdr_stat, sc)) {\r\nscsi_print_command(sc);\r\nSNIC_HOST_ERR(snic->shost,\r\n"icmnd_cmpl:IO Failed, sc 0x%p Tag %d Cmd %x Hdr Status %s flags 0x%llx\n",\r\nsc, sc->cmnd[0], cmnd_id,\r\nsnic_io_status_to_str(hdr_stat), CMD_FLAGS(sc));\r\n}\r\nCMD_SP(sc) = NULL;\r\nCMD_FLAGS(sc) |= SNIC_IO_DONE;\r\nspin_unlock_irqrestore(io_lock, flags);\r\nsnic_calc_io_process_time(snic, rqi);\r\nsnic_release_req_buf(snic, rqi, sc);\r\nSNIC_TRC(snic->shost->host_no, cmnd_id, (ulong) sc,\r\njiffies_to_msecs(jiffies - start_time), (ulong) fwreq,\r\nSNIC_TRC_CMD(sc), SNIC_TRC_CMD_STATE_FLAGS(sc));\r\nif (sc->scsi_done)\r\nsc->scsi_done(sc);\r\nsnic_stats_update_io_cmpl(&snic->s_stats);\r\n}\r\nstatic void\r\nsnic_proc_dr_cmpl_locked(struct snic *snic,\r\nstruct snic_fw_req *fwreq,\r\nu8 cmpl_stat,\r\nu32 cmnd_id,\r\nstruct scsi_cmnd *sc)\r\n{\r\nstruct snic_req_info *rqi = (struct snic_req_info *) CMD_SP(sc);\r\nu32 start_time = rqi->start_time;\r\nCMD_LR_STATUS(sc) = cmpl_stat;\r\nSNIC_SCSI_DBG(snic->shost, "itmf_cmpl: Cmd State = %s\n",\r\nsnic_ioreq_state_to_str(CMD_STATE(sc)));\r\nif (CMD_STATE(sc) == SNIC_IOREQ_ABTS_PENDING) {\r\nCMD_FLAGS(sc) |= SNIC_DEV_RST_ABTS_PENDING;\r\nSNIC_TRC(snic->shost->host_no, cmnd_id, (ulong) sc,\r\njiffies_to_msecs(jiffies - start_time),\r\n(ulong) fwreq, 0, SNIC_TRC_CMD_STATE_FLAGS(sc));\r\nSNIC_SCSI_DBG(snic->shost,\r\n"itmf_cmpl: Terminate Pending Dev Reset Cmpl Recvd.id %x, status %s flags 0x%llx\n",\r\n(int)(cmnd_id & SNIC_TAG_MASK),\r\nsnic_io_status_to_str(cmpl_stat),\r\nCMD_FLAGS(sc));\r\nreturn;\r\n}\r\nif (CMD_FLAGS(sc) & SNIC_DEV_RST_TIMEDOUT) {\r\nSNIC_TRC(snic->shost->host_no, cmnd_id, (ulong) sc,\r\njiffies_to_msecs(jiffies - start_time),\r\n(ulong) fwreq, 0, SNIC_TRC_CMD_STATE_FLAGS(sc));\r\nSNIC_SCSI_DBG(snic->shost,\r\n"itmf_cmpl:Dev Reset Completion Received after timeout. id %d cmpl status %s flags 0x%llx\n",\r\n(int)(cmnd_id & SNIC_TAG_MASK),\r\nsnic_io_status_to_str(cmpl_stat),\r\nCMD_FLAGS(sc));\r\nreturn;\r\n}\r\nCMD_STATE(sc) = SNIC_IOREQ_LR_COMPLETE;\r\nCMD_FLAGS(sc) |= SNIC_DEV_RST_DONE;\r\nSNIC_SCSI_DBG(snic->shost,\r\n"itmf_cmpl:Dev Reset Cmpl Recvd id %d cmpl status %s flags 0x%llx\n",\r\n(int)(cmnd_id & SNIC_TAG_MASK),\r\nsnic_io_status_to_str(cmpl_stat),\r\nCMD_FLAGS(sc));\r\nif (rqi->dr_done)\r\ncomplete(rqi->dr_done);\r\n}\r\nstatic void\r\nsnic_update_abort_stats(struct snic *snic, u8 cmpl_stat)\r\n{\r\nstruct snic_abort_stats *abt_stats = &snic->s_stats.abts;\r\nSNIC_SCSI_DBG(snic->shost, "Updating Abort stats.\n");\r\nswitch (cmpl_stat) {\r\ncase SNIC_STAT_IO_SUCCESS:\r\nbreak;\r\ncase SNIC_STAT_TIMEOUT:\r\natomic64_inc(&abt_stats->fw_tmo);\r\nbreak;\r\ncase SNIC_STAT_IO_NOT_FOUND:\r\natomic64_inc(&abt_stats->io_not_found);\r\nbreak;\r\ndefault:\r\natomic64_inc(&abt_stats->fail);\r\nbreak;\r\n}\r\n}\r\nstatic int\r\nsnic_process_itmf_cmpl(struct snic *snic,\r\nstruct snic_fw_req *fwreq,\r\nu32 cmnd_id,\r\nu8 cmpl_stat,\r\nstruct scsi_cmnd *sc)\r\n{\r\nstruct snic_req_info *rqi = NULL;\r\nu32 tm_tags = 0;\r\nspinlock_t *io_lock = NULL;\r\nunsigned long flags;\r\nu32 start_time = 0;\r\nint ret = 0;\r\nio_lock = snic_io_lock_hash(snic, sc);\r\nspin_lock_irqsave(io_lock, flags);\r\nif (CMD_FLAGS(sc) & SNIC_HOST_RESET_CMD_TERM) {\r\nspin_unlock_irqrestore(io_lock, flags);\r\nreturn ret;\r\n}\r\nrqi = (struct snic_req_info *) CMD_SP(sc);\r\nWARN_ON_ONCE(!rqi);\r\nif (!rqi) {\r\natomic64_inc(&snic->s_stats.io.req_null);\r\nspin_unlock_irqrestore(io_lock, flags);\r\nCMD_FLAGS(sc) |= SNIC_IO_ABTS_TERM_REQ_NULL;\r\nSNIC_HOST_ERR(snic->shost,\r\n"itmf_cmpl: rqi is null,Hdr stat = %s Tag = 0x%x sc = 0x%p flags 0x%llx\n",\r\nsnic_io_status_to_str(cmpl_stat), cmnd_id, sc,\r\nCMD_FLAGS(sc));\r\nreturn ret;\r\n}\r\ntm_tags = cmnd_id & ~(SNIC_TAG_MASK);\r\nstart_time = rqi->start_time;\r\ncmnd_id &= (SNIC_TAG_MASK);\r\nswitch (tm_tags) {\r\ncase SNIC_TAG_ABORT:\r\nsnic_update_abort_stats(snic, cmpl_stat);\r\nif (CMD_STATE(sc) != SNIC_IOREQ_ABTS_PENDING) {\r\nret = -1;\r\nspin_unlock_irqrestore(io_lock, flags);\r\nbreak;\r\n}\r\nCMD_STATE(sc) = SNIC_IOREQ_ABTS_COMPLETE;\r\nCMD_ABTS_STATUS(sc) = cmpl_stat;\r\nCMD_FLAGS(sc) |= SNIC_IO_ABTS_TERM_DONE;\r\nSNIC_SCSI_DBG(snic->shost,\r\n"itmf_cmpl:Abort Cmpl Recvd.Tag 0x%x Status %s flags 0x%llx\n",\r\ncmnd_id,\r\nsnic_io_status_to_str(cmpl_stat),\r\nCMD_FLAGS(sc));\r\nif (rqi->abts_done) {\r\ncomplete(rqi->abts_done);\r\nspin_unlock_irqrestore(io_lock, flags);\r\nbreak;\r\n}\r\nCMD_SP(sc) = NULL;\r\nsc->result = (DID_ERROR << 16);\r\nSNIC_SCSI_DBG(snic->shost,\r\n"itmf_cmpl: Completing IO. sc %p flags 0x%llx\n",\r\nsc, CMD_FLAGS(sc));\r\nspin_unlock_irqrestore(io_lock, flags);\r\nsnic_release_req_buf(snic, rqi, sc);\r\nif (sc->scsi_done) {\r\nSNIC_TRC(snic->shost->host_no, cmnd_id, (ulong) sc,\r\njiffies_to_msecs(jiffies - start_time),\r\n(ulong) fwreq, SNIC_TRC_CMD(sc),\r\nSNIC_TRC_CMD_STATE_FLAGS(sc));\r\nsc->scsi_done(sc);\r\n}\r\nbreak;\r\ncase SNIC_TAG_DEV_RST:\r\ncase SNIC_TAG_DEV_RST | SNIC_TAG_IOCTL_DEV_RST:\r\nsnic_proc_dr_cmpl_locked(snic, fwreq, cmpl_stat, cmnd_id, sc);\r\nspin_unlock_irqrestore(io_lock, flags);\r\nret = 0;\r\nbreak;\r\ncase SNIC_TAG_ABORT | SNIC_TAG_DEV_RST:\r\nCMD_STATE(sc) = SNIC_IOREQ_ABTS_COMPLETE;\r\nCMD_ABTS_STATUS(sc) = cmpl_stat;\r\nCMD_FLAGS(sc) |= SNIC_DEV_RST_DONE;\r\nSNIC_SCSI_DBG(snic->shost,\r\n"itmf_cmpl:dev reset abts cmpl recvd. id %d status %s flags 0x%llx\n",\r\ncmnd_id, snic_io_status_to_str(cmpl_stat),\r\nCMD_FLAGS(sc));\r\nif (rqi->abts_done)\r\ncomplete(rqi->abts_done);\r\nspin_unlock_irqrestore(io_lock, flags);\r\nbreak;\r\ndefault:\r\nspin_unlock_irqrestore(io_lock, flags);\r\nSNIC_HOST_ERR(snic->shost,\r\n"itmf_cmpl: Unknown TM tag bit 0x%x\n", tm_tags);\r\nSNIC_HOST_ERR(snic->shost,\r\n"itmf_cmpl:Unexpected itmf io stat %s Tag = 0x%x flags 0x%llx\n",\r\nsnic_ioreq_state_to_str(CMD_STATE(sc)),\r\ncmnd_id,\r\nCMD_FLAGS(sc));\r\nret = -1;\r\nSNIC_BUG_ON(1);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void\r\nsnic_itmf_cmpl_handler(struct snic *snic, struct snic_fw_req *fwreq)\r\n{\r\nstruct scsi_cmnd *sc = NULL;\r\nstruct snic_req_info *rqi = NULL;\r\nstruct snic_itmf_cmpl *itmf_cmpl = NULL;\r\nulong ctx;\r\nu32 cmnd_id;\r\nu32 hid;\r\nu8 typ;\r\nu8 hdr_stat;\r\nsnic_io_hdr_dec(&fwreq->hdr, &typ, &hdr_stat, &cmnd_id, &hid, &ctx);\r\nSNIC_SCSI_DBG(snic->shost,\r\n"Itmf_cmpl: %s: type = %x, hdr_stat = %x, cmnd_id = %x, hid = %x,ctx = %lx\n",\r\n__func__, typ, hdr_stat, cmnd_id, hid, ctx);\r\nitmf_cmpl = &fwreq->u.itmf_cmpl;\r\nSNIC_SCSI_DBG(snic->shost,\r\n"Itmf_cmpl: nterm %u , flags 0x%x\n",\r\nle32_to_cpu(itmf_cmpl->nterminated), itmf_cmpl->flags);\r\nif (cmnd_id & SNIC_TAG_IOCTL_DEV_RST) {\r\nrqi = (struct snic_req_info *) ctx;\r\nsc = rqi->sc;\r\ngoto ioctl_dev_rst;\r\n}\r\nif ((cmnd_id & SNIC_TAG_MASK) >= snic->max_tag_id) {\r\nSNIC_HOST_ERR(snic->shost,\r\n"Itmf_cmpl: Tag 0x%x out of Range,HdrStat %s\n",\r\ncmnd_id, snic_io_status_to_str(hdr_stat));\r\nSNIC_BUG_ON(1);\r\nreturn;\r\n}\r\nsc = scsi_host_find_tag(snic->shost, cmnd_id & SNIC_TAG_MASK);\r\nWARN_ON_ONCE(!sc);\r\nioctl_dev_rst:\r\nif (!sc) {\r\natomic64_inc(&snic->s_stats.io.sc_null);\r\nSNIC_HOST_ERR(snic->shost,\r\n"Itmf_cmpl: sc is NULL - Hdr Stat %s Tag 0x%x\n",\r\nsnic_io_status_to_str(hdr_stat), cmnd_id);\r\nreturn;\r\n}\r\nsnic_process_itmf_cmpl(snic, fwreq, cmnd_id, hdr_stat, sc);\r\n}\r\nstatic void\r\nsnic_hba_reset_scsi_cleanup(struct snic *snic, struct scsi_cmnd *sc)\r\n{\r\nstruct snic_stats *st = &snic->s_stats;\r\nlong act_ios = 0, act_fwreqs = 0;\r\nSNIC_SCSI_DBG(snic->shost, "HBA Reset scsi cleanup.\n");\r\nsnic_scsi_cleanup(snic, snic_cmd_tag(sc));\r\nact_ios = atomic64_read(&st->io.active);\r\natomic64_add(act_ios, &st->io.compl);\r\natomic64_sub(act_ios, &st->io.active);\r\nact_fwreqs = atomic64_read(&st->fw.actv_reqs);\r\natomic64_sub(act_fwreqs, &st->fw.actv_reqs);\r\n}\r\nstatic int\r\nsnic_hba_reset_cmpl_handler(struct snic *snic, struct snic_fw_req *fwreq)\r\n{\r\nulong ctx;\r\nu32 cmnd_id;\r\nu32 hid;\r\nu8 typ;\r\nu8 hdr_stat;\r\nstruct scsi_cmnd *sc = NULL;\r\nstruct snic_req_info *rqi = NULL;\r\nspinlock_t *io_lock = NULL;\r\nunsigned long flags, gflags;\r\nint ret = 0;\r\nsnic_io_hdr_dec(&fwreq->hdr, &typ, &hdr_stat, &cmnd_id, &hid, &ctx);\r\nSNIC_HOST_INFO(snic->shost,\r\n"reset_cmpl:Tag %d ctx %lx cmpl status %s HBA Reset Completion received.\n",\r\ncmnd_id, ctx, snic_io_status_to_str(hdr_stat));\r\nSNIC_SCSI_DBG(snic->shost,\r\n"reset_cmpl: type = %x, hdr_stat = %x, cmnd_id = %x, hid = %x, ctx = %lx\n",\r\ntyp, hdr_stat, cmnd_id, hid, ctx);\r\nif (cmnd_id == SCSI_NO_TAG) {\r\nrqi = (struct snic_req_info *) ctx;\r\nSNIC_HOST_INFO(snic->shost,\r\n"reset_cmpl:Tag %d ctx %lx cmpl stat %s\n",\r\ncmnd_id, ctx, snic_io_status_to_str(hdr_stat));\r\nsc = rqi->sc;\r\ngoto ioctl_hba_rst;\r\n}\r\nif (cmnd_id >= snic->max_tag_id) {\r\nSNIC_HOST_ERR(snic->shost,\r\n"reset_cmpl: Tag 0x%x out of Range,HdrStat %s\n",\r\ncmnd_id, snic_io_status_to_str(hdr_stat));\r\nSNIC_BUG_ON(1);\r\nreturn 1;\r\n}\r\nsc = scsi_host_find_tag(snic->shost, cmnd_id);\r\nioctl_hba_rst:\r\nif (!sc) {\r\natomic64_inc(&snic->s_stats.io.sc_null);\r\nSNIC_HOST_ERR(snic->shost,\r\n"reset_cmpl: sc is NULL - Hdr Stat %s Tag 0x%x\n",\r\nsnic_io_status_to_str(hdr_stat), cmnd_id);\r\nret = 1;\r\nreturn ret;\r\n}\r\nSNIC_HOST_INFO(snic->shost,\r\n"reset_cmpl: sc %p rqi %p Tag %d flags 0x%llx\n",\r\nsc, rqi, cmnd_id, CMD_FLAGS(sc));\r\nio_lock = snic_io_lock_hash(snic, sc);\r\nspin_lock_irqsave(io_lock, flags);\r\nif (!snic->remove_wait) {\r\nspin_unlock_irqrestore(io_lock, flags);\r\nSNIC_HOST_ERR(snic->shost,\r\n"reset_cmpl:host reset completed after timeout\n");\r\nret = 1;\r\nreturn ret;\r\n}\r\nrqi = (struct snic_req_info *) CMD_SP(sc);\r\nWARN_ON_ONCE(!rqi);\r\nif (!rqi) {\r\natomic64_inc(&snic->s_stats.io.req_null);\r\nspin_unlock_irqrestore(io_lock, flags);\r\nCMD_FLAGS(sc) |= SNIC_IO_ABTS_TERM_REQ_NULL;\r\nSNIC_HOST_ERR(snic->shost,\r\n"reset_cmpl: rqi is null,Hdr stat %s Tag 0x%x sc 0x%p flags 0x%llx\n",\r\nsnic_io_status_to_str(hdr_stat), cmnd_id, sc,\r\nCMD_FLAGS(sc));\r\nret = 1;\r\nreturn ret;\r\n}\r\nspin_unlock_irqrestore(io_lock, flags);\r\nsnic_hba_reset_scsi_cleanup(snic, sc);\r\nSNIC_BUG_ON(snic_get_state(snic) != SNIC_OFFLINE &&\r\nsnic_get_state(snic) != SNIC_FWRESET);\r\nspin_lock_irqsave(io_lock, flags);\r\nspin_lock_irqsave(&snic->snic_lock, gflags);\r\nif (snic_get_state(snic) == SNIC_FWRESET)\r\nsnic_set_state(snic, SNIC_ONLINE);\r\nspin_unlock_irqrestore(&snic->snic_lock, gflags);\r\nif (snic->remove_wait)\r\ncomplete(snic->remove_wait);\r\nspin_unlock_irqrestore(io_lock, flags);\r\natomic64_inc(&snic->s_stats.reset.hba_reset_cmpl);\r\nret = 0;\r\nif (snic->config.xpt_type == SNIC_DAS)\r\nreturn ret;\r\nSNIC_SCSI_DBG(snic->shost, "reset_cmpl: Queuing discovery work.\n");\r\nqueue_work(snic_glob->event_q, &snic->disc_work);\r\nreturn ret;\r\n}\r\nstatic void\r\nsnic_msg_ack_handler(struct snic *snic, struct snic_fw_req *fwreq)\r\n{\r\nSNIC_HOST_INFO(snic->shost, "Message Ack Received.\n");\r\nSNIC_ASSERT_NOT_IMPL(1);\r\n}\r\nstatic void\r\nsnic_aen_handler(struct snic *snic, struct snic_fw_req *fwreq)\r\n{\r\nu8 typ, hdr_stat;\r\nu32 cmnd_id, hid;\r\nulong ctx;\r\nstruct snic_async_evnotify *aen = &fwreq->u.async_ev;\r\nu32 event_id = 0;\r\nsnic_io_hdr_dec(&fwreq->hdr, &typ, &hdr_stat, &cmnd_id, &hid, &ctx);\r\nSNIC_SCSI_DBG(snic->shost,\r\n"aen: type = %x, hdr_stat = %x, cmnd_id = %x, hid = %x, ctx = %lx\n",\r\ntyp, hdr_stat, cmnd_id, hid, ctx);\r\nevent_id = le32_to_cpu(aen->ev_id);\r\nswitch (event_id) {\r\ncase SNIC_EV_TGT_OFFLINE:\r\nSNIC_HOST_INFO(snic->shost, "aen:TGT_OFFLINE Event Recvd.\n");\r\nbreak;\r\ncase SNIC_EV_TGT_ONLINE:\r\nSNIC_HOST_INFO(snic->shost, "aen:TGT_ONLINE Event Recvd.\n");\r\nbreak;\r\ncase SNIC_EV_LUN_OFFLINE:\r\nSNIC_HOST_INFO(snic->shost, "aen:LUN_OFFLINE Event Recvd.\n");\r\nbreak;\r\ncase SNIC_EV_LUN_ONLINE:\r\nSNIC_HOST_INFO(snic->shost, "aen:LUN_ONLINE Event Recvd.\n");\r\nbreak;\r\ncase SNIC_EV_CONF_CHG:\r\nSNIC_HOST_INFO(snic->shost, "aen:Config Change Event Recvd.\n");\r\nbreak;\r\ncase SNIC_EV_TGT_ADDED:\r\nSNIC_HOST_INFO(snic->shost, "aen:TGT_ADD Event Recvd.\n");\r\nbreak;\r\ncase SNIC_EV_TGT_DELTD:\r\nSNIC_HOST_INFO(snic->shost, "aen:TGT_DEL Event Recvd.\n");\r\nbreak;\r\ncase SNIC_EV_LUN_ADDED:\r\nSNIC_HOST_INFO(snic->shost, "aen:LUN_ADD Event Recvd.\n");\r\nbreak;\r\ncase SNIC_EV_LUN_DELTD:\r\nSNIC_HOST_INFO(snic->shost, "aen:LUN_DEL Event Recvd.\n");\r\nbreak;\r\ncase SNIC_EV_DISC_CMPL:\r\nSNIC_HOST_INFO(snic->shost, "aen:DISC_CMPL Event Recvd.\n");\r\nbreak;\r\ndefault:\r\nSNIC_HOST_INFO(snic->shost, "aen:Unknown Event Recvd.\n");\r\nSNIC_BUG_ON(1);\r\nbreak;\r\n}\r\nSNIC_ASSERT_NOT_IMPL(1);\r\n}\r\nstatic int\r\nsnic_io_cmpl_handler(struct vnic_dev *vdev,\r\nunsigned int cq_idx,\r\nstruct snic_fw_req *fwreq)\r\n{\r\nstruct snic *snic = svnic_dev_priv(vdev);\r\nu64 start = jiffies, cmpl_time;\r\nsnic_print_desc(__func__, (char *)fwreq, sizeof(*fwreq));\r\nif ((fwreq->hdr.type >= SNIC_RSP_REPORT_TGTS_CMPL) &&\r\n(fwreq->hdr.type <= SNIC_RSP_BOOT_LUNS_CMPL))\r\natomic64_dec(&snic->s_stats.fw.actv_reqs);\r\nSNIC_BUG_ON((fwreq->hdr.type > SNIC_RSP_BOOT_LUNS_CMPL) &&\r\n(fwreq->hdr.type < SNIC_MSG_ASYNC_EVNOTIFY));\r\nswitch (fwreq->hdr.status) {\r\ncase SNIC_STAT_NOT_READY:\r\nSNIC_HOST_ERR(snic->shost,\r\n"sNIC SubSystem is NOT Ready.\n");\r\nbreak;\r\ncase SNIC_STAT_FATAL_ERROR:\r\nSNIC_HOST_ERR(snic->shost,\r\n"sNIC SubSystem in Unrecoverable State.\n");\r\nbreak;\r\n}\r\nswitch (fwreq->hdr.type) {\r\ncase SNIC_RSP_EXCH_VER_CMPL:\r\nsnic_io_exch_ver_cmpl_handler(snic, fwreq);\r\nbreak;\r\ncase SNIC_RSP_REPORT_TGTS_CMPL:\r\nsnic_report_tgt_cmpl_handler(snic, fwreq);\r\nbreak;\r\ncase SNIC_RSP_ICMND_CMPL:\r\nsnic_icmnd_cmpl_handler(snic, fwreq);\r\nbreak;\r\ncase SNIC_RSP_ITMF_CMPL:\r\nsnic_itmf_cmpl_handler(snic, fwreq);\r\nbreak;\r\ncase SNIC_RSP_HBA_RESET_CMPL:\r\nsnic_hba_reset_cmpl_handler(snic, fwreq);\r\nbreak;\r\ncase SNIC_MSG_ACK:\r\nsnic_msg_ack_handler(snic, fwreq);\r\nbreak;\r\ncase SNIC_MSG_ASYNC_EVNOTIFY:\r\nsnic_aen_handler(snic, fwreq);\r\nbreak;\r\ndefault:\r\nSNIC_BUG_ON(1);\r\nSNIC_SCSI_DBG(snic->shost,\r\n"Unknown Firmware completion request type %d\n",\r\nfwreq->hdr.type);\r\nbreak;\r\n}\r\ncmpl_time = jiffies - start;\r\nif (cmpl_time > atomic64_read(&snic->s_stats.io.max_cmpl_time))\r\natomic64_set(&snic->s_stats.io.max_cmpl_time, cmpl_time);\r\nreturn 0;\r\n}\r\nint\r\nsnic_fwcq_cmpl_handler(struct snic *snic, int io_cmpl_work)\r\n{\r\nunsigned int num_ent = 0;\r\nunsigned int cq_idx;\r\nunsigned int nent_per_cq;\r\nstruct snic_misc_stats *misc_stats = &snic->s_stats.misc;\r\nfor (cq_idx = snic->wq_count; cq_idx < snic->cq_count; cq_idx++) {\r\nnent_per_cq = vnic_cq_fw_service(&snic->cq[cq_idx],\r\nsnic_io_cmpl_handler,\r\nio_cmpl_work);\r\nnum_ent += nent_per_cq;\r\nif (nent_per_cq > atomic64_read(&misc_stats->max_cq_ents))\r\natomic64_set(&misc_stats->max_cq_ents, nent_per_cq);\r\n}\r\nreturn num_ent;\r\n}\r\nstatic int\r\nsnic_queue_itmf_req(struct snic *snic,\r\nstruct snic_host_req *tmreq,\r\nstruct scsi_cmnd *sc,\r\nu32 tmf,\r\nu32 req_id)\r\n{\r\nstruct snic_req_info *rqi = req_to_rqi(tmreq);\r\nstruct scsi_lun lun;\r\nint tm_tag = snic_cmd_tag(sc) | rqi->tm_tag;\r\nint ret = 0;\r\nSNIC_BUG_ON(!rqi);\r\nSNIC_BUG_ON(!rqi->tm_tag);\r\nint_to_scsilun(sc->device->lun, &lun);\r\nsnic_itmf_init(tmreq,\r\ntm_tag,\r\nsnic->config.hid,\r\n(ulong) rqi,\r\n0 ,\r\nreq_id,\r\nrqi->tgt_id,\r\nlun.scsi_lun,\r\ntmf);\r\nret = snic_queue_wq_desc(snic, tmreq, sizeof(*tmreq));\r\nif (ret)\r\nSNIC_HOST_ERR(snic->shost,\r\n"qitmf:Queuing ITMF(%d) Req sc %p, rqi %p, req_id %d tag %d Failed, ret = %d\n",\r\ntmf, sc, rqi, req_id, snic_cmd_tag(sc), ret);\r\nelse\r\nSNIC_SCSI_DBG(snic->shost,\r\n"qitmf:Queuing ITMF(%d) Req sc %p, rqi %p, req_id %d, tag %d (req_id)- Success.",\r\ntmf, sc, rqi, req_id, snic_cmd_tag(sc));\r\nreturn ret;\r\n}\r\nstatic int\r\nsnic_issue_tm_req(struct snic *snic,\r\nstruct snic_req_info *rqi,\r\nstruct scsi_cmnd *sc,\r\nint tmf)\r\n{\r\nstruct snic_host_req *tmreq = NULL;\r\nint req_id = 0, tag = snic_cmd_tag(sc);\r\nint ret = 0;\r\nif (snic_get_state(snic) == SNIC_FWRESET)\r\nreturn -EBUSY;\r\natomic_inc(&snic->ios_inflight);\r\nSNIC_SCSI_DBG(snic->shost,\r\n"issu_tmreq: Task mgmt req %d. rqi %p w/ tag %x\n",\r\ntmf, rqi, tag);\r\nif (tmf == SNIC_ITMF_LUN_RESET) {\r\ntmreq = snic_dr_req_init(snic, rqi);\r\nreq_id = SCSI_NO_TAG;\r\n} else {\r\ntmreq = snic_abort_req_init(snic, rqi);\r\nreq_id = tag;\r\n}\r\nif (!tmreq) {\r\nret = -ENOMEM;\r\ngoto tmreq_err;\r\n}\r\nret = snic_queue_itmf_req(snic, tmreq, sc, tmf, req_id);\r\nif (ret)\r\ngoto tmreq_err;\r\nret = 0;\r\ntmreq_err:\r\nif (ret) {\r\nSNIC_HOST_ERR(snic->shost,\r\n"issu_tmreq: Queing ITMF(%d) Req, sc %p rqi %p req_id %d tag %x fails err = %d\n",\r\ntmf, sc, rqi, req_id, tag, ret);\r\n} else {\r\nSNIC_SCSI_DBG(snic->shost,\r\n"issu_tmreq: Queuing ITMF(%d) Req, sc %p, rqi %p, req_id %d tag %x - Success.\n",\r\ntmf, sc, rqi, req_id, tag);\r\n}\r\natomic_dec(&snic->ios_inflight);\r\nreturn ret;\r\n}\r\nstatic int\r\nsnic_queue_abort_req(struct snic *snic,\r\nstruct snic_req_info *rqi,\r\nstruct scsi_cmnd *sc,\r\nint tmf)\r\n{\r\nSNIC_SCSI_DBG(snic->shost, "q_abtreq: sc %p, rqi %p, tag %x, tmf %d\n",\r\nsc, rqi, snic_cmd_tag(sc), tmf);\r\nrqi->tm_tag |= SNIC_TAG_ABORT;\r\nreturn snic_issue_tm_req(snic, rqi, sc, tmf);\r\n}\r\nstatic int\r\nsnic_abort_finish(struct snic *snic, struct scsi_cmnd *sc)\r\n{\r\nstruct snic_req_info *rqi = NULL;\r\nspinlock_t *io_lock = NULL;\r\nunsigned long flags;\r\nint ret = 0, tag = snic_cmd_tag(sc);\r\nio_lock = snic_io_lock_hash(snic, sc);\r\nspin_lock_irqsave(io_lock, flags);\r\nrqi = (struct snic_req_info *) CMD_SP(sc);\r\nif (!rqi) {\r\natomic64_inc(&snic->s_stats.io.req_null);\r\nCMD_FLAGS(sc) |= SNIC_IO_ABTS_TERM_REQ_NULL;\r\nSNIC_SCSI_DBG(snic->shost,\r\n"abt_fini:req info is null tag 0x%x, sc 0x%p flags 0x%llx\n",\r\ntag, sc, CMD_FLAGS(sc));\r\nret = FAILED;\r\ngoto abort_fail;\r\n}\r\nrqi->abts_done = NULL;\r\nret = FAILED;\r\nswitch (CMD_ABTS_STATUS(sc)) {\r\ncase SNIC_INVALID_CODE:\r\nCMD_FLAGS(sc) |= SNIC_IO_ABTS_TIMEDOUT;\r\natomic64_inc(&snic->s_stats.abts.drv_tmo);\r\nSNIC_SCSI_DBG(snic->shost,\r\n"abt_fini:sc %p Tag %x Driver Timeout.flags 0x%llx\n",\r\nsc, snic_cmd_tag(sc), CMD_FLAGS(sc));\r\nrqi = NULL;\r\ngoto abort_fail;\r\ncase SNIC_STAT_IO_SUCCESS:\r\ncase SNIC_STAT_IO_NOT_FOUND:\r\nret = SUCCESS;\r\nsc->result = (DID_ERROR << 16);\r\nsc->scsi_done(sc);\r\nbreak;\r\ndefault:\r\nret = FAILED;\r\nrqi = NULL;\r\nbreak;\r\n}\r\nCMD_SP(sc) = NULL;\r\nSNIC_HOST_INFO(snic->shost,\r\n"abt_fini: Tag %x, Cmpl Status %s flags 0x%llx\n",\r\ntag, snic_io_status_to_str(CMD_ABTS_STATUS(sc)),\r\nCMD_FLAGS(sc));\r\nabort_fail:\r\nspin_unlock_irqrestore(io_lock, flags);\r\nif (rqi)\r\nsnic_release_req_buf(snic, rqi, sc);\r\nreturn ret;\r\n}\r\nstatic int\r\nsnic_send_abort_and_wait(struct snic *snic, struct scsi_cmnd *sc)\r\n{\r\nstruct snic_req_info *rqi = NULL;\r\nenum snic_ioreq_state sv_state;\r\nstruct snic_tgt *tgt = NULL;\r\nspinlock_t *io_lock = NULL;\r\nDECLARE_COMPLETION_ONSTACK(tm_done);\r\nunsigned long flags;\r\nint ret = 0, tmf = 0, tag = snic_cmd_tag(sc);\r\ntgt = starget_to_tgt(scsi_target(sc->device));\r\nif ((snic_tgt_chkready(tgt) != 0) && (tgt->tdata.typ == SNIC_TGT_SAN))\r\ntmf = SNIC_ITMF_ABTS_TASK_TERM;\r\nelse\r\ntmf = SNIC_ITMF_ABTS_TASK;\r\nio_lock = snic_io_lock_hash(snic, sc);\r\nspin_lock_irqsave(io_lock, flags);\r\nrqi = (struct snic_req_info *) CMD_SP(sc);\r\nif (!rqi) {\r\nspin_unlock_irqrestore(io_lock, flags);\r\nSNIC_HOST_ERR(snic->shost,\r\n"abt_cmd: rqi is null. Tag %d flags 0x%llx\n",\r\ntag, CMD_FLAGS(sc));\r\nret = SUCCESS;\r\ngoto send_abts_end;\r\n}\r\nrqi->abts_done = &tm_done;\r\nif (CMD_STATE(sc) == SNIC_IOREQ_ABTS_PENDING) {\r\nspin_unlock_irqrestore(io_lock, flags);\r\nret = 0;\r\ngoto abts_pending;\r\n}\r\nSNIC_BUG_ON(!rqi->abts_done);\r\nsv_state = CMD_STATE(sc);\r\nCMD_STATE(sc) = SNIC_IOREQ_ABTS_PENDING;\r\nCMD_ABTS_STATUS(sc) = SNIC_INVALID_CODE;\r\nSNIC_SCSI_DBG(snic->shost, "send_abt_cmd: TAG 0x%x\n", tag);\r\nspin_unlock_irqrestore(io_lock, flags);\r\nret = snic_queue_abort_req(snic, rqi, sc, tmf);\r\nif (ret) {\r\natomic64_inc(&snic->s_stats.abts.q_fail);\r\nSNIC_HOST_ERR(snic->shost,\r\n"send_abt_cmd: IO w/ Tag 0x%x fail w/ err %d flags 0x%llx\n",\r\ntag, ret, CMD_FLAGS(sc));\r\nspin_lock_irqsave(io_lock, flags);\r\nCMD_STATE(sc) = sv_state;\r\nrqi = (struct snic_req_info *) CMD_SP(sc);\r\nif (rqi)\r\nrqi->abts_done = NULL;\r\nspin_unlock_irqrestore(io_lock, flags);\r\nret = FAILED;\r\ngoto send_abts_end;\r\n}\r\nspin_lock_irqsave(io_lock, flags);\r\nif (tmf == SNIC_ITMF_ABTS_TASK) {\r\nCMD_FLAGS(sc) |= SNIC_IO_ABTS_ISSUED;\r\natomic64_inc(&snic->s_stats.abts.num);\r\n} else {\r\nCMD_FLAGS(sc) |= SNIC_IO_TERM_ISSUED;\r\n}\r\nspin_unlock_irqrestore(io_lock, flags);\r\nSNIC_SCSI_DBG(snic->shost,\r\n"send_abt_cmd: sc %p Tag %x flags 0x%llx\n",\r\nsc, tag, CMD_FLAGS(sc));\r\nret = 0;\r\nabts_pending:\r\nwait_for_completion_timeout(&tm_done, SNIC_ABTS_TIMEOUT);\r\nsend_abts_end:\r\nreturn ret;\r\n}\r\nint\r\nsnic_abort_cmd(struct scsi_cmnd *sc)\r\n{\r\nstruct snic *snic = shost_priv(sc->device->host);\r\nint ret = SUCCESS, tag = snic_cmd_tag(sc);\r\nu32 start_time = jiffies;\r\nSNIC_SCSI_DBG(snic->shost, "abt_cmd:sc %p :0x%x :req = %p :tag = %d\n",\r\nsc, sc->cmnd[0], sc->request, tag);\r\nif (unlikely(snic_get_state(snic) != SNIC_ONLINE)) {\r\nSNIC_HOST_ERR(snic->shost,\r\n"abt_cmd: tag %x Parent Devs are not rdy\n",\r\ntag);\r\nret = FAST_IO_FAIL;\r\ngoto abort_end;\r\n}\r\nret = snic_send_abort_and_wait(snic, sc);\r\nif (ret)\r\ngoto abort_end;\r\nret = snic_abort_finish(snic, sc);\r\nabort_end:\r\nSNIC_TRC(snic->shost->host_no, tag, (ulong) sc,\r\njiffies_to_msecs(jiffies - start_time), 0,\r\nSNIC_TRC_CMD(sc), SNIC_TRC_CMD_STATE_FLAGS(sc));\r\nSNIC_SCSI_DBG(snic->shost,\r\n"abts: Abort Req Status = %s\n",\r\n(ret == SUCCESS) ? "SUCCESS" :\r\n((ret == FAST_IO_FAIL) ? "FAST_IO_FAIL" : "FAILED"));\r\nreturn ret;\r\n}\r\nstatic int\r\nsnic_is_abts_pending(struct snic *snic, struct scsi_cmnd *lr_sc)\r\n{\r\nstruct snic_req_info *rqi = NULL;\r\nstruct scsi_cmnd *sc = NULL;\r\nstruct scsi_device *lr_sdev = NULL;\r\nspinlock_t *io_lock = NULL;\r\nu32 tag;\r\nunsigned long flags;\r\nif (lr_sc)\r\nlr_sdev = lr_sc->device;\r\nfor (tag = 0; tag < snic->max_tag_id; tag++) {\r\nio_lock = snic_io_lock_tag(snic, tag);\r\nspin_lock_irqsave(io_lock, flags);\r\nsc = scsi_host_find_tag(snic->shost, tag);\r\nif (!sc || (lr_sc && (sc->device != lr_sdev || sc == lr_sc))) {\r\nspin_unlock_irqrestore(io_lock, flags);\r\ncontinue;\r\n}\r\nrqi = (struct snic_req_info *) CMD_SP(sc);\r\nif (!rqi) {\r\nspin_unlock_irqrestore(io_lock, flags);\r\ncontinue;\r\n}\r\nSNIC_SCSI_DBG(snic->shost, "Found IO in %s on LUN\n",\r\nsnic_ioreq_state_to_str(CMD_STATE(sc)));\r\nif (CMD_STATE(sc) == SNIC_IOREQ_ABTS_PENDING) {\r\nspin_unlock_irqrestore(io_lock, flags);\r\nreturn 1;\r\n}\r\nspin_unlock_irqrestore(io_lock, flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nsnic_dr_clean_single_req(struct snic *snic,\r\nu32 tag,\r\nstruct scsi_device *lr_sdev)\r\n{\r\nstruct snic_req_info *rqi = NULL;\r\nstruct snic_tgt *tgt = NULL;\r\nstruct scsi_cmnd *sc = NULL;\r\nspinlock_t *io_lock = NULL;\r\nu32 sv_state = 0, tmf = 0;\r\nDECLARE_COMPLETION_ONSTACK(tm_done);\r\nunsigned long flags;\r\nint ret = 0;\r\nio_lock = snic_io_lock_tag(snic, tag);\r\nspin_lock_irqsave(io_lock, flags);\r\nsc = scsi_host_find_tag(snic->shost, tag);\r\nif (!sc || sc->device != lr_sdev)\r\ngoto skip_clean;\r\nrqi = (struct snic_req_info *) CMD_SP(sc);\r\nif (!rqi)\r\ngoto skip_clean;\r\nif (CMD_STATE(sc) == SNIC_IOREQ_ABTS_PENDING)\r\ngoto skip_clean;\r\nif ((CMD_FLAGS(sc) & SNIC_DEVICE_RESET) &&\r\n(!(CMD_FLAGS(sc) & SNIC_DEV_RST_ISSUED))) {\r\nSNIC_SCSI_DBG(snic->shost,\r\n"clean_single_req: devrst is not pending sc 0x%p\n",\r\nsc);\r\ngoto skip_clean;\r\n}\r\nSNIC_SCSI_DBG(snic->shost,\r\n"clean_single_req: Found IO in %s on lun\n",\r\nsnic_ioreq_state_to_str(CMD_STATE(sc)));\r\nsv_state = CMD_STATE(sc);\r\nCMD_STATE(sc) = SNIC_IOREQ_ABTS_PENDING;\r\nSNIC_BUG_ON(rqi->abts_done);\r\nif (CMD_FLAGS(sc) & SNIC_DEVICE_RESET) {\r\nrqi->tm_tag = SNIC_TAG_DEV_RST;\r\nSNIC_SCSI_DBG(snic->shost,\r\n"clean_single_req:devrst sc 0x%p\n", sc);\r\n}\r\nCMD_ABTS_STATUS(sc) = SNIC_INVALID_CODE;\r\nrqi->abts_done = &tm_done;\r\nspin_unlock_irqrestore(io_lock, flags);\r\ntgt = starget_to_tgt(scsi_target(sc->device));\r\nif ((snic_tgt_chkready(tgt) != 0) && (tgt->tdata.typ == SNIC_TGT_SAN))\r\ntmf = SNIC_ITMF_ABTS_TASK_TERM;\r\nelse\r\ntmf = SNIC_ITMF_ABTS_TASK;\r\nret = snic_queue_abort_req(snic, rqi, sc, tmf);\r\nif (ret) {\r\nSNIC_HOST_ERR(snic->shost,\r\n"clean_single_req_err:sc %p, tag %d abt failed. tm_tag %d flags 0x%llx\n",\r\nsc, tag, rqi->tm_tag, CMD_FLAGS(sc));\r\nspin_lock_irqsave(io_lock, flags);\r\nrqi = (struct snic_req_info *) CMD_SP(sc);\r\nif (rqi)\r\nrqi->abts_done = NULL;\r\nif (CMD_STATE(sc) == SNIC_IOREQ_ABTS_PENDING)\r\nCMD_STATE(sc) = sv_state;\r\nret = 1;\r\ngoto skip_clean;\r\n}\r\nspin_lock_irqsave(io_lock, flags);\r\nif (CMD_FLAGS(sc) & SNIC_DEVICE_RESET)\r\nCMD_FLAGS(sc) |= SNIC_DEV_RST_TERM_ISSUED;\r\nCMD_FLAGS(sc) |= SNIC_IO_INTERNAL_TERM_ISSUED;\r\nspin_unlock_irqrestore(io_lock, flags);\r\nwait_for_completion_timeout(&tm_done, SNIC_ABTS_TIMEOUT);\r\nspin_lock_irqsave(io_lock, flags);\r\nrqi = (struct snic_req_info *) CMD_SP(sc);\r\nif (!rqi) {\r\nCMD_FLAGS(sc) |= SNIC_IO_ABTS_TERM_REQ_NULL;\r\ngoto skip_clean;\r\n}\r\nrqi->abts_done = NULL;\r\nif (CMD_ABTS_STATUS(sc) == SNIC_INVALID_CODE) {\r\nSNIC_HOST_ERR(snic->shost,\r\n"clean_single_req_err:sc %p tag %d abt still pending w/ fw, tm_tag %d flags 0x%llx\n",\r\nsc, tag, rqi->tm_tag, CMD_FLAGS(sc));\r\nCMD_FLAGS(sc) |= SNIC_IO_ABTS_TERM_DONE;\r\nret = 1;\r\ngoto skip_clean;\r\n}\r\nCMD_STATE(sc) = SNIC_IOREQ_ABTS_COMPLETE;\r\nCMD_SP(sc) = NULL;\r\nspin_unlock_irqrestore(io_lock, flags);\r\nsnic_release_req_buf(snic, rqi, sc);\r\nsc->result = (DID_ERROR << 16);\r\nsc->scsi_done(sc);\r\nret = 0;\r\nreturn ret;\r\nskip_clean:\r\nspin_unlock_irqrestore(io_lock, flags);\r\nreturn ret;\r\n}\r\nstatic int\r\nsnic_dr_clean_pending_req(struct snic *snic, struct scsi_cmnd *lr_sc)\r\n{\r\nstruct scsi_device *lr_sdev = lr_sc->device;\r\nu32 tag = 0;\r\nint ret = FAILED;\r\nfor (tag = 0; tag < snic->max_tag_id; tag++) {\r\nif (tag == snic_cmd_tag(lr_sc))\r\ncontinue;\r\nret = snic_dr_clean_single_req(snic, tag, lr_sdev);\r\nif (ret) {\r\nSNIC_HOST_ERR(snic->shost, "clean_err:tag = %d\n", tag);\r\ngoto clean_err;\r\n}\r\n}\r\nschedule_timeout(msecs_to_jiffies(100));\r\nif (snic_is_abts_pending(snic, lr_sc)) {\r\nret = FAILED;\r\ngoto clean_err;\r\n}\r\nret = 0;\r\nSNIC_SCSI_DBG(snic->shost, "clean_pending_req: Success.\n");\r\nreturn ret;\r\nclean_err:\r\nret = FAILED;\r\nSNIC_HOST_ERR(snic->shost,\r\n"Failed to Clean Pending IOs on %s device.\n",\r\ndev_name(&lr_sdev->sdev_gendev));\r\nreturn ret;\r\n}\r\nstatic int\r\nsnic_dr_finish(struct snic *snic, struct scsi_cmnd *sc)\r\n{\r\nstruct snic_req_info *rqi = NULL;\r\nspinlock_t *io_lock = NULL;\r\nunsigned long flags;\r\nint lr_res = 0;\r\nint ret = FAILED;\r\nio_lock = snic_io_lock_hash(snic, sc);\r\nspin_lock_irqsave(io_lock, flags);\r\nrqi = (struct snic_req_info *) CMD_SP(sc);\r\nif (!rqi) {\r\nspin_unlock_irqrestore(io_lock, flags);\r\nSNIC_SCSI_DBG(snic->shost,\r\n"dr_fini: rqi is null tag 0x%x sc 0x%p flags 0x%llx\n",\r\nsnic_cmd_tag(sc), sc, CMD_FLAGS(sc));\r\nret = FAILED;\r\ngoto dr_fini_end;\r\n}\r\nrqi->dr_done = NULL;\r\nlr_res = CMD_LR_STATUS(sc);\r\nswitch (lr_res) {\r\ncase SNIC_INVALID_CODE:\r\nSNIC_SCSI_DBG(snic->shost,\r\n"dr_fini: Tag %x Dev Reset Timedout. flags 0x%llx\n",\r\nsnic_cmd_tag(sc), CMD_FLAGS(sc));\r\nCMD_FLAGS(sc) |= SNIC_DEV_RST_TIMEDOUT;\r\nret = FAILED;\r\ngoto dr_failed;\r\ncase SNIC_STAT_IO_SUCCESS:\r\nSNIC_SCSI_DBG(snic->shost,\r\n"dr_fini: Tag %x Dev Reset cmpl\n",\r\nsnic_cmd_tag(sc));\r\nret = 0;\r\nbreak;\r\ndefault:\r\nSNIC_HOST_ERR(snic->shost,\r\n"dr_fini:Device Reset completed& failed.Tag = %x lr_status %s flags 0x%llx\n",\r\nsnic_cmd_tag(sc),\r\nsnic_io_status_to_str(lr_res), CMD_FLAGS(sc));\r\nret = FAILED;\r\ngoto dr_failed;\r\n}\r\nspin_unlock_irqrestore(io_lock, flags);\r\nret = snic_dr_clean_pending_req(snic, sc);\r\nif (ret) {\r\nspin_lock_irqsave(io_lock, flags);\r\nSNIC_SCSI_DBG(snic->shost,\r\n"dr_fini: Device Reset Failed since could not abort all IOs. Tag = %x.\n",\r\nsnic_cmd_tag(sc));\r\nrqi = (struct snic_req_info *) CMD_SP(sc);\r\ngoto dr_failed;\r\n} else {\r\nspin_lock_irqsave(io_lock, flags);\r\nrqi = (struct snic_req_info *) CMD_SP(sc);\r\nif (rqi)\r\nret = SUCCESS;\r\nelse\r\nret = FAILED;\r\n}\r\ndr_failed:\r\nSNIC_BUG_ON(!spin_is_locked(io_lock));\r\nif (rqi)\r\nCMD_SP(sc) = NULL;\r\nspin_unlock_irqrestore(io_lock, flags);\r\nif (rqi)\r\nsnic_release_req_buf(snic, rqi, sc);\r\ndr_fini_end:\r\nreturn ret;\r\n}\r\nstatic int\r\nsnic_queue_dr_req(struct snic *snic,\r\nstruct snic_req_info *rqi,\r\nstruct scsi_cmnd *sc)\r\n{\r\nrqi->tm_tag |= SNIC_TAG_DEV_RST;\r\nreturn snic_issue_tm_req(snic, rqi, sc, SNIC_ITMF_LUN_RESET);\r\n}\r\nstatic int\r\nsnic_send_dr_and_wait(struct snic *snic, struct scsi_cmnd *sc)\r\n{\r\nstruct snic_req_info *rqi = NULL;\r\nenum snic_ioreq_state sv_state;\r\nspinlock_t *io_lock = NULL;\r\nunsigned long flags;\r\nDECLARE_COMPLETION_ONSTACK(tm_done);\r\nint ret = FAILED, tag = snic_cmd_tag(sc);\r\nio_lock = snic_io_lock_hash(snic, sc);\r\nspin_lock_irqsave(io_lock, flags);\r\nCMD_FLAGS(sc) |= SNIC_DEVICE_RESET;\r\nrqi = (struct snic_req_info *) CMD_SP(sc);\r\nif (!rqi) {\r\nSNIC_HOST_ERR(snic->shost,\r\n"send_dr: rqi is null, Tag 0x%x flags 0x%llx\n",\r\ntag, CMD_FLAGS(sc));\r\nspin_unlock_irqrestore(io_lock, flags);\r\nret = FAILED;\r\ngoto send_dr_end;\r\n}\r\nsv_state = CMD_STATE(sc);\r\nCMD_STATE(sc) = SNIC_IOREQ_LR_PENDING;\r\nCMD_LR_STATUS(sc) = SNIC_INVALID_CODE;\r\nSNIC_SCSI_DBG(snic->shost, "dr: TAG = %x\n", tag);\r\nrqi->dr_done = &tm_done;\r\nSNIC_BUG_ON(!rqi->dr_done);\r\nspin_unlock_irqrestore(io_lock, flags);\r\nret = snic_queue_dr_req(snic, rqi, sc);\r\nif (ret) {\r\nSNIC_HOST_ERR(snic->shost,\r\n"send_dr: IO w/ Tag 0x%x Failed err = %d. flags 0x%llx\n",\r\ntag, ret, CMD_FLAGS(sc));\r\nspin_lock_irqsave(io_lock, flags);\r\nCMD_STATE(sc) = sv_state;\r\nrqi = (struct snic_req_info *) CMD_SP(sc);\r\nif (rqi)\r\nrqi->dr_done = NULL;\r\nspin_unlock_irqrestore(io_lock, flags);\r\nret = FAILED;\r\ngoto send_dr_end;\r\n}\r\nspin_lock_irqsave(io_lock, flags);\r\nCMD_FLAGS(sc) |= SNIC_DEV_RST_ISSUED;\r\nspin_unlock_irqrestore(io_lock, flags);\r\nret = 0;\r\nwait_for_completion_timeout(&tm_done, SNIC_LUN_RESET_TIMEOUT);\r\nsend_dr_end:\r\nreturn ret;\r\n}\r\nstatic int\r\nsnic_dev_reset_supported(struct scsi_device *sdev)\r\n{\r\nstruct snic_tgt *tgt = starget_to_tgt(scsi_target(sdev));\r\nif (tgt->tdata.typ == SNIC_TGT_DAS)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void\r\nsnic_unlink_and_release_req(struct snic *snic, struct scsi_cmnd *sc, int flag)\r\n{\r\nstruct snic_req_info *rqi = NULL;\r\nspinlock_t *io_lock = NULL;\r\nunsigned long flags;\r\nu32 start_time = jiffies;\r\nio_lock = snic_io_lock_hash(snic, sc);\r\nspin_lock_irqsave(io_lock, flags);\r\nrqi = (struct snic_req_info *) CMD_SP(sc);\r\nif (rqi) {\r\nstart_time = rqi->start_time;\r\nCMD_SP(sc) = NULL;\r\n}\r\nCMD_FLAGS(sc) |= flag;\r\nspin_unlock_irqrestore(io_lock, flags);\r\nif (rqi)\r\nsnic_release_req_buf(snic, rqi, sc);\r\nSNIC_TRC(snic->shost->host_no, snic_cmd_tag(sc), (ulong) sc,\r\njiffies_to_msecs(jiffies - start_time), (ulong) rqi,\r\nSNIC_TRC_CMD(sc), SNIC_TRC_CMD_STATE_FLAGS(sc));\r\n}\r\nint\r\nsnic_device_reset(struct scsi_cmnd *sc)\r\n{\r\nstruct Scsi_Host *shost = sc->device->host;\r\nstruct snic *snic = shost_priv(shost);\r\nstruct snic_req_info *rqi = NULL;\r\nint tag = snic_cmd_tag(sc);\r\nint start_time = jiffies;\r\nint ret = FAILED;\r\nint dr_supp = 0;\r\nSNIC_SCSI_DBG(shost, "dev_reset:sc %p :0x%x :req = %p :tag = %d\n",\r\nsc, sc->cmnd[0], sc->request,\r\nsnic_cmd_tag(sc));\r\ndr_supp = snic_dev_reset_supported(sc->device);\r\nif (!dr_supp) {\r\nSNIC_HOST_INFO(shost, "LUN Reset Op not supported.\n");\r\nsnic_unlink_and_release_req(snic, sc, SNIC_DEV_RST_NOTSUP);\r\ngoto dev_rst_end;\r\n}\r\nif (unlikely(snic_get_state(snic) != SNIC_ONLINE)) {\r\nsnic_unlink_and_release_req(snic, sc, 0);\r\nSNIC_HOST_ERR(shost, "Devrst: Parent Devs are not online.\n");\r\ngoto dev_rst_end;\r\n}\r\nif (unlikely(tag <= SNIC_NO_TAG)) {\r\nSNIC_HOST_INFO(snic->shost,\r\n"Devrst: LUN Reset Recvd thru IOCTL.\n");\r\nrqi = snic_req_init(snic, 0);\r\nif (!rqi)\r\ngoto dev_rst_end;\r\nmemset(scsi_cmd_priv(sc), 0,\r\nsizeof(struct snic_internal_io_state));\r\nCMD_SP(sc) = (char *)rqi;\r\nCMD_FLAGS(sc) = SNIC_NO_FLAGS;\r\nrqi->tm_tag = SNIC_TAG_IOCTL_DEV_RST;\r\nrqi->sc = sc;\r\n}\r\nret = snic_send_dr_and_wait(snic, sc);\r\nif (ret) {\r\nSNIC_HOST_ERR(snic->shost,\r\n"Devrst: IO w/ Tag %x Failed w/ err = %d\n",\r\ntag, ret);\r\nsnic_unlink_and_release_req(snic, sc, 0);\r\ngoto dev_rst_end;\r\n}\r\nret = snic_dr_finish(snic, sc);\r\ndev_rst_end:\r\nSNIC_TRC(snic->shost->host_no, tag, (ulong) sc,\r\njiffies_to_msecs(jiffies - start_time),\r\n0, SNIC_TRC_CMD(sc), SNIC_TRC_CMD_STATE_FLAGS(sc));\r\nSNIC_SCSI_DBG(snic->shost,\r\n"Devrst: Returning from Device Reset : %s\n",\r\n(ret == SUCCESS) ? "SUCCESS" : "FAILED");\r\nreturn ret;\r\n}\r\nstatic int\r\nsnic_issue_hba_reset(struct snic *snic, struct scsi_cmnd *sc)\r\n{\r\nstruct snic_req_info *rqi = NULL;\r\nstruct snic_host_req *req = NULL;\r\nspinlock_t *io_lock = NULL;\r\nDECLARE_COMPLETION_ONSTACK(wait);\r\nunsigned long flags;\r\nint ret = -ENOMEM;\r\nrqi = snic_req_init(snic, 0);\r\nif (!rqi) {\r\nret = -ENOMEM;\r\ngoto hba_rst_end;\r\n}\r\nif (snic_cmd_tag(sc) == SCSI_NO_TAG) {\r\nmemset(scsi_cmd_priv(sc), 0,\r\nsizeof(struct snic_internal_io_state));\r\nSNIC_HOST_INFO(snic->shost, "issu_hr:Host reset thru ioctl.\n");\r\nrqi->sc = sc;\r\n}\r\nreq = rqi_to_req(rqi);\r\nio_lock = snic_io_lock_hash(snic, sc);\r\nspin_lock_irqsave(io_lock, flags);\r\nSNIC_BUG_ON(CMD_SP(sc) != NULL);\r\nCMD_STATE(sc) = SNIC_IOREQ_PENDING;\r\nCMD_SP(sc) = (char *) rqi;\r\nCMD_FLAGS(sc) |= SNIC_IO_INITIALIZED;\r\nsnic->remove_wait = &wait;\r\nspin_unlock_irqrestore(io_lock, flags);\r\nsnic_io_hdr_enc(&req->hdr, SNIC_REQ_HBA_RESET, 0, snic_cmd_tag(sc),\r\nsnic->config.hid, 0, (ulong) rqi);\r\nreq->u.reset.flags = 0;\r\nret = snic_queue_wq_desc(snic, req, sizeof(*req));\r\nif (ret) {\r\nSNIC_HOST_ERR(snic->shost,\r\n"issu_hr:Queuing HBA Reset Failed. w err %d\n",\r\nret);\r\ngoto hba_rst_err;\r\n}\r\nspin_lock_irqsave(io_lock, flags);\r\nCMD_FLAGS(sc) |= SNIC_HOST_RESET_ISSUED;\r\nspin_unlock_irqrestore(io_lock, flags);\r\natomic64_inc(&snic->s_stats.reset.hba_resets);\r\nSNIC_HOST_INFO(snic->shost, "Queued HBA Reset Successfully.\n");\r\nwait_for_completion_timeout(snic->remove_wait,\r\nSNIC_HOST_RESET_TIMEOUT);\r\nif (snic_get_state(snic) == SNIC_FWRESET) {\r\nSNIC_HOST_ERR(snic->shost, "reset_cmpl: Reset Timedout.\n");\r\nret = -ETIMEDOUT;\r\ngoto hba_rst_err;\r\n}\r\nspin_lock_irqsave(io_lock, flags);\r\nsnic->remove_wait = NULL;\r\nrqi = (struct snic_req_info *) CMD_SP(sc);\r\nCMD_SP(sc) = NULL;\r\nspin_unlock_irqrestore(io_lock, flags);\r\nif (rqi)\r\nsnic_req_free(snic, rqi);\r\nret = 0;\r\nreturn ret;\r\nhba_rst_err:\r\nspin_lock_irqsave(io_lock, flags);\r\nsnic->remove_wait = NULL;\r\nrqi = (struct snic_req_info *) CMD_SP(sc);\r\nCMD_SP(sc) = NULL;\r\nspin_unlock_irqrestore(io_lock, flags);\r\nif (rqi)\r\nsnic_req_free(snic, rqi);\r\nhba_rst_end:\r\nSNIC_HOST_ERR(snic->shost,\r\n"reset:HBA Reset Failed w/ err = %d.\n",\r\nret);\r\nreturn ret;\r\n}\r\nint\r\nsnic_reset(struct Scsi_Host *shost, struct scsi_cmnd *sc)\r\n{\r\nstruct snic *snic = shost_priv(shost);\r\nenum snic_state sv_state;\r\nunsigned long flags;\r\nint ret = FAILED;\r\nsv_state = snic_get_state(snic);\r\nspin_lock_irqsave(&snic->snic_lock, flags);\r\nif (snic_get_state(snic) == SNIC_FWRESET) {\r\nspin_unlock_irqrestore(&snic->snic_lock, flags);\r\nSNIC_HOST_INFO(shost, "reset:prev reset is in progres\n");\r\nmsleep(SNIC_HOST_RESET_TIMEOUT);\r\nret = SUCCESS;\r\ngoto reset_end;\r\n}\r\nsnic_set_state(snic, SNIC_FWRESET);\r\nspin_unlock_irqrestore(&snic->snic_lock, flags);\r\nwhile (atomic_read(&snic->ios_inflight))\r\nschedule_timeout(msecs_to_jiffies(1));\r\nret = snic_issue_hba_reset(snic, sc);\r\nif (ret) {\r\nSNIC_HOST_ERR(shost,\r\n"reset:Host Reset Failed w/ err %d.\n",\r\nret);\r\nspin_lock_irqsave(&snic->snic_lock, flags);\r\nsnic_set_state(snic, sv_state);\r\nspin_unlock_irqrestore(&snic->snic_lock, flags);\r\natomic64_inc(&snic->s_stats.reset.hba_reset_fail);\r\nret = FAILED;\r\ngoto reset_end;\r\n}\r\nret = SUCCESS;\r\nreset_end:\r\nreturn ret;\r\n}\r\nint\r\nsnic_host_reset(struct scsi_cmnd *sc)\r\n{\r\nstruct Scsi_Host *shost = sc->device->host;\r\nu32 start_time = jiffies;\r\nint ret = FAILED;\r\nSNIC_SCSI_DBG(shost,\r\n"host reset:sc %p sc_cmd 0x%x req %p tag %d flags 0x%llx\n",\r\nsc, sc->cmnd[0], sc->request,\r\nsnic_cmd_tag(sc), CMD_FLAGS(sc));\r\nret = snic_reset(shost, sc);\r\nSNIC_TRC(shost->host_no, snic_cmd_tag(sc), (ulong) sc,\r\njiffies_to_msecs(jiffies - start_time),\r\n0, SNIC_TRC_CMD(sc), SNIC_TRC_CMD_STATE_FLAGS(sc));\r\nreturn ret;\r\n}\r\nstatic void\r\nsnic_cmpl_pending_tmreq(struct snic *snic, struct scsi_cmnd *sc)\r\n{\r\nstruct snic_req_info *rqi = NULL;\r\nSNIC_SCSI_DBG(snic->shost,\r\n"Completing Pending TM Req sc %p, state %s flags 0x%llx\n",\r\nsc, snic_io_status_to_str(CMD_STATE(sc)), CMD_FLAGS(sc));\r\nCMD_ABTS_STATUS(sc) = SNIC_STAT_IO_SUCCESS;\r\nrqi = (struct snic_req_info *) CMD_SP(sc);\r\nif (!rqi)\r\nreturn;\r\nif (rqi->dr_done)\r\ncomplete(rqi->dr_done);\r\nelse if (rqi->abts_done)\r\ncomplete(rqi->abts_done);\r\n}\r\nstatic void\r\nsnic_scsi_cleanup(struct snic *snic, int ex_tag)\r\n{\r\nstruct snic_req_info *rqi = NULL;\r\nstruct scsi_cmnd *sc = NULL;\r\nspinlock_t *io_lock = NULL;\r\nunsigned long flags;\r\nint tag;\r\nu64 st_time = 0;\r\nSNIC_SCSI_DBG(snic->shost, "sc_clean: scsi cleanup.\n");\r\nfor (tag = 0; tag < snic->max_tag_id; tag++) {\r\nif (tag == ex_tag)\r\ncontinue;\r\nio_lock = snic_io_lock_tag(snic, tag);\r\nspin_lock_irqsave(io_lock, flags);\r\nsc = scsi_host_find_tag(snic->shost, tag);\r\nif (!sc) {\r\nspin_unlock_irqrestore(io_lock, flags);\r\ncontinue;\r\n}\r\nif (unlikely(snic_tmreq_pending(sc))) {\r\nsnic_cmpl_pending_tmreq(snic, sc);\r\nspin_unlock_irqrestore(io_lock, flags);\r\ncontinue;\r\n}\r\nrqi = (struct snic_req_info *) CMD_SP(sc);\r\nif (!rqi) {\r\nspin_unlock_irqrestore(io_lock, flags);\r\ngoto cleanup;\r\n}\r\nSNIC_SCSI_DBG(snic->shost,\r\n"sc_clean: sc %p, rqi %p, tag %d flags 0x%llx\n",\r\nsc, rqi, tag, CMD_FLAGS(sc));\r\nCMD_SP(sc) = NULL;\r\nCMD_FLAGS(sc) |= SNIC_SCSI_CLEANUP;\r\nspin_unlock_irqrestore(io_lock, flags);\r\nst_time = rqi->start_time;\r\nSNIC_HOST_INFO(snic->shost,\r\n"sc_clean: Releasing rqi %p : flags 0x%llx\n",\r\nrqi, CMD_FLAGS(sc));\r\nsnic_release_req_buf(snic, rqi, sc);\r\ncleanup:\r\nsc->result = DID_TRANSPORT_DISRUPTED << 16;\r\nSNIC_HOST_INFO(snic->shost,\r\n"sc_clean: DID_TRANSPORT_DISRUPTED for sc %p, Tag %d flags 0x%llx rqi %p duration %u msecs\n",\r\nsc, sc->request->tag, CMD_FLAGS(sc), rqi,\r\njiffies_to_msecs(jiffies - st_time));\r\nsnic_stats_update_io_cmpl(&snic->s_stats);\r\nif (sc->scsi_done) {\r\nSNIC_TRC(snic->shost->host_no, tag, (ulong) sc,\r\njiffies_to_msecs(jiffies - st_time), 0,\r\nSNIC_TRC_CMD(sc),\r\nSNIC_TRC_CMD_STATE_FLAGS(sc));\r\nsc->scsi_done(sc);\r\n}\r\n}\r\n}\r\nvoid\r\nsnic_shutdown_scsi_cleanup(struct snic *snic)\r\n{\r\nSNIC_HOST_INFO(snic->shost, "Shutdown time SCSI Cleanup.\n");\r\nsnic_scsi_cleanup(snic, SCSI_NO_TAG);\r\n}\r\nstatic int\r\nsnic_internal_abort_io(struct snic *snic, struct scsi_cmnd *sc, int tmf)\r\n{\r\nstruct snic_req_info *rqi = NULL;\r\nspinlock_t *io_lock = NULL;\r\nunsigned long flags;\r\nu32 sv_state = 0;\r\nint ret = 0;\r\nio_lock = snic_io_lock_hash(snic, sc);\r\nspin_lock_irqsave(io_lock, flags);\r\nrqi = (struct snic_req_info *) CMD_SP(sc);\r\nif (!rqi)\r\ngoto skip_internal_abts;\r\nif (CMD_STATE(sc) == SNIC_IOREQ_ABTS_PENDING)\r\ngoto skip_internal_abts;\r\nif ((CMD_FLAGS(sc) & SNIC_DEVICE_RESET) &&\r\n(!(CMD_FLAGS(sc) & SNIC_DEV_RST_ISSUED))) {\r\nSNIC_SCSI_DBG(snic->shost,\r\n"internal_abts: dev rst not pending sc 0x%p\n",\r\nsc);\r\ngoto skip_internal_abts;\r\n}\r\nif (!(CMD_FLAGS(sc) & SNIC_IO_ISSUED)) {\r\nSNIC_SCSI_DBG(snic->shost,\r\n"internal_abts: IO not yet issued sc 0x%p tag 0x%x flags 0x%llx state %d\n",\r\nsc, snic_cmd_tag(sc), CMD_FLAGS(sc), CMD_STATE(sc));\r\ngoto skip_internal_abts;\r\n}\r\nsv_state = CMD_STATE(sc);\r\nCMD_STATE(sc) = SNIC_IOREQ_ABTS_PENDING;\r\nCMD_ABTS_STATUS(sc) = SNIC_INVALID_CODE;\r\nCMD_FLAGS(sc) |= SNIC_IO_INTERNAL_TERM_PENDING;\r\nif (CMD_FLAGS(sc) & SNIC_DEVICE_RESET) {\r\nrqi->tm_tag = SNIC_TAG_DEV_RST;\r\nSNIC_SCSI_DBG(snic->shost, "internal_abts:dev rst sc %p\n", sc);\r\n}\r\nSNIC_SCSI_DBG(snic->shost, "internal_abts: Issuing abts tag %x\n",\r\nsnic_cmd_tag(sc));\r\nSNIC_BUG_ON(rqi->abts_done);\r\nspin_unlock_irqrestore(io_lock, flags);\r\nret = snic_queue_abort_req(snic, rqi, sc, tmf);\r\nif (ret) {\r\nSNIC_HOST_ERR(snic->shost,\r\n"internal_abts: Tag = %x , Failed w/ err = %d\n",\r\nsnic_cmd_tag(sc), ret);\r\nspin_lock_irqsave(io_lock, flags);\r\nif (CMD_STATE(sc) == SNIC_IOREQ_ABTS_PENDING)\r\nCMD_STATE(sc) = sv_state;\r\ngoto skip_internal_abts;\r\n}\r\nspin_lock_irqsave(io_lock, flags);\r\nif (CMD_FLAGS(sc) & SNIC_DEVICE_RESET)\r\nCMD_FLAGS(sc) |= SNIC_DEV_RST_TERM_ISSUED;\r\nelse\r\nCMD_FLAGS(sc) |= SNIC_IO_INTERNAL_TERM_ISSUED;\r\nret = SUCCESS;\r\nskip_internal_abts:\r\nSNIC_BUG_ON(!spin_is_locked(io_lock));\r\nspin_unlock_irqrestore(io_lock, flags);\r\nreturn ret;\r\n}\r\nint\r\nsnic_tgt_scsi_abort_io(struct snic_tgt *tgt)\r\n{\r\nstruct snic *snic = NULL;\r\nstruct scsi_cmnd *sc = NULL;\r\nstruct snic_tgt *sc_tgt = NULL;\r\nspinlock_t *io_lock = NULL;\r\nunsigned long flags;\r\nint ret = 0, tag, abt_cnt = 0, tmf = 0;\r\nif (!tgt)\r\nreturn -1;\r\nsnic = shost_priv(snic_tgt_to_shost(tgt));\r\nSNIC_SCSI_DBG(snic->shost, "tgt_abt_io: Cleaning Pending IOs.\n");\r\nif (tgt->tdata.typ == SNIC_TGT_DAS)\r\ntmf = SNIC_ITMF_ABTS_TASK;\r\nelse\r\ntmf = SNIC_ITMF_ABTS_TASK_TERM;\r\nfor (tag = 0; tag < snic->max_tag_id; tag++) {\r\nio_lock = snic_io_lock_tag(snic, tag);\r\nspin_lock_irqsave(io_lock, flags);\r\nsc = scsi_host_find_tag(snic->shost, tag);\r\nif (!sc) {\r\nspin_unlock_irqrestore(io_lock, flags);\r\ncontinue;\r\n}\r\nsc_tgt = starget_to_tgt(scsi_target(sc->device));\r\nif (sc_tgt != tgt) {\r\nspin_unlock_irqrestore(io_lock, flags);\r\ncontinue;\r\n}\r\nspin_unlock_irqrestore(io_lock, flags);\r\nret = snic_internal_abort_io(snic, sc, tmf);\r\nif (ret < 0) {\r\nSNIC_HOST_ERR(snic->shost,\r\n"tgt_abt_io: Tag %x, Failed w err = %d\n",\r\ntag, ret);\r\ncontinue;\r\n}\r\nif (ret == SUCCESS)\r\nabt_cnt++;\r\n}\r\nSNIC_SCSI_DBG(snic->shost, "tgt_abt_io: abt_cnt = %d\n", abt_cnt);\r\nreturn 0;\r\n}
