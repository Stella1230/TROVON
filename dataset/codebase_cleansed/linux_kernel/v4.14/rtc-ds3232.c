static int ds3232_check_rtc_status(struct device *dev)\r\n{\r\nstruct ds3232 *ds3232 = dev_get_drvdata(dev);\r\nint ret = 0;\r\nint control, stat;\r\nret = regmap_read(ds3232->regmap, DS3232_REG_SR, &stat);\r\nif (ret)\r\nreturn ret;\r\nif (stat & DS3232_REG_SR_OSF)\r\ndev_warn(dev,\r\n"oscillator discontinuity flagged, "\r\n"time unreliable\n");\r\nstat &= ~(DS3232_REG_SR_OSF | DS3232_REG_SR_A1F | DS3232_REG_SR_A2F);\r\nret = regmap_write(ds3232->regmap, DS3232_REG_SR, stat);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_read(ds3232->regmap, DS3232_REG_CR, &control);\r\nif (ret)\r\nreturn ret;\r\ncontrol &= ~(DS3232_REG_CR_A1IE | DS3232_REG_CR_A2IE);\r\ncontrol |= DS3232_REG_CR_INTCN;\r\nreturn regmap_write(ds3232->regmap, DS3232_REG_CR, control);\r\n}\r\nstatic int ds3232_read_time(struct device *dev, struct rtc_time *time)\r\n{\r\nstruct ds3232 *ds3232 = dev_get_drvdata(dev);\r\nint ret;\r\nu8 buf[7];\r\nunsigned int year, month, day, hour, minute, second;\r\nunsigned int week, twelve_hr, am_pm;\r\nunsigned int century, add_century = 0;\r\nret = regmap_bulk_read(ds3232->regmap, DS3232_REG_SECONDS, buf, 7);\r\nif (ret)\r\nreturn ret;\r\nsecond = buf[0];\r\nminute = buf[1];\r\nhour = buf[2];\r\nweek = buf[3];\r\nday = buf[4];\r\nmonth = buf[5];\r\nyear = buf[6];\r\ntwelve_hr = hour & 0x40;\r\nam_pm = hour & 0x20;\r\ncentury = month & 0x80;\r\ntime->tm_sec = bcd2bin(second);\r\ntime->tm_min = bcd2bin(minute);\r\nif (twelve_hr) {\r\nif (am_pm)\r\ntime->tm_hour = bcd2bin(hour & 0x1F) + 12;\r\nelse\r\ntime->tm_hour = bcd2bin(hour & 0x1F);\r\n} else {\r\ntime->tm_hour = bcd2bin(hour);\r\n}\r\ntime->tm_wday = bcd2bin(week) - 1;\r\ntime->tm_mday = bcd2bin(day);\r\ntime->tm_mon = bcd2bin(month & 0x7F) - 1;\r\nif (century)\r\nadd_century = 100;\r\ntime->tm_year = bcd2bin(year) + add_century;\r\nreturn rtc_valid_tm(time);\r\n}\r\nstatic int ds3232_set_time(struct device *dev, struct rtc_time *time)\r\n{\r\nstruct ds3232 *ds3232 = dev_get_drvdata(dev);\r\nu8 buf[7];\r\nbuf[0] = bin2bcd(time->tm_sec);\r\nbuf[1] = bin2bcd(time->tm_min);\r\nbuf[2] = bin2bcd(time->tm_hour);\r\nbuf[3] = bin2bcd(time->tm_wday + 1);\r\nbuf[4] = bin2bcd(time->tm_mday);\r\nbuf[5] = bin2bcd(time->tm_mon + 1);\r\nif (time->tm_year >= 100) {\r\nbuf[5] |= 0x80;\r\nbuf[6] = bin2bcd(time->tm_year - 100);\r\n} else {\r\nbuf[6] = bin2bcd(time->tm_year);\r\n}\r\nreturn regmap_bulk_write(ds3232->regmap, DS3232_REG_SECONDS, buf, 7);\r\n}\r\nstatic int ds3232_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)\r\n{\r\nstruct ds3232 *ds3232 = dev_get_drvdata(dev);\r\nint control, stat;\r\nint ret;\r\nu8 buf[4];\r\nret = regmap_read(ds3232->regmap, DS3232_REG_SR, &stat);\r\nif (ret)\r\ngoto out;\r\nret = regmap_read(ds3232->regmap, DS3232_REG_CR, &control);\r\nif (ret)\r\ngoto out;\r\nret = regmap_bulk_read(ds3232->regmap, DS3232_REG_ALARM1, buf, 4);\r\nif (ret)\r\ngoto out;\r\nalarm->time.tm_sec = bcd2bin(buf[0] & 0x7F);\r\nalarm->time.tm_min = bcd2bin(buf[1] & 0x7F);\r\nalarm->time.tm_hour = bcd2bin(buf[2] & 0x7F);\r\nalarm->time.tm_mday = bcd2bin(buf[3] & 0x7F);\r\nalarm->enabled = !!(control & DS3232_REG_CR_A1IE);\r\nalarm->pending = !!(stat & DS3232_REG_SR_A1F);\r\nret = 0;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int ds3232_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)\r\n{\r\nstruct ds3232 *ds3232 = dev_get_drvdata(dev);\r\nint control, stat;\r\nint ret;\r\nu8 buf[4];\r\nif (ds3232->irq <= 0)\r\nreturn -EINVAL;\r\nbuf[0] = bin2bcd(alarm->time.tm_sec);\r\nbuf[1] = bin2bcd(alarm->time.tm_min);\r\nbuf[2] = bin2bcd(alarm->time.tm_hour);\r\nbuf[3] = bin2bcd(alarm->time.tm_mday);\r\nret = regmap_read(ds3232->regmap, DS3232_REG_CR, &control);\r\nif (ret)\r\ngoto out;\r\ncontrol &= ~(DS3232_REG_CR_A1IE | DS3232_REG_CR_A2IE);\r\nret = regmap_write(ds3232->regmap, DS3232_REG_CR, control);\r\nif (ret)\r\ngoto out;\r\nret = regmap_read(ds3232->regmap, DS3232_REG_SR, &stat);\r\nif (ret)\r\ngoto out;\r\nstat &= ~(DS3232_REG_SR_A1F | DS3232_REG_SR_A2F);\r\nret = regmap_write(ds3232->regmap, DS3232_REG_SR, stat);\r\nif (ret)\r\ngoto out;\r\nret = regmap_bulk_write(ds3232->regmap, DS3232_REG_ALARM1, buf, 4);\r\nif (ret)\r\ngoto out;\r\nif (alarm->enabled) {\r\ncontrol |= DS3232_REG_CR_A1IE;\r\nret = regmap_write(ds3232->regmap, DS3232_REG_CR, control);\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int ds3232_update_alarm(struct device *dev, unsigned int enabled)\r\n{\r\nstruct ds3232 *ds3232 = dev_get_drvdata(dev);\r\nint control;\r\nint ret;\r\nret = regmap_read(ds3232->regmap, DS3232_REG_CR, &control);\r\nif (ret)\r\nreturn ret;\r\nif (enabled)\r\ncontrol |= DS3232_REG_CR_A1IE;\r\nelse\r\ncontrol &= ~(DS3232_REG_CR_A1IE);\r\nret = regmap_write(ds3232->regmap, DS3232_REG_CR, control);\r\nreturn ret;\r\n}\r\nstatic int ds3232_hwmon_read_temp(struct device *dev, long int *mC)\r\n{\r\nstruct ds3232 *ds3232 = dev_get_drvdata(dev);\r\nu8 temp_buf[2];\r\ns16 temp;\r\nint ret;\r\nret = regmap_bulk_read(ds3232->regmap, DS3232_REG_TEMPERATURE, temp_buf,\r\nsizeof(temp_buf));\r\nif (ret < 0)\r\nreturn ret;\r\ntemp = (temp_buf[0] << 8) | temp_buf[1];\r\ntemp >>= 6;\r\n*mC = temp * 250;\r\nreturn 0;\r\n}\r\nstatic umode_t ds3232_hwmon_is_visible(const void *data,\r\nenum hwmon_sensor_types type,\r\nu32 attr, int channel)\r\n{\r\nif (type != hwmon_temp)\r\nreturn 0;\r\nswitch (attr) {\r\ncase hwmon_temp_input:\r\nreturn 0444;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int ds3232_hwmon_read(struct device *dev,\r\nenum hwmon_sensor_types type,\r\nu32 attr, int channel, long *temp)\r\n{\r\nint err;\r\nswitch (attr) {\r\ncase hwmon_temp_input:\r\nerr = ds3232_hwmon_read_temp(dev, temp);\r\nbreak;\r\ndefault:\r\nerr = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic void ds3232_hwmon_register(struct device *dev, const char *name)\r\n{\r\nstruct ds3232 *ds3232 = dev_get_drvdata(dev);\r\nstruct device *hwmon_dev;\r\nif (!IS_ENABLED(CONFIG_RTC_DRV_DS3232_HWMON))\r\nreturn;\r\nhwmon_dev = devm_hwmon_device_register_with_info(dev, name, ds3232,\r\n&ds3232_hwmon_chip_info,\r\nNULL);\r\nif (IS_ERR(hwmon_dev)) {\r\ndev_err(dev, "unable to register hwmon device %ld\n",\r\nPTR_ERR(hwmon_dev));\r\n}\r\n}\r\nstatic int ds3232_alarm_irq_enable(struct device *dev, unsigned int enabled)\r\n{\r\nstruct ds3232 *ds3232 = dev_get_drvdata(dev);\r\nif (ds3232->irq <= 0)\r\nreturn -EINVAL;\r\nreturn ds3232_update_alarm(dev, enabled);\r\n}\r\nstatic irqreturn_t ds3232_irq(int irq, void *dev_id)\r\n{\r\nstruct device *dev = dev_id;\r\nstruct ds3232 *ds3232 = dev_get_drvdata(dev);\r\nstruct mutex *lock = &ds3232->rtc->ops_lock;\r\nint ret;\r\nint stat, control;\r\nmutex_lock(lock);\r\nret = regmap_read(ds3232->regmap, DS3232_REG_SR, &stat);\r\nif (ret)\r\ngoto unlock;\r\nif (stat & DS3232_REG_SR_A1F) {\r\nret = regmap_read(ds3232->regmap, DS3232_REG_CR, &control);\r\nif (ret) {\r\ndev_warn(ds3232->dev,\r\n"Read Control Register error %d\n", ret);\r\n} else {\r\ncontrol &= ~(DS3232_REG_CR_A1IE);\r\nret = regmap_write(ds3232->regmap, DS3232_REG_CR,\r\ncontrol);\r\nif (ret) {\r\ndev_warn(ds3232->dev,\r\n"Write Control Register error %d\n",\r\nret);\r\ngoto unlock;\r\n}\r\nstat &= ~DS3232_REG_SR_A1F;\r\nret = regmap_write(ds3232->regmap, DS3232_REG_SR, stat);\r\nif (ret) {\r\ndev_warn(ds3232->dev,\r\n"Write Status Register error %d\n",\r\nret);\r\ngoto unlock;\r\n}\r\nrtc_update_irq(ds3232->rtc, 1, RTC_AF | RTC_IRQF);\r\n}\r\n}\r\nunlock:\r\nmutex_unlock(lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ds3232_probe(struct device *dev, struct regmap *regmap, int irq,\r\nconst char *name)\r\n{\r\nstruct ds3232 *ds3232;\r\nint ret;\r\nds3232 = devm_kzalloc(dev, sizeof(*ds3232), GFP_KERNEL);\r\nif (!ds3232)\r\nreturn -ENOMEM;\r\nds3232->regmap = regmap;\r\nds3232->irq = irq;\r\nds3232->dev = dev;\r\ndev_set_drvdata(dev, ds3232);\r\nret = ds3232_check_rtc_status(dev);\r\nif (ret)\r\nreturn ret;\r\nif (ds3232->irq > 0)\r\ndevice_init_wakeup(dev, 1);\r\nds3232_hwmon_register(dev, name);\r\nds3232->rtc = devm_rtc_device_register(dev, name, &ds3232_rtc_ops,\r\nTHIS_MODULE);\r\nif (IS_ERR(ds3232->rtc))\r\nreturn PTR_ERR(ds3232->rtc);\r\nif (ds3232->irq > 0) {\r\nret = devm_request_threaded_irq(dev, ds3232->irq, NULL,\r\nds3232_irq,\r\nIRQF_SHARED | IRQF_ONESHOT,\r\nname, dev);\r\nif (ret) {\r\ndevice_set_wakeup_capable(dev, 0);\r\nds3232->irq = 0;\r\ndev_err(dev, "unable to request IRQ\n");\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ds3232_suspend(struct device *dev)\r\n{\r\nstruct ds3232 *ds3232 = dev_get_drvdata(dev);\r\nif (device_may_wakeup(dev)) {\r\nif (enable_irq_wake(ds3232->irq))\r\ndev_warn_once(dev, "Cannot set wakeup source\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int ds3232_resume(struct device *dev)\r\n{\r\nstruct ds3232 *ds3232 = dev_get_drvdata(dev);\r\nif (device_may_wakeup(dev))\r\ndisable_irq_wake(ds3232->irq);\r\nreturn 0;\r\n}\r\nstatic int ds3232_i2c_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct regmap *regmap;\r\nstatic const struct regmap_config config = {\r\n.reg_bits = 8,\r\n.val_bits = 8,\r\n.max_register = 0x13,\r\n};\r\nregmap = devm_regmap_init_i2c(client, &config);\r\nif (IS_ERR(regmap)) {\r\ndev_err(&client->dev, "%s: regmap allocation failed: %ld\n",\r\n__func__, PTR_ERR(regmap));\r\nreturn PTR_ERR(regmap);\r\n}\r\nreturn ds3232_probe(&client->dev, regmap, client->irq, client->name);\r\n}\r\nstatic int ds3232_register_driver(void)\r\n{\r\nreturn i2c_add_driver(&ds3232_driver);\r\n}\r\nstatic void ds3232_unregister_driver(void)\r\n{\r\ni2c_del_driver(&ds3232_driver);\r\n}\r\nstatic int ds3232_register_driver(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void ds3232_unregister_driver(void)\r\n{\r\n}\r\nstatic int ds3234_probe(struct spi_device *spi)\r\n{\r\nint res;\r\nunsigned int tmp;\r\nstatic const struct regmap_config config = {\r\n.reg_bits = 8,\r\n.val_bits = 8,\r\n.max_register = 0x13,\r\n.write_flag_mask = 0x80,\r\n};\r\nstruct regmap *regmap;\r\nregmap = devm_regmap_init_spi(spi, &config);\r\nif (IS_ERR(regmap)) {\r\ndev_err(&spi->dev, "%s: regmap allocation failed: %ld\n",\r\n__func__, PTR_ERR(regmap));\r\nreturn PTR_ERR(regmap);\r\n}\r\nspi->mode = SPI_MODE_3;\r\nspi->bits_per_word = 8;\r\nspi_setup(spi);\r\nres = regmap_read(regmap, DS3232_REG_SECONDS, &tmp);\r\nif (res)\r\nreturn res;\r\nres = regmap_read(regmap, DS3232_REG_CR, &tmp);\r\nif (res)\r\nreturn res;\r\nres = regmap_write(regmap, DS3232_REG_CR, tmp & 0x1c);\r\nif (res)\r\nreturn res;\r\nres = regmap_read(regmap, DS3232_REG_SR, &tmp);\r\nif (res)\r\nreturn res;\r\nres = regmap_write(regmap, DS3232_REG_SR, tmp & 0x88);\r\nif (res)\r\nreturn res;\r\nres = regmap_read(regmap, DS3232_REG_CR, &tmp);\r\nif (res)\r\nreturn res;\r\ndev_info(&spi->dev, "Control Reg: 0x%02x\n", tmp);\r\nres = regmap_read(regmap, DS3232_REG_SR, &tmp);\r\nif (res)\r\nreturn res;\r\ndev_info(&spi->dev, "Ctrl/Stat Reg: 0x%02x\n", tmp);\r\nreturn ds3232_probe(&spi->dev, regmap, spi->irq, "ds3234");\r\n}\r\nstatic int ds3234_register_driver(void)\r\n{\r\nreturn spi_register_driver(&ds3234_driver);\r\n}\r\nstatic void ds3234_unregister_driver(void)\r\n{\r\nspi_unregister_driver(&ds3234_driver);\r\n}\r\nstatic int ds3234_register_driver(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void ds3234_unregister_driver(void)\r\n{\r\n}\r\nstatic int __init ds323x_init(void)\r\n{\r\nint ret;\r\nret = ds3232_register_driver();\r\nif (ret) {\r\npr_err("Failed to register ds3232 driver: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = ds3234_register_driver();\r\nif (ret) {\r\npr_err("Failed to register ds3234 driver: %d\n", ret);\r\nds3232_unregister_driver();\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit ds323x_exit(void)\r\n{\r\nds3234_unregister_driver();\r\nds3232_unregister_driver();\r\n}
