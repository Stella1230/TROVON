static struct genwqe_dev *genwqe_dev_alloc(void)\r\n{\r\nunsigned int i = 0, j;\r\nstruct genwqe_dev *cd;\r\nfor (i = 0; i < GENWQE_CARD_NO_MAX; i++) {\r\nif (genwqe_devices[i] == NULL)\r\nbreak;\r\n}\r\nif (i >= GENWQE_CARD_NO_MAX)\r\nreturn ERR_PTR(-ENODEV);\r\ncd = kzalloc(sizeof(struct genwqe_dev), GFP_KERNEL);\r\nif (!cd)\r\nreturn ERR_PTR(-ENOMEM);\r\ncd->card_idx = i;\r\ncd->class_genwqe = class_genwqe;\r\ncd->debugfs_genwqe = debugfs_genwqe;\r\ncd->use_platform_recovery = CONFIG_GENWQE_PLATFORM_ERROR_RECOVERY;\r\ninit_waitqueue_head(&cd->queue_waitq);\r\nspin_lock_init(&cd->file_lock);\r\nINIT_LIST_HEAD(&cd->file_list);\r\ncd->card_state = GENWQE_CARD_UNUSED;\r\nspin_lock_init(&cd->print_lock);\r\ncd->ddcb_software_timeout = genwqe_ddcb_software_timeout;\r\ncd->kill_timeout = genwqe_kill_timeout;\r\nfor (j = 0; j < GENWQE_MAX_VFS; j++)\r\ncd->vf_jobtimeout_msec[j] = genwqe_vf_jobtimeout_msec;\r\ngenwqe_devices[i] = cd;\r\nreturn cd;\r\n}\r\nstatic void genwqe_dev_free(struct genwqe_dev *cd)\r\n{\r\nif (!cd)\r\nreturn;\r\ngenwqe_devices[cd->card_idx] = NULL;\r\nkfree(cd);\r\n}\r\nstatic int genwqe_bus_reset(struct genwqe_dev *cd)\r\n{\r\nint rc = 0;\r\nstruct pci_dev *pci_dev = cd->pci_dev;\r\nvoid __iomem *mmio;\r\nif (cd->err_inject & GENWQE_INJECT_BUS_RESET_FAILURE)\r\nreturn -EIO;\r\nmmio = cd->mmio;\r\ncd->mmio = NULL;\r\npci_iounmap(pci_dev, mmio);\r\npci_release_mem_regions(pci_dev);\r\ndev_dbg(&pci_dev->dev, "[%s] pci_reset function ...\n", __func__);\r\nrc = pci_reset_function(pci_dev);\r\nif (rc) {\r\ndev_err(&pci_dev->dev,\r\n"[%s] err: failed reset func (rc %d)\n", __func__, rc);\r\nreturn rc;\r\n}\r\ndev_dbg(&pci_dev->dev, "[%s] done with rc=%d\n", __func__, rc);\r\ncd->err_inject &= ~(GENWQE_INJECT_HARDWARE_FAILURE |\r\nGENWQE_INJECT_GFIR_FATAL |\r\nGENWQE_INJECT_GFIR_INFO);\r\nrc = pci_request_mem_regions(pci_dev, genwqe_driver_name);\r\nif (rc) {\r\ndev_err(&pci_dev->dev,\r\n"[%s] err: request bars failed (%d)\n", __func__, rc);\r\nreturn -EIO;\r\n}\r\ncd->mmio = pci_iomap(pci_dev, 0, 0);\r\nif (cd->mmio == NULL) {\r\ndev_err(&pci_dev->dev,\r\n"[%s] err: mapping BAR0 failed\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nbool genwqe_need_err_masking(struct genwqe_dev *cd)\r\n{\r\nreturn (cd->slu_unitcfg & 0xFFFF0ull) < 0x32170ull;\r\n}\r\nstatic void genwqe_tweak_hardware(struct genwqe_dev *cd)\r\n{\r\nstruct pci_dev *pci_dev = cd->pci_dev;\r\nif (((cd->slu_unitcfg & 0xFFFF0ull) >= 0x32000ull) &&\r\n((cd->slu_unitcfg & 0xFFFF0ull) <= 0x33250ull)) {\r\ndev_warn(&pci_dev->dev,\r\n"FIRs masked due to bitstream %016llx.%016llx\n",\r\ncd->slu_unitcfg, cd->app_unitcfg);\r\n__genwqe_writeq(cd, IO_APP_SEC_LEM_DEBUG_OVR,\r\n0xFFFFFFFFFFFFFFFFull);\r\n__genwqe_writeq(cd, IO_APP_ERR_ACT_MASK,\r\n0x0000000000000000ull);\r\n}\r\n}\r\nint genwqe_recovery_on_fatal_gfir_required(struct genwqe_dev *cd)\r\n{\r\nreturn (cd->slu_unitcfg & 0xFFFF0ull) >= 0x32170ull;\r\n}\r\nint genwqe_flash_readback_fails(struct genwqe_dev *cd)\r\n{\r\nreturn (cd->slu_unitcfg & 0xFFFF0ull) < 0x32170ull;\r\n}\r\nstatic int genwqe_T_psec(struct genwqe_dev *cd)\r\n{\r\nu16 speed;\r\nstatic const int T[] = { 4000, 5000, 6000, 5714 };\r\nspeed = (u16)((cd->slu_unitcfg >> 28) & 0x0full);\r\nif (speed >= ARRAY_SIZE(T))\r\nreturn -1;\r\nreturn T[speed];\r\n}\r\nstatic bool genwqe_setup_pf_jtimer(struct genwqe_dev *cd)\r\n{\r\nu32 T = genwqe_T_psec(cd);\r\nu64 x;\r\nif (genwqe_pf_jobtimeout_msec == 0)\r\nreturn false;\r\nx = ilog2(genwqe_pf_jobtimeout_msec *\r\n16000000000uL/(T * 15)) - 10;\r\ngenwqe_write_vreg(cd, IO_SLC_VF_APPJOB_TIMEOUT,\r\n0xff00 | (x & 0xff), 0);\r\nreturn true;\r\n}\r\nstatic bool genwqe_setup_vf_jtimer(struct genwqe_dev *cd)\r\n{\r\nstruct pci_dev *pci_dev = cd->pci_dev;\r\nunsigned int vf;\r\nu32 T = genwqe_T_psec(cd);\r\nu64 x;\r\nint totalvfs;\r\ntotalvfs = pci_sriov_get_totalvfs(pci_dev);\r\nif (totalvfs <= 0)\r\nreturn false;\r\nfor (vf = 0; vf < totalvfs; vf++) {\r\nif (cd->vf_jobtimeout_msec[vf] == 0)\r\ncontinue;\r\nx = ilog2(cd->vf_jobtimeout_msec[vf] *\r\n16000000000uL/(T * 15)) - 10;\r\ngenwqe_write_vreg(cd, IO_SLC_VF_APPJOB_TIMEOUT,\r\n0xff00 | (x & 0xff), vf + 1);\r\n}\r\nreturn true;\r\n}\r\nstatic int genwqe_ffdc_buffs_alloc(struct genwqe_dev *cd)\r\n{\r\nunsigned int type, e = 0;\r\nfor (type = 0; type < GENWQE_DBG_UNITS; type++) {\r\nswitch (type) {\r\ncase GENWQE_DBG_UNIT0:\r\ne = genwqe_ffdc_buff_size(cd, 0);\r\nbreak;\r\ncase GENWQE_DBG_UNIT1:\r\ne = genwqe_ffdc_buff_size(cd, 1);\r\nbreak;\r\ncase GENWQE_DBG_UNIT2:\r\ne = genwqe_ffdc_buff_size(cd, 2);\r\nbreak;\r\ncase GENWQE_DBG_REGS:\r\ne = GENWQE_FFDC_REGS;\r\nbreak;\r\n}\r\ncd->ffdc[type].entries = e;\r\ncd->ffdc[type].regs =\r\nkmalloc_array(e, sizeof(struct genwqe_reg),\r\nGFP_KERNEL);\r\n}\r\nreturn 0;\r\n}\r\nstatic void genwqe_ffdc_buffs_free(struct genwqe_dev *cd)\r\n{\r\nunsigned int type;\r\nfor (type = 0; type < GENWQE_DBG_UNITS; type++) {\r\nkfree(cd->ffdc[type].regs);\r\ncd->ffdc[type].regs = NULL;\r\n}\r\n}\r\nstatic int genwqe_read_ids(struct genwqe_dev *cd)\r\n{\r\nint err = 0;\r\nint slu_id;\r\nstruct pci_dev *pci_dev = cd->pci_dev;\r\ncd->slu_unitcfg = __genwqe_readq(cd, IO_SLU_UNITCFG);\r\nif (cd->slu_unitcfg == IO_ILLEGAL_VALUE) {\r\ndev_err(&pci_dev->dev,\r\n"err: SLUID=%016llx\n", cd->slu_unitcfg);\r\nerr = -EIO;\r\ngoto out_err;\r\n}\r\nslu_id = genwqe_get_slu_id(cd);\r\nif (slu_id < GENWQE_SLU_ARCH_REQ || slu_id == 0xff) {\r\ndev_err(&pci_dev->dev,\r\n"err: incompatible SLU Architecture %u\n", slu_id);\r\nerr = -ENOENT;\r\ngoto out_err;\r\n}\r\ncd->app_unitcfg = __genwqe_readq(cd, IO_APP_UNITCFG);\r\nif (cd->app_unitcfg == IO_ILLEGAL_VALUE) {\r\ndev_err(&pci_dev->dev,\r\n"err: APPID=%016llx\n", cd->app_unitcfg);\r\nerr = -EIO;\r\ngoto out_err;\r\n}\r\ngenwqe_read_app_id(cd, cd->app_name, sizeof(cd->app_name));\r\nif (pci_dev->is_virtfn)\r\ncd->is_privileged = 0;\r\nelse\r\ncd->is_privileged = (__genwqe_readq(cd, IO_SLU_BITSTREAM)\r\n!= IO_ILLEGAL_VALUE);\r\nout_err:\r\nreturn err;\r\n}\r\nstatic int genwqe_start(struct genwqe_dev *cd)\r\n{\r\nint err;\r\nstruct pci_dev *pci_dev = cd->pci_dev;\r\nerr = genwqe_read_ids(cd);\r\nif (err)\r\nreturn err;\r\nif (genwqe_is_privileged(cd)) {\r\ngenwqe_ffdc_buffs_alloc(cd);\r\ngenwqe_stop_traps(cd);\r\ngenwqe_read_ffdc_regs(cd, cd->ffdc[GENWQE_DBG_REGS].regs,\r\ncd->ffdc[GENWQE_DBG_REGS].entries, 0);\r\ngenwqe_ffdc_buff_read(cd, GENWQE_DBG_UNIT0,\r\ncd->ffdc[GENWQE_DBG_UNIT0].regs,\r\ncd->ffdc[GENWQE_DBG_UNIT0].entries);\r\ngenwqe_ffdc_buff_read(cd, GENWQE_DBG_UNIT1,\r\ncd->ffdc[GENWQE_DBG_UNIT1].regs,\r\ncd->ffdc[GENWQE_DBG_UNIT1].entries);\r\ngenwqe_ffdc_buff_read(cd, GENWQE_DBG_UNIT2,\r\ncd->ffdc[GENWQE_DBG_UNIT2].regs,\r\ncd->ffdc[GENWQE_DBG_UNIT2].entries);\r\ngenwqe_start_traps(cd);\r\nif (cd->card_state == GENWQE_CARD_FATAL_ERROR) {\r\ndev_warn(&pci_dev->dev,\r\n"[%s] chip reload/recovery!\n", __func__);\r\ncd->softreset = 0x7Cull;\r\n__genwqe_writeq(cd, IO_SLC_CFGREG_SOFTRESET,\r\ncd->softreset);\r\nerr = genwqe_bus_reset(cd);\r\nif (err != 0) {\r\ndev_err(&pci_dev->dev,\r\n"[%s] err: bus reset failed!\n",\r\n__func__);\r\ngoto out;\r\n}\r\nerr = genwqe_read_ids(cd);\r\nif (err)\r\ngoto out;\r\n}\r\n}\r\nerr = genwqe_setup_service_layer(cd);\r\nif (err != 0) {\r\ndev_err(&pci_dev->dev,\r\n"[%s] err: could not setup servicelayer!\n", __func__);\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\nif (genwqe_is_privileged(cd)) {\r\ngenwqe_tweak_hardware(cd);\r\ngenwqe_setup_pf_jtimer(cd);\r\ngenwqe_setup_vf_jtimer(cd);\r\n}\r\nerr = genwqe_device_create(cd);\r\nif (err < 0) {\r\ndev_err(&pci_dev->dev,\r\n"err: chdev init failed! (err=%d)\n", err);\r\ngoto out_release_service_layer;\r\n}\r\nreturn 0;\r\nout_release_service_layer:\r\ngenwqe_release_service_layer(cd);\r\nout:\r\nif (genwqe_is_privileged(cd))\r\ngenwqe_ffdc_buffs_free(cd);\r\nreturn -EIO;\r\n}\r\nstatic int genwqe_stop(struct genwqe_dev *cd)\r\n{\r\ngenwqe_finish_queue(cd);\r\ngenwqe_device_remove(cd);\r\ngenwqe_release_service_layer(cd);\r\nif (genwqe_is_privileged(cd)) {\r\npci_disable_sriov(cd->pci_dev);\r\ngenwqe_ffdc_buffs_free(cd);\r\n}\r\nreturn 0;\r\n}\r\nstatic int genwqe_recover_card(struct genwqe_dev *cd, int fatal_err)\r\n{\r\nint rc;\r\nstruct pci_dev *pci_dev = cd->pci_dev;\r\ngenwqe_stop(cd);\r\nif (!fatal_err) {\r\ncd->softreset = 0x70ull;\r\n__genwqe_writeq(cd, IO_SLC_CFGREG_SOFTRESET, cd->softreset);\r\n}\r\nrc = genwqe_bus_reset(cd);\r\nif (rc != 0) {\r\ndev_err(&pci_dev->dev,\r\n"[%s] err: card recovery impossible!\n", __func__);\r\nreturn rc;\r\n}\r\nrc = genwqe_start(cd);\r\nif (rc < 0) {\r\ndev_err(&pci_dev->dev,\r\n"[%s] err: failed to launch device!\n", __func__);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int genwqe_health_check_cond(struct genwqe_dev *cd, u64 *gfir)\r\n{\r\n*gfir = __genwqe_readq(cd, IO_SLC_CFGREG_GFIR);\r\nreturn (*gfir & GFIR_ERR_TRIGGER) &&\r\ngenwqe_recovery_on_fatal_gfir_required(cd);\r\n}\r\nstatic u64 genwqe_fir_checking(struct genwqe_dev *cd)\r\n{\r\nint j, iterations = 0;\r\nu64 mask, fir, fec, uid, gfir, gfir_masked, sfir, sfec;\r\nu32 fir_addr, fir_clr_addr, fec_addr, sfir_addr, sfec_addr;\r\nstruct pci_dev *pci_dev = cd->pci_dev;\r\nhealthMonitor:\r\niterations++;\r\nif (iterations > 16) {\r\ndev_err(&pci_dev->dev, "* exit looping after %d times\n",\r\niterations);\r\ngoto fatal_error;\r\n}\r\ngfir = __genwqe_readq(cd, IO_SLC_CFGREG_GFIR);\r\nif (gfir != 0x0)\r\ndev_err(&pci_dev->dev, "* 0x%08x 0x%016llx\n",\r\nIO_SLC_CFGREG_GFIR, gfir);\r\nif (gfir == IO_ILLEGAL_VALUE)\r\ngoto fatal_error;\r\nif (gfir == 0)\r\nreturn 0;\r\ngfir_masked = gfir & GFIR_ERR_TRIGGER;\r\nfor (uid = 0; uid < GENWQE_MAX_UNITS; uid++) {\r\nfir_addr = (uid << 24) + 0x08;\r\nfir = __genwqe_readq(cd, fir_addr);\r\nif (fir == 0x0)\r\ncontinue;\r\ndev_err(&pci_dev->dev, "* 0x%08x 0x%016llx\n", fir_addr, fir);\r\nif (fir == IO_ILLEGAL_VALUE)\r\ngoto fatal_error;\r\nfec_addr = (uid << 24) + 0x18;\r\nfec = __genwqe_readq(cd, fec_addr);\r\ndev_err(&pci_dev->dev, "* 0x%08x 0x%016llx\n", fec_addr, fec);\r\nif (fec == IO_ILLEGAL_VALUE)\r\ngoto fatal_error;\r\nfor (j = 0, mask = 1ULL; j < 64; j++, mask <<= 1) {\r\nif ((fir & mask) == 0x0)\r\ncontinue;\r\nsfir_addr = (uid << 24) + 0x100 + 0x08 * j;\r\nsfir = __genwqe_readq(cd, sfir_addr);\r\nif (sfir == IO_ILLEGAL_VALUE)\r\ngoto fatal_error;\r\ndev_err(&pci_dev->dev,\r\n"* 0x%08x 0x%016llx\n", sfir_addr, sfir);\r\nsfec_addr = (uid << 24) + 0x300 + 0x08 * j;\r\nsfec = __genwqe_readq(cd, sfec_addr);\r\nif (sfec == IO_ILLEGAL_VALUE)\r\ngoto fatal_error;\r\ndev_err(&pci_dev->dev,\r\n"* 0x%08x 0x%016llx\n", sfec_addr, sfec);\r\ngfir = __genwqe_readq(cd, IO_SLC_CFGREG_GFIR);\r\nif (gfir == IO_ILLEGAL_VALUE)\r\ngoto fatal_error;\r\nif ((gfir_masked == 0x0) &&\r\n(gfir & GFIR_ERR_TRIGGER)) {\r\ngoto healthMonitor;\r\n}\r\nif (gfir_masked == 0x0) {\r\nsfir_addr = (uid << 24) + 0x100 + 0x08 * j;\r\n__genwqe_writeq(cd, sfir_addr, sfir);\r\ndev_dbg(&pci_dev->dev,\r\n"[HM] Clearing 2ndary FIR 0x%08x with 0x%016llx\n",\r\nsfir_addr, sfir);\r\nfir_clr_addr = (uid << 24) + 0x10;\r\n__genwqe_writeq(cd, fir_clr_addr, mask);\r\ndev_dbg(&pci_dev->dev,\r\n"[HM] Clearing primary FIR 0x%08x with 0x%016llx\n",\r\nfir_clr_addr, mask);\r\n}\r\n}\r\n}\r\ngfir = __genwqe_readq(cd, IO_SLC_CFGREG_GFIR);\r\nif (gfir == IO_ILLEGAL_VALUE)\r\ngoto fatal_error;\r\nif ((gfir_masked == 0x0) && (gfir & GFIR_ERR_TRIGGER)) {\r\ndev_dbg(&pci_dev->dev, "ACK! Another FIR! Recursing %d!\n",\r\niterations);\r\ngoto healthMonitor;\r\n}\r\nreturn gfir_masked;\r\nfatal_error:\r\nreturn IO_ILLEGAL_VALUE;\r\n}\r\nstatic int genwqe_pci_fundamental_reset(struct pci_dev *pci_dev)\r\n{\r\nint rc;\r\npci_cfg_access_lock(pci_dev);\r\npci_save_state(pci_dev);\r\nrc = pci_set_pcie_reset_state(pci_dev, pcie_warm_reset);\r\nif (!rc) {\r\nmsleep(250);\r\npci_set_pcie_reset_state(pci_dev, pcie_deassert_reset);\r\nmsleep(2000);\r\n}\r\npci_restore_state(pci_dev);\r\npci_cfg_access_unlock(pci_dev);\r\nreturn rc;\r\n}\r\nstatic int genwqe_platform_recovery(struct genwqe_dev *cd)\r\n{\r\nstruct pci_dev *pci_dev = cd->pci_dev;\r\nint rc;\r\ndev_info(&pci_dev->dev,\r\n"[%s] resetting card for error recovery\n", __func__);\r\ncd->err_inject &= ~(GENWQE_INJECT_HARDWARE_FAILURE |\r\nGENWQE_INJECT_GFIR_FATAL |\r\nGENWQE_INJECT_GFIR_INFO);\r\ngenwqe_stop(cd);\r\nrc = genwqe_pci_fundamental_reset(pci_dev);\r\nif (!rc) {\r\nrc = genwqe_start(cd);\r\nif (!rc)\r\ndev_info(&pci_dev->dev,\r\n"[%s] card recovered\n", __func__);\r\nelse\r\ndev_err(&pci_dev->dev,\r\n"[%s] err: cannot start card services! (err=%d)\n",\r\n__func__, rc);\r\n} else {\r\ndev_err(&pci_dev->dev,\r\n"[%s] card reset failed\n", __func__);\r\n}\r\nreturn rc;\r\n}\r\nstatic int genwqe_reload_bistream(struct genwqe_dev *cd)\r\n{\r\nstruct pci_dev *pci_dev = cd->pci_dev;\r\nint rc;\r\ndev_info(&pci_dev->dev,\r\n"[%s] resetting card for bitstream reload\n",\r\n__func__);\r\ngenwqe_stop(cd);\r\n__genwqe_writeq(cd, IO_SLC_CFGREG_SOFTRESET,\r\n(cd->softreset & 0xcull) | 0x70ull);\r\nrc = genwqe_pci_fundamental_reset(pci_dev);\r\nif (rc) {\r\ndev_err(&pci_dev->dev,\r\n"[%s] err: failed to reset card for bitstream reload\n",\r\n__func__);\r\n}\r\nrc = genwqe_start(cd);\r\nif (rc) {\r\ndev_err(&pci_dev->dev,\r\n"[%s] err: cannot start card services! (err=%d)\n",\r\n__func__, rc);\r\nreturn rc;\r\n}\r\ndev_info(&pci_dev->dev,\r\n"[%s] card reloaded\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int genwqe_health_thread(void *data)\r\n{\r\nint rc, should_stop = 0;\r\nstruct genwqe_dev *cd = data;\r\nstruct pci_dev *pci_dev = cd->pci_dev;\r\nu64 gfir, gfir_masked, slu_unitcfg, app_unitcfg;\r\nhealth_thread_begin:\r\nwhile (!kthread_should_stop()) {\r\nrc = wait_event_interruptible_timeout(cd->health_waitq,\r\n(genwqe_health_check_cond(cd, &gfir) ||\r\n(should_stop = kthread_should_stop())),\r\ngenwqe_health_check_interval * HZ);\r\nif (should_stop)\r\nbreak;\r\nif (gfir == IO_ILLEGAL_VALUE) {\r\ndev_err(&pci_dev->dev,\r\n"[%s] GFIR=%016llx\n", __func__, gfir);\r\ngoto fatal_error;\r\n}\r\nslu_unitcfg = __genwqe_readq(cd, IO_SLU_UNITCFG);\r\nif (slu_unitcfg == IO_ILLEGAL_VALUE) {\r\ndev_err(&pci_dev->dev,\r\n"[%s] SLU_UNITCFG=%016llx\n",\r\n__func__, slu_unitcfg);\r\ngoto fatal_error;\r\n}\r\napp_unitcfg = __genwqe_readq(cd, IO_APP_UNITCFG);\r\nif (app_unitcfg == IO_ILLEGAL_VALUE) {\r\ndev_err(&pci_dev->dev,\r\n"[%s] APP_UNITCFG=%016llx\n",\r\n__func__, app_unitcfg);\r\ngoto fatal_error;\r\n}\r\ngfir = __genwqe_readq(cd, IO_SLC_CFGREG_GFIR);\r\nif (gfir == IO_ILLEGAL_VALUE) {\r\ndev_err(&pci_dev->dev,\r\n"[%s] %s: GFIR=%016llx\n", __func__,\r\n(gfir & GFIR_ERR_TRIGGER) ? "err" : "info",\r\ngfir);\r\ngoto fatal_error;\r\n}\r\ngfir_masked = genwqe_fir_checking(cd);\r\nif (gfir_masked == IO_ILLEGAL_VALUE)\r\ngoto fatal_error;\r\nif ((gfir_masked) && !cd->skip_recovery &&\r\ngenwqe_recovery_on_fatal_gfir_required(cd)) {\r\ncd->card_state = GENWQE_CARD_FATAL_ERROR;\r\nrc = genwqe_recover_card(cd, 0);\r\nif (rc < 0) {\r\ngoto fatal_error;\r\n}\r\n}\r\nif (cd->card_state == GENWQE_CARD_RELOAD_BITSTREAM) {\r\nrc = genwqe_reload_bistream(cd);\r\nif (rc)\r\ngoto fatal_error;\r\n}\r\ncd->last_gfir = gfir;\r\ncond_resched();\r\n}\r\nreturn 0;\r\nfatal_error:\r\nif (cd->use_platform_recovery) {\r\nreadq(cd->mmio + IO_SLC_CFGREG_GFIR);\r\nif (pci_channel_offline(pci_dev))\r\nreturn -EIO;\r\nrc = genwqe_platform_recovery(cd);\r\nif (!rc)\r\ngoto health_thread_begin;\r\n}\r\ndev_err(&pci_dev->dev,\r\n"[%s] card unusable. Please trigger unbind!\n", __func__);\r\ncd->card_state = GENWQE_CARD_FATAL_ERROR;\r\ngenwqe_stop(cd);\r\nwhile (!kthread_should_stop())\r\ncond_resched();\r\nreturn -EIO;\r\n}\r\nstatic int genwqe_health_check_start(struct genwqe_dev *cd)\r\n{\r\nint rc;\r\nif (genwqe_health_check_interval <= 0)\r\nreturn 0;\r\ncd->health_thread = kthread_run(genwqe_health_thread, cd,\r\nGENWQE_DEVNAME "%d_health",\r\ncd->card_idx);\r\nif (IS_ERR(cd->health_thread)) {\r\nrc = PTR_ERR(cd->health_thread);\r\ncd->health_thread = NULL;\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int genwqe_health_thread_running(struct genwqe_dev *cd)\r\n{\r\nreturn cd->health_thread != NULL;\r\n}\r\nstatic int genwqe_health_check_stop(struct genwqe_dev *cd)\r\n{\r\nint rc;\r\nif (!genwqe_health_thread_running(cd))\r\nreturn -EIO;\r\nrc = kthread_stop(cd->health_thread);\r\ncd->health_thread = NULL;\r\nreturn 0;\r\n}\r\nstatic int genwqe_pci_setup(struct genwqe_dev *cd)\r\n{\r\nint err;\r\nstruct pci_dev *pci_dev = cd->pci_dev;\r\nerr = pci_enable_device_mem(pci_dev);\r\nif (err) {\r\ndev_err(&pci_dev->dev,\r\n"err: failed to enable pci memory (err=%d)\n", err);\r\ngoto err_out;\r\n}\r\nerr = pci_request_mem_regions(pci_dev, genwqe_driver_name);\r\nif (err) {\r\ndev_err(&pci_dev->dev,\r\n"[%s] err: request bars failed (%d)\n", __func__, err);\r\nerr = -EIO;\r\ngoto err_disable_device;\r\n}\r\nif (!pci_set_dma_mask(pci_dev, DMA_BIT_MASK(64))) {\r\nerr = pci_set_consistent_dma_mask(pci_dev, DMA_BIT_MASK(64));\r\nif (err) {\r\ndev_err(&pci_dev->dev,\r\n"err: DMA64 consistent mask error\n");\r\nerr = -EIO;\r\ngoto out_release_resources;\r\n}\r\n} else if (!pci_set_dma_mask(pci_dev, DMA_BIT_MASK(32))) {\r\nerr = pci_set_consistent_dma_mask(pci_dev, DMA_BIT_MASK(32));\r\nif (err) {\r\ndev_err(&pci_dev->dev,\r\n"err: DMA32 consistent mask error\n");\r\nerr = -EIO;\r\ngoto out_release_resources;\r\n}\r\n} else {\r\ndev_err(&pci_dev->dev,\r\n"err: neither DMA32 nor DMA64 supported\n");\r\nerr = -EIO;\r\ngoto out_release_resources;\r\n}\r\npci_set_master(pci_dev);\r\npci_enable_pcie_error_reporting(pci_dev);\r\npci_dev->needs_freset = 1;\r\ncd->mmio_len = pci_resource_len(pci_dev, 0);\r\ncd->mmio = pci_iomap(pci_dev, 0, 0);\r\nif (cd->mmio == NULL) {\r\ndev_err(&pci_dev->dev,\r\n"[%s] err: mapping BAR0 failed\n", __func__);\r\nerr = -ENOMEM;\r\ngoto out_release_resources;\r\n}\r\ncd->num_vfs = pci_sriov_get_totalvfs(pci_dev);\r\nif (cd->num_vfs < 0)\r\ncd->num_vfs = 0;\r\nerr = genwqe_read_ids(cd);\r\nif (err)\r\ngoto out_iounmap;\r\nreturn 0;\r\nout_iounmap:\r\npci_iounmap(pci_dev, cd->mmio);\r\nout_release_resources:\r\npci_release_mem_regions(pci_dev);\r\nerr_disable_device:\r\npci_disable_device(pci_dev);\r\nerr_out:\r\nreturn err;\r\n}\r\nstatic void genwqe_pci_remove(struct genwqe_dev *cd)\r\n{\r\nstruct pci_dev *pci_dev = cd->pci_dev;\r\nif (cd->mmio)\r\npci_iounmap(pci_dev, cd->mmio);\r\npci_release_mem_regions(pci_dev);\r\npci_disable_device(pci_dev);\r\n}\r\nstatic int genwqe_probe(struct pci_dev *pci_dev,\r\nconst struct pci_device_id *id)\r\n{\r\nint err;\r\nstruct genwqe_dev *cd;\r\ngenwqe_init_crc32();\r\ncd = genwqe_dev_alloc();\r\nif (IS_ERR(cd)) {\r\ndev_err(&pci_dev->dev, "err: could not alloc mem (err=%d)!\n",\r\n(int)PTR_ERR(cd));\r\nreturn PTR_ERR(cd);\r\n}\r\ndev_set_drvdata(&pci_dev->dev, cd);\r\ncd->pci_dev = pci_dev;\r\nerr = genwqe_pci_setup(cd);\r\nif (err < 0) {\r\ndev_err(&pci_dev->dev,\r\n"err: problems with PCI setup (err=%d)\n", err);\r\ngoto out_free_dev;\r\n}\r\nerr = genwqe_start(cd);\r\nif (err < 0) {\r\ndev_err(&pci_dev->dev,\r\n"err: cannot start card services! (err=%d)\n", err);\r\ngoto out_pci_remove;\r\n}\r\nif (genwqe_is_privileged(cd)) {\r\nerr = genwqe_health_check_start(cd);\r\nif (err < 0) {\r\ndev_err(&pci_dev->dev,\r\n"err: cannot start health checking! (err=%d)\n",\r\nerr);\r\ngoto out_stop_services;\r\n}\r\n}\r\nreturn 0;\r\nout_stop_services:\r\ngenwqe_stop(cd);\r\nout_pci_remove:\r\ngenwqe_pci_remove(cd);\r\nout_free_dev:\r\ngenwqe_dev_free(cd);\r\nreturn err;\r\n}\r\nstatic void genwqe_remove(struct pci_dev *pci_dev)\r\n{\r\nstruct genwqe_dev *cd = dev_get_drvdata(&pci_dev->dev);\r\ngenwqe_health_check_stop(cd);\r\ngenwqe_stop(cd);\r\ngenwqe_pci_remove(cd);\r\ngenwqe_dev_free(cd);\r\n}\r\nstatic pci_ers_result_t genwqe_err_error_detected(struct pci_dev *pci_dev,\r\nenum pci_channel_state state)\r\n{\r\nstruct genwqe_dev *cd;\r\ndev_err(&pci_dev->dev, "[%s] state=%d\n", __func__, state);\r\ncd = dev_get_drvdata(&pci_dev->dev);\r\nif (cd == NULL)\r\nreturn PCI_ERS_RESULT_DISCONNECT;\r\ngenwqe_health_check_stop(cd);\r\ngenwqe_stop(cd);\r\nif (state == pci_channel_io_perm_failure) {\r\nreturn PCI_ERS_RESULT_DISCONNECT;\r\n} else {\r\ngenwqe_pci_remove(cd);\r\nreturn PCI_ERS_RESULT_NEED_RESET;\r\n}\r\n}\r\nstatic pci_ers_result_t genwqe_err_slot_reset(struct pci_dev *pci_dev)\r\n{\r\nint rc;\r\nstruct genwqe_dev *cd = dev_get_drvdata(&pci_dev->dev);\r\nrc = genwqe_pci_setup(cd);\r\nif (!rc) {\r\nreturn PCI_ERS_RESULT_RECOVERED;\r\n} else {\r\ndev_err(&pci_dev->dev,\r\n"err: problems with PCI setup (err=%d)\n", rc);\r\nreturn PCI_ERS_RESULT_DISCONNECT;\r\n}\r\n}\r\nstatic pci_ers_result_t genwqe_err_result_none(struct pci_dev *dev)\r\n{\r\nreturn PCI_ERS_RESULT_NONE;\r\n}\r\nstatic void genwqe_err_resume(struct pci_dev *pci_dev)\r\n{\r\nint rc;\r\nstruct genwqe_dev *cd = dev_get_drvdata(&pci_dev->dev);\r\nrc = genwqe_start(cd);\r\nif (!rc) {\r\nrc = genwqe_health_check_start(cd);\r\nif (rc)\r\ndev_err(&pci_dev->dev,\r\n"err: cannot start health checking! (err=%d)\n",\r\nrc);\r\n} else {\r\ndev_err(&pci_dev->dev,\r\n"err: cannot start card services! (err=%d)\n", rc);\r\n}\r\n}\r\nstatic int genwqe_sriov_configure(struct pci_dev *dev, int numvfs)\r\n{\r\nint rc;\r\nstruct genwqe_dev *cd = dev_get_drvdata(&dev->dev);\r\nif (numvfs > 0) {\r\ngenwqe_setup_vf_jtimer(cd);\r\nrc = pci_enable_sriov(dev, numvfs);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn numvfs;\r\n}\r\nif (numvfs == 0) {\r\npci_disable_sriov(dev);\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic char *genwqe_devnode(struct device *dev, umode_t *mode)\r\n{\r\nif (mode)\r\n*mode = 0666;\r\nreturn NULL;\r\n}\r\nstatic int __init genwqe_init_module(void)\r\n{\r\nint rc;\r\nclass_genwqe = class_create(THIS_MODULE, GENWQE_DEVNAME);\r\nif (IS_ERR(class_genwqe)) {\r\npr_err("[%s] create class failed\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nclass_genwqe->devnode = genwqe_devnode;\r\ndebugfs_genwqe = debugfs_create_dir(GENWQE_DEVNAME, NULL);\r\nif (!debugfs_genwqe) {\r\nrc = -ENOMEM;\r\ngoto err_out;\r\n}\r\nrc = pci_register_driver(&genwqe_driver);\r\nif (rc != 0) {\r\npr_err("[%s] pci_reg_driver (rc=%d)\n", __func__, rc);\r\ngoto err_out0;\r\n}\r\nreturn rc;\r\nerr_out0:\r\ndebugfs_remove(debugfs_genwqe);\r\nerr_out:\r\nclass_destroy(class_genwqe);\r\nreturn rc;\r\n}\r\nstatic void __exit genwqe_exit_module(void)\r\n{\r\npci_unregister_driver(&genwqe_driver);\r\ndebugfs_remove(debugfs_genwqe);\r\nclass_destroy(class_genwqe);\r\n}
