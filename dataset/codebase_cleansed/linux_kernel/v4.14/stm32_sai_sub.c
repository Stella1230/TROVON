static bool stm32_sai_sub_readable_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase STM_SAI_CR1_REGX:\r\ncase STM_SAI_CR2_REGX:\r\ncase STM_SAI_FRCR_REGX:\r\ncase STM_SAI_SLOTR_REGX:\r\ncase STM_SAI_IMR_REGX:\r\ncase STM_SAI_SR_REGX:\r\ncase STM_SAI_CLRFR_REGX:\r\ncase STM_SAI_DR_REGX:\r\ncase STM_SAI_PDMCR_REGX:\r\ncase STM_SAI_PDMLY_REGX:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool stm32_sai_sub_volatile_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase STM_SAI_DR_REGX:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool stm32_sai_sub_writeable_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase STM_SAI_CR1_REGX:\r\ncase STM_SAI_CR2_REGX:\r\ncase STM_SAI_FRCR_REGX:\r\ncase STM_SAI_SLOTR_REGX:\r\ncase STM_SAI_IMR_REGX:\r\ncase STM_SAI_SR_REGX:\r\ncase STM_SAI_CLRFR_REGX:\r\ncase STM_SAI_DR_REGX:\r\ncase STM_SAI_PDMCR_REGX:\r\ncase STM_SAI_PDMLY_REGX:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic irqreturn_t stm32_sai_isr(int irq, void *devid)\r\n{\r\nstruct stm32_sai_sub_data *sai = (struct stm32_sai_sub_data *)devid;\r\nstruct snd_pcm_substream *substream = sai->substream;\r\nstruct platform_device *pdev = sai->pdev;\r\nunsigned int sr, imr, flags;\r\nsnd_pcm_state_t status = SNDRV_PCM_STATE_RUNNING;\r\nregmap_read(sai->regmap, STM_SAI_IMR_REGX, &imr);\r\nregmap_read(sai->regmap, STM_SAI_SR_REGX, &sr);\r\nflags = sr & imr;\r\nif (!flags)\r\nreturn IRQ_NONE;\r\nregmap_update_bits(sai->regmap, STM_SAI_CLRFR_REGX, SAI_XCLRFR_MASK,\r\nSAI_XCLRFR_MASK);\r\nif (flags & SAI_XIMR_OVRUDRIE) {\r\ndev_err(&pdev->dev, "IRQ %s\n",\r\nSTM_SAI_IS_PLAYBACK(sai) ? "underrun" : "overrun");\r\nstatus = SNDRV_PCM_STATE_XRUN;\r\n}\r\nif (flags & SAI_XIMR_MUTEDETIE)\r\ndev_dbg(&pdev->dev, "IRQ mute detected\n");\r\nif (flags & SAI_XIMR_WCKCFGIE) {\r\ndev_err(&pdev->dev, "IRQ wrong clock configuration\n");\r\nstatus = SNDRV_PCM_STATE_DISCONNECTED;\r\n}\r\nif (flags & SAI_XIMR_CNRDYIE)\r\ndev_err(&pdev->dev, "IRQ Codec not ready\n");\r\nif (flags & SAI_XIMR_AFSDETIE) {\r\ndev_err(&pdev->dev, "IRQ Anticipated frame synchro\n");\r\nstatus = SNDRV_PCM_STATE_XRUN;\r\n}\r\nif (flags & SAI_XIMR_LFSDETIE) {\r\ndev_err(&pdev->dev, "IRQ Late frame synchro\n");\r\nstatus = SNDRV_PCM_STATE_XRUN;\r\n}\r\nif (status != SNDRV_PCM_STATE_RUNNING) {\r\nsnd_pcm_stream_lock(substream);\r\nsnd_pcm_stop(substream, SNDRV_PCM_STATE_XRUN);\r\nsnd_pcm_stream_unlock(substream);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int stm32_sai_set_sysclk(struct snd_soc_dai *cpu_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct stm32_sai_sub_data *sai = snd_soc_dai_get_drvdata(cpu_dai);\r\nint ret;\r\nif ((dir == SND_SOC_CLOCK_OUT) && sai->master) {\r\nret = regmap_update_bits(sai->regmap, STM_SAI_CR1_REGX,\r\nSAI_XCR1_NODIV,\r\n(unsigned int)~SAI_XCR1_NODIV);\r\nif (ret < 0)\r\nreturn ret;\r\nsai->mclk_rate = freq;\r\ndev_dbg(cpu_dai->dev, "SAI MCLK frequency is %uHz\n", freq);\r\n}\r\nreturn 0;\r\n}\r\nstatic int stm32_sai_set_dai_tdm_slot(struct snd_soc_dai *cpu_dai, u32 tx_mask,\r\nu32 rx_mask, int slots, int slot_width)\r\n{\r\nstruct stm32_sai_sub_data *sai = snd_soc_dai_get_drvdata(cpu_dai);\r\nint slotr, slotr_mask, slot_size;\r\ndev_dbg(cpu_dai->dev, "Masks tx/rx:%#x/%#x, slots:%d, width:%d\n",\r\ntx_mask, rx_mask, slots, slot_width);\r\nswitch (slot_width) {\r\ncase 16:\r\nslot_size = SAI_SLOT_SIZE_16;\r\nbreak;\r\ncase 32:\r\nslot_size = SAI_SLOT_SIZE_32;\r\nbreak;\r\ndefault:\r\nslot_size = SAI_SLOT_SIZE_AUTO;\r\nbreak;\r\n}\r\nslotr = SAI_XSLOTR_SLOTSZ_SET(slot_size) |\r\nSAI_XSLOTR_NBSLOT_SET(slots - 1);\r\nslotr_mask = SAI_XSLOTR_SLOTSZ_MASK | SAI_XSLOTR_NBSLOT_MASK;\r\nif (STM_SAI_IS_PLAYBACK(sai)) {\r\nsai->slot_mask = tx_mask;\r\nslotr |= SAI_XSLOTR_SLOTEN_SET(tx_mask);\r\n}\r\nif (STM_SAI_IS_CAPTURE(sai)) {\r\nsai->slot_mask = rx_mask;\r\nslotr |= SAI_XSLOTR_SLOTEN_SET(rx_mask);\r\n}\r\nslotr_mask |= SAI_XSLOTR_SLOTEN_MASK;\r\nregmap_update_bits(sai->regmap, STM_SAI_SLOTR_REGX, slotr_mask, slotr);\r\nsai->slot_width = slot_width;\r\nsai->slots = slots;\r\nreturn 0;\r\n}\r\nstatic int stm32_sai_set_dai_fmt(struct snd_soc_dai *cpu_dai, unsigned int fmt)\r\n{\r\nstruct stm32_sai_sub_data *sai = snd_soc_dai_get_drvdata(cpu_dai);\r\nint cr1 = 0, frcr = 0;\r\nint cr1_mask = 0, frcr_mask = 0;\r\nint ret;\r\ndev_dbg(cpu_dai->dev, "fmt %x\n", fmt);\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\ncr1 |= SAI_XCR1_CKSTR;\r\nfrcr |= SAI_XFRCR_FSOFF | SAI_XFRCR_FSDEF;\r\nbreak;\r\ncase SND_SOC_DAIFMT_MSB:\r\nfrcr |= SAI_XFRCR_FSPOL | SAI_XFRCR_FSDEF;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LSB:\r\nfrcr |= SAI_XFRCR_FSPOL | SAI_XFRCR_FSDEF;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\nfrcr |= SAI_XFRCR_FSPOL | SAI_XFRCR_FSOFF;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nfrcr |= SAI_XFRCR_FSPOL;\r\nbreak;\r\ndefault:\r\ndev_err(cpu_dai->dev, "Unsupported protocol %#x\n",\r\nfmt & SND_SOC_DAIFMT_FORMAT_MASK);\r\nreturn -EINVAL;\r\n}\r\ncr1_mask |= SAI_XCR1_PRTCFG_MASK | SAI_XCR1_CKSTR;\r\nfrcr_mask |= SAI_XFRCR_FSPOL | SAI_XFRCR_FSOFF |\r\nSAI_XFRCR_FSDEF;\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\ncr1 ^= SAI_XCR1_CKSTR;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nfrcr ^= SAI_XFRCR_FSPOL;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\ncr1 ^= SAI_XCR1_CKSTR;\r\nfrcr ^= SAI_XFRCR_FSPOL;\r\nbreak;\r\ndefault:\r\ndev_err(cpu_dai->dev, "Unsupported strobing %#x\n",\r\nfmt & SND_SOC_DAIFMT_INV_MASK);\r\nreturn -EINVAL;\r\n}\r\ncr1_mask |= SAI_XCR1_CKSTR;\r\nfrcr_mask |= SAI_XFRCR_FSPOL;\r\nregmap_update_bits(sai->regmap, STM_SAI_FRCR_REGX, frcr_mask, frcr);\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\ncr1 |= SAI_XCR1_SLAVE;\r\nsai->master = false;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nsai->master = true;\r\nbreak;\r\ndefault:\r\ndev_err(cpu_dai->dev, "Unsupported mode %#x\n",\r\nfmt & SND_SOC_DAIFMT_MASTER_MASK);\r\nreturn -EINVAL;\r\n}\r\ncr1_mask |= SAI_XCR1_SLAVE;\r\ncr1 |= SAI_XCR1_NODIV;\r\ncr1_mask |= SAI_XCR1_NODIV;\r\nret = regmap_update_bits(sai->regmap, STM_SAI_CR1_REGX, cr1_mask, cr1);\r\nif (ret < 0) {\r\ndev_err(cpu_dai->dev, "Failed to update CR1 register\n");\r\nreturn ret;\r\n}\r\nsai->fmt = fmt;\r\nreturn 0;\r\n}\r\nstatic int stm32_sai_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *cpu_dai)\r\n{\r\nstruct stm32_sai_sub_data *sai = snd_soc_dai_get_drvdata(cpu_dai);\r\nint imr, cr2, ret;\r\nsai->substream = substream;\r\nret = clk_prepare_enable(sai->sai_ck);\r\nif (ret < 0) {\r\ndev_err(cpu_dai->dev, "Failed to enable clock: %d\n", ret);\r\nreturn ret;\r\n}\r\nregmap_update_bits(sai->regmap, STM_SAI_SR_REGX,\r\nSAI_XSR_MASK, (unsigned int)~SAI_XSR_MASK);\r\nregmap_update_bits(sai->regmap, STM_SAI_CLRFR_REGX,\r\nSAI_XCLRFR_MASK, SAI_XCLRFR_MASK);\r\nimr = SAI_XIMR_OVRUDRIE;\r\nif (STM_SAI_IS_CAPTURE(sai)) {\r\nregmap_read(sai->regmap, STM_SAI_CR2_REGX, &cr2);\r\nif (cr2 & SAI_XCR2_MUTECNT_MASK)\r\nimr |= SAI_XIMR_MUTEDETIE;\r\n}\r\nif (sai->master)\r\nimr |= SAI_XIMR_WCKCFGIE;\r\nelse\r\nimr |= SAI_XIMR_AFSDETIE | SAI_XIMR_LFSDETIE;\r\nregmap_update_bits(sai->regmap, STM_SAI_IMR_REGX,\r\nSAI_XIMR_MASK, imr);\r\nreturn 0;\r\n}\r\nstatic int stm32_sai_set_config(struct snd_soc_dai *cpu_dai,\r\nstruct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct stm32_sai_sub_data *sai = snd_soc_dai_get_drvdata(cpu_dai);\r\nint cr1, cr1_mask, ret;\r\nint fth = STM_SAI_FIFO_TH_HALF;\r\nregmap_update_bits(sai->regmap, STM_SAI_CR2_REGX,\r\nSAI_XCR2_FFLUSH | SAI_XCR2_FTH_MASK,\r\nSAI_XCR2_FFLUSH | SAI_XCR2_FTH_SET(fth));\r\ncr1 = SAI_XCR1_PRTCFG_SET(SAI_FREE_PROTOCOL);\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S8:\r\ncr1 |= SAI_XCR1_DS_SET(SAI_DATASIZE_8);\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\ncr1 |= SAI_XCR1_DS_SET(SAI_DATASIZE_16);\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\ncr1 |= SAI_XCR1_DS_SET(SAI_DATASIZE_32);\r\nbreak;\r\ndefault:\r\ndev_err(cpu_dai->dev, "Data format not supported");\r\nreturn -EINVAL;\r\n}\r\ncr1_mask = SAI_XCR1_DS_MASK | SAI_XCR1_PRTCFG_MASK;\r\ncr1_mask |= SAI_XCR1_RX_TX;\r\nif (STM_SAI_IS_CAPTURE(sai))\r\ncr1 |= SAI_XCR1_RX_TX;\r\ncr1_mask |= SAI_XCR1_MONO;\r\nif ((sai->slots == 2) && (params_channels(params) == 1))\r\ncr1 |= SAI_XCR1_MONO;\r\nret = regmap_update_bits(sai->regmap, STM_SAI_CR1_REGX, cr1_mask, cr1);\r\nif (ret < 0) {\r\ndev_err(cpu_dai->dev, "Failed to update CR1 register\n");\r\nreturn ret;\r\n}\r\nsai->dma_params.maxburst = STM_SAI_FIFO_SIZE * fth / sizeof(u32);\r\nsnd_soc_dai_set_dma_data(cpu_dai, substream, (void *)&sai->dma_params);\r\nreturn 0;\r\n}\r\nstatic int stm32_sai_set_slots(struct snd_soc_dai *cpu_dai)\r\n{\r\nstruct stm32_sai_sub_data *sai = snd_soc_dai_get_drvdata(cpu_dai);\r\nint slotr, slot_sz;\r\nregmap_read(sai->regmap, STM_SAI_SLOTR_REGX, &slotr);\r\nslot_sz = slotr & SAI_XSLOTR_SLOTSZ_MASK;\r\nif (slot_sz == SAI_XSLOTR_SLOTSZ_SET(SAI_SLOT_SIZE_AUTO))\r\nsai->slot_width = sai->data_size;\r\nif (sai->slot_width < sai->data_size) {\r\ndev_err(cpu_dai->dev,\r\n"Data size %d larger than slot width\n",\r\nsai->data_size);\r\nreturn -EINVAL;\r\n}\r\nif (!sai->slots)\r\nsai->slots = 2;\r\nregmap_update_bits(sai->regmap, STM_SAI_SLOTR_REGX,\r\nSAI_XSLOTR_NBSLOT_MASK,\r\nSAI_XSLOTR_NBSLOT_SET((sai->slots - 1)));\r\nif (!(slotr & SAI_XSLOTR_SLOTEN_MASK)) {\r\nsai->slot_mask = (1 << sai->slots) - 1;\r\nregmap_update_bits(sai->regmap,\r\nSTM_SAI_SLOTR_REGX, SAI_XSLOTR_SLOTEN_MASK,\r\nSAI_XSLOTR_SLOTEN_SET(sai->slot_mask));\r\n}\r\ndev_dbg(cpu_dai->dev, "Slots %d, slot width %d\n",\r\nsai->slots, sai->slot_width);\r\nreturn 0;\r\n}\r\nstatic void stm32_sai_set_frame(struct snd_soc_dai *cpu_dai)\r\n{\r\nstruct stm32_sai_sub_data *sai = snd_soc_dai_get_drvdata(cpu_dai);\r\nint fs_active, offset, format;\r\nint frcr, frcr_mask;\r\nformat = sai->fmt & SND_SOC_DAIFMT_FORMAT_MASK;\r\nsai->fs_length = sai->slot_width * sai->slots;\r\nfs_active = sai->fs_length / 2;\r\nif ((format == SND_SOC_DAIFMT_DSP_A) ||\r\n(format == SND_SOC_DAIFMT_DSP_B))\r\nfs_active = 1;\r\nfrcr = SAI_XFRCR_FRL_SET((sai->fs_length - 1));\r\nfrcr |= SAI_XFRCR_FSALL_SET((fs_active - 1));\r\nfrcr_mask = SAI_XFRCR_FRL_MASK | SAI_XFRCR_FSALL_MASK;\r\ndev_dbg(cpu_dai->dev, "Frame length %d, frame active %d\n",\r\nsai->fs_length, fs_active);\r\nregmap_update_bits(sai->regmap, STM_SAI_FRCR_REGX, frcr_mask, frcr);\r\nif ((sai->fmt & SND_SOC_DAIFMT_FORMAT_MASK) == SND_SOC_DAIFMT_LSB) {\r\noffset = sai->slot_width - sai->data_size;\r\nregmap_update_bits(sai->regmap, STM_SAI_SLOTR_REGX,\r\nSAI_XSLOTR_FBOFF_MASK,\r\nSAI_XSLOTR_FBOFF_SET(offset));\r\n}\r\n}\r\nstatic int stm32_sai_configure_clock(struct snd_soc_dai *cpu_dai,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct stm32_sai_sub_data *sai = snd_soc_dai_get_drvdata(cpu_dai);\r\nint cr1, mask, div = 0;\r\nint sai_clk_rate, mclk_ratio, den, ret;\r\nint version = sai->pdata->conf->version;\r\nif (!sai->mclk_rate) {\r\ndev_err(cpu_dai->dev, "Mclk rate is null\n");\r\nreturn -EINVAL;\r\n}\r\nif (!(params_rate(params) % 11025))\r\nclk_set_parent(sai->sai_ck, sai->pdata->clk_x11k);\r\nelse\r\nclk_set_parent(sai->sai_ck, sai->pdata->clk_x8k);\r\nsai_clk_rate = clk_get_rate(sai->sai_ck);\r\nif (STM_SAI_IS_F4(sai->pdata)) {\r\nif (2 * sai_clk_rate >= 3 * sai->mclk_rate)\r\ndiv = DIV_ROUND_CLOSEST(sai_clk_rate,\r\n2 * sai->mclk_rate);\r\n} else {\r\nif (sai->mclk_rate) {\r\nmclk_ratio = sai->mclk_rate / params_rate(params);\r\nif (mclk_ratio != 256) {\r\nif (mclk_ratio == 512) {\r\nmask = SAI_XCR1_OSR;\r\ncr1 = SAI_XCR1_OSR;\r\n} else {\r\ndev_err(cpu_dai->dev,\r\n"Wrong mclk ratio %d\n",\r\nmclk_ratio);\r\nreturn -EINVAL;\r\n}\r\n}\r\ndiv = DIV_ROUND_CLOSEST(sai_clk_rate, sai->mclk_rate);\r\n} else {\r\nden = sai->fs_length * params_rate(params);\r\ndiv = DIV_ROUND_CLOSEST(sai_clk_rate, den);\r\n}\r\n}\r\nif (div > SAI_XCR1_MCKDIV_MAX(version)) {\r\ndev_err(cpu_dai->dev, "Divider %d out of range\n", div);\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(cpu_dai->dev, "SAI clock %d, divider %d\n", sai_clk_rate, div);\r\nmask = SAI_XCR1_MCKDIV_MASK(SAI_XCR1_MCKDIV_WIDTH(version));\r\ncr1 = SAI_XCR1_MCKDIV_SET(div);\r\nret = regmap_update_bits(sai->regmap, STM_SAI_CR1_REGX, mask, cr1);\r\nif (ret < 0) {\r\ndev_err(cpu_dai->dev, "Failed to update CR1 register\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int stm32_sai_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *cpu_dai)\r\n{\r\nstruct stm32_sai_sub_data *sai = snd_soc_dai_get_drvdata(cpu_dai);\r\nint ret;\r\nsai->data_size = params_width(params);\r\nret = stm32_sai_set_slots(cpu_dai);\r\nif (ret < 0)\r\nreturn ret;\r\nstm32_sai_set_frame(cpu_dai);\r\nret = stm32_sai_set_config(cpu_dai, substream, params);\r\nif (ret)\r\nreturn ret;\r\nif (sai->master)\r\nret = stm32_sai_configure_clock(cpu_dai, params);\r\nreturn ret;\r\n}\r\nstatic int stm32_sai_trigger(struct snd_pcm_substream *substream, int cmd,\r\nstruct snd_soc_dai *cpu_dai)\r\n{\r\nstruct stm32_sai_sub_data *sai = snd_soc_dai_get_drvdata(cpu_dai);\r\nint ret;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\ndev_dbg(cpu_dai->dev, "Enable DMA and SAI\n");\r\nregmap_update_bits(sai->regmap, STM_SAI_CR1_REGX,\r\nSAI_XCR1_DMAEN, SAI_XCR1_DMAEN);\r\nret = regmap_update_bits(sai->regmap, STM_SAI_CR1_REGX,\r\nSAI_XCR1_SAIEN, SAI_XCR1_SAIEN);\r\nif (ret < 0)\r\ndev_err(cpu_dai->dev, "Failed to update CR1 register\n");\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ndev_dbg(cpu_dai->dev, "Disable DMA and SAI\n");\r\nregmap_update_bits(sai->regmap, STM_SAI_CR1_REGX,\r\nSAI_XCR1_SAIEN,\r\n(unsigned int)~SAI_XCR1_SAIEN);\r\nret = regmap_update_bits(sai->regmap, STM_SAI_CR1_REGX,\r\nSAI_XCR1_DMAEN,\r\n(unsigned int)~SAI_XCR1_DMAEN);\r\nif (ret < 0)\r\ndev_err(cpu_dai->dev, "Failed to update CR1 register\n");\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic void stm32_sai_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *cpu_dai)\r\n{\r\nstruct stm32_sai_sub_data *sai = snd_soc_dai_get_drvdata(cpu_dai);\r\nregmap_update_bits(sai->regmap, STM_SAI_IMR_REGX, SAI_XIMR_MASK, 0);\r\nregmap_update_bits(sai->regmap, STM_SAI_CR1_REGX, SAI_XCR1_NODIV,\r\nSAI_XCR1_NODIV);\r\nclk_disable_unprepare(sai->sai_ck);\r\nsai->substream = NULL;\r\n}\r\nstatic int stm32_sai_dai_probe(struct snd_soc_dai *cpu_dai)\r\n{\r\nstruct stm32_sai_sub_data *sai = dev_get_drvdata(cpu_dai->dev);\r\nsai->dma_params.addr = (dma_addr_t)(sai->phys_addr + STM_SAI_DR_REGX);\r\nsai->dma_params.maxburst = 1;\r\nsai->dma_params.addr_width = DMA_SLAVE_BUSWIDTH_UNDEFINED;\r\nif (STM_SAI_IS_PLAYBACK(sai))\r\nsnd_soc_dai_init_dma_data(cpu_dai, &sai->dma_params, NULL);\r\nelse\r\nsnd_soc_dai_init_dma_data(cpu_dai, NULL, &sai->dma_params);\r\nreturn 0;\r\n}\r\nstatic int stm32_sai_sub_parse_of(struct platform_device *pdev,\r\nstruct stm32_sai_sub_data *sai)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct resource *res;\r\nvoid __iomem *base;\r\nif (!np)\r\nreturn -ENODEV;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\nsai->phys_addr = res->start;\r\nsai->regmap_config = &stm32_sai_sub_regmap_config_f4;\r\nif (STM_SAI_IS_H7(sai->pdata) && STM_SAI_IS_SUB_A(sai))\r\nsai->regmap_config = &stm32_sai_sub_regmap_config_h7;\r\nsai->regmap = devm_regmap_init_mmio_clk(&pdev->dev, "sai_ck",\r\nbase, sai->regmap_config);\r\nif (IS_ERR(sai->regmap)) {\r\ndev_err(&pdev->dev, "Failed to initialize MMIO\n");\r\nreturn PTR_ERR(sai->regmap);\r\n}\r\nif (of_property_match_string(np, "dma-names", "tx") >= 0) {\r\nsai->dir = SNDRV_PCM_STREAM_PLAYBACK;\r\n} else if (of_property_match_string(np, "dma-names", "rx") >= 0) {\r\nsai->dir = SNDRV_PCM_STREAM_CAPTURE;\r\n} else {\r\ndev_err(&pdev->dev, "Unsupported direction\n");\r\nreturn -EINVAL;\r\n}\r\nsai->sai_ck = devm_clk_get(&pdev->dev, "sai_ck");\r\nif (IS_ERR(sai->sai_ck)) {\r\ndev_err(&pdev->dev, "Missing kernel clock sai_ck\n");\r\nreturn PTR_ERR(sai->sai_ck);\r\n}\r\nreturn 0;\r\n}\r\nstatic int stm32_sai_sub_dais_init(struct platform_device *pdev,\r\nstruct stm32_sai_sub_data *sai)\r\n{\r\nsai->cpu_dai_drv = devm_kzalloc(&pdev->dev,\r\nsizeof(struct snd_soc_dai_driver),\r\nGFP_KERNEL);\r\nif (!sai->cpu_dai_drv)\r\nreturn -ENOMEM;\r\nsai->cpu_dai_drv->name = dev_name(&pdev->dev);\r\nif (STM_SAI_IS_PLAYBACK(sai)) {\r\nmemcpy(sai->cpu_dai_drv, &stm32_sai_playback_dai,\r\nsizeof(stm32_sai_playback_dai));\r\nsai->cpu_dai_drv->playback.stream_name = sai->cpu_dai_drv->name;\r\n} else {\r\nmemcpy(sai->cpu_dai_drv, &stm32_sai_capture_dai,\r\nsizeof(stm32_sai_capture_dai));\r\nsai->cpu_dai_drv->capture.stream_name = sai->cpu_dai_drv->name;\r\n}\r\nreturn 0;\r\n}\r\nstatic int stm32_sai_sub_probe(struct platform_device *pdev)\r\n{\r\nstruct stm32_sai_sub_data *sai;\r\nconst struct of_device_id *of_id;\r\nint ret;\r\nsai = devm_kzalloc(&pdev->dev, sizeof(*sai), GFP_KERNEL);\r\nif (!sai)\r\nreturn -ENOMEM;\r\nof_id = of_match_device(stm32_sai_sub_ids, &pdev->dev);\r\nif (!of_id)\r\nreturn -EINVAL;\r\nsai->id = (uintptr_t)of_id->data;\r\nsai->pdev = pdev;\r\nplatform_set_drvdata(pdev, sai);\r\nsai->pdata = dev_get_drvdata(pdev->dev.parent);\r\nif (!sai->pdata) {\r\ndev_err(&pdev->dev, "Parent device data not available\n");\r\nreturn -EINVAL;\r\n}\r\nret = stm32_sai_sub_parse_of(pdev, sai);\r\nif (ret)\r\nreturn ret;\r\nret = stm32_sai_sub_dais_init(pdev, sai);\r\nif (ret)\r\nreturn ret;\r\nret = devm_request_irq(&pdev->dev, sai->pdata->irq, stm32_sai_isr,\r\nIRQF_SHARED, dev_name(&pdev->dev), sai);\r\nif (ret) {\r\ndev_err(&pdev->dev, "IRQ request returned %d\n", ret);\r\nreturn ret;\r\n}\r\nret = devm_snd_soc_register_component(&pdev->dev, &stm32_component,\r\nsai->cpu_dai_drv, 1);\r\nif (ret)\r\nreturn ret;\r\nret = devm_snd_dmaengine_pcm_register(&pdev->dev,\r\n&stm32_sai_pcm_config, 0);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Could not register pcm dma\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
