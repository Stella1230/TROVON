int hgsmi_report_flags_location(struct gen_pool *ctx, u32 location)\r\n{\r\nstruct hgsmi_buffer_location *p;\r\np = hgsmi_buffer_alloc(ctx, sizeof(*p), HGSMI_CH_HGSMI,\r\nHGSMI_CC_HOST_FLAGS_LOCATION);\r\nif (!p)\r\nreturn -ENOMEM;\r\np->buf_location = location;\r\np->buf_len = sizeof(struct hgsmi_host_flags);\r\nhgsmi_buffer_submit(ctx, p);\r\nhgsmi_buffer_free(ctx, p);\r\nreturn 0;\r\n}\r\nint hgsmi_send_caps_info(struct gen_pool *ctx, u32 caps)\r\n{\r\nstruct vbva_caps *p;\r\np = hgsmi_buffer_alloc(ctx, sizeof(*p), HGSMI_CH_VBVA, VBVA_INFO_CAPS);\r\nif (!p)\r\nreturn -ENOMEM;\r\np->rc = VERR_NOT_IMPLEMENTED;\r\np->caps = caps;\r\nhgsmi_buffer_submit(ctx, p);\r\nWARN_ON_ONCE(RT_FAILURE(p->rc));\r\nhgsmi_buffer_free(ctx, p);\r\nreturn 0;\r\n}\r\nint hgsmi_test_query_conf(struct gen_pool *ctx)\r\n{\r\nu32 value = 0;\r\nint ret;\r\nret = hgsmi_query_conf(ctx, U32_MAX, &value);\r\nif (ret)\r\nreturn ret;\r\nreturn value == U32_MAX ? 0 : -EIO;\r\n}\r\nint hgsmi_query_conf(struct gen_pool *ctx, u32 index, u32 *value_ret)\r\n{\r\nstruct vbva_conf32 *p;\r\np = hgsmi_buffer_alloc(ctx, sizeof(*p), HGSMI_CH_VBVA,\r\nVBVA_QUERY_CONF32);\r\nif (!p)\r\nreturn -ENOMEM;\r\np->index = index;\r\np->value = U32_MAX;\r\nhgsmi_buffer_submit(ctx, p);\r\n*value_ret = p->value;\r\nhgsmi_buffer_free(ctx, p);\r\nreturn 0;\r\n}\r\nint hgsmi_update_pointer_shape(struct gen_pool *ctx, u32 flags,\r\nu32 hot_x, u32 hot_y, u32 width, u32 height,\r\nu8 *pixels, u32 len)\r\n{\r\nstruct vbva_mouse_pointer_shape *p;\r\nu32 pixel_len = 0;\r\nint rc;\r\nif (flags & VBOX_MOUSE_POINTER_SHAPE) {\r\npixel_len = ((((width + 7) / 8) * height + 3) & ~3) +\r\nwidth * 4 * height;\r\nif (pixel_len > len)\r\nreturn -EINVAL;\r\nflags |= VBOX_MOUSE_POINTER_VISIBLE;\r\n}\r\np = hgsmi_buffer_alloc(ctx, sizeof(*p) + pixel_len, HGSMI_CH_VBVA,\r\nVBVA_MOUSE_POINTER_SHAPE);\r\nif (!p)\r\nreturn -ENOMEM;\r\np->result = VINF_SUCCESS;\r\np->flags = flags;\r\np->hot_X = hot_x;\r\np->hot_y = hot_y;\r\np->width = width;\r\np->height = height;\r\nif (pixel_len)\r\nmemcpy(p->data, pixels, pixel_len);\r\nhgsmi_buffer_submit(ctx, p);\r\nswitch (p->result) {\r\ncase VINF_SUCCESS:\r\nrc = 0;\r\nbreak;\r\ncase VERR_NO_MEMORY:\r\nrc = -ENOMEM;\r\nbreak;\r\ncase VERR_NOT_SUPPORTED:\r\nrc = -EBUSY;\r\nbreak;\r\ndefault:\r\nrc = -EINVAL;\r\n}\r\nhgsmi_buffer_free(ctx, p);\r\nreturn rc;\r\n}\r\nint hgsmi_cursor_position(struct gen_pool *ctx, bool report_position,\r\nu32 x, u32 y, u32 *x_host, u32 *y_host)\r\n{\r\nstruct vbva_cursor_position *p;\r\np = hgsmi_buffer_alloc(ctx, sizeof(*p), HGSMI_CH_VBVA,\r\nVBVA_CURSOR_POSITION);\r\nif (!p)\r\nreturn -ENOMEM;\r\np->report_position = report_position;\r\np->x = x;\r\np->y = y;\r\nhgsmi_buffer_submit(ctx, p);\r\n*x_host = p->x;\r\n*y_host = p->y;\r\nhgsmi_buffer_free(ctx, p);\r\nreturn 0;\r\n}
