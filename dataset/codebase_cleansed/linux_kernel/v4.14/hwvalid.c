static acpi_status\r\nacpi_hw_validate_io_request(acpi_io_address address, u32 bit_width)\r\n{\r\nu32 i;\r\nu32 byte_width;\r\nacpi_io_address last_address;\r\nconst struct acpi_port_info *port_info;\r\nACPI_FUNCTION_NAME(hw_validate_io_request);\r\nif ((bit_width != 8) && (bit_width != 16) && (bit_width != 32)) {\r\nACPI_ERROR((AE_INFO,\r\n"Bad BitWidth parameter: %8.8X", bit_width));\r\nreturn (AE_BAD_PARAMETER);\r\n}\r\nport_info = acpi_protected_ports;\r\nbyte_width = ACPI_DIV_8(bit_width);\r\nlast_address = address + byte_width - 1;\r\nACPI_DEBUG_PRINT((ACPI_DB_IO,\r\n"Address %8.8X%8.8X LastAddress %8.8X%8.8X Length %X",\r\nACPI_FORMAT_UINT64(address),\r\nACPI_FORMAT_UINT64(last_address), byte_width));\r\nif (last_address > ACPI_UINT16_MAX) {\r\nACPI_ERROR((AE_INFO,\r\n"Illegal I/O port address/length above 64K: %8.8X%8.8X/0x%X",\r\nACPI_FORMAT_UINT64(address), byte_width));\r\nreturn (AE_LIMIT);\r\n}\r\nif (address > acpi_protected_ports[ACPI_PORT_INFO_ENTRIES - 1].end) {\r\nreturn (AE_OK);\r\n}\r\nfor (i = 0; i < ACPI_PORT_INFO_ENTRIES; i++, port_info++) {\r\nif ((address <= port_info->end)\r\n&& (last_address >= port_info->start)) {\r\nif (acpi_gbl_osi_data >= port_info->osi_dependency) {\r\nACPI_DEBUG_PRINT((ACPI_DB_IO,\r\n"Denied AML access to port 0x%8.8X%8.8X/%X (%s 0x%.4X-0x%.4X)",\r\nACPI_FORMAT_UINT64(address),\r\nbyte_width, port_info->name,\r\nport_info->start,\r\nport_info->end));\r\nreturn_ACPI_STATUS(AE_AML_ILLEGAL_ADDRESS);\r\n}\r\n}\r\nif (last_address <= port_info->end) {\r\nbreak;\r\n}\r\n}\r\nreturn (AE_OK);\r\n}\r\nacpi_status acpi_hw_read_port(acpi_io_address address, u32 *value, u32 width)\r\n{\r\nacpi_status status;\r\nu32 one_byte;\r\nu32 i;\r\nif (acpi_gbl_truncate_io_addresses) {\r\naddress &= ACPI_UINT16_MAX;\r\n}\r\nstatus = acpi_hw_validate_io_request(address, width);\r\nif (ACPI_SUCCESS(status)) {\r\nstatus = acpi_os_read_port(address, value, width);\r\nreturn (status);\r\n}\r\nif (status != AE_AML_ILLEGAL_ADDRESS) {\r\nreturn (status);\r\n}\r\nfor (i = 0, *value = 0; i < width; i += 8) {\r\nif (acpi_hw_validate_io_request(address, 8) == AE_OK) {\r\nstatus = acpi_os_read_port(address, &one_byte, 8);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\n*value |= (one_byte << i);\r\n}\r\naddress++;\r\n}\r\nreturn (AE_OK);\r\n}\r\nacpi_status acpi_hw_write_port(acpi_io_address address, u32 value, u32 width)\r\n{\r\nacpi_status status;\r\nu32 i;\r\nif (acpi_gbl_truncate_io_addresses) {\r\naddress &= ACPI_UINT16_MAX;\r\n}\r\nstatus = acpi_hw_validate_io_request(address, width);\r\nif (ACPI_SUCCESS(status)) {\r\nstatus = acpi_os_write_port(address, value, width);\r\nreturn (status);\r\n}\r\nif (status != AE_AML_ILLEGAL_ADDRESS) {\r\nreturn (status);\r\n}\r\nfor (i = 0; i < width; i += 8) {\r\nif (acpi_hw_validate_io_request(address, 8) == AE_OK) {\r\nstatus =\r\nacpi_os_write_port(address, (value >> i) & 0xFF, 8);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\n}\r\naddress++;\r\n}\r\nreturn (AE_OK);\r\n}
