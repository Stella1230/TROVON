static int ad7879_read(struct ad7879 *ts, u8 reg)\r\n{\r\nunsigned int val;\r\nint error;\r\nerror = regmap_read(ts->regmap, reg, &val);\r\nif (error) {\r\ndev_err(ts->dev, "failed to read register %#02x: %d\n",\r\nreg, error);\r\nreturn error;\r\n}\r\nreturn val;\r\n}\r\nstatic int ad7879_write(struct ad7879 *ts, u8 reg, u16 val)\r\n{\r\nint error;\r\nerror = regmap_write(ts->regmap, reg, val);\r\nif (error) {\r\ndev_err(ts->dev,\r\n"failed to write %#04x to register %#02x: %d\n",\r\nval, reg, error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ad7879_report(struct ad7879 *ts)\r\n{\r\nstruct input_dev *input_dev = ts->input;\r\nunsigned Rt;\r\nu16 x, y, z1, z2;\r\nx = ts->conversion_data[AD7879_SEQ_XPOS] & MAX_12BIT;\r\ny = ts->conversion_data[AD7879_SEQ_YPOS] & MAX_12BIT;\r\nz1 = ts->conversion_data[AD7879_SEQ_Z1] & MAX_12BIT;\r\nz2 = ts->conversion_data[AD7879_SEQ_Z2] & MAX_12BIT;\r\nif (ts->swap_xy)\r\nswap(x, y);\r\nif (likely(x && z1)) {\r\nRt = (z2 - z1) * x * ts->x_plate_ohms;\r\nRt /= z1;\r\nRt = (Rt + 2047) >> 12;\r\nif (Rt > input_abs_get_max(input_dev, ABS_PRESSURE))\r\nreturn -EINVAL;\r\nif (timer_pending(&ts->timer)) {\r\ninput_report_key(input_dev, BTN_TOUCH, 1);\r\ninput_report_abs(input_dev, ABS_X, ts->x);\r\ninput_report_abs(input_dev, ABS_Y, ts->y);\r\ninput_report_abs(input_dev, ABS_PRESSURE, ts->Rt);\r\ninput_sync(input_dev);\r\n}\r\nts->x = x;\r\nts->y = y;\r\nts->Rt = Rt;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void ad7879_ts_event_release(struct ad7879 *ts)\r\n{\r\nstruct input_dev *input_dev = ts->input;\r\ninput_report_abs(input_dev, ABS_PRESSURE, 0);\r\ninput_report_key(input_dev, BTN_TOUCH, 0);\r\ninput_sync(input_dev);\r\n}\r\nstatic void ad7879_timer(unsigned long handle)\r\n{\r\nstruct ad7879 *ts = (void *)handle;\r\nad7879_ts_event_release(ts);\r\n}\r\nstatic irqreturn_t ad7879_irq(int irq, void *handle)\r\n{\r\nstruct ad7879 *ts = handle;\r\nregmap_bulk_read(ts->regmap, AD7879_REG_XPLUS,\r\nts->conversion_data, AD7879_NR_SENSE);\r\nif (!ad7879_report(ts))\r\nmod_timer(&ts->timer, jiffies + TS_PEN_UP_TIMEOUT);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void __ad7879_enable(struct ad7879 *ts)\r\n{\r\nad7879_write(ts, AD7879_REG_CTRL2, ts->cmd_crtl2);\r\nad7879_write(ts, AD7879_REG_CTRL3, ts->cmd_crtl3);\r\nad7879_write(ts, AD7879_REG_CTRL1, ts->cmd_crtl1);\r\nenable_irq(ts->irq);\r\n}\r\nstatic void __ad7879_disable(struct ad7879 *ts)\r\n{\r\nu16 reg = (ts->cmd_crtl2 & ~AD7879_PM(-1)) |\r\nAD7879_PM(AD7879_PM_SHUTDOWN);\r\ndisable_irq(ts->irq);\r\nif (del_timer_sync(&ts->timer))\r\nad7879_ts_event_release(ts);\r\nad7879_write(ts, AD7879_REG_CTRL2, reg);\r\n}\r\nstatic int ad7879_open(struct input_dev *input)\r\n{\r\nstruct ad7879 *ts = input_get_drvdata(input);\r\nif (!ts->disabled && !ts->suspended)\r\n__ad7879_enable(ts);\r\nreturn 0;\r\n}\r\nstatic void ad7879_close(struct input_dev* input)\r\n{\r\nstruct ad7879 *ts = input_get_drvdata(input);\r\nif (!ts->disabled && !ts->suspended)\r\n__ad7879_disable(ts);\r\n}\r\nstatic int __maybe_unused ad7879_suspend(struct device *dev)\r\n{\r\nstruct ad7879 *ts = dev_get_drvdata(dev);\r\nmutex_lock(&ts->input->mutex);\r\nif (!ts->suspended && !ts->disabled && ts->input->users)\r\n__ad7879_disable(ts);\r\nts->suspended = true;\r\nmutex_unlock(&ts->input->mutex);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused ad7879_resume(struct device *dev)\r\n{\r\nstruct ad7879 *ts = dev_get_drvdata(dev);\r\nmutex_lock(&ts->input->mutex);\r\nif (ts->suspended && !ts->disabled && ts->input->users)\r\n__ad7879_enable(ts);\r\nts->suspended = false;\r\nmutex_unlock(&ts->input->mutex);\r\nreturn 0;\r\n}\r\nstatic void ad7879_toggle(struct ad7879 *ts, bool disable)\r\n{\r\nmutex_lock(&ts->input->mutex);\r\nif (!ts->suspended && ts->input->users != 0) {\r\nif (disable) {\r\nif (ts->disabled)\r\n__ad7879_enable(ts);\r\n} else {\r\nif (!ts->disabled)\r\n__ad7879_disable(ts);\r\n}\r\n}\r\nts->disabled = disable;\r\nmutex_unlock(&ts->input->mutex);\r\n}\r\nstatic ssize_t ad7879_disable_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ad7879 *ts = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%u\n", ts->disabled);\r\n}\r\nstatic ssize_t ad7879_disable_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ad7879 *ts = dev_get_drvdata(dev);\r\nunsigned int val;\r\nint error;\r\nerror = kstrtouint(buf, 10, &val);\r\nif (error)\r\nreturn error;\r\nad7879_toggle(ts, val);\r\nreturn count;\r\n}\r\nstatic int ad7879_gpio_direction_input(struct gpio_chip *chip,\r\nunsigned gpio)\r\n{\r\nstruct ad7879 *ts = gpiochip_get_data(chip);\r\nint err;\r\nmutex_lock(&ts->mutex);\r\nts->cmd_crtl2 |= AD7879_GPIO_EN | AD7879_GPIODIR | AD7879_GPIOPOL;\r\nerr = ad7879_write(ts, AD7879_REG_CTRL2, ts->cmd_crtl2);\r\nmutex_unlock(&ts->mutex);\r\nreturn err;\r\n}\r\nstatic int ad7879_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned gpio, int level)\r\n{\r\nstruct ad7879 *ts = gpiochip_get_data(chip);\r\nint err;\r\nmutex_lock(&ts->mutex);\r\nts->cmd_crtl2 &= ~AD7879_GPIODIR;\r\nts->cmd_crtl2 |= AD7879_GPIO_EN | AD7879_GPIOPOL;\r\nif (level)\r\nts->cmd_crtl2 |= AD7879_GPIO_DATA;\r\nelse\r\nts->cmd_crtl2 &= ~AD7879_GPIO_DATA;\r\nerr = ad7879_write(ts, AD7879_REG_CTRL2, ts->cmd_crtl2);\r\nmutex_unlock(&ts->mutex);\r\nreturn err;\r\n}\r\nstatic int ad7879_gpio_get_value(struct gpio_chip *chip, unsigned gpio)\r\n{\r\nstruct ad7879 *ts = gpiochip_get_data(chip);\r\nu16 val;\r\nmutex_lock(&ts->mutex);\r\nval = ad7879_read(ts, AD7879_REG_CTRL2);\r\nmutex_unlock(&ts->mutex);\r\nreturn !!(val & AD7879_GPIO_DATA);\r\n}\r\nstatic void ad7879_gpio_set_value(struct gpio_chip *chip,\r\nunsigned gpio, int value)\r\n{\r\nstruct ad7879 *ts = gpiochip_get_data(chip);\r\nmutex_lock(&ts->mutex);\r\nif (value)\r\nts->cmd_crtl2 |= AD7879_GPIO_DATA;\r\nelse\r\nts->cmd_crtl2 &= ~AD7879_GPIO_DATA;\r\nad7879_write(ts, AD7879_REG_CTRL2, ts->cmd_crtl2);\r\nmutex_unlock(&ts->mutex);\r\n}\r\nstatic int ad7879_gpio_add(struct ad7879 *ts,\r\nconst struct ad7879_platform_data *pdata)\r\n{\r\nbool gpio_export;\r\nint gpio_base;\r\nint ret = 0;\r\nif (pdata) {\r\ngpio_export = pdata->gpio_export;\r\ngpio_base = pdata->gpio_base;\r\n} else {\r\ngpio_export = device_property_read_bool(ts->dev,\r\n"gpio-controller");\r\ngpio_base = -1;\r\n}\r\nmutex_init(&ts->mutex);\r\nif (gpio_export) {\r\nts->gc.direction_input = ad7879_gpio_direction_input;\r\nts->gc.direction_output = ad7879_gpio_direction_output;\r\nts->gc.get = ad7879_gpio_get_value;\r\nts->gc.set = ad7879_gpio_set_value;\r\nts->gc.can_sleep = 1;\r\nts->gc.base = gpio_base;\r\nts->gc.ngpio = 1;\r\nts->gc.label = "AD7879-GPIO";\r\nts->gc.owner = THIS_MODULE;\r\nts->gc.parent = ts->dev;\r\nret = devm_gpiochip_add_data(ts->dev, &ts->gc, ts);\r\nif (ret)\r\ndev_err(ts->dev, "failed to register gpio %d\n",\r\nts->gc.base);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ad7879_gpio_add(struct ad7879 *ts,\r\nconst struct ad7879_platform_data *pdata)\r\n{\r\nreturn 0;\r\n}\r\nstatic int ad7879_parse_dt(struct device *dev, struct ad7879 *ts)\r\n{\r\nint err;\r\nu32 tmp;\r\nerr = device_property_read_u32(dev, "adi,resistance-plate-x", &tmp);\r\nif (err) {\r\ndev_err(dev, "failed to get resistance-plate-x property\n");\r\nreturn err;\r\n}\r\nts->x_plate_ohms = (u16)tmp;\r\ndevice_property_read_u8(dev, "adi,first-conversion-delay",\r\n&ts->first_conversion_delay);\r\ndevice_property_read_u8(dev, "adi,acquisition-time",\r\n&ts->acquisition_time);\r\ndevice_property_read_u8(dev, "adi,median-filter-size", &ts->median);\r\ndevice_property_read_u8(dev, "adi,averaging", &ts->averaging);\r\ndevice_property_read_u8(dev, "adi,conversion-interval",\r\n&ts->pen_down_acc_interval);\r\nts->swap_xy = device_property_read_bool(dev, "touchscreen-swapped-x-y");\r\nreturn 0;\r\n}\r\nstatic void ad7879_cleanup_sysfs(void *_ts)\r\n{\r\nstruct ad7879 *ts = _ts;\r\nsysfs_remove_group(&ts->dev->kobj, &ad7879_attr_group);\r\n}\r\nint ad7879_probe(struct device *dev, struct regmap *regmap,\r\nint irq, u16 bustype, u8 devid)\r\n{\r\nstruct ad7879_platform_data *pdata = dev_get_platdata(dev);\r\nstruct ad7879 *ts;\r\nstruct input_dev *input_dev;\r\nint err;\r\nu16 revid;\r\nif (irq <= 0) {\r\ndev_err(dev, "No IRQ specified\n");\r\nreturn -EINVAL;\r\n}\r\nts = devm_kzalloc(dev, sizeof(*ts), GFP_KERNEL);\r\nif (!ts)\r\nreturn -ENOMEM;\r\nif (pdata) {\r\nts->swap_xy = !pdata->swap_xy;\r\nts->x_plate_ohms = pdata->x_plate_ohms ? : 400;\r\nts->first_conversion_delay = pdata->first_conversion_delay;\r\nts->acquisition_time = pdata->acquisition_time;\r\nts->averaging = pdata->averaging;\r\nts->pen_down_acc_interval = pdata->pen_down_acc_interval;\r\nts->median = pdata->median;\r\n} else {\r\nerr = ad7879_parse_dt(dev, ts);\r\nif (err)\r\nreturn err;\r\n}\r\ninput_dev = devm_input_allocate_device(dev);\r\nif (!input_dev) {\r\ndev_err(dev, "Failed to allocate input device\n");\r\nreturn -ENOMEM;\r\n}\r\nts->dev = dev;\r\nts->input = input_dev;\r\nts->irq = irq;\r\nts->regmap = regmap;\r\nsetup_timer(&ts->timer, ad7879_timer, (unsigned long) ts);\r\nsnprintf(ts->phys, sizeof(ts->phys), "%s/input0", dev_name(dev));\r\ninput_dev->name = "AD7879 Touchscreen";\r\ninput_dev->phys = ts->phys;\r\ninput_dev->dev.parent = dev;\r\ninput_dev->id.bustype = bustype;\r\ninput_dev->open = ad7879_open;\r\ninput_dev->close = ad7879_close;\r\ninput_set_drvdata(input_dev, ts);\r\ninput_set_capability(input_dev, EV_KEY, BTN_TOUCH);\r\nif (pdata) {\r\ninput_set_abs_params(input_dev, ABS_X,\r\npdata->x_min ? : 0,\r\npdata->x_max ? : MAX_12BIT,\r\n0, 0);\r\ninput_set_abs_params(input_dev, ABS_Y,\r\npdata->y_min ? : 0,\r\npdata->y_max ? : MAX_12BIT,\r\n0, 0);\r\ninput_set_abs_params(input_dev, ABS_PRESSURE,\r\npdata->pressure_min,\r\npdata->pressure_max ? : ~0,\r\n0, 0);\r\n} else {\r\ninput_set_abs_params(input_dev, ABS_X, 0, MAX_12BIT, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_Y, 0, MAX_12BIT, 0, 0);\r\ninput_set_capability(input_dev, EV_ABS, ABS_PRESSURE);\r\ntouchscreen_parse_properties(input_dev, false, NULL);\r\nif (!input_abs_get_max(input_dev, ABS_PRESSURE)) {\r\ndev_err(dev, "Touchscreen pressure is not specified\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nerr = ad7879_write(ts, AD7879_REG_CTRL2, AD7879_RESET);\r\nif (err < 0) {\r\ndev_err(dev, "Failed to write %s\n", input_dev->name);\r\nreturn err;\r\n}\r\nrevid = ad7879_read(ts, AD7879_REG_REVID);\r\ninput_dev->id.product = (revid & 0xff);\r\ninput_dev->id.version = revid >> 8;\r\nif (input_dev->id.product != devid) {\r\ndev_err(dev, "Failed to probe %s (%x vs %x)\n",\r\ninput_dev->name, devid, revid);\r\nreturn -ENODEV;\r\n}\r\nts->cmd_crtl3 = AD7879_YPLUS_BIT |\r\nAD7879_XPLUS_BIT |\r\nAD7879_Z2_BIT |\r\nAD7879_Z1_BIT |\r\nAD7879_TEMPMASK_BIT |\r\nAD7879_AUXVBATMASK_BIT |\r\nAD7879_GPIOALERTMASK_BIT;\r\nts->cmd_crtl2 = AD7879_PM(AD7879_PM_DYN) | AD7879_DFR |\r\nAD7879_AVG(ts->averaging) |\r\nAD7879_MFS(ts->median) |\r\nAD7879_FCD(ts->first_conversion_delay);\r\nts->cmd_crtl1 = AD7879_MODE_INT | AD7879_MODE_SEQ1 |\r\nAD7879_ACQ(ts->acquisition_time) |\r\nAD7879_TMR(ts->pen_down_acc_interval);\r\nerr = devm_request_threaded_irq(dev, ts->irq, NULL, ad7879_irq,\r\nIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\r\ndev_name(dev), ts);\r\nif (err) {\r\ndev_err(dev, "Failed to request IRQ: %d\n", err);\r\nreturn err;\r\n}\r\n__ad7879_disable(ts);\r\nerr = sysfs_create_group(&dev->kobj, &ad7879_attr_group);\r\nif (err)\r\nreturn err;\r\nerr = devm_add_action_or_reset(dev, ad7879_cleanup_sysfs, ts);\r\nif (err)\r\nreturn err;\r\nerr = ad7879_gpio_add(ts, pdata);\r\nif (err)\r\nreturn err;\r\nerr = input_register_device(input_dev);\r\nif (err)\r\nreturn err;\r\ndev_set_drvdata(dev, ts);\r\nreturn 0;\r\n}
