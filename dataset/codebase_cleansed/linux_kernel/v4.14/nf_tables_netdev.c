static unsigned int\r\nnft_do_chain_netdev(void *priv, struct sk_buff *skb,\r\nconst struct nf_hook_state *state)\r\n{\r\nstruct nft_pktinfo pkt;\r\nswitch (skb->protocol) {\r\ncase htons(ETH_P_IP):\r\nnft_set_pktinfo_ipv4_validate(&pkt, skb, state);\r\nbreak;\r\ncase htons(ETH_P_IPV6):\r\nnft_set_pktinfo_ipv6_validate(&pkt, skb, state);\r\nbreak;\r\ndefault:\r\nnft_set_pktinfo_unspec(&pkt, skb, state);\r\nbreak;\r\n}\r\nreturn nft_do_chain(&pkt, priv);\r\n}\r\nstatic int nf_tables_netdev_init_net(struct net *net)\r\n{\r\nnet->nft.netdev = kmalloc(sizeof(struct nft_af_info), GFP_KERNEL);\r\nif (net->nft.netdev == NULL)\r\nreturn -ENOMEM;\r\nmemcpy(net->nft.netdev, &nft_af_netdev, sizeof(nft_af_netdev));\r\nif (nft_register_afinfo(net, net->nft.netdev) < 0)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nkfree(net->nft.netdev);\r\nreturn -ENOMEM;\r\n}\r\nstatic void nf_tables_netdev_exit_net(struct net *net)\r\n{\r\nnft_unregister_afinfo(net, net->nft.netdev);\r\nkfree(net->nft.netdev);\r\n}\r\nstatic void nft_netdev_event(unsigned long event, struct net_device *dev,\r\nstruct nft_ctx *ctx)\r\n{\r\nstruct nft_base_chain *basechain = nft_base_chain(ctx->chain);\r\nswitch (event) {\r\ncase NETDEV_UNREGISTER:\r\nif (strcmp(basechain->dev_name, dev->name) != 0)\r\nreturn;\r\n__nft_release_basechain(ctx);\r\nbreak;\r\ncase NETDEV_CHANGENAME:\r\nif (dev->ifindex != basechain->ops[0].dev->ifindex)\r\nreturn;\r\nstrncpy(basechain->dev_name, dev->name, IFNAMSIZ);\r\nbreak;\r\n}\r\n}\r\nstatic int nf_tables_netdev_event(struct notifier_block *this,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\r\nstruct nft_af_info *afi;\r\nstruct nft_table *table;\r\nstruct nft_chain *chain, *nr;\r\nstruct nft_ctx ctx = {\r\n.net = dev_net(dev),\r\n};\r\nif (event != NETDEV_UNREGISTER &&\r\nevent != NETDEV_CHANGENAME)\r\nreturn NOTIFY_DONE;\r\nnfnl_lock(NFNL_SUBSYS_NFTABLES);\r\nlist_for_each_entry(afi, &dev_net(dev)->nft.af_info, list) {\r\nctx.afi = afi;\r\nif (afi->family != NFPROTO_NETDEV)\r\ncontinue;\r\nlist_for_each_entry(table, &afi->tables, list) {\r\nctx.table = table;\r\nlist_for_each_entry_safe(chain, nr, &table->chains, list) {\r\nif (!nft_is_base_chain(chain))\r\ncontinue;\r\nctx.chain = chain;\r\nnft_netdev_event(event, dev, &ctx);\r\n}\r\n}\r\n}\r\nnfnl_unlock(NFNL_SUBSYS_NFTABLES);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int __init nf_tables_netdev_init(void)\r\n{\r\nint ret;\r\nret = nft_register_chain_type(&nft_filter_chain_netdev);\r\nif (ret)\r\nreturn ret;\r\nret = register_pernet_subsys(&nf_tables_netdev_net_ops);\r\nif (ret)\r\ngoto err1;\r\nret = register_netdevice_notifier(&nf_tables_netdev_notifier);\r\nif (ret)\r\ngoto err2;\r\nreturn 0;\r\nerr2:\r\nunregister_pernet_subsys(&nf_tables_netdev_net_ops);\r\nerr1:\r\nnft_unregister_chain_type(&nft_filter_chain_netdev);\r\nreturn ret;\r\n}\r\nstatic void __exit nf_tables_netdev_exit(void)\r\n{\r\nunregister_netdevice_notifier(&nf_tables_netdev_notifier);\r\nunregister_pernet_subsys(&nf_tables_netdev_net_ops);\r\nnft_unregister_chain_type(&nft_filter_chain_netdev);\r\n}
