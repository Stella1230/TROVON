static int rr_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nstruct net_device *dev;\r\nstatic int version_disp;\r\nu8 pci_latency;\r\nstruct rr_private *rrpriv;\r\nvoid *tmpptr;\r\ndma_addr_t ring_dma;\r\nint ret = -ENOMEM;\r\ndev = alloc_hippi_dev(sizeof(struct rr_private));\r\nif (!dev)\r\ngoto out3;\r\nret = pci_enable_device(pdev);\r\nif (ret) {\r\nret = -ENODEV;\r\ngoto out2;\r\n}\r\nrrpriv = netdev_priv(dev);\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\nret = pci_request_regions(pdev, "rrunner");\r\nif (ret < 0)\r\ngoto out;\r\npci_set_drvdata(pdev, dev);\r\nrrpriv->pci_dev = pdev;\r\nspin_lock_init(&rrpriv->lock);\r\ndev->netdev_ops = &rr_netdev_ops;\r\nif (!version_disp) {\r\nversion_disp = 1;\r\nprintk(version);\r\n}\r\npci_read_config_byte(pdev, PCI_LATENCY_TIMER, &pci_latency);\r\nif (pci_latency <= 0x58){\r\npci_latency = 0x58;\r\npci_write_config_byte(pdev, PCI_LATENCY_TIMER, pci_latency);\r\n}\r\npci_set_master(pdev);\r\nprintk(KERN_INFO "%s: Essential RoadRunner serial HIPPI "\r\n"at 0x%llx, irq %i, PCI latency %i\n", dev->name,\r\n(unsigned long long)pci_resource_start(pdev, 0),\r\npdev->irq, pci_latency);\r\nrrpriv->regs = pci_iomap(pdev, 0, 0x1000);\r\nif (!rrpriv->regs) {\r\nprintk(KERN_ERR "%s: Unable to map I/O register, "\r\n"RoadRunner will be disabled.\n", dev->name);\r\nret = -EIO;\r\ngoto out;\r\n}\r\ntmpptr = pci_alloc_consistent(pdev, TX_TOTAL_SIZE, &ring_dma);\r\nrrpriv->tx_ring = tmpptr;\r\nrrpriv->tx_ring_dma = ring_dma;\r\nif (!tmpptr) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\ntmpptr = pci_alloc_consistent(pdev, RX_TOTAL_SIZE, &ring_dma);\r\nrrpriv->rx_ring = tmpptr;\r\nrrpriv->rx_ring_dma = ring_dma;\r\nif (!tmpptr) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\ntmpptr = pci_alloc_consistent(pdev, EVT_RING_SIZE, &ring_dma);\r\nrrpriv->evt_ring = tmpptr;\r\nrrpriv->evt_ring_dma = ring_dma;\r\nif (!tmpptr) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\n#ifdef __BIG_ENDIAN\r\nwritel(readl(&rrpriv->regs->HostCtrl) | NO_SWAP,\r\n&rrpriv->regs->HostCtrl);\r\n#endif\r\nrr_init(dev);\r\nret = register_netdev(dev);\r\nif (ret)\r\ngoto out;\r\nreturn 0;\r\nout:\r\nif (rrpriv->evt_ring)\r\npci_free_consistent(pdev, EVT_RING_SIZE, rrpriv->evt_ring,\r\nrrpriv->evt_ring_dma);\r\nif (rrpriv->rx_ring)\r\npci_free_consistent(pdev, RX_TOTAL_SIZE, rrpriv->rx_ring,\r\nrrpriv->rx_ring_dma);\r\nif (rrpriv->tx_ring)\r\npci_free_consistent(pdev, TX_TOTAL_SIZE, rrpriv->tx_ring,\r\nrrpriv->tx_ring_dma);\r\nif (rrpriv->regs)\r\npci_iounmap(pdev, rrpriv->regs);\r\nif (pdev)\r\npci_release_regions(pdev);\r\nout2:\r\nfree_netdev(dev);\r\nout3:\r\nreturn ret;\r\n}\r\nstatic void rr_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct rr_private *rr = netdev_priv(dev);\r\nif (!(readl(&rr->regs->HostCtrl) & NIC_HALTED)) {\r\nprintk(KERN_ERR "%s: trying to unload running NIC\n",\r\ndev->name);\r\nwritel(HALT_NIC, &rr->regs->HostCtrl);\r\n}\r\nunregister_netdev(dev);\r\npci_free_consistent(pdev, EVT_RING_SIZE, rr->evt_ring,\r\nrr->evt_ring_dma);\r\npci_free_consistent(pdev, RX_TOTAL_SIZE, rr->rx_ring,\r\nrr->rx_ring_dma);\r\npci_free_consistent(pdev, TX_TOTAL_SIZE, rr->tx_ring,\r\nrr->tx_ring_dma);\r\npci_iounmap(pdev, rr->regs);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\nfree_netdev(dev);\r\n}\r\nstatic void rr_issue_cmd(struct rr_private *rrpriv, struct cmd *cmd)\r\n{\r\nstruct rr_regs __iomem *regs;\r\nu32 idx;\r\nregs = rrpriv->regs;\r\nif (readl(&regs->HostCtrl) & NIC_HALTED){\r\nprintk("issuing command for halted NIC, code 0x%x, "\r\n"HostCtrl %08x\n", cmd->code, readl(&regs->HostCtrl));\r\nif (readl(&regs->Mode) & FATAL_ERR)\r\nprintk("error codes Fail1 %02x, Fail2 %02x\n",\r\nreadl(&regs->Fail1), readl(&regs->Fail2));\r\n}\r\nidx = rrpriv->info->cmd_ctrl.pi;\r\nwritel(*(u32*)(cmd), &regs->CmdRing[idx]);\r\nwmb();\r\nidx = (idx - 1) % CMD_RING_ENTRIES;\r\nrrpriv->info->cmd_ctrl.pi = idx;\r\nwmb();\r\nif (readl(&regs->Mode) & FATAL_ERR)\r\nprintk("error code %02x\n", readl(&regs->Fail1));\r\n}\r\nstatic int rr_reset(struct net_device *dev)\r\n{\r\nstruct rr_private *rrpriv;\r\nstruct rr_regs __iomem *regs;\r\nu32 start_pc;\r\nint i;\r\nrrpriv = netdev_priv(dev);\r\nregs = rrpriv->regs;\r\nrr_load_firmware(dev);\r\nwritel(0x01000000, &regs->TX_state);\r\nwritel(0xff800000, &regs->RX_state);\r\nwritel(0, &regs->AssistState);\r\nwritel(CLEAR_INTA, &regs->LocalCtrl);\r\nwritel(0x01, &regs->BrkPt);\r\nwritel(0, &regs->Timer);\r\nwritel(0, &regs->TimerRef);\r\nwritel(RESET_DMA, &regs->DmaReadState);\r\nwritel(RESET_DMA, &regs->DmaWriteState);\r\nwritel(0, &regs->DmaWriteHostHi);\r\nwritel(0, &regs->DmaWriteHostLo);\r\nwritel(0, &regs->DmaReadHostHi);\r\nwritel(0, &regs->DmaReadHostLo);\r\nwritel(0, &regs->DmaReadLen);\r\nwritel(0, &regs->DmaWriteLen);\r\nwritel(0, &regs->DmaWriteLcl);\r\nwritel(0, &regs->DmaWriteIPchecksum);\r\nwritel(0, &regs->DmaReadLcl);\r\nwritel(0, &regs->DmaReadIPchecksum);\r\nwritel(0, &regs->PciState);\r\n#if (BITS_PER_LONG == 64) && defined __LITTLE_ENDIAN\r\nwritel(SWAP_DATA | PTR64BIT | PTR_WD_SWAP, &regs->Mode);\r\n#elif (BITS_PER_LONG == 64)\r\nwritel(SWAP_DATA | PTR64BIT | PTR_WD_NOSWAP, &regs->Mode);\r\n#else\r\nwritel(SWAP_DATA | PTR32BIT | PTR_WD_NOSWAP, &regs->Mode);\r\n#endif\r\n#if 0\r\nwritel(0xdf000, &regs->RxBase);\r\nwritel(0xdf000, &regs->RxPrd);\r\nwritel(0xdf000, &regs->RxCon);\r\nwritel(0xce000, &regs->TxBase);\r\nwritel(0xce000, &regs->TxPrd);\r\nwritel(0xce000, &regs->TxCon);\r\nwritel(0, &regs->RxIndPro);\r\nwritel(0, &regs->RxIndCon);\r\nwritel(0, &regs->RxIndRef);\r\nwritel(0, &regs->TxIndPro);\r\nwritel(0, &regs->TxIndCon);\r\nwritel(0, &regs->TxIndRef);\r\nwritel(0xcc000, &regs->pad10[0]);\r\nwritel(0, &regs->DrCmndPro);\r\nwritel(0, &regs->DrCmndCon);\r\nwritel(0, &regs->DwCmndPro);\r\nwritel(0, &regs->DwCmndCon);\r\nwritel(0, &regs->DwCmndRef);\r\nwritel(0, &regs->DrDataPro);\r\nwritel(0, &regs->DrDataCon);\r\nwritel(0, &regs->DrDataRef);\r\nwritel(0, &regs->DwDataPro);\r\nwritel(0, &regs->DwDataCon);\r\nwritel(0, &regs->DwDataRef);\r\n#endif\r\nwritel(0xffffffff, &regs->MbEvent);\r\nwritel(0, &regs->Event);\r\nwritel(0, &regs->TxPi);\r\nwritel(0, &regs->IpRxPi);\r\nwritel(0, &regs->EvtCon);\r\nwritel(0, &regs->EvtPrd);\r\nrrpriv->info->evt_ctrl.pi = 0;\r\nfor (i = 0; i < CMD_RING_ENTRIES; i++)\r\nwritel(0, &regs->CmdRing[i]);\r\nwritel(RBURST_64|WBURST_64, &regs->PciState);\r\nwmb();\r\nstart_pc = rr_read_eeprom_word(rrpriv,\r\noffsetof(struct eeprom, rncd_info.FwStart));\r\n#if (DEBUG > 1)\r\nprintk("%s: Executing firmware at address 0x%06x\n",\r\ndev->name, start_pc);\r\n#endif\r\nwritel(start_pc + 0x800, &regs->Pc);\r\nwmb();\r\nudelay(5);\r\nwritel(start_pc, &regs->Pc);\r\nwmb();\r\nreturn 0;\r\n}\r\nstatic unsigned int rr_read_eeprom(struct rr_private *rrpriv,\r\nunsigned long offset,\r\nunsigned char *buf,\r\nunsigned long length)\r\n{\r\nstruct rr_regs __iomem *regs = rrpriv->regs;\r\nu32 misc, io, host, i;\r\nio = readl(&regs->ExtIo);\r\nwritel(0, &regs->ExtIo);\r\nmisc = readl(&regs->LocalCtrl);\r\nwritel(0, &regs->LocalCtrl);\r\nhost = readl(&regs->HostCtrl);\r\nwritel(host | HALT_NIC, &regs->HostCtrl);\r\nmb();\r\nfor (i = 0; i < length; i++){\r\nwritel((EEPROM_BASE + ((offset+i) << 3)), &regs->WinBase);\r\nmb();\r\nbuf[i] = (readl(&regs->WinData) >> 24) & 0xff;\r\nmb();\r\n}\r\nwritel(host, &regs->HostCtrl);\r\nwritel(misc, &regs->LocalCtrl);\r\nwritel(io, &regs->ExtIo);\r\nmb();\r\nreturn i;\r\n}\r\nstatic u32 rr_read_eeprom_word(struct rr_private *rrpriv,\r\nsize_t offset)\r\n{\r\n__be32 word;\r\nif ((rr_read_eeprom(rrpriv, offset,\r\n(unsigned char *)&word, 4) == 4))\r\nreturn be32_to_cpu(word);\r\nreturn 0;\r\n}\r\nstatic unsigned int write_eeprom(struct rr_private *rrpriv,\r\nunsigned long offset,\r\nunsigned char *buf,\r\nunsigned long length)\r\n{\r\nstruct rr_regs __iomem *regs = rrpriv->regs;\r\nu32 misc, io, data, i, j, ready, error = 0;\r\nio = readl(&regs->ExtIo);\r\nwritel(0, &regs->ExtIo);\r\nmisc = readl(&regs->LocalCtrl);\r\nwritel(ENABLE_EEPROM_WRITE, &regs->LocalCtrl);\r\nmb();\r\nfor (i = 0; i < length; i++){\r\nwritel((EEPROM_BASE + ((offset+i) << 3)), &regs->WinBase);\r\nmb();\r\ndata = buf[i] << 24;\r\nif ((readl(&regs->WinData) & 0xff000000) != data){\r\nwritel(data, &regs->WinData);\r\nready = 0;\r\nj = 0;\r\nmb();\r\nwhile(!ready){\r\nudelay(20);\r\nif ((readl(&regs->WinData) & 0xff000000) ==\r\ndata)\r\nready = 1;\r\nmb();\r\nif (j++ > 5000){\r\nprintk("data mismatch: %08x, "\r\n"WinData %08x\n", data,\r\nreadl(&regs->WinData));\r\nready = 1;\r\nerror = 1;\r\n}\r\n}\r\n}\r\n}\r\nwritel(misc, &regs->LocalCtrl);\r\nwritel(io, &regs->ExtIo);\r\nmb();\r\nreturn error;\r\n}\r\nstatic int rr_init(struct net_device *dev)\r\n{\r\nstruct rr_private *rrpriv;\r\nstruct rr_regs __iomem *regs;\r\nu32 sram_size, rev;\r\nrrpriv = netdev_priv(dev);\r\nregs = rrpriv->regs;\r\nrev = readl(&regs->FwRev);\r\nrrpriv->fw_rev = rev;\r\nif (rev > 0x00020024)\r\nprintk(" Firmware revision: %i.%i.%i\n", (rev >> 16),\r\n((rev >> 8) & 0xff), (rev & 0xff));\r\nelse if (rev >= 0x00020000) {\r\nprintk(" Firmware revision: %i.%i.%i (2.0.37 or "\r\n"later is recommended)\n", (rev >> 16),\r\n((rev >> 8) & 0xff), (rev & 0xff));\r\n}else{\r\nprintk(" Firmware revision too old: %i.%i.%i, please "\r\n"upgrade to 2.0.37 or later.\n",\r\n(rev >> 16), ((rev >> 8) & 0xff), (rev & 0xff));\r\n}\r\n#if (DEBUG > 2)\r\nprintk(" Maximum receive rings %i\n", readl(&regs->MaxRxRng));\r\n#endif\r\n*(__be16 *)(dev->dev_addr) =\r\nhtons(rr_read_eeprom_word(rrpriv, offsetof(struct eeprom, manf.BoardULA)));\r\n*(__be32 *)(dev->dev_addr+2) =\r\nhtonl(rr_read_eeprom_word(rrpriv, offsetof(struct eeprom, manf.BoardULA[4])));\r\nprintk(" MAC: %pM\n", dev->dev_addr);\r\nsram_size = rr_read_eeprom_word(rrpriv, 8);\r\nprintk(" SRAM size 0x%06x\n", sram_size);\r\nreturn 0;\r\n}\r\nstatic int rr_init1(struct net_device *dev)\r\n{\r\nstruct rr_private *rrpriv;\r\nstruct rr_regs __iomem *regs;\r\nunsigned long myjif, flags;\r\nstruct cmd cmd;\r\nu32 hostctrl;\r\nint ecode = 0;\r\nshort i;\r\nrrpriv = netdev_priv(dev);\r\nregs = rrpriv->regs;\r\nspin_lock_irqsave(&rrpriv->lock, flags);\r\nhostctrl = readl(&regs->HostCtrl);\r\nwritel(hostctrl | HALT_NIC | RR_CLEAR_INT, &regs->HostCtrl);\r\nwmb();\r\nif (hostctrl & PARITY_ERR){\r\nprintk("%s: Parity error halting NIC - this is serious!\n",\r\ndev->name);\r\nspin_unlock_irqrestore(&rrpriv->lock, flags);\r\necode = -EFAULT;\r\ngoto error;\r\n}\r\nset_rxaddr(regs, rrpriv->rx_ctrl_dma);\r\nset_infoaddr(regs, rrpriv->info_dma);\r\nrrpriv->info->evt_ctrl.entry_size = sizeof(struct event);\r\nrrpriv->info->evt_ctrl.entries = EVT_RING_ENTRIES;\r\nrrpriv->info->evt_ctrl.mode = 0;\r\nrrpriv->info->evt_ctrl.pi = 0;\r\nset_rraddr(&rrpriv->info->evt_ctrl.rngptr, rrpriv->evt_ring_dma);\r\nrrpriv->info->cmd_ctrl.entry_size = sizeof(struct cmd);\r\nrrpriv->info->cmd_ctrl.entries = CMD_RING_ENTRIES;\r\nrrpriv->info->cmd_ctrl.mode = 0;\r\nrrpriv->info->cmd_ctrl.pi = 15;\r\nfor (i = 0; i < CMD_RING_ENTRIES; i++) {\r\nwritel(0, &regs->CmdRing[i]);\r\n}\r\nfor (i = 0; i < TX_RING_ENTRIES; i++) {\r\nrrpriv->tx_ring[i].size = 0;\r\nset_rraddr(&rrpriv->tx_ring[i].addr, 0);\r\nrrpriv->tx_skbuff[i] = NULL;\r\n}\r\nrrpriv->info->tx_ctrl.entry_size = sizeof(struct tx_desc);\r\nrrpriv->info->tx_ctrl.entries = TX_RING_ENTRIES;\r\nrrpriv->info->tx_ctrl.mode = 0;\r\nrrpriv->info->tx_ctrl.pi = 0;\r\nset_rraddr(&rrpriv->info->tx_ctrl.rngptr, rrpriv->tx_ring_dma);\r\nrrpriv->tx_full = 0;\r\nrrpriv->cur_rx = 0;\r\nrrpriv->dirty_rx = rrpriv->dirty_tx = 0;\r\nrr_reset(dev);\r\nwritel(0x5000, &regs->ConRetry);\r\nwritel(0x100, &regs->ConRetryTmr);\r\nwritel(0x500000, &regs->ConTmout);\r\nwritel(0x60, &regs->IntrTmr);\r\nwritel(0x500000, &regs->TxDataMvTimeout);\r\nwritel(0x200000, &regs->RxDataMvTimeout);\r\nwritel(0x80, &regs->WriteDmaThresh);\r\nwritel(0x80, &regs->ReadDmaThresh);\r\nrrpriv->fw_running = 0;\r\nwmb();\r\nhostctrl &= ~(HALT_NIC | INVALID_INST_B | PARITY_ERR);\r\nwritel(hostctrl, &regs->HostCtrl);\r\nwmb();\r\nspin_unlock_irqrestore(&rrpriv->lock, flags);\r\nfor (i = 0; i < RX_RING_ENTRIES; i++) {\r\nstruct sk_buff *skb;\r\ndma_addr_t addr;\r\nrrpriv->rx_ring[i].mode = 0;\r\nskb = alloc_skb(dev->mtu + HIPPI_HLEN, GFP_ATOMIC);\r\nif (!skb) {\r\nprintk(KERN_WARNING "%s: Unable to allocate memory "\r\n"for receive ring - halting NIC\n", dev->name);\r\necode = -ENOMEM;\r\ngoto error;\r\n}\r\nrrpriv->rx_skbuff[i] = skb;\r\naddr = pci_map_single(rrpriv->pci_dev, skb->data,\r\ndev->mtu + HIPPI_HLEN, PCI_DMA_FROMDEVICE);\r\nif ((((unsigned long)skb->data) & 0xfff) > ~65320)\r\nprintk("skb alloc error\n");\r\nset_rraddr(&rrpriv->rx_ring[i].addr, addr);\r\nrrpriv->rx_ring[i].size = dev->mtu + HIPPI_HLEN;\r\n}\r\nrrpriv->rx_ctrl[4].entry_size = sizeof(struct rx_desc);\r\nrrpriv->rx_ctrl[4].entries = RX_RING_ENTRIES;\r\nrrpriv->rx_ctrl[4].mode = 8;\r\nrrpriv->rx_ctrl[4].pi = 0;\r\nwmb();\r\nset_rraddr(&rrpriv->rx_ctrl[4].rngptr, rrpriv->rx_ring_dma);\r\nudelay(1000);\r\ncmd.code = C_START_FW;\r\ncmd.ring = 0;\r\ncmd.index = 0;\r\nrr_issue_cmd(rrpriv, &cmd);\r\nmyjif = jiffies + 5 * HZ;\r\nwhile (time_before(jiffies, myjif) && !rrpriv->fw_running)\r\ncpu_relax();\r\nnetif_start_queue(dev);\r\nreturn ecode;\r\nerror:\r\nfor (i = 0; i < RX_RING_ENTRIES; i++) {\r\nstruct sk_buff *skb = rrpriv->rx_skbuff[i];\r\nif (skb) {\r\npci_unmap_single(rrpriv->pci_dev,\r\nrrpriv->rx_ring[i].addr.addrlo,\r\ndev->mtu + HIPPI_HLEN,\r\nPCI_DMA_FROMDEVICE);\r\nrrpriv->rx_ring[i].size = 0;\r\nset_rraddr(&rrpriv->rx_ring[i].addr, 0);\r\ndev_kfree_skb(skb);\r\nrrpriv->rx_skbuff[i] = NULL;\r\n}\r\n}\r\nreturn ecode;\r\n}\r\nstatic u32 rr_handle_event(struct net_device *dev, u32 prodidx, u32 eidx)\r\n{\r\nstruct rr_private *rrpriv;\r\nstruct rr_regs __iomem *regs;\r\nu32 tmp;\r\nrrpriv = netdev_priv(dev);\r\nregs = rrpriv->regs;\r\nwhile (prodidx != eidx){\r\nswitch (rrpriv->evt_ring[eidx].code){\r\ncase E_NIC_UP:\r\ntmp = readl(&regs->FwRev);\r\nprintk(KERN_INFO "%s: Firmware revision %i.%i.%i "\r\n"up and running\n", dev->name,\r\n(tmp >> 16), ((tmp >> 8) & 0xff), (tmp & 0xff));\r\nrrpriv->fw_running = 1;\r\nwritel(RX_RING_ENTRIES - 1, &regs->IpRxPi);\r\nwmb();\r\nbreak;\r\ncase E_LINK_ON:\r\nprintk(KERN_INFO "%s: Optical link ON\n", dev->name);\r\nbreak;\r\ncase E_LINK_OFF:\r\nprintk(KERN_INFO "%s: Optical link OFF\n", dev->name);\r\nbreak;\r\ncase E_RX_IDLE:\r\nprintk(KERN_WARNING "%s: RX data not moving\n",\r\ndev->name);\r\ngoto drop;\r\ncase E_WATCHDOG:\r\nprintk(KERN_INFO "%s: The watchdog is here to see "\r\n"us\n", dev->name);\r\nbreak;\r\ncase E_INTERN_ERR:\r\nprintk(KERN_ERR "%s: HIPPI Internal NIC error\n",\r\ndev->name);\r\nwritel(readl(&regs->HostCtrl)|HALT_NIC|RR_CLEAR_INT,\r\n&regs->HostCtrl);\r\nwmb();\r\nbreak;\r\ncase E_HOST_ERR:\r\nprintk(KERN_ERR "%s: Host software error\n",\r\ndev->name);\r\nwritel(readl(&regs->HostCtrl)|HALT_NIC|RR_CLEAR_INT,\r\n&regs->HostCtrl);\r\nwmb();\r\nbreak;\r\ncase E_CON_REJ:\r\nprintk(KERN_WARNING "%s: Connection rejected\n",\r\ndev->name);\r\ndev->stats.tx_aborted_errors++;\r\nbreak;\r\ncase E_CON_TMOUT:\r\nprintk(KERN_WARNING "%s: Connection timeout\n",\r\ndev->name);\r\nbreak;\r\ncase E_DISC_ERR:\r\nprintk(KERN_WARNING "%s: HIPPI disconnect error\n",\r\ndev->name);\r\ndev->stats.tx_aborted_errors++;\r\nbreak;\r\ncase E_INT_PRTY:\r\nprintk(KERN_ERR "%s: HIPPI Internal Parity error\n",\r\ndev->name);\r\nwritel(readl(&regs->HostCtrl)|HALT_NIC|RR_CLEAR_INT,\r\n&regs->HostCtrl);\r\nwmb();\r\nbreak;\r\ncase E_TX_IDLE:\r\nprintk(KERN_WARNING "%s: Transmitter idle\n",\r\ndev->name);\r\nbreak;\r\ncase E_TX_LINK_DROP:\r\nprintk(KERN_WARNING "%s: Link lost during transmit\n",\r\ndev->name);\r\ndev->stats.tx_aborted_errors++;\r\nwritel(readl(&regs->HostCtrl)|HALT_NIC|RR_CLEAR_INT,\r\n&regs->HostCtrl);\r\nwmb();\r\nbreak;\r\ncase E_TX_INV_RNG:\r\nprintk(KERN_ERR "%s: Invalid send ring block\n",\r\ndev->name);\r\nwritel(readl(&regs->HostCtrl)|HALT_NIC|RR_CLEAR_INT,\r\n&regs->HostCtrl);\r\nwmb();\r\nbreak;\r\ncase E_TX_INV_BUF:\r\nprintk(KERN_ERR "%s: Invalid send buffer address\n",\r\ndev->name);\r\nwritel(readl(&regs->HostCtrl)|HALT_NIC|RR_CLEAR_INT,\r\n&regs->HostCtrl);\r\nwmb();\r\nbreak;\r\ncase E_TX_INV_DSC:\r\nprintk(KERN_ERR "%s: Invalid descriptor address\n",\r\ndev->name);\r\nwritel(readl(&regs->HostCtrl)|HALT_NIC|RR_CLEAR_INT,\r\n&regs->HostCtrl);\r\nwmb();\r\nbreak;\r\ncase E_RX_RNG_OUT:\r\nprintk(KERN_INFO "%s: Receive ring full\n", dev->name);\r\nbreak;\r\ncase E_RX_PAR_ERR:\r\nprintk(KERN_WARNING "%s: Receive parity error\n",\r\ndev->name);\r\ngoto drop;\r\ncase E_RX_LLRC_ERR:\r\nprintk(KERN_WARNING "%s: Receive LLRC error\n",\r\ndev->name);\r\ngoto drop;\r\ncase E_PKT_LN_ERR:\r\nprintk(KERN_WARNING "%s: Receive packet length "\r\n"error\n", dev->name);\r\ngoto drop;\r\ncase E_DTA_CKSM_ERR:\r\nprintk(KERN_WARNING "%s: Data checksum error\n",\r\ndev->name);\r\ngoto drop;\r\ncase E_SHT_BST:\r\nprintk(KERN_WARNING "%s: Unexpected short burst "\r\n"error\n", dev->name);\r\ngoto drop;\r\ncase E_STATE_ERR:\r\nprintk(KERN_WARNING "%s: Recv. state transition"\r\n" error\n", dev->name);\r\ngoto drop;\r\ncase E_UNEXP_DATA:\r\nprintk(KERN_WARNING "%s: Unexpected data error\n",\r\ndev->name);\r\ngoto drop;\r\ncase E_LST_LNK_ERR:\r\nprintk(KERN_WARNING "%s: Link lost error\n",\r\ndev->name);\r\ngoto drop;\r\ncase E_FRM_ERR:\r\nprintk(KERN_WARNING "%s: Framming Error\n",\r\ndev->name);\r\ngoto drop;\r\ncase E_FLG_SYN_ERR:\r\nprintk(KERN_WARNING "%s: Flag sync. lost during "\r\n"packet\n", dev->name);\r\ngoto drop;\r\ncase E_RX_INV_BUF:\r\nprintk(KERN_ERR "%s: Invalid receive buffer "\r\n"address\n", dev->name);\r\nwritel(readl(&regs->HostCtrl)|HALT_NIC|RR_CLEAR_INT,\r\n&regs->HostCtrl);\r\nwmb();\r\nbreak;\r\ncase E_RX_INV_DSC:\r\nprintk(KERN_ERR "%s: Invalid receive descriptor "\r\n"address\n", dev->name);\r\nwritel(readl(&regs->HostCtrl)|HALT_NIC|RR_CLEAR_INT,\r\n&regs->HostCtrl);\r\nwmb();\r\nbreak;\r\ncase E_RNG_BLK:\r\nprintk(KERN_ERR "%s: Invalid ring block\n",\r\ndev->name);\r\nwritel(readl(&regs->HostCtrl)|HALT_NIC|RR_CLEAR_INT,\r\n&regs->HostCtrl);\r\nwmb();\r\nbreak;\r\ndrop:\r\n{\r\nu16 index = rrpriv->evt_ring[eidx].index;\r\nindex = (index + (RX_RING_ENTRIES - 1)) %\r\nRX_RING_ENTRIES;\r\nrrpriv->rx_ring[index].mode |=\r\n(PACKET_BAD | PACKET_END);\r\n}\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "%s: Unhandled event 0x%02x\n",\r\ndev->name, rrpriv->evt_ring[eidx].code);\r\n}\r\neidx = (eidx + 1) % EVT_RING_ENTRIES;\r\n}\r\nrrpriv->info->evt_ctrl.pi = eidx;\r\nwmb();\r\nreturn eidx;\r\n}\r\nstatic void rx_int(struct net_device *dev, u32 rxlimit, u32 index)\r\n{\r\nstruct rr_private *rrpriv = netdev_priv(dev);\r\nstruct rr_regs __iomem *regs = rrpriv->regs;\r\ndo {\r\nstruct rx_desc *desc;\r\nu32 pkt_len;\r\ndesc = &(rrpriv->rx_ring[index]);\r\npkt_len = desc->size;\r\n#if (DEBUG > 2)\r\nprintk("index %i, rxlimit %i\n", index, rxlimit);\r\nprintk("len %x, mode %x\n", pkt_len, desc->mode);\r\n#endif\r\nif ( (rrpriv->rx_ring[index].mode & PACKET_BAD) == PACKET_BAD){\r\ndev->stats.rx_dropped++;\r\ngoto defer;\r\n}\r\nif (pkt_len > 0){\r\nstruct sk_buff *skb, *rx_skb;\r\nrx_skb = rrpriv->rx_skbuff[index];\r\nif (pkt_len < PKT_COPY_THRESHOLD) {\r\nskb = alloc_skb(pkt_len, GFP_ATOMIC);\r\nif (skb == NULL){\r\nprintk(KERN_WARNING "%s: Unable to allocate skb (%i bytes), deferring packet\n", dev->name, pkt_len);\r\ndev->stats.rx_dropped++;\r\ngoto defer;\r\n} else {\r\npci_dma_sync_single_for_cpu(rrpriv->pci_dev,\r\ndesc->addr.addrlo,\r\npkt_len,\r\nPCI_DMA_FROMDEVICE);\r\nskb_put_data(skb, rx_skb->data,\r\npkt_len);\r\npci_dma_sync_single_for_device(rrpriv->pci_dev,\r\ndesc->addr.addrlo,\r\npkt_len,\r\nPCI_DMA_FROMDEVICE);\r\n}\r\n}else{\r\nstruct sk_buff *newskb;\r\nnewskb = alloc_skb(dev->mtu + HIPPI_HLEN,\r\nGFP_ATOMIC);\r\nif (newskb){\r\ndma_addr_t addr;\r\npci_unmap_single(rrpriv->pci_dev,\r\ndesc->addr.addrlo, dev->mtu +\r\nHIPPI_HLEN, PCI_DMA_FROMDEVICE);\r\nskb = rx_skb;\r\nskb_put(skb, pkt_len);\r\nrrpriv->rx_skbuff[index] = newskb;\r\naddr = pci_map_single(rrpriv->pci_dev,\r\nnewskb->data,\r\ndev->mtu + HIPPI_HLEN,\r\nPCI_DMA_FROMDEVICE);\r\nset_rraddr(&desc->addr, addr);\r\n} else {\r\nprintk("%s: Out of memory, deferring "\r\n"packet\n", dev->name);\r\ndev->stats.rx_dropped++;\r\ngoto defer;\r\n}\r\n}\r\nskb->protocol = hippi_type_trans(skb, dev);\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += pkt_len;\r\n}\r\ndefer:\r\ndesc->mode = 0;\r\ndesc->size = dev->mtu + HIPPI_HLEN;\r\nif ((index & 7) == 7)\r\nwritel(index, &regs->IpRxPi);\r\nindex = (index + 1) % RX_RING_ENTRIES;\r\n} while(index != rxlimit);\r\nrrpriv->cur_rx = index;\r\nwmb();\r\n}\r\nstatic irqreturn_t rr_interrupt(int irq, void *dev_id)\r\n{\r\nstruct rr_private *rrpriv;\r\nstruct rr_regs __iomem *regs;\r\nstruct net_device *dev = (struct net_device *)dev_id;\r\nu32 prodidx, rxindex, eidx, txcsmr, rxlimit, txcon;\r\nrrpriv = netdev_priv(dev);\r\nregs = rrpriv->regs;\r\nif (!(readl(&regs->HostCtrl) & RR_INT))\r\nreturn IRQ_NONE;\r\nspin_lock(&rrpriv->lock);\r\nprodidx = readl(&regs->EvtPrd);\r\ntxcsmr = (prodidx >> 8) & 0xff;\r\nrxlimit = (prodidx >> 16) & 0xff;\r\nprodidx &= 0xff;\r\n#if (DEBUG > 2)\r\nprintk("%s: interrupt, prodidx = %i, eidx = %i\n", dev->name,\r\nprodidx, rrpriv->info->evt_ctrl.pi);\r\n#endif\r\neidx = rrpriv->info->evt_ctrl.pi;\r\nif (prodidx != eidx)\r\neidx = rr_handle_event(dev, prodidx, eidx);\r\nrxindex = rrpriv->cur_rx;\r\nif (rxindex != rxlimit)\r\nrx_int(dev, rxlimit, rxindex);\r\ntxcon = rrpriv->dirty_tx;\r\nif (txcsmr != txcon) {\r\ndo {\r\nif(rrpriv->tx_skbuff[txcon]){\r\nstruct tx_desc *desc;\r\nstruct sk_buff *skb;\r\ndesc = &(rrpriv->tx_ring[txcon]);\r\nskb = rrpriv->tx_skbuff[txcon];\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += skb->len;\r\npci_unmap_single(rrpriv->pci_dev,\r\ndesc->addr.addrlo, skb->len,\r\nPCI_DMA_TODEVICE);\r\ndev_kfree_skb_irq(skb);\r\nrrpriv->tx_skbuff[txcon] = NULL;\r\ndesc->size = 0;\r\nset_rraddr(&rrpriv->tx_ring[txcon].addr, 0);\r\ndesc->mode = 0;\r\n}\r\ntxcon = (txcon + 1) % TX_RING_ENTRIES;\r\n} while (txcsmr != txcon);\r\nwmb();\r\nrrpriv->dirty_tx = txcon;\r\nif (rrpriv->tx_full && rr_if_busy(dev) &&\r\n(((rrpriv->info->tx_ctrl.pi + 1) % TX_RING_ENTRIES)\r\n!= rrpriv->dirty_tx)){\r\nrrpriv->tx_full = 0;\r\nnetif_wake_queue(dev);\r\n}\r\n}\r\neidx |= ((txcsmr << 8) | (rxlimit << 16));\r\nwritel(eidx, &regs->EvtCon);\r\nwmb();\r\nspin_unlock(&rrpriv->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic inline void rr_raz_tx(struct rr_private *rrpriv,\r\nstruct net_device *dev)\r\n{\r\nint i;\r\nfor (i = 0; i < TX_RING_ENTRIES; i++) {\r\nstruct sk_buff *skb = rrpriv->tx_skbuff[i];\r\nif (skb) {\r\nstruct tx_desc *desc = &(rrpriv->tx_ring[i]);\r\npci_unmap_single(rrpriv->pci_dev, desc->addr.addrlo,\r\nskb->len, PCI_DMA_TODEVICE);\r\ndesc->size = 0;\r\nset_rraddr(&desc->addr, 0);\r\ndev_kfree_skb(skb);\r\nrrpriv->tx_skbuff[i] = NULL;\r\n}\r\n}\r\n}\r\nstatic inline void rr_raz_rx(struct rr_private *rrpriv,\r\nstruct net_device *dev)\r\n{\r\nint i;\r\nfor (i = 0; i < RX_RING_ENTRIES; i++) {\r\nstruct sk_buff *skb = rrpriv->rx_skbuff[i];\r\nif (skb) {\r\nstruct rx_desc *desc = &(rrpriv->rx_ring[i]);\r\npci_unmap_single(rrpriv->pci_dev, desc->addr.addrlo,\r\ndev->mtu + HIPPI_HLEN, PCI_DMA_FROMDEVICE);\r\ndesc->size = 0;\r\nset_rraddr(&desc->addr, 0);\r\ndev_kfree_skb(skb);\r\nrrpriv->rx_skbuff[i] = NULL;\r\n}\r\n}\r\n}\r\nstatic void rr_timer(unsigned long data)\r\n{\r\nstruct net_device *dev = (struct net_device *)data;\r\nstruct rr_private *rrpriv = netdev_priv(dev);\r\nstruct rr_regs __iomem *regs = rrpriv->regs;\r\nunsigned long flags;\r\nif (readl(&regs->HostCtrl) & NIC_HALTED){\r\nprintk("%s: Restarting nic\n", dev->name);\r\nmemset(rrpriv->rx_ctrl, 0, 256 * sizeof(struct ring_ctrl));\r\nmemset(rrpriv->info, 0, sizeof(struct rr_info));\r\nwmb();\r\nrr_raz_tx(rrpriv, dev);\r\nrr_raz_rx(rrpriv, dev);\r\nif (rr_init1(dev)) {\r\nspin_lock_irqsave(&rrpriv->lock, flags);\r\nwritel(readl(&regs->HostCtrl)|HALT_NIC|RR_CLEAR_INT,\r\n&regs->HostCtrl);\r\nspin_unlock_irqrestore(&rrpriv->lock, flags);\r\n}\r\n}\r\nrrpriv->timer.expires = RUN_AT(5*HZ);\r\nadd_timer(&rrpriv->timer);\r\n}\r\nstatic int rr_open(struct net_device *dev)\r\n{\r\nstruct rr_private *rrpriv = netdev_priv(dev);\r\nstruct pci_dev *pdev = rrpriv->pci_dev;\r\nstruct rr_regs __iomem *regs;\r\nint ecode = 0;\r\nunsigned long flags;\r\ndma_addr_t dma_addr;\r\nregs = rrpriv->regs;\r\nif (rrpriv->fw_rev < 0x00020000) {\r\nprintk(KERN_WARNING "%s: trying to configure device with "\r\n"obsolete firmware\n", dev->name);\r\necode = -EBUSY;\r\ngoto error;\r\n}\r\nrrpriv->rx_ctrl = pci_alloc_consistent(pdev,\r\n256 * sizeof(struct ring_ctrl),\r\n&dma_addr);\r\nif (!rrpriv->rx_ctrl) {\r\necode = -ENOMEM;\r\ngoto error;\r\n}\r\nrrpriv->rx_ctrl_dma = dma_addr;\r\nmemset(rrpriv->rx_ctrl, 0, 256*sizeof(struct ring_ctrl));\r\nrrpriv->info = pci_alloc_consistent(pdev, sizeof(struct rr_info),\r\n&dma_addr);\r\nif (!rrpriv->info) {\r\necode = -ENOMEM;\r\ngoto error;\r\n}\r\nrrpriv->info_dma = dma_addr;\r\nmemset(rrpriv->info, 0, sizeof(struct rr_info));\r\nwmb();\r\nspin_lock_irqsave(&rrpriv->lock, flags);\r\nwritel(readl(&regs->HostCtrl)|HALT_NIC|RR_CLEAR_INT, &regs->HostCtrl);\r\nreadl(&regs->HostCtrl);\r\nspin_unlock_irqrestore(&rrpriv->lock, flags);\r\nif (request_irq(pdev->irq, rr_interrupt, IRQF_SHARED, dev->name, dev)) {\r\nprintk(KERN_WARNING "%s: Requested IRQ %d is busy\n",\r\ndev->name, pdev->irq);\r\necode = -EAGAIN;\r\ngoto error;\r\n}\r\nif ((ecode = rr_init1(dev)))\r\ngoto error;\r\ninit_timer(&rrpriv->timer);\r\nrrpriv->timer.expires = RUN_AT(5*HZ);\r\nrrpriv->timer.data = (unsigned long)dev;\r\nrrpriv->timer.function = rr_timer;\r\nadd_timer(&rrpriv->timer);\r\nnetif_start_queue(dev);\r\nreturn ecode;\r\nerror:\r\nspin_lock_irqsave(&rrpriv->lock, flags);\r\nwritel(readl(&regs->HostCtrl)|HALT_NIC|RR_CLEAR_INT, &regs->HostCtrl);\r\nspin_unlock_irqrestore(&rrpriv->lock, flags);\r\nif (rrpriv->info) {\r\npci_free_consistent(pdev, sizeof(struct rr_info), rrpriv->info,\r\nrrpriv->info_dma);\r\nrrpriv->info = NULL;\r\n}\r\nif (rrpriv->rx_ctrl) {\r\npci_free_consistent(pdev, sizeof(struct ring_ctrl),\r\nrrpriv->rx_ctrl, rrpriv->rx_ctrl_dma);\r\nrrpriv->rx_ctrl = NULL;\r\n}\r\nnetif_stop_queue(dev);\r\nreturn ecode;\r\n}\r\nstatic void rr_dump(struct net_device *dev)\r\n{\r\nstruct rr_private *rrpriv;\r\nstruct rr_regs __iomem *regs;\r\nu32 index, cons;\r\nshort i;\r\nint len;\r\nrrpriv = netdev_priv(dev);\r\nregs = rrpriv->regs;\r\nprintk("%s: dumping NIC TX rings\n", dev->name);\r\nprintk("RxPrd %08x, TxPrd %02x, EvtPrd %08x, TxPi %02x, TxCtrlPi %02x\n",\r\nreadl(&regs->RxPrd), readl(&regs->TxPrd),\r\nreadl(&regs->EvtPrd), readl(&regs->TxPi),\r\nrrpriv->info->tx_ctrl.pi);\r\nprintk("Error code 0x%x\n", readl(&regs->Fail1));\r\nindex = (((readl(&regs->EvtPrd) >> 8) & 0xff) - 1) % TX_RING_ENTRIES;\r\ncons = rrpriv->dirty_tx;\r\nprintk("TX ring index %i, TX consumer %i\n",\r\nindex, cons);\r\nif (rrpriv->tx_skbuff[index]){\r\nlen = min_t(int, 0x80, rrpriv->tx_skbuff[index]->len);\r\nprintk("skbuff for index %i is valid - dumping data (0x%x bytes - DMA len 0x%x)\n", index, len, rrpriv->tx_ring[index].size);\r\nfor (i = 0; i < len; i++){\r\nif (!(i & 7))\r\nprintk("\n");\r\nprintk("%02x ", (unsigned char) rrpriv->tx_skbuff[index]->data[i]);\r\n}\r\nprintk("\n");\r\n}\r\nif (rrpriv->tx_skbuff[cons]){\r\nlen = min_t(int, 0x80, rrpriv->tx_skbuff[cons]->len);\r\nprintk("skbuff for cons %i is valid - dumping data (0x%x bytes - skbuff len 0x%x)\n", cons, len, rrpriv->tx_skbuff[cons]->len);\r\nprintk("mode 0x%x, size 0x%x,\n phys %08Lx, skbuff-addr %08lx, truesize 0x%x\n",\r\nrrpriv->tx_ring[cons].mode,\r\nrrpriv->tx_ring[cons].size,\r\n(unsigned long long) rrpriv->tx_ring[cons].addr.addrlo,\r\n(unsigned long)rrpriv->tx_skbuff[cons]->data,\r\n(unsigned int)rrpriv->tx_skbuff[cons]->truesize);\r\nfor (i = 0; i < len; i++){\r\nif (!(i & 7))\r\nprintk("\n");\r\nprintk("%02x ", (unsigned char)rrpriv->tx_ring[cons].size);\r\n}\r\nprintk("\n");\r\n}\r\nprintk("dumping TX ring info:\n");\r\nfor (i = 0; i < TX_RING_ENTRIES; i++)\r\nprintk("mode 0x%x, size 0x%x, phys-addr %08Lx\n",\r\nrrpriv->tx_ring[i].mode,\r\nrrpriv->tx_ring[i].size,\r\n(unsigned long long) rrpriv->tx_ring[i].addr.addrlo);\r\n}\r\nstatic int rr_close(struct net_device *dev)\r\n{\r\nstruct rr_private *rrpriv = netdev_priv(dev);\r\nstruct rr_regs __iomem *regs = rrpriv->regs;\r\nstruct pci_dev *pdev = rrpriv->pci_dev;\r\nunsigned long flags;\r\nu32 tmp;\r\nshort i;\r\nnetif_stop_queue(dev);\r\nspin_lock_irqsave(&rrpriv->lock, flags);\r\ntmp = readl(&regs->HostCtrl);\r\nif (tmp & NIC_HALTED){\r\nprintk("%s: NIC already halted\n", dev->name);\r\nrr_dump(dev);\r\n}else{\r\ntmp |= HALT_NIC | RR_CLEAR_INT;\r\nwritel(tmp, &regs->HostCtrl);\r\nreadl(&regs->HostCtrl);\r\n}\r\nrrpriv->fw_running = 0;\r\ndel_timer_sync(&rrpriv->timer);\r\nwritel(0, &regs->TxPi);\r\nwritel(0, &regs->IpRxPi);\r\nwritel(0, &regs->EvtCon);\r\nwritel(0, &regs->EvtPrd);\r\nfor (i = 0; i < CMD_RING_ENTRIES; i++)\r\nwritel(0, &regs->CmdRing[i]);\r\nrrpriv->info->tx_ctrl.entries = 0;\r\nrrpriv->info->cmd_ctrl.pi = 0;\r\nrrpriv->info->evt_ctrl.pi = 0;\r\nrrpriv->rx_ctrl[4].entries = 0;\r\nrr_raz_tx(rrpriv, dev);\r\nrr_raz_rx(rrpriv, dev);\r\npci_free_consistent(pdev, 256 * sizeof(struct ring_ctrl),\r\nrrpriv->rx_ctrl, rrpriv->rx_ctrl_dma);\r\nrrpriv->rx_ctrl = NULL;\r\npci_free_consistent(pdev, sizeof(struct rr_info), rrpriv->info,\r\nrrpriv->info_dma);\r\nrrpriv->info = NULL;\r\nfree_irq(pdev->irq, dev);\r\nspin_unlock_irqrestore(&rrpriv->lock, flags);\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t rr_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct rr_private *rrpriv = netdev_priv(dev);\r\nstruct rr_regs __iomem *regs = rrpriv->regs;\r\nstruct hippi_cb *hcb = (struct hippi_cb *) skb->cb;\r\nstruct ring_ctrl *txctrl;\r\nunsigned long flags;\r\nu32 index, len = skb->len;\r\nu32 *ifield;\r\nstruct sk_buff *new_skb;\r\nif (readl(&regs->Mode) & FATAL_ERR)\r\nprintk("error codes Fail1 %02x, Fail2 %02x\n",\r\nreadl(&regs->Fail1), readl(&regs->Fail2));\r\nif (skb_headroom(skb) < 8){\r\nprintk("incoming skb too small - reallocating\n");\r\nif (!(new_skb = dev_alloc_skb(len + 8))) {\r\ndev_kfree_skb(skb);\r\nnetif_wake_queue(dev);\r\nreturn NETDEV_TX_OK;\r\n}\r\nskb_reserve(new_skb, 8);\r\nskb_put(new_skb, len);\r\nskb_copy_from_linear_data(skb, new_skb->data, len);\r\ndev_kfree_skb(skb);\r\nskb = new_skb;\r\n}\r\nifield = skb_push(skb, 8);\r\nifield[0] = 0;\r\nifield[1] = hcb->ifield;\r\nspin_lock_irqsave(&rrpriv->lock, flags);\r\ntxctrl = &rrpriv->info->tx_ctrl;\r\nindex = txctrl->pi;\r\nrrpriv->tx_skbuff[index] = skb;\r\nset_rraddr(&rrpriv->tx_ring[index].addr, pci_map_single(\r\nrrpriv->pci_dev, skb->data, len + 8, PCI_DMA_TODEVICE));\r\nrrpriv->tx_ring[index].size = len + 8;\r\nrrpriv->tx_ring[index].mode = PACKET_START | PACKET_END;\r\ntxctrl->pi = (index + 1) % TX_RING_ENTRIES;\r\nwmb();\r\nwritel(txctrl->pi, &regs->TxPi);\r\nif (txctrl->pi == rrpriv->dirty_tx){\r\nrrpriv->tx_full = 1;\r\nnetif_stop_queue(dev);\r\n}\r\nspin_unlock_irqrestore(&rrpriv->lock, flags);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int rr_load_firmware(struct net_device *dev)\r\n{\r\nstruct rr_private *rrpriv;\r\nstruct rr_regs __iomem *regs;\r\nsize_t eptr, segptr;\r\nint i, j;\r\nu32 localctrl, sptr, len, tmp;\r\nu32 p2len, p2size, nr_seg, revision, io, sram_size;\r\nrrpriv = netdev_priv(dev);\r\nregs = rrpriv->regs;\r\nif (dev->flags & IFF_UP)\r\nreturn -EBUSY;\r\nif (!(readl(&regs->HostCtrl) & NIC_HALTED)){\r\nprintk("%s: Trying to load firmware to a running NIC.\n",\r\ndev->name);\r\nreturn -EBUSY;\r\n}\r\nlocalctrl = readl(&regs->LocalCtrl);\r\nwritel(0, &regs->LocalCtrl);\r\nwritel(0, &regs->EvtPrd);\r\nwritel(0, &regs->RxPrd);\r\nwritel(0, &regs->TxPrd);\r\nio = readl(&regs->ExtIo);\r\nwritel(0, &regs->ExtIo);\r\nsram_size = rr_read_eeprom_word(rrpriv, 8);\r\nfor (i = 200; i < sram_size / 4; i++){\r\nwritel(i * 4, &regs->WinBase);\r\nmb();\r\nwritel(0, &regs->WinData);\r\nmb();\r\n}\r\nwritel(io, &regs->ExtIo);\r\nmb();\r\neptr = rr_read_eeprom_word(rrpriv,\r\noffsetof(struct eeprom, rncd_info.AddrRunCodeSegs));\r\neptr = ((eptr & 0x1fffff) >> 3);\r\np2len = rr_read_eeprom_word(rrpriv, 0x83*4);\r\np2len = (p2len << 2);\r\np2size = rr_read_eeprom_word(rrpriv, 0x84*4);\r\np2size = ((p2size & 0x1fffff) >> 3);\r\nif ((eptr < p2size) || (eptr > (p2size + p2len))){\r\nprintk("%s: eptr is invalid\n", dev->name);\r\ngoto out;\r\n}\r\nrevision = rr_read_eeprom_word(rrpriv,\r\noffsetof(struct eeprom, manf.HeaderFmt));\r\nif (revision != 1){\r\nprintk("%s: invalid firmware format (%i)\n",\r\ndev->name, revision);\r\ngoto out;\r\n}\r\nnr_seg = rr_read_eeprom_word(rrpriv, eptr);\r\neptr +=4;\r\n#if (DEBUG > 1)\r\nprintk("%s: nr_seg %i\n", dev->name, nr_seg);\r\n#endif\r\nfor (i = 0; i < nr_seg; i++){\r\nsptr = rr_read_eeprom_word(rrpriv, eptr);\r\neptr += 4;\r\nlen = rr_read_eeprom_word(rrpriv, eptr);\r\neptr += 4;\r\nsegptr = rr_read_eeprom_word(rrpriv, eptr);\r\nsegptr = ((segptr & 0x1fffff) >> 3);\r\neptr += 4;\r\n#if (DEBUG > 1)\r\nprintk("%s: segment %i, sram address %06x, length %04x, segptr %06x\n",\r\ndev->name, i, sptr, len, segptr);\r\n#endif\r\nfor (j = 0; j < len; j++){\r\ntmp = rr_read_eeprom_word(rrpriv, segptr);\r\nwritel(sptr, &regs->WinBase);\r\nmb();\r\nwritel(tmp, &regs->WinData);\r\nmb();\r\nsegptr += 4;\r\nsptr += 4;\r\n}\r\n}\r\nout:\r\nwritel(localctrl, &regs->LocalCtrl);\r\nmb();\r\nreturn 0;\r\n}\r\nstatic int rr_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct rr_private *rrpriv;\r\nunsigned char *image, *oldimage;\r\nunsigned long flags;\r\nunsigned int i;\r\nint error = -EOPNOTSUPP;\r\nrrpriv = netdev_priv(dev);\r\nswitch(cmd){\r\ncase SIOCRRGFW:\r\nif (!capable(CAP_SYS_RAWIO)){\r\nreturn -EPERM;\r\n}\r\nimage = kmalloc(EEPROM_WORDS * sizeof(u32), GFP_KERNEL);\r\nif (!image)\r\nreturn -ENOMEM;\r\nif (rrpriv->fw_running){\r\nprintk("%s: Firmware already running\n", dev->name);\r\nerror = -EPERM;\r\ngoto gf_out;\r\n}\r\nspin_lock_irqsave(&rrpriv->lock, flags);\r\ni = rr_read_eeprom(rrpriv, 0, image, EEPROM_BYTES);\r\nspin_unlock_irqrestore(&rrpriv->lock, flags);\r\nif (i != EEPROM_BYTES){\r\nprintk(KERN_ERR "%s: Error reading EEPROM\n",\r\ndev->name);\r\nerror = -EFAULT;\r\ngoto gf_out;\r\n}\r\nerror = copy_to_user(rq->ifr_data, image, EEPROM_BYTES);\r\nif (error)\r\nerror = -EFAULT;\r\ngf_out:\r\nkfree(image);\r\nreturn error;\r\ncase SIOCRRPFW:\r\nif (!capable(CAP_SYS_RAWIO)){\r\nreturn -EPERM;\r\n}\r\nimage = memdup_user(rq->ifr_data, EEPROM_BYTES);\r\nif (IS_ERR(image))\r\nreturn PTR_ERR(image);\r\noldimage = kmalloc(EEPROM_BYTES, GFP_KERNEL);\r\nif (!oldimage) {\r\nkfree(image);\r\nreturn -ENOMEM;\r\n}\r\nif (rrpriv->fw_running){\r\nprintk("%s: Firmware already running\n", dev->name);\r\nerror = -EPERM;\r\ngoto wf_out;\r\n}\r\nprintk("%s: Updating EEPROM firmware\n", dev->name);\r\nspin_lock_irqsave(&rrpriv->lock, flags);\r\nerror = write_eeprom(rrpriv, 0, image, EEPROM_BYTES);\r\nif (error)\r\nprintk(KERN_ERR "%s: Error writing EEPROM\n",\r\ndev->name);\r\ni = rr_read_eeprom(rrpriv, 0, oldimage, EEPROM_BYTES);\r\nspin_unlock_irqrestore(&rrpriv->lock, flags);\r\nif (i != EEPROM_BYTES)\r\nprintk(KERN_ERR "%s: Error reading back EEPROM "\r\n"image\n", dev->name);\r\nerror = memcmp(image, oldimage, EEPROM_BYTES);\r\nif (error){\r\nprintk(KERN_ERR "%s: Error verifying EEPROM image\n",\r\ndev->name);\r\nerror = -EFAULT;\r\n}\r\nwf_out:\r\nkfree(oldimage);\r\nkfree(image);\r\nreturn error;\r\ncase SIOCRRID:\r\nreturn put_user(0x52523032, (int __user *)rq->ifr_data);\r\ndefault:\r\nreturn error;\r\n}\r\n}
