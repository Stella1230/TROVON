static inline void ipip_ecn_decapsulate(struct sk_buff *skb)\r\n{\r\nstruct iphdr *inner_iph = ipip_hdr(skb);\r\nif (INET_ECN_is_ce(XFRM_MODE_SKB_CB(skb)->tos))\r\nIP_ECN_set_ce(inner_iph);\r\n}\r\nstatic int xfrm4_mode_tunnel_output(struct xfrm_state *x, struct sk_buff *skb)\r\n{\r\nstruct dst_entry *dst = skb_dst(skb);\r\nstruct iphdr *top_iph;\r\nint flags;\r\nskb_set_inner_network_header(skb, skb_network_offset(skb));\r\nskb_set_inner_transport_header(skb, skb_transport_offset(skb));\r\nskb_set_network_header(skb, -x->props.header_len);\r\nskb->mac_header = skb->network_header +\r\noffsetof(struct iphdr, protocol);\r\nskb->transport_header = skb->network_header + sizeof(*top_iph);\r\ntop_iph = ip_hdr(skb);\r\ntop_iph->ihl = 5;\r\ntop_iph->version = 4;\r\ntop_iph->protocol = xfrm_af2proto(skb_dst(skb)->ops->family);\r\nif (x->props.extra_flags & XFRM_SA_XFLAG_DONT_ENCAP_DSCP)\r\ntop_iph->tos = 0;\r\nelse\r\ntop_iph->tos = XFRM_MODE_SKB_CB(skb)->tos;\r\ntop_iph->tos = INET_ECN_encapsulate(top_iph->tos,\r\nXFRM_MODE_SKB_CB(skb)->tos);\r\nflags = x->props.flags;\r\nif (flags & XFRM_STATE_NOECN)\r\nIP_ECN_clear(top_iph);\r\ntop_iph->frag_off = (flags & XFRM_STATE_NOPMTUDISC) ?\r\n0 : (XFRM_MODE_SKB_CB(skb)->frag_off & htons(IP_DF));\r\ntop_iph->ttl = ip4_dst_hoplimit(dst->child);\r\ntop_iph->saddr = x->props.saddr.a4;\r\ntop_iph->daddr = x->id.daddr.a4;\r\nip_select_ident(dev_net(dst->dev), skb, NULL);\r\nreturn 0;\r\n}\r\nstatic int xfrm4_mode_tunnel_input(struct xfrm_state *x, struct sk_buff *skb)\r\n{\r\nint err = -EINVAL;\r\nif (XFRM_MODE_SKB_CB(skb)->protocol != IPPROTO_IPIP)\r\ngoto out;\r\nif (!pskb_may_pull(skb, sizeof(struct iphdr)))\r\ngoto out;\r\nerr = skb_unclone(skb, GFP_ATOMIC);\r\nif (err)\r\ngoto out;\r\nif (x->props.flags & XFRM_STATE_DECAP_DSCP)\r\nipv4_copy_dscp(XFRM_MODE_SKB_CB(skb)->tos, ipip_hdr(skb));\r\nif (!(x->props.flags & XFRM_STATE_NOECN))\r\nipip_ecn_decapsulate(skb);\r\nskb_reset_network_header(skb);\r\nskb_mac_header_rebuild(skb);\r\nerr = 0;\r\nout:\r\nreturn err;\r\n}\r\nstatic struct sk_buff *xfrm4_mode_tunnel_gso_segment(struct xfrm_state *x,\r\nstruct sk_buff *skb,\r\nnetdev_features_t features)\r\n{\r\n__skb_push(skb, skb->mac_len);\r\nreturn skb_mac_gso_segment(skb, features);\r\n}\r\nstatic void xfrm4_mode_tunnel_xmit(struct xfrm_state *x, struct sk_buff *skb)\r\n{\r\nstruct xfrm_offload *xo = xfrm_offload(skb);\r\nif (xo->flags & XFRM_GSO_SEGMENT) {\r\nskb->network_header = skb->network_header - x->props.header_len;\r\nskb->transport_header = skb->network_header +\r\nsizeof(struct iphdr);\r\n}\r\nskb_reset_mac_len(skb);\r\npskb_pull(skb, skb->mac_len + x->props.header_len);\r\n}\r\nstatic int __init xfrm4_mode_tunnel_init(void)\r\n{\r\nreturn xfrm_register_mode(&xfrm4_tunnel_mode, AF_INET);\r\n}\r\nstatic void __exit xfrm4_mode_tunnel_exit(void)\r\n{\r\nint err;\r\nerr = xfrm_unregister_mode(&xfrm4_tunnel_mode, AF_INET);\r\nBUG_ON(err);\r\n}
