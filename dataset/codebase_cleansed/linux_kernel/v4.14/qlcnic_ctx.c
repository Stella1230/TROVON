static inline u32 qlcnic_get_cmd_signature(struct qlcnic_hardware_context *ahw)\r\n{\r\nreturn (ahw->pci_func & 0xff) | ((ahw->fw_hal_version & 0xff) << 8) |\r\n(0xcafe << 16);\r\n}\r\nint qlcnic_82xx_alloc_mbx_args(struct qlcnic_cmd_args *mbx,\r\nstruct qlcnic_adapter *adapter, u32 type)\r\n{\r\nint i, size;\r\nconst struct qlcnic_mailbox_metadata *mbx_tbl;\r\nmbx_tbl = qlcnic_mbx_tbl;\r\nsize = ARRAY_SIZE(qlcnic_mbx_tbl);\r\nfor (i = 0; i < size; i++) {\r\nif (type == mbx_tbl[i].cmd) {\r\nmbx->req.num = mbx_tbl[i].in_args;\r\nmbx->rsp.num = mbx_tbl[i].out_args;\r\nmbx->req.arg = kcalloc(mbx->req.num,\r\nsizeof(u32), GFP_ATOMIC);\r\nif (!mbx->req.arg)\r\nreturn -ENOMEM;\r\nmbx->rsp.arg = kcalloc(mbx->rsp.num,\r\nsizeof(u32), GFP_ATOMIC);\r\nif (!mbx->rsp.arg) {\r\nkfree(mbx->req.arg);\r\nmbx->req.arg = NULL;\r\nreturn -ENOMEM;\r\n}\r\nmbx->req.arg[0] = type;\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid qlcnic_free_mbx_args(struct qlcnic_cmd_args *cmd)\r\n{\r\nkfree(cmd->req.arg);\r\ncmd->req.arg = NULL;\r\nkfree(cmd->rsp.arg);\r\ncmd->rsp.arg = NULL;\r\n}\r\nstatic u32\r\nqlcnic_poll_rsp(struct qlcnic_adapter *adapter)\r\n{\r\nu32 rsp;\r\nint timeout = 0, err = 0;\r\ndo {\r\nmdelay(1);\r\nif (++timeout > QLCNIC_OS_CRB_RETRY_COUNT)\r\nreturn QLCNIC_CDRP_RSP_TIMEOUT;\r\nrsp = QLCRD32(adapter, QLCNIC_CDRP_CRB_OFFSET, &err);\r\n} while (!QLCNIC_CDRP_IS_RSP(rsp));\r\nreturn rsp;\r\n}\r\nint qlcnic_82xx_issue_cmd(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_cmd_args *cmd)\r\n{\r\nint i, err = 0;\r\nu32 rsp;\r\nu32 signature;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nconst char *fmt;\r\nsignature = qlcnic_get_cmd_signature(ahw);\r\nif (qlcnic_api_lock(adapter)) {\r\ncmd->rsp.arg[0] = QLCNIC_RCODE_TIMEOUT;\r\nreturn cmd->rsp.arg[0];\r\n}\r\nQLCWR32(adapter, QLCNIC_SIGN_CRB_OFFSET, signature);\r\nfor (i = 1; i < cmd->req.num; i++)\r\nQLCWR32(adapter, QLCNIC_CDRP_ARG(i), cmd->req.arg[i]);\r\nQLCWR32(adapter, QLCNIC_CDRP_CRB_OFFSET,\r\nQLCNIC_CDRP_FORM_CMD(cmd->req.arg[0]));\r\nrsp = qlcnic_poll_rsp(adapter);\r\nif (rsp == QLCNIC_CDRP_RSP_TIMEOUT) {\r\ndev_err(&pdev->dev, "command timeout, response = 0x%x\n", rsp);\r\ncmd->rsp.arg[0] = QLCNIC_RCODE_TIMEOUT;\r\n} else if (rsp == QLCNIC_CDRP_RSP_FAIL) {\r\ncmd->rsp.arg[0] = QLCRD32(adapter, QLCNIC_CDRP_ARG(1), &err);\r\nswitch (cmd->rsp.arg[0]) {\r\ncase QLCNIC_RCODE_INVALID_ARGS:\r\nfmt = "CDRP invalid args: [%d]\n";\r\nbreak;\r\ncase QLCNIC_RCODE_NOT_SUPPORTED:\r\ncase QLCNIC_RCODE_NOT_IMPL:\r\nfmt = "CDRP command not supported: [%d]\n";\r\nbreak;\r\ncase QLCNIC_RCODE_NOT_PERMITTED:\r\nfmt = "CDRP requested action not permitted: [%d]\n";\r\nbreak;\r\ncase QLCNIC_RCODE_INVALID:\r\nfmt = "CDRP invalid or unknown cmd received: [%d]\n";\r\nbreak;\r\ncase QLCNIC_RCODE_TIMEOUT:\r\nfmt = "CDRP command timeout: [%d]\n";\r\nbreak;\r\ndefault:\r\nfmt = "CDRP command failed: [%d]\n";\r\nbreak;\r\n}\r\ndev_err(&pdev->dev, fmt, cmd->rsp.arg[0]);\r\nqlcnic_dump_mbx(adapter, cmd);\r\n} else if (rsp == QLCNIC_CDRP_RSP_OK)\r\ncmd->rsp.arg[0] = QLCNIC_RCODE_SUCCESS;\r\nfor (i = 1; i < cmd->rsp.num; i++)\r\ncmd->rsp.arg[i] = QLCRD32(adapter, QLCNIC_CDRP_ARG(i), &err);\r\nqlcnic_api_unlock(adapter);\r\nreturn cmd->rsp.arg[0];\r\n}\r\nint qlcnic_fw_cmd_set_drv_version(struct qlcnic_adapter *adapter, u32 fw_cmd)\r\n{\r\nstruct qlcnic_cmd_args cmd;\r\nu32 arg1, arg2, arg3;\r\nchar drv_string[12];\r\nint err = 0;\r\nmemset(drv_string, 0, sizeof(drv_string));\r\nsnprintf(drv_string, sizeof(drv_string), "%d"".""%d"".""%d",\r\n_QLCNIC_LINUX_MAJOR, _QLCNIC_LINUX_MINOR,\r\n_QLCNIC_LINUX_SUBVERSION);\r\nerr = qlcnic_alloc_mbx_args(&cmd, adapter, fw_cmd);\r\nif (err)\r\nreturn err;\r\nmemcpy(&arg1, drv_string, sizeof(u32));\r\nmemcpy(&arg2, drv_string + 4, sizeof(u32));\r\nmemcpy(&arg3, drv_string + 8, sizeof(u32));\r\ncmd.req.arg[1] = arg1;\r\ncmd.req.arg[2] = arg2;\r\ncmd.req.arg[3] = arg3;\r\nerr = qlcnic_issue_cmd(adapter, &cmd);\r\nif (err) {\r\ndev_info(&adapter->pdev->dev,\r\n"Failed to set driver version in firmware\n");\r\nerr = -EIO;\r\n}\r\nqlcnic_free_mbx_args(&cmd);\r\nreturn err;\r\n}\r\nint\r\nqlcnic_fw_cmd_set_mtu(struct qlcnic_adapter *adapter, int mtu)\r\n{\r\nint err = 0;\r\nstruct qlcnic_cmd_args cmd;\r\nstruct qlcnic_recv_context *recv_ctx = adapter->recv_ctx;\r\nif (recv_ctx->state != QLCNIC_HOST_CTX_STATE_ACTIVE)\r\nreturn err;\r\nerr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_SET_MTU);\r\nif (err)\r\nreturn err;\r\ncmd.req.arg[1] = recv_ctx->context_id;\r\ncmd.req.arg[2] = mtu;\r\nerr = qlcnic_issue_cmd(adapter, &cmd);\r\nif (err) {\r\ndev_err(&adapter->pdev->dev, "Failed to set mtu\n");\r\nerr = -EIO;\r\n}\r\nqlcnic_free_mbx_args(&cmd);\r\nreturn err;\r\n}\r\nint qlcnic_82xx_fw_cmd_create_rx_ctx(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_recv_context *recv_ctx = adapter->recv_ctx;\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\ndma_addr_t hostrq_phys_addr, cardrsp_phys_addr;\r\nstruct net_device *netdev = adapter->netdev;\r\nu32 temp_intr_crb_mode, temp_rds_crb_mode;\r\nstruct qlcnic_cardrsp_rds_ring *prsp_rds;\r\nstruct qlcnic_cardrsp_sds_ring *prsp_sds;\r\nstruct qlcnic_hostrq_rds_ring *prq_rds;\r\nstruct qlcnic_hostrq_sds_ring *prq_sds;\r\nstruct qlcnic_host_rds_ring *rds_ring;\r\nstruct qlcnic_host_sds_ring *sds_ring;\r\nstruct qlcnic_cardrsp_rx_ctx *prsp;\r\nstruct qlcnic_hostrq_rx_ctx *prq;\r\nu8 i, nrds_rings, nsds_rings;\r\nstruct qlcnic_cmd_args cmd;\r\nsize_t rq_size, rsp_size;\r\nu32 cap, reg, val, reg2;\r\nu64 phys_addr;\r\nu16 temp_u16;\r\nvoid *addr;\r\nint err;\r\nnrds_rings = adapter->max_rds_rings;\r\nnsds_rings = adapter->drv_sds_rings;\r\nrq_size = SIZEOF_HOSTRQ_RX(struct qlcnic_hostrq_rx_ctx, nrds_rings,\r\nnsds_rings);\r\nrsp_size = SIZEOF_CARDRSP_RX(struct qlcnic_cardrsp_rx_ctx, nrds_rings,\r\nnsds_rings);\r\naddr = dma_alloc_coherent(&adapter->pdev->dev, rq_size,\r\n&hostrq_phys_addr, GFP_KERNEL);\r\nif (addr == NULL)\r\nreturn -ENOMEM;\r\nprq = addr;\r\naddr = dma_alloc_coherent(&adapter->pdev->dev, rsp_size,\r\n&cardrsp_phys_addr, GFP_KERNEL);\r\nif (addr == NULL) {\r\nerr = -ENOMEM;\r\ngoto out_free_rq;\r\n}\r\nprsp = addr;\r\nprq->host_rsp_dma_addr = cpu_to_le64(cardrsp_phys_addr);\r\ncap = (QLCNIC_CAP0_LEGACY_CONTEXT | QLCNIC_CAP0_LEGACY_MN\r\n| QLCNIC_CAP0_VALIDOFF);\r\ncap |= (QLCNIC_CAP0_JUMBO_CONTIGUOUS | QLCNIC_CAP0_LRO_CONTIGUOUS);\r\nif (qlcnic_check_multi_tx(adapter) &&\r\n!adapter->ahw->diag_test) {\r\ncap |= QLCNIC_CAP0_TX_MULTI;\r\n} else {\r\ntemp_u16 = offsetof(struct qlcnic_hostrq_rx_ctx, msix_handler);\r\nprq->valid_field_offset = cpu_to_le16(temp_u16);\r\nprq->txrx_sds_binding = nsds_rings - 1;\r\ntemp_intr_crb_mode = QLCNIC_HOST_INT_CRB_MODE_SHARED;\r\nprq->host_int_crb_mode = cpu_to_le32(temp_intr_crb_mode);\r\ntemp_rds_crb_mode = QLCNIC_HOST_RDS_CRB_MODE_UNIQUE;\r\nprq->host_rds_crb_mode = cpu_to_le32(temp_rds_crb_mode);\r\n}\r\nprq->capabilities[0] = cpu_to_le32(cap);\r\nprq->num_rds_rings = cpu_to_le16(nrds_rings);\r\nprq->num_sds_rings = cpu_to_le16(nsds_rings);\r\nprq->rds_ring_offset = 0;\r\nval = le32_to_cpu(prq->rds_ring_offset) +\r\n(sizeof(struct qlcnic_hostrq_rds_ring) * nrds_rings);\r\nprq->sds_ring_offset = cpu_to_le32(val);\r\nprq_rds = (struct qlcnic_hostrq_rds_ring *)(prq->data +\r\nle32_to_cpu(prq->rds_ring_offset));\r\nfor (i = 0; i < nrds_rings; i++) {\r\nrds_ring = &recv_ctx->rds_rings[i];\r\nrds_ring->producer = 0;\r\nprq_rds[i].host_phys_addr = cpu_to_le64(rds_ring->phys_addr);\r\nprq_rds[i].ring_size = cpu_to_le32(rds_ring->num_desc);\r\nprq_rds[i].ring_kind = cpu_to_le32(i);\r\nprq_rds[i].buff_size = cpu_to_le64(rds_ring->dma_size);\r\n}\r\nprq_sds = (struct qlcnic_hostrq_sds_ring *)(prq->data +\r\nle32_to_cpu(prq->sds_ring_offset));\r\nfor (i = 0; i < nsds_rings; i++) {\r\nsds_ring = &recv_ctx->sds_rings[i];\r\nsds_ring->consumer = 0;\r\nmemset(sds_ring->desc_head, 0, STATUS_DESC_RINGSIZE(sds_ring));\r\nprq_sds[i].host_phys_addr = cpu_to_le64(sds_ring->phys_addr);\r\nprq_sds[i].ring_size = cpu_to_le32(sds_ring->num_desc);\r\nif (qlcnic_check_multi_tx(adapter) &&\r\n!adapter->ahw->diag_test)\r\nprq_sds[i].msi_index = cpu_to_le16(ahw->intr_tbl[i].id);\r\nelse\r\nprq_sds[i].msi_index = cpu_to_le16(i);\r\n}\r\nphys_addr = hostrq_phys_addr;\r\nerr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_CREATE_RX_CTX);\r\nif (err)\r\ngoto out_free_rsp;\r\ncmd.req.arg[1] = MSD(phys_addr);\r\ncmd.req.arg[2] = LSD(phys_addr);\r\ncmd.req.arg[3] = rq_size;\r\nerr = qlcnic_issue_cmd(adapter, &cmd);\r\nif (err) {\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to create rx ctx in firmware%d\n", err);\r\ngoto out_free_rsp;\r\n}\r\nprsp_rds = ((struct qlcnic_cardrsp_rds_ring *)\r\n&prsp->data[le32_to_cpu(prsp->rds_ring_offset)]);\r\nfor (i = 0; i < le16_to_cpu(prsp->num_rds_rings); i++) {\r\nrds_ring = &recv_ctx->rds_rings[i];\r\nreg = le32_to_cpu(prsp_rds[i].host_producer_crb);\r\nrds_ring->crb_rcv_producer = ahw->pci_base0 + reg;\r\n}\r\nprsp_sds = ((struct qlcnic_cardrsp_sds_ring *)\r\n&prsp->data[le32_to_cpu(prsp->sds_ring_offset)]);\r\nfor (i = 0; i < le16_to_cpu(prsp->num_sds_rings); i++) {\r\nsds_ring = &recv_ctx->sds_rings[i];\r\nreg = le32_to_cpu(prsp_sds[i].host_consumer_crb);\r\nif (qlcnic_check_multi_tx(adapter) && !adapter->ahw->diag_test)\r\nreg2 = ahw->intr_tbl[i].src;\r\nelse\r\nreg2 = le32_to_cpu(prsp_sds[i].interrupt_crb);\r\nsds_ring->crb_intr_mask = ahw->pci_base0 + reg2;\r\nsds_ring->crb_sts_consumer = ahw->pci_base0 + reg;\r\n}\r\nrecv_ctx->state = le32_to_cpu(prsp->host_ctx_state);\r\nrecv_ctx->context_id = le16_to_cpu(prsp->context_id);\r\nrecv_ctx->virt_port = prsp->virt_port;\r\nnetdev_info(netdev, "Rx Context[%d] Created, state 0x%x\n",\r\nrecv_ctx->context_id, recv_ctx->state);\r\nqlcnic_free_mbx_args(&cmd);\r\nout_free_rsp:\r\ndma_free_coherent(&adapter->pdev->dev, rsp_size, prsp,\r\ncardrsp_phys_addr);\r\nout_free_rq:\r\ndma_free_coherent(&adapter->pdev->dev, rq_size, prq, hostrq_phys_addr);\r\nreturn err;\r\n}\r\nvoid qlcnic_82xx_fw_cmd_del_rx_ctx(struct qlcnic_adapter *adapter)\r\n{\r\nint err;\r\nstruct qlcnic_cmd_args cmd;\r\nstruct qlcnic_recv_context *recv_ctx = adapter->recv_ctx;\r\nerr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_DESTROY_RX_CTX);\r\nif (err)\r\nreturn;\r\ncmd.req.arg[1] = recv_ctx->context_id;\r\nerr = qlcnic_issue_cmd(adapter, &cmd);\r\nif (err)\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to destroy rx ctx in firmware\n");\r\nrecv_ctx->state = QLCNIC_HOST_CTX_STATE_FREED;\r\nqlcnic_free_mbx_args(&cmd);\r\n}\r\nint qlcnic_82xx_fw_cmd_create_tx_ctx(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_host_tx_ring *tx_ring,\r\nint ring)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nstruct net_device *netdev = adapter->netdev;\r\nstruct qlcnic_hostrq_tx_ctx *prq;\r\nstruct qlcnic_hostrq_cds_ring *prq_cds;\r\nstruct qlcnic_cardrsp_tx_ctx *prsp;\r\nstruct qlcnic_cmd_args cmd;\r\nu32 temp, intr_mask, temp_int_crb_mode;\r\ndma_addr_t rq_phys_addr, rsp_phys_addr;\r\nint temp_nsds_rings, index, err;\r\nvoid *rq_addr, *rsp_addr;\r\nsize_t rq_size, rsp_size;\r\nu64 phys_addr;\r\nu16 msix_id;\r\n/* reset host resources */\r\ntx_ring->producer = 0;\r\ntx_ring->sw_consumer = 0;\r\n*(tx_ring->hw_consumer) = 0;\r\nrq_size = SIZEOF_HOSTRQ_TX(struct qlcnic_hostrq_tx_ctx);\r\nrq_addr = dma_zalloc_coherent(&adapter->pdev->dev, rq_size,\r\n&rq_phys_addr, GFP_KERNEL);\r\nif (!rq_addr)\r\nreturn -ENOMEM;\r\nrsp_size = SIZEOF_CARDRSP_TX(struct qlcnic_cardrsp_tx_ctx);\r\nrsp_addr = dma_zalloc_coherent(&adapter->pdev->dev, rsp_size,\r\n&rsp_phys_addr, GFP_KERNEL);\r\nif (!rsp_addr) {\r\nerr = -ENOMEM;\r\ngoto out_free_rq;\r\n}\r\nprq = rq_addr;\r\nprsp = rsp_addr;\r\nprq->host_rsp_dma_addr = cpu_to_le64(rsp_phys_addr);\r\ntemp = (QLCNIC_CAP0_LEGACY_CONTEXT | QLCNIC_CAP0_LEGACY_MN |\r\nQLCNIC_CAP0_LSO);\r\nif (qlcnic_check_multi_tx(adapter) && !adapter->ahw->diag_test)\r\ntemp |= QLCNIC_CAP0_TX_MULTI;\r\nprq->capabilities[0] = cpu_to_le32(temp);\r\nif (qlcnic_check_multi_tx(adapter) &&\r\n!adapter->ahw->diag_test) {\r\ntemp_nsds_rings = adapter->drv_sds_rings;\r\nindex = temp_nsds_rings + ring;\r\nmsix_id = ahw->intr_tbl[index].id;\r\nprq->msi_index = cpu_to_le16(msix_id);\r\n} else {\r\ntemp_int_crb_mode = QLCNIC_HOST_INT_CRB_MODE_SHARED;\r\nprq->host_int_crb_mode = cpu_to_le32(temp_int_crb_mode);\r\nprq->msi_index = 0;\r\n}\r\nprq->interrupt_ctl = 0;\r\nprq->cmd_cons_dma_addr = cpu_to_le64(tx_ring->hw_cons_phys_addr);\r\nprq_cds = &prq->cds_ring;\r\nprq_cds->host_phys_addr = cpu_to_le64(tx_ring->phys_addr);\r\nprq_cds->ring_size = cpu_to_le32(tx_ring->num_desc);\r\nphys_addr = rq_phys_addr;\r\nerr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_CREATE_TX_CTX);\r\nif (err)\r\ngoto out_free_rsp;\r\ncmd.req.arg[1] = MSD(phys_addr);\r\ncmd.req.arg[2] = LSD(phys_addr);\r\ncmd.req.arg[3] = rq_size;\r\nerr = qlcnic_issue_cmd(adapter, &cmd);\r\nif (err == QLCNIC_RCODE_SUCCESS) {\r\ntx_ring->state = le32_to_cpu(prsp->host_ctx_state);\r\ntemp = le32_to_cpu(prsp->cds_ring.host_producer_crb);\r\ntx_ring->crb_cmd_producer = adapter->ahw->pci_base0 + temp;\r\ntx_ring->ctx_id = le16_to_cpu(prsp->context_id);\r\nif (qlcnic_check_multi_tx(adapter) &&\r\n!adapter->ahw->diag_test &&\r\n(adapter->flags & QLCNIC_MSIX_ENABLED)) {\r\nindex = adapter->drv_sds_rings + ring;\r\nintr_mask = ahw->intr_tbl[index].src;\r\ntx_ring->crb_intr_mask = ahw->pci_base0 + intr_mask;\r\n}\r\nnetdev_info(netdev, "Tx Context[0x%x] Created, state 0x%x\n",\r\ntx_ring->ctx_id, tx_ring->state);\r\n} else {\r\nnetdev_err(netdev, "Failed to create tx ctx in firmware%d\n",\r\nerr);\r\nerr = -EIO;\r\n}\r\nqlcnic_free_mbx_args(&cmd);\r\nout_free_rsp:\r\ndma_free_coherent(&adapter->pdev->dev, rsp_size, rsp_addr,\r\nrsp_phys_addr);\r\nout_free_rq:\r\ndma_free_coherent(&adapter->pdev->dev, rq_size, rq_addr, rq_phys_addr);\r\nreturn err;\r\n}\r\nvoid qlcnic_82xx_fw_cmd_del_tx_ctx(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_host_tx_ring *tx_ring)\r\n{\r\nstruct qlcnic_cmd_args cmd;\r\nint ret;\r\nret = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_DESTROY_TX_CTX);\r\nif (ret)\r\nreturn;\r\ncmd.req.arg[1] = tx_ring->ctx_id;\r\nif (qlcnic_issue_cmd(adapter, &cmd))\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to destroy tx ctx in firmware\n");\r\nqlcnic_free_mbx_args(&cmd);\r\n}\r\nint\r\nqlcnic_fw_cmd_set_port(struct qlcnic_adapter *adapter, u32 config)\r\n{\r\nint err;\r\nstruct qlcnic_cmd_args cmd;\r\nerr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_CONFIG_PORT);\r\nif (err)\r\nreturn err;\r\ncmd.req.arg[1] = config;\r\nerr = qlcnic_issue_cmd(adapter, &cmd);\r\nqlcnic_free_mbx_args(&cmd);\r\nreturn err;\r\n}\r\nint qlcnic_alloc_hw_resources(struct qlcnic_adapter *adapter)\r\n{\r\nvoid *addr;\r\nint err, ring;\r\nstruct qlcnic_recv_context *recv_ctx;\r\nstruct qlcnic_host_rds_ring *rds_ring;\r\nstruct qlcnic_host_sds_ring *sds_ring;\r\nstruct qlcnic_host_tx_ring *tx_ring;\r\n__le32 *ptr;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nrecv_ctx = adapter->recv_ctx;\r\nfor (ring = 0; ring < adapter->drv_tx_rings; ring++) {\r\ntx_ring = &adapter->tx_ring[ring];\r\nptr = (__le32 *)dma_alloc_coherent(&pdev->dev, sizeof(u32),\r\n&tx_ring->hw_cons_phys_addr,\r\nGFP_KERNEL);\r\nif (ptr == NULL) {\r\nerr = -ENOMEM;\r\ngoto err_out_free;\r\n}\r\ntx_ring->hw_consumer = ptr;\r\n/* cmd desc ring */\r\naddr = dma_alloc_coherent(&pdev->dev, TX_DESC_RINGSIZE(tx_ring),\r\n&tx_ring->phys_addr,\r\nGFP_KERNEL);\r\nif (addr == NULL) {\r\nerr = -ENOMEM;\r\ngoto err_out_free;\r\n}\r\ntx_ring->desc_head = addr;\r\n}\r\nfor (ring = 0; ring < adapter->max_rds_rings; ring++) {\r\nrds_ring = &recv_ctx->rds_rings[ring];\r\naddr = dma_alloc_coherent(&adapter->pdev->dev,\r\nRCV_DESC_RINGSIZE(rds_ring),\r\n&rds_ring->phys_addr, GFP_KERNEL);\r\nif (addr == NULL) {\r\nerr = -ENOMEM;\r\ngoto err_out_free;\r\n}\r\nrds_ring->desc_head = addr;\r\n}\r\nfor (ring = 0; ring < adapter->drv_sds_rings; ring++) {\r\nsds_ring = &recv_ctx->sds_rings[ring];\r\naddr = dma_alloc_coherent(&adapter->pdev->dev,\r\nSTATUS_DESC_RINGSIZE(sds_ring),\r\n&sds_ring->phys_addr, GFP_KERNEL);\r\nif (addr == NULL) {\r\nerr = -ENOMEM;\r\ngoto err_out_free;\r\n}\r\nsds_ring->desc_head = addr;\r\n}\r\nreturn 0;\r\nerr_out_free:\r\nqlcnic_free_hw_resources(adapter);\r\nreturn err;\r\n}\r\nint qlcnic_fw_create_ctx(struct qlcnic_adapter *dev)\r\n{\r\nint i, err, ring;\r\nif (dev->flags & QLCNIC_NEED_FLR) {\r\npci_reset_function(dev->pdev);\r\ndev->flags &= ~QLCNIC_NEED_FLR;\r\n}\r\nif (qlcnic_83xx_check(dev) && (dev->flags & QLCNIC_MSIX_ENABLED)) {\r\nif (dev->ahw->diag_test != QLCNIC_LOOPBACK_TEST) {\r\nerr = qlcnic_83xx_config_intrpt(dev, 1);\r\nif (err)\r\nreturn err;\r\n}\r\n}\r\nif (qlcnic_82xx_check(dev) && (dev->flags & QLCNIC_MSIX_ENABLED) &&\r\nqlcnic_check_multi_tx(dev) && !dev->ahw->diag_test) {\r\nerr = qlcnic_82xx_mq_intrpt(dev, 1);\r\nif (err)\r\nreturn err;\r\n}\r\nerr = qlcnic_fw_cmd_create_rx_ctx(dev);\r\nif (err)\r\ngoto err_out;\r\nfor (ring = 0; ring < dev->drv_tx_rings; ring++) {\r\nerr = qlcnic_fw_cmd_create_tx_ctx(dev,\r\n&dev->tx_ring[ring],\r\nring);\r\nif (err) {\r\nqlcnic_fw_cmd_del_rx_ctx(dev);\r\nif (ring == 0)\r\ngoto err_out;\r\nfor (i = 0; i < ring; i++)\r\nqlcnic_fw_cmd_del_tx_ctx(dev, &dev->tx_ring[i]);\r\ngoto err_out;\r\n}\r\n}\r\nset_bit(__QLCNIC_FW_ATTACHED, &dev->state);\r\nreturn 0;\r\nerr_out:\r\nif (qlcnic_82xx_check(dev) && (dev->flags & QLCNIC_MSIX_ENABLED) &&\r\nqlcnic_check_multi_tx(dev) && !dev->ahw->diag_test)\r\nqlcnic_82xx_config_intrpt(dev, 0);\r\nif (qlcnic_83xx_check(dev) && (dev->flags & QLCNIC_MSIX_ENABLED)) {\r\nif (dev->ahw->diag_test != QLCNIC_LOOPBACK_TEST)\r\nqlcnic_83xx_config_intrpt(dev, 0);\r\n}\r\nreturn err;\r\n}\r\nvoid qlcnic_fw_destroy_ctx(struct qlcnic_adapter *adapter)\r\n{\r\nint ring;\r\nif (test_and_clear_bit(__QLCNIC_FW_ATTACHED, &adapter->state)) {\r\nqlcnic_fw_cmd_del_rx_ctx(adapter);\r\nfor (ring = 0; ring < adapter->drv_tx_rings; ring++)\r\nqlcnic_fw_cmd_del_tx_ctx(adapter,\r\n&adapter->tx_ring[ring]);\r\nif (qlcnic_82xx_check(adapter) &&\r\n(adapter->flags & QLCNIC_MSIX_ENABLED) &&\r\nqlcnic_check_multi_tx(adapter) &&\r\n!adapter->ahw->diag_test)\r\nqlcnic_82xx_config_intrpt(adapter, 0);\r\nif (qlcnic_83xx_check(adapter) &&\r\n(adapter->flags & QLCNIC_MSIX_ENABLED)) {\r\nif (adapter->ahw->diag_test != QLCNIC_LOOPBACK_TEST)\r\nqlcnic_83xx_config_intrpt(adapter, 0);\r\n}\r\n/* Allow dma queues to drain after context reset */\r\nmdelay(20);\r\n}\r\n}\r\nvoid qlcnic_free_hw_resources(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_recv_context *recv_ctx;\r\nstruct qlcnic_host_rds_ring *rds_ring;\r\nstruct qlcnic_host_sds_ring *sds_ring;\r\nstruct qlcnic_host_tx_ring *tx_ring;\r\nint ring;\r\nrecv_ctx = adapter->recv_ctx;\r\nfor (ring = 0; ring < adapter->drv_tx_rings; ring++) {\r\ntx_ring = &adapter->tx_ring[ring];\r\nif (tx_ring->hw_consumer != NULL) {\r\ndma_free_coherent(&adapter->pdev->dev, sizeof(u32),\r\ntx_ring->hw_consumer,\r\ntx_ring->hw_cons_phys_addr);\r\ntx_ring->hw_consumer = NULL;\r\n}\r\nif (tx_ring->desc_head != NULL) {\r\ndma_free_coherent(&adapter->pdev->dev,\r\nTX_DESC_RINGSIZE(tx_ring),\r\ntx_ring->desc_head,\r\ntx_ring->phys_addr);\r\ntx_ring->desc_head = NULL;\r\n}\r\n}\r\nfor (ring = 0; ring < adapter->max_rds_rings; ring++) {\r\nrds_ring = &recv_ctx->rds_rings[ring];\r\nif (rds_ring->desc_head != NULL) {\r\ndma_free_coherent(&adapter->pdev->dev,\r\nRCV_DESC_RINGSIZE(rds_ring),\r\nrds_ring->desc_head,\r\nrds_ring->phys_addr);\r\nrds_ring->desc_head = NULL;\r\n}\r\n}\r\nfor (ring = 0; ring < adapter->drv_sds_rings; ring++) {\r\nsds_ring = &recv_ctx->sds_rings[ring];\r\nif (sds_ring->desc_head != NULL) {\r\ndma_free_coherent(&adapter->pdev->dev,\r\nSTATUS_DESC_RINGSIZE(sds_ring),\r\nsds_ring->desc_head,\r\nsds_ring->phys_addr);\r\nsds_ring->desc_head = NULL;\r\n}\r\n}\r\n}\r\nint qlcnic_82xx_config_intrpt(struct qlcnic_adapter *adapter, u8 op_type)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nstruct net_device *netdev = adapter->netdev;\r\nstruct qlcnic_cmd_args cmd;\r\nu32 type, val;\r\nint i, err = 0;\r\nfor (i = 0; i < ahw->num_msix; i++) {\r\nerr = qlcnic_alloc_mbx_args(&cmd, adapter,\r\nQLCNIC_CMD_MQ_TX_CONFIG_INTR);\r\nif (err)\r\nreturn err;\r\ntype = op_type ? QLCNIC_INTRPT_ADD : QLCNIC_INTRPT_DEL;\r\nval = type | (ahw->intr_tbl[i].type << 4);\r\nif (ahw->intr_tbl[i].type == QLCNIC_INTRPT_MSIX)\r\nval |= (ahw->intr_tbl[i].id << 16);\r\ncmd.req.arg[1] = val;\r\nerr = qlcnic_issue_cmd(adapter, &cmd);\r\nif (err) {\r\nnetdev_err(netdev, "Failed to %s interrupts %d\n",\r\nop_type == QLCNIC_INTRPT_ADD ? "Add" :\r\n"Delete", err);\r\nqlcnic_free_mbx_args(&cmd);\r\nreturn err;\r\n}\r\nval = cmd.rsp.arg[1];\r\nif (LSB(val)) {\r\nnetdev_info(netdev,\r\n"failed to configure interrupt for %d\n",\r\nahw->intr_tbl[i].id);\r\ncontinue;\r\n}\r\nif (op_type) {\r\nahw->intr_tbl[i].id = MSW(val);\r\nahw->intr_tbl[i].enabled = 1;\r\nahw->intr_tbl[i].src = cmd.rsp.arg[2];\r\n} else {\r\nahw->intr_tbl[i].id = i;\r\nahw->intr_tbl[i].enabled = 0;\r\nahw->intr_tbl[i].src = 0;\r\n}\r\nqlcnic_free_mbx_args(&cmd);\r\n}\r\nreturn err;\r\n}\r\nint qlcnic_82xx_get_mac_address(struct qlcnic_adapter *adapter, u8 *mac,\r\nu8 function)\r\n{\r\nint err, i;\r\nstruct qlcnic_cmd_args cmd;\r\nu32 mac_low, mac_high;\r\nerr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_MAC_ADDRESS);\r\nif (err)\r\nreturn err;\r\ncmd.req.arg[1] = function | BIT_8;\r\nerr = qlcnic_issue_cmd(adapter, &cmd);\r\nif (err == QLCNIC_RCODE_SUCCESS) {\r\nmac_low = cmd.rsp.arg[1];\r\nmac_high = cmd.rsp.arg[2];\r\nfor (i = 0; i < 2; i++)\r\nmac[i] = (u8) (mac_high >> ((1 - i) * 8));\r\nfor (i = 2; i < 6; i++)\r\nmac[i] = (u8) (mac_low >> ((5 - i) * 8));\r\n} else {\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to get mac address%d\n", err);\r\nerr = -EIO;\r\n}\r\nqlcnic_free_mbx_args(&cmd);\r\nreturn err;\r\n}\r\n/* Get info of a NIC partition */\r\nint qlcnic_82xx_get_nic_info(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_info *npar_info, u8 func_id)\r\n{\r\nint err;\r\ndma_addr_t nic_dma_t;\r\nconst struct qlcnic_info_le *nic_info;\r\nvoid *nic_info_addr;\r\nstruct qlcnic_cmd_args cmd;\r\nsize_t nic_size = sizeof(struct qlcnic_info_le);\r\nnic_info_addr = dma_zalloc_coherent(&adapter->pdev->dev, nic_size,\r\n&nic_dma_t, GFP_KERNEL);\r\nif (!nic_info_addr)\r\nreturn -ENOMEM;\r\nnic_info = nic_info_addr;\r\nerr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_GET_NIC_INFO);\r\nif (err)\r\ngoto out_free_dma;\r\ncmd.req.arg[1] = MSD(nic_dma_t);\r\ncmd.req.arg[2] = LSD(nic_dma_t);\r\ncmd.req.arg[3] = (func_id << 16 | nic_size);\r\nerr = qlcnic_issue_cmd(adapter, &cmd);\r\nif (err != QLCNIC_RCODE_SUCCESS) {\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to get nic info%d\n", err);\r\nerr = -EIO;\r\n} else {\r\nnpar_info->pci_func = le16_to_cpu(nic_info->pci_func);\r\nnpar_info->op_mode = le16_to_cpu(nic_info->op_mode);\r\nnpar_info->min_tx_bw = le16_to_cpu(nic_info->min_tx_bw);\r\nnpar_info->max_tx_bw = le16_to_cpu(nic_info->max_tx_bw);\r\nnpar_info->phys_port = le16_to_cpu(nic_info->phys_port);\r\nnpar_info->switch_mode = le16_to_cpu(nic_info->switch_mode);\r\nnpar_info->max_tx_ques = le16_to_cpu(nic_info->max_tx_ques);\r\nnpar_info->max_rx_ques = le16_to_cpu(nic_info->max_rx_ques);\r\nnpar_info->capabilities = le32_to_cpu(nic_info->capabilities);\r\nnpar_info->max_mtu = le16_to_cpu(nic_info->max_mtu);\r\n}\r\nqlcnic_free_mbx_args(&cmd);\r\nout_free_dma:\r\ndma_free_coherent(&adapter->pdev->dev, nic_size, nic_info_addr,\r\nnic_dma_t);\r\nreturn err;\r\n}\r\n/* Configure a NIC partition */\r\nint qlcnic_82xx_set_nic_info(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_info *nic)\r\n{\r\nint err = -EIO;\r\ndma_addr_t nic_dma_t;\r\nvoid *nic_info_addr;\r\nstruct qlcnic_cmd_args cmd;\r\nstruct qlcnic_info_le *nic_info;\r\nsize_t nic_size = sizeof(struct qlcnic_info_le);\r\nif (adapter->ahw->op_mode != QLCNIC_MGMT_FUNC)\r\nreturn err;\r\nnic_info_addr = dma_zalloc_coherent(&adapter->pdev->dev, nic_size,\r\n&nic_dma_t, GFP_KERNEL);\r\nif (!nic_info_addr)\r\nreturn -ENOMEM;\r\nnic_info = nic_info_addr;\r\nnic_info->pci_func = cpu_to_le16(nic->pci_func);\r\nnic_info->op_mode = cpu_to_le16(nic->op_mode);\r\nnic_info->phys_port = cpu_to_le16(nic->phys_port);\r\nnic_info->switch_mode = cpu_to_le16(nic->switch_mode);\r\nnic_info->capabilities = cpu_to_le32(nic->capabilities);\r\nnic_info->max_mac_filters = nic->max_mac_filters;\r\nnic_info->max_tx_ques = cpu_to_le16(nic->max_tx_ques);\r\nnic_info->max_rx_ques = cpu_to_le16(nic->max_rx_ques);\r\nnic_info->min_tx_bw = cpu_to_le16(nic->min_tx_bw);\r\nnic_info->max_tx_bw = cpu_to_le16(nic->max_tx_bw);\r\nerr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_SET_NIC_INFO);\r\nif (err)\r\ngoto out_free_dma;\r\ncmd.req.arg[1] = MSD(nic_dma_t);\r\ncmd.req.arg[2] = LSD(nic_dma_t);\r\ncmd.req.arg[3] = ((nic->pci_func << 16) | nic_size);\r\nerr = qlcnic_issue_cmd(adapter, &cmd);\r\nif (err != QLCNIC_RCODE_SUCCESS) {\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to set nic info%d\n", err);\r\nerr = -EIO;\r\n}\r\nqlcnic_free_mbx_args(&cmd);\r\nout_free_dma:\r\ndma_free_coherent(&adapter->pdev->dev, nic_size, nic_info_addr,\r\nnic_dma_t);\r\nreturn err;\r\n}\r\n/* Get PCI Info of a partition */\r\nint qlcnic_82xx_get_pci_info(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_pci_info *pci_info)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nsize_t npar_size = sizeof(struct qlcnic_pci_info_le);\r\nsize_t pci_size = npar_size * ahw->max_vnic_func;\r\nu16 nic = 0, fcoe = 0, iscsi = 0;\r\nstruct qlcnic_pci_info_le *npar;\r\nstruct qlcnic_cmd_args cmd;\r\ndma_addr_t pci_info_dma_t;\r\nvoid *pci_info_addr;\r\nint err = 0, i;\r\npci_info_addr = dma_zalloc_coherent(&adapter->pdev->dev, pci_size,\r\n&pci_info_dma_t, GFP_KERNEL);\r\nif (!pci_info_addr)\r\nreturn -ENOMEM;\r\nnpar = pci_info_addr;\r\nerr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_GET_PCI_INFO);\r\nif (err)\r\ngoto out_free_dma;\r\ncmd.req.arg[1] = MSD(pci_info_dma_t);\r\ncmd.req.arg[2] = LSD(pci_info_dma_t);\r\ncmd.req.arg[3] = pci_size;\r\nerr = qlcnic_issue_cmd(adapter, &cmd);\r\nahw->total_nic_func = 0;\r\nif (err == QLCNIC_RCODE_SUCCESS) {\r\nfor (i = 0; i < ahw->max_vnic_func; i++, npar++, pci_info++) {\r\npci_info->id = le16_to_cpu(npar->id);\r\npci_info->active = le16_to_cpu(npar->active);\r\nif (!pci_info->active)\r\ncontinue;\r\npci_info->type = le16_to_cpu(npar->type);\r\nerr = qlcnic_get_pci_func_type(adapter, pci_info->type,\r\n&nic, &fcoe, &iscsi);\r\npci_info->default_port =\r\nle16_to_cpu(npar->default_port);\r\npci_info->tx_min_bw =\r\nle16_to_cpu(npar->tx_min_bw);\r\npci_info->tx_max_bw =\r\nle16_to_cpu(npar->tx_max_bw);\r\nmemcpy(pci_info->mac, npar->mac, ETH_ALEN);\r\n}\r\n} else {\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to get PCI Info%d\n", err);\r\nerr = -EIO;\r\n}\r\nahw->total_nic_func = nic;\r\nahw->total_pci_func = nic + fcoe + iscsi;\r\nif (ahw->total_nic_func == 0 || ahw->total_pci_func == 0) {\r\ndev_err(&adapter->pdev->dev,\r\n"%s: Invalid function count: total nic func[%x], total pci func[%x]\n",\r\n__func__, ahw->total_nic_func, ahw->total_pci_func);\r\nerr = -EIO;\r\n}\r\nqlcnic_free_mbx_args(&cmd);\r\nout_free_dma:\r\ndma_free_coherent(&adapter->pdev->dev, pci_size, pci_info_addr,\r\npci_info_dma_t);\r\nreturn err;\r\n}\r\n/* Configure eSwitch for port mirroring */\r\nint qlcnic_config_port_mirroring(struct qlcnic_adapter *adapter, u8 id,\r\nu8 enable_mirroring, u8 pci_func)\r\n{\r\nstruct device *dev = &adapter->pdev->dev;\r\nstruct qlcnic_cmd_args cmd;\r\nint err = -EIO;\r\nu32 arg1;\r\nif (adapter->ahw->op_mode != QLCNIC_MGMT_FUNC ||\r\n!(adapter->eswitch[id].flags & QLCNIC_SWITCH_ENABLE)) {\r\ndev_err(&adapter->pdev->dev, "%s: Not a management function\n",\r\n__func__);\r\nreturn err;\r\n}\r\narg1 = id | (enable_mirroring ? BIT_4 : 0);\r\narg1 |= pci_func << 8;\r\nerr = qlcnic_alloc_mbx_args(&cmd, adapter,\r\nQLCNIC_CMD_SET_PORTMIRRORING);\r\nif (err)\r\nreturn err;\r\ncmd.req.arg[1] = arg1;\r\nerr = qlcnic_issue_cmd(adapter, &cmd);\r\nif (err != QLCNIC_RCODE_SUCCESS)\r\ndev_err(dev, "Failed to configure port mirroring for vNIC function %d on eSwitch %d\n",\r\npci_func, id);\r\nelse\r\ndev_info(dev, "Configured port mirroring for vNIC function %d on eSwitch %d\n",\r\npci_func, id);\r\nqlcnic_free_mbx_args(&cmd);\r\nreturn err;\r\n}\r\nint qlcnic_get_port_stats(struct qlcnic_adapter *adapter, const u8 func,\r\nconst u8 rx_tx, struct __qlcnic_esw_statistics *esw_stats) {\r\nsize_t stats_size = sizeof(struct qlcnic_esw_stats_le);\r\nstruct qlcnic_esw_stats_le *stats;\r\ndma_addr_t stats_dma_t;\r\nvoid *stats_addr;\r\nu32 arg1;\r\nstruct qlcnic_cmd_args cmd;\r\nint err;\r\nif (esw_stats == NULL)\r\nreturn -ENOMEM;\r\nif ((adapter->ahw->op_mode != QLCNIC_MGMT_FUNC) &&\r\n(func != adapter->ahw->pci_func)) {\r\ndev_err(&adapter->pdev->dev,\r\n"Not privilege to query stats for func=%d", func);\r\nreturn -EIO;\r\n}\r\nstats_addr = dma_zalloc_coherent(&adapter->pdev->dev, stats_size,\r\n&stats_dma_t, GFP_KERNEL);\r\nif (!stats_addr)\r\nreturn -ENOMEM;\r\narg1 = func | QLCNIC_STATS_VERSION << 8 | QLCNIC_STATS_PORT << 12;\r\narg1 |= rx_tx << 15 | stats_size << 16;\r\nerr = qlcnic_alloc_mbx_args(&cmd, adapter,\r\nQLCNIC_CMD_GET_ESWITCH_STATS);\r\nif (err)\r\ngoto out_free_dma;\r\ncmd.req.arg[1] = arg1;\r\ncmd.req.arg[2] = MSD(stats_dma_t);\r\ncmd.req.arg[3] = LSD(stats_dma_t);\r\nerr = qlcnic_issue_cmd(adapter, &cmd);\r\nif (!err) {\r\nstats = stats_addr;\r\nesw_stats->context_id = le16_to_cpu(stats->context_id);\r\nesw_stats->version = le16_to_cpu(stats->version);\r\nesw_stats->size = le16_to_cpu(stats->size);\r\nesw_stats->multicast_frames =\r\nle64_to_cpu(stats->multicast_frames);\r\nesw_stats->broadcast_frames =\r\nle64_to_cpu(stats->broadcast_frames);\r\nesw_stats->unicast_frames = le64_to_cpu(stats->unicast_frames);\r\nesw_stats->dropped_frames = le64_to_cpu(stats->dropped_frames);\r\nesw_stats->local_frames = le64_to_cpu(stats->local_frames);\r\nesw_stats->errors = le64_to_cpu(stats->errors);\r\nesw_stats->numbytes = le64_to_cpu(stats->numbytes);\r\n}\r\nqlcnic_free_mbx_args(&cmd);\r\nout_free_dma:\r\ndma_free_coherent(&adapter->pdev->dev, stats_size, stats_addr,\r\nstats_dma_t);\r\nreturn err;\r\n}\r\n/* This routine will retrieve the MAC statistics from firmware */\r\nint qlcnic_get_mac_stats(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_mac_statistics *mac_stats)\r\n{\r\nstruct qlcnic_mac_statistics_le *stats;\r\nstruct qlcnic_cmd_args cmd;\r\nsize_t stats_size = sizeof(struct qlcnic_mac_statistics_le);\r\ndma_addr_t stats_dma_t;\r\nvoid *stats_addr;\r\nint err;\r\nif (mac_stats == NULL)\r\nreturn -ENOMEM;\r\nstats_addr = dma_zalloc_coherent(&adapter->pdev->dev, stats_size,\r\n&stats_dma_t, GFP_KERNEL);\r\nif (!stats_addr)\r\nreturn -ENOMEM;\r\nerr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_GET_MAC_STATS);\r\nif (err)\r\ngoto out_free_dma;\r\ncmd.req.arg[1] = stats_size << 16;\r\ncmd.req.arg[2] = MSD(stats_dma_t);\r\ncmd.req.arg[3] = LSD(stats_dma_t);\r\nerr = qlcnic_issue_cmd(adapter, &cmd);\r\nif (!err) {\r\nstats = stats_addr;\r\nmac_stats->mac_tx_frames = le64_to_cpu(stats->mac_tx_frames);\r\nmac_stats->mac_tx_bytes = le64_to_cpu(stats->mac_tx_bytes);\r\nmac_stats->mac_tx_mcast_pkts =\r\nle64_to_cpu(stats->mac_tx_mcast_pkts);\r\nmac_stats->mac_tx_bcast_pkts =\r\nle64_to_cpu(stats->mac_tx_bcast_pkts);\r\nmac_stats->mac_rx_frames = le64_to_cpu(stats->mac_rx_frames);\r\nmac_stats->mac_rx_bytes = le64_to_cpu(stats->mac_rx_bytes);\r\nmac_stats->mac_rx_mcast_pkts =\r\nle64_to_cpu(stats->mac_rx_mcast_pkts);\r\nmac_stats->mac_rx_length_error =\r\nle64_to_cpu(stats->mac_rx_length_error);\r\nmac_stats->mac_rx_length_small =\r\nle64_to_cpu(stats->mac_rx_length_small);\r\nmac_stats->mac_rx_length_large =\r\nle64_to_cpu(stats->mac_rx_length_large);\r\nmac_stats->mac_rx_jabber = le64_to_cpu(stats->mac_rx_jabber);\r\nmac_stats->mac_rx_dropped = le64_to_cpu(stats->mac_rx_dropped);\r\nmac_stats->mac_rx_crc_error = le64_to_cpu(stats->mac_rx_crc_error);\r\n} else {\r\ndev_err(&adapter->pdev->dev,\r\n"%s: Get mac stats failed, err=%d.\n", __func__, err);\r\n}\r\nqlcnic_free_mbx_args(&cmd);\r\nout_free_dma:\r\ndma_free_coherent(&adapter->pdev->dev, stats_size, stats_addr,\r\nstats_dma_t);\r\nreturn err;\r\n}\r\nint qlcnic_get_eswitch_stats(struct qlcnic_adapter *adapter, const u8 eswitch,\r\nconst u8 rx_tx, struct __qlcnic_esw_statistics *esw_stats) {\r\nstruct __qlcnic_esw_statistics port_stats;\r\nu8 i;\r\nint ret = -EIO;\r\nif (esw_stats == NULL)\r\nreturn -ENOMEM;\r\nif (adapter->ahw->op_mode != QLCNIC_MGMT_FUNC)\r\nreturn -EIO;\r\nif (adapter->npars == NULL)\r\nreturn -EIO;\r\nmemset(esw_stats, 0, sizeof(u64));\r\nesw_stats->unicast_frames = QLCNIC_STATS_NOT_AVAIL;\r\nesw_stats->multicast_frames = QLCNIC_STATS_NOT_AVAIL;\r\nesw_stats->broadcast_frames = QLCNIC_STATS_NOT_AVAIL;\r\nesw_stats->dropped_frames = QLCNIC_STATS_NOT_AVAIL;\r\nesw_stats->errors = QLCNIC_STATS_NOT_AVAIL;\r\nesw_stats->local_frames = QLCNIC_STATS_NOT_AVAIL;\r\nesw_stats->numbytes = QLCNIC_STATS_NOT_AVAIL;\r\nesw_stats->context_id = eswitch;\r\nfor (i = 0; i < adapter->ahw->total_nic_func; i++) {\r\nif (adapter->npars[i].phy_port != eswitch)\r\ncontinue;\r\nmemset(&port_stats, 0, sizeof(struct __qlcnic_esw_statistics));\r\nif (qlcnic_get_port_stats(adapter, adapter->npars[i].pci_func,\r\nrx_tx, &port_stats))\r\ncontinue;\r\nesw_stats->size = port_stats.size;\r\nesw_stats->version = port_stats.version;\r\nQLCNIC_ADD_ESW_STATS(esw_stats->unicast_frames,\r\nport_stats.unicast_frames);\r\nQLCNIC_ADD_ESW_STATS(esw_stats->multicast_frames,\r\nport_stats.multicast_frames);\r\nQLCNIC_ADD_ESW_STATS(esw_stats->broadcast_frames,\r\nport_stats.broadcast_frames);\r\nQLCNIC_ADD_ESW_STATS(esw_stats->dropped_frames,\r\nport_stats.dropped_frames);\r\nQLCNIC_ADD_ESW_STATS(esw_stats->errors,\r\nport_stats.errors);\r\nQLCNIC_ADD_ESW_STATS(esw_stats->local_frames,\r\nport_stats.local_frames);\r\nQLCNIC_ADD_ESW_STATS(esw_stats->numbytes,\r\nport_stats.numbytes);\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nint qlcnic_clear_esw_stats(struct qlcnic_adapter *adapter, const u8 func_esw,\r\nconst u8 port, const u8 rx_tx)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nstruct qlcnic_cmd_args cmd;\r\nint err;\r\nu32 arg1;\r\nif (ahw->op_mode != QLCNIC_MGMT_FUNC)\r\nreturn -EIO;\r\nif (func_esw == QLCNIC_STATS_PORT) {\r\nif (port >= ahw->max_vnic_func)\r\ngoto err_ret;\r\n} else if (func_esw == QLCNIC_STATS_ESWITCH) {\r\nif (port >= QLCNIC_NIU_MAX_XG_PORTS)\r\ngoto err_ret;\r\n} else {\r\ngoto err_ret;\r\n}\r\nif (rx_tx > QLCNIC_QUERY_TX_COUNTER)\r\ngoto err_ret;\r\narg1 = port | QLCNIC_STATS_VERSION << 8 | func_esw << 12;\r\narg1 |= BIT_14 | rx_tx << 15;\r\nerr = qlcnic_alloc_mbx_args(&cmd, adapter,\r\nQLCNIC_CMD_GET_ESWITCH_STATS);\r\nif (err)\r\nreturn err;\r\ncmd.req.arg[1] = arg1;\r\nerr = qlcnic_issue_cmd(adapter, &cmd);\r\nqlcnic_free_mbx_args(&cmd);\r\nreturn err;\r\nerr_ret:\r\ndev_err(&adapter->pdev->dev,\r\n"Invalid args func_esw %d port %d rx_ctx %d\n",\r\nfunc_esw, port, rx_tx);\r\nreturn -EIO;\r\n}\r\nstatic int __qlcnic_get_eswitch_port_config(struct qlcnic_adapter *adapter,\r\nu32 *arg1, u32 *arg2)\r\n{\r\nstruct device *dev = &adapter->pdev->dev;\r\nstruct qlcnic_cmd_args cmd;\r\nu8 pci_func = *arg1 >> 8;\r\nint err;\r\nerr = qlcnic_alloc_mbx_args(&cmd, adapter,\r\nQLCNIC_CMD_GET_ESWITCH_PORT_CONFIG);\r\nif (err)\r\nreturn err;\r\ncmd.req.arg[1] = *arg1;\r\nerr = qlcnic_issue_cmd(adapter, &cmd);\r\n*arg1 = cmd.rsp.arg[1];\r\n*arg2 = cmd.rsp.arg[2];\r\nqlcnic_free_mbx_args(&cmd);\r\nif (err == QLCNIC_RCODE_SUCCESS)\r\ndev_info(dev, "Get eSwitch port config for vNIC function %d\n",\r\npci_func);\r\nelse\r\ndev_err(dev, "Failed to get eswitch port config for vNIC function %d\n",\r\npci_func);\r\nreturn err;\r\n}\r\n/* Configure eSwitch port\r\nop_mode = 0 for setting default port behavior\r\nop_mode = 1 for setting vlan id\r\nop_mode = 2 for deleting vlan id\r\nop_type = 0 for vlan_id\r\nop_type = 1 for port vlan_id\r\n*/\r\nint qlcnic_config_switch_port(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_esw_func_cfg *esw_cfg)\r\n{\r\nstruct device *dev = &adapter->pdev->dev;\r\nstruct qlcnic_cmd_args cmd;\r\nint err = -EIO, index;\r\nu32 arg1, arg2 = 0;\r\nu8 pci_func;\r\nif (adapter->ahw->op_mode != QLCNIC_MGMT_FUNC) {\r\ndev_err(&adapter->pdev->dev, "%s: Not a management function\n",\r\n__func__);\r\nreturn err;\r\n}\r\npci_func = esw_cfg->pci_func;\r\nindex = qlcnic_is_valid_nic_func(adapter, pci_func);\r\nif (index < 0)\r\nreturn err;\r\narg1 = (adapter->npars[index].phy_port & BIT_0);\r\narg1 |= (pci_func << 8);\r\nif (__qlcnic_get_eswitch_port_config(adapter, &arg1, &arg2))\r\nreturn err;\r\narg1 &= ~(0x0ff << 8);\r\narg1 |= (pci_func << 8);\r\narg1 &= ~(BIT_2 | BIT_3);\r\nswitch (esw_cfg->op_mode) {\r\ncase QLCNIC_PORT_DEFAULTS:\r\narg1 |= (BIT_4 | BIT_6 | BIT_7);\r\narg2 |= (BIT_0 | BIT_1);\r\nif (adapter->ahw->capabilities & QLCNIC_FW_CAPABILITY_TSO)\r\narg2 |= (BIT_2 | BIT_3);\r\nif (!(esw_cfg->discard_tagged))\r\narg1 &= ~BIT_4;\r\nif (!(esw_cfg->promisc_mode))\r\narg1 &= ~BIT_6;\r\nif (!(esw_cfg->mac_override))\r\narg1 &= ~BIT_7;\r\nif (!(esw_cfg->mac_anti_spoof))\r\narg2 &= ~BIT_0;\r\nif (!(esw_cfg->offload_flags & BIT_0))\r\narg2 &= ~(BIT_1 | BIT_2 | BIT_3);\r\nif (!(esw_cfg->offload_flags & BIT_1))\r\narg2 &= ~BIT_2;\r\nif (!(esw_cfg->offload_flags & BIT_2))\r\narg2 &= ~BIT_3;\r\nbreak;\r\ncase QLCNIC_ADD_VLAN:\r\narg1 &= ~(0x0ffff << 16);\r\narg1 |= (BIT_2 | BIT_5);\r\narg1 |= (esw_cfg->vlan_id << 16);\r\nbreak;\r\ncase QLCNIC_DEL_VLAN:\r\narg1 |= (BIT_3 | BIT_5);\r\narg1 &= ~(0x0ffff << 16);\r\nbreak;\r\ndefault:\r\ndev_err(&adapter->pdev->dev, "%s: Invalid opmode 0x%x\n",\r\n__func__, esw_cfg->op_mode);\r\nreturn err;\r\n}\r\nerr = qlcnic_alloc_mbx_args(&cmd, adapter,\r\nQLCNIC_CMD_CONFIGURE_ESWITCH);\r\nif (err)\r\nreturn err;\r\ncmd.req.arg[1] = arg1;\r\ncmd.req.arg[2] = arg2;\r\nerr = qlcnic_issue_cmd(adapter, &cmd);\r\nqlcnic_free_mbx_args(&cmd);\r\nif (err != QLCNIC_RCODE_SUCCESS)\r\ndev_err(dev, "Failed to configure eswitch for vNIC function %d\n",\r\npci_func);\r\nelse\r\ndev_info(dev, "Configured eSwitch for vNIC function %d\n"
