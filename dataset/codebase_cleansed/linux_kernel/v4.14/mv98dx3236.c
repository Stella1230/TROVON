static u32 __init mv98dx3236_get_tclk_freq(void __iomem *sar)\r\n{\r\nreturn 200000000;\r\n}\r\nstatic u32 __init mv98dx3236_get_cpu_freq(void __iomem *sar)\r\n{\r\nu32 cpu_freq = 0;\r\nu8 cpu_freq_select = 0;\r\ncpu_freq_select = ((readl(sar) >> SAR1_MV98DX3236_CPU_DDR_MPLL_FREQ_OPT) &\r\nSAR1_MV98DX3236_CPU_DDR_MPLL_FREQ_OPT_MASK);\r\nif (of_machine_is_compatible("marvell,armadaxp-98dx4251"))\r\ncpu_freq = mv98dx4251_cpu_frequencies[cpu_freq_select];\r\nelse if (of_machine_is_compatible("marvell,armadaxp-98dx3236"))\r\ncpu_freq = mv98dx3236_cpu_frequencies[cpu_freq_select];\r\nif (!cpu_freq)\r\npr_err("CPU freq select unsupported %d\n", cpu_freq_select);\r\nreturn cpu_freq;\r\n}\r\nstatic void __init mv98dx3236_get_clk_ratio(\r\nvoid __iomem *sar, int id, int *mult, int *div)\r\n{\r\nu32 opt = ((readl(sar) >> SAR1_MV98DX3236_CPU_DDR_MPLL_FREQ_OPT) &\r\nSAR1_MV98DX3236_CPU_DDR_MPLL_FREQ_OPT_MASK);\r\nswitch (id) {\r\ncase MV98DX3236_CPU_TO_DDR:\r\nif (of_machine_is_compatible("marvell,armadaxp-98dx4251")) {\r\n*mult = mv98dx4251_cpu_ddr_ratios[opt][0];\r\n*div = mv98dx4251_cpu_ddr_ratios[opt][1];\r\n} else if (of_machine_is_compatible("marvell,armadaxp-98dx3236")) {\r\n*mult = mv98dx3236_cpu_ddr_ratios[opt][0];\r\n*div = mv98dx3236_cpu_ddr_ratios[opt][1];\r\n}\r\nbreak;\r\ncase MV98DX3236_CPU_TO_MPLL:\r\nif (of_machine_is_compatible("marvell,armadaxp-98dx4251")) {\r\n*mult = mv98dx4251_cpu_mpll_ratios[opt][0];\r\n*div = mv98dx4251_cpu_mpll_ratios[opt][1];\r\n} else if (of_machine_is_compatible("marvell,armadaxp-98dx3236")) {\r\n*mult = mv98dx3236_cpu_mpll_ratios[opt][0];\r\n*div = mv98dx3236_cpu_mpll_ratios[opt][1];\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void __init mv98dx3236_clk_init(struct device_node *np)\r\n{\r\nstruct device_node *cgnp =\r\nof_find_compatible_node(NULL, NULL, "marvell,mv98dx3236-gating-clock");\r\nmvebu_coreclk_setup(np, &mv98dx3236_core_clocks);\r\nif (cgnp)\r\nmvebu_clk_gating_setup(cgnp, mv98dx3236_gating_desc);\r\n}
