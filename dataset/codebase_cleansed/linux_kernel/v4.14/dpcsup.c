unsigned int aac_response_normal(struct aac_queue * q)\r\n{\r\nstruct aac_dev * dev = q->dev;\r\nstruct aac_entry *entry;\r\nstruct hw_fib * hwfib;\r\nstruct fib * fib;\r\nint consumed = 0;\r\nunsigned long flags, mflags;\r\nspin_lock_irqsave(q->lock, flags);\r\nwhile(aac_consumer_get(dev, q, &entry))\r\n{\r\nint fast;\r\nu32 index = le32_to_cpu(entry->addr);\r\nfast = index & 0x01;\r\nfib = &dev->fibs[index >> 2];\r\nhwfib = fib->hw_fib_va;\r\naac_consumer_free(dev, q, HostNormRespQueue);\r\natomic_dec(&dev->queues->queue[AdapNormCmdQueue].numpending);\r\nif (unlikely(fib->flags & FIB_CONTEXT_FLAG_TIMED_OUT)) {\r\nspin_unlock_irqrestore(q->lock, flags);\r\naac_fib_complete(fib);\r\naac_fib_free(fib);\r\nspin_lock_irqsave(q->lock, flags);\r\ncontinue;\r\n}\r\nspin_unlock_irqrestore(q->lock, flags);\r\nif (fast) {\r\n*(__le32 *)hwfib->data = cpu_to_le32(ST_OK);\r\nhwfib->header.XferState |= cpu_to_le32(AdapterProcessed);\r\nfib->flags |= FIB_CONTEXT_FLAG_FASTRESP;\r\n}\r\nFIB_COUNTER_INCREMENT(aac_config.FibRecved);\r\nif (hwfib->header.Command == cpu_to_le16(NuFileSystem))\r\n{\r\n__le32 *pstatus = (__le32 *)hwfib->data;\r\nif (*pstatus & cpu_to_le32(0xffff0000))\r\n*pstatus = cpu_to_le32(ST_OK);\r\n}\r\nif (hwfib->header.XferState & cpu_to_le32(NoResponseExpected | Async))\r\n{\r\nif (hwfib->header.XferState & cpu_to_le32(NoResponseExpected))\r\nFIB_COUNTER_INCREMENT(aac_config.NoResponseRecved);\r\nelse\r\nFIB_COUNTER_INCREMENT(aac_config.AsyncRecved);\r\nfib->callback(fib->callback_data, fib);\r\n} else {\r\nunsigned long flagv;\r\nspin_lock_irqsave(&fib->event_lock, flagv);\r\nif (!fib->done) {\r\nfib->done = 1;\r\nup(&fib->event_wait);\r\n}\r\nspin_unlock_irqrestore(&fib->event_lock, flagv);\r\nspin_lock_irqsave(&dev->manage_lock, mflags);\r\ndev->management_fib_count--;\r\nspin_unlock_irqrestore(&dev->manage_lock, mflags);\r\nFIB_COUNTER_INCREMENT(aac_config.NormalRecved);\r\nif (fib->done == 2) {\r\nspin_lock_irqsave(&fib->event_lock, flagv);\r\nfib->done = 0;\r\nspin_unlock_irqrestore(&fib->event_lock, flagv);\r\naac_fib_complete(fib);\r\naac_fib_free(fib);\r\n}\r\n}\r\nconsumed++;\r\nspin_lock_irqsave(q->lock, flags);\r\n}\r\nif (consumed > aac_config.peak_fibs)\r\naac_config.peak_fibs = consumed;\r\nif (consumed == 0)\r\naac_config.zero_fibs++;\r\nspin_unlock_irqrestore(q->lock, flags);\r\nreturn 0;\r\n}\r\nunsigned int aac_command_normal(struct aac_queue *q)\r\n{\r\nstruct aac_dev * dev = q->dev;\r\nstruct aac_entry *entry;\r\nunsigned long flags;\r\nspin_lock_irqsave(q->lock, flags);\r\nwhile(aac_consumer_get(dev, q, &entry))\r\n{\r\nstruct fib fibctx;\r\nstruct hw_fib * hw_fib;\r\nu32 index;\r\nstruct fib *fib = &fibctx;\r\nindex = le32_to_cpu(entry->addr) / sizeof(struct hw_fib);\r\nhw_fib = &dev->aif_base_va[index];\r\nif (dev->aif_thread)\r\nif((fib = kmalloc(sizeof(struct fib), GFP_ATOMIC)) == NULL)\r\nfib = &fibctx;\r\nmemset(fib, 0, sizeof(struct fib));\r\nINIT_LIST_HEAD(&fib->fiblink);\r\nfib->type = FSAFS_NTC_FIB_CONTEXT;\r\nfib->size = sizeof(struct fib);\r\nfib->hw_fib_va = hw_fib;\r\nfib->data = hw_fib->data;\r\nfib->dev = dev;\r\nif (dev->aif_thread && fib != &fibctx) {\r\nlist_add_tail(&fib->fiblink, &q->cmdq);\r\naac_consumer_free(dev, q, HostNormCmdQueue);\r\nwake_up_interruptible(&q->cmdready);\r\n} else {\r\naac_consumer_free(dev, q, HostNormCmdQueue);\r\nspin_unlock_irqrestore(q->lock, flags);\r\n*(__le32 *)hw_fib->data = cpu_to_le32(ST_OK);\r\naac_fib_adapter_complete(fib, sizeof(u32));\r\nspin_lock_irqsave(q->lock, flags);\r\n}\r\n}\r\nspin_unlock_irqrestore(q->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void aac_aif_callback(void *context, struct fib * fibptr)\r\n{\r\nstruct fib *fibctx;\r\nstruct aac_dev *dev;\r\nstruct aac_aifcmd *cmd;\r\nint status;\r\nfibctx = (struct fib *)context;\r\nBUG_ON(fibptr == NULL);\r\ndev = fibptr->dev;\r\nif ((fibptr->hw_fib_va->header.XferState &\r\ncpu_to_le32(NoMoreAifDataAvailable)) ||\r\ndev->sa_firmware) {\r\naac_fib_complete(fibptr);\r\naac_fib_free(fibptr);\r\nreturn;\r\n}\r\naac_intr_normal(dev, 0, 1, 0, fibptr->hw_fib_va);\r\naac_fib_init(fibctx);\r\ncmd = (struct aac_aifcmd *) fib_data(fibctx);\r\ncmd->command = cpu_to_le32(AifReqEvent);\r\nstatus = aac_fib_send(AifRequest,\r\nfibctx,\r\nsizeof(struct hw_fib)-sizeof(struct aac_fibhdr),\r\nFsaNormal,\r\n0, 1,\r\n(fib_callback)aac_aif_callback, fibctx);\r\n}\r\nunsigned int aac_intr_normal(struct aac_dev *dev, u32 index, int isAif,\r\nint isFastResponse, struct hw_fib *aif_fib)\r\n{\r\nunsigned long mflags;\r\ndprintk((KERN_INFO "aac_intr_normal(%p,%x)\n", dev, index));\r\nif (isAif == 1) {\r\nstruct hw_fib * hw_fib;\r\nstruct fib * fib;\r\nstruct aac_queue *q = &dev->queues->queue[HostNormCmdQueue];\r\nunsigned long flags;\r\nif ((!dev->aif_thread)\r\n|| (!(fib = kzalloc(sizeof(struct fib),GFP_ATOMIC))))\r\nreturn 1;\r\nif (!(hw_fib = kzalloc(sizeof(struct hw_fib),GFP_ATOMIC))) {\r\nkfree (fib);\r\nreturn 1;\r\n}\r\nif (dev->sa_firmware) {\r\nfib->hbacmd_size = index;\r\n} else if (aif_fib != NULL) {\r\nmemcpy(hw_fib, aif_fib, sizeof(struct hw_fib));\r\n} else {\r\nmemcpy(hw_fib, (struct hw_fib *)\r\n(((uintptr_t)(dev->regs.sa)) + index),\r\nsizeof(struct hw_fib));\r\n}\r\nINIT_LIST_HEAD(&fib->fiblink);\r\nfib->type = FSAFS_NTC_FIB_CONTEXT;\r\nfib->size = sizeof(struct fib);\r\nfib->hw_fib_va = hw_fib;\r\nfib->data = hw_fib->data;\r\nfib->dev = dev;\r\nspin_lock_irqsave(q->lock, flags);\r\nlist_add_tail(&fib->fiblink, &q->cmdq);\r\nwake_up_interruptible(&q->cmdready);\r\nspin_unlock_irqrestore(q->lock, flags);\r\nreturn 1;\r\n} else if (isAif == 2) {\r\nstruct fib *fibctx;\r\nstruct aac_aifcmd *cmd;\r\nfibctx = aac_fib_alloc(dev);\r\nif (!fibctx)\r\nreturn 1;\r\naac_fib_init(fibctx);\r\ncmd = (struct aac_aifcmd *) fib_data(fibctx);\r\ncmd->command = cpu_to_le32(AifReqEvent);\r\nreturn aac_fib_send(AifRequest,\r\nfibctx,\r\nsizeof(struct hw_fib)-sizeof(struct aac_fibhdr),\r\nFsaNormal,\r\n0, 1,\r\n(fib_callback)aac_aif_callback, fibctx);\r\n} else {\r\nstruct fib *fib = &dev->fibs[index];\r\nint start_callback = 0;\r\natomic_dec(&dev->queues->queue[AdapNormCmdQueue].numpending);\r\nif (unlikely(fib->flags & FIB_CONTEXT_FLAG_TIMED_OUT)) {\r\naac_fib_complete(fib);\r\naac_fib_free(fib);\r\nreturn 0;\r\n}\r\nFIB_COUNTER_INCREMENT(aac_config.FibRecved);\r\nif (fib->flags & FIB_CONTEXT_FLAG_NATIVE_HBA) {\r\nif (isFastResponse)\r\nfib->flags |= FIB_CONTEXT_FLAG_FASTRESP;\r\nif (fib->callback) {\r\nstart_callback = 1;\r\n} else {\r\nunsigned long flagv;\r\nint complete = 0;\r\ndprintk((KERN_INFO "event_wait up\n"));\r\nspin_lock_irqsave(&fib->event_lock, flagv);\r\nif (fib->done == 2) {\r\nfib->done = 1;\r\ncomplete = 1;\r\n} else {\r\nfib->done = 1;\r\nup(&fib->event_wait);\r\n}\r\nspin_unlock_irqrestore(&fib->event_lock, flagv);\r\nspin_lock_irqsave(&dev->manage_lock, mflags);\r\ndev->management_fib_count--;\r\nspin_unlock_irqrestore(&dev->manage_lock,\r\nmflags);\r\nFIB_COUNTER_INCREMENT(aac_config.NativeRecved);\r\nif (complete)\r\naac_fib_complete(fib);\r\n}\r\n} else {\r\nstruct hw_fib *hwfib = fib->hw_fib_va;\r\nif (isFastResponse) {\r\n*(__le32 *)hwfib->data = cpu_to_le32(ST_OK);\r\nhwfib->header.XferState |=\r\ncpu_to_le32(AdapterProcessed);\r\nfib->flags |= FIB_CONTEXT_FLAG_FASTRESP;\r\n}\r\nif (hwfib->header.Command ==\r\ncpu_to_le16(NuFileSystem)) {\r\n__le32 *pstatus = (__le32 *)hwfib->data;\r\nif (*pstatus & cpu_to_le32(0xffff0000))\r\n*pstatus = cpu_to_le32(ST_OK);\r\n}\r\nif (hwfib->header.XferState &\r\ncpu_to_le32(NoResponseExpected | Async)) {\r\nif (hwfib->header.XferState & cpu_to_le32(\r\nNoResponseExpected))\r\nFIB_COUNTER_INCREMENT(\r\naac_config.NoResponseRecved);\r\nelse\r\nFIB_COUNTER_INCREMENT(\r\naac_config.AsyncRecved);\r\nstart_callback = 1;\r\n} else {\r\nunsigned long flagv;\r\nint complete = 0;\r\ndprintk((KERN_INFO "event_wait up\n"));\r\nspin_lock_irqsave(&fib->event_lock, flagv);\r\nif (fib->done == 2) {\r\nfib->done = 1;\r\ncomplete = 1;\r\n} else {\r\nfib->done = 1;\r\nup(&fib->event_wait);\r\n}\r\nspin_unlock_irqrestore(&fib->event_lock, flagv);\r\nspin_lock_irqsave(&dev->manage_lock, mflags);\r\ndev->management_fib_count--;\r\nspin_unlock_irqrestore(&dev->manage_lock,\r\nmflags);\r\nFIB_COUNTER_INCREMENT(aac_config.NormalRecved);\r\nif (complete)\r\naac_fib_complete(fib);\r\n}\r\n}\r\nif (start_callback) {\r\nif (likely(fib->callback && fib->callback_data)) {\r\nfib->callback(fib->callback_data, fib);\r\n} else {\r\naac_fib_complete(fib);\r\naac_fib_free(fib);\r\n}\r\n}\r\nreturn 0;\r\n}\r\n}
