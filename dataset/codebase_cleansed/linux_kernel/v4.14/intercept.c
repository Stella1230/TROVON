u8 kvm_s390_get_ilen(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvm_s390_sie_block *sie_block = vcpu->arch.sie_block;\r\nu8 ilen = 0;\r\nswitch (vcpu->arch.sie_block->icptcode) {\r\ncase ICPT_INST:\r\ncase ICPT_INSTPROGI:\r\ncase ICPT_OPEREXC:\r\ncase ICPT_PARTEXEC:\r\ncase ICPT_IOINST:\r\nilen = insn_length(vcpu->arch.sie_block->ipa >> 8);\r\nif (sie_block->icptstatus & 1) {\r\nilen = (sie_block->icptstatus >> 4) & 0x6;\r\nif (!ilen)\r\nilen = 4;\r\n}\r\nbreak;\r\ncase ICPT_PROGI:\r\nilen = vcpu->arch.sie_block->pgmilc & 0x6;\r\nbreak;\r\n}\r\nreturn ilen;\r\n}\r\nstatic int handle_noop(struct kvm_vcpu *vcpu)\r\n{\r\nswitch (vcpu->arch.sie_block->icptcode) {\r\ncase 0x10:\r\nvcpu->stat.exit_external_request++;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int handle_stop(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvm_s390_local_interrupt *li = &vcpu->arch.local_int;\r\nint rc = 0;\r\nuint8_t flags, stop_pending;\r\nvcpu->stat.exit_stop_request++;\r\nif (kvm_s390_vcpu_has_irq(vcpu, 1))\r\nreturn 0;\r\nspin_lock(&li->lock);\r\nflags = li->irq.stop.flags;\r\nstop_pending = kvm_s390_is_stop_irq_pending(vcpu);\r\nspin_unlock(&li->lock);\r\ntrace_kvm_s390_stop_request(stop_pending, flags);\r\nif (!stop_pending)\r\nreturn 0;\r\nif (flags & KVM_S390_STOP_FLAG_STORE_STATUS) {\r\nrc = kvm_s390_vcpu_store_status(vcpu,\r\nKVM_S390_STORE_STATUS_NOADDR);\r\nif (rc)\r\nreturn rc;\r\n}\r\nif (!kvm_s390_user_cpu_state_ctrl(vcpu->kvm))\r\nkvm_s390_vcpu_stop(vcpu);\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int handle_validity(struct kvm_vcpu *vcpu)\r\n{\r\nint viwhy = vcpu->arch.sie_block->ipb >> 16;\r\nvcpu->stat.exit_validity++;\r\ntrace_kvm_s390_intercept_validity(vcpu, viwhy);\r\nKVM_EVENT(3, "validity intercept 0x%x for pid %u (kvm 0x%pK)", viwhy,\r\ncurrent->pid, vcpu->kvm);\r\nWARN_ONCE(viwhy != 0x44, "kvm: unhandled validity intercept 0x%x\n",\r\nviwhy);\r\nreturn -EINVAL;\r\n}\r\nstatic int handle_instruction(struct kvm_vcpu *vcpu)\r\n{\r\nintercept_handler_t handler;\r\nvcpu->stat.exit_instruction++;\r\ntrace_kvm_s390_intercept_instruction(vcpu,\r\nvcpu->arch.sie_block->ipa,\r\nvcpu->arch.sie_block->ipb);\r\nhandler = instruction_handlers[vcpu->arch.sie_block->ipa >> 8];\r\nif (handler)\r\nreturn handler(vcpu);\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int inject_prog_on_prog_intercept(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvm_s390_pgm_info pgm_info = {\r\n.code = vcpu->arch.sie_block->iprcc,\r\n.flags = KVM_S390_PGM_FLAGS_NO_REWIND,\r\n};\r\nswitch (vcpu->arch.sie_block->iprcc & ~PGM_PER) {\r\ncase PGM_AFX_TRANSLATION:\r\ncase PGM_ASX_TRANSLATION:\r\ncase PGM_EX_TRANSLATION:\r\ncase PGM_LFX_TRANSLATION:\r\ncase PGM_LSTE_SEQUENCE:\r\ncase PGM_LSX_TRANSLATION:\r\ncase PGM_LX_TRANSLATION:\r\ncase PGM_PRIMARY_AUTHORITY:\r\ncase PGM_SECONDARY_AUTHORITY:\r\ncase PGM_SPACE_SWITCH:\r\npgm_info.trans_exc_code = vcpu->arch.sie_block->tecmc;\r\nbreak;\r\ncase PGM_ALEN_TRANSLATION:\r\ncase PGM_ALE_SEQUENCE:\r\ncase PGM_ASTE_INSTANCE:\r\ncase PGM_ASTE_SEQUENCE:\r\ncase PGM_ASTE_VALIDITY:\r\ncase PGM_EXTENDED_AUTHORITY:\r\npgm_info.exc_access_id = vcpu->arch.sie_block->eai;\r\nbreak;\r\ncase PGM_ASCE_TYPE:\r\ncase PGM_PAGE_TRANSLATION:\r\ncase PGM_REGION_FIRST_TRANS:\r\ncase PGM_REGION_SECOND_TRANS:\r\ncase PGM_REGION_THIRD_TRANS:\r\ncase PGM_SEGMENT_TRANSLATION:\r\npgm_info.trans_exc_code = vcpu->arch.sie_block->tecmc;\r\npgm_info.exc_access_id = vcpu->arch.sie_block->eai;\r\npgm_info.op_access_id = vcpu->arch.sie_block->oai;\r\nbreak;\r\ncase PGM_MONITOR:\r\npgm_info.mon_class_nr = vcpu->arch.sie_block->mcn;\r\npgm_info.mon_code = vcpu->arch.sie_block->tecmc;\r\nbreak;\r\ncase PGM_VECTOR_PROCESSING:\r\ncase PGM_DATA:\r\npgm_info.data_exc_code = vcpu->arch.sie_block->dxc;\r\nbreak;\r\ncase PGM_PROTECTION:\r\npgm_info.trans_exc_code = vcpu->arch.sie_block->tecmc;\r\npgm_info.exc_access_id = vcpu->arch.sie_block->eai;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (vcpu->arch.sie_block->iprcc & PGM_PER) {\r\npgm_info.per_code = vcpu->arch.sie_block->perc;\r\npgm_info.per_atmid = vcpu->arch.sie_block->peratmid;\r\npgm_info.per_address = vcpu->arch.sie_block->peraddr;\r\npgm_info.per_access_id = vcpu->arch.sie_block->peraid;\r\n}\r\nreturn kvm_s390_inject_prog_irq(vcpu, &pgm_info);\r\n}\r\nstatic int handle_itdb(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvm_s390_itdb *itdb;\r\nint rc;\r\nif (!IS_TE_ENABLED(vcpu) || !IS_ITDB_VALID(vcpu))\r\nreturn 0;\r\nif (current->thread.per_flags & PER_FLAG_NO_TE)\r\nreturn 0;\r\nitdb = (struct kvm_s390_itdb *)vcpu->arch.sie_block->itdba;\r\nrc = write_guest_lc(vcpu, __LC_PGM_TDB, itdb, sizeof(*itdb));\r\nif (rc)\r\nreturn rc;\r\nmemset(itdb, 0, sizeof(*itdb));\r\nreturn 0;\r\n}\r\nstatic int handle_prog(struct kvm_vcpu *vcpu)\r\n{\r\npsw_t psw;\r\nint rc;\r\nvcpu->stat.exit_program_interruption++;\r\nif (guestdbg_enabled(vcpu) && per_event(vcpu)) {\r\nrc = kvm_s390_handle_per_event(vcpu);\r\nif (rc)\r\nreturn rc;\r\nif (vcpu->arch.sie_block->iprcc == 0)\r\nreturn 0;\r\n}\r\ntrace_kvm_s390_intercept_prog(vcpu, vcpu->arch.sie_block->iprcc);\r\nif (vcpu->arch.sie_block->iprcc == PGM_SPECIFICATION) {\r\nrc = read_guest_lc(vcpu, __LC_PGM_NEW_PSW, &psw, sizeof(psw_t));\r\nif (rc)\r\nreturn rc;\r\nif (!is_valid_psw(&psw))\r\nreturn -EOPNOTSUPP;\r\n}\r\nrc = handle_itdb(vcpu);\r\nif (rc)\r\nreturn rc;\r\nreturn inject_prog_on_prog_intercept(vcpu);\r\n}\r\nstatic int handle_external_interrupt(struct kvm_vcpu *vcpu)\r\n{\r\nu16 eic = vcpu->arch.sie_block->eic;\r\nstruct kvm_s390_irq irq;\r\npsw_t newpsw;\r\nint rc;\r\nvcpu->stat.exit_external_interrupt++;\r\nrc = read_guest_lc(vcpu, __LC_EXT_NEW_PSW, &newpsw, sizeof(psw_t));\r\nif (rc)\r\nreturn rc;\r\nif ((eic == EXT_IRQ_CLK_COMP || eic == EXT_IRQ_CPU_TIMER) &&\r\n(newpsw.mask & PSW_MASK_EXT))\r\nreturn -EOPNOTSUPP;\r\nswitch (eic) {\r\ncase EXT_IRQ_CLK_COMP:\r\nirq.type = KVM_S390_INT_CLOCK_COMP;\r\nbreak;\r\ncase EXT_IRQ_CPU_TIMER:\r\nirq.type = KVM_S390_INT_CPU_TIMER;\r\nbreak;\r\ncase EXT_IRQ_EXTERNAL_CALL:\r\nirq.type = KVM_S390_INT_EXTERNAL_CALL;\r\nirq.u.extcall.code = vcpu->arch.sie_block->extcpuaddr;\r\nrc = kvm_s390_inject_vcpu(vcpu, &irq);\r\nif (rc == -EBUSY)\r\nreturn 0;\r\nreturn rc;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn kvm_s390_inject_vcpu(vcpu, &irq);\r\n}\r\nstatic int handle_mvpg_pei(struct kvm_vcpu *vcpu)\r\n{\r\nunsigned long srcaddr, dstaddr;\r\nint reg1, reg2, rc;\r\nkvm_s390_get_regs_rre(vcpu, &reg1, &reg2);\r\nrc = guest_translate_address(vcpu, vcpu->run->s.regs.gprs[reg2],\r\nreg2, &srcaddr, GACC_FETCH);\r\nif (rc)\r\nreturn kvm_s390_inject_prog_cond(vcpu, rc);\r\nrc = kvm_arch_fault_in_page(vcpu, srcaddr, 0);\r\nif (rc != 0)\r\nreturn rc;\r\nrc = guest_translate_address(vcpu, vcpu->run->s.regs.gprs[reg1],\r\nreg1, &dstaddr, GACC_STORE);\r\nif (rc)\r\nreturn kvm_s390_inject_prog_cond(vcpu, rc);\r\nrc = kvm_arch_fault_in_page(vcpu, dstaddr, 1);\r\nif (rc != 0)\r\nreturn rc;\r\nkvm_s390_retry_instr(vcpu);\r\nreturn 0;\r\n}\r\nstatic int handle_partial_execution(struct kvm_vcpu *vcpu)\r\n{\r\nvcpu->stat.exit_pei++;\r\nif (vcpu->arch.sie_block->ipa == 0xb254)\r\nreturn handle_mvpg_pei(vcpu);\r\nif (vcpu->arch.sie_block->ipa >> 8 == 0xae)\r\nreturn kvm_s390_handle_sigp_pei(vcpu);\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int handle_operexc(struct kvm_vcpu *vcpu)\r\n{\r\npsw_t oldpsw, newpsw;\r\nint rc;\r\nvcpu->stat.exit_operation_exception++;\r\ntrace_kvm_s390_handle_operexc(vcpu, vcpu->arch.sie_block->ipa,\r\nvcpu->arch.sie_block->ipb);\r\nif (vcpu->arch.sie_block->ipa == 0xb256)\r\nreturn handle_sthyi(vcpu);\r\nif (vcpu->arch.sie_block->ipa == 0 && vcpu->kvm->arch.user_instr0)\r\nreturn -EOPNOTSUPP;\r\nrc = read_guest_lc(vcpu, __LC_PGM_NEW_PSW, &newpsw, sizeof(psw_t));\r\nif (rc)\r\nreturn rc;\r\noldpsw = vcpu->arch.sie_block->gpsw;\r\nif (oldpsw.addr - newpsw.addr <= 6 &&\r\n!(newpsw.mask & PSW_MASK_WAIT) &&\r\n!(oldpsw.mask & PSW_MASK_PSTATE) &&\r\n(newpsw.mask & PSW_MASK_ASC) == (oldpsw.mask & PSW_MASK_ASC) &&\r\n(newpsw.mask & PSW_MASK_DAT) == (oldpsw.mask & PSW_MASK_DAT))\r\nreturn -EOPNOTSUPP;\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_OPERATION);\r\n}\r\nint kvm_handle_sie_intercept(struct kvm_vcpu *vcpu)\r\n{\r\nint rc, per_rc = 0;\r\nif (kvm_is_ucontrol(vcpu->kvm))\r\nreturn -EOPNOTSUPP;\r\nswitch (vcpu->arch.sie_block->icptcode) {\r\ncase ICPT_EXTREQ:\r\ncase ICPT_IOREQ:\r\nreturn handle_noop(vcpu);\r\ncase ICPT_INST:\r\nrc = handle_instruction(vcpu);\r\nbreak;\r\ncase ICPT_PROGI:\r\nreturn handle_prog(vcpu);\r\ncase ICPT_EXTINT:\r\nreturn handle_external_interrupt(vcpu);\r\ncase ICPT_WAIT:\r\nreturn kvm_s390_handle_wait(vcpu);\r\ncase ICPT_VALIDITY:\r\nreturn handle_validity(vcpu);\r\ncase ICPT_STOP:\r\nreturn handle_stop(vcpu);\r\ncase ICPT_OPEREXC:\r\nrc = handle_operexc(vcpu);\r\nbreak;\r\ncase ICPT_PARTEXEC:\r\nrc = handle_partial_execution(vcpu);\r\nbreak;\r\ncase ICPT_KSS:\r\nrc = kvm_s390_skey_check_enable(vcpu);\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (vcpu->arch.sie_block->icptstatus & 0x02 &&\r\n(!rc || rc == -EOPNOTSUPP))\r\nper_rc = kvm_s390_handle_per_ifetch_icpt(vcpu);\r\nreturn per_rc ? per_rc : rc;\r\n}
