int nfp_cpp_readl(struct nfp_cpp *cpp, u32 cpp_id,\r\nunsigned long long address, u32 *value)\r\n{\r\nu8 tmp[4];\r\nint err;\r\nerr = nfp_cpp_read(cpp, cpp_id, address, tmp, sizeof(tmp));\r\n*value = get_unaligned_le32(tmp);\r\nreturn err;\r\n}\r\nint nfp_cpp_writel(struct nfp_cpp *cpp, u32 cpp_id,\r\nunsigned long long address, u32 value)\r\n{\r\nu8 tmp[4];\r\nput_unaligned_le32(value, tmp);\r\nreturn nfp_cpp_write(cpp, cpp_id, address, tmp, sizeof(tmp));\r\n}\r\nint nfp_cpp_readq(struct nfp_cpp *cpp, u32 cpp_id,\r\nunsigned long long address, u64 *value)\r\n{\r\nu8 tmp[8];\r\nint err;\r\nerr = nfp_cpp_read(cpp, cpp_id, address, tmp, sizeof(tmp));\r\n*value = get_unaligned_le64(tmp);\r\nreturn err;\r\n}\r\nint nfp_cpp_writeq(struct nfp_cpp *cpp, u32 cpp_id,\r\nunsigned long long address, u64 value)\r\n{\r\nu8 tmp[8];\r\nput_unaligned_le64(value, tmp);\r\nreturn nfp_cpp_write(cpp, cpp_id, address, tmp, sizeof(tmp));\r\n}\r\nint nfp_cpp_model_autodetect(struct nfp_cpp *cpp, u32 *model)\r\n{\r\nconst u32 arm_id = NFP_CPP_ID(NFP_CPP_TARGET_ARM, 0, 0);\r\nu32 reg;\r\nint err;\r\nerr = nfp_cpp_readl(cpp, arm_id, NFP6000_ARM_GCSR_SOFTMODEL0, model);\r\nif (err < 0)\r\nreturn err;\r\n*model &= ~0xff;\r\nerr = nfp_xpb_readl(cpp, NFP_XPB_DEVICE(1, 1, 16) + NFP_PL_DEVICE_ID,\r\n&reg);\r\nif (err < 0)\r\nreturn err;\r\n*model |= (NFP_PL_DEVICE_ID_MASK & reg) - 0x10;\r\nreturn 0;\r\n}\r\nstatic u8 nfp_bytemask(int width, u64 addr)\r\n{\r\nif (width == 8)\r\nreturn 0xff;\r\nelse if (width == 4)\r\nreturn 0x0f << (addr & 4);\r\nelse if (width == 2)\r\nreturn 0x03 << (addr & 6);\r\nelse if (width == 1)\r\nreturn 0x01 << (addr & 7);\r\nelse\r\nreturn 0;\r\n}\r\nint nfp_cpp_explicit_read(struct nfp_cpp *cpp, u32 cpp_id,\r\nu64 addr, void *buff, size_t len, int width_read)\r\n{\r\nstruct nfp_cpp_explicit *expl;\r\nchar *tmp = buff;\r\nint err, i, incr;\r\nu8 byte_mask;\r\nif (len & (width_read - 1))\r\nreturn -EINVAL;\r\nexpl = nfp_cpp_explicit_acquire(cpp);\r\nif (!expl)\r\nreturn -EBUSY;\r\nincr = min_t(int, 16 * width_read, 128);\r\nincr = min_t(int, incr, len);\r\nif (NFP_CPP_ID_ACTION_of(cpp_id) == NFP_CPP_ACTION_RW)\r\ncpp_id = NFP_CPP_ID(NFP_CPP_ID_TARGET_of(cpp_id), 0,\r\nNFP_CPP_ID_TOKEN_of(cpp_id));\r\nbyte_mask = nfp_bytemask(width_read, addr);\r\nnfp_cpp_explicit_set_target(expl, cpp_id,\r\nincr / width_read - 1, byte_mask);\r\nnfp_cpp_explicit_set_posted(expl, 1, 0, NFP_SIGNAL_PUSH,\r\n0, NFP_SIGNAL_NONE);\r\nfor (i = 0; i < len; i += incr, addr += incr, tmp += incr) {\r\nif (i + incr > len) {\r\nincr = len - i;\r\nnfp_cpp_explicit_set_target(expl, cpp_id,\r\nincr / width_read - 1,\r\n0xff);\r\n}\r\nerr = nfp_cpp_explicit_do(expl, addr);\r\nif (err < 0)\r\ngoto exit_release;\r\nerr = nfp_cpp_explicit_get(expl, tmp, incr);\r\nif (err < 0)\r\ngoto exit_release;\r\n}\r\nerr = len;\r\nexit_release:\r\nnfp_cpp_explicit_release(expl);\r\nreturn err;\r\n}\r\nint nfp_cpp_explicit_write(struct nfp_cpp *cpp, u32 cpp_id, u64 addr,\r\nconst void *buff, size_t len, int width_write)\r\n{\r\nstruct nfp_cpp_explicit *expl;\r\nconst char *tmp = buff;\r\nint err, i, incr;\r\nu8 byte_mask;\r\nif (len & (width_write - 1))\r\nreturn -EINVAL;\r\nexpl = nfp_cpp_explicit_acquire(cpp);\r\nif (!expl)\r\nreturn -EBUSY;\r\nincr = min_t(int, 16 * width_write, 128);\r\nincr = min_t(int, incr, len);\r\nif (NFP_CPP_ID_ACTION_of(cpp_id) == NFP_CPP_ACTION_RW)\r\ncpp_id = NFP_CPP_ID(NFP_CPP_ID_TARGET_of(cpp_id), 1,\r\nNFP_CPP_ID_TOKEN_of(cpp_id));\r\nbyte_mask = nfp_bytemask(width_write, addr);\r\nnfp_cpp_explicit_set_target(expl, cpp_id,\r\nincr / width_write - 1, byte_mask);\r\nnfp_cpp_explicit_set_posted(expl, 1, 0, NFP_SIGNAL_PULL,\r\n0, NFP_SIGNAL_NONE);\r\nfor (i = 0; i < len; i += incr, addr += incr, tmp += incr) {\r\nif (i + incr > len) {\r\nincr = len - i;\r\nnfp_cpp_explicit_set_target(expl, cpp_id,\r\nincr / width_write - 1,\r\n0xff);\r\n}\r\nerr = nfp_cpp_explicit_put(expl, tmp, incr);\r\nif (err < 0)\r\ngoto exit_release;\r\nerr = nfp_cpp_explicit_do(expl, addr);\r\nif (err < 0)\r\ngoto exit_release;\r\n}\r\nerr = len;\r\nexit_release:\r\nnfp_cpp_explicit_release(expl);\r\nreturn err;\r\n}\r\nu8 __iomem *\r\nnfp_cpp_map_area(struct nfp_cpp *cpp, const char *name, int domain, int target,\r\nu64 addr, unsigned long size, struct nfp_cpp_area **area)\r\n{\r\nu8 __iomem *res;\r\nu32 dest;\r\ndest = NFP_CPP_ISLAND_ID(target, NFP_CPP_ACTION_RW, 0, domain);\r\n*area = nfp_cpp_area_alloc_acquire(cpp, name, dest, addr, size);\r\nif (!*area)\r\ngoto err_eio;\r\nres = nfp_cpp_area_iomem(*area);\r\nif (!res)\r\ngoto err_release_free;\r\nreturn res;\r\nerr_release_free:\r\nnfp_cpp_area_release_free(*area);\r\nerr_eio:\r\nreturn (u8 __iomem *)ERR_PTR(-EIO);\r\n}
