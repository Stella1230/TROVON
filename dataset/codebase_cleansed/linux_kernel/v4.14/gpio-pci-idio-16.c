static int idio_16_gpio_get_direction(struct gpio_chip *chip,\r\nunsigned int offset)\r\n{\r\nif (offset > 15)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int idio_16_gpio_direction_input(struct gpio_chip *chip,\r\nunsigned int offset)\r\n{\r\nreturn 0;\r\n}\r\nstatic int idio_16_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned int offset, int value)\r\n{\r\nchip->set(chip, offset, value);\r\nreturn 0;\r\n}\r\nstatic int idio_16_gpio_get(struct gpio_chip *chip, unsigned int offset)\r\n{\r\nstruct idio_16_gpio *const idio16gpio = gpiochip_get_data(chip);\r\nunsigned long mask = BIT(offset);\r\nif (offset < 8)\r\nreturn !!(ioread8(&idio16gpio->reg->out0_7) & mask);\r\nif (offset < 16)\r\nreturn !!(ioread8(&idio16gpio->reg->out8_15) & (mask >> 8));\r\nif (offset < 24)\r\nreturn !!(ioread8(&idio16gpio->reg->in0_7) & (mask >> 16));\r\nreturn !!(ioread8(&idio16gpio->reg->in8_15) & (mask >> 24));\r\n}\r\nstatic void idio_16_gpio_set(struct gpio_chip *chip, unsigned int offset,\r\nint value)\r\n{\r\nstruct idio_16_gpio *const idio16gpio = gpiochip_get_data(chip);\r\nunsigned int mask = BIT(offset);\r\nvoid __iomem *base;\r\nunsigned long flags;\r\nunsigned int out_state;\r\nif (offset > 15)\r\nreturn;\r\nif (offset > 7) {\r\nmask >>= 8;\r\nbase = &idio16gpio->reg->out8_15;\r\n} else\r\nbase = &idio16gpio->reg->out0_7;\r\nraw_spin_lock_irqsave(&idio16gpio->lock, flags);\r\nif (value)\r\nout_state = ioread8(base) | mask;\r\nelse\r\nout_state = ioread8(base) & ~mask;\r\niowrite8(out_state, base);\r\nraw_spin_unlock_irqrestore(&idio16gpio->lock, flags);\r\n}\r\nstatic void idio_16_gpio_set_multiple(struct gpio_chip *chip,\r\nunsigned long *mask, unsigned long *bits)\r\n{\r\nstruct idio_16_gpio *const idio16gpio = gpiochip_get_data(chip);\r\nunsigned long flags;\r\nunsigned int out_state;\r\nraw_spin_lock_irqsave(&idio16gpio->lock, flags);\r\nif (*mask & 0xFF) {\r\nout_state = ioread8(&idio16gpio->reg->out0_7) & ~*mask;\r\nout_state |= *mask & *bits;\r\niowrite8(out_state, &idio16gpio->reg->out0_7);\r\n}\r\n*mask >>= 8;\r\nif (*mask & 0xFF) {\r\n*bits >>= 8;\r\nout_state = ioread8(&idio16gpio->reg->out8_15) & ~*mask;\r\nout_state |= *mask & *bits;\r\niowrite8(out_state, &idio16gpio->reg->out8_15);\r\n}\r\nraw_spin_unlock_irqrestore(&idio16gpio->lock, flags);\r\n}\r\nstatic void idio_16_irq_ack(struct irq_data *data)\r\n{\r\n}\r\nstatic void idio_16_irq_mask(struct irq_data *data)\r\n{\r\nstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\r\nstruct idio_16_gpio *const idio16gpio = gpiochip_get_data(chip);\r\nconst unsigned long mask = BIT(irqd_to_hwirq(data));\r\nunsigned long flags;\r\nidio16gpio->irq_mask &= ~mask;\r\nif (!idio16gpio->irq_mask) {\r\nraw_spin_lock_irqsave(&idio16gpio->lock, flags);\r\niowrite8(0, &idio16gpio->reg->irq_ctl);\r\nraw_spin_unlock_irqrestore(&idio16gpio->lock, flags);\r\n}\r\n}\r\nstatic void idio_16_irq_unmask(struct irq_data *data)\r\n{\r\nstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\r\nstruct idio_16_gpio *const idio16gpio = gpiochip_get_data(chip);\r\nconst unsigned long mask = BIT(irqd_to_hwirq(data));\r\nconst unsigned long prev_irq_mask = idio16gpio->irq_mask;\r\nunsigned long flags;\r\nidio16gpio->irq_mask |= mask;\r\nif (!prev_irq_mask) {\r\nraw_spin_lock_irqsave(&idio16gpio->lock, flags);\r\nioread8(&idio16gpio->reg->irq_ctl);\r\nraw_spin_unlock_irqrestore(&idio16gpio->lock, flags);\r\n}\r\n}\r\nstatic int idio_16_irq_set_type(struct irq_data *data, unsigned int flow_type)\r\n{\r\nif (flow_type != IRQ_TYPE_NONE &&\r\n(flow_type & IRQ_TYPE_EDGE_BOTH) != IRQ_TYPE_EDGE_BOTH)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t idio_16_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct idio_16_gpio *const idio16gpio = dev_id;\r\nunsigned int irq_status;\r\nstruct gpio_chip *const chip = &idio16gpio->chip;\r\nint gpio;\r\nraw_spin_lock(&idio16gpio->lock);\r\nirq_status = ioread8(&idio16gpio->reg->irq_status);\r\nraw_spin_unlock(&idio16gpio->lock);\r\nif (!(irq_status & 0x3) || !(irq_status & 0x4))\r\nreturn IRQ_NONE;\r\nfor_each_set_bit(gpio, &idio16gpio->irq_mask, chip->ngpio)\r\ngeneric_handle_irq(irq_find_mapping(chip->irqdomain, gpio));\r\nraw_spin_lock(&idio16gpio->lock);\r\niowrite8(0, &idio16gpio->reg->in0_7);\r\nraw_spin_unlock(&idio16gpio->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int idio_16_probe(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nstruct device *const dev = &pdev->dev;\r\nstruct idio_16_gpio *idio16gpio;\r\nint err;\r\nconst size_t pci_bar_index = 2;\r\nconst char *const name = pci_name(pdev);\r\nidio16gpio = devm_kzalloc(dev, sizeof(*idio16gpio), GFP_KERNEL);\r\nif (!idio16gpio)\r\nreturn -ENOMEM;\r\nerr = pcim_enable_device(pdev);\r\nif (err) {\r\ndev_err(dev, "Failed to enable PCI device (%d)\n", err);\r\nreturn err;\r\n}\r\nerr = pcim_iomap_regions(pdev, BIT(pci_bar_index), name);\r\nif (err) {\r\ndev_err(dev, "Unable to map PCI I/O addresses (%d)\n", err);\r\nreturn err;\r\n}\r\nidio16gpio->reg = pcim_iomap_table(pdev)[pci_bar_index];\r\niowrite8(0, &idio16gpio->reg->filter_ctl);\r\nidio16gpio->chip.label = name;\r\nidio16gpio->chip.parent = dev;\r\nidio16gpio->chip.owner = THIS_MODULE;\r\nidio16gpio->chip.base = -1;\r\nidio16gpio->chip.ngpio = IDIO_16_NGPIO;\r\nidio16gpio->chip.names = idio_16_names;\r\nidio16gpio->chip.get_direction = idio_16_gpio_get_direction;\r\nidio16gpio->chip.direction_input = idio_16_gpio_direction_input;\r\nidio16gpio->chip.direction_output = idio_16_gpio_direction_output;\r\nidio16gpio->chip.get = idio_16_gpio_get;\r\nidio16gpio->chip.set = idio_16_gpio_set;\r\nidio16gpio->chip.set_multiple = idio_16_gpio_set_multiple;\r\nraw_spin_lock_init(&idio16gpio->lock);\r\nerr = devm_gpiochip_add_data(dev, &idio16gpio->chip, idio16gpio);\r\nif (err) {\r\ndev_err(dev, "GPIO registering failed (%d)\n", err);\r\nreturn err;\r\n}\r\niowrite8(0, &idio16gpio->reg->irq_ctl);\r\niowrite8(0, &idio16gpio->reg->in0_7);\r\nerr = gpiochip_irqchip_add(&idio16gpio->chip, &idio_16_irqchip, 0,\r\nhandle_edge_irq, IRQ_TYPE_NONE);\r\nif (err) {\r\ndev_err(dev, "Could not add irqchip (%d)\n", err);\r\nreturn err;\r\n}\r\nerr = devm_request_irq(dev, pdev->irq, idio_16_irq_handler, IRQF_SHARED,\r\nname, idio16gpio);\r\nif (err) {\r\ndev_err(dev, "IRQ handler registering failed (%d)\n", err);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}
