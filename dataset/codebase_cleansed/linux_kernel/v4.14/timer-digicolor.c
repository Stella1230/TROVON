static struct digicolor_timer *dc_timer(struct clock_event_device *ce)\r\n{\r\nreturn container_of(ce, struct digicolor_timer, ce);\r\n}\r\nstatic inline void dc_timer_disable(struct clock_event_device *ce)\r\n{\r\nstruct digicolor_timer *dt = dc_timer(ce);\r\nwriteb(CONTROL_DISABLE, dt->base + CONTROL(dt->timer_id));\r\n}\r\nstatic inline void dc_timer_enable(struct clock_event_device *ce, u32 mode)\r\n{\r\nstruct digicolor_timer *dt = dc_timer(ce);\r\nwriteb(CONTROL_ENABLE | mode, dt->base + CONTROL(dt->timer_id));\r\n}\r\nstatic inline void dc_timer_set_count(struct clock_event_device *ce,\r\nunsigned long count)\r\n{\r\nstruct digicolor_timer *dt = dc_timer(ce);\r\nwritel(count, dt->base + COUNT(dt->timer_id));\r\n}\r\nstatic int digicolor_clkevt_shutdown(struct clock_event_device *ce)\r\n{\r\ndc_timer_disable(ce);\r\nreturn 0;\r\n}\r\nstatic int digicolor_clkevt_set_oneshot(struct clock_event_device *ce)\r\n{\r\ndc_timer_disable(ce);\r\ndc_timer_enable(ce, CONTROL_MODE_ONESHOT);\r\nreturn 0;\r\n}\r\nstatic int digicolor_clkevt_set_periodic(struct clock_event_device *ce)\r\n{\r\nstruct digicolor_timer *dt = dc_timer(ce);\r\ndc_timer_disable(ce);\r\ndc_timer_set_count(ce, dt->ticks_per_jiffy);\r\ndc_timer_enable(ce, CONTROL_MODE_PERIODIC);\r\nreturn 0;\r\n}\r\nstatic int digicolor_clkevt_next_event(unsigned long evt,\r\nstruct clock_event_device *ce)\r\n{\r\ndc_timer_disable(ce);\r\ndc_timer_set_count(ce, evt);\r\ndc_timer_enable(ce, CONTROL_MODE_ONESHOT);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t digicolor_timer_interrupt(int irq, void *dev_id)\r\n{\r\nstruct clock_event_device *evt = dev_id;\r\nevt->event_handler(evt);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic u64 notrace digicolor_timer_sched_read(void)\r\n{\r\nreturn ~readl(dc_timer_dev.base + COUNT(TIMER_B));\r\n}\r\nstatic int __init digicolor_timer_init(struct device_node *node)\r\n{\r\nunsigned long rate;\r\nstruct clk *clk;\r\nint ret, irq;\r\ndc_timer_dev.base = of_iomap(node, 0);\r\nif (!dc_timer_dev.base) {\r\npr_err("Can't map registers\n");\r\nreturn -ENXIO;\r\n}\r\nirq = irq_of_parse_and_map(node, dc_timer_dev.timer_id);\r\nif (irq <= 0) {\r\npr_err("Can't parse IRQ\n");\r\nreturn -EINVAL;\r\n}\r\nclk = of_clk_get(node, 0);\r\nif (IS_ERR(clk)) {\r\npr_err("Can't get timer clock\n");\r\nreturn PTR_ERR(clk);\r\n}\r\nclk_prepare_enable(clk);\r\nrate = clk_get_rate(clk);\r\ndc_timer_dev.ticks_per_jiffy = DIV_ROUND_UP(rate, HZ);\r\nwriteb(CONTROL_DISABLE, dc_timer_dev.base + CONTROL(TIMER_B));\r\nwritel(UINT_MAX, dc_timer_dev.base + COUNT(TIMER_B));\r\nwriteb(CONTROL_ENABLE, dc_timer_dev.base + CONTROL(TIMER_B));\r\nsched_clock_register(digicolor_timer_sched_read, 32, rate);\r\nclocksource_mmio_init(dc_timer_dev.base + COUNT(TIMER_B), node->name,\r\nrate, 340, 32, clocksource_mmio_readl_down);\r\nret = request_irq(irq, digicolor_timer_interrupt,\r\nIRQF_TIMER | IRQF_IRQPOLL, "digicolor_timerC",\r\n&dc_timer_dev.ce);\r\nif (ret) {\r\npr_warn("request of timer irq %d failed (%d)\n", irq, ret);\r\nreturn ret;\r\n}\r\ndc_timer_dev.ce.cpumask = cpu_possible_mask;\r\ndc_timer_dev.ce.irq = irq;\r\nclockevents_config_and_register(&dc_timer_dev.ce, rate, 0, 0xffffffff);\r\nreturn 0;\r\n}
