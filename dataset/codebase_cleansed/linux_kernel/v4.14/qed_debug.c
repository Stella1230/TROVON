static u32 cond5(const u32 *r, const u32 *imm)\r\n{\r\nreturn ((r[0] & imm[0]) != imm[1]) && ((r[1] & imm[2]) != imm[3]);\r\n}\r\nstatic u32 cond7(const u32 *r, const u32 *imm)\r\n{\r\nreturn ((r[0] >> imm[0]) & imm[1]) != imm[2];\r\n}\r\nstatic u32 cond14(const u32 *r, const u32 *imm)\r\n{\r\nreturn (r[0] != imm[0]) && (((r[1] >> imm[1]) & imm[2]) == imm[3]);\r\n}\r\nstatic u32 cond6(const u32 *r, const u32 *imm)\r\n{\r\nreturn (r[0] & imm[0]) != imm[1];\r\n}\r\nstatic u32 cond9(const u32 *r, const u32 *imm)\r\n{\r\nreturn ((r[0] & imm[0]) >> imm[1]) !=\r\n(((r[0] & imm[2]) >> imm[3]) | ((r[1] & imm[4]) << imm[5]));\r\n}\r\nstatic u32 cond10(const u32 *r, const u32 *imm)\r\n{\r\nreturn ((r[0] & imm[0]) >> imm[1]) != (r[0] & imm[2]);\r\n}\r\nstatic u32 cond4(const u32 *r, const u32 *imm)\r\n{\r\nreturn (r[0] & ~imm[0]) != imm[1];\r\n}\r\nstatic u32 cond0(const u32 *r, const u32 *imm)\r\n{\r\nreturn (r[0] & ~r[1]) != imm[0];\r\n}\r\nstatic u32 cond1(const u32 *r, const u32 *imm)\r\n{\r\nreturn r[0] != imm[0];\r\n}\r\nstatic u32 cond11(const u32 *r, const u32 *imm)\r\n{\r\nreturn r[0] != r[1] && r[2] == imm[0];\r\n}\r\nstatic u32 cond12(const u32 *r, const u32 *imm)\r\n{\r\nreturn r[0] != r[1] && r[2] > imm[0];\r\n}\r\nstatic u32 cond3(const u32 *r, const u32 *imm)\r\n{\r\nreturn r[0] != r[1];\r\n}\r\nstatic u32 cond13(const u32 *r, const u32 *imm)\r\n{\r\nreturn r[0] & imm[0];\r\n}\r\nstatic u32 cond8(const u32 *r, const u32 *imm)\r\n{\r\nreturn r[0] < (r[1] - imm[0]);\r\n}\r\nstatic u32 cond2(const u32 *r, const u32 *imm)\r\n{\r\nreturn r[0] > imm[0];\r\n}\r\nstatic u32 qed_read_unaligned_dword(u8 *buf)\r\n{\r\nu32 dword;\r\nmemcpy((u8 *)&dword, buf, sizeof(dword));\r\nreturn dword;\r\n}\r\nstatic u32 qed_grc_get_param(struct qed_hwfn *p_hwfn,\r\nenum dbg_grc_params grc_param)\r\n{\r\nstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\r\nreturn dev_data->grc.param_val[grc_param];\r\n}\r\nstatic void qed_dbg_grc_init_params(struct qed_hwfn *p_hwfn)\r\n{\r\nstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\r\nif (!dev_data->grc.params_initialized) {\r\nqed_dbg_grc_set_params_default(p_hwfn);\r\ndev_data->grc.params_initialized = 1;\r\n}\r\n}\r\nstatic enum dbg_status qed_dbg_dev_init(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt)\r\n{\r\nstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\r\nif (dev_data->initialized)\r\nreturn DBG_STATUS_OK;\r\nif (QED_IS_K2(p_hwfn->cdev)) {\r\ndev_data->chip_id = CHIP_K2;\r\ndev_data->mode_enable[MODE_K2] = 1;\r\n} else if (QED_IS_BB_B0(p_hwfn->cdev)) {\r\ndev_data->chip_id = CHIP_BB;\r\ndev_data->mode_enable[MODE_BB] = 1;\r\n} else {\r\nreturn DBG_STATUS_UNKNOWN_CHIP;\r\n}\r\ndev_data->platform_id = PLATFORM_ASIC;\r\ndev_data->mode_enable[MODE_ASIC] = 1;\r\nqed_dbg_grc_init_params(p_hwfn);\r\ndev_data->initialized = true;\r\nreturn DBG_STATUS_OK;\r\n}\r\nstatic struct dbg_bus_block *get_dbg_bus_block_desc(struct qed_hwfn *p_hwfn,\r\nenum block_id block_id)\r\n{\r\nstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\r\nreturn (struct dbg_bus_block *)&dbg_bus_blocks[block_id *\r\nMAX_CHIP_IDS +\r\ndev_data->chip_id];\r\n}\r\nstatic void qed_read_fw_info(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu8 storm_id, struct fw_info *fw_info)\r\n{\r\nstruct storm_defs *storm = &s_storm_defs[storm_id];\r\nstruct fw_info_location fw_info_location;\r\nu32 addr, i, *dest;\r\nmemset(&fw_info_location, 0, sizeof(fw_info_location));\r\nmemset(fw_info, 0, sizeof(*fw_info));\r\naddr = storm->sem_fast_mem_addr + SEM_FAST_REG_INT_RAM +\r\nDWORDS_TO_BYTES(SEM_FAST_REG_INT_RAM_SIZE) -\r\nsizeof(fw_info_location);\r\ndest = (u32 *)&fw_info_location;\r\nfor (i = 0; i < BYTES_TO_DWORDS(sizeof(fw_info_location));\r\ni++, addr += BYTES_IN_DWORD)\r\ndest[i] = qed_rd(p_hwfn, p_ptt, addr);\r\nif (fw_info_location.size > 0 && fw_info_location.size <=\r\nsizeof(*fw_info)) {\r\naddr = fw_info_location.grc_addr;\r\ndest = (u32 *)fw_info;\r\nfor (i = 0; i < BYTES_TO_DWORDS(fw_info_location.size);\r\ni++, addr += BYTES_IN_DWORD)\r\ndest[i] = qed_rd(p_hwfn, p_ptt, addr);\r\n}\r\n}\r\nstatic u32 qed_dump_str(char *dump_buf, bool dump, const char *str)\r\n{\r\nif (dump)\r\nstrcpy(dump_buf, str);\r\nreturn (u32)strlen(str) + 1;\r\n}\r\nstatic u32 qed_dump_align(char *dump_buf, bool dump, u32 byte_offset)\r\n{\r\nu8 offset_in_dword, align_size;\r\noffset_in_dword = (u8)(byte_offset & 0x3);\r\nalign_size = offset_in_dword ? BYTES_IN_DWORD - offset_in_dword : 0;\r\nif (dump && align_size)\r\nmemset(dump_buf, 0, align_size);\r\nreturn align_size;\r\n}\r\nstatic u32 qed_dump_str_param(u32 *dump_buf,\r\nbool dump,\r\nconst char *param_name, const char *param_val)\r\n{\r\nchar *char_buf = (char *)dump_buf;\r\nu32 offset = 0;\r\noffset += qed_dump_str(char_buf + offset, dump, param_name);\r\nif (dump)\r\n*(char_buf + offset) = 1;\r\noffset++;\r\noffset += qed_dump_str(char_buf + offset, dump, param_val);\r\noffset += qed_dump_align(char_buf + offset, dump, offset);\r\nreturn BYTES_TO_DWORDS(offset);\r\n}\r\nstatic u32 qed_dump_num_param(u32 *dump_buf,\r\nbool dump, const char *param_name, u32 param_val)\r\n{\r\nchar *char_buf = (char *)dump_buf;\r\nu32 offset = 0;\r\noffset += qed_dump_str(char_buf + offset, dump, param_name);\r\nif (dump)\r\n*(char_buf + offset) = 0;\r\noffset++;\r\noffset += qed_dump_align(char_buf + offset, dump, offset);\r\noffset = BYTES_TO_DWORDS(offset);\r\nif (dump)\r\n*(dump_buf + offset) = param_val;\r\noffset++;\r\nreturn offset;\r\n}\r\nstatic u32 qed_dump_fw_ver_param(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 *dump_buf, bool dump)\r\n{\r\nstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\r\nchar fw_ver_str[16] = EMPTY_FW_VERSION_STR;\r\nchar fw_img_str[16] = EMPTY_FW_IMAGE_STR;\r\nstruct fw_info fw_info = { {0}, {0} };\r\nu32 offset = 0;\r\nif (dump && !qed_grc_get_param(p_hwfn, DBG_GRC_PARAM_NO_FW_VER)) {\r\nbool found = false;\r\nu8 storm_id;\r\nfor (storm_id = 0; storm_id < MAX_DBG_STORMS && !found;\r\nstorm_id++) {\r\nstruct storm_defs *storm = &s_storm_defs[storm_id];\r\nif (dev_data->block_in_reset[storm->block_id])\r\ncontinue;\r\nqed_read_fw_info(p_hwfn, p_ptt, storm_id, &fw_info);\r\nif (snprintf(fw_ver_str, sizeof(fw_ver_str),\r\n"%d_%d_%d_%d", fw_info.ver.num.major,\r\nfw_info.ver.num.minor, fw_info.ver.num.rev,\r\nfw_info.ver.num.eng) < 0)\r\nDP_NOTICE(p_hwfn,\r\n"Unexpected debug error: invalid FW version string\n");\r\nswitch (fw_info.ver.image_id) {\r\ncase FW_IMG_MAIN:\r\nstrcpy(fw_img_str, "main");\r\nbreak;\r\ndefault:\r\nstrcpy(fw_img_str, "unknown");\r\nbreak;\r\n}\r\nfound = true;\r\n}\r\n}\r\noffset += qed_dump_str_param(dump_buf + offset,\r\ndump, "fw-version", fw_ver_str);\r\noffset += qed_dump_str_param(dump_buf + offset,\r\ndump, "fw-image", fw_img_str);\r\noffset += qed_dump_num_param(dump_buf + offset,\r\ndump,\r\n"fw-timestamp", fw_info.ver.timestamp);\r\nreturn offset;\r\n}\r\nstatic u32 qed_dump_mfw_ver_param(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 *dump_buf, bool dump)\r\n{\r\nchar mfw_ver_str[16] = EMPTY_FW_VERSION_STR;\r\nif (dump &&\r\n!qed_grc_get_param(p_hwfn, DBG_GRC_PARAM_NO_FW_VER)) {\r\nu32 global_section_offsize, global_section_addr, mfw_ver;\r\nu32 public_data_addr, global_section_offsize_addr;\r\npublic_data_addr = qed_rd(p_hwfn,\r\np_ptt,\r\nMISC_REG_SHARED_MEM_ADDR) |\r\nMCP_REG_SCRATCH;\r\nglobal_section_offsize_addr = public_data_addr +\r\noffsetof(struct mcp_public_data,\r\nsections) +\r\nsizeof(offsize_t) * PUBLIC_GLOBAL;\r\nglobal_section_offsize = qed_rd(p_hwfn, p_ptt,\r\nglobal_section_offsize_addr);\r\nglobal_section_addr =\r\nMCP_REG_SCRATCH +\r\n(global_section_offsize & OFFSIZE_OFFSET_MASK) * 4;\r\nmfw_ver = qed_rd(p_hwfn, p_ptt,\r\nglobal_section_addr +\r\noffsetof(struct public_global, mfw_ver));\r\nif (snprintf(mfw_ver_str, sizeof(mfw_ver_str), "%d_%d_%d_%d",\r\n(u8)(mfw_ver >> 24), (u8)(mfw_ver >> 16),\r\n(u8)(mfw_ver >> 8), (u8)mfw_ver) < 0)\r\nDP_NOTICE(p_hwfn,\r\n"Unexpected debug error: invalid MFW version string\n");\r\n}\r\nreturn qed_dump_str_param(dump_buf, dump, "mfw-version", mfw_ver_str);\r\n}\r\nstatic u32 qed_dump_section_hdr(u32 *dump_buf,\r\nbool dump, const char *name, u32 num_params)\r\n{\r\nreturn qed_dump_num_param(dump_buf, dump, name, num_params);\r\n}\r\nstatic u32 qed_dump_common_global_params(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 *dump_buf,\r\nbool dump,\r\nu8 num_specific_global_params)\r\n{\r\nstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\r\nu32 offset = 0;\r\nu8 num_params;\r\nnum_params = NUM_COMMON_GLOBAL_PARAMS + num_specific_global_params;\r\noffset += qed_dump_section_hdr(dump_buf + offset,\r\ndump, "global_params", num_params);\r\noffset += qed_dump_fw_ver_param(p_hwfn, p_ptt, dump_buf + offset, dump);\r\noffset += qed_dump_mfw_ver_param(p_hwfn,\r\np_ptt, dump_buf + offset, dump);\r\noffset += qed_dump_num_param(dump_buf + offset,\r\ndump, "tools-version", TOOLS_VERSION);\r\noffset += qed_dump_str_param(dump_buf + offset,\r\ndump,\r\n"chip",\r\ns_chip_defs[dev_data->chip_id].name);\r\noffset += qed_dump_str_param(dump_buf + offset,\r\ndump,\r\n"platform",\r\ns_platform_defs[dev_data->platform_id].\r\nname);\r\noffset +=\r\nqed_dump_num_param(dump_buf + offset, dump, "pci-func",\r\np_hwfn->abs_pf_id);\r\nreturn offset;\r\n}\r\nstatic u32 qed_dump_last_section(struct qed_hwfn *p_hwfn,\r\nu32 *dump_buf, u32 offset, bool dump)\r\n{\r\nu32 start_offset = offset;\r\noffset += qed_dump_section_hdr(dump_buf + offset, dump, "last", 0);\r\nif (dump)\r\n*(dump_buf + offset) = ~crc32(0xffffffff,\r\n(u8 *)dump_buf,\r\nDWORDS_TO_BYTES(offset));\r\noffset++;\r\nreturn offset - start_offset;\r\n}\r\nstatic void qed_update_blocks_reset_state(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt)\r\n{\r\nstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\r\nu32 reg_val[MAX_DBG_RESET_REGS] = { 0 };\r\nu32 i;\r\nfor (i = 0; i < MAX_DBG_RESET_REGS; i++)\r\nif (s_reset_regs_defs[i].exists[dev_data->chip_id])\r\nreg_val[i] = qed_rd(p_hwfn,\r\np_ptt, s_reset_regs_defs[i].addr);\r\nfor (i = 0; i < MAX_BLOCK_ID; i++) {\r\nstruct block_defs *block = s_block_defs[i];\r\ndev_data->block_in_reset[i] = block->has_reset_bit &&\r\n!(reg_val[block->reset_reg] & BIT(block->reset_bit_offset));\r\n}\r\n}\r\nstatic void qed_bus_enable_dbg_block(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt, bool enable)\r\n{\r\nqed_wr(p_hwfn, p_ptt, DBG_REG_DBG_BLOCK_ON, enable ? 1 : 0);\r\n}\r\nstatic void qed_bus_reset_dbg_block(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt)\r\n{\r\nu32 dbg_reset_reg_addr, old_reset_reg_val, new_reset_reg_val;\r\nstruct block_defs *dbg_block = s_block_defs[BLOCK_DBG];\r\ndbg_reset_reg_addr = s_reset_regs_defs[dbg_block->reset_reg].addr;\r\nold_reset_reg_val = qed_rd(p_hwfn, p_ptt, dbg_reset_reg_addr);\r\nnew_reset_reg_val =\r\nold_reset_reg_val & ~BIT(dbg_block->reset_bit_offset);\r\nqed_wr(p_hwfn, p_ptt, dbg_reset_reg_addr, new_reset_reg_val);\r\nqed_wr(p_hwfn, p_ptt, dbg_reset_reg_addr, old_reset_reg_val);\r\n}\r\nstatic void qed_bus_set_framing_mode(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nenum dbg_bus_frame_modes mode)\r\n{\r\nqed_wr(p_hwfn, p_ptt, DBG_REG_FRAMING_MODE, (u8)mode);\r\n}\r\nstatic void qed_bus_enable_clients(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt, u32 client_mask)\r\n{\r\nqed_wr(p_hwfn, p_ptt, DBG_REG_CLIENT_ENABLE, client_mask);\r\n}\r\nstatic bool qed_is_mode_match(struct qed_hwfn *p_hwfn, u16 *modes_buf_offset)\r\n{\r\nstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\r\nbool arg1, arg2;\r\nconst u32 *ptr;\r\nu8 tree_val;\r\nptr = s_dbg_arrays[BIN_BUF_DBG_MODE_TREE].ptr;\r\ntree_val = ((u8 *)ptr)[(*modes_buf_offset)++];\r\nswitch (tree_val) {\r\ncase INIT_MODE_OP_NOT:\r\nreturn !qed_is_mode_match(p_hwfn, modes_buf_offset);\r\ncase INIT_MODE_OP_OR:\r\ncase INIT_MODE_OP_AND:\r\narg1 = qed_is_mode_match(p_hwfn, modes_buf_offset);\r\narg2 = qed_is_mode_match(p_hwfn, modes_buf_offset);\r\nreturn (tree_val == INIT_MODE_OP_OR) ? (arg1 ||\r\narg2) : (arg1 && arg2);\r\ndefault:\r\nreturn dev_data->mode_enable[tree_val - MAX_INIT_MODE_OPS] > 0;\r\n}\r\n}\r\nstatic bool qed_grc_is_included(struct qed_hwfn *p_hwfn,\r\nenum dbg_grc_params grc_param)\r\n{\r\nreturn qed_grc_get_param(p_hwfn, grc_param) > 0;\r\n}\r\nstatic bool qed_grc_is_storm_included(struct qed_hwfn *p_hwfn,\r\nenum dbg_storms storm)\r\n{\r\nreturn qed_grc_get_param(p_hwfn, (enum dbg_grc_params)storm) > 0;\r\n}\r\nstatic bool qed_grc_is_mem_included(struct qed_hwfn *p_hwfn,\r\nenum block_id block_id, u8 mem_group_id)\r\n{\r\nstruct block_defs *block = s_block_defs[block_id];\r\nu8 i;\r\nif (block->associated_to_storm &&\r\n!qed_grc_is_storm_included(p_hwfn,\r\n(enum dbg_storms)block->storm_id))\r\nreturn false;\r\nfor (i = 0; i < NUM_BIG_RAM_TYPES; i++) {\r\nstruct big_ram_defs *big_ram = &s_big_ram_defs[i];\r\nif (mem_group_id == big_ram->mem_group_id ||\r\nmem_group_id == big_ram->ram_mem_group_id)\r\nreturn qed_grc_is_included(p_hwfn, big_ram->grc_param);\r\n}\r\nswitch (mem_group_id) {\r\ncase MEM_GROUP_PXP_ILT:\r\ncase MEM_GROUP_PXP_MEM:\r\nreturn qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_PXP);\r\ncase MEM_GROUP_RAM:\r\nreturn qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_RAM);\r\ncase MEM_GROUP_PBUF:\r\nreturn qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_PBUF);\r\ncase MEM_GROUP_CAU_MEM:\r\ncase MEM_GROUP_CAU_SB:\r\ncase MEM_GROUP_CAU_PI:\r\nreturn qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_CAU);\r\ncase MEM_GROUP_QM_MEM:\r\nreturn qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_QM);\r\ncase MEM_GROUP_CFC_MEM:\r\ncase MEM_GROUP_CONN_CFC_MEM:\r\ncase MEM_GROUP_TASK_CFC_MEM:\r\nreturn qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_CFC);\r\ncase MEM_GROUP_IGU_MEM:\r\ncase MEM_GROUP_IGU_MSIX:\r\nreturn qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_IGU);\r\ncase MEM_GROUP_MULD_MEM:\r\nreturn qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_MULD);\r\ncase MEM_GROUP_PRS_MEM:\r\nreturn qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_PRS);\r\ncase MEM_GROUP_DMAE_MEM:\r\nreturn qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_DMAE);\r\ncase MEM_GROUP_TM_MEM:\r\nreturn qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_TM);\r\ncase MEM_GROUP_SDM_MEM:\r\nreturn qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_SDM);\r\ncase MEM_GROUP_TDIF_CTX:\r\ncase MEM_GROUP_RDIF_CTX:\r\nreturn qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_DIF);\r\ncase MEM_GROUP_CM_MEM:\r\nreturn qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_CM);\r\ncase MEM_GROUP_IOR:\r\nreturn qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_IOR);\r\ndefault:\r\nreturn true;\r\n}\r\n}\r\nstatic void qed_grc_stall_storms(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt, bool stall)\r\n{\r\nu32 reg_addr;\r\nu8 storm_id;\r\nfor (storm_id = 0; storm_id < MAX_DBG_STORMS; storm_id++) {\r\nif (!qed_grc_is_storm_included(p_hwfn,\r\n(enum dbg_storms)storm_id))\r\ncontinue;\r\nreg_addr = s_storm_defs[storm_id].sem_fast_mem_addr +\r\nSEM_FAST_REG_STALL_0_BB_K2;\r\nqed_wr(p_hwfn, p_ptt, reg_addr, stall ? 1 : 0);\r\n}\r\nmsleep(STALL_DELAY_MS);\r\n}\r\nstatic void qed_grc_unreset_blocks(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt)\r\n{\r\nstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\r\nu32 reg_val[MAX_DBG_RESET_REGS] = { 0 };\r\nu32 block_id, i;\r\nfor (block_id = 0; block_id < MAX_BLOCK_ID; block_id++) {\r\nstruct block_defs *block = s_block_defs[block_id];\r\nif (block->has_reset_bit && block->unreset)\r\nreg_val[block->reset_reg] |=\r\nBIT(block->reset_bit_offset);\r\n}\r\nfor (i = 0; i < MAX_DBG_RESET_REGS; i++) {\r\nif (!s_reset_regs_defs[i].exists[dev_data->chip_id])\r\ncontinue;\r\nreg_val[i] |= s_reset_regs_defs[i].unreset_val;\r\nif (reg_val[i])\r\nqed_wr(p_hwfn,\r\np_ptt,\r\ns_reset_regs_defs[i].addr +\r\nRESET_REG_UNRESET_OFFSET, reg_val[i]);\r\n}\r\n}\r\nstatic const struct dbg_attn_block_type_data *\r\nqed_get_block_attn_data(enum block_id block_id, enum dbg_attn_type attn_type)\r\n{\r\nconst struct dbg_attn_block *base_attn_block_arr =\r\n(const struct dbg_attn_block *)\r\ns_dbg_arrays[BIN_BUF_DBG_ATTN_BLOCKS].ptr;\r\nreturn &base_attn_block_arr[block_id].per_type_data[attn_type];\r\n}\r\nstatic const struct dbg_attn_reg *\r\nqed_get_block_attn_regs(enum block_id block_id, enum dbg_attn_type attn_type,\r\nu8 *num_attn_regs)\r\n{\r\nconst struct dbg_attn_block_type_data *block_type_data =\r\nqed_get_block_attn_data(block_id, attn_type);\r\n*num_attn_regs = block_type_data->num_regs;\r\nreturn &((const struct dbg_attn_reg *)\r\ns_dbg_arrays[BIN_BUF_DBG_ATTN_REGS].ptr)[block_type_data->\r\nregs_offset];\r\n}\r\nstatic void qed_grc_clear_all_prty(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt)\r\n{\r\nstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\r\nconst struct dbg_attn_reg *attn_reg_arr;\r\nu8 reg_idx, num_attn_regs;\r\nu32 block_id;\r\nfor (block_id = 0; block_id < MAX_BLOCK_ID; block_id++) {\r\nif (dev_data->block_in_reset[block_id])\r\ncontinue;\r\nattn_reg_arr = qed_get_block_attn_regs((enum block_id)block_id,\r\nATTN_TYPE_PARITY,\r\n&num_attn_regs);\r\nfor (reg_idx = 0; reg_idx < num_attn_regs; reg_idx++) {\r\nconst struct dbg_attn_reg *reg_data =\r\n&attn_reg_arr[reg_idx];\r\nu16 modes_buf_offset;\r\nbool eval_mode;\r\neval_mode = GET_FIELD(reg_data->mode.data,\r\nDBG_MODE_HDR_EVAL_MODE) > 0;\r\nmodes_buf_offset =\r\nGET_FIELD(reg_data->mode.data,\r\nDBG_MODE_HDR_MODES_BUF_OFFSET);\r\nif (!eval_mode ||\r\nqed_is_mode_match(p_hwfn, &modes_buf_offset))\r\nqed_rd(p_hwfn, p_ptt,\r\nDWORDS_TO_BYTES(reg_data->\r\nsts_clr_address));\r\n}\r\n}\r\n}\r\nstatic u32 qed_grc_dump_regs_hdr(u32 *dump_buf,\r\nbool dump,\r\nu32 num_reg_entries,\r\nconst char *split_type,\r\nint split_id,\r\nconst char *param_name, const char *param_val)\r\n{\r\nu8 num_params = 2 + (split_id >= 0 ? 1 : 0) + (param_name ? 1 : 0);\r\nu32 offset = 0;\r\noffset += qed_dump_section_hdr(dump_buf + offset,\r\ndump, "grc_regs", num_params);\r\noffset += qed_dump_num_param(dump_buf + offset,\r\ndump, "count", num_reg_entries);\r\noffset += qed_dump_str_param(dump_buf + offset,\r\ndump, "split", split_type);\r\nif (split_id >= 0)\r\noffset += qed_dump_num_param(dump_buf + offset,\r\ndump, "id", split_id);\r\nif (param_name && param_val)\r\noffset += qed_dump_str_param(dump_buf + offset,\r\ndump, param_name, param_val);\r\nreturn offset;\r\n}\r\nstatic u32 qed_grc_dump_addr_range(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 *dump_buf,\r\nbool dump, u32 addr, u32 len, bool wide_bus)\r\n{\r\nu32 byte_addr = DWORDS_TO_BYTES(addr), offset = 0, i;\r\nif (!dump)\r\nreturn len;\r\nfor (i = 0; i < len; i++, byte_addr += BYTES_IN_DWORD, offset++)\r\n*(dump_buf + offset) = qed_rd(p_hwfn, p_ptt, byte_addr);\r\nreturn offset;\r\n}\r\nstatic u32 qed_grc_dump_reg_entry_hdr(u32 *dump_buf,\r\nbool dump, u32 addr, u32 len)\r\n{\r\nif (dump)\r\n*dump_buf = addr | (len << REG_DUMP_LEN_SHIFT);\r\nreturn 1;\r\n}\r\nstatic u32 qed_grc_dump_reg_entry(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 *dump_buf,\r\nbool dump, u32 addr, u32 len, bool wide_bus)\r\n{\r\nu32 offset = 0;\r\noffset += qed_grc_dump_reg_entry_hdr(dump_buf, dump, addr, len);\r\noffset += qed_grc_dump_addr_range(p_hwfn,\r\np_ptt,\r\ndump_buf + offset,\r\ndump, addr, len, wide_bus);\r\nreturn offset;\r\n}\r\nstatic u32 qed_grc_dump_reg_entry_skip(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 *dump_buf,\r\nbool dump,\r\nu32 addr,\r\nu32 total_len,\r\nu32 read_len, u32 skip_len)\r\n{\r\nu32 offset = 0, reg_offset = 0;\r\noffset += qed_grc_dump_reg_entry_hdr(dump_buf, dump, addr, total_len);\r\nif (!dump)\r\nreturn offset + total_len;\r\nwhile (reg_offset < total_len) {\r\nu32 curr_len = min_t(u32, read_len, total_len - reg_offset);\r\noffset += qed_grc_dump_addr_range(p_hwfn,\r\np_ptt,\r\ndump_buf + offset,\r\ndump, addr, curr_len, false);\r\nreg_offset += curr_len;\r\naddr += curr_len;\r\nif (reg_offset < total_len) {\r\ncurr_len = min_t(u32, skip_len, total_len - skip_len);\r\nmemset(dump_buf + offset, 0, DWORDS_TO_BYTES(curr_len));\r\noffset += curr_len;\r\nreg_offset += curr_len;\r\naddr += curr_len;\r\n}\r\n}\r\nreturn offset;\r\n}\r\nstatic u32 qed_grc_dump_regs_entries(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nstruct dbg_array input_regs_arr,\r\nu32 *dump_buf,\r\nbool dump,\r\nbool block_enable[MAX_BLOCK_ID],\r\nu32 *num_dumped_reg_entries)\r\n{\r\nu32 i, offset = 0, input_offset = 0;\r\nbool mode_match = true;\r\n*num_dumped_reg_entries = 0;\r\nwhile (input_offset < input_regs_arr.size_in_dwords) {\r\nconst struct dbg_dump_cond_hdr *cond_hdr =\r\n(const struct dbg_dump_cond_hdr *)\r\n&input_regs_arr.ptr[input_offset++];\r\nu16 modes_buf_offset;\r\nbool eval_mode;\r\neval_mode = GET_FIELD(cond_hdr->mode.data,\r\nDBG_MODE_HDR_EVAL_MODE) > 0;\r\nif (eval_mode) {\r\nmodes_buf_offset =\r\nGET_FIELD(cond_hdr->mode.data,\r\nDBG_MODE_HDR_MODES_BUF_OFFSET);\r\nmode_match = qed_is_mode_match(p_hwfn,\r\n&modes_buf_offset);\r\n}\r\nif (!mode_match || !block_enable[cond_hdr->block_id]) {\r\ninput_offset += cond_hdr->data_size;\r\ncontinue;\r\n}\r\nfor (i = 0; i < cond_hdr->data_size; i++, input_offset++) {\r\nconst struct dbg_dump_reg *reg =\r\n(const struct dbg_dump_reg *)\r\n&input_regs_arr.ptr[input_offset];\r\nu32 addr, len;\r\nbool wide_bus;\r\naddr = GET_FIELD(reg->data, DBG_DUMP_REG_ADDRESS);\r\nlen = GET_FIELD(reg->data, DBG_DUMP_REG_LENGTH);\r\nwide_bus = GET_FIELD(reg->data, DBG_DUMP_REG_WIDE_BUS);\r\noffset += qed_grc_dump_reg_entry(p_hwfn,\r\np_ptt,\r\ndump_buf + offset,\r\ndump,\r\naddr,\r\nlen,\r\nwide_bus);\r\n(*num_dumped_reg_entries)++;\r\n}\r\n}\r\nreturn offset;\r\n}\r\nstatic u32 qed_grc_dump_split_data(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nstruct dbg_array input_regs_arr,\r\nu32 *dump_buf,\r\nbool dump,\r\nbool block_enable[MAX_BLOCK_ID],\r\nconst char *split_type_name,\r\nu32 split_id,\r\nconst char *param_name,\r\nconst char *param_val)\r\n{\r\nu32 num_dumped_reg_entries, offset;\r\noffset = qed_grc_dump_regs_hdr(dump_buf,\r\nfalse,\r\n0,\r\nsplit_type_name,\r\nsplit_id, param_name, param_val);\r\noffset += qed_grc_dump_regs_entries(p_hwfn,\r\np_ptt,\r\ninput_regs_arr,\r\ndump_buf + offset,\r\ndump,\r\nblock_enable,\r\n&num_dumped_reg_entries);\r\nif (dump && num_dumped_reg_entries > 0)\r\nqed_grc_dump_regs_hdr(dump_buf,\r\ndump,\r\nnum_dumped_reg_entries,\r\nsplit_type_name,\r\nsplit_id, param_name, param_val);\r\nreturn num_dumped_reg_entries > 0 ? offset : 0;\r\n}\r\nstatic u32 qed_grc_dump_registers(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 *dump_buf,\r\nbool dump,\r\nbool block_enable[MAX_BLOCK_ID],\r\nconst char *param_name, const char *param_val)\r\n{\r\nstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\r\nstruct chip_platform_defs *chip_platform;\r\nu32 offset = 0, input_offset = 0;\r\nstruct chip_defs *chip;\r\nu8 port_id, pf_id, vf_id;\r\nu16 fid;\r\nchip = &s_chip_defs[dev_data->chip_id];\r\nchip_platform = &chip->per_platform[dev_data->platform_id];\r\nif (dump)\r\nDP_VERBOSE(p_hwfn, QED_MSG_DEBUG, "Dumping registers...\n");\r\nwhile (input_offset <\r\ns_dbg_arrays[BIN_BUF_DBG_DUMP_REG].size_in_dwords) {\r\nconst struct dbg_dump_split_hdr *split_hdr;\r\nstruct dbg_array curr_input_regs_arr;\r\nu32 split_data_size;\r\nu8 split_type_id;\r\nsplit_hdr =\r\n(const struct dbg_dump_split_hdr *)\r\n&s_dbg_arrays[BIN_BUF_DBG_DUMP_REG].ptr[input_offset++];\r\nsplit_type_id =\r\nGET_FIELD(split_hdr->hdr,\r\nDBG_DUMP_SPLIT_HDR_SPLIT_TYPE_ID);\r\nsplit_data_size =\r\nGET_FIELD(split_hdr->hdr,\r\nDBG_DUMP_SPLIT_HDR_DATA_SIZE);\r\ncurr_input_regs_arr.ptr =\r\n&s_dbg_arrays[BIN_BUF_DBG_DUMP_REG].ptr[input_offset];\r\ncurr_input_regs_arr.size_in_dwords = split_data_size;\r\nswitch (split_type_id) {\r\ncase SPLIT_TYPE_NONE:\r\noffset += qed_grc_dump_split_data(p_hwfn,\r\np_ptt,\r\ncurr_input_regs_arr,\r\ndump_buf + offset,\r\ndump,\r\nblock_enable,\r\n"eng",\r\n(u32)(-1),\r\nparam_name,\r\nparam_val);\r\nbreak;\r\ncase SPLIT_TYPE_PORT:\r\nfor (port_id = 0; port_id < chip_platform->num_ports;\r\nport_id++) {\r\nif (dump)\r\nqed_port_pretend(p_hwfn, p_ptt,\r\nport_id);\r\noffset +=\r\nqed_grc_dump_split_data(p_hwfn, p_ptt,\r\ncurr_input_regs_arr,\r\ndump_buf + offset,\r\ndump, block_enable,\r\n"port", port_id,\r\nparam_name,\r\nparam_val);\r\n}\r\nbreak;\r\ncase SPLIT_TYPE_PF:\r\ncase SPLIT_TYPE_PORT_PF:\r\nfor (pf_id = 0; pf_id < chip_platform->num_pfs;\r\npf_id++) {\r\nu8 pfid_shift =\r\nPXP_PRETEND_CONCRETE_FID_PFID_SHIFT;\r\nif (dump) {\r\nfid = pf_id << pfid_shift;\r\nqed_fid_pretend(p_hwfn, p_ptt, fid);\r\n}\r\noffset +=\r\nqed_grc_dump_split_data(p_hwfn,\r\np_ptt,\r\ncurr_input_regs_arr,\r\ndump_buf + offset,\r\ndump,\r\nblock_enable,\r\n"pf",\r\npf_id,\r\nparam_name,\r\nparam_val);\r\n}\r\nbreak;\r\ncase SPLIT_TYPE_VF:\r\nfor (vf_id = 0; vf_id < chip_platform->num_vfs;\r\nvf_id++) {\r\nu8 vfvalid_shift =\r\nPXP_PRETEND_CONCRETE_FID_VFVALID_SHIFT;\r\nu8 vfid_shift =\r\nPXP_PRETEND_CONCRETE_FID_VFID_SHIFT;\r\nif (dump) {\r\nfid = BIT(vfvalid_shift) |\r\n(vf_id << vfid_shift);\r\nqed_fid_pretend(p_hwfn, p_ptt, fid);\r\n}\r\noffset +=\r\nqed_grc_dump_split_data(p_hwfn, p_ptt,\r\ncurr_input_regs_arr,\r\ndump_buf + offset,\r\ndump, block_enable,\r\n"vf", vf_id,\r\nparam_name,\r\nparam_val);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ninput_offset += split_data_size;\r\n}\r\nif (dump) {\r\nfid = p_hwfn->rel_pf_id << PXP_PRETEND_CONCRETE_FID_PFID_SHIFT;\r\nqed_fid_pretend(p_hwfn, p_ptt, fid);\r\n}\r\nreturn offset;\r\n}\r\nstatic u32 qed_grc_dump_reset_regs(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 *dump_buf, bool dump)\r\n{\r\nstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\r\nu32 i, offset = 0, num_regs = 0;\r\noffset += qed_grc_dump_regs_hdr(dump_buf,\r\nfalse, 0, "eng", -1, NULL, NULL);\r\nfor (i = 0; i < MAX_DBG_RESET_REGS; i++) {\r\nif (!s_reset_regs_defs[i].exists[dev_data->chip_id])\r\ncontinue;\r\noffset += qed_grc_dump_reg_entry(p_hwfn,\r\np_ptt,\r\ndump_buf + offset,\r\ndump,\r\nBYTES_TO_DWORDS\r\n(s_reset_regs_defs[i].addr), 1,\r\nfalse);\r\nnum_regs++;\r\n}\r\nif (dump)\r\nqed_grc_dump_regs_hdr(dump_buf,\r\ntrue, num_regs, "eng", -1, NULL, NULL);\r\nreturn offset;\r\n}\r\nstatic u32 qed_grc_dump_modified_regs(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 *dump_buf, bool dump)\r\n{\r\nstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\r\nu32 block_id, offset = 0, num_reg_entries = 0;\r\nconst struct dbg_attn_reg *attn_reg_arr;\r\nu8 storm_id, reg_idx, num_attn_regs;\r\noffset += qed_grc_dump_regs_hdr(dump_buf,\r\nfalse, 0, "eng", -1, NULL, NULL);\r\nfor (block_id = 0; block_id < MAX_BLOCK_ID; block_id++) {\r\nif (dev_data->block_in_reset[block_id] && dump)\r\ncontinue;\r\nattn_reg_arr = qed_get_block_attn_regs((enum block_id)block_id,\r\nATTN_TYPE_PARITY,\r\n&num_attn_regs);\r\nfor (reg_idx = 0; reg_idx < num_attn_regs; reg_idx++) {\r\nconst struct dbg_attn_reg *reg_data =\r\n&attn_reg_arr[reg_idx];\r\nu16 modes_buf_offset;\r\nbool eval_mode;\r\nu32 addr;\r\neval_mode = GET_FIELD(reg_data->mode.data,\r\nDBG_MODE_HDR_EVAL_MODE) > 0;\r\nmodes_buf_offset =\r\nGET_FIELD(reg_data->mode.data,\r\nDBG_MODE_HDR_MODES_BUF_OFFSET);\r\nif (eval_mode &&\r\n!qed_is_mode_match(p_hwfn, &modes_buf_offset))\r\ncontinue;\r\naddr = reg_data->mask_address;\r\noffset += qed_grc_dump_reg_entry(p_hwfn,\r\np_ptt,\r\ndump_buf + offset,\r\ndump,\r\naddr,\r\n1, false);\r\naddr = GET_FIELD(reg_data->data,\r\nDBG_ATTN_REG_STS_ADDRESS);\r\noffset += qed_grc_dump_reg_entry(p_hwfn,\r\np_ptt,\r\ndump_buf + offset,\r\ndump,\r\naddr,\r\n1, false);\r\nnum_reg_entries += 2;\r\n}\r\n}\r\nfor (storm_id = 0; storm_id < MAX_DBG_STORMS; storm_id++) {\r\nstruct storm_defs *storm = &s_storm_defs[storm_id];\r\nu32 addr;\r\nif (dev_data->block_in_reset[storm->block_id] && dump)\r\ncontinue;\r\naddr =\r\nBYTES_TO_DWORDS(s_storm_defs[storm_id].sem_fast_mem_addr +\r\nSEM_FAST_REG_STALLED);\r\noffset += qed_grc_dump_reg_entry(p_hwfn,\r\np_ptt,\r\ndump_buf + offset,\r\ndump,\r\naddr,\r\n1,\r\nfalse);\r\nnum_reg_entries++;\r\n}\r\nif (dump)\r\nqed_grc_dump_regs_hdr(dump_buf,\r\ntrue,\r\nnum_reg_entries, "eng", -1, NULL, NULL);\r\nreturn offset;\r\n}\r\nstatic u32 qed_grc_dump_special_regs(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 *dump_buf, bool dump)\r\n{\r\nu32 offset = 0, addr;\r\noffset += qed_grc_dump_regs_hdr(dump_buf,\r\ndump, 2, "eng", -1, NULL, NULL);\r\naddr = BYTES_TO_DWORDS(RDIF_REG_DEBUG_ERROR_INFO);\r\noffset += qed_grc_dump_reg_entry_skip(p_hwfn,\r\np_ptt,\r\ndump_buf + offset,\r\ndump,\r\naddr,\r\nRDIF_REG_DEBUG_ERROR_INFO_SIZE,\r\n7,\r\n1);\r\naddr = BYTES_TO_DWORDS(TDIF_REG_DEBUG_ERROR_INFO);\r\noffset +=\r\nqed_grc_dump_reg_entry_skip(p_hwfn,\r\np_ptt,\r\ndump_buf + offset,\r\ndump,\r\naddr,\r\nTDIF_REG_DEBUG_ERROR_INFO_SIZE,\r\n7,\r\n1);\r\nreturn offset;\r\n}\r\nstatic u32 qed_grc_dump_mem_hdr(struct qed_hwfn *p_hwfn,\r\nu32 *dump_buf,\r\nbool dump,\r\nconst char *name,\r\nu32 addr,\r\nu32 len,\r\nu32 bit_width,\r\nbool packed,\r\nconst char *mem_group,\r\nbool is_storm, char storm_letter)\r\n{\r\nu8 num_params = 3;\r\nu32 offset = 0;\r\nchar buf[64];\r\nif (!len)\r\nDP_NOTICE(p_hwfn,\r\n"Unexpected GRC Dump error: dumped memory size must be non-zero\n");\r\nif (bit_width)\r\nnum_params++;\r\nif (packed)\r\nnum_params++;\r\noffset += qed_dump_section_hdr(dump_buf + offset,\r\ndump, "grc_mem", num_params);\r\nif (name) {\r\nif (is_storm) {\r\nstrcpy(buf, "?STORM_");\r\nbuf[0] = storm_letter;\r\nstrcpy(buf + strlen(buf), name);\r\n} else {\r\nstrcpy(buf, name);\r\n}\r\noffset += qed_dump_str_param(dump_buf + offset,\r\ndump, "name", buf);\r\nif (dump)\r\nDP_VERBOSE(p_hwfn,\r\nQED_MSG_DEBUG,\r\n"Dumping %d registers from %s...\n",\r\nlen, buf);\r\n} else {\r\nu32 addr_in_bytes = DWORDS_TO_BYTES(addr);\r\noffset += qed_dump_num_param(dump_buf + offset,\r\ndump, "addr", addr_in_bytes);\r\nif (dump && len > 64)\r\nDP_VERBOSE(p_hwfn,\r\nQED_MSG_DEBUG,\r\n"Dumping %d registers from address 0x%x...\n",\r\nlen, addr_in_bytes);\r\n}\r\noffset += qed_dump_num_param(dump_buf + offset, dump, "len", len);\r\nif (bit_width)\r\noffset += qed_dump_num_param(dump_buf + offset,\r\ndump, "width", bit_width);\r\nif (packed)\r\noffset += qed_dump_num_param(dump_buf + offset,\r\ndump, "packed", 1);\r\nif (is_storm) {\r\nstrcpy(buf, "?STORM_");\r\nbuf[0] = storm_letter;\r\nstrcpy(buf + strlen(buf), mem_group);\r\n} else {\r\nstrcpy(buf, mem_group);\r\n}\r\noffset += qed_dump_str_param(dump_buf + offset, dump, "type", buf);\r\nreturn offset;\r\n}\r\nstatic u32 qed_grc_dump_mem(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 *dump_buf,\r\nbool dump,\r\nconst char *name,\r\nu32 addr,\r\nu32 len,\r\nbool wide_bus,\r\nu32 bit_width,\r\nbool packed,\r\nconst char *mem_group,\r\nbool is_storm, char storm_letter)\r\n{\r\nu32 offset = 0;\r\noffset += qed_grc_dump_mem_hdr(p_hwfn,\r\ndump_buf + offset,\r\ndump,\r\nname,\r\naddr,\r\nlen,\r\nbit_width,\r\npacked,\r\nmem_group, is_storm, storm_letter);\r\noffset += qed_grc_dump_addr_range(p_hwfn,\r\np_ptt,\r\ndump_buf + offset,\r\ndump, addr, len, wide_bus);\r\nreturn offset;\r\n}\r\nstatic u32 qed_grc_dump_mem_entries(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nstruct dbg_array input_mems_arr,\r\nu32 *dump_buf, bool dump)\r\n{\r\nu32 i, offset = 0, input_offset = 0;\r\nbool mode_match = true;\r\nwhile (input_offset < input_mems_arr.size_in_dwords) {\r\nconst struct dbg_dump_cond_hdr *cond_hdr;\r\nu16 modes_buf_offset;\r\nu32 num_entries;\r\nbool eval_mode;\r\ncond_hdr = (const struct dbg_dump_cond_hdr *)\r\n&input_mems_arr.ptr[input_offset++];\r\nnum_entries = cond_hdr->data_size / MEM_DUMP_ENTRY_SIZE_DWORDS;\r\neval_mode = GET_FIELD(cond_hdr->mode.data,\r\nDBG_MODE_HDR_EVAL_MODE) > 0;\r\nif (eval_mode) {\r\nmodes_buf_offset =\r\nGET_FIELD(cond_hdr->mode.data,\r\nDBG_MODE_HDR_MODES_BUF_OFFSET);\r\nmode_match = qed_is_mode_match(p_hwfn,\r\n&modes_buf_offset);\r\n}\r\nif (!mode_match) {\r\ninput_offset += cond_hdr->data_size;\r\ncontinue;\r\n}\r\nfor (i = 0; i < num_entries;\r\ni++, input_offset += MEM_DUMP_ENTRY_SIZE_DWORDS) {\r\nconst struct dbg_dump_mem *mem =\r\n(const struct dbg_dump_mem *)\r\n&input_mems_arr.ptr[input_offset];\r\nu8 mem_group_id = GET_FIELD(mem->dword0,\r\nDBG_DUMP_MEM_MEM_GROUP_ID);\r\nbool is_storm = false, mem_wide_bus;\r\nenum dbg_grc_params grc_param;\r\nchar storm_letter = 'a';\r\nenum block_id block_id;\r\nu32 mem_addr, mem_len;\r\nif (mem_group_id >= MEM_GROUPS_NUM) {\r\nDP_NOTICE(p_hwfn, "Invalid mem_group_id\n");\r\nreturn 0;\r\n}\r\nblock_id = (enum block_id)cond_hdr->block_id;\r\nif (!qed_grc_is_mem_included(p_hwfn,\r\nblock_id,\r\nmem_group_id))\r\ncontinue;\r\nmem_addr = GET_FIELD(mem->dword0, DBG_DUMP_MEM_ADDRESS);\r\nmem_len = GET_FIELD(mem->dword1, DBG_DUMP_MEM_LENGTH);\r\nmem_wide_bus = GET_FIELD(mem->dword1,\r\nDBG_DUMP_MEM_WIDE_BUS);\r\nif (mem_group_id == MEM_GROUP_CONN_CFC_MEM) {\r\nif (mem_len % MAX_LCIDS) {\r\nDP_NOTICE(p_hwfn,\r\n"Invalid CCFC connection memory size\n");\r\nreturn 0;\r\n}\r\ngrc_param = DBG_GRC_PARAM_NUM_LCIDS;\r\nmem_len = qed_grc_get_param(p_hwfn, grc_param) *\r\n(mem_len / MAX_LCIDS);\r\n} else if (mem_group_id == MEM_GROUP_TASK_CFC_MEM) {\r\nif (mem_len % MAX_LTIDS) {\r\nDP_NOTICE(p_hwfn,\r\n"Invalid TCFC task memory size\n");\r\nreturn 0;\r\n}\r\ngrc_param = DBG_GRC_PARAM_NUM_LTIDS;\r\nmem_len = qed_grc_get_param(p_hwfn, grc_param) *\r\n(mem_len / MAX_LTIDS);\r\n}\r\nif (s_block_defs\r\n[cond_hdr->block_id]->associated_to_storm) {\r\nis_storm = true;\r\nstorm_letter =\r\ns_storm_defs[s_block_defs\r\n[cond_hdr->block_id]->\r\nstorm_id].letter;\r\n}\r\noffset += qed_grc_dump_mem(p_hwfn,\r\np_ptt,\r\ndump_buf + offset,\r\ndump,\r\nNULL,\r\nmem_addr,\r\nmem_len,\r\nmem_wide_bus,\r\n0,\r\nfalse,\r\ns_mem_group_names[mem_group_id],\r\nis_storm,\r\nstorm_letter);\r\n}\r\n}\r\nreturn offset;\r\n}\r\nstatic u32 qed_grc_dump_memories(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 *dump_buf, bool dump)\r\n{\r\nu32 offset = 0, input_offset = 0;\r\nwhile (input_offset <\r\ns_dbg_arrays[BIN_BUF_DBG_DUMP_MEM].size_in_dwords) {\r\nconst struct dbg_dump_split_hdr *split_hdr;\r\nstruct dbg_array curr_input_mems_arr;\r\nu32 split_data_size;\r\nu8 split_type_id;\r\nsplit_hdr = (const struct dbg_dump_split_hdr *)\r\n&s_dbg_arrays[BIN_BUF_DBG_DUMP_MEM].ptr[input_offset++];\r\nsplit_type_id =\r\nGET_FIELD(split_hdr->hdr,\r\nDBG_DUMP_SPLIT_HDR_SPLIT_TYPE_ID);\r\nsplit_data_size =\r\nGET_FIELD(split_hdr->hdr,\r\nDBG_DUMP_SPLIT_HDR_DATA_SIZE);\r\ncurr_input_mems_arr.ptr =\r\n&s_dbg_arrays[BIN_BUF_DBG_DUMP_MEM].ptr[input_offset];\r\ncurr_input_mems_arr.size_in_dwords = split_data_size;\r\nswitch (split_type_id) {\r\ncase SPLIT_TYPE_NONE:\r\noffset += qed_grc_dump_mem_entries(p_hwfn,\r\np_ptt,\r\ncurr_input_mems_arr,\r\ndump_buf + offset,\r\ndump);\r\nbreak;\r\ndefault:\r\nDP_NOTICE(p_hwfn,\r\n"Dumping split memories is currently not supported\n");\r\nbreak;\r\n}\r\ninput_offset += split_data_size;\r\n}\r\nreturn offset;\r\n}\r\nstatic u32 qed_grc_dump_ctx_data(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 *dump_buf,\r\nbool dump,\r\nconst char *name,\r\nu32 num_lids,\r\nu32 lid_size,\r\nu32 rd_reg_addr,\r\nu8 storm_id)\r\n{\r\nstruct storm_defs *storm = &s_storm_defs[storm_id];\r\nu32 i, lid, total_size, offset = 0;\r\nif (!lid_size)\r\nreturn 0;\r\nlid_size *= BYTES_IN_DWORD;\r\ntotal_size = num_lids * lid_size;\r\noffset += qed_grc_dump_mem_hdr(p_hwfn,\r\ndump_buf + offset,\r\ndump,\r\nname,\r\n0,\r\ntotal_size,\r\nlid_size * 32,\r\nfalse, name, true, storm->letter);\r\nif (!dump)\r\nreturn offset + total_size;\r\nfor (lid = 0; lid < num_lids; lid++) {\r\nfor (i = 0; i < lid_size; i++, offset++) {\r\nqed_wr(p_hwfn,\r\np_ptt, storm->cm_ctx_wr_addr, (i << 9) | lid);\r\n*(dump_buf + offset) = qed_rd(p_hwfn,\r\np_ptt, rd_reg_addr);\r\n}\r\n}\r\nreturn offset;\r\n}\r\nstatic u32 qed_grc_dump_ctx(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt, u32 *dump_buf, bool dump)\r\n{\r\nenum dbg_grc_params grc_param;\r\nu32 offset = 0;\r\nu8 storm_id;\r\nfor (storm_id = 0; storm_id < MAX_DBG_STORMS; storm_id++) {\r\nstruct storm_defs *storm = &s_storm_defs[storm_id];\r\nif (!qed_grc_is_storm_included(p_hwfn,\r\n(enum dbg_storms)storm_id))\r\ncontinue;\r\ngrc_param = DBG_GRC_PARAM_NUM_LCIDS;\r\noffset +=\r\nqed_grc_dump_ctx_data(p_hwfn,\r\np_ptt,\r\ndump_buf + offset,\r\ndump,\r\n"CONN_AG_CTX",\r\nqed_grc_get_param(p_hwfn,\r\ngrc_param),\r\nstorm->cm_conn_ag_ctx_lid_size,\r\nstorm->cm_conn_ag_ctx_rd_addr,\r\nstorm_id);\r\ngrc_param = DBG_GRC_PARAM_NUM_LCIDS;\r\noffset +=\r\nqed_grc_dump_ctx_data(p_hwfn,\r\np_ptt,\r\ndump_buf + offset,\r\ndump,\r\n"CONN_ST_CTX",\r\nqed_grc_get_param(p_hwfn,\r\ngrc_param),\r\nstorm->cm_conn_st_ctx_lid_size,\r\nstorm->cm_conn_st_ctx_rd_addr,\r\nstorm_id);\r\ngrc_param = DBG_GRC_PARAM_NUM_LTIDS;\r\noffset +=\r\nqed_grc_dump_ctx_data(p_hwfn,\r\np_ptt,\r\ndump_buf + offset,\r\ndump,\r\n"TASK_AG_CTX",\r\nqed_grc_get_param(p_hwfn,\r\ngrc_param),\r\nstorm->cm_task_ag_ctx_lid_size,\r\nstorm->cm_task_ag_ctx_rd_addr,\r\nstorm_id);\r\ngrc_param = DBG_GRC_PARAM_NUM_LTIDS;\r\noffset +=\r\nqed_grc_dump_ctx_data(p_hwfn,\r\np_ptt,\r\ndump_buf + offset,\r\ndump,\r\n"TASK_ST_CTX",\r\nqed_grc_get_param(p_hwfn,\r\ngrc_param),\r\nstorm->cm_task_st_ctx_lid_size,\r\nstorm->cm_task_st_ctx_rd_addr,\r\nstorm_id);\r\n}\r\nreturn offset;\r\n}\r\nstatic u32 qed_grc_dump_iors(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt, u32 *dump_buf, bool dump)\r\n{\r\nchar buf[10] = "IOR_SET_?";\r\nu32 addr, offset = 0;\r\nu8 storm_id, set_id;\r\nfor (storm_id = 0; storm_id < MAX_DBG_STORMS; storm_id++) {\r\nstruct storm_defs *storm = &s_storm_defs[storm_id];\r\nif (!qed_grc_is_storm_included(p_hwfn,\r\n(enum dbg_storms)storm_id))\r\ncontinue;\r\nfor (set_id = 0; set_id < NUM_IOR_SETS; set_id++) {\r\naddr = BYTES_TO_DWORDS(storm->sem_fast_mem_addr +\r\nSEM_FAST_REG_STORM_REG_FILE) +\r\nIOR_SET_OFFSET(set_id);\r\nbuf[strlen(buf) - 1] = '0' + set_id;\r\noffset += qed_grc_dump_mem(p_hwfn,\r\np_ptt,\r\ndump_buf + offset,\r\ndump,\r\nbuf,\r\naddr,\r\nIORS_PER_SET,\r\nfalse,\r\n32,\r\nfalse,\r\n"ior",\r\ntrue,\r\nstorm->letter);\r\n}\r\n}\r\nreturn offset;\r\n}\r\nstatic u32 qed_grc_dump_vfc_cam(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 *dump_buf, bool dump, u8 storm_id)\r\n{\r\nu32 total_size = VFC_CAM_NUM_ROWS * VFC_CAM_RESP_DWORDS;\r\nstruct storm_defs *storm = &s_storm_defs[storm_id];\r\nu32 cam_addr[VFC_CAM_ADDR_DWORDS] = { 0 };\r\nu32 cam_cmd[VFC_CAM_CMD_DWORDS] = { 0 };\r\nu32 row, i, offset = 0;\r\noffset += qed_grc_dump_mem_hdr(p_hwfn,\r\ndump_buf + offset,\r\ndump,\r\n"vfc_cam",\r\n0,\r\ntotal_size,\r\n256,\r\nfalse, "vfc_cam", true, storm->letter);\r\nif (!dump)\r\nreturn offset + total_size;\r\nSET_VAR_FIELD(cam_addr, VFC_CAM_ADDR, OP, VFC_OPCODE_CAM_RD);\r\nfor (row = 0; row < VFC_CAM_NUM_ROWS;\r\nrow++, offset += VFC_CAM_RESP_DWORDS) {\r\nSET_VAR_FIELD(cam_cmd, VFC_CAM_CMD, ROW, row);\r\nARR_REG_WR(p_hwfn,\r\np_ptt,\r\nstorm->sem_fast_mem_addr + SEM_FAST_REG_VFC_DATA_WR,\r\ncam_cmd, VFC_CAM_CMD_DWORDS);\r\nARR_REG_WR(p_hwfn,\r\np_ptt,\r\nstorm->sem_fast_mem_addr + SEM_FAST_REG_VFC_ADDR,\r\ncam_addr, VFC_CAM_ADDR_DWORDS);\r\nARR_REG_RD(p_hwfn,\r\np_ptt,\r\nstorm->sem_fast_mem_addr + SEM_FAST_REG_VFC_DATA_RD,\r\ndump_buf + offset, VFC_CAM_RESP_DWORDS);\r\n}\r\nreturn offset;\r\n}\r\nstatic u32 qed_grc_dump_vfc_ram(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 *dump_buf,\r\nbool dump,\r\nu8 storm_id, struct vfc_ram_defs *ram_defs)\r\n{\r\nu32 total_size = ram_defs->num_rows * VFC_RAM_RESP_DWORDS;\r\nstruct storm_defs *storm = &s_storm_defs[storm_id];\r\nu32 ram_addr[VFC_RAM_ADDR_DWORDS] = { 0 };\r\nu32 ram_cmd[VFC_RAM_CMD_DWORDS] = { 0 };\r\nu32 row, i, offset = 0;\r\noffset += qed_grc_dump_mem_hdr(p_hwfn,\r\ndump_buf + offset,\r\ndump,\r\nram_defs->mem_name,\r\n0,\r\ntotal_size,\r\n256,\r\nfalse,\r\nram_defs->type_name,\r\ntrue, storm->letter);\r\nSET_VAR_FIELD(ram_addr, VFC_RAM_ADDR, OP, VFC_OPCODE_RAM_RD);\r\nif (!dump)\r\nreturn offset + total_size;\r\nfor (row = ram_defs->base_row;\r\nrow < ram_defs->base_row + ram_defs->num_rows;\r\nrow++, offset += VFC_RAM_RESP_DWORDS) {\r\nARR_REG_WR(p_hwfn,\r\np_ptt,\r\nstorm->sem_fast_mem_addr + SEM_FAST_REG_VFC_DATA_WR,\r\nram_cmd, VFC_RAM_CMD_DWORDS);\r\nSET_VAR_FIELD(ram_addr, VFC_RAM_ADDR, ROW, row);\r\nARR_REG_WR(p_hwfn,\r\np_ptt,\r\nstorm->sem_fast_mem_addr + SEM_FAST_REG_VFC_ADDR,\r\nram_addr, VFC_RAM_ADDR_DWORDS);\r\nARR_REG_RD(p_hwfn,\r\np_ptt,\r\nstorm->sem_fast_mem_addr + SEM_FAST_REG_VFC_DATA_RD,\r\ndump_buf + offset, VFC_RAM_RESP_DWORDS);\r\n}\r\nreturn offset;\r\n}\r\nstatic u32 qed_grc_dump_vfc(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt, u32 *dump_buf, bool dump)\r\n{\r\nstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\r\nu8 storm_id, i;\r\nu32 offset = 0;\r\nfor (storm_id = 0; storm_id < MAX_DBG_STORMS; storm_id++) {\r\nif (!qed_grc_is_storm_included(p_hwfn,\r\n(enum dbg_storms)storm_id) ||\r\n!s_storm_defs[storm_id].has_vfc ||\r\n(storm_id == DBG_PSTORM_ID && dev_data->platform_id !=\r\nPLATFORM_ASIC))\r\ncontinue;\r\noffset += qed_grc_dump_vfc_cam(p_hwfn,\r\np_ptt,\r\ndump_buf + offset,\r\ndump, storm_id);\r\nfor (i = 0; i < NUM_VFC_RAM_TYPES; i++)\r\noffset += qed_grc_dump_vfc_ram(p_hwfn,\r\np_ptt,\r\ndump_buf + offset,\r\ndump,\r\nstorm_id,\r\n&s_vfc_ram_defs[i]);\r\n}\r\nreturn offset;\r\n}\r\nstatic u32 qed_grc_dump_rss(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt, u32 *dump_buf, bool dump)\r\n{\r\nstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\r\nu32 offset = 0;\r\nu8 rss_mem_id;\r\nfor (rss_mem_id = 0; rss_mem_id < NUM_RSS_MEM_TYPES; rss_mem_id++) {\r\nu32 rss_addr, num_entries, entry_width, total_dwords, i;\r\nstruct rss_mem_defs *rss_defs;\r\nu32 addr, size;\r\nbool packed;\r\nrss_defs = &s_rss_mem_defs[rss_mem_id];\r\nrss_addr = rss_defs->addr;\r\nnum_entries = rss_defs->num_entries[dev_data->chip_id];\r\nentry_width = rss_defs->entry_width[dev_data->chip_id];\r\ntotal_dwords = (num_entries * entry_width) / 32;\r\npacked = (entry_width == 16);\r\noffset += qed_grc_dump_mem_hdr(p_hwfn,\r\ndump_buf + offset,\r\ndump,\r\nrss_defs->mem_name,\r\n0,\r\ntotal_dwords,\r\nentry_width,\r\npacked,\r\nrss_defs->type_name, false, 0);\r\nif (!dump) {\r\noffset += total_dwords;\r\ncontinue;\r\n}\r\naddr = BYTES_TO_DWORDS(RSS_REG_RSS_RAM_DATA);\r\nsize = RSS_REG_RSS_RAM_DATA_SIZE;\r\nfor (i = 0; i < total_dwords; i += size, rss_addr++) {\r\nqed_wr(p_hwfn, p_ptt, RSS_REG_RSS_RAM_ADDR, rss_addr);\r\noffset += qed_grc_dump_addr_range(p_hwfn,\r\np_ptt,\r\ndump_buf + offset,\r\ndump,\r\naddr,\r\nsize,\r\nfalse);\r\n}\r\n}\r\nreturn offset;\r\n}\r\nstatic u32 qed_grc_dump_big_ram(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 *dump_buf, bool dump, u8 big_ram_id)\r\n{\r\nstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\r\nu32 total_blocks, ram_size, offset = 0, i;\r\nchar mem_name[12] = "???_BIG_RAM";\r\nchar type_name[8] = "???_RAM";\r\nstruct big_ram_defs *big_ram;\r\nbig_ram = &s_big_ram_defs[big_ram_id];\r\ntotal_blocks = big_ram->num_of_blocks[dev_data->chip_id];\r\nram_size = total_blocks * BIG_RAM_BLOCK_SIZE_DWORDS;\r\nstrncpy(type_name, big_ram->instance_name,\r\nstrlen(big_ram->instance_name));\r\nstrncpy(mem_name, big_ram->instance_name,\r\nstrlen(big_ram->instance_name));\r\noffset += qed_grc_dump_mem_hdr(p_hwfn,\r\ndump_buf + offset,\r\ndump,\r\nmem_name,\r\n0,\r\nram_size,\r\nBIG_RAM_BLOCK_SIZE_BYTES * 8,\r\nfalse, type_name, false, 0);\r\nif (!dump)\r\nreturn offset + ram_size;\r\nfor (i = 0; i < total_blocks / 2; i++) {\r\nu32 addr, len;\r\nqed_wr(p_hwfn, p_ptt, big_ram->addr_reg_addr, i);\r\naddr = BYTES_TO_DWORDS(big_ram->data_reg_addr);\r\nlen = 2 * BIG_RAM_BLOCK_SIZE_DWORDS;\r\noffset += qed_grc_dump_addr_range(p_hwfn,\r\np_ptt,\r\ndump_buf + offset,\r\ndump,\r\naddr,\r\nlen,\r\nfalse);\r\n}\r\nreturn offset;\r\n}\r\nstatic u32 qed_grc_dump_mcp(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt, u32 *dump_buf, bool dump)\r\n{\r\nbool block_enable[MAX_BLOCK_ID] = { 0 };\r\nu32 offset = 0, addr;\r\nbool halted = false;\r\nif (dump && !qed_grc_get_param(p_hwfn, DBG_GRC_PARAM_NO_MCP)) {\r\nhalted = !qed_mcp_halt(p_hwfn, p_ptt);\r\nif (!halted)\r\nDP_NOTICE(p_hwfn, "MCP halt failed!\n");\r\n}\r\noffset += qed_grc_dump_mem(p_hwfn,\r\np_ptt,\r\ndump_buf + offset,\r\ndump,\r\nNULL,\r\nBYTES_TO_DWORDS(MCP_REG_SCRATCH),\r\nMCP_REG_SCRATCH_SIZE,\r\nfalse, 0, false, "MCP", false, 0);\r\noffset += qed_grc_dump_mem(p_hwfn,\r\np_ptt,\r\ndump_buf + offset,\r\ndump,\r\nNULL,\r\nBYTES_TO_DWORDS(MCP_REG_CPU_REG_FILE),\r\nMCP_REG_CPU_REG_FILE_SIZE,\r\nfalse, 0, false, "MCP", false, 0);\r\nblock_enable[BLOCK_MCP] = true;\r\noffset += qed_grc_dump_registers(p_hwfn,\r\np_ptt,\r\ndump_buf + offset,\r\ndump, block_enable, "block", "MCP");\r\noffset += qed_grc_dump_regs_hdr(dump_buf + offset,\r\ndump, 1, "eng", -1, "block", "MCP");\r\naddr = BYTES_TO_DWORDS(MISC_REG_SHARED_MEM_ADDR);\r\noffset += qed_grc_dump_reg_entry(p_hwfn,\r\np_ptt,\r\ndump_buf + offset,\r\ndump,\r\naddr,\r\n1,\r\nfalse);\r\nif (halted && qed_mcp_resume(p_hwfn, p_ptt))\r\nDP_NOTICE(p_hwfn, "Failed to resume MCP after halt!\n");\r\nreturn offset;\r\n}\r\nstatic u32 qed_grc_dump_phy(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt, u32 *dump_buf, bool dump)\r\n{\r\nu32 offset = 0, tbus_lo_offset, tbus_hi_offset;\r\nchar mem_name[32];\r\nu8 phy_id;\r\nfor (phy_id = 0; phy_id < ARRAY_SIZE(s_phy_defs); phy_id++) {\r\nu32 addr_lo_addr, addr_hi_addr, data_lo_addr, data_hi_addr;\r\nstruct phy_defs *phy_defs;\r\nu8 *bytes_buf;\r\nphy_defs = &s_phy_defs[phy_id];\r\naddr_lo_addr = phy_defs->base_addr +\r\nphy_defs->tbus_addr_lo_addr;\r\naddr_hi_addr = phy_defs->base_addr +\r\nphy_defs->tbus_addr_hi_addr;\r\ndata_lo_addr = phy_defs->base_addr +\r\nphy_defs->tbus_data_lo_addr;\r\ndata_hi_addr = phy_defs->base_addr +\r\nphy_defs->tbus_data_hi_addr;\r\nbytes_buf = (u8 *)(dump_buf + offset);\r\nif (snprintf(mem_name, sizeof(mem_name), "tbus_%s",\r\nphy_defs->phy_name) < 0)\r\nDP_NOTICE(p_hwfn,\r\n"Unexpected debug error: invalid PHY memory name\n");\r\noffset += qed_grc_dump_mem_hdr(p_hwfn,\r\ndump_buf + offset,\r\ndump,\r\nmem_name,\r\n0,\r\nPHY_DUMP_SIZE_DWORDS,\r\n16, true, mem_name, false, 0);\r\nif (!dump) {\r\noffset += PHY_DUMP_SIZE_DWORDS;\r\ncontinue;\r\n}\r\nfor (tbus_hi_offset = 0;\r\ntbus_hi_offset < (NUM_PHY_TBUS_ADDRESSES >> 8);\r\ntbus_hi_offset++) {\r\nqed_wr(p_hwfn, p_ptt, addr_hi_addr, tbus_hi_offset);\r\nfor (tbus_lo_offset = 0; tbus_lo_offset < 256;\r\ntbus_lo_offset++) {\r\nqed_wr(p_hwfn,\r\np_ptt, addr_lo_addr, tbus_lo_offset);\r\n*(bytes_buf++) = (u8)qed_rd(p_hwfn,\r\np_ptt,\r\ndata_lo_addr);\r\n*(bytes_buf++) = (u8)qed_rd(p_hwfn,\r\np_ptt,\r\ndata_hi_addr);\r\n}\r\n}\r\noffset += PHY_DUMP_SIZE_DWORDS;\r\n}\r\nreturn offset;\r\n}\r\nstatic void qed_config_dbg_line(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nenum block_id block_id,\r\nu8 line_id,\r\nu8 enable_mask,\r\nu8 right_shift,\r\nu8 force_valid_mask, u8 force_frame_mask)\r\n{\r\nstruct block_defs *block = s_block_defs[block_id];\r\nqed_wr(p_hwfn, p_ptt, block->dbg_select_addr, line_id);\r\nqed_wr(p_hwfn, p_ptt, block->dbg_enable_addr, enable_mask);\r\nqed_wr(p_hwfn, p_ptt, block->dbg_shift_addr, right_shift);\r\nqed_wr(p_hwfn, p_ptt, block->dbg_force_valid_addr, force_valid_mask);\r\nqed_wr(p_hwfn, p_ptt, block->dbg_force_frame_addr, force_frame_mask);\r\n}\r\nstatic u32 qed_grc_dump_static_debug(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 *dump_buf, bool dump)\r\n{\r\nstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\r\nu32 block_id, line_id, offset = 0;\r\nif (qed_rd(p_hwfn, p_ptt, DBG_REG_DBG_BLOCK_ON))\r\nreturn 0;\r\nif (dump) {\r\nDP_VERBOSE(p_hwfn,\r\nQED_MSG_DEBUG, "Dumping static debug data...\n");\r\nfor (block_id = 0; block_id < MAX_BLOCK_ID; block_id++) {\r\nstruct block_defs *block = s_block_defs[block_id];\r\nif (block->has_dbg_bus[dev_data->chip_id])\r\nqed_wr(p_hwfn, p_ptt, block->dbg_enable_addr,\r\n0);\r\n}\r\nqed_bus_reset_dbg_block(p_hwfn, p_ptt);\r\nqed_bus_set_framing_mode(p_hwfn,\r\np_ptt, DBG_BUS_FRAME_MODE_8HW_0ST);\r\nqed_wr(p_hwfn,\r\np_ptt, DBG_REG_DEBUG_TARGET, DBG_BUS_TARGET_ID_INT_BUF);\r\nqed_wr(p_hwfn, p_ptt, DBG_REG_FULL_MODE, 1);\r\nqed_bus_enable_dbg_block(p_hwfn, p_ptt, true);\r\n}\r\nfor (block_id = 0; block_id < MAX_BLOCK_ID; block_id++) {\r\nstruct block_defs *block = s_block_defs[block_id];\r\nstruct dbg_bus_block *block_desc;\r\nu32 block_dwords, addr, len;\r\nu8 dbg_client_id;\r\nif (!block->has_dbg_bus[dev_data->chip_id])\r\ncontinue;\r\nblock_desc =\r\nget_dbg_bus_block_desc(p_hwfn,\r\n(enum block_id)block_id);\r\nblock_dwords = NUM_DBG_LINES(block_desc) *\r\nSTATIC_DEBUG_LINE_DWORDS;\r\noffset += qed_grc_dump_mem_hdr(p_hwfn,\r\ndump_buf + offset,\r\ndump,\r\nblock->name,\r\n0,\r\nblock_dwords,\r\n32, false, "STATIC", false, 0);\r\nif (!dump) {\r\noffset += block_dwords;\r\ncontinue;\r\n}\r\nif (dev_data->block_in_reset[block_id]) {\r\nmemset(dump_buf + offset, 0,\r\nDWORDS_TO_BYTES(block_dwords));\r\noffset += block_dwords;\r\ncontinue;\r\n}\r\ndbg_client_id = block->dbg_client_id[dev_data->chip_id];\r\nqed_bus_enable_clients(p_hwfn,\r\np_ptt,\r\nBIT(dbg_client_id));\r\naddr = BYTES_TO_DWORDS(DBG_REG_CALENDAR_OUT_DATA);\r\nlen = STATIC_DEBUG_LINE_DWORDS;\r\nfor (line_id = 0; line_id < (u32)NUM_DBG_LINES(block_desc);\r\nline_id++) {\r\nqed_config_dbg_line(p_hwfn,\r\np_ptt,\r\n(enum block_id)block_id,\r\n(u8)line_id, 0xf, 0, 0, 0);\r\noffset += qed_grc_dump_addr_range(p_hwfn,\r\np_ptt,\r\ndump_buf + offset,\r\ndump,\r\naddr,\r\nlen,\r\ntrue);\r\n}\r\nqed_bus_enable_clients(p_hwfn, p_ptt, 0);\r\nqed_wr(p_hwfn, p_ptt, block->dbg_enable_addr, 0);\r\n}\r\nif (dump) {\r\nqed_bus_enable_dbg_block(p_hwfn, p_ptt, false);\r\nqed_bus_enable_clients(p_hwfn, p_ptt, 0);\r\n}\r\nreturn offset;\r\n}\r\nstatic enum dbg_status qed_grc_dump(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 *dump_buf,\r\nbool dump, u32 *num_dumped_dwords)\r\n{\r\nstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\r\nbool parities_masked = false;\r\nu8 i, port_mode = 0;\r\nu32 offset = 0;\r\n*num_dumped_dwords = 0;\r\nif (dump) {\r\nswitch (qed_rd(p_hwfn, p_ptt, MISC_REG_PORT_MODE)) {\r\ncase 0:\r\nport_mode = 1;\r\nbreak;\r\ncase 1:\r\nport_mode = 2;\r\nbreak;\r\ncase 2:\r\nport_mode = 4;\r\nbreak;\r\n}\r\nqed_update_blocks_reset_state(p_hwfn, p_ptt);\r\n}\r\noffset += qed_dump_common_global_params(p_hwfn,\r\np_ptt,\r\ndump_buf + offset, dump, 4);\r\noffset += qed_dump_str_param(dump_buf + offset,\r\ndump, "dump-type", "grc-dump");\r\noffset += qed_dump_num_param(dump_buf + offset,\r\ndump,\r\n"num-lcids",\r\nqed_grc_get_param(p_hwfn,\r\nDBG_GRC_PARAM_NUM_LCIDS));\r\noffset += qed_dump_num_param(dump_buf + offset,\r\ndump,\r\n"num-ltids",\r\nqed_grc_get_param(p_hwfn,\r\nDBG_GRC_PARAM_NUM_LTIDS));\r\noffset += qed_dump_num_param(dump_buf + offset,\r\ndump, "num-ports", port_mode);\r\nif (qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_REGS))\r\noffset += qed_grc_dump_reset_regs(p_hwfn,\r\np_ptt,\r\ndump_buf + offset, dump);\r\nif (dump) {\r\nqed_grc_unreset_blocks(p_hwfn, p_ptt);\r\nqed_update_blocks_reset_state(p_hwfn, p_ptt);\r\n}\r\nif (dump &&\r\n!qed_grc_get_param(p_hwfn, DBG_GRC_PARAM_NO_MCP)) {\r\nparities_masked = !qed_mcp_mask_parities(p_hwfn, p_ptt, 1);\r\nif (!parities_masked) {\r\nDP_NOTICE(p_hwfn,\r\n"Failed to mask parities using MFW\n");\r\nif (qed_grc_get_param\r\n(p_hwfn, DBG_GRC_PARAM_PARITY_SAFE))\r\nreturn DBG_STATUS_MCP_COULD_NOT_MASK_PRTY;\r\n}\r\n}\r\nif (qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_REGS))\r\noffset += qed_grc_dump_modified_regs(p_hwfn,\r\np_ptt,\r\ndump_buf + offset, dump);\r\nif (dump &&\r\n(qed_grc_is_included(p_hwfn,\r\nDBG_GRC_PARAM_DUMP_IOR) ||\r\nqed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_VFC)))\r\nqed_grc_stall_storms(p_hwfn, p_ptt, true);\r\nif (qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_REGS)) {\r\nbool block_enable[MAX_BLOCK_ID];\r\nfor (i = 0; i < MAX_BLOCK_ID; i++)\r\nblock_enable[i] = true;\r\nblock_enable[BLOCK_MCP] = false;\r\noffset += qed_grc_dump_registers(p_hwfn,\r\np_ptt,\r\ndump_buf +\r\noffset,\r\ndump,\r\nblock_enable, NULL, NULL);\r\noffset += qed_grc_dump_special_regs(p_hwfn,\r\np_ptt,\r\ndump_buf + offset, dump);\r\n}\r\noffset += qed_grc_dump_memories(p_hwfn, p_ptt, dump_buf + offset, dump);\r\nif (qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_MCP))\r\noffset += qed_grc_dump_mcp(p_hwfn,\r\np_ptt, dump_buf + offset, dump);\r\nif (qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_CM_CTX))\r\noffset += qed_grc_dump_ctx(p_hwfn,\r\np_ptt, dump_buf + offset, dump);\r\nif (qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_RSS))\r\noffset += qed_grc_dump_rss(p_hwfn,\r\np_ptt, dump_buf + offset, dump);\r\nfor (i = 0; i < NUM_BIG_RAM_TYPES; i++)\r\nif (qed_grc_is_included(p_hwfn, s_big_ram_defs[i].grc_param))\r\noffset += qed_grc_dump_big_ram(p_hwfn,\r\np_ptt,\r\ndump_buf + offset,\r\ndump, i);\r\nif (qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_IOR))\r\noffset += qed_grc_dump_iors(p_hwfn,\r\np_ptt, dump_buf + offset, dump);\r\nif (qed_grc_is_included(p_hwfn, DBG_GRC_PARAM_DUMP_VFC))\r\noffset += qed_grc_dump_vfc(p_hwfn,\r\np_ptt, dump_buf + offset, dump);\r\nif (qed_grc_is_included(p_hwfn,\r\nDBG_GRC_PARAM_DUMP_PHY) && dev_data->chip_id ==\r\nCHIP_K2 && dev_data->platform_id == PLATFORM_ASIC)\r\noffset += qed_grc_dump_phy(p_hwfn,\r\np_ptt, dump_buf + offset, dump);\r\nif (qed_grc_is_included(p_hwfn,\r\nDBG_GRC_PARAM_DUMP_STATIC) &&\r\ndev_data->bus.state == DBG_BUS_STATE_IDLE)\r\noffset += qed_grc_dump_static_debug(p_hwfn,\r\np_ptt,\r\ndump_buf + offset, dump);\r\noffset += qed_dump_last_section(p_hwfn, dump_buf, offset, dump);\r\nif (dump) {\r\nif (qed_grc_get_param(p_hwfn, DBG_GRC_PARAM_UNSTALL))\r\nqed_grc_stall_storms(p_hwfn, p_ptt, false);\r\nqed_grc_clear_all_prty(p_hwfn, p_ptt);\r\nif (parities_masked)\r\nqed_mcp_mask_parities(p_hwfn, p_ptt, 0);\r\n}\r\n*num_dumped_dwords = offset;\r\nreturn DBG_STATUS_OK;\r\n}\r\nstatic u32 qed_idle_chk_dump_failure(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 *\r\ndump_buf,\r\nbool dump,\r\nu16 rule_id,\r\nconst struct dbg_idle_chk_rule *rule,\r\nu16 fail_entry_id, u32 *cond_reg_values)\r\n{\r\nstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\r\nconst struct dbg_idle_chk_cond_reg *cond_regs;\r\nconst struct dbg_idle_chk_info_reg *info_regs;\r\nu32 i, next_reg_offset = 0, offset = 0;\r\nstruct dbg_idle_chk_result_hdr *hdr;\r\nconst union dbg_idle_chk_reg *regs;\r\nu8 reg_id;\r\nhdr = (struct dbg_idle_chk_result_hdr *)dump_buf;\r\nregs = &((const union dbg_idle_chk_reg *)\r\ns_dbg_arrays[BIN_BUF_DBG_IDLE_CHK_REGS].ptr)[rule->reg_offset];\r\ncond_regs = &regs[0].cond_reg;\r\ninfo_regs = &regs[rule->num_cond_regs].info_reg;\r\nif (dump) {\r\nmemset(hdr, 0, sizeof(*hdr));\r\nhdr->rule_id = rule_id;\r\nhdr->mem_entry_id = fail_entry_id;\r\nhdr->severity = rule->severity;\r\nhdr->num_dumped_cond_regs = rule->num_cond_regs;\r\n}\r\noffset += IDLE_CHK_RESULT_HDR_DWORDS;\r\nfor (reg_id = 0; reg_id < rule->num_cond_regs; reg_id++) {\r\nconst struct dbg_idle_chk_cond_reg *reg = &cond_regs[reg_id];\r\nstruct dbg_idle_chk_result_reg_hdr *reg_hdr;\r\nreg_hdr = (struct dbg_idle_chk_result_reg_hdr *)\r\n(dump_buf + offset);\r\nif (!dump) {\r\noffset += IDLE_CHK_RESULT_REG_HDR_DWORDS +\r\nreg->entry_size;\r\ncontinue;\r\n}\r\noffset += IDLE_CHK_RESULT_REG_HDR_DWORDS;\r\nmemset(reg_hdr, 0, sizeof(*reg_hdr));\r\nreg_hdr->start_entry = reg->start_entry;\r\nreg_hdr->size = reg->entry_size;\r\nSET_FIELD(reg_hdr->data,\r\nDBG_IDLE_CHK_RESULT_REG_HDR_IS_MEM,\r\nreg->num_entries > 1 || reg->start_entry > 0 ? 1 : 0);\r\nSET_FIELD(reg_hdr->data,\r\nDBG_IDLE_CHK_RESULT_REG_HDR_REG_ID, reg_id);\r\nfor (i = 0; i < reg_hdr->size; i++, next_reg_offset++, offset++)\r\ndump_buf[offset] = cond_reg_values[next_reg_offset];\r\n}\r\nfor (reg_id = 0; reg_id < rule->num_info_regs; reg_id++) {\r\nconst struct dbg_idle_chk_info_reg *reg = &info_regs[reg_id];\r\nu32 block_id;\r\nif (!dump) {\r\noffset += IDLE_CHK_RESULT_REG_HDR_DWORDS + reg->size;\r\ncontinue;\r\n}\r\nblock_id = GET_FIELD(reg->data, DBG_IDLE_CHK_INFO_REG_BLOCK_ID);\r\nif (block_id >= MAX_BLOCK_ID) {\r\nDP_NOTICE(p_hwfn, "Invalid block_id\n");\r\nreturn 0;\r\n}\r\nif (!dev_data->block_in_reset[block_id]) {\r\nstruct dbg_idle_chk_result_reg_hdr *reg_hdr;\r\nbool wide_bus, eval_mode, mode_match = true;\r\nu16 modes_buf_offset;\r\nu32 addr;\r\nreg_hdr = (struct dbg_idle_chk_result_reg_hdr *)\r\n(dump_buf + offset);\r\neval_mode = GET_FIELD(reg->mode.data,\r\nDBG_MODE_HDR_EVAL_MODE) > 0;\r\nif (eval_mode) {\r\nmodes_buf_offset =\r\nGET_FIELD(reg->mode.data,\r\nDBG_MODE_HDR_MODES_BUF_OFFSET);\r\nmode_match =\r\nqed_is_mode_match(p_hwfn,\r\n&modes_buf_offset);\r\n}\r\nif (!mode_match)\r\ncontinue;\r\naddr = GET_FIELD(reg->data,\r\nDBG_IDLE_CHK_INFO_REG_ADDRESS);\r\nwide_bus = GET_FIELD(reg->data,\r\nDBG_IDLE_CHK_INFO_REG_WIDE_BUS);\r\noffset += IDLE_CHK_RESULT_REG_HDR_DWORDS;\r\nhdr->num_dumped_info_regs++;\r\nmemset(reg_hdr, 0, sizeof(*reg_hdr));\r\nreg_hdr->size = reg->size;\r\nSET_FIELD(reg_hdr->data,\r\nDBG_IDLE_CHK_RESULT_REG_HDR_REG_ID,\r\nrule->num_cond_regs + reg_id);\r\noffset += qed_grc_dump_addr_range(p_hwfn,\r\np_ptt,\r\ndump_buf + offset,\r\ndump,\r\naddr,\r\nreg->size, wide_bus);\r\n}\r\n}\r\nreturn offset;\r\n}\r\nstatic u32\r\nqed_idle_chk_dump_rule_entries(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt,\r\nu32 *dump_buf, bool dump,\r\nconst struct dbg_idle_chk_rule *input_rules,\r\nu32 num_input_rules, u32 *num_failing_rules)\r\n{\r\nstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\r\nu32 cond_reg_values[IDLE_CHK_MAX_ENTRIES_SIZE];\r\nu32 i, offset = 0;\r\nu16 entry_id;\r\nu8 reg_id;\r\n*num_failing_rules = 0;\r\nfor (i = 0; i < num_input_rules; i++) {\r\nconst struct dbg_idle_chk_cond_reg *cond_regs;\r\nconst struct dbg_idle_chk_rule *rule;\r\nconst union dbg_idle_chk_reg *regs;\r\nu16 num_reg_entries = 1;\r\nbool check_rule = true;\r\nconst u32 *imm_values;\r\nrule = &input_rules[i];\r\nregs = &((const union dbg_idle_chk_reg *)\r\ns_dbg_arrays[BIN_BUF_DBG_IDLE_CHK_REGS].ptr)\r\n[rule->reg_offset];\r\ncond_regs = &regs[0].cond_reg;\r\nimm_values = &s_dbg_arrays[BIN_BUF_DBG_IDLE_CHK_IMMS].ptr\r\n[rule->imm_offset];\r\nfor (reg_id = 0; reg_id < rule->num_cond_regs && check_rule;\r\nreg_id++) {\r\nu32 block_id =\r\nGET_FIELD(cond_regs[reg_id].data,\r\nDBG_IDLE_CHK_COND_REG_BLOCK_ID);\r\nif (block_id >= MAX_BLOCK_ID) {\r\nDP_NOTICE(p_hwfn, "Invalid block_id\n");\r\nreturn 0;\r\n}\r\ncheck_rule = !dev_data->block_in_reset[block_id];\r\nif (cond_regs[reg_id].num_entries > num_reg_entries)\r\nnum_reg_entries = cond_regs[reg_id].num_entries;\r\n}\r\nif (!check_rule && dump)\r\ncontinue;\r\nfor (entry_id = 0; entry_id < num_reg_entries; entry_id++) {\r\nu32 next_reg_offset = 0;\r\nif (!dump) {\r\noffset += qed_idle_chk_dump_failure(p_hwfn,\r\np_ptt,\r\ndump_buf + offset,\r\nfalse,\r\nrule->rule_id,\r\nrule,\r\nentry_id,\r\nNULL);\r\n(*num_failing_rules)++;\r\nbreak;\r\n}\r\nfor (reg_id = 0; reg_id < rule->num_cond_regs;\r\nreg_id++) {\r\nconst struct dbg_idle_chk_cond_reg *reg =\r\n&cond_regs[reg_id];\r\nu32 padded_entry_size, addr;\r\nbool wide_bus;\r\naddr = GET_FIELD(reg->data,\r\nDBG_IDLE_CHK_COND_REG_ADDRESS);\r\nwide_bus =\r\nGET_FIELD(reg->data,\r\nDBG_IDLE_CHK_COND_REG_WIDE_BUS);\r\nif (reg->num_entries > 1 ||\r\nreg->start_entry > 0) {\r\npadded_entry_size =\r\nreg->entry_size > 1 ?\r\nroundup_pow_of_two(reg->entry_size)\r\n: 1;\r\naddr += (reg->start_entry + entry_id) *\r\npadded_entry_size;\r\n}\r\nif (next_reg_offset + reg->entry_size >=\r\nIDLE_CHK_MAX_ENTRIES_SIZE) {\r\nDP_NOTICE(p_hwfn,\r\n"idle check registers entry is too large\n");\r\nreturn 0;\r\n}\r\nnext_reg_offset +=\r\nqed_grc_dump_addr_range(p_hwfn, p_ptt,\r\ncond_reg_values +\r\nnext_reg_offset,\r\ndump, addr,\r\nreg->entry_size,\r\nwide_bus);\r\n}\r\nif ((*cond_arr[rule->cond_id]) (cond_reg_values,\r\nimm_values)) {\r\noffset += qed_idle_chk_dump_failure(p_hwfn,\r\np_ptt,\r\ndump_buf + offset,\r\ndump,\r\nrule->rule_id,\r\nrule,\r\nentry_id,\r\ncond_reg_values);\r\n(*num_failing_rules)++;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn offset;\r\n}\r\nstatic u32 qed_idle_chk_dump(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt, u32 *dump_buf, bool dump)\r\n{\r\nu32 num_failing_rules_offset, offset = 0, input_offset = 0;\r\nu32 num_failing_rules = 0;\r\noffset += qed_dump_common_global_params(p_hwfn,\r\np_ptt,\r\ndump_buf + offset, dump, 1);\r\noffset += qed_dump_str_param(dump_buf + offset,\r\ndump, "dump-type", "idle-chk");\r\noffset += qed_dump_section_hdr(dump_buf + offset, dump, "idle_chk", 1);\r\nnum_failing_rules_offset = offset;\r\noffset += qed_dump_num_param(dump_buf + offset, dump, "num_rules", 0);\r\nwhile (input_offset <\r\ns_dbg_arrays[BIN_BUF_DBG_IDLE_CHK_RULES].size_in_dwords) {\r\nconst struct dbg_idle_chk_cond_hdr *cond_hdr =\r\n(const struct dbg_idle_chk_cond_hdr *)\r\n&s_dbg_arrays[BIN_BUF_DBG_IDLE_CHK_RULES].ptr\r\n[input_offset++];\r\nbool eval_mode, mode_match = true;\r\nu32 curr_failing_rules;\r\nu16 modes_buf_offset;\r\neval_mode = GET_FIELD(cond_hdr->mode.data,\r\nDBG_MODE_HDR_EVAL_MODE) > 0;\r\nif (eval_mode) {\r\nmodes_buf_offset =\r\nGET_FIELD(cond_hdr->mode.data,\r\nDBG_MODE_HDR_MODES_BUF_OFFSET);\r\nmode_match = qed_is_mode_match(p_hwfn,\r\n&modes_buf_offset);\r\n}\r\nif (mode_match) {\r\noffset +=\r\nqed_idle_chk_dump_rule_entries(p_hwfn,\r\np_ptt,\r\ndump_buf + offset,\r\ndump,\r\n(const struct dbg_idle_chk_rule *)\r\n&s_dbg_arrays[BIN_BUF_DBG_IDLE_CHK_RULES].\r\nptr[input_offset],\r\ncond_hdr->data_size / IDLE_CHK_RULE_SIZE_DWORDS,\r\n&curr_failing_rules);\r\nnum_failing_rules += curr_failing_rules;\r\n}\r\ninput_offset += cond_hdr->data_size;\r\n}\r\nif (dump)\r\nqed_dump_num_param(dump_buf + num_failing_rules_offset,\r\ndump, "num_rules", num_failing_rules);\r\noffset += qed_dump_last_section(p_hwfn, dump_buf, offset, dump);\r\nreturn offset;\r\n}\r\nstatic enum dbg_status qed_find_nvram_image(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 image_type,\r\nu32 *nvram_offset_bytes,\r\nu32 *nvram_size_bytes)\r\n{\r\nu32 ret_mcp_resp, ret_mcp_param, ret_txn_size;\r\nstruct mcp_file_att file_att;\r\nint nvm_result;\r\nnvm_result = qed_mcp_nvm_rd_cmd(p_hwfn,\r\np_ptt,\r\nDRV_MSG_CODE_NVM_GET_FILE_ATT,\r\nimage_type,\r\n&ret_mcp_resp,\r\n&ret_mcp_param,\r\n&ret_txn_size, (u32 *)&file_att);\r\nif (nvm_result ||\r\n(ret_mcp_resp & FW_MSG_CODE_MASK) != FW_MSG_CODE_NVM_OK)\r\nreturn DBG_STATUS_NVRAM_GET_IMAGE_FAILED;\r\n*nvram_offset_bytes = file_att.nvm_start_addr;\r\n*nvram_size_bytes = file_att.len;\r\nDP_VERBOSE(p_hwfn,\r\nQED_MSG_DEBUG,\r\n"find_nvram_image: found NVRAM image of type %d in NVRAM offset %d bytes with size %d bytes\n",\r\nimage_type, *nvram_offset_bytes, *nvram_size_bytes);\r\nif (*nvram_size_bytes & 0x3)\r\nreturn DBG_STATUS_NON_ALIGNED_NVRAM_IMAGE;\r\nreturn DBG_STATUS_OK;\r\n}\r\nstatic enum dbg_status qed_nvram_read(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 nvram_offset_bytes,\r\nu32 nvram_size_bytes, u32 *ret_buf)\r\n{\r\nu32 ret_mcp_resp, ret_mcp_param, ret_read_size, bytes_to_copy;\r\ns32 bytes_left = nvram_size_bytes;\r\nu32 read_offset = 0;\r\nDP_VERBOSE(p_hwfn,\r\nQED_MSG_DEBUG,\r\n"nvram_read: reading image of size %d bytes from NVRAM\n",\r\nnvram_size_bytes);\r\ndo {\r\nbytes_to_copy =\r\n(bytes_left >\r\nMCP_DRV_NVM_BUF_LEN) ? MCP_DRV_NVM_BUF_LEN : bytes_left;\r\nif (qed_mcp_nvm_rd_cmd(p_hwfn, p_ptt,\r\nDRV_MSG_CODE_NVM_READ_NVRAM,\r\n(nvram_offset_bytes +\r\nread_offset) |\r\n(bytes_to_copy <<\r\nDRV_MB_PARAM_NVM_LEN_SHIFT),\r\n&ret_mcp_resp, &ret_mcp_param,\r\n&ret_read_size,\r\n(u32 *)((u8 *)ret_buf + read_offset)))\r\nreturn DBG_STATUS_NVRAM_READ_FAILED;\r\nif ((ret_mcp_resp & FW_MSG_CODE_MASK) != FW_MSG_CODE_NVM_OK)\r\nreturn DBG_STATUS_NVRAM_READ_FAILED;\r\nread_offset += ret_read_size;\r\nbytes_left -= ret_read_size;\r\n} while (bytes_left > 0);\r\nreturn DBG_STATUS_OK;\r\n}\r\nstatic enum dbg_status qed_mcp_trace_get_data_info(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 *trace_data_grc_addr,\r\nu32 *trace_data_size)\r\n{\r\nu32 spad_trace_offsize, signature;\r\nspad_trace_offsize = qed_rd(p_hwfn, p_ptt, MCP_SPAD_TRACE_OFFSIZE_ADDR);\r\n*trace_data_grc_addr =\r\nMCP_REG_SCRATCH + SECTION_OFFSET(spad_trace_offsize);\r\nsignature = qed_rd(p_hwfn, p_ptt,\r\n*trace_data_grc_addr +\r\noffsetof(struct mcp_trace, signature));\r\nif (signature != MFW_TRACE_SIGNATURE)\r\nreturn DBG_STATUS_INVALID_TRACE_SIGNATURE;\r\n*trace_data_size = qed_rd(p_hwfn,\r\np_ptt,\r\n*trace_data_grc_addr +\r\noffsetof(struct mcp_trace, size));\r\nreturn DBG_STATUS_OK;\r\n}\r\nstatic enum dbg_status qed_mcp_trace_get_meta_info(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 trace_data_size_bytes,\r\nu32 *running_bundle_id,\r\nu32 *trace_meta_offset,\r\nu32 *trace_meta_size)\r\n{\r\nu32 spad_trace_offsize, nvram_image_type, running_mfw_addr;\r\nspad_trace_offsize = qed_rd(p_hwfn, p_ptt, MCP_SPAD_TRACE_OFFSIZE_ADDR);\r\nrunning_mfw_addr =\r\nMCP_REG_SCRATCH + SECTION_OFFSET(spad_trace_offsize) +\r\nQED_SECTION_SIZE(spad_trace_offsize) + trace_data_size_bytes;\r\n*running_bundle_id = qed_rd(p_hwfn, p_ptt, running_mfw_addr);\r\nif (*running_bundle_id > 1)\r\nreturn DBG_STATUS_INVALID_NVRAM_BUNDLE;\r\nnvram_image_type =\r\n(*running_bundle_id ==\r\nDIR_ID_1) ? NVM_TYPE_MFW_TRACE1 : NVM_TYPE_MFW_TRACE2;\r\nreturn qed_find_nvram_image(p_hwfn,\r\np_ptt,\r\nnvram_image_type,\r\ntrace_meta_offset, trace_meta_size);\r\n}\r\nstatic enum dbg_status qed_mcp_trace_read_meta(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 nvram_offset_in_bytes,\r\nu32 size_in_bytes, u32 *buf)\r\n{\r\nu8 modules_num, module_len, i, *byte_buf = (u8 *)buf;\r\nenum dbg_status status;\r\nu32 signature;\r\nstatus = qed_nvram_read(p_hwfn,\r\np_ptt,\r\nnvram_offset_in_bytes, size_in_bytes, buf);\r\nif (status != DBG_STATUS_OK)\r\nreturn status;\r\nsignature = qed_read_unaligned_dword(byte_buf);\r\nbyte_buf += sizeof(signature);\r\nif (signature != NVM_MAGIC_VALUE)\r\nreturn DBG_STATUS_INVALID_TRACE_SIGNATURE;\r\nmodules_num = *(byte_buf++);\r\nfor (i = 0; i < modules_num; i++) {\r\nmodule_len = *(byte_buf++);\r\nbyte_buf += module_len;\r\n}\r\nsignature = qed_read_unaligned_dword(byte_buf);\r\nbyte_buf += sizeof(signature);\r\nif (signature != NVM_MAGIC_VALUE)\r\nreturn DBG_STATUS_INVALID_TRACE_SIGNATURE;\r\nreturn DBG_STATUS_OK;\r\n}\r\nstatic enum dbg_status qed_mcp_trace_dump(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 *dump_buf,\r\nbool dump, u32 *num_dumped_dwords)\r\n{\r\nu32 trace_data_grc_addr, trace_data_size_bytes, trace_data_size_dwords;\r\nu32 trace_meta_size_dwords = 0, running_bundle_id, offset = 0;\r\nu32 trace_meta_offset_bytes = 0, trace_meta_size_bytes = 0;\r\nenum dbg_status status;\r\nbool mcp_access;\r\nint halted = 0;\r\n*num_dumped_dwords = 0;\r\nmcp_access = !qed_grc_get_param(p_hwfn, DBG_GRC_PARAM_NO_MCP);\r\nstatus = qed_mcp_trace_get_data_info(p_hwfn,\r\np_ptt,\r\n&trace_data_grc_addr,\r\n&trace_data_size_bytes);\r\nif (status != DBG_STATUS_OK)\r\nreturn status;\r\noffset += qed_dump_common_global_params(p_hwfn,\r\np_ptt,\r\ndump_buf + offset, dump, 1);\r\noffset += qed_dump_str_param(dump_buf + offset,\r\ndump, "dump-type", "mcp-trace");\r\nif (dump && mcp_access) {\r\nhalted = !qed_mcp_halt(p_hwfn, p_ptt);\r\nif (!halted)\r\nDP_NOTICE(p_hwfn, "MCP halt failed!\n");\r\n}\r\ntrace_data_size_dwords =\r\nDIV_ROUND_UP(trace_data_size_bytes + sizeof(struct mcp_trace),\r\nBYTES_IN_DWORD);\r\noffset += qed_dump_section_hdr(dump_buf + offset,\r\ndump, "mcp_trace_data", 1);\r\noffset += qed_dump_num_param(dump_buf + offset,\r\ndump, "size", trace_data_size_dwords);\r\noffset += qed_grc_dump_addr_range(p_hwfn,\r\np_ptt,\r\ndump_buf + offset,\r\ndump,\r\nBYTES_TO_DWORDS(trace_data_grc_addr),\r\ntrace_data_size_dwords, false);\r\nif (halted && qed_mcp_resume(p_hwfn, p_ptt))\r\nDP_NOTICE(p_hwfn, "Failed to resume MCP after halt!\n");\r\noffset += qed_dump_section_hdr(dump_buf + offset,\r\ndump, "mcp_trace_meta", 1);\r\nif (mcp_access) {\r\nstatus = qed_mcp_trace_get_meta_info(p_hwfn,\r\np_ptt,\r\ntrace_data_size_bytes,\r\n&running_bundle_id,\r\n&trace_meta_offset_bytes,\r\n&trace_meta_size_bytes);\r\nif (status == DBG_STATUS_OK)\r\ntrace_meta_size_dwords =\r\nBYTES_TO_DWORDS(trace_meta_size_bytes);\r\n}\r\noffset += qed_dump_num_param(dump_buf + offset,\r\ndump, "size", trace_meta_size_dwords);\r\nif (dump && trace_meta_size_dwords)\r\nstatus = qed_mcp_trace_read_meta(p_hwfn,\r\np_ptt,\r\ntrace_meta_offset_bytes,\r\ntrace_meta_size_bytes,\r\ndump_buf + offset);\r\nif (status == DBG_STATUS_OK)\r\noffset += trace_meta_size_dwords;\r\noffset += qed_dump_last_section(p_hwfn, dump_buf, offset, dump);\r\n*num_dumped_dwords = offset;\r\nreturn mcp_access ? status : DBG_STATUS_NVRAM_GET_IMAGE_FAILED;\r\n}\r\nstatic enum dbg_status qed_reg_fifo_dump(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 *dump_buf,\r\nbool dump, u32 *num_dumped_dwords)\r\n{\r\nu32 dwords_read, size_param_offset, offset = 0;\r\nbool fifo_has_data;\r\n*num_dumped_dwords = 0;\r\noffset += qed_dump_common_global_params(p_hwfn,\r\np_ptt,\r\ndump_buf + offset, dump, 1);\r\noffset += qed_dump_str_param(dump_buf + offset,\r\ndump, "dump-type", "reg-fifo");\r\noffset += qed_dump_section_hdr(dump_buf + offset,\r\ndump, "reg_fifo_data", 1);\r\nsize_param_offset = offset;\r\noffset += qed_dump_num_param(dump_buf + offset, dump, "size", 0);\r\nif (!dump) {\r\noffset += REG_FIFO_DEPTH_DWORDS;\r\ngoto out;\r\n}\r\nfifo_has_data = qed_rd(p_hwfn, p_ptt,\r\nGRC_REG_TRACE_FIFO_VALID_DATA) > 0;\r\nfor (dwords_read = 0;\r\nfifo_has_data && dwords_read < REG_FIFO_DEPTH_DWORDS;\r\ndwords_read += REG_FIFO_ELEMENT_DWORDS, offset +=\r\nREG_FIFO_ELEMENT_DWORDS) {\r\nif (qed_dmae_grc2host(p_hwfn, p_ptt, GRC_REG_TRACE_FIFO,\r\n(u64)(uintptr_t)(&dump_buf[offset]),\r\nREG_FIFO_ELEMENT_DWORDS, 0))\r\nreturn DBG_STATUS_DMAE_FAILED;\r\nfifo_has_data = qed_rd(p_hwfn, p_ptt,\r\nGRC_REG_TRACE_FIFO_VALID_DATA) > 0;\r\n}\r\nqed_dump_num_param(dump_buf + size_param_offset, dump, "size",\r\ndwords_read);\r\nout:\r\noffset += qed_dump_last_section(p_hwfn, dump_buf, offset, dump);\r\n*num_dumped_dwords = offset;\r\nreturn DBG_STATUS_OK;\r\n}\r\nstatic enum dbg_status qed_igu_fifo_dump(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 *dump_buf,\r\nbool dump, u32 *num_dumped_dwords)\r\n{\r\nu32 dwords_read, size_param_offset, offset = 0;\r\nbool fifo_has_data;\r\n*num_dumped_dwords = 0;\r\noffset += qed_dump_common_global_params(p_hwfn,\r\np_ptt,\r\ndump_buf + offset, dump, 1);\r\noffset += qed_dump_str_param(dump_buf + offset,\r\ndump, "dump-type", "igu-fifo");\r\noffset += qed_dump_section_hdr(dump_buf + offset,\r\ndump, "igu_fifo_data", 1);\r\nsize_param_offset = offset;\r\noffset += qed_dump_num_param(dump_buf + offset, dump, "size", 0);\r\nif (!dump) {\r\noffset += IGU_FIFO_DEPTH_DWORDS;\r\ngoto out;\r\n}\r\nfifo_has_data = qed_rd(p_hwfn, p_ptt,\r\nIGU_REG_ERROR_HANDLING_DATA_VALID) > 0;\r\nfor (dwords_read = 0;\r\nfifo_has_data && dwords_read < IGU_FIFO_DEPTH_DWORDS;\r\ndwords_read += IGU_FIFO_ELEMENT_DWORDS, offset +=\r\nIGU_FIFO_ELEMENT_DWORDS) {\r\nif (qed_dmae_grc2host(p_hwfn, p_ptt,\r\nIGU_REG_ERROR_HANDLING_MEMORY,\r\n(u64)(uintptr_t)(&dump_buf[offset]),\r\nIGU_FIFO_ELEMENT_DWORDS, 0))\r\nreturn DBG_STATUS_DMAE_FAILED;\r\nfifo_has_data = qed_rd(p_hwfn, p_ptt,\r\nIGU_REG_ERROR_HANDLING_DATA_VALID) > 0;\r\n}\r\nqed_dump_num_param(dump_buf + size_param_offset, dump, "size",\r\ndwords_read);\r\nout:\r\noffset += qed_dump_last_section(p_hwfn, dump_buf, offset, dump);\r\n*num_dumped_dwords = offset;\r\nreturn DBG_STATUS_OK;\r\n}\r\nstatic enum dbg_status qed_protection_override_dump(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 *dump_buf,\r\nbool dump,\r\nu32 *num_dumped_dwords)\r\n{\r\nu32 size_param_offset, override_window_dwords, offset = 0;\r\n*num_dumped_dwords = 0;\r\noffset += qed_dump_common_global_params(p_hwfn,\r\np_ptt,\r\ndump_buf + offset, dump, 1);\r\noffset += qed_dump_str_param(dump_buf + offset,\r\ndump, "dump-type", "protection-override");\r\noffset += qed_dump_section_hdr(dump_buf + offset,\r\ndump, "protection_override_data", 1);\r\nsize_param_offset = offset;\r\noffset += qed_dump_num_param(dump_buf + offset, dump, "size", 0);\r\nif (!dump) {\r\noffset += PROTECTION_OVERRIDE_DEPTH_DWORDS;\r\ngoto out;\r\n}\r\noverride_window_dwords =\r\nqed_rd(p_hwfn, p_ptt,\r\nGRC_REG_NUMBER_VALID_OVERRIDE_WINDOW) *\r\nPROTECTION_OVERRIDE_ELEMENT_DWORDS;\r\nif (qed_dmae_grc2host(p_hwfn, p_ptt,\r\nGRC_REG_PROTECTION_OVERRIDE_WINDOW,\r\n(u64)(uintptr_t)(dump_buf + offset),\r\noverride_window_dwords, 0))\r\nreturn DBG_STATUS_DMAE_FAILED;\r\noffset += override_window_dwords;\r\nqed_dump_num_param(dump_buf + size_param_offset, dump, "size",\r\noverride_window_dwords);\r\nout:\r\noffset += qed_dump_last_section(p_hwfn, dump_buf, offset, dump);\r\n*num_dumped_dwords = offset;\r\nreturn DBG_STATUS_OK;\r\n}\r\nstatic u32 qed_fw_asserts_dump(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt, u32 *dump_buf, bool dump)\r\n{\r\nstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\r\nstruct fw_asserts_ram_section *asserts;\r\nchar storm_letter_str[2] = "?";\r\nstruct fw_info fw_info;\r\nu32 offset = 0;\r\nu8 storm_id;\r\noffset += qed_dump_common_global_params(p_hwfn,\r\np_ptt,\r\ndump_buf + offset, dump, 1);\r\noffset += qed_dump_str_param(dump_buf + offset,\r\ndump, "dump-type", "fw-asserts");\r\nfor (storm_id = 0; storm_id < MAX_DBG_STORMS; storm_id++) {\r\nu32 fw_asserts_section_addr, next_list_idx_addr, next_list_idx;\r\nstruct storm_defs *storm = &s_storm_defs[storm_id];\r\nu32 last_list_idx, addr;\r\nif (dev_data->block_in_reset[storm->block_id])\r\ncontinue;\r\nqed_read_fw_info(p_hwfn, p_ptt, storm_id, &fw_info);\r\nasserts = &fw_info.fw_asserts_section;\r\nstorm_letter_str[0] = storm->letter;\r\noffset += qed_dump_section_hdr(dump_buf + offset,\r\ndump, "fw_asserts", 2);\r\noffset += qed_dump_str_param(dump_buf + offset,\r\ndump, "storm", storm_letter_str);\r\noffset += qed_dump_num_param(dump_buf + offset,\r\ndump,\r\n"size",\r\nasserts->list_element_dword_size);\r\nif (!dump) {\r\noffset += asserts->list_element_dword_size;\r\ncontinue;\r\n}\r\nfw_asserts_section_addr = storm->sem_fast_mem_addr +\r\nSEM_FAST_REG_INT_RAM +\r\nRAM_LINES_TO_BYTES(asserts->section_ram_line_offset);\r\nnext_list_idx_addr = fw_asserts_section_addr +\r\nDWORDS_TO_BYTES(asserts->list_next_index_dword_offset);\r\nnext_list_idx = qed_rd(p_hwfn, p_ptt, next_list_idx_addr);\r\nlast_list_idx = (next_list_idx > 0\r\n? next_list_idx\r\n: asserts->list_num_elements) - 1;\r\naddr = BYTES_TO_DWORDS(fw_asserts_section_addr) +\r\nasserts->list_dword_offset +\r\nlast_list_idx * asserts->list_element_dword_size;\r\noffset +=\r\nqed_grc_dump_addr_range(p_hwfn, p_ptt,\r\ndump_buf + offset,\r\ndump, addr,\r\nasserts->list_element_dword_size,\r\nfalse);\r\n}\r\noffset += qed_dump_last_section(p_hwfn, dump_buf, offset, dump);\r\nreturn offset;\r\n}\r\nenum dbg_status qed_dbg_set_bin_ptr(const u8 * const bin_ptr)\r\n{\r\nstruct bin_buffer_hdr *buf_array = (struct bin_buffer_hdr *)bin_ptr;\r\nu8 buf_id;\r\nfor (buf_id = 0; buf_id < MAX_BIN_DBG_BUFFER_TYPE; buf_id++) {\r\ns_dbg_arrays[buf_id].ptr =\r\n(u32 *)(bin_ptr + buf_array[buf_id].offset);\r\ns_dbg_arrays[buf_id].size_in_dwords =\r\nBYTES_TO_DWORDS(buf_array[buf_id].length);\r\n}\r\nreturn DBG_STATUS_OK;\r\n}\r\nvoid qed_dbg_grc_set_params_default(struct qed_hwfn *p_hwfn)\r\n{\r\nstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\r\nu32 i;\r\nfor (i = 0; i < MAX_DBG_GRC_PARAMS; i++)\r\ndev_data->grc.param_val[i] =\r\ns_grc_param_defs[i].default_val[dev_data->chip_id];\r\n}\r\nenum dbg_status qed_dbg_grc_get_dump_buf_size(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 *buf_size)\r\n{\r\nenum dbg_status status = qed_dbg_dev_init(p_hwfn, p_ptt);\r\n*buf_size = 0;\r\nif (status != DBG_STATUS_OK)\r\nreturn status;\r\nif (!s_dbg_arrays[BIN_BUF_DBG_MODE_TREE].ptr ||\r\n!s_dbg_arrays[BIN_BUF_DBG_DUMP_REG].ptr ||\r\n!s_dbg_arrays[BIN_BUF_DBG_DUMP_MEM].ptr ||\r\n!s_dbg_arrays[BIN_BUF_DBG_ATTN_BLOCKS].ptr ||\r\n!s_dbg_arrays[BIN_BUF_DBG_ATTN_REGS].ptr)\r\nreturn DBG_STATUS_DBG_ARRAY_NOT_SET;\r\nreturn qed_grc_dump(p_hwfn, p_ptt, NULL, false, buf_size);\r\n}\r\nenum dbg_status qed_dbg_grc_dump(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 *dump_buf,\r\nu32 buf_size_in_dwords,\r\nu32 *num_dumped_dwords)\r\n{\r\nu32 needed_buf_size_in_dwords;\r\nenum dbg_status status;\r\n*num_dumped_dwords = 0;\r\nstatus = qed_dbg_grc_get_dump_buf_size(p_hwfn,\r\np_ptt,\r\n&needed_buf_size_in_dwords);\r\nif (status != DBG_STATUS_OK)\r\nreturn status;\r\nif (buf_size_in_dwords < needed_buf_size_in_dwords)\r\nreturn DBG_STATUS_DUMP_BUF_TOO_SMALL;\r\nstatus = qed_grc_dump(p_hwfn, p_ptt, dump_buf, true, num_dumped_dwords);\r\nqed_dbg_grc_set_params_default(p_hwfn);\r\nreturn status;\r\n}\r\nenum dbg_status qed_dbg_idle_chk_get_dump_buf_size(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 *buf_size)\r\n{\r\nstruct dbg_tools_data *dev_data = &p_hwfn->dbg_info;\r\nstruct idle_chk_data *idle_chk;\r\nenum dbg_status status;\r\nidle_chk = &dev_data->idle_chk;\r\n*buf_size = 0;\r\nstatus = qed_dbg_dev_init(p_hwfn, p_ptt);\r\nif (status != DBG_STATUS_OK)\r\nreturn status;\r\nif (!s_dbg_arrays[BIN_BUF_DBG_MODE_TREE].ptr ||\r\n!s_dbg_arrays[BIN_BUF_DBG_IDLE_CHK_REGS].ptr ||\r\n!s_dbg_arrays[BIN_BUF_DBG_IDLE_CHK_IMMS].ptr ||\r\n!s_dbg_arrays[BIN_BUF_DBG_IDLE_CHK_RULES].ptr)\r\nreturn DBG_STATUS_DBG_ARRAY_NOT_SET;\r\nif (!idle_chk->buf_size_set) {\r\nidle_chk->buf_size = qed_idle_chk_dump(p_hwfn,\r\np_ptt, NULL, false);\r\nidle_chk->buf_size_set = true;\r\n}\r\n*buf_size = idle_chk->buf_size;\r\nreturn DBG_STATUS_OK;\r\n}\r\nenum dbg_status qed_dbg_idle_chk_dump(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 *dump_buf,\r\nu32 buf_size_in_dwords,\r\nu32 *num_dumped_dwords)\r\n{\r\nu32 needed_buf_size_in_dwords;\r\nenum dbg_status status;\r\n*num_dumped_dwords = 0;\r\nstatus = qed_dbg_idle_chk_get_dump_buf_size(p_hwfn,\r\np_ptt,\r\n&needed_buf_size_in_dwords);\r\nif (status != DBG_STATUS_OK)\r\nreturn status;\r\nif (buf_size_in_dwords < needed_buf_size_in_dwords)\r\nreturn DBG_STATUS_DUMP_BUF_TOO_SMALL;\r\nqed_update_blocks_reset_state(p_hwfn, p_ptt);\r\n*num_dumped_dwords = qed_idle_chk_dump(p_hwfn, p_ptt, dump_buf, true);\r\nqed_dbg_grc_set_params_default(p_hwfn);\r\nreturn DBG_STATUS_OK;\r\n}\r\nenum dbg_status qed_dbg_mcp_trace_get_dump_buf_size(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 *buf_size)\r\n{\r\nenum dbg_status status = qed_dbg_dev_init(p_hwfn, p_ptt);\r\n*buf_size = 0;\r\nif (status != DBG_STATUS_OK)\r\nreturn status;\r\nreturn qed_mcp_trace_dump(p_hwfn, p_ptt, NULL, false, buf_size);\r\n}\r\nenum dbg_status qed_dbg_mcp_trace_dump(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 *dump_buf,\r\nu32 buf_size_in_dwords,\r\nu32 *num_dumped_dwords)\r\n{\r\nu32 needed_buf_size_in_dwords;\r\nenum dbg_status status;\r\nstatus =\r\nqed_dbg_mcp_trace_get_dump_buf_size(p_hwfn,\r\np_ptt,\r\n&needed_buf_size_in_dwords);\r\nif (status != DBG_STATUS_OK && status !=\r\nDBG_STATUS_NVRAM_GET_IMAGE_FAILED)\r\nreturn status;\r\nif (buf_size_in_dwords < needed_buf_size_in_dwords)\r\nreturn DBG_STATUS_DUMP_BUF_TOO_SMALL;\r\nqed_update_blocks_reset_state(p_hwfn, p_ptt);\r\nstatus = qed_mcp_trace_dump(p_hwfn,\r\np_ptt, dump_buf, true, num_dumped_dwords);\r\nqed_dbg_grc_set_params_default(p_hwfn);\r\nreturn status;\r\n}\r\nenum dbg_status qed_dbg_reg_fifo_get_dump_buf_size(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 *buf_size)\r\n{\r\nenum dbg_status status = qed_dbg_dev_init(p_hwfn, p_ptt);\r\n*buf_size = 0;\r\nif (status != DBG_STATUS_OK)\r\nreturn status;\r\nreturn qed_reg_fifo_dump(p_hwfn, p_ptt, NULL, false, buf_size);\r\n}\r\nenum dbg_status qed_dbg_reg_fifo_dump(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 *dump_buf,\r\nu32 buf_size_in_dwords,\r\nu32 *num_dumped_dwords)\r\n{\r\nu32 needed_buf_size_in_dwords;\r\nenum dbg_status status;\r\n*num_dumped_dwords = 0;\r\nstatus = qed_dbg_reg_fifo_get_dump_buf_size(p_hwfn,\r\np_ptt,\r\n&needed_buf_size_in_dwords);\r\nif (status != DBG_STATUS_OK)\r\nreturn status;\r\nif (buf_size_in_dwords < needed_buf_size_in_dwords)\r\nreturn DBG_STATUS_DUMP_BUF_TOO_SMALL;\r\nqed_update_blocks_reset_state(p_hwfn, p_ptt);\r\nstatus = qed_reg_fifo_dump(p_hwfn,\r\np_ptt, dump_buf, true, num_dumped_dwords);\r\nqed_dbg_grc_set_params_default(p_hwfn);\r\nreturn status;\r\n}\r\nenum dbg_status qed_dbg_igu_fifo_get_dump_buf_size(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 *buf_size)\r\n{\r\nenum dbg_status status = qed_dbg_dev_init(p_hwfn, p_ptt);\r\n*buf_size = 0;\r\nif (status != DBG_STATUS_OK)\r\nreturn status;\r\nreturn qed_igu_fifo_dump(p_hwfn, p_ptt, NULL, false, buf_size);\r\n}\r\nenum dbg_status qed_dbg_igu_fifo_dump(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 *dump_buf,\r\nu32 buf_size_in_dwords,\r\nu32 *num_dumped_dwords)\r\n{\r\nu32 needed_buf_size_in_dwords;\r\nenum dbg_status status;\r\n*num_dumped_dwords = 0;\r\nstatus = qed_dbg_igu_fifo_get_dump_buf_size(p_hwfn,\r\np_ptt,\r\n&needed_buf_size_in_dwords);\r\nif (status != DBG_STATUS_OK)\r\nreturn status;\r\nif (buf_size_in_dwords < needed_buf_size_in_dwords)\r\nreturn DBG_STATUS_DUMP_BUF_TOO_SMALL;\r\nqed_update_blocks_reset_state(p_hwfn, p_ptt);\r\nstatus = qed_igu_fifo_dump(p_hwfn,\r\np_ptt, dump_buf, true, num_dumped_dwords);\r\nqed_dbg_grc_set_params_default(p_hwfn);\r\nreturn status;\r\n}\r\nenum dbg_status\r\nqed_dbg_protection_override_get_dump_buf_size(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 *buf_size)\r\n{\r\nenum dbg_status status = qed_dbg_dev_init(p_hwfn, p_ptt);\r\n*buf_size = 0;\r\nif (status != DBG_STATUS_OK)\r\nreturn status;\r\nreturn qed_protection_override_dump(p_hwfn,\r\np_ptt, NULL, false, buf_size);\r\n}\r\nenum dbg_status qed_dbg_protection_override_dump(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 *dump_buf,\r\nu32 buf_size_in_dwords,\r\nu32 *num_dumped_dwords)\r\n{\r\nu32 needed_buf_size_in_dwords, *p_size = &needed_buf_size_in_dwords;\r\nenum dbg_status status;\r\n*num_dumped_dwords = 0;\r\nstatus =\r\nqed_dbg_protection_override_get_dump_buf_size(p_hwfn,\r\np_ptt,\r\np_size);\r\nif (status != DBG_STATUS_OK)\r\nreturn status;\r\nif (buf_size_in_dwords < needed_buf_size_in_dwords)\r\nreturn DBG_STATUS_DUMP_BUF_TOO_SMALL;\r\nqed_update_blocks_reset_state(p_hwfn, p_ptt);\r\nstatus = qed_protection_override_dump(p_hwfn,\r\np_ptt,\r\ndump_buf,\r\ntrue, num_dumped_dwords);\r\nqed_dbg_grc_set_params_default(p_hwfn);\r\nreturn status;\r\n}\r\nenum dbg_status qed_dbg_fw_asserts_get_dump_buf_size(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 *buf_size)\r\n{\r\nenum dbg_status status = qed_dbg_dev_init(p_hwfn, p_ptt);\r\n*buf_size = 0;\r\nif (status != DBG_STATUS_OK)\r\nreturn status;\r\nqed_update_blocks_reset_state(p_hwfn, p_ptt);\r\n*buf_size = qed_fw_asserts_dump(p_hwfn, p_ptt, NULL, false);\r\nreturn DBG_STATUS_OK;\r\n}\r\nenum dbg_status qed_dbg_fw_asserts_dump(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 *dump_buf,\r\nu32 buf_size_in_dwords,\r\nu32 *num_dumped_dwords)\r\n{\r\nu32 needed_buf_size_in_dwords, *p_size = &needed_buf_size_in_dwords;\r\nenum dbg_status status;\r\n*num_dumped_dwords = 0;\r\nstatus =\r\nqed_dbg_fw_asserts_get_dump_buf_size(p_hwfn,\r\np_ptt,\r\np_size);\r\nif (status != DBG_STATUS_OK)\r\nreturn status;\r\nif (buf_size_in_dwords < needed_buf_size_in_dwords)\r\nreturn DBG_STATUS_DUMP_BUF_TOO_SMALL;\r\n*num_dumped_dwords = qed_fw_asserts_dump(p_hwfn, p_ptt, dump_buf, true);\r\nqed_dbg_grc_set_params_default(p_hwfn);\r\nreturn DBG_STATUS_OK;\r\n}\r\nenum dbg_status qed_dbg_read_attn(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nenum block_id block_id,\r\nenum dbg_attn_type attn_type,\r\nbool clear_status,\r\nstruct dbg_attn_block_result *results)\r\n{\r\nenum dbg_status status = qed_dbg_dev_init(p_hwfn, p_ptt);\r\nu8 reg_idx, num_attn_regs, num_result_regs = 0;\r\nconst struct dbg_attn_reg *attn_reg_arr;\r\nif (status != DBG_STATUS_OK)\r\nreturn status;\r\nif (!s_dbg_arrays[BIN_BUF_DBG_MODE_TREE].ptr ||\r\n!s_dbg_arrays[BIN_BUF_DBG_ATTN_BLOCKS].ptr ||\r\n!s_dbg_arrays[BIN_BUF_DBG_ATTN_REGS].ptr)\r\nreturn DBG_STATUS_DBG_ARRAY_NOT_SET;\r\nattn_reg_arr = qed_get_block_attn_regs(block_id,\r\nattn_type, &num_attn_regs);\r\nfor (reg_idx = 0; reg_idx < num_attn_regs; reg_idx++) {\r\nconst struct dbg_attn_reg *reg_data = &attn_reg_arr[reg_idx];\r\nstruct dbg_attn_reg_result *reg_result;\r\nu32 sts_addr, sts_val;\r\nu16 modes_buf_offset;\r\nbool eval_mode;\r\neval_mode = GET_FIELD(reg_data->mode.data,\r\nDBG_MODE_HDR_EVAL_MODE) > 0;\r\nmodes_buf_offset = GET_FIELD(reg_data->mode.data,\r\nDBG_MODE_HDR_MODES_BUF_OFFSET);\r\nif (eval_mode && !qed_is_mode_match(p_hwfn, &modes_buf_offset))\r\ncontinue;\r\nsts_addr = DWORDS_TO_BYTES(clear_status ?\r\nreg_data->sts_clr_address :\r\nGET_FIELD(reg_data->data,\r\nDBG_ATTN_REG_STS_ADDRESS));\r\nsts_val = qed_rd(p_hwfn, p_ptt, sts_addr);\r\nif (!sts_val)\r\ncontinue;\r\nreg_result = &results->reg_results[num_result_regs];\r\nSET_FIELD(reg_result->data,\r\nDBG_ATTN_REG_RESULT_STS_ADDRESS, sts_addr);\r\nSET_FIELD(reg_result->data,\r\nDBG_ATTN_REG_RESULT_NUM_REG_ATTN,\r\nGET_FIELD(reg_data->data, DBG_ATTN_REG_NUM_REG_ATTN));\r\nreg_result->block_attn_offset = reg_data->block_attn_offset;\r\nreg_result->sts_val = sts_val;\r\nreg_result->mask_val = qed_rd(p_hwfn,\r\np_ptt,\r\nDWORDS_TO_BYTES\r\n(reg_data->mask_address));\r\nnum_result_regs++;\r\n}\r\nresults->block_id = (u8)block_id;\r\nresults->names_offset =\r\nqed_get_block_attn_data(block_id, attn_type)->names_offset;\r\nSET_FIELD(results->data, DBG_ATTN_BLOCK_RESULT_ATTN_TYPE, attn_type);\r\nSET_FIELD(results->data,\r\nDBG_ATTN_BLOCK_RESULT_NUM_REGS, num_result_regs);\r\nreturn DBG_STATUS_OK;\r\n}\r\nstatic u32 qed_cyclic_add(u32 a, u32 b, u32 size)\r\n{\r\nreturn (a + b) % size;\r\n}\r\nstatic u32 qed_cyclic_sub(u32 a, u32 b, u32 size)\r\n{\r\nreturn (size + a - b) % size;\r\n}\r\nstatic u32 qed_read_from_cyclic_buf(void *buf,\r\nu32 *offset,\r\nu32 buf_size, u8 num_bytes_to_read)\r\n{\r\nu8 i, *val_ptr, *bytes_buf = (u8 *)buf;\r\nu32 val = 0;\r\nval_ptr = (u8 *)&val;\r\nfor (i = 0; i < num_bytes_to_read; i++) {\r\nval_ptr[i] = bytes_buf[*offset];\r\n*offset = qed_cyclic_add(*offset, 1, buf_size);\r\n}\r\nreturn val;\r\n}\r\nstatic u8 qed_read_byte_from_buf(void *buf, u32 *offset)\r\n{\r\nreturn ((u8 *)buf)[(*offset)++];\r\n}\r\nstatic u32 qed_read_dword_from_buf(void *buf, u32 *offset)\r\n{\r\nu32 dword_val = *(u32 *)&((u8 *)buf)[*offset];\r\n*offset += 4;\r\nreturn dword_val;\r\n}\r\nstatic void qed_read_str_from_buf(void *buf, u32 *offset, u32 size, char *dest)\r\n{\r\nconst char *source_str = &((const char *)buf)[*offset];\r\nstrncpy(dest, source_str, size);\r\ndest[size - 1] = '\0';\r\n*offset += size;\r\n}\r\nstatic char *qed_get_buf_ptr(void *buf, u32 offset)\r\n{\r\nreturn buf ? (char *)buf + offset : s_temp_buf;\r\n}\r\nstatic u32 qed_read_param(u32 *dump_buf,\r\nconst char **param_name,\r\nconst char **param_str_val, u32 *param_num_val)\r\n{\r\nchar *char_buf = (char *)dump_buf;\r\nsize_t offset = 0;\r\n*param_name = char_buf;\r\noffset += strlen(*param_name) + 1;\r\nif (*(char_buf + offset++)) {\r\n*param_str_val = char_buf + offset;\r\noffset += strlen(*param_str_val) + 1;\r\nif (offset & 0x3)\r\noffset += (4 - (offset & 0x3));\r\n} else {\r\n*param_str_val = NULL;\r\nif (offset & 0x3)\r\noffset += (4 - (offset & 0x3));\r\n*param_num_val = *(u32 *)(char_buf + offset);\r\noffset += 4;\r\n}\r\nreturn offset / 4;\r\n}\r\nstatic u32 qed_read_section_hdr(u32 *dump_buf,\r\nconst char **section_name,\r\nu32 *num_section_params)\r\n{\r\nconst char *param_str_val;\r\nreturn qed_read_param(dump_buf,\r\nsection_name, &param_str_val, num_section_params);\r\n}\r\nstatic u32 qed_print_section_params(u32 *dump_buf,\r\nu32 num_section_params,\r\nchar *results_buf, u32 *num_chars_printed)\r\n{\r\nu32 i, dump_offset = 0, results_offset = 0;\r\nfor (i = 0; i < num_section_params; i++) {\r\nconst char *param_name, *param_str_val;\r\nu32 param_num_val = 0;\r\ndump_offset += qed_read_param(dump_buf + dump_offset,\r\n&param_name,\r\n&param_str_val, &param_num_val);\r\nif (param_str_val)\r\nresults_offset +=\r\nsprintf(qed_get_buf_ptr(results_buf,\r\nresults_offset),\r\n"%s: %s\n", param_name, param_str_val);\r\nelse if (strcmp(param_name, "fw-timestamp"))\r\nresults_offset +=\r\nsprintf(qed_get_buf_ptr(results_buf,\r\nresults_offset),\r\n"%s: %d\n", param_name, param_num_val);\r\n}\r\nresults_offset += sprintf(qed_get_buf_ptr(results_buf, results_offset),\r\n"\n");\r\n*num_chars_printed = results_offset;\r\nreturn dump_offset;\r\n}\r\nstatic u32 qed_parse_idle_chk_dump_rules(struct qed_hwfn *p_hwfn,\r\nu32 *dump_buf,\r\nu32 *dump_buf_end,\r\nu32 num_rules,\r\nbool print_fw_idle_chk,\r\nchar *results_buf,\r\nu32 *num_errors, u32 *num_warnings)\r\n{\r\nu32 results_offset = 0;\r\nu32 rule_idx;\r\nu16 i, j;\r\n*num_errors = 0;\r\n*num_warnings = 0;\r\nfor (rule_idx = 0; rule_idx < num_rules && dump_buf < dump_buf_end;\r\nrule_idx++) {\r\nconst struct dbg_idle_chk_rule_parsing_data *rule_parsing_data;\r\nstruct dbg_idle_chk_result_hdr *hdr;\r\nconst char *parsing_str, *lsi_msg;\r\nu32 parsing_str_offset;\r\nbool has_fw_msg;\r\nu8 curr_reg_id;\r\nhdr = (struct dbg_idle_chk_result_hdr *)dump_buf;\r\nrule_parsing_data =\r\n(const struct dbg_idle_chk_rule_parsing_data *)\r\n&s_user_dbg_arrays[BIN_BUF_DBG_IDLE_CHK_PARSING_DATA].\r\nptr[hdr->rule_id];\r\nparsing_str_offset =\r\nGET_FIELD(rule_parsing_data->data,\r\nDBG_IDLE_CHK_RULE_PARSING_DATA_STR_OFFSET);\r\nhas_fw_msg =\r\nGET_FIELD(rule_parsing_data->data,\r\nDBG_IDLE_CHK_RULE_PARSING_DATA_HAS_FW_MSG) > 0;\r\nparsing_str =\r\n&((const char *)\r\ns_user_dbg_arrays[BIN_BUF_DBG_PARSING_STRINGS].ptr)\r\n[parsing_str_offset];\r\nlsi_msg = parsing_str;\r\ncurr_reg_id = 0;\r\nif (hdr->severity >= MAX_DBG_IDLE_CHK_SEVERITY_TYPES)\r\nreturn 0;\r\ndump_buf += BYTES_TO_DWORDS(sizeof(*hdr));\r\nif (hdr->severity == IDLE_CHK_SEVERITY_ERROR ||\r\nhdr->severity == IDLE_CHK_SEVERITY_ERROR_NO_TRAFFIC)\r\n(*num_errors)++;\r\nelse\r\n(*num_warnings)++;\r\nresults_offset +=\r\nsprintf(qed_get_buf_ptr(results_buf,\r\nresults_offset), "%s: ",\r\ns_idle_chk_severity_str[hdr->severity]);\r\nif (has_fw_msg)\r\nparsing_str += strlen(parsing_str) + 1;\r\nresults_offset +=\r\nsprintf(qed_get_buf_ptr(results_buf,\r\nresults_offset), "%s.",\r\nhas_fw_msg &&\r\nprint_fw_idle_chk ? parsing_str : lsi_msg);\r\nparsing_str += strlen(parsing_str) + 1;\r\nresults_offset +=\r\nsprintf(qed_get_buf_ptr(results_buf,\r\nresults_offset), " Registers:");\r\nfor (i = 0;\r\ni < hdr->num_dumped_cond_regs + hdr->num_dumped_info_regs;\r\ni++) {\r\nstruct dbg_idle_chk_result_reg_hdr *reg_hdr;\r\nbool is_mem;\r\nu8 reg_id;\r\nreg_hdr =\r\n(struct dbg_idle_chk_result_reg_hdr *)dump_buf;\r\nis_mem = GET_FIELD(reg_hdr->data,\r\nDBG_IDLE_CHK_RESULT_REG_HDR_IS_MEM);\r\nreg_id = GET_FIELD(reg_hdr->data,\r\nDBG_IDLE_CHK_RESULT_REG_HDR_REG_ID);\r\ndump_buf += BYTES_TO_DWORDS(sizeof(*reg_hdr));\r\nfor (; reg_id > curr_reg_id;\r\ncurr_reg_id++,\r\nparsing_str += strlen(parsing_str) + 1);\r\nresults_offset +=\r\nsprintf(qed_get_buf_ptr(results_buf,\r\nresults_offset), " %s",\r\nparsing_str);\r\nif (i < hdr->num_dumped_cond_regs && is_mem)\r\nresults_offset +=\r\nsprintf(qed_get_buf_ptr(results_buf,\r\nresults_offset),\r\n"[%d]", hdr->mem_entry_id +\r\nreg_hdr->start_entry);\r\nresults_offset +=\r\nsprintf(qed_get_buf_ptr(results_buf,\r\nresults_offset), "=");\r\nfor (j = 0; j < reg_hdr->size; j++, dump_buf++) {\r\nresults_offset +=\r\nsprintf(qed_get_buf_ptr(results_buf,\r\nresults_offset),\r\n"0x%x", *dump_buf);\r\nif (j < reg_hdr->size - 1)\r\nresults_offset +=\r\nsprintf(qed_get_buf_ptr\r\n(results_buf,\r\nresults_offset), ",");\r\n}\r\n}\r\nresults_offset +=\r\nsprintf(qed_get_buf_ptr(results_buf, results_offset), "\n");\r\n}\r\nif (dump_buf > dump_buf_end)\r\nreturn 0;\r\nreturn results_offset;\r\n}\r\nstatic enum dbg_status qed_parse_idle_chk_dump(struct qed_hwfn *p_hwfn,\r\nu32 *dump_buf,\r\nu32 num_dumped_dwords,\r\nchar *results_buf,\r\nu32 *parsed_results_bytes,\r\nu32 *num_errors,\r\nu32 *num_warnings)\r\n{\r\nconst char *section_name, *param_name, *param_str_val;\r\nu32 *dump_buf_end = dump_buf + num_dumped_dwords;\r\nu32 num_section_params = 0, num_rules;\r\nu32 results_offset = 0;\r\n*parsed_results_bytes = 0;\r\n*num_errors = 0;\r\n*num_warnings = 0;\r\nif (!s_user_dbg_arrays[BIN_BUF_DBG_PARSING_STRINGS].ptr ||\r\n!s_user_dbg_arrays[BIN_BUF_DBG_IDLE_CHK_PARSING_DATA].ptr)\r\nreturn DBG_STATUS_DBG_ARRAY_NOT_SET;\r\ndump_buf += qed_read_section_hdr(dump_buf,\r\n&section_name, &num_section_params);\r\nif (strcmp(section_name, "global_params"))\r\nreturn DBG_STATUS_IDLE_CHK_PARSE_FAILED;\r\ndump_buf += qed_print_section_params(dump_buf,\r\nnum_section_params,\r\nresults_buf, &results_offset);\r\ndump_buf += qed_read_section_hdr(dump_buf,\r\n&section_name, &num_section_params);\r\nif (strcmp(section_name, "idle_chk") || num_section_params != 1)\r\nreturn DBG_STATUS_IDLE_CHK_PARSE_FAILED;\r\ndump_buf += qed_read_param(dump_buf,\r\n&param_name, &param_str_val, &num_rules);\r\nif (strcmp(param_name, "num_rules"))\r\nreturn DBG_STATUS_IDLE_CHK_PARSE_FAILED;\r\nif (num_rules) {\r\nu32 rules_print_size;\r\nresults_offset +=\r\nsprintf(qed_get_buf_ptr(results_buf,\r\nresults_offset),\r\n"FW_IDLE_CHECK:\n");\r\nrules_print_size =\r\nqed_parse_idle_chk_dump_rules(p_hwfn, dump_buf,\r\ndump_buf_end, num_rules,\r\ntrue,\r\nresults_buf ?\r\nresults_buf +\r\nresults_offset : NULL,\r\nnum_errors, num_warnings);\r\nresults_offset += rules_print_size;\r\nif (!rules_print_size)\r\nreturn DBG_STATUS_IDLE_CHK_PARSE_FAILED;\r\nresults_offset +=\r\nsprintf(qed_get_buf_ptr(results_buf,\r\nresults_offset),\r\n"\nLSI_IDLE_CHECK:\n");\r\nrules_print_size =\r\nqed_parse_idle_chk_dump_rules(p_hwfn, dump_buf,\r\ndump_buf_end, num_rules,\r\nfalse,\r\nresults_buf ?\r\nresults_buf +\r\nresults_offset : NULL,\r\nnum_errors, num_warnings);\r\nresults_offset += rules_print_size;\r\nif (!rules_print_size)\r\nreturn DBG_STATUS_IDLE_CHK_PARSE_FAILED;\r\n}\r\nif (*num_errors)\r\nresults_offset +=\r\nsprintf(qed_get_buf_ptr(results_buf,\r\nresults_offset),\r\n"\nIdle Check failed!!! (with %d errors and %d warnings)\n",\r\n*num_errors, *num_warnings);\r\nelse if (*num_warnings)\r\nresults_offset +=\r\nsprintf(qed_get_buf_ptr(results_buf,\r\nresults_offset),\r\n"\nIdle Check completed successfully (with %d warnings)\n",\r\n*num_warnings);\r\nelse\r\nresults_offset +=\r\nsprintf(qed_get_buf_ptr(results_buf,\r\nresults_offset),\r\n"\nIdle Check completed successfully\n");\r\n*parsed_results_bytes = results_offset + 1;\r\nreturn DBG_STATUS_OK;\r\n}\r\nstatic void qed_mcp_trace_free_meta(struct qed_hwfn *p_hwfn,\r\nstruct mcp_trace_meta *meta)\r\n{\r\nu32 i;\r\nif (meta->modules) {\r\nfor (i = 0; i < meta->modules_num; i++)\r\nkfree(meta->modules[i]);\r\nkfree(meta->modules);\r\n}\r\nif (meta->formats) {\r\nfor (i = 0; i < meta->formats_num; i++)\r\nkfree(meta->formats[i].format_str);\r\nkfree(meta->formats);\r\n}\r\n}\r\nstatic enum dbg_status qed_mcp_trace_alloc_meta(struct qed_hwfn *p_hwfn,\r\nconst u32 *meta_buf,\r\nstruct mcp_trace_meta *meta)\r\n{\r\nu8 *meta_buf_bytes = (u8 *)meta_buf;\r\nu32 offset = 0, signature, i;\r\nmemset(meta, 0, sizeof(*meta));\r\nsignature = qed_read_dword_from_buf(meta_buf_bytes, &offset);\r\nif (signature != NVM_MAGIC_VALUE)\r\nreturn DBG_STATUS_INVALID_TRACE_SIGNATURE;\r\nmeta->modules_num = qed_read_byte_from_buf(meta_buf_bytes, &offset);\r\nmeta->modules = kzalloc(meta->modules_num * sizeof(char *), GFP_KERNEL);\r\nif (!meta->modules)\r\nreturn DBG_STATUS_VIRT_MEM_ALLOC_FAILED;\r\nfor (i = 0; i < meta->modules_num; i++) {\r\nu8 module_len = qed_read_byte_from_buf(meta_buf_bytes, &offset);\r\n*(meta->modules + i) = kzalloc(module_len, GFP_KERNEL);\r\nif (!(*(meta->modules + i))) {\r\nmeta->modules_num = i ? i - 1 : 0;\r\nreturn DBG_STATUS_VIRT_MEM_ALLOC_FAILED;\r\n}\r\nqed_read_str_from_buf(meta_buf_bytes, &offset, module_len,\r\n*(meta->modules + i));\r\nif (module_len > MCP_TRACE_MAX_MODULE_LEN)\r\n(*(meta->modules + i))[MCP_TRACE_MAX_MODULE_LEN] = '\0';\r\n}\r\nsignature = qed_read_dword_from_buf(meta_buf_bytes, &offset);\r\nif (signature != NVM_MAGIC_VALUE)\r\nreturn DBG_STATUS_INVALID_TRACE_SIGNATURE;\r\nmeta->formats_num = qed_read_dword_from_buf(meta_buf_bytes, &offset);\r\nmeta->formats = kzalloc(meta->formats_num *\r\nsizeof(struct mcp_trace_format),\r\nGFP_KERNEL);\r\nif (!meta->formats)\r\nreturn DBG_STATUS_VIRT_MEM_ALLOC_FAILED;\r\nfor (i = 0; i < meta->formats_num; i++) {\r\nstruct mcp_trace_format *format_ptr = &meta->formats[i];\r\nu8 format_len;\r\nformat_ptr->data = qed_read_dword_from_buf(meta_buf_bytes,\r\n&offset);\r\nformat_len =\r\n(format_ptr->data &\r\nMCP_TRACE_FORMAT_LEN_MASK) >> MCP_TRACE_FORMAT_LEN_SHIFT;\r\nformat_ptr->format_str = kzalloc(format_len, GFP_KERNEL);\r\nif (!format_ptr->format_str) {\r\nmeta->formats_num = i ? i - 1 : 0;\r\nreturn DBG_STATUS_VIRT_MEM_ALLOC_FAILED;\r\n}\r\nqed_read_str_from_buf(meta_buf_bytes,\r\n&offset,\r\nformat_len, format_ptr->format_str);\r\n}\r\nreturn DBG_STATUS_OK;\r\n}\r\nstatic enum dbg_status qed_parse_mcp_trace_dump(struct qed_hwfn *p_hwfn,\r\nu32 *dump_buf,\r\nu32 num_dumped_dwords,\r\nchar *results_buf,\r\nu32 *parsed_results_bytes)\r\n{\r\nu32 end_offset, bytes_left, trace_data_dwords, trace_meta_dwords;\r\nu32 param_mask, param_shift, param_num_val, num_section_params;\r\nconst char *section_name, *param_name, *param_str_val;\r\nu32 offset, results_offset = 0;\r\nstruct mcp_trace_meta meta;\r\nstruct mcp_trace *trace;\r\nenum dbg_status status;\r\nconst u32 *meta_buf;\r\nu8 *trace_buf;\r\n*parsed_results_bytes = 0;\r\ndump_buf += qed_read_section_hdr(dump_buf,\r\n&section_name, &num_section_params);\r\nif (strcmp(section_name, "global_params"))\r\nreturn DBG_STATUS_MCP_TRACE_BAD_DATA;\r\ndump_buf += qed_print_section_params(dump_buf,\r\nnum_section_params,\r\nresults_buf, &results_offset);\r\ndump_buf += qed_read_section_hdr(dump_buf,\r\n&section_name, &num_section_params);\r\nif (strcmp(section_name, "mcp_trace_data") || num_section_params != 1)\r\nreturn DBG_STATUS_MCP_TRACE_BAD_DATA;\r\ndump_buf += qed_read_param(dump_buf,\r\n&param_name, &param_str_val, &param_num_val);\r\nif (strcmp(param_name, "size"))\r\nreturn DBG_STATUS_MCP_TRACE_BAD_DATA;\r\ntrace_data_dwords = param_num_val;\r\ntrace = (struct mcp_trace *)dump_buf;\r\ntrace_buf = (u8 *)dump_buf + sizeof(*trace);\r\noffset = trace->trace_oldest;\r\nend_offset = trace->trace_prod;\r\nbytes_left = qed_cyclic_sub(end_offset, offset, trace->size);\r\ndump_buf += trace_data_dwords;\r\ndump_buf += qed_read_section_hdr(dump_buf,\r\n&section_name, &num_section_params);\r\nif (strcmp(section_name, "mcp_trace_meta"))\r\nreturn DBG_STATUS_MCP_TRACE_BAD_DATA;\r\ndump_buf += qed_read_param(dump_buf,\r\n&param_name, &param_str_val, &param_num_val);\r\nif (strcmp(param_name, "size"))\r\nreturn DBG_STATUS_MCP_TRACE_BAD_DATA;\r\ntrace_meta_dwords = param_num_val;\r\nif (!trace_meta_dwords) {\r\nif (!s_mcp_trace_meta.ptr)\r\nreturn DBG_STATUS_MCP_TRACE_NO_META;\r\nmeta_buf = s_mcp_trace_meta.ptr;\r\n} else {\r\nmeta_buf = dump_buf;\r\n}\r\nstatus = qed_mcp_trace_alloc_meta(p_hwfn, meta_buf, &meta);\r\nif (status != DBG_STATUS_OK)\r\ngoto free_mem;\r\nwhile (bytes_left) {\r\nstruct mcp_trace_format *format_ptr;\r\nu8 format_level, format_module;\r\nu32 params[3] = { 0, 0, 0 };\r\nu32 header, format_idx, i;\r\nif (bytes_left < MFW_TRACE_ENTRY_SIZE) {\r\nstatus = DBG_STATUS_MCP_TRACE_BAD_DATA;\r\ngoto free_mem;\r\n}\r\nheader = qed_read_from_cyclic_buf(trace_buf,\r\n&offset,\r\ntrace->size,\r\nMFW_TRACE_ENTRY_SIZE);\r\nbytes_left -= MFW_TRACE_ENTRY_SIZE;\r\nformat_idx = header & MFW_TRACE_EVENTID_MASK;\r\nif (format_idx > meta.formats_num) {\r\nu8 format_size =\r\n(u8)((header &\r\nMFW_TRACE_PRM_SIZE_MASK) >>\r\nMFW_TRACE_PRM_SIZE_SHIFT);\r\nif (bytes_left < format_size) {\r\nstatus = DBG_STATUS_MCP_TRACE_BAD_DATA;\r\ngoto free_mem;\r\n}\r\noffset = qed_cyclic_add(offset,\r\nformat_size, trace->size);\r\nbytes_left -= format_size;\r\ncontinue;\r\n}\r\nformat_ptr = &meta.formats[format_idx];\r\nfor (i = 0,\r\nparam_mask = MCP_TRACE_FORMAT_P1_SIZE_MASK, param_shift =\r\nMCP_TRACE_FORMAT_P1_SIZE_SHIFT;\r\ni < MCP_TRACE_FORMAT_MAX_PARAMS;\r\ni++, param_mask <<= MCP_TRACE_FORMAT_PARAM_WIDTH,\r\nparam_shift += MCP_TRACE_FORMAT_PARAM_WIDTH) {\r\nu8 param_size =\r\n(u8)((format_ptr->data &\r\nparam_mask) >> param_shift);\r\nif (!param_size)\r\nbreak;\r\nif (param_size == 3)\r\nparam_size = 4;\r\nif (bytes_left < param_size) {\r\nstatus = DBG_STATUS_MCP_TRACE_BAD_DATA;\r\ngoto free_mem;\r\n}\r\nparams[i] = qed_read_from_cyclic_buf(trace_buf,\r\n&offset,\r\ntrace->size,\r\nparam_size);\r\nbytes_left -= param_size;\r\n}\r\nformat_level =\r\n(u8)((format_ptr->data &\r\nMCP_TRACE_FORMAT_LEVEL_MASK) >>\r\nMCP_TRACE_FORMAT_LEVEL_SHIFT);\r\nformat_module =\r\n(u8)((format_ptr->data &\r\nMCP_TRACE_FORMAT_MODULE_MASK) >>\r\nMCP_TRACE_FORMAT_MODULE_SHIFT);\r\nif (format_level >= ARRAY_SIZE(s_mcp_trace_level_str)) {\r\nstatus = DBG_STATUS_MCP_TRACE_BAD_DATA;\r\ngoto free_mem;\r\n}\r\nresults_offset +=\r\nsprintf(qed_get_buf_ptr(results_buf,\r\nresults_offset), "%s %-8s: ",\r\ns_mcp_trace_level_str[format_level],\r\nmeta.modules[format_module]);\r\nresults_offset +=\r\nsprintf(qed_get_buf_ptr(results_buf,\r\nresults_offset),\r\nformat_ptr->format_str, params[0], params[1],\r\nparams[2]);\r\n}\r\nfree_mem:\r\n*parsed_results_bytes = results_offset + 1;\r\nqed_mcp_trace_free_meta(p_hwfn, &meta);\r\nreturn status;\r\n}\r\nstatic enum dbg_status qed_parse_reg_fifo_dump(struct qed_hwfn *p_hwfn,\r\nu32 *dump_buf,\r\nu32 num_dumped_dwords,\r\nchar *results_buf,\r\nu32 *parsed_results_bytes)\r\n{\r\nconst char *section_name, *param_name, *param_str_val;\r\nu32 param_num_val, num_section_params, num_elements;\r\nstruct reg_fifo_element *elements;\r\nu8 i, j, err_val, vf_val;\r\nu32 results_offset = 0;\r\nchar vf_str[4];\r\ndump_buf += qed_read_section_hdr(dump_buf,\r\n&section_name, &num_section_params);\r\nif (strcmp(section_name, "global_params"))\r\nreturn DBG_STATUS_REG_FIFO_BAD_DATA;\r\ndump_buf += qed_print_section_params(dump_buf,\r\nnum_section_params,\r\nresults_buf, &results_offset);\r\ndump_buf += qed_read_section_hdr(dump_buf,\r\n&section_name, &num_section_params);\r\nif (strcmp(section_name, "reg_fifo_data"))\r\nreturn DBG_STATUS_REG_FIFO_BAD_DATA;\r\ndump_buf += qed_read_param(dump_buf,\r\n&param_name, &param_str_val, &param_num_val);\r\nif (strcmp(param_name, "size"))\r\nreturn DBG_STATUS_REG_FIFO_BAD_DATA;\r\nif (param_num_val % REG_FIFO_ELEMENT_DWORDS)\r\nreturn DBG_STATUS_REG_FIFO_BAD_DATA;\r\nnum_elements = param_num_val / REG_FIFO_ELEMENT_DWORDS;\r\nelements = (struct reg_fifo_element *)dump_buf;\r\nfor (i = 0; i < num_elements; i++) {\r\nbool err_printed = false;\r\nvf_val = GET_FIELD(elements[i].data, REG_FIFO_ELEMENT_VF);\r\nif (vf_val == REG_FIFO_ELEMENT_IS_PF_VF_VAL)\r\nsprintf(vf_str, "%s", "N/A");\r\nelse\r\nsprintf(vf_str, "%d", vf_val);\r\nresults_offset +=\r\nsprintf(qed_get_buf_ptr(results_buf,\r\nresults_offset),\r\n"raw: 0x%016llx, address: 0x%07x, access: %-5s, pf: %2d, vf: %s, port: %d, privilege: %-3s, protection: %-12s, master: %-4s, errors: ",\r\nelements[i].data,\r\n(u32)GET_FIELD(elements[i].data,\r\nREG_FIFO_ELEMENT_ADDRESS) *\r\nREG_FIFO_ELEMENT_ADDR_FACTOR,\r\ns_access_strs[GET_FIELD(elements[i].data,\r\nREG_FIFO_ELEMENT_ACCESS)],\r\n(u32)GET_FIELD(elements[i].data,\r\nREG_FIFO_ELEMENT_PF),\r\nvf_str,\r\n(u32)GET_FIELD(elements[i].data,\r\nREG_FIFO_ELEMENT_PORT),\r\ns_privilege_strs[GET_FIELD(elements[i].data,\r\nREG_FIFO_ELEMENT_PRIVILEGE)],\r\ns_protection_strs[GET_FIELD(elements[i].data,\r\nREG_FIFO_ELEMENT_PROTECTION)],\r\ns_master_strs[GET_FIELD(elements[i].data,\r\nREG_FIFO_ELEMENT_MASTER)]);\r\nfor (j = 0,\r\nerr_val = GET_FIELD(elements[i].data,\r\nREG_FIFO_ELEMENT_ERROR);\r\nj < ARRAY_SIZE(s_reg_fifo_error_strs);\r\nj++, err_val >>= 1) {\r\nif (err_val & 0x1) {\r\nif (err_printed)\r\nresults_offset +=\r\nsprintf(qed_get_buf_ptr\r\n(results_buf,\r\nresults_offset), ", ");\r\nresults_offset +=\r\nsprintf(qed_get_buf_ptr\r\n(results_buf, results_offset), "%s",\r\ns_reg_fifo_error_strs[j]);\r\nerr_printed = true;\r\n}\r\n}\r\nresults_offset +=\r\nsprintf(qed_get_buf_ptr(results_buf, results_offset), "\n");\r\n}\r\nresults_offset += sprintf(qed_get_buf_ptr(results_buf,\r\nresults_offset),\r\n"fifo contained %d elements", num_elements);\r\n*parsed_results_bytes = results_offset + 1;\r\nreturn DBG_STATUS_OK;\r\n}\r\nstatic enum dbg_status qed_parse_igu_fifo_element(struct igu_fifo_element\r\n*element, char\r\n*results_buf,\r\nu32 *results_offset,\r\nu32 *parsed_results_bytes)\r\n{\r\nconst struct igu_fifo_addr_data *found_addr = NULL;\r\nu8 source, err_type, i, is_cleanup;\r\nchar parsed_addr_data[32];\r\nchar parsed_wr_data[256];\r\nu32 wr_data, prod_cons;\r\nbool is_wr_cmd, is_pf;\r\nu16 cmd_addr;\r\nu64 dword12;\r\ndword12 = ((u64)element->dword2 << 32) | element->dword1;\r\nis_wr_cmd = GET_FIELD(dword12, IGU_FIFO_ELEMENT_DWORD12_IS_WR_CMD);\r\nis_pf = GET_FIELD(element->dword0, IGU_FIFO_ELEMENT_DWORD0_IS_PF);\r\ncmd_addr = GET_FIELD(element->dword0, IGU_FIFO_ELEMENT_DWORD0_CMD_ADDR);\r\nsource = GET_FIELD(element->dword0, IGU_FIFO_ELEMENT_DWORD0_SOURCE);\r\nerr_type = GET_FIELD(element->dword0, IGU_FIFO_ELEMENT_DWORD0_ERR_TYPE);\r\nif (source >= ARRAY_SIZE(s_igu_fifo_source_strs))\r\nreturn DBG_STATUS_IGU_FIFO_BAD_DATA;\r\nif (err_type >= ARRAY_SIZE(s_igu_fifo_error_strs))\r\nreturn DBG_STATUS_IGU_FIFO_BAD_DATA;\r\nfor (i = 0; i < ARRAY_SIZE(s_igu_fifo_addr_data) && !found_addr; i++) {\r\nconst struct igu_fifo_addr_data *curr_addr =\r\n&s_igu_fifo_addr_data[i];\r\nif (cmd_addr >= curr_addr->start_addr && cmd_addr <=\r\ncurr_addr->end_addr)\r\nfound_addr = curr_addr;\r\n}\r\nif (!found_addr)\r\nreturn DBG_STATUS_IGU_FIFO_BAD_DATA;\r\nswitch (found_addr->type) {\r\ncase IGU_ADDR_TYPE_MSIX_MEM:\r\nsprintf(parsed_addr_data, " vector_num = 0x%x", cmd_addr / 2);\r\nbreak;\r\ncase IGU_ADDR_TYPE_WRITE_INT_ACK:\r\ncase IGU_ADDR_TYPE_WRITE_PROD_UPDATE:\r\nsprintf(parsed_addr_data,\r\n" SB = 0x%x", cmd_addr - found_addr->start_addr);\r\nbreak;\r\ndefault:\r\nparsed_addr_data[0] = '\0';\r\n}\r\nif (!is_wr_cmd) {\r\nparsed_wr_data[0] = '\0';\r\ngoto out;\r\n}\r\nwr_data = GET_FIELD(dword12, IGU_FIFO_ELEMENT_DWORD12_WR_DATA);\r\nprod_cons = GET_FIELD(wr_data, IGU_FIFO_WR_DATA_PROD_CONS);\r\nis_cleanup = GET_FIELD(wr_data, IGU_FIFO_WR_DATA_CMD_TYPE);\r\nif (source == IGU_SRC_ATTN) {\r\nsprintf(parsed_wr_data, "prod: 0x%x, ", prod_cons);\r\n} else {\r\nif (is_cleanup) {\r\nu8 cleanup_val, cleanup_type;\r\ncleanup_val =\r\nGET_FIELD(wr_data,\r\nIGU_FIFO_CLEANUP_WR_DATA_CLEANUP_VAL);\r\ncleanup_type =\r\nGET_FIELD(wr_data,\r\nIGU_FIFO_CLEANUP_WR_DATA_CLEANUP_TYPE);\r\nsprintf(parsed_wr_data,\r\n"cmd_type: cleanup, cleanup_val: %s, cleanup_type : %d, ",\r\ncleanup_val ? "set" : "clear",\r\ncleanup_type);\r\n} else {\r\nu8 update_flag, en_dis_int_for_sb, segment;\r\nu8 timer_mask;\r\nupdate_flag = GET_FIELD(wr_data,\r\nIGU_FIFO_WR_DATA_UPDATE_FLAG);\r\nen_dis_int_for_sb =\r\nGET_FIELD(wr_data,\r\nIGU_FIFO_WR_DATA_EN_DIS_INT_FOR_SB);\r\nsegment = GET_FIELD(wr_data,\r\nIGU_FIFO_WR_DATA_SEGMENT);\r\ntimer_mask = GET_FIELD(wr_data,\r\nIGU_FIFO_WR_DATA_TIMER_MASK);\r\nsprintf(parsed_wr_data,\r\n"cmd_type: prod/cons update, prod/cons: 0x%x, update_flag: %s, en_dis_int_for_sb : %s, segment : %s, timer_mask = %d, ",\r\nprod_cons,\r\nupdate_flag ? "update" : "nop",\r\nen_dis_int_for_sb\r\n? (en_dis_int_for_sb == 1 ? "disable" : "nop")\r\n: "enable",\r\nsegment ? "attn" : "regular",\r\ntimer_mask);\r\n}\r\n}\r\nout:\r\n*results_offset += sprintf(qed_get_buf_ptr(results_buf,\r\n*results_offset),\r\n"raw: 0x%01x%08x%08x, %s: %d, source : %s, type : %s, cmd_addr : 0x%x(%s%s), %serror: %s\n",\r\nelement->dword2, element->dword1,\r\nelement->dword0,\r\nis_pf ? "pf" : "vf",\r\nGET_FIELD(element->dword0,\r\nIGU_FIFO_ELEMENT_DWORD0_FID),\r\ns_igu_fifo_source_strs[source],\r\nis_wr_cmd ? "wr" : "rd",\r\ncmd_addr,\r\n(!is_pf && found_addr->vf_desc)\r\n? found_addr->vf_desc\r\n: found_addr->desc,\r\nparsed_addr_data,\r\nparsed_wr_data,\r\ns_igu_fifo_error_strs[err_type]);\r\nreturn DBG_STATUS_OK;\r\n}\r\nstatic enum dbg_status qed_parse_igu_fifo_dump(struct qed_hwfn *p_hwfn,\r\nu32 *dump_buf,\r\nu32 num_dumped_dwords,\r\nchar *results_buf,\r\nu32 *parsed_results_bytes)\r\n{\r\nconst char *section_name, *param_name, *param_str_val;\r\nu32 param_num_val, num_section_params, num_elements;\r\nstruct igu_fifo_element *elements;\r\nenum dbg_status status;\r\nu32 results_offset = 0;\r\nu8 i;\r\ndump_buf += qed_read_section_hdr(dump_buf,\r\n&section_name, &num_section_params);\r\nif (strcmp(section_name, "global_params"))\r\nreturn DBG_STATUS_IGU_FIFO_BAD_DATA;\r\ndump_buf += qed_print_section_params(dump_buf,\r\nnum_section_params,\r\nresults_buf, &results_offset);\r\ndump_buf += qed_read_section_hdr(dump_buf,\r\n&section_name, &num_section_params);\r\nif (strcmp(section_name, "igu_fifo_data"))\r\nreturn DBG_STATUS_IGU_FIFO_BAD_DATA;\r\ndump_buf += qed_read_param(dump_buf,\r\n&param_name, &param_str_val, &param_num_val);\r\nif (strcmp(param_name, "size"))\r\nreturn DBG_STATUS_IGU_FIFO_BAD_DATA;\r\nif (param_num_val % IGU_FIFO_ELEMENT_DWORDS)\r\nreturn DBG_STATUS_IGU_FIFO_BAD_DATA;\r\nnum_elements = param_num_val / IGU_FIFO_ELEMENT_DWORDS;\r\nelements = (struct igu_fifo_element *)dump_buf;\r\nfor (i = 0; i < num_elements; i++) {\r\nstatus = qed_parse_igu_fifo_element(&elements[i],\r\nresults_buf,\r\n&results_offset,\r\nparsed_results_bytes);\r\nif (status != DBG_STATUS_OK)\r\nreturn status;\r\n}\r\nresults_offset += sprintf(qed_get_buf_ptr(results_buf,\r\nresults_offset),\r\n"fifo contained %d elements", num_elements);\r\n*parsed_results_bytes = results_offset + 1;\r\nreturn DBG_STATUS_OK;\r\n}\r\nstatic enum dbg_status\r\nqed_parse_protection_override_dump(struct qed_hwfn *p_hwfn,\r\nu32 *dump_buf,\r\nu32 num_dumped_dwords,\r\nchar *results_buf,\r\nu32 *parsed_results_bytes)\r\n{\r\nconst char *section_name, *param_name, *param_str_val;\r\nu32 param_num_val, num_section_params, num_elements;\r\nstruct protection_override_element *elements;\r\nu32 results_offset = 0;\r\nu8 i;\r\ndump_buf += qed_read_section_hdr(dump_buf,\r\n&section_name, &num_section_params);\r\nif (strcmp(section_name, "global_params"))\r\nreturn DBG_STATUS_PROTECTION_OVERRIDE_BAD_DATA;\r\ndump_buf += qed_print_section_params(dump_buf,\r\nnum_section_params,\r\nresults_buf, &results_offset);\r\ndump_buf += qed_read_section_hdr(dump_buf,\r\n&section_name, &num_section_params);\r\nif (strcmp(section_name, "protection_override_data"))\r\nreturn DBG_STATUS_PROTECTION_OVERRIDE_BAD_DATA;\r\ndump_buf += qed_read_param(dump_buf,\r\n&param_name, &param_str_val, &param_num_val);\r\nif (strcmp(param_name, "size"))\r\nreturn DBG_STATUS_PROTECTION_OVERRIDE_BAD_DATA;\r\nif (param_num_val % PROTECTION_OVERRIDE_ELEMENT_DWORDS)\r\nreturn DBG_STATUS_PROTECTION_OVERRIDE_BAD_DATA;\r\nnum_elements = param_num_val / PROTECTION_OVERRIDE_ELEMENT_DWORDS;\r\nelements = (struct protection_override_element *)dump_buf;\r\nfor (i = 0; i < num_elements; i++) {\r\nu32 address = GET_FIELD(elements[i].data,\r\nPROTECTION_OVERRIDE_ELEMENT_ADDRESS) *\r\nPROTECTION_OVERRIDE_ELEMENT_ADDR_FACTOR;\r\nresults_offset +=\r\nsprintf(qed_get_buf_ptr(results_buf,\r\nresults_offset),\r\n"window %2d, address: 0x%07x, size: %7d regs, read: %d, write: %d, read protection: %-12s, write protection: %-12s\n",\r\ni, address,\r\n(u32)GET_FIELD(elements[i].data,\r\nPROTECTION_OVERRIDE_ELEMENT_WINDOW_SIZE),\r\n(u32)GET_FIELD(elements[i].data,\r\nPROTECTION_OVERRIDE_ELEMENT_READ),\r\n(u32)GET_FIELD(elements[i].data,\r\nPROTECTION_OVERRIDE_ELEMENT_WRITE),\r\ns_protection_strs[GET_FIELD(elements[i].data,\r\nPROTECTION_OVERRIDE_ELEMENT_READ_PROTECTION)],\r\ns_protection_strs[GET_FIELD(elements[i].data,\r\nPROTECTION_OVERRIDE_ELEMENT_WRITE_PROTECTION)]);\r\n}\r\nresults_offset += sprintf(qed_get_buf_ptr(results_buf,\r\nresults_offset),\r\n"protection override contained %d elements",\r\nnum_elements);\r\n*parsed_results_bytes = results_offset + 1;\r\nreturn DBG_STATUS_OK;\r\n}\r\nstatic enum dbg_status qed_parse_fw_asserts_dump(struct qed_hwfn *p_hwfn,\r\nu32 *dump_buf,\r\nu32 num_dumped_dwords,\r\nchar *results_buf,\r\nu32 *parsed_results_bytes)\r\n{\r\nu32 num_section_params, param_num_val, i, results_offset = 0;\r\nconst char *param_name, *param_str_val, *section_name;\r\nbool last_section_found = false;\r\n*parsed_results_bytes = 0;\r\ndump_buf += qed_read_section_hdr(dump_buf,\r\n&section_name, &num_section_params);\r\nif (strcmp(section_name, "global_params"))\r\nreturn DBG_STATUS_FW_ASSERTS_PARSE_FAILED;\r\ndump_buf += qed_print_section_params(dump_buf,\r\nnum_section_params,\r\nresults_buf, &results_offset);\r\nwhile (!last_section_found) {\r\ndump_buf += qed_read_section_hdr(dump_buf,\r\n&section_name,\r\n&num_section_params);\r\nif (!strcmp(section_name, "fw_asserts")) {\r\nconst char *storm_letter = NULL;\r\nu32 storm_dump_size = 0;\r\nfor (i = 0; i < num_section_params; i++) {\r\ndump_buf += qed_read_param(dump_buf,\r\n&param_name,\r\n&param_str_val,\r\n&param_num_val);\r\nif (!strcmp(param_name, "storm"))\r\nstorm_letter = param_str_val;\r\nelse if (!strcmp(param_name, "size"))\r\nstorm_dump_size = param_num_val;\r\nelse\r\nreturn\r\nDBG_STATUS_FW_ASSERTS_PARSE_FAILED;\r\n}\r\nif (!storm_letter || !storm_dump_size)\r\nreturn DBG_STATUS_FW_ASSERTS_PARSE_FAILED;\r\nresults_offset +=\r\nsprintf(qed_get_buf_ptr(results_buf,\r\nresults_offset),\r\n"\n%sSTORM_ASSERT: size=%d\n",\r\nstorm_letter, storm_dump_size);\r\nfor (i = 0; i < storm_dump_size; i++, dump_buf++)\r\nresults_offset +=\r\nsprintf(qed_get_buf_ptr(results_buf,\r\nresults_offset),\r\n"%08x\n", *dump_buf);\r\n} else if (!strcmp(section_name, "last")) {\r\nlast_section_found = true;\r\n} else {\r\nreturn DBG_STATUS_FW_ASSERTS_PARSE_FAILED;\r\n}\r\n}\r\n*parsed_results_bytes = results_offset + 1;\r\nreturn DBG_STATUS_OK;\r\n}\r\nenum dbg_status qed_dbg_user_set_bin_ptr(const u8 * const bin_ptr)\r\n{\r\nstruct bin_buffer_hdr *buf_array = (struct bin_buffer_hdr *)bin_ptr;\r\nu8 buf_id;\r\nfor (buf_id = 0; buf_id < MAX_BIN_DBG_BUFFER_TYPE; buf_id++) {\r\ns_user_dbg_arrays[buf_id].ptr =\r\n(u32 *)(bin_ptr + buf_array[buf_id].offset);\r\ns_user_dbg_arrays[buf_id].size_in_dwords =\r\nBYTES_TO_DWORDS(buf_array[buf_id].length);\r\n}\r\nreturn DBG_STATUS_OK;\r\n}\r\nconst char *qed_dbg_get_status_str(enum dbg_status status)\r\n{\r\nreturn (status <\r\nMAX_DBG_STATUS) ? s_status_str[status] : "Invalid debug status";\r\n}\r\nenum dbg_status qed_get_idle_chk_results_buf_size(struct qed_hwfn *p_hwfn,\r\nu32 *dump_buf,\r\nu32 num_dumped_dwords,\r\nu32 *results_buf_size)\r\n{\r\nu32 num_errors, num_warnings;\r\nreturn qed_parse_idle_chk_dump(p_hwfn,\r\ndump_buf,\r\nnum_dumped_dwords,\r\nNULL,\r\nresults_buf_size,\r\n&num_errors, &num_warnings);\r\n}\r\nenum dbg_status qed_print_idle_chk_results(struct qed_hwfn *p_hwfn,\r\nu32 *dump_buf,\r\nu32 num_dumped_dwords,\r\nchar *results_buf,\r\nu32 *num_errors, u32 *num_warnings)\r\n{\r\nu32 parsed_buf_size;\r\nreturn qed_parse_idle_chk_dump(p_hwfn,\r\ndump_buf,\r\nnum_dumped_dwords,\r\nresults_buf,\r\n&parsed_buf_size,\r\nnum_errors, num_warnings);\r\n}\r\nvoid qed_dbg_mcp_trace_set_meta_data(u32 *data, u32 size)\r\n{\r\ns_mcp_trace_meta.ptr = data;\r\ns_mcp_trace_meta.size_in_dwords = size;\r\n}\r\nenum dbg_status qed_get_mcp_trace_results_buf_size(struct qed_hwfn *p_hwfn,\r\nu32 *dump_buf,\r\nu32 num_dumped_dwords,\r\nu32 *results_buf_size)\r\n{\r\nreturn qed_parse_mcp_trace_dump(p_hwfn,\r\ndump_buf,\r\nnum_dumped_dwords,\r\nNULL, results_buf_size);\r\n}\r\nenum dbg_status qed_print_mcp_trace_results(struct qed_hwfn *p_hwfn,\r\nu32 *dump_buf,\r\nu32 num_dumped_dwords,\r\nchar *results_buf)\r\n{\r\nu32 parsed_buf_size;\r\nreturn qed_parse_mcp_trace_dump(p_hwfn,\r\ndump_buf,\r\nnum_dumped_dwords,\r\nresults_buf, &parsed_buf_size);\r\n}\r\nenum dbg_status qed_get_reg_fifo_results_buf_size(struct qed_hwfn *p_hwfn,\r\nu32 *dump_buf,\r\nu32 num_dumped_dwords,\r\nu32 *results_buf_size)\r\n{\r\nreturn qed_parse_reg_fifo_dump(p_hwfn,\r\ndump_buf,\r\nnum_dumped_dwords,\r\nNULL, results_buf_size);\r\n}\r\nenum dbg_status qed_print_reg_fifo_results(struct qed_hwfn *p_hwfn,\r\nu32 *dump_buf,\r\nu32 num_dumped_dwords,\r\nchar *results_buf)\r\n{\r\nu32 parsed_buf_size;\r\nreturn qed_parse_reg_fifo_dump(p_hwfn,\r\ndump_buf,\r\nnum_dumped_dwords,\r\nresults_buf, &parsed_buf_size);\r\n}\r\nenum dbg_status qed_get_igu_fifo_results_buf_size(struct qed_hwfn *p_hwfn,\r\nu32 *dump_buf,\r\nu32 num_dumped_dwords,\r\nu32 *results_buf_size)\r\n{\r\nreturn qed_parse_igu_fifo_dump(p_hwfn,\r\ndump_buf,\r\nnum_dumped_dwords,\r\nNULL, results_buf_size);\r\n}\r\nenum dbg_status qed_print_igu_fifo_results(struct qed_hwfn *p_hwfn,\r\nu32 *dump_buf,\r\nu32 num_dumped_dwords,\r\nchar *results_buf)\r\n{\r\nu32 parsed_buf_size;\r\nreturn qed_parse_igu_fifo_dump(p_hwfn,\r\ndump_buf,\r\nnum_dumped_dwords,\r\nresults_buf, &parsed_buf_size);\r\n}\r\nenum dbg_status\r\nqed_get_protection_override_results_buf_size(struct qed_hwfn *p_hwfn,\r\nu32 *dump_buf,\r\nu32 num_dumped_dwords,\r\nu32 *results_buf_size)\r\n{\r\nreturn qed_parse_protection_override_dump(p_hwfn,\r\ndump_buf,\r\nnum_dumped_dwords,\r\nNULL, results_buf_size);\r\n}\r\nenum dbg_status qed_print_protection_override_results(struct qed_hwfn *p_hwfn,\r\nu32 *dump_buf,\r\nu32 num_dumped_dwords,\r\nchar *results_buf)\r\n{\r\nu32 parsed_buf_size;\r\nreturn qed_parse_protection_override_dump(p_hwfn,\r\ndump_buf,\r\nnum_dumped_dwords,\r\nresults_buf,\r\n&parsed_buf_size);\r\n}\r\nenum dbg_status qed_get_fw_asserts_results_buf_size(struct qed_hwfn *p_hwfn,\r\nu32 *dump_buf,\r\nu32 num_dumped_dwords,\r\nu32 *results_buf_size)\r\n{\r\nreturn qed_parse_fw_asserts_dump(p_hwfn,\r\ndump_buf,\r\nnum_dumped_dwords,\r\nNULL, results_buf_size);\r\n}\r\nenum dbg_status qed_print_fw_asserts_results(struct qed_hwfn *p_hwfn,\r\nu32 *dump_buf,\r\nu32 num_dumped_dwords,\r\nchar *results_buf)\r\n{\r\nu32 parsed_buf_size;\r\nreturn qed_parse_fw_asserts_dump(p_hwfn,\r\ndump_buf,\r\nnum_dumped_dwords,\r\nresults_buf, &parsed_buf_size);\r\n}\r\nenum dbg_status qed_dbg_parse_attn(struct qed_hwfn *p_hwfn,\r\nstruct dbg_attn_block_result *results)\r\n{\r\nstruct user_dbg_array *block_attn, *pstrings;\r\nconst u32 *block_attn_name_offsets;\r\nenum dbg_attn_type attn_type;\r\nconst char *block_name;\r\nu8 num_regs, i, j;\r\nnum_regs = GET_FIELD(results->data, DBG_ATTN_BLOCK_RESULT_NUM_REGS);\r\nattn_type = (enum dbg_attn_type)\r\nGET_FIELD(results->data,\r\nDBG_ATTN_BLOCK_RESULT_ATTN_TYPE);\r\nblock_name = s_block_info_arr[results->block_id].name;\r\nif (!s_user_dbg_arrays[BIN_BUF_DBG_ATTN_INDEXES].ptr ||\r\n!s_user_dbg_arrays[BIN_BUF_DBG_ATTN_NAME_OFFSETS].ptr ||\r\n!s_user_dbg_arrays[BIN_BUF_DBG_PARSING_STRINGS].ptr)\r\nreturn DBG_STATUS_DBG_ARRAY_NOT_SET;\r\nblock_attn = &s_user_dbg_arrays[BIN_BUF_DBG_ATTN_NAME_OFFSETS];\r\nblock_attn_name_offsets = &block_attn->ptr[results->names_offset];\r\nfor (i = 0; i < num_regs; i++) {\r\nstruct dbg_attn_reg_result *reg_result;\r\nstruct dbg_attn_bit_mapping *mapping;\r\nu8 num_reg_attn, bit_idx = 0;\r\nreg_result = &results->reg_results[i];\r\nnum_reg_attn = GET_FIELD(reg_result->data,\r\nDBG_ATTN_REG_RESULT_NUM_REG_ATTN);\r\nblock_attn = &s_user_dbg_arrays[BIN_BUF_DBG_ATTN_INDEXES];\r\nmapping = &((struct dbg_attn_bit_mapping *)\r\nblock_attn->ptr)[reg_result->block_attn_offset];\r\npstrings = &s_user_dbg_arrays[BIN_BUF_DBG_PARSING_STRINGS];\r\nfor (j = 0; j < num_reg_attn; j++) {\r\nu16 attn_idx_val = GET_FIELD(mapping[j].data,\r\nDBG_ATTN_BIT_MAPPING_VAL);\r\nconst char *attn_name, *attn_type_str, *masked_str;\r\nu32 name_offset, sts_addr;\r\nif (GET_FIELD(mapping[j].data,\r\nDBG_ATTN_BIT_MAPPING_IS_UNUSED_BIT_CNT)) {\r\nbit_idx += (u8)attn_idx_val;\r\ncontinue;\r\n}\r\nif (!(reg_result->sts_val & BIT(bit_idx))) {\r\nbit_idx++;\r\ncontinue;\r\n}\r\nname_offset = block_attn_name_offsets[attn_idx_val];\r\nattn_name = &((const char *)\r\npstrings->ptr)[name_offset];\r\nattn_type_str = attn_type == ATTN_TYPE_INTERRUPT ?\r\n"Interrupt" : "Parity";\r\nmasked_str = reg_result->mask_val & BIT(bit_idx) ?\r\n" [masked]" : "";\r\nsts_addr = GET_FIELD(reg_result->data,\r\nDBG_ATTN_REG_RESULT_STS_ADDRESS);\r\nDP_NOTICE(p_hwfn,\r\n"%s (%s) : %s [address 0x%08x, bit %d]%s\n",\r\nblock_name, attn_type_str, attn_name,\r\nsts_addr, bit_idx, masked_str);\r\nbit_idx++;\r\n}\r\n}\r\nreturn DBG_STATUS_OK;\r\n}\r\nstatic enum dbg_status\r\nqed_print_idle_chk_results_wrapper(struct qed_hwfn *p_hwfn,\r\nu32 *dump_buf,\r\nu32 num_dumped_dwords,\r\nchar *results_buf)\r\n{\r\nu32 num_errors, num_warnnings;\r\nreturn qed_print_idle_chk_results(p_hwfn, dump_buf, num_dumped_dwords,\r\nresults_buf, &num_errors,\r\n&num_warnnings);\r\n}\r\nstatic void qed_dbg_print_feature(u8 *p_text_buf, u32 text_size)\r\n{\r\nu32 i, precision = 80;\r\nif (!p_text_buf)\r\nreturn;\r\npr_notice("\n%.*s", precision, p_text_buf);\r\nfor (i = precision; i < text_size; i += precision)\r\npr_cont("%.*s", precision, p_text_buf + i);\r\npr_cont("\n");\r\n}\r\nstatic enum dbg_status format_feature(struct qed_hwfn *p_hwfn,\r\nenum qed_dbg_features feature_idx)\r\n{\r\nstruct qed_dbg_feature *feature =\r\n&p_hwfn->cdev->dbg_params.features[feature_idx];\r\nu32 text_size_bytes, null_char_pos, i;\r\nenum dbg_status rc;\r\nchar *text_buf;\r\nif (!qed_features_lookup[feature_idx].results_buf_size)\r\nreturn DBG_STATUS_OK;\r\nrc = qed_features_lookup[feature_idx].\r\nresults_buf_size(p_hwfn, (u32 *)feature->dump_buf,\r\nfeature->dumped_dwords, &text_size_bytes);\r\nif (rc != DBG_STATUS_OK)\r\nreturn rc;\r\nnull_char_pos = text_size_bytes - 1;\r\ntext_size_bytes = (text_size_bytes + 3) & ~0x3;\r\nif (text_size_bytes < QED_RESULTS_BUF_MIN_SIZE) {\r\nDP_NOTICE(p_hwfn->cdev,\r\n"formatted size of feature was too small %d. Aborting\n",\r\ntext_size_bytes);\r\nreturn DBG_STATUS_INVALID_ARGS;\r\n}\r\ntext_buf = vzalloc(text_size_bytes);\r\nif (!text_buf)\r\nreturn DBG_STATUS_VIRT_MEM_ALLOC_FAILED;\r\nrc = qed_features_lookup[feature_idx].\r\nprint_results(p_hwfn, (u32 *)feature->dump_buf,\r\nfeature->dumped_dwords, text_buf);\r\nif (rc != DBG_STATUS_OK) {\r\nvfree(text_buf);\r\nreturn rc;\r\n}\r\nfor (i = null_char_pos; i < text_size_bytes; i++)\r\ntext_buf[i] = '\n';\r\nif (p_hwfn->cdev->dbg_params.print_data)\r\nqed_dbg_print_feature(text_buf, text_size_bytes);\r\nvfree(feature->dump_buf);\r\nfeature->dump_buf = text_buf;\r\nfeature->buf_size = text_size_bytes;\r\nfeature->dumped_dwords = text_size_bytes / 4;\r\nreturn rc;\r\n}\r\nstatic enum dbg_status qed_dbg_dump(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nenum qed_dbg_features feature_idx)\r\n{\r\nstruct qed_dbg_feature *feature =\r\n&p_hwfn->cdev->dbg_params.features[feature_idx];\r\nu32 buf_size_dwords;\r\nenum dbg_status rc;\r\nDP_NOTICE(p_hwfn->cdev, "Collecting a debug feature [\"%s\"]\n",\r\nqed_features_lookup[feature_idx].name);\r\nif (feature->dump_buf) {\r\nvfree(feature->dump_buf);\r\nfeature->dump_buf = NULL;\r\n}\r\nrc = qed_features_lookup[feature_idx].get_size(p_hwfn, p_ptt,\r\n&buf_size_dwords);\r\nif (rc != DBG_STATUS_OK && rc != DBG_STATUS_NVRAM_GET_IMAGE_FAILED)\r\nreturn rc;\r\nfeature->buf_size = buf_size_dwords * sizeof(u32);\r\nfeature->dump_buf = vmalloc(feature->buf_size);\r\nif (!feature->dump_buf)\r\nreturn DBG_STATUS_VIRT_MEM_ALLOC_FAILED;\r\nrc = qed_features_lookup[feature_idx].\r\nperform_dump(p_hwfn, p_ptt, (u32 *)feature->dump_buf,\r\nfeature->buf_size / sizeof(u32),\r\n&feature->dumped_dwords);\r\nif (rc == DBG_STATUS_NVRAM_GET_IMAGE_FAILED)\r\nreturn DBG_STATUS_OK;\r\nif (rc != DBG_STATUS_OK)\r\nreturn rc;\r\nrc = format_feature(p_hwfn, feature_idx);\r\nreturn rc;\r\n}\r\nint qed_dbg_grc(struct qed_dev *cdev, void *buffer, u32 *num_dumped_bytes)\r\n{\r\nreturn qed_dbg_feature(cdev, buffer, DBG_FEATURE_GRC, num_dumped_bytes);\r\n}\r\nint qed_dbg_grc_size(struct qed_dev *cdev)\r\n{\r\nreturn qed_dbg_feature_size(cdev, DBG_FEATURE_GRC);\r\n}\r\nint qed_dbg_idle_chk(struct qed_dev *cdev, void *buffer, u32 *num_dumped_bytes)\r\n{\r\nreturn qed_dbg_feature(cdev, buffer, DBG_FEATURE_IDLE_CHK,\r\nnum_dumped_bytes);\r\n}\r\nint qed_dbg_idle_chk_size(struct qed_dev *cdev)\r\n{\r\nreturn qed_dbg_feature_size(cdev, DBG_FEATURE_IDLE_CHK);\r\n}\r\nint qed_dbg_reg_fifo(struct qed_dev *cdev, void *buffer, u32 *num_dumped_bytes)\r\n{\r\nreturn qed_dbg_feature(cdev, buffer, DBG_FEATURE_REG_FIFO,\r\nnum_dumped_bytes);\r\n}\r\nint qed_dbg_reg_fifo_size(struct qed_dev *cdev)\r\n{\r\nreturn qed_dbg_feature_size(cdev, DBG_FEATURE_REG_FIFO);\r\n}\r\nint qed_dbg_igu_fifo(struct qed_dev *cdev, void *buffer, u32 *num_dumped_bytes)\r\n{\r\nreturn qed_dbg_feature(cdev, buffer, DBG_FEATURE_IGU_FIFO,\r\nnum_dumped_bytes);\r\n}\r\nint qed_dbg_igu_fifo_size(struct qed_dev *cdev)\r\n{\r\nreturn qed_dbg_feature_size(cdev, DBG_FEATURE_IGU_FIFO);\r\n}\r\nint qed_dbg_protection_override(struct qed_dev *cdev, void *buffer,\r\nu32 *num_dumped_bytes)\r\n{\r\nreturn qed_dbg_feature(cdev, buffer, DBG_FEATURE_PROTECTION_OVERRIDE,\r\nnum_dumped_bytes);\r\n}\r\nint qed_dbg_protection_override_size(struct qed_dev *cdev)\r\n{\r\nreturn qed_dbg_feature_size(cdev, DBG_FEATURE_PROTECTION_OVERRIDE);\r\n}\r\nint qed_dbg_fw_asserts(struct qed_dev *cdev, void *buffer,\r\nu32 *num_dumped_bytes)\r\n{\r\nreturn qed_dbg_feature(cdev, buffer, DBG_FEATURE_FW_ASSERTS,\r\nnum_dumped_bytes);\r\n}\r\nint qed_dbg_fw_asserts_size(struct qed_dev *cdev)\r\n{\r\nreturn qed_dbg_feature_size(cdev, DBG_FEATURE_FW_ASSERTS);\r\n}\r\nint qed_dbg_mcp_trace(struct qed_dev *cdev, void *buffer,\r\nu32 *num_dumped_bytes)\r\n{\r\nreturn qed_dbg_feature(cdev, buffer, DBG_FEATURE_MCP_TRACE,\r\nnum_dumped_bytes);\r\n}\r\nint qed_dbg_mcp_trace_size(struct qed_dev *cdev)\r\n{\r\nreturn qed_dbg_feature_size(cdev, DBG_FEATURE_MCP_TRACE);\r\n}\r\nstatic u32 qed_calc_regdump_header(enum debug_print_features feature,\r\nint engine, u32 feature_size, u8 omit_engine)\r\n{\r\nreturn feature_size | (feature << REGDUMP_HEADER_FEATURE_SHIFT) |\r\n(omit_engine << REGDUMP_HEADER_OMIT_ENGINE_SHIFT) |\r\n(engine << REGDUMP_HEADER_ENGINE_SHIFT);\r\n}\r\nint qed_dbg_all_data(struct qed_dev *cdev, void *buffer)\r\n{\r\nu8 cur_engine, omit_engine = 0, org_engine;\r\nu32 offset = 0, feature_size;\r\nint rc;\r\nif (cdev->num_hwfns == 1)\r\nomit_engine = 1;\r\norg_engine = qed_get_debug_engine(cdev);\r\nfor (cur_engine = 0; cur_engine < cdev->num_hwfns; cur_engine++) {\r\nDP_VERBOSE(cdev, QED_MSG_DEBUG,\r\n"obtaining idle_chk and grcdump for current engine\n");\r\nqed_set_debug_engine(cdev, cur_engine);\r\nrc = qed_dbg_idle_chk(cdev, (u8 *)buffer + offset +\r\nREGDUMP_HEADER_SIZE, &feature_size);\r\nif (!rc) {\r\n*(u32 *)((u8 *)buffer + offset) =\r\nqed_calc_regdump_header(IDLE_CHK, cur_engine,\r\nfeature_size, omit_engine);\r\noffset += (feature_size + REGDUMP_HEADER_SIZE);\r\n} else {\r\nDP_ERR(cdev, "qed_dbg_idle_chk failed. rc = %d\n", rc);\r\n}\r\nrc = qed_dbg_idle_chk(cdev, (u8 *)buffer + offset +\r\nREGDUMP_HEADER_SIZE, &feature_size);\r\nif (!rc) {\r\n*(u32 *)((u8 *)buffer + offset) =\r\nqed_calc_regdump_header(IDLE_CHK, cur_engine,\r\nfeature_size, omit_engine);\r\noffset += (feature_size + REGDUMP_HEADER_SIZE);\r\n} else {\r\nDP_ERR(cdev, "qed_dbg_idle_chk failed. rc = %d\n", rc);\r\n}\r\nrc = qed_dbg_reg_fifo(cdev, (u8 *)buffer + offset +\r\nREGDUMP_HEADER_SIZE, &feature_size);\r\nif (!rc) {\r\n*(u32 *)((u8 *)buffer + offset) =\r\nqed_calc_regdump_header(REG_FIFO, cur_engine,\r\nfeature_size, omit_engine);\r\noffset += (feature_size + REGDUMP_HEADER_SIZE);\r\n} else {\r\nDP_ERR(cdev, "qed_dbg_reg_fifo failed. rc = %d\n", rc);\r\n}\r\nrc = qed_dbg_igu_fifo(cdev, (u8 *)buffer + offset +\r\nREGDUMP_HEADER_SIZE, &feature_size);\r\nif (!rc) {\r\n*(u32 *)((u8 *)buffer + offset) =\r\nqed_calc_regdump_header(IGU_FIFO, cur_engine,\r\nfeature_size, omit_engine);\r\noffset += (feature_size + REGDUMP_HEADER_SIZE);\r\n} else {\r\nDP_ERR(cdev, "qed_dbg_igu_fifo failed. rc = %d", rc);\r\n}\r\nrc = qed_dbg_protection_override(cdev, (u8 *)buffer + offset +\r\nREGDUMP_HEADER_SIZE,\r\n&feature_size);\r\nif (!rc) {\r\n*(u32 *)((u8 *)buffer + offset) =\r\nqed_calc_regdump_header(PROTECTION_OVERRIDE,\r\ncur_engine,\r\nfeature_size, omit_engine);\r\noffset += (feature_size + REGDUMP_HEADER_SIZE);\r\n} else {\r\nDP_ERR(cdev,\r\n"qed_dbg_protection_override failed. rc = %d\n",\r\nrc);\r\n}\r\nrc = qed_dbg_fw_asserts(cdev, (u8 *)buffer + offset +\r\nREGDUMP_HEADER_SIZE, &feature_size);\r\nif (!rc) {\r\n*(u32 *)((u8 *)buffer + offset) =\r\nqed_calc_regdump_header(FW_ASSERTS, cur_engine,\r\nfeature_size, omit_engine);\r\noffset += (feature_size + REGDUMP_HEADER_SIZE);\r\n} else {\r\nDP_ERR(cdev, "qed_dbg_fw_asserts failed. rc = %d\n",\r\nrc);\r\n}\r\nrc = qed_dbg_grc(cdev, (u8 *)buffer + offset +\r\nREGDUMP_HEADER_SIZE, &feature_size);\r\nif (!rc) {\r\n*(u32 *)((u8 *)buffer + offset) =\r\nqed_calc_regdump_header(GRC_DUMP, cur_engine,\r\nfeature_size, omit_engine);\r\noffset += (feature_size + REGDUMP_HEADER_SIZE);\r\n} else {\r\nDP_ERR(cdev, "qed_dbg_grc failed. rc = %d", rc);\r\n}\r\n}\r\nrc = qed_dbg_mcp_trace(cdev, (u8 *)buffer + offset +\r\nREGDUMP_HEADER_SIZE, &feature_size);\r\nif (!rc) {\r\n*(u32 *)((u8 *)buffer + offset) =\r\nqed_calc_regdump_header(MCP_TRACE, cur_engine,\r\nfeature_size, omit_engine);\r\noffset += (feature_size + REGDUMP_HEADER_SIZE);\r\n} else {\r\nDP_ERR(cdev, "qed_dbg_mcp_trace failed. rc = %d\n", rc);\r\n}\r\nqed_set_debug_engine(cdev, org_engine);\r\nreturn 0;\r\n}\r\nint qed_dbg_all_data_size(struct qed_dev *cdev)\r\n{\r\nu8 cur_engine, org_engine;\r\nu32 regs_len = 0;\r\norg_engine = qed_get_debug_engine(cdev);\r\nfor (cur_engine = 0; cur_engine < cdev->num_hwfns; cur_engine++) {\r\nDP_VERBOSE(cdev, QED_MSG_DEBUG,\r\n"calculating idle_chk and grcdump register length for current engine\n");\r\nqed_set_debug_engine(cdev, cur_engine);\r\nregs_len += REGDUMP_HEADER_SIZE + qed_dbg_idle_chk_size(cdev) +\r\nREGDUMP_HEADER_SIZE + qed_dbg_idle_chk_size(cdev) +\r\nREGDUMP_HEADER_SIZE + qed_dbg_grc_size(cdev) +\r\nREGDUMP_HEADER_SIZE + qed_dbg_reg_fifo_size(cdev) +\r\nREGDUMP_HEADER_SIZE + qed_dbg_igu_fifo_size(cdev) +\r\nREGDUMP_HEADER_SIZE +\r\nqed_dbg_protection_override_size(cdev) +\r\nREGDUMP_HEADER_SIZE + qed_dbg_fw_asserts_size(cdev);\r\n}\r\nregs_len += REGDUMP_HEADER_SIZE + qed_dbg_mcp_trace_size(cdev);\r\nqed_set_debug_engine(cdev, org_engine);\r\nreturn regs_len;\r\n}\r\nint qed_dbg_feature(struct qed_dev *cdev, void *buffer,\r\nenum qed_dbg_features feature, u32 *num_dumped_bytes)\r\n{\r\nstruct qed_hwfn *p_hwfn =\r\n&cdev->hwfns[cdev->dbg_params.engine_for_debug];\r\nstruct qed_dbg_feature *qed_feature =\r\n&cdev->dbg_params.features[feature];\r\nenum dbg_status dbg_rc;\r\nstruct qed_ptt *p_ptt;\r\nint rc = 0;\r\np_ptt = qed_ptt_acquire(p_hwfn);\r\nif (!p_ptt)\r\nreturn -EINVAL;\r\ndbg_rc = qed_dbg_dump(p_hwfn, p_ptt, feature);\r\nif (dbg_rc != DBG_STATUS_OK) {\r\nDP_VERBOSE(cdev, QED_MSG_DEBUG, "%s\n",\r\nqed_dbg_get_status_str(dbg_rc));\r\n*num_dumped_bytes = 0;\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nDP_VERBOSE(cdev, QED_MSG_DEBUG,\r\n"copying debugfs feature to external buffer\n");\r\nmemcpy(buffer, qed_feature->dump_buf, qed_feature->buf_size);\r\n*num_dumped_bytes = cdev->dbg_params.features[feature].dumped_dwords *\r\n4;\r\nout:\r\nqed_ptt_release(p_hwfn, p_ptt);\r\nreturn rc;\r\n}\r\nint qed_dbg_feature_size(struct qed_dev *cdev, enum qed_dbg_features feature)\r\n{\r\nstruct qed_hwfn *p_hwfn =\r\n&cdev->hwfns[cdev->dbg_params.engine_for_debug];\r\nstruct qed_ptt *p_ptt = qed_ptt_acquire(p_hwfn);\r\nstruct qed_dbg_feature *qed_feature =\r\n&cdev->dbg_params.features[feature];\r\nu32 buf_size_dwords;\r\nenum dbg_status rc;\r\nif (!p_ptt)\r\nreturn -EINVAL;\r\nrc = qed_features_lookup[feature].get_size(p_hwfn, p_ptt,\r\n&buf_size_dwords);\r\nif (rc != DBG_STATUS_OK)\r\nbuf_size_dwords = 0;\r\nqed_ptt_release(p_hwfn, p_ptt);\r\nqed_feature->buf_size = buf_size_dwords * sizeof(u32);\r\nreturn qed_feature->buf_size;\r\n}\r\nu8 qed_get_debug_engine(struct qed_dev *cdev)\r\n{\r\nreturn cdev->dbg_params.engine_for_debug;\r\n}\r\nvoid qed_set_debug_engine(struct qed_dev *cdev, int engine_number)\r\n{\r\nDP_VERBOSE(cdev, QED_MSG_DEBUG, "set debug engine to %d\n",\r\nengine_number);\r\ncdev->dbg_params.engine_for_debug = engine_number;\r\n}\r\nvoid qed_dbg_pf_init(struct qed_dev *cdev)\r\n{\r\nconst u8 *dbg_values;\r\ndbg_values = cdev->firmware->data + *(u32 *)cdev->firmware->data;\r\nqed_dbg_set_bin_ptr((u8 *)dbg_values);\r\nqed_dbg_user_set_bin_ptr((u8 *)dbg_values);\r\n}\r\nvoid qed_dbg_pf_exit(struct qed_dev *cdev)\r\n{\r\nstruct qed_dbg_feature *feature = NULL;\r\nenum qed_dbg_features feature_idx;\r\nfor (feature_idx = 0; feature_idx < DBG_FEATURE_NUM; feature_idx++) {\r\nfeature = &cdev->dbg_params.features[feature_idx];\r\nif (feature->dump_buf) {\r\nvfree(feature->dump_buf);\r\nfeature->dump_buf = NULL;\r\n}\r\n}\r\n}
