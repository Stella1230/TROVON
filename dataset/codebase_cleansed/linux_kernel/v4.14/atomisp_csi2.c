static struct v4l2_mbus_framefmt *__csi2_get_format(struct\r\natomisp_mipi_csi2_device\r\n*csi2,\r\nstruct\r\nv4l2_subdev_pad_config *cfg,\r\nenum\r\nv4l2_subdev_format_whence\r\nwhich, unsigned int pad)\r\n{\r\nif (which == V4L2_SUBDEV_FORMAT_TRY)\r\nreturn v4l2_subdev_get_try_format(&csi2->subdev, cfg, pad);\r\nelse\r\nreturn &csi2->formats[pad];\r\n}\r\nstatic int csi2_enum_mbus_code(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nconst struct atomisp_in_fmt_conv *ic = atomisp_in_fmt_conv;\r\nunsigned int i = 0;\r\nwhile (ic->code) {\r\nif (i == code->index) {\r\ncode->code = ic->code;\r\nreturn 0;\r\n}\r\ni++, ic++;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int csi2_get_format(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct atomisp_mipi_csi2_device *csi2 = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt *format;\r\nformat = __csi2_get_format(csi2, cfg, fmt->which, fmt->pad);\r\nfmt->format = *format;\r\nreturn 0;\r\n}\r\nint atomisp_csi2_set_ffmt(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nunsigned int which, uint16_t pad,\r\nstruct v4l2_mbus_framefmt *ffmt)\r\n{\r\nstruct atomisp_mipi_csi2_device *csi2 = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt *actual_ffmt =\r\n#ifndef ISP2401\r\n__csi2_get_format(csi2, cfg, which, pad);\r\n#else\r\n__csi2_get_format(csi2, cfg, which, pad);\r\n#endif\r\nif (pad == CSI2_PAD_SINK) {\r\nconst struct atomisp_in_fmt_conv *ic;\r\nstruct v4l2_mbus_framefmt tmp_ffmt;\r\nic = atomisp_find_in_fmt_conv(ffmt->code);\r\nif (ic)\r\nactual_ffmt->code = ic->code;\r\nelse\r\nactual_ffmt->code = atomisp_in_fmt_conv[0].code;\r\nactual_ffmt->width = clamp_t(\r\nu32, ffmt->width, ATOM_ISP_MIN_WIDTH,\r\nATOM_ISP_MAX_WIDTH);\r\nactual_ffmt->height = clamp_t(\r\nu32, ffmt->height, ATOM_ISP_MIN_HEIGHT,\r\nATOM_ISP_MAX_HEIGHT);\r\ntmp_ffmt = *ffmt = *actual_ffmt;\r\nreturn atomisp_csi2_set_ffmt(sd, cfg, which, CSI2_PAD_SOURCE,\r\n&tmp_ffmt);\r\n}\r\n*actual_ffmt = *ffmt =\r\n#ifndef ISP2401\r\n*__csi2_get_format(csi2, cfg, which, CSI2_PAD_SINK);\r\n#else\r\n*__csi2_get_format(csi2, cfg, which, CSI2_PAD_SINK);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int csi2_set_format(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nreturn atomisp_csi2_set_ffmt(sd, cfg, fmt->which, fmt->pad,\r\n&fmt->format);\r\n}\r\nstatic int csi2_set_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nreturn 0;\r\n}\r\nstatic int csi2_link_setup(struct media_entity *entity,\r\nconst struct media_pad *local,\r\nconst struct media_pad *remote, u32 flags)\r\n{\r\nstruct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);\r\nstruct atomisp_mipi_csi2_device *csi2 = v4l2_get_subdevdata(sd);\r\nu32 result = local->index | is_media_entity_v4l2_subdev(remote->entity);\r\nswitch (result) {\r\ncase CSI2_PAD_SOURCE | MEDIA_ENT_F_OLD_BASE:\r\nreturn -EINVAL;\r\ncase CSI2_PAD_SOURCE | MEDIA_ENT_F_V4L2_SUBDEV_UNKNOWN:\r\nif (flags & MEDIA_LNK_FL_ENABLED) {\r\nif (csi2->output & ~CSI2_OUTPUT_ISP_SUBDEV)\r\nreturn -EBUSY;\r\ncsi2->output |= CSI2_OUTPUT_ISP_SUBDEV;\r\n} else {\r\ncsi2->output &= ~CSI2_OUTPUT_ISP_SUBDEV;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mipi_csi2_init_entities(struct atomisp_mipi_csi2_device *csi2,\r\nint port)\r\n{\r\nstruct v4l2_subdev *sd = &csi2->subdev;\r\nstruct media_pad *pads = csi2->pads;\r\nstruct media_entity *me = &sd->entity;\r\nint ret;\r\nv4l2_subdev_init(sd, &csi2_ops);\r\nsnprintf(sd->name, sizeof(sd->name), "ATOM ISP CSI2-port%d", port);\r\nv4l2_set_subdevdata(sd, csi2);\r\nsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\npads[CSI2_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;\r\npads[CSI2_PAD_SINK].flags = MEDIA_PAD_FL_SINK;\r\nme->ops = &csi2_media_ops;\r\nme->function = MEDIA_ENT_F_V4L2_SUBDEV_UNKNOWN;\r\nret = media_entity_pads_init(me, CSI2_PADS_NUM, pads);\r\nif (ret < 0)\r\nreturn ret;\r\ncsi2->formats[CSI2_PAD_SINK].code =\r\ncsi2->formats[CSI2_PAD_SOURCE].code =\r\natomisp_in_fmt_conv[0].code;\r\nreturn 0;\r\n}\r\nvoid\r\natomisp_mipi_csi2_unregister_entities(struct atomisp_mipi_csi2_device *csi2)\r\n{\r\nmedia_entity_cleanup(&csi2->subdev.entity);\r\nv4l2_device_unregister_subdev(&csi2->subdev);\r\n}\r\nint atomisp_mipi_csi2_register_entities(struct atomisp_mipi_csi2_device *csi2,\r\nstruct v4l2_device *vdev)\r\n{\r\nint ret;\r\nret = v4l2_device_register_subdev(vdev, &csi2->subdev);\r\nif (ret < 0)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\natomisp_mipi_csi2_unregister_entities(csi2);\r\nreturn ret;\r\n}\r\nstatic int\r\natomisp_csi2_configure_calc(const short int coeffs[2], int mipi_freq, int def)\r\n{\r\nstatic const int accinv = 16;\r\nint r;\r\nif (mipi_freq >> LIMIT_SHIFT <= 0)\r\nreturn def;\r\nr = accinv * coeffs[1] * (500000000 >> LIMIT_SHIFT);\r\nr /= mipi_freq >> LIMIT_SHIFT;\r\nr += accinv * coeffs[0];\r\nreturn r;\r\n}\r\nstatic void atomisp_csi2_configure_isp2401(struct atomisp_sub_device *asd)\r\n{\r\nstatic const short int coeff_clk_termen[] = { 0, 0 };\r\nstatic const short int coeff_clk_settle[] = { 95, -8 };\r\nstatic const short int coeff_dat_termen[] = { 0, 0 };\r\nstatic const short int coeff_dat_settle[] = { 85, -2 };\r\nstatic const int TERMEN_DEFAULT = 0 * 0;\r\nstatic const int SETTLE_DEFAULT = 0x480;\r\nstatic const hrt_address csi2_port_base[] = {\r\n[ATOMISP_CAMERA_PORT_PRIMARY] = CSI2_PORT_A_BASE,\r\n[ATOMISP_CAMERA_PORT_SECONDARY] = CSI2_PORT_B_BASE,\r\n[ATOMISP_CAMERA_PORT_TERTIARY] = CSI2_PORT_C_BASE,\r\n};\r\nstatic const unsigned char csi2_port_lanes[] = {\r\n[ATOMISP_CAMERA_PORT_PRIMARY] = 4,\r\n[ATOMISP_CAMERA_PORT_SECONDARY] = 2,\r\n[ATOMISP_CAMERA_PORT_TERTIARY] = 2,\r\n};\r\nstatic const hrt_address csi2_lane_base[] = {\r\nCSI2_LANE_CL_BASE,\r\nCSI2_LANE_D0_BASE,\r\nCSI2_LANE_D1_BASE,\r\nCSI2_LANE_D2_BASE,\r\nCSI2_LANE_D3_BASE,\r\n};\r\nint clk_termen;\r\nint clk_settle;\r\nint dat_termen;\r\nint dat_settle;\r\nstruct v4l2_control ctrl;\r\nstruct atomisp_device *isp = asd->isp;\r\nstruct camera_mipi_info *mipi_info;\r\nint mipi_freq = 0;\r\nenum atomisp_camera_port port;\r\nint n;\r\nmipi_info = atomisp_to_sensor_mipi_info(\r\nisp->inputs[asd->input_curr].camera);\r\nport = mipi_info->port;\r\nctrl.id = V4L2_CID_LINK_FREQ;\r\nif (v4l2_g_ctrl\r\n(isp->inputs[asd->input_curr].camera->ctrl_handler, &ctrl) == 0)\r\nmipi_freq = ctrl.value;\r\nclk_termen = atomisp_csi2_configure_calc(coeff_clk_termen,\r\nmipi_freq, TERMEN_DEFAULT);\r\nclk_settle = atomisp_csi2_configure_calc(coeff_clk_settle,\r\nmipi_freq, SETTLE_DEFAULT);\r\ndat_termen = atomisp_csi2_configure_calc(coeff_dat_termen,\r\nmipi_freq, TERMEN_DEFAULT);\r\ndat_settle = atomisp_csi2_configure_calc(coeff_dat_settle,\r\nmipi_freq, SETTLE_DEFAULT);\r\nfor (n = 0; n < csi2_port_lanes[port] + 1; n++) {\r\nhrt_address base = csi2_port_base[port] + csi2_lane_base[n];\r\natomisp_store_uint32(base + CSI2_REG_RX_CSI_DLY_CNT_TERMEN,\r\nn == 0 ? clk_termen : dat_termen);\r\natomisp_store_uint32(base + CSI2_REG_RX_CSI_DLY_CNT_SETTLE,\r\nn == 0 ? clk_settle : dat_settle);\r\n}\r\n}\r\nvoid atomisp_csi2_configure(struct atomisp_sub_device *asd)\r\n{\r\nif (IS_HWREVISION(asd->isp, ATOMISP_HW_REVISION_ISP2401))\r\natomisp_csi2_configure_isp2401(asd);\r\n}\r\nvoid atomisp_mipi_csi2_cleanup(struct atomisp_device *isp)\r\n{\r\n}\r\nint atomisp_mipi_csi2_init(struct atomisp_device *isp)\r\n{\r\nstruct atomisp_mipi_csi2_device *csi2_port;\r\nunsigned int i;\r\nint ret;\r\nfor (i = 0; i < ATOMISP_CAMERA_NR_PORTS; i++) {\r\ncsi2_port = &isp->csi2_port[i];\r\ncsi2_port->isp = isp;\r\nret = mipi_csi2_init_entities(csi2_port, i);\r\nif (ret < 0)\r\ngoto fail;\r\n}\r\nreturn 0;\r\nfail:\r\natomisp_mipi_csi2_cleanup(isp);\r\nreturn ret;\r\n}
