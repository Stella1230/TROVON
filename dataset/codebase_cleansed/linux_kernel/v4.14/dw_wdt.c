static inline int dw_wdt_is_enabled(struct dw_wdt *dw_wdt)\r\n{\r\nreturn readl(dw_wdt->regs + WDOG_CONTROL_REG_OFFSET) &\r\nWDOG_CONTROL_REG_WDT_EN_MASK;\r\n}\r\nstatic inline int dw_wdt_top_in_seconds(struct dw_wdt *dw_wdt, unsigned top)\r\n{\r\nreturn (1U << (16 + top)) / dw_wdt->rate;\r\n}\r\nstatic int dw_wdt_get_top(struct dw_wdt *dw_wdt)\r\n{\r\nint top = readl(dw_wdt->regs + WDOG_TIMEOUT_RANGE_REG_OFFSET) & 0xF;\r\nreturn dw_wdt_top_in_seconds(dw_wdt, top);\r\n}\r\nstatic int dw_wdt_ping(struct watchdog_device *wdd)\r\n{\r\nstruct dw_wdt *dw_wdt = to_dw_wdt(wdd);\r\nwritel(WDOG_COUNTER_RESTART_KICK_VALUE, dw_wdt->regs +\r\nWDOG_COUNTER_RESTART_REG_OFFSET);\r\nreturn 0;\r\n}\r\nstatic int dw_wdt_set_timeout(struct watchdog_device *wdd, unsigned int top_s)\r\n{\r\nstruct dw_wdt *dw_wdt = to_dw_wdt(wdd);\r\nint i, top_val = DW_WDT_MAX_TOP;\r\nfor (i = 0; i <= DW_WDT_MAX_TOP; ++i)\r\nif (dw_wdt_top_in_seconds(dw_wdt, i) >= top_s) {\r\ntop_val = i;\r\nbreak;\r\n}\r\nwritel(top_val | top_val << WDOG_TIMEOUT_RANGE_TOPINIT_SHIFT,\r\ndw_wdt->regs + WDOG_TIMEOUT_RANGE_REG_OFFSET);\r\nwdd->timeout = dw_wdt_top_in_seconds(dw_wdt, top_val);\r\nreturn 0;\r\n}\r\nstatic int dw_wdt_start(struct watchdog_device *wdd)\r\n{\r\nstruct dw_wdt *dw_wdt = to_dw_wdt(wdd);\r\ndw_wdt_set_timeout(wdd, wdd->timeout);\r\nset_bit(WDOG_HW_RUNNING, &wdd->status);\r\nwritel(WDOG_CONTROL_REG_WDT_EN_MASK,\r\ndw_wdt->regs + WDOG_CONTROL_REG_OFFSET);\r\nreturn 0;\r\n}\r\nstatic int dw_wdt_restart(struct watchdog_device *wdd,\r\nunsigned long action, void *data)\r\n{\r\nstruct dw_wdt *dw_wdt = to_dw_wdt(wdd);\r\nu32 val;\r\nwritel(0, dw_wdt->regs + WDOG_TIMEOUT_RANGE_REG_OFFSET);\r\nval = readl(dw_wdt->regs + WDOG_CONTROL_REG_OFFSET);\r\nif (val & WDOG_CONTROL_REG_WDT_EN_MASK)\r\nwritel(WDOG_COUNTER_RESTART_KICK_VALUE,\r\ndw_wdt->regs + WDOG_COUNTER_RESTART_REG_OFFSET);\r\nelse\r\nwritel(WDOG_CONTROL_REG_WDT_EN_MASK,\r\ndw_wdt->regs + WDOG_CONTROL_REG_OFFSET);\r\nmdelay(500);\r\nreturn 0;\r\n}\r\nstatic unsigned int dw_wdt_get_timeleft(struct watchdog_device *wdd)\r\n{\r\nstruct dw_wdt *dw_wdt = to_dw_wdt(wdd);\r\nreturn readl(dw_wdt->regs + WDOG_CURRENT_COUNT_REG_OFFSET) /\r\ndw_wdt->rate;\r\n}\r\nstatic int dw_wdt_suspend(struct device *dev)\r\n{\r\nstruct dw_wdt *dw_wdt = dev_get_drvdata(dev);\r\nclk_disable_unprepare(dw_wdt->clk);\r\nreturn 0;\r\n}\r\nstatic int dw_wdt_resume(struct device *dev)\r\n{\r\nstruct dw_wdt *dw_wdt = dev_get_drvdata(dev);\r\nint err = clk_prepare_enable(dw_wdt->clk);\r\nif (err)\r\nreturn err;\r\ndw_wdt_ping(&dw_wdt->wdd);\r\nreturn 0;\r\n}\r\nstatic int dw_wdt_drv_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct watchdog_device *wdd;\r\nstruct dw_wdt *dw_wdt;\r\nstruct resource *mem;\r\nint ret;\r\ndw_wdt = devm_kzalloc(dev, sizeof(*dw_wdt), GFP_KERNEL);\r\nif (!dw_wdt)\r\nreturn -ENOMEM;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndw_wdt->regs = devm_ioremap_resource(dev, mem);\r\nif (IS_ERR(dw_wdt->regs))\r\nreturn PTR_ERR(dw_wdt->regs);\r\ndw_wdt->clk = devm_clk_get(dev, NULL);\r\nif (IS_ERR(dw_wdt->clk))\r\nreturn PTR_ERR(dw_wdt->clk);\r\nret = clk_prepare_enable(dw_wdt->clk);\r\nif (ret)\r\nreturn ret;\r\ndw_wdt->rate = clk_get_rate(dw_wdt->clk);\r\nif (dw_wdt->rate == 0) {\r\nret = -EINVAL;\r\ngoto out_disable_clk;\r\n}\r\ndw_wdt->rst = devm_reset_control_get_optional_shared(&pdev->dev, NULL);\r\nif (IS_ERR(dw_wdt->rst)) {\r\nret = PTR_ERR(dw_wdt->rst);\r\ngoto out_disable_clk;\r\n}\r\nreset_control_deassert(dw_wdt->rst);\r\nwdd = &dw_wdt->wdd;\r\nwdd->info = &dw_wdt_ident;\r\nwdd->ops = &dw_wdt_ops;\r\nwdd->min_timeout = 1;\r\nwdd->max_hw_heartbeat_ms =\r\ndw_wdt_top_in_seconds(dw_wdt, DW_WDT_MAX_TOP) * 1000;\r\nwdd->parent = dev;\r\nwatchdog_set_drvdata(wdd, dw_wdt);\r\nwatchdog_set_nowayout(wdd, nowayout);\r\nwatchdog_init_timeout(wdd, 0, dev);\r\nif (dw_wdt_is_enabled(dw_wdt)) {\r\nwdd->timeout = dw_wdt_get_top(dw_wdt);\r\nset_bit(WDOG_HW_RUNNING, &wdd->status);\r\n} else {\r\nwdd->timeout = DW_WDT_DEFAULT_SECONDS;\r\nwatchdog_init_timeout(wdd, 0, dev);\r\n}\r\nplatform_set_drvdata(pdev, dw_wdt);\r\nwatchdog_set_restart_priority(wdd, 128);\r\nret = watchdog_register_device(wdd);\r\nif (ret)\r\ngoto out_disable_clk;\r\nreturn 0;\r\nout_disable_clk:\r\nclk_disable_unprepare(dw_wdt->clk);\r\nreturn ret;\r\n}\r\nstatic int dw_wdt_drv_remove(struct platform_device *pdev)\r\n{\r\nstruct dw_wdt *dw_wdt = platform_get_drvdata(pdev);\r\nwatchdog_unregister_device(&dw_wdt->wdd);\r\nreset_control_assert(dw_wdt->rst);\r\nclk_disable_unprepare(dw_wdt->clk);\r\nreturn 0;\r\n}
