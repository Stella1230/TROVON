static struct mdev_state *find_mdev_state_by_uuid(uuid_le uuid)\r\n{\r\nstruct mdev_state *mds;\r\nlist_for_each_entry(mds, &mdev_devices_list, next) {\r\nif (uuid_le_cmp(mdev_uuid(mds->mdev), uuid) == 0)\r\nreturn mds;\r\n}\r\nreturn NULL;\r\n}\r\nvoid dump_buffer(char *buf, uint32_t count)\r\n{\r\n#if defined(DEBUG)\r\nint i;\r\npr_info("Buffer:\n");\r\nfor (i = 0; i < count; i++) {\r\npr_info("%2x ", *(buf + i));\r\nif ((i + 1) % 16 == 0)\r\npr_info("\n");\r\n}\r\n#endif\r\n}\r\nstatic void mtty_create_config_space(struct mdev_state *mdev_state)\r\n{\r\nSTORE_LE32((u32 *) &mdev_state->vconfig[0x0], 0x32534348);\r\nSTORE_LE16((u16 *) &mdev_state->vconfig[0x4], 0x0001);\r\nSTORE_LE16((u16 *) &mdev_state->vconfig[0x6], 0x0200);\r\nmdev_state->vconfig[0x8] = 0x10;\r\nmdev_state->vconfig[0x9] = 0x02;\r\nmdev_state->vconfig[0xa] = 0x00;\r\nmdev_state->vconfig[0xb] = 0x07;\r\nSTORE_LE32((u32 *) &mdev_state->vconfig[0x10], 0x000001);\r\nmdev_state->bar_mask[0] = ~(MTTY_IO_BAR_SIZE) + 1;\r\nif (mdev_state->nr_ports == 2) {\r\nSTORE_LE32((u32 *) &mdev_state->vconfig[0x14], 0x000001);\r\nmdev_state->bar_mask[1] = ~(MTTY_IO_BAR_SIZE) + 1;\r\n}\r\nSTORE_LE32((u32 *) &mdev_state->vconfig[0x2c], 0x32534348);\r\nmdev_state->vconfig[0x34] = 0x00;\r\nmdev_state->vconfig[0x3d] = 0x01;\r\nmdev_state->vconfig[0x40] = 0x23;\r\nmdev_state->vconfig[0x43] = 0x80;\r\nmdev_state->vconfig[0x44] = 0x23;\r\nmdev_state->vconfig[0x48] = 0x23;\r\nmdev_state->vconfig[0x4c] = 0x23;\r\nmdev_state->vconfig[0x60] = 0x50;\r\nmdev_state->vconfig[0x61] = 0x43;\r\nmdev_state->vconfig[0x62] = 0x49;\r\nmdev_state->vconfig[0x63] = 0x20;\r\nmdev_state->vconfig[0x64] = 0x53;\r\nmdev_state->vconfig[0x65] = 0x65;\r\nmdev_state->vconfig[0x66] = 0x72;\r\nmdev_state->vconfig[0x67] = 0x69;\r\nmdev_state->vconfig[0x68] = 0x61;\r\nmdev_state->vconfig[0x69] = 0x6c;\r\nmdev_state->vconfig[0x6a] = 0x2f;\r\nmdev_state->vconfig[0x6b] = 0x55;\r\nmdev_state->vconfig[0x6c] = 0x41;\r\nmdev_state->vconfig[0x6d] = 0x52;\r\nmdev_state->vconfig[0x6e] = 0x54;\r\n}\r\nstatic void handle_pci_cfg_write(struct mdev_state *mdev_state, u16 offset,\r\nchar *buf, u32 count)\r\n{\r\nu32 cfg_addr, bar_mask, bar_index = 0;\r\nswitch (offset) {\r\ncase 0x04:\r\ncase 0x06:\r\nbreak;\r\ncase 0x3c:\r\nmdev_state->vconfig[0x3c] = buf[0];\r\nbreak;\r\ncase 0x3d:\r\nbreak;\r\ncase 0x10:\r\ncase 0x14:\r\nif (offset == 0x10)\r\nbar_index = 0;\r\nelse if (offset == 0x14)\r\nbar_index = 1;\r\nif ((mdev_state->nr_ports == 1) && (bar_index == 1)) {\r\nSTORE_LE32(&mdev_state->vconfig[offset], 0);\r\nbreak;\r\n}\r\ncfg_addr = *(u32 *)buf;\r\npr_info("BAR%d addr 0x%x\n", bar_index, cfg_addr);\r\nif (cfg_addr == 0xffffffff) {\r\nbar_mask = mdev_state->bar_mask[bar_index];\r\ncfg_addr = (cfg_addr & bar_mask);\r\n}\r\ncfg_addr |= (mdev_state->vconfig[offset] & 0x3ul);\r\nSTORE_LE32(&mdev_state->vconfig[offset], cfg_addr);\r\nbreak;\r\ncase 0x18:\r\ncase 0x1c:\r\ncase 0x20:\r\nSTORE_LE32(&mdev_state->vconfig[offset], 0);\r\nbreak;\r\ndefault:\r\npr_info("PCI config write @0x%x of %d bytes not handled\n",\r\noffset, count);\r\nbreak;\r\n}\r\n}\r\nstatic void handle_bar_write(unsigned int index, struct mdev_state *mdev_state,\r\nu16 offset, char *buf, u32 count)\r\n{\r\nu8 data = *buf;\r\nswitch (offset) {\r\ncase UART_TX:\r\nif (mdev_state->s[index].dlab) {\r\nmdev_state->s[index].divisor |= data;\r\nbreak;\r\n}\r\nmutex_lock(&mdev_state->rxtx_lock);\r\nif (mdev_state->s[index].rxtx.count <\r\nmdev_state->s[index].max_fifo_size) {\r\nmdev_state->s[index].rxtx.fifo[\r\nmdev_state->s[index].rxtx.head] = data;\r\nmdev_state->s[index].rxtx.count++;\r\nCIRCULAR_BUF_INC_IDX(mdev_state->s[index].rxtx.head);\r\nmdev_state->s[index].overrun = false;\r\nif ((mdev_state->s[index].uart_reg[UART_IER] &\r\nUART_IER_RDI) &&\r\n(mdev_state->s[index].rxtx.count ==\r\nmdev_state->s[index].intr_trigger_level)) {\r\n#if defined(DEBUG_INTR)\r\npr_err("Serial port %d: Fifo level trigger\n",\r\nindex);\r\n#endif\r\nmtty_trigger_interrupt(\r\nmdev_uuid(mdev_state->mdev));\r\n}\r\n} else {\r\n#if defined(DEBUG_INTR)\r\npr_err("Serial port %d: Buffer Overflow\n", index);\r\n#endif\r\nmdev_state->s[index].overrun = true;\r\nif (mdev_state->s[index].uart_reg[UART_IER] &\r\nUART_IER_RLSI)\r\nmtty_trigger_interrupt(\r\nmdev_uuid(mdev_state->mdev));\r\n}\r\nmutex_unlock(&mdev_state->rxtx_lock);\r\nbreak;\r\ncase UART_IER:\r\nif (mdev_state->s[index].dlab)\r\nmdev_state->s[index].divisor |= (u16)data << 8;\r\nelse {\r\nmdev_state->s[index].uart_reg[offset] = data;\r\nmutex_lock(&mdev_state->rxtx_lock);\r\nif ((data & UART_IER_THRI) &&\r\n(mdev_state->s[index].rxtx.head ==\r\nmdev_state->s[index].rxtx.tail)) {\r\n#if defined(DEBUG_INTR)\r\npr_err("Serial port %d: IER_THRI write\n",\r\nindex);\r\n#endif\r\nmtty_trigger_interrupt(\r\nmdev_uuid(mdev_state->mdev));\r\n}\r\nmutex_unlock(&mdev_state->rxtx_lock);\r\n}\r\nbreak;\r\ncase UART_FCR:\r\nmdev_state->s[index].fcr = data;\r\nmutex_lock(&mdev_state->rxtx_lock);\r\nif (data & (UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT)) {\r\nmdev_state->s[index].rxtx.count = 0;\r\nmdev_state->s[index].rxtx.head = 0;\r\nmdev_state->s[index].rxtx.tail = 0;\r\n}\r\nmutex_unlock(&mdev_state->rxtx_lock);\r\nswitch (data & UART_FCR_TRIGGER_MASK) {\r\ncase UART_FCR_TRIGGER_1:\r\nmdev_state->s[index].intr_trigger_level = 1;\r\nbreak;\r\ncase UART_FCR_TRIGGER_4:\r\nmdev_state->s[index].intr_trigger_level = 4;\r\nbreak;\r\ncase UART_FCR_TRIGGER_8:\r\nmdev_state->s[index].intr_trigger_level = 8;\r\nbreak;\r\ncase UART_FCR_TRIGGER_14:\r\nmdev_state->s[index].intr_trigger_level = 14;\r\nbreak;\r\n}\r\nmdev_state->s[index].intr_trigger_level = 1;\r\nif (data & UART_FCR_ENABLE_FIFO)\r\nmdev_state->s[index].max_fifo_size = MAX_FIFO_SIZE;\r\nelse {\r\nmdev_state->s[index].max_fifo_size = 1;\r\nmdev_state->s[index].intr_trigger_level = 1;\r\n}\r\nbreak;\r\ncase UART_LCR:\r\nif (data & UART_LCR_DLAB) {\r\nmdev_state->s[index].dlab = true;\r\nmdev_state->s[index].divisor = 0;\r\n} else\r\nmdev_state->s[index].dlab = false;\r\nmdev_state->s[index].uart_reg[offset] = data;\r\nbreak;\r\ncase UART_MCR:\r\nmdev_state->s[index].uart_reg[offset] = data;\r\nif ((mdev_state->s[index].uart_reg[UART_IER] & UART_IER_MSI) &&\r\n(data & UART_MCR_OUT2)) {\r\n#if defined(DEBUG_INTR)\r\npr_err("Serial port %d: MCR_OUT2 write\n", index);\r\n#endif\r\nmtty_trigger_interrupt(mdev_uuid(mdev_state->mdev));\r\n}\r\nif ((mdev_state->s[index].uart_reg[UART_IER] & UART_IER_MSI) &&\r\n(data & (UART_MCR_RTS | UART_MCR_DTR))) {\r\n#if defined(DEBUG_INTR)\r\npr_err("Serial port %d: MCR RTS/DTR write\n", index);\r\n#endif\r\nmtty_trigger_interrupt(mdev_uuid(mdev_state->mdev));\r\n}\r\nbreak;\r\ncase UART_LSR:\r\ncase UART_MSR:\r\nbreak;\r\ncase UART_SCR:\r\nmdev_state->s[index].uart_reg[offset] = data;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void handle_bar_read(unsigned int index, struct mdev_state *mdev_state,\r\nu16 offset, char *buf, u32 count)\r\n{\r\nswitch (offset) {\r\ncase UART_RX:\r\nif (mdev_state->s[index].dlab) {\r\n*buf = (u8)mdev_state->s[index].divisor;\r\nbreak;\r\n}\r\nmutex_lock(&mdev_state->rxtx_lock);\r\nif (mdev_state->s[index].rxtx.head !=\r\nmdev_state->s[index].rxtx.tail) {\r\n*buf = mdev_state->s[index].rxtx.fifo[\r\nmdev_state->s[index].rxtx.tail];\r\nmdev_state->s[index].rxtx.count--;\r\nCIRCULAR_BUF_INC_IDX(mdev_state->s[index].rxtx.tail);\r\n}\r\nif (mdev_state->s[index].rxtx.head ==\r\nmdev_state->s[index].rxtx.tail) {\r\n#if defined(DEBUG_INTR)\r\npr_err("Serial port %d: Buffer Empty\n", index);\r\n#endif\r\nif (mdev_state->s[index].uart_reg[UART_IER] &\r\nUART_IER_THRI)\r\nmtty_trigger_interrupt(\r\nmdev_uuid(mdev_state->mdev));\r\n}\r\nmutex_unlock(&mdev_state->rxtx_lock);\r\nbreak;\r\ncase UART_IER:\r\nif (mdev_state->s[index].dlab) {\r\n*buf = (u8)(mdev_state->s[index].divisor >> 8);\r\nbreak;\r\n}\r\n*buf = mdev_state->s[index].uart_reg[offset] & 0x0f;\r\nbreak;\r\ncase UART_IIR:\r\n{\r\nu8 ier = mdev_state->s[index].uart_reg[UART_IER];\r\n*buf = 0;\r\nmutex_lock(&mdev_state->rxtx_lock);\r\nif ((ier & UART_IER_RLSI) && mdev_state->s[index].overrun)\r\n*buf |= UART_IIR_RLSI;\r\nif ((ier & UART_IER_RDI) &&\r\n(mdev_state->s[index].rxtx.count ==\r\nmdev_state->s[index].intr_trigger_level))\r\n*buf |= UART_IIR_RDI;\r\nif ((ier & UART_IER_THRI) &&\r\n(mdev_state->s[index].rxtx.head ==\r\nmdev_state->s[index].rxtx.tail))\r\n*buf |= UART_IIR_THRI;\r\nif ((ier & UART_IER_MSI) &&\r\n(mdev_state->s[index].uart_reg[UART_MCR] &\r\n(UART_MCR_RTS | UART_MCR_DTR)))\r\n*buf |= UART_IIR_MSI;\r\nif (*buf == 0)\r\n*buf = UART_IIR_NO_INT;\r\n*buf |= 0xC0;\r\nmutex_unlock(&mdev_state->rxtx_lock);\r\n}\r\nbreak;\r\ncase UART_LCR:\r\ncase UART_MCR:\r\n*buf = mdev_state->s[index].uart_reg[offset];\r\nbreak;\r\ncase UART_LSR:\r\n{\r\nu8 lsr = 0;\r\nmutex_lock(&mdev_state->rxtx_lock);\r\nif (mdev_state->s[index].rxtx.head !=\r\nmdev_state->s[index].rxtx.tail)\r\nlsr |= UART_LSR_DR;\r\nif (mdev_state->s[index].overrun)\r\nlsr |= UART_LSR_OE;\r\nif (mdev_state->s[index].rxtx.head ==\r\nmdev_state->s[index].rxtx.tail)\r\nlsr |= UART_LSR_TEMT | UART_LSR_THRE;\r\nmutex_unlock(&mdev_state->rxtx_lock);\r\n*buf = lsr;\r\nbreak;\r\n}\r\ncase UART_MSR:\r\n*buf = UART_MSR_DSR | UART_MSR_DDSR | UART_MSR_DCD;\r\nmutex_lock(&mdev_state->rxtx_lock);\r\nif (mdev_state->s[index].uart_reg[UART_MCR] &\r\nUART_MCR_AFE) {\r\nif (mdev_state->s[index].rxtx.count <\r\nmdev_state->s[index].max_fifo_size)\r\n*buf |= UART_MSR_CTS | UART_MSR_DCTS;\r\n} else\r\n*buf |= UART_MSR_CTS | UART_MSR_DCTS;\r\nmutex_unlock(&mdev_state->rxtx_lock);\r\nbreak;\r\ncase UART_SCR:\r\n*buf = mdev_state->s[index].uart_reg[offset];\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void mdev_read_base(struct mdev_state *mdev_state)\r\n{\r\nint index, pos;\r\nu32 start_lo, start_hi;\r\nu32 mem_type;\r\npos = PCI_BASE_ADDRESS_0;\r\nfor (index = 0; index <= VFIO_PCI_BAR5_REGION_INDEX; index++) {\r\nif (!mdev_state->region_info[index].size)\r\ncontinue;\r\nstart_lo = (*(u32 *)(mdev_state->vconfig + pos)) &\r\nPCI_BASE_ADDRESS_MEM_MASK;\r\nmem_type = (*(u32 *)(mdev_state->vconfig + pos)) &\r\nPCI_BASE_ADDRESS_MEM_TYPE_MASK;\r\nswitch (mem_type) {\r\ncase PCI_BASE_ADDRESS_MEM_TYPE_64:\r\nstart_hi = (*(u32 *)(mdev_state->vconfig + pos + 4));\r\npos += 4;\r\nbreak;\r\ncase PCI_BASE_ADDRESS_MEM_TYPE_32:\r\ncase PCI_BASE_ADDRESS_MEM_TYPE_1M:\r\ndefault:\r\nstart_hi = 0;\r\nbreak;\r\n}\r\npos += 4;\r\nmdev_state->region_info[index].start = ((u64)start_hi << 32) |\r\nstart_lo;\r\n}\r\n}\r\nstatic ssize_t mdev_access(struct mdev_device *mdev, char *buf, size_t count,\r\nloff_t pos, bool is_write)\r\n{\r\nstruct mdev_state *mdev_state;\r\nunsigned int index;\r\nloff_t offset;\r\nint ret = 0;\r\nif (!mdev || !buf)\r\nreturn -EINVAL;\r\nmdev_state = mdev_get_drvdata(mdev);\r\nif (!mdev_state) {\r\npr_err("%s mdev_state not found\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&mdev_state->ops_lock);\r\nindex = MTTY_VFIO_PCI_OFFSET_TO_INDEX(pos);\r\noffset = pos & MTTY_VFIO_PCI_OFFSET_MASK;\r\nswitch (index) {\r\ncase VFIO_PCI_CONFIG_REGION_INDEX:\r\n#if defined(DEBUG)\r\npr_info("%s: PCI config space %s at offset 0x%llx\n",\r\n__func__, is_write ? "write" : "read", offset);\r\n#endif\r\nif (is_write) {\r\ndump_buffer(buf, count);\r\nhandle_pci_cfg_write(mdev_state, offset, buf, count);\r\n} else {\r\nmemcpy(buf, (mdev_state->vconfig + offset), count);\r\ndump_buffer(buf, count);\r\n}\r\nbreak;\r\ncase VFIO_PCI_BAR0_REGION_INDEX ... VFIO_PCI_BAR5_REGION_INDEX:\r\nif (!mdev_state->region_info[index].start)\r\nmdev_read_base(mdev_state);\r\nif (is_write) {\r\ndump_buffer(buf, count);\r\n#if defined(DEBUG_REGS)\r\npr_info("%s: BAR%d WR @0x%llx %s val:0x%02x dlab:%d\n",\r\n__func__, index, offset, wr_reg[offset],\r\n(u8)*buf, mdev_state->s[index].dlab);\r\n#endif\r\nhandle_bar_write(index, mdev_state, offset, buf, count);\r\n} else {\r\nhandle_bar_read(index, mdev_state, offset, buf, count);\r\ndump_buffer(buf, count);\r\n#if defined(DEBUG_REGS)\r\npr_info("%s: BAR%d RD @0x%llx %s val:0x%02x dlab:%d\n",\r\n__func__, index, offset, rd_reg[offset],\r\n(u8)*buf, mdev_state->s[index].dlab);\r\n#endif\r\n}\r\nbreak;\r\ndefault:\r\nret = -1;\r\ngoto accessfailed;\r\n}\r\nret = count;\r\naccessfailed:\r\nmutex_unlock(&mdev_state->ops_lock);\r\nreturn ret;\r\n}\r\nint mtty_create(struct kobject *kobj, struct mdev_device *mdev)\r\n{\r\nstruct mdev_state *mdev_state;\r\nchar name[MTTY_STRING_LEN];\r\nint nr_ports = 0, i;\r\nif (!mdev)\r\nreturn -EINVAL;\r\nfor (i = 0; i < 2; i++) {\r\nsnprintf(name, MTTY_STRING_LEN, "%s-%d",\r\ndev_driver_string(mdev_parent_dev(mdev)), i + 1);\r\nif (!strcmp(kobj->name, name)) {\r\nnr_ports = i + 1;\r\nbreak;\r\n}\r\n}\r\nif (!nr_ports)\r\nreturn -EINVAL;\r\nmdev_state = kzalloc(sizeof(struct mdev_state), GFP_KERNEL);\r\nif (mdev_state == NULL)\r\nreturn -ENOMEM;\r\nmdev_state->nr_ports = nr_ports;\r\nmdev_state->irq_index = -1;\r\nmdev_state->s[0].max_fifo_size = MAX_FIFO_SIZE;\r\nmdev_state->s[1].max_fifo_size = MAX_FIFO_SIZE;\r\nmutex_init(&mdev_state->rxtx_lock);\r\nmdev_state->vconfig = kzalloc(MTTY_CONFIG_SPACE_SIZE, GFP_KERNEL);\r\nif (mdev_state->vconfig == NULL) {\r\nkfree(mdev_state);\r\nreturn -ENOMEM;\r\n}\r\nmutex_init(&mdev_state->ops_lock);\r\nmdev_state->mdev = mdev;\r\nmdev_set_drvdata(mdev, mdev_state);\r\nmtty_create_config_space(mdev_state);\r\nmutex_lock(&mdev_list_lock);\r\nlist_add(&mdev_state->next, &mdev_devices_list);\r\nmutex_unlock(&mdev_list_lock);\r\nreturn 0;\r\n}\r\nint mtty_remove(struct mdev_device *mdev)\r\n{\r\nstruct mdev_state *mds, *tmp_mds;\r\nstruct mdev_state *mdev_state = mdev_get_drvdata(mdev);\r\nint ret = -EINVAL;\r\nmutex_lock(&mdev_list_lock);\r\nlist_for_each_entry_safe(mds, tmp_mds, &mdev_devices_list, next) {\r\nif (mdev_state == mds) {\r\nlist_del(&mdev_state->next);\r\nmdev_set_drvdata(mdev, NULL);\r\nkfree(mdev_state->vconfig);\r\nkfree(mdev_state);\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&mdev_list_lock);\r\nreturn ret;\r\n}\r\nint mtty_reset(struct mdev_device *mdev)\r\n{\r\nstruct mdev_state *mdev_state;\r\nif (!mdev)\r\nreturn -EINVAL;\r\nmdev_state = mdev_get_drvdata(mdev);\r\nif (!mdev_state)\r\nreturn -EINVAL;\r\npr_info("%s: called\n", __func__);\r\nreturn 0;\r\n}\r\nssize_t mtty_read(struct mdev_device *mdev, char __user *buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nunsigned int done = 0;\r\nint ret;\r\nwhile (count) {\r\nsize_t filled;\r\nif (count >= 4 && !(*ppos % 4)) {\r\nu32 val;\r\nret = mdev_access(mdev, (char *)&val, sizeof(val),\r\n*ppos, false);\r\nif (ret <= 0)\r\ngoto read_err;\r\nif (copy_to_user(buf, &val, sizeof(val)))\r\ngoto read_err;\r\nfilled = 4;\r\n} else if (count >= 2 && !(*ppos % 2)) {\r\nu16 val;\r\nret = mdev_access(mdev, (char *)&val, sizeof(val),\r\n*ppos, false);\r\nif (ret <= 0)\r\ngoto read_err;\r\nif (copy_to_user(buf, &val, sizeof(val)))\r\ngoto read_err;\r\nfilled = 2;\r\n} else {\r\nu8 val;\r\nret = mdev_access(mdev, (char *)&val, sizeof(val),\r\n*ppos, false);\r\nif (ret <= 0)\r\ngoto read_err;\r\nif (copy_to_user(buf, &val, sizeof(val)))\r\ngoto read_err;\r\nfilled = 1;\r\n}\r\ncount -= filled;\r\ndone += filled;\r\n*ppos += filled;\r\nbuf += filled;\r\n}\r\nreturn done;\r\nread_err:\r\nreturn -EFAULT;\r\n}\r\nssize_t mtty_write(struct mdev_device *mdev, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nunsigned int done = 0;\r\nint ret;\r\nwhile (count) {\r\nsize_t filled;\r\nif (count >= 4 && !(*ppos % 4)) {\r\nu32 val;\r\nif (copy_from_user(&val, buf, sizeof(val)))\r\ngoto write_err;\r\nret = mdev_access(mdev, (char *)&val, sizeof(val),\r\n*ppos, true);\r\nif (ret <= 0)\r\ngoto write_err;\r\nfilled = 4;\r\n} else if (count >= 2 && !(*ppos % 2)) {\r\nu16 val;\r\nif (copy_from_user(&val, buf, sizeof(val)))\r\ngoto write_err;\r\nret = mdev_access(mdev, (char *)&val, sizeof(val),\r\n*ppos, true);\r\nif (ret <= 0)\r\ngoto write_err;\r\nfilled = 2;\r\n} else {\r\nu8 val;\r\nif (copy_from_user(&val, buf, sizeof(val)))\r\ngoto write_err;\r\nret = mdev_access(mdev, (char *)&val, sizeof(val),\r\n*ppos, true);\r\nif (ret <= 0)\r\ngoto write_err;\r\nfilled = 1;\r\n}\r\ncount -= filled;\r\ndone += filled;\r\n*ppos += filled;\r\nbuf += filled;\r\n}\r\nreturn done;\r\nwrite_err:\r\nreturn -EFAULT;\r\n}\r\nstatic int mtty_set_irqs(struct mdev_device *mdev, uint32_t flags,\r\nunsigned int index, unsigned int start,\r\nunsigned int count, void *data)\r\n{\r\nint ret = 0;\r\nstruct mdev_state *mdev_state;\r\nif (!mdev)\r\nreturn -EINVAL;\r\nmdev_state = mdev_get_drvdata(mdev);\r\nif (!mdev_state)\r\nreturn -EINVAL;\r\nmutex_lock(&mdev_state->ops_lock);\r\nswitch (index) {\r\ncase VFIO_PCI_INTX_IRQ_INDEX:\r\nswitch (flags & VFIO_IRQ_SET_ACTION_TYPE_MASK) {\r\ncase VFIO_IRQ_SET_ACTION_MASK:\r\ncase VFIO_IRQ_SET_ACTION_UNMASK:\r\nbreak;\r\ncase VFIO_IRQ_SET_ACTION_TRIGGER:\r\n{\r\nif (flags & VFIO_IRQ_SET_DATA_NONE) {\r\npr_info("%s: disable INTx\n", __func__);\r\nif (mdev_state->intx_evtfd)\r\neventfd_ctx_put(mdev_state->intx_evtfd);\r\nbreak;\r\n}\r\nif (flags & VFIO_IRQ_SET_DATA_EVENTFD) {\r\nint fd = *(int *)data;\r\nif (fd > 0) {\r\nstruct eventfd_ctx *evt;\r\nevt = eventfd_ctx_fdget(fd);\r\nif (IS_ERR(evt)) {\r\nret = PTR_ERR(evt);\r\nbreak;\r\n}\r\nmdev_state->intx_evtfd = evt;\r\nmdev_state->irq_fd = fd;\r\nmdev_state->irq_index = index;\r\nbreak;\r\n}\r\n}\r\nbreak;\r\n}\r\n}\r\nbreak;\r\ncase VFIO_PCI_MSI_IRQ_INDEX:\r\nswitch (flags & VFIO_IRQ_SET_ACTION_TYPE_MASK) {\r\ncase VFIO_IRQ_SET_ACTION_MASK:\r\ncase VFIO_IRQ_SET_ACTION_UNMASK:\r\nbreak;\r\ncase VFIO_IRQ_SET_ACTION_TRIGGER:\r\nif (flags & VFIO_IRQ_SET_DATA_NONE) {\r\nif (mdev_state->msi_evtfd)\r\neventfd_ctx_put(mdev_state->msi_evtfd);\r\npr_info("%s: disable MSI\n", __func__);\r\nmdev_state->irq_index = VFIO_PCI_INTX_IRQ_INDEX;\r\nbreak;\r\n}\r\nif (flags & VFIO_IRQ_SET_DATA_EVENTFD) {\r\nint fd = *(int *)data;\r\nstruct eventfd_ctx *evt;\r\nif (fd <= 0)\r\nbreak;\r\nif (mdev_state->msi_evtfd)\r\nbreak;\r\nevt = eventfd_ctx_fdget(fd);\r\nif (IS_ERR(evt)) {\r\nret = PTR_ERR(evt);\r\nbreak;\r\n}\r\nmdev_state->msi_evtfd = evt;\r\nmdev_state->irq_fd = fd;\r\nmdev_state->irq_index = index;\r\n}\r\nbreak;\r\n}\r\nbreak;\r\ncase VFIO_PCI_MSIX_IRQ_INDEX:\r\npr_info("%s: MSIX_IRQ\n", __func__);\r\nbreak;\r\ncase VFIO_PCI_ERR_IRQ_INDEX:\r\npr_info("%s: ERR_IRQ\n", __func__);\r\nbreak;\r\ncase VFIO_PCI_REQ_IRQ_INDEX:\r\npr_info("%s: REQ_IRQ\n", __func__);\r\nbreak;\r\n}\r\nmutex_unlock(&mdev_state->ops_lock);\r\nreturn ret;\r\n}\r\nstatic int mtty_trigger_interrupt(uuid_le uuid)\r\n{\r\nint ret = -1;\r\nstruct mdev_state *mdev_state;\r\nmdev_state = find_mdev_state_by_uuid(uuid);\r\nif (!mdev_state) {\r\npr_info("%s: mdev not found\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif ((mdev_state->irq_index == VFIO_PCI_MSI_IRQ_INDEX) &&\r\n(!mdev_state->msi_evtfd))\r\nreturn -EINVAL;\r\nelse if ((mdev_state->irq_index == VFIO_PCI_INTX_IRQ_INDEX) &&\r\n(!mdev_state->intx_evtfd)) {\r\npr_info("%s: Intr eventfd not found\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (mdev_state->irq_index == VFIO_PCI_MSI_IRQ_INDEX)\r\nret = eventfd_signal(mdev_state->msi_evtfd, 1);\r\nelse\r\nret = eventfd_signal(mdev_state->intx_evtfd, 1);\r\n#if defined(DEBUG_INTR)\r\npr_info("Intx triggered\n");\r\n#endif\r\nif (ret != 1)\r\npr_err("%s: eventfd signal failed (%d)\n", __func__, ret);\r\nreturn ret;\r\n}\r\nint mtty_get_region_info(struct mdev_device *mdev,\r\nstruct vfio_region_info *region_info,\r\nu16 *cap_type_id, void **cap_type)\r\n{\r\nunsigned int size = 0;\r\nstruct mdev_state *mdev_state;\r\nu32 bar_index;\r\nif (!mdev)\r\nreturn -EINVAL;\r\nmdev_state = mdev_get_drvdata(mdev);\r\nif (!mdev_state)\r\nreturn -EINVAL;\r\nbar_index = region_info->index;\r\nif (bar_index >= VFIO_PCI_NUM_REGIONS)\r\nreturn -EINVAL;\r\nmutex_lock(&mdev_state->ops_lock);\r\nswitch (bar_index) {\r\ncase VFIO_PCI_CONFIG_REGION_INDEX:\r\nsize = MTTY_CONFIG_SPACE_SIZE;\r\nbreak;\r\ncase VFIO_PCI_BAR0_REGION_INDEX:\r\nsize = MTTY_IO_BAR_SIZE;\r\nbreak;\r\ncase VFIO_PCI_BAR1_REGION_INDEX:\r\nif (mdev_state->nr_ports == 2)\r\nsize = MTTY_IO_BAR_SIZE;\r\nbreak;\r\ndefault:\r\nsize = 0;\r\nbreak;\r\n}\r\nmdev_state->region_info[bar_index].size = size;\r\nmdev_state->region_info[bar_index].vfio_offset =\r\nMTTY_VFIO_PCI_INDEX_TO_OFFSET(bar_index);\r\nregion_info->size = size;\r\nregion_info->offset = MTTY_VFIO_PCI_INDEX_TO_OFFSET(bar_index);\r\nregion_info->flags = VFIO_REGION_INFO_FLAG_READ |\r\nVFIO_REGION_INFO_FLAG_WRITE;\r\nmutex_unlock(&mdev_state->ops_lock);\r\nreturn 0;\r\n}\r\nint mtty_get_irq_info(struct mdev_device *mdev, struct vfio_irq_info *irq_info)\r\n{\r\nswitch (irq_info->index) {\r\ncase VFIO_PCI_INTX_IRQ_INDEX:\r\ncase VFIO_PCI_MSI_IRQ_INDEX:\r\ncase VFIO_PCI_REQ_IRQ_INDEX:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nirq_info->flags = VFIO_IRQ_INFO_EVENTFD;\r\nirq_info->count = 1;\r\nif (irq_info->index == VFIO_PCI_INTX_IRQ_INDEX)\r\nirq_info->flags |= (VFIO_IRQ_INFO_MASKABLE |\r\nVFIO_IRQ_INFO_AUTOMASKED);\r\nelse\r\nirq_info->flags |= VFIO_IRQ_INFO_NORESIZE;\r\nreturn 0;\r\n}\r\nint mtty_get_device_info(struct mdev_device *mdev,\r\nstruct vfio_device_info *dev_info)\r\n{\r\ndev_info->flags = VFIO_DEVICE_FLAGS_PCI;\r\ndev_info->num_regions = VFIO_PCI_NUM_REGIONS;\r\ndev_info->num_irqs = VFIO_PCI_NUM_IRQS;\r\nreturn 0;\r\n}\r\nstatic long mtty_ioctl(struct mdev_device *mdev, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nint ret = 0;\r\nunsigned long minsz;\r\nstruct mdev_state *mdev_state;\r\nif (!mdev)\r\nreturn -EINVAL;\r\nmdev_state = mdev_get_drvdata(mdev);\r\nif (!mdev_state)\r\nreturn -ENODEV;\r\nswitch (cmd) {\r\ncase VFIO_DEVICE_GET_INFO:\r\n{\r\nstruct vfio_device_info info;\r\nminsz = offsetofend(struct vfio_device_info, num_irqs);\r\nif (copy_from_user(&info, (void __user *)arg, minsz))\r\nreturn -EFAULT;\r\nif (info.argsz < minsz)\r\nreturn -EINVAL;\r\nret = mtty_get_device_info(mdev, &info);\r\nif (ret)\r\nreturn ret;\r\nmemcpy(&mdev_state->dev_info, &info, sizeof(info));\r\nif (copy_to_user((void __user *)arg, &info, minsz))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\ncase VFIO_DEVICE_GET_REGION_INFO:\r\n{\r\nstruct vfio_region_info info;\r\nu16 cap_type_id = 0;\r\nvoid *cap_type = NULL;\r\nminsz = offsetofend(struct vfio_region_info, offset);\r\nif (copy_from_user(&info, (void __user *)arg, minsz))\r\nreturn -EFAULT;\r\nif (info.argsz < minsz)\r\nreturn -EINVAL;\r\nret = mtty_get_region_info(mdev, &info, &cap_type_id,\r\n&cap_type);\r\nif (ret)\r\nreturn ret;\r\nif (copy_to_user((void __user *)arg, &info, minsz))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\ncase VFIO_DEVICE_GET_IRQ_INFO:\r\n{\r\nstruct vfio_irq_info info;\r\nminsz = offsetofend(struct vfio_irq_info, count);\r\nif (copy_from_user(&info, (void __user *)arg, minsz))\r\nreturn -EFAULT;\r\nif ((info.argsz < minsz) ||\r\n(info.index >= mdev_state->dev_info.num_irqs))\r\nreturn -EINVAL;\r\nret = mtty_get_irq_info(mdev, &info);\r\nif (ret)\r\nreturn ret;\r\nif (copy_to_user((void __user *)arg, &info, minsz))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\ncase VFIO_DEVICE_SET_IRQS:\r\n{\r\nstruct vfio_irq_set hdr;\r\nu8 *data = NULL, *ptr = NULL;\r\nsize_t data_size = 0;\r\nminsz = offsetofend(struct vfio_irq_set, count);\r\nif (copy_from_user(&hdr, (void __user *)arg, minsz))\r\nreturn -EFAULT;\r\nret = vfio_set_irqs_validate_and_prepare(&hdr,\r\nmdev_state->dev_info.num_irqs,\r\nVFIO_PCI_NUM_IRQS,\r\n&data_size);\r\nif (ret)\r\nreturn ret;\r\nif (data_size) {\r\nptr = data = memdup_user((void __user *)(arg + minsz),\r\ndata_size);\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\n}\r\nret = mtty_set_irqs(mdev, hdr.flags, hdr.index, hdr.start,\r\nhdr.count, data);\r\nkfree(ptr);\r\nreturn ret;\r\n}\r\ncase VFIO_DEVICE_RESET:\r\nreturn mtty_reset(mdev);\r\n}\r\nreturn -ENOTTY;\r\n}\r\nint mtty_open(struct mdev_device *mdev)\r\n{\r\npr_info("%s\n", __func__);\r\nreturn 0;\r\n}\r\nvoid mtty_close(struct mdev_device *mdev)\r\n{\r\npr_info("%s\n", __func__);\r\n}\r\nstatic ssize_t\r\nsample_mtty_dev_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "This is phy device\n");\r\n}\r\nstatic ssize_t\r\nsample_mdev_dev_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nif (mdev_from_dev(dev))\r\nreturn sprintf(buf, "This is MDEV %s\n", dev_name(dev));\r\nreturn sprintf(buf, "\n");\r\n}\r\nstatic ssize_t\r\nname_show(struct kobject *kobj, struct device *dev, char *buf)\r\n{\r\nchar name[MTTY_STRING_LEN];\r\nint i;\r\nconst char *name_str[2] = {"Single port serial", "Dual port serial"};\r\nfor (i = 0; i < 2; i++) {\r\nsnprintf(name, MTTY_STRING_LEN, "%s-%d",\r\ndev_driver_string(dev), i + 1);\r\nif (!strcmp(kobj->name, name))\r\nreturn sprintf(buf, "%s\n", name_str[i]);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t\r\navailable_instances_show(struct kobject *kobj, struct device *dev, char *buf)\r\n{\r\nchar name[MTTY_STRING_LEN];\r\nint i;\r\nstruct mdev_state *mds;\r\nint ports = 0, used = 0;\r\nfor (i = 0; i < 2; i++) {\r\nsnprintf(name, MTTY_STRING_LEN, "%s-%d",\r\ndev_driver_string(dev), i + 1);\r\nif (!strcmp(kobj->name, name)) {\r\nports = i + 1;\r\nbreak;\r\n}\r\n}\r\nif (!ports)\r\nreturn -EINVAL;\r\nlist_for_each_entry(mds, &mdev_devices_list, next)\r\nused += mds->nr_ports;\r\nreturn sprintf(buf, "%d\n", (MAX_MTTYS - used)/ports);\r\n}\r\nstatic ssize_t device_api_show(struct kobject *kobj, struct device *dev,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "%s\n", VFIO_DEVICE_API_PCI_STRING);\r\n}\r\nstatic void mtty_device_release(struct device *dev)\r\n{\r\ndev_dbg(dev, "mtty: released\n");\r\n}\r\nstatic int __init mtty_dev_init(void)\r\n{\r\nint ret = 0;\r\npr_info("mtty_dev: %s\n", __func__);\r\nmemset(&mtty_dev, 0, sizeof(mtty_dev));\r\nidr_init(&mtty_dev.vd_idr);\r\nret = alloc_chrdev_region(&mtty_dev.vd_devt, 0, MINORMASK, MTTY_NAME);\r\nif (ret < 0) {\r\npr_err("Error: failed to register mtty_dev, err:%d\n", ret);\r\nreturn ret;\r\n}\r\ncdev_init(&mtty_dev.vd_cdev, &vd_fops);\r\ncdev_add(&mtty_dev.vd_cdev, mtty_dev.vd_devt, MINORMASK);\r\npr_info("major_number:%d\n", MAJOR(mtty_dev.vd_devt));\r\nmtty_dev.vd_class = class_create(THIS_MODULE, MTTY_CLASS_NAME);\r\nif (IS_ERR(mtty_dev.vd_class)) {\r\npr_err("Error: failed to register mtty_dev class\n");\r\nret = PTR_ERR(mtty_dev.vd_class);\r\ngoto failed1;\r\n}\r\nmtty_dev.dev.class = mtty_dev.vd_class;\r\nmtty_dev.dev.release = mtty_device_release;\r\ndev_set_name(&mtty_dev.dev, "%s", MTTY_NAME);\r\nret = device_register(&mtty_dev.dev);\r\nif (ret)\r\ngoto failed2;\r\nret = mdev_register_device(&mtty_dev.dev, &mdev_fops);\r\nif (ret)\r\ngoto failed3;\r\nmutex_init(&mdev_list_lock);\r\nINIT_LIST_HEAD(&mdev_devices_list);\r\ngoto all_done;\r\nfailed3:\r\ndevice_unregister(&mtty_dev.dev);\r\nfailed2:\r\nclass_destroy(mtty_dev.vd_class);\r\nfailed1:\r\ncdev_del(&mtty_dev.vd_cdev);\r\nunregister_chrdev_region(mtty_dev.vd_devt, MINORMASK);\r\nall_done:\r\nreturn ret;\r\n}\r\nstatic void __exit mtty_dev_exit(void)\r\n{\r\nmtty_dev.dev.bus = NULL;\r\nmdev_unregister_device(&mtty_dev.dev);\r\ndevice_unregister(&mtty_dev.dev);\r\nidr_destroy(&mtty_dev.vd_idr);\r\ncdev_del(&mtty_dev.vd_cdev);\r\nunregister_chrdev_region(mtty_dev.vd_devt, MINORMASK);\r\nclass_destroy(mtty_dev.vd_class);\r\nmtty_dev.vd_class = NULL;\r\npr_info("mtty_dev: Unloaded!\n");\r\n}
