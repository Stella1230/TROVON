static struct governor_priv *find_governor_by_name(const char *gov_name)\r\n{\r\nstruct governor_priv *priv;\r\nlist_for_each_entry(priv, &governor_list, entry)\r\nif (sysfs_streq(gov_name, priv->gov->name))\r\nreturn priv;\r\nreturn NULL;\r\n}\r\nint watchdog_pretimeout_available_governors_get(char *buf)\r\n{\r\nstruct governor_priv *priv;\r\nint count = 0;\r\nmutex_lock(&governor_lock);\r\nlist_for_each_entry(priv, &governor_list, entry)\r\ncount += sprintf(buf + count, "%s\n", priv->gov->name);\r\nmutex_unlock(&governor_lock);\r\nreturn count;\r\n}\r\nint watchdog_pretimeout_governor_get(struct watchdog_device *wdd, char *buf)\r\n{\r\nint count = 0;\r\nspin_lock_irq(&pretimeout_lock);\r\nif (wdd->gov)\r\ncount = sprintf(buf, "%s\n", wdd->gov->name);\r\nspin_unlock_irq(&pretimeout_lock);\r\nreturn count;\r\n}\r\nint watchdog_pretimeout_governor_set(struct watchdog_device *wdd,\r\nconst char *buf)\r\n{\r\nstruct governor_priv *priv;\r\nmutex_lock(&governor_lock);\r\npriv = find_governor_by_name(buf);\r\nif (!priv) {\r\nmutex_unlock(&governor_lock);\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irq(&pretimeout_lock);\r\nwdd->gov = priv->gov;\r\nspin_unlock_irq(&pretimeout_lock);\r\nmutex_unlock(&governor_lock);\r\nreturn 0;\r\n}\r\nvoid watchdog_notify_pretimeout(struct watchdog_device *wdd)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&pretimeout_lock, flags);\r\nif (!wdd->gov) {\r\nspin_unlock_irqrestore(&pretimeout_lock, flags);\r\nreturn;\r\n}\r\nwdd->gov->pretimeout(wdd);\r\nspin_unlock_irqrestore(&pretimeout_lock, flags);\r\n}\r\nint watchdog_register_governor(struct watchdog_governor *gov)\r\n{\r\nstruct watchdog_pretimeout *p;\r\nstruct governor_priv *priv;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nmutex_lock(&governor_lock);\r\nif (find_governor_by_name(gov->name)) {\r\nmutex_unlock(&governor_lock);\r\nkfree(priv);\r\nreturn -EBUSY;\r\n}\r\npriv->gov = gov;\r\nlist_add(&priv->entry, &governor_list);\r\nif (!strncmp(gov->name, WATCHDOG_PRETIMEOUT_DEFAULT_GOV,\r\nWATCHDOG_GOV_NAME_MAXLEN)) {\r\nspin_lock_irq(&pretimeout_lock);\r\ndefault_gov = gov;\r\nlist_for_each_entry(p, &pretimeout_list, entry)\r\nif (!p->wdd->gov)\r\np->wdd->gov = default_gov;\r\nspin_unlock_irq(&pretimeout_lock);\r\n}\r\nmutex_unlock(&governor_lock);\r\nreturn 0;\r\n}\r\nvoid watchdog_unregister_governor(struct watchdog_governor *gov)\r\n{\r\nstruct watchdog_pretimeout *p;\r\nstruct governor_priv *priv, *t;\r\nmutex_lock(&governor_lock);\r\nlist_for_each_entry_safe(priv, t, &governor_list, entry) {\r\nif (priv->gov == gov) {\r\nlist_del(&priv->entry);\r\nkfree(priv);\r\nbreak;\r\n}\r\n}\r\nspin_lock_irq(&pretimeout_lock);\r\nlist_for_each_entry(p, &pretimeout_list, entry)\r\nif (p->wdd->gov == gov)\r\np->wdd->gov = default_gov;\r\nspin_unlock_irq(&pretimeout_lock);\r\nmutex_unlock(&governor_lock);\r\n}\r\nint watchdog_register_pretimeout(struct watchdog_device *wdd)\r\n{\r\nstruct watchdog_pretimeout *p;\r\nif (!(wdd->info->options & WDIOF_PRETIMEOUT))\r\nreturn 0;\r\np = kzalloc(sizeof(*p), GFP_KERNEL);\r\nif (!p)\r\nreturn -ENOMEM;\r\nspin_lock_irq(&pretimeout_lock);\r\nlist_add(&p->entry, &pretimeout_list);\r\np->wdd = wdd;\r\nwdd->gov = default_gov;\r\nspin_unlock_irq(&pretimeout_lock);\r\nreturn 0;\r\n}\r\nvoid watchdog_unregister_pretimeout(struct watchdog_device *wdd)\r\n{\r\nstruct watchdog_pretimeout *p, *t;\r\nif (!(wdd->info->options & WDIOF_PRETIMEOUT))\r\nreturn;\r\nspin_lock_irq(&pretimeout_lock);\r\nwdd->gov = NULL;\r\nlist_for_each_entry_safe(p, t, &pretimeout_list, entry) {\r\nif (p->wdd == wdd) {\r\nlist_del(&p->entry);\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irq(&pretimeout_lock);\r\nkfree(p);\r\n}
