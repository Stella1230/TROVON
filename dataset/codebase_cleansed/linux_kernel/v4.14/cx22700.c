static int cx22700_writereg (struct cx22700_state* state, u8 reg, u8 data)\r\n{\r\nint ret;\r\nu8 buf [] = { reg, data };\r\nstruct i2c_msg msg = { .addr = state->config->demod_address, .flags = 0, .buf = buf, .len = 2 };\r\ndprintk ("%s\n", __func__);\r\nret = i2c_transfer (state->i2c, &msg, 1);\r\nif (ret != 1)\r\nprintk("%s: writereg error (reg == 0x%02x, val == 0x%02x, ret == %i)\n",\r\n__func__, reg, data, ret);\r\nreturn (ret != 1) ? -1 : 0;\r\n}\r\nstatic int cx22700_readreg (struct cx22700_state* state, u8 reg)\r\n{\r\nint ret;\r\nu8 b0 [] = { reg };\r\nu8 b1 [] = { 0 };\r\nstruct i2c_msg msg [] = { { .addr = state->config->demod_address, .flags = 0, .buf = b0, .len = 1 },\r\n{ .addr = state->config->demod_address, .flags = I2C_M_RD, .buf = b1, .len = 1 } };\r\ndprintk ("%s\n", __func__);\r\nret = i2c_transfer (state->i2c, msg, 2);\r\nif (ret != 2) return -EIO;\r\nreturn b1[0];\r\n}\r\nstatic int cx22700_set_inversion (struct cx22700_state* state, int inversion)\r\n{\r\nu8 val;\r\ndprintk ("%s\n", __func__);\r\nswitch (inversion) {\r\ncase INVERSION_AUTO:\r\nreturn -EOPNOTSUPP;\r\ncase INVERSION_ON:\r\nval = cx22700_readreg (state, 0x09);\r\nreturn cx22700_writereg (state, 0x09, val | 0x01);\r\ncase INVERSION_OFF:\r\nval = cx22700_readreg (state, 0x09);\r\nreturn cx22700_writereg (state, 0x09, val & 0xfe);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int cx22700_set_tps(struct cx22700_state *state,\r\nstruct dtv_frontend_properties *p)\r\n{\r\nstatic const u8 qam_tab [4] = { 0, 1, 0, 2 };\r\nstatic const u8 fec_tab [6] = { 0, 1, 2, 0, 3, 4 };\r\nu8 val;\r\ndprintk ("%s\n", __func__);\r\nif (p->code_rate_HP < FEC_1_2 || p->code_rate_HP > FEC_7_8)\r\nreturn -EINVAL;\r\nif (p->code_rate_LP < FEC_1_2 || p->code_rate_LP > FEC_7_8)\r\nreturn -EINVAL;\r\nif (p->code_rate_HP == FEC_4_5 || p->code_rate_LP == FEC_4_5)\r\nreturn -EINVAL;\r\nif ((int)p->guard_interval < GUARD_INTERVAL_1_32 ||\r\np->guard_interval > GUARD_INTERVAL_1_4)\r\nreturn -EINVAL;\r\nif (p->transmission_mode != TRANSMISSION_MODE_2K &&\r\np->transmission_mode != TRANSMISSION_MODE_8K)\r\nreturn -EINVAL;\r\nif (p->modulation != QPSK &&\r\np->modulation != QAM_16 &&\r\np->modulation != QAM_64)\r\nreturn -EINVAL;\r\nif ((int)p->hierarchy < HIERARCHY_NONE ||\r\np->hierarchy > HIERARCHY_4)\r\nreturn -EINVAL;\r\nif (p->bandwidth_hz > 8000000 || p->bandwidth_hz < 6000000)\r\nreturn -EINVAL;\r\nif (p->bandwidth_hz == 7000000)\r\ncx22700_writereg (state, 0x09, cx22700_readreg (state, 0x09 | 0x10));\r\nelse\r\ncx22700_writereg (state, 0x09, cx22700_readreg (state, 0x09 & ~0x10));\r\nval = qam_tab[p->modulation - QPSK];\r\nval |= p->hierarchy - HIERARCHY_NONE;\r\ncx22700_writereg (state, 0x04, val);\r\nif (p->code_rate_HP - FEC_1_2 >= sizeof(fec_tab) ||\r\np->code_rate_LP - FEC_1_2 >= sizeof(fec_tab))\r\nreturn -EINVAL;\r\nval = fec_tab[p->code_rate_HP - FEC_1_2] << 3;\r\nval |= fec_tab[p->code_rate_LP - FEC_1_2];\r\ncx22700_writereg (state, 0x05, val);\r\nval = (p->guard_interval - GUARD_INTERVAL_1_32) << 2;\r\nval |= p->transmission_mode - TRANSMISSION_MODE_2K;\r\ncx22700_writereg (state, 0x06, val);\r\ncx22700_writereg (state, 0x08, 0x04 | 0x02);\r\ncx22700_writereg (state, 0x08, 0x04);\r\nreturn 0;\r\n}\r\nstatic int cx22700_get_tps(struct cx22700_state *state,\r\nstruct dtv_frontend_properties *p)\r\n{\r\nstatic const enum fe_modulation qam_tab[3] = { QPSK, QAM_16, QAM_64 };\r\nstatic const enum fe_code_rate fec_tab[5] = {\r\nFEC_1_2, FEC_2_3, FEC_3_4, FEC_5_6, FEC_7_8\r\n};\r\nu8 val;\r\ndprintk ("%s\n", __func__);\r\nif (!(cx22700_readreg(state, 0x07) & 0x20))\r\nreturn -EAGAIN;\r\nval = cx22700_readreg (state, 0x01);\r\nif ((val & 0x7) > 4)\r\np->hierarchy = HIERARCHY_AUTO;\r\nelse\r\np->hierarchy = HIERARCHY_NONE + (val & 0x7);\r\nif (((val >> 3) & 0x3) > 2)\r\np->modulation = QAM_AUTO;\r\nelse\r\np->modulation = qam_tab[(val >> 3) & 0x3];\r\nval = cx22700_readreg (state, 0x02);\r\nif (((val >> 3) & 0x07) > 4)\r\np->code_rate_HP = FEC_AUTO;\r\nelse\r\np->code_rate_HP = fec_tab[(val >> 3) & 0x07];\r\nif ((val & 0x07) > 4)\r\np->code_rate_LP = FEC_AUTO;\r\nelse\r\np->code_rate_LP = fec_tab[val & 0x07];\r\nval = cx22700_readreg (state, 0x03);\r\np->guard_interval = GUARD_INTERVAL_1_32 + ((val >> 6) & 0x3);\r\np->transmission_mode = TRANSMISSION_MODE_2K + ((val >> 5) & 0x1);\r\nreturn 0;\r\n}\r\nstatic int cx22700_init (struct dvb_frontend* fe)\r\n{ struct cx22700_state* state = fe->demodulator_priv;\r\nint i;\r\ndprintk("cx22700_init: init chip\n");\r\ncx22700_writereg (state, 0x00, 0x02);\r\ncx22700_writereg (state, 0x00, 0x00);\r\nmsleep(10);\r\nfor (i=0; i<sizeof(init_tab); i+=2)\r\ncx22700_writereg (state, init_tab[i], init_tab[i+1]);\r\ncx22700_writereg (state, 0x00, 0x01);\r\nreturn 0;\r\n}\r\nstatic int cx22700_read_status(struct dvb_frontend *fe, enum fe_status *status)\r\n{\r\nstruct cx22700_state* state = fe->demodulator_priv;\r\nu16 rs_ber = (cx22700_readreg (state, 0x0d) << 9)\r\n| (cx22700_readreg (state, 0x0e) << 1);\r\nu8 sync = cx22700_readreg (state, 0x07);\r\n*status = 0;\r\nif (rs_ber < 0xff00)\r\n*status |= FE_HAS_SIGNAL;\r\nif (sync & 0x20)\r\n*status |= FE_HAS_CARRIER;\r\nif (sync & 0x10)\r\n*status |= FE_HAS_VITERBI;\r\nif (sync & 0x10)\r\n*status |= FE_HAS_SYNC;\r\nif (*status == 0x0f)\r\n*status |= FE_HAS_LOCK;\r\nreturn 0;\r\n}\r\nstatic int cx22700_read_ber(struct dvb_frontend* fe, u32* ber)\r\n{\r\nstruct cx22700_state* state = fe->demodulator_priv;\r\n*ber = cx22700_readreg (state, 0x0c) & 0x7f;\r\ncx22700_writereg (state, 0x0c, 0x00);\r\nreturn 0;\r\n}\r\nstatic int cx22700_read_signal_strength(struct dvb_frontend* fe, u16* signal_strength)\r\n{\r\nstruct cx22700_state* state = fe->demodulator_priv;\r\nu16 rs_ber = (cx22700_readreg (state, 0x0d) << 9)\r\n| (cx22700_readreg (state, 0x0e) << 1);\r\n*signal_strength = ~rs_ber;\r\nreturn 0;\r\n}\r\nstatic int cx22700_read_snr(struct dvb_frontend* fe, u16* snr)\r\n{\r\nstruct cx22700_state* state = fe->demodulator_priv;\r\nu16 rs_ber = (cx22700_readreg (state, 0x0d) << 9)\r\n| (cx22700_readreg (state, 0x0e) << 1);\r\n*snr = ~rs_ber;\r\nreturn 0;\r\n}\r\nstatic int cx22700_read_ucblocks(struct dvb_frontend* fe, u32* ucblocks)\r\n{\r\nstruct cx22700_state* state = fe->demodulator_priv;\r\n*ucblocks = cx22700_readreg (state, 0x0f);\r\ncx22700_writereg (state, 0x0f, 0x00);\r\nreturn 0;\r\n}\r\nstatic int cx22700_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct cx22700_state* state = fe->demodulator_priv;\r\ncx22700_writereg (state, 0x00, 0x02);\r\ncx22700_writereg (state, 0x00, 0x00);\r\nif (fe->ops.tuner_ops.set_params) {\r\nfe->ops.tuner_ops.set_params(fe);\r\nif (fe->ops.i2c_gate_ctrl) fe->ops.i2c_gate_ctrl(fe, 0);\r\n}\r\ncx22700_set_inversion(state, c->inversion);\r\ncx22700_set_tps(state, c);\r\ncx22700_writereg (state, 0x37, 0x01);\r\ncx22700_writereg (state, 0x00, 0x01);\r\nreturn 0;\r\n}\r\nstatic int cx22700_get_frontend(struct dvb_frontend *fe,\r\nstruct dtv_frontend_properties *c)\r\n{\r\nstruct cx22700_state* state = fe->demodulator_priv;\r\nu8 reg09 = cx22700_readreg (state, 0x09);\r\nc->inversion = reg09 & 0x1 ? INVERSION_ON : INVERSION_OFF;\r\nreturn cx22700_get_tps(state, c);\r\n}\r\nstatic int cx22700_i2c_gate_ctrl(struct dvb_frontend* fe, int enable)\r\n{\r\nstruct cx22700_state* state = fe->demodulator_priv;\r\nif (enable) {\r\nreturn cx22700_writereg(state, 0x0a, 0x00);\r\n} else {\r\nreturn cx22700_writereg(state, 0x0a, 0x01);\r\n}\r\n}\r\nstatic int cx22700_get_tune_settings(struct dvb_frontend* fe, struct dvb_frontend_tune_settings* fesettings)\r\n{\r\nfesettings->min_delay_ms = 150;\r\nfesettings->step_size = 166667;\r\nfesettings->max_drift = 166667*2;\r\nreturn 0;\r\n}\r\nstatic void cx22700_release(struct dvb_frontend* fe)\r\n{\r\nstruct cx22700_state* state = fe->demodulator_priv;\r\nkfree(state);\r\n}\r\nstruct dvb_frontend* cx22700_attach(const struct cx22700_config* config,\r\nstruct i2c_adapter* i2c)\r\n{\r\nstruct cx22700_state* state = NULL;\r\nstate = kzalloc(sizeof(struct cx22700_state), GFP_KERNEL);\r\nif (state == NULL) goto error;\r\nstate->config = config;\r\nstate->i2c = i2c;\r\nif (cx22700_readreg(state, 0x07) < 0) goto error;\r\nmemcpy(&state->frontend.ops, &cx22700_ops, sizeof(struct dvb_frontend_ops));\r\nstate->frontend.demodulator_priv = state;\r\nreturn &state->frontend;\r\nerror:\r\nkfree(state);\r\nreturn NULL;\r\n}
