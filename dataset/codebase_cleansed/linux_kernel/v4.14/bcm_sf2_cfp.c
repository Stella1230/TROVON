static inline unsigned int bcm_sf2_get_num_udf_slices(const u8 *layout)\r\n{\r\nunsigned int i, count = 0;\r\nfor (i = 0; i < UDF_NUM_SLICES; i++) {\r\nif (layout[i] != 0)\r\ncount++;\r\n}\r\nreturn count;\r\n}\r\nstatic void bcm_sf2_cfp_udf_set(struct bcm_sf2_priv *priv,\r\nunsigned int slice_num,\r\nconst u8 *layout)\r\n{\r\nu32 offset = CORE_UDF_0_A_0_8_PORT_0 + slice_num * UDF_SLICE_OFFSET;\r\nunsigned int i;\r\nfor (i = 0; i < UDF_NUM_SLICES; i++)\r\ncore_writel(priv, layout[i], offset + i * 4);\r\n}\r\nstatic int bcm_sf2_cfp_op(struct bcm_sf2_priv *priv, unsigned int op)\r\n{\r\nunsigned int timeout = 1000;\r\nu32 reg;\r\nreg = core_readl(priv, CORE_CFP_ACC);\r\nreg &= ~(OP_SEL_MASK | RAM_SEL_MASK);\r\nreg |= OP_STR_DONE | op;\r\ncore_writel(priv, reg, CORE_CFP_ACC);\r\ndo {\r\nreg = core_readl(priv, CORE_CFP_ACC);\r\nif (!(reg & OP_STR_DONE))\r\nbreak;\r\ncpu_relax();\r\n} while (timeout--);\r\nif (!timeout)\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic inline void bcm_sf2_cfp_rule_addr_set(struct bcm_sf2_priv *priv,\r\nunsigned int addr)\r\n{\r\nu32 reg;\r\nWARN_ON(addr >= priv->num_cfp_rules);\r\nreg = core_readl(priv, CORE_CFP_ACC);\r\nreg &= ~(XCESS_ADDR_MASK << XCESS_ADDR_SHIFT);\r\nreg |= addr << XCESS_ADDR_SHIFT;\r\ncore_writel(priv, reg, CORE_CFP_ACC);\r\n}\r\nstatic inline unsigned int bcm_sf2_cfp_rule_size(struct bcm_sf2_priv *priv)\r\n{\r\nreturn priv->num_cfp_rules - 1;\r\n}\r\nstatic int bcm_sf2_cfp_rule_set(struct dsa_switch *ds, int port,\r\nstruct ethtool_rx_flow_spec *fs)\r\n{\r\nstruct bcm_sf2_priv *priv = bcm_sf2_to_priv(ds);\r\nstruct ethtool_tcpip4_spec *v4_spec;\r\nconst struct cfp_udf_layout *layout;\r\nunsigned int slice_num, rule_index;\r\nunsigned int queue_num, port_num;\r\nu8 ip_proto, ip_frag;\r\nu8 num_udf;\r\nu32 reg;\r\nint ret;\r\nif ((fs->flow_type & FLOW_EXT) &&\r\n(fs->m_ext.vlan_etype || fs->m_ext.data[1]))\r\nreturn -EINVAL;\r\nif (fs->location != RX_CLS_LOC_ANY &&\r\ntest_bit(fs->location, priv->cfp.used))\r\nreturn -EBUSY;\r\nif (fs->location != RX_CLS_LOC_ANY &&\r\nfs->location > bcm_sf2_cfp_rule_size(priv))\r\nreturn -EINVAL;\r\nip_frag = be32_to_cpu(fs->m_ext.data[0]);\r\nport_num = fs->ring_cookie / 8;\r\nif (fs->ring_cookie == RX_CLS_FLOW_DISC ||\r\n!(BIT(port_num) & ds->enabled_port_mask) ||\r\nport_num >= priv->hw_params.num_ports)\r\nreturn -EINVAL;\r\nswitch (fs->flow_type & ~FLOW_EXT) {\r\ncase TCP_V4_FLOW:\r\nip_proto = IPPROTO_TCP;\r\nv4_spec = &fs->h_u.tcp_ip4_spec;\r\nbreak;\r\ncase UDP_V4_FLOW:\r\nip_proto = IPPROTO_UDP;\r\nv4_spec = &fs->h_u.udp_ip4_spec;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nslice_num = 1;\r\nlayout = &udf_tcpip4_layout;\r\nnum_udf = bcm_sf2_get_num_udf_slices(layout->slices);\r\nbcm_sf2_cfp_udf_set(priv, slice_num, layout->slices);\r\ncore_writel(priv, BIT(port), CORE_CFP_DATA_PORT(7));\r\ncore_writel(priv, v4_spec->tos << 16 | ip_proto << 8 | ip_frag << 7,\r\nCORE_CFP_DATA_PORT(6));\r\ncore_writel(priv, GENMASK(num_udf - 1, 0) << 24, CORE_CFP_DATA_PORT(5));\r\ncore_writel(priv, 0, CORE_CFP_DATA_PORT(4));\r\ncore_writel(priv, be16_to_cpu(v4_spec->pdst) >> 8,\r\nCORE_CFP_DATA_PORT(3));\r\nreg = (be16_to_cpu(v4_spec->pdst) & 0xff) << 24 |\r\n(u32)be16_to_cpu(v4_spec->psrc) << 8 |\r\n(be32_to_cpu(v4_spec->ip4dst) & 0x0000ff00) >> 8;\r\ncore_writel(priv, reg, CORE_CFP_DATA_PORT(2));\r\nreg = (u32)(be32_to_cpu(v4_spec->ip4dst) & 0xff) << 24 |\r\n(u32)(be32_to_cpu(v4_spec->ip4dst) >> 16) << 8 |\r\n(be32_to_cpu(v4_spec->ip4src) & 0x0000ff00) >> 8;\r\ncore_writel(priv, reg, CORE_CFP_DATA_PORT(1));\r\nreg = (u32)(be32_to_cpu(v4_spec->ip4src) & 0xff) << 24 |\r\n(u32)(be32_to_cpu(v4_spec->ip4src) >> 16) << 8 |\r\nSLICE_NUM(slice_num) | SLICE_VALID;\r\ncore_writel(priv, reg, CORE_CFP_DATA_PORT(0));\r\ncore_writel(priv, 0xff, CORE_CFP_MASK_PORT(7));\r\ncore_writel(priv, layout->mask_value, CORE_CFP_MASK_PORT(6));\r\ncore_writel(priv, GENMASK(num_udf - 1, 0) << 24, CORE_CFP_MASK_PORT(5));\r\ncore_writel(priv, 0, CORE_CFP_MASK_PORT(4));\r\ncore_writel(priv, 0xff, CORE_CFP_MASK_PORT(3));\r\ncore_writel(priv, 0xffffffff, CORE_CFP_MASK_PORT(2));\r\ncore_writel(priv, 0xffffffff, CORE_CFP_MASK_PORT(1));\r\ncore_writel(priv, 0xffffff0f, CORE_CFP_MASK_PORT(0));\r\nif (fs->location == RX_CLS_LOC_ANY)\r\nrule_index = find_first_zero_bit(priv->cfp.used,\r\nbcm_sf2_cfp_rule_size(priv));\r\nelse\r\nrule_index = fs->location;\r\nbcm_sf2_cfp_rule_addr_set(priv, rule_index);\r\nret = bcm_sf2_cfp_op(priv, OP_SEL_WRITE | TCAM_SEL);\r\nif (ret) {\r\npr_err("TCAM entry at addr %d failed\n", rule_index);\r\nreturn ret;\r\n}\r\nqueue_num = fs->ring_cookie % 8;\r\nif (port_num >= 7)\r\nport_num -= 1;\r\nreg = CHANGE_FWRD_MAP_IB_REP_ARL | BIT(port_num + DST_MAP_IB_SHIFT) |\r\nCHANGE_TC | queue_num << NEW_TC_SHIFT;\r\ncore_writel(priv, reg, CORE_ACT_POL_DATA0);\r\ncore_writel(priv, rule_index << CHAIN_ID_SHIFT,\r\nCORE_ACT_POL_DATA1);\r\ncore_writel(priv, 0, CORE_ACT_POL_DATA2);\r\nret = bcm_sf2_cfp_op(priv, OP_SEL_WRITE | ACT_POL_RAM);\r\nif (ret) {\r\npr_err("Policer entry at %d failed\n", rule_index);\r\nreturn ret;\r\n}\r\ncore_writel(priv, POLICER_MODE_DISABLE, CORE_RATE_METER0);\r\nret = bcm_sf2_cfp_op(priv, OP_SEL_WRITE | RATE_METER_RAM);\r\nif (ret) {\r\npr_err("Meter entry at %d failed\n", rule_index);\r\nreturn ret;\r\n}\r\nreg = core_readl(priv, CORE_CFP_CTL_REG);\r\nreg |= BIT(port);\r\ncore_writel(priv, reg, CORE_CFP_CTL_REG);\r\nset_bit(rule_index, priv->cfp.used);\r\nfs->location = rule_index;\r\nreturn 0;\r\n}\r\nstatic int bcm_sf2_cfp_rule_del(struct bcm_sf2_priv *priv, int port,\r\nu32 loc)\r\n{\r\nint ret;\r\nu32 reg;\r\nif (!test_bit(loc, priv->cfp.used) || loc == 0)\r\nreturn -EINVAL;\r\nbcm_sf2_cfp_rule_addr_set(priv, loc);\r\nret = bcm_sf2_cfp_op(priv, OP_SEL_READ | TCAM_SEL);\r\nif (ret)\r\nreturn ret;\r\nreg = core_readl(priv, CORE_CFP_DATA_PORT(0));\r\nreg &= ~SLICE_VALID;\r\ncore_writel(priv, reg, CORE_CFP_DATA_PORT(0));\r\nret = bcm_sf2_cfp_op(priv, OP_SEL_WRITE | TCAM_SEL);\r\nif (ret)\r\nreturn ret;\r\nclear_bit(loc, priv->cfp.used);\r\nreturn 0;\r\n}\r\nstatic void bcm_sf2_invert_masks(struct ethtool_rx_flow_spec *flow)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < sizeof(flow->m_u); i++)\r\nflow->m_u.hdata[i] ^= 0xff;\r\nflow->m_ext.vlan_etype ^= cpu_to_be16(~0);\r\nflow->m_ext.vlan_tci ^= cpu_to_be16(~0);\r\nflow->m_ext.data[0] ^= cpu_to_be32(~0);\r\nflow->m_ext.data[1] ^= cpu_to_be32(~0);\r\n}\r\nstatic int bcm_sf2_cfp_rule_get(struct bcm_sf2_priv *priv, int port,\r\nstruct ethtool_rxnfc *nfc, bool search)\r\n{\r\nstruct ethtool_tcpip4_spec *v4_spec;\r\nunsigned int queue_num;\r\nu16 src_dst_port;\r\nu32 reg, ipv4;\r\nint ret;\r\nif (!search) {\r\nbcm_sf2_cfp_rule_addr_set(priv, nfc->fs.location);\r\nret = bcm_sf2_cfp_op(priv, OP_SEL_READ | ACT_POL_RAM);\r\nif (ret)\r\nreturn ret;\r\nreg = core_readl(priv, CORE_ACT_POL_DATA0);\r\nret = bcm_sf2_cfp_op(priv, OP_SEL_READ | TCAM_SEL);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\nreg = core_readl(priv, CORE_ACT_POL_DATA0);\r\n}\r\nnfc->fs.ring_cookie = fls((reg >> DST_MAP_IB_SHIFT) &\r\nDST_MAP_IB_MASK) - 1;\r\nif (nfc->fs.ring_cookie >= 6)\r\nnfc->fs.ring_cookie++;\r\nnfc->fs.ring_cookie *= 8;\r\nqueue_num = (reg >> NEW_TC_SHIFT) & NEW_TC_MASK;\r\nnfc->fs.ring_cookie += queue_num;\r\nreg = core_readl(priv, CORE_CFP_DATA_PORT(6));\r\nswitch ((reg & IPPROTO_MASK) >> IPPROTO_SHIFT) {\r\ncase IPPROTO_TCP:\r\nnfc->fs.flow_type = TCP_V4_FLOW;\r\nv4_spec = &nfc->fs.h_u.tcp_ip4_spec;\r\nbreak;\r\ncase IPPROTO_UDP:\r\nnfc->fs.flow_type = UDP_V4_FLOW;\r\nv4_spec = &nfc->fs.h_u.udp_ip4_spec;\r\nbreak;\r\ndefault:\r\nif (search)\r\ncore_readl(priv, CORE_CFP_DATA_PORT(7));\r\nreturn -EINVAL;\r\n}\r\nv4_spec->tos = (reg >> 16) & IPPROTO_MASK;\r\nnfc->fs.m_ext.data[0] = cpu_to_be32((reg >> 7) & 1);\r\nreg = core_readl(priv, CORE_CFP_DATA_PORT(3));\r\nsrc_dst_port = reg << 8;\r\nreg = core_readl(priv, CORE_CFP_DATA_PORT(2));\r\nsrc_dst_port |= (reg >> 24);\r\nv4_spec->pdst = cpu_to_be16(src_dst_port);\r\nnfc->fs.m_u.tcp_ip4_spec.pdst = cpu_to_be16(~0);\r\nv4_spec->psrc = cpu_to_be16((u16)(reg >> 8));\r\nnfc->fs.m_u.tcp_ip4_spec.psrc = cpu_to_be16(~0);\r\nipv4 = (reg & 0xff) << 8;\r\nreg = core_readl(priv, CORE_CFP_DATA_PORT(1));\r\nipv4 |= ((reg >> 8) & 0xffff) << 16;\r\nipv4 |= (reg >> 24) & 0xff;\r\nv4_spec->ip4dst = cpu_to_be32(ipv4);\r\nnfc->fs.m_u.tcp_ip4_spec.ip4dst = cpu_to_be32(~0);\r\nipv4 = (reg & 0xff) << 8;\r\nreg = core_readl(priv, CORE_CFP_DATA_PORT(0));\r\nif (!(reg & SLICE_VALID))\r\nreturn -EINVAL;\r\nipv4 |= (reg >> 24) & 0xff;\r\nipv4 |= ((reg >> 8) & 0xffff) << 16;\r\nv4_spec->ip4src = cpu_to_be32(ipv4);\r\nnfc->fs.m_u.tcp_ip4_spec.ip4src = cpu_to_be32(~0);\r\nreg = core_readl(priv, CORE_CFP_DATA_PORT(7));\r\nif (!(reg & 1 << port))\r\nreturn -EINVAL;\r\nbcm_sf2_invert_masks(&nfc->fs);\r\nnfc->data = bcm_sf2_cfp_rule_size(priv);\r\nreturn 0;\r\n}\r\nstatic int bcm_sf2_cfp_rule_get_all(struct bcm_sf2_priv *priv,\r\nint port, struct ethtool_rxnfc *nfc,\r\nu32 *rule_locs)\r\n{\r\nunsigned int index = 1, rules_cnt = 0;\r\nint ret;\r\nu32 reg;\r\nreg = core_readl(priv, CORE_CFP_ACC);\r\nreg &= ~(XCESS_ADDR_MASK << XCESS_ADDR_SHIFT);\r\nreg |= index << XCESS_ADDR_SHIFT;\r\nreg &= ~(OP_SEL_MASK | RAM_SEL_MASK);\r\nreg |= OP_SEL_SEARCH | TCAM_SEL | OP_STR_DONE;\r\ncore_writel(priv, reg, CORE_CFP_ACC);\r\ndo {\r\nreg = core_readl(priv, CORE_CFP_ACC);\r\nindex = reg >> XCESS_ADDR_SHIFT;\r\nindex &= XCESS_ADDR_MASK;\r\nif (reg & SEARCH_STS) {\r\nret = bcm_sf2_cfp_rule_get(priv, port, nfc, true);\r\nif (ret)\r\ncontinue;\r\nrule_locs[rules_cnt] = index;\r\nrules_cnt++;\r\n}\r\nif (!(reg & OP_STR_DONE))\r\nbreak;\r\n} while (index < priv->num_cfp_rules);\r\nnfc->data = bcm_sf2_cfp_rule_size(priv);\r\nnfc->rule_cnt = rules_cnt;\r\nreturn 0;\r\n}\r\nint bcm_sf2_get_rxnfc(struct dsa_switch *ds, int port,\r\nstruct ethtool_rxnfc *nfc, u32 *rule_locs)\r\n{\r\nstruct bcm_sf2_priv *priv = bcm_sf2_to_priv(ds);\r\nint ret = 0;\r\nmutex_lock(&priv->cfp.lock);\r\nswitch (nfc->cmd) {\r\ncase ETHTOOL_GRXCLSRLCNT:\r\nnfc->rule_cnt = bitmap_weight(priv->cfp.used,\r\npriv->num_cfp_rules) - 1;\r\nnfc->data |= RX_CLS_LOC_SPECIAL;\r\nbreak;\r\ncase ETHTOOL_GRXCLSRULE:\r\nret = bcm_sf2_cfp_rule_get(priv, port, nfc, false);\r\nbreak;\r\ncase ETHTOOL_GRXCLSRLALL:\r\nret = bcm_sf2_cfp_rule_get_all(priv, port, nfc, rule_locs);\r\nbreak;\r\ndefault:\r\nret = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nmutex_unlock(&priv->cfp.lock);\r\nreturn ret;\r\n}\r\nint bcm_sf2_set_rxnfc(struct dsa_switch *ds, int port,\r\nstruct ethtool_rxnfc *nfc)\r\n{\r\nstruct bcm_sf2_priv *priv = bcm_sf2_to_priv(ds);\r\nint ret = 0;\r\nmutex_lock(&priv->cfp.lock);\r\nswitch (nfc->cmd) {\r\ncase ETHTOOL_SRXCLSRLINS:\r\nret = bcm_sf2_cfp_rule_set(ds, port, &nfc->fs);\r\nbreak;\r\ncase ETHTOOL_SRXCLSRLDEL:\r\nret = bcm_sf2_cfp_rule_del(priv, port, nfc->fs.location);\r\nbreak;\r\ndefault:\r\nret = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nmutex_unlock(&priv->cfp.lock);\r\nreturn ret;\r\n}\r\nint bcm_sf2_cfp_rst(struct bcm_sf2_priv *priv)\r\n{\r\nunsigned int timeout = 1000;\r\nu32 reg;\r\nreg = core_readl(priv, CORE_CFP_ACC);\r\nreg |= TCAM_RESET;\r\ncore_writel(priv, reg, CORE_CFP_ACC);\r\ndo {\r\nreg = core_readl(priv, CORE_CFP_ACC);\r\nif (!(reg & TCAM_RESET))\r\nbreak;\r\ncpu_relax();\r\n} while (timeout--);\r\nif (!timeout)\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}
