static inline struct gr2d *to_gr2d(struct tegra_drm_client *client)\r\n{\r\nreturn container_of(client, struct gr2d, client);\r\n}\r\nstatic int gr2d_init(struct host1x_client *client)\r\n{\r\nstruct tegra_drm_client *drm = host1x_to_drm_client(client);\r\nstruct drm_device *dev = dev_get_drvdata(client->parent);\r\nunsigned long flags = HOST1X_SYNCPT_HAS_BASE;\r\nstruct gr2d *gr2d = to_gr2d(drm);\r\ngr2d->channel = host1x_channel_request(client->dev);\r\nif (!gr2d->channel)\r\nreturn -ENOMEM;\r\nclient->syncpts[0] = host1x_syncpt_request(client->dev, flags);\r\nif (!client->syncpts[0]) {\r\nhost1x_channel_put(gr2d->channel);\r\nreturn -ENOMEM;\r\n}\r\nreturn tegra_drm_register_client(dev->dev_private, drm);\r\n}\r\nstatic int gr2d_exit(struct host1x_client *client)\r\n{\r\nstruct tegra_drm_client *drm = host1x_to_drm_client(client);\r\nstruct drm_device *dev = dev_get_drvdata(client->parent);\r\nstruct gr2d *gr2d = to_gr2d(drm);\r\nint err;\r\nerr = tegra_drm_unregister_client(dev->dev_private, drm);\r\nif (err < 0)\r\nreturn err;\r\nhost1x_syncpt_free(client->syncpts[0]);\r\nhost1x_channel_put(gr2d->channel);\r\nreturn 0;\r\n}\r\nstatic int gr2d_open_channel(struct tegra_drm_client *client,\r\nstruct tegra_drm_context *context)\r\n{\r\nstruct gr2d *gr2d = to_gr2d(client);\r\ncontext->channel = host1x_channel_get(gr2d->channel);\r\nif (!context->channel)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void gr2d_close_channel(struct tegra_drm_context *context)\r\n{\r\nhost1x_channel_put(context->channel);\r\n}\r\nstatic int gr2d_is_addr_reg(struct device *dev, u32 class, u32 offset)\r\n{\r\nstruct gr2d *gr2d = dev_get_drvdata(dev);\r\nswitch (class) {\r\ncase HOST1X_CLASS_HOST1X:\r\nif (offset == 0x2b)\r\nreturn 1;\r\nbreak;\r\ncase HOST1X_CLASS_GR2D:\r\ncase HOST1X_CLASS_GR2D_SB:\r\nif (offset >= GR2D_NUM_REGS)\r\nbreak;\r\nif (test_bit(offset, gr2d->addr_regs))\r\nreturn 1;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int gr2d_is_valid_class(u32 class)\r\n{\r\nreturn (class == HOST1X_CLASS_GR2D ||\r\nclass == HOST1X_CLASS_GR2D_SB);\r\n}\r\nstatic int gr2d_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct host1x_syncpt **syncpts;\r\nstruct gr2d *gr2d;\r\nunsigned int i;\r\nint err;\r\ngr2d = devm_kzalloc(dev, sizeof(*gr2d), GFP_KERNEL);\r\nif (!gr2d)\r\nreturn -ENOMEM;\r\nsyncpts = devm_kzalloc(dev, sizeof(*syncpts), GFP_KERNEL);\r\nif (!syncpts)\r\nreturn -ENOMEM;\r\ngr2d->clk = devm_clk_get(dev, NULL);\r\nif (IS_ERR(gr2d->clk)) {\r\ndev_err(dev, "cannot get clock\n");\r\nreturn PTR_ERR(gr2d->clk);\r\n}\r\nerr = clk_prepare_enable(gr2d->clk);\r\nif (err) {\r\ndev_err(dev, "cannot turn on clock\n");\r\nreturn err;\r\n}\r\nINIT_LIST_HEAD(&gr2d->client.base.list);\r\ngr2d->client.base.ops = &gr2d_client_ops;\r\ngr2d->client.base.dev = dev;\r\ngr2d->client.base.class = HOST1X_CLASS_GR2D;\r\ngr2d->client.base.syncpts = syncpts;\r\ngr2d->client.base.num_syncpts = 1;\r\nINIT_LIST_HEAD(&gr2d->client.list);\r\ngr2d->client.ops = &gr2d_ops;\r\nerr = host1x_client_register(&gr2d->client.base);\r\nif (err < 0) {\r\ndev_err(dev, "failed to register host1x client: %d\n", err);\r\nclk_disable_unprepare(gr2d->clk);\r\nreturn err;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(gr2d_addr_regs); i++)\r\nset_bit(gr2d_addr_regs[i], gr2d->addr_regs);\r\nplatform_set_drvdata(pdev, gr2d);\r\nreturn 0;\r\n}\r\nstatic int gr2d_remove(struct platform_device *pdev)\r\n{\r\nstruct gr2d *gr2d = platform_get_drvdata(pdev);\r\nint err;\r\nerr = host1x_client_unregister(&gr2d->client.base);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to unregister host1x client: %d\n",\r\nerr);\r\nreturn err;\r\n}\r\nclk_disable_unprepare(gr2d->clk);\r\nreturn 0;\r\n}
