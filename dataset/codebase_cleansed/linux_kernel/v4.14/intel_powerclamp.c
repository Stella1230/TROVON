static int duration_set(const char *arg, const struct kernel_param *kp)\r\n{\r\nint ret = 0;\r\nunsigned long new_duration;\r\nret = kstrtoul(arg, 10, &new_duration);\r\nif (ret)\r\ngoto exit;\r\nif (new_duration > 25 || new_duration < 6) {\r\npr_err("Out of recommended range %lu, between 6-25ms\n",\r\nnew_duration);\r\nret = -EINVAL;\r\n}\r\nduration = clamp(new_duration, 6ul, 25ul);\r\nsmp_mb();\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int window_size_set(const char *arg, const struct kernel_param *kp)\r\n{\r\nint ret = 0;\r\nunsigned long new_window_size;\r\nret = kstrtoul(arg, 10, &new_window_size);\r\nif (ret)\r\ngoto exit_win;\r\nif (new_window_size > 10 || new_window_size < 2) {\r\npr_err("Out of recommended window size %lu, between 2-10\n",\r\nnew_window_size);\r\nret = -EINVAL;\r\n}\r\nwindow_size = clamp(new_window_size, 2ul, 10ul);\r\nsmp_mb();\r\nexit_win:\r\nreturn ret;\r\n}\r\nstatic void find_target_mwait(void)\r\n{\r\nunsigned int eax, ebx, ecx, edx;\r\nunsigned int highest_cstate = 0;\r\nunsigned int highest_subcstate = 0;\r\nint i;\r\nif (boot_cpu_data.cpuid_level < CPUID_MWAIT_LEAF)\r\nreturn;\r\ncpuid(CPUID_MWAIT_LEAF, &eax, &ebx, &ecx, &edx);\r\nif (!(ecx & CPUID5_ECX_EXTENSIONS_SUPPORTED) ||\r\n!(ecx & CPUID5_ECX_INTERRUPT_BREAK))\r\nreturn;\r\nedx >>= MWAIT_SUBSTATE_SIZE;\r\nfor (i = 0; i < 7 && edx; i++, edx >>= MWAIT_SUBSTATE_SIZE) {\r\nif (edx & MWAIT_SUBSTATE_MASK) {\r\nhighest_cstate = i;\r\nhighest_subcstate = edx & MWAIT_SUBSTATE_MASK;\r\n}\r\n}\r\ntarget_mwait = (highest_cstate << MWAIT_SUBSTATE_SIZE) |\r\n(highest_subcstate - 1);\r\n}\r\nstatic bool has_pkg_state_counter(void)\r\n{\r\nu64 val;\r\nstruct pkg_cstate_info *info = pkg_cstates;\r\nwhile (info->msr_index) {\r\nif (!rdmsrl_safe(info->msr_index, &val))\r\nreturn true;\r\ninfo++;\r\n}\r\nreturn false;\r\n}\r\nstatic u64 pkg_state_counter(void)\r\n{\r\nu64 val;\r\nu64 count = 0;\r\nstruct pkg_cstate_info *info = pkg_cstates;\r\nwhile (info->msr_index) {\r\nif (!info->skip) {\r\nif (!rdmsrl_safe(info->msr_index, &val))\r\ncount += val;\r\nelse\r\ninfo->skip = true;\r\n}\r\ninfo++;\r\n}\r\nreturn count;\r\n}\r\nstatic unsigned int get_compensation(int ratio)\r\n{\r\nunsigned int comp = 0;\r\nif (ratio == 1 &&\r\ncal_data[ratio].confidence >= CONFIDENCE_OK &&\r\ncal_data[ratio + 1].confidence >= CONFIDENCE_OK &&\r\ncal_data[ratio + 2].confidence >= CONFIDENCE_OK) {\r\ncomp = (cal_data[ratio].steady_comp +\r\ncal_data[ratio + 1].steady_comp +\r\ncal_data[ratio + 2].steady_comp) / 3;\r\n} else if (ratio == MAX_TARGET_RATIO - 1 &&\r\ncal_data[ratio].confidence >= CONFIDENCE_OK &&\r\ncal_data[ratio - 1].confidence >= CONFIDENCE_OK &&\r\ncal_data[ratio - 2].confidence >= CONFIDENCE_OK) {\r\ncomp = (cal_data[ratio].steady_comp +\r\ncal_data[ratio - 1].steady_comp +\r\ncal_data[ratio - 2].steady_comp) / 3;\r\n} else if (cal_data[ratio].confidence >= CONFIDENCE_OK &&\r\ncal_data[ratio - 1].confidence >= CONFIDENCE_OK &&\r\ncal_data[ratio + 1].confidence >= CONFIDENCE_OK) {\r\ncomp = (cal_data[ratio].steady_comp +\r\ncal_data[ratio - 1].steady_comp +\r\ncal_data[ratio + 1].steady_comp) / 3;\r\n}\r\nif (reduce_irq)\r\ncomp = ratio;\r\nif (comp + ratio >= MAX_TARGET_RATIO)\r\ncomp = MAX_TARGET_RATIO - ratio - 1;\r\nreturn comp;\r\n}\r\nstatic void adjust_compensation(int target_ratio, unsigned int win)\r\n{\r\nint delta;\r\nstruct powerclamp_calibration_data *d = &cal_data[target_ratio];\r\nif (d->confidence >= CONFIDENCE_OK ||\r\natomic_read(&idle_wakeup_counter) >\r\nwin * num_online_cpus())\r\nreturn;\r\ndelta = set_target_ratio - current_ratio;\r\nif (delta >= 0 && delta <= (1+target_ratio/10)) {\r\nif (d->steady_comp)\r\nd->steady_comp =\r\nroundup(delta+d->steady_comp, 2)/2;\r\nelse\r\nd->steady_comp = delta;\r\nd->confidence++;\r\n}\r\n}\r\nstatic bool powerclamp_adjust_controls(unsigned int target_ratio,\r\nunsigned int guard, unsigned int win)\r\n{\r\nstatic u64 msr_last, tsc_last;\r\nu64 msr_now, tsc_now;\r\nu64 val64;\r\nmsr_now = pkg_state_counter();\r\ntsc_now = rdtsc();\r\nif (!msr_last || !tsc_last)\r\ncurrent_ratio = 1;\r\nelse if (tsc_now-tsc_last) {\r\nval64 = 100*(msr_now-msr_last);\r\ndo_div(val64, (tsc_now-tsc_last));\r\ncurrent_ratio = val64;\r\n}\r\nmsr_last = msr_now;\r\ntsc_last = tsc_now;\r\nadjust_compensation(target_ratio, win);\r\nreduce_irq = atomic_read(&idle_wakeup_counter) >=\r\n2 * win * num_online_cpus();\r\natomic_set(&idle_wakeup_counter, 0);\r\nreturn set_target_ratio + guard <= current_ratio;\r\n}\r\nstatic void clamp_balancing_func(struct kthread_work *work)\r\n{\r\nstruct powerclamp_worker_data *w_data;\r\nint sleeptime;\r\nunsigned long target_jiffies;\r\nunsigned int compensated_ratio;\r\nint interval;\r\nw_data = container_of(work, struct powerclamp_worker_data,\r\nbalancing_work);\r\nw_data->target_ratio = READ_ONCE(set_target_ratio);\r\nw_data->guard = 1 + w_data->target_ratio / 20;\r\nw_data->window_size_now = window_size;\r\nw_data->duration_jiffies = msecs_to_jiffies(duration);\r\nw_data->count++;\r\ncompensated_ratio = w_data->target_ratio +\r\nget_compensation(w_data->target_ratio);\r\nif (compensated_ratio <= 0)\r\ncompensated_ratio = 1;\r\ninterval = w_data->duration_jiffies * 100 / compensated_ratio;\r\ntarget_jiffies = roundup(jiffies, interval);\r\nsleeptime = target_jiffies - jiffies;\r\nif (sleeptime <= 0)\r\nsleeptime = 1;\r\nif (clamping && w_data->clamping && cpu_online(w_data->cpu))\r\nkthread_queue_delayed_work(w_data->worker,\r\n&w_data->idle_injection_work,\r\nsleeptime);\r\n}\r\nstatic void clamp_idle_injection_func(struct kthread_work *work)\r\n{\r\nstruct powerclamp_worker_data *w_data;\r\nw_data = container_of(work, struct powerclamp_worker_data,\r\nidle_injection_work.work);\r\nif (w_data->cpu == control_cpu &&\r\n!(w_data->count % w_data->window_size_now)) {\r\nshould_skip =\r\npowerclamp_adjust_controls(w_data->target_ratio,\r\nw_data->guard,\r\nw_data->window_size_now);\r\nsmp_mb();\r\n}\r\nif (should_skip)\r\ngoto balance;\r\nplay_idle(jiffies_to_msecs(w_data->duration_jiffies));\r\nbalance:\r\nif (clamping && w_data->clamping && cpu_online(w_data->cpu))\r\nkthread_queue_work(w_data->worker, &w_data->balancing_work);\r\n}\r\nstatic void poll_pkg_cstate(struct work_struct *dummy)\r\n{\r\nstatic u64 msr_last;\r\nstatic u64 tsc_last;\r\nu64 msr_now;\r\nu64 tsc_now;\r\nu64 val64;\r\nmsr_now = pkg_state_counter();\r\ntsc_now = rdtsc();\r\nif (!msr_last || !tsc_last)\r\npkg_cstate_ratio_cur = 1;\r\nelse {\r\nif (tsc_now - tsc_last) {\r\nval64 = 100 * (msr_now - msr_last);\r\ndo_div(val64, (tsc_now - tsc_last));\r\npkg_cstate_ratio_cur = val64;\r\n}\r\n}\r\nmsr_last = msr_now;\r\ntsc_last = tsc_now;\r\nif (true == clamping)\r\nschedule_delayed_work(&poll_pkg_cstate_work, HZ);\r\n}\r\nstatic void start_power_clamp_worker(unsigned long cpu)\r\n{\r\nstruct powerclamp_worker_data *w_data = per_cpu_ptr(worker_data, cpu);\r\nstruct kthread_worker *worker;\r\nworker = kthread_create_worker_on_cpu(cpu, 0, "kidle_inject/%ld", cpu);\r\nif (IS_ERR(worker))\r\nreturn;\r\nw_data->worker = worker;\r\nw_data->count = 0;\r\nw_data->cpu = cpu;\r\nw_data->clamping = true;\r\nset_bit(cpu, cpu_clamping_mask);\r\nsched_setscheduler(worker->task, SCHED_FIFO, &sparam);\r\nkthread_init_work(&w_data->balancing_work, clamp_balancing_func);\r\nkthread_init_delayed_work(&w_data->idle_injection_work,\r\nclamp_idle_injection_func);\r\nkthread_queue_work(w_data->worker, &w_data->balancing_work);\r\n}\r\nstatic void stop_power_clamp_worker(unsigned long cpu)\r\n{\r\nstruct powerclamp_worker_data *w_data = per_cpu_ptr(worker_data, cpu);\r\nif (!w_data->worker)\r\nreturn;\r\nw_data->clamping = false;\r\nsmp_wmb();\r\nkthread_cancel_work_sync(&w_data->balancing_work);\r\nkthread_cancel_delayed_work_sync(&w_data->idle_injection_work);\r\nclear_bit(w_data->cpu, cpu_clamping_mask);\r\nkthread_destroy_worker(w_data->worker);\r\nw_data->worker = NULL;\r\n}\r\nstatic int start_power_clamp(void)\r\n{\r\nunsigned long cpu;\r\nset_target_ratio = clamp(set_target_ratio, 0U, MAX_TARGET_RATIO - 1);\r\nget_online_cpus();\r\ncontrol_cpu = 0;\r\nif (!cpu_online(control_cpu))\r\ncontrol_cpu = smp_processor_id();\r\nclamping = true;\r\nschedule_delayed_work(&poll_pkg_cstate_work, 0);\r\nfor_each_online_cpu(cpu) {\r\nstart_power_clamp_worker(cpu);\r\n}\r\nput_online_cpus();\r\nreturn 0;\r\n}\r\nstatic void end_power_clamp(void)\r\n{\r\nint i;\r\nclamping = false;\r\nif (bitmap_weight(cpu_clamping_mask, num_possible_cpus())) {\r\nfor_each_set_bit(i, cpu_clamping_mask, num_possible_cpus()) {\r\npr_debug("clamping worker for cpu %d alive, destroy\n",\r\ni);\r\nstop_power_clamp_worker(i);\r\n}\r\n}\r\n}\r\nstatic int powerclamp_cpu_online(unsigned int cpu)\r\n{\r\nif (clamping == false)\r\nreturn 0;\r\nstart_power_clamp_worker(cpu);\r\nif (cpu == 0) {\r\ncontrol_cpu = 0;\r\nsmp_mb();\r\n}\r\nreturn 0;\r\n}\r\nstatic int powerclamp_cpu_predown(unsigned int cpu)\r\n{\r\nif (clamping == false)\r\nreturn 0;\r\nstop_power_clamp_worker(cpu);\r\nif (cpu != control_cpu)\r\nreturn 0;\r\ncontrol_cpu = cpumask_first(cpu_online_mask);\r\nif (control_cpu == cpu)\r\ncontrol_cpu = cpumask_next(cpu, cpu_online_mask);\r\nsmp_mb();\r\nreturn 0;\r\n}\r\nstatic int powerclamp_get_max_state(struct thermal_cooling_device *cdev,\r\nunsigned long *state)\r\n{\r\n*state = MAX_TARGET_RATIO;\r\nreturn 0;\r\n}\r\nstatic int powerclamp_get_cur_state(struct thermal_cooling_device *cdev,\r\nunsigned long *state)\r\n{\r\nif (true == clamping)\r\n*state = pkg_cstate_ratio_cur;\r\nelse\r\n*state = -1;\r\nreturn 0;\r\n}\r\nstatic int powerclamp_set_cur_state(struct thermal_cooling_device *cdev,\r\nunsigned long new_target_ratio)\r\n{\r\nint ret = 0;\r\nnew_target_ratio = clamp(new_target_ratio, 0UL,\r\n(unsigned long) (MAX_TARGET_RATIO-1));\r\nif (set_target_ratio == 0 && new_target_ratio > 0) {\r\npr_info("Start idle injection to reduce power\n");\r\nset_target_ratio = new_target_ratio;\r\nret = start_power_clamp();\r\ngoto exit_set;\r\n} else if (set_target_ratio > 0 && new_target_ratio == 0) {\r\npr_info("Stop forced idle injection\n");\r\nend_power_clamp();\r\nset_target_ratio = 0;\r\n} else {\r\nset_target_ratio = new_target_ratio;\r\nsmp_mb();\r\n}\r\nexit_set:\r\nreturn ret;\r\n}\r\nstatic int __init powerclamp_probe(void)\r\n{\r\nif (!x86_match_cpu(intel_powerclamp_ids)) {\r\npr_err("CPU does not support MWAIT");\r\nreturn -ENODEV;\r\n}\r\nif (!has_pkg_state_counter()) {\r\npr_info("No package C-state available");\r\nreturn -ENODEV;\r\n}\r\nfind_target_mwait();\r\nreturn 0;\r\n}\r\nstatic int powerclamp_debug_show(struct seq_file *m, void *unused)\r\n{\r\nint i = 0;\r\nseq_printf(m, "controlling cpu: %d\n", control_cpu);\r\nseq_printf(m, "pct confidence steady dynamic (compensation)\n");\r\nfor (i = 0; i < MAX_TARGET_RATIO; i++) {\r\nseq_printf(m, "%d\t%lu\t%lu\t%lu\n",\r\ni,\r\ncal_data[i].confidence,\r\ncal_data[i].steady_comp,\r\ncal_data[i].dynamic_comp);\r\n}\r\nreturn 0;\r\n}\r\nstatic int powerclamp_debug_open(struct inode *inode,\r\nstruct file *file)\r\n{\r\nreturn single_open(file, powerclamp_debug_show, inode->i_private);\r\n}\r\nstatic inline void powerclamp_create_debug_files(void)\r\n{\r\ndebug_dir = debugfs_create_dir("intel_powerclamp", NULL);\r\nif (!debug_dir)\r\nreturn;\r\nif (!debugfs_create_file("powerclamp_calib", S_IRUGO, debug_dir,\r\ncal_data, &powerclamp_debug_fops))\r\ngoto file_error;\r\nreturn;\r\nfile_error:\r\ndebugfs_remove_recursive(debug_dir);\r\n}\r\nstatic int __init powerclamp_init(void)\r\n{\r\nint retval;\r\nint bitmap_size;\r\nbitmap_size = BITS_TO_LONGS(num_possible_cpus()) * sizeof(long);\r\ncpu_clamping_mask = kzalloc(bitmap_size, GFP_KERNEL);\r\nif (!cpu_clamping_mask)\r\nreturn -ENOMEM;\r\nretval = powerclamp_probe();\r\nif (retval)\r\ngoto exit_free;\r\nwindow_size = 2;\r\nretval = cpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN,\r\n"thermal/intel_powerclamp:online",\r\npowerclamp_cpu_online,\r\npowerclamp_cpu_predown);\r\nif (retval < 0)\r\ngoto exit_free;\r\nhp_state = retval;\r\nworker_data = alloc_percpu(struct powerclamp_worker_data);\r\nif (!worker_data) {\r\nretval = -ENOMEM;\r\ngoto exit_unregister;\r\n}\r\ncooling_dev = thermal_cooling_device_register("intel_powerclamp", NULL,\r\n&powerclamp_cooling_ops);\r\nif (IS_ERR(cooling_dev)) {\r\nretval = -ENODEV;\r\ngoto exit_free_thread;\r\n}\r\nif (!duration)\r\nduration = jiffies_to_msecs(DEFAULT_DURATION_JIFFIES);\r\npowerclamp_create_debug_files();\r\nreturn 0;\r\nexit_free_thread:\r\nfree_percpu(worker_data);\r\nexit_unregister:\r\ncpuhp_remove_state_nocalls(hp_state);\r\nexit_free:\r\nkfree(cpu_clamping_mask);\r\nreturn retval;\r\n}\r\nstatic void __exit powerclamp_exit(void)\r\n{\r\nend_power_clamp();\r\ncpuhp_remove_state_nocalls(hp_state);\r\nfree_percpu(worker_data);\r\nthermal_cooling_device_unregister(cooling_dev);\r\nkfree(cpu_clamping_mask);\r\ncancel_delayed_work_sync(&poll_pkg_cstate_work);\r\ndebugfs_remove_recursive(debug_dir);\r\n}
