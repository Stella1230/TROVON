void mlx5e_fill_hwstamp(struct mlx5e_tstamp *tstamp, u64 timestamp,\r\nstruct skb_shared_hwtstamps *hwts)\r\n{\r\nu64 nsec;\r\nread_lock(&tstamp->lock);\r\nnsec = timecounter_cyc2time(&tstamp->clock, timestamp);\r\nread_unlock(&tstamp->lock);\r\nhwts->hwtstamp = ns_to_ktime(nsec);\r\n}\r\nstatic u64 mlx5e_read_internal_timer(const struct cyclecounter *cc)\r\n{\r\nstruct mlx5e_tstamp *tstamp = container_of(cc, struct mlx5e_tstamp,\r\ncycles);\r\nreturn mlx5_read_internal_timer(tstamp->mdev) & cc->mask;\r\n}\r\nstatic void mlx5e_pps_out(struct work_struct *work)\r\n{\r\nstruct mlx5e_pps *pps_info = container_of(work, struct mlx5e_pps,\r\nout_work);\r\nstruct mlx5e_tstamp *tstamp = container_of(pps_info, struct mlx5e_tstamp,\r\npps_info);\r\nu32 in[MLX5_ST_SZ_DW(mtpps_reg)] = {0};\r\nunsigned long flags;\r\nint i;\r\nfor (i = 0; i < tstamp->ptp_info.n_pins; i++) {\r\nu64 tstart;\r\nwrite_lock_irqsave(&tstamp->lock, flags);\r\ntstart = tstamp->pps_info.start[i];\r\ntstamp->pps_info.start[i] = 0;\r\nwrite_unlock_irqrestore(&tstamp->lock, flags);\r\nif (!tstart)\r\ncontinue;\r\nMLX5_SET(mtpps_reg, in, pin, i);\r\nMLX5_SET64(mtpps_reg, in, time_stamp, tstart);\r\nMLX5_SET(mtpps_reg, in, field_select, MLX5E_MTPPS_FS_TIME_STAMP);\r\nmlx5_set_mtpps(tstamp->mdev, in, sizeof(in));\r\n}\r\n}\r\nstatic void mlx5e_timestamp_overflow(struct work_struct *work)\r\n{\r\nstruct delayed_work *dwork = to_delayed_work(work);\r\nstruct mlx5e_tstamp *tstamp = container_of(dwork, struct mlx5e_tstamp,\r\noverflow_work);\r\nstruct mlx5e_priv *priv = container_of(tstamp, struct mlx5e_priv, tstamp);\r\nunsigned long flags;\r\nwrite_lock_irqsave(&tstamp->lock, flags);\r\ntimecounter_read(&tstamp->clock);\r\nwrite_unlock_irqrestore(&tstamp->lock, flags);\r\nqueue_delayed_work(priv->wq, &tstamp->overflow_work,\r\nmsecs_to_jiffies(tstamp->overflow_period * 1000));\r\n}\r\nint mlx5e_hwstamp_set(struct mlx5e_priv *priv, struct ifreq *ifr)\r\n{\r\nstruct hwtstamp_config config;\r\nint err;\r\nif (!MLX5_CAP_GEN(priv->mdev, device_frequency_khz))\r\nreturn -EOPNOTSUPP;\r\nif (copy_from_user(&config, ifr->ifr_data, sizeof(config)))\r\nreturn -EFAULT;\r\nswitch (config.tx_type) {\r\ncase HWTSTAMP_TX_OFF:\r\ncase HWTSTAMP_TX_ON:\r\nbreak;\r\ndefault:\r\nreturn -ERANGE;\r\n}\r\nmutex_lock(&priv->state_lock);\r\nswitch (config.rx_filter) {\r\ncase HWTSTAMP_FILTER_NONE:\r\nmlx5e_modify_rx_cqe_compression_locked(priv, priv->channels.params.rx_cqe_compress_def);\r\nbreak;\r\ncase HWTSTAMP_FILTER_ALL:\r\ncase HWTSTAMP_FILTER_SOME:\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\r\ncase HWTSTAMP_FILTER_PTP_V2_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V2_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\r\ncase HWTSTAMP_FILTER_NTP_ALL:\r\nnetdev_warn(priv->netdev, "Disabling cqe compression");\r\nerr = mlx5e_modify_rx_cqe_compression_locked(priv, false);\r\nif (err) {\r\nnetdev_err(priv->netdev, "Failed disabling cqe compression err=%d\n", err);\r\nmutex_unlock(&priv->state_lock);\r\nreturn err;\r\n}\r\nconfig.rx_filter = HWTSTAMP_FILTER_ALL;\r\nbreak;\r\ndefault:\r\nmutex_unlock(&priv->state_lock);\r\nreturn -ERANGE;\r\n}\r\nmemcpy(&priv->tstamp.hwtstamp_config, &config, sizeof(config));\r\nmutex_unlock(&priv->state_lock);\r\nreturn copy_to_user(ifr->ifr_data, &config,\r\nsizeof(config)) ? -EFAULT : 0;\r\n}\r\nint mlx5e_hwstamp_get(struct mlx5e_priv *priv, struct ifreq *ifr)\r\n{\r\nstruct hwtstamp_config *cfg = &priv->tstamp.hwtstamp_config;\r\nif (!MLX5_CAP_GEN(priv->mdev, device_frequency_khz))\r\nreturn -EOPNOTSUPP;\r\nreturn copy_to_user(ifr->ifr_data, cfg, sizeof(*cfg)) ? -EFAULT : 0;\r\n}\r\nstatic int mlx5e_ptp_settime(struct ptp_clock_info *ptp,\r\nconst struct timespec64 *ts)\r\n{\r\nstruct mlx5e_tstamp *tstamp = container_of(ptp, struct mlx5e_tstamp,\r\nptp_info);\r\nu64 ns = timespec64_to_ns(ts);\r\nunsigned long flags;\r\nwrite_lock_irqsave(&tstamp->lock, flags);\r\ntimecounter_init(&tstamp->clock, &tstamp->cycles, ns);\r\nwrite_unlock_irqrestore(&tstamp->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int mlx5e_ptp_gettime(struct ptp_clock_info *ptp,\r\nstruct timespec64 *ts)\r\n{\r\nstruct mlx5e_tstamp *tstamp = container_of(ptp, struct mlx5e_tstamp,\r\nptp_info);\r\nu64 ns;\r\nunsigned long flags;\r\nwrite_lock_irqsave(&tstamp->lock, flags);\r\nns = timecounter_read(&tstamp->clock);\r\nwrite_unlock_irqrestore(&tstamp->lock, flags);\r\n*ts = ns_to_timespec64(ns);\r\nreturn 0;\r\n}\r\nstatic int mlx5e_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)\r\n{\r\nstruct mlx5e_tstamp *tstamp = container_of(ptp, struct mlx5e_tstamp,\r\nptp_info);\r\nunsigned long flags;\r\nwrite_lock_irqsave(&tstamp->lock, flags);\r\ntimecounter_adjtime(&tstamp->clock, delta);\r\nwrite_unlock_irqrestore(&tstamp->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int mlx5e_ptp_adjfreq(struct ptp_clock_info *ptp, s32 delta)\r\n{\r\nu64 adj;\r\nu32 diff;\r\nunsigned long flags;\r\nint neg_adj = 0;\r\nstruct mlx5e_tstamp *tstamp = container_of(ptp, struct mlx5e_tstamp,\r\nptp_info);\r\nif (delta < 0) {\r\nneg_adj = 1;\r\ndelta = -delta;\r\n}\r\nadj = tstamp->nominal_c_mult;\r\nadj *= delta;\r\ndiff = div_u64(adj, 1000000000ULL);\r\nwrite_lock_irqsave(&tstamp->lock, flags);\r\ntimecounter_read(&tstamp->clock);\r\ntstamp->cycles.mult = neg_adj ? tstamp->nominal_c_mult - diff :\r\ntstamp->nominal_c_mult + diff;\r\nwrite_unlock_irqrestore(&tstamp->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int mlx5e_extts_configure(struct ptp_clock_info *ptp,\r\nstruct ptp_clock_request *rq,\r\nint on)\r\n{\r\nstruct mlx5e_tstamp *tstamp =\r\ncontainer_of(ptp, struct mlx5e_tstamp, ptp_info);\r\nstruct mlx5e_priv *priv =\r\ncontainer_of(tstamp, struct mlx5e_priv, tstamp);\r\nu32 in[MLX5_ST_SZ_DW(mtpps_reg)] = {0};\r\nu32 field_select = 0;\r\nu8 pin_mode = 0;\r\nu8 pattern = 0;\r\nint pin = -1;\r\nint err = 0;\r\nif (!MLX5_PPS_CAP(priv->mdev))\r\nreturn -EOPNOTSUPP;\r\nif (rq->extts.index >= tstamp->ptp_info.n_pins)\r\nreturn -EINVAL;\r\nif (on) {\r\npin = ptp_find_pin(tstamp->ptp, PTP_PF_EXTTS, rq->extts.index);\r\nif (pin < 0)\r\nreturn -EBUSY;\r\npin_mode = MLX5E_PIN_MODE_IN;\r\npattern = !!(rq->extts.flags & PTP_FALLING_EDGE);\r\nfield_select = MLX5E_MTPPS_FS_PIN_MODE |\r\nMLX5E_MTPPS_FS_PATTERN |\r\nMLX5E_MTPPS_FS_ENABLE;\r\n} else {\r\npin = rq->extts.index;\r\nfield_select = MLX5E_MTPPS_FS_ENABLE;\r\n}\r\nMLX5_SET(mtpps_reg, in, pin, pin);\r\nMLX5_SET(mtpps_reg, in, pin_mode, pin_mode);\r\nMLX5_SET(mtpps_reg, in, pattern, pattern);\r\nMLX5_SET(mtpps_reg, in, enable, on);\r\nMLX5_SET(mtpps_reg, in, field_select, field_select);\r\nerr = mlx5_set_mtpps(priv->mdev, in, sizeof(in));\r\nif (err)\r\nreturn err;\r\nreturn mlx5_set_mtppse(priv->mdev, pin, 0,\r\nMLX5E_EVENT_MODE_REPETETIVE & on);\r\n}\r\nstatic int mlx5e_perout_configure(struct ptp_clock_info *ptp,\r\nstruct ptp_clock_request *rq,\r\nint on)\r\n{\r\nstruct mlx5e_tstamp *tstamp =\r\ncontainer_of(ptp, struct mlx5e_tstamp, ptp_info);\r\nstruct mlx5e_priv *priv =\r\ncontainer_of(tstamp, struct mlx5e_priv, tstamp);\r\nu32 in[MLX5_ST_SZ_DW(mtpps_reg)] = {0};\r\nu64 nsec_now, nsec_delta, time_stamp = 0;\r\nu64 cycles_now, cycles_delta;\r\nstruct timespec64 ts;\r\nunsigned long flags;\r\nu32 field_select = 0;\r\nu8 pin_mode = 0;\r\nu8 pattern = 0;\r\nint pin = -1;\r\nint err = 0;\r\ns64 ns;\r\nif (!MLX5_PPS_CAP(priv->mdev))\r\nreturn -EOPNOTSUPP;\r\nif (rq->perout.index >= tstamp->ptp_info.n_pins)\r\nreturn -EINVAL;\r\nif (on) {\r\npin = ptp_find_pin(tstamp->ptp, PTP_PF_PEROUT,\r\nrq->perout.index);\r\nif (pin < 0)\r\nreturn -EBUSY;\r\npin_mode = MLX5E_PIN_MODE_OUT;\r\npattern = MLX5E_OUT_PATTERN_PERIODIC;\r\nts.tv_sec = rq->perout.period.sec;\r\nts.tv_nsec = rq->perout.period.nsec;\r\nns = timespec64_to_ns(&ts);\r\nif ((ns >> 1) != 500000000LL)\r\nreturn -EINVAL;\r\nts.tv_sec = rq->perout.start.sec;\r\nts.tv_nsec = rq->perout.start.nsec;\r\nns = timespec64_to_ns(&ts);\r\ncycles_now = mlx5_read_internal_timer(tstamp->mdev);\r\nwrite_lock_irqsave(&tstamp->lock, flags);\r\nnsec_now = timecounter_cyc2time(&tstamp->clock, cycles_now);\r\nnsec_delta = ns - nsec_now;\r\ncycles_delta = div64_u64(nsec_delta << tstamp->cycles.shift,\r\ntstamp->cycles.mult);\r\nwrite_unlock_irqrestore(&tstamp->lock, flags);\r\ntime_stamp = cycles_now + cycles_delta;\r\nfield_select = MLX5E_MTPPS_FS_PIN_MODE |\r\nMLX5E_MTPPS_FS_PATTERN |\r\nMLX5E_MTPPS_FS_ENABLE |\r\nMLX5E_MTPPS_FS_TIME_STAMP;\r\n} else {\r\npin = rq->perout.index;\r\nfield_select = MLX5E_MTPPS_FS_ENABLE;\r\n}\r\nMLX5_SET(mtpps_reg, in, pin, pin);\r\nMLX5_SET(mtpps_reg, in, pin_mode, pin_mode);\r\nMLX5_SET(mtpps_reg, in, pattern, pattern);\r\nMLX5_SET(mtpps_reg, in, enable, on);\r\nMLX5_SET64(mtpps_reg, in, time_stamp, time_stamp);\r\nMLX5_SET(mtpps_reg, in, field_select, field_select);\r\nerr = mlx5_set_mtpps(priv->mdev, in, sizeof(in));\r\nif (err)\r\nreturn err;\r\nreturn mlx5_set_mtppse(priv->mdev, pin, 0,\r\nMLX5E_EVENT_MODE_REPETETIVE & on);\r\n}\r\nstatic int mlx5e_pps_configure(struct ptp_clock_info *ptp,\r\nstruct ptp_clock_request *rq,\r\nint on)\r\n{\r\nstruct mlx5e_tstamp *tstamp =\r\ncontainer_of(ptp, struct mlx5e_tstamp, ptp_info);\r\ntstamp->pps_info.enabled = !!on;\r\nreturn 0;\r\n}\r\nstatic int mlx5e_ptp_enable(struct ptp_clock_info *ptp,\r\nstruct ptp_clock_request *rq,\r\nint on)\r\n{\r\nswitch (rq->type) {\r\ncase PTP_CLK_REQ_EXTTS:\r\nreturn mlx5e_extts_configure(ptp, rq, on);\r\ncase PTP_CLK_REQ_PEROUT:\r\nreturn mlx5e_perout_configure(ptp, rq, on);\r\ncase PTP_CLK_REQ_PPS:\r\nreturn mlx5e_pps_configure(ptp, rq, on);\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mlx5e_ptp_verify(struct ptp_clock_info *ptp, unsigned int pin,\r\nenum ptp_pin_function func, unsigned int chan)\r\n{\r\nreturn (func == PTP_PF_PHYSYNC) ? -EOPNOTSUPP : 0;\r\n}\r\nstatic void mlx5e_timestamp_init_config(struct mlx5e_tstamp *tstamp)\r\n{\r\ntstamp->hwtstamp_config.tx_type = HWTSTAMP_TX_OFF;\r\ntstamp->hwtstamp_config.rx_filter = HWTSTAMP_FILTER_NONE;\r\n}\r\nstatic int mlx5e_init_pin_config(struct mlx5e_tstamp *tstamp)\r\n{\r\nint i;\r\ntstamp->ptp_info.pin_config =\r\nkzalloc(sizeof(*tstamp->ptp_info.pin_config) *\r\ntstamp->ptp_info.n_pins, GFP_KERNEL);\r\nif (!tstamp->ptp_info.pin_config)\r\nreturn -ENOMEM;\r\ntstamp->ptp_info.enable = mlx5e_ptp_enable;\r\ntstamp->ptp_info.verify = mlx5e_ptp_verify;\r\ntstamp->ptp_info.pps = 1;\r\nfor (i = 0; i < tstamp->ptp_info.n_pins; i++) {\r\nsnprintf(tstamp->ptp_info.pin_config[i].name,\r\nsizeof(tstamp->ptp_info.pin_config[i].name),\r\n"mlx5_pps%d", i);\r\ntstamp->ptp_info.pin_config[i].index = i;\r\ntstamp->ptp_info.pin_config[i].func = PTP_PF_NONE;\r\ntstamp->ptp_info.pin_config[i].chan = i;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mlx5e_get_pps_caps(struct mlx5e_priv *priv,\r\nstruct mlx5e_tstamp *tstamp)\r\n{\r\nu32 out[MLX5_ST_SZ_DW(mtpps_reg)] = {0};\r\nmlx5_query_mtpps(priv->mdev, out, sizeof(out));\r\ntstamp->ptp_info.n_pins = MLX5_GET(mtpps_reg, out,\r\ncap_number_of_pps_pins);\r\ntstamp->ptp_info.n_ext_ts = MLX5_GET(mtpps_reg, out,\r\ncap_max_num_of_pps_in_pins);\r\ntstamp->ptp_info.n_per_out = MLX5_GET(mtpps_reg, out,\r\ncap_max_num_of_pps_out_pins);\r\ntstamp->pps_info.pin_caps[0] = MLX5_GET(mtpps_reg, out, cap_pin_0_mode);\r\ntstamp->pps_info.pin_caps[1] = MLX5_GET(mtpps_reg, out, cap_pin_1_mode);\r\ntstamp->pps_info.pin_caps[2] = MLX5_GET(mtpps_reg, out, cap_pin_2_mode);\r\ntstamp->pps_info.pin_caps[3] = MLX5_GET(mtpps_reg, out, cap_pin_3_mode);\r\ntstamp->pps_info.pin_caps[4] = MLX5_GET(mtpps_reg, out, cap_pin_4_mode);\r\ntstamp->pps_info.pin_caps[5] = MLX5_GET(mtpps_reg, out, cap_pin_5_mode);\r\ntstamp->pps_info.pin_caps[6] = MLX5_GET(mtpps_reg, out, cap_pin_6_mode);\r\ntstamp->pps_info.pin_caps[7] = MLX5_GET(mtpps_reg, out, cap_pin_7_mode);\r\n}\r\nvoid mlx5e_pps_event_handler(struct mlx5e_priv *priv,\r\nstruct ptp_clock_event *event)\r\n{\r\nstruct net_device *netdev = priv->netdev;\r\nstruct mlx5e_tstamp *tstamp = &priv->tstamp;\r\nstruct timespec64 ts;\r\nu64 nsec_now, nsec_delta;\r\nu64 cycles_now, cycles_delta;\r\nint pin = event->index;\r\ns64 ns;\r\nunsigned long flags;\r\nswitch (tstamp->ptp_info.pin_config[pin].func) {\r\ncase PTP_PF_EXTTS:\r\nif (tstamp->pps_info.enabled) {\r\nevent->type = PTP_CLOCK_PPSUSR;\r\nevent->pps_times.ts_real = ns_to_timespec64(event->timestamp);\r\n} else {\r\nevent->type = PTP_CLOCK_EXTTS;\r\n}\r\nptp_clock_event(tstamp->ptp, event);\r\nbreak;\r\ncase PTP_PF_PEROUT:\r\nmlx5e_ptp_gettime(&tstamp->ptp_info, &ts);\r\ncycles_now = mlx5_read_internal_timer(tstamp->mdev);\r\nts.tv_sec += 1;\r\nts.tv_nsec = 0;\r\nns = timespec64_to_ns(&ts);\r\nwrite_lock_irqsave(&tstamp->lock, flags);\r\nnsec_now = timecounter_cyc2time(&tstamp->clock, cycles_now);\r\nnsec_delta = ns - nsec_now;\r\ncycles_delta = div64_u64(nsec_delta << tstamp->cycles.shift,\r\ntstamp->cycles.mult);\r\ntstamp->pps_info.start[pin] = cycles_now + cycles_delta;\r\nqueue_work(priv->wq, &tstamp->pps_info.out_work);\r\nwrite_unlock_irqrestore(&tstamp->lock, flags);\r\nbreak;\r\ndefault:\r\nnetdev_err(netdev, "%s: Unhandled event\n", __func__);\r\n}\r\n}\r\nvoid mlx5e_timestamp_init(struct mlx5e_priv *priv)\r\n{\r\nstruct mlx5e_tstamp *tstamp = &priv->tstamp;\r\nu64 ns;\r\nu64 frac = 0;\r\nu32 dev_freq;\r\nmlx5e_timestamp_init_config(tstamp);\r\ndev_freq = MLX5_CAP_GEN(priv->mdev, device_frequency_khz);\r\nif (!dev_freq) {\r\nmlx5_core_warn(priv->mdev, "invalid device_frequency_khz, aborting HW clock init\n");\r\nreturn;\r\n}\r\nrwlock_init(&tstamp->lock);\r\ntstamp->cycles.read = mlx5e_read_internal_timer;\r\ntstamp->cycles.shift = MLX5E_CYCLES_SHIFT;\r\ntstamp->cycles.mult = clocksource_khz2mult(dev_freq,\r\ntstamp->cycles.shift);\r\ntstamp->nominal_c_mult = tstamp->cycles.mult;\r\ntstamp->cycles.mask = CLOCKSOURCE_MASK(41);\r\ntstamp->mdev = priv->mdev;\r\ntimecounter_init(&tstamp->clock, &tstamp->cycles,\r\nktime_to_ns(ktime_get_real()));\r\nns = cyclecounter_cyc2ns(&tstamp->cycles, tstamp->cycles.mask,\r\nfrac, &frac);\r\ndo_div(ns, NSEC_PER_SEC / 2 / HZ);\r\ntstamp->overflow_period = ns;\r\nINIT_WORK(&tstamp->pps_info.out_work, mlx5e_pps_out);\r\nINIT_DELAYED_WORK(&tstamp->overflow_work, mlx5e_timestamp_overflow);\r\nif (tstamp->overflow_period)\r\nqueue_delayed_work(priv->wq, &tstamp->overflow_work, 0);\r\nelse\r\nmlx5_core_warn(priv->mdev, "invalid overflow period, overflow_work is not scheduled\n");\r\ntstamp->ptp_info = mlx5e_ptp_clock_info;\r\nsnprintf(tstamp->ptp_info.name, 16, "mlx5 ptp");\r\nif (MLX5_PPS_CAP(priv->mdev))\r\nmlx5e_get_pps_caps(priv, tstamp);\r\nif (tstamp->ptp_info.n_pins)\r\nmlx5e_init_pin_config(tstamp);\r\ntstamp->ptp = ptp_clock_register(&tstamp->ptp_info,\r\n&priv->mdev->pdev->dev);\r\nif (IS_ERR(tstamp->ptp)) {\r\nmlx5_core_warn(priv->mdev, "ptp_clock_register failed %ld\n",\r\nPTR_ERR(tstamp->ptp));\r\ntstamp->ptp = NULL;\r\n}\r\n}\r\nvoid mlx5e_timestamp_cleanup(struct mlx5e_priv *priv)\r\n{\r\nstruct mlx5e_tstamp *tstamp = &priv->tstamp;\r\nif (!MLX5_CAP_GEN(priv->mdev, device_frequency_khz))\r\nreturn;\r\nif (priv->tstamp.ptp) {\r\nptp_clock_unregister(priv->tstamp.ptp);\r\npriv->tstamp.ptp = NULL;\r\n}\r\ncancel_work_sync(&tstamp->pps_info.out_work);\r\ncancel_delayed_work_sync(&tstamp->overflow_work);\r\nkfree(tstamp->ptp_info.pin_config);\r\n}
