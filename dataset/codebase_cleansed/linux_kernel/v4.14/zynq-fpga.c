static inline void zynq_fpga_write(struct zynq_fpga_priv *priv, u32 offset,\r\nu32 val)\r\n{\r\nwritel(val, priv->io_base + offset);\r\n}\r\nstatic inline u32 zynq_fpga_read(const struct zynq_fpga_priv *priv,\r\nu32 offset)\r\n{\r\nreturn readl(priv->io_base + offset);\r\n}\r\nstatic inline void zynq_fpga_set_irq(struct zynq_fpga_priv *priv, u32 enable)\r\n{\r\nzynq_fpga_write(priv, INT_MASK_OFFSET, ~enable);\r\n}\r\nstatic void zynq_step_dma(struct zynq_fpga_priv *priv)\r\n{\r\nu32 addr;\r\nu32 len;\r\nbool first;\r\nfirst = priv->dma_elm == 0;\r\nwhile (priv->cur_sg) {\r\nif (zynq_fpga_read(priv, STATUS_OFFSET) & STATUS_DMA_Q_F)\r\nbreak;\r\naddr = sg_dma_address(priv->cur_sg);\r\nlen = sg_dma_len(priv->cur_sg);\r\nif (priv->dma_elm + 1 == priv->dma_nelms) {\r\naddr |= DMA_SRC_LAST_TRANSFER;\r\npriv->cur_sg = NULL;\r\n} else {\r\npriv->cur_sg = sg_next(priv->cur_sg);\r\npriv->dma_elm++;\r\n}\r\nzynq_fpga_write(priv, DMA_SRC_ADDR_OFFSET, addr);\r\nzynq_fpga_write(priv, DMA_DST_ADDR_OFFSET, DMA_INVALID_ADDRESS);\r\nzynq_fpga_write(priv, DMA_SRC_LEN_OFFSET, len / 4);\r\nzynq_fpga_write(priv, DMA_DEST_LEN_OFFSET, 0);\r\n}\r\nif (first && priv->cur_sg) {\r\nzynq_fpga_set_irq(priv,\r\nIXR_DMA_DONE_MASK | IXR_ERROR_FLAGS_MASK);\r\n} else if (!priv->cur_sg) {\r\nzynq_fpga_set_irq(priv,\r\nIXR_D_P_DONE_MASK | IXR_ERROR_FLAGS_MASK);\r\n}\r\n}\r\nstatic irqreturn_t zynq_fpga_isr(int irq, void *data)\r\n{\r\nstruct zynq_fpga_priv *priv = data;\r\nu32 intr_status;\r\nspin_lock(&priv->dma_lock);\r\nintr_status = zynq_fpga_read(priv, INT_STS_OFFSET);\r\nif (!(intr_status & IXR_ERROR_FLAGS_MASK) &&\r\n(intr_status & IXR_DMA_DONE_MASK) && priv->cur_sg) {\r\nzynq_fpga_write(priv, INT_STS_OFFSET, IXR_DMA_DONE_MASK);\r\nzynq_step_dma(priv);\r\nspin_unlock(&priv->dma_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nspin_unlock(&priv->dma_lock);\r\nzynq_fpga_set_irq(priv, 0);\r\ncomplete(&priv->dma_done);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic bool zynq_fpga_has_sync(const u8 *buf, size_t count)\r\n{\r\nfor (; count >= 4; buf += 4, count -= 4)\r\nif (buf[0] == 0x66 && buf[1] == 0x55 && buf[2] == 0x99 &&\r\nbuf[3] == 0xaa)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int zynq_fpga_ops_write_init(struct fpga_manager *mgr,\r\nstruct fpga_image_info *info,\r\nconst char *buf, size_t count)\r\n{\r\nstruct zynq_fpga_priv *priv;\r\nu32 ctrl, status;\r\nint err;\r\npriv = mgr->priv;\r\nerr = clk_enable(priv->clk);\r\nif (err)\r\nreturn err;\r\nif (info->flags & FPGA_MGR_ENCRYPTED_BITSTREAM) {\r\nctrl = zynq_fpga_read(priv, CTRL_OFFSET);\r\nif (!(ctrl & CTRL_SEC_EN_MASK)) {\r\ndev_err(&mgr->dev,\r\n"System not secure, can't use crypted bitstreams\n");\r\nerr = -EINVAL;\r\ngoto out_err;\r\n}\r\n}\r\nif (!(info->flags & FPGA_MGR_PARTIAL_RECONFIG)) {\r\nif (!zynq_fpga_has_sync(buf, count)) {\r\ndev_err(&mgr->dev,\r\n"Invalid bitstream, could not find a sync word. Bitstream must be a byte swapped .bin file\n");\r\nerr = -EINVAL;\r\ngoto out_err;\r\n}\r\nregmap_write(priv->slcr, SLCR_FPGA_RST_CTRL_OFFSET,\r\nFPGA_RST_ALL_MASK);\r\nregmap_write(priv->slcr, SLCR_LVL_SHFTR_EN_OFFSET,\r\nLVL_SHFTR_DISABLE_ALL_MASK);\r\nregmap_write(priv->slcr, SLCR_LVL_SHFTR_EN_OFFSET,\r\nLVL_SHFTR_ENABLE_PS_TO_PL);\r\nctrl = zynq_fpga_read(priv, CTRL_OFFSET);\r\nctrl |= CTRL_PCFG_PROG_B_MASK;\r\nzynq_fpga_write(priv, CTRL_OFFSET, ctrl);\r\nerr = zynq_fpga_poll_timeout(priv, STATUS_OFFSET, status,\r\nstatus & STATUS_PCFG_INIT_MASK,\r\nINIT_POLL_DELAY,\r\nINIT_POLL_TIMEOUT);\r\nif (err) {\r\ndev_err(&mgr->dev, "Timeout waiting for PCFG_INIT\n");\r\ngoto out_err;\r\n}\r\nctrl = zynq_fpga_read(priv, CTRL_OFFSET);\r\nctrl &= ~CTRL_PCFG_PROG_B_MASK;\r\nzynq_fpga_write(priv, CTRL_OFFSET, ctrl);\r\nerr = zynq_fpga_poll_timeout(priv, STATUS_OFFSET, status,\r\n!(status & STATUS_PCFG_INIT_MASK),\r\nINIT_POLL_DELAY,\r\nINIT_POLL_TIMEOUT);\r\nif (err) {\r\ndev_err(&mgr->dev, "Timeout waiting for !PCFG_INIT\n");\r\ngoto out_err;\r\n}\r\nctrl = zynq_fpga_read(priv, CTRL_OFFSET);\r\nctrl |= CTRL_PCFG_PROG_B_MASK;\r\nzynq_fpga_write(priv, CTRL_OFFSET, ctrl);\r\nerr = zynq_fpga_poll_timeout(priv, STATUS_OFFSET, status,\r\nstatus & STATUS_PCFG_INIT_MASK,\r\nINIT_POLL_DELAY,\r\nINIT_POLL_TIMEOUT);\r\nif (err) {\r\ndev_err(&mgr->dev, "Timeout waiting for PCFG_INIT\n");\r\ngoto out_err;\r\n}\r\n}\r\nctrl = zynq_fpga_read(priv, CTRL_OFFSET);\r\nif (info->flags & FPGA_MGR_ENCRYPTED_BITSTREAM)\r\nzynq_fpga_write(priv, CTRL_OFFSET,\r\n(CTRL_PCAP_PR_MASK | CTRL_PCAP_MODE_MASK\r\n| CTRL_PCAP_RATE_EN_MASK | ctrl));\r\nelse\r\nzynq_fpga_write(priv, CTRL_OFFSET,\r\n(CTRL_PCAP_PR_MASK | CTRL_PCAP_MODE_MASK\r\n| ctrl));\r\nstatus = zynq_fpga_read(priv, STATUS_OFFSET);\r\nif ((status & STATUS_DMA_Q_F) ||\r\n(status & STATUS_DMA_Q_E) != STATUS_DMA_Q_E) {\r\ndev_err(&mgr->dev, "DMA command queue not right\n");\r\nerr = -EBUSY;\r\ngoto out_err;\r\n}\r\nctrl = zynq_fpga_read(priv, MCTRL_OFFSET);\r\nzynq_fpga_write(priv, MCTRL_OFFSET, (~MCTRL_PCAP_LPBK_MASK & ctrl));\r\nclk_disable(priv->clk);\r\nreturn 0;\r\nout_err:\r\nclk_disable(priv->clk);\r\nreturn err;\r\n}\r\nstatic int zynq_fpga_ops_write(struct fpga_manager *mgr, struct sg_table *sgt)\r\n{\r\nstruct zynq_fpga_priv *priv;\r\nconst char *why;\r\nint err;\r\nu32 intr_status;\r\nunsigned long timeout;\r\nunsigned long flags;\r\nstruct scatterlist *sg;\r\nint i;\r\npriv = mgr->priv;\r\nfor_each_sg(sgt->sgl, sg, sgt->nents, i) {\r\nif ((sg->offset % 8) || (sg->length % 4)) {\r\ndev_err(&mgr->dev,\r\n"Invalid bitstream, chunks must be aligned\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\npriv->dma_nelms =\r\ndma_map_sg(mgr->dev.parent, sgt->sgl, sgt->nents, DMA_TO_DEVICE);\r\nif (priv->dma_nelms == 0) {\r\ndev_err(&mgr->dev, "Unable to DMA map (TO_DEVICE)\n");\r\nreturn -ENOMEM;\r\n}\r\nerr = clk_enable(priv->clk);\r\nif (err)\r\ngoto out_free;\r\nzynq_fpga_write(priv, INT_STS_OFFSET, IXR_ALL_MASK);\r\nreinit_completion(&priv->dma_done);\r\nspin_lock_irqsave(&priv->dma_lock, flags);\r\npriv->dma_elm = 0;\r\npriv->cur_sg = sgt->sgl;\r\nzynq_step_dma(priv);\r\nspin_unlock_irqrestore(&priv->dma_lock, flags);\r\ntimeout = wait_for_completion_timeout(&priv->dma_done,\r\nmsecs_to_jiffies(DMA_TIMEOUT_MS));\r\nspin_lock_irqsave(&priv->dma_lock, flags);\r\nzynq_fpga_set_irq(priv, 0);\r\npriv->cur_sg = NULL;\r\nspin_unlock_irqrestore(&priv->dma_lock, flags);\r\nintr_status = zynq_fpga_read(priv, INT_STS_OFFSET);\r\nzynq_fpga_write(priv, INT_STS_OFFSET, IXR_ALL_MASK);\r\nif (intr_status & IXR_ERROR_FLAGS_MASK) {\r\nwhy = "DMA reported error";\r\nerr = -EIO;\r\ngoto out_report;\r\n}\r\nif (priv->cur_sg ||\r\n!((intr_status & IXR_D_P_DONE_MASK) == IXR_D_P_DONE_MASK)) {\r\nif (timeout == 0)\r\nwhy = "DMA timed out";\r\nelse\r\nwhy = "DMA did not complete";\r\nerr = -EIO;\r\ngoto out_report;\r\n}\r\nerr = 0;\r\ngoto out_clk;\r\nout_report:\r\ndev_err(&mgr->dev,\r\n"%s: INT_STS:0x%x CTRL:0x%x LOCK:0x%x INT_MASK:0x%x STATUS:0x%x MCTRL:0x%x\n",\r\nwhy,\r\nintr_status,\r\nzynq_fpga_read(priv, CTRL_OFFSET),\r\nzynq_fpga_read(priv, LOCK_OFFSET),\r\nzynq_fpga_read(priv, INT_MASK_OFFSET),\r\nzynq_fpga_read(priv, STATUS_OFFSET),\r\nzynq_fpga_read(priv, MCTRL_OFFSET));\r\nout_clk:\r\nclk_disable(priv->clk);\r\nout_free:\r\ndma_unmap_sg(mgr->dev.parent, sgt->sgl, sgt->nents, DMA_TO_DEVICE);\r\nreturn err;\r\n}\r\nstatic int zynq_fpga_ops_write_complete(struct fpga_manager *mgr,\r\nstruct fpga_image_info *info)\r\n{\r\nstruct zynq_fpga_priv *priv = mgr->priv;\r\nint err;\r\nu32 intr_status;\r\nerr = clk_enable(priv->clk);\r\nif (err)\r\nreturn err;\r\nerr = zynq_fpga_poll_timeout(priv, INT_STS_OFFSET, intr_status,\r\nintr_status & IXR_PCFG_DONE_MASK,\r\nINIT_POLL_DELAY,\r\nINIT_POLL_TIMEOUT);\r\nclk_disable(priv->clk);\r\nif (err)\r\nreturn err;\r\nif (!(info->flags & FPGA_MGR_PARTIAL_RECONFIG)) {\r\nregmap_write(priv->slcr, SLCR_LVL_SHFTR_EN_OFFSET,\r\nLVL_SHFTR_ENABLE_PL_TO_PS);\r\nregmap_write(priv->slcr, SLCR_FPGA_RST_CTRL_OFFSET,\r\nFPGA_RST_NONE_MASK);\r\n}\r\nreturn 0;\r\n}\r\nstatic enum fpga_mgr_states zynq_fpga_ops_state(struct fpga_manager *mgr)\r\n{\r\nint err;\r\nu32 intr_status;\r\nstruct zynq_fpga_priv *priv;\r\npriv = mgr->priv;\r\nerr = clk_enable(priv->clk);\r\nif (err)\r\nreturn FPGA_MGR_STATE_UNKNOWN;\r\nintr_status = zynq_fpga_read(priv, INT_STS_OFFSET);\r\nclk_disable(priv->clk);\r\nif (intr_status & IXR_PCFG_DONE_MASK)\r\nreturn FPGA_MGR_STATE_OPERATING;\r\nreturn FPGA_MGR_STATE_UNKNOWN;\r\n}\r\nstatic int zynq_fpga_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct zynq_fpga_priv *priv;\r\nstruct resource *res;\r\nint err;\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nspin_lock_init(&priv->dma_lock);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npriv->io_base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(priv->io_base))\r\nreturn PTR_ERR(priv->io_base);\r\npriv->slcr = syscon_regmap_lookup_by_phandle(dev->of_node,\r\n"syscon");\r\nif (IS_ERR(priv->slcr)) {\r\ndev_err(dev, "unable to get zynq-slcr regmap\n");\r\nreturn PTR_ERR(priv->slcr);\r\n}\r\ninit_completion(&priv->dma_done);\r\npriv->irq = platform_get_irq(pdev, 0);\r\nif (priv->irq < 0) {\r\ndev_err(dev, "No IRQ available\n");\r\nreturn priv->irq;\r\n}\r\npriv->clk = devm_clk_get(dev, "ref_clk");\r\nif (IS_ERR(priv->clk)) {\r\ndev_err(dev, "input clock not found\n");\r\nreturn PTR_ERR(priv->clk);\r\n}\r\nerr = clk_prepare_enable(priv->clk);\r\nif (err) {\r\ndev_err(dev, "unable to enable clock\n");\r\nreturn err;\r\n}\r\nzynq_fpga_write(priv, UNLOCK_OFFSET, UNLOCK_MASK);\r\nzynq_fpga_set_irq(priv, 0);\r\nzynq_fpga_write(priv, INT_STS_OFFSET, IXR_ALL_MASK);\r\nerr = devm_request_irq(dev, priv->irq, zynq_fpga_isr, 0, dev_name(dev),\r\npriv);\r\nif (err) {\r\ndev_err(dev, "unable to request IRQ\n");\r\nclk_disable_unprepare(priv->clk);\r\nreturn err;\r\n}\r\nclk_disable(priv->clk);\r\nerr = fpga_mgr_register(dev, "Xilinx Zynq FPGA Manager",\r\n&zynq_fpga_ops, priv);\r\nif (err) {\r\ndev_err(dev, "unable to register FPGA manager\n");\r\nclk_unprepare(priv->clk);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int zynq_fpga_remove(struct platform_device *pdev)\r\n{\r\nstruct zynq_fpga_priv *priv;\r\nstruct fpga_manager *mgr;\r\nmgr = platform_get_drvdata(pdev);\r\npriv = mgr->priv;\r\nfpga_mgr_unregister(&pdev->dev);\r\nclk_unprepare(priv->clk);\r\nreturn 0;\r\n}
