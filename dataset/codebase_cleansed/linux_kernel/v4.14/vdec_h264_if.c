static unsigned int get_mv_buf_size(unsigned int width, unsigned int height)\r\n{\r\nreturn HW_MB_STORE_SZ * (width/MB_UNIT_LEN) * (height/MB_UNIT_LEN);\r\n}\r\nstatic int allocate_predication_buf(struct vdec_h264_inst *inst)\r\n{\r\nint err = 0;\r\ninst->pred_buf.size = BUF_PREDICTION_SZ;\r\nerr = mtk_vcodec_mem_alloc(inst->ctx, &inst->pred_buf);\r\nif (err) {\r\nmtk_vcodec_err(inst, "failed to allocate ppl buf");\r\nreturn err;\r\n}\r\ninst->vsi->pred_buf_dma = inst->pred_buf.dma_addr;\r\nreturn 0;\r\n}\r\nstatic void free_predication_buf(struct vdec_h264_inst *inst)\r\n{\r\nstruct mtk_vcodec_mem *mem = NULL;\r\nmtk_vcodec_debug_enter(inst);\r\ninst->vsi->pred_buf_dma = 0;\r\nmem = &inst->pred_buf;\r\nif (mem->va)\r\nmtk_vcodec_mem_free(inst->ctx, mem);\r\n}\r\nstatic int alloc_mv_buf(struct vdec_h264_inst *inst, struct vdec_pic_info *pic)\r\n{\r\nint i;\r\nint err;\r\nstruct mtk_vcodec_mem *mem = NULL;\r\nunsigned int buf_sz = get_mv_buf_size(pic->buf_w, pic->buf_h);\r\nfor (i = 0; i < H264_MAX_FB_NUM; i++) {\r\nmem = &inst->mv_buf[i];\r\nif (mem->va)\r\nmtk_vcodec_mem_free(inst->ctx, mem);\r\nmem->size = buf_sz;\r\nerr = mtk_vcodec_mem_alloc(inst->ctx, mem);\r\nif (err) {\r\nmtk_vcodec_err(inst, "failed to allocate mv buf");\r\nreturn err;\r\n}\r\ninst->vsi->mv_buf_dma[i] = mem->dma_addr;\r\n}\r\nreturn 0;\r\n}\r\nstatic void free_mv_buf(struct vdec_h264_inst *inst)\r\n{\r\nint i;\r\nstruct mtk_vcodec_mem *mem = NULL;\r\nfor (i = 0; i < H264_MAX_FB_NUM; i++) {\r\ninst->vsi->mv_buf_dma[i] = 0;\r\nmem = &inst->mv_buf[i];\r\nif (mem->va)\r\nmtk_vcodec_mem_free(inst->ctx, mem);\r\n}\r\n}\r\nstatic int check_list_validity(struct vdec_h264_inst *inst, bool disp_list)\r\n{\r\nstruct h264_ring_fb_list *list;\r\nlist = disp_list ? &inst->vsi->list_disp : &inst->vsi->list_free;\r\nif (list->count > H264_MAX_FB_NUM ||\r\nlist->read_idx >= H264_MAX_FB_NUM ||\r\nlist->write_idx >= H264_MAX_FB_NUM) {\r\nmtk_vcodec_err(inst, "%s list err: cnt=%d r_idx=%d w_idx=%d",\r\ndisp_list ? "disp" : "free", list->count,\r\nlist->read_idx, list->write_idx);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void put_fb_to_free(struct vdec_h264_inst *inst, struct vdec_fb *fb)\r\n{\r\nstruct h264_ring_fb_list *list;\r\nif (fb) {\r\nif (check_list_validity(inst, false))\r\nreturn;\r\nlist = &inst->vsi->list_free;\r\nif (list->count == H264_MAX_FB_NUM) {\r\nmtk_vcodec_err(inst, "[FB] put fb free_list full");\r\nreturn;\r\n}\r\nmtk_vcodec_debug(inst, "[FB] put fb into free_list @(%p, %llx)",\r\nfb->base_y.va, (u64)fb->base_y.dma_addr);\r\nlist->fb_list[list->write_idx].vdec_fb_va = (u64)(uintptr_t)fb;\r\nlist->write_idx = (list->write_idx == H264_MAX_FB_NUM - 1) ?\r\n0 : list->write_idx + 1;\r\nlist->count++;\r\n}\r\n}\r\nstatic void get_pic_info(struct vdec_h264_inst *inst,\r\nstruct vdec_pic_info *pic)\r\n{\r\n*pic = inst->vsi->pic;\r\nmtk_vcodec_debug(inst, "pic(%d, %d), buf(%d, %d)",\r\npic->pic_w, pic->pic_h, pic->buf_w, pic->buf_h);\r\nmtk_vcodec_debug(inst, "Y(%d, %d), C(%d, %d)", pic->y_bs_sz,\r\npic->y_len_sz, pic->c_bs_sz, pic->c_len_sz);\r\n}\r\nstatic void get_crop_info(struct vdec_h264_inst *inst, struct v4l2_rect *cr)\r\n{\r\ncr->left = inst->vsi->crop.left;\r\ncr->top = inst->vsi->crop.top;\r\ncr->width = inst->vsi->crop.width;\r\ncr->height = inst->vsi->crop.height;\r\nmtk_vcodec_debug(inst, "l=%d, t=%d, w=%d, h=%d",\r\ncr->left, cr->top, cr->width, cr->height);\r\n}\r\nstatic void get_dpb_size(struct vdec_h264_inst *inst, unsigned int *dpb_sz)\r\n{\r\n*dpb_sz = inst->vsi->dec.dpb_sz;\r\nmtk_vcodec_debug(inst, "sz=%d", *dpb_sz);\r\n}\r\nstatic int vdec_h264_init(struct mtk_vcodec_ctx *ctx, unsigned long *h_vdec)\r\n{\r\nstruct vdec_h264_inst *inst = NULL;\r\nint err;\r\ninst = kzalloc(sizeof(*inst), GFP_KERNEL);\r\nif (!inst)\r\nreturn -ENOMEM;\r\ninst->ctx = ctx;\r\ninst->vpu.id = IPI_VDEC_H264;\r\ninst->vpu.dev = ctx->dev->vpu_plat_dev;\r\ninst->vpu.ctx = ctx;\r\ninst->vpu.handler = vpu_dec_ipi_handler;\r\nerr = vpu_dec_init(&inst->vpu);\r\nif (err) {\r\nmtk_vcodec_err(inst, "vdec_h264 init err=%d", err);\r\ngoto error_free_inst;\r\n}\r\ninst->vsi = (struct vdec_h264_vsi *)inst->vpu.vsi;\r\nerr = allocate_predication_buf(inst);\r\nif (err)\r\ngoto error_deinit;\r\nmtk_vcodec_debug(inst, "H264 Instance >> %p", inst);\r\n*h_vdec = (unsigned long)inst;\r\nreturn 0;\r\nerror_deinit:\r\nvpu_dec_deinit(&inst->vpu);\r\nerror_free_inst:\r\nkfree(inst);\r\nreturn err;\r\n}\r\nstatic void vdec_h264_deinit(unsigned long h_vdec)\r\n{\r\nstruct vdec_h264_inst *inst = (struct vdec_h264_inst *)h_vdec;\r\nmtk_vcodec_debug_enter(inst);\r\nvpu_dec_deinit(&inst->vpu);\r\nfree_predication_buf(inst);\r\nfree_mv_buf(inst);\r\nkfree(inst);\r\n}\r\nstatic int find_start_code(unsigned char *data, unsigned int data_sz)\r\n{\r\nif (data_sz > 3 && data[0] == 0 && data[1] == 0 && data[2] == 1)\r\nreturn 3;\r\nif (data_sz > 4 && data[0] == 0 && data[1] == 0 && data[2] == 0 &&\r\ndata[3] == 1)\r\nreturn 4;\r\nreturn -1;\r\n}\r\nstatic int vdec_h264_decode(unsigned long h_vdec, struct mtk_vcodec_mem *bs,\r\nstruct vdec_fb *fb, bool *res_chg)\r\n{\r\nstruct vdec_h264_inst *inst = (struct vdec_h264_inst *)h_vdec;\r\nstruct vdec_vpu_inst *vpu = &inst->vpu;\r\nint nal_start_idx = 0;\r\nint err = 0;\r\nunsigned int nal_start;\r\nunsigned int nal_type;\r\nunsigned char *buf;\r\nunsigned int buf_sz;\r\nunsigned int data[2];\r\nuint64_t vdec_fb_va = (u64)(uintptr_t)fb;\r\nuint64_t y_fb_dma = fb ? (u64)fb->base_y.dma_addr : 0;\r\nuint64_t c_fb_dma = fb ? (u64)fb->base_c.dma_addr : 0;\r\nmtk_vcodec_debug(inst, "+ [%d] FB y_dma=%llx c_dma=%llx va=%p",\r\n++inst->num_nalu, y_fb_dma, c_fb_dma, fb);\r\nif (bs == NULL)\r\nreturn vpu_dec_reset(vpu);\r\nbuf = (unsigned char *)bs->va;\r\nbuf_sz = bs->size;\r\nnal_start_idx = find_start_code(buf, buf_sz);\r\nif (nal_start_idx < 0)\r\ngoto err_free_fb_out;\r\nnal_start = buf[nal_start_idx];\r\nnal_type = NAL_TYPE(buf[nal_start_idx]);\r\nmtk_vcodec_debug(inst, "\n + NALU[%d] type %d +\n", inst->num_nalu,\r\nnal_type);\r\nif (nal_type == NAL_H264_PPS) {\r\nbuf_sz -= nal_start_idx;\r\nif (buf_sz > HDR_PARSING_BUF_SZ) {\r\nerr = -EILSEQ;\r\ngoto err_free_fb_out;\r\n}\r\nmemcpy(inst->vsi->hdr_buf, buf + nal_start_idx, buf_sz);\r\n}\r\ninst->vsi->dec.bs_dma = (uint64_t)bs->dma_addr;\r\ninst->vsi->dec.y_fb_dma = y_fb_dma;\r\ninst->vsi->dec.c_fb_dma = c_fb_dma;\r\ninst->vsi->dec.vdec_fb_va = vdec_fb_va;\r\ndata[0] = buf_sz;\r\ndata[1] = nal_start;\r\nerr = vpu_dec_start(vpu, data, 2);\r\nif (err)\r\ngoto err_free_fb_out;\r\n*res_chg = inst->vsi->dec.resolution_changed;\r\nif (*res_chg) {\r\nstruct vdec_pic_info pic;\r\nmtk_vcodec_debug(inst, "- resolution changed -");\r\nget_pic_info(inst, &pic);\r\nif (inst->vsi->dec.realloc_mv_buf) {\r\nerr = alloc_mv_buf(inst, &pic);\r\nif (err)\r\ngoto err_free_fb_out;\r\n}\r\n}\r\nif (nal_type == NAL_NON_IDR_SLICE || nal_type == NAL_IDR_SLICE) {\r\nerr = mtk_vcodec_wait_for_done_ctx(inst->ctx,\r\nMTK_INST_IRQ_RECEIVED,\r\nWAIT_INTR_TIMEOUT_MS);\r\nif (err)\r\ngoto err_free_fb_out;\r\nvpu_dec_end(vpu);\r\n}\r\nmtk_vcodec_debug(inst, "\n - NALU[%d] type=%d -\n", inst->num_nalu,\r\nnal_type);\r\nreturn 0;\r\nerr_free_fb_out:\r\nput_fb_to_free(inst, fb);\r\nmtk_vcodec_err(inst, "\n - NALU[%d] err=%d -\n", inst->num_nalu, err);\r\nreturn err;\r\n}\r\nstatic void vdec_h264_get_fb(struct vdec_h264_inst *inst,\r\nstruct h264_ring_fb_list *list,\r\nbool disp_list, struct vdec_fb **out_fb)\r\n{\r\nstruct vdec_fb *fb;\r\nif (check_list_validity(inst, disp_list))\r\nreturn;\r\nif (list->count == 0) {\r\nmtk_vcodec_debug(inst, "[FB] there is no %s fb",\r\ndisp_list ? "disp" : "free");\r\n*out_fb = NULL;\r\nreturn;\r\n}\r\nfb = (struct vdec_fb *)\r\n(uintptr_t)list->fb_list[list->read_idx].vdec_fb_va;\r\nfb->status |= (disp_list ? FB_ST_DISPLAY : FB_ST_FREE);\r\n*out_fb = fb;\r\nmtk_vcodec_debug(inst, "[FB] get %s fb st=%d poc=%d %llx",\r\ndisp_list ? "disp" : "free",\r\nfb->status, list->fb_list[list->read_idx].poc,\r\nlist->fb_list[list->read_idx].vdec_fb_va);\r\nlist->read_idx = (list->read_idx == H264_MAX_FB_NUM - 1) ?\r\n0 : list->read_idx + 1;\r\nlist->count--;\r\n}\r\nstatic int vdec_h264_get_param(unsigned long h_vdec,\r\nenum vdec_get_param_type type, void *out)\r\n{\r\nstruct vdec_h264_inst *inst = (struct vdec_h264_inst *)h_vdec;\r\nswitch (type) {\r\ncase GET_PARAM_DISP_FRAME_BUFFER:\r\nvdec_h264_get_fb(inst, &inst->vsi->list_disp, true, out);\r\nbreak;\r\ncase GET_PARAM_FREE_FRAME_BUFFER:\r\nvdec_h264_get_fb(inst, &inst->vsi->list_free, false, out);\r\nbreak;\r\ncase GET_PARAM_PIC_INFO:\r\nget_pic_info(inst, out);\r\nbreak;\r\ncase GET_PARAM_DPB_SIZE:\r\nget_dpb_size(inst, out);\r\nbreak;\r\ncase GET_PARAM_CROP_INFO:\r\nget_crop_info(inst, out);\r\nbreak;\r\ndefault:\r\nmtk_vcodec_err(inst, "invalid get parameter type=%d", type);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstruct vdec_common_if *get_h264_dec_comm_if(void)\r\n{\r\nreturn &vdec_h264_if;\r\n}
