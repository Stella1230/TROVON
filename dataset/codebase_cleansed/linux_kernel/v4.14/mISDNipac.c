static inline void\r\nph_command(struct isac_hw *isac, u8 command)\r\n{\r\npr_debug("%s: ph_command %x\n", isac->name, command);\r\nif (isac->type & IPAC_TYPE_ISACX)\r\nWriteISAC(isac, ISACX_CIX0, (command << 4) | 0xE);\r\nelse\r\nWriteISAC(isac, ISAC_CIX0, (command << 2) | 3);\r\n}\r\nstatic void\r\nisac_ph_state_change(struct isac_hw *isac)\r\n{\r\nswitch (isac->state) {\r\ncase (ISAC_IND_RS):\r\ncase (ISAC_IND_EI):\r\nph_command(isac, ISAC_CMD_DUI);\r\n}\r\nschedule_event(&isac->dch, FLG_PHCHANGE);\r\n}\r\nstatic void\r\nisac_ph_state_bh(struct dchannel *dch)\r\n{\r\nstruct isac_hw *isac = container_of(dch, struct isac_hw, dch);\r\nswitch (isac->state) {\r\ncase ISAC_IND_RS:\r\ncase ISAC_IND_EI:\r\ndch->state = 0;\r\nl1_event(dch->l1, HW_RESET_IND);\r\nbreak;\r\ncase ISAC_IND_DID:\r\ndch->state = 3;\r\nl1_event(dch->l1, HW_DEACT_CNF);\r\nbreak;\r\ncase ISAC_IND_DR:\r\ncase ISAC_IND_DR6:\r\ndch->state = 3;\r\nl1_event(dch->l1, HW_DEACT_IND);\r\nbreak;\r\ncase ISAC_IND_PU:\r\ndch->state = 4;\r\nl1_event(dch->l1, HW_POWERUP_IND);\r\nbreak;\r\ncase ISAC_IND_RSY:\r\nif (dch->state <= 5) {\r\ndch->state = 5;\r\nl1_event(dch->l1, ANYSIGNAL);\r\n} else {\r\ndch->state = 8;\r\nl1_event(dch->l1, LOSTFRAMING);\r\n}\r\nbreak;\r\ncase ISAC_IND_ARD:\r\ndch->state = 6;\r\nl1_event(dch->l1, INFO2);\r\nbreak;\r\ncase ISAC_IND_AI8:\r\ndch->state = 7;\r\nl1_event(dch->l1, INFO4_P8);\r\nbreak;\r\ncase ISAC_IND_AI10:\r\ndch->state = 7;\r\nl1_event(dch->l1, INFO4_P10);\r\nbreak;\r\n}\r\npr_debug("%s: TE newstate %x\n", isac->name, dch->state);\r\n}\r\nstatic void\r\nisac_empty_fifo(struct isac_hw *isac, int count)\r\n{\r\nu8 *ptr;\r\npr_debug("%s: %s %d\n", isac->name, __func__, count);\r\nif (!isac->dch.rx_skb) {\r\nisac->dch.rx_skb = mI_alloc_skb(isac->dch.maxlen, GFP_ATOMIC);\r\nif (!isac->dch.rx_skb) {\r\npr_info("%s: D receive out of memory\n", isac->name);\r\nWriteISAC(isac, ISAC_CMDR, 0x80);\r\nreturn;\r\n}\r\n}\r\nif ((isac->dch.rx_skb->len + count) >= isac->dch.maxlen) {\r\npr_debug("%s: %s overrun %d\n", isac->name, __func__,\r\nisac->dch.rx_skb->len + count);\r\nWriteISAC(isac, ISAC_CMDR, 0x80);\r\nreturn;\r\n}\r\nptr = skb_put(isac->dch.rx_skb, count);\r\nisac->read_fifo(isac->dch.hw, isac->off, ptr, count);\r\nWriteISAC(isac, ISAC_CMDR, 0x80);\r\nif (isac->dch.debug & DEBUG_HW_DFIFO) {\r\nchar pfx[MISDN_MAX_IDLEN + 16];\r\nsnprintf(pfx, MISDN_MAX_IDLEN + 15, "D-recv %s %d ",\r\nisac->name, count);\r\nprint_hex_dump_bytes(pfx, DUMP_PREFIX_OFFSET, ptr, count);\r\n}\r\n}\r\nstatic void\r\nisac_fill_fifo(struct isac_hw *isac)\r\n{\r\nint count, more;\r\nu8 *ptr;\r\nif (!isac->dch.tx_skb)\r\nreturn;\r\ncount = isac->dch.tx_skb->len - isac->dch.tx_idx;\r\nif (count <= 0)\r\nreturn;\r\nmore = 0;\r\nif (count > 32) {\r\nmore = !0;\r\ncount = 32;\r\n}\r\npr_debug("%s: %s %d\n", isac->name, __func__, count);\r\nptr = isac->dch.tx_skb->data + isac->dch.tx_idx;\r\nisac->dch.tx_idx += count;\r\nisac->write_fifo(isac->dch.hw, isac->off, ptr, count);\r\nWriteISAC(isac, ISAC_CMDR, more ? 0x8 : 0xa);\r\nif (test_and_set_bit(FLG_BUSY_TIMER, &isac->dch.Flags)) {\r\npr_debug("%s: %s dbusytimer running\n", isac->name, __func__);\r\ndel_timer(&isac->dch.timer);\r\n}\r\ninit_timer(&isac->dch.timer);\r\nisac->dch.timer.expires = jiffies + ((DBUSY_TIMER_VALUE * HZ)/1000);\r\nadd_timer(&isac->dch.timer);\r\nif (isac->dch.debug & DEBUG_HW_DFIFO) {\r\nchar pfx[MISDN_MAX_IDLEN + 16];\r\nsnprintf(pfx, MISDN_MAX_IDLEN + 15, "D-send %s %d ",\r\nisac->name, count);\r\nprint_hex_dump_bytes(pfx, DUMP_PREFIX_OFFSET, ptr, count);\r\n}\r\n}\r\nstatic void\r\nisac_rme_irq(struct isac_hw *isac)\r\n{\r\nu8 val, count;\r\nval = ReadISAC(isac, ISAC_RSTA);\r\nif ((val & 0x70) != 0x20) {\r\nif (val & 0x40) {\r\npr_debug("%s: ISAC RDO\n", isac->name);\r\n#ifdef ERROR_STATISTIC\r\nisac->dch.err_rx++;\r\n#endif\r\n}\r\nif (!(val & 0x20)) {\r\npr_debug("%s: ISAC CRC error\n", isac->name);\r\n#ifdef ERROR_STATISTIC\r\nisac->dch.err_crc++;\r\n#endif\r\n}\r\nWriteISAC(isac, ISAC_CMDR, 0x80);\r\nif (isac->dch.rx_skb)\r\ndev_kfree_skb(isac->dch.rx_skb);\r\nisac->dch.rx_skb = NULL;\r\n} else {\r\ncount = ReadISAC(isac, ISAC_RBCL) & 0x1f;\r\nif (count == 0)\r\ncount = 32;\r\nisac_empty_fifo(isac, count);\r\nrecv_Dchannel(&isac->dch);\r\n}\r\n}\r\nstatic void\r\nisac_xpr_irq(struct isac_hw *isac)\r\n{\r\nif (test_and_clear_bit(FLG_BUSY_TIMER, &isac->dch.Flags))\r\ndel_timer(&isac->dch.timer);\r\nif (isac->dch.tx_skb && isac->dch.tx_idx < isac->dch.tx_skb->len) {\r\nisac_fill_fifo(isac);\r\n} else {\r\nif (isac->dch.tx_skb)\r\ndev_kfree_skb(isac->dch.tx_skb);\r\nif (get_next_dframe(&isac->dch))\r\nisac_fill_fifo(isac);\r\n}\r\n}\r\nstatic void\r\nisac_retransmit(struct isac_hw *isac)\r\n{\r\nif (test_and_clear_bit(FLG_BUSY_TIMER, &isac->dch.Flags))\r\ndel_timer(&isac->dch.timer);\r\nif (test_bit(FLG_TX_BUSY, &isac->dch.Flags)) {\r\nisac->dch.tx_idx = 0;\r\nisac_fill_fifo(isac);\r\n} else if (isac->dch.tx_skb) {\r\npr_info("%s: tx_skb exist but not busy\n", isac->name);\r\ntest_and_set_bit(FLG_TX_BUSY, &isac->dch.Flags);\r\nisac->dch.tx_idx = 0;\r\nisac_fill_fifo(isac);\r\n} else {\r\npr_info("%s: ISAC XDU no TX_BUSY\n", isac->name);\r\nif (get_next_dframe(&isac->dch))\r\nisac_fill_fifo(isac);\r\n}\r\n}\r\nstatic void\r\nisac_mos_irq(struct isac_hw *isac)\r\n{\r\nu8 val;\r\nint ret;\r\nval = ReadISAC(isac, ISAC_MOSR);\r\npr_debug("%s: ISAC MOSR %02x\n", isac->name, val);\r\n#if ARCOFI_USE\r\nif (val & 0x08) {\r\nif (!isac->mon_rx) {\r\nisac->mon_rx = kmalloc(MAX_MON_FRAME, GFP_ATOMIC);\r\nif (!isac->mon_rx) {\r\npr_info("%s: ISAC MON RX out of memory!\n",\r\nisac->name);\r\nisac->mocr &= 0xf0;\r\nisac->mocr |= 0x0a;\r\nWriteISAC(isac, ISAC_MOCR, isac->mocr);\r\ngoto afterMONR0;\r\n} else\r\nisac->mon_rxp = 0;\r\n}\r\nif (isac->mon_rxp >= MAX_MON_FRAME) {\r\nisac->mocr &= 0xf0;\r\nisac->mocr |= 0x0a;\r\nWriteISAC(isac, ISAC_MOCR, isac->mocr);\r\nisac->mon_rxp = 0;\r\npr_debug("%s: ISAC MON RX overflow!\n", isac->name);\r\ngoto afterMONR0;\r\n}\r\nisac->mon_rx[isac->mon_rxp++] = ReadISAC(isac, ISAC_MOR0);\r\npr_debug("%s: ISAC MOR0 %02x\n", isac->name,\r\nisac->mon_rx[isac->mon_rxp - 1]);\r\nif (isac->mon_rxp == 1) {\r\nisac->mocr |= 0x04;\r\nWriteISAC(isac, ISAC_MOCR, isac->mocr);\r\n}\r\n}\r\nafterMONR0:\r\nif (val & 0x80) {\r\nif (!isac->mon_rx) {\r\nisac->mon_rx = kmalloc(MAX_MON_FRAME, GFP_ATOMIC);\r\nif (!isac->mon_rx) {\r\npr_info("%s: ISAC MON RX out of memory!\n",\r\nisac->name);\r\nisac->mocr &= 0x0f;\r\nisac->mocr |= 0xa0;\r\nWriteISAC(isac, ISAC_MOCR, isac->mocr);\r\ngoto afterMONR1;\r\n} else\r\nisac->mon_rxp = 0;\r\n}\r\nif (isac->mon_rxp >= MAX_MON_FRAME) {\r\nisac->mocr &= 0x0f;\r\nisac->mocr |= 0xa0;\r\nWriteISAC(isac, ISAC_MOCR, isac->mocr);\r\nisac->mon_rxp = 0;\r\npr_debug("%s: ISAC MON RX overflow!\n", isac->name);\r\ngoto afterMONR1;\r\n}\r\nisac->mon_rx[isac->mon_rxp++] = ReadISAC(isac, ISAC_MOR1);\r\npr_debug("%s: ISAC MOR1 %02x\n", isac->name,\r\nisac->mon_rx[isac->mon_rxp - 1]);\r\nisac->mocr |= 0x40;\r\nWriteISAC(isac, ISAC_MOCR, isac->mocr);\r\n}\r\nafterMONR1:\r\nif (val & 0x04) {\r\nisac->mocr &= 0xf0;\r\nWriteISAC(isac, ISAC_MOCR, isac->mocr);\r\nisac->mocr |= 0x0a;\r\nWriteISAC(isac, ISAC_MOCR, isac->mocr);\r\nif (isac->monitor) {\r\nret = isac->monitor(isac->dch.hw, MONITOR_RX_0,\r\nisac->mon_rx, isac->mon_rxp);\r\nif (ret)\r\nkfree(isac->mon_rx);\r\n} else {\r\npr_info("%s: MONITOR 0 received %d but no user\n",\r\nisac->name, isac->mon_rxp);\r\nkfree(isac->mon_rx);\r\n}\r\nisac->mon_rx = NULL;\r\nisac->mon_rxp = 0;\r\n}\r\nif (val & 0x40) {\r\nisac->mocr &= 0x0f;\r\nWriteISAC(isac, ISAC_MOCR, isac->mocr);\r\nisac->mocr |= 0xa0;\r\nWriteISAC(isac, ISAC_MOCR, isac->mocr);\r\nif (isac->monitor) {\r\nret = isac->monitor(isac->dch.hw, MONITOR_RX_1,\r\nisac->mon_rx, isac->mon_rxp);\r\nif (ret)\r\nkfree(isac->mon_rx);\r\n} else {\r\npr_info("%s: MONITOR 1 received %d but no user\n",\r\nisac->name, isac->mon_rxp);\r\nkfree(isac->mon_rx);\r\n}\r\nisac->mon_rx = NULL;\r\nisac->mon_rxp = 0;\r\n}\r\nif (val & 0x02) {\r\nif ((!isac->mon_tx) || (isac->mon_txc &&\r\n(isac->mon_txp >= isac->mon_txc) && !(val & 0x08))) {\r\nisac->mocr &= 0xf0;\r\nWriteISAC(isac, ISAC_MOCR, isac->mocr);\r\nisac->mocr |= 0x0a;\r\nWriteISAC(isac, ISAC_MOCR, isac->mocr);\r\nif (isac->mon_txc && (isac->mon_txp >= isac->mon_txc)) {\r\nif (isac->monitor)\r\nisac->monitor(isac->dch.hw,\r\nMONITOR_TX_0, NULL, 0);\r\n}\r\nkfree(isac->mon_tx);\r\nisac->mon_tx = NULL;\r\nisac->mon_txc = 0;\r\nisac->mon_txp = 0;\r\ngoto AfterMOX0;\r\n}\r\nif (isac->mon_txc && (isac->mon_txp >= isac->mon_txc)) {\r\nif (isac->monitor)\r\nisac->monitor(isac->dch.hw,\r\nMONITOR_TX_0, NULL, 0);\r\nkfree(isac->mon_tx);\r\nisac->mon_tx = NULL;\r\nisac->mon_txc = 0;\r\nisac->mon_txp = 0;\r\ngoto AfterMOX0;\r\n}\r\nWriteISAC(isac, ISAC_MOX0, isac->mon_tx[isac->mon_txp++]);\r\npr_debug("%s: ISAC %02x -> MOX0\n", isac->name,\r\nisac->mon_tx[isac->mon_txp - 1]);\r\n}\r\nAfterMOX0:\r\nif (val & 0x20) {\r\nif ((!isac->mon_tx) || (isac->mon_txc &&\r\n(isac->mon_txp >= isac->mon_txc) && !(val & 0x80))) {\r\nisac->mocr &= 0x0f;\r\nWriteISAC(isac, ISAC_MOCR, isac->mocr);\r\nisac->mocr |= 0xa0;\r\nWriteISAC(isac, ISAC_MOCR, isac->mocr);\r\nif (isac->mon_txc && (isac->mon_txp >= isac->mon_txc)) {\r\nif (isac->monitor)\r\nisac->monitor(isac->dch.hw,\r\nMONITOR_TX_1, NULL, 0);\r\n}\r\nkfree(isac->mon_tx);\r\nisac->mon_tx = NULL;\r\nisac->mon_txc = 0;\r\nisac->mon_txp = 0;\r\ngoto AfterMOX1;\r\n}\r\nif (isac->mon_txc && (isac->mon_txp >= isac->mon_txc)) {\r\nif (isac->monitor)\r\nisac->monitor(isac->dch.hw,\r\nMONITOR_TX_1, NULL, 0);\r\nkfree(isac->mon_tx);\r\nisac->mon_tx = NULL;\r\nisac->mon_txc = 0;\r\nisac->mon_txp = 0;\r\ngoto AfterMOX1;\r\n}\r\nWriteISAC(isac, ISAC_MOX1, isac->mon_tx[isac->mon_txp++]);\r\npr_debug("%s: ISAC %02x -> MOX1\n", isac->name,\r\nisac->mon_tx[isac->mon_txp - 1]);\r\n}\r\nAfterMOX1:\r\nval = 0;\r\n#endif\r\n}\r\nstatic void\r\nisac_cisq_irq(struct isac_hw *isac) {\r\nu8 val;\r\nval = ReadISAC(isac, ISAC_CIR0);\r\npr_debug("%s: ISAC CIR0 %02X\n", isac->name, val);\r\nif (val & 2) {\r\npr_debug("%s: ph_state change %x->%x\n", isac->name,\r\nisac->state, (val >> 2) & 0xf);\r\nisac->state = (val >> 2) & 0xf;\r\nisac_ph_state_change(isac);\r\n}\r\nif (val & 1) {\r\nval = ReadISAC(isac, ISAC_CIR1);\r\npr_debug("%s: ISAC CIR1 %02X\n", isac->name, val);\r\n}\r\n}\r\nstatic void\r\nisacsx_cic_irq(struct isac_hw *isac)\r\n{\r\nu8 val;\r\nval = ReadISAC(isac, ISACX_CIR0);\r\npr_debug("%s: ISACX CIR0 %02X\n", isac->name, val);\r\nif (val & ISACX_CIR0_CIC0) {\r\npr_debug("%s: ph_state change %x->%x\n", isac->name,\r\nisac->state, val >> 4);\r\nisac->state = val >> 4;\r\nisac_ph_state_change(isac);\r\n}\r\n}\r\nstatic void\r\nisacsx_rme_irq(struct isac_hw *isac)\r\n{\r\nint count;\r\nu8 val;\r\nval = ReadISAC(isac, ISACX_RSTAD);\r\nif ((val & (ISACX_RSTAD_VFR |\r\nISACX_RSTAD_RDO |\r\nISACX_RSTAD_CRC |\r\nISACX_RSTAD_RAB))\r\n!= (ISACX_RSTAD_VFR | ISACX_RSTAD_CRC)) {\r\npr_debug("%s: RSTAD %#x, dropped\n", isac->name, val);\r\n#ifdef ERROR_STATISTIC\r\nif (val & ISACX_RSTAD_CRC)\r\nisac->dch.err_rx++;\r\nelse\r\nisac->dch.err_crc++;\r\n#endif\r\nWriteISAC(isac, ISACX_CMDRD, ISACX_CMDRD_RMC);\r\nif (isac->dch.rx_skb)\r\ndev_kfree_skb(isac->dch.rx_skb);\r\nisac->dch.rx_skb = NULL;\r\n} else {\r\ncount = ReadISAC(isac, ISACX_RBCLD) & 0x1f;\r\nif (count == 0)\r\ncount = 32;\r\nisac_empty_fifo(isac, count);\r\nif (isac->dch.rx_skb) {\r\nskb_trim(isac->dch.rx_skb, isac->dch.rx_skb->len - 1);\r\npr_debug("%s: dchannel received %d\n", isac->name,\r\nisac->dch.rx_skb->len);\r\nrecv_Dchannel(&isac->dch);\r\n}\r\n}\r\n}\r\nirqreturn_t\r\nmISDNisac_irq(struct isac_hw *isac, u8 val)\r\n{\r\nif (unlikely(!val))\r\nreturn IRQ_NONE;\r\npr_debug("%s: ISAC interrupt %02x\n", isac->name, val);\r\nif (isac->type & IPAC_TYPE_ISACX) {\r\nif (val & ISACX__CIC)\r\nisacsx_cic_irq(isac);\r\nif (val & ISACX__ICD) {\r\nval = ReadISAC(isac, ISACX_ISTAD);\r\npr_debug("%s: ISTAD %02x\n", isac->name, val);\r\nif (val & ISACX_D_XDU) {\r\npr_debug("%s: ISAC XDU\n", isac->name);\r\n#ifdef ERROR_STATISTIC\r\nisac->dch.err_tx++;\r\n#endif\r\nisac_retransmit(isac);\r\n}\r\nif (val & ISACX_D_XMR) {\r\npr_debug("%s: ISAC XMR\n", isac->name);\r\n#ifdef ERROR_STATISTIC\r\nisac->dch.err_tx++;\r\n#endif\r\nisac_retransmit(isac);\r\n}\r\nif (val & ISACX_D_XPR)\r\nisac_xpr_irq(isac);\r\nif (val & ISACX_D_RFO) {\r\npr_debug("%s: ISAC RFO\n", isac->name);\r\nWriteISAC(isac, ISACX_CMDRD, ISACX_CMDRD_RMC);\r\n}\r\nif (val & ISACX_D_RME)\r\nisacsx_rme_irq(isac);\r\nif (val & ISACX_D_RPF)\r\nisac_empty_fifo(isac, 0x20);\r\n}\r\n} else {\r\nif (val & 0x80)\r\nisac_rme_irq(isac);\r\nif (val & 0x40)\r\nisac_empty_fifo(isac, 32);\r\nif (val & 0x10)\r\nisac_xpr_irq(isac);\r\nif (val & 0x04)\r\nisac_cisq_irq(isac);\r\nif (val & 0x20)\r\npr_debug("%s: ISAC RSC interrupt\n", isac->name);\r\nif (val & 0x02)\r\npr_debug("%s: ISAC SIN interrupt\n", isac->name);\r\nif (val & 0x01) {\r\nval = ReadISAC(isac, ISAC_EXIR);\r\npr_debug("%s: ISAC EXIR %02x\n", isac->name, val);\r\nif (val & 0x80)\r\npr_debug("%s: ISAC XMR\n", isac->name);\r\nif (val & 0x40) {\r\npr_debug("%s: ISAC XDU\n", isac->name);\r\n#ifdef ERROR_STATISTIC\r\nisac->dch.err_tx++;\r\n#endif\r\nisac_retransmit(isac);\r\n}\r\nif (val & 0x04)\r\nisac_mos_irq(isac);\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int\r\nisac_l1hw(struct mISDNchannel *ch, struct sk_buff *skb)\r\n{\r\nstruct mISDNdevice *dev = container_of(ch, struct mISDNdevice, D);\r\nstruct dchannel *dch = container_of(dev, struct dchannel, dev);\r\nstruct isac_hw *isac = container_of(dch, struct isac_hw, dch);\r\nint ret = -EINVAL;\r\nstruct mISDNhead *hh = mISDN_HEAD_P(skb);\r\nu32 id;\r\nu_long flags;\r\nswitch (hh->prim) {\r\ncase PH_DATA_REQ:\r\nspin_lock_irqsave(isac->hwlock, flags);\r\nret = dchannel_senddata(dch, skb);\r\nif (ret > 0) {\r\nid = hh->id;\r\nisac_fill_fifo(isac);\r\nret = 0;\r\nspin_unlock_irqrestore(isac->hwlock, flags);\r\nqueue_ch_frame(ch, PH_DATA_CNF, id, NULL);\r\n} else\r\nspin_unlock_irqrestore(isac->hwlock, flags);\r\nreturn ret;\r\ncase PH_ACTIVATE_REQ:\r\nret = l1_event(dch->l1, hh->prim);\r\nbreak;\r\ncase PH_DEACTIVATE_REQ:\r\ntest_and_clear_bit(FLG_L2_ACTIVATED, &dch->Flags);\r\nret = l1_event(dch->l1, hh->prim);\r\nbreak;\r\n}\r\nif (!ret)\r\ndev_kfree_skb(skb);\r\nreturn ret;\r\n}\r\nstatic int\r\nisac_ctrl(struct isac_hw *isac, u32 cmd, unsigned long para)\r\n{\r\nu8 tl = 0;\r\nunsigned long flags;\r\nint ret = 0;\r\nswitch (cmd) {\r\ncase HW_TESTLOOP:\r\nspin_lock_irqsave(isac->hwlock, flags);\r\nif (!(isac->type & IPAC_TYPE_ISACX)) {\r\nif (para & 1)\r\ntl |= 0x0c;\r\nelse if (para & 2)\r\ntl |= 0x3;\r\nWriteISAC(isac, ISAC_SPCR, tl);\r\nif (tl)\r\nWriteISAC(isac, ISAC_ADF1, 0x8);\r\nelse\r\nWriteISAC(isac, ISAC_ADF1, 0x0);\r\n}\r\nspin_unlock_irqrestore(isac->hwlock, flags);\r\nbreak;\r\ncase HW_TIMER3_VALUE:\r\nret = l1_event(isac->dch.l1, HW_TIMER3_VALUE | (para & 0xff));\r\nbreak;\r\ndefault:\r\npr_debug("%s: %s unknown command %x %lx\n", isac->name,\r\n__func__, cmd, para);\r\nret = -1;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nisac_l1cmd(struct dchannel *dch, u32 cmd)\r\n{\r\nstruct isac_hw *isac = container_of(dch, struct isac_hw, dch);\r\nu_long flags;\r\npr_debug("%s: cmd(%x) state(%02x)\n", isac->name, cmd, isac->state);\r\nswitch (cmd) {\r\ncase INFO3_P8:\r\nspin_lock_irqsave(isac->hwlock, flags);\r\nph_command(isac, ISAC_CMD_AR8);\r\nspin_unlock_irqrestore(isac->hwlock, flags);\r\nbreak;\r\ncase INFO3_P10:\r\nspin_lock_irqsave(isac->hwlock, flags);\r\nph_command(isac, ISAC_CMD_AR10);\r\nspin_unlock_irqrestore(isac->hwlock, flags);\r\nbreak;\r\ncase HW_RESET_REQ:\r\nspin_lock_irqsave(isac->hwlock, flags);\r\nif ((isac->state == ISAC_IND_EI) ||\r\n(isac->state == ISAC_IND_DR) ||\r\n(isac->state == ISAC_IND_DR6) ||\r\n(isac->state == ISAC_IND_RS))\r\nph_command(isac, ISAC_CMD_TIM);\r\nelse\r\nph_command(isac, ISAC_CMD_RS);\r\nspin_unlock_irqrestore(isac->hwlock, flags);\r\nbreak;\r\ncase HW_DEACT_REQ:\r\nskb_queue_purge(&dch->squeue);\r\nif (dch->tx_skb) {\r\ndev_kfree_skb(dch->tx_skb);\r\ndch->tx_skb = NULL;\r\n}\r\ndch->tx_idx = 0;\r\nif (dch->rx_skb) {\r\ndev_kfree_skb(dch->rx_skb);\r\ndch->rx_skb = NULL;\r\n}\r\ntest_and_clear_bit(FLG_TX_BUSY, &dch->Flags);\r\nif (test_and_clear_bit(FLG_BUSY_TIMER, &dch->Flags))\r\ndel_timer(&dch->timer);\r\nbreak;\r\ncase HW_POWERUP_REQ:\r\nspin_lock_irqsave(isac->hwlock, flags);\r\nph_command(isac, ISAC_CMD_TIM);\r\nspin_unlock_irqrestore(isac->hwlock, flags);\r\nbreak;\r\ncase PH_ACTIVATE_IND:\r\ntest_and_set_bit(FLG_ACTIVE, &dch->Flags);\r\n_queue_data(&dch->dev.D, cmd, MISDN_ID_ANY, 0, NULL,\r\nGFP_ATOMIC);\r\nbreak;\r\ncase PH_DEACTIVATE_IND:\r\ntest_and_clear_bit(FLG_ACTIVE, &dch->Flags);\r\n_queue_data(&dch->dev.D, cmd, MISDN_ID_ANY, 0, NULL,\r\nGFP_ATOMIC);\r\nbreak;\r\ndefault:\r\npr_debug("%s: %s unknown command %x\n", isac->name,\r\n__func__, cmd);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nisac_release(struct isac_hw *isac)\r\n{\r\nif (isac->type & IPAC_TYPE_ISACX)\r\nWriteISAC(isac, ISACX_MASK, 0xff);\r\nelse\r\nWriteISAC(isac, ISAC_MASK, 0xff);\r\nif (isac->dch.timer.function != NULL) {\r\ndel_timer(&isac->dch.timer);\r\nisac->dch.timer.function = NULL;\r\n}\r\nkfree(isac->mon_rx);\r\nisac->mon_rx = NULL;\r\nkfree(isac->mon_tx);\r\nisac->mon_tx = NULL;\r\nif (isac->dch.l1)\r\nl1_event(isac->dch.l1, CLOSE_CHANNEL);\r\nmISDN_freedchannel(&isac->dch);\r\n}\r\nstatic void\r\ndbusy_timer_handler(struct isac_hw *isac)\r\n{\r\nint rbch, star;\r\nu_long flags;\r\nif (test_bit(FLG_BUSY_TIMER, &isac->dch.Flags)) {\r\nspin_lock_irqsave(isac->hwlock, flags);\r\nrbch = ReadISAC(isac, ISAC_RBCH);\r\nstar = ReadISAC(isac, ISAC_STAR);\r\npr_debug("%s: D-Channel Busy RBCH %02x STAR %02x\n",\r\nisac->name, rbch, star);\r\nif (rbch & ISAC_RBCH_XAC)\r\ntest_and_set_bit(FLG_L1_BUSY, &isac->dch.Flags);\r\nelse {\r\ntest_and_clear_bit(FLG_BUSY_TIMER, &isac->dch.Flags);\r\nif (isac->dch.tx_idx)\r\nisac->dch.tx_idx = 0;\r\nelse\r\npr_info("%s: ISAC D-Channel Busy no tx_idx\n",\r\nisac->name);\r\nWriteISAC(isac, ISAC_CMDR, 0x01);\r\n}\r\nspin_unlock_irqrestore(isac->hwlock, flags);\r\n}\r\n}\r\nstatic int\r\nopen_dchannel_caller(struct isac_hw *isac, struct channel_req *rq, void *caller)\r\n{\r\npr_debug("%s: %s dev(%d) open from %p\n", isac->name, __func__,\r\nisac->dch.dev.id, caller);\r\nif (rq->protocol != ISDN_P_TE_S0)\r\nreturn -EINVAL;\r\nif (rq->adr.channel == 1)\r\nreturn -EINVAL;\r\nrq->ch = &isac->dch.dev.D;\r\nrq->ch->protocol = rq->protocol;\r\nif (isac->dch.state == 7)\r\n_queue_data(rq->ch, PH_ACTIVATE_IND, MISDN_ID_ANY,\r\n0, NULL, GFP_KERNEL);\r\nreturn 0;\r\n}\r\nstatic int\r\nopen_dchannel(struct isac_hw *isac, struct channel_req *rq)\r\n{\r\nreturn open_dchannel_caller(isac, rq, __builtin_return_address(0));\r\n}\r\nstatic int\r\nisac_init(struct isac_hw *isac)\r\n{\r\nu8 val;\r\nint err = 0;\r\nif (!isac->dch.l1) {\r\nerr = create_l1(&isac->dch, isac_l1cmd);\r\nif (err)\r\nreturn err;\r\n}\r\nisac->mon_tx = NULL;\r\nisac->mon_rx = NULL;\r\nsetup_timer(&isac->dch.timer, (void *)dbusy_timer_handler,\r\n(long)isac);\r\nisac->mocr = 0xaa;\r\nif (isac->type & IPAC_TYPE_ISACX) {\r\nWriteISAC(isac, ISACX_MASK, 0xff);\r\nval = ReadISAC(isac, ISACX_STARD);\r\npr_debug("%s: ISACX STARD %x\n", isac->name, val);\r\nval = ReadISAC(isac, ISACX_ISTAD);\r\npr_debug("%s: ISACX ISTAD %x\n", isac->name, val);\r\nval = ReadISAC(isac, ISACX_ISTA);\r\npr_debug("%s: ISACX ISTA %x\n", isac->name, val);\r\nWriteISAC(isac, ISACX_TR_CONF0, 0x00);\r\nWriteISAC(isac, ISACX_TR_CONF2, 0x00);\r\nWriteISAC(isac, ISACX_MODED, 0xc9);\r\nval = ReadISAC(isac, ISACX_ID);\r\nif (isac->dch.debug & DEBUG_HW)\r\npr_notice("%s: ISACX Design ID %x\n",\r\nisac->name, val & 0x3f);\r\nval = ReadISAC(isac, ISACX_CIR0);\r\npr_debug("%s: ISACX CIR0 %02X\n", isac->name, val);\r\nisac->state = val >> 4;\r\nisac_ph_state_change(isac);\r\nph_command(isac, ISAC_CMD_RS);\r\nWriteISAC(isac, ISACX_MASK, IPACX__ON);\r\nWriteISAC(isac, ISACX_MASKD, 0x00);\r\n} else {\r\nWriteISAC(isac, ISAC_MASK, 0xff);\r\nval = ReadISAC(isac, ISAC_STAR);\r\npr_debug("%s: ISAC STAR %x\n", isac->name, val);\r\nval = ReadISAC(isac, ISAC_MODE);\r\npr_debug("%s: ISAC MODE %x\n", isac->name, val);\r\nval = ReadISAC(isac, ISAC_ADF2);\r\npr_debug("%s: ISAC ADF2 %x\n", isac->name, val);\r\nval = ReadISAC(isac, ISAC_ISTA);\r\npr_debug("%s: ISAC ISTA %x\n", isac->name, val);\r\nif (val & 0x01) {\r\nval = ReadISAC(isac, ISAC_EXIR);\r\npr_debug("%s: ISAC EXIR %x\n", isac->name, val);\r\n}\r\nval = ReadISAC(isac, ISAC_RBCH);\r\nif (isac->dch.debug & DEBUG_HW)\r\npr_notice("%s: ISAC version (%x): %s\n", isac->name,\r\nval, ISACVer[(val >> 5) & 3]);\r\nisac->type |= ((val >> 5) & 3);\r\nif (!isac->adf2)\r\nisac->adf2 = 0x80;\r\nif (!(isac->adf2 & 0x80)) {\r\npr_info("%s: only support IOM2 mode but adf2=%02x\n",\r\nisac->name, isac->adf2);\r\nisac_release(isac);\r\nreturn -EINVAL;\r\n}\r\nWriteISAC(isac, ISAC_ADF2, isac->adf2);\r\nWriteISAC(isac, ISAC_SQXR, 0x2f);\r\nWriteISAC(isac, ISAC_SPCR, 0x00);\r\nWriteISAC(isac, ISAC_STCR, 0x70);\r\nWriteISAC(isac, ISAC_MODE, 0xc9);\r\nWriteISAC(isac, ISAC_TIMR, 0x00);\r\nWriteISAC(isac, ISAC_ADF1, 0x00);\r\nval = ReadISAC(isac, ISAC_CIR0);\r\npr_debug("%s: ISAC CIR0 %x\n", isac->name, val);\r\nisac->state = (val >> 2) & 0xf;\r\nisac_ph_state_change(isac);\r\nph_command(isac, ISAC_CMD_RS);\r\nWriteISAC(isac, ISAC_MASK, 0);\r\n}\r\nreturn err;\r\n}\r\nint\r\nmISDNisac_init(struct isac_hw *isac, void *hw)\r\n{\r\nmISDN_initdchannel(&isac->dch, MAX_DFRAME_LEN_L1, isac_ph_state_bh);\r\nisac->dch.hw = hw;\r\nisac->dch.dev.D.send = isac_l1hw;\r\nisac->init = isac_init;\r\nisac->release = isac_release;\r\nisac->ctrl = isac_ctrl;\r\nisac->open = open_dchannel;\r\nisac->dch.dev.Dprotocols = (1 << ISDN_P_TE_S0);\r\nisac->dch.dev.nrbchan = 2;\r\nreturn 0;\r\n}\r\nstatic void\r\nwaitforCEC(struct hscx_hw *hx)\r\n{\r\nu8 starb, to = 50;\r\nwhile (to) {\r\nstarb = ReadHSCX(hx, IPAC_STARB);\r\nif (!(starb & 0x04))\r\nbreak;\r\nudelay(1);\r\nto--;\r\n}\r\nif (to < 50)\r\npr_debug("%s: B%1d CEC %d us\n", hx->ip->name, hx->bch.nr,\r\n50 - to);\r\nif (!to)\r\npr_info("%s: B%1d CEC timeout\n", hx->ip->name, hx->bch.nr);\r\n}\r\nstatic void\r\nwaitforXFW(struct hscx_hw *hx)\r\n{\r\nu8 starb, to = 50;\r\nwhile (to) {\r\nstarb = ReadHSCX(hx, IPAC_STARB);\r\nif ((starb & 0x44) == 0x40)\r\nbreak;\r\nudelay(1);\r\nto--;\r\n}\r\nif (to < 50)\r\npr_debug("%s: B%1d XFW %d us\n", hx->ip->name, hx->bch.nr,\r\n50 - to);\r\nif (!to)\r\npr_info("%s: B%1d XFW timeout\n", hx->ip->name, hx->bch.nr);\r\n}\r\nstatic void\r\nhscx_cmdr(struct hscx_hw *hx, u8 cmd)\r\n{\r\nif (hx->ip->type & IPAC_TYPE_IPACX)\r\nWriteHSCX(hx, IPACX_CMDRB, cmd);\r\nelse {\r\nwaitforCEC(hx);\r\nWriteHSCX(hx, IPAC_CMDRB, cmd);\r\n}\r\n}\r\nstatic void\r\nhscx_empty_fifo(struct hscx_hw *hscx, u8 count)\r\n{\r\nu8 *p;\r\nint maxlen;\r\npr_debug("%s: B%1d %d\n", hscx->ip->name, hscx->bch.nr, count);\r\nif (test_bit(FLG_RX_OFF, &hscx->bch.Flags)) {\r\nhscx->bch.dropcnt += count;\r\nhscx_cmdr(hscx, 0x80);\r\nreturn;\r\n}\r\nmaxlen = bchannel_get_rxbuf(&hscx->bch, count);\r\nif (maxlen < 0) {\r\nhscx_cmdr(hscx, 0x80);\r\nif (hscx->bch.rx_skb)\r\nskb_trim(hscx->bch.rx_skb, 0);\r\npr_warning("%s.B%d: No bufferspace for %d bytes\n",\r\nhscx->ip->name, hscx->bch.nr, count);\r\nreturn;\r\n}\r\np = skb_put(hscx->bch.rx_skb, count);\r\nif (hscx->ip->type & IPAC_TYPE_IPACX)\r\nhscx->ip->read_fifo(hscx->ip->hw,\r\nhscx->off + IPACX_RFIFOB, p, count);\r\nelse\r\nhscx->ip->read_fifo(hscx->ip->hw,\r\nhscx->off, p, count);\r\nhscx_cmdr(hscx, 0x80);\r\nif (hscx->bch.debug & DEBUG_HW_BFIFO) {\r\nsnprintf(hscx->log, 64, "B%1d-recv %s %d ",\r\nhscx->bch.nr, hscx->ip->name, count);\r\nprint_hex_dump_bytes(hscx->log, DUMP_PREFIX_OFFSET, p, count);\r\n}\r\n}\r\nstatic void\r\nhscx_fill_fifo(struct hscx_hw *hscx)\r\n{\r\nint count, more;\r\nu8 *p;\r\nif (!hscx->bch.tx_skb) {\r\nif (!test_bit(FLG_TX_EMPTY, &hscx->bch.Flags))\r\nreturn;\r\ncount = hscx->fifo_size;\r\nmore = 1;\r\np = hscx->log;\r\nmemset(p, hscx->bch.fill[0], count);\r\n} else {\r\ncount = hscx->bch.tx_skb->len - hscx->bch.tx_idx;\r\nif (count <= 0)\r\nreturn;\r\np = hscx->bch.tx_skb->data + hscx->bch.tx_idx;\r\nmore = test_bit(FLG_TRANSPARENT, &hscx->bch.Flags) ? 1 : 0;\r\nif (count > hscx->fifo_size) {\r\ncount = hscx->fifo_size;\r\nmore = 1;\r\n}\r\npr_debug("%s: B%1d %d/%d/%d\n", hscx->ip->name, hscx->bch.nr,\r\ncount, hscx->bch.tx_idx, hscx->bch.tx_skb->len);\r\nhscx->bch.tx_idx += count;\r\n}\r\nif (hscx->ip->type & IPAC_TYPE_IPACX)\r\nhscx->ip->write_fifo(hscx->ip->hw,\r\nhscx->off + IPACX_XFIFOB, p, count);\r\nelse {\r\nwaitforXFW(hscx);\r\nhscx->ip->write_fifo(hscx->ip->hw,\r\nhscx->off, p, count);\r\n}\r\nhscx_cmdr(hscx, more ? 0x08 : 0x0a);\r\nif (hscx->bch.tx_skb && (hscx->bch.debug & DEBUG_HW_BFIFO)) {\r\nsnprintf(hscx->log, 64, "B%1d-send %s %d ",\r\nhscx->bch.nr, hscx->ip->name, count);\r\nprint_hex_dump_bytes(hscx->log, DUMP_PREFIX_OFFSET, p, count);\r\n}\r\n}\r\nstatic void\r\nhscx_xpr(struct hscx_hw *hx)\r\n{\r\nif (hx->bch.tx_skb && hx->bch.tx_idx < hx->bch.tx_skb->len) {\r\nhscx_fill_fifo(hx);\r\n} else {\r\nif (hx->bch.tx_skb)\r\ndev_kfree_skb(hx->bch.tx_skb);\r\nif (get_next_bframe(&hx->bch)) {\r\nhscx_fill_fifo(hx);\r\ntest_and_clear_bit(FLG_TX_EMPTY, &hx->bch.Flags);\r\n} else if (test_bit(FLG_TX_EMPTY, &hx->bch.Flags)) {\r\nhscx_fill_fifo(hx);\r\n}\r\n}\r\n}\r\nstatic void\r\nipac_rme(struct hscx_hw *hx)\r\n{\r\nint count;\r\nu8 rstab;\r\nif (hx->ip->type & IPAC_TYPE_IPACX)\r\nrstab = ReadHSCX(hx, IPACX_RSTAB);\r\nelse\r\nrstab = ReadHSCX(hx, IPAC_RSTAB);\r\npr_debug("%s: B%1d RSTAB %02x\n", hx->ip->name, hx->bch.nr, rstab);\r\nif ((rstab & 0xf0) != 0xa0) {\r\nif (!(rstab & 0x80)) {\r\nif (hx->bch.debug & DEBUG_HW_BCHANNEL)\r\npr_notice("%s: B%1d invalid frame\n",\r\nhx->ip->name, hx->bch.nr);\r\n}\r\nif (rstab & 0x40) {\r\nif (hx->bch.debug & DEBUG_HW_BCHANNEL)\r\npr_notice("%s: B%1d RDO proto=%x\n",\r\nhx->ip->name, hx->bch.nr,\r\nhx->bch.state);\r\n}\r\nif (!(rstab & 0x20)) {\r\nif (hx->bch.debug & DEBUG_HW_BCHANNEL)\r\npr_notice("%s: B%1d CRC error\n",\r\nhx->ip->name, hx->bch.nr);\r\n}\r\nhscx_cmdr(hx, 0x80);\r\nreturn;\r\n}\r\nif (hx->ip->type & IPAC_TYPE_IPACX)\r\ncount = ReadHSCX(hx, IPACX_RBCLB);\r\nelse\r\ncount = ReadHSCX(hx, IPAC_RBCLB);\r\ncount &= (hx->fifo_size - 1);\r\nif (count == 0)\r\ncount = hx->fifo_size;\r\nhscx_empty_fifo(hx, count);\r\nif (!hx->bch.rx_skb)\r\nreturn;\r\nif (hx->bch.rx_skb->len < 2) {\r\npr_debug("%s: B%1d frame to short %d\n",\r\nhx->ip->name, hx->bch.nr, hx->bch.rx_skb->len);\r\nskb_trim(hx->bch.rx_skb, 0);\r\n} else {\r\nskb_trim(hx->bch.rx_skb, hx->bch.rx_skb->len - 1);\r\nrecv_Bchannel(&hx->bch, 0, false);\r\n}\r\n}\r\nstatic void\r\nipac_irq(struct hscx_hw *hx, u8 ista)\r\n{\r\nu8 istab, m, exirb = 0;\r\nif (hx->ip->type & IPAC_TYPE_IPACX)\r\nistab = ReadHSCX(hx, IPACX_ISTAB);\r\nelse if (hx->ip->type & IPAC_TYPE_IPAC) {\r\nistab = ReadHSCX(hx, IPAC_ISTAB);\r\nm = (hx->bch.nr & 1) ? IPAC__EXA : IPAC__EXB;\r\nif (m & ista) {\r\nexirb = ReadHSCX(hx, IPAC_EXIRB);\r\npr_debug("%s: B%1d EXIRB %02x\n", hx->ip->name,\r\nhx->bch.nr, exirb);\r\n}\r\n} else if (hx->bch.nr & 2) {\r\nif (ista & (HSCX__EXA | HSCX__ICA))\r\nipac_irq(&hx->ip->hscx[0], ista);\r\nif (ista & HSCX__EXB) {\r\nexirb = ReadHSCX(hx, IPAC_EXIRB);\r\npr_debug("%s: B%1d EXIRB %02x\n", hx->ip->name,\r\nhx->bch.nr, exirb);\r\n}\r\nistab = ista & 0xF8;\r\n} else {\r\nistab = ReadHSCX(hx, IPAC_ISTAB);\r\nif (ista & HSCX__EXA) {\r\nexirb = ReadHSCX(hx, IPAC_EXIRB);\r\npr_debug("%s: B%1d EXIRB %02x\n", hx->ip->name,\r\nhx->bch.nr, exirb);\r\n}\r\nistab = istab & 0xF8;\r\n}\r\nif (exirb & IPAC_B_XDU)\r\nistab |= IPACX_B_XDU;\r\nif (exirb & IPAC_B_RFO)\r\nistab |= IPACX_B_RFO;\r\npr_debug("%s: B%1d ISTAB %02x\n", hx->ip->name, hx->bch.nr, istab);\r\nif (!test_bit(FLG_ACTIVE, &hx->bch.Flags))\r\nreturn;\r\nif (istab & IPACX_B_RME)\r\nipac_rme(hx);\r\nif (istab & IPACX_B_RPF) {\r\nhscx_empty_fifo(hx, hx->fifo_size);\r\nif (test_bit(FLG_TRANSPARENT, &hx->bch.Flags))\r\nrecv_Bchannel(&hx->bch, 0, false);\r\n}\r\nif (istab & IPACX_B_RFO) {\r\npr_debug("%s: B%1d RFO error\n", hx->ip->name, hx->bch.nr);\r\nhscx_cmdr(hx, 0x40);\r\n}\r\nif (istab & IPACX_B_XPR)\r\nhscx_xpr(hx);\r\nif (istab & IPACX_B_XDU) {\r\nif (test_bit(FLG_TRANSPARENT, &hx->bch.Flags)) {\r\nif (test_bit(FLG_FILLEMPTY, &hx->bch.Flags))\r\ntest_and_set_bit(FLG_TX_EMPTY, &hx->bch.Flags);\r\nhscx_xpr(hx);\r\nreturn;\r\n}\r\npr_debug("%s: B%1d XDU error at len %d\n", hx->ip->name,\r\nhx->bch.nr, hx->bch.tx_idx);\r\nhx->bch.tx_idx = 0;\r\nhscx_cmdr(hx, 0x01);\r\n}\r\n}\r\nirqreturn_t\r\nmISDNipac_irq(struct ipac_hw *ipac, int maxloop)\r\n{\r\nint cnt = maxloop + 1;\r\nu8 ista, istad;\r\nstruct isac_hw *isac = &ipac->isac;\r\nif (ipac->type & IPAC_TYPE_IPACX) {\r\nista = ReadIPAC(ipac, ISACX_ISTA);\r\nwhile (ista && --cnt) {\r\npr_debug("%s: ISTA %02x\n", ipac->name, ista);\r\nif (ista & IPACX__ICA)\r\nipac_irq(&ipac->hscx[0], ista);\r\nif (ista & IPACX__ICB)\r\nipac_irq(&ipac->hscx[1], ista);\r\nif (ista & (ISACX__ICD | ISACX__CIC))\r\nmISDNisac_irq(&ipac->isac, ista);\r\nista = ReadIPAC(ipac, ISACX_ISTA);\r\n}\r\n} else if (ipac->type & IPAC_TYPE_IPAC) {\r\nista = ReadIPAC(ipac, IPAC_ISTA);\r\nwhile (ista && --cnt) {\r\npr_debug("%s: ISTA %02x\n", ipac->name, ista);\r\nif (ista & (IPAC__ICD | IPAC__EXD)) {\r\nistad = ReadISAC(isac, ISAC_ISTA);\r\npr_debug("%s: ISTAD %02x\n", ipac->name, istad);\r\nif (istad & IPAC_D_TIN2)\r\npr_debug("%s TIN2 irq\n", ipac->name);\r\nif (ista & IPAC__EXD)\r\nistad |= 1;\r\nmISDNisac_irq(isac, istad);\r\n}\r\nif (ista & (IPAC__ICA | IPAC__EXA))\r\nipac_irq(&ipac->hscx[0], ista);\r\nif (ista & (IPAC__ICB | IPAC__EXB))\r\nipac_irq(&ipac->hscx[1], ista);\r\nista = ReadIPAC(ipac, IPAC_ISTA);\r\n}\r\n} else if (ipac->type & IPAC_TYPE_HSCX) {\r\nwhile (--cnt) {\r\nista = ReadIPAC(ipac, IPAC_ISTAB + ipac->hscx[1].off);\r\npr_debug("%s: B2 ISTA %02x\n", ipac->name, ista);\r\nif (ista)\r\nipac_irq(&ipac->hscx[1], ista);\r\nistad = ReadISAC(isac, ISAC_ISTA);\r\npr_debug("%s: ISTAD %02x\n", ipac->name, istad);\r\nif (istad)\r\nmISDNisac_irq(isac, istad);\r\nif (0 == (ista | istad))\r\nbreak;\r\n}\r\n}\r\nif (cnt > maxloop)\r\nreturn IRQ_NONE;\r\nif (cnt < maxloop)\r\npr_debug("%s: %d irqloops cpu%d\n", ipac->name,\r\nmaxloop - cnt, smp_processor_id());\r\nif (maxloop && !cnt)\r\npr_notice("%s: %d IRQ LOOP cpu%d\n", ipac->name,\r\nmaxloop, smp_processor_id());\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int\r\nhscx_mode(struct hscx_hw *hscx, u32 bprotocol)\r\n{\r\npr_debug("%s: HSCX %c protocol %x-->%x ch %d\n", hscx->ip->name,\r\n'@' + hscx->bch.nr, hscx->bch.state, bprotocol, hscx->bch.nr);\r\nif (hscx->ip->type & IPAC_TYPE_IPACX) {\r\nif (hscx->bch.nr & 1) {\r\nWriteIPAC(hscx->ip, ISACX_BCHA_TSDP_BC1, 0x80);\r\nWriteIPAC(hscx->ip, ISACX_BCHA_CR, 0x88);\r\n} else {\r\nWriteIPAC(hscx->ip, ISACX_BCHB_TSDP_BC1, 0x81);\r\nWriteIPAC(hscx->ip, ISACX_BCHB_CR, 0x88);\r\n}\r\nswitch (bprotocol) {\r\ncase ISDN_P_NONE:\r\nWriteHSCX(hscx, IPACX_MODEB, 0xC0);\r\nWriteHSCX(hscx, IPACX_EXMB, 0x30);\r\nWriteHSCX(hscx, IPACX_MASKB, 0xFF);\r\nhscx_cmdr(hscx, 0x41);\r\ntest_and_clear_bit(FLG_HDLC, &hscx->bch.Flags);\r\ntest_and_clear_bit(FLG_TRANSPARENT, &hscx->bch.Flags);\r\nbreak;\r\ncase ISDN_P_B_RAW:\r\nWriteHSCX(hscx, IPACX_MODEB, 0x88);\r\nWriteHSCX(hscx, IPACX_EXMB, 0x00);\r\nhscx_cmdr(hscx, 0x41);\r\nWriteHSCX(hscx, IPACX_MASKB, IPACX_B_ON);\r\ntest_and_set_bit(FLG_TRANSPARENT, &hscx->bch.Flags);\r\nbreak;\r\ncase ISDN_P_B_HDLC:\r\nWriteHSCX(hscx, IPACX_MODEB, 0xC0);\r\nWriteHSCX(hscx, IPACX_EXMB, 0x00);\r\nhscx_cmdr(hscx, 0x41);\r\nWriteHSCX(hscx, IPACX_MASKB, IPACX_B_ON);\r\ntest_and_set_bit(FLG_HDLC, &hscx->bch.Flags);\r\nbreak;\r\ndefault:\r\npr_info("%s: protocol not known %x\n", hscx->ip->name,\r\nbprotocol);\r\nreturn -ENOPROTOOPT;\r\n}\r\n} else if (hscx->ip->type & IPAC_TYPE_IPAC) {\r\nWriteHSCX(hscx, IPAC_CCR1, 0x82);\r\nWriteHSCX(hscx, IPAC_CCR2, 0x30);\r\nWriteHSCX(hscx, IPAC_XCCR, 0x07);\r\nWriteHSCX(hscx, IPAC_RCCR, 0x07);\r\nWriteHSCX(hscx, IPAC_TSAX, hscx->slot);\r\nWriteHSCX(hscx, IPAC_TSAR, hscx->slot);\r\nswitch (bprotocol) {\r\ncase ISDN_P_NONE:\r\nWriteHSCX(hscx, IPAC_TSAX, 0x1F);\r\nWriteHSCX(hscx, IPAC_TSAR, 0x1F);\r\nWriteHSCX(hscx, IPAC_MODEB, 0x84);\r\nWriteHSCX(hscx, IPAC_CCR1, 0x82);\r\nWriteHSCX(hscx, IPAC_MASKB, 0xFF);\r\ntest_and_clear_bit(FLG_HDLC, &hscx->bch.Flags);\r\ntest_and_clear_bit(FLG_TRANSPARENT, &hscx->bch.Flags);\r\nbreak;\r\ncase ISDN_P_B_RAW:\r\nWriteHSCX(hscx, IPAC_MODEB, 0xe4);\r\nWriteHSCX(hscx, IPAC_CCR1, 0x82);\r\nhscx_cmdr(hscx, 0x41);\r\nWriteHSCX(hscx, IPAC_MASKB, 0);\r\ntest_and_set_bit(FLG_TRANSPARENT, &hscx->bch.Flags);\r\nbreak;\r\ncase ISDN_P_B_HDLC:\r\nWriteHSCX(hscx, IPAC_MODEB, 0x8c);\r\nWriteHSCX(hscx, IPAC_CCR1, 0x8a);\r\nhscx_cmdr(hscx, 0x41);\r\nWriteHSCX(hscx, IPAC_MASKB, 0);\r\ntest_and_set_bit(FLG_HDLC, &hscx->bch.Flags);\r\nbreak;\r\ndefault:\r\npr_info("%s: protocol not known %x\n", hscx->ip->name,\r\nbprotocol);\r\nreturn -ENOPROTOOPT;\r\n}\r\n} else if (hscx->ip->type & IPAC_TYPE_HSCX) {\r\nWriteHSCX(hscx, IPAC_CCR1, 0x85);\r\nWriteHSCX(hscx, IPAC_CCR2, 0x30);\r\nWriteHSCX(hscx, IPAC_XCCR, 0x07);\r\nWriteHSCX(hscx, IPAC_RCCR, 0x07);\r\nWriteHSCX(hscx, IPAC_TSAX, hscx->slot);\r\nWriteHSCX(hscx, IPAC_TSAR, hscx->slot);\r\nswitch (bprotocol) {\r\ncase ISDN_P_NONE:\r\nWriteHSCX(hscx, IPAC_TSAX, 0x1F);\r\nWriteHSCX(hscx, IPAC_TSAR, 0x1F);\r\nWriteHSCX(hscx, IPAC_MODEB, 0x84);\r\nWriteHSCX(hscx, IPAC_CCR1, 0x85);\r\nWriteHSCX(hscx, IPAC_MASKB, 0xFF);\r\ntest_and_clear_bit(FLG_HDLC, &hscx->bch.Flags);\r\ntest_and_clear_bit(FLG_TRANSPARENT, &hscx->bch.Flags);\r\nbreak;\r\ncase ISDN_P_B_RAW:\r\nWriteHSCX(hscx, IPAC_MODEB, 0xe4);\r\nWriteHSCX(hscx, IPAC_CCR1, 0x85);\r\nhscx_cmdr(hscx, 0x41);\r\nWriteHSCX(hscx, IPAC_MASKB, 0);\r\ntest_and_set_bit(FLG_TRANSPARENT, &hscx->bch.Flags);\r\nbreak;\r\ncase ISDN_P_B_HDLC:\r\nWriteHSCX(hscx, IPAC_MODEB, 0x8c);\r\nWriteHSCX(hscx, IPAC_CCR1, 0x8d);\r\nhscx_cmdr(hscx, 0x41);\r\nWriteHSCX(hscx, IPAC_MASKB, 0);\r\ntest_and_set_bit(FLG_HDLC, &hscx->bch.Flags);\r\nbreak;\r\ndefault:\r\npr_info("%s: protocol not known %x\n", hscx->ip->name,\r\nbprotocol);\r\nreturn -ENOPROTOOPT;\r\n}\r\n} else\r\nreturn -EINVAL;\r\nhscx->bch.state = bprotocol;\r\nreturn 0;\r\n}\r\nstatic int\r\nhscx_l2l1(struct mISDNchannel *ch, struct sk_buff *skb)\r\n{\r\nstruct bchannel *bch = container_of(ch, struct bchannel, ch);\r\nstruct hscx_hw *hx = container_of(bch, struct hscx_hw, bch);\r\nint ret = -EINVAL;\r\nstruct mISDNhead *hh = mISDN_HEAD_P(skb);\r\nunsigned long flags;\r\nswitch (hh->prim) {\r\ncase PH_DATA_REQ:\r\nspin_lock_irqsave(hx->ip->hwlock, flags);\r\nret = bchannel_senddata(bch, skb);\r\nif (ret > 0) {\r\nret = 0;\r\nhscx_fill_fifo(hx);\r\n}\r\nspin_unlock_irqrestore(hx->ip->hwlock, flags);\r\nreturn ret;\r\ncase PH_ACTIVATE_REQ:\r\nspin_lock_irqsave(hx->ip->hwlock, flags);\r\nif (!test_and_set_bit(FLG_ACTIVE, &bch->Flags))\r\nret = hscx_mode(hx, ch->protocol);\r\nelse\r\nret = 0;\r\nspin_unlock_irqrestore(hx->ip->hwlock, flags);\r\nif (!ret)\r\n_queue_data(ch, PH_ACTIVATE_IND, MISDN_ID_ANY, 0,\r\nNULL, GFP_KERNEL);\r\nbreak;\r\ncase PH_DEACTIVATE_REQ:\r\nspin_lock_irqsave(hx->ip->hwlock, flags);\r\nmISDN_clear_bchannel(bch);\r\nhscx_mode(hx, ISDN_P_NONE);\r\nspin_unlock_irqrestore(hx->ip->hwlock, flags);\r\n_queue_data(ch, PH_DEACTIVATE_IND, MISDN_ID_ANY, 0,\r\nNULL, GFP_KERNEL);\r\nret = 0;\r\nbreak;\r\ndefault:\r\npr_info("%s: %s unknown prim(%x,%x)\n",\r\nhx->ip->name, __func__, hh->prim, hh->id);\r\nret = -EINVAL;\r\n}\r\nif (!ret)\r\ndev_kfree_skb(skb);\r\nreturn ret;\r\n}\r\nstatic int\r\nchannel_bctrl(struct bchannel *bch, struct mISDN_ctrl_req *cq)\r\n{\r\nreturn mISDN_ctrl_bchannel(bch, cq);\r\n}\r\nstatic int\r\nhscx_bctrl(struct mISDNchannel *ch, u32 cmd, void *arg)\r\n{\r\nstruct bchannel *bch = container_of(ch, struct bchannel, ch);\r\nstruct hscx_hw *hx = container_of(bch, struct hscx_hw, bch);\r\nint ret = -EINVAL;\r\nu_long flags;\r\npr_debug("%s: %s cmd:%x %p\n", hx->ip->name, __func__, cmd, arg);\r\nswitch (cmd) {\r\ncase CLOSE_CHANNEL:\r\ntest_and_clear_bit(FLG_OPEN, &bch->Flags);\r\ncancel_work_sync(&bch->workq);\r\nspin_lock_irqsave(hx->ip->hwlock, flags);\r\nmISDN_clear_bchannel(bch);\r\nhscx_mode(hx, ISDN_P_NONE);\r\nspin_unlock_irqrestore(hx->ip->hwlock, flags);\r\nch->protocol = ISDN_P_NONE;\r\nch->peer = NULL;\r\nmodule_put(hx->ip->owner);\r\nret = 0;\r\nbreak;\r\ncase CONTROL_CHANNEL:\r\nret = channel_bctrl(bch, arg);\r\nbreak;\r\ndefault:\r\npr_info("%s: %s unknown prim(%x)\n",\r\nhx->ip->name, __func__, cmd);\r\n}\r\nreturn ret;\r\n}\r\nstatic void\r\nfree_ipac(struct ipac_hw *ipac)\r\n{\r\nisac_release(&ipac->isac);\r\n}\r\nstatic void\r\nhscx_init(struct hscx_hw *hx)\r\n{\r\nu8 val;\r\nWriteHSCX(hx, IPAC_RAH2, 0xFF);\r\nWriteHSCX(hx, IPAC_XBCH, 0x00);\r\nWriteHSCX(hx, IPAC_RLCR, 0x00);\r\nif (hx->ip->type & IPAC_TYPE_HSCX) {\r\nWriteHSCX(hx, IPAC_CCR1, 0x85);\r\nval = ReadHSCX(hx, HSCX_VSTR);\r\npr_debug("%s: HSCX VSTR %02x\n", hx->ip->name, val);\r\nif (hx->bch.debug & DEBUG_HW)\r\npr_notice("%s: HSCX version %s\n", hx->ip->name,\r\nHSCXVer[val & 0x0f]);\r\n} else\r\nWriteHSCX(hx, IPAC_CCR1, 0x82);\r\nWriteHSCX(hx, IPAC_CCR2, 0x30);\r\nWriteHSCX(hx, IPAC_XCCR, 0x07);\r\nWriteHSCX(hx, IPAC_RCCR, 0x07);\r\n}\r\nstatic int\r\nipac_init(struct ipac_hw *ipac)\r\n{\r\nu8 val;\r\nif (ipac->type & IPAC_TYPE_HSCX) {\r\nhscx_init(&ipac->hscx[0]);\r\nhscx_init(&ipac->hscx[1]);\r\nval = ReadIPAC(ipac, IPAC_ID);\r\n} else if (ipac->type & IPAC_TYPE_IPAC) {\r\nhscx_init(&ipac->hscx[0]);\r\nhscx_init(&ipac->hscx[1]);\r\nWriteIPAC(ipac, IPAC_MASK, IPAC__ON);\r\nval = ReadIPAC(ipac, IPAC_CONF);\r\npr_debug("%s: IPAC CONF %02x/%02x\n", ipac->name,\r\nval, ipac->conf);\r\nWriteIPAC(ipac, IPAC_CONF, ipac->conf);\r\nval = ReadIPAC(ipac, IPAC_ID);\r\nif (ipac->hscx[0].bch.debug & DEBUG_HW)\r\npr_notice("%s: IPAC Design ID %02x\n", ipac->name, val);\r\n}\r\nreturn isac_init(&ipac->isac);\r\n}\r\nstatic int\r\nopen_bchannel(struct ipac_hw *ipac, struct channel_req *rq)\r\n{\r\nstruct bchannel *bch;\r\nif (rq->adr.channel == 0 || rq->adr.channel > 2)\r\nreturn -EINVAL;\r\nif (rq->protocol == ISDN_P_NONE)\r\nreturn -EINVAL;\r\nbch = &ipac->hscx[rq->adr.channel - 1].bch;\r\nif (test_and_set_bit(FLG_OPEN, &bch->Flags))\r\nreturn -EBUSY;\r\ntest_and_clear_bit(FLG_FILLEMPTY, &bch->Flags);\r\nbch->ch.protocol = rq->protocol;\r\nrq->ch = &bch->ch;\r\nreturn 0;\r\n}\r\nstatic int\r\nchannel_ctrl(struct ipac_hw *ipac, struct mISDN_ctrl_req *cq)\r\n{\r\nint ret = 0;\r\nswitch (cq->op) {\r\ncase MISDN_CTRL_GETOP:\r\ncq->op = MISDN_CTRL_LOOP | MISDN_CTRL_L1_TIMER3;\r\nbreak;\r\ncase MISDN_CTRL_LOOP:\r\nif (cq->channel < 0 || cq->channel > 3) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nret = ipac->ctrl(ipac, HW_TESTLOOP, cq->channel);\r\nbreak;\r\ncase MISDN_CTRL_L1_TIMER3:\r\nret = ipac->isac.ctrl(&ipac->isac, HW_TIMER3_VALUE, cq->p1);\r\nbreak;\r\ndefault:\r\npr_info("%s: unknown CTRL OP %x\n", ipac->name, cq->op);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nipac_dctrl(struct mISDNchannel *ch, u32 cmd, void *arg)\r\n{\r\nstruct mISDNdevice *dev = container_of(ch, struct mISDNdevice, D);\r\nstruct dchannel *dch = container_of(dev, struct dchannel, dev);\r\nstruct isac_hw *isac = container_of(dch, struct isac_hw, dch);\r\nstruct ipac_hw *ipac = container_of(isac, struct ipac_hw, isac);\r\nstruct channel_req *rq;\r\nint err = 0;\r\npr_debug("%s: DCTRL: %x %p\n", ipac->name, cmd, arg);\r\nswitch (cmd) {\r\ncase OPEN_CHANNEL:\r\nrq = arg;\r\nif (rq->protocol == ISDN_P_TE_S0)\r\nerr = open_dchannel_caller(isac, rq, __builtin_return_address(0));\r\nelse\r\nerr = open_bchannel(ipac, rq);\r\nif (err)\r\nbreak;\r\nif (!try_module_get(ipac->owner))\r\npr_info("%s: cannot get module\n", ipac->name);\r\nbreak;\r\ncase CLOSE_CHANNEL:\r\npr_debug("%s: dev(%d) close from %p\n", ipac->name,\r\ndch->dev.id, __builtin_return_address(0));\r\nmodule_put(ipac->owner);\r\nbreak;\r\ncase CONTROL_CHANNEL:\r\nerr = channel_ctrl(ipac, arg);\r\nbreak;\r\ndefault:\r\npr_debug("%s: unknown DCTRL command %x\n", ipac->name, cmd);\r\nreturn -EINVAL;\r\n}\r\nreturn err;\r\n}\r\nu32\r\nmISDNipac_init(struct ipac_hw *ipac, void *hw)\r\n{\r\nu32 ret;\r\nu8 i;\r\nipac->hw = hw;\r\nif (ipac->isac.dch.debug & DEBUG_HW)\r\npr_notice("%s: ipac type %x\n", ipac->name, ipac->type);\r\nif (ipac->type & IPAC_TYPE_HSCX) {\r\nipac->isac.type = IPAC_TYPE_ISAC;\r\nipac->hscx[0].off = 0;\r\nipac->hscx[1].off = 0x40;\r\nipac->hscx[0].fifo_size = 32;\r\nipac->hscx[1].fifo_size = 32;\r\n} else if (ipac->type & IPAC_TYPE_IPAC) {\r\nipac->isac.type = IPAC_TYPE_IPAC | IPAC_TYPE_ISAC;\r\nipac->hscx[0].off = 0;\r\nipac->hscx[1].off = 0x40;\r\nipac->hscx[0].fifo_size = 64;\r\nipac->hscx[1].fifo_size = 64;\r\n} else if (ipac->type & IPAC_TYPE_IPACX) {\r\nipac->isac.type = IPAC_TYPE_IPACX | IPAC_TYPE_ISACX;\r\nipac->hscx[0].off = IPACX_OFF_ICA;\r\nipac->hscx[1].off = IPACX_OFF_ICB;\r\nipac->hscx[0].fifo_size = 64;\r\nipac->hscx[1].fifo_size = 64;\r\n} else\r\nreturn 0;\r\nmISDNisac_init(&ipac->isac, hw);\r\nipac->isac.dch.dev.D.ctrl = ipac_dctrl;\r\nfor (i = 0; i < 2; i++) {\r\nipac->hscx[i].bch.nr = i + 1;\r\nset_channelmap(i + 1, ipac->isac.dch.dev.channelmap);\r\nlist_add(&ipac->hscx[i].bch.ch.list,\r\n&ipac->isac.dch.dev.bchannels);\r\nmISDN_initbchannel(&ipac->hscx[i].bch, MAX_DATA_MEM,\r\nipac->hscx[i].fifo_size);\r\nipac->hscx[i].bch.ch.nr = i + 1;\r\nipac->hscx[i].bch.ch.send = &hscx_l2l1;\r\nipac->hscx[i].bch.ch.ctrl = hscx_bctrl;\r\nipac->hscx[i].bch.hw = hw;\r\nipac->hscx[i].ip = ipac;\r\nipac->hscx[i].slot = (i == 0) ? 0x2f : 0x03;\r\n}\r\nipac->init = ipac_init;\r\nipac->release = free_ipac;\r\nret = (1 << (ISDN_P_B_RAW & ISDN_P_B_MASK)) |\r\n(1 << (ISDN_P_B_HDLC & ISDN_P_B_MASK));\r\nreturn ret;\r\n}\r\nstatic int __init\r\nisac_mod_init(void)\r\n{\r\npr_notice("mISDNipac module version %s\n", ISAC_REV);\r\nreturn 0;\r\n}\r\nstatic void __exit\r\nisac_mod_cleanup(void)\r\n{\r\npr_notice("mISDNipac module unloaded\n");\r\n}
