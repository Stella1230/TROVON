static struct ucounts *inc_uts_namespaces(struct user_namespace *ns)\r\n{\r\nreturn inc_ucount(ns, current_euid(), UCOUNT_UTS_NAMESPACES);\r\n}\r\nstatic void dec_uts_namespaces(struct ucounts *ucounts)\r\n{\r\ndec_ucount(ucounts, UCOUNT_UTS_NAMESPACES);\r\n}\r\nstatic struct uts_namespace *create_uts_ns(void)\r\n{\r\nstruct uts_namespace *uts_ns;\r\nuts_ns = kmalloc(sizeof(struct uts_namespace), GFP_KERNEL);\r\nif (uts_ns)\r\nkref_init(&uts_ns->kref);\r\nreturn uts_ns;\r\n}\r\nstatic struct uts_namespace *clone_uts_ns(struct user_namespace *user_ns,\r\nstruct uts_namespace *old_ns)\r\n{\r\nstruct uts_namespace *ns;\r\nstruct ucounts *ucounts;\r\nint err;\r\nerr = -ENOSPC;\r\nucounts = inc_uts_namespaces(user_ns);\r\nif (!ucounts)\r\ngoto fail;\r\nerr = -ENOMEM;\r\nns = create_uts_ns();\r\nif (!ns)\r\ngoto fail_dec;\r\nerr = ns_alloc_inum(&ns->ns);\r\nif (err)\r\ngoto fail_free;\r\nns->ucounts = ucounts;\r\nns->ns.ops = &utsns_operations;\r\ndown_read(&uts_sem);\r\nmemcpy(&ns->name, &old_ns->name, sizeof(ns->name));\r\nns->user_ns = get_user_ns(user_ns);\r\nup_read(&uts_sem);\r\nreturn ns;\r\nfail_free:\r\nkfree(ns);\r\nfail_dec:\r\ndec_uts_namespaces(ucounts);\r\nfail:\r\nreturn ERR_PTR(err);\r\n}\r\nstruct uts_namespace *copy_utsname(unsigned long flags,\r\nstruct user_namespace *user_ns, struct uts_namespace *old_ns)\r\n{\r\nstruct uts_namespace *new_ns;\r\nBUG_ON(!old_ns);\r\nget_uts_ns(old_ns);\r\nif (!(flags & CLONE_NEWUTS))\r\nreturn old_ns;\r\nnew_ns = clone_uts_ns(user_ns, old_ns);\r\nput_uts_ns(old_ns);\r\nreturn new_ns;\r\n}\r\nvoid free_uts_ns(struct kref *kref)\r\n{\r\nstruct uts_namespace *ns;\r\nns = container_of(kref, struct uts_namespace, kref);\r\ndec_uts_namespaces(ns->ucounts);\r\nput_user_ns(ns->user_ns);\r\nns_free_inum(&ns->ns);\r\nkfree(ns);\r\n}\r\nstatic inline struct uts_namespace *to_uts_ns(struct ns_common *ns)\r\n{\r\nreturn container_of(ns, struct uts_namespace, ns);\r\n}\r\nstatic struct ns_common *utsns_get(struct task_struct *task)\r\n{\r\nstruct uts_namespace *ns = NULL;\r\nstruct nsproxy *nsproxy;\r\ntask_lock(task);\r\nnsproxy = task->nsproxy;\r\nif (nsproxy) {\r\nns = nsproxy->uts_ns;\r\nget_uts_ns(ns);\r\n}\r\ntask_unlock(task);\r\nreturn ns ? &ns->ns : NULL;\r\n}\r\nstatic void utsns_put(struct ns_common *ns)\r\n{\r\nput_uts_ns(to_uts_ns(ns));\r\n}\r\nstatic int utsns_install(struct nsproxy *nsproxy, struct ns_common *new)\r\n{\r\nstruct uts_namespace *ns = to_uts_ns(new);\r\nif (!ns_capable(ns->user_ns, CAP_SYS_ADMIN) ||\r\n!ns_capable(current_user_ns(), CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nget_uts_ns(ns);\r\nput_uts_ns(nsproxy->uts_ns);\r\nnsproxy->uts_ns = ns;\r\nreturn 0;\r\n}\r\nstatic struct user_namespace *utsns_owner(struct ns_common *ns)\r\n{\r\nreturn to_uts_ns(ns)->user_ns;\r\n}
