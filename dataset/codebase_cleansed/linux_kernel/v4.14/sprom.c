static int sprom2hex(const u16 *sprom, char *buf, size_t buf_len,\r\nsize_t sprom_size_words)\r\n{\r\nint i, pos = 0;\r\nfor (i = 0; i < sprom_size_words; i++)\r\npos += snprintf(buf + pos, buf_len - pos - 1,\r\n"%04X", swab16(sprom[i]) & 0xFFFF);\r\npos += snprintf(buf + pos, buf_len - pos - 1, "\n");\r\nreturn pos + 1;\r\n}\r\nstatic int hex2sprom(u16 *sprom, const char *dump, size_t len,\r\nsize_t sprom_size_words)\r\n{\r\nchar c, tmp[5] = { 0 };\r\nint err, cnt = 0;\r\nunsigned long parsed;\r\nwhile (len) {\r\nc = dump[len - 1];\r\nif (!isspace(c) && c != '\0')\r\nbreak;\r\nlen--;\r\n}\r\nif (len != sprom_size_words * 4)\r\nreturn -EINVAL;\r\nwhile (cnt < sprom_size_words) {\r\nmemcpy(tmp, dump, 4);\r\ndump += 4;\r\nerr = kstrtoul(tmp, 16, &parsed);\r\nif (err)\r\nreturn err;\r\nsprom[cnt++] = swab16((u16)parsed);\r\n}\r\nreturn 0;\r\n}\r\nssize_t ssb_attr_sprom_show(struct ssb_bus *bus, char *buf,\r\nint (*sprom_read)(struct ssb_bus *bus, u16 *sprom))\r\n{\r\nu16 *sprom;\r\nint err = -ENOMEM;\r\nssize_t count = 0;\r\nsize_t sprom_size_words = bus->sprom_size;\r\nsprom = kcalloc(sprom_size_words, sizeof(u16), GFP_KERNEL);\r\nif (!sprom)\r\ngoto out;\r\nerr = -ERESTARTSYS;\r\nif (mutex_lock_interruptible(&bus->sprom_mutex))\r\ngoto out_kfree;\r\nerr = sprom_read(bus, sprom);\r\nmutex_unlock(&bus->sprom_mutex);\r\nif (!err)\r\ncount = sprom2hex(sprom, buf, PAGE_SIZE, sprom_size_words);\r\nout_kfree:\r\nkfree(sprom);\r\nout:\r\nreturn err ? err : count;\r\n}\r\nssize_t ssb_attr_sprom_store(struct ssb_bus *bus,\r\nconst char *buf, size_t count,\r\nint (*sprom_check_crc)(const u16 *sprom, size_t size),\r\nint (*sprom_write)(struct ssb_bus *bus, const u16 *sprom))\r\n{\r\nu16 *sprom;\r\nint res = 0, err = -ENOMEM;\r\nsize_t sprom_size_words = bus->sprom_size;\r\nstruct ssb_freeze_context freeze;\r\nsprom = kcalloc(bus->sprom_size, sizeof(u16), GFP_KERNEL);\r\nif (!sprom)\r\ngoto out;\r\nerr = hex2sprom(sprom, buf, count, sprom_size_words);\r\nif (err) {\r\nerr = -EINVAL;\r\ngoto out_kfree;\r\n}\r\nerr = sprom_check_crc(sprom, sprom_size_words);\r\nif (err) {\r\nerr = -EINVAL;\r\ngoto out_kfree;\r\n}\r\nerr = -ERESTARTSYS;\r\nif (mutex_lock_interruptible(&bus->sprom_mutex))\r\ngoto out_kfree;\r\nerr = ssb_devices_freeze(bus, &freeze);\r\nif (err) {\r\nssb_err("SPROM write: Could not freeze all devices\n");\r\ngoto out_unlock;\r\n}\r\nres = sprom_write(bus, sprom);\r\nerr = ssb_devices_thaw(&freeze);\r\nif (err)\r\nssb_err("SPROM write: Could not thaw all devices\n");\r\nout_unlock:\r\nmutex_unlock(&bus->sprom_mutex);\r\nout_kfree:\r\nkfree(sprom);\r\nout:\r\nif (res)\r\nreturn res;\r\nreturn err ? err : count;\r\n}\r\nint ssb_arch_register_fallback_sprom(int (*sprom_callback)(struct ssb_bus *bus,\r\nstruct ssb_sprom *out))\r\n{\r\nif (get_fallback_sprom)\r\nreturn -EEXIST;\r\nget_fallback_sprom = sprom_callback;\r\nreturn 0;\r\n}\r\nint ssb_fill_sprom_with_fallback(struct ssb_bus *bus, struct ssb_sprom *out)\r\n{\r\nif (!get_fallback_sprom)\r\nreturn -ENOENT;\r\nreturn get_fallback_sprom(bus, out);\r\n}\r\nbool ssb_is_sprom_available(struct ssb_bus *bus)\r\n{\r\nif (bus->bustype == SSB_BUSTYPE_PCI &&\r\nbus->chipco.dev &&\r\nbus->chipco.dev->id.revision >= 31)\r\nreturn bus->chipco.capabilities & SSB_CHIPCO_CAP_SPROM;\r\nreturn true;\r\n}
