static int vnic_wq_alloc_bufs(struct vnic_wq *wq)\r\n{\r\nstruct vnic_wq_buf *buf;\r\nunsigned int i, j, count = wq->ring.desc_count;\r\nunsigned int blks = VNIC_WQ_BUF_BLKS_NEEDED(count);\r\nfor (i = 0; i < blks; i++) {\r\nwq->bufs[i] = kzalloc(VNIC_WQ_BUF_BLK_SZ(count), GFP_ATOMIC);\r\nif (!wq->bufs[i])\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < blks; i++) {\r\nbuf = wq->bufs[i];\r\nfor (j = 0; j < VNIC_WQ_BUF_BLK_ENTRIES(count); j++) {\r\nbuf->index = i * VNIC_WQ_BUF_BLK_ENTRIES(count) + j;\r\nbuf->desc = (u8 *)wq->ring.descs +\r\nwq->ring.desc_size * buf->index;\r\nif (buf->index + 1 == count) {\r\nbuf->next = wq->bufs[0];\r\nbuf->next->prev = buf;\r\nbreak;\r\n} else if (j + 1 == VNIC_WQ_BUF_BLK_ENTRIES(count)) {\r\nbuf->next = wq->bufs[i + 1];\r\nbuf->next->prev = buf;\r\n} else {\r\nbuf->next = buf + 1;\r\nbuf->next->prev = buf;\r\nbuf++;\r\n}\r\n}\r\n}\r\nwq->to_use = wq->to_clean = wq->bufs[0];\r\nreturn 0;\r\n}\r\nvoid vnic_wq_free(struct vnic_wq *wq)\r\n{\r\nstruct vnic_dev *vdev;\r\nunsigned int i;\r\nvdev = wq->vdev;\r\nvnic_dev_free_desc_ring(vdev, &wq->ring);\r\nfor (i = 0; i < VNIC_WQ_BUF_BLKS_MAX; i++) {\r\nif (wq->bufs[i]) {\r\nkfree(wq->bufs[i]);\r\nwq->bufs[i] = NULL;\r\n}\r\n}\r\nwq->ctrl = NULL;\r\n}\r\nint vnic_wq_alloc(struct vnic_dev *vdev, struct vnic_wq *wq, unsigned int index,\r\nunsigned int desc_count, unsigned int desc_size)\r\n{\r\nint err;\r\nwq->index = index;\r\nwq->vdev = vdev;\r\nwq->ctrl = vnic_dev_get_res(vdev, RES_TYPE_WQ, index);\r\nif (!wq->ctrl) {\r\nvdev_err(vdev, "Failed to hook WQ[%d] resource\n", index);\r\nreturn -EINVAL;\r\n}\r\nvnic_wq_disable(wq);\r\nerr = vnic_dev_alloc_desc_ring(vdev, &wq->ring, desc_count, desc_size);\r\nif (err)\r\nreturn err;\r\nerr = vnic_wq_alloc_bufs(wq);\r\nif (err) {\r\nvnic_wq_free(wq);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nint enic_wq_devcmd2_alloc(struct vnic_dev *vdev, struct vnic_wq *wq,\r\nunsigned int desc_count, unsigned int desc_size)\r\n{\r\nint err;\r\nwq->index = 0;\r\nwq->vdev = vdev;\r\nwq->ctrl = vnic_dev_get_res(vdev, RES_TYPE_DEVCMD2, 0);\r\nif (!wq->ctrl)\r\nreturn -EINVAL;\r\nvnic_wq_disable(wq);\r\nerr = vnic_dev_alloc_desc_ring(vdev, &wq->ring, desc_count, desc_size);\r\nreturn err;\r\n}\r\nvoid enic_wq_init_start(struct vnic_wq *wq, unsigned int cq_index,\r\nunsigned int fetch_index, unsigned int posted_index,\r\nunsigned int error_interrupt_enable,\r\nunsigned int error_interrupt_offset)\r\n{\r\nu64 paddr;\r\nunsigned int count = wq->ring.desc_count;\r\npaddr = (u64)wq->ring.base_addr | VNIC_PADDR_TARGET;\r\nwriteq(paddr, &wq->ctrl->ring_base);\r\niowrite32(count, &wq->ctrl->ring_size);\r\niowrite32(fetch_index, &wq->ctrl->fetch_index);\r\niowrite32(posted_index, &wq->ctrl->posted_index);\r\niowrite32(cq_index, &wq->ctrl->cq_index);\r\niowrite32(error_interrupt_enable, &wq->ctrl->error_interrupt_enable);\r\niowrite32(error_interrupt_offset, &wq->ctrl->error_interrupt_offset);\r\niowrite32(0, &wq->ctrl->error_status);\r\nwq->to_use = wq->to_clean =\r\n&wq->bufs[fetch_index / VNIC_WQ_BUF_BLK_ENTRIES(count)]\r\n[fetch_index % VNIC_WQ_BUF_BLK_ENTRIES(count)];\r\n}\r\nvoid vnic_wq_init(struct vnic_wq *wq, unsigned int cq_index,\r\nunsigned int error_interrupt_enable,\r\nunsigned int error_interrupt_offset)\r\n{\r\nenic_wq_init_start(wq, cq_index, 0, 0,\r\nerror_interrupt_enable,\r\nerror_interrupt_offset);\r\n}\r\nunsigned int vnic_wq_error_status(struct vnic_wq *wq)\r\n{\r\nreturn ioread32(&wq->ctrl->error_status);\r\n}\r\nvoid vnic_wq_enable(struct vnic_wq *wq)\r\n{\r\niowrite32(1, &wq->ctrl->enable);\r\n}\r\nint vnic_wq_disable(struct vnic_wq *wq)\r\n{\r\nunsigned int wait;\r\nstruct vnic_dev *vdev = wq->vdev;\r\niowrite32(0, &wq->ctrl->enable);\r\nfor (wait = 0; wait < 1000; wait++) {\r\nif (!(ioread32(&wq->ctrl->running)))\r\nreturn 0;\r\nudelay(10);\r\n}\r\nvdev_neterr(vdev, "Failed to disable WQ[%d]\n", wq->index);\r\nreturn -ETIMEDOUT;\r\n}\r\nvoid vnic_wq_clean(struct vnic_wq *wq,\r\nvoid (*buf_clean)(struct vnic_wq *wq, struct vnic_wq_buf *buf))\r\n{\r\nstruct vnic_wq_buf *buf;\r\nbuf = wq->to_clean;\r\nwhile (vnic_wq_desc_used(wq) > 0) {\r\n(*buf_clean)(wq, buf);\r\nbuf = wq->to_clean = buf->next;\r\nwq->ring.desc_avail++;\r\n}\r\nwq->to_use = wq->to_clean = wq->bufs[0];\r\niowrite32(0, &wq->ctrl->fetch_index);\r\niowrite32(0, &wq->ctrl->posted_index);\r\niowrite32(0, &wq->ctrl->error_status);\r\nvnic_dev_clear_desc_ring(&wq->ring);\r\n}
