static ssize_t modalias_show(struct device *dev,\r\nstruct device_attribute *a __maybe_unused, char *buf)\r\n{\r\nreturn sprintf(buf, "hsi:%s\n", dev_name(dev));\r\n}\r\nstatic int hsi_bus_uevent(struct device *dev, struct kobj_uevent_env *env)\r\n{\r\nadd_uevent_var(env, "MODALIAS=hsi:%s", dev_name(dev));\r\nreturn 0;\r\n}\r\nstatic int hsi_bus_match(struct device *dev, struct device_driver *driver)\r\n{\r\nif (of_driver_match_device(dev, driver))\r\nreturn true;\r\nif (strcmp(dev_name(dev), driver->name) == 0)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void hsi_client_release(struct device *dev)\r\n{\r\nstruct hsi_client *cl = to_hsi_client(dev);\r\nkfree(cl->tx_cfg.channels);\r\nkfree(cl->rx_cfg.channels);\r\nkfree(cl);\r\n}\r\nstruct hsi_client *hsi_new_client(struct hsi_port *port,\r\nstruct hsi_board_info *info)\r\n{\r\nstruct hsi_client *cl;\r\nsize_t size;\r\ncl = kzalloc(sizeof(*cl), GFP_KERNEL);\r\nif (!cl)\r\ngoto err;\r\ncl->tx_cfg = info->tx_cfg;\r\nif (cl->tx_cfg.channels) {\r\nsize = cl->tx_cfg.num_channels * sizeof(*cl->tx_cfg.channels);\r\ncl->tx_cfg.channels = kmemdup(info->tx_cfg.channels, size,\r\nGFP_KERNEL);\r\nif (!cl->tx_cfg.channels)\r\ngoto err_tx;\r\n}\r\ncl->rx_cfg = info->rx_cfg;\r\nif (cl->rx_cfg.channels) {\r\nsize = cl->rx_cfg.num_channels * sizeof(*cl->rx_cfg.channels);\r\ncl->rx_cfg.channels = kmemdup(info->rx_cfg.channels, size,\r\nGFP_KERNEL);\r\nif (!cl->rx_cfg.channels)\r\ngoto err_rx;\r\n}\r\ncl->device.bus = &hsi_bus_type;\r\ncl->device.parent = &port->device;\r\ncl->device.release = hsi_client_release;\r\ndev_set_name(&cl->device, "%s", info->name);\r\ncl->device.platform_data = info->platform_data;\r\nif (info->archdata)\r\ncl->device.archdata = *info->archdata;\r\nif (device_register(&cl->device) < 0) {\r\npr_err("hsi: failed to register client: %s\n", info->name);\r\nput_device(&cl->device);\r\n}\r\nreturn cl;\r\nerr_rx:\r\nkfree(cl->tx_cfg.channels);\r\nerr_tx:\r\nkfree(cl);\r\nerr:\r\nreturn NULL;\r\n}\r\nstatic void hsi_scan_board_info(struct hsi_controller *hsi)\r\n{\r\nstruct hsi_cl_info *cl_info;\r\nstruct hsi_port *p;\r\nlist_for_each_entry(cl_info, &hsi_board_list, list)\r\nif (cl_info->info.hsi_id == hsi->id) {\r\np = hsi_find_port_num(hsi, cl_info->info.port);\r\nif (!p)\r\ncontinue;\r\nhsi_new_client(p, &cl_info->info);\r\n}\r\n}\r\nstatic int hsi_of_property_parse_mode(struct device_node *client, char *name,\r\nunsigned int *result)\r\n{\r\nconst char *mode;\r\nint err;\r\nerr = of_property_read_string(client, name, &mode);\r\nif (err < 0)\r\nreturn err;\r\nif (strcmp(mode, "stream") == 0)\r\n*result = HSI_MODE_STREAM;\r\nelse if (strcmp(mode, "frame") == 0)\r\n*result = HSI_MODE_FRAME;\r\nelse\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int hsi_of_property_parse_flow(struct device_node *client, char *name,\r\nunsigned int *result)\r\n{\r\nconst char *flow;\r\nint err;\r\nerr = of_property_read_string(client, name, &flow);\r\nif (err < 0)\r\nreturn err;\r\nif (strcmp(flow, "synchronized") == 0)\r\n*result = HSI_FLOW_SYNC;\r\nelse if (strcmp(flow, "pipeline") == 0)\r\n*result = HSI_FLOW_PIPE;\r\nelse\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int hsi_of_property_parse_arb_mode(struct device_node *client,\r\nchar *name, unsigned int *result)\r\n{\r\nconst char *arb_mode;\r\nint err;\r\nerr = of_property_read_string(client, name, &arb_mode);\r\nif (err < 0)\r\nreturn err;\r\nif (strcmp(arb_mode, "round-robin") == 0)\r\n*result = HSI_ARB_RR;\r\nelse if (strcmp(arb_mode, "priority") == 0)\r\n*result = HSI_ARB_PRIO;\r\nelse\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void hsi_add_client_from_dt(struct hsi_port *port,\r\nstruct device_node *client)\r\n{\r\nstruct hsi_client *cl;\r\nstruct hsi_channel channel;\r\nstruct property *prop;\r\nchar name[32];\r\nint length, cells, err, i, max_chan, mode;\r\ncl = kzalloc(sizeof(*cl), GFP_KERNEL);\r\nif (!cl)\r\nreturn;\r\nerr = of_modalias_node(client, name, sizeof(name));\r\nif (err)\r\ngoto err;\r\ndev_set_name(&cl->device, "%s", name);\r\nerr = hsi_of_property_parse_mode(client, "hsi-mode", &mode);\r\nif (err) {\r\nerr = hsi_of_property_parse_mode(client, "hsi-rx-mode",\r\n&cl->rx_cfg.mode);\r\nif (err)\r\ngoto err;\r\nerr = hsi_of_property_parse_mode(client, "hsi-tx-mode",\r\n&cl->tx_cfg.mode);\r\nif (err)\r\ngoto err;\r\n} else {\r\ncl->rx_cfg.mode = mode;\r\ncl->tx_cfg.mode = mode;\r\n}\r\nerr = of_property_read_u32(client, "hsi-speed-kbps",\r\n&cl->tx_cfg.speed);\r\nif (err)\r\ngoto err;\r\ncl->rx_cfg.speed = cl->tx_cfg.speed;\r\nerr = hsi_of_property_parse_flow(client, "hsi-flow",\r\n&cl->rx_cfg.flow);\r\nif (err)\r\ngoto err;\r\nerr = hsi_of_property_parse_arb_mode(client, "hsi-arb-mode",\r\n&cl->rx_cfg.arb_mode);\r\nif (err)\r\ngoto err;\r\nprop = of_find_property(client, "hsi-channel-ids", &length);\r\nif (!prop) {\r\nerr = -EINVAL;\r\ngoto err;\r\n}\r\ncells = length / sizeof(u32);\r\ncl->rx_cfg.num_channels = cells;\r\ncl->tx_cfg.num_channels = cells;\r\ncl->rx_cfg.channels = kcalloc(cells, sizeof(channel), GFP_KERNEL);\r\nif (!cl->rx_cfg.channels) {\r\nerr = -ENOMEM;\r\ngoto err;\r\n}\r\ncl->tx_cfg.channels = kcalloc(cells, sizeof(channel), GFP_KERNEL);\r\nif (!cl->tx_cfg.channels) {\r\nerr = -ENOMEM;\r\ngoto err2;\r\n}\r\nmax_chan = 0;\r\nfor (i = 0; i < cells; i++) {\r\nerr = of_property_read_u32_index(client, "hsi-channel-ids", i,\r\n&channel.id);\r\nif (err)\r\ngoto err3;\r\nerr = of_property_read_string_index(client, "hsi-channel-names",\r\ni, &channel.name);\r\nif (err)\r\nchannel.name = NULL;\r\nif (channel.id > max_chan)\r\nmax_chan = channel.id;\r\ncl->rx_cfg.channels[i] = channel;\r\ncl->tx_cfg.channels[i] = channel;\r\n}\r\ncl->rx_cfg.num_hw_channels = max_chan + 1;\r\ncl->tx_cfg.num_hw_channels = max_chan + 1;\r\ncl->device.bus = &hsi_bus_type;\r\ncl->device.parent = &port->device;\r\ncl->device.release = hsi_client_release;\r\ncl->device.of_node = client;\r\nif (device_register(&cl->device) < 0) {\r\npr_err("hsi: failed to register client: %s\n", name);\r\nput_device(&cl->device);\r\n}\r\nreturn;\r\nerr3:\r\nkfree(cl->tx_cfg.channels);\r\nerr2:\r\nkfree(cl->rx_cfg.channels);\r\nerr:\r\nkfree(cl);\r\npr_err("hsi client: missing or incorrect of property: err=%d\n", err);\r\n}\r\nvoid hsi_add_clients_from_dt(struct hsi_port *port, struct device_node *clients)\r\n{\r\nstruct device_node *child;\r\nhsi_new_client(port, &hsi_char_dev_info);\r\nfor_each_available_child_of_node(clients, child)\r\nhsi_add_client_from_dt(port, child);\r\n}\r\nint hsi_remove_client(struct device *dev, void *data __maybe_unused)\r\n{\r\ndevice_unregister(dev);\r\nreturn 0;\r\n}\r\nstatic int hsi_remove_port(struct device *dev, void *data __maybe_unused)\r\n{\r\ndevice_for_each_child(dev, NULL, hsi_remove_client);\r\ndevice_unregister(dev);\r\nreturn 0;\r\n}\r\nstatic void hsi_controller_release(struct device *dev)\r\n{\r\nstruct hsi_controller *hsi = to_hsi_controller(dev);\r\nkfree(hsi->port);\r\nkfree(hsi);\r\n}\r\nstatic void hsi_port_release(struct device *dev)\r\n{\r\nkfree(to_hsi_port(dev));\r\n}\r\nvoid hsi_port_unregister_clients(struct hsi_port *port)\r\n{\r\ndevice_for_each_child(&port->device, NULL, hsi_remove_client);\r\n}\r\nvoid hsi_unregister_controller(struct hsi_controller *hsi)\r\n{\r\ndevice_for_each_child(&hsi->device, NULL, hsi_remove_port);\r\ndevice_unregister(&hsi->device);\r\n}\r\nint hsi_register_controller(struct hsi_controller *hsi)\r\n{\r\nunsigned int i;\r\nint err;\r\nerr = device_add(&hsi->device);\r\nif (err < 0)\r\nreturn err;\r\nfor (i = 0; i < hsi->num_ports; i++) {\r\nhsi->port[i]->device.parent = &hsi->device;\r\nerr = device_add(&hsi->port[i]->device);\r\nif (err < 0)\r\ngoto out;\r\n}\r\nhsi_scan_board_info(hsi);\r\nreturn 0;\r\nout:\r\nwhile (i-- > 0)\r\ndevice_del(&hsi->port[i]->device);\r\ndevice_del(&hsi->device);\r\nreturn err;\r\n}\r\nint hsi_register_client_driver(struct hsi_client_driver *drv)\r\n{\r\ndrv->driver.bus = &hsi_bus_type;\r\nreturn driver_register(&drv->driver);\r\n}\r\nstatic inline int hsi_dummy_msg(struct hsi_msg *msg __maybe_unused)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline int hsi_dummy_cl(struct hsi_client *cl __maybe_unused)\r\n{\r\nreturn 0;\r\n}\r\nvoid hsi_put_controller(struct hsi_controller *hsi)\r\n{\r\nunsigned int i;\r\nif (!hsi)\r\nreturn;\r\nfor (i = 0; i < hsi->num_ports; i++)\r\nif (hsi->port && hsi->port[i])\r\nput_device(&hsi->port[i]->device);\r\nput_device(&hsi->device);\r\n}\r\nstruct hsi_controller *hsi_alloc_controller(unsigned int n_ports, gfp_t flags)\r\n{\r\nstruct hsi_controller *hsi;\r\nstruct hsi_port **port;\r\nunsigned int i;\r\nif (!n_ports)\r\nreturn NULL;\r\nhsi = kzalloc(sizeof(*hsi), flags);\r\nif (!hsi)\r\nreturn NULL;\r\nport = kcalloc(n_ports, sizeof(*port), flags);\r\nif (!port) {\r\nkfree(hsi);\r\nreturn NULL;\r\n}\r\nhsi->num_ports = n_ports;\r\nhsi->port = port;\r\nhsi->device.release = hsi_controller_release;\r\ndevice_initialize(&hsi->device);\r\nfor (i = 0; i < n_ports; i++) {\r\nport[i] = kzalloc(sizeof(**port), flags);\r\nif (port[i] == NULL)\r\ngoto out;\r\nport[i]->num = i;\r\nport[i]->async = hsi_dummy_msg;\r\nport[i]->setup = hsi_dummy_cl;\r\nport[i]->flush = hsi_dummy_cl;\r\nport[i]->start_tx = hsi_dummy_cl;\r\nport[i]->stop_tx = hsi_dummy_cl;\r\nport[i]->release = hsi_dummy_cl;\r\nmutex_init(&port[i]->lock);\r\nBLOCKING_INIT_NOTIFIER_HEAD(&port[i]->n_head);\r\ndev_set_name(&port[i]->device, "port%d", i);\r\nhsi->port[i]->device.release = hsi_port_release;\r\ndevice_initialize(&hsi->port[i]->device);\r\n}\r\nreturn hsi;\r\nout:\r\nhsi_put_controller(hsi);\r\nreturn NULL;\r\n}\r\nvoid hsi_free_msg(struct hsi_msg *msg)\r\n{\r\nif (!msg)\r\nreturn;\r\nsg_free_table(&msg->sgt);\r\nkfree(msg);\r\n}\r\nstruct hsi_msg *hsi_alloc_msg(unsigned int nents, gfp_t flags)\r\n{\r\nstruct hsi_msg *msg;\r\nint err;\r\nmsg = kzalloc(sizeof(*msg), flags);\r\nif (!msg)\r\nreturn NULL;\r\nif (!nents)\r\nreturn msg;\r\nerr = sg_alloc_table(&msg->sgt, nents, flags);\r\nif (unlikely(err)) {\r\nkfree(msg);\r\nmsg = NULL;\r\n}\r\nreturn msg;\r\n}\r\nint hsi_async(struct hsi_client *cl, struct hsi_msg *msg)\r\n{\r\nstruct hsi_port *port = hsi_get_port(cl);\r\nif (!hsi_port_claimed(cl))\r\nreturn -EACCES;\r\nWARN_ON_ONCE(!msg->destructor || !msg->complete);\r\nmsg->cl = cl;\r\nreturn port->async(msg);\r\n}\r\nint hsi_claim_port(struct hsi_client *cl, unsigned int share)\r\n{\r\nstruct hsi_port *port = hsi_get_port(cl);\r\nint err = 0;\r\nmutex_lock(&port->lock);\r\nif ((port->claimed) && (!port->shared || !share)) {\r\nerr = -EBUSY;\r\ngoto out;\r\n}\r\nif (!try_module_get(to_hsi_controller(port->device.parent)->owner)) {\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\nport->claimed++;\r\nport->shared = !!share;\r\ncl->pclaimed = 1;\r\nout:\r\nmutex_unlock(&port->lock);\r\nreturn err;\r\n}\r\nvoid hsi_release_port(struct hsi_client *cl)\r\n{\r\nstruct hsi_port *port = hsi_get_port(cl);\r\nmutex_lock(&port->lock);\r\nport->release(cl);\r\nif (cl->pclaimed)\r\nport->claimed--;\r\nBUG_ON(port->claimed < 0);\r\ncl->pclaimed = 0;\r\nif (!port->claimed)\r\nport->shared = 0;\r\nmodule_put(to_hsi_controller(port->device.parent)->owner);\r\nmutex_unlock(&port->lock);\r\n}\r\nstatic int hsi_event_notifier_call(struct notifier_block *nb,\r\nunsigned long event, void *data __maybe_unused)\r\n{\r\nstruct hsi_client *cl = container_of(nb, struct hsi_client, nb);\r\n(*cl->ehandler)(cl, event);\r\nreturn 0;\r\n}\r\nint hsi_register_port_event(struct hsi_client *cl,\r\nvoid (*handler)(struct hsi_client *, unsigned long))\r\n{\r\nstruct hsi_port *port = hsi_get_port(cl);\r\nif (!handler || cl->ehandler)\r\nreturn -EINVAL;\r\nif (!hsi_port_claimed(cl))\r\nreturn -EACCES;\r\ncl->ehandler = handler;\r\ncl->nb.notifier_call = hsi_event_notifier_call;\r\nreturn blocking_notifier_chain_register(&port->n_head, &cl->nb);\r\n}\r\nint hsi_unregister_port_event(struct hsi_client *cl)\r\n{\r\nstruct hsi_port *port = hsi_get_port(cl);\r\nint err;\r\nWARN_ON(!hsi_port_claimed(cl));\r\nerr = blocking_notifier_chain_unregister(&port->n_head, &cl->nb);\r\nif (!err)\r\ncl->ehandler = NULL;\r\nreturn err;\r\n}\r\nint hsi_event(struct hsi_port *port, unsigned long event)\r\n{\r\nreturn blocking_notifier_call_chain(&port->n_head, event, NULL);\r\n}\r\nint hsi_get_channel_id_by_name(struct hsi_client *cl, char *name)\r\n{\r\nint i;\r\nif (!cl->rx_cfg.channels)\r\nreturn -ENOENT;\r\nfor (i = 0; i < cl->rx_cfg.num_channels; i++)\r\nif (!strcmp(cl->rx_cfg.channels[i].name, name))\r\nreturn cl->rx_cfg.channels[i].id;\r\nreturn -ENXIO;\r\n}\r\nstatic int __init hsi_init(void)\r\n{\r\nreturn bus_register(&hsi_bus_type);\r\n}\r\nstatic void __exit hsi_exit(void)\r\n{\r\nbus_unregister(&hsi_bus_type);\r\n}
