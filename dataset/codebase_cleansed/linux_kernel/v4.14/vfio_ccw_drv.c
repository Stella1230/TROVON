int vfio_ccw_sch_quiesce(struct subchannel *sch)\r\n{\r\nstruct vfio_ccw_private *private = dev_get_drvdata(&sch->dev);\r\nDECLARE_COMPLETION_ONSTACK(completion);\r\nint iretry, ret = 0;\r\nspin_lock_irq(sch->lock);\r\nif (!sch->schib.pmcw.ena)\r\ngoto out_unlock;\r\nret = cio_disable_subchannel(sch);\r\nif (ret != -EBUSY)\r\ngoto out_unlock;\r\ndo {\r\niretry = 255;\r\nret = cio_cancel_halt_clear(sch, &iretry);\r\nwhile (ret == -EBUSY) {\r\nprivate->completion = &completion;\r\nspin_unlock_irq(sch->lock);\r\nwait_for_completion_timeout(&completion, 3*HZ);\r\nspin_lock_irq(sch->lock);\r\nprivate->completion = NULL;\r\nflush_workqueue(vfio_ccw_work_q);\r\nret = cio_cancel_halt_clear(sch, &iretry);\r\n};\r\nret = cio_disable_subchannel(sch);\r\n} while (ret == -EBUSY);\r\nout_unlock:\r\nprivate->state = VFIO_CCW_STATE_NOT_OPER;\r\nspin_unlock_irq(sch->lock);\r\nreturn ret;\r\n}\r\nstatic void vfio_ccw_sch_io_todo(struct work_struct *work)\r\n{\r\nstruct vfio_ccw_private *private;\r\nstruct irb *irb;\r\nprivate = container_of(work, struct vfio_ccw_private, io_work);\r\nirb = &private->irb;\r\nif (scsw_is_solicited(&irb->scsw)) {\r\ncp_update_scsw(&private->cp, &irb->scsw);\r\ncp_free(&private->cp);\r\n}\r\nmemcpy(private->io_region.irb_area, irb, sizeof(*irb));\r\nif (private->io_trigger)\r\neventfd_signal(private->io_trigger, 1);\r\nif (private->mdev)\r\nprivate->state = VFIO_CCW_STATE_IDLE;\r\n}\r\nstatic void vfio_ccw_sch_irq(struct subchannel *sch)\r\n{\r\nstruct vfio_ccw_private *private = dev_get_drvdata(&sch->dev);\r\ninc_irq_stat(IRQIO_CIO);\r\nvfio_ccw_fsm_event(private, VFIO_CCW_EVENT_INTERRUPT);\r\n}\r\nstatic int vfio_ccw_sch_probe(struct subchannel *sch)\r\n{\r\nstruct pmcw *pmcw = &sch->schib.pmcw;\r\nstruct vfio_ccw_private *private;\r\nint ret;\r\nif (pmcw->qf) {\r\ndev_warn(&sch->dev, "vfio: ccw: does not support QDIO: %s\n",\r\ndev_name(&sch->dev));\r\nreturn -ENODEV;\r\n}\r\nprivate = kzalloc(sizeof(*private), GFP_KERNEL | GFP_DMA);\r\nif (!private)\r\nreturn -ENOMEM;\r\nprivate->sch = sch;\r\ndev_set_drvdata(&sch->dev, private);\r\nspin_lock_irq(sch->lock);\r\nprivate->state = VFIO_CCW_STATE_NOT_OPER;\r\nsch->isc = VFIO_CCW_ISC;\r\nret = cio_enable_subchannel(sch, (u32)(unsigned long)sch);\r\nspin_unlock_irq(sch->lock);\r\nif (ret)\r\ngoto out_free;\r\nret = vfio_ccw_mdev_reg(sch);\r\nif (ret)\r\ngoto out_disable;\r\nINIT_WORK(&private->io_work, vfio_ccw_sch_io_todo);\r\natomic_set(&private->avail, 1);\r\nprivate->state = VFIO_CCW_STATE_STANDBY;\r\nreturn 0;\r\nout_disable:\r\ncio_disable_subchannel(sch);\r\nout_free:\r\ndev_set_drvdata(&sch->dev, NULL);\r\nkfree(private);\r\nreturn ret;\r\n}\r\nstatic int vfio_ccw_sch_remove(struct subchannel *sch)\r\n{\r\nstruct vfio_ccw_private *private = dev_get_drvdata(&sch->dev);\r\nvfio_ccw_sch_quiesce(sch);\r\nvfio_ccw_mdev_unreg(sch);\r\ndev_set_drvdata(&sch->dev, NULL);\r\nkfree(private);\r\nreturn 0;\r\n}\r\nstatic void vfio_ccw_sch_shutdown(struct subchannel *sch)\r\n{\r\nvfio_ccw_sch_quiesce(sch);\r\n}\r\nstatic int vfio_ccw_sch_event(struct subchannel *sch, int process)\r\n{\r\nstruct vfio_ccw_private *private = dev_get_drvdata(&sch->dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(sch->lock, flags);\r\nif (!device_is_registered(&sch->dev))\r\ngoto out_unlock;\r\nif (work_pending(&sch->todo_work))\r\ngoto out_unlock;\r\nif (cio_update_schib(sch)) {\r\nvfio_ccw_fsm_event(private, VFIO_CCW_EVENT_NOT_OPER);\r\ngoto out_unlock;\r\n}\r\nprivate = dev_get_drvdata(&sch->dev);\r\nif (private->state == VFIO_CCW_STATE_NOT_OPER) {\r\nprivate->state = private->mdev ? VFIO_CCW_STATE_IDLE :\r\nVFIO_CCW_STATE_STANDBY;\r\n}\r\nout_unlock:\r\nspin_unlock_irqrestore(sch->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int __init vfio_ccw_sch_init(void)\r\n{\r\nint ret;\r\nvfio_ccw_work_q = create_singlethread_workqueue("vfio-ccw");\r\nif (!vfio_ccw_work_q)\r\nreturn -ENOMEM;\r\nisc_register(VFIO_CCW_ISC);\r\nret = css_driver_register(&vfio_ccw_sch_driver);\r\nif (ret) {\r\nisc_unregister(VFIO_CCW_ISC);\r\ndestroy_workqueue(vfio_ccw_work_q);\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit vfio_ccw_sch_exit(void)\r\n{\r\ncss_driver_unregister(&vfio_ccw_sch_driver);\r\nisc_unregister(VFIO_CCW_ISC);\r\ndestroy_workqueue(vfio_ccw_work_q);\r\n}
