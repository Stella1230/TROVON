static void ipack_device_release(struct device *dev)\r\n{\r\nstruct ipack_device *device = to_ipack_dev(dev);\r\nkfree(device->id);\r\ndevice->release(device);\r\n}\r\nstatic inline const struct ipack_device_id *\r\nipack_match_one_device(const struct ipack_device_id *id,\r\nconst struct ipack_device *device)\r\n{\r\nif ((id->format == IPACK_ANY_FORMAT ||\r\nid->format == device->id_format) &&\r\n(id->vendor == IPACK_ANY_ID || id->vendor == device->id_vendor) &&\r\n(id->device == IPACK_ANY_ID || id->device == device->id_device))\r\nreturn id;\r\nreturn NULL;\r\n}\r\nstatic const struct ipack_device_id *\r\nipack_match_id(const struct ipack_device_id *ids, struct ipack_device *idev)\r\n{\r\nif (ids) {\r\nwhile (ids->vendor || ids->device) {\r\nif (ipack_match_one_device(ids, idev))\r\nreturn ids;\r\nids++;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic int ipack_bus_match(struct device *dev, struct device_driver *drv)\r\n{\r\nstruct ipack_device *idev = to_ipack_dev(dev);\r\nstruct ipack_driver *idrv = to_ipack_driver(drv);\r\nconst struct ipack_device_id *found_id;\r\nfound_id = ipack_match_id(idrv->id_table, idev);\r\nreturn found_id ? 1 : 0;\r\n}\r\nstatic int ipack_bus_probe(struct device *device)\r\n{\r\nstruct ipack_device *dev = to_ipack_dev(device);\r\nstruct ipack_driver *drv = to_ipack_driver(device->driver);\r\nif (!drv->ops->probe)\r\nreturn -EINVAL;\r\nreturn drv->ops->probe(dev);\r\n}\r\nstatic int ipack_bus_remove(struct device *device)\r\n{\r\nstruct ipack_device *dev = to_ipack_dev(device);\r\nstruct ipack_driver *drv = to_ipack_driver(device->driver);\r\nif (!drv->ops->remove)\r\nreturn -EINVAL;\r\ndrv->ops->remove(dev);\r\nreturn 0;\r\n}\r\nstatic int ipack_uevent(struct device *dev, struct kobj_uevent_env *env)\r\n{\r\nstruct ipack_device *idev;\r\nif (!dev)\r\nreturn -ENODEV;\r\nidev = to_ipack_dev(dev);\r\nif (add_uevent_var(env,\r\n"MODALIAS=ipack:f%02Xv%08Xd%08X", idev->id_format,\r\nidev->id_vendor, idev->id_device))\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic ssize_t id_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nunsigned int i, c, l, s;\r\nstruct ipack_device *idev = to_ipack_dev(dev);\r\nswitch (idev->id_format) {\r\ncase IPACK_ID_VERSION_1:\r\nl = 0x7; s = 1; break;\r\ncase IPACK_ID_VERSION_2:\r\nl = 0xf; s = 2; break;\r\ndefault:\r\nreturn -EIO;\r\n}\r\nc = 0;\r\nfor (i = 0; i < idev->id_avail; i++) {\r\nif (i > 0) {\r\nif ((i & l) == 0)\r\nbuf[c++] = '\n';\r\nelse if ((i & s) == 0)\r\nbuf[c++] = ' ';\r\n}\r\nsprintf(&buf[c], "%02x", idev->id[i]);\r\nc += 2;\r\n}\r\nbuf[c++] = '\n';\r\nreturn c;\r\n}\r\nstatic ssize_t\r\nid_vendor_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct ipack_device *idev = to_ipack_dev(dev);\r\nswitch (idev->id_format) {\r\ncase IPACK_ID_VERSION_1:\r\nreturn sprintf(buf, "0x%02x\n", idev->id_vendor);\r\ncase IPACK_ID_VERSION_2:\r\nreturn sprintf(buf, "0x%06x\n", idev->id_vendor);\r\ndefault:\r\nreturn -EIO;\r\n}\r\n}\r\nstatic ssize_t\r\nid_device_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct ipack_device *idev = to_ipack_dev(dev);\r\nswitch (idev->id_format) {\r\ncase IPACK_ID_VERSION_1:\r\nreturn sprintf(buf, "0x%02x\n", idev->id_device);\r\ncase IPACK_ID_VERSION_2:\r\nreturn sprintf(buf, "0x%04x\n", idev->id_device);\r\ndefault:\r\nreturn -EIO;\r\n}\r\n}\r\nstatic ssize_t modalias_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ipack_device *idev = to_ipack_dev(dev);\r\nreturn sprintf(buf, "ipac:f%02Xv%08Xd%08X", idev->id_format,\r\nidev->id_vendor, idev->id_device);\r\n}\r\nstruct ipack_bus_device *ipack_bus_register(struct device *parent, int slots,\r\nconst struct ipack_bus_ops *ops,\r\nstruct module *owner)\r\n{\r\nint bus_nr;\r\nstruct ipack_bus_device *bus;\r\nbus = kzalloc(sizeof(*bus), GFP_KERNEL);\r\nif (!bus)\r\nreturn NULL;\r\nbus_nr = ida_simple_get(&ipack_ida, 0, 0, GFP_KERNEL);\r\nif (bus_nr < 0) {\r\nkfree(bus);\r\nreturn NULL;\r\n}\r\nbus->bus_nr = bus_nr;\r\nbus->parent = parent;\r\nbus->slots = slots;\r\nbus->ops = ops;\r\nbus->owner = owner;\r\nreturn bus;\r\n}\r\nstatic int ipack_unregister_bus_member(struct device *dev, void *data)\r\n{\r\nstruct ipack_device *idev = to_ipack_dev(dev);\r\nstruct ipack_bus_device *bus = data;\r\nif (idev->bus == bus)\r\nipack_device_del(idev);\r\nreturn 1;\r\n}\r\nint ipack_bus_unregister(struct ipack_bus_device *bus)\r\n{\r\nbus_for_each_dev(&ipack_bus_type, NULL, bus,\r\nipack_unregister_bus_member);\r\nida_simple_remove(&ipack_ida, bus->bus_nr);\r\nkfree(bus);\r\nreturn 0;\r\n}\r\nint ipack_driver_register(struct ipack_driver *edrv, struct module *owner,\r\nconst char *name)\r\n{\r\nedrv->driver.owner = owner;\r\nedrv->driver.name = name;\r\nedrv->driver.bus = &ipack_bus_type;\r\nreturn driver_register(&edrv->driver);\r\n}\r\nvoid ipack_driver_unregister(struct ipack_driver *edrv)\r\n{\r\ndriver_unregister(&edrv->driver);\r\n}\r\nstatic u16 ipack_crc_byte(u16 crc, u8 c)\r\n{\r\nint i;\r\ncrc ^= c << 8;\r\nfor (i = 0; i < 8; i++)\r\ncrc = (crc << 1) ^ ((crc & 0x8000) ? 0x1021 : 0);\r\nreturn crc;\r\n}\r\nstatic u8 ipack_calc_crc1(struct ipack_device *dev)\r\n{\r\nu8 c;\r\nu16 crc;\r\nunsigned int i;\r\ncrc = 0xffff;\r\nfor (i = 0; i < dev->id_avail; i++) {\r\nc = (i != 11) ? dev->id[i] : 0;\r\ncrc = ipack_crc_byte(crc, c);\r\n}\r\ncrc = ~crc;\r\nreturn crc & 0xff;\r\n}\r\nstatic u16 ipack_calc_crc2(struct ipack_device *dev)\r\n{\r\nu8 c;\r\nu16 crc;\r\nunsigned int i;\r\ncrc = 0xffff;\r\nfor (i = 0; i < dev->id_avail; i++) {\r\nc = ((i != 0x18) && (i != 0x19)) ? dev->id[i] : 0;\r\ncrc = ipack_crc_byte(crc, c);\r\n}\r\ncrc = ~crc;\r\nreturn crc;\r\n}\r\nstatic void ipack_parse_id1(struct ipack_device *dev)\r\n{\r\nu8 *id = dev->id;\r\nu8 crc;\r\ndev->id_vendor = id[4];\r\ndev->id_device = id[5];\r\ndev->speed_8mhz = 1;\r\ndev->speed_32mhz = (id[7] == 'H');\r\ncrc = ipack_calc_crc1(dev);\r\ndev->id_crc_correct = (crc == id[11]);\r\nif (!dev->id_crc_correct) {\r\ndev_warn(&dev->dev, "ID CRC invalid found 0x%x, expected 0x%x.\n",\r\nid[11], crc);\r\n}\r\n}\r\nstatic void ipack_parse_id2(struct ipack_device *dev)\r\n{\r\n__be16 *id = (__be16 *) dev->id;\r\nu16 flags, crc;\r\ndev->id_vendor = ((be16_to_cpu(id[3]) & 0xff) << 16)\r\n+ be16_to_cpu(id[4]);\r\ndev->id_device = be16_to_cpu(id[5]);\r\nflags = be16_to_cpu(id[10]);\r\ndev->speed_8mhz = !!(flags & 2);\r\ndev->speed_32mhz = !!(flags & 4);\r\ncrc = ipack_calc_crc2(dev);\r\ndev->id_crc_correct = (crc == be16_to_cpu(id[12]));\r\nif (!dev->id_crc_correct) {\r\ndev_warn(&dev->dev, "ID CRC invalid found 0x%x, expected 0x%x.\n",\r\nid[11], crc);\r\n}\r\n}\r\nstatic int ipack_device_read_id(struct ipack_device *dev)\r\n{\r\nu8 __iomem *idmem;\r\nint i;\r\nint ret = 0;\r\nidmem = ioremap(dev->region[IPACK_ID_SPACE].start,\r\ndev->region[IPACK_ID_SPACE].size);\r\nif (!idmem) {\r\ndev_err(&dev->dev, "error mapping memory\n");\r\nreturn -ENOMEM;\r\n}\r\nif ((ioread8(idmem + 1) == 'I') &&\r\n(ioread8(idmem + 3) == 'P') &&\r\n(ioread8(idmem + 5) == 'A') &&\r\n((ioread8(idmem + 7) == 'C') ||\r\n(ioread8(idmem + 7) == 'H'))) {\r\ndev->id_format = IPACK_ID_VERSION_1;\r\ndev->id_avail = ioread8(idmem + 0x15);\r\nif ((dev->id_avail < 0x0c) || (dev->id_avail > 0x40)) {\r\ndev_warn(&dev->dev, "invalid id size");\r\ndev->id_avail = 0x0c;\r\n}\r\n} else if ((ioread8(idmem + 0) == 'I') &&\r\n(ioread8(idmem + 1) == 'V') &&\r\n(ioread8(idmem + 2) == 'A') &&\r\n(ioread8(idmem + 3) == 'T') &&\r\n(ioread8(idmem + 4) == ' ') &&\r\n(ioread8(idmem + 5) == '4')) {\r\ndev->id_format = IPACK_ID_VERSION_2;\r\ndev->id_avail = ioread16be(idmem + 0x16);\r\nif ((dev->id_avail < 0x1a) || (dev->id_avail > 0x40)) {\r\ndev_warn(&dev->dev, "invalid id size");\r\ndev->id_avail = 0x1a;\r\n}\r\n} else {\r\ndev->id_format = IPACK_ID_VERSION_INVALID;\r\ndev->id_avail = 0;\r\n}\r\nif (!dev->id_avail) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\ndev->id = kmalloc(dev->id_avail, GFP_KERNEL);\r\nif (!dev->id) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nfor (i = 0; i < dev->id_avail; i++) {\r\nif (dev->id_format == IPACK_ID_VERSION_1)\r\ndev->id[i] = ioread8(idmem + (i << 1) + 1);\r\nelse\r\ndev->id[i] = ioread8(idmem + i);\r\n}\r\nswitch (dev->id_format) {\r\ncase IPACK_ID_VERSION_1:\r\nipack_parse_id1(dev);\r\nbreak;\r\ncase IPACK_ID_VERSION_2:\r\nipack_parse_id2(dev);\r\nbreak;\r\n}\r\nout:\r\niounmap(idmem);\r\nreturn ret;\r\n}\r\nint ipack_device_init(struct ipack_device *dev)\r\n{\r\nint ret;\r\ndev->dev.bus = &ipack_bus_type;\r\ndev->dev.release = ipack_device_release;\r\ndev->dev.parent = dev->bus->parent;\r\ndev_set_name(&dev->dev,\r\n"ipack-dev.%u.%u", dev->bus->bus_nr, dev->slot);\r\ndevice_initialize(&dev->dev);\r\nif (dev->bus->ops->set_clockrate(dev, 8))\r\ndev_warn(&dev->dev, "failed to switch to 8 MHz operation for reading of device ID.\n");\r\nif (dev->bus->ops->reset_timeout(dev))\r\ndev_warn(&dev->dev, "failed to reset potential timeout.");\r\nret = ipack_device_read_id(dev);\r\nif (ret < 0) {\r\ndev_err(&dev->dev, "error reading device id section.\n");\r\nreturn ret;\r\n}\r\nif (dev->speed_32mhz) {\r\nret = dev->bus->ops->set_clockrate(dev, 32);\r\nif (ret < 0)\r\ndev_err(&dev->dev, "failed to switch to 32 MHz operation.\n");\r\n}\r\nreturn 0;\r\n}\r\nint ipack_device_add(struct ipack_device *dev)\r\n{\r\nreturn device_add(&dev->dev);\r\n}\r\nvoid ipack_device_del(struct ipack_device *dev)\r\n{\r\ndevice_del(&dev->dev);\r\nipack_put_device(dev);\r\n}\r\nvoid ipack_get_device(struct ipack_device *dev)\r\n{\r\nget_device(&dev->dev);\r\n}\r\nvoid ipack_put_device(struct ipack_device *dev)\r\n{\r\nput_device(&dev->dev);\r\n}\r\nstatic int __init ipack_init(void)\r\n{\r\nida_init(&ipack_ida);\r\nreturn bus_register(&ipack_bus_type);\r\n}\r\nstatic void __exit ipack_exit(void)\r\n{\r\nbus_unregister(&ipack_bus_type);\r\nida_destroy(&ipack_ida);\r\n}
