static struct i40e_vsi *i40e_dbg_find_vsi(struct i40e_pf *pf, int seid)\r\n{\r\nint i;\r\nif (seid < 0)\r\ndev_info(&pf->pdev->dev, "%d: bad seid\n", seid);\r\nelse\r\nfor (i = 0; i < pf->num_alloc_vsi; i++)\r\nif (pf->vsi[i] && (pf->vsi[i]->seid == seid))\r\nreturn pf->vsi[i];\r\nreturn NULL;\r\n}\r\nstatic struct i40e_veb *i40e_dbg_find_veb(struct i40e_pf *pf, int seid)\r\n{\r\nint i;\r\nfor (i = 0; i < I40E_MAX_VEB; i++)\r\nif (pf->veb[i] && pf->veb[i]->seid == seid)\r\nreturn pf->veb[i];\r\nreturn NULL;\r\n}\r\nstatic ssize_t i40e_dbg_command_read(struct file *filp, char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct i40e_pf *pf = filp->private_data;\r\nint bytes_not_copied;\r\nint buf_size = 256;\r\nchar *buf;\r\nint len;\r\nif (*ppos != 0)\r\nreturn 0;\r\nif (count < buf_size)\r\nreturn -ENOSPC;\r\nbuf = kzalloc(buf_size, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOSPC;\r\nlen = snprintf(buf, buf_size, "%s: %s\n",\r\npf->vsi[pf->lan_vsi]->netdev->name,\r\ni40e_dbg_command_buf);\r\nbytes_not_copied = copy_to_user(buffer, buf, len);\r\nkfree(buf);\r\nif (bytes_not_copied)\r\nreturn -EFAULT;\r\n*ppos = len;\r\nreturn len;\r\n}\r\nstatic void i40e_dbg_dump_vsi_seid(struct i40e_pf *pf, int seid)\r\n{\r\nstruct rtnl_link_stats64 *nstat;\r\nstruct i40e_mac_filter *f;\r\nstruct i40e_vsi *vsi;\r\nint i, bkt;\r\nvsi = i40e_dbg_find_vsi(pf, seid);\r\nif (!vsi) {\r\ndev_info(&pf->pdev->dev,\r\n"dump %d: seid not found\n", seid);\r\nreturn;\r\n}\r\ndev_info(&pf->pdev->dev, "vsi seid %d\n", seid);\r\nif (vsi->netdev) {\r\nstruct net_device *nd = vsi->netdev;\r\ndev_info(&pf->pdev->dev, " netdev: name = %s, state = %lu, flags = 0x%08x\n",\r\nnd->name, nd->state, nd->flags);\r\ndev_info(&pf->pdev->dev, " features = 0x%08lx\n",\r\n(unsigned long int)nd->features);\r\ndev_info(&pf->pdev->dev, " hw_features = 0x%08lx\n",\r\n(unsigned long int)nd->hw_features);\r\ndev_info(&pf->pdev->dev, " vlan_features = 0x%08lx\n",\r\n(unsigned long int)nd->vlan_features);\r\n}\r\ndev_info(&pf->pdev->dev,\r\n" vlgrp: & = %p\n", vsi->active_vlans);\r\ndev_info(&pf->pdev->dev,\r\n" flags = 0x%08lx, netdev_registered = %i, current_netdev_flags = 0x%04x\n",\r\nvsi->flags, vsi->netdev_registered, vsi->current_netdev_flags);\r\nfor (i = 0; i < BITS_TO_LONGS(__I40E_VSI_STATE_SIZE__); i++)\r\ndev_info(&pf->pdev->dev,\r\n" state[%d] = %08lx\n",\r\ni, vsi->state[i]);\r\nif (vsi == pf->vsi[pf->lan_vsi])\r\ndev_info(&pf->pdev->dev, " MAC address: %pM SAN MAC: %pM Port MAC: %pM\n",\r\npf->hw.mac.addr,\r\npf->hw.mac.san_addr,\r\npf->hw.mac.port_addr);\r\nhash_for_each(vsi->mac_filter_hash, bkt, f, hlist) {\r\ndev_info(&pf->pdev->dev,\r\n" mac_filter_hash: %pM vid=%d, state %s\n",\r\nf->macaddr, f->vlan,\r\ni40e_filter_state_string[f->state]);\r\n}\r\ndev_info(&pf->pdev->dev, " active_filters %u, promisc_threshold %u, overflow promisc %s\n",\r\nvsi->active_filters, vsi->promisc_threshold,\r\n(test_bit(__I40E_VSI_OVERFLOW_PROMISC, vsi->state) ?\r\n"ON" : "OFF"));\r\nnstat = i40e_get_vsi_stats_struct(vsi);\r\ndev_info(&pf->pdev->dev,\r\n" net_stats: rx_packets = %lu, rx_bytes = %lu, rx_errors = %lu, rx_dropped = %lu\n",\r\n(unsigned long int)nstat->rx_packets,\r\n(unsigned long int)nstat->rx_bytes,\r\n(unsigned long int)nstat->rx_errors,\r\n(unsigned long int)nstat->rx_dropped);\r\ndev_info(&pf->pdev->dev,\r\n" net_stats: tx_packets = %lu, tx_bytes = %lu, tx_errors = %lu, tx_dropped = %lu\n",\r\n(unsigned long int)nstat->tx_packets,\r\n(unsigned long int)nstat->tx_bytes,\r\n(unsigned long int)nstat->tx_errors,\r\n(unsigned long int)nstat->tx_dropped);\r\ndev_info(&pf->pdev->dev,\r\n" net_stats: multicast = %lu, collisions = %lu\n",\r\n(unsigned long int)nstat->multicast,\r\n(unsigned long int)nstat->collisions);\r\ndev_info(&pf->pdev->dev,\r\n" net_stats: rx_length_errors = %lu, rx_over_errors = %lu, rx_crc_errors = %lu\n",\r\n(unsigned long int)nstat->rx_length_errors,\r\n(unsigned long int)nstat->rx_over_errors,\r\n(unsigned long int)nstat->rx_crc_errors);\r\ndev_info(&pf->pdev->dev,\r\n" net_stats: rx_frame_errors = %lu, rx_fifo_errors = %lu, rx_missed_errors = %lu\n",\r\n(unsigned long int)nstat->rx_frame_errors,\r\n(unsigned long int)nstat->rx_fifo_errors,\r\n(unsigned long int)nstat->rx_missed_errors);\r\ndev_info(&pf->pdev->dev,\r\n" net_stats: tx_aborted_errors = %lu, tx_carrier_errors = %lu, tx_fifo_errors = %lu\n",\r\n(unsigned long int)nstat->tx_aborted_errors,\r\n(unsigned long int)nstat->tx_carrier_errors,\r\n(unsigned long int)nstat->tx_fifo_errors);\r\ndev_info(&pf->pdev->dev,\r\n" net_stats: tx_heartbeat_errors = %lu, tx_window_errors = %lu\n",\r\n(unsigned long int)nstat->tx_heartbeat_errors,\r\n(unsigned long int)nstat->tx_window_errors);\r\ndev_info(&pf->pdev->dev,\r\n" net_stats: rx_compressed = %lu, tx_compressed = %lu\n",\r\n(unsigned long int)nstat->rx_compressed,\r\n(unsigned long int)nstat->tx_compressed);\r\ndev_info(&pf->pdev->dev,\r\n" net_stats_offsets: rx_packets = %lu, rx_bytes = %lu, rx_errors = %lu, rx_dropped = %lu\n",\r\n(unsigned long int)vsi->net_stats_offsets.rx_packets,\r\n(unsigned long int)vsi->net_stats_offsets.rx_bytes,\r\n(unsigned long int)vsi->net_stats_offsets.rx_errors,\r\n(unsigned long int)vsi->net_stats_offsets.rx_dropped);\r\ndev_info(&pf->pdev->dev,\r\n" net_stats_offsets: tx_packets = %lu, tx_bytes = %lu, tx_errors = %lu, tx_dropped = %lu\n",\r\n(unsigned long int)vsi->net_stats_offsets.tx_packets,\r\n(unsigned long int)vsi->net_stats_offsets.tx_bytes,\r\n(unsigned long int)vsi->net_stats_offsets.tx_errors,\r\n(unsigned long int)vsi->net_stats_offsets.tx_dropped);\r\ndev_info(&pf->pdev->dev,\r\n" net_stats_offsets: multicast = %lu, collisions = %lu\n",\r\n(unsigned long int)vsi->net_stats_offsets.multicast,\r\n(unsigned long int)vsi->net_stats_offsets.collisions);\r\ndev_info(&pf->pdev->dev,\r\n" net_stats_offsets: rx_length_errors = %lu, rx_over_errors = %lu, rx_crc_errors = %lu\n",\r\n(unsigned long int)vsi->net_stats_offsets.rx_length_errors,\r\n(unsigned long int)vsi->net_stats_offsets.rx_over_errors,\r\n(unsigned long int)vsi->net_stats_offsets.rx_crc_errors);\r\ndev_info(&pf->pdev->dev,\r\n" net_stats_offsets: rx_frame_errors = %lu, rx_fifo_errors = %lu, rx_missed_errors = %lu\n",\r\n(unsigned long int)vsi->net_stats_offsets.rx_frame_errors,\r\n(unsigned long int)vsi->net_stats_offsets.rx_fifo_errors,\r\n(unsigned long int)vsi->net_stats_offsets.rx_missed_errors);\r\ndev_info(&pf->pdev->dev,\r\n" net_stats_offsets: tx_aborted_errors = %lu, tx_carrier_errors = %lu, tx_fifo_errors = %lu\n",\r\n(unsigned long int)vsi->net_stats_offsets.tx_aborted_errors,\r\n(unsigned long int)vsi->net_stats_offsets.tx_carrier_errors,\r\n(unsigned long int)vsi->net_stats_offsets.tx_fifo_errors);\r\ndev_info(&pf->pdev->dev,\r\n" net_stats_offsets: tx_heartbeat_errors = %lu, tx_window_errors = %lu\n",\r\n(unsigned long int)vsi->net_stats_offsets.tx_heartbeat_errors,\r\n(unsigned long int)vsi->net_stats_offsets.tx_window_errors);\r\ndev_info(&pf->pdev->dev,\r\n" net_stats_offsets: rx_compressed = %lu, tx_compressed = %lu\n",\r\n(unsigned long int)vsi->net_stats_offsets.rx_compressed,\r\n(unsigned long int)vsi->net_stats_offsets.tx_compressed);\r\ndev_info(&pf->pdev->dev,\r\n" tx_restart = %d, tx_busy = %d, rx_buf_failed = %d, rx_page_failed = %d\n",\r\nvsi->tx_restart, vsi->tx_busy,\r\nvsi->rx_buf_failed, vsi->rx_page_failed);\r\nrcu_read_lock();\r\nfor (i = 0; i < vsi->num_queue_pairs; i++) {\r\nstruct i40e_ring *rx_ring = ACCESS_ONCE(vsi->rx_rings[i]);\r\nif (!rx_ring)\r\ncontinue;\r\ndev_info(&pf->pdev->dev,\r\n" rx_rings[%i]: desc = %p\n",\r\ni, rx_ring->desc);\r\ndev_info(&pf->pdev->dev,\r\n" rx_rings[%i]: dev = %p, netdev = %p, rx_bi = %p\n",\r\ni, rx_ring->dev,\r\nrx_ring->netdev,\r\nrx_ring->rx_bi);\r\ndev_info(&pf->pdev->dev,\r\n" rx_rings[%i]: state = %li, queue_index = %d, reg_idx = %d\n",\r\ni, rx_ring->state,\r\nrx_ring->queue_index,\r\nrx_ring->reg_idx);\r\ndev_info(&pf->pdev->dev,\r\n" rx_rings[%i]: rx_buf_len = %d\n",\r\ni, rx_ring->rx_buf_len);\r\ndev_info(&pf->pdev->dev,\r\n" rx_rings[%i]: next_to_use = %d, next_to_clean = %d, ring_active = %i\n",\r\ni,\r\nrx_ring->next_to_use,\r\nrx_ring->next_to_clean,\r\nrx_ring->ring_active);\r\ndev_info(&pf->pdev->dev,\r\n" rx_rings[%i]: rx_stats: packets = %lld, bytes = %lld, non_eop_descs = %lld\n",\r\ni, rx_ring->stats.packets,\r\nrx_ring->stats.bytes,\r\nrx_ring->rx_stats.non_eop_descs);\r\ndev_info(&pf->pdev->dev,\r\n" rx_rings[%i]: rx_stats: alloc_page_failed = %lld, alloc_buff_failed = %lld\n",\r\ni,\r\nrx_ring->rx_stats.alloc_page_failed,\r\nrx_ring->rx_stats.alloc_buff_failed);\r\ndev_info(&pf->pdev->dev,\r\n" rx_rings[%i]: rx_stats: realloc_count = %lld, page_reuse_count = %lld\n",\r\ni,\r\nrx_ring->rx_stats.realloc_count,\r\nrx_ring->rx_stats.page_reuse_count);\r\ndev_info(&pf->pdev->dev,\r\n" rx_rings[%i]: size = %i, dma = 0x%08lx\n",\r\ni, rx_ring->size,\r\n(unsigned long int)rx_ring->dma);\r\ndev_info(&pf->pdev->dev,\r\n" rx_rings[%i]: vsi = %p, q_vector = %p\n",\r\ni, rx_ring->vsi,\r\nrx_ring->q_vector);\r\ndev_info(&pf->pdev->dev,\r\n" rx_rings[%i]: rx_itr_setting = %d (%s)\n",\r\ni, rx_ring->rx_itr_setting,\r\nITR_IS_DYNAMIC(rx_ring->rx_itr_setting) ? "dynamic" : "fixed");\r\n}\r\nfor (i = 0; i < vsi->num_queue_pairs; i++) {\r\nstruct i40e_ring *tx_ring = ACCESS_ONCE(vsi->tx_rings[i]);\r\nif (!tx_ring)\r\ncontinue;\r\ndev_info(&pf->pdev->dev,\r\n" tx_rings[%i]: desc = %p\n",\r\ni, tx_ring->desc);\r\ndev_info(&pf->pdev->dev,\r\n" tx_rings[%i]: dev = %p, netdev = %p, tx_bi = %p\n",\r\ni, tx_ring->dev,\r\ntx_ring->netdev,\r\ntx_ring->tx_bi);\r\ndev_info(&pf->pdev->dev,\r\n" tx_rings[%i]: state = %li, queue_index = %d, reg_idx = %d\n",\r\ni, tx_ring->state,\r\ntx_ring->queue_index,\r\ntx_ring->reg_idx);\r\ndev_info(&pf->pdev->dev,\r\n" tx_rings[%i]: next_to_use = %d, next_to_clean = %d, ring_active = %i\n",\r\ni,\r\ntx_ring->next_to_use,\r\ntx_ring->next_to_clean,\r\ntx_ring->ring_active);\r\ndev_info(&pf->pdev->dev,\r\n" tx_rings[%i]: tx_stats: packets = %lld, bytes = %lld, restart_queue = %lld\n",\r\ni, tx_ring->stats.packets,\r\ntx_ring->stats.bytes,\r\ntx_ring->tx_stats.restart_queue);\r\ndev_info(&pf->pdev->dev,\r\n" tx_rings[%i]: tx_stats: tx_busy = %lld, tx_done_old = %lld\n",\r\ni,\r\ntx_ring->tx_stats.tx_busy,\r\ntx_ring->tx_stats.tx_done_old);\r\ndev_info(&pf->pdev->dev,\r\n" tx_rings[%i]: size = %i, dma = 0x%08lx\n",\r\ni, tx_ring->size,\r\n(unsigned long int)tx_ring->dma);\r\ndev_info(&pf->pdev->dev,\r\n" tx_rings[%i]: vsi = %p, q_vector = %p\n",\r\ni, tx_ring->vsi,\r\ntx_ring->q_vector);\r\ndev_info(&pf->pdev->dev,\r\n" tx_rings[%i]: DCB tc = %d\n",\r\ni, tx_ring->dcb_tc);\r\ndev_info(&pf->pdev->dev,\r\n" tx_rings[%i]: tx_itr_setting = %d (%s)\n",\r\ni, tx_ring->tx_itr_setting,\r\nITR_IS_DYNAMIC(tx_ring->tx_itr_setting) ? "dynamic" : "fixed");\r\n}\r\nrcu_read_unlock();\r\ndev_info(&pf->pdev->dev,\r\n" work_limit = %d\n",\r\nvsi->work_limit);\r\ndev_info(&pf->pdev->dev,\r\n" max_frame = %d, rx_buf_len = %d dtype = %d\n",\r\nvsi->max_frame, vsi->rx_buf_len, 0);\r\ndev_info(&pf->pdev->dev,\r\n" num_q_vectors = %i, base_vector = %i\n",\r\nvsi->num_q_vectors, vsi->base_vector);\r\ndev_info(&pf->pdev->dev,\r\n" seid = %d, id = %d, uplink_seid = %d\n",\r\nvsi->seid, vsi->id, vsi->uplink_seid);\r\ndev_info(&pf->pdev->dev,\r\n" base_queue = %d, num_queue_pairs = %d, num_desc = %d\n",\r\nvsi->base_queue, vsi->num_queue_pairs, vsi->num_desc);\r\ndev_info(&pf->pdev->dev, " type = %i\n", vsi->type);\r\nif (vsi->type == I40E_VSI_SRIOV)\r\ndev_info(&pf->pdev->dev, " VF ID = %i\n", vsi->vf_id);\r\ndev_info(&pf->pdev->dev,\r\n" info: valid_sections = 0x%04x, switch_id = 0x%04x\n",\r\nvsi->info.valid_sections, vsi->info.switch_id);\r\ndev_info(&pf->pdev->dev,\r\n" info: sw_reserved[] = 0x%02x 0x%02x\n",\r\nvsi->info.sw_reserved[0], vsi->info.sw_reserved[1]);\r\ndev_info(&pf->pdev->dev,\r\n" info: sec_flags = 0x%02x, sec_reserved = 0x%02x\n",\r\nvsi->info.sec_flags, vsi->info.sec_reserved);\r\ndev_info(&pf->pdev->dev,\r\n" info: pvid = 0x%04x, fcoe_pvid = 0x%04x, port_vlan_flags = 0x%02x\n",\r\nvsi->info.pvid, vsi->info.fcoe_pvid,\r\nvsi->info.port_vlan_flags);\r\ndev_info(&pf->pdev->dev,\r\n" info: pvlan_reserved[] = 0x%02x 0x%02x 0x%02x\n",\r\nvsi->info.pvlan_reserved[0], vsi->info.pvlan_reserved[1],\r\nvsi->info.pvlan_reserved[2]);\r\ndev_info(&pf->pdev->dev,\r\n" info: ingress_table = 0x%08x, egress_table = 0x%08x\n",\r\nvsi->info.ingress_table, vsi->info.egress_table);\r\ndev_info(&pf->pdev->dev,\r\n" info: cas_pv_stag = 0x%04x, cas_pv_flags= 0x%02x, cas_pv_reserved = 0x%02x\n",\r\nvsi->info.cas_pv_tag, vsi->info.cas_pv_flags,\r\nvsi->info.cas_pv_reserved);\r\ndev_info(&pf->pdev->dev,\r\n" info: queue_mapping[0..7 ] = 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x\n",\r\nvsi->info.queue_mapping[0], vsi->info.queue_mapping[1],\r\nvsi->info.queue_mapping[2], vsi->info.queue_mapping[3],\r\nvsi->info.queue_mapping[4], vsi->info.queue_mapping[5],\r\nvsi->info.queue_mapping[6], vsi->info.queue_mapping[7]);\r\ndev_info(&pf->pdev->dev,\r\n" info: queue_mapping[8..15] = 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x\n",\r\nvsi->info.queue_mapping[8], vsi->info.queue_mapping[9],\r\nvsi->info.queue_mapping[10], vsi->info.queue_mapping[11],\r\nvsi->info.queue_mapping[12], vsi->info.queue_mapping[13],\r\nvsi->info.queue_mapping[14], vsi->info.queue_mapping[15]);\r\ndev_info(&pf->pdev->dev,\r\n" info: tc_mapping[] = 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x\n",\r\nvsi->info.tc_mapping[0], vsi->info.tc_mapping[1],\r\nvsi->info.tc_mapping[2], vsi->info.tc_mapping[3],\r\nvsi->info.tc_mapping[4], vsi->info.tc_mapping[5],\r\nvsi->info.tc_mapping[6], vsi->info.tc_mapping[7]);\r\ndev_info(&pf->pdev->dev,\r\n" info: queueing_opt_flags = 0x%02x queueing_opt_reserved[0..2] = 0x%02x 0x%02x 0x%02x\n",\r\nvsi->info.queueing_opt_flags,\r\nvsi->info.queueing_opt_reserved[0],\r\nvsi->info.queueing_opt_reserved[1],\r\nvsi->info.queueing_opt_reserved[2]);\r\ndev_info(&pf->pdev->dev,\r\n" info: up_enable_bits = 0x%02x\n",\r\nvsi->info.up_enable_bits);\r\ndev_info(&pf->pdev->dev,\r\n" info: sched_reserved = 0x%02x, outer_up_table = 0x%04x\n",\r\nvsi->info.sched_reserved, vsi->info.outer_up_table);\r\ndev_info(&pf->pdev->dev,\r\n" info: cmd_reserved[] = 0x%02x 0x%02x 0x%02x 0x0%02x 0x%02x 0x%02x 0x%02x 0x0%02x\n",\r\nvsi->info.cmd_reserved[0], vsi->info.cmd_reserved[1],\r\nvsi->info.cmd_reserved[2], vsi->info.cmd_reserved[3],\r\nvsi->info.cmd_reserved[4], vsi->info.cmd_reserved[5],\r\nvsi->info.cmd_reserved[6], vsi->info.cmd_reserved[7]);\r\ndev_info(&pf->pdev->dev,\r\n" info: qs_handle[] = 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x\n",\r\nvsi->info.qs_handle[0], vsi->info.qs_handle[1],\r\nvsi->info.qs_handle[2], vsi->info.qs_handle[3],\r\nvsi->info.qs_handle[4], vsi->info.qs_handle[5],\r\nvsi->info.qs_handle[6], vsi->info.qs_handle[7]);\r\ndev_info(&pf->pdev->dev,\r\n" info: stat_counter_idx = 0x%04x, sched_id = 0x%04x\n",\r\nvsi->info.stat_counter_idx, vsi->info.sched_id);\r\ndev_info(&pf->pdev->dev,\r\n" info: resp_reserved[] = 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x\n",\r\nvsi->info.resp_reserved[0], vsi->info.resp_reserved[1],\r\nvsi->info.resp_reserved[2], vsi->info.resp_reserved[3],\r\nvsi->info.resp_reserved[4], vsi->info.resp_reserved[5],\r\nvsi->info.resp_reserved[6], vsi->info.resp_reserved[7],\r\nvsi->info.resp_reserved[8], vsi->info.resp_reserved[9],\r\nvsi->info.resp_reserved[10], vsi->info.resp_reserved[11]);\r\nif (vsi->back)\r\ndev_info(&pf->pdev->dev, " PF = %p\n", vsi->back);\r\ndev_info(&pf->pdev->dev, " idx = %d\n", vsi->idx);\r\ndev_info(&pf->pdev->dev,\r\n" tc_config: numtc = %d, enabled_tc = 0x%x\n",\r\nvsi->tc_config.numtc, vsi->tc_config.enabled_tc);\r\nfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {\r\ndev_info(&pf->pdev->dev,\r\n" tc_config: tc = %d, qoffset = %d, qcount = %d, netdev_tc = %d\n",\r\ni, vsi->tc_config.tc_info[i].qoffset,\r\nvsi->tc_config.tc_info[i].qcount,\r\nvsi->tc_config.tc_info[i].netdev_tc);\r\n}\r\ndev_info(&pf->pdev->dev,\r\n" bw: bw_limit = %d, bw_max_quanta = %d\n",\r\nvsi->bw_limit, vsi->bw_max_quanta);\r\nfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {\r\ndev_info(&pf->pdev->dev,\r\n" bw[%d]: ets_share_credits = %d, ets_limit_credits = %d, max_quanta = %d\n",\r\ni, vsi->bw_ets_share_credits[i],\r\nvsi->bw_ets_limit_credits[i],\r\nvsi->bw_ets_max_quanta[i]);\r\n}\r\n}\r\nstatic void i40e_dbg_dump_aq_desc(struct i40e_pf *pf)\r\n{\r\nstruct i40e_adminq_ring *ring;\r\nstruct i40e_hw *hw = &pf->hw;\r\nchar hdr[32];\r\nint i;\r\nsnprintf(hdr, sizeof(hdr), "%s %s: ",\r\ndev_driver_string(&pf->pdev->dev),\r\ndev_name(&pf->pdev->dev));\r\ndev_info(&pf->pdev->dev, "AdminQ Tx Ring\n");\r\nring = &(hw->aq.asq);\r\nfor (i = 0; i < ring->count; i++) {\r\nstruct i40e_aq_desc *d = I40E_ADMINQ_DESC(*ring, i);\r\ndev_info(&pf->pdev->dev,\r\n" at[%02d] flags=0x%04x op=0x%04x dlen=0x%04x ret=0x%04x cookie_h=0x%08x cookie_l=0x%08x\n",\r\ni, d->flags, d->opcode, d->datalen, d->retval,\r\nd->cookie_high, d->cookie_low);\r\nprint_hex_dump(KERN_INFO, hdr, DUMP_PREFIX_NONE,\r\n16, 1, d->params.raw, 16, 0);\r\n}\r\ndev_info(&pf->pdev->dev, "AdminQ Rx Ring\n");\r\nring = &(hw->aq.arq);\r\nfor (i = 0; i < ring->count; i++) {\r\nstruct i40e_aq_desc *d = I40E_ADMINQ_DESC(*ring, i);\r\ndev_info(&pf->pdev->dev,\r\n" ar[%02d] flags=0x%04x op=0x%04x dlen=0x%04x ret=0x%04x cookie_h=0x%08x cookie_l=0x%08x\n",\r\ni, d->flags, d->opcode, d->datalen, d->retval,\r\nd->cookie_high, d->cookie_low);\r\nprint_hex_dump(KERN_INFO, hdr, DUMP_PREFIX_NONE,\r\n16, 1, d->params.raw, 16, 0);\r\n}\r\n}\r\nstatic void i40e_dbg_dump_desc(int cnt, int vsi_seid, int ring_id, int desc_n,\r\nstruct i40e_pf *pf, bool is_rx_ring)\r\n{\r\nstruct i40e_tx_desc *txd;\r\nunion i40e_rx_desc *rxd;\r\nstruct i40e_ring *ring;\r\nstruct i40e_vsi *vsi;\r\nint i;\r\nvsi = i40e_dbg_find_vsi(pf, vsi_seid);\r\nif (!vsi) {\r\ndev_info(&pf->pdev->dev, "vsi %d not found\n", vsi_seid);\r\nreturn;\r\n}\r\nif (ring_id >= vsi->num_queue_pairs || ring_id < 0) {\r\ndev_info(&pf->pdev->dev, "ring %d not found\n", ring_id);\r\nreturn;\r\n}\r\nif (!vsi->tx_rings || !vsi->tx_rings[0]->desc) {\r\ndev_info(&pf->pdev->dev,\r\n"descriptor rings have not been allocated for vsi %d\n",\r\nvsi_seid);\r\nreturn;\r\n}\r\nring = kmemdup(is_rx_ring\r\n? vsi->rx_rings[ring_id] : vsi->tx_rings[ring_id],\r\nsizeof(*ring), GFP_KERNEL);\r\nif (!ring)\r\nreturn;\r\nif (cnt == 2) {\r\ndev_info(&pf->pdev->dev, "vsi = %02i %s ring = %02i\n",\r\nvsi_seid, is_rx_ring ? "rx" : "tx", ring_id);\r\nfor (i = 0; i < ring->count; i++) {\r\nif (!is_rx_ring) {\r\ntxd = I40E_TX_DESC(ring, i);\r\ndev_info(&pf->pdev->dev,\r\n" d[%03x] = 0x%016llx 0x%016llx\n",\r\ni, txd->buffer_addr,\r\ntxd->cmd_type_offset_bsz);\r\n} else {\r\nrxd = I40E_RX_DESC(ring, i);\r\ndev_info(&pf->pdev->dev,\r\n" d[%03x] = 0x%016llx 0x%016llx 0x%016llx 0x%016llx\n",\r\ni, rxd->read.pkt_addr,\r\nrxd->read.hdr_addr,\r\nrxd->read.rsvd1, rxd->read.rsvd2);\r\n}\r\n}\r\n} else if (cnt == 3) {\r\nif (desc_n >= ring->count || desc_n < 0) {\r\ndev_info(&pf->pdev->dev,\r\n"descriptor %d not found\n", desc_n);\r\ngoto out;\r\n}\r\nif (!is_rx_ring) {\r\ntxd = I40E_TX_DESC(ring, desc_n);\r\ndev_info(&pf->pdev->dev,\r\n"vsi = %02i tx ring = %02i d[%03x] = 0x%016llx 0x%016llx\n",\r\nvsi_seid, ring_id, desc_n,\r\ntxd->buffer_addr, txd->cmd_type_offset_bsz);\r\n} else {\r\nrxd = I40E_RX_DESC(ring, desc_n);\r\ndev_info(&pf->pdev->dev,\r\n"vsi = %02i rx ring = %02i d[%03x] = 0x%016llx 0x%016llx 0x%016llx 0x%016llx\n",\r\nvsi_seid, ring_id, desc_n,\r\nrxd->read.pkt_addr, rxd->read.hdr_addr,\r\nrxd->read.rsvd1, rxd->read.rsvd2);\r\n}\r\n} else {\r\ndev_info(&pf->pdev->dev, "dump desc rx/tx <vsi_seid> <ring_id> [<desc_n>]\n");\r\n}\r\nout:\r\nkfree(ring);\r\n}\r\nstatic void i40e_dbg_dump_vsi_no_seid(struct i40e_pf *pf)\r\n{\r\nint i;\r\nfor (i = 0; i < pf->num_alloc_vsi; i++)\r\nif (pf->vsi[i])\r\ndev_info(&pf->pdev->dev, "dump vsi[%d]: %d\n",\r\ni, pf->vsi[i]->seid);\r\n}\r\nstatic void i40e_dbg_dump_eth_stats(struct i40e_pf *pf,\r\nstruct i40e_eth_stats *estats)\r\n{\r\ndev_info(&pf->pdev->dev, " ethstats:\n");\r\ndev_info(&pf->pdev->dev,\r\n" rx_bytes = \t%lld \trx_unicast = \t\t%lld \trx_multicast = \t%lld\n",\r\nestats->rx_bytes, estats->rx_unicast, estats->rx_multicast);\r\ndev_info(&pf->pdev->dev,\r\n" rx_broadcast = \t%lld \trx_discards = \t\t%lld\n",\r\nestats->rx_broadcast, estats->rx_discards);\r\ndev_info(&pf->pdev->dev,\r\n" rx_unknown_protocol = \t%lld \ttx_bytes = \t%lld\n",\r\nestats->rx_unknown_protocol, estats->tx_bytes);\r\ndev_info(&pf->pdev->dev,\r\n" tx_unicast = \t%lld \ttx_multicast = \t\t%lld \ttx_broadcast = \t%lld\n",\r\nestats->tx_unicast, estats->tx_multicast, estats->tx_broadcast);\r\ndev_info(&pf->pdev->dev,\r\n" tx_discards = \t%lld \ttx_errors = \t\t%lld\n",\r\nestats->tx_discards, estats->tx_errors);\r\n}\r\nstatic void i40e_dbg_dump_veb_seid(struct i40e_pf *pf, int seid)\r\n{\r\nstruct i40e_veb *veb;\r\nveb = i40e_dbg_find_veb(pf, seid);\r\nif (!veb) {\r\ndev_info(&pf->pdev->dev, "can't find veb %d\n", seid);\r\nreturn;\r\n}\r\ndev_info(&pf->pdev->dev,\r\n"veb idx=%d,%d stats_ic=%d seid=%d uplink=%d mode=%s\n",\r\nveb->idx, veb->veb_idx, veb->stats_idx, veb->seid,\r\nveb->uplink_seid,\r\nveb->bridge_mode == BRIDGE_MODE_VEPA ? "VEPA" : "VEB");\r\ni40e_dbg_dump_eth_stats(pf, &veb->stats);\r\n}\r\nstatic void i40e_dbg_dump_veb_all(struct i40e_pf *pf)\r\n{\r\nstruct i40e_veb *veb;\r\nint i;\r\nfor (i = 0; i < I40E_MAX_VEB; i++) {\r\nveb = pf->veb[i];\r\nif (veb)\r\ni40e_dbg_dump_veb_seid(pf, veb->seid);\r\n}\r\n}\r\nstatic void i40e_dbg_dump_vf(struct i40e_pf *pf, int vf_id)\r\n{\r\nstruct i40e_vf *vf;\r\nstruct i40e_vsi *vsi;\r\nif (!pf->num_alloc_vfs) {\r\ndev_info(&pf->pdev->dev, "no VFs allocated\n");\r\n} else if ((vf_id >= 0) && (vf_id < pf->num_alloc_vfs)) {\r\nvf = &pf->vf[vf_id];\r\nvsi = pf->vsi[vf->lan_vsi_idx];\r\ndev_info(&pf->pdev->dev, "vf %2d: VSI id=%d, seid=%d, qps=%d\n",\r\nvf_id, vf->lan_vsi_id, vsi->seid, vf->num_queue_pairs);\r\ndev_info(&pf->pdev->dev, " num MDD=%lld, invalid msg=%lld, valid msg=%lld\n",\r\nvf->num_mdd_events,\r\nvf->num_invalid_msgs,\r\nvf->num_valid_msgs);\r\n} else {\r\ndev_info(&pf->pdev->dev, "invalid VF id %d\n", vf_id);\r\n}\r\n}\r\nstatic void i40e_dbg_dump_vf_all(struct i40e_pf *pf)\r\n{\r\nint i;\r\nif (!pf->num_alloc_vfs)\r\ndev_info(&pf->pdev->dev, "no VFs enabled!\n");\r\nelse\r\nfor (i = 0; i < pf->num_alloc_vfs; i++)\r\ni40e_dbg_dump_vf(pf, i);\r\n}\r\nstatic ssize_t i40e_dbg_command_write(struct file *filp,\r\nconst char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct i40e_pf *pf = filp->private_data;\r\nchar *cmd_buf, *cmd_buf_tmp;\r\nint bytes_not_copied;\r\nstruct i40e_vsi *vsi;\r\nint vsi_seid;\r\nint veb_seid;\r\nint vf_id;\r\nint cnt;\r\nif (*ppos != 0)\r\nreturn 0;\r\ncmd_buf = kzalloc(count + 1, GFP_KERNEL);\r\nif (!cmd_buf)\r\nreturn count;\r\nbytes_not_copied = copy_from_user(cmd_buf, buffer, count);\r\nif (bytes_not_copied) {\r\nkfree(cmd_buf);\r\nreturn -EFAULT;\r\n}\r\ncmd_buf[count] = '\0';\r\ncmd_buf_tmp = strchr(cmd_buf, '\n');\r\nif (cmd_buf_tmp) {\r\n*cmd_buf_tmp = '\0';\r\ncount = cmd_buf_tmp - cmd_buf + 1;\r\n}\r\nif (strncmp(cmd_buf, "add vsi", 7) == 0) {\r\nvsi_seid = -1;\r\ncnt = sscanf(&cmd_buf[7], "%i", &vsi_seid);\r\nif (cnt == 0) {\r\nvsi_seid = pf->vsi[pf->lan_vsi]->seid;\r\n} else if (vsi_seid < 0) {\r\ndev_info(&pf->pdev->dev, "add VSI %d: bad vsi seid\n",\r\nvsi_seid);\r\ngoto command_write_done;\r\n}\r\nif (!(pf->flags & I40E_FLAG_VEB_MODE_ENABLED)) {\r\npf->flags |= I40E_FLAG_VEB_MODE_ENABLED;\r\ni40e_do_reset_safe(pf,\r\nBIT_ULL(__I40E_PF_RESET_REQUESTED));\r\n}\r\nvsi = i40e_vsi_setup(pf, I40E_VSI_VMDQ2, vsi_seid, 0);\r\nif (vsi)\r\ndev_info(&pf->pdev->dev, "added VSI %d to relay %d\n",\r\nvsi->seid, vsi->uplink_seid);\r\nelse\r\ndev_info(&pf->pdev->dev, "'%s' failed\n", cmd_buf);\r\n} else if (strncmp(cmd_buf, "del vsi", 7) == 0) {\r\ncnt = sscanf(&cmd_buf[7], "%i", &vsi_seid);\r\nif (cnt != 1) {\r\ndev_info(&pf->pdev->dev,\r\n"del vsi: bad command string, cnt=%d\n",\r\ncnt);\r\ngoto command_write_done;\r\n}\r\nvsi = i40e_dbg_find_vsi(pf, vsi_seid);\r\nif (!vsi) {\r\ndev_info(&pf->pdev->dev, "del VSI %d: seid not found\n",\r\nvsi_seid);\r\ngoto command_write_done;\r\n}\r\ndev_info(&pf->pdev->dev, "deleting VSI %d\n", vsi_seid);\r\ni40e_vsi_release(vsi);\r\n} else if (strncmp(cmd_buf, "add relay", 9) == 0) {\r\nstruct i40e_veb *veb;\r\nint uplink_seid, i;\r\ncnt = sscanf(&cmd_buf[9], "%i %i", &uplink_seid, &vsi_seid);\r\nif (cnt != 2) {\r\ndev_info(&pf->pdev->dev,\r\n"add relay: bad command string, cnt=%d\n",\r\ncnt);\r\ngoto command_write_done;\r\n} else if (uplink_seid < 0) {\r\ndev_info(&pf->pdev->dev,\r\n"add relay %d: bad uplink seid\n",\r\nuplink_seid);\r\ngoto command_write_done;\r\n}\r\nvsi = i40e_dbg_find_vsi(pf, vsi_seid);\r\nif (!vsi) {\r\ndev_info(&pf->pdev->dev,\r\n"add relay: VSI %d not found\n", vsi_seid);\r\ngoto command_write_done;\r\n}\r\nfor (i = 0; i < I40E_MAX_VEB; i++)\r\nif (pf->veb[i] && pf->veb[i]->seid == uplink_seid)\r\nbreak;\r\nif (i >= I40E_MAX_VEB && uplink_seid != 0 &&\r\nuplink_seid != pf->mac_seid) {\r\ndev_info(&pf->pdev->dev,\r\n"add relay: relay uplink %d not found\n",\r\nuplink_seid);\r\ngoto command_write_done;\r\n}\r\nveb = i40e_veb_setup(pf, 0, uplink_seid, vsi_seid,\r\nvsi->tc_config.enabled_tc);\r\nif (veb)\r\ndev_info(&pf->pdev->dev, "added relay %d\n", veb->seid);\r\nelse\r\ndev_info(&pf->pdev->dev, "add relay failed\n");\r\n} else if (strncmp(cmd_buf, "del relay", 9) == 0) {\r\nint i;\r\ncnt = sscanf(&cmd_buf[9], "%i", &veb_seid);\r\nif (cnt != 1) {\r\ndev_info(&pf->pdev->dev,\r\n"del relay: bad command string, cnt=%d\n",\r\ncnt);\r\ngoto command_write_done;\r\n} else if (veb_seid < 0) {\r\ndev_info(&pf->pdev->dev,\r\n"del relay %d: bad relay seid\n", veb_seid);\r\ngoto command_write_done;\r\n}\r\nfor (i = 0; i < I40E_MAX_VEB; i++)\r\nif (pf->veb[i] && pf->veb[i]->seid == veb_seid)\r\nbreak;\r\nif (i >= I40E_MAX_VEB) {\r\ndev_info(&pf->pdev->dev,\r\n"del relay: relay %d not found\n", veb_seid);\r\ngoto command_write_done;\r\n}\r\ndev_info(&pf->pdev->dev, "deleting relay %d\n", veb_seid);\r\ni40e_veb_release(pf->veb[i]);\r\n} else if (strncmp(cmd_buf, "add pvid", 8) == 0) {\r\ni40e_status ret;\r\nu16 vid;\r\nunsigned int v;\r\ncnt = sscanf(&cmd_buf[8], "%i %u", &vsi_seid, &v);\r\nif (cnt != 2) {\r\ndev_info(&pf->pdev->dev,\r\n"add pvid: bad command string, cnt=%d\n", cnt);\r\ngoto command_write_done;\r\n}\r\nvsi = i40e_dbg_find_vsi(pf, vsi_seid);\r\nif (!vsi) {\r\ndev_info(&pf->pdev->dev, "add pvid: VSI %d not found\n",\r\nvsi_seid);\r\ngoto command_write_done;\r\n}\r\nvid = v;\r\nret = i40e_vsi_add_pvid(vsi, vid);\r\nif (!ret)\r\ndev_info(&pf->pdev->dev,\r\n"add pvid: %d added to VSI %d\n",\r\nvid, vsi_seid);\r\nelse\r\ndev_info(&pf->pdev->dev,\r\n"add pvid: %d to VSI %d failed, ret=%d\n",\r\nvid, vsi_seid, ret);\r\n} else if (strncmp(cmd_buf, "del pvid", 8) == 0) {\r\ncnt = sscanf(&cmd_buf[8], "%i", &vsi_seid);\r\nif (cnt != 1) {\r\ndev_info(&pf->pdev->dev,\r\n"del pvid: bad command string, cnt=%d\n",\r\ncnt);\r\ngoto command_write_done;\r\n}\r\nvsi = i40e_dbg_find_vsi(pf, vsi_seid);\r\nif (!vsi) {\r\ndev_info(&pf->pdev->dev,\r\n"del pvid: VSI %d not found\n", vsi_seid);\r\ngoto command_write_done;\r\n}\r\ni40e_vsi_remove_pvid(vsi);\r\ndev_info(&pf->pdev->dev,\r\n"del pvid: removed from VSI %d\n", vsi_seid);\r\n} else if (strncmp(cmd_buf, "dump", 4) == 0) {\r\nif (strncmp(&cmd_buf[5], "switch", 6) == 0) {\r\ni40e_fetch_switch_configuration(pf, true);\r\n} else if (strncmp(&cmd_buf[5], "vsi", 3) == 0) {\r\ncnt = sscanf(&cmd_buf[8], "%i", &vsi_seid);\r\nif (cnt > 0)\r\ni40e_dbg_dump_vsi_seid(pf, vsi_seid);\r\nelse\r\ni40e_dbg_dump_vsi_no_seid(pf);\r\n} else if (strncmp(&cmd_buf[5], "veb", 3) == 0) {\r\ncnt = sscanf(&cmd_buf[8], "%i", &vsi_seid);\r\nif (cnt > 0)\r\ni40e_dbg_dump_veb_seid(pf, vsi_seid);\r\nelse\r\ni40e_dbg_dump_veb_all(pf);\r\n} else if (strncmp(&cmd_buf[5], "vf", 2) == 0) {\r\ncnt = sscanf(&cmd_buf[7], "%i", &vf_id);\r\nif (cnt > 0)\r\ni40e_dbg_dump_vf(pf, vf_id);\r\nelse\r\ni40e_dbg_dump_vf_all(pf);\r\n} else if (strncmp(&cmd_buf[5], "desc", 4) == 0) {\r\nint ring_id, desc_n;\r\nif (strncmp(&cmd_buf[10], "rx", 2) == 0) {\r\ncnt = sscanf(&cmd_buf[12], "%i %i %i",\r\n&vsi_seid, &ring_id, &desc_n);\r\ni40e_dbg_dump_desc(cnt, vsi_seid, ring_id,\r\ndesc_n, pf, true);\r\n} else if (strncmp(&cmd_buf[10], "tx", 2)\r\n== 0) {\r\ncnt = sscanf(&cmd_buf[12], "%i %i %i",\r\n&vsi_seid, &ring_id, &desc_n);\r\ni40e_dbg_dump_desc(cnt, vsi_seid, ring_id,\r\ndesc_n, pf, false);\r\n} else if (strncmp(&cmd_buf[10], "aq", 2) == 0) {\r\ni40e_dbg_dump_aq_desc(pf);\r\n} else {\r\ndev_info(&pf->pdev->dev,\r\n"dump desc tx <vsi_seid> <ring_id> [<desc_n>]\n");\r\ndev_info(&pf->pdev->dev,\r\n"dump desc rx <vsi_seid> <ring_id> [<desc_n>]\n");\r\ndev_info(&pf->pdev->dev, "dump desc aq\n");\r\n}\r\n} else if (strncmp(&cmd_buf[5], "reset stats", 11) == 0) {\r\ndev_info(&pf->pdev->dev,\r\n"core reset count: %d\n", pf->corer_count);\r\ndev_info(&pf->pdev->dev,\r\n"global reset count: %d\n", pf->globr_count);\r\ndev_info(&pf->pdev->dev,\r\n"emp reset count: %d\n", pf->empr_count);\r\ndev_info(&pf->pdev->dev,\r\n"pf reset count: %d\n", pf->pfr_count);\r\ndev_info(&pf->pdev->dev,\r\n"pf tx sluggish count: %d\n",\r\npf->tx_sluggish_count);\r\n} else if (strncmp(&cmd_buf[5], "port", 4) == 0) {\r\nstruct i40e_aqc_query_port_ets_config_resp *bw_data;\r\nstruct i40e_dcbx_config *cfg =\r\n&pf->hw.local_dcbx_config;\r\nstruct i40e_dcbx_config *r_cfg =\r\n&pf->hw.remote_dcbx_config;\r\nint i, ret;\r\nu16 switch_id;\r\nbw_data = kzalloc(sizeof(\r\nstruct i40e_aqc_query_port_ets_config_resp),\r\nGFP_KERNEL);\r\nif (!bw_data) {\r\nret = -ENOMEM;\r\ngoto command_write_done;\r\n}\r\nvsi = pf->vsi[pf->lan_vsi];\r\nswitch_id =\r\nle16_to_cpu(vsi->info.switch_id) &\r\nI40E_AQ_VSI_SW_ID_MASK;\r\nret = i40e_aq_query_port_ets_config(&pf->hw,\r\nswitch_id,\r\nbw_data, NULL);\r\nif (ret) {\r\ndev_info(&pf->pdev->dev,\r\n"Query Port ETS Config AQ command failed =0x%x\n",\r\npf->hw.aq.asq_last_status);\r\nkfree(bw_data);\r\nbw_data = NULL;\r\ngoto command_write_done;\r\n}\r\ndev_info(&pf->pdev->dev,\r\n"port bw: tc_valid=0x%x tc_strict_prio=0x%x, tc_bw_max=0x%04x,0x%04x\n",\r\nbw_data->tc_valid_bits,\r\nbw_data->tc_strict_priority_bits,\r\nle16_to_cpu(bw_data->tc_bw_max[0]),\r\nle16_to_cpu(bw_data->tc_bw_max[1]));\r\nfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {\r\ndev_info(&pf->pdev->dev, "port bw: tc_bw_share=%d tc_bw_limit=%d\n",\r\nbw_data->tc_bw_share_credits[i],\r\nle16_to_cpu(bw_data->tc_bw_limits[i]));\r\n}\r\nkfree(bw_data);\r\nbw_data = NULL;\r\ndev_info(&pf->pdev->dev,\r\n"port dcbx_mode=%d\n", cfg->dcbx_mode);\r\ndev_info(&pf->pdev->dev,\r\n"port ets_cfg: willing=%d cbs=%d, maxtcs=%d\n",\r\ncfg->etscfg.willing, cfg->etscfg.cbs,\r\ncfg->etscfg.maxtcs);\r\nfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {\r\ndev_info(&pf->pdev->dev, "port ets_cfg: %d prio_tc=%d tcbw=%d tctsa=%d\n",\r\ni, cfg->etscfg.prioritytable[i],\r\ncfg->etscfg.tcbwtable[i],\r\ncfg->etscfg.tsatable[i]);\r\n}\r\nfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {\r\ndev_info(&pf->pdev->dev, "port ets_rec: %d prio_tc=%d tcbw=%d tctsa=%d\n",\r\ni, cfg->etsrec.prioritytable[i],\r\ncfg->etsrec.tcbwtable[i],\r\ncfg->etsrec.tsatable[i]);\r\n}\r\ndev_info(&pf->pdev->dev,\r\n"port pfc_cfg: willing=%d mbc=%d, pfccap=%d pfcenable=0x%x\n",\r\ncfg->pfc.willing, cfg->pfc.mbc,\r\ncfg->pfc.pfccap, cfg->pfc.pfcenable);\r\ndev_info(&pf->pdev->dev,\r\n"port app_table: num_apps=%d\n", cfg->numapps);\r\nfor (i = 0; i < cfg->numapps; i++) {\r\ndev_info(&pf->pdev->dev, "port app_table: %d prio=%d selector=%d protocol=0x%x\n",\r\ni, cfg->app[i].priority,\r\ncfg->app[i].selector,\r\ncfg->app[i].protocolid);\r\n}\r\ndev_info(&pf->pdev->dev,\r\n"remote port ets_cfg: willing=%d cbs=%d, maxtcs=%d\n",\r\nr_cfg->etscfg.willing,\r\nr_cfg->etscfg.cbs, r_cfg->etscfg.maxtcs);\r\nfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {\r\ndev_info(&pf->pdev->dev, "remote port ets_cfg: %d prio_tc=%d tcbw=%d tctsa=%d\n",\r\ni, r_cfg->etscfg.prioritytable[i],\r\nr_cfg->etscfg.tcbwtable[i],\r\nr_cfg->etscfg.tsatable[i]);\r\n}\r\nfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {\r\ndev_info(&pf->pdev->dev, "remote port ets_rec: %d prio_tc=%d tcbw=%d tctsa=%d\n",\r\ni, r_cfg->etsrec.prioritytable[i],\r\nr_cfg->etsrec.tcbwtable[i],\r\nr_cfg->etsrec.tsatable[i]);\r\n}\r\ndev_info(&pf->pdev->dev,\r\n"remote port pfc_cfg: willing=%d mbc=%d, pfccap=%d pfcenable=0x%x\n",\r\nr_cfg->pfc.willing,\r\nr_cfg->pfc.mbc,\r\nr_cfg->pfc.pfccap,\r\nr_cfg->pfc.pfcenable);\r\ndev_info(&pf->pdev->dev,\r\n"remote port app_table: num_apps=%d\n",\r\nr_cfg->numapps);\r\nfor (i = 0; i < r_cfg->numapps; i++) {\r\ndev_info(&pf->pdev->dev, "remote port app_table: %d prio=%d selector=%d protocol=0x%x\n",\r\ni, r_cfg->app[i].priority,\r\nr_cfg->app[i].selector,\r\nr_cfg->app[i].protocolid);\r\n}\r\n} else if (strncmp(&cmd_buf[5], "debug fwdata", 12) == 0) {\r\nint cluster_id, table_id;\r\nint index, ret;\r\nu16 buff_len = 4096;\r\nu32 next_index;\r\nu8 next_table;\r\nu8 *buff;\r\nu16 rlen;\r\ncnt = sscanf(&cmd_buf[18], "%i %i %i",\r\n&cluster_id, &table_id, &index);\r\nif (cnt != 3) {\r\ndev_info(&pf->pdev->dev,\r\n"dump debug fwdata <cluster_id> <table_id> <index>\n");\r\ngoto command_write_done;\r\n}\r\ndev_info(&pf->pdev->dev,\r\n"AQ debug dump fwdata params %x %x %x %x\n",\r\ncluster_id, table_id, index, buff_len);\r\nbuff = kzalloc(buff_len, GFP_KERNEL);\r\nif (!buff)\r\ngoto command_write_done;\r\nret = i40e_aq_debug_dump(&pf->hw, cluster_id, table_id,\r\nindex, buff_len, buff, &rlen,\r\n&next_table, &next_index,\r\nNULL);\r\nif (ret) {\r\ndev_info(&pf->pdev->dev,\r\n"debug dump fwdata AQ Failed %d 0x%x\n",\r\nret, pf->hw.aq.asq_last_status);\r\nkfree(buff);\r\nbuff = NULL;\r\ngoto command_write_done;\r\n}\r\ndev_info(&pf->pdev->dev,\r\n"AQ debug dump fwdata rlen=0x%x next_table=0x%x next_index=0x%x\n",\r\nrlen, next_table, next_index);\r\nprint_hex_dump(KERN_INFO, "AQ buffer WB: ",\r\nDUMP_PREFIX_OFFSET, 16, 1,\r\nbuff, rlen, true);\r\nkfree(buff);\r\nbuff = NULL;\r\n} else {\r\ndev_info(&pf->pdev->dev,\r\n"dump desc tx <vsi_seid> <ring_id> [<desc_n>], dump desc rx <vsi_seid> <ring_id> [<desc_n>],\n");\r\ndev_info(&pf->pdev->dev, "dump switch\n");\r\ndev_info(&pf->pdev->dev, "dump vsi [seid]\n");\r\ndev_info(&pf->pdev->dev, "dump reset stats\n");\r\ndev_info(&pf->pdev->dev, "dump port\n");\r\ndev_info(&pf->pdev->dev, "dump vf [vf_id]\n");\r\ndev_info(&pf->pdev->dev,\r\n"dump debug fwdata <cluster_id> <table_id> <index>\n");\r\n}\r\n} else if (strncmp(cmd_buf, "pfr", 3) == 0) {\r\ndev_info(&pf->pdev->dev, "debugfs: forcing PFR\n");\r\ni40e_do_reset_safe(pf, BIT(__I40E_PF_RESET_REQUESTED));\r\n} else if (strncmp(cmd_buf, "corer", 5) == 0) {\r\ndev_info(&pf->pdev->dev, "debugfs: forcing CoreR\n");\r\ni40e_do_reset_safe(pf, BIT(__I40E_CORE_RESET_REQUESTED));\r\n} else if (strncmp(cmd_buf, "globr", 5) == 0) {\r\ndev_info(&pf->pdev->dev, "debugfs: forcing GlobR\n");\r\ni40e_do_reset_safe(pf, BIT(__I40E_GLOBAL_RESET_REQUESTED));\r\n} else if (strncmp(cmd_buf, "empr", 4) == 0) {\r\ndev_info(&pf->pdev->dev, "debugfs: forcing EMPR\n");\r\ni40e_do_reset_safe(pf, BIT(__I40E_EMP_RESET_REQUESTED));\r\n} else if (strncmp(cmd_buf, "read", 4) == 0) {\r\nu32 address;\r\nu32 value;\r\ncnt = sscanf(&cmd_buf[4], "%i", &address);\r\nif (cnt != 1) {\r\ndev_info(&pf->pdev->dev, "read <reg>\n");\r\ngoto command_write_done;\r\n}\r\nif (address > (pf->ioremap_len - sizeof(u32))) {\r\ndev_info(&pf->pdev->dev, "read reg address 0x%08x too large, max=0x%08lx\n",\r\naddress, (unsigned long int)(pf->ioremap_len - sizeof(u32)));\r\ngoto command_write_done;\r\n}\r\nvalue = rd32(&pf->hw, address);\r\ndev_info(&pf->pdev->dev, "read: 0x%08x = 0x%08x\n",\r\naddress, value);\r\n} else if (strncmp(cmd_buf, "write", 5) == 0) {\r\nu32 address, value;\r\ncnt = sscanf(&cmd_buf[5], "%i %i", &address, &value);\r\nif (cnt != 2) {\r\ndev_info(&pf->pdev->dev, "write <reg> <value>\n");\r\ngoto command_write_done;\r\n}\r\nif (address > (pf->ioremap_len - sizeof(u32))) {\r\ndev_info(&pf->pdev->dev, "write reg address 0x%08x too large, max=0x%08lx\n",\r\naddress, (unsigned long int)(pf->ioremap_len - sizeof(u32)));\r\ngoto command_write_done;\r\n}\r\nwr32(&pf->hw, address, value);\r\nvalue = rd32(&pf->hw, address);\r\ndev_info(&pf->pdev->dev, "write: 0x%08x = 0x%08x\n",\r\naddress, value);\r\n} else if (strncmp(cmd_buf, "clear_stats", 11) == 0) {\r\nif (strncmp(&cmd_buf[12], "vsi", 3) == 0) {\r\ncnt = sscanf(&cmd_buf[15], "%i", &vsi_seid);\r\nif (cnt == 0) {\r\nint i;\r\nfor (i = 0; i < pf->num_alloc_vsi; i++)\r\ni40e_vsi_reset_stats(pf->vsi[i]);\r\ndev_info(&pf->pdev->dev, "vsi clear stats called for all vsi's\n");\r\n} else if (cnt == 1) {\r\nvsi = i40e_dbg_find_vsi(pf, vsi_seid);\r\nif (!vsi) {\r\ndev_info(&pf->pdev->dev,\r\n"clear_stats vsi: bad vsi %d\n",\r\nvsi_seid);\r\ngoto command_write_done;\r\n}\r\ni40e_vsi_reset_stats(vsi);\r\ndev_info(&pf->pdev->dev,\r\n"vsi clear stats called for vsi %d\n",\r\nvsi_seid);\r\n} else {\r\ndev_info(&pf->pdev->dev, "clear_stats vsi [seid]\n");\r\n}\r\n} else if (strncmp(&cmd_buf[12], "port", 4) == 0) {\r\nif (pf->hw.partition_id == 1) {\r\ni40e_pf_reset_stats(pf);\r\ndev_info(&pf->pdev->dev, "port stats cleared\n");\r\n} else {\r\ndev_info(&pf->pdev->dev, "clear port stats not allowed on this port partition\n");\r\n}\r\n} else {\r\ndev_info(&pf->pdev->dev, "clear_stats vsi [seid] or clear_stats port\n");\r\n}\r\n} else if (strncmp(cmd_buf, "send aq_cmd", 11) == 0) {\r\nstruct i40e_aq_desc *desc;\r\ni40e_status ret;\r\ndesc = kzalloc(sizeof(struct i40e_aq_desc), GFP_KERNEL);\r\nif (!desc)\r\ngoto command_write_done;\r\ncnt = sscanf(&cmd_buf[11],\r\n"%hi %hi %hi %hi %i %i %i %i %i %i",\r\n&desc->flags,\r\n&desc->opcode, &desc->datalen, &desc->retval,\r\n&desc->cookie_high, &desc->cookie_low,\r\n&desc->params.internal.param0,\r\n&desc->params.internal.param1,\r\n&desc->params.internal.param2,\r\n&desc->params.internal.param3);\r\nif (cnt != 10) {\r\ndev_info(&pf->pdev->dev,\r\n"send aq_cmd: bad command string, cnt=%d\n",\r\ncnt);\r\nkfree(desc);\r\ndesc = NULL;\r\ngoto command_write_done;\r\n}\r\nret = i40e_asq_send_command(&pf->hw, desc, NULL, 0, NULL);\r\nif (!ret) {\r\ndev_info(&pf->pdev->dev, "AQ command sent Status : Success\n");\r\n} else if (ret == I40E_ERR_ADMIN_QUEUE_ERROR) {\r\ndev_info(&pf->pdev->dev,\r\n"AQ command send failed Opcode %x AQ Error: %d\n",\r\ndesc->opcode, pf->hw.aq.asq_last_status);\r\n} else {\r\ndev_info(&pf->pdev->dev,\r\n"AQ command send failed Opcode %x Status: %d\n",\r\ndesc->opcode, ret);\r\n}\r\ndev_info(&pf->pdev->dev,\r\n"AQ desc WB 0x%04x 0x%04x 0x%04x 0x%04x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\n",\r\ndesc->flags, desc->opcode, desc->datalen, desc->retval,\r\ndesc->cookie_high, desc->cookie_low,\r\ndesc->params.internal.param0,\r\ndesc->params.internal.param1,\r\ndesc->params.internal.param2,\r\ndesc->params.internal.param3);\r\nkfree(desc);\r\ndesc = NULL;\r\n} else if (strncmp(cmd_buf, "send indirect aq_cmd", 20) == 0) {\r\nstruct i40e_aq_desc *desc;\r\ni40e_status ret;\r\nu16 buffer_len;\r\nu8 *buff;\r\ndesc = kzalloc(sizeof(struct i40e_aq_desc), GFP_KERNEL);\r\nif (!desc)\r\ngoto command_write_done;\r\ncnt = sscanf(&cmd_buf[20],\r\n"%hi %hi %hi %hi %i %i %i %i %i %i %hi",\r\n&desc->flags,\r\n&desc->opcode, &desc->datalen, &desc->retval,\r\n&desc->cookie_high, &desc->cookie_low,\r\n&desc->params.internal.param0,\r\n&desc->params.internal.param1,\r\n&desc->params.internal.param2,\r\n&desc->params.internal.param3,\r\n&buffer_len);\r\nif (cnt != 11) {\r\ndev_info(&pf->pdev->dev,\r\n"send indirect aq_cmd: bad command string, cnt=%d\n",\r\ncnt);\r\nkfree(desc);\r\ndesc = NULL;\r\ngoto command_write_done;\r\n}\r\nif (buffer_len == 0)\r\nbuffer_len = 1280;\r\nbuff = kzalloc(buffer_len, GFP_KERNEL);\r\nif (!buff) {\r\nkfree(desc);\r\ndesc = NULL;\r\ngoto command_write_done;\r\n}\r\ndesc->flags |= cpu_to_le16((u16)I40E_AQ_FLAG_BUF);\r\nret = i40e_asq_send_command(&pf->hw, desc, buff,\r\nbuffer_len, NULL);\r\nif (!ret) {\r\ndev_info(&pf->pdev->dev, "AQ command sent Status : Success\n");\r\n} else if (ret == I40E_ERR_ADMIN_QUEUE_ERROR) {\r\ndev_info(&pf->pdev->dev,\r\n"AQ command send failed Opcode %x AQ Error: %d\n",\r\ndesc->opcode, pf->hw.aq.asq_last_status);\r\n} else {\r\ndev_info(&pf->pdev->dev,\r\n"AQ command send failed Opcode %x Status: %d\n",\r\ndesc->opcode, ret);\r\n}\r\ndev_info(&pf->pdev->dev,\r\n"AQ desc WB 0x%04x 0x%04x 0x%04x 0x%04x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\n",\r\ndesc->flags, desc->opcode, desc->datalen, desc->retval,\r\ndesc->cookie_high, desc->cookie_low,\r\ndesc->params.internal.param0,\r\ndesc->params.internal.param1,\r\ndesc->params.internal.param2,\r\ndesc->params.internal.param3);\r\nprint_hex_dump(KERN_INFO, "AQ buffer WB: ",\r\nDUMP_PREFIX_OFFSET, 16, 1,\r\nbuff, buffer_len, true);\r\nkfree(buff);\r\nbuff = NULL;\r\nkfree(desc);\r\ndesc = NULL;\r\n} else if (strncmp(cmd_buf, "fd current cnt", 14) == 0) {\r\ndev_info(&pf->pdev->dev, "FD current total filter count for this interface: %d\n",\r\ni40e_get_current_fd_count(pf));\r\n} else if (strncmp(cmd_buf, "lldp", 4) == 0) {\r\nif (strncmp(&cmd_buf[5], "stop", 4) == 0) {\r\nint ret;\r\nret = i40e_aq_stop_lldp(&pf->hw, false, NULL);\r\nif (ret) {\r\ndev_info(&pf->pdev->dev,\r\n"Stop LLDP AQ command failed =0x%x\n",\r\npf->hw.aq.asq_last_status);\r\ngoto command_write_done;\r\n}\r\nret = i40e_aq_add_rem_control_packet_filter(&pf->hw,\r\npf->hw.mac.addr,\r\nI40E_ETH_P_LLDP, 0,\r\npf->vsi[pf->lan_vsi]->seid,\r\n0, true, NULL, NULL);\r\nif (ret) {\r\ndev_info(&pf->pdev->dev,\r\n"%s: Add Control Packet Filter AQ command failed =0x%x\n",\r\n__func__, pf->hw.aq.asq_last_status);\r\ngoto command_write_done;\r\n}\r\n#ifdef CONFIG_I40E_DCB\r\npf->dcbx_cap = DCB_CAP_DCBX_HOST |\r\nDCB_CAP_DCBX_VER_IEEE;\r\n#endif\r\n} else if (strncmp(&cmd_buf[5], "start", 5) == 0) {\r\nint ret;\r\nret = i40e_aq_add_rem_control_packet_filter(&pf->hw,\r\npf->hw.mac.addr,\r\nI40E_ETH_P_LLDP, 0,\r\npf->vsi[pf->lan_vsi]->seid,\r\n0, false, NULL, NULL);\r\nif (ret) {\r\ndev_info(&pf->pdev->dev,\r\n"%s: Remove Control Packet Filter AQ command failed =0x%x\n",\r\n__func__, pf->hw.aq.asq_last_status);\r\n}\r\nret = i40e_aq_start_lldp(&pf->hw, NULL);\r\nif (ret) {\r\ndev_info(&pf->pdev->dev,\r\n"Start LLDP AQ command failed =0x%x\n",\r\npf->hw.aq.asq_last_status);\r\ngoto command_write_done;\r\n}\r\n#ifdef CONFIG_I40E_DCB\r\npf->dcbx_cap = DCB_CAP_DCBX_LLD_MANAGED |\r\nDCB_CAP_DCBX_VER_IEEE;\r\n#endif\r\n} else if (strncmp(&cmd_buf[5],\r\n"get local", 9) == 0) {\r\nu16 llen, rlen;\r\nint ret;\r\nu8 *buff;\r\nbuff = kzalloc(I40E_LLDPDU_SIZE, GFP_KERNEL);\r\nif (!buff)\r\ngoto command_write_done;\r\nret = i40e_aq_get_lldp_mib(&pf->hw, 0,\r\nI40E_AQ_LLDP_MIB_LOCAL,\r\nbuff, I40E_LLDPDU_SIZE,\r\n&llen, &rlen, NULL);\r\nif (ret) {\r\ndev_info(&pf->pdev->dev,\r\n"Get LLDP MIB (local) AQ command failed =0x%x\n",\r\npf->hw.aq.asq_last_status);\r\nkfree(buff);\r\nbuff = NULL;\r\ngoto command_write_done;\r\n}\r\ndev_info(&pf->pdev->dev, "LLDP MIB (local)\n");\r\nprint_hex_dump(KERN_INFO, "LLDP MIB (local): ",\r\nDUMP_PREFIX_OFFSET, 16, 1,\r\nbuff, I40E_LLDPDU_SIZE, true);\r\nkfree(buff);\r\nbuff = NULL;\r\n} else if (strncmp(&cmd_buf[5], "get remote", 10) == 0) {\r\nu16 llen, rlen;\r\nint ret;\r\nu8 *buff;\r\nbuff = kzalloc(I40E_LLDPDU_SIZE, GFP_KERNEL);\r\nif (!buff)\r\ngoto command_write_done;\r\nret = i40e_aq_get_lldp_mib(&pf->hw,\r\nI40E_AQ_LLDP_BRIDGE_TYPE_NEAREST_BRIDGE,\r\nI40E_AQ_LLDP_MIB_REMOTE,\r\nbuff, I40E_LLDPDU_SIZE,\r\n&llen, &rlen, NULL);\r\nif (ret) {\r\ndev_info(&pf->pdev->dev,\r\n"Get LLDP MIB (remote) AQ command failed =0x%x\n",\r\npf->hw.aq.asq_last_status);\r\nkfree(buff);\r\nbuff = NULL;\r\ngoto command_write_done;\r\n}\r\ndev_info(&pf->pdev->dev, "LLDP MIB (remote)\n");\r\nprint_hex_dump(KERN_INFO, "LLDP MIB (remote): ",\r\nDUMP_PREFIX_OFFSET, 16, 1,\r\nbuff, I40E_LLDPDU_SIZE, true);\r\nkfree(buff);\r\nbuff = NULL;\r\n} else if (strncmp(&cmd_buf[5], "event on", 8) == 0) {\r\nint ret;\r\nret = i40e_aq_cfg_lldp_mib_change_event(&pf->hw,\r\ntrue, NULL);\r\nif (ret) {\r\ndev_info(&pf->pdev->dev,\r\n"Config LLDP MIB Change Event (on) AQ command failed =0x%x\n",\r\npf->hw.aq.asq_last_status);\r\ngoto command_write_done;\r\n}\r\n} else if (strncmp(&cmd_buf[5], "event off", 9) == 0) {\r\nint ret;\r\nret = i40e_aq_cfg_lldp_mib_change_event(&pf->hw,\r\nfalse, NULL);\r\nif (ret) {\r\ndev_info(&pf->pdev->dev,\r\n"Config LLDP MIB Change Event (off) AQ command failed =0x%x\n",\r\npf->hw.aq.asq_last_status);\r\ngoto command_write_done;\r\n}\r\n}\r\n} else if (strncmp(cmd_buf, "nvm read", 8) == 0) {\r\nu16 buffer_len, bytes;\r\nu16 module;\r\nu32 offset;\r\nu16 *buff;\r\nint ret;\r\ncnt = sscanf(&cmd_buf[8], "%hx %x %hx",\r\n&module, &offset, &buffer_len);\r\nif (cnt == 0) {\r\nmodule = 0;\r\noffset = 0;\r\nbuffer_len = 0;\r\n} else if (cnt == 1) {\r\noffset = 0;\r\nbuffer_len = 0;\r\n} else if (cnt == 2) {\r\nbuffer_len = 0;\r\n} else if (cnt > 3) {\r\ndev_info(&pf->pdev->dev,\r\n"nvm read: bad command string, cnt=%d\n", cnt);\r\ngoto command_write_done;\r\n}\r\nbuffer_len = min_t(u16, buffer_len, I40E_MAX_AQ_BUF_SIZE/2);\r\nbytes = 2 * buffer_len;\r\nbytes = clamp(bytes, (u16)1024, (u16)I40E_MAX_AQ_BUF_SIZE);\r\nbuff = kzalloc(bytes, GFP_KERNEL);\r\nif (!buff)\r\ngoto command_write_done;\r\nret = i40e_acquire_nvm(&pf->hw, I40E_RESOURCE_READ);\r\nif (ret) {\r\ndev_info(&pf->pdev->dev,\r\n"Failed Acquiring NVM resource for read err=%d status=0x%x\n",\r\nret, pf->hw.aq.asq_last_status);\r\nkfree(buff);\r\ngoto command_write_done;\r\n}\r\nret = i40e_aq_read_nvm(&pf->hw, module, (2 * offset),\r\nbytes, (u8 *)buff, true, NULL);\r\ni40e_release_nvm(&pf->hw);\r\nif (ret) {\r\ndev_info(&pf->pdev->dev,\r\n"Read NVM AQ failed err=%d status=0x%x\n",\r\nret, pf->hw.aq.asq_last_status);\r\n} else {\r\ndev_info(&pf->pdev->dev,\r\n"Read NVM module=0x%x offset=0x%x words=%d\n",\r\nmodule, offset, buffer_len);\r\nif (bytes)\r\nprint_hex_dump(KERN_INFO, "NVM Dump: ",\r\nDUMP_PREFIX_OFFSET, 16, 2,\r\nbuff, bytes, true);\r\n}\r\nkfree(buff);\r\nbuff = NULL;\r\n} else {\r\ndev_info(&pf->pdev->dev, "unknown command '%s'\n", cmd_buf);\r\ndev_info(&pf->pdev->dev, "available commands\n");\r\ndev_info(&pf->pdev->dev, " add vsi [relay_seid]\n");\r\ndev_info(&pf->pdev->dev, " del vsi [vsi_seid]\n");\r\ndev_info(&pf->pdev->dev, " add relay <uplink_seid> <vsi_seid>\n");\r\ndev_info(&pf->pdev->dev, " del relay <relay_seid>\n");\r\ndev_info(&pf->pdev->dev, " add pvid <vsi_seid> <vid>\n");\r\ndev_info(&pf->pdev->dev, " del pvid <vsi_seid>\n");\r\ndev_info(&pf->pdev->dev, " dump switch\n");\r\ndev_info(&pf->pdev->dev, " dump vsi [seid]\n");\r\ndev_info(&pf->pdev->dev, " dump desc tx <vsi_seid> <ring_id> [<desc_n>]\n");\r\ndev_info(&pf->pdev->dev, " dump desc rx <vsi_seid> <ring_id> [<desc_n>]\n");\r\ndev_info(&pf->pdev->dev, " dump desc aq\n");\r\ndev_info(&pf->pdev->dev, " dump reset stats\n");\r\ndev_info(&pf->pdev->dev, " dump debug fwdata <cluster_id> <table_id> <index>\n");\r\ndev_info(&pf->pdev->dev, " read <reg>\n");\r\ndev_info(&pf->pdev->dev, " write <reg> <value>\n");\r\ndev_info(&pf->pdev->dev, " clear_stats vsi [seid]\n");\r\ndev_info(&pf->pdev->dev, " clear_stats port\n");\r\ndev_info(&pf->pdev->dev, " pfr\n");\r\ndev_info(&pf->pdev->dev, " corer\n");\r\ndev_info(&pf->pdev->dev, " globr\n");\r\ndev_info(&pf->pdev->dev, " send aq_cmd <flags> <opcode> <datalen> <retval> <cookie_h> <cookie_l> <param0> <param1> <param2> <param3>\n");\r\ndev_info(&pf->pdev->dev, " send indirect aq_cmd <flags> <opcode> <datalen> <retval> <cookie_h> <cookie_l> <param0> <param1> <param2> <param3> <buffer_len>\n");\r\ndev_info(&pf->pdev->dev, " fd current cnt");\r\ndev_info(&pf->pdev->dev, " lldp start\n");\r\ndev_info(&pf->pdev->dev, " lldp stop\n");\r\ndev_info(&pf->pdev->dev, " lldp get local\n");\r\ndev_info(&pf->pdev->dev, " lldp get remote\n");\r\ndev_info(&pf->pdev->dev, " lldp event on\n");\r\ndev_info(&pf->pdev->dev, " lldp event off\n");\r\ndev_info(&pf->pdev->dev, " nvm read [module] [word_offset] [word_count]\n");\r\n}\r\ncommand_write_done:\r\nkfree(cmd_buf);\r\ncmd_buf = NULL;\r\nreturn count;\r\n}\r\nstatic ssize_t i40e_dbg_netdev_ops_read(struct file *filp, char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct i40e_pf *pf = filp->private_data;\r\nint bytes_not_copied;\r\nint buf_size = 256;\r\nchar *buf;\r\nint len;\r\nif (*ppos != 0)\r\nreturn 0;\r\nif (count < buf_size)\r\nreturn -ENOSPC;\r\nbuf = kzalloc(buf_size, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOSPC;\r\nlen = snprintf(buf, buf_size, "%s: %s\n",\r\npf->vsi[pf->lan_vsi]->netdev->name,\r\ni40e_dbg_netdev_ops_buf);\r\nbytes_not_copied = copy_to_user(buffer, buf, len);\r\nkfree(buf);\r\nif (bytes_not_copied)\r\nreturn -EFAULT;\r\n*ppos = len;\r\nreturn len;\r\n}\r\nstatic ssize_t i40e_dbg_netdev_ops_write(struct file *filp,\r\nconst char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct i40e_pf *pf = filp->private_data;\r\nint bytes_not_copied;\r\nstruct i40e_vsi *vsi;\r\nchar *buf_tmp;\r\nint vsi_seid;\r\nint i, cnt;\r\nif (*ppos != 0)\r\nreturn 0;\r\nif (count >= sizeof(i40e_dbg_netdev_ops_buf))\r\nreturn -ENOSPC;\r\nmemset(i40e_dbg_netdev_ops_buf, 0, sizeof(i40e_dbg_netdev_ops_buf));\r\nbytes_not_copied = copy_from_user(i40e_dbg_netdev_ops_buf,\r\nbuffer, count);\r\nif (bytes_not_copied)\r\nreturn -EFAULT;\r\ni40e_dbg_netdev_ops_buf[count] = '\0';\r\nbuf_tmp = strchr(i40e_dbg_netdev_ops_buf, '\n');\r\nif (buf_tmp) {\r\n*buf_tmp = '\0';\r\ncount = buf_tmp - i40e_dbg_netdev_ops_buf + 1;\r\n}\r\nif (strncmp(i40e_dbg_netdev_ops_buf, "tx_timeout", 10) == 0) {\r\ncnt = sscanf(&i40e_dbg_netdev_ops_buf[11], "%i", &vsi_seid);\r\nif (cnt != 1) {\r\ndev_info(&pf->pdev->dev, "tx_timeout <vsi_seid>\n");\r\ngoto netdev_ops_write_done;\r\n}\r\nvsi = i40e_dbg_find_vsi(pf, vsi_seid);\r\nif (!vsi) {\r\ndev_info(&pf->pdev->dev,\r\n"tx_timeout: VSI %d not found\n", vsi_seid);\r\n} else if (!vsi->netdev) {\r\ndev_info(&pf->pdev->dev, "tx_timeout: no netdev for VSI %d\n",\r\nvsi_seid);\r\n} else if (test_bit(__I40E_VSI_DOWN, vsi->state)) {\r\ndev_info(&pf->pdev->dev, "tx_timeout: VSI %d not UP\n",\r\nvsi_seid);\r\n} else if (rtnl_trylock()) {\r\nvsi->netdev->netdev_ops->ndo_tx_timeout(vsi->netdev);\r\nrtnl_unlock();\r\ndev_info(&pf->pdev->dev, "tx_timeout called\n");\r\n} else {\r\ndev_info(&pf->pdev->dev, "Could not acquire RTNL - please try again\n");\r\n}\r\n} else if (strncmp(i40e_dbg_netdev_ops_buf, "change_mtu", 10) == 0) {\r\nint mtu;\r\ncnt = sscanf(&i40e_dbg_netdev_ops_buf[11], "%i %i",\r\n&vsi_seid, &mtu);\r\nif (cnt != 2) {\r\ndev_info(&pf->pdev->dev, "change_mtu <vsi_seid> <mtu>\n");\r\ngoto netdev_ops_write_done;\r\n}\r\nvsi = i40e_dbg_find_vsi(pf, vsi_seid);\r\nif (!vsi) {\r\ndev_info(&pf->pdev->dev,\r\n"change_mtu: VSI %d not found\n", vsi_seid);\r\n} else if (!vsi->netdev) {\r\ndev_info(&pf->pdev->dev, "change_mtu: no netdev for VSI %d\n",\r\nvsi_seid);\r\n} else if (rtnl_trylock()) {\r\nvsi->netdev->netdev_ops->ndo_change_mtu(vsi->netdev,\r\nmtu);\r\nrtnl_unlock();\r\ndev_info(&pf->pdev->dev, "change_mtu called\n");\r\n} else {\r\ndev_info(&pf->pdev->dev, "Could not acquire RTNL - please try again\n");\r\n}\r\n} else if (strncmp(i40e_dbg_netdev_ops_buf, "set_rx_mode", 11) == 0) {\r\ncnt = sscanf(&i40e_dbg_netdev_ops_buf[11], "%i", &vsi_seid);\r\nif (cnt != 1) {\r\ndev_info(&pf->pdev->dev, "set_rx_mode <vsi_seid>\n");\r\ngoto netdev_ops_write_done;\r\n}\r\nvsi = i40e_dbg_find_vsi(pf, vsi_seid);\r\nif (!vsi) {\r\ndev_info(&pf->pdev->dev,\r\n"set_rx_mode: VSI %d not found\n", vsi_seid);\r\n} else if (!vsi->netdev) {\r\ndev_info(&pf->pdev->dev, "set_rx_mode: no netdev for VSI %d\n",\r\nvsi_seid);\r\n} else if (rtnl_trylock()) {\r\nvsi->netdev->netdev_ops->ndo_set_rx_mode(vsi->netdev);\r\nrtnl_unlock();\r\ndev_info(&pf->pdev->dev, "set_rx_mode called\n");\r\n} else {\r\ndev_info(&pf->pdev->dev, "Could not acquire RTNL - please try again\n");\r\n}\r\n} else if (strncmp(i40e_dbg_netdev_ops_buf, "napi", 4) == 0) {\r\ncnt = sscanf(&i40e_dbg_netdev_ops_buf[4], "%i", &vsi_seid);\r\nif (cnt != 1) {\r\ndev_info(&pf->pdev->dev, "napi <vsi_seid>\n");\r\ngoto netdev_ops_write_done;\r\n}\r\nvsi = i40e_dbg_find_vsi(pf, vsi_seid);\r\nif (!vsi) {\r\ndev_info(&pf->pdev->dev, "napi: VSI %d not found\n",\r\nvsi_seid);\r\n} else if (!vsi->netdev) {\r\ndev_info(&pf->pdev->dev, "napi: no netdev for VSI %d\n",\r\nvsi_seid);\r\n} else {\r\nfor (i = 0; i < vsi->num_q_vectors; i++)\r\nnapi_schedule(&vsi->q_vectors[i]->napi);\r\ndev_info(&pf->pdev->dev, "napi called\n");\r\n}\r\n} else {\r\ndev_info(&pf->pdev->dev, "unknown command '%s'\n",\r\ni40e_dbg_netdev_ops_buf);\r\ndev_info(&pf->pdev->dev, "available commands\n");\r\ndev_info(&pf->pdev->dev, " tx_timeout <vsi_seid>\n");\r\ndev_info(&pf->pdev->dev, " change_mtu <vsi_seid> <mtu>\n");\r\ndev_info(&pf->pdev->dev, " set_rx_mode <vsi_seid>\n");\r\ndev_info(&pf->pdev->dev, " napi <vsi_seid>\n");\r\n}\r\nnetdev_ops_write_done:\r\nreturn count;\r\n}\r\nvoid i40e_dbg_pf_init(struct i40e_pf *pf)\r\n{\r\nstruct dentry *pfile;\r\nconst char *name = pci_name(pf->pdev);\r\nconst struct device *dev = &pf->pdev->dev;\r\npf->i40e_dbg_pf = debugfs_create_dir(name, i40e_dbg_root);\r\nif (!pf->i40e_dbg_pf)\r\nreturn;\r\npfile = debugfs_create_file("command", 0600, pf->i40e_dbg_pf, pf,\r\n&i40e_dbg_command_fops);\r\nif (!pfile)\r\ngoto create_failed;\r\npfile = debugfs_create_file("netdev_ops", 0600, pf->i40e_dbg_pf, pf,\r\n&i40e_dbg_netdev_ops_fops);\r\nif (!pfile)\r\ngoto create_failed;\r\nreturn;\r\ncreate_failed:\r\ndev_info(dev, "debugfs dir/file for %s failed\n", name);\r\ndebugfs_remove_recursive(pf->i40e_dbg_pf);\r\n}\r\nvoid i40e_dbg_pf_exit(struct i40e_pf *pf)\r\n{\r\ndebugfs_remove_recursive(pf->i40e_dbg_pf);\r\npf->i40e_dbg_pf = NULL;\r\n}\r\nvoid i40e_dbg_init(void)\r\n{\r\ni40e_dbg_root = debugfs_create_dir(i40e_driver_name, NULL);\r\nif (!i40e_dbg_root)\r\npr_info("init of debugfs failed\n");\r\n}\r\nvoid i40e_dbg_exit(void)\r\n{\r\ndebugfs_remove_recursive(i40e_dbg_root);\r\ni40e_dbg_root = NULL;\r\n}
