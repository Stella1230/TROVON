int irq_reserve_ipi(struct irq_domain *domain,\r\nconst struct cpumask *dest)\r\n{\r\nunsigned int nr_irqs, offset;\r\nstruct irq_data *data;\r\nint virq, i;\r\nif (!domain ||!irq_domain_is_ipi(domain)) {\r\npr_warn("Reservation on a non IPI domain\n");\r\nreturn -EINVAL;\r\n}\r\nif (!cpumask_subset(dest, cpu_possible_mask)) {\r\npr_warn("Reservation is not in possible_cpu_mask\n");\r\nreturn -EINVAL;\r\n}\r\nnr_irqs = cpumask_weight(dest);\r\nif (!nr_irqs) {\r\npr_warn("Reservation for empty destination mask\n");\r\nreturn -EINVAL;\r\n}\r\nif (irq_domain_is_ipi_single(domain)) {\r\nnr_irqs = 1;\r\noffset = 0;\r\n} else {\r\nunsigned int next;\r\noffset = cpumask_first(dest);\r\nnext = cpumask_next_zero(offset, dest);\r\nif (next < nr_cpu_ids)\r\nnext = cpumask_next(next, dest);\r\nif (next < nr_cpu_ids) {\r\npr_warn("Destination mask has holes\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nvirq = irq_domain_alloc_descs(-1, nr_irqs, 0, NUMA_NO_NODE, NULL);\r\nif (virq <= 0) {\r\npr_warn("Can't reserve IPI, failed to alloc descs\n");\r\nreturn -ENOMEM;\r\n}\r\nvirq = __irq_domain_alloc_irqs(domain, virq, nr_irqs, NUMA_NO_NODE,\r\n(void *) dest, true, NULL);\r\nif (virq <= 0) {\r\npr_warn("Can't reserve IPI, failed to alloc hw irqs\n");\r\ngoto free_descs;\r\n}\r\nfor (i = 0; i < nr_irqs; i++) {\r\ndata = irq_get_irq_data(virq + i);\r\ncpumask_copy(data->common->affinity, dest);\r\ndata->common->ipi_offset = offset;\r\nirq_set_status_flags(virq + i, IRQ_NO_BALANCING);\r\n}\r\nreturn virq;\r\nfree_descs:\r\nirq_free_descs(virq, nr_irqs);\r\nreturn -EBUSY;\r\n}\r\nint irq_destroy_ipi(unsigned int irq, const struct cpumask *dest)\r\n{\r\nstruct irq_data *data = irq_get_irq_data(irq);\r\nstruct cpumask *ipimask = data ? irq_data_get_affinity_mask(data) : NULL;\r\nstruct irq_domain *domain;\r\nunsigned int nr_irqs;\r\nif (!irq || !data || !ipimask)\r\nreturn -EINVAL;\r\ndomain = data->domain;\r\nif (WARN_ON(domain == NULL))\r\nreturn -EINVAL;\r\nif (!irq_domain_is_ipi(domain)) {\r\npr_warn("Trying to destroy a non IPI domain!\n");\r\nreturn -EINVAL;\r\n}\r\nif (WARN_ON(!cpumask_subset(dest, ipimask)))\r\nreturn -EINVAL;\r\nif (irq_domain_is_ipi_per_cpu(domain)) {\r\nirq = irq + cpumask_first(dest) - data->common->ipi_offset;\r\nnr_irqs = cpumask_weight(dest);\r\n} else {\r\nnr_irqs = 1;\r\n}\r\nirq_domain_free_irqs(irq, nr_irqs);\r\nreturn 0;\r\n}\r\nirq_hw_number_t ipi_get_hwirq(unsigned int irq, unsigned int cpu)\r\n{\r\nstruct irq_data *data = irq_get_irq_data(irq);\r\nstruct cpumask *ipimask = data ? irq_data_get_affinity_mask(data) : NULL;\r\nif (!data || !ipimask || cpu >= nr_cpu_ids)\r\nreturn INVALID_HWIRQ;\r\nif (!cpumask_test_cpu(cpu, ipimask))\r\nreturn INVALID_HWIRQ;\r\nif (irq_domain_is_ipi_per_cpu(data->domain))\r\ndata = irq_get_irq_data(irq + cpu - data->common->ipi_offset);\r\nreturn data ? irqd_to_hwirq(data) : INVALID_HWIRQ;\r\n}\r\nstatic int ipi_send_verify(struct irq_chip *chip, struct irq_data *data,\r\nconst struct cpumask *dest, unsigned int cpu)\r\n{\r\nstruct cpumask *ipimask = irq_data_get_affinity_mask(data);\r\nif (!chip || !ipimask)\r\nreturn -EINVAL;\r\nif (!chip->ipi_send_single && !chip->ipi_send_mask)\r\nreturn -EINVAL;\r\nif (cpu >= nr_cpu_ids)\r\nreturn -EINVAL;\r\nif (dest) {\r\nif (!cpumask_subset(dest, ipimask))\r\nreturn -EINVAL;\r\n} else {\r\nif (!cpumask_test_cpu(cpu, ipimask))\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint __ipi_send_single(struct irq_desc *desc, unsigned int cpu)\r\n{\r\nstruct irq_data *data = irq_desc_get_irq_data(desc);\r\nstruct irq_chip *chip = irq_data_get_irq_chip(data);\r\n#ifdef DEBUG\r\nif (WARN_ON_ONCE(ipi_send_verify(chip, data, NULL, cpu)))\r\nreturn -EINVAL;\r\n#endif\r\nif (!chip->ipi_send_single) {\r\nchip->ipi_send_mask(data, cpumask_of(cpu));\r\nreturn 0;\r\n}\r\nif (irq_domain_is_ipi_per_cpu(data->domain) &&\r\ncpu != data->common->ipi_offset) {\r\nunsigned irq = data->irq + cpu - data->common->ipi_offset;\r\ndata = irq_get_irq_data(irq);\r\n}\r\nchip->ipi_send_single(data, cpu);\r\nreturn 0;\r\n}\r\nint __ipi_send_mask(struct irq_desc *desc, const struct cpumask *dest)\r\n{\r\nstruct irq_data *data = irq_desc_get_irq_data(desc);\r\nstruct irq_chip *chip = irq_data_get_irq_chip(data);\r\nunsigned int cpu;\r\n#ifdef DEBUG\r\nif (WARN_ON_ONCE(ipi_send_verify(chip, data, dest, 0)))\r\nreturn -EINVAL;\r\n#endif\r\nif (chip->ipi_send_mask) {\r\nchip->ipi_send_mask(data, dest);\r\nreturn 0;\r\n}\r\nif (irq_domain_is_ipi_per_cpu(data->domain)) {\r\nunsigned int base = data->irq;\r\nfor_each_cpu(cpu, dest) {\r\nunsigned irq = base + cpu - data->common->ipi_offset;\r\ndata = irq_get_irq_data(irq);\r\nchip->ipi_send_single(data, cpu);\r\n}\r\n} else {\r\nfor_each_cpu(cpu, dest)\r\nchip->ipi_send_single(data, cpu);\r\n}\r\nreturn 0;\r\n}\r\nint ipi_send_single(unsigned int virq, unsigned int cpu)\r\n{\r\nstruct irq_desc *desc = irq_to_desc(virq);\r\nstruct irq_data *data = desc ? irq_desc_get_irq_data(desc) : NULL;\r\nstruct irq_chip *chip = data ? irq_data_get_irq_chip(data) : NULL;\r\nif (WARN_ON_ONCE(ipi_send_verify(chip, data, NULL, cpu)))\r\nreturn -EINVAL;\r\nreturn __ipi_send_single(desc, cpu);\r\n}\r\nint ipi_send_mask(unsigned int virq, const struct cpumask *dest)\r\n{\r\nstruct irq_desc *desc = irq_to_desc(virq);\r\nstruct irq_data *data = desc ? irq_desc_get_irq_data(desc) : NULL;\r\nstruct irq_chip *chip = data ? irq_data_get_irq_chip(data) : NULL;\r\nif (WARN_ON_ONCE(ipi_send_verify(chip, data, dest, 0)))\r\nreturn -EINVAL;\r\nreturn __ipi_send_mask(desc, dest);\r\n}
