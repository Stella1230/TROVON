static u32 _rtl92e_calculate_bit_shift(u32 dwBitMask)\r\n{\r\nif (!dwBitMask)\r\nreturn 32;\r\nreturn ffs(dwBitMask) - 1;\r\n}\r\nu8 rtl92e_is_legal_rf_path(struct net_device *dev, u32 eRFPath)\r\n{\r\nu8 ret = 1;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nif (priv->rf_type == RF_2T4R)\r\nret = 0;\r\nelse if (priv->rf_type == RF_1T2R) {\r\nif (eRFPath == RF90_PATH_A || eRFPath == RF90_PATH_B)\r\nret = 1;\r\nelse if (eRFPath == RF90_PATH_C || eRFPath == RF90_PATH_D)\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nvoid rtl92e_set_bb_reg(struct net_device *dev, u32 dwRegAddr, u32 dwBitMask,\r\nu32 dwData)\r\n{\r\nu32 OriginalValue, BitShift, NewValue;\r\nif (dwBitMask != bMaskDWord) {\r\nOriginalValue = rtl92e_readl(dev, dwRegAddr);\r\nBitShift = _rtl92e_calculate_bit_shift(dwBitMask);\r\nNewValue = (((OriginalValue) & (~dwBitMask)) |\r\n(dwData << BitShift));\r\nrtl92e_writel(dev, dwRegAddr, NewValue);\r\n} else\r\nrtl92e_writel(dev, dwRegAddr, dwData);\r\n}\r\nu32 rtl92e_get_bb_reg(struct net_device *dev, u32 dwRegAddr, u32 dwBitMask)\r\n{\r\nu32 OriginalValue, BitShift;\r\nOriginalValue = rtl92e_readl(dev, dwRegAddr);\r\nBitShift = _rtl92e_calculate_bit_shift(dwBitMask);\r\nreturn (OriginalValue & dwBitMask) >> BitShift;\r\n}\r\nstatic u32 _rtl92e_phy_rf_read(struct net_device *dev,\r\nenum rf90_radio_path eRFPath, u32 Offset)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu32 ret = 0;\r\nu32 NewOffset = 0;\r\nstruct bb_reg_definition *pPhyReg = &priv->PHYRegDef[eRFPath];\r\nOffset &= 0x3f;\r\nif (priv->rf_chip == RF_8256) {\r\nrtl92e_set_bb_reg(dev, rFPGA0_AnalogParameter4, 0xf00, 0x0);\r\nif (Offset >= 31) {\r\npriv->RfReg0Value[eRFPath] |= 0x140;\r\nrtl92e_set_bb_reg(dev, pPhyReg->rf3wireOffset,\r\nbMaskDWord,\r\n(priv->RfReg0Value[eRFPath]<<16));\r\nNewOffset = Offset - 30;\r\n} else if (Offset >= 16) {\r\npriv->RfReg0Value[eRFPath] |= 0x100;\r\npriv->RfReg0Value[eRFPath] &= (~0x40);\r\nrtl92e_set_bb_reg(dev, pPhyReg->rf3wireOffset,\r\nbMaskDWord,\r\n(priv->RfReg0Value[eRFPath]<<16));\r\nNewOffset = Offset - 15;\r\n} else\r\nNewOffset = Offset;\r\n} else {\r\nRT_TRACE((COMP_PHY|COMP_ERR),\r\n"check RF type here, need to be 8256\n");\r\nNewOffset = Offset;\r\n}\r\nrtl92e_set_bb_reg(dev, pPhyReg->rfHSSIPara2, bLSSIReadAddress,\r\nNewOffset);\r\nrtl92e_set_bb_reg(dev, pPhyReg->rfHSSIPara2, bLSSIReadEdge, 0x0);\r\nrtl92e_set_bb_reg(dev, pPhyReg->rfHSSIPara2, bLSSIReadEdge, 0x1);\r\nmdelay(1);\r\nret = rtl92e_get_bb_reg(dev, pPhyReg->rfLSSIReadBack,\r\nbLSSIReadBackData);\r\nif (priv->rf_chip == RF_8256) {\r\npriv->RfReg0Value[eRFPath] &= 0xebf;\r\nrtl92e_set_bb_reg(dev, pPhyReg->rf3wireOffset, bMaskDWord,\r\n(priv->RfReg0Value[eRFPath] << 16));\r\nrtl92e_set_bb_reg(dev, rFPGA0_AnalogParameter4, 0x300, 0x3);\r\n}\r\nreturn ret;\r\n}\r\nstatic void _rtl92e_phy_rf_write(struct net_device *dev,\r\nenum rf90_radio_path eRFPath, u32 Offset,\r\nu32 Data)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu32 DataAndAddr = 0, NewOffset = 0;\r\nstruct bb_reg_definition *pPhyReg = &priv->PHYRegDef[eRFPath];\r\nOffset &= 0x3f;\r\nif (priv->rf_chip == RF_8256) {\r\nrtl92e_set_bb_reg(dev, rFPGA0_AnalogParameter4, 0xf00, 0x0);\r\nif (Offset >= 31) {\r\npriv->RfReg0Value[eRFPath] |= 0x140;\r\nrtl92e_set_bb_reg(dev, pPhyReg->rf3wireOffset,\r\nbMaskDWord,\r\n(priv->RfReg0Value[eRFPath] << 16));\r\nNewOffset = Offset - 30;\r\n} else if (Offset >= 16) {\r\npriv->RfReg0Value[eRFPath] |= 0x100;\r\npriv->RfReg0Value[eRFPath] &= (~0x40);\r\nrtl92e_set_bb_reg(dev, pPhyReg->rf3wireOffset,\r\nbMaskDWord,\r\n(priv->RfReg0Value[eRFPath] << 16));\r\nNewOffset = Offset - 15;\r\n} else\r\nNewOffset = Offset;\r\n} else {\r\nRT_TRACE((COMP_PHY|COMP_ERR),\r\n"check RF type here, need to be 8256\n");\r\nNewOffset = Offset;\r\n}\r\nDataAndAddr = (Data<<16) | (NewOffset&0x3f);\r\nrtl92e_set_bb_reg(dev, pPhyReg->rf3wireOffset, bMaskDWord, DataAndAddr);\r\nif (Offset == 0x0)\r\npriv->RfReg0Value[eRFPath] = Data;\r\nif (priv->rf_chip == RF_8256) {\r\nif (Offset != 0) {\r\npriv->RfReg0Value[eRFPath] &= 0xebf;\r\nrtl92e_set_bb_reg(dev, pPhyReg->rf3wireOffset,\r\nbMaskDWord,\r\n(priv->RfReg0Value[eRFPath] << 16));\r\n}\r\nrtl92e_set_bb_reg(dev, rFPGA0_AnalogParameter4, 0x300, 0x3);\r\n}\r\n}\r\nvoid rtl92e_set_rf_reg(struct net_device *dev, enum rf90_radio_path eRFPath,\r\nu32 RegAddr, u32 BitMask, u32 Data)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu32 Original_Value, BitShift, New_Value;\r\nif (!rtl92e_is_legal_rf_path(dev, eRFPath))\r\nreturn;\r\nif (priv->rtllib->eRFPowerState != eRfOn && !priv->being_init_adapter)\r\nreturn;\r\nRT_TRACE(COMP_PHY, "FW RF CTRL is not ready now\n");\r\nif (priv->Rf_Mode == RF_OP_By_FW) {\r\nif (BitMask != bMask12Bits) {\r\nOriginal_Value = _rtl92e_phy_rf_fw_read(dev, eRFPath,\r\nRegAddr);\r\nBitShift = _rtl92e_calculate_bit_shift(BitMask);\r\nNew_Value = (((Original_Value) & (~BitMask)) |\r\n(Data << BitShift));\r\n_rtl92e_phy_rf_fw_write(dev, eRFPath, RegAddr,\r\nNew_Value);\r\n} else\r\n_rtl92e_phy_rf_fw_write(dev, eRFPath, RegAddr, Data);\r\nudelay(200);\r\n} else {\r\nif (BitMask != bMask12Bits) {\r\nOriginal_Value = _rtl92e_phy_rf_read(dev, eRFPath,\r\nRegAddr);\r\nBitShift = _rtl92e_calculate_bit_shift(BitMask);\r\nNew_Value = (((Original_Value) & (~BitMask)) |\r\n(Data << BitShift));\r\n_rtl92e_phy_rf_write(dev, eRFPath, RegAddr, New_Value);\r\n} else\r\n_rtl92e_phy_rf_write(dev, eRFPath, RegAddr, Data);\r\n}\r\n}\r\nu32 rtl92e_get_rf_reg(struct net_device *dev, enum rf90_radio_path eRFPath,\r\nu32 RegAddr, u32 BitMask)\r\n{\r\nu32 Original_Value, Readback_Value, BitShift;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nif (!rtl92e_is_legal_rf_path(dev, eRFPath))\r\nreturn 0;\r\nif (priv->rtllib->eRFPowerState != eRfOn && !priv->being_init_adapter)\r\nreturn 0;\r\nmutex_lock(&priv->rf_mutex);\r\nif (priv->Rf_Mode == RF_OP_By_FW) {\r\nOriginal_Value = _rtl92e_phy_rf_fw_read(dev, eRFPath, RegAddr);\r\nudelay(200);\r\n} else {\r\nOriginal_Value = _rtl92e_phy_rf_read(dev, eRFPath, RegAddr);\r\n}\r\nBitShift = _rtl92e_calculate_bit_shift(BitMask);\r\nReadback_Value = (Original_Value & BitMask) >> BitShift;\r\nmutex_unlock(&priv->rf_mutex);\r\nreturn Readback_Value;\r\n}\r\nstatic u32 _rtl92e_phy_rf_fw_read(struct net_device *dev,\r\nenum rf90_radio_path eRFPath, u32 Offset)\r\n{\r\nu32 Data = 0;\r\nu8 time = 0;\r\nData |= ((Offset & 0xFF) << 12);\r\nData |= ((eRFPath & 0x3) << 20);\r\nData |= 0x80000000;\r\nwhile (rtl92e_readl(dev, QPNR) & 0x80000000) {\r\nif (time++ < 100)\r\nudelay(10);\r\nelse\r\nbreak;\r\n}\r\nrtl92e_writel(dev, QPNR, Data);\r\nwhile (rtl92e_readl(dev, QPNR) & 0x80000000) {\r\nif (time++ < 100)\r\nudelay(10);\r\nelse\r\nreturn 0;\r\n}\r\nreturn rtl92e_readl(dev, RF_DATA);\r\n}\r\nstatic void _rtl92e_phy_rf_fw_write(struct net_device *dev,\r\nenum rf90_radio_path eRFPath, u32 Offset,\r\nu32 Data)\r\n{\r\nu8 time = 0;\r\nData |= ((Offset & 0xFF) << 12);\r\nData |= ((eRFPath & 0x3) << 20);\r\nData |= 0x400000;\r\nData |= 0x80000000;\r\nwhile (rtl92e_readl(dev, QPNR) & 0x80000000) {\r\nif (time++ < 100)\r\nudelay(10);\r\nelse\r\nbreak;\r\n}\r\nrtl92e_writel(dev, QPNR, Data);\r\n}\r\nvoid rtl92e_config_mac(struct net_device *dev)\r\n{\r\nu32 dwArrayLen = 0, i = 0;\r\nu32 *pdwArray = NULL;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nif (priv->bTXPowerDataReadFromEEPORM) {\r\nRT_TRACE(COMP_PHY, "Rtl819XMACPHY_Array_PG\n");\r\ndwArrayLen = MACPHY_Array_PGLength;\r\npdwArray = Rtl819XMACPHY_Array_PG;\r\n} else {\r\nRT_TRACE(COMP_PHY, "Read rtl819XMACPHY_Array\n");\r\ndwArrayLen = MACPHY_ArrayLength;\r\npdwArray = Rtl819XMACPHY_Array;\r\n}\r\nfor (i = 0; i < dwArrayLen; i += 3) {\r\nRT_TRACE(COMP_DBG,\r\n"The Rtl8190MACPHY_Array[0] is %x Rtl8190MACPHY_Array[1] is %x Rtl8190MACPHY_Array[2] is %x\n",\r\npdwArray[i], pdwArray[i+1], pdwArray[i+2]);\r\nif (pdwArray[i] == 0x318)\r\npdwArray[i+2] = 0x00000800;\r\nrtl92e_set_bb_reg(dev, pdwArray[i], pdwArray[i+1],\r\npdwArray[i+2]);\r\n}\r\nreturn;\r\n}\r\nstatic void _rtl92e_phy_config_bb(struct net_device *dev, u8 ConfigType)\r\n{\r\nint i;\r\nu32 *Rtl819XPHY_REGArray_Table = NULL;\r\nu32 *Rtl819XAGCTAB_Array_Table = NULL;\r\nu16 AGCTAB_ArrayLen, PHY_REGArrayLen = 0;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nAGCTAB_ArrayLen = AGCTAB_ArrayLength;\r\nRtl819XAGCTAB_Array_Table = Rtl819XAGCTAB_Array;\r\nif (priv->rf_type == RF_2T4R) {\r\nPHY_REGArrayLen = PHY_REGArrayLength;\r\nRtl819XPHY_REGArray_Table = Rtl819XPHY_REGArray;\r\n} else if (priv->rf_type == RF_1T2R) {\r\nPHY_REGArrayLen = PHY_REG_1T2RArrayLength;\r\nRtl819XPHY_REGArray_Table = Rtl819XPHY_REG_1T2RArray;\r\n}\r\nif (ConfigType == BaseBand_Config_PHY_REG) {\r\nfor (i = 0; i < PHY_REGArrayLen; i += 2) {\r\nrtl92e_set_bb_reg(dev, Rtl819XPHY_REGArray_Table[i],\r\nbMaskDWord,\r\nRtl819XPHY_REGArray_Table[i+1]);\r\nRT_TRACE(COMP_DBG,\r\n"i: %x, The Rtl819xUsbPHY_REGArray[0] is %x Rtl819xUsbPHY_REGArray[1] is %x\n",\r\ni, Rtl819XPHY_REGArray_Table[i],\r\nRtl819XPHY_REGArray_Table[i+1]);\r\n}\r\n} else if (ConfigType == BaseBand_Config_AGC_TAB) {\r\nfor (i = 0; i < AGCTAB_ArrayLen; i += 2) {\r\nrtl92e_set_bb_reg(dev, Rtl819XAGCTAB_Array_Table[i],\r\nbMaskDWord,\r\nRtl819XAGCTAB_Array_Table[i+1]);\r\nRT_TRACE(COMP_DBG,\r\n"i:%x, The rtl819XAGCTAB_Array[0] is %x rtl819XAGCTAB_Array[1] is %x\n",\r\ni, Rtl819XAGCTAB_Array_Table[i],\r\nRtl819XAGCTAB_Array_Table[i+1]);\r\n}\r\n}\r\n}\r\nstatic void _rtl92e_init_bb_rf_reg_def(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\npriv->PHYRegDef[RF90_PATH_A].rfintfs = rFPGA0_XAB_RFInterfaceSW;\r\npriv->PHYRegDef[RF90_PATH_B].rfintfs = rFPGA0_XAB_RFInterfaceSW;\r\npriv->PHYRegDef[RF90_PATH_C].rfintfs = rFPGA0_XCD_RFInterfaceSW;\r\npriv->PHYRegDef[RF90_PATH_D].rfintfs = rFPGA0_XCD_RFInterfaceSW;\r\npriv->PHYRegDef[RF90_PATH_A].rfintfi = rFPGA0_XAB_RFInterfaceRB;\r\npriv->PHYRegDef[RF90_PATH_B].rfintfi = rFPGA0_XAB_RFInterfaceRB;\r\npriv->PHYRegDef[RF90_PATH_C].rfintfi = rFPGA0_XCD_RFInterfaceRB;\r\npriv->PHYRegDef[RF90_PATH_D].rfintfi = rFPGA0_XCD_RFInterfaceRB;\r\npriv->PHYRegDef[RF90_PATH_A].rfintfo = rFPGA0_XA_RFInterfaceOE;\r\npriv->PHYRegDef[RF90_PATH_B].rfintfo = rFPGA0_XB_RFInterfaceOE;\r\npriv->PHYRegDef[RF90_PATH_C].rfintfo = rFPGA0_XC_RFInterfaceOE;\r\npriv->PHYRegDef[RF90_PATH_D].rfintfo = rFPGA0_XD_RFInterfaceOE;\r\npriv->PHYRegDef[RF90_PATH_A].rfintfe = rFPGA0_XA_RFInterfaceOE;\r\npriv->PHYRegDef[RF90_PATH_B].rfintfe = rFPGA0_XB_RFInterfaceOE;\r\npriv->PHYRegDef[RF90_PATH_C].rfintfe = rFPGA0_XC_RFInterfaceOE;\r\npriv->PHYRegDef[RF90_PATH_D].rfintfe = rFPGA0_XD_RFInterfaceOE;\r\npriv->PHYRegDef[RF90_PATH_A].rf3wireOffset = rFPGA0_XA_LSSIParameter;\r\npriv->PHYRegDef[RF90_PATH_B].rf3wireOffset = rFPGA0_XB_LSSIParameter;\r\npriv->PHYRegDef[RF90_PATH_C].rf3wireOffset = rFPGA0_XC_LSSIParameter;\r\npriv->PHYRegDef[RF90_PATH_D].rf3wireOffset = rFPGA0_XD_LSSIParameter;\r\npriv->PHYRegDef[RF90_PATH_A].rfLSSI_Select = rFPGA0_XAB_RFParameter;\r\npriv->PHYRegDef[RF90_PATH_B].rfLSSI_Select = rFPGA0_XAB_RFParameter;\r\npriv->PHYRegDef[RF90_PATH_C].rfLSSI_Select = rFPGA0_XCD_RFParameter;\r\npriv->PHYRegDef[RF90_PATH_D].rfLSSI_Select = rFPGA0_XCD_RFParameter;\r\npriv->PHYRegDef[RF90_PATH_A].rfTxGainStage = rFPGA0_TxGainStage;\r\npriv->PHYRegDef[RF90_PATH_B].rfTxGainStage = rFPGA0_TxGainStage;\r\npriv->PHYRegDef[RF90_PATH_C].rfTxGainStage = rFPGA0_TxGainStage;\r\npriv->PHYRegDef[RF90_PATH_D].rfTxGainStage = rFPGA0_TxGainStage;\r\npriv->PHYRegDef[RF90_PATH_A].rfHSSIPara1 = rFPGA0_XA_HSSIParameter1;\r\npriv->PHYRegDef[RF90_PATH_B].rfHSSIPara1 = rFPGA0_XB_HSSIParameter1;\r\npriv->PHYRegDef[RF90_PATH_C].rfHSSIPara1 = rFPGA0_XC_HSSIParameter1;\r\npriv->PHYRegDef[RF90_PATH_D].rfHSSIPara1 = rFPGA0_XD_HSSIParameter1;\r\npriv->PHYRegDef[RF90_PATH_A].rfHSSIPara2 = rFPGA0_XA_HSSIParameter2;\r\npriv->PHYRegDef[RF90_PATH_B].rfHSSIPara2 = rFPGA0_XB_HSSIParameter2;\r\npriv->PHYRegDef[RF90_PATH_C].rfHSSIPara2 = rFPGA0_XC_HSSIParameter2;\r\npriv->PHYRegDef[RF90_PATH_D].rfHSSIPara2 = rFPGA0_XD_HSSIParameter2;\r\npriv->PHYRegDef[RF90_PATH_A].rfSwitchControl = rFPGA0_XAB_SwitchControl;\r\npriv->PHYRegDef[RF90_PATH_B].rfSwitchControl = rFPGA0_XAB_SwitchControl;\r\npriv->PHYRegDef[RF90_PATH_C].rfSwitchControl = rFPGA0_XCD_SwitchControl;\r\npriv->PHYRegDef[RF90_PATH_D].rfSwitchControl = rFPGA0_XCD_SwitchControl;\r\npriv->PHYRegDef[RF90_PATH_A].rfAGCControl1 = rOFDM0_XAAGCCore1;\r\npriv->PHYRegDef[RF90_PATH_B].rfAGCControl1 = rOFDM0_XBAGCCore1;\r\npriv->PHYRegDef[RF90_PATH_C].rfAGCControl1 = rOFDM0_XCAGCCore1;\r\npriv->PHYRegDef[RF90_PATH_D].rfAGCControl1 = rOFDM0_XDAGCCore1;\r\npriv->PHYRegDef[RF90_PATH_A].rfAGCControl2 = rOFDM0_XAAGCCore2;\r\npriv->PHYRegDef[RF90_PATH_B].rfAGCControl2 = rOFDM0_XBAGCCore2;\r\npriv->PHYRegDef[RF90_PATH_C].rfAGCControl2 = rOFDM0_XCAGCCore2;\r\npriv->PHYRegDef[RF90_PATH_D].rfAGCControl2 = rOFDM0_XDAGCCore2;\r\npriv->PHYRegDef[RF90_PATH_A].rfRxIQImbalance = rOFDM0_XARxIQImbalance;\r\npriv->PHYRegDef[RF90_PATH_B].rfRxIQImbalance = rOFDM0_XBRxIQImbalance;\r\npriv->PHYRegDef[RF90_PATH_C].rfRxIQImbalance = rOFDM0_XCRxIQImbalance;\r\npriv->PHYRegDef[RF90_PATH_D].rfRxIQImbalance = rOFDM0_XDRxIQImbalance;\r\npriv->PHYRegDef[RF90_PATH_A].rfRxAFE = rOFDM0_XARxAFE;\r\npriv->PHYRegDef[RF90_PATH_B].rfRxAFE = rOFDM0_XBRxAFE;\r\npriv->PHYRegDef[RF90_PATH_C].rfRxAFE = rOFDM0_XCRxAFE;\r\npriv->PHYRegDef[RF90_PATH_D].rfRxAFE = rOFDM0_XDRxAFE;\r\npriv->PHYRegDef[RF90_PATH_A].rfTxIQImbalance = rOFDM0_XATxIQImbalance;\r\npriv->PHYRegDef[RF90_PATH_B].rfTxIQImbalance = rOFDM0_XBTxIQImbalance;\r\npriv->PHYRegDef[RF90_PATH_C].rfTxIQImbalance = rOFDM0_XCTxIQImbalance;\r\npriv->PHYRegDef[RF90_PATH_D].rfTxIQImbalance = rOFDM0_XDTxIQImbalance;\r\npriv->PHYRegDef[RF90_PATH_A].rfTxAFE = rOFDM0_XATxAFE;\r\npriv->PHYRegDef[RF90_PATH_B].rfTxAFE = rOFDM0_XBTxAFE;\r\npriv->PHYRegDef[RF90_PATH_C].rfTxAFE = rOFDM0_XCTxAFE;\r\npriv->PHYRegDef[RF90_PATH_D].rfTxAFE = rOFDM0_XDTxAFE;\r\npriv->PHYRegDef[RF90_PATH_A].rfLSSIReadBack = rFPGA0_XA_LSSIReadBack;\r\npriv->PHYRegDef[RF90_PATH_B].rfLSSIReadBack = rFPGA0_XB_LSSIReadBack;\r\npriv->PHYRegDef[RF90_PATH_C].rfLSSIReadBack = rFPGA0_XC_LSSIReadBack;\r\npriv->PHYRegDef[RF90_PATH_D].rfLSSIReadBack = rFPGA0_XD_LSSIReadBack;\r\n}\r\nbool rtl92e_check_bb_and_rf(struct net_device *dev, enum hw90_block CheckBlock,\r\nenum rf90_radio_path eRFPath)\r\n{\r\nbool ret = true;\r\nu32 i, CheckTimes = 4, dwRegRead = 0;\r\nu32 WriteAddr[4];\r\nu32 WriteData[] = {0xfffff027, 0xaa55a02f, 0x00000027, 0x55aa502f};\r\nWriteAddr[HW90_BLOCK_MAC] = 0x100;\r\nWriteAddr[HW90_BLOCK_PHY0] = 0x900;\r\nWriteAddr[HW90_BLOCK_PHY1] = 0x800;\r\nWriteAddr[HW90_BLOCK_RF] = 0x3;\r\nRT_TRACE(COMP_PHY, "=======>%s(), CheckBlock:%d\n", __func__,\r\nCheckBlock);\r\nif (CheckBlock == HW90_BLOCK_MAC) {\r\nnetdev_warn(dev, "%s(): No checks available for MAC block.\n",\r\n__func__);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < CheckTimes; i++) {\r\nswitch (CheckBlock) {\r\ncase HW90_BLOCK_PHY0:\r\ncase HW90_BLOCK_PHY1:\r\nrtl92e_writel(dev, WriteAddr[CheckBlock],\r\nWriteData[i]);\r\ndwRegRead = rtl92e_readl(dev, WriteAddr[CheckBlock]);\r\nbreak;\r\ncase HW90_BLOCK_RF:\r\nWriteData[i] &= 0xfff;\r\nrtl92e_set_rf_reg(dev, eRFPath,\r\nWriteAddr[HW90_BLOCK_RF],\r\nbMask12Bits, WriteData[i]);\r\nmdelay(10);\r\ndwRegRead = rtl92e_get_rf_reg(dev, eRFPath,\r\nWriteAddr[HW90_BLOCK_RF],\r\nbMaskDWord);\r\nmdelay(10);\r\nbreak;\r\ndefault:\r\nret = false;\r\nbreak;\r\n}\r\nif (dwRegRead != WriteData[i]) {\r\nnetdev_warn(dev, "%s(): Check failed.\n", __func__);\r\nret = false;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic bool _rtl92e_bb_config_para_file(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nbool rtStatus = true;\r\nu8 bRegValue = 0, eCheckItem = 0;\r\nu32 dwRegValue = 0;\r\nbRegValue = rtl92e_readb(dev, BB_GLOBAL_RESET);\r\nrtl92e_writeb(dev, BB_GLOBAL_RESET, (bRegValue|BB_GLOBAL_RESET_BIT));\r\ndwRegValue = rtl92e_readl(dev, CPU_GEN);\r\nrtl92e_writel(dev, CPU_GEN, (dwRegValue&(~CPU_GEN_BB_RST)));\r\nfor (eCheckItem = (enum hw90_block)HW90_BLOCK_PHY0;\r\neCheckItem <= HW90_BLOCK_PHY1; eCheckItem++) {\r\nrtStatus = rtl92e_check_bb_and_rf(dev,\r\n(enum hw90_block)eCheckItem,\r\n(enum rf90_radio_path)0);\r\nif (!rtStatus) {\r\nRT_TRACE((COMP_ERR | COMP_PHY),\r\n"rtl92e_config_rf():Check PHY%d Fail!!\n",\r\neCheckItem-1);\r\nreturn rtStatus;\r\n}\r\n}\r\nrtl92e_set_bb_reg(dev, rFPGA0_RFMOD, bCCKEn|bOFDMEn, 0x0);\r\n_rtl92e_phy_config_bb(dev, BaseBand_Config_PHY_REG);\r\ndwRegValue = rtl92e_readl(dev, CPU_GEN);\r\nrtl92e_writel(dev, CPU_GEN, (dwRegValue|CPU_GEN_BB_RST));\r\n_rtl92e_phy_config_bb(dev, BaseBand_Config_AGC_TAB);\r\nif (priv->IC_Cut > VERSION_8190_BD) {\r\nif (priv->rf_type == RF_2T4R)\r\ndwRegValue = (priv->AntennaTxPwDiff[2]<<8 |\r\npriv->AntennaTxPwDiff[1]<<4 |\r\npriv->AntennaTxPwDiff[0]);\r\nelse\r\ndwRegValue = 0x0;\r\nrtl92e_set_bb_reg(dev, rFPGA0_TxGainStage,\r\n(bXBTxAGC|bXCTxAGC|bXDTxAGC), dwRegValue);\r\ndwRegValue = priv->CrystalCap;\r\nrtl92e_set_bb_reg(dev, rFPGA0_AnalogParameter1, bXtalCap92x,\r\ndwRegValue);\r\n}\r\nreturn rtStatus;\r\n}\r\nbool rtl92e_config_bb(struct net_device *dev)\r\n{\r\n_rtl92e_init_bb_rf_reg_def(dev);\r\nreturn _rtl92e_bb_config_para_file(dev);\r\n}\r\nvoid rtl92e_get_tx_power(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\npriv->MCSTxPowerLevelOriginalOffset[0] =\r\nrtl92e_readl(dev, rTxAGC_Rate18_06);\r\npriv->MCSTxPowerLevelOriginalOffset[1] =\r\nrtl92e_readl(dev, rTxAGC_Rate54_24);\r\npriv->MCSTxPowerLevelOriginalOffset[2] =\r\nrtl92e_readl(dev, rTxAGC_Mcs03_Mcs00);\r\npriv->MCSTxPowerLevelOriginalOffset[3] =\r\nrtl92e_readl(dev, rTxAGC_Mcs07_Mcs04);\r\npriv->MCSTxPowerLevelOriginalOffset[4] =\r\nrtl92e_readl(dev, rTxAGC_Mcs11_Mcs08);\r\npriv->MCSTxPowerLevelOriginalOffset[5] =\r\nrtl92e_readl(dev, rTxAGC_Mcs15_Mcs12);\r\npriv->DefaultInitialGain[0] = rtl92e_readb(dev, rOFDM0_XAAGCCore1);\r\npriv->DefaultInitialGain[1] = rtl92e_readb(dev, rOFDM0_XBAGCCore1);\r\npriv->DefaultInitialGain[2] = rtl92e_readb(dev, rOFDM0_XCAGCCore1);\r\npriv->DefaultInitialGain[3] = rtl92e_readb(dev, rOFDM0_XDAGCCore1);\r\nRT_TRACE(COMP_INIT,\r\n"Default initial gain (c50=0x%x, c58=0x%x, c60=0x%x, c68=0x%x)\n",\r\npriv->DefaultInitialGain[0], priv->DefaultInitialGain[1],\r\npriv->DefaultInitialGain[2], priv->DefaultInitialGain[3]);\r\npriv->framesync = rtl92e_readb(dev, rOFDM0_RxDetector3);\r\npriv->framesyncC34 = rtl92e_readl(dev, rOFDM0_RxDetector2);\r\nRT_TRACE(COMP_INIT, "Default framesync (0x%x) = 0x%x\n",\r\nrOFDM0_RxDetector3, priv->framesync);\r\npriv->SifsTime = rtl92e_readw(dev, SIFS);\r\n}\r\nvoid rtl92e_set_tx_power(struct net_device *dev, u8 channel)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu8 powerlevel = 0, powerlevelOFDM24G = 0;\r\ns8 ant_pwr_diff;\r\nu32 u4RegValue;\r\nif (priv->epromtype == EEPROM_93C46) {\r\npowerlevel = priv->TxPowerLevelCCK[channel-1];\r\npowerlevelOFDM24G = priv->TxPowerLevelOFDM24G[channel-1];\r\n} else if (priv->epromtype == EEPROM_93C56) {\r\nif (priv->rf_type == RF_1T2R) {\r\npowerlevel = priv->TxPowerLevelCCK_C[channel-1];\r\npowerlevelOFDM24G = priv->TxPowerLevelOFDM24G_C[channel-1];\r\n} else if (priv->rf_type == RF_2T4R) {\r\npowerlevel = priv->TxPowerLevelCCK_A[channel-1];\r\npowerlevelOFDM24G = priv->TxPowerLevelOFDM24G_A[channel-1];\r\nant_pwr_diff = priv->TxPowerLevelOFDM24G_C[channel-1]\r\n- priv->TxPowerLevelOFDM24G_A[channel-1];\r\npriv->RF_C_TxPwDiff = ant_pwr_diff;\r\nant_pwr_diff &= 0xf;\r\npriv->AntennaTxPwDiff[2] = 0;\r\npriv->AntennaTxPwDiff[1] = (u8)(ant_pwr_diff);\r\npriv->AntennaTxPwDiff[0] = 0;\r\nu4RegValue = (priv->AntennaTxPwDiff[2]<<8 |\r\npriv->AntennaTxPwDiff[1]<<4 |\r\npriv->AntennaTxPwDiff[0]);\r\nrtl92e_set_bb_reg(dev, rFPGA0_TxGainStage,\r\n(bXBTxAGC|bXCTxAGC|bXDTxAGC),\r\nu4RegValue);\r\n}\r\n}\r\nswitch (priv->rf_chip) {\r\ncase RF_8225:\r\nbreak;\r\ncase RF_8256:\r\nrtl92e_set_cck_tx_power(dev, powerlevel);\r\nrtl92e_set_ofdm_tx_power(dev, powerlevelOFDM24G);\r\nbreak;\r\ncase RF_8258:\r\nbreak;\r\ndefault:\r\nnetdev_err(dev, "Invalid RF Chip ID.\n");\r\nbreak;\r\n}\r\n}\r\nbool rtl92e_config_phy(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nbool rtStatus = true;\r\nswitch (priv->rf_chip) {\r\ncase RF_8225:\r\nbreak;\r\ncase RF_8256:\r\nrtStatus = rtl92e_config_rf(dev);\r\nbreak;\r\ncase RF_8258:\r\nbreak;\r\ncase RF_PSEUDO_11N:\r\nbreak;\r\ndefault:\r\nnetdev_err(dev, "Invalid RF Chip ID.\n");\r\nbreak;\r\n}\r\nreturn rtStatus;\r\n}\r\nu8 rtl92e_config_rf_path(struct net_device *dev, enum rf90_radio_path eRFPath)\r\n{\r\nint i;\r\nswitch (eRFPath) {\r\ncase RF90_PATH_A:\r\nfor (i = 0; i < RadioA_ArrayLength; i += 2) {\r\nif (Rtl819XRadioA_Array[i] == 0xfe) {\r\nmsleep(100);\r\ncontinue;\r\n}\r\nrtl92e_set_rf_reg(dev, eRFPath, Rtl819XRadioA_Array[i],\r\nbMask12Bits,\r\nRtl819XRadioA_Array[i+1]);\r\n}\r\nbreak;\r\ncase RF90_PATH_B:\r\nfor (i = 0; i < RadioB_ArrayLength; i += 2) {\r\nif (Rtl819XRadioB_Array[i] == 0xfe) {\r\nmsleep(100);\r\ncontinue;\r\n}\r\nrtl92e_set_rf_reg(dev, eRFPath, Rtl819XRadioB_Array[i],\r\nbMask12Bits,\r\nRtl819XRadioB_Array[i+1]);\r\n}\r\nbreak;\r\ncase RF90_PATH_C:\r\nfor (i = 0; i < RadioC_ArrayLength; i += 2) {\r\nif (Rtl819XRadioC_Array[i] == 0xfe) {\r\nmsleep(100);\r\ncontinue;\r\n}\r\nrtl92e_set_rf_reg(dev, eRFPath, Rtl819XRadioC_Array[i],\r\nbMask12Bits,\r\nRtl819XRadioC_Array[i+1]);\r\n}\r\nbreak;\r\ncase RF90_PATH_D:\r\nfor (i = 0; i < RadioD_ArrayLength; i += 2) {\r\nif (Rtl819XRadioD_Array[i] == 0xfe) {\r\nmsleep(100);\r\ncontinue;\r\n}\r\nrtl92e_set_rf_reg(dev, eRFPath, Rtl819XRadioD_Array[i],\r\nbMask12Bits,\r\nRtl819XRadioD_Array[i+1]);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void _rtl92e_set_tx_power_level(struct net_device *dev, u8 channel)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu8 powerlevel = priv->TxPowerLevelCCK[channel-1];\r\nu8 powerlevelOFDM24G = priv->TxPowerLevelOFDM24G[channel-1];\r\nswitch (priv->rf_chip) {\r\ncase RF_8225:\r\nbreak;\r\ncase RF_8256:\r\nrtl92e_set_cck_tx_power(dev, powerlevel);\r\nrtl92e_set_ofdm_tx_power(dev, powerlevelOFDM24G);\r\nbreak;\r\ncase RF_8258:\r\nbreak;\r\ndefault:\r\nnetdev_warn(dev, "%s(): Invalid RF Chip ID\n", __func__);\r\nbreak;\r\n}\r\n}\r\nstatic u8 _rtl92e_phy_set_sw_chnl_cmd_array(struct net_device *dev,\r\nstruct sw_chnl_cmd *CmdTable,\r\nu32 CmdTableIdx, u32 CmdTableSz,\r\nenum sw_chnl_cmd_id CmdID,\r\nu32 Para1, u32 Para2, u32 msDelay)\r\n{\r\nstruct sw_chnl_cmd *pCmd;\r\nif (CmdTable == NULL) {\r\nnetdev_err(dev, "%s(): CmdTable cannot be NULL.\n", __func__);\r\nreturn false;\r\n}\r\nif (CmdTableIdx >= CmdTableSz) {\r\nnetdev_err(dev, "%s(): Invalid index requested.\n", __func__);\r\nreturn false;\r\n}\r\npCmd = CmdTable + CmdTableIdx;\r\npCmd->CmdID = CmdID;\r\npCmd->Para1 = Para1;\r\npCmd->Para2 = Para2;\r\npCmd->msDelay = msDelay;\r\nreturn true;\r\n}\r\nstatic u8 _rtl92e_phy_switch_channel_step(struct net_device *dev, u8 channel,\r\nu8 *stage, u8 *step, u32 *delay)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rtllib_device *ieee = priv->rtllib;\r\nu32 PreCommonCmdCnt;\r\nu32 PostCommonCmdCnt;\r\nu32 RfDependCmdCnt;\r\nstruct sw_chnl_cmd *CurrentCmd = NULL;\r\nu8 eRFPath;\r\nRT_TRACE(COMP_TRACE, "====>%s()====stage:%d, step:%d, channel:%d\n",\r\n__func__, *stage, *step, channel);\r\nif (!rtllib_legal_channel(priv->rtllib, channel)) {\r\nnetdev_err(dev, "Invalid channel requested: %d\n", channel);\r\nreturn true;\r\n}\r\n{\r\nPreCommonCmdCnt = 0;\r\n_rtl92e_phy_set_sw_chnl_cmd_array(dev, ieee->PreCommonCmd,\r\nPreCommonCmdCnt++,\r\nMAX_PRECMD_CNT,\r\nCmdID_SetTxPowerLevel,\r\n0, 0, 0);\r\n_rtl92e_phy_set_sw_chnl_cmd_array(dev, ieee->PreCommonCmd,\r\nPreCommonCmdCnt++,\r\nMAX_PRECMD_CNT, CmdID_End,\r\n0, 0, 0);\r\nPostCommonCmdCnt = 0;\r\n_rtl92e_phy_set_sw_chnl_cmd_array(dev, ieee->PostCommonCmd,\r\nPostCommonCmdCnt++,\r\nMAX_POSTCMD_CNT, CmdID_End,\r\n0, 0, 0);\r\nRfDependCmdCnt = 0;\r\nswitch (priv->rf_chip) {\r\ncase RF_8225:\r\nif (!(channel >= 1 && channel <= 14)) {\r\nnetdev_err(dev,\r\n"Invalid channel requested for 8225: %d\n",\r\nchannel);\r\nreturn false;\r\n}\r\n_rtl92e_phy_set_sw_chnl_cmd_array(dev,\r\nieee->RfDependCmd,\r\nRfDependCmdCnt++,\r\nMAX_RFDEPENDCMD_CNT,\r\nCmdID_RF_WriteReg,\r\nrZebra1_Channel,\r\nRF_CHANNEL_TABLE_ZEBRA[channel],\r\n10);\r\n_rtl92e_phy_set_sw_chnl_cmd_array(dev,\r\nieee->RfDependCmd,\r\nRfDependCmdCnt++,\r\nMAX_RFDEPENDCMD_CNT,\r\nCmdID_End, 0, 0, 0);\r\nbreak;\r\ncase RF_8256:\r\nif (!(channel >= 1 && channel <= 14)) {\r\nnetdev_err(dev,\r\n"Invalid channel requested for 8256: %d\n",\r\nchannel);\r\nreturn false;\r\n}\r\n_rtl92e_phy_set_sw_chnl_cmd_array(dev,\r\nieee->RfDependCmd,\r\nRfDependCmdCnt++,\r\nMAX_RFDEPENDCMD_CNT,\r\nCmdID_RF_WriteReg,\r\nrZebra1_Channel,\r\nchannel, 10);\r\n_rtl92e_phy_set_sw_chnl_cmd_array(dev,\r\nieee->RfDependCmd,\r\nRfDependCmdCnt++,\r\nMAX_RFDEPENDCMD_CNT,\r\nCmdID_End, 0, 0, 0);\r\nbreak;\r\ncase RF_8258:\r\nbreak;\r\ndefault:\r\nnetdev_warn(dev, "Unknown RF Chip ID\n");\r\nreturn false;\r\n}\r\ndo {\r\nswitch (*stage) {\r\ncase 0:\r\nCurrentCmd = &ieee->PreCommonCmd[*step];\r\nbreak;\r\ncase 1:\r\nCurrentCmd = &ieee->RfDependCmd[*step];\r\nbreak;\r\ncase 2:\r\nCurrentCmd = &ieee->PostCommonCmd[*step];\r\nbreak;\r\n}\r\nif (CurrentCmd && CurrentCmd->CmdID == CmdID_End) {\r\nif ((*stage) == 2)\r\nreturn true;\r\n(*stage)++;\r\n(*step) = 0;\r\ncontinue;\r\n}\r\nif (!CurrentCmd)\r\ncontinue;\r\nswitch (CurrentCmd->CmdID) {\r\ncase CmdID_SetTxPowerLevel:\r\nif (priv->IC_Cut > (u8)VERSION_8190_BD)\r\n_rtl92e_set_tx_power_level(dev,\r\nchannel);\r\nbreak;\r\ncase CmdID_WritePortUlong:\r\nrtl92e_writel(dev, CurrentCmd->Para1,\r\nCurrentCmd->Para2);\r\nbreak;\r\ncase CmdID_WritePortUshort:\r\nrtl92e_writew(dev, CurrentCmd->Para1,\r\n(u16)CurrentCmd->Para2);\r\nbreak;\r\ncase CmdID_WritePortUchar:\r\nrtl92e_writeb(dev, CurrentCmd->Para1,\r\n(u8)CurrentCmd->Para2);\r\nbreak;\r\ncase CmdID_RF_WriteReg:\r\nfor (eRFPath = 0; eRFPath <\r\npriv->NumTotalRFPath; eRFPath++)\r\nrtl92e_set_rf_reg(dev,\r\n(enum rf90_radio_path)eRFPath,\r\nCurrentCmd->Para1, bMask12Bits,\r\nCurrentCmd->Para2<<7);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\n} while (true);\r\n}\r\n(*delay) = CurrentCmd->msDelay;\r\n(*step)++;\r\nreturn false;\r\n}\r\nstatic void _rtl92e_phy_switch_channel(struct net_device *dev, u8 channel)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu32 delay = 0;\r\nwhile (!_rtl92e_phy_switch_channel_step(dev, channel,\r\n&priv->SwChnlStage,\r\n&priv->SwChnlStep, &delay)) {\r\nif (delay > 0)\r\nmsleep(delay);\r\nif (!priv->up)\r\nbreak;\r\n}\r\n}\r\nstatic void _rtl92e_phy_switch_channel_work_item(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nRT_TRACE(COMP_TRACE, "==> SwChnlCallback819xUsbWorkItem()\n");\r\nRT_TRACE(COMP_TRACE, "=====>--%s(), set chan:%d, priv:%p\n", __func__,\r\npriv->chan, priv);\r\n_rtl92e_phy_switch_channel(dev, priv->chan);\r\nRT_TRACE(COMP_TRACE, "<== SwChnlCallback819xUsbWorkItem()\n");\r\n}\r\nu8 rtl92e_set_channel(struct net_device *dev, u8 channel)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nRT_TRACE(COMP_PHY, "=====>%s()\n", __func__);\r\nif (!priv->up) {\r\nnetdev_err(dev, "%s(): Driver is not initialized\n", __func__);\r\nreturn false;\r\n}\r\nif (priv->SwChnlInProgress)\r\nreturn false;\r\nswitch (priv->rtllib->mode) {\r\ncase WIRELESS_MODE_A:\r\ncase WIRELESS_MODE_N_5G:\r\nif (channel <= 14) {\r\nnetdev_warn(dev,\r\n"Channel %d not available in 802.11a.\n",\r\nchannel);\r\nreturn false;\r\n}\r\nbreak;\r\ncase WIRELESS_MODE_B:\r\nif (channel > 14) {\r\nnetdev_warn(dev,\r\n"Channel %d not available in 802.11b.\n",\r\nchannel);\r\nreturn false;\r\n}\r\nbreak;\r\ncase WIRELESS_MODE_G:\r\ncase WIRELESS_MODE_N_24G:\r\nif (channel > 14) {\r\nnetdev_warn(dev,\r\n"Channel %d not available in 802.11g.\n",\r\nchannel);\r\nreturn false;\r\n}\r\nbreak;\r\n}\r\npriv->SwChnlInProgress = true;\r\nif (channel == 0)\r\nchannel = 1;\r\npriv->chan = channel;\r\npriv->SwChnlStage = 0;\r\npriv->SwChnlStep = 0;\r\nif (priv->up)\r\n_rtl92e_phy_switch_channel_work_item(dev);\r\npriv->SwChnlInProgress = false;\r\nreturn true;\r\n}\r\nstatic void _rtl92e_cck_tx_power_track_bw_switch_tssi(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nswitch (priv->CurrentChannelBW) {\r\ncase HT_CHANNEL_WIDTH_20:\r\npriv->CCKPresentAttentuation =\r\npriv->CCKPresentAttentuation_20Mdefault +\r\npriv->CCKPresentAttentuation_difference;\r\nif (priv->CCKPresentAttentuation >\r\n(CCKTxBBGainTableLength-1))\r\npriv->CCKPresentAttentuation =\r\nCCKTxBBGainTableLength-1;\r\nif (priv->CCKPresentAttentuation < 0)\r\npriv->CCKPresentAttentuation = 0;\r\nRT_TRACE(COMP_POWER_TRACKING,\r\n"20M, priv->CCKPresentAttentuation = %d\n",\r\npriv->CCKPresentAttentuation);\r\nif (priv->rtllib->current_network.channel == 14 &&\r\n!priv->bcck_in_ch14) {\r\npriv->bcck_in_ch14 = true;\r\nrtl92e_dm_cck_txpower_adjust(dev, priv->bcck_in_ch14);\r\n} else if (priv->rtllib->current_network.channel !=\r\n14 && priv->bcck_in_ch14) {\r\npriv->bcck_in_ch14 = false;\r\nrtl92e_dm_cck_txpower_adjust(dev, priv->bcck_in_ch14);\r\n} else {\r\nrtl92e_dm_cck_txpower_adjust(dev, priv->bcck_in_ch14);\r\n}\r\nbreak;\r\ncase HT_CHANNEL_WIDTH_20_40:\r\npriv->CCKPresentAttentuation =\r\npriv->CCKPresentAttentuation_40Mdefault +\r\npriv->CCKPresentAttentuation_difference;\r\nRT_TRACE(COMP_POWER_TRACKING,\r\n"40M, priv->CCKPresentAttentuation = %d\n",\r\npriv->CCKPresentAttentuation);\r\nif (priv->CCKPresentAttentuation >\r\n(CCKTxBBGainTableLength - 1))\r\npriv->CCKPresentAttentuation =\r\nCCKTxBBGainTableLength-1;\r\nif (priv->CCKPresentAttentuation < 0)\r\npriv->CCKPresentAttentuation = 0;\r\nif (priv->rtllib->current_network.channel == 14 &&\r\n!priv->bcck_in_ch14) {\r\npriv->bcck_in_ch14 = true;\r\nrtl92e_dm_cck_txpower_adjust(dev, priv->bcck_in_ch14);\r\n} else if (priv->rtllib->current_network.channel != 14\r\n&& priv->bcck_in_ch14) {\r\npriv->bcck_in_ch14 = false;\r\nrtl92e_dm_cck_txpower_adjust(dev, priv->bcck_in_ch14);\r\n} else {\r\nrtl92e_dm_cck_txpower_adjust(dev, priv->bcck_in_ch14);\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void _rtl92e_cck_tx_power_track_bw_switch_thermal(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nif (priv->rtllib->current_network.channel == 14 &&\r\n!priv->bcck_in_ch14)\r\npriv->bcck_in_ch14 = true;\r\nelse if (priv->rtllib->current_network.channel != 14 &&\r\npriv->bcck_in_ch14)\r\npriv->bcck_in_ch14 = false;\r\nswitch (priv->CurrentChannelBW) {\r\ncase HT_CHANNEL_WIDTH_20:\r\nif (priv->Record_CCK_20Mindex == 0)\r\npriv->Record_CCK_20Mindex = 6;\r\npriv->CCK_index = priv->Record_CCK_20Mindex;\r\nRT_TRACE(COMP_POWER_TRACKING,\r\n"20MHz, _rtl92e_cck_tx_power_track_bw_switch_thermal(),CCK_index = %d\n",\r\npriv->CCK_index);\r\nbreak;\r\ncase HT_CHANNEL_WIDTH_20_40:\r\npriv->CCK_index = priv->Record_CCK_40Mindex;\r\nRT_TRACE(COMP_POWER_TRACKING,\r\n"40MHz, _rtl92e_cck_tx_power_track_bw_switch_thermal(), CCK_index = %d\n",\r\npriv->CCK_index);\r\nbreak;\r\n}\r\nrtl92e_dm_cck_txpower_adjust(dev, priv->bcck_in_ch14);\r\n}\r\nstatic void _rtl92e_cck_tx_power_track_bw_switch(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nif (priv->IC_Cut >= IC_VersionCut_D)\r\n_rtl92e_cck_tx_power_track_bw_switch_tssi(dev);\r\nelse\r\n_rtl92e_cck_tx_power_track_bw_switch_thermal(dev);\r\n}\r\nstatic void _rtl92e_set_bw_mode_work_item(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu8 regBwOpMode;\r\nRT_TRACE(COMP_SWBW,\r\n"==>_rtl92e_set_bw_mode_work_item() Switch to %s bandwidth\n",\r\npriv->CurrentChannelBW == HT_CHANNEL_WIDTH_20 ?\r\n"20MHz" : "40MHz");\r\nif (priv->rf_chip == RF_PSEUDO_11N) {\r\npriv->SetBWModeInProgress = false;\r\nreturn;\r\n}\r\nif (!priv->up) {\r\nnetdev_err(dev, "%s(): Driver is not initialized\n", __func__);\r\nreturn;\r\n}\r\nregBwOpMode = rtl92e_readb(dev, BW_OPMODE);\r\nswitch (priv->CurrentChannelBW) {\r\ncase HT_CHANNEL_WIDTH_20:\r\nregBwOpMode |= BW_OPMODE_20MHZ;\r\nrtl92e_writeb(dev, BW_OPMODE, regBwOpMode);\r\nbreak;\r\ncase HT_CHANNEL_WIDTH_20_40:\r\nregBwOpMode &= ~BW_OPMODE_20MHZ;\r\nrtl92e_writeb(dev, BW_OPMODE, regBwOpMode);\r\nbreak;\r\ndefault:\r\nnetdev_err(dev, "%s(): unknown Bandwidth: %#X\n", __func__,\r\npriv->CurrentChannelBW);\r\nbreak;\r\n}\r\nswitch (priv->CurrentChannelBW) {\r\ncase HT_CHANNEL_WIDTH_20:\r\nrtl92e_set_bb_reg(dev, rFPGA0_RFMOD, bRFMOD, 0x0);\r\nrtl92e_set_bb_reg(dev, rFPGA1_RFMOD, bRFMOD, 0x0);\r\nif (!priv->btxpower_tracking) {\r\nrtl92e_writel(dev, rCCK0_TxFilter1, 0x1a1b0000);\r\nrtl92e_writel(dev, rCCK0_TxFilter2, 0x090e1317);\r\nrtl92e_writel(dev, rCCK0_DebugPort, 0x00000204);\r\n} else {\r\n_rtl92e_cck_tx_power_track_bw_switch(dev);\r\n}\r\nrtl92e_set_bb_reg(dev, rFPGA0_AnalogParameter1, 0x00100000, 1);\r\nbreak;\r\ncase HT_CHANNEL_WIDTH_20_40:\r\nrtl92e_set_bb_reg(dev, rFPGA0_RFMOD, bRFMOD, 0x1);\r\nrtl92e_set_bb_reg(dev, rFPGA1_RFMOD, bRFMOD, 0x1);\r\nif (!priv->btxpower_tracking) {\r\nrtl92e_writel(dev, rCCK0_TxFilter1, 0x35360000);\r\nrtl92e_writel(dev, rCCK0_TxFilter2, 0x121c252e);\r\nrtl92e_writel(dev, rCCK0_DebugPort, 0x00000409);\r\n} else {\r\n_rtl92e_cck_tx_power_track_bw_switch(dev);\r\n}\r\nrtl92e_set_bb_reg(dev, rCCK0_System, bCCKSideBand,\r\n(priv->nCur40MhzPrimeSC>>1));\r\nrtl92e_set_bb_reg(dev, rOFDM1_LSTF, 0xC00,\r\npriv->nCur40MhzPrimeSC);\r\nrtl92e_set_bb_reg(dev, rFPGA0_AnalogParameter1, 0x00100000, 0);\r\nbreak;\r\ndefault:\r\nnetdev_err(dev, "%s(): unknown Bandwidth: %#X\n", __func__,\r\npriv->CurrentChannelBW);\r\nbreak;\r\n}\r\nswitch (priv->rf_chip) {\r\ncase RF_8225:\r\nbreak;\r\ncase RF_8256:\r\nrtl92e_set_bandwidth(dev, priv->CurrentChannelBW);\r\nbreak;\r\ncase RF_8258:\r\nbreak;\r\ncase RF_PSEUDO_11N:\r\nbreak;\r\ndefault:\r\nnetdev_info(dev, "%s(): Unknown RFChipID: %d\n", __func__,\r\npriv->rf_chip);\r\nbreak;\r\n}\r\natomic_dec(&(priv->rtllib->atm_swbw));\r\npriv->SetBWModeInProgress = false;\r\nRT_TRACE(COMP_SWBW, "<==SetBWMode819xUsb()");\r\n}\r\nvoid rtl92e_set_bw_mode(struct net_device *dev, enum ht_channel_width Bandwidth,\r\nenum ht_extchnl_offset Offset)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nif (priv->SetBWModeInProgress)\r\nreturn;\r\natomic_inc(&(priv->rtllib->atm_swbw));\r\npriv->SetBWModeInProgress = true;\r\npriv->CurrentChannelBW = Bandwidth;\r\nif (Offset == HT_EXTCHNL_OFFSET_LOWER)\r\npriv->nCur40MhzPrimeSC = HAL_PRIME_CHNL_OFFSET_UPPER;\r\nelse if (Offset == HT_EXTCHNL_OFFSET_UPPER)\r\npriv->nCur40MhzPrimeSC = HAL_PRIME_CHNL_OFFSET_LOWER;\r\nelse\r\npriv->nCur40MhzPrimeSC = HAL_PRIME_CHNL_OFFSET_DONT_CARE;\r\n_rtl92e_set_bw_mode_work_item(dev);\r\n}\r\nvoid rtl92e_init_gain(struct net_device *dev, u8 Operation)\r\n{\r\n#define SCAN_RX_INITIAL_GAIN 0x17\r\n#define POWER_DETECTION_TH 0x08\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu32 BitMask;\r\nu8 initial_gain;\r\nif (priv->up) {\r\nswitch (Operation) {\r\ncase IG_Backup:\r\nRT_TRACE(COMP_SCAN,\r\n"IG_Backup, backup the initial gain.\n");\r\ninitial_gain = SCAN_RX_INITIAL_GAIN;\r\nBitMask = bMaskByte0;\r\nif (dm_digtable.dig_algorithm ==\r\nDIG_ALGO_BY_FALSE_ALARM)\r\nrtl92e_set_bb_reg(dev, UFWP, bMaskByte1, 0x8);\r\npriv->initgain_backup.xaagccore1 =\r\n(u8)rtl92e_get_bb_reg(dev, rOFDM0_XAAGCCore1,\r\nBitMask);\r\npriv->initgain_backup.xbagccore1 =\r\n(u8)rtl92e_get_bb_reg(dev, rOFDM0_XBAGCCore1,\r\nBitMask);\r\npriv->initgain_backup.xcagccore1 =\r\n(u8)rtl92e_get_bb_reg(dev, rOFDM0_XCAGCCore1,\r\nBitMask);\r\npriv->initgain_backup.xdagccore1 =\r\n(u8)rtl92e_get_bb_reg(dev, rOFDM0_XDAGCCore1,\r\nBitMask);\r\nBitMask = bMaskByte2;\r\npriv->initgain_backup.cca = (u8)rtl92e_get_bb_reg(dev,\r\nrCCK0_CCA, BitMask);\r\nRT_TRACE(COMP_SCAN,\r\n"Scan InitialGainBackup 0xc50 is %x\n",\r\npriv->initgain_backup.xaagccore1);\r\nRT_TRACE(COMP_SCAN,\r\n"Scan InitialGainBackup 0xc58 is %x\n",\r\npriv->initgain_backup.xbagccore1);\r\nRT_TRACE(COMP_SCAN,\r\n"Scan InitialGainBackup 0xc60 is %x\n",\r\npriv->initgain_backup.xcagccore1);\r\nRT_TRACE(COMP_SCAN,\r\n"Scan InitialGainBackup 0xc68 is %x\n",\r\npriv->initgain_backup.xdagccore1);\r\nRT_TRACE(COMP_SCAN,\r\n"Scan InitialGainBackup 0xa0a is %x\n",\r\npriv->initgain_backup.cca);\r\nRT_TRACE(COMP_SCAN, "Write scan initial gain = 0x%x\n",\r\ninitial_gain);\r\nrtl92e_writeb(dev, rOFDM0_XAAGCCore1, initial_gain);\r\nrtl92e_writeb(dev, rOFDM0_XBAGCCore1, initial_gain);\r\nrtl92e_writeb(dev, rOFDM0_XCAGCCore1, initial_gain);\r\nrtl92e_writeb(dev, rOFDM0_XDAGCCore1, initial_gain);\r\nRT_TRACE(COMP_SCAN, "Write scan 0xa0a = 0x%x\n",\r\nPOWER_DETECTION_TH);\r\nrtl92e_writeb(dev, 0xa0a, POWER_DETECTION_TH);\r\nbreak;\r\ncase IG_Restore:\r\nRT_TRACE(COMP_SCAN,\r\n"IG_Restore, restore the initial gain.\n");\r\nBitMask = 0x7f;\r\nif (dm_digtable.dig_algorithm ==\r\nDIG_ALGO_BY_FALSE_ALARM)\r\nrtl92e_set_bb_reg(dev, UFWP, bMaskByte1, 0x8);\r\nrtl92e_set_bb_reg(dev, rOFDM0_XAAGCCore1, BitMask,\r\n(u32)priv->initgain_backup.xaagccore1);\r\nrtl92e_set_bb_reg(dev, rOFDM0_XBAGCCore1, BitMask,\r\n(u32)priv->initgain_backup.xbagccore1);\r\nrtl92e_set_bb_reg(dev, rOFDM0_XCAGCCore1, BitMask,\r\n(u32)priv->initgain_backup.xcagccore1);\r\nrtl92e_set_bb_reg(dev, rOFDM0_XDAGCCore1, BitMask,\r\n(u32)priv->initgain_backup.xdagccore1);\r\nBitMask = bMaskByte2;\r\nrtl92e_set_bb_reg(dev, rCCK0_CCA, BitMask,\r\n(u32)priv->initgain_backup.cca);\r\nRT_TRACE(COMP_SCAN,\r\n"Scan BBInitialGainRestore 0xc50 is %x\n",\r\npriv->initgain_backup.xaagccore1);\r\nRT_TRACE(COMP_SCAN,\r\n"Scan BBInitialGainRestore 0xc58 is %x\n",\r\npriv->initgain_backup.xbagccore1);\r\nRT_TRACE(COMP_SCAN,\r\n"Scan BBInitialGainRestore 0xc60 is %x\n",\r\npriv->initgain_backup.xcagccore1);\r\nRT_TRACE(COMP_SCAN,\r\n"Scan BBInitialGainRestore 0xc68 is %x\n",\r\npriv->initgain_backup.xdagccore1);\r\nRT_TRACE(COMP_SCAN,\r\n"Scan BBInitialGainRestore 0xa0a is %x\n",\r\npriv->initgain_backup.cca);\r\nrtl92e_set_tx_power(dev,\r\npriv->rtllib->current_network.channel);\r\nif (dm_digtable.dig_algorithm ==\r\nDIG_ALGO_BY_FALSE_ALARM)\r\nrtl92e_set_bb_reg(dev, UFWP, bMaskByte1, 0x1);\r\nbreak;\r\ndefault:\r\nRT_TRACE(COMP_SCAN, "Unknown IG Operation.\n");\r\nbreak;\r\n}\r\n}\r\n}\r\nvoid rtl92e_set_rf_off(struct net_device *dev)\r\n{\r\nrtl92e_set_bb_reg(dev, rFPGA0_XA_RFInterfaceOE, BIT4, 0x0);\r\nrtl92e_set_bb_reg(dev, rFPGA0_AnalogParameter4, 0x300, 0x0);\r\nrtl92e_set_bb_reg(dev, rFPGA0_AnalogParameter1, 0x18, 0x0);\r\nrtl92e_set_bb_reg(dev, rOFDM0_TRxPathEnable, 0xf, 0x0);\r\nrtl92e_set_bb_reg(dev, rOFDM1_TRxPathEnable, 0xf, 0x0);\r\nrtl92e_set_bb_reg(dev, rFPGA0_AnalogParameter1, 0x60, 0x0);\r\nrtl92e_set_bb_reg(dev, rFPGA0_AnalogParameter1, 0x4, 0x0);\r\nrtl92e_writeb(dev, ANAPAR_FOR_8192PciE, 0x07);\r\n}\r\nstatic bool _rtl92e_set_rf_power_state(struct net_device *dev,\r\nenum rt_rf_power_state eRFPowerState)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rt_pwr_save_ctrl *pPSC = (struct rt_pwr_save_ctrl *)\r\n(&(priv->rtllib->PowerSaveControl));\r\nbool bResult = true;\r\nu8 i = 0, QueueID = 0;\r\nstruct rtl8192_tx_ring *ring = NULL;\r\nif (priv->SetRFPowerStateInProgress)\r\nreturn false;\r\nRT_TRACE(COMP_PS, "===========> _rtl92e_set_rf_power_state()!\n");\r\npriv->SetRFPowerStateInProgress = true;\r\nswitch (priv->rf_chip) {\r\ncase RF_8256:\r\nswitch (eRFPowerState) {\r\ncase eRfOn:\r\nRT_TRACE(COMP_PS,\r\n"_rtl92e_set_rf_power_state() eRfOn!\n");\r\nif ((priv->rtllib->eRFPowerState == eRfOff) &&\r\nRT_IN_PS_LEVEL(pPSC, RT_RF_OFF_LEVL_HALT_NIC)) {\r\nbool rtstatus = true;\r\nu32 InitilizeCount = 3;\r\ndo {\r\nInitilizeCount--;\r\npriv->RegRfOff = false;\r\nrtstatus = rtl92e_enable_nic(dev);\r\n} while (!rtstatus && (InitilizeCount > 0));\r\nif (!rtstatus) {\r\nnetdev_err(dev,\r\n"%s(): Failed to initialize Adapter.\n",\r\n__func__);\r\npriv->SetRFPowerStateInProgress = false;\r\nreturn false;\r\n}\r\nRT_CLEAR_PS_LEVEL(pPSC,\r\nRT_RF_OFF_LEVL_HALT_NIC);\r\n} else {\r\nrtl92e_writeb(dev, ANAPAR, 0x37);\r\nmdelay(1);\r\nrtl92e_set_bb_reg(dev, rFPGA0_AnalogParameter1,\r\n0x4, 0x1);\r\npriv->bHwRfOffAction = 0;\r\nrtl92e_set_bb_reg(dev, rFPGA0_XA_RFInterfaceOE,\r\nBIT4, 0x1);\r\nrtl92e_set_bb_reg(dev, rFPGA0_AnalogParameter4,\r\n0x300, 0x3);\r\nrtl92e_set_bb_reg(dev, rFPGA0_AnalogParameter1,\r\n0x18, 0x3);\r\nrtl92e_set_bb_reg(dev, rOFDM0_TRxPathEnable,\r\n0x3, 0x3);\r\nrtl92e_set_bb_reg(dev, rOFDM1_TRxPathEnable,\r\n0x3, 0x3);\r\nrtl92e_set_bb_reg(dev, rFPGA0_AnalogParameter1,\r\n0x60, 0x3);\r\n}\r\nbreak;\r\ncase eRfSleep:\r\nif (priv->rtllib->eRFPowerState == eRfOff)\r\nbreak;\r\nfor (QueueID = 0, i = 0; QueueID < MAX_TX_QUEUE; ) {\r\nring = &priv->tx_ring[QueueID];\r\nif (skb_queue_len(&ring->queue) == 0) {\r\nQueueID++;\r\ncontinue;\r\n} else {\r\nRT_TRACE((COMP_POWER|COMP_RF),\r\n"eRf Off/Sleep: %d times TcbBusyQueue[%d] !=0 before doze!\n",\r\n(i+1), QueueID);\r\nudelay(10);\r\ni++;\r\n}\r\nif (i >= MAX_DOZE_WAITING_TIMES_9x) {\r\nRT_TRACE(COMP_POWER,\r\n"\n\n\n TimeOut!! _rtl92e_set_rf_power_state(): eRfOff: %d times TcbBusyQueue[%d] != 0 !!!\n",\r\nMAX_DOZE_WAITING_TIMES_9x,\r\nQueueID);\r\nbreak;\r\n}\r\n}\r\nrtl92e_set_rf_off(dev);\r\nbreak;\r\ncase eRfOff:\r\nRT_TRACE(COMP_PS,\r\n"_rtl92e_set_rf_power_state() eRfOff/Sleep !\n");\r\nfor (QueueID = 0, i = 0; QueueID < MAX_TX_QUEUE; ) {\r\nring = &priv->tx_ring[QueueID];\r\nif (skb_queue_len(&ring->queue) == 0) {\r\nQueueID++;\r\ncontinue;\r\n} else {\r\nRT_TRACE(COMP_POWER,\r\n"eRf Off/Sleep: %d times TcbBusyQueue[%d] !=0 before doze!\n",\r\n(i+1), QueueID);\r\nudelay(10);\r\ni++;\r\n}\r\nif (i >= MAX_DOZE_WAITING_TIMES_9x) {\r\nRT_TRACE(COMP_POWER,\r\n"\n\n\n SetZebra: RFPowerState8185B(): eRfOff: %d times TcbBusyQueue[%d] != 0 !!!\n",\r\nMAX_DOZE_WAITING_TIMES_9x,\r\nQueueID);\r\nbreak;\r\n}\r\n}\r\nif (pPSC->RegRfPsLevel & RT_RF_OFF_LEVL_HALT_NIC &&\r\n!RT_IN_PS_LEVEL(pPSC, RT_RF_OFF_LEVL_HALT_NIC)) {\r\nrtl92e_disable_nic(dev);\r\nRT_SET_PS_LEVEL(pPSC, RT_RF_OFF_LEVL_HALT_NIC);\r\n} else if (!(pPSC->RegRfPsLevel &\r\nRT_RF_OFF_LEVL_HALT_NIC)) {\r\nrtl92e_set_rf_off(dev);\r\n}\r\nbreak;\r\ndefault:\r\nbResult = false;\r\nnetdev_warn(dev,\r\n"%s(): Unknown state requested: 0x%X.\n",\r\n__func__, eRFPowerState);\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nnetdev_warn(dev, "%s(): Unknown RF type\n", __func__);\r\nbreak;\r\n}\r\nif (bResult) {\r\npriv->rtllib->eRFPowerState = eRFPowerState;\r\nswitch (priv->rf_chip) {\r\ncase RF_8256:\r\nbreak;\r\ndefault:\r\nnetdev_warn(dev, "%s(): Unknown RF type\n", __func__);\r\nbreak;\r\n}\r\n}\r\npriv->SetRFPowerStateInProgress = false;\r\nRT_TRACE(COMP_PS,\r\n"<=========== _rtl92e_set_rf_power_state() bResult = %d!\n",\r\nbResult);\r\nreturn bResult;\r\n}\r\nbool rtl92e_set_rf_power_state(struct net_device *dev,\r\nenum rt_rf_power_state eRFPowerState)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nbool bResult = false;\r\nRT_TRACE(COMP_PS,\r\n"---------> rtl92e_set_rf_power_state(): eRFPowerState(%d)\n",\r\neRFPowerState);\r\nif (eRFPowerState == priv->rtllib->eRFPowerState &&\r\npriv->bHwRfOffAction == 0) {\r\nRT_TRACE(COMP_PS,\r\n"<--------- rtl92e_set_rf_power_state(): discard the request for eRFPowerState(%d) is the same.\n",\r\neRFPowerState);\r\nreturn bResult;\r\n}\r\nbResult = _rtl92e_set_rf_power_state(dev, eRFPowerState);\r\nRT_TRACE(COMP_PS,\r\n"<--------- rtl92e_set_rf_power_state(): bResult(%d)\n",\r\nbResult);\r\nreturn bResult;\r\n}\r\nvoid rtl92e_scan_op_backup(struct net_device *dev, u8 Operation)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nif (priv->up) {\r\nswitch (Operation) {\r\ncase SCAN_OPT_BACKUP:\r\npriv->rtllib->InitialGainHandler(dev, IG_Backup);\r\nbreak;\r\ncase SCAN_OPT_RESTORE:\r\npriv->rtllib->InitialGainHandler(dev, IG_Restore);\r\nbreak;\r\ndefault:\r\nRT_TRACE(COMP_SCAN, "Unknown Scan Backup Operation.\n");\r\nbreak;\r\n}\r\n}\r\n}
