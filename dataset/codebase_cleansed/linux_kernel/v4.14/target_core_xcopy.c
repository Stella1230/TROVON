static int target_xcopy_gen_naa_ieee(struct se_device *dev, unsigned char *buf)\r\n{\r\nint off = 0;\r\nbuf[off++] = (0x6 << 4);\r\nbuf[off++] = 0x01;\r\nbuf[off++] = 0x40;\r\nbuf[off] = (0x5 << 4);\r\nspc_parse_naa_6h_vendor_specific(dev, &buf[off]);\r\nreturn 0;\r\n}\r\nstatic int target_xcopy_locate_se_dev_e4_iter(struct se_device *se_dev,\r\nvoid *data)\r\n{\r\nstruct xcopy_dev_search_info *info = data;\r\nunsigned char tmp_dev_wwn[XCOPY_NAA_IEEE_REGEX_LEN];\r\nint rc;\r\nif (!se_dev->dev_attrib.emulate_3pc)\r\nreturn 0;\r\nmemset(&tmp_dev_wwn[0], 0, XCOPY_NAA_IEEE_REGEX_LEN);\r\ntarget_xcopy_gen_naa_ieee(se_dev, &tmp_dev_wwn[0]);\r\nrc = memcmp(&tmp_dev_wwn[0], info->dev_wwn, XCOPY_NAA_IEEE_REGEX_LEN);\r\nif (rc != 0)\r\nreturn 0;\r\ninfo->found_dev = se_dev;\r\npr_debug("XCOPY 0xe4: located se_dev: %p\n", se_dev);\r\nrc = target_depend_item(&se_dev->dev_group.cg_item);\r\nif (rc != 0) {\r\npr_err("configfs_depend_item attempt failed: %d for se_dev: %p\n",\r\nrc, se_dev);\r\nreturn rc;\r\n}\r\npr_debug("Called configfs_depend_item for se_dev: %p se_dev->se_dev_group: %p\n",\r\nse_dev, &se_dev->dev_group);\r\nreturn 1;\r\n}\r\nstatic int target_xcopy_locate_se_dev_e4(const unsigned char *dev_wwn,\r\nstruct se_device **found_dev)\r\n{\r\nstruct xcopy_dev_search_info info;\r\nint ret;\r\nmemset(&info, 0, sizeof(info));\r\ninfo.dev_wwn = dev_wwn;\r\nret = target_for_each_device(target_xcopy_locate_se_dev_e4_iter, &info);\r\nif (ret == 1) {\r\n*found_dev = info.found_dev;\r\nreturn 0;\r\n} else {\r\npr_debug_ratelimited("Unable to locate 0xe4 descriptor for EXTENDED_COPY\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int target_xcopy_parse_tiddesc_e4(struct se_cmd *se_cmd, struct xcopy_op *xop,\r\nunsigned char *p, unsigned short cscd_index)\r\n{\r\nunsigned char *desc = p;\r\nunsigned short ript;\r\nu8 desig_len;\r\nript = get_unaligned_be16(&desc[2]);\r\npr_debug("XCOPY 0xe4: RELATIVE INITIATOR PORT IDENTIFIER: %hu\n", ript);\r\nif ((desc[4] & 0x0f) != 0x1) {\r\npr_err("XCOPY 0xe4: code set of non binary type not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif ((desc[5] & 0x30) != 0x00) {\r\npr_err("XCOPY 0xe4: association other than LUN not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif ((desc[5] & 0x0f) != 0x3) {\r\npr_err("XCOPY 0xe4: designator type unsupported: 0x%02x\n",\r\n(desc[5] & 0x0f));\r\nreturn -EINVAL;\r\n}\r\ndesig_len = desc[7];\r\nif (desig_len != 16) {\r\npr_err("XCOPY 0xe4: invalid desig_len: %d\n", (int)desig_len);\r\nreturn -EINVAL;\r\n}\r\npr_debug("XCOPY 0xe4: desig_len: %d\n", (int)desig_len);\r\nif ((desc[8] & 0xf0) != 0x60) {\r\npr_err("XCOPY 0xe4: Unsupported DESIGNATOR TYPE: 0x%02x\n",\r\n(desc[8] & 0xf0));\r\nreturn -EINVAL;\r\n}\r\nif (cscd_index != xop->stdi && cscd_index != xop->dtdi) {\r\npr_debug("XCOPY 0xe4: ignoring CSCD entry %d - neither src nor "\r\n"dest\n", cscd_index);\r\nreturn 0;\r\n}\r\nif (cscd_index == xop->stdi) {\r\nmemcpy(&xop->src_tid_wwn[0], &desc[8], XCOPY_NAA_IEEE_REGEX_LEN);\r\nif (!memcmp(&xop->local_dev_wwn[0], &xop->src_tid_wwn[0],\r\nXCOPY_NAA_IEEE_REGEX_LEN)) {\r\nxop->op_origin = XCOL_SOURCE_RECV_OP;\r\nxop->src_dev = se_cmd->se_dev;\r\npr_debug("XCOPY 0xe4: Set xop->src_dev %p from source"\r\n" received xop\n", xop->src_dev);\r\n}\r\n}\r\nif (cscd_index == xop->dtdi) {\r\nmemcpy(&xop->dst_tid_wwn[0], &desc[8], XCOPY_NAA_IEEE_REGEX_LEN);\r\nif (!memcmp(&xop->local_dev_wwn[0], &xop->dst_tid_wwn[0],\r\nXCOPY_NAA_IEEE_REGEX_LEN)) {\r\nxop->op_origin = XCOL_DEST_RECV_OP;\r\nxop->dst_dev = se_cmd->se_dev;\r\npr_debug("XCOPY 0xe4: Set xop->dst_dev: %p from destination"\r\n" received xop\n", xop->dst_dev);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int target_xcopy_parse_target_descriptors(struct se_cmd *se_cmd,\r\nstruct xcopy_op *xop, unsigned char *p,\r\nunsigned short tdll, sense_reason_t *sense_ret)\r\n{\r\nstruct se_device *local_dev = se_cmd->se_dev;\r\nunsigned char *desc = p;\r\nint offset = tdll % XCOPY_TARGET_DESC_LEN, rc;\r\nunsigned short cscd_index = 0;\r\nunsigned short start = 0;\r\n*sense_ret = TCM_INVALID_PARAMETER_LIST;\r\nif (offset != 0) {\r\npr_err("XCOPY target descriptor list length is not"\r\n" multiple of %d\n", XCOPY_TARGET_DESC_LEN);\r\n*sense_ret = TCM_UNSUPPORTED_TARGET_DESC_TYPE_CODE;\r\nreturn -EINVAL;\r\n}\r\nif (tdll > RCR_OP_MAX_TARGET_DESC_COUNT * XCOPY_TARGET_DESC_LEN) {\r\npr_err("XCOPY target descriptor supports a maximum"\r\n" two src/dest descriptors, tdll: %hu too large..\n", tdll);\r\n*sense_ret = TCM_TOO_MANY_TARGET_DESCS;\r\nreturn -EINVAL;\r\n}\r\nmemset(&xop->local_dev_wwn[0], 0, XCOPY_NAA_IEEE_REGEX_LEN);\r\ntarget_xcopy_gen_naa_ieee(local_dev, &xop->local_dev_wwn[0]);\r\nwhile (start < tdll) {\r\nswitch (desc[0]) {\r\ncase 0xe4:\r\nrc = target_xcopy_parse_tiddesc_e4(se_cmd, xop,\r\n&desc[0], cscd_index);\r\nif (rc != 0)\r\ngoto out;\r\nstart += XCOPY_TARGET_DESC_LEN;\r\ndesc += XCOPY_TARGET_DESC_LEN;\r\ncscd_index++;\r\nbreak;\r\ndefault:\r\npr_err("XCOPY unsupported descriptor type code:"\r\n" 0x%02x\n", desc[0]);\r\n*sense_ret = TCM_UNSUPPORTED_TARGET_DESC_TYPE_CODE;\r\ngoto out;\r\n}\r\n}\r\nswitch (xop->op_origin) {\r\ncase XCOL_SOURCE_RECV_OP:\r\nrc = target_xcopy_locate_se_dev_e4(xop->dst_tid_wwn,\r\n&xop->dst_dev);\r\nbreak;\r\ncase XCOL_DEST_RECV_OP:\r\nrc = target_xcopy_locate_se_dev_e4(xop->src_tid_wwn,\r\n&xop->src_dev);\r\nbreak;\r\ndefault:\r\npr_err("XCOPY CSCD descriptor IDs not found in CSCD list - "\r\n"stdi: %hu dtdi: %hu\n", xop->stdi, xop->dtdi);\r\nrc = -EINVAL;\r\nbreak;\r\n}\r\nif (rc < 0) {\r\n*sense_ret = TCM_COPY_TARGET_DEVICE_NOT_REACHABLE;\r\ngoto out;\r\n}\r\npr_debug("XCOPY TGT desc: Source dev: %p NAA IEEE WWN: 0x%16phN\n",\r\nxop->src_dev, &xop->src_tid_wwn[0]);\r\npr_debug("XCOPY TGT desc: Dest dev: %p NAA IEEE WWN: 0x%16phN\n",\r\nxop->dst_dev, &xop->dst_tid_wwn[0]);\r\nreturn cscd_index;\r\nout:\r\nreturn -EINVAL;\r\n}\r\nstatic int target_xcopy_parse_segdesc_02(struct se_cmd *se_cmd, struct xcopy_op *xop,\r\nunsigned char *p)\r\n{\r\nunsigned char *desc = p;\r\nint dc = (desc[1] & 0x02);\r\nunsigned short desc_len;\r\ndesc_len = get_unaligned_be16(&desc[2]);\r\nif (desc_len != 0x18) {\r\npr_err("XCOPY segment desc 0x02: Illegal desc_len:"\r\n" %hu\n", desc_len);\r\nreturn -EINVAL;\r\n}\r\nxop->stdi = get_unaligned_be16(&desc[4]);\r\nxop->dtdi = get_unaligned_be16(&desc[6]);\r\nif (xop->stdi > XCOPY_CSCD_DESC_ID_LIST_OFF_MAX ||\r\nxop->dtdi > XCOPY_CSCD_DESC_ID_LIST_OFF_MAX) {\r\npr_err("XCOPY segment desc 0x02: unsupported CSCD ID > 0x%x; stdi: %hu dtdi: %hu\n",\r\nXCOPY_CSCD_DESC_ID_LIST_OFF_MAX, xop->stdi, xop->dtdi);\r\nreturn -EINVAL;\r\n}\r\npr_debug("XCOPY seg desc 0x02: desc_len: %hu stdi: %hu dtdi: %hu, DC: %d\n",\r\ndesc_len, xop->stdi, xop->dtdi, dc);\r\nxop->nolb = get_unaligned_be16(&desc[10]);\r\nxop->src_lba = get_unaligned_be64(&desc[12]);\r\nxop->dst_lba = get_unaligned_be64(&desc[20]);\r\npr_debug("XCOPY seg desc 0x02: nolb: %hu src_lba: %llu dst_lba: %llu\n",\r\nxop->nolb, (unsigned long long)xop->src_lba,\r\n(unsigned long long)xop->dst_lba);\r\nif (dc != 0) {\r\nxop->dbl = get_unaligned_be24(&desc[29]);\r\npr_debug("XCOPY seg desc 0x02: DC=1 w/ dbl: %u\n", xop->dbl);\r\n}\r\nreturn 0;\r\n}\r\nstatic int target_xcopy_parse_segment_descriptors(struct se_cmd *se_cmd,\r\nstruct xcopy_op *xop, unsigned char *p,\r\nunsigned int sdll, sense_reason_t *sense_ret)\r\n{\r\nunsigned char *desc = p;\r\nunsigned int start = 0;\r\nint offset = sdll % XCOPY_SEGMENT_DESC_LEN, rc, ret = 0;\r\n*sense_ret = TCM_INVALID_PARAMETER_LIST;\r\nif (offset != 0) {\r\npr_err("XCOPY segment descriptor list length is not"\r\n" multiple of %d\n", XCOPY_SEGMENT_DESC_LEN);\r\n*sense_ret = TCM_UNSUPPORTED_SEGMENT_DESC_TYPE_CODE;\r\nreturn -EINVAL;\r\n}\r\nif (sdll > RCR_OP_MAX_SG_DESC_COUNT * XCOPY_SEGMENT_DESC_LEN) {\r\npr_err("XCOPY supports %u segment descriptor(s), sdll: %u too"\r\n" large..\n", RCR_OP_MAX_SG_DESC_COUNT, sdll);\r\n*sense_ret = TCM_TOO_MANY_SEGMENT_DESCS;\r\nreturn -EINVAL;\r\n}\r\nwhile (start < sdll) {\r\nswitch (desc[0]) {\r\ncase 0x02:\r\nrc = target_xcopy_parse_segdesc_02(se_cmd, xop, desc);\r\nif (rc < 0)\r\ngoto out;\r\nret++;\r\nstart += XCOPY_SEGMENT_DESC_LEN;\r\ndesc += XCOPY_SEGMENT_DESC_LEN;\r\nbreak;\r\ndefault:\r\npr_err("XCOPY unsupported segment descriptor"\r\n"type: 0x%02x\n", desc[0]);\r\n*sense_ret = TCM_UNSUPPORTED_SEGMENT_DESC_TYPE_CODE;\r\ngoto out;\r\n}\r\n}\r\nreturn ret;\r\nout:\r\nreturn -EINVAL;\r\n}\r\nstatic char *xcopy_pt_get_fabric_name(void)\r\n{\r\nreturn "xcopy-pt";\r\n}\r\nstatic int xcopy_pt_get_cmd_state(struct se_cmd *se_cmd)\r\n{\r\nreturn 0;\r\n}\r\nstatic void xcopy_pt_undepend_remotedev(struct xcopy_op *xop)\r\n{\r\nstruct se_device *remote_dev;\r\nif (xop->op_origin == XCOL_SOURCE_RECV_OP)\r\nremote_dev = xop->dst_dev;\r\nelse\r\nremote_dev = xop->src_dev;\r\npr_debug("Calling configfs_undepend_item for"\r\n" remote_dev: %p remote_dev->dev_group: %p\n",\r\nremote_dev, &remote_dev->dev_group.cg_item);\r\ntarget_undepend_item(&remote_dev->dev_group.cg_item);\r\n}\r\nstatic void xcopy_pt_release_cmd(struct se_cmd *se_cmd)\r\n{\r\nstruct xcopy_pt_cmd *xpt_cmd = container_of(se_cmd,\r\nstruct xcopy_pt_cmd, se_cmd);\r\nkfree(xpt_cmd);\r\n}\r\nstatic int xcopy_pt_check_stop_free(struct se_cmd *se_cmd)\r\n{\r\nstruct xcopy_pt_cmd *xpt_cmd = container_of(se_cmd,\r\nstruct xcopy_pt_cmd, se_cmd);\r\ncomplete(&xpt_cmd->xpt_passthrough_sem);\r\nreturn 0;\r\n}\r\nstatic int xcopy_pt_write_pending(struct se_cmd *se_cmd)\r\n{\r\nreturn 0;\r\n}\r\nstatic int xcopy_pt_write_pending_status(struct se_cmd *se_cmd)\r\n{\r\nreturn 0;\r\n}\r\nstatic int xcopy_pt_queue_data_in(struct se_cmd *se_cmd)\r\n{\r\nreturn 0;\r\n}\r\nstatic int xcopy_pt_queue_status(struct se_cmd *se_cmd)\r\n{\r\nreturn 0;\r\n}\r\nint target_xcopy_setup_pt(void)\r\n{\r\nxcopy_wq = alloc_workqueue("xcopy_wq", WQ_MEM_RECLAIM, 0);\r\nif (!xcopy_wq) {\r\npr_err("Unable to allocate xcopy_wq\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(&xcopy_pt_tpg, 0, sizeof(struct se_portal_group));\r\nINIT_LIST_HEAD(&xcopy_pt_tpg.se_tpg_node);\r\nINIT_LIST_HEAD(&xcopy_pt_tpg.acl_node_list);\r\nINIT_LIST_HEAD(&xcopy_pt_tpg.tpg_sess_list);\r\nxcopy_pt_tpg.se_tpg_tfo = &xcopy_pt_tfo;\r\nmemset(&xcopy_pt_nacl, 0, sizeof(struct se_node_acl));\r\nINIT_LIST_HEAD(&xcopy_pt_nacl.acl_list);\r\nINIT_LIST_HEAD(&xcopy_pt_nacl.acl_sess_list);\r\nmemset(&xcopy_pt_sess, 0, sizeof(struct se_session));\r\nINIT_LIST_HEAD(&xcopy_pt_sess.sess_list);\r\nINIT_LIST_HEAD(&xcopy_pt_sess.sess_acl_list);\r\nINIT_LIST_HEAD(&xcopy_pt_sess.sess_cmd_list);\r\nspin_lock_init(&xcopy_pt_sess.sess_cmd_lock);\r\nxcopy_pt_nacl.se_tpg = &xcopy_pt_tpg;\r\nxcopy_pt_nacl.nacl_sess = &xcopy_pt_sess;\r\nxcopy_pt_sess.se_tpg = &xcopy_pt_tpg;\r\nxcopy_pt_sess.se_node_acl = &xcopy_pt_nacl;\r\nreturn 0;\r\n}\r\nvoid target_xcopy_release_pt(void)\r\n{\r\nif (xcopy_wq)\r\ndestroy_workqueue(xcopy_wq);\r\n}\r\nstatic void target_xcopy_setup_pt_port(\r\nstruct xcopy_pt_cmd *xpt_cmd,\r\nstruct xcopy_op *xop,\r\nbool remote_port)\r\n{\r\nstruct se_cmd *ec_cmd = xop->xop_se_cmd;\r\nstruct se_cmd *pt_cmd = &xpt_cmd->se_cmd;\r\nif (xop->op_origin == XCOL_SOURCE_RECV_OP) {\r\nif (remote_port) {\r\nxpt_cmd->remote_port = remote_port;\r\n} else {\r\npt_cmd->se_lun = ec_cmd->se_lun;\r\npt_cmd->se_dev = ec_cmd->se_dev;\r\npr_debug("Honoring local SRC port from ec_cmd->se_dev:"\r\n" %p\n", pt_cmd->se_dev);\r\npt_cmd->se_lun = ec_cmd->se_lun;\r\npr_debug("Honoring local SRC port from ec_cmd->se_lun: %p\n",\r\npt_cmd->se_lun);\r\n}\r\n} else {\r\nif (remote_port) {\r\nxpt_cmd->remote_port = remote_port;\r\n} else {\r\npt_cmd->se_lun = ec_cmd->se_lun;\r\npt_cmd->se_dev = ec_cmd->se_dev;\r\npr_debug("Honoring local DST port from ec_cmd->se_dev:"\r\n" %p\n", pt_cmd->se_dev);\r\npt_cmd->se_lun = ec_cmd->se_lun;\r\npr_debug("Honoring local DST port from ec_cmd->se_lun: %p\n",\r\npt_cmd->se_lun);\r\n}\r\n}\r\n}\r\nstatic void target_xcopy_init_pt_lun(struct se_device *se_dev,\r\nstruct se_cmd *pt_cmd, bool remote_port)\r\n{\r\nif (remote_port) {\r\npr_debug("Setup emulated se_dev: %p from se_dev\n",\r\npt_cmd->se_dev);\r\npt_cmd->se_lun = &se_dev->xcopy_lun;\r\npt_cmd->se_dev = se_dev;\r\n}\r\npt_cmd->se_cmd_flags |= SCF_SE_LUN_CMD;\r\n}\r\nstatic int target_xcopy_setup_pt_cmd(\r\nstruct xcopy_pt_cmd *xpt_cmd,\r\nstruct xcopy_op *xop,\r\nstruct se_device *se_dev,\r\nunsigned char *cdb,\r\nbool remote_port,\r\nbool alloc_mem)\r\n{\r\nstruct se_cmd *cmd = &xpt_cmd->se_cmd;\r\nsense_reason_t sense_rc;\r\nint ret = 0, rc;\r\ntarget_xcopy_init_pt_lun(se_dev, cmd, remote_port);\r\nxpt_cmd->xcopy_op = xop;\r\ntarget_xcopy_setup_pt_port(xpt_cmd, xop, remote_port);\r\ncmd->tag = 0;\r\nsense_rc = target_setup_cmd_from_cdb(cmd, cdb);\r\nif (sense_rc) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (alloc_mem) {\r\nrc = target_alloc_sgl(&cmd->t_data_sg, &cmd->t_data_nents,\r\ncmd->data_length, false, false);\r\nif (rc < 0) {\r\nret = rc;\r\ngoto out;\r\n}\r\ncmd->se_cmd_flags |= SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC;\r\n} else {\r\nsense_rc = transport_generic_map_mem_to_cmd(cmd,\r\nxop->xop_data_sg, xop->xop_data_nents,\r\nNULL, 0);\r\nif (sense_rc) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\npr_debug("Setup PASSTHROUGH_NOALLOC t_data_sg: %p t_data_nents:"\r\n" %u\n", cmd->t_data_sg, cmd->t_data_nents);\r\n}\r\nreturn 0;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int target_xcopy_issue_pt_cmd(struct xcopy_pt_cmd *xpt_cmd)\r\n{\r\nstruct se_cmd *se_cmd = &xpt_cmd->se_cmd;\r\nsense_reason_t sense_rc;\r\nsense_rc = transport_generic_new_cmd(se_cmd);\r\nif (sense_rc)\r\nreturn -EINVAL;\r\nif (se_cmd->data_direction == DMA_TO_DEVICE)\r\ntarget_execute_cmd(se_cmd);\r\nwait_for_completion_interruptible(&xpt_cmd->xpt_passthrough_sem);\r\npr_debug("target_xcopy_issue_pt_cmd(): SCSI status: 0x%02x\n",\r\nse_cmd->scsi_status);\r\nreturn (se_cmd->scsi_status) ? -EINVAL : 0;\r\n}\r\nstatic int target_xcopy_read_source(\r\nstruct se_cmd *ec_cmd,\r\nstruct xcopy_op *xop,\r\nstruct se_device *src_dev,\r\nsector_t src_lba,\r\nu32 src_sectors)\r\n{\r\nstruct xcopy_pt_cmd *xpt_cmd;\r\nstruct se_cmd *se_cmd;\r\nu32 length = (src_sectors * src_dev->dev_attrib.block_size);\r\nint rc;\r\nunsigned char cdb[16];\r\nbool remote_port = (xop->op_origin == XCOL_DEST_RECV_OP);\r\nxpt_cmd = kzalloc(sizeof(struct xcopy_pt_cmd), GFP_KERNEL);\r\nif (!xpt_cmd) {\r\npr_err("Unable to allocate xcopy_pt_cmd\n");\r\nreturn -ENOMEM;\r\n}\r\ninit_completion(&xpt_cmd->xpt_passthrough_sem);\r\nse_cmd = &xpt_cmd->se_cmd;\r\nmemset(&cdb[0], 0, 16);\r\ncdb[0] = READ_16;\r\nput_unaligned_be64(src_lba, &cdb[2]);\r\nput_unaligned_be32(src_sectors, &cdb[10]);\r\npr_debug("XCOPY: Built READ_16: LBA: %llu Sectors: %u Length: %u\n",\r\n(unsigned long long)src_lba, src_sectors, length);\r\ntransport_init_se_cmd(se_cmd, &xcopy_pt_tfo, &xcopy_pt_sess, length,\r\nDMA_FROM_DEVICE, 0, &xpt_cmd->sense_buffer[0]);\r\nxop->src_pt_cmd = xpt_cmd;\r\nrc = target_xcopy_setup_pt_cmd(xpt_cmd, xop, src_dev, &cdb[0],\r\nremote_port, true);\r\nif (rc < 0) {\r\nec_cmd->scsi_status = xpt_cmd->se_cmd.scsi_status;\r\ntransport_generic_free_cmd(se_cmd, 0);\r\nreturn rc;\r\n}\r\nxop->xop_data_sg = se_cmd->t_data_sg;\r\nxop->xop_data_nents = se_cmd->t_data_nents;\r\npr_debug("XCOPY-READ: Saved xop->xop_data_sg: %p, num: %u for READ"\r\n" memory\n", xop->xop_data_sg, xop->xop_data_nents);\r\nrc = target_xcopy_issue_pt_cmd(xpt_cmd);\r\nif (rc < 0) {\r\nec_cmd->scsi_status = xpt_cmd->se_cmd.scsi_status;\r\ntransport_generic_free_cmd(se_cmd, 0);\r\nreturn rc;\r\n}\r\nse_cmd->t_data_sg = NULL;\r\nse_cmd->t_data_nents = 0;\r\nreturn 0;\r\n}\r\nstatic int target_xcopy_write_destination(\r\nstruct se_cmd *ec_cmd,\r\nstruct xcopy_op *xop,\r\nstruct se_device *dst_dev,\r\nsector_t dst_lba,\r\nu32 dst_sectors)\r\n{\r\nstruct xcopy_pt_cmd *xpt_cmd;\r\nstruct se_cmd *se_cmd;\r\nu32 length = (dst_sectors * dst_dev->dev_attrib.block_size);\r\nint rc;\r\nunsigned char cdb[16];\r\nbool remote_port = (xop->op_origin == XCOL_SOURCE_RECV_OP);\r\nxpt_cmd = kzalloc(sizeof(struct xcopy_pt_cmd), GFP_KERNEL);\r\nif (!xpt_cmd) {\r\npr_err("Unable to allocate xcopy_pt_cmd\n");\r\nreturn -ENOMEM;\r\n}\r\ninit_completion(&xpt_cmd->xpt_passthrough_sem);\r\nse_cmd = &xpt_cmd->se_cmd;\r\nmemset(&cdb[0], 0, 16);\r\ncdb[0] = WRITE_16;\r\nput_unaligned_be64(dst_lba, &cdb[2]);\r\nput_unaligned_be32(dst_sectors, &cdb[10]);\r\npr_debug("XCOPY: Built WRITE_16: LBA: %llu Sectors: %u Length: %u\n",\r\n(unsigned long long)dst_lba, dst_sectors, length);\r\ntransport_init_se_cmd(se_cmd, &xcopy_pt_tfo, &xcopy_pt_sess, length,\r\nDMA_TO_DEVICE, 0, &xpt_cmd->sense_buffer[0]);\r\nxop->dst_pt_cmd = xpt_cmd;\r\nrc = target_xcopy_setup_pt_cmd(xpt_cmd, xop, dst_dev, &cdb[0],\r\nremote_port, false);\r\nif (rc < 0) {\r\nstruct se_cmd *src_cmd = &xop->src_pt_cmd->se_cmd;\r\nec_cmd->scsi_status = xpt_cmd->se_cmd.scsi_status;\r\nsrc_cmd->se_cmd_flags &= ~SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC;\r\nsrc_cmd->t_data_sg = xop->xop_data_sg;\r\nsrc_cmd->t_data_nents = xop->xop_data_nents;\r\ntransport_generic_free_cmd(se_cmd, 0);\r\nreturn rc;\r\n}\r\nrc = target_xcopy_issue_pt_cmd(xpt_cmd);\r\nif (rc < 0) {\r\nec_cmd->scsi_status = xpt_cmd->se_cmd.scsi_status;\r\nse_cmd->se_cmd_flags &= ~SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC;\r\ntransport_generic_free_cmd(se_cmd, 0);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic void target_xcopy_do_work(struct work_struct *work)\r\n{\r\nstruct xcopy_op *xop = container_of(work, struct xcopy_op, xop_work);\r\nstruct se_cmd *ec_cmd = xop->xop_se_cmd;\r\nstruct se_device *src_dev, *dst_dev;\r\nsector_t src_lba, dst_lba, end_lba;\r\nunsigned int max_sectors;\r\nint rc = 0;\r\nunsigned short nolb, cur_nolb, max_nolb, copied_nolb = 0;\r\nif (target_parse_xcopy_cmd(xop) != TCM_NO_SENSE)\r\ngoto err_free;\r\nif (WARN_ON_ONCE(!xop->src_dev) || WARN_ON_ONCE(!xop->dst_dev))\r\ngoto err_free;\r\nsrc_dev = xop->src_dev;\r\ndst_dev = xop->dst_dev;\r\nsrc_lba = xop->src_lba;\r\ndst_lba = xop->dst_lba;\r\nnolb = xop->nolb;\r\nend_lba = src_lba + nolb;\r\nmax_sectors = min(src_dev->dev_attrib.hw_max_sectors,\r\ndst_dev->dev_attrib.hw_max_sectors);\r\nmax_sectors = min_t(u32, max_sectors, XCOPY_MAX_SECTORS);\r\nmax_nolb = min_t(u16, max_sectors, ((u16)(~0U)));\r\npr_debug("target_xcopy_do_work: nolb: %hu, max_nolb: %hu end_lba: %llu\n",\r\nnolb, max_nolb, (unsigned long long)end_lba);\r\npr_debug("target_xcopy_do_work: Starting src_lba: %llu, dst_lba: %llu\n",\r\n(unsigned long long)src_lba, (unsigned long long)dst_lba);\r\nwhile (src_lba < end_lba) {\r\ncur_nolb = min(nolb, max_nolb);\r\npr_debug("target_xcopy_do_work: Calling read src_dev: %p src_lba: %llu,"\r\n" cur_nolb: %hu\n", src_dev, (unsigned long long)src_lba, cur_nolb);\r\nrc = target_xcopy_read_source(ec_cmd, xop, src_dev, src_lba, cur_nolb);\r\nif (rc < 0)\r\ngoto out;\r\nsrc_lba += cur_nolb;\r\npr_debug("target_xcopy_do_work: Incremented READ src_lba to %llu\n",\r\n(unsigned long long)src_lba);\r\npr_debug("target_xcopy_do_work: Calling write dst_dev: %p dst_lba: %llu,"\r\n" cur_nolb: %hu\n", dst_dev, (unsigned long long)dst_lba, cur_nolb);\r\nrc = target_xcopy_write_destination(ec_cmd, xop, dst_dev,\r\ndst_lba, cur_nolb);\r\nif (rc < 0) {\r\ntransport_generic_free_cmd(&xop->src_pt_cmd->se_cmd, 0);\r\ngoto out;\r\n}\r\ndst_lba += cur_nolb;\r\npr_debug("target_xcopy_do_work: Incremented WRITE dst_lba to %llu\n",\r\n(unsigned long long)dst_lba);\r\ncopied_nolb += cur_nolb;\r\nnolb -= cur_nolb;\r\ntransport_generic_free_cmd(&xop->src_pt_cmd->se_cmd, 0);\r\nxop->dst_pt_cmd->se_cmd.se_cmd_flags &= ~SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC;\r\ntransport_generic_free_cmd(&xop->dst_pt_cmd->se_cmd, 0);\r\n}\r\nxcopy_pt_undepend_remotedev(xop);\r\nkfree(xop);\r\npr_debug("target_xcopy_do_work: Final src_lba: %llu, dst_lba: %llu\n",\r\n(unsigned long long)src_lba, (unsigned long long)dst_lba);\r\npr_debug("target_xcopy_do_work: Blocks copied: %hu, Bytes Copied: %u\n",\r\ncopied_nolb, copied_nolb * dst_dev->dev_attrib.block_size);\r\npr_debug("target_xcopy_do_work: Setting X-COPY GOOD status -> sending response\n");\r\ntarget_complete_cmd(ec_cmd, SAM_STAT_GOOD);\r\nreturn;\r\nout:\r\nxcopy_pt_undepend_remotedev(xop);\r\nerr_free:\r\nkfree(xop);\r\nif (ec_cmd->scsi_status == SAM_STAT_GOOD) {\r\npr_warn_ratelimited("target_xcopy_do_work: rc: %d, Setting X-COPY"\r\n" CHECK_CONDITION -> sending response\n", rc);\r\nec_cmd->scsi_status = SAM_STAT_CHECK_CONDITION;\r\n}\r\ntarget_complete_cmd(ec_cmd, ec_cmd->scsi_status);\r\n}\r\nstatic sense_reason_t target_parse_xcopy_cmd(struct xcopy_op *xop)\r\n{\r\nstruct se_cmd *se_cmd = xop->xop_se_cmd;\r\nunsigned char *p = NULL, *seg_desc;\r\nunsigned int list_id, list_id_usage, sdll, inline_dl;\r\nsense_reason_t ret = TCM_INVALID_PARAMETER_LIST;\r\nint rc;\r\nunsigned short tdll;\r\np = transport_kmap_data_sg(se_cmd);\r\nif (!p) {\r\npr_err("transport_kmap_data_sg() failed in target_do_xcopy\n");\r\nreturn TCM_OUT_OF_RESOURCES;\r\n}\r\nlist_id = p[0];\r\nlist_id_usage = (p[1] & 0x18) >> 3;\r\ntdll = get_unaligned_be16(&p[2]);\r\nsdll = get_unaligned_be32(&p[8]);\r\nif (tdll + sdll > RCR_OP_MAX_DESC_LIST_LEN) {\r\npr_err("XCOPY descriptor list length %u exceeds maximum %u\n",\r\ntdll + sdll, RCR_OP_MAX_DESC_LIST_LEN);\r\nret = TCM_PARAMETER_LIST_LENGTH_ERROR;\r\ngoto out;\r\n}\r\ninline_dl = get_unaligned_be32(&p[12]);\r\nif (inline_dl != 0) {\r\npr_err("XCOPY with non zero inline data length\n");\r\ngoto out;\r\n}\r\nif (se_cmd->data_length < (XCOPY_HDR_LEN + tdll + sdll + inline_dl)) {\r\npr_err("XCOPY parameter truncation: data length %u too small "\r\n"for tdll: %hu sdll: %u inline_dl: %u\n",\r\nse_cmd->data_length, tdll, sdll, inline_dl);\r\nret = TCM_PARAMETER_LIST_LENGTH_ERROR;\r\ngoto out;\r\n}\r\npr_debug("Processing XCOPY with list_id: 0x%02x list_id_usage: 0x%02x"\r\n" tdll: %hu sdll: %u inline_dl: %u\n", list_id, list_id_usage,\r\ntdll, sdll, inline_dl);\r\nseg_desc = &p[16] + tdll;\r\nrc = target_xcopy_parse_segment_descriptors(se_cmd, xop, seg_desc,\r\nsdll, &ret);\r\nif (rc <= 0)\r\ngoto out;\r\npr_debug("XCOPY: Processed %d segment descriptors, length: %u\n", rc,\r\nrc * XCOPY_SEGMENT_DESC_LEN);\r\nrc = target_xcopy_parse_target_descriptors(se_cmd, xop, &p[16], tdll, &ret);\r\nif (rc <= 0)\r\ngoto out;\r\nif (xop->src_dev->dev_attrib.block_size !=\r\nxop->dst_dev->dev_attrib.block_size) {\r\npr_err("XCOPY: Non matching src_dev block_size: %u + dst_dev"\r\n" block_size: %u currently unsupported\n",\r\nxop->src_dev->dev_attrib.block_size,\r\nxop->dst_dev->dev_attrib.block_size);\r\nxcopy_pt_undepend_remotedev(xop);\r\nret = TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\ngoto out;\r\n}\r\npr_debug("XCOPY: Processed %d target descriptors, length: %u\n", rc,\r\nrc * XCOPY_TARGET_DESC_LEN);\r\ntransport_kunmap_data_sg(se_cmd);\r\nreturn TCM_NO_SENSE;\r\nout:\r\nif (p)\r\ntransport_kunmap_data_sg(se_cmd);\r\nreturn ret;\r\n}\r\nsense_reason_t target_do_xcopy(struct se_cmd *se_cmd)\r\n{\r\nstruct se_device *dev = se_cmd->se_dev;\r\nstruct xcopy_op *xop;\r\nunsigned int sa;\r\nif (!dev->dev_attrib.emulate_3pc) {\r\npr_err("EXTENDED_COPY operation explicitly disabled\n");\r\nreturn TCM_UNSUPPORTED_SCSI_OPCODE;\r\n}\r\nsa = se_cmd->t_task_cdb[1] & 0x1f;\r\nif (sa != 0x00) {\r\npr_err("EXTENDED_COPY(LID4) not supported\n");\r\nreturn TCM_UNSUPPORTED_SCSI_OPCODE;\r\n}\r\nif (se_cmd->data_length == 0) {\r\ntarget_complete_cmd(se_cmd, SAM_STAT_GOOD);\r\nreturn TCM_NO_SENSE;\r\n}\r\nif (se_cmd->data_length < XCOPY_HDR_LEN) {\r\npr_err("XCOPY parameter truncation: length %u < hdr_len %u\n",\r\nse_cmd->data_length, XCOPY_HDR_LEN);\r\nreturn TCM_PARAMETER_LIST_LENGTH_ERROR;\r\n}\r\nxop = kzalloc(sizeof(struct xcopy_op), GFP_KERNEL);\r\nif (!xop)\r\ngoto err;\r\nxop->xop_se_cmd = se_cmd;\r\nINIT_WORK(&xop->xop_work, target_xcopy_do_work);\r\nif (WARN_ON_ONCE(!queue_work(xcopy_wq, &xop->xop_work)))\r\ngoto free;\r\nreturn TCM_NO_SENSE;\r\nfree:\r\nkfree(xop);\r\nerr:\r\nreturn TCM_OUT_OF_RESOURCES;\r\n}\r\nstatic sense_reason_t target_rcr_operating_parameters(struct se_cmd *se_cmd)\r\n{\r\nunsigned char *p;\r\np = transport_kmap_data_sg(se_cmd);\r\nif (!p) {\r\npr_err("transport_kmap_data_sg failed in"\r\n" target_rcr_operating_parameters\n");\r\nreturn TCM_OUT_OF_RESOURCES;\r\n}\r\nif (se_cmd->data_length < 54) {\r\npr_err("Receive Copy Results Op Parameters length"\r\n" too small: %u\n", se_cmd->data_length);\r\ntransport_kunmap_data_sg(se_cmd);\r\nreturn TCM_INVALID_CDB_FIELD;\r\n}\r\np[4] = 0x1;\r\nput_unaligned_be16(RCR_OP_MAX_TARGET_DESC_COUNT, &p[8]);\r\nput_unaligned_be16(RCR_OP_MAX_SG_DESC_COUNT, &p[10]);\r\nput_unaligned_be32(RCR_OP_MAX_DESC_LIST_LEN, &p[12]);\r\nput_unaligned_be32(RCR_OP_MAX_SEGMENT_LEN, &p[16]);\r\nput_unaligned_be32(0x0, &p[20]);\r\nput_unaligned_be32(0x0, &p[24]);\r\nput_unaligned_be32(0x0, &p[28]);\r\nput_unaligned_be16(RCR_OP_TOTAL_CONCURR_COPIES, &p[34]);\r\np[36] = RCR_OP_MAX_CONCURR_COPIES;\r\np[37] = RCR_OP_DATA_SEG_GRAN_LOG2;\r\np[38] = RCR_OP_INLINE_DATA_GRAN_LOG2;\r\np[39] = RCR_OP_HELD_DATA_GRAN_LOG2;\r\np[43] = 0x2;\r\np[44] = 0x02;\r\np[45] = 0xe4;\r\nput_unaligned_be32(42, &p[0]);\r\ntransport_kunmap_data_sg(se_cmd);\r\ntarget_complete_cmd(se_cmd, GOOD);\r\nreturn TCM_NO_SENSE;\r\n}\r\nsense_reason_t target_do_receive_copy_results(struct se_cmd *se_cmd)\r\n{\r\nunsigned char *cdb = &se_cmd->t_task_cdb[0];\r\nint sa = (cdb[1] & 0x1f), list_id = cdb[2];\r\nsense_reason_t rc = TCM_NO_SENSE;\r\npr_debug("Entering target_do_receive_copy_results: SA: 0x%02x, List ID:"\r\n" 0x%02x, AL: %u\n", sa, list_id, se_cmd->data_length);\r\nif (list_id != 0) {\r\npr_err("Receive Copy Results with non zero list identifier"\r\n" not supported\n");\r\nreturn TCM_INVALID_CDB_FIELD;\r\n}\r\nswitch (sa) {\r\ncase RCR_SA_OPERATING_PARAMETERS:\r\nrc = target_rcr_operating_parameters(se_cmd);\r\nbreak;\r\ncase RCR_SA_COPY_STATUS:\r\ncase RCR_SA_RECEIVE_DATA:\r\ncase RCR_SA_FAILED_SEGMENT_DETAILS:\r\ndefault:\r\npr_err("Unsupported SA for receive copy results: 0x%02x\n", sa);\r\nreturn TCM_INVALID_CDB_FIELD;\r\n}\r\nreturn rc;\r\n}
