void __init tboot_probe(void)\r\n{\r\nif (!boot_params.tboot_addr)\r\nreturn;\r\nif (!e820__mapped_any(boot_params.tboot_addr,\r\nboot_params.tboot_addr, E820_TYPE_RESERVED)) {\r\npr_warning("non-0 tboot_addr but it is not of type E820_TYPE_RESERVED\n");\r\nreturn;\r\n}\r\nset_fixmap(FIX_TBOOT_BASE, boot_params.tboot_addr);\r\ntboot = (struct tboot *)fix_to_virt(FIX_TBOOT_BASE);\r\nif (memcmp(&tboot_uuid, &tboot->uuid, sizeof(tboot->uuid))) {\r\npr_warning("tboot at 0x%llx is invalid\n",\r\nboot_params.tboot_addr);\r\ntboot = NULL;\r\nreturn;\r\n}\r\nif (tboot->version < 5) {\r\npr_warning("tboot version is invalid: %u\n", tboot->version);\r\ntboot = NULL;\r\nreturn;\r\n}\r\npr_info("found shared page at phys addr 0x%llx:\n",\r\nboot_params.tboot_addr);\r\npr_debug("version: %d\n", tboot->version);\r\npr_debug("log_addr: 0x%08x\n", tboot->log_addr);\r\npr_debug("shutdown_entry: 0x%x\n", tboot->shutdown_entry);\r\npr_debug("tboot_base: 0x%08x\n", tboot->tboot_base);\r\npr_debug("tboot_size: 0x%x\n", tboot->tboot_size);\r\n}\r\nstatic inline void switch_to_tboot_pt(void)\r\n{\r\nwrite_cr3(virt_to_phys(tboot_pg_dir));\r\n}\r\nstatic int map_tboot_page(unsigned long vaddr, unsigned long pfn,\r\npgprot_t prot)\r\n{\r\npgd_t *pgd;\r\np4d_t *p4d;\r\npud_t *pud;\r\npmd_t *pmd;\r\npte_t *pte;\r\npgd = pgd_offset(&tboot_mm, vaddr);\r\np4d = p4d_alloc(&tboot_mm, pgd, vaddr);\r\nif (!p4d)\r\nreturn -1;\r\npud = pud_alloc(&tboot_mm, p4d, vaddr);\r\nif (!pud)\r\nreturn -1;\r\npmd = pmd_alloc(&tboot_mm, pud, vaddr);\r\nif (!pmd)\r\nreturn -1;\r\npte = pte_alloc_map(&tboot_mm, pmd, vaddr);\r\nif (!pte)\r\nreturn -1;\r\nset_pte_at(&tboot_mm, vaddr, pte, pfn_pte(pfn, prot));\r\npte_unmap(pte);\r\nreturn 0;\r\n}\r\nstatic int map_tboot_pages(unsigned long vaddr, unsigned long start_pfn,\r\nunsigned long nr)\r\n{\r\ntboot_pg_dir = pgd_alloc(&tboot_mm);\r\nif (!tboot_pg_dir)\r\nreturn -1;\r\nfor (; nr > 0; nr--, vaddr += PAGE_SIZE, start_pfn++) {\r\nif (map_tboot_page(vaddr, start_pfn, PAGE_KERNEL_EXEC))\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void tboot_create_trampoline(void)\r\n{\r\nu32 map_base, map_size;\r\nmap_base = PFN_DOWN(tboot->tboot_base);\r\nmap_size = PFN_UP(tboot->tboot_size);\r\nif (map_tboot_pages(map_base << PAGE_SHIFT, map_base, map_size))\r\npanic("tboot: Error mapping tboot pages (mfns) @ 0x%x, 0x%x\n",\r\nmap_base, map_size);\r\n}\r\nstatic void add_mac_region(phys_addr_t start, unsigned long size)\r\n{\r\nstruct tboot_mac_region *mr;\r\nphys_addr_t end = start + size;\r\nif (tboot->num_mac_regions >= MAX_TB_MAC_REGIONS)\r\npanic("tboot: Too many MAC regions\n");\r\nif (start && size) {\r\nmr = &tboot->mac_regions[tboot->num_mac_regions++];\r\nmr->start = round_down(start, PAGE_SIZE);\r\nmr->size = round_up(end, PAGE_SIZE) - mr->start;\r\n}\r\n}\r\nstatic int tboot_setup_sleep(void)\r\n{\r\nint i;\r\ntboot->num_mac_regions = 0;\r\nfor (i = 0; i < e820_table->nr_entries; i++) {\r\nif ((e820_table->entries[i].type != E820_TYPE_RAM)\r\n&& (e820_table->entries[i].type != E820_TYPE_RESERVED_KERN))\r\ncontinue;\r\nadd_mac_region(e820_table->entries[i].addr, e820_table->entries[i].size);\r\n}\r\ntboot->acpi_sinfo.kernel_s3_resume_vector =\r\nreal_mode_header->wakeup_start;\r\nreturn 0;\r\n}\r\nstatic int tboot_setup_sleep(void)\r\n{\r\nBUG();\r\nreturn -1;\r\n}\r\nvoid tboot_shutdown(u32 shutdown_type)\r\n{\r\nvoid (*shutdown)(void);\r\nif (!tboot_enabled())\r\nreturn;\r\nif (!tboot_pg_dir)\r\nreturn;\r\nif (shutdown_type == TB_SHUTDOWN_S3)\r\nif (tboot_setup_sleep())\r\nreturn;\r\ntboot->shutdown_type = shutdown_type;\r\nswitch_to_tboot_pt();\r\nshutdown = (void(*)(void))(unsigned long)tboot->shutdown_entry;\r\nshutdown();\r\nwhile (1)\r\nhalt();\r\n}\r\nstatic void tboot_copy_fadt(const struct acpi_table_fadt *fadt)\r\n{\r\n#define TB_COPY_GAS(tbg, g) \\r\ntbg.space_id = g.space_id; \\r\ntbg.bit_width = g.bit_width; \\r\ntbg.bit_offset = g.bit_offset; \\r\ntbg.access_width = g.access_width; \\r\ntbg.address = g.address;\r\nTB_COPY_GAS(tboot->acpi_sinfo.pm1a_cnt_blk, fadt->xpm1a_control_block);\r\nTB_COPY_GAS(tboot->acpi_sinfo.pm1b_cnt_blk, fadt->xpm1b_control_block);\r\nTB_COPY_GAS(tboot->acpi_sinfo.pm1a_evt_blk, fadt->xpm1a_event_block);\r\nTB_COPY_GAS(tboot->acpi_sinfo.pm1b_evt_blk, fadt->xpm1b_event_block);\r\ntboot->acpi_sinfo.wakeup_vector = fadt->facs +\r\noffsetof(struct acpi_table_facs, firmware_waking_vector);\r\n}\r\nstatic int tboot_sleep(u8 sleep_state, u32 pm1a_control, u32 pm1b_control)\r\n{\r\nstatic u32 acpi_shutdown_map[ACPI_S_STATE_COUNT] = {\r\n-1, -1, -1,\r\nTB_SHUTDOWN_S3,\r\nTB_SHUTDOWN_S4,\r\nTB_SHUTDOWN_S5 };\r\nif (!tboot_enabled())\r\nreturn 0;\r\ntboot_copy_fadt(&acpi_gbl_FADT);\r\ntboot->acpi_sinfo.pm1a_cnt_val = pm1a_control;\r\ntboot->acpi_sinfo.pm1b_cnt_val = pm1b_control;\r\ntboot->acpi_sinfo.vector_width = 32;\r\nif (sleep_state >= ACPI_S_STATE_COUNT ||\r\nacpi_shutdown_map[sleep_state] == -1) {\r\npr_warning("unsupported sleep state 0x%x\n", sleep_state);\r\nreturn -1;\r\n}\r\ntboot_shutdown(acpi_shutdown_map[sleep_state]);\r\nreturn 0;\r\n}\r\nstatic int tboot_extended_sleep(u8 sleep_state, u32 val_a, u32 val_b)\r\n{\r\nif (!tboot_enabled())\r\nreturn 0;\r\npr_warning("tboot is not able to suspend on platforms with reduced hardware sleep (ACPIv5)");\r\nreturn -ENODEV;\r\n}\r\nstatic int tboot_wait_for_aps(int num_aps)\r\n{\r\nunsigned long timeout;\r\ntimeout = AP_WAIT_TIMEOUT*HZ;\r\nwhile (atomic_read((atomic_t *)&tboot->num_in_wfs) != num_aps &&\r\ntimeout) {\r\nmdelay(1);\r\ntimeout--;\r\n}\r\nif (timeout)\r\npr_warning("tboot wait for APs timeout\n");\r\nreturn !(atomic_read((atomic_t *)&tboot->num_in_wfs) == num_aps);\r\n}\r\nstatic int tboot_dying_cpu(unsigned int cpu)\r\n{\r\natomic_inc(&ap_wfs_count);\r\nif (num_online_cpus() == 1) {\r\nif (tboot_wait_for_aps(atomic_read(&ap_wfs_count)))\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t tboot_log_read(struct file *file, char __user *user_buf, size_t count, loff_t *ppos)\r\n{\r\nvoid __iomem *log_base;\r\nu8 log_uuid[16];\r\nu32 max_size;\r\nvoid *kbuf;\r\nint ret = -EFAULT;\r\nlog_base = ioremap_nocache(TBOOT_SERIAL_LOG_ADDR, TBOOT_SERIAL_LOG_SIZE);\r\nif (!log_base)\r\nreturn ret;\r\nmemcpy_fromio(log_uuid, log_base, sizeof(log_uuid));\r\nif (memcmp(&tboot_log_uuid, log_uuid, sizeof(log_uuid)))\r\ngoto err_iounmap;\r\nmax_size = readl(log_base + LOG_MAX_SIZE_OFF);\r\nif (*ppos >= max_size) {\r\nret = 0;\r\ngoto err_iounmap;\r\n}\r\nif (*ppos + count > max_size)\r\ncount = max_size - *ppos;\r\nkbuf = kmalloc(count, GFP_KERNEL);\r\nif (!kbuf) {\r\nret = -ENOMEM;\r\ngoto err_iounmap;\r\n}\r\nmemcpy_fromio(kbuf, log_base + LOG_BUF_OFF + *ppos, count);\r\nif (copy_to_user(user_buf, kbuf, count))\r\ngoto err_kfree;\r\n*ppos += count;\r\nret = count;\r\nerr_kfree:\r\nkfree(kbuf);\r\nerr_iounmap:\r\niounmap(log_base);\r\nreturn ret;\r\n}\r\nstatic __init int tboot_late_init(void)\r\n{\r\nif (!tboot_enabled())\r\nreturn 0;\r\ntboot_create_trampoline();\r\natomic_set(&ap_wfs_count, 0);\r\ncpuhp_setup_state(CPUHP_AP_X86_TBOOT_DYING, "x86/tboot:dying", NULL,\r\ntboot_dying_cpu);\r\n#ifdef CONFIG_DEBUG_FS\r\ndebugfs_create_file("tboot_log", S_IRUSR,\r\narch_debugfs_dir, NULL, &tboot_log_fops);\r\n#endif\r\nacpi_os_set_prepare_sleep(&tboot_sleep);\r\nacpi_os_set_prepare_extended_sleep(&tboot_extended_sleep);\r\nreturn 0;\r\n}\r\nstruct acpi_table_header *tboot_get_dmar_table(struct acpi_table_header *dmar_tbl)\r\n{\r\nvoid *heap_base, *heap_ptr, *config;\r\nif (!tboot_enabled())\r\nreturn dmar_tbl;\r\nconfig = ioremap(TXT_PUB_CONFIG_REGS_BASE, NR_TXT_CONFIG_PAGES *\r\nPAGE_SIZE);\r\nif (!config)\r\nreturn NULL;\r\nheap_base = ioremap(*(u64 *)(config + TXTCR_HEAP_BASE),\r\n*(u64 *)(config + TXTCR_HEAP_SIZE));\r\niounmap(config);\r\nif (!heap_base)\r\nreturn NULL;\r\nheap_ptr = heap_base + *(u64 *)heap_base;\r\nheap_ptr += *(u64 *)heap_ptr;\r\nheap_ptr += *(u64 *)heap_ptr;\r\nheap_ptr += sizeof(u64);\r\ndmar_tbl = (struct acpi_table_header *)(heap_ptr +\r\n((struct sinit_mle_data *)heap_ptr)->vtd_dmars_off -\r\nsizeof(u64));\r\nreturn dmar_tbl;\r\n}\r\nint tboot_force_iommu(void)\r\n{\r\nif (!tboot_enabled())\r\nreturn 0;\r\nif (intel_iommu_tboot_noforce)\r\nreturn 1;\r\nif (no_iommu || swiotlb || dmar_disabled)\r\npr_warning("Forcing Intel-IOMMU to enabled\n");\r\ndmar_disabled = 0;\r\n#ifdef CONFIG_SWIOTLB\r\nswiotlb = 0;\r\n#endif\r\nno_iommu = 0;\r\nreturn 1;\r\n}
