static inline struct ppp* get_ppp(struct net_device *dev)\r\n{\r\nreturn (struct ppp *)dev_to_hdlc(dev)->state;\r\n}\r\nstatic inline struct proto* get_proto(struct net_device *dev, u16 pid)\r\n{\r\nstruct ppp *ppp = get_ppp(dev);\r\nswitch (pid) {\r\ncase PID_LCP:\r\nreturn &ppp->protos[IDX_LCP];\r\ncase PID_IPCP:\r\nreturn &ppp->protos[IDX_IPCP];\r\ncase PID_IPV6CP:\r\nreturn &ppp->protos[IDX_IPV6CP];\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nstatic inline const char* proto_name(u16 pid)\r\n{\r\nswitch (pid) {\r\ncase PID_LCP:\r\nreturn "LCP";\r\ncase PID_IPCP:\r\nreturn "IPCP";\r\ncase PID_IPV6CP:\r\nreturn "IPV6CP";\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nstatic __be16 ppp_type_trans(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct hdlc_header *data = (struct hdlc_header*)skb->data;\r\nif (skb->len < sizeof(struct hdlc_header))\r\nreturn htons(ETH_P_HDLC);\r\nif (data->address != HDLC_ADDR_ALLSTATIONS ||\r\ndata->control != HDLC_CTRL_UI)\r\nreturn htons(ETH_P_HDLC);\r\nswitch (data->protocol) {\r\ncase cpu_to_be16(PID_IP):\r\nskb_pull(skb, sizeof(struct hdlc_header));\r\nreturn htons(ETH_P_IP);\r\ncase cpu_to_be16(PID_IPV6):\r\nskb_pull(skb, sizeof(struct hdlc_header));\r\nreturn htons(ETH_P_IPV6);\r\ndefault:\r\nreturn htons(ETH_P_HDLC);\r\n}\r\n}\r\nstatic int ppp_hard_header(struct sk_buff *skb, struct net_device *dev,\r\nu16 type, const void *daddr, const void *saddr,\r\nunsigned int len)\r\n{\r\nstruct hdlc_header *data;\r\n#if DEBUG_HARD_HEADER\r\nprintk(KERN_DEBUG "%s: ppp_hard_header() called\n", dev->name);\r\n#endif\r\nskb_push(skb, sizeof(struct hdlc_header));\r\ndata = (struct hdlc_header*)skb->data;\r\ndata->address = HDLC_ADDR_ALLSTATIONS;\r\ndata->control = HDLC_CTRL_UI;\r\nswitch (type) {\r\ncase ETH_P_IP:\r\ndata->protocol = htons(PID_IP);\r\nbreak;\r\ncase ETH_P_IPV6:\r\ndata->protocol = htons(PID_IPV6);\r\nbreak;\r\ncase PID_LCP:\r\ncase PID_IPCP:\r\ncase PID_IPV6CP:\r\ndata->protocol = htons(type);\r\nbreak;\r\ndefault:\r\ndata->protocol = 0;\r\n}\r\nreturn sizeof(struct hdlc_header);\r\n}\r\nstatic void ppp_tx_flush(void)\r\n{\r\nstruct sk_buff *skb;\r\nwhile ((skb = skb_dequeue(&tx_queue)) != NULL)\r\ndev_queue_xmit(skb);\r\n}\r\nstatic void ppp_tx_cp(struct net_device *dev, u16 pid, u8 code,\r\nu8 id, unsigned int len, const void *data)\r\n{\r\nstruct sk_buff *skb;\r\nstruct cp_header *cp;\r\nunsigned int magic_len = 0;\r\nstatic u32 magic;\r\n#if DEBUG_CP\r\nint i;\r\nchar *ptr;\r\n#endif\r\nif (pid == PID_LCP && (code == LCP_ECHO_REQ || code == LCP_ECHO_REPLY))\r\nmagic_len = sizeof(magic);\r\nskb = dev_alloc_skb(sizeof(struct hdlc_header) +\r\nsizeof(struct cp_header) + magic_len + len);\r\nif (!skb) {\r\nnetdev_warn(dev, "out of memory in ppp_tx_cp()\n");\r\nreturn;\r\n}\r\nskb_reserve(skb, sizeof(struct hdlc_header));\r\ncp = skb_put(skb, sizeof(struct cp_header));\r\ncp->code = code;\r\ncp->id = id;\r\ncp->len = htons(sizeof(struct cp_header) + magic_len + len);\r\nif (magic_len)\r\nskb_put_data(skb, &magic, magic_len);\r\nif (len)\r\nskb_put_data(skb, data, len);\r\n#if DEBUG_CP\r\nBUG_ON(code >= CP_CODES);\r\nptr = debug_buffer;\r\n*ptr = '\x0';\r\nfor (i = 0; i < min_t(unsigned int, magic_len + len, DEBUG_CP); i++) {\r\nsprintf(ptr, " %02X", skb->data[sizeof(struct cp_header) + i]);\r\nptr += strlen(ptr);\r\n}\r\nprintk(KERN_DEBUG "%s: TX %s [%s id 0x%X]%s\n", dev->name,\r\nproto_name(pid), code_names[code], id, debug_buffer);\r\n#endif\r\nppp_hard_header(skb, dev, pid, NULL, NULL, 0);\r\nskb->priority = TC_PRIO_CONTROL;\r\nskb->dev = dev;\r\nskb_reset_network_header(skb);\r\nskb_queue_tail(&tx_queue, skb);\r\n}\r\nstatic void ppp_cp_event(struct net_device *dev, u16 pid, u16 event, u8 code,\r\nu8 id, unsigned int len, const void *data)\r\n{\r\nint old_state, action;\r\nstruct ppp *ppp = get_ppp(dev);\r\nstruct proto *proto = get_proto(dev, pid);\r\nold_state = proto->state;\r\nBUG_ON(old_state >= STATES);\r\nBUG_ON(event >= EVENTS);\r\n#if DEBUG_STATE\r\nprintk(KERN_DEBUG "%s: %s ppp_cp_event(%s) %s ...\n", dev->name,\r\nproto_name(pid), event_names[event], state_names[proto->state]);\r\n#endif\r\naction = cp_table[event][old_state];\r\nproto->state = action & STATE_MASK;\r\nif (action & (SCR | STR))\r\nmod_timer(&proto->timer, proto->timeout =\r\njiffies + ppp->req_timeout * HZ);\r\nif (action & ZRC)\r\nproto->restart_counter = 0;\r\nif (action & IRC)\r\nproto->restart_counter = (proto->state == STOPPING) ?\r\nppp->term_retries : ppp->cr_retries;\r\nif (action & SCR)\r\nppp_tx_cp(dev, pid, CP_CONF_REQ, proto->cr_id = ++ppp->seq,\r\n0, NULL);\r\nif (action & SCA)\r\nppp_tx_cp(dev, pid, CP_CONF_ACK, id, len, data);\r\nif (action & SCN)\r\nppp_tx_cp(dev, pid, code, id, len, data);\r\nif (action & STR)\r\nppp_tx_cp(dev, pid, CP_TERM_REQ, ++ppp->seq, 0, NULL);\r\nif (action & STA)\r\nppp_tx_cp(dev, pid, CP_TERM_ACK, id, 0, NULL);\r\nif (action & SCJ)\r\nppp_tx_cp(dev, pid, CP_CODE_REJ, ++ppp->seq, len, data);\r\nif (old_state != OPENED && proto->state == OPENED) {\r\nnetdev_info(dev, "%s up\n", proto_name(pid));\r\nif (pid == PID_LCP) {\r\nnetif_dormant_off(dev);\r\nppp_cp_event(dev, PID_IPCP, START, 0, 0, 0, NULL);\r\nppp_cp_event(dev, PID_IPV6CP, START, 0, 0, 0, NULL);\r\nppp->last_pong = jiffies;\r\nmod_timer(&proto->timer, proto->timeout =\r\njiffies + ppp->keepalive_interval * HZ);\r\n}\r\n}\r\nif (old_state == OPENED && proto->state != OPENED) {\r\nnetdev_info(dev, "%s down\n", proto_name(pid));\r\nif (pid == PID_LCP) {\r\nnetif_dormant_on(dev);\r\nppp_cp_event(dev, PID_IPCP, STOP, 0, 0, 0, NULL);\r\nppp_cp_event(dev, PID_IPV6CP, STOP, 0, 0, 0, NULL);\r\n}\r\n}\r\nif (old_state != CLOSED && proto->state == CLOSED)\r\ndel_timer(&proto->timer);\r\n#if DEBUG_STATE\r\nprintk(KERN_DEBUG "%s: %s ppp_cp_event(%s) ... %s\n", dev->name,\r\nproto_name(pid), event_names[event], state_names[proto->state]);\r\n#endif\r\n}\r\nstatic void ppp_cp_parse_cr(struct net_device *dev, u16 pid, u8 id,\r\nunsigned int req_len, const u8 *data)\r\n{\r\nstatic u8 const valid_accm[6] = { LCP_OPTION_ACCM, 6, 0, 0, 0, 0 };\r\nconst u8 *opt;\r\nu8 *out;\r\nunsigned int len = req_len, nak_len = 0, rej_len = 0;\r\nif (!(out = kmalloc(len, GFP_ATOMIC))) {\r\ndev->stats.rx_dropped++;\r\nreturn;\r\n}\r\nfor (opt = data; len; len -= opt[1], opt += opt[1]) {\r\nif (len < 2 || len < opt[1]) {\r\ndev->stats.rx_errors++;\r\nkfree(out);\r\nreturn;\r\n}\r\nif (pid == PID_LCP)\r\nswitch (opt[0]) {\r\ncase LCP_OPTION_MRU:\r\ncontinue;\r\ncase LCP_OPTION_ACCM:\r\nif (!memcmp(opt, valid_accm,\r\nsizeof(valid_accm)))\r\ncontinue;\r\nif (!rej_len) {\r\nmemcpy(out + nak_len, valid_accm,\r\nsizeof(valid_accm));\r\nnak_len += sizeof(valid_accm);\r\ncontinue;\r\n}\r\nbreak;\r\ncase LCP_OPTION_MAGIC:\r\nif (opt[1] != 6 || (!opt[2] && !opt[3] &&\r\n!opt[4] && !opt[5]))\r\nbreak;\r\ncontinue;\r\n}\r\nmemcpy(out + rej_len, opt, opt[1]);\r\nrej_len += opt[1];\r\n}\r\nif (rej_len)\r\nppp_cp_event(dev, pid, RCR_BAD, CP_CONF_REJ, id, rej_len, out);\r\nelse if (nak_len)\r\nppp_cp_event(dev, pid, RCR_BAD, CP_CONF_NAK, id, nak_len, out);\r\nelse\r\nppp_cp_event(dev, pid, RCR_GOOD, CP_CONF_ACK, id, req_len, data);\r\nkfree(out);\r\n}\r\nstatic int ppp_rx(struct sk_buff *skb)\r\n{\r\nstruct hdlc_header *hdr = (struct hdlc_header*)skb->data;\r\nstruct net_device *dev = skb->dev;\r\nstruct ppp *ppp = get_ppp(dev);\r\nstruct proto *proto;\r\nstruct cp_header *cp;\r\nunsigned long flags;\r\nunsigned int len;\r\nu16 pid;\r\n#if DEBUG_CP\r\nint i;\r\nchar *ptr;\r\n#endif\r\nspin_lock_irqsave(&ppp->lock, flags);\r\nif (skb->len < sizeof(struct hdlc_header))\r\ngoto rx_error;\r\ncp = skb_pull(skb, sizeof(struct hdlc_header));\r\nif (hdr->address != HDLC_ADDR_ALLSTATIONS ||\r\nhdr->control != HDLC_CTRL_UI)\r\ngoto rx_error;\r\npid = ntohs(hdr->protocol);\r\nproto = get_proto(dev, pid);\r\nif (!proto) {\r\nif (ppp->protos[IDX_LCP].state == OPENED)\r\nppp_tx_cp(dev, PID_LCP, LCP_PROTO_REJ,\r\n++ppp->seq, skb->len + 2, &hdr->protocol);\r\ngoto rx_error;\r\n}\r\nlen = ntohs(cp->len);\r\nif (len < sizeof(struct cp_header) ||\r\nskb->len < len )\r\ngoto rx_error;\r\nskb_pull(skb, sizeof(struct cp_header));\r\nlen -= sizeof(struct cp_header);\r\n#if DEBUG_CP\r\nif (cp->code < CP_CODES)\r\nsprintf(debug_buffer, "[%s id 0x%X]", code_names[cp->code],\r\ncp->id);\r\nelse\r\nsprintf(debug_buffer, "[code %u id 0x%X]", cp->code, cp->id);\r\nptr = debug_buffer + strlen(debug_buffer);\r\nfor (i = 0; i < min_t(unsigned int, len, DEBUG_CP); i++) {\r\nsprintf(ptr, " %02X", skb->data[i]);\r\nptr += strlen(ptr);\r\n}\r\nprintk(KERN_DEBUG "%s: RX %s %s\n", dev->name, proto_name(pid),\r\ndebug_buffer);\r\n#endif\r\nif (pid == PID_LCP)\r\nswitch (cp->code) {\r\ncase LCP_PROTO_REJ:\r\npid = ntohs(*(__be16*)skb->data);\r\nif (pid == PID_LCP || pid == PID_IPCP ||\r\npid == PID_IPV6CP)\r\nppp_cp_event(dev, pid, RXJ_BAD, 0, 0,\r\n0, NULL);\r\ngoto out;\r\ncase LCP_ECHO_REQ:\r\nif (len >= 4 && proto->state == OPENED)\r\nppp_tx_cp(dev, PID_LCP, LCP_ECHO_REPLY,\r\ncp->id, len - 4, skb->data + 4);\r\ngoto out;\r\ncase LCP_ECHO_REPLY:\r\nif (cp->id == ppp->echo_id)\r\nppp->last_pong = jiffies;\r\ngoto out;\r\ncase LCP_DISC_REQ:\r\ngoto out;\r\n}\r\nswitch (cp->code) {\r\ncase CP_CONF_REQ:\r\nppp_cp_parse_cr(dev, pid, cp->id, len, skb->data);\r\nbreak;\r\ncase CP_CONF_ACK:\r\nif (cp->id == proto->cr_id)\r\nppp_cp_event(dev, pid, RCA, 0, 0, 0, NULL);\r\nbreak;\r\ncase CP_CONF_REJ:\r\ncase CP_CONF_NAK:\r\nif (cp->id == proto->cr_id)\r\nppp_cp_event(dev, pid, RCN, 0, 0, 0, NULL);\r\nbreak;\r\ncase CP_TERM_REQ:\r\nppp_cp_event(dev, pid, RTR, 0, cp->id, 0, NULL);\r\nbreak;\r\ncase CP_TERM_ACK:\r\nppp_cp_event(dev, pid, RTA, 0, 0, 0, NULL);\r\nbreak;\r\ncase CP_CODE_REJ:\r\nppp_cp_event(dev, pid, RXJ_BAD, 0, 0, 0, NULL);\r\nbreak;\r\ndefault:\r\nlen += sizeof(struct cp_header);\r\nif (len > dev->mtu)\r\nlen = dev->mtu;\r\nppp_cp_event(dev, pid, RUC, 0, 0, len, cp);\r\nbreak;\r\n}\r\ngoto out;\r\nrx_error:\r\ndev->stats.rx_errors++;\r\nout:\r\nspin_unlock_irqrestore(&ppp->lock, flags);\r\ndev_kfree_skb_any(skb);\r\nppp_tx_flush();\r\nreturn NET_RX_DROP;\r\n}\r\nstatic void ppp_timer(unsigned long arg)\r\n{\r\nstruct proto *proto = (struct proto *)arg;\r\nstruct ppp *ppp = get_ppp(proto->dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&ppp->lock, flags);\r\nswitch (proto->state) {\r\ncase STOPPING:\r\ncase REQ_SENT:\r\ncase ACK_RECV:\r\ncase ACK_SENT:\r\nif (proto->restart_counter) {\r\nppp_cp_event(proto->dev, proto->pid, TO_GOOD, 0, 0,\r\n0, NULL);\r\nproto->restart_counter--;\r\n} else\r\nppp_cp_event(proto->dev, proto->pid, TO_BAD, 0, 0,\r\n0, NULL);\r\nbreak;\r\ncase OPENED:\r\nif (proto->pid != PID_LCP)\r\nbreak;\r\nif (time_after(jiffies, ppp->last_pong +\r\nppp->keepalive_timeout * HZ)) {\r\nnetdev_info(proto->dev, "Link down\n");\r\nppp_cp_event(proto->dev, PID_LCP, STOP, 0, 0, 0, NULL);\r\nppp_cp_event(proto->dev, PID_LCP, START, 0, 0, 0, NULL);\r\n} else {\r\nppp->echo_id = ++ppp->seq;\r\nppp_tx_cp(proto->dev, PID_LCP, LCP_ECHO_REQ,\r\nppp->echo_id, 0, NULL);\r\nproto->timer.expires = jiffies +\r\nppp->keepalive_interval * HZ;\r\nadd_timer(&proto->timer);\r\n}\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&ppp->lock, flags);\r\nppp_tx_flush();\r\n}\r\nstatic void ppp_start(struct net_device *dev)\r\n{\r\nstruct ppp *ppp = get_ppp(dev);\r\nint i;\r\nfor (i = 0; i < IDX_COUNT; i++) {\r\nstruct proto *proto = &ppp->protos[i];\r\nproto->dev = dev;\r\ninit_timer(&proto->timer);\r\nproto->timer.function = ppp_timer;\r\nproto->timer.data = (unsigned long)proto;\r\nproto->state = CLOSED;\r\n}\r\nppp->protos[IDX_LCP].pid = PID_LCP;\r\nppp->protos[IDX_IPCP].pid = PID_IPCP;\r\nppp->protos[IDX_IPV6CP].pid = PID_IPV6CP;\r\nppp_cp_event(dev, PID_LCP, START, 0, 0, 0, NULL);\r\n}\r\nstatic void ppp_stop(struct net_device *dev)\r\n{\r\nppp_cp_event(dev, PID_LCP, STOP, 0, 0, 0, NULL);\r\n}\r\nstatic void ppp_close(struct net_device *dev)\r\n{\r\nppp_tx_flush();\r\n}\r\nstatic int ppp_ioctl(struct net_device *dev, struct ifreq *ifr)\r\n{\r\nhdlc_device *hdlc = dev_to_hdlc(dev);\r\nstruct ppp *ppp;\r\nint result;\r\nswitch (ifr->ifr_settings.type) {\r\ncase IF_GET_PROTO:\r\nif (dev_to_hdlc(dev)->proto != &proto)\r\nreturn -EINVAL;\r\nifr->ifr_settings.type = IF_PROTO_PPP;\r\nreturn 0;\r\ncase IF_PROTO_PPP:\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (dev->flags & IFF_UP)\r\nreturn -EBUSY;\r\nresult = hdlc->attach(dev, ENCODING_NRZ,PARITY_CRC16_PR1_CCITT);\r\nif (result)\r\nreturn result;\r\nresult = attach_hdlc_protocol(dev, &proto, sizeof(struct ppp));\r\nif (result)\r\nreturn result;\r\nppp = get_ppp(dev);\r\nspin_lock_init(&ppp->lock);\r\nppp->req_timeout = 2;\r\nppp->cr_retries = 10;\r\nppp->term_retries = 2;\r\nppp->keepalive_interval = 10;\r\nppp->keepalive_timeout = 60;\r\ndev->hard_header_len = sizeof(struct hdlc_header);\r\ndev->header_ops = &ppp_header_ops;\r\ndev->type = ARPHRD_PPP;\r\ncall_netdevice_notifiers(NETDEV_POST_TYPE_CHANGE, dev);\r\nnetif_dormant_on(dev);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int __init mod_init(void)\r\n{\r\nskb_queue_head_init(&tx_queue);\r\nregister_hdlc_protocol(&proto);\r\nreturn 0;\r\n}\r\nstatic void __exit mod_exit(void)\r\n{\r\nunregister_hdlc_protocol(&proto);\r\n}
