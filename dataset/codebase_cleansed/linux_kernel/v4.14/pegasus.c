static void async_ctrl_callback(struct urb *urb)\r\n{\r\nstruct usb_ctrlrequest *req = (struct usb_ctrlrequest *)urb->context;\r\nint status = urb->status;\r\nif (status < 0)\r\ndev_dbg(&urb->dev->dev, "%s failed with %d", __func__, status);\r\nkfree(req);\r\nusb_free_urb(urb);\r\n}\r\nstatic int get_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)\r\n{\r\nu8 *buf;\r\nint ret;\r\nbuf = kmalloc(size, GFP_NOIO);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nret = usb_control_msg(pegasus->usb, usb_rcvctrlpipe(pegasus->usb, 0),\r\nPEGASUS_REQ_GET_REGS, PEGASUS_REQT_READ, 0,\r\nindx, buf, size, 1000);\r\nif (ret < 0)\r\nnetif_dbg(pegasus, drv, pegasus->net,\r\n"%s returned %d\n", __func__, ret);\r\nelse if (ret <= size)\r\nmemcpy(data, buf, ret);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int set_registers(pegasus_t *pegasus, __u16 indx, __u16 size,\r\nconst void *data)\r\n{\r\nu8 *buf;\r\nint ret;\r\nbuf = kmemdup(data, size, GFP_NOIO);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),\r\nPEGASUS_REQ_SET_REGS, PEGASUS_REQT_WRITE, 0,\r\nindx, buf, size, 100);\r\nif (ret < 0)\r\nnetif_dbg(pegasus, drv, pegasus->net,\r\n"%s returned %d\n", __func__, ret);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int set_register(pegasus_t *pegasus, __u16 indx, __u8 data)\r\n{\r\nu8 *buf;\r\nint ret;\r\nbuf = kmemdup(&data, 1, GFP_NOIO);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),\r\nPEGASUS_REQ_SET_REG, PEGASUS_REQT_WRITE, data,\r\nindx, buf, 1, 1000);\r\nif (ret < 0)\r\nnetif_dbg(pegasus, drv, pegasus->net,\r\n"%s returned %d\n", __func__, ret);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int update_eth_regs_async(pegasus_t *pegasus)\r\n{\r\nint ret = -ENOMEM;\r\nstruct urb *async_urb;\r\nstruct usb_ctrlrequest *req;\r\nreq = kmalloc(sizeof(struct usb_ctrlrequest), GFP_ATOMIC);\r\nif (req == NULL)\r\nreturn ret;\r\nasync_urb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (async_urb == NULL) {\r\nkfree(req);\r\nreturn ret;\r\n}\r\nreq->bRequestType = PEGASUS_REQT_WRITE;\r\nreq->bRequest = PEGASUS_REQ_SET_REGS;\r\nreq->wValue = cpu_to_le16(0);\r\nreq->wIndex = cpu_to_le16(EthCtrl0);\r\nreq->wLength = cpu_to_le16(3);\r\nusb_fill_control_urb(async_urb, pegasus->usb,\r\nusb_sndctrlpipe(pegasus->usb, 0), (void *)req,\r\npegasus->eth_regs, 3, async_ctrl_callback, req);\r\nret = usb_submit_urb(async_urb, GFP_ATOMIC);\r\nif (ret) {\r\nif (ret == -ENODEV)\r\nnetif_device_detach(pegasus->net);\r\nnetif_err(pegasus, drv, pegasus->net,\r\n"%s returned %d\n", __func__, ret);\r\n}\r\nreturn ret;\r\n}\r\nstatic int __mii_op(pegasus_t *p, __u8 phy, __u8 indx, __u16 *regd, __u8 cmd)\r\n{\r\nint i;\r\n__u8 data[4] = { phy, 0, 0, indx };\r\n__le16 regdi;\r\nint ret = -ETIMEDOUT;\r\nif (cmd & PHY_WRITE) {\r\n__le16 *t = (__le16 *) & data[1];\r\n*t = cpu_to_le16(*regd);\r\n}\r\nset_register(p, PhyCtrl, 0);\r\nset_registers(p, PhyAddr, sizeof(data), data);\r\nset_register(p, PhyCtrl, (indx | cmd));\r\nfor (i = 0; i < REG_TIMEOUT; i++) {\r\nret = get_registers(p, PhyCtrl, 1, data);\r\nif (ret < 0)\r\ngoto fail;\r\nif (data[0] & PHY_DONE)\r\nbreak;\r\n}\r\nif (i >= REG_TIMEOUT)\r\ngoto fail;\r\nif (cmd & PHY_READ) {\r\nret = get_registers(p, PhyData, 2, &regdi);\r\n*regd = le16_to_cpu(regdi);\r\nreturn ret;\r\n}\r\nreturn 0;\r\nfail:\r\nnetif_dbg(p, drv, p->net, "%s failed\n", __func__);\r\nreturn ret;\r\n}\r\nstatic int read_mii_word(pegasus_t *pegasus, __u8 phy, __u8 indx, __u16 *regd)\r\n{\r\nreturn __mii_op(pegasus, phy, indx, regd, PHY_READ);\r\n}\r\nstatic int write_mii_word(pegasus_t *pegasus, __u8 phy, __u8 indx, __u16 *regd)\r\n{\r\nreturn __mii_op(pegasus, phy, indx, regd, PHY_WRITE);\r\n}\r\nstatic int mdio_read(struct net_device *dev, int phy_id, int loc)\r\n{\r\npegasus_t *pegasus = netdev_priv(dev);\r\nu16 res;\r\nread_mii_word(pegasus, phy_id, loc, &res);\r\nreturn (int)res;\r\n}\r\nstatic void mdio_write(struct net_device *dev, int phy_id, int loc, int val)\r\n{\r\npegasus_t *pegasus = netdev_priv(dev);\r\nu16 data = val;\r\nwrite_mii_word(pegasus, phy_id, loc, &data);\r\n}\r\nstatic int read_eprom_word(pegasus_t *pegasus, __u8 index, __u16 *retdata)\r\n{\r\nint i;\r\n__u8 tmp;\r\n__le16 retdatai;\r\nint ret;\r\nset_register(pegasus, EpromCtrl, 0);\r\nset_register(pegasus, EpromOffset, index);\r\nset_register(pegasus, EpromCtrl, EPROM_READ);\r\nfor (i = 0; i < REG_TIMEOUT; i++) {\r\nret = get_registers(pegasus, EpromCtrl, 1, &tmp);\r\nif (tmp & EPROM_DONE)\r\nbreak;\r\nif (ret == -ESHUTDOWN)\r\ngoto fail;\r\n}\r\nif (i >= REG_TIMEOUT)\r\ngoto fail;\r\nret = get_registers(pegasus, EpromData, 2, &retdatai);\r\n*retdata = le16_to_cpu(retdatai);\r\nreturn ret;\r\nfail:\r\nnetif_warn(pegasus, drv, pegasus->net, "%s failed\n", __func__);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic inline void enable_eprom_write(pegasus_t *pegasus)\r\n{\r\n__u8 tmp;\r\nget_registers(pegasus, EthCtrl2, 1, &tmp);\r\nset_register(pegasus, EthCtrl2, tmp | EPROM_WR_ENABLE);\r\n}\r\nstatic inline void disable_eprom_write(pegasus_t *pegasus)\r\n{\r\n__u8 tmp;\r\nget_registers(pegasus, EthCtrl2, 1, &tmp);\r\nset_register(pegasus, EpromCtrl, 0);\r\nset_register(pegasus, EthCtrl2, tmp & ~EPROM_WR_ENABLE);\r\n}\r\nstatic int write_eprom_word(pegasus_t *pegasus, __u8 index, __u16 data)\r\n{\r\nint i;\r\n__u8 tmp, d[4] = { 0x3f, 0, 0, EPROM_WRITE };\r\nint ret;\r\n__le16 le_data = cpu_to_le16(data);\r\nset_registers(pegasus, EpromOffset, 4, d);\r\nenable_eprom_write(pegasus);\r\nset_register(pegasus, EpromOffset, index);\r\nset_registers(pegasus, EpromData, 2, &le_data);\r\nset_register(pegasus, EpromCtrl, EPROM_WRITE);\r\nfor (i = 0; i < REG_TIMEOUT; i++) {\r\nret = get_registers(pegasus, EpromCtrl, 1, &tmp);\r\nif (ret == -ESHUTDOWN)\r\ngoto fail;\r\nif (tmp & EPROM_DONE)\r\nbreak;\r\n}\r\ndisable_eprom_write(pegasus);\r\nif (i >= REG_TIMEOUT)\r\ngoto fail;\r\nreturn ret;\r\nfail:\r\nnetif_warn(pegasus, drv, pegasus->net, "%s failed\n", __func__);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic inline void get_node_id(pegasus_t *pegasus, __u8 *id)\r\n{\r\nint i;\r\n__u16 w16;\r\nfor (i = 0; i < 3; i++) {\r\nread_eprom_word(pegasus, i, &w16);\r\n((__le16 *) id)[i] = cpu_to_le16(w16);\r\n}\r\n}\r\nstatic void set_ethernet_addr(pegasus_t *pegasus)\r\n{\r\n__u8 node_id[6];\r\nif (pegasus->features & PEGASUS_II) {\r\nget_registers(pegasus, 0x10, sizeof(node_id), node_id);\r\n} else {\r\nget_node_id(pegasus, node_id);\r\nset_registers(pegasus, EthID, sizeof(node_id), node_id);\r\n}\r\nmemcpy(pegasus->net->dev_addr, node_id, sizeof(node_id));\r\n}\r\nstatic inline int reset_mac(pegasus_t *pegasus)\r\n{\r\n__u8 data = 0x8;\r\nint i;\r\nset_register(pegasus, EthCtrl1, data);\r\nfor (i = 0; i < REG_TIMEOUT; i++) {\r\nget_registers(pegasus, EthCtrl1, 1, &data);\r\nif (~data & 0x08) {\r\nif (loopback)\r\nbreak;\r\nif (mii_mode && (pegasus->features & HAS_HOME_PNA))\r\nset_register(pegasus, Gpio1, 0x34);\r\nelse\r\nset_register(pegasus, Gpio1, 0x26);\r\nset_register(pegasus, Gpio0, pegasus->features);\r\nset_register(pegasus, Gpio0, DEFAULT_GPIO_SET);\r\nbreak;\r\n}\r\n}\r\nif (i == REG_TIMEOUT)\r\nreturn -ETIMEDOUT;\r\nif (usb_dev_id[pegasus->dev_index].vendor == VENDOR_LINKSYS ||\r\nusb_dev_id[pegasus->dev_index].vendor == VENDOR_DLINK) {\r\nset_register(pegasus, Gpio0, 0x24);\r\nset_register(pegasus, Gpio0, 0x26);\r\n}\r\nif (usb_dev_id[pegasus->dev_index].vendor == VENDOR_ELCON) {\r\n__u16 auxmode;\r\nread_mii_word(pegasus, 3, 0x1b, &auxmode);\r\nauxmode |= 4;\r\nwrite_mii_word(pegasus, 3, 0x1b, &auxmode);\r\n}\r\nreturn 0;\r\n}\r\nstatic int enable_net_traffic(struct net_device *dev, struct usb_device *usb)\r\n{\r\n__u16 linkpart;\r\n__u8 data[4];\r\npegasus_t *pegasus = netdev_priv(dev);\r\nint ret;\r\nread_mii_word(pegasus, pegasus->phy, MII_LPA, &linkpart);\r\ndata[0] = 0xc8;\r\ndata[1] = 0;\r\nif (linkpart & (ADVERTISE_100FULL | ADVERTISE_10FULL))\r\ndata[1] |= 0x20;\r\nif (linkpart & (ADVERTISE_100FULL | ADVERTISE_100HALF))\r\ndata[1] |= 0x10;\r\nif (mii_mode)\r\ndata[1] = 0;\r\ndata[2] = loopback ? 0x09 : 0x01;\r\nmemcpy(pegasus->eth_regs, data, sizeof(data));\r\nret = set_registers(pegasus, EthCtrl0, 3, data);\r\nif (usb_dev_id[pegasus->dev_index].vendor == VENDOR_LINKSYS ||\r\nusb_dev_id[pegasus->dev_index].vendor == VENDOR_LINKSYS2 ||\r\nusb_dev_id[pegasus->dev_index].vendor == VENDOR_DLINK) {\r\nu16 auxmode;\r\nread_mii_word(pegasus, 0, 0x1b, &auxmode);\r\nauxmode |= 4;\r\nwrite_mii_word(pegasus, 0, 0x1b, &auxmode);\r\n}\r\nreturn ret;\r\n}\r\nstatic void read_bulk_callback(struct urb *urb)\r\n{\r\npegasus_t *pegasus = urb->context;\r\nstruct net_device *net;\r\nint rx_status, count = urb->actual_length;\r\nint status = urb->status;\r\nu8 *buf = urb->transfer_buffer;\r\n__u16 pkt_len;\r\nif (!pegasus)\r\nreturn;\r\nnet = pegasus->net;\r\nif (!netif_device_present(net) || !netif_running(net))\r\nreturn;\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -ETIME:\r\nnetif_dbg(pegasus, rx_err, net, "reset MAC\n");\r\npegasus->flags &= ~PEGASUS_RX_BUSY;\r\nbreak;\r\ncase -EPIPE:\r\nnetif_warn(pegasus, rx_err, net, "no rx stall recovery\n");\r\nreturn;\r\ncase -ENOENT:\r\ncase -ECONNRESET:\r\ncase -ESHUTDOWN:\r\nnetif_dbg(pegasus, ifdown, net, "rx unlink, %d\n", status);\r\nreturn;\r\ndefault:\r\nnetif_dbg(pegasus, rx_err, net, "RX status %d\n", status);\r\ngoto goon;\r\n}\r\nif (count < 4)\r\ngoto goon;\r\nrx_status = buf[count - 2];\r\nif (rx_status & 0x1e) {\r\nnetif_dbg(pegasus, rx_err, net,\r\n"RX packet error %x\n", rx_status);\r\nnet->stats.rx_errors++;\r\nif (rx_status & 0x06)\r\nnet->stats.rx_length_errors++;\r\nif (rx_status & 0x08)\r\nnet->stats.rx_crc_errors++;\r\nif (rx_status & 0x10)\r\nnet->stats.rx_frame_errors++;\r\ngoto goon;\r\n}\r\nif (pegasus->chip == 0x8513) {\r\npkt_len = le32_to_cpu(*(__le32 *)urb->transfer_buffer);\r\npkt_len &= 0x0fff;\r\npegasus->rx_skb->data += 2;\r\n} else {\r\npkt_len = buf[count - 3] << 8;\r\npkt_len += buf[count - 4];\r\npkt_len &= 0xfff;\r\npkt_len -= 4;\r\n}\r\nif (pkt_len > PEGASUS_MTU)\r\ngoto goon;\r\nskb_put(pegasus->rx_skb, pkt_len);\r\npegasus->rx_skb->protocol = eth_type_trans(pegasus->rx_skb, net);\r\nnetif_rx(pegasus->rx_skb);\r\nnet->stats.rx_packets++;\r\nnet->stats.rx_bytes += pkt_len;\r\nif (pegasus->flags & PEGASUS_UNPLUG)\r\nreturn;\r\npegasus->rx_skb = __netdev_alloc_skb_ip_align(pegasus->net, PEGASUS_MTU,\r\nGFP_ATOMIC);\r\nif (pegasus->rx_skb == NULL)\r\ngoto tl_sched;\r\ngoon:\r\nusb_fill_bulk_urb(pegasus->rx_urb, pegasus->usb,\r\nusb_rcvbulkpipe(pegasus->usb, 1),\r\npegasus->rx_skb->data, PEGASUS_MTU,\r\nread_bulk_callback, pegasus);\r\nrx_status = usb_submit_urb(pegasus->rx_urb, GFP_ATOMIC);\r\nif (rx_status == -ENODEV)\r\nnetif_device_detach(pegasus->net);\r\nelse if (rx_status) {\r\npegasus->flags |= PEGASUS_RX_URB_FAIL;\r\ngoto tl_sched;\r\n} else {\r\npegasus->flags &= ~PEGASUS_RX_URB_FAIL;\r\n}\r\nreturn;\r\ntl_sched:\r\ntasklet_schedule(&pegasus->rx_tl);\r\n}\r\nstatic void rx_fixup(unsigned long data)\r\n{\r\npegasus_t *pegasus;\r\nint status;\r\npegasus = (pegasus_t *) data;\r\nif (pegasus->flags & PEGASUS_UNPLUG)\r\nreturn;\r\nif (pegasus->flags & PEGASUS_RX_URB_FAIL)\r\nif (pegasus->rx_skb)\r\ngoto try_again;\r\nif (pegasus->rx_skb == NULL)\r\npegasus->rx_skb = __netdev_alloc_skb_ip_align(pegasus->net,\r\nPEGASUS_MTU,\r\nGFP_ATOMIC);\r\nif (pegasus->rx_skb == NULL) {\r\nnetif_warn(pegasus, rx_err, pegasus->net, "low on memory\n");\r\ntasklet_schedule(&pegasus->rx_tl);\r\nreturn;\r\n}\r\nusb_fill_bulk_urb(pegasus->rx_urb, pegasus->usb,\r\nusb_rcvbulkpipe(pegasus->usb, 1),\r\npegasus->rx_skb->data, PEGASUS_MTU,\r\nread_bulk_callback, pegasus);\r\ntry_again:\r\nstatus = usb_submit_urb(pegasus->rx_urb, GFP_ATOMIC);\r\nif (status == -ENODEV)\r\nnetif_device_detach(pegasus->net);\r\nelse if (status) {\r\npegasus->flags |= PEGASUS_RX_URB_FAIL;\r\ntasklet_schedule(&pegasus->rx_tl);\r\n} else {\r\npegasus->flags &= ~PEGASUS_RX_URB_FAIL;\r\n}\r\n}\r\nstatic void write_bulk_callback(struct urb *urb)\r\n{\r\npegasus_t *pegasus = urb->context;\r\nstruct net_device *net;\r\nint status = urb->status;\r\nif (!pegasus)\r\nreturn;\r\nnet = pegasus->net;\r\nif (!netif_device_present(net) || !netif_running(net))\r\nreturn;\r\nswitch (status) {\r\ncase -EPIPE:\r\nnetif_stop_queue(net);\r\nnetif_warn(pegasus, tx_err, net, "no tx stall recovery\n");\r\nreturn;\r\ncase -ENOENT:\r\ncase -ECONNRESET:\r\ncase -ESHUTDOWN:\r\nnetif_dbg(pegasus, ifdown, net, "tx unlink, %d\n", status);\r\nreturn;\r\ndefault:\r\nnetif_info(pegasus, tx_err, net, "TX status %d\n", status);\r\ncase 0:\r\nbreak;\r\n}\r\nnetif_trans_update(net);\r\nnetif_wake_queue(net);\r\n}\r\nstatic void intr_callback(struct urb *urb)\r\n{\r\npegasus_t *pegasus = urb->context;\r\nstruct net_device *net;\r\nint res, status = urb->status;\r\nif (!pegasus)\r\nreturn;\r\nnet = pegasus->net;\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\nreturn;\r\ndefault:\r\nnetif_dbg(pegasus, timer, net, "intr status %d\n", status);\r\n}\r\nif (urb->actual_length >= 6) {\r\nu8 *d = urb->transfer_buffer;\r\nif (d[0] & (TX_UNDERRUN|EXCESSIVE_COL\r\n|LATE_COL|JABBER_TIMEOUT)) {\r\nnet->stats.tx_errors++;\r\nif (d[0] & TX_UNDERRUN)\r\nnet->stats.tx_fifo_errors++;\r\nif (d[0] & (EXCESSIVE_COL | JABBER_TIMEOUT))\r\nnet->stats.tx_aborted_errors++;\r\nif (d[0] & LATE_COL)\r\nnet->stats.tx_window_errors++;\r\n}\r\nnet->stats.rx_missed_errors += ((d[3] & 0x7f) << 8) | d[4];\r\n}\r\nres = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (res == -ENODEV)\r\nnetif_device_detach(pegasus->net);\r\nif (res)\r\nnetif_err(pegasus, timer, net,\r\n"can't resubmit interrupt urb, %d\n", res);\r\n}\r\nstatic void pegasus_tx_timeout(struct net_device *net)\r\n{\r\npegasus_t *pegasus = netdev_priv(net);\r\nnetif_warn(pegasus, timer, net, "tx timeout\n");\r\nusb_unlink_urb(pegasus->tx_urb);\r\nnet->stats.tx_errors++;\r\n}\r\nstatic netdev_tx_t pegasus_start_xmit(struct sk_buff *skb,\r\nstruct net_device *net)\r\n{\r\npegasus_t *pegasus = netdev_priv(net);\r\nint count = ((skb->len + 2) & 0x3f) ? skb->len + 2 : skb->len + 3;\r\nint res;\r\n__u16 l16 = skb->len;\r\nnetif_stop_queue(net);\r\n((__le16 *) pegasus->tx_buff)[0] = cpu_to_le16(l16);\r\nskb_copy_from_linear_data(skb, pegasus->tx_buff + 2, skb->len);\r\nusb_fill_bulk_urb(pegasus->tx_urb, pegasus->usb,\r\nusb_sndbulkpipe(pegasus->usb, 2),\r\npegasus->tx_buff, count,\r\nwrite_bulk_callback, pegasus);\r\nif ((res = usb_submit_urb(pegasus->tx_urb, GFP_ATOMIC))) {\r\nnetif_warn(pegasus, tx_err, net, "fail tx, %d\n", res);\r\nswitch (res) {\r\ncase -EPIPE:\r\nbreak;\r\ncase -ENODEV:\r\ncase -EPERM:\r\nnetif_device_detach(pegasus->net);\r\nbreak;\r\ndefault:\r\nnet->stats.tx_errors++;\r\nnetif_start_queue(net);\r\n}\r\n} else {\r\nnet->stats.tx_packets++;\r\nnet->stats.tx_bytes += skb->len;\r\n}\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic inline void disable_net_traffic(pegasus_t *pegasus)\r\n{\r\n__le16 tmp = cpu_to_le16(0);\r\nset_registers(pegasus, EthCtrl0, sizeof(tmp), &tmp);\r\n}\r\nstatic inline void get_interrupt_interval(pegasus_t *pegasus)\r\n{\r\nu16 data;\r\nu8 interval;\r\nread_eprom_word(pegasus, 4, &data);\r\ninterval = data >> 8;\r\nif (pegasus->usb->speed != USB_SPEED_HIGH) {\r\nif (interval < 0x80) {\r\nnetif_info(pegasus, timer, pegasus->net,\r\n"intr interval changed from %ums to %ums\n",\r\ninterval, 0x80);\r\ninterval = 0x80;\r\ndata = (data & 0x00FF) | ((u16)interval << 8);\r\n#ifdef PEGASUS_WRITE_EEPROM\r\nwrite_eprom_word(pegasus, 4, data);\r\n#endif\r\n}\r\n}\r\npegasus->intr_interval = interval;\r\n}\r\nstatic void set_carrier(struct net_device *net)\r\n{\r\npegasus_t *pegasus = netdev_priv(net);\r\nu16 tmp;\r\nif (read_mii_word(pegasus, pegasus->phy, MII_BMSR, &tmp))\r\nreturn;\r\nif (tmp & BMSR_LSTATUS)\r\nnetif_carrier_on(net);\r\nelse\r\nnetif_carrier_off(net);\r\n}\r\nstatic void free_all_urbs(pegasus_t *pegasus)\r\n{\r\nusb_free_urb(pegasus->intr_urb);\r\nusb_free_urb(pegasus->tx_urb);\r\nusb_free_urb(pegasus->rx_urb);\r\n}\r\nstatic void unlink_all_urbs(pegasus_t *pegasus)\r\n{\r\nusb_kill_urb(pegasus->intr_urb);\r\nusb_kill_urb(pegasus->tx_urb);\r\nusb_kill_urb(pegasus->rx_urb);\r\n}\r\nstatic int alloc_urbs(pegasus_t *pegasus)\r\n{\r\nint res = -ENOMEM;\r\npegasus->rx_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!pegasus->rx_urb) {\r\nreturn res;\r\n}\r\npegasus->tx_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!pegasus->tx_urb) {\r\nusb_free_urb(pegasus->rx_urb);\r\nreturn res;\r\n}\r\npegasus->intr_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!pegasus->intr_urb) {\r\nusb_free_urb(pegasus->tx_urb);\r\nusb_free_urb(pegasus->rx_urb);\r\nreturn res;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pegasus_open(struct net_device *net)\r\n{\r\npegasus_t *pegasus = netdev_priv(net);\r\nint res=-ENOMEM;\r\nif (pegasus->rx_skb == NULL)\r\npegasus->rx_skb = __netdev_alloc_skb_ip_align(pegasus->net,\r\nPEGASUS_MTU,\r\nGFP_KERNEL);\r\nif (!pegasus->rx_skb)\r\ngoto exit;\r\nres = set_registers(pegasus, EthID, 6, net->dev_addr);\r\nusb_fill_bulk_urb(pegasus->rx_urb, pegasus->usb,\r\nusb_rcvbulkpipe(pegasus->usb, 1),\r\npegasus->rx_skb->data, PEGASUS_MTU,\r\nread_bulk_callback, pegasus);\r\nif ((res = usb_submit_urb(pegasus->rx_urb, GFP_KERNEL))) {\r\nif (res == -ENODEV)\r\nnetif_device_detach(pegasus->net);\r\nnetif_dbg(pegasus, ifup, net, "failed rx_urb, %d\n", res);\r\ngoto exit;\r\n}\r\nusb_fill_int_urb(pegasus->intr_urb, pegasus->usb,\r\nusb_rcvintpipe(pegasus->usb, 3),\r\npegasus->intr_buff, sizeof(pegasus->intr_buff),\r\nintr_callback, pegasus, pegasus->intr_interval);\r\nif ((res = usb_submit_urb(pegasus->intr_urb, GFP_KERNEL))) {\r\nif (res == -ENODEV)\r\nnetif_device_detach(pegasus->net);\r\nnetif_dbg(pegasus, ifup, net, "failed intr_urb, %d\n", res);\r\nusb_kill_urb(pegasus->rx_urb);\r\ngoto exit;\r\n}\r\nres = enable_net_traffic(net, pegasus->usb);\r\nif (res < 0) {\r\nnetif_dbg(pegasus, ifup, net,\r\n"can't enable_net_traffic() - %d\n", res);\r\nres = -EIO;\r\nusb_kill_urb(pegasus->rx_urb);\r\nusb_kill_urb(pegasus->intr_urb);\r\ngoto exit;\r\n}\r\nset_carrier(net);\r\nnetif_start_queue(net);\r\nnetif_dbg(pegasus, ifup, net, "open\n");\r\nres = 0;\r\nexit:\r\nreturn res;\r\n}\r\nstatic int pegasus_close(struct net_device *net)\r\n{\r\npegasus_t *pegasus = netdev_priv(net);\r\nnetif_stop_queue(net);\r\nif (!(pegasus->flags & PEGASUS_UNPLUG))\r\ndisable_net_traffic(pegasus);\r\ntasklet_kill(&pegasus->rx_tl);\r\nunlink_all_urbs(pegasus);\r\nreturn 0;\r\n}\r\nstatic void pegasus_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\npegasus_t *pegasus = netdev_priv(dev);\r\nstrlcpy(info->driver, driver_name, sizeof(info->driver));\r\nstrlcpy(info->version, DRIVER_VERSION, sizeof(info->version));\r\nusb_make_path(pegasus->usb, info->bus_info, sizeof(info->bus_info));\r\n}\r\nstatic void\r\npegasus_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\r\n{\r\npegasus_t *pegasus = netdev_priv(dev);\r\nwol->supported = WAKE_MAGIC | WAKE_PHY;\r\nwol->wolopts = pegasus->wolopts;\r\n}\r\nstatic int\r\npegasus_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\r\n{\r\npegasus_t *pegasus = netdev_priv(dev);\r\nu8 reg78 = 0x04;\r\nint ret;\r\nif (wol->wolopts & ~WOL_SUPPORTED)\r\nreturn -EINVAL;\r\nif (wol->wolopts & WAKE_MAGIC)\r\nreg78 |= 0x80;\r\nif (wol->wolopts & WAKE_PHY)\r\nreg78 |= 0x40;\r\nif (wol->wolopts)\r\npegasus->eth_regs[0] |= 0x10;\r\nelse\r\npegasus->eth_regs[0] &= ~0x10;\r\npegasus->wolopts = wol->wolopts;\r\nret = set_register(pegasus, WakeupControl, reg78);\r\nif (!ret)\r\nret = device_set_wakeup_enable(&pegasus->usb->dev,\r\nwol->wolopts);\r\nreturn ret;\r\n}\r\nstatic inline void pegasus_reset_wol(struct net_device *dev)\r\n{\r\nstruct ethtool_wolinfo wol;\r\nmemset(&wol, 0, sizeof wol);\r\n(void) pegasus_set_wol(dev, &wol);\r\n}\r\nstatic int\r\npegasus_get_link_ksettings(struct net_device *dev,\r\nstruct ethtool_link_ksettings *ecmd)\r\n{\r\npegasus_t *pegasus;\r\npegasus = netdev_priv(dev);\r\nmii_ethtool_get_link_ksettings(&pegasus->mii, ecmd);\r\nreturn 0;\r\n}\r\nstatic int\r\npegasus_set_link_ksettings(struct net_device *dev,\r\nconst struct ethtool_link_ksettings *ecmd)\r\n{\r\npegasus_t *pegasus = netdev_priv(dev);\r\nreturn mii_ethtool_set_link_ksettings(&pegasus->mii, ecmd);\r\n}\r\nstatic int pegasus_nway_reset(struct net_device *dev)\r\n{\r\npegasus_t *pegasus = netdev_priv(dev);\r\nreturn mii_nway_restart(&pegasus->mii);\r\n}\r\nstatic u32 pegasus_get_link(struct net_device *dev)\r\n{\r\npegasus_t *pegasus = netdev_priv(dev);\r\nreturn mii_link_ok(&pegasus->mii);\r\n}\r\nstatic u32 pegasus_get_msglevel(struct net_device *dev)\r\n{\r\npegasus_t *pegasus = netdev_priv(dev);\r\nreturn pegasus->msg_enable;\r\n}\r\nstatic void pegasus_set_msglevel(struct net_device *dev, u32 v)\r\n{\r\npegasus_t *pegasus = netdev_priv(dev);\r\npegasus->msg_enable = v;\r\n}\r\nstatic int pegasus_ioctl(struct net_device *net, struct ifreq *rq, int cmd)\r\n{\r\n__u16 *data = (__u16 *) &rq->ifr_ifru;\r\npegasus_t *pegasus = netdev_priv(net);\r\nint res;\r\nswitch (cmd) {\r\ncase SIOCDEVPRIVATE:\r\ndata[0] = pegasus->phy;\r\ncase SIOCDEVPRIVATE + 1:\r\nread_mii_word(pegasus, data[0], data[1] & 0x1f, &data[3]);\r\nres = 0;\r\nbreak;\r\ncase SIOCDEVPRIVATE + 2:\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nwrite_mii_word(pegasus, pegasus->phy, data[1] & 0x1f, &data[2]);\r\nres = 0;\r\nbreak;\r\ndefault:\r\nres = -EOPNOTSUPP;\r\n}\r\nreturn res;\r\n}\r\nstatic void pegasus_set_multicast(struct net_device *net)\r\n{\r\npegasus_t *pegasus = netdev_priv(net);\r\nif (net->flags & IFF_PROMISC) {\r\npegasus->eth_regs[EthCtrl2] |= RX_PROMISCUOUS;\r\nnetif_info(pegasus, link, net, "Promiscuous mode enabled\n");\r\n} else if (!netdev_mc_empty(net) || (net->flags & IFF_ALLMULTI)) {\r\npegasus->eth_regs[EthCtrl0] |= RX_MULTICAST;\r\npegasus->eth_regs[EthCtrl2] &= ~RX_PROMISCUOUS;\r\nnetif_dbg(pegasus, link, net, "set allmulti\n");\r\n} else {\r\npegasus->eth_regs[EthCtrl0] &= ~RX_MULTICAST;\r\npegasus->eth_regs[EthCtrl2] &= ~RX_PROMISCUOUS;\r\n}\r\nupdate_eth_regs_async(pegasus);\r\n}\r\nstatic __u8 mii_phy_probe(pegasus_t *pegasus)\r\n{\r\nint i;\r\n__u16 tmp;\r\nfor (i = 0; i < 32; i++) {\r\nread_mii_word(pegasus, i, MII_BMSR, &tmp);\r\nif (tmp == 0 || tmp == 0xffff || (tmp & BMSR_MEDIA) == 0)\r\ncontinue;\r\nelse\r\nreturn i;\r\n}\r\nreturn 0xff;\r\n}\r\nstatic inline void setup_pegasus_II(pegasus_t *pegasus)\r\n{\r\n__u8 data = 0xa5;\r\nset_register(pegasus, Reg1d, 0);\r\nset_register(pegasus, Reg7b, 1);\r\nmdelay(100);\r\nif ((pegasus->features & HAS_HOME_PNA) && mii_mode)\r\nset_register(pegasus, Reg7b, 0);\r\nelse\r\nset_register(pegasus, Reg7b, 2);\r\nset_register(pegasus, 0x83, data);\r\nget_registers(pegasus, 0x83, 1, &data);\r\nif (data == 0xa5)\r\npegasus->chip = 0x8513;\r\nelse\r\npegasus->chip = 0;\r\nset_register(pegasus, 0x80, 0xc0);\r\nset_register(pegasus, 0x83, 0xff);\r\nset_register(pegasus, 0x84, 0x01);\r\nif (pegasus->features & HAS_HOME_PNA && mii_mode)\r\nset_register(pegasus, Reg81, 6);\r\nelse\r\nset_register(pegasus, Reg81, 2);\r\n}\r\nstatic void check_carrier(struct work_struct *work)\r\n{\r\npegasus_t *pegasus = container_of(work, pegasus_t, carrier_check.work);\r\nset_carrier(pegasus->net);\r\nif (!(pegasus->flags & PEGASUS_UNPLUG)) {\r\nqueue_delayed_work(pegasus_workqueue, &pegasus->carrier_check,\r\nCARRIER_CHECK_DELAY);\r\n}\r\n}\r\nstatic int pegasus_blacklisted(struct usb_device *udev)\r\n{\r\nstruct usb_device_descriptor *udd = &udev->descriptor;\r\nif ((udd->idVendor == cpu_to_le16(VENDOR_BELKIN)) &&\r\n(udd->idProduct == cpu_to_le16(0x0121)) &&\r\n(udd->bDeviceClass == USB_CLASS_WIRELESS_CONTROLLER) &&\r\n(udd->bDeviceProtocol == 1))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void pegasus_dec_workqueue(void)\r\n{\r\npegasus_count--;\r\nif (pegasus_count == 0) {\r\ndestroy_workqueue(pegasus_workqueue);\r\npegasus_workqueue = NULL;\r\n}\r\n}\r\nstatic int pegasus_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *dev = interface_to_usbdev(intf);\r\nstruct net_device *net;\r\npegasus_t *pegasus;\r\nint dev_index = id - pegasus_ids;\r\nint res = -ENOMEM;\r\nif (pegasus_blacklisted(dev))\r\nreturn -ENODEV;\r\nif (pegasus_count == 0) {\r\npegasus_workqueue = alloc_workqueue("pegasus", WQ_MEM_RECLAIM,\r\n0);\r\nif (!pegasus_workqueue)\r\nreturn -ENOMEM;\r\n}\r\npegasus_count++;\r\nnet = alloc_etherdev(sizeof(struct pegasus));\r\nif (!net)\r\ngoto out;\r\npegasus = netdev_priv(net);\r\npegasus->dev_index = dev_index;\r\nres = alloc_urbs(pegasus);\r\nif (res < 0) {\r\ndev_err(&intf->dev, "can't allocate %s\n", "urbs");\r\ngoto out1;\r\n}\r\ntasklet_init(&pegasus->rx_tl, rx_fixup, (unsigned long) pegasus);\r\nINIT_DELAYED_WORK(&pegasus->carrier_check, check_carrier);\r\npegasus->intf = intf;\r\npegasus->usb = dev;\r\npegasus->net = net;\r\nnet->watchdog_timeo = PEGASUS_TX_TIMEOUT;\r\nnet->netdev_ops = &pegasus_netdev_ops;\r\nnet->ethtool_ops = &ops;\r\npegasus->mii.dev = net;\r\npegasus->mii.mdio_read = mdio_read;\r\npegasus->mii.mdio_write = mdio_write;\r\npegasus->mii.phy_id_mask = 0x1f;\r\npegasus->mii.reg_num_mask = 0x1f;\r\npegasus->msg_enable = netif_msg_init(msg_level, NETIF_MSG_DRV\r\n| NETIF_MSG_PROBE | NETIF_MSG_LINK);\r\npegasus->features = usb_dev_id[dev_index].private;\r\nget_interrupt_interval(pegasus);\r\nif (reset_mac(pegasus)) {\r\ndev_err(&intf->dev, "can't reset MAC\n");\r\nres = -EIO;\r\ngoto out2;\r\n}\r\nset_ethernet_addr(pegasus);\r\nif (pegasus->features & PEGASUS_II) {\r\ndev_info(&intf->dev, "setup Pegasus II specific registers\n");\r\nsetup_pegasus_II(pegasus);\r\n}\r\npegasus->phy = mii_phy_probe(pegasus);\r\nif (pegasus->phy == 0xff) {\r\ndev_warn(&intf->dev, "can't locate MII phy, using default\n");\r\npegasus->phy = 1;\r\n}\r\npegasus->mii.phy_id = pegasus->phy;\r\nusb_set_intfdata(intf, pegasus);\r\nSET_NETDEV_DEV(net, &intf->dev);\r\npegasus_reset_wol(net);\r\nres = register_netdev(net);\r\nif (res)\r\ngoto out3;\r\nqueue_delayed_work(pegasus_workqueue, &pegasus->carrier_check,\r\nCARRIER_CHECK_DELAY);\r\ndev_info(&intf->dev, "%s, %s, %pM\n", net->name,\r\nusb_dev_id[dev_index].name, net->dev_addr);\r\nreturn 0;\r\nout3:\r\nusb_set_intfdata(intf, NULL);\r\nout2:\r\nfree_all_urbs(pegasus);\r\nout1:\r\nfree_netdev(net);\r\nout:\r\npegasus_dec_workqueue();\r\nreturn res;\r\n}\r\nstatic void pegasus_disconnect(struct usb_interface *intf)\r\n{\r\nstruct pegasus *pegasus = usb_get_intfdata(intf);\r\nusb_set_intfdata(intf, NULL);\r\nif (!pegasus) {\r\ndev_dbg(&intf->dev, "unregistering non-bound device?\n");\r\nreturn;\r\n}\r\npegasus->flags |= PEGASUS_UNPLUG;\r\ncancel_delayed_work(&pegasus->carrier_check);\r\nunregister_netdev(pegasus->net);\r\nunlink_all_urbs(pegasus);\r\nfree_all_urbs(pegasus);\r\nif (pegasus->rx_skb != NULL) {\r\ndev_kfree_skb(pegasus->rx_skb);\r\npegasus->rx_skb = NULL;\r\n}\r\nfree_netdev(pegasus->net);\r\npegasus_dec_workqueue();\r\n}\r\nstatic int pegasus_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct pegasus *pegasus = usb_get_intfdata(intf);\r\nnetif_device_detach(pegasus->net);\r\ncancel_delayed_work(&pegasus->carrier_check);\r\nif (netif_running(pegasus->net)) {\r\nusb_kill_urb(pegasus->rx_urb);\r\nusb_kill_urb(pegasus->intr_urb);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pegasus_resume(struct usb_interface *intf)\r\n{\r\nstruct pegasus *pegasus = usb_get_intfdata(intf);\r\nnetif_device_attach(pegasus->net);\r\nif (netif_running(pegasus->net)) {\r\npegasus->rx_urb->status = 0;\r\npegasus->rx_urb->actual_length = 0;\r\nread_bulk_callback(pegasus->rx_urb);\r\npegasus->intr_urb->status = 0;\r\npegasus->intr_urb->actual_length = 0;\r\nintr_callback(pegasus->intr_urb);\r\n}\r\nqueue_delayed_work(pegasus_workqueue, &pegasus->carrier_check,\r\nCARRIER_CHECK_DELAY);\r\nreturn 0;\r\n}\r\nstatic void __init parse_id(char *id)\r\n{\r\nunsigned int vendor_id = 0, device_id = 0, flags = 0, i = 0;\r\nchar *token, *name = NULL;\r\nif ((token = strsep(&id, ":")) != NULL)\r\nname = token;\r\nif ((token = strsep(&id, ":")) != NULL)\r\nvendor_id = simple_strtoul(token, NULL, 16);\r\nif ((token = strsep(&id, ":")) != NULL)\r\ndevice_id = simple_strtoul(token, NULL, 16);\r\nflags = simple_strtoul(id, NULL, 16);\r\npr_info("%s: new device %s, vendor ID 0x%04x, device ID 0x%04x, flags: 0x%x\n",\r\ndriver_name, name, vendor_id, device_id, flags);\r\nif (vendor_id > 0x10000 || vendor_id == 0)\r\nreturn;\r\nif (device_id > 0x10000 || device_id == 0)\r\nreturn;\r\nfor (i = 0; usb_dev_id[i].name; i++);\r\nusb_dev_id[i].name = name;\r\nusb_dev_id[i].vendor = vendor_id;\r\nusb_dev_id[i].device = device_id;\r\nusb_dev_id[i].private = flags;\r\npegasus_ids[i].match_flags = USB_DEVICE_ID_MATCH_DEVICE;\r\npegasus_ids[i].idVendor = vendor_id;\r\npegasus_ids[i].idProduct = device_id;\r\n}\r\nstatic int __init pegasus_init(void)\r\n{\r\npr_info("%s: %s, " DRIVER_DESC "\n", driver_name, DRIVER_VERSION);\r\nif (devid)\r\nparse_id(devid);\r\nreturn usb_register(&pegasus_driver);\r\n}\r\nstatic void __exit pegasus_exit(void)\r\n{\r\nusb_deregister(&pegasus_driver);\r\n}
