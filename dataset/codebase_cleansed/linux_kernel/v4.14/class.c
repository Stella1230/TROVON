static ssize_t class_attr_show(struct kobject *kobj, struct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct class_attribute *class_attr = to_class_attr(attr);\r\nstruct subsys_private *cp = to_subsys_private(kobj);\r\nssize_t ret = -EIO;\r\nif (class_attr->show)\r\nret = class_attr->show(cp->class, class_attr, buf);\r\nreturn ret;\r\n}\r\nstatic ssize_t class_attr_store(struct kobject *kobj, struct attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct class_attribute *class_attr = to_class_attr(attr);\r\nstruct subsys_private *cp = to_subsys_private(kobj);\r\nssize_t ret = -EIO;\r\nif (class_attr->store)\r\nret = class_attr->store(cp->class, class_attr, buf, count);\r\nreturn ret;\r\n}\r\nstatic void class_release(struct kobject *kobj)\r\n{\r\nstruct subsys_private *cp = to_subsys_private(kobj);\r\nstruct class *class = cp->class;\r\npr_debug("class '%s': release.\n", class->name);\r\nif (class->class_release)\r\nclass->class_release(class);\r\nelse\r\npr_debug("class '%s' does not have a release() function, "\r\n"be careful\n", class->name);\r\nkfree(cp);\r\n}\r\nstatic const struct kobj_ns_type_operations *class_child_ns_type(struct kobject *kobj)\r\n{\r\nstruct subsys_private *cp = to_subsys_private(kobj);\r\nstruct class *class = cp->class;\r\nreturn class->ns_type;\r\n}\r\nint class_create_file_ns(struct class *cls, const struct class_attribute *attr,\r\nconst void *ns)\r\n{\r\nint error;\r\nif (cls)\r\nerror = sysfs_create_file_ns(&cls->p->subsys.kobj,\r\n&attr->attr, ns);\r\nelse\r\nerror = -EINVAL;\r\nreturn error;\r\n}\r\nvoid class_remove_file_ns(struct class *cls, const struct class_attribute *attr,\r\nconst void *ns)\r\n{\r\nif (cls)\r\nsysfs_remove_file_ns(&cls->p->subsys.kobj, &attr->attr, ns);\r\n}\r\nstatic struct class *class_get(struct class *cls)\r\n{\r\nif (cls)\r\nkset_get(&cls->p->subsys);\r\nreturn cls;\r\n}\r\nstatic void class_put(struct class *cls)\r\n{\r\nif (cls)\r\nkset_put(&cls->p->subsys);\r\n}\r\nstatic void klist_class_dev_get(struct klist_node *n)\r\n{\r\nstruct device *dev = container_of(n, struct device, knode_class);\r\nget_device(dev);\r\n}\r\nstatic void klist_class_dev_put(struct klist_node *n)\r\n{\r\nstruct device *dev = container_of(n, struct device, knode_class);\r\nput_device(dev);\r\n}\r\nstatic int class_add_groups(struct class *cls,\r\nconst struct attribute_group **groups)\r\n{\r\nreturn sysfs_create_groups(&cls->p->subsys.kobj, groups);\r\n}\r\nstatic void class_remove_groups(struct class *cls,\r\nconst struct attribute_group **groups)\r\n{\r\nreturn sysfs_remove_groups(&cls->p->subsys.kobj, groups);\r\n}\r\nint __class_register(struct class *cls, struct lock_class_key *key)\r\n{\r\nstruct subsys_private *cp;\r\nint error;\r\npr_debug("device class '%s': registering\n", cls->name);\r\ncp = kzalloc(sizeof(*cp), GFP_KERNEL);\r\nif (!cp)\r\nreturn -ENOMEM;\r\nklist_init(&cp->klist_devices, klist_class_dev_get, klist_class_dev_put);\r\nINIT_LIST_HEAD(&cp->interfaces);\r\nkset_init(&cp->glue_dirs);\r\n__mutex_init(&cp->mutex, "subsys mutex", key);\r\nerror = kobject_set_name(&cp->subsys.kobj, "%s", cls->name);\r\nif (error) {\r\nkfree(cp);\r\nreturn error;\r\n}\r\nif (!cls->dev_kobj)\r\ncls->dev_kobj = sysfs_dev_char_kobj;\r\n#if defined(CONFIG_BLOCK)\r\nif (!sysfs_deprecated || cls != &block_class)\r\ncp->subsys.kobj.kset = class_kset;\r\n#else\r\ncp->subsys.kobj.kset = class_kset;\r\n#endif\r\ncp->subsys.kobj.ktype = &class_ktype;\r\ncp->class = cls;\r\ncls->p = cp;\r\nerror = kset_register(&cp->subsys);\r\nif (error) {\r\nkfree(cp);\r\nreturn error;\r\n}\r\nerror = class_add_groups(class_get(cls), cls->class_groups);\r\nclass_put(cls);\r\nreturn error;\r\n}\r\nvoid class_unregister(struct class *cls)\r\n{\r\npr_debug("device class '%s': unregistering\n", cls->name);\r\nclass_remove_groups(cls, cls->class_groups);\r\nkset_unregister(&cls->p->subsys);\r\n}\r\nstatic void class_create_release(struct class *cls)\r\n{\r\npr_debug("%s called for %s\n", __func__, cls->name);\r\nkfree(cls);\r\n}\r\nstruct class *__class_create(struct module *owner, const char *name,\r\nstruct lock_class_key *key)\r\n{\r\nstruct class *cls;\r\nint retval;\r\ncls = kzalloc(sizeof(*cls), GFP_KERNEL);\r\nif (!cls) {\r\nretval = -ENOMEM;\r\ngoto error;\r\n}\r\ncls->name = name;\r\ncls->owner = owner;\r\ncls->class_release = class_create_release;\r\nretval = __class_register(cls, key);\r\nif (retval)\r\ngoto error;\r\nreturn cls;\r\nerror:\r\nkfree(cls);\r\nreturn ERR_PTR(retval);\r\n}\r\nvoid class_destroy(struct class *cls)\r\n{\r\nif ((cls == NULL) || (IS_ERR(cls)))\r\nreturn;\r\nclass_unregister(cls);\r\n}\r\nvoid class_dev_iter_init(struct class_dev_iter *iter, struct class *class,\r\nstruct device *start, const struct device_type *type)\r\n{\r\nstruct klist_node *start_knode = NULL;\r\nif (start)\r\nstart_knode = &start->knode_class;\r\nklist_iter_init_node(&class->p->klist_devices, &iter->ki, start_knode);\r\niter->type = type;\r\n}\r\nstruct device *class_dev_iter_next(struct class_dev_iter *iter)\r\n{\r\nstruct klist_node *knode;\r\nstruct device *dev;\r\nwhile (1) {\r\nknode = klist_next(&iter->ki);\r\nif (!knode)\r\nreturn NULL;\r\ndev = container_of(knode, struct device, knode_class);\r\nif (!iter->type || iter->type == dev->type)\r\nreturn dev;\r\n}\r\n}\r\nvoid class_dev_iter_exit(struct class_dev_iter *iter)\r\n{\r\nklist_iter_exit(&iter->ki);\r\n}\r\nint class_for_each_device(struct class *class, struct device *start,\r\nvoid *data, int (*fn)(struct device *, void *))\r\n{\r\nstruct class_dev_iter iter;\r\nstruct device *dev;\r\nint error = 0;\r\nif (!class)\r\nreturn -EINVAL;\r\nif (!class->p) {\r\nWARN(1, "%s called for class '%s' before it was initialized",\r\n__func__, class->name);\r\nreturn -EINVAL;\r\n}\r\nclass_dev_iter_init(&iter, class, start, NULL);\r\nwhile ((dev = class_dev_iter_next(&iter))) {\r\nerror = fn(dev, data);\r\nif (error)\r\nbreak;\r\n}\r\nclass_dev_iter_exit(&iter);\r\nreturn error;\r\n}\r\nstruct device *class_find_device(struct class *class, struct device *start,\r\nconst void *data,\r\nint (*match)(struct device *, const void *))\r\n{\r\nstruct class_dev_iter iter;\r\nstruct device *dev;\r\nif (!class)\r\nreturn NULL;\r\nif (!class->p) {\r\nWARN(1, "%s called for class '%s' before it was initialized",\r\n__func__, class->name);\r\nreturn NULL;\r\n}\r\nclass_dev_iter_init(&iter, class, start, NULL);\r\nwhile ((dev = class_dev_iter_next(&iter))) {\r\nif (match(dev, data)) {\r\nget_device(dev);\r\nbreak;\r\n}\r\n}\r\nclass_dev_iter_exit(&iter);\r\nreturn dev;\r\n}\r\nint class_interface_register(struct class_interface *class_intf)\r\n{\r\nstruct class *parent;\r\nstruct class_dev_iter iter;\r\nstruct device *dev;\r\nif (!class_intf || !class_intf->class)\r\nreturn -ENODEV;\r\nparent = class_get(class_intf->class);\r\nif (!parent)\r\nreturn -EINVAL;\r\nmutex_lock(&parent->p->mutex);\r\nlist_add_tail(&class_intf->node, &parent->p->interfaces);\r\nif (class_intf->add_dev) {\r\nclass_dev_iter_init(&iter, parent, NULL, NULL);\r\nwhile ((dev = class_dev_iter_next(&iter)))\r\nclass_intf->add_dev(dev, class_intf);\r\nclass_dev_iter_exit(&iter);\r\n}\r\nmutex_unlock(&parent->p->mutex);\r\nreturn 0;\r\n}\r\nvoid class_interface_unregister(struct class_interface *class_intf)\r\n{\r\nstruct class *parent = class_intf->class;\r\nstruct class_dev_iter iter;\r\nstruct device *dev;\r\nif (!parent)\r\nreturn;\r\nmutex_lock(&parent->p->mutex);\r\nlist_del_init(&class_intf->node);\r\nif (class_intf->remove_dev) {\r\nclass_dev_iter_init(&iter, parent, NULL, NULL);\r\nwhile ((dev = class_dev_iter_next(&iter)))\r\nclass_intf->remove_dev(dev, class_intf);\r\nclass_dev_iter_exit(&iter);\r\n}\r\nmutex_unlock(&parent->p->mutex);\r\nclass_put(parent);\r\n}\r\nssize_t show_class_attr_string(struct class *class,\r\nstruct class_attribute *attr, char *buf)\r\n{\r\nstruct class_attribute_string *cs;\r\ncs = container_of(attr, struct class_attribute_string, attr);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", cs->str);\r\n}\r\nstruct class_compat *class_compat_register(const char *name)\r\n{\r\nstruct class_compat *cls;\r\ncls = kmalloc(sizeof(struct class_compat), GFP_KERNEL);\r\nif (!cls)\r\nreturn NULL;\r\ncls->kobj = kobject_create_and_add(name, &class_kset->kobj);\r\nif (!cls->kobj) {\r\nkfree(cls);\r\nreturn NULL;\r\n}\r\nreturn cls;\r\n}\r\nvoid class_compat_unregister(struct class_compat *cls)\r\n{\r\nkobject_put(cls->kobj);\r\nkfree(cls);\r\n}\r\nint class_compat_create_link(struct class_compat *cls, struct device *dev,\r\nstruct device *device_link)\r\n{\r\nint error;\r\nerror = sysfs_create_link(cls->kobj, &dev->kobj, dev_name(dev));\r\nif (error)\r\nreturn error;\r\nif (device_link) {\r\nerror = sysfs_create_link(&dev->kobj, &device_link->kobj,\r\n"device");\r\nif (error)\r\nsysfs_remove_link(cls->kobj, dev_name(dev));\r\n}\r\nreturn error;\r\n}\r\nvoid class_compat_remove_link(struct class_compat *cls, struct device *dev,\r\nstruct device *device_link)\r\n{\r\nif (device_link)\r\nsysfs_remove_link(&dev->kobj, "device");\r\nsysfs_remove_link(cls->kobj, dev_name(dev));\r\n}\r\nint __init classes_init(void)\r\n{\r\nclass_kset = kset_create_and_add("class", NULL, NULL);\r\nif (!class_kset)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}
