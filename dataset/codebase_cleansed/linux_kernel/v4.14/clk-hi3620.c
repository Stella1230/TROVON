static void __init hi3620_clk_init(struct device_node *np)\r\n{\r\nstruct hisi_clock_data *clk_data;\r\nclk_data = hisi_clk_init(np, HI3620_NR_CLKS);\r\nif (!clk_data)\r\nreturn;\r\nhisi_clk_register_fixed_rate(hi3620_fixed_rate_clks,\r\nARRAY_SIZE(hi3620_fixed_rate_clks),\r\nclk_data);\r\nhisi_clk_register_fixed_factor(hi3620_fixed_factor_clks,\r\nARRAY_SIZE(hi3620_fixed_factor_clks),\r\nclk_data);\r\nhisi_clk_register_mux(hi3620_mux_clks, ARRAY_SIZE(hi3620_mux_clks),\r\nclk_data);\r\nhisi_clk_register_divider(hi3620_div_clks, ARRAY_SIZE(hi3620_div_clks),\r\nclk_data);\r\nhisi_clk_register_gate_sep(hi3620_separated_gate_clks,\r\nARRAY_SIZE(hi3620_separated_gate_clks),\r\nclk_data);\r\n}\r\nstatic unsigned long mmc_clk_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nswitch (parent_rate) {\r\ncase 26000000:\r\nreturn 13000000;\r\ncase 180000000:\r\nreturn 25000000;\r\ncase 360000000:\r\nreturn 50000000;\r\ncase 720000000:\r\nreturn 100000000;\r\ncase 1440000000:\r\nreturn 180000000;\r\ndefault:\r\nreturn parent_rate;\r\n}\r\n}\r\nstatic int mmc_clk_determine_rate(struct clk_hw *hw,\r\nstruct clk_rate_request *req)\r\n{\r\nstruct clk_mmc *mclk = to_mmc(hw);\r\nif ((req->rate <= 13000000) && (mclk->id == HI3620_MMC_CIUCLK1)) {\r\nreq->rate = 13000000;\r\nreq->best_parent_rate = 26000000;\r\n} else if (req->rate <= 26000000) {\r\nreq->rate = 25000000;\r\nreq->best_parent_rate = 180000000;\r\n} else if (req->rate <= 52000000) {\r\nreq->rate = 50000000;\r\nreq->best_parent_rate = 360000000;\r\n} else if (req->rate <= 100000000) {\r\nreq->rate = 100000000;\r\nreq->best_parent_rate = 720000000;\r\n} else {\r\nreq->rate = 180000000;\r\nreq->best_parent_rate = 1440000000;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic u32 mmc_clk_delay(u32 val, u32 para, u32 off, u32 len)\r\n{\r\nu32 i;\r\nfor (i = 0; i < len; i++) {\r\nif (para % 2)\r\nval |= 1 << (off + i);\r\nelse\r\nval &= ~(1 << (off + i));\r\npara = para >> 1;\r\n}\r\nreturn val;\r\n}\r\nstatic int mmc_clk_set_timing(struct clk_hw *hw, unsigned long rate)\r\n{\r\nstruct clk_mmc *mclk = to_mmc(hw);\r\nunsigned long flags;\r\nu32 sam, drv, div, val;\r\nstatic DEFINE_SPINLOCK(mmc_clk_lock);\r\nswitch (rate) {\r\ncase 13000000:\r\nsam = 3;\r\ndrv = 1;\r\ndiv = 1;\r\nbreak;\r\ncase 25000000:\r\nsam = 13;\r\ndrv = 6;\r\ndiv = 6;\r\nbreak;\r\ncase 50000000:\r\nsam = 3;\r\ndrv = 6;\r\ndiv = 6;\r\nbreak;\r\ncase 100000000:\r\nsam = 6;\r\ndrv = 4;\r\ndiv = 6;\r\nbreak;\r\ncase 180000000:\r\nsam = 6;\r\ndrv = 4;\r\ndiv = 7;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&mmc_clk_lock, flags);\r\nval = readl_relaxed(mclk->clken_reg);\r\nval &= ~(1 << mclk->clken_bit);\r\nwritel_relaxed(val, mclk->clken_reg);\r\nval = readl_relaxed(mclk->sam_reg);\r\nval = mmc_clk_delay(val, sam, mclk->sam_off, mclk->sam_bits);\r\nwritel_relaxed(val, mclk->sam_reg);\r\nval = readl_relaxed(mclk->drv_reg);\r\nval = mmc_clk_delay(val, drv, mclk->drv_off, mclk->drv_bits);\r\nwritel_relaxed(val, mclk->drv_reg);\r\nval = readl_relaxed(mclk->div_reg);\r\nval = mmc_clk_delay(val, div, mclk->div_off, mclk->div_bits);\r\nwritel_relaxed(val, mclk->div_reg);\r\nval = readl_relaxed(mclk->clken_reg);\r\nval |= 1 << mclk->clken_bit;\r\nwritel_relaxed(val, mclk->clken_reg);\r\nspin_unlock_irqrestore(&mmc_clk_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int mmc_clk_prepare(struct clk_hw *hw)\r\n{\r\nstruct clk_mmc *mclk = to_mmc(hw);\r\nunsigned long rate;\r\nif (mclk->id == HI3620_MMC_CIUCLK1)\r\nrate = 13000000;\r\nelse\r\nrate = 25000000;\r\nreturn mmc_clk_set_timing(hw, rate);\r\n}\r\nstatic int mmc_clk_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nreturn mmc_clk_set_timing(hw, rate);\r\n}\r\nstatic struct clk *hisi_register_clk_mmc(struct hisi_mmc_clock *mmc_clk,\r\nvoid __iomem *base, struct device_node *np)\r\n{\r\nstruct clk_mmc *mclk;\r\nstruct clk *clk;\r\nstruct clk_init_data init;\r\nmclk = kzalloc(sizeof(*mclk), GFP_KERNEL);\r\nif (!mclk)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = mmc_clk->name;\r\ninit.ops = &clk_mmc_ops;\r\ninit.flags = mmc_clk->flags | CLK_IS_BASIC;\r\ninit.parent_names = (mmc_clk->parent_name ? &mmc_clk->parent_name : NULL);\r\ninit.num_parents = (mmc_clk->parent_name ? 1 : 0);\r\nmclk->hw.init = &init;\r\nmclk->id = mmc_clk->id;\r\nmclk->clken_reg = base + mmc_clk->clken_reg;\r\nmclk->clken_bit = mmc_clk->clken_bit;\r\nmclk->div_reg = base + mmc_clk->div_reg;\r\nmclk->div_off = mmc_clk->div_off;\r\nmclk->div_bits = mmc_clk->div_bits;\r\nmclk->drv_reg = base + mmc_clk->drv_reg;\r\nmclk->drv_off = mmc_clk->drv_off;\r\nmclk->drv_bits = mmc_clk->drv_bits;\r\nmclk->sam_reg = base + mmc_clk->sam_reg;\r\nmclk->sam_off = mmc_clk->sam_off;\r\nmclk->sam_bits = mmc_clk->sam_bits;\r\nclk = clk_register(NULL, &mclk->hw);\r\nif (WARN_ON(IS_ERR(clk)))\r\nkfree(mclk);\r\nreturn clk;\r\n}\r\nstatic void __init hi3620_mmc_clk_init(struct device_node *node)\r\n{\r\nvoid __iomem *base;\r\nint i, num = ARRAY_SIZE(hi3620_mmc_clks);\r\nstruct clk_onecell_data *clk_data;\r\nif (!node) {\r\npr_err("failed to find pctrl node in DTS\n");\r\nreturn;\r\n}\r\nbase = of_iomap(node, 0);\r\nif (!base) {\r\npr_err("failed to map pctrl\n");\r\nreturn;\r\n}\r\nclk_data = kzalloc(sizeof(*clk_data), GFP_KERNEL);\r\nif (WARN_ON(!clk_data))\r\nreturn;\r\nclk_data->clks = kcalloc(num, sizeof(*clk_data->clks), GFP_KERNEL);\r\nif (!clk_data->clks)\r\nreturn;\r\nfor (i = 0; i < num; i++) {\r\nstruct hisi_mmc_clock *mmc_clk = &hi3620_mmc_clks[i];\r\nclk_data->clks[mmc_clk->id] =\r\nhisi_register_clk_mmc(mmc_clk, base, node);\r\n}\r\nclk_data->clk_num = num;\r\nof_clk_add_provider(node, of_clk_src_onecell_get, clk_data);\r\n}
