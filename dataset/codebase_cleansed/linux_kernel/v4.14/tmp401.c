static int tmp401_register_to_temp(u16 reg, u8 config)\r\n{\r\nint temp = reg;\r\nif (config & TMP401_CONFIG_RANGE)\r\ntemp -= 64 * 256;\r\nreturn DIV_ROUND_CLOSEST(temp * 125, 32);\r\n}\r\nstatic u16 tmp401_temp_to_register(long temp, u8 config, int zbits)\r\n{\r\nif (config & TMP401_CONFIG_RANGE) {\r\ntemp = clamp_val(temp, -64000, 191000);\r\ntemp += 64000;\r\n} else\r\ntemp = clamp_val(temp, 0, 127000);\r\nreturn DIV_ROUND_CLOSEST(temp * (1 << (8 - zbits)), 1000) << zbits;\r\n}\r\nstatic int tmp401_update_device_reg16(struct i2c_client *client,\r\nstruct tmp401_data *data)\r\n{\r\nint i, j, val;\r\nint num_regs = data->kind == tmp411 ? 6 : 4;\r\nint num_sensors = data->kind == tmp432 ? 3 : 2;\r\nfor (i = 0; i < num_sensors; i++) {\r\nfor (j = 0; j < num_regs; j++) {\r\nu8 regaddr;\r\nregaddr = data->kind == tmp432 ?\r\nTMP432_TEMP_MSB_READ[j][i] :\r\nTMP401_TEMP_MSB_READ[j][i];\r\nif (j == 3) {\r\nval = i2c_smbus_read_byte_data(client, regaddr);\r\n} else {\r\nval = i2c_smbus_read_word_swapped(client,\r\nregaddr);\r\n}\r\nif (val < 0)\r\nreturn val;\r\ndata->temp[j][i] = j == 3 ? val << 8 : val;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic struct tmp401_data *tmp401_update_device(struct device *dev)\r\n{\r\nstruct tmp401_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nstruct tmp401_data *ret = data;\r\nint i, val;\r\nunsigned long next_update;\r\nmutex_lock(&data->update_lock);\r\nnext_update = data->last_updated +\r\nmsecs_to_jiffies(data->update_interval);\r\nif (time_after(jiffies, next_update) || !data->valid) {\r\nif (data->kind != tmp432) {\r\nval = i2c_smbus_read_byte_data(client, TMP401_STATUS);\r\nif (val < 0) {\r\nret = ERR_PTR(val);\r\ngoto abort;\r\n}\r\ndata->status[0] =\r\n(val & TMP401_STATUS_REMOTE_OPEN) >> 1;\r\ndata->status[1] =\r\n((val & TMP401_STATUS_REMOTE_LOW) >> 2) |\r\n((val & TMP401_STATUS_LOCAL_LOW) >> 5);\r\ndata->status[2] =\r\n((val & TMP401_STATUS_REMOTE_HIGH) >> 3) |\r\n((val & TMP401_STATUS_LOCAL_HIGH) >> 6);\r\ndata->status[3] = val & (TMP401_STATUS_LOCAL_CRIT\r\n| TMP401_STATUS_REMOTE_CRIT);\r\n} else {\r\nfor (i = 0; i < ARRAY_SIZE(data->status); i++) {\r\nval = i2c_smbus_read_byte_data(client,\r\nTMP432_STATUS_REG[i]);\r\nif (val < 0) {\r\nret = ERR_PTR(val);\r\ngoto abort;\r\n}\r\ndata->status[i] = val;\r\n}\r\n}\r\nval = i2c_smbus_read_byte_data(client, TMP401_CONFIG_READ);\r\nif (val < 0) {\r\nret = ERR_PTR(val);\r\ngoto abort;\r\n}\r\ndata->config = val;\r\nval = tmp401_update_device_reg16(client, data);\r\nif (val < 0) {\r\nret = ERR_PTR(val);\r\ngoto abort;\r\n}\r\nval = i2c_smbus_read_byte_data(client, TMP401_TEMP_CRIT_HYST);\r\nif (val < 0) {\r\nret = ERR_PTR(val);\r\ngoto abort;\r\n}\r\ndata->temp_crit_hyst = val;\r\ndata->last_updated = jiffies;\r\ndata->valid = 1;\r\n}\r\nabort:\r\nmutex_unlock(&data->update_lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t show_temp(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nint nr = to_sensor_dev_attr_2(devattr)->nr;\r\nint index = to_sensor_dev_attr_2(devattr)->index;\r\nstruct tmp401_data *data = tmp401_update_device(dev);\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nreturn sprintf(buf, "%d\n",\r\ntmp401_register_to_temp(data->temp[nr][index], data->config));\r\n}\r\nstatic ssize_t show_temp_crit_hyst(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nint temp, index = to_sensor_dev_attr(devattr)->index;\r\nstruct tmp401_data *data = tmp401_update_device(dev);\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nmutex_lock(&data->update_lock);\r\ntemp = tmp401_register_to_temp(data->temp[3][index], data->config);\r\ntemp -= data->temp_crit_hyst * 1000;\r\nmutex_unlock(&data->update_lock);\r\nreturn sprintf(buf, "%d\n", temp);\r\n}\r\nstatic ssize_t show_status(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nint nr = to_sensor_dev_attr_2(devattr)->nr;\r\nint mask = to_sensor_dev_attr_2(devattr)->index;\r\nstruct tmp401_data *data = tmp401_update_device(dev);\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nreturn sprintf(buf, "%d\n", !!(data->status[nr] & mask));\r\n}\r\nstatic ssize_t store_temp(struct device *dev, struct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr_2(devattr)->nr;\r\nint index = to_sensor_dev_attr_2(devattr)->index;\r\nstruct tmp401_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nlong val;\r\nu16 reg;\r\nu8 regaddr;\r\nif (kstrtol(buf, 10, &val))\r\nreturn -EINVAL;\r\nreg = tmp401_temp_to_register(val, data->config, nr == 3 ? 8 : 4);\r\nmutex_lock(&data->update_lock);\r\nregaddr = data->kind == tmp432 ? TMP432_TEMP_MSB_WRITE[nr][index]\r\n: TMP401_TEMP_MSB_WRITE[nr][index];\r\nif (nr == 3) {\r\ni2c_smbus_write_byte_data(client, regaddr, reg >> 8);\r\n} else {\r\ni2c_smbus_write_word_swapped(client, regaddr, reg);\r\n}\r\ndata->temp[nr][index] = reg;\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t store_temp_crit_hyst(struct device *dev, struct device_attribute\r\n*devattr, const char *buf, size_t count)\r\n{\r\nint temp, index = to_sensor_dev_attr(devattr)->index;\r\nstruct tmp401_data *data = tmp401_update_device(dev);\r\nlong val;\r\nu8 reg;\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nif (kstrtol(buf, 10, &val))\r\nreturn -EINVAL;\r\nif (data->config & TMP401_CONFIG_RANGE)\r\nval = clamp_val(val, -64000, 191000);\r\nelse\r\nval = clamp_val(val, 0, 127000);\r\nmutex_lock(&data->update_lock);\r\ntemp = tmp401_register_to_temp(data->temp[3][index], data->config);\r\nval = clamp_val(val, temp - 255000, temp);\r\nreg = ((temp - val) + 500) / 1000;\r\ni2c_smbus_write_byte_data(data->client, TMP401_TEMP_CRIT_HYST,\r\nreg);\r\ndata->temp_crit_hyst = reg;\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t reset_temp_history(struct device *dev,\r\nstruct device_attribute *devattr, const char *buf, size_t count)\r\n{\r\nstruct tmp401_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nlong val;\r\nif (kstrtol(buf, 10, &val))\r\nreturn -EINVAL;\r\nif (val != 1) {\r\ndev_err(dev,\r\n"temp_reset_history value %ld not supported. Use 1 to reset the history!\n",\r\nval);\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&data->update_lock);\r\ni2c_smbus_write_byte_data(client, TMP401_TEMP_MSB_WRITE[5][0], val);\r\ndata->valid = 0;\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t update_interval_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct tmp401_data *data = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%u\n", data->update_interval);\r\n}\r\nstatic ssize_t update_interval_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct tmp401_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nunsigned long val;\r\nint err, rate;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nval = clamp_val(val, 125, 16000);\r\nrate = 7 - __fls(val * 4 / (125 * 3));\r\nmutex_lock(&data->update_lock);\r\ni2c_smbus_write_byte_data(client, TMP401_CONVERSION_RATE_WRITE, rate);\r\ndata->update_interval = (1 << (7 - rate)) * 125;\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic int tmp401_init_client(struct tmp401_data *data,\r\nstruct i2c_client *client)\r\n{\r\nint config, config_orig, status = 0;\r\ni2c_smbus_write_byte_data(client, TMP401_CONVERSION_RATE_WRITE, 5);\r\ndata->update_interval = 500;\r\nconfig = i2c_smbus_read_byte_data(client, TMP401_CONFIG_READ);\r\nif (config < 0)\r\nreturn config;\r\nconfig_orig = config;\r\nconfig &= ~TMP401_CONFIG_SHUTDOWN;\r\nif (config != config_orig)\r\nstatus = i2c_smbus_write_byte_data(client,\r\nTMP401_CONFIG_WRITE,\r\nconfig);\r\nreturn status;\r\n}\r\nstatic int tmp401_detect(struct i2c_client *client,\r\nstruct i2c_board_info *info)\r\n{\r\nenum chips kind;\r\nstruct i2c_adapter *adapter = client->adapter;\r\nu8 reg;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -ENODEV;\r\nreg = i2c_smbus_read_byte_data(client, TMP401_MANUFACTURER_ID_REG);\r\nif (reg != TMP401_MANUFACTURER_ID)\r\nreturn -ENODEV;\r\nreg = i2c_smbus_read_byte_data(client, TMP401_DEVICE_ID_REG);\r\nswitch (reg) {\r\ncase TMP401_DEVICE_ID:\r\nif (client->addr != 0x4c)\r\nreturn -ENODEV;\r\nkind = tmp401;\r\nbreak;\r\ncase TMP411A_DEVICE_ID:\r\nif (client->addr != 0x4c)\r\nreturn -ENODEV;\r\nkind = tmp411;\r\nbreak;\r\ncase TMP411B_DEVICE_ID:\r\nif (client->addr != 0x4d)\r\nreturn -ENODEV;\r\nkind = tmp411;\r\nbreak;\r\ncase TMP411C_DEVICE_ID:\r\nif (client->addr != 0x4e)\r\nreturn -ENODEV;\r\nkind = tmp411;\r\nbreak;\r\ncase TMP431_DEVICE_ID:\r\nif (client->addr != 0x4c && client->addr != 0x4d)\r\nreturn -ENODEV;\r\nkind = tmp431;\r\nbreak;\r\ncase TMP432_DEVICE_ID:\r\nif (client->addr != 0x4c && client->addr != 0x4d)\r\nreturn -ENODEV;\r\nkind = tmp432;\r\nbreak;\r\ncase TMP435_DEVICE_ID:\r\nkind = tmp435;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nreg = i2c_smbus_read_byte_data(client, TMP401_CONFIG_READ);\r\nif (reg & 0x1b)\r\nreturn -ENODEV;\r\nreg = i2c_smbus_read_byte_data(client, TMP401_CONVERSION_RATE_READ);\r\nif (reg > 15)\r\nreturn -ENODEV;\r\nstrlcpy(info->type, tmp401_id[kind].name, I2C_NAME_SIZE);\r\nreturn 0;\r\n}\r\nstatic int tmp401_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstatic const char * const names[] = {\r\n"TMP401", "TMP411", "TMP431", "TMP432", "TMP435", "TMP461"\r\n};\r\nstruct device *dev = &client->dev;\r\nstruct device *hwmon_dev;\r\nstruct tmp401_data *data;\r\nint groups = 0, status;\r\ndata = devm_kzalloc(dev, sizeof(struct tmp401_data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->client = client;\r\nmutex_init(&data->update_lock);\r\ndata->kind = id->driver_data;\r\nstatus = tmp401_init_client(data, client);\r\nif (status < 0)\r\nreturn status;\r\ndata->groups[groups++] = &tmp401_group;\r\nif (data->kind == tmp411)\r\ndata->groups[groups++] = &tmp411_group;\r\nif (data->kind == tmp432)\r\ndata->groups[groups++] = &tmp432_group;\r\nif (data->kind == tmp461)\r\ndata->groups[groups++] = &tmp461_group;\r\nhwmon_dev = devm_hwmon_device_register_with_groups(dev, client->name,\r\ndata, data->groups);\r\nif (IS_ERR(hwmon_dev))\r\nreturn PTR_ERR(hwmon_dev);\r\ndev_info(dev, "Detected TI %s chip\n", names[data->kind]);\r\nreturn 0;\r\n}
