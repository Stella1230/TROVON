static inline int tusb_omap_use_shared_dmareq(struct tusb_omap_dma_ch *chdat)\r\n{\r\nu32 reg = musb_readl(chdat->tbase, TUSB_DMA_EP_MAP);\r\nif (reg != 0) {\r\ndev_dbg(chdat->musb->controller, "ep%i dmareq0 is busy for ep%i\n",\r\nchdat->epnum, reg & 0xf);\r\nreturn -EAGAIN;\r\n}\r\nif (chdat->tx)\r\nreg = (1 << 4) | chdat->epnum;\r\nelse\r\nreg = chdat->epnum;\r\nmusb_writel(chdat->tbase, TUSB_DMA_EP_MAP, reg);\r\nreturn 0;\r\n}\r\nstatic inline void tusb_omap_free_shared_dmareq(struct tusb_omap_dma_ch *chdat)\r\n{\r\nu32 reg = musb_readl(chdat->tbase, TUSB_DMA_EP_MAP);\r\nif ((reg & 0xf) != chdat->epnum) {\r\nprintk(KERN_ERR "ep%i trying to release dmareq0 for ep%i\n",\r\nchdat->epnum, reg & 0xf);\r\nreturn;\r\n}\r\nmusb_writel(chdat->tbase, TUSB_DMA_EP_MAP, 0);\r\n}\r\nstatic void tusb_omap_dma_cb(void *data)\r\n{\r\nstruct dma_channel *channel = (struct dma_channel *)data;\r\nstruct tusb_omap_dma_ch *chdat = to_chdat(channel);\r\nstruct tusb_omap_dma *tusb_dma = chdat->tusb_dma;\r\nstruct musb *musb = chdat->musb;\r\nstruct device *dev = musb->controller;\r\nstruct musb_hw_ep *hw_ep = chdat->hw_ep;\r\nvoid __iomem *ep_conf = hw_ep->conf;\r\nvoid __iomem *mbase = musb->mregs;\r\nunsigned long remaining, flags, pio;\r\nspin_lock_irqsave(&musb->lock, flags);\r\ndev_dbg(musb->controller, "ep%i %s dma callback\n",\r\nchdat->epnum, chdat->tx ? "tx" : "rx");\r\nif (chdat->tx)\r\nremaining = musb_readl(ep_conf, TUSB_EP_TX_OFFSET);\r\nelse\r\nremaining = musb_readl(ep_conf, TUSB_EP_RX_OFFSET);\r\nremaining = TUSB_EP_CONFIG_XFR_SIZE(remaining);\r\nif (unlikely(remaining > chdat->transfer_len)) {\r\ndev_dbg(musb->controller, "Corrupt %s XFR_SIZE: 0x%08lx\n",\r\nchdat->tx ? "tx" : "rx", remaining);\r\nremaining = 0;\r\n}\r\nchannel->actual_len = chdat->transfer_len - remaining;\r\npio = chdat->len - channel->actual_len;\r\ndev_dbg(musb->controller, "DMA remaining %lu/%u\n", remaining, chdat->transfer_len);\r\nif (pio > 0 && pio < 32) {\r\nu8 *buf;\r\ndev_dbg(musb->controller, "Using PIO for remaining %lu bytes\n", pio);\r\nbuf = phys_to_virt((u32)chdat->dma_addr) + chdat->transfer_len;\r\nif (chdat->tx) {\r\ndma_unmap_single(dev, chdat->dma_addr,\r\nchdat->transfer_len,\r\nDMA_TO_DEVICE);\r\nmusb_write_fifo(hw_ep, pio, buf);\r\n} else {\r\ndma_unmap_single(dev, chdat->dma_addr,\r\nchdat->transfer_len,\r\nDMA_FROM_DEVICE);\r\nmusb_read_fifo(hw_ep, pio, buf);\r\n}\r\nchannel->actual_len += pio;\r\n}\r\nif (!tusb_dma->multichannel)\r\ntusb_omap_free_shared_dmareq(chdat);\r\nchannel->status = MUSB_DMA_STATUS_FREE;\r\nmusb_dma_completion(musb, chdat->epnum, chdat->tx);\r\nif ((chdat->transfer_len < chdat->packet_sz)\r\n|| (chdat->transfer_len % chdat->packet_sz != 0)) {\r\nu16 csr;\r\nif (chdat->tx) {\r\ndev_dbg(musb->controller, "terminating short tx packet\n");\r\nmusb_ep_select(mbase, chdat->epnum);\r\ncsr = musb_readw(hw_ep->regs, MUSB_TXCSR);\r\ncsr |= MUSB_TXCSR_MODE | MUSB_TXCSR_TXPKTRDY\r\n| MUSB_TXCSR_P_WZC_BITS;\r\nmusb_writew(hw_ep->regs, MUSB_TXCSR, csr);\r\n}\r\n}\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\n}\r\nstatic int tusb_omap_dma_program(struct dma_channel *channel, u16 packet_sz,\r\nu8 rndis_mode, dma_addr_t dma_addr, u32 len)\r\n{\r\nstruct tusb_omap_dma_ch *chdat = to_chdat(channel);\r\nstruct tusb_omap_dma *tusb_dma = chdat->tusb_dma;\r\nstruct musb *musb = chdat->musb;\r\nstruct device *dev = musb->controller;\r\nstruct musb_hw_ep *hw_ep = chdat->hw_ep;\r\nvoid __iomem *mbase = musb->mregs;\r\nvoid __iomem *ep_conf = hw_ep->conf;\r\ndma_addr_t fifo_addr = hw_ep->fifo_sync;\r\nu32 dma_remaining;\r\nu16 csr;\r\nu32 psize;\r\nstruct tusb_dma_data *dma_data;\r\nstruct dma_async_tx_descriptor *dma_desc;\r\nstruct dma_slave_config dma_cfg;\r\nenum dma_transfer_direction dma_dir;\r\nu32 port_window;\r\nint ret;\r\nif (unlikely(dma_addr & 0x1) || (len < 32) || (len > packet_sz))\r\nreturn false;\r\nif (dma_addr & 0x2)\r\nreturn false;\r\nif (chdat->tx)\r\ndma_remaining = musb_readl(ep_conf, TUSB_EP_TX_OFFSET);\r\nelse\r\ndma_remaining = musb_readl(ep_conf, TUSB_EP_RX_OFFSET);\r\ndma_remaining = TUSB_EP_CONFIG_XFR_SIZE(dma_remaining);\r\nif (dma_remaining) {\r\ndev_dbg(musb->controller, "Busy %s dma, not using: %08x\n",\r\nchdat->tx ? "tx" : "rx", dma_remaining);\r\nreturn false;\r\n}\r\nchdat->transfer_len = len & ~0x1f;\r\nif (len < packet_sz)\r\nchdat->transfer_packet_sz = chdat->transfer_len;\r\nelse\r\nchdat->transfer_packet_sz = packet_sz;\r\ndma_data = chdat->dma_data;\r\nif (!tusb_dma->multichannel) {\r\nif (tusb_omap_use_shared_dmareq(chdat) != 0) {\r\ndev_dbg(musb->controller, "could not get dma for ep%i\n", chdat->epnum);\r\nreturn false;\r\n}\r\nif (dma_data->dmareq < 0) {\r\nWARN_ON(1);\r\nreturn false;\r\n}\r\n}\r\nchdat->packet_sz = packet_sz;\r\nchdat->len = len;\r\nchannel->actual_len = 0;\r\nchdat->dma_addr = dma_addr;\r\nchannel->status = MUSB_DMA_STATUS_BUSY;\r\nif (chdat->tx) {\r\ndma_dir = DMA_MEM_TO_DEV;\r\ndma_map_single(dev, phys_to_virt(dma_addr), len,\r\nDMA_TO_DEVICE);\r\n} else {\r\ndma_dir = DMA_DEV_TO_MEM;\r\ndma_map_single(dev, phys_to_virt(dma_addr), len,\r\nDMA_FROM_DEVICE);\r\n}\r\nmemset(&dma_cfg, 0, sizeof(dma_cfg));\r\nif ((dma_addr & 0x3) == 0) {\r\ndma_cfg.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\ndma_cfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\nport_window = 8;\r\n} else {\r\ndma_cfg.src_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;\r\ndma_cfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;\r\nport_window = 16;\r\nfifo_addr = hw_ep->fifo_async;\r\n}\r\ndev_dbg(musb->controller,\r\n"ep%i %s dma: %pad len: %u(%u) packet_sz: %i(%i)\n",\r\nchdat->epnum, chdat->tx ? "tx" : "rx", &dma_addr,\r\nchdat->transfer_len, len, chdat->transfer_packet_sz, packet_sz);\r\ndma_cfg.src_addr = fifo_addr;\r\ndma_cfg.dst_addr = fifo_addr;\r\ndma_cfg.src_port_window_size = port_window;\r\ndma_cfg.src_maxburst = port_window;\r\ndma_cfg.dst_port_window_size = port_window;\r\ndma_cfg.dst_maxburst = port_window;\r\nret = dmaengine_slave_config(dma_data->chan, &dma_cfg);\r\nif (ret) {\r\ndev_err(musb->controller, "DMA slave config failed: %d\n", ret);\r\nreturn false;\r\n}\r\ndma_desc = dmaengine_prep_slave_single(dma_data->chan, dma_addr,\r\nchdat->transfer_len, dma_dir,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!dma_desc) {\r\ndev_err(musb->controller, "DMA prep_slave_single failed\n");\r\nreturn false;\r\n}\r\ndma_desc->callback = tusb_omap_dma_cb;\r\ndma_desc->callback_param = channel;\r\ndmaengine_submit(dma_desc);\r\ndev_dbg(musb->controller,\r\n"ep%i %s using %i-bit %s dma from %pad to %pad\n",\r\nchdat->epnum, chdat->tx ? "tx" : "rx",\r\ndma_cfg.src_addr_width * 8,\r\n((dma_addr & 0x3) == 0) ? "sync" : "async",\r\n(dma_dir == DMA_MEM_TO_DEV) ? &dma_addr : &fifo_addr,\r\n(dma_dir == DMA_MEM_TO_DEV) ? &fifo_addr : &dma_addr);\r\nmusb_ep_select(mbase, chdat->epnum);\r\nif (chdat->tx) {\r\ncsr = musb_readw(hw_ep->regs, MUSB_TXCSR);\r\ncsr |= (MUSB_TXCSR_AUTOSET | MUSB_TXCSR_DMAENAB\r\n| MUSB_TXCSR_DMAMODE | MUSB_TXCSR_MODE);\r\ncsr &= ~MUSB_TXCSR_P_UNDERRUN;\r\nmusb_writew(hw_ep->regs, MUSB_TXCSR, csr);\r\n} else {\r\ncsr = musb_readw(hw_ep->regs, MUSB_RXCSR);\r\ncsr |= MUSB_RXCSR_DMAENAB;\r\ncsr &= ~(MUSB_RXCSR_AUTOCLEAR | MUSB_RXCSR_DMAMODE);\r\nmusb_writew(hw_ep->regs, MUSB_RXCSR,\r\ncsr | MUSB_RXCSR_P_WZC_BITS);\r\n}\r\ndma_async_issue_pending(dma_data->chan);\r\nif (chdat->tx) {\r\npsize = musb_readl(ep_conf, TUSB_EP_MAX_PACKET_SIZE_OFFSET);\r\npsize &= ~0x7ff;\r\npsize |= chdat->transfer_packet_sz;\r\nmusb_writel(ep_conf, TUSB_EP_MAX_PACKET_SIZE_OFFSET, psize);\r\nmusb_writel(ep_conf, TUSB_EP_TX_OFFSET,\r\nTUSB_EP_CONFIG_XFR_SIZE(chdat->transfer_len));\r\n} else {\r\npsize = musb_readl(ep_conf, TUSB_EP_MAX_PACKET_SIZE_OFFSET);\r\npsize &= ~(0x7ff << 16);\r\npsize |= (chdat->transfer_packet_sz << 16);\r\nmusb_writel(ep_conf, TUSB_EP_MAX_PACKET_SIZE_OFFSET, psize);\r\nmusb_writel(ep_conf, TUSB_EP_RX_OFFSET,\r\nTUSB_EP_CONFIG_XFR_SIZE(chdat->transfer_len));\r\n}\r\nreturn true;\r\n}\r\nstatic int tusb_omap_dma_abort(struct dma_channel *channel)\r\n{\r\nstruct tusb_omap_dma_ch *chdat = to_chdat(channel);\r\nif (chdat->dma_data)\r\ndmaengine_terminate_all(chdat->dma_data->chan);\r\nchannel->status = MUSB_DMA_STATUS_FREE;\r\nreturn 0;\r\n}\r\nstatic inline int tusb_omap_dma_allocate_dmareq(struct tusb_omap_dma_ch *chdat)\r\n{\r\nu32 reg = musb_readl(chdat->tbase, TUSB_DMA_EP_MAP);\r\nint i, dmareq_nr = -1;\r\nfor (i = 0; i < MAX_DMAREQ; i++) {\r\nint cur = (reg & (0xf << (i * 5))) >> (i * 5);\r\nif (cur == 0) {\r\ndmareq_nr = i;\r\nbreak;\r\n}\r\n}\r\nif (dmareq_nr == -1)\r\nreturn -EAGAIN;\r\nreg |= (chdat->epnum << (dmareq_nr * 5));\r\nif (chdat->tx)\r\nreg |= ((1 << 4) << (dmareq_nr * 5));\r\nmusb_writel(chdat->tbase, TUSB_DMA_EP_MAP, reg);\r\nchdat->dma_data = &chdat->tusb_dma->dma_pool[dmareq_nr];\r\nreturn 0;\r\n}\r\nstatic inline void tusb_omap_dma_free_dmareq(struct tusb_omap_dma_ch *chdat)\r\n{\r\nu32 reg;\r\nif (!chdat || !chdat->dma_data || chdat->dma_data->dmareq < 0)\r\nreturn;\r\nreg = musb_readl(chdat->tbase, TUSB_DMA_EP_MAP);\r\nreg &= ~(0x1f << (chdat->dma_data->dmareq * 5));\r\nmusb_writel(chdat->tbase, TUSB_DMA_EP_MAP, reg);\r\nchdat->dma_data = NULL;\r\n}\r\nstatic struct dma_channel *\r\ntusb_omap_dma_allocate(struct dma_controller *c,\r\nstruct musb_hw_ep *hw_ep,\r\nu8 tx)\r\n{\r\nint ret, i;\r\nstruct tusb_omap_dma *tusb_dma;\r\nstruct musb *musb;\r\nstruct dma_channel *channel = NULL;\r\nstruct tusb_omap_dma_ch *chdat = NULL;\r\nstruct tusb_dma_data *dma_data = NULL;\r\ntusb_dma = container_of(c, struct tusb_omap_dma, controller);\r\nmusb = tusb_dma->controller.musb;\r\nif (hw_ep->epnum == 0) {\r\ndev_dbg(musb->controller, "Not allowing DMA for ep0 %s\n", tx ? "tx" : "rx");\r\nreturn NULL;\r\n}\r\nfor (i = 0; i < MAX_DMAREQ; i++) {\r\nstruct dma_channel *ch = dma_channel_pool[i];\r\nif (ch->status == MUSB_DMA_STATUS_UNKNOWN) {\r\nch->status = MUSB_DMA_STATUS_FREE;\r\nchannel = ch;\r\nchdat = ch->private_data;\r\nbreak;\r\n}\r\n}\r\nif (!channel)\r\nreturn NULL;\r\nchdat->musb = tusb_dma->controller.musb;\r\nchdat->tbase = tusb_dma->tbase;\r\nchdat->hw_ep = hw_ep;\r\nchdat->epnum = hw_ep->epnum;\r\nchdat->completed_len = 0;\r\nchdat->tusb_dma = tusb_dma;\r\nif (tx)\r\nchdat->tx = 1;\r\nelse\r\nchdat->tx = 0;\r\nchannel->max_len = 0x7fffffff;\r\nchannel->desired_mode = 0;\r\nchannel->actual_len = 0;\r\nif (!chdat->dma_data) {\r\nif (tusb_dma->multichannel) {\r\nret = tusb_omap_dma_allocate_dmareq(chdat);\r\nif (ret != 0)\r\ngoto free_dmareq;\r\n} else {\r\nchdat->dma_data = &tusb_dma->dma_pool[0];\r\n}\r\n}\r\ndma_data = chdat->dma_data;\r\ndev_dbg(musb->controller, "ep%i %s dma: %s dmareq%i\n",\r\nchdat->epnum,\r\nchdat->tx ? "tx" : "rx",\r\ntusb_dma->multichannel ? "shared" : "dedicated",\r\ndma_data->dmareq);\r\nreturn channel;\r\nfree_dmareq:\r\ntusb_omap_dma_free_dmareq(chdat);\r\ndev_dbg(musb->controller, "ep%i: Could not get a DMA channel\n", chdat->epnum);\r\nchannel->status = MUSB_DMA_STATUS_UNKNOWN;\r\nreturn NULL;\r\n}\r\nstatic void tusb_omap_dma_release(struct dma_channel *channel)\r\n{\r\nstruct tusb_omap_dma_ch *chdat = to_chdat(channel);\r\nstruct musb *musb = chdat->musb;\r\ndev_dbg(musb->controller, "Release for ep%i\n", chdat->epnum);\r\nchannel->status = MUSB_DMA_STATUS_UNKNOWN;\r\ndmaengine_terminate_sync(chdat->dma_data->chan);\r\ntusb_omap_dma_free_dmareq(chdat);\r\nchannel = NULL;\r\n}\r\nvoid tusb_dma_controller_destroy(struct dma_controller *c)\r\n{\r\nstruct tusb_omap_dma *tusb_dma;\r\nint i;\r\ntusb_dma = container_of(c, struct tusb_omap_dma, controller);\r\nfor (i = 0; i < MAX_DMAREQ; i++) {\r\nstruct dma_channel *ch = dma_channel_pool[i];\r\nif (ch) {\r\nkfree(ch->private_data);\r\nkfree(ch);\r\n}\r\nif (tusb_dma && tusb_dma->dma_pool[i].chan)\r\ndma_release_channel(tusb_dma->dma_pool[i].chan);\r\n}\r\nkfree(tusb_dma);\r\n}\r\nstatic int tusb_omap_allocate_dma_pool(struct tusb_omap_dma *tusb_dma)\r\n{\r\nstruct musb *musb = tusb_dma->controller.musb;\r\nint i;\r\nint ret = 0;\r\nfor (i = 0; i < MAX_DMAREQ; i++) {\r\nstruct tusb_dma_data *dma_data = &tusb_dma->dma_pool[i];\r\nif (i == 0 || tusb_dma->multichannel) {\r\nchar ch_name[8];\r\nsprintf(ch_name, "dmareq%d", i);\r\ndma_data->chan = dma_request_chan(musb->controller,\r\nch_name);\r\nif (IS_ERR(dma_data->chan)) {\r\ndev_err(musb->controller,\r\n"Failed to request %s\n", ch_name);\r\nret = PTR_ERR(dma_data->chan);\r\ngoto dma_error;\r\n}\r\ndma_data->dmareq = i;\r\n} else {\r\ndma_data->dmareq = -1;\r\n}\r\n}\r\nreturn 0;\r\ndma_error:\r\nfor (; i >= 0; i--) {\r\nstruct tusb_dma_data *dma_data = &tusb_dma->dma_pool[i];\r\nif (dma_data->dmareq >= 0)\r\ndma_release_channel(dma_data->chan);\r\n}\r\nreturn ret;\r\n}\r\nstruct dma_controller *\r\ntusb_dma_controller_create(struct musb *musb, void __iomem *base)\r\n{\r\nvoid __iomem *tbase = musb->ctrl_base;\r\nstruct tusb_omap_dma *tusb_dma;\r\nint i;\r\nmusb_writel(musb->ctrl_base, TUSB_DMA_INT_MASK, 0x7fffffff);\r\nmusb_writel(musb->ctrl_base, TUSB_DMA_EP_MAP, 0);\r\nmusb_writel(tbase, TUSB_DMA_REQ_CONF,\r\nTUSB_DMA_REQ_CONF_BURST_SIZE(2)\r\n| TUSB_DMA_REQ_CONF_DMA_REQ_EN(0x3f)\r\n| TUSB_DMA_REQ_CONF_DMA_REQ_ASSER(2));\r\ntusb_dma = kzalloc(sizeof(struct tusb_omap_dma), GFP_KERNEL);\r\nif (!tusb_dma)\r\ngoto out;\r\ntusb_dma->controller.musb = musb;\r\ntusb_dma->tbase = musb->ctrl_base;\r\ntusb_dma->controller.channel_alloc = tusb_omap_dma_allocate;\r\ntusb_dma->controller.channel_release = tusb_omap_dma_release;\r\ntusb_dma->controller.channel_program = tusb_omap_dma_program;\r\ntusb_dma->controller.channel_abort = tusb_omap_dma_abort;\r\nif (musb->tusb_revision >= TUSB_REV_30)\r\ntusb_dma->multichannel = 1;\r\nfor (i = 0; i < MAX_DMAREQ; i++) {\r\nstruct dma_channel *ch;\r\nstruct tusb_omap_dma_ch *chdat;\r\nch = kzalloc(sizeof(struct dma_channel), GFP_KERNEL);\r\nif (!ch)\r\ngoto cleanup;\r\ndma_channel_pool[i] = ch;\r\nchdat = kzalloc(sizeof(struct tusb_omap_dma_ch), GFP_KERNEL);\r\nif (!chdat)\r\ngoto cleanup;\r\nch->status = MUSB_DMA_STATUS_UNKNOWN;\r\nch->private_data = chdat;\r\n}\r\nif (tusb_omap_allocate_dma_pool(tusb_dma))\r\ngoto cleanup;\r\nreturn &tusb_dma->controller;\r\ncleanup:\r\nmusb_dma_controller_destroy(&tusb_dma->controller);\r\nout:\r\nreturn NULL;\r\n}
