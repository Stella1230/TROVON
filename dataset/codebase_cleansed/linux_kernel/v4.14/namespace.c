char *nfs_path(char **p, struct dentry *dentry, char *buffer, ssize_t buflen,\r\nunsigned flags)\r\n{\r\nchar *end;\r\nint namelen;\r\nunsigned seq;\r\nconst char *base;\r\nrename_retry:\r\nend = buffer+buflen;\r\n*--end = '\0';\r\nbuflen--;\r\nseq = read_seqbegin(&rename_lock);\r\nrcu_read_lock();\r\nwhile (1) {\r\nspin_lock(&dentry->d_lock);\r\nif (IS_ROOT(dentry))\r\nbreak;\r\nnamelen = dentry->d_name.len;\r\nbuflen -= namelen + 1;\r\nif (buflen < 0)\r\ngoto Elong_unlock;\r\nend -= namelen;\r\nmemcpy(end, dentry->d_name.name, namelen);\r\n*--end = '/';\r\nspin_unlock(&dentry->d_lock);\r\ndentry = dentry->d_parent;\r\n}\r\nif (read_seqretry(&rename_lock, seq)) {\r\nspin_unlock(&dentry->d_lock);\r\nrcu_read_unlock();\r\ngoto rename_retry;\r\n}\r\nif ((flags & NFS_PATH_CANONICAL) && *end != '/') {\r\nif (--buflen < 0) {\r\nspin_unlock(&dentry->d_lock);\r\nrcu_read_unlock();\r\ngoto Elong;\r\n}\r\n*--end = '/';\r\n}\r\n*p = end;\r\nbase = dentry->d_fsdata;\r\nif (!base) {\r\nspin_unlock(&dentry->d_lock);\r\nrcu_read_unlock();\r\nWARN_ON(1);\r\nreturn end;\r\n}\r\nnamelen = strlen(base);\r\nif (*end == '/') {\r\nwhile (namelen > 0 && base[namelen - 1] == '/')\r\nnamelen--;\r\n}\r\nbuflen -= namelen;\r\nif (buflen < 0) {\r\nspin_unlock(&dentry->d_lock);\r\nrcu_read_unlock();\r\ngoto Elong;\r\n}\r\nend -= namelen;\r\nmemcpy(end, base, namelen);\r\nspin_unlock(&dentry->d_lock);\r\nrcu_read_unlock();\r\nreturn end;\r\nElong_unlock:\r\nspin_unlock(&dentry->d_lock);\r\nrcu_read_unlock();\r\nif (read_seqretry(&rename_lock, seq))\r\ngoto rename_retry;\r\nElong:\r\nreturn ERR_PTR(-ENAMETOOLONG);\r\n}\r\nstruct vfsmount *nfs_d_automount(struct path *path)\r\n{\r\nstruct vfsmount *mnt;\r\nstruct nfs_server *server = NFS_SERVER(d_inode(path->dentry));\r\nstruct nfs_fh *fh = NULL;\r\nstruct nfs_fattr *fattr = NULL;\r\nif (IS_ROOT(path->dentry))\r\nreturn ERR_PTR(-ESTALE);\r\nmnt = ERR_PTR(-ENOMEM);\r\nfh = nfs_alloc_fhandle();\r\nfattr = nfs_alloc_fattr();\r\nif (fh == NULL || fattr == NULL)\r\ngoto out;\r\nmnt = server->nfs_client->rpc_ops->submount(server, path->dentry, fh, fattr);\r\nif (IS_ERR(mnt))\r\ngoto out;\r\nmntget(mnt);\r\nmnt_set_expiry(mnt, &nfs_automount_list);\r\nschedule_delayed_work(&nfs_automount_task, nfs_mountpoint_expiry_timeout);\r\nout:\r\nnfs_free_fattr(fattr);\r\nnfs_free_fhandle(fh);\r\nreturn mnt;\r\n}\r\nstatic int\r\nnfs_namespace_getattr(const struct path *path, struct kstat *stat,\r\nu32 request_mask, unsigned int query_flags)\r\n{\r\nif (NFS_FH(d_inode(path->dentry))->size != 0)\r\nreturn nfs_getattr(path, stat, request_mask, query_flags);\r\ngeneric_fillattr(d_inode(path->dentry), stat);\r\nreturn 0;\r\n}\r\nstatic int\r\nnfs_namespace_setattr(struct dentry *dentry, struct iattr *attr)\r\n{\r\nif (NFS_FH(d_inode(dentry))->size != 0)\r\nreturn nfs_setattr(dentry, attr);\r\nreturn -EACCES;\r\n}\r\nstatic void nfs_expire_automounts(struct work_struct *work)\r\n{\r\nstruct list_head *list = &nfs_automount_list;\r\nmark_mounts_for_expiry(list);\r\nif (!list_empty(list))\r\nschedule_delayed_work(&nfs_automount_task, nfs_mountpoint_expiry_timeout);\r\n}\r\nvoid nfs_release_automount_timer(void)\r\n{\r\nif (list_empty(&nfs_automount_list))\r\ncancel_delayed_work(&nfs_automount_task);\r\n}\r\nstatic struct vfsmount *nfs_do_clone_mount(struct nfs_server *server,\r\nconst char *devname,\r\nstruct nfs_clone_mount *mountdata)\r\n{\r\nreturn vfs_submount(mountdata->dentry, &nfs_xdev_fs_type, devname, mountdata);\r\n}\r\nstruct vfsmount *nfs_do_submount(struct dentry *dentry, struct nfs_fh *fh,\r\nstruct nfs_fattr *fattr, rpc_authflavor_t authflavor)\r\n{\r\nstruct nfs_clone_mount mountdata = {\r\n.sb = dentry->d_sb,\r\n.dentry = dentry,\r\n.fh = fh,\r\n.fattr = fattr,\r\n.authflavor = authflavor,\r\n};\r\nstruct vfsmount *mnt;\r\nchar *page = (char *) __get_free_page(GFP_USER);\r\nchar *devname;\r\nif (page == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\ndevname = nfs_devname(dentry, page, PAGE_SIZE);\r\nif (IS_ERR(devname))\r\nmnt = ERR_CAST(devname);\r\nelse\r\nmnt = nfs_do_clone_mount(NFS_SB(dentry->d_sb), devname, &mountdata);\r\nfree_page((unsigned long)page);\r\nreturn mnt;\r\n}\r\nstruct vfsmount *nfs_submount(struct nfs_server *server, struct dentry *dentry,\r\nstruct nfs_fh *fh, struct nfs_fattr *fattr)\r\n{\r\nint err;\r\nstruct dentry *parent = dget_parent(dentry);\r\nerr = server->nfs_client->rpc_ops->lookup(d_inode(parent), &dentry->d_name, fh, fattr, NULL);\r\ndput(parent);\r\nif (err != 0)\r\nreturn ERR_PTR(err);\r\nreturn nfs_do_submount(dentry, fh, fattr, server->client->cl_auth->au_flavor);\r\n}
