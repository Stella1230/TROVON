static inline int zcrypt_process_rescan(void)\r\n{\r\nif (atomic_read(&zcrypt_rescan_req)) {\r\natomic_set(&zcrypt_rescan_req, 0);\r\natomic_inc(&zcrypt_rescan_count);\r\nap_bus_force_rescan();\r\nZCRYPT_DBF(DBF_INFO, "rescan count=%07d\n",\r\natomic_inc_return(&zcrypt_rescan_count));\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nvoid zcrypt_msgtype_register(struct zcrypt_ops *zops)\r\n{\r\nlist_add_tail(&zops->list, &zcrypt_ops_list);\r\n}\r\nvoid zcrypt_msgtype_unregister(struct zcrypt_ops *zops)\r\n{\r\nlist_del_init(&zops->list);\r\n}\r\nstruct zcrypt_ops *zcrypt_msgtype(unsigned char *name, int variant)\r\n{\r\nstruct zcrypt_ops *zops;\r\nlist_for_each_entry(zops, &zcrypt_ops_list, list)\r\nif ((zops->variant == variant) &&\r\n(!strncmp(zops->name, name, sizeof(zops->name))))\r\nreturn zops;\r\nreturn NULL;\r\n}\r\nstatic ssize_t zcrypt_read(struct file *filp, char __user *buf,\r\nsize_t count, loff_t *f_pos)\r\n{\r\nreturn -EPERM;\r\n}\r\nstatic ssize_t zcrypt_write(struct file *filp, const char __user *buf,\r\nsize_t count, loff_t *f_pos)\r\n{\r\nreturn -EPERM;\r\n}\r\nstatic int zcrypt_open(struct inode *inode, struct file *filp)\r\n{\r\natomic_inc(&zcrypt_open_count);\r\nreturn nonseekable_open(inode, filp);\r\n}\r\nstatic int zcrypt_release(struct inode *inode, struct file *filp)\r\n{\r\natomic_dec(&zcrypt_open_count);\r\nreturn 0;\r\n}\r\nstatic inline struct zcrypt_queue *zcrypt_pick_queue(struct zcrypt_card *zc,\r\nstruct zcrypt_queue *zq,\r\nunsigned int weight)\r\n{\r\nif (!zq || !try_module_get(zq->queue->ap_dev.drv->driver.owner))\r\nreturn NULL;\r\nzcrypt_queue_get(zq);\r\nget_device(&zq->queue->ap_dev.device);\r\natomic_add(weight, &zc->load);\r\natomic_add(weight, &zq->load);\r\nzq->request_count++;\r\nreturn zq;\r\n}\r\nstatic inline void zcrypt_drop_queue(struct zcrypt_card *zc,\r\nstruct zcrypt_queue *zq,\r\nunsigned int weight)\r\n{\r\nstruct module *mod = zq->queue->ap_dev.drv->driver.owner;\r\nzq->request_count--;\r\natomic_sub(weight, &zc->load);\r\natomic_sub(weight, &zq->load);\r\nput_device(&zq->queue->ap_dev.device);\r\nzcrypt_queue_put(zq);\r\nmodule_put(mod);\r\n}\r\nstatic inline bool zcrypt_card_compare(struct zcrypt_card *zc,\r\nstruct zcrypt_card *pref_zc,\r\nunsigned weight, unsigned pref_weight)\r\n{\r\nif (!pref_zc)\r\nreturn false;\r\nweight += atomic_read(&zc->load);\r\npref_weight += atomic_read(&pref_zc->load);\r\nif (weight == pref_weight)\r\nreturn atomic_read(&zc->card->total_request_count) >\r\natomic_read(&pref_zc->card->total_request_count);\r\nreturn weight > pref_weight;\r\n}\r\nstatic inline bool zcrypt_queue_compare(struct zcrypt_queue *zq,\r\nstruct zcrypt_queue *pref_zq,\r\nunsigned weight, unsigned pref_weight)\r\n{\r\nif (!pref_zq)\r\nreturn false;\r\nweight += atomic_read(&zq->load);\r\npref_weight += atomic_read(&pref_zq->load);\r\nif (weight == pref_weight)\r\nreturn &zq->queue->total_request_count >\r\n&pref_zq->queue->total_request_count;\r\nreturn weight > pref_weight;\r\n}\r\nstatic long zcrypt_rsa_modexpo(struct ica_rsa_modexpo *mex)\r\n{\r\nstruct zcrypt_card *zc, *pref_zc;\r\nstruct zcrypt_queue *zq, *pref_zq;\r\nunsigned int weight, pref_weight;\r\nunsigned int func_code;\r\nint qid = 0, rc = -ENODEV;\r\ntrace_s390_zcrypt_req(mex, TP_ICARSAMODEXPO);\r\nif (mex->outputdatalength < mex->inputdatalength) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nmex->outputdatalength = mex->inputdatalength;\r\nrc = get_rsa_modex_fc(mex, &func_code);\r\nif (rc)\r\ngoto out;\r\npref_zc = NULL;\r\npref_zq = NULL;\r\nspin_lock(&zcrypt_list_lock);\r\nfor_each_zcrypt_card(zc) {\r\nif (!zc->online || !(zc->card->functions & 0x18000000))\r\ncontinue;\r\nif (zc->min_mod_size > mex->inputdatalength ||\r\nzc->max_mod_size < mex->inputdatalength)\r\ncontinue;\r\nweight = zc->speed_rating[func_code];\r\nif (zcrypt_card_compare(zc, pref_zc, weight, pref_weight))\r\ncontinue;\r\nfor_each_zcrypt_queue(zq, zc) {\r\nif (!zq->online || !zq->ops->rsa_modexpo)\r\ncontinue;\r\nif (zcrypt_queue_compare(zq, pref_zq,\r\nweight, pref_weight))\r\ncontinue;\r\npref_zc = zc;\r\npref_zq = zq;\r\npref_weight = weight;\r\n}\r\n}\r\npref_zq = zcrypt_pick_queue(pref_zc, pref_zq, weight);\r\nspin_unlock(&zcrypt_list_lock);\r\nif (!pref_zq) {\r\nrc = -ENODEV;\r\ngoto out;\r\n}\r\nqid = pref_zq->queue->qid;\r\nrc = pref_zq->ops->rsa_modexpo(pref_zq, mex);\r\nspin_lock(&zcrypt_list_lock);\r\nzcrypt_drop_queue(pref_zc, pref_zq, weight);\r\nspin_unlock(&zcrypt_list_lock);\r\nout:\r\ntrace_s390_zcrypt_rep(mex, func_code, rc,\r\nAP_QID_CARD(qid), AP_QID_QUEUE(qid));\r\nreturn rc;\r\n}\r\nstatic long zcrypt_rsa_crt(struct ica_rsa_modexpo_crt *crt)\r\n{\r\nstruct zcrypt_card *zc, *pref_zc;\r\nstruct zcrypt_queue *zq, *pref_zq;\r\nunsigned int weight, pref_weight;\r\nunsigned int func_code;\r\nint qid = 0, rc = -ENODEV;\r\ntrace_s390_zcrypt_req(crt, TP_ICARSACRT);\r\nif (crt->outputdatalength < crt->inputdatalength) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\ncrt->outputdatalength = crt->inputdatalength;\r\nrc = get_rsa_crt_fc(crt, &func_code);\r\nif (rc)\r\ngoto out;\r\npref_zc = NULL;\r\npref_zq = NULL;\r\nspin_lock(&zcrypt_list_lock);\r\nfor_each_zcrypt_card(zc) {\r\nif (!zc->online || !(zc->card->functions & 0x18000000))\r\ncontinue;\r\nif (zc->min_mod_size > crt->inputdatalength ||\r\nzc->max_mod_size < crt->inputdatalength)\r\ncontinue;\r\nweight = zc->speed_rating[func_code];\r\nif (zcrypt_card_compare(zc, pref_zc, weight, pref_weight))\r\ncontinue;\r\nfor_each_zcrypt_queue(zq, zc) {\r\nif (!zq->online || !zq->ops->rsa_modexpo_crt)\r\ncontinue;\r\nif (zcrypt_queue_compare(zq, pref_zq,\r\nweight, pref_weight))\r\ncontinue;\r\npref_zc = zc;\r\npref_zq = zq;\r\npref_weight = weight;\r\n}\r\n}\r\npref_zq = zcrypt_pick_queue(pref_zc, pref_zq, weight);\r\nspin_unlock(&zcrypt_list_lock);\r\nif (!pref_zq) {\r\nrc = -ENODEV;\r\ngoto out;\r\n}\r\nqid = pref_zq->queue->qid;\r\nrc = pref_zq->ops->rsa_modexpo_crt(pref_zq, crt);\r\nspin_lock(&zcrypt_list_lock);\r\nzcrypt_drop_queue(pref_zc, pref_zq, weight);\r\nspin_unlock(&zcrypt_list_lock);\r\nout:\r\ntrace_s390_zcrypt_rep(crt, func_code, rc,\r\nAP_QID_CARD(qid), AP_QID_QUEUE(qid));\r\nreturn rc;\r\n}\r\nlong zcrypt_send_cprb(struct ica_xcRB *xcRB)\r\n{\r\nstruct zcrypt_card *zc, *pref_zc;\r\nstruct zcrypt_queue *zq, *pref_zq;\r\nstruct ap_message ap_msg;\r\nunsigned int weight, pref_weight;\r\nunsigned int func_code;\r\nunsigned short *domain;\r\nint qid = 0, rc = -ENODEV;\r\ntrace_s390_zcrypt_req(xcRB, TB_ZSECSENDCPRB);\r\nrc = get_cprb_fc(xcRB, &ap_msg, &func_code, &domain);\r\nif (rc)\r\ngoto out;\r\npref_zc = NULL;\r\npref_zq = NULL;\r\nspin_lock(&zcrypt_list_lock);\r\nfor_each_zcrypt_card(zc) {\r\nif (!zc->online || !(zc->card->functions & 0x10000000))\r\ncontinue;\r\nif (xcRB->user_defined != AUTOSELECT &&\r\nxcRB->user_defined != zc->card->id)\r\ncontinue;\r\nweight = speed_idx_cca(func_code) * zc->speed_rating[SECKEY];\r\nif (zcrypt_card_compare(zc, pref_zc, weight, pref_weight))\r\ncontinue;\r\nfor_each_zcrypt_queue(zq, zc) {\r\nif (!zq->online ||\r\n!zq->ops->send_cprb ||\r\n((*domain != (unsigned short) AUTOSELECT) &&\r\n(*domain != AP_QID_QUEUE(zq->queue->qid))))\r\ncontinue;\r\nif (zcrypt_queue_compare(zq, pref_zq,\r\nweight, pref_weight))\r\ncontinue;\r\npref_zc = zc;\r\npref_zq = zq;\r\npref_weight = weight;\r\n}\r\n}\r\npref_zq = zcrypt_pick_queue(pref_zc, pref_zq, weight);\r\nspin_unlock(&zcrypt_list_lock);\r\nif (!pref_zq) {\r\nrc = -ENODEV;\r\ngoto out;\r\n}\r\nqid = pref_zq->queue->qid;\r\nif (*domain == (unsigned short) AUTOSELECT)\r\n*domain = AP_QID_QUEUE(qid);\r\nrc = pref_zq->ops->send_cprb(pref_zq, xcRB, &ap_msg);\r\nspin_lock(&zcrypt_list_lock);\r\nzcrypt_drop_queue(pref_zc, pref_zq, weight);\r\nspin_unlock(&zcrypt_list_lock);\r\nout:\r\ntrace_s390_zcrypt_rep(xcRB, func_code, rc,\r\nAP_QID_CARD(qid), AP_QID_QUEUE(qid));\r\nreturn rc;\r\n}\r\nstatic bool is_desired_ep11_card(unsigned int dev_id,\r\nunsigned short target_num,\r\nstruct ep11_target_dev *targets)\r\n{\r\nwhile (target_num-- > 0) {\r\nif (dev_id == targets->ap_id)\r\nreturn true;\r\ntargets++;\r\n}\r\nreturn false;\r\n}\r\nstatic bool is_desired_ep11_queue(unsigned int dev_qid,\r\nunsigned short target_num,\r\nstruct ep11_target_dev *targets)\r\n{\r\nwhile (target_num-- > 0) {\r\nif (AP_MKQID(targets->ap_id, targets->dom_id) == dev_qid)\r\nreturn true;\r\ntargets++;\r\n}\r\nreturn false;\r\n}\r\nstatic long zcrypt_send_ep11_cprb(struct ep11_urb *xcrb)\r\n{\r\nstruct zcrypt_card *zc, *pref_zc;\r\nstruct zcrypt_queue *zq, *pref_zq;\r\nstruct ep11_target_dev *targets;\r\nunsigned short target_num;\r\nunsigned int weight, pref_weight;\r\nunsigned int func_code;\r\nstruct ap_message ap_msg;\r\nint qid = 0, rc = -ENODEV;\r\ntrace_s390_zcrypt_req(xcrb, TP_ZSENDEP11CPRB);\r\ntarget_num = (unsigned short) xcrb->targets_num;\r\ntargets = NULL;\r\nif (target_num != 0) {\r\nstruct ep11_target_dev __user *uptr;\r\ntargets = kcalloc(target_num, sizeof(*targets), GFP_KERNEL);\r\nif (!targets) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nuptr = (struct ep11_target_dev __force __user *) xcrb->targets;\r\nif (copy_from_user(targets, uptr,\r\ntarget_num * sizeof(*targets))) {\r\nrc = -EFAULT;\r\ngoto out;\r\n}\r\n}\r\nrc = get_ep11cprb_fc(xcrb, &ap_msg, &func_code);\r\nif (rc)\r\ngoto out_free;\r\npref_zc = NULL;\r\npref_zq = NULL;\r\nspin_lock(&zcrypt_list_lock);\r\nfor_each_zcrypt_card(zc) {\r\nif (!zc->online || !(zc->card->functions & 0x04000000))\r\ncontinue;\r\nif (targets &&\r\n!is_desired_ep11_card(zc->card->id, target_num, targets))\r\ncontinue;\r\nweight = speed_idx_ep11(func_code) * zc->speed_rating[SECKEY];\r\nif (zcrypt_card_compare(zc, pref_zc, weight, pref_weight))\r\ncontinue;\r\nfor_each_zcrypt_queue(zq, zc) {\r\nif (!zq->online ||\r\n!zq->ops->send_ep11_cprb ||\r\n(targets &&\r\n!is_desired_ep11_queue(zq->queue->qid,\r\ntarget_num, targets)))\r\ncontinue;\r\nif (zcrypt_queue_compare(zq, pref_zq,\r\nweight, pref_weight))\r\ncontinue;\r\npref_zc = zc;\r\npref_zq = zq;\r\npref_weight = weight;\r\n}\r\n}\r\npref_zq = zcrypt_pick_queue(pref_zc, pref_zq, weight);\r\nspin_unlock(&zcrypt_list_lock);\r\nif (!pref_zq) {\r\nrc = -ENODEV;\r\ngoto out_free;\r\n}\r\nqid = pref_zq->queue->qid;\r\nrc = pref_zq->ops->send_ep11_cprb(pref_zq, xcrb, &ap_msg);\r\nspin_lock(&zcrypt_list_lock);\r\nzcrypt_drop_queue(pref_zc, pref_zq, weight);\r\nspin_unlock(&zcrypt_list_lock);\r\nout_free:\r\nkfree(targets);\r\nout:\r\ntrace_s390_zcrypt_rep(xcrb, func_code, rc,\r\nAP_QID_CARD(qid), AP_QID_QUEUE(qid));\r\nreturn rc;\r\n}\r\nstatic long zcrypt_rng(char *buffer)\r\n{\r\nstruct zcrypt_card *zc, *pref_zc;\r\nstruct zcrypt_queue *zq, *pref_zq;\r\nunsigned int weight, pref_weight;\r\nunsigned int func_code;\r\nstruct ap_message ap_msg;\r\nunsigned int domain;\r\nint qid = 0, rc = -ENODEV;\r\ntrace_s390_zcrypt_req(buffer, TP_HWRNGCPRB);\r\nrc = get_rng_fc(&ap_msg, &func_code, &domain);\r\nif (rc)\r\ngoto out;\r\npref_zc = NULL;\r\npref_zq = NULL;\r\nspin_lock(&zcrypt_list_lock);\r\nfor_each_zcrypt_card(zc) {\r\nif (!zc->online || !(zc->card->functions & 0x10000000))\r\ncontinue;\r\nweight = zc->speed_rating[func_code];\r\nif (zcrypt_card_compare(zc, pref_zc, weight, pref_weight))\r\ncontinue;\r\nfor_each_zcrypt_queue(zq, zc) {\r\nif (!zq->online || !zq->ops->rng)\r\ncontinue;\r\nif (zcrypt_queue_compare(zq, pref_zq,\r\nweight, pref_weight))\r\ncontinue;\r\npref_zc = zc;\r\npref_zq = zq;\r\npref_weight = weight;\r\n}\r\n}\r\npref_zq = zcrypt_pick_queue(pref_zc, pref_zq, weight);\r\nspin_unlock(&zcrypt_list_lock);\r\nif (!pref_zq)\r\nreturn -ENODEV;\r\nqid = pref_zq->queue->qid;\r\nrc = pref_zq->ops->rng(pref_zq, buffer, &ap_msg);\r\nspin_lock(&zcrypt_list_lock);\r\nzcrypt_drop_queue(pref_zc, pref_zq, weight);\r\nspin_unlock(&zcrypt_list_lock);\r\nout:\r\ntrace_s390_zcrypt_rep(buffer, func_code, rc,\r\nAP_QID_CARD(qid), AP_QID_QUEUE(qid));\r\nreturn rc;\r\n}\r\nvoid zcrypt_device_status_mask(struct zcrypt_device_matrix *matrix)\r\n{\r\nstruct zcrypt_card *zc;\r\nstruct zcrypt_queue *zq;\r\nstruct zcrypt_device_status *stat;\r\nmemset(matrix, 0, sizeof(*matrix));\r\nspin_lock(&zcrypt_list_lock);\r\nfor_each_zcrypt_card(zc) {\r\nfor_each_zcrypt_queue(zq, zc) {\r\nstat = matrix->device;\r\nstat += AP_QID_CARD(zq->queue->qid) * MAX_ZDEV_DOMAINS;\r\nstat += AP_QID_QUEUE(zq->queue->qid);\r\nstat->hwtype = zc->card->ap_dev.device_type;\r\nstat->functions = zc->card->functions >> 26;\r\nstat->qid = zq->queue->qid;\r\nstat->online = zq->online ? 0x01 : 0x00;\r\n}\r\n}\r\nspin_unlock(&zcrypt_list_lock);\r\n}\r\nstatic void zcrypt_status_mask(char status[AP_DEVICES])\r\n{\r\nstruct zcrypt_card *zc;\r\nstruct zcrypt_queue *zq;\r\nmemset(status, 0, sizeof(char) * AP_DEVICES);\r\nspin_lock(&zcrypt_list_lock);\r\nfor_each_zcrypt_card(zc) {\r\nfor_each_zcrypt_queue(zq, zc) {\r\nif (AP_QID_QUEUE(zq->queue->qid) != ap_domain_index)\r\ncontinue;\r\nstatus[AP_QID_CARD(zq->queue->qid)] =\r\nzc->online ? zc->user_space_type : 0x0d;\r\n}\r\n}\r\nspin_unlock(&zcrypt_list_lock);\r\n}\r\nstatic void zcrypt_qdepth_mask(char qdepth[AP_DEVICES])\r\n{\r\nstruct zcrypt_card *zc;\r\nstruct zcrypt_queue *zq;\r\nmemset(qdepth, 0, sizeof(char) * AP_DEVICES);\r\nspin_lock(&zcrypt_list_lock);\r\nlocal_bh_disable();\r\nfor_each_zcrypt_card(zc) {\r\nfor_each_zcrypt_queue(zq, zc) {\r\nif (AP_QID_QUEUE(zq->queue->qid) != ap_domain_index)\r\ncontinue;\r\nspin_lock(&zq->queue->lock);\r\nqdepth[AP_QID_CARD(zq->queue->qid)] =\r\nzq->queue->pendingq_count +\r\nzq->queue->requestq_count;\r\nspin_unlock(&zq->queue->lock);\r\n}\r\n}\r\nlocal_bh_enable();\r\nspin_unlock(&zcrypt_list_lock);\r\n}\r\nstatic void zcrypt_perdev_reqcnt(int reqcnt[AP_DEVICES])\r\n{\r\nstruct zcrypt_card *zc;\r\nstruct zcrypt_queue *zq;\r\nmemset(reqcnt, 0, sizeof(int) * AP_DEVICES);\r\nspin_lock(&zcrypt_list_lock);\r\nlocal_bh_disable();\r\nfor_each_zcrypt_card(zc) {\r\nfor_each_zcrypt_queue(zq, zc) {\r\nif (AP_QID_QUEUE(zq->queue->qid) != ap_domain_index)\r\ncontinue;\r\nspin_lock(&zq->queue->lock);\r\nreqcnt[AP_QID_CARD(zq->queue->qid)] =\r\nzq->queue->total_request_count;\r\nspin_unlock(&zq->queue->lock);\r\n}\r\n}\r\nlocal_bh_enable();\r\nspin_unlock(&zcrypt_list_lock);\r\n}\r\nstatic int zcrypt_pendingq_count(void)\r\n{\r\nstruct zcrypt_card *zc;\r\nstruct zcrypt_queue *zq;\r\nint pendingq_count;\r\npendingq_count = 0;\r\nspin_lock(&zcrypt_list_lock);\r\nlocal_bh_disable();\r\nfor_each_zcrypt_card(zc) {\r\nfor_each_zcrypt_queue(zq, zc) {\r\nif (AP_QID_QUEUE(zq->queue->qid) != ap_domain_index)\r\ncontinue;\r\nspin_lock(&zq->queue->lock);\r\npendingq_count += zq->queue->pendingq_count;\r\nspin_unlock(&zq->queue->lock);\r\n}\r\n}\r\nlocal_bh_enable();\r\nspin_unlock(&zcrypt_list_lock);\r\nreturn pendingq_count;\r\n}\r\nstatic int zcrypt_requestq_count(void)\r\n{\r\nstruct zcrypt_card *zc;\r\nstruct zcrypt_queue *zq;\r\nint requestq_count;\r\nrequestq_count = 0;\r\nspin_lock(&zcrypt_list_lock);\r\nlocal_bh_disable();\r\nfor_each_zcrypt_card(zc) {\r\nfor_each_zcrypt_queue(zq, zc) {\r\nif (AP_QID_QUEUE(zq->queue->qid) != ap_domain_index)\r\ncontinue;\r\nspin_lock(&zq->queue->lock);\r\nrequestq_count += zq->queue->requestq_count;\r\nspin_unlock(&zq->queue->lock);\r\n}\r\n}\r\nlocal_bh_enable();\r\nspin_unlock(&zcrypt_list_lock);\r\nreturn requestq_count;\r\n}\r\nstatic int zcrypt_count_type(int type)\r\n{\r\nstruct zcrypt_card *zc;\r\nstruct zcrypt_queue *zq;\r\nint device_count;\r\ndevice_count = 0;\r\nspin_lock(&zcrypt_list_lock);\r\nfor_each_zcrypt_card(zc) {\r\nif (zc->card->id != type)\r\ncontinue;\r\nfor_each_zcrypt_queue(zq, zc) {\r\nif (AP_QID_QUEUE(zq->queue->qid) != ap_domain_index)\r\ncontinue;\r\ndevice_count++;\r\n}\r\n}\r\nspin_unlock(&zcrypt_list_lock);\r\nreturn device_count;\r\n}\r\nstatic long zcrypt_ica_status(struct file *filp, unsigned long arg)\r\n{\r\nstruct ica_z90_status *pstat;\r\nint ret;\r\npstat = kzalloc(sizeof(*pstat), GFP_KERNEL);\r\nif (!pstat)\r\nreturn -ENOMEM;\r\npstat->totalcount = zcrypt_device_count;\r\npstat->leedslitecount = zcrypt_count_type(ZCRYPT_PCICA);\r\npstat->leeds2count = zcrypt_count_type(ZCRYPT_PCICC);\r\npstat->requestqWaitCount = zcrypt_requestq_count();\r\npstat->pendingqWaitCount = zcrypt_pendingq_count();\r\npstat->totalOpenCount = atomic_read(&zcrypt_open_count);\r\npstat->cryptoDomain = ap_domain_index;\r\nzcrypt_status_mask(pstat->status);\r\nzcrypt_qdepth_mask(pstat->qdepth);\r\nret = 0;\r\nif (copy_to_user((void __user *) arg, pstat, sizeof(*pstat)))\r\nret = -EFAULT;\r\nkfree(pstat);\r\nreturn ret;\r\n}\r\nstatic long zcrypt_unlocked_ioctl(struct file *filp, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nint rc;\r\nswitch (cmd) {\r\ncase ICARSAMODEXPO: {\r\nstruct ica_rsa_modexpo __user *umex = (void __user *) arg;\r\nstruct ica_rsa_modexpo mex;\r\nif (copy_from_user(&mex, umex, sizeof(mex)))\r\nreturn -EFAULT;\r\ndo {\r\nrc = zcrypt_rsa_modexpo(&mex);\r\n} while (rc == -EAGAIN);\r\nif ((rc == -ENODEV) && (zcrypt_process_rescan()))\r\ndo {\r\nrc = zcrypt_rsa_modexpo(&mex);\r\n} while (rc == -EAGAIN);\r\nif (rc) {\r\nZCRYPT_DBF(DBF_DEBUG, "ioctl ICARSAMODEXPO rc=%d\n", rc);\r\nreturn rc;\r\n}\r\nreturn put_user(mex.outputdatalength, &umex->outputdatalength);\r\n}\r\ncase ICARSACRT: {\r\nstruct ica_rsa_modexpo_crt __user *ucrt = (void __user *) arg;\r\nstruct ica_rsa_modexpo_crt crt;\r\nif (copy_from_user(&crt, ucrt, sizeof(crt)))\r\nreturn -EFAULT;\r\ndo {\r\nrc = zcrypt_rsa_crt(&crt);\r\n} while (rc == -EAGAIN);\r\nif ((rc == -ENODEV) && (zcrypt_process_rescan()))\r\ndo {\r\nrc = zcrypt_rsa_crt(&crt);\r\n} while (rc == -EAGAIN);\r\nif (rc) {\r\nZCRYPT_DBF(DBF_DEBUG, "ioctl ICARSACRT rc=%d\n", rc);\r\nreturn rc;\r\n}\r\nreturn put_user(crt.outputdatalength, &ucrt->outputdatalength);\r\n}\r\ncase ZSECSENDCPRB: {\r\nstruct ica_xcRB __user *uxcRB = (void __user *) arg;\r\nstruct ica_xcRB xcRB;\r\nif (copy_from_user(&xcRB, uxcRB, sizeof(xcRB)))\r\nreturn -EFAULT;\r\ndo {\r\nrc = zcrypt_send_cprb(&xcRB);\r\n} while (rc == -EAGAIN);\r\nif ((rc == -ENODEV) && (zcrypt_process_rescan()))\r\ndo {\r\nrc = zcrypt_send_cprb(&xcRB);\r\n} while (rc == -EAGAIN);\r\nif (rc)\r\nZCRYPT_DBF(DBF_DEBUG, "ioctl ZSENDCPRB rc=%d\n", rc);\r\nif (copy_to_user(uxcRB, &xcRB, sizeof(xcRB)))\r\nreturn -EFAULT;\r\nreturn rc;\r\n}\r\ncase ZSENDEP11CPRB: {\r\nstruct ep11_urb __user *uxcrb = (void __user *)arg;\r\nstruct ep11_urb xcrb;\r\nif (copy_from_user(&xcrb, uxcrb, sizeof(xcrb)))\r\nreturn -EFAULT;\r\ndo {\r\nrc = zcrypt_send_ep11_cprb(&xcrb);\r\n} while (rc == -EAGAIN);\r\nif ((rc == -ENODEV) && (zcrypt_process_rescan()))\r\ndo {\r\nrc = zcrypt_send_ep11_cprb(&xcrb);\r\n} while (rc == -EAGAIN);\r\nif (rc)\r\nZCRYPT_DBF(DBF_DEBUG, "ioctl ZSENDEP11CPRB rc=%d\n", rc);\r\nif (copy_to_user(uxcrb, &xcrb, sizeof(xcrb)))\r\nreturn -EFAULT;\r\nreturn rc;\r\n}\r\ncase ZDEVICESTATUS: {\r\nstruct zcrypt_device_matrix *device_status;\r\ndevice_status = kzalloc(sizeof(struct zcrypt_device_matrix),\r\nGFP_KERNEL);\r\nif (!device_status)\r\nreturn -ENOMEM;\r\nzcrypt_device_status_mask(device_status);\r\nif (copy_to_user((char __user *) arg, device_status,\r\nsizeof(struct zcrypt_device_matrix))) {\r\nkfree(device_status);\r\nreturn -EFAULT;\r\n}\r\nkfree(device_status);\r\nreturn 0;\r\n}\r\ncase Z90STAT_STATUS_MASK: {\r\nchar status[AP_DEVICES];\r\nzcrypt_status_mask(status);\r\nif (copy_to_user((char __user *) arg, status,\r\nsizeof(char) * AP_DEVICES))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\ncase Z90STAT_QDEPTH_MASK: {\r\nchar qdepth[AP_DEVICES];\r\nzcrypt_qdepth_mask(qdepth);\r\nif (copy_to_user((char __user *) arg, qdepth,\r\nsizeof(char) * AP_DEVICES))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\ncase Z90STAT_PERDEV_REQCNT: {\r\nint reqcnt[AP_DEVICES];\r\nzcrypt_perdev_reqcnt(reqcnt);\r\nif (copy_to_user((int __user *) arg, reqcnt,\r\nsizeof(int) * AP_DEVICES))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\ncase Z90STAT_REQUESTQ_COUNT:\r\nreturn put_user(zcrypt_requestq_count(), (int __user *) arg);\r\ncase Z90STAT_PENDINGQ_COUNT:\r\nreturn put_user(zcrypt_pendingq_count(), (int __user *) arg);\r\ncase Z90STAT_TOTALOPEN_COUNT:\r\nreturn put_user(atomic_read(&zcrypt_open_count),\r\n(int __user *) arg);\r\ncase Z90STAT_DOMAIN_INDEX:\r\nreturn put_user(ap_domain_index, (int __user *) arg);\r\ncase ICAZ90STATUS:\r\nreturn zcrypt_ica_status(filp, arg);\r\ncase Z90STAT_TOTALCOUNT:\r\nreturn put_user(zcrypt_device_count, (int __user *) arg);\r\ncase Z90STAT_PCICACOUNT:\r\nreturn put_user(zcrypt_count_type(ZCRYPT_PCICA),\r\n(int __user *) arg);\r\ncase Z90STAT_PCICCCOUNT:\r\nreturn put_user(zcrypt_count_type(ZCRYPT_PCICC),\r\n(int __user *) arg);\r\ncase Z90STAT_PCIXCCMCL2COUNT:\r\nreturn put_user(zcrypt_count_type(ZCRYPT_PCIXCC_MCL2),\r\n(int __user *) arg);\r\ncase Z90STAT_PCIXCCMCL3COUNT:\r\nreturn put_user(zcrypt_count_type(ZCRYPT_PCIXCC_MCL3),\r\n(int __user *) arg);\r\ncase Z90STAT_PCIXCCCOUNT:\r\nreturn put_user(zcrypt_count_type(ZCRYPT_PCIXCC_MCL2) +\r\nzcrypt_count_type(ZCRYPT_PCIXCC_MCL3),\r\n(int __user *) arg);\r\ncase Z90STAT_CEX2CCOUNT:\r\nreturn put_user(zcrypt_count_type(ZCRYPT_CEX2C),\r\n(int __user *) arg);\r\ncase Z90STAT_CEX2ACOUNT:\r\nreturn put_user(zcrypt_count_type(ZCRYPT_CEX2A),\r\n(int __user *) arg);\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\n}\r\nstatic long trans_modexpo32(struct file *filp, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct compat_ica_rsa_modexpo __user *umex32 = compat_ptr(arg);\r\nstruct compat_ica_rsa_modexpo mex32;\r\nstruct ica_rsa_modexpo mex64;\r\nlong rc;\r\nif (copy_from_user(&mex32, umex32, sizeof(mex32)))\r\nreturn -EFAULT;\r\nmex64.inputdata = compat_ptr(mex32.inputdata);\r\nmex64.inputdatalength = mex32.inputdatalength;\r\nmex64.outputdata = compat_ptr(mex32.outputdata);\r\nmex64.outputdatalength = mex32.outputdatalength;\r\nmex64.b_key = compat_ptr(mex32.b_key);\r\nmex64.n_modulus = compat_ptr(mex32.n_modulus);\r\ndo {\r\nrc = zcrypt_rsa_modexpo(&mex64);\r\n} while (rc == -EAGAIN);\r\nif ((rc == -ENODEV) && (zcrypt_process_rescan()))\r\ndo {\r\nrc = zcrypt_rsa_modexpo(&mex64);\r\n} while (rc == -EAGAIN);\r\nif (rc)\r\nreturn rc;\r\nreturn put_user(mex64.outputdatalength,\r\n&umex32->outputdatalength);\r\n}\r\nstatic long trans_modexpo_crt32(struct file *filp, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct compat_ica_rsa_modexpo_crt __user *ucrt32 = compat_ptr(arg);\r\nstruct compat_ica_rsa_modexpo_crt crt32;\r\nstruct ica_rsa_modexpo_crt crt64;\r\nlong rc;\r\nif (copy_from_user(&crt32, ucrt32, sizeof(crt32)))\r\nreturn -EFAULT;\r\ncrt64.inputdata = compat_ptr(crt32.inputdata);\r\ncrt64.inputdatalength = crt32.inputdatalength;\r\ncrt64.outputdata= compat_ptr(crt32.outputdata);\r\ncrt64.outputdatalength = crt32.outputdatalength;\r\ncrt64.bp_key = compat_ptr(crt32.bp_key);\r\ncrt64.bq_key = compat_ptr(crt32.bq_key);\r\ncrt64.np_prime = compat_ptr(crt32.np_prime);\r\ncrt64.nq_prime = compat_ptr(crt32.nq_prime);\r\ncrt64.u_mult_inv = compat_ptr(crt32.u_mult_inv);\r\ndo {\r\nrc = zcrypt_rsa_crt(&crt64);\r\n} while (rc == -EAGAIN);\r\nif ((rc == -ENODEV) && (zcrypt_process_rescan()))\r\ndo {\r\nrc = zcrypt_rsa_crt(&crt64);\r\n} while (rc == -EAGAIN);\r\nif (rc)\r\nreturn rc;\r\nreturn put_user(crt64.outputdatalength,\r\n&ucrt32->outputdatalength);\r\n}\r\nstatic long trans_xcRB32(struct file *filp, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct compat_ica_xcRB __user *uxcRB32 = compat_ptr(arg);\r\nstruct compat_ica_xcRB xcRB32;\r\nstruct ica_xcRB xcRB64;\r\nlong rc;\r\nif (copy_from_user(&xcRB32, uxcRB32, sizeof(xcRB32)))\r\nreturn -EFAULT;\r\nxcRB64.agent_ID = xcRB32.agent_ID;\r\nxcRB64.user_defined = xcRB32.user_defined;\r\nxcRB64.request_ID = xcRB32.request_ID;\r\nxcRB64.request_control_blk_length =\r\nxcRB32.request_control_blk_length;\r\nxcRB64.request_control_blk_addr =\r\ncompat_ptr(xcRB32.request_control_blk_addr);\r\nxcRB64.request_data_length =\r\nxcRB32.request_data_length;\r\nxcRB64.request_data_address =\r\ncompat_ptr(xcRB32.request_data_address);\r\nxcRB64.reply_control_blk_length =\r\nxcRB32.reply_control_blk_length;\r\nxcRB64.reply_control_blk_addr =\r\ncompat_ptr(xcRB32.reply_control_blk_addr);\r\nxcRB64.reply_data_length = xcRB32.reply_data_length;\r\nxcRB64.reply_data_addr =\r\ncompat_ptr(xcRB32.reply_data_addr);\r\nxcRB64.priority_window = xcRB32.priority_window;\r\nxcRB64.status = xcRB32.status;\r\ndo {\r\nrc = zcrypt_send_cprb(&xcRB64);\r\n} while (rc == -EAGAIN);\r\nif ((rc == -ENODEV) && (zcrypt_process_rescan()))\r\ndo {\r\nrc = zcrypt_send_cprb(&xcRB64);\r\n} while (rc == -EAGAIN);\r\nxcRB32.reply_control_blk_length = xcRB64.reply_control_blk_length;\r\nxcRB32.reply_data_length = xcRB64.reply_data_length;\r\nxcRB32.status = xcRB64.status;\r\nif (copy_to_user(uxcRB32, &xcRB32, sizeof(xcRB32)))\r\nreturn -EFAULT;\r\nreturn rc;\r\n}\r\nstatic long zcrypt_compat_ioctl(struct file *filp, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nif (cmd == ICARSAMODEXPO)\r\nreturn trans_modexpo32(filp, cmd, arg);\r\nif (cmd == ICARSACRT)\r\nreturn trans_modexpo_crt32(filp, cmd, arg);\r\nif (cmd == ZSECSENDCPRB)\r\nreturn trans_xcRB32(filp, cmd, arg);\r\nreturn zcrypt_unlocked_ioctl(filp, cmd, arg);\r\n}\r\nstatic void sprintcl(struct seq_file *m, unsigned char *addr, unsigned int len)\r\n{\r\nint i;\r\nfor (i = 0; i < len; i++)\r\nseq_printf(m, "%01x", (unsigned int) addr[i]);\r\nseq_putc(m, ' ');\r\n}\r\nstatic void sprintrw(struct seq_file *m, unsigned char *addr, unsigned int len)\r\n{\r\nint inl, c, cx;\r\nseq_printf(m, " ");\r\ninl = 0;\r\nfor (c = 0; c < (len / 16); c++) {\r\nsprintcl(m, addr+inl, 16);\r\ninl += 16;\r\n}\r\ncx = len%16;\r\nif (cx) {\r\nsprintcl(m, addr+inl, cx);\r\ninl += cx;\r\n}\r\nseq_putc(m, '\n');\r\n}\r\nstatic void sprinthx(unsigned char *title, struct seq_file *m,\r\nunsigned char *addr, unsigned int len)\r\n{\r\nint inl, r, rx;\r\nseq_printf(m, "\n%s\n", title);\r\ninl = 0;\r\nfor (r = 0; r < (len / 64); r++) {\r\nsprintrw(m, addr+inl, 64);\r\ninl += 64;\r\n}\r\nrx = len % 64;\r\nif (rx) {\r\nsprintrw(m, addr+inl, rx);\r\ninl += rx;\r\n}\r\nseq_putc(m, '\n');\r\n}\r\nstatic void sprinthx4(unsigned char *title, struct seq_file *m,\r\nunsigned int *array, unsigned int len)\r\n{\r\nseq_printf(m, "\n%s\n", title);\r\nseq_hex_dump(m, " ", DUMP_PREFIX_NONE, 32, 4, array, len, false);\r\nseq_putc(m, '\n');\r\n}\r\nstatic int zcrypt_proc_show(struct seq_file *m, void *v)\r\n{\r\nchar workarea[sizeof(int) * AP_DEVICES];\r\nseq_printf(m, "\nzcrypt version: %d.%d.%d\n",\r\nZCRYPT_VERSION, ZCRYPT_RELEASE, ZCRYPT_VARIANT);\r\nseq_printf(m, "Cryptographic domain: %d\n", ap_domain_index);\r\nseq_printf(m, "Total device count: %d\n", zcrypt_device_count);\r\nseq_printf(m, "PCICA count: %d\n", zcrypt_count_type(ZCRYPT_PCICA));\r\nseq_printf(m, "PCICC count: %d\n", zcrypt_count_type(ZCRYPT_PCICC));\r\nseq_printf(m, "PCIXCC MCL2 count: %d\n",\r\nzcrypt_count_type(ZCRYPT_PCIXCC_MCL2));\r\nseq_printf(m, "PCIXCC MCL3 count: %d\n",\r\nzcrypt_count_type(ZCRYPT_PCIXCC_MCL3));\r\nseq_printf(m, "CEX2C count: %d\n", zcrypt_count_type(ZCRYPT_CEX2C));\r\nseq_printf(m, "CEX2A count: %d\n", zcrypt_count_type(ZCRYPT_CEX2A));\r\nseq_printf(m, "CEX3C count: %d\n", zcrypt_count_type(ZCRYPT_CEX3C));\r\nseq_printf(m, "CEX3A count: %d\n", zcrypt_count_type(ZCRYPT_CEX3A));\r\nseq_printf(m, "requestq count: %d\n", zcrypt_requestq_count());\r\nseq_printf(m, "pendingq count: %d\n", zcrypt_pendingq_count());\r\nseq_printf(m, "Total open handles: %d\n\n",\r\natomic_read(&zcrypt_open_count));\r\nzcrypt_status_mask(workarea);\r\nsprinthx("Online devices: 1=PCICA 2=PCICC 3=PCIXCC(MCL2) "\r\n"4=PCIXCC(MCL3) 5=CEX2C 6=CEX2A 7=CEX3C 8=CEX3A",\r\nm, workarea, AP_DEVICES);\r\nzcrypt_qdepth_mask(workarea);\r\nsprinthx("Waiting work element counts", m, workarea, AP_DEVICES);\r\nzcrypt_perdev_reqcnt((int *) workarea);\r\nsprinthx4("Per-device successfully completed request counts",\r\nm, (unsigned int *) workarea, AP_DEVICES);\r\nreturn 0;\r\n}\r\nstatic int zcrypt_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, zcrypt_proc_show, NULL);\r\n}\r\nstatic void zcrypt_disable_card(int index)\r\n{\r\nstruct zcrypt_card *zc;\r\nstruct zcrypt_queue *zq;\r\nspin_lock(&zcrypt_list_lock);\r\nfor_each_zcrypt_card(zc) {\r\nfor_each_zcrypt_queue(zq, zc) {\r\nif (AP_QID_QUEUE(zq->queue->qid) != ap_domain_index)\r\ncontinue;\r\nzq->online = 0;\r\nap_flush_queue(zq->queue);\r\n}\r\n}\r\nspin_unlock(&zcrypt_list_lock);\r\n}\r\nstatic void zcrypt_enable_card(int index)\r\n{\r\nstruct zcrypt_card *zc;\r\nstruct zcrypt_queue *zq;\r\nspin_lock(&zcrypt_list_lock);\r\nfor_each_zcrypt_card(zc) {\r\nfor_each_zcrypt_queue(zq, zc) {\r\nif (AP_QID_QUEUE(zq->queue->qid) != ap_domain_index)\r\ncontinue;\r\nzq->online = 1;\r\nap_flush_queue(zq->queue);\r\n}\r\n}\r\nspin_unlock(&zcrypt_list_lock);\r\n}\r\nstatic ssize_t zcrypt_proc_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *pos)\r\n{\r\nunsigned char *lbuf, *ptr;\r\nsize_t local_count;\r\nint j;\r\nif (count <= 0)\r\nreturn 0;\r\n#define LBUFSIZE 1200UL\r\nlbuf = kmalloc(LBUFSIZE, GFP_KERNEL);\r\nif (!lbuf)\r\nreturn 0;\r\nlocal_count = min(LBUFSIZE - 1, count);\r\nif (copy_from_user(lbuf, buffer, local_count) != 0) {\r\nkfree(lbuf);\r\nreturn -EFAULT;\r\n}\r\nlbuf[local_count] = '\0';\r\nptr = strstr(lbuf, "Online devices");\r\nif (!ptr)\r\ngoto out;\r\nptr = strstr(ptr, "\n");\r\nif (!ptr)\r\ngoto out;\r\nptr++;\r\nif (strstr(ptr, "Waiting work element counts") == NULL)\r\ngoto out;\r\nfor (j = 0; j < 64 && *ptr; ptr++) {\r\nif (*ptr >= '0' && *ptr <= '8')\r\nj++;\r\nelse if (*ptr == 'd' || *ptr == 'D')\r\nzcrypt_disable_card(j++);\r\nelse if (*ptr == 'e' || *ptr == 'E')\r\nzcrypt_enable_card(j++);\r\nelse if (*ptr != ' ' && *ptr != '\t')\r\nbreak;\r\n}\r\nout:\r\nkfree(lbuf);\r\nreturn count;\r\n}\r\nstatic int zcrypt_rng_data_read(struct hwrng *rng, u32 *data)\r\n{\r\nint rc;\r\nif (zcrypt_rng_buffer_index == 0) {\r\nrc = zcrypt_rng((char *) zcrypt_rng_buffer);\r\nif ((rc == -ENODEV) && (zcrypt_process_rescan()))\r\nrc = zcrypt_rng((char *) zcrypt_rng_buffer);\r\nif (rc < 0)\r\nreturn -EIO;\r\nzcrypt_rng_buffer_index = rc / sizeof *data;\r\n}\r\n*data = zcrypt_rng_buffer[--zcrypt_rng_buffer_index];\r\nreturn sizeof *data;\r\n}\r\nint zcrypt_rng_device_add(void)\r\n{\r\nint rc = 0;\r\nmutex_lock(&zcrypt_rng_mutex);\r\nif (zcrypt_rng_device_count == 0) {\r\nzcrypt_rng_buffer = (u32 *) get_zeroed_page(GFP_KERNEL);\r\nif (!zcrypt_rng_buffer) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nzcrypt_rng_buffer_index = 0;\r\nif (!zcrypt_hwrng_seed)\r\nzcrypt_rng_dev.quality = 0;\r\nrc = hwrng_register(&zcrypt_rng_dev);\r\nif (rc)\r\ngoto out_free;\r\nzcrypt_rng_device_count = 1;\r\n} else\r\nzcrypt_rng_device_count++;\r\nmutex_unlock(&zcrypt_rng_mutex);\r\nreturn 0;\r\nout_free:\r\nfree_page((unsigned long) zcrypt_rng_buffer);\r\nout:\r\nmutex_unlock(&zcrypt_rng_mutex);\r\nreturn rc;\r\n}\r\nvoid zcrypt_rng_device_remove(void)\r\n{\r\nmutex_lock(&zcrypt_rng_mutex);\r\nzcrypt_rng_device_count--;\r\nif (zcrypt_rng_device_count == 0) {\r\nhwrng_unregister(&zcrypt_rng_dev);\r\nfree_page((unsigned long) zcrypt_rng_buffer);\r\n}\r\nmutex_unlock(&zcrypt_rng_mutex);\r\n}\r\nint __init zcrypt_debug_init(void)\r\n{\r\nzcrypt_dbf_info = debug_register("zcrypt", 1, 1,\r\nDBF_MAX_SPRINTF_ARGS * sizeof(long));\r\ndebug_register_view(zcrypt_dbf_info, &debug_sprintf_view);\r\ndebug_set_level(zcrypt_dbf_info, DBF_ERR);\r\nreturn 0;\r\n}\r\nvoid zcrypt_debug_exit(void)\r\n{\r\ndebug_unregister(zcrypt_dbf_info);\r\n}\r\nint __init zcrypt_api_init(void)\r\n{\r\nint rc;\r\nrc = zcrypt_debug_init();\r\nif (rc)\r\ngoto out;\r\natomic_set(&zcrypt_rescan_req, 0);\r\nrc = misc_register(&zcrypt_misc_device);\r\nif (rc < 0)\r\ngoto out;\r\nzcrypt_entry = proc_create("driver/z90crypt", 0644, NULL,\r\n&zcrypt_proc_fops);\r\nif (!zcrypt_entry) {\r\nrc = -ENOMEM;\r\ngoto out_misc;\r\n}\r\nzcrypt_msgtype6_init();\r\nzcrypt_msgtype50_init();\r\nreturn 0;\r\nout_misc:\r\nmisc_deregister(&zcrypt_misc_device);\r\nout:\r\nreturn rc;\r\n}\r\nvoid __exit zcrypt_api_exit(void)\r\n{\r\nremove_proc_entry("driver/z90crypt", NULL);\r\nmisc_deregister(&zcrypt_misc_device);\r\nzcrypt_msgtype6_exit();\r\nzcrypt_msgtype50_exit();\r\nzcrypt_debug_exit();\r\n}
