void iptunnel_xmit(struct sock *sk, struct rtable *rt, struct sk_buff *skb,\r\n__be32 src, __be32 dst, __u8 proto,\r\n__u8 tos, __u8 ttl, __be16 df, bool xnet)\r\n{\r\nint pkt_len = skb->len - skb_inner_network_offset(skb);\r\nstruct net *net = dev_net(rt->dst.dev);\r\nstruct net_device *dev = skb->dev;\r\nstruct iphdr *iph;\r\nint err;\r\nskb_scrub_packet(skb, xnet);\r\nskb_clear_hash_if_not_l4(skb);\r\nskb_dst_set(skb, &rt->dst);\r\nmemset(IPCB(skb), 0, sizeof(*IPCB(skb)));\r\nskb_push(skb, sizeof(struct iphdr));\r\nskb_reset_network_header(skb);\r\niph = ip_hdr(skb);\r\niph->version = 4;\r\niph->ihl = sizeof(struct iphdr) >> 2;\r\niph->frag_off = df;\r\niph->protocol = proto;\r\niph->tos = tos;\r\niph->daddr = dst;\r\niph->saddr = src;\r\niph->ttl = ttl;\r\n__ip_select_ident(net, iph, skb_shinfo(skb)->gso_segs ?: 1);\r\nerr = ip_local_out(net, sk, skb);\r\nif (unlikely(net_xmit_eval(err)))\r\npkt_len = 0;\r\niptunnel_xmit_stats(dev, pkt_len);\r\n}\r\nint __iptunnel_pull_header(struct sk_buff *skb, int hdr_len,\r\n__be16 inner_proto, bool raw_proto, bool xnet)\r\n{\r\nif (unlikely(!pskb_may_pull(skb, hdr_len)))\r\nreturn -ENOMEM;\r\nskb_pull_rcsum(skb, hdr_len);\r\nif (!raw_proto && inner_proto == htons(ETH_P_TEB)) {\r\nstruct ethhdr *eh;\r\nif (unlikely(!pskb_may_pull(skb, ETH_HLEN)))\r\nreturn -ENOMEM;\r\neh = (struct ethhdr *)skb->data;\r\nif (likely(eth_proto_is_802_3(eh->h_proto)))\r\nskb->protocol = eh->h_proto;\r\nelse\r\nskb->protocol = htons(ETH_P_802_2);\r\n} else {\r\nskb->protocol = inner_proto;\r\n}\r\nskb_clear_hash_if_not_l4(skb);\r\nskb->vlan_tci = 0;\r\nskb_set_queue_mapping(skb, 0);\r\nskb_scrub_packet(skb, xnet);\r\nreturn iptunnel_pull_offloads(skb);\r\n}\r\nstruct metadata_dst *iptunnel_metadata_reply(struct metadata_dst *md,\r\ngfp_t flags)\r\n{\r\nstruct metadata_dst *res;\r\nstruct ip_tunnel_info *dst, *src;\r\nif (!md || md->type != METADATA_IP_TUNNEL ||\r\nmd->u.tun_info.mode & IP_TUNNEL_INFO_TX)\r\nreturn NULL;\r\nres = metadata_dst_alloc(0, METADATA_IP_TUNNEL, flags);\r\nif (!res)\r\nreturn NULL;\r\ndst = &res->u.tun_info;\r\nsrc = &md->u.tun_info;\r\ndst->key.tun_id = src->key.tun_id;\r\nif (src->mode & IP_TUNNEL_INFO_IPV6)\r\nmemcpy(&dst->key.u.ipv6.dst, &src->key.u.ipv6.src,\r\nsizeof(struct in6_addr));\r\nelse\r\ndst->key.u.ipv4.dst = src->key.u.ipv4.src;\r\ndst->mode = src->mode | IP_TUNNEL_INFO_TX;\r\nreturn res;\r\n}\r\nint iptunnel_handle_offloads(struct sk_buff *skb,\r\nint gso_type_mask)\r\n{\r\nint err;\r\nif (likely(!skb->encapsulation)) {\r\nskb_reset_inner_headers(skb);\r\nskb->encapsulation = 1;\r\n}\r\nif (skb_is_gso(skb)) {\r\nerr = skb_header_unclone(skb, GFP_ATOMIC);\r\nif (unlikely(err))\r\nreturn err;\r\nskb_shinfo(skb)->gso_type |= gso_type_mask;\r\nreturn 0;\r\n}\r\nif (skb->ip_summed != CHECKSUM_PARTIAL) {\r\nskb->ip_summed = CHECKSUM_NONE;\r\nskb->encapsulation = 0;\r\n}\r\nreturn 0;\r\n}\r\nvoid ip_tunnel_get_stats64(struct net_device *dev,\r\nstruct rtnl_link_stats64 *tot)\r\n{\r\nint i;\r\nnetdev_stats_to_stats64(tot, &dev->stats);\r\nfor_each_possible_cpu(i) {\r\nconst struct pcpu_sw_netstats *tstats =\r\nper_cpu_ptr(dev->tstats, i);\r\nu64 rx_packets, rx_bytes, tx_packets, tx_bytes;\r\nunsigned int start;\r\ndo {\r\nstart = u64_stats_fetch_begin_irq(&tstats->syncp);\r\nrx_packets = tstats->rx_packets;\r\ntx_packets = tstats->tx_packets;\r\nrx_bytes = tstats->rx_bytes;\r\ntx_bytes = tstats->tx_bytes;\r\n} while (u64_stats_fetch_retry_irq(&tstats->syncp, start));\r\ntot->rx_packets += rx_packets;\r\ntot->tx_packets += tx_packets;\r\ntot->rx_bytes += rx_bytes;\r\ntot->tx_bytes += tx_bytes;\r\n}\r\n}\r\nstatic int ip_tun_build_state(struct nlattr *attr,\r\nunsigned int family, const void *cfg,\r\nstruct lwtunnel_state **ts,\r\nstruct netlink_ext_ack *extack)\r\n{\r\nstruct ip_tunnel_info *tun_info;\r\nstruct lwtunnel_state *new_state;\r\nstruct nlattr *tb[LWTUNNEL_IP_MAX + 1];\r\nint err;\r\nerr = nla_parse_nested(tb, LWTUNNEL_IP_MAX, attr, ip_tun_policy,\r\nextack);\r\nif (err < 0)\r\nreturn err;\r\nnew_state = lwtunnel_state_alloc(sizeof(*tun_info));\r\nif (!new_state)\r\nreturn -ENOMEM;\r\nnew_state->type = LWTUNNEL_ENCAP_IP;\r\ntun_info = lwt_tun_info(new_state);\r\nif (tb[LWTUNNEL_IP_ID])\r\ntun_info->key.tun_id = nla_get_be64(tb[LWTUNNEL_IP_ID]);\r\nif (tb[LWTUNNEL_IP_DST])\r\ntun_info->key.u.ipv4.dst = nla_get_in_addr(tb[LWTUNNEL_IP_DST]);\r\nif (tb[LWTUNNEL_IP_SRC])\r\ntun_info->key.u.ipv4.src = nla_get_in_addr(tb[LWTUNNEL_IP_SRC]);\r\nif (tb[LWTUNNEL_IP_TTL])\r\ntun_info->key.ttl = nla_get_u8(tb[LWTUNNEL_IP_TTL]);\r\nif (tb[LWTUNNEL_IP_TOS])\r\ntun_info->key.tos = nla_get_u8(tb[LWTUNNEL_IP_TOS]);\r\nif (tb[LWTUNNEL_IP_FLAGS])\r\ntun_info->key.tun_flags = nla_get_be16(tb[LWTUNNEL_IP_FLAGS]);\r\ntun_info->mode = IP_TUNNEL_INFO_TX;\r\ntun_info->options_len = 0;\r\n*ts = new_state;\r\nreturn 0;\r\n}\r\nstatic int ip_tun_fill_encap_info(struct sk_buff *skb,\r\nstruct lwtunnel_state *lwtstate)\r\n{\r\nstruct ip_tunnel_info *tun_info = lwt_tun_info(lwtstate);\r\nif (nla_put_be64(skb, LWTUNNEL_IP_ID, tun_info->key.tun_id,\r\nLWTUNNEL_IP_PAD) ||\r\nnla_put_in_addr(skb, LWTUNNEL_IP_DST, tun_info->key.u.ipv4.dst) ||\r\nnla_put_in_addr(skb, LWTUNNEL_IP_SRC, tun_info->key.u.ipv4.src) ||\r\nnla_put_u8(skb, LWTUNNEL_IP_TOS, tun_info->key.tos) ||\r\nnla_put_u8(skb, LWTUNNEL_IP_TTL, tun_info->key.ttl) ||\r\nnla_put_be16(skb, LWTUNNEL_IP_FLAGS, tun_info->key.tun_flags))\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int ip_tun_encap_nlsize(struct lwtunnel_state *lwtstate)\r\n{\r\nreturn nla_total_size_64bit(8)\r\n+ nla_total_size(4)\r\n+ nla_total_size(4)\r\n+ nla_total_size(1)\r\n+ nla_total_size(1)\r\n+ nla_total_size(2);\r\n}\r\nstatic int ip_tun_cmp_encap(struct lwtunnel_state *a, struct lwtunnel_state *b)\r\n{\r\nreturn memcmp(lwt_tun_info(a), lwt_tun_info(b),\r\nsizeof(struct ip_tunnel_info));\r\n}\r\nstatic int ip6_tun_build_state(struct nlattr *attr,\r\nunsigned int family, const void *cfg,\r\nstruct lwtunnel_state **ts,\r\nstruct netlink_ext_ack *extack)\r\n{\r\nstruct ip_tunnel_info *tun_info;\r\nstruct lwtunnel_state *new_state;\r\nstruct nlattr *tb[LWTUNNEL_IP6_MAX + 1];\r\nint err;\r\nerr = nla_parse_nested(tb, LWTUNNEL_IP6_MAX, attr, ip6_tun_policy,\r\nextack);\r\nif (err < 0)\r\nreturn err;\r\nnew_state = lwtunnel_state_alloc(sizeof(*tun_info));\r\nif (!new_state)\r\nreturn -ENOMEM;\r\nnew_state->type = LWTUNNEL_ENCAP_IP6;\r\ntun_info = lwt_tun_info(new_state);\r\nif (tb[LWTUNNEL_IP6_ID])\r\ntun_info->key.tun_id = nla_get_be64(tb[LWTUNNEL_IP6_ID]);\r\nif (tb[LWTUNNEL_IP6_DST])\r\ntun_info->key.u.ipv6.dst = nla_get_in6_addr(tb[LWTUNNEL_IP6_DST]);\r\nif (tb[LWTUNNEL_IP6_SRC])\r\ntun_info->key.u.ipv6.src = nla_get_in6_addr(tb[LWTUNNEL_IP6_SRC]);\r\nif (tb[LWTUNNEL_IP6_HOPLIMIT])\r\ntun_info->key.ttl = nla_get_u8(tb[LWTUNNEL_IP6_HOPLIMIT]);\r\nif (tb[LWTUNNEL_IP6_TC])\r\ntun_info->key.tos = nla_get_u8(tb[LWTUNNEL_IP6_TC]);\r\nif (tb[LWTUNNEL_IP6_FLAGS])\r\ntun_info->key.tun_flags = nla_get_be16(tb[LWTUNNEL_IP6_FLAGS]);\r\ntun_info->mode = IP_TUNNEL_INFO_TX | IP_TUNNEL_INFO_IPV6;\r\ntun_info->options_len = 0;\r\n*ts = new_state;\r\nreturn 0;\r\n}\r\nstatic int ip6_tun_fill_encap_info(struct sk_buff *skb,\r\nstruct lwtunnel_state *lwtstate)\r\n{\r\nstruct ip_tunnel_info *tun_info = lwt_tun_info(lwtstate);\r\nif (nla_put_be64(skb, LWTUNNEL_IP6_ID, tun_info->key.tun_id,\r\nLWTUNNEL_IP6_PAD) ||\r\nnla_put_in6_addr(skb, LWTUNNEL_IP6_DST, &tun_info->key.u.ipv6.dst) ||\r\nnla_put_in6_addr(skb, LWTUNNEL_IP6_SRC, &tun_info->key.u.ipv6.src) ||\r\nnla_put_u8(skb, LWTUNNEL_IP6_TC, tun_info->key.tos) ||\r\nnla_put_u8(skb, LWTUNNEL_IP6_HOPLIMIT, tun_info->key.ttl) ||\r\nnla_put_be16(skb, LWTUNNEL_IP6_FLAGS, tun_info->key.tun_flags))\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int ip6_tun_encap_nlsize(struct lwtunnel_state *lwtstate)\r\n{\r\nreturn nla_total_size_64bit(8)\r\n+ nla_total_size(16)\r\n+ nla_total_size(16)\r\n+ nla_total_size(1)\r\n+ nla_total_size(1)\r\n+ nla_total_size(2);\r\n}\r\nvoid __init ip_tunnel_core_init(void)\r\n{\r\nBUILD_BUG_ON(IP_TUNNEL_OPTS_MAX != 255);\r\nlwtunnel_encap_add_ops(&ip_tun_lwt_ops, LWTUNNEL_ENCAP_IP);\r\nlwtunnel_encap_add_ops(&ip6_tun_lwt_ops, LWTUNNEL_ENCAP_IP6);\r\n}\r\nvoid ip_tunnel_need_metadata(void)\r\n{\r\nstatic_key_slow_inc(&ip_tunnel_metadata_cnt);\r\n}\r\nvoid ip_tunnel_unneed_metadata(void)\r\n{\r\nstatic_key_slow_dec(&ip_tunnel_metadata_cnt);\r\n}
