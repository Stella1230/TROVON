int cckrates_included(unsigned char *rate, int ratelen)\r\n{\r\nint i;\r\nfor (i = 0; i < ratelen; i++) {\r\nif ((((rate[i]) & 0x7f) == 2) || (((rate[i]) & 0x7f) == 4) ||\r\n(((rate[i]) & 0x7f) == 11) || (((rate[i]) & 0x7f) == 22))\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nint cckratesonly_included(unsigned char *rate, int ratelen)\r\n{\r\nint i;\r\nfor (i = 0; i < ratelen; i++) {\r\nif ((((rate[i]) & 0x7f) != 2) && (((rate[i]) & 0x7f) != 4) &&\r\n(((rate[i]) & 0x7f) != 11) && (((rate[i]) & 0x7f) != 22))\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nu8 networktype_to_raid_ex(struct adapter *adapter, struct sta_info *psta)\r\n{\r\nu8 raid, cur_rf_type, rf_type = RF_1T1R;\r\nrtw_hal_get_hwreg(adapter, HW_VAR_RF_TYPE, (u8 *)(&cur_rf_type));\r\nif (cur_rf_type == RF_1T1R) {\r\nrf_type = RF_1T1R;\r\n} else if (IsSupportedVHT(psta->wireless_mode)) {\r\nif (psta->ra_mask & 0xffc00000)\r\nrf_type = RF_2T2R;\r\n} else if (IsSupportedHT(psta->wireless_mode)) {\r\nif (psta->ra_mask & 0xfff00000)\r\nrf_type = RF_2T2R;\r\n}\r\nswitch (psta->wireless_mode) {\r\ncase WIRELESS_11B:\r\nraid = RATEID_IDX_B;\r\nbreak;\r\ncase WIRELESS_11A:\r\ncase WIRELESS_11G:\r\nraid = RATEID_IDX_G;\r\nbreak;\r\ncase WIRELESS_11BG:\r\nraid = RATEID_IDX_BG;\r\nbreak;\r\ncase WIRELESS_11_24N:\r\ncase WIRELESS_11_5N:\r\ncase WIRELESS_11A_5N:\r\ncase WIRELESS_11G_24N:\r\nif (rf_type == RF_2T2R)\r\nraid = RATEID_IDX_GN_N2SS;\r\nelse\r\nraid = RATEID_IDX_GN_N1SS;\r\nbreak;\r\ncase WIRELESS_11B_24N:\r\ncase WIRELESS_11BG_24N:\r\nif (psta->bw_mode == CHANNEL_WIDTH_20) {\r\nif (rf_type == RF_2T2R)\r\nraid = RATEID_IDX_BGN_20M_2SS_BN;\r\nelse\r\nraid = RATEID_IDX_BGN_20M_1SS_BN;\r\n} else {\r\nif (rf_type == RF_2T2R)\r\nraid = RATEID_IDX_BGN_40M_2SS;\r\nelse\r\nraid = RATEID_IDX_BGN_40M_1SS;\r\n}\r\nbreak;\r\ndefault:\r\nraid = RATEID_IDX_BGN_40M_2SS;\r\nbreak;\r\n}\r\nreturn raid;\r\n}\r\nunsigned char ratetbl_val_2wifirate(unsigned char rate)\r\n{\r\nunsigned char val = 0;\r\nswitch (rate & 0x7f) {\r\ncase 0:\r\nval = IEEE80211_CCK_RATE_1MB;\r\nbreak;\r\ncase 1:\r\nval = IEEE80211_CCK_RATE_2MB;\r\nbreak;\r\ncase 2:\r\nval = IEEE80211_CCK_RATE_5MB;\r\nbreak;\r\ncase 3:\r\nval = IEEE80211_CCK_RATE_11MB;\r\nbreak;\r\ncase 4:\r\nval = IEEE80211_OFDM_RATE_6MB;\r\nbreak;\r\ncase 5:\r\nval = IEEE80211_OFDM_RATE_9MB;\r\nbreak;\r\ncase 6:\r\nval = IEEE80211_OFDM_RATE_12MB;\r\nbreak;\r\ncase 7:\r\nval = IEEE80211_OFDM_RATE_18MB;\r\nbreak;\r\ncase 8:\r\nval = IEEE80211_OFDM_RATE_24MB;\r\nbreak;\r\ncase 9:\r\nval = IEEE80211_OFDM_RATE_36MB;\r\nbreak;\r\ncase 10:\r\nval = IEEE80211_OFDM_RATE_48MB;\r\nbreak;\r\ncase 11:\r\nval = IEEE80211_OFDM_RATE_54MB;\r\nbreak;\r\n}\r\nreturn val;\r\n}\r\nint is_basicrate(struct adapter *padapter, unsigned char rate)\r\n{\r\nint i;\r\nunsigned char val;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nfor (i = 0; i < NumRates; i++) {\r\nval = pmlmeext->basicrate[i];\r\nif ((val != 0xff) && (val != 0xfe))\r\nif (rate == ratetbl_val_2wifirate(val))\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nunsigned int ratetbl2rateset(struct adapter *padapter, unsigned char *rateset)\r\n{\r\nint i;\r\nunsigned char rate;\r\nunsigned int len = 0;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nfor (i = 0; i < NumRates; i++) {\r\nrate = pmlmeext->datarate[i];\r\nswitch (rate) {\r\ncase 0xff:\r\nreturn len;\r\ncase 0xfe:\r\ncontinue;\r\ndefault:\r\nrate = ratetbl_val_2wifirate(rate);\r\nif (is_basicrate(padapter, rate) == true)\r\nrate |= IEEE80211_BASIC_RATE_MASK;\r\nrateset[len] = rate;\r\nlen++;\r\nbreak;\r\n}\r\n}\r\nreturn len;\r\n}\r\nvoid get_rate_set(struct adapter *padapter, unsigned char *pbssrate, int *bssrate_len)\r\n{\r\nunsigned char supportedrates[NumRates];\r\nmemset(supportedrates, 0, NumRates);\r\n*bssrate_len = ratetbl2rateset(padapter, supportedrates);\r\nmemcpy(pbssrate, supportedrates, *bssrate_len);\r\n}\r\nvoid set_mcs_rate_by_mask(u8 *mcs_set, u32 mask)\r\n{\r\nu8 mcs_rate_1r = (u8)(mask&0xff);\r\nu8 mcs_rate_2r = (u8)((mask>>8)&0xff);\r\nu8 mcs_rate_3r = (u8)((mask>>16)&0xff);\r\nu8 mcs_rate_4r = (u8)((mask>>24)&0xff);\r\nmcs_set[0] &= mcs_rate_1r;\r\nmcs_set[1] &= mcs_rate_2r;\r\nmcs_set[2] &= mcs_rate_3r;\r\nmcs_set[3] &= mcs_rate_4r;\r\n}\r\nvoid UpdateBrateTbl(struct adapter *Adapter, u8 *mBratesOS)\r\n{\r\nu8 i;\r\nu8 rate;\r\nfor (i = 0; i < NDIS_802_11_LENGTH_RATES_EX; i++) {\r\nrate = mBratesOS[i] & 0x7f;\r\nswitch (rate) {\r\ncase IEEE80211_CCK_RATE_1MB:\r\ncase IEEE80211_CCK_RATE_2MB:\r\ncase IEEE80211_CCK_RATE_5MB:\r\ncase IEEE80211_CCK_RATE_11MB:\r\ncase IEEE80211_OFDM_RATE_6MB:\r\ncase IEEE80211_OFDM_RATE_12MB:\r\ncase IEEE80211_OFDM_RATE_24MB:\r\nmBratesOS[i] |= IEEE80211_BASIC_RATE_MASK;\r\nbreak;\r\n}\r\n}\r\n}\r\nvoid UpdateBrateTblForSoftAP(u8 *bssrateset, u32 bssratelen)\r\n{\r\nu8 i;\r\nu8 rate;\r\nfor (i = 0; i < bssratelen; i++) {\r\nrate = bssrateset[i] & 0x7f;\r\nswitch (rate) {\r\ncase IEEE80211_CCK_RATE_1MB:\r\ncase IEEE80211_CCK_RATE_2MB:\r\ncase IEEE80211_CCK_RATE_5MB:\r\ncase IEEE80211_CCK_RATE_11MB:\r\nbssrateset[i] |= IEEE80211_BASIC_RATE_MASK;\r\nbreak;\r\n}\r\n}\r\n}\r\nvoid Save_DM_Func_Flag(struct adapter *padapter)\r\n{\r\nu8 bSaveFlag = true;\r\nrtw_hal_set_hwreg(padapter, HW_VAR_DM_FUNC_OP, (u8 *)(&bSaveFlag));\r\n}\r\nvoid Restore_DM_Func_Flag(struct adapter *padapter)\r\n{\r\nu8 bSaveFlag = false;\r\nrtw_hal_set_hwreg(padapter, HW_VAR_DM_FUNC_OP, (u8 *)(&bSaveFlag));\r\n}\r\nvoid Switch_DM_Func(struct adapter *padapter, u32 mode, u8 enable)\r\n{\r\nif (enable == true)\r\nrtw_hal_set_hwreg(padapter, HW_VAR_DM_FUNC_SET, (u8 *)(&mode));\r\nelse\r\nrtw_hal_set_hwreg(padapter, HW_VAR_DM_FUNC_CLR, (u8 *)(&mode));\r\n}\r\nstatic void Set_NETYPE0_MSR(struct adapter *padapter, u8 type)\r\n{\r\nrtw_hal_set_hwreg(padapter, HW_VAR_MEDIA_STATUS, (u8 *)(&type));\r\n}\r\nvoid Set_MSR(struct adapter *padapter, u8 type)\r\n{\r\nSet_NETYPE0_MSR(padapter, type);\r\n}\r\ninline u8 rtw_get_oper_ch(struct adapter *adapter)\r\n{\r\nreturn adapter_to_dvobj(adapter)->oper_channel;\r\n}\r\ninline void rtw_set_oper_ch(struct adapter *adapter, u8 ch)\r\n{\r\n#ifdef DBG_CH_SWITCH\r\nconst int len = 128;\r\nchar msg[128] = {0};\r\nint cnt = 0;\r\nint i = 0;\r\n#endif\r\nstruct dvobj_priv *dvobj = adapter_to_dvobj(adapter);\r\nif (dvobj->oper_channel != ch) {\r\ndvobj->on_oper_ch_time = jiffies;\r\n#ifdef DBG_CH_SWITCH\r\ncnt += snprintf(msg+cnt, len-cnt, "switch to ch %3u", ch);\r\nfor (i = 0; i < dvobj->iface_nums; i++) {\r\nstruct adapter *iface = dvobj->padapters[i];\r\ncnt += snprintf(msg+cnt, len-cnt, " ["ADPT_FMT":", ADPT_ARG(iface));\r\nif (iface->mlmeextpriv.cur_channel == ch)\r\ncnt += snprintf(msg+cnt, len-cnt, "C");\r\nelse\r\ncnt += snprintf(msg+cnt, len-cnt, "_");\r\nif (iface->wdinfo.listen_channel == ch && !rtw_p2p_chk_state(&iface->wdinfo, P2P_STATE_NONE))\r\ncnt += snprintf(msg+cnt, len-cnt, "L");\r\nelse\r\ncnt += snprintf(msg+cnt, len-cnt, "_");\r\ncnt += snprintf(msg+cnt, len-cnt, "]");\r\n}\r\nDBG_871X(FUNC_ADPT_FMT" %s\n", FUNC_ADPT_ARG(adapter), msg);\r\n#endif\r\n}\r\ndvobj->oper_channel = ch;\r\n}\r\ninline u8 rtw_get_oper_bw(struct adapter *adapter)\r\n{\r\nreturn adapter_to_dvobj(adapter)->oper_bwmode;\r\n}\r\ninline void rtw_set_oper_bw(struct adapter *adapter, u8 bw)\r\n{\r\nadapter_to_dvobj(adapter)->oper_bwmode = bw;\r\n}\r\ninline u8 rtw_get_oper_choffset(struct adapter *adapter)\r\n{\r\nreturn adapter_to_dvobj(adapter)->oper_ch_offset;\r\n}\r\ninline void rtw_set_oper_choffset(struct adapter *adapter, u8 offset)\r\n{\r\nadapter_to_dvobj(adapter)->oper_ch_offset = offset;\r\n}\r\nu8 rtw_get_center_ch(u8 channel, u8 chnl_bw, u8 chnl_offset)\r\n{\r\nu8 center_ch = channel;\r\nif (chnl_bw == CHANNEL_WIDTH_80) {\r\nif ((channel == 36) || (channel == 40) || (channel == 44) || (channel == 48))\r\ncenter_ch = 42;\r\nif ((channel == 52) || (channel == 56) || (channel == 60) || (channel == 64))\r\ncenter_ch = 58;\r\nif ((channel == 100) || (channel == 104) || (channel == 108) || (channel == 112))\r\ncenter_ch = 106;\r\nif ((channel == 116) || (channel == 120) || (channel == 124) || (channel == 128))\r\ncenter_ch = 122;\r\nif ((channel == 132) || (channel == 136) || (channel == 140) || (channel == 144))\r\ncenter_ch = 138;\r\nif ((channel == 149) || (channel == 153) || (channel == 157) || (channel == 161))\r\ncenter_ch = 155;\r\nelse if (channel <= 14)\r\ncenter_ch = 7;\r\n} else if (chnl_bw == CHANNEL_WIDTH_40) {\r\nif (chnl_offset == HAL_PRIME_CHNL_OFFSET_LOWER)\r\ncenter_ch = channel + 2;\r\nelse\r\ncenter_ch = channel - 2;\r\n}\r\nreturn center_ch;\r\n}\r\ninline unsigned long rtw_get_on_cur_ch_time(struct adapter *adapter)\r\n{\r\nif (adapter->mlmeextpriv.cur_channel == adapter_to_dvobj(adapter)->oper_channel)\r\nreturn adapter_to_dvobj(adapter)->on_oper_ch_time;\r\nelse\r\nreturn 0;\r\n}\r\nvoid SelectChannel(struct adapter *padapter, unsigned char channel)\r\n{\r\nif (mutex_lock_interruptible(&(adapter_to_dvobj(padapter)->setch_mutex)))\r\nreturn;\r\nrtw_set_oper_ch(padapter, channel);\r\nrtw_hal_set_chan(padapter, channel);\r\nmutex_unlock(&(adapter_to_dvobj(padapter)->setch_mutex));\r\n}\r\nvoid set_channel_bwmode(struct adapter *padapter, unsigned char channel, unsigned char channel_offset, unsigned short bwmode)\r\n{\r\nu8 center_ch, chnl_offset80 = HAL_PRIME_CHNL_OFFSET_DONT_CARE;\r\nif (padapter->bNotifyChannelChange)\r\nDBG_871X("[%s] ch = %d, offset = %d, bwmode = %d\n", __func__, channel, channel_offset, bwmode);\r\ncenter_ch = rtw_get_center_ch(channel, bwmode, channel_offset);\r\nif (bwmode == CHANNEL_WIDTH_80) {\r\nif (center_ch > channel)\r\nchnl_offset80 = HAL_PRIME_CHNL_OFFSET_LOWER;\r\nelse if (center_ch < channel)\r\nchnl_offset80 = HAL_PRIME_CHNL_OFFSET_UPPER;\r\nelse\r\nchnl_offset80 = HAL_PRIME_CHNL_OFFSET_DONT_CARE;\r\n}\r\nif (mutex_lock_interruptible(&(adapter_to_dvobj(padapter)->setch_mutex)))\r\nreturn;\r\nrtw_set_oper_ch(padapter, channel);\r\nrtw_set_oper_bw(padapter, bwmode);\r\nrtw_set_oper_choffset(padapter, channel_offset);\r\nrtw_hal_set_chnl_bw(padapter, center_ch, bwmode, channel_offset, chnl_offset80);\r\nmutex_unlock(&(adapter_to_dvobj(padapter)->setch_mutex));\r\n}\r\n__inline u8 *get_my_bssid(struct wlan_bssid_ex *pnetwork)\r\n{\r\nreturn pnetwork->MacAddress;\r\n}\r\nu16 get_beacon_interval(struct wlan_bssid_ex *bss)\r\n{\r\n__le16 val;\r\nmemcpy((unsigned char *)&val, rtw_get_beacon_interval_from_ie(bss->IEs), 2);\r\nreturn le16_to_cpu(val);\r\n}\r\nint is_client_associated_to_ap(struct adapter *padapter)\r\n{\r\nstruct mlme_ext_priv *pmlmeext;\r\nstruct mlme_ext_info *pmlmeinfo;\r\nif (!padapter)\r\nreturn _FAIL;\r\npmlmeext = &padapter->mlmeextpriv;\r\npmlmeinfo = &(pmlmeext->mlmext_info);\r\nif ((pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS) && ((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE))\r\nreturn true;\r\nelse\r\nreturn _FAIL;\r\n}\r\nint is_client_associated_to_ibss(struct adapter *padapter)\r\n{\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nif ((pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS) && ((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE))\r\nreturn true;\r\nelse\r\nreturn _FAIL;\r\n}\r\nint is_IBSS_empty(struct adapter *padapter)\r\n{\r\nunsigned int i;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nfor (i = IBSS_START_MAC_ID; i < NUM_STA; i++) {\r\nif (pmlmeinfo->FW_sta_info[i].status == 1)\r\nreturn _FAIL;\r\n}\r\nreturn true;\r\n}\r\nunsigned int decide_wait_for_beacon_timeout(unsigned int bcn_interval)\r\n{\r\nif ((bcn_interval << 2) < WAIT_FOR_BCN_TO_MIN)\r\nreturn WAIT_FOR_BCN_TO_MIN;\r\nelse if ((bcn_interval << 2) > WAIT_FOR_BCN_TO_MAX)\r\nreturn WAIT_FOR_BCN_TO_MAX;\r\nelse\r\nreturn ((bcn_interval << 2));\r\n}\r\nvoid invalidate_cam_all(struct adapter *padapter)\r\n{\r\nstruct dvobj_priv *dvobj = adapter_to_dvobj(padapter);\r\nstruct cam_ctl_t *cam_ctl = &dvobj->cam_ctl;\r\nrtw_hal_set_hwreg(padapter, HW_VAR_CAM_INVALID_ALL, NULL);\r\nspin_lock_bh(&cam_ctl->lock);\r\ncam_ctl->bitmap = 0;\r\nmemset(dvobj->cam_cache, 0, sizeof(struct cam_entry_cache)*TOTAL_CAM_ENTRY);\r\nspin_unlock_bh(&cam_ctl->lock);\r\n}\r\nstatic u32 _ReadCAM(struct adapter *padapter, u32 addr)\r\n{\r\nu32 count = 0, cmd;\r\ncmd = CAM_POLLINIG | addr;\r\nrtw_write32(padapter, RWCAM, cmd);\r\ndo {\r\nif (0 == (rtw_read32(padapter, REG_CAMCMD) & CAM_POLLINIG))\r\nbreak;\r\n} while (count++ < 100);\r\nreturn rtw_read32(padapter, REG_CAMREAD);\r\n}\r\nvoid read_cam(struct adapter *padapter, u8 entry, u8 *get_key)\r\n{\r\nu32 j, addr, cmd;\r\naddr = entry << 3;\r\nfor (j = 0; j < 6; j++) {\r\ncmd = _ReadCAM(padapter, addr+j);\r\nif (j > 1)\r\nmemcpy(get_key+(j-2)*4, &cmd, 4);\r\n}\r\n}\r\nvoid _write_cam(struct adapter *padapter, u8 entry, u16 ctrl, u8 *mac, u8 *key)\r\n{\r\nunsigned int i, val, addr;\r\nint j;\r\nu32 cam_val[2];\r\naddr = entry << 3;\r\nfor (j = 5; j >= 0; j--) {\r\nswitch (j) {\r\ncase 0:\r\nval = (ctrl | (mac[0] << 16) | (mac[1] << 24));\r\nbreak;\r\ncase 1:\r\nval = (mac[2] | (mac[3] << 8) | (mac[4] << 16) | (mac[5] << 24));\r\nbreak;\r\ndefault:\r\ni = (j - 2) << 2;\r\nval = (key[i] | (key[i+1] << 8) | (key[i+2] << 16) | (key[i+3] << 24));\r\nbreak;\r\n}\r\ncam_val[0] = val;\r\ncam_val[1] = addr + (unsigned int)j;\r\nrtw_hal_set_hwreg(padapter, HW_VAR_CAM_WRITE, (u8 *)cam_val);\r\n}\r\n}\r\nvoid _clear_cam_entry(struct adapter *padapter, u8 entry)\r\n{\r\nunsigned char null_sta[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\r\nunsigned char null_key[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\r\n_write_cam(padapter, entry, 0, null_sta, null_key);\r\n}\r\ninline void write_cam(struct adapter *adapter, u8 id, u16 ctrl, u8 *mac, u8 *key)\r\n{\r\n_write_cam(adapter, id, ctrl, mac, key);\r\nwrite_cam_cache(adapter, id, ctrl, mac, key);\r\n}\r\ninline void clear_cam_entry(struct adapter *adapter, u8 id)\r\n{\r\n_clear_cam_entry(adapter, id);\r\nclear_cam_cache(adapter, id);\r\n}\r\ninline void write_cam_from_cache(struct adapter *adapter, u8 id)\r\n{\r\nstruct dvobj_priv *dvobj = adapter_to_dvobj(adapter);\r\nstruct cam_ctl_t *cam_ctl = &dvobj->cam_ctl;\r\nstruct cam_entry_cache cache;\r\nspin_lock_bh(&cam_ctl->lock);\r\nmemcpy(&cache, &dvobj->cam_cache[id], sizeof(struct cam_entry_cache));\r\nspin_unlock_bh(&cam_ctl->lock);\r\n_write_cam(adapter, id, cache.ctrl, cache.mac, cache.key);\r\n}\r\nvoid write_cam_cache(struct adapter *adapter, u8 id, u16 ctrl, u8 *mac, u8 *key)\r\n{\r\nstruct dvobj_priv *dvobj = adapter_to_dvobj(adapter);\r\nstruct cam_ctl_t *cam_ctl = &dvobj->cam_ctl;\r\nspin_lock_bh(&cam_ctl->lock);\r\ndvobj->cam_cache[id].ctrl = ctrl;\r\nmemcpy(dvobj->cam_cache[id].mac, mac, ETH_ALEN);\r\nmemcpy(dvobj->cam_cache[id].key, key, 16);\r\nspin_unlock_bh(&cam_ctl->lock);\r\n}\r\nvoid clear_cam_cache(struct adapter *adapter, u8 id)\r\n{\r\nstruct dvobj_priv *dvobj = adapter_to_dvobj(adapter);\r\nstruct cam_ctl_t *cam_ctl = &dvobj->cam_ctl;\r\nspin_lock_bh(&cam_ctl->lock);\r\nmemset(&(dvobj->cam_cache[id]), 0, sizeof(struct cam_entry_cache));\r\nspin_unlock_bh(&cam_ctl->lock);\r\n}\r\nstatic bool _rtw_camid_is_gk(struct adapter *adapter, u8 cam_id)\r\n{\r\nstruct dvobj_priv *dvobj = adapter_to_dvobj(adapter);\r\nstruct cam_ctl_t *cam_ctl = &dvobj->cam_ctl;\r\nbool ret = false;\r\nif (cam_id >= TOTAL_CAM_ENTRY)\r\ngoto exit;\r\nif (!(cam_ctl->bitmap & BIT(cam_id)))\r\ngoto exit;\r\nret = (dvobj->cam_cache[cam_id].ctrl&BIT6)?true:false;\r\nexit:\r\nreturn ret;\r\n}\r\nstatic s16 _rtw_camid_search(struct adapter *adapter, u8 *addr, s16 kid)\r\n{\r\nstruct dvobj_priv *dvobj = adapter_to_dvobj(adapter);\r\nint i;\r\ns16 cam_id = -1;\r\nfor (i = 0; i < TOTAL_CAM_ENTRY; i++) {\r\nif (addr && memcmp(dvobj->cam_cache[i].mac, addr, ETH_ALEN))\r\ncontinue;\r\nif (kid >= 0 && kid != (dvobj->cam_cache[i].ctrl&0x03))\r\ncontinue;\r\ncam_id = i;\r\nbreak;\r\n}\r\nif (addr)\r\nDBG_871X(FUNC_ADPT_FMT" addr:"MAC_FMT" kid:%d, return cam_id:%d\n"\r\n, FUNC_ADPT_ARG(adapter), MAC_ARG(addr), kid, cam_id);\r\nelse\r\nDBG_871X(FUNC_ADPT_FMT" addr:%p kid:%d, return cam_id:%d\n"\r\n, FUNC_ADPT_ARG(adapter), addr, kid, cam_id);\r\nreturn cam_id;\r\n}\r\ns16 rtw_camid_search(struct adapter *adapter, u8 *addr, s16 kid)\r\n{\r\nstruct dvobj_priv *dvobj = adapter_to_dvobj(adapter);\r\nstruct cam_ctl_t *cam_ctl = &dvobj->cam_ctl;\r\ns16 cam_id = -1;\r\nspin_lock_bh(&cam_ctl->lock);\r\ncam_id = _rtw_camid_search(adapter, addr, kid);\r\nspin_unlock_bh(&cam_ctl->lock);\r\nreturn cam_id;\r\n}\r\ns16 rtw_camid_alloc(struct adapter *adapter, struct sta_info *sta, u8 kid)\r\n{\r\nstruct dvobj_priv *dvobj = adapter_to_dvobj(adapter);\r\nstruct cam_ctl_t *cam_ctl = &dvobj->cam_ctl;\r\ns16 cam_id = -1;\r\nstruct mlme_ext_info *mlmeinfo;\r\nspin_lock_bh(&cam_ctl->lock);\r\nmlmeinfo = &adapter->mlmeextpriv.mlmext_info;\r\nif ((((mlmeinfo->state&0x03) == WIFI_FW_AP_STATE) || ((mlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE))\r\n&& !sta) {\r\nif (kid > 3) {\r\nDBG_871X_LEVEL(_drv_always_, FUNC_ADPT_FMT" group key with invalid key id:%u\n"\r\n, FUNC_ADPT_ARG(adapter), kid);\r\nrtw_warn_on(1);\r\ngoto bitmap_handle;\r\n}\r\ncam_id = kid;\r\n} else {\r\nint i;\r\nu8 *addr = sta?sta->hwaddr:NULL;\r\nif (!sta) {\r\nif (!(mlmeinfo->state & WIFI_FW_ASSOC_SUCCESS)) {\r\ngoto bitmap_handle;\r\n}\r\naddr = get_bssid(&adapter->mlmepriv);\r\n}\r\ni = _rtw_camid_search(adapter, addr, kid);\r\nif (i >= 0) {\r\nif (sta || _rtw_camid_is_gk(adapter, i) == true)\r\ncam_id = i;\r\nelse\r\nDBG_871X_LEVEL(_drv_always_, FUNC_ADPT_FMT" group key id:%u the same key id as pairwise key\n"\r\n, FUNC_ADPT_ARG(adapter), kid);\r\ngoto bitmap_handle;\r\n}\r\nfor (i = 4; i < TOTAL_CAM_ENTRY; i++)\r\nif (!(cam_ctl->bitmap & BIT(i)))\r\nbreak;\r\nif (i == TOTAL_CAM_ENTRY) {\r\nif (sta)\r\nDBG_871X_LEVEL(_drv_always_, FUNC_ADPT_FMT" pairwise key with "MAC_FMT" id:%u no room\n"\r\n, FUNC_ADPT_ARG(adapter), MAC_ARG(sta->hwaddr), kid);\r\nelse\r\nDBG_871X_LEVEL(_drv_always_, FUNC_ADPT_FMT" group key id:%u no room\n"\r\n, FUNC_ADPT_ARG(adapter), kid);\r\nrtw_warn_on(1);\r\ngoto bitmap_handle;\r\n}\r\ncam_id = i;\r\n}\r\nbitmap_handle:\r\nif (cam_id >= 0 && cam_id < 32)\r\ncam_ctl->bitmap |= BIT(cam_id);\r\nspin_unlock_bh(&cam_ctl->lock);\r\nreturn cam_id;\r\n}\r\nvoid rtw_camid_free(struct adapter *adapter, u8 cam_id)\r\n{\r\nstruct dvobj_priv *dvobj = adapter_to_dvobj(adapter);\r\nstruct cam_ctl_t *cam_ctl = &dvobj->cam_ctl;\r\nspin_lock_bh(&cam_ctl->lock);\r\nif (cam_id < TOTAL_CAM_ENTRY)\r\ncam_ctl->bitmap &= ~(BIT(cam_id));\r\nspin_unlock_bh(&cam_ctl->lock);\r\n}\r\nint allocate_fw_sta_entry(struct adapter *padapter)\r\n{\r\nunsigned int mac_id;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nfor (mac_id = IBSS_START_MAC_ID; mac_id < NUM_STA; mac_id++) {\r\nif (pmlmeinfo->FW_sta_info[mac_id].status == 0) {\r\npmlmeinfo->FW_sta_info[mac_id].status = 1;\r\npmlmeinfo->FW_sta_info[mac_id].retry = 0;\r\nbreak;\r\n}\r\n}\r\nreturn mac_id;\r\n}\r\nvoid flush_all_cam_entry(struct adapter *padapter)\r\n{\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\ninvalidate_cam_all(padapter);\r\nrtw_hal_set_hwreg(padapter, HW_VAR_SEC_DK_CFG, (u8 *)false);\r\nmemset((u8 *)(pmlmeinfo->FW_sta_info), 0, sizeof(pmlmeinfo->FW_sta_info));\r\n}\r\nint WMM_param_handler(struct adapter *padapter, struct ndis_80211_var_ie *pIE)\r\n{\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nif (pmlmepriv->qospriv.qos_option == 0) {\r\npmlmeinfo->WMM_enable = 0;\r\nreturn false;\r\n}\r\nif (!memcmp(&(pmlmeinfo->WMM_param), (pIE->data + 6), sizeof(struct WMM_para_element)))\r\nreturn false;\r\nelse\r\nmemcpy(&(pmlmeinfo->WMM_param), (pIE->data + 6), sizeof(struct WMM_para_element));\r\npmlmeinfo->WMM_enable = 1;\r\nreturn true;\r\n}\r\nvoid WMMOnAssocRsp(struct adapter *padapter)\r\n{\r\nu8 ACI, ACM, AIFS, ECWMin, ECWMax, aSifsTime;\r\nu8 acm_mask;\r\nu16 TXOP;\r\nu32 acParm, i;\r\nu32 edca[4], inx[4];\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nstruct registry_priv *pregpriv = &padapter->registrypriv;\r\nacm_mask = 0;\r\nif (pmlmeext->cur_wireless_mode & WIRELESS_11_24N)\r\naSifsTime = 16;\r\nelse\r\naSifsTime = 10;\r\nif (pmlmeinfo->WMM_enable == 0) {\r\npadapter->mlmepriv.acm_mask = 0;\r\nAIFS = aSifsTime + (2 * pmlmeinfo->slotTime);\r\nif (pmlmeext->cur_wireless_mode & (WIRELESS_11G | WIRELESS_11A)) {\r\nECWMin = 4;\r\nECWMax = 10;\r\n} else if (pmlmeext->cur_wireless_mode & WIRELESS_11B) {\r\nECWMin = 5;\r\nECWMax = 10;\r\n} else {\r\nECWMin = 4;\r\nECWMax = 10;\r\n}\r\nTXOP = 0;\r\nacParm = AIFS | (ECWMin << 8) | (ECWMax << 12) | (TXOP << 16);\r\nrtw_hal_set_hwreg(padapter, HW_VAR_AC_PARAM_BE, (u8 *)(&acParm));\r\nrtw_hal_set_hwreg(padapter, HW_VAR_AC_PARAM_BK, (u8 *)(&acParm));\r\nrtw_hal_set_hwreg(padapter, HW_VAR_AC_PARAM_VI, (u8 *)(&acParm));\r\nECWMin = 2;\r\nECWMax = 3;\r\nTXOP = 0x2f;\r\nacParm = AIFS | (ECWMin << 8) | (ECWMax << 12) | (TXOP << 16);\r\nrtw_hal_set_hwreg(padapter, HW_VAR_AC_PARAM_VO, (u8 *)(&acParm));\r\n} else{\r\nedca[0] = edca[1] = edca[2] = edca[3] = 0;\r\nfor (i = 0; i < 4; i++) {\r\nACI = (pmlmeinfo->WMM_param.ac_param[i].ACI_AIFSN >> 5) & 0x03;\r\nACM = (pmlmeinfo->WMM_param.ac_param[i].ACI_AIFSN >> 4) & 0x01;\r\nAIFS = (pmlmeinfo->WMM_param.ac_param[i].ACI_AIFSN & 0x0f) * pmlmeinfo->slotTime + aSifsTime;\r\nECWMin = (pmlmeinfo->WMM_param.ac_param[i].CW & 0x0f);\r\nECWMax = (pmlmeinfo->WMM_param.ac_param[i].CW & 0xf0) >> 4;\r\nTXOP = le16_to_cpu(pmlmeinfo->WMM_param.ac_param[i].TXOP_limit);\r\nacParm = AIFS | (ECWMin << 8) | (ECWMax << 12) | (TXOP << 16);\r\nswitch (ACI) {\r\ncase 0x0:\r\nrtw_hal_set_hwreg(padapter, HW_VAR_AC_PARAM_BE, (u8 *)(&acParm));\r\nacm_mask |= (ACM ? BIT(1):0);\r\nedca[XMIT_BE_QUEUE] = acParm;\r\nbreak;\r\ncase 0x1:\r\nrtw_hal_set_hwreg(padapter, HW_VAR_AC_PARAM_BK, (u8 *)(&acParm));\r\nedca[XMIT_BK_QUEUE] = acParm;\r\nbreak;\r\ncase 0x2:\r\nrtw_hal_set_hwreg(padapter, HW_VAR_AC_PARAM_VI, (u8 *)(&acParm));\r\nacm_mask |= (ACM ? BIT(2):0);\r\nedca[XMIT_VI_QUEUE] = acParm;\r\nbreak;\r\ncase 0x3:\r\nrtw_hal_set_hwreg(padapter, HW_VAR_AC_PARAM_VO, (u8 *)(&acParm));\r\nacm_mask |= (ACM ? BIT(3):0);\r\nedca[XMIT_VO_QUEUE] = acParm;\r\nbreak;\r\n}\r\nDBG_871X("WMM(%x): %x, %x\n", ACI, ACM, acParm);\r\n}\r\nif (padapter->registrypriv.acm_method == 1)\r\nrtw_hal_set_hwreg(padapter, HW_VAR_ACM_CTRL, (u8 *)(&acm_mask));\r\nelse\r\npadapter->mlmepriv.acm_mask = acm_mask;\r\ninx[0] = 0; inx[1] = 1; inx[2] = 2; inx[3] = 3;\r\nif (pregpriv->wifi_spec == 1) {\r\nu32 j, tmp, change_inx = false;\r\nfor (i = 0; i < 4; i++) {\r\nfor (j = i+1; j < 4; j++) {\r\nif ((edca[j] & 0xFFFF) < (edca[i] & 0xFFFF)) {\r\nchange_inx = true;\r\n} else if ((edca[j] & 0xFFFF) == (edca[i] & 0xFFFF)) {\r\nif ((edca[j] >> 16) > (edca[i] >> 16))\r\nchange_inx = true;\r\n}\r\nif (change_inx) {\r\ntmp = edca[i];\r\nedca[i] = edca[j];\r\nedca[j] = tmp;\r\ntmp = inx[i];\r\ninx[i] = inx[j];\r\ninx[j] = tmp;\r\nchange_inx = false;\r\n}\r\n}\r\n}\r\n}\r\nfor (i = 0; i < 4; i++) {\r\npxmitpriv->wmm_para_seq[i] = inx[i];\r\nDBG_871X("wmm_para_seq(%d): %d\n", i, pxmitpriv->wmm_para_seq[i]);\r\n}\r\n}\r\n}\r\nstatic void bwmode_update_check(struct adapter *padapter, struct ndis_80211_var_ie *pIE)\r\n{\r\nunsigned char new_bwmode;\r\nunsigned char new_ch_offset;\r\nstruct HT_info_element *pHT_info;\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nstruct registry_priv *pregistrypriv = &padapter->registrypriv;\r\nstruct ht_priv *phtpriv = &pmlmepriv->htpriv;\r\nu8 cbw40_enable = 0;\r\nif (!pIE)\r\nreturn;\r\nif (phtpriv->ht_option == false)\r\nreturn;\r\nif (pmlmeext->cur_bwmode >= CHANNEL_WIDTH_80)\r\nreturn;\r\nif (pIE->Length > sizeof(struct HT_info_element))\r\nreturn;\r\npHT_info = (struct HT_info_element *)pIE->data;\r\nif (pmlmeext->cur_channel > 14) {\r\nif ((pregistrypriv->bw_mode & 0xf0) > 0)\r\ncbw40_enable = 1;\r\n} else\r\nif ((pregistrypriv->bw_mode & 0x0f) > 0)\r\ncbw40_enable = 1;\r\nif ((pHT_info->infos[0] & BIT(2)) && cbw40_enable) {\r\nnew_bwmode = CHANNEL_WIDTH_40;\r\nswitch (pHT_info->infos[0] & 0x3) {\r\ncase 1:\r\nnew_ch_offset = HAL_PRIME_CHNL_OFFSET_LOWER;\r\nbreak;\r\ncase 3:\r\nnew_ch_offset = HAL_PRIME_CHNL_OFFSET_UPPER;\r\nbreak;\r\ndefault:\r\nnew_bwmode = CHANNEL_WIDTH_20;\r\nnew_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;\r\nbreak;\r\n}\r\n} else{\r\nnew_bwmode = CHANNEL_WIDTH_20;\r\nnew_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;\r\n}\r\nif ((new_bwmode != pmlmeext->cur_bwmode) || (new_ch_offset != pmlmeext->cur_ch_offset)) {\r\npmlmeinfo->bwmode_updated = true;\r\npmlmeext->cur_bwmode = new_bwmode;\r\npmlmeext->cur_ch_offset = new_ch_offset;\r\nHT_info_handler(padapter, pIE);\r\n} else\r\npmlmeinfo->bwmode_updated = false;\r\nif (true == pmlmeinfo->bwmode_updated) {\r\nstruct sta_info *psta;\r\nstruct wlan_bssid_ex *cur_network = &(pmlmeinfo->network);\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\npsta = rtw_get_stainfo(pstapriv, cur_network->MacAddress);\r\nif (psta) {\r\nstruct ht_priv *phtpriv_sta = &psta->htpriv;\r\nif (phtpriv_sta->ht_option) {\r\npsta->bw_mode = pmlmeext->cur_bwmode;\r\nphtpriv_sta->ch_offset = pmlmeext->cur_ch_offset;\r\n} else{\r\npsta->bw_mode = CHANNEL_WIDTH_20;\r\nphtpriv_sta->ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;\r\n}\r\nrtw_dm_ra_mask_wk_cmd(padapter, (u8 *)psta);\r\n}\r\n}\r\n}\r\nvoid HT_caps_handler(struct adapter *padapter, struct ndis_80211_var_ie *pIE)\r\n{\r\nunsigned int i;\r\nu8 rf_type;\r\nu8 max_AMPDU_len, min_MPDU_spacing;\r\nu8 cur_ldpc_cap = 0, cur_stbc_cap = 0;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct ht_priv *phtpriv = &pmlmepriv->htpriv;\r\nif (pIE == NULL)\r\nreturn;\r\nif (phtpriv->ht_option == false)\r\nreturn;\r\npmlmeinfo->HT_caps_enable = 1;\r\nfor (i = 0; i < (pIE->Length); i++) {\r\nif (i != 2) {\r\npmlmeinfo->HT_caps.u.HT_cap[i] &= (pIE->data[i]);\r\n} else{\r\nif ((pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x3) > (pIE->data[i] & 0x3))\r\nmax_AMPDU_len = (pIE->data[i] & 0x3);\r\nelse\r\nmax_AMPDU_len = (pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x3);\r\nif ((pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x1c) > (pIE->data[i] & 0x1c))\r\nmin_MPDU_spacing = (pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x1c);\r\nelse\r\nmin_MPDU_spacing = (pIE->data[i] & 0x1c);\r\npmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para = max_AMPDU_len | min_MPDU_spacing;\r\n}\r\n}\r\nrtw_hal_get_hwreg(padapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));\r\nfor (i = 0; i < 16; i++)\r\npmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] &= pmlmeext->default_supported_mcs_set[i];\r\nswitch (rf_type) {\r\ncase RF_1T1R:\r\ncase RF_1T2R:\r\nset_mcs_rate_by_mask(pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate, MCS_RATE_1R);\r\nbreak;\r\ncase RF_2T2R:\r\ndefault:\r\n#ifdef CONFIG_DISABLE_MCS13TO15\r\nif (pmlmeext->cur_bwmode == CHANNEL_WIDTH_40 && pregistrypriv->wifi_spec != 1)\r\nset_mcs_rate_by_mask(pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate, MCS_RATE_2R_13TO15_OFF);\r\nelse\r\nset_mcs_rate_by_mask(pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate, MCS_RATE_2R);\r\n#else\r\nset_mcs_rate_by_mask(pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate, MCS_RATE_2R);\r\n#endif\r\n}\r\nif (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {\r\nif (TEST_FLAG(phtpriv->stbc_cap, STBC_HT_ENABLE_TX) && GET_HT_CAPABILITY_ELE_TX_STBC(pIE->data)) {\r\nSET_FLAG(cur_stbc_cap, STBC_HT_ENABLE_TX);\r\nDBG_871X("Enable HT Tx STBC !\n");\r\n}\r\nphtpriv->stbc_cap = cur_stbc_cap;\r\n} else {\r\nif (TEST_FLAG(phtpriv->ldpc_cap, LDPC_HT_ENABLE_TX) && GET_HT_CAPABILITY_ELE_LDPC_CAP(pIE->data)) {\r\nSET_FLAG(cur_ldpc_cap, (LDPC_HT_ENABLE_TX | LDPC_HT_CAP_TX));\r\nDBG_871X("Enable HT Tx LDPC!\n");\r\n}\r\nphtpriv->ldpc_cap = cur_ldpc_cap;\r\nif (TEST_FLAG(phtpriv->stbc_cap, STBC_HT_ENABLE_TX) && GET_HT_CAPABILITY_ELE_RX_STBC(pIE->data)) {\r\nSET_FLAG(cur_stbc_cap, (STBC_HT_ENABLE_TX | STBC_HT_CAP_TX));\r\nDBG_871X("Enable HT Tx STBC!\n");\r\n}\r\nphtpriv->stbc_cap = cur_stbc_cap;\r\n}\r\n}\r\nvoid HT_info_handler(struct adapter *padapter, struct ndis_80211_var_ie *pIE)\r\n{\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct ht_priv *phtpriv = &pmlmepriv->htpriv;\r\nif (pIE == NULL)\r\nreturn;\r\nif (phtpriv->ht_option == false)\r\nreturn;\r\nif (pIE->Length > sizeof(struct HT_info_element))\r\nreturn;\r\npmlmeinfo->HT_info_enable = 1;\r\nmemcpy(&(pmlmeinfo->HT_info), pIE->data, pIE->Length);\r\nreturn;\r\n}\r\nvoid HTOnAssocRsp(struct adapter *padapter)\r\n{\r\nunsigned char max_AMPDU_len;\r\nunsigned char min_MPDU_spacing;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nDBG_871X("%s\n", __func__);\r\nif ((pmlmeinfo->HT_info_enable) && (pmlmeinfo->HT_caps_enable)) {\r\npmlmeinfo->HT_enable = 1;\r\n} else{\r\npmlmeinfo->HT_enable = 0;\r\nreturn;\r\n}\r\nmax_AMPDU_len = pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x03;\r\nmin_MPDU_spacing = (pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x1c) >> 2;\r\nrtw_hal_set_hwreg(padapter, HW_VAR_AMPDU_MIN_SPACE, (u8 *)(&min_MPDU_spacing));\r\nrtw_hal_set_hwreg(padapter, HW_VAR_AMPDU_FACTOR, (u8 *)(&max_AMPDU_len));\r\n}\r\nvoid ERP_IE_handler(struct adapter *padapter, struct ndis_80211_var_ie *pIE)\r\n{\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nif (pIE->Length > 1)\r\nreturn;\r\npmlmeinfo->ERP_enable = 1;\r\nmemcpy(&(pmlmeinfo->ERP_IE), pIE->data, pIE->Length);\r\n}\r\nvoid VCS_update(struct adapter *padapter, struct sta_info *psta)\r\n{\r\nstruct registry_priv *pregpriv = &padapter->registrypriv;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nswitch (pregpriv->vrtl_carrier_sense) {\r\ncase 0:\r\npsta->rtsen = 0;\r\npsta->cts2self = 0;\r\nbreak;\r\ncase 1:\r\nif (pregpriv->vcs_type == 1) {\r\npsta->rtsen = 1;\r\npsta->cts2self = 0;\r\n} else{\r\npsta->rtsen = 0;\r\npsta->cts2self = 1;\r\n}\r\nbreak;\r\ncase 2:\r\ndefault:\r\nif ((pmlmeinfo->ERP_enable) && (pmlmeinfo->ERP_IE & BIT(1))) {\r\nif (pregpriv->vcs_type == 1) {\r\npsta->rtsen = 1;\r\npsta->cts2self = 0;\r\n} else{\r\npsta->rtsen = 0;\r\npsta->cts2self = 1;\r\n}\r\n} else{\r\npsta->rtsen = 0;\r\npsta->cts2self = 0;\r\n}\r\nbreak;\r\n}\r\n}\r\nvoid update_ldpc_stbc_cap(struct sta_info *psta)\r\n{\r\nif (psta->htpriv.ht_option) {\r\nif (TEST_FLAG(psta->htpriv.ldpc_cap, LDPC_HT_ENABLE_TX))\r\npsta->ldpc = 1;\r\nif (TEST_FLAG(psta->htpriv.stbc_cap, STBC_HT_ENABLE_TX))\r\npsta->stbc = 1;\r\n} else {\r\npsta->ldpc = 0;\r\npsta->stbc = 0;\r\n}\r\n}\r\nint rtw_check_bcn_info(struct adapter *Adapter, u8 *pframe, u32 packet_len)\r\n{\r\nunsigned int len;\r\nunsigned char *p;\r\nunsigned short val16, subtype;\r\nstruct wlan_network *cur_network = &(Adapter->mlmepriv.cur_network);\r\nu16 wpa_len = 0, rsn_len = 0;\r\nu8 encryp_protocol = 0;\r\nstruct wlan_bssid_ex *bssid;\r\nint group_cipher = 0, pairwise_cipher = 0, is_8021x = 0;\r\nunsigned char *pbuf;\r\nu32 wpa_ielen = 0;\r\nu8 *pbssid = GetAddr3Ptr(pframe);\r\nu32 hidden_ssid = 0;\r\nstruct HT_info_element *pht_info = NULL;\r\nstruct rtw_ieee80211_ht_cap *pht_cap = NULL;\r\nu32 bcn_channel;\r\nunsigned short ht_cap_info;\r\nunsigned char ht_info_infos_0;\r\nstruct mlme_priv *pmlmepriv = &Adapter->mlmepriv;\r\nif (is_client_associated_to_ap(Adapter) == false)\r\nreturn true;\r\nlen = packet_len - sizeof(struct ieee80211_hdr_3addr);\r\nif (len > MAX_IE_SZ) {\r\nDBG_871X("%s IE too long for survey event\n", __func__);\r\nreturn _FAIL;\r\n}\r\nif (memcmp(cur_network->network.MacAddress, pbssid, 6)) {\r\nDBG_871X("Oops: rtw_check_network_encrypt linked but recv other bssid bcn\n" MAC_FMT MAC_FMT,\r\nMAC_ARG(pbssid), MAC_ARG(cur_network->network.MacAddress));\r\nreturn true;\r\n}\r\nbssid = (struct wlan_bssid_ex *)rtw_zmalloc(sizeof(struct wlan_bssid_ex));\r\nif (bssid == NULL) {\r\nDBG_871X("%s rtw_zmalloc fail !!!\n", __func__);\r\nreturn true;\r\n}\r\nif ((pmlmepriv->timeBcnInfoChkStart != 0) && (jiffies_to_msecs(jiffies - pmlmepriv->timeBcnInfoChkStart) > DISCONNECT_BY_CHK_BCN_FAIL_OBSERV_PERIOD_IN_MS)) {\r\npmlmepriv->timeBcnInfoChkStart = 0;\r\npmlmepriv->NumOfBcnInfoChkFail = 0;\r\n}\r\nsubtype = GetFrameSubType(pframe) >> 4;\r\nif (subtype == WIFI_BEACON)\r\nbssid->Reserved[0] = 1;\r\nbssid->Length = sizeof(struct wlan_bssid_ex) - MAX_IE_SZ + len;\r\nbssid->IELength = len;\r\nmemcpy(bssid->IEs, (pframe + sizeof(struct ieee80211_hdr_3addr)), bssid->IELength);\r\np = rtw_get_ie(bssid->IEs + _FIXED_IE_LENGTH_, _HT_CAPABILITY_IE_, &len, bssid->IELength - _FIXED_IE_LENGTH_);\r\nif (p && len > 0) {\r\npht_cap = (struct rtw_ieee80211_ht_cap *)(p + 2);\r\nht_cap_info = le16_to_cpu(pht_cap->cap_info);\r\n} else {\r\nht_cap_info = 0;\r\n}\r\np = rtw_get_ie(bssid->IEs + _FIXED_IE_LENGTH_, _HT_ADD_INFO_IE_, &len, bssid->IELength - _FIXED_IE_LENGTH_);\r\nif (p && len > 0) {\r\npht_info = (struct HT_info_element *)(p + 2);\r\nht_info_infos_0 = pht_info->infos[0];\r\n} else {\r\nht_info_infos_0 = 0;\r\n}\r\nif (ht_cap_info != cur_network->BcnInfo.ht_cap_info ||\r\n((ht_info_infos_0&0x03) != (cur_network->BcnInfo.ht_info_infos_0&0x03))) {\r\nDBG_871X("%s bcn now: ht_cap_info:%x ht_info_infos_0:%x\n", __func__,\r\nht_cap_info, ht_info_infos_0);\r\nDBG_871X("%s bcn link: ht_cap_info:%x ht_info_infos_0:%x\n", __func__,\r\ncur_network->BcnInfo.ht_cap_info, cur_network->BcnInfo.ht_info_infos_0);\r\nDBG_871X("%s bw mode change\n", __func__);\r\n{\r\ncur_network->BcnInfo.ht_cap_info = ht_cap_info;\r\ncur_network->BcnInfo.ht_info_infos_0 = ht_info_infos_0;\r\n}\r\n}\r\np = rtw_get_ie(bssid->IEs + _FIXED_IE_LENGTH_, _DSSET_IE_, &len, bssid->IELength - _FIXED_IE_LENGTH_);\r\nif (p) {\r\nbcn_channel = *(p + 2);\r\n} else {\r\nrtw_get_ie(bssid->IEs + _FIXED_IE_LENGTH_, _HT_ADD_INFO_IE_, &len, bssid->IELength - _FIXED_IE_LENGTH_);\r\nif (pht_info) {\r\nbcn_channel = pht_info->primary_channel;\r\n} else {\r\nbcn_channel = Adapter->mlmeextpriv.cur_channel;\r\n}\r\n}\r\nif (bcn_channel != Adapter->mlmeextpriv.cur_channel) {\r\nDBG_871X("%s beacon channel:%d cur channel:%d disconnect\n", __func__,\r\nbcn_channel, Adapter->mlmeextpriv.cur_channel);\r\ngoto _mismatch;\r\n}\r\np = rtw_get_ie(bssid->IEs + _FIXED_IE_LENGTH_, _SSID_IE_, &len, bssid->IELength - _FIXED_IE_LENGTH_);\r\nif (p == NULL) {\r\nDBG_871X("%s marc: cannot find SSID for survey event\n", __func__);\r\nhidden_ssid = true;\r\n} else {\r\nhidden_ssid = false;\r\n}\r\nif ((NULL != p) && (false == hidden_ssid && (*(p + 1)))) {\r\nmemcpy(bssid->Ssid.Ssid, (p + 2), *(p + 1));\r\nbssid->Ssid.SsidLength = *(p + 1);\r\n} else {\r\nbssid->Ssid.SsidLength = 0;\r\nbssid->Ssid.Ssid[0] = '\0';\r\n}\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("%s bssid.Ssid.Ssid:%s bssid.Ssid.SsidLength:%d "\r\n"cur_network->network.Ssid.Ssid:%s len:%d\n", __func__, bssid->Ssid.Ssid,\r\nbssid->Ssid.SsidLength, cur_network->network.Ssid.Ssid,\r\ncur_network->network.Ssid.SsidLength));\r\nif (memcmp(bssid->Ssid.Ssid, cur_network->network.Ssid.Ssid, 32) ||\r\nbssid->Ssid.SsidLength != cur_network->network.Ssid.SsidLength) {\r\nif (bssid->Ssid.Ssid[0] != '\0' && bssid->Ssid.SsidLength != 0) {\r\nDBG_871X("%s(), SSID is not match\n", __func__);\r\ngoto _mismatch;\r\n}\r\n}\r\nval16 = rtw_get_capability((struct wlan_bssid_ex *)bssid);\r\nif (val16 & BIT(4))\r\nbssid->Privacy = 1;\r\nelse\r\nbssid->Privacy = 0;\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_info_,\r\n("%s(): cur_network->network.Privacy is %d, bssid.Privacy is %d\n",\r\n__func__, cur_network->network.Privacy, bssid->Privacy));\r\nif (cur_network->network.Privacy != bssid->Privacy) {\r\nDBG_871X("%s(), privacy is not match\n", __func__);\r\ngoto _mismatch;\r\n}\r\nrtw_get_sec_ie(bssid->IEs, bssid->IELength, NULL, &rsn_len, NULL, &wpa_len);\r\nif (rsn_len > 0) {\r\nencryp_protocol = ENCRYP_PROTOCOL_WPA2;\r\n} else if (wpa_len > 0) {\r\nencryp_protocol = ENCRYP_PROTOCOL_WPA;\r\n} else {\r\nif (bssid->Privacy)\r\nencryp_protocol = ENCRYP_PROTOCOL_WEP;\r\n}\r\nif (cur_network->BcnInfo.encryp_protocol != encryp_protocol) {\r\nDBG_871X("%s(): enctyp is not match\n", __func__);\r\ngoto _mismatch;\r\n}\r\nif (encryp_protocol == ENCRYP_PROTOCOL_WPA || encryp_protocol == ENCRYP_PROTOCOL_WPA2) {\r\npbuf = rtw_get_wpa_ie(&bssid->IEs[12], &wpa_ielen, bssid->IELength-12);\r\nif (pbuf && (wpa_ielen > 0)) {\r\nif (_SUCCESS == rtw_parse_wpa_ie(pbuf, wpa_ielen+2, &group_cipher, &pairwise_cipher, &is_8021x)) {\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_info_,\r\n("%s pnetwork->pairwise_cipher: %d, group_cipher is %d, is_8021x is %d\n", __func__,\r\npairwise_cipher, group_cipher, is_8021x));\r\n}\r\n} else {\r\npbuf = rtw_get_wpa2_ie(&bssid->IEs[12], &wpa_ielen, bssid->IELength-12);\r\nif (pbuf && (wpa_ielen > 0)) {\r\nif (_SUCCESS == rtw_parse_wpa2_ie(pbuf, wpa_ielen+2, &group_cipher, &pairwise_cipher, &is_8021x)) {\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_info_,\r\n("%s pnetwork->pairwise_cipher: %d, pnetwork->group_cipher is %d, is_802x is %d\n",\r\n__func__, pairwise_cipher, group_cipher, is_8021x));\r\n}\r\n}\r\n}\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,\r\n("%s cur_network->group_cipher is %d: %d\n", __func__, cur_network->BcnInfo.group_cipher, group_cipher));\r\nif (pairwise_cipher != cur_network->BcnInfo.pairwise_cipher || group_cipher != cur_network->BcnInfo.group_cipher) {\r\nDBG_871X("%s pairwise_cipher(%x:%x) or group_cipher(%x:%x) is not match\n", __func__,\r\npairwise_cipher, cur_network->BcnInfo.pairwise_cipher,\r\ngroup_cipher, cur_network->BcnInfo.group_cipher);\r\ngoto _mismatch;\r\n}\r\nif (is_8021x != cur_network->BcnInfo.is_8021x) {\r\nDBG_871X("%s authentication is not match\n", __func__);\r\ngoto _mismatch;\r\n}\r\n}\r\nkfree((u8 *)bssid);\r\nreturn _SUCCESS;\r\n_mismatch:\r\nkfree((u8 *)bssid);\r\nif (pmlmepriv->NumOfBcnInfoChkFail == 0)\r\npmlmepriv->timeBcnInfoChkStart = jiffies;\r\npmlmepriv->NumOfBcnInfoChkFail++;\r\nDBG_871X("%s by "ADPT_FMT" - NumOfChkFail = %d (SeqNum of this Beacon frame = %d).\n", __func__, ADPT_ARG(Adapter), pmlmepriv->NumOfBcnInfoChkFail, GetSequence(pframe));\r\nif ((pmlmepriv->timeBcnInfoChkStart != 0) && (jiffies_to_msecs(jiffies - pmlmepriv->timeBcnInfoChkStart) <= DISCONNECT_BY_CHK_BCN_FAIL_OBSERV_PERIOD_IN_MS)\r\n&& (pmlmepriv->NumOfBcnInfoChkFail >= DISCONNECT_BY_CHK_BCN_FAIL_THRESHOLD)) {\r\nDBG_871X("%s by "ADPT_FMT" - NumOfChkFail = %d >= threshold : %d (in %d ms), return FAIL.\n", __func__, ADPT_ARG(Adapter), pmlmepriv->NumOfBcnInfoChkFail,\r\nDISCONNECT_BY_CHK_BCN_FAIL_THRESHOLD, jiffies_to_msecs(jiffies - pmlmepriv->timeBcnInfoChkStart));\r\npmlmepriv->timeBcnInfoChkStart = 0;\r\npmlmepriv->NumOfBcnInfoChkFail = 0;\r\nreturn _FAIL;\r\n}\r\nreturn _SUCCESS;\r\n}\r\nvoid update_beacon_info(struct adapter *padapter, u8 *pframe, uint pkt_len, struct sta_info *psta)\r\n{\r\nunsigned int i;\r\nunsigned int len;\r\nstruct ndis_80211_var_ie *pIE;\r\nlen = pkt_len - (_BEACON_IE_OFFSET_ + WLAN_HDR_A3_LEN);\r\nfor (i = 0; i < len;) {\r\npIE = (struct ndis_80211_var_ie *)(pframe + (_BEACON_IE_OFFSET_ + WLAN_HDR_A3_LEN) + i);\r\nswitch (pIE->ElementID) {\r\ncase _VENDOR_SPECIFIC_IE_:\r\nif (!memcmp(pIE->data, WMM_PARA_OUI, 6) && pIE->Length == WLAN_WMM_LEN)\r\nif (WMM_param_handler(padapter, pIE))\r\nreport_wmm_edca_update(padapter);\r\nbreak;\r\ncase _HT_EXTRA_INFO_IE_:\r\nbwmode_update_check(padapter, pIE);\r\nbreak;\r\ncase _ERPINFO_IE_:\r\nERP_IE_handler(padapter, pIE);\r\nVCS_update(padapter, psta);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ni += (pIE->Length + 2);\r\n}\r\n}\r\nunsigned int is_ap_in_tkip(struct adapter *padapter)\r\n{\r\nu32 i;\r\nstruct ndis_80211_var_ie *pIE;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nstruct wlan_bssid_ex *cur_network = &(pmlmeinfo->network);\r\nif (rtw_get_capability((struct wlan_bssid_ex *)cur_network) & WLAN_CAPABILITY_PRIVACY) {\r\nfor (i = sizeof(struct ndis_802_11_fix_ie); i < pmlmeinfo->network.IELength;) {\r\npIE = (struct ndis_80211_var_ie *)(pmlmeinfo->network.IEs + i);\r\nswitch (pIE->ElementID) {\r\ncase _VENDOR_SPECIFIC_IE_:\r\nif ((!memcmp(pIE->data, RTW_WPA_OUI, 4)) && (!memcmp((pIE->data + 12), WPA_TKIP_CIPHER, 4)))\r\nreturn true;\r\nbreak;\r\ncase _RSN_IE_2_:\r\nif (!memcmp((pIE->data + 8), RSN_TKIP_CIPHER, 4))\r\nreturn true;\r\ndefault:\r\nbreak;\r\n}\r\ni += (pIE->Length + 2);\r\n}\r\nreturn false;\r\n} else\r\nreturn false;\r\n}\r\nint support_short_GI(struct adapter *padapter, struct HT_caps_element *pHT_caps, u8 bwmode)\r\n{\r\nunsigned char bit_offset;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nif (!(pmlmeinfo->HT_enable))\r\nreturn _FAIL;\r\nbit_offset = (bwmode & CHANNEL_WIDTH_40) ? 6 : 5;\r\nif (le16_to_cpu(pHT_caps->u.HT_cap_element.HT_caps_info) & (0x1 << bit_offset))\r\nreturn _SUCCESS;\r\nelse\r\nreturn _FAIL;\r\n}\r\nunsigned char get_highest_rate_idx(u32 mask)\r\n{\r\nint i;\r\nunsigned char rate_idx = 0;\r\nfor (i = 31; i >= 0; i--) {\r\nif (mask & BIT(i)) {\r\nrate_idx = i;\r\nbreak;\r\n}\r\n}\r\nreturn rate_idx;\r\n}\r\nvoid Update_RA_Entry(struct adapter *padapter, struct sta_info *psta)\r\n{\r\nrtw_hal_update_ra_mask(psta, 0);\r\n}\r\nvoid enable_rate_adaptive(struct adapter *padapter, struct sta_info *psta)\r\n{\r\nUpdate_RA_Entry(padapter, psta);\r\n}\r\nvoid set_sta_rate(struct adapter *padapter, struct sta_info *psta)\r\n{\r\nenable_rate_adaptive(padapter, psta);\r\n}\r\nunsigned char check_assoc_AP(u8 *pframe, uint len)\r\n{\r\nunsigned int i;\r\nstruct ndis_80211_var_ie *pIE;\r\nfor (i = sizeof(struct ndis_802_11_fix_ie); i < len;) {\r\npIE = (struct ndis_80211_var_ie *)(pframe + i);\r\nswitch (pIE->ElementID) {\r\ncase _VENDOR_SPECIFIC_IE_:\r\nif ((!memcmp(pIE->data, ARTHEROS_OUI1, 3)) || (!memcmp(pIE->data, ARTHEROS_OUI2, 3))) {\r\nDBG_871X("link to Artheros AP\n");\r\nreturn HT_IOT_PEER_ATHEROS;\r\n} else if ((!memcmp(pIE->data, BROADCOM_OUI1, 3))\r\n|| (!memcmp(pIE->data, BROADCOM_OUI2, 3))\r\n|| (!memcmp(pIE->data, BROADCOM_OUI3, 3))) {\r\nDBG_871X("link to Broadcom AP\n");\r\nreturn HT_IOT_PEER_BROADCOM;\r\n} else if (!memcmp(pIE->data, MARVELL_OUI, 3)) {\r\nDBG_871X("link to Marvell AP\n");\r\nreturn HT_IOT_PEER_MARVELL;\r\n} else if (!memcmp(pIE->data, RALINK_OUI, 3)) {\r\nDBG_871X("link to Ralink AP\n");\r\nreturn HT_IOT_PEER_RALINK;\r\n} else if (!memcmp(pIE->data, CISCO_OUI, 3)) {\r\nDBG_871X("link to Cisco AP\n");\r\nreturn HT_IOT_PEER_CISCO;\r\n} else if (!memcmp(pIE->data, REALTEK_OUI, 3)) {\r\nu32 Vender = HT_IOT_PEER_REALTEK;\r\nif (pIE->Length >= 5) {\r\nif (pIE->data[4] == 1)\r\nif (pIE->data[5] & RT_HT_CAP_USE_92SE)\r\nVender = HT_IOT_PEER_REALTEK_92SE;\r\nif (pIE->data[5] & RT_HT_CAP_USE_SOFTAP)\r\nVender = HT_IOT_PEER_REALTEK_SOFTAP;\r\nif (pIE->data[4] == 2) {\r\nif (pIE->data[6] & RT_HT_CAP_USE_JAGUAR_BCUT) {\r\nVender = HT_IOT_PEER_REALTEK_JAGUAR_BCUTAP;\r\nDBG_871X("link to Realtek JAGUAR_BCUTAP\n");\r\n}\r\nif (pIE->data[6] & RT_HT_CAP_USE_JAGUAR_CCUT) {\r\nVender = HT_IOT_PEER_REALTEK_JAGUAR_CCUTAP;\r\nDBG_871X("link to Realtek JAGUAR_CCUTAP\n");\r\n}\r\n}\r\n}\r\nDBG_871X("link to Realtek AP\n");\r\nreturn Vender;\r\n} else if (!memcmp(pIE->data, AIRGOCAP_OUI, 3)) {\r\nDBG_871X("link to Airgo Cap\n");\r\nreturn HT_IOT_PEER_AIRGO;\r\n} else\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ni += (pIE->Length + 2);\r\n}\r\nDBG_871X("link to new AP\n");\r\nreturn HT_IOT_PEER_UNKNOWN;\r\n}\r\nvoid update_IOT_info(struct adapter *padapter)\r\n{\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nswitch (pmlmeinfo->assoc_AP_vendor) {\r\ncase HT_IOT_PEER_MARVELL:\r\npmlmeinfo->turboMode_cts2self = 1;\r\npmlmeinfo->turboMode_rtsen = 0;\r\nbreak;\r\ncase HT_IOT_PEER_RALINK:\r\npmlmeinfo->turboMode_cts2self = 0;\r\npmlmeinfo->turboMode_rtsen = 1;\r\nSwitch_DM_Func(padapter, (~DYNAMIC_BB_DYNAMIC_TXPWR), false);\r\nbreak;\r\ncase HT_IOT_PEER_REALTEK:\r\nSwitch_DM_Func(padapter, (~DYNAMIC_BB_DYNAMIC_TXPWR), false);\r\nbreak;\r\ndefault:\r\npmlmeinfo->turboMode_cts2self = 0;\r\npmlmeinfo->turboMode_rtsen = 1;\r\nbreak;\r\n}\r\n}\r\nvoid update_capinfo(struct adapter *Adapter, u16 updateCap)\r\n{\r\nstruct mlme_ext_priv *pmlmeext = &Adapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nbool ShortPreamble;\r\n{\r\nif (updateCap & cShortPreamble) {\r\nif (pmlmeinfo->preamble_mode != PREAMBLE_SHORT) {\r\nShortPreamble = true;\r\npmlmeinfo->preamble_mode = PREAMBLE_SHORT;\r\nrtw_hal_set_hwreg(Adapter, HW_VAR_ACK_PREAMBLE, (u8 *)&ShortPreamble);\r\n}\r\n} else{\r\nif (pmlmeinfo->preamble_mode != PREAMBLE_LONG) {\r\nShortPreamble = false;\r\npmlmeinfo->preamble_mode = PREAMBLE_LONG;\r\nrtw_hal_set_hwreg(Adapter, HW_VAR_ACK_PREAMBLE, (u8 *)&ShortPreamble);\r\n}\r\n}\r\n}\r\nif (updateCap & cIBSS)\r\npmlmeinfo->slotTime = NON_SHORT_SLOT_TIME;\r\nelse {\r\nif (pmlmeext->cur_wireless_mode & (WIRELESS_11_24N | WIRELESS_11A | WIRELESS_11_5N | WIRELESS_11AC))\r\npmlmeinfo->slotTime = SHORT_SLOT_TIME;\r\nelse if (pmlmeext->cur_wireless_mode & (WIRELESS_11G)) {\r\nif ((updateCap & cShortSlotTime) )\r\npmlmeinfo->slotTime = SHORT_SLOT_TIME;\r\nelse\r\npmlmeinfo->slotTime = NON_SHORT_SLOT_TIME;\r\n} else\r\npmlmeinfo->slotTime = NON_SHORT_SLOT_TIME;\r\n}\r\nrtw_hal_set_hwreg(Adapter, HW_VAR_SLOT_TIME, &pmlmeinfo->slotTime);\r\n}\r\nvoid update_wireless_mode(struct adapter *padapter)\r\n{\r\nint ratelen, network_type = 0;\r\nu32 SIFS_Timer;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nstruct wlan_bssid_ex *cur_network = &(pmlmeinfo->network);\r\nunsigned char *rate = cur_network->SupportedRates;\r\nratelen = rtw_get_rateset_len(cur_network->SupportedRates);\r\nif ((pmlmeinfo->HT_info_enable) && (pmlmeinfo->HT_caps_enable))\r\npmlmeinfo->HT_enable = 1;\r\nif (pmlmeext->cur_channel > 14) {\r\nif (pmlmeinfo->VHT_enable)\r\nnetwork_type = WIRELESS_11AC;\r\nelse if (pmlmeinfo->HT_enable)\r\nnetwork_type = WIRELESS_11_5N;\r\nnetwork_type |= WIRELESS_11A;\r\n} else{\r\nif (pmlmeinfo->VHT_enable)\r\nnetwork_type = WIRELESS_11AC;\r\nelse if (pmlmeinfo->HT_enable)\r\nnetwork_type = WIRELESS_11_24N;\r\nif ((cckratesonly_included(rate, ratelen)) == true)\r\nnetwork_type |= WIRELESS_11B;\r\nelse if ((cckrates_included(rate, ratelen)) == true)\r\nnetwork_type |= WIRELESS_11BG;\r\nelse\r\nnetwork_type |= WIRELESS_11G;\r\n}\r\npmlmeext->cur_wireless_mode = network_type & padapter->registrypriv.wireless_mode;\r\nSIFS_Timer = 0x0a0a0808;\r\npadapter->HalFunc.SetHwRegHandler(padapter, HW_VAR_RESP_SIFS, (u8 *)&SIFS_Timer);\r\npadapter->HalFunc.SetHwRegHandler(padapter, HW_VAR_WIRELESS_MODE, (u8 *)&(pmlmeext->cur_wireless_mode));\r\nif (pmlmeext->cur_wireless_mode & WIRELESS_11B)\r\nupdate_mgnt_tx_rate(padapter, IEEE80211_CCK_RATE_1MB);\r\nelse\r\nupdate_mgnt_tx_rate(padapter, IEEE80211_OFDM_RATE_6MB);\r\n}\r\nvoid update_sta_basic_rate(struct sta_info *psta, u8 wireless_mode)\r\n{\r\nif (IsSupportedTxCCK(wireless_mode)) {\r\nmemcpy(psta->bssrateset, rtw_basic_rate_cck, 4);\r\npsta->bssratelen = 4;\r\n} else{\r\nmemcpy(psta->bssrateset, rtw_basic_rate_ofdm, 3);\r\npsta->bssratelen = 3;\r\n}\r\n}\r\nint update_sta_support_rate(struct adapter *padapter, u8 *pvar_ie, uint var_ie_len, int cam_idx)\r\n{\r\nunsigned int ie_len;\r\nstruct ndis_80211_var_ie *pIE;\r\nint supportRateNum = 0;\r\nstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\npIE = (struct ndis_80211_var_ie *)rtw_get_ie(pvar_ie, _SUPPORTEDRATES_IE_, &ie_len, var_ie_len);\r\nif (pIE == NULL)\r\nreturn _FAIL;\r\nmemcpy(pmlmeinfo->FW_sta_info[cam_idx].SupportedRates, pIE->data, ie_len);\r\nsupportRateNum = ie_len;\r\npIE = (struct ndis_80211_var_ie *)rtw_get_ie(pvar_ie, _EXT_SUPPORTEDRATES_IE_, &ie_len, var_ie_len);\r\nif (pIE)\r\nmemcpy((pmlmeinfo->FW_sta_info[cam_idx].SupportedRates + supportRateNum), pIE->data, ie_len);\r\nreturn _SUCCESS;\r\n}\r\nvoid process_addba_req(struct adapter *padapter, u8 *paddba_req, u8 *addr)\r\n{\r\nstruct sta_info *psta;\r\nu16 tid, start_seq, param;\r\nstruct recv_reorder_ctrl *preorder_ctrl;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct ADDBA_request *preq = (struct ADDBA_request *)paddba_req;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\npsta = rtw_get_stainfo(pstapriv, addr);\r\nif (psta) {\r\nstart_seq = le16_to_cpu(preq->BA_starting_seqctrl) >> 4;\r\nparam = le16_to_cpu(preq->BA_para_set);\r\ntid = (param>>2)&0x0f;\r\npreorder_ctrl = &psta->recvreorder_ctrl[tid];\r\n#ifdef CONFIG_UPDATE_INDICATE_SEQ_WHILE_PROCESS_ADDBA_REQ\r\npreorder_ctrl->indicate_seq = start_seq;\r\n#ifdef DBG_RX_SEQ\r\nDBG_871X("DBG_RX_SEQ %s:%d IndicateSeq: %d, start_seq: %d\n", __func__, __LINE__,\r\npreorder_ctrl->indicate_seq, start_seq);\r\n#endif\r\n#else\r\npreorder_ctrl->indicate_seq = 0xffff;\r\n#endif\r\npreorder_ctrl->enable = (pmlmeinfo->bAcceptAddbaReq == true) ? true : false;\r\n}\r\n}\r\nvoid update_TSF(struct mlme_ext_priv *pmlmeext, u8 *pframe, uint len)\r\n{\r\nu8 *pIE;\r\n__le32 *pbuf;\r\npIE = pframe + sizeof(struct ieee80211_hdr_3addr);\r\npbuf = (__le32 *)pIE;\r\npmlmeext->TSFValue = le32_to_cpu(*(pbuf+1));\r\npmlmeext->TSFValue = pmlmeext->TSFValue << 32;\r\npmlmeext->TSFValue |= le32_to_cpu(*pbuf);\r\n}\r\nvoid correct_TSF(struct adapter *padapter, struct mlme_ext_priv *pmlmeext)\r\n{\r\nrtw_hal_set_hwreg(padapter, HW_VAR_CORRECT_TSF, NULL);\r\n}\r\nvoid adaptive_early_32k(struct mlme_ext_priv *pmlmeext, u8 *pframe, uint len)\r\n{\r\nint i;\r\nu8 *pIE;\r\n__le32 *pbuf;\r\nu64 tsf = 0;\r\nu32 delay_ms;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\npmlmeext->bcn_cnt++;\r\npIE = pframe + sizeof(struct ieee80211_hdr_3addr);\r\npbuf = (__le32 *)pIE;\r\ntsf = le32_to_cpu(*(pbuf+1));\r\ntsf = tsf << 32;\r\ntsf |= le32_to_cpu(*pbuf);\r\ndelay_ms = rtw_modular64(tsf, (pmlmeinfo->bcn_interval*1024));\r\ndelay_ms = delay_ms/1000;\r\nif (delay_ms >= 8)\r\npmlmeext->bcn_delay_cnt[8]++;\r\nelse\r\npmlmeext->bcn_delay_cnt[delay_ms]++;\r\nif (pmlmeext->bcn_cnt > 100 && (pmlmeext->adaptive_tsf_done == true)) {\r\nu8 ratio_20_delay, ratio_80_delay;\r\nu8 DrvBcnEarly, DrvBcnTimeOut;\r\nratio_20_delay = 0;\r\nratio_80_delay = 0;\r\nDrvBcnEarly = 0xff;\r\nDrvBcnTimeOut = 0xff;\r\nDBG_871X("%s(): bcn_cnt = %d\n", __func__, pmlmeext->bcn_cnt);\r\nfor (i = 0; i < 9; i++) {\r\npmlmeext->bcn_delay_ratio[i] = (pmlmeext->bcn_delay_cnt[i] * 100) / pmlmeext->bcn_cnt;\r\nDBG_871X("%s():bcn_delay_cnt[%d]=%d, bcn_delay_ratio[%d]=%d\n", __func__, i,\r\npmlmeext->bcn_delay_cnt[i], i, pmlmeext->bcn_delay_ratio[i]);\r\nratio_20_delay += pmlmeext->bcn_delay_ratio[i];\r\nratio_80_delay += pmlmeext->bcn_delay_ratio[i];\r\nif (ratio_20_delay > 20 && DrvBcnEarly == 0xff) {\r\nDrvBcnEarly = i;\r\nDBG_871X("%s(): DrvBcnEarly = %d\n", __func__, DrvBcnEarly);\r\n}\r\nif (ratio_80_delay > 80 && DrvBcnTimeOut == 0xff) {\r\nDrvBcnTimeOut = i;\r\nDBG_871X("%s(): DrvBcnTimeOut = %d\n", __func__, DrvBcnTimeOut);\r\n}\r\npmlmeext->bcn_delay_cnt[i] = 0;\r\npmlmeext->bcn_delay_ratio[i] = 0;\r\n}\r\npmlmeext->DrvBcnEarly = DrvBcnEarly;\r\npmlmeext->DrvBcnTimeOut = DrvBcnTimeOut;\r\npmlmeext->bcn_cnt = 0;\r\n}\r\n}\r\nvoid beacon_timing_control(struct adapter *padapter)\r\n{\r\nrtw_hal_bcn_related_reg_setting(padapter);\r\n}\r\nvoid rtw_alloc_macid(struct adapter *padapter, struct sta_info *psta)\r\n{\r\nint i;\r\nu8 bc_addr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\r\nstruct dvobj_priv *pdvobj = adapter_to_dvobj(padapter);\r\nif (!memcmp(psta->hwaddr, bc_addr, ETH_ALEN))\r\nreturn;\r\nif (!memcmp(psta->hwaddr, myid(&padapter->eeprompriv), ETH_ALEN)) {\r\npsta->mac_id = NUM_STA;\r\nreturn;\r\n}\r\nspin_lock_bh(&pdvobj->lock);\r\nfor (i = 0; i < NUM_STA; i++) {\r\nif (pdvobj->macid[i] == false) {\r\npdvobj->macid[i] = true;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_bh(&pdvobj->lock);\r\nif (i > (NUM_STA-1)) {\r\npsta->mac_id = NUM_STA;\r\nDBG_871X(" no room for more MACIDs\n");\r\n} else{\r\npsta->mac_id = i;\r\nDBG_871X("%s = %d\n", __func__, psta->mac_id);\r\n}\r\n}\r\nvoid rtw_release_macid(struct adapter *padapter, struct sta_info *psta)\r\n{\r\nu8 bc_addr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\r\nstruct dvobj_priv *pdvobj = adapter_to_dvobj(padapter);\r\nif (!memcmp(psta->hwaddr, bc_addr, ETH_ALEN))\r\nreturn;\r\nif (!memcmp(psta->hwaddr, myid(&padapter->eeprompriv), ETH_ALEN))\r\nreturn;\r\nspin_lock_bh(&pdvobj->lock);\r\nif (psta->mac_id < NUM_STA && psta->mac_id != 1) {\r\nif (pdvobj->macid[psta->mac_id] == true) {\r\nDBG_871X("%s = %d\n", __func__, psta->mac_id);\r\npdvobj->macid[psta->mac_id] = false;\r\npsta->mac_id = NUM_STA;\r\n}\r\n}\r\nspin_unlock_bh(&pdvobj->lock);\r\n}\r\nu8 rtw_search_max_mac_id(struct adapter *padapter)\r\n{\r\nu8 max_mac_id = 0;\r\nstruct dvobj_priv *pdvobj = adapter_to_dvobj(padapter);\r\nint i;\r\nspin_lock_bh(&pdvobj->lock);\r\nfor (i = (NUM_STA-1); i >= 0 ; i--) {\r\nif (pdvobj->macid[i] == true)\r\nbreak;\r\n}\r\nmax_mac_id = i;\r\nspin_unlock_bh(&pdvobj->lock);\r\nreturn max_mac_id;\r\n}\r\nstruct adapter *dvobj_get_port0_adapter(struct dvobj_priv *dvobj)\r\n{\r\nif (get_iface_type(dvobj->padapters[i]) != IFACE_PORT0)\r\nreturn NULL;\r\nreturn dvobj->padapters;\r\n}\r\nint rtw_get_gpio(struct net_device *netdev, int gpio_num)\r\n{\r\nu8 value;\r\nu8 direction;\r\nstruct adapter *adapter = (struct adapter *)rtw_netdev_priv(netdev);\r\nstruct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(adapter);\r\nrtw_ps_deny(adapter, PS_DENY_IOCTL);\r\nDBG_871X("rf_pwrstate = 0x%02x\n", pwrpriv->rf_pwrstate);\r\nLeaveAllPowerSaveModeDirect(adapter);\r\ndirection = (rtw_read8(adapter, REG_GPIO_PIN_CTRL + 2) & BIT(gpio_num)) >> gpio_num;\r\nif (direction)\r\nvalue = (rtw_read8(adapter, REG_GPIO_PIN_CTRL + 1) & BIT(gpio_num)) >> gpio_num;\r\nelse\r\nvalue = (rtw_read8(adapter, REG_GPIO_PIN_CTRL) & BIT(gpio_num)) >> gpio_num;\r\nrtw_ps_deny_cancel(adapter, PS_DENY_IOCTL);\r\nDBG_871X("%s direction =%d value =%d\n", __func__, direction, value);\r\nreturn value;\r\n}\r\nint rtw_set_gpio_output_value(struct net_device *netdev, int gpio_num, bool isHigh)\r\n{\r\nu8 direction = 0;\r\nu8 res = -1;\r\nstruct adapter *adapter = (struct adapter *)rtw_netdev_priv(netdev);\r\nif (gpio_num > 7 || gpio_num < 4) {\r\nDBG_871X("%s The gpio number does not included 4~7.\n", __func__);\r\nreturn -1;\r\n}\r\nrtw_ps_deny(adapter, PS_DENY_IOCTL);\r\nLeaveAllPowerSaveModeDirect(adapter);\r\ndirection = (rtw_read8(adapter, REG_GPIO_PIN_CTRL + 2) & BIT(gpio_num)) >> gpio_num;\r\nif (direction) {\r\nif (isHigh)\r\nrtw_write8(adapter, REG_GPIO_PIN_CTRL + 1, rtw_read8(adapter, REG_GPIO_PIN_CTRL + 1) | BIT(gpio_num));\r\nelse\r\nrtw_write8(adapter, REG_GPIO_PIN_CTRL + 1, rtw_read8(adapter, REG_GPIO_PIN_CTRL + 1) & ~BIT(gpio_num));\r\nDBG_871X("%s Set gpio %x[%d]=%d\n", __func__, REG_GPIO_PIN_CTRL+1, gpio_num, isHigh);\r\nres = 0;\r\n} else{\r\nDBG_871X("%s The gpio is input, not be set!\n", __func__);\r\nres = -1;\r\n}\r\nrtw_ps_deny_cancel(adapter, PS_DENY_IOCTL);\r\nreturn res;\r\n}\r\nint rtw_config_gpio(struct net_device *netdev, int gpio_num, bool isOutput)\r\n{\r\nstruct adapter *adapter = (struct adapter *)rtw_netdev_priv(netdev);\r\nif (gpio_num > 7 || gpio_num < 4) {\r\nDBG_871X("%s The gpio number does not included 4~7.\n", __func__);\r\nreturn -1;\r\n}\r\nDBG_871X("%s gpio_num =%d direction =%d\n", __func__, gpio_num, isOutput);\r\nrtw_ps_deny(adapter, PS_DENY_IOCTL);\r\nLeaveAllPowerSaveModeDirect(adapter);\r\nif (isOutput)\r\nrtw_write8(adapter, REG_GPIO_PIN_CTRL + 2, rtw_read8(adapter, REG_GPIO_PIN_CTRL + 2) | BIT(gpio_num));\r\nelse\r\nrtw_write8(adapter, REG_GPIO_PIN_CTRL + 2, rtw_read8(adapter, REG_GPIO_PIN_CTRL + 2) & ~BIT(gpio_num));\r\nrtw_ps_deny_cancel(adapter, PS_DENY_IOCTL);\r\nreturn 0;\r\n}\r\nvoid rtw_get_current_ip_address(struct adapter *padapter, u8 *pcurrentip)\r\n{\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nstruct in_device *my_ip_ptr = padapter->pnetdev->ip_ptr;\r\nu8 ipaddress[4];\r\nif ((pmlmeinfo->state & WIFI_FW_LINKING_STATE) ||\r\npmlmeinfo->state & WIFI_FW_AP_STATE) {\r\nif (my_ip_ptr != NULL) {\r\nstruct in_ifaddr *my_ifa_list = my_ip_ptr->ifa_list;\r\nif (my_ifa_list != NULL) {\r\nipaddress[0] = my_ifa_list->ifa_address & 0xFF;\r\nipaddress[1] = (my_ifa_list->ifa_address >> 8) & 0xFF;\r\nipaddress[2] = (my_ifa_list->ifa_address >> 16) & 0xFF;\r\nipaddress[3] = my_ifa_list->ifa_address >> 24;\r\nDBG_871X("%s: %d.%d.%d.%d ==========\n", __func__,\r\nipaddress[0], ipaddress[1], ipaddress[2], ipaddress[3]);\r\nmemcpy(pcurrentip, ipaddress, 4);\r\n}\r\n}\r\n}\r\n}\r\nvoid rtw_get_sec_iv(struct adapter *padapter, u8 *pcur_dot11txpn, u8 *StaAddr)\r\n{\r\nstruct sta_info *psta;\r\nstruct security_priv *psecpriv = &padapter->securitypriv;\r\nmemset(pcur_dot11txpn, 0, 8);\r\nif (NULL == StaAddr)\r\nreturn;\r\npsta = rtw_get_stainfo(&padapter->stapriv, StaAddr);\r\nDBG_871X("%s(): StaAddr: %02x %02x %02x %02x %02x %02x\n",\r\n__func__, StaAddr[0], StaAddr[1], StaAddr[2],\r\nStaAddr[3], StaAddr[4], StaAddr[5]);\r\nif (psta) {\r\nif (psecpriv->dot11PrivacyAlgrthm != _NO_PRIVACY_ && psta->dot11txpn.val > 0)\r\npsta->dot11txpn.val--;\r\nAES_IV(pcur_dot11txpn, psta->dot11txpn, 0);\r\nDBG_871X("%s(): CurrentIV: %02x %02x %02x %02x %02x %02x %02x %02x\n"\r\n, __func__, pcur_dot11txpn[0], pcur_dot11txpn[1],\r\npcur_dot11txpn[2], pcur_dot11txpn[3], pcur_dot11txpn[4],\r\npcur_dot11txpn[5], pcur_dot11txpn[6], pcur_dot11txpn[7]);\r\n}\r\n}\r\nvoid rtw_set_sec_pn(struct adapter *padapter)\r\n{\r\nstruct sta_info *psta;\r\nstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nstruct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);\r\nstruct security_priv *psecpriv = &padapter->securitypriv;\r\npsta = rtw_get_stainfo(&padapter->stapriv,\r\nget_my_bssid(&pmlmeinfo->network));\r\nif (psta) {\r\nif (pwrpriv->wowlan_fw_iv > psta->dot11txpn.val) {\r\nif (psecpriv->dot11PrivacyAlgrthm != _NO_PRIVACY_)\r\npsta->dot11txpn.val = pwrpriv->wowlan_fw_iv + 2;\r\n} else {\r\nDBG_871X("%s(): FW IV is smaller than driver\n", __func__);\r\npsta->dot11txpn.val += 2;\r\n}\r\nDBG_871X("%s: dot11txpn: 0x%016llx\n", __func__, psta->dot11txpn.val);\r\n}\r\n}
