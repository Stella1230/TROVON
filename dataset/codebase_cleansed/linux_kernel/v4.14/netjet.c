static void\r\n_set_debug(struct tiger_hw *card)\r\n{\r\ncard->isac.dch.debug = debug;\r\ncard->bc[0].bch.debug = debug;\r\ncard->bc[1].bch.debug = debug;\r\n}\r\nstatic int\r\nset_debug(const char *val, struct kernel_param *kp)\r\n{\r\nint ret;\r\nstruct tiger_hw *card;\r\nret = param_set_uint(val, kp);\r\nif (!ret) {\r\nread_lock(&card_lock);\r\nlist_for_each_entry(card, &Cards, list)\r\n_set_debug(card);\r\nread_unlock(&card_lock);\r\n}\r\nreturn ret;\r\n}\r\nstatic void\r\nnj_disable_hwirq(struct tiger_hw *card)\r\n{\r\noutb(0, card->base + NJ_IRQMASK0);\r\noutb(0, card->base + NJ_IRQMASK1);\r\n}\r\nstatic u8\r\nReadISAC_nj(void *p, u8 offset)\r\n{\r\nstruct tiger_hw *card = p;\r\nu8 ret;\r\ncard->auxd &= 0xfc;\r\ncard->auxd |= (offset >> 4) & 3;\r\noutb(card->auxd, card->base + NJ_AUXDATA);\r\nret = inb(card->base + NJ_ISAC_OFF + ((offset & 0x0f) << 2));\r\nreturn ret;\r\n}\r\nstatic void\r\nWriteISAC_nj(void *p, u8 offset, u8 value)\r\n{\r\nstruct tiger_hw *card = p;\r\ncard->auxd &= 0xfc;\r\ncard->auxd |= (offset >> 4) & 3;\r\noutb(card->auxd, card->base + NJ_AUXDATA);\r\noutb(value, card->base + NJ_ISAC_OFF + ((offset & 0x0f) << 2));\r\n}\r\nstatic void\r\nReadFiFoISAC_nj(void *p, u8 offset, u8 *data, int size)\r\n{\r\nstruct tiger_hw *card = p;\r\ncard->auxd &= 0xfc;\r\noutb(card->auxd, card->base + NJ_AUXDATA);\r\ninsb(card->base + NJ_ISAC_OFF, data, size);\r\n}\r\nstatic void\r\nWriteFiFoISAC_nj(void *p, u8 offset, u8 *data, int size)\r\n{\r\nstruct tiger_hw *card = p;\r\ncard->auxd &= 0xfc;\r\noutb(card->auxd, card->base + NJ_AUXDATA);\r\noutsb(card->base + NJ_ISAC_OFF, data, size);\r\n}\r\nstatic void\r\nfill_mem(struct tiger_ch *bc, u32 idx, u32 cnt, u32 fill)\r\n{\r\nstruct tiger_hw *card = bc->bch.hw;\r\nu32 mask = 0xff, val;\r\npr_debug("%s: B%1d fill %02x len %d idx %d/%d\n", card->name,\r\nbc->bch.nr, fill, cnt, idx, card->send.idx);\r\nif (bc->bch.nr & 2) {\r\nfill <<= 8;\r\nmask <<= 8;\r\n}\r\nmask ^= 0xffffffff;\r\nwhile (cnt--) {\r\nval = card->send.start[idx];\r\nval &= mask;\r\nval |= fill;\r\ncard->send.start[idx++] = val;\r\nif (idx >= card->send.size)\r\nidx = 0;\r\n}\r\n}\r\nstatic int\r\nmode_tiger(struct tiger_ch *bc, u32 protocol)\r\n{\r\nstruct tiger_hw *card = bc->bch.hw;\r\npr_debug("%s: B%1d protocol %x-->%x\n", card->name,\r\nbc->bch.nr, bc->bch.state, protocol);\r\nswitch (protocol) {\r\ncase ISDN_P_NONE:\r\nif (bc->bch.state == ISDN_P_NONE)\r\nbreak;\r\nfill_mem(bc, 0, card->send.size, 0xff);\r\nbc->bch.state = protocol;\r\nif ((card->bc[0].bch.state == ISDN_P_NONE) &&\r\n(card->bc[1].bch.state == ISDN_P_NONE)) {\r\ncard->dmactrl = 0;\r\noutb(card->dmactrl, card->base + NJ_DMACTRL);\r\noutb(0, card->base + NJ_IRQMASK0);\r\n}\r\ntest_and_clear_bit(FLG_HDLC, &bc->bch.Flags);\r\ntest_and_clear_bit(FLG_TRANSPARENT, &bc->bch.Flags);\r\nbc->txstate = 0;\r\nbc->rxstate = 0;\r\nbc->lastrx = -1;\r\nbreak;\r\ncase ISDN_P_B_RAW:\r\ntest_and_set_bit(FLG_TRANSPARENT, &bc->bch.Flags);\r\nbc->bch.state = protocol;\r\nbc->idx = 0;\r\nbc->free = card->send.size / 2;\r\nbc->rxstate = 0;\r\nbc->txstate = TX_INIT | TX_IDLE;\r\nbc->lastrx = -1;\r\nif (!card->dmactrl) {\r\ncard->dmactrl = 1;\r\noutb(card->dmactrl, card->base + NJ_DMACTRL);\r\noutb(0x0f, card->base + NJ_IRQMASK0);\r\n}\r\nbreak;\r\ncase ISDN_P_B_HDLC:\r\ntest_and_set_bit(FLG_HDLC, &bc->bch.Flags);\r\nbc->bch.state = protocol;\r\nbc->idx = 0;\r\nbc->free = card->send.size / 2;\r\nbc->rxstate = 0;\r\nbc->txstate = TX_INIT | TX_IDLE;\r\nisdnhdlc_rcv_init(&bc->hrecv, 0);\r\nisdnhdlc_out_init(&bc->hsend, 0);\r\nbc->lastrx = -1;\r\nif (!card->dmactrl) {\r\ncard->dmactrl = 1;\r\noutb(card->dmactrl, card->base + NJ_DMACTRL);\r\noutb(0x0f, card->base + NJ_IRQMASK0);\r\n}\r\nbreak;\r\ndefault:\r\npr_info("%s: %s protocol %x not handled\n", card->name,\r\n__func__, protocol);\r\nreturn -ENOPROTOOPT;\r\n}\r\ncard->send.dmacur = inl(card->base + NJ_DMA_READ_ADR);\r\ncard->recv.dmacur = inl(card->base + NJ_DMA_WRITE_ADR);\r\ncard->send.idx = (card->send.dmacur - card->send.dmastart) >> 2;\r\ncard->recv.idx = (card->recv.dmacur - card->recv.dmastart) >> 2;\r\npr_debug("%s: %s ctrl %x irq %02x/%02x idx %d/%d\n",\r\ncard->name, __func__,\r\ninb(card->base + NJ_DMACTRL),\r\ninb(card->base + NJ_IRQMASK0),\r\ninb(card->base + NJ_IRQSTAT0),\r\ncard->send.idx,\r\ncard->recv.idx);\r\nreturn 0;\r\n}\r\nstatic void\r\nnj_reset(struct tiger_hw *card)\r\n{\r\noutb(0xff, card->base + NJ_CTRL);\r\nmdelay(1);\r\nif (card->typ == NETJET_S_TJ320)\r\ncard->ctrlreg = 0x40;\r\nelse\r\ncard->ctrlreg = 0x00;\r\noutb(card->ctrlreg, card->base + NJ_CTRL);\r\nmdelay(10);\r\ncard->auxd = 0;\r\ncard->dmactrl = 0;\r\noutb(~NJ_ISACIRQ, card->base + NJ_AUXCTRL);\r\noutb(NJ_ISACIRQ, card->base + NJ_IRQMASK1);\r\noutb(card->auxd, card->base + NJ_AUXDATA);\r\n}\r\nstatic int\r\ninittiger(struct tiger_hw *card)\r\n{\r\nint i;\r\ncard->dma_p = pci_alloc_consistent(card->pdev, NJ_DMA_SIZE,\r\n&card->dma);\r\nif (!card->dma_p) {\r\npr_info("%s: No DMA memory\n", card->name);\r\nreturn -ENOMEM;\r\n}\r\nif ((u64)card->dma > 0xffffffff) {\r\npr_info("%s: DMA outside 32 bit\n", card->name);\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < 2; i++) {\r\ncard->bc[i].hsbuf = kmalloc(NJ_DMA_TXSIZE, GFP_ATOMIC);\r\nif (!card->bc[i].hsbuf) {\r\npr_info("%s: no B%d send buffer\n", card->name, i + 1);\r\nreturn -ENOMEM;\r\n}\r\ncard->bc[i].hrbuf = kmalloc(NJ_DMA_RXSIZE, GFP_ATOMIC);\r\nif (!card->bc[i].hrbuf) {\r\npr_info("%s: no B%d recv buffer\n", card->name, i + 1);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nmemset(card->dma_p, 0xff, NJ_DMA_SIZE);\r\ncard->send.start = card->dma_p;\r\ncard->send.dmastart = (u32)card->dma;\r\ncard->send.dmaend = card->send.dmastart +\r\n(4 * (NJ_DMA_TXSIZE - 1));\r\ncard->send.dmairq = card->send.dmastart +\r\n(4 * ((NJ_DMA_TXSIZE / 2) - 1));\r\ncard->send.size = NJ_DMA_TXSIZE;\r\nif (debug & DEBUG_HW)\r\npr_notice("%s: send buffer phy %#x - %#x - %#x virt %p"\r\n" size %zu u32\n", card->name,\r\ncard->send.dmastart, card->send.dmairq,\r\ncard->send.dmaend, card->send.start, card->send.size);\r\noutl(card->send.dmastart, card->base + NJ_DMA_READ_START);\r\noutl(card->send.dmairq, card->base + NJ_DMA_READ_IRQ);\r\noutl(card->send.dmaend, card->base + NJ_DMA_READ_END);\r\ncard->recv.start = card->dma_p + (NJ_DMA_SIZE / 2);\r\ncard->recv.dmastart = (u32)card->dma + (NJ_DMA_SIZE / 2);\r\ncard->recv.dmaend = card->recv.dmastart +\r\n(4 * (NJ_DMA_RXSIZE - 1));\r\ncard->recv.dmairq = card->recv.dmastart +\r\n(4 * ((NJ_DMA_RXSIZE / 2) - 1));\r\ncard->recv.size = NJ_DMA_RXSIZE;\r\nif (debug & DEBUG_HW)\r\npr_notice("%s: recv buffer phy %#x - %#x - %#x virt %p"\r\n" size %zu u32\n", card->name,\r\ncard->recv.dmastart, card->recv.dmairq,\r\ncard->recv.dmaend, card->recv.start, card->recv.size);\r\noutl(card->recv.dmastart, card->base + NJ_DMA_WRITE_START);\r\noutl(card->recv.dmairq, card->base + NJ_DMA_WRITE_IRQ);\r\noutl(card->recv.dmaend, card->base + NJ_DMA_WRITE_END);\r\nreturn 0;\r\n}\r\nstatic void\r\nread_dma(struct tiger_ch *bc, u32 idx, int cnt)\r\n{\r\nstruct tiger_hw *card = bc->bch.hw;\r\nint i, stat;\r\nu32 val;\r\nu8 *p, *pn;\r\nif (bc->lastrx == idx) {\r\nbc->rxstate |= RX_OVERRUN;\r\npr_info("%s: B%1d overrun at idx %d\n", card->name,\r\nbc->bch.nr, idx);\r\n}\r\nbc->lastrx = idx;\r\nif (test_bit(FLG_RX_OFF, &bc->bch.Flags)) {\r\nbc->bch.dropcnt += cnt;\r\nreturn;\r\n}\r\nstat = bchannel_get_rxbuf(&bc->bch, cnt);\r\nif (stat == -ENOMEM) {\r\npr_warning("%s.B%d: No memory for %d bytes\n",\r\ncard->name, bc->bch.nr, cnt);\r\nreturn;\r\n}\r\nif (test_bit(FLG_TRANSPARENT, &bc->bch.Flags))\r\np = skb_put(bc->bch.rx_skb, cnt);\r\nelse\r\np = bc->hrbuf;\r\nfor (i = 0; i < cnt; i++) {\r\nval = card->recv.start[idx++];\r\nif (bc->bch.nr & 2)\r\nval >>= 8;\r\nif (idx >= card->recv.size)\r\nidx = 0;\r\np[i] = val & 0xff;\r\n}\r\nif (test_bit(FLG_TRANSPARENT, &bc->bch.Flags)) {\r\nrecv_Bchannel(&bc->bch, 0, false);\r\nreturn;\r\n}\r\npn = bc->hrbuf;\r\nwhile (cnt > 0) {\r\nstat = isdnhdlc_decode(&bc->hrecv, pn, cnt, &i,\r\nbc->bch.rx_skb->data, bc->bch.maxlen);\r\nif (stat > 0) {\r\np = skb_put(bc->bch.rx_skb, stat);\r\nif (debug & DEBUG_HW_BFIFO) {\r\nsnprintf(card->log, LOG_SIZE,\r\n"B%1d-recv %s %d ", bc->bch.nr,\r\ncard->name, stat);\r\nprint_hex_dump_bytes(card->log,\r\nDUMP_PREFIX_OFFSET, p,\r\nstat);\r\n}\r\nrecv_Bchannel(&bc->bch, 0, false);\r\nstat = bchannel_get_rxbuf(&bc->bch, bc->bch.maxlen);\r\nif (stat < 0) {\r\npr_warning("%s.B%d: No memory for %d bytes\n",\r\ncard->name, bc->bch.nr, cnt);\r\nreturn;\r\n}\r\n} else if (stat == -HDLC_CRC_ERROR) {\r\npr_info("%s: B%1d receive frame CRC error\n",\r\ncard->name, bc->bch.nr);\r\n} else if (stat == -HDLC_FRAMING_ERROR) {\r\npr_info("%s: B%1d receive framing error\n",\r\ncard->name, bc->bch.nr);\r\n} else if (stat == -HDLC_LENGTH_ERROR) {\r\npr_info("%s: B%1d receive frame too long (> %d)\n",\r\ncard->name, bc->bch.nr, bc->bch.maxlen);\r\n}\r\npn += i;\r\ncnt -= i;\r\n}\r\n}\r\nstatic void\r\nrecv_tiger(struct tiger_hw *card, u8 irq_stat)\r\n{\r\nu32 idx;\r\nint cnt = card->recv.size / 2;\r\ncard->last_is0 &= ~NJ_IRQM0_WR_MASK;\r\ncard->last_is0 |= (irq_stat & NJ_IRQM0_WR_MASK);\r\nif (irq_stat & NJ_IRQM0_WR_END)\r\nidx = cnt - 1;\r\nelse\r\nidx = card->recv.size - 1;\r\nif (test_bit(FLG_ACTIVE, &card->bc[0].bch.Flags))\r\nread_dma(&card->bc[0], idx, cnt);\r\nif (test_bit(FLG_ACTIVE, &card->bc[1].bch.Flags))\r\nread_dma(&card->bc[1], idx, cnt);\r\n}\r\nstatic void\r\nresync(struct tiger_ch *bc, struct tiger_hw *card)\r\n{\r\ncard->send.dmacur = inl(card->base | NJ_DMA_READ_ADR);\r\ncard->send.idx = (card->send.dmacur - card->send.dmastart) >> 2;\r\nif (bc->free > card->send.size / 2)\r\nbc->free = card->send.size / 2;\r\nif (card->send.idx < ((card->send.size / 2) - 1))\r\nbc->idx = (card->recv.size / 2) - 1;\r\nelse\r\nbc->idx = card->recv.size - 1;\r\nbc->txstate = TX_RUN;\r\npr_debug("%s: %s B%1d free %d idx %d/%d\n", card->name,\r\n__func__, bc->bch.nr, bc->free, bc->idx, card->send.idx);\r\n}\r\nstatic void\r\nfill_hdlc_flag(struct tiger_ch *bc)\r\n{\r\nstruct tiger_hw *card = bc->bch.hw;\r\nint count, i;\r\nu32 m, v;\r\nu8 *p;\r\nif (bc->free == 0)\r\nreturn;\r\npr_debug("%s: %s B%1d %d state %x idx %d/%d\n", card->name,\r\n__func__, bc->bch.nr, bc->free, bc->txstate,\r\nbc->idx, card->send.idx);\r\nif (bc->txstate & (TX_IDLE | TX_INIT | TX_UNDERRUN))\r\nresync(bc, card);\r\ncount = isdnhdlc_encode(&bc->hsend, NULL, 0, &i,\r\nbc->hsbuf, bc->free);\r\npr_debug("%s: B%1d hdlc encoded %d flags\n", card->name,\r\nbc->bch.nr, count);\r\nbc->free -= count;\r\np = bc->hsbuf;\r\nm = (bc->bch.nr & 1) ? 0xffffff00 : 0xffff00ff;\r\nfor (i = 0; i < count; i++) {\r\nif (bc->idx >= card->send.size)\r\nbc->idx = 0;\r\nv = card->send.start[bc->idx];\r\nv &= m;\r\nv |= (bc->bch.nr & 1) ? (u32)(p[i]) : ((u32)(p[i])) << 8;\r\ncard->send.start[bc->idx++] = v;\r\n}\r\nif (debug & DEBUG_HW_BFIFO) {\r\nsnprintf(card->log, LOG_SIZE, "B%1d-send %s %d ",\r\nbc->bch.nr, card->name, count);\r\nprint_hex_dump_bytes(card->log, DUMP_PREFIX_OFFSET, p, count);\r\n}\r\n}\r\nstatic void\r\nfill_dma(struct tiger_ch *bc)\r\n{\r\nstruct tiger_hw *card = bc->bch.hw;\r\nint count, i, fillempty = 0;\r\nu32 m, v, n = 0;\r\nu8 *p;\r\nif (bc->free == 0)\r\nreturn;\r\nif (!bc->bch.tx_skb) {\r\nif (!test_bit(FLG_TX_EMPTY, &bc->bch.Flags))\r\nreturn;\r\nfillempty = 1;\r\ncount = card->send.size >> 1;\r\np = bc->bch.fill;\r\n} else {\r\ncount = bc->bch.tx_skb->len - bc->bch.tx_idx;\r\nif (count <= 0)\r\nreturn;\r\npr_debug("%s: %s B%1d %d/%d/%d/%d state %x idx %d/%d\n",\r\ncard->name, __func__, bc->bch.nr, count, bc->free,\r\nbc->bch.tx_idx, bc->bch.tx_skb->len, bc->txstate,\r\nbc->idx, card->send.idx);\r\np = bc->bch.tx_skb->data + bc->bch.tx_idx;\r\n}\r\nif (bc->txstate & (TX_IDLE | TX_INIT | TX_UNDERRUN))\r\nresync(bc, card);\r\nif (test_bit(FLG_HDLC, &bc->bch.Flags) && !fillempty) {\r\ncount = isdnhdlc_encode(&bc->hsend, p, count, &i,\r\nbc->hsbuf, bc->free);\r\npr_debug("%s: B%1d hdlc encoded %d in %d\n", card->name,\r\nbc->bch.nr, i, count);\r\nbc->bch.tx_idx += i;\r\nbc->free -= count;\r\np = bc->hsbuf;\r\n} else {\r\nif (count > bc->free)\r\ncount = bc->free;\r\nif (!fillempty)\r\nbc->bch.tx_idx += count;\r\nbc->free -= count;\r\n}\r\nm = (bc->bch.nr & 1) ? 0xffffff00 : 0xffff00ff;\r\nif (fillempty) {\r\nn = p[0];\r\nif (!(bc->bch.nr & 1))\r\nn <<= 8;\r\nfor (i = 0; i < count; i++) {\r\nif (bc->idx >= card->send.size)\r\nbc->idx = 0;\r\nv = card->send.start[bc->idx];\r\nv &= m;\r\nv |= n;\r\ncard->send.start[bc->idx++] = v;\r\n}\r\n} else {\r\nfor (i = 0; i < count; i++) {\r\nif (bc->idx >= card->send.size)\r\nbc->idx = 0;\r\nv = card->send.start[bc->idx];\r\nv &= m;\r\nn = p[i];\r\nv |= (bc->bch.nr & 1) ? n : n << 8;\r\ncard->send.start[bc->idx++] = v;\r\n}\r\n}\r\nif (debug & DEBUG_HW_BFIFO) {\r\nsnprintf(card->log, LOG_SIZE, "B%1d-send %s %d ",\r\nbc->bch.nr, card->name, count);\r\nprint_hex_dump_bytes(card->log, DUMP_PREFIX_OFFSET, p, count);\r\n}\r\nif (bc->free)\r\nbc_next_frame(bc);\r\n}\r\nstatic int\r\nbc_next_frame(struct tiger_ch *bc)\r\n{\r\nint ret = 1;\r\nif (bc->bch.tx_skb && bc->bch.tx_idx < bc->bch.tx_skb->len) {\r\nfill_dma(bc);\r\n} else {\r\nif (bc->bch.tx_skb)\r\ndev_kfree_skb(bc->bch.tx_skb);\r\nif (get_next_bframe(&bc->bch)) {\r\nfill_dma(bc);\r\ntest_and_clear_bit(FLG_TX_EMPTY, &bc->bch.Flags);\r\n} else if (test_bit(FLG_TX_EMPTY, &bc->bch.Flags)) {\r\nfill_dma(bc);\r\n} else if (test_bit(FLG_FILLEMPTY, &bc->bch.Flags)) {\r\ntest_and_set_bit(FLG_TX_EMPTY, &bc->bch.Flags);\r\nret = 0;\r\n} else {\r\nret = 0;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void\r\nsend_tiger_bc(struct tiger_hw *card, struct tiger_ch *bc)\r\n{\r\nint ret;\r\nbc->free += card->send.size / 2;\r\nif (bc->free >= card->send.size) {\r\nif (!(bc->txstate & (TX_UNDERRUN | TX_INIT))) {\r\npr_info("%s: B%1d TX underrun state %x\n", card->name,\r\nbc->bch.nr, bc->txstate);\r\nbc->txstate |= TX_UNDERRUN;\r\n}\r\nbc->free = card->send.size;\r\n}\r\nret = bc_next_frame(bc);\r\nif (!ret) {\r\nif (test_bit(FLG_HDLC, &bc->bch.Flags)) {\r\nfill_hdlc_flag(bc);\r\nreturn;\r\n}\r\npr_debug("%s: B%1d TX no data free %d idx %d/%d\n", card->name,\r\nbc->bch.nr, bc->free, bc->idx, card->send.idx);\r\nif (!(bc->txstate & (TX_IDLE | TX_INIT))) {\r\nfill_mem(bc, bc->idx, bc->free, 0xff);\r\nif (bc->free == card->send.size)\r\nbc->txstate |= TX_IDLE;\r\n}\r\n}\r\n}\r\nstatic void\r\nsend_tiger(struct tiger_hw *card, u8 irq_stat)\r\n{\r\nint i;\r\nif ((irq_stat & card->last_is0) & NJ_IRQM0_RD_MASK) {\r\npr_info("%s: tiger warn write double dma %x/%x\n",\r\ncard->name, irq_stat, card->last_is0);\r\nreturn;\r\n} else {\r\ncard->last_is0 &= ~NJ_IRQM0_RD_MASK;\r\ncard->last_is0 |= (irq_stat & NJ_IRQM0_RD_MASK);\r\n}\r\nfor (i = 0; i < 2; i++) {\r\nif (test_bit(FLG_ACTIVE, &card->bc[i].bch.Flags))\r\nsend_tiger_bc(card, &card->bc[i]);\r\n}\r\n}\r\nstatic irqreturn_t\r\nnj_irq(int intno, void *dev_id)\r\n{\r\nstruct tiger_hw *card = dev_id;\r\nu8 val, s1val, s0val;\r\nspin_lock(&card->lock);\r\ns0val = inb(card->base | NJ_IRQSTAT0);\r\ns1val = inb(card->base | NJ_IRQSTAT1);\r\nif ((s1val & NJ_ISACIRQ) && (s0val == 0)) {\r\nspin_unlock(&card->lock);\r\nreturn IRQ_NONE;\r\n}\r\npr_debug("%s: IRQSTAT0 %02x IRQSTAT1 %02x\n", card->name, s0val, s1val);\r\ncard->irqcnt++;\r\nif (!(s1val & NJ_ISACIRQ)) {\r\nval = ReadISAC_nj(card, ISAC_ISTA);\r\nif (val)\r\nmISDNisac_irq(&card->isac, val);\r\n}\r\nif (s0val)\r\noutb(s0val, card->base | NJ_IRQSTAT0);\r\nelse\r\ngoto end;\r\ns1val = s0val;\r\ncard->recv.dmacur = inl(card->base | NJ_DMA_WRITE_ADR);\r\ncard->recv.idx = (card->recv.dmacur - card->recv.dmastart) >> 2;\r\nif (card->recv.dmacur < card->recv.dmairq)\r\ns0val = 0x08;\r\nelse\r\ns0val = 0x04;\r\ncard->send.dmacur = inl(card->base | NJ_DMA_READ_ADR);\r\ncard->send.idx = (card->send.dmacur - card->send.dmastart) >> 2;\r\nif (card->send.dmacur < card->send.dmairq)\r\ns0val |= 0x02;\r\nelse\r\ns0val |= 0x01;\r\npr_debug("%s: DMA Status %02x/%02x/%02x %d/%d\n", card->name,\r\ns1val, s0val, card->last_is0,\r\ncard->recv.idx, card->send.idx);\r\nif (s0val != card->last_is0) {\r\nif ((s0val & NJ_IRQM0_RD_MASK) !=\r\n(card->last_is0 & NJ_IRQM0_RD_MASK))\r\nsend_tiger(card, s0val);\r\nif ((s0val & NJ_IRQM0_WR_MASK) !=\r\n(card->last_is0 & NJ_IRQM0_WR_MASK))\r\nrecv_tiger(card, s0val);\r\n}\r\nend:\r\nspin_unlock(&card->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int\r\nnj_l2l1B(struct mISDNchannel *ch, struct sk_buff *skb)\r\n{\r\nint ret = -EINVAL;\r\nstruct bchannel *bch = container_of(ch, struct bchannel, ch);\r\nstruct tiger_ch *bc = container_of(bch, struct tiger_ch, bch);\r\nstruct tiger_hw *card = bch->hw;\r\nstruct mISDNhead *hh = mISDN_HEAD_P(skb);\r\nunsigned long flags;\r\nswitch (hh->prim) {\r\ncase PH_DATA_REQ:\r\nspin_lock_irqsave(&card->lock, flags);\r\nret = bchannel_senddata(bch, skb);\r\nif (ret > 0) {\r\nfill_dma(bc);\r\nret = 0;\r\n}\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nreturn ret;\r\ncase PH_ACTIVATE_REQ:\r\nspin_lock_irqsave(&card->lock, flags);\r\nif (!test_and_set_bit(FLG_ACTIVE, &bch->Flags))\r\nret = mode_tiger(bc, ch->protocol);\r\nelse\r\nret = 0;\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nif (!ret)\r\n_queue_data(ch, PH_ACTIVATE_IND, MISDN_ID_ANY, 0,\r\nNULL, GFP_KERNEL);\r\nbreak;\r\ncase PH_DEACTIVATE_REQ:\r\nspin_lock_irqsave(&card->lock, flags);\r\nmISDN_clear_bchannel(bch);\r\nmode_tiger(bc, ISDN_P_NONE);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\n_queue_data(ch, PH_DEACTIVATE_IND, MISDN_ID_ANY, 0,\r\nNULL, GFP_KERNEL);\r\nret = 0;\r\nbreak;\r\n}\r\nif (!ret)\r\ndev_kfree_skb(skb);\r\nreturn ret;\r\n}\r\nstatic int\r\nchannel_bctrl(struct tiger_ch *bc, struct mISDN_ctrl_req *cq)\r\n{\r\nreturn mISDN_ctrl_bchannel(&bc->bch, cq);\r\n}\r\nstatic int\r\nnj_bctrl(struct mISDNchannel *ch, u32 cmd, void *arg)\r\n{\r\nstruct bchannel *bch = container_of(ch, struct bchannel, ch);\r\nstruct tiger_ch *bc = container_of(bch, struct tiger_ch, bch);\r\nstruct tiger_hw *card = bch->hw;\r\nint ret = -EINVAL;\r\nu_long flags;\r\npr_debug("%s: %s cmd:%x %p\n", card->name, __func__, cmd, arg);\r\nswitch (cmd) {\r\ncase CLOSE_CHANNEL:\r\ntest_and_clear_bit(FLG_OPEN, &bch->Flags);\r\ncancel_work_sync(&bch->workq);\r\nspin_lock_irqsave(&card->lock, flags);\r\nmISDN_clear_bchannel(bch);\r\nmode_tiger(bc, ISDN_P_NONE);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nch->protocol = ISDN_P_NONE;\r\nch->peer = NULL;\r\nmodule_put(THIS_MODULE);\r\nret = 0;\r\nbreak;\r\ncase CONTROL_CHANNEL:\r\nret = channel_bctrl(bc, arg);\r\nbreak;\r\ndefault:\r\npr_info("%s: %s unknown prim(%x)\n", card->name, __func__, cmd);\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nchannel_ctrl(struct tiger_hw *card, struct mISDN_ctrl_req *cq)\r\n{\r\nint ret = 0;\r\nswitch (cq->op) {\r\ncase MISDN_CTRL_GETOP:\r\ncq->op = MISDN_CTRL_LOOP | MISDN_CTRL_L1_TIMER3;\r\nbreak;\r\ncase MISDN_CTRL_LOOP:\r\nif (cq->channel < 0 || cq->channel > 3) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nret = card->isac.ctrl(&card->isac, HW_TESTLOOP, cq->channel);\r\nbreak;\r\ncase MISDN_CTRL_L1_TIMER3:\r\nret = card->isac.ctrl(&card->isac, HW_TIMER3_VALUE, cq->p1);\r\nbreak;\r\ndefault:\r\npr_info("%s: %s unknown Op %x\n", card->name, __func__, cq->op);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nopen_bchannel(struct tiger_hw *card, struct channel_req *rq)\r\n{\r\nstruct bchannel *bch;\r\nif (rq->adr.channel == 0 || rq->adr.channel > 2)\r\nreturn -EINVAL;\r\nif (rq->protocol == ISDN_P_NONE)\r\nreturn -EINVAL;\r\nbch = &card->bc[rq->adr.channel - 1].bch;\r\nif (test_and_set_bit(FLG_OPEN, &bch->Flags))\r\nreturn -EBUSY;\r\ntest_and_clear_bit(FLG_FILLEMPTY, &bch->Flags);\r\nbch->ch.protocol = rq->protocol;\r\nrq->ch = &bch->ch;\r\nreturn 0;\r\n}\r\nstatic int\r\nnj_dctrl(struct mISDNchannel *ch, u32 cmd, void *arg)\r\n{\r\nstruct mISDNdevice *dev = container_of(ch, struct mISDNdevice, D);\r\nstruct dchannel *dch = container_of(dev, struct dchannel, dev);\r\nstruct tiger_hw *card = dch->hw;\r\nstruct channel_req *rq;\r\nint err = 0;\r\npr_debug("%s: %s cmd:%x %p\n", card->name, __func__, cmd, arg);\r\nswitch (cmd) {\r\ncase OPEN_CHANNEL:\r\nrq = arg;\r\nif (rq->protocol == ISDN_P_TE_S0)\r\nerr = card->isac.open(&card->isac, rq);\r\nelse\r\nerr = open_bchannel(card, rq);\r\nif (err)\r\nbreak;\r\nif (!try_module_get(THIS_MODULE))\r\npr_info("%s: cannot get module\n", card->name);\r\nbreak;\r\ncase CLOSE_CHANNEL:\r\npr_debug("%s: dev(%d) close from %p\n", card->name, dch->dev.id,\r\n__builtin_return_address(0));\r\nmodule_put(THIS_MODULE);\r\nbreak;\r\ncase CONTROL_CHANNEL:\r\nerr = channel_ctrl(card, arg);\r\nbreak;\r\ndefault:\r\npr_debug("%s: %s unknown command %x\n",\r\ncard->name, __func__, cmd);\r\nreturn -EINVAL;\r\n}\r\nreturn err;\r\n}\r\nstatic int\r\nnj_init_card(struct tiger_hw *card)\r\n{\r\nu_long flags;\r\nint ret;\r\nspin_lock_irqsave(&card->lock, flags);\r\nnj_disable_hwirq(card);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\ncard->irq = card->pdev->irq;\r\nif (request_irq(card->irq, nj_irq, IRQF_SHARED, card->name, card)) {\r\npr_info("%s: couldn't get interrupt %d\n",\r\ncard->name, card->irq);\r\ncard->irq = -1;\r\nreturn -EIO;\r\n}\r\nspin_lock_irqsave(&card->lock, flags);\r\nnj_reset(card);\r\nret = card->isac.init(&card->isac);\r\nif (ret)\r\ngoto error;\r\nret = inittiger(card);\r\nif (ret)\r\ngoto error;\r\nmode_tiger(&card->bc[0], ISDN_P_NONE);\r\nmode_tiger(&card->bc[1], ISDN_P_NONE);\r\nerror:\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void\r\nnj_release(struct tiger_hw *card)\r\n{\r\nu_long flags;\r\nint i;\r\nif (card->base_s) {\r\nspin_lock_irqsave(&card->lock, flags);\r\nnj_disable_hwirq(card);\r\nmode_tiger(&card->bc[0], ISDN_P_NONE);\r\nmode_tiger(&card->bc[1], ISDN_P_NONE);\r\ncard->isac.release(&card->isac);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nrelease_region(card->base, card->base_s);\r\ncard->base_s = 0;\r\n}\r\nif (card->irq > 0)\r\nfree_irq(card->irq, card);\r\nif (card->isac.dch.dev.dev.class)\r\nmISDN_unregister_device(&card->isac.dch.dev);\r\nfor (i = 0; i < 2; i++) {\r\nmISDN_freebchannel(&card->bc[i].bch);\r\nkfree(card->bc[i].hsbuf);\r\nkfree(card->bc[i].hrbuf);\r\n}\r\nif (card->dma_p)\r\npci_free_consistent(card->pdev, NJ_DMA_SIZE,\r\ncard->dma_p, card->dma);\r\nwrite_lock_irqsave(&card_lock, flags);\r\nlist_del(&card->list);\r\nwrite_unlock_irqrestore(&card_lock, flags);\r\npci_clear_master(card->pdev);\r\npci_disable_device(card->pdev);\r\npci_set_drvdata(card->pdev, NULL);\r\nkfree(card);\r\n}\r\nstatic int\r\nnj_setup(struct tiger_hw *card)\r\n{\r\ncard->base = pci_resource_start(card->pdev, 0);\r\ncard->base_s = pci_resource_len(card->pdev, 0);\r\nif (!request_region(card->base, card->base_s, card->name)) {\r\npr_info("%s: NETjet config port %#x-%#x already in use\n",\r\ncard->name, card->base,\r\n(u32)(card->base + card->base_s - 1));\r\ncard->base_s = 0;\r\nreturn -EIO;\r\n}\r\nASSIGN_FUNC(nj, ISAC, card->isac);\r\nreturn 0;\r\n}\r\nstatic int\r\nsetup_instance(struct tiger_hw *card)\r\n{\r\nint i, err;\r\nu_long flags;\r\nsnprintf(card->name, MISDN_MAX_IDLEN - 1, "netjet.%d", nj_cnt + 1);\r\nwrite_lock_irqsave(&card_lock, flags);\r\nlist_add_tail(&card->list, &Cards);\r\nwrite_unlock_irqrestore(&card_lock, flags);\r\n_set_debug(card);\r\ncard->isac.name = card->name;\r\nspin_lock_init(&card->lock);\r\ncard->isac.hwlock = &card->lock;\r\nmISDNisac_init(&card->isac, card);\r\ncard->isac.dch.dev.Bprotocols = (1 << (ISDN_P_B_RAW & ISDN_P_B_MASK)) |\r\n(1 << (ISDN_P_B_HDLC & ISDN_P_B_MASK));\r\ncard->isac.dch.dev.D.ctrl = nj_dctrl;\r\nfor (i = 0; i < 2; i++) {\r\ncard->bc[i].bch.nr = i + 1;\r\nset_channelmap(i + 1, card->isac.dch.dev.channelmap);\r\nmISDN_initbchannel(&card->bc[i].bch, MAX_DATA_MEM,\r\nNJ_DMA_RXSIZE >> 1);\r\ncard->bc[i].bch.hw = card;\r\ncard->bc[i].bch.ch.send = nj_l2l1B;\r\ncard->bc[i].bch.ch.ctrl = nj_bctrl;\r\ncard->bc[i].bch.ch.nr = i + 1;\r\nlist_add(&card->bc[i].bch.ch.list,\r\n&card->isac.dch.dev.bchannels);\r\ncard->bc[i].bch.hw = card;\r\n}\r\nerr = nj_setup(card);\r\nif (err)\r\ngoto error;\r\nerr = mISDN_register_device(&card->isac.dch.dev, &card->pdev->dev,\r\ncard->name);\r\nif (err)\r\ngoto error;\r\nerr = nj_init_card(card);\r\nif (!err) {\r\nnj_cnt++;\r\npr_notice("Netjet %d cards installed\n", nj_cnt);\r\nreturn 0;\r\n}\r\nerror:\r\nnj_release(card);\r\nreturn err;\r\n}\r\nstatic int\r\nnj_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nint err = -ENOMEM;\r\nint cfg;\r\nstruct tiger_hw *card;\r\nif (pdev->subsystem_vendor == 0x8086 &&\r\npdev->subsystem_device == 0x0003) {\r\npr_notice("Netjet: Digium X100P/X101P not handled\n");\r\nreturn -ENODEV;\r\n}\r\nif (pdev->subsystem_vendor == 0x55 &&\r\npdev->subsystem_device == 0x02) {\r\npr_notice("Netjet: Enter!Now not handled yet\n");\r\nreturn -ENODEV;\r\n}\r\nif (pdev->subsystem_vendor == 0xb100 &&\r\npdev->subsystem_device == 0x0003) {\r\npr_notice("Netjet: Digium TDM400P not handled yet\n");\r\nreturn -ENODEV;\r\n}\r\ncard = kzalloc(sizeof(struct tiger_hw), GFP_ATOMIC);\r\nif (!card) {\r\npr_info("No kmem for Netjet\n");\r\nreturn err;\r\n}\r\ncard->pdev = pdev;\r\nerr = pci_enable_device(pdev);\r\nif (err) {\r\nkfree(card);\r\nreturn err;\r\n}\r\nprintk(KERN_INFO "nj_probe(mISDN): found adapter at %s\n",\r\npci_name(pdev));\r\npci_set_master(pdev);\r\npci_read_config_dword(pdev, 0x04, &cfg);\r\nif (cfg & 0x00100000)\r\ncard->typ = NETJET_S_TJ320;\r\nelse\r\ncard->typ = NETJET_S_TJ300;\r\ncard->base = pci_resource_start(pdev, 0);\r\ncard->irq = pdev->irq;\r\npci_set_drvdata(pdev, card);\r\nerr = setup_instance(card);\r\nif (err)\r\npci_set_drvdata(pdev, NULL);\r\nreturn err;\r\n}\r\nstatic void nj_remove(struct pci_dev *pdev)\r\n{\r\nstruct tiger_hw *card = pci_get_drvdata(pdev);\r\nif (card)\r\nnj_release(card);\r\nelse\r\npr_info("%s drvdata already removed\n", __func__);\r\n}\r\nstatic int __init nj_init(void)\r\n{\r\nint err;\r\npr_notice("Netjet PCI driver Rev. %s\n", NETJET_REV);\r\nerr = pci_register_driver(&nj_driver);\r\nreturn err;\r\n}\r\nstatic void __exit nj_cleanup(void)\r\n{\r\npci_unregister_driver(&nj_driver);\r\n}
