s32 rtw_hal_init_xmit_priv(struct adapter *adapt)\r\n{\r\nstruct xmit_priv *pxmitpriv = &adapt->xmitpriv;\r\ntasklet_init(&pxmitpriv->xmit_tasklet,\r\n(void(*)(unsigned long))rtl8188eu_xmit_tasklet,\r\n(unsigned long)adapt);\r\nreturn _SUCCESS;\r\n}\r\nstatic u8 urb_zero_packet_chk(struct adapter *adapt, int sz)\r\n{\r\nreturn !((sz + TXDESC_SIZE) % adapt->HalData->UsbBulkOutSize);\r\n}\r\nstatic void rtl8188eu_cal_txdesc_chksum(struct tx_desc *ptxdesc)\r\n{\r\nu16 *usptr = (u16 *)ptxdesc;\r\nu32 count = 16;\r\nu32 index;\r\nu16 checksum = 0;\r\nptxdesc->txdw7 &= cpu_to_le32(0xffff0000);\r\nfor (index = 0; index < count; index++)\r\nchecksum = checksum ^ le16_to_cpu(*(__le16 *)(usptr + index));\r\nptxdesc->txdw7 |= cpu_to_le32(0x0000ffff & checksum);\r\n}\r\nvoid rtl8188e_fill_fake_txdesc(struct adapter *adapt, u8 *desc, u32 BufferLen, u8 ispspoll, u8 is_btqosnull)\r\n{\r\nstruct tx_desc *ptxdesc;\r\nptxdesc = (struct tx_desc *)desc;\r\nmemset(desc, 0, TXDESC_SIZE);\r\nptxdesc->txdw0 |= cpu_to_le32(OWN | FSG | LSG);\r\nptxdesc->txdw0 |= cpu_to_le32(((TXDESC_SIZE+OFFSET_SZ)<<OFFSET_SHT)&0x00ff0000);\r\nptxdesc->txdw0 |= cpu_to_le32(BufferLen&0x0000ffff);\r\nptxdesc->txdw1 |= cpu_to_le32((QSLT_MGNT<<QSEL_SHT)&0x00001f00);\r\nif (ispspoll) {\r\nptxdesc->txdw1 |= cpu_to_le32(NAVUSEHDR);\r\n} else {\r\nptxdesc->txdw4 |= cpu_to_le32(BIT(7));\r\nptxdesc->txdw3 |= cpu_to_le32((8 << 28));\r\n}\r\nif (is_btqosnull)\r\nptxdesc->txdw2 |= cpu_to_le32(BIT(23));\r\nptxdesc->txdw4 |= cpu_to_le32(BIT(8));\r\nrtl8188eu_cal_txdesc_chksum(ptxdesc);\r\n}\r\nstatic void fill_txdesc_sectype(struct pkt_attrib *pattrib, struct tx_desc *ptxdesc)\r\n{\r\nif ((pattrib->encrypt > 0) && !pattrib->bswenc) {\r\nswitch (pattrib->encrypt) {\r\ncase _WEP40_:\r\ncase _WEP104_:\r\nptxdesc->txdw1 |= cpu_to_le32((0x01<<SEC_TYPE_SHT)&0x00c00000);\r\nptxdesc->txdw2 |= cpu_to_le32(0x7 << AMPDU_DENSITY_SHT);\r\nbreak;\r\ncase _TKIP_:\r\ncase _TKIP_WTMIC_:\r\nptxdesc->txdw1 |= cpu_to_le32((0x01<<SEC_TYPE_SHT)&0x00c00000);\r\nptxdesc->txdw2 |= cpu_to_le32(0x7 << AMPDU_DENSITY_SHT);\r\nbreak;\r\ncase _AES_:\r\nptxdesc->txdw1 |= cpu_to_le32((0x03<<SEC_TYPE_SHT)&0x00c00000);\r\nptxdesc->txdw2 |= cpu_to_le32(0x7 << AMPDU_DENSITY_SHT);\r\nbreak;\r\ncase _NO_PRIVACY_:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void fill_txdesc_vcs(struct pkt_attrib *pattrib, __le32 *pdw)\r\n{\r\nswitch (pattrib->vcs_mode) {\r\ncase RTS_CTS:\r\n*pdw |= cpu_to_le32(RTS_EN);\r\nbreak;\r\ncase CTS_TO_SELF:\r\n*pdw |= cpu_to_le32(CTS_2_SELF);\r\nbreak;\r\ncase NONE_VCS:\r\ndefault:\r\nbreak;\r\n}\r\nif (pattrib->vcs_mode) {\r\n*pdw |= cpu_to_le32(HW_RTS_EN);\r\nif (pattrib->ht_en) {\r\n*pdw |= (pattrib->bwmode&HT_CHANNEL_WIDTH_40) ? cpu_to_le32(BIT(27)) : 0;\r\nif (pattrib->ch_offset == HAL_PRIME_CHNL_OFFSET_LOWER)\r\n*pdw |= cpu_to_le32((0x01 << 28) & 0x30000000);\r\nelse if (pattrib->ch_offset == HAL_PRIME_CHNL_OFFSET_UPPER)\r\n*pdw |= cpu_to_le32((0x02 << 28) & 0x30000000);\r\nelse if (pattrib->ch_offset == HAL_PRIME_CHNL_OFFSET_DONT_CARE)\r\n*pdw |= 0;\r\nelse\r\n*pdw |= cpu_to_le32((0x03 << 28) & 0x30000000);\r\n}\r\n}\r\n}\r\nstatic void fill_txdesc_phy(struct pkt_attrib *pattrib, __le32 *pdw)\r\n{\r\nif (pattrib->ht_en) {\r\n*pdw |= (pattrib->bwmode&HT_CHANNEL_WIDTH_40) ? cpu_to_le32(BIT(25)) : 0;\r\nif (pattrib->ch_offset == HAL_PRIME_CHNL_OFFSET_LOWER)\r\n*pdw |= cpu_to_le32((0x01 << DATA_SC_SHT) & 0x003f0000);\r\nelse if (pattrib->ch_offset == HAL_PRIME_CHNL_OFFSET_UPPER)\r\n*pdw |= cpu_to_le32((0x02 << DATA_SC_SHT) & 0x003f0000);\r\nelse if (pattrib->ch_offset == HAL_PRIME_CHNL_OFFSET_DONT_CARE)\r\n*pdw |= 0;\r\nelse\r\n*pdw |= cpu_to_le32((0x03 << DATA_SC_SHT) & 0x003f0000);\r\n}\r\n}\r\nstatic s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz, u8 bagg_pkt)\r\n{\r\nint pull = 0;\r\nuint qsel;\r\nu8 data_rate, pwr_status, offset;\r\nstruct adapter *adapt = pxmitframe->padapter;\r\nstruct pkt_attrib *pattrib = &pxmitframe->attrib;\r\nstruct odm_dm_struct *odmpriv = &adapt->HalData->odmpriv;\r\nstruct tx_desc *ptxdesc = (struct tx_desc *)pmem;\r\nstruct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nint bmcst = IS_MCAST(pattrib->ra);\r\nif (adapt->registrypriv.mp_mode == 0) {\r\nif ((!bagg_pkt) && (urb_zero_packet_chk(adapt, sz) == 0)) {\r\nptxdesc = (struct tx_desc *)(pmem+PACKET_OFFSET_SZ);\r\npull = 1;\r\n}\r\n}\r\nmemset(ptxdesc, 0, sizeof(struct tx_desc));\r\nptxdesc->txdw0 |= cpu_to_le32(OWN | FSG | LSG);\r\nptxdesc->txdw0 |= cpu_to_le32(sz & 0x0000ffff);\r\noffset = TXDESC_SIZE + OFFSET_SZ;\r\nptxdesc->txdw0 |= cpu_to_le32(((offset) << OFFSET_SHT) & 0x00ff0000);\r\nif (bmcst)\r\nptxdesc->txdw0 |= cpu_to_le32(BMC);\r\nif (adapt->registrypriv.mp_mode == 0) {\r\nif (!bagg_pkt) {\r\nif ((pull) && (pxmitframe->pkt_offset > 0))\r\npxmitframe->pkt_offset = pxmitframe->pkt_offset - 1;\r\n}\r\n}\r\nif (pxmitframe->pkt_offset > 0)\r\nptxdesc->txdw1 |= cpu_to_le32((pxmitframe->pkt_offset << 26) & 0x7c000000);\r\nptxdesc->txdw4 |= cpu_to_le32(USERATE);\r\nif ((pxmitframe->frame_tag & 0x0f) == DATA_FRAMETAG) {\r\nptxdesc->txdw1 |= cpu_to_le32(pattrib->mac_id & 0x3F);\r\nqsel = (uint)(pattrib->qsel & 0x0000001f);\r\nptxdesc->txdw1 |= cpu_to_le32((qsel << QSEL_SHT) & 0x00001f00);\r\nptxdesc->txdw1 |= cpu_to_le32((pattrib->raid << RATE_ID_SHT) & 0x000F0000);\r\nfill_txdesc_sectype(pattrib, ptxdesc);\r\nif (pattrib->ampdu_en) {\r\nptxdesc->txdw2 |= cpu_to_le32(AGG_EN);\r\nptxdesc->txdw6 = cpu_to_le32(0x6666f800);\r\n} else {\r\nptxdesc->txdw2 |= cpu_to_le32(AGG_BK);\r\n}\r\nptxdesc->txdw3 |= cpu_to_le32((pattrib->seqnum << SEQ_SHT) & 0x0FFF0000);\r\nif (pattrib->qos_en)\r\nptxdesc->txdw4 |= cpu_to_le32(QOS);\r\nif (pxmitframe->agg_num > 1)\r\nptxdesc->txdw5 |= cpu_to_le32((pxmitframe->agg_num << USB_TXAGG_NUM_SHT) & 0xFF000000);\r\nif ((pattrib->ether_type != 0x888e) &&\r\n(pattrib->ether_type != 0x0806) &&\r\n(pattrib->ether_type != 0x88b4) &&\r\n(pattrib->dhcp_pkt != 1)) {\r\nfill_txdesc_vcs(pattrib, &ptxdesc->txdw4);\r\nfill_txdesc_phy(pattrib, &ptxdesc->txdw4);\r\nptxdesc->txdw4 |= cpu_to_le32(0x00000008);\r\nptxdesc->txdw5 |= cpu_to_le32(0x0001ff00);\r\nif (pattrib->ht_en) {\r\nif (ODM_RA_GetShortGI_8188E(odmpriv, pattrib->mac_id))\r\nptxdesc->txdw5 |= cpu_to_le32(SGI);\r\n}\r\ndata_rate = ODM_RA_GetDecisionRate_8188E(odmpriv, pattrib->mac_id);\r\nptxdesc->txdw5 |= cpu_to_le32(data_rate & 0x3F);\r\npwr_status = ODM_RA_GetHwPwrStatus_8188E(odmpriv, pattrib->mac_id);\r\nptxdesc->txdw4 |= cpu_to_le32((pwr_status & 0x7) << PWR_STATUS_SHT);\r\n} else {\r\nptxdesc->txdw2 |= cpu_to_le32(AGG_BK);\r\nif (pmlmeinfo->preamble_mode == PREAMBLE_SHORT)\r\nptxdesc->txdw4 |= cpu_to_le32(BIT(24));\r\nptxdesc->txdw5 |= cpu_to_le32(MRateToHwRate(pmlmeext->tx_rate));\r\n}\r\n} else if ((pxmitframe->frame_tag&0x0f) == MGNT_FRAMETAG) {\r\nptxdesc->txdw1 |= cpu_to_le32(pattrib->mac_id & 0x3f);\r\nqsel = (uint)(pattrib->qsel&0x0000001f);\r\nptxdesc->txdw1 |= cpu_to_le32((qsel << QSEL_SHT) & 0x00001f00);\r\nptxdesc->txdw1 |= cpu_to_le32((pattrib->raid << RATE_ID_SHT) & 0x000f0000);\r\nif (pxmitframe->ack_report)\r\nptxdesc->txdw2 |= cpu_to_le32(BIT(19));\r\nptxdesc->txdw3 |= cpu_to_le32((pattrib->seqnum<<SEQ_SHT)&0x0FFF0000);\r\nptxdesc->txdw5 |= cpu_to_le32(RTY_LMT_EN);\r\nif (pattrib->retry_ctrl)\r\nptxdesc->txdw5 |= cpu_to_le32(0x00180000);\r\nelse\r\nptxdesc->txdw5 |= cpu_to_le32(0x00300000);\r\nptxdesc->txdw5 |= cpu_to_le32(MRateToHwRate(pmlmeext->tx_rate));\r\n} else if ((pxmitframe->frame_tag&0x0f) == TXAGG_FRAMETAG) {\r\nDBG_88E("pxmitframe->frame_tag == TXAGG_FRAMETAG\n");\r\n} else {\r\nDBG_88E("pxmitframe->frame_tag = %d\n", pxmitframe->frame_tag);\r\nptxdesc->txdw1 |= cpu_to_le32((4) & 0x3f);\r\nptxdesc->txdw1 |= cpu_to_le32((6 << RATE_ID_SHT) & 0x000f0000);\r\nptxdesc->txdw3 |= cpu_to_le32((pattrib->seqnum<<SEQ_SHT)&0x0fff0000);\r\nptxdesc->txdw5 |= cpu_to_le32(MRateToHwRate(pmlmeext->tx_rate));\r\n}\r\nif (!pattrib->qos_en) {\r\nptxdesc->txdw3 |= cpu_to_le32(EN_HWSEQ);\r\nptxdesc->txdw4 |= cpu_to_le32(HW_SSN);\r\n}\r\nrtl88eu_dm_set_tx_ant_by_tx_info(odmpriv, pmem, pattrib->mac_id);\r\nrtl8188eu_cal_txdesc_chksum(ptxdesc);\r\n_dbg_dump_tx_info(adapt, pxmitframe->frame_tag, ptxdesc);\r\nreturn pull;\r\n}\r\nstatic s32 rtw_dump_xframe(struct adapter *adapt, struct xmit_frame *pxmitframe)\r\n{\r\ns32 ret = _SUCCESS;\r\ns32 inner_ret = _SUCCESS;\r\nint t, sz, w_sz, pull = 0;\r\nu8 *mem_addr;\r\nu32 ff_hwaddr;\r\nstruct xmit_buf *pxmitbuf = pxmitframe->pxmitbuf;\r\nstruct pkt_attrib *pattrib = &pxmitframe->attrib;\r\nstruct xmit_priv *pxmitpriv = &adapt->xmitpriv;\r\nif ((pxmitframe->frame_tag == DATA_FRAMETAG) &&\r\n(pxmitframe->attrib.ether_type != 0x0806) &&\r\n(pxmitframe->attrib.ether_type != 0x888e) &&\r\n(pxmitframe->attrib.ether_type != 0x88b4) &&\r\n(pxmitframe->attrib.dhcp_pkt != 1))\r\nrtw_issue_addbareq_cmd(adapt, pxmitframe);\r\nmem_addr = pxmitframe->buf_addr;\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_info_, ("rtw_dump_xframe()\n"));\r\nfor (t = 0; t < pattrib->nr_frags; t++) {\r\nif (inner_ret != _SUCCESS && ret == _SUCCESS)\r\nret = _FAIL;\r\nif (t != (pattrib->nr_frags - 1)) {\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("pattrib->nr_frags=%d\n", pattrib->nr_frags));\r\nsz = pxmitpriv->frag_len;\r\nsz = sz - 4 - pattrib->icv_len;\r\n} else {\r\nsz = pattrib->last_txcmdsz;\r\n}\r\npull = update_txdesc(pxmitframe, mem_addr, sz, false);\r\nif (pull) {\r\nmem_addr += PACKET_OFFSET_SZ;\r\npxmitframe->buf_addr = mem_addr;\r\nw_sz = sz + TXDESC_SIZE;\r\n} else {\r\nw_sz = sz + TXDESC_SIZE + PACKET_OFFSET_SZ;\r\n}\r\nff_hwaddr = rtw_get_ff_hwaddr(pxmitframe);\r\ninner_ret = usb_write_port(adapt, ff_hwaddr, w_sz, pxmitbuf);\r\nrtw_count_tx_stats(adapt, pxmitframe, sz);\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_info_, ("rtw_write_port, w_sz=%d\n", w_sz));\r\nmem_addr += w_sz;\r\nmem_addr = (u8 *)round_up((size_t)mem_addr, 4);\r\n}\r\nrtw_free_xmitframe(pxmitpriv, pxmitframe);\r\nif (ret != _SUCCESS)\r\nrtw_sctx_done_err(&pxmitbuf->sctx, RTW_SCTX_DONE_UNKNOWN);\r\nreturn ret;\r\n}\r\nstatic u32 xmitframe_need_length(struct xmit_frame *pxmitframe)\r\n{\r\nstruct pkt_attrib *pattrib = &pxmitframe->attrib;\r\nu32 len;\r\nlen = pattrib->hdrlen + pattrib->iv_len +\r\nSNAP_SIZE + sizeof(u16) +\r\npattrib->pktlen +\r\n((pattrib->bswenc) ? pattrib->icv_len : 0);\r\nif (pattrib->encrypt == _TKIP_)\r\nlen += 8;\r\nreturn len;\r\n}\r\ns32 rtl8188eu_xmitframe_complete(struct adapter *adapt, struct xmit_priv *pxmitpriv)\r\n{\r\nstruct xmit_frame *pxmitframe = NULL;\r\nstruct xmit_frame *pfirstframe = NULL;\r\nstruct xmit_buf *pxmitbuf;\r\nstruct hw_xmit *phwxmit;\r\nstruct sta_info *psta = NULL;\r\nstruct tx_servq *ptxservq = NULL;\r\nstruct list_head *xmitframe_plist = NULL, *xmitframe_phead = NULL;\r\nu32 pbuf;\r\nu32 pbuf_tail;\r\nu32 len;\r\nu32 bulksize = adapt->HalData->UsbBulkOutSize;\r\nu8 desc_cnt;\r\nu32 bulkptr;\r\nu32 ff_hwaddr;\r\nRT_TRACE(_module_rtl8192c_xmit_c_, _drv_info_, ("+xmitframe_complete\n"));\r\npxmitbuf = rtw_alloc_xmitbuf(pxmitpriv);\r\nif (pxmitbuf == NULL)\r\nreturn false;\r\nrtw_free_xmitframe(pxmitpriv, pxmitframe);\r\npxmitframe = rtw_dequeue_xframe(pxmitpriv, pxmitpriv->hwxmits, pxmitpriv->hwxmit_entry);\r\nif (pxmitframe == NULL) {\r\nrtw_free_xmitbuf(pxmitpriv, pxmitbuf);\r\nreturn false;\r\n}\r\npxmitframe->pxmitbuf = pxmitbuf;\r\npxmitframe->buf_addr = pxmitbuf->pbuf;\r\npxmitbuf->priv_data = pxmitframe;\r\npxmitframe->agg_num = 1;\r\npxmitframe->pkt_offset = 1;\r\nrtw_xmitframe_coalesce(adapt, pxmitframe->pkt, pxmitframe);\r\nrtw_os_xmit_complete(adapt, pxmitframe);\r\npfirstframe = pxmitframe;\r\nlen = xmitframe_need_length(pfirstframe) + TXDESC_SIZE + (pfirstframe->pkt_offset*PACKET_OFFSET_SZ);\r\npbuf_tail = len;\r\npbuf = round_up(pbuf_tail, 8);\r\ndesc_cnt = 0;\r\nbulkptr = bulksize;\r\nif (pbuf < bulkptr) {\r\ndesc_cnt++;\r\n} else {\r\ndesc_cnt = 0;\r\nbulkptr = ((pbuf / bulksize) + 1) * bulksize;\r\n}\r\npsta = pfirstframe->attrib.psta;\r\nswitch (pfirstframe->attrib.priority) {\r\ncase 1:\r\ncase 2:\r\nptxservq = &(psta->sta_xmitpriv.bk_q);\r\nphwxmit = pxmitpriv->hwxmits + 3;\r\nbreak;\r\ncase 4:\r\ncase 5:\r\nptxservq = &(psta->sta_xmitpriv.vi_q);\r\nphwxmit = pxmitpriv->hwxmits + 1;\r\nbreak;\r\ncase 6:\r\ncase 7:\r\nptxservq = &(psta->sta_xmitpriv.vo_q);\r\nphwxmit = pxmitpriv->hwxmits;\r\nbreak;\r\ncase 0:\r\ncase 3:\r\ndefault:\r\nptxservq = &(psta->sta_xmitpriv.be_q);\r\nphwxmit = pxmitpriv->hwxmits + 2;\r\nbreak;\r\n}\r\nspin_lock_bh(&pxmitpriv->lock);\r\nxmitframe_phead = get_list_head(&ptxservq->sta_pending);\r\nxmitframe_plist = xmitframe_phead->next;\r\nwhile (xmitframe_phead != xmitframe_plist) {\r\npxmitframe = container_of(xmitframe_plist, struct xmit_frame, list);\r\nxmitframe_plist = xmitframe_plist->next;\r\npxmitframe->agg_num = 0;\r\npxmitframe->pkt_offset = 0;\r\nlen = xmitframe_need_length(pxmitframe) + TXDESC_SIZE + (pxmitframe->pkt_offset*PACKET_OFFSET_SZ);\r\nif (round_up(pbuf + len, 8) > MAX_XMITBUF_SZ) {\r\npxmitframe->agg_num = 1;\r\npxmitframe->pkt_offset = 1;\r\nbreak;\r\n}\r\nlist_del_init(&pxmitframe->list);\r\nptxservq->qcnt--;\r\nphwxmit->accnt--;\r\npxmitframe->buf_addr = pxmitbuf->pbuf + pbuf;\r\nrtw_xmitframe_coalesce(adapt, pxmitframe->pkt, pxmitframe);\r\nrtw_os_xmit_complete(adapt, pxmitframe);\r\nupdate_txdesc(pxmitframe, pxmitframe->buf_addr, pxmitframe->attrib.last_txcmdsz, true);\r\nrtw_free_xmitframe(pxmitpriv, pxmitframe);\r\npbuf_tail = pbuf + len;\r\npbuf = round_up(pbuf_tail, 8);\r\npfirstframe->agg_num++;\r\nif (MAX_TX_AGG_PACKET_NUMBER == pfirstframe->agg_num)\r\nbreak;\r\nif (pbuf < bulkptr) {\r\ndesc_cnt++;\r\nif (desc_cnt == adapt->HalData->UsbTxAggDescNum)\r\nbreak;\r\n} else {\r\ndesc_cnt = 0;\r\nbulkptr = ((pbuf / bulksize) + 1) * bulksize;\r\n}\r\n}\r\nif (list_empty(&ptxservq->sta_pending.queue))\r\nlist_del_init(&ptxservq->tx_pending);\r\nspin_unlock_bh(&pxmitpriv->lock);\r\nif ((pfirstframe->attrib.ether_type != 0x0806) &&\r\n(pfirstframe->attrib.ether_type != 0x888e) &&\r\n(pfirstframe->attrib.ether_type != 0x88b4) &&\r\n(pfirstframe->attrib.dhcp_pkt != 1))\r\nrtw_issue_addbareq_cmd(adapt, pfirstframe);\r\nif ((pbuf_tail % bulksize) == 0) {\r\npbuf_tail -= PACKET_OFFSET_SZ;\r\npfirstframe->buf_addr += PACKET_OFFSET_SZ;\r\npfirstframe->pkt_offset--;\r\n}\r\nupdate_txdesc(pfirstframe, pfirstframe->buf_addr, pfirstframe->attrib.last_txcmdsz, true);\r\nff_hwaddr = rtw_get_ff_hwaddr(pfirstframe);\r\nusb_write_port(adapt, ff_hwaddr, pbuf_tail, pxmitbuf);\r\npbuf_tail -= (pfirstframe->agg_num * TXDESC_SIZE);\r\npbuf_tail -= (pfirstframe->pkt_offset * PACKET_OFFSET_SZ);\r\nrtw_count_tx_stats(adapt, pfirstframe, pbuf_tail);\r\nrtw_free_xmitframe(pxmitpriv, pfirstframe);\r\nreturn true;\r\n}\r\ns32 rtw_hal_xmit(struct adapter *adapt, struct xmit_frame *pxmitframe)\r\n{\r\ns32 res;\r\nstruct xmit_buf *pxmitbuf = NULL;\r\nstruct xmit_priv *pxmitpriv = &adapt->xmitpriv;\r\nstruct pkt_attrib *pattrib = &pxmitframe->attrib;\r\nstruct mlme_priv *pmlmepriv = &adapt->mlmepriv;\r\nspin_lock_bh(&pxmitpriv->lock);\r\nif (rtw_txframes_sta_ac_pending(adapt, pattrib) > 0)\r\ngoto enqueue;\r\nif (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == true)\r\ngoto enqueue;\r\npxmitbuf = rtw_alloc_xmitbuf(pxmitpriv);\r\nif (!pxmitbuf)\r\ngoto enqueue;\r\nspin_unlock_bh(&pxmitpriv->lock);\r\npxmitframe->pxmitbuf = pxmitbuf;\r\npxmitframe->buf_addr = pxmitbuf->pbuf;\r\npxmitbuf->priv_data = pxmitframe;\r\nres = rtw_xmitframe_coalesce(adapt, pxmitframe->pkt, pxmitframe);\r\nif (res == _SUCCESS) {\r\nrtw_dump_xframe(adapt, pxmitframe);\r\n} else {\r\nDBG_88E("==> %s xmitframe_coalesce failed\n", __func__);\r\nrtw_free_xmitbuf(pxmitpriv, pxmitbuf);\r\nrtw_free_xmitframe(pxmitpriv, pxmitframe);\r\n}\r\nreturn true;\r\nenqueue:\r\nres = rtw_xmitframe_enqueue(adapt, pxmitframe);\r\nspin_unlock_bh(&pxmitpriv->lock);\r\nif (res != _SUCCESS) {\r\nRT_TRACE(_module_xmit_osdep_c_, _drv_err_, ("pre_xmitframe: enqueue xmitframe fail\n"));\r\nrtw_free_xmitframe(pxmitpriv, pxmitframe);\r\npxmitpriv->tx_pkts--;\r\npxmitpriv->tx_drop++;\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\ns32 rtw_hal_mgnt_xmit(struct adapter *adapt, struct xmit_frame *pmgntframe)\r\n{\r\nstruct xmit_priv *xmitpriv = &adapt->xmitpriv;\r\nrtl88eu_mon_xmit_hook(adapt->pmondev, pmgntframe, xmitpriv->frag_len);\r\nreturn rtw_dump_xframe(adapt, pmgntframe);\r\n}
