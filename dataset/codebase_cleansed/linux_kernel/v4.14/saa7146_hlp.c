static void calculate_output_format_register(struct saa7146_dev* saa, u32 palette, u32* clip_format)\r\n{\r\n*clip_format &= 0x0000ffff;\r\n*clip_format |= (( ((palette&0xf00)>>8) << 30) | ((palette&0x00f) << 24) | (((palette&0x0f0)>>4) << 16));\r\n}\r\nstatic void calculate_hps_source_and_sync(struct saa7146_dev *dev, int source, int sync, u32* hps_ctrl)\r\n{\r\n*hps_ctrl &= ~(MASK_30 | MASK_31 | MASK_28);\r\n*hps_ctrl |= (source << 30) | (sync << 28);\r\n}\r\nstatic void calculate_hxo_and_hyo(struct saa7146_vv *vv, u32* hps_h_scale, u32* hps_ctrl)\r\n{\r\nint hyo = 0, hxo = 0;\r\nhyo = vv->standard->v_offset;\r\nhxo = vv->standard->h_offset;\r\n*hps_h_scale &= ~(MASK_B0 | 0xf00);\r\n*hps_h_scale |= (hxo << 0);\r\n*hps_ctrl &= ~(MASK_W0 | MASK_B2);\r\n*hps_ctrl |= (hyo << 12);\r\n}\r\nstatic int calculate_h_scale_registers(struct saa7146_dev *dev,\r\nint in_x, int out_x, int flip_lr,\r\nu32* hps_ctrl, u32* hps_v_gain, u32* hps_h_prescale, u32* hps_h_scale)\r\n{\r\nu32 dcgx = 0, xpsc = 0, xacm = 0, cxy = 0, cxuv = 0;\r\nu32 xim = 0, xp = 0, xsci =0;\r\nu32 pfuv = 0;\r\nu32 h_atten = 0, i = 0;\r\nif ( 0 == out_x ) {\r\nreturn -EINVAL;\r\n}\r\n*hps_ctrl &= ~MASK_29;\r\nif (in_x > out_x) {\r\nxpsc = in_x / out_x;\r\n}\r\nelse {\r\nxpsc = 1;\r\n}\r\nif ( 0 != flip_lr ) {\r\n*hps_ctrl |= MASK_29;\r\nwhile (in_x / xpsc >= 384 )\r\nxpsc++;\r\n}\r\nelse {\r\nwhile ( in_x / xpsc >= 768 )\r\nxpsc++;\r\n}\r\nif ( xpsc > 64 )\r\nxpsc = 64;\r\nxacm = 0;\r\ncxy = hps_h_coeff_tab[( (xpsc - 1) < 63 ? (xpsc - 1) : 63 )].hps_coeff;\r\ncxuv = cxy;\r\nif ( (in_x == out_x) && ( 1 == xpsc ) )\r\nxsci = 0x400;\r\nelse\r\nxsci = ( (1024 * in_x) / (out_x * xpsc) ) + xpsc;\r\nxp = 0;\r\nif ( 0x400 == xsci )\r\nxim = 1;\r\nelse\r\nxim = 0;\r\nif( 1 == xpsc ) {\r\nxacm = 1;\r\ndcgx = 0;\r\n} else {\r\nxacm = 0;\r\nh_atten = hps_h_coeff_tab[( (xpsc - 1) < 63 ? (xpsc - 1) : 63 )].weight_sum;\r\nfor (i = 0; h_attenuation[i] != 0; i++) {\r\nif (h_attenuation[i] >= h_atten)\r\nbreak;\r\n}\r\ndcgx = i;\r\n}\r\nif ( xsci == 0x400)\r\npfuv = 0x00;\r\nelse if ( xsci < 0x600)\r\npfuv = 0x01;\r\nelse if ( xsci < 0x680)\r\npfuv = 0x11;\r\nelse if ( xsci < 0x700)\r\npfuv = 0x22;\r\nelse\r\npfuv = 0x33;\r\n*hps_v_gain &= MASK_W0|MASK_B2;\r\n*hps_v_gain |= (pfuv << 24);\r\n*hps_h_scale &= ~(MASK_W1 | 0xf000);\r\n*hps_h_scale |= (xim << 31) | (xp << 24) | (xsci << 12);\r\n*hps_h_prescale |= (dcgx << 27) | ((xpsc-1) << 18) | (xacm << 17) | (cxy << 8) | (cxuv << 0);\r\nreturn 0;\r\n}\r\nstatic int calculate_v_scale_registers(struct saa7146_dev *dev, enum v4l2_field field,\r\nint in_y, int out_y, u32* hps_v_scale, u32* hps_v_gain)\r\n{\r\nint lpi = 0;\r\nu32 yacm = 0, ysci = 0, yacl = 0, ypo = 0, ype = 0;\r\nu32 dcgy = 0, cya_cyb = 0;\r\nu32 v_atten = 0, i = 0;\r\nif ( in_y < out_y ) {\r\nreturn -EINVAL;\r\n}\r\nif (V4L2_FIELD_HAS_BOTH(field)) {\r\nif( 2*out_y >= in_y) {\r\nlpi = 1;\r\n}\r\n} else if (field == V4L2_FIELD_TOP\r\n|| field == V4L2_FIELD_ALTERNATE\r\n|| field == V4L2_FIELD_BOTTOM) {\r\nif( 4*out_y >= in_y ) {\r\nlpi = 1;\r\n}\r\nout_y *= 2;\r\n}\r\nif( 0 != lpi ) {\r\nyacm = 0;\r\nyacl = 0;\r\ncya_cyb = 0x00ff;\r\nif ( in_y > out_y )\r\nysci = ((1024 * in_y) / (out_y + 1)) - 1024;\r\nelse\r\nysci = 0;\r\ndcgy = 0;\r\nype = ysci / 16;\r\nypo = ype + (ysci / 64);\r\n} else {\r\nyacm = 1;\r\nysci = (((10 * 1024 * (in_y - out_y - 1)) / in_y) + 9) / 10;\r\nypo = ype = ((ysci + 15) / 16);\r\nif ( ysci < 512) {\r\nyacl = 0;\r\n} else {\r\nyacl = ( ysci / (1024 - ysci) );\r\n}\r\ncya_cyb = hps_v_coeff_tab[ (yacl < 63 ? yacl : 63 ) ].hps_coeff;\r\nv_atten = hps_v_coeff_tab[ (yacl < 63 ? yacl : 63 ) ].weight_sum;\r\nfor (i = 0; v_attenuation[i] != 0; i++) {\r\nif (v_attenuation[i] >= v_atten)\r\nbreak;\r\n}\r\ndcgy = i;\r\n}\r\n*hps_v_scale |= (yacm << 31) | (ysci << 21) | (yacl << 15) | (ypo << 8 ) | (ype << 1);\r\n*hps_v_gain &= ~(MASK_W0|MASK_B2);\r\n*hps_v_gain |= (dcgy << 16) | (cya_cyb << 0);\r\nreturn 0;\r\n}\r\nstatic int sort_and_eliminate(u32* values, int* count)\r\n{\r\nint low = 0, high = 0, top = 0;\r\nint cur = 0, next = 0;\r\nif( (0 > *count) || (NULL == values) ) {\r\nreturn -EINVAL;\r\n}\r\nfor( top = *count; top > 0; top--) {\r\nfor( low = 0, high = 1; high < top; low++, high++) {\r\nif( values[low] > values[high] )\r\nswap(values[low], values[high]);\r\n}\r\n}\r\nfor( cur = 0, next = 1; next < *count; next++) {\r\nif( values[cur] != values[next])\r\nvalues[++cur] = values[next];\r\n}\r\n*count = cur + 1;\r\nreturn 0;\r\n}\r\nstatic void calculate_clipping_registers_rect(struct saa7146_dev *dev, struct saa7146_fh *fh,\r\nstruct saa7146_video_dma *vdma2, u32* clip_format, u32* arbtr_ctrl, enum v4l2_field field)\r\n{\r\nstruct saa7146_vv *vv = dev->vv_data;\r\n__le32 *clipping = vv->d_clipping.cpu_addr;\r\nint width = vv->ov.win.w.width;\r\nint height = vv->ov.win.w.height;\r\nint clipcount = vv->ov.nclips;\r\nu32 line_list[32];\r\nu32 pixel_list[32];\r\nint numdwords = 0;\r\nint i = 0, j = 0;\r\nint cnt_line = 0, cnt_pixel = 0;\r\nint x[32], y[32], w[32], h[32];\r\nmemset(&line_list[0], 0x00, sizeof(u32)*32);\r\nmemset(&pixel_list[0], 0x00, sizeof(u32)*32);\r\nmemset(clipping, 0x00, SAA7146_CLIPPING_MEM);\r\nfor(i = 0; i < clipcount; i++) {\r\nint l = 0, r = 0, t = 0, b = 0;\r\nx[i] = vv->ov.clips[i].c.left;\r\ny[i] = vv->ov.clips[i].c.top;\r\nw[i] = vv->ov.clips[i].c.width;\r\nh[i] = vv->ov.clips[i].c.height;\r\nif( w[i] < 0) {\r\nx[i] += w[i]; w[i] = -w[i];\r\n}\r\nif( h[i] < 0) {\r\ny[i] += h[i]; h[i] = -h[i];\r\n}\r\nif( x[i] < 0) {\r\nw[i] += x[i]; x[i] = 0;\r\n}\r\nif( y[i] < 0) {\r\nh[i] += y[i]; y[i] = 0;\r\n}\r\nif( 0 != vv->vflip ) {\r\ny[i] = height - y[i] - h[i];\r\n}\r\nl = x[i];\r\nr = x[i]+w[i];\r\nt = y[i];\r\nb = y[i]+h[i];\r\npixel_list[ 2*i ] = min_t(int, l, width);\r\npixel_list[(2*i)+1] = min_t(int, r, width);\r\nline_list[ 2*i ] = min_t(int, t, height);\r\nline_list[(2*i)+1] = min_t(int, b, height);\r\n}\r\ncnt_line = cnt_pixel = 2*clipcount;\r\nsort_and_eliminate( &pixel_list[0], &cnt_pixel );\r\nsort_and_eliminate( &line_list[0], &cnt_line );\r\nnumdwords = max_t(int, (cnt_line+1), (cnt_pixel+1))*2;\r\nnumdwords = max_t(int, 4, numdwords);\r\nnumdwords = min_t(int, 64, numdwords);\r\nfor(i = 0; i < cnt_pixel; i++) {\r\nclipping[2*i] |= cpu_to_le32(pixel_list[i] << 16);\r\n}\r\nfor(i = 0; i < cnt_line; i++) {\r\nclipping[(2*i)+1] |= cpu_to_le32(line_list[i] << 16);\r\n}\r\nfor(j = 0; j < clipcount; j++) {\r\nfor(i = 0; i < cnt_pixel; i++) {\r\nif( x[j] < 0)\r\nx[j] = 0;\r\nif( pixel_list[i] < (x[j] + w[j])) {\r\nif ( pixel_list[i] >= x[j] ) {\r\nclipping[2*i] |= cpu_to_le32(1 << j);\r\n}\r\n}\r\n}\r\nfor(i = 0; i < cnt_line; i++) {\r\nif( y[j] < 0)\r\ny[j] = 0;\r\nif( line_list[i] < (y[j] + h[j]) ) {\r\nif( line_list[i] >= y[j] ) {\r\nclipping[(2*i)+1] |= cpu_to_le32(1 << j);\r\n}\r\n}\r\n}\r\n}\r\n*arbtr_ctrl &= 0xffff00ff;\r\n*arbtr_ctrl |= 0x00001c00;\r\nvdma2->base_even = vv->d_clipping.dma_handle;\r\nvdma2->base_odd = vv->d_clipping.dma_handle;\r\nvdma2->prot_addr = vv->d_clipping.dma_handle+((sizeof(u32))*(numdwords));\r\nvdma2->base_page = 0x04;\r\nvdma2->pitch = 0x00;\r\nvdma2->num_line_byte = (0 << 16 | (sizeof(u32))*(numdwords-1) );\r\n*clip_format &= 0xfffffff7;\r\nif (V4L2_FIELD_HAS_BOTH(field)) {\r\n*clip_format |= 0x00000008;\r\n} else {\r\n*clip_format |= 0x00000000;\r\n}\r\n}\r\nstatic void saa7146_disable_clipping(struct saa7146_dev *dev)\r\n{\r\nu32 clip_format = saa7146_read(dev, CLIP_FORMAT_CTRL);\r\nclip_format &= MASK_W1;\r\nsaa7146_write(dev, CLIP_FORMAT_CTRL,clip_format);\r\nsaa7146_write(dev, MC2, (MASK_05 | MASK_21));\r\nsaa7146_write(dev, MC1, MASK_21);\r\n}\r\nstatic void saa7146_set_clipping_rect(struct saa7146_fh *fh)\r\n{\r\nstruct saa7146_dev *dev = fh->dev;\r\nstruct saa7146_vv *vv = dev->vv_data;\r\nenum v4l2_field field = vv->ov.win.field;\r\nstruct saa7146_video_dma vdma2;\r\nu32 clip_format;\r\nu32 arbtr_ctrl;\r\nif (vv->ov.nclips == 0) {\r\nsaa7146_disable_clipping(dev);\r\nreturn;\r\n}\r\nclip_format = saa7146_read(dev, CLIP_FORMAT_CTRL);\r\narbtr_ctrl = saa7146_read(dev, PCI_BT_V1);\r\ncalculate_clipping_registers_rect(dev, fh, &vdma2, &clip_format, &arbtr_ctrl, field);\r\nclip_format &= 0xffff0008;\r\nclip_format |= (SAA7146_CLIPPING_RECT << 4);\r\nsaa7146_write(dev, BASE_EVEN2, vdma2.base_even);\r\nsaa7146_write(dev, BASE_ODD2, vdma2.base_odd);\r\nsaa7146_write(dev, PROT_ADDR2, vdma2.prot_addr);\r\nsaa7146_write(dev, BASE_PAGE2, vdma2.base_page);\r\nsaa7146_write(dev, PITCH2, vdma2.pitch);\r\nsaa7146_write(dev, NUM_LINE_BYTE2, vdma2.num_line_byte);\r\nsaa7146_write(dev, CLIP_FORMAT_CTRL,clip_format);\r\nsaa7146_write(dev, PCI_BT_V1, arbtr_ctrl);\r\nsaa7146_write(dev, MC2, (MASK_05 | MASK_21 | MASK_03 | MASK_19));\r\nsaa7146_write(dev, MC1, (MASK_05 | MASK_21));\r\n}\r\nstatic void saa7146_set_window(struct saa7146_dev *dev, int width, int height, enum v4l2_field field)\r\n{\r\nstruct saa7146_vv *vv = dev->vv_data;\r\nint source = vv->current_hps_source;\r\nint sync = vv->current_hps_sync;\r\nu32 hps_v_scale = 0, hps_v_gain = 0, hps_ctrl = 0, hps_h_prescale = 0, hps_h_scale = 0;\r\nhps_v_scale = 0;\r\nhps_v_gain = 0;\r\ncalculate_v_scale_registers(dev, field, vv->standard->v_field*2, height, &hps_v_scale, &hps_v_gain);\r\nhps_ctrl = 0;\r\nhps_h_prescale = 0;\r\nhps_h_scale = 0;\r\ncalculate_h_scale_registers(dev, vv->standard->h_pixels, width, vv->hflip, &hps_ctrl, &hps_v_gain, &hps_h_prescale, &hps_h_scale);\r\ncalculate_hxo_and_hyo(vv, &hps_h_scale, &hps_ctrl);\r\ncalculate_hps_source_and_sync(dev, source, sync, &hps_ctrl);\r\nsaa7146_write(dev, HPS_V_SCALE, hps_v_scale);\r\nsaa7146_write(dev, HPS_V_GAIN, hps_v_gain);\r\nsaa7146_write(dev, HPS_CTRL, hps_ctrl);\r\nsaa7146_write(dev, HPS_H_PRESCALE,hps_h_prescale);\r\nsaa7146_write(dev, HPS_H_SCALE, hps_h_scale);\r\nsaa7146_write(dev, MC2, (MASK_05 | MASK_06 | MASK_21 | MASK_22) );\r\n}\r\nstatic void saa7146_set_position(struct saa7146_dev *dev, int w_x, int w_y, int w_height, enum v4l2_field field, u32 pixelformat)\r\n{\r\nstruct saa7146_vv *vv = dev->vv_data;\r\nstruct saa7146_format *sfmt = saa7146_format_by_fourcc(dev, pixelformat);\r\nint b_depth = vv->ov_fmt->depth;\r\nint b_bpl = vv->ov_fb.fmt.bytesperline;\r\nu32 base = (u32)(unsigned long)vv->ov_fb.base;\r\nstruct saa7146_video_dma vdma1;\r\nvdma1.pitch = 2*b_bpl;\r\nif ( 0 == vv->vflip ) {\r\nvdma1.base_even = base + (w_y * (vdma1.pitch/2)) + (w_x * (b_depth / 8));\r\nvdma1.base_odd = vdma1.base_even + (vdma1.pitch / 2);\r\nvdma1.prot_addr = vdma1.base_even + (w_height * (vdma1.pitch / 2));\r\n}\r\nelse {\r\nvdma1.base_even = base + ((w_y+w_height) * (vdma1.pitch/2)) + (w_x * (b_depth / 8));\r\nvdma1.base_odd = vdma1.base_even - (vdma1.pitch / 2);\r\nvdma1.prot_addr = vdma1.base_odd - (w_height * (vdma1.pitch / 2));\r\n}\r\nif (V4L2_FIELD_HAS_BOTH(field)) {\r\n} else if (field == V4L2_FIELD_ALTERNATE) {\r\nvdma1.base_odd = vdma1.prot_addr;\r\nvdma1.pitch /= 2;\r\n} else if (field == V4L2_FIELD_TOP) {\r\nvdma1.base_odd = vdma1.prot_addr;\r\nvdma1.pitch /= 2;\r\n} else if (field == V4L2_FIELD_BOTTOM) {\r\nvdma1.base_odd = vdma1.base_even;\r\nvdma1.base_even = vdma1.prot_addr;\r\nvdma1.pitch /= 2;\r\n}\r\nif ( 0 != vv->vflip ) {\r\nvdma1.pitch *= -1;\r\n}\r\nvdma1.base_page = sfmt->swap;\r\nvdma1.num_line_byte = (vv->standard->v_field<<16)+vv->standard->h_pixels;\r\nsaa7146_write_out_dma(dev, 1, &vdma1);\r\n}\r\nstatic void saa7146_set_output_format(struct saa7146_dev *dev, unsigned long palette)\r\n{\r\nu32 clip_format = saa7146_read(dev, CLIP_FORMAT_CTRL);\r\ncalculate_output_format_register(dev,palette,&clip_format);\r\nsaa7146_write(dev, CLIP_FORMAT_CTRL, clip_format);\r\nsaa7146_write(dev, MC2, (MASK_05 | MASK_21));\r\n}\r\nvoid saa7146_set_hps_source_and_sync(struct saa7146_dev *dev, int source, int sync)\r\n{\r\nstruct saa7146_vv *vv = dev->vv_data;\r\nu32 hps_ctrl = 0;\r\nhps_ctrl = saa7146_read(dev, HPS_CTRL);\r\nhps_ctrl &= ~( MASK_31 | MASK_30 | MASK_28 );\r\nhps_ctrl |= (source << 30) | (sync << 28);\r\nsaa7146_write(dev, HPS_CTRL, hps_ctrl);\r\nsaa7146_write(dev, MC2, (MASK_05 | MASK_21));\r\nvv->current_hps_source = source;\r\nvv->current_hps_sync = sync;\r\n}\r\nint saa7146_enable_overlay(struct saa7146_fh *fh)\r\n{\r\nstruct saa7146_dev *dev = fh->dev;\r\nstruct saa7146_vv *vv = dev->vv_data;\r\nsaa7146_set_window(dev, vv->ov.win.w.width, vv->ov.win.w.height, vv->ov.win.field);\r\nsaa7146_set_position(dev, vv->ov.win.w.left, vv->ov.win.w.top, vv->ov.win.w.height, vv->ov.win.field, vv->ov_fmt->pixelformat);\r\nsaa7146_set_output_format(dev, vv->ov_fmt->trans);\r\nsaa7146_set_clipping_rect(fh);\r\nsaa7146_write(dev, MC1, (MASK_06 | MASK_22));\r\nreturn 0;\r\n}\r\nvoid saa7146_disable_overlay(struct saa7146_fh *fh)\r\n{\r\nstruct saa7146_dev *dev = fh->dev;\r\nsaa7146_disable_clipping(dev);\r\nsaa7146_write(dev, MC1, MASK_22);\r\n}\r\nvoid saa7146_write_out_dma(struct saa7146_dev* dev, int which, struct saa7146_video_dma* vdma)\r\n{\r\nint where = 0;\r\nif( which < 1 || which > 3) {\r\nreturn;\r\n}\r\nwhere = (which-1)*0x18;\r\nsaa7146_write(dev, where, vdma->base_odd);\r\nsaa7146_write(dev, where+0x04, vdma->base_even);\r\nsaa7146_write(dev, where+0x08, vdma->prot_addr);\r\nsaa7146_write(dev, where+0x0c, vdma->pitch);\r\nsaa7146_write(dev, where+0x10, vdma->base_page);\r\nsaa7146_write(dev, where+0x14, vdma->num_line_byte);\r\nsaa7146_write(dev, MC2, (MASK_02<<(which-1))|(MASK_18<<(which-1)));\r\n}\r\nstatic int calculate_video_dma_grab_packed(struct saa7146_dev* dev, struct saa7146_buf *buf)\r\n{\r\nstruct saa7146_vv *vv = dev->vv_data;\r\nstruct saa7146_video_dma vdma1;\r\nstruct saa7146_format *sfmt = saa7146_format_by_fourcc(dev,buf->fmt->pixelformat);\r\nint width = buf->fmt->width;\r\nint height = buf->fmt->height;\r\nint bytesperline = buf->fmt->bytesperline;\r\nenum v4l2_field field = buf->fmt->field;\r\nint depth = sfmt->depth;\r\nDEB_CAP("[size=%dx%d,fields=%s]\n",\r\nwidth, height, v4l2_field_names[field]);\r\nif( bytesperline != 0) {\r\nvdma1.pitch = bytesperline*2;\r\n} else {\r\nvdma1.pitch = (width*depth*2)/8;\r\n}\r\nvdma1.num_line_byte = ((vv->standard->v_field<<16) + vv->standard->h_pixels);\r\nvdma1.base_page = buf->pt[0].dma | ME1 | sfmt->swap;\r\nif( 0 != vv->vflip ) {\r\nvdma1.prot_addr = buf->pt[0].offset;\r\nvdma1.base_even = buf->pt[0].offset+(vdma1.pitch/2)*height;\r\nvdma1.base_odd = vdma1.base_even - (vdma1.pitch/2);\r\n} else {\r\nvdma1.base_even = buf->pt[0].offset;\r\nvdma1.base_odd = vdma1.base_even + (vdma1.pitch/2);\r\nvdma1.prot_addr = buf->pt[0].offset+(vdma1.pitch/2)*height;\r\n}\r\nif (V4L2_FIELD_HAS_BOTH(field)) {\r\n} else if (field == V4L2_FIELD_ALTERNATE) {\r\nif ( vv->last_field == V4L2_FIELD_TOP ) {\r\nvdma1.base_odd = vdma1.prot_addr;\r\nvdma1.pitch /= 2;\r\n} else if ( vv->last_field == V4L2_FIELD_BOTTOM ) {\r\nvdma1.base_odd = vdma1.base_even;\r\nvdma1.base_even = vdma1.prot_addr;\r\nvdma1.pitch /= 2;\r\n}\r\n} else if (field == V4L2_FIELD_TOP) {\r\nvdma1.base_odd = vdma1.prot_addr;\r\nvdma1.pitch /= 2;\r\n} else if (field == V4L2_FIELD_BOTTOM) {\r\nvdma1.base_odd = vdma1.base_even;\r\nvdma1.base_even = vdma1.prot_addr;\r\nvdma1.pitch /= 2;\r\n}\r\nif( 0 != vv->vflip ) {\r\nvdma1.pitch *= -1;\r\n}\r\nsaa7146_write_out_dma(dev, 1, &vdma1);\r\nreturn 0;\r\n}\r\nstatic int calc_planar_422(struct saa7146_vv *vv, struct saa7146_buf *buf, struct saa7146_video_dma *vdma2, struct saa7146_video_dma *vdma3)\r\n{\r\nint height = buf->fmt->height;\r\nint width = buf->fmt->width;\r\nvdma2->pitch = width;\r\nvdma3->pitch = width;\r\nif( 0 != vv->vflip ) {\r\nvdma2->prot_addr = buf->pt[1].offset;\r\nvdma2->base_even = ((vdma2->pitch/2)*height)+buf->pt[1].offset;\r\nvdma2->base_odd = vdma2->base_even - (vdma2->pitch/2);\r\nvdma3->prot_addr = buf->pt[2].offset;\r\nvdma3->base_even = ((vdma3->pitch/2)*height)+buf->pt[2].offset;\r\nvdma3->base_odd = vdma3->base_even - (vdma3->pitch/2);\r\n} else {\r\nvdma3->base_even = buf->pt[2].offset;\r\nvdma3->base_odd = vdma3->base_even + (vdma3->pitch/2);\r\nvdma3->prot_addr = (vdma3->pitch/2)*height+buf->pt[2].offset;\r\nvdma2->base_even = buf->pt[1].offset;\r\nvdma2->base_odd = vdma2->base_even + (vdma2->pitch/2);\r\nvdma2->prot_addr = (vdma2->pitch/2)*height+buf->pt[1].offset;\r\n}\r\nreturn 0;\r\n}\r\nstatic int calc_planar_420(struct saa7146_vv *vv, struct saa7146_buf *buf, struct saa7146_video_dma *vdma2, struct saa7146_video_dma *vdma3)\r\n{\r\nint height = buf->fmt->height;\r\nint width = buf->fmt->width;\r\nvdma2->pitch = width/2;\r\nvdma3->pitch = width/2;\r\nif( 0 != vv->vflip ) {\r\nvdma2->prot_addr = buf->pt[2].offset;\r\nvdma2->base_even = ((vdma2->pitch/2)*height)+buf->pt[2].offset;\r\nvdma2->base_odd = vdma2->base_even - (vdma2->pitch/2);\r\nvdma3->prot_addr = buf->pt[1].offset;\r\nvdma3->base_even = ((vdma3->pitch/2)*height)+buf->pt[1].offset;\r\nvdma3->base_odd = vdma3->base_even - (vdma3->pitch/2);\r\n} else {\r\nvdma3->base_even = buf->pt[2].offset;\r\nvdma3->base_odd = vdma3->base_even + (vdma3->pitch);\r\nvdma3->prot_addr = (vdma3->pitch/2)*height+buf->pt[2].offset;\r\nvdma2->base_even = buf->pt[1].offset;\r\nvdma2->base_odd = vdma2->base_even + (vdma2->pitch);\r\nvdma2->prot_addr = (vdma2->pitch/2)*height+buf->pt[1].offset;\r\n}\r\nreturn 0;\r\n}\r\nstatic int calculate_video_dma_grab_planar(struct saa7146_dev* dev, struct saa7146_buf *buf)\r\n{\r\nstruct saa7146_vv *vv = dev->vv_data;\r\nstruct saa7146_video_dma vdma1;\r\nstruct saa7146_video_dma vdma2;\r\nstruct saa7146_video_dma vdma3;\r\nstruct saa7146_format *sfmt = saa7146_format_by_fourcc(dev,buf->fmt->pixelformat);\r\nint width = buf->fmt->width;\r\nint height = buf->fmt->height;\r\nenum v4l2_field field = buf->fmt->field;\r\nBUG_ON(0 == buf->pt[0].dma);\r\nBUG_ON(0 == buf->pt[1].dma);\r\nBUG_ON(0 == buf->pt[2].dma);\r\nDEB_CAP("[size=%dx%d,fields=%s]\n",\r\nwidth, height, v4l2_field_names[field]);\r\nvdma1.pitch = width*2;\r\nvdma1.num_line_byte = ((vv->standard->v_field<<16) + vv->standard->h_pixels);\r\nvdma1.base_page = buf->pt[0].dma | ME1;\r\nif( 0 != vv->vflip ) {\r\nvdma1.prot_addr = buf->pt[0].offset;\r\nvdma1.base_even = ((vdma1.pitch/2)*height)+buf->pt[0].offset;\r\nvdma1.base_odd = vdma1.base_even - (vdma1.pitch/2);\r\n} else {\r\nvdma1.base_even = buf->pt[0].offset;\r\nvdma1.base_odd = vdma1.base_even + (vdma1.pitch/2);\r\nvdma1.prot_addr = (vdma1.pitch/2)*height+buf->pt[0].offset;\r\n}\r\nvdma2.num_line_byte = 0;\r\nvdma2.base_page = buf->pt[1].dma | ME1;\r\nvdma3.num_line_byte = 0;\r\nvdma3.base_page = buf->pt[2].dma | ME1;\r\nswitch( sfmt->depth ) {\r\ncase 12: {\r\ncalc_planar_420(vv,buf,&vdma2,&vdma3);\r\nbreak;\r\n}\r\ncase 16: {\r\ncalc_planar_422(vv,buf,&vdma2,&vdma3);\r\nbreak;\r\n}\r\ndefault: {\r\nreturn -1;\r\n}\r\n}\r\nif (V4L2_FIELD_HAS_BOTH(field)) {\r\n} else if (field == V4L2_FIELD_ALTERNATE) {\r\nvdma1.base_odd = vdma1.prot_addr;\r\nvdma1.pitch /= 2;\r\nvdma2.base_odd = vdma2.prot_addr;\r\nvdma2.pitch /= 2;\r\nvdma3.base_odd = vdma3.prot_addr;\r\nvdma3.pitch /= 2;\r\n} else if (field == V4L2_FIELD_TOP) {\r\nvdma1.base_odd = vdma1.prot_addr;\r\nvdma1.pitch /= 2;\r\nvdma2.base_odd = vdma2.prot_addr;\r\nvdma2.pitch /= 2;\r\nvdma3.base_odd = vdma3.prot_addr;\r\nvdma3.pitch /= 2;\r\n} else if (field == V4L2_FIELD_BOTTOM) {\r\nvdma1.base_odd = vdma1.base_even;\r\nvdma1.base_even = vdma1.prot_addr;\r\nvdma1.pitch /= 2;\r\nvdma2.base_odd = vdma2.base_even;\r\nvdma2.base_even = vdma2.prot_addr;\r\nvdma2.pitch /= 2;\r\nvdma3.base_odd = vdma3.base_even;\r\nvdma3.base_even = vdma3.prot_addr;\r\nvdma3.pitch /= 2;\r\n}\r\nif( 0 != vv->vflip ) {\r\nvdma1.pitch *= -1;\r\nvdma2.pitch *= -1;\r\nvdma3.pitch *= -1;\r\n}\r\nsaa7146_write_out_dma(dev, 1, &vdma1);\r\nif( (sfmt->flags & FORMAT_BYTE_SWAP) != 0 ) {\r\nsaa7146_write_out_dma(dev, 3, &vdma2);\r\nsaa7146_write_out_dma(dev, 2, &vdma3);\r\n} else {\r\nsaa7146_write_out_dma(dev, 2, &vdma2);\r\nsaa7146_write_out_dma(dev, 3, &vdma3);\r\n}\r\nreturn 0;\r\n}\r\nstatic void program_capture_engine(struct saa7146_dev *dev, int planar)\r\n{\r\nstruct saa7146_vv *vv = dev->vv_data;\r\nint count = 0;\r\nunsigned long e_wait = vv->current_hps_sync == SAA7146_HPS_SYNC_PORT_A ? CMD_E_FID_A : CMD_E_FID_B;\r\nunsigned long o_wait = vv->current_hps_sync == SAA7146_HPS_SYNC_PORT_A ? CMD_O_FID_A : CMD_O_FID_B;\r\nWRITE_RPS0(CMD_PAUSE | CMD_OAN | CMD_SIG0 | o_wait);\r\nWRITE_RPS0(CMD_PAUSE | CMD_OAN | CMD_SIG0 | e_wait);\r\nWRITE_RPS0(CMD_WR_REG | (1 << 8) | (MC2/4));\r\nWRITE_RPS0(MASK_27 | MASK_11);\r\nWRITE_RPS0(CMD_WR_REG_MASK | (MC1/4));\r\nWRITE_RPS0(MASK_06 | MASK_22);\r\nWRITE_RPS0(MASK_06 | MASK_22);\r\nif( 0 != planar ) {\r\nWRITE_RPS0(CMD_WR_REG_MASK | (MC1/4));\r\nWRITE_RPS0(MASK_05 | MASK_21);\r\nWRITE_RPS0(MASK_05 | MASK_21);\r\nWRITE_RPS0(CMD_WR_REG_MASK | (MC1/4));\r\nWRITE_RPS0(MASK_04 | MASK_20);\r\nWRITE_RPS0(MASK_04 | MASK_20);\r\n}\r\nif ( vv->last_field == V4L2_FIELD_INTERLACED ) {\r\nWRITE_RPS0(CMD_PAUSE | o_wait);\r\nWRITE_RPS0(CMD_PAUSE | e_wait);\r\n} else if ( vv->last_field == V4L2_FIELD_TOP ) {\r\nWRITE_RPS0(CMD_PAUSE | (vv->current_hps_sync == SAA7146_HPS_SYNC_PORT_A ? MASK_10 : MASK_09));\r\nWRITE_RPS0(CMD_PAUSE | o_wait);\r\n} else if ( vv->last_field == V4L2_FIELD_BOTTOM ) {\r\nWRITE_RPS0(CMD_PAUSE | (vv->current_hps_sync == SAA7146_HPS_SYNC_PORT_A ? MASK_10 : MASK_09));\r\nWRITE_RPS0(CMD_PAUSE | e_wait);\r\n}\r\nWRITE_RPS0(CMD_WR_REG_MASK | (MC1/4));\r\nWRITE_RPS0(MASK_22 | MASK_06);\r\nWRITE_RPS0(MASK_22);\r\nif( 0 != planar ) {\r\nWRITE_RPS0(CMD_WR_REG_MASK | (MC1/4));\r\nWRITE_RPS0(MASK_05 | MASK_21);\r\nWRITE_RPS0(MASK_21);\r\nWRITE_RPS0(CMD_WR_REG_MASK | (MC1/4));\r\nWRITE_RPS0(MASK_04 | MASK_20);\r\nWRITE_RPS0(MASK_20);\r\n}\r\nWRITE_RPS0(CMD_INTERRUPT);\r\nWRITE_RPS0(CMD_STOP);\r\n}\r\nvoid saa7146_set_capture(struct saa7146_dev *dev, struct saa7146_buf *buf, struct saa7146_buf *next)\r\n{\r\nstruct saa7146_format *sfmt = saa7146_format_by_fourcc(dev,buf->fmt->pixelformat);\r\nstruct saa7146_vv *vv = dev->vv_data;\r\nu32 vdma1_prot_addr;\r\nDEB_CAP("buf:%p, next:%p\n", buf, next);\r\nvdma1_prot_addr = saa7146_read(dev, PROT_ADDR1);\r\nif( 0 == vdma1_prot_addr ) {\r\nDEB_CAP("forcing sync to new frame\n");\r\nsaa7146_write(dev, MC2, MASK_27 );\r\n}\r\nsaa7146_set_window(dev, buf->fmt->width, buf->fmt->height, buf->fmt->field);\r\nsaa7146_set_output_format(dev, sfmt->trans);\r\nsaa7146_disable_clipping(dev);\r\nif ( vv->last_field == V4L2_FIELD_INTERLACED ) {\r\n} else if ( vv->last_field == V4L2_FIELD_TOP ) {\r\nvv->last_field = V4L2_FIELD_BOTTOM;\r\n} else if ( vv->last_field == V4L2_FIELD_BOTTOM ) {\r\nvv->last_field = V4L2_FIELD_TOP;\r\n}\r\nif( 0 != IS_PLANAR(sfmt->trans)) {\r\ncalculate_video_dma_grab_planar(dev, buf);\r\nprogram_capture_engine(dev,1);\r\n} else {\r\ncalculate_video_dma_grab_packed(dev, buf);\r\nprogram_capture_engine(dev,0);\r\n}\r\nsaa7146_write(dev, RPS_ADDR0, dev->d_rps0.dma_handle);\r\nsaa7146_write(dev, MC1, (MASK_12 | MASK_28));\r\n}
