bool mlxfw_mfa2_check(const struct firmware *fw)\r\n{\r\nif (fw->size < sizeof(mlxfw_mfa2_fingerprint))\r\nreturn false;\r\nreturn memcmp(fw->data, mlxfw_mfa2_fingerprint,\r\nmlxfw_mfa2_fingerprint_len) == 0;\r\n}\r\nstatic bool\r\nmlxfw_mfa2_tlv_multi_validate(const struct mlxfw_mfa2_file *mfa2_file,\r\nconst struct mlxfw_mfa2_tlv_multi *multi)\r\n{\r\nconst struct mlxfw_mfa2_tlv *tlv;\r\nu16 idx;\r\nmlxfw_mfa2_tlv_multi_foreach(mfa2_file, tlv, idx, multi) {\r\nif (!tlv) {\r\npr_err("Multi has invalid child");\r\nreturn false;\r\n}\r\n}\r\nreturn true;\r\n}\r\nstatic bool\r\nmlxfw_mfa2_file_dev_validate(const struct mlxfw_mfa2_file *mfa2_file,\r\nconst struct mlxfw_mfa2_tlv *dev_tlv,\r\nu16 dev_idx)\r\n{\r\nconst struct mlxfw_mfa2_tlv_component_ptr *cptr;\r\nconst struct mlxfw_mfa2_tlv_multi *multi;\r\nconst struct mlxfw_mfa2_tlv_psid *psid;\r\nconst struct mlxfw_mfa2_tlv *tlv;\r\nu16 cptr_count;\r\nu16 cptr_idx;\r\nint err;\r\npr_debug("Device %d\n", dev_idx);\r\nmulti = mlxfw_mfa2_tlv_multi_get(mfa2_file, dev_tlv);\r\nif (!multi) {\r\npr_err("Device %d is not a valid TLV error\n", dev_idx);\r\nreturn false;\r\n}\r\nif (!mlxfw_mfa2_tlv_multi_validate(mfa2_file, multi))\r\nreturn false;\r\ntlv = mlxfw_mfa2_tlv_multi_child_find(mfa2_file, multi,\r\nMLXFW_MFA2_TLV_PSID, 0);\r\nif (!tlv) {\r\npr_err("Device %d does not have PSID\n", dev_idx);\r\nreturn false;\r\n}\r\npsid = mlxfw_mfa2_tlv_psid_get(mfa2_file, tlv);\r\nif (!psid) {\r\npr_err("Device %d PSID TLV is not valid\n", dev_idx);\r\nreturn false;\r\n}\r\nprint_hex_dump_debug(" -- Device PSID ", DUMP_PREFIX_NONE, 16, 16,\r\npsid->psid, be16_to_cpu(tlv->len), true);\r\nerr = mlxfw_mfa2_tlv_multi_child_count(mfa2_file, multi,\r\nMLXFW_MFA2_TLV_COMPONENT_PTR,\r\n&cptr_count);\r\nif (err)\r\nreturn false;\r\nif (cptr_count == 0) {\r\npr_err("Device %d has no components\n", dev_idx);\r\nreturn false;\r\n}\r\nfor (cptr_idx = 0; cptr_idx < cptr_count; cptr_idx++) {\r\ntlv = mlxfw_mfa2_tlv_multi_child_find(mfa2_file, multi,\r\nMLXFW_MFA2_TLV_COMPONENT_PTR,\r\ncptr_idx);\r\nif (!tlv)\r\nreturn false;\r\ncptr = mlxfw_mfa2_tlv_component_ptr_get(mfa2_file, tlv);\r\nif (!cptr) {\r\npr_err("Device %d COMPONENT_PTR TLV is not valid\n",\r\ndev_idx);\r\nreturn false;\r\n}\r\npr_debug(" -- Component index %d\n",\r\nbe16_to_cpu(cptr->component_index));\r\n}\r\nreturn true;\r\n}\r\nstatic bool\r\nmlxfw_mfa2_file_comp_validate(const struct mlxfw_mfa2_file *mfa2_file,\r\nconst struct mlxfw_mfa2_tlv *comp_tlv,\r\nu16 comp_idx)\r\n{\r\nconst struct mlxfw_mfa2_tlv_component_descriptor *cdesc;\r\nconst struct mlxfw_mfa2_tlv_multi *multi;\r\nconst struct mlxfw_mfa2_tlv *tlv;\r\npr_debug("Component %d\n", comp_idx);\r\nmulti = mlxfw_mfa2_tlv_multi_get(mfa2_file, comp_tlv);\r\nif (!multi) {\r\npr_err("Component %d is not a valid TLV error\n", comp_idx);\r\nreturn false;\r\n}\r\nif (!mlxfw_mfa2_tlv_multi_validate(mfa2_file, multi))\r\nreturn false;\r\ntlv = mlxfw_mfa2_tlv_multi_child(mfa2_file, multi);\r\nif (!tlv) {\r\npr_err("Component descriptor %d multi TLV error\n", comp_idx);\r\nreturn false;\r\n}\r\ncdesc = mlxfw_mfa2_tlv_component_descriptor_get(mfa2_file, tlv);\r\nif (!cdesc) {\r\npr_err("Component %d does not have a valid descriptor\n",\r\ncomp_idx);\r\nreturn false;\r\n}\r\npr_debug(" -- Component type %d\n", be16_to_cpu(cdesc->identifier));\r\npr_debug(" -- Offset 0x%llx and size %d\n",\r\n((u64) be32_to_cpu(cdesc->cb_offset_h) << 32)\r\n| be32_to_cpu(cdesc->cb_offset_l), be32_to_cpu(cdesc->size));\r\nreturn true;\r\n}\r\nstatic bool mlxfw_mfa2_file_validate(const struct mlxfw_mfa2_file *mfa2_file)\r\n{\r\nconst struct mlxfw_mfa2_tlv *tlv;\r\nu16 idx;\r\npr_debug("Validating file\n");\r\nmlxfw_mfa2_tlv_foreach(mfa2_file, tlv, idx, mfa2_file->first_dev,\r\nmfa2_file->dev_count) {\r\nif (!tlv) {\r\npr_err("Device TLV error\n");\r\nreturn false;\r\n}\r\nif (!mlxfw_mfa2_file_dev_validate(mfa2_file, tlv, idx))\r\nreturn false;\r\n}\r\nmlxfw_mfa2_tlv_foreach(mfa2_file, tlv, idx, mfa2_file->first_component,\r\nmfa2_file->component_count) {\r\nif (!tlv) {\r\npr_err("Device TLV error\n");\r\nreturn false;\r\n}\r\nif (!mlxfw_mfa2_file_comp_validate(mfa2_file, tlv, idx))\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstruct mlxfw_mfa2_file *mlxfw_mfa2_file_init(const struct firmware *fw)\r\n{\r\nconst struct mlxfw_mfa2_tlv_package_descriptor *pd;\r\nconst struct mlxfw_mfa2_tlv_multi *multi;\r\nconst struct mlxfw_mfa2_tlv *multi_child;\r\nconst struct mlxfw_mfa2_tlv *first_tlv;\r\nstruct mlxfw_mfa2_file *mfa2_file;\r\nconst void *first_tlv_ptr;\r\nconst void *cb_top_ptr;\r\nmfa2_file = kcalloc(1, sizeof(*mfa2_file), GFP_KERNEL);\r\nif (!mfa2_file)\r\nreturn ERR_PTR(-ENOMEM);\r\nmfa2_file->fw = fw;\r\nfirst_tlv_ptr = fw->data + NLA_ALIGN(mlxfw_mfa2_fingerprint_len);\r\nfirst_tlv = mlxfw_mfa2_tlv_get(mfa2_file, first_tlv_ptr);\r\nif (!first_tlv) {\r\npr_err("Could not parse package descriptor TLV\n");\r\ngoto err_out;\r\n}\r\nmulti = mlxfw_mfa2_tlv_multi_get(mfa2_file, first_tlv);\r\nif (!multi) {\r\npr_err("First TLV is not of valid multi type\n");\r\ngoto err_out;\r\n}\r\nmulti_child = mlxfw_mfa2_tlv_multi_child(mfa2_file, multi);\r\nif (!multi_child)\r\ngoto err_out;\r\npd = mlxfw_mfa2_tlv_package_descriptor_get(mfa2_file, multi_child);\r\nif (!pd) {\r\npr_err("Could not parse package descriptor TLV\n");\r\ngoto err_out;\r\n}\r\nmfa2_file->first_dev = mlxfw_mfa2_tlv_next(mfa2_file, first_tlv);\r\nif (!mfa2_file->first_dev) {\r\npr_err("First device TLV is not valid\n");\r\ngoto err_out;\r\n}\r\nmfa2_file->dev_count = be16_to_cpu(pd->num_devices);\r\nmfa2_file->first_component = mlxfw_mfa2_tlv_advance(mfa2_file,\r\nmfa2_file->first_dev,\r\nmfa2_file->dev_count);\r\nmfa2_file->component_count = be16_to_cpu(pd->num_components);\r\nmfa2_file->cb = fw->data + NLA_ALIGN(be32_to_cpu(pd->cb_offset));\r\nif (!mlxfw_mfa2_valid_ptr(mfa2_file, mfa2_file->cb)) {\r\npr_err("Component block is out side the file\n");\r\ngoto err_out;\r\n}\r\nmfa2_file->cb_archive_size = be32_to_cpu(pd->cb_archive_size);\r\ncb_top_ptr = mfa2_file->cb + mfa2_file->cb_archive_size - 1;\r\nif (!mlxfw_mfa2_valid_ptr(mfa2_file, cb_top_ptr)) {\r\npr_err("Component block size is too big\n");\r\ngoto err_out;\r\n}\r\nif (!mlxfw_mfa2_file_validate(mfa2_file))\r\ngoto err_out;\r\nreturn mfa2_file;\r\nerr_out:\r\nkfree(mfa2_file);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nstatic const struct mlxfw_mfa2_tlv_multi *\r\nmlxfw_mfa2_tlv_dev_get(const struct mlxfw_mfa2_file *mfa2_file,\r\nconst char *psid, u16 psid_size)\r\n{\r\nconst struct mlxfw_mfa2_tlv_psid *tlv_psid;\r\nconst struct mlxfw_mfa2_tlv_multi *dev_multi;\r\nconst struct mlxfw_mfa2_tlv *dev_tlv;\r\nconst struct mlxfw_mfa2_tlv *tlv;\r\nu32 idx;\r\nmlxfw_mfa2_tlv_foreach(mfa2_file, dev_tlv, idx, mfa2_file->first_dev,\r\nmfa2_file->dev_count) {\r\nif (!dev_tlv)\r\nreturn NULL;\r\ndev_multi = mlxfw_mfa2_tlv_multi_get(mfa2_file, dev_tlv);\r\nif (!dev_multi)\r\nreturn NULL;\r\ntlv = mlxfw_mfa2_tlv_multi_child_find(mfa2_file, dev_multi,\r\nMLXFW_MFA2_TLV_PSID, 0);\r\nif (!tlv)\r\nreturn NULL;\r\nif (be16_to_cpu(tlv->len) != psid_size)\r\ncontinue;\r\ntlv_psid = mlxfw_mfa2_tlv_psid_get(mfa2_file, tlv);\r\nif (!tlv_psid)\r\nreturn NULL;\r\nif (memcmp(psid, tlv_psid->psid, psid_size) == 0)\r\nreturn dev_multi;\r\n}\r\nreturn NULL;\r\n}\r\nint mlxfw_mfa2_file_component_count(const struct mlxfw_mfa2_file *mfa2_file,\r\nconst char *psid, u32 psid_size,\r\nu32 *p_count)\r\n{\r\nconst struct mlxfw_mfa2_tlv_multi *dev_multi;\r\nu16 count;\r\nint err;\r\ndev_multi = mlxfw_mfa2_tlv_dev_get(mfa2_file, psid, psid_size);\r\nif (!dev_multi)\r\nreturn -EINVAL;\r\nerr = mlxfw_mfa2_tlv_multi_child_count(mfa2_file, dev_multi,\r\nMLXFW_MFA2_TLV_COMPONENT_PTR,\r\n&count);\r\nif (err)\r\nreturn err;\r\n*p_count = count;\r\nreturn 0;\r\n}\r\nstatic int mlxfw_mfa2_xz_dec_run(struct xz_dec *xz_dec, struct xz_buf *xz_buf,\r\nbool *finished)\r\n{\r\nenum xz_ret xz_ret;\r\nxz_ret = xz_dec_run(xz_dec, xz_buf);\r\nswitch (xz_ret) {\r\ncase XZ_STREAM_END:\r\n*finished = true;\r\nreturn 0;\r\ncase XZ_OK:\r\n*finished = false;\r\nreturn 0;\r\ncase XZ_MEM_ERROR:\r\npr_err("xz no memory\n");\r\nreturn -ENOMEM;\r\ncase XZ_DATA_ERROR:\r\npr_err("xz file corrupted\n");\r\nreturn -EINVAL;\r\ncase XZ_FORMAT_ERROR:\r\npr_err("xz format not found\n");\r\nreturn -EINVAL;\r\ncase XZ_OPTIONS_ERROR:\r\npr_err("unsupported xz option\n");\r\nreturn -EINVAL;\r\ncase XZ_MEMLIMIT_ERROR:\r\npr_err("xz dictionary too small\n");\r\nreturn -EINVAL;\r\ndefault:\r\npr_err("xz error %d\n", xz_ret);\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int mlxfw_mfa2_file_cb_offset_xz(const struct mlxfw_mfa2_file *mfa2_file,\r\noff_t off, size_t size, u8 *buf)\r\n{\r\nstruct xz_dec *xz_dec;\r\nstruct xz_buf dec_buf;\r\noff_t curr_off = 0;\r\nbool finished;\r\nint err;\r\nxz_dec = xz_dec_init(XZ_DYNALLOC, (u32) -1);\r\nif (!xz_dec)\r\nreturn -EINVAL;\r\ndec_buf.in_size = mfa2_file->cb_archive_size;\r\ndec_buf.in = mfa2_file->cb;\r\ndec_buf.in_pos = 0;\r\ndec_buf.out = buf;\r\ndo {\r\ndec_buf.out_pos = 0;\r\ndec_buf.out_size = min_t(size_t, size, off - curr_off);\r\nif (dec_buf.out_size == 0)\r\nbreak;\r\nerr = mlxfw_mfa2_xz_dec_run(xz_dec, &dec_buf, &finished);\r\nif (err)\r\ngoto out;\r\nif (finished) {\r\npr_err("xz section too short\n");\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\ncurr_off += dec_buf.out_pos;\r\n} while (curr_off != off);\r\ndec_buf.out_pos = 0;\r\ndec_buf.out_size = size;\r\nerr = mlxfw_mfa2_xz_dec_run(xz_dec, &dec_buf, &finished);\r\nout:\r\nxz_dec_end(xz_dec);\r\nreturn err;\r\n}\r\nstatic const struct mlxfw_mfa2_tlv_component_descriptor *\r\nmlxfw_mfa2_file_component_tlv_get(const struct mlxfw_mfa2_file *mfa2_file,\r\nu16 comp_index)\r\n{\r\nconst struct mlxfw_mfa2_tlv_multi *multi;\r\nconst struct mlxfw_mfa2_tlv *multi_child;\r\nconst struct mlxfw_mfa2_tlv *comp_tlv;\r\nif (comp_index > mfa2_file->component_count)\r\nreturn NULL;\r\ncomp_tlv = mlxfw_mfa2_tlv_advance(mfa2_file, mfa2_file->first_component,\r\ncomp_index);\r\nif (!comp_tlv)\r\nreturn NULL;\r\nmulti = mlxfw_mfa2_tlv_multi_get(mfa2_file, comp_tlv);\r\nif (!multi)\r\nreturn NULL;\r\nmulti_child = mlxfw_mfa2_tlv_multi_child(mfa2_file, multi);\r\nif (!multi_child)\r\nreturn NULL;\r\nreturn mlxfw_mfa2_tlv_component_descriptor_get(mfa2_file, multi_child);\r\n}\r\nstatic const struct mlxfw_mfa2_tlv_component_descriptor *\r\nmlxfw_mfa2_file_component_find(const struct mlxfw_mfa2_file *mfa2_file,\r\nconst char *psid, int psid_size,\r\nint component_index)\r\n{\r\nconst struct mlxfw_mfa2_tlv_component_ptr *cptr;\r\nconst struct mlxfw_mfa2_tlv_multi *dev_multi;\r\nconst struct mlxfw_mfa2_tlv *cptr_tlv;\r\nu16 comp_idx;\r\ndev_multi = mlxfw_mfa2_tlv_dev_get(mfa2_file, psid, psid_size);\r\nif (!dev_multi)\r\nreturn NULL;\r\ncptr_tlv = mlxfw_mfa2_tlv_multi_child_find(mfa2_file, dev_multi,\r\nMLXFW_MFA2_TLV_COMPONENT_PTR,\r\ncomponent_index);\r\nif (!cptr_tlv)\r\nreturn NULL;\r\ncptr = mlxfw_mfa2_tlv_component_ptr_get(mfa2_file, cptr_tlv);\r\nif (!cptr)\r\nreturn NULL;\r\ncomp_idx = be16_to_cpu(cptr->component_index);\r\nreturn mlxfw_mfa2_file_component_tlv_get(mfa2_file, comp_idx);\r\n}\r\nstruct mlxfw_mfa2_component *\r\nmlxfw_mfa2_file_component_get(const struct mlxfw_mfa2_file *mfa2_file,\r\nconst char *psid, int psid_size,\r\nint component_index)\r\n{\r\nconst struct mlxfw_mfa2_tlv_component_descriptor *comp;\r\nstruct mlxfw_mfa2_comp_data *comp_data;\r\nu32 comp_buf_size;\r\noff_t cb_offset;\r\nu32 comp_size;\r\nint err;\r\ncomp = mlxfw_mfa2_file_component_find(mfa2_file, psid, psid_size,\r\ncomponent_index);\r\nif (!comp)\r\nreturn ERR_PTR(-EINVAL);\r\ncb_offset = (u64) be32_to_cpu(comp->cb_offset_h) << 32 |\r\nbe32_to_cpu(comp->cb_offset_l);\r\ncomp_size = be32_to_cpu(comp->size);\r\ncomp_buf_size = comp_size + mlxfw_mfa2_comp_magic_len;\r\ncomp_data = kmalloc(sizeof(*comp_data) + comp_buf_size, GFP_KERNEL);\r\nif (!comp_data)\r\nreturn ERR_PTR(-ENOMEM);\r\ncomp_data->comp.data_size = comp_size;\r\ncomp_data->comp.index = be16_to_cpu(comp->identifier);\r\nerr = mlxfw_mfa2_file_cb_offset_xz(mfa2_file, cb_offset, comp_buf_size,\r\ncomp_data->buff);\r\nif (err) {\r\npr_err("Component could not be reached in CB\n");\r\ngoto err_out;\r\n}\r\nif (memcmp(comp_data->buff, mlxfw_mfa2_comp_magic,\r\nmlxfw_mfa2_comp_magic_len) != 0) {\r\npr_err("Component has wrong magic\n");\r\nerr = -EINVAL;\r\ngoto err_out;\r\n}\r\ncomp_data->comp.data = comp_data->buff + mlxfw_mfa2_comp_magic_len;\r\nreturn &comp_data->comp;\r\nerr_out:\r\nkfree(comp_data);\r\nreturn ERR_PTR(err);\r\n}\r\nvoid mlxfw_mfa2_file_component_put(struct mlxfw_mfa2_component *comp)\r\n{\r\nconst struct mlxfw_mfa2_comp_data *comp_data;\r\ncomp_data = container_of(comp, struct mlxfw_mfa2_comp_data, comp);\r\nkfree(comp_data);\r\n}\r\nvoid mlxfw_mfa2_file_fini(struct mlxfw_mfa2_file *mfa2_file)\r\n{\r\nkfree(mfa2_file);\r\n}
