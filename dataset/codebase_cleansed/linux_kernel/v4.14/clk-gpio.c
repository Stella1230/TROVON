static int clk_gpio_gate_enable(struct clk_hw *hw)\r\n{\r\nstruct clk_gpio *clk = to_clk_gpio(hw);\r\ngpiod_set_value(clk->gpiod, 1);\r\nreturn 0;\r\n}\r\nstatic void clk_gpio_gate_disable(struct clk_hw *hw)\r\n{\r\nstruct clk_gpio *clk = to_clk_gpio(hw);\r\ngpiod_set_value(clk->gpiod, 0);\r\n}\r\nstatic int clk_gpio_gate_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct clk_gpio *clk = to_clk_gpio(hw);\r\nreturn gpiod_get_value(clk->gpiod);\r\n}\r\nstatic u8 clk_gpio_mux_get_parent(struct clk_hw *hw)\r\n{\r\nstruct clk_gpio *clk = to_clk_gpio(hw);\r\nreturn gpiod_get_value(clk->gpiod);\r\n}\r\nstatic int clk_gpio_mux_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct clk_gpio *clk = to_clk_gpio(hw);\r\ngpiod_set_value(clk->gpiod, index);\r\nreturn 0;\r\n}\r\nstatic struct clk_hw *clk_register_gpio(struct device *dev, const char *name,\r\nconst char * const *parent_names, u8 num_parents, unsigned gpio,\r\nbool active_low, unsigned long flags,\r\nconst struct clk_ops *clk_gpio_ops)\r\n{\r\nstruct clk_gpio *clk_gpio;\r\nstruct clk_hw *hw;\r\nstruct clk_init_data init = {};\r\nunsigned long gpio_flags;\r\nint err;\r\nif (dev)\r\nclk_gpio = devm_kzalloc(dev, sizeof(*clk_gpio), GFP_KERNEL);\r\nelse\r\nclk_gpio = kzalloc(sizeof(*clk_gpio), GFP_KERNEL);\r\nif (!clk_gpio)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (active_low)\r\ngpio_flags = GPIOF_ACTIVE_LOW | GPIOF_OUT_INIT_HIGH;\r\nelse\r\ngpio_flags = GPIOF_OUT_INIT_LOW;\r\nif (dev)\r\nerr = devm_gpio_request_one(dev, gpio, gpio_flags, name);\r\nelse\r\nerr = gpio_request_one(gpio, gpio_flags, name);\r\nif (err) {\r\nif (err != -EPROBE_DEFER)\r\npr_err("%s: %s: Error requesting clock control gpio %u\n",\r\n__func__, name, gpio);\r\nif (!dev)\r\nkfree(clk_gpio);\r\nreturn ERR_PTR(err);\r\n}\r\ninit.name = name;\r\ninit.ops = clk_gpio_ops;\r\ninit.flags = flags | CLK_IS_BASIC;\r\ninit.parent_names = parent_names;\r\ninit.num_parents = num_parents;\r\nclk_gpio->gpiod = gpio_to_desc(gpio);\r\nclk_gpio->hw.init = &init;\r\nhw = &clk_gpio->hw;\r\nif (dev)\r\nerr = devm_clk_hw_register(dev, hw);\r\nelse\r\nerr = clk_hw_register(NULL, hw);\r\nif (!err)\r\nreturn hw;\r\nif (!dev) {\r\ngpiod_put(clk_gpio->gpiod);\r\nkfree(clk_gpio);\r\n}\r\nreturn ERR_PTR(err);\r\n}\r\nstruct clk_hw *clk_hw_register_gpio_gate(struct device *dev, const char *name,\r\nconst char *parent_name, unsigned gpio, bool active_low,\r\nunsigned long flags)\r\n{\r\nreturn clk_register_gpio(dev, name,\r\n(parent_name ? &parent_name : NULL),\r\n(parent_name ? 1 : 0), gpio, active_low, flags,\r\n&clk_gpio_gate_ops);\r\n}\r\nstruct clk *clk_register_gpio_gate(struct device *dev, const char *name,\r\nconst char *parent_name, unsigned gpio, bool active_low,\r\nunsigned long flags)\r\n{\r\nstruct clk_hw *hw;\r\nhw = clk_hw_register_gpio_gate(dev, name, parent_name, gpio, active_low,\r\nflags);\r\nif (IS_ERR(hw))\r\nreturn ERR_CAST(hw);\r\nreturn hw->clk;\r\n}\r\nstruct clk_hw *clk_hw_register_gpio_mux(struct device *dev, const char *name,\r\nconst char * const *parent_names, u8 num_parents, unsigned gpio,\r\nbool active_low, unsigned long flags)\r\n{\r\nif (num_parents != 2) {\r\npr_err("mux-clock %s must have 2 parents\n", name);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nreturn clk_register_gpio(dev, name, parent_names, num_parents,\r\ngpio, active_low, flags, &clk_gpio_mux_ops);\r\n}\r\nstruct clk *clk_register_gpio_mux(struct device *dev, const char *name,\r\nconst char * const *parent_names, u8 num_parents, unsigned gpio,\r\nbool active_low, unsigned long flags)\r\n{\r\nstruct clk_hw *hw;\r\nhw = clk_hw_register_gpio_mux(dev, name, parent_names, num_parents,\r\ngpio, active_low, flags);\r\nif (IS_ERR(hw))\r\nreturn ERR_CAST(hw);\r\nreturn hw->clk;\r\n}\r\nstatic int gpio_clk_driver_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *node = pdev->dev.of_node;\r\nconst char **parent_names, *gpio_name;\r\nunsigned int num_parents;\r\nint gpio;\r\nenum of_gpio_flags of_flags;\r\nstruct clk *clk;\r\nbool active_low, is_mux;\r\nnum_parents = of_clk_get_parent_count(node);\r\nif (num_parents) {\r\nparent_names = devm_kcalloc(&pdev->dev, num_parents,\r\nsizeof(char *), GFP_KERNEL);\r\nif (!parent_names)\r\nreturn -ENOMEM;\r\nof_clk_parent_fill(node, parent_names, num_parents);\r\n} else {\r\nparent_names = NULL;\r\n}\r\nis_mux = of_device_is_compatible(node, "gpio-mux-clock");\r\ngpio_name = is_mux ? "select-gpios" : "enable-gpios";\r\ngpio = of_get_named_gpio_flags(node, gpio_name, 0, &of_flags);\r\nif (gpio < 0) {\r\nif (gpio == -EPROBE_DEFER)\r\npr_debug("%s: %s: GPIOs not yet available, retry later\n",\r\nnode->name, __func__);\r\nelse\r\npr_err("%s: %s: Can't get '%s' DT property\n",\r\nnode->name, __func__,\r\ngpio_name);\r\nreturn gpio;\r\n}\r\nactive_low = of_flags & OF_GPIO_ACTIVE_LOW;\r\nif (is_mux)\r\nclk = clk_register_gpio_mux(&pdev->dev, node->name,\r\nparent_names, num_parents, gpio, active_low, 0);\r\nelse\r\nclk = clk_register_gpio_gate(&pdev->dev, node->name,\r\nparent_names ? parent_names[0] : NULL, gpio,\r\nactive_low, 0);\r\nif (IS_ERR(clk))\r\nreturn PTR_ERR(clk);\r\nreturn of_clk_add_provider(node, of_clk_src_simple_get, clk);\r\n}
