ieee80211_tx_result\r\nieee80211_tx_h_michael_mic_add(struct ieee80211_tx_data *tx)\r\n{\r\nu8 *data, *key, *mic;\r\nsize_t data_len;\r\nunsigned int hdrlen;\r\nstruct ieee80211_hdr *hdr;\r\nstruct sk_buff *skb = tx->skb;\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nint tail;\r\nhdr = (struct ieee80211_hdr *)skb->data;\r\nif (!tx->key || tx->key->conf.cipher != WLAN_CIPHER_SUITE_TKIP ||\r\nskb->len < 24 || !ieee80211_is_data_present(hdr->frame_control))\r\nreturn TX_CONTINUE;\r\nhdrlen = ieee80211_hdrlen(hdr->frame_control);\r\nif (skb->len < hdrlen)\r\nreturn TX_DROP;\r\ndata = skb->data + hdrlen;\r\ndata_len = skb->len - hdrlen;\r\nif (unlikely(info->flags & IEEE80211_TX_INTFL_TKIP_MIC_FAILURE)) {\r\ninfo->control.hw_key = NULL;\r\n}\r\nif (info->control.hw_key &&\r\n(info->flags & IEEE80211_TX_CTL_DONTFRAG ||\r\nieee80211_hw_check(&tx->local->hw, SUPPORTS_TX_FRAG)) &&\r\n!(tx->key->conf.flags & IEEE80211_KEY_FLAG_GENERATE_MMIC)) {\r\nreturn TX_CONTINUE;\r\n}\r\ntail = MICHAEL_MIC_LEN;\r\nif (!info->control.hw_key)\r\ntail += IEEE80211_TKIP_ICV_LEN;\r\nif (WARN(skb_tailroom(skb) < tail ||\r\nskb_headroom(skb) < IEEE80211_TKIP_IV_LEN,\r\n"mmic: not enough head/tail (%d/%d,%d/%d)\n",\r\nskb_headroom(skb), IEEE80211_TKIP_IV_LEN,\r\nskb_tailroom(skb), tail))\r\nreturn TX_DROP;\r\nkey = &tx->key->conf.key[NL80211_TKIP_DATA_OFFSET_TX_MIC_KEY];\r\nmic = skb_put(skb, MICHAEL_MIC_LEN);\r\nmichael_mic(key, hdr, data, data_len, mic);\r\nif (unlikely(info->flags & IEEE80211_TX_INTFL_TKIP_MIC_FAILURE))\r\nmic[0]++;\r\nreturn TX_CONTINUE;\r\n}\r\nieee80211_rx_result\r\nieee80211_rx_h_michael_mic_verify(struct ieee80211_rx_data *rx)\r\n{\r\nu8 *data, *key = NULL;\r\nsize_t data_len;\r\nunsigned int hdrlen;\r\nu8 mic[MICHAEL_MIC_LEN];\r\nstruct sk_buff *skb = rx->skb;\r\nstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\r\nif (!ieee80211_is_data_present(hdr->frame_control))\r\nreturn RX_CONTINUE;\r\nif (status->flag & (RX_FLAG_MMIC_STRIPPED | RX_FLAG_IV_STRIPPED)) {\r\nif (status->flag & RX_FLAG_MMIC_ERROR)\r\ngoto mic_fail_no_key;\r\nif (!(status->flag & RX_FLAG_IV_STRIPPED) && rx->key &&\r\nrx->key->conf.cipher == WLAN_CIPHER_SUITE_TKIP)\r\ngoto update_iv;\r\nreturn RX_CONTINUE;\r\n}\r\nif (!rx->key || rx->key->conf.cipher != WLAN_CIPHER_SUITE_TKIP ||\r\n!(status->flag & RX_FLAG_DECRYPTED))\r\nreturn RX_CONTINUE;\r\nif (rx->sdata->vif.type == NL80211_IFTYPE_AP && rx->key->conf.keyidx) {\r\nreturn RX_DROP_UNUSABLE;\r\n}\r\nif (status->flag & RX_FLAG_MMIC_ERROR)\r\ngoto mic_fail;\r\nhdrlen = ieee80211_hdrlen(hdr->frame_control);\r\nif (skb->len < hdrlen + MICHAEL_MIC_LEN)\r\nreturn RX_DROP_UNUSABLE;\r\nif (skb_linearize(rx->skb))\r\nreturn RX_DROP_UNUSABLE;\r\nhdr = (void *)skb->data;\r\ndata = skb->data + hdrlen;\r\ndata_len = skb->len - hdrlen - MICHAEL_MIC_LEN;\r\nkey = &rx->key->conf.key[NL80211_TKIP_DATA_OFFSET_RX_MIC_KEY];\r\nmichael_mic(key, hdr, data, data_len, mic);\r\nif (crypto_memneq(mic, data + data_len, MICHAEL_MIC_LEN))\r\ngoto mic_fail;\r\nskb_trim(skb, skb->len - MICHAEL_MIC_LEN);\r\nupdate_iv:\r\nrx->key->u.tkip.rx[rx->security_idx].iv32 = rx->tkip_iv32;\r\nrx->key->u.tkip.rx[rx->security_idx].iv16 = rx->tkip_iv16;\r\nreturn RX_CONTINUE;\r\nmic_fail:\r\nrx->key->u.tkip.mic_failures++;\r\nmic_fail_no_key:\r\ncfg80211_michael_mic_failure(rx->sdata->dev, hdr->addr2,\r\nis_multicast_ether_addr(hdr->addr1) ?\r\nNL80211_KEYTYPE_GROUP :\r\nNL80211_KEYTYPE_PAIRWISE,\r\nrx->key ? rx->key->conf.keyidx : -1,\r\nNULL, GFP_ATOMIC);\r\nreturn RX_DROP_UNUSABLE;\r\n}\r\nstatic int tkip_encrypt_skb(struct ieee80211_tx_data *tx, struct sk_buff *skb)\r\n{\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\r\nstruct ieee80211_key *key = tx->key;\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nunsigned int hdrlen;\r\nint len, tail;\r\nu64 pn;\r\nu8 *pos;\r\nif (info->control.hw_key &&\r\n!(info->control.hw_key->flags & IEEE80211_KEY_FLAG_GENERATE_IV) &&\r\n!(info->control.hw_key->flags & IEEE80211_KEY_FLAG_PUT_IV_SPACE)) {\r\nreturn 0;\r\n}\r\nhdrlen = ieee80211_hdrlen(hdr->frame_control);\r\nlen = skb->len - hdrlen;\r\nif (info->control.hw_key)\r\ntail = 0;\r\nelse\r\ntail = IEEE80211_TKIP_ICV_LEN;\r\nif (WARN_ON(skb_tailroom(skb) < tail ||\r\nskb_headroom(skb) < IEEE80211_TKIP_IV_LEN))\r\nreturn -1;\r\npos = skb_push(skb, IEEE80211_TKIP_IV_LEN);\r\nmemmove(pos, pos + IEEE80211_TKIP_IV_LEN, hdrlen);\r\npos += hdrlen;\r\nif (info->control.hw_key &&\r\n(info->control.hw_key->flags & IEEE80211_KEY_FLAG_PUT_IV_SPACE))\r\nreturn 0;\r\npn = atomic64_inc_return(&key->conf.tx_pn);\r\npos = ieee80211_tkip_add_iv(pos, &key->conf, pn);\r\nif (info->control.hw_key)\r\nreturn 0;\r\nskb_put(skb, IEEE80211_TKIP_ICV_LEN);\r\nreturn ieee80211_tkip_encrypt_data(tx->local->wep_tx_tfm,\r\nkey, skb, pos, len);\r\n}\r\nieee80211_tx_result\r\nieee80211_crypto_tkip_encrypt(struct ieee80211_tx_data *tx)\r\n{\r\nstruct sk_buff *skb;\r\nieee80211_tx_set_protected(tx);\r\nskb_queue_walk(&tx->skbs, skb) {\r\nif (tkip_encrypt_skb(tx, skb) < 0)\r\nreturn TX_DROP;\r\n}\r\nreturn TX_CONTINUE;\r\n}\r\nieee80211_rx_result\r\nieee80211_crypto_tkip_decrypt(struct ieee80211_rx_data *rx)\r\n{\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) rx->skb->data;\r\nint hdrlen, res, hwaccel = 0;\r\nstruct ieee80211_key *key = rx->key;\r\nstruct sk_buff *skb = rx->skb;\r\nstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\r\nhdrlen = ieee80211_hdrlen(hdr->frame_control);\r\nif (!ieee80211_is_data(hdr->frame_control))\r\nreturn RX_CONTINUE;\r\nif (!rx->sta || skb->len - hdrlen < 12)\r\nreturn RX_DROP_UNUSABLE;\r\nif (skb_linearize(rx->skb))\r\nreturn RX_DROP_UNUSABLE;\r\nhdr = (void *)skb->data;\r\nif (status->flag & RX_FLAG_DECRYPTED)\r\nhwaccel = 1;\r\nres = ieee80211_tkip_decrypt_data(rx->local->wep_rx_tfm,\r\nkey, skb->data + hdrlen,\r\nskb->len - hdrlen, rx->sta->sta.addr,\r\nhdr->addr1, hwaccel, rx->security_idx,\r\n&rx->tkip_iv32,\r\n&rx->tkip_iv16);\r\nif (res != TKIP_DECRYPT_OK)\r\nreturn RX_DROP_UNUSABLE;\r\nif (!(status->flag & RX_FLAG_ICV_STRIPPED))\r\nskb_trim(skb, skb->len - IEEE80211_TKIP_ICV_LEN);\r\nmemmove(skb->data + IEEE80211_TKIP_IV_LEN, skb->data, hdrlen);\r\nskb_pull(skb, IEEE80211_TKIP_IV_LEN);\r\nreturn RX_CONTINUE;\r\n}\r\nstatic void ccmp_special_blocks(struct sk_buff *skb, u8 *pn, u8 *b_0, u8 *aad)\r\n{\r\n__le16 mask_fc;\r\nint a4_included, mgmt;\r\nu8 qos_tid;\r\nu16 len_a;\r\nunsigned int hdrlen;\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\r\nmgmt = ieee80211_is_mgmt(hdr->frame_control);\r\nmask_fc = hdr->frame_control;\r\nmask_fc &= ~cpu_to_le16(IEEE80211_FCTL_RETRY |\r\nIEEE80211_FCTL_PM | IEEE80211_FCTL_MOREDATA);\r\nif (!mgmt)\r\nmask_fc &= ~cpu_to_le16(0x0070);\r\nmask_fc |= cpu_to_le16(IEEE80211_FCTL_PROTECTED);\r\nhdrlen = ieee80211_hdrlen(hdr->frame_control);\r\nlen_a = hdrlen - 2;\r\na4_included = ieee80211_has_a4(hdr->frame_control);\r\nif (ieee80211_is_data_qos(hdr->frame_control))\r\nqos_tid = *ieee80211_get_qos_ctl(hdr) & IEEE80211_QOS_CTL_TID_MASK;\r\nelse\r\nqos_tid = 0;\r\nb_0[0] = 0x1;\r\nb_0[1] = qos_tid | (mgmt << 4);\r\nmemcpy(&b_0[2], hdr->addr2, ETH_ALEN);\r\nmemcpy(&b_0[8], pn, IEEE80211_CCMP_PN_LEN);\r\nput_unaligned_be16(len_a, &aad[0]);\r\nput_unaligned(mask_fc, (__le16 *)&aad[2]);\r\nmemcpy(&aad[4], &hdr->addr1, 3 * ETH_ALEN);\r\naad[22] = *((u8 *) &hdr->seq_ctrl) & 0x0f;\r\naad[23] = 0;\r\nif (a4_included) {\r\nmemcpy(&aad[24], hdr->addr4, ETH_ALEN);\r\naad[30] = qos_tid;\r\naad[31] = 0;\r\n} else {\r\nmemset(&aad[24], 0, ETH_ALEN + IEEE80211_QOS_CTL_LEN);\r\naad[24] = qos_tid;\r\n}\r\n}\r\nstatic inline void ccmp_pn2hdr(u8 *hdr, u8 *pn, int key_id)\r\n{\r\nhdr[0] = pn[5];\r\nhdr[1] = pn[4];\r\nhdr[2] = 0;\r\nhdr[3] = 0x20 | (key_id << 6);\r\nhdr[4] = pn[3];\r\nhdr[5] = pn[2];\r\nhdr[6] = pn[1];\r\nhdr[7] = pn[0];\r\n}\r\nstatic inline void ccmp_hdr2pn(u8 *pn, u8 *hdr)\r\n{\r\npn[0] = hdr[7];\r\npn[1] = hdr[6];\r\npn[2] = hdr[5];\r\npn[3] = hdr[4];\r\npn[4] = hdr[1];\r\npn[5] = hdr[0];\r\n}\r\nstatic int ccmp_encrypt_skb(struct ieee80211_tx_data *tx, struct sk_buff *skb,\r\nunsigned int mic_len)\r\n{\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\r\nstruct ieee80211_key *key = tx->key;\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nint hdrlen, len, tail;\r\nu8 *pos;\r\nu8 pn[6];\r\nu64 pn64;\r\nu8 aad[CCM_AAD_LEN];\r\nu8 b_0[AES_BLOCK_SIZE];\r\nif (info->control.hw_key &&\r\n!(info->control.hw_key->flags & IEEE80211_KEY_FLAG_GENERATE_IV) &&\r\n!(info->control.hw_key->flags & IEEE80211_KEY_FLAG_PUT_IV_SPACE) &&\r\n!((info->control.hw_key->flags &\r\nIEEE80211_KEY_FLAG_GENERATE_IV_MGMT) &&\r\nieee80211_is_mgmt(hdr->frame_control))) {\r\nreturn 0;\r\n}\r\nhdrlen = ieee80211_hdrlen(hdr->frame_control);\r\nlen = skb->len - hdrlen;\r\nif (info->control.hw_key)\r\ntail = 0;\r\nelse\r\ntail = mic_len;\r\nif (WARN_ON(skb_tailroom(skb) < tail ||\r\nskb_headroom(skb) < IEEE80211_CCMP_HDR_LEN))\r\nreturn -1;\r\npos = skb_push(skb, IEEE80211_CCMP_HDR_LEN);\r\nmemmove(pos, pos + IEEE80211_CCMP_HDR_LEN, hdrlen);\r\nif (info->control.hw_key &&\r\n(info->control.hw_key->flags & IEEE80211_KEY_FLAG_PUT_IV_SPACE))\r\nreturn 0;\r\nhdr = (struct ieee80211_hdr *) pos;\r\npos += hdrlen;\r\npn64 = atomic64_inc_return(&key->conf.tx_pn);\r\npn[5] = pn64;\r\npn[4] = pn64 >> 8;\r\npn[3] = pn64 >> 16;\r\npn[2] = pn64 >> 24;\r\npn[1] = pn64 >> 32;\r\npn[0] = pn64 >> 40;\r\nccmp_pn2hdr(pos, pn, key->conf.keyidx);\r\nif (info->control.hw_key)\r\nreturn 0;\r\npos += IEEE80211_CCMP_HDR_LEN;\r\nccmp_special_blocks(skb, pn, b_0, aad);\r\nreturn ieee80211_aes_ccm_encrypt(key->u.ccmp.tfm, b_0, aad, pos, len,\r\nskb_put(skb, mic_len), mic_len);\r\n}\r\nieee80211_tx_result\r\nieee80211_crypto_ccmp_encrypt(struct ieee80211_tx_data *tx,\r\nunsigned int mic_len)\r\n{\r\nstruct sk_buff *skb;\r\nieee80211_tx_set_protected(tx);\r\nskb_queue_walk(&tx->skbs, skb) {\r\nif (ccmp_encrypt_skb(tx, skb, mic_len) < 0)\r\nreturn TX_DROP;\r\n}\r\nreturn TX_CONTINUE;\r\n}\r\nieee80211_rx_result\r\nieee80211_crypto_ccmp_decrypt(struct ieee80211_rx_data *rx,\r\nunsigned int mic_len)\r\n{\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)rx->skb->data;\r\nint hdrlen;\r\nstruct ieee80211_key *key = rx->key;\r\nstruct sk_buff *skb = rx->skb;\r\nstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\r\nu8 pn[IEEE80211_CCMP_PN_LEN];\r\nint data_len;\r\nint queue;\r\nhdrlen = ieee80211_hdrlen(hdr->frame_control);\r\nif (!ieee80211_is_data(hdr->frame_control) &&\r\n!ieee80211_is_robust_mgmt_frame(skb))\r\nreturn RX_CONTINUE;\r\nif (status->flag & RX_FLAG_DECRYPTED) {\r\nif (!pskb_may_pull(rx->skb, hdrlen + IEEE80211_CCMP_HDR_LEN))\r\nreturn RX_DROP_UNUSABLE;\r\nif (status->flag & RX_FLAG_MIC_STRIPPED)\r\nmic_len = 0;\r\n} else {\r\nif (skb_linearize(rx->skb))\r\nreturn RX_DROP_UNUSABLE;\r\n}\r\ndata_len = skb->len - hdrlen - IEEE80211_CCMP_HDR_LEN - mic_len;\r\nif (!rx->sta || data_len < 0)\r\nreturn RX_DROP_UNUSABLE;\r\nif (!(status->flag & RX_FLAG_PN_VALIDATED)) {\r\nint res;\r\nccmp_hdr2pn(pn, skb->data + hdrlen);\r\nqueue = rx->security_idx;\r\nres = memcmp(pn, key->u.ccmp.rx_pn[queue],\r\nIEEE80211_CCMP_PN_LEN);\r\nif (res < 0 ||\r\n(!res && !(status->flag & RX_FLAG_ALLOW_SAME_PN))) {\r\nkey->u.ccmp.replays++;\r\nreturn RX_DROP_UNUSABLE;\r\n}\r\nif (!(status->flag & RX_FLAG_DECRYPTED)) {\r\nu8 aad[2 * AES_BLOCK_SIZE];\r\nu8 b_0[AES_BLOCK_SIZE];\r\nccmp_special_blocks(skb, pn, b_0, aad);\r\nif (ieee80211_aes_ccm_decrypt(\r\nkey->u.ccmp.tfm, b_0, aad,\r\nskb->data + hdrlen + IEEE80211_CCMP_HDR_LEN,\r\ndata_len,\r\nskb->data + skb->len - mic_len, mic_len))\r\nreturn RX_DROP_UNUSABLE;\r\n}\r\nmemcpy(key->u.ccmp.rx_pn[queue], pn, IEEE80211_CCMP_PN_LEN);\r\n}\r\nif (pskb_trim(skb, skb->len - mic_len))\r\nreturn RX_DROP_UNUSABLE;\r\nmemmove(skb->data + IEEE80211_CCMP_HDR_LEN, skb->data, hdrlen);\r\nskb_pull(skb, IEEE80211_CCMP_HDR_LEN);\r\nreturn RX_CONTINUE;\r\n}\r\nstatic void gcmp_special_blocks(struct sk_buff *skb, u8 *pn, u8 *j_0, u8 *aad)\r\n{\r\n__le16 mask_fc;\r\nu8 qos_tid;\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\r\nmemcpy(j_0, hdr->addr2, ETH_ALEN);\r\nmemcpy(&j_0[ETH_ALEN], pn, IEEE80211_GCMP_PN_LEN);\r\nj_0[13] = 0;\r\nj_0[14] = 0;\r\nj_0[AES_BLOCK_SIZE - 1] = 0x01;\r\nput_unaligned_be16(ieee80211_hdrlen(hdr->frame_control) - 2, &aad[0]);\r\nmask_fc = hdr->frame_control;\r\nmask_fc &= ~cpu_to_le16(IEEE80211_FCTL_RETRY |\r\nIEEE80211_FCTL_PM | IEEE80211_FCTL_MOREDATA);\r\nif (!ieee80211_is_mgmt(hdr->frame_control))\r\nmask_fc &= ~cpu_to_le16(0x0070);\r\nmask_fc |= cpu_to_le16(IEEE80211_FCTL_PROTECTED);\r\nput_unaligned(mask_fc, (__le16 *)&aad[2]);\r\nmemcpy(&aad[4], &hdr->addr1, 3 * ETH_ALEN);\r\naad[22] = *((u8 *)&hdr->seq_ctrl) & 0x0f;\r\naad[23] = 0;\r\nif (ieee80211_is_data_qos(hdr->frame_control))\r\nqos_tid = *ieee80211_get_qos_ctl(hdr) &\r\nIEEE80211_QOS_CTL_TID_MASK;\r\nelse\r\nqos_tid = 0;\r\nif (ieee80211_has_a4(hdr->frame_control)) {\r\nmemcpy(&aad[24], hdr->addr4, ETH_ALEN);\r\naad[30] = qos_tid;\r\naad[31] = 0;\r\n} else {\r\nmemset(&aad[24], 0, ETH_ALEN + IEEE80211_QOS_CTL_LEN);\r\naad[24] = qos_tid;\r\n}\r\n}\r\nstatic inline void gcmp_pn2hdr(u8 *hdr, const u8 *pn, int key_id)\r\n{\r\nhdr[0] = pn[5];\r\nhdr[1] = pn[4];\r\nhdr[2] = 0;\r\nhdr[3] = 0x20 | (key_id << 6);\r\nhdr[4] = pn[3];\r\nhdr[5] = pn[2];\r\nhdr[6] = pn[1];\r\nhdr[7] = pn[0];\r\n}\r\nstatic inline void gcmp_hdr2pn(u8 *pn, const u8 *hdr)\r\n{\r\npn[0] = hdr[7];\r\npn[1] = hdr[6];\r\npn[2] = hdr[5];\r\npn[3] = hdr[4];\r\npn[4] = hdr[1];\r\npn[5] = hdr[0];\r\n}\r\nstatic int gcmp_encrypt_skb(struct ieee80211_tx_data *tx, struct sk_buff *skb)\r\n{\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\r\nstruct ieee80211_key *key = tx->key;\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nint hdrlen, len, tail;\r\nu8 *pos;\r\nu8 pn[6];\r\nu64 pn64;\r\nu8 aad[GCM_AAD_LEN];\r\nu8 j_0[AES_BLOCK_SIZE];\r\nif (info->control.hw_key &&\r\n!(info->control.hw_key->flags & IEEE80211_KEY_FLAG_GENERATE_IV) &&\r\n!(info->control.hw_key->flags & IEEE80211_KEY_FLAG_PUT_IV_SPACE) &&\r\n!((info->control.hw_key->flags &\r\nIEEE80211_KEY_FLAG_GENERATE_IV_MGMT) &&\r\nieee80211_is_mgmt(hdr->frame_control))) {\r\nreturn 0;\r\n}\r\nhdrlen = ieee80211_hdrlen(hdr->frame_control);\r\nlen = skb->len - hdrlen;\r\nif (info->control.hw_key)\r\ntail = 0;\r\nelse\r\ntail = IEEE80211_GCMP_MIC_LEN;\r\nif (WARN_ON(skb_tailroom(skb) < tail ||\r\nskb_headroom(skb) < IEEE80211_GCMP_HDR_LEN))\r\nreturn -1;\r\npos = skb_push(skb, IEEE80211_GCMP_HDR_LEN);\r\nmemmove(pos, pos + IEEE80211_GCMP_HDR_LEN, hdrlen);\r\nskb_set_network_header(skb, skb_network_offset(skb) +\r\nIEEE80211_GCMP_HDR_LEN);\r\nif (info->control.hw_key &&\r\n(info->control.hw_key->flags & IEEE80211_KEY_FLAG_PUT_IV_SPACE))\r\nreturn 0;\r\nhdr = (struct ieee80211_hdr *)pos;\r\npos += hdrlen;\r\npn64 = atomic64_inc_return(&key->conf.tx_pn);\r\npn[5] = pn64;\r\npn[4] = pn64 >> 8;\r\npn[3] = pn64 >> 16;\r\npn[2] = pn64 >> 24;\r\npn[1] = pn64 >> 32;\r\npn[0] = pn64 >> 40;\r\ngcmp_pn2hdr(pos, pn, key->conf.keyidx);\r\nif (info->control.hw_key)\r\nreturn 0;\r\npos += IEEE80211_GCMP_HDR_LEN;\r\ngcmp_special_blocks(skb, pn, j_0, aad);\r\nreturn ieee80211_aes_gcm_encrypt(key->u.gcmp.tfm, j_0, aad, pos, len,\r\nskb_put(skb, IEEE80211_GCMP_MIC_LEN));\r\n}\r\nieee80211_tx_result\r\nieee80211_crypto_gcmp_encrypt(struct ieee80211_tx_data *tx)\r\n{\r\nstruct sk_buff *skb;\r\nieee80211_tx_set_protected(tx);\r\nskb_queue_walk(&tx->skbs, skb) {\r\nif (gcmp_encrypt_skb(tx, skb) < 0)\r\nreturn TX_DROP;\r\n}\r\nreturn TX_CONTINUE;\r\n}\r\nieee80211_rx_result\r\nieee80211_crypto_gcmp_decrypt(struct ieee80211_rx_data *rx)\r\n{\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)rx->skb->data;\r\nint hdrlen;\r\nstruct ieee80211_key *key = rx->key;\r\nstruct sk_buff *skb = rx->skb;\r\nstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\r\nu8 pn[IEEE80211_GCMP_PN_LEN];\r\nint data_len, queue, mic_len = IEEE80211_GCMP_MIC_LEN;\r\nhdrlen = ieee80211_hdrlen(hdr->frame_control);\r\nif (!ieee80211_is_data(hdr->frame_control) &&\r\n!ieee80211_is_robust_mgmt_frame(skb))\r\nreturn RX_CONTINUE;\r\nif (status->flag & RX_FLAG_DECRYPTED) {\r\nif (!pskb_may_pull(rx->skb, hdrlen + IEEE80211_GCMP_HDR_LEN))\r\nreturn RX_DROP_UNUSABLE;\r\nif (status->flag & RX_FLAG_MIC_STRIPPED)\r\nmic_len = 0;\r\n} else {\r\nif (skb_linearize(rx->skb))\r\nreturn RX_DROP_UNUSABLE;\r\n}\r\ndata_len = skb->len - hdrlen - IEEE80211_GCMP_HDR_LEN - mic_len;\r\nif (!rx->sta || data_len < 0)\r\nreturn RX_DROP_UNUSABLE;\r\nif (!(status->flag & RX_FLAG_PN_VALIDATED)) {\r\nint res;\r\ngcmp_hdr2pn(pn, skb->data + hdrlen);\r\nqueue = rx->security_idx;\r\nres = memcmp(pn, key->u.gcmp.rx_pn[queue],\r\nIEEE80211_GCMP_PN_LEN);\r\nif (res < 0 ||\r\n(!res && !(status->flag & RX_FLAG_ALLOW_SAME_PN))) {\r\nkey->u.gcmp.replays++;\r\nreturn RX_DROP_UNUSABLE;\r\n}\r\nif (!(status->flag & RX_FLAG_DECRYPTED)) {\r\nu8 aad[2 * AES_BLOCK_SIZE];\r\nu8 j_0[AES_BLOCK_SIZE];\r\ngcmp_special_blocks(skb, pn, j_0, aad);\r\nif (ieee80211_aes_gcm_decrypt(\r\nkey->u.gcmp.tfm, j_0, aad,\r\nskb->data + hdrlen + IEEE80211_GCMP_HDR_LEN,\r\ndata_len,\r\nskb->data + skb->len -\r\nIEEE80211_GCMP_MIC_LEN))\r\nreturn RX_DROP_UNUSABLE;\r\n}\r\nmemcpy(key->u.gcmp.rx_pn[queue], pn, IEEE80211_GCMP_PN_LEN);\r\n}\r\nif (pskb_trim(skb, skb->len - mic_len))\r\nreturn RX_DROP_UNUSABLE;\r\nmemmove(skb->data + IEEE80211_GCMP_HDR_LEN, skb->data, hdrlen);\r\nskb_pull(skb, IEEE80211_GCMP_HDR_LEN);\r\nreturn RX_CONTINUE;\r\n}\r\nstatic ieee80211_tx_result\r\nieee80211_crypto_cs_encrypt(struct ieee80211_tx_data *tx,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\r\nstruct ieee80211_key *key = tx->key;\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nint hdrlen;\r\nu8 *pos, iv_len = key->conf.iv_len;\r\nif (info->control.hw_key &&\r\n!(info->control.hw_key->flags & IEEE80211_KEY_FLAG_PUT_IV_SPACE)) {\r\nreturn TX_CONTINUE;\r\n}\r\nif (unlikely(skb_headroom(skb) < iv_len &&\r\npskb_expand_head(skb, iv_len, 0, GFP_ATOMIC)))\r\nreturn TX_DROP;\r\nhdrlen = ieee80211_hdrlen(hdr->frame_control);\r\npos = skb_push(skb, iv_len);\r\nmemmove(pos, pos + iv_len, hdrlen);\r\nreturn TX_CONTINUE;\r\n}\r\nstatic inline int ieee80211_crypto_cs_pn_compare(u8 *pn1, u8 *pn2, int len)\r\n{\r\nint i;\r\nfor (i = len - 1; i >= 0; i--) {\r\nif (pn1[i] < pn2[i])\r\nreturn -1;\r\nelse if (pn1[i] > pn2[i])\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic ieee80211_rx_result\r\nieee80211_crypto_cs_decrypt(struct ieee80211_rx_data *rx)\r\n{\r\nstruct ieee80211_key *key = rx->key;\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)rx->skb->data;\r\nconst struct ieee80211_cipher_scheme *cs = NULL;\r\nint hdrlen = ieee80211_hdrlen(hdr->frame_control);\r\nstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(rx->skb);\r\nint data_len;\r\nu8 *rx_pn;\r\nu8 *skb_pn;\r\nu8 qos_tid;\r\nif (!rx->sta || !rx->sta->cipher_scheme ||\r\n!(status->flag & RX_FLAG_DECRYPTED))\r\nreturn RX_DROP_UNUSABLE;\r\nif (!ieee80211_is_data(hdr->frame_control))\r\nreturn RX_CONTINUE;\r\ncs = rx->sta->cipher_scheme;\r\ndata_len = rx->skb->len - hdrlen - cs->hdr_len;\r\nif (data_len < 0)\r\nreturn RX_DROP_UNUSABLE;\r\nif (ieee80211_is_data_qos(hdr->frame_control))\r\nqos_tid = *ieee80211_get_qos_ctl(hdr) &\r\nIEEE80211_QOS_CTL_TID_MASK;\r\nelse\r\nqos_tid = 0;\r\nif (skb_linearize(rx->skb))\r\nreturn RX_DROP_UNUSABLE;\r\nhdr = (struct ieee80211_hdr *)rx->skb->data;\r\nrx_pn = key->u.gen.rx_pn[qos_tid];\r\nskb_pn = rx->skb->data + hdrlen + cs->pn_off;\r\nif (ieee80211_crypto_cs_pn_compare(skb_pn, rx_pn, cs->pn_len) <= 0)\r\nreturn RX_DROP_UNUSABLE;\r\nmemcpy(rx_pn, skb_pn, cs->pn_len);\r\nif (pskb_trim(rx->skb, rx->skb->len - cs->mic_len))\r\nreturn RX_DROP_UNUSABLE;\r\nmemmove(rx->skb->data + cs->hdr_len, rx->skb->data, hdrlen);\r\nskb_pull(rx->skb, cs->hdr_len);\r\nreturn RX_CONTINUE;\r\n}\r\nstatic void bip_aad(struct sk_buff *skb, u8 *aad)\r\n{\r\n__le16 mask_fc;\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\r\nmask_fc = hdr->frame_control;\r\nmask_fc &= ~cpu_to_le16(IEEE80211_FCTL_RETRY | IEEE80211_FCTL_PM |\r\nIEEE80211_FCTL_MOREDATA);\r\nput_unaligned(mask_fc, (__le16 *) &aad[0]);\r\nmemcpy(aad + 2, &hdr->addr1, 3 * ETH_ALEN);\r\n}\r\nstatic inline void bip_ipn_set64(u8 *d, u64 pn)\r\n{\r\n*d++ = pn;\r\n*d++ = pn >> 8;\r\n*d++ = pn >> 16;\r\n*d++ = pn >> 24;\r\n*d++ = pn >> 32;\r\n*d = pn >> 40;\r\n}\r\nstatic inline void bip_ipn_swap(u8 *d, const u8 *s)\r\n{\r\n*d++ = s[5];\r\n*d++ = s[4];\r\n*d++ = s[3];\r\n*d++ = s[2];\r\n*d++ = s[1];\r\n*d = s[0];\r\n}\r\nieee80211_tx_result\r\nieee80211_crypto_aes_cmac_encrypt(struct ieee80211_tx_data *tx)\r\n{\r\nstruct sk_buff *skb;\r\nstruct ieee80211_tx_info *info;\r\nstruct ieee80211_key *key = tx->key;\r\nstruct ieee80211_mmie *mmie;\r\nu8 aad[20];\r\nu64 pn64;\r\nif (WARN_ON(skb_queue_len(&tx->skbs) != 1))\r\nreturn TX_DROP;\r\nskb = skb_peek(&tx->skbs);\r\ninfo = IEEE80211_SKB_CB(skb);\r\nif (info->control.hw_key)\r\nreturn TX_CONTINUE;\r\nif (WARN_ON(skb_tailroom(skb) < sizeof(*mmie)))\r\nreturn TX_DROP;\r\nmmie = skb_put(skb, sizeof(*mmie));\r\nmmie->element_id = WLAN_EID_MMIE;\r\nmmie->length = sizeof(*mmie) - 2;\r\nmmie->key_id = cpu_to_le16(key->conf.keyidx);\r\npn64 = atomic64_inc_return(&key->conf.tx_pn);\r\nbip_ipn_set64(mmie->sequence_number, pn64);\r\nbip_aad(skb, aad);\r\nieee80211_aes_cmac(key->u.aes_cmac.tfm, aad,\r\nskb->data + 24, skb->len - 24, mmie->mic);\r\nreturn TX_CONTINUE;\r\n}\r\nieee80211_tx_result\r\nieee80211_crypto_aes_cmac_256_encrypt(struct ieee80211_tx_data *tx)\r\n{\r\nstruct sk_buff *skb;\r\nstruct ieee80211_tx_info *info;\r\nstruct ieee80211_key *key = tx->key;\r\nstruct ieee80211_mmie_16 *mmie;\r\nu8 aad[20];\r\nu64 pn64;\r\nif (WARN_ON(skb_queue_len(&tx->skbs) != 1))\r\nreturn TX_DROP;\r\nskb = skb_peek(&tx->skbs);\r\ninfo = IEEE80211_SKB_CB(skb);\r\nif (info->control.hw_key)\r\nreturn TX_CONTINUE;\r\nif (WARN_ON(skb_tailroom(skb) < sizeof(*mmie)))\r\nreturn TX_DROP;\r\nmmie = skb_put(skb, sizeof(*mmie));\r\nmmie->element_id = WLAN_EID_MMIE;\r\nmmie->length = sizeof(*mmie) - 2;\r\nmmie->key_id = cpu_to_le16(key->conf.keyidx);\r\npn64 = atomic64_inc_return(&key->conf.tx_pn);\r\nbip_ipn_set64(mmie->sequence_number, pn64);\r\nbip_aad(skb, aad);\r\nieee80211_aes_cmac_256(key->u.aes_cmac.tfm, aad,\r\nskb->data + 24, skb->len - 24, mmie->mic);\r\nreturn TX_CONTINUE;\r\n}\r\nieee80211_rx_result\r\nieee80211_crypto_aes_cmac_decrypt(struct ieee80211_rx_data *rx)\r\n{\r\nstruct sk_buff *skb = rx->skb;\r\nstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\r\nstruct ieee80211_key *key = rx->key;\r\nstruct ieee80211_mmie *mmie;\r\nu8 aad[20], mic[8], ipn[6];\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\r\nif (!ieee80211_is_mgmt(hdr->frame_control))\r\nreturn RX_CONTINUE;\r\nif (skb->len < 24 + sizeof(*mmie))\r\nreturn RX_DROP_UNUSABLE;\r\nmmie = (struct ieee80211_mmie *)\r\n(skb->data + skb->len - sizeof(*mmie));\r\nif (mmie->element_id != WLAN_EID_MMIE ||\r\nmmie->length != sizeof(*mmie) - 2)\r\nreturn RX_DROP_UNUSABLE;\r\nbip_ipn_swap(ipn, mmie->sequence_number);\r\nif (memcmp(ipn, key->u.aes_cmac.rx_pn, 6) <= 0) {\r\nkey->u.aes_cmac.replays++;\r\nreturn RX_DROP_UNUSABLE;\r\n}\r\nif (!(status->flag & RX_FLAG_DECRYPTED)) {\r\nbip_aad(skb, aad);\r\nieee80211_aes_cmac(key->u.aes_cmac.tfm, aad,\r\nskb->data + 24, skb->len - 24, mic);\r\nif (crypto_memneq(mic, mmie->mic, sizeof(mmie->mic))) {\r\nkey->u.aes_cmac.icverrors++;\r\nreturn RX_DROP_UNUSABLE;\r\n}\r\n}\r\nmemcpy(key->u.aes_cmac.rx_pn, ipn, 6);\r\nskb_trim(skb, skb->len - sizeof(*mmie));\r\nreturn RX_CONTINUE;\r\n}\r\nieee80211_rx_result\r\nieee80211_crypto_aes_cmac_256_decrypt(struct ieee80211_rx_data *rx)\r\n{\r\nstruct sk_buff *skb = rx->skb;\r\nstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\r\nstruct ieee80211_key *key = rx->key;\r\nstruct ieee80211_mmie_16 *mmie;\r\nu8 aad[20], mic[16], ipn[6];\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\r\nif (!ieee80211_is_mgmt(hdr->frame_control))\r\nreturn RX_CONTINUE;\r\nif (skb->len < 24 + sizeof(*mmie))\r\nreturn RX_DROP_UNUSABLE;\r\nmmie = (struct ieee80211_mmie_16 *)\r\n(skb->data + skb->len - sizeof(*mmie));\r\nif (mmie->element_id != WLAN_EID_MMIE ||\r\nmmie->length != sizeof(*mmie) - 2)\r\nreturn RX_DROP_UNUSABLE;\r\nbip_ipn_swap(ipn, mmie->sequence_number);\r\nif (memcmp(ipn, key->u.aes_cmac.rx_pn, 6) <= 0) {\r\nkey->u.aes_cmac.replays++;\r\nreturn RX_DROP_UNUSABLE;\r\n}\r\nif (!(status->flag & RX_FLAG_DECRYPTED)) {\r\nbip_aad(skb, aad);\r\nieee80211_aes_cmac_256(key->u.aes_cmac.tfm, aad,\r\nskb->data + 24, skb->len - 24, mic);\r\nif (crypto_memneq(mic, mmie->mic, sizeof(mmie->mic))) {\r\nkey->u.aes_cmac.icverrors++;\r\nreturn RX_DROP_UNUSABLE;\r\n}\r\n}\r\nmemcpy(key->u.aes_cmac.rx_pn, ipn, 6);\r\nskb_trim(skb, skb->len - sizeof(*mmie));\r\nreturn RX_CONTINUE;\r\n}\r\nieee80211_tx_result\r\nieee80211_crypto_aes_gmac_encrypt(struct ieee80211_tx_data *tx)\r\n{\r\nstruct sk_buff *skb;\r\nstruct ieee80211_tx_info *info;\r\nstruct ieee80211_key *key = tx->key;\r\nstruct ieee80211_mmie_16 *mmie;\r\nstruct ieee80211_hdr *hdr;\r\nu8 aad[GMAC_AAD_LEN];\r\nu64 pn64;\r\nu8 nonce[GMAC_NONCE_LEN];\r\nif (WARN_ON(skb_queue_len(&tx->skbs) != 1))\r\nreturn TX_DROP;\r\nskb = skb_peek(&tx->skbs);\r\ninfo = IEEE80211_SKB_CB(skb);\r\nif (info->control.hw_key)\r\nreturn TX_CONTINUE;\r\nif (WARN_ON(skb_tailroom(skb) < sizeof(*mmie)))\r\nreturn TX_DROP;\r\nmmie = skb_put(skb, sizeof(*mmie));\r\nmmie->element_id = WLAN_EID_MMIE;\r\nmmie->length = sizeof(*mmie) - 2;\r\nmmie->key_id = cpu_to_le16(key->conf.keyidx);\r\npn64 = atomic64_inc_return(&key->conf.tx_pn);\r\nbip_ipn_set64(mmie->sequence_number, pn64);\r\nbip_aad(skb, aad);\r\nhdr = (struct ieee80211_hdr *)skb->data;\r\nmemcpy(nonce, hdr->addr2, ETH_ALEN);\r\nbip_ipn_swap(nonce + ETH_ALEN, mmie->sequence_number);\r\nif (ieee80211_aes_gmac(key->u.aes_gmac.tfm, aad, nonce,\r\nskb->data + 24, skb->len - 24, mmie->mic) < 0)\r\nreturn TX_DROP;\r\nreturn TX_CONTINUE;\r\n}\r\nieee80211_rx_result\r\nieee80211_crypto_aes_gmac_decrypt(struct ieee80211_rx_data *rx)\r\n{\r\nstruct sk_buff *skb = rx->skb;\r\nstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\r\nstruct ieee80211_key *key = rx->key;\r\nstruct ieee80211_mmie_16 *mmie;\r\nu8 aad[GMAC_AAD_LEN], mic[GMAC_MIC_LEN], ipn[6], nonce[GMAC_NONCE_LEN];\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\r\nif (!ieee80211_is_mgmt(hdr->frame_control))\r\nreturn RX_CONTINUE;\r\nif (skb->len < 24 + sizeof(*mmie))\r\nreturn RX_DROP_UNUSABLE;\r\nmmie = (struct ieee80211_mmie_16 *)\r\n(skb->data + skb->len - sizeof(*mmie));\r\nif (mmie->element_id != WLAN_EID_MMIE ||\r\nmmie->length != sizeof(*mmie) - 2)\r\nreturn RX_DROP_UNUSABLE;\r\nbip_ipn_swap(ipn, mmie->sequence_number);\r\nif (memcmp(ipn, key->u.aes_gmac.rx_pn, 6) <= 0) {\r\nkey->u.aes_gmac.replays++;\r\nreturn RX_DROP_UNUSABLE;\r\n}\r\nif (!(status->flag & RX_FLAG_DECRYPTED)) {\r\nbip_aad(skb, aad);\r\nmemcpy(nonce, hdr->addr2, ETH_ALEN);\r\nmemcpy(nonce + ETH_ALEN, ipn, 6);\r\nif (ieee80211_aes_gmac(key->u.aes_gmac.tfm, aad, nonce,\r\nskb->data + 24, skb->len - 24,\r\nmic) < 0 ||\r\ncrypto_memneq(mic, mmie->mic, sizeof(mmie->mic))) {\r\nkey->u.aes_gmac.icverrors++;\r\nreturn RX_DROP_UNUSABLE;\r\n}\r\n}\r\nmemcpy(key->u.aes_gmac.rx_pn, ipn, 6);\r\nskb_trim(skb, skb->len - sizeof(*mmie));\r\nreturn RX_CONTINUE;\r\n}\r\nieee80211_tx_result\r\nieee80211_crypto_hw_encrypt(struct ieee80211_tx_data *tx)\r\n{\r\nstruct sk_buff *skb;\r\nstruct ieee80211_tx_info *info = NULL;\r\nieee80211_tx_result res;\r\nskb_queue_walk(&tx->skbs, skb) {\r\ninfo = IEEE80211_SKB_CB(skb);\r\nif (!info->control.hw_key)\r\nreturn TX_DROP;\r\nif (tx->key->flags & KEY_FLAG_CIPHER_SCHEME) {\r\nres = ieee80211_crypto_cs_encrypt(tx, skb);\r\nif (res != TX_CONTINUE)\r\nreturn res;\r\n}\r\n}\r\nieee80211_tx_set_protected(tx);\r\nreturn TX_CONTINUE;\r\n}\r\nieee80211_rx_result\r\nieee80211_crypto_hw_decrypt(struct ieee80211_rx_data *rx)\r\n{\r\nif (rx->sta && rx->sta->cipher_scheme)\r\nreturn ieee80211_crypto_cs_decrypt(rx);\r\nreturn RX_DROP_UNUSABLE;\r\n}
