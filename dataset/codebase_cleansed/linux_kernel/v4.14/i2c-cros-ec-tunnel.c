static int ec_i2c_count_message(const struct i2c_msg i2c_msgs[], int num)\r\n{\r\nint i;\r\nint size;\r\nsize = sizeof(struct ec_params_i2c_passthru);\r\nsize += num * sizeof(struct ec_params_i2c_passthru_msg);\r\nfor (i = 0; i < num; i++)\r\nif (!(i2c_msgs[i].flags & I2C_M_RD))\r\nsize += i2c_msgs[i].len;\r\nreturn size;\r\n}\r\nstatic int ec_i2c_construct_message(u8 *buf, const struct i2c_msg i2c_msgs[],\r\nint num, u16 bus_num)\r\n{\r\nstruct ec_params_i2c_passthru *params;\r\nu8 *out_data;\r\nint i;\r\nout_data = buf + sizeof(struct ec_params_i2c_passthru) +\r\nnum * sizeof(struct ec_params_i2c_passthru_msg);\r\nparams = (struct ec_params_i2c_passthru *)buf;\r\nparams->port = bus_num;\r\nparams->num_msgs = num;\r\nfor (i = 0; i < num; i++) {\r\nconst struct i2c_msg *i2c_msg = &i2c_msgs[i];\r\nstruct ec_params_i2c_passthru_msg *msg = &params->msg[i];\r\nmsg->len = i2c_msg->len;\r\nmsg->addr_flags = i2c_msg->addr;\r\nif (i2c_msg->flags & I2C_M_TEN)\r\nreturn -EINVAL;\r\nif (i2c_msg->flags & I2C_M_RD) {\r\nmsg->addr_flags |= EC_I2C_FLAG_READ;\r\n} else {\r\nmemcpy(out_data, i2c_msg->buf, msg->len);\r\nout_data += msg->len;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ec_i2c_count_response(struct i2c_msg i2c_msgs[], int num)\r\n{\r\nint size;\r\nint i;\r\nsize = sizeof(struct ec_response_i2c_passthru);\r\nfor (i = 0; i < num; i++)\r\nif (i2c_msgs[i].flags & I2C_M_RD)\r\nsize += i2c_msgs[i].len;\r\nreturn size;\r\n}\r\nstatic int ec_i2c_parse_response(const u8 *buf, struct i2c_msg i2c_msgs[],\r\nint *num)\r\n{\r\nconst struct ec_response_i2c_passthru *resp;\r\nconst u8 *in_data;\r\nint i;\r\nin_data = buf + sizeof(struct ec_response_i2c_passthru);\r\nresp = (const struct ec_response_i2c_passthru *)buf;\r\nif (resp->i2c_status & EC_I2C_STATUS_TIMEOUT)\r\nreturn -ETIMEDOUT;\r\nelse if (resp->i2c_status & EC_I2C_STATUS_NAK)\r\nreturn -ENXIO;\r\nelse if (resp->i2c_status & EC_I2C_STATUS_ERROR)\r\nreturn -EIO;\r\nif (resp->num_msgs > *num)\r\nreturn -EPROTO;\r\n*num = resp->num_msgs;\r\nfor (i = 0; i < *num; i++) {\r\nstruct i2c_msg *i2c_msg = &i2c_msgs[i];\r\nif (i2c_msgs[i].flags & I2C_M_RD) {\r\nmemcpy(i2c_msg->buf, in_data, i2c_msg->len);\r\nin_data += i2c_msg->len;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ec_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg i2c_msgs[],\r\nint num)\r\n{\r\nstruct ec_i2c_device *bus = adap->algo_data;\r\nstruct device *dev = bus->dev;\r\nconst u16 bus_num = bus->remote_bus;\r\nint request_len;\r\nint response_len;\r\nint alloc_size;\r\nint result;\r\nstruct cros_ec_command *msg;\r\nrequest_len = ec_i2c_count_message(i2c_msgs, num);\r\nif (request_len < 0) {\r\ndev_warn(dev, "Error constructing message %d\n", request_len);\r\nreturn request_len;\r\n}\r\nresponse_len = ec_i2c_count_response(i2c_msgs, num);\r\nif (response_len < 0) {\r\ndev_warn(dev, "Error preparing response %d\n", response_len);\r\nreturn response_len;\r\n}\r\nalloc_size = max(request_len, response_len);\r\nmsg = kmalloc(sizeof(*msg) + alloc_size, GFP_KERNEL);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nresult = ec_i2c_construct_message(msg->data, i2c_msgs, num, bus_num);\r\nif (result) {\r\ndev_err(dev, "Error constructing EC i2c message %d\n", result);\r\ngoto exit;\r\n}\r\nmsg->version = 0;\r\nmsg->command = EC_CMD_I2C_PASSTHRU;\r\nmsg->outsize = request_len;\r\nmsg->insize = response_len;\r\nresult = cros_ec_cmd_xfer_status(bus->ec, msg);\r\nif (result < 0) {\r\ndev_err(dev, "Error transferring EC i2c message %d\n", result);\r\ngoto exit;\r\n}\r\nresult = ec_i2c_parse_response(msg->data, i2c_msgs, &num);\r\nif (result < 0)\r\ngoto exit;\r\nresult = num;\r\nexit:\r\nkfree(msg);\r\nreturn result;\r\n}\r\nstatic u32 ec_i2c_functionality(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\r\n}\r\nstatic int ec_i2c_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct cros_ec_device *ec = dev_get_drvdata(pdev->dev.parent);\r\nstruct device *dev = &pdev->dev;\r\nstruct ec_i2c_device *bus = NULL;\r\nu32 remote_bus;\r\nint err;\r\nif (!ec->cmd_xfer) {\r\ndev_err(dev, "Missing sendrecv\n");\r\nreturn -EINVAL;\r\n}\r\nbus = devm_kzalloc(dev, sizeof(*bus), GFP_KERNEL);\r\nif (bus == NULL)\r\nreturn -ENOMEM;\r\nerr = of_property_read_u32(np, "google,remote-bus", &remote_bus);\r\nif (err) {\r\ndev_err(dev, "Couldn't read remote-bus property\n");\r\nreturn err;\r\n}\r\nbus->remote_bus = remote_bus;\r\nbus->ec = ec;\r\nbus->dev = dev;\r\nbus->adap.owner = THIS_MODULE;\r\nstrlcpy(bus->adap.name, "cros-ec-i2c-tunnel", sizeof(bus->adap.name));\r\nbus->adap.algo = &ec_i2c_algorithm;\r\nbus->adap.algo_data = bus;\r\nbus->adap.dev.parent = &pdev->dev;\r\nbus->adap.dev.of_node = np;\r\nbus->adap.retries = I2C_MAX_RETRIES;\r\nerr = i2c_add_adapter(&bus->adap);\r\nif (err)\r\nreturn err;\r\nplatform_set_drvdata(pdev, bus);\r\nreturn err;\r\n}\r\nstatic int ec_i2c_remove(struct platform_device *dev)\r\n{\r\nstruct ec_i2c_device *bus = platform_get_drvdata(dev);\r\ni2c_del_adapter(&bus->adap);\r\nreturn 0;\r\n}
