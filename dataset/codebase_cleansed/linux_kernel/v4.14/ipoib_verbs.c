int ipoib_mcast_attach(struct net_device *dev, struct ib_device *hca,\r\nunion ib_gid *mgid, u16 mlid, int set_qkey, u32 qkey)\r\n{\r\nstruct ipoib_dev_priv *priv = ipoib_priv(dev);\r\nstruct ib_qp_attr *qp_attr = NULL;\r\nint ret;\r\nu16 pkey_index;\r\nif (ib_find_pkey(priv->ca, priv->port, priv->pkey, &pkey_index)) {\r\nclear_bit(IPOIB_PKEY_ASSIGNED, &priv->flags);\r\nret = -ENXIO;\r\ngoto out;\r\n}\r\nset_bit(IPOIB_PKEY_ASSIGNED, &priv->flags);\r\nif (set_qkey) {\r\nret = -ENOMEM;\r\nqp_attr = kmalloc(sizeof *qp_attr, GFP_KERNEL);\r\nif (!qp_attr)\r\ngoto out;\r\nqp_attr->qkey = qkey;\r\nret = ib_modify_qp(priv->qp, qp_attr, IB_QP_QKEY);\r\nif (ret) {\r\nipoib_warn(priv, "failed to modify QP, ret = %d\n", ret);\r\ngoto out;\r\n}\r\n}\r\nret = ib_attach_mcast(priv->qp, mgid, mlid);\r\nif (ret)\r\nipoib_warn(priv, "failed to attach to multicast group, ret = %d\n", ret);\r\nout:\r\nkfree(qp_attr);\r\nreturn ret;\r\n}\r\nint ipoib_mcast_detach(struct net_device *dev, struct ib_device *hca,\r\nunion ib_gid *mgid, u16 mlid)\r\n{\r\nstruct ipoib_dev_priv *priv = ipoib_priv(dev);\r\nint ret;\r\nret = ib_detach_mcast(priv->qp, mgid, mlid);\r\nreturn ret;\r\n}\r\nint ipoib_init_qp(struct net_device *dev)\r\n{\r\nstruct ipoib_dev_priv *priv = ipoib_priv(dev);\r\nint ret;\r\nstruct ib_qp_attr qp_attr;\r\nint attr_mask;\r\nif (!test_bit(IPOIB_PKEY_ASSIGNED, &priv->flags))\r\nreturn -1;\r\nqp_attr.qp_state = IB_QPS_INIT;\r\nqp_attr.qkey = 0;\r\nqp_attr.port_num = priv->port;\r\nqp_attr.pkey_index = priv->pkey_index;\r\nattr_mask =\r\nIB_QP_QKEY |\r\nIB_QP_PORT |\r\nIB_QP_PKEY_INDEX |\r\nIB_QP_STATE;\r\nret = ib_modify_qp(priv->qp, &qp_attr, attr_mask);\r\nif (ret) {\r\nipoib_warn(priv, "failed to modify QP to init, ret = %d\n", ret);\r\ngoto out_fail;\r\n}\r\nqp_attr.qp_state = IB_QPS_RTR;\r\nattr_mask &= ~IB_QP_PORT;\r\nret = ib_modify_qp(priv->qp, &qp_attr, attr_mask);\r\nif (ret) {\r\nipoib_warn(priv, "failed to modify QP to RTR, ret = %d\n", ret);\r\ngoto out_fail;\r\n}\r\nqp_attr.qp_state = IB_QPS_RTS;\r\nqp_attr.sq_psn = 0;\r\nattr_mask |= IB_QP_SQ_PSN;\r\nattr_mask &= ~IB_QP_PKEY_INDEX;\r\nret = ib_modify_qp(priv->qp, &qp_attr, attr_mask);\r\nif (ret) {\r\nipoib_warn(priv, "failed to modify QP to RTS, ret = %d\n", ret);\r\ngoto out_fail;\r\n}\r\nreturn 0;\r\nout_fail:\r\nqp_attr.qp_state = IB_QPS_RESET;\r\nif (ib_modify_qp(priv->qp, &qp_attr, IB_QP_STATE))\r\nipoib_warn(priv, "Failed to modify QP to RESET state\n");\r\nreturn ret;\r\n}\r\nint ipoib_transport_dev_init(struct net_device *dev, struct ib_device *ca)\r\n{\r\nstruct ipoib_dev_priv *priv = ipoib_priv(dev);\r\nstruct ib_qp_init_attr init_attr = {\r\n.cap = {\r\n.max_send_wr = ipoib_sendq_size,\r\n.max_recv_wr = ipoib_recvq_size,\r\n.max_send_sge = min_t(u32, priv->ca->attrs.max_sge,\r\nMAX_SKB_FRAGS + 1),\r\n.max_recv_sge = IPOIB_UD_RX_SG\r\n},\r\n.sq_sig_type = IB_SIGNAL_ALL_WR,\r\n.qp_type = IB_QPT_UD\r\n};\r\nstruct ib_cq_init_attr cq_attr = {};\r\nint ret, size;\r\nint i;\r\nsize = ipoib_recvq_size + 1;\r\nret = ipoib_cm_dev_init(dev);\r\nif (!ret) {\r\nsize += ipoib_sendq_size;\r\nif (ipoib_cm_has_srq(dev))\r\nsize += ipoib_recvq_size + 1;\r\nelse\r\nsize += ipoib_recvq_size * ipoib_max_conn_qp;\r\n} else\r\nif (ret != -ENOSYS)\r\nreturn -ENODEV;\r\ncq_attr.cqe = size;\r\npriv->recv_cq = ib_create_cq(priv->ca, ipoib_ib_completion, NULL,\r\ndev, &cq_attr);\r\nif (IS_ERR(priv->recv_cq)) {\r\nprintk(KERN_WARNING "%s: failed to create receive CQ\n", ca->name);\r\ngoto out_cm_dev_cleanup;\r\n}\r\ncq_attr.cqe = ipoib_sendq_size;\r\npriv->send_cq = ib_create_cq(priv->ca, ipoib_send_comp_handler, NULL,\r\ndev, &cq_attr);\r\nif (IS_ERR(priv->send_cq)) {\r\nprintk(KERN_WARNING "%s: failed to create send CQ\n", ca->name);\r\ngoto out_free_recv_cq;\r\n}\r\nif (ib_req_notify_cq(priv->recv_cq, IB_CQ_NEXT_COMP))\r\ngoto out_free_send_cq;\r\ninit_attr.send_cq = priv->send_cq;\r\ninit_attr.recv_cq = priv->recv_cq;\r\nif (priv->hca_caps & IB_DEVICE_UD_TSO)\r\ninit_attr.create_flags |= IB_QP_CREATE_IPOIB_UD_LSO;\r\nif (priv->hca_caps & IB_DEVICE_BLOCK_MULTICAST_LOOPBACK)\r\ninit_attr.create_flags |= IB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK;\r\nif (priv->hca_caps & IB_DEVICE_MANAGED_FLOW_STEERING)\r\ninit_attr.create_flags |= IB_QP_CREATE_NETIF_QP;\r\npriv->qp = ib_create_qp(priv->pd, &init_attr);\r\nif (IS_ERR(priv->qp)) {\r\nprintk(KERN_WARNING "%s: failed to create QP\n", ca->name);\r\ngoto out_free_send_cq;\r\n}\r\nfor (i = 0; i < MAX_SKB_FRAGS + 1; ++i)\r\npriv->tx_sge[i].lkey = priv->pd->local_dma_lkey;\r\npriv->tx_wr.wr.opcode = IB_WR_SEND;\r\npriv->tx_wr.wr.sg_list = priv->tx_sge;\r\npriv->tx_wr.wr.send_flags = IB_SEND_SIGNALED;\r\npriv->rx_sge[0].lkey = priv->pd->local_dma_lkey;\r\npriv->rx_sge[0].length = IPOIB_UD_BUF_SIZE(priv->max_ib_mtu);\r\npriv->rx_wr.num_sge = 1;\r\npriv->rx_wr.next = NULL;\r\npriv->rx_wr.sg_list = priv->rx_sge;\r\nif (init_attr.cap.max_send_sge > 1)\r\ndev->features |= NETIF_F_SG;\r\npriv->max_send_sge = init_attr.cap.max_send_sge;\r\nreturn 0;\r\nout_free_send_cq:\r\nib_destroy_cq(priv->send_cq);\r\nout_free_recv_cq:\r\nib_destroy_cq(priv->recv_cq);\r\nout_cm_dev_cleanup:\r\nipoib_cm_dev_cleanup(dev);\r\nreturn -ENODEV;\r\n}\r\nvoid ipoib_transport_dev_cleanup(struct net_device *dev)\r\n{\r\nstruct ipoib_dev_priv *priv = ipoib_priv(dev);\r\nif (priv->qp) {\r\nif (ib_destroy_qp(priv->qp))\r\nipoib_warn(priv, "ib_qp_destroy failed\n");\r\npriv->qp = NULL;\r\n}\r\nif (ib_destroy_cq(priv->send_cq))\r\nipoib_warn(priv, "ib_cq_destroy (send) failed\n");\r\nif (ib_destroy_cq(priv->recv_cq))\r\nipoib_warn(priv, "ib_cq_destroy (recv) failed\n");\r\n}\r\nvoid ipoib_event(struct ib_event_handler *handler,\r\nstruct ib_event *record)\r\n{\r\nstruct ipoib_dev_priv *priv =\r\ncontainer_of(handler, struct ipoib_dev_priv, event_handler);\r\nif (record->element.port_num != priv->port)\r\nreturn;\r\nipoib_dbg(priv, "Event %d on device %s port %d\n", record->event,\r\nrecord->device->name, record->element.port_num);\r\nif (record->event == IB_EVENT_SM_CHANGE ||\r\nrecord->event == IB_EVENT_CLIENT_REREGISTER) {\r\nqueue_work(ipoib_workqueue, &priv->flush_light);\r\n} else if (record->event == IB_EVENT_PORT_ERR ||\r\nrecord->event == IB_EVENT_PORT_ACTIVE ||\r\nrecord->event == IB_EVENT_LID_CHANGE) {\r\nqueue_work(ipoib_workqueue, &priv->flush_normal);\r\n} else if (record->event == IB_EVENT_PKEY_CHANGE) {\r\nqueue_work(ipoib_workqueue, &priv->flush_heavy);\r\n} else if (record->event == IB_EVENT_GID_CHANGE &&\r\n!test_bit(IPOIB_FLAG_DEV_ADDR_SET, &priv->flags)) {\r\nqueue_work(ipoib_workqueue, &priv->flush_light);\r\n}\r\n}
