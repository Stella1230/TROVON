static int debugfs_log_show(struct seq_file *f, void *offset)\r\n{\r\nint *levp = f->private;\r\nchar *log_value = NULL;\r\nswitch (*levp) {\r\ncase VCHIQ_LOG_ERROR:\r\nlog_value = VCHIQ_LOG_ERROR_STR;\r\nbreak;\r\ncase VCHIQ_LOG_WARNING:\r\nlog_value = VCHIQ_LOG_WARNING_STR;\r\nbreak;\r\ncase VCHIQ_LOG_INFO:\r\nlog_value = VCHIQ_LOG_INFO_STR;\r\nbreak;\r\ncase VCHIQ_LOG_TRACE:\r\nlog_value = VCHIQ_LOG_TRACE_STR;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nseq_printf(f, "%s\n", log_value ? log_value : "(null)");\r\nreturn 0;\r\n}\r\nstatic int debugfs_log_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, debugfs_log_show, inode->i_private);\r\n}\r\nstatic ssize_t debugfs_log_write(struct file *file,\r\nconst char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct seq_file *f = (struct seq_file *)file->private_data;\r\nint *levp = f->private;\r\nchar kbuf[DEBUGFS_WRITE_BUF_SIZE + 1];\r\nmemset(kbuf, 0, DEBUGFS_WRITE_BUF_SIZE + 1);\r\nif (count >= DEBUGFS_WRITE_BUF_SIZE)\r\ncount = DEBUGFS_WRITE_BUF_SIZE;\r\nif (copy_from_user(kbuf, buffer, count) != 0)\r\nreturn -EFAULT;\r\nkbuf[count - 1] = 0;\r\nif (strncmp("error", kbuf, strlen("error")) == 0)\r\n*levp = VCHIQ_LOG_ERROR;\r\nelse if (strncmp("warning", kbuf, strlen("warning")) == 0)\r\n*levp = VCHIQ_LOG_WARNING;\r\nelse if (strncmp("info", kbuf, strlen("info")) == 0)\r\n*levp = VCHIQ_LOG_INFO;\r\nelse if (strncmp("trace", kbuf, strlen("trace")) == 0)\r\n*levp = VCHIQ_LOG_TRACE;\r\nelse\r\n*levp = VCHIQ_LOG_DEFAULT;\r\n*ppos += count;\r\nreturn count;\r\n}\r\nstatic int vchiq_debugfs_create_log_entries(struct dentry *top)\r\n{\r\nstruct dentry *dir;\r\nsize_t i;\r\nint ret = 0;\r\ndir = debugfs_create_dir("log", vchiq_debugfs_top());\r\nif (!dir)\r\nreturn -ENOMEM;\r\ndebugfs_info.log_categories = dir;\r\nfor (i = 0; i < n_log_entries; i++) {\r\nvoid *levp = (void *)vchiq_debugfs_log_entries[i].plevel;\r\ndir = debugfs_create_file(vchiq_debugfs_log_entries[i].name,\r\n0644,\r\ndebugfs_info.log_categories,\r\nlevp,\r\n&debugfs_log_fops);\r\nif (!dir) {\r\nret = -ENOMEM;\r\nbreak;\r\n}\r\nvchiq_debugfs_log_entries[i].dir = dir;\r\n}\r\nreturn ret;\r\n}\r\nstatic int debugfs_usecount_show(struct seq_file *f, void *offset)\r\n{\r\nVCHIQ_INSTANCE_T instance = f->private;\r\nint use_count;\r\nuse_count = vchiq_instance_get_use_count(instance);\r\nseq_printf(f, "%d\n", use_count);\r\nreturn 0;\r\n}\r\nstatic int debugfs_usecount_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, debugfs_usecount_show, inode->i_private);\r\n}\r\nstatic int debugfs_trace_show(struct seq_file *f, void *offset)\r\n{\r\nVCHIQ_INSTANCE_T instance = f->private;\r\nint trace;\r\ntrace = vchiq_instance_get_trace(instance);\r\nseq_printf(f, "%s\n", trace ? "Y" : "N");\r\nreturn 0;\r\n}\r\nstatic int debugfs_trace_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, debugfs_trace_show, inode->i_private);\r\n}\r\nstatic ssize_t debugfs_trace_write(struct file *file,\r\nconst char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct seq_file *f = (struct seq_file *)file->private_data;\r\nVCHIQ_INSTANCE_T instance = f->private;\r\nchar firstchar;\r\nif (copy_from_user(&firstchar, buffer, 1) != 0)\r\nreturn -EFAULT;\r\nswitch (firstchar) {\r\ncase 'Y':\r\ncase 'y':\r\ncase '1':\r\nvchiq_instance_set_trace(instance, 1);\r\nbreak;\r\ncase 'N':\r\ncase 'n':\r\ncase '0':\r\nvchiq_instance_set_trace(instance, 0);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n*ppos += count;\r\nreturn count;\r\n}\r\nint vchiq_debugfs_add_instance(VCHIQ_INSTANCE_T instance)\r\n{\r\nchar pidstr[16];\r\nstruct dentry *top, *use_count, *trace;\r\nstruct dentry *clients = vchiq_clients_top();\r\nsnprintf(pidstr, sizeof(pidstr), "%d",\r\nvchiq_instance_get_pid(instance));\r\ntop = debugfs_create_dir(pidstr, clients);\r\nif (!top)\r\ngoto fail_top;\r\nuse_count = debugfs_create_file("use_count",\r\n0444, top,\r\ninstance,\r\n&debugfs_usecount_fops);\r\nif (!use_count)\r\ngoto fail_use_count;\r\ntrace = debugfs_create_file("trace",\r\n0644, top,\r\ninstance,\r\n&debugfs_trace_fops);\r\nif (!trace)\r\ngoto fail_trace;\r\nvchiq_instance_get_debugfs_node(instance)->dentry = top;\r\nreturn 0;\r\nfail_trace:\r\ndebugfs_remove(use_count);\r\nfail_use_count:\r\ndebugfs_remove(top);\r\nfail_top:\r\nreturn -ENOMEM;\r\n}\r\nvoid vchiq_debugfs_remove_instance(VCHIQ_INSTANCE_T instance)\r\n{\r\nVCHIQ_DEBUGFS_NODE_T *node = vchiq_instance_get_debugfs_node(instance);\r\ndebugfs_remove_recursive(node->dentry);\r\n}\r\nint vchiq_debugfs_init(void)\r\n{\r\nBUG_ON(debugfs_info.vchiq_cfg_dir != NULL);\r\ndebugfs_info.vchiq_cfg_dir = debugfs_create_dir("vchiq", NULL);\r\nif (debugfs_info.vchiq_cfg_dir == NULL)\r\ngoto fail;\r\ndebugfs_info.clients = debugfs_create_dir("clients",\r\nvchiq_debugfs_top());\r\nif (!debugfs_info.clients)\r\ngoto fail;\r\nif (vchiq_debugfs_create_log_entries(vchiq_debugfs_top()) != 0)\r\ngoto fail;\r\nreturn 0;\r\nfail:\r\nvchiq_debugfs_deinit();\r\nvchiq_log_error(vchiq_arm_log_level,\r\n"%s: failed to create debugfs directory",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nvoid vchiq_debugfs_deinit(void)\r\n{\r\ndebugfs_remove_recursive(vchiq_debugfs_top());\r\n}\r\nstatic struct dentry *vchiq_clients_top(void)\r\n{\r\nreturn debugfs_info.clients;\r\n}\r\nstatic struct dentry *vchiq_debugfs_top(void)\r\n{\r\nBUG_ON(debugfs_info.vchiq_cfg_dir == NULL);\r\nreturn debugfs_info.vchiq_cfg_dir;\r\n}\r\nint vchiq_debugfs_init(void)\r\n{\r\nreturn 0;\r\n}\r\nvoid vchiq_debugfs_deinit(void)\r\n{\r\n}\r\nint vchiq_debugfs_add_instance(VCHIQ_INSTANCE_T instance)\r\n{\r\nreturn 0;\r\n}\r\nvoid vchiq_debugfs_remove_instance(VCHIQ_INSTANCE_T instance)\r\n{\r\n}
