static int da850_async3_set_parent(struct clk *clk, struct clk *parent)\r\n{\r\nu32 val;\r\nval = readl(DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP3_REG));\r\nif (parent == &pll0_sysclk2) {\r\nval &= ~CFGCHIP3_ASYNC3_CLKSRC;\r\n} else if (parent == &pll1_sysclk2) {\r\nval |= CFGCHIP3_ASYNC3_CLKSRC;\r\n} else {\r\npr_err("Bad parent on async3 clock mux\n");\r\nreturn -EINVAL;\r\n}\r\nwritel(val, DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP3_REG));\r\nreturn 0;\r\n}\r\nstatic void ehrpwm_tblck_enable(struct clk *clk)\r\n{\r\nu32 val;\r\nval = readl(DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP1_REG));\r\nval |= DA8XX_EHRPWM_TBCLKSYNC;\r\nwritel(val, DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP1_REG));\r\n}\r\nstatic void ehrpwm_tblck_disable(struct clk *clk)\r\n{\r\nu32 val;\r\nval = readl(DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP1_REG));\r\nval &= ~DA8XX_EHRPWM_TBCLKSYNC;\r\nwritel(val, DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP1_REG));\r\n}\r\nstatic int da850_set_voltage(unsigned int index)\r\n{\r\nstruct da850_opp *opp;\r\nif (!cvdd)\r\nreturn -ENODEV;\r\nopp = (struct da850_opp *) cpufreq_info.freq_table[index].driver_data;\r\nreturn regulator_set_voltage(cvdd, opp->cvdd_min, opp->cvdd_max);\r\n}\r\nstatic int da850_regulator_init(void)\r\n{\r\ncvdd = regulator_get(NULL, "cvdd");\r\nif (WARN(IS_ERR(cvdd), "Unable to obtain voltage regulator for CVDD;"\r\n" voltage scaling unsupported\n")) {\r\nreturn PTR_ERR(cvdd);\r\n}\r\nreturn 0;\r\n}\r\nint da850_register_cpufreq(char *async_clk)\r\n{\r\nint i;\r\nif (async_clk)\r\nclk_add_alias("async", da850_cpufreq_device.name,\r\nasync_clk, NULL);\r\nfor (i = 0; i < ARRAY_SIZE(da850_freq_table); i++) {\r\nif (da850_freq_table[i].frequency <= da850_max_speed) {\r\ncpufreq_info.freq_table = &da850_freq_table[i];\r\nbreak;\r\n}\r\n}\r\nreturn platform_device_register(&da850_cpufreq_device);\r\n}\r\nstatic int da850_round_armrate(struct clk *clk, unsigned long rate)\r\n{\r\nint ret = 0, diff;\r\nunsigned int best = (unsigned int) -1;\r\nstruct cpufreq_frequency_table *table = cpufreq_info.freq_table;\r\nstruct cpufreq_frequency_table *pos;\r\nrate /= 1000;\r\ncpufreq_for_each_entry(pos, table) {\r\ndiff = pos->frequency - rate;\r\nif (diff < 0)\r\ndiff = -diff;\r\nif (diff < best) {\r\nbest = diff;\r\nret = pos->frequency;\r\n}\r\n}\r\nreturn ret * 1000;\r\n}\r\nstatic int da850_set_armrate(struct clk *clk, unsigned long index)\r\n{\r\nstruct clk *pllclk = &pll0_clk;\r\nreturn clk_set_rate(pllclk, index);\r\n}\r\nstatic int da850_set_pll0rate(struct clk *clk, unsigned long rate)\r\n{\r\nstruct pll_data *pll = clk->pll_data;\r\nstruct cpufreq_frequency_table *freq;\r\nunsigned int prediv, mult, postdiv;\r\nstruct da850_opp *opp = NULL;\r\nint ret;\r\nrate /= 1000;\r\nfor (freq = da850_freq_table;\r\nfreq->frequency != CPUFREQ_TABLE_END; freq++) {\r\nif (freq->frequency == rate) {\r\nopp = (struct da850_opp *)freq->driver_data;\r\nbreak;\r\n}\r\n}\r\nif (!opp)\r\nreturn -EINVAL;\r\nprediv = opp->prediv;\r\nmult = opp->mult;\r\npostdiv = opp->postdiv;\r\nret = davinci_set_pllrate(pll, prediv, mult, postdiv);\r\nif (WARN_ON(ret))\r\nreturn ret;\r\nreturn 0;\r\n}\r\nint __init da850_register_cpufreq(char *async_clk)\r\n{\r\nreturn 0;\r\n}\r\nstatic int da850_set_armrate(struct clk *clk, unsigned long rate)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int da850_set_pll0rate(struct clk *clk, unsigned long armrate)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int da850_round_armrate(struct clk *clk, unsigned long rate)\r\n{\r\nreturn clk->rate;\r\n}\r\nint __init da850_register_vpif(void)\r\n{\r\nreturn platform_device_register(&da850_vpif_dev);\r\n}\r\nint __init da850_register_vpif_display(struct vpif_display_config\r\n*display_config)\r\n{\r\nda850_vpif_display_dev.dev.platform_data = display_config;\r\nreturn platform_device_register(&da850_vpif_display_dev);\r\n}\r\nint __init da850_register_vpif_capture(struct vpif_capture_config\r\n*capture_config)\r\n{\r\nda850_vpif_capture_dev.dev.platform_data = capture_config;\r\nreturn platform_device_register(&da850_vpif_capture_dev);\r\n}\r\nint __init da850_register_gpio(void)\r\n{\r\nreturn da8xx_register_gpio(&da850_gpio_platform_data);\r\n}\r\nvoid __init da850_init(void)\r\n{\r\nunsigned int v;\r\ndavinci_common_init(&davinci_soc_info_da850);\r\nda8xx_syscfg0_base = ioremap(DA8XX_SYSCFG0_BASE, SZ_4K);\r\nif (WARN(!da8xx_syscfg0_base, "Unable to map syscfg0 module"))\r\nreturn;\r\nda8xx_syscfg1_base = ioremap(DA8XX_SYSCFG1_BASE, SZ_4K);\r\nif (WARN(!da8xx_syscfg1_base, "Unable to map syscfg1 module"))\r\nreturn;\r\nv = __raw_readl(DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP0_REG));\r\nv &= ~CFGCHIP0_PLL_MASTER_LOCK;\r\n__raw_writel(v, DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP0_REG));\r\nv = __raw_readl(DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP3_REG));\r\nv &= ~CFGCHIP3_PLL1_MASTER_LOCK;\r\n__raw_writel(v, DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP3_REG));\r\ndavinci_clk_init(davinci_soc_info_da850.cpu_clks);\r\n}
