static inline bool\r\nports_match_v1(const struct xt_multiport_v1 *minfo,\r\nu_int16_t src, u_int16_t dst)\r\n{\r\nunsigned int i;\r\nu_int16_t s, e;\r\nfor (i = 0; i < minfo->count; i++) {\r\ns = minfo->ports[i];\r\nif (minfo->pflags[i]) {\r\ne = minfo->ports[++i];\r\npr_debug("src or dst matches with %d-%d?\n", s, e);\r\nswitch (minfo->flags) {\r\ncase XT_MULTIPORT_SOURCE:\r\nif (src >= s && src <= e)\r\nreturn true ^ minfo->invert;\r\nbreak;\r\ncase XT_MULTIPORT_DESTINATION:\r\nif (dst >= s && dst <= e)\r\nreturn true ^ minfo->invert;\r\nbreak;\r\ncase XT_MULTIPORT_EITHER:\r\nif ((dst >= s && dst <= e) ||\r\n(src >= s && src <= e))\r\nreturn true ^ minfo->invert;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} else {\r\npr_debug("src or dst matches with %d?\n", s);\r\nswitch (minfo->flags) {\r\ncase XT_MULTIPORT_SOURCE:\r\nif (src == s)\r\nreturn true ^ minfo->invert;\r\nbreak;\r\ncase XT_MULTIPORT_DESTINATION:\r\nif (dst == s)\r\nreturn true ^ minfo->invert;\r\nbreak;\r\ncase XT_MULTIPORT_EITHER:\r\nif (src == s || dst == s)\r\nreturn true ^ minfo->invert;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn minfo->invert;\r\n}\r\nstatic bool\r\nmultiport_mt(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nconst __be16 *pptr;\r\n__be16 _ports[2];\r\nconst struct xt_multiport_v1 *multiinfo = par->matchinfo;\r\nif (par->fragoff != 0)\r\nreturn false;\r\npptr = skb_header_pointer(skb, par->thoff, sizeof(_ports), _ports);\r\nif (pptr == NULL) {\r\npr_debug("Dropping evil offset=0 tinygram.\n");\r\npar->hotdrop = true;\r\nreturn false;\r\n}\r\nreturn ports_match_v1(multiinfo, ntohs(pptr[0]), ntohs(pptr[1]));\r\n}\r\nstatic inline bool\r\ncheck(u_int16_t proto,\r\nu_int8_t ip_invflags,\r\nu_int8_t match_flags,\r\nu_int8_t count)\r\n{\r\nreturn (proto == IPPROTO_TCP || proto == IPPROTO_UDP\r\n|| proto == IPPROTO_UDPLITE\r\n|| proto == IPPROTO_SCTP || proto == IPPROTO_DCCP)\r\n&& !(ip_invflags & XT_INV_PROTO)\r\n&& (match_flags == XT_MULTIPORT_SOURCE\r\n|| match_flags == XT_MULTIPORT_DESTINATION\r\n|| match_flags == XT_MULTIPORT_EITHER)\r\n&& count <= XT_MULTI_PORTS;\r\n}\r\nstatic int multiport_mt_check(const struct xt_mtchk_param *par)\r\n{\r\nconst struct ipt_ip *ip = par->entryinfo;\r\nconst struct xt_multiport_v1 *multiinfo = par->matchinfo;\r\nreturn check(ip->proto, ip->invflags, multiinfo->flags,\r\nmultiinfo->count) ? 0 : -EINVAL;\r\n}\r\nstatic int multiport_mt6_check(const struct xt_mtchk_param *par)\r\n{\r\nconst struct ip6t_ip6 *ip = par->entryinfo;\r\nconst struct xt_multiport_v1 *multiinfo = par->matchinfo;\r\nreturn check(ip->proto, ip->invflags, multiinfo->flags,\r\nmultiinfo->count) ? 0 : -EINVAL;\r\n}\r\nstatic int __init multiport_mt_init(void)\r\n{\r\nreturn xt_register_matches(multiport_mt_reg,\r\nARRAY_SIZE(multiport_mt_reg));\r\n}\r\nstatic void __exit multiport_mt_exit(void)\r\n{\r\nxt_unregister_matches(multiport_mt_reg, ARRAY_SIZE(multiport_mt_reg));\r\n}
