u8 acpi_ev_is_notify_object(struct acpi_namespace_node *node)\r\n{\r\nswitch (node->type) {\r\ncase ACPI_TYPE_DEVICE:\r\ncase ACPI_TYPE_PROCESSOR:\r\ncase ACPI_TYPE_THERMAL:\r\nreturn (TRUE);\r\ndefault:\r\nreturn (FALSE);\r\n}\r\n}\r\nacpi_status\r\nacpi_ev_queue_notify_request(struct acpi_namespace_node *node, u32 notify_value)\r\n{\r\nunion acpi_operand_object *obj_desc;\r\nunion acpi_operand_object *handler_list_head = NULL;\r\nunion acpi_generic_state *info;\r\nu8 handler_list_id = 0;\r\nacpi_status status = AE_OK;\r\nACPI_FUNCTION_NAME(ev_queue_notify_request);\r\nif (!acpi_ev_is_notify_object(node)) {\r\nreturn (AE_TYPE);\r\n}\r\nif (notify_value <= ACPI_MAX_SYS_NOTIFY) {\r\nhandler_list_id = ACPI_SYSTEM_HANDLER_LIST;\r\n} else {\r\nhandler_list_id = ACPI_DEVICE_HANDLER_LIST;\r\n}\r\nobj_desc = acpi_ns_get_attached_object(node);\r\nif (obj_desc) {\r\nhandler_list_head =\r\nobj_desc->common_notify.notify_list[handler_list_id];\r\n}\r\nif (!acpi_gbl_global_notify[handler_list_id].handler\r\n&& !handler_list_head) {\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"No notify handler for Notify, ignoring (%4.4s, %X) node %p\n",\r\nacpi_ut_get_node_name(node), notify_value,\r\nnode));\r\nreturn (AE_OK);\r\n}\r\ninfo = acpi_ut_create_generic_state();\r\nif (!info) {\r\nreturn (AE_NO_MEMORY);\r\n}\r\ninfo->common.descriptor_type = ACPI_DESC_TYPE_STATE_NOTIFY;\r\ninfo->notify.node = node;\r\ninfo->notify.value = (u16)notify_value;\r\ninfo->notify.handler_list_id = handler_list_id;\r\ninfo->notify.handler_list_head = handler_list_head;\r\ninfo->notify.global = &acpi_gbl_global_notify[handler_list_id];\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Dispatching Notify on [%4.4s] (%s) Value 0x%2.2X (%s) Node %p\n",\r\nacpi_ut_get_node_name(node),\r\nacpi_ut_get_type_name(node->type), notify_value,\r\nacpi_ut_get_notify_name(notify_value, ACPI_TYPE_ANY),\r\nnode));\r\nstatus = acpi_os_execute(OSL_NOTIFY_HANDLER,\r\nacpi_ev_notify_dispatch, info);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_ut_delete_generic_state(info);\r\n}\r\nreturn (status);\r\n}\r\nstatic void ACPI_SYSTEM_XFACE acpi_ev_notify_dispatch(void *context)\r\n{\r\nunion acpi_generic_state *info = (union acpi_generic_state *)context;\r\nunion acpi_operand_object *handler_obj;\r\nACPI_FUNCTION_ENTRY();\r\nif (info->notify.global->handler) {\r\ninfo->notify.global->handler(info->notify.node,\r\ninfo->notify.value,\r\ninfo->notify.global->context);\r\n}\r\nhandler_obj = info->notify.handler_list_head;\r\nwhile (handler_obj) {\r\nhandler_obj->notify.handler(info->notify.node,\r\ninfo->notify.value,\r\nhandler_obj->notify.context);\r\nhandler_obj =\r\nhandler_obj->notify.next[info->notify.handler_list_id];\r\n}\r\nacpi_ut_delete_generic_state(info);\r\n}\r\nvoid acpi_ev_terminate(void)\r\n{\r\nu32 i;\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(ev_terminate);\r\nif (acpi_gbl_events_initialized) {\r\nfor (i = 0; i < ACPI_NUM_FIXED_EVENTS; i++) {\r\nstatus = acpi_disable_event(i, 0);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_ERROR((AE_INFO,\r\n"Could not disable fixed event %u",\r\n(u32) i));\r\n}\r\n}\r\nstatus = acpi_ev_walk_gpe_list(acpi_hw_disable_gpe_block, NULL);\r\nstatus = acpi_ev_remove_global_lock_handler();\r\nif (ACPI_FAILURE(status)) {\r\nACPI_ERROR((AE_INFO,\r\n"Could not remove Global Lock handler"));\r\n}\r\nacpi_gbl_events_initialized = FALSE;\r\n}\r\nstatus = acpi_ev_remove_all_sci_handlers();\r\nif (ACPI_FAILURE(status)) {\r\nACPI_ERROR((AE_INFO, "Could not remove SCI handler"));\r\n}\r\nstatus = acpi_ev_walk_gpe_list(acpi_ev_delete_gpe_handlers, NULL);\r\nif (acpi_gbl_original_mode == ACPI_SYS_MODE_LEGACY) {\r\nstatus = acpi_disable();\r\nif (ACPI_FAILURE(status)) {\r\nACPI_WARNING((AE_INFO, "AcpiDisable failed"));\r\n}\r\n}\r\nreturn_VOID;\r\n}
