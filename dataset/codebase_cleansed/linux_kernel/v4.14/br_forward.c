static inline int should_deliver(const struct net_bridge_port *p,\r\nconst struct sk_buff *skb)\r\n{\r\nstruct net_bridge_vlan_group *vg;\r\nvg = nbp_vlan_group_rcu(p);\r\nreturn ((p->flags & BR_HAIRPIN_MODE) || skb->dev != p->dev) &&\r\nbr_allowed_egress(vg, skb) && p->state == BR_STATE_FORWARDING &&\r\nnbp_switchdev_allowed_egress(p, skb);\r\n}\r\nint br_dev_queue_push_xmit(struct net *net, struct sock *sk, struct sk_buff *skb)\r\n{\r\nif (!is_skb_forwardable(skb->dev, skb))\r\ngoto drop;\r\nskb_push(skb, ETH_HLEN);\r\nbr_drop_fake_rtable(skb);\r\nif (skb->ip_summed == CHECKSUM_PARTIAL &&\r\n(skb->protocol == htons(ETH_P_8021Q) ||\r\nskb->protocol == htons(ETH_P_8021AD))) {\r\nint depth;\r\nif (!__vlan_get_protocol(skb, skb->protocol, &depth))\r\ngoto drop;\r\nskb_set_network_header(skb, depth);\r\n}\r\ndev_queue_xmit(skb);\r\nreturn 0;\r\ndrop:\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nint br_forward_finish(struct net *net, struct sock *sk, struct sk_buff *skb)\r\n{\r\nreturn NF_HOOK(NFPROTO_BRIDGE, NF_BR_POST_ROUTING,\r\nnet, sk, skb, NULL, skb->dev,\r\nbr_dev_queue_push_xmit);\r\n}\r\nstatic void __br_forward(const struct net_bridge_port *to,\r\nstruct sk_buff *skb, bool local_orig)\r\n{\r\nstruct net_bridge_vlan_group *vg;\r\nstruct net_device *indev;\r\nstruct net *net;\r\nint br_hook;\r\nvg = nbp_vlan_group_rcu(to);\r\nskb = br_handle_vlan(to->br, to, vg, skb);\r\nif (!skb)\r\nreturn;\r\nindev = skb->dev;\r\nskb->dev = to->dev;\r\nif (!local_orig) {\r\nif (skb_warn_if_lro(skb)) {\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nbr_hook = NF_BR_FORWARD;\r\nskb_forward_csum(skb);\r\nnet = dev_net(indev);\r\n} else {\r\nif (unlikely(netpoll_tx_running(to->br->dev))) {\r\nif (!is_skb_forwardable(skb->dev, skb)) {\r\nkfree_skb(skb);\r\n} else {\r\nskb_push(skb, ETH_HLEN);\r\nbr_netpoll_send_skb(to, skb);\r\n}\r\nreturn;\r\n}\r\nbr_hook = NF_BR_LOCAL_OUT;\r\nnet = dev_net(skb->dev);\r\nindev = NULL;\r\n}\r\nNF_HOOK(NFPROTO_BRIDGE, br_hook,\r\nnet, NULL, skb, indev, skb->dev,\r\nbr_forward_finish);\r\n}\r\nstatic int deliver_clone(const struct net_bridge_port *prev,\r\nstruct sk_buff *skb, bool local_orig)\r\n{\r\nstruct net_device *dev = BR_INPUT_SKB_CB(skb)->brdev;\r\nskb = skb_clone(skb, GFP_ATOMIC);\r\nif (!skb) {\r\ndev->stats.tx_dropped++;\r\nreturn -ENOMEM;\r\n}\r\n__br_forward(prev, skb, local_orig);\r\nreturn 0;\r\n}\r\nvoid br_forward(const struct net_bridge_port *to,\r\nstruct sk_buff *skb, bool local_rcv, bool local_orig)\r\n{\r\nif (to && should_deliver(to, skb)) {\r\nif (local_rcv)\r\ndeliver_clone(to, skb, local_orig);\r\nelse\r\n__br_forward(to, skb, local_orig);\r\nreturn;\r\n}\r\nif (!local_rcv)\r\nkfree_skb(skb);\r\n}\r\nstatic struct net_bridge_port *maybe_deliver(\r\nstruct net_bridge_port *prev, struct net_bridge_port *p,\r\nstruct sk_buff *skb, bool local_orig)\r\n{\r\nint err;\r\nif (!should_deliver(p, skb))\r\nreturn prev;\r\nif (!prev)\r\ngoto out;\r\nerr = deliver_clone(prev, skb, local_orig);\r\nif (err)\r\nreturn ERR_PTR(err);\r\nout:\r\nreturn p;\r\n}\r\nvoid br_flood(struct net_bridge *br, struct sk_buff *skb,\r\nenum br_pkt_type pkt_type, bool local_rcv, bool local_orig)\r\n{\r\nu8 igmp_type = br_multicast_igmp_type(skb);\r\nstruct net_bridge_port *prev = NULL;\r\nstruct net_bridge_port *p;\r\nlist_for_each_entry_rcu(p, &br->port_list, list) {\r\nswitch (pkt_type) {\r\ncase BR_PKT_UNICAST:\r\nif (!(p->flags & BR_FLOOD))\r\ncontinue;\r\nbreak;\r\ncase BR_PKT_MULTICAST:\r\nif (!(p->flags & BR_MCAST_FLOOD) && skb->dev != br->dev)\r\ncontinue;\r\nbreak;\r\ncase BR_PKT_BROADCAST:\r\nif (!(p->flags & BR_BCAST_FLOOD) && skb->dev != br->dev)\r\ncontinue;\r\nbreak;\r\n}\r\nif (p->flags & BR_PROXYARP)\r\ncontinue;\r\nif ((p->flags & BR_PROXYARP_WIFI) &&\r\nBR_INPUT_SKB_CB(skb)->proxyarp_replied)\r\ncontinue;\r\nprev = maybe_deliver(prev, p, skb, local_orig);\r\nif (IS_ERR(prev))\r\ngoto out;\r\nif (prev == p)\r\nbr_multicast_count(p->br, p, skb, igmp_type,\r\nBR_MCAST_DIR_TX);\r\n}\r\nif (!prev)\r\ngoto out;\r\nif (local_rcv)\r\ndeliver_clone(prev, skb, local_orig);\r\nelse\r\n__br_forward(prev, skb, local_orig);\r\nreturn;\r\nout:\r\nif (!local_rcv)\r\nkfree_skb(skb);\r\n}\r\nstatic void maybe_deliver_addr(struct net_bridge_port *p, struct sk_buff *skb,\r\nconst unsigned char *addr, bool local_orig)\r\n{\r\nstruct net_device *dev = BR_INPUT_SKB_CB(skb)->brdev;\r\nconst unsigned char *src = eth_hdr(skb)->h_source;\r\nif (!should_deliver(p, skb))\r\nreturn;\r\nif (skb->dev == p->dev && ether_addr_equal(src, addr))\r\nreturn;\r\nskb = skb_copy(skb, GFP_ATOMIC);\r\nif (!skb) {\r\ndev->stats.tx_dropped++;\r\nreturn;\r\n}\r\nif (!is_broadcast_ether_addr(addr))\r\nmemcpy(eth_hdr(skb)->h_dest, addr, ETH_ALEN);\r\n__br_forward(p, skb, local_orig);\r\n}\r\nvoid br_multicast_flood(struct net_bridge_mdb_entry *mdst,\r\nstruct sk_buff *skb,\r\nbool local_rcv, bool local_orig)\r\n{\r\nstruct net_device *dev = BR_INPUT_SKB_CB(skb)->brdev;\r\nu8 igmp_type = br_multicast_igmp_type(skb);\r\nstruct net_bridge *br = netdev_priv(dev);\r\nstruct net_bridge_port *prev = NULL;\r\nstruct net_bridge_port_group *p;\r\nstruct hlist_node *rp;\r\nrp = rcu_dereference(hlist_first_rcu(&br->router_list));\r\np = mdst ? rcu_dereference(mdst->ports) : NULL;\r\nwhile (p || rp) {\r\nstruct net_bridge_port *port, *lport, *rport;\r\nlport = p ? p->port : NULL;\r\nrport = rp ? hlist_entry(rp, struct net_bridge_port, rlist) :\r\nNULL;\r\nif ((unsigned long)lport > (unsigned long)rport) {\r\nport = lport;\r\nif (port->flags & BR_MULTICAST_TO_UNICAST) {\r\nmaybe_deliver_addr(lport, skb, p->eth_addr,\r\nlocal_orig);\r\ngoto delivered;\r\n}\r\n} else {\r\nport = rport;\r\n}\r\nprev = maybe_deliver(prev, port, skb, local_orig);\r\ndelivered:\r\nif (IS_ERR(prev))\r\ngoto out;\r\nif (prev == port)\r\nbr_multicast_count(port->br, port, skb, igmp_type,\r\nBR_MCAST_DIR_TX);\r\nif ((unsigned long)lport >= (unsigned long)port)\r\np = rcu_dereference(p->next);\r\nif ((unsigned long)rport >= (unsigned long)port)\r\nrp = rcu_dereference(hlist_next_rcu(rp));\r\n}\r\nif (!prev)\r\ngoto out;\r\nif (local_rcv)\r\ndeliver_clone(prev, skb, local_orig);\r\nelse\r\n__br_forward(prev, skb, local_orig);\r\nreturn;\r\nout:\r\nif (!local_rcv)\r\nkfree_skb(skb);\r\n}
