static int fuel_gauge_reg_readb(struct axp288_fg_info *info, int reg)\r\n{\r\nint ret, i;\r\nunsigned int val;\r\nfor (i = 0; i < NR_RETRY_CNT; i++) {\r\nret = regmap_read(info->regmap, reg, &val);\r\nif (ret == -EBUSY)\r\ncontinue;\r\nelse\r\nbreak;\r\n}\r\nif (ret < 0) {\r\ndev_err(&info->pdev->dev, "axp288 reg read err:%d\n", ret);\r\nreturn ret;\r\n}\r\nreturn val;\r\n}\r\nstatic int fuel_gauge_reg_writeb(struct axp288_fg_info *info, int reg, u8 val)\r\n{\r\nint ret;\r\nret = regmap_write(info->regmap, reg, (unsigned int)val);\r\nif (ret < 0)\r\ndev_err(&info->pdev->dev, "axp288 reg write err:%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int fuel_gauge_read_15bit_word(struct axp288_fg_info *info, int reg)\r\n{\r\nunsigned char buf[2];\r\nint ret;\r\nret = regmap_bulk_read(info->regmap, reg, buf, 2);\r\nif (ret < 0) {\r\ndev_err(&info->pdev->dev, "Error reading reg 0x%02x err: %d\n",\r\nreg, ret);\r\nreturn ret;\r\n}\r\nret = get_unaligned_be16(buf);\r\nif (!(ret & FG_15BIT_WORD_VALID)) {\r\ndev_err(&info->pdev->dev, "Error reg 0x%02x contents not valid\n",\r\nreg);\r\nreturn -ENXIO;\r\n}\r\nreturn ret & FG_15BIT_VAL_MASK;\r\n}\r\nstatic int fuel_gauge_read_12bit_word(struct axp288_fg_info *info, int reg)\r\n{\r\nunsigned char buf[2];\r\nint ret;\r\nret = regmap_bulk_read(info->regmap, reg, buf, 2);\r\nif (ret < 0) {\r\ndev_err(&info->pdev->dev, "Error reading reg 0x%02x err: %d\n",\r\nreg, ret);\r\nreturn ret;\r\n}\r\nreturn (buf[0] << 4) | ((buf[1] >> 4) & 0x0f);\r\n}\r\nstatic int pmic_read_adc_val(const char *name, int *raw_val,\r\nstruct axp288_fg_info *info)\r\n{\r\nint ret, val = 0;\r\nstruct iio_channel *indio_chan;\r\nindio_chan = iio_channel_get(NULL, name);\r\nif (IS_ERR_OR_NULL(indio_chan)) {\r\nret = PTR_ERR(indio_chan);\r\ngoto exit;\r\n}\r\nret = iio_read_channel_raw(indio_chan, &val);\r\nif (ret < 0) {\r\ndev_err(&info->pdev->dev,\r\n"IIO channel read error: %x, %x\n", ret, val);\r\ngoto err_exit;\r\n}\r\ndev_dbg(&info->pdev->dev, "adc raw val=%x\n", val);\r\n*raw_val = val;\r\nerr_exit:\r\niio_channel_release(indio_chan);\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int fuel_gauge_debug_show(struct seq_file *s, void *data)\r\n{\r\nstruct axp288_fg_info *info = s->private;\r\nint raw_val, ret;\r\nseq_printf(s, " PWR_STATUS[%02x] : %02x\n",\r\nAXP20X_PWR_INPUT_STATUS,\r\nfuel_gauge_reg_readb(info, AXP20X_PWR_INPUT_STATUS));\r\nseq_printf(s, "PWR_OP_MODE[%02x] : %02x\n",\r\nAXP20X_PWR_OP_MODE,\r\nfuel_gauge_reg_readb(info, AXP20X_PWR_OP_MODE));\r\nseq_printf(s, " CHRG_CTRL1[%02x] : %02x\n",\r\nAXP20X_CHRG_CTRL1,\r\nfuel_gauge_reg_readb(info, AXP20X_CHRG_CTRL1));\r\nseq_printf(s, " VLTF[%02x] : %02x\n",\r\nAXP20X_V_LTF_DISCHRG,\r\nfuel_gauge_reg_readb(info, AXP20X_V_LTF_DISCHRG));\r\nseq_printf(s, " VHTF[%02x] : %02x\n",\r\nAXP20X_V_HTF_DISCHRG,\r\nfuel_gauge_reg_readb(info, AXP20X_V_HTF_DISCHRG));\r\nseq_printf(s, " CC_CTRL[%02x] : %02x\n",\r\nAXP20X_CC_CTRL,\r\nfuel_gauge_reg_readb(info, AXP20X_CC_CTRL));\r\nseq_printf(s, "BATTERY CAP[%02x] : %02x\n",\r\nAXP20X_FG_RES,\r\nfuel_gauge_reg_readb(info, AXP20X_FG_RES));\r\nseq_printf(s, " FG_RDC1[%02x] : %02x\n",\r\nAXP288_FG_RDC1_REG,\r\nfuel_gauge_reg_readb(info, AXP288_FG_RDC1_REG));\r\nseq_printf(s, " FG_RDC0[%02x] : %02x\n",\r\nAXP288_FG_RDC0_REG,\r\nfuel_gauge_reg_readb(info, AXP288_FG_RDC0_REG));\r\nseq_printf(s, " FG_OCV[%02x] : %04x\n",\r\nAXP288_FG_OCVH_REG,\r\nfuel_gauge_read_12bit_word(info, AXP288_FG_OCVH_REG));\r\nseq_printf(s, " FG_DES_CAP[%02x] : %04x\n",\r\nAXP288_FG_DES_CAP1_REG,\r\nfuel_gauge_read_15bit_word(info, AXP288_FG_DES_CAP1_REG));\r\nseq_printf(s, " FG_CC_MTR[%02x] : %04x\n",\r\nAXP288_FG_CC_MTR1_REG,\r\nfuel_gauge_read_15bit_word(info, AXP288_FG_CC_MTR1_REG));\r\nseq_printf(s, " FG_OCV_CAP[%02x] : %02x\n",\r\nAXP288_FG_OCV_CAP_REG,\r\nfuel_gauge_reg_readb(info, AXP288_FG_OCV_CAP_REG));\r\nseq_printf(s, " FG_CC_CAP[%02x] : %02x\n",\r\nAXP288_FG_CC_CAP_REG,\r\nfuel_gauge_reg_readb(info, AXP288_FG_CC_CAP_REG));\r\nseq_printf(s, " FG_LOW_CAP[%02x] : %02x\n",\r\nAXP288_FG_LOW_CAP_REG,\r\nfuel_gauge_reg_readb(info, AXP288_FG_LOW_CAP_REG));\r\nseq_printf(s, "TUNING_CTL0[%02x] : %02x\n",\r\nAXP288_FG_TUNE0,\r\nfuel_gauge_reg_readb(info, AXP288_FG_TUNE0));\r\nseq_printf(s, "TUNING_CTL1[%02x] : %02x\n",\r\nAXP288_FG_TUNE1,\r\nfuel_gauge_reg_readb(info, AXP288_FG_TUNE1));\r\nseq_printf(s, "TUNING_CTL2[%02x] : %02x\n",\r\nAXP288_FG_TUNE2,\r\nfuel_gauge_reg_readb(info, AXP288_FG_TUNE2));\r\nseq_printf(s, "TUNING_CTL3[%02x] : %02x\n",\r\nAXP288_FG_TUNE3,\r\nfuel_gauge_reg_readb(info, AXP288_FG_TUNE3));\r\nseq_printf(s, "TUNING_CTL4[%02x] : %02x\n",\r\nAXP288_FG_TUNE4,\r\nfuel_gauge_reg_readb(info, AXP288_FG_TUNE4));\r\nseq_printf(s, "TUNING_CTL5[%02x] : %02x\n",\r\nAXP288_FG_TUNE5,\r\nfuel_gauge_reg_readb(info, AXP288_FG_TUNE5));\r\nret = pmic_read_adc_val("axp288-batt-temp", &raw_val, info);\r\nif (ret >= 0)\r\nseq_printf(s, "axp288-batttemp : %d\n", raw_val);\r\nret = pmic_read_adc_val("axp288-pmic-temp", &raw_val, info);\r\nif (ret >= 0)\r\nseq_printf(s, "axp288-pmictemp : %d\n", raw_val);\r\nret = pmic_read_adc_val("axp288-system-temp", &raw_val, info);\r\nif (ret >= 0)\r\nseq_printf(s, "axp288-systtemp : %d\n", raw_val);\r\nret = pmic_read_adc_val("axp288-chrg-curr", &raw_val, info);\r\nif (ret >= 0)\r\nseq_printf(s, "axp288-chrgcurr : %d\n", raw_val);\r\nret = pmic_read_adc_val("axp288-chrg-d-curr", &raw_val, info);\r\nif (ret >= 0)\r\nseq_printf(s, "axp288-dchrgcur : %d\n", raw_val);\r\nret = pmic_read_adc_val("axp288-batt-volt", &raw_val, info);\r\nif (ret >= 0)\r\nseq_printf(s, "axp288-battvolt : %d\n", raw_val);\r\nreturn 0;\r\n}\r\nstatic int debug_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, fuel_gauge_debug_show, inode->i_private);\r\n}\r\nstatic void fuel_gauge_create_debugfs(struct axp288_fg_info *info)\r\n{\r\ninfo->debug_file = debugfs_create_file("fuelgauge", 0666, NULL,\r\ninfo, &fg_debug_fops);\r\n}\r\nstatic void fuel_gauge_remove_debugfs(struct axp288_fg_info *info)\r\n{\r\ndebugfs_remove(info->debug_file);\r\n}\r\nstatic inline void fuel_gauge_create_debugfs(struct axp288_fg_info *info)\r\n{\r\n}\r\nstatic inline void fuel_gauge_remove_debugfs(struct axp288_fg_info *info)\r\n{\r\n}\r\nstatic void fuel_gauge_get_status(struct axp288_fg_info *info)\r\n{\r\nint pwr_stat, ret;\r\nint charge, discharge;\r\npwr_stat = fuel_gauge_reg_readb(info, AXP20X_PWR_INPUT_STATUS);\r\nif (pwr_stat < 0) {\r\ndev_err(&info->pdev->dev,\r\n"PWR STAT read failed:%d\n", pwr_stat);\r\nreturn;\r\n}\r\nret = pmic_read_adc_val("axp288-chrg-curr", &charge, info);\r\nif (ret < 0) {\r\ndev_err(&info->pdev->dev,\r\n"ADC charge current read failed:%d\n", ret);\r\nreturn;\r\n}\r\nret = pmic_read_adc_val("axp288-chrg-d-curr", &discharge, info);\r\nif (ret < 0) {\r\ndev_err(&info->pdev->dev,\r\n"ADC discharge current read failed:%d\n", ret);\r\nreturn;\r\n}\r\nif (charge > 0)\r\ninfo->status = POWER_SUPPLY_STATUS_CHARGING;\r\nelse if (discharge > 0)\r\ninfo->status = POWER_SUPPLY_STATUS_DISCHARGING;\r\nelse {\r\nif (pwr_stat & CHRG_STAT_BAT_PRESENT)\r\ninfo->status = POWER_SUPPLY_STATUS_FULL;\r\nelse\r\ninfo->status = POWER_SUPPLY_STATUS_NOT_CHARGING;\r\n}\r\n}\r\nstatic int fuel_gauge_get_vbatt(struct axp288_fg_info *info, int *vbatt)\r\n{\r\nint ret = 0, raw_val;\r\nret = pmic_read_adc_val("axp288-batt-volt", &raw_val, info);\r\nif (ret < 0)\r\ngoto vbatt_read_fail;\r\n*vbatt = VOLTAGE_FROM_ADC(raw_val);\r\nvbatt_read_fail:\r\nreturn ret;\r\n}\r\nstatic int fuel_gauge_get_current(struct axp288_fg_info *info, int *cur)\r\n{\r\nint ret, value = 0;\r\nint charge, discharge;\r\nret = pmic_read_adc_val("axp288-chrg-curr", &charge, info);\r\nif (ret < 0)\r\ngoto current_read_fail;\r\nret = pmic_read_adc_val("axp288-chrg-d-curr", &discharge, info);\r\nif (ret < 0)\r\ngoto current_read_fail;\r\nif (charge > 0)\r\nvalue = charge;\r\nelse if (discharge > 0)\r\nvalue = -1 * discharge;\r\n*cur = value;\r\ncurrent_read_fail:\r\nreturn ret;\r\n}\r\nstatic int fuel_gauge_get_vocv(struct axp288_fg_info *info, int *vocv)\r\n{\r\nint ret;\r\nret = fuel_gauge_read_12bit_word(info, AXP288_FG_OCVH_REG);\r\nif (ret >= 0)\r\n*vocv = VOLTAGE_FROM_ADC(ret);\r\nreturn ret;\r\n}\r\nstatic int fuel_gauge_battery_health(struct axp288_fg_info *info)\r\n{\r\nint ret, vocv, health = POWER_SUPPLY_HEALTH_UNKNOWN;\r\nret = fuel_gauge_get_vocv(info, &vocv);\r\nif (ret < 0)\r\ngoto health_read_fail;\r\nif (vocv > info->max_volt)\r\nhealth = POWER_SUPPLY_HEALTH_OVERVOLTAGE;\r\nelse\r\nhealth = POWER_SUPPLY_HEALTH_GOOD;\r\nhealth_read_fail:\r\nreturn health;\r\n}\r\nstatic int fuel_gauge_get_property(struct power_supply *ps,\r\nenum power_supply_property prop,\r\nunion power_supply_propval *val)\r\n{\r\nstruct axp288_fg_info *info = power_supply_get_drvdata(ps);\r\nint ret = 0, value;\r\nmutex_lock(&info->lock);\r\nswitch (prop) {\r\ncase POWER_SUPPLY_PROP_STATUS:\r\nfuel_gauge_get_status(info);\r\nval->intval = info->status;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_HEALTH:\r\nval->intval = fuel_gauge_battery_health(info);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_NOW:\r\nret = fuel_gauge_get_vbatt(info, &value);\r\nif (ret < 0)\r\ngoto fuel_gauge_read_err;\r\nval->intval = PROP_VOLT(value);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_OCV:\r\nret = fuel_gauge_get_vocv(info, &value);\r\nif (ret < 0)\r\ngoto fuel_gauge_read_err;\r\nval->intval = PROP_VOLT(value);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CURRENT_NOW:\r\nret = fuel_gauge_get_current(info, &value);\r\nif (ret < 0)\r\ngoto fuel_gauge_read_err;\r\nval->intval = PROP_CURR(value);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_PRESENT:\r\nret = fuel_gauge_reg_readb(info, AXP20X_PWR_OP_MODE);\r\nif (ret < 0)\r\ngoto fuel_gauge_read_err;\r\nif (ret & CHRG_STAT_BAT_PRESENT)\r\nval->intval = 1;\r\nelse\r\nval->intval = 0;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CAPACITY:\r\nret = fuel_gauge_reg_readb(info, AXP20X_FG_RES);\r\nif (ret < 0)\r\ngoto fuel_gauge_read_err;\r\nif (!(ret & FG_REP_CAP_VALID))\r\ndev_err(&info->pdev->dev,\r\n"capacity measurement not valid\n");\r\nval->intval = (ret & FG_REP_CAP_VAL_MASK);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CAPACITY_ALERT_MIN:\r\nret = fuel_gauge_reg_readb(info, AXP288_FG_LOW_CAP_REG);\r\nif (ret < 0)\r\ngoto fuel_gauge_read_err;\r\nval->intval = (ret & 0x0f);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TECHNOLOGY:\r\nval->intval = POWER_SUPPLY_TECHNOLOGY_LION;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_NOW:\r\nret = fuel_gauge_read_15bit_word(info, AXP288_FG_CC_MTR1_REG);\r\nif (ret < 0)\r\ngoto fuel_gauge_read_err;\r\nval->intval = ret * FG_DES_CAP_RES_LSB;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_FULL:\r\nret = fuel_gauge_read_15bit_word(info, AXP288_FG_DES_CAP1_REG);\r\nif (ret < 0)\r\ngoto fuel_gauge_read_err;\r\nval->intval = ret * FG_DES_CAP_RES_LSB;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:\r\nval->intval = PROP_VOLT(info->max_volt);\r\nbreak;\r\ndefault:\r\nmutex_unlock(&info->lock);\r\nreturn -EINVAL;\r\n}\r\nmutex_unlock(&info->lock);\r\nreturn 0;\r\nfuel_gauge_read_err:\r\nmutex_unlock(&info->lock);\r\nreturn ret;\r\n}\r\nstatic int fuel_gauge_set_property(struct power_supply *ps,\r\nenum power_supply_property prop,\r\nconst union power_supply_propval *val)\r\n{\r\nstruct axp288_fg_info *info = power_supply_get_drvdata(ps);\r\nint ret = 0;\r\nmutex_lock(&info->lock);\r\nswitch (prop) {\r\ncase POWER_SUPPLY_PROP_CAPACITY_ALERT_MIN:\r\nif ((val->intval < 0) || (val->intval > 15)) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nret = fuel_gauge_reg_readb(info, AXP288_FG_LOW_CAP_REG);\r\nif (ret < 0)\r\nbreak;\r\nret &= 0xf0;\r\nret |= (val->intval & 0xf);\r\nret = fuel_gauge_reg_writeb(info, AXP288_FG_LOW_CAP_REG, ret);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nmutex_unlock(&info->lock);\r\nreturn ret;\r\n}\r\nstatic int fuel_gauge_property_is_writeable(struct power_supply *psy,\r\nenum power_supply_property psp)\r\n{\r\nint ret;\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_CAPACITY_ALERT_MIN:\r\nret = 1;\r\nbreak;\r\ndefault:\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic void fuel_gauge_status_monitor(struct work_struct *work)\r\n{\r\nstruct axp288_fg_info *info = container_of(work,\r\nstruct axp288_fg_info, status_monitor.work);\r\nfuel_gauge_get_status(info);\r\npower_supply_changed(info->bat);\r\nschedule_delayed_work(&info->status_monitor, STATUS_MON_DELAY_JIFFIES);\r\n}\r\nstatic irqreturn_t fuel_gauge_thread_handler(int irq, void *dev)\r\n{\r\nstruct axp288_fg_info *info = dev;\r\nint i;\r\nfor (i = 0; i < AXP288_FG_INTR_NUM; i++) {\r\nif (info->irq[i] == irq)\r\nbreak;\r\n}\r\nif (i >= AXP288_FG_INTR_NUM) {\r\ndev_warn(&info->pdev->dev, "spurious interrupt!!\n");\r\nreturn IRQ_NONE;\r\n}\r\nswitch (i) {\r\ncase QWBTU_IRQ:\r\ndev_info(&info->pdev->dev,\r\n"Quit Battery under temperature in work mode IRQ (QWBTU)\n");\r\nbreak;\r\ncase WBTU_IRQ:\r\ndev_info(&info->pdev->dev,\r\n"Battery under temperature in work mode IRQ (WBTU)\n");\r\nbreak;\r\ncase QWBTO_IRQ:\r\ndev_info(&info->pdev->dev,\r\n"Quit Battery over temperature in work mode IRQ (QWBTO)\n");\r\nbreak;\r\ncase WBTO_IRQ:\r\ndev_info(&info->pdev->dev,\r\n"Battery over temperature in work mode IRQ (WBTO)\n");\r\nbreak;\r\ncase WL2_IRQ:\r\ndev_info(&info->pdev->dev, "Low Batt Warning(2) INTR\n");\r\nbreak;\r\ncase WL1_IRQ:\r\ndev_info(&info->pdev->dev, "Low Batt Warning(1) INTR\n");\r\nbreak;\r\ndefault:\r\ndev_warn(&info->pdev->dev, "Spurious Interrupt!!!\n");\r\n}\r\npower_supply_changed(info->bat);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void fuel_gauge_external_power_changed(struct power_supply *psy)\r\n{\r\nstruct axp288_fg_info *info = power_supply_get_drvdata(psy);\r\npower_supply_changed(info->bat);\r\n}\r\nstatic void fuel_gauge_init_irq(struct axp288_fg_info *info)\r\n{\r\nint ret, i, pirq;\r\nfor (i = 0; i < AXP288_FG_INTR_NUM; i++) {\r\npirq = platform_get_irq(info->pdev, i);\r\ninfo->irq[i] = regmap_irq_get_virq(info->regmap_irqc, pirq);\r\nif (info->irq[i] < 0) {\r\ndev_warn(&info->pdev->dev,\r\n"regmap_irq get virq failed for IRQ %d: %d\n",\r\npirq, info->irq[i]);\r\ninfo->irq[i] = -1;\r\ngoto intr_failed;\r\n}\r\nret = request_threaded_irq(info->irq[i],\r\nNULL, fuel_gauge_thread_handler,\r\nIRQF_ONESHOT, DEV_NAME, info);\r\nif (ret) {\r\ndev_warn(&info->pdev->dev,\r\n"request irq failed for IRQ %d: %d\n",\r\npirq, info->irq[i]);\r\ninfo->irq[i] = -1;\r\ngoto intr_failed;\r\n} else {\r\ndev_info(&info->pdev->dev, "HW IRQ %d -> VIRQ %d\n",\r\npirq, info->irq[i]);\r\n}\r\n}\r\nreturn;\r\nintr_failed:\r\nfor (; i > 0; i--) {\r\nfree_irq(info->irq[i - 1], info);\r\ninfo->irq[i - 1] = -1;\r\n}\r\n}\r\nstatic int axp288_fuel_gauge_probe(struct platform_device *pdev)\r\n{\r\nint ret = 0;\r\nstruct axp288_fg_info *info;\r\nstruct axp20x_dev *axp20x = dev_get_drvdata(pdev->dev.parent);\r\nstruct power_supply_config psy_cfg = {};\r\ninfo = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\ninfo->pdev = pdev;\r\ninfo->regmap = axp20x->regmap;\r\ninfo->regmap_irqc = axp20x->regmap_irqc;\r\ninfo->status = POWER_SUPPLY_STATUS_UNKNOWN;\r\nplatform_set_drvdata(pdev, info);\r\nmutex_init(&info->lock);\r\nINIT_DELAYED_WORK(&info->status_monitor, fuel_gauge_status_monitor);\r\nret = fuel_gauge_reg_readb(info, AXP288_FG_DES_CAP1_REG);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!(ret & FG_DES_CAP1_VALID)) {\r\ndev_err(&pdev->dev, "axp288 not configured by firmware\n");\r\nreturn -ENODEV;\r\n}\r\nret = fuel_gauge_reg_readb(info, AXP20X_CHRG_CTRL1);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch ((ret & CHRG_CCCV_CV_MASK) >> CHRG_CCCV_CV_BIT_POS) {\r\ncase CHRG_CCCV_CV_4100MV:\r\ninfo->max_volt = 4100;\r\nbreak;\r\ncase CHRG_CCCV_CV_4150MV:\r\ninfo->max_volt = 4150;\r\nbreak;\r\ncase CHRG_CCCV_CV_4200MV:\r\ninfo->max_volt = 4200;\r\nbreak;\r\ncase CHRG_CCCV_CV_4350MV:\r\ninfo->max_volt = 4350;\r\nbreak;\r\n}\r\npsy_cfg.drv_data = info;\r\ninfo->bat = power_supply_register(&pdev->dev, &fuel_gauge_desc, &psy_cfg);\r\nif (IS_ERR(info->bat)) {\r\nret = PTR_ERR(info->bat);\r\ndev_err(&pdev->dev, "failed to register battery: %d\n", ret);\r\nreturn ret;\r\n}\r\nfuel_gauge_create_debugfs(info);\r\nfuel_gauge_init_irq(info);\r\nschedule_delayed_work(&info->status_monitor, STATUS_MON_DELAY_JIFFIES);\r\nreturn 0;\r\n}\r\nstatic int axp288_fuel_gauge_remove(struct platform_device *pdev)\r\n{\r\nstruct axp288_fg_info *info = platform_get_drvdata(pdev);\r\nint i;\r\ncancel_delayed_work_sync(&info->status_monitor);\r\npower_supply_unregister(info->bat);\r\nfuel_gauge_remove_debugfs(info);\r\nfor (i = 0; i < AXP288_FG_INTR_NUM; i++)\r\nif (info->irq[i] >= 0)\r\nfree_irq(info->irq[i], info);\r\nreturn 0;\r\n}
