MPI mpi_read_raw_data(const void *xbuffer, size_t nbytes)\r\n{\r\nconst uint8_t *buffer = xbuffer;\r\nint i, j;\r\nunsigned nbits, nlimbs;\r\nmpi_limb_t a;\r\nMPI val = NULL;\r\nwhile (nbytes > 0 && buffer[0] == 0) {\r\nbuffer++;\r\nnbytes--;\r\n}\r\nnbits = nbytes * 8;\r\nif (nbits > MAX_EXTERN_MPI_BITS) {\r\npr_info("MPI: mpi too large (%u bits)\n", nbits);\r\nreturn NULL;\r\n}\r\nif (nbytes > 0)\r\nnbits -= count_leading_zeros(buffer[0]) - (BITS_PER_LONG - 8);\r\nnlimbs = DIV_ROUND_UP(nbytes, BYTES_PER_MPI_LIMB);\r\nval = mpi_alloc(nlimbs);\r\nif (!val)\r\nreturn NULL;\r\nval->nbits = nbits;\r\nval->sign = 0;\r\nval->nlimbs = nlimbs;\r\nif (nbytes > 0) {\r\ni = BYTES_PER_MPI_LIMB - nbytes % BYTES_PER_MPI_LIMB;\r\ni %= BYTES_PER_MPI_LIMB;\r\nfor (j = nlimbs; j > 0; j--) {\r\na = 0;\r\nfor (; i < BYTES_PER_MPI_LIMB; i++) {\r\na <<= 8;\r\na |= *buffer++;\r\n}\r\ni = 0;\r\nval->d[j - 1] = a;\r\n}\r\n}\r\nreturn val;\r\n}\r\nMPI mpi_read_from_buffer(const void *xbuffer, unsigned *ret_nread)\r\n{\r\nconst uint8_t *buffer = xbuffer;\r\nunsigned int nbits, nbytes;\r\nMPI val;\r\nif (*ret_nread < 2)\r\nreturn ERR_PTR(-EINVAL);\r\nnbits = buffer[0] << 8 | buffer[1];\r\nif (nbits > MAX_EXTERN_MPI_BITS) {\r\npr_info("MPI: mpi too large (%u bits)\n", nbits);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nnbytes = DIV_ROUND_UP(nbits, 8);\r\nif (nbytes + 2 > *ret_nread) {\r\npr_info("MPI: mpi larger than buffer nbytes=%u ret_nread=%u\n",\r\nnbytes, *ret_nread);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nval = mpi_read_raw_data(buffer + 2, nbytes);\r\nif (!val)\r\nreturn ERR_PTR(-ENOMEM);\r\n*ret_nread = nbytes + 2;\r\nreturn val;\r\n}\r\nstatic int count_lzeros(MPI a)\r\n{\r\nmpi_limb_t alimb;\r\nint i, lzeros = 0;\r\nfor (i = a->nlimbs - 1; i >= 0; i--) {\r\nalimb = a->d[i];\r\nif (alimb == 0) {\r\nlzeros += sizeof(mpi_limb_t);\r\n} else {\r\nlzeros += count_leading_zeros(alimb) / 8;\r\nbreak;\r\n}\r\n}\r\nreturn lzeros;\r\n}\r\nint mpi_read_buffer(MPI a, uint8_t *buf, unsigned buf_len, unsigned *nbytes,\r\nint *sign)\r\n{\r\nuint8_t *p;\r\n#if BYTES_PER_MPI_LIMB == 4\r\n__be32 alimb;\r\n#elif BYTES_PER_MPI_LIMB == 8\r\n__be64 alimb;\r\n#else\r\n#error please implement for this limb size.\r\n#endif\r\nunsigned int n = mpi_get_size(a);\r\nint i, lzeros;\r\nif (!buf || !nbytes)\r\nreturn -EINVAL;\r\nif (sign)\r\n*sign = a->sign;\r\nlzeros = count_lzeros(a);\r\nif (buf_len < n - lzeros) {\r\n*nbytes = n - lzeros;\r\nreturn -EOVERFLOW;\r\n}\r\np = buf;\r\n*nbytes = n - lzeros;\r\nfor (i = a->nlimbs - 1 - lzeros / BYTES_PER_MPI_LIMB,\r\nlzeros %= BYTES_PER_MPI_LIMB;\r\ni >= 0; i--) {\r\n#if BYTES_PER_MPI_LIMB == 4\r\nalimb = cpu_to_be32(a->d[i]);\r\n#elif BYTES_PER_MPI_LIMB == 8\r\nalimb = cpu_to_be64(a->d[i]);\r\n#else\r\n#error please implement for this limb size.\r\n#endif\r\nmemcpy(p, (u8 *)&alimb + lzeros, BYTES_PER_MPI_LIMB - lzeros);\r\np += BYTES_PER_MPI_LIMB - lzeros;\r\nlzeros = 0;\r\n}\r\nreturn 0;\r\n}\r\nvoid *mpi_get_buffer(MPI a, unsigned *nbytes, int *sign)\r\n{\r\nuint8_t *buf;\r\nunsigned int n;\r\nint ret;\r\nif (!nbytes)\r\nreturn NULL;\r\nn = mpi_get_size(a);\r\nif (!n)\r\nn++;\r\nbuf = kmalloc(n, GFP_KERNEL);\r\nif (!buf)\r\nreturn NULL;\r\nret = mpi_read_buffer(a, buf, n, nbytes, sign);\r\nif (ret) {\r\nkfree(buf);\r\nreturn NULL;\r\n}\r\nreturn buf;\r\n}\r\nint mpi_write_to_sgl(MPI a, struct scatterlist *sgl, unsigned nbytes,\r\nint *sign)\r\n{\r\nu8 *p, *p2;\r\n#if BYTES_PER_MPI_LIMB == 4\r\n__be32 alimb;\r\n#elif BYTES_PER_MPI_LIMB == 8\r\n__be64 alimb;\r\n#else\r\n#error please implement for this limb size.\r\n#endif\r\nunsigned int n = mpi_get_size(a);\r\nstruct sg_mapping_iter miter;\r\nint i, x, buf_len;\r\nint nents;\r\nif (sign)\r\n*sign = a->sign;\r\nif (nbytes < n)\r\nreturn -EOVERFLOW;\r\nnents = sg_nents_for_len(sgl, nbytes);\r\nif (nents < 0)\r\nreturn -EINVAL;\r\nsg_miter_start(&miter, sgl, nents, SG_MITER_ATOMIC | SG_MITER_TO_SG);\r\nsg_miter_next(&miter);\r\nbuf_len = miter.length;\r\np2 = miter.addr;\r\nwhile (nbytes > n) {\r\ni = min_t(unsigned, nbytes - n, buf_len);\r\nmemset(p2, 0, i);\r\np2 += i;\r\nnbytes -= i;\r\nbuf_len -= i;\r\nif (!buf_len) {\r\nsg_miter_next(&miter);\r\nbuf_len = miter.length;\r\np2 = miter.addr;\r\n}\r\n}\r\nfor (i = a->nlimbs - 1; i >= 0; i--) {\r\n#if BYTES_PER_MPI_LIMB == 4\r\nalimb = a->d[i] ? cpu_to_be32(a->d[i]) : 0;\r\n#elif BYTES_PER_MPI_LIMB == 8\r\nalimb = a->d[i] ? cpu_to_be64(a->d[i]) : 0;\r\n#else\r\n#error please implement for this limb size.\r\n#endif\r\np = (u8 *)&alimb;\r\nfor (x = 0; x < sizeof(alimb); x++) {\r\n*p2++ = *p++;\r\nif (!--buf_len) {\r\nsg_miter_next(&miter);\r\nbuf_len = miter.length;\r\np2 = miter.addr;\r\n}\r\n}\r\n}\r\nsg_miter_stop(&miter);\r\nreturn 0;\r\n}\r\nMPI mpi_read_raw_from_sgl(struct scatterlist *sgl, unsigned int nbytes)\r\n{\r\nstruct sg_mapping_iter miter;\r\nunsigned int nbits, nlimbs;\r\nint x, j, z, lzeros, ents;\r\nunsigned int len;\r\nconst u8 *buff;\r\nmpi_limb_t a;\r\nMPI val = NULL;\r\nents = sg_nents_for_len(sgl, nbytes);\r\nif (ents < 0)\r\nreturn NULL;\r\nsg_miter_start(&miter, sgl, ents, SG_MITER_ATOMIC | SG_MITER_FROM_SG);\r\nlzeros = 0;\r\nlen = 0;\r\nwhile (nbytes > 0) {\r\nwhile (len && !*buff) {\r\nlzeros++;\r\nlen--;\r\nbuff++;\r\n}\r\nif (len && *buff)\r\nbreak;\r\nsg_miter_next(&miter);\r\nbuff = miter.addr;\r\nlen = miter.length;\r\nnbytes -= lzeros;\r\nlzeros = 0;\r\n}\r\nmiter.consumed = lzeros;\r\nnbytes -= lzeros;\r\nnbits = nbytes * 8;\r\nif (nbits > MAX_EXTERN_MPI_BITS) {\r\nsg_miter_stop(&miter);\r\npr_info("MPI: mpi too large (%u bits)\n", nbits);\r\nreturn NULL;\r\n}\r\nif (nbytes > 0)\r\nnbits -= count_leading_zeros(*buff) - (BITS_PER_LONG - 8);\r\nsg_miter_stop(&miter);\r\nnlimbs = DIV_ROUND_UP(nbytes, BYTES_PER_MPI_LIMB);\r\nval = mpi_alloc(nlimbs);\r\nif (!val)\r\nreturn NULL;\r\nval->nbits = nbits;\r\nval->sign = 0;\r\nval->nlimbs = nlimbs;\r\nif (nbytes == 0)\r\nreturn val;\r\nj = nlimbs - 1;\r\na = 0;\r\nz = BYTES_PER_MPI_LIMB - nbytes % BYTES_PER_MPI_LIMB;\r\nz %= BYTES_PER_MPI_LIMB;\r\nwhile (sg_miter_next(&miter)) {\r\nbuff = miter.addr;\r\nlen = miter.length;\r\nfor (x = 0; x < len; x++) {\r\na <<= 8;\r\na |= *buff++;\r\nif (((z + x + 1) % BYTES_PER_MPI_LIMB) == 0) {\r\nval->d[j--] = a;\r\na = 0;\r\n}\r\n}\r\nz += x;\r\n}\r\nreturn val;\r\n}
