static void db9_saturn_write_sub(struct parport *port, int type, unsigned char data, int powered, int pwr_sub)\r\n{\r\nunsigned char c;\r\nswitch (type) {\r\ncase 1:\r\nc = 0x80 | 0x30 | (powered ? 0x08 : 0) | (pwr_sub ? 0x04 : 0) | data;\r\nparport_write_data(port, c);\r\nbreak;\r\ncase 2:\r\nc = 0x40 | data << 4 | (powered ? 0x08 : 0) | (pwr_sub ? 0x04 : 0) | 0x03;\r\nparport_write_data(port, c);\r\nbreak;\r\ncase 0:\r\nc = ((((data & 2) ? 2 : 0) | ((data & 1) ? 4 : 0)) ^ 0x02) | !powered;\r\nparport_write_control(port, c);\r\nbreak;\r\n}\r\n}\r\nstatic unsigned char db9_saturn_read_sub(struct parport *port, int type)\r\n{\r\nunsigned char data;\r\nif (type) {\r\ndata = parport_read_status(port) ^ 0x80;\r\nreturn (data & 0x80 ? 1 : 0) | (data & 0x40 ? 2 : 0)\r\n| (data & 0x20 ? 4 : 0) | (data & 0x10 ? 8 : 0);\r\n} else {\r\ndata = parport_read_data(port) & 0x0f;\r\nreturn (data & 0x8 ? 1 : 0) | (data & 0x4 ? 2 : 0)\r\n| (data & 0x2 ? 4 : 0) | (data & 0x1 ? 8 : 0);\r\n}\r\n}\r\nstatic unsigned char db9_saturn_read_analog(struct parport *port, int type, int powered)\r\n{\r\nunsigned char data;\r\ndb9_saturn_write_sub(port, type, 0, powered, 0);\r\nudelay(DB9_SATURN_DELAY);\r\ndata = db9_saturn_read_sub(port, type) << 4;\r\ndb9_saturn_write_sub(port, type, 2, powered, 0);\r\nudelay(DB9_SATURN_DELAY);\r\ndata |= db9_saturn_read_sub(port, type);\r\nreturn data;\r\n}\r\nstatic unsigned char db9_saturn_read_packet(struct parport *port, unsigned char *data, int type, int powered)\r\n{\r\nint i, j;\r\nunsigned char tmp;\r\ndb9_saturn_write_sub(port, type, 3, powered, 0);\r\ndata[0] = db9_saturn_read_sub(port, type);\r\nswitch (data[0] & 0x0f) {\r\ncase 0xf:\r\nreturn data[0] = 0xff;\r\ncase 0x4: case 0x4 | 0x8:\r\ndb9_saturn_write_sub(port, type, 0, powered, 1);\r\ndata[2] = db9_saturn_read_sub(port, type) << 4;\r\ndb9_saturn_write_sub(port, type, 2, powered, 1);\r\ndata[1] = db9_saturn_read_sub(port, type) << 4;\r\ndb9_saturn_write_sub(port, type, 1, powered, 1);\r\ndata[1] |= db9_saturn_read_sub(port, type);\r\ndb9_saturn_write_sub(port, type, 3, powered, 1);\r\ndata[2] |= data[0];\r\nreturn data[0] = 0x02;\r\ncase 0x1:\r\ndb9_saturn_write_sub(port, type, 2, powered, 0);\r\nudelay(DB9_SATURN_DELAY);\r\ndata[0] = db9_saturn_read_analog(port, type, powered);\r\nif (data[0] != 0x41) {\r\nfor (i = 0; i < (data[0] & 0x0f); i++)\r\ndata[i + 1] = db9_saturn_read_analog(port, type, powered);\r\ndb9_saturn_write_sub(port, type, 3, powered, 0);\r\nreturn data[0];\r\n} else {\r\nif (db9_saturn_read_analog(port, type, powered) != 0x60)\r\nreturn data[0] = 0xff;\r\nfor (i = 0; i < 60; i += 10) {\r\ndata[i] = db9_saturn_read_analog(port, type, powered);\r\nif (data[i] != 0xff)\r\nfor (j = 0; j < (data[i] & 0x0f); j++)\r\ndata[i + j + 1] = db9_saturn_read_analog(port, type, powered);\r\n}\r\ndb9_saturn_write_sub(port, type, 3, powered, 0);\r\nreturn 0x41;\r\n}\r\ncase 0x0:\r\ndb9_saturn_write_sub(port, type, 2, powered, 0);\r\nudelay(DB9_SATURN_DELAY);\r\ntmp = db9_saturn_read_analog(port, type, powered);\r\nif (tmp == 0xff) {\r\nfor (i = 0; i < 3; i++)\r\ndata[i + 1] = db9_saturn_read_analog(port, type, powered);\r\ndb9_saturn_write_sub(port, type, 3, powered, 0);\r\nreturn data[0] = 0xe3;\r\n}\r\ndefault:\r\nreturn data[0];\r\n}\r\n}\r\nstatic int db9_saturn_report(unsigned char id, unsigned char data[60], struct input_dev *devs[], int n, int max_pads)\r\n{\r\nstruct input_dev *dev;\r\nint tmp, i, j;\r\ntmp = (id == 0x41) ? 60 : 10;\r\nfor (j = 0; j < tmp && n < max_pads; j += 10, n++) {\r\ndev = devs[n];\r\nswitch (data[j]) {\r\ncase 0x16:\r\ninput_report_abs(dev, db9_abs[5], data[j + 6]);\r\ncase 0x15:\r\ninput_report_abs(dev, db9_abs[3], data[j + 4]);\r\ninput_report_abs(dev, db9_abs[4], data[j + 5]);\r\ncase 0x13:\r\ninput_report_abs(dev, db9_abs[2], data[j + 3]);\r\ncase 0x34:\r\ncase 0x02:\r\ninput_report_abs(dev, db9_abs[0], !(data[j + 1] & 128) - !(data[j + 1] & 64));\r\ninput_report_abs(dev, db9_abs[1], !(data[j + 1] & 32) - !(data[j + 1] & 16));\r\nfor (i = 0; i < 9; i++)\r\ninput_report_key(dev, db9_cd32_btn[i], ~data[j + db9_saturn_byte[i]] & db9_saturn_mask[i]);\r\nbreak;\r\ncase 0x19:\r\ninput_report_abs(dev, db9_abs[0], !(data[j + 1] & 128) - !(data[j + 1] & 64));\r\ninput_report_abs(dev, db9_abs[1], !(data[j + 1] & 32) - !(data[j + 1] & 16));\r\nfor (i = 0; i < 9; i++)\r\ninput_report_key(dev, db9_cd32_btn[i], ~data[j + db9_saturn_byte[i]] & db9_saturn_mask[i]);\r\ninput_report_abs(dev, db9_abs[2], data[j + 3]);\r\ninput_report_abs(dev, db9_abs[3], data[j + 4]);\r\ninput_report_abs(dev, db9_abs[4], data[j + 5]);\r\ninput_report_abs(dev, db9_abs[6], data[j + 7]);\r\ninput_report_abs(dev, db9_abs[7], data[j + 8]);\r\ninput_report_abs(dev, db9_abs[5], data[j + 9]);\r\nbreak;\r\ncase 0xd3:\r\ninput_report_key(dev, BTN_A, data[j + 3] & 0x80);\r\ninput_report_abs(dev, db9_abs[2], data[j + 3] & 0x7f);\r\nbreak;\r\ncase 0xe3:\r\ninput_report_key(dev, BTN_START, data[j + 1] & 0x08);\r\ninput_report_key(dev, BTN_A, data[j + 1] & 0x04);\r\ninput_report_key(dev, BTN_C, data[j + 1] & 0x02);\r\ninput_report_key(dev, BTN_B, data[j + 1] & 0x01);\r\ninput_report_abs(dev, db9_abs[2], data[j + 2] ^ 0x80);\r\ninput_report_abs(dev, db9_abs[3], (0xff-(data[j + 3] ^ 0x80))+1);\r\nbreak;\r\ncase 0xff:\r\ndefault:\r\ninput_report_abs(dev, db9_abs[0], 0);\r\ninput_report_abs(dev, db9_abs[1], 0);\r\nfor (i = 0; i < 9; i++)\r\ninput_report_key(dev, db9_cd32_btn[i], 0);\r\nbreak;\r\n}\r\n}\r\nreturn n;\r\n}\r\nstatic int db9_saturn(int mode, struct parport *port, struct input_dev *devs[])\r\n{\r\nunsigned char id, data[60];\r\nint type, n, max_pads;\r\nint tmp, i;\r\nswitch (mode) {\r\ncase DB9_SATURN_PAD:\r\ntype = 0;\r\nn = 1;\r\nbreak;\r\ncase DB9_SATURN_DPP:\r\ntype = 1;\r\nn = 1;\r\nbreak;\r\ncase DB9_SATURN_DPP_2:\r\ntype = 1;\r\nn = 2;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nmax_pads = min(db9_modes[mode].n_pads, DB9_MAX_DEVICES);\r\nfor (tmp = 0, i = 0; i < n; i++) {\r\nid = db9_saturn_read_packet(port, data, type + i, 1);\r\ntmp = db9_saturn_report(id, data, devs, tmp, max_pads);\r\n}\r\nreturn 0;\r\n}\r\nstatic void db9_timer(unsigned long private)\r\n{\r\nstruct db9 *db9 = (void *) private;\r\nstruct parport *port = db9->pd->port;\r\nstruct input_dev *dev = db9->dev[0];\r\nstruct input_dev *dev2 = db9->dev[1];\r\nint data, i;\r\nswitch (db9->mode) {\r\ncase DB9_MULTI_0802_2:\r\ndata = parport_read_data(port) >> 3;\r\ninput_report_abs(dev2, ABS_X, (data & DB9_RIGHT ? 0 : 1) - (data & DB9_LEFT ? 0 : 1));\r\ninput_report_abs(dev2, ABS_Y, (data & DB9_DOWN ? 0 : 1) - (data & DB9_UP ? 0 : 1));\r\ninput_report_key(dev2, BTN_TRIGGER, ~data & DB9_FIRE1);\r\ncase DB9_MULTI_0802:\r\ndata = parport_read_status(port) >> 3;\r\ninput_report_abs(dev, ABS_X, (data & DB9_RIGHT ? 0 : 1) - (data & DB9_LEFT ? 0 : 1));\r\ninput_report_abs(dev, ABS_Y, (data & DB9_DOWN ? 0 : 1) - (data & DB9_UP ? 0 : 1));\r\ninput_report_key(dev, BTN_TRIGGER, data & DB9_FIRE1);\r\nbreak;\r\ncase DB9_MULTI_STICK:\r\ndata = parport_read_data(port);\r\ninput_report_abs(dev, ABS_X, (data & DB9_RIGHT ? 0 : 1) - (data & DB9_LEFT ? 0 : 1));\r\ninput_report_abs(dev, ABS_Y, (data & DB9_DOWN ? 0 : 1) - (data & DB9_UP ? 0 : 1));\r\ninput_report_key(dev, BTN_TRIGGER, ~data & DB9_FIRE1);\r\nbreak;\r\ncase DB9_MULTI2_STICK:\r\ndata = parport_read_data(port);\r\ninput_report_abs(dev, ABS_X, (data & DB9_RIGHT ? 0 : 1) - (data & DB9_LEFT ? 0 : 1));\r\ninput_report_abs(dev, ABS_Y, (data & DB9_DOWN ? 0 : 1) - (data & DB9_UP ? 0 : 1));\r\ninput_report_key(dev, BTN_TRIGGER, ~data & DB9_FIRE1);\r\ninput_report_key(dev, BTN_THUMB, ~data & DB9_FIRE2);\r\nbreak;\r\ncase DB9_GENESIS_PAD:\r\nparport_write_control(port, DB9_NOSELECT);\r\ndata = parport_read_data(port);\r\ninput_report_abs(dev, ABS_X, (data & DB9_RIGHT ? 0 : 1) - (data & DB9_LEFT ? 0 : 1));\r\ninput_report_abs(dev, ABS_Y, (data & DB9_DOWN ? 0 : 1) - (data & DB9_UP ? 0 : 1));\r\ninput_report_key(dev, BTN_B, ~data & DB9_FIRE1);\r\ninput_report_key(dev, BTN_C, ~data & DB9_FIRE2);\r\nparport_write_control(port, DB9_NORMAL);\r\ndata = parport_read_data(port);\r\ninput_report_key(dev, BTN_A, ~data & DB9_FIRE1);\r\ninput_report_key(dev, BTN_START, ~data & DB9_FIRE2);\r\nbreak;\r\ncase DB9_GENESIS5_PAD:\r\nparport_write_control(port, DB9_NOSELECT);\r\ndata = parport_read_data(port);\r\ninput_report_abs(dev, ABS_X, (data & DB9_RIGHT ? 0 : 1) - (data & DB9_LEFT ? 0 : 1));\r\ninput_report_abs(dev, ABS_Y, (data & DB9_DOWN ? 0 : 1) - (data & DB9_UP ? 0 : 1));\r\ninput_report_key(dev, BTN_B, ~data & DB9_FIRE1);\r\ninput_report_key(dev, BTN_C, ~data & DB9_FIRE2);\r\nparport_write_control(port, DB9_NORMAL);\r\ndata = parport_read_data(port);\r\ninput_report_key(dev, BTN_A, ~data & DB9_FIRE1);\r\ninput_report_key(dev, BTN_X, ~data & DB9_FIRE2);\r\ninput_report_key(dev, BTN_Y, ~data & DB9_LEFT);\r\ninput_report_key(dev, BTN_START, ~data & DB9_RIGHT);\r\nbreak;\r\ncase DB9_GENESIS6_PAD:\r\nparport_write_control(port, DB9_NOSELECT);\r\nudelay(DB9_GENESIS6_DELAY);\r\ndata = parport_read_data(port);\r\ninput_report_abs(dev, ABS_X, (data & DB9_RIGHT ? 0 : 1) - (data & DB9_LEFT ? 0 : 1));\r\ninput_report_abs(dev, ABS_Y, (data & DB9_DOWN ? 0 : 1) - (data & DB9_UP ? 0 : 1));\r\ninput_report_key(dev, BTN_B, ~data & DB9_FIRE1);\r\ninput_report_key(dev, BTN_C, ~data & DB9_FIRE2);\r\nparport_write_control(port, DB9_NORMAL);\r\nudelay(DB9_GENESIS6_DELAY);\r\ndata = parport_read_data(port);\r\ninput_report_key(dev, BTN_A, ~data & DB9_FIRE1);\r\ninput_report_key(dev, BTN_START, ~data & DB9_FIRE2);\r\nparport_write_control(port, DB9_NOSELECT);\r\nudelay(DB9_GENESIS6_DELAY);\r\nparport_write_control(port, DB9_NORMAL);\r\nudelay(DB9_GENESIS6_DELAY);\r\nparport_write_control(port, DB9_NOSELECT);\r\nudelay(DB9_GENESIS6_DELAY);\r\ndata=parport_read_data(port);\r\ninput_report_key(dev, BTN_X, ~data & DB9_LEFT);\r\ninput_report_key(dev, BTN_Y, ~data & DB9_DOWN);\r\ninput_report_key(dev, BTN_Z, ~data & DB9_UP);\r\ninput_report_key(dev, BTN_MODE, ~data & DB9_RIGHT);\r\nparport_write_control(port, DB9_NORMAL);\r\nudelay(DB9_GENESIS6_DELAY);\r\nparport_write_control(port, DB9_NOSELECT);\r\nudelay(DB9_GENESIS6_DELAY);\r\nparport_write_control(port, DB9_NORMAL);\r\nbreak;\r\ncase DB9_SATURN_PAD:\r\ncase DB9_SATURN_DPP:\r\ncase DB9_SATURN_DPP_2:\r\ndb9_saturn(db9->mode, port, db9->dev);\r\nbreak;\r\ncase DB9_CD32_PAD:\r\ndata = parport_read_data(port);\r\ninput_report_abs(dev, ABS_X, (data & DB9_RIGHT ? 0 : 1) - (data & DB9_LEFT ? 0 : 1));\r\ninput_report_abs(dev, ABS_Y, (data & DB9_DOWN ? 0 : 1) - (data & DB9_UP ? 0 : 1));\r\nparport_write_control(port, 0x0a);\r\nfor (i = 0; i < 7; i++) {\r\ndata = parport_read_data(port);\r\nparport_write_control(port, 0x02);\r\nparport_write_control(port, 0x0a);\r\ninput_report_key(dev, db9_cd32_btn[i], ~data & DB9_FIRE2);\r\n}\r\nparport_write_control(port, 0x00);\r\nbreak;\r\n}\r\ninput_sync(dev);\r\nmod_timer(&db9->timer, jiffies + DB9_REFRESH_TIME);\r\n}\r\nstatic int db9_open(struct input_dev *dev)\r\n{\r\nstruct db9 *db9 = input_get_drvdata(dev);\r\nstruct parport *port = db9->pd->port;\r\nint err;\r\nerr = mutex_lock_interruptible(&db9->mutex);\r\nif (err)\r\nreturn err;\r\nif (!db9->used++) {\r\nparport_claim(db9->pd);\r\nparport_write_data(port, 0xff);\r\nif (db9_modes[db9->mode].reverse) {\r\nparport_data_reverse(port);\r\nparport_write_control(port, DB9_NORMAL);\r\n}\r\nmod_timer(&db9->timer, jiffies + DB9_REFRESH_TIME);\r\n}\r\nmutex_unlock(&db9->mutex);\r\nreturn 0;\r\n}\r\nstatic void db9_close(struct input_dev *dev)\r\n{\r\nstruct db9 *db9 = input_get_drvdata(dev);\r\nstruct parport *port = db9->pd->port;\r\nmutex_lock(&db9->mutex);\r\nif (!--db9->used) {\r\ndel_timer_sync(&db9->timer);\r\nparport_write_control(port, 0x00);\r\nparport_data_forward(port);\r\nparport_release(db9->pd);\r\n}\r\nmutex_unlock(&db9->mutex);\r\n}\r\nstatic void db9_attach(struct parport *pp)\r\n{\r\nstruct db9 *db9;\r\nconst struct db9_mode_data *db9_mode;\r\nstruct pardevice *pd;\r\nstruct input_dev *input_dev;\r\nint i, j, port_idx;\r\nint mode;\r\nstruct pardev_cb db9_parport_cb;\r\nfor (port_idx = 0; port_idx < DB9_MAX_PORTS; port_idx++) {\r\nif (db9_cfg[port_idx].nargs == 0 ||\r\ndb9_cfg[port_idx].args[DB9_ARG_PARPORT] < 0)\r\ncontinue;\r\nif (db9_cfg[port_idx].args[DB9_ARG_PARPORT] == pp->number)\r\nbreak;\r\n}\r\nif (port_idx == DB9_MAX_PORTS) {\r\npr_debug("Not using parport%d.\n", pp->number);\r\nreturn;\r\n}\r\nmode = db9_cfg[port_idx].args[DB9_ARG_MODE];\r\nif (mode < 1 || mode >= DB9_MAX_PAD || !db9_modes[mode].n_buttons) {\r\nprintk(KERN_ERR "db9.c: Bad device type %d\n", mode);\r\nreturn;\r\n}\r\ndb9_mode = &db9_modes[mode];\r\nif (db9_mode->bidirectional && !(pp->modes & PARPORT_MODE_TRISTATE)) {\r\nprintk(KERN_ERR "db9.c: specified parport is not bidirectional\n");\r\nreturn;\r\n}\r\nmemset(&db9_parport_cb, 0, sizeof(db9_parport_cb));\r\ndb9_parport_cb.flags = PARPORT_FLAG_EXCL;\r\npd = parport_register_dev_model(pp, "db9", &db9_parport_cb, port_idx);\r\nif (!pd) {\r\nprintk(KERN_ERR "db9.c: parport busy already - lp.o loaded?\n");\r\nreturn;\r\n}\r\ndb9 = kzalloc(sizeof(struct db9), GFP_KERNEL);\r\nif (!db9)\r\ngoto err_unreg_pardev;\r\nmutex_init(&db9->mutex);\r\ndb9->pd = pd;\r\ndb9->mode = mode;\r\ndb9->parportno = pp->number;\r\nsetup_timer(&db9->timer, db9_timer, (long)db9);\r\nfor (i = 0; i < (min(db9_mode->n_pads, DB9_MAX_DEVICES)); i++) {\r\ndb9->dev[i] = input_dev = input_allocate_device();\r\nif (!input_dev) {\r\nprintk(KERN_ERR "db9.c: Not enough memory for input device\n");\r\ngoto err_unreg_devs;\r\n}\r\nsnprintf(db9->phys[i], sizeof(db9->phys[i]),\r\n"%s/input%d", db9->pd->port->name, i);\r\ninput_dev->name = db9_mode->name;\r\ninput_dev->phys = db9->phys[i];\r\ninput_dev->id.bustype = BUS_PARPORT;\r\ninput_dev->id.vendor = 0x0002;\r\ninput_dev->id.product = mode;\r\ninput_dev->id.version = 0x0100;\r\ninput_set_drvdata(input_dev, db9);\r\ninput_dev->open = db9_open;\r\ninput_dev->close = db9_close;\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\nfor (j = 0; j < db9_mode->n_buttons; j++)\r\nset_bit(db9_mode->buttons[j], input_dev->keybit);\r\nfor (j = 0; j < db9_mode->n_axis; j++) {\r\nif (j < 2)\r\ninput_set_abs_params(input_dev, db9_abs[j], -1, 1, 0, 0);\r\nelse\r\ninput_set_abs_params(input_dev, db9_abs[j], 1, 255, 0, 0);\r\n}\r\nif (input_register_device(input_dev))\r\ngoto err_free_dev;\r\n}\r\ndb9_base[port_idx] = db9;\r\nreturn;\r\nerr_free_dev:\r\ninput_free_device(db9->dev[i]);\r\nerr_unreg_devs:\r\nwhile (--i >= 0)\r\ninput_unregister_device(db9->dev[i]);\r\nkfree(db9);\r\nerr_unreg_pardev:\r\nparport_unregister_device(pd);\r\n}\r\nstatic void db9_detach(struct parport *port)\r\n{\r\nint i;\r\nstruct db9 *db9;\r\nfor (i = 0; i < DB9_MAX_PORTS; i++) {\r\nif (db9_base[i] && db9_base[i]->parportno == port->number)\r\nbreak;\r\n}\r\nif (i == DB9_MAX_PORTS)\r\nreturn;\r\ndb9 = db9_base[i];\r\ndb9_base[i] = NULL;\r\nfor (i = 0; i < min(db9_modes[db9->mode].n_pads, DB9_MAX_DEVICES); i++)\r\ninput_unregister_device(db9->dev[i]);\r\nparport_unregister_device(db9->pd);\r\nkfree(db9);\r\n}\r\nstatic int __init db9_init(void)\r\n{\r\nint i;\r\nint have_dev = 0;\r\nfor (i = 0; i < DB9_MAX_PORTS; i++) {\r\nif (db9_cfg[i].nargs == 0 || db9_cfg[i].args[DB9_ARG_PARPORT] < 0)\r\ncontinue;\r\nif (db9_cfg[i].nargs < 2) {\r\nprintk(KERN_ERR "db9.c: Device type must be specified.\n");\r\nreturn -EINVAL;\r\n}\r\nhave_dev = 1;\r\n}\r\nif (!have_dev)\r\nreturn -ENODEV;\r\nreturn parport_register_driver(&db9_parport_driver);\r\n}\r\nstatic void __exit db9_exit(void)\r\n{\r\nparport_unregister_driver(&db9_parport_driver);\r\n}
