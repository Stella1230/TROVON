static inline void qusb2_setbits(void __iomem *base, u32 offset, u32 val)\r\n{\r\nu32 reg;\r\nreg = readl(base + offset);\r\nreg |= val;\r\nwritel(reg, base + offset);\r\nreadl(base + offset);\r\n}\r\nstatic inline void qusb2_clrbits(void __iomem *base, u32 offset, u32 val)\r\n{\r\nu32 reg;\r\nreg = readl(base + offset);\r\nreg &= ~val;\r\nwritel(reg, base + offset);\r\nreadl(base + offset);\r\n}\r\nstatic inline\r\nvoid qcom_qusb2_phy_configure(void __iomem *base,\r\nconst struct qusb2_phy_init_tbl tbl[], int num)\r\n{\r\nint i;\r\nfor (i = 0; i < num; i++)\r\nwritel(tbl[i].val, base + tbl[i].offset);\r\n}\r\nstatic void qusb2_phy_set_tune2_param(struct qusb2_phy *qphy)\r\n{\r\nstruct device *dev = &qphy->phy->dev;\r\nu8 *val;\r\nval = nvmem_cell_read(qphy->cell, NULL);\r\nif (IS_ERR(val) || !val[0]) {\r\ndev_dbg(dev, "failed to read a valid hs-tx trim value\n");\r\nreturn;\r\n}\r\nqusb2_setbits(qphy->base, QUSB2PHY_PORT_TUNE2, val[0] << 0x4);\r\n}\r\nstatic int qusb2_phy_poweron(struct phy *phy)\r\n{\r\nstruct qusb2_phy *qphy = phy_get_drvdata(phy);\r\nint num = ARRAY_SIZE(qphy->vregs);\r\nint ret;\r\ndev_vdbg(&phy->dev, "%s(): Powering-on QUSB2 phy\n", __func__);\r\nret = regulator_bulk_enable(num, qphy->vregs);\r\nif (ret)\r\nreturn ret;\r\nret = clk_prepare_enable(qphy->iface_clk);\r\nif (ret) {\r\ndev_err(&phy->dev, "failed to enable iface_clk, %d\n", ret);\r\nregulator_bulk_disable(num, qphy->vregs);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qusb2_phy_poweroff(struct phy *phy)\r\n{\r\nstruct qusb2_phy *qphy = phy_get_drvdata(phy);\r\nclk_disable_unprepare(qphy->iface_clk);\r\nregulator_bulk_disable(ARRAY_SIZE(qphy->vregs), qphy->vregs);\r\nreturn 0;\r\n}\r\nstatic int qusb2_phy_init(struct phy *phy)\r\n{\r\nstruct qusb2_phy *qphy = phy_get_drvdata(phy);\r\nunsigned int val;\r\nunsigned int clk_scheme;\r\nint ret;\r\ndev_vdbg(&phy->dev, "%s(): Initializing QUSB2 phy\n", __func__);\r\nret = clk_prepare_enable(qphy->cfg_ahb_clk);\r\nif (ret) {\r\ndev_err(&phy->dev, "failed to enable cfg ahb clock, %d\n", ret);\r\nreturn ret;\r\n}\r\nret = reset_control_assert(qphy->phy_reset);\r\nif (ret) {\r\ndev_err(&phy->dev, "failed to assert phy_reset, %d\n", ret);\r\ngoto disable_ahb_clk;\r\n}\r\nusleep_range(100, 150);\r\nret = reset_control_deassert(qphy->phy_reset);\r\nif (ret) {\r\ndev_err(&phy->dev, "failed to de-assert phy_reset, %d\n", ret);\r\ngoto disable_ahb_clk;\r\n}\r\nqusb2_setbits(qphy->base, QUSB2PHY_PORT_POWERDOWN,\r\nCLAMP_N_EN | FREEZIO_N | POWER_DOWN);\r\nval = readl(qphy->base + QUSB2PHY_PLL_TEST);\r\nqcom_qusb2_phy_configure(qphy->base, qphy->cfg->tbl,\r\nqphy->cfg->tbl_num);\r\nqusb2_phy_set_tune2_param(qphy);\r\nqusb2_clrbits(qphy->base, QUSB2PHY_PORT_POWERDOWN, POWER_DOWN);\r\nusleep_range(150, 160);\r\nqphy->has_se_clk_scheme = true;\r\nif (qphy->tcsr) {\r\nret = regmap_read(qphy->tcsr, qphy->cfg->clk_scheme_offset,\r\n&clk_scheme);\r\nif (ret) {\r\ndev_err(&phy->dev, "failed to read clk scheme reg\n");\r\ngoto assert_phy_reset;\r\n}\r\nif (!(clk_scheme & PHY_CLK_SCHEME_SEL)) {\r\ndev_vdbg(&phy->dev, "%s(): select differential clk\n",\r\n__func__);\r\nqphy->has_se_clk_scheme = false;\r\n} else {\r\ndev_vdbg(&phy->dev, "%s(): select single-ended clk\n",\r\n__func__);\r\n}\r\n}\r\nif (!qphy->has_se_clk_scheme) {\r\nval &= ~CLK_REF_SEL;\r\nret = clk_prepare_enable(qphy->ref_clk);\r\nif (ret) {\r\ndev_err(&phy->dev, "failed to enable ref clk, %d\n",\r\nret);\r\ngoto assert_phy_reset;\r\n}\r\n} else {\r\nval |= CLK_REF_SEL;\r\n}\r\nwritel(val, qphy->base + QUSB2PHY_PLL_TEST);\r\nreadl(qphy->base + QUSB2PHY_PLL_TEST);\r\nusleep_range(100, 110);\r\nval = readb(qphy->base + QUSB2PHY_PLL_STATUS);\r\nif (!(val & PLL_LOCKED)) {\r\ndev_err(&phy->dev,\r\n"QUSB2PHY pll lock failed: status reg = %x\n", val);\r\nret = -EBUSY;\r\ngoto disable_ref_clk;\r\n}\r\nreturn 0;\r\ndisable_ref_clk:\r\nif (!qphy->has_se_clk_scheme)\r\nclk_disable_unprepare(qphy->ref_clk);\r\nassert_phy_reset:\r\nreset_control_assert(qphy->phy_reset);\r\ndisable_ahb_clk:\r\nclk_disable_unprepare(qphy->cfg_ahb_clk);\r\nreturn ret;\r\n}\r\nstatic int qusb2_phy_exit(struct phy *phy)\r\n{\r\nstruct qusb2_phy *qphy = phy_get_drvdata(phy);\r\nqusb2_setbits(qphy->base, QUSB2PHY_PORT_POWERDOWN,\r\nCLAMP_N_EN | FREEZIO_N | POWER_DOWN);\r\nif (!qphy->has_se_clk_scheme)\r\nclk_disable_unprepare(qphy->ref_clk);\r\nreset_control_assert(qphy->phy_reset);\r\nclk_disable_unprepare(qphy->cfg_ahb_clk);\r\nreturn 0;\r\n}\r\nstatic int qusb2_phy_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct qusb2_phy *qphy;\r\nstruct phy_provider *phy_provider;\r\nstruct phy *generic_phy;\r\nstruct resource *res;\r\nint ret, i;\r\nint num;\r\nqphy = devm_kzalloc(dev, sizeof(*qphy), GFP_KERNEL);\r\nif (!qphy)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nqphy->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(qphy->base))\r\nreturn PTR_ERR(qphy->base);\r\nqphy->cfg_ahb_clk = devm_clk_get(dev, "cfg_ahb");\r\nif (IS_ERR(qphy->cfg_ahb_clk)) {\r\nret = PTR_ERR(qphy->cfg_ahb_clk);\r\nif (ret != -EPROBE_DEFER)\r\ndev_err(dev, "failed to get cfg ahb clk, %d\n", ret);\r\nreturn ret;\r\n}\r\nqphy->ref_clk = devm_clk_get(dev, "ref");\r\nif (IS_ERR(qphy->ref_clk)) {\r\nret = PTR_ERR(qphy->ref_clk);\r\nif (ret != -EPROBE_DEFER)\r\ndev_err(dev, "failed to get ref clk, %d\n", ret);\r\nreturn ret;\r\n}\r\nqphy->iface_clk = devm_clk_get(dev, "iface");\r\nif (IS_ERR(qphy->iface_clk)) {\r\nret = PTR_ERR(qphy->iface_clk);\r\nif (ret == -EPROBE_DEFER)\r\nreturn ret;\r\nqphy->iface_clk = NULL;\r\ndev_dbg(dev, "failed to get iface clk, %d\n", ret);\r\n}\r\nqphy->phy_reset = devm_reset_control_get_by_index(&pdev->dev, 0);\r\nif (IS_ERR(qphy->phy_reset)) {\r\ndev_err(dev, "failed to get phy core reset\n");\r\nreturn PTR_ERR(qphy->phy_reset);\r\n}\r\nnum = ARRAY_SIZE(qphy->vregs);\r\nfor (i = 0; i < num; i++)\r\nqphy->vregs[i].supply = qusb2_phy_vreg_names[i];\r\nret = devm_regulator_bulk_get(dev, num, qphy->vregs);\r\nif (ret) {\r\ndev_err(dev, "failed to get regulator supplies\n");\r\nreturn ret;\r\n}\r\nqphy->cfg = of_device_get_match_data(dev);\r\nqphy->tcsr = syscon_regmap_lookup_by_phandle(dev->of_node,\r\n"qcom,tcsr-syscon");\r\nif (IS_ERR(qphy->tcsr)) {\r\ndev_dbg(dev, "failed to lookup TCSR regmap\n");\r\nqphy->tcsr = NULL;\r\n}\r\nqphy->cell = devm_nvmem_cell_get(dev, NULL);\r\nif (IS_ERR(qphy->cell)) {\r\nif (PTR_ERR(qphy->cell) == -EPROBE_DEFER)\r\nreturn -EPROBE_DEFER;\r\nqphy->cell = NULL;\r\ndev_dbg(dev, "failed to lookup tune2 hstx trim value\n");\r\n}\r\ngeneric_phy = devm_phy_create(dev, NULL, &qusb2_phy_gen_ops);\r\nif (IS_ERR(generic_phy)) {\r\nret = PTR_ERR(generic_phy);\r\ndev_err(dev, "failed to create phy, %d\n", ret);\r\nreturn ret;\r\n}\r\nqphy->phy = generic_phy;\r\ndev_set_drvdata(dev, qphy);\r\nphy_set_drvdata(generic_phy, qphy);\r\nphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\r\nif (!IS_ERR(phy_provider))\r\ndev_info(dev, "Registered Qcom-QUSB2 phy\n");\r\nreturn PTR_ERR_OR_ZERO(phy_provider);\r\n}
