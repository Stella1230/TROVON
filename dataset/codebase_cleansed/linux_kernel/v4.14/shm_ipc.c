static bool qtnf_shm_ipc_has_new_data(struct qtnf_shm_ipc *ipc)\r\n{\r\nconst u32 flags = readl(&ipc->shm_region->headroom.hdr.flags);\r\nreturn (flags & QTNF_SHM_IPC_NEW_DATA);\r\n}\r\nstatic void qtnf_shm_handle_new_data(struct qtnf_shm_ipc *ipc)\r\n{\r\nsize_t size;\r\nbool rx_buff_ok = true;\r\nstruct qtnf_shm_ipc_region_header __iomem *shm_reg_hdr;\r\nshm_reg_hdr = &ipc->shm_region->headroom.hdr;\r\nsize = readw(&shm_reg_hdr->data_len);\r\nif (unlikely(size == 0 || size > QTN_IPC_MAX_DATA_SZ)) {\r\npr_err("wrong rx packet size: %zu\n", size);\r\nrx_buff_ok = false;\r\n} else {\r\nmemcpy_fromio(ipc->rx_data, ipc->shm_region->data, size);\r\n}\r\nwritel(QTNF_SHM_IPC_ACK, &shm_reg_hdr->flags);\r\nreadl(&shm_reg_hdr->flags);\r\nipc->interrupt.fn(ipc->interrupt.arg);\r\nif (likely(rx_buff_ok)) {\r\nipc->rx_packet_count++;\r\nipc->rx_callback.fn(ipc->rx_callback.arg, ipc->rx_data, size);\r\n}\r\n}\r\nstatic void qtnf_shm_ipc_irq_work(struct work_struct *work)\r\n{\r\nstruct qtnf_shm_ipc *ipc = container_of(work, struct qtnf_shm_ipc,\r\nirq_work);\r\nwhile (qtnf_shm_ipc_has_new_data(ipc))\r\nqtnf_shm_handle_new_data(ipc);\r\n}\r\nstatic void qtnf_shm_ipc_irq_inbound_handler(struct qtnf_shm_ipc *ipc)\r\n{\r\nu32 flags;\r\nflags = readl(&ipc->shm_region->headroom.hdr.flags);\r\nif (flags & QTNF_SHM_IPC_NEW_DATA)\r\nqueue_work(ipc->workqueue, &ipc->irq_work);\r\n}\r\nstatic void qtnf_shm_ipc_irq_outbound_handler(struct qtnf_shm_ipc *ipc)\r\n{\r\nu32 flags;\r\nif (!READ_ONCE(ipc->waiting_for_ack))\r\nreturn;\r\nflags = readl(&ipc->shm_region->headroom.hdr.flags);\r\nif (flags & QTNF_SHM_IPC_ACK) {\r\nWRITE_ONCE(ipc->waiting_for_ack, 0);\r\ncomplete(&ipc->tx_completion);\r\n}\r\n}\r\nint qtnf_shm_ipc_init(struct qtnf_shm_ipc *ipc,\r\nenum qtnf_shm_ipc_direction direction,\r\nstruct qtnf_shm_ipc_region __iomem *shm_region,\r\nstruct workqueue_struct *workqueue,\r\nconst struct qtnf_shm_ipc_int *interrupt,\r\nconst struct qtnf_shm_ipc_rx_callback *rx_callback)\r\n{\r\nBUILD_BUG_ON(offsetof(struct qtnf_shm_ipc_region, data) !=\r\nQTN_IPC_REG_HDR_SZ);\r\nBUILD_BUG_ON(sizeof(struct qtnf_shm_ipc_region) > QTN_IPC_REG_SZ);\r\nipc->shm_region = shm_region;\r\nipc->direction = direction;\r\nipc->interrupt = *interrupt;\r\nipc->rx_callback = *rx_callback;\r\nipc->tx_packet_count = 0;\r\nipc->rx_packet_count = 0;\r\nipc->workqueue = workqueue;\r\nipc->waiting_for_ack = 0;\r\nipc->tx_timeout_count = 0;\r\nswitch (direction) {\r\ncase QTNF_SHM_IPC_OUTBOUND:\r\nipc->irq_handler = qtnf_shm_ipc_irq_outbound_handler;\r\nbreak;\r\ncase QTNF_SHM_IPC_INBOUND:\r\nipc->irq_handler = qtnf_shm_ipc_irq_inbound_handler;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nINIT_WORK(&ipc->irq_work, qtnf_shm_ipc_irq_work);\r\ninit_completion(&ipc->tx_completion);\r\nreturn 0;\r\n}\r\nvoid qtnf_shm_ipc_free(struct qtnf_shm_ipc *ipc)\r\n{\r\ncomplete_all(&ipc->tx_completion);\r\n}\r\nint qtnf_shm_ipc_send(struct qtnf_shm_ipc *ipc, const u8 *buf, size_t size)\r\n{\r\nint ret = 0;\r\nstruct qtnf_shm_ipc_region_header __iomem *shm_reg_hdr;\r\nshm_reg_hdr = &ipc->shm_region->headroom.hdr;\r\nif (unlikely(size > QTN_IPC_MAX_DATA_SZ))\r\nreturn -E2BIG;\r\nipc->tx_packet_count++;\r\nwritew(size, &shm_reg_hdr->data_len);\r\nmemcpy_toio(ipc->shm_region->data, buf, size);\r\ndma_wmb();\r\nWRITE_ONCE(ipc->waiting_for_ack, 1);\r\nwmb();\r\nwritel(QTNF_SHM_IPC_NEW_DATA, &shm_reg_hdr->flags);\r\nreadl(&shm_reg_hdr->flags);\r\nipc->interrupt.fn(ipc->interrupt.arg);\r\nif (!wait_for_completion_timeout(&ipc->tx_completion,\r\nQTN_SHM_IPC_ACK_TIMEOUT)) {\r\nret = -ETIMEDOUT;\r\nipc->tx_timeout_count++;\r\npr_err("TX ACK timeout\n");\r\n}\r\nWRITE_ONCE(ipc->waiting_for_ack, 0);\r\nreturn ret;\r\n}
