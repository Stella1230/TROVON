static int acpi_aml_set_fl(int fd, int flags)\r\n{\r\nint ret;\r\nret = fcntl(fd, F_GETFL, 0);\r\nif (ret < 0) {\r\nperror("fcntl(F_GETFL)");\r\nreturn ret;\r\n}\r\nflags |= ret;\r\nret = fcntl(fd, F_SETFL, flags);\r\nif (ret < 0) {\r\nperror("fcntl(F_SETFL)");\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic int acpi_aml_set_fd(int fd, int maxfd, fd_set *set)\r\n{\r\nif (fd > maxfd)\r\nmaxfd = fd;\r\nFD_SET(fd, set);\r\nreturn maxfd;\r\n}\r\nstatic int acpi_aml_read(int fd, struct circ_buf *crc)\r\n{\r\nchar *p;\r\nint len;\r\np = &crc->buf[crc->head];\r\nlen = circ_space_to_end(crc);\r\nlen = read(fd, p, len);\r\nif (len < 0)\r\nperror("read");\r\nelse if (len > 0)\r\ncrc->head = (crc->head + len) & (ACPI_AML_BUF_SIZE - 1);\r\nreturn len;\r\n}\r\nstatic int acpi_aml_read_batch_cmd(int unused, struct circ_buf *crc)\r\n{\r\nchar *p;\r\nint len;\r\nint remained = strlen(acpi_aml_batch_pos);\r\np = &crc->buf[crc->head];\r\nlen = circ_space_to_end(crc);\r\nif (len > remained) {\r\nmemcpy(p, acpi_aml_batch_pos, remained);\r\nacpi_aml_batch_pos += remained;\r\nlen = remained;\r\n} else {\r\nmemcpy(p, acpi_aml_batch_pos, len);\r\nacpi_aml_batch_pos += len;\r\n}\r\nif (len > 0)\r\ncrc->head = (crc->head + len) & (ACPI_AML_BUF_SIZE - 1);\r\nreturn len;\r\n}\r\nstatic int acpi_aml_read_batch_log(int fd, struct circ_buf *crc)\r\n{\r\nchar *p;\r\nint len;\r\nint ret = 0;\r\np = &crc->buf[crc->head];\r\nlen = circ_space_to_end(crc);\r\nwhile (ret < len && acpi_aml_log_state != ACPI_AML_LOG_STOP) {\r\nif (acpi_aml_log_state == ACPI_AML_PROMPT_ROLL) {\r\n*p = acpi_aml_batch_roll;\r\nlen = 1;\r\ncrc->head = (crc->head + 1) & (ACPI_AML_BUF_SIZE - 1);\r\nret += 1;\r\nacpi_aml_log_state = ACPI_AML_LOG_START;\r\n} else {\r\nlen = read(fd, p, 1);\r\nif (len <= 0) {\r\nif (len < 0)\r\nperror("read");\r\nret = len;\r\nbreak;\r\n}\r\n}\r\nswitch (acpi_aml_log_state) {\r\ncase ACPI_AML_LOG_START:\r\nif (*p == '\n')\r\nacpi_aml_log_state = ACPI_AML_PROMPT_START;\r\ncrc->head = (crc->head + 1) & (ACPI_AML_BUF_SIZE - 1);\r\nret += 1;\r\nbreak;\r\ncase ACPI_AML_PROMPT_START:\r\nif (*p == ACPI_DEBUGGER_COMMAND_PROMPT ||\r\n*p == ACPI_DEBUGGER_EXECUTE_PROMPT) {\r\nacpi_aml_batch_prompt = *p;\r\nacpi_aml_log_state = ACPI_AML_PROMPT_STOP;\r\n} else {\r\nif (*p != '\n')\r\nacpi_aml_log_state = ACPI_AML_LOG_START;\r\ncrc->head = (crc->head + 1) & (ACPI_AML_BUF_SIZE - 1);\r\nret += 1;\r\n}\r\nbreak;\r\ncase ACPI_AML_PROMPT_STOP:\r\nif (*p == ' ') {\r\nacpi_aml_log_state = ACPI_AML_LOG_STOP;\r\nacpi_aml_exit = true;\r\n} else {\r\nacpi_aml_log_state = ACPI_AML_PROMPT_ROLL;\r\nacpi_aml_batch_roll = *p;\r\n*p = acpi_aml_batch_prompt;\r\ncrc->head = (crc->head + 1) & (ACPI_AML_BUF_SIZE - 1);\r\nret += 1;\r\n}\r\nbreak;\r\ndefault:\r\nassert(0);\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int acpi_aml_write(int fd, struct circ_buf *crc)\r\n{\r\nchar *p;\r\nint len;\r\np = &crc->buf[crc->tail];\r\nlen = circ_count_to_end(crc);\r\nlen = write(fd, p, len);\r\nif (len < 0)\r\nperror("write");\r\nelse if (len > 0)\r\ncrc->tail = (crc->tail + len) & (ACPI_AML_BUF_SIZE - 1);\r\nreturn len;\r\n}\r\nstatic int acpi_aml_write_batch_log(int fd, struct circ_buf *crc)\r\n{\r\nchar *p;\r\nint len;\r\np = &crc->buf[crc->tail];\r\nlen = circ_count_to_end(crc);\r\nif (!acpi_aml_batch_drain) {\r\nlen = write(fd, p, len);\r\nif (len < 0)\r\nperror("write");\r\n}\r\nif (len > 0)\r\ncrc->tail = (crc->tail + len) & (ACPI_AML_BUF_SIZE - 1);\r\nreturn len;\r\n}\r\nstatic int acpi_aml_write_batch_cmd(int fd, struct circ_buf *crc)\r\n{\r\nint len;\r\nlen = acpi_aml_write(fd, crc);\r\nif (circ_count_to_end(crc) == 0)\r\nacpi_aml_batch_state = ACPI_AML_BATCH_READ_LOG;\r\nreturn len;\r\n}\r\nstatic void acpi_aml_loop(int fd)\r\n{\r\nfd_set rfds;\r\nfd_set wfds;\r\nstruct timeval tv;\r\nint ret;\r\nint maxfd = 0;\r\nif (acpi_aml_mode == ACPI_AML_BATCH) {\r\nacpi_aml_log_state = ACPI_AML_LOG_START;\r\nacpi_aml_batch_pos = acpi_aml_batch_cmd;\r\nif (acpi_aml_batch_drain)\r\nacpi_aml_batch_state = ACPI_AML_BATCH_READ_LOG;\r\nelse\r\nacpi_aml_batch_state = ACPI_AML_BATCH_WRITE_CMD;\r\n}\r\nacpi_aml_exit = false;\r\nwhile (!acpi_aml_exit) {\r\ntv.tv_sec = ACPI_AML_SEC_TICK;\r\ntv.tv_usec = 0;\r\nFD_ZERO(&rfds);\r\nFD_ZERO(&wfds);\r\nif (acpi_aml_cmd_space()) {\r\nif (acpi_aml_mode == ACPI_AML_INTERACTIVE)\r\nmaxfd = acpi_aml_set_fd(STDIN_FILENO, maxfd, &rfds);\r\nelse if (strlen(acpi_aml_batch_pos) &&\r\nacpi_aml_batch_state == ACPI_AML_BATCH_WRITE_CMD)\r\nACPI_AML_BATCH_DO(STDIN_FILENO, read, cmd, ret);\r\n}\r\nif (acpi_aml_cmd_count() &&\r\n(acpi_aml_mode == ACPI_AML_INTERACTIVE ||\r\nacpi_aml_batch_state == ACPI_AML_BATCH_WRITE_CMD))\r\nmaxfd = acpi_aml_set_fd(fd, maxfd, &wfds);\r\nif (acpi_aml_log_space() &&\r\n(acpi_aml_mode == ACPI_AML_INTERACTIVE ||\r\nacpi_aml_batch_state == ACPI_AML_BATCH_READ_LOG))\r\nmaxfd = acpi_aml_set_fd(fd, maxfd, &rfds);\r\nif (acpi_aml_log_count())\r\nmaxfd = acpi_aml_set_fd(STDOUT_FILENO, maxfd, &wfds);\r\nret = select(maxfd+1, &rfds, &wfds, NULL, &tv);\r\nif (ret < 0) {\r\nperror("select");\r\nbreak;\r\n}\r\nif (ret > 0) {\r\nif (FD_ISSET(STDIN_FILENO, &rfds))\r\nACPI_AML_DO(STDIN_FILENO, read, cmd, ret);\r\nif (FD_ISSET(fd, &wfds)) {\r\nif (acpi_aml_mode == ACPI_AML_BATCH)\r\nACPI_AML_BATCH_DO(fd, write, cmd, ret);\r\nelse\r\nACPI_AML_DO(fd, write, cmd, ret);\r\n}\r\nif (FD_ISSET(fd, &rfds)) {\r\nif (acpi_aml_mode == ACPI_AML_BATCH)\r\nACPI_AML_BATCH_DO(fd, read, log, ret);\r\nelse\r\nACPI_AML_DO(fd, read, log, ret);\r\n}\r\nif (FD_ISSET(STDOUT_FILENO, &wfds)) {\r\nif (acpi_aml_mode == ACPI_AML_BATCH)\r\nACPI_AML_BATCH_DO(STDOUT_FILENO, write, log, ret);\r\nelse\r\nACPI_AML_DO(STDOUT_FILENO, write, log, ret);\r\n}\r\n}\r\n}\r\n}\r\nstatic bool acpi_aml_readable(int fd)\r\n{\r\nfd_set rfds;\r\nstruct timeval tv;\r\nint ret;\r\nint maxfd = 0;\r\ntv.tv_sec = 0;\r\ntv.tv_usec = ACPI_AML_USEC_PEEK;\r\nFD_ZERO(&rfds);\r\nmaxfd = acpi_aml_set_fd(fd, maxfd, &rfds);\r\nret = select(maxfd+1, &rfds, NULL, NULL, &tv);\r\nif (ret < 0)\r\nperror("select");\r\nif (ret > 0 && FD_ISSET(fd, &rfds))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void acpi_aml_flush(int fd)\r\n{\r\nwhile (acpi_aml_readable(fd)) {\r\nacpi_aml_batch_drain = true;\r\nacpi_aml_loop(fd);\r\nacpi_aml_batch_drain = false;\r\n}\r\n}\r\nvoid usage(FILE *file, char *progname)\r\n{\r\nfprintf(file, "usage: %s [-b cmd] [-f file] [-h]\n", progname);\r\nfprintf(file, "\nOptions:\n");\r\nfprintf(file, " -b Specify command to be executed in batch mode\n");\r\nfprintf(file, " -f Specify interface file other than");\r\nfprintf(file, " /sys/kernel/debug/acpi/acpidbg\n");\r\nfprintf(file, " -h Print this help message\n");\r\n}\r\nint main(int argc, char **argv)\r\n{\r\nint fd = -1;\r\nint ch;\r\nint len;\r\nint ret = EXIT_SUCCESS;\r\nwhile ((ch = getopt(argc, argv, "b:f:h")) != -1) {\r\nswitch (ch) {\r\ncase 'b':\r\nif (acpi_aml_batch_cmd) {\r\nfprintf(stderr, "Already specify %s\n",\r\nacpi_aml_batch_cmd);\r\nret = EXIT_FAILURE;\r\ngoto exit;\r\n}\r\nlen = strlen(optarg);\r\nacpi_aml_batch_cmd = calloc(len + 2, 1);\r\nif (!acpi_aml_batch_cmd) {\r\nperror("calloc");\r\nret = EXIT_FAILURE;\r\ngoto exit;\r\n}\r\nmemcpy(acpi_aml_batch_cmd, optarg, len);\r\nacpi_aml_batch_cmd[len] = '\n';\r\nacpi_aml_mode = ACPI_AML_BATCH;\r\nbreak;\r\ncase 'f':\r\nacpi_aml_file_path = optarg;\r\nbreak;\r\ncase 'h':\r\nusage(stdout, argv[0]);\r\ngoto exit;\r\nbreak;\r\ncase '?':\r\ndefault:\r\nusage(stderr, argv[0]);\r\nret = EXIT_FAILURE;\r\ngoto exit;\r\nbreak;\r\n}\r\n}\r\nfd = open(acpi_aml_file_path, O_RDWR | O_NONBLOCK);\r\nif (fd < 0) {\r\nperror("open");\r\nret = EXIT_FAILURE;\r\ngoto exit;\r\n}\r\nacpi_aml_set_fl(STDIN_FILENO, O_NONBLOCK);\r\nacpi_aml_set_fl(STDOUT_FILENO, O_NONBLOCK);\r\nif (acpi_aml_mode == ACPI_AML_BATCH)\r\nacpi_aml_flush(fd);\r\nacpi_aml_loop(fd);\r\nexit:\r\nif (fd >= 0)\r\nclose(fd);\r\nif (acpi_aml_batch_cmd)\r\nfree(acpi_aml_batch_cmd);\r\nreturn ret;\r\n}
