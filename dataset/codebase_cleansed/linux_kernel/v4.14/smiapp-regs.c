static uint32_t float_to_u32_mul_1000000(struct i2c_client *client,\r\nuint32_t phloat)\r\n{\r\nint32_t exp;\r\nuint64_t man;\r\nif (phloat >= 0x80000000) {\r\ndev_err(&client->dev, "this is a negative number\n");\r\nreturn 0;\r\n}\r\nif (phloat == 0x7f800000)\r\nreturn ~0;\r\nif ((phloat & 0x7f800000) == 0x7f800000) {\r\ndev_err(&client->dev, "NaN or other special number\n");\r\nreturn 0;\r\n}\r\nif (phloat == 0)\r\nreturn 0;\r\nif (phloat > 0x4f800000)\r\nreturn ~0;\r\nexp = ((int32_t)phloat >> 23) - 127;\r\nman = ((phloat & 0x7fffff) | 0x800000) * 1000000ULL;\r\nif (exp < 0)\r\nman >>= -exp;\r\nelse\r\nman <<= exp;\r\nman >>= 23;\r\nreturn man & 0xffffffff;\r\n}\r\nstatic int ____smiapp_read(struct smiapp_sensor *sensor, u16 reg,\r\nu16 len, u32 *val)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\r\nstruct i2c_msg msg;\r\nunsigned char data[4];\r\nu16 offset = reg;\r\nint r;\r\nmsg.addr = client->addr;\r\nmsg.flags = 0;\r\nmsg.len = 2;\r\nmsg.buf = data;\r\ndata[0] = (u8) (offset >> 8);\r\ndata[1] = (u8) offset;\r\nr = i2c_transfer(client->adapter, &msg, 1);\r\nif (r != 1) {\r\nif (r >= 0)\r\nr = -EBUSY;\r\ngoto err;\r\n}\r\nmsg.len = len;\r\nmsg.flags = I2C_M_RD;\r\nr = i2c_transfer(client->adapter, &msg, 1);\r\nif (r != 1) {\r\nif (r >= 0)\r\nr = -EBUSY;\r\ngoto err;\r\n}\r\n*val = 0;\r\nswitch (len) {\r\ncase SMIAPP_REG_32BIT:\r\n*val = (data[0] << 24) + (data[1] << 16) + (data[2] << 8) +\r\ndata[3];\r\nbreak;\r\ncase SMIAPP_REG_16BIT:\r\n*val = (data[0] << 8) + data[1];\r\nbreak;\r\ncase SMIAPP_REG_8BIT:\r\n*val = data[0];\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nreturn 0;\r\nerr:\r\ndev_err(&client->dev, "read from offset 0x%x error %d\n", offset, r);\r\nreturn r;\r\n}\r\nstatic int ____smiapp_read_8only(struct smiapp_sensor *sensor, u16 reg,\r\nu16 len, u32 *val)\r\n{\r\nunsigned int i;\r\nint rval;\r\n*val = 0;\r\nfor (i = 0; i < len; i++) {\r\nu32 val8;\r\nrval = ____smiapp_read(sensor, reg + i, 1, &val8);\r\nif (rval < 0)\r\nreturn rval;\r\n*val |= val8 << ((len - i - 1) << 3);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __smiapp_read(struct smiapp_sensor *sensor, u32 reg, u32 *val,\r\nbool only8)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\r\nu8 len = SMIAPP_REG_WIDTH(reg);\r\nint rval;\r\nif (len != SMIAPP_REG_8BIT && len != SMIAPP_REG_16BIT\r\n&& len != SMIAPP_REG_32BIT)\r\nreturn -EINVAL;\r\nif (len == SMIAPP_REG_8BIT || !only8)\r\nrval = ____smiapp_read(sensor, SMIAPP_REG_ADDR(reg), len, val);\r\nelse\r\nrval = ____smiapp_read_8only(sensor, SMIAPP_REG_ADDR(reg), len,\r\nval);\r\nif (rval < 0)\r\nreturn rval;\r\nif (reg & SMIAPP_REG_FLAG_FLOAT)\r\n*val = float_to_u32_mul_1000000(client, *val);\r\nreturn 0;\r\n}\r\nint smiapp_read_no_quirk(struct smiapp_sensor *sensor, u32 reg, u32 *val)\r\n{\r\nreturn __smiapp_read(\r\nsensor, reg, val,\r\nsmiapp_needs_quirk(sensor,\r\nSMIAPP_QUIRK_FLAG_8BIT_READ_ONLY));\r\n}\r\nstatic int smiapp_read_quirk(struct smiapp_sensor *sensor, u32 reg, u32 *val,\r\nbool force8)\r\n{\r\nint rval;\r\n*val = 0;\r\nrval = smiapp_call_quirk(sensor, reg_access, false, &reg, val);\r\nif (rval == -ENOIOCTLCMD)\r\nreturn 0;\r\nif (rval < 0)\r\nreturn rval;\r\nif (force8)\r\nreturn __smiapp_read(sensor, reg, val, true);\r\nreturn smiapp_read_no_quirk(sensor, reg, val);\r\n}\r\nint smiapp_read(struct smiapp_sensor *sensor, u32 reg, u32 *val)\r\n{\r\nreturn smiapp_read_quirk(sensor, reg, val, false);\r\n}\r\nint smiapp_read_8only(struct smiapp_sensor *sensor, u32 reg, u32 *val)\r\n{\r\nreturn smiapp_read_quirk(sensor, reg, val, true);\r\n}\r\nint smiapp_write_no_quirk(struct smiapp_sensor *sensor, u32 reg, u32 val)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\r\nstruct i2c_msg msg;\r\nunsigned char data[6];\r\nunsigned int retries;\r\nu8 flags = SMIAPP_REG_FLAGS(reg);\r\nu8 len = SMIAPP_REG_WIDTH(reg);\r\nu16 offset = SMIAPP_REG_ADDR(reg);\r\nint r;\r\nif ((len != SMIAPP_REG_8BIT && len != SMIAPP_REG_16BIT &&\r\nlen != SMIAPP_REG_32BIT) || flags)\r\nreturn -EINVAL;\r\nmsg.addr = client->addr;\r\nmsg.flags = 0;\r\nmsg.len = 2 + len;\r\nmsg.buf = data;\r\ndata[0] = (u8) (reg >> 8);\r\ndata[1] = (u8) (reg & 0xff);\r\nswitch (len) {\r\ncase SMIAPP_REG_8BIT:\r\ndata[2] = val;\r\nbreak;\r\ncase SMIAPP_REG_16BIT:\r\ndata[2] = val >> 8;\r\ndata[3] = val;\r\nbreak;\r\ncase SMIAPP_REG_32BIT:\r\ndata[2] = val >> 24;\r\ndata[3] = val >> 16;\r\ndata[4] = val >> 8;\r\ndata[5] = val;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nfor (retries = 0; retries < 5; retries++) {\r\nr = i2c_transfer(client->adapter, &msg, 1);\r\nif (r == 1) {\r\nif (retries)\r\ndev_err(&client->dev,\r\n"sensor i2c stall encountered. retries: %d\n",\r\nretries);\r\nreturn 0;\r\n}\r\nusleep_range(2000, 2000);\r\n}\r\ndev_err(&client->dev,\r\n"wrote 0x%x to offset 0x%x error %d\n", val, offset, r);\r\nreturn r;\r\n}\r\nint smiapp_write(struct smiapp_sensor *sensor, u32 reg, u32 val)\r\n{\r\nint rval;\r\nrval = smiapp_call_quirk(sensor, reg_access, true, &reg, &val);\r\nif (rval == -ENOIOCTLCMD)\r\nreturn 0;\r\nif (rval < 0)\r\nreturn rval;\r\nreturn smiapp_write_no_quirk(sensor, reg, val);\r\n}
