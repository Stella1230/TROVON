static void pgd_ctor(void *addr)\r\n{\r\nmemset(addr, 0, PGD_TABLE_SIZE);\r\n}\r\nstatic void pud_ctor(void *addr)\r\n{\r\nmemset(addr, 0, PUD_TABLE_SIZE);\r\n}\r\nstatic void pmd_ctor(void *addr)\r\n{\r\nmemset(addr, 0, PMD_TABLE_SIZE);\r\n}\r\nvoid pgtable_cache_add(unsigned shift, void (*ctor)(void *))\r\n{\r\nchar *name;\r\nunsigned long table_size = sizeof(void *) << shift;\r\nunsigned long align = table_size;\r\nunsigned long minalign = max(MAX_PGTABLE_INDEX_SIZE + 1,\r\nHUGEPD_SHIFT_MASK + 1);\r\nstruct kmem_cache *new;\r\nBUG_ON(!is_power_of_2(minalign));\r\nBUG_ON((shift < 1) || (shift > MAX_PGTABLE_INDEX_SIZE));\r\nif (PGT_CACHE(shift))\r\nreturn;\r\nalign = max_t(unsigned long, align, minalign);\r\nname = kasprintf(GFP_KERNEL, "pgtable-2^%d", shift);\r\nnew = kmem_cache_create(name, table_size, align, 0, ctor);\r\nif (!new)\r\npanic("Could not allocate pgtable cache for order %d", shift);\r\nkfree(name);\r\npgtable_cache[shift - 1] = new;\r\npr_debug("Allocated pgtable cache for order %d\n", shift);\r\n}\r\nvoid pgtable_cache_init(void)\r\n{\r\npgtable_cache_add(PGD_INDEX_SIZE, pgd_ctor);\r\nif (PMD_CACHE_INDEX && !PGT_CACHE(PMD_CACHE_INDEX))\r\npgtable_cache_add(PMD_CACHE_INDEX, pmd_ctor);\r\nif (PUD_INDEX_SIZE && !PGT_CACHE(PUD_INDEX_SIZE))\r\npgtable_cache_add(PUD_INDEX_SIZE, pud_ctor);\r\n}
