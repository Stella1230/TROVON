static int cx24120_readreg(struct cx24120_state *state, u8 reg)\r\n{\r\nint ret;\r\nu8 buf = 0;\r\nstruct i2c_msg msg[] = {\r\n{\r\n.addr = state->config->i2c_addr,\r\n.flags = 0,\r\n.len = 1,\r\n.buf = &reg\r\n}, {\r\n.addr = state->config->i2c_addr,\r\n.flags = I2C_M_RD,\r\n.len = 1,\r\n.buf = &buf\r\n}\r\n};\r\nret = i2c_transfer(state->i2c, msg, 2);\r\nif (ret != 2) {\r\nerr("Read error: reg=0x%02x, ret=%i)\n", reg, ret);\r\nreturn ret;\r\n}\r\ndev_dbg(&state->i2c->dev, "reg=0x%02x; data=0x%02x\n", reg, buf);\r\nreturn buf;\r\n}\r\nstatic int cx24120_writereg(struct cx24120_state *state, u8 reg, u8 data)\r\n{\r\nu8 buf[] = { reg, data };\r\nstruct i2c_msg msg = {\r\n.addr = state->config->i2c_addr,\r\n.flags = 0,\r\n.buf = buf,\r\n.len = 2\r\n};\r\nint ret;\r\nret = i2c_transfer(state->i2c, &msg, 1);\r\nif (ret != 1) {\r\nerr("Write error: i2c_write error(err == %i, 0x%02x: 0x%02x)\n",\r\nret, reg, data);\r\nreturn ret;\r\n}\r\ndev_dbg(&state->i2c->dev, "reg=0x%02x; data=0x%02x\n", reg, data);\r\nreturn 0;\r\n}\r\nstatic int cx24120_writeregs(struct cx24120_state *state,\r\nu8 reg, const u8 *values, u16 len, u8 incr)\r\n{\r\nint ret;\r\nu16 max = state->config->i2c_wr_max > 0 ?\r\nstate->config->i2c_wr_max :\r\nlen;\r\nstruct i2c_msg msg = {\r\n.addr = state->config->i2c_addr,\r\n.flags = 0,\r\n};\r\nmsg.buf = kmalloc(max + 1, GFP_KERNEL);\r\nif (!msg.buf)\r\nreturn -ENOMEM;\r\nwhile (len) {\r\nmsg.buf[0] = reg;\r\nmsg.len = len > max ? max : len;\r\nmemcpy(&msg.buf[1], values, msg.len);\r\nlen -= msg.len;\r\nvalues += msg.len;\r\nif (incr)\r\nreg += msg.len;\r\nmsg.len++;\r\nret = i2c_transfer(state->i2c, &msg, 1);\r\nif (ret != 1) {\r\nerr("i2c_write error(err == %i, 0x%02x)\n", ret, reg);\r\ngoto out;\r\n}\r\ndev_dbg(&state->i2c->dev, "reg=0x%02x; data=%*ph\n",\r\nreg, msg.len - 1, msg.buf + 1);\r\n}\r\nret = 0;\r\nout:\r\nkfree(msg.buf);\r\nreturn ret;\r\n}\r\nstruct dvb_frontend *cx24120_attach(const struct cx24120_config *config,\r\nstruct i2c_adapter *i2c)\r\n{\r\nstruct cx24120_state *state;\r\nint demod_rev;\r\ninfo("Conexant cx24120/cx24118 - DVBS/S2 Satellite demod/tuner\n");\r\nstate = kzalloc(sizeof(*state), GFP_KERNEL);\r\nif (!state) {\r\nerr("Unable to allocate memory for cx24120_state\n");\r\ngoto error;\r\n}\r\nstate->config = config;\r\nstate->i2c = i2c;\r\ndemod_rev = cx24120_readreg(state, CX24120_REG_REVISION);\r\nswitch (demod_rev) {\r\ncase 0x07:\r\ninfo("Demod cx24120 rev. 0x07 detected.\n");\r\nbreak;\r\ncase 0x05:\r\ninfo("Demod cx24120 rev. 0x05 detected.\n");\r\nbreak;\r\ndefault:\r\nerr("Unsupported demod revision: 0x%x detected.\n", demod_rev);\r\ngoto error;\r\n}\r\nstate->cold_init = 0;\r\nmemcpy(&state->frontend.ops, &cx24120_ops,\r\nsizeof(struct dvb_frontend_ops));\r\nstate->frontend.demodulator_priv = state;\r\ninfo("Conexant cx24120/cx24118 attached.\n");\r\nreturn &state->frontend;\r\nerror:\r\nkfree(state);\r\nreturn NULL;\r\n}\r\nstatic int cx24120_test_rom(struct cx24120_state *state)\r\n{\r\nint err, ret;\r\nerr = cx24120_readreg(state, 0xfd);\r\nif (err & 4) {\r\nret = cx24120_readreg(state, 0xdf) & 0xfe;\r\nerr = cx24120_writereg(state, 0xdf, ret);\r\n}\r\nreturn err;\r\n}\r\nstatic int cx24120_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nif (c->cnr.stat[0].scale != FE_SCALE_DECIBEL)\r\n*snr = 0;\r\nelse\r\n*snr = div_s64(c->cnr.stat[0].svalue, 100);\r\nreturn 0;\r\n}\r\nstatic int cx24120_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nstruct cx24120_state *state = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nif (c->post_bit_error.stat[0].scale != FE_SCALE_COUNTER) {\r\n*ber = 0;\r\nreturn 0;\r\n}\r\n*ber = c->post_bit_error.stat[0].uvalue - state->ber_prev;\r\nstate->ber_prev = c->post_bit_error.stat[0].uvalue;\r\nreturn 0;\r\n}\r\nstatic void cx24120_check_cmd(struct cx24120_state *state, u8 id)\r\n{\r\nswitch (id) {\r\ncase CMD_TUNEREQUEST:\r\ncase CMD_CLOCK_READ:\r\ncase CMD_DISEQC_MSG1:\r\ncase CMD_DISEQC_MSG2:\r\ncase CMD_SETVOLTAGE:\r\ncase CMD_SETTONE:\r\ncase CMD_DISEQC_BURST:\r\ncx24120_msg_mpeg_output_global_config(state, 0);\r\ndefault:\r\nreturn;\r\n}\r\n}\r\nstatic int cx24120_message_send(struct cx24120_state *state,\r\nstruct cx24120_cmd *cmd)\r\n{\r\nint ficus;\r\nif (state->mpeg_enabled) {\r\ncx24120_check_cmd(state, cmd->id);\r\n}\r\ncx24120_writereg(state, CX24120_REG_CMD_START, cmd->id);\r\ncx24120_writeregs(state, CX24120_REG_CMD_ARGS, &cmd->arg[0],\r\ncmd->len, 1);\r\ncx24120_writereg(state, CX24120_REG_CMD_END, 0x01);\r\nficus = 1000;\r\nwhile (cx24120_readreg(state, CX24120_REG_CMD_END)) {\r\nmsleep(20);\r\nficus -= 20;\r\nif (ficus == 0) {\r\nerr("Error sending message to firmware\n");\r\nreturn -EREMOTEIO;\r\n}\r\n}\r\ndev_dbg(&state->i2c->dev, "sent message 0x%02x\n", cmd->id);\r\nreturn 0;\r\n}\r\nstatic int cx24120_message_sendrcv(struct cx24120_state *state,\r\nstruct cx24120_cmd *cmd, u8 numreg)\r\n{\r\nint ret, i;\r\nif (numreg > CX24120_MAX_CMD_LEN) {\r\nerr("Too many registers to read. cmd->reg = %d", numreg);\r\nreturn -EREMOTEIO;\r\n}\r\nret = cx24120_message_send(state, cmd);\r\nif (ret != 0)\r\nreturn ret;\r\nif (!numreg)\r\nreturn 0;\r\nfor (i = 0; i < numreg; i++)\r\ncmd->arg[i] = cx24120_readreg(state, (cmd->len + i + 1));\r\nreturn 0;\r\n}\r\nstatic int cx24120_read_signal_strength(struct dvb_frontend *fe,\r\nu16 *signal_strength)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nif (c->strength.stat[0].scale != FE_SCALE_RELATIVE)\r\n*signal_strength = 0;\r\nelse\r\n*signal_strength = c->strength.stat[0].uvalue;\r\nreturn 0;\r\n}\r\nstatic int cx24120_msg_mpeg_output_global_config(struct cx24120_state *state,\r\nu8 enable)\r\n{\r\nstruct cx24120_cmd cmd;\r\nint ret;\r\ncmd.id = CMD_MPEG_ONOFF;\r\ncmd.len = 4;\r\ncmd.arg[0] = 0x01;\r\ncmd.arg[1] = 0x00;\r\ncmd.arg[2] = enable ? 0 : (u8)(-1);\r\ncmd.arg[3] = 0x01;\r\nret = cx24120_message_send(state, &cmd);\r\nif (ret != 0) {\r\ndev_dbg(&state->i2c->dev, "failed to %s MPEG output\n",\r\nenable ? "enable" : "disable");\r\nreturn ret;\r\n}\r\nstate->mpeg_enabled = enable;\r\ndev_dbg(&state->i2c->dev, "MPEG output %s\n",\r\nenable ? "enabled" : "disabled");\r\nreturn 0;\r\n}\r\nstatic int cx24120_msg_mpeg_output_config(struct cx24120_state *state, u8 seq)\r\n{\r\nstruct cx24120_cmd cmd;\r\nstruct cx24120_initial_mpeg_config i =\r\nstate->config->initial_mpeg_config;\r\ncmd.id = CMD_MPEG_INIT;\r\ncmd.len = 7;\r\ncmd.arg[0] = seq;\r\ncmd.arg[1] = ((i.x1 & 0x01) << 1) | ((i.x1 >> 1) & 0x01);\r\ncmd.arg[2] = 0x05;\r\ncmd.arg[3] = 0x02;\r\ncmd.arg[4] = ((i.x2 >> 1) & 0x01);\r\ncmd.arg[5] = (i.x2 & 0xf0) | (i.x3 & 0x0f);\r\ncmd.arg[6] = 0x10;\r\nreturn cx24120_message_send(state, &cmd);\r\n}\r\nstatic int cx24120_diseqc_send_burst(struct dvb_frontend *fe,\r\nenum fe_sec_mini_cmd burst)\r\n{\r\nstruct cx24120_state *state = fe->demodulator_priv;\r\nstruct cx24120_cmd cmd;\r\ndev_dbg(&state->i2c->dev, "\n");\r\ncmd.id = CMD_DISEQC_BURST;\r\ncmd.len = 0;\r\ncmd.arg[0] = 0x00;\r\ncmd.arg[1] = (burst == SEC_MINI_B) ? 0x01 : 0x00;\r\nreturn cx24120_message_send(state, &cmd);\r\n}\r\nstatic int cx24120_set_tone(struct dvb_frontend *fe, enum fe_sec_tone_mode tone)\r\n{\r\nstruct cx24120_state *state = fe->demodulator_priv;\r\nstruct cx24120_cmd cmd;\r\ndev_dbg(&state->i2c->dev, "(%d)\n", tone);\r\nif ((tone != SEC_TONE_ON) && (tone != SEC_TONE_OFF)) {\r\nerr("Invalid tone=%d\n", tone);\r\nreturn -EINVAL;\r\n}\r\ncmd.id = CMD_SETTONE;\r\ncmd.len = 4;\r\ncmd.arg[0] = 0x00;\r\ncmd.arg[1] = 0x00;\r\ncmd.arg[2] = 0x00;\r\ncmd.arg[3] = (tone == SEC_TONE_ON) ? 0x01 : 0x00;\r\nreturn cx24120_message_send(state, &cmd);\r\n}\r\nstatic int cx24120_set_voltage(struct dvb_frontend *fe,\r\nenum fe_sec_voltage voltage)\r\n{\r\nstruct cx24120_state *state = fe->demodulator_priv;\r\nstruct cx24120_cmd cmd;\r\ndev_dbg(&state->i2c->dev, "(%d)\n", voltage);\r\ncmd.id = CMD_SETVOLTAGE;\r\ncmd.len = 2;\r\ncmd.arg[0] = 0x00;\r\ncmd.arg[1] = (voltage == SEC_VOLTAGE_18) ? 0x01 : 0x00;\r\nreturn cx24120_message_send(state, &cmd);\r\n}\r\nstatic int cx24120_send_diseqc_msg(struct dvb_frontend *fe,\r\nstruct dvb_diseqc_master_cmd *d)\r\n{\r\nstruct cx24120_state *state = fe->demodulator_priv;\r\nstruct cx24120_cmd cmd;\r\nint back_count;\r\ndev_dbg(&state->i2c->dev, "\n");\r\ncmd.id = CMD_DISEQC_MSG1;\r\ncmd.len = 11;\r\ncmd.arg[0] = 0x00;\r\ncmd.arg[1] = 0x00;\r\ncmd.arg[2] = 0x03;\r\ncmd.arg[3] = 0x16;\r\ncmd.arg[4] = 0x28;\r\ncmd.arg[5] = 0x01;\r\ncmd.arg[6] = 0x01;\r\ncmd.arg[7] = 0x14;\r\ncmd.arg[8] = 0x19;\r\ncmd.arg[9] = 0x14;\r\ncmd.arg[10] = 0x1e;\r\nif (cx24120_message_send(state, &cmd)) {\r\nerr("send 1st message(0x%x) failed\n", cmd.id);\r\nreturn -EREMOTEIO;\r\n}\r\ncmd.id = CMD_DISEQC_MSG2;\r\ncmd.len = d->msg_len + 6;\r\ncmd.arg[0] = 0x00;\r\ncmd.arg[1] = 0x01;\r\ncmd.arg[2] = 0x02;\r\ncmd.arg[3] = 0x00;\r\ncmd.arg[4] = 0x00;\r\ncmd.arg[5] = d->msg_len;\r\nmemcpy(&cmd.arg[6], &d->msg, d->msg_len);\r\nif (cx24120_message_send(state, &cmd)) {\r\nerr("send 2nd message(0x%x) failed\n", cmd.id);\r\nreturn -EREMOTEIO;\r\n}\r\nback_count = 500;\r\ndo {\r\nif (!(cx24120_readreg(state, 0x93) & 0x01)) {\r\ndev_dbg(&state->i2c->dev, "diseqc sequence sent\n");\r\nreturn 0;\r\n}\r\nmsleep(20);\r\nback_count -= 20;\r\n} while (back_count);\r\nerr("Too long waiting for diseqc.\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic void cx24120_get_stats(struct cx24120_state *state)\r\n{\r\nstruct dvb_frontend *fe = &state->frontend;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct cx24120_cmd cmd;\r\nint ret, cnr, msecs;\r\nu16 sig, ucb;\r\nu32 ber;\r\ndev_dbg(&state->i2c->dev, "\n");\r\nif (state->fe_status & FE_HAS_SIGNAL) {\r\ncmd.id = CMD_READ_SNR;\r\ncmd.len = 1;\r\ncmd.arg[0] = 0x00;\r\nret = cx24120_message_send(state, &cmd);\r\nif (ret != 0) {\r\nerr("error reading signal strength\n");\r\nreturn;\r\n}\r\nsig = cx24120_readreg(state, CX24120_REG_SIGSTR_H) >> 6;\r\nsig = sig << 8;\r\nsig |= cx24120_readreg(state, CX24120_REG_SIGSTR_L);\r\ndev_dbg(&state->i2c->dev,\r\n"signal strength from firmware = 0x%x\n", sig);\r\nsig = -100 * sig + 94324;\r\nc->strength.stat[0].scale = FE_SCALE_RELATIVE;\r\nc->strength.stat[0].uvalue = sig;\r\n} else {\r\nc->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\n}\r\nif (state->fe_status & FE_HAS_VITERBI) {\r\ncnr = cx24120_readreg(state, CX24120_REG_QUALITY_H) << 8;\r\ncnr |= cx24120_readreg(state, CX24120_REG_QUALITY_L);\r\ndev_dbg(&state->i2c->dev, "read SNR index = %d\n", cnr);\r\ncnr = cnr * 100;\r\nc->cnr.stat[0].scale = FE_SCALE_DECIBEL;\r\nc->cnr.stat[0].svalue = cnr;\r\n} else {\r\nc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\n}\r\nif (!(state->fe_status & FE_HAS_LOCK)) {\r\nc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->block_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nreturn;\r\n}\r\nif (time_after(jiffies, state->ber_jiffies_stats)) {\r\nmsecs = (state->berw_usecs + 500) / 1000;\r\nstate->ber_jiffies_stats = jiffies + msecs_to_jiffies(msecs);\r\nber = cx24120_readreg(state, CX24120_REG_BER_HH) << 24;\r\nber |= cx24120_readreg(state, CX24120_REG_BER_HL) << 16;\r\nber |= cx24120_readreg(state, CX24120_REG_BER_LH) << 8;\r\nber |= cx24120_readreg(state, CX24120_REG_BER_LL);\r\ndev_dbg(&state->i2c->dev, "read BER index = %d\n", ber);\r\nc->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;\r\nc->post_bit_error.stat[0].uvalue += ber;\r\nc->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;\r\nc->post_bit_count.stat[0].uvalue += CX24120_BER_WSIZE;\r\n}\r\nif (time_after(jiffies, state->per_jiffies_stats)) {\r\nstate->per_jiffies_stats = jiffies + msecs_to_jiffies(1000);\r\nucb = cx24120_readreg(state, CX24120_REG_UCB_H) << 8;\r\nucb |= cx24120_readreg(state, CX24120_REG_UCB_L);\r\ndev_dbg(&state->i2c->dev, "ucblocks = %d\n", ucb);\r\nif (ucb < state->ucb_offset)\r\nstate->ucb_offset = c->block_error.stat[0].uvalue;\r\nc->block_error.stat[0].scale = FE_SCALE_COUNTER;\r\nc->block_error.stat[0].uvalue = ucb + state->ucb_offset;\r\nc->block_count.stat[0].scale = FE_SCALE_COUNTER;\r\nc->block_count.stat[0].uvalue += state->bitrate / 8 / 208;\r\n}\r\n}\r\nstatic int cx24120_read_status(struct dvb_frontend *fe, enum fe_status *status)\r\n{\r\nstruct cx24120_state *state = fe->demodulator_priv;\r\nint lock;\r\nlock = cx24120_readreg(state, CX24120_REG_STATUS);\r\ndev_dbg(&state->i2c->dev, "status = 0x%02x\n", lock);\r\n*status = 0;\r\nif (lock & CX24120_HAS_SIGNAL)\r\n*status = FE_HAS_SIGNAL;\r\nif (lock & CX24120_HAS_CARRIER)\r\n*status |= FE_HAS_CARRIER;\r\nif (lock & CX24120_HAS_VITERBI)\r\n*status |= FE_HAS_VITERBI | FE_HAS_SYNC;\r\nif (lock & CX24120_HAS_LOCK)\r\n*status |= FE_HAS_LOCK;\r\nstate->fe_status = *status;\r\ncx24120_get_stats(state);\r\nif (state->need_clock_set && *status & FE_HAS_LOCK) {\r\ncx24120_set_clock_ratios(fe);\r\nif (!state->mpeg_enabled)\r\ncx24120_msg_mpeg_output_global_config(state, 1);\r\nstate->need_clock_set = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cx24120_get_fec(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct cx24120_state *state = fe->demodulator_priv;\r\nint idx;\r\nint ret;\r\nint fec;\r\nret = cx24120_readreg(state, CX24120_REG_FECMODE);\r\nfec = ret & 0x3f;\r\ndev_dbg(&state->i2c->dev, "raw fec = %d\n", fec);\r\nfor (idx = 0; idx < ARRAY_SIZE(modfec_lookup_table); idx++) {\r\nif (modfec_lookup_table[idx].delsys != state->dcur.delsys)\r\ncontinue;\r\nif (modfec_lookup_table[idx].val != fec)\r\ncontinue;\r\nbreak;\r\n}\r\nif (idx >= ARRAY_SIZE(modfec_lookup_table)) {\r\ndev_dbg(&state->i2c->dev, "couldn't find fec!\n");\r\nreturn -EINVAL;\r\n}\r\nc->modulation = modfec_lookup_table[idx].mod;\r\nc->fec_inner = modfec_lookup_table[idx].fec;\r\nc->pilot = (ret & 0x80) ? PILOT_ON : PILOT_OFF;\r\ndev_dbg(&state->i2c->dev, "mod(%d), fec(%d), pilot(%d)\n",\r\nc->modulation, c->fec_inner, c->pilot);\r\nreturn 0;\r\n}\r\nstatic void cx24120_calculate_ber_window(struct cx24120_state *state, u32 rate)\r\n{\r\nstruct dvb_frontend *fe = &state->frontend;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nu64 tmp;\r\ntmp = (u64)c->symbol_rate * rate;\r\ndo_div(tmp, 256);\r\nstate->bitrate = tmp;\r\ntmp = 1000000ULL * CX24120_BER_WSIZE;\r\ndo_div(tmp, state->bitrate);\r\nstate->berw_usecs = tmp;\r\ndev_dbg(&state->i2c->dev, "bitrate: %u, berw_usecs: %u\n",\r\nstate->bitrate, state->berw_usecs);\r\n}\r\nstatic void cx24120_set_clock_ratios(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct cx24120_state *state = fe->demodulator_priv;\r\nstruct cx24120_cmd cmd;\r\nint ret, idx;\r\nret = cx24120_get_fec(fe);\r\nif (ret != 0)\r\nreturn;\r\nfor (idx = 0; idx < ARRAY_SIZE(clock_ratios_table); idx++) {\r\nif (clock_ratios_table[idx].delsys != state->dcur.delsys)\r\ncontinue;\r\nif (clock_ratios_table[idx].mod != c->modulation)\r\ncontinue;\r\nif (clock_ratios_table[idx].fec != c->fec_inner)\r\ncontinue;\r\nif (clock_ratios_table[idx].pilot != c->pilot)\r\ncontinue;\r\nbreak;\r\n}\r\nif (idx >= ARRAY_SIZE(clock_ratios_table)) {\r\ninfo("Clock ratio not found - data reception in danger\n");\r\nreturn;\r\n}\r\ncmd.id = CMD_CLOCK_READ;\r\ncmd.len = 1;\r\ncmd.arg[0] = 0x00;\r\nret = cx24120_message_sendrcv(state, &cmd, 6);\r\nif (ret != 0)\r\nreturn;\r\ndev_dbg(&state->i2c->dev, "m=%d, n=%d; idx: %d m=%d, n=%d, rate=%d\n",\r\ncmd.arg[2] | (cmd.arg[1] << 8) | (cmd.arg[0] << 16),\r\ncmd.arg[5] | (cmd.arg[4] << 8) | (cmd.arg[3] << 16),\r\nidx,\r\nclock_ratios_table[idx].m_rat,\r\nclock_ratios_table[idx].n_rat,\r\nclock_ratios_table[idx].rate);\r\ncmd.id = CMD_CLOCK_SET;\r\ncmd.len = 10;\r\ncmd.arg[0] = 0;\r\ncmd.arg[1] = 0x10;\r\ncmd.arg[2] = (clock_ratios_table[idx].m_rat >> 16) & 0xff;\r\ncmd.arg[3] = (clock_ratios_table[idx].m_rat >> 8) & 0xff;\r\ncmd.arg[4] = (clock_ratios_table[idx].m_rat >> 0) & 0xff;\r\ncmd.arg[5] = (clock_ratios_table[idx].n_rat >> 16) & 0xff;\r\ncmd.arg[6] = (clock_ratios_table[idx].n_rat >> 8) & 0xff;\r\ncmd.arg[7] = (clock_ratios_table[idx].n_rat >> 0) & 0xff;\r\ncmd.arg[8] = (clock_ratios_table[idx].rate >> 8) & 0xff;\r\ncmd.arg[9] = (clock_ratios_table[idx].rate >> 0) & 0xff;\r\ncx24120_message_send(state, &cmd);\r\ncx24120_calculate_ber_window(state, clock_ratios_table[idx].rate);\r\n}\r\nstatic int cx24120_set_inversion(struct cx24120_state *state,\r\nenum fe_spectral_inversion inversion)\r\n{\r\ndev_dbg(&state->i2c->dev, "(%d)\n", inversion);\r\nswitch (inversion) {\r\ncase INVERSION_OFF:\r\nstate->dnxt.inversion_val = 0x00;\r\nbreak;\r\ncase INVERSION_ON:\r\nstate->dnxt.inversion_val = 0x04;\r\nbreak;\r\ncase INVERSION_AUTO:\r\nstate->dnxt.inversion_val = 0x0c;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nstate->dnxt.inversion = inversion;\r\nreturn 0;\r\n}\r\nstatic int cx24120_set_fec(struct cx24120_state *state, enum fe_modulation mod,\r\nenum fe_code_rate fec)\r\n{\r\nint idx;\r\ndev_dbg(&state->i2c->dev, "(0x%02x,0x%02x)\n", mod, fec);\r\nstate->dnxt.fec = fec;\r\nfor (idx = 0; idx < ARRAY_SIZE(modfec_table); idx++) {\r\nif (modfec_table[idx].delsys != state->dnxt.delsys)\r\ncontinue;\r\nif (modfec_table[idx].mod != mod)\r\ncontinue;\r\nif (modfec_table[idx].fec != fec)\r\ncontinue;\r\nstate->dnxt.fec_mask = 0x00;\r\nstate->dnxt.fec_val = modfec_table[idx].val;\r\nreturn 0;\r\n}\r\nif (state->dnxt.delsys == SYS_DVBS2) {\r\nstate->dnxt.fec_mask = 0x00;\r\nstate->dnxt.fec_val = 0x00;\r\n} else {\r\nstate->dnxt.fec_val = 0x2e;\r\nstate->dnxt.fec_mask = 0xac;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cx24120_set_pilot(struct cx24120_state *state, enum fe_pilot pilot)\r\n{\r\ndev_dbg(&state->i2c->dev, "(%d)\n", pilot);\r\nif (state->dnxt.delsys != SYS_DVBS2) {\r\nstate->dnxt.pilot_val = CX24120_PILOT_OFF;\r\nreturn 0;\r\n}\r\nswitch (pilot) {\r\ncase PILOT_OFF:\r\nstate->dnxt.pilot_val = CX24120_PILOT_OFF;\r\nbreak;\r\ncase PILOT_ON:\r\nstate->dnxt.pilot_val = CX24120_PILOT_ON;\r\nbreak;\r\ncase PILOT_AUTO:\r\ndefault:\r\nstate->dnxt.pilot_val = CX24120_PILOT_AUTO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cx24120_set_symbolrate(struct cx24120_state *state, u32 rate)\r\n{\r\ndev_dbg(&state->i2c->dev, "(%d)\n", rate);\r\nstate->dnxt.symbol_rate = rate;\r\nif (rate > 31000000) {\r\nstate->dnxt.clkdiv = (-(rate < 31000001) & 3) + 2;\r\nstate->dnxt.ratediv = (-(rate < 31000001) & 6) + 4;\r\n} else {\r\nstate->dnxt.clkdiv = 3;\r\nstate->dnxt.ratediv = 6;\r\n}\r\nreturn 0;\r\n}\r\nstatic void cx24120_clone_params(struct dvb_frontend *fe)\r\n{\r\nstruct cx24120_state *state = fe->demodulator_priv;\r\nstate->dcur = state->dnxt;\r\n}\r\nstatic int cx24120_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct cx24120_state *state = fe->demodulator_priv;\r\nstruct cx24120_cmd cmd;\r\nint ret;\r\nswitch (c->delivery_system) {\r\ncase SYS_DVBS2:\r\ndev_dbg(&state->i2c->dev, "DVB-S2\n");\r\nbreak;\r\ncase SYS_DVBS:\r\ndev_dbg(&state->i2c->dev, "DVB-S\n");\r\nbreak;\r\ndefault:\r\ndev_dbg(&state->i2c->dev,\r\n"delivery system(%d) not supported\n",\r\nc->delivery_system);\r\nreturn -EINVAL;\r\n}\r\nstate->dnxt.delsys = c->delivery_system;\r\nstate->dnxt.modulation = c->modulation;\r\nstate->dnxt.frequency = c->frequency;\r\nstate->dnxt.pilot = c->pilot;\r\nret = cx24120_set_inversion(state, c->inversion);\r\nif (ret != 0)\r\nreturn ret;\r\nret = cx24120_set_fec(state, c->modulation, c->fec_inner);\r\nif (ret != 0)\r\nreturn ret;\r\nret = cx24120_set_pilot(state, c->pilot);\r\nif (ret != 0)\r\nreturn ret;\r\nret = cx24120_set_symbolrate(state, c->symbol_rate);\r\nif (ret != 0)\r\nreturn ret;\r\ncx24120_clone_params(fe);\r\ndev_dbg(&state->i2c->dev,\r\n"delsys = %d\n", state->dcur.delsys);\r\ndev_dbg(&state->i2c->dev,\r\n"modulation = %d\n", state->dcur.modulation);\r\ndev_dbg(&state->i2c->dev,\r\n"frequency = %d\n", state->dcur.frequency);\r\ndev_dbg(&state->i2c->dev,\r\n"pilot = %d (val = 0x%02x)\n",\r\nstate->dcur.pilot, state->dcur.pilot_val);\r\ndev_dbg(&state->i2c->dev,\r\n"symbol_rate = %d (clkdiv/ratediv = 0x%02x/0x%02x)\n",\r\nstate->dcur.symbol_rate,\r\nstate->dcur.clkdiv, state->dcur.ratediv);\r\ndev_dbg(&state->i2c->dev,\r\n"FEC = %d (mask/val = 0x%02x/0x%02x)\n",\r\nstate->dcur.fec, state->dcur.fec_mask, state->dcur.fec_val);\r\ndev_dbg(&state->i2c->dev,\r\n"Inversion = %d (val = 0x%02x)\n",\r\nstate->dcur.inversion, state->dcur.inversion_val);\r\nstate->need_clock_set = 1;\r\ncmd.id = CMD_TUNEREQUEST;\r\ncmd.len = 15;\r\ncmd.arg[0] = 0;\r\ncmd.arg[1] = (state->dcur.frequency & 0xff0000) >> 16;\r\ncmd.arg[2] = (state->dcur.frequency & 0x00ff00) >> 8;\r\ncmd.arg[3] = (state->dcur.frequency & 0x0000ff);\r\ncmd.arg[4] = ((state->dcur.symbol_rate / 1000) & 0xff00) >> 8;\r\ncmd.arg[5] = ((state->dcur.symbol_rate / 1000) & 0x00ff);\r\ncmd.arg[6] = state->dcur.inversion;\r\ncmd.arg[7] = state->dcur.fec_val | state->dcur.pilot_val;\r\ncmd.arg[8] = CX24120_SEARCH_RANGE_KHZ >> 8;\r\ncmd.arg[9] = CX24120_SEARCH_RANGE_KHZ & 0xff;\r\ncmd.arg[10] = 0;\r\ncmd.arg[11] = state->dcur.fec_mask;\r\ncmd.arg[12] = state->dcur.ratediv;\r\ncmd.arg[13] = state->dcur.clkdiv;\r\ncmd.arg[14] = 0;\r\nret = cx24120_message_send(state, &cmd);\r\nif (ret != 0)\r\nreturn ret;\r\nret = cx24120_writereg(state, CX24120_REG_CLKDIV, state->dcur.clkdiv);\r\nret = cx24120_readreg(state, CX24120_REG_RATEDIV);\r\nret &= 0xfffffff0;\r\nret |= state->dcur.ratediv;\r\nret = cx24120_writereg(state, CX24120_REG_RATEDIV, ret);\r\nreturn 0;\r\n}\r\nstatic int cx24120_set_vco(struct cx24120_state *state)\r\n{\r\nstruct cx24120_cmd cmd;\r\nu32 nxtal_khz, vco;\r\nu64 inv_vco;\r\nu32 xtal_khz = state->config->xtal_khz;\r\nnxtal_khz = xtal_khz * 4;\r\nvco = nxtal_khz * 10;\r\ninv_vco = DIV_ROUND_CLOSEST_ULL(0x400000000ULL, vco);\r\ndev_dbg(&state->i2c->dev, "xtal=%d, vco=%d, inv_vco=%lld\n",\r\nxtal_khz, vco, inv_vco);\r\ncmd.id = CMD_VCO_SET;\r\ncmd.len = 12;\r\ncmd.arg[0] = (vco >> 16) & 0xff;\r\ncmd.arg[1] = (vco >> 8) & 0xff;\r\ncmd.arg[2] = vco & 0xff;\r\ncmd.arg[3] = (inv_vco >> 8) & 0xff;\r\ncmd.arg[4] = (inv_vco) & 0xff;\r\ncmd.arg[5] = 0x03;\r\ncmd.arg[6] = (nxtal_khz >> 8) & 0xff;\r\ncmd.arg[7] = nxtal_khz & 0xff;\r\ncmd.arg[8] = 0x06;\r\ncmd.arg[9] = 0x03;\r\ncmd.arg[10] = (xtal_khz >> 16) & 0xff;\r\ncmd.arg[11] = xtal_khz & 0xff;\r\nreturn cx24120_message_send(state, &cmd);\r\n}\r\nstatic int cx24120_init(struct dvb_frontend *fe)\r\n{\r\nconst struct firmware *fw;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct cx24120_state *state = fe->demodulator_priv;\r\nstruct cx24120_cmd cmd;\r\nu8 reg;\r\nint ret, i;\r\nunsigned char vers[4];\r\nif (state->cold_init)\r\nreturn 0;\r\ncx24120_writereg(state, 0xea, 0x00);\r\ncx24120_test_rom(state);\r\nreg = cx24120_readreg(state, 0xfb) & 0xfe;\r\ncx24120_writereg(state, 0xfb, reg);\r\nreg = cx24120_readreg(state, 0xfc) & 0xfe;\r\ncx24120_writereg(state, 0xfc, reg);\r\ncx24120_writereg(state, 0xc3, 0x04);\r\ncx24120_writereg(state, 0xc4, 0x04);\r\ncx24120_writereg(state, 0xce, 0x00);\r\ncx24120_writereg(state, 0xcf, 0x00);\r\nreg = cx24120_readreg(state, 0xea) & 0xfe;\r\ncx24120_writereg(state, 0xea, reg);\r\ncx24120_writereg(state, 0xeb, 0x0c);\r\ncx24120_writereg(state, 0xec, 0x06);\r\ncx24120_writereg(state, 0xed, 0x05);\r\ncx24120_writereg(state, 0xee, 0x03);\r\ncx24120_writereg(state, 0xef, 0x05);\r\ncx24120_writereg(state, 0xf3, 0x03);\r\ncx24120_writereg(state, 0xf4, 0x44);\r\nfor (i = 0; i < 3; i++) {\r\ncx24120_writereg(state, 0xf0 + i, 0x04);\r\ncx24120_writereg(state, 0xe6 + i, 0x02);\r\n}\r\ncx24120_writereg(state, 0xea, (reg | 0x01));\r\nfor (i = 0; i < 6; i += 2) {\r\ncx24120_writereg(state, 0xc5 + i, 0x00);\r\ncx24120_writereg(state, 0xc6 + i, 0x00);\r\n}\r\ncx24120_writereg(state, 0xe4, 0x03);\r\ncx24120_writereg(state, 0xeb, 0x0a);\r\ndev_dbg(&state->i2c->dev, "requesting firmware (%s) to download...\n",\r\nCX24120_FIRMWARE);\r\nret = state->config->request_firmware(fe, &fw, CX24120_FIRMWARE);\r\nif (ret) {\r\nerr("Could not load firmware (%s): %d\n", CX24120_FIRMWARE,\r\nret);\r\nreturn ret;\r\n}\r\ndev_dbg(&state->i2c->dev,\r\n"Firmware found, size %d bytes (%02x %02x .. %02x %02x)\n",\r\n(int)fw->size,\r\nfw->data[0],\r\nfw->data[1],\r\nfw->data[fw->size - 2],\r\nfw->data[fw->size - 1]);\r\ncx24120_test_rom(state);\r\nreg = cx24120_readreg(state, 0xfb) & 0xfe;\r\ncx24120_writereg(state, 0xfb, reg);\r\ncx24120_writereg(state, 0xe0, 0x76);\r\ncx24120_writereg(state, 0xf7, 0x81);\r\ncx24120_writereg(state, 0xf8, 0x00);\r\ncx24120_writereg(state, 0xf9, 0x00);\r\ncx24120_writeregs(state, 0xfa, fw->data, (fw->size - 1), 0x00);\r\ncx24120_writereg(state, 0xf7, 0xc0);\r\ncx24120_writereg(state, 0xe0, 0x00);\r\nreg = (fw->size - 2) & 0x00ff;\r\ncx24120_writereg(state, 0xf8, reg);\r\nreg = ((fw->size - 2) >> 8) & 0x00ff;\r\ncx24120_writereg(state, 0xf9, reg);\r\ncx24120_writereg(state, 0xf7, 0x00);\r\ncx24120_writereg(state, 0xdc, 0x00);\r\ncx24120_writereg(state, 0xdc, 0x07);\r\nmsleep(500);\r\nreg = cx24120_readreg(state, 0xe1);\r\nif (reg == fw->data[fw->size - 1]) {\r\ndev_dbg(&state->i2c->dev, "Firmware uploaded successfully\n");\r\nret = 0;\r\n} else {\r\nerr("Firmware upload failed. Last byte returned=0x%x\n", ret);\r\nret = -EREMOTEIO;\r\n}\r\ncx24120_writereg(state, 0xdc, 0x00);\r\nrelease_firmware(fw);\r\nif (ret != 0)\r\nreturn ret;\r\ncmd.id = CMD_START_TUNER;\r\ncmd.len = 3;\r\ncmd.arg[0] = 0x00;\r\ncmd.arg[1] = 0x00;\r\ncmd.arg[2] = 0x00;\r\nif (cx24120_message_send(state, &cmd) != 0) {\r\nerr("Error tuner start! :(\n");\r\nreturn -EREMOTEIO;\r\n}\r\nret = cx24120_set_vco(state);\r\nif (ret != 0) {\r\nerr("Error set VCO! :(\n");\r\nreturn ret;\r\n}\r\ncmd.id = CMD_BANDWIDTH;\r\ncmd.len = 12;\r\ncmd.arg[0] = 0x00;\r\ncmd.arg[1] = 0x00;\r\ncmd.arg[2] = 0x00;\r\ncmd.arg[3] = 0x00;\r\ncmd.arg[4] = 0x05;\r\ncmd.arg[5] = 0x02;\r\ncmd.arg[6] = 0x02;\r\ncmd.arg[7] = 0x00;\r\ncmd.arg[8] = 0x05;\r\ncmd.arg[9] = 0x02;\r\ncmd.arg[10] = 0x02;\r\ncmd.arg[11] = 0x00;\r\nif (cx24120_message_send(state, &cmd)) {\r\nerr("Error set bandwidth!\n");\r\nreturn -EREMOTEIO;\r\n}\r\nreg = cx24120_readreg(state, 0xba);\r\nif (reg > 3) {\r\ndev_dbg(&state->i2c->dev, "Reset-readreg 0xba: %x\n", ret);\r\nerr("Error initialising tuner!\n");\r\nreturn -EREMOTEIO;\r\n}\r\ndev_dbg(&state->i2c->dev, "Tuner initialised correctly.\n");\r\ncx24120_writereg(state, 0xeb, 0x0a);\r\nif (cx24120_msg_mpeg_output_global_config(state, 0) ||\r\ncx24120_msg_mpeg_output_config(state, 0) ||\r\ncx24120_msg_mpeg_output_config(state, 1) ||\r\ncx24120_msg_mpeg_output_config(state, 2)) {\r\nerr("Error initialising mpeg output. :(\n");\r\nreturn -EREMOTEIO;\r\n}\r\ncmd.id = CMD_BER_CTRL;\r\ncmd.len = 3;\r\ncmd.arg[0] = 0x00;\r\ncmd.arg[1] = CX24120_BER_WINDOW;\r\ncmd.arg[2] = CX24120_BER_WINDOW;\r\nif (cx24120_message_send(state, &cmd)) {\r\nerr("Error setting ber window\n");\r\nreturn -EREMOTEIO;\r\n}\r\ncmd.id = CMD_FWVERSION;\r\ncmd.len = 1;\r\nfor (i = 0; i < 4; i++) {\r\ncmd.arg[0] = i;\r\nret = cx24120_message_send(state, &cmd);\r\nif (ret != 0)\r\nreturn ret;\r\nvers[i] = cx24120_readreg(state, CX24120_REG_MAILBOX);\r\n}\r\ninfo("FW version %i.%i.%i.%i\n", vers[0], vers[1], vers[2], vers[3]);\r\nc->strength.len = 1;\r\nc->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->cnr.len = 1;\r\nc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->post_bit_error.len = 1;\r\nc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->post_bit_count.len = 1;\r\nc->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->block_error.len = 1;\r\nc->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->block_count.len = 1;\r\nc->block_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nstate->cold_init = 1;\r\nreturn 0;\r\n}\r\nstatic int cx24120_tune(struct dvb_frontend *fe, bool re_tune,\r\nunsigned int mode_flags, unsigned int *delay,\r\nenum fe_status *status)\r\n{\r\nstruct cx24120_state *state = fe->demodulator_priv;\r\nint ret;\r\ndev_dbg(&state->i2c->dev, "(%d)\n", re_tune);\r\nif (re_tune) {\r\nret = cx24120_set_frontend(fe);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn cx24120_read_status(fe, status);\r\n}\r\nstatic int cx24120_get_algo(struct dvb_frontend *fe)\r\n{\r\nreturn DVBFE_ALGO_HW;\r\n}\r\nstatic int cx24120_sleep(struct dvb_frontend *fe)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cx24120_get_frontend(struct dvb_frontend *fe,\r\nstruct dtv_frontend_properties *c)\r\n{\r\nstruct cx24120_state *state = fe->demodulator_priv;\r\nu8 freq1, freq2, freq3;\r\nint status;\r\ndev_dbg(&state->i2c->dev, "\n");\r\nstatus = cx24120_readreg(state, CX24120_REG_STATUS);\r\nif (!(status & CX24120_HAS_LOCK))\r\nreturn 0;\r\nfreq1 = cx24120_readreg(state, CX24120_REG_FREQ1);\r\nfreq2 = cx24120_readreg(state, CX24120_REG_FREQ2);\r\nfreq3 = cx24120_readreg(state, CX24120_REG_FREQ3);\r\nc->frequency = (freq3 << 16) | (freq2 << 8) | freq1;\r\ndev_dbg(&state->i2c->dev, "frequency = %d\n", c->frequency);\r\ncx24120_get_fec(fe);\r\nreturn 0;\r\n}\r\nstatic void cx24120_release(struct dvb_frontend *fe)\r\n{\r\nstruct cx24120_state *state = fe->demodulator_priv;\r\ndev_dbg(&state->i2c->dev, "Clear state structure\n");\r\nkfree(state);\r\n}\r\nstatic int cx24120_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\r\n{\r\nstruct cx24120_state *state = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nif (c->block_error.stat[0].scale != FE_SCALE_COUNTER) {\r\n*ucblocks = 0;\r\nreturn 0;\r\n}\r\n*ucblocks = c->block_error.stat[0].uvalue - state->ucb_offset;\r\nreturn 0;\r\n}
