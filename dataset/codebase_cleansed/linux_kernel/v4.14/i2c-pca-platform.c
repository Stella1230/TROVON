static int i2c_pca_pf_readbyte8(void *pd, int reg)\r\n{\r\nstruct i2c_pca_pf_data *i2c = pd;\r\nreturn ioread8(i2c->reg_base + reg);\r\n}\r\nstatic int i2c_pca_pf_readbyte16(void *pd, int reg)\r\n{\r\nstruct i2c_pca_pf_data *i2c = pd;\r\nreturn ioread8(i2c->reg_base + reg * 2);\r\n}\r\nstatic int i2c_pca_pf_readbyte32(void *pd, int reg)\r\n{\r\nstruct i2c_pca_pf_data *i2c = pd;\r\nreturn ioread8(i2c->reg_base + reg * 4);\r\n}\r\nstatic void i2c_pca_pf_writebyte8(void *pd, int reg, int val)\r\n{\r\nstruct i2c_pca_pf_data *i2c = pd;\r\niowrite8(val, i2c->reg_base + reg);\r\n}\r\nstatic void i2c_pca_pf_writebyte16(void *pd, int reg, int val)\r\n{\r\nstruct i2c_pca_pf_data *i2c = pd;\r\niowrite8(val, i2c->reg_base + reg * 2);\r\n}\r\nstatic void i2c_pca_pf_writebyte32(void *pd, int reg, int val)\r\n{\r\nstruct i2c_pca_pf_data *i2c = pd;\r\niowrite8(val, i2c->reg_base + reg * 4);\r\n}\r\nstatic int i2c_pca_pf_waitforcompletion(void *pd)\r\n{\r\nstruct i2c_pca_pf_data *i2c = pd;\r\nunsigned long timeout;\r\nlong ret;\r\nif (i2c->irq) {\r\nret = wait_event_timeout(i2c->wait,\r\ni2c->algo_data.read_byte(i2c, I2C_PCA_CON)\r\n& I2C_PCA_CON_SI, i2c->adap.timeout);\r\n} else {\r\ntimeout = jiffies + i2c->adap.timeout;\r\ndo {\r\nret = time_before(jiffies, timeout);\r\nif (i2c->algo_data.read_byte(i2c, I2C_PCA_CON)\r\n& I2C_PCA_CON_SI)\r\nbreak;\r\nudelay(100);\r\n} while (ret);\r\n}\r\nreturn ret > 0;\r\n}\r\nstatic void i2c_pca_pf_dummyreset(void *pd)\r\n{\r\nstruct i2c_pca_pf_data *i2c = pd;\r\ndev_warn(&i2c->adap.dev, "No reset-pin found. Chip may get stuck!\n");\r\n}\r\nstatic void i2c_pca_pf_resetchip(void *pd)\r\n{\r\nstruct i2c_pca_pf_data *i2c = pd;\r\ngpiod_set_value(i2c->gpio, 1);\r\nndelay(100);\r\ngpiod_set_value(i2c->gpio, 0);\r\n}\r\nstatic irqreturn_t i2c_pca_pf_handler(int this_irq, void *dev_id)\r\n{\r\nstruct i2c_pca_pf_data *i2c = dev_id;\r\nif ((i2c->algo_data.read_byte(i2c, I2C_PCA_CON) & I2C_PCA_CON_SI) == 0)\r\nreturn IRQ_NONE;\r\nwake_up(&i2c->wait);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int i2c_pca_pf_probe(struct platform_device *pdev)\r\n{\r\nstruct i2c_pca_pf_data *i2c;\r\nstruct resource *res;\r\nstruct i2c_pca9564_pf_platform_data *platform_data =\r\ndev_get_platdata(&pdev->dev);\r\nstruct device_node *np = pdev->dev.of_node;\r\nint ret = 0;\r\nint irq;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nirq = 0;\r\ni2c = devm_kzalloc(&pdev->dev, sizeof(*i2c), GFP_KERNEL);\r\nif (!i2c)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ni2c->reg_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(i2c->reg_base))\r\nreturn PTR_ERR(i2c->reg_base);\r\ninit_waitqueue_head(&i2c->wait);\r\ni2c->io_base = res->start;\r\ni2c->io_size = resource_size(res);\r\ni2c->irq = irq;\r\ni2c->adap.nr = pdev->id;\r\ni2c->adap.owner = THIS_MODULE;\r\nsnprintf(i2c->adap.name, sizeof(i2c->adap.name),\r\n"PCA9564/PCA9665 at 0x%08lx",\r\n(unsigned long) res->start);\r\ni2c->adap.algo_data = &i2c->algo_data;\r\ni2c->adap.dev.parent = &pdev->dev;\r\ni2c->adap.dev.of_node = np;\r\nif (platform_data) {\r\ni2c->adap.timeout = platform_data->timeout;\r\ni2c->algo_data.i2c_clock = platform_data->i2c_clock_speed;\r\nif (gpio_is_valid(platform_data->gpio)) {\r\nret = devm_gpio_request_one(&pdev->dev,\r\nplatform_data->gpio,\r\nGPIOF_ACTIVE_LOW,\r\ni2c->adap.name);\r\nif (ret == 0) {\r\ni2c->gpio = gpio_to_desc(platform_data->gpio);\r\ngpiod_direction_output(i2c->gpio, 0);\r\n} else {\r\ndev_warn(&pdev->dev, "Registering gpio failed!\n");\r\ni2c->gpio = NULL;\r\n}\r\n}\r\n} else if (np) {\r\ni2c->adap.timeout = HZ;\r\ni2c->gpio = devm_gpiod_get_optional(&pdev->dev, "reset-gpios", GPIOD_OUT_LOW);\r\nif (IS_ERR(i2c->gpio))\r\nreturn PTR_ERR(i2c->gpio);\r\nof_property_read_u32_index(np, "clock-frequency", 0,\r\n&i2c->algo_data.i2c_clock);\r\n} else {\r\ni2c->adap.timeout = HZ;\r\ni2c->algo_data.i2c_clock = 59000;\r\ni2c->gpio = NULL;\r\n}\r\ni2c->algo_data.data = i2c;\r\ni2c->algo_data.wait_for_completion = i2c_pca_pf_waitforcompletion;\r\nif (i2c->gpio)\r\ni2c->algo_data.reset_chip = i2c_pca_pf_resetchip;\r\nelse\r\ni2c->algo_data.reset_chip = i2c_pca_pf_dummyreset;\r\nswitch (res->flags & IORESOURCE_MEM_TYPE_MASK) {\r\ncase IORESOURCE_MEM_32BIT:\r\ni2c->algo_data.write_byte = i2c_pca_pf_writebyte32;\r\ni2c->algo_data.read_byte = i2c_pca_pf_readbyte32;\r\nbreak;\r\ncase IORESOURCE_MEM_16BIT:\r\ni2c->algo_data.write_byte = i2c_pca_pf_writebyte16;\r\ni2c->algo_data.read_byte = i2c_pca_pf_readbyte16;\r\nbreak;\r\ncase IORESOURCE_MEM_8BIT:\r\ndefault:\r\ni2c->algo_data.write_byte = i2c_pca_pf_writebyte8;\r\ni2c->algo_data.read_byte = i2c_pca_pf_readbyte8;\r\nbreak;\r\n}\r\nif (irq) {\r\nret = devm_request_irq(&pdev->dev, irq, i2c_pca_pf_handler,\r\nIRQF_TRIGGER_FALLING, pdev->name, i2c);\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = i2c_pca_add_numbered_bus(&i2c->adap);\r\nif (ret)\r\nreturn ret;\r\nplatform_set_drvdata(pdev, i2c);\r\ndev_info(&pdev->dev, "registered.\n");\r\nreturn 0;\r\n}\r\nstatic int i2c_pca_pf_remove(struct platform_device *pdev)\r\n{\r\nstruct i2c_pca_pf_data *i2c = platform_get_drvdata(pdev);\r\ni2c_del_adapter(&i2c->adap);\r\nreturn 0;\r\n}
