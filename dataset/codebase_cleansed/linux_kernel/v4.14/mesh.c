static inline u32 readtb(void)\r\n{\r\nu32 tb;\r\n#ifdef DBG_USE_TB\r\nasm ("mftb %0" : "=r" (tb) : );\r\n#else\r\ntb = 0;\r\n#endif\r\nreturn tb;\r\n}\r\nstatic void dlog(struct mesh_state *ms, char *fmt, int a)\r\n{\r\nstruct mesh_target *tp = &ms->tgts[ms->conn_tgt];\r\nstruct dbglog *tlp, *slp;\r\ntlp = &tp->log[tp->log_ix];\r\nslp = &ms->log[ms->log_ix];\r\ntlp->fmt = fmt;\r\ntlp->tb = readtb();\r\ntlp->phase = (ms->msgphase << 4) + ms->phase;\r\ntlp->bs0 = ms->mesh->bus_status0;\r\ntlp->bs1 = ms->mesh->bus_status1;\r\ntlp->tgt = ms->conn_tgt;\r\ntlp->d = a;\r\n*slp = *tlp;\r\nif (++tp->log_ix >= N_DBG_LOG)\r\ntp->log_ix = 0;\r\nif (tp->n_log < N_DBG_LOG)\r\n++tp->n_log;\r\nif (++ms->log_ix >= N_DBG_SLOG)\r\nms->log_ix = 0;\r\nif (ms->n_log < N_DBG_SLOG)\r\n++ms->n_log;\r\n}\r\nstatic void dumplog(struct mesh_state *ms, int t)\r\n{\r\nstruct mesh_target *tp = &ms->tgts[t];\r\nstruct dbglog *lp;\r\nint i;\r\nif (tp->n_log == 0)\r\nreturn;\r\ni = tp->log_ix - tp->n_log;\r\nif (i < 0)\r\ni += N_DBG_LOG;\r\ntp->n_log = 0;\r\ndo {\r\nlp = &tp->log[i];\r\nprintk(KERN_DEBUG "mesh log %d: bs=%.2x%.2x ph=%.2x ",\r\nt, lp->bs1, lp->bs0, lp->phase);\r\n#ifdef DBG_USE_TB\r\nprintk("tb=%10u ", lp->tb);\r\n#endif\r\nprintk(lp->fmt, lp->d);\r\nprintk("\n");\r\nif (++i >= N_DBG_LOG)\r\ni = 0;\r\n} while (i != tp->log_ix);\r\n}\r\nstatic void dumpslog(struct mesh_state *ms)\r\n{\r\nstruct dbglog *lp;\r\nint i;\r\nif (ms->n_log == 0)\r\nreturn;\r\ni = ms->log_ix - ms->n_log;\r\nif (i < 0)\r\ni += N_DBG_SLOG;\r\nms->n_log = 0;\r\ndo {\r\nlp = &ms->log[i];\r\nprintk(KERN_DEBUG "mesh log: bs=%.2x%.2x ph=%.2x t%d ",\r\nlp->bs1, lp->bs0, lp->phase, lp->tgt);\r\n#ifdef DBG_USE_TB\r\nprintk("tb=%10u ", lp->tb);\r\n#endif\r\nprintk(lp->fmt, lp->d);\r\nprintk("\n");\r\nif (++i >= N_DBG_SLOG)\r\ni = 0;\r\n} while (i != ms->log_ix);\r\n}\r\nstatic inline void dlog(struct mesh_state *ms, char *fmt, int a)\r\n{}\r\nstatic inline void dumplog(struct mesh_state *ms, int tgt)\r\n{}\r\nstatic inline void dumpslog(struct mesh_state *ms)\r\n{}\r\nstatic void\r\nmesh_dump_regs(struct mesh_state *ms)\r\n{\r\nvolatile struct mesh_regs __iomem *mr = ms->mesh;\r\nvolatile struct dbdma_regs __iomem *md = ms->dma;\r\nint t;\r\nstruct mesh_target *tp;\r\nprintk(KERN_DEBUG "mesh: state at %p, regs at %p, dma at %p\n",\r\nms, mr, md);\r\nprintk(KERN_DEBUG " ct=%4x seq=%2x bs=%4x fc=%2x "\r\n"exc=%2x err=%2x im=%2x int=%2x sp=%2x\n",\r\n(mr->count_hi << 8) + mr->count_lo, mr->sequence,\r\n(mr->bus_status1 << 8) + mr->bus_status0, mr->fifo_count,\r\nmr->exception, mr->error, mr->intr_mask, mr->interrupt,\r\nmr->sync_params);\r\nwhile(in_8(&mr->fifo_count))\r\nprintk(KERN_DEBUG " fifo data=%.2x\n",in_8(&mr->fifo));\r\nprintk(KERN_DEBUG " dma stat=%x cmdptr=%x\n",\r\nin_le32(&md->status), in_le32(&md->cmdptr));\r\nprintk(KERN_DEBUG " phase=%d msgphase=%d conn_tgt=%d data_ptr=%d\n",\r\nms->phase, ms->msgphase, ms->conn_tgt, ms->data_ptr);\r\nprintk(KERN_DEBUG " dma_st=%d dma_ct=%d n_msgout=%d\n",\r\nms->dma_started, ms->dma_count, ms->n_msgout);\r\nfor (t = 0; t < 8; ++t) {\r\ntp = &ms->tgts[t];\r\nif (tp->current_req == NULL)\r\ncontinue;\r\nprintk(KERN_DEBUG " target %d: req=%p goes_out=%d saved_ptr=%d\n",\r\nt, tp->current_req, tp->data_goes_out, tp->saved_ptr);\r\n}\r\n}\r\nstatic inline void mesh_flush_io(volatile struct mesh_regs __iomem *mr)\r\n{\r\n(void)in_8(&mr->mesh_id);\r\n}\r\nstatic void mesh_completed(struct mesh_state *ms, struct scsi_cmnd *cmd)\r\n{\r\n(*cmd->scsi_done)(cmd);\r\n}\r\nstatic void mesh_init(struct mesh_state *ms)\r\n{\r\nvolatile struct mesh_regs __iomem *mr = ms->mesh;\r\nvolatile struct dbdma_regs __iomem *md = ms->dma;\r\nmesh_flush_io(mr);\r\nudelay(100);\r\nout_le32(&md->control, (RUN|PAUSE|FLUSH|WAKE) << 16);\r\nout_8(&mr->exception, 0xff);\r\nout_8(&mr->error, 0xff);\r\nout_8(&mr->sequence, SEQ_RESETMESH);\r\nmesh_flush_io(mr);\r\nudelay(10);\r\nout_8(&mr->intr_mask, INT_ERROR | INT_EXCEPTION | INT_CMDDONE);\r\nout_8(&mr->source_id, ms->host->this_id);\r\nout_8(&mr->sel_timeout, 25);\r\nout_8(&mr->sync_params, ASYNC_PARAMS);\r\nif (init_reset_delay) {\r\nprintk(KERN_INFO "mesh: performing initial bus reset...\n");\r\nout_8(&mr->bus_status1, BS1_RST);\r\nmesh_flush_io(mr);\r\nudelay(30);\r\nout_8(&mr->bus_status1, 0);\r\nmesh_flush_io(mr);\r\nmsleep(init_reset_delay);\r\n}\r\nout_8(&mr->interrupt, 0xff);\r\nout_8(&mr->sequence, SEQ_FLUSHFIFO);\r\nmesh_flush_io(mr);\r\nudelay(1);\r\nout_8(&mr->sync_params, ASYNC_PARAMS);\r\nout_8(&mr->sequence, SEQ_ENBRESEL);\r\nms->phase = idle;\r\nms->msgphase = msg_none;\r\n}\r\nstatic void mesh_start_cmd(struct mesh_state *ms, struct scsi_cmnd *cmd)\r\n{\r\nvolatile struct mesh_regs __iomem *mr = ms->mesh;\r\nint t, id;\r\nid = cmd->device->id;\r\nms->current_req = cmd;\r\nms->tgts[id].data_goes_out = cmd->sc_data_direction == DMA_TO_DEVICE;\r\nms->tgts[id].current_req = cmd;\r\n#if 1\r\nif (DEBUG_TARGET(cmd)) {\r\nint i;\r\nprintk(KERN_DEBUG "mesh_start: %p tgt=%d cmd=", cmd, id);\r\nfor (i = 0; i < cmd->cmd_len; ++i)\r\nprintk(" %x", cmd->cmnd[i]);\r\nprintk(" use_sg=%d buffer=%p bufflen=%u\n",\r\nscsi_sg_count(cmd), scsi_sglist(cmd), scsi_bufflen(cmd));\r\n}\r\n#endif\r\nif (ms->dma_started)\r\npanic("mesh: double DMA start !\n");\r\nms->phase = arbitrating;\r\nms->msgphase = msg_none;\r\nms->data_ptr = 0;\r\nms->dma_started = 0;\r\nms->n_msgout = 0;\r\nms->last_n_msgout = 0;\r\nms->expect_reply = 0;\r\nms->conn_tgt = id;\r\nms->tgts[id].saved_ptr = 0;\r\nms->stat = DID_OK;\r\nms->aborting = 0;\r\n#ifdef MESH_DBG\r\nms->tgts[id].n_log = 0;\r\ndlog(ms, "start cmd=%x", (int) cmd);\r\n#endif\r\ndlog(ms, "about to arb, intr/exc/err/fc=%.8x",\r\nMKWORD(mr->interrupt, mr->exception, mr->error, mr->fifo_count));\r\nout_8(&mr->interrupt, INT_CMDDONE);\r\nout_8(&mr->sequence, SEQ_ENBRESEL);\r\nmesh_flush_io(mr);\r\nudelay(1);\r\nif (in_8(&mr->bus_status1) & (BS1_BSY | BS1_SEL)) {\r\ndlog(ms, "busy b4 arb, intr/exc/err/fc=%.8x",\r\nMKWORD(mr->interrupt, mr->exception,\r\nmr->error, mr->fifo_count));\r\nfor (t = 100; t > 0; --t) {\r\nif ((in_8(&mr->bus_status1) & (BS1_BSY | BS1_SEL)) == 0)\r\nbreak;\r\nif (in_8(&mr->interrupt) != 0) {\r\ndlog(ms, "intr b4 arb, intr/exc/err/fc=%.8x",\r\nMKWORD(mr->interrupt, mr->exception,\r\nmr->error, mr->fifo_count));\r\nmesh_interrupt(ms);\r\nif (ms->phase != arbitrating)\r\nreturn;\r\n}\r\nudelay(1);\r\n}\r\nif (in_8(&mr->bus_status1) & (BS1_BSY | BS1_SEL)) {\r\nms->stat = DID_BUS_BUSY;\r\nms->phase = idle;\r\nmesh_done(ms, 0);\r\nreturn;\r\n}\r\n}\r\nout_8(&mr->dest_id, mr->source_id);\r\nout_8(&mr->sequence, SEQ_DISRESEL);\r\nif (in_8(&mr->interrupt) != 0) {\r\ndlog(ms, "intr after disresel, intr/exc/err/fc=%.8x",\r\nMKWORD(mr->interrupt, mr->exception,\r\nmr->error, mr->fifo_count));\r\nmesh_interrupt(ms);\r\nif (ms->phase != arbitrating)\r\nreturn;\r\ndlog(ms, "after intr after disresel, intr/exc/err/fc=%.8x",\r\nMKWORD(mr->interrupt, mr->exception,\r\nmr->error, mr->fifo_count));\r\n}\r\nout_8(&mr->sequence, SEQ_ARBITRATE);\r\nfor (t = 230; t > 0; --t) {\r\nif (in_8(&mr->interrupt) != 0)\r\nbreak;\r\nudelay(1);\r\n}\r\ndlog(ms, "after arb, intr/exc/err/fc=%.8x",\r\nMKWORD(mr->interrupt, mr->exception, mr->error, mr->fifo_count));\r\nif (in_8(&mr->interrupt) == 0 && (in_8(&mr->bus_status1) & BS1_SEL)\r\n&& (in_8(&mr->bus_status0) & BS0_IO)) {\r\ndlog(ms, "resel? after arb, intr/exc/err/fc=%.8x",\r\nMKWORD(mr->interrupt, mr->exception, mr->error, mr->fifo_count));\r\nout_8(&mr->sequence, SEQ_RESETMESH);\r\nmesh_flush_io(mr);\r\nudelay(10);\r\nout_8(&mr->interrupt, INT_ERROR | INT_EXCEPTION | INT_CMDDONE);\r\nout_8(&mr->intr_mask, INT_ERROR | INT_EXCEPTION | INT_CMDDONE);\r\nout_8(&mr->sequence, SEQ_ENBRESEL);\r\nmesh_flush_io(mr);\r\nfor (t = 10; t > 0 && in_8(&mr->interrupt) == 0; --t)\r\nudelay(1);\r\ndlog(ms, "tried reset after arb, intr/exc/err/fc=%.8x",\r\nMKWORD(mr->interrupt, mr->exception, mr->error, mr->fifo_count));\r\n#ifndef MESH_MULTIPLE_HOSTS\r\nif (in_8(&mr->interrupt) == 0 && (in_8(&mr->bus_status1) & BS1_SEL)\r\n&& (in_8(&mr->bus_status0) & BS0_IO)) {\r\nprintk(KERN_ERR "mesh: controller not responding"\r\n" to reselection!\n");\r\n}\r\n#endif\r\n}\r\n}\r\nstatic void mesh_start(struct mesh_state *ms)\r\n{\r\nstruct scsi_cmnd *cmd, *prev, *next;\r\nif (ms->phase != idle || ms->current_req != NULL) {\r\nprintk(KERN_ERR "inappropriate mesh_start (phase=%d, ms=%p)",\r\nms->phase, ms);\r\nreturn;\r\n}\r\nwhile (ms->phase == idle) {\r\nprev = NULL;\r\nfor (cmd = ms->request_q; ; cmd = (struct scsi_cmnd *) cmd->host_scribble) {\r\nif (cmd == NULL)\r\nreturn;\r\nif (ms->tgts[cmd->device->id].current_req == NULL)\r\nbreak;\r\nprev = cmd;\r\n}\r\nnext = (struct scsi_cmnd *) cmd->host_scribble;\r\nif (prev == NULL)\r\nms->request_q = next;\r\nelse\r\nprev->host_scribble = (void *) next;\r\nif (next == NULL)\r\nms->request_qtail = prev;\r\nmesh_start_cmd(ms, cmd);\r\n}\r\n}\r\nstatic void mesh_done(struct mesh_state *ms, int start_next)\r\n{\r\nstruct scsi_cmnd *cmd;\r\nstruct mesh_target *tp = &ms->tgts[ms->conn_tgt];\r\ncmd = ms->current_req;\r\nms->current_req = NULL;\r\ntp->current_req = NULL;\r\nif (cmd) {\r\ncmd->result = (ms->stat << 16) + cmd->SCp.Status;\r\nif (ms->stat == DID_OK)\r\ncmd->result += (cmd->SCp.Message << 8);\r\nif (DEBUG_TARGET(cmd)) {\r\nprintk(KERN_DEBUG "mesh_done: result = %x, data_ptr=%d, buflen=%d\n",\r\ncmd->result, ms->data_ptr, scsi_bufflen(cmd));\r\n#if 0\r\nif ((cmd->cmnd[0] == 0 || cmd->cmnd[0] == 0x12 || cmd->cmnd[0] == 3)\r\n&& cmd->request_buffer != 0) {\r\nunsigned char *b = cmd->request_buffer;\r\nprintk(KERN_DEBUG "buffer = %x %x %x %x %x %x %x %x\n",\r\nb[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7]);\r\n}\r\n#endif\r\n}\r\ncmd->SCp.this_residual -= ms->data_ptr;\r\nmesh_completed(ms, cmd);\r\n}\r\nif (start_next) {\r\nout_8(&ms->mesh->sequence, SEQ_ENBRESEL);\r\nmesh_flush_io(ms->mesh);\r\nudelay(1);\r\nms->phase = idle;\r\nmesh_start(ms);\r\n}\r\n}\r\nstatic inline void add_sdtr_msg(struct mesh_state *ms)\r\n{\r\nint i = ms->n_msgout;\r\nms->msgout[i] = EXTENDED_MESSAGE;\r\nms->msgout[i+1] = 3;\r\nms->msgout[i+2] = EXTENDED_SDTR;\r\nms->msgout[i+3] = mesh_sync_period/4;\r\nms->msgout[i+4] = (ALLOW_SYNC(ms->conn_tgt)? mesh_sync_offset: 0);\r\nms->n_msgout = i + 5;\r\n}\r\nstatic void set_sdtr(struct mesh_state *ms, int period, int offset)\r\n{\r\nstruct mesh_target *tp = &ms->tgts[ms->conn_tgt];\r\nvolatile struct mesh_regs __iomem *mr = ms->mesh;\r\nint v, tr;\r\ntp->sdtr_state = sdtr_done;\r\nif (offset == 0) {\r\nif (SYNC_OFF(tp->sync_params))\r\nprintk(KERN_INFO "mesh: target %d now asynchronous\n",\r\nms->conn_tgt);\r\ntp->sync_params = ASYNC_PARAMS;\r\nout_8(&mr->sync_params, ASYNC_PARAMS);\r\nreturn;\r\n}\r\nv = (ms->clk_freq / 5000) * period;\r\nif (v <= 250000) {\r\nv = 0;\r\ntr = (ms->clk_freq + 250000) / 500000;\r\n} else {\r\nv = (v + 99999) / 100000 - 2;\r\nif (v > 15)\r\nv = 15;\r\ntr = ((ms->clk_freq / (v + 2)) + 199999) / 200000;\r\n}\r\nif (offset > 15)\r\noffset = 15;\r\ntp->sync_params = SYNC_PARAMS(offset, v);\r\nout_8(&mr->sync_params, tp->sync_params);\r\nprintk(KERN_INFO "mesh: target %d synchronous at %d.%d MB/s\n",\r\nms->conn_tgt, tr/10, tr%10);\r\n}\r\nstatic void start_phase(struct mesh_state *ms)\r\n{\r\nint i, seq, nb;\r\nvolatile struct mesh_regs __iomem *mr = ms->mesh;\r\nvolatile struct dbdma_regs __iomem *md = ms->dma;\r\nstruct scsi_cmnd *cmd = ms->current_req;\r\nstruct mesh_target *tp = &ms->tgts[ms->conn_tgt];\r\ndlog(ms, "start_phase nmo/exc/fc/seq = %.8x",\r\nMKWORD(ms->n_msgout, mr->exception, mr->fifo_count, mr->sequence));\r\nout_8(&mr->interrupt, INT_ERROR | INT_EXCEPTION | INT_CMDDONE);\r\nseq = use_active_neg + (ms->n_msgout? SEQ_ATN: 0);\r\nswitch (ms->msgphase) {\r\ncase msg_none:\r\nbreak;\r\ncase msg_in:\r\nout_8(&mr->count_hi, 0);\r\nout_8(&mr->count_lo, 1);\r\nout_8(&mr->sequence, SEQ_MSGIN + seq);\r\nms->n_msgin = 0;\r\nreturn;\r\ncase msg_out:\r\nif (ms->n_msgout <= 0) {\r\nprintk(KERN_ERR "mesh: msg_out but n_msgout=%d\n",\r\nms->n_msgout);\r\nmesh_dump_regs(ms);\r\nms->msgphase = msg_none;\r\nbreak;\r\n}\r\nif (ALLOW_DEBUG(ms->conn_tgt)) {\r\nprintk(KERN_DEBUG "mesh: sending %d msg bytes:",\r\nms->n_msgout);\r\nfor (i = 0; i < ms->n_msgout; ++i)\r\nprintk(" %x", ms->msgout[i]);\r\nprintk("\n");\r\n}\r\ndlog(ms, "msgout msg=%.8x", MKWORD(ms->n_msgout, ms->msgout[0],\r\nms->msgout[1], ms->msgout[2]));\r\nout_8(&mr->count_hi, 0);\r\nout_8(&mr->sequence, SEQ_FLUSHFIFO);\r\nmesh_flush_io(mr);\r\nudelay(1);\r\nif ((in_8(&mr->bus_status0) & BS0_ATN) == 0) {\r\ndlog(ms, "bus0 was %.2x explicitly asserting ATN", mr->bus_status0);\r\nout_8(&mr->bus_status0, BS0_ATN);\r\nmesh_flush_io(mr);\r\nudelay(1);\r\nout_8(&mr->count_lo, 1);\r\nout_8(&mr->sequence, SEQ_MSGOUT + seq);\r\nout_8(&mr->bus_status0, 0);\r\ndlog(ms,"hace: after explicit ATN bus0=%.2x",mr->bus_status0);\r\n}\r\nif (ms->n_msgout == 1) {\r\ncmd_complete(ms);\r\n} else {\r\nout_8(&mr->count_lo, ms->n_msgout - 1);\r\nout_8(&mr->sequence, SEQ_MSGOUT + seq);\r\nfor (i = 0; i < ms->n_msgout - 1; ++i)\r\nout_8(&mr->fifo, ms->msgout[i]);\r\n}\r\nreturn;\r\ndefault:\r\nprintk(KERN_ERR "mesh bug: start_phase msgphase=%d\n",\r\nms->msgphase);\r\n}\r\nswitch (ms->phase) {\r\ncase selecting:\r\nout_8(&mr->dest_id, ms->conn_tgt);\r\nout_8(&mr->sequence, SEQ_SELECT + SEQ_ATN);\r\nbreak;\r\ncase commanding:\r\nout_8(&mr->sync_params, tp->sync_params);\r\nout_8(&mr->count_hi, 0);\r\nif (cmd) {\r\nout_8(&mr->count_lo, cmd->cmd_len);\r\nout_8(&mr->sequence, SEQ_COMMAND + seq);\r\nfor (i = 0; i < cmd->cmd_len; ++i)\r\nout_8(&mr->fifo, cmd->cmnd[i]);\r\n} else {\r\nout_8(&mr->count_lo, 6);\r\nout_8(&mr->sequence, SEQ_COMMAND + seq);\r\nfor (i = 0; i < 6; ++i)\r\nout_8(&mr->fifo, 0);\r\n}\r\nbreak;\r\ncase dataing:\r\nif (!ms->dma_started) {\r\nset_dma_cmds(ms, cmd);\r\nout_le32(&md->cmdptr, virt_to_phys(ms->dma_cmds));\r\nout_le32(&md->control, (RUN << 16) | RUN);\r\nms->dma_started = 1;\r\n}\r\nnb = ms->dma_count;\r\nif (nb > 0xfff0)\r\nnb = 0xfff0;\r\nms->dma_count -= nb;\r\nms->data_ptr += nb;\r\nout_8(&mr->count_lo, nb);\r\nout_8(&mr->count_hi, nb >> 8);\r\nout_8(&mr->sequence, (tp->data_goes_out?\r\nSEQ_DATAOUT: SEQ_DATAIN) + SEQ_DMA_MODE + seq);\r\nbreak;\r\ncase statusing:\r\nout_8(&mr->count_hi, 0);\r\nout_8(&mr->count_lo, 1);\r\nout_8(&mr->sequence, SEQ_STATUS + seq);\r\nbreak;\r\ncase busfreeing:\r\ncase disconnecting:\r\nout_8(&mr->sequence, SEQ_ENBRESEL);\r\nmesh_flush_io(mr);\r\nudelay(1);\r\ndlog(ms, "enbresel intr/exc/err/fc=%.8x",\r\nMKWORD(mr->interrupt, mr->exception, mr->error,\r\nmr->fifo_count));\r\nout_8(&mr->sequence, SEQ_BUSFREE);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "mesh: start_phase called with phase=%d\n",\r\nms->phase);\r\ndumpslog(ms);\r\n}\r\n}\r\nstatic inline void get_msgin(struct mesh_state *ms)\r\n{\r\nvolatile struct mesh_regs __iomem *mr = ms->mesh;\r\nint i, n;\r\nn = mr->fifo_count;\r\nif (n != 0) {\r\ni = ms->n_msgin;\r\nms->n_msgin = i + n;\r\nfor (; n > 0; --n)\r\nms->msgin[i++] = in_8(&mr->fifo);\r\n}\r\n}\r\nstatic inline int msgin_length(struct mesh_state *ms)\r\n{\r\nint b, n;\r\nn = 1;\r\nif (ms->n_msgin > 0) {\r\nb = ms->msgin[0];\r\nif (b == 1) {\r\nn = ms->n_msgin < 2? 2: ms->msgin[1] + 2;\r\n} else if (0x20 <= b && b <= 0x2f) {\r\nn = 2;\r\n}\r\n}\r\nreturn n;\r\n}\r\nstatic void reselected(struct mesh_state *ms)\r\n{\r\nvolatile struct mesh_regs __iomem *mr = ms->mesh;\r\nstruct scsi_cmnd *cmd;\r\nstruct mesh_target *tp;\r\nint b, t, prev;\r\nswitch (ms->phase) {\r\ncase idle:\r\nbreak;\r\ncase arbitrating:\r\nif ((cmd = ms->current_req) != NULL) {\r\ncmd->host_scribble = (void *) ms->request_q;\r\nif (ms->request_q == NULL)\r\nms->request_qtail = cmd;\r\nms->request_q = cmd;\r\ntp = &ms->tgts[cmd->device->id];\r\ntp->current_req = NULL;\r\n}\r\nbreak;\r\ncase busfreeing:\r\nms->phase = reselecting;\r\nmesh_done(ms, 0);\r\nbreak;\r\ncase disconnecting:\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "mesh: reselected in phase %d/%d tgt %d\n",\r\nms->msgphase, ms->phase, ms->conn_tgt);\r\ndumplog(ms, ms->conn_tgt);\r\ndumpslog(ms);\r\n}\r\nif (ms->dma_started) {\r\nprintk(KERN_ERR "mesh: reselected with DMA started !\n");\r\nhalt_dma(ms);\r\n}\r\nms->current_req = NULL;\r\nms->phase = dataing;\r\nms->msgphase = msg_in;\r\nms->n_msgout = 0;\r\nms->last_n_msgout = 0;\r\nprev = ms->conn_tgt;\r\nwhile ((in_8(&mr->bus_status1) & BS1_BSY) == 0) {\r\nstatic int mesh_aborted_resels;\r\nmesh_aborted_resels++;\r\nout_8(&mr->interrupt, INT_ERROR | INT_EXCEPTION | INT_CMDDONE);\r\nmesh_flush_io(mr);\r\nudelay(1);\r\nout_8(&mr->sequence, SEQ_ENBRESEL);\r\nmesh_flush_io(mr);\r\nudelay(5);\r\ndlog(ms, "extra resel err/exc/fc = %.6x",\r\nMKWORD(0, mr->error, mr->exception, mr->fifo_count));\r\n}\r\nout_8(&mr->interrupt, INT_ERROR | INT_EXCEPTION | INT_CMDDONE);\r\nmesh_flush_io(mr);\r\nudelay(1);\r\nout_8(&mr->sequence, SEQ_ENBRESEL);\r\nmesh_flush_io(mr);\r\nudelay(1);\r\nout_8(&mr->sync_params, ASYNC_PARAMS);\r\nif (in_8(&mr->fifo_count) == 0) {\r\nprintk(KERN_ERR "mesh: reselection but nothing in fifo?\n");\r\nms->conn_tgt = ms->host->this_id;\r\ngoto bogus;\r\n}\r\ndo {\r\nb = in_8(&mr->fifo);\r\ndlog(ms, "reseldata %x", b);\r\n} while (in_8(&mr->fifo_count));\r\nfor (t = 0; t < 8; ++t)\r\nif ((b & (1 << t)) != 0 && t != ms->host->this_id)\r\nbreak;\r\nif (b != (1 << t) + (1 << ms->host->this_id)) {\r\nprintk(KERN_ERR "mesh: bad reselection data %x\n", b);\r\nms->conn_tgt = ms->host->this_id;\r\ngoto bogus;\r\n}\r\nms->conn_tgt = t;\r\ntp = &ms->tgts[t];\r\nout_8(&mr->sync_params, tp->sync_params);\r\nif (ALLOW_DEBUG(t)) {\r\nprintk(KERN_DEBUG "mesh: reselected by target %d\n", t);\r\nprintk(KERN_DEBUG "mesh: saved_ptr=%x goes_out=%d cmd=%p\n",\r\ntp->saved_ptr, tp->data_goes_out, tp->current_req);\r\n}\r\nms->current_req = tp->current_req;\r\nif (tp->current_req == NULL) {\r\nprintk(KERN_ERR "mesh: reselected by tgt %d but no cmd!\n", t);\r\ngoto bogus;\r\n}\r\nms->data_ptr = tp->saved_ptr;\r\ndlog(ms, "resel prev tgt=%d", prev);\r\ndlog(ms, "resel err/exc=%.4x", MKWORD(0, 0, mr->error, mr->exception));\r\nstart_phase(ms);\r\nreturn;\r\nbogus:\r\ndumplog(ms, ms->conn_tgt);\r\ndumpslog(ms);\r\nms->data_ptr = 0;\r\nms->aborting = 1;\r\nstart_phase(ms);\r\n}\r\nstatic void do_abort(struct mesh_state *ms)\r\n{\r\nms->msgout[0] = ABORT;\r\nms->n_msgout = 1;\r\nms->aborting = 1;\r\nms->stat = DID_ABORT;\r\ndlog(ms, "abort", 0);\r\n}\r\nstatic void handle_reset(struct mesh_state *ms)\r\n{\r\nint tgt;\r\nstruct mesh_target *tp;\r\nstruct scsi_cmnd *cmd;\r\nvolatile struct mesh_regs __iomem *mr = ms->mesh;\r\nfor (tgt = 0; tgt < 8; ++tgt) {\r\ntp = &ms->tgts[tgt];\r\nif ((cmd = tp->current_req) != NULL) {\r\ncmd->result = DID_RESET << 16;\r\ntp->current_req = NULL;\r\nmesh_completed(ms, cmd);\r\n}\r\nms->tgts[tgt].sdtr_state = do_sdtr;\r\nms->tgts[tgt].sync_params = ASYNC_PARAMS;\r\n}\r\nms->current_req = NULL;\r\nwhile ((cmd = ms->request_q) != NULL) {\r\nms->request_q = (struct scsi_cmnd *) cmd->host_scribble;\r\ncmd->result = DID_RESET << 16;\r\nmesh_completed(ms, cmd);\r\n}\r\nms->phase = idle;\r\nms->msgphase = msg_none;\r\nout_8(&mr->interrupt, INT_ERROR | INT_EXCEPTION | INT_CMDDONE);\r\nout_8(&mr->sequence, SEQ_FLUSHFIFO);\r\nmesh_flush_io(mr);\r\nudelay(1);\r\nout_8(&mr->sync_params, ASYNC_PARAMS);\r\nout_8(&mr->sequence, SEQ_ENBRESEL);\r\n}\r\nstatic irqreturn_t do_mesh_interrupt(int irq, void *dev_id)\r\n{\r\nunsigned long flags;\r\nstruct mesh_state *ms = dev_id;\r\nstruct Scsi_Host *dev = ms->host;\r\nspin_lock_irqsave(dev->host_lock, flags);\r\nmesh_interrupt(ms);\r\nspin_unlock_irqrestore(dev->host_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void handle_error(struct mesh_state *ms)\r\n{\r\nint err, exc, count;\r\nvolatile struct mesh_regs __iomem *mr = ms->mesh;\r\nerr = in_8(&mr->error);\r\nexc = in_8(&mr->exception);\r\nout_8(&mr->interrupt, INT_ERROR | INT_EXCEPTION | INT_CMDDONE);\r\ndlog(ms, "error err/exc/fc/cl=%.8x",\r\nMKWORD(err, exc, mr->fifo_count, mr->count_lo));\r\nif (err & ERR_SCSIRESET) {\r\nprintk(KERN_INFO "mesh: SCSI bus reset detected: "\r\n"waiting for end...");\r\nwhile ((in_8(&mr->bus_status1) & BS1_RST) != 0)\r\nudelay(1);\r\nprintk("done\n");\r\nhandle_reset(ms);\r\nreturn;\r\n}\r\nif (err & ERR_UNEXPDISC) {\r\nif (exc & EXC_RESELECTED) {\r\nreselected(ms);\r\nreturn;\r\n}\r\nif (!ms->aborting) {\r\nprintk(KERN_WARNING "mesh: target %d aborted\n",\r\nms->conn_tgt);\r\ndumplog(ms, ms->conn_tgt);\r\ndumpslog(ms);\r\n}\r\nout_8(&mr->interrupt, INT_CMDDONE);\r\nms->stat = DID_ABORT;\r\nmesh_done(ms, 1);\r\nreturn;\r\n}\r\nif (err & ERR_PARITY) {\r\nif (ms->msgphase == msg_in) {\r\nprintk(KERN_ERR "mesh: msg parity error, target %d\n",\r\nms->conn_tgt);\r\nms->msgout[0] = MSG_PARITY_ERROR;\r\nms->n_msgout = 1;\r\nms->msgphase = msg_in_bad;\r\ncmd_complete(ms);\r\nreturn;\r\n}\r\nif (ms->stat == DID_OK) {\r\nprintk(KERN_ERR "mesh: parity error, target %d\n",\r\nms->conn_tgt);\r\nms->stat = DID_PARITY;\r\n}\r\ncount = (mr->count_hi << 8) + mr->count_lo;\r\nif (count == 0) {\r\ncmd_complete(ms);\r\n} else {\r\nout_8(&mr->sequence, mr->sequence);\r\n}\r\nreturn;\r\n}\r\nif (err & ERR_SEQERR) {\r\nif (exc & EXC_RESELECTED) {\r\nstatic int mesh_resel_seqerr;\r\nmesh_resel_seqerr++;\r\nreselected(ms);\r\nreturn;\r\n}\r\nif (exc == EXC_PHASEMM) {\r\nstatic int mesh_phasemm_seqerr;\r\nmesh_phasemm_seqerr++;\r\nphase_mismatch(ms);\r\nreturn;\r\n}\r\nprintk(KERN_ERR "mesh: sequence error (err=%x exc=%x)\n",\r\nerr, exc);\r\n} else {\r\nprintk(KERN_ERR "mesh: unknown error %x (exc=%x)\n", err, exc);\r\n}\r\nmesh_dump_regs(ms);\r\ndumplog(ms, ms->conn_tgt);\r\nif (ms->phase > selecting && (in_8(&mr->bus_status1) & BS1_BSY)) {\r\ndo_abort(ms);\r\nphase_mismatch(ms);\r\nreturn;\r\n}\r\nms->stat = DID_ERROR;\r\nmesh_done(ms, 1);\r\n}\r\nstatic void handle_exception(struct mesh_state *ms)\r\n{\r\nint exc;\r\nvolatile struct mesh_regs __iomem *mr = ms->mesh;\r\nexc = in_8(&mr->exception);\r\nout_8(&mr->interrupt, INT_EXCEPTION | INT_CMDDONE);\r\nif (exc & EXC_RESELECTED) {\r\nstatic int mesh_resel_exc;\r\nmesh_resel_exc++;\r\nreselected(ms);\r\n} else if (exc == EXC_ARBLOST) {\r\nprintk(KERN_DEBUG "mesh: lost arbitration\n");\r\nms->stat = DID_BUS_BUSY;\r\nmesh_done(ms, 1);\r\n} else if (exc == EXC_SELTO) {\r\nms->stat = DID_BAD_TARGET;\r\nmesh_done(ms, 1);\r\n} else if (exc == EXC_PHASEMM) {\r\nphase_mismatch(ms);\r\n} else {\r\nprintk(KERN_ERR "mesh: can't cope with exception %x\n", exc);\r\nmesh_dump_regs(ms);\r\ndumplog(ms, ms->conn_tgt);\r\ndo_abort(ms);\r\nphase_mismatch(ms);\r\n}\r\n}\r\nstatic void handle_msgin(struct mesh_state *ms)\r\n{\r\nint i, code;\r\nstruct scsi_cmnd *cmd = ms->current_req;\r\nstruct mesh_target *tp = &ms->tgts[ms->conn_tgt];\r\nif (ms->n_msgin == 0)\r\nreturn;\r\ncode = ms->msgin[0];\r\nif (ALLOW_DEBUG(ms->conn_tgt)) {\r\nprintk(KERN_DEBUG "got %d message bytes:", ms->n_msgin);\r\nfor (i = 0; i < ms->n_msgin; ++i)\r\nprintk(" %x", ms->msgin[i]);\r\nprintk("\n");\r\n}\r\ndlog(ms, "msgin msg=%.8x",\r\nMKWORD(ms->n_msgin, code, ms->msgin[1], ms->msgin[2]));\r\nms->expect_reply = 0;\r\nms->n_msgout = 0;\r\nif (ms->n_msgin < msgin_length(ms))\r\ngoto reject;\r\nif (cmd)\r\ncmd->SCp.Message = code;\r\nswitch (code) {\r\ncase COMMAND_COMPLETE:\r\nbreak;\r\ncase EXTENDED_MESSAGE:\r\nswitch (ms->msgin[2]) {\r\ncase EXTENDED_MODIFY_DATA_POINTER:\r\nms->data_ptr += (ms->msgin[3] << 24) + ms->msgin[6]\r\n+ (ms->msgin[4] << 16) + (ms->msgin[5] << 8);\r\nbreak;\r\ncase EXTENDED_SDTR:\r\nif (tp->sdtr_state != sdtr_sent) {\r\nadd_sdtr_msg(ms);\r\nif (ms->msgout[3] < ms->msgin[3])\r\nms->msgout[3] = ms->msgin[3];\r\nif (ms->msgout[4] > ms->msgin[4])\r\nms->msgout[4] = ms->msgin[4];\r\nset_sdtr(ms, ms->msgout[3], ms->msgout[4]);\r\nms->msgphase = msg_out;\r\n} else {\r\nset_sdtr(ms, ms->msgin[3], ms->msgin[4]);\r\n}\r\nbreak;\r\ndefault:\r\ngoto reject;\r\n}\r\nbreak;\r\ncase SAVE_POINTERS:\r\ntp->saved_ptr = ms->data_ptr;\r\nbreak;\r\ncase RESTORE_POINTERS:\r\nms->data_ptr = tp->saved_ptr;\r\nbreak;\r\ncase DISCONNECT:\r\nms->phase = disconnecting;\r\nbreak;\r\ncase ABORT:\r\nbreak;\r\ncase MESSAGE_REJECT:\r\nif (tp->sdtr_state == sdtr_sent)\r\nset_sdtr(ms, 0, 0);\r\nbreak;\r\ncase NOP:\r\nbreak;\r\ndefault:\r\nif (IDENTIFY_BASE <= code && code <= IDENTIFY_BASE + 7) {\r\nif (cmd == NULL) {\r\ndo_abort(ms);\r\nms->msgphase = msg_out;\r\n} else if (code != cmd->device->lun + IDENTIFY_BASE) {\r\nprintk(KERN_WARNING "mesh: lun mismatch "\r\n"(%d != %llu) on reselection from "\r\n"target %d\n", code - IDENTIFY_BASE,\r\ncmd->device->lun, ms->conn_tgt);\r\n}\r\nbreak;\r\n}\r\ngoto reject;\r\n}\r\nreturn;\r\nreject:\r\nprintk(KERN_WARNING "mesh: rejecting message from target %d:",\r\nms->conn_tgt);\r\nfor (i = 0; i < ms->n_msgin; ++i)\r\nprintk(" %x", ms->msgin[i]);\r\nprintk("\n");\r\nms->msgout[0] = MESSAGE_REJECT;\r\nms->n_msgout = 1;\r\nms->msgphase = msg_out;\r\n}\r\nstatic void set_dma_cmds(struct mesh_state *ms, struct scsi_cmnd *cmd)\r\n{\r\nint i, dma_cmd, total, off, dtot;\r\nstruct scatterlist *scl;\r\nstruct dbdma_cmd *dcmds;\r\ndma_cmd = ms->tgts[ms->conn_tgt].data_goes_out?\r\nOUTPUT_MORE: INPUT_MORE;\r\ndcmds = ms->dma_cmds;\r\ndtot = 0;\r\nif (cmd) {\r\nint nseg;\r\ncmd->SCp.this_residual = scsi_bufflen(cmd);\r\nnseg = scsi_dma_map(cmd);\r\nBUG_ON(nseg < 0);\r\nif (nseg) {\r\ntotal = 0;\r\noff = ms->data_ptr;\r\nscsi_for_each_sg(cmd, scl, nseg, i) {\r\nu32 dma_addr = sg_dma_address(scl);\r\nu32 dma_len = sg_dma_len(scl);\r\ntotal += scl->length;\r\nif (off >= dma_len) {\r\noff -= dma_len;\r\ncontinue;\r\n}\r\nif (dma_len > 0xffff)\r\npanic("mesh: scatterlist element >= 64k");\r\ndcmds->req_count = cpu_to_le16(dma_len - off);\r\ndcmds->command = cpu_to_le16(dma_cmd);\r\ndcmds->phy_addr = cpu_to_le32(dma_addr + off);\r\ndcmds->xfer_status = 0;\r\n++dcmds;\r\ndtot += dma_len - off;\r\noff = 0;\r\n}\r\n}\r\n}\r\nif (dtot == 0) {\r\nstatic char mesh_extra_buf[64];\r\ndtot = sizeof(mesh_extra_buf);\r\ndcmds->req_count = cpu_to_le16(dtot);\r\ndcmds->phy_addr = cpu_to_le32(virt_to_phys(mesh_extra_buf));\r\ndcmds->xfer_status = 0;\r\n++dcmds;\r\n}\r\ndma_cmd += OUTPUT_LAST - OUTPUT_MORE;\r\ndcmds[-1].command = cpu_to_le16(dma_cmd);\r\nmemset(dcmds, 0, sizeof(*dcmds));\r\ndcmds->command = cpu_to_le16(DBDMA_STOP);\r\nms->dma_count = dtot;\r\n}\r\nstatic void halt_dma(struct mesh_state *ms)\r\n{\r\nvolatile struct dbdma_regs __iomem *md = ms->dma;\r\nvolatile struct mesh_regs __iomem *mr = ms->mesh;\r\nstruct scsi_cmnd *cmd = ms->current_req;\r\nint t, nb;\r\nif (!ms->tgts[ms->conn_tgt].data_goes_out) {\r\nt = 50;\r\nwhile (t > 0 && in_8(&mr->fifo_count) != 0\r\n&& (in_le32(&md->status) & ACTIVE) != 0) {\r\n--t;\r\nudelay(1);\r\n}\r\n}\r\nout_le32(&md->control, RUN << 16);\r\nnb = (mr->count_hi << 8) + mr->count_lo;\r\ndlog(ms, "halt_dma fc/count=%.6x",\r\nMKWORD(0, mr->fifo_count, 0, nb));\r\nif (ms->tgts[ms->conn_tgt].data_goes_out)\r\nnb += mr->fifo_count;\r\nms->data_ptr -= nb;\r\ndlog(ms, "data_ptr %x", ms->data_ptr);\r\nif (ms->data_ptr < 0) {\r\nprintk(KERN_ERR "mesh: halt_dma: data_ptr=%d (nb=%d, ms=%p)\n",\r\nms->data_ptr, nb, ms);\r\nms->data_ptr = 0;\r\n#ifdef MESH_DBG\r\ndumplog(ms, ms->conn_tgt);\r\ndumpslog(ms);\r\n#endif\r\n} else if (cmd && scsi_bufflen(cmd) &&\r\nms->data_ptr > scsi_bufflen(cmd)) {\r\nprintk(KERN_DEBUG "mesh: target %d overrun, "\r\n"data_ptr=%x total=%x goes_out=%d\n",\r\nms->conn_tgt, ms->data_ptr, scsi_bufflen(cmd),\r\nms->tgts[ms->conn_tgt].data_goes_out);\r\n}\r\nscsi_dma_unmap(cmd);\r\nms->dma_started = 0;\r\n}\r\nstatic void phase_mismatch(struct mesh_state *ms)\r\n{\r\nvolatile struct mesh_regs __iomem *mr = ms->mesh;\r\nint phase;\r\ndlog(ms, "phasemm ch/cl/seq/fc=%.8x",\r\nMKWORD(mr->count_hi, mr->count_lo, mr->sequence, mr->fifo_count));\r\nphase = in_8(&mr->bus_status0) & BS0_PHASE;\r\nif (ms->msgphase == msg_out_xxx && phase == BP_MSGOUT) {\r\nout_8(&mr->count_lo, 1);\r\nout_8(&mr->sequence, SEQ_MSGOUT + use_active_neg);\r\nmesh_flush_io(mr);\r\nudelay(1);\r\nout_8(&mr->fifo, ms->msgout[ms->n_msgout-1]);\r\nms->msgphase = msg_out_last;\r\nreturn;\r\n}\r\nif (ms->msgphase == msg_in) {\r\nget_msgin(ms);\r\nif (ms->n_msgin)\r\nhandle_msgin(ms);\r\n}\r\nif (ms->dma_started)\r\nhalt_dma(ms);\r\nif (mr->fifo_count) {\r\nout_8(&mr->sequence, SEQ_FLUSHFIFO);\r\nmesh_flush_io(mr);\r\nudelay(1);\r\n}\r\nms->msgphase = msg_none;\r\nswitch (phase) {\r\ncase BP_DATAIN:\r\nms->tgts[ms->conn_tgt].data_goes_out = 0;\r\nms->phase = dataing;\r\nbreak;\r\ncase BP_DATAOUT:\r\nms->tgts[ms->conn_tgt].data_goes_out = 1;\r\nms->phase = dataing;\r\nbreak;\r\ncase BP_COMMAND:\r\nms->phase = commanding;\r\nbreak;\r\ncase BP_STATUS:\r\nms->phase = statusing;\r\nbreak;\r\ncase BP_MSGIN:\r\nms->msgphase = msg_in;\r\nms->n_msgin = 0;\r\nbreak;\r\ncase BP_MSGOUT:\r\nms->msgphase = msg_out;\r\nif (ms->n_msgout == 0) {\r\nif (ms->aborting) {\r\ndo_abort(ms);\r\n} else {\r\nif (ms->last_n_msgout == 0) {\r\nprintk(KERN_DEBUG\r\n"mesh: no msg to repeat\n");\r\nms->msgout[0] = NOP;\r\nms->last_n_msgout = 1;\r\n}\r\nms->n_msgout = ms->last_n_msgout;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nprintk(KERN_DEBUG "mesh: unknown scsi phase %x\n", phase);\r\nms->stat = DID_ERROR;\r\nmesh_done(ms, 1);\r\nreturn;\r\n}\r\nstart_phase(ms);\r\n}\r\nstatic void cmd_complete(struct mesh_state *ms)\r\n{\r\nvolatile struct mesh_regs __iomem *mr = ms->mesh;\r\nstruct scsi_cmnd *cmd = ms->current_req;\r\nstruct mesh_target *tp = &ms->tgts[ms->conn_tgt];\r\nint seq, n, t;\r\ndlog(ms, "cmd_complete fc=%x", mr->fifo_count);\r\nseq = use_active_neg + (ms->n_msgout? SEQ_ATN: 0);\r\nswitch (ms->msgphase) {\r\ncase msg_out_xxx:\r\nms->n_msgin = 0;\r\nms->msgphase = msg_in;\r\ncase msg_in:\r\nget_msgin(ms);\r\nn = msgin_length(ms);\r\nif (ms->n_msgin < n) {\r\nout_8(&mr->count_lo, n - ms->n_msgin);\r\nout_8(&mr->sequence, SEQ_MSGIN + seq);\r\n} else {\r\nms->msgphase = msg_none;\r\nhandle_msgin(ms);\r\nstart_phase(ms);\r\n}\r\nbreak;\r\ncase msg_in_bad:\r\nout_8(&mr->sequence, SEQ_FLUSHFIFO);\r\nmesh_flush_io(mr);\r\nudelay(1);\r\nout_8(&mr->count_lo, 1);\r\nout_8(&mr->sequence, SEQ_MSGIN + SEQ_ATN + use_active_neg);\r\nbreak;\r\ncase msg_out:\r\nout_8(&mr->count_lo, 1);\r\nout_8(&mr->sequence, SEQ_MSGOUT + use_active_neg + SEQ_ATN);\r\nt = 30;\r\nwhile ((in_8(&mr->bus_status0) & BS0_REQ) == 0 && --t >= 0)\r\nudelay(1);\r\ndlog(ms, "last_mbyte err/exc/fc/cl=%.8x",\r\nMKWORD(mr->error, mr->exception,\r\nmr->fifo_count, mr->count_lo));\r\nif (in_8(&mr->interrupt) & (INT_ERROR | INT_EXCEPTION)) {\r\nms->last_n_msgout = ms->n_msgout;\r\nms->n_msgout = 0;\r\nif (in_8(&mr->interrupt) & INT_ERROR) {\r\nprintk(KERN_ERR "mesh: error %x in msg_out\n",\r\nin_8(&mr->error));\r\nhandle_error(ms);\r\nreturn;\r\n}\r\nif (in_8(&mr->exception) != EXC_PHASEMM)\r\nprintk(KERN_ERR "mesh: exc %x in msg_out\n",\r\nin_8(&mr->exception));\r\nelse\r\nprintk(KERN_DEBUG "mesh: bs0=%x in msg_out\n",\r\nin_8(&mr->bus_status0));\r\nhandle_exception(ms);\r\nreturn;\r\n}\r\nif (in_8(&mr->bus_status0) & BS0_REQ) {\r\nout_8(&mr->sequence, SEQ_MSGOUT + use_active_neg);\r\nmesh_flush_io(mr);\r\nudelay(1);\r\nout_8(&mr->fifo, ms->msgout[ms->n_msgout-1]);\r\nms->msgphase = msg_out_last;\r\n} else {\r\nout_8(&mr->sequence, SEQ_MSGIN + use_active_neg + SEQ_ATN);\r\nms->msgphase = msg_out_xxx;\r\n}\r\nbreak;\r\ncase msg_out_last:\r\nms->last_n_msgout = ms->n_msgout;\r\nms->n_msgout = 0;\r\nms->msgphase = ms->expect_reply? msg_in: msg_none;\r\nstart_phase(ms);\r\nbreak;\r\ncase msg_none:\r\nswitch (ms->phase) {\r\ncase idle:\r\nprintk(KERN_ERR "mesh: interrupt in idle phase?\n");\r\ndumpslog(ms);\r\nreturn;\r\ncase selecting:\r\ndlog(ms, "Selecting phase at command completion",0);\r\nms->msgout[0] = IDENTIFY(ALLOW_RESEL(ms->conn_tgt),\r\n(cmd? cmd->device->lun: 0));\r\nms->n_msgout = 1;\r\nms->expect_reply = 0;\r\nif (ms->aborting) {\r\nms->msgout[0] = ABORT;\r\nms->n_msgout++;\r\n} else if (tp->sdtr_state == do_sdtr) {\r\nadd_sdtr_msg(ms);\r\nms->expect_reply = 1;\r\ntp->sdtr_state = sdtr_sent;\r\n}\r\nms->msgphase = msg_out;\r\nt = 230;\r\nwhile ((in_8(&mr->bus_status0) & BS0_REQ) == 0) {\r\nif (--t < 0) {\r\ndlog(ms, "impatient for req", ms->n_msgout);\r\nms->msgphase = msg_none;\r\nbreak;\r\n}\r\nudelay(1);\r\n}\r\nbreak;\r\ncase dataing:\r\nif (ms->dma_count != 0) {\r\nstart_phase(ms);\r\nreturn;\r\n}\r\nout_8(&mr->sequence, 0);\r\nout_8(&mr->interrupt,\r\nINT_ERROR | INT_EXCEPTION | INT_CMDDONE);\r\nhalt_dma(ms);\r\nbreak;\r\ncase statusing:\r\nif (cmd) {\r\ncmd->SCp.Status = mr->fifo;\r\nif (DEBUG_TARGET(cmd))\r\nprintk(KERN_DEBUG "mesh: status is %x\n",\r\ncmd->SCp.Status);\r\n}\r\nms->msgphase = msg_in;\r\nbreak;\r\ncase busfreeing:\r\nmesh_done(ms, 1);\r\nreturn;\r\ncase disconnecting:\r\nms->current_req = NULL;\r\nms->phase = idle;\r\nmesh_start(ms);\r\nreturn;\r\ndefault:\r\nbreak;\r\n}\r\n++ms->phase;\r\nstart_phase(ms);\r\nbreak;\r\n}\r\n}\r\nstatic int mesh_queue_lck(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *))\r\n{\r\nstruct mesh_state *ms;\r\ncmd->scsi_done = done;\r\ncmd->host_scribble = NULL;\r\nms = (struct mesh_state *) cmd->device->host->hostdata;\r\nif (ms->request_q == NULL)\r\nms->request_q = cmd;\r\nelse\r\nms->request_qtail->host_scribble = (void *) cmd;\r\nms->request_qtail = cmd;\r\nif (ms->phase == idle)\r\nmesh_start(ms);\r\nreturn 0;\r\n}\r\nstatic int mesh_abort(struct scsi_cmnd *cmd)\r\n{\r\nstruct mesh_state *ms = (struct mesh_state *) cmd->device->host->hostdata;\r\nprintk(KERN_DEBUG "mesh_abort(%p)\n", cmd);\r\nmesh_dump_regs(ms);\r\ndumplog(ms, cmd->device->id);\r\ndumpslog(ms);\r\nreturn FAILED;\r\n}\r\nstatic int mesh_host_reset(struct scsi_cmnd *cmd)\r\n{\r\nstruct mesh_state *ms = (struct mesh_state *) cmd->device->host->hostdata;\r\nvolatile struct mesh_regs __iomem *mr = ms->mesh;\r\nvolatile struct dbdma_regs __iomem *md = ms->dma;\r\nunsigned long flags;\r\nprintk(KERN_DEBUG "mesh_host_reset\n");\r\nspin_lock_irqsave(ms->host->host_lock, flags);\r\nout_le32(&md->control, (RUN|PAUSE|FLUSH|WAKE) << 16);\r\nout_8(&mr->exception, 0xff);\r\nout_8(&mr->error, 0xff);\r\nout_8(&mr->sequence, SEQ_RESETMESH);\r\nmesh_flush_io(mr);\r\nudelay(1);\r\nout_8(&mr->intr_mask, INT_ERROR | INT_EXCEPTION | INT_CMDDONE);\r\nout_8(&mr->source_id, ms->host->this_id);\r\nout_8(&mr->sel_timeout, 25);\r\nout_8(&mr->sync_params, ASYNC_PARAMS);\r\nout_8(&mr->bus_status1, BS1_RST);\r\nmesh_flush_io(mr);\r\nudelay(30);\r\nout_8(&mr->bus_status1, 0);\r\nhandle_reset(ms);\r\nspin_unlock_irqrestore(ms->host->host_lock, flags);\r\nreturn SUCCESS;\r\n}\r\nstatic void set_mesh_power(struct mesh_state *ms, int state)\r\n{\r\nif (!machine_is(powermac))\r\nreturn;\r\nif (state) {\r\npmac_call_feature(PMAC_FTR_MESH_ENABLE, macio_get_of_node(ms->mdev), 0, 1);\r\nmsleep(200);\r\n} else {\r\npmac_call_feature(PMAC_FTR_MESH_ENABLE, macio_get_of_node(ms->mdev), 0, 0);\r\nmsleep(10);\r\n}\r\n}\r\nstatic int mesh_suspend(struct macio_dev *mdev, pm_message_t mesg)\r\n{\r\nstruct mesh_state *ms = (struct mesh_state *)macio_get_drvdata(mdev);\r\nunsigned long flags;\r\nswitch (mesg.event) {\r\ncase PM_EVENT_SUSPEND:\r\ncase PM_EVENT_HIBERNATE:\r\ncase PM_EVENT_FREEZE:\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (ms->phase == sleeping)\r\nreturn 0;\r\nscsi_block_requests(ms->host);\r\nspin_lock_irqsave(ms->host->host_lock, flags);\r\nwhile(ms->phase != idle) {\r\nspin_unlock_irqrestore(ms->host->host_lock, flags);\r\nmsleep(10);\r\nspin_lock_irqsave(ms->host->host_lock, flags);\r\n}\r\nms->phase = sleeping;\r\nspin_unlock_irqrestore(ms->host->host_lock, flags);\r\ndisable_irq(ms->meshintr);\r\nset_mesh_power(ms, 0);\r\nreturn 0;\r\n}\r\nstatic int mesh_resume(struct macio_dev *mdev)\r\n{\r\nstruct mesh_state *ms = (struct mesh_state *)macio_get_drvdata(mdev);\r\nunsigned long flags;\r\nif (ms->phase != sleeping)\r\nreturn 0;\r\nset_mesh_power(ms, 1);\r\nmesh_init(ms);\r\nspin_lock_irqsave(ms->host->host_lock, flags);\r\nmesh_start(ms);\r\nspin_unlock_irqrestore(ms->host->host_lock, flags);\r\nenable_irq(ms->meshintr);\r\nscsi_unblock_requests(ms->host);\r\nreturn 0;\r\n}\r\nstatic int mesh_shutdown(struct macio_dev *mdev)\r\n{\r\nstruct mesh_state *ms = (struct mesh_state *)macio_get_drvdata(mdev);\r\nvolatile struct mesh_regs __iomem *mr;\r\nunsigned long flags;\r\nprintk(KERN_INFO "resetting MESH scsi bus(es)\n");\r\nspin_lock_irqsave(ms->host->host_lock, flags);\r\nmr = ms->mesh;\r\nout_8(&mr->intr_mask, 0);\r\nout_8(&mr->interrupt, INT_ERROR | INT_EXCEPTION | INT_CMDDONE);\r\nout_8(&mr->bus_status1, BS1_RST);\r\nmesh_flush_io(mr);\r\nudelay(30);\r\nout_8(&mr->bus_status1, 0);\r\nspin_unlock_irqrestore(ms->host->host_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int mesh_probe(struct macio_dev *mdev, const struct of_device_id *match)\r\n{\r\nstruct device_node *mesh = macio_get_of_node(mdev);\r\nstruct pci_dev* pdev = macio_get_pci_dev(mdev);\r\nint tgt, minper;\r\nconst int *cfp;\r\nstruct mesh_state *ms;\r\nstruct Scsi_Host *mesh_host;\r\nvoid *dma_cmd_space;\r\ndma_addr_t dma_cmd_bus;\r\nswitch (mdev->bus->chip->type) {\r\ncase macio_heathrow:\r\ncase macio_gatwick:\r\ncase macio_paddington:\r\nuse_active_neg = 0;\r\nbreak;\r\ndefault:\r\nuse_active_neg = SEQ_ACTIVE_NEG;\r\n}\r\nif (macio_resource_count(mdev) != 2 || macio_irq_count(mdev) != 2) {\r\nprintk(KERN_ERR "mesh: expected 2 addrs and 2 intrs"\r\n" (got %d,%d)\n", macio_resource_count(mdev),\r\nmacio_irq_count(mdev));\r\nreturn -ENODEV;\r\n}\r\nif (macio_request_resources(mdev, "mesh") != 0) {\r\nprintk(KERN_ERR "mesh: unable to request memory resources");\r\nreturn -EBUSY;\r\n}\r\nmesh_host = scsi_host_alloc(&mesh_template, sizeof(struct mesh_state));\r\nif (mesh_host == NULL) {\r\nprintk(KERN_ERR "mesh: couldn't register host");\r\ngoto out_release;\r\n}\r\n#if !defined(MODULE)\r\nnote_scsi_host(mesh, mesh_host);\r\n#endif\r\nmesh_host->base = macio_resource_start(mdev, 0);\r\nmesh_host->irq = macio_irq(mdev, 0);\r\nms = (struct mesh_state *) mesh_host->hostdata;\r\nmacio_set_drvdata(mdev, ms);\r\nms->host = mesh_host;\r\nms->mdev = mdev;\r\nms->pdev = pdev;\r\nms->mesh = ioremap(macio_resource_start(mdev, 0), 0x1000);\r\nif (ms->mesh == NULL) {\r\nprintk(KERN_ERR "mesh: can't map registers\n");\r\ngoto out_free;\r\n}\r\nms->dma = ioremap(macio_resource_start(mdev, 1), 0x1000);\r\nif (ms->dma == NULL) {\r\nprintk(KERN_ERR "mesh: can't map registers\n");\r\niounmap(ms->mesh);\r\ngoto out_free;\r\n}\r\nms->meshintr = macio_irq(mdev, 0);\r\nms->dmaintr = macio_irq(mdev, 1);\r\nms->dma_cmd_size = (mesh_host->sg_tablesize + 2) * sizeof(struct dbdma_cmd);\r\ndma_cmd_space = pci_zalloc_consistent(macio_get_pci_dev(mdev),\r\nms->dma_cmd_size, &dma_cmd_bus);\r\nif (dma_cmd_space == NULL) {\r\nprintk(KERN_ERR "mesh: can't allocate DMA table\n");\r\ngoto out_unmap;\r\n}\r\nms->dma_cmds = (struct dbdma_cmd *) DBDMA_ALIGN(dma_cmd_space);\r\nms->dma_cmd_space = dma_cmd_space;\r\nms->dma_cmd_bus = dma_cmd_bus + ((unsigned long)ms->dma_cmds)\r\n- (unsigned long)dma_cmd_space;\r\nms->current_req = NULL;\r\nfor (tgt = 0; tgt < 8; ++tgt) {\r\nms->tgts[tgt].sdtr_state = do_sdtr;\r\nms->tgts[tgt].sync_params = ASYNC_PARAMS;\r\nms->tgts[tgt].current_req = NULL;\r\n}\r\nif ((cfp = of_get_property(mesh, "clock-frequency", NULL)))\r\nms->clk_freq = *cfp;\r\nelse {\r\nprintk(KERN_INFO "mesh: assuming 50MHz clock frequency\n");\r\nms->clk_freq = 50000000;\r\n}\r\nminper = 1000000000 / (ms->clk_freq / 5);\r\nif (mesh_sync_period < minper)\r\nmesh_sync_period = minper;\r\nset_mesh_power(ms, 1);\r\nmesh_init(ms);\r\nif (request_irq(ms->meshintr, do_mesh_interrupt, 0, "MESH", ms)) {\r\nprintk(KERN_ERR "MESH: can't get irq %d\n", ms->meshintr);\r\ngoto out_shutdown;\r\n}\r\nif (scsi_add_host(mesh_host, &mdev->ofdev.dev))\r\ngoto out_release_irq;\r\nscsi_scan_host(mesh_host);\r\nreturn 0;\r\nout_release_irq:\r\nfree_irq(ms->meshintr, ms);\r\nout_shutdown:\r\nmesh_shutdown(mdev);\r\nset_mesh_power(ms, 0);\r\npci_free_consistent(macio_get_pci_dev(mdev), ms->dma_cmd_size,\r\nms->dma_cmd_space, ms->dma_cmd_bus);\r\nout_unmap:\r\niounmap(ms->dma);\r\niounmap(ms->mesh);\r\nout_free:\r\nscsi_host_put(mesh_host);\r\nout_release:\r\nmacio_release_resources(mdev);\r\nreturn -ENODEV;\r\n}\r\nstatic int mesh_remove(struct macio_dev *mdev)\r\n{\r\nstruct mesh_state *ms = (struct mesh_state *)macio_get_drvdata(mdev);\r\nstruct Scsi_Host *mesh_host = ms->host;\r\nscsi_remove_host(mesh_host);\r\nfree_irq(ms->meshintr, ms);\r\nmesh_shutdown(mdev);\r\nset_mesh_power(ms, 0);\r\niounmap(ms->mesh);\r\niounmap(ms->dma);\r\npci_free_consistent(macio_get_pci_dev(mdev), ms->dma_cmd_size,\r\nms->dma_cmd_space, ms->dma_cmd_bus);\r\nmacio_release_resources(mdev);\r\nscsi_host_put(mesh_host);\r\nreturn 0;\r\n}\r\nstatic int __init init_mesh(void)\r\n{\r\nif (sync_rate > 10)\r\nsync_rate = 10;\r\nif (sync_rate > 0) {\r\nprintk(KERN_INFO "mesh: configured for synchronous %d MB/s\n", sync_rate);\r\nmesh_sync_period = 1000 / sync_rate;\r\nmesh_sync_offset = 15;\r\n} else\r\nprintk(KERN_INFO "mesh: configured for asynchronous\n");\r\nreturn macio_register_driver(&mesh_driver);\r\n}\r\nstatic void __exit exit_mesh(void)\r\n{\r\nreturn macio_unregister_driver(&mesh_driver);\r\n}
