static unsigned int z8536_read(struct comedi_device *dev, unsigned int reg)\r\n{\r\nunsigned long flags;\r\nunsigned int val;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\noutb(reg, dev->iobase + APCI1500_Z8536_CTRL_REG);\r\nval = inb(dev->iobase + APCI1500_Z8536_CTRL_REG);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nreturn val;\r\n}\r\nstatic void z8536_write(struct comedi_device *dev,\r\nunsigned int val, unsigned int reg)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\noutb(reg, dev->iobase + APCI1500_Z8536_CTRL_REG);\r\noutb(val, dev->iobase + APCI1500_Z8536_CTRL_REG);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\n}\r\nstatic void z8536_reset(struct comedi_device *dev)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ninb(dev->iobase + APCI1500_Z8536_CTRL_REG);\r\noutb(0, dev->iobase + APCI1500_Z8536_CTRL_REG);\r\ninb(dev->iobase + APCI1500_Z8536_CTRL_REG);\r\noutb(0, dev->iobase + APCI1500_Z8536_CTRL_REG);\r\noutb(1, dev->iobase + APCI1500_Z8536_CTRL_REG);\r\noutb(0, dev->iobase + APCI1500_Z8536_CTRL_REG);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nz8536_write(dev, 0x00, Z8536_CFG_CTRL_REG);\r\nz8536_write(dev, Z8536_PAB_MODE_PTS_BIT |\r\nZ8536_PAB_MODE_SB |\r\nZ8536_PAB_MODE_PMS_DISABLE,\r\nZ8536_PA_MODE_REG);\r\nz8536_write(dev, 0xff, Z8536_PB_DPP_REG);\r\nz8536_write(dev, 0xff, Z8536_PA_DD_REG);\r\nz8536_write(dev, Z8536_PAB_MODE_PTS_BIT |\r\nZ8536_PAB_MODE_SB |\r\nZ8536_PAB_MODE_PMS_DISABLE,\r\nZ8536_PB_MODE_REG);\r\nz8536_write(dev, 0x7f, Z8536_PB_DPP_REG);\r\nz8536_write(dev, 0xff, Z8536_PB_DD_REG);\r\nz8536_write(dev, 0x09, Z8536_PC_DPP_REG);\r\nz8536_write(dev, 0x0e, Z8536_PC_DD_REG);\r\nz8536_write(dev, Z8536_CMD_CLR_IP_IUS, Z8536_PA_CMDSTAT_REG);\r\nz8536_write(dev, Z8536_CMD_CLR_IE, Z8536_PA_CMDSTAT_REG);\r\nz8536_write(dev, Z8536_CMD_CLR_IP_IUS, Z8536_PB_CMDSTAT_REG);\r\nz8536_write(dev, Z8536_CMD_CLR_IE, Z8536_PB_CMDSTAT_REG);\r\nz8536_write(dev, Z8536_CMD_CLR_IP_IUS, Z8536_CT_CMDSTAT_REG(0));\r\nz8536_write(dev, Z8536_CMD_CLR_IE, Z8536_CT_CMDSTAT_REG(0));\r\nz8536_write(dev, Z8536_CMD_CLR_IP_IUS, Z8536_CT_CMDSTAT_REG(1));\r\nz8536_write(dev, Z8536_CMD_CLR_IE, Z8536_CT_CMDSTAT_REG(1));\r\nz8536_write(dev, Z8536_CMD_CLR_IP_IUS, Z8536_CT_CMDSTAT_REG(2));\r\nz8536_write(dev, Z8536_CMD_CLR_IE, Z8536_CT_CMDSTAT_REG(2));\r\nz8536_write(dev, 0x00, Z8536_INT_CTRL_REG);\r\n}\r\nstatic void apci1500_port_enable(struct comedi_device *dev, bool enable)\r\n{\r\nunsigned int cfg;\r\ncfg = z8536_read(dev, Z8536_CFG_CTRL_REG);\r\nif (enable)\r\ncfg |= (Z8536_CFG_CTRL_PAE | Z8536_CFG_CTRL_PBE);\r\nelse\r\ncfg &= ~(Z8536_CFG_CTRL_PAE | Z8536_CFG_CTRL_PBE);\r\nz8536_write(dev, cfg, Z8536_CFG_CTRL_REG);\r\n}\r\nstatic void apci1500_timer_enable(struct comedi_device *dev,\r\nunsigned int chan, bool enable)\r\n{\r\nunsigned int bit;\r\nunsigned int cfg;\r\nif (chan == 0)\r\nbit = Z8536_CFG_CTRL_CT1E;\r\nelse if (chan == 1)\r\nbit = Z8536_CFG_CTRL_CT2E;\r\nelse\r\nbit = Z8536_CFG_CTRL_PCE_CT3E;\r\ncfg = z8536_read(dev, Z8536_CFG_CTRL_REG);\r\nif (enable) {\r\ncfg |= bit;\r\n} else {\r\ncfg &= ~bit;\r\nz8536_write(dev, 0x00, Z8536_CT_CMDSTAT_REG(chan));\r\n}\r\nz8536_write(dev, cfg, Z8536_CFG_CTRL_REG);\r\n}\r\nstatic bool apci1500_ack_irq(struct comedi_device *dev,\r\nunsigned int reg)\r\n{\r\nunsigned int val;\r\nval = z8536_read(dev, reg);\r\nif ((val & Z8536_STAT_IE_IP) == Z8536_STAT_IE_IP) {\r\nval &= 0x0f;\r\nval |= Z8536_CMD_CLR_IP_IUS;\r\nz8536_write(dev, val, reg);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic irqreturn_t apci1500_interrupt(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nstruct apci1500_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nunsigned int status = 0;\r\nunsigned int val;\r\nval = inl(devpriv->amcc + AMCC_OP_REG_INTCSR);\r\nif (!(val & INTCSR_INTR_ASSERTED))\r\nreturn IRQ_NONE;\r\nif (apci1500_ack_irq(dev, Z8536_PA_CMDSTAT_REG))\r\nstatus |= 0x01;\r\nif (apci1500_ack_irq(dev, Z8536_PB_CMDSTAT_REG)) {\r\nval = inb(dev->iobase + APCI1500_Z8536_PORTB_REG);\r\nval &= 0xc0;\r\nif (val) {\r\nif (val & 0x80)\r\nstatus |= 0x40;\r\nif (val & 0x40)\r\nstatus |= 0x80;\r\n} else {\r\nstatus |= 0x02;\r\n}\r\n}\r\ncomedi_buf_write_samples(s, &status, 1);\r\ncomedi_handle_events(dev, s);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int apci1500_di_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nz8536_write(dev, 0x00, Z8536_INT_CTRL_REG);\r\napci1500_port_enable(dev, false);\r\napci1500_ack_irq(dev, Z8536_PA_CMDSTAT_REG);\r\napci1500_ack_irq(dev, Z8536_PB_CMDSTAT_REG);\r\nz8536_write(dev, Z8536_CMD_CLR_IE, Z8536_PA_CMDSTAT_REG);\r\nz8536_write(dev, Z8536_CMD_CLR_IE, Z8536_PB_CMDSTAT_REG);\r\napci1500_port_enable(dev, true);\r\nreturn 0;\r\n}\r\nstatic int apci1500_di_inttrig_start(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int trig_num)\r\n{\r\nstruct apci1500_private *devpriv = dev->private;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned int pa_mode = Z8536_PAB_MODE_PMS_DISABLE;\r\nunsigned int pb_mode = Z8536_PAB_MODE_PMS_DISABLE;\r\nunsigned int pa_trig = trig_num & 0x01;\r\nunsigned int pb_trig = (trig_num >> 1) & 0x01;\r\nbool valid_trig = false;\r\nunsigned int val;\r\nif (trig_num != cmd->start_arg)\r\nreturn -EINVAL;\r\napci1500_port_enable(dev, false);\r\nz8536_write(dev, devpriv->pm[pa_trig] & 0xff, Z8536_PA_PM_REG);\r\nz8536_write(dev, devpriv->pt[pa_trig] & 0xff, Z8536_PA_PT_REG);\r\nz8536_write(dev, devpriv->pp[pa_trig] & 0xff, Z8536_PA_PP_REG);\r\nz8536_write(dev, (devpriv->pm[pb_trig] >> 8) & 0xff, Z8536_PB_PM_REG);\r\nz8536_write(dev, (devpriv->pt[pb_trig] >> 8) & 0xff, Z8536_PB_PT_REG);\r\nz8536_write(dev, (devpriv->pp[pb_trig] >> 8) & 0xff, Z8536_PB_PP_REG);\r\nif (devpriv->pm[pa_trig] & 0xff) {\r\npa_mode = pa_trig ? Z8536_PAB_MODE_PMS_AND\r\n: Z8536_PAB_MODE_PMS_OR;\r\nval = z8536_read(dev, Z8536_PA_MODE_REG);\r\nval &= ~Z8536_PAB_MODE_PMS_MASK;\r\nval |= (pa_mode | Z8536_PAB_MODE_IMO);\r\nz8536_write(dev, val, Z8536_PA_MODE_REG);\r\nz8536_write(dev, Z8536_CMD_SET_IE, Z8536_PA_CMDSTAT_REG);\r\nvalid_trig = true;\r\ndev_dbg(dev->class_dev,\r\n"Port A configured for %s mode pattern detection\n",\r\npa_trig ? "AND" : "OR");\r\n}\r\nif (devpriv->pm[pb_trig] & 0xff00) {\r\npb_mode = pb_trig ? Z8536_PAB_MODE_PMS_AND\r\n: Z8536_PAB_MODE_PMS_OR;\r\nval = z8536_read(dev, Z8536_PB_MODE_REG);\r\nval &= ~Z8536_PAB_MODE_PMS_MASK;\r\nval |= (pb_mode | Z8536_PAB_MODE_IMO);\r\nz8536_write(dev, val, Z8536_PB_MODE_REG);\r\nz8536_write(dev, Z8536_CMD_SET_IE, Z8536_PB_CMDSTAT_REG);\r\nvalid_trig = true;\r\ndev_dbg(dev->class_dev,\r\n"Port B configured for %s mode pattern detection\n",\r\npb_trig ? "AND" : "OR");\r\n}\r\napci1500_port_enable(dev, true);\r\nif (!valid_trig) {\r\ndev_dbg(dev->class_dev,\r\n"digital trigger %d is not configured\n", trig_num);\r\nreturn -EINVAL;\r\n}\r\nz8536_write(dev, Z8536_INT_CTRL_MIE | Z8536_INT_CTRL_DLC,\r\nZ8536_INT_CTRL_REG);\r\nreturn 0;\r\n}\r\nstatic int apci1500_di_cmd(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\ns->async->inttrig = apci1500_di_inttrig_start;\r\nreturn 0;\r\n}\r\nstatic int apci1500_di_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nint err = 0;\r\nerr |= comedi_check_trigger_src(&cmd->start_src, TRIG_INT);\r\nerr |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_EXT);\r\nerr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_FOLLOW);\r\nerr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_NONE);\r\nif (err)\r\nreturn 1;\r\nerr |= comedi_check_trigger_arg_max(&cmd->start_arg, 3);\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\r\nerr |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\r\ncmd->chanlist_len);\r\nerr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\r\nif (err)\r\nreturn 3;\r\nreturn 0;\r\n}\r\nstatic int apci1500_di_cfg_trig(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct apci1500_private *devpriv = dev->private;\r\nunsigned int trig = data[1];\r\nunsigned int shift = data[3];\r\nunsigned int hi_mask = data[4] << shift;\r\nunsigned int lo_mask = data[5] << shift;\r\nunsigned int chan_mask = hi_mask | lo_mask;\r\nunsigned int old_mask = (1 << shift) - 1;\r\nunsigned int pm = devpriv->pm[trig] & old_mask;\r\nunsigned int pt = devpriv->pt[trig] & old_mask;\r\nunsigned int pp = devpriv->pp[trig] & old_mask;\r\nif (trig > 1) {\r\ndev_dbg(dev->class_dev,\r\n"invalid digital trigger number (0=AND, 1=OR)\n");\r\nreturn -EINVAL;\r\n}\r\nif (chan_mask > 0xffff) {\r\ndev_dbg(dev->class_dev, "invalid digital trigger channel\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (data[2]) {\r\ncase COMEDI_DIGITAL_TRIG_DISABLE:\r\npm = 0;\r\npt = 0;\r\npp = 0;\r\nbreak;\r\ncase COMEDI_DIGITAL_TRIG_ENABLE_EDGES:\r\npm |= chan_mask;\r\npt |= chan_mask;\r\npp |= hi_mask;\r\npp &= ~lo_mask;\r\nbreak;\r\ncase COMEDI_DIGITAL_TRIG_ENABLE_LEVELS:\r\npm |= chan_mask;\r\npt &= ~chan_mask;\r\npp |= hi_mask;\r\npp &= ~lo_mask;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (trig == 0) {\r\nint ret = 0;\r\nunsigned int src;\r\nsrc = pt & 0xff;\r\nif (src)\r\nret |= comedi_check_trigger_is_unique(src);\r\nsrc = (pt >> 8) & 0xff;\r\nif (src)\r\nret |= comedi_check_trigger_is_unique(src);\r\nif (ret) {\r\ndev_dbg(dev->class_dev,\r\n"invalid AND trigger configuration\n");\r\nreturn ret;\r\n}\r\n}\r\ndevpriv->pm[trig] = pm;\r\ndevpriv->pt[trig] = pt;\r\ndevpriv->pp[trig] = pp;\r\nreturn insn->n;\r\n}\r\nstatic int apci1500_di_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_DIGITAL_TRIG:\r\nreturn apci1500_di_cfg_trig(dev, s, insn, data);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int apci1500_di_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct apci1500_private *devpriv = dev->private;\r\ndata[1] = inw(devpriv->addon + APCI1500_DI_REG);\r\nreturn insn->n;\r\n}\r\nstatic int apci1500_do_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct apci1500_private *devpriv = dev->private;\r\nif (comedi_dio_update_state(s, data))\r\noutw(s->state, devpriv->addon + APCI1500_DO_REG);\r\ndata[1] = s->state;\r\nreturn insn->n;\r\n}\r\nstatic int apci1500_timer_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct apci1500_private *devpriv = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int val;\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_ARM:\r\nval = data[1] & s->maxdata;\r\nz8536_write(dev, val & 0xff, Z8536_CT_RELOAD_LSB_REG(chan));\r\nz8536_write(dev, (val >> 8) & 0xff,\r\nZ8536_CT_RELOAD_MSB_REG(chan));\r\napci1500_timer_enable(dev, chan, true);\r\nz8536_write(dev, Z8536_CT_CMDSTAT_GCB,\r\nZ8536_CT_CMDSTAT_REG(chan));\r\nbreak;\r\ncase INSN_CONFIG_DISARM:\r\napci1500_timer_enable(dev, chan, false);\r\nbreak;\r\ncase INSN_CONFIG_GET_COUNTER_STATUS:\r\ndata[1] = 0;\r\nval = z8536_read(dev, Z8536_CT_CMDSTAT_REG(chan));\r\nif (val & Z8536_CT_STAT_CIP)\r\ndata[1] |= COMEDI_COUNTER_COUNTING;\r\nif (val & Z8536_CT_CMDSTAT_GCB)\r\ndata[1] |= COMEDI_COUNTER_ARMED;\r\nif (val & Z8536_STAT_IP) {\r\ndata[1] |= COMEDI_COUNTER_TERMINAL_COUNT;\r\napci1500_ack_irq(dev, Z8536_CT_CMDSTAT_REG(chan));\r\n}\r\ndata[2] = COMEDI_COUNTER_ARMED | COMEDI_COUNTER_COUNTING |\r\nCOMEDI_COUNTER_TERMINAL_COUNT;\r\nbreak;\r\ncase INSN_CONFIG_SET_COUNTER_MODE:\r\nswitch (data[1]) {\r\ncase I8254_MODE0:\r\nval = Z8536_CT_MODE_ECE |\r\nZ8536_CT_MODE_DCS_ONESHOT;\r\nbreak;\r\ncase I8254_MODE1:\r\nval = Z8536_CT_MODE_ETE |\r\nZ8536_CT_MODE_DCS_ONESHOT;\r\nbreak;\r\ncase I8254_MODE2:\r\nval = Z8536_CT_MODE_CSC |\r\nZ8536_CT_MODE_DCS_PULSE;\r\nbreak;\r\ncase I8254_MODE3:\r\nval = Z8536_CT_MODE_CSC |\r\nZ8536_CT_MODE_DCS_SQRWAVE;\r\nbreak;\r\ncase I8254_MODE4:\r\nval = Z8536_CT_MODE_REB |\r\nZ8536_CT_MODE_DCS_PULSE;\r\nbreak;\r\ncase I8254_MODE5:\r\nval = Z8536_CT_MODE_EOE |\r\nZ8536_CT_MODE_ETE |\r\nZ8536_CT_MODE_REB |\r\nZ8536_CT_MODE_DCS_PULSE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\napci1500_timer_enable(dev, chan, false);\r\nz8536_write(dev, val, Z8536_CT_MODE_REG(chan));\r\nbreak;\r\ncase INSN_CONFIG_SET_CLOCK_SRC:\r\nif (data[1] > 2)\r\nreturn -EINVAL;\r\ndevpriv->clk_src = data[1];\r\nif (devpriv->clk_src == 2)\r\ndevpriv->clk_src = 3;\r\noutw(devpriv->clk_src, devpriv->addon + APCI1500_CLK_SEL_REG);\r\nbreak;\r\ncase INSN_CONFIG_GET_CLOCK_SRC:\r\nswitch (devpriv->clk_src) {\r\ncase 0:\r\ndata[1] = 0;\r\ndata[2] = 17879;\r\nbreak;\r\ncase 1:\r\ndata[1] = 1;\r\ndata[2] = 573066;\r\nbreak;\r\ncase 3:\r\ndata[1] = 2;\r\ndata[2] = 1164822;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase INSN_CONFIG_SET_GATE_SRC:\r\nif (chan == 0)\r\nreturn -EINVAL;\r\nval = z8536_read(dev, Z8536_CT_MODE_REG(chan));\r\nval &= Z8536_CT_MODE_EGE;\r\nif (data[1] == 1)\r\nval |= Z8536_CT_MODE_EGE;\r\nelse if (data[1] > 1)\r\nreturn -EINVAL;\r\nz8536_write(dev, val, Z8536_CT_MODE_REG(chan));\r\nbreak;\r\ncase INSN_CONFIG_GET_GATE_SRC:\r\nif (chan == 0)\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int apci1500_timer_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int cmd;\r\ncmd = z8536_read(dev, Z8536_CT_CMDSTAT_REG(chan));\r\ncmd &= Z8536_CT_CMDSTAT_GCB;\r\ncmd |= Z8536_CT_CMD_TCB;\r\nif (insn->n)\r\nz8536_write(dev, cmd, Z8536_CT_CMDSTAT_REG(chan));\r\nreturn insn->n;\r\n}\r\nstatic int apci1500_timer_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int cmd;\r\nunsigned int val;\r\nint i;\r\ncmd = z8536_read(dev, Z8536_CT_CMDSTAT_REG(chan));\r\ncmd &= Z8536_CT_CMDSTAT_GCB;\r\ncmd |= Z8536_CT_CMD_RCC;\r\nfor (i = 0; i < insn->n; i++) {\r\nz8536_write(dev, cmd, Z8536_CT_CMDSTAT_REG(chan));\r\nval = z8536_read(dev, Z8536_CT_VAL_MSB_REG(chan)) << 8;\r\nval |= z8536_read(dev, Z8536_CT_VAL_LSB_REG(chan));\r\ndata[i] = val;\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int apci1500_auto_attach(struct comedi_device *dev,\r\nunsigned long context)\r\n{\r\nstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\r\nstruct apci1500_private *devpriv;\r\nstruct comedi_subdevice *s;\r\nint ret;\r\ndevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\nret = comedi_pci_enable(dev);\r\nif (ret)\r\nreturn ret;\r\ndev->iobase = pci_resource_start(pcidev, 1);\r\ndevpriv->amcc = pci_resource_start(pcidev, 0);\r\ndevpriv->addon = pci_resource_start(pcidev, 2);\r\nz8536_reset(dev);\r\nif (pcidev->irq > 0) {\r\nret = request_irq(pcidev->irq, apci1500_interrupt, IRQF_SHARED,\r\ndev->board_name, dev);\r\nif (ret == 0)\r\ndev->irq = pcidev->irq;\r\n}\r\nret = comedi_alloc_subdevices(dev, 3);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[0];\r\ns->type = COMEDI_SUBD_DI;\r\ns->subdev_flags = SDF_READABLE;\r\ns->n_chan = 16;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = apci1500_di_insn_bits;\r\nif (dev->irq) {\r\ndev->read_subdev = s;\r\ns->subdev_flags |= SDF_CMD_READ;\r\ns->len_chanlist = 1;\r\ns->insn_config = apci1500_di_insn_config;\r\ns->do_cmdtest = apci1500_di_cmdtest;\r\ns->do_cmd = apci1500_di_cmd;\r\ns->cancel = apci1500_di_cancel;\r\n}\r\ns = &dev->subdevices[1];\r\ns->type = COMEDI_SUBD_DO;\r\ns->subdev_flags = SDF_WRITABLE;\r\ns->n_chan = 16;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = apci1500_do_insn_bits;\r\noutw(0x0, devpriv->addon + APCI1500_DO_REG);\r\ns = &dev->subdevices[2];\r\ns->type = COMEDI_SUBD_TIMER;\r\ns->subdev_flags = SDF_WRITABLE | SDF_READABLE;\r\ns->n_chan = 3;\r\ns->maxdata = 0xffff;\r\ns->range_table = &range_unknown;\r\ns->insn_config = apci1500_timer_insn_config;\r\ns->insn_write = apci1500_timer_insn_write;\r\ns->insn_read = apci1500_timer_insn_read;\r\nif (dev->irq) {\r\noutl(0x2000 | INTCSR_INBOX_FULL_INT,\r\ndevpriv->amcc + AMCC_OP_REG_INTCSR);\r\ninl(devpriv->amcc + AMCC_OP_REG_IMB1);\r\ninl(devpriv->amcc + AMCC_OP_REG_INTCSR);\r\noutl(INTCSR_INBOX_INTR_STATUS | 0x2000 | INTCSR_INBOX_FULL_INT,\r\ndevpriv->amcc + AMCC_OP_REG_INTCSR);\r\n}\r\nreturn 0;\r\n}\r\nstatic void apci1500_detach(struct comedi_device *dev)\r\n{\r\nstruct apci1500_private *devpriv = dev->private;\r\nif (devpriv->amcc)\r\noutl(0x0, devpriv->amcc + AMCC_OP_REG_INTCSR);\r\ncomedi_pci_detach(dev);\r\n}\r\nstatic int apci1500_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nreturn comedi_pci_auto_config(dev, &apci1500_driver, id->driver_data);\r\n}
