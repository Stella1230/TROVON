static void viafb_fill_var_color_info(struct fb_var_screeninfo *var, u8 depth)\r\n{\r\nvar->grayscale = 0;\r\nvar->red.msb_right = 0;\r\nvar->green.msb_right = 0;\r\nvar->blue.msb_right = 0;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nvar->transp.msb_right = 0;\r\nvar->nonstd = 0;\r\nswitch (depth) {\r\ncase 8:\r\nvar->bits_per_pixel = 8;\r\nvar->red.offset = 0;\r\nvar->green.offset = 0;\r\nvar->blue.offset = 0;\r\nvar->red.length = 8;\r\nvar->green.length = 8;\r\nvar->blue.length = 8;\r\nbreak;\r\ncase 15:\r\nvar->bits_per_pixel = 16;\r\nvar->red.offset = 10;\r\nvar->green.offset = 5;\r\nvar->blue.offset = 0;\r\nvar->red.length = 5;\r\nvar->green.length = 5;\r\nvar->blue.length = 5;\r\nbreak;\r\ncase 16:\r\nvar->bits_per_pixel = 16;\r\nvar->red.offset = 11;\r\nvar->green.offset = 5;\r\nvar->blue.offset = 0;\r\nvar->red.length = 5;\r\nvar->green.length = 6;\r\nvar->blue.length = 5;\r\nbreak;\r\ncase 24:\r\nvar->bits_per_pixel = 32;\r\nvar->red.offset = 16;\r\nvar->green.offset = 8;\r\nvar->blue.offset = 0;\r\nvar->red.length = 8;\r\nvar->green.length = 8;\r\nvar->blue.length = 8;\r\nbreak;\r\ncase 30:\r\nvar->bits_per_pixel = 32;\r\nvar->red.offset = 20;\r\nvar->green.offset = 10;\r\nvar->blue.offset = 0;\r\nvar->red.length = 10;\r\nvar->green.length = 10;\r\nvar->blue.length = 10;\r\nbreak;\r\n}\r\n}\r\nstatic void viafb_update_fix(struct fb_info *info)\r\n{\r\nu32 bpp = info->var.bits_per_pixel;\r\ninfo->fix.visual =\r\nbpp == 8 ? FB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;\r\ninfo->fix.line_length = ALIGN(info->var.xres_virtual * bpp / 8,\r\nVIA_PITCH_SIZE);\r\n}\r\nstatic void viafb_setup_fixinfo(struct fb_fix_screeninfo *fix,\r\nstruct viafb_par *viaparinfo)\r\n{\r\nmemset(fix, 0, sizeof(struct fb_fix_screeninfo));\r\nstrcpy(fix->id, viafb_name);\r\nfix->smem_start = viaparinfo->fbmem;\r\nfix->smem_len = viaparinfo->fbmem_free;\r\nfix->type = FB_TYPE_PACKED_PIXELS;\r\nfix->type_aux = 0;\r\nfix->visual = FB_VISUAL_TRUECOLOR;\r\nfix->xpanstep = fix->ywrapstep = 0;\r\nfix->ypanstep = 1;\r\nviafbinfo->fix.accel = FB_ACCEL_VIA_UNICHROME;\r\n}\r\nstatic int viafb_open(struct fb_info *info, int user)\r\n{\r\nDEBUG_MSG(KERN_INFO "viafb_open!\n");\r\nreturn 0;\r\n}\r\nstatic int viafb_release(struct fb_info *info, int user)\r\n{\r\nDEBUG_MSG(KERN_INFO "viafb_release!\n");\r\nreturn 0;\r\n}\r\nstatic inline int get_var_refresh(struct fb_var_screeninfo *var)\r\n{\r\nu32 htotal, vtotal;\r\nhtotal = var->left_margin + var->xres + var->right_margin\r\n+ var->hsync_len;\r\nvtotal = var->upper_margin + var->yres + var->lower_margin\r\n+ var->vsync_len;\r\nreturn PICOS2KHZ(var->pixclock) * 1000 / (htotal * vtotal);\r\n}\r\nstatic int viafb_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nint depth, refresh;\r\nstruct viafb_par *ppar = info->par;\r\nu32 line;\r\nDEBUG_MSG(KERN_INFO "viafb_check_var!\n");\r\nif (var->vmode & FB_VMODE_INTERLACED || var->vmode & FB_VMODE_DOUBLE)\r\nreturn -EINVAL;\r\nif (!viafb_get_best_mode(var->xres, var->yres, 60)) {\r\nDEBUG_MSG(KERN_INFO\r\n"viafb: Mode %dx%dx%d not supported!!\n",\r\nvar->xres, var->yres, var->bits_per_pixel);\r\nreturn -EINVAL;\r\n}\r\ndepth = fb_get_color_depth(var, &info->fix);\r\nif (!depth)\r\ndepth = var->bits_per_pixel;\r\nif (depth < 0 || depth > 32)\r\nreturn -EINVAL;\r\nelse if (!depth)\r\ndepth = 24;\r\nelse if (depth == 15 && viafb_dual_fb && ppar->iga_path == IGA1)\r\ndepth = 15;\r\nelse if (depth == 30)\r\ndepth = 30;\r\nelse if (depth <= 8)\r\ndepth = 8;\r\nelse if (depth <= 16)\r\ndepth = 16;\r\nelse\r\ndepth = 24;\r\nviafb_fill_var_color_info(var, depth);\r\nif (var->xres_virtual < var->xres)\r\nvar->xres_virtual = var->xres;\r\nline = ALIGN(var->xres_virtual * var->bits_per_pixel / 8,\r\nVIA_PITCH_SIZE);\r\nif (line > VIA_PITCH_MAX || line * var->yres_virtual > ppar->memsize)\r\nreturn -EINVAL;\r\nrefresh = viafb_get_refresh(var->xres, var->yres,\r\nget_var_refresh(var));\r\nviafb_fill_var_timing_info(var,\r\nviafb_get_best_mode(var->xres, var->yres, refresh));\r\nif (var->accel_flags & FB_ACCELF_TEXT &&\r\n!ppar->shared->vdev->engine_mmio)\r\nvar->accel_flags = 0;\r\nreturn 0;\r\n}\r\nstatic int viafb_set_par(struct fb_info *info)\r\n{\r\nstruct viafb_par *viapar = info->par;\r\nint refresh;\r\nDEBUG_MSG(KERN_INFO "viafb_set_par!\n");\r\nviafb_update_fix(info);\r\nviapar->depth = fb_get_color_depth(&info->var, &info->fix);\r\nviafb_update_device_setting(viafbinfo->var.xres, viafbinfo->var.yres,\r\nviafbinfo->var.bits_per_pixel, 0);\r\nif (viafb_dual_fb) {\r\nviafb_update_device_setting(viafbinfo1->var.xres,\r\nviafbinfo1->var.yres, viafbinfo1->var.bits_per_pixel,\r\n1);\r\n} else if (viafb_SAMM_ON == 1) {\r\nDEBUG_MSG(KERN_INFO\r\n"viafb_second_xres = %d, viafb_second_yres = %d, bpp = %d\n",\r\nviafb_second_xres, viafb_second_yres, viafb_bpp1);\r\nviafb_update_device_setting(viafb_second_xres,\r\nviafb_second_yres, viafb_bpp1, 1);\r\n}\r\nrefresh = get_var_refresh(&info->var);\r\nif (viafb_dual_fb && viapar->iga_path == IGA2) {\r\nviafb_bpp1 = info->var.bits_per_pixel;\r\nviafb_refresh1 = refresh;\r\n} else {\r\nviafb_bpp = info->var.bits_per_pixel;\r\nviafb_refresh = refresh;\r\n}\r\nif (info->var.accel_flags & FB_ACCELF_TEXT)\r\ninfo->flags &= ~FBINFO_HWACCEL_DISABLED;\r\nelse\r\ninfo->flags |= FBINFO_HWACCEL_DISABLED;\r\nviafb_setmode();\r\nviafb_pan_display(&info->var, info);\r\nreturn 0;\r\n}\r\nstatic int viafb_setcolreg(unsigned regno, unsigned red, unsigned green,\r\nunsigned blue, unsigned transp, struct fb_info *info)\r\n{\r\nstruct viafb_par *viapar = info->par;\r\nu32 r, g, b;\r\nif (info->fix.visual == FB_VISUAL_PSEUDOCOLOR) {\r\nif (regno > 255)\r\nreturn -EINVAL;\r\nif (!viafb_dual_fb || viapar->iga_path == IGA1)\r\nviafb_set_primary_color_register(regno, red >> 8,\r\ngreen >> 8, blue >> 8);\r\nif (!viafb_dual_fb || viapar->iga_path == IGA2)\r\nviafb_set_secondary_color_register(regno, red >> 8,\r\ngreen >> 8, blue >> 8);\r\n} else {\r\nif (regno > 15)\r\nreturn -EINVAL;\r\nr = (red >> (16 - info->var.red.length))\r\n<< info->var.red.offset;\r\nb = (blue >> (16 - info->var.blue.length))\r\n<< info->var.blue.offset;\r\ng = (green >> (16 - info->var.green.length))\r\n<< info->var.green.offset;\r\n((u32 *) info->pseudo_palette)[regno] = r | g | b;\r\n}\r\nreturn 0;\r\n}\r\nstatic int viafb_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct viafb_par *viapar = info->par;\r\nu32 vram_addr = viapar->vram_addr\r\n+ var->yoffset * info->fix.line_length\r\n+ var->xoffset * info->var.bits_per_pixel / 8;\r\nDEBUG_MSG(KERN_DEBUG "viafb_pan_display, address = %d\n", vram_addr);\r\nif (!viafb_dual_fb) {\r\nvia_set_primary_address(vram_addr);\r\nvia_set_secondary_address(vram_addr);\r\n} else if (viapar->iga_path == IGA1)\r\nvia_set_primary_address(vram_addr);\r\nelse\r\nvia_set_secondary_address(vram_addr);\r\nreturn 0;\r\n}\r\nstatic int viafb_blank(int blank_mode, struct fb_info *info)\r\n{\r\nDEBUG_MSG(KERN_INFO "viafb_blank!\n");\r\nswitch (blank_mode) {\r\ncase FB_BLANK_UNBLANK:\r\nvia_set_state(VIA_CRT, VIA_STATE_ON);\r\nbreak;\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\nvia_set_state(VIA_CRT, VIA_STATE_STANDBY);\r\nbreak;\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\nvia_set_state(VIA_CRT, VIA_STATE_SUSPEND);\r\nbreak;\r\ncase FB_BLANK_POWERDOWN:\r\nvia_set_state(VIA_CRT, VIA_STATE_OFF);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int viafb_ioctl(struct fb_info *info, u_int cmd, u_long arg)\r\n{\r\nunion {\r\nstruct viafb_ioctl_mode viamode;\r\nstruct viafb_ioctl_samm viasamm;\r\nstruct viafb_driver_version driver_version;\r\nstruct fb_var_screeninfo sec_var;\r\nstruct _panel_size_pos_info panel_pos_size_para;\r\nstruct viafb_ioctl_setting viafb_setting;\r\nstruct device_t active_dev;\r\n} u;\r\nu32 state_info = 0;\r\nu32 *viafb_gamma_table;\r\nchar driver_name[] = "viafb";\r\nu32 __user *argp = (u32 __user *) arg;\r\nu32 gpu32;\r\nDEBUG_MSG(KERN_INFO "viafb_ioctl: 0x%X !!\n", cmd);\r\nprintk(KERN_WARNING "viafb_ioctl: Please avoid this interface as it is unstable and might change or vanish at any time!\n");\r\nmemset(&u, 0, sizeof(u));\r\nswitch (cmd) {\r\ncase VIAFB_GET_CHIP_INFO:\r\nif (copy_to_user(argp, viaparinfo->chip_info,\r\nsizeof(struct chip_information)))\r\nreturn -EFAULT;\r\nbreak;\r\ncase VIAFB_GET_INFO_SIZE:\r\nreturn put_user((u32)sizeof(struct viafb_ioctl_info), argp);\r\ncase VIAFB_GET_INFO:\r\nreturn viafb_ioctl_get_viafb_info(arg);\r\ncase VIAFB_HOTPLUG:\r\nreturn put_user(viafb_ioctl_hotplug(info->var.xres,\r\ninfo->var.yres,\r\ninfo->var.bits_per_pixel), argp);\r\ncase VIAFB_SET_HOTPLUG_FLAG:\r\nif (copy_from_user(&gpu32, argp, sizeof(gpu32)))\r\nreturn -EFAULT;\r\nviafb_hotplug = (gpu32) ? 1 : 0;\r\nbreak;\r\ncase VIAFB_GET_RESOLUTION:\r\nu.viamode.xres = (u32) viafb_hotplug_Xres;\r\nu.viamode.yres = (u32) viafb_hotplug_Yres;\r\nu.viamode.refresh = (u32) viafb_hotplug_refresh;\r\nu.viamode.bpp = (u32) viafb_hotplug_bpp;\r\nif (viafb_SAMM_ON == 1) {\r\nu.viamode.xres_sec = viafb_second_xres;\r\nu.viamode.yres_sec = viafb_second_yres;\r\nu.viamode.virtual_xres_sec = viafb_dual_fb ? viafbinfo1->var.xres_virtual : viafbinfo->var.xres_virtual;\r\nu.viamode.virtual_yres_sec = viafb_dual_fb ? viafbinfo1->var.yres_virtual : viafbinfo->var.yres_virtual;\r\nu.viamode.refresh_sec = viafb_refresh1;\r\nu.viamode.bpp_sec = viafb_bpp1;\r\n} else {\r\nu.viamode.xres_sec = 0;\r\nu.viamode.yres_sec = 0;\r\nu.viamode.virtual_xres_sec = 0;\r\nu.viamode.virtual_yres_sec = 0;\r\nu.viamode.refresh_sec = 0;\r\nu.viamode.bpp_sec = 0;\r\n}\r\nif (copy_to_user(argp, &u.viamode, sizeof(u.viamode)))\r\nreturn -EFAULT;\r\nbreak;\r\ncase VIAFB_GET_SAMM_INFO:\r\nu.viasamm.samm_status = viafb_SAMM_ON;\r\nif (viafb_SAMM_ON == 1) {\r\nif (viafb_dual_fb) {\r\nu.viasamm.size_prim = viaparinfo->fbmem_free;\r\nu.viasamm.size_sec = viaparinfo1->fbmem_free;\r\n} else {\r\nif (viafb_second_size) {\r\nu.viasamm.size_prim =\r\nviaparinfo->fbmem_free -\r\nviafb_second_size * 1024 * 1024;\r\nu.viasamm.size_sec =\r\nviafb_second_size * 1024 * 1024;\r\n} else {\r\nu.viasamm.size_prim =\r\nviaparinfo->fbmem_free >> 1;\r\nu.viasamm.size_sec =\r\n(viaparinfo->fbmem_free >> 1);\r\n}\r\n}\r\nu.viasamm.mem_base = viaparinfo->fbmem;\r\nu.viasamm.offset_sec = viafb_second_offset;\r\n} else {\r\nu.viasamm.size_prim =\r\nviaparinfo->memsize - viaparinfo->fbmem_used;\r\nu.viasamm.size_sec = 0;\r\nu.viasamm.mem_base = viaparinfo->fbmem;\r\nu.viasamm.offset_sec = 0;\r\n}\r\nif (copy_to_user(argp, &u.viasamm, sizeof(u.viasamm)))\r\nreturn -EFAULT;\r\nbreak;\r\ncase VIAFB_TURN_ON_OUTPUT_DEVICE:\r\nif (copy_from_user(&gpu32, argp, sizeof(gpu32)))\r\nreturn -EFAULT;\r\nif (gpu32 & CRT_Device)\r\nvia_set_state(VIA_CRT, VIA_STATE_ON);\r\nif (gpu32 & DVI_Device)\r\nviafb_dvi_enable();\r\nif (gpu32 & LCD_Device)\r\nviafb_lcd_enable();\r\nbreak;\r\ncase VIAFB_TURN_OFF_OUTPUT_DEVICE:\r\nif (copy_from_user(&gpu32, argp, sizeof(gpu32)))\r\nreturn -EFAULT;\r\nif (gpu32 & CRT_Device)\r\nvia_set_state(VIA_CRT, VIA_STATE_OFF);\r\nif (gpu32 & DVI_Device)\r\nviafb_dvi_disable();\r\nif (gpu32 & LCD_Device)\r\nviafb_lcd_disable();\r\nbreak;\r\ncase VIAFB_GET_DEVICE:\r\nu.active_dev.crt = viafb_CRT_ON;\r\nu.active_dev.dvi = viafb_DVI_ON;\r\nu.active_dev.lcd = viafb_LCD_ON;\r\nu.active_dev.samm = viafb_SAMM_ON;\r\nu.active_dev.primary_dev = viafb_primary_dev;\r\nu.active_dev.lcd_dsp_cent = viafb_lcd_dsp_method;\r\nu.active_dev.lcd_panel_id = viafb_lcd_panel_id;\r\nu.active_dev.lcd_mode = viafb_lcd_mode;\r\nu.active_dev.xres = viafb_hotplug_Xres;\r\nu.active_dev.yres = viafb_hotplug_Yres;\r\nu.active_dev.xres1 = viafb_second_xres;\r\nu.active_dev.yres1 = viafb_second_yres;\r\nu.active_dev.bpp = viafb_bpp;\r\nu.active_dev.bpp1 = viafb_bpp1;\r\nu.active_dev.refresh = viafb_refresh;\r\nu.active_dev.refresh1 = viafb_refresh1;\r\nu.active_dev.epia_dvi = viafb_platform_epia_dvi;\r\nu.active_dev.lcd_dual_edge = viafb_device_lcd_dualedge;\r\nu.active_dev.bus_width = viafb_bus_width;\r\nif (copy_to_user(argp, &u.active_dev, sizeof(u.active_dev)))\r\nreturn -EFAULT;\r\nbreak;\r\ncase VIAFB_GET_DRIVER_VERSION:\r\nu.driver_version.iMajorNum = VERSION_MAJOR;\r\nu.driver_version.iKernelNum = VERSION_KERNEL;\r\nu.driver_version.iOSNum = VERSION_OS;\r\nu.driver_version.iMinorNum = VERSION_MINOR;\r\nif (copy_to_user(argp, &u.driver_version,\r\nsizeof(u.driver_version)))\r\nreturn -EFAULT;\r\nbreak;\r\ncase VIAFB_GET_DEVICE_INFO:\r\nretrieve_device_setting(&u.viafb_setting);\r\nif (copy_to_user(argp, &u.viafb_setting,\r\nsizeof(u.viafb_setting)))\r\nreturn -EFAULT;\r\nbreak;\r\ncase VIAFB_GET_DEVICE_SUPPORT:\r\nviafb_get_device_support_state(&state_info);\r\nif (put_user(state_info, argp))\r\nreturn -EFAULT;\r\nbreak;\r\ncase VIAFB_GET_DEVICE_CONNECT:\r\nviafb_get_device_connect_state(&state_info);\r\nif (put_user(state_info, argp))\r\nreturn -EFAULT;\r\nbreak;\r\ncase VIAFB_GET_PANEL_SUPPORT_EXPAND:\r\nstate_info =\r\nviafb_lcd_get_support_expand_state(info->var.xres,\r\ninfo->var.yres);\r\nif (put_user(state_info, argp))\r\nreturn -EFAULT;\r\nbreak;\r\ncase VIAFB_GET_DRIVER_NAME:\r\nif (copy_to_user(argp, driver_name, sizeof(driver_name)))\r\nreturn -EFAULT;\r\nbreak;\r\ncase VIAFB_SET_GAMMA_LUT:\r\nviafb_gamma_table = memdup_user(argp, 256 * sizeof(u32));\r\nif (IS_ERR(viafb_gamma_table))\r\nreturn PTR_ERR(viafb_gamma_table);\r\nviafb_set_gamma_table(viafb_bpp, viafb_gamma_table);\r\nkfree(viafb_gamma_table);\r\nbreak;\r\ncase VIAFB_GET_GAMMA_LUT:\r\nviafb_gamma_table = kmalloc(256 * sizeof(u32), GFP_KERNEL);\r\nif (!viafb_gamma_table)\r\nreturn -ENOMEM;\r\nviafb_get_gamma_table(viafb_gamma_table);\r\nif (copy_to_user(argp, viafb_gamma_table,\r\n256 * sizeof(u32))) {\r\nkfree(viafb_gamma_table);\r\nreturn -EFAULT;\r\n}\r\nkfree(viafb_gamma_table);\r\nbreak;\r\ncase VIAFB_GET_GAMMA_SUPPORT_STATE:\r\nviafb_get_gamma_support_state(viafb_bpp, &state_info);\r\nif (put_user(state_info, argp))\r\nreturn -EFAULT;\r\nbreak;\r\ncase VIAFB_SYNC_SURFACE:\r\nDEBUG_MSG(KERN_INFO "lobo VIAFB_SYNC_SURFACE\n");\r\nbreak;\r\ncase VIAFB_GET_DRIVER_CAPS:\r\nbreak;\r\ncase VIAFB_GET_PANEL_MAX_SIZE:\r\nif (copy_from_user(&u.panel_pos_size_para, argp,\r\nsizeof(u.panel_pos_size_para)))\r\nreturn -EFAULT;\r\nu.panel_pos_size_para.x = u.panel_pos_size_para.y = 0;\r\nif (copy_to_user(argp, &u.panel_pos_size_para,\r\nsizeof(u.panel_pos_size_para)))\r\nreturn -EFAULT;\r\nbreak;\r\ncase VIAFB_GET_PANEL_MAX_POSITION:\r\nif (copy_from_user(&u.panel_pos_size_para, argp,\r\nsizeof(u.panel_pos_size_para)))\r\nreturn -EFAULT;\r\nu.panel_pos_size_para.x = u.panel_pos_size_para.y = 0;\r\nif (copy_to_user(argp, &u.panel_pos_size_para,\r\nsizeof(u.panel_pos_size_para)))\r\nreturn -EFAULT;\r\nbreak;\r\ncase VIAFB_GET_PANEL_POSITION:\r\nif (copy_from_user(&u.panel_pos_size_para, argp,\r\nsizeof(u.panel_pos_size_para)))\r\nreturn -EFAULT;\r\nu.panel_pos_size_para.x = u.panel_pos_size_para.y = 0;\r\nif (copy_to_user(argp, &u.panel_pos_size_para,\r\nsizeof(u.panel_pos_size_para)))\r\nreturn -EFAULT;\r\nbreak;\r\ncase VIAFB_GET_PANEL_SIZE:\r\nif (copy_from_user(&u.panel_pos_size_para, argp,\r\nsizeof(u.panel_pos_size_para)))\r\nreturn -EFAULT;\r\nu.panel_pos_size_para.x = u.panel_pos_size_para.y = 0;\r\nif (copy_to_user(argp, &u.panel_pos_size_para,\r\nsizeof(u.panel_pos_size_para)))\r\nreturn -EFAULT;\r\nbreak;\r\ncase VIAFB_SET_PANEL_POSITION:\r\nif (copy_from_user(&u.panel_pos_size_para, argp,\r\nsizeof(u.panel_pos_size_para)))\r\nreturn -EFAULT;\r\nbreak;\r\ncase VIAFB_SET_PANEL_SIZE:\r\nif (copy_from_user(&u.panel_pos_size_para, argp,\r\nsizeof(u.panel_pos_size_para)))\r\nreturn -EFAULT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void viafb_fillrect(struct fb_info *info,\r\nconst struct fb_fillrect *rect)\r\n{\r\nstruct viafb_par *viapar = info->par;\r\nstruct viafb_shared *shared = viapar->shared;\r\nu32 fg_color;\r\nu8 rop;\r\nif (info->flags & FBINFO_HWACCEL_DISABLED || !shared->hw_bitblt) {\r\ncfb_fillrect(info, rect);\r\nreturn;\r\n}\r\nif (!rect->width || !rect->height)\r\nreturn;\r\nif (info->fix.visual == FB_VISUAL_TRUECOLOR)\r\nfg_color = ((u32 *)info->pseudo_palette)[rect->color];\r\nelse\r\nfg_color = rect->color;\r\nif (rect->rop == ROP_XOR)\r\nrop = 0x5A;\r\nelse\r\nrop = 0xF0;\r\nDEBUG_MSG(KERN_DEBUG "viafb 2D engine: fillrect\n");\r\nif (shared->hw_bitblt(shared->vdev->engine_mmio, VIA_BITBLT_FILL,\r\nrect->width, rect->height, info->var.bits_per_pixel,\r\nviapar->vram_addr, info->fix.line_length, rect->dx, rect->dy,\r\nNULL, 0, 0, 0, 0, fg_color, 0, rop))\r\ncfb_fillrect(info, rect);\r\n}\r\nstatic void viafb_copyarea(struct fb_info *info,\r\nconst struct fb_copyarea *area)\r\n{\r\nstruct viafb_par *viapar = info->par;\r\nstruct viafb_shared *shared = viapar->shared;\r\nif (info->flags & FBINFO_HWACCEL_DISABLED || !shared->hw_bitblt) {\r\ncfb_copyarea(info, area);\r\nreturn;\r\n}\r\nif (!area->width || !area->height)\r\nreturn;\r\nDEBUG_MSG(KERN_DEBUG "viafb 2D engine: copyarea\n");\r\nif (shared->hw_bitblt(shared->vdev->engine_mmio, VIA_BITBLT_COLOR,\r\narea->width, area->height, info->var.bits_per_pixel,\r\nviapar->vram_addr, info->fix.line_length, area->dx, area->dy,\r\nNULL, viapar->vram_addr, info->fix.line_length,\r\narea->sx, area->sy, 0, 0, 0))\r\ncfb_copyarea(info, area);\r\n}\r\nstatic void viafb_imageblit(struct fb_info *info,\r\nconst struct fb_image *image)\r\n{\r\nstruct viafb_par *viapar = info->par;\r\nstruct viafb_shared *shared = viapar->shared;\r\nu32 fg_color = 0, bg_color = 0;\r\nu8 op;\r\nif (info->flags & FBINFO_HWACCEL_DISABLED || !shared->hw_bitblt ||\r\n(image->depth != 1 && image->depth != viapar->depth)) {\r\ncfb_imageblit(info, image);\r\nreturn;\r\n}\r\nif (image->depth == 1) {\r\nop = VIA_BITBLT_MONO;\r\nif (info->fix.visual == FB_VISUAL_TRUECOLOR) {\r\nfg_color =\r\n((u32 *)info->pseudo_palette)[image->fg_color];\r\nbg_color =\r\n((u32 *)info->pseudo_palette)[image->bg_color];\r\n} else {\r\nfg_color = image->fg_color;\r\nbg_color = image->bg_color;\r\n}\r\n} else\r\nop = VIA_BITBLT_COLOR;\r\nDEBUG_MSG(KERN_DEBUG "viafb 2D engine: imageblit\n");\r\nif (shared->hw_bitblt(shared->vdev->engine_mmio, op,\r\nimage->width, image->height, info->var.bits_per_pixel,\r\nviapar->vram_addr, info->fix.line_length, image->dx, image->dy,\r\n(u32 *)image->data, 0, 0, 0, 0, fg_color, bg_color, 0))\r\ncfb_imageblit(info, image);\r\n}\r\nstatic int viafb_cursor(struct fb_info *info, struct fb_cursor *cursor)\r\n{\r\nstruct viafb_par *viapar = info->par;\r\nvoid __iomem *engine = viapar->shared->vdev->engine_mmio;\r\nu32 temp, xx, yy, bg_color = 0, fg_color = 0,\r\nchip_name = viapar->shared->chip_info.gfx_chip_name;\r\nint i, j = 0, cur_size = 64;\r\nif (info->flags & FBINFO_HWACCEL_DISABLED || info != viafbinfo)\r\nreturn -ENODEV;\r\nif ((chip_name == UNICHROME_CLE266 && viapar->iga_path == IGA2) ||\r\nviafb_LCD_ON)\r\nreturn -ENODEV;\r\nviafb_show_hw_cursor(info, HW_Cursor_OFF);\r\nif (cursor->set & FB_CUR_SETHOT) {\r\ntemp = (cursor->hot.x << 16) + cursor->hot.y;\r\nwritel(temp, engine + VIA_REG_CURSOR_ORG);\r\n}\r\nif (cursor->set & FB_CUR_SETPOS) {\r\nyy = cursor->image.dy - info->var.yoffset;\r\nxx = cursor->image.dx - info->var.xoffset;\r\ntemp = yy & 0xFFFF;\r\ntemp |= (xx << 16);\r\nwritel(temp, engine + VIA_REG_CURSOR_POS);\r\n}\r\nif (cursor->image.width <= 32 && cursor->image.height <= 32)\r\ncur_size = 32;\r\nelse if (cursor->image.width <= 64 && cursor->image.height <= 64)\r\ncur_size = 64;\r\nelse {\r\nprintk(KERN_WARNING "viafb_cursor: The cursor is too large "\r\n"%dx%d", cursor->image.width, cursor->image.height);\r\nreturn -ENXIO;\r\n}\r\nif (cursor->set & FB_CUR_SETSIZE) {\r\ntemp = readl(engine + VIA_REG_CURSOR_MODE);\r\nif (cur_size == 32)\r\ntemp |= 0x2;\r\nelse\r\ntemp &= ~0x2;\r\nwritel(temp, engine + VIA_REG_CURSOR_MODE);\r\n}\r\nif (cursor->set & FB_CUR_SETCMAP) {\r\nfg_color = cursor->image.fg_color;\r\nbg_color = cursor->image.bg_color;\r\nif (chip_name == UNICHROME_CX700 ||\r\nchip_name == UNICHROME_VX800 ||\r\nchip_name == UNICHROME_VX855 ||\r\nchip_name == UNICHROME_VX900) {\r\nfg_color =\r\n((info->cmap.red[fg_color] & 0xFFC0) << 14) |\r\n((info->cmap.green[fg_color] & 0xFFC0) << 4) |\r\n((info->cmap.blue[fg_color] & 0xFFC0) >> 6);\r\nbg_color =\r\n((info->cmap.red[bg_color] & 0xFFC0) << 14) |\r\n((info->cmap.green[bg_color] & 0xFFC0) << 4) |\r\n((info->cmap.blue[bg_color] & 0xFFC0) >> 6);\r\n} else {\r\nfg_color =\r\n((info->cmap.red[fg_color] & 0xFF00) << 8) |\r\n(info->cmap.green[fg_color] & 0xFF00) |\r\n((info->cmap.blue[fg_color] & 0xFF00) >> 8);\r\nbg_color =\r\n((info->cmap.red[bg_color] & 0xFF00) << 8) |\r\n(info->cmap.green[bg_color] & 0xFF00) |\r\n((info->cmap.blue[bg_color] & 0xFF00) >> 8);\r\n}\r\nwritel(bg_color, engine + VIA_REG_CURSOR_BG);\r\nwritel(fg_color, engine + VIA_REG_CURSOR_FG);\r\n}\r\nif (cursor->set & FB_CUR_SETSHAPE) {\r\nstruct {\r\nu8 data[CURSOR_SIZE];\r\nu32 bak[CURSOR_SIZE / 4];\r\n} *cr_data = kzalloc(sizeof(*cr_data), GFP_ATOMIC);\r\nint size = ((cursor->image.width + 7) >> 3) *\r\ncursor->image.height;\r\nif (!cr_data)\r\nreturn -ENOMEM;\r\nif (cur_size == 32) {\r\nfor (i = 0; i < (CURSOR_SIZE / 4); i++) {\r\ncr_data->bak[i] = 0x0;\r\ncr_data->bak[i + 1] = 0xFFFFFFFF;\r\ni += 1;\r\n}\r\n} else {\r\nfor (i = 0; i < (CURSOR_SIZE / 4); i++) {\r\ncr_data->bak[i] = 0x0;\r\ncr_data->bak[i + 1] = 0x0;\r\ncr_data->bak[i + 2] = 0xFFFFFFFF;\r\ncr_data->bak[i + 3] = 0xFFFFFFFF;\r\ni += 3;\r\n}\r\n}\r\nswitch (cursor->rop) {\r\ncase ROP_XOR:\r\nfor (i = 0; i < size; i++)\r\ncr_data->data[i] = cursor->mask[i];\r\nbreak;\r\ncase ROP_COPY:\r\nfor (i = 0; i < size; i++)\r\ncr_data->data[i] = cursor->mask[i];\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (cur_size == 32) {\r\nfor (i = 0; i < size; i++) {\r\ncr_data->bak[j] = (u32) cr_data->data[i];\r\ncr_data->bak[j + 1] = ~cr_data->bak[j];\r\nj += 2;\r\n}\r\n} else {\r\nfor (i = 0; i < size; i++) {\r\ncr_data->bak[j] = (u32) cr_data->data[i];\r\ncr_data->bak[j + 1] = 0x0;\r\ncr_data->bak[j + 2] = ~cr_data->bak[j];\r\ncr_data->bak[j + 3] = ~cr_data->bak[j + 1];\r\nj += 4;\r\n}\r\n}\r\nmemcpy_toio(viafbinfo->screen_base + viapar->shared->\r\ncursor_vram_addr, cr_data->bak, CURSOR_SIZE);\r\nkfree(cr_data);\r\n}\r\nif (cursor->enable)\r\nviafb_show_hw_cursor(info, HW_Cursor_ON);\r\nreturn 0;\r\n}\r\nstatic int viafb_sync(struct fb_info *info)\r\n{\r\nif (!(info->flags & FBINFO_HWACCEL_DISABLED))\r\nviafb_wait_engine_idle(info);\r\nreturn 0;\r\n}\r\nstatic int get_primary_device(void)\r\n{\r\nint primary_device = 0;\r\nif (viafb_SAMM_ON) {\r\nif (viafb_CRT_ON) {\r\nif (viaparinfo->shared->iga1_devices & VIA_CRT) {\r\nDEBUG_MSG(KERN_INFO "CRT IGA Path:%d\n", IGA1);\r\nprimary_device = CRT_Device;\r\n}\r\n}\r\nif (viafb_DVI_ON) {\r\nif (viaparinfo->tmds_setting_info->iga_path == IGA1) {\r\nDEBUG_MSG(KERN_INFO "DVI IGA Path:%d\n",\r\nviaparinfo->\r\ntmds_setting_info->iga_path);\r\nprimary_device = DVI_Device;\r\n}\r\n}\r\nif (viafb_LCD_ON) {\r\nif (viaparinfo->lvds_setting_info->iga_path == IGA1) {\r\nDEBUG_MSG(KERN_INFO "LCD IGA Path:%d\n",\r\nviaparinfo->\r\nlvds_setting_info->iga_path);\r\nprimary_device = LCD_Device;\r\n}\r\n}\r\nif (viafb_LCD2_ON) {\r\nif (viaparinfo->lvds_setting_info2->iga_path == IGA1) {\r\nDEBUG_MSG(KERN_INFO "LCD2 IGA Path:%d\n",\r\nviaparinfo->\r\nlvds_setting_info2->iga_path);\r\nprimary_device = LCD2_Device;\r\n}\r\n}\r\n}\r\nreturn primary_device;\r\n}\r\nstatic void retrieve_device_setting(struct viafb_ioctl_setting\r\n*setting_info)\r\n{\r\nif (viafb_CRT_ON == 1)\r\nsetting_info->device_status = CRT_Device;\r\nif (viafb_DVI_ON == 1)\r\nsetting_info->device_status |= DVI_Device;\r\nif (viafb_LCD_ON == 1)\r\nsetting_info->device_status |= LCD_Device;\r\nif (viafb_LCD2_ON == 1)\r\nsetting_info->device_status |= LCD2_Device;\r\nsetting_info->samm_status = viafb_SAMM_ON;\r\nsetting_info->primary_device = get_primary_device();\r\nsetting_info->first_dev_bpp = viafb_bpp;\r\nsetting_info->second_dev_bpp = viafb_bpp1;\r\nsetting_info->first_dev_refresh = viafb_refresh;\r\nsetting_info->second_dev_refresh = viafb_refresh1;\r\nsetting_info->first_dev_hor_res = viafb_hotplug_Xres;\r\nsetting_info->first_dev_ver_res = viafb_hotplug_Yres;\r\nsetting_info->second_dev_hor_res = viafb_second_xres;\r\nsetting_info->second_dev_ver_res = viafb_second_yres;\r\nsetting_info->lcd_attributes.display_center = viafb_lcd_dsp_method;\r\nsetting_info->lcd_attributes.panel_id = viafb_lcd_panel_id;\r\nsetting_info->lcd_attributes.lcd_mode = viafb_lcd_mode;\r\n}\r\nstatic int __init parse_active_dev(void)\r\n{\r\nviafb_CRT_ON = STATE_OFF;\r\nviafb_DVI_ON = STATE_OFF;\r\nviafb_LCD_ON = STATE_OFF;\r\nviafb_LCD2_ON = STATE_OFF;\r\nif (!viafb_active_dev) {\r\nif (machine_is_olpc()) {\r\nviafb_LCD_ON = STATE_ON;\r\nviafb_SAMM_ON = STATE_OFF;\r\n} else {\r\nviafb_CRT_ON = STATE_ON;\r\nviafb_SAMM_ON = STATE_OFF;\r\n}\r\n} else if (!strcmp(viafb_active_dev, "CRT+DVI")) {\r\nviafb_CRT_ON = STATE_ON;\r\nviafb_DVI_ON = STATE_ON;\r\nviafb_primary_dev = CRT_Device;\r\n} else if (!strcmp(viafb_active_dev, "DVI+CRT")) {\r\nviafb_CRT_ON = STATE_ON;\r\nviafb_DVI_ON = STATE_ON;\r\nviafb_primary_dev = DVI_Device;\r\n} else if (!strcmp(viafb_active_dev, "CRT+LCD")) {\r\nviafb_CRT_ON = STATE_ON;\r\nviafb_LCD_ON = STATE_ON;\r\nviafb_primary_dev = CRT_Device;\r\n} else if (!strcmp(viafb_active_dev, "LCD+CRT")) {\r\nviafb_CRT_ON = STATE_ON;\r\nviafb_LCD_ON = STATE_ON;\r\nviafb_primary_dev = LCD_Device;\r\n} else if (!strcmp(viafb_active_dev, "DVI+LCD")) {\r\nviafb_DVI_ON = STATE_ON;\r\nviafb_LCD_ON = STATE_ON;\r\nviafb_primary_dev = DVI_Device;\r\n} else if (!strcmp(viafb_active_dev, "LCD+DVI")) {\r\nviafb_DVI_ON = STATE_ON;\r\nviafb_LCD_ON = STATE_ON;\r\nviafb_primary_dev = LCD_Device;\r\n} else if (!strcmp(viafb_active_dev, "LCD+LCD2")) {\r\nviafb_LCD_ON = STATE_ON;\r\nviafb_LCD2_ON = STATE_ON;\r\nviafb_primary_dev = LCD_Device;\r\n} else if (!strcmp(viafb_active_dev, "LCD2+LCD")) {\r\nviafb_LCD_ON = STATE_ON;\r\nviafb_LCD2_ON = STATE_ON;\r\nviafb_primary_dev = LCD2_Device;\r\n} else if (!strcmp(viafb_active_dev, "CRT")) {\r\nviafb_CRT_ON = STATE_ON;\r\nviafb_SAMM_ON = STATE_OFF;\r\n} else if (!strcmp(viafb_active_dev, "DVI")) {\r\nviafb_DVI_ON = STATE_ON;\r\nviafb_SAMM_ON = STATE_OFF;\r\n} else if (!strcmp(viafb_active_dev, "LCD")) {\r\nviafb_LCD_ON = STATE_ON;\r\nviafb_SAMM_ON = STATE_OFF;\r\n} else\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int parse_port(char *opt_str, int *output_interface)\r\n{\r\nif (!strncmp(opt_str, "DVP0", 4))\r\n*output_interface = INTERFACE_DVP0;\r\nelse if (!strncmp(opt_str, "DVP1", 4))\r\n*output_interface = INTERFACE_DVP1;\r\nelse if (!strncmp(opt_str, "DFP_HIGHLOW", 11))\r\n*output_interface = INTERFACE_DFP;\r\nelse if (!strncmp(opt_str, "DFP_HIGH", 8))\r\n*output_interface = INTERFACE_DFP_HIGH;\r\nelse if (!strncmp(opt_str, "DFP_LOW", 7))\r\n*output_interface = INTERFACE_DFP_LOW;\r\nelse\r\n*output_interface = INTERFACE_NONE;\r\nreturn 0;\r\n}\r\nstatic void parse_lcd_port(void)\r\n{\r\nparse_port(viafb_lcd_port, &viaparinfo->chip_info->lvds_chip_info.\r\noutput_interface);\r\nviaparinfo->chip_info->lvds_chip_info2.output_interface =\r\nINTERFACE_NONE;\r\nDEBUG_MSG(KERN_INFO "parse_lcd_port: viafb_lcd_port:%s,interface:%d\n",\r\nviafb_lcd_port, viaparinfo->chip_info->lvds_chip_info.\r\noutput_interface);\r\n}\r\nstatic void parse_dvi_port(void)\r\n{\r\nparse_port(viafb_dvi_port, &viaparinfo->chip_info->tmds_chip_info.\r\noutput_interface);\r\nDEBUG_MSG(KERN_INFO "parse_dvi_port: viafb_dvi_port:%s,interface:%d\n",\r\nviafb_dvi_port, viaparinfo->chip_info->tmds_chip_info.\r\noutput_interface);\r\n}\r\nstatic int viafb_dvp0_proc_show(struct seq_file *m, void *v)\r\n{\r\nu8 dvp0_data_dri = 0, dvp0_clk_dri = 0, dvp0 = 0;\r\ndvp0_data_dri =\r\n(viafb_read_reg(VIASR, SR2A) & BIT5) >> 4 |\r\n(viafb_read_reg(VIASR, SR1B) & BIT1) >> 1;\r\ndvp0_clk_dri =\r\n(viafb_read_reg(VIASR, SR2A) & BIT4) >> 3 |\r\n(viafb_read_reg(VIASR, SR1E) & BIT2) >> 2;\r\ndvp0 = viafb_read_reg(VIACR, CR96) & 0x0f;\r\nseq_printf(m, "%x %x %x\n", dvp0, dvp0_data_dri, dvp0_clk_dri);\r\nreturn 0;\r\n}\r\nstatic int viafb_dvp0_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, viafb_dvp0_proc_show, NULL);\r\n}\r\nstatic ssize_t viafb_dvp0_proc_write(struct file *file,\r\nconst char __user *buffer, size_t count, loff_t *pos)\r\n{\r\nchar buf[20], *value, *pbuf;\r\nu8 reg_val = 0;\r\nunsigned long length, i;\r\nif (count < 1)\r\nreturn -EINVAL;\r\nlength = count > 20 ? 20 : count;\r\nif (copy_from_user(&buf[0], buffer, length))\r\nreturn -EFAULT;\r\nbuf[length - 1] = '\0';\r\npbuf = &buf[0];\r\nfor (i = 0; i < 3; i++) {\r\nvalue = strsep(&pbuf, " ");\r\nif (value != NULL) {\r\nif (kstrtou8(value, 0, &reg_val) < 0)\r\nreturn -EINVAL;\r\nDEBUG_MSG(KERN_INFO "DVP0:reg_val[%l]=:%x\n", i,\r\nreg_val);\r\nswitch (i) {\r\ncase 0:\r\nviafb_write_reg_mask(CR96, VIACR,\r\nreg_val, 0x0f);\r\nbreak;\r\ncase 1:\r\nviafb_write_reg_mask(SR2A, VIASR,\r\nreg_val << 4, BIT5);\r\nviafb_write_reg_mask(SR1B, VIASR,\r\nreg_val << 1, BIT1);\r\nbreak;\r\ncase 2:\r\nviafb_write_reg_mask(SR2A, VIASR,\r\nreg_val << 3, BIT4);\r\nviafb_write_reg_mask(SR1E, VIASR,\r\nreg_val << 2, BIT2);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} else {\r\nbreak;\r\n}\r\n}\r\nreturn count;\r\n}\r\nstatic int viafb_dvp1_proc_show(struct seq_file *m, void *v)\r\n{\r\nu8 dvp1 = 0, dvp1_data_dri = 0, dvp1_clk_dri = 0;\r\ndvp1 = viafb_read_reg(VIACR, CR9B) & 0x0f;\r\ndvp1_data_dri = (viafb_read_reg(VIASR, SR65) & 0x0c) >> 2;\r\ndvp1_clk_dri = viafb_read_reg(VIASR, SR65) & 0x03;\r\nseq_printf(m, "%x %x %x\n", dvp1, dvp1_data_dri, dvp1_clk_dri);\r\nreturn 0;\r\n}\r\nstatic int viafb_dvp1_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, viafb_dvp1_proc_show, NULL);\r\n}\r\nstatic ssize_t viafb_dvp1_proc_write(struct file *file,\r\nconst char __user *buffer, size_t count, loff_t *pos)\r\n{\r\nchar buf[20], *value, *pbuf;\r\nu8 reg_val = 0;\r\nunsigned long length, i;\r\nif (count < 1)\r\nreturn -EINVAL;\r\nlength = count > 20 ? 20 : count;\r\nif (copy_from_user(&buf[0], buffer, length))\r\nreturn -EFAULT;\r\nbuf[length - 1] = '\0';\r\npbuf = &buf[0];\r\nfor (i = 0; i < 3; i++) {\r\nvalue = strsep(&pbuf, " ");\r\nif (value != NULL) {\r\nif (kstrtou8(value, 0, &reg_val) < 0)\r\nreturn -EINVAL;\r\nswitch (i) {\r\ncase 0:\r\nviafb_write_reg_mask(CR9B, VIACR,\r\nreg_val, 0x0f);\r\nbreak;\r\ncase 1:\r\nviafb_write_reg_mask(SR65, VIASR,\r\nreg_val << 2, 0x0c);\r\nbreak;\r\ncase 2:\r\nviafb_write_reg_mask(SR65, VIASR,\r\nreg_val, 0x03);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} else {\r\nbreak;\r\n}\r\n}\r\nreturn count;\r\n}\r\nstatic int viafb_dfph_proc_show(struct seq_file *m, void *v)\r\n{\r\nu8 dfp_high = 0;\r\ndfp_high = viafb_read_reg(VIACR, CR97) & 0x0f;\r\nseq_printf(m, "%x\n", dfp_high);\r\nreturn 0;\r\n}\r\nstatic int viafb_dfph_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, viafb_dfph_proc_show, NULL);\r\n}\r\nstatic ssize_t viafb_dfph_proc_write(struct file *file,\r\nconst char __user *buffer, size_t count, loff_t *pos)\r\n{\r\nint err;\r\nu8 reg_val;\r\nerr = kstrtou8_from_user(buffer, count, 0, &reg_val);\r\nif (err)\r\nreturn err;\r\nviafb_write_reg_mask(CR97, VIACR, reg_val, 0x0f);\r\nreturn count;\r\n}\r\nstatic int viafb_dfpl_proc_show(struct seq_file *m, void *v)\r\n{\r\nu8 dfp_low = 0;\r\ndfp_low = viafb_read_reg(VIACR, CR99) & 0x0f;\r\nseq_printf(m, "%x\n", dfp_low);\r\nreturn 0;\r\n}\r\nstatic int viafb_dfpl_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, viafb_dfpl_proc_show, NULL);\r\n}\r\nstatic ssize_t viafb_dfpl_proc_write(struct file *file,\r\nconst char __user *buffer, size_t count, loff_t *pos)\r\n{\r\nint err;\r\nu8 reg_val;\r\nerr = kstrtou8_from_user(buffer, count, 0, &reg_val);\r\nif (err)\r\nreturn err;\r\nviafb_write_reg_mask(CR99, VIACR, reg_val, 0x0f);\r\nreturn count;\r\n}\r\nstatic int viafb_vt1636_proc_show(struct seq_file *m, void *v)\r\n{\r\nu8 vt1636_08 = 0, vt1636_09 = 0;\r\nswitch (viaparinfo->chip_info->lvds_chip_info.lvds_chip_name) {\r\ncase VT1636_LVDS:\r\nvt1636_08 =\r\nviafb_gpio_i2c_read_lvds(viaparinfo->lvds_setting_info,\r\n&viaparinfo->chip_info->lvds_chip_info, 0x08) & 0x0f;\r\nvt1636_09 =\r\nviafb_gpio_i2c_read_lvds(viaparinfo->lvds_setting_info,\r\n&viaparinfo->chip_info->lvds_chip_info, 0x09) & 0x1f;\r\nseq_printf(m, "%x %x\n", vt1636_08, vt1636_09);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (viaparinfo->chip_info->lvds_chip_info2.lvds_chip_name) {\r\ncase VT1636_LVDS:\r\nvt1636_08 =\r\nviafb_gpio_i2c_read_lvds(viaparinfo->lvds_setting_info2,\r\n&viaparinfo->chip_info->lvds_chip_info2, 0x08) & 0x0f;\r\nvt1636_09 =\r\nviafb_gpio_i2c_read_lvds(viaparinfo->lvds_setting_info2,\r\n&viaparinfo->chip_info->lvds_chip_info2, 0x09) & 0x1f;\r\nseq_printf(m, " %x %x\n", vt1636_08, vt1636_09);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int viafb_vt1636_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, viafb_vt1636_proc_show, NULL);\r\n}\r\nstatic ssize_t viafb_vt1636_proc_write(struct file *file,\r\nconst char __user *buffer, size_t count, loff_t *pos)\r\n{\r\nchar buf[30], *value, *pbuf;\r\nstruct IODATA reg_val;\r\nunsigned long length, i;\r\nif (count < 1)\r\nreturn -EINVAL;\r\nlength = count > 30 ? 30 : count;\r\nif (copy_from_user(&buf[0], buffer, length))\r\nreturn -EFAULT;\r\nbuf[length - 1] = '\0';\r\npbuf = &buf[0];\r\nswitch (viaparinfo->chip_info->lvds_chip_info.lvds_chip_name) {\r\ncase VT1636_LVDS:\r\nfor (i = 0; i < 2; i++) {\r\nvalue = strsep(&pbuf, " ");\r\nif (value != NULL) {\r\nif (kstrtou8(value, 0, &reg_val.Data) < 0)\r\nreturn -EINVAL;\r\nswitch (i) {\r\ncase 0:\r\nreg_val.Index = 0x08;\r\nreg_val.Mask = 0x0f;\r\nviafb_gpio_i2c_write_mask_lvds\r\n(viaparinfo->lvds_setting_info,\r\n&viaparinfo->\r\nchip_info->lvds_chip_info,\r\nreg_val);\r\nbreak;\r\ncase 1:\r\nreg_val.Index = 0x09;\r\nreg_val.Mask = 0x1f;\r\nviafb_gpio_i2c_write_mask_lvds\r\n(viaparinfo->lvds_setting_info,\r\n&viaparinfo->\r\nchip_info->lvds_chip_info,\r\nreg_val);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} else {\r\nbreak;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (viaparinfo->chip_info->lvds_chip_info2.lvds_chip_name) {\r\ncase VT1636_LVDS:\r\nfor (i = 0; i < 2; i++) {\r\nvalue = strsep(&pbuf, " ");\r\nif (value != NULL) {\r\nif (kstrtou8(value, 0, &reg_val.Data) < 0)\r\nreturn -EINVAL;\r\nswitch (i) {\r\ncase 0:\r\nreg_val.Index = 0x08;\r\nreg_val.Mask = 0x0f;\r\nviafb_gpio_i2c_write_mask_lvds\r\n(viaparinfo->lvds_setting_info2,\r\n&viaparinfo->\r\nchip_info->lvds_chip_info2,\r\nreg_val);\r\nbreak;\r\ncase 1:\r\nreg_val.Index = 0x09;\r\nreg_val.Mask = 0x1f;\r\nviafb_gpio_i2c_write_mask_lvds\r\n(viaparinfo->lvds_setting_info2,\r\n&viaparinfo->\r\nchip_info->lvds_chip_info2,\r\nreg_val);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} else {\r\nbreak;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn count;\r\n}\r\nstatic int viafb_sup_odev_proc_show(struct seq_file *m, void *v)\r\n{\r\nvia_odev_to_seq(m, supported_odev_map[\r\nviaparinfo->shared->chip_info.gfx_chip_name]);\r\nreturn 0;\r\n}\r\nstatic int viafb_sup_odev_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, viafb_sup_odev_proc_show, NULL);\r\n}\r\nstatic ssize_t odev_update(const char __user *buffer, size_t count, u32 *odev)\r\n{\r\nchar buf[64], *ptr = buf;\r\nu32 devices;\r\nbool add, sub;\r\nif (count < 1 || count > 63)\r\nreturn -EINVAL;\r\nif (copy_from_user(&buf[0], buffer, count))\r\nreturn -EFAULT;\r\nbuf[count] = '\0';\r\nadd = buf[0] == '+';\r\nsub = buf[0] == '-';\r\nif (add || sub)\r\nptr++;\r\ndevices = via_parse_odev(ptr, &ptr);\r\nif (*ptr == '\n')\r\nptr++;\r\nif (*ptr != 0)\r\nreturn -EINVAL;\r\nif (add)\r\n*odev |= devices;\r\nelse if (sub)\r\n*odev &= ~devices;\r\nelse\r\n*odev = devices;\r\nreturn count;\r\n}\r\nstatic int viafb_iga1_odev_proc_show(struct seq_file *m, void *v)\r\n{\r\nvia_odev_to_seq(m, viaparinfo->shared->iga1_devices);\r\nreturn 0;\r\n}\r\nstatic int viafb_iga1_odev_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, viafb_iga1_odev_proc_show, NULL);\r\n}\r\nstatic ssize_t viafb_iga1_odev_proc_write(struct file *file,\r\nconst char __user *buffer, size_t count, loff_t *pos)\r\n{\r\nu32 dev_on, dev_off, dev_old, dev_new;\r\nssize_t res;\r\ndev_old = dev_new = viaparinfo->shared->iga1_devices;\r\nres = odev_update(buffer, count, &dev_new);\r\nif (res != count)\r\nreturn res;\r\ndev_off = dev_old & ~dev_new;\r\ndev_on = dev_new & ~dev_old;\r\nviaparinfo->shared->iga1_devices = dev_new;\r\nviaparinfo->shared->iga2_devices &= ~dev_new;\r\nvia_set_state(dev_off, VIA_STATE_OFF);\r\nvia_set_source(dev_new, IGA1);\r\nvia_set_state(dev_on, VIA_STATE_ON);\r\nreturn res;\r\n}\r\nstatic int viafb_iga2_odev_proc_show(struct seq_file *m, void *v)\r\n{\r\nvia_odev_to_seq(m, viaparinfo->shared->iga2_devices);\r\nreturn 0;\r\n}\r\nstatic int viafb_iga2_odev_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, viafb_iga2_odev_proc_show, NULL);\r\n}\r\nstatic ssize_t viafb_iga2_odev_proc_write(struct file *file,\r\nconst char __user *buffer, size_t count, loff_t *pos)\r\n{\r\nu32 dev_on, dev_off, dev_old, dev_new;\r\nssize_t res;\r\ndev_old = dev_new = viaparinfo->shared->iga2_devices;\r\nres = odev_update(buffer, count, &dev_new);\r\nif (res != count)\r\nreturn res;\r\ndev_off = dev_old & ~dev_new;\r\ndev_on = dev_new & ~dev_old;\r\nviaparinfo->shared->iga2_devices = dev_new;\r\nviaparinfo->shared->iga1_devices &= ~dev_new;\r\nvia_set_state(dev_off, VIA_STATE_OFF);\r\nvia_set_source(dev_new, IGA2);\r\nvia_set_state(dev_on, VIA_STATE_ON);\r\nreturn res;\r\n}\r\nstatic void viafb_init_proc(struct viafb_shared *shared)\r\n{\r\nstruct proc_dir_entry *iga1_entry, *iga2_entry,\r\n*viafb_entry = proc_mkdir("viafb", NULL);\r\nshared->proc_entry = viafb_entry;\r\nif (viafb_entry) {\r\n#ifdef CONFIG_FB_VIA_DIRECT_PROCFS\r\nproc_create("dvp0", 0, viafb_entry, &viafb_dvp0_proc_fops);\r\nproc_create("dvp1", 0, viafb_entry, &viafb_dvp1_proc_fops);\r\nproc_create("dfph", 0, viafb_entry, &viafb_dfph_proc_fops);\r\nproc_create("dfpl", 0, viafb_entry, &viafb_dfpl_proc_fops);\r\nif (IS_VT1636(shared->chip_info.lvds_chip_info)\r\n|| IS_VT1636(shared->chip_info.lvds_chip_info2))\r\nproc_create("vt1636", 0, viafb_entry,\r\n&viafb_vt1636_proc_fops);\r\n#endif\r\nproc_create("supported_output_devices", 0, viafb_entry,\r\n&viafb_sup_odev_proc_fops);\r\niga1_entry = proc_mkdir("iga1", viafb_entry);\r\nshared->iga1_proc_entry = iga1_entry;\r\nproc_create("output_devices", 0, iga1_entry,\r\n&viafb_iga1_odev_proc_fops);\r\niga2_entry = proc_mkdir("iga2", viafb_entry);\r\nshared->iga2_proc_entry = iga2_entry;\r\nproc_create("output_devices", 0, iga2_entry,\r\n&viafb_iga2_odev_proc_fops);\r\n}\r\n}\r\nstatic void viafb_remove_proc(struct viafb_shared *shared)\r\n{\r\nstruct proc_dir_entry *viafb_entry = shared->proc_entry;\r\nif (!viafb_entry)\r\nreturn;\r\nremove_proc_entry("output_devices", shared->iga2_proc_entry);\r\nremove_proc_entry("iga2", viafb_entry);\r\nremove_proc_entry("output_devices", shared->iga1_proc_entry);\r\nremove_proc_entry("iga1", viafb_entry);\r\nremove_proc_entry("supported_output_devices", viafb_entry);\r\n#ifdef CONFIG_FB_VIA_DIRECT_PROCFS\r\nremove_proc_entry("dvp0", viafb_entry);\r\nremove_proc_entry("dvp1", viafb_entry);\r\nremove_proc_entry("dfph", viafb_entry);\r\nremove_proc_entry("dfpl", viafb_entry);\r\nif (IS_VT1636(shared->chip_info.lvds_chip_info)\r\n|| IS_VT1636(shared->chip_info.lvds_chip_info2))\r\nremove_proc_entry("vt1636", viafb_entry);\r\n#endif\r\nremove_proc_entry("viafb", NULL);\r\n}\r\nstatic int parse_mode(const char *str, u32 devices, u32 *xres, u32 *yres)\r\n{\r\nconst struct fb_videomode *mode = NULL;\r\nchar *ptr;\r\nif (!str) {\r\nif (devices == VIA_CRT)\r\nmode = via_aux_get_preferred_mode(\r\nviaparinfo->shared->i2c_26);\r\nelse if (devices == VIA_DVP1)\r\nmode = via_aux_get_preferred_mode(\r\nviaparinfo->shared->i2c_31);\r\nif (mode) {\r\n*xres = mode->xres;\r\n*yres = mode->yres;\r\n} else if (machine_is_olpc()) {\r\n*xres = 1200;\r\n*yres = 900;\r\n} else {\r\n*xres = 640;\r\n*yres = 480;\r\n}\r\nreturn 0;\r\n}\r\n*xres = simple_strtoul(str, &ptr, 10);\r\nif (ptr[0] != 'x')\r\nreturn -EINVAL;\r\n*yres = simple_strtoul(&ptr[1], &ptr, 10);\r\nif (ptr[0])\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int viafb_suspend(void *unused)\r\n{\r\nconsole_lock();\r\nfb_set_suspend(viafbinfo, 1);\r\nviafb_sync(viafbinfo);\r\nconsole_unlock();\r\nreturn 0;\r\n}\r\nstatic int viafb_resume(void *unused)\r\n{\r\nconsole_lock();\r\nif (viaparinfo->shared->vdev->engine_mmio)\r\nviafb_reset_engine(viaparinfo);\r\nviafb_set_par(viafbinfo);\r\nif (viafb_dual_fb)\r\nviafb_set_par(viafbinfo1);\r\nfb_set_suspend(viafbinfo, 0);\r\nconsole_unlock();\r\nreturn 0;\r\n}\r\nstatic void i2c_bus_probe(struct viafb_shared *shared)\r\n{\r\nprintk(KERN_INFO "viafb: Probing I2C bus 0x26\n");\r\nshared->i2c_26 = via_aux_probe(viafb_find_i2c_adapter(VIA_PORT_26));\r\nprintk(KERN_INFO "viafb: Probing I2C bus 0x31\n");\r\nshared->i2c_31 = via_aux_probe(viafb_find_i2c_adapter(VIA_PORT_31));\r\nif (!machine_is_olpc()) {\r\nprintk(KERN_INFO "viafb: Probing I2C bus 0x2C\n");\r\nshared->i2c_2C = via_aux_probe(viafb_find_i2c_adapter(VIA_PORT_2C));\r\n}\r\nprintk(KERN_INFO "viafb: Finished I2C bus probing");\r\n}\r\nstatic void i2c_bus_free(struct viafb_shared *shared)\r\n{\r\nvia_aux_free(shared->i2c_26);\r\nvia_aux_free(shared->i2c_31);\r\nvia_aux_free(shared->i2c_2C);\r\n}\r\nint via_fb_pci_probe(struct viafb_dev *vdev)\r\n{\r\nu32 default_xres, default_yres;\r\nstruct fb_var_screeninfo default_var;\r\nint rc;\r\nu32 viafb_par_length;\r\nDEBUG_MSG(KERN_INFO "VIAFB PCI Probe!!\n");\r\nmemset(&default_var, 0, sizeof(default_var));\r\nviafb_par_length = ALIGN(sizeof(struct viafb_par), BITS_PER_LONG/8);\r\nviafbinfo = framebuffer_alloc(viafb_par_length +\r\nALIGN(sizeof(struct viafb_shared), BITS_PER_LONG/8),\r\n&vdev->pdev->dev);\r\nif (!viafbinfo) {\r\nprintk(KERN_ERR"Could not allocate memory for viafb_info.\n");\r\nreturn -ENOMEM;\r\n}\r\nviaparinfo = (struct viafb_par *)viafbinfo->par;\r\nviaparinfo->shared = viafbinfo->par + viafb_par_length;\r\nviaparinfo->shared->vdev = vdev;\r\nviaparinfo->vram_addr = 0;\r\nviaparinfo->tmds_setting_info = &viaparinfo->shared->tmds_setting_info;\r\nviaparinfo->lvds_setting_info = &viaparinfo->shared->lvds_setting_info;\r\nviaparinfo->lvds_setting_info2 =\r\n&viaparinfo->shared->lvds_setting_info2;\r\nviaparinfo->chip_info = &viaparinfo->shared->chip_info;\r\ni2c_bus_probe(viaparinfo->shared);\r\nif (viafb_dual_fb)\r\nviafb_SAMM_ON = 1;\r\nparse_lcd_port();\r\nparse_dvi_port();\r\nviafb_init_chip_info(vdev->chip_type);\r\nviaparinfo->fbmem = vdev->fbmem_start;\r\nviaparinfo->memsize = vdev->fbmem_len;\r\nviaparinfo->fbmem_free = viaparinfo->memsize;\r\nviaparinfo->fbmem_used = 0;\r\nviafbinfo->screen_base = vdev->fbmem;\r\nviafbinfo->fix.mmio_start = vdev->engine_start;\r\nviafbinfo->fix.mmio_len = vdev->engine_len;\r\nviafbinfo->node = 0;\r\nviafbinfo->fbops = &viafb_ops;\r\nviafbinfo->flags = FBINFO_DEFAULT | FBINFO_HWACCEL_YPAN;\r\nviafbinfo->pseudo_palette = pseudo_pal;\r\nif (viafb_accel && !viafb_setup_engine(viafbinfo)) {\r\nviafbinfo->flags |= FBINFO_HWACCEL_COPYAREA |\r\nFBINFO_HWACCEL_FILLRECT | FBINFO_HWACCEL_IMAGEBLIT;\r\ndefault_var.accel_flags = FB_ACCELF_TEXT;\r\n} else {\r\nviafbinfo->flags |= FBINFO_HWACCEL_DISABLED;\r\ndefault_var.accel_flags = 0;\r\n}\r\nif (viafb_second_size && (viafb_second_size < 8)) {\r\nviafb_second_offset = viaparinfo->fbmem_free -\r\nviafb_second_size * 1024 * 1024;\r\n} else {\r\nviafb_second_size = 8;\r\nviafb_second_offset = viaparinfo->fbmem_free -\r\nviafb_second_size * 1024 * 1024;\r\n}\r\nparse_mode(viafb_mode, viaparinfo->shared->iga1_devices,\r\n&default_xres, &default_yres);\r\nif (viafb_SAMM_ON == 1)\r\nparse_mode(viafb_mode1, viaparinfo->shared->iga2_devices,\r\n&viafb_second_xres, &viafb_second_yres);\r\ndefault_var.xres = default_xres;\r\ndefault_var.yres = default_yres;\r\ndefault_var.xres_virtual = default_xres;\r\ndefault_var.yres_virtual = default_yres;\r\ndefault_var.bits_per_pixel = viafb_bpp;\r\nviafb_fill_var_timing_info(&default_var, viafb_get_best_mode(\r\ndefault_var.xres, default_var.yres, viafb_refresh));\r\nviafb_setup_fixinfo(&viafbinfo->fix, viaparinfo);\r\nviafbinfo->var = default_var;\r\nif (viafb_dual_fb) {\r\nviafbinfo1 = framebuffer_alloc(viafb_par_length,\r\n&vdev->pdev->dev);\r\nif (!viafbinfo1) {\r\nprintk(KERN_ERR\r\n"allocate the second framebuffer struct error\n");\r\nrc = -ENOMEM;\r\ngoto out_fb_release;\r\n}\r\nviaparinfo1 = viafbinfo1->par;\r\nmemcpy(viaparinfo1, viaparinfo, viafb_par_length);\r\nviaparinfo1->vram_addr = viafb_second_offset;\r\nviaparinfo1->memsize = viaparinfo->memsize -\r\nviafb_second_offset;\r\nviaparinfo->memsize = viafb_second_offset;\r\nviaparinfo1->fbmem = viaparinfo->fbmem + viafb_second_offset;\r\nviaparinfo1->fbmem_used = viaparinfo->fbmem_used;\r\nviaparinfo1->fbmem_free = viaparinfo1->memsize -\r\nviaparinfo1->fbmem_used;\r\nviaparinfo->fbmem_free = viaparinfo->memsize;\r\nviaparinfo->fbmem_used = 0;\r\nviaparinfo->iga_path = IGA1;\r\nviaparinfo1->iga_path = IGA2;\r\nmemcpy(viafbinfo1, viafbinfo, sizeof(struct fb_info));\r\nviafbinfo1->par = viaparinfo1;\r\nviafbinfo1->screen_base = viafbinfo->screen_base +\r\nviafb_second_offset;\r\ndefault_var.xres = viafb_second_xres;\r\ndefault_var.yres = viafb_second_yres;\r\ndefault_var.xres_virtual = viafb_second_xres;\r\ndefault_var.yres_virtual = viafb_second_yres;\r\ndefault_var.bits_per_pixel = viafb_bpp1;\r\nviafb_fill_var_timing_info(&default_var, viafb_get_best_mode(\r\ndefault_var.xres, default_var.yres, viafb_refresh1));\r\nviafb_setup_fixinfo(&viafbinfo1->fix, viaparinfo1);\r\nviafb_check_var(&default_var, viafbinfo1);\r\nviafbinfo1->var = default_var;\r\nviafb_update_fix(viafbinfo1);\r\nviaparinfo1->depth = fb_get_color_depth(&viafbinfo1->var,\r\n&viafbinfo1->fix);\r\n}\r\nviafb_check_var(&viafbinfo->var, viafbinfo);\r\nviafb_update_fix(viafbinfo);\r\nviaparinfo->depth = fb_get_color_depth(&viafbinfo->var,\r\n&viafbinfo->fix);\r\ndefault_var.activate = FB_ACTIVATE_NOW;\r\nrc = fb_alloc_cmap(&viafbinfo->cmap, 256, 0);\r\nif (rc)\r\ngoto out_fb1_release;\r\nif (viafb_dual_fb && (viafb_primary_dev == LCD_Device)\r\n&& (viaparinfo->chip_info->gfx_chip_name == UNICHROME_CLE266)) {\r\nrc = register_framebuffer(viafbinfo1);\r\nif (rc)\r\ngoto out_dealloc_cmap;\r\n}\r\nrc = register_framebuffer(viafbinfo);\r\nif (rc)\r\ngoto out_fb1_unreg_lcd_cle266;\r\nif (viafb_dual_fb && ((viafb_primary_dev != LCD_Device)\r\n|| (viaparinfo->chip_info->gfx_chip_name !=\r\nUNICHROME_CLE266))) {\r\nrc = register_framebuffer(viafbinfo1);\r\nif (rc)\r\ngoto out_fb_unreg;\r\n}\r\nDEBUG_MSG(KERN_INFO "fb%d: %s frame buffer device %dx%d-%dbpp\n",\r\nviafbinfo->node, viafbinfo->fix.id, default_var.xres,\r\ndefault_var.yres, default_var.bits_per_pixel);\r\nviafb_init_proc(viaparinfo->shared);\r\nviafb_init_dac(IGA2);\r\n#ifdef CONFIG_PM\r\nviafb_pm_register(&viafb_fb_pm_hooks);\r\n#endif\r\nreturn 0;\r\nout_fb_unreg:\r\nunregister_framebuffer(viafbinfo);\r\nout_fb1_unreg_lcd_cle266:\r\nif (viafb_dual_fb && (viafb_primary_dev == LCD_Device)\r\n&& (viaparinfo->chip_info->gfx_chip_name == UNICHROME_CLE266))\r\nunregister_framebuffer(viafbinfo1);\r\nout_dealloc_cmap:\r\nfb_dealloc_cmap(&viafbinfo->cmap);\r\nout_fb1_release:\r\nframebuffer_release(viafbinfo1);\r\nout_fb_release:\r\ni2c_bus_free(viaparinfo->shared);\r\nframebuffer_release(viafbinfo);\r\nreturn rc;\r\n}\r\nvoid via_fb_pci_remove(struct pci_dev *pdev)\r\n{\r\nDEBUG_MSG(KERN_INFO "via_pci_remove!\n");\r\nfb_dealloc_cmap(&viafbinfo->cmap);\r\nunregister_framebuffer(viafbinfo);\r\nif (viafb_dual_fb)\r\nunregister_framebuffer(viafbinfo1);\r\nviafb_remove_proc(viaparinfo->shared);\r\ni2c_bus_free(viaparinfo->shared);\r\nframebuffer_release(viafbinfo);\r\nif (viafb_dual_fb)\r\nframebuffer_release(viafbinfo1);\r\n}\r\nstatic int __init viafb_setup(void)\r\n{\r\nchar *this_opt;\r\nchar *options;\r\nDEBUG_MSG(KERN_INFO "viafb_setup!\n");\r\nif (fb_get_options("viafb", &options))\r\nreturn -ENODEV;\r\nif (!options || !*options)\r\nreturn 0;\r\nwhile ((this_opt = strsep(&options, ",")) != NULL) {\r\nif (!*this_opt)\r\ncontinue;\r\nif (!strncmp(this_opt, "viafb_mode1=", 12)) {\r\nviafb_mode1 = kstrdup(this_opt + 12, GFP_KERNEL);\r\n} else if (!strncmp(this_opt, "viafb_mode=", 11)) {\r\nviafb_mode = kstrdup(this_opt + 11, GFP_KERNEL);\r\n} else if (!strncmp(this_opt, "viafb_bpp1=", 11)) {\r\nif (kstrtouint(this_opt + 11, 0, &viafb_bpp1) < 0)\r\nreturn -EINVAL;\r\n} else if (!strncmp(this_opt, "viafb_bpp=", 10)) {\r\nif (kstrtouint(this_opt + 10, 0, &viafb_bpp) < 0)\r\nreturn -EINVAL;\r\n} else if (!strncmp(this_opt, "viafb_refresh1=", 15)) {\r\nif (kstrtoint(this_opt + 15, 0, &viafb_refresh1) < 0)\r\nreturn -EINVAL;\r\n} else if (!strncmp(this_opt, "viafb_refresh=", 14)) {\r\nif (kstrtoint(this_opt + 14, 0, &viafb_refresh) < 0)\r\nreturn -EINVAL;\r\n} else if (!strncmp(this_opt, "viafb_lcd_dsp_method=", 21)) {\r\nif (kstrtoint(this_opt + 21, 0,\r\n&viafb_lcd_dsp_method) < 0)\r\nreturn -EINVAL;\r\n} else if (!strncmp(this_opt, "viafb_lcd_panel_id=", 19)) {\r\nif (kstrtoint(this_opt + 19, 0,\r\n&viafb_lcd_panel_id) < 0)\r\nreturn -EINVAL;\r\n} else if (!strncmp(this_opt, "viafb_accel=", 12)) {\r\nif (kstrtoint(this_opt + 12, 0, &viafb_accel) < 0)\r\nreturn -EINVAL;\r\n} else if (!strncmp(this_opt, "viafb_SAMM_ON=", 14)) {\r\nif (kstrtoint(this_opt + 14, 0, &viafb_SAMM_ON) < 0)\r\nreturn -EINVAL;\r\n} else if (!strncmp(this_opt, "viafb_active_dev=", 17)) {\r\nviafb_active_dev = kstrdup(this_opt + 17, GFP_KERNEL);\r\n} else if (!strncmp(this_opt,\r\n"viafb_display_hardware_layout=", 30)) {\r\nif (kstrtoint(this_opt + 30, 0,\r\n&viafb_display_hardware_layout) < 0)\r\nreturn -EINVAL;\r\n} else if (!strncmp(this_opt, "viafb_second_size=", 18)) {\r\nif (kstrtoint(this_opt + 18, 0, &viafb_second_size) < 0)\r\nreturn -EINVAL;\r\n} else if (!strncmp(this_opt,\r\n"viafb_platform_epia_dvi=", 24)) {\r\nif (kstrtoint(this_opt + 24, 0,\r\n&viafb_platform_epia_dvi) < 0)\r\nreturn -EINVAL;\r\n} else if (!strncmp(this_opt,\r\n"viafb_device_lcd_dualedge=", 26)) {\r\nif (kstrtoint(this_opt + 26, 0,\r\n&viafb_device_lcd_dualedge) < 0)\r\nreturn -EINVAL;\r\n} else if (!strncmp(this_opt, "viafb_bus_width=", 16)) {\r\nif (kstrtoint(this_opt + 16, 0, &viafb_bus_width) < 0)\r\nreturn -EINVAL;\r\n} else if (!strncmp(this_opt, "viafb_lcd_mode=", 15)) {\r\nif (kstrtoint(this_opt + 15, 0, &viafb_lcd_mode) < 0)\r\nreturn -EINVAL;\r\n} else if (!strncmp(this_opt, "viafb_lcd_port=", 15)) {\r\nviafb_lcd_port = kstrdup(this_opt + 15, GFP_KERNEL);\r\n} else if (!strncmp(this_opt, "viafb_dvi_port=", 15)) {\r\nviafb_dvi_port = kstrdup(this_opt + 15, GFP_KERNEL);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint __init viafb_init(void)\r\n{\r\nu32 dummy_x, dummy_y;\r\nint r = 0;\r\nif (machine_is_olpc())\r\nviafb_lcd_panel_id = 23;\r\n#ifndef MODULE\r\nr = viafb_setup();\r\nif (r < 0)\r\nreturn r;\r\n#endif\r\nif (parse_mode(viafb_mode, 0, &dummy_x, &dummy_y)\r\n|| !viafb_get_best_mode(dummy_x, dummy_y, viafb_refresh)\r\n|| parse_mode(viafb_mode1, 0, &dummy_x, &dummy_y)\r\n|| !viafb_get_best_mode(dummy_x, dummy_y, viafb_refresh1)\r\n|| viafb_bpp < 0 || viafb_bpp > 32\r\n|| viafb_bpp1 < 0 || viafb_bpp1 > 32\r\n|| parse_active_dev())\r\nreturn -EINVAL;\r\nprintk(KERN_INFO\r\n"VIA Graphics Integration Chipset framebuffer %d.%d initializing\n",\r\nVERSION_MAJOR, VERSION_MINOR);\r\nreturn r;\r\n}\r\nvoid __exit viafb_exit(void)\r\n{\r\nDEBUG_MSG(KERN_INFO "viafb_exit!\n");\r\n}
