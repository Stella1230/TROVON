void Efuse_PowerSwitch(\r\nstruct adapter *pAdapter,\r\nu8 bWrite,\r\nu8 PwrState)\r\n{\r\nu8 tempval;\r\nu16 tmpV16;\r\nif (PwrState) {\r\nusb_write8(pAdapter, REG_EFUSE_ACCESS, EFUSE_ACCESS_ON);\r\ntmpV16 = usb_read16(pAdapter, REG_SYS_ISO_CTRL);\r\nif (!(tmpV16 & PWC_EV12V)) {\r\ntmpV16 |= PWC_EV12V;\r\nusb_write16(pAdapter, REG_SYS_ISO_CTRL, tmpV16);\r\n}\r\ntmpV16 = usb_read16(pAdapter, REG_SYS_FUNC_EN);\r\nif (!(tmpV16 & FEN_ELDR)) {\r\ntmpV16 |= FEN_ELDR;\r\nusb_write16(pAdapter, REG_SYS_FUNC_EN, tmpV16);\r\n}\r\ntmpV16 = usb_read16(pAdapter, REG_SYS_CLKR);\r\nif ((!(tmpV16 & LOADER_CLK_EN)) || (!(tmpV16 & ANA8M))) {\r\ntmpV16 |= (LOADER_CLK_EN | ANA8M);\r\nusb_write16(pAdapter, REG_SYS_CLKR, tmpV16);\r\n}\r\nif (bWrite) {\r\ntempval = usb_read8(pAdapter, EFUSE_TEST+3);\r\ntempval &= 0x0F;\r\ntempval |= (VOLTAGE_V25 << 4);\r\nusb_write8(pAdapter, EFUSE_TEST+3, (tempval | 0x80));\r\n}\r\n} else {\r\nusb_write8(pAdapter, REG_EFUSE_ACCESS, EFUSE_ACCESS_OFF);\r\nif (bWrite) {\r\ntempval = usb_read8(pAdapter, EFUSE_TEST+3);\r\nusb_write8(pAdapter, EFUSE_TEST+3, (tempval & 0x7F));\r\n}\r\n}\r\n}\r\nstatic void\r\nefuse_phymap_to_logical(u8 *phymap, u16 _offset, u16 _size_byte, u8 *pbuf)\r\n{\r\nu8 *efuseTbl = NULL;\r\nu8 rtemp8;\r\nu16 eFuse_Addr = 0;\r\nu8 offset, wren;\r\nu16 i, j;\r\nu16 **eFuseWord = NULL;\r\nu16 efuse_utilized = 0;\r\nu8 u1temp = 0;\r\nefuseTbl = kzalloc(EFUSE_MAP_LEN_88E, GFP_KERNEL);\r\nif (!efuseTbl)\r\nreturn;\r\neFuseWord = (u16 **)rtw_malloc2d(EFUSE_MAX_SECTION_88E, EFUSE_MAX_WORD_UNIT, sizeof(u16));\r\nif (!eFuseWord) {\r\nDBG_88E("%s: alloc eFuseWord fail!\n", __func__);\r\ngoto eFuseWord_failed;\r\n}\r\nfor (i = 0; i < EFUSE_MAX_SECTION_88E; i++)\r\nfor (j = 0; j < EFUSE_MAX_WORD_UNIT; j++)\r\neFuseWord[i][j] = 0xFFFF;\r\nrtemp8 = *(phymap+eFuse_Addr);\r\nif (rtemp8 != 0xFF) {\r\nefuse_utilized++;\r\neFuse_Addr++;\r\n} else {\r\nDBG_88E("EFUSE is empty efuse_Addr-%d efuse_data =%x\n", eFuse_Addr, rtemp8);\r\ngoto exit;\r\n}\r\nwhile ((rtemp8 != 0xFF) && (eFuse_Addr < EFUSE_REAL_CONTENT_LEN_88E)) {\r\nif ((rtemp8 & 0x1F) == 0x0F) {\r\nu1temp = (rtemp8 & 0xE0) >> 5;\r\nrtemp8 = *(phymap+eFuse_Addr);\r\nif ((rtemp8 & 0x0F) == 0x0F) {\r\neFuse_Addr++;\r\nrtemp8 = *(phymap+eFuse_Addr);\r\nif (rtemp8 != 0xFF && (eFuse_Addr < EFUSE_REAL_CONTENT_LEN_88E))\r\neFuse_Addr++;\r\ncontinue;\r\n} else {\r\noffset = ((rtemp8 & 0xF0) >> 1) | u1temp;\r\nwren = rtemp8 & 0x0F;\r\neFuse_Addr++;\r\n}\r\n} else {\r\noffset = (rtemp8 >> 4) & 0x0f;\r\nwren = rtemp8 & 0x0f;\r\n}\r\nif (offset < EFUSE_MAX_SECTION_88E) {\r\nfor (i = 0; i < EFUSE_MAX_WORD_UNIT; i++) {\r\nif (!(wren & 0x01)) {\r\nrtemp8 = *(phymap+eFuse_Addr);\r\neFuse_Addr++;\r\nefuse_utilized++;\r\neFuseWord[offset][i] = (rtemp8 & 0xff);\r\nif (eFuse_Addr >= EFUSE_REAL_CONTENT_LEN_88E)\r\nbreak;\r\nrtemp8 = *(phymap+eFuse_Addr);\r\neFuse_Addr++;\r\nefuse_utilized++;\r\neFuseWord[offset][i] |= (((u16)rtemp8 << 8) & 0xff00);\r\nif (eFuse_Addr >= EFUSE_REAL_CONTENT_LEN_88E)\r\nbreak;\r\n}\r\nwren >>= 1;\r\n}\r\n}\r\nrtemp8 = *(phymap+eFuse_Addr);\r\nif (rtemp8 != 0xFF && (eFuse_Addr < EFUSE_REAL_CONTENT_LEN_88E)) {\r\nefuse_utilized++;\r\neFuse_Addr++;\r\n}\r\n}\r\nfor (i = 0; i < EFUSE_MAX_SECTION_88E; i++) {\r\nfor (j = 0; j < EFUSE_MAX_WORD_UNIT; j++) {\r\nefuseTbl[(i*8)+(j*2)] = (eFuseWord[i][j] & 0xff);\r\nefuseTbl[(i*8)+((j*2)+1)] = ((eFuseWord[i][j] >> 8) & 0xff);\r\n}\r\n}\r\nfor (i = 0; i < _size_byte; i++)\r\npbuf[i] = efuseTbl[_offset+i];\r\nexit:\r\nkfree(eFuseWord);\r\neFuseWord_failed:\r\nkfree(efuseTbl);\r\n}\r\nstatic void efuse_read_phymap_from_txpktbuf(\r\nstruct adapter *adapter,\r\nint bcnhead,\r\nu8 *content,\r\nu16 *size\r\n)\r\n{\r\nu16 dbg_addr = 0;\r\nunsigned long start = 0;\r\nu8 reg_0x143 = 0;\r\nu32 lo32 = 0, hi32 = 0;\r\nu16 len = 0, count = 0;\r\nint i = 0;\r\nu16 limit = *size;\r\nu8 *pos = content;\r\nif (bcnhead < 0)\r\nbcnhead = usb_read8(adapter, REG_TDECTRL+1);\r\nDBG_88E("%s bcnhead:%d\n", __func__, bcnhead);\r\nusb_write8(adapter, REG_PKT_BUFF_ACCESS_CTRL, TXPKT_BUF_SELECT);\r\ndbg_addr = bcnhead*128/8;\r\nwhile (1) {\r\nusb_write16(adapter, REG_PKTBUF_DBG_ADDR, dbg_addr+i);\r\nusb_write8(adapter, REG_TXPKTBUF_DBG, 0);\r\nstart = jiffies;\r\nwhile (!(reg_0x143 = usb_read8(adapter, REG_TXPKTBUF_DBG)) &&\r\njiffies_to_msecs(jiffies - start) < 1000) {\r\nDBG_88E("%s polling reg_0x143:0x%02x, reg_0x106:0x%02x\n", __func__, reg_0x143, usb_read8(adapter, 0x106));\r\nusleep_range(1000, 2000);\r\n}\r\nlo32 = usb_read32(adapter, REG_PKTBUF_DBG_DATA_L);\r\nhi32 = usb_read32(adapter, REG_PKTBUF_DBG_DATA_H);\r\nif (i == 0) {\r\nu8 lenc[2];\r\nu16 lenbak, aaabak;\r\nu16 aaa;\r\nlenc[0] = usb_read8(adapter, REG_PKTBUF_DBG_DATA_L);\r\nlenc[1] = usb_read8(adapter, REG_PKTBUF_DBG_DATA_L+1);\r\naaabak = le16_to_cpup((__le16 *)lenc);\r\nlenbak = le16_to_cpu(*((__le16 *)lenc));\r\naaa = le16_to_cpup((__le16 *)&lo32);\r\nlen = le16_to_cpu(*((__le16 *)&lo32));\r\nlimit = min_t(u16, len-2, limit);\r\nDBG_88E("%s len:%u, lenbak:%u, aaa:%u, aaabak:%u\n", __func__, len, lenbak, aaa, aaabak);\r\nmemcpy(pos, ((u8 *)&lo32)+2, (limit >= count+2) ? 2 : limit-count);\r\ncount += (limit >= count+2) ? 2 : limit-count;\r\npos = content+count;\r\n} else {\r\nmemcpy(pos, ((u8 *)&lo32), (limit >= count+4) ? 4 : limit-count);\r\ncount += (limit >= count+4) ? 4 : limit-count;\r\npos = content+count;\r\n}\r\nif (limit > count && len-2 > count) {\r\nmemcpy(pos, (u8 *)&hi32, (limit >= count+4) ? 4 : limit-count);\r\ncount += (limit >= count+4) ? 4 : limit-count;\r\npos = content+count;\r\n}\r\nif (limit <= count || len-2 <= count)\r\nbreak;\r\ni++;\r\n}\r\nusb_write8(adapter, REG_PKT_BUFF_ACCESS_CTRL, DISABLE_TRXPKT_BUF_ACCESS);\r\nDBG_88E("%s read count:%u\n", __func__, count);\r\n*size = count;\r\n}\r\nstatic s32 iol_read_efuse(struct adapter *padapter, u8 txpktbuf_bndy, u16 offset, u16 size_byte, u8 *logical_map)\r\n{\r\ns32 status = _FAIL;\r\nu8 physical_map[512];\r\nu16 size = 512;\r\nusb_write8(padapter, REG_TDECTRL+1, txpktbuf_bndy);\r\nmemset(physical_map, 0xFF, 512);\r\nusb_write8(padapter, REG_PKT_BUFF_ACCESS_CTRL, TXPKT_BUF_SELECT);\r\nstatus = iol_execute(padapter, CMD_READ_EFUSE_MAP);\r\nif (status == _SUCCESS)\r\nefuse_read_phymap_from_txpktbuf(padapter, txpktbuf_bndy, physical_map, &size);\r\nefuse_phymap_to_logical(physical_map, offset, size_byte, logical_map);\r\nreturn status;\r\n}\r\nvoid efuse_ReadEFuse(struct adapter *Adapter, u8 efuseType, u16 _offset, u16 _size_byte, u8 *pbuf)\r\n{\r\nif (rtw_IOL_applied(Adapter)) {\r\nrtw_hal_power_on(Adapter);\r\niol_mode_enable(Adapter, 1);\r\niol_read_efuse(Adapter, 0, _offset, _size_byte, pbuf);\r\niol_mode_enable(Adapter, 0);\r\n}\r\n}\r\nu8 Efuse_WordEnableDataWrite(struct adapter *pAdapter, u16 efuse_addr, u8 word_en, u8 *data)\r\n{\r\nu16 tmpaddr = 0;\r\nu16 start_addr = efuse_addr;\r\nu8 badworden = 0x0F;\r\nu8 tmpdata[8];\r\nmemset(tmpdata, 0xff, PGPKT_DATA_SIZE);\r\nif (!(word_en & BIT(0))) {\r\ntmpaddr = start_addr;\r\nefuse_OneByteWrite(pAdapter, start_addr++, data[0]);\r\nefuse_OneByteWrite(pAdapter, start_addr++, data[1]);\r\nefuse_OneByteRead(pAdapter, tmpaddr, &tmpdata[0]);\r\nefuse_OneByteRead(pAdapter, tmpaddr+1, &tmpdata[1]);\r\nif ((data[0] != tmpdata[0]) || (data[1] != tmpdata[1]))\r\nbadworden &= (~BIT(0));\r\n}\r\nif (!(word_en & BIT(1))) {\r\ntmpaddr = start_addr;\r\nefuse_OneByteWrite(pAdapter, start_addr++, data[2]);\r\nefuse_OneByteWrite(pAdapter, start_addr++, data[3]);\r\nefuse_OneByteRead(pAdapter, tmpaddr, &tmpdata[2]);\r\nefuse_OneByteRead(pAdapter, tmpaddr+1, &tmpdata[3]);\r\nif ((data[2] != tmpdata[2]) || (data[3] != tmpdata[3]))\r\nbadworden &= (~BIT(1));\r\n}\r\nif (!(word_en & BIT(2))) {\r\ntmpaddr = start_addr;\r\nefuse_OneByteWrite(pAdapter, start_addr++, data[4]);\r\nefuse_OneByteWrite(pAdapter, start_addr++, data[5]);\r\nefuse_OneByteRead(pAdapter, tmpaddr, &tmpdata[4]);\r\nefuse_OneByteRead(pAdapter, tmpaddr+1, &tmpdata[5]);\r\nif ((data[4] != tmpdata[4]) || (data[5] != tmpdata[5]))\r\nbadworden &= (~BIT(2));\r\n}\r\nif (!(word_en & BIT(3))) {\r\ntmpaddr = start_addr;\r\nefuse_OneByteWrite(pAdapter, start_addr++, data[6]);\r\nefuse_OneByteWrite(pAdapter, start_addr++, data[7]);\r\nefuse_OneByteRead(pAdapter, tmpaddr, &tmpdata[6]);\r\nefuse_OneByteRead(pAdapter, tmpaddr+1, &tmpdata[7]);\r\nif ((data[6] != tmpdata[6]) || (data[7] != tmpdata[7]))\r\nbadworden &= (~BIT(3));\r\n}\r\nreturn badworden;\r\n}\r\nstatic u16 Efuse_GetCurrentSize(struct adapter *pAdapter)\r\n{\r\nint bContinual = true;\r\nu16 efuse_addr = 0;\r\nu8 hoffset = 0, hworden = 0;\r\nu8 efuse_data, word_cnts = 0;\r\nrtw_hal_get_hwreg(pAdapter, HW_VAR_EFUSE_BYTES, (u8 *)&efuse_addr);\r\nwhile (bContinual &&\r\nefuse_OneByteRead(pAdapter, efuse_addr, &efuse_data) &&\r\nAVAILABLE_EFUSE_ADDR(efuse_addr)) {\r\nif (efuse_data != 0xFF) {\r\nif ((efuse_data&0x1F) == 0x0F) {\r\nhoffset = efuse_data;\r\nefuse_addr++;\r\nefuse_OneByteRead(pAdapter, efuse_addr, &efuse_data);\r\nif ((efuse_data & 0x0F) == 0x0F) {\r\nefuse_addr++;\r\ncontinue;\r\n} else {\r\nhoffset = ((hoffset & 0xE0) >> 5) | ((efuse_data & 0xF0) >> 1);\r\nhworden = efuse_data & 0x0F;\r\n}\r\n} else {\r\nhoffset = (efuse_data>>4) & 0x0F;\r\nhworden = efuse_data & 0x0F;\r\n}\r\nword_cnts = Efuse_CalculateWordCnts(hworden);\r\nefuse_addr = efuse_addr + (word_cnts*2)+1;\r\n} else {\r\nbContinual = false;\r\n}\r\n}\r\nrtw_hal_set_hwreg(pAdapter, HW_VAR_EFUSE_BYTES, (u8 *)&efuse_addr);\r\nreturn efuse_addr;\r\n}\r\nint Efuse_PgPacketRead(struct adapter *pAdapter, u8 offset, u8 *data)\r\n{\r\nu8 ReadState = PG_STATE_HEADER;\r\nint bContinual = true;\r\nint bDataEmpty = true;\r\nu8 efuse_data, word_cnts = 0;\r\nu16 efuse_addr = 0;\r\nu8 hoffset = 0, hworden = 0;\r\nu8 tmpidx = 0;\r\nu8 tmpdata[8];\r\nu8 tmp_header = 0;\r\nif (!data)\r\nreturn false;\r\nif (offset > EFUSE_MAX_SECTION_88E)\r\nreturn false;\r\nmemset(data, 0xff, sizeof(u8) * PGPKT_DATA_SIZE);\r\nmemset(tmpdata, 0xff, sizeof(u8) * PGPKT_DATA_SIZE);\r\nwhile (bContinual && AVAILABLE_EFUSE_ADDR(efuse_addr)) {\r\nif (ReadState & PG_STATE_HEADER) {\r\nif (efuse_OneByteRead(pAdapter, efuse_addr, &efuse_data) && (efuse_data != 0xFF)) {\r\nif (EXT_HEADER(efuse_data)) {\r\ntmp_header = efuse_data;\r\nefuse_addr++;\r\nefuse_OneByteRead(pAdapter, efuse_addr, &efuse_data);\r\nif (!ALL_WORDS_DISABLED(efuse_data)) {\r\nhoffset = ((tmp_header & 0xE0) >> 5) | ((efuse_data & 0xF0) >> 1);\r\nhworden = efuse_data & 0x0F;\r\n} else {\r\nDBG_88E("Error, All words disabled\n");\r\nefuse_addr++;\r\ncontinue;\r\n}\r\n} else {\r\nhoffset = (efuse_data>>4) & 0x0F;\r\nhworden = efuse_data & 0x0F;\r\n}\r\nword_cnts = Efuse_CalculateWordCnts(hworden);\r\nbDataEmpty = true;\r\nif (hoffset == offset) {\r\nfor (tmpidx = 0; tmpidx < word_cnts*2; tmpidx++) {\r\nif (efuse_OneByteRead(pAdapter, efuse_addr+1+tmpidx, &efuse_data)) {\r\ntmpdata[tmpidx] = efuse_data;\r\nif (efuse_data != 0xff)\r\nbDataEmpty = false;\r\n}\r\n}\r\nif (bDataEmpty == false) {\r\nReadState = PG_STATE_DATA;\r\n} else {\r\nefuse_addr = efuse_addr + (word_cnts*2)+1;\r\nReadState = PG_STATE_HEADER;\r\n}\r\n} else {\r\nefuse_addr = efuse_addr + (word_cnts*2)+1;\r\nReadState = PG_STATE_HEADER;\r\n}\r\n} else {\r\nbContinual = false;\r\n}\r\n} else if (ReadState & PG_STATE_DATA) {\r\nefuse_WordEnableDataRead(hworden, tmpdata, data);\r\nefuse_addr = efuse_addr + (word_cnts*2)+1;\r\nReadState = PG_STATE_HEADER;\r\n}\r\n}\r\nif ((data[0] == 0xff) && (data[1] == 0xff) && (data[2] == 0xff) && (data[3] == 0xff) &&\r\n(data[4] == 0xff) && (data[5] == 0xff) && (data[6] == 0xff) && (data[7] == 0xff))\r\nreturn false;\r\nelse\r\nreturn true;\r\n}\r\nstatic bool hal_EfuseFixHeaderProcess(struct adapter *pAdapter, u8 efuseType, struct pgpkt *pFixPkt, u16 *pAddr)\r\n{\r\nu8 originaldata[8], badworden = 0;\r\nu16 efuse_addr = *pAddr;\r\nu32 PgWriteSuccess = 0;\r\nmemset(originaldata, 0xff, 8);\r\nif (Efuse_PgPacketRead(pAdapter, pFixPkt->offset, originaldata)) {\r\nbadworden = Efuse_WordEnableDataWrite(pAdapter, efuse_addr+1, pFixPkt->word_en, originaldata);\r\nif (badworden != 0xf) {\r\nPgWriteSuccess = Efuse_PgPacketWrite(pAdapter, pFixPkt->offset, badworden, originaldata);\r\nif (!PgWriteSuccess)\r\nreturn false;\r\nelse\r\nefuse_addr = Efuse_GetCurrentSize(pAdapter);\r\n} else {\r\nefuse_addr = efuse_addr + (pFixPkt->word_cnts*2) + 1;\r\n}\r\n} else {\r\nefuse_addr = efuse_addr + (pFixPkt->word_cnts*2) + 1;\r\n}\r\n*pAddr = efuse_addr;\r\nreturn true;\r\n}\r\nstatic bool hal_EfusePgPacketWrite2ByteHeader(struct adapter *pAdapter, u8 efuseType, u16 *pAddr, struct pgpkt *pTargetPkt)\r\n{\r\nbool bRet = false;\r\nu16 efuse_addr = *pAddr;\r\nu16 efuse_max_available_len =\r\nEFUSE_REAL_CONTENT_LEN_88E - EFUSE_OOB_PROTECT_BYTES_88E;\r\nu8 pg_header = 0, tmp_header = 0, pg_header_temp = 0;\r\nu8 repeatcnt = 0;\r\nwhile (efuse_addr < efuse_max_available_len) {\r\npg_header = ((pTargetPkt->offset & 0x07) << 5) | 0x0F;\r\nefuse_OneByteWrite(pAdapter, efuse_addr, pg_header);\r\nefuse_OneByteRead(pAdapter, efuse_addr, &tmp_header);\r\nwhile (tmp_header == 0xFF) {\r\nif (repeatcnt++ > EFUSE_REPEAT_THRESHOLD_)\r\nreturn false;\r\nefuse_OneByteWrite(pAdapter, efuse_addr, pg_header);\r\nefuse_OneByteRead(pAdapter, efuse_addr, &tmp_header);\r\n}\r\nif (tmp_header == pg_header) {\r\nefuse_addr++;\r\npg_header_temp = pg_header;\r\npg_header = ((pTargetPkt->offset & 0x78) << 1) | pTargetPkt->word_en;\r\nefuse_OneByteWrite(pAdapter, efuse_addr, pg_header);\r\nefuse_OneByteRead(pAdapter, efuse_addr, &tmp_header);\r\nwhile (tmp_header == 0xFF) {\r\nif (repeatcnt++ > EFUSE_REPEAT_THRESHOLD_)\r\nreturn false;\r\nefuse_OneByteWrite(pAdapter, efuse_addr, pg_header);\r\nefuse_OneByteRead(pAdapter, efuse_addr, &tmp_header);\r\n}\r\nif ((tmp_header & 0x0F) == 0x0F) {\r\nif (repeatcnt++ > EFUSE_REPEAT_THRESHOLD_)\r\nreturn false;\r\nefuse_addr++;\r\ncontinue;\r\n} else if (pg_header != tmp_header) {\r\nstruct pgpkt fixPkt;\r\nfixPkt.offset = ((pg_header_temp & 0xE0) >> 5) | ((tmp_header & 0xF0) >> 1);\r\nfixPkt.word_en = tmp_header & 0x0F;\r\nfixPkt.word_cnts = Efuse_CalculateWordCnts(fixPkt.word_en);\r\nif (!hal_EfuseFixHeaderProcess(pAdapter, efuseType, &fixPkt, &efuse_addr))\r\nreturn false;\r\n} else {\r\nbRet = true;\r\nbreak;\r\n}\r\n} else if ((tmp_header & 0x1F) == 0x0F) {\r\nefuse_addr += 2;\r\ncontinue;\r\n}\r\n}\r\n*pAddr = efuse_addr;\r\nreturn bRet;\r\n}\r\nstatic bool hal_EfusePgPacketWrite1ByteHeader(struct adapter *pAdapter, u8 efuseType, u16 *pAddr, struct pgpkt *pTargetPkt)\r\n{\r\nbool bRet = false;\r\nu8 pg_header = 0, tmp_header = 0;\r\nu16 efuse_addr = *pAddr;\r\nu8 repeatcnt = 0;\r\npg_header = ((pTargetPkt->offset << 4) & 0xf0) | pTargetPkt->word_en;\r\nefuse_OneByteWrite(pAdapter, efuse_addr, pg_header);\r\nefuse_OneByteRead(pAdapter, efuse_addr, &tmp_header);\r\nwhile (tmp_header == 0xFF) {\r\nif (repeatcnt++ > EFUSE_REPEAT_THRESHOLD_)\r\nreturn false;\r\nefuse_OneByteWrite(pAdapter, efuse_addr, pg_header);\r\nefuse_OneByteRead(pAdapter, efuse_addr, &tmp_header);\r\n}\r\nif (pg_header == tmp_header) {\r\nbRet = true;\r\n} else {\r\nstruct pgpkt fixPkt;\r\nfixPkt.offset = (tmp_header>>4) & 0x0F;\r\nfixPkt.word_en = tmp_header & 0x0F;\r\nfixPkt.word_cnts = Efuse_CalculateWordCnts(fixPkt.word_en);\r\nif (!hal_EfuseFixHeaderProcess(pAdapter, efuseType, &fixPkt, &efuse_addr))\r\nreturn false;\r\n}\r\n*pAddr = efuse_addr;\r\nreturn bRet;\r\n}\r\nstatic bool hal_EfusePgPacketWriteData(struct adapter *pAdapter, u8 efuseType, u16 *pAddr, struct pgpkt *pTargetPkt)\r\n{\r\nu16 efuse_addr = *pAddr;\r\nu8 badworden = 0;\r\nu32 PgWriteSuccess = 0;\r\nbadworden = 0x0f;\r\nbadworden = Efuse_WordEnableDataWrite(pAdapter, efuse_addr+1, pTargetPkt->word_en, pTargetPkt->data);\r\nif (badworden == 0x0F) {\r\nreturn true;\r\n}\r\nPgWriteSuccess = Efuse_PgPacketWrite(pAdapter, pTargetPkt->offset, badworden, pTargetPkt->data);\r\nif (!PgWriteSuccess)\r\nreturn false;\r\nelse\r\nreturn true;\r\n}\r\nstatic bool\r\nhal_EfusePgPacketWriteHeader(\r\nstruct adapter *pAdapter,\r\nu8 efuseType,\r\nu16 *pAddr,\r\nstruct pgpkt *pTargetPkt)\r\n{\r\nbool bRet = false;\r\nif (pTargetPkt->offset >= EFUSE_MAX_SECTION_BASE)\r\nbRet = hal_EfusePgPacketWrite2ByteHeader(pAdapter, efuseType, pAddr, pTargetPkt);\r\nelse\r\nbRet = hal_EfusePgPacketWrite1ByteHeader(pAdapter, efuseType, pAddr, pTargetPkt);\r\nreturn bRet;\r\n}\r\nstatic bool wordEnMatched(struct pgpkt *pTargetPkt, struct pgpkt *pCurPkt,\r\nu8 *pWden)\r\n{\r\nu8 match_word_en = 0x0F;\r\nif (((pTargetPkt->word_en & BIT(0)) == 0) &&\r\n((pCurPkt->word_en & BIT(0)) == 0))\r\nmatch_word_en &= ~BIT(0);\r\nif (((pTargetPkt->word_en & BIT(1)) == 0) &&\r\n((pCurPkt->word_en & BIT(1)) == 0))\r\nmatch_word_en &= ~BIT(1);\r\nif (((pTargetPkt->word_en & BIT(2)) == 0) &&\r\n((pCurPkt->word_en & BIT(2)) == 0))\r\nmatch_word_en &= ~BIT(2);\r\nif (((pTargetPkt->word_en & BIT(3)) == 0) &&\r\n((pCurPkt->word_en & BIT(3)) == 0))\r\nmatch_word_en &= ~BIT(3);\r\n*pWden = match_word_en;\r\nif (match_word_en != 0xf)\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic bool hal_EfuseCheckIfDatafollowed(struct adapter *pAdapter, u8 word_cnts, u16 startAddr)\r\n{\r\nbool bRet = false;\r\nu8 i, efuse_data;\r\nfor (i = 0; i < (word_cnts*2); i++) {\r\nif (efuse_OneByteRead(pAdapter, (startAddr+i), &efuse_data) && (efuse_data != 0xFF))\r\nbRet = true;\r\n}\r\nreturn bRet;\r\n}\r\nstatic bool hal_EfusePartialWriteCheck(struct adapter *pAdapter, u8 efuseType, u16 *pAddr, struct pgpkt *pTargetPkt)\r\n{\r\nbool bRet = false;\r\nu8 i, efuse_data = 0, cur_header = 0;\r\nu8 matched_wden = 0, badworden = 0;\r\nu16 startAddr = 0;\r\nu16 efuse_max_available_len =\r\nEFUSE_REAL_CONTENT_LEN_88E - EFUSE_OOB_PROTECT_BYTES_88E;\r\nstruct pgpkt curPkt;\r\nrtw_hal_get_hwreg(pAdapter, HW_VAR_EFUSE_BYTES, (u8 *)&startAddr);\r\nstartAddr %= EFUSE_REAL_CONTENT_LEN;\r\nwhile (1) {\r\nif (startAddr >= efuse_max_available_len) {\r\nbRet = false;\r\nbreak;\r\n}\r\nif (efuse_OneByteRead(pAdapter, startAddr, &efuse_data) && (efuse_data != 0xFF)) {\r\nif (EXT_HEADER(efuse_data)) {\r\ncur_header = efuse_data;\r\nstartAddr++;\r\nefuse_OneByteRead(pAdapter, startAddr, &efuse_data);\r\nif (ALL_WORDS_DISABLED(efuse_data)) {\r\nbRet = false;\r\nbreak;\r\n} else {\r\ncurPkt.offset = ((cur_header & 0xE0) >> 5) | ((efuse_data & 0xF0) >> 1);\r\ncurPkt.word_en = efuse_data & 0x0F;\r\n}\r\n} else {\r\ncur_header = efuse_data;\r\ncurPkt.offset = (cur_header>>4) & 0x0F;\r\ncurPkt.word_en = cur_header & 0x0F;\r\n}\r\ncurPkt.word_cnts = Efuse_CalculateWordCnts(curPkt.word_en);\r\nif ((curPkt.offset == pTargetPkt->offset) &&\r\n(!hal_EfuseCheckIfDatafollowed(pAdapter, curPkt.word_cnts, startAddr+1)) &&\r\nwordEnMatched(pTargetPkt, &curPkt, &matched_wden)) {\r\nbadworden = Efuse_WordEnableDataWrite(pAdapter, startAddr+1, matched_wden, pTargetPkt->data);\r\nif (badworden != 0x0F) {\r\nu32 PgWriteSuccess = 0;\r\nPgWriteSuccess = Efuse_PgPacketWrite(pAdapter, pTargetPkt->offset, badworden, pTargetPkt->data);\r\nif (!PgWriteSuccess) {\r\nbRet = false;\r\nbreak;\r\n}\r\n}\r\nfor (i = 0; i < 4; i++) {\r\nif ((matched_wden & (0x1<<i)) == 0)\r\npTargetPkt->word_en |= (0x1<<i);\r\n}\r\npTargetPkt->word_cnts = Efuse_CalculateWordCnts(pTargetPkt->word_en);\r\n}\r\nstartAddr = startAddr + (curPkt.word_cnts*2) + 1;\r\n} else {\r\n*pAddr = startAddr;\r\nbRet = true;\r\nbreak;\r\n}\r\n}\r\nreturn bRet;\r\n}\r\nstatic bool\r\nhal_EfusePgCheckAvailableAddr(\r\nstruct adapter *pAdapter,\r\nu8 efuseType\r\n)\r\n{\r\nif (Efuse_GetCurrentSize(pAdapter) >= EFUSE_MAP_LEN_88E)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic void hal_EfuseConstructPGPkt(u8 offset, u8 word_en, u8 *pData, struct pgpkt *pTargetPkt)\r\n{\r\nmemset((void *)pTargetPkt->data, 0xFF, sizeof(u8)*8);\r\npTargetPkt->offset = offset;\r\npTargetPkt->word_en = word_en;\r\nefuse_WordEnableDataRead(word_en, pData, pTargetPkt->data);\r\npTargetPkt->word_cnts = Efuse_CalculateWordCnts(pTargetPkt->word_en);\r\n}\r\nbool Efuse_PgPacketWrite(struct adapter *pAdapter, u8 offset, u8 word_en, u8 *pData)\r\n{\r\nstruct pgpkt targetPkt;\r\nu16 startAddr = 0;\r\nu8 efuseType = EFUSE_WIFI;\r\nif (!hal_EfusePgCheckAvailableAddr(pAdapter, efuseType))\r\nreturn false;\r\nhal_EfuseConstructPGPkt(offset, word_en, pData, &targetPkt);\r\nif (!hal_EfusePartialWriteCheck(pAdapter, efuseType, &startAddr, &targetPkt))\r\nreturn false;\r\nif (!hal_EfusePgPacketWriteHeader(pAdapter, efuseType, &startAddr, &targetPkt))\r\nreturn false;\r\nif (!hal_EfusePgPacketWriteData(pAdapter, efuseType, &startAddr, &targetPkt))\r\nreturn false;\r\nreturn true;\r\n}\r\nu8 Efuse_CalculateWordCnts(u8 word_en)\r\n{\r\nu8 word_cnts = 0;\r\nif (!(word_en & BIT(0)))\r\nword_cnts++;\r\nif (!(word_en & BIT(1)))\r\nword_cnts++;\r\nif (!(word_en & BIT(2)))\r\nword_cnts++;\r\nif (!(word_en & BIT(3)))\r\nword_cnts++;\r\nreturn word_cnts;\r\n}\r\nu8 efuse_OneByteRead(struct adapter *pAdapter, u16 addr, u8 *data)\r\n{\r\nu8 tmpidx = 0;\r\nu8 result;\r\nusb_write8(pAdapter, EFUSE_CTRL+1, (u8)(addr & 0xff));\r\nusb_write8(pAdapter, EFUSE_CTRL+2, ((u8)((addr>>8) & 0x03)) |\r\n(usb_read8(pAdapter, EFUSE_CTRL+2) & 0xFC));\r\nusb_write8(pAdapter, EFUSE_CTRL+3, 0x72);\r\nwhile (!(0x80 & usb_read8(pAdapter, EFUSE_CTRL+3)) && (tmpidx < 100))\r\ntmpidx++;\r\nif (tmpidx < 100) {\r\n*data = usb_read8(pAdapter, EFUSE_CTRL);\r\nresult = true;\r\n} else {\r\n*data = 0xff;\r\nresult = false;\r\n}\r\nreturn result;\r\n}\r\nu8 efuse_OneByteWrite(struct adapter *pAdapter, u16 addr, u8 data)\r\n{\r\nu8 tmpidx = 0;\r\nu8 result;\r\nusb_write8(pAdapter, EFUSE_CTRL+1, (u8)(addr&0xff));\r\nusb_write8(pAdapter, EFUSE_CTRL+2,\r\n(usb_read8(pAdapter, EFUSE_CTRL+2) & 0xFC) |\r\n(u8)((addr>>8) & 0x03));\r\nusb_write8(pAdapter, EFUSE_CTRL, data);\r\nusb_write8(pAdapter, EFUSE_CTRL+3, 0xF2);\r\nwhile ((0x80 & usb_read8(pAdapter, EFUSE_CTRL+3)) && (tmpidx < 100))\r\ntmpidx++;\r\nif (tmpidx < 100)\r\nresult = true;\r\nelse\r\nresult = false;\r\nreturn result;\r\n}\r\nvoid efuse_WordEnableDataRead(u8 word_en, u8 *sourdata, u8 *targetdata)\r\n{\r\nif (!(word_en & BIT(0))) {\r\ntargetdata[0] = sourdata[0];\r\ntargetdata[1] = sourdata[1];\r\n}\r\nif (!(word_en & BIT(1))) {\r\ntargetdata[2] = sourdata[2];\r\ntargetdata[3] = sourdata[3];\r\n}\r\nif (!(word_en & BIT(2))) {\r\ntargetdata[4] = sourdata[4];\r\ntargetdata[5] = sourdata[5];\r\n}\r\nif (!(word_en & BIT(3))) {\r\ntargetdata[6] = sourdata[6];\r\ntargetdata[7] = sourdata[7];\r\n}\r\n}\r\nstatic void Efuse_ReadAllMap(struct adapter *pAdapter, u8 efuseType, u8 *Efuse)\r\n{\r\nEfuse_PowerSwitch(pAdapter, false, true);\r\nefuse_ReadEFuse(pAdapter, efuseType, 0, EFUSE_MAP_LEN_88E, Efuse);\r\nEfuse_PowerSwitch(pAdapter, false, false);\r\n}\r\nvoid EFUSE_ShadowMapUpdate(\r\nstruct adapter *pAdapter,\r\nu8 efuseType)\r\n{\r\nstruct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(pAdapter);\r\nif (pEEPROM->bautoload_fail_flag)\r\nmemset(pEEPROM->efuse_eeprom_data, 0xFF, EFUSE_MAP_LEN_88E);\r\nelse\r\nEfuse_ReadAllMap(pAdapter, efuseType, pEEPROM->efuse_eeprom_data);\r\n}
