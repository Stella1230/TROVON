int crush_find_rule(const struct crush_map *map, int ruleset, int type, int size)\r\n{\r\n__u32 i;\r\nfor (i = 0; i < map->max_rules; i++) {\r\nif (map->rules[i] &&\r\nmap->rules[i]->mask.ruleset == ruleset &&\r\nmap->rules[i]->mask.type == type &&\r\nmap->rules[i]->mask.min_size <= size &&\r\nmap->rules[i]->mask.max_size >= size)\r\nreturn i;\r\n}\r\nreturn -1;\r\n}\r\nstatic int bucket_perm_choose(const struct crush_bucket *bucket,\r\nstruct crush_work_bucket *work,\r\nint x, int r)\r\n{\r\nunsigned int pr = r % bucket->size;\r\nunsigned int i, s;\r\nif (work->perm_x != (__u32)x || work->perm_n == 0) {\r\ndprintk("bucket %d new x=%d\n", bucket->id, x);\r\nwork->perm_x = x;\r\nif (pr == 0) {\r\ns = crush_hash32_3(bucket->hash, x, bucket->id, 0) %\r\nbucket->size;\r\nwork->perm[0] = s;\r\nwork->perm_n = 0xffff;\r\ngoto out;\r\n}\r\nfor (i = 0; i < bucket->size; i++)\r\nwork->perm[i] = i;\r\nwork->perm_n = 0;\r\n} else if (work->perm_n == 0xffff) {\r\nfor (i = 1; i < bucket->size; i++)\r\nwork->perm[i] = i;\r\nwork->perm[work->perm[0]] = 0;\r\nwork->perm_n = 1;\r\n}\r\nfor (i = 0; i < work->perm_n; i++)\r\ndprintk(" perm_choose have %d: %d\n", i, work->perm[i]);\r\nwhile (work->perm_n <= pr) {\r\nunsigned int p = work->perm_n;\r\nif (p < bucket->size - 1) {\r\ni = crush_hash32_3(bucket->hash, x, bucket->id, p) %\r\n(bucket->size - p);\r\nif (i) {\r\nunsigned int t = work->perm[p + i];\r\nwork->perm[p + i] = work->perm[p];\r\nwork->perm[p] = t;\r\n}\r\ndprintk(" perm_choose swap %d with %d\n", p, p+i);\r\n}\r\nwork->perm_n++;\r\n}\r\nfor (i = 0; i < bucket->size; i++)\r\ndprintk(" perm_choose %d: %d\n", i, work->perm[i]);\r\ns = work->perm[pr];\r\nout:\r\ndprintk(" perm_choose %d sz=%d x=%d r=%d (%d) s=%d\n", bucket->id,\r\nbucket->size, x, r, pr, s);\r\nreturn bucket->items[s];\r\n}\r\nstatic int bucket_uniform_choose(const struct crush_bucket_uniform *bucket,\r\nstruct crush_work_bucket *work, int x, int r)\r\n{\r\nreturn bucket_perm_choose(&bucket->h, work, x, r);\r\n}\r\nstatic int bucket_list_choose(const struct crush_bucket_list *bucket,\r\nint x, int r)\r\n{\r\nint i;\r\nfor (i = bucket->h.size-1; i >= 0; i--) {\r\n__u64 w = crush_hash32_4(bucket->h.hash, x, bucket->h.items[i],\r\nr, bucket->h.id);\r\nw &= 0xffff;\r\ndprintk("list_choose i=%d x=%d r=%d item %d weight %x "\r\n"sw %x rand %llx",\r\ni, x, r, bucket->h.items[i], bucket->item_weights[i],\r\nbucket->sum_weights[i], w);\r\nw *= bucket->sum_weights[i];\r\nw = w >> 16;\r\nif (w < bucket->item_weights[i]) {\r\nreturn bucket->h.items[i];\r\n}\r\n}\r\ndprintk("bad list sums for bucket %d\n", bucket->h.id);\r\nreturn bucket->h.items[0];\r\n}\r\nstatic int height(int n)\r\n{\r\nint h = 0;\r\nwhile ((n & 1) == 0) {\r\nh++;\r\nn = n >> 1;\r\n}\r\nreturn h;\r\n}\r\nstatic int left(int x)\r\n{\r\nint h = height(x);\r\nreturn x - (1 << (h-1));\r\n}\r\nstatic int right(int x)\r\n{\r\nint h = height(x);\r\nreturn x + (1 << (h-1));\r\n}\r\nstatic int terminal(int x)\r\n{\r\nreturn x & 1;\r\n}\r\nstatic int bucket_tree_choose(const struct crush_bucket_tree *bucket,\r\nint x, int r)\r\n{\r\nint n;\r\n__u32 w;\r\n__u64 t;\r\nn = bucket->num_nodes >> 1;\r\nwhile (!terminal(n)) {\r\nint l;\r\nw = bucket->node_weights[n];\r\nt = (__u64)crush_hash32_4(bucket->h.hash, x, n, r,\r\nbucket->h.id) * (__u64)w;\r\nt = t >> 32;\r\nl = left(n);\r\nif (t < bucket->node_weights[l])\r\nn = l;\r\nelse\r\nn = right(n);\r\n}\r\nreturn bucket->h.items[n >> 1];\r\n}\r\nstatic int bucket_straw_choose(const struct crush_bucket_straw *bucket,\r\nint x, int r)\r\n{\r\n__u32 i;\r\nint high = 0;\r\n__u64 high_draw = 0;\r\n__u64 draw;\r\nfor (i = 0; i < bucket->h.size; i++) {\r\ndraw = crush_hash32_3(bucket->h.hash, x, bucket->h.items[i], r);\r\ndraw &= 0xffff;\r\ndraw *= bucket->straws[i];\r\nif (i == 0 || draw > high_draw) {\r\nhigh = i;\r\nhigh_draw = draw;\r\n}\r\n}\r\nreturn bucket->h.items[high];\r\n}\r\nstatic __u64 crush_ln(unsigned int xin)\r\n{\r\nunsigned int x = xin;\r\nint iexpon, index1, index2;\r\n__u64 RH, LH, LL, xl64, result;\r\nx++;\r\niexpon = 15;\r\nif (!(x & 0x18000)) {\r\nint bits = __builtin_clz(x & 0x1FFFF) - 16;\r\nx <<= bits;\r\niexpon = 15 - bits;\r\n}\r\nindex1 = (x >> 8) << 1;\r\nRH = __RH_LH_tbl[index1 - 256];\r\nLH = __RH_LH_tbl[index1 + 1 - 256];\r\nxl64 = (__s64)x * RH;\r\nxl64 >>= 48;\r\nresult = iexpon;\r\nresult <<= (12 + 32);\r\nindex2 = xl64 & 0xff;\r\nLL = __LL_tbl[index2];\r\nLH = LH + LL;\r\nLH >>= (48 - 12 - 32);\r\nresult += LH;\r\nreturn result;\r\n}\r\nstatic __u32 *get_choose_arg_weights(const struct crush_bucket_straw2 *bucket,\r\nconst struct crush_choose_arg *arg,\r\nint position)\r\n{\r\nif (!arg || !arg->weight_set)\r\nreturn bucket->item_weights;\r\nif (position >= arg->weight_set_size)\r\nposition = arg->weight_set_size - 1;\r\nreturn arg->weight_set[position].weights;\r\n}\r\nstatic __s32 *get_choose_arg_ids(const struct crush_bucket_straw2 *bucket,\r\nconst struct crush_choose_arg *arg)\r\n{\r\nif (!arg || !arg->ids)\r\nreturn bucket->h.items;\r\nreturn arg->ids;\r\n}\r\nstatic int bucket_straw2_choose(const struct crush_bucket_straw2 *bucket,\r\nint x, int r,\r\nconst struct crush_choose_arg *arg,\r\nint position)\r\n{\r\nunsigned int i, high = 0;\r\nunsigned int u;\r\n__s64 ln, draw, high_draw = 0;\r\n__u32 *weights = get_choose_arg_weights(bucket, arg, position);\r\n__s32 *ids = get_choose_arg_ids(bucket, arg);\r\nfor (i = 0; i < bucket->h.size; i++) {\r\ndprintk("weight 0x%x item %d\n", weights[i], ids[i]);\r\nif (weights[i]) {\r\nu = crush_hash32_3(bucket->h.hash, x, ids[i], r);\r\nu &= 0xffff;\r\nln = crush_ln(u) - 0x1000000000000ll;\r\ndraw = div64_s64(ln, weights[i]);\r\n} else {\r\ndraw = S64_MIN;\r\n}\r\nif (i == 0 || draw > high_draw) {\r\nhigh = i;\r\nhigh_draw = draw;\r\n}\r\n}\r\nreturn bucket->h.items[high];\r\n}\r\nstatic int crush_bucket_choose(const struct crush_bucket *in,\r\nstruct crush_work_bucket *work,\r\nint x, int r,\r\nconst struct crush_choose_arg *arg,\r\nint position)\r\n{\r\ndprintk(" crush_bucket_choose %d x=%d r=%d\n", in->id, x, r);\r\nBUG_ON(in->size == 0);\r\nswitch (in->alg) {\r\ncase CRUSH_BUCKET_UNIFORM:\r\nreturn bucket_uniform_choose(\r\n(const struct crush_bucket_uniform *)in,\r\nwork, x, r);\r\ncase CRUSH_BUCKET_LIST:\r\nreturn bucket_list_choose((const struct crush_bucket_list *)in,\r\nx, r);\r\ncase CRUSH_BUCKET_TREE:\r\nreturn bucket_tree_choose((const struct crush_bucket_tree *)in,\r\nx, r);\r\ncase CRUSH_BUCKET_STRAW:\r\nreturn bucket_straw_choose(\r\n(const struct crush_bucket_straw *)in,\r\nx, r);\r\ncase CRUSH_BUCKET_STRAW2:\r\nreturn bucket_straw2_choose(\r\n(const struct crush_bucket_straw2 *)in,\r\nx, r, arg, position);\r\ndefault:\r\ndprintk("unknown bucket %d alg %d\n", in->id, in->alg);\r\nreturn in->items[0];\r\n}\r\n}\r\nstatic int is_out(const struct crush_map *map,\r\nconst __u32 *weight, int weight_max,\r\nint item, int x)\r\n{\r\nif (item >= weight_max)\r\nreturn 1;\r\nif (weight[item] >= 0x10000)\r\nreturn 0;\r\nif (weight[item] == 0)\r\nreturn 1;\r\nif ((crush_hash32_2(CRUSH_HASH_RJENKINS1, x, item) & 0xffff)\r\n< weight[item])\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int crush_choose_firstn(const struct crush_map *map,\r\nstruct crush_work *work,\r\nconst struct crush_bucket *bucket,\r\nconst __u32 *weight, int weight_max,\r\nint x, int numrep, int type,\r\nint *out, int outpos,\r\nint out_size,\r\nunsigned int tries,\r\nunsigned int recurse_tries,\r\nunsigned int local_retries,\r\nunsigned int local_fallback_retries,\r\nint recurse_to_leaf,\r\nunsigned int vary_r,\r\nunsigned int stable,\r\nint *out2,\r\nint parent_r,\r\nconst struct crush_choose_arg *choose_args)\r\n{\r\nint rep;\r\nunsigned int ftotal, flocal;\r\nint retry_descent, retry_bucket, skip_rep;\r\nconst struct crush_bucket *in = bucket;\r\nint r;\r\nint i;\r\nint item = 0;\r\nint itemtype;\r\nint collide, reject;\r\nint count = out_size;\r\ndprintk("CHOOSE%s bucket %d x %d outpos %d numrep %d tries %d recurse_tries %d local_retries %d local_fallback_retries %d parent_r %d stable %d\n",\r\nrecurse_to_leaf ? "_LEAF" : "",\r\nbucket->id, x, outpos, numrep,\r\ntries, recurse_tries, local_retries, local_fallback_retries,\r\nparent_r, stable);\r\nfor (rep = stable ? 0 : outpos; rep < numrep && count > 0 ; rep++) {\r\nftotal = 0;\r\nskip_rep = 0;\r\ndo {\r\nretry_descent = 0;\r\nin = bucket;\r\nflocal = 0;\r\ndo {\r\ncollide = 0;\r\nretry_bucket = 0;\r\nr = rep + parent_r;\r\nr += ftotal;\r\nif (in->size == 0) {\r\nreject = 1;\r\ngoto reject;\r\n}\r\nif (local_fallback_retries > 0 &&\r\nflocal >= (in->size>>1) &&\r\nflocal > local_fallback_retries)\r\nitem = bucket_perm_choose(\r\nin, work->work[-1-in->id],\r\nx, r);\r\nelse\r\nitem = crush_bucket_choose(\r\nin, work->work[-1-in->id],\r\nx, r,\r\n(choose_args ?\r\n&choose_args[-1-in->id] : 0),\r\noutpos);\r\nif (item >= map->max_devices) {\r\ndprintk(" bad item %d\n", item);\r\nskip_rep = 1;\r\nbreak;\r\n}\r\nif (item < 0)\r\nitemtype = map->buckets[-1-item]->type;\r\nelse\r\nitemtype = 0;\r\ndprintk(" item %d type %d\n", item, itemtype);\r\nif (itemtype != type) {\r\nif (item >= 0 ||\r\n(-1-item) >= map->max_buckets) {\r\ndprintk(" bad item type %d\n", type);\r\nskip_rep = 1;\r\nbreak;\r\n}\r\nin = map->buckets[-1-item];\r\nretry_bucket = 1;\r\ncontinue;\r\n}\r\nfor (i = 0; i < outpos; i++) {\r\nif (out[i] == item) {\r\ncollide = 1;\r\nbreak;\r\n}\r\n}\r\nreject = 0;\r\nif (!collide && recurse_to_leaf) {\r\nif (item < 0) {\r\nint sub_r;\r\nif (vary_r)\r\nsub_r = r >> (vary_r-1);\r\nelse\r\nsub_r = 0;\r\nif (crush_choose_firstn(\r\nmap,\r\nwork,\r\nmap->buckets[-1-item],\r\nweight, weight_max,\r\nx, stable ? 1 : outpos+1, 0,\r\nout2, outpos, count,\r\nrecurse_tries, 0,\r\nlocal_retries,\r\nlocal_fallback_retries,\r\n0,\r\nvary_r,\r\nstable,\r\nNULL,\r\nsub_r,\r\nchoose_args) <= outpos)\r\nreject = 1;\r\n} else {\r\nout2[outpos] = item;\r\n}\r\n}\r\nif (!reject && !collide) {\r\nif (itemtype == 0)\r\nreject = is_out(map, weight,\r\nweight_max,\r\nitem, x);\r\n}\r\nreject:\r\nif (reject || collide) {\r\nftotal++;\r\nflocal++;\r\nif (collide && flocal <= local_retries)\r\nretry_bucket = 1;\r\nelse if (local_fallback_retries > 0 &&\r\nflocal <= in->size + local_fallback_retries)\r\nretry_bucket = 1;\r\nelse if (ftotal < tries)\r\nretry_descent = 1;\r\nelse\r\nskip_rep = 1;\r\ndprintk(" reject %d collide %d "\r\n"ftotal %u flocal %u\n",\r\nreject, collide, ftotal,\r\nflocal);\r\n}\r\n} while (retry_bucket);\r\n} while (retry_descent);\r\nif (skip_rep) {\r\ndprintk("skip rep\n");\r\ncontinue;\r\n}\r\ndprintk("CHOOSE got %d\n", item);\r\nout[outpos] = item;\r\noutpos++;\r\ncount--;\r\n#ifndef __KERNEL__\r\nif (map->choose_tries && ftotal <= map->choose_total_tries)\r\nmap->choose_tries[ftotal]++;\r\n#endif\r\n}\r\ndprintk("CHOOSE returns %d\n", outpos);\r\nreturn outpos;\r\n}\r\nstatic void crush_choose_indep(const struct crush_map *map,\r\nstruct crush_work *work,\r\nconst struct crush_bucket *bucket,\r\nconst __u32 *weight, int weight_max,\r\nint x, int left, int numrep, int type,\r\nint *out, int outpos,\r\nunsigned int tries,\r\nunsigned int recurse_tries,\r\nint recurse_to_leaf,\r\nint *out2,\r\nint parent_r,\r\nconst struct crush_choose_arg *choose_args)\r\n{\r\nconst struct crush_bucket *in = bucket;\r\nint endpos = outpos + left;\r\nint rep;\r\nunsigned int ftotal;\r\nint r;\r\nint i;\r\nint item = 0;\r\nint itemtype;\r\nint collide;\r\ndprintk("CHOOSE%s INDEP bucket %d x %d outpos %d numrep %d\n", recurse_to_leaf ? "_LEAF" : "",\r\nbucket->id, x, outpos, numrep);\r\nfor (rep = outpos; rep < endpos; rep++) {\r\nout[rep] = CRUSH_ITEM_UNDEF;\r\nif (out2)\r\nout2[rep] = CRUSH_ITEM_UNDEF;\r\n}\r\nfor (ftotal = 0; left > 0 && ftotal < tries; ftotal++) {\r\n#ifdef DEBUG_INDEP\r\nif (out2 && ftotal) {\r\ndprintk("%u %d a: ", ftotal, left);\r\nfor (rep = outpos; rep < endpos; rep++) {\r\ndprintk(" %d", out[rep]);\r\n}\r\ndprintk("\n");\r\ndprintk("%u %d b: ", ftotal, left);\r\nfor (rep = outpos; rep < endpos; rep++) {\r\ndprintk(" %d", out2[rep]);\r\n}\r\ndprintk("\n");\r\n}\r\n#endif\r\nfor (rep = outpos; rep < endpos; rep++) {\r\nif (out[rep] != CRUSH_ITEM_UNDEF)\r\ncontinue;\r\nin = bucket;\r\nfor (;;) {\r\nr = rep + parent_r;\r\nif (in->alg == CRUSH_BUCKET_UNIFORM &&\r\nin->size % numrep == 0)\r\nr += (numrep+1) * ftotal;\r\nelse\r\nr += numrep * ftotal;\r\nif (in->size == 0) {\r\ndprintk(" empty bucket\n");\r\nbreak;\r\n}\r\nitem = crush_bucket_choose(\r\nin, work->work[-1-in->id],\r\nx, r,\r\n(choose_args ?\r\n&choose_args[-1-in->id] : 0),\r\noutpos);\r\nif (item >= map->max_devices) {\r\ndprintk(" bad item %d\n", item);\r\nout[rep] = CRUSH_ITEM_NONE;\r\nif (out2)\r\nout2[rep] = CRUSH_ITEM_NONE;\r\nleft--;\r\nbreak;\r\n}\r\nif (item < 0)\r\nitemtype = map->buckets[-1-item]->type;\r\nelse\r\nitemtype = 0;\r\ndprintk(" item %d type %d\n", item, itemtype);\r\nif (itemtype != type) {\r\nif (item >= 0 ||\r\n(-1-item) >= map->max_buckets) {\r\ndprintk(" bad item type %d\n", type);\r\nout[rep] = CRUSH_ITEM_NONE;\r\nif (out2)\r\nout2[rep] =\r\nCRUSH_ITEM_NONE;\r\nleft--;\r\nbreak;\r\n}\r\nin = map->buckets[-1-item];\r\ncontinue;\r\n}\r\ncollide = 0;\r\nfor (i = outpos; i < endpos; i++) {\r\nif (out[i] == item) {\r\ncollide = 1;\r\nbreak;\r\n}\r\n}\r\nif (collide)\r\nbreak;\r\nif (recurse_to_leaf) {\r\nif (item < 0) {\r\ncrush_choose_indep(\r\nmap,\r\nwork,\r\nmap->buckets[-1-item],\r\nweight, weight_max,\r\nx, 1, numrep, 0,\r\nout2, rep,\r\nrecurse_tries, 0,\r\n0, NULL, r,\r\nchoose_args);\r\nif (out2[rep] == CRUSH_ITEM_NONE) {\r\nbreak;\r\n}\r\n} else {\r\nout2[rep] = item;\r\n}\r\n}\r\nif (itemtype == 0 &&\r\nis_out(map, weight, weight_max, item, x))\r\nbreak;\r\nout[rep] = item;\r\nleft--;\r\nbreak;\r\n}\r\n}\r\n}\r\nfor (rep = outpos; rep < endpos; rep++) {\r\nif (out[rep] == CRUSH_ITEM_UNDEF) {\r\nout[rep] = CRUSH_ITEM_NONE;\r\n}\r\nif (out2 && out2[rep] == CRUSH_ITEM_UNDEF) {\r\nout2[rep] = CRUSH_ITEM_NONE;\r\n}\r\n}\r\n#ifndef __KERNEL__\r\nif (map->choose_tries && ftotal <= map->choose_total_tries)\r\nmap->choose_tries[ftotal]++;\r\n#endif\r\n#ifdef DEBUG_INDEP\r\nif (out2) {\r\ndprintk("%u %d a: ", ftotal, left);\r\nfor (rep = outpos; rep < endpos; rep++) {\r\ndprintk(" %d", out[rep]);\r\n}\r\ndprintk("\n");\r\ndprintk("%u %d b: ", ftotal, left);\r\nfor (rep = outpos; rep < endpos; rep++) {\r\ndprintk(" %d", out2[rep]);\r\n}\r\ndprintk("\n");\r\n}\r\n#endif\r\n}\r\nvoid crush_init_workspace(const struct crush_map *map, void *v)\r\n{\r\nstruct crush_work *w = v;\r\n__s32 b;\r\nv += sizeof(struct crush_work);\r\nw->work = v;\r\nv += map->max_buckets * sizeof(struct crush_work_bucket *);\r\nfor (b = 0; b < map->max_buckets; ++b) {\r\nif (!map->buckets[b])\r\ncontinue;\r\nw->work[b] = v;\r\nswitch (map->buckets[b]->alg) {\r\ndefault:\r\nv += sizeof(struct crush_work_bucket);\r\nbreak;\r\n}\r\nw->work[b]->perm_x = 0;\r\nw->work[b]->perm_n = 0;\r\nw->work[b]->perm = v;\r\nv += map->buckets[b]->size * sizeof(__u32);\r\n}\r\nBUG_ON(v - (void *)w != map->working_size);\r\n}\r\nint crush_do_rule(const struct crush_map *map,\r\nint ruleno, int x, int *result, int result_max,\r\nconst __u32 *weight, int weight_max,\r\nvoid *cwin, const struct crush_choose_arg *choose_args)\r\n{\r\nint result_len;\r\nstruct crush_work *cw = cwin;\r\nint *a = cwin + map->working_size;\r\nint *b = a + result_max;\r\nint *c = b + result_max;\r\nint *w = a;\r\nint *o = b;\r\nint recurse_to_leaf;\r\nint wsize = 0;\r\nint osize;\r\nint *tmp;\r\nconst struct crush_rule *rule;\r\n__u32 step;\r\nint i, j;\r\nint numrep;\r\nint out_size;\r\nint choose_tries = map->choose_total_tries + 1;\r\nint choose_leaf_tries = 0;\r\nint choose_local_retries = map->choose_local_tries;\r\nint choose_local_fallback_retries = map->choose_local_fallback_tries;\r\nint vary_r = map->chooseleaf_vary_r;\r\nint stable = map->chooseleaf_stable;\r\nif ((__u32)ruleno >= map->max_rules) {\r\ndprintk(" bad ruleno %d\n", ruleno);\r\nreturn 0;\r\n}\r\nrule = map->rules[ruleno];\r\nresult_len = 0;\r\nfor (step = 0; step < rule->len; step++) {\r\nint firstn = 0;\r\nconst struct crush_rule_step *curstep = &rule->steps[step];\r\nswitch (curstep->op) {\r\ncase CRUSH_RULE_TAKE:\r\nif ((curstep->arg1 >= 0 &&\r\ncurstep->arg1 < map->max_devices) ||\r\n(-1-curstep->arg1 >= 0 &&\r\n-1-curstep->arg1 < map->max_buckets &&\r\nmap->buckets[-1-curstep->arg1])) {\r\nw[0] = curstep->arg1;\r\nwsize = 1;\r\n} else {\r\ndprintk(" bad take value %d\n", curstep->arg1);\r\n}\r\nbreak;\r\ncase CRUSH_RULE_SET_CHOOSE_TRIES:\r\nif (curstep->arg1 > 0)\r\nchoose_tries = curstep->arg1;\r\nbreak;\r\ncase CRUSH_RULE_SET_CHOOSELEAF_TRIES:\r\nif (curstep->arg1 > 0)\r\nchoose_leaf_tries = curstep->arg1;\r\nbreak;\r\ncase CRUSH_RULE_SET_CHOOSE_LOCAL_TRIES:\r\nif (curstep->arg1 >= 0)\r\nchoose_local_retries = curstep->arg1;\r\nbreak;\r\ncase CRUSH_RULE_SET_CHOOSE_LOCAL_FALLBACK_TRIES:\r\nif (curstep->arg1 >= 0)\r\nchoose_local_fallback_retries = curstep->arg1;\r\nbreak;\r\ncase CRUSH_RULE_SET_CHOOSELEAF_VARY_R:\r\nif (curstep->arg1 >= 0)\r\nvary_r = curstep->arg1;\r\nbreak;\r\ncase CRUSH_RULE_SET_CHOOSELEAF_STABLE:\r\nif (curstep->arg1 >= 0)\r\nstable = curstep->arg1;\r\nbreak;\r\ncase CRUSH_RULE_CHOOSELEAF_FIRSTN:\r\ncase CRUSH_RULE_CHOOSE_FIRSTN:\r\nfirstn = 1;\r\ncase CRUSH_RULE_CHOOSELEAF_INDEP:\r\ncase CRUSH_RULE_CHOOSE_INDEP:\r\nif (wsize == 0)\r\nbreak;\r\nrecurse_to_leaf =\r\ncurstep->op ==\r\nCRUSH_RULE_CHOOSELEAF_FIRSTN ||\r\ncurstep->op ==\r\nCRUSH_RULE_CHOOSELEAF_INDEP;\r\nosize = 0;\r\nfor (i = 0; i < wsize; i++) {\r\nint bno;\r\nnumrep = curstep->arg1;\r\nif (numrep <= 0) {\r\nnumrep += result_max;\r\nif (numrep <= 0)\r\ncontinue;\r\n}\r\nj = 0;\r\nbno = -1 - w[i];\r\nif (bno < 0 || bno >= map->max_buckets) {\r\ndprintk(" bad w[i] %d\n", w[i]);\r\ncontinue;\r\n}\r\nif (firstn) {\r\nint recurse_tries;\r\nif (choose_leaf_tries)\r\nrecurse_tries =\r\nchoose_leaf_tries;\r\nelse if (map->chooseleaf_descend_once)\r\nrecurse_tries = 1;\r\nelse\r\nrecurse_tries = choose_tries;\r\nosize += crush_choose_firstn(\r\nmap,\r\ncw,\r\nmap->buckets[bno],\r\nweight, weight_max,\r\nx, numrep,\r\ncurstep->arg2,\r\no+osize, j,\r\nresult_max-osize,\r\nchoose_tries,\r\nrecurse_tries,\r\nchoose_local_retries,\r\nchoose_local_fallback_retries,\r\nrecurse_to_leaf,\r\nvary_r,\r\nstable,\r\nc+osize,\r\n0,\r\nchoose_args);\r\n} else {\r\nout_size = ((numrep < (result_max-osize)) ?\r\nnumrep : (result_max-osize));\r\ncrush_choose_indep(\r\nmap,\r\ncw,\r\nmap->buckets[bno],\r\nweight, weight_max,\r\nx, out_size, numrep,\r\ncurstep->arg2,\r\no+osize, j,\r\nchoose_tries,\r\nchoose_leaf_tries ?\r\nchoose_leaf_tries : 1,\r\nrecurse_to_leaf,\r\nc+osize,\r\n0,\r\nchoose_args);\r\nosize += out_size;\r\n}\r\n}\r\nif (recurse_to_leaf)\r\nmemcpy(o, c, osize*sizeof(*o));\r\ntmp = o;\r\no = w;\r\nw = tmp;\r\nwsize = osize;\r\nbreak;\r\ncase CRUSH_RULE_EMIT:\r\nfor (i = 0; i < wsize && result_len < result_max; i++) {\r\nresult[result_len] = w[i];\r\nresult_len++;\r\n}\r\nwsize = 0;\r\nbreak;\r\ndefault:\r\ndprintk(" unknown op %d at step %d\n",\r\ncurstep->op, step);\r\nbreak;\r\n}\r\n}\r\nreturn result_len;\r\n}
