static int __init init_scx200_docflash(void)\r\n{\r\nunsigned u;\r\nunsigned base;\r\nunsigned ctrl;\r\nunsigned pmr;\r\nstruct pci_dev *bridge;\r\nprintk(KERN_DEBUG NAME ": NatSemi SCx200 DOCCS Flash Driver\n");\r\nif ((bridge = pci_get_device(PCI_VENDOR_ID_NS,\r\nPCI_DEVICE_ID_NS_SCx200_BRIDGE,\r\nNULL)) == NULL)\r\nreturn -ENODEV;\r\nif (!scx200_cb_present()) {\r\npci_dev_put(bridge);\r\nreturn -ENODEV;\r\n}\r\nif (probe) {\r\npci_read_config_dword(bridge, SCx200_DOCCS_BASE, &base);\r\npci_read_config_dword(bridge, SCx200_DOCCS_CTRL, &ctrl);\r\npci_dev_put(bridge);\r\npmr = inl(scx200_cb_base + SCx200_PMR);\r\nif (base == 0\r\n|| (ctrl & 0x07000000) != 0x07000000\r\n|| (ctrl & 0x0007ffff) == 0)\r\nreturn -ENODEV;\r\nsize = ((ctrl&0x1fff)<<13) + (1<<13);\r\nfor (u = size; u > 1; u >>= 1)\r\n;\r\nif (u != 1)\r\nreturn -ENODEV;\r\nif (pmr & (1<<6))\r\nwidth = 16;\r\nelse\r\nwidth = 8;\r\ndocmem.start = base;\r\ndocmem.end = base + size;\r\nif (request_resource(&iomem_resource, &docmem)) {\r\nprintk(KERN_ERR NAME ": unable to allocate memory for flash mapping\n");\r\nreturn -ENOMEM;\r\n}\r\n} else {\r\npci_dev_put(bridge);\r\nfor (u = size; u > 1; u >>= 1)\r\n;\r\nif (u != 1) {\r\nprintk(KERN_ERR NAME ": invalid size for flash mapping\n");\r\nreturn -EINVAL;\r\n}\r\nif (width != 8 && width != 16) {\r\nprintk(KERN_ERR NAME ": invalid bus width for flash mapping\n");\r\nreturn -EINVAL;\r\n}\r\nif (allocate_resource(&iomem_resource, &docmem,\r\nsize,\r\n0xc0000000, 0xffffffff,\r\nsize, NULL, NULL)) {\r\nprintk(KERN_ERR NAME ": unable to allocate memory for flash mapping\n");\r\nreturn -ENOMEM;\r\n}\r\nctrl = 0x07000000 | ((size-1) >> 13);\r\nprintk(KERN_INFO "DOCCS BASE=0x%08lx, CTRL=0x%08lx\n", (long)docmem.start, (long)ctrl);\r\npci_write_config_dword(bridge, SCx200_DOCCS_BASE, docmem.start);\r\npci_write_config_dword(bridge, SCx200_DOCCS_CTRL, ctrl);\r\npmr = inl(scx200_cb_base + SCx200_PMR);\r\nif (width == 8) {\r\npmr &= ~(1<<6);\r\n} else {\r\npmr |= (1<<6);\r\n}\r\noutl(pmr, scx200_cb_base + SCx200_PMR);\r\n}\r\nprintk(KERN_INFO NAME ": DOCCS mapped at %pR, width %d\n",\r\n&docmem, width);\r\nscx200_docflash_map.size = size;\r\nif (width == 8)\r\nscx200_docflash_map.bankwidth = 1;\r\nelse\r\nscx200_docflash_map.bankwidth = 2;\r\nsimple_map_init(&scx200_docflash_map);\r\nscx200_docflash_map.phys = docmem.start;\r\nscx200_docflash_map.virt = ioremap(docmem.start, scx200_docflash_map.size);\r\nif (!scx200_docflash_map.virt) {\r\nprintk(KERN_ERR NAME ": failed to ioremap the flash\n");\r\nrelease_resource(&docmem);\r\nreturn -EIO;\r\n}\r\nmymtd = do_map_probe(flashtype, &scx200_docflash_map);\r\nif (!mymtd) {\r\nprintk(KERN_ERR NAME ": unable to detect flash\n");\r\niounmap(scx200_docflash_map.virt);\r\nrelease_resource(&docmem);\r\nreturn -ENXIO;\r\n}\r\nif (size < mymtd->size)\r\nprintk(KERN_WARNING NAME ": warning, flash mapping is smaller than flash size\n");\r\nmymtd->owner = THIS_MODULE;\r\npartition_info[3].offset = mymtd->size-partition_info[3].size;\r\npartition_info[2].size = partition_info[3].offset-partition_info[2].offset;\r\nmtd_device_register(mymtd, partition_info, NUM_PARTITIONS);\r\nreturn 0;\r\n}\r\nstatic void __exit cleanup_scx200_docflash(void)\r\n{\r\nif (mymtd) {\r\nmtd_device_unregister(mymtd);\r\nmap_destroy(mymtd);\r\n}\r\nif (scx200_docflash_map.virt) {\r\niounmap(scx200_docflash_map.virt);\r\nrelease_resource(&docmem);\r\n}\r\n}
