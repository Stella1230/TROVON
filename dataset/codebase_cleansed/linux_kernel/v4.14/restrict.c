static int __init ca_keys_setup(char *str)\r\n{\r\nif (!str)\r\nreturn 1;\r\nif (strncmp(str, "id:", 3) == 0) {\r\nstruct asymmetric_key_id *p = &cakey.id;\r\nsize_t hexlen = (strlen(str) - 3) / 2;\r\nint ret;\r\nif (hexlen == 0 || hexlen > sizeof(cakey.data)) {\r\npr_err("Missing or invalid ca_keys id\n");\r\nreturn 1;\r\n}\r\nret = __asymmetric_key_hex_to_key_id(str + 3, p, hexlen);\r\nif (ret < 0)\r\npr_err("Unparsable ca_keys id hex string\n");\r\nelse\r\nca_keyid = p;\r\n} else if (strcmp(str, "builtin") == 0) {\r\nuse_builtin_keys = true;\r\n}\r\nreturn 1;\r\n}\r\nint restrict_link_by_signature(struct key *dest_keyring,\r\nconst struct key_type *type,\r\nconst union key_payload *payload,\r\nstruct key *trust_keyring)\r\n{\r\nconst struct public_key_signature *sig;\r\nstruct key *key;\r\nint ret;\r\npr_devel("==>%s()\n", __func__);\r\nif (!trust_keyring)\r\nreturn -ENOKEY;\r\nif (type != &key_type_asymmetric)\r\nreturn -EOPNOTSUPP;\r\nsig = payload->data[asym_auth];\r\nif (!sig->auth_ids[0] && !sig->auth_ids[1])\r\nreturn -ENOKEY;\r\nif (ca_keyid && !asymmetric_key_id_partial(sig->auth_ids[1], ca_keyid))\r\nreturn -EPERM;\r\nkey = find_asymmetric_key(trust_keyring,\r\nsig->auth_ids[0], sig->auth_ids[1],\r\nfalse);\r\nif (IS_ERR(key))\r\nreturn -ENOKEY;\r\nif (use_builtin_keys && !test_bit(KEY_FLAG_BUILTIN, &key->flags))\r\nret = -ENOKEY;\r\nelse\r\nret = verify_signature(key, sig);\r\nkey_put(key);\r\nreturn ret;\r\n}\r\nstatic bool match_either_id(const struct asymmetric_key_ids *pair,\r\nconst struct asymmetric_key_id *single)\r\n{\r\nreturn (asymmetric_key_id_same(pair->id[0], single) ||\r\nasymmetric_key_id_same(pair->id[1], single));\r\n}\r\nstatic int key_or_keyring_common(struct key *dest_keyring,\r\nconst struct key_type *type,\r\nconst union key_payload *payload,\r\nstruct key *trusted, bool check_dest)\r\n{\r\nconst struct public_key_signature *sig;\r\nstruct key *key = NULL;\r\nint ret;\r\npr_devel("==>%s()\n", __func__);\r\nif (!dest_keyring)\r\nreturn -ENOKEY;\r\nelse if (dest_keyring->type != &key_type_keyring)\r\nreturn -EOPNOTSUPP;\r\nif (!trusted && !check_dest)\r\nreturn -ENOKEY;\r\nif (type != &key_type_asymmetric)\r\nreturn -EOPNOTSUPP;\r\nsig = payload->data[asym_auth];\r\nif (!sig->auth_ids[0] && !sig->auth_ids[1])\r\nreturn -ENOKEY;\r\nif (trusted) {\r\nif (trusted->type == &key_type_keyring) {\r\nkey = find_asymmetric_key(trusted, sig->auth_ids[0],\r\nsig->auth_ids[1], false);\r\nif (IS_ERR(key))\r\nkey = NULL;\r\n} else if (trusted->type == &key_type_asymmetric) {\r\nconst struct asymmetric_key_ids *signer_ids;\r\nsigner_ids = asymmetric_key_ids(trusted);\r\nif (!sig->auth_ids[0] || !sig->auth_ids[1]) {\r\nconst struct asymmetric_key_id *auth_id;\r\nauth_id = sig->auth_ids[0] ?: sig->auth_ids[1];\r\nif (match_either_id(signer_ids, auth_id))\r\nkey = __key_get(trusted);\r\n} else if (asymmetric_key_id_same(signer_ids->id[1],\r\nsig->auth_ids[1]) &&\r\nmatch_either_id(signer_ids,\r\nsig->auth_ids[0])) {\r\nkey = __key_get(trusted);\r\n}\r\n} else {\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nif (check_dest && !key) {\r\nkey = find_asymmetric_key(dest_keyring, sig->auth_ids[0],\r\nsig->auth_ids[1], false);\r\nif (IS_ERR(key))\r\nkey = NULL;\r\n}\r\nif (!key)\r\nreturn -ENOKEY;\r\nret = key_validate(key);\r\nif (ret == 0)\r\nret = verify_signature(key, sig);\r\nkey_put(key);\r\nreturn ret;\r\n}\r\nint restrict_link_by_key_or_keyring(struct key *dest_keyring,\r\nconst struct key_type *type,\r\nconst union key_payload *payload,\r\nstruct key *trusted)\r\n{\r\nreturn key_or_keyring_common(dest_keyring, type, payload, trusted,\r\nfalse);\r\n}\r\nint restrict_link_by_key_or_keyring_chain(struct key *dest_keyring,\r\nconst struct key_type *type,\r\nconst union key_payload *payload,\r\nstruct key *trusted)\r\n{\r\nreturn key_or_keyring_common(dest_keyring, type, payload, trusted,\r\ntrue);\r\n}
