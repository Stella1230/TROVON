int sun4i_hash_crainit(struct crypto_tfm *tfm)\r\n{\r\nstruct sun4i_tfm_ctx *op = crypto_tfm_ctx(tfm);\r\nstruct ahash_alg *alg = __crypto_ahash_alg(tfm->__crt_alg);\r\nstruct sun4i_ss_alg_template *algt;\r\nmemset(op, 0, sizeof(struct sun4i_tfm_ctx));\r\nalgt = container_of(alg, struct sun4i_ss_alg_template, alg.hash);\r\nop->ss = algt->ss;\r\ncrypto_ahash_set_reqsize(__crypto_ahash_cast(tfm),\r\nsizeof(struct sun4i_req_ctx));\r\nreturn 0;\r\n}\r\nint sun4i_hash_init(struct ahash_request *areq)\r\n{\r\nstruct sun4i_req_ctx *op = ahash_request_ctx(areq);\r\nstruct crypto_ahash *tfm = crypto_ahash_reqtfm(areq);\r\nstruct ahash_alg *alg = __crypto_ahash_alg(tfm->base.__crt_alg);\r\nstruct sun4i_ss_alg_template *algt;\r\nmemset(op, 0, sizeof(struct sun4i_req_ctx));\r\nalgt = container_of(alg, struct sun4i_ss_alg_template, alg.hash);\r\nop->mode = algt->mode;\r\nreturn 0;\r\n}\r\nint sun4i_hash_export_md5(struct ahash_request *areq, void *out)\r\n{\r\nstruct sun4i_req_ctx *op = ahash_request_ctx(areq);\r\nstruct md5_state *octx = out;\r\nint i;\r\noctx->byte_count = op->byte_count + op->len;\r\nmemcpy(octx->block, op->buf, op->len);\r\nif (op->byte_count) {\r\nfor (i = 0; i < 4; i++)\r\noctx->hash[i] = op->hash[i];\r\n} else {\r\noctx->hash[0] = SHA1_H0;\r\noctx->hash[1] = SHA1_H1;\r\noctx->hash[2] = SHA1_H2;\r\noctx->hash[3] = SHA1_H3;\r\n}\r\nreturn 0;\r\n}\r\nint sun4i_hash_import_md5(struct ahash_request *areq, const void *in)\r\n{\r\nstruct sun4i_req_ctx *op = ahash_request_ctx(areq);\r\nconst struct md5_state *ictx = in;\r\nint i;\r\nsun4i_hash_init(areq);\r\nop->byte_count = ictx->byte_count & ~0x3F;\r\nop->len = ictx->byte_count & 0x3F;\r\nmemcpy(op->buf, ictx->block, op->len);\r\nfor (i = 0; i < 4; i++)\r\nop->hash[i] = ictx->hash[i];\r\nreturn 0;\r\n}\r\nint sun4i_hash_export_sha1(struct ahash_request *areq, void *out)\r\n{\r\nstruct sun4i_req_ctx *op = ahash_request_ctx(areq);\r\nstruct sha1_state *octx = out;\r\nint i;\r\noctx->count = op->byte_count + op->len;\r\nmemcpy(octx->buffer, op->buf, op->len);\r\nif (op->byte_count) {\r\nfor (i = 0; i < 5; i++)\r\noctx->state[i] = op->hash[i];\r\n} else {\r\noctx->state[0] = SHA1_H0;\r\noctx->state[1] = SHA1_H1;\r\noctx->state[2] = SHA1_H2;\r\noctx->state[3] = SHA1_H3;\r\noctx->state[4] = SHA1_H4;\r\n}\r\nreturn 0;\r\n}\r\nint sun4i_hash_import_sha1(struct ahash_request *areq, const void *in)\r\n{\r\nstruct sun4i_req_ctx *op = ahash_request_ctx(areq);\r\nconst struct sha1_state *ictx = in;\r\nint i;\r\nsun4i_hash_init(areq);\r\nop->byte_count = ictx->count & ~0x3F;\r\nop->len = ictx->count & 0x3F;\r\nmemcpy(op->buf, ictx->buffer, op->len);\r\nfor (i = 0; i < 5; i++)\r\nop->hash[i] = ictx->state[i];\r\nreturn 0;\r\n}\r\nstatic int sun4i_hash(struct ahash_request *areq)\r\n{\r\nunsigned int i = 0, end, fill, min_fill, nwait, nbw = 0, j = 0, todo;\r\nunsigned int in_i = 0;\r\nu32 spaces, rx_cnt = SS_RX_DEFAULT, bf[32] = {0}, wb = 0, v, ivmode = 0;\r\nstruct sun4i_req_ctx *op = ahash_request_ctx(areq);\r\nstruct crypto_ahash *tfm = crypto_ahash_reqtfm(areq);\r\nstruct sun4i_tfm_ctx *tfmctx = crypto_ahash_ctx(tfm);\r\nstruct sun4i_ss_ctx *ss = tfmctx->ss;\r\nstruct scatterlist *in_sg = areq->src;\r\nstruct sg_mapping_iter mi;\r\nint in_r, err = 0;\r\nsize_t copied = 0;\r\ndev_dbg(ss->dev, "%s %s bc=%llu len=%u mode=%x wl=%u h0=%0x",\r\n__func__, crypto_tfm_alg_name(areq->base.tfm),\r\nop->byte_count, areq->nbytes, op->mode,\r\nop->len, op->hash[0]);\r\nif (unlikely(!areq->nbytes) && !(op->flags & SS_HASH_FINAL))\r\nreturn 0;\r\nif (unlikely(areq->nbytes > UINT_MAX - op->len)) {\r\ndev_err(ss->dev, "Cannot process too large request\n");\r\nreturn -EINVAL;\r\n}\r\nif (op->len + areq->nbytes < 64 && !(op->flags & SS_HASH_FINAL)) {\r\ncopied = sg_pcopy_to_buffer(areq->src, sg_nents(areq->src),\r\nop->buf + op->len, areq->nbytes, 0);\r\nop->len += copied;\r\nreturn 0;\r\n}\r\nspin_lock_bh(&ss->slock);\r\nif (op->byte_count) {\r\nivmode = SS_IV_ARBITRARY;\r\nfor (i = 0; i < 5; i++)\r\nwritel(op->hash[i], ss->base + SS_IV0 + i * 4);\r\n}\r\nwritel(op->mode | SS_ENABLED | ivmode, ss->base + SS_CTL);\r\nif (!(op->flags & SS_HASH_UPDATE))\r\ngoto hash_final;\r\nif (!(op->flags & SS_HASH_FINAL)) {\r\nend = ((areq->nbytes + op->len) / 64) * 64 - op->len;\r\nif (end > areq->nbytes || areq->nbytes - end > 63) {\r\ndev_err(ss->dev, "ERROR: Bound error %u %u\n",\r\nend, areq->nbytes);\r\nerr = -EINVAL;\r\ngoto release_ss;\r\n}\r\n} else {\r\nend = ((areq->nbytes + op->len) / 4) * 4 - op->len;\r\n}\r\ni = 1;\r\nwhile (in_sg && i == 1) {\r\nif (in_sg->length % 4)\r\ni = 0;\r\nin_sg = sg_next(in_sg);\r\n}\r\nif (i == 1 && !op->len && areq->nbytes)\r\ndev_dbg(ss->dev, "We can DMA\n");\r\ni = 0;\r\nsg_miter_start(&mi, areq->src, sg_nents(areq->src),\r\nSG_MITER_FROM_SG | SG_MITER_ATOMIC);\r\nsg_miter_next(&mi);\r\nin_i = 0;\r\ndo {\r\nif (op->len || (mi.length - in_i) < 4) {\r\nwhile (op->len < 64 && i < end) {\r\nin_r = min3(mi.length - in_i, end - i,\r\n64 - op->len);\r\nmemcpy(op->buf + op->len, mi.addr + in_i, in_r);\r\nop->len += in_r;\r\ni += in_r;\r\nin_i += in_r;\r\nif (in_i == mi.length) {\r\nsg_miter_next(&mi);\r\nin_i = 0;\r\n}\r\n}\r\nif (op->len > 3 && !(op->len % 4)) {\r\nwritesl(ss->base + SS_RXFIFO, op->buf,\r\nop->len / 4);\r\nop->byte_count += op->len;\r\nop->len = 0;\r\n}\r\n}\r\nif (mi.length - in_i > 3 && i < end) {\r\nin_r = min3(mi.length - in_i, areq->nbytes - i,\r\n((mi.length - in_i) / 4) * 4);\r\ntodo = min3((u32)(end - i) / 4, rx_cnt, (u32)in_r / 4);\r\nwritesl(ss->base + SS_RXFIFO, mi.addr + in_i, todo);\r\nop->byte_count += todo * 4;\r\ni += todo * 4;\r\nin_i += todo * 4;\r\nrx_cnt -= todo;\r\nif (!rx_cnt) {\r\nspaces = readl(ss->base + SS_FCSR);\r\nrx_cnt = SS_RXFIFO_SPACES(spaces);\r\n}\r\nif (in_i == mi.length) {\r\nsg_miter_next(&mi);\r\nin_i = 0;\r\n}\r\n}\r\n} while (i < end);\r\nif ((areq->nbytes - i) < 64) {\r\nwhile (i < areq->nbytes && in_i < mi.length && op->len < 64) {\r\nin_r = min3(mi.length - in_i, areq->nbytes - i,\r\n64 - op->len);\r\nmemcpy(op->buf + op->len, mi.addr + in_i, in_r);\r\nop->len += in_r;\r\ni += in_r;\r\nin_i += in_r;\r\nif (in_i == mi.length) {\r\nsg_miter_next(&mi);\r\nin_i = 0;\r\n}\r\n}\r\n}\r\nsg_miter_stop(&mi);\r\nif (op->flags & SS_HASH_FINAL)\r\ngoto hash_final;\r\nwritel(op->mode | SS_ENABLED | SS_DATA_END, ss->base + SS_CTL);\r\ni = 0;\r\ndo {\r\nv = readl(ss->base + SS_CTL);\r\ni++;\r\n} while (i < SS_TIMEOUT && (v & SS_DATA_END));\r\nif (unlikely(i >= SS_TIMEOUT)) {\r\ndev_err_ratelimited(ss->dev,\r\n"ERROR: hash end timeout %d>%d ctl=%x len=%u\n",\r\ni, SS_TIMEOUT, v, areq->nbytes);\r\nerr = -EIO;\r\ngoto release_ss;\r\n}\r\nndelay(1);\r\nfor (i = 0; i < crypto_ahash_digestsize(tfm) / 4; i++)\r\nop->hash[i] = readl(ss->base + SS_MD0 + i * 4);\r\ngoto release_ss;\r\nhash_final:\r\nif (op->len) {\r\nnwait = op->len / 4;\r\nif (nwait) {\r\nwritesl(ss->base + SS_RXFIFO, op->buf, nwait);\r\nop->byte_count += 4 * nwait;\r\n}\r\nnbw = op->len - 4 * nwait;\r\nif (nbw) {\r\nwb = *(u32 *)(op->buf + nwait * 4);\r\nwb &= GENMASK((nbw * 8) - 1, 0);\r\nop->byte_count += nbw;\r\n}\r\n}\r\nwb |= ((1 << 7) << (nbw * 8));\r\nbf[j++] = wb;\r\nfill = 64 - (op->byte_count % 64);\r\nmin_fill = 2 * sizeof(u32) + (nbw ? 0 : sizeof(u32));\r\nif (fill < min_fill)\r\nfill += 64;\r\nj += (fill - min_fill) / sizeof(u32);\r\nif (op->mode == SS_OP_SHA1) {\r\n__be64 bits = cpu_to_be64(op->byte_count << 3);\r\nbf[j++] = lower_32_bits(bits);\r\nbf[j++] = upper_32_bits(bits);\r\n} else {\r\n__le64 bits = op->byte_count << 3;\r\nbf[j++] = lower_32_bits(bits);\r\nbf[j++] = upper_32_bits(bits);\r\n}\r\nwritesl(ss->base + SS_RXFIFO, bf, j);\r\nwritel(op->mode | SS_ENABLED | SS_DATA_END, ss->base + SS_CTL);\r\ni = 0;\r\ndo {\r\nv = readl(ss->base + SS_CTL);\r\ni++;\r\n} while (i < SS_TIMEOUT && (v & SS_DATA_END));\r\nif (unlikely(i >= SS_TIMEOUT)) {\r\ndev_err_ratelimited(ss->dev,\r\n"ERROR: hash end timeout %d>%d ctl=%x len=%u\n",\r\ni, SS_TIMEOUT, v, areq->nbytes);\r\nerr = -EIO;\r\ngoto release_ss;\r\n}\r\nndelay(1);\r\nif (op->mode == SS_OP_SHA1) {\r\nfor (i = 0; i < 5; i++) {\r\nv = cpu_to_be32(readl(ss->base + SS_MD0 + i * 4));\r\nmemcpy(areq->result + i * 4, &v, 4);\r\n}\r\n} else {\r\nfor (i = 0; i < 4; i++) {\r\nv = readl(ss->base + SS_MD0 + i * 4);\r\nmemcpy(areq->result + i * 4, &v, 4);\r\n}\r\n}\r\nrelease_ss:\r\nwritel(0, ss->base + SS_CTL);\r\nspin_unlock_bh(&ss->slock);\r\nreturn err;\r\n}\r\nint sun4i_hash_final(struct ahash_request *areq)\r\n{\r\nstruct sun4i_req_ctx *op = ahash_request_ctx(areq);\r\nop->flags = SS_HASH_FINAL;\r\nreturn sun4i_hash(areq);\r\n}\r\nint sun4i_hash_update(struct ahash_request *areq)\r\n{\r\nstruct sun4i_req_ctx *op = ahash_request_ctx(areq);\r\nop->flags = SS_HASH_UPDATE;\r\nreturn sun4i_hash(areq);\r\n}\r\nint sun4i_hash_finup(struct ahash_request *areq)\r\n{\r\nstruct sun4i_req_ctx *op = ahash_request_ctx(areq);\r\nop->flags = SS_HASH_UPDATE | SS_HASH_FINAL;\r\nreturn sun4i_hash(areq);\r\n}\r\nint sun4i_hash_digest(struct ahash_request *areq)\r\n{\r\nint err;\r\nstruct sun4i_req_ctx *op = ahash_request_ctx(areq);\r\nerr = sun4i_hash_init(areq);\r\nif (err)\r\nreturn err;\r\nop->flags = SS_HASH_UPDATE | SS_HASH_FINAL;\r\nreturn sun4i_hash(areq);\r\n}
