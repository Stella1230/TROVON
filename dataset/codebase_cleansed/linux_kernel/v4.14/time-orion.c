static unsigned long notrace orion_read_timer(void)\r\n{\r\nreturn ~readl(timer_base + TIMER0_VAL);\r\n}\r\nstatic void orion_delay_timer_init(unsigned long rate)\r\n{\r\norion_delay_timer.freq = rate;\r\nregister_current_timer_delay(&orion_delay_timer);\r\n}\r\nstatic u64 notrace orion_read_sched_clock(void)\r\n{\r\nreturn ~readl(timer_base + TIMER0_VAL);\r\n}\r\nstatic int orion_clkevt_next_event(unsigned long delta,\r\nstruct clock_event_device *dev)\r\n{\r\nwritel(delta, timer_base + TIMER1_VAL);\r\natomic_io_modify(timer_base + TIMER_CTRL,\r\nTIMER1_RELOAD_EN | TIMER1_EN, TIMER1_EN);\r\nreturn 0;\r\n}\r\nstatic int orion_clkevt_shutdown(struct clock_event_device *dev)\r\n{\r\natomic_io_modify(timer_base + TIMER_CTRL,\r\nTIMER1_RELOAD_EN | TIMER1_EN, 0);\r\nreturn 0;\r\n}\r\nstatic int orion_clkevt_set_periodic(struct clock_event_device *dev)\r\n{\r\nwritel(ticks_per_jiffy - 1, timer_base + TIMER1_RELOAD);\r\nwritel(ticks_per_jiffy - 1, timer_base + TIMER1_VAL);\r\natomic_io_modify(timer_base + TIMER_CTRL,\r\nTIMER1_RELOAD_EN | TIMER1_EN,\r\nTIMER1_RELOAD_EN | TIMER1_EN);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t orion_clkevt_irq_handler(int irq, void *dev_id)\r\n{\r\norion_clkevt.event_handler(&orion_clkevt);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __init orion_timer_init(struct device_node *np)\r\n{\r\nunsigned long rate;\r\nstruct clk *clk;\r\nint irq, ret;\r\ntimer_base = of_iomap(np, 0);\r\nif (!timer_base) {\r\npr_err("%s: unable to map resource\n", np->name);\r\nreturn -ENXIO;\r\n}\r\nclk = of_clk_get(np, 0);\r\nif (IS_ERR(clk)) {\r\npr_err("%s: unable to get clk\n", np->name);\r\nreturn PTR_ERR(clk);\r\n}\r\nret = clk_prepare_enable(clk);\r\nif (ret) {\r\npr_err("Failed to prepare clock\n");\r\nreturn ret;\r\n}\r\nirq = irq_of_parse_and_map(np, 1);\r\nif (irq <= 0) {\r\npr_err("%s: unable to parse timer1 irq\n", np->name);\r\nreturn -EINVAL;\r\n}\r\nrate = clk_get_rate(clk);\r\nwritel(~0, timer_base + TIMER0_VAL);\r\nwritel(~0, timer_base + TIMER0_RELOAD);\r\natomic_io_modify(timer_base + TIMER_CTRL,\r\nTIMER0_RELOAD_EN | TIMER0_EN,\r\nTIMER0_RELOAD_EN | TIMER0_EN);\r\nret = clocksource_mmio_init(timer_base + TIMER0_VAL,\r\n"orion_clocksource", rate, 300, 32,\r\nclocksource_mmio_readl_down);\r\nif (ret) {\r\npr_err("Failed to initialize mmio timer\n");\r\nreturn ret;\r\n}\r\nsched_clock_register(orion_read_sched_clock, 32, rate);\r\nret = setup_irq(irq, &orion_clkevt_irq);\r\nif (ret) {\r\npr_err("%s: unable to setup irq\n", np->name);\r\nreturn ret;\r\n}\r\nticks_per_jiffy = (clk_get_rate(clk) + HZ/2) / HZ;\r\norion_clkevt.cpumask = cpumask_of(0);\r\norion_clkevt.irq = irq;\r\nclockevents_config_and_register(&orion_clkevt, rate,\r\nORION_ONESHOT_MIN, ORION_ONESHOT_MAX);\r\norion_delay_timer_init(rate);\r\nreturn 0;\r\n}
