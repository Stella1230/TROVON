static int tas571x_register_size(struct tas571x_private *priv, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase TAS571X_MVOL_REG:\r\ncase TAS571X_CH1_VOL_REG:\r\ncase TAS571X_CH2_VOL_REG:\r\nreturn priv->chip->vol_reg_size;\r\ncase TAS571X_INPUT_MUX_REG:\r\ncase TAS571X_CH4_SRC_SELECT_REG:\r\ncase TAS571X_PWM_MUX_REG:\r\ncase TAS5717_CH1_RIGHT_CH_MIX_REG:\r\ncase TAS5717_CH1_LEFT_CH_MIX_REG:\r\ncase TAS5717_CH2_LEFT_CH_MIX_REG:\r\ncase TAS5717_CH2_RIGHT_CH_MIX_REG:\r\nreturn 4;\r\ndefault:\r\nreturn 1;\r\n}\r\n}\r\nstatic int tas571x_reg_write(void *context, unsigned int reg,\r\nunsigned int value)\r\n{\r\nstruct i2c_client *client = context;\r\nstruct tas571x_private *priv = i2c_get_clientdata(client);\r\nunsigned int i, size;\r\nuint8_t buf[5];\r\nint ret;\r\nsize = tas571x_register_size(priv, reg);\r\nbuf[0] = reg;\r\nfor (i = size; i >= 1; --i) {\r\nbuf[i] = value;\r\nvalue >>= 8;\r\n}\r\nret = i2c_master_send(client, buf, size + 1);\r\nif (ret == size + 1)\r\nreturn 0;\r\nelse if (ret < 0)\r\nreturn ret;\r\nelse\r\nreturn -EIO;\r\n}\r\nstatic int tas571x_reg_read(void *context, unsigned int reg,\r\nunsigned int *value)\r\n{\r\nstruct i2c_client *client = context;\r\nstruct tas571x_private *priv = i2c_get_clientdata(client);\r\nuint8_t send_buf, recv_buf[4];\r\nstruct i2c_msg msgs[2];\r\nunsigned int size;\r\nunsigned int i;\r\nint ret;\r\nsize = tas571x_register_size(priv, reg);\r\nsend_buf = reg;\r\nmsgs[0].addr = client->addr;\r\nmsgs[0].len = sizeof(send_buf);\r\nmsgs[0].buf = &send_buf;\r\nmsgs[0].flags = 0;\r\nmsgs[1].addr = client->addr;\r\nmsgs[1].len = size;\r\nmsgs[1].buf = recv_buf;\r\nmsgs[1].flags = I2C_M_RD;\r\nret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\r\nif (ret < 0)\r\nreturn ret;\r\nelse if (ret != ARRAY_SIZE(msgs))\r\nreturn -EIO;\r\n*value = 0;\r\nfor (i = 0; i < size; i++) {\r\n*value <<= 8;\r\n*value |= recv_buf[i];\r\n}\r\nreturn 0;\r\n}\r\nstatic int tas571x_reg_write_multiword(struct i2c_client *client,\r\nunsigned int reg, const long values[], size_t len)\r\n{\r\nsize_t i;\r\nuint8_t *buf, *p;\r\nint ret;\r\nsize_t send_size = 1 + len * sizeof(uint32_t);\r\nbuf = kzalloc(send_size, GFP_KERNEL | GFP_DMA);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nbuf[0] = reg;\r\nfor (i = 0, p = buf + 1; i < len; i++, p += sizeof(uint32_t))\r\nput_unaligned_be32(values[i], p);\r\nret = i2c_master_send(client, buf, send_size);\r\nkfree(buf);\r\nif (ret == send_size)\r\nreturn 0;\r\nelse if (ret < 0)\r\nreturn ret;\r\nelse\r\nreturn -EIO;\r\n}\r\nstatic int tas571x_reg_read_multiword(struct i2c_client *client,\r\nunsigned int reg, long values[], size_t len)\r\n{\r\nunsigned int i;\r\nuint8_t send_buf;\r\nuint8_t *recv_buf, *p;\r\nstruct i2c_msg msgs[2];\r\nunsigned int recv_size = len * sizeof(uint32_t);\r\nint ret;\r\nrecv_buf = kzalloc(recv_size, GFP_KERNEL | GFP_DMA);\r\nif (!recv_buf)\r\nreturn -ENOMEM;\r\nsend_buf = reg;\r\nmsgs[0].addr = client->addr;\r\nmsgs[0].len = sizeof(send_buf);\r\nmsgs[0].buf = &send_buf;\r\nmsgs[0].flags = 0;\r\nmsgs[1].addr = client->addr;\r\nmsgs[1].len = recv_size;\r\nmsgs[1].buf = recv_buf;\r\nmsgs[1].flags = I2C_M_RD;\r\nret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\r\nif (ret < 0)\r\ngoto err_ret;\r\nelse if (ret != ARRAY_SIZE(msgs)) {\r\nret = -EIO;\r\ngoto err_ret;\r\n}\r\nfor (i = 0, p = recv_buf; i < len; i++, p += sizeof(uint32_t))\r\nvalues[i] = get_unaligned_be32(p);\r\nerr_ret:\r\nkfree(recv_buf);\r\nreturn ret;\r\n}\r\nstatic int tas571x_coefficient_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nint numcoef = kcontrol->private_value >> 16;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = numcoef;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 0xffffffff;\r\nreturn 0;\r\n}\r\nstatic int tas571x_coefficient_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct i2c_client *i2c = to_i2c_client(codec->dev);\r\nint numcoef = kcontrol->private_value >> 16;\r\nint index = kcontrol->private_value & 0xffff;\r\nreturn tas571x_reg_read_multiword(i2c, index,\r\nucontrol->value.integer.value, numcoef);\r\n}\r\nstatic int tas571x_coefficient_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct i2c_client *i2c = to_i2c_client(codec->dev);\r\nint numcoef = kcontrol->private_value >> 16;\r\nint index = kcontrol->private_value & 0xffff;\r\nreturn tas571x_reg_write_multiword(i2c, index,\r\nucontrol->value.integer.value, numcoef);\r\n}\r\nstatic int tas571x_set_dai_fmt(struct snd_soc_dai *dai, unsigned int format)\r\n{\r\nstruct tas571x_private *priv = snd_soc_codec_get_drvdata(dai->codec);\r\npriv->format = format;\r\nreturn 0;\r\n}\r\nstatic int tas571x_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct tas571x_private *priv = snd_soc_codec_get_drvdata(dai->codec);\r\nu32 val;\r\nswitch (priv->format & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nval = 0x00;\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\nval = 0x03;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nval = 0x06;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (params_width(params) >= 24)\r\nval += 2;\r\nelse if (params_width(params) >= 20)\r\nval += 1;\r\nreturn regmap_update_bits(priv->regmap, TAS571X_SDI_REG,\r\nTAS571X_SDI_FMT_MASK, val);\r\n}\r\nstatic int tas571x_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nu8 sysctl2;\r\nint ret;\r\nsysctl2 = mute ? TAS571X_SYS_CTRL_2_SDN_MASK : 0;\r\nret = snd_soc_update_bits(codec,\r\nTAS571X_SYS_CTRL_2_REG,\r\nTAS571X_SYS_CTRL_2_SDN_MASK,\r\nsysctl2);\r\nusleep_range(1000, 2000);\r\nreturn ret;\r\n}\r\nstatic int tas571x_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct tas571x_private *priv = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_OFF) {\r\nif (!IS_ERR(priv->mclk)) {\r\nret = clk_prepare_enable(priv->mclk);\r\nif (ret) {\r\ndev_err(codec->dev,\r\n"Failed to enable master clock: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\n}\r\n}\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nif (!IS_ERR(priv->mclk))\r\nclk_disable_unprepare(priv->mclk);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tas571x_i2c_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct tas571x_private *priv;\r\nstruct device *dev = &client->dev;\r\nconst struct of_device_id *of_id;\r\nint i, ret;\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, priv);\r\nof_id = of_match_device(tas571x_of_match, dev);\r\nif (of_id)\r\npriv->chip = of_id->data;\r\nelse\r\npriv->chip = (void *) id->driver_data;\r\npriv->mclk = devm_clk_get(dev, "mclk");\r\nif (IS_ERR(priv->mclk) && PTR_ERR(priv->mclk) != -ENOENT) {\r\ndev_err(dev, "Failed to request mclk: %ld\n",\r\nPTR_ERR(priv->mclk));\r\nreturn PTR_ERR(priv->mclk);\r\n}\r\nBUG_ON(priv->chip->num_supply_names > TAS571X_MAX_SUPPLIES);\r\nfor (i = 0; i < priv->chip->num_supply_names; i++)\r\npriv->supplies[i].supply = priv->chip->supply_names[i];\r\nret = devm_regulator_bulk_get(dev, priv->chip->num_supply_names,\r\npriv->supplies);\r\nif (ret) {\r\ndev_err(dev, "Failed to get supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regulator_bulk_enable(priv->chip->num_supply_names,\r\npriv->supplies);\r\nif (ret) {\r\ndev_err(dev, "Failed to enable supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\npriv->regmap = devm_regmap_init(dev, NULL, client,\r\npriv->chip->regmap_config);\r\nif (IS_ERR(priv->regmap))\r\nreturn PTR_ERR(priv->regmap);\r\npriv->pdn_gpio = devm_gpiod_get_optional(dev, "pdn", GPIOD_OUT_LOW);\r\nif (IS_ERR(priv->pdn_gpio)) {\r\ndev_err(dev, "error requesting pdn_gpio: %ld\n",\r\nPTR_ERR(priv->pdn_gpio));\r\nreturn PTR_ERR(priv->pdn_gpio);\r\n}\r\npriv->reset_gpio = devm_gpiod_get_optional(dev, "reset",\r\nGPIOD_OUT_HIGH);\r\nif (IS_ERR(priv->reset_gpio)) {\r\ndev_err(dev, "error requesting reset_gpio: %ld\n",\r\nPTR_ERR(priv->reset_gpio));\r\nreturn PTR_ERR(priv->reset_gpio);\r\n} else if (priv->reset_gpio) {\r\nusleep_range(100, 200);\r\ngpiod_set_value(priv->reset_gpio, 0);\r\nusleep_range(13500, 20000);\r\n}\r\nret = regmap_write(priv->regmap, TAS571X_OSC_TRIM_REG, 0);\r\nif (ret)\r\nreturn ret;\r\nusleep_range(50000, 60000);\r\nmemcpy(&priv->codec_driver, &tas571x_codec, sizeof(priv->codec_driver));\r\npriv->codec_driver.component_driver.controls = priv->chip->controls;\r\npriv->codec_driver.component_driver.num_controls = priv->chip->num_controls;\r\nif (priv->chip->vol_reg_size == 2) {\r\nret = regmap_update_bits(priv->regmap, TAS571X_MVOL_REG, 1, 0);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn snd_soc_register_codec(&client->dev, &priv->codec_driver,\r\n&tas571x_dai, 1);\r\n}\r\nstatic int tas571x_i2c_remove(struct i2c_client *client)\r\n{\r\nstruct tas571x_private *priv = i2c_get_clientdata(client);\r\nsnd_soc_unregister_codec(&client->dev);\r\nregulator_bulk_disable(priv->chip->num_supply_names, priv->supplies);\r\nreturn 0;\r\n}
