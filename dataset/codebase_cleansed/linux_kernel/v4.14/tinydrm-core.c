void tinydrm_lastclose(struct drm_device *drm)\r\n{\r\nstruct tinydrm_device *tdev = drm->dev_private;\r\nDRM_DEBUG_KMS("\n");\r\ndrm_fbdev_cma_restore_mode(tdev->fbdev_cma);\r\n}\r\nstruct drm_gem_object *\r\ntinydrm_gem_cma_prime_import_sg_table(struct drm_device *drm,\r\nstruct dma_buf_attachment *attach,\r\nstruct sg_table *sgt)\r\n{\r\nstruct drm_gem_cma_object *cma_obj;\r\nstruct drm_gem_object *obj;\r\nvoid *vaddr;\r\nvaddr = dma_buf_vmap(attach->dmabuf);\r\nif (!vaddr) {\r\nDRM_ERROR("Failed to vmap PRIME buffer\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nobj = drm_gem_cma_prime_import_sg_table(drm, attach, sgt);\r\nif (IS_ERR(obj)) {\r\ndma_buf_vunmap(attach->dmabuf, vaddr);\r\nreturn obj;\r\n}\r\ncma_obj = to_drm_gem_cma_obj(obj);\r\ncma_obj->vaddr = vaddr;\r\nreturn obj;\r\n}\r\nvoid tinydrm_gem_cma_free_object(struct drm_gem_object *gem_obj)\r\n{\r\nif (gem_obj->import_attach) {\r\nstruct drm_gem_cma_object *cma_obj;\r\ncma_obj = to_drm_gem_cma_obj(gem_obj);\r\ndma_buf_vunmap(gem_obj->import_attach->dmabuf, cma_obj->vaddr);\r\ncma_obj->vaddr = NULL;\r\n}\r\ndrm_gem_cma_free_object(gem_obj);\r\n}\r\nstatic struct drm_framebuffer *\r\ntinydrm_fb_create(struct drm_device *drm, struct drm_file *file_priv,\r\nconst struct drm_mode_fb_cmd2 *mode_cmd)\r\n{\r\nstruct tinydrm_device *tdev = drm->dev_private;\r\nreturn drm_fb_cma_create_with_funcs(drm, file_priv, mode_cmd,\r\ntdev->fb_funcs);\r\n}\r\nstatic int tinydrm_init(struct device *parent, struct tinydrm_device *tdev,\r\nconst struct drm_framebuffer_funcs *fb_funcs,\r\nstruct drm_driver *driver)\r\n{\r\nstruct drm_device *drm;\r\nmutex_init(&tdev->dirty_lock);\r\ntdev->fb_funcs = fb_funcs;\r\ndrm = drm_dev_alloc(driver, parent);\r\nif (IS_ERR(drm))\r\nreturn PTR_ERR(drm);\r\ntdev->drm = drm;\r\ndrm->dev_private = tdev;\r\ndrm_mode_config_init(drm);\r\ndrm->mode_config.funcs = &tinydrm_mode_config_funcs;\r\nreturn 0;\r\n}\r\nstatic void tinydrm_fini(struct tinydrm_device *tdev)\r\n{\r\ndrm_mode_config_cleanup(tdev->drm);\r\nmutex_destroy(&tdev->dirty_lock);\r\ntdev->drm->dev_private = NULL;\r\ndrm_dev_unref(tdev->drm);\r\n}\r\nstatic void devm_tinydrm_release(void *data)\r\n{\r\ntinydrm_fini(data);\r\n}\r\nint devm_tinydrm_init(struct device *parent, struct tinydrm_device *tdev,\r\nconst struct drm_framebuffer_funcs *fb_funcs,\r\nstruct drm_driver *driver)\r\n{\r\nint ret;\r\nret = tinydrm_init(parent, tdev, fb_funcs, driver);\r\nif (ret)\r\nreturn ret;\r\nret = devm_add_action(parent, devm_tinydrm_release, tdev);\r\nif (ret)\r\ntinydrm_fini(tdev);\r\nreturn ret;\r\n}\r\nstatic int tinydrm_register(struct tinydrm_device *tdev)\r\n{\r\nstruct drm_device *drm = tdev->drm;\r\nint bpp = drm->mode_config.preferred_depth;\r\nstruct drm_fbdev_cma *fbdev;\r\nint ret;\r\nret = drm_dev_register(tdev->drm, 0);\r\nif (ret)\r\nreturn ret;\r\nfbdev = drm_fbdev_cma_init_with_funcs(drm, bpp ? bpp : 32,\r\ndrm->mode_config.num_connector,\r\ntdev->fb_funcs);\r\nif (IS_ERR(fbdev))\r\nDRM_ERROR("Failed to initialize fbdev: %ld\n", PTR_ERR(fbdev));\r\nelse\r\ntdev->fbdev_cma = fbdev;\r\nreturn 0;\r\n}\r\nstatic void tinydrm_unregister(struct tinydrm_device *tdev)\r\n{\r\nstruct drm_fbdev_cma *fbdev_cma = tdev->fbdev_cma;\r\ndrm_atomic_helper_shutdown(tdev->drm);\r\ntdev->fbdev_cma = NULL;\r\ndrm_dev_unregister(tdev->drm);\r\nif (fbdev_cma)\r\ndrm_fbdev_cma_fini(fbdev_cma);\r\n}\r\nstatic void devm_tinydrm_register_release(void *data)\r\n{\r\ntinydrm_unregister(data);\r\n}\r\nint devm_tinydrm_register(struct tinydrm_device *tdev)\r\n{\r\nstruct device *dev = tdev->drm->dev;\r\nint ret;\r\nret = tinydrm_register(tdev);\r\nif (ret)\r\nreturn ret;\r\nret = devm_add_action(dev, devm_tinydrm_register_release, tdev);\r\nif (ret)\r\ntinydrm_unregister(tdev);\r\nreturn ret;\r\n}\r\nvoid tinydrm_shutdown(struct tinydrm_device *tdev)\r\n{\r\ndrm_atomic_helper_shutdown(tdev->drm);\r\n}\r\nint tinydrm_suspend(struct tinydrm_device *tdev)\r\n{\r\nstruct drm_atomic_state *state;\r\nif (tdev->suspend_state) {\r\nDRM_ERROR("Failed to suspend: state already set\n");\r\nreturn -EINVAL;\r\n}\r\ndrm_fbdev_cma_set_suspend_unlocked(tdev->fbdev_cma, 1);\r\nstate = drm_atomic_helper_suspend(tdev->drm);\r\nif (IS_ERR(state)) {\r\ndrm_fbdev_cma_set_suspend_unlocked(tdev->fbdev_cma, 0);\r\nreturn PTR_ERR(state);\r\n}\r\ntdev->suspend_state = state;\r\nreturn 0;\r\n}\r\nint tinydrm_resume(struct tinydrm_device *tdev)\r\n{\r\nstruct drm_atomic_state *state = tdev->suspend_state;\r\nint ret;\r\nif (!state) {\r\nDRM_ERROR("Failed to resume: state is not set\n");\r\nreturn -EINVAL;\r\n}\r\ntdev->suspend_state = NULL;\r\nret = drm_atomic_helper_resume(tdev->drm, state);\r\nif (ret) {\r\nDRM_ERROR("Error resuming state: %d\n", ret);\r\nreturn ret;\r\n}\r\ndrm_fbdev_cma_set_suspend_unlocked(tdev->fbdev_cma, 0);\r\nreturn 0;\r\n}
