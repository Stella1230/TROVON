static bool seq_nr_after(u16 a, u16 b)\r\n{\r\nif ((int) b - a == 32768)\r\nreturn false;\r\nreturn (((s16) (b - a)) < 0);\r\n}\r\nbool hsr_addr_is_self(struct hsr_priv *hsr, unsigned char *addr)\r\n{\r\nstruct hsr_node *node;\r\nnode = list_first_or_null_rcu(&hsr->self_node_db, struct hsr_node,\r\nmac_list);\r\nif (!node) {\r\nWARN_ONCE(1, "HSR: No self node\n");\r\nreturn false;\r\n}\r\nif (ether_addr_equal(addr, node->MacAddressA))\r\nreturn true;\r\nif (ether_addr_equal(addr, node->MacAddressB))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic struct hsr_node *find_node_by_AddrA(struct list_head *node_db,\r\nconst unsigned char addr[ETH_ALEN])\r\n{\r\nstruct hsr_node *node;\r\nlist_for_each_entry_rcu(node, node_db, mac_list) {\r\nif (ether_addr_equal(node->MacAddressA, addr))\r\nreturn node;\r\n}\r\nreturn NULL;\r\n}\r\nint hsr_create_self_node(struct list_head *self_node_db,\r\nunsigned char addr_a[ETH_ALEN],\r\nunsigned char addr_b[ETH_ALEN])\r\n{\r\nstruct hsr_node *node, *oldnode;\r\nnode = kmalloc(sizeof(*node), GFP_KERNEL);\r\nif (!node)\r\nreturn -ENOMEM;\r\nether_addr_copy(node->MacAddressA, addr_a);\r\nether_addr_copy(node->MacAddressB, addr_b);\r\nrcu_read_lock();\r\noldnode = list_first_or_null_rcu(self_node_db,\r\nstruct hsr_node, mac_list);\r\nif (oldnode) {\r\nlist_replace_rcu(&oldnode->mac_list, &node->mac_list);\r\nrcu_read_unlock();\r\nsynchronize_rcu();\r\nkfree(oldnode);\r\n} else {\r\nrcu_read_unlock();\r\nlist_add_tail_rcu(&node->mac_list, self_node_db);\r\n}\r\nreturn 0;\r\n}\r\nstruct hsr_node *hsr_add_node(struct list_head *node_db, unsigned char addr[],\r\nu16 seq_out)\r\n{\r\nstruct hsr_node *node;\r\nunsigned long now;\r\nint i;\r\nnode = kzalloc(sizeof(*node), GFP_ATOMIC);\r\nif (!node)\r\nreturn NULL;\r\nether_addr_copy(node->MacAddressA, addr);\r\nnow = jiffies;\r\nfor (i = 0; i < HSR_PT_PORTS; i++)\r\nnode->time_in[i] = now;\r\nfor (i = 0; i < HSR_PT_PORTS; i++)\r\nnode->seq_out[i] = seq_out;\r\nlist_add_tail_rcu(&node->mac_list, node_db);\r\nreturn node;\r\n}\r\nstruct hsr_node *hsr_get_node(struct hsr_port *port, struct sk_buff *skb,\r\nbool is_sup)\r\n{\r\nstruct list_head *node_db = &port->hsr->node_db;\r\nstruct hsr_node *node;\r\nstruct ethhdr *ethhdr;\r\nu16 seq_out;\r\nif (!skb_mac_header_was_set(skb))\r\nreturn NULL;\r\nethhdr = (struct ethhdr *) skb_mac_header(skb);\r\nlist_for_each_entry_rcu(node, node_db, mac_list) {\r\nif (ether_addr_equal(node->MacAddressA, ethhdr->h_source))\r\nreturn node;\r\nif (ether_addr_equal(node->MacAddressB, ethhdr->h_source))\r\nreturn node;\r\n}\r\nif (ethhdr->h_proto == htons(ETH_P_PRP)\r\n|| ethhdr->h_proto == htons(ETH_P_HSR)) {\r\nseq_out = hsr_get_skb_sequence_nr(skb) - 1;\r\n} else {\r\nif (port->type != HSR_PT_MASTER)\r\nWARN_ONCE(1, "%s: Non-HSR frame\n", __func__);\r\nseq_out = HSR_SEQNR_START;\r\n}\r\nreturn hsr_add_node(node_db, ethhdr->h_source, seq_out);\r\n}\r\nvoid hsr_handle_sup_frame(struct sk_buff *skb, struct hsr_node *node_curr,\r\nstruct hsr_port *port_rcv)\r\n{\r\nstruct ethhdr *ethhdr;\r\nstruct hsr_node *node_real;\r\nstruct hsr_sup_payload *hsr_sp;\r\nstruct list_head *node_db;\r\nint i;\r\nethhdr = (struct ethhdr *) skb_mac_header(skb);\r\nskb_pull(skb, sizeof(struct ethhdr));\r\nif (ethhdr->h_proto == htons(ETH_P_HSR))\r\nskb_pull(skb, sizeof(struct hsr_tag));\r\nskb_pull(skb, sizeof(struct hsr_sup_tag));\r\nhsr_sp = (struct hsr_sup_payload *) skb->data;\r\nnode_db = &port_rcv->hsr->node_db;\r\nnode_real = find_node_by_AddrA(node_db, hsr_sp->MacAddressA);\r\nif (!node_real)\r\nnode_real = hsr_add_node(node_db, hsr_sp->MacAddressA,\r\nHSR_SEQNR_START - 1);\r\nif (!node_real)\r\ngoto done;\r\nif (node_real == node_curr)\r\ngoto done;\r\nether_addr_copy(node_real->MacAddressB, ethhdr->h_source);\r\nfor (i = 0; i < HSR_PT_PORTS; i++) {\r\nif (!node_curr->time_in_stale[i] &&\r\ntime_after(node_curr->time_in[i], node_real->time_in[i])) {\r\nnode_real->time_in[i] = node_curr->time_in[i];\r\nnode_real->time_in_stale[i] = node_curr->time_in_stale[i];\r\n}\r\nif (seq_nr_after(node_curr->seq_out[i], node_real->seq_out[i]))\r\nnode_real->seq_out[i] = node_curr->seq_out[i];\r\n}\r\nnode_real->AddrB_port = port_rcv->type;\r\nlist_del_rcu(&node_curr->mac_list);\r\nkfree_rcu(node_curr, rcu_head);\r\ndone:\r\nskb_push(skb, sizeof(struct hsrv1_ethhdr_sp));\r\n}\r\nvoid hsr_addr_subst_source(struct hsr_node *node, struct sk_buff *skb)\r\n{\r\nif (!skb_mac_header_was_set(skb)) {\r\nWARN_ONCE(1, "%s: Mac header not set\n", __func__);\r\nreturn;\r\n}\r\nmemcpy(&eth_hdr(skb)->h_source, node->MacAddressA, ETH_ALEN);\r\n}\r\nvoid hsr_addr_subst_dest(struct hsr_node *node_src, struct sk_buff *skb,\r\nstruct hsr_port *port)\r\n{\r\nstruct hsr_node *node_dst;\r\nif (!skb_mac_header_was_set(skb)) {\r\nWARN_ONCE(1, "%s: Mac header not set\n", __func__);\r\nreturn;\r\n}\r\nif (!is_unicast_ether_addr(eth_hdr(skb)->h_dest))\r\nreturn;\r\nnode_dst = find_node_by_AddrA(&port->hsr->node_db, eth_hdr(skb)->h_dest);\r\nif (!node_dst) {\r\nWARN_ONCE(1, "%s: Unknown node\n", __func__);\r\nreturn;\r\n}\r\nif (port->type != node_dst->AddrB_port)\r\nreturn;\r\nether_addr_copy(eth_hdr(skb)->h_dest, node_dst->MacAddressB);\r\n}\r\nvoid hsr_register_frame_in(struct hsr_node *node, struct hsr_port *port,\r\nu16 sequence_nr)\r\n{\r\nif (seq_nr_before(sequence_nr, node->seq_out[port->type]))\r\nreturn;\r\nnode->time_in[port->type] = jiffies;\r\nnode->time_in_stale[port->type] = false;\r\n}\r\nint hsr_register_frame_out(struct hsr_port *port, struct hsr_node *node,\r\nu16 sequence_nr)\r\n{\r\nif (seq_nr_before_or_eq(sequence_nr, node->seq_out[port->type]))\r\nreturn 1;\r\nnode->seq_out[port->type] = sequence_nr;\r\nreturn 0;\r\n}\r\nstatic struct hsr_port *get_late_port(struct hsr_priv *hsr,\r\nstruct hsr_node *node)\r\n{\r\nif (node->time_in_stale[HSR_PT_SLAVE_A])\r\nreturn hsr_port_get_hsr(hsr, HSR_PT_SLAVE_A);\r\nif (node->time_in_stale[HSR_PT_SLAVE_B])\r\nreturn hsr_port_get_hsr(hsr, HSR_PT_SLAVE_B);\r\nif (time_after(node->time_in[HSR_PT_SLAVE_B],\r\nnode->time_in[HSR_PT_SLAVE_A] +\r\nmsecs_to_jiffies(MAX_SLAVE_DIFF)))\r\nreturn hsr_port_get_hsr(hsr, HSR_PT_SLAVE_A);\r\nif (time_after(node->time_in[HSR_PT_SLAVE_A],\r\nnode->time_in[HSR_PT_SLAVE_B] +\r\nmsecs_to_jiffies(MAX_SLAVE_DIFF)))\r\nreturn hsr_port_get_hsr(hsr, HSR_PT_SLAVE_B);\r\nreturn NULL;\r\n}\r\nvoid hsr_prune_nodes(unsigned long data)\r\n{\r\nstruct hsr_priv *hsr;\r\nstruct hsr_node *node;\r\nstruct hsr_port *port;\r\nunsigned long timestamp;\r\nunsigned long time_a, time_b;\r\nhsr = (struct hsr_priv *) data;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(node, &hsr->node_db, mac_list) {\r\ntime_a = node->time_in[HSR_PT_SLAVE_A];\r\ntime_b = node->time_in[HSR_PT_SLAVE_B];\r\nif (time_after(jiffies, time_a + MAX_JIFFY_OFFSET/2))\r\nnode->time_in_stale[HSR_PT_SLAVE_A] = true;\r\nif (time_after(jiffies, time_b + MAX_JIFFY_OFFSET/2))\r\nnode->time_in_stale[HSR_PT_SLAVE_B] = true;\r\ntimestamp = time_a;\r\nif (node->time_in_stale[HSR_PT_SLAVE_A] ||\r\n(!node->time_in_stale[HSR_PT_SLAVE_B] &&\r\ntime_after(time_b, time_a)))\r\ntimestamp = time_b;\r\nif (time_is_after_jiffies(timestamp +\r\nmsecs_to_jiffies(1.5*MAX_SLAVE_DIFF))) {\r\nrcu_read_lock();\r\nport = get_late_port(hsr, node);\r\nif (port != NULL)\r\nhsr_nl_ringerror(hsr, node->MacAddressA, port);\r\nrcu_read_unlock();\r\n}\r\nif (time_is_before_jiffies(timestamp +\r\nmsecs_to_jiffies(HSR_NODE_FORGET_TIME))) {\r\nhsr_nl_nodedown(hsr, node->MacAddressA);\r\nlist_del_rcu(&node->mac_list);\r\nkfree_rcu(node, rcu_head);\r\n}\r\n}\r\nrcu_read_unlock();\r\n}\r\nvoid *hsr_get_next_node(struct hsr_priv *hsr, void *_pos,\r\nunsigned char addr[ETH_ALEN])\r\n{\r\nstruct hsr_node *node;\r\nif (!_pos) {\r\nnode = list_first_or_null_rcu(&hsr->node_db,\r\nstruct hsr_node, mac_list);\r\nif (node)\r\nether_addr_copy(addr, node->MacAddressA);\r\nreturn node;\r\n}\r\nnode = _pos;\r\nlist_for_each_entry_continue_rcu(node, &hsr->node_db, mac_list) {\r\nether_addr_copy(addr, node->MacAddressA);\r\nreturn node;\r\n}\r\nreturn NULL;\r\n}\r\nint hsr_get_node_data(struct hsr_priv *hsr,\r\nconst unsigned char *addr,\r\nunsigned char addr_b[ETH_ALEN],\r\nunsigned int *addr_b_ifindex,\r\nint *if1_age,\r\nu16 *if1_seq,\r\nint *if2_age,\r\nu16 *if2_seq)\r\n{\r\nstruct hsr_node *node;\r\nstruct hsr_port *port;\r\nunsigned long tdiff;\r\nrcu_read_lock();\r\nnode = find_node_by_AddrA(&hsr->node_db, addr);\r\nif (!node) {\r\nrcu_read_unlock();\r\nreturn -ENOENT;\r\n}\r\nether_addr_copy(addr_b, node->MacAddressB);\r\ntdiff = jiffies - node->time_in[HSR_PT_SLAVE_A];\r\nif (node->time_in_stale[HSR_PT_SLAVE_A])\r\n*if1_age = INT_MAX;\r\n#if HZ <= MSEC_PER_SEC\r\nelse if (tdiff > msecs_to_jiffies(INT_MAX))\r\n*if1_age = INT_MAX;\r\n#endif\r\nelse\r\n*if1_age = jiffies_to_msecs(tdiff);\r\ntdiff = jiffies - node->time_in[HSR_PT_SLAVE_B];\r\nif (node->time_in_stale[HSR_PT_SLAVE_B])\r\n*if2_age = INT_MAX;\r\n#if HZ <= MSEC_PER_SEC\r\nelse if (tdiff > msecs_to_jiffies(INT_MAX))\r\n*if2_age = INT_MAX;\r\n#endif\r\nelse\r\n*if2_age = jiffies_to_msecs(tdiff);\r\n*if1_seq = node->seq_out[HSR_PT_SLAVE_B];\r\n*if2_seq = node->seq_out[HSR_PT_SLAVE_A];\r\nif (node->AddrB_port != HSR_PT_NONE) {\r\nport = hsr_port_get_hsr(hsr, node->AddrB_port);\r\n*addr_b_ifindex = port->dev->ifindex;\r\n} else {\r\n*addr_b_ifindex = -1;\r\n}\r\nrcu_read_unlock();\r\nreturn 0;\r\n}
