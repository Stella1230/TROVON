int mac802154_wpan_update_llsec(struct net_device *dev)\r\n{\r\nstruct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);\r\nstruct ieee802154_mlme_ops *ops = ieee802154_mlme_ops(dev);\r\nstruct wpan_dev *wpan_dev = &sdata->wpan_dev;\r\nint rc = 0;\r\nif (ops->llsec) {\r\nstruct ieee802154_llsec_params params;\r\nint changed = 0;\r\nparams.pan_id = wpan_dev->pan_id;\r\nchanged |= IEEE802154_LLSEC_PARAM_PAN_ID;\r\nparams.hwaddr = wpan_dev->extended_addr;\r\nchanged |= IEEE802154_LLSEC_PARAM_HWADDR;\r\nrc = ops->llsec->set_params(dev, &params, changed);\r\n}\r\nreturn rc;\r\n}\r\nstatic int\r\nmac802154_wpan_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nstruct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);\r\nstruct wpan_dev *wpan_dev = &sdata->wpan_dev;\r\nstruct sockaddr_ieee802154 *sa =\r\n(struct sockaddr_ieee802154 *)&ifr->ifr_addr;\r\nint err = -ENOIOCTLCMD;\r\nif (cmd != SIOCGIFADDR && cmd != SIOCSIFADDR)\r\nreturn err;\r\nrtnl_lock();\r\nswitch (cmd) {\r\ncase SIOCGIFADDR:\r\n{\r\nu16 pan_id, short_addr;\r\npan_id = le16_to_cpu(wpan_dev->pan_id);\r\nshort_addr = le16_to_cpu(wpan_dev->short_addr);\r\nif (pan_id == IEEE802154_PANID_BROADCAST ||\r\nshort_addr == IEEE802154_ADDR_BROADCAST) {\r\nerr = -EADDRNOTAVAIL;\r\nbreak;\r\n}\r\nsa->family = AF_IEEE802154;\r\nsa->addr.addr_type = IEEE802154_ADDR_SHORT;\r\nsa->addr.pan_id = pan_id;\r\nsa->addr.short_addr = short_addr;\r\nerr = 0;\r\nbreak;\r\n}\r\ncase SIOCSIFADDR:\r\nif (netif_running(dev)) {\r\nrtnl_unlock();\r\nreturn -EBUSY;\r\n}\r\ndev_warn(&dev->dev,\r\n"Using DEBUGing ioctl SIOCSIFADDR isn't recommended!\n");\r\nif (sa->family != AF_IEEE802154 ||\r\nsa->addr.addr_type != IEEE802154_ADDR_SHORT ||\r\nsa->addr.pan_id == IEEE802154_PANID_BROADCAST ||\r\nsa->addr.short_addr == IEEE802154_ADDR_BROADCAST ||\r\nsa->addr.short_addr == IEEE802154_ADDR_UNDEF) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nwpan_dev->pan_id = cpu_to_le16(sa->addr.pan_id);\r\nwpan_dev->short_addr = cpu_to_le16(sa->addr.short_addr);\r\nerr = mac802154_wpan_update_llsec(dev);\r\nbreak;\r\n}\r\nrtnl_unlock();\r\nreturn err;\r\n}\r\nstatic int mac802154_wpan_mac_addr(struct net_device *dev, void *p)\r\n{\r\nstruct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);\r\nstruct sockaddr *addr = p;\r\n__le64 extended_addr;\r\nif (netif_running(dev))\r\nreturn -EBUSY;\r\nif (sdata->wpan_dev.lowpan_dev) {\r\nif (netif_running(sdata->wpan_dev.lowpan_dev))\r\nreturn -EBUSY;\r\n}\r\nieee802154_be64_to_le64(&extended_addr, addr->sa_data);\r\nif (!ieee802154_is_valid_extended_unicast_addr(extended_addr))\r\nreturn -EINVAL;\r\nmemcpy(dev->dev_addr, addr->sa_data, dev->addr_len);\r\nsdata->wpan_dev.extended_addr = extended_addr;\r\nif (sdata->wpan_dev.lowpan_dev)\r\nmemcpy(sdata->wpan_dev.lowpan_dev->dev_addr, dev->dev_addr,\r\ndev->addr_len);\r\nreturn mac802154_wpan_update_llsec(dev);\r\n}\r\nstatic int ieee802154_setup_hw(struct ieee802154_sub_if_data *sdata)\r\n{\r\nstruct ieee802154_local *local = sdata->local;\r\nstruct wpan_dev *wpan_dev = &sdata->wpan_dev;\r\nint ret;\r\nif (local->hw.flags & IEEE802154_HW_PROMISCUOUS) {\r\nret = drv_set_promiscuous_mode(local,\r\nwpan_dev->promiscuous_mode);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (local->hw.flags & IEEE802154_HW_AFILT) {\r\nret = drv_set_pan_id(local, wpan_dev->pan_id);\r\nif (ret < 0)\r\nreturn ret;\r\nret = drv_set_extended_addr(local, wpan_dev->extended_addr);\r\nif (ret < 0)\r\nreturn ret;\r\nret = drv_set_short_addr(local, wpan_dev->short_addr);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (local->hw.flags & IEEE802154_HW_LBT) {\r\nret = drv_set_lbt_mode(local, wpan_dev->lbt);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (local->hw.flags & IEEE802154_HW_CSMA_PARAMS) {\r\nret = drv_set_csma_params(local, wpan_dev->min_be,\r\nwpan_dev->max_be,\r\nwpan_dev->csma_retries);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (local->hw.flags & IEEE802154_HW_FRAME_RETRIES) {\r\nret = drv_set_max_frame_retries(local, wpan_dev->frame_retries);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mac802154_slave_open(struct net_device *dev)\r\n{\r\nstruct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);\r\nstruct ieee802154_local *local = sdata->local;\r\nint res;\r\nASSERT_RTNL();\r\nset_bit(SDATA_STATE_RUNNING, &sdata->state);\r\nif (!local->open_count) {\r\nres = ieee802154_setup_hw(sdata);\r\nif (res)\r\ngoto err;\r\nres = drv_start(local);\r\nif (res)\r\ngoto err;\r\n}\r\nlocal->open_count++;\r\nnetif_start_queue(dev);\r\nreturn 0;\r\nerr:\r\nclear_bit(SDATA_STATE_RUNNING, &sdata->state);\r\nreturn res;\r\n}\r\nstatic int\r\nieee802154_check_mac_settings(struct ieee802154_local *local,\r\nstruct wpan_dev *wpan_dev,\r\nstruct wpan_dev *nwpan_dev)\r\n{\r\nASSERT_RTNL();\r\nif (local->hw.flags & IEEE802154_HW_PROMISCUOUS) {\r\nif (wpan_dev->promiscuous_mode != nwpan_dev->promiscuous_mode)\r\nreturn -EBUSY;\r\n}\r\nif (local->hw.flags & IEEE802154_HW_AFILT) {\r\nif (wpan_dev->pan_id != nwpan_dev->pan_id ||\r\nwpan_dev->short_addr != nwpan_dev->short_addr ||\r\nwpan_dev->extended_addr != nwpan_dev->extended_addr)\r\nreturn -EBUSY;\r\n}\r\nif (local->hw.flags & IEEE802154_HW_CSMA_PARAMS) {\r\nif (wpan_dev->min_be != nwpan_dev->min_be ||\r\nwpan_dev->max_be != nwpan_dev->max_be ||\r\nwpan_dev->csma_retries != nwpan_dev->csma_retries)\r\nreturn -EBUSY;\r\n}\r\nif (local->hw.flags & IEEE802154_HW_FRAME_RETRIES) {\r\nif (wpan_dev->frame_retries != nwpan_dev->frame_retries)\r\nreturn -EBUSY;\r\n}\r\nif (local->hw.flags & IEEE802154_HW_LBT) {\r\nif (wpan_dev->lbt != nwpan_dev->lbt)\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nieee802154_check_concurrent_iface(struct ieee802154_sub_if_data *sdata,\r\nenum nl802154_iftype iftype)\r\n{\r\nstruct ieee802154_local *local = sdata->local;\r\nstruct wpan_dev *wpan_dev = &sdata->wpan_dev;\r\nstruct ieee802154_sub_if_data *nsdata;\r\nlist_for_each_entry(nsdata, &local->interfaces, list) {\r\nif (nsdata != sdata && ieee802154_sdata_running(nsdata)) {\r\nint ret;\r\nif (wpan_dev->iftype == NL802154_IFTYPE_NODE &&\r\nnsdata->wpan_dev.iftype == NL802154_IFTYPE_NODE)\r\nreturn -EBUSY;\r\nret = ieee802154_check_mac_settings(local, wpan_dev,\r\n&nsdata->wpan_dev);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int mac802154_wpan_open(struct net_device *dev)\r\n{\r\nint rc;\r\nstruct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);\r\nstruct wpan_dev *wpan_dev = &sdata->wpan_dev;\r\nrc = ieee802154_check_concurrent_iface(sdata, wpan_dev->iftype);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn mac802154_slave_open(dev);\r\n}\r\nstatic int mac802154_slave_close(struct net_device *dev)\r\n{\r\nstruct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);\r\nstruct ieee802154_local *local = sdata->local;\r\nASSERT_RTNL();\r\nnetif_stop_queue(dev);\r\nlocal->open_count--;\r\nclear_bit(SDATA_STATE_RUNNING, &sdata->state);\r\nif (!local->open_count)\r\nieee802154_stop_device(local);\r\nreturn 0;\r\n}\r\nstatic int mac802154_set_header_security(struct ieee802154_sub_if_data *sdata,\r\nstruct ieee802154_hdr *hdr,\r\nconst struct ieee802154_mac_cb *cb)\r\n{\r\nstruct ieee802154_llsec_params params;\r\nu8 level;\r\nmac802154_llsec_get_params(&sdata->sec, &params);\r\nif (!params.enabled && cb->secen_override && cb->secen)\r\nreturn -EINVAL;\r\nif (!params.enabled ||\r\n(cb->secen_override && !cb->secen) ||\r\n!params.out_level)\r\nreturn 0;\r\nif (cb->seclevel_override && !cb->seclevel)\r\nreturn -EINVAL;\r\nlevel = cb->seclevel_override ? cb->seclevel : params.out_level;\r\nhdr->fc.security_enabled = 1;\r\nhdr->sec.level = level;\r\nhdr->sec.key_id_mode = params.out_key.mode;\r\nif (params.out_key.mode == IEEE802154_SCF_KEY_SHORT_INDEX)\r\nhdr->sec.short_src = params.out_key.short_source;\r\nelse if (params.out_key.mode == IEEE802154_SCF_KEY_HW_INDEX)\r\nhdr->sec.extended_src = params.out_key.extended_source;\r\nhdr->sec.key_id = params.out_key.id;\r\nreturn 0;\r\n}\r\nstatic int ieee802154_header_create(struct sk_buff *skb,\r\nstruct net_device *dev,\r\nconst struct ieee802154_addr *daddr,\r\nconst struct ieee802154_addr *saddr,\r\nunsigned len)\r\n{\r\nstruct ieee802154_hdr hdr;\r\nstruct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);\r\nstruct wpan_dev *wpan_dev = &sdata->wpan_dev;\r\nstruct ieee802154_mac_cb *cb = mac_cb(skb);\r\nint hlen;\r\nif (!daddr)\r\nreturn -EINVAL;\r\nmemset(&hdr.fc, 0, sizeof(hdr.fc));\r\nhdr.fc.type = cb->type;\r\nhdr.fc.security_enabled = cb->secen;\r\nhdr.fc.ack_request = cb->ackreq;\r\nhdr.seq = atomic_inc_return(&dev->ieee802154_ptr->dsn) & 0xFF;\r\nif (mac802154_set_header_security(sdata, &hdr, cb) < 0)\r\nreturn -EINVAL;\r\nif (!saddr) {\r\nif (wpan_dev->short_addr == cpu_to_le16(IEEE802154_ADDR_BROADCAST) ||\r\nwpan_dev->short_addr == cpu_to_le16(IEEE802154_ADDR_UNDEF) ||\r\nwpan_dev->pan_id == cpu_to_le16(IEEE802154_PANID_BROADCAST)) {\r\nhdr.source.mode = IEEE802154_ADDR_LONG;\r\nhdr.source.extended_addr = wpan_dev->extended_addr;\r\n} else {\r\nhdr.source.mode = IEEE802154_ADDR_SHORT;\r\nhdr.source.short_addr = wpan_dev->short_addr;\r\n}\r\nhdr.source.pan_id = wpan_dev->pan_id;\r\n} else {\r\nhdr.source = *(const struct ieee802154_addr *)saddr;\r\n}\r\nhdr.dest = *(const struct ieee802154_addr *)daddr;\r\nhlen = ieee802154_hdr_push(skb, &hdr);\r\nif (hlen < 0)\r\nreturn -EINVAL;\r\nskb_reset_mac_header(skb);\r\nskb->mac_len = hlen;\r\nif (len > ieee802154_max_payload(&hdr))\r\nreturn -EMSGSIZE;\r\nreturn hlen;\r\n}\r\nstatic int mac802154_header_create(struct sk_buff *skb,\r\nstruct net_device *dev,\r\nunsigned short type,\r\nconst void *daddr,\r\nconst void *saddr,\r\nunsigned len)\r\n{\r\nstruct ieee802154_hdr hdr;\r\nstruct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);\r\nstruct wpan_dev *wpan_dev = &sdata->wpan_dev;\r\nstruct ieee802154_mac_cb cb = { };\r\nint hlen;\r\nif (!daddr)\r\nreturn -EINVAL;\r\nmemset(&hdr.fc, 0, sizeof(hdr.fc));\r\nhdr.fc.type = IEEE802154_FC_TYPE_DATA;\r\nhdr.fc.ack_request = wpan_dev->ackreq;\r\nhdr.seq = atomic_inc_return(&dev->ieee802154_ptr->dsn) & 0xFF;\r\nif (mac802154_set_header_security(sdata, &hdr, &cb) < 0)\r\nreturn -EINVAL;\r\nhdr.dest.pan_id = wpan_dev->pan_id;\r\nhdr.dest.mode = IEEE802154_ADDR_LONG;\r\nieee802154_be64_to_le64(&hdr.dest.extended_addr, daddr);\r\nhdr.source.pan_id = hdr.dest.pan_id;\r\nhdr.source.mode = IEEE802154_ADDR_LONG;\r\nif (!saddr)\r\nhdr.source.extended_addr = wpan_dev->extended_addr;\r\nelse\r\nieee802154_be64_to_le64(&hdr.source.extended_addr, saddr);\r\nhlen = ieee802154_hdr_push(skb, &hdr);\r\nif (hlen < 0)\r\nreturn -EINVAL;\r\nskb_reset_mac_header(skb);\r\nskb->mac_len = hlen;\r\nif (len > ieee802154_max_payload(&hdr))\r\nreturn -EMSGSIZE;\r\nreturn hlen;\r\n}\r\nstatic int\r\nmac802154_header_parse(const struct sk_buff *skb, unsigned char *haddr)\r\n{\r\nstruct ieee802154_hdr hdr;\r\nif (ieee802154_hdr_peek_addrs(skb, &hdr) < 0) {\r\npr_debug("malformed packet\n");\r\nreturn 0;\r\n}\r\nif (hdr.source.mode == IEEE802154_ADDR_LONG) {\r\nieee802154_le64_to_be64(haddr, &hdr.source.extended_addr);\r\nreturn IEEE802154_EXTENDED_ADDR_LEN;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mac802154_wpan_free(struct net_device *dev)\r\n{\r\nstruct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);\r\nmac802154_llsec_destroy(&sdata->sec);\r\n}\r\nstatic void ieee802154_if_setup(struct net_device *dev)\r\n{\r\ndev->addr_len = IEEE802154_EXTENDED_ADDR_LEN;\r\nmemset(dev->broadcast, 0xff, IEEE802154_EXTENDED_ADDR_LEN);\r\ndev->hard_header_len = IEEE802154_MIN_HEADER_LEN - 1;\r\ndev->needed_tailroom = IEEE802154_MAX_AUTH_TAG_LEN +\r\nIEEE802154_FCS_LEN;\r\ndev->mtu = IEEE802154_MTU - IEEE802154_FCS_LEN -\r\ndev->hard_header_len;\r\ndev->tx_queue_len = 300;\r\ndev->flags = IFF_NOARP | IFF_BROADCAST;\r\n}\r\nstatic int\r\nieee802154_setup_sdata(struct ieee802154_sub_if_data *sdata,\r\nenum nl802154_iftype type)\r\n{\r\nstruct wpan_dev *wpan_dev = &sdata->wpan_dev;\r\nint ret;\r\nu8 tmp;\r\nsdata->wpan_dev.iftype = type;\r\nget_random_bytes(&tmp, sizeof(tmp));\r\natomic_set(&wpan_dev->bsn, tmp);\r\nget_random_bytes(&tmp, sizeof(tmp));\r\natomic_set(&wpan_dev->dsn, tmp);\r\nwpan_dev->min_be = 3;\r\nwpan_dev->max_be = 5;\r\nwpan_dev->csma_retries = 4;\r\nwpan_dev->frame_retries = 3;\r\nwpan_dev->pan_id = cpu_to_le16(IEEE802154_PANID_BROADCAST);\r\nwpan_dev->short_addr = cpu_to_le16(IEEE802154_ADDR_BROADCAST);\r\nswitch (type) {\r\ncase NL802154_IFTYPE_NODE:\r\nieee802154_be64_to_le64(&wpan_dev->extended_addr,\r\nsdata->dev->dev_addr);\r\nsdata->dev->header_ops = &mac802154_header_ops;\r\nsdata->dev->needs_free_netdev = true;\r\nsdata->dev->priv_destructor = mac802154_wpan_free;\r\nsdata->dev->netdev_ops = &mac802154_wpan_ops;\r\nsdata->dev->ml_priv = &mac802154_mlme_wpan;\r\nwpan_dev->promiscuous_mode = false;\r\nwpan_dev->header_ops = &ieee802154_header_ops;\r\nmutex_init(&sdata->sec_mtx);\r\nmac802154_llsec_init(&sdata->sec);\r\nret = mac802154_wpan_update_llsec(sdata->dev);\r\nif (ret < 0)\r\nreturn ret;\r\nbreak;\r\ncase NL802154_IFTYPE_MONITOR:\r\nsdata->dev->needs_free_netdev = true;\r\nsdata->dev->netdev_ops = &mac802154_monitor_ops;\r\nwpan_dev->promiscuous_mode = true;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nreturn 0;\r\n}\r\nstruct net_device *\r\nieee802154_if_add(struct ieee802154_local *local, const char *name,\r\nunsigned char name_assign_type, enum nl802154_iftype type,\r\n__le64 extended_addr)\r\n{\r\nstruct net_device *ndev = NULL;\r\nstruct ieee802154_sub_if_data *sdata = NULL;\r\nint ret = -ENOMEM;\r\nASSERT_RTNL();\r\nndev = alloc_netdev(sizeof(*sdata), name,\r\nname_assign_type, ieee802154_if_setup);\r\nif (!ndev)\r\nreturn ERR_PTR(-ENOMEM);\r\nndev->needed_headroom = local->hw.extra_tx_headroom +\r\nIEEE802154_MAX_HEADER_LEN;\r\nret = dev_alloc_name(ndev, ndev->name);\r\nif (ret < 0)\r\ngoto err;\r\nieee802154_le64_to_be64(ndev->perm_addr,\r\n&local->hw.phy->perm_extended_addr);\r\nswitch (type) {\r\ncase NL802154_IFTYPE_NODE:\r\nndev->type = ARPHRD_IEEE802154;\r\nif (ieee802154_is_valid_extended_unicast_addr(extended_addr))\r\nieee802154_le64_to_be64(ndev->dev_addr, &extended_addr);\r\nelse\r\nmemcpy(ndev->dev_addr, ndev->perm_addr,\r\nIEEE802154_EXTENDED_ADDR_LEN);\r\nbreak;\r\ncase NL802154_IFTYPE_MONITOR:\r\nndev->type = ARPHRD_IEEE802154_MONITOR;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nSET_NETDEV_DEV(ndev, &local->phy->dev);\r\ndev_net_set(ndev, wpan_phy_net(local->hw.phy));\r\nsdata = netdev_priv(ndev);\r\nndev->ieee802154_ptr = &sdata->wpan_dev;\r\nmemcpy(sdata->name, ndev->name, IFNAMSIZ);\r\nsdata->dev = ndev;\r\nsdata->wpan_dev.wpan_phy = local->hw.phy;\r\nsdata->local = local;\r\nret = ieee802154_setup_sdata(sdata, type);\r\nif (ret)\r\ngoto err;\r\nret = register_netdevice(ndev);\r\nif (ret < 0)\r\ngoto err;\r\nmutex_lock(&local->iflist_mtx);\r\nlist_add_tail_rcu(&sdata->list, &local->interfaces);\r\nmutex_unlock(&local->iflist_mtx);\r\nreturn ndev;\r\nerr:\r\nfree_netdev(ndev);\r\nreturn ERR_PTR(ret);\r\n}\r\nvoid ieee802154_if_remove(struct ieee802154_sub_if_data *sdata)\r\n{\r\nASSERT_RTNL();\r\nmutex_lock(&sdata->local->iflist_mtx);\r\nlist_del_rcu(&sdata->list);\r\nmutex_unlock(&sdata->local->iflist_mtx);\r\nsynchronize_rcu();\r\nunregister_netdevice(sdata->dev);\r\n}\r\nvoid ieee802154_remove_interfaces(struct ieee802154_local *local)\r\n{\r\nstruct ieee802154_sub_if_data *sdata, *tmp;\r\nmutex_lock(&local->iflist_mtx);\r\nlist_for_each_entry_safe(sdata, tmp, &local->interfaces, list) {\r\nlist_del(&sdata->list);\r\nunregister_netdevice(sdata->dev);\r\n}\r\nmutex_unlock(&local->iflist_mtx);\r\n}\r\nstatic int netdev_notify(struct notifier_block *nb,\r\nunsigned long state, void *ptr)\r\n{\r\nstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\r\nstruct ieee802154_sub_if_data *sdata;\r\nif (state != NETDEV_CHANGENAME)\r\nreturn NOTIFY_DONE;\r\nif (!dev->ieee802154_ptr || !dev->ieee802154_ptr->wpan_phy)\r\nreturn NOTIFY_DONE;\r\nif (dev->ieee802154_ptr->wpan_phy->privid != mac802154_wpan_phy_privid)\r\nreturn NOTIFY_DONE;\r\nsdata = IEEE802154_DEV_TO_SUB_IF(dev);\r\nmemcpy(sdata->name, dev->name, IFNAMSIZ);\r\nreturn NOTIFY_OK;\r\n}\r\nint ieee802154_iface_init(void)\r\n{\r\nreturn register_netdevice_notifier(&mac802154_netdev_notifier);\r\n}\r\nvoid ieee802154_iface_exit(void)\r\n{\r\nunregister_netdevice_notifier(&mac802154_netdev_notifier);\r\n}
