static void dt3k_send_cmd(struct comedi_device *dev, unsigned int cmd)\r\n{\r\nint i;\r\nunsigned int status = 0;\r\nwritew(cmd, dev->mmio + DPR_CMD_MBX);\r\nfor (i = 0; i < DPR_CMD_TIMEOUT; i++) {\r\nstatus = readw(dev->mmio + DPR_CMD_MBX);\r\nstatus &= DPR_CMD_COMPLETION_MASK;\r\nif (status != DPR_CMD_NOTPROCESSED)\r\nbreak;\r\nudelay(1);\r\n}\r\nif (status != DPR_CMD_NOERROR)\r\ndev_dbg(dev->class_dev, "%s: timeout/error status=0x%04x\n",\r\n__func__, status);\r\n}\r\nstatic unsigned int dt3k_readsingle(struct comedi_device *dev,\r\nunsigned int subsys, unsigned int chan,\r\nunsigned int gain)\r\n{\r\nwritew(subsys, dev->mmio + DPR_SUBSYS);\r\nwritew(chan, dev->mmio + DPR_PARAMS(0));\r\nwritew(gain, dev->mmio + DPR_PARAMS(1));\r\ndt3k_send_cmd(dev, DPR_CMD_READSINGLE);\r\nreturn readw(dev->mmio + DPR_PARAMS(2));\r\n}\r\nstatic void dt3k_writesingle(struct comedi_device *dev, unsigned int subsys,\r\nunsigned int chan, unsigned int data)\r\n{\r\nwritew(subsys, dev->mmio + DPR_SUBSYS);\r\nwritew(chan, dev->mmio + DPR_PARAMS(0));\r\nwritew(0, dev->mmio + DPR_PARAMS(1));\r\nwritew(data, dev->mmio + DPR_PARAMS(2));\r\ndt3k_send_cmd(dev, DPR_CMD_WRITESINGLE);\r\n}\r\nstatic void dt3k_ai_empty_fifo(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct dt3k_private *devpriv = dev->private;\r\nint front;\r\nint rear;\r\nint count;\r\nint i;\r\nunsigned short data;\r\nfront = readw(dev->mmio + DPR_AD_BUF_FRONT);\r\ncount = front - devpriv->ai_front;\r\nif (count < 0)\r\ncount += DPR_AI_FIFO_DEPTH;\r\nrear = devpriv->ai_rear;\r\nfor (i = 0; i < count; i++) {\r\ndata = readw(dev->mmio + DPR_ADC_BUFFER + rear);\r\ncomedi_buf_write_samples(s, &data, 1);\r\nrear++;\r\nif (rear >= DPR_AI_FIFO_DEPTH)\r\nrear = 0;\r\n}\r\ndevpriv->ai_rear = rear;\r\nwritew(rear, dev->mmio + DPR_AD_BUF_REAR);\r\n}\r\nstatic int dt3k_ai_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nwritew(DPR_SUBSYS_AI, dev->mmio + DPR_SUBSYS);\r\ndt3k_send_cmd(dev, DPR_CMD_STOP);\r\nwritew(0, dev->mmio + DPR_INT_MASK);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t dt3k_interrupt(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nunsigned int status;\r\nif (!dev->attached)\r\nreturn IRQ_NONE;\r\nstatus = readw(dev->mmio + DPR_INTR_FLAG);\r\nif (status & DPR_INTR_ADFULL)\r\ndt3k_ai_empty_fifo(dev, s);\r\nif (status & (DPR_INTR_ADSWERR | DPR_INTR_ADHWERR))\r\ns->async->events |= COMEDI_CB_ERROR;\r\ndebug_n_ints++;\r\nif (debug_n_ints >= 10)\r\ns->async->events |= COMEDI_CB_EOA;\r\ncomedi_handle_events(dev, s);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int dt3k_ns_to_timer(unsigned int timer_base, unsigned int *nanosec,\r\nunsigned int flags)\r\n{\r\nint divider, base, prescale;\r\nfor (prescale = 0; prescale < 16; prescale++) {\r\nbase = timer_base * (prescale + 1);\r\nswitch (flags & CMDF_ROUND_MASK) {\r\ncase CMDF_ROUND_NEAREST:\r\ndefault:\r\ndivider = DIV_ROUND_CLOSEST(*nanosec, base);\r\nbreak;\r\ncase CMDF_ROUND_DOWN:\r\ndivider = (*nanosec) / base;\r\nbreak;\r\ncase CMDF_ROUND_UP:\r\ndivider = (*nanosec) / base;\r\nbreak;\r\n}\r\nif (divider < 65536) {\r\n*nanosec = divider * base;\r\nreturn (prescale << 16) | (divider);\r\n}\r\n}\r\nprescale = 15;\r\nbase = timer_base * (1 << prescale);\r\ndivider = 65535;\r\n*nanosec = divider * base;\r\nreturn (prescale << 16) | (divider);\r\n}\r\nstatic int dt3k_ai_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_cmd *cmd)\r\n{\r\nconst struct dt3k_boardtype *board = dev->board_ptr;\r\nint err = 0;\r\nunsigned int arg;\r\nerr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW);\r\nerr |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_TIMER);\r\nerr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_TIMER);\r\nerr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT);\r\nif (err)\r\nreturn 1;\r\nerr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nerr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,\r\nboard->ai_speed);\r\nerr |= comedi_check_trigger_arg_max(&cmd->scan_begin_arg,\r\n100 * 16 * 65535);\r\n}\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nerr |= comedi_check_trigger_arg_min(&cmd->convert_arg,\r\nboard->ai_speed);\r\nerr |= comedi_check_trigger_arg_max(&cmd->convert_arg,\r\n50 * 16 * 65535);\r\n}\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\r\ncmd->chanlist_len);\r\nif (cmd->stop_src == TRIG_COUNT)\r\nerr |= comedi_check_trigger_arg_max(&cmd->stop_arg, 0x00ffffff);\r\nelse\r\nerr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\r\nif (err)\r\nreturn 3;\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\narg = cmd->scan_begin_arg;\r\ndt3k_ns_to_timer(100, &arg, cmd->flags);\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, arg);\r\n}\r\nif (cmd->convert_src == TRIG_TIMER) {\r\narg = cmd->convert_arg;\r\ndt3k_ns_to_timer(50, &arg, cmd->flags);\r\nerr |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg);\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\narg = cmd->convert_arg * cmd->scan_end_arg;\r\nerr |= comedi_check_trigger_arg_min(&cmd->\r\nscan_begin_arg,\r\narg);\r\n}\r\n}\r\nif (err)\r\nreturn 4;\r\nreturn 0;\r\n}\r\nstatic int dt3k_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nint i;\r\nunsigned int chan, range, aref;\r\nunsigned int divider;\r\nunsigned int tscandiv;\r\nfor (i = 0; i < cmd->chanlist_len; i++) {\r\nchan = CR_CHAN(cmd->chanlist[i]);\r\nrange = CR_RANGE(cmd->chanlist[i]);\r\nwritew((range << 6) | chan, dev->mmio + DPR_ADC_BUFFER + i);\r\n}\r\naref = CR_AREF(cmd->chanlist[0]);\r\nwritew(cmd->scan_end_arg, dev->mmio + DPR_PARAMS(0));\r\nif (cmd->convert_src == TRIG_TIMER) {\r\ndivider = dt3k_ns_to_timer(50, &cmd->convert_arg, cmd->flags);\r\nwritew((divider >> 16), dev->mmio + DPR_PARAMS(1));\r\nwritew((divider & 0xffff), dev->mmio + DPR_PARAMS(2));\r\n}\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\ntscandiv = dt3k_ns_to_timer(100, &cmd->scan_begin_arg,\r\ncmd->flags);\r\nwritew((tscandiv >> 16), dev->mmio + DPR_PARAMS(3));\r\nwritew((tscandiv & 0xffff), dev->mmio + DPR_PARAMS(4));\r\n}\r\nwritew(DPR_PARAM5_AD_TRIG_INT_RETRIG, dev->mmio + DPR_PARAMS(5));\r\nwritew((aref == AREF_DIFF) ? DPR_PARAM6_AD_DIFF : 0,\r\ndev->mmio + DPR_PARAMS(6));\r\nwritew(DPR_AI_FIFO_DEPTH / 2, dev->mmio + DPR_PARAMS(7));\r\nwritew(DPR_SUBSYS_AI, dev->mmio + DPR_SUBSYS);\r\ndt3k_send_cmd(dev, DPR_CMD_CONFIG);\r\nwritew(DPR_INTR_ADFULL | DPR_INTR_ADSWERR | DPR_INTR_ADHWERR,\r\ndev->mmio + DPR_INT_MASK);\r\ndebug_n_ints = 0;\r\nwritew(DPR_SUBSYS_AI, dev->mmio + DPR_SUBSYS);\r\ndt3k_send_cmd(dev, DPR_CMD_START);\r\nreturn 0;\r\n}\r\nstatic int dt3k_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nint i;\r\nunsigned int chan, gain, aref;\r\nchan = CR_CHAN(insn->chanspec);\r\ngain = CR_RANGE(insn->chanspec);\r\naref = CR_AREF(insn->chanspec);\r\nfor (i = 0; i < insn->n; i++)\r\ndata[i] = dt3k_readsingle(dev, DPR_SUBSYS_AI, chan, gain);\r\nreturn i;\r\n}\r\nstatic int dt3k_ao_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int val = s->readback[chan];\r\nint i;\r\nfor (i = 0; i < insn->n; i++) {\r\nval = data[i];\r\ndt3k_writesingle(dev, DPR_SUBSYS_AO, chan, val);\r\n}\r\ns->readback[chan] = val;\r\nreturn insn->n;\r\n}\r\nstatic void dt3k_dio_config(struct comedi_device *dev, int bits)\r\n{\r\nwritew(DPR_SUBSYS_DOUT, dev->mmio + DPR_SUBSYS);\r\nwritew(bits, dev->mmio + DPR_PARAMS(0));\r\ndt3k_send_cmd(dev, DPR_CMD_CONFIG);\r\n}\r\nstatic int dt3k_dio_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int mask;\r\nint ret;\r\nif (chan < 4)\r\nmask = 0x0f;\r\nelse\r\nmask = 0xf0;\r\nret = comedi_dio_insn_config(dev, s, insn, data, mask);\r\nif (ret)\r\nreturn ret;\r\ndt3k_dio_config(dev, (s->io_bits & 0x01) | ((s->io_bits & 0x10) >> 3));\r\nreturn insn->n;\r\n}\r\nstatic int dt3k_dio_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nif (comedi_dio_update_state(s, data))\r\ndt3k_writesingle(dev, DPR_SUBSYS_DOUT, 0, s->state);\r\ndata[1] = dt3k_readsingle(dev, DPR_SUBSYS_DIN, 0, 0);\r\nreturn insn->n;\r\n}\r\nstatic int dt3k_mem_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int addr = CR_CHAN(insn->chanspec);\r\nint i;\r\nfor (i = 0; i < insn->n; i++) {\r\nwritew(DPR_SUBSYS_MEM, dev->mmio + DPR_SUBSYS);\r\nwritew(addr, dev->mmio + DPR_PARAMS(0));\r\nwritew(1, dev->mmio + DPR_PARAMS(1));\r\ndt3k_send_cmd(dev, DPR_CMD_READCODE);\r\ndata[i] = readw(dev->mmio + DPR_PARAMS(2));\r\n}\r\nreturn i;\r\n}\r\nstatic int dt3000_auto_attach(struct comedi_device *dev,\r\nunsigned long context)\r\n{\r\nstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\r\nconst struct dt3k_boardtype *board = NULL;\r\nstruct dt3k_private *devpriv;\r\nstruct comedi_subdevice *s;\r\nint ret = 0;\r\nif (context < ARRAY_SIZE(dt3k_boardtypes))\r\nboard = &dt3k_boardtypes[context];\r\nif (!board)\r\nreturn -ENODEV;\r\ndev->board_ptr = board;\r\ndev->board_name = board->name;\r\ndevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\nret = comedi_pci_enable(dev);\r\nif (ret < 0)\r\nreturn ret;\r\ndev->mmio = pci_ioremap_bar(pcidev, 0);\r\nif (!dev->mmio)\r\nreturn -ENOMEM;\r\nif (pcidev->irq) {\r\nret = request_irq(pcidev->irq, dt3k_interrupt, IRQF_SHARED,\r\ndev->board_name, dev);\r\nif (ret == 0)\r\ndev->irq = pcidev->irq;\r\n}\r\nret = comedi_alloc_subdevices(dev, 4);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[0];\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_DIFF;\r\ns->n_chan = board->adchan;\r\ns->maxdata = board->ai_is_16bit ? 0xffff : 0x0fff;\r\ns->range_table = &range_dt3000_ai;\r\ns->insn_read = dt3k_ai_insn_read;\r\nif (dev->irq) {\r\ndev->read_subdev = s;\r\ns->subdev_flags |= SDF_CMD_READ;\r\ns->len_chanlist = 512;\r\ns->do_cmd = dt3k_ai_cmd;\r\ns->do_cmdtest = dt3k_ai_cmdtest;\r\ns->cancel = dt3k_ai_cancel;\r\n}\r\ns = &dev->subdevices[1];\r\nif (board->has_ao) {\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE;\r\ns->n_chan = 2;\r\ns->maxdata = 0x0fff;\r\ns->range_table = &range_bipolar10;\r\ns->insn_write = dt3k_ao_insn_write;\r\nret = comedi_alloc_subdev_readback(s);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ns = &dev->subdevices[2];\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE;\r\ns->n_chan = 8;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_config = dt3k_dio_insn_config;\r\ns->insn_bits = dt3k_dio_insn_bits;\r\ns = &dev->subdevices[3];\r\ns->type = COMEDI_SUBD_MEMORY;\r\ns->subdev_flags = SDF_READABLE;\r\ns->n_chan = 0x1000;\r\ns->maxdata = 0xff;\r\ns->range_table = &range_unknown;\r\ns->insn_read = dt3k_mem_insn_read;\r\nreturn 0;\r\n}\r\nstatic int dt3000_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nreturn comedi_pci_auto_config(dev, &dt3000_driver, id->driver_data);\r\n}
