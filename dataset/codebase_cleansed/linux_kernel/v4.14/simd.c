static int simd_skcipher_setkey(struct crypto_skcipher *tfm, const u8 *key,\r\nunsigned int key_len)\r\n{\r\nstruct simd_skcipher_ctx *ctx = crypto_skcipher_ctx(tfm);\r\nstruct crypto_skcipher *child = &ctx->cryptd_tfm->base;\r\nint err;\r\ncrypto_skcipher_clear_flags(child, CRYPTO_TFM_REQ_MASK);\r\ncrypto_skcipher_set_flags(child, crypto_skcipher_get_flags(tfm) &\r\nCRYPTO_TFM_REQ_MASK);\r\nerr = crypto_skcipher_setkey(child, key, key_len);\r\ncrypto_skcipher_set_flags(tfm, crypto_skcipher_get_flags(child) &\r\nCRYPTO_TFM_RES_MASK);\r\nreturn err;\r\n}\r\nstatic int simd_skcipher_encrypt(struct skcipher_request *req)\r\n{\r\nstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\r\nstruct simd_skcipher_ctx *ctx = crypto_skcipher_ctx(tfm);\r\nstruct skcipher_request *subreq;\r\nstruct crypto_skcipher *child;\r\nsubreq = skcipher_request_ctx(req);\r\n*subreq = *req;\r\nif (!may_use_simd() ||\r\n(in_atomic() && cryptd_skcipher_queued(ctx->cryptd_tfm)))\r\nchild = &ctx->cryptd_tfm->base;\r\nelse\r\nchild = cryptd_skcipher_child(ctx->cryptd_tfm);\r\nskcipher_request_set_tfm(subreq, child);\r\nreturn crypto_skcipher_encrypt(subreq);\r\n}\r\nstatic int simd_skcipher_decrypt(struct skcipher_request *req)\r\n{\r\nstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\r\nstruct simd_skcipher_ctx *ctx = crypto_skcipher_ctx(tfm);\r\nstruct skcipher_request *subreq;\r\nstruct crypto_skcipher *child;\r\nsubreq = skcipher_request_ctx(req);\r\n*subreq = *req;\r\nif (!may_use_simd() ||\r\n(in_atomic() && cryptd_skcipher_queued(ctx->cryptd_tfm)))\r\nchild = &ctx->cryptd_tfm->base;\r\nelse\r\nchild = cryptd_skcipher_child(ctx->cryptd_tfm);\r\nskcipher_request_set_tfm(subreq, child);\r\nreturn crypto_skcipher_decrypt(subreq);\r\n}\r\nstatic void simd_skcipher_exit(struct crypto_skcipher *tfm)\r\n{\r\nstruct simd_skcipher_ctx *ctx = crypto_skcipher_ctx(tfm);\r\ncryptd_free_skcipher(ctx->cryptd_tfm);\r\n}\r\nstatic int simd_skcipher_init(struct crypto_skcipher *tfm)\r\n{\r\nstruct simd_skcipher_ctx *ctx = crypto_skcipher_ctx(tfm);\r\nstruct cryptd_skcipher *cryptd_tfm;\r\nstruct simd_skcipher_alg *salg;\r\nstruct skcipher_alg *alg;\r\nunsigned reqsize;\r\nalg = crypto_skcipher_alg(tfm);\r\nsalg = container_of(alg, struct simd_skcipher_alg, alg);\r\ncryptd_tfm = cryptd_alloc_skcipher(salg->ialg_name,\r\nCRYPTO_ALG_INTERNAL,\r\nCRYPTO_ALG_INTERNAL);\r\nif (IS_ERR(cryptd_tfm))\r\nreturn PTR_ERR(cryptd_tfm);\r\nctx->cryptd_tfm = cryptd_tfm;\r\nreqsize = sizeof(struct skcipher_request);\r\nreqsize += crypto_skcipher_reqsize(&cryptd_tfm->base);\r\ncrypto_skcipher_set_reqsize(tfm, reqsize);\r\nreturn 0;\r\n}\r\nstruct simd_skcipher_alg *simd_skcipher_create_compat(const char *algname,\r\nconst char *drvname,\r\nconst char *basename)\r\n{\r\nstruct simd_skcipher_alg *salg;\r\nstruct crypto_skcipher *tfm;\r\nstruct skcipher_alg *ialg;\r\nstruct skcipher_alg *alg;\r\nint err;\r\ntfm = crypto_alloc_skcipher(basename, CRYPTO_ALG_INTERNAL,\r\nCRYPTO_ALG_INTERNAL | CRYPTO_ALG_ASYNC);\r\nif (IS_ERR(tfm))\r\nreturn ERR_CAST(tfm);\r\nialg = crypto_skcipher_alg(tfm);\r\nsalg = kzalloc(sizeof(*salg), GFP_KERNEL);\r\nif (!salg) {\r\nsalg = ERR_PTR(-ENOMEM);\r\ngoto out_put_tfm;\r\n}\r\nsalg->ialg_name = basename;\r\nalg = &salg->alg;\r\nerr = -ENAMETOOLONG;\r\nif (snprintf(alg->base.cra_name, CRYPTO_MAX_ALG_NAME, "%s", algname) >=\r\nCRYPTO_MAX_ALG_NAME)\r\ngoto out_free_salg;\r\nif (snprintf(alg->base.cra_driver_name, CRYPTO_MAX_ALG_NAME, "%s",\r\ndrvname) >= CRYPTO_MAX_ALG_NAME)\r\ngoto out_free_salg;\r\nalg->base.cra_flags = CRYPTO_ALG_ASYNC;\r\nalg->base.cra_priority = ialg->base.cra_priority;\r\nalg->base.cra_blocksize = ialg->base.cra_blocksize;\r\nalg->base.cra_alignmask = ialg->base.cra_alignmask;\r\nalg->base.cra_module = ialg->base.cra_module;\r\nalg->base.cra_ctxsize = sizeof(struct simd_skcipher_ctx);\r\nalg->ivsize = ialg->ivsize;\r\nalg->chunksize = ialg->chunksize;\r\nalg->min_keysize = ialg->min_keysize;\r\nalg->max_keysize = ialg->max_keysize;\r\nalg->init = simd_skcipher_init;\r\nalg->exit = simd_skcipher_exit;\r\nalg->setkey = simd_skcipher_setkey;\r\nalg->encrypt = simd_skcipher_encrypt;\r\nalg->decrypt = simd_skcipher_decrypt;\r\nerr = crypto_register_skcipher(alg);\r\nif (err)\r\ngoto out_free_salg;\r\nout_put_tfm:\r\ncrypto_free_skcipher(tfm);\r\nreturn salg;\r\nout_free_salg:\r\nkfree(salg);\r\nsalg = ERR_PTR(err);\r\ngoto out_put_tfm;\r\n}\r\nstruct simd_skcipher_alg *simd_skcipher_create(const char *algname,\r\nconst char *basename)\r\n{\r\nchar drvname[CRYPTO_MAX_ALG_NAME];\r\nif (snprintf(drvname, CRYPTO_MAX_ALG_NAME, "simd-%s", basename) >=\r\nCRYPTO_MAX_ALG_NAME)\r\nreturn ERR_PTR(-ENAMETOOLONG);\r\nreturn simd_skcipher_create_compat(algname, drvname, basename);\r\n}\r\nvoid simd_skcipher_free(struct simd_skcipher_alg *salg)\r\n{\r\ncrypto_unregister_skcipher(&salg->alg);\r\nkfree(salg);\r\n}
