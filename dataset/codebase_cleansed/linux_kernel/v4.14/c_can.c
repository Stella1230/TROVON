static inline void c_can_pm_runtime_enable(const struct c_can_priv *priv)\r\n{\r\nif (priv->device)\r\npm_runtime_enable(priv->device);\r\n}\r\nstatic inline void c_can_pm_runtime_disable(const struct c_can_priv *priv)\r\n{\r\nif (priv->device)\r\npm_runtime_disable(priv->device);\r\n}\r\nstatic inline void c_can_pm_runtime_get_sync(const struct c_can_priv *priv)\r\n{\r\nif (priv->device)\r\npm_runtime_get_sync(priv->device);\r\n}\r\nstatic inline void c_can_pm_runtime_put_sync(const struct c_can_priv *priv)\r\n{\r\nif (priv->device)\r\npm_runtime_put_sync(priv->device);\r\n}\r\nstatic inline void c_can_reset_ram(const struct c_can_priv *priv, bool enable)\r\n{\r\nif (priv->raminit)\r\npriv->raminit(priv, enable);\r\n}\r\nstatic void c_can_irq_control(struct c_can_priv *priv, bool enable)\r\n{\r\nu32 ctrl = priv->read_reg(priv, C_CAN_CTRL_REG) & ~CONTROL_IRQMSK;\r\nif (enable)\r\nctrl |= CONTROL_IRQMSK;\r\npriv->write_reg(priv, C_CAN_CTRL_REG, ctrl);\r\n}\r\nstatic void c_can_obj_update(struct net_device *dev, int iface, u32 cmd, u32 obj)\r\n{\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\nint cnt, reg = C_CAN_IFACE(COMREQ_REG, iface);\r\npriv->write_reg32(priv, reg, (cmd << 16) | obj);\r\nfor (cnt = MIN_TIMEOUT_VALUE; cnt; cnt--) {\r\nif (!(priv->read_reg(priv, reg) & IF_COMR_BUSY))\r\nreturn;\r\nudelay(1);\r\n}\r\nnetdev_err(dev, "Updating object timed out\n");\r\n}\r\nstatic inline void c_can_object_get(struct net_device *dev, int iface,\r\nu32 obj, u32 cmd)\r\n{\r\nc_can_obj_update(dev, iface, cmd, obj);\r\n}\r\nstatic inline void c_can_object_put(struct net_device *dev, int iface,\r\nu32 obj, u32 cmd)\r\n{\r\nc_can_obj_update(dev, iface, cmd | IF_COMM_WR, obj);\r\n}\r\nstatic void c_can_inval_tx_object(struct net_device *dev, int iface, int obj)\r\n{\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\npriv->write_reg(priv, C_CAN_IFACE(MSGCTRL_REG, iface), 0);\r\nc_can_object_put(dev, iface, obj, IF_COMM_INVAL);\r\n}\r\nstatic void c_can_inval_msg_object(struct net_device *dev, int iface, int obj)\r\n{\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\npriv->write_reg(priv, C_CAN_IFACE(ARB1_REG, iface), 0);\r\npriv->write_reg(priv, C_CAN_IFACE(ARB2_REG, iface), 0);\r\nc_can_inval_tx_object(dev, iface, obj);\r\n}\r\nstatic void c_can_setup_tx_object(struct net_device *dev, int iface,\r\nstruct can_frame *frame, int idx)\r\n{\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\nu16 ctrl = IF_MCONT_TX | frame->can_dlc;\r\nbool rtr = frame->can_id & CAN_RTR_FLAG;\r\nu32 arb = IF_ARB_MSGVAL;\r\nint i;\r\nif (frame->can_id & CAN_EFF_FLAG) {\r\narb |= frame->can_id & CAN_EFF_MASK;\r\narb |= IF_ARB_MSGXTD;\r\n} else {\r\narb |= (frame->can_id & CAN_SFF_MASK) << 18;\r\n}\r\nif (!rtr)\r\narb |= IF_ARB_TRANSMIT;\r\nif (rtr != (bool)test_bit(idx, &priv->tx_dir)) {\r\nu32 obj = idx + C_CAN_MSG_OBJ_TX_FIRST;\r\nc_can_inval_msg_object(dev, iface, obj);\r\nchange_bit(idx, &priv->tx_dir);\r\n}\r\npriv->write_reg32(priv, C_CAN_IFACE(ARB1_REG, iface), arb);\r\npriv->write_reg(priv, C_CAN_IFACE(MSGCTRL_REG, iface), ctrl);\r\nif (priv->type == BOSCH_D_CAN) {\r\nu32 data = 0, dreg = C_CAN_IFACE(DATA1_REG, iface);\r\nfor (i = 0; i < frame->can_dlc; i += 4, dreg += 2) {\r\ndata = (u32)frame->data[i];\r\ndata |= (u32)frame->data[i + 1] << 8;\r\ndata |= (u32)frame->data[i + 2] << 16;\r\ndata |= (u32)frame->data[i + 3] << 24;\r\npriv->write_reg32(priv, dreg, data);\r\n}\r\n} else {\r\nfor (i = 0; i < frame->can_dlc; i += 2) {\r\npriv->write_reg(priv,\r\nC_CAN_IFACE(DATA1_REG, iface) + i / 2,\r\nframe->data[i] |\r\n(frame->data[i + 1] << 8));\r\n}\r\n}\r\n}\r\nstatic inline void c_can_activate_all_lower_rx_msg_obj(struct net_device *dev,\r\nint iface)\r\n{\r\nint i;\r\nfor (i = C_CAN_MSG_OBJ_RX_FIRST; i <= C_CAN_MSG_RX_LOW_LAST; i++)\r\nc_can_object_get(dev, iface, i, IF_COMM_CLR_NEWDAT);\r\n}\r\nstatic int c_can_handle_lost_msg_obj(struct net_device *dev,\r\nint iface, int objno, u32 ctrl)\r\n{\r\nstruct net_device_stats *stats = &dev->stats;\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\nstruct can_frame *frame;\r\nstruct sk_buff *skb;\r\nctrl &= ~(IF_MCONT_MSGLST | IF_MCONT_INTPND | IF_MCONT_NEWDAT);\r\npriv->write_reg(priv, C_CAN_IFACE(MSGCTRL_REG, iface), ctrl);\r\nc_can_object_put(dev, iface, objno, IF_COMM_CONTROL);\r\nstats->rx_errors++;\r\nstats->rx_over_errors++;\r\nskb = alloc_can_err_skb(dev, &frame);\r\nif (unlikely(!skb))\r\nreturn 0;\r\nframe->can_id |= CAN_ERR_CRTL;\r\nframe->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\r\nnetif_receive_skb(skb);\r\nreturn 1;\r\n}\r\nstatic int c_can_read_msg_object(struct net_device *dev, int iface, u32 ctrl)\r\n{\r\nstruct net_device_stats *stats = &dev->stats;\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\nstruct can_frame *frame;\r\nstruct sk_buff *skb;\r\nu32 arb, data;\r\nskb = alloc_can_skb(dev, &frame);\r\nif (!skb) {\r\nstats->rx_dropped++;\r\nreturn -ENOMEM;\r\n}\r\nframe->can_dlc = get_can_dlc(ctrl & 0x0F);\r\narb = priv->read_reg32(priv, C_CAN_IFACE(ARB1_REG, iface));\r\nif (arb & IF_ARB_MSGXTD)\r\nframe->can_id = (arb & CAN_EFF_MASK) | CAN_EFF_FLAG;\r\nelse\r\nframe->can_id = (arb >> 18) & CAN_SFF_MASK;\r\nif (arb & IF_ARB_TRANSMIT) {\r\nframe->can_id |= CAN_RTR_FLAG;\r\n} else {\r\nint i, dreg = C_CAN_IFACE(DATA1_REG, iface);\r\nif (priv->type == BOSCH_D_CAN) {\r\nfor (i = 0; i < frame->can_dlc; i += 4, dreg += 2) {\r\ndata = priv->read_reg32(priv, dreg);\r\nframe->data[i] = data;\r\nframe->data[i + 1] = data >> 8;\r\nframe->data[i + 2] = data >> 16;\r\nframe->data[i + 3] = data >> 24;\r\n}\r\n} else {\r\nfor (i = 0; i < frame->can_dlc; i += 2, dreg++) {\r\ndata = priv->read_reg(priv, dreg);\r\nframe->data[i] = data;\r\nframe->data[i + 1] = data >> 8;\r\n}\r\n}\r\n}\r\nstats->rx_packets++;\r\nstats->rx_bytes += frame->can_dlc;\r\nnetif_receive_skb(skb);\r\nreturn 0;\r\n}\r\nstatic void c_can_setup_receive_object(struct net_device *dev, int iface,\r\nu32 obj, u32 mask, u32 id, u32 mcont)\r\n{\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\nmask |= BIT(29);\r\npriv->write_reg32(priv, C_CAN_IFACE(MASK1_REG, iface), mask);\r\nid |= IF_ARB_MSGVAL;\r\npriv->write_reg32(priv, C_CAN_IFACE(ARB1_REG, iface), id);\r\npriv->write_reg(priv, C_CAN_IFACE(MSGCTRL_REG, iface), mcont);\r\nc_can_object_put(dev, iface, obj, IF_COMM_RCV_SETUP);\r\n}\r\nstatic netdev_tx_t c_can_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct can_frame *frame = (struct can_frame *)skb->data;\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\nu32 idx, obj;\r\nif (can_dropped_invalid_skb(dev, skb))\r\nreturn NETDEV_TX_OK;\r\nidx = fls(atomic_read(&priv->tx_active));\r\nobj = idx + C_CAN_MSG_OBJ_TX_FIRST;\r\nif (idx == C_CAN_MSG_OBJ_TX_NUM - 1)\r\nnetif_stop_queue(dev);\r\nc_can_setup_tx_object(dev, IF_TX, frame, idx);\r\npriv->dlc[idx] = frame->can_dlc;\r\ncan_put_echo_skb(skb, dev, idx);\r\natomic_add((1 << idx), &priv->tx_active);\r\nc_can_object_put(dev, IF_TX, obj, IF_COMM_TX);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int c_can_wait_for_ctrl_init(struct net_device *dev,\r\nstruct c_can_priv *priv, u32 init)\r\n{\r\nint retry = 0;\r\nwhile (init != (priv->read_reg(priv, C_CAN_CTRL_REG) & CONTROL_INIT)) {\r\nudelay(10);\r\nif (retry++ > 1000) {\r\nnetdev_err(dev, "CCTRL: set CONTROL_INIT failed\n");\r\nreturn -EIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int c_can_set_bittiming(struct net_device *dev)\r\n{\r\nunsigned int reg_btr, reg_brpe, ctrl_save;\r\nu8 brp, brpe, sjw, tseg1, tseg2;\r\nu32 ten_bit_brp;\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\nconst struct can_bittiming *bt = &priv->can.bittiming;\r\nint res;\r\nten_bit_brp = bt->brp - 1;\r\nbrp = ten_bit_brp & BTR_BRP_MASK;\r\nbrpe = ten_bit_brp >> 6;\r\nsjw = bt->sjw - 1;\r\ntseg1 = bt->prop_seg + bt->phase_seg1 - 1;\r\ntseg2 = bt->phase_seg2 - 1;\r\nreg_btr = brp | (sjw << BTR_SJW_SHIFT) | (tseg1 << BTR_TSEG1_SHIFT) |\r\n(tseg2 << BTR_TSEG2_SHIFT);\r\nreg_brpe = brpe & BRP_EXT_BRPE_MASK;\r\nnetdev_info(dev,\r\n"setting BTR=%04x BRPE=%04x\n", reg_btr, reg_brpe);\r\nctrl_save = priv->read_reg(priv, C_CAN_CTRL_REG);\r\nctrl_save &= ~CONTROL_INIT;\r\npriv->write_reg(priv, C_CAN_CTRL_REG, CONTROL_CCE | CONTROL_INIT);\r\nres = c_can_wait_for_ctrl_init(dev, priv, CONTROL_INIT);\r\nif (res)\r\nreturn res;\r\npriv->write_reg(priv, C_CAN_BTR_REG, reg_btr);\r\npriv->write_reg(priv, C_CAN_BRPEXT_REG, reg_brpe);\r\npriv->write_reg(priv, C_CAN_CTRL_REG, ctrl_save);\r\nreturn c_can_wait_for_ctrl_init(dev, priv, 0);\r\n}\r\nstatic void c_can_configure_msg_objects(struct net_device *dev)\r\n{\r\nint i;\r\nfor (i = C_CAN_MSG_OBJ_RX_FIRST; i <= C_CAN_NO_OF_OBJECTS; i++)\r\nc_can_inval_msg_object(dev, IF_RX, i);\r\nfor (i = C_CAN_MSG_OBJ_RX_FIRST; i < C_CAN_MSG_OBJ_RX_LAST; i++)\r\nc_can_setup_receive_object(dev, IF_RX, i, 0, 0, IF_MCONT_RCV);\r\nc_can_setup_receive_object(dev, IF_RX, C_CAN_MSG_OBJ_RX_LAST, 0, 0,\r\nIF_MCONT_RCV_EOB);\r\n}\r\nstatic int c_can_chip_config(struct net_device *dev)\r\n{\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\npriv->write_reg(priv, C_CAN_CTRL_REG, CONTROL_ENABLE_AR);\r\nif ((priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY) &&\r\n(priv->can.ctrlmode & CAN_CTRLMODE_LOOPBACK)) {\r\npriv->write_reg(priv, C_CAN_CTRL_REG, CONTROL_TEST);\r\npriv->write_reg(priv, C_CAN_TEST_REG, TEST_LBACK | TEST_SILENT);\r\n} else if (priv->can.ctrlmode & CAN_CTRLMODE_LOOPBACK) {\r\npriv->write_reg(priv, C_CAN_CTRL_REG, CONTROL_TEST);\r\npriv->write_reg(priv, C_CAN_TEST_REG, TEST_LBACK);\r\n} else if (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY) {\r\npriv->write_reg(priv, C_CAN_CTRL_REG, CONTROL_TEST);\r\npriv->write_reg(priv, C_CAN_TEST_REG, TEST_SILENT);\r\n}\r\nc_can_configure_msg_objects(dev);\r\npriv->write_reg(priv, C_CAN_STS_REG, LEC_UNUSED);\r\natomic_set(&priv->tx_active, 0);\r\npriv->rxmasked = 0;\r\npriv->tx_dir = 0;\r\nreturn c_can_set_bittiming(dev);\r\n}\r\nstatic int c_can_start(struct net_device *dev)\r\n{\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\nint err;\r\nstruct pinctrl *p;\r\nerr = c_can_chip_config(dev);\r\nif (err)\r\nreturn err;\r\npriv->comm_rcv_high = priv->type != BOSCH_D_CAN ?\r\nIF_COMM_RCV_LOW : IF_COMM_RCV_HIGH;\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\np = pinctrl_get_select(priv->device, "active");\r\nif (!IS_ERR(p))\r\npinctrl_put(p);\r\nelse\r\npinctrl_pm_select_default_state(priv->device);\r\nreturn 0;\r\n}\r\nstatic void c_can_stop(struct net_device *dev)\r\n{\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\nc_can_irq_control(priv, false);\r\npriv->write_reg(priv, C_CAN_CTRL_REG, CONTROL_INIT);\r\npinctrl_pm_select_sleep_state(dev->dev.parent);\r\npriv->can.state = CAN_STATE_STOPPED;\r\n}\r\nstatic int c_can_set_mode(struct net_device *dev, enum can_mode mode)\r\n{\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\nint err;\r\nswitch (mode) {\r\ncase CAN_MODE_START:\r\nerr = c_can_start(dev);\r\nif (err)\r\nreturn err;\r\nnetif_wake_queue(dev);\r\nc_can_irq_control(priv, true);\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __c_can_get_berr_counter(const struct net_device *dev,\r\nstruct can_berr_counter *bec)\r\n{\r\nunsigned int reg_err_counter;\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\nreg_err_counter = priv->read_reg(priv, C_CAN_ERR_CNT_REG);\r\nbec->rxerr = (reg_err_counter & ERR_CNT_REC_MASK) >>\r\nERR_CNT_REC_SHIFT;\r\nbec->txerr = reg_err_counter & ERR_CNT_TEC_MASK;\r\nreturn 0;\r\n}\r\nstatic int c_can_get_berr_counter(const struct net_device *dev,\r\nstruct can_berr_counter *bec)\r\n{\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\nint err;\r\nc_can_pm_runtime_get_sync(priv);\r\nerr = __c_can_get_berr_counter(dev, bec);\r\nc_can_pm_runtime_put_sync(priv);\r\nreturn err;\r\n}\r\nstatic void c_can_do_tx(struct net_device *dev)\r\n{\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\nstruct net_device_stats *stats = &dev->stats;\r\nu32 idx, obj, pkts = 0, bytes = 0, pend, clr;\r\nclr = pend = priv->read_reg(priv, C_CAN_INTPND2_REG);\r\nwhile ((idx = ffs(pend))) {\r\nidx--;\r\npend &= ~(1 << idx);\r\nobj = idx + C_CAN_MSG_OBJ_TX_FIRST;\r\nc_can_inval_tx_object(dev, IF_RX, obj);\r\ncan_get_echo_skb(dev, idx);\r\nbytes += priv->dlc[idx];\r\npkts++;\r\n}\r\natomic_sub(clr, &priv->tx_active);\r\nif (clr & (1 << (C_CAN_MSG_OBJ_TX_NUM - 1)))\r\nnetif_wake_queue(dev);\r\nif (pkts) {\r\nstats->tx_bytes += bytes;\r\nstats->tx_packets += pkts;\r\ncan_led_event(dev, CAN_LED_EVENT_TX);\r\n}\r\n}\r\nstatic u32 c_can_adjust_pending(u32 pend)\r\n{\r\nu32 weight, lasts;\r\nif (pend == RECEIVE_OBJECT_BITS)\r\nreturn pend;\r\nweight = hweight32(pend);\r\nlasts = fls(pend);\r\nif (lasts == weight)\r\nreturn pend;\r\nfor (lasts--; pend & (1 << (lasts - 1)); lasts--);\r\nreturn pend & ~((1 << lasts) - 1);\r\n}\r\nstatic inline void c_can_rx_object_get(struct net_device *dev,\r\nstruct c_can_priv *priv, u32 obj)\r\n{\r\nc_can_object_get(dev, IF_RX, obj, priv->comm_rcv_high);\r\n}\r\nstatic inline void c_can_rx_finalize(struct net_device *dev,\r\nstruct c_can_priv *priv, u32 obj)\r\n{\r\nif (priv->type != BOSCH_D_CAN)\r\nc_can_object_get(dev, IF_RX, obj, IF_COMM_CLR_NEWDAT);\r\n}\r\nstatic int c_can_read_objects(struct net_device *dev, struct c_can_priv *priv,\r\nu32 pend, int quota)\r\n{\r\nu32 pkts = 0, ctrl, obj;\r\nwhile ((obj = ffs(pend)) && quota > 0) {\r\npend &= ~BIT(obj - 1);\r\nc_can_rx_object_get(dev, priv, obj);\r\nctrl = priv->read_reg(priv, C_CAN_IFACE(MSGCTRL_REG, IF_RX));\r\nif (ctrl & IF_MCONT_MSGLST) {\r\nint n = c_can_handle_lost_msg_obj(dev, IF_RX, obj, ctrl);\r\npkts += n;\r\nquota -= n;\r\ncontinue;\r\n}\r\nif (!(ctrl & IF_MCONT_NEWDAT))\r\ncontinue;\r\nc_can_read_msg_object(dev, IF_RX, ctrl);\r\nc_can_rx_finalize(dev, priv, obj);\r\npkts++;\r\nquota--;\r\n}\r\nreturn pkts;\r\n}\r\nstatic inline u32 c_can_get_pending(struct c_can_priv *priv)\r\n{\r\nu32 pend = priv->read_reg(priv, C_CAN_NEWDAT1_REG);\r\nreturn pend;\r\n}\r\nstatic int c_can_do_rx_poll(struct net_device *dev, int quota)\r\n{\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\nu32 pkts = 0, pend = 0, toread, n;\r\nBUILD_BUG_ON_MSG(C_CAN_MSG_OBJ_RX_LAST > 16,\r\n"Implementation does not support more message objects than 16");\r\nwhile (quota > 0) {\r\nif (!pend) {\r\npend = c_can_get_pending(priv);\r\nif (!pend)\r\nbreak;\r\ntoread = c_can_adjust_pending(pend);\r\n} else {\r\ntoread = pend;\r\n}\r\npend &= ~toread;\r\nn = c_can_read_objects(dev, priv, toread, quota);\r\npkts += n;\r\nquota -= n;\r\n}\r\nif (pkts)\r\ncan_led_event(dev, CAN_LED_EVENT_RX);\r\nreturn pkts;\r\n}\r\nstatic int c_can_handle_state_change(struct net_device *dev,\r\nenum c_can_bus_error_types error_type)\r\n{\r\nunsigned int reg_err_counter;\r\nunsigned int rx_err_passive;\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\nstruct net_device_stats *stats = &dev->stats;\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nstruct can_berr_counter bec;\r\nswitch (error_type) {\r\ncase C_CAN_ERROR_WARNING:\r\npriv->can.can_stats.error_warning++;\r\npriv->can.state = CAN_STATE_ERROR_WARNING;\r\nbreak;\r\ncase C_CAN_ERROR_PASSIVE:\r\npriv->can.can_stats.error_passive++;\r\npriv->can.state = CAN_STATE_ERROR_PASSIVE;\r\nbreak;\r\ncase C_CAN_BUS_OFF:\r\npriv->can.state = CAN_STATE_BUS_OFF;\r\npriv->can.can_stats.bus_off++;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nskb = alloc_can_err_skb(dev, &cf);\r\nif (unlikely(!skb))\r\nreturn 0;\r\n__c_can_get_berr_counter(dev, &bec);\r\nreg_err_counter = priv->read_reg(priv, C_CAN_ERR_CNT_REG);\r\nrx_err_passive = (reg_err_counter & ERR_CNT_RP_MASK) >>\r\nERR_CNT_RP_SHIFT;\r\nswitch (error_type) {\r\ncase C_CAN_ERROR_WARNING:\r\ncf->can_id |= CAN_ERR_CRTL;\r\ncf->data[1] = (bec.txerr > bec.rxerr) ?\r\nCAN_ERR_CRTL_TX_WARNING :\r\nCAN_ERR_CRTL_RX_WARNING;\r\ncf->data[6] = bec.txerr;\r\ncf->data[7] = bec.rxerr;\r\nbreak;\r\ncase C_CAN_ERROR_PASSIVE:\r\ncf->can_id |= CAN_ERR_CRTL;\r\nif (rx_err_passive)\r\ncf->data[1] |= CAN_ERR_CRTL_RX_PASSIVE;\r\nif (bec.txerr > 127)\r\ncf->data[1] |= CAN_ERR_CRTL_TX_PASSIVE;\r\ncf->data[6] = bec.txerr;\r\ncf->data[7] = bec.rxerr;\r\nbreak;\r\ncase C_CAN_BUS_OFF:\r\ncf->can_id |= CAN_ERR_BUSOFF;\r\ncan_bus_off(dev);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nstats->rx_packets++;\r\nstats->rx_bytes += cf->can_dlc;\r\nnetif_receive_skb(skb);\r\nreturn 1;\r\n}\r\nstatic int c_can_handle_bus_err(struct net_device *dev,\r\nenum c_can_lec_type lec_type)\r\n{\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\nstruct net_device_stats *stats = &dev->stats;\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nif (lec_type == LEC_UNUSED || lec_type == LEC_NO_ERROR)\r\nreturn 0;\r\nif (!(priv->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING))\r\nreturn 0;\r\npriv->can.can_stats.bus_error++;\r\nstats->rx_errors++;\r\nskb = alloc_can_err_skb(dev, &cf);\r\nif (unlikely(!skb))\r\nreturn 0;\r\ncf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;\r\nswitch (lec_type) {\r\ncase LEC_STUFF_ERROR:\r\nnetdev_dbg(dev, "stuff error\n");\r\ncf->data[2] |= CAN_ERR_PROT_STUFF;\r\nbreak;\r\ncase LEC_FORM_ERROR:\r\nnetdev_dbg(dev, "form error\n");\r\ncf->data[2] |= CAN_ERR_PROT_FORM;\r\nbreak;\r\ncase LEC_ACK_ERROR:\r\nnetdev_dbg(dev, "ack error\n");\r\ncf->data[3] = CAN_ERR_PROT_LOC_ACK;\r\nbreak;\r\ncase LEC_BIT1_ERROR:\r\nnetdev_dbg(dev, "bit1 error\n");\r\ncf->data[2] |= CAN_ERR_PROT_BIT1;\r\nbreak;\r\ncase LEC_BIT0_ERROR:\r\nnetdev_dbg(dev, "bit0 error\n");\r\ncf->data[2] |= CAN_ERR_PROT_BIT0;\r\nbreak;\r\ncase LEC_CRC_ERROR:\r\nnetdev_dbg(dev, "CRC error\n");\r\ncf->data[3] = CAN_ERR_PROT_LOC_CRC_SEQ;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nstats->rx_packets++;\r\nstats->rx_bytes += cf->can_dlc;\r\nnetif_receive_skb(skb);\r\nreturn 1;\r\n}\r\nstatic int c_can_poll(struct napi_struct *napi, int quota)\r\n{\r\nstruct net_device *dev = napi->dev;\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\nu16 curr, last = priv->last_status;\r\nint work_done = 0;\r\npriv->last_status = curr = priv->read_reg(priv, C_CAN_STS_REG);\r\nif (priv->type != BOSCH_D_CAN)\r\npriv->write_reg(priv, C_CAN_STS_REG, LEC_UNUSED);\r\nif ((curr & STATUS_EWARN) && (!(last & STATUS_EWARN))) {\r\nnetdev_dbg(dev, "entered error warning state\n");\r\nwork_done += c_can_handle_state_change(dev, C_CAN_ERROR_WARNING);\r\n}\r\nif ((curr & STATUS_EPASS) && (!(last & STATUS_EPASS))) {\r\nnetdev_dbg(dev, "entered error passive state\n");\r\nwork_done += c_can_handle_state_change(dev, C_CAN_ERROR_PASSIVE);\r\n}\r\nif ((curr & STATUS_BOFF) && (!(last & STATUS_BOFF))) {\r\nnetdev_dbg(dev, "entered bus off state\n");\r\nwork_done += c_can_handle_state_change(dev, C_CAN_BUS_OFF);\r\ngoto end;\r\n}\r\nif ((!(curr & STATUS_BOFF)) && (last & STATUS_BOFF)) {\r\nnetdev_dbg(dev, "left bus off state\n");\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\n}\r\nif ((!(curr & STATUS_EPASS)) && (last & STATUS_EPASS)) {\r\nnetdev_dbg(dev, "left error passive state\n");\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\n}\r\nwork_done += c_can_handle_bus_err(dev, curr & LEC_MASK);\r\nwork_done += c_can_do_rx_poll(dev, (quota - work_done));\r\nc_can_do_tx(dev);\r\nend:\r\nif (work_done < quota) {\r\nnapi_complete_done(napi, work_done);\r\nif (priv->can.state != CAN_STATE_BUS_OFF)\r\nc_can_irq_control(priv, true);\r\n}\r\nreturn work_done;\r\n}\r\nstatic irqreturn_t c_can_isr(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = (struct net_device *)dev_id;\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\nif (!priv->read_reg(priv, C_CAN_INT_REG))\r\nreturn IRQ_NONE;\r\nc_can_irq_control(priv, false);\r\nnapi_schedule(&priv->napi);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int c_can_open(struct net_device *dev)\r\n{\r\nint err;\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\nc_can_pm_runtime_get_sync(priv);\r\nc_can_reset_ram(priv, true);\r\nerr = open_candev(dev);\r\nif (err) {\r\nnetdev_err(dev, "failed to open can device\n");\r\ngoto exit_open_fail;\r\n}\r\nerr = request_irq(dev->irq, &c_can_isr, IRQF_SHARED, dev->name,\r\ndev);\r\nif (err < 0) {\r\nnetdev_err(dev, "failed to request interrupt\n");\r\ngoto exit_irq_fail;\r\n}\r\nerr = c_can_start(dev);\r\nif (err)\r\ngoto exit_start_fail;\r\ncan_led_event(dev, CAN_LED_EVENT_OPEN);\r\nnapi_enable(&priv->napi);\r\nc_can_irq_control(priv, true);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\nexit_start_fail:\r\nfree_irq(dev->irq, dev);\r\nexit_irq_fail:\r\nclose_candev(dev);\r\nexit_open_fail:\r\nc_can_reset_ram(priv, false);\r\nc_can_pm_runtime_put_sync(priv);\r\nreturn err;\r\n}\r\nstatic int c_can_close(struct net_device *dev)\r\n{\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\nnetif_stop_queue(dev);\r\nnapi_disable(&priv->napi);\r\nc_can_stop(dev);\r\nfree_irq(dev->irq, dev);\r\nclose_candev(dev);\r\nc_can_reset_ram(priv, false);\r\nc_can_pm_runtime_put_sync(priv);\r\ncan_led_event(dev, CAN_LED_EVENT_STOP);\r\nreturn 0;\r\n}\r\nstruct net_device *alloc_c_can_dev(void)\r\n{\r\nstruct net_device *dev;\r\nstruct c_can_priv *priv;\r\ndev = alloc_candev(sizeof(struct c_can_priv), C_CAN_MSG_OBJ_TX_NUM);\r\nif (!dev)\r\nreturn NULL;\r\npriv = netdev_priv(dev);\r\nnetif_napi_add(dev, &priv->napi, c_can_poll, C_CAN_NAPI_WEIGHT);\r\npriv->dev = dev;\r\npriv->can.bittiming_const = &c_can_bittiming_const;\r\npriv->can.do_set_mode = c_can_set_mode;\r\npriv->can.do_get_berr_counter = c_can_get_berr_counter;\r\npriv->can.ctrlmode_supported = CAN_CTRLMODE_LOOPBACK |\r\nCAN_CTRLMODE_LISTENONLY |\r\nCAN_CTRLMODE_BERR_REPORTING;\r\nreturn dev;\r\n}\r\nint c_can_power_down(struct net_device *dev)\r\n{\r\nu32 val;\r\nunsigned long time_out;\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\nif (!(dev->flags & IFF_UP))\r\nreturn 0;\r\nWARN_ON(priv->type != BOSCH_D_CAN);\r\nval = priv->read_reg(priv, C_CAN_CTRL_EX_REG);\r\nval |= CONTROL_EX_PDR;\r\npriv->write_reg(priv, C_CAN_CTRL_EX_REG, val);\r\ntime_out = jiffies + msecs_to_jiffies(INIT_WAIT_MS);\r\nwhile (!(priv->read_reg(priv, C_CAN_STS_REG) & STATUS_PDA) &&\r\ntime_after(time_out, jiffies))\r\ncpu_relax();\r\nif (time_after(jiffies, time_out))\r\nreturn -ETIMEDOUT;\r\nc_can_stop(dev);\r\nc_can_reset_ram(priv, false);\r\nc_can_pm_runtime_put_sync(priv);\r\nreturn 0;\r\n}\r\nint c_can_power_up(struct net_device *dev)\r\n{\r\nu32 val;\r\nunsigned long time_out;\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\nint ret;\r\nif (!(dev->flags & IFF_UP))\r\nreturn 0;\r\nWARN_ON(priv->type != BOSCH_D_CAN);\r\nc_can_pm_runtime_get_sync(priv);\r\nc_can_reset_ram(priv, true);\r\nval = priv->read_reg(priv, C_CAN_CTRL_EX_REG);\r\nval &= ~CONTROL_EX_PDR;\r\npriv->write_reg(priv, C_CAN_CTRL_EX_REG, val);\r\nval = priv->read_reg(priv, C_CAN_CTRL_REG);\r\nval &= ~CONTROL_INIT;\r\npriv->write_reg(priv, C_CAN_CTRL_REG, val);\r\ntime_out = jiffies + msecs_to_jiffies(INIT_WAIT_MS);\r\nwhile ((priv->read_reg(priv, C_CAN_STS_REG) & STATUS_PDA) &&\r\ntime_after(time_out, jiffies))\r\ncpu_relax();\r\nif (time_after(jiffies, time_out))\r\nreturn -ETIMEDOUT;\r\nret = c_can_start(dev);\r\nif (!ret)\r\nc_can_irq_control(priv, true);\r\nreturn ret;\r\n}\r\nvoid free_c_can_dev(struct net_device *dev)\r\n{\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\nnetif_napi_del(&priv->napi);\r\nfree_candev(dev);\r\n}\r\nint register_c_can_dev(struct net_device *dev)\r\n{\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\nint err;\r\npinctrl_pm_select_sleep_state(dev->dev.parent);\r\nc_can_pm_runtime_enable(priv);\r\ndev->flags |= IFF_ECHO;\r\ndev->netdev_ops = &c_can_netdev_ops;\r\nerr = register_candev(dev);\r\nif (err)\r\nc_can_pm_runtime_disable(priv);\r\nelse\r\ndevm_can_led_init(dev);\r\nreturn err;\r\n}\r\nvoid unregister_c_can_dev(struct net_device *dev)\r\n{\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\nunregister_candev(dev);\r\nc_can_pm_runtime_disable(priv);\r\n}
