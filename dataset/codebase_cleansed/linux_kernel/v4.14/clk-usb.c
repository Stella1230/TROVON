static unsigned long at91sam9x5_clk_usb_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct at91sam9x5_clk_usb *usb = to_at91sam9x5_clk_usb(hw);\r\nunsigned int usbr;\r\nu8 usbdiv;\r\nregmap_read(usb->regmap, AT91_PMC_USB, &usbr);\r\nusbdiv = (usbr & AT91_PMC_OHCIUSBDIV) >> SAM9X5_USB_DIV_SHIFT;\r\nreturn DIV_ROUND_CLOSEST(parent_rate, (usbdiv + 1));\r\n}\r\nstatic int at91sam9x5_clk_usb_determine_rate(struct clk_hw *hw,\r\nstruct clk_rate_request *req)\r\n{\r\nstruct clk_hw *parent;\r\nlong best_rate = -EINVAL;\r\nunsigned long tmp_rate;\r\nint best_diff = -1;\r\nint tmp_diff;\r\nint i;\r\nfor (i = 0; i < clk_hw_get_num_parents(hw); i++) {\r\nint div;\r\nparent = clk_hw_get_parent_by_index(hw, i);\r\nif (!parent)\r\ncontinue;\r\nfor (div = 1; div < SAM9X5_USB_MAX_DIV + 2; div++) {\r\nunsigned long tmp_parent_rate;\r\ntmp_parent_rate = req->rate * div;\r\ntmp_parent_rate = clk_hw_round_rate(parent,\r\ntmp_parent_rate);\r\ntmp_rate = DIV_ROUND_CLOSEST(tmp_parent_rate, div);\r\nif (tmp_rate < req->rate)\r\ntmp_diff = req->rate - tmp_rate;\r\nelse\r\ntmp_diff = tmp_rate - req->rate;\r\nif (best_diff < 0 || best_diff > tmp_diff) {\r\nbest_rate = tmp_rate;\r\nbest_diff = tmp_diff;\r\nreq->best_parent_rate = tmp_parent_rate;\r\nreq->best_parent_hw = parent;\r\n}\r\nif (!best_diff || tmp_rate < req->rate)\r\nbreak;\r\n}\r\nif (!best_diff)\r\nbreak;\r\n}\r\nif (best_rate < 0)\r\nreturn best_rate;\r\nreq->rate = best_rate;\r\nreturn 0;\r\n}\r\nstatic int at91sam9x5_clk_usb_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct at91sam9x5_clk_usb *usb = to_at91sam9x5_clk_usb(hw);\r\nif (index > 1)\r\nreturn -EINVAL;\r\nregmap_update_bits(usb->regmap, AT91_PMC_USB, AT91_PMC_USBS,\r\nindex ? AT91_PMC_USBS : 0);\r\nreturn 0;\r\n}\r\nstatic u8 at91sam9x5_clk_usb_get_parent(struct clk_hw *hw)\r\n{\r\nstruct at91sam9x5_clk_usb *usb = to_at91sam9x5_clk_usb(hw);\r\nunsigned int usbr;\r\nregmap_read(usb->regmap, AT91_PMC_USB, &usbr);\r\nreturn usbr & AT91_PMC_USBS;\r\n}\r\nstatic int at91sam9x5_clk_usb_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct at91sam9x5_clk_usb *usb = to_at91sam9x5_clk_usb(hw);\r\nunsigned long div;\r\nif (!rate)\r\nreturn -EINVAL;\r\ndiv = DIV_ROUND_CLOSEST(parent_rate, rate);\r\nif (div > SAM9X5_USB_MAX_DIV + 1 || !div)\r\nreturn -EINVAL;\r\nregmap_update_bits(usb->regmap, AT91_PMC_USB, AT91_PMC_OHCIUSBDIV,\r\n(div - 1) << SAM9X5_USB_DIV_SHIFT);\r\nreturn 0;\r\n}\r\nstatic int at91sam9n12_clk_usb_enable(struct clk_hw *hw)\r\n{\r\nstruct at91sam9x5_clk_usb *usb = to_at91sam9x5_clk_usb(hw);\r\nregmap_update_bits(usb->regmap, AT91_PMC_USB, AT91_PMC_USBS,\r\nAT91_PMC_USBS);\r\nreturn 0;\r\n}\r\nstatic void at91sam9n12_clk_usb_disable(struct clk_hw *hw)\r\n{\r\nstruct at91sam9x5_clk_usb *usb = to_at91sam9x5_clk_usb(hw);\r\nregmap_update_bits(usb->regmap, AT91_PMC_USB, AT91_PMC_USBS, 0);\r\n}\r\nstatic int at91sam9n12_clk_usb_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct at91sam9x5_clk_usb *usb = to_at91sam9x5_clk_usb(hw);\r\nunsigned int usbr;\r\nregmap_read(usb->regmap, AT91_PMC_USB, &usbr);\r\nreturn usbr & AT91_PMC_USBS;\r\n}\r\nstatic struct clk_hw * __init\r\nat91sam9x5_clk_register_usb(struct regmap *regmap, const char *name,\r\nconst char **parent_names, u8 num_parents)\r\n{\r\nstruct at91sam9x5_clk_usb *usb;\r\nstruct clk_hw *hw;\r\nstruct clk_init_data init;\r\nint ret;\r\nusb = kzalloc(sizeof(*usb), GFP_KERNEL);\r\nif (!usb)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = name;\r\ninit.ops = &at91sam9x5_usb_ops;\r\ninit.parent_names = parent_names;\r\ninit.num_parents = num_parents;\r\ninit.flags = CLK_SET_RATE_GATE | CLK_SET_PARENT_GATE |\r\nCLK_SET_RATE_PARENT;\r\nusb->hw.init = &init;\r\nusb->regmap = regmap;\r\nhw = &usb->hw;\r\nret = clk_hw_register(NULL, &usb->hw);\r\nif (ret) {\r\nkfree(usb);\r\nhw = ERR_PTR(ret);\r\n}\r\nreturn hw;\r\n}\r\nstatic struct clk_hw * __init\r\nat91sam9n12_clk_register_usb(struct regmap *regmap, const char *name,\r\nconst char *parent_name)\r\n{\r\nstruct at91sam9x5_clk_usb *usb;\r\nstruct clk_hw *hw;\r\nstruct clk_init_data init;\r\nint ret;\r\nusb = kzalloc(sizeof(*usb), GFP_KERNEL);\r\nif (!usb)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = name;\r\ninit.ops = &at91sam9n12_usb_ops;\r\ninit.parent_names = &parent_name;\r\ninit.num_parents = 1;\r\ninit.flags = CLK_SET_RATE_GATE | CLK_SET_RATE_PARENT;\r\nusb->hw.init = &init;\r\nusb->regmap = regmap;\r\nhw = &usb->hw;\r\nret = clk_hw_register(NULL, &usb->hw);\r\nif (ret) {\r\nkfree(usb);\r\nhw = ERR_PTR(ret);\r\n}\r\nreturn hw;\r\n}\r\nstatic unsigned long at91rm9200_clk_usb_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct at91rm9200_clk_usb *usb = to_at91rm9200_clk_usb(hw);\r\nunsigned int pllbr;\r\nu8 usbdiv;\r\nregmap_read(usb->regmap, AT91_CKGR_PLLBR, &pllbr);\r\nusbdiv = (pllbr & AT91_PMC_USBDIV) >> RM9200_USB_DIV_SHIFT;\r\nif (usb->divisors[usbdiv])\r\nreturn parent_rate / usb->divisors[usbdiv];\r\nreturn 0;\r\n}\r\nstatic long at91rm9200_clk_usb_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nstruct at91rm9200_clk_usb *usb = to_at91rm9200_clk_usb(hw);\r\nstruct clk_hw *parent = clk_hw_get_parent(hw);\r\nunsigned long bestrate = 0;\r\nint bestdiff = -1;\r\nunsigned long tmprate;\r\nint tmpdiff;\r\nint i = 0;\r\nfor (i = 0; i < RM9200_USB_DIV_TAB_SIZE; i++) {\r\nunsigned long tmp_parent_rate;\r\nif (!usb->divisors[i])\r\ncontinue;\r\ntmp_parent_rate = rate * usb->divisors[i];\r\ntmp_parent_rate = clk_hw_round_rate(parent, tmp_parent_rate);\r\ntmprate = DIV_ROUND_CLOSEST(tmp_parent_rate, usb->divisors[i]);\r\nif (tmprate < rate)\r\ntmpdiff = rate - tmprate;\r\nelse\r\ntmpdiff = tmprate - rate;\r\nif (bestdiff < 0 || bestdiff > tmpdiff) {\r\nbestrate = tmprate;\r\nbestdiff = tmpdiff;\r\n*parent_rate = tmp_parent_rate;\r\n}\r\nif (!bestdiff)\r\nbreak;\r\n}\r\nreturn bestrate;\r\n}\r\nstatic int at91rm9200_clk_usb_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nint i;\r\nstruct at91rm9200_clk_usb *usb = to_at91rm9200_clk_usb(hw);\r\nunsigned long div;\r\nif (!rate)\r\nreturn -EINVAL;\r\ndiv = DIV_ROUND_CLOSEST(parent_rate, rate);\r\nfor (i = 0; i < RM9200_USB_DIV_TAB_SIZE; i++) {\r\nif (usb->divisors[i] == div) {\r\nregmap_update_bits(usb->regmap, AT91_CKGR_PLLBR,\r\nAT91_PMC_USBDIV,\r\ni << RM9200_USB_DIV_SHIFT);\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic struct clk_hw * __init\r\nat91rm9200_clk_register_usb(struct regmap *regmap, const char *name,\r\nconst char *parent_name, const u32 *divisors)\r\n{\r\nstruct at91rm9200_clk_usb *usb;\r\nstruct clk_hw *hw;\r\nstruct clk_init_data init;\r\nint ret;\r\nusb = kzalloc(sizeof(*usb), GFP_KERNEL);\r\nif (!usb)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = name;\r\ninit.ops = &at91rm9200_usb_ops;\r\ninit.parent_names = &parent_name;\r\ninit.num_parents = 1;\r\ninit.flags = CLK_SET_RATE_PARENT;\r\nusb->hw.init = &init;\r\nusb->regmap = regmap;\r\nmemcpy(usb->divisors, divisors, sizeof(usb->divisors));\r\nhw = &usb->hw;\r\nret = clk_hw_register(NULL, &usb->hw);\r\nif (ret) {\r\nkfree(usb);\r\nhw = ERR_PTR(ret);\r\n}\r\nreturn hw;\r\n}\r\nstatic void __init of_at91sam9x5_clk_usb_setup(struct device_node *np)\r\n{\r\nstruct clk_hw *hw;\r\nunsigned int num_parents;\r\nconst char *parent_names[USB_SOURCE_MAX];\r\nconst char *name = np->name;\r\nstruct regmap *regmap;\r\nnum_parents = of_clk_get_parent_count(np);\r\nif (num_parents == 0 || num_parents > USB_SOURCE_MAX)\r\nreturn;\r\nof_clk_parent_fill(np, parent_names, num_parents);\r\nof_property_read_string(np, "clock-output-names", &name);\r\nregmap = syscon_node_to_regmap(of_get_parent(np));\r\nif (IS_ERR(regmap))\r\nreturn;\r\nhw = at91sam9x5_clk_register_usb(regmap, name, parent_names,\r\nnum_parents);\r\nif (IS_ERR(hw))\r\nreturn;\r\nof_clk_add_hw_provider(np, of_clk_hw_simple_get, hw);\r\n}\r\nstatic void __init of_at91sam9n12_clk_usb_setup(struct device_node *np)\r\n{\r\nstruct clk_hw *hw;\r\nconst char *parent_name;\r\nconst char *name = np->name;\r\nstruct regmap *regmap;\r\nparent_name = of_clk_get_parent_name(np, 0);\r\nif (!parent_name)\r\nreturn;\r\nof_property_read_string(np, "clock-output-names", &name);\r\nregmap = syscon_node_to_regmap(of_get_parent(np));\r\nif (IS_ERR(regmap))\r\nreturn;\r\nhw = at91sam9n12_clk_register_usb(regmap, name, parent_name);\r\nif (IS_ERR(hw))\r\nreturn;\r\nof_clk_add_hw_provider(np, of_clk_hw_simple_get, hw);\r\n}\r\nstatic void __init of_at91rm9200_clk_usb_setup(struct device_node *np)\r\n{\r\nstruct clk_hw *hw;\r\nconst char *parent_name;\r\nconst char *name = np->name;\r\nu32 divisors[4] = {0, 0, 0, 0};\r\nstruct regmap *regmap;\r\nparent_name = of_clk_get_parent_name(np, 0);\r\nif (!parent_name)\r\nreturn;\r\nof_property_read_u32_array(np, "atmel,clk-divisors", divisors, 4);\r\nif (!divisors[0])\r\nreturn;\r\nof_property_read_string(np, "clock-output-names", &name);\r\nregmap = syscon_node_to_regmap(of_get_parent(np));\r\nif (IS_ERR(regmap))\r\nreturn;\r\nhw = at91rm9200_clk_register_usb(regmap, name, parent_name, divisors);\r\nif (IS_ERR(hw))\r\nreturn;\r\nof_clk_add_hw_provider(np, of_clk_hw_simple_get, hw);\r\n}
