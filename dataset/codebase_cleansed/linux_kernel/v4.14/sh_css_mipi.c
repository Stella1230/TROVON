enum ia_css_err\r\nia_css_mipi_frame_specify(const unsigned int size_mem_words,\r\nconst bool contiguous)\r\n{\r\nenum ia_css_err err = IA_CSS_SUCCESS;\r\nmy_css.size_mem_words = size_mem_words;\r\n(void)contiguous;\r\nreturn err;\r\n}\r\nstatic bool ia_css_mipi_is_source_port_valid(struct ia_css_pipe *pipe,\r\nunsigned int *pport)\r\n{\r\nbool ret = true;\r\nunsigned int port = 0;\r\nunsigned int max_ports = 0;\r\nswitch (pipe->stream->config.mode) {\r\ncase IA_CSS_INPUT_MODE_BUFFERED_SENSOR:\r\nport = (unsigned int) pipe->stream->config.source.port.port;\r\nmax_ports = N_CSI_PORTS;\r\nbreak;\r\ncase IA_CSS_INPUT_MODE_TPG:\r\nport = (unsigned int) pipe->stream->config.source.tpg.id;\r\nmax_ports = N_CSS_TPG_IDS;\r\nbreak;\r\ncase IA_CSS_INPUT_MODE_PRBS:\r\nport = (unsigned int) pipe->stream->config.source.prbs.id;\r\nmax_ports = N_CSS_PRBS_IDS;\r\nbreak;\r\ndefault:\r\nassert(false);\r\nret = false;\r\nbreak;\r\n}\r\nif (ret) {\r\nassert(port < max_ports);\r\nif (port >= max_ports)\r\nret = false;\r\n}\r\n*pport = port;\r\nreturn ret;\r\n}\r\nenum ia_css_err\r\nia_css_mipi_frame_calculate_size(const unsigned int width,\r\nconst unsigned int height,\r\nconst enum ia_css_stream_format format,\r\nconst bool hasSOLandEOL,\r\nconst unsigned int embedded_data_size_words,\r\nunsigned int *size_mem_words)\r\n{\r\nenum ia_css_err err = IA_CSS_SUCCESS;\r\nunsigned int bits_per_pixel = 0;\r\nunsigned int even_line_bytes = 0;\r\nunsigned int odd_line_bytes = 0;\r\nunsigned int words_per_odd_line = 0;\r\nunsigned int words_for_first_line = 0;\r\nunsigned int words_per_even_line = 0;\r\nunsigned int mem_words_per_even_line = 0;\r\nunsigned int mem_words_per_odd_line = 0;\r\nunsigned int mem_words_for_first_line = 0;\r\nunsigned int mem_words_for_EOF = 0;\r\nunsigned int mem_words = 0;\r\nunsigned int width_padded = width;\r\n#if defined(USE_INPUT_SYSTEM_VERSION_2401)\r\nwidth_padded += (2 * ISP_VEC_NELEMS);\r\n#endif\r\nIA_CSS_ENTER("padded_width=%d, height=%d, format=%d, hasSOLandEOL=%d, embedded_data_size_words=%d\n",\r\nwidth_padded, height, format, hasSOLandEOL, embedded_data_size_words);\r\nswitch (format) {\r\ncase IA_CSS_STREAM_FORMAT_RAW_6:\r\nbits_per_pixel = 6; break;\r\ncase IA_CSS_STREAM_FORMAT_RAW_7:\r\nbits_per_pixel = 7; break;\r\ncase IA_CSS_STREAM_FORMAT_RAW_8:\r\ncase IA_CSS_STREAM_FORMAT_BINARY_8:\r\ncase IA_CSS_STREAM_FORMAT_YUV420_8:\r\nbits_per_pixel = 8; break;\r\ncase IA_CSS_STREAM_FORMAT_YUV420_10:\r\ncase IA_CSS_STREAM_FORMAT_RAW_10:\r\n#if !defined(HAS_NO_PACKED_RAW_PIXELS)\r\nbits_per_pixel = 10;\r\n#else\r\nbits_per_pixel = 16;\r\n#endif\r\nbreak;\r\ncase IA_CSS_STREAM_FORMAT_YUV420_8_LEGACY:\r\ncase IA_CSS_STREAM_FORMAT_RAW_12:\r\nbits_per_pixel = 12; break;\r\ncase IA_CSS_STREAM_FORMAT_RAW_14:\r\nbits_per_pixel = 14; break;\r\ncase IA_CSS_STREAM_FORMAT_RGB_444:\r\ncase IA_CSS_STREAM_FORMAT_RGB_555:\r\ncase IA_CSS_STREAM_FORMAT_RGB_565:\r\ncase IA_CSS_STREAM_FORMAT_YUV422_8:\r\nbits_per_pixel = 16; break;\r\ncase IA_CSS_STREAM_FORMAT_RGB_666:\r\nbits_per_pixel = 18; break;\r\ncase IA_CSS_STREAM_FORMAT_YUV422_10:\r\nbits_per_pixel = 20; break;\r\ncase IA_CSS_STREAM_FORMAT_RGB_888:\r\nbits_per_pixel = 24; break;\r\ncase IA_CSS_STREAM_FORMAT_YUV420_16:\r\ncase IA_CSS_STREAM_FORMAT_YUV422_16:\r\ncase IA_CSS_STREAM_FORMAT_RAW_16:\r\ndefault:\r\nreturn IA_CSS_ERR_INVALID_ARGUMENTS;\r\n}\r\nodd_line_bytes = (width_padded * bits_per_pixel + 7) >> 3;\r\nif (format == IA_CSS_STREAM_FORMAT_YUV420_8\r\n|| format == IA_CSS_STREAM_FORMAT_YUV420_10\r\n|| format == IA_CSS_STREAM_FORMAT_YUV420_16) {\r\neven_line_bytes = (width_padded * 2 * bits_per_pixel + 7) >> 3;\r\n} else {\r\neven_line_bytes = odd_line_bytes;\r\n}\r\nwords_per_odd_line = (odd_line_bytes + 3) >> 2;\r\nwords_per_even_line = (even_line_bytes + 3) >> 2;\r\nwords_for_first_line = words_per_odd_line + 2 + (hasSOLandEOL ? 1 : 0);\r\nwords_per_odd_line += (1 + (hasSOLandEOL ? 2 : 0));\r\nwords_per_even_line += (1 + (hasSOLandEOL ? 2 : 0));\r\nmem_words_per_odd_line = (words_per_odd_line + 7) >> 3;\r\nmem_words_for_first_line = (words_for_first_line + 7) >> 3;\r\nmem_words_per_even_line = (words_per_even_line + 7) >> 3;\r\nmem_words_for_EOF = 1;\r\nmem_words = ((embedded_data_size_words + 7) >> 3) +\r\nmem_words_for_first_line +\r\n(((height + 1) >> 1) - 1) * mem_words_per_odd_line +\r\n(height >> 1) * mem_words_per_even_line +\r\nmem_words_for_EOF;\r\n*size_mem_words = mem_words;\r\nIA_CSS_LEAVE_ERR(err);\r\nreturn err;\r\n}\r\nenum ia_css_err\r\nia_css_mipi_frame_enable_check_on_size(const enum ia_css_csi2_port port,\r\nconst unsigned int size_mem_words)\r\n{\r\nuint32_t idx;\r\nenum ia_css_err err = IA_CSS_ERR_RESOURCE_NOT_AVAILABLE;\r\nOP___assert(port < N_CSI_PORTS);\r\nOP___assert(size_mem_words != 0);\r\nfor (idx = 0; idx < IA_CSS_MIPI_SIZE_CHECK_MAX_NOF_ENTRIES_PER_PORT &&\r\nmy_css.mipi_sizes_for_check[port][idx] != 0;\r\nidx++) {\r\n}\r\nif (idx < IA_CSS_MIPI_SIZE_CHECK_MAX_NOF_ENTRIES_PER_PORT) {\r\nmy_css.mipi_sizes_for_check[port][idx] = size_mem_words;\r\nerr = IA_CSS_SUCCESS;\r\n}\r\nreturn err;\r\n}\r\nvoid\r\nmipi_init(void)\r\n{\r\n#if defined(USE_INPUT_SYSTEM_VERSION_2) || defined(USE_INPUT_SYSTEM_VERSION_2401)\r\nunsigned int i;\r\nfor (i = 0; i < N_CSI_PORTS; i++)\r\nref_count_mipi_allocation[i] = 0;\r\n#endif\r\n}\r\nenum ia_css_err\r\ncalculate_mipi_buff_size(\r\nstruct ia_css_stream_config *stream_cfg,\r\nunsigned int *size_mem_words)\r\n{\r\n#if !defined(USE_INPUT_SYSTEM_VERSION_2401)\r\nenum ia_css_err err = IA_CSS_ERR_INTERNAL_ERROR;\r\n(void)stream_cfg;\r\n(void)size_mem_words;\r\n#else\r\nunsigned int width;\r\nunsigned int height;\r\nenum ia_css_stream_format format;\r\nbool pack_raw_pixels;\r\nunsigned int width_padded;\r\nunsigned int bits_per_pixel = 0;\r\nunsigned int even_line_bytes = 0;\r\nunsigned int odd_line_bytes = 0;\r\nunsigned int words_per_odd_line = 0;\r\nunsigned int words_per_even_line = 0;\r\nunsigned int mem_words_per_even_line = 0;\r\nunsigned int mem_words_per_odd_line = 0;\r\nunsigned int mem_words_per_buff_line = 0;\r\nunsigned int mem_words_per_buff = 0;\r\nenum ia_css_err err = IA_CSS_SUCCESS;\r\nwidth = stream_cfg->input_config.input_res.width;\r\nheight = stream_cfg->input_config.input_res.height;\r\nformat = stream_cfg->input_config.format;\r\npack_raw_pixels = stream_cfg->pack_raw_pixels;\r\nwidth_padded = width + (2 * ISP_VEC_NELEMS);\r\nIA_CSS_ENTER("padded_width=%d, height=%d, format=%d\n",\r\nwidth_padded, height, format);\r\nbits_per_pixel = sh_css_stream_format_2_bits_per_subpixel(format);\r\nbits_per_pixel =\r\n(format == IA_CSS_STREAM_FORMAT_RAW_10 && pack_raw_pixels) ? bits_per_pixel : 16;\r\nif (bits_per_pixel == 0)\r\nreturn IA_CSS_ERR_INTERNAL_ERROR;\r\nodd_line_bytes = (width_padded * bits_per_pixel + 7) >> 3;\r\nif (format == IA_CSS_STREAM_FORMAT_YUV420_8\r\n|| format == IA_CSS_STREAM_FORMAT_YUV420_10) {\r\neven_line_bytes = (width_padded * 2 * bits_per_pixel + 7) >> 3;\r\n} else {\r\neven_line_bytes = odd_line_bytes;\r\n}\r\nwords_per_odd_line = (odd_line_bytes + 3) >> 2;\r\nwords_per_even_line = (even_line_bytes + 3) >> 2;\r\nmem_words_per_odd_line = (words_per_odd_line + 7) >> 3;\r\nmem_words_per_even_line = (words_per_even_line + 7) >> 3;\r\nmem_words_per_buff_line =\r\n(mem_words_per_odd_line > mem_words_per_even_line) ? mem_words_per_odd_line : mem_words_per_even_line;\r\nmem_words_per_buff = mem_words_per_buff_line * height;\r\n*size_mem_words = mem_words_per_buff;\r\nIA_CSS_LEAVE_ERR(err);\r\n#endif\r\nreturn err;\r\n}\r\nenum ia_css_err\r\nsend_mipi_frames(struct ia_css_pipe *pipe)\r\n{\r\n#if defined(USE_INPUT_SYSTEM_VERSION_2) || defined(USE_INPUT_SYSTEM_VERSION_2401)\r\nenum ia_css_err err = IA_CSS_ERR_INTERNAL_ERROR;\r\nunsigned int i;\r\n#ifndef ISP2401\r\nunsigned int port;\r\n#else\r\nunsigned int port = 0;\r\n#endif\r\nIA_CSS_ENTER_PRIVATE("pipe=%p", pipe);\r\nassert(pipe != NULL);\r\nassert(pipe->stream != NULL);\r\nif (pipe == NULL || pipe->stream == NULL) {\r\nIA_CSS_ERROR("pipe or stream is null");\r\nreturn IA_CSS_ERR_INVALID_ARGUMENTS;\r\n}\r\n#ifndef ISP2401\r\nif (pipe->stream->config.mode != IA_CSS_INPUT_MODE_BUFFERED_SENSOR) {\r\n#else\r\nif (!(pipe->stream->config.mode == IA_CSS_INPUT_MODE_BUFFERED_SENSOR ||\r\npipe->stream->config.mode == IA_CSS_INPUT_MODE_TPG ||\r\npipe->stream->config.mode == IA_CSS_INPUT_MODE_PRBS)) {\r\n#endif\r\nIA_CSS_LOG("nothing to be done for this mode");\r\nreturn IA_CSS_SUCCESS;\r\n}\r\n#ifndef ISP2401\r\nport = (unsigned int) pipe->stream->config.source.port.port;\r\nassert(port < N_CSI_PORTS);\r\nif (port >= N_CSI_PORTS) {\r\nIA_CSS_ERROR("invalid port specified (%d)", port);\r\n#else\r\nif (!ia_css_mipi_is_source_port_valid(pipe, &port)) {\r\nIA_CSS_ERROR("send_mipi_frames(%p) exit: invalid port specified (port=%d).\n", pipe, port);\r\n#endif\r\nreturn err;\r\n}\r\nfor (i = 0; i < my_css.num_mipi_frames[port]; i++) {\r\nsh_css_update_host2sp_mipi_frame(port * NUM_MIPI_FRAMES_PER_STREAM + i,\r\nmy_css.mipi_frames[port][i]);\r\nsh_css_update_host2sp_mipi_metadata(port * NUM_MIPI_FRAMES_PER_STREAM + i,\r\nmy_css.mipi_metadata[port][i]);\r\n}\r\nsh_css_update_host2sp_num_mipi_frames(my_css.num_mipi_frames[port]);\r\nif (!sh_css_sp_is_running()) {\r\nIA_CSS_ERROR("sp is not running");\r\nreturn err;\r\n}\r\nia_css_bufq_enqueue_psys_event(\r\nIA_CSS_PSYS_SW_EVENT_MIPI_BUFFERS_READY,\r\n(uint8_t)port,\r\n(uint8_t)my_css.num_mipi_frames[port],\r\n0 );\r\nIA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_SUCCESS);\r\n#else\r\n(void)pipe;\r\n#endif\r\nreturn IA_CSS_SUCCESS;\r\n}
