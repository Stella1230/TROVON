static inline int plt_reg_to_parent(int reg)\r\n{\r\nswitch (reg & PMC_MASK_CLK_FREQ) {\r\ndefault:\r\ncase PMC_CLK_FREQ_XTAL:\r\nreturn 0;\r\ncase PMC_CLK_FREQ_PLL:\r\nreturn 1;\r\n}\r\n}\r\nstatic inline int plt_parent_to_reg(int index)\r\n{\r\nswitch (index) {\r\ndefault:\r\ncase 0:\r\nreturn PMC_CLK_FREQ_XTAL;\r\ncase 1:\r\nreturn PMC_CLK_FREQ_PLL;\r\n}\r\n}\r\nstatic inline int plt_reg_to_enabled(int reg)\r\n{\r\nswitch (reg & PMC_MASK_CLK_CTL) {\r\ncase PMC_CLK_CTL_GATED_ON_D3:\r\ncase PMC_CLK_CTL_FORCE_ON:\r\nreturn 1;\r\ncase PMC_CLK_CTL_FORCE_OFF:\r\ncase PMC_CLK_CTL_RESERVED:\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic void plt_clk_reg_update(struct clk_plt *clk, u32 mask, u32 val)\r\n{\r\nu32 tmp;\r\nunsigned long flags;\r\nspin_lock_irqsave(&clk->lock, flags);\r\ntmp = readl(clk->reg);\r\ntmp = (tmp & ~mask) | (val & mask);\r\nwritel(tmp, clk->reg);\r\nspin_unlock_irqrestore(&clk->lock, flags);\r\n}\r\nstatic int plt_clk_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct clk_plt *clk = to_clk_plt(hw);\r\nplt_clk_reg_update(clk, PMC_MASK_CLK_FREQ, plt_parent_to_reg(index));\r\nreturn 0;\r\n}\r\nstatic u8 plt_clk_get_parent(struct clk_hw *hw)\r\n{\r\nstruct clk_plt *clk = to_clk_plt(hw);\r\nu32 value;\r\nvalue = readl(clk->reg);\r\nreturn plt_reg_to_parent(value);\r\n}\r\nstatic int plt_clk_enable(struct clk_hw *hw)\r\n{\r\nstruct clk_plt *clk = to_clk_plt(hw);\r\nplt_clk_reg_update(clk, PMC_MASK_CLK_CTL, PMC_CLK_CTL_FORCE_ON);\r\nreturn 0;\r\n}\r\nstatic void plt_clk_disable(struct clk_hw *hw)\r\n{\r\nstruct clk_plt *clk = to_clk_plt(hw);\r\nplt_clk_reg_update(clk, PMC_MASK_CLK_CTL, PMC_CLK_CTL_FORCE_OFF);\r\n}\r\nstatic int plt_clk_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct clk_plt *clk = to_clk_plt(hw);\r\nu32 value;\r\nvalue = readl(clk->reg);\r\nreturn plt_reg_to_enabled(value);\r\n}\r\nstatic struct clk_plt *plt_clk_register(struct platform_device *pdev, int id,\r\nvoid __iomem *base,\r\nconst char **parent_names,\r\nint num_parents)\r\n{\r\nstruct clk_plt *pclk;\r\nstruct clk_init_data init;\r\nint ret;\r\npclk = devm_kzalloc(&pdev->dev, sizeof(*pclk), GFP_KERNEL);\r\nif (!pclk)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = kasprintf(GFP_KERNEL, "%s_%d", PLT_CLK_NAME_BASE, id);\r\ninit.ops = &plt_clk_ops;\r\ninit.flags = 0;\r\ninit.parent_names = parent_names;\r\ninit.num_parents = num_parents;\r\npclk->hw.init = &init;\r\npclk->reg = base + PMC_CLK_CTL_OFFSET + id * PMC_CLK_CTL_SIZE;\r\nspin_lock_init(&pclk->lock);\r\nif (plt_clk_is_enabled(&pclk->hw))\r\ninit.flags |= CLK_IS_CRITICAL;\r\nret = devm_clk_hw_register(&pdev->dev, &pclk->hw);\r\nif (ret) {\r\npclk = ERR_PTR(ret);\r\ngoto err_free_init;\r\n}\r\npclk->lookup = clkdev_hw_create(&pclk->hw, init.name, NULL);\r\nif (!pclk->lookup) {\r\npclk = ERR_PTR(-ENOMEM);\r\ngoto err_free_init;\r\n}\r\nerr_free_init:\r\nkfree(init.name);\r\nreturn pclk;\r\n}\r\nstatic void plt_clk_unregister(struct clk_plt *pclk)\r\n{\r\nclkdev_drop(pclk->lookup);\r\n}\r\nstatic struct clk_plt_fixed *plt_clk_register_fixed_rate(struct platform_device *pdev,\r\nconst char *name,\r\nconst char *parent_name,\r\nunsigned long fixed_rate)\r\n{\r\nstruct clk_plt_fixed *pclk;\r\npclk = devm_kzalloc(&pdev->dev, sizeof(*pclk), GFP_KERNEL);\r\nif (!pclk)\r\nreturn ERR_PTR(-ENOMEM);\r\npclk->clk = clk_hw_register_fixed_rate(&pdev->dev, name, parent_name,\r\n0, fixed_rate);\r\nif (IS_ERR(pclk->clk))\r\nreturn ERR_CAST(pclk->clk);\r\npclk->lookup = clkdev_hw_create(pclk->clk, name, NULL);\r\nif (!pclk->lookup) {\r\nclk_hw_unregister_fixed_rate(pclk->clk);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nreturn pclk;\r\n}\r\nstatic void plt_clk_unregister_fixed_rate(struct clk_plt_fixed *pclk)\r\n{\r\nclkdev_drop(pclk->lookup);\r\nclk_hw_unregister_fixed_rate(pclk->clk);\r\n}\r\nstatic void plt_clk_unregister_fixed_rate_loop(struct clk_plt_data *data,\r\nunsigned int i)\r\n{\r\nwhile (i--)\r\nplt_clk_unregister_fixed_rate(data->parents[i]);\r\n}\r\nstatic void plt_clk_free_parent_names_loop(const char **parent_names,\r\nunsigned int i)\r\n{\r\nwhile (i--)\r\nkfree_const(parent_names[i]);\r\nkfree(parent_names);\r\n}\r\nstatic void plt_clk_unregister_loop(struct clk_plt_data *data,\r\nunsigned int i)\r\n{\r\nwhile (i--)\r\nplt_clk_unregister(data->clks[i]);\r\n}\r\nstatic const char **plt_clk_register_parents(struct platform_device *pdev,\r\nstruct clk_plt_data *data,\r\nconst struct pmc_clk *clks)\r\n{\r\nconst char **parent_names;\r\nunsigned int i;\r\nint err;\r\nint nparents = 0;\r\ndata->nparents = 0;\r\nwhile (clks[nparents].name)\r\nnparents++;\r\ndata->parents = devm_kcalloc(&pdev->dev, nparents,\r\nsizeof(*data->parents), GFP_KERNEL);\r\nif (!data->parents)\r\nreturn ERR_PTR(-ENOMEM);\r\nparent_names = kcalloc(nparents, sizeof(*parent_names),\r\nGFP_KERNEL);\r\nif (!parent_names)\r\nreturn ERR_PTR(-ENOMEM);\r\nfor (i = 0; i < nparents; i++) {\r\ndata->parents[i] =\r\nplt_clk_register_fixed_rate(pdev, clks[i].name,\r\nclks[i].parent_name,\r\nclks[i].freq);\r\nif (IS_ERR(data->parents[i])) {\r\nerr = PTR_ERR(data->parents[i]);\r\ngoto err_unreg;\r\n}\r\nparent_names[i] = kstrdup_const(clks[i].name, GFP_KERNEL);\r\n}\r\ndata->nparents = nparents;\r\nreturn parent_names;\r\nerr_unreg:\r\nplt_clk_unregister_fixed_rate_loop(data, i);\r\nplt_clk_free_parent_names_loop(parent_names, i);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void plt_clk_unregister_parents(struct clk_plt_data *data)\r\n{\r\nplt_clk_unregister_fixed_rate_loop(data, data->nparents);\r\n}\r\nstatic int plt_clk_probe(struct platform_device *pdev)\r\n{\r\nconst struct pmc_clk_data *pmc_data;\r\nconst char **parent_names;\r\nstruct clk_plt_data *data;\r\nunsigned int i;\r\nint err;\r\npmc_data = dev_get_platdata(&pdev->dev);\r\nif (!pmc_data || !pmc_data->clks)\r\nreturn -EINVAL;\r\ndata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nparent_names = plt_clk_register_parents(pdev, data, pmc_data->clks);\r\nif (IS_ERR(parent_names))\r\nreturn PTR_ERR(parent_names);\r\nfor (i = 0; i < PMC_CLK_NUM; i++) {\r\ndata->clks[i] = plt_clk_register(pdev, i, pmc_data->base,\r\nparent_names, data->nparents);\r\nif (IS_ERR(data->clks[i])) {\r\nerr = PTR_ERR(data->clks[i]);\r\ngoto err_unreg_clk_plt;\r\n}\r\n}\r\ndata->mclk_lookup = clkdev_hw_create(&data->clks[3]->hw, "mclk", NULL);\r\nif (!data->mclk_lookup) {\r\nerr = -ENOMEM;\r\ngoto err_unreg_clk_plt;\r\n}\r\nplt_clk_free_parent_names_loop(parent_names, data->nparents);\r\nplatform_set_drvdata(pdev, data);\r\nreturn 0;\r\nerr_unreg_clk_plt:\r\nplt_clk_unregister_loop(data, i);\r\nplt_clk_unregister_parents(data);\r\nplt_clk_free_parent_names_loop(parent_names, data->nparents);\r\nreturn err;\r\n}\r\nstatic int plt_clk_remove(struct platform_device *pdev)\r\n{\r\nstruct clk_plt_data *data;\r\ndata = platform_get_drvdata(pdev);\r\nclkdev_drop(data->mclk_lookup);\r\nplt_clk_unregister_loop(data, PMC_CLK_NUM);\r\nplt_clk_unregister_parents(data);\r\nreturn 0;\r\n}
