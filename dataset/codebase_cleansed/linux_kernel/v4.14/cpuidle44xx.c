static int omap_enter_idle_simple(struct cpuidle_device *dev,\r\nstruct cpuidle_driver *drv,\r\nint index)\r\n{\r\nomap_do_wfi();\r\nreturn index;\r\n}\r\nstatic int omap_enter_idle_smp(struct cpuidle_device *dev,\r\nstruct cpuidle_driver *drv,\r\nint index)\r\n{\r\nstruct idle_statedata *cx = state_ptr + index;\r\nunsigned long flag;\r\nraw_spin_lock_irqsave(&mpu_lock, flag);\r\ncx->mpu_state_vote++;\r\nif (cx->mpu_state_vote == num_online_cpus()) {\r\npwrdm_set_logic_retst(mpu_pd, cx->mpu_logic_state);\r\nomap_set_pwrdm_state(mpu_pd, cx->mpu_state);\r\n}\r\nraw_spin_unlock_irqrestore(&mpu_lock, flag);\r\nomap4_enter_lowpower(dev->cpu, cx->cpu_state);\r\nraw_spin_lock_irqsave(&mpu_lock, flag);\r\nif (cx->mpu_state_vote == num_online_cpus())\r\nomap_set_pwrdm_state(mpu_pd, PWRDM_POWER_ON);\r\ncx->mpu_state_vote--;\r\nraw_spin_unlock_irqrestore(&mpu_lock, flag);\r\nreturn index;\r\n}\r\nstatic int omap_enter_idle_coupled(struct cpuidle_device *dev,\r\nstruct cpuidle_driver *drv,\r\nint index)\r\n{\r\nstruct idle_statedata *cx = state_ptr + index;\r\nu32 mpuss_can_lose_context = 0;\r\nif (dev->cpu == 0 && cpumask_test_cpu(1, cpu_online_mask)) {\r\nwhile (pwrdm_read_pwrst(cpu_pd[1]) != PWRDM_POWER_OFF) {\r\ncpu_relax();\r\nif (cpu_done[1])\r\ngoto fail;\r\n}\r\n}\r\nmpuss_can_lose_context = (cx->mpu_state == PWRDM_POWER_RET) &&\r\n(cx->mpu_logic_state == PWRDM_POWER_OFF);\r\ntick_broadcast_enter();\r\ncpu_pm_enter();\r\nif (dev->cpu == 0) {\r\npwrdm_set_logic_retst(mpu_pd, cx->mpu_logic_state);\r\nomap_set_pwrdm_state(mpu_pd, cx->mpu_state);\r\nif (mpuss_can_lose_context)\r\ncpu_cluster_pm_enter();\r\n}\r\nomap4_enter_lowpower(dev->cpu, cx->cpu_state);\r\ncpu_done[dev->cpu] = true;\r\nif (dev->cpu == 0 && cpumask_test_cpu(1, cpu_online_mask)) {\r\nif (IS_PM44XX_ERRATUM(PM_OMAP4_ROM_SMP_BOOT_ERRATUM_GICD) &&\r\nmpuss_can_lose_context)\r\ngic_dist_disable();\r\nclkdm_deny_idle(cpu_clkdm[1]);\r\nomap_set_pwrdm_state(cpu_pd[1], PWRDM_POWER_ON);\r\nclkdm_allow_idle(cpu_clkdm[1]);\r\nif (IS_PM44XX_ERRATUM(PM_OMAP4_ROM_SMP_BOOT_ERRATUM_GICD) &&\r\nmpuss_can_lose_context) {\r\nwhile (gic_dist_disabled()) {\r\nudelay(1);\r\ncpu_relax();\r\n}\r\ngic_timer_retrigger();\r\n}\r\n}\r\ncpu_pm_exit();\r\nif (dev->cpu == 0 && mpuss_can_lose_context)\r\ncpu_cluster_pm_exit();\r\ntick_broadcast_exit();\r\nfail:\r\ncpuidle_coupled_parallel_barrier(dev, &abort_barrier);\r\ncpu_done[dev->cpu] = false;\r\nreturn index;\r\n}\r\nstatic void omap_setup_broadcast_timer(void *arg)\r\n{\r\ntick_broadcast_enable();\r\n}\r\nint __init omap4_idle_init(void)\r\n{\r\nstruct cpuidle_driver *idle_driver;\r\nif (soc_is_omap54xx()) {\r\nstate_ptr = &omap5_idle_data[0];\r\nidle_driver = &omap5_idle_driver;\r\n} else {\r\nstate_ptr = &omap4_idle_data[0];\r\nidle_driver = &omap4_idle_driver;\r\n}\r\nmpu_pd = pwrdm_lookup("mpu_pwrdm");\r\ncpu_pd[0] = pwrdm_lookup("cpu0_pwrdm");\r\ncpu_pd[1] = pwrdm_lookup("cpu1_pwrdm");\r\nif ((!mpu_pd) || (!cpu_pd[0]) || (!cpu_pd[1]))\r\nreturn -ENODEV;\r\ncpu_clkdm[0] = clkdm_lookup("mpu0_clkdm");\r\ncpu_clkdm[1] = clkdm_lookup("mpu1_clkdm");\r\nif (!cpu_clkdm[0] || !cpu_clkdm[1])\r\nreturn -ENODEV;\r\non_each_cpu(omap_setup_broadcast_timer, NULL, 1);\r\nreturn cpuidle_register(idle_driver, cpu_online_mask);\r\n}
