static void ctr_set_enable(u64 *state, int ctr_set)\r\n{\r\n*state |= cpumf_state_ctl[ctr_set] << CPUMF_LCCTL_ENABLE_SHIFT;\r\n}\r\nstatic void ctr_set_disable(u64 *state, int ctr_set)\r\n{\r\n*state &= ~(cpumf_state_ctl[ctr_set] << CPUMF_LCCTL_ENABLE_SHIFT);\r\n}\r\nstatic void ctr_set_start(u64 *state, int ctr_set)\r\n{\r\n*state |= cpumf_state_ctl[ctr_set] << CPUMF_LCCTL_ACTCTL_SHIFT;\r\n}\r\nstatic void ctr_set_stop(u64 *state, int ctr_set)\r\n{\r\n*state &= ~(cpumf_state_ctl[ctr_set] << CPUMF_LCCTL_ACTCTL_SHIFT);\r\n}\r\nstatic enum cpumf_ctr_set get_counter_set(u64 event)\r\n{\r\nint set = CPUMF_CTR_SET_MAX;\r\nif (event < 32)\r\nset = CPUMF_CTR_SET_BASIC;\r\nelse if (event < 64)\r\nset = CPUMF_CTR_SET_USER;\r\nelse if (event < 128)\r\nset = CPUMF_CTR_SET_CRYPTO;\r\nelse if (event < 256)\r\nset = CPUMF_CTR_SET_EXT;\r\nelse if (event >= 448 && event < 496)\r\nset = CPUMF_CTR_SET_MT_DIAG;\r\nreturn set;\r\n}\r\nstatic int validate_ctr_version(const struct hw_perf_event *hwc)\r\n{\r\nstruct cpu_hw_events *cpuhw;\r\nint err = 0;\r\nu16 mtdiag_ctl;\r\ncpuhw = &get_cpu_var(cpu_hw_events);\r\nswitch (hwc->config_base) {\r\ncase CPUMF_CTR_SET_BASIC:\r\ncase CPUMF_CTR_SET_USER:\r\nif (cpuhw->info.cfvn < 1)\r\nerr = -EOPNOTSUPP;\r\nbreak;\r\ncase CPUMF_CTR_SET_CRYPTO:\r\ncase CPUMF_CTR_SET_EXT:\r\nif (cpuhw->info.csvn < 1)\r\nerr = -EOPNOTSUPP;\r\nif ((cpuhw->info.csvn == 1 && hwc->config > 159) ||\r\n(cpuhw->info.csvn == 2 && hwc->config > 175) ||\r\n(cpuhw->info.csvn > 2 && hwc->config > 255))\r\nerr = -EOPNOTSUPP;\r\nbreak;\r\ncase CPUMF_CTR_SET_MT_DIAG:\r\nif (cpuhw->info.csvn <= 3)\r\nerr = -EOPNOTSUPP;\r\nmtdiag_ctl = cpumf_state_ctl[CPUMF_CTR_SET_MT_DIAG];\r\nif (!((cpuhw->info.auth_ctl & mtdiag_ctl) &&\r\n(cpuhw->info.enable_ctl & mtdiag_ctl) &&\r\n(cpuhw->info.act_ctl & mtdiag_ctl)))\r\nerr = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nput_cpu_var(cpu_hw_events);\r\nreturn err;\r\n}\r\nstatic int validate_ctr_auth(const struct hw_perf_event *hwc)\r\n{\r\nstruct cpu_hw_events *cpuhw;\r\nu64 ctrs_state;\r\nint err = 0;\r\ncpuhw = &get_cpu_var(cpu_hw_events);\r\nctrs_state = cpumf_state_ctl[hwc->config_base];\r\nif (!(ctrs_state & cpuhw->info.auth_ctl))\r\nerr = -ENOENT;\r\nput_cpu_var(cpu_hw_events);\r\nreturn err;\r\n}\r\nstatic void cpumf_pmu_enable(struct pmu *pmu)\r\n{\r\nstruct cpu_hw_events *cpuhw = this_cpu_ptr(&cpu_hw_events);\r\nint err;\r\nif (cpuhw->flags & PMU_F_ENABLED)\r\nreturn;\r\nerr = lcctl(cpuhw->state);\r\nif (err) {\r\npr_err("Enabling the performance measuring unit "\r\n"failed with rc=%x\n", err);\r\nreturn;\r\n}\r\ncpuhw->flags |= PMU_F_ENABLED;\r\n}\r\nstatic void cpumf_pmu_disable(struct pmu *pmu)\r\n{\r\nstruct cpu_hw_events *cpuhw = this_cpu_ptr(&cpu_hw_events);\r\nint err;\r\nu64 inactive;\r\nif (!(cpuhw->flags & PMU_F_ENABLED))\r\nreturn;\r\ninactive = cpuhw->state & ~((1 << CPUMF_LCCTL_ENABLE_SHIFT) - 1);\r\nerr = lcctl(inactive);\r\nif (err) {\r\npr_err("Disabling the performance measuring unit "\r\n"failed with rc=%x\n", err);\r\nreturn;\r\n}\r\ncpuhw->flags &= ~PMU_F_ENABLED;\r\n}\r\nstatic void cpumf_measurement_alert(struct ext_code ext_code,\r\nunsigned int alert, unsigned long unused)\r\n{\r\nstruct cpu_hw_events *cpuhw;\r\nif (!(alert & CPU_MF_INT_CF_MASK))\r\nreturn;\r\ninc_irq_stat(IRQEXT_CMC);\r\ncpuhw = this_cpu_ptr(&cpu_hw_events);\r\nif (!(cpuhw->flags & PMU_F_RESERVED))\r\nreturn;\r\nif (alert & CPU_MF_INT_CF_CACA)\r\nqctri(&cpuhw->info);\r\nif (alert & CPU_MF_INT_CF_LCDA)\r\npr_err("CPU[%i] Counter data was lost\n", smp_processor_id());\r\nif (alert & CPU_MF_INT_CF_MTDA)\r\npr_warn("CPU[%i] MT counter data was lost\n",\r\nsmp_processor_id());\r\n}\r\nstatic void setup_pmc_cpu(void *flags)\r\n{\r\nstruct cpu_hw_events *cpuhw = this_cpu_ptr(&cpu_hw_events);\r\nswitch (*((int *) flags)) {\r\ncase PMC_INIT:\r\nmemset(&cpuhw->info, 0, sizeof(cpuhw->info));\r\nqctri(&cpuhw->info);\r\ncpuhw->flags |= PMU_F_RESERVED;\r\nbreak;\r\ncase PMC_RELEASE:\r\ncpuhw->flags &= ~PMU_F_RESERVED;\r\nbreak;\r\n}\r\nlcctl(0);\r\n}\r\nstatic int reserve_pmc_hardware(void)\r\n{\r\nint flags = PMC_INIT;\r\non_each_cpu(setup_pmc_cpu, &flags, 1);\r\nirq_subclass_register(IRQ_SUBCLASS_MEASUREMENT_ALERT);\r\nreturn 0;\r\n}\r\nstatic void release_pmc_hardware(void)\r\n{\r\nint flags = PMC_RELEASE;\r\non_each_cpu(setup_pmc_cpu, &flags, 1);\r\nirq_subclass_unregister(IRQ_SUBCLASS_MEASUREMENT_ALERT);\r\n}\r\nstatic void hw_perf_event_destroy(struct perf_event *event)\r\n{\r\nif (!atomic_add_unless(&num_events, -1, 1)) {\r\nmutex_lock(&pmc_reserve_mutex);\r\nif (atomic_dec_return(&num_events) == 0)\r\nrelease_pmc_hardware();\r\nmutex_unlock(&pmc_reserve_mutex);\r\n}\r\n}\r\nstatic int __hw_perf_event_init(struct perf_event *event)\r\n{\r\nstruct perf_event_attr *attr = &event->attr;\r\nstruct hw_perf_event *hwc = &event->hw;\r\nenum cpumf_ctr_set set;\r\nint err;\r\nu64 ev;\r\nswitch (attr->type) {\r\ncase PERF_TYPE_RAW:\r\nif (attr->exclude_kernel || attr->exclude_user ||\r\nattr->exclude_hv)\r\nreturn -EOPNOTSUPP;\r\nev = attr->config;\r\nbreak;\r\ncase PERF_TYPE_HARDWARE:\r\nev = attr->config;\r\nif (!attr->exclude_user && attr->exclude_kernel) {\r\nif (ev >= ARRAY_SIZE(cpumf_generic_events_user))\r\nreturn -EOPNOTSUPP;\r\nev = cpumf_generic_events_user[ev];\r\n} else if (!attr->exclude_kernel && attr->exclude_user) {\r\nreturn -EOPNOTSUPP;\r\n} else {\r\nif (ev >= ARRAY_SIZE(cpumf_generic_events_basic))\r\nreturn -EOPNOTSUPP;\r\nev = cpumf_generic_events_basic[ev];\r\n}\r\nbreak;\r\ndefault:\r\nreturn -ENOENT;\r\n}\r\nif (ev == -1)\r\nreturn -ENOENT;\r\nif (ev > PERF_CPUM_CF_MAX_CTR)\r\nreturn -EINVAL;\r\nset = get_counter_set(ev);\r\nswitch (set) {\r\ncase CPUMF_CTR_SET_BASIC:\r\ncase CPUMF_CTR_SET_USER:\r\ncase CPUMF_CTR_SET_CRYPTO:\r\ncase CPUMF_CTR_SET_EXT:\r\ncase CPUMF_CTR_SET_MT_DIAG:\r\nhwc->config = ev;\r\nhwc->config_base = set;\r\nbreak;\r\ncase CPUMF_CTR_SET_MAX:\r\nreturn -EINVAL;\r\n};\r\nif (!atomic_inc_not_zero(&num_events)) {\r\nmutex_lock(&pmc_reserve_mutex);\r\nif (atomic_read(&num_events) == 0 && reserve_pmc_hardware())\r\nerr = -EBUSY;\r\nelse\r\natomic_inc(&num_events);\r\nmutex_unlock(&pmc_reserve_mutex);\r\n}\r\nevent->destroy = hw_perf_event_destroy;\r\nerr = validate_ctr_auth(hwc);\r\nif (!err)\r\nerr = validate_ctr_version(hwc);\r\nreturn err;\r\n}\r\nstatic int cpumf_pmu_event_init(struct perf_event *event)\r\n{\r\nint err;\r\nswitch (event->attr.type) {\r\ncase PERF_TYPE_HARDWARE:\r\ncase PERF_TYPE_HW_CACHE:\r\ncase PERF_TYPE_RAW:\r\nerr = __hw_perf_event_init(event);\r\nbreak;\r\ndefault:\r\nreturn -ENOENT;\r\n}\r\nif (unlikely(err) && event->destroy)\r\nevent->destroy(event);\r\nreturn err;\r\n}\r\nstatic int hw_perf_event_reset(struct perf_event *event)\r\n{\r\nu64 prev, new;\r\nint err;\r\ndo {\r\nprev = local64_read(&event->hw.prev_count);\r\nerr = ecctr(event->hw.config, &new);\r\nif (err) {\r\nif (err != 3)\r\nbreak;\r\nnew = 0;\r\n}\r\n} while (local64_cmpxchg(&event->hw.prev_count, prev, new) != prev);\r\nreturn err;\r\n}\r\nstatic void hw_perf_event_update(struct perf_event *event)\r\n{\r\nu64 prev, new, delta;\r\nint err;\r\ndo {\r\nprev = local64_read(&event->hw.prev_count);\r\nerr = ecctr(event->hw.config, &new);\r\nif (err)\r\nreturn;\r\n} while (local64_cmpxchg(&event->hw.prev_count, prev, new) != prev);\r\ndelta = (prev <= new) ? new - prev\r\n: (-1ULL - prev) + new + 1;\r\nlocal64_add(delta, &event->count);\r\n}\r\nstatic void cpumf_pmu_read(struct perf_event *event)\r\n{\r\nif (event->hw.state & PERF_HES_STOPPED)\r\nreturn;\r\nhw_perf_event_update(event);\r\n}\r\nstatic void cpumf_pmu_start(struct perf_event *event, int flags)\r\n{\r\nstruct cpu_hw_events *cpuhw = this_cpu_ptr(&cpu_hw_events);\r\nstruct hw_perf_event *hwc = &event->hw;\r\nif (WARN_ON_ONCE(!(hwc->state & PERF_HES_STOPPED)))\r\nreturn;\r\nif (WARN_ON_ONCE(hwc->config == -1))\r\nreturn;\r\nif (flags & PERF_EF_RELOAD)\r\nWARN_ON_ONCE(!(hwc->state & PERF_HES_UPTODATE));\r\nhwc->state = 0;\r\nctr_set_enable(&cpuhw->state, hwc->config_base);\r\nctr_set_start(&cpuhw->state, hwc->config_base);\r\nhw_perf_event_reset(event);\r\natomic_inc(&cpuhw->ctr_set[hwc->config_base]);\r\n}\r\nstatic void cpumf_pmu_stop(struct perf_event *event, int flags)\r\n{\r\nstruct cpu_hw_events *cpuhw = this_cpu_ptr(&cpu_hw_events);\r\nstruct hw_perf_event *hwc = &event->hw;\r\nif (!(hwc->state & PERF_HES_STOPPED)) {\r\nif (!atomic_dec_return(&cpuhw->ctr_set[hwc->config_base]))\r\nctr_set_stop(&cpuhw->state, hwc->config_base);\r\nevent->hw.state |= PERF_HES_STOPPED;\r\n}\r\nif ((flags & PERF_EF_UPDATE) && !(hwc->state & PERF_HES_UPTODATE)) {\r\nhw_perf_event_update(event);\r\nevent->hw.state |= PERF_HES_UPTODATE;\r\n}\r\n}\r\nstatic int cpumf_pmu_add(struct perf_event *event, int flags)\r\n{\r\nstruct cpu_hw_events *cpuhw = this_cpu_ptr(&cpu_hw_events);\r\nif (!(cpuhw->txn_flags & PERF_PMU_TXN_ADD))\r\nif (validate_ctr_auth(&event->hw))\r\nreturn -ENOENT;\r\nctr_set_enable(&cpuhw->state, event->hw.config_base);\r\nevent->hw.state = PERF_HES_UPTODATE | PERF_HES_STOPPED;\r\nif (flags & PERF_EF_START)\r\ncpumf_pmu_start(event, PERF_EF_RELOAD);\r\nperf_event_update_userpage(event);\r\nreturn 0;\r\n}\r\nstatic void cpumf_pmu_del(struct perf_event *event, int flags)\r\n{\r\nstruct cpu_hw_events *cpuhw = this_cpu_ptr(&cpu_hw_events);\r\ncpumf_pmu_stop(event, PERF_EF_UPDATE);\r\nif (!atomic_read(&cpuhw->ctr_set[event->hw.config_base]))\r\nctr_set_disable(&cpuhw->state, event->hw.config_base);\r\nperf_event_update_userpage(event);\r\n}\r\nstatic void cpumf_pmu_start_txn(struct pmu *pmu, unsigned int txn_flags)\r\n{\r\nstruct cpu_hw_events *cpuhw = this_cpu_ptr(&cpu_hw_events);\r\nWARN_ON_ONCE(cpuhw->txn_flags);\r\ncpuhw->txn_flags = txn_flags;\r\nif (txn_flags & ~PERF_PMU_TXN_ADD)\r\nreturn;\r\nperf_pmu_disable(pmu);\r\ncpuhw->tx_state = cpuhw->state;\r\n}\r\nstatic void cpumf_pmu_cancel_txn(struct pmu *pmu)\r\n{\r\nunsigned int txn_flags;\r\nstruct cpu_hw_events *cpuhw = this_cpu_ptr(&cpu_hw_events);\r\nWARN_ON_ONCE(!cpuhw->txn_flags);\r\ntxn_flags = cpuhw->txn_flags;\r\ncpuhw->txn_flags = 0;\r\nif (txn_flags & ~PERF_PMU_TXN_ADD)\r\nreturn;\r\nWARN_ON(cpuhw->tx_state != cpuhw->state);\r\nperf_pmu_enable(pmu);\r\n}\r\nstatic int cpumf_pmu_commit_txn(struct pmu *pmu)\r\n{\r\nstruct cpu_hw_events *cpuhw = this_cpu_ptr(&cpu_hw_events);\r\nu64 state;\r\nWARN_ON_ONCE(!cpuhw->txn_flags);\r\nif (cpuhw->txn_flags & ~PERF_PMU_TXN_ADD) {\r\ncpuhw->txn_flags = 0;\r\nreturn 0;\r\n}\r\nstate = cpuhw->state & ~((1 << CPUMF_LCCTL_ENABLE_SHIFT) - 1);\r\nstate >>= CPUMF_LCCTL_ENABLE_SHIFT;\r\nif ((state & cpuhw->info.auth_ctl) != state)\r\nreturn -ENOENT;\r\ncpuhw->txn_flags = 0;\r\nperf_pmu_enable(pmu);\r\nreturn 0;\r\n}\r\nstatic int cpumf_pmf_setup(unsigned int cpu, int flags)\r\n{\r\nlocal_irq_disable();\r\nsetup_pmc_cpu(&flags);\r\nlocal_irq_enable();\r\nreturn 0;\r\n}\r\nstatic int s390_pmu_online_cpu(unsigned int cpu)\r\n{\r\nreturn cpumf_pmf_setup(cpu, PMC_INIT);\r\n}\r\nstatic int s390_pmu_offline_cpu(unsigned int cpu)\r\n{\r\nreturn cpumf_pmf_setup(cpu, PMC_RELEASE);\r\n}\r\nstatic int __init cpumf_pmu_init(void)\r\n{\r\nint rc;\r\nif (!cpum_cf_avail())\r\nreturn -ENODEV;\r\nctl_clear_bit(0, 48);\r\nrc = register_external_irq(EXT_IRQ_MEASURE_ALERT,\r\ncpumf_measurement_alert);\r\nif (rc) {\r\npr_err("Registering for CPU-measurement alerts "\r\n"failed with rc=%i\n", rc);\r\nreturn rc;\r\n}\r\ncpumf_pmu.attr_groups = cpumf_cf_event_group();\r\nrc = perf_pmu_register(&cpumf_pmu, "cpum_cf", PERF_TYPE_RAW);\r\nif (rc) {\r\npr_err("Registering the cpum_cf PMU failed with rc=%i\n", rc);\r\nunregister_external_irq(EXT_IRQ_MEASURE_ALERT,\r\ncpumf_measurement_alert);\r\nreturn rc;\r\n}\r\nreturn cpuhp_setup_state(CPUHP_AP_PERF_S390_CF_ONLINE,\r\n"perf/s390/cf:online",\r\ns390_pmu_online_cpu, s390_pmu_offline_cpu);\r\n}
