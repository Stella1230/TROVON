void __fsnotify_inode_delete(struct inode *inode)\r\n{\r\nfsnotify_clear_marks_by_inode(inode);\r\n}\r\nvoid __fsnotify_vfsmount_delete(struct vfsmount *mnt)\r\n{\r\nfsnotify_clear_marks_by_mount(mnt);\r\n}\r\nvoid fsnotify_unmount_inodes(struct super_block *sb)\r\n{\r\nstruct inode *inode, *iput_inode = NULL;\r\nspin_lock(&sb->s_inode_list_lock);\r\nlist_for_each_entry(inode, &sb->s_inodes, i_sb_list) {\r\nspin_lock(&inode->i_lock);\r\nif (inode->i_state & (I_FREEING|I_WILL_FREE|I_NEW)) {\r\nspin_unlock(&inode->i_lock);\r\ncontinue;\r\n}\r\nif (!atomic_read(&inode->i_count)) {\r\nspin_unlock(&inode->i_lock);\r\ncontinue;\r\n}\r\n__iget(inode);\r\nspin_unlock(&inode->i_lock);\r\nspin_unlock(&sb->s_inode_list_lock);\r\nif (iput_inode)\r\niput(iput_inode);\r\nfsnotify(inode, FS_UNMOUNT, inode, FSNOTIFY_EVENT_INODE, NULL, 0);\r\nfsnotify_inode_delete(inode);\r\niput_inode = inode;\r\nspin_lock(&sb->s_inode_list_lock);\r\n}\r\nspin_unlock(&sb->s_inode_list_lock);\r\nif (iput_inode)\r\niput(iput_inode);\r\n}\r\nvoid __fsnotify_update_child_dentry_flags(struct inode *inode)\r\n{\r\nstruct dentry *alias;\r\nint watched;\r\nif (!S_ISDIR(inode->i_mode))\r\nreturn;\r\nwatched = fsnotify_inode_watches_children(inode);\r\nspin_lock(&inode->i_lock);\r\nhlist_for_each_entry(alias, &inode->i_dentry, d_u.d_alias) {\r\nstruct dentry *child;\r\nspin_lock(&alias->d_lock);\r\nlist_for_each_entry(child, &alias->d_subdirs, d_child) {\r\nif (!child->d_inode)\r\ncontinue;\r\nspin_lock_nested(&child->d_lock, DENTRY_D_LOCK_NESTED);\r\nif (watched)\r\nchild->d_flags |= DCACHE_FSNOTIFY_PARENT_WATCHED;\r\nelse\r\nchild->d_flags &= ~DCACHE_FSNOTIFY_PARENT_WATCHED;\r\nspin_unlock(&child->d_lock);\r\n}\r\nspin_unlock(&alias->d_lock);\r\n}\r\nspin_unlock(&inode->i_lock);\r\n}\r\nint __fsnotify_parent(const struct path *path, struct dentry *dentry, __u32 mask)\r\n{\r\nstruct dentry *parent;\r\nstruct inode *p_inode;\r\nint ret = 0;\r\nif (!dentry)\r\ndentry = path->dentry;\r\nif (!(dentry->d_flags & DCACHE_FSNOTIFY_PARENT_WATCHED))\r\nreturn 0;\r\nparent = dget_parent(dentry);\r\np_inode = parent->d_inode;\r\nif (unlikely(!fsnotify_inode_watches_children(p_inode)))\r\n__fsnotify_update_child_dentry_flags(p_inode);\r\nelse if (p_inode->i_fsnotify_mask & mask) {\r\nstruct name_snapshot name;\r\nmask |= FS_EVENT_ON_CHILD;\r\ntake_dentry_name_snapshot(&name, dentry);\r\nif (path)\r\nret = fsnotify(p_inode, mask, path, FSNOTIFY_EVENT_PATH,\r\nname.name, 0);\r\nelse\r\nret = fsnotify(p_inode, mask, dentry->d_inode, FSNOTIFY_EVENT_INODE,\r\nname.name, 0);\r\nrelease_dentry_name_snapshot(&name);\r\n}\r\ndput(parent);\r\nreturn ret;\r\n}\r\nstatic int send_to_group(struct inode *to_tell,\r\nstruct fsnotify_mark *inode_mark,\r\nstruct fsnotify_mark *vfsmount_mark,\r\n__u32 mask, const void *data,\r\nint data_is, u32 cookie,\r\nconst unsigned char *file_name,\r\nstruct fsnotify_iter_info *iter_info)\r\n{\r\nstruct fsnotify_group *group = NULL;\r\n__u32 inode_test_mask = 0;\r\n__u32 vfsmount_test_mask = 0;\r\nif (unlikely(!inode_mark && !vfsmount_mark)) {\r\nBUG();\r\nreturn 0;\r\n}\r\nif (mask & FS_MODIFY) {\r\nif (inode_mark &&\r\n!(inode_mark->flags & FSNOTIFY_MARK_FLAG_IGNORED_SURV_MODIFY))\r\ninode_mark->ignored_mask = 0;\r\nif (vfsmount_mark &&\r\n!(vfsmount_mark->flags & FSNOTIFY_MARK_FLAG_IGNORED_SURV_MODIFY))\r\nvfsmount_mark->ignored_mask = 0;\r\n}\r\nif (inode_mark) {\r\ngroup = inode_mark->group;\r\ninode_test_mask = (mask & ~FS_EVENT_ON_CHILD);\r\ninode_test_mask &= inode_mark->mask;\r\ninode_test_mask &= ~inode_mark->ignored_mask;\r\n}\r\nif (vfsmount_mark) {\r\nvfsmount_test_mask = (mask & ~FS_EVENT_ON_CHILD);\r\ngroup = vfsmount_mark->group;\r\nvfsmount_test_mask &= vfsmount_mark->mask;\r\nvfsmount_test_mask &= ~vfsmount_mark->ignored_mask;\r\nif (inode_mark)\r\nvfsmount_test_mask &= ~inode_mark->ignored_mask;\r\n}\r\npr_debug("%s: group=%p to_tell=%p mask=%x inode_mark=%p"\r\n" inode_test_mask=%x vfsmount_mark=%p vfsmount_test_mask=%x"\r\n" data=%p data_is=%d cookie=%d\n",\r\n__func__, group, to_tell, mask, inode_mark,\r\ninode_test_mask, vfsmount_mark, vfsmount_test_mask, data,\r\ndata_is, cookie);\r\nif (!inode_test_mask && !vfsmount_test_mask)\r\nreturn 0;\r\nreturn group->ops->handle_event(group, to_tell, inode_mark,\r\nvfsmount_mark, mask, data, data_is,\r\nfile_name, cookie, iter_info);\r\n}\r\nint fsnotify(struct inode *to_tell, __u32 mask, const void *data, int data_is,\r\nconst unsigned char *file_name, u32 cookie)\r\n{\r\nstruct hlist_node *inode_node = NULL, *vfsmount_node = NULL;\r\nstruct fsnotify_mark *inode_mark = NULL, *vfsmount_mark = NULL;\r\nstruct fsnotify_group *inode_group, *vfsmount_group;\r\nstruct fsnotify_mark_connector *inode_conn, *vfsmount_conn;\r\nstruct fsnotify_iter_info iter_info;\r\nstruct mount *mnt;\r\nint ret = 0;\r\n__u32 test_mask = (mask & ~FS_EVENT_ON_CHILD);\r\nif (data_is == FSNOTIFY_EVENT_PATH)\r\nmnt = real_mount(((const struct path *)data)->mnt);\r\nelse\r\nmnt = NULL;\r\nif (!to_tell->i_fsnotify_marks &&\r\n(!mnt || !mnt->mnt_fsnotify_marks))\r\nreturn 0;\r\nif (!(mask & FS_MODIFY) &&\r\n!(test_mask & to_tell->i_fsnotify_mask) &&\r\n!(mnt && test_mask & mnt->mnt_fsnotify_mask))\r\nreturn 0;\r\niter_info.srcu_idx = srcu_read_lock(&fsnotify_mark_srcu);\r\nif ((mask & FS_MODIFY) ||\r\n(test_mask & to_tell->i_fsnotify_mask)) {\r\ninode_conn = srcu_dereference(to_tell->i_fsnotify_marks,\r\n&fsnotify_mark_srcu);\r\nif (inode_conn)\r\ninode_node = srcu_dereference(inode_conn->list.first,\r\n&fsnotify_mark_srcu);\r\n}\r\nif (mnt && ((mask & FS_MODIFY) ||\r\n(test_mask & mnt->mnt_fsnotify_mask))) {\r\ninode_conn = srcu_dereference(to_tell->i_fsnotify_marks,\r\n&fsnotify_mark_srcu);\r\nif (inode_conn)\r\ninode_node = srcu_dereference(inode_conn->list.first,\r\n&fsnotify_mark_srcu);\r\nvfsmount_conn = srcu_dereference(mnt->mnt_fsnotify_marks,\r\n&fsnotify_mark_srcu);\r\nif (vfsmount_conn)\r\nvfsmount_node = srcu_dereference(\r\nvfsmount_conn->list.first,\r\n&fsnotify_mark_srcu);\r\n}\r\nwhile (inode_node || vfsmount_node) {\r\ninode_group = NULL;\r\ninode_mark = NULL;\r\nvfsmount_group = NULL;\r\nvfsmount_mark = NULL;\r\nif (inode_node) {\r\ninode_mark = hlist_entry(srcu_dereference(inode_node, &fsnotify_mark_srcu),\r\nstruct fsnotify_mark, obj_list);\r\ninode_group = inode_mark->group;\r\n}\r\nif (vfsmount_node) {\r\nvfsmount_mark = hlist_entry(srcu_dereference(vfsmount_node, &fsnotify_mark_srcu),\r\nstruct fsnotify_mark, obj_list);\r\nvfsmount_group = vfsmount_mark->group;\r\n}\r\nif (inode_group && vfsmount_group) {\r\nint cmp = fsnotify_compare_groups(inode_group,\r\nvfsmount_group);\r\nif (cmp > 0) {\r\ninode_group = NULL;\r\ninode_mark = NULL;\r\n} else if (cmp < 0) {\r\nvfsmount_group = NULL;\r\nvfsmount_mark = NULL;\r\n}\r\n}\r\niter_info.inode_mark = inode_mark;\r\niter_info.vfsmount_mark = vfsmount_mark;\r\nret = send_to_group(to_tell, inode_mark, vfsmount_mark, mask,\r\ndata, data_is, cookie, file_name,\r\n&iter_info);\r\nif (ret && (mask & ALL_FSNOTIFY_PERM_EVENTS))\r\ngoto out;\r\nif (inode_group)\r\ninode_node = srcu_dereference(inode_node->next,\r\n&fsnotify_mark_srcu);\r\nif (vfsmount_group)\r\nvfsmount_node = srcu_dereference(vfsmount_node->next,\r\n&fsnotify_mark_srcu);\r\n}\r\nret = 0;\r\nout:\r\nsrcu_read_unlock(&fsnotify_mark_srcu, iter_info.srcu_idx);\r\nreturn ret;\r\n}\r\nstatic __init int fsnotify_init(void)\r\n{\r\nint ret;\r\nBUG_ON(hweight32(ALL_FSNOTIFY_EVENTS) != 23);\r\nret = init_srcu_struct(&fsnotify_mark_srcu);\r\nif (ret)\r\npanic("initializing fsnotify_mark_srcu");\r\nfsnotify_mark_connector_cachep = KMEM_CACHE(fsnotify_mark_connector,\r\nSLAB_PANIC);\r\nreturn 0;\r\n}
