static int wdt87xx_i2c_xfer(struct i2c_client *client,\r\nvoid *txdata, size_t txlen,\r\nvoid *rxdata, size_t rxlen)\r\n{\r\nstruct i2c_msg msgs[] = {\r\n{\r\n.addr = client->addr,\r\n.flags = 0,\r\n.len = txlen,\r\n.buf = txdata,\r\n},\r\n{\r\n.addr = client->addr,\r\n.flags = I2C_M_RD,\r\n.len = rxlen,\r\n.buf = rxdata,\r\n},\r\n};\r\nint error;\r\nint ret;\r\nret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\r\nif (ret != ARRAY_SIZE(msgs)) {\r\nerror = ret < 0 ? ret : -EIO;\r\ndev_err(&client->dev, "%s: i2c transfer failed: %d\n",\r\n__func__, error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wdt87xx_get_desc(struct i2c_client *client, u8 desc_idx,\r\nu8 *buf, size_t len)\r\n{\r\nu8 tx_buf[] = { 0x22, 0x00, 0x10, 0x0E, 0x23, 0x00 };\r\nint error;\r\ntx_buf[2] |= desc_idx & 0xF;\r\nerror = wdt87xx_i2c_xfer(client, tx_buf, sizeof(tx_buf),\r\nbuf, len);\r\nif (error) {\r\ndev_err(&client->dev, "get desc failed: %d\n", error);\r\nreturn error;\r\n}\r\nif (buf[0] != len) {\r\ndev_err(&client->dev, "unexpected response to get desc: %d\n",\r\nbuf[0]);\r\nreturn -EINVAL;\r\n}\r\nmdelay(WDT_COMMAND_DELAY_MS);\r\nreturn 0;\r\n}\r\nstatic int wdt87xx_get_string(struct i2c_client *client, u8 str_idx,\r\nu8 *buf, size_t len)\r\n{\r\nu8 tx_buf[] = { 0x22, 0x00, 0x13, 0x0E, str_idx, 0x23, 0x00 };\r\nu8 rx_buf[PKT_WRITE_SIZE];\r\nsize_t rx_len = len + 2;\r\nint error;\r\nif (rx_len > sizeof(rx_buf))\r\nreturn -EINVAL;\r\nerror = wdt87xx_i2c_xfer(client, tx_buf, sizeof(tx_buf),\r\nrx_buf, rx_len);\r\nif (error) {\r\ndev_err(&client->dev, "get string failed: %d\n", error);\r\nreturn error;\r\n}\r\nif (rx_buf[1] != 0x03) {\r\ndev_err(&client->dev, "unexpected response to get string: %d\n",\r\nrx_buf[1]);\r\nreturn -EINVAL;\r\n}\r\nrx_len = min_t(size_t, len, rx_buf[0]);\r\nmemcpy(buf, &rx_buf[2], rx_len);\r\nmdelay(WDT_COMMAND_DELAY_MS);\r\nreturn 0;\r\n}\r\nstatic int wdt87xx_get_feature(struct i2c_client *client,\r\nu8 *buf, size_t buf_size)\r\n{\r\nu8 tx_buf[8];\r\nu8 rx_buf[PKT_WRITE_SIZE];\r\nsize_t tx_len = 0;\r\nsize_t rx_len = buf_size + 2;\r\nint error;\r\nif (rx_len > sizeof(rx_buf))\r\nreturn -EINVAL;\r\ntx_buf[tx_len++] = 0x22;\r\ntx_buf[tx_len++] = 0x00;\r\nif (buf[CMD_REPORT_ID_OFFSET] > 0xF) {\r\ntx_buf[tx_len++] = 0x30;\r\ntx_buf[tx_len++] = 0x02;\r\ntx_buf[tx_len++] = buf[CMD_REPORT_ID_OFFSET];\r\n} else {\r\ntx_buf[tx_len++] = 0x30 | buf[CMD_REPORT_ID_OFFSET];\r\ntx_buf[tx_len++] = 0x02;\r\n}\r\ntx_buf[tx_len++] = 0x23;\r\ntx_buf[tx_len++] = 0x00;\r\nerror = wdt87xx_i2c_xfer(client, tx_buf, tx_len, rx_buf, rx_len);\r\nif (error) {\r\ndev_err(&client->dev, "get feature failed: %d\n", error);\r\nreturn error;\r\n}\r\nrx_len = min_t(size_t, buf_size, get_unaligned_le16(rx_buf));\r\nmemcpy(buf, &rx_buf[2], rx_len);\r\nmdelay(WDT_COMMAND_DELAY_MS);\r\nreturn 0;\r\n}\r\nstatic int wdt87xx_set_feature(struct i2c_client *client,\r\nconst u8 *buf, size_t buf_size)\r\n{\r\nu8 tx_buf[PKT_WRITE_SIZE];\r\nint tx_len = 0;\r\nint error;\r\ntx_buf[tx_len++] = 0x22;\r\ntx_buf[tx_len++] = 0x00;\r\nif (buf[CMD_REPORT_ID_OFFSET] > 0xF) {\r\ntx_buf[tx_len++] = 0x30;\r\ntx_buf[tx_len++] = 0x03;\r\ntx_buf[tx_len++] = buf[CMD_REPORT_ID_OFFSET];\r\n} else {\r\ntx_buf[tx_len++] = 0x30 | buf[CMD_REPORT_ID_OFFSET];\r\ntx_buf[tx_len++] = 0x03;\r\n}\r\ntx_buf[tx_len++] = 0x23;\r\ntx_buf[tx_len++] = 0x00;\r\ntx_buf[tx_len++] = (buf_size & 0xFF);\r\ntx_buf[tx_len++] = ((buf_size & 0xFF00) >> 8);\r\nif (tx_len + buf_size > sizeof(tx_buf))\r\nreturn -EINVAL;\r\nmemcpy(&tx_buf[tx_len], buf, buf_size);\r\ntx_len += buf_size;\r\nerror = i2c_master_send(client, tx_buf, tx_len);\r\nif (error < 0) {\r\ndev_err(&client->dev, "set feature failed: %d\n", error);\r\nreturn error;\r\n}\r\nmdelay(WDT_COMMAND_DELAY_MS);\r\nreturn 0;\r\n}\r\nstatic int wdt87xx_send_command(struct i2c_client *client, int cmd, int value)\r\n{\r\nu8 cmd_buf[CMD_BUF_SIZE];\r\ncmd_buf[CMD_REPORT_ID_OFFSET] = VND_REQ_WRITE;\r\ncmd_buf[CMD_TYPE_OFFSET] = VND_SET_COMMAND_DATA;\r\nput_unaligned_le16((u16)cmd, &cmd_buf[CMD_INDEX_OFFSET]);\r\nswitch (cmd) {\r\ncase VND_CMD_START:\r\ncase VND_CMD_STOP:\r\ncase VND_CMD_RESET:\r\nput_unaligned_le32((value & 0xFF), &cmd_buf[CMD_LENGTH_OFFSET]);\r\nbreak;\r\ncase VND_CMD_SFLCK:\r\nput_unaligned_le16(CMD_SFLCK_KEY, &cmd_buf[CMD_KEY_OFFSET]);\r\nbreak;\r\ncase VND_CMD_SFUNL:\r\nput_unaligned_le16(CMD_SFUNL_KEY, &cmd_buf[CMD_KEY_OFFSET]);\r\nbreak;\r\ncase VND_CMD_ERASE:\r\ncase VND_SET_CHECKSUM_CALC:\r\ncase VND_SET_CHECKSUM_LENGTH:\r\nput_unaligned_le32(value, &cmd_buf[CMD_KEY_OFFSET]);\r\nbreak;\r\ndefault:\r\ncmd_buf[CMD_REPORT_ID_OFFSET] = 0;\r\ndev_err(&client->dev, "Invalid command: %d\n", cmd);\r\nreturn -EINVAL;\r\n}\r\nreturn wdt87xx_set_feature(client, cmd_buf, sizeof(cmd_buf));\r\n}\r\nstatic int wdt87xx_sw_reset(struct i2c_client *client)\r\n{\r\nint error;\r\ndev_dbg(&client->dev, "resetting device now\n");\r\nerror = wdt87xx_send_command(client, VND_CMD_RESET, 0);\r\nif (error) {\r\ndev_err(&client->dev, "reset failed\n");\r\nreturn error;\r\n}\r\nmsleep(WDT_FW_RESET_TIME);\r\nreturn 0;\r\n}\r\nstatic const void *wdt87xx_get_fw_chunk(const struct firmware *fw, u32 id)\r\n{\r\nsize_t pos = FW_PAYLOAD_OFFSET;\r\nu32 chunk_id, chunk_size;\r\nwhile (pos < fw->size) {\r\nchunk_id = get_unaligned_le32(fw->data +\r\npos + FW_CHUNK_ID_OFFSET);\r\nif (chunk_id == id)\r\nreturn fw->data + pos;\r\nchunk_size = get_unaligned_le32(fw->data +\r\npos + FW_CHUNK_SIZE_OFFSET);\r\npos += chunk_size + 2 * sizeof(u32);\r\n}\r\nreturn NULL;\r\n}\r\nstatic int wdt87xx_get_sysparam(struct i2c_client *client,\r\nstruct wdt87xx_sys_param *param)\r\n{\r\nu8 buf[PKT_READ_SIZE];\r\nint error;\r\nerror = wdt87xx_get_desc(client, WDT_GD_DEVICE, buf, 18);\r\nif (error) {\r\ndev_err(&client->dev, "failed to get device desc\n");\r\nreturn error;\r\n}\r\nparam->vendor_id = get_unaligned_le16(buf + DEV_DESC_OFFSET_VID);\r\nparam->product_id = get_unaligned_le16(buf + DEV_DESC_OFFSET_PID);\r\nerror = wdt87xx_get_string(client, STRIDX_PARAMETERS, buf, 34);\r\nif (error) {\r\ndev_err(&client->dev, "failed to get parameters\n");\r\nreturn error;\r\n}\r\nparam->xmls_id1 = get_unaligned_le16(buf + CTL_PARAM_OFFSET_XMLS_ID1);\r\nparam->xmls_id2 = get_unaligned_le16(buf + CTL_PARAM_OFFSET_XMLS_ID2);\r\nparam->phy_ch_x = get_unaligned_le16(buf + CTL_PARAM_OFFSET_PHY_CH_X);\r\nparam->phy_ch_y = get_unaligned_le16(buf + CTL_PARAM_OFFSET_PHY_CH_Y);\r\nparam->phy_w = get_unaligned_le16(buf + CTL_PARAM_OFFSET_PHY_W) / 10;\r\nparam->phy_h = get_unaligned_le16(buf + CTL_PARAM_OFFSET_PHY_H) / 10;\r\nparam->scaling_factor =\r\nget_unaligned_le16(buf + CTL_PARAM_OFFSET_FACTOR);\r\nparam->max_x = MAX_UNIT_AXIS;\r\nparam->max_y = DIV_ROUND_CLOSEST(MAX_UNIT_AXIS * param->phy_h,\r\nparam->phy_w);\r\nerror = wdt87xx_get_string(client, STRIDX_PLATFORM_ID, buf, 8);\r\nif (error) {\r\ndev_err(&client->dev, "failed to get platform id\n");\r\nreturn error;\r\n}\r\nparam->plat_id = buf[1];\r\nbuf[0] = 0xf2;\r\nerror = wdt87xx_get_feature(client, buf, 16);\r\nif (error) {\r\ndev_err(&client->dev, "failed to get firmware id\n");\r\nreturn error;\r\n}\r\nif (buf[0] != 0xf2) {\r\ndev_err(&client->dev, "wrong id of fw response: 0x%x\n",\r\nbuf[0]);\r\nreturn -EINVAL;\r\n}\r\nparam->fw_id = get_unaligned_le16(&buf[1]);\r\ndev_info(&client->dev,\r\n"fw_id: 0x%x, plat_id: 0x%x, xml_id1: %04x, xml_id2: %04x\n",\r\nparam->fw_id, param->plat_id,\r\nparam->xmls_id1, param->xmls_id2);\r\nreturn 0;\r\n}\r\nstatic int wdt87xx_validate_firmware(struct wdt87xx_data *wdt,\r\nconst struct firmware *fw)\r\n{\r\nconst void *fw_chunk;\r\nu32 data1, data2;\r\nu32 size;\r\nu8 fw_chip_id;\r\nu8 chip_id;\r\ndata1 = get_unaligned_le32(fw->data + FW_FOURCC1_OFFSET);\r\ndata2 = get_unaligned_le32(fw->data + FW_FOURCC2_OFFSET);\r\nif (data1 != FOURCC_ID_RIFF || data2 != FOURCC_ID_WHIF) {\r\ndev_err(&wdt->client->dev, "check fw tag failed\n");\r\nreturn -EINVAL;\r\n}\r\nsize = get_unaligned_le32(fw->data + FW_SIZE_OFFSET);\r\nif (size != fw->size) {\r\ndev_err(&wdt->client->dev,\r\n"fw size mismatch: expected %d, actual %zu\n",\r\nsize, fw->size);\r\nreturn -EINVAL;\r\n}\r\nfw_chunk = wdt87xx_get_fw_chunk(fw, CHUNK_ID_FRWR);\r\nif (!fw_chunk) {\r\ndev_err(&wdt->client->dev,\r\n"unable to locate firmware chunk\n");\r\nreturn -EINVAL;\r\n}\r\nfw_chip_id = (get_unaligned_le32(fw_chunk +\r\nFW_CHUNK_VERSION_OFFSET) >> 12) & 0xF;\r\nchip_id = (wdt->param.fw_id >> 12) & 0xF;\r\nif (fw_chip_id != chip_id) {\r\ndev_err(&wdt->client->dev,\r\n"fw version mismatch: fw %d vs. chip %d\n",\r\nfw_chip_id, chip_id);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wdt87xx_validate_fw_chunk(const void *data, int id)\r\n{\r\nif (id == CHUNK_ID_FRWR) {\r\nu32 fw_id;\r\nfw_id = get_unaligned_le32(data + FW_CHUNK_PAYLOAD_OFFSET);\r\nif (fw_id != WDT_FIRMWARE_ID)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wdt87xx_write_data(struct i2c_client *client, const char *data,\r\nu32 address, int length)\r\n{\r\nu16 packet_size;\r\nint count = 0;\r\nint error;\r\nu8 pkt_buf[PKT_BUF_SIZE];\r\nif ((address & 0x3) != 0 || (length & 0x3) != 0) {\r\ndev_err(&client->dev,\r\n"addr & len must be 4 bytes aligned %x, %x\n",\r\naddress, length);\r\nreturn -EINVAL;\r\n}\r\nwhile (length) {\r\npacket_size = min(length, PACKET_SIZE);\r\npkt_buf[CMD_REPORT_ID_OFFSET] = VND_REQ_WRITE;\r\npkt_buf[CMD_TYPE_OFFSET] = VND_SET_DATA;\r\nput_unaligned_le16(packet_size, &pkt_buf[CMD_INDEX_OFFSET]);\r\nput_unaligned_le32(address, &pkt_buf[CMD_LENGTH_OFFSET]);\r\nmemcpy(&pkt_buf[CMD_DATA_OFFSET], data, packet_size);\r\nerror = wdt87xx_set_feature(client, pkt_buf, sizeof(pkt_buf));\r\nif (error)\r\nreturn error;\r\nlength -= packet_size;\r\ndata += packet_size;\r\naddress += packet_size;\r\nmdelay(WDT_FLASH_WRITE_DELAY_MS);\r\nif ((++count % 32) == 0) {\r\nmsleep(20);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic u16 misr(u16 cur_value, u8 new_value)\r\n{\r\nu32 a, b;\r\nu32 bit0;\r\nu32 y;\r\na = cur_value;\r\nb = new_value;\r\nbit0 = a ^ (b & 1);\r\nbit0 ^= a >> 1;\r\nbit0 ^= a >> 2;\r\nbit0 ^= a >> 4;\r\nbit0 ^= a >> 5;\r\nbit0 ^= a >> 7;\r\nbit0 ^= a >> 11;\r\nbit0 ^= a >> 15;\r\ny = (a << 1) ^ b;\r\ny = (y & ~1) | (bit0 & 1);\r\nreturn (u16)y;\r\n}\r\nstatic u16 wdt87xx_calculate_checksum(const u8 *data, size_t length)\r\n{\r\nu16 checksum = 0;\r\nsize_t i;\r\nfor (i = 0; i < length; i++)\r\nchecksum = misr(checksum, data[i]);\r\nreturn checksum;\r\n}\r\nstatic int wdt87xx_get_checksum(struct i2c_client *client, u16 *checksum,\r\nu32 address, int length)\r\n{\r\nint error;\r\nint time_delay;\r\nu8 pkt_buf[PKT_BUF_SIZE];\r\nu8 cmd_buf[CMD_BUF_SIZE];\r\nerror = wdt87xx_send_command(client, VND_SET_CHECKSUM_LENGTH, length);\r\nif (error) {\r\ndev_err(&client->dev, "failed to set checksum length\n");\r\nreturn error;\r\n}\r\nerror = wdt87xx_send_command(client, VND_SET_CHECKSUM_CALC, address);\r\nif (error) {\r\ndev_err(&client->dev, "failed to set checksum address\n");\r\nreturn error;\r\n}\r\ntime_delay = DIV_ROUND_UP(length, 1024);\r\nmsleep(time_delay * 30);\r\nmemset(cmd_buf, 0, sizeof(cmd_buf));\r\ncmd_buf[CMD_REPORT_ID_OFFSET] = VND_REQ_READ;\r\ncmd_buf[CMD_TYPE_OFFSET] = VND_GET_CHECKSUM;\r\nerror = wdt87xx_set_feature(client, cmd_buf, sizeof(cmd_buf));\r\nif (error) {\r\ndev_err(&client->dev, "failed to request checksum\n");\r\nreturn error;\r\n}\r\nmemset(pkt_buf, 0, sizeof(pkt_buf));\r\npkt_buf[CMD_REPORT_ID_OFFSET] = VND_READ_DATA;\r\nerror = wdt87xx_get_feature(client, pkt_buf, sizeof(pkt_buf));\r\nif (error) {\r\ndev_err(&client->dev, "failed to read checksum\n");\r\nreturn error;\r\n}\r\n*checksum = get_unaligned_le16(&pkt_buf[CMD_DATA_OFFSET]);\r\nreturn 0;\r\n}\r\nstatic int wdt87xx_write_firmware(struct i2c_client *client, const void *chunk)\r\n{\r\nu32 start_addr = get_unaligned_le32(chunk + FW_CHUNK_TGT_START_OFFSET);\r\nu32 size = get_unaligned_le32(chunk + FW_CHUNK_PAYLOAD_LEN_OFFSET);\r\nconst void *data = chunk + FW_CHUNK_PAYLOAD_OFFSET;\r\nint error;\r\nint err1;\r\nint page_size;\r\nint retry = 0;\r\nu16 device_checksum, firmware_checksum;\r\ndev_dbg(&client->dev, "start 4k page program\n");\r\nerror = wdt87xx_send_command(client, VND_CMD_STOP, MODE_STOP);\r\nif (error) {\r\ndev_err(&client->dev, "stop report mode failed\n");\r\nreturn error;\r\n}\r\nerror = wdt87xx_send_command(client, VND_CMD_SFUNL, 0);\r\nif (error) {\r\ndev_err(&client->dev, "unlock failed\n");\r\ngoto out_enable_reporting;\r\n}\r\nmdelay(10);\r\nwhile (size) {\r\ndev_dbg(&client->dev, "%s: %x, %x\n", __func__,\r\nstart_addr, size);\r\npage_size = min_t(u32, size, PG_SIZE);\r\nsize -= page_size;\r\nfor (retry = 0; retry < MAX_RETRIES; retry++) {\r\nerror = wdt87xx_send_command(client, VND_CMD_ERASE,\r\nstart_addr);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"erase failed at %#08x\n", start_addr);\r\nbreak;\r\n}\r\nmsleep(WDT_FLASH_ERASE_DELAY_MS);\r\nerror = wdt87xx_write_data(client, data, start_addr,\r\npage_size);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"write failed at %#08x (%d bytes)\n",\r\nstart_addr, page_size);\r\nbreak;\r\n}\r\nerror = wdt87xx_get_checksum(client, &device_checksum,\r\nstart_addr, page_size);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"failed to retrieve checksum for %#08x (len: %d)\n",\r\nstart_addr, page_size);\r\nbreak;\r\n}\r\nfirmware_checksum =\r\nwdt87xx_calculate_checksum(data, page_size);\r\nif (device_checksum == firmware_checksum)\r\nbreak;\r\ndev_err(&client->dev,\r\n"checksum fail: %d vs %d, retry %d\n",\r\ndevice_checksum, firmware_checksum, retry);\r\n}\r\nif (retry == MAX_RETRIES) {\r\ndev_err(&client->dev, "page write failed\n");\r\nerror = -EIO;\r\ngoto out_lock_device;\r\n}\r\nstart_addr = start_addr + page_size;\r\ndata = data + page_size;\r\n}\r\nout_lock_device:\r\nerr1 = wdt87xx_send_command(client, VND_CMD_SFLCK, 0);\r\nif (err1)\r\ndev_err(&client->dev, "lock failed\n");\r\nmdelay(10);\r\nout_enable_reporting:\r\nerr1 = wdt87xx_send_command(client, VND_CMD_START, 0);\r\nif (err1)\r\ndev_err(&client->dev, "start to report failed\n");\r\nreturn error ? error : err1;\r\n}\r\nstatic int wdt87xx_load_chunk(struct i2c_client *client,\r\nconst struct firmware *fw, u32 ck_id)\r\n{\r\nconst void *chunk;\r\nint error;\r\nchunk = wdt87xx_get_fw_chunk(fw, ck_id);\r\nif (!chunk) {\r\ndev_err(&client->dev, "unable to locate chunk (type %d)\n",\r\nck_id);\r\nreturn -EINVAL;\r\n}\r\nerror = wdt87xx_validate_fw_chunk(chunk, ck_id);\r\nif (error) {\r\ndev_err(&client->dev, "invalid chunk (type %d): %d\n",\r\nck_id, error);\r\nreturn error;\r\n}\r\nerror = wdt87xx_write_firmware(client, chunk);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"failed to write fw chunk (type %d): %d\n",\r\nck_id, error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wdt87xx_do_update_firmware(struct i2c_client *client,\r\nconst struct firmware *fw,\r\nunsigned int chunk_id)\r\n{\r\nstruct wdt87xx_data *wdt = i2c_get_clientdata(client);\r\nint error;\r\nerror = wdt87xx_validate_firmware(wdt, fw);\r\nif (error)\r\nreturn error;\r\nerror = mutex_lock_interruptible(&wdt->fw_mutex);\r\nif (error)\r\nreturn error;\r\ndisable_irq(client->irq);\r\nerror = wdt87xx_load_chunk(client, fw, chunk_id);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"firmware load failed (type: %d): %d\n",\r\nchunk_id, error);\r\ngoto out;\r\n}\r\nerror = wdt87xx_sw_reset(client);\r\nif (error) {\r\ndev_err(&client->dev, "soft reset failed: %d\n", error);\r\ngoto out;\r\n}\r\nerror = wdt87xx_get_sysparam(client, &wdt->param);\r\nif (error)\r\ndev_err(&client->dev,\r\n"failed to refresh system parameters: %d\n", error);\r\nout:\r\nenable_irq(client->irq);\r\nmutex_unlock(&wdt->fw_mutex);\r\nreturn error ? error : 0;\r\n}\r\nstatic int wdt87xx_update_firmware(struct device *dev,\r\nconst char *fw_name, unsigned int chunk_id)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nconst struct firmware *fw;\r\nint error;\r\nerror = request_firmware(&fw, fw_name, dev);\r\nif (error) {\r\ndev_err(&client->dev, "unable to retrieve firmware %s: %d\n",\r\nfw_name, error);\r\nreturn error;\r\n}\r\nerror = wdt87xx_do_update_firmware(client, fw, chunk_id);\r\nrelease_firmware(fw);\r\nreturn error ? error : 0;\r\n}\r\nstatic ssize_t config_csum_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct wdt87xx_data *wdt = i2c_get_clientdata(client);\r\nu32 cfg_csum;\r\ncfg_csum = wdt->param.xmls_id1;\r\ncfg_csum = (cfg_csum << 16) | wdt->param.xmls_id2;\r\nreturn scnprintf(buf, PAGE_SIZE, "%x\n", cfg_csum);\r\n}\r\nstatic ssize_t fw_version_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct wdt87xx_data *wdt = i2c_get_clientdata(client);\r\nreturn scnprintf(buf, PAGE_SIZE, "%x\n", wdt->param.fw_id);\r\n}\r\nstatic ssize_t plat_id_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct wdt87xx_data *wdt = i2c_get_clientdata(client);\r\nreturn scnprintf(buf, PAGE_SIZE, "%x\n", wdt->param.plat_id);\r\n}\r\nstatic ssize_t update_config_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint error;\r\nerror = wdt87xx_update_firmware(dev, WDT87XX_CFG_NAME, CHUNK_ID_CNFG);\r\nreturn error ? error : count;\r\n}\r\nstatic ssize_t update_fw_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint error;\r\nerror = wdt87xx_update_firmware(dev, WDT87XX_FW_NAME, CHUNK_ID_FRWR);\r\nreturn error ? error : count;\r\n}\r\nstatic void wdt87xx_report_contact(struct input_dev *input,\r\nstruct wdt87xx_sys_param *param,\r\nu8 *buf)\r\n{\r\nint finger_id;\r\nu32 x, y, w;\r\nu8 p;\r\nfinger_id = (buf[FINGER_EV_V1_OFFSET_ID] >> 3) - 1;\r\nif (finger_id < 0)\r\nreturn;\r\nif (!(buf[FINGER_EV_V1_OFFSET_ID] & 0x1))\r\nreturn;\r\nw = buf[FINGER_EV_V1_OFFSET_W];\r\nw *= param->scaling_factor;\r\np = buf[FINGER_EV_V1_OFFSET_P];\r\nx = get_unaligned_le16(buf + FINGER_EV_V1_OFFSET_X);\r\ny = get_unaligned_le16(buf + FINGER_EV_V1_OFFSET_Y);\r\ny = DIV_ROUND_CLOSEST(y * param->phy_h, param->phy_w);\r\nif (x > param->max_x || y > param->max_y)\r\nreturn;\r\ndev_dbg(input->dev.parent, "tip on (%d), x(%d), y(%d)\n",\r\nfinger_id, x, y);\r\ninput_mt_slot(input, finger_id);\r\ninput_mt_report_slot_state(input, MT_TOOL_FINGER, 1);\r\ninput_report_abs(input, ABS_MT_TOUCH_MAJOR, w);\r\ninput_report_abs(input, ABS_MT_PRESSURE, p);\r\ninput_report_abs(input, ABS_MT_POSITION_X, x);\r\ninput_report_abs(input, ABS_MT_POSITION_Y, y);\r\n}\r\nstatic irqreturn_t wdt87xx_ts_interrupt(int irq, void *dev_id)\r\n{\r\nstruct wdt87xx_data *wdt = dev_id;\r\nstruct i2c_client *client = wdt->client;\r\nint i, fingers;\r\nint error;\r\nu8 raw_buf[WDT_V1_RAW_BUF_COUNT] = {0};\r\nerror = i2c_master_recv(client, raw_buf, WDT_V1_RAW_BUF_COUNT);\r\nif (error < 0) {\r\ndev_err(&client->dev, "read v1 raw data failed: %d\n", error);\r\ngoto irq_exit;\r\n}\r\nfingers = raw_buf[TOUCH_PK_V1_OFFSET_FNGR_NUM];\r\nif (!fingers)\r\ngoto irq_exit;\r\nfor (i = 0; i < WDT_MAX_FINGER; i++)\r\nwdt87xx_report_contact(wdt->input,\r\n&wdt->param,\r\n&raw_buf[TOUCH_PK_V1_OFFSET_EVENT +\r\ni * FINGER_EV_V1_SIZE]);\r\ninput_mt_sync_frame(wdt->input);\r\ninput_sync(wdt->input);\r\nirq_exit:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int wdt87xx_ts_create_input_device(struct wdt87xx_data *wdt)\r\n{\r\nstruct device *dev = &wdt->client->dev;\r\nstruct input_dev *input;\r\nunsigned int res = DIV_ROUND_CLOSEST(MAX_UNIT_AXIS, wdt->param.phy_w);\r\nint error;\r\ninput = devm_input_allocate_device(dev);\r\nif (!input) {\r\ndev_err(dev, "failed to allocate input device\n");\r\nreturn -ENOMEM;\r\n}\r\nwdt->input = input;\r\ninput->name = "WDT87xx Touchscreen";\r\ninput->id.bustype = BUS_I2C;\r\ninput->id.vendor = wdt->param.vendor_id;\r\ninput->id.product = wdt->param.product_id;\r\ninput->phys = wdt->phys;\r\ninput_set_abs_params(input, ABS_MT_POSITION_X, 0,\r\nwdt->param.max_x, 0, 0);\r\ninput_set_abs_params(input, ABS_MT_POSITION_Y, 0,\r\nwdt->param.max_y, 0, 0);\r\ninput_abs_set_res(input, ABS_MT_POSITION_X, res);\r\ninput_abs_set_res(input, ABS_MT_POSITION_Y, res);\r\ninput_set_abs_params(input, ABS_MT_TOUCH_MAJOR,\r\n0, wdt->param.max_x, 0, 0);\r\ninput_set_abs_params(input, ABS_MT_PRESSURE, 0, 0xFF, 0, 0);\r\ninput_mt_init_slots(input, WDT_MAX_FINGER,\r\nINPUT_MT_DIRECT | INPUT_MT_DROP_UNUSED);\r\nerror = input_register_device(input);\r\nif (error) {\r\ndev_err(dev, "failed to register input device: %d\n", error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wdt87xx_ts_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct wdt87xx_data *wdt;\r\nint error;\r\ndev_dbg(&client->dev, "adapter=%d, client irq: %d\n",\r\nclient->adapter->nr, client->irq);\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\r\nreturn -ENXIO;\r\nwdt = devm_kzalloc(&client->dev, sizeof(*wdt), GFP_KERNEL);\r\nif (!wdt)\r\nreturn -ENOMEM;\r\nwdt->client = client;\r\nmutex_init(&wdt->fw_mutex);\r\ni2c_set_clientdata(client, wdt);\r\nsnprintf(wdt->phys, sizeof(wdt->phys), "i2c-%u-%04x/input0",\r\nclient->adapter->nr, client->addr);\r\nerror = wdt87xx_get_sysparam(client, &wdt->param);\r\nif (error)\r\nreturn error;\r\nerror = wdt87xx_ts_create_input_device(wdt);\r\nif (error)\r\nreturn error;\r\nerror = devm_request_threaded_irq(&client->dev, client->irq,\r\nNULL, wdt87xx_ts_interrupt,\r\nIRQF_ONESHOT,\r\nclient->name, wdt);\r\nif (error) {\r\ndev_err(&client->dev, "request irq failed: %d\n", error);\r\nreturn error;\r\n}\r\nerror = sysfs_create_group(&client->dev.kobj, &wdt87xx_attr_group);\r\nif (error) {\r\ndev_err(&client->dev, "create sysfs failed: %d\n", error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wdt87xx_ts_remove(struct i2c_client *client)\r\n{\r\nsysfs_remove_group(&client->dev.kobj, &wdt87xx_attr_group);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused wdt87xx_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nint error;\r\ndisable_irq(client->irq);\r\nerror = wdt87xx_send_command(client, VND_CMD_STOP, MODE_IDLE);\r\nif (error) {\r\nenable_irq(client->irq);\r\ndev_err(&client->dev,\r\n"failed to stop device when suspending: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused wdt87xx_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nint error;\r\nmdelay(100);\r\nerror = wdt87xx_send_command(client, VND_CMD_START, 0);\r\nif (error)\r\ndev_err(&client->dev,\r\n"failed to start device when resuming: %d\n",\r\nerror);\r\nenable_irq(client->irq);\r\nreturn 0;\r\n}
