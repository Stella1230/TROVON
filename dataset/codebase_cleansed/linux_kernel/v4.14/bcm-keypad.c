static int bcm_kp_get_keycode(struct bcm_kp *kp, int row, int col)\r\n{\r\nunsigned int row_shift = get_count_order(kp->n_cols);\r\nunsigned short *keymap = kp->input_dev->keycode;\r\nreturn keymap[MATRIX_SCAN_CODE(row, col, row_shift)];\r\n}\r\nstatic void bcm_kp_report_keys(struct bcm_kp *kp, int reg_num, int pull_mode)\r\n{\r\nunsigned long state, change;\r\nint bit_nr;\r\nint key_press;\r\nint row, col;\r\nunsigned int keycode;\r\nwritel(0xFFFFFFFF, kp->base + KPICRN_OFFSET(reg_num));\r\nstate = readl(kp->base + KPSSRN_OFFSET(reg_num));\r\nchange = kp->last_state[reg_num] ^ state;\r\nkp->last_state[reg_num] = state;\r\nfor_each_set_bit(bit_nr, &change, BITS_PER_LONG) {\r\nkey_press = state & BIT(bit_nr);\r\nkey_press = pull_mode ? !key_press : key_press;\r\nrow = BIT_TO_ROW_SSRN(bit_nr, reg_num);\r\ncol = BIT_TO_COL(bit_nr);\r\nkeycode = bcm_kp_get_keycode(kp, row, col);\r\ninput_report_key(kp->input_dev, keycode, key_press);\r\n}\r\n}\r\nstatic irqreturn_t bcm_kp_isr_thread(int irq, void *dev_id)\r\n{\r\nstruct bcm_kp *kp = dev_id;\r\nint pull_mode = (kp->kpcr >> KPCR_MODE_SHIFT) & KPCR_MODE_MASK;\r\nint reg_num;\r\nfor (reg_num = 0; reg_num <= 1; reg_num++)\r\nbcm_kp_report_keys(kp, reg_num, pull_mode);\r\ninput_sync(kp->input_dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int bcm_kp_start(struct bcm_kp *kp)\r\n{\r\nint error;\r\nif (kp->clk) {\r\nerror = clk_prepare_enable(kp->clk);\r\nif (error)\r\nreturn error;\r\n}\r\nwritel(kp->kpior, kp->base + KPIOR_OFFSET);\r\nwritel(kp->imr0_val, kp->base + KPIMR0_OFFSET);\r\nwritel(kp->imr1_val, kp->base + KPIMR1_OFFSET);\r\nwritel(kp->kpemr, kp->base + KPEMR0_OFFSET);\r\nwritel(kp->kpemr, kp->base + KPEMR1_OFFSET);\r\nwritel(kp->kpemr, kp->base + KPEMR2_OFFSET);\r\nwritel(kp->kpemr, kp->base + KPEMR3_OFFSET);\r\nwritel(0xFFFFFFFF, kp->base + KPICR0_OFFSET);\r\nwritel(0xFFFFFFFF, kp->base + KPICR1_OFFSET);\r\nkp->last_state[0] = readl(kp->base + KPSSR0_OFFSET);\r\nkp->last_state[0] = readl(kp->base + KPSSR1_OFFSET);\r\nwritel(kp->kpcr | KPCR_ENABLE, kp->base + KPCR_OFFSET);\r\nreturn 0;\r\n}\r\nstatic void bcm_kp_stop(const struct bcm_kp *kp)\r\n{\r\nu32 val;\r\nval = readl(kp->base + KPCR_OFFSET);\r\nval &= ~KPCR_ENABLE;\r\nwritel(0, kp->base + KPCR_OFFSET);\r\nwritel(0, kp->base + KPIMR0_OFFSET);\r\nwritel(0, kp->base + KPIMR1_OFFSET);\r\nwritel(0xFFFFFFFF, kp->base + KPICR0_OFFSET);\r\nwritel(0xFFFFFFFF, kp->base + KPICR1_OFFSET);\r\nif (kp->clk)\r\nclk_disable_unprepare(kp->clk);\r\n}\r\nstatic int bcm_kp_open(struct input_dev *dev)\r\n{\r\nstruct bcm_kp *kp = input_get_drvdata(dev);\r\nreturn bcm_kp_start(kp);\r\n}\r\nstatic void bcm_kp_close(struct input_dev *dev)\r\n{\r\nstruct bcm_kp *kp = input_get_drvdata(dev);\r\nbcm_kp_stop(kp);\r\n}\r\nstatic int bcm_kp_matrix_key_parse_dt(struct bcm_kp *kp)\r\n{\r\nstruct device *dev = kp->input_dev->dev.parent;\r\nstruct device_node *np = dev->of_node;\r\nint error;\r\nunsigned int dt_val;\r\nunsigned int i;\r\nunsigned int num_rows, col_mask, rows_set;\r\nkp->kpcr = KPCR_STATUSFILTERENABLE | KPCR_COLFILTERENABLE;\r\nerror = matrix_keypad_parse_properties(dev, &kp->n_rows, &kp->n_cols);\r\nif (error) {\r\ndev_err(dev, "failed to parse kp params\n");\r\nreturn error;\r\n}\r\nkp->kpcr |= (kp->n_rows - 1) << KPCR_ROWWIDTH_SHIFT;\r\nkp->kpcr |= (kp->n_cols - 1) << KPCR_COLUMNWIDTH_SHIFT;\r\ncol_mask = (1 << (kp->n_cols)) - 1;\r\nnum_rows = kp->n_rows;\r\nkp->imr0_val = col_mask;\r\nrows_set = 1;\r\nwhile (--num_rows && rows_set++ < 4)\r\nkp->imr0_val |= kp->imr0_val << MAX_COLS;\r\nkp->imr1_val = 0;\r\nif (num_rows) {\r\nkp->imr1_val = col_mask;\r\nwhile (--num_rows)\r\nkp->imr1_val |= kp->imr1_val << MAX_COLS;\r\n}\r\nkp->kpemr = 0;\r\nfor (i = 0; i <= 30; i += 2)\r\nkp->kpemr |= (KPEMR_EDGETYPE_BOTH << i);\r\nof_property_read_u32(np, "status-debounce-filter-period", &dt_val);\r\nif (dt_val > KPCR_STATUSFILTERTYPE_MAX) {\r\ndev_err(dev, "Invalid Status filter debounce value %d\n",\r\ndt_val);\r\nreturn -EINVAL;\r\n}\r\nkp->kpcr |= dt_val << KPCR_STATUSFILTERTYPE_SHIFT;\r\nof_property_read_u32(np, "col-debounce-filter-period", &dt_val);\r\nif (dt_val > KPCR_COLFILTERTYPE_MAX) {\r\ndev_err(dev, "Invalid Column filter debounce value %d\n",\r\ndt_val);\r\nreturn -EINVAL;\r\n}\r\nkp->kpcr |= dt_val << KPCR_COLFILTERTYPE_SHIFT;\r\nif (of_property_read_bool(np, "row-output-enabled")) {\r\nkp->kpior = ((1 << kp->n_rows) - 1) <<\r\nKPIOR_ROWOCONTRL_SHIFT;\r\n} else {\r\nkp->kpior = ((1 << kp->n_cols) - 1) <<\r\nKPIOR_COLUMNOCONTRL_SHIFT;\r\n}\r\nif (of_property_read_bool(np, "pull-up-enabled"))\r\nkp->kpcr |= KPCR_MODE;\r\ndev_dbg(dev, "n_rows=%d n_col=%d kpcr=%x kpior=%x kpemr=%x\n",\r\nkp->n_rows, kp->n_cols,\r\nkp->kpcr, kp->kpior, kp->kpemr);\r\nreturn 0;\r\n}\r\nstatic int bcm_kp_probe(struct platform_device *pdev)\r\n{\r\nstruct bcm_kp *kp;\r\nstruct input_dev *input_dev;\r\nstruct resource *res;\r\nint error;\r\nkp = devm_kzalloc(&pdev->dev, sizeof(*kp), GFP_KERNEL);\r\nif (!kp)\r\nreturn -ENOMEM;\r\ninput_dev = devm_input_allocate_device(&pdev->dev);\r\nif (!input_dev) {\r\ndev_err(&pdev->dev, "failed to allocate the input device\n");\r\nreturn -ENOMEM;\r\n}\r\n__set_bit(EV_KEY, input_dev->evbit);\r\nif (of_property_read_bool(pdev->dev.of_node, "autorepeat"))\r\n__set_bit(EV_REP, input_dev->evbit);\r\ninput_dev->name = pdev->name;\r\ninput_dev->phys = "keypad/input0";\r\ninput_dev->dev.parent = &pdev->dev;\r\ninput_dev->open = bcm_kp_open;\r\ninput_dev->close = bcm_kp_close;\r\ninput_dev->id.bustype = BUS_HOST;\r\ninput_dev->id.vendor = 0x0001;\r\ninput_dev->id.product = 0x0001;\r\ninput_dev->id.version = 0x0100;\r\ninput_set_drvdata(input_dev, kp);\r\nkp->input_dev = input_dev;\r\nerror = bcm_kp_matrix_key_parse_dt(kp);\r\nif (error)\r\nreturn error;\r\nerror = matrix_keypad_build_keymap(NULL, NULL,\r\nkp->n_rows, kp->n_cols,\r\nNULL, input_dev);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed to build keymap\n");\r\nreturn error;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "Missing keypad base address resource\n");\r\nreturn -ENODEV;\r\n}\r\nkp->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(kp->base))\r\nreturn PTR_ERR(kp->base);\r\nkp->clk = devm_clk_get(&pdev->dev, "peri_clk");\r\nif (IS_ERR(kp->clk)) {\r\nerror = PTR_ERR(kp->clk);\r\nif (error != -ENOENT) {\r\nif (error != -EPROBE_DEFER)\r\ndev_err(&pdev->dev, "Failed to get clock\n");\r\nreturn error;\r\n}\r\ndev_dbg(&pdev->dev,\r\n"No clock specified. Assuming it's enabled\n");\r\nkp->clk = NULL;\r\n} else {\r\nunsigned int desired_rate;\r\nlong actual_rate;\r\nerror = of_property_read_u32(pdev->dev.of_node,\r\n"clock-frequency", &desired_rate);\r\nif (error < 0)\r\ndesired_rate = DEFAULT_CLK_HZ;\r\nactual_rate = clk_round_rate(kp->clk, desired_rate);\r\nif (actual_rate <= 0)\r\nreturn -EINVAL;\r\nerror = clk_set_rate(kp->clk, actual_rate);\r\nif (error)\r\nreturn error;\r\nerror = clk_prepare_enable(kp->clk);\r\nif (error)\r\nreturn error;\r\n}\r\nbcm_kp_stop(kp);\r\nkp->irq = platform_get_irq(pdev, 0);\r\nif (kp->irq < 0) {\r\ndev_err(&pdev->dev, "no IRQ specified\n");\r\nreturn -EINVAL;\r\n}\r\nerror = devm_request_threaded_irq(&pdev->dev, kp->irq,\r\nNULL, bcm_kp_isr_thread,\r\nIRQF_ONESHOT, pdev->name, kp);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed to request IRQ\n");\r\nreturn error;\r\n}\r\nerror = input_register_device(input_dev);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed to register input device\n");\r\nreturn error;\r\n}\r\nreturn 0;\r\n}
