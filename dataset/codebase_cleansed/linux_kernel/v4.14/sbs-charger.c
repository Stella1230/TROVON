static int sbs_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct sbs_info *chip = power_supply_get_drvdata(psy);\r\nunsigned int reg;\r\nreg = chip->last_state;\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_PRESENT:\r\nval->intval = !!(reg & SBS_CHARGER_STATUS_BATTERY_PRESENT);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_ONLINE:\r\nval->intval = !!(reg & SBS_CHARGER_STATUS_AC_PRESENT);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_STATUS:\r\nval->intval = POWER_SUPPLY_STATUS_UNKNOWN;\r\nif (!(reg & SBS_CHARGER_STATUS_BATTERY_PRESENT))\r\nval->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;\r\nelse if (reg & SBS_CHARGER_STATUS_AC_PRESENT &&\r\n!(reg & SBS_CHARGER_STATUS_CHARGE_INHIBITED))\r\nval->intval = POWER_SUPPLY_STATUS_CHARGING;\r\nelse\r\nval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_HEALTH:\r\nif (reg & SBS_CHARGER_STATUS_RES_COLD)\r\nval->intval = POWER_SUPPLY_HEALTH_COLD;\r\nif (reg & SBS_CHARGER_STATUS_RES_HOT)\r\nval->intval = POWER_SUPPLY_HEALTH_OVERHEAT;\r\nelse\r\nval->intval = POWER_SUPPLY_HEALTH_GOOD;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sbs_check_state(struct sbs_info *chip)\r\n{\r\nunsigned int reg;\r\nint ret;\r\nret = regmap_read(chip->regmap, SBS_CHARGER_REG_STATUS, &reg);\r\nif (!ret && reg != chip->last_state) {\r\nchip->last_state = reg;\r\npower_supply_changed(chip->power_supply);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void sbs_delayed_work(struct work_struct *work)\r\n{\r\nstruct sbs_info *chip = container_of(work, struct sbs_info, work.work);\r\nsbs_check_state(chip);\r\nschedule_delayed_work(&chip->work,\r\nmsecs_to_jiffies(SBS_CHARGER_POLL_TIME));\r\n}\r\nstatic irqreturn_t sbs_irq_thread(int irq, void *data)\r\n{\r\nstruct sbs_info *chip = data;\r\nint ret;\r\nret = sbs_check_state(chip);\r\nreturn ret ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic bool sbs_readable_reg(struct device *dev, unsigned int reg)\r\n{\r\nreturn reg >= SBS_CHARGER_REG_SPEC_INFO;\r\n}\r\nstatic bool sbs_volatile_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase SBS_CHARGER_REG_STATUS:\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int sbs_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct power_supply_config psy_cfg = {};\r\nstruct sbs_info *chip;\r\nint ret, val;\r\nchip = devm_kzalloc(&client->dev, sizeof(struct sbs_info), GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\nchip->client = client;\r\npsy_cfg.of_node = client->dev.of_node;\r\npsy_cfg.drv_data = chip;\r\ni2c_set_clientdata(client, chip);\r\nchip->regmap = devm_regmap_init_i2c(client, &sbs_regmap);\r\nif (IS_ERR(chip->regmap))\r\nreturn PTR_ERR(chip->regmap);\r\nret = regmap_read(chip->regmap, SBS_CHARGER_REG_STATUS, &val);\r\nif (ret) {\r\ndev_err(&client->dev, "Failed to get device status\n");\r\nreturn ret;\r\n}\r\nchip->last_state = val;\r\nchip->power_supply = devm_power_supply_register(&client->dev, &sbs_desc,\r\n&psy_cfg);\r\nif (IS_ERR(chip->power_supply)) {\r\ndev_err(&client->dev, "Failed to register power supply\n");\r\nreturn PTR_ERR(chip->power_supply);\r\n}\r\nif (client->irq) {\r\nret = devm_request_threaded_irq(&client->dev, client->irq,\r\nNULL, sbs_irq_thread,\r\nIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\r\ndev_name(&client->dev), chip);\r\nif (ret) {\r\ndev_err(&client->dev, "Failed to request irq, %d\n", ret);\r\nreturn ret;\r\n}\r\n} else {\r\nINIT_DELAYED_WORK(&chip->work, sbs_delayed_work);\r\nschedule_delayed_work(&chip->work,\r\nmsecs_to_jiffies(SBS_CHARGER_POLL_TIME));\r\n}\r\ndev_info(&client->dev,\r\n"%s: smart charger device registered\n", client->name);\r\nreturn 0;\r\n}\r\nstatic int sbs_remove(struct i2c_client *client)\r\n{\r\nstruct sbs_info *chip = i2c_get_clientdata(client);\r\ncancel_delayed_work_sync(&chip->work);\r\nreturn 0;\r\n}
