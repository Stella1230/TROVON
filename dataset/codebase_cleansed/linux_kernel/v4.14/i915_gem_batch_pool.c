void i915_gem_batch_pool_init(struct intel_engine_cs *engine,\r\nstruct i915_gem_batch_pool *pool)\r\n{\r\nint n;\r\npool->engine = engine;\r\nfor (n = 0; n < ARRAY_SIZE(pool->cache_list); n++)\r\nINIT_LIST_HEAD(&pool->cache_list[n]);\r\n}\r\nvoid i915_gem_batch_pool_fini(struct i915_gem_batch_pool *pool)\r\n{\r\nint n;\r\nlockdep_assert_held(&pool->engine->i915->drm.struct_mutex);\r\nfor (n = 0; n < ARRAY_SIZE(pool->cache_list); n++) {\r\nstruct drm_i915_gem_object *obj, *next;\r\nlist_for_each_entry_safe(obj, next,\r\n&pool->cache_list[n],\r\nbatch_pool_link)\r\n__i915_gem_object_release_unless_active(obj);\r\nINIT_LIST_HEAD(&pool->cache_list[n]);\r\n}\r\n}\r\nstruct drm_i915_gem_object *\r\ni915_gem_batch_pool_get(struct i915_gem_batch_pool *pool,\r\nsize_t size)\r\n{\r\nstruct drm_i915_gem_object *obj;\r\nstruct list_head *list;\r\nint n, ret;\r\nlockdep_assert_held(&pool->engine->i915->drm.struct_mutex);\r\nn = fls(size >> PAGE_SHIFT) - 1;\r\nif (n >= ARRAY_SIZE(pool->cache_list))\r\nn = ARRAY_SIZE(pool->cache_list) - 1;\r\nlist = &pool->cache_list[n];\r\nlist_for_each_entry(obj, list, batch_pool_link) {\r\nif (i915_gem_object_is_active(obj)) {\r\nstruct reservation_object *resv = obj->resv;\r\nif (!reservation_object_test_signaled_rcu(resv, true))\r\nbreak;\r\ni915_gem_retire_requests(pool->engine->i915);\r\nGEM_BUG_ON(i915_gem_object_is_active(obj));\r\nif (rcu_access_pointer(resv->fence)) {\r\nreservation_object_lock(resv, NULL);\r\nreservation_object_add_excl_fence(resv, NULL);\r\nreservation_object_unlock(resv);\r\n}\r\n}\r\nGEM_BUG_ON(!reservation_object_test_signaled_rcu(obj->resv,\r\ntrue));\r\nif (obj->base.size >= size)\r\ngoto found;\r\n}\r\nobj = i915_gem_object_create_internal(pool->engine->i915, size);\r\nif (IS_ERR(obj))\r\nreturn obj;\r\nfound:\r\nret = i915_gem_object_pin_pages(obj);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\nlist_move_tail(&obj->batch_pool_link, list);\r\nreturn obj;\r\n}
