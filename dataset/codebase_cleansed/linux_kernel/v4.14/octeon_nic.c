void *\r\nocteon_alloc_soft_command_resp(struct octeon_device *oct,\r\nunion octeon_instr_64B *cmd,\r\nu32 rdatasize)\r\n{\r\nstruct octeon_soft_command *sc;\r\nstruct octeon_instr_ih3 *ih3;\r\nstruct octeon_instr_ih2 *ih2;\r\nstruct octeon_instr_irh *irh;\r\nstruct octeon_instr_rdp *rdp;\r\nsc = (struct octeon_soft_command *)\r\nocteon_alloc_soft_command(oct, 0, rdatasize, 0);\r\nif (!sc)\r\nreturn NULL;\r\nmemcpy(&sc->cmd, cmd, sizeof(union octeon_instr_64B));\r\nif (OCTEON_CN23XX_PF(oct) || OCTEON_CN23XX_VF(oct)) {\r\nih3 = (struct octeon_instr_ih3 *)&sc->cmd.cmd3.ih3;\r\nrdp = (struct octeon_instr_rdp *)&sc->cmd.cmd3.rdp;\r\nirh = (struct octeon_instr_irh *)&sc->cmd.cmd3.irh;\r\nih3->fsz = LIO_SOFTCMDRESP_IH3;\r\n} else {\r\nih2 = (struct octeon_instr_ih2 *)&sc->cmd.cmd2.ih2;\r\nrdp = (struct octeon_instr_rdp *)&sc->cmd.cmd2.rdp;\r\nirh = (struct octeon_instr_irh *)&sc->cmd.cmd2.irh;\r\nih2->fsz = LIO_SOFTCMDRESP_IH2;\r\n}\r\nirh->rflag = 1;\r\nrdp->pcie_port = oct->pcie_port;\r\nrdp->rlen = rdatasize;\r\n*sc->status_word = COMPLETION_WORD_INIT;\r\nif (OCTEON_CN23XX_PF(oct) || OCTEON_CN23XX_VF(oct))\r\nsc->cmd.cmd3.rptr = sc->dmarptr;\r\nelse\r\nsc->cmd.cmd2.rptr = sc->dmarptr;\r\nsc->wait_time = 1000;\r\nsc->timeout = jiffies + sc->wait_time;\r\nreturn sc;\r\n}\r\nint octnet_send_nic_data_pkt(struct octeon_device *oct,\r\nstruct octnic_data_pkt *ndata)\r\n{\r\nint ring_doorbell = 1;\r\nreturn octeon_send_command(oct, ndata->q_no, ring_doorbell, &ndata->cmd,\r\nndata->buf, ndata->datasize,\r\nndata->reqtype);\r\n}\r\nstatic void octnet_link_ctrl_callback(struct octeon_device *oct,\r\nu32 status,\r\nvoid *sc_ptr)\r\n{\r\nstruct octeon_soft_command *sc = (struct octeon_soft_command *)sc_ptr;\r\nstruct octnic_ctrl_pkt *nctrl;\r\nnctrl = (struct octnic_ctrl_pkt *)sc->ctxptr;\r\nif ((!status || status > FIRMWARE_STATUS_CODE(0)) && nctrl->cb_fn) {\r\nnctrl->status = status;\r\nnctrl->cb_fn(nctrl);\r\n}\r\nocteon_free_soft_command(oct, sc);\r\n}\r\nstatic inline struct octeon_soft_command\r\n*octnic_alloc_ctrl_pkt_sc(struct octeon_device *oct,\r\nstruct octnic_ctrl_pkt *nctrl)\r\n{\r\nstruct octeon_soft_command *sc = NULL;\r\nu8 *data;\r\nu32 rdatasize;\r\nu32 uddsize = 0, datasize = 0;\r\nuddsize = (u32)(nctrl->ncmd.s.more * 8);\r\ndatasize = OCTNET_CMD_SIZE + uddsize;\r\nrdatasize = (nctrl->wait_time) ? 16 : 0;\r\nsc = (struct octeon_soft_command *)\r\nocteon_alloc_soft_command(oct, datasize, rdatasize,\r\nsizeof(struct octnic_ctrl_pkt));\r\nif (!sc)\r\nreturn NULL;\r\nmemcpy(sc->ctxptr, nctrl, sizeof(struct octnic_ctrl_pkt));\r\ndata = (u8 *)sc->virtdptr;\r\nmemcpy(data, &nctrl->ncmd, OCTNET_CMD_SIZE);\r\nocteon_swap_8B_data((u64 *)data, (OCTNET_CMD_SIZE >> 3));\r\nif (uddsize) {\r\nmemcpy(data + OCTNET_CMD_SIZE, nctrl->udd, uddsize);\r\n}\r\nsc->iq_no = (u32)nctrl->iq_no;\r\nocteon_prepare_soft_command(oct, sc, OPCODE_NIC, OPCODE_NIC_CMD,\r\n0, 0, 0);\r\nsc->callback = octnet_link_ctrl_callback;\r\nsc->callback_arg = sc;\r\nsc->wait_time = nctrl->wait_time;\r\nreturn sc;\r\n}\r\nint\r\noctnet_send_nic_ctrl_pkt(struct octeon_device *oct,\r\nstruct octnic_ctrl_pkt *nctrl)\r\n{\r\nint retval;\r\nstruct octeon_soft_command *sc = NULL;\r\nspin_lock_bh(&oct->cmd_resp_wqlock);\r\nif ((oct->cmd_resp_state == OCT_DRV_OFFLINE) &&\r\n(nctrl->ncmd.s.cmd != OCTNET_CMD_RX_CTL)) {\r\nspin_unlock_bh(&oct->cmd_resp_wqlock);\r\ndev_err(&oct->pci_dev->dev,\r\n"%s cmd:%d not processed since driver offline\n",\r\n__func__, nctrl->ncmd.s.cmd);\r\nreturn -1;\r\n}\r\nsc = octnic_alloc_ctrl_pkt_sc(oct, nctrl);\r\nif (!sc) {\r\ndev_err(&oct->pci_dev->dev, "%s soft command alloc failed\n",\r\n__func__);\r\nspin_unlock_bh(&oct->cmd_resp_wqlock);\r\nreturn -1;\r\n}\r\nretval = octeon_send_soft_command(oct, sc);\r\nif (retval == IQ_SEND_FAILED) {\r\nocteon_free_soft_command(oct, sc);\r\ndev_err(&oct->pci_dev->dev, "%s pf_num:%d soft command:%d send failed status: %x\n",\r\n__func__, oct->pf_num, nctrl->ncmd.s.cmd, retval);\r\nspin_unlock_bh(&oct->cmd_resp_wqlock);\r\nreturn -1;\r\n}\r\nspin_unlock_bh(&oct->cmd_resp_wqlock);\r\nreturn retval;\r\n}
