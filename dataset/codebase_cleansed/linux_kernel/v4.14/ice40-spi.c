static enum fpga_mgr_states ice40_fpga_ops_state(struct fpga_manager *mgr)\r\n{\r\nstruct ice40_fpga_priv *priv = mgr->priv;\r\nreturn gpiod_get_value(priv->cdone) ? FPGA_MGR_STATE_OPERATING :\r\nFPGA_MGR_STATE_UNKNOWN;\r\n}\r\nstatic int ice40_fpga_ops_write_init(struct fpga_manager *mgr,\r\nstruct fpga_image_info *info,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ice40_fpga_priv *priv = mgr->priv;\r\nstruct spi_device *dev = priv->dev;\r\nstruct spi_message message;\r\nstruct spi_transfer assert_cs_then_reset_delay = {\r\n.cs_change = 1,\r\n.delay_usecs = ICE40_SPI_RESET_DELAY\r\n};\r\nstruct spi_transfer housekeeping_delay_then_release_cs = {\r\n.delay_usecs = ICE40_SPI_HOUSEKEEPING_DELAY\r\n};\r\nint ret;\r\nif ((info->flags & FPGA_MGR_PARTIAL_RECONFIG)) {\r\ndev_err(&dev->dev,\r\n"Partial reconfiguration is not supported\n");\r\nreturn -ENOTSUPP;\r\n}\r\nspi_bus_lock(dev->master);\r\ngpiod_set_value(priv->reset, 1);\r\nspi_message_init(&message);\r\nspi_message_add_tail(&assert_cs_then_reset_delay, &message);\r\nret = spi_sync_locked(dev, &message);\r\ngpiod_set_value(priv->reset, 0);\r\nif (ret)\r\ngoto fail;\r\nif (gpiod_get_value(priv->cdone)) {\r\ndev_err(&dev->dev, "Device reset failed, CDONE is asserted\n");\r\nret = -EIO;\r\ngoto fail;\r\n}\r\nspi_message_init(&message);\r\nspi_message_add_tail(&housekeeping_delay_then_release_cs, &message);\r\nret = spi_sync_locked(dev, &message);\r\nfail:\r\nspi_bus_unlock(dev->master);\r\nreturn ret;\r\n}\r\nstatic int ice40_fpga_ops_write(struct fpga_manager *mgr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ice40_fpga_priv *priv = mgr->priv;\r\nreturn spi_write(priv->dev, buf, count);\r\n}\r\nstatic int ice40_fpga_ops_write_complete(struct fpga_manager *mgr,\r\nstruct fpga_image_info *info)\r\n{\r\nstruct ice40_fpga_priv *priv = mgr->priv;\r\nstruct spi_device *dev = priv->dev;\r\nconst u8 padding[ICE40_SPI_NUM_ACTIVATION_BYTES] = {0};\r\nif (!gpiod_get_value(priv->cdone)) {\r\ndev_err(&dev->dev,\r\n"CDONE was not asserted after firmware transfer\n");\r\nreturn -EIO;\r\n}\r\nreturn spi_write(dev, padding, sizeof(padding));\r\n}\r\nstatic int ice40_fpga_probe(struct spi_device *spi)\r\n{\r\nstruct device *dev = &spi->dev;\r\nstruct ice40_fpga_priv *priv;\r\nint ret;\r\npriv = devm_kzalloc(&spi->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->dev = spi;\r\nif (spi->max_speed_hz > ICE40_SPI_MAX_SPEED) {\r\ndev_err(dev, "SPI speed is too high, maximum speed is "\r\n__stringify(ICE40_SPI_MAX_SPEED) "\n");\r\nreturn -EINVAL;\r\n}\r\nif (spi->max_speed_hz < ICE40_SPI_MIN_SPEED) {\r\ndev_err(dev, "SPI speed is too low, minimum speed is "\r\n__stringify(ICE40_SPI_MIN_SPEED) "\n");\r\nreturn -EINVAL;\r\n}\r\nif (spi->mode & SPI_CPHA) {\r\ndev_err(dev, "Bad SPI mode, CPHA not supported\n");\r\nreturn -EINVAL;\r\n}\r\npriv->cdone = devm_gpiod_get(dev, "cdone", GPIOD_IN);\r\nif (IS_ERR(priv->cdone)) {\r\nret = PTR_ERR(priv->cdone);\r\ndev_err(dev, "Failed to get CDONE GPIO: %d\n", ret);\r\nreturn ret;\r\n}\r\npriv->reset = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);\r\nif (IS_ERR(priv->reset)) {\r\nret = PTR_ERR(priv->reset);\r\ndev_err(dev, "Failed to get CRESET_B GPIO: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn fpga_mgr_register(dev, "Lattice iCE40 FPGA Manager",\r\n&ice40_fpga_ops, priv);\r\n}\r\nstatic int ice40_fpga_remove(struct spi_device *spi)\r\n{\r\nfpga_mgr_unregister(&spi->dev);\r\nreturn 0;\r\n}
