static int snd_line6_impulse_volume_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 255;\r\nreturn 0;\r\n}\r\nstatic int snd_line6_impulse_volume_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_line6_pcm *line6pcm = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] = line6pcm->impulse_volume;\r\nreturn 0;\r\n}\r\nstatic int snd_line6_impulse_volume_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_line6_pcm *line6pcm = snd_kcontrol_chip(kcontrol);\r\nint value = ucontrol->value.integer.value[0];\r\nint err;\r\nif (line6pcm->impulse_volume == value)\r\nreturn 0;\r\nline6pcm->impulse_volume = value;\r\nif (value > 0) {\r\nerr = line6_pcm_acquire(line6pcm, LINE6_STREAM_IMPULSE, true);\r\nif (err < 0) {\r\nline6pcm->impulse_volume = 0;\r\nreturn err;\r\n}\r\n} else {\r\nline6_pcm_release(line6pcm, LINE6_STREAM_IMPULSE);\r\n}\r\nreturn 1;\r\n}\r\nstatic int snd_line6_impulse_period_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 2000;\r\nreturn 0;\r\n}\r\nstatic int snd_line6_impulse_period_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_line6_pcm *line6pcm = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] = line6pcm->impulse_period;\r\nreturn 0;\r\n}\r\nstatic int snd_line6_impulse_period_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_line6_pcm *line6pcm = snd_kcontrol_chip(kcontrol);\r\nint value = ucontrol->value.integer.value[0];\r\nif (line6pcm->impulse_period == value)\r\nreturn 0;\r\nline6pcm->impulse_period = value;\r\nreturn 1;\r\n}\r\nstatic void line6_unlink_audio_urbs(struct snd_line6_pcm *line6pcm,\r\nstruct line6_pcm_stream *pcms)\r\n{\r\nint i;\r\nfor (i = 0; i < line6pcm->line6->iso_buffers; i++) {\r\nif (test_bit(i, &pcms->active_urbs)) {\r\nif (!test_and_set_bit(i, &pcms->unlink_urbs))\r\nusb_unlink_urb(pcms->urbs[i]);\r\n}\r\n}\r\n}\r\nstatic void line6_wait_clear_audio_urbs(struct snd_line6_pcm *line6pcm,\r\nstruct line6_pcm_stream *pcms)\r\n{\r\nint timeout = HZ;\r\nint i;\r\nint alive;\r\ndo {\r\nalive = 0;\r\nfor (i = 0; i < line6pcm->line6->iso_buffers; i++) {\r\nif (test_bit(i, &pcms->active_urbs))\r\nalive++;\r\n}\r\nif (!alive)\r\nbreak;\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout(1);\r\n} while (--timeout > 0);\r\nif (alive)\r\ndev_err(line6pcm->line6->ifcdev,\r\n"timeout: still %d active urbs..\n", alive);\r\n}\r\nstatic inline struct line6_pcm_stream *\r\nget_stream(struct snd_line6_pcm *line6pcm, int direction)\r\n{\r\nreturn (direction == SNDRV_PCM_STREAM_PLAYBACK) ?\r\n&line6pcm->out : &line6pcm->in;\r\n}\r\nstatic int line6_buffer_acquire(struct snd_line6_pcm *line6pcm,\r\nstruct line6_pcm_stream *pstr, int direction, int type)\r\n{\r\nconst int pkt_size =\r\n(direction == SNDRV_PCM_STREAM_PLAYBACK) ?\r\nline6pcm->max_packet_size_out :\r\nline6pcm->max_packet_size_in;\r\nif (!test_and_set_bit(type, &pstr->opened) && !pstr->buffer) {\r\npstr->buffer = kmalloc(line6pcm->line6->iso_buffers *\r\nLINE6_ISO_PACKETS * pkt_size, GFP_KERNEL);\r\nif (!pstr->buffer)\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void line6_buffer_release(struct snd_line6_pcm *line6pcm,\r\nstruct line6_pcm_stream *pstr, int type)\r\n{\r\nclear_bit(type, &pstr->opened);\r\nif (!pstr->opened) {\r\nline6_wait_clear_audio_urbs(line6pcm, pstr);\r\nkfree(pstr->buffer);\r\npstr->buffer = NULL;\r\n}\r\n}\r\nstatic int line6_stream_start(struct snd_line6_pcm *line6pcm, int direction,\r\nint type)\r\n{\r\nunsigned long flags;\r\nstruct line6_pcm_stream *pstr = get_stream(line6pcm, direction);\r\nint ret = 0;\r\nspin_lock_irqsave(&pstr->lock, flags);\r\nif (!test_and_set_bit(type, &pstr->running) &&\r\n!(pstr->active_urbs || pstr->unlink_urbs)) {\r\npstr->count = 0;\r\nif (direction == SNDRV_PCM_STREAM_PLAYBACK)\r\nret = line6_submit_audio_out_all_urbs(line6pcm);\r\nelse\r\nret = line6_submit_audio_in_all_urbs(line6pcm);\r\n}\r\nif (ret < 0)\r\nclear_bit(type, &pstr->running);\r\nspin_unlock_irqrestore(&pstr->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void line6_stream_stop(struct snd_line6_pcm *line6pcm, int direction,\r\nint type)\r\n{\r\nunsigned long flags;\r\nstruct line6_pcm_stream *pstr = get_stream(line6pcm, direction);\r\nspin_lock_irqsave(&pstr->lock, flags);\r\nclear_bit(type, &pstr->running);\r\nif (!pstr->running) {\r\nspin_unlock_irqrestore(&pstr->lock, flags);\r\nline6_unlink_audio_urbs(line6pcm, pstr);\r\nspin_lock_irqsave(&pstr->lock, flags);\r\nif (direction == SNDRV_PCM_STREAM_CAPTURE) {\r\nline6pcm->prev_fbuf = NULL;\r\nline6pcm->prev_fsize = 0;\r\n}\r\n}\r\nspin_unlock_irqrestore(&pstr->lock, flags);\r\n}\r\nint snd_line6_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_line6_pcm *line6pcm = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_substream *s;\r\nint err;\r\nclear_bit(LINE6_FLAG_PREPARED, &line6pcm->flags);\r\nsnd_pcm_group_for_each_entry(s, substream) {\r\nif (s->pcm->card != substream->pcm->card)\r\ncontinue;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nif (s->stream == SNDRV_PCM_STREAM_CAPTURE &&\r\n(line6pcm->line6->properties->capabilities &\r\nLINE6_CAP_IN_NEEDS_OUT)) {\r\nerr = line6_stream_start(line6pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\nLINE6_STREAM_CAPTURE_HELPER);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nerr = line6_stream_start(line6pcm, s->stream,\r\nLINE6_STREAM_PCM);\r\nif (err < 0)\r\nreturn err;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nif (s->stream == SNDRV_PCM_STREAM_CAPTURE &&\r\n(line6pcm->line6->properties->capabilities &\r\nLINE6_CAP_IN_NEEDS_OUT)) {\r\nline6_stream_stop(line6pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\nLINE6_STREAM_CAPTURE_HELPER);\r\n}\r\nline6_stream_stop(line6pcm, s->stream,\r\nLINE6_STREAM_PCM);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nif (s->stream != SNDRV_PCM_STREAM_PLAYBACK)\r\nreturn -EINVAL;\r\nset_bit(LINE6_FLAG_PAUSE_PLAYBACK, &line6pcm->flags);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nif (s->stream != SNDRV_PCM_STREAM_PLAYBACK)\r\nreturn -EINVAL;\r\nclear_bit(LINE6_FLAG_PAUSE_PLAYBACK, &line6pcm->flags);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nsnd_pcm_uframes_t snd_line6_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_line6_pcm *line6pcm = snd_pcm_substream_chip(substream);\r\nstruct line6_pcm_stream *pstr = get_stream(line6pcm, substream->stream);\r\nreturn pstr->pos_done;\r\n}\r\nint line6_pcm_acquire(struct snd_line6_pcm *line6pcm, int type, bool start)\r\n{\r\nstruct line6_pcm_stream *pstr;\r\nint ret = 0, dir;\r\nmutex_lock(&line6pcm->state_mutex);\r\nfor (dir = 0; dir < 2; dir++) {\r\npstr = get_stream(line6pcm, dir);\r\nret = line6_buffer_acquire(line6pcm, pstr, dir, type);\r\nif (ret < 0)\r\ngoto error;\r\nif (!pstr->running)\r\nline6_wait_clear_audio_urbs(line6pcm, pstr);\r\n}\r\nif (start) {\r\nfor (dir = 0; dir < 2; dir++) {\r\nret = line6_stream_start(line6pcm, dir, type);\r\nif (ret < 0)\r\ngoto error;\r\n}\r\n}\r\nerror:\r\nmutex_unlock(&line6pcm->state_mutex);\r\nif (ret < 0)\r\nline6_pcm_release(line6pcm, type);\r\nreturn ret;\r\n}\r\nvoid line6_pcm_release(struct snd_line6_pcm *line6pcm, int type)\r\n{\r\nstruct line6_pcm_stream *pstr;\r\nint dir;\r\nmutex_lock(&line6pcm->state_mutex);\r\nfor (dir = 0; dir < 2; dir++)\r\nline6_stream_stop(line6pcm, dir, type);\r\nfor (dir = 0; dir < 2; dir++) {\r\npstr = get_stream(line6pcm, dir);\r\nline6_buffer_release(line6pcm, pstr, type);\r\n}\r\nmutex_unlock(&line6pcm->state_mutex);\r\n}\r\nint snd_line6_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nint ret;\r\nstruct snd_line6_pcm *line6pcm = snd_pcm_substream_chip(substream);\r\nstruct line6_pcm_stream *pstr = get_stream(line6pcm, substream->stream);\r\nmutex_lock(&line6pcm->state_mutex);\r\nret = line6_buffer_acquire(line6pcm, pstr, substream->stream,\r\nLINE6_STREAM_PCM);\r\nif (ret < 0)\r\ngoto error;\r\nret = snd_pcm_lib_malloc_pages(substream,\r\nparams_buffer_bytes(hw_params));\r\nif (ret < 0) {\r\nline6_buffer_release(line6pcm, pstr, LINE6_STREAM_PCM);\r\ngoto error;\r\n}\r\npstr->period = params_period_bytes(hw_params);\r\nerror:\r\nmutex_unlock(&line6pcm->state_mutex);\r\nreturn ret;\r\n}\r\nint snd_line6_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_line6_pcm *line6pcm = snd_pcm_substream_chip(substream);\r\nstruct line6_pcm_stream *pstr = get_stream(line6pcm, substream->stream);\r\nmutex_lock(&line6pcm->state_mutex);\r\nline6_buffer_release(line6pcm, pstr, LINE6_STREAM_PCM);\r\nmutex_unlock(&line6pcm->state_mutex);\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int snd_line6_control_playback_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 256;\r\nreturn 0;\r\n}\r\nstatic int snd_line6_control_playback_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nint i;\r\nstruct snd_line6_pcm *line6pcm = snd_kcontrol_chip(kcontrol);\r\nfor (i = 0; i < 2; i++)\r\nucontrol->value.integer.value[i] = line6pcm->volume_playback[i];\r\nreturn 0;\r\n}\r\nstatic int snd_line6_control_playback_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nint i, changed = 0;\r\nstruct snd_line6_pcm *line6pcm = snd_kcontrol_chip(kcontrol);\r\nfor (i = 0; i < 2; i++)\r\nif (line6pcm->volume_playback[i] !=\r\nucontrol->value.integer.value[i]) {\r\nline6pcm->volume_playback[i] =\r\nucontrol->value.integer.value[i];\r\nchanged = 1;\r\n}\r\nreturn changed;\r\n}\r\nstatic void cleanup_urbs(struct line6_pcm_stream *pcms, int iso_buffers)\r\n{\r\nint i;\r\nif (pcms->urbs == NULL)\r\nreturn;\r\nfor (i = 0; i < iso_buffers; i++) {\r\nif (pcms->urbs[i]) {\r\nusb_kill_urb(pcms->urbs[i]);\r\nusb_free_urb(pcms->urbs[i]);\r\n}\r\n}\r\nkfree(pcms->urbs);\r\npcms->urbs = NULL;\r\n}\r\nstatic void line6_cleanup_pcm(struct snd_pcm *pcm)\r\n{\r\nstruct snd_line6_pcm *line6pcm = snd_pcm_chip(pcm);\r\ncleanup_urbs(&line6pcm->out, line6pcm->line6->iso_buffers);\r\ncleanup_urbs(&line6pcm->in, line6pcm->line6->iso_buffers);\r\nkfree(line6pcm);\r\n}\r\nstatic int snd_line6_new_pcm(struct usb_line6 *line6, struct snd_pcm **pcm_ret)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nerr = snd_pcm_new(line6->card, (char *)line6->properties->name,\r\n0, 1, 1, pcm_ret);\r\nif (err < 0)\r\nreturn err;\r\npcm = *pcm_ret;\r\nstrcpy(pcm->name, line6->properties->name);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\n&snd_line6_playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_line6_capture_ops);\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_CONTINUOUS,\r\nsnd_dma_continuous_data\r\n(GFP_KERNEL), 64 * 1024,\r\n128 * 1024);\r\nreturn 0;\r\n}\r\nvoid line6_pcm_disconnect(struct snd_line6_pcm *line6pcm)\r\n{\r\nline6_unlink_audio_urbs(line6pcm, &line6pcm->out);\r\nline6_unlink_audio_urbs(line6pcm, &line6pcm->in);\r\nline6_wait_clear_audio_urbs(line6pcm, &line6pcm->out);\r\nline6_wait_clear_audio_urbs(line6pcm, &line6pcm->in);\r\n}\r\nint line6_init_pcm(struct usb_line6 *line6,\r\nstruct line6_pcm_properties *properties)\r\n{\r\nint i, err;\r\nunsigned ep_read = line6->properties->ep_audio_r;\r\nunsigned ep_write = line6->properties->ep_audio_w;\r\nstruct snd_pcm *pcm;\r\nstruct snd_line6_pcm *line6pcm;\r\nif (!(line6->properties->capabilities & LINE6_CAP_PCM))\r\nreturn 0;\r\nerr = snd_line6_new_pcm(line6, &pcm);\r\nif (err < 0)\r\nreturn err;\r\nline6pcm = kzalloc(sizeof(*line6pcm), GFP_KERNEL);\r\nif (!line6pcm)\r\nreturn -ENOMEM;\r\nmutex_init(&line6pcm->state_mutex);\r\nline6pcm->pcm = pcm;\r\nline6pcm->properties = properties;\r\nline6pcm->volume_playback[0] = line6pcm->volume_playback[1] = 255;\r\nline6pcm->volume_monitor = 255;\r\nline6pcm->line6 = line6;\r\nline6pcm->max_packet_size_in =\r\nusb_maxpacket(line6->usbdev,\r\nusb_rcvisocpipe(line6->usbdev, ep_read), 0);\r\nline6pcm->max_packet_size_out =\r\nusb_maxpacket(line6->usbdev,\r\nusb_sndisocpipe(line6->usbdev, ep_write), 1);\r\nspin_lock_init(&line6pcm->out.lock);\r\nspin_lock_init(&line6pcm->in.lock);\r\nline6pcm->impulse_period = LINE6_IMPULSE_DEFAULT_PERIOD;\r\nline6->line6pcm = line6pcm;\r\npcm->private_data = line6pcm;\r\npcm->private_free = line6_cleanup_pcm;\r\nerr = line6_create_audio_out_urbs(line6pcm);\r\nif (err < 0)\r\nreturn err;\r\nerr = line6_create_audio_in_urbs(line6pcm);\r\nif (err < 0)\r\nreturn err;\r\nfor (i = 0; i < ARRAY_SIZE(line6_controls); i++) {\r\nerr = snd_ctl_add(line6->card,\r\nsnd_ctl_new1(&line6_controls[i], line6pcm));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nint snd_line6_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_line6_pcm *line6pcm = snd_pcm_substream_chip(substream);\r\nstruct line6_pcm_stream *pstr = get_stream(line6pcm, substream->stream);\r\nmutex_lock(&line6pcm->state_mutex);\r\nif (!pstr->running)\r\nline6_wait_clear_audio_urbs(line6pcm, pstr);\r\nif (!test_and_set_bit(LINE6_FLAG_PREPARED, &line6pcm->flags)) {\r\nline6pcm->out.count = 0;\r\nline6pcm->out.pos = 0;\r\nline6pcm->out.pos_done = 0;\r\nline6pcm->out.bytes = 0;\r\nline6pcm->in.count = 0;\r\nline6pcm->in.pos_done = 0;\r\nline6pcm->in.bytes = 0;\r\n}\r\nmutex_unlock(&line6pcm->state_mutex);\r\nreturn 0;\r\n}
