static int send_isa_command(int cmd)\r\n{\r\nint i;\r\nint control_status;\r\nint port0, last_port0;\r\nif (debug >= DEBUG)\r\npr_debug("sending following data cmd=0x%02x\n", cmd);\r\ncontrol_status = (cmd & 0x0F) | WD_WCMD;\r\noutb_p(control_status, pcwd_private.io_addr + 2);\r\nudelay(ISA_COMMAND_TIMEOUT);\r\nport0 = inb_p(pcwd_private.io_addr);\r\nfor (i = 0; i < 25; ++i) {\r\nlast_port0 = port0;\r\nport0 = inb_p(pcwd_private.io_addr);\r\nif (port0 == last_port0)\r\nbreak;\r\nudelay(250);\r\n}\r\nif (debug >= DEBUG)\r\npr_debug("received following data for cmd=0x%02x: port0=0x%02x last_port0=0x%02x\n",\r\ncmd, port0, last_port0);\r\nreturn port0;\r\n}\r\nstatic int set_command_mode(void)\r\n{\r\nint i, found = 0, count = 0;\r\nspin_lock(&pcwd_private.io_lock);\r\nwhile ((!found) && (count < 3)) {\r\ni = send_isa_command(CMD_ISA_IDLE);\r\nif (i == 0x00)\r\nfound = 1;\r\nelse if (i == 0xF3) {\r\noutb_p(0x00, pcwd_private.io_addr + 2);\r\nudelay(1200);\r\noutb_p(0x00, pcwd_private.io_addr + 2);\r\nudelay(ISA_COMMAND_TIMEOUT);\r\n}\r\ncount++;\r\n}\r\nspin_unlock(&pcwd_private.io_lock);\r\npcwd_private.command_mode = found;\r\nif (debug >= DEBUG)\r\npr_debug("command_mode=%d\n", pcwd_private.command_mode);\r\nreturn found;\r\n}\r\nstatic void unset_command_mode(void)\r\n{\r\nspin_lock(&pcwd_private.io_lock);\r\noutb_p(0x00, pcwd_private.io_addr + 2);\r\nudelay(ISA_COMMAND_TIMEOUT);\r\nspin_unlock(&pcwd_private.io_lock);\r\npcwd_private.command_mode = 0;\r\nif (debug >= DEBUG)\r\npr_debug("command_mode=%d\n", pcwd_private.command_mode);\r\n}\r\nstatic inline void pcwd_check_temperature_support(void)\r\n{\r\nif (inb(pcwd_private.io_addr) != 0xF0)\r\npcwd_private.supports_temp = 1;\r\n}\r\nstatic inline void pcwd_get_firmware(void)\r\n{\r\nint one, ten, hund, minor;\r\nstrcpy(pcwd_private.fw_ver_str, "ERROR");\r\nif (set_command_mode()) {\r\none = send_isa_command(CMD_ISA_VERSION_INTEGER);\r\nten = send_isa_command(CMD_ISA_VERSION_TENTH);\r\nhund = send_isa_command(CMD_ISA_VERSION_HUNDRETH);\r\nminor = send_isa_command(CMD_ISA_VERSION_MINOR);\r\nsprintf(pcwd_private.fw_ver_str, "%c.%c%c%c",\r\none, ten, hund, minor);\r\n}\r\nunset_command_mode();\r\nreturn;\r\n}\r\nstatic inline int pcwd_get_option_switches(void)\r\n{\r\nint option_switches = 0;\r\nif (set_command_mode()) {\r\noption_switches = send_isa_command(CMD_ISA_SWITCH_SETTINGS);\r\n}\r\nunset_command_mode();\r\nreturn option_switches;\r\n}\r\nstatic void pcwd_show_card_info(void)\r\n{\r\nint option_switches;\r\nif (pcwd_private.revision == PCWD_REVISION_A)\r\npr_info("ISA-PC Watchdog (REV.A) detected at port 0x%04x\n",\r\npcwd_private.io_addr);\r\nelse if (pcwd_private.revision == PCWD_REVISION_C) {\r\npcwd_get_firmware();\r\npr_info("ISA-PC Watchdog (REV.C) detected at port 0x%04x (Firmware version: %s)\n",\r\npcwd_private.io_addr, pcwd_private.fw_ver_str);\r\noption_switches = pcwd_get_option_switches();\r\npr_info("Option switches (0x%02x): Temperature Reset Enable=%s, Power On Delay=%s\n",\r\noption_switches,\r\n((option_switches & 0x10) ? "ON" : "OFF"),\r\n((option_switches & 0x08) ? "ON" : "OFF"));\r\nif (set_command_mode()) {\r\nsend_isa_command(CMD_ISA_DELAY_TIME_2SECS);\r\nunset_command_mode();\r\n}\r\n}\r\nif (pcwd_private.supports_temp)\r\npr_info("Temperature Option Detected\n");\r\nif (pcwd_private.boot_status & WDIOF_CARDRESET)\r\npr_info("Previous reboot was caused by the card\n");\r\nif (pcwd_private.boot_status & WDIOF_OVERHEAT) {\r\npr_emerg("Card senses a CPU Overheat. Panicking!\n");\r\npr_emerg("CPU Overheat\n");\r\n}\r\nif (pcwd_private.boot_status == 0)\r\npr_info("No previous trip detected - Cold boot or reset\n");\r\n}\r\nstatic void pcwd_timer_ping(unsigned long data)\r\n{\r\nint wdrst_stat;\r\nif (time_before(jiffies, pcwd_private.next_heartbeat)) {\r\nspin_lock(&pcwd_private.io_lock);\r\nif (pcwd_private.revision == PCWD_REVISION_A) {\r\nwdrst_stat = inb_p(pcwd_private.io_addr);\r\nwdrst_stat &= 0x0F;\r\nwdrst_stat |= WD_WDRST;\r\noutb_p(wdrst_stat, pcwd_private.io_addr + 1);\r\n} else {\r\noutb_p(0x00, pcwd_private.io_addr);\r\n}\r\nmod_timer(&pcwd_private.timer, jiffies + WDT_INTERVAL);\r\nspin_unlock(&pcwd_private.io_lock);\r\n} else {\r\npr_warn("Heartbeat lost! Will not ping the watchdog\n");\r\n}\r\n}\r\nstatic int pcwd_start(void)\r\n{\r\nint stat_reg;\r\npcwd_private.next_heartbeat = jiffies + (heartbeat * HZ);\r\nmod_timer(&pcwd_private.timer, jiffies + WDT_INTERVAL);\r\nif (pcwd_private.revision == PCWD_REVISION_C) {\r\nspin_lock(&pcwd_private.io_lock);\r\noutb_p(0x00, pcwd_private.io_addr + 3);\r\nudelay(ISA_COMMAND_TIMEOUT);\r\nstat_reg = inb_p(pcwd_private.io_addr + 2);\r\nspin_unlock(&pcwd_private.io_lock);\r\nif (stat_reg & WD_WDIS) {\r\npr_info("Could not start watchdog\n");\r\nreturn -EIO;\r\n}\r\n}\r\nif (debug >= VERBOSE)\r\npr_debug("Watchdog started\n");\r\nreturn 0;\r\n}\r\nstatic int pcwd_stop(void)\r\n{\r\nint stat_reg;\r\ndel_timer(&pcwd_private.timer);\r\nif (pcwd_private.revision == PCWD_REVISION_C) {\r\nspin_lock(&pcwd_private.io_lock);\r\noutb_p(0xA5, pcwd_private.io_addr + 3);\r\nudelay(ISA_COMMAND_TIMEOUT);\r\noutb_p(0xA5, pcwd_private.io_addr + 3);\r\nudelay(ISA_COMMAND_TIMEOUT);\r\nstat_reg = inb_p(pcwd_private.io_addr + 2);\r\nspin_unlock(&pcwd_private.io_lock);\r\nif ((stat_reg & WD_WDIS) == 0) {\r\npr_info("Could not stop watchdog\n");\r\nreturn -EIO;\r\n}\r\n}\r\nif (debug >= VERBOSE)\r\npr_debug("Watchdog stopped\n");\r\nreturn 0;\r\n}\r\nstatic int pcwd_keepalive(void)\r\n{\r\npcwd_private.next_heartbeat = jiffies + (heartbeat * HZ);\r\nif (debug >= DEBUG)\r\npr_debug("Watchdog keepalive signal send\n");\r\nreturn 0;\r\n}\r\nstatic int pcwd_set_heartbeat(int t)\r\n{\r\nif (t < 2 || t > 7200)\r\nreturn -EINVAL;\r\nheartbeat = t;\r\nif (debug >= VERBOSE)\r\npr_debug("New heartbeat: %d\n", heartbeat);\r\nreturn 0;\r\n}\r\nstatic int pcwd_get_status(int *status)\r\n{\r\nint control_status;\r\n*status = 0;\r\nspin_lock(&pcwd_private.io_lock);\r\nif (pcwd_private.revision == PCWD_REVISION_A)\r\ncontrol_status = inb(pcwd_private.io_addr);\r\nelse {\r\ncontrol_status = inb(pcwd_private.io_addr + 1);\r\n}\r\nspin_unlock(&pcwd_private.io_lock);\r\nif (pcwd_private.revision == PCWD_REVISION_A) {\r\nif (control_status & WD_WDRST)\r\n*status |= WDIOF_CARDRESET;\r\nif (control_status & WD_T110) {\r\n*status |= WDIOF_OVERHEAT;\r\nif (temp_panic) {\r\npr_info("Temperature overheat trip!\n");\r\nkernel_power_off();\r\n}\r\n}\r\n} else {\r\nif (control_status & WD_REVC_WTRP)\r\n*status |= WDIOF_CARDRESET;\r\nif (control_status & WD_REVC_TTRP) {\r\n*status |= WDIOF_OVERHEAT;\r\nif (temp_panic) {\r\npr_info("Temperature overheat trip!\n");\r\nkernel_power_off();\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcwd_clear_status(void)\r\n{\r\nint control_status;\r\nif (pcwd_private.revision == PCWD_REVISION_C) {\r\nspin_lock(&pcwd_private.io_lock);\r\nif (debug >= VERBOSE)\r\npr_info("clearing watchdog trip status\n");\r\ncontrol_status = inb_p(pcwd_private.io_addr + 1);\r\nif (debug >= DEBUG) {\r\npr_debug("status was: 0x%02x\n", control_status);\r\npr_debug("sending: 0x%02x\n",\r\n(control_status & WD_REVC_R2DS));\r\n}\r\noutb_p((control_status & WD_REVC_R2DS),\r\npcwd_private.io_addr + 1);\r\nspin_unlock(&pcwd_private.io_lock);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcwd_get_temperature(int *temperature)\r\n{\r\nif (pcwd_private.command_mode)\r\nreturn -1;\r\n*temperature = 0;\r\nif (!pcwd_private.supports_temp)\r\nreturn -ENODEV;\r\nspin_lock(&pcwd_private.io_lock);\r\n*temperature = ((inb(pcwd_private.io_addr)) * 9 / 5) + 32;\r\nspin_unlock(&pcwd_private.io_lock);\r\nif (debug >= DEBUG) {\r\npr_debug("temperature is: %d F\n", *temperature);\r\n}\r\nreturn 0;\r\n}\r\nstatic long pcwd_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nint rv;\r\nint status;\r\nint temperature;\r\nint new_heartbeat;\r\nint __user *argp = (int __user *)arg;\r\nstatic const struct watchdog_info ident = {\r\n.options = WDIOF_OVERHEAT |\r\nWDIOF_CARDRESET |\r\nWDIOF_KEEPALIVEPING |\r\nWDIOF_SETTIMEOUT |\r\nWDIOF_MAGICCLOSE,\r\n.firmware_version = 1,\r\n.identity = "PCWD",\r\n};\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nif (copy_to_user(argp, &ident, sizeof(ident)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase WDIOC_GETSTATUS:\r\npcwd_get_status(&status);\r\nreturn put_user(status, argp);\r\ncase WDIOC_GETBOOTSTATUS:\r\nreturn put_user(pcwd_private.boot_status, argp);\r\ncase WDIOC_GETTEMP:\r\nif (pcwd_get_temperature(&temperature))\r\nreturn -EFAULT;\r\nreturn put_user(temperature, argp);\r\ncase WDIOC_SETOPTIONS:\r\nif (pcwd_private.revision == PCWD_REVISION_C) {\r\nif (get_user(rv, argp))\r\nreturn -EFAULT;\r\nif (rv & WDIOS_DISABLECARD) {\r\nstatus = pcwd_stop();\r\nif (status < 0)\r\nreturn status;\r\n}\r\nif (rv & WDIOS_ENABLECARD) {\r\nstatus = pcwd_start();\r\nif (status < 0)\r\nreturn status;\r\n}\r\nif (rv & WDIOS_TEMPPANIC)\r\ntemp_panic = 1;\r\n}\r\nreturn -EINVAL;\r\ncase WDIOC_KEEPALIVE:\r\npcwd_keepalive();\r\nreturn 0;\r\ncase WDIOC_SETTIMEOUT:\r\nif (get_user(new_heartbeat, argp))\r\nreturn -EFAULT;\r\nif (pcwd_set_heartbeat(new_heartbeat))\r\nreturn -EINVAL;\r\npcwd_keepalive();\r\ncase WDIOC_GETTIMEOUT:\r\nreturn put_user(heartbeat, argp);\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t pcwd_write(struct file *file, const char __user *buf, size_t len,\r\nloff_t *ppos)\r\n{\r\nif (len) {\r\nif (!nowayout) {\r\nsize_t i;\r\nexpect_close = 0;\r\nfor (i = 0; i != len; i++) {\r\nchar c;\r\nif (get_user(c, buf + i))\r\nreturn -EFAULT;\r\nif (c == 'V')\r\nexpect_close = 42;\r\n}\r\n}\r\npcwd_keepalive();\r\n}\r\nreturn len;\r\n}\r\nstatic int pcwd_open(struct inode *inode, struct file *file)\r\n{\r\nif (test_and_set_bit(0, &open_allowed))\r\nreturn -EBUSY;\r\nif (nowayout)\r\n__module_get(THIS_MODULE);\r\npcwd_start();\r\npcwd_keepalive();\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int pcwd_close(struct inode *inode, struct file *file)\r\n{\r\nif (expect_close == 42)\r\npcwd_stop();\r\nelse {\r\npr_crit("Unexpected close, not stopping watchdog!\n");\r\npcwd_keepalive();\r\n}\r\nexpect_close = 0;\r\nclear_bit(0, &open_allowed);\r\nreturn 0;\r\n}\r\nstatic ssize_t pcwd_temp_read(struct file *file, char __user *buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nint temperature;\r\nif (pcwd_get_temperature(&temperature))\r\nreturn -EFAULT;\r\nif (copy_to_user(buf, &temperature, 1))\r\nreturn -EFAULT;\r\nreturn 1;\r\n}\r\nstatic int pcwd_temp_open(struct inode *inode, struct file *file)\r\n{\r\nif (!pcwd_private.supports_temp)\r\nreturn -ENODEV;\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int pcwd_temp_close(struct inode *inode, struct file *file)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline int get_revision(void)\r\n{\r\nint r = PCWD_REVISION_C;\r\nspin_lock(&pcwd_private.io_lock);\r\nif ((inb(pcwd_private.io_addr + 2) == 0xFF) ||\r\n(inb(pcwd_private.io_addr + 3) == 0xFF))\r\nr = PCWD_REVISION_A;\r\nspin_unlock(&pcwd_private.io_lock);\r\nreturn r;\r\n}\r\nstatic int pcwd_isa_match(struct device *dev, unsigned int id)\r\n{\r\nint base_addr = pcwd_ioports[id];\r\nint port0, last_port0;\r\nint port1, last_port1;\r\nint i;\r\nint retval;\r\nif (debug >= DEBUG)\r\npr_debug("pcwd_isa_match id=%d\n", id);\r\nif (!request_region(base_addr, 4, "PCWD")) {\r\npr_info("Port 0x%04x unavailable\n", base_addr);\r\nreturn 0;\r\n}\r\nretval = 0;\r\nport0 = inb_p(base_addr);\r\nport1 = inb_p(base_addr + 1);\r\nif (port0 != 0xff || port1 != 0xff) {\r\nfor (i = 0; i < 4; ++i) {\r\nmsleep(500);\r\nlast_port0 = port0;\r\nlast_port1 = port1;\r\nport0 = inb_p(base_addr);\r\nport1 = inb_p(base_addr + 1);\r\nif ((port0 ^ last_port0) & WD_HRTBT ||\r\n(port1 ^ last_port1) & WD_REVC_HRBT) {\r\nretval = 1;\r\nbreak;\r\n}\r\n}\r\n}\r\nrelease_region(base_addr, 4);\r\nreturn retval;\r\n}\r\nstatic int pcwd_isa_probe(struct device *dev, unsigned int id)\r\n{\r\nint ret;\r\nif (debug >= DEBUG)\r\npr_debug("pcwd_isa_probe id=%d\n", id);\r\ncards_found++;\r\nif (cards_found == 1)\r\npr_info("v%s Ken Hollis (kenji@bitgate.com)\n",\r\nWATCHDOG_VERSION);\r\nif (cards_found > 1) {\r\npr_err("This driver only supports 1 device\n");\r\nreturn -ENODEV;\r\n}\r\nif (pcwd_ioports[id] == 0x0000) {\r\npr_err("No I/O-Address for card detected\n");\r\nreturn -ENODEV;\r\n}\r\npcwd_private.io_addr = pcwd_ioports[id];\r\nspin_lock_init(&pcwd_private.io_lock);\r\npcwd_private.revision = get_revision();\r\nif (!request_region(pcwd_private.io_addr,\r\n(pcwd_private.revision == PCWD_REVISION_A) ? 2 : 4, "PCWD")) {\r\npr_err("I/O address 0x%04x already in use\n",\r\npcwd_private.io_addr);\r\nret = -EIO;\r\ngoto error_request_region;\r\n}\r\npcwd_private.supports_temp = 0;\r\ntemp_panic = 0;\r\npcwd_private.boot_status = 0x0000;\r\npcwd_get_status(&pcwd_private.boot_status);\r\npcwd_clear_status();\r\nsetup_timer(&pcwd_private.timer, pcwd_timer_ping, 0);\r\npcwd_stop();\r\npcwd_check_temperature_support();\r\npcwd_show_card_info();\r\nif (heartbeat == 0)\r\nheartbeat = heartbeat_tbl[(pcwd_get_option_switches() & 0x07)];\r\nif (pcwd_set_heartbeat(heartbeat)) {\r\npcwd_set_heartbeat(WATCHDOG_HEARTBEAT);\r\npr_info("heartbeat value must be 2 <= heartbeat <= 7200, using %d\n",\r\nWATCHDOG_HEARTBEAT);\r\n}\r\nif (pcwd_private.supports_temp) {\r\nret = misc_register(&temp_miscdev);\r\nif (ret) {\r\npr_err("cannot register miscdev on minor=%d (err=%d)\n",\r\nTEMP_MINOR, ret);\r\ngoto error_misc_register_temp;\r\n}\r\n}\r\nret = misc_register(&pcwd_miscdev);\r\nif (ret) {\r\npr_err("cannot register miscdev on minor=%d (err=%d)\n",\r\nWATCHDOG_MINOR, ret);\r\ngoto error_misc_register_watchdog;\r\n}\r\npr_info("initialized. heartbeat=%d sec (nowayout=%d)\n",\r\nheartbeat, nowayout);\r\nreturn 0;\r\nerror_misc_register_watchdog:\r\nif (pcwd_private.supports_temp)\r\nmisc_deregister(&temp_miscdev);\r\nerror_misc_register_temp:\r\nrelease_region(pcwd_private.io_addr,\r\n(pcwd_private.revision == PCWD_REVISION_A) ? 2 : 4);\r\nerror_request_region:\r\npcwd_private.io_addr = 0x0000;\r\ncards_found--;\r\nreturn ret;\r\n}\r\nstatic int pcwd_isa_remove(struct device *dev, unsigned int id)\r\n{\r\nif (debug >= DEBUG)\r\npr_debug("pcwd_isa_remove id=%d\n", id);\r\nif (!pcwd_private.io_addr)\r\nreturn 1;\r\nif (!nowayout)\r\npcwd_stop();\r\nmisc_deregister(&pcwd_miscdev);\r\nif (pcwd_private.supports_temp)\r\nmisc_deregister(&temp_miscdev);\r\nrelease_region(pcwd_private.io_addr,\r\n(pcwd_private.revision == PCWD_REVISION_A) ? 2 : 4);\r\npcwd_private.io_addr = 0x0000;\r\ncards_found--;\r\nreturn 0;\r\n}\r\nstatic void pcwd_isa_shutdown(struct device *dev, unsigned int id)\r\n{\r\nif (debug >= DEBUG)\r\npr_debug("pcwd_isa_shutdown id=%d\n", id);\r\npcwd_stop();\r\n}
