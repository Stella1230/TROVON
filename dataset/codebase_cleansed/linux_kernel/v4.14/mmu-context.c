int init_new_context(struct task_struct *tsk, struct mm_struct *mm)\r\n{\r\nmemset(&mm->context, 0, sizeof(mm->context));\r\nINIT_LIST_HEAD(&mm->context.id_link);\r\nmm->context.itlb_cached_pge = 0xffffffffUL;\r\nmm->context.dtlb_cached_pge = 0xffffffffUL;\r\nreturn 0;\r\n}\r\nstatic unsigned get_cxn(mm_context_t *ctx)\r\n{\r\nstruct list_head *_p;\r\nmm_context_t *p;\r\nunsigned cxn;\r\nif (!list_empty(&ctx->id_link)) {\r\nlist_move_tail(&ctx->id_link, &cxn_owners_lru);\r\n}\r\nelse {\r\ncxn = find_next_zero_bit(cxn_bitmap, NR_CXN, 1);\r\nif (cxn < NR_CXN) {\r\nset_bit(cxn, cxn_bitmap);\r\n}\r\nelse {\r\np = NULL;\r\nlist_for_each(_p, &cxn_owners_lru) {\r\np = list_entry(_p, mm_context_t, id_link);\r\nif (!p->id_busy && p->id != cxn_pinned)\r\nbreak;\r\n}\r\nBUG_ON(_p == &cxn_owners_lru);\r\ncxn = p->id;\r\np->id = 0;\r\nlist_del_init(&p->id_link);\r\n__flush_tlb_mm(cxn);\r\n}\r\nctx->id = cxn;\r\nlist_add_tail(&ctx->id_link, &cxn_owners_lru);\r\n}\r\nreturn ctx->id;\r\n}\r\nvoid change_mm_context(mm_context_t *old, mm_context_t *ctx, pgd_t *pgd)\r\n{\r\nunsigned long _pgd;\r\n_pgd = virt_to_phys(pgd);\r\nold->id_busy = 0;\r\nasm volatile("movsg scr0,%0" : "=r"(old->itlb_cached_pge));\r\nasm volatile("movsg dampr4,%0" : "=r"(old->itlb_ptd_mapping));\r\nasm volatile("movsg scr1,%0" : "=r"(old->dtlb_cached_pge));\r\nasm volatile("movsg dampr5,%0" : "=r"(old->dtlb_ptd_mapping));\r\nspin_lock(&cxn_owners_lock);\r\nget_cxn(ctx);\r\nctx->id_busy = 1;\r\nspin_unlock(&cxn_owners_lock);\r\nasm volatile("movgs %0,cxnr" : : "r"(ctx->id));\r\nasm volatile("movgs %0,scr0" : : "r"(ctx->itlb_cached_pge));\r\nasm volatile("movgs %0,dampr4" : : "r"(ctx->itlb_ptd_mapping));\r\nasm volatile("movgs %0,scr1" : : "r"(ctx->dtlb_cached_pge));\r\nasm volatile("movgs %0,dampr5" : : "r"(ctx->dtlb_ptd_mapping));\r\nasm volatile("movgs %0,ttbr" : : "r"(_pgd));\r\nasm volatile("movgs %0,dampr3"\r\n:: "r"(_pgd | xAMPRx_L | xAMPRx_M | xAMPRx_SS_16Kb |\r\nxAMPRx_S | xAMPRx_C | xAMPRx_V));\r\n}\r\nvoid destroy_context(struct mm_struct *mm)\r\n{\r\nmm_context_t *ctx = &mm->context;\r\nspin_lock(&cxn_owners_lock);\r\nif (!list_empty(&ctx->id_link)) {\r\nif (ctx->id == cxn_pinned)\r\ncxn_pinned = -1;\r\nlist_del_init(&ctx->id_link);\r\nclear_bit(ctx->id, cxn_bitmap);\r\n__flush_tlb_mm(ctx->id);\r\nctx->id = 0;\r\n}\r\nspin_unlock(&cxn_owners_lock);\r\n}\r\nchar *proc_pid_status_frv_cxnr(struct mm_struct *mm, char *buffer)\r\n{\r\nspin_lock(&cxn_owners_lock);\r\nbuffer += sprintf(buffer, "CXNR: %u\n", mm->context.id);\r\nspin_unlock(&cxn_owners_lock);\r\nreturn buffer;\r\n}\r\nint cxn_pin_by_pid(pid_t pid)\r\n{\r\nstruct task_struct *tsk;\r\nstruct mm_struct *mm = NULL;\r\nint ret;\r\nif (pid == 0) {\r\ncxn_pinned = -1;\r\nreturn 0;\r\n}\r\nret = -ESRCH;\r\nread_lock(&tasklist_lock);\r\ntsk = find_task_by_vpid(pid);\r\nif (tsk) {\r\nret = -EINVAL;\r\ntask_lock(tsk);\r\nif (tsk->mm) {\r\nmm = tsk->mm;\r\nmmget(mm);\r\nret = 0;\r\n}\r\ntask_unlock(tsk);\r\n}\r\nread_unlock(&tasklist_lock);\r\nif (ret < 0)\r\nreturn ret;\r\nspin_lock(&cxn_owners_lock);\r\ncxn_pinned = get_cxn(&mm->context);\r\nspin_unlock(&cxn_owners_lock);\r\nmmput(mm);\r\nreturn 0;\r\n}
