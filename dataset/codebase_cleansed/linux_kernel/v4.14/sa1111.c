static void sa1111_irq_handler(struct irq_desc *desc)\r\n{\r\nunsigned int stat0, stat1, i;\r\nstruct sa1111 *sachip = irq_desc_get_handler_data(desc);\r\nvoid __iomem *mapbase = sachip->base + SA1111_INTC;\r\nstat0 = sa1111_readl(mapbase + SA1111_INTSTATCLR0);\r\nstat1 = sa1111_readl(mapbase + SA1111_INTSTATCLR1);\r\nsa1111_writel(stat0, mapbase + SA1111_INTSTATCLR0);\r\ndesc->irq_data.chip->irq_ack(&desc->irq_data);\r\nsa1111_writel(stat1, mapbase + SA1111_INTSTATCLR1);\r\nif (stat0 == 0 && stat1 == 0) {\r\ndo_bad_IRQ(desc);\r\nreturn;\r\n}\r\nfor (i = 0; stat0; i++, stat0 >>= 1)\r\nif (stat0 & 1)\r\ngeneric_handle_irq(i + sachip->irq_base);\r\nfor (i = 32; stat1; i++, stat1 >>= 1)\r\nif (stat1 & 1)\r\ngeneric_handle_irq(i + sachip->irq_base);\r\ndesc->irq_data.chip->irq_unmask(&desc->irq_data);\r\n}\r\nstatic u32 sa1111_irqmask(struct irq_data *d)\r\n{\r\nstruct sa1111 *sachip = irq_data_get_irq_chip_data(d);\r\nreturn BIT((d->irq - sachip->irq_base) & 31);\r\n}\r\nstatic int sa1111_irqbank(struct irq_data *d)\r\n{\r\nstruct sa1111 *sachip = irq_data_get_irq_chip_data(d);\r\nreturn ((d->irq - sachip->irq_base) / 32) * 4;\r\n}\r\nstatic void sa1111_ack_irq(struct irq_data *d)\r\n{\r\n}\r\nstatic void sa1111_mask_irq(struct irq_data *d)\r\n{\r\nstruct sa1111 *sachip = irq_data_get_irq_chip_data(d);\r\nvoid __iomem *mapbase = sachip->base + SA1111_INTC + sa1111_irqbank(d);\r\nu32 ie;\r\nie = sa1111_readl(mapbase + SA1111_INTEN0);\r\nie &= ~sa1111_irqmask(d);\r\nsa1111_writel(ie, mapbase + SA1111_INTEN0);\r\n}\r\nstatic void sa1111_unmask_irq(struct irq_data *d)\r\n{\r\nstruct sa1111 *sachip = irq_data_get_irq_chip_data(d);\r\nvoid __iomem *mapbase = sachip->base + SA1111_INTC + sa1111_irqbank(d);\r\nu32 ie;\r\nie = sa1111_readl(mapbase + SA1111_INTEN0);\r\nie |= sa1111_irqmask(d);\r\nsa1111_writel(ie, mapbase + SA1111_INTEN0);\r\n}\r\nstatic int sa1111_retrigger_irq(struct irq_data *d)\r\n{\r\nstruct sa1111 *sachip = irq_data_get_irq_chip_data(d);\r\nvoid __iomem *mapbase = sachip->base + SA1111_INTC + sa1111_irqbank(d);\r\nu32 ip, mask = sa1111_irqmask(d);\r\nint i;\r\nip = sa1111_readl(mapbase + SA1111_INTPOL0);\r\nfor (i = 0; i < 8; i++) {\r\nsa1111_writel(ip ^ mask, mapbase + SA1111_INTPOL0);\r\nsa1111_writel(ip, mapbase + SA1111_INTPOL0);\r\nif (sa1111_readl(mapbase + SA1111_INTSTATCLR0) & mask)\r\nbreak;\r\n}\r\nif (i == 8)\r\npr_err("Danger Will Robinson: failed to re-trigger IRQ%d\n",\r\nd->irq);\r\nreturn i == 8 ? -1 : 0;\r\n}\r\nstatic int sa1111_type_irq(struct irq_data *d, unsigned int flags)\r\n{\r\nstruct sa1111 *sachip = irq_data_get_irq_chip_data(d);\r\nvoid __iomem *mapbase = sachip->base + SA1111_INTC + sa1111_irqbank(d);\r\nu32 ip, mask = sa1111_irqmask(d);\r\nif (flags == IRQ_TYPE_PROBE)\r\nreturn 0;\r\nif ((!(flags & IRQ_TYPE_EDGE_RISING) ^ !(flags & IRQ_TYPE_EDGE_FALLING)) == 0)\r\nreturn -EINVAL;\r\nip = sa1111_readl(mapbase + SA1111_INTPOL0);\r\nif (flags & IRQ_TYPE_EDGE_RISING)\r\nip &= ~mask;\r\nelse\r\nip |= mask;\r\nsa1111_writel(ip, mapbase + SA1111_INTPOL0);\r\nsa1111_writel(ip, mapbase + SA1111_WAKEPOL0);\r\nreturn 0;\r\n}\r\nstatic int sa1111_wake_irq(struct irq_data *d, unsigned int on)\r\n{\r\nstruct sa1111 *sachip = irq_data_get_irq_chip_data(d);\r\nvoid __iomem *mapbase = sachip->base + SA1111_INTC + sa1111_irqbank(d);\r\nu32 we, mask = sa1111_irqmask(d);\r\nwe = sa1111_readl(mapbase + SA1111_WAKEEN0);\r\nif (on)\r\nwe |= mask;\r\nelse\r\nwe &= ~mask;\r\nsa1111_writel(we, mapbase + SA1111_WAKEEN0);\r\nreturn 0;\r\n}\r\nstatic int sa1111_setup_irq(struct sa1111 *sachip, unsigned irq_base)\r\n{\r\nvoid __iomem *irqbase = sachip->base + SA1111_INTC;\r\nunsigned i, irq;\r\nint ret;\r\nrequest_mem_region(sachip->phys + SA1111_INTC, 512, "irq");\r\nret = irq_alloc_descs(-1, irq_base, SA1111_IRQ_NR, -1);\r\nif (ret <= 0) {\r\ndev_err(sachip->dev, "unable to allocate %u irqs: %d\n",\r\nSA1111_IRQ_NR, ret);\r\nif (ret == 0)\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nsachip->irq_base = ret;\r\nsa1111_writel(0, irqbase + SA1111_INTEN0);\r\nsa1111_writel(0, irqbase + SA1111_INTEN1);\r\nsa1111_writel(0, irqbase + SA1111_WAKEEN0);\r\nsa1111_writel(0, irqbase + SA1111_WAKEEN1);\r\nsa1111_writel(0, irqbase + SA1111_INTPOL0);\r\nsa1111_writel(BIT(IRQ_S0_READY_NINT & 31) |\r\nBIT(IRQ_S1_READY_NINT & 31),\r\nirqbase + SA1111_INTPOL1);\r\nsa1111_writel(~0, irqbase + SA1111_INTSTATCLR0);\r\nsa1111_writel(~0, irqbase + SA1111_INTSTATCLR1);\r\nfor (i = IRQ_GPAIN0; i <= SSPROR; i++) {\r\nirq = sachip->irq_base + i;\r\nirq_set_chip_and_handler(irq, &sa1111_irq_chip, handle_edge_irq);\r\nirq_set_chip_data(irq, sachip);\r\nirq_clear_status_flags(irq, IRQ_NOREQUEST | IRQ_NOPROBE);\r\n}\r\nfor (i = AUDXMTDMADONEA; i <= IRQ_S1_BVD1_STSCHG; i++) {\r\nirq = sachip->irq_base + i;\r\nirq_set_chip_and_handler(irq, &sa1111_irq_chip, handle_edge_irq);\r\nirq_set_chip_data(irq, sachip);\r\nirq_clear_status_flags(irq, IRQ_NOREQUEST | IRQ_NOPROBE);\r\n}\r\nirq_set_irq_type(sachip->irq, IRQ_TYPE_EDGE_RISING);\r\nirq_set_chained_handler_and_data(sachip->irq, sa1111_irq_handler,\r\nsachip);\r\ndev_info(sachip->dev, "Providing IRQ%u-%u\n",\r\nsachip->irq_base, sachip->irq_base + SA1111_IRQ_NR - 1);\r\nreturn 0;\r\n}\r\nstatic void sa1111_remove_irq(struct sa1111 *sachip)\r\n{\r\nvoid __iomem *irqbase = sachip->base + SA1111_INTC;\r\nsa1111_writel(0, irqbase + SA1111_INTEN0);\r\nsa1111_writel(0, irqbase + SA1111_INTEN1);\r\nsa1111_writel(0, irqbase + SA1111_WAKEEN0);\r\nsa1111_writel(0, irqbase + SA1111_WAKEEN1);\r\nif (sachip->irq != NO_IRQ) {\r\nirq_set_chained_handler_and_data(sachip->irq, NULL, NULL);\r\nirq_free_descs(sachip->irq_base, SA1111_IRQ_NR);\r\nrelease_mem_region(sachip->phys + SA1111_INTC, 512);\r\n}\r\n}\r\nstatic struct sa1111 *gc_to_sa1111(struct gpio_chip *gc)\r\n{\r\nreturn container_of(gc, struct sa1111, gc);\r\n}\r\nstatic void __iomem *sa1111_gpio_map_reg(struct sa1111 *sachip, unsigned offset)\r\n{\r\nvoid __iomem *reg = sachip->base + SA1111_GPIO;\r\nif (offset < 4)\r\nreturn reg + SA1111_GPIO_PADDR;\r\nif (offset < 10)\r\nreturn reg + SA1111_GPIO_PBDDR;\r\nif (offset < 18)\r\nreturn reg + SA1111_GPIO_PCDDR;\r\nreturn NULL;\r\n}\r\nstatic u32 sa1111_gpio_map_bit(unsigned offset)\r\n{\r\nif (offset < 4)\r\nreturn BIT(offset);\r\nif (offset < 10)\r\nreturn BIT(offset - 4);\r\nif (offset < 18)\r\nreturn BIT(offset - 10);\r\nreturn 0;\r\n}\r\nstatic void sa1111_gpio_modify(void __iomem *reg, u32 mask, u32 set)\r\n{\r\nu32 val;\r\nval = readl_relaxed(reg);\r\nval &= ~mask;\r\nval |= mask & set;\r\nwritel_relaxed(val, reg);\r\n}\r\nstatic int sa1111_gpio_get_direction(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct sa1111 *sachip = gc_to_sa1111(gc);\r\nvoid __iomem *reg = sa1111_gpio_map_reg(sachip, offset);\r\nu32 mask = sa1111_gpio_map_bit(offset);\r\nreturn !!(readl_relaxed(reg + SA1111_GPIO_PXDDR) & mask);\r\n}\r\nstatic int sa1111_gpio_direction_input(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct sa1111 *sachip = gc_to_sa1111(gc);\r\nunsigned long flags;\r\nvoid __iomem *reg = sa1111_gpio_map_reg(sachip, offset);\r\nu32 mask = sa1111_gpio_map_bit(offset);\r\nspin_lock_irqsave(&sachip->lock, flags);\r\nsa1111_gpio_modify(reg + SA1111_GPIO_PXDDR, mask, mask);\r\nsa1111_gpio_modify(reg + SA1111_GPIO_PXSDR, mask, mask);\r\nspin_unlock_irqrestore(&sachip->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int sa1111_gpio_direction_output(struct gpio_chip *gc, unsigned offset,\r\nint value)\r\n{\r\nstruct sa1111 *sachip = gc_to_sa1111(gc);\r\nunsigned long flags;\r\nvoid __iomem *reg = sa1111_gpio_map_reg(sachip, offset);\r\nu32 mask = sa1111_gpio_map_bit(offset);\r\nspin_lock_irqsave(&sachip->lock, flags);\r\nsa1111_gpio_modify(reg + SA1111_GPIO_PXDWR, mask, value ? mask : 0);\r\nsa1111_gpio_modify(reg + SA1111_GPIO_PXSSR, mask, value ? mask : 0);\r\nsa1111_gpio_modify(reg + SA1111_GPIO_PXDDR, mask, 0);\r\nsa1111_gpio_modify(reg + SA1111_GPIO_PXSDR, mask, 0);\r\nspin_unlock_irqrestore(&sachip->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int sa1111_gpio_get(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct sa1111 *sachip = gc_to_sa1111(gc);\r\nvoid __iomem *reg = sa1111_gpio_map_reg(sachip, offset);\r\nu32 mask = sa1111_gpio_map_bit(offset);\r\nreturn !!(readl_relaxed(reg + SA1111_GPIO_PXDRR) & mask);\r\n}\r\nstatic void sa1111_gpio_set(struct gpio_chip *gc, unsigned offset, int value)\r\n{\r\nstruct sa1111 *sachip = gc_to_sa1111(gc);\r\nunsigned long flags;\r\nvoid __iomem *reg = sa1111_gpio_map_reg(sachip, offset);\r\nu32 mask = sa1111_gpio_map_bit(offset);\r\nspin_lock_irqsave(&sachip->lock, flags);\r\nsa1111_gpio_modify(reg + SA1111_GPIO_PXDWR, mask, value ? mask : 0);\r\nsa1111_gpio_modify(reg + SA1111_GPIO_PXSSR, mask, value ? mask : 0);\r\nspin_unlock_irqrestore(&sachip->lock, flags);\r\n}\r\nstatic void sa1111_gpio_set_multiple(struct gpio_chip *gc, unsigned long *mask,\r\nunsigned long *bits)\r\n{\r\nstruct sa1111 *sachip = gc_to_sa1111(gc);\r\nunsigned long flags;\r\nvoid __iomem *reg = sachip->base + SA1111_GPIO;\r\nu32 msk, val;\r\nmsk = *mask;\r\nval = *bits;\r\nspin_lock_irqsave(&sachip->lock, flags);\r\nsa1111_gpio_modify(reg + SA1111_GPIO_PADWR, msk & 15, val);\r\nsa1111_gpio_modify(reg + SA1111_GPIO_PASSR, msk & 15, val);\r\nsa1111_gpio_modify(reg + SA1111_GPIO_PBDWR, (msk >> 4) & 255, val >> 4);\r\nsa1111_gpio_modify(reg + SA1111_GPIO_PBSSR, (msk >> 4) & 255, val >> 4);\r\nsa1111_gpio_modify(reg + SA1111_GPIO_PCDWR, (msk >> 12) & 255, val >> 12);\r\nsa1111_gpio_modify(reg + SA1111_GPIO_PCSSR, (msk >> 12) & 255, val >> 12);\r\nspin_unlock_irqrestore(&sachip->lock, flags);\r\n}\r\nstatic int sa1111_gpio_to_irq(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct sa1111 *sachip = gc_to_sa1111(gc);\r\nreturn sachip->irq_base + offset;\r\n}\r\nstatic int sa1111_setup_gpios(struct sa1111 *sachip)\r\n{\r\nsachip->gc.label = "sa1111";\r\nsachip->gc.parent = sachip->dev;\r\nsachip->gc.owner = THIS_MODULE;\r\nsachip->gc.get_direction = sa1111_gpio_get_direction;\r\nsachip->gc.direction_input = sa1111_gpio_direction_input;\r\nsachip->gc.direction_output = sa1111_gpio_direction_output;\r\nsachip->gc.get = sa1111_gpio_get;\r\nsachip->gc.set = sa1111_gpio_set;\r\nsachip->gc.set_multiple = sa1111_gpio_set_multiple;\r\nsachip->gc.to_irq = sa1111_gpio_to_irq;\r\nsachip->gc.base = -1;\r\nsachip->gc.ngpio = 18;\r\nreturn devm_gpiochip_add_data(sachip->dev, &sachip->gc, sachip);\r\n}\r\nstatic void sa1111_wake(struct sa1111 *sachip)\r\n{\r\nunsigned long flags, r;\r\nspin_lock_irqsave(&sachip->lock, flags);\r\nclk_enable(sachip->clk);\r\nr = sa1111_readl(sachip->base + SA1111_SKCR);\r\nr &= ~SKCR_VCO_OFF;\r\nsa1111_writel(r, sachip->base + SA1111_SKCR);\r\nr |= SKCR_PLL_BYPASS | SKCR_OE_EN;\r\nsa1111_writel(r, sachip->base + SA1111_SKCR);\r\nudelay(100);\r\nr |= SKCR_RCLKEN | SKCR_RDYEN;\r\nsa1111_writel(r, sachip->base + SA1111_SKCR);\r\nudelay(1);\r\nsa1111_writel(0, sachip->base + SA1111_SKPCR);\r\nspin_unlock_irqrestore(&sachip->lock, flags);\r\n}\r\nvoid\r\nsa1111_configure_smc(struct sa1111 *sachip, int sdram, unsigned int drac,\r\nunsigned int cas_latency)\r\n{\r\nunsigned int smcr = SMCR_DTIM | SMCR_MBGE | FInsrt(drac, SMCR_DRAC);\r\nif (cas_latency == 3)\r\nsmcr |= SMCR_CLAT;\r\nsa1111_writel(smcr, sachip->base + SA1111_SMCR);\r\nif (sachip->dev->dma_mask)\r\n*sachip->dev->dma_mask &= sa1111_dma_mask[drac >> 2];\r\nsachip->dev->coherent_dma_mask &= sa1111_dma_mask[drac >> 2];\r\n}\r\nstatic void sa1111_dev_release(struct device *_dev)\r\n{\r\nstruct sa1111_dev *dev = to_sa1111_device(_dev);\r\nkfree(dev);\r\n}\r\nstatic int\r\nsa1111_init_one_child(struct sa1111 *sachip, struct resource *parent,\r\nstruct sa1111_dev_info *info)\r\n{\r\nstruct sa1111_dev *dev;\r\nunsigned i;\r\nint ret;\r\ndev = kzalloc(sizeof(struct sa1111_dev), GFP_KERNEL);\r\nif (!dev) {\r\nret = -ENOMEM;\r\ngoto err_alloc;\r\n}\r\ndevice_initialize(&dev->dev);\r\ndev_set_name(&dev->dev, "%4.4lx", info->offset);\r\ndev->devid = info->devid;\r\ndev->dev.parent = sachip->dev;\r\ndev->dev.bus = &sa1111_bus_type;\r\ndev->dev.release = sa1111_dev_release;\r\ndev->res.start = sachip->phys + info->offset;\r\ndev->res.end = dev->res.start + 511;\r\ndev->res.name = dev_name(&dev->dev);\r\ndev->res.flags = IORESOURCE_MEM;\r\ndev->mapbase = sachip->base + info->offset;\r\ndev->skpcr_mask = info->skpcr_mask;\r\nfor (i = 0; i < ARRAY_SIZE(info->irq); i++)\r\ndev->irq[i] = sachip->irq_base + info->irq[i];\r\nif (info->dma && sachip->dev->dma_mask) {\r\ndev->dma_mask = *sachip->dev->dma_mask;\r\ndev->dev.dma_mask = &dev->dma_mask;\r\ndev->dev.coherent_dma_mask = sachip->dev->coherent_dma_mask;\r\n}\r\nret = request_resource(parent, &dev->res);\r\nif (ret) {\r\ndev_err(sachip->dev, "failed to allocate resource for %s\n",\r\ndev->res.name);\r\ngoto err_resource;\r\n}\r\nret = device_add(&dev->dev);\r\nif (ret)\r\ngoto err_add;\r\nreturn 0;\r\nerr_add:\r\nrelease_resource(&dev->res);\r\nerr_resource:\r\nput_device(&dev->dev);\r\nerr_alloc:\r\nreturn ret;\r\n}\r\nstatic int __sa1111_probe(struct device *me, struct resource *mem, int irq)\r\n{\r\nstruct sa1111_platform_data *pd = me->platform_data;\r\nstruct sa1111 *sachip;\r\nunsigned long id;\r\nunsigned int has_devs;\r\nint i, ret = -ENODEV;\r\nif (!pd)\r\nreturn -EINVAL;\r\nsachip = devm_kzalloc(me, sizeof(struct sa1111), GFP_KERNEL);\r\nif (!sachip)\r\nreturn -ENOMEM;\r\nsachip->clk = devm_clk_get(me, "SA1111_CLK");\r\nif (IS_ERR(sachip->clk))\r\nreturn PTR_ERR(sachip->clk);\r\nret = clk_prepare(sachip->clk);\r\nif (ret)\r\nreturn ret;\r\nspin_lock_init(&sachip->lock);\r\nsachip->dev = me;\r\ndev_set_drvdata(sachip->dev, sachip);\r\nsachip->pdata = pd;\r\nsachip->phys = mem->start;\r\nsachip->irq = irq;\r\nsachip->base = ioremap(mem->start, PAGE_SIZE * 2);\r\nif (!sachip->base) {\r\nret = -ENOMEM;\r\ngoto err_clk_unprep;\r\n}\r\nid = sa1111_readl(sachip->base + SA1111_SKID);\r\nif ((id & SKID_ID_MASK) != SKID_SA1111_ID) {\r\nprintk(KERN_DEBUG "SA1111 not detected: ID = %08lx\n", id);\r\nret = -ENODEV;\r\ngoto err_unmap;\r\n}\r\npr_info("SA1111 Microprocessor Companion Chip: silicon revision %lx, metal revision %lx\n",\r\n(id & SKID_SIREV_MASK) >> 4, id & SKID_MTREV_MASK);\r\nsa1111_wake(sachip);\r\nif (sachip->irq != NO_IRQ) {\r\nret = sa1111_setup_irq(sachip, pd->irq_base);\r\nif (ret)\r\ngoto err_clk;\r\n}\r\nret = sa1111_setup_gpios(sachip);\r\nif (ret)\r\ngoto err_irq;\r\n#ifdef CONFIG_ARCH_SA1100\r\n{\r\nunsigned int val;\r\nsa1111_configure_smc(sachip, 1,\r\nFExtr(MDCNFG, MDCNFG_SA1110_DRAC0),\r\nFExtr(MDCNFG, MDCNFG_SA1110_TDL0));\r\nval = sa1111_readl(sachip->base + SA1111_SKPCR);\r\nsa1111_writel(val | SKPCR_DCLKEN, sachip->base + SA1111_SKPCR);\r\nsa1110_mb_enable();\r\n}\r\n#endif\r\ng_sa1111 = sachip;\r\nhas_devs = ~0;\r\nif (pd)\r\nhas_devs &= ~pd->disable_devs;\r\nfor (i = 0; i < ARRAY_SIZE(sa1111_devices); i++)\r\nif (sa1111_devices[i].devid & has_devs)\r\nsa1111_init_one_child(sachip, mem, &sa1111_devices[i]);\r\nreturn 0;\r\nerr_irq:\r\nsa1111_remove_irq(sachip);\r\nerr_clk:\r\nclk_disable(sachip->clk);\r\nerr_unmap:\r\niounmap(sachip->base);\r\nerr_clk_unprep:\r\nclk_unprepare(sachip->clk);\r\nreturn ret;\r\n}\r\nstatic int sa1111_remove_one(struct device *dev, void *data)\r\n{\r\nstruct sa1111_dev *sadev = to_sa1111_device(dev);\r\nif (dev->bus != &sa1111_bus_type)\r\nreturn 0;\r\ndevice_del(&sadev->dev);\r\nrelease_resource(&sadev->res);\r\nput_device(&sadev->dev);\r\nreturn 0;\r\n}\r\nstatic void __sa1111_remove(struct sa1111 *sachip)\r\n{\r\ndevice_for_each_child(sachip->dev, NULL, sa1111_remove_one);\r\nsa1111_remove_irq(sachip);\r\nclk_disable(sachip->clk);\r\nclk_unprepare(sachip->clk);\r\niounmap(sachip->base);\r\n}\r\nstatic int sa1111_suspend_noirq(struct device *dev)\r\n{\r\nstruct sa1111 *sachip = dev_get_drvdata(dev);\r\nstruct sa1111_save_data *save;\r\nunsigned long flags;\r\nunsigned int val;\r\nvoid __iomem *base;\r\nsave = kmalloc(sizeof(struct sa1111_save_data), GFP_KERNEL);\r\nif (!save)\r\nreturn -ENOMEM;\r\nsachip->saved_state = save;\r\nspin_lock_irqsave(&sachip->lock, flags);\r\nbase = sachip->base;\r\nsave->skcr = sa1111_readl(base + SA1111_SKCR);\r\nsave->skpcr = sa1111_readl(base + SA1111_SKPCR);\r\nsave->skcdr = sa1111_readl(base + SA1111_SKCDR);\r\nsave->skaud = sa1111_readl(base + SA1111_SKAUD);\r\nsave->skpwm0 = sa1111_readl(base + SA1111_SKPWM0);\r\nsave->skpwm1 = sa1111_readl(base + SA1111_SKPWM1);\r\nsa1111_writel(0, sachip->base + SA1111_SKPWM0);\r\nsa1111_writel(0, sachip->base + SA1111_SKPWM1);\r\nbase = sachip->base + SA1111_INTC;\r\nsave->intpol0 = sa1111_readl(base + SA1111_INTPOL0);\r\nsave->intpol1 = sa1111_readl(base + SA1111_INTPOL1);\r\nsave->inten0 = sa1111_readl(base + SA1111_INTEN0);\r\nsave->inten1 = sa1111_readl(base + SA1111_INTEN1);\r\nsave->wakepol0 = sa1111_readl(base + SA1111_WAKEPOL0);\r\nsave->wakepol1 = sa1111_readl(base + SA1111_WAKEPOL1);\r\nsave->wakeen0 = sa1111_readl(base + SA1111_WAKEEN0);\r\nsave->wakeen1 = sa1111_readl(base + SA1111_WAKEEN1);\r\nval = sa1111_readl(sachip->base + SA1111_SKCR);\r\nsa1111_writel(val | SKCR_SLEEP, sachip->base + SA1111_SKCR);\r\nclk_disable(sachip->clk);\r\nspin_unlock_irqrestore(&sachip->lock, flags);\r\n#ifdef CONFIG_ARCH_SA1100\r\nsa1110_mb_disable();\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int sa1111_resume_noirq(struct device *dev)\r\n{\r\nstruct sa1111 *sachip = dev_get_drvdata(dev);\r\nstruct sa1111_save_data *save;\r\nunsigned long flags, id;\r\nvoid __iomem *base;\r\nsave = sachip->saved_state;\r\nif (!save)\r\nreturn 0;\r\nid = sa1111_readl(sachip->base + SA1111_SKID);\r\nif ((id & SKID_ID_MASK) != SKID_SA1111_ID) {\r\n__sa1111_remove(sachip);\r\ndev_set_drvdata(dev, NULL);\r\nkfree(save);\r\nreturn 0;\r\n}\r\nsa1111_wake(sachip);\r\n#ifdef CONFIG_ARCH_SA1100\r\nsa1110_mb_enable();\r\n#endif\r\nspin_lock_irqsave(&sachip->lock, flags);\r\nsa1111_writel(0, sachip->base + SA1111_INTC + SA1111_INTEN0);\r\nsa1111_writel(0, sachip->base + SA1111_INTC + SA1111_INTEN1);\r\nbase = sachip->base;\r\nsa1111_writel(save->skcr, base + SA1111_SKCR);\r\nsa1111_writel(save->skpcr, base + SA1111_SKPCR);\r\nsa1111_writel(save->skcdr, base + SA1111_SKCDR);\r\nsa1111_writel(save->skaud, base + SA1111_SKAUD);\r\nsa1111_writel(save->skpwm0, base + SA1111_SKPWM0);\r\nsa1111_writel(save->skpwm1, base + SA1111_SKPWM1);\r\nbase = sachip->base + SA1111_INTC;\r\nsa1111_writel(save->intpol0, base + SA1111_INTPOL0);\r\nsa1111_writel(save->intpol1, base + SA1111_INTPOL1);\r\nsa1111_writel(save->inten0, base + SA1111_INTEN0);\r\nsa1111_writel(save->inten1, base + SA1111_INTEN1);\r\nsa1111_writel(save->wakepol0, base + SA1111_WAKEPOL0);\r\nsa1111_writel(save->wakepol1, base + SA1111_WAKEPOL1);\r\nsa1111_writel(save->wakeen0, base + SA1111_WAKEEN0);\r\nsa1111_writel(save->wakeen1, base + SA1111_WAKEEN1);\r\nspin_unlock_irqrestore(&sachip->lock, flags);\r\nsachip->saved_state = NULL;\r\nkfree(save);\r\nreturn 0;\r\n}\r\nstatic int sa1111_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *mem;\r\nint irq;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!mem)\r\nreturn -EINVAL;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn irq;\r\nreturn __sa1111_probe(&pdev->dev, mem, irq);\r\n}\r\nstatic int sa1111_remove(struct platform_device *pdev)\r\n{\r\nstruct sa1111 *sachip = platform_get_drvdata(pdev);\r\nif (sachip) {\r\n#ifdef CONFIG_PM\r\nkfree(sachip->saved_state);\r\nsachip->saved_state = NULL;\r\n#endif\r\n__sa1111_remove(sachip);\r\nplatform_set_drvdata(pdev, NULL);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline struct sa1111 *sa1111_chip_driver(struct sa1111_dev *sadev)\r\n{\r\nreturn (struct sa1111 *)dev_get_drvdata(sadev->dev.parent);\r\n}\r\nstatic unsigned int __sa1111_pll_clock(struct sa1111 *sachip)\r\n{\r\nunsigned int skcdr, fbdiv, ipdiv, opdiv;\r\nskcdr = sa1111_readl(sachip->base + SA1111_SKCDR);\r\nfbdiv = (skcdr & 0x007f) + 2;\r\nipdiv = ((skcdr & 0x0f80) >> 7) + 2;\r\nopdiv = opdiv_table[(skcdr & 0x3000) >> 12];\r\nreturn 3686400 * fbdiv / (ipdiv * opdiv);\r\n}\r\nunsigned int sa1111_pll_clock(struct sa1111_dev *sadev)\r\n{\r\nstruct sa1111 *sachip = sa1111_chip_driver(sadev);\r\nreturn __sa1111_pll_clock(sachip);\r\n}\r\nvoid sa1111_select_audio_mode(struct sa1111_dev *sadev, int mode)\r\n{\r\nstruct sa1111 *sachip = sa1111_chip_driver(sadev);\r\nunsigned long flags;\r\nunsigned int val;\r\nspin_lock_irqsave(&sachip->lock, flags);\r\nval = sa1111_readl(sachip->base + SA1111_SKCR);\r\nif (mode == SA1111_AUDIO_I2S) {\r\nval &= ~SKCR_SELAC;\r\n} else {\r\nval |= SKCR_SELAC;\r\n}\r\nsa1111_writel(val, sachip->base + SA1111_SKCR);\r\nspin_unlock_irqrestore(&sachip->lock, flags);\r\n}\r\nint sa1111_set_audio_rate(struct sa1111_dev *sadev, int rate)\r\n{\r\nstruct sa1111 *sachip = sa1111_chip_driver(sadev);\r\nunsigned int div;\r\nif (sadev->devid != SA1111_DEVID_SAC)\r\nreturn -EINVAL;\r\ndiv = (__sa1111_pll_clock(sachip) / 256 + rate / 2) / rate;\r\nif (div == 0)\r\ndiv = 1;\r\nif (div > 128)\r\ndiv = 128;\r\nsa1111_writel(div - 1, sachip->base + SA1111_SKAUD);\r\nreturn 0;\r\n}\r\nint sa1111_get_audio_rate(struct sa1111_dev *sadev)\r\n{\r\nstruct sa1111 *sachip = sa1111_chip_driver(sadev);\r\nunsigned long div;\r\nif (sadev->devid != SA1111_DEVID_SAC)\r\nreturn -EINVAL;\r\ndiv = sa1111_readl(sachip->base + SA1111_SKAUD) + 1;\r\nreturn __sa1111_pll_clock(sachip) / (256 * div);\r\n}\r\nvoid sa1111_set_io_dir(struct sa1111_dev *sadev,\r\nunsigned int bits, unsigned int dir,\r\nunsigned int sleep_dir)\r\n{\r\nstruct sa1111 *sachip = sa1111_chip_driver(sadev);\r\nunsigned long flags;\r\nunsigned int val;\r\nvoid __iomem *gpio = sachip->base + SA1111_GPIO;\r\n#define MODIFY_BITS(port, mask, dir) \\r\nif (mask) { \\r\nval = sa1111_readl(port); \\r\nval &= ~(mask); \\r\nval |= (dir) & (mask); \\r\nsa1111_writel(val, port); \\r\n}\r\nspin_lock_irqsave(&sachip->lock, flags);\r\nMODIFY_BITS(gpio + SA1111_GPIO_PADDR, bits & 15, dir);\r\nMODIFY_BITS(gpio + SA1111_GPIO_PBDDR, (bits >> 8) & 255, dir >> 8);\r\nMODIFY_BITS(gpio + SA1111_GPIO_PCDDR, (bits >> 16) & 255, dir >> 16);\r\nMODIFY_BITS(gpio + SA1111_GPIO_PASDR, bits & 15, sleep_dir);\r\nMODIFY_BITS(gpio + SA1111_GPIO_PBSDR, (bits >> 8) & 255, sleep_dir >> 8);\r\nMODIFY_BITS(gpio + SA1111_GPIO_PCSDR, (bits >> 16) & 255, sleep_dir >> 16);\r\nspin_unlock_irqrestore(&sachip->lock, flags);\r\n}\r\nvoid sa1111_set_io(struct sa1111_dev *sadev, unsigned int bits, unsigned int v)\r\n{\r\nstruct sa1111 *sachip = sa1111_chip_driver(sadev);\r\nunsigned long flags;\r\nunsigned int val;\r\nvoid __iomem *gpio = sachip->base + SA1111_GPIO;\r\nspin_lock_irqsave(&sachip->lock, flags);\r\nMODIFY_BITS(gpio + SA1111_GPIO_PADWR, bits & 15, v);\r\nMODIFY_BITS(gpio + SA1111_GPIO_PBDWR, (bits >> 8) & 255, v >> 8);\r\nMODIFY_BITS(gpio + SA1111_GPIO_PCDWR, (bits >> 16) & 255, v >> 16);\r\nspin_unlock_irqrestore(&sachip->lock, flags);\r\n}\r\nvoid sa1111_set_sleep_io(struct sa1111_dev *sadev, unsigned int bits, unsigned int v)\r\n{\r\nstruct sa1111 *sachip = sa1111_chip_driver(sadev);\r\nunsigned long flags;\r\nunsigned int val;\r\nvoid __iomem *gpio = sachip->base + SA1111_GPIO;\r\nspin_lock_irqsave(&sachip->lock, flags);\r\nMODIFY_BITS(gpio + SA1111_GPIO_PASSR, bits & 15, v);\r\nMODIFY_BITS(gpio + SA1111_GPIO_PBSSR, (bits >> 8) & 255, v >> 8);\r\nMODIFY_BITS(gpio + SA1111_GPIO_PCSSR, (bits >> 16) & 255, v >> 16);\r\nspin_unlock_irqrestore(&sachip->lock, flags);\r\n}\r\nint sa1111_enable_device(struct sa1111_dev *sadev)\r\n{\r\nstruct sa1111 *sachip = sa1111_chip_driver(sadev);\r\nunsigned long flags;\r\nunsigned int val;\r\nint ret = 0;\r\nif (sachip->pdata && sachip->pdata->enable)\r\nret = sachip->pdata->enable(sachip->pdata->data, sadev->devid);\r\nif (ret == 0) {\r\nspin_lock_irqsave(&sachip->lock, flags);\r\nval = sa1111_readl(sachip->base + SA1111_SKPCR);\r\nsa1111_writel(val | sadev->skpcr_mask, sachip->base + SA1111_SKPCR);\r\nspin_unlock_irqrestore(&sachip->lock, flags);\r\n}\r\nreturn ret;\r\n}\r\nvoid sa1111_disable_device(struct sa1111_dev *sadev)\r\n{\r\nstruct sa1111 *sachip = sa1111_chip_driver(sadev);\r\nunsigned long flags;\r\nunsigned int val;\r\nspin_lock_irqsave(&sachip->lock, flags);\r\nval = sa1111_readl(sachip->base + SA1111_SKPCR);\r\nsa1111_writel(val & ~sadev->skpcr_mask, sachip->base + SA1111_SKPCR);\r\nspin_unlock_irqrestore(&sachip->lock, flags);\r\nif (sachip->pdata && sachip->pdata->disable)\r\nsachip->pdata->disable(sachip->pdata->data, sadev->devid);\r\n}\r\nint sa1111_get_irq(struct sa1111_dev *sadev, unsigned num)\r\n{\r\nif (num >= ARRAY_SIZE(sadev->irq))\r\nreturn -EINVAL;\r\nreturn sadev->irq[num];\r\n}\r\nstatic int sa1111_match(struct device *_dev, struct device_driver *_drv)\r\n{\r\nstruct sa1111_dev *dev = to_sa1111_device(_dev);\r\nstruct sa1111_driver *drv = SA1111_DRV(_drv);\r\nreturn !!(dev->devid & drv->devid);\r\n}\r\nstatic int sa1111_bus_suspend(struct device *dev, pm_message_t state)\r\n{\r\nstruct sa1111_dev *sadev = to_sa1111_device(dev);\r\nstruct sa1111_driver *drv = SA1111_DRV(dev->driver);\r\nint ret = 0;\r\nif (drv && drv->suspend)\r\nret = drv->suspend(sadev, state);\r\nreturn ret;\r\n}\r\nstatic int sa1111_bus_resume(struct device *dev)\r\n{\r\nstruct sa1111_dev *sadev = to_sa1111_device(dev);\r\nstruct sa1111_driver *drv = SA1111_DRV(dev->driver);\r\nint ret = 0;\r\nif (drv && drv->resume)\r\nret = drv->resume(sadev);\r\nreturn ret;\r\n}\r\nstatic void sa1111_bus_shutdown(struct device *dev)\r\n{\r\nstruct sa1111_driver *drv = SA1111_DRV(dev->driver);\r\nif (drv && drv->shutdown)\r\ndrv->shutdown(to_sa1111_device(dev));\r\n}\r\nstatic int sa1111_bus_probe(struct device *dev)\r\n{\r\nstruct sa1111_dev *sadev = to_sa1111_device(dev);\r\nstruct sa1111_driver *drv = SA1111_DRV(dev->driver);\r\nint ret = -ENODEV;\r\nif (drv->probe)\r\nret = drv->probe(sadev);\r\nreturn ret;\r\n}\r\nstatic int sa1111_bus_remove(struct device *dev)\r\n{\r\nstruct sa1111_dev *sadev = to_sa1111_device(dev);\r\nstruct sa1111_driver *drv = SA1111_DRV(dev->driver);\r\nint ret = 0;\r\nif (drv->remove)\r\nret = drv->remove(sadev);\r\nreturn ret;\r\n}\r\nint sa1111_driver_register(struct sa1111_driver *driver)\r\n{\r\ndriver->drv.bus = &sa1111_bus_type;\r\nreturn driver_register(&driver->drv);\r\n}\r\nvoid sa1111_driver_unregister(struct sa1111_driver *driver)\r\n{\r\ndriver_unregister(&driver->drv);\r\n}\r\nstatic int sa1111_needs_bounce(struct device *dev, dma_addr_t addr, size_t size)\r\n{\r\nreturn (machine_is_assabet() || machine_is_pfs168()) &&\r\n(addr >= 0xc8000000 || (addr + size) >= 0xc8000000);\r\n}\r\nstatic int sa1111_notifier_call(struct notifier_block *n, unsigned long action,\r\nvoid *data)\r\n{\r\nstruct sa1111_dev *dev = to_sa1111_device(data);\r\nswitch (action) {\r\ncase BUS_NOTIFY_ADD_DEVICE:\r\nif (dev->dev.dma_mask && dev->dma_mask < 0xffffffffUL) {\r\nint ret = dmabounce_register_dev(&dev->dev, 1024, 4096,\r\nsa1111_needs_bounce);\r\nif (ret)\r\ndev_err(&dev->dev, "failed to register with dmabounce: %d\n", ret);\r\n}\r\nbreak;\r\ncase BUS_NOTIFY_DEL_DEVICE:\r\nif (dev->dev.dma_mask && dev->dma_mask < 0xffffffffUL)\r\ndmabounce_unregister_dev(&dev->dev);\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int __init sa1111_init(void)\r\n{\r\nint ret = bus_register(&sa1111_bus_type);\r\n#ifdef CONFIG_DMABOUNCE\r\nif (ret == 0)\r\nbus_register_notifier(&sa1111_bus_type, &sa1111_bus_notifier);\r\n#endif\r\nif (ret == 0)\r\nplatform_driver_register(&sa1111_device_driver);\r\nreturn ret;\r\n}\r\nstatic void __exit sa1111_exit(void)\r\n{\r\nplatform_driver_unregister(&sa1111_device_driver);\r\n#ifdef CONFIG_DMABOUNCE\r\nbus_unregister_notifier(&sa1111_bus_type, &sa1111_bus_notifier);\r\n#endif\r\nbus_unregister(&sa1111_bus_type);\r\n}
