const struct vivid_fmt *vivid_get_format(struct vivid_dev *dev, u32 pixelformat)\r\n{\r\nconst struct vivid_fmt *fmt;\r\nunsigned k;\r\nfor (k = 0; k < ARRAY_SIZE(vivid_formats); k++) {\r\nfmt = &vivid_formats[k];\r\nif (fmt->fourcc == pixelformat)\r\nif (fmt->buffers == 1 || dev->multiplanar)\r\nreturn fmt;\r\n}\r\nreturn NULL;\r\n}\r\nbool vivid_vid_can_loop(struct vivid_dev *dev)\r\n{\r\nif (dev->src_rect.width != dev->sink_rect.width ||\r\ndev->src_rect.height != dev->sink_rect.height)\r\nreturn false;\r\nif (dev->fmt_cap->fourcc != dev->fmt_out->fourcc)\r\nreturn false;\r\nif (dev->field_cap != dev->field_out)\r\nreturn false;\r\nif (dev->field_cap == V4L2_FIELD_SEQ_TB ||\r\ndev->field_cap == V4L2_FIELD_SEQ_BT)\r\nreturn false;\r\nif (vivid_is_svid_cap(dev) && vivid_is_svid_out(dev)) {\r\nif (!(dev->std_cap & V4L2_STD_525_60) !=\r\n!(dev->std_out & V4L2_STD_525_60))\r\nreturn false;\r\nreturn true;\r\n}\r\nif (vivid_is_hdmi_cap(dev) && vivid_is_hdmi_out(dev))\r\nreturn true;\r\nreturn false;\r\n}\r\nvoid vivid_send_source_change(struct vivid_dev *dev, unsigned type)\r\n{\r\nstruct v4l2_event ev = {\r\n.type = V4L2_EVENT_SOURCE_CHANGE,\r\n.u.src_change.changes = V4L2_EVENT_SRC_CH_RESOLUTION,\r\n};\r\nunsigned i;\r\nfor (i = 0; i < dev->num_inputs; i++) {\r\nev.id = i;\r\nif (dev->input_type[i] == type) {\r\nif (video_is_registered(&dev->vid_cap_dev) && dev->has_vid_cap)\r\nv4l2_event_queue(&dev->vid_cap_dev, &ev);\r\nif (video_is_registered(&dev->vbi_cap_dev) && dev->has_vbi_cap)\r\nv4l2_event_queue(&dev->vbi_cap_dev, &ev);\r\n}\r\n}\r\n}\r\nvoid fmt_sp2mp(const struct v4l2_format *sp_fmt, struct v4l2_format *mp_fmt)\r\n{\r\nstruct v4l2_pix_format_mplane *mp = &mp_fmt->fmt.pix_mp;\r\nstruct v4l2_plane_pix_format *ppix = &mp->plane_fmt[0];\r\nconst struct v4l2_pix_format *pix = &sp_fmt->fmt.pix;\r\nbool is_out = sp_fmt->type == V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\nmemset(mp->reserved, 0, sizeof(mp->reserved));\r\nmp_fmt->type = is_out ? V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE :\r\nV4L2_CAP_VIDEO_CAPTURE_MPLANE;\r\nmp->width = pix->width;\r\nmp->height = pix->height;\r\nmp->pixelformat = pix->pixelformat;\r\nmp->field = pix->field;\r\nmp->colorspace = pix->colorspace;\r\nmp->xfer_func = pix->xfer_func;\r\nmp->ycbcr_enc = pix->ycbcr_enc;\r\nmp->quantization = pix->quantization;\r\nmp->num_planes = 1;\r\nmp->flags = pix->flags;\r\nppix->sizeimage = pix->sizeimage;\r\nppix->bytesperline = pix->bytesperline;\r\nmemset(ppix->reserved, 0, sizeof(ppix->reserved));\r\n}\r\nint fmt_sp2mp_func(struct file *file, void *priv,\r\nstruct v4l2_format *f, fmtfunc func)\r\n{\r\nstruct v4l2_format fmt;\r\nstruct v4l2_pix_format_mplane *mp = &fmt.fmt.pix_mp;\r\nstruct v4l2_plane_pix_format *ppix = &mp->plane_fmt[0];\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nint ret;\r\nfmt_sp2mp(f, &fmt);\r\nret = func(file, priv, &fmt);\r\npix->width = mp->width;\r\npix->height = mp->height;\r\npix->pixelformat = mp->pixelformat;\r\npix->field = mp->field;\r\npix->colorspace = mp->colorspace;\r\npix->xfer_func = mp->xfer_func;\r\npix->ycbcr_enc = mp->ycbcr_enc;\r\npix->quantization = mp->quantization;\r\npix->sizeimage = ppix->sizeimage;\r\npix->bytesperline = ppix->bytesperline;\r\npix->flags = mp->flags;\r\nreturn ret;\r\n}\r\nint vivid_vid_adjust_sel(unsigned flags, struct v4l2_rect *r)\r\n{\r\nunsigned w = r->width;\r\nunsigned h = r->height;\r\nw &= 0xffff;\r\nh &= 0xffff;\r\nif (!(flags & V4L2_SEL_FLAG_LE)) {\r\nw++;\r\nh++;\r\nif (w < 2)\r\nw = 2;\r\nif (h < 2)\r\nh = 2;\r\n}\r\nif (!(flags & V4L2_SEL_FLAG_GE)) {\r\nif (w > MAX_WIDTH)\r\nw = MAX_WIDTH;\r\nif (h > MAX_HEIGHT)\r\nh = MAX_HEIGHT;\r\n}\r\nw = w & ~1;\r\nh = h & ~1;\r\nif (w < 2 || h < 2)\r\nreturn -ERANGE;\r\nif (w > MAX_WIDTH || h > MAX_HEIGHT)\r\nreturn -ERANGE;\r\nif (r->top < 0)\r\nr->top = 0;\r\nif (r->left < 0)\r\nr->left = 0;\r\nr->left &= 0xfffe;\r\nr->top &= 0xfffe;\r\nif (r->left + w > MAX_WIDTH)\r\nr->left = MAX_WIDTH - w;\r\nif (r->top + h > MAX_HEIGHT)\r\nr->top = MAX_HEIGHT - h;\r\nif ((flags & (V4L2_SEL_FLAG_GE | V4L2_SEL_FLAG_LE)) ==\r\n(V4L2_SEL_FLAG_GE | V4L2_SEL_FLAG_LE) &&\r\n(r->width != w || r->height != h))\r\nreturn -ERANGE;\r\nr->width = w;\r\nr->height = h;\r\nreturn 0;\r\n}\r\nint vivid_enum_fmt_vid(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\nconst struct vivid_fmt *fmt;\r\nif (f->index >= ARRAY_SIZE(vivid_formats) -\r\n(dev->multiplanar ? 0 : VIVID_MPLANAR_FORMATS))\r\nreturn -EINVAL;\r\nfmt = &vivid_formats[f->index];\r\nf->pixelformat = fmt->fourcc;\r\nreturn 0;\r\n}\r\nint vidioc_enum_fmt_vid_mplane(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\nif (!dev->multiplanar)\r\nreturn -ENOTTY;\r\nreturn vivid_enum_fmt_vid(file, priv, f);\r\n}\r\nint vidioc_enum_fmt_vid(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\nif (dev->multiplanar)\r\nreturn -ENOTTY;\r\nreturn vivid_enum_fmt_vid(file, priv, f);\r\n}\r\nint vidioc_g_std(struct file *file, void *priv, v4l2_std_id *id)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\nstruct video_device *vdev = video_devdata(file);\r\nif (vdev->vfl_dir == VFL_DIR_RX) {\r\nif (!vivid_is_sdtv_cap(dev))\r\nreturn -ENODATA;\r\n*id = dev->std_cap;\r\n} else {\r\nif (!vivid_is_svid_out(dev))\r\nreturn -ENODATA;\r\n*id = dev->std_out;\r\n}\r\nreturn 0;\r\n}\r\nint vidioc_g_dv_timings(struct file *file, void *_fh,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\nstruct video_device *vdev = video_devdata(file);\r\nif (vdev->vfl_dir == VFL_DIR_RX) {\r\nif (!vivid_is_hdmi_cap(dev))\r\nreturn -ENODATA;\r\n*timings = dev->dv_timings_cap;\r\n} else {\r\nif (!vivid_is_hdmi_out(dev))\r\nreturn -ENODATA;\r\n*timings = dev->dv_timings_out;\r\n}\r\nreturn 0;\r\n}\r\nint vidioc_enum_dv_timings(struct file *file, void *_fh,\r\nstruct v4l2_enum_dv_timings *timings)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\nstruct video_device *vdev = video_devdata(file);\r\nif (vdev->vfl_dir == VFL_DIR_RX) {\r\nif (!vivid_is_hdmi_cap(dev))\r\nreturn -ENODATA;\r\n} else {\r\nif (!vivid_is_hdmi_out(dev))\r\nreturn -ENODATA;\r\n}\r\nreturn v4l2_enum_dv_timings_cap(timings, &vivid_dv_timings_cap,\r\nNULL, NULL);\r\n}\r\nint vidioc_dv_timings_cap(struct file *file, void *_fh,\r\nstruct v4l2_dv_timings_cap *cap)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\nstruct video_device *vdev = video_devdata(file);\r\nif (vdev->vfl_dir == VFL_DIR_RX) {\r\nif (!vivid_is_hdmi_cap(dev))\r\nreturn -ENODATA;\r\n} else {\r\nif (!vivid_is_hdmi_out(dev))\r\nreturn -ENODATA;\r\n}\r\n*cap = vivid_dv_timings_cap;\r\nreturn 0;\r\n}\r\nint vidioc_g_edid(struct file *file, void *_fh,\r\nstruct v4l2_edid *edid)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct cec_adapter *adap;\r\nmemset(edid->reserved, 0, sizeof(edid->reserved));\r\nif (vdev->vfl_dir == VFL_DIR_RX) {\r\nif (edid->pad >= dev->num_inputs)\r\nreturn -EINVAL;\r\nif (dev->input_type[edid->pad] != HDMI)\r\nreturn -EINVAL;\r\nadap = dev->cec_rx_adap;\r\n} else {\r\nunsigned int bus_idx;\r\nif (edid->pad >= dev->num_outputs)\r\nreturn -EINVAL;\r\nif (dev->output_type[edid->pad] != HDMI)\r\nreturn -EINVAL;\r\nbus_idx = dev->cec_output2bus_map[edid->pad];\r\nadap = dev->cec_tx_adap[bus_idx];\r\n}\r\nif (edid->start_block == 0 && edid->blocks == 0) {\r\nedid->blocks = dev->edid_blocks;\r\nreturn 0;\r\n}\r\nif (dev->edid_blocks == 0)\r\nreturn -ENODATA;\r\nif (edid->start_block >= dev->edid_blocks)\r\nreturn -EINVAL;\r\nif (edid->start_block + edid->blocks > dev->edid_blocks)\r\nedid->blocks = dev->edid_blocks - edid->start_block;\r\ncec_set_edid_phys_addr(dev->edid, dev->edid_blocks * 128, adap->phys_addr);\r\nmemcpy(edid->edid, dev->edid + edid->start_block * 128, edid->blocks * 128);\r\nreturn 0;\r\n}
