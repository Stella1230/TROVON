static struct vmw_cotable *vmw_cotable(struct vmw_resource *res)\r\n{\r\nreturn container_of(res, struct vmw_cotable, res);\r\n}\r\nstatic int vmw_cotable_destroy(struct vmw_resource *res)\r\n{\r\nres->id = -1;\r\nreturn 0;\r\n}\r\nstatic int vmw_cotable_unscrub(struct vmw_resource *res)\r\n{\r\nstruct vmw_cotable *vcotbl = vmw_cotable(res);\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nstruct ttm_buffer_object *bo = &res->backup->base;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdDXSetCOTable body;\r\n} *cmd;\r\nWARN_ON_ONCE(bo->mem.mem_type != VMW_PL_MOB);\r\nlockdep_assert_held(&bo->resv->lock.base);\r\ncmd = vmw_fifo_reserve_dx(dev_priv, sizeof(*cmd), SVGA3D_INVALID_ID);\r\nif (!cmd) {\r\nDRM_ERROR("Failed reserving FIFO space for cotable "\r\n"binding.\n");\r\nreturn -ENOMEM;\r\n}\r\nWARN_ON(vcotbl->ctx->id == SVGA3D_INVALID_ID);\r\nWARN_ON(bo->mem.mem_type != VMW_PL_MOB);\r\ncmd->header.id = SVGA_3D_CMD_DX_SET_COTABLE;\r\ncmd->header.size = sizeof(cmd->body);\r\ncmd->body.cid = vcotbl->ctx->id;\r\ncmd->body.type = vcotbl->type;\r\ncmd->body.mobid = bo->mem.start;\r\ncmd->body.validSizeInBytes = vcotbl->size_read_back;\r\nvmw_fifo_commit_flush(dev_priv, sizeof(*cmd));\r\nvcotbl->scrubbed = false;\r\nreturn 0;\r\n}\r\nstatic int vmw_cotable_bind(struct vmw_resource *res,\r\nstruct ttm_validate_buffer *val_buf)\r\n{\r\nval_buf->bo = &res->backup->base;\r\nreturn vmw_cotable_unscrub(res);\r\n}\r\nint vmw_cotable_scrub(struct vmw_resource *res, bool readback)\r\n{\r\nstruct vmw_cotable *vcotbl = vmw_cotable(res);\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nsize_t submit_size;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdDXReadbackCOTable body;\r\n} *cmd0;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdDXSetCOTable body;\r\n} *cmd1;\r\nif (vcotbl->scrubbed)\r\nreturn 0;\r\nif (co_info[vcotbl->type].unbind_func)\r\nco_info[vcotbl->type].unbind_func(dev_priv,\r\n&vcotbl->resource_list,\r\nreadback);\r\nsubmit_size = sizeof(*cmd1);\r\nif (readback)\r\nsubmit_size += sizeof(*cmd0);\r\ncmd1 = vmw_fifo_reserve_dx(dev_priv, submit_size, SVGA3D_INVALID_ID);\r\nif (!cmd1) {\r\nDRM_ERROR("Failed reserving FIFO space for cotable "\r\n"unbinding.\n");\r\nreturn -ENOMEM;\r\n}\r\nvcotbl->size_read_back = 0;\r\nif (readback) {\r\ncmd0 = (void *) cmd1;\r\ncmd0->header.id = SVGA_3D_CMD_DX_READBACK_COTABLE;\r\ncmd0->header.size = sizeof(cmd0->body);\r\ncmd0->body.cid = vcotbl->ctx->id;\r\ncmd0->body.type = vcotbl->type;\r\ncmd1 = (void *) &cmd0[1];\r\nvcotbl->size_read_back = res->backup_size;\r\n}\r\ncmd1->header.id = SVGA_3D_CMD_DX_SET_COTABLE;\r\ncmd1->header.size = sizeof(cmd1->body);\r\ncmd1->body.cid = vcotbl->ctx->id;\r\ncmd1->body.type = vcotbl->type;\r\ncmd1->body.mobid = SVGA3D_INVALID_ID;\r\ncmd1->body.validSizeInBytes = 0;\r\nvmw_fifo_commit_flush(dev_priv, submit_size);\r\nvcotbl->scrubbed = true;\r\nres->id = -1;\r\nreturn 0;\r\n}\r\nstatic int vmw_cotable_unbind(struct vmw_resource *res,\r\nbool readback,\r\nstruct ttm_validate_buffer *val_buf)\r\n{\r\nstruct vmw_cotable *vcotbl = vmw_cotable(res);\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nstruct ttm_buffer_object *bo = val_buf->bo;\r\nstruct vmw_fence_obj *fence;\r\nif (list_empty(&res->mob_head))\r\nreturn 0;\r\nWARN_ON_ONCE(bo->mem.mem_type != VMW_PL_MOB);\r\nlockdep_assert_held(&bo->resv->lock.base);\r\nmutex_lock(&dev_priv->binding_mutex);\r\nif (!vcotbl->scrubbed)\r\nvmw_dx_context_scrub_cotables(vcotbl->ctx, readback);\r\nmutex_unlock(&dev_priv->binding_mutex);\r\n(void) vmw_execbuf_fence_commands(NULL, dev_priv, &fence, NULL);\r\nvmw_fence_single_bo(bo, fence);\r\nif (likely(fence != NULL))\r\nvmw_fence_obj_unreference(&fence);\r\nreturn 0;\r\n}\r\nstatic int vmw_cotable_readback(struct vmw_resource *res)\r\n{\r\nstruct vmw_cotable *vcotbl = vmw_cotable(res);\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdDXReadbackCOTable body;\r\n} *cmd;\r\nstruct vmw_fence_obj *fence;\r\nif (!vcotbl->scrubbed) {\r\ncmd = vmw_fifo_reserve_dx(dev_priv, sizeof(*cmd),\r\nSVGA3D_INVALID_ID);\r\nif (!cmd) {\r\nDRM_ERROR("Failed reserving FIFO space for cotable "\r\n"readback.\n");\r\nreturn -ENOMEM;\r\n}\r\ncmd->header.id = SVGA_3D_CMD_DX_READBACK_COTABLE;\r\ncmd->header.size = sizeof(cmd->body);\r\ncmd->body.cid = vcotbl->ctx->id;\r\ncmd->body.type = vcotbl->type;\r\nvcotbl->size_read_back = res->backup_size;\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\n}\r\n(void) vmw_execbuf_fence_commands(NULL, dev_priv, &fence, NULL);\r\nvmw_fence_single_bo(&res->backup->base, fence);\r\nvmw_fence_obj_unreference(&fence);\r\nreturn 0;\r\n}\r\nstatic int vmw_cotable_resize(struct vmw_resource *res, size_t new_size)\r\n{\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nstruct vmw_cotable *vcotbl = vmw_cotable(res);\r\nstruct vmw_dma_buffer *buf, *old_buf = res->backup;\r\nstruct ttm_buffer_object *bo, *old_bo = &res->backup->base;\r\nsize_t old_size = res->backup_size;\r\nsize_t old_size_read_back = vcotbl->size_read_back;\r\nsize_t cur_size_read_back;\r\nstruct ttm_bo_kmap_obj old_map, new_map;\r\nint ret;\r\nsize_t i;\r\nret = vmw_cotable_readback(res);\r\nif (ret)\r\nreturn ret;\r\ncur_size_read_back = vcotbl->size_read_back;\r\nvcotbl->size_read_back = old_size_read_back;\r\nbuf = kzalloc(sizeof(*buf), GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nret = vmw_dmabuf_init(dev_priv, buf, new_size, &vmw_mob_ne_placement,\r\ntrue, vmw_dmabuf_bo_free);\r\nif (ret) {\r\nDRM_ERROR("Failed initializing new cotable MOB.\n");\r\nreturn ret;\r\n}\r\nbo = &buf->base;\r\nWARN_ON_ONCE(ttm_bo_reserve(bo, false, true, NULL));\r\nret = ttm_bo_wait(old_bo, false, false);\r\nif (unlikely(ret != 0)) {\r\nDRM_ERROR("Failed waiting for cotable unbind.\n");\r\ngoto out_wait;\r\n}\r\nfor (i = 0; i < old_bo->num_pages; ++i) {\r\nbool dummy;\r\nret = ttm_bo_kmap(old_bo, i, 1, &old_map);\r\nif (unlikely(ret != 0)) {\r\nDRM_ERROR("Failed mapping old COTable on resize.\n");\r\ngoto out_wait;\r\n}\r\nret = ttm_bo_kmap(bo, i, 1, &new_map);\r\nif (unlikely(ret != 0)) {\r\nDRM_ERROR("Failed mapping new COTable on resize.\n");\r\ngoto out_map_new;\r\n}\r\nmemcpy(ttm_kmap_obj_virtual(&new_map, &dummy),\r\nttm_kmap_obj_virtual(&old_map, &dummy),\r\nPAGE_SIZE);\r\nttm_bo_kunmap(&new_map);\r\nttm_bo_kunmap(&old_map);\r\n}\r\nret = ttm_bo_validate(bo, &vmw_mob_placement, false, false);\r\nif (unlikely(ret != 0)) {\r\nDRM_ERROR("Failed validating new COTable backup buffer.\n");\r\ngoto out_wait;\r\n}\r\nres->backup = buf;\r\nres->backup_size = new_size;\r\nvcotbl->size_read_back = cur_size_read_back;\r\nret = vmw_cotable_unscrub(res);\r\nif (ret) {\r\nDRM_ERROR("Failed switching COTable backup buffer.\n");\r\nres->backup = old_buf;\r\nres->backup_size = old_size;\r\nvcotbl->size_read_back = old_size_read_back;\r\ngoto out_wait;\r\n}\r\nlist_del(&res->mob_head);\r\nlist_add_tail(&res->mob_head, &buf->res_list);\r\nvmw_dmabuf_unreference(&old_buf);\r\nres->id = vcotbl->type;\r\nreturn 0;\r\nout_map_new:\r\nttm_bo_kunmap(&old_map);\r\nout_wait:\r\nttm_bo_unreserve(bo);\r\nvmw_dmabuf_unreference(&buf);\r\nreturn ret;\r\n}\r\nstatic int vmw_cotable_create(struct vmw_resource *res)\r\n{\r\nstruct vmw_cotable *vcotbl = vmw_cotable(res);\r\nsize_t new_size = res->backup_size;\r\nsize_t needed_size;\r\nint ret;\r\nneeded_size = (vcotbl->seen_entries + 1) * co_info[vcotbl->type].size;\r\nwhile (needed_size > new_size)\r\nnew_size *= 2;\r\nif (likely(new_size <= res->backup_size)) {\r\nif (vcotbl->scrubbed && !list_empty(&res->mob_head)) {\r\nret = vmw_cotable_unscrub(res);\r\nif (ret)\r\nreturn ret;\r\n}\r\nres->id = vcotbl->type;\r\nreturn 0;\r\n}\r\nreturn vmw_cotable_resize(res, new_size);\r\n}\r\nstatic void vmw_hw_cotable_destroy(struct vmw_resource *res)\r\n{\r\n(void) vmw_cotable_destroy(res);\r\n}\r\nstatic void vmw_cotable_free(struct vmw_resource *res)\r\n{\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nkfree(res);\r\nttm_mem_global_free(vmw_mem_glob(dev_priv), cotable_acc_size);\r\n}\r\nstruct vmw_resource *vmw_cotable_alloc(struct vmw_private *dev_priv,\r\nstruct vmw_resource *ctx,\r\nu32 type)\r\n{\r\nstruct vmw_cotable *vcotbl;\r\nint ret;\r\nu32 num_entries;\r\nif (unlikely(cotable_acc_size == 0))\r\ncotable_acc_size = ttm_round_pot(sizeof(struct vmw_cotable));\r\nret = ttm_mem_global_alloc(vmw_mem_glob(dev_priv),\r\ncotable_acc_size, false, true);\r\nif (unlikely(ret))\r\nreturn ERR_PTR(ret);\r\nvcotbl = kzalloc(sizeof(*vcotbl), GFP_KERNEL);\r\nif (unlikely(!vcotbl)) {\r\nret = -ENOMEM;\r\ngoto out_no_alloc;\r\n}\r\nret = vmw_resource_init(dev_priv, &vcotbl->res, true,\r\nvmw_cotable_free, &vmw_cotable_func);\r\nif (unlikely(ret != 0))\r\ngoto out_no_init;\r\nINIT_LIST_HEAD(&vcotbl->resource_list);\r\nvcotbl->res.id = type;\r\nvcotbl->res.backup_size = PAGE_SIZE;\r\nnum_entries = PAGE_SIZE / co_info[type].size;\r\nif (num_entries < co_info[type].min_initial_entries) {\r\nvcotbl->res.backup_size = co_info[type].min_initial_entries *\r\nco_info[type].size;\r\nvcotbl->res.backup_size =\r\n(vcotbl->res.backup_size + PAGE_SIZE - 1) & PAGE_MASK;\r\n}\r\nvcotbl->scrubbed = true;\r\nvcotbl->seen_entries = -1;\r\nvcotbl->type = type;\r\nvcotbl->ctx = ctx;\r\nvmw_resource_activate(&vcotbl->res, vmw_hw_cotable_destroy);\r\nreturn &vcotbl->res;\r\nout_no_init:\r\nkfree(vcotbl);\r\nout_no_alloc:\r\nttm_mem_global_free(vmw_mem_glob(dev_priv), cotable_acc_size);\r\nreturn ERR_PTR(ret);\r\n}\r\nint vmw_cotable_notify(struct vmw_resource *res, int id)\r\n{\r\nstruct vmw_cotable *vcotbl = vmw_cotable(res);\r\nif (id < 0 || id >= SVGA_COTABLE_MAX_IDS) {\r\nDRM_ERROR("Illegal COTable id. Type is %u. Id is %d\n",\r\n(unsigned) vcotbl->type, id);\r\nreturn -EINVAL;\r\n}\r\nif (vcotbl->seen_entries < id) {\r\nres->id = -1;\r\nvcotbl->seen_entries = id;\r\n}\r\nreturn 0;\r\n}\r\nvoid vmw_cotable_add_resource(struct vmw_resource *res, struct list_head *head)\r\n{\r\nstruct vmw_cotable *vcotbl =\r\ncontainer_of(res, struct vmw_cotable, res);\r\nlist_add_tail(head, &vcotbl->resource_list);\r\n}
