static void internal_define_dest_src_infos(int shift_mode,\r\nstruct tree_balance *tb,\r\nint h,\r\nstruct buffer_info *dest_bi,\r\nstruct buffer_info *src_bi,\r\nint *d_key, struct buffer_head **cf)\r\n{\r\nmemset(dest_bi, 0, sizeof(struct buffer_info));\r\nmemset(src_bi, 0, sizeof(struct buffer_info));\r\nswitch (shift_mode) {\r\ncase INTERNAL_SHIFT_FROM_S_TO_L:\r\nsrc_bi->tb = tb;\r\nsrc_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\r\nsrc_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\r\nsrc_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\r\ndest_bi->tb = tb;\r\ndest_bi->bi_bh = tb->L[h];\r\ndest_bi->bi_parent = tb->FL[h];\r\ndest_bi->bi_position = get_left_neighbor_position(tb, h);\r\n*d_key = tb->lkey[h];\r\n*cf = tb->CFL[h];\r\nbreak;\r\ncase INTERNAL_SHIFT_FROM_L_TO_S:\r\nsrc_bi->tb = tb;\r\nsrc_bi->bi_bh = tb->L[h];\r\nsrc_bi->bi_parent = tb->FL[h];\r\nsrc_bi->bi_position = get_left_neighbor_position(tb, h);\r\ndest_bi->tb = tb;\r\ndest_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\r\ndest_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\r\ndest_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\r\n*d_key = tb->lkey[h];\r\n*cf = tb->CFL[h];\r\nbreak;\r\ncase INTERNAL_SHIFT_FROM_R_TO_S:\r\nsrc_bi->tb = tb;\r\nsrc_bi->bi_bh = tb->R[h];\r\nsrc_bi->bi_parent = tb->FR[h];\r\nsrc_bi->bi_position = get_right_neighbor_position(tb, h);\r\ndest_bi->tb = tb;\r\ndest_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\r\ndest_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\r\ndest_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\r\n*d_key = tb->rkey[h];\r\n*cf = tb->CFR[h];\r\nbreak;\r\ncase INTERNAL_SHIFT_FROM_S_TO_R:\r\nsrc_bi->tb = tb;\r\nsrc_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\r\nsrc_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\r\nsrc_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\r\ndest_bi->tb = tb;\r\ndest_bi->bi_bh = tb->R[h];\r\ndest_bi->bi_parent = tb->FR[h];\r\ndest_bi->bi_position = get_right_neighbor_position(tb, h);\r\n*d_key = tb->rkey[h];\r\n*cf = tb->CFR[h];\r\nbreak;\r\ncase INTERNAL_INSERT_TO_L:\r\ndest_bi->tb = tb;\r\ndest_bi->bi_bh = tb->L[h];\r\ndest_bi->bi_parent = tb->FL[h];\r\ndest_bi->bi_position = get_left_neighbor_position(tb, h);\r\nbreak;\r\ncase INTERNAL_INSERT_TO_S:\r\ndest_bi->tb = tb;\r\ndest_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\r\ndest_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\r\ndest_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\r\nbreak;\r\ncase INTERNAL_INSERT_TO_R:\r\ndest_bi->tb = tb;\r\ndest_bi->bi_bh = tb->R[h];\r\ndest_bi->bi_parent = tb->FR[h];\r\ndest_bi->bi_position = get_right_neighbor_position(tb, h);\r\nbreak;\r\ndefault:\r\nreiserfs_panic(tb->tb_sb, "ibalance-1",\r\n"shift type is unknown (%d)",\r\nshift_mode);\r\n}\r\n}\r\nstatic void internal_insert_childs(struct buffer_info *cur_bi,\r\nint to, int count,\r\nstruct item_head *inserted,\r\nstruct buffer_head **bh)\r\n{\r\nstruct buffer_head *cur = cur_bi->bi_bh;\r\nstruct block_head *blkh;\r\nint nr;\r\nstruct reiserfs_key *ih;\r\nstruct disk_child new_dc[2];\r\nstruct disk_child *dc;\r\nint i;\r\nif (count <= 0)\r\nreturn;\r\nblkh = B_BLK_HEAD(cur);\r\nnr = blkh_nr_item(blkh);\r\nRFALSE(count > 2, "too many children (%d) are to be inserted", count);\r\nRFALSE(B_FREE_SPACE(cur) < count * (KEY_SIZE + DC_SIZE),\r\n"no enough free space (%d), needed %d bytes",\r\nB_FREE_SPACE(cur), count * (KEY_SIZE + DC_SIZE));\r\ndc = B_N_CHILD(cur, to + 1);\r\nmemmove(dc + count, dc, (nr + 1 - (to + 1)) * DC_SIZE);\r\nfor (i = 0; i < count; i++) {\r\nput_dc_size(&new_dc[i],\r\nMAX_CHILD_SIZE(bh[i]) - B_FREE_SPACE(bh[i]));\r\nput_dc_block_number(&new_dc[i], bh[i]->b_blocknr);\r\n}\r\nmemcpy(dc, new_dc, DC_SIZE * count);\r\nih = internal_key(cur, ((to == -1) ? 0 : to));\r\nmemmove(ih + count, ih,\r\n(nr - to) * KEY_SIZE + (nr + 1 + count) * DC_SIZE);\r\nmemcpy(ih, inserted, KEY_SIZE);\r\nif (count > 1)\r\nmemcpy(ih + 1, inserted + 1, KEY_SIZE);\r\nset_blkh_nr_item(blkh, blkh_nr_item(blkh) + count);\r\nset_blkh_free_space(blkh,\r\nblkh_free_space(blkh) - count * (DC_SIZE +\r\nKEY_SIZE));\r\ndo_balance_mark_internal_dirty(cur_bi->tb, cur, 0);\r\ncheck_internal(cur);\r\nif (cur_bi->bi_parent) {\r\nstruct disk_child *t_dc =\r\nB_N_CHILD(cur_bi->bi_parent, cur_bi->bi_position);\r\nput_dc_size(t_dc,\r\ndc_size(t_dc) + (count * (DC_SIZE + KEY_SIZE)));\r\ndo_balance_mark_internal_dirty(cur_bi->tb, cur_bi->bi_parent,\r\n0);\r\ncheck_internal(cur_bi->bi_parent);\r\n}\r\n}\r\nstatic void internal_delete_pointers_items(struct buffer_info *cur_bi,\r\nint first_p,\r\nint first_i, int del_num)\r\n{\r\nstruct buffer_head *cur = cur_bi->bi_bh;\r\nint nr;\r\nstruct block_head *blkh;\r\nstruct reiserfs_key *key;\r\nstruct disk_child *dc;\r\nRFALSE(cur == NULL, "buffer is 0");\r\nRFALSE(del_num < 0,\r\n"negative number of items (%d) can not be deleted", del_num);\r\nRFALSE(first_p < 0 || first_p + del_num > B_NR_ITEMS(cur) + 1\r\n|| first_i < 0,\r\n"first pointer order (%d) < 0 or "\r\n"no so many pointers (%d), only (%d) or "\r\n"first key order %d < 0", first_p, first_p + del_num,\r\nB_NR_ITEMS(cur) + 1, first_i);\r\nif (del_num == 0)\r\nreturn;\r\nblkh = B_BLK_HEAD(cur);\r\nnr = blkh_nr_item(blkh);\r\nif (first_p == 0 && del_num == nr + 1) {\r\nRFALSE(first_i != 0,\r\n"1st deleted key must have order 0, not %d", first_i);\r\nmake_empty_node(cur_bi);\r\nreturn;\r\n}\r\nRFALSE(first_i + del_num > B_NR_ITEMS(cur),\r\n"first_i = %d del_num = %d "\r\n"no so many keys (%d) in the node (%b)(%z)",\r\nfirst_i, del_num, first_i + del_num, cur, cur);\r\ndc = B_N_CHILD(cur, first_p);\r\nmemmove(dc, dc + del_num, (nr + 1 - first_p - del_num) * DC_SIZE);\r\nkey = internal_key(cur, first_i);\r\nmemmove(key, key + del_num,\r\n(nr - first_i - del_num) * KEY_SIZE + (nr + 1 -\r\ndel_num) * DC_SIZE);\r\nset_blkh_nr_item(blkh, blkh_nr_item(blkh) - del_num);\r\nset_blkh_free_space(blkh,\r\nblkh_free_space(blkh) +\r\n(del_num * (KEY_SIZE + DC_SIZE)));\r\ndo_balance_mark_internal_dirty(cur_bi->tb, cur, 0);\r\ncheck_internal(cur);\r\nif (cur_bi->bi_parent) {\r\nstruct disk_child *t_dc;\r\nt_dc = B_N_CHILD(cur_bi->bi_parent, cur_bi->bi_position);\r\nput_dc_size(t_dc,\r\ndc_size(t_dc) - (del_num * (KEY_SIZE + DC_SIZE)));\r\ndo_balance_mark_internal_dirty(cur_bi->tb, cur_bi->bi_parent,\r\n0);\r\ncheck_internal(cur_bi->bi_parent);\r\n}\r\n}\r\nstatic void internal_delete_childs(struct buffer_info *cur_bi, int from, int n)\r\n{\r\nint i_from;\r\ni_from = (from == 0) ? from : from - 1;\r\ninternal_delete_pointers_items(cur_bi, from, i_from, n);\r\n}\r\nstatic void internal_copy_pointers_items(struct buffer_info *dest_bi,\r\nstruct buffer_head *src,\r\nint last_first, int cpy_num)\r\n{\r\nstruct buffer_head *dest = dest_bi->bi_bh;\r\nint nr_dest, nr_src;\r\nint dest_order, src_order;\r\nstruct block_head *blkh;\r\nstruct reiserfs_key *key;\r\nstruct disk_child *dc;\r\nnr_src = B_NR_ITEMS(src);\r\nRFALSE(dest == NULL || src == NULL,\r\n"src (%p) or dest (%p) buffer is 0", src, dest);\r\nRFALSE(last_first != FIRST_TO_LAST && last_first != LAST_TO_FIRST,\r\n"invalid last_first parameter (%d)", last_first);\r\nRFALSE(nr_src < cpy_num - 1,\r\n"no so many items (%d) in src (%d)", cpy_num, nr_src);\r\nRFALSE(cpy_num < 0, "cpy_num less than 0 (%d)", cpy_num);\r\nRFALSE(cpy_num - 1 + B_NR_ITEMS(dest) > (int)MAX_NR_KEY(dest),\r\n"cpy_num (%d) + item number in dest (%d) can not be > MAX_NR_KEY(%d)",\r\ncpy_num, B_NR_ITEMS(dest), MAX_NR_KEY(dest));\r\nif (cpy_num == 0)\r\nreturn;\r\nblkh = B_BLK_HEAD(dest);\r\nnr_dest = blkh_nr_item(blkh);\r\n(last_first == LAST_TO_FIRST) ? (dest_order = 0, src_order =\r\nnr_src - cpy_num + 1) : (dest_order =\r\nnr_dest,\r\nsrc_order =\r\n0);\r\ndc = B_N_CHILD(dest, dest_order);\r\nmemmove(dc + cpy_num, dc, (nr_dest - dest_order) * DC_SIZE);\r\nmemcpy(dc, B_N_CHILD(src, src_order), DC_SIZE * cpy_num);\r\nkey = internal_key(dest, dest_order);\r\nmemmove(key + cpy_num - 1, key,\r\nKEY_SIZE * (nr_dest - dest_order) + DC_SIZE * (nr_dest +\r\ncpy_num));\r\nmemcpy(key, internal_key(src, src_order), KEY_SIZE * (cpy_num - 1));\r\nset_blkh_nr_item(blkh, blkh_nr_item(blkh) + (cpy_num - 1));\r\nset_blkh_free_space(blkh,\r\nblkh_free_space(blkh) - (KEY_SIZE * (cpy_num - 1) +\r\nDC_SIZE * cpy_num));\r\ndo_balance_mark_internal_dirty(dest_bi->tb, dest, 0);\r\ncheck_internal(dest);\r\nif (dest_bi->bi_parent) {\r\nstruct disk_child *t_dc;\r\nt_dc = B_N_CHILD(dest_bi->bi_parent, dest_bi->bi_position);\r\nput_dc_size(t_dc,\r\ndc_size(t_dc) + (KEY_SIZE * (cpy_num - 1) +\r\nDC_SIZE * cpy_num));\r\ndo_balance_mark_internal_dirty(dest_bi->tb, dest_bi->bi_parent,\r\n0);\r\ncheck_internal(dest_bi->bi_parent);\r\n}\r\n}\r\nstatic void internal_move_pointers_items(struct buffer_info *dest_bi,\r\nstruct buffer_info *src_bi,\r\nint last_first, int cpy_num,\r\nint del_par)\r\n{\r\nint first_pointer;\r\nint first_item;\r\ninternal_copy_pointers_items(dest_bi, src_bi->bi_bh, last_first,\r\ncpy_num);\r\nif (last_first == FIRST_TO_LAST) {\r\nfirst_pointer = 0;\r\nfirst_item = 0;\r\ninternal_delete_pointers_items(src_bi, first_pointer,\r\nfirst_item, cpy_num - del_par);\r\n} else {\r\nint i, j;\r\ni = (cpy_num - del_par ==\r\n(j =\r\nB_NR_ITEMS(src_bi->bi_bh)) + 1) ? 0 : j - cpy_num +\r\ndel_par;\r\ninternal_delete_pointers_items(src_bi,\r\nj + 1 - cpy_num + del_par, i,\r\ncpy_num - del_par);\r\n}\r\n}\r\nstatic void internal_insert_key(struct buffer_info *dest_bi,\r\nint dest_position_before,\r\nstruct buffer_head *src, int src_position)\r\n{\r\nstruct buffer_head *dest = dest_bi->bi_bh;\r\nint nr;\r\nstruct block_head *blkh;\r\nstruct reiserfs_key *key;\r\nRFALSE(dest == NULL || src == NULL,\r\n"source(%p) or dest(%p) buffer is 0", src, dest);\r\nRFALSE(dest_position_before < 0 || src_position < 0,\r\n"source(%d) or dest(%d) key number less than 0",\r\nsrc_position, dest_position_before);\r\nRFALSE(dest_position_before > B_NR_ITEMS(dest) ||\r\nsrc_position >= B_NR_ITEMS(src),\r\n"invalid position in dest (%d (key number %d)) or in src (%d (key number %d))",\r\ndest_position_before, B_NR_ITEMS(dest),\r\nsrc_position, B_NR_ITEMS(src));\r\nRFALSE(B_FREE_SPACE(dest) < KEY_SIZE,\r\n"no enough free space (%d) in dest buffer", B_FREE_SPACE(dest));\r\nblkh = B_BLK_HEAD(dest);\r\nnr = blkh_nr_item(blkh);\r\nkey = internal_key(dest, dest_position_before);\r\nmemmove(key + 1, key,\r\n(nr - dest_position_before) * KEY_SIZE + (nr + 1) * DC_SIZE);\r\nmemcpy(key, internal_key(src, src_position), KEY_SIZE);\r\nset_blkh_nr_item(blkh, blkh_nr_item(blkh) + 1);\r\nset_blkh_free_space(blkh, blkh_free_space(blkh) - KEY_SIZE);\r\ndo_balance_mark_internal_dirty(dest_bi->tb, dest, 0);\r\nif (dest_bi->bi_parent) {\r\nstruct disk_child *t_dc;\r\nt_dc = B_N_CHILD(dest_bi->bi_parent, dest_bi->bi_position);\r\nput_dc_size(t_dc, dc_size(t_dc) + KEY_SIZE);\r\ndo_balance_mark_internal_dirty(dest_bi->tb, dest_bi->bi_parent,\r\n0);\r\n}\r\n}\r\nstatic void internal_shift_left(\r\nint mode,\r\nstruct tree_balance *tb,\r\nint h, int pointer_amount)\r\n{\r\nstruct buffer_info dest_bi, src_bi;\r\nstruct buffer_head *cf;\r\nint d_key_position;\r\ninternal_define_dest_src_infos(mode, tb, h, &dest_bi, &src_bi,\r\n&d_key_position, &cf);\r\nif (pointer_amount) {\r\ninternal_insert_key(&dest_bi, B_NR_ITEMS(dest_bi.bi_bh), cf,\r\nd_key_position);\r\nif (B_NR_ITEMS(src_bi.bi_bh) == pointer_amount - 1) {\r\nif (src_bi.bi_position == 0)\r\nreplace_key(tb, cf, d_key_position,\r\nsrc_bi.\r\nbi_parent , 0);\r\n} else\r\nreplace_key(tb, cf, d_key_position, src_bi.bi_bh,\r\npointer_amount - 1);\r\n}\r\ninternal_move_pointers_items(&dest_bi, &src_bi, FIRST_TO_LAST,\r\npointer_amount, 0);\r\n}\r\nstatic void internal_shift1_left(struct tree_balance *tb,\r\nint h, int pointer_amount)\r\n{\r\nstruct buffer_info dest_bi, src_bi;\r\nstruct buffer_head *cf;\r\nint d_key_position;\r\ninternal_define_dest_src_infos(INTERNAL_SHIFT_FROM_S_TO_L, tb, h,\r\n&dest_bi, &src_bi, &d_key_position, &cf);\r\nif (pointer_amount > 0)\r\ninternal_insert_key(&dest_bi, B_NR_ITEMS(dest_bi.bi_bh), cf,\r\nd_key_position);\r\ninternal_move_pointers_items(&dest_bi, &src_bi, FIRST_TO_LAST,\r\npointer_amount, 1);\r\n}\r\nstatic void internal_shift_right(\r\nint mode,\r\nstruct tree_balance *tb,\r\nint h, int pointer_amount)\r\n{\r\nstruct buffer_info dest_bi, src_bi;\r\nstruct buffer_head *cf;\r\nint d_key_position;\r\nint nr;\r\ninternal_define_dest_src_infos(mode, tb, h, &dest_bi, &src_bi,\r\n&d_key_position, &cf);\r\nnr = B_NR_ITEMS(src_bi.bi_bh);\r\nif (pointer_amount > 0) {\r\ninternal_insert_key(&dest_bi, 0, cf, d_key_position);\r\nif (nr == pointer_amount - 1) {\r\nRFALSE(src_bi.bi_bh != PATH_H_PBUFFER(tb->tb_path, h) ||\r\ndest_bi.bi_bh != tb->R[h],\r\n"src (%p) must be == tb->S[h](%p) when it disappears",\r\nsrc_bi.bi_bh, PATH_H_PBUFFER(tb->tb_path, h));\r\nif (tb->CFL[h])\r\nreplace_key(tb, cf, d_key_position, tb->CFL[h],\r\ntb->lkey[h]);\r\n} else\r\nreplace_key(tb, cf, d_key_position, src_bi.bi_bh,\r\nnr - pointer_amount);\r\n}\r\ninternal_move_pointers_items(&dest_bi, &src_bi, LAST_TO_FIRST,\r\npointer_amount, 0);\r\n}\r\nstatic void internal_shift1_right(struct tree_balance *tb,\r\nint h, int pointer_amount)\r\n{\r\nstruct buffer_info dest_bi, src_bi;\r\nstruct buffer_head *cf;\r\nint d_key_position;\r\ninternal_define_dest_src_infos(INTERNAL_SHIFT_FROM_S_TO_R, tb, h,\r\n&dest_bi, &src_bi, &d_key_position, &cf);\r\nif (pointer_amount > 0)\r\ninternal_insert_key(&dest_bi, 0, cf, d_key_position);\r\ninternal_move_pointers_items(&dest_bi, &src_bi, LAST_TO_FIRST,\r\npointer_amount, 1);\r\n}\r\nstatic void balance_internal_when_delete(struct tree_balance *tb,\r\nint h, int child_pos)\r\n{\r\nint insert_num;\r\nint n;\r\nstruct buffer_head *tbSh = PATH_H_PBUFFER(tb->tb_path, h);\r\nstruct buffer_info bi;\r\ninsert_num = tb->insert_size[h] / ((int)(DC_SIZE + KEY_SIZE));\r\nbi.tb = tb;\r\nbi.bi_bh = tbSh;\r\nbi.bi_parent = PATH_H_PPARENT(tb->tb_path, h);\r\nbi.bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\r\ninternal_delete_childs(&bi, child_pos, -insert_num);\r\nRFALSE(tb->blknum[h] > 1,\r\n"tb->blknum[%d]=%d when insert_size < 0", h, tb->blknum[h]);\r\nn = B_NR_ITEMS(tbSh);\r\nif (tb->lnum[h] == 0 && tb->rnum[h] == 0) {\r\nif (tb->blknum[h] == 0) {\r\nstruct buffer_head *new_root;\r\nRFALSE(n\r\n|| B_FREE_SPACE(tbSh) !=\r\nMAX_CHILD_SIZE(tbSh) - DC_SIZE,\r\n"buffer must have only 0 keys (%d)", n);\r\nRFALSE(bi.bi_parent, "root has parent (%p)",\r\nbi.bi_parent);\r\nif (!tb->L[h - 1] || !B_NR_ITEMS(tb->L[h - 1]))\r\nnew_root = tb->R[h - 1];\r\nelse\r\nnew_root = tb->L[h - 1];\r\nPUT_SB_ROOT_BLOCK(tb->tb_sb, new_root->b_blocknr);\r\nPUT_SB_TREE_HEIGHT(tb->tb_sb,\r\nSB_TREE_HEIGHT(tb->tb_sb) - 1);\r\ndo_balance_mark_sb_dirty(tb,\r\nREISERFS_SB(tb->tb_sb)->s_sbh,\r\n1);\r\nif (h > 1)\r\ncheck_internal(new_root);\r\nreiserfs_invalidate_buffer(tb, tbSh);\r\nreturn;\r\n}\r\nreturn;\r\n}\r\nif (tb->L[h] && tb->lnum[h] == -B_NR_ITEMS(tb->L[h]) - 1) {\r\nRFALSE(tb->rnum[h] != 0,\r\n"invalid tb->rnum[%d]==%d when joining S[h] with L[h]",\r\nh, tb->rnum[h]);\r\ninternal_shift_left(INTERNAL_SHIFT_FROM_S_TO_L, tb, h, n + 1);\r\nreiserfs_invalidate_buffer(tb, tbSh);\r\nreturn;\r\n}\r\nif (tb->R[h] && tb->rnum[h] == -B_NR_ITEMS(tb->R[h]) - 1) {\r\nRFALSE(tb->lnum[h] != 0,\r\n"invalid tb->lnum[%d]==%d when joining S[h] with R[h]",\r\nh, tb->lnum[h]);\r\ninternal_shift_right(INTERNAL_SHIFT_FROM_S_TO_R, tb, h, n + 1);\r\nreiserfs_invalidate_buffer(tb, tbSh);\r\nreturn;\r\n}\r\nif (tb->lnum[h] < 0) {\r\nRFALSE(tb->rnum[h] != 0,\r\n"wrong tb->rnum[%d]==%d when borrow from L[h]", h,\r\ntb->rnum[h]);\r\ninternal_shift_right(INTERNAL_SHIFT_FROM_L_TO_S, tb, h,\r\n-tb->lnum[h]);\r\nreturn;\r\n}\r\nif (tb->rnum[h] < 0) {\r\nRFALSE(tb->lnum[h] != 0,\r\n"invalid tb->lnum[%d]==%d when borrow from R[h]",\r\nh, tb->lnum[h]);\r\ninternal_shift_left(INTERNAL_SHIFT_FROM_R_TO_S, tb, h, -tb->rnum[h]);\r\nreturn;\r\n}\r\nif (tb->lnum[h] > 0) {\r\nRFALSE(tb->rnum[h] == 0 || tb->lnum[h] + tb->rnum[h] != n + 1,\r\n"invalid tb->lnum[%d]==%d or tb->rnum[%d]==%d when S[h](item number == %d) is split between them",\r\nh, tb->lnum[h], h, tb->rnum[h], n);\r\ninternal_shift_left(INTERNAL_SHIFT_FROM_S_TO_L, tb, h, tb->lnum[h]);\r\ninternal_shift_right(INTERNAL_SHIFT_FROM_S_TO_R, tb, h,\r\ntb->rnum[h]);\r\nreiserfs_invalidate_buffer(tb, tbSh);\r\nreturn;\r\n}\r\nreiserfs_panic(tb->tb_sb, "ibalance-2",\r\n"unexpected tb->lnum[%d]==%d or tb->rnum[%d]==%d",\r\nh, tb->lnum[h], h, tb->rnum[h]);\r\n}\r\nstatic void replace_lkey(struct tree_balance *tb, int h, struct item_head *key)\r\n{\r\nRFALSE(tb->L[h] == NULL || tb->CFL[h] == NULL,\r\n"L[h](%p) and CFL[h](%p) must exist in replace_lkey",\r\ntb->L[h], tb->CFL[h]);\r\nif (B_NR_ITEMS(PATH_H_PBUFFER(tb->tb_path, h)) == 0)\r\nreturn;\r\nmemcpy(internal_key(tb->CFL[h], tb->lkey[h]), key, KEY_SIZE);\r\ndo_balance_mark_internal_dirty(tb, tb->CFL[h], 0);\r\n}\r\nstatic void replace_rkey(struct tree_balance *tb, int h, struct item_head *key)\r\n{\r\nRFALSE(tb->R[h] == NULL || tb->CFR[h] == NULL,\r\n"R[h](%p) and CFR[h](%p) must exist in replace_rkey",\r\ntb->R[h], tb->CFR[h]);\r\nRFALSE(B_NR_ITEMS(tb->R[h]) == 0,\r\n"R[h] can not be empty if it exists (item number=%d)",\r\nB_NR_ITEMS(tb->R[h]));\r\nmemcpy(internal_key(tb->CFR[h], tb->rkey[h]), key, KEY_SIZE);\r\ndo_balance_mark_internal_dirty(tb, tb->CFR[h], 0);\r\n}\r\nint balance_internal(struct tree_balance *tb,\r\nint h,\r\nint child_pos,\r\nstruct item_head *insert_key,\r\nstruct buffer_head **insert_ptr)\r\n{\r\nstruct buffer_head *tbSh = PATH_H_PBUFFER(tb->tb_path, h);\r\nstruct buffer_info bi;\r\nint order;\r\nint insert_num, n, k;\r\nstruct buffer_head *S_new;\r\nstruct item_head new_insert_key;\r\nstruct buffer_head *new_insert_ptr = NULL;\r\nstruct item_head *new_insert_key_addr = insert_key;\r\nRFALSE(h < 1, "h (%d) can not be < 1 on internal level", h);\r\nPROC_INFO_INC(tb->tb_sb, balance_at[h]);\r\norder =\r\n(tbSh) ? PATH_H_POSITION(tb->tb_path,\r\nh + 1) : 0;\r\ninsert_num = tb->insert_size[h] / ((int)(KEY_SIZE + DC_SIZE));\r\nRFALSE(insert_num < -2 || insert_num > 2,\r\n"incorrect number of items inserted to the internal node (%d)",\r\ninsert_num);\r\nRFALSE(h > 1 && (insert_num > 1 || insert_num < -1),\r\n"incorrect number of items (%d) inserted to the internal node on a level (h=%d) higher than last internal level",\r\ninsert_num, h);\r\nif (insert_num < 0) {\r\nbalance_internal_when_delete(tb, h, child_pos);\r\nreturn order;\r\n}\r\nk = 0;\r\nif (tb->lnum[h] > 0) {\r\nn = B_NR_ITEMS(tb->L[h]);\r\nif (tb->lnum[h] <= child_pos) {\r\ninternal_shift_left(INTERNAL_SHIFT_FROM_S_TO_L, tb, h,\r\ntb->lnum[h]);\r\nchild_pos -= tb->lnum[h];\r\n} else if (tb->lnum[h] > child_pos + insert_num) {\r\ninternal_shift_left(INTERNAL_SHIFT_FROM_S_TO_L, tb, h,\r\ntb->lnum[h] - insert_num);\r\nbi.tb = tb;\r\nbi.bi_bh = tb->L[h];\r\nbi.bi_parent = tb->FL[h];\r\nbi.bi_position = get_left_neighbor_position(tb, h);\r\ninternal_insert_childs(&bi,\r\nn + child_pos + 1,\r\ninsert_num, insert_key,\r\ninsert_ptr);\r\ninsert_num = 0;\r\n} else {\r\nstruct disk_child *dc;\r\ninternal_shift1_left(tb, h, child_pos + 1);\r\nk = tb->lnum[h] - child_pos - 1;\r\nbi.tb = tb;\r\nbi.bi_bh = tb->L[h];\r\nbi.bi_parent = tb->FL[h];\r\nbi.bi_position = get_left_neighbor_position(tb, h);\r\ninternal_insert_childs(&bi,\r\nn + child_pos + 1, k,\r\ninsert_key, insert_ptr);\r\nreplace_lkey(tb, h, insert_key + k);\r\ndc = B_N_CHILD(tbSh, 0);\r\nput_dc_size(dc,\r\nMAX_CHILD_SIZE(insert_ptr[k]) -\r\nB_FREE_SPACE(insert_ptr[k]));\r\nput_dc_block_number(dc, insert_ptr[k]->b_blocknr);\r\ndo_balance_mark_internal_dirty(tb, tbSh, 0);\r\nk++;\r\ninsert_key += k;\r\ninsert_ptr += k;\r\ninsert_num -= k;\r\nchild_pos = 0;\r\n}\r\n}\r\nif (tb->rnum[h] > 0) {\r\nn = B_NR_ITEMS(tbSh);\r\nif (n - tb->rnum[h] >= child_pos)\r\ninternal_shift_right(INTERNAL_SHIFT_FROM_S_TO_R, tb, h,\r\ntb->rnum[h]);\r\nelse if (n + insert_num - tb->rnum[h] < child_pos) {\r\ninternal_shift_right(INTERNAL_SHIFT_FROM_S_TO_R, tb, h,\r\ntb->rnum[h] - insert_num);\r\nbi.tb = tb;\r\nbi.bi_bh = tb->R[h];\r\nbi.bi_parent = tb->FR[h];\r\nbi.bi_position = get_right_neighbor_position(tb, h);\r\ninternal_insert_childs(&bi,\r\nchild_pos - n - insert_num +\r\ntb->rnum[h] - 1,\r\ninsert_num, insert_key,\r\ninsert_ptr);\r\ninsert_num = 0;\r\n} else {\r\nstruct disk_child *dc;\r\ninternal_shift1_right(tb, h, n - child_pos + 1);\r\nk = tb->rnum[h] - n + child_pos - 1;\r\nbi.tb = tb;\r\nbi.bi_bh = tb->R[h];\r\nbi.bi_parent = tb->FR[h];\r\nbi.bi_position = get_right_neighbor_position(tb, h);\r\ninternal_insert_childs(&bi,\r\n0, k, insert_key + 1,\r\ninsert_ptr + 1);\r\nreplace_rkey(tb, h, insert_key + insert_num - k - 1);\r\ndc = B_N_CHILD(tb->R[h], 0);\r\nput_dc_size(dc,\r\nMAX_CHILD_SIZE(insert_ptr\r\n[insert_num - k - 1]) -\r\nB_FREE_SPACE(insert_ptr\r\n[insert_num - k - 1]));\r\nput_dc_block_number(dc,\r\ninsert_ptr[insert_num - k -\r\n1]->b_blocknr);\r\ndo_balance_mark_internal_dirty(tb, tb->R[h], 0);\r\ninsert_num -= (k + 1);\r\n}\r\n}\r\nRFALSE(tb->blknum[h] > 2, "blknum can not be > 2 for internal level");\r\nRFALSE(tb->blknum[h] < 0, "blknum can not be < 0");\r\nif (!tb->blknum[h]) {\r\nRFALSE(!tbSh, "S[h] is equal NULL");\r\nreiserfs_invalidate_buffer(tb, tbSh);\r\nreturn order;\r\n}\r\nif (!tbSh) {\r\nstruct disk_child *dc;\r\nstruct buffer_head *tbSh_1 = PATH_H_PBUFFER(tb->tb_path, h - 1);\r\nstruct block_head *blkh;\r\nif (tb->blknum[h] != 1)\r\nreiserfs_panic(NULL, "ibalance-3", "One new node "\r\n"required for creating the new root");\r\ntbSh = get_FEB(tb);\r\nblkh = B_BLK_HEAD(tbSh);\r\nset_blkh_level(blkh, h + 1);\r\ndc = B_N_CHILD(tbSh, 0);\r\nput_dc_block_number(dc, tbSh_1->b_blocknr);\r\nput_dc_size(dc,\r\n(MAX_CHILD_SIZE(tbSh_1) - B_FREE_SPACE(tbSh_1)));\r\ntb->insert_size[h] -= DC_SIZE;\r\nset_blkh_free_space(blkh, blkh_free_space(blkh) - DC_SIZE);\r\ndo_balance_mark_internal_dirty(tb, tbSh, 0);\r\ncheck_internal(tbSh);\r\nPATH_OFFSET_PBUFFER(tb->tb_path, ILLEGAL_PATH_ELEMENT_OFFSET) =\r\ntbSh;\r\nPUT_SB_ROOT_BLOCK(tb->tb_sb, tbSh->b_blocknr);\r\nPUT_SB_TREE_HEIGHT(tb->tb_sb, SB_TREE_HEIGHT(tb->tb_sb) + 1);\r\ndo_balance_mark_sb_dirty(tb, REISERFS_SB(tb->tb_sb)->s_sbh, 1);\r\n}\r\nif (tb->blknum[h] == 2) {\r\nint snum;\r\nstruct buffer_info dest_bi, src_bi;\r\nS_new = get_FEB(tb);\r\nset_blkh_level(B_BLK_HEAD(S_new), h + 1);\r\ndest_bi.tb = tb;\r\ndest_bi.bi_bh = S_new;\r\ndest_bi.bi_parent = NULL;\r\ndest_bi.bi_position = 0;\r\nsrc_bi.tb = tb;\r\nsrc_bi.bi_bh = tbSh;\r\nsrc_bi.bi_parent = PATH_H_PPARENT(tb->tb_path, h);\r\nsrc_bi.bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\r\nn = B_NR_ITEMS(tbSh);\r\nsnum = (insert_num + n + 1) / 2;\r\nif (n - snum >= child_pos) {\r\nmemcpy(&new_insert_key, internal_key(tbSh, n - snum),\r\nKEY_SIZE);\r\ninternal_move_pointers_items(&dest_bi, &src_bi,\r\nLAST_TO_FIRST, snum, 0);\r\n} else if (n + insert_num - snum < child_pos) {\r\nmemcpy(&new_insert_key,\r\ninternal_key(tbSh, n + insert_num - snum),\r\nKEY_SIZE);\r\ninternal_move_pointers_items(&dest_bi, &src_bi,\r\nLAST_TO_FIRST,\r\nsnum - insert_num, 0);\r\ninternal_insert_childs(&dest_bi,\r\nchild_pos - n - insert_num +\r\nsnum - 1,\r\ninsert_num, insert_key,\r\ninsert_ptr);\r\ninsert_num = 0;\r\n} else {\r\nstruct disk_child *dc;\r\ninternal_move_pointers_items(&dest_bi, &src_bi,\r\nLAST_TO_FIRST,\r\nn - child_pos + 1, 1);\r\nk = snum - n + child_pos - 1;\r\ninternal_insert_childs(&dest_bi, 0, k,\r\ninsert_key + 1, insert_ptr + 1);\r\nmemcpy(&new_insert_key, insert_key + insert_num - k - 1,\r\nKEY_SIZE);\r\ndc = B_N_CHILD(S_new, 0);\r\nput_dc_size(dc,\r\n(MAX_CHILD_SIZE\r\n(insert_ptr[insert_num - k - 1]) -\r\nB_FREE_SPACE(insert_ptr\r\n[insert_num - k - 1])));\r\nput_dc_block_number(dc,\r\ninsert_ptr[insert_num - k -\r\n1]->b_blocknr);\r\ndo_balance_mark_internal_dirty(tb, S_new, 0);\r\ninsert_num -= (k + 1);\r\n}\r\nnew_insert_ptr = S_new;\r\nRFALSE(!buffer_journaled(S_new) || buffer_journal_dirty(S_new)\r\n|| buffer_dirty(S_new), "cm-00001: bad S_new (%b)",\r\nS_new);\r\n}\r\nn = B_NR_ITEMS(tbSh);\r\nif (0 <= child_pos && child_pos <= n && insert_num > 0) {\r\nbi.tb = tb;\r\nbi.bi_bh = tbSh;\r\nbi.bi_parent = PATH_H_PPARENT(tb->tb_path, h);\r\nbi.bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\r\ninternal_insert_childs(&bi,\r\nchild_pos, insert_num, insert_key,\r\ninsert_ptr);\r\n}\r\ninsert_ptr[0] = new_insert_ptr;\r\nif (new_insert_ptr)\r\nmemcpy(new_insert_key_addr, &new_insert_key, KEY_SIZE);\r\nreturn order;\r\n}
