static inline struct mps2_uart_port *to_mps2_port(struct uart_port *port)\r\n{\r\nreturn container_of(port, struct mps2_uart_port, port);\r\n}\r\nstatic void mps2_uart_write8(struct uart_port *port, u8 val, unsigned int off)\r\n{\r\nstruct mps2_uart_port *mps_port = to_mps2_port(port);\r\nwriteb(val, mps_port->port.membase + off);\r\n}\r\nstatic u8 mps2_uart_read8(struct uart_port *port, unsigned int off)\r\n{\r\nstruct mps2_uart_port *mps_port = to_mps2_port(port);\r\nreturn readb(mps_port->port.membase + off);\r\n}\r\nstatic void mps2_uart_write32(struct uart_port *port, u32 val, unsigned int off)\r\n{\r\nstruct mps2_uart_port *mps_port = to_mps2_port(port);\r\nwritel_relaxed(val, mps_port->port.membase + off);\r\n}\r\nstatic unsigned int mps2_uart_tx_empty(struct uart_port *port)\r\n{\r\nu8 status = mps2_uart_read8(port, UARTn_STATE);\r\nreturn (status & UARTn_STATE_TX_FULL) ? 0 : TIOCSER_TEMT;\r\n}\r\nstatic void mps2_uart_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\n}\r\nstatic unsigned int mps2_uart_get_mctrl(struct uart_port *port)\r\n{\r\nreturn TIOCM_CAR | TIOCM_CTS | TIOCM_DSR;\r\n}\r\nstatic void mps2_uart_stop_tx(struct uart_port *port)\r\n{\r\nu8 control = mps2_uart_read8(port, UARTn_CTRL);\r\ncontrol &= ~UARTn_CTRL_TX_INT_ENABLE;\r\nmps2_uart_write8(port, control, UARTn_CTRL);\r\n}\r\nstatic void mps2_uart_tx_chars(struct uart_port *port)\r\n{\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nwhile (!(mps2_uart_read8(port, UARTn_STATE) & UARTn_STATE_TX_FULL)) {\r\nif (port->x_char) {\r\nmps2_uart_write8(port, port->x_char, UARTn_DATA);\r\nport->x_char = 0;\r\nport->icount.tx++;\r\ncontinue;\r\n}\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(port))\r\nbreak;\r\nmps2_uart_write8(port, xmit->buf[xmit->tail], UARTn_DATA);\r\nxmit->tail = (xmit->tail + 1) % UART_XMIT_SIZE;\r\nport->icount.tx++;\r\n}\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\nif (uart_circ_empty(xmit))\r\nmps2_uart_stop_tx(port);\r\n}\r\nstatic void mps2_uart_start_tx(struct uart_port *port)\r\n{\r\nu8 control = mps2_uart_read8(port, UARTn_CTRL);\r\ncontrol |= UARTn_CTRL_TX_INT_ENABLE;\r\nmps2_uart_write8(port, control, UARTn_CTRL);\r\nmps2_uart_tx_chars(port);\r\n}\r\nstatic void mps2_uart_stop_rx(struct uart_port *port)\r\n{\r\nu8 control = mps2_uart_read8(port, UARTn_CTRL);\r\ncontrol &= ~UARTn_CTRL_RX_GRP;\r\nmps2_uart_write8(port, control, UARTn_CTRL);\r\n}\r\nstatic void mps2_uart_break_ctl(struct uart_port *port, int ctl)\r\n{\r\n}\r\nstatic void mps2_uart_rx_chars(struct uart_port *port)\r\n{\r\nstruct tty_port *tport = &port->state->port;\r\nwhile (mps2_uart_read8(port, UARTn_STATE) & UARTn_STATE_RX_FULL) {\r\nu8 rxdata = mps2_uart_read8(port, UARTn_DATA);\r\nport->icount.rx++;\r\ntty_insert_flip_char(&port->state->port, rxdata, TTY_NORMAL);\r\n}\r\ntty_flip_buffer_push(tport);\r\n}\r\nstatic irqreturn_t mps2_uart_rxirq(int irq, void *data)\r\n{\r\nstruct uart_port *port = data;\r\nu8 irqflag = mps2_uart_read8(port, UARTn_INT);\r\nif (unlikely(!(irqflag & UARTn_INT_RX)))\r\nreturn IRQ_NONE;\r\nspin_lock(&port->lock);\r\nmps2_uart_write8(port, UARTn_INT_RX, UARTn_INT);\r\nmps2_uart_rx_chars(port);\r\nspin_unlock(&port->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t mps2_uart_txirq(int irq, void *data)\r\n{\r\nstruct uart_port *port = data;\r\nu8 irqflag = mps2_uart_read8(port, UARTn_INT);\r\nif (unlikely(!(irqflag & UARTn_INT_TX)))\r\nreturn IRQ_NONE;\r\nspin_lock(&port->lock);\r\nmps2_uart_write8(port, UARTn_INT_TX, UARTn_INT);\r\nmps2_uart_tx_chars(port);\r\nspin_unlock(&port->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t mps2_uart_oerrirq(int irq, void *data)\r\n{\r\nirqreturn_t handled = IRQ_NONE;\r\nstruct uart_port *port = data;\r\nu8 irqflag = mps2_uart_read8(port, UARTn_INT);\r\nspin_lock(&port->lock);\r\nif (irqflag & UARTn_INT_RX_OVERRUN) {\r\nstruct tty_port *tport = &port->state->port;\r\nmps2_uart_write8(port, UARTn_INT_RX_OVERRUN, UARTn_INT);\r\nport->icount.overrun++;\r\ntty_insert_flip_char(tport, 0, TTY_OVERRUN);\r\ntty_flip_buffer_push(tport);\r\nhandled = IRQ_HANDLED;\r\n}\r\nif (irqflag & UARTn_INT_TX_OVERRUN) {\r\nmps2_uart_write8(port, UARTn_INT_TX_OVERRUN, UARTn_INT);\r\nhandled = IRQ_HANDLED;\r\n}\r\nspin_unlock(&port->lock);\r\nreturn handled;\r\n}\r\nstatic int mps2_uart_startup(struct uart_port *port)\r\n{\r\nstruct mps2_uart_port *mps_port = to_mps2_port(port);\r\nu8 control = mps2_uart_read8(port, UARTn_CTRL);\r\nint ret;\r\ncontrol &= ~(UARTn_CTRL_RX_GRP | UARTn_CTRL_TX_GRP);\r\nmps2_uart_write8(port, control, UARTn_CTRL);\r\nret = request_irq(mps_port->rx_irq, mps2_uart_rxirq, 0,\r\nMAKE_NAME(-rx), mps_port);\r\nif (ret) {\r\ndev_err(port->dev, "failed to register rxirq (%d)\n", ret);\r\nreturn ret;\r\n}\r\nret = request_irq(mps_port->tx_irq, mps2_uart_txirq, 0,\r\nMAKE_NAME(-tx), mps_port);\r\nif (ret) {\r\ndev_err(port->dev, "failed to register txirq (%d)\n", ret);\r\ngoto err_free_rxirq;\r\n}\r\nret = request_irq(port->irq, mps2_uart_oerrirq, IRQF_SHARED,\r\nMAKE_NAME(-overrun), mps_port);\r\nif (ret) {\r\ndev_err(port->dev, "failed to register oerrirq (%d)\n", ret);\r\ngoto err_free_txirq;\r\n}\r\ncontrol |= UARTn_CTRL_RX_GRP | UARTn_CTRL_TX_GRP;\r\nmps2_uart_write8(port, control, UARTn_CTRL);\r\nreturn 0;\r\nerr_free_txirq:\r\nfree_irq(mps_port->tx_irq, mps_port);\r\nerr_free_rxirq:\r\nfree_irq(mps_port->rx_irq, mps_port);\r\nreturn ret;\r\n}\r\nstatic void mps2_uart_shutdown(struct uart_port *port)\r\n{\r\nstruct mps2_uart_port *mps_port = to_mps2_port(port);\r\nu8 control = mps2_uart_read8(port, UARTn_CTRL);\r\ncontrol &= ~(UARTn_CTRL_RX_GRP | UARTn_CTRL_TX_GRP);\r\nmps2_uart_write8(port, control, UARTn_CTRL);\r\nfree_irq(mps_port->rx_irq, mps_port);\r\nfree_irq(mps_port->tx_irq, mps_port);\r\nfree_irq(port->irq, mps_port);\r\n}\r\nstatic void\r\nmps2_uart_set_termios(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nunsigned long flags;\r\nunsigned int baud, bauddiv;\r\ntermios->c_cflag &= ~(CRTSCTS | CMSPAR);\r\ntermios->c_cflag &= ~CSIZE;\r\ntermios->c_cflag |= CS8;\r\ntermios->c_cflag &= ~PARENB;\r\ntermios->c_cflag &= ~CSTOPB;\r\nbaud = uart_get_baud_rate(port, termios, old,\r\nDIV_ROUND_CLOSEST(port->uartclk, UARTn_BAUDDIV_MASK),\r\nDIV_ROUND_CLOSEST(port->uartclk, 16));\r\nbauddiv = DIV_ROUND_CLOSEST(port->uartclk, baud);\r\nspin_lock_irqsave(&port->lock, flags);\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nmps2_uart_write32(port, bauddiv, UARTn_BAUDDIV);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nif (tty_termios_baud_rate(termios))\r\ntty_termios_encode_baud_rate(termios, baud, baud);\r\n}\r\nstatic const char *mps2_uart_type(struct uart_port *port)\r\n{\r\nreturn (port->type == PORT_MPS2UART) ? DRIVER_NAME : NULL;\r\n}\r\nstatic void mps2_uart_release_port(struct uart_port *port)\r\n{\r\n}\r\nstatic int mps2_uart_request_port(struct uart_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void mps2_uart_config_port(struct uart_port *port, int type)\r\n{\r\nif (type & UART_CONFIG_TYPE && !mps2_uart_request_port(port))\r\nport->type = PORT_MPS2UART;\r\n}\r\nstatic int mps2_uart_verify_port(struct uart_port *port, struct serial_struct *serinfo)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic void mps2_uart_console_putchar(struct uart_port *port, int ch)\r\n{\r\nwhile (mps2_uart_read8(port, UARTn_STATE) & UARTn_STATE_TX_FULL)\r\ncpu_relax();\r\nmps2_uart_write8(port, ch, UARTn_DATA);\r\n}\r\nstatic void mps2_uart_console_write(struct console *co, const char *s, unsigned int cnt)\r\n{\r\nstruct uart_port *port = &mps2_uart_ports[co->index].port;\r\nuart_console_write(port, s, cnt, mps2_uart_console_putchar);\r\n}\r\nstatic int mps2_uart_console_setup(struct console *co, char *options)\r\n{\r\nstruct mps2_uart_port *mps_port;\r\nint baud = 9600;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nif (co->index < 0 || co->index >= MPS2_MAX_PORTS)\r\nreturn -ENODEV;\r\nmps_port = &mps2_uart_ports[co->index];\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nreturn uart_set_options(&mps_port->port, co, baud, parity, bits, flow);\r\n}\r\nstatic void mps2_early_putchar(struct uart_port *port, int ch)\r\n{\r\nwhile (readb(port->membase + UARTn_STATE) & UARTn_STATE_TX_FULL)\r\ncpu_relax();\r\nwriteb((unsigned char)ch, port->membase + UARTn_DATA);\r\n}\r\nstatic void mps2_early_write(struct console *con, const char *s, unsigned int n)\r\n{\r\nstruct earlycon_device *dev = con->data;\r\nuart_console_write(&dev->port, s, n, mps2_early_putchar);\r\n}\r\nstatic int __init mps2_early_console_setup(struct earlycon_device *device,\r\nconst char *opt)\r\n{\r\nif (!device->port.membase)\r\nreturn -ENODEV;\r\ndevice->con->write = mps2_early_write;\r\nreturn 0;\r\n}\r\nstatic struct mps2_uart_port *mps2_of_get_port(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nint id;\r\nif (!np)\r\nreturn NULL;\r\nid = of_alias_get_id(np, "serial");\r\nif (id < 0)\r\nid = 0;\r\nif (WARN_ON(id >= MPS2_MAX_PORTS))\r\nreturn NULL;\r\nmps2_uart_ports[id].port.line = id;\r\nreturn &mps2_uart_ports[id];\r\n}\r\nstatic int mps2_init_port(struct mps2_uart_port *mps_port,\r\nstruct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nint ret;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nmps_port->port.membase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(mps_port->port.membase))\r\nreturn PTR_ERR(mps_port->port.membase);\r\nmps_port->port.mapbase = res->start;\r\nmps_port->port.mapsize = resource_size(res);\r\nmps_port->rx_irq = platform_get_irq(pdev, 0);\r\nmps_port->tx_irq = platform_get_irq(pdev, 1);\r\nmps_port->port.irq = platform_get_irq(pdev, 2);\r\nmps_port->port.iotype = UPIO_MEM;\r\nmps_port->port.flags = UPF_BOOT_AUTOCONF;\r\nmps_port->port.fifosize = 1;\r\nmps_port->port.ops = &mps2_uart_pops;\r\nmps_port->port.dev = &pdev->dev;\r\nmps_port->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(mps_port->clk))\r\nreturn PTR_ERR(mps_port->clk);\r\nret = clk_prepare_enable(mps_port->clk);\r\nif (ret)\r\nreturn ret;\r\nmps_port->port.uartclk = clk_get_rate(mps_port->clk);\r\nclk_disable_unprepare(mps_port->clk);\r\nreturn ret;\r\n}\r\nstatic int mps2_serial_probe(struct platform_device *pdev)\r\n{\r\nstruct mps2_uart_port *mps_port;\r\nint ret;\r\nmps_port = mps2_of_get_port(pdev);\r\nif (!mps_port)\r\nreturn -ENODEV;\r\nret = mps2_init_port(mps_port, pdev);\r\nif (ret)\r\nreturn ret;\r\nret = uart_add_one_port(&mps2_uart_driver, &mps_port->port);\r\nif (ret)\r\nreturn ret;\r\nplatform_set_drvdata(pdev, mps_port);\r\nreturn 0;\r\n}\r\nstatic int __init mps2_uart_init(void)\r\n{\r\nint ret;\r\nret = uart_register_driver(&mps2_uart_driver);\r\nif (ret)\r\nreturn ret;\r\nret = platform_driver_register(&mps2_serial_driver);\r\nif (ret)\r\nuart_unregister_driver(&mps2_uart_driver);\r\nreturn ret;\r\n}
