static int cortina_read_reg(struct phy_device *phydev, u16 regnum)\r\n{\r\nreturn mdiobus_read(phydev->mdio.bus, phydev->mdio.addr,\r\nMII_ADDR_C45 | regnum);\r\n}\r\nstatic int cortina_config_aneg(struct phy_device *phydev)\r\n{\r\nphydev->supported = SUPPORTED_10000baseT_Full;\r\nphydev->advertising = SUPPORTED_10000baseT_Full;\r\nreturn 0;\r\n}\r\nstatic int cortina_read_status(struct phy_device *phydev)\r\n{\r\nint gpio_int_status, ret = 0;\r\ngpio_int_status = cortina_read_reg(phydev, VILLA_GLOBAL_GPIO_1_INTS);\r\nif (gpio_int_status < 0) {\r\nret = gpio_int_status;\r\ngoto err;\r\n}\r\nif (gpio_int_status & 0x8) {\r\nphydev->speed = SPEED_10000;\r\nphydev->duplex = DUPLEX_FULL;\r\nphydev->link = 1;\r\n} else {\r\nphydev->link = 0;\r\n}\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int cortina_soft_reset(struct phy_device *phydev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cortina_probe(struct phy_device *phydev)\r\n{\r\nu32 phy_id = 0;\r\nint id_lsb = 0, id_msb = 0;\r\nid_lsb = cortina_read_reg(phydev, VILLA_GLOBAL_CHIP_ID_LSB);\r\nif (id_lsb < 0)\r\nreturn -ENXIO;\r\nphy_id = id_lsb << 16;\r\nid_msb = cortina_read_reg(phydev, VILLA_GLOBAL_CHIP_ID_MSB);\r\nif (id_msb < 0)\r\nreturn -ENXIO;\r\nphy_id |= id_msb;\r\nif (phy_id != phydev->drv->phy_id) {\r\nphydev_err(phydev, "Error matching phy with %s driver\n",\r\nphydev->drv->name);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}
