static struct atomisp_acc_fw *acc_alloc_fw(unsigned int fw_size)\r\n{\r\nstruct atomisp_acc_fw *acc_fw;\r\nacc_fw = kzalloc(sizeof(*acc_fw), GFP_KERNEL);\r\nif (!acc_fw)\r\nreturn NULL;\r\nacc_fw->fw = vmalloc(fw_size);\r\nif (!acc_fw->fw) {\r\nkfree(acc_fw);\r\nreturn NULL;\r\n}\r\nreturn acc_fw;\r\n}\r\nstatic void acc_free_fw(struct atomisp_acc_fw *acc_fw)\r\n{\r\nvfree(acc_fw->fw);\r\nkfree(acc_fw);\r\n}\r\nstatic struct atomisp_acc_fw *\r\nacc_get_fw(struct atomisp_sub_device *asd, unsigned int handle)\r\n{\r\nstruct atomisp_acc_fw *acc_fw;\r\nlist_for_each_entry(acc_fw, &asd->acc.fw, list)\r\nif (acc_fw->handle == handle)\r\nreturn acc_fw;\r\nreturn NULL;\r\n}\r\nstatic struct atomisp_map *acc_get_map(struct atomisp_sub_device *asd,\r\nunsigned long css_ptr, size_t length)\r\n{\r\nstruct atomisp_map *atomisp_map;\r\nlist_for_each_entry(atomisp_map, &asd->acc.memory_maps, list) {\r\nif (atomisp_map->ptr == css_ptr &&\r\natomisp_map->length == length)\r\nreturn atomisp_map;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int acc_stop_acceleration(struct atomisp_sub_device *asd)\r\n{\r\nint ret;\r\nret = atomisp_css_stop_acc_pipe(asd);\r\natomisp_css_destroy_acc_pipe(asd);\r\nreturn ret;\r\n}\r\nvoid atomisp_acc_cleanup(struct atomisp_device *isp)\r\n{\r\nint i;\r\nfor (i = 0; i < isp->num_of_streams; i++)\r\nida_destroy(&isp->asd[i].acc.ida);\r\n}\r\nvoid atomisp_acc_release(struct atomisp_sub_device *asd)\r\n{\r\nstruct atomisp_acc_fw *acc_fw, *ta;\r\nstruct atomisp_map *atomisp_map, *tm;\r\nif (asd->acc.pipeline)\r\nacc_stop_acceleration(asd);\r\nlist_for_each_entry_safe(acc_fw, ta, &asd->acc.fw, list) {\r\nlist_del(&acc_fw->list);\r\nida_remove(&asd->acc.ida, acc_fw->handle);\r\nacc_free_fw(acc_fw);\r\n}\r\nlist_for_each_entry_safe(atomisp_map, tm, &asd->acc.memory_maps, list) {\r\nlist_del(&atomisp_map->list);\r\nhmm_free(atomisp_map->ptr);\r\nkfree(atomisp_map);\r\n}\r\n}\r\nint atomisp_acc_load_to_pipe(struct atomisp_sub_device *asd,\r\nstruct atomisp_acc_fw_load_to_pipe *user_fw)\r\n{\r\nstatic const unsigned int pipeline_flags =\r\nATOMISP_ACC_FW_LOAD_FL_PREVIEW | ATOMISP_ACC_FW_LOAD_FL_COPY |\r\nATOMISP_ACC_FW_LOAD_FL_VIDEO |\r\nATOMISP_ACC_FW_LOAD_FL_CAPTURE | ATOMISP_ACC_FW_LOAD_FL_ACC;\r\nstruct atomisp_acc_fw *acc_fw;\r\nint handle;\r\nif (!user_fw->data || user_fw->size < sizeof(*acc_fw->fw))\r\nreturn -EINVAL;\r\nif (!(user_fw->flags & pipeline_flags))\r\nreturn -EINVAL;\r\nif (user_fw->flags & ~pipeline_flags)\r\nreturn -EINVAL;\r\nif (user_fw->type < ATOMISP_ACC_FW_LOAD_TYPE_OUTPUT ||\r\nuser_fw->type > ATOMISP_ACC_FW_LOAD_TYPE_STANDALONE)\r\nreturn -EINVAL;\r\nif (asd->acc.pipeline || asd->acc.extension_mode)\r\nreturn -EBUSY;\r\nacc_fw = acc_alloc_fw(user_fw->size);\r\nif (!acc_fw)\r\nreturn -ENOMEM;\r\nif (copy_from_user(acc_fw->fw, user_fw->data, user_fw->size)) {\r\nacc_free_fw(acc_fw);\r\nreturn -EFAULT;\r\n}\r\nif (!ida_pre_get(&asd->acc.ida, GFP_KERNEL) ||\r\nida_get_new_above(&asd->acc.ida, 1, &handle)) {\r\nacc_free_fw(acc_fw);\r\nreturn -ENOSPC;\r\n}\r\nuser_fw->fw_handle = handle;\r\nacc_fw->handle = handle;\r\nacc_fw->flags = user_fw->flags;\r\nacc_fw->type = user_fw->type;\r\nacc_fw->fw->handle = handle;\r\nif (acc_fw->fw->type == ia_css_isp_firmware) {\r\nstatic const int type_to_css[] = {\r\n[ATOMISP_ACC_FW_LOAD_TYPE_OUTPUT] =\r\nIA_CSS_ACC_OUTPUT,\r\n[ATOMISP_ACC_FW_LOAD_TYPE_VIEWFINDER] =\r\nIA_CSS_ACC_VIEWFINDER,\r\n[ATOMISP_ACC_FW_LOAD_TYPE_STANDALONE] =\r\nIA_CSS_ACC_STANDALONE,\r\n};\r\nacc_fw->fw->info.isp.type = type_to_css[acc_fw->type];\r\n}\r\nlist_add_tail(&acc_fw->list, &asd->acc.fw);\r\nreturn 0;\r\n}\r\nint atomisp_acc_load(struct atomisp_sub_device *asd,\r\nstruct atomisp_acc_fw_load *user_fw)\r\n{\r\nstruct atomisp_acc_fw_load_to_pipe ltp = {0};\r\nint r;\r\nltp.flags = ATOMISP_ACC_FW_LOAD_FL_ACC;\r\nltp.type = ATOMISP_ACC_FW_LOAD_TYPE_STANDALONE;\r\nltp.size = user_fw->size;\r\nltp.data = user_fw->data;\r\nr = atomisp_acc_load_to_pipe(asd, &ltp);\r\nuser_fw->fw_handle = ltp.fw_handle;\r\nreturn r;\r\n}\r\nint atomisp_acc_unload(struct atomisp_sub_device *asd, unsigned int *handle)\r\n{\r\nstruct atomisp_acc_fw *acc_fw;\r\nif (asd->acc.pipeline || asd->acc.extension_mode)\r\nreturn -EBUSY;\r\nacc_fw = acc_get_fw(asd, *handle);\r\nif (!acc_fw)\r\nreturn -EINVAL;\r\nlist_del(&acc_fw->list);\r\nida_remove(&asd->acc.ida, acc_fw->handle);\r\nacc_free_fw(acc_fw);\r\nreturn 0;\r\n}\r\nint atomisp_acc_start(struct atomisp_sub_device *asd, unsigned int *handle)\r\n{\r\nstruct atomisp_device *isp = asd->isp;\r\nstruct atomisp_acc_fw *acc_fw;\r\nint ret;\r\nunsigned int nbin;\r\nif (asd->acc.pipeline || asd->acc.extension_mode)\r\nreturn -EBUSY;\r\nwbinvd();\r\nret = atomisp_css_create_acc_pipe(asd);\r\nif (ret)\r\nreturn ret;\r\nnbin = 0;\r\nlist_for_each_entry(acc_fw, &asd->acc.fw, list) {\r\nif (*handle != 0 && *handle != acc_fw->handle)\r\ncontinue;\r\nif (acc_fw->type != ATOMISP_ACC_FW_LOAD_TYPE_STANDALONE)\r\ncontinue;\r\nret = atomisp_css_load_acc_binary(asd, acc_fw->fw, nbin);\r\nif (ret < 0) {\r\ndev_err(isp->dev, "acc_load_binary failed\n");\r\ngoto err_stage;\r\n}\r\nret = atomisp_css_set_acc_parameters(acc_fw);\r\nif (ret < 0) {\r\ndev_err(isp->dev, "acc_set_parameters failed\n");\r\ngoto err_stage;\r\n}\r\nnbin++;\r\n}\r\nif (nbin < 1) {\r\ndev_err(isp->dev, "%s: no acc binary available\n", __func__);\r\nret = -EINVAL;\r\ngoto err_stage;\r\n}\r\nret = atomisp_css_start_acc_pipe(asd);\r\nif (ret) {\r\ndev_err(isp->dev, "%s: atomisp_acc_start_acc_pipe failed\n",\r\n__func__);\r\ngoto err_stage;\r\n}\r\nreturn 0;\r\nerr_stage:\r\natomisp_css_destroy_acc_pipe(asd);\r\nreturn ret;\r\n}\r\nint atomisp_acc_wait(struct atomisp_sub_device *asd, unsigned int *handle)\r\n{\r\nstruct atomisp_device *isp = asd->isp;\r\nint ret;\r\nif (!asd->acc.pipeline)\r\nreturn -ENOENT;\r\nif (*handle && !acc_get_fw(asd, *handle))\r\nreturn -EINVAL;\r\nret = atomisp_css_wait_acc_finish(asd);\r\nif (acc_stop_acceleration(asd) == -EIO) {\r\natomisp_reset(isp);\r\nreturn -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nvoid atomisp_acc_done(struct atomisp_sub_device *asd, unsigned int handle)\r\n{\r\nstruct v4l2_event event = { 0 };\r\nevent.type = V4L2_EVENT_ATOMISP_ACC_COMPLETE;\r\nevent.u.frame_sync.frame_sequence = atomic_read(&asd->sequence);\r\nevent.id = handle;\r\nv4l2_event_queue(asd->subdev.devnode, &event);\r\n}\r\nint atomisp_acc_map(struct atomisp_sub_device *asd, struct atomisp_acc_map *map)\r\n{\r\nstruct atomisp_map *atomisp_map;\r\nia_css_ptr cssptr;\r\nint pgnr;\r\nif (map->css_ptr)\r\nreturn -EINVAL;\r\nif (asd->acc.pipeline)\r\nreturn -EBUSY;\r\nif (map->user_ptr) {\r\nif ((unsigned long)map->user_ptr & ~PAGE_MASK) {\r\ndev_err(asd->isp->dev,\r\n"%s: mapped buffer address %p is not page aligned\n",\r\n__func__, map->user_ptr);\r\nreturn -EINVAL;\r\n}\r\npgnr = DIV_ROUND_UP(map->length, PAGE_SIZE);\r\ncssptr = hrt_isp_css_mm_alloc_user_ptr(\r\nmap->length, map->user_ptr,\r\npgnr, HRT_USR_PTR,\r\n(map->flags & ATOMISP_MAP_FLAG_CACHED));\r\n} else {\r\nif (map->flags & ATOMISP_MAP_FLAG_CACHED)\r\ncssptr = hrt_isp_css_mm_calloc_cached(map->length);\r\nelse\r\ncssptr = hrt_isp_css_mm_calloc(map->length);\r\n}\r\nif (!cssptr)\r\nreturn -ENOMEM;\r\natomisp_map = kmalloc(sizeof(*atomisp_map), GFP_KERNEL);\r\nif (!atomisp_map) {\r\nhmm_free(cssptr);\r\nreturn -ENOMEM;\r\n}\r\natomisp_map->ptr = cssptr;\r\natomisp_map->length = map->length;\r\nlist_add(&atomisp_map->list, &asd->acc.memory_maps);\r\ndev_dbg(asd->isp->dev, "%s: userptr %p, css_address 0x%x, size %d\n",\r\n__func__, map->user_ptr, cssptr, map->length);\r\nmap->css_ptr = cssptr;\r\nreturn 0;\r\n}\r\nint atomisp_acc_unmap(struct atomisp_sub_device *asd, struct atomisp_acc_map *map)\r\n{\r\nstruct atomisp_map *atomisp_map;\r\nif (asd->acc.pipeline)\r\nreturn -EBUSY;\r\natomisp_map = acc_get_map(asd, map->css_ptr, map->length);\r\nif (!atomisp_map)\r\nreturn -EINVAL;\r\nlist_del(&atomisp_map->list);\r\nhmm_free(atomisp_map->ptr);\r\nkfree(atomisp_map);\r\nreturn 0;\r\n}\r\nint atomisp_acc_s_mapped_arg(struct atomisp_sub_device *asd,\r\nstruct atomisp_acc_s_mapped_arg *arg)\r\n{\r\nstruct atomisp_acc_fw *acc_fw;\r\nif (arg->memory >= ATOMISP_ACC_NR_MEMORY)\r\nreturn -EINVAL;\r\nif (asd->acc.pipeline)\r\nreturn -EBUSY;\r\nacc_fw = acc_get_fw(asd, arg->fw_handle);\r\nif (!acc_fw)\r\nreturn -EINVAL;\r\nif (arg->css_ptr != 0 || arg->length != 0) {\r\nif (!acc_get_map(asd, arg->css_ptr, arg->length))\r\nreturn -EINVAL;\r\n}\r\nacc_fw->args[arg->memory].length = arg->length;\r\nacc_fw->args[arg->memory].css_ptr = arg->css_ptr;\r\ndev_dbg(asd->isp->dev, "%s: mem %d, address %p, size %ld\n",\r\n__func__, arg->memory, (void *)arg->css_ptr,\r\n(unsigned long)arg->length);\r\nreturn 0;\r\n}\r\nint atomisp_acc_load_extensions(struct atomisp_sub_device *asd)\r\n{\r\nstruct atomisp_acc_fw *acc_fw;\r\nbool ext_loaded = false;\r\nbool continuous = asd->continuous_mode->val &&\r\nasd->run_mode->val == ATOMISP_RUN_MODE_PREVIEW;\r\nint ret = 0, i = -1;\r\nstruct atomisp_device *isp = asd->isp;\r\nif (asd->acc.pipeline || asd->acc.extension_mode)\r\nreturn -EBUSY;\r\nwbinvd();\r\nlist_for_each_entry(acc_fw, &asd->acc.fw, list) {\r\nif (acc_fw->type != ATOMISP_ACC_FW_LOAD_TYPE_OUTPUT &&\r\nacc_fw->type != ATOMISP_ACC_FW_LOAD_TYPE_VIEWFINDER)\r\ncontinue;\r\nfor (i = 0; i < ARRAY_SIZE(acc_flag_to_pipe); i++) {\r\nif (!continuous &&\r\nacc_flag_to_pipe[i].flag ==\r\nATOMISP_ACC_FW_LOAD_FL_ACC)\r\ncontinue;\r\nif (acc_fw->flags & acc_flag_to_pipe[i].flag) {\r\nret = atomisp_css_load_acc_extension(asd,\r\nacc_fw->fw,\r\nacc_flag_to_pipe[i].pipe_id,\r\nacc_fw->type);\r\nif (ret)\r\ngoto error;\r\next_loaded = true;\r\n}\r\n}\r\nret = atomisp_css_set_acc_parameters(acc_fw);\r\nif (ret < 0)\r\ngoto error;\r\n}\r\nif (!ext_loaded)\r\nreturn ret;\r\nret = atomisp_css_update_stream(asd);\r\nif (ret) {\r\ndev_err(isp->dev, "%s: update stream failed.\n", __func__);\r\ngoto error;\r\n}\r\nasd->acc.extension_mode = true;\r\nreturn 0;\r\nerror:\r\nwhile (--i >= 0) {\r\nif (acc_fw->flags & acc_flag_to_pipe[i].flag) {\r\natomisp_css_unload_acc_extension(asd, acc_fw->fw,\r\nacc_flag_to_pipe[i].pipe_id);\r\n}\r\n}\r\nlist_for_each_entry_continue_reverse(acc_fw, &asd->acc.fw, list) {\r\nif (acc_fw->type != ATOMISP_ACC_FW_LOAD_TYPE_OUTPUT &&\r\nacc_fw->type != ATOMISP_ACC_FW_LOAD_TYPE_VIEWFINDER)\r\ncontinue;\r\nfor (i = ARRAY_SIZE(acc_flag_to_pipe) - 1; i >= 0; i--) {\r\nif (!continuous &&\r\nacc_flag_to_pipe[i].flag ==\r\nATOMISP_ACC_FW_LOAD_FL_ACC)\r\ncontinue;\r\nif (acc_fw->flags & acc_flag_to_pipe[i].flag) {\r\natomisp_css_unload_acc_extension(asd,\r\nacc_fw->fw,\r\nacc_flag_to_pipe[i].pipe_id);\r\n}\r\n}\r\n}\r\nreturn ret;\r\n}\r\nvoid atomisp_acc_unload_extensions(struct atomisp_sub_device *asd)\r\n{\r\nstruct atomisp_acc_fw *acc_fw;\r\nint i;\r\nif (!asd->acc.extension_mode)\r\nreturn;\r\nlist_for_each_entry_reverse(acc_fw, &asd->acc.fw, list) {\r\nif (acc_fw->type != ATOMISP_ACC_FW_LOAD_TYPE_OUTPUT &&\r\nacc_fw->type != ATOMISP_ACC_FW_LOAD_TYPE_VIEWFINDER)\r\ncontinue;\r\nfor (i = ARRAY_SIZE(acc_flag_to_pipe) - 1; i >= 0; i--) {\r\nif (acc_fw->flags & acc_flag_to_pipe[i].flag) {\r\natomisp_css_unload_acc_extension(asd,\r\nacc_fw->fw,\r\nacc_flag_to_pipe[i].pipe_id);\r\n}\r\n}\r\n}\r\nasd->acc.extension_mode = false;\r\n}\r\nint atomisp_acc_set_state(struct atomisp_sub_device *asd,\r\nstruct atomisp_acc_state *arg)\r\n{\r\nstruct atomisp_acc_fw *acc_fw;\r\nbool enable = (arg->flags & ATOMISP_STATE_FLAG_ENABLE) != 0;\r\nstruct ia_css_pipe *pipe;\r\nenum ia_css_err r;\r\nint i;\r\nif (!asd->acc.extension_mode)\r\nreturn -EBUSY;\r\nif (arg->flags & ~ATOMISP_STATE_FLAG_ENABLE)\r\nreturn -EINVAL;\r\nacc_fw = acc_get_fw(asd, arg->fw_handle);\r\nif (!acc_fw)\r\nreturn -EINVAL;\r\nif (enable)\r\nwbinvd();\r\nfor (i = 0; i < ARRAY_SIZE(acc_flag_to_pipe); i++) {\r\nif (acc_fw->flags & acc_flag_to_pipe[i].flag) {\r\npipe = asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].\r\npipes[acc_flag_to_pipe[i].pipe_id];\r\nr = ia_css_pipe_set_qos_ext_state(pipe, acc_fw->handle,\r\nenable);\r\nif (r != IA_CSS_SUCCESS)\r\nreturn -EBADRQC;\r\n}\r\n}\r\nif (enable)\r\nacc_fw->flags |= ATOMISP_ACC_FW_LOAD_FL_ENABLE;\r\nelse\r\nacc_fw->flags &= ~ATOMISP_ACC_FW_LOAD_FL_ENABLE;\r\nreturn 0;\r\n}\r\nint atomisp_acc_get_state(struct atomisp_sub_device *asd,\r\nstruct atomisp_acc_state *arg)\r\n{\r\nstruct atomisp_acc_fw *acc_fw;\r\nif (!asd->acc.extension_mode)\r\nreturn -EBUSY;\r\nacc_fw = acc_get_fw(asd, arg->fw_handle);\r\nif (!acc_fw)\r\nreturn -EINVAL;\r\narg->flags = acc_fw->flags;\r\nreturn 0;\r\n}
