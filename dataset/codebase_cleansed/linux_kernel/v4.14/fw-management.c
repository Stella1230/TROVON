static void fw_mgmt_kref_release(struct kref *kref)\r\n{\r\nstruct fw_mgmt *fw_mgmt = container_of(kref, struct fw_mgmt, kref);\r\nida_destroy(&fw_mgmt->id_map);\r\nkfree(fw_mgmt);\r\n}\r\nstatic void put_fw_mgmt(struct fw_mgmt *fw_mgmt)\r\n{\r\nkref_put(&fw_mgmt->kref, fw_mgmt_kref_release);\r\n}\r\nstatic struct fw_mgmt *get_fw_mgmt(struct cdev *cdev)\r\n{\r\nstruct fw_mgmt *fw_mgmt;\r\nmutex_lock(&list_mutex);\r\nlist_for_each_entry(fw_mgmt, &fw_mgmt_list, node) {\r\nif (&fw_mgmt->cdev == cdev) {\r\nkref_get(&fw_mgmt->kref);\r\ngoto unlock;\r\n}\r\n}\r\nfw_mgmt = NULL;\r\nunlock:\r\nmutex_unlock(&list_mutex);\r\nreturn fw_mgmt;\r\n}\r\nstatic int fw_mgmt_interface_fw_version_operation(struct fw_mgmt *fw_mgmt,\r\nstruct fw_mgmt_ioc_get_intf_version *fw_info)\r\n{\r\nstruct gb_connection *connection = fw_mgmt->connection;\r\nstruct gb_fw_mgmt_interface_fw_version_response response;\r\nint ret;\r\nret = gb_operation_sync(connection,\r\nGB_FW_MGMT_TYPE_INTERFACE_FW_VERSION, NULL, 0,\r\n&response, sizeof(response));\r\nif (ret) {\r\ndev_err(fw_mgmt->parent,\r\n"failed to get interface firmware version (%d)\n", ret);\r\nreturn ret;\r\n}\r\nfw_info->major = le16_to_cpu(response.major);\r\nfw_info->minor = le16_to_cpu(response.minor);\r\nstrncpy(fw_info->firmware_tag, response.firmware_tag,\r\nGB_FIRMWARE_TAG_MAX_SIZE);\r\nif (fw_info->firmware_tag[GB_FIRMWARE_TAG_MAX_SIZE - 1] != '\0') {\r\ndev_err(fw_mgmt->parent,\r\n"fw-version: firmware-tag is not NULL terminated\n");\r\nfw_info->firmware_tag[GB_FIRMWARE_TAG_MAX_SIZE - 1] = '\0';\r\n}\r\nreturn 0;\r\n}\r\nstatic int fw_mgmt_load_and_validate_operation(struct fw_mgmt *fw_mgmt,\r\nu8 load_method, const char *tag)\r\n{\r\nstruct gb_fw_mgmt_load_and_validate_fw_request request;\r\nint ret;\r\nif (load_method != GB_FW_LOAD_METHOD_UNIPRO &&\r\nload_method != GB_FW_LOAD_METHOD_INTERNAL) {\r\ndev_err(fw_mgmt->parent,\r\n"invalid load-method (%d)\n", load_method);\r\nreturn -EINVAL;\r\n}\r\nrequest.load_method = load_method;\r\nstrncpy(request.firmware_tag, tag, GB_FIRMWARE_TAG_MAX_SIZE);\r\nif (request.firmware_tag[GB_FIRMWARE_TAG_MAX_SIZE - 1] != '\0') {\r\ndev_err(fw_mgmt->parent, "load-and-validate: firmware-tag is not NULL terminated\n");\r\nreturn -EINVAL;\r\n}\r\nret = ida_simple_get(&fw_mgmt->id_map, 1, 256, GFP_KERNEL);\r\nif (ret < 0) {\r\ndev_err(fw_mgmt->parent, "failed to allocate request id (%d)\n",\r\nret);\r\nreturn ret;\r\n}\r\nfw_mgmt->intf_fw_request_id = ret;\r\nfw_mgmt->intf_fw_loaded = false;\r\nrequest.request_id = ret;\r\nret = gb_operation_sync(fw_mgmt->connection,\r\nGB_FW_MGMT_TYPE_LOAD_AND_VALIDATE_FW, &request,\r\nsizeof(request), NULL, 0);\r\nif (ret) {\r\nida_simple_remove(&fw_mgmt->id_map,\r\nfw_mgmt->intf_fw_request_id);\r\nfw_mgmt->intf_fw_request_id = 0;\r\ndev_err(fw_mgmt->parent,\r\n"load and validate firmware request failed (%d)\n",\r\nret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fw_mgmt_interface_fw_loaded_operation(struct gb_operation *op)\r\n{\r\nstruct gb_connection *connection = op->connection;\r\nstruct fw_mgmt *fw_mgmt = gb_connection_get_data(connection);\r\nstruct gb_fw_mgmt_loaded_fw_request *request;\r\nif (!fw_mgmt->intf_fw_request_id) {\r\ndev_err(fw_mgmt->parent,\r\n"unexpected firmware loaded request received\n");\r\nreturn -ENODEV;\r\n}\r\nif (op->request->payload_size != sizeof(*request)) {\r\ndev_err(fw_mgmt->parent, "illegal size of firmware loaded request (%zu != %zu)\n",\r\nop->request->payload_size, sizeof(*request));\r\nreturn -EINVAL;\r\n}\r\nrequest = op->request->payload;\r\nif (request->request_id != fw_mgmt->intf_fw_request_id) {\r\ndev_err(fw_mgmt->parent, "invalid request id for firmware loaded request (%02u != %02u)\n",\r\nfw_mgmt->intf_fw_request_id, request->request_id);\r\nreturn -ENODEV;\r\n}\r\nida_simple_remove(&fw_mgmt->id_map, fw_mgmt->intf_fw_request_id);\r\nfw_mgmt->intf_fw_request_id = 0;\r\nfw_mgmt->intf_fw_status = request->status;\r\nfw_mgmt->intf_fw_major = le16_to_cpu(request->major);\r\nfw_mgmt->intf_fw_minor = le16_to_cpu(request->minor);\r\nif (fw_mgmt->intf_fw_status == GB_FW_LOAD_STATUS_FAILED)\r\ndev_err(fw_mgmt->parent,\r\n"failed to load interface firmware, status:%02x\n",\r\nfw_mgmt->intf_fw_status);\r\nelse if (fw_mgmt->intf_fw_status == GB_FW_LOAD_STATUS_VALIDATION_FAILED)\r\ndev_err(fw_mgmt->parent,\r\n"failed to validate interface firmware, status:%02x\n",\r\nfw_mgmt->intf_fw_status);\r\nelse\r\nfw_mgmt->intf_fw_loaded = true;\r\ncomplete(&fw_mgmt->completion);\r\nreturn 0;\r\n}\r\nstatic int fw_mgmt_backend_fw_version_operation(struct fw_mgmt *fw_mgmt,\r\nstruct fw_mgmt_ioc_get_backend_version *fw_info)\r\n{\r\nstruct gb_connection *connection = fw_mgmt->connection;\r\nstruct gb_fw_mgmt_backend_fw_version_request request;\r\nstruct gb_fw_mgmt_backend_fw_version_response response;\r\nint ret;\r\nstrncpy(request.firmware_tag, fw_info->firmware_tag,\r\nGB_FIRMWARE_TAG_MAX_SIZE);\r\nif (request.firmware_tag[GB_FIRMWARE_TAG_MAX_SIZE - 1] != '\0') {\r\ndev_err(fw_mgmt->parent, "backend-version: firmware-tag is not NULL terminated\n");\r\nreturn -EINVAL;\r\n}\r\nret = gb_operation_sync(connection,\r\nGB_FW_MGMT_TYPE_BACKEND_FW_VERSION, &request,\r\nsizeof(request), &response, sizeof(response));\r\nif (ret) {\r\ndev_err(fw_mgmt->parent, "failed to get version of %s backend firmware (%d)\n",\r\nfw_info->firmware_tag, ret);\r\nreturn ret;\r\n}\r\nfw_info->status = response.status;\r\nfw_info->major = 0;\r\nfw_info->minor = 0;\r\nswitch (fw_info->status) {\r\ncase GB_FW_BACKEND_VERSION_STATUS_SUCCESS:\r\nfw_info->major = le16_to_cpu(response.major);\r\nfw_info->minor = le16_to_cpu(response.minor);\r\nbreak;\r\ncase GB_FW_BACKEND_VERSION_STATUS_NOT_AVAILABLE:\r\ncase GB_FW_BACKEND_VERSION_STATUS_RETRY:\r\nbreak;\r\ncase GB_FW_BACKEND_VERSION_STATUS_NOT_SUPPORTED:\r\ndev_err(fw_mgmt->parent,\r\n"Firmware with tag %s is not supported by Interface\n",\r\nfw_info->firmware_tag);\r\nbreak;\r\ndefault:\r\ndev_err(fw_mgmt->parent, "Invalid status received: %u\n",\r\nfw_info->status);\r\n}\r\nreturn 0;\r\n}\r\nstatic int fw_mgmt_backend_fw_update_operation(struct fw_mgmt *fw_mgmt,\r\nchar *tag)\r\n{\r\nstruct gb_fw_mgmt_backend_fw_update_request request;\r\nint ret;\r\nstrncpy(request.firmware_tag, tag, GB_FIRMWARE_TAG_MAX_SIZE);\r\nif (request.firmware_tag[GB_FIRMWARE_TAG_MAX_SIZE - 1] != '\0') {\r\ndev_err(fw_mgmt->parent, "backend-update: firmware-tag is not NULL terminated\n");\r\nreturn -EINVAL;\r\n}\r\nret = ida_simple_get(&fw_mgmt->id_map, 1, 256, GFP_KERNEL);\r\nif (ret < 0) {\r\ndev_err(fw_mgmt->parent, "failed to allocate request id (%d)\n",\r\nret);\r\nreturn ret;\r\n}\r\nfw_mgmt->backend_fw_request_id = ret;\r\nrequest.request_id = ret;\r\nret = gb_operation_sync(fw_mgmt->connection,\r\nGB_FW_MGMT_TYPE_BACKEND_FW_UPDATE, &request,\r\nsizeof(request), NULL, 0);\r\nif (ret) {\r\nida_simple_remove(&fw_mgmt->id_map,\r\nfw_mgmt->backend_fw_request_id);\r\nfw_mgmt->backend_fw_request_id = 0;\r\ndev_err(fw_mgmt->parent,\r\n"backend %s firmware update request failed (%d)\n", tag,\r\nret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fw_mgmt_backend_fw_updated_operation(struct gb_operation *op)\r\n{\r\nstruct gb_connection *connection = op->connection;\r\nstruct fw_mgmt *fw_mgmt = gb_connection_get_data(connection);\r\nstruct gb_fw_mgmt_backend_fw_updated_request *request;\r\nif (!fw_mgmt->backend_fw_request_id) {\r\ndev_err(fw_mgmt->parent, "unexpected backend firmware updated request received\n");\r\nreturn -ENODEV;\r\n}\r\nif (op->request->payload_size != sizeof(*request)) {\r\ndev_err(fw_mgmt->parent, "illegal size of backend firmware updated request (%zu != %zu)\n",\r\nop->request->payload_size, sizeof(*request));\r\nreturn -EINVAL;\r\n}\r\nrequest = op->request->payload;\r\nif (request->request_id != fw_mgmt->backend_fw_request_id) {\r\ndev_err(fw_mgmt->parent, "invalid request id for backend firmware updated request (%02u != %02u)\n",\r\nfw_mgmt->backend_fw_request_id, request->request_id);\r\nreturn -ENODEV;\r\n}\r\nida_simple_remove(&fw_mgmt->id_map, fw_mgmt->backend_fw_request_id);\r\nfw_mgmt->backend_fw_request_id = 0;\r\nfw_mgmt->backend_fw_status = request->status;\r\nif ((fw_mgmt->backend_fw_status != GB_FW_BACKEND_FW_STATUS_SUCCESS) &&\r\n(fw_mgmt->backend_fw_status != GB_FW_BACKEND_FW_STATUS_RETRY))\r\ndev_err(fw_mgmt->parent,\r\n"failed to load backend firmware: %02x\n",\r\nfw_mgmt->backend_fw_status);\r\ncomplete(&fw_mgmt->completion);\r\nreturn 0;\r\n}\r\nstatic int fw_mgmt_open(struct inode *inode, struct file *file)\r\n{\r\nstruct fw_mgmt *fw_mgmt = get_fw_mgmt(inode->i_cdev);\r\nif (fw_mgmt) {\r\nfile->private_data = fw_mgmt;\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int fw_mgmt_release(struct inode *inode, struct file *file)\r\n{\r\nstruct fw_mgmt *fw_mgmt = file->private_data;\r\nput_fw_mgmt(fw_mgmt);\r\nreturn 0;\r\n}\r\nstatic int fw_mgmt_ioctl(struct fw_mgmt *fw_mgmt, unsigned int cmd,\r\nvoid __user *buf)\r\n{\r\nstruct fw_mgmt_ioc_get_intf_version intf_fw_info;\r\nstruct fw_mgmt_ioc_get_backend_version backend_fw_info;\r\nstruct fw_mgmt_ioc_intf_load_and_validate intf_load;\r\nstruct fw_mgmt_ioc_backend_fw_update backend_update;\r\nunsigned int timeout;\r\nint ret;\r\nif (fw_mgmt->mode_switch_started)\r\nreturn -EBUSY;\r\nswitch (cmd) {\r\ncase FW_MGMT_IOC_GET_INTF_FW:\r\nret = fw_mgmt_interface_fw_version_operation(fw_mgmt,\r\n&intf_fw_info);\r\nif (ret)\r\nreturn ret;\r\nif (copy_to_user(buf, &intf_fw_info, sizeof(intf_fw_info)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase FW_MGMT_IOC_GET_BACKEND_FW:\r\nif (copy_from_user(&backend_fw_info, buf,\r\nsizeof(backend_fw_info)))\r\nreturn -EFAULT;\r\nret = fw_mgmt_backend_fw_version_operation(fw_mgmt,\r\n&backend_fw_info);\r\nif (ret)\r\nreturn ret;\r\nif (copy_to_user(buf, &backend_fw_info,\r\nsizeof(backend_fw_info)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase FW_MGMT_IOC_INTF_LOAD_AND_VALIDATE:\r\nif (copy_from_user(&intf_load, buf, sizeof(intf_load)))\r\nreturn -EFAULT;\r\nret = fw_mgmt_load_and_validate_operation(fw_mgmt,\r\nintf_load.load_method, intf_load.firmware_tag);\r\nif (ret)\r\nreturn ret;\r\nif (!wait_for_completion_timeout(&fw_mgmt->completion,\r\nfw_mgmt->timeout_jiffies)) {\r\ndev_err(fw_mgmt->parent, "timed out waiting for firmware load and validation to finish\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nintf_load.status = fw_mgmt->intf_fw_status;\r\nintf_load.major = fw_mgmt->intf_fw_major;\r\nintf_load.minor = fw_mgmt->intf_fw_minor;\r\nif (copy_to_user(buf, &intf_load, sizeof(intf_load)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase FW_MGMT_IOC_INTF_BACKEND_FW_UPDATE:\r\nif (copy_from_user(&backend_update, buf,\r\nsizeof(backend_update)))\r\nreturn -EFAULT;\r\nret = fw_mgmt_backend_fw_update_operation(fw_mgmt,\r\nbackend_update.firmware_tag);\r\nif (ret)\r\nreturn ret;\r\nif (!wait_for_completion_timeout(&fw_mgmt->completion,\r\nfw_mgmt->timeout_jiffies)) {\r\ndev_err(fw_mgmt->parent, "timed out waiting for backend firmware update to finish\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nbackend_update.status = fw_mgmt->backend_fw_status;\r\nif (copy_to_user(buf, &backend_update, sizeof(backend_update)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase FW_MGMT_IOC_SET_TIMEOUT_MS:\r\nif (get_user(timeout, (unsigned int __user *)buf))\r\nreturn -EFAULT;\r\nif (!timeout) {\r\ndev_err(fw_mgmt->parent, "timeout can't be zero\n");\r\nreturn -EINVAL;\r\n}\r\nfw_mgmt->timeout_jiffies = msecs_to_jiffies(timeout);\r\nreturn 0;\r\ncase FW_MGMT_IOC_MODE_SWITCH:\r\nif (!fw_mgmt->intf_fw_loaded) {\r\ndev_err(fw_mgmt->parent,\r\n"Firmware not loaded for mode-switch\n");\r\nreturn -EPERM;\r\n}\r\nfw_mgmt->mode_switch_started = true;\r\nret = gb_interface_request_mode_switch(fw_mgmt->connection->intf);\r\nif (ret) {\r\ndev_err(fw_mgmt->parent, "Mode-switch failed: %d\n",\r\nret);\r\nfw_mgmt->mode_switch_started = false;\r\nreturn ret;\r\n}\r\nreturn 0;\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}\r\nstatic long fw_mgmt_ioctl_unlocked(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct fw_mgmt *fw_mgmt = file->private_data;\r\nstruct gb_bundle *bundle = fw_mgmt->connection->bundle;\r\nint ret = -ENODEV;\r\nmutex_lock(&fw_mgmt->mutex);\r\nif (!fw_mgmt->disabled) {\r\nret = gb_pm_runtime_get_sync(bundle);\r\nif (!ret) {\r\nret = fw_mgmt_ioctl(fw_mgmt, cmd, (void __user *)arg);\r\ngb_pm_runtime_put_autosuspend(bundle);\r\n}\r\n}\r\nmutex_unlock(&fw_mgmt->mutex);\r\nreturn ret;\r\n}\r\nint gb_fw_mgmt_request_handler(struct gb_operation *op)\r\n{\r\nu8 type = op->type;\r\nswitch (type) {\r\ncase GB_FW_MGMT_TYPE_LOADED_FW:\r\nreturn fw_mgmt_interface_fw_loaded_operation(op);\r\ncase GB_FW_MGMT_TYPE_BACKEND_FW_UPDATED:\r\nreturn fw_mgmt_backend_fw_updated_operation(op);\r\ndefault:\r\ndev_err(&op->connection->bundle->dev,\r\n"unsupported request: %u\n", type);\r\nreturn -EINVAL;\r\n}\r\n}\r\nint gb_fw_mgmt_connection_init(struct gb_connection *connection)\r\n{\r\nstruct fw_mgmt *fw_mgmt;\r\nint ret, minor;\r\nif (!connection)\r\nreturn 0;\r\nfw_mgmt = kzalloc(sizeof(*fw_mgmt), GFP_KERNEL);\r\nif (!fw_mgmt)\r\nreturn -ENOMEM;\r\nfw_mgmt->parent = &connection->bundle->dev;\r\nfw_mgmt->timeout_jiffies = msecs_to_jiffies(FW_MGMT_TIMEOUT_MS);\r\nfw_mgmt->connection = connection;\r\ngb_connection_set_data(connection, fw_mgmt);\r\ninit_completion(&fw_mgmt->completion);\r\nida_init(&fw_mgmt->id_map);\r\nmutex_init(&fw_mgmt->mutex);\r\nkref_init(&fw_mgmt->kref);\r\nmutex_lock(&list_mutex);\r\nlist_add(&fw_mgmt->node, &fw_mgmt_list);\r\nmutex_unlock(&list_mutex);\r\nret = gb_connection_enable(connection);\r\nif (ret)\r\ngoto err_list_del;\r\nminor = ida_simple_get(&fw_mgmt_minors_map, 0, NUM_MINORS, GFP_KERNEL);\r\nif (minor < 0) {\r\nret = minor;\r\ngoto err_connection_disable;\r\n}\r\nfw_mgmt->dev_num = MKDEV(MAJOR(fw_mgmt_dev_num), minor);\r\ncdev_init(&fw_mgmt->cdev, &fw_mgmt_fops);\r\nret = cdev_add(&fw_mgmt->cdev, fw_mgmt->dev_num, 1);\r\nif (ret)\r\ngoto err_remove_ida;\r\nfw_mgmt->class_device = device_create(fw_mgmt_class, fw_mgmt->parent,\r\nfw_mgmt->dev_num, NULL,\r\n"gb-fw-mgmt-%d", minor);\r\nif (IS_ERR(fw_mgmt->class_device)) {\r\nret = PTR_ERR(fw_mgmt->class_device);\r\ngoto err_del_cdev;\r\n}\r\nreturn 0;\r\nerr_del_cdev:\r\ncdev_del(&fw_mgmt->cdev);\r\nerr_remove_ida:\r\nida_simple_remove(&fw_mgmt_minors_map, minor);\r\nerr_connection_disable:\r\ngb_connection_disable(connection);\r\nerr_list_del:\r\nmutex_lock(&list_mutex);\r\nlist_del(&fw_mgmt->node);\r\nmutex_unlock(&list_mutex);\r\nput_fw_mgmt(fw_mgmt);\r\nreturn ret;\r\n}\r\nvoid gb_fw_mgmt_connection_exit(struct gb_connection *connection)\r\n{\r\nstruct fw_mgmt *fw_mgmt;\r\nif (!connection)\r\nreturn;\r\nfw_mgmt = gb_connection_get_data(connection);\r\ndevice_destroy(fw_mgmt_class, fw_mgmt->dev_num);\r\ncdev_del(&fw_mgmt->cdev);\r\nida_simple_remove(&fw_mgmt_minors_map, MINOR(fw_mgmt->dev_num));\r\nmutex_lock(&fw_mgmt->mutex);\r\nfw_mgmt->disabled = true;\r\nmutex_unlock(&fw_mgmt->mutex);\r\ngb_connection_disable(fw_mgmt->connection);\r\nmutex_lock(&list_mutex);\r\nlist_del(&fw_mgmt->node);\r\nmutex_unlock(&list_mutex);\r\nput_fw_mgmt(fw_mgmt);\r\n}\r\nint fw_mgmt_init(void)\r\n{\r\nint ret;\r\nfw_mgmt_class = class_create(THIS_MODULE, "gb_fw_mgmt");\r\nif (IS_ERR(fw_mgmt_class))\r\nreturn PTR_ERR(fw_mgmt_class);\r\nret = alloc_chrdev_region(&fw_mgmt_dev_num, 0, NUM_MINORS,\r\n"gb_fw_mgmt");\r\nif (ret)\r\ngoto err_remove_class;\r\nreturn 0;\r\nerr_remove_class:\r\nclass_destroy(fw_mgmt_class);\r\nreturn ret;\r\n}\r\nvoid fw_mgmt_exit(void)\r\n{\r\nunregister_chrdev_region(fw_mgmt_dev_num, NUM_MINORS);\r\nclass_destroy(fw_mgmt_class);\r\nida_destroy(&fw_mgmt_minors_map);\r\n}
