static int put_cfg_tlv_u32(struct wcn36xx *wcn, size_t *len, u32 id, u32 value)\r\n{\r\nstruct wcn36xx_hal_cfg *entry;\r\nu32 *val;\r\nif (*len + sizeof(*entry) + sizeof(u32) >= WCN36XX_HAL_BUF_SIZE) {\r\nwcn36xx_err("Not enough room for TLV entry\n");\r\nreturn -ENOMEM;\r\n}\r\nentry = (struct wcn36xx_hal_cfg *) (wcn->hal_buf + *len);\r\nentry->id = id;\r\nentry->len = sizeof(u32);\r\nentry->pad_bytes = 0;\r\nentry->reserve = 0;\r\nval = (u32 *) (entry + 1);\r\n*val = value;\r\n*len += sizeof(*entry) + sizeof(u32);\r\nreturn 0;\r\n}\r\nstatic void wcn36xx_smd_set_bss_nw_type(struct wcn36xx *wcn,\r\nstruct ieee80211_sta *sta,\r\nstruct wcn36xx_hal_config_bss_params *bss_params)\r\n{\r\nif (NL80211_BAND_5GHZ == WCN36XX_BAND(wcn))\r\nbss_params->nw_type = WCN36XX_HAL_11A_NW_TYPE;\r\nelse if (sta && sta->ht_cap.ht_supported)\r\nbss_params->nw_type = WCN36XX_HAL_11N_NW_TYPE;\r\nelse if (sta && (sta->supp_rates[NL80211_BAND_2GHZ] & 0x7f))\r\nbss_params->nw_type = WCN36XX_HAL_11G_NW_TYPE;\r\nelse\r\nbss_params->nw_type = WCN36XX_HAL_11B_NW_TYPE;\r\n}\r\nstatic inline u8 is_cap_supported(unsigned long caps, unsigned long flag)\r\n{\r\nreturn caps & flag ? 1 : 0;\r\n}\r\nstatic void wcn36xx_smd_set_bss_ht_params(struct ieee80211_vif *vif,\r\nstruct ieee80211_sta *sta,\r\nstruct wcn36xx_hal_config_bss_params *bss_params)\r\n{\r\nif (sta && sta->ht_cap.ht_supported) {\r\nunsigned long caps = sta->ht_cap.cap;\r\nbss_params->ht = sta->ht_cap.ht_supported;\r\nbss_params->tx_channel_width_set = is_cap_supported(caps,\r\nIEEE80211_HT_CAP_SUP_WIDTH_20_40);\r\nbss_params->lsig_tx_op_protection_full_support =\r\nis_cap_supported(caps,\r\nIEEE80211_HT_CAP_LSIG_TXOP_PROT);\r\nbss_params->ht_oper_mode = vif->bss_conf.ht_operation_mode;\r\nbss_params->lln_non_gf_coexist =\r\n!!(vif->bss_conf.ht_operation_mode &\r\nIEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT);\r\nbss_params->dual_cts_protection = 0;\r\nbss_params->ht20_coexist = 0;\r\n}\r\n}\r\nstatic void wcn36xx_smd_set_sta_ht_params(struct ieee80211_sta *sta,\r\nstruct wcn36xx_hal_config_sta_params *sta_params)\r\n{\r\nif (sta->ht_cap.ht_supported) {\r\nunsigned long caps = sta->ht_cap.cap;\r\nsta_params->ht_capable = sta->ht_cap.ht_supported;\r\nsta_params->tx_channel_width_set = is_cap_supported(caps,\r\nIEEE80211_HT_CAP_SUP_WIDTH_20_40);\r\nsta_params->lsig_txop_protection = is_cap_supported(caps,\r\nIEEE80211_HT_CAP_LSIG_TXOP_PROT);\r\nsta_params->max_ampdu_size = sta->ht_cap.ampdu_factor;\r\nsta_params->max_ampdu_density = sta->ht_cap.ampdu_density;\r\nsta_params->max_amsdu_size = is_cap_supported(caps,\r\nIEEE80211_HT_CAP_MAX_AMSDU);\r\nsta_params->sgi_20Mhz = is_cap_supported(caps,\r\nIEEE80211_HT_CAP_SGI_20);\r\nsta_params->sgi_40mhz = is_cap_supported(caps,\r\nIEEE80211_HT_CAP_SGI_40);\r\nsta_params->green_field_capable = is_cap_supported(caps,\r\nIEEE80211_HT_CAP_GRN_FLD);\r\nsta_params->delayed_ba_support = is_cap_supported(caps,\r\nIEEE80211_HT_CAP_DELAY_BA);\r\nsta_params->dsss_cck_mode_40mhz = is_cap_supported(caps,\r\nIEEE80211_HT_CAP_DSSSCCK40);\r\n}\r\n}\r\nstatic void wcn36xx_smd_set_sta_default_ht_params(\r\nstruct wcn36xx_hal_config_sta_params *sta_params)\r\n{\r\nsta_params->ht_capable = 1;\r\nsta_params->tx_channel_width_set = 1;\r\nsta_params->lsig_txop_protection = 1;\r\nsta_params->max_ampdu_size = 3;\r\nsta_params->max_ampdu_density = 5;\r\nsta_params->max_amsdu_size = 0;\r\nsta_params->sgi_20Mhz = 1;\r\nsta_params->sgi_40mhz = 1;\r\nsta_params->green_field_capable = 1;\r\nsta_params->delayed_ba_support = 0;\r\nsta_params->dsss_cck_mode_40mhz = 1;\r\n}\r\nstatic void wcn36xx_smd_set_sta_params(struct wcn36xx *wcn,\r\nstruct ieee80211_vif *vif,\r\nstruct ieee80211_sta *sta,\r\nstruct wcn36xx_hal_config_sta_params *sta_params)\r\n{\r\nstruct wcn36xx_vif *vif_priv = wcn36xx_vif_to_priv(vif);\r\nstruct wcn36xx_sta *sta_priv = NULL;\r\nif (vif->type == NL80211_IFTYPE_ADHOC ||\r\nvif->type == NL80211_IFTYPE_AP ||\r\nvif->type == NL80211_IFTYPE_MESH_POINT) {\r\nsta_params->type = 1;\r\nsta_params->sta_index = WCN36XX_HAL_STA_INVALID_IDX;\r\n} else {\r\nsta_params->type = 0;\r\nsta_params->sta_index = vif_priv->self_sta_index;\r\n}\r\nsta_params->listen_interval = WCN36XX_LISTEN_INTERVAL(wcn);\r\nif (NL80211_IFTYPE_STATION == vif->type)\r\nmemcpy(&sta_params->mac, vif->addr, ETH_ALEN);\r\nelse\r\nmemcpy(&sta_params->bssid, vif->addr, ETH_ALEN);\r\nsta_params->encrypt_type = vif_priv->encrypt_type;\r\nsta_params->short_preamble_supported = true;\r\nsta_params->rifs_mode = 0;\r\nsta_params->rmf = 0;\r\nsta_params->action = 0;\r\nsta_params->uapsd = 0;\r\nsta_params->mimo_ps = WCN36XX_HAL_HT_MIMO_PS_STATIC;\r\nsta_params->max_ampdu_duration = 0;\r\nsta_params->bssid_index = vif_priv->bss_index;\r\nsta_params->p2p = 0;\r\nif (sta) {\r\nsta_priv = wcn36xx_sta_to_priv(sta);\r\nif (NL80211_IFTYPE_STATION == vif->type)\r\nmemcpy(&sta_params->bssid, sta->addr, ETH_ALEN);\r\nelse\r\nmemcpy(&sta_params->mac, sta->addr, ETH_ALEN);\r\nsta_params->wmm_enabled = sta->wme;\r\nsta_params->max_sp_len = sta->max_sp;\r\nsta_params->aid = sta_priv->aid;\r\nwcn36xx_smd_set_sta_ht_params(sta, sta_params);\r\nmemcpy(&sta_params->supported_rates, &sta_priv->supported_rates,\r\nsizeof(sta_priv->supported_rates));\r\n} else {\r\nwcn36xx_set_default_rates(&sta_params->supported_rates);\r\nwcn36xx_smd_set_sta_default_ht_params(sta_params);\r\n}\r\n}\r\nstatic int wcn36xx_smd_send_and_wait(struct wcn36xx *wcn, size_t len)\r\n{\r\nint ret = 0;\r\nunsigned long start;\r\nwcn36xx_dbg_dump(WCN36XX_DBG_SMD_DUMP, "HAL >>> ", wcn->hal_buf, len);\r\ninit_completion(&wcn->hal_rsp_compl);\r\nstart = jiffies;\r\nret = rpmsg_send(wcn->smd_channel, wcn->hal_buf, len);\r\nif (ret) {\r\nwcn36xx_err("HAL TX failed\n");\r\ngoto out;\r\n}\r\nif (wait_for_completion_timeout(&wcn->hal_rsp_compl,\r\nmsecs_to_jiffies(HAL_MSG_TIMEOUT)) <= 0) {\r\nwcn36xx_err("Timeout! No SMD response in %dms\n",\r\nHAL_MSG_TIMEOUT);\r\nret = -ETIME;\r\ngoto out;\r\n}\r\nwcn36xx_dbg(WCN36XX_DBG_SMD, "SMD command completed in %dms",\r\njiffies_to_msecs(jiffies - start));\r\nout:\r\nreturn ret;\r\n}\r\nstatic void init_hal_msg(struct wcn36xx_hal_msg_header *hdr,\r\nenum wcn36xx_hal_host_msg_type msg_type,\r\nsize_t msg_size)\r\n{\r\nmemset(hdr, 0, msg_size + sizeof(*hdr));\r\nhdr->msg_type = msg_type;\r\nhdr->msg_version = WCN36XX_HAL_MSG_VERSION0;\r\nhdr->len = msg_size + sizeof(*hdr);\r\n}\r\nint wcn36xx_smd_load_nv(struct wcn36xx *wcn)\r\n{\r\nstruct nv_data *nv_d;\r\nstruct wcn36xx_hal_nv_img_download_req_msg msg_body;\r\nint fw_bytes_left;\r\nint ret;\r\nu16 fm_offset = 0;\r\nif (!wcn->nv) {\r\nret = request_firmware(&wcn->nv, WLAN_NV_FILE, wcn->dev);\r\nif (ret) {\r\nwcn36xx_err("Failed to load nv file %s: %d\n",\r\nWLAN_NV_FILE, ret);\r\ngoto out;\r\n}\r\n}\r\nnv_d = (struct nv_data *)wcn->nv->data;\r\nINIT_HAL_MSG(msg_body, WCN36XX_HAL_DOWNLOAD_NV_REQ);\r\nmsg_body.header.len += WCN36XX_NV_FRAGMENT_SIZE;\r\nmsg_body.frag_number = 0;\r\nmutex_lock(&wcn->hal_mutex);\r\ndo {\r\nfw_bytes_left = wcn->nv->size - fm_offset - 4;\r\nif (fw_bytes_left > WCN36XX_NV_FRAGMENT_SIZE) {\r\nmsg_body.last_fragment = 0;\r\nmsg_body.nv_img_buffer_size = WCN36XX_NV_FRAGMENT_SIZE;\r\n} else {\r\nmsg_body.last_fragment = 1;\r\nmsg_body.nv_img_buffer_size = fw_bytes_left;\r\nmsg_body.header.len = sizeof(msg_body) + fw_bytes_left;\r\n}\r\nmemcpy(wcn->hal_buf, &msg_body, sizeof(msg_body));\r\nmemcpy(wcn->hal_buf + sizeof(msg_body),\r\n&nv_d->table + fm_offset,\r\nmsg_body.nv_img_buffer_size);\r\nret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\r\nif (ret)\r\ngoto out_unlock;\r\nret = wcn36xx_smd_rsp_status_check(wcn->hal_buf,\r\nwcn->hal_rsp_len);\r\nif (ret) {\r\nwcn36xx_err("hal_load_nv response failed err=%d\n",\r\nret);\r\ngoto out_unlock;\r\n}\r\nmsg_body.frag_number++;\r\nfm_offset += WCN36XX_NV_FRAGMENT_SIZE;\r\n} while (msg_body.last_fragment != 1);\r\nout_unlock:\r\nmutex_unlock(&wcn->hal_mutex);\r\nout: return ret;\r\n}\r\nstatic int wcn36xx_smd_start_rsp(struct wcn36xx *wcn, void *buf, size_t len)\r\n{\r\nstruct wcn36xx_hal_mac_start_rsp_msg *rsp;\r\nif (len < sizeof(*rsp))\r\nreturn -EIO;\r\nrsp = (struct wcn36xx_hal_mac_start_rsp_msg *)buf;\r\nif (WCN36XX_FW_MSG_RESULT_SUCCESS != rsp->start_rsp_params.status)\r\nreturn -EIO;\r\nmemcpy(wcn->crm_version, rsp->start_rsp_params.crm_version,\r\nWCN36XX_HAL_VERSION_LENGTH);\r\nmemcpy(wcn->wlan_version, rsp->start_rsp_params.wlan_version,\r\nWCN36XX_HAL_VERSION_LENGTH);\r\nwcn->crm_version[WCN36XX_HAL_VERSION_LENGTH] = '\0';\r\nwcn->wlan_version[WCN36XX_HAL_VERSION_LENGTH] = '\0';\r\nwcn->fw_revision = rsp->start_rsp_params.version.revision;\r\nwcn->fw_version = rsp->start_rsp_params.version.version;\r\nwcn->fw_minor = rsp->start_rsp_params.version.minor;\r\nwcn->fw_major = rsp->start_rsp_params.version.major;\r\nwcn36xx_info("firmware WLAN version '%s' and CRM version '%s'\n",\r\nwcn->wlan_version, wcn->crm_version);\r\nwcn36xx_info("firmware API %u.%u.%u.%u, %u stations, %u bssids\n",\r\nwcn->fw_major, wcn->fw_minor,\r\nwcn->fw_version, wcn->fw_revision,\r\nrsp->start_rsp_params.stations,\r\nrsp->start_rsp_params.bssids);\r\nreturn 0;\r\n}\r\nint wcn36xx_smd_start(struct wcn36xx *wcn)\r\n{\r\nstruct wcn36xx_hal_mac_start_req_msg msg_body, *body;\r\nint ret = 0;\r\nint i;\r\nsize_t len;\r\nmutex_lock(&wcn->hal_mutex);\r\nINIT_HAL_MSG(msg_body, WCN36XX_HAL_START_REQ);\r\nmsg_body.params.type = DRIVER_TYPE_PRODUCTION;\r\nmsg_body.params.len = 0;\r\nPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\r\nbody = (struct wcn36xx_hal_mac_start_req_msg *)wcn->hal_buf;\r\nlen = body->header.len;\r\nfor (i = 0; i < ARRAY_SIZE(wcn36xx_cfg_vals); i++) {\r\nret = put_cfg_tlv_u32(wcn, &len, wcn36xx_cfg_vals[i].cfg_id,\r\nwcn36xx_cfg_vals[i].value);\r\nif (ret)\r\ngoto out;\r\n}\r\nbody->header.len = len;\r\nbody->params.len = len - sizeof(*body);\r\nwcn36xx_dbg(WCN36XX_DBG_HAL, "hal start type %d\n",\r\nmsg_body.params.type);\r\nret = wcn36xx_smd_send_and_wait(wcn, body->header.len);\r\nif (ret) {\r\nwcn36xx_err("Sending hal_start failed\n");\r\ngoto out;\r\n}\r\nret = wcn36xx_smd_start_rsp(wcn, wcn->hal_buf, wcn->hal_rsp_len);\r\nif (ret) {\r\nwcn36xx_err("hal_start response failed err=%d\n", ret);\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&wcn->hal_mutex);\r\nreturn ret;\r\n}\r\nint wcn36xx_smd_stop(struct wcn36xx *wcn)\r\n{\r\nstruct wcn36xx_hal_mac_stop_req_msg msg_body;\r\nint ret = 0;\r\nmutex_lock(&wcn->hal_mutex);\r\nINIT_HAL_MSG(msg_body, WCN36XX_HAL_STOP_REQ);\r\nmsg_body.stop_req_params.reason = HAL_STOP_TYPE_RF_KILL;\r\nPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\r\nret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\r\nif (ret) {\r\nwcn36xx_err("Sending hal_stop failed\n");\r\ngoto out;\r\n}\r\nret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\r\nif (ret) {\r\nwcn36xx_err("hal_stop response failed err=%d\n", ret);\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&wcn->hal_mutex);\r\nreturn ret;\r\n}\r\nint wcn36xx_smd_init_scan(struct wcn36xx *wcn, enum wcn36xx_hal_sys_mode mode)\r\n{\r\nstruct wcn36xx_hal_init_scan_req_msg msg_body;\r\nint ret = 0;\r\nmutex_lock(&wcn->hal_mutex);\r\nINIT_HAL_MSG(msg_body, WCN36XX_HAL_INIT_SCAN_REQ);\r\nmsg_body.mode = mode;\r\nPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\r\nwcn36xx_dbg(WCN36XX_DBG_HAL, "hal init scan mode %d\n", msg_body.mode);\r\nret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\r\nif (ret) {\r\nwcn36xx_err("Sending hal_init_scan failed\n");\r\ngoto out;\r\n}\r\nret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\r\nif (ret) {\r\nwcn36xx_err("hal_init_scan response failed err=%d\n", ret);\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&wcn->hal_mutex);\r\nreturn ret;\r\n}\r\nint wcn36xx_smd_start_scan(struct wcn36xx *wcn, u8 scan_channel)\r\n{\r\nstruct wcn36xx_hal_start_scan_req_msg msg_body;\r\nint ret = 0;\r\nmutex_lock(&wcn->hal_mutex);\r\nINIT_HAL_MSG(msg_body, WCN36XX_HAL_START_SCAN_REQ);\r\nmsg_body.scan_channel = scan_channel;\r\nPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\r\nwcn36xx_dbg(WCN36XX_DBG_HAL, "hal start scan channel %d\n",\r\nmsg_body.scan_channel);\r\nret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\r\nif (ret) {\r\nwcn36xx_err("Sending hal_start_scan failed\n");\r\ngoto out;\r\n}\r\nret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\r\nif (ret) {\r\nwcn36xx_err("hal_start_scan response failed err=%d\n", ret);\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&wcn->hal_mutex);\r\nreturn ret;\r\n}\r\nint wcn36xx_smd_end_scan(struct wcn36xx *wcn, u8 scan_channel)\r\n{\r\nstruct wcn36xx_hal_end_scan_req_msg msg_body;\r\nint ret = 0;\r\nmutex_lock(&wcn->hal_mutex);\r\nINIT_HAL_MSG(msg_body, WCN36XX_HAL_END_SCAN_REQ);\r\nmsg_body.scan_channel = scan_channel;\r\nPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\r\nwcn36xx_dbg(WCN36XX_DBG_HAL, "hal end scan channel %d\n",\r\nmsg_body.scan_channel);\r\nret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\r\nif (ret) {\r\nwcn36xx_err("Sending hal_end_scan failed\n");\r\ngoto out;\r\n}\r\nret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\r\nif (ret) {\r\nwcn36xx_err("hal_end_scan response failed err=%d\n", ret);\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&wcn->hal_mutex);\r\nreturn ret;\r\n}\r\nint wcn36xx_smd_finish_scan(struct wcn36xx *wcn,\r\nenum wcn36xx_hal_sys_mode mode)\r\n{\r\nstruct wcn36xx_hal_finish_scan_req_msg msg_body;\r\nint ret = 0;\r\nmutex_lock(&wcn->hal_mutex);\r\nINIT_HAL_MSG(msg_body, WCN36XX_HAL_FINISH_SCAN_REQ);\r\nmsg_body.mode = mode;\r\nPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\r\nwcn36xx_dbg(WCN36XX_DBG_HAL, "hal finish scan mode %d\n",\r\nmsg_body.mode);\r\nret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\r\nif (ret) {\r\nwcn36xx_err("Sending hal_finish_scan failed\n");\r\ngoto out;\r\n}\r\nret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\r\nif (ret) {\r\nwcn36xx_err("hal_finish_scan response failed err=%d\n", ret);\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&wcn->hal_mutex);\r\nreturn ret;\r\n}\r\nstatic int wcn36xx_smd_switch_channel_rsp(void *buf, size_t len)\r\n{\r\nstruct wcn36xx_hal_switch_channel_rsp_msg *rsp;\r\nint ret = 0;\r\nret = wcn36xx_smd_rsp_status_check(buf, len);\r\nif (ret)\r\nreturn ret;\r\nrsp = (struct wcn36xx_hal_switch_channel_rsp_msg *)buf;\r\nwcn36xx_dbg(WCN36XX_DBG_HAL, "channel switched to: %d, status: %d\n",\r\nrsp->channel_number, rsp->status);\r\nreturn ret;\r\n}\r\nint wcn36xx_smd_switch_channel(struct wcn36xx *wcn,\r\nstruct ieee80211_vif *vif, int ch)\r\n{\r\nstruct wcn36xx_hal_switch_channel_req_msg msg_body;\r\nint ret = 0;\r\nmutex_lock(&wcn->hal_mutex);\r\nINIT_HAL_MSG(msg_body, WCN36XX_HAL_CH_SWITCH_REQ);\r\nmsg_body.channel_number = (u8)ch;\r\nmsg_body.tx_mgmt_power = 0xbf;\r\nmsg_body.max_tx_power = 0xbf;\r\nmemcpy(msg_body.self_sta_mac_addr, vif->addr, ETH_ALEN);\r\nPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\r\nret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\r\nif (ret) {\r\nwcn36xx_err("Sending hal_switch_channel failed\n");\r\ngoto out;\r\n}\r\nret = wcn36xx_smd_switch_channel_rsp(wcn->hal_buf, wcn->hal_rsp_len);\r\nif (ret) {\r\nwcn36xx_err("hal_switch_channel response failed err=%d\n", ret);\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&wcn->hal_mutex);\r\nreturn ret;\r\n}\r\nstatic int wcn36xx_smd_update_scan_params_rsp(void *buf, size_t len)\r\n{\r\nstruct wcn36xx_hal_update_scan_params_resp *rsp;\r\nrsp = (struct wcn36xx_hal_update_scan_params_resp *)buf;\r\nrsp->status &= (~(WCN36XX_FW_MSG_PNO_VERSION_MASK));\r\nif (WCN36XX_FW_MSG_RESULT_SUCCESS != rsp->status) {\r\nwcn36xx_warn("error response from update scan\n");\r\nreturn rsp->status;\r\n}\r\nreturn 0;\r\n}\r\nint wcn36xx_smd_update_scan_params(struct wcn36xx *wcn,\r\nu8 *channels, size_t channel_count)\r\n{\r\nstruct wcn36xx_hal_update_scan_params_req_ex msg_body;\r\nint ret = 0;\r\nmutex_lock(&wcn->hal_mutex);\r\nINIT_HAL_MSG(msg_body, WCN36XX_HAL_UPDATE_SCAN_PARAM_REQ);\r\nmsg_body.dot11d_enabled = false;\r\nmsg_body.dot11d_resolved = true;\r\nmsg_body.channel_count = channel_count;\r\nmemcpy(msg_body.channels, channels, channel_count);\r\nmsg_body.active_min_ch_time = 60;\r\nmsg_body.active_max_ch_time = 120;\r\nmsg_body.passive_min_ch_time = 60;\r\nmsg_body.passive_max_ch_time = 110;\r\nmsg_body.state = PHY_SINGLE_CHANNEL_CENTERED;\r\nPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\r\nwcn36xx_dbg(WCN36XX_DBG_HAL,\r\n"hal update scan params channel_count %d\n",\r\nmsg_body.channel_count);\r\nret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\r\nif (ret) {\r\nwcn36xx_err("Sending hal_update_scan_params failed\n");\r\ngoto out;\r\n}\r\nret = wcn36xx_smd_update_scan_params_rsp(wcn->hal_buf,\r\nwcn->hal_rsp_len);\r\nif (ret) {\r\nwcn36xx_err("hal_update_scan_params response failed err=%d\n",\r\nret);\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&wcn->hal_mutex);\r\nreturn ret;\r\n}\r\nstatic int wcn36xx_smd_add_sta_self_rsp(struct wcn36xx *wcn,\r\nstruct ieee80211_vif *vif,\r\nvoid *buf,\r\nsize_t len)\r\n{\r\nstruct wcn36xx_hal_add_sta_self_rsp_msg *rsp;\r\nstruct wcn36xx_vif *vif_priv = wcn36xx_vif_to_priv(vif);\r\nif (len < sizeof(*rsp))\r\nreturn -EINVAL;\r\nrsp = (struct wcn36xx_hal_add_sta_self_rsp_msg *)buf;\r\nif (rsp->status != WCN36XX_FW_MSG_RESULT_SUCCESS) {\r\nwcn36xx_warn("hal add sta self failure: %d\n",\r\nrsp->status);\r\nreturn rsp->status;\r\n}\r\nwcn36xx_dbg(WCN36XX_DBG_HAL,\r\n"hal add sta self status %d self_sta_index %d dpu_index %d\n",\r\nrsp->status, rsp->self_sta_index, rsp->dpu_index);\r\nvif_priv->self_sta_index = rsp->self_sta_index;\r\nvif_priv->self_dpu_desc_index = rsp->dpu_index;\r\nreturn 0;\r\n}\r\nint wcn36xx_smd_add_sta_self(struct wcn36xx *wcn, struct ieee80211_vif *vif)\r\n{\r\nstruct wcn36xx_hal_add_sta_self_req msg_body;\r\nint ret = 0;\r\nmutex_lock(&wcn->hal_mutex);\r\nINIT_HAL_MSG(msg_body, WCN36XX_HAL_ADD_STA_SELF_REQ);\r\nmemcpy(&msg_body.self_addr, vif->addr, ETH_ALEN);\r\nPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\r\nwcn36xx_dbg(WCN36XX_DBG_HAL,\r\n"hal add sta self self_addr %pM status %d\n",\r\nmsg_body.self_addr, msg_body.status);\r\nret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\r\nif (ret) {\r\nwcn36xx_err("Sending hal_add_sta_self failed\n");\r\ngoto out;\r\n}\r\nret = wcn36xx_smd_add_sta_self_rsp(wcn,\r\nvif,\r\nwcn->hal_buf,\r\nwcn->hal_rsp_len);\r\nif (ret) {\r\nwcn36xx_err("hal_add_sta_self response failed err=%d\n", ret);\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&wcn->hal_mutex);\r\nreturn ret;\r\n}\r\nint wcn36xx_smd_delete_sta_self(struct wcn36xx *wcn, u8 *addr)\r\n{\r\nstruct wcn36xx_hal_del_sta_self_req_msg msg_body;\r\nint ret = 0;\r\nmutex_lock(&wcn->hal_mutex);\r\nINIT_HAL_MSG(msg_body, WCN36XX_HAL_DEL_STA_SELF_REQ);\r\nmemcpy(&msg_body.self_addr, addr, ETH_ALEN);\r\nPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\r\nret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\r\nif (ret) {\r\nwcn36xx_err("Sending hal_delete_sta_self failed\n");\r\ngoto out;\r\n}\r\nret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\r\nif (ret) {\r\nwcn36xx_err("hal_delete_sta_self response failed err=%d\n",\r\nret);\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&wcn->hal_mutex);\r\nreturn ret;\r\n}\r\nint wcn36xx_smd_delete_sta(struct wcn36xx *wcn, u8 sta_index)\r\n{\r\nstruct wcn36xx_hal_delete_sta_req_msg msg_body;\r\nint ret = 0;\r\nmutex_lock(&wcn->hal_mutex);\r\nINIT_HAL_MSG(msg_body, WCN36XX_HAL_DELETE_STA_REQ);\r\nmsg_body.sta_index = sta_index;\r\nPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\r\nwcn36xx_dbg(WCN36XX_DBG_HAL,\r\n"hal delete sta sta_index %d\n",\r\nmsg_body.sta_index);\r\nret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\r\nif (ret) {\r\nwcn36xx_err("Sending hal_delete_sta failed\n");\r\ngoto out;\r\n}\r\nret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\r\nif (ret) {\r\nwcn36xx_err("hal_delete_sta response failed err=%d\n", ret);\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&wcn->hal_mutex);\r\nreturn ret;\r\n}\r\nstatic int wcn36xx_smd_join_rsp(void *buf, size_t len)\r\n{\r\nstruct wcn36xx_hal_join_rsp_msg *rsp;\r\nif (wcn36xx_smd_rsp_status_check(buf, len))\r\nreturn -EIO;\r\nrsp = (struct wcn36xx_hal_join_rsp_msg *)buf;\r\nwcn36xx_dbg(WCN36XX_DBG_HAL,\r\n"hal rsp join status %d tx_mgmt_power %d\n",\r\nrsp->status, rsp->tx_mgmt_power);\r\nreturn 0;\r\n}\r\nint wcn36xx_smd_join(struct wcn36xx *wcn, const u8 *bssid, u8 *vif, u8 ch)\r\n{\r\nstruct wcn36xx_hal_join_req_msg msg_body;\r\nint ret = 0;\r\nmutex_lock(&wcn->hal_mutex);\r\nINIT_HAL_MSG(msg_body, WCN36XX_HAL_JOIN_REQ);\r\nmemcpy(&msg_body.bssid, bssid, ETH_ALEN);\r\nmemcpy(&msg_body.self_sta_mac_addr, vif, ETH_ALEN);\r\nmsg_body.channel = ch;\r\nif (conf_is_ht40_minus(&wcn->hw->conf))\r\nmsg_body.secondary_channel_offset =\r\nPHY_DOUBLE_CHANNEL_HIGH_PRIMARY;\r\nelse if (conf_is_ht40_plus(&wcn->hw->conf))\r\nmsg_body.secondary_channel_offset =\r\nPHY_DOUBLE_CHANNEL_LOW_PRIMARY;\r\nelse\r\nmsg_body.secondary_channel_offset =\r\nPHY_SINGLE_CHANNEL_CENTERED;\r\nmsg_body.link_state = WCN36XX_HAL_LINK_PREASSOC_STATE;\r\nmsg_body.max_tx_power = 0xbf;\r\nPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\r\nwcn36xx_dbg(WCN36XX_DBG_HAL,\r\n"hal join req bssid %pM self_sta_mac_addr %pM channel %d link_state %d\n",\r\nmsg_body.bssid, msg_body.self_sta_mac_addr,\r\nmsg_body.channel, msg_body.link_state);\r\nret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\r\nif (ret) {\r\nwcn36xx_err("Sending hal_join failed\n");\r\ngoto out;\r\n}\r\nret = wcn36xx_smd_join_rsp(wcn->hal_buf, wcn->hal_rsp_len);\r\nif (ret) {\r\nwcn36xx_err("hal_join response failed err=%d\n", ret);\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&wcn->hal_mutex);\r\nreturn ret;\r\n}\r\nint wcn36xx_smd_set_link_st(struct wcn36xx *wcn, const u8 *bssid,\r\nconst u8 *sta_mac,\r\nenum wcn36xx_hal_link_state state)\r\n{\r\nstruct wcn36xx_hal_set_link_state_req_msg msg_body;\r\nint ret = 0;\r\nmutex_lock(&wcn->hal_mutex);\r\nINIT_HAL_MSG(msg_body, WCN36XX_HAL_SET_LINK_ST_REQ);\r\nmemcpy(&msg_body.bssid, bssid, ETH_ALEN);\r\nmemcpy(&msg_body.self_mac_addr, sta_mac, ETH_ALEN);\r\nmsg_body.state = state;\r\nPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\r\nwcn36xx_dbg(WCN36XX_DBG_HAL,\r\n"hal set link state bssid %pM self_mac_addr %pM state %d\n",\r\nmsg_body.bssid, msg_body.self_mac_addr, msg_body.state);\r\nret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\r\nif (ret) {\r\nwcn36xx_err("Sending hal_set_link_st failed\n");\r\ngoto out;\r\n}\r\nret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\r\nif (ret) {\r\nwcn36xx_err("hal_set_link_st response failed err=%d\n", ret);\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&wcn->hal_mutex);\r\nreturn ret;\r\n}\r\nstatic void wcn36xx_smd_convert_sta_to_v1(struct wcn36xx *wcn,\r\nconst struct wcn36xx_hal_config_sta_params *orig,\r\nstruct wcn36xx_hal_config_sta_params_v1 *v1)\r\n{\r\nmemcpy(&v1->bssid, orig->bssid, ETH_ALEN);\r\nmemcpy(&v1->mac, orig->mac, ETH_ALEN);\r\nv1->aid = orig->aid;\r\nv1->type = orig->type;\r\nv1->short_preamble_supported = orig->short_preamble_supported;\r\nv1->listen_interval = orig->listen_interval;\r\nv1->wmm_enabled = orig->wmm_enabled;\r\nv1->ht_capable = orig->ht_capable;\r\nv1->tx_channel_width_set = orig->tx_channel_width_set;\r\nv1->rifs_mode = orig->rifs_mode;\r\nv1->lsig_txop_protection = orig->lsig_txop_protection;\r\nv1->max_ampdu_size = orig->max_ampdu_size;\r\nv1->max_ampdu_density = orig->max_ampdu_density;\r\nv1->sgi_40mhz = orig->sgi_40mhz;\r\nv1->sgi_20Mhz = orig->sgi_20Mhz;\r\nv1->rmf = orig->rmf;\r\nv1->encrypt_type = orig->encrypt_type;\r\nv1->action = orig->action;\r\nv1->uapsd = orig->uapsd;\r\nv1->max_sp_len = orig->max_sp_len;\r\nv1->green_field_capable = orig->green_field_capable;\r\nv1->mimo_ps = orig->mimo_ps;\r\nv1->delayed_ba_support = orig->delayed_ba_support;\r\nv1->max_ampdu_duration = orig->max_ampdu_duration;\r\nv1->dsss_cck_mode_40mhz = orig->dsss_cck_mode_40mhz;\r\nmemcpy(&v1->supported_rates, &orig->supported_rates,\r\nsizeof(orig->supported_rates));\r\nv1->sta_index = orig->sta_index;\r\nv1->bssid_index = orig->bssid_index;\r\nv1->p2p = orig->p2p;\r\n}\r\nstatic int wcn36xx_smd_config_sta_rsp(struct wcn36xx *wcn,\r\nstruct ieee80211_sta *sta,\r\nvoid *buf,\r\nsize_t len)\r\n{\r\nstruct wcn36xx_hal_config_sta_rsp_msg *rsp;\r\nstruct config_sta_rsp_params *params;\r\nstruct wcn36xx_sta *sta_priv = wcn36xx_sta_to_priv(sta);\r\nif (len < sizeof(*rsp))\r\nreturn -EINVAL;\r\nrsp = (struct wcn36xx_hal_config_sta_rsp_msg *)buf;\r\nparams = &rsp->params;\r\nif (params->status != WCN36XX_FW_MSG_RESULT_SUCCESS) {\r\nwcn36xx_warn("hal config sta response failure: %d\n",\r\nparams->status);\r\nreturn -EIO;\r\n}\r\nsta_priv->sta_index = params->sta_index;\r\nsta_priv->dpu_desc_index = params->dpu_index;\r\nsta_priv->ucast_dpu_sign = params->uc_ucast_sig;\r\nwcn36xx_dbg(WCN36XX_DBG_HAL,\r\n"hal config sta rsp status %d sta_index %d bssid_index %d uc_ucast_sig %d p2p %d\n",\r\nparams->status, params->sta_index, params->bssid_index,\r\nparams->uc_ucast_sig, params->p2p);\r\nreturn 0;\r\n}\r\nstatic int wcn36xx_smd_config_sta_v1(struct wcn36xx *wcn,\r\nconst struct wcn36xx_hal_config_sta_req_msg *orig)\r\n{\r\nstruct wcn36xx_hal_config_sta_req_msg_v1 msg_body;\r\nstruct wcn36xx_hal_config_sta_params_v1 *sta = &msg_body.sta_params;\r\nINIT_HAL_MSG(msg_body, WCN36XX_HAL_CONFIG_STA_REQ);\r\nwcn36xx_smd_convert_sta_to_v1(wcn, &orig->sta_params,\r\n&msg_body.sta_params);\r\nPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\r\nwcn36xx_dbg(WCN36XX_DBG_HAL,\r\n"hal config sta v1 action %d sta_index %d bssid_index %d bssid %pM type %d mac %pM aid %d\n",\r\nsta->action, sta->sta_index, sta->bssid_index,\r\nsta->bssid, sta->type, sta->mac, sta->aid);\r\nreturn wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\r\n}\r\nint wcn36xx_smd_config_sta(struct wcn36xx *wcn, struct ieee80211_vif *vif,\r\nstruct ieee80211_sta *sta)\r\n{\r\nstruct wcn36xx_hal_config_sta_req_msg msg;\r\nstruct wcn36xx_hal_config_sta_params *sta_params;\r\nint ret = 0;\r\nmutex_lock(&wcn->hal_mutex);\r\nINIT_HAL_MSG(msg, WCN36XX_HAL_CONFIG_STA_REQ);\r\nsta_params = &msg.sta_params;\r\nwcn36xx_smd_set_sta_params(wcn, vif, sta, sta_params);\r\nif (!wcn36xx_is_fw_version(wcn, 1, 2, 2, 24)) {\r\nret = wcn36xx_smd_config_sta_v1(wcn, &msg);\r\n} else {\r\nPREPARE_HAL_BUF(wcn->hal_buf, msg);\r\nwcn36xx_dbg(WCN36XX_DBG_HAL,\r\n"hal config sta action %d sta_index %d bssid_index %d bssid %pM type %d mac %pM aid %d\n",\r\nsta_params->action, sta_params->sta_index,\r\nsta_params->bssid_index, sta_params->bssid,\r\nsta_params->type, sta_params->mac, sta_params->aid);\r\nret = wcn36xx_smd_send_and_wait(wcn, msg.header.len);\r\n}\r\nif (ret) {\r\nwcn36xx_err("Sending hal_config_sta failed\n");\r\ngoto out;\r\n}\r\nret = wcn36xx_smd_config_sta_rsp(wcn,\r\nsta,\r\nwcn->hal_buf,\r\nwcn->hal_rsp_len);\r\nif (ret) {\r\nwcn36xx_err("hal_config_sta response failed err=%d\n", ret);\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&wcn->hal_mutex);\r\nreturn ret;\r\n}\r\nstatic int wcn36xx_smd_config_bss_v1(struct wcn36xx *wcn,\r\nconst struct wcn36xx_hal_config_bss_req_msg *orig)\r\n{\r\nstruct wcn36xx_hal_config_bss_req_msg_v1 msg_body;\r\nstruct wcn36xx_hal_config_bss_params_v1 *bss = &msg_body.bss_params;\r\nstruct wcn36xx_hal_config_sta_params_v1 *sta = &bss->sta;\r\nINIT_HAL_MSG(msg_body, WCN36XX_HAL_CONFIG_BSS_REQ);\r\nmemcpy(&msg_body.bss_params.bssid,\r\n&orig->bss_params.bssid, ETH_ALEN);\r\nmemcpy(&msg_body.bss_params.self_mac_addr,\r\n&orig->bss_params.self_mac_addr, ETH_ALEN);\r\nmsg_body.bss_params.bss_type = orig->bss_params.bss_type;\r\nmsg_body.bss_params.oper_mode = orig->bss_params.oper_mode;\r\nmsg_body.bss_params.nw_type = orig->bss_params.nw_type;\r\nmsg_body.bss_params.short_slot_time_supported =\r\norig->bss_params.short_slot_time_supported;\r\nmsg_body.bss_params.lla_coexist = orig->bss_params.lla_coexist;\r\nmsg_body.bss_params.llb_coexist = orig->bss_params.llb_coexist;\r\nmsg_body.bss_params.llg_coexist = orig->bss_params.llg_coexist;\r\nmsg_body.bss_params.ht20_coexist = orig->bss_params.ht20_coexist;\r\nmsg_body.bss_params.lln_non_gf_coexist =\r\norig->bss_params.lln_non_gf_coexist;\r\nmsg_body.bss_params.lsig_tx_op_protection_full_support =\r\norig->bss_params.lsig_tx_op_protection_full_support;\r\nmsg_body.bss_params.rifs_mode = orig->bss_params.rifs_mode;\r\nmsg_body.bss_params.beacon_interval = orig->bss_params.beacon_interval;\r\nmsg_body.bss_params.dtim_period = orig->bss_params.dtim_period;\r\nmsg_body.bss_params.tx_channel_width_set =\r\norig->bss_params.tx_channel_width_set;\r\nmsg_body.bss_params.oper_channel = orig->bss_params.oper_channel;\r\nmsg_body.bss_params.ext_channel = orig->bss_params.ext_channel;\r\nmsg_body.bss_params.reserved = orig->bss_params.reserved;\r\nmemcpy(&msg_body.bss_params.ssid,\r\n&orig->bss_params.ssid,\r\nsizeof(orig->bss_params.ssid));\r\nmsg_body.bss_params.action = orig->bss_params.action;\r\nmsg_body.bss_params.rateset = orig->bss_params.rateset;\r\nmsg_body.bss_params.ht = orig->bss_params.ht;\r\nmsg_body.bss_params.obss_prot_enabled =\r\norig->bss_params.obss_prot_enabled;\r\nmsg_body.bss_params.rmf = orig->bss_params.rmf;\r\nmsg_body.bss_params.ht_oper_mode = orig->bss_params.ht_oper_mode;\r\nmsg_body.bss_params.dual_cts_protection =\r\norig->bss_params.dual_cts_protection;\r\nmsg_body.bss_params.max_probe_resp_retry_limit =\r\norig->bss_params.max_probe_resp_retry_limit;\r\nmsg_body.bss_params.hidden_ssid = orig->bss_params.hidden_ssid;\r\nmsg_body.bss_params.proxy_probe_resp =\r\norig->bss_params.proxy_probe_resp;\r\nmsg_body.bss_params.edca_params_valid =\r\norig->bss_params.edca_params_valid;\r\nmemcpy(&msg_body.bss_params.acbe,\r\n&orig->bss_params.acbe,\r\nsizeof(orig->bss_params.acbe));\r\nmemcpy(&msg_body.bss_params.acbk,\r\n&orig->bss_params.acbk,\r\nsizeof(orig->bss_params.acbk));\r\nmemcpy(&msg_body.bss_params.acvi,\r\n&orig->bss_params.acvi,\r\nsizeof(orig->bss_params.acvi));\r\nmemcpy(&msg_body.bss_params.acvo,\r\n&orig->bss_params.acvo,\r\nsizeof(orig->bss_params.acvo));\r\nmsg_body.bss_params.ext_set_sta_key_param_valid =\r\norig->bss_params.ext_set_sta_key_param_valid;\r\nmemcpy(&msg_body.bss_params.ext_set_sta_key_param,\r\n&orig->bss_params.ext_set_sta_key_param,\r\nsizeof(orig->bss_params.acvo));\r\nmsg_body.bss_params.wcn36xx_hal_persona =\r\norig->bss_params.wcn36xx_hal_persona;\r\nmsg_body.bss_params.spectrum_mgt_enable =\r\norig->bss_params.spectrum_mgt_enable;\r\nmsg_body.bss_params.tx_mgmt_power = orig->bss_params.tx_mgmt_power;\r\nmsg_body.bss_params.max_tx_power = orig->bss_params.max_tx_power;\r\nwcn36xx_smd_convert_sta_to_v1(wcn, &orig->bss_params.sta,\r\n&msg_body.bss_params.sta);\r\nPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\r\nwcn36xx_dbg(WCN36XX_DBG_HAL,\r\n"hal config bss v1 bssid %pM self_mac_addr %pM bss_type %d oper_mode %d nw_type %d\n",\r\nbss->bssid, bss->self_mac_addr, bss->bss_type,\r\nbss->oper_mode, bss->nw_type);\r\nwcn36xx_dbg(WCN36XX_DBG_HAL,\r\n"- sta bssid %pM action %d sta_index %d bssid_index %d aid %d type %d mac %pM\n",\r\nsta->bssid, sta->action, sta->sta_index,\r\nsta->bssid_index, sta->aid, sta->type, sta->mac);\r\nreturn wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\r\n}\r\nstatic int wcn36xx_smd_config_bss_rsp(struct wcn36xx *wcn,\r\nstruct ieee80211_vif *vif,\r\nstruct ieee80211_sta *sta,\r\nvoid *buf,\r\nsize_t len)\r\n{\r\nstruct wcn36xx_hal_config_bss_rsp_msg *rsp;\r\nstruct wcn36xx_hal_config_bss_rsp_params *params;\r\nstruct wcn36xx_vif *vif_priv = wcn36xx_vif_to_priv(vif);\r\nif (len < sizeof(*rsp))\r\nreturn -EINVAL;\r\nrsp = (struct wcn36xx_hal_config_bss_rsp_msg *)buf;\r\nparams = &rsp->bss_rsp_params;\r\nif (params->status != WCN36XX_FW_MSG_RESULT_SUCCESS) {\r\nwcn36xx_warn("hal config bss response failure: %d\n",\r\nparams->status);\r\nreturn -EIO;\r\n}\r\nwcn36xx_dbg(WCN36XX_DBG_HAL,\r\n"hal config bss rsp status %d bss_idx %d dpu_desc_index %d"\r\n" sta_idx %d self_idx %d bcast_idx %d mac %pM"\r\n" power %d ucast_dpu_signature %d\n",\r\nparams->status, params->bss_index, params->dpu_desc_index,\r\nparams->bss_sta_index, params->bss_self_sta_index,\r\nparams->bss_bcast_sta_idx, params->mac,\r\nparams->tx_mgmt_power, params->ucast_dpu_signature);\r\nvif_priv->bss_index = params->bss_index;\r\nif (sta) {\r\nstruct wcn36xx_sta *sta_priv = wcn36xx_sta_to_priv(sta);\r\nsta_priv->bss_sta_index = params->bss_sta_index;\r\nsta_priv->bss_dpu_desc_index = params->dpu_desc_index;\r\n}\r\nvif_priv->self_ucast_dpu_sign = params->ucast_dpu_signature;\r\nreturn 0;\r\n}\r\nint wcn36xx_smd_config_bss(struct wcn36xx *wcn, struct ieee80211_vif *vif,\r\nstruct ieee80211_sta *sta, const u8 *bssid,\r\nbool update)\r\n{\r\nstruct wcn36xx_hal_config_bss_req_msg msg;\r\nstruct wcn36xx_hal_config_bss_params *bss;\r\nstruct wcn36xx_hal_config_sta_params *sta_params;\r\nstruct wcn36xx_vif *vif_priv = wcn36xx_vif_to_priv(vif);\r\nint ret = 0;\r\nmutex_lock(&wcn->hal_mutex);\r\nINIT_HAL_MSG(msg, WCN36XX_HAL_CONFIG_BSS_REQ);\r\nbss = &msg.bss_params;\r\nsta_params = &bss->sta;\r\nWARN_ON(is_zero_ether_addr(bssid));\r\nmemcpy(&bss->bssid, bssid, ETH_ALEN);\r\nmemcpy(bss->self_mac_addr, vif->addr, ETH_ALEN);\r\nif (vif->type == NL80211_IFTYPE_STATION) {\r\nbss->bss_type = WCN36XX_HAL_INFRASTRUCTURE_MODE;\r\nbss->oper_mode = 1;\r\nbss->wcn36xx_hal_persona = WCN36XX_HAL_STA_MODE;\r\n} else if (vif->type == NL80211_IFTYPE_AP ||\r\nvif->type == NL80211_IFTYPE_MESH_POINT) {\r\nbss->bss_type = WCN36XX_HAL_INFRA_AP_MODE;\r\nbss->oper_mode = 0;\r\nbss->wcn36xx_hal_persona = WCN36XX_HAL_STA_SAP_MODE;\r\n} else if (vif->type == NL80211_IFTYPE_ADHOC) {\r\nbss->bss_type = WCN36XX_HAL_IBSS_MODE;\r\nbss->oper_mode = 1;\r\n} else {\r\nwcn36xx_warn("Unknown type for bss config: %d\n", vif->type);\r\n}\r\nif (vif->type == NL80211_IFTYPE_STATION)\r\nwcn36xx_smd_set_bss_nw_type(wcn, sta, bss);\r\nelse\r\nbss->nw_type = WCN36XX_HAL_11N_NW_TYPE;\r\nbss->short_slot_time_supported = vif->bss_conf.use_short_slot;\r\nbss->lla_coexist = 0;\r\nbss->llb_coexist = 0;\r\nbss->llg_coexist = 0;\r\nbss->rifs_mode = 0;\r\nbss->beacon_interval = vif->bss_conf.beacon_int;\r\nbss->dtim_period = vif_priv->dtim_period;\r\nwcn36xx_smd_set_bss_ht_params(vif, sta, bss);\r\nbss->oper_channel = WCN36XX_HW_CHANNEL(wcn);\r\nif (conf_is_ht40_minus(&wcn->hw->conf))\r\nbss->ext_channel = IEEE80211_HT_PARAM_CHA_SEC_BELOW;\r\nelse if (conf_is_ht40_plus(&wcn->hw->conf))\r\nbss->ext_channel = IEEE80211_HT_PARAM_CHA_SEC_ABOVE;\r\nelse\r\nbss->ext_channel = IEEE80211_HT_PARAM_CHA_SEC_NONE;\r\nbss->reserved = 0;\r\nwcn36xx_smd_set_sta_params(wcn, vif, sta, sta_params);\r\nbss->ssid.length = vif_priv->ssid.length;\r\nmemcpy(bss->ssid.ssid, vif_priv->ssid.ssid, vif_priv->ssid.length);\r\nbss->obss_prot_enabled = 0;\r\nbss->rmf = 0;\r\nbss->max_probe_resp_retry_limit = 0;\r\nbss->hidden_ssid = vif->bss_conf.hidden_ssid;\r\nbss->proxy_probe_resp = 0;\r\nbss->edca_params_valid = 0;\r\nbss->ext_set_sta_key_param_valid = 0;\r\nbss->spectrum_mgt_enable = 0;\r\nbss->tx_mgmt_power = 0;\r\nbss->max_tx_power = WCN36XX_MAX_POWER(wcn);\r\nbss->action = update;\r\nwcn36xx_dbg(WCN36XX_DBG_HAL,\r\n"hal config bss bssid %pM self_mac_addr %pM bss_type %d oper_mode %d nw_type %d\n",\r\nbss->bssid, bss->self_mac_addr, bss->bss_type,\r\nbss->oper_mode, bss->nw_type);\r\nwcn36xx_dbg(WCN36XX_DBG_HAL,\r\n"- sta bssid %pM action %d sta_index %d bssid_index %d aid %d type %d mac %pM\n",\r\nsta_params->bssid, sta_params->action,\r\nsta_params->sta_index, sta_params->bssid_index,\r\nsta_params->aid, sta_params->type,\r\nsta_params->mac);\r\nif (!wcn36xx_is_fw_version(wcn, 1, 2, 2, 24)) {\r\nret = wcn36xx_smd_config_bss_v1(wcn, &msg);\r\n} else {\r\nPREPARE_HAL_BUF(wcn->hal_buf, msg);\r\nret = wcn36xx_smd_send_and_wait(wcn, msg.header.len);\r\n}\r\nif (ret) {\r\nwcn36xx_err("Sending hal_config_bss failed\n");\r\ngoto out;\r\n}\r\nret = wcn36xx_smd_config_bss_rsp(wcn,\r\nvif,\r\nsta,\r\nwcn->hal_buf,\r\nwcn->hal_rsp_len);\r\nif (ret) {\r\nwcn36xx_err("hal_config_bss response failed err=%d\n", ret);\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&wcn->hal_mutex);\r\nreturn ret;\r\n}\r\nint wcn36xx_smd_delete_bss(struct wcn36xx *wcn, struct ieee80211_vif *vif)\r\n{\r\nstruct wcn36xx_hal_delete_bss_req_msg msg_body;\r\nstruct wcn36xx_vif *vif_priv = wcn36xx_vif_to_priv(vif);\r\nint ret = 0;\r\nmutex_lock(&wcn->hal_mutex);\r\nINIT_HAL_MSG(msg_body, WCN36XX_HAL_DELETE_BSS_REQ);\r\nmsg_body.bss_index = vif_priv->bss_index;\r\nPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\r\nwcn36xx_dbg(WCN36XX_DBG_HAL, "hal delete bss %d\n", msg_body.bss_index);\r\nret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\r\nif (ret) {\r\nwcn36xx_err("Sending hal_delete_bss failed\n");\r\ngoto out;\r\n}\r\nret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\r\nif (ret) {\r\nwcn36xx_err("hal_delete_bss response failed err=%d\n", ret);\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&wcn->hal_mutex);\r\nreturn ret;\r\n}\r\nint wcn36xx_smd_send_beacon(struct wcn36xx *wcn, struct ieee80211_vif *vif,\r\nstruct sk_buff *skb_beacon, u16 tim_off,\r\nu16 p2p_off)\r\n{\r\nstruct wcn36xx_hal_send_beacon_req_msg msg_body;\r\nint ret = 0, pad, pvm_len;\r\nmutex_lock(&wcn->hal_mutex);\r\nINIT_HAL_MSG(msg_body, WCN36XX_HAL_SEND_BEACON_REQ);\r\npvm_len = skb_beacon->data[tim_off + 1] - 3;\r\npad = TIM_MIN_PVM_SIZE - pvm_len;\r\nif (vif->type == NL80211_IFTYPE_MESH_POINT)\r\npad = 0;\r\nmsg_body.beacon_length = skb_beacon->len + pad;\r\nmsg_body.beacon_length6 = msg_body.beacon_length + 6;\r\nif (msg_body.beacon_length > BEACON_TEMPLATE_SIZE) {\r\nwcn36xx_err("Beacon is to big: beacon size=%d\n",\r\nmsg_body.beacon_length);\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nmemcpy(msg_body.beacon, skb_beacon->data, skb_beacon->len);\r\nmemcpy(msg_body.bssid, vif->addr, ETH_ALEN);\r\nif (pad > 0) {\r\nwcn36xx_dbg(WCN36XX_DBG_HAL, "Pad TIM PVM. %d bytes at %d\n",\r\npad, pvm_len);\r\nmemmove(&msg_body.beacon[tim_off + 5 + pvm_len + pad],\r\n&msg_body.beacon[tim_off + 5 + pvm_len],\r\nskb_beacon->len - (tim_off + 5 + pvm_len));\r\nmemset(&msg_body.beacon[tim_off + 5 + pvm_len], 0, pad);\r\nmsg_body.beacon[tim_off + 1] += pad;\r\n}\r\nif (vif->type == NL80211_IFTYPE_MESH_POINT)\r\nmsg_body.tim_ie_offset = 256;\r\nelse\r\nmsg_body.tim_ie_offset = tim_off+4;\r\nmsg_body.p2p_ie_offset = p2p_off;\r\nPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\r\nwcn36xx_dbg(WCN36XX_DBG_HAL,\r\n"hal send beacon beacon_length %d\n",\r\nmsg_body.beacon_length);\r\nret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\r\nif (ret) {\r\nwcn36xx_err("Sending hal_send_beacon failed\n");\r\ngoto out;\r\n}\r\nret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\r\nif (ret) {\r\nwcn36xx_err("hal_send_beacon response failed err=%d\n", ret);\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&wcn->hal_mutex);\r\nreturn ret;\r\n}\r\nint wcn36xx_smd_update_proberesp_tmpl(struct wcn36xx *wcn,\r\nstruct ieee80211_vif *vif,\r\nstruct sk_buff *skb)\r\n{\r\nstruct wcn36xx_hal_send_probe_resp_req_msg msg;\r\nint ret = 0;\r\nmutex_lock(&wcn->hal_mutex);\r\nINIT_HAL_MSG(msg, WCN36XX_HAL_UPDATE_PROBE_RSP_TEMPLATE_REQ);\r\nif (skb->len > BEACON_TEMPLATE_SIZE) {\r\nwcn36xx_warn("probe response template is too big: %d\n",\r\nskb->len);\r\nret = -E2BIG;\r\ngoto out;\r\n}\r\nmsg.probe_resp_template_len = skb->len;\r\nmemcpy(&msg.probe_resp_template, skb->data, skb->len);\r\nmemcpy(msg.bssid, vif->addr, ETH_ALEN);\r\nPREPARE_HAL_BUF(wcn->hal_buf, msg);\r\nwcn36xx_dbg(WCN36XX_DBG_HAL,\r\n"hal update probe rsp len %d bssid %pM\n",\r\nmsg.probe_resp_template_len, msg.bssid);\r\nret = wcn36xx_smd_send_and_wait(wcn, msg.header.len);\r\nif (ret) {\r\nwcn36xx_err("Sending hal_update_proberesp_tmpl failed\n");\r\ngoto out;\r\n}\r\nret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\r\nif (ret) {\r\nwcn36xx_err("hal_update_proberesp_tmpl response failed err=%d\n",\r\nret);\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&wcn->hal_mutex);\r\nreturn ret;\r\n}\r\nint wcn36xx_smd_set_stakey(struct wcn36xx *wcn,\r\nenum ani_ed_type enc_type,\r\nu8 keyidx,\r\nu8 keylen,\r\nu8 *key,\r\nu8 sta_index)\r\n{\r\nstruct wcn36xx_hal_set_sta_key_req_msg msg_body;\r\nint ret = 0;\r\nmutex_lock(&wcn->hal_mutex);\r\nINIT_HAL_MSG(msg_body, WCN36XX_HAL_SET_STAKEY_REQ);\r\nmsg_body.set_sta_key_params.sta_index = sta_index;\r\nmsg_body.set_sta_key_params.enc_type = enc_type;\r\nmsg_body.set_sta_key_params.key[0].id = keyidx;\r\nmsg_body.set_sta_key_params.key[0].unicast = 1;\r\nmsg_body.set_sta_key_params.key[0].direction = WCN36XX_HAL_TX_RX;\r\nmsg_body.set_sta_key_params.key[0].pae_role = 0;\r\nmsg_body.set_sta_key_params.key[0].length = keylen;\r\nmemcpy(msg_body.set_sta_key_params.key[0].key, key, keylen);\r\nmsg_body.set_sta_key_params.single_tid_rc = 1;\r\nPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\r\nret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\r\nif (ret) {\r\nwcn36xx_err("Sending hal_set_stakey failed\n");\r\ngoto out;\r\n}\r\nret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\r\nif (ret) {\r\nwcn36xx_err("hal_set_stakey response failed err=%d\n", ret);\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&wcn->hal_mutex);\r\nreturn ret;\r\n}\r\nint wcn36xx_smd_set_bsskey(struct wcn36xx *wcn,\r\nenum ani_ed_type enc_type,\r\nu8 keyidx,\r\nu8 keylen,\r\nu8 *key)\r\n{\r\nstruct wcn36xx_hal_set_bss_key_req_msg msg_body;\r\nint ret = 0;\r\nmutex_lock(&wcn->hal_mutex);\r\nINIT_HAL_MSG(msg_body, WCN36XX_HAL_SET_BSSKEY_REQ);\r\nmsg_body.bss_idx = 0;\r\nmsg_body.enc_type = enc_type;\r\nmsg_body.num_keys = 1;\r\nmsg_body.keys[0].id = keyidx;\r\nmsg_body.keys[0].unicast = 0;\r\nmsg_body.keys[0].direction = WCN36XX_HAL_RX_ONLY;\r\nmsg_body.keys[0].pae_role = 0;\r\nmsg_body.keys[0].length = keylen;\r\nmemcpy(msg_body.keys[0].key, key, keylen);\r\nPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\r\nret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\r\nif (ret) {\r\nwcn36xx_err("Sending hal_set_bsskey failed\n");\r\ngoto out;\r\n}\r\nret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\r\nif (ret) {\r\nwcn36xx_err("hal_set_bsskey response failed err=%d\n", ret);\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&wcn->hal_mutex);\r\nreturn ret;\r\n}\r\nint wcn36xx_smd_remove_stakey(struct wcn36xx *wcn,\r\nenum ani_ed_type enc_type,\r\nu8 keyidx,\r\nu8 sta_index)\r\n{\r\nstruct wcn36xx_hal_remove_sta_key_req_msg msg_body;\r\nint ret = 0;\r\nmutex_lock(&wcn->hal_mutex);\r\nINIT_HAL_MSG(msg_body, WCN36XX_HAL_RMV_STAKEY_REQ);\r\nmsg_body.sta_idx = sta_index;\r\nmsg_body.enc_type = enc_type;\r\nmsg_body.key_id = keyidx;\r\nPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\r\nret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\r\nif (ret) {\r\nwcn36xx_err("Sending hal_remove_stakey failed\n");\r\ngoto out;\r\n}\r\nret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\r\nif (ret) {\r\nwcn36xx_err("hal_remove_stakey response failed err=%d\n", ret);\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&wcn->hal_mutex);\r\nreturn ret;\r\n}\r\nint wcn36xx_smd_remove_bsskey(struct wcn36xx *wcn,\r\nenum ani_ed_type enc_type,\r\nu8 keyidx)\r\n{\r\nstruct wcn36xx_hal_remove_bss_key_req_msg msg_body;\r\nint ret = 0;\r\nmutex_lock(&wcn->hal_mutex);\r\nINIT_HAL_MSG(msg_body, WCN36XX_HAL_RMV_BSSKEY_REQ);\r\nmsg_body.bss_idx = 0;\r\nmsg_body.enc_type = enc_type;\r\nmsg_body.key_id = keyidx;\r\nPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\r\nret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\r\nif (ret) {\r\nwcn36xx_err("Sending hal_remove_bsskey failed\n");\r\ngoto out;\r\n}\r\nret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\r\nif (ret) {\r\nwcn36xx_err("hal_remove_bsskey response failed err=%d\n", ret);\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&wcn->hal_mutex);\r\nreturn ret;\r\n}\r\nint wcn36xx_smd_enter_bmps(struct wcn36xx *wcn, struct ieee80211_vif *vif)\r\n{\r\nstruct wcn36xx_hal_enter_bmps_req_msg msg_body;\r\nstruct wcn36xx_vif *vif_priv = wcn36xx_vif_to_priv(vif);\r\nint ret = 0;\r\nmutex_lock(&wcn->hal_mutex);\r\nINIT_HAL_MSG(msg_body, WCN36XX_HAL_ENTER_BMPS_REQ);\r\nmsg_body.bss_index = vif_priv->bss_index;\r\nmsg_body.tbtt = vif->bss_conf.sync_tsf;\r\nmsg_body.dtim_period = vif_priv->dtim_period;\r\nPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\r\nret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\r\nif (ret) {\r\nwcn36xx_err("Sending hal_enter_bmps failed\n");\r\ngoto out;\r\n}\r\nret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\r\nif (ret) {\r\nwcn36xx_err("hal_enter_bmps response failed err=%d\n", ret);\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&wcn->hal_mutex);\r\nreturn ret;\r\n}\r\nint wcn36xx_smd_exit_bmps(struct wcn36xx *wcn, struct ieee80211_vif *vif)\r\n{\r\nstruct wcn36xx_hal_exit_bmps_req_msg msg_body;\r\nstruct wcn36xx_vif *vif_priv = wcn36xx_vif_to_priv(vif);\r\nint ret = 0;\r\nmutex_lock(&wcn->hal_mutex);\r\nINIT_HAL_MSG(msg_body, WCN36XX_HAL_EXIT_BMPS_REQ);\r\nmsg_body.bss_index = vif_priv->bss_index;\r\nPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\r\nret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\r\nif (ret) {\r\nwcn36xx_err("Sending hal_exit_bmps failed\n");\r\ngoto out;\r\n}\r\nret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\r\nif (ret) {\r\nwcn36xx_err("hal_exit_bmps response failed err=%d\n", ret);\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&wcn->hal_mutex);\r\nreturn ret;\r\n}\r\nint wcn36xx_smd_set_power_params(struct wcn36xx *wcn, bool ignore_dtim)\r\n{\r\nstruct wcn36xx_hal_set_power_params_req_msg msg_body;\r\nint ret = 0;\r\nmutex_lock(&wcn->hal_mutex);\r\nINIT_HAL_MSG(msg_body, WCN36XX_HAL_SET_POWER_PARAMS_REQ);\r\nif (ignore_dtim) {\r\nmsg_body.ignore_dtim = 1;\r\nmsg_body.dtim_period = 2;\r\n}\r\nmsg_body.listen_interval = WCN36XX_LISTEN_INTERVAL(wcn);\r\nPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\r\nret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\r\nif (ret) {\r\nwcn36xx_err("Sending hal_set_power_params failed\n");\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&wcn->hal_mutex);\r\nreturn ret;\r\n}\r\nint wcn36xx_smd_keep_alive_req(struct wcn36xx *wcn,\r\nstruct ieee80211_vif *vif,\r\nint packet_type)\r\n{\r\nstruct wcn36xx_hal_keep_alive_req_msg msg_body;\r\nstruct wcn36xx_vif *vif_priv = wcn36xx_vif_to_priv(vif);\r\nint ret = 0;\r\nmutex_lock(&wcn->hal_mutex);\r\nINIT_HAL_MSG(msg_body, WCN36XX_HAL_KEEP_ALIVE_REQ);\r\nif (packet_type == WCN36XX_HAL_KEEP_ALIVE_NULL_PKT) {\r\nmsg_body.bss_index = vif_priv->bss_index;\r\nmsg_body.packet_type = WCN36XX_HAL_KEEP_ALIVE_NULL_PKT;\r\nmsg_body.time_period = WCN36XX_KEEP_ALIVE_TIME_PERIOD;\r\n} else if (packet_type == WCN36XX_HAL_KEEP_ALIVE_UNSOLICIT_ARP_RSP) {\r\n} else {\r\nwcn36xx_warn("unknown keep alive packet type %d\n", packet_type);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\r\nret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\r\nif (ret) {\r\nwcn36xx_err("Sending hal_keep_alive failed\n");\r\ngoto out;\r\n}\r\nret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\r\nif (ret) {\r\nwcn36xx_err("hal_keep_alive response failed err=%d\n", ret);\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&wcn->hal_mutex);\r\nreturn ret;\r\n}\r\nint wcn36xx_smd_dump_cmd_req(struct wcn36xx *wcn, u32 arg1, u32 arg2,\r\nu32 arg3, u32 arg4, u32 arg5)\r\n{\r\nstruct wcn36xx_hal_dump_cmd_req_msg msg_body;\r\nint ret = 0;\r\nmutex_lock(&wcn->hal_mutex);\r\nINIT_HAL_MSG(msg_body, WCN36XX_HAL_DUMP_COMMAND_REQ);\r\nmsg_body.arg1 = arg1;\r\nmsg_body.arg2 = arg2;\r\nmsg_body.arg3 = arg3;\r\nmsg_body.arg4 = arg4;\r\nmsg_body.arg5 = arg5;\r\nPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\r\nret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\r\nif (ret) {\r\nwcn36xx_err("Sending hal_dump_cmd failed\n");\r\ngoto out;\r\n}\r\nret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\r\nif (ret) {\r\nwcn36xx_err("hal_dump_cmd response failed err=%d\n", ret);\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&wcn->hal_mutex);\r\nreturn ret;\r\n}\r\nvoid set_feat_caps(u32 *bitmap, enum place_holder_in_cap_bitmap cap)\r\n{\r\nint arr_idx, bit_idx;\r\nif (cap < 0 || cap > 127) {\r\nwcn36xx_warn("error cap idx %d\n", cap);\r\nreturn;\r\n}\r\narr_idx = cap / 32;\r\nbit_idx = cap % 32;\r\nbitmap[arr_idx] |= (1 << bit_idx);\r\n}\r\nint get_feat_caps(u32 *bitmap, enum place_holder_in_cap_bitmap cap)\r\n{\r\nint arr_idx, bit_idx;\r\nint ret = 0;\r\nif (cap < 0 || cap > 127) {\r\nwcn36xx_warn("error cap idx %d\n", cap);\r\nreturn -EINVAL;\r\n}\r\narr_idx = cap / 32;\r\nbit_idx = cap % 32;\r\nret = (bitmap[arr_idx] & (1 << bit_idx)) ? 1 : 0;\r\nreturn ret;\r\n}\r\nvoid clear_feat_caps(u32 *bitmap, enum place_holder_in_cap_bitmap cap)\r\n{\r\nint arr_idx, bit_idx;\r\nif (cap < 0 || cap > 127) {\r\nwcn36xx_warn("error cap idx %d\n", cap);\r\nreturn;\r\n}\r\narr_idx = cap / 32;\r\nbit_idx = cap % 32;\r\nbitmap[arr_idx] &= ~(1 << bit_idx);\r\n}\r\nint wcn36xx_smd_feature_caps_exchange(struct wcn36xx *wcn)\r\n{\r\nstruct wcn36xx_hal_feat_caps_msg msg_body, *rsp;\r\nint ret = 0, i;\r\nmutex_lock(&wcn->hal_mutex);\r\nINIT_HAL_MSG(msg_body, WCN36XX_HAL_FEATURE_CAPS_EXCHANGE_REQ);\r\nset_feat_caps(msg_body.feat_caps, STA_POWERSAVE);\r\nPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\r\nret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\r\nif (ret) {\r\nwcn36xx_err("Sending hal_feature_caps_exchange failed\n");\r\ngoto out;\r\n}\r\nif (wcn->hal_rsp_len != sizeof(*rsp)) {\r\nwcn36xx_err("Invalid hal_feature_caps_exchange response");\r\ngoto out;\r\n}\r\nrsp = (struct wcn36xx_hal_feat_caps_msg *) wcn->hal_buf;\r\nfor (i = 0; i < WCN36XX_HAL_CAPS_SIZE; i++)\r\nwcn->fw_feat_caps[i] = rsp->feat_caps[i];\r\nout:\r\nmutex_unlock(&wcn->hal_mutex);\r\nreturn ret;\r\n}\r\nint wcn36xx_smd_add_ba_session(struct wcn36xx *wcn,\r\nstruct ieee80211_sta *sta,\r\nu16 tid,\r\nu16 *ssn,\r\nu8 direction,\r\nu8 sta_index)\r\n{\r\nstruct wcn36xx_hal_add_ba_session_req_msg msg_body;\r\nint ret = 0;\r\nmutex_lock(&wcn->hal_mutex);\r\nINIT_HAL_MSG(msg_body, WCN36XX_HAL_ADD_BA_SESSION_REQ);\r\nmsg_body.sta_index = sta_index;\r\nmemcpy(&msg_body.mac_addr, sta->addr, ETH_ALEN);\r\nmsg_body.dialog_token = 0x10;\r\nmsg_body.tid = tid;\r\nmsg_body.policy = 1;\r\nmsg_body.buffer_size = WCN36XX_AGGR_BUFFER_SIZE;\r\nmsg_body.timeout = 0;\r\nif (ssn)\r\nmsg_body.ssn = *ssn;\r\nmsg_body.direction = direction;\r\nPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\r\nret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\r\nif (ret) {\r\nwcn36xx_err("Sending hal_add_ba_session failed\n");\r\ngoto out;\r\n}\r\nret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\r\nif (ret) {\r\nwcn36xx_err("hal_add_ba_session response failed err=%d\n", ret);\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&wcn->hal_mutex);\r\nreturn ret;\r\n}\r\nint wcn36xx_smd_add_ba(struct wcn36xx *wcn)\r\n{\r\nstruct wcn36xx_hal_add_ba_req_msg msg_body;\r\nint ret = 0;\r\nmutex_lock(&wcn->hal_mutex);\r\nINIT_HAL_MSG(msg_body, WCN36XX_HAL_ADD_BA_REQ);\r\nmsg_body.session_id = 0;\r\nmsg_body.win_size = WCN36XX_AGGR_BUFFER_SIZE;\r\nPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\r\nret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\r\nif (ret) {\r\nwcn36xx_err("Sending hal_add_ba failed\n");\r\ngoto out;\r\n}\r\nret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\r\nif (ret) {\r\nwcn36xx_err("hal_add_ba response failed err=%d\n", ret);\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&wcn->hal_mutex);\r\nreturn ret;\r\n}\r\nint wcn36xx_smd_del_ba(struct wcn36xx *wcn, u16 tid, u8 sta_index)\r\n{\r\nstruct wcn36xx_hal_del_ba_req_msg msg_body;\r\nint ret = 0;\r\nmutex_lock(&wcn->hal_mutex);\r\nINIT_HAL_MSG(msg_body, WCN36XX_HAL_DEL_BA_REQ);\r\nmsg_body.sta_index = sta_index;\r\nmsg_body.tid = tid;\r\nmsg_body.direction = 0;\r\nPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\r\nret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\r\nif (ret) {\r\nwcn36xx_err("Sending hal_del_ba failed\n");\r\ngoto out;\r\n}\r\nret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\r\nif (ret) {\r\nwcn36xx_err("hal_del_ba response failed err=%d\n", ret);\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&wcn->hal_mutex);\r\nreturn ret;\r\n}\r\nstatic int wcn36xx_smd_trigger_ba_rsp(void *buf, int len)\r\n{\r\nstruct wcn36xx_hal_trigger_ba_rsp_msg *rsp;\r\nif (len < sizeof(*rsp))\r\nreturn -EINVAL;\r\nrsp = (struct wcn36xx_hal_trigger_ba_rsp_msg *) buf;\r\nreturn rsp->status;\r\n}\r\nint wcn36xx_smd_trigger_ba(struct wcn36xx *wcn, u8 sta_index)\r\n{\r\nstruct wcn36xx_hal_trigger_ba_req_msg msg_body;\r\nstruct wcn36xx_hal_trigger_ba_req_candidate *candidate;\r\nint ret = 0;\r\nmutex_lock(&wcn->hal_mutex);\r\nINIT_HAL_MSG(msg_body, WCN36XX_HAL_TRIGGER_BA_REQ);\r\nmsg_body.session_id = 0;\r\nmsg_body.candidate_cnt = 1;\r\nmsg_body.header.len += sizeof(*candidate);\r\nPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\r\ncandidate = (struct wcn36xx_hal_trigger_ba_req_candidate *)\r\n(wcn->hal_buf + sizeof(msg_body));\r\ncandidate->sta_index = sta_index;\r\ncandidate->tid_bitmap = 1;\r\nret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\r\nif (ret) {\r\nwcn36xx_err("Sending hal_trigger_ba failed\n");\r\ngoto out;\r\n}\r\nret = wcn36xx_smd_trigger_ba_rsp(wcn->hal_buf, wcn->hal_rsp_len);\r\nif (ret) {\r\nwcn36xx_err("hal_trigger_ba response failed err=%d\n", ret);\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&wcn->hal_mutex);\r\nreturn ret;\r\n}\r\nstatic int wcn36xx_smd_tx_compl_ind(struct wcn36xx *wcn, void *buf, size_t len)\r\n{\r\nstruct wcn36xx_hal_tx_compl_ind_msg *rsp = buf;\r\nif (len != sizeof(*rsp)) {\r\nwcn36xx_warn("Bad TX complete indication\n");\r\nreturn -EIO;\r\n}\r\nwcn36xx_dxe_tx_ack_ind(wcn, rsp->status);\r\nreturn 0;\r\n}\r\nstatic int wcn36xx_smd_missed_beacon_ind(struct wcn36xx *wcn,\r\nvoid *buf,\r\nsize_t len)\r\n{\r\nstruct wcn36xx_hal_missed_beacon_ind_msg *rsp = buf;\r\nstruct ieee80211_vif *vif = NULL;\r\nstruct wcn36xx_vif *tmp;\r\nif (wcn36xx_is_fw_version(wcn, 1, 2, 2, 24)) {\r\nlist_for_each_entry(tmp, &wcn->vif_list, list) {\r\nwcn36xx_dbg(WCN36XX_DBG_HAL, "beacon missed bss_index %d\n",\r\ntmp->bss_index);\r\nvif = wcn36xx_priv_to_vif(tmp);\r\nieee80211_connection_loss(vif);\r\n}\r\nreturn 0;\r\n}\r\nif (len != sizeof(*rsp)) {\r\nwcn36xx_warn("Corrupted missed beacon indication\n");\r\nreturn -EIO;\r\n}\r\nlist_for_each_entry(tmp, &wcn->vif_list, list) {\r\nif (tmp->bss_index == rsp->bss_index) {\r\nwcn36xx_dbg(WCN36XX_DBG_HAL, "beacon missed bss_index %d\n",\r\nrsp->bss_index);\r\nvif = wcn36xx_priv_to_vif(tmp);\r\nieee80211_connection_loss(vif);\r\nreturn 0;\r\n}\r\n}\r\nwcn36xx_warn("BSS index %d not found\n", rsp->bss_index);\r\nreturn -ENOENT;\r\n}\r\nstatic int wcn36xx_smd_delete_sta_context_ind(struct wcn36xx *wcn,\r\nvoid *buf,\r\nsize_t len)\r\n{\r\nstruct wcn36xx_hal_delete_sta_context_ind_msg *rsp = buf;\r\nstruct wcn36xx_vif *tmp;\r\nstruct ieee80211_sta *sta;\r\nif (len != sizeof(*rsp)) {\r\nwcn36xx_warn("Corrupted delete sta indication\n");\r\nreturn -EIO;\r\n}\r\nwcn36xx_dbg(WCN36XX_DBG_HAL, "delete station indication %pM index %d\n",\r\nrsp->addr2, rsp->sta_id);\r\nlist_for_each_entry(tmp, &wcn->vif_list, list) {\r\nrcu_read_lock();\r\nsta = ieee80211_find_sta(wcn36xx_priv_to_vif(tmp), rsp->addr2);\r\nif (sta)\r\nieee80211_report_low_ack(sta, 0);\r\nrcu_read_unlock();\r\nif (sta)\r\nreturn 0;\r\n}\r\nwcn36xx_warn("STA with addr %pM and index %d not found\n",\r\nrsp->addr2,\r\nrsp->sta_id);\r\nreturn -ENOENT;\r\n}\r\nstatic int wcn36xx_smd_print_reg_info_ind(struct wcn36xx *wcn,\r\nvoid *buf,\r\nsize_t len)\r\n{\r\nstruct wcn36xx_hal_print_reg_info_ind *rsp = buf;\r\nint i;\r\nif (len < sizeof(*rsp)) {\r\nwcn36xx_warn("Corrupted print reg info indication\n");\r\nreturn -EIO;\r\n}\r\nwcn36xx_dbg(WCN36XX_DBG_HAL,\r\n"reginfo indication, scenario: 0x%x reason: 0x%x\n",\r\nrsp->scenario, rsp->reason);\r\nfor (i = 0; i < rsp->count; i++) {\r\nwcn36xx_dbg(WCN36XX_DBG_HAL, "\t0x%x: 0x%x\n",\r\nrsp->regs[i].addr, rsp->regs[i].value);\r\n}\r\nreturn 0;\r\n}\r\nint wcn36xx_smd_update_cfg(struct wcn36xx *wcn, u32 cfg_id, u32 value)\r\n{\r\nstruct wcn36xx_hal_update_cfg_req_msg msg_body, *body;\r\nsize_t len;\r\nint ret = 0;\r\nmutex_lock(&wcn->hal_mutex);\r\nINIT_HAL_MSG(msg_body, WCN36XX_HAL_UPDATE_CFG_REQ);\r\nPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\r\nbody = (struct wcn36xx_hal_update_cfg_req_msg *) wcn->hal_buf;\r\nlen = msg_body.header.len;\r\nput_cfg_tlv_u32(wcn, &len, cfg_id, value);\r\nbody->header.len = len;\r\nbody->len = len - sizeof(*body);\r\nret = wcn36xx_smd_send_and_wait(wcn, body->header.len);\r\nif (ret) {\r\nwcn36xx_err("Sending hal_update_cfg failed\n");\r\ngoto out;\r\n}\r\nret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\r\nif (ret) {\r\nwcn36xx_err("hal_update_cfg response failed err=%d\n", ret);\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&wcn->hal_mutex);\r\nreturn ret;\r\n}\r\nint wcn36xx_smd_set_mc_list(struct wcn36xx *wcn,\r\nstruct ieee80211_vif *vif,\r\nstruct wcn36xx_hal_rcv_flt_mc_addr_list_type *fp)\r\n{\r\nstruct wcn36xx_vif *vif_priv = wcn36xx_vif_to_priv(vif);\r\nstruct wcn36xx_hal_rcv_flt_pkt_set_mc_list_req_msg *msg_body = NULL;\r\nint ret = 0;\r\nmutex_lock(&wcn->hal_mutex);\r\nmsg_body = (struct wcn36xx_hal_rcv_flt_pkt_set_mc_list_req_msg *)\r\nwcn->hal_buf;\r\ninit_hal_msg(&msg_body->header, WCN36XX_HAL_8023_MULTICAST_LIST_REQ,\r\nsizeof(msg_body->mc_addr_list));\r\nif (fp)\r\nmemcpy(&msg_body->mc_addr_list, fp,\r\nsizeof(msg_body->mc_addr_list));\r\nelse\r\nmsg_body->mc_addr_list.mc_addr_count = 0;\r\nmsg_body->mc_addr_list.bss_index = vif_priv->bss_index;\r\nret = wcn36xx_smd_send_and_wait(wcn, msg_body->header.len);\r\nif (ret) {\r\nwcn36xx_err("Sending HAL_8023_MULTICAST_LIST failed\n");\r\ngoto out;\r\n}\r\nret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\r\nif (ret) {\r\nwcn36xx_err("HAL_8023_MULTICAST_LIST rsp failed err=%d\n", ret);\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&wcn->hal_mutex);\r\nreturn ret;\r\n}\r\nint wcn36xx_smd_rsp_process(struct rpmsg_device *rpdev,\r\nvoid *buf, int len, void *priv, u32 addr)\r\n{\r\nconst struct wcn36xx_hal_msg_header *msg_header = buf;\r\nstruct ieee80211_hw *hw = priv;\r\nstruct wcn36xx *wcn = hw->priv;\r\nstruct wcn36xx_hal_ind_msg *msg_ind;\r\nwcn36xx_dbg_dump(WCN36XX_DBG_SMD_DUMP, "SMD <<< ", buf, len);\r\nswitch (msg_header->msg_type) {\r\ncase WCN36XX_HAL_START_RSP:\r\ncase WCN36XX_HAL_CONFIG_STA_RSP:\r\ncase WCN36XX_HAL_CONFIG_BSS_RSP:\r\ncase WCN36XX_HAL_ADD_STA_SELF_RSP:\r\ncase WCN36XX_HAL_STOP_RSP:\r\ncase WCN36XX_HAL_DEL_STA_SELF_RSP:\r\ncase WCN36XX_HAL_DELETE_STA_RSP:\r\ncase WCN36XX_HAL_INIT_SCAN_RSP:\r\ncase WCN36XX_HAL_START_SCAN_RSP:\r\ncase WCN36XX_HAL_END_SCAN_RSP:\r\ncase WCN36XX_HAL_FINISH_SCAN_RSP:\r\ncase WCN36XX_HAL_DOWNLOAD_NV_RSP:\r\ncase WCN36XX_HAL_DELETE_BSS_RSP:\r\ncase WCN36XX_HAL_SEND_BEACON_RSP:\r\ncase WCN36XX_HAL_SET_LINK_ST_RSP:\r\ncase WCN36XX_HAL_UPDATE_PROBE_RSP_TEMPLATE_RSP:\r\ncase WCN36XX_HAL_SET_BSSKEY_RSP:\r\ncase WCN36XX_HAL_SET_STAKEY_RSP:\r\ncase WCN36XX_HAL_RMV_STAKEY_RSP:\r\ncase WCN36XX_HAL_RMV_BSSKEY_RSP:\r\ncase WCN36XX_HAL_ENTER_BMPS_RSP:\r\ncase WCN36XX_HAL_SET_POWER_PARAMS_RSP:\r\ncase WCN36XX_HAL_EXIT_BMPS_RSP:\r\ncase WCN36XX_HAL_KEEP_ALIVE_RSP:\r\ncase WCN36XX_HAL_DUMP_COMMAND_RSP:\r\ncase WCN36XX_HAL_ADD_BA_SESSION_RSP:\r\ncase WCN36XX_HAL_ADD_BA_RSP:\r\ncase WCN36XX_HAL_DEL_BA_RSP:\r\ncase WCN36XX_HAL_TRIGGER_BA_RSP:\r\ncase WCN36XX_HAL_UPDATE_CFG_RSP:\r\ncase WCN36XX_HAL_JOIN_RSP:\r\ncase WCN36XX_HAL_UPDATE_SCAN_PARAM_RSP:\r\ncase WCN36XX_HAL_CH_SWITCH_RSP:\r\ncase WCN36XX_HAL_FEATURE_CAPS_EXCHANGE_RSP:\r\ncase WCN36XX_HAL_8023_MULTICAST_LIST_RSP:\r\nmemcpy(wcn->hal_buf, buf, len);\r\nwcn->hal_rsp_len = len;\r\ncomplete(&wcn->hal_rsp_compl);\r\nbreak;\r\ncase WCN36XX_HAL_COEX_IND:\r\ncase WCN36XX_HAL_AVOID_FREQ_RANGE_IND:\r\ncase WCN36XX_HAL_DEL_BA_IND:\r\ncase WCN36XX_HAL_OTA_TX_COMPL_IND:\r\ncase WCN36XX_HAL_MISSED_BEACON_IND:\r\ncase WCN36XX_HAL_DELETE_STA_CONTEXT_IND:\r\ncase WCN36XX_HAL_PRINT_REG_INFO_IND:\r\nmsg_ind = kmalloc(sizeof(*msg_ind) + len, GFP_ATOMIC);\r\nif (!msg_ind) {\r\nwcn36xx_err("Run out of memory while handling SMD_EVENT (%d)\n",\r\nmsg_header->msg_type);\r\nreturn -ENOMEM;\r\n}\r\nmsg_ind->msg_len = len;\r\nmemcpy(msg_ind->msg, buf, len);\r\nspin_lock(&wcn->hal_ind_lock);\r\nlist_add_tail(&msg_ind->list, &wcn->hal_ind_queue);\r\nqueue_work(wcn->hal_ind_wq, &wcn->hal_ind_work);\r\nspin_unlock(&wcn->hal_ind_lock);\r\nwcn36xx_dbg(WCN36XX_DBG_HAL, "indication arrived\n");\r\nbreak;\r\ndefault:\r\nwcn36xx_err("SMD_EVENT (%d) not supported\n",\r\nmsg_header->msg_type);\r\n}\r\nreturn 0;\r\n}\r\nstatic void wcn36xx_ind_smd_work(struct work_struct *work)\r\n{\r\nstruct wcn36xx *wcn =\r\ncontainer_of(work, struct wcn36xx, hal_ind_work);\r\nstruct wcn36xx_hal_msg_header *msg_header;\r\nstruct wcn36xx_hal_ind_msg *hal_ind_msg;\r\nunsigned long flags;\r\nspin_lock_irqsave(&wcn->hal_ind_lock, flags);\r\nhal_ind_msg = list_first_entry(&wcn->hal_ind_queue,\r\nstruct wcn36xx_hal_ind_msg,\r\nlist);\r\nmsg_header = (struct wcn36xx_hal_msg_header *)hal_ind_msg->msg;\r\nswitch (msg_header->msg_type) {\r\ncase WCN36XX_HAL_COEX_IND:\r\ncase WCN36XX_HAL_DEL_BA_IND:\r\ncase WCN36XX_HAL_AVOID_FREQ_RANGE_IND:\r\nbreak;\r\ncase WCN36XX_HAL_OTA_TX_COMPL_IND:\r\nwcn36xx_smd_tx_compl_ind(wcn,\r\nhal_ind_msg->msg,\r\nhal_ind_msg->msg_len);\r\nbreak;\r\ncase WCN36XX_HAL_MISSED_BEACON_IND:\r\nwcn36xx_smd_missed_beacon_ind(wcn,\r\nhal_ind_msg->msg,\r\nhal_ind_msg->msg_len);\r\nbreak;\r\ncase WCN36XX_HAL_DELETE_STA_CONTEXT_IND:\r\nwcn36xx_smd_delete_sta_context_ind(wcn,\r\nhal_ind_msg->msg,\r\nhal_ind_msg->msg_len);\r\nbreak;\r\ncase WCN36XX_HAL_PRINT_REG_INFO_IND:\r\nwcn36xx_smd_print_reg_info_ind(wcn,\r\nhal_ind_msg->msg,\r\nhal_ind_msg->msg_len);\r\nbreak;\r\ndefault:\r\nwcn36xx_err("SMD_EVENT (%d) not supported\n",\r\nmsg_header->msg_type);\r\n}\r\nlist_del(wcn->hal_ind_queue.next);\r\nspin_unlock_irqrestore(&wcn->hal_ind_lock, flags);\r\nkfree(hal_ind_msg);\r\n}\r\nint wcn36xx_smd_open(struct wcn36xx *wcn)\r\n{\r\nint ret = 0;\r\nwcn->hal_ind_wq = create_freezable_workqueue("wcn36xx_smd_ind");\r\nif (!wcn->hal_ind_wq) {\r\nwcn36xx_err("failed to allocate wq\n");\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nINIT_WORK(&wcn->hal_ind_work, wcn36xx_ind_smd_work);\r\nINIT_LIST_HEAD(&wcn->hal_ind_queue);\r\nspin_lock_init(&wcn->hal_ind_lock);\r\nreturn 0;\r\nout:\r\nreturn ret;\r\n}\r\nvoid wcn36xx_smd_close(struct wcn36xx *wcn)\r\n{\r\ndestroy_workqueue(wcn->hal_ind_wq);\r\n}
