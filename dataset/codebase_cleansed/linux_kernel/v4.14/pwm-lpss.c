static inline struct pwm_lpss_chip *to_lpwm(struct pwm_chip *chip)\r\n{\r\nreturn container_of(chip, struct pwm_lpss_chip, chip);\r\n}\r\nstatic inline u32 pwm_lpss_read(const struct pwm_device *pwm)\r\n{\r\nstruct pwm_lpss_chip *lpwm = to_lpwm(pwm->chip);\r\nreturn readl(lpwm->regs + pwm->hwpwm * PWM_SIZE + PWM);\r\n}\r\nstatic inline void pwm_lpss_write(const struct pwm_device *pwm, u32 value)\r\n{\r\nstruct pwm_lpss_chip *lpwm = to_lpwm(pwm->chip);\r\nwritel(value, lpwm->regs + pwm->hwpwm * PWM_SIZE + PWM);\r\n}\r\nstatic int pwm_lpss_wait_for_update(struct pwm_device *pwm)\r\n{\r\nstruct pwm_lpss_chip *lpwm = to_lpwm(pwm->chip);\r\nconst void __iomem *addr = lpwm->regs + pwm->hwpwm * PWM_SIZE + PWM;\r\nconst unsigned int ms = 500 * USEC_PER_MSEC;\r\nu32 val;\r\nint err;\r\nerr = readl_poll_timeout(addr, val, !(val & PWM_SW_UPDATE), 40, ms);\r\nif (err)\r\ndev_err(pwm->chip->dev, "PWM_SW_UPDATE was not cleared\n");\r\nreturn err;\r\n}\r\nstatic inline int pwm_lpss_is_updating(struct pwm_device *pwm)\r\n{\r\nreturn (pwm_lpss_read(pwm) & PWM_SW_UPDATE) ? -EBUSY : 0;\r\n}\r\nstatic void pwm_lpss_prepare(struct pwm_lpss_chip *lpwm, struct pwm_device *pwm,\r\nint duty_ns, int period_ns)\r\n{\r\nunsigned long long on_time_div;\r\nunsigned long c = lpwm->info->clk_rate, base_unit_range;\r\nunsigned long long base_unit, freq = NSEC_PER_SEC;\r\nu32 ctrl;\r\ndo_div(freq, period_ns);\r\nbase_unit_range = BIT(lpwm->info->base_unit_bits) - 1;\r\nfreq *= base_unit_range;\r\nbase_unit = DIV_ROUND_CLOSEST_ULL(freq, c);\r\non_time_div = 255ULL * duty_ns;\r\ndo_div(on_time_div, period_ns);\r\non_time_div = 255ULL - on_time_div;\r\nctrl = pwm_lpss_read(pwm);\r\nctrl &= ~PWM_ON_TIME_DIV_MASK;\r\nctrl &= ~(base_unit_range << PWM_BASE_UNIT_SHIFT);\r\nbase_unit &= base_unit_range;\r\nctrl |= (u32) base_unit << PWM_BASE_UNIT_SHIFT;\r\nctrl |= on_time_div;\r\npwm_lpss_write(pwm, ctrl);\r\n}\r\nstatic inline void pwm_lpss_cond_enable(struct pwm_device *pwm, bool cond)\r\n{\r\nif (cond)\r\npwm_lpss_write(pwm, pwm_lpss_read(pwm) | PWM_ENABLE);\r\n}\r\nstatic int pwm_lpss_apply(struct pwm_chip *chip, struct pwm_device *pwm,\r\nstruct pwm_state *state)\r\n{\r\nstruct pwm_lpss_chip *lpwm = to_lpwm(chip);\r\nint ret;\r\nif (state->enabled) {\r\nif (!pwm_is_enabled(pwm)) {\r\npm_runtime_get_sync(chip->dev);\r\nret = pwm_lpss_is_updating(pwm);\r\nif (ret) {\r\npm_runtime_put(chip->dev);\r\nreturn ret;\r\n}\r\npwm_lpss_prepare(lpwm, pwm, state->duty_cycle, state->period);\r\npwm_lpss_write(pwm, pwm_lpss_read(pwm) | PWM_SW_UPDATE);\r\npwm_lpss_cond_enable(pwm, lpwm->info->bypass == false);\r\nret = pwm_lpss_wait_for_update(pwm);\r\nif (ret) {\r\npm_runtime_put(chip->dev);\r\nreturn ret;\r\n}\r\npwm_lpss_cond_enable(pwm, lpwm->info->bypass == true);\r\n} else {\r\nret = pwm_lpss_is_updating(pwm);\r\nif (ret)\r\nreturn ret;\r\npwm_lpss_prepare(lpwm, pwm, state->duty_cycle, state->period);\r\npwm_lpss_write(pwm, pwm_lpss_read(pwm) | PWM_SW_UPDATE);\r\nreturn pwm_lpss_wait_for_update(pwm);\r\n}\r\n} else if (pwm_is_enabled(pwm)) {\r\npwm_lpss_write(pwm, pwm_lpss_read(pwm) & ~PWM_ENABLE);\r\npm_runtime_put(chip->dev);\r\n}\r\nreturn 0;\r\n}\r\nstruct pwm_lpss_chip *pwm_lpss_probe(struct device *dev, struct resource *r,\r\nconst struct pwm_lpss_boardinfo *info)\r\n{\r\nstruct pwm_lpss_chip *lpwm;\r\nunsigned long c;\r\nint ret;\r\nlpwm = devm_kzalloc(dev, sizeof(*lpwm), GFP_KERNEL);\r\nif (!lpwm)\r\nreturn ERR_PTR(-ENOMEM);\r\nlpwm->regs = devm_ioremap_resource(dev, r);\r\nif (IS_ERR(lpwm->regs))\r\nreturn ERR_CAST(lpwm->regs);\r\nlpwm->info = info;\r\nc = lpwm->info->clk_rate;\r\nif (!c)\r\nreturn ERR_PTR(-EINVAL);\r\nlpwm->chip.dev = dev;\r\nlpwm->chip.ops = &pwm_lpss_ops;\r\nlpwm->chip.base = -1;\r\nlpwm->chip.npwm = info->npwm;\r\nret = pwmchip_add(&lpwm->chip);\r\nif (ret) {\r\ndev_err(dev, "failed to add PWM chip: %d\n", ret);\r\nreturn ERR_PTR(ret);\r\n}\r\nreturn lpwm;\r\n}\r\nint pwm_lpss_remove(struct pwm_lpss_chip *lpwm)\r\n{\r\nreturn pwmchip_remove(&lpwm->chip);\r\n}
