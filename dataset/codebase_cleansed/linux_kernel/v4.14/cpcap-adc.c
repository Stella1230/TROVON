static irqreturn_t cpcap_adc_irq_thread(int irq, void *data)\r\n{\r\nstruct iio_dev *indio_dev = data;\r\nstruct cpcap_adc *ddata = iio_priv(indio_dev);\r\nint error;\r\nerror = regmap_update_bits(ddata->reg, CPCAP_REG_ADCC2,\r\nCPCAP_BIT_ADTRIG_DIS,\r\nCPCAP_BIT_ADTRIG_DIS);\r\nif (error)\r\nreturn IRQ_NONE;\r\nddata->done = true;\r\nwake_up_interruptible(&ddata->wq_data_avail);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void cpcap_adc_setup_calibrate(struct cpcap_adc *ddata,\r\nenum cpcap_adc_channel chan)\r\n{\r\nunsigned int value = 0;\r\nunsigned long timeout = jiffies + msecs_to_jiffies(3000);\r\nint error;\r\nif ((chan != CPCAP_ADC_CHG_ISENSE) &&\r\n(chan != CPCAP_ADC_BATTI))\r\nreturn;\r\nvalue |= CPCAP_BIT_CAL_MODE | CPCAP_BIT_RAND0;\r\nvalue |= ((chan << 4) &\r\n(CPCAP_BIT_ADA2 | CPCAP_BIT_ADA1 | CPCAP_BIT_ADA0));\r\nerror = regmap_update_bits(ddata->reg, CPCAP_REG_ADCC1,\r\nCPCAP_BIT_CAL_MODE | CPCAP_BIT_ATOX |\r\nCPCAP_BIT_ATO3 | CPCAP_BIT_ATO2 |\r\nCPCAP_BIT_ATO1 | CPCAP_BIT_ATO0 |\r\nCPCAP_BIT_ADA2 | CPCAP_BIT_ADA1 |\r\nCPCAP_BIT_ADA0 | CPCAP_BIT_AD_SEL1 |\r\nCPCAP_BIT_RAND1 | CPCAP_BIT_RAND0,\r\nvalue);\r\nif (error)\r\nreturn;\r\nerror = regmap_update_bits(ddata->reg, CPCAP_REG_ADCC2,\r\nCPCAP_BIT_ATOX_PS_FACTOR |\r\nCPCAP_BIT_ADC_PS_FACTOR1 |\r\nCPCAP_BIT_ADC_PS_FACTOR0,\r\n0);\r\nif (error)\r\nreturn;\r\nerror = regmap_update_bits(ddata->reg, CPCAP_REG_ADCC2,\r\nCPCAP_BIT_ADTRIG_DIS,\r\nCPCAP_BIT_ADTRIG_DIS);\r\nif (error)\r\nreturn;\r\nerror = regmap_update_bits(ddata->reg, CPCAP_REG_ADCC2,\r\nCPCAP_BIT_ASC,\r\nCPCAP_BIT_ASC);\r\nif (error)\r\nreturn;\r\ndo {\r\nschedule_timeout_uninterruptible(1);\r\nerror = regmap_read(ddata->reg, CPCAP_REG_ADCC2, &value);\r\nif (error)\r\nreturn;\r\n} while ((value & CPCAP_BIT_ASC) && time_before(jiffies, timeout));\r\nif (value & CPCAP_BIT_ASC)\r\ndev_err(ddata->dev,\r\n"Timeout waiting for calibration to complete\n");\r\nerror = regmap_update_bits(ddata->reg, CPCAP_REG_ADCC1,\r\nCPCAP_BIT_CAL_MODE, 0);\r\nif (error)\r\nreturn;\r\n}\r\nstatic int cpcap_adc_calibrate_one(struct cpcap_adc *ddata,\r\nint channel,\r\nu16 calibration_register,\r\nint lower_threshold,\r\nint upper_threshold)\r\n{\r\nunsigned int calibration_data[2];\r\nunsigned short cal_data_diff;\r\nint i, error;\r\nfor (i = 0; i < CPCAP_ADC_MAX_RETRIES; i++) {\r\ncalibration_data[0] = 0;\r\ncalibration_data[1] = 0;\r\ncal_data_diff = 0;\r\ncpcap_adc_setup_calibrate(ddata, channel);\r\nerror = regmap_read(ddata->reg, calibration_register,\r\n&calibration_data[0]);\r\nif (error)\r\nreturn error;\r\ncpcap_adc_setup_calibrate(ddata, channel);\r\nerror = regmap_read(ddata->reg, calibration_register,\r\n&calibration_data[1]);\r\nif (error)\r\nreturn error;\r\nif (calibration_data[0] > calibration_data[1])\r\ncal_data_diff =\r\ncalibration_data[0] - calibration_data[1];\r\nelse\r\ncal_data_diff =\r\ncalibration_data[1] - calibration_data[0];\r\nif (((calibration_data[1] >= lower_threshold) &&\r\n(calibration_data[1] <= upper_threshold) &&\r\n(cal_data_diff <= ST_ADC_CALIBRATE_DIFF_THRESHOLD)) ||\r\n(ddata->vendor == CPCAP_VENDOR_TI)) {\r\nbank_conversion[channel].cal_offset =\r\n((short)calibration_data[1] * -1) + 512;\r\ndev_dbg(ddata->dev, "ch%i calibration complete: %i\n",\r\nchannel, bank_conversion[channel].cal_offset);\r\nbreak;\r\n}\r\nusleep_range(5000, 10000);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cpcap_adc_calibrate(struct cpcap_adc *ddata)\r\n{\r\nint error;\r\nerror = cpcap_adc_calibrate_one(ddata, CPCAP_ADC_CHG_ISENSE,\r\nCPCAP_REG_ADCAL1,\r\nST_ADC_CAL_CHRGI_LOW_THRESHOLD,\r\nST_ADC_CAL_CHRGI_HIGH_THRESHOLD);\r\nif (error)\r\nreturn error;\r\nerror = cpcap_adc_calibrate_one(ddata, CPCAP_ADC_BATTI,\r\nCPCAP_REG_ADCAL2,\r\nST_ADC_CAL_BATTI_LOW_THRESHOLD,\r\nST_ADC_CAL_BATTI_HIGH_THRESHOLD);\r\nif (error)\r\nreturn error;\r\nreturn 0;\r\n}\r\nstatic void cpcap_adc_setup_bank(struct cpcap_adc *ddata,\r\nstruct cpcap_adc_request *req)\r\n{\r\nconst struct cpcap_adc_ato *ato = ddata->ato;\r\nunsigned short value1 = 0;\r\nunsigned short value2 = 0;\r\nint error;\r\nif (!ato)\r\nreturn;\r\nswitch (req->channel) {\r\ncase CPCAP_ADC_AD0:\r\nvalue2 |= CPCAP_BIT_THERMBIAS_EN;\r\nerror = regmap_update_bits(ddata->reg, CPCAP_REG_ADCC2,\r\nCPCAP_BIT_THERMBIAS_EN,\r\nvalue2);\r\nif (error)\r\nreturn;\r\nusleep_range(800, 1000);\r\nbreak;\r\ncase CPCAP_ADC_AD8 ... CPCAP_ADC_TSY2_AD15:\r\nvalue1 |= CPCAP_BIT_AD_SEL1;\r\nbreak;\r\ncase CPCAP_ADC_BATTP_PI16 ... CPCAP_ADC_BATTI_PI17:\r\nvalue1 |= CPCAP_BIT_RAND1;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (req->timing) {\r\ncase CPCAP_ADC_TIMING_IN:\r\nvalue1 |= ato->ato_in;\r\nvalue1 |= ato->atox_in;\r\nvalue2 |= ato->adc_ps_factor_in;\r\nvalue2 |= ato->atox_ps_factor_in;\r\nbreak;\r\ncase CPCAP_ADC_TIMING_OUT:\r\nvalue1 |= ato->ato_out;\r\nvalue1 |= ato->atox_out;\r\nvalue2 |= ato->adc_ps_factor_out;\r\nvalue2 |= ato->atox_ps_factor_out;\r\nbreak;\r\ncase CPCAP_ADC_TIMING_IMM:\r\ndefault:\r\nbreak;\r\n}\r\nerror = regmap_update_bits(ddata->reg, CPCAP_REG_ADCC1,\r\nCPCAP_BIT_CAL_MODE | CPCAP_BIT_ATOX |\r\nCPCAP_BIT_ATO3 | CPCAP_BIT_ATO2 |\r\nCPCAP_BIT_ATO1 | CPCAP_BIT_ATO0 |\r\nCPCAP_BIT_ADA2 | CPCAP_BIT_ADA1 |\r\nCPCAP_BIT_ADA0 | CPCAP_BIT_AD_SEL1 |\r\nCPCAP_BIT_RAND1 | CPCAP_BIT_RAND0,\r\nvalue1);\r\nif (error)\r\nreturn;\r\nerror = regmap_update_bits(ddata->reg, CPCAP_REG_ADCC2,\r\nCPCAP_BIT_ATOX_PS_FACTOR |\r\nCPCAP_BIT_ADC_PS_FACTOR1 |\r\nCPCAP_BIT_ADC_PS_FACTOR0 |\r\nCPCAP_BIT_THERMBIAS_EN,\r\nvalue2);\r\nif (error)\r\nreturn;\r\nif (req->timing == CPCAP_ADC_TIMING_IMM) {\r\nerror = regmap_update_bits(ddata->reg, CPCAP_REG_ADCC2,\r\nCPCAP_BIT_ADTRIG_DIS,\r\nCPCAP_BIT_ADTRIG_DIS);\r\nif (error)\r\nreturn;\r\nerror = regmap_update_bits(ddata->reg, CPCAP_REG_ADCC2,\r\nCPCAP_BIT_ASC,\r\nCPCAP_BIT_ASC);\r\nif (error)\r\nreturn;\r\n} else {\r\nerror = regmap_update_bits(ddata->reg, CPCAP_REG_ADCC2,\r\nCPCAP_BIT_ADTRIG_ONESHOT,\r\nCPCAP_BIT_ADTRIG_ONESHOT);\r\nif (error)\r\nreturn;\r\nerror = regmap_update_bits(ddata->reg, CPCAP_REG_ADCC2,\r\nCPCAP_BIT_ADTRIG_DIS, 0);\r\nif (error)\r\nreturn;\r\n}\r\n}\r\nstatic int cpcap_adc_start_bank(struct cpcap_adc *ddata,\r\nstruct cpcap_adc_request *req)\r\n{\r\nint i, error;\r\nreq->timing = CPCAP_ADC_TIMING_IMM;\r\nddata->done = false;\r\nfor (i = 0; i < CPCAP_ADC_MAX_RETRIES; i++) {\r\ncpcap_adc_setup_bank(ddata, req);\r\nerror = wait_event_interruptible_timeout(ddata->wq_data_avail,\r\nddata->done,\r\nmsecs_to_jiffies(50));\r\nif (error > 0)\r\nreturn 0;\r\nif (error == 0) {\r\nerror = -ETIMEDOUT;\r\ncontinue;\r\n}\r\nif (error < 0)\r\nreturn error;\r\n}\r\nreturn error;\r\n}\r\nstatic int cpcap_adc_stop_bank(struct cpcap_adc *ddata)\r\n{\r\nint error;\r\nerror = regmap_update_bits(ddata->reg, CPCAP_REG_ADCC1,\r\n0xffff,\r\nCPCAP_REG_ADCC1_DEFAULTS);\r\nif (error)\r\nreturn error;\r\nreturn regmap_update_bits(ddata->reg, CPCAP_REG_ADCC2,\r\n0xffff,\r\nCPCAP_REG_ADCC2_DEFAULTS);\r\n}\r\nstatic void cpcap_adc_phase(struct cpcap_adc_request *req)\r\n{\r\nconst struct cpcap_adc_conversion_tbl *conv_tbl = req->conv_tbl;\r\nconst struct cpcap_adc_phasing_tbl *phase_tbl = req->phase_tbl;\r\nint index = req->channel;\r\nswitch (req->channel) {\r\ncase CPCAP_ADC_BATTP:\r\ncase CPCAP_ADC_BATTP_PI16:\r\nindex = req->bank_index;\r\nreq->result -= phase_tbl[index].offset;\r\nreq->result -= CPCAP_FOUR_POINT_TWO_ADC;\r\nreq->result *= phase_tbl[index].multiplier;\r\nif (phase_tbl[index].divider == 0)\r\nreturn;\r\nreq->result /= phase_tbl[index].divider;\r\nreq->result += CPCAP_FOUR_POINT_TWO_ADC;\r\nbreak;\r\ncase CPCAP_ADC_BATTI_PI17:\r\nindex = req->bank_index;\r\ndefault:\r\nreq->result += conv_tbl[index].cal_offset;\r\nreq->result += conv_tbl[index].align_offset;\r\nreq->result *= phase_tbl[index].multiplier;\r\nif (phase_tbl[index].divider == 0)\r\nreturn;\r\nreq->result /= phase_tbl[index].divider;\r\nreq->result += phase_tbl[index].offset;\r\nbreak;\r\n}\r\nif (req->result < phase_tbl[index].min)\r\nreq->result = phase_tbl[index].min;\r\nelse if (req->result > phase_tbl[index].max)\r\nreq->result = phase_tbl[index].max;\r\n}\r\nstatic int cpcap_adc_table_to_millicelcius(unsigned short value)\r\n{\r\nint i, result = 0, alpha;\r\nif (value <= temp_map[CPCAP_MAX_TEMP_LVL - 1][0])\r\nreturn temp_map[CPCAP_MAX_TEMP_LVL - 1][1];\r\nif (value >= temp_map[0][0])\r\nreturn temp_map[0][1];\r\nfor (i = 0; i < CPCAP_MAX_TEMP_LVL - 1; i++) {\r\nif ((value <= temp_map[i][0]) &&\r\n(value >= temp_map[i + 1][0])) {\r\nif (value == temp_map[i][0]) {\r\nresult = temp_map[i][1];\r\n} else if (value == temp_map[i + 1][0]) {\r\nresult = temp_map[i + 1][1];\r\n} else {\r\nalpha = ((value - temp_map[i][0]) * 1000) /\r\n(temp_map[i + 1][0] - temp_map[i][0]);\r\nresult = temp_map[i][1] +\r\n((alpha * (temp_map[i + 1][1] -\r\ntemp_map[i][1])) / 1000);\r\n}\r\nbreak;\r\n}\r\n}\r\nreturn result;\r\n}\r\nstatic void cpcap_adc_convert(struct cpcap_adc_request *req)\r\n{\r\nconst struct cpcap_adc_conversion_tbl *conv_tbl = req->conv_tbl;\r\nint index = req->channel;\r\nswitch (req->channel) {\r\ncase CPCAP_ADC_BATTP_PI16:\r\nindex = CPCAP_ADC_BATTP;\r\nbreak;\r\ncase CPCAP_ADC_BATTI_PI17:\r\nindex = CPCAP_ADC_BATTI;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (conv_tbl[index].conv_type == IIO_CHAN_INFO_RAW)\r\nreturn;\r\nif ((req->channel == CPCAP_ADC_AD0) ||\r\n(req->channel == CPCAP_ADC_AD3)) {\r\nreq->result =\r\ncpcap_adc_table_to_millicelcius(req->result);\r\nreturn;\r\n}\r\nreq->result *= conv_tbl[index].multiplier;\r\nif (conv_tbl[index].divider == 0)\r\nreturn;\r\nreq->result /= conv_tbl[index].divider;\r\nreq->result += conv_tbl[index].conv_offset;\r\n}\r\nstatic int cpcap_adc_read_bank_scaled(struct cpcap_adc *ddata,\r\nstruct cpcap_adc_request *req)\r\n{\r\nint calibration_data, error, addr;\r\nif (ddata->vendor == CPCAP_VENDOR_TI) {\r\nerror = regmap_read(ddata->reg, CPCAP_REG_ADCAL1,\r\n&calibration_data);\r\nif (error)\r\nreturn error;\r\nbank_conversion[CPCAP_ADC_CHG_ISENSE].cal_offset =\r\n((short)calibration_data * -1) + 512;\r\nerror = regmap_read(ddata->reg, CPCAP_REG_ADCAL2,\r\n&calibration_data);\r\nif (error)\r\nreturn error;\r\nbank_conversion[CPCAP_ADC_BATTI].cal_offset =\r\n((short)calibration_data * -1) + 512;\r\n}\r\naddr = CPCAP_REG_ADCD0 + req->bank_index * 4;\r\nerror = regmap_read(ddata->reg, addr, &req->result);\r\nif (error)\r\nreturn error;\r\nreq->result &= 0x3ff;\r\ncpcap_adc_phase(req);\r\ncpcap_adc_convert(req);\r\nreturn 0;\r\n}\r\nstatic int cpcap_adc_init_request(struct cpcap_adc_request *req,\r\nint channel)\r\n{\r\nreq->channel = channel;\r\nreq->phase_tbl = bank_phasing;\r\nreq->conv_tbl = bank_conversion;\r\nswitch (channel) {\r\ncase CPCAP_ADC_AD0 ... CPCAP_ADC_USB_ID:\r\nreq->bank_index = channel;\r\nbreak;\r\ncase CPCAP_ADC_AD8 ... CPCAP_ADC_TSY2_AD15:\r\nreq->bank_index = channel - 8;\r\nbreak;\r\ncase CPCAP_ADC_BATTP_PI16:\r\nreq->bank_index = CPCAP_ADC_BATTP;\r\nbreak;\r\ncase CPCAP_ADC_BATTI_PI17:\r\nreq->bank_index = CPCAP_ADC_BATTI;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cpcap_adc_read_st_die_temp(struct cpcap_adc *ddata,\r\nint addr, int *val)\r\n{\r\nint error;\r\nerror = regmap_read(ddata->reg, addr, val);\r\nif (error)\r\nreturn error;\r\n*val -= 282;\r\n*val *= 114;\r\n*val += 25000;\r\nreturn 0;\r\n}\r\nstatic int cpcap_adc_read(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2, long mask)\r\n{\r\nstruct cpcap_adc *ddata = iio_priv(indio_dev);\r\nstruct cpcap_adc_request req;\r\nint error;\r\nerror = cpcap_adc_init_request(&req, chan->channel);\r\nif (error)\r\nreturn error;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nmutex_lock(&ddata->lock);\r\nerror = cpcap_adc_start_bank(ddata, &req);\r\nif (error)\r\ngoto err_unlock;\r\nerror = regmap_read(ddata->reg, chan->address, val);\r\nif (error)\r\ngoto err_unlock;\r\nerror = cpcap_adc_stop_bank(ddata);\r\nif (error)\r\ngoto err_unlock;\r\nmutex_unlock(&ddata->lock);\r\nbreak;\r\ncase IIO_CHAN_INFO_PROCESSED:\r\nmutex_lock(&ddata->lock);\r\nerror = cpcap_adc_start_bank(ddata, &req);\r\nif (error)\r\ngoto err_unlock;\r\nif ((ddata->vendor == CPCAP_VENDOR_ST) &&\r\n(chan->channel == CPCAP_ADC_AD3)) {\r\nerror = cpcap_adc_read_st_die_temp(ddata,\r\nchan->address,\r\n&req.result);\r\nif (error)\r\ngoto err_unlock;\r\n} else {\r\nerror = cpcap_adc_read_bank_scaled(ddata, &req);\r\nif (error)\r\ngoto err_unlock;\r\n}\r\nerror = cpcap_adc_stop_bank(ddata);\r\nif (error)\r\ngoto err_unlock;\r\nmutex_unlock(&ddata->lock);\r\n*val = req.result;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn IIO_VAL_INT;\r\nerr_unlock:\r\nmutex_unlock(&ddata->lock);\r\ndev_err(ddata->dev, "error reading ADC: %i\n", error);\r\nreturn error;\r\n}\r\nstatic int cpcap_adc_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *match;\r\nstruct cpcap_adc *ddata;\r\nstruct iio_dev *indio_dev;\r\nint error;\r\nmatch = of_match_device(of_match_ptr(cpcap_adc_id_table),\r\n&pdev->dev);\r\nif (!match)\r\nreturn -EINVAL;\r\nif (!match->data) {\r\ndev_err(&pdev->dev, "no configuration data found\n");\r\nreturn -ENODEV;\r\n}\r\nindio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*ddata));\r\nif (!indio_dev) {\r\ndev_err(&pdev->dev, "failed to allocate iio device\n");\r\nreturn -ENOMEM;\r\n}\r\nddata = iio_priv(indio_dev);\r\nddata->ato = match->data;\r\nddata->dev = &pdev->dev;\r\nmutex_init(&ddata->lock);\r\ninit_waitqueue_head(&ddata->wq_data_avail);\r\nindio_dev->modes = INDIO_DIRECT_MODE | INDIO_BUFFER_SOFTWARE;\r\nindio_dev->dev.parent = &pdev->dev;\r\nindio_dev->dev.of_node = pdev->dev.of_node;\r\nindio_dev->channels = cpcap_adc_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(cpcap_adc_channels);\r\nindio_dev->name = dev_name(&pdev->dev);\r\nindio_dev->info = &cpcap_adc_info;\r\nddata->reg = dev_get_regmap(pdev->dev.parent, NULL);\r\nif (!ddata->reg)\r\nreturn -ENODEV;\r\nerror = cpcap_get_vendor(ddata->dev, ddata->reg, &ddata->vendor);\r\nif (error)\r\nreturn error;\r\nplatform_set_drvdata(pdev, indio_dev);\r\nddata->irq = platform_get_irq_byname(pdev, "adcdone");\r\nif (!ddata->irq)\r\nreturn -ENODEV;\r\nerror = devm_request_threaded_irq(&pdev->dev, ddata->irq, NULL,\r\ncpcap_adc_irq_thread,\r\nIRQF_TRIGGER_NONE,\r\n"cpcap-adc", indio_dev);\r\nif (error) {\r\ndev_err(&pdev->dev, "could not get irq: %i\n",\r\nerror);\r\nreturn error;\r\n}\r\nerror = cpcap_adc_calibrate(ddata);\r\nif (error)\r\nreturn error;\r\ndev_info(&pdev->dev, "CPCAP ADC device probed\n");\r\nreturn devm_iio_device_register(&pdev->dev, indio_dev);\r\n}
