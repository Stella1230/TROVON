static inline u32 __alloc_dma_pages(int order)\r\n{\r\nunsigned long flags;\r\nu32 pos;\r\nspin_lock_irqsave(&dma_lock, flags);\r\npos = bitmap_find_free_region(dma_bitmap, dma_pages, order);\r\nspin_unlock_irqrestore(&dma_lock, flags);\r\nreturn dma_base + (pos << PAGE_SHIFT);\r\n}\r\nstatic void __free_dma_pages(u32 addr, int order)\r\n{\r\nunsigned long flags;\r\nu32 pos = (addr - dma_base) >> PAGE_SHIFT;\r\nif (addr < dma_base || (pos + (1 << order)) >= dma_pages) {\r\nprintk(KERN_ERR "%s: freeing outside range.\n", __func__);\r\nBUG();\r\n}\r\nspin_lock_irqsave(&dma_lock, flags);\r\nbitmap_release_region(dma_bitmap, pos, order);\r\nspin_unlock_irqrestore(&dma_lock, flags);\r\n}\r\nvoid *c6x_dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,\r\ngfp_t gfp, unsigned long attrs)\r\n{\r\nu32 paddr;\r\nint order;\r\nif (!dma_size || !size)\r\nreturn NULL;\r\norder = get_count_order(((size - 1) >> PAGE_SHIFT) + 1);\r\npaddr = __alloc_dma_pages(order);\r\nif (handle)\r\n*handle = paddr;\r\nif (!paddr)\r\nreturn NULL;\r\nreturn phys_to_virt(paddr);\r\n}\r\nvoid c6x_dma_free(struct device *dev, size_t size, void *vaddr,\r\ndma_addr_t dma_handle, unsigned long attrs)\r\n{\r\nint order;\r\nif (!dma_size || !size)\r\nreturn;\r\norder = get_count_order(((size - 1) >> PAGE_SHIFT) + 1);\r\n__free_dma_pages(virt_to_phys(vaddr), order);\r\n}\r\nvoid __init coherent_mem_init(phys_addr_t start, u32 size)\r\n{\r\nphys_addr_t bitmap_phys;\r\nif (!size)\r\nreturn;\r\nprintk(KERN_INFO\r\n"Coherent memory (DMA) region start=0x%x size=0x%x\n",\r\nstart, size);\r\ndma_base = start;\r\ndma_size = size;\r\ndma_pages = dma_size >> PAGE_SHIFT;\r\nif (dma_size & (PAGE_SIZE - 1))\r\n++dma_pages;\r\nbitmap_phys = memblock_alloc(BITS_TO_LONGS(dma_pages) * sizeof(long),\r\nsizeof(long));\r\ndma_bitmap = phys_to_virt(bitmap_phys);\r\nmemset(dma_bitmap, 0, dma_pages * PAGE_SIZE);\r\n}
