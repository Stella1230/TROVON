static int bcma_wait_bits(struct bcma_device *dev, u16 reg, u32 bitmask,\r\nint timeout)\r\n{\r\nint i;\r\nu32 val;\r\nfor (i = 0; i < timeout; i++) {\r\nval = bcma_read32(dev, reg);\r\nif ((val & bitmask) == bitmask)\r\nreturn 0;\r\nudelay(10);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic void bcma_hcd_4716wa(struct bcma_device *dev)\r\n{\r\n#ifdef CONFIG_BCMA_DRIVER_MIPS\r\nif (dev->bus->chipinfo.id == 0x4716) {\r\nu32 tmp;\r\ntmp = bcma_cpu_clock(&dev->bus->drv_mips);\r\nif (tmp >= 480000000)\r\ntmp = 0x1846b;\r\nelse if (tmp == 453000000)\r\ntmp = 0x1046b;\r\nelse\r\ntmp = 0;\r\nif (tmp) {\r\nbcma_write32(dev, 0x524, 0x1);\r\nudelay(500);\r\nbcma_write32(dev, 0x524, tmp);\r\nudelay(500);\r\nbcma_write32(dev, 0x524, 0x4ab);\r\nudelay(500);\r\nbcma_read32(dev, 0x528);\r\nbcma_write32(dev, 0x528, 0x80000000);\r\n}\r\n}\r\n#endif\r\n}\r\nstatic void bcma_hcd_init_chip_mips(struct bcma_device *dev)\r\n{\r\nu32 tmp;\r\nif (!bcma_core_is_enabled(dev)) {\r\nbcma_core_enable(dev, 0);\r\nmdelay(10);\r\nif (dev->id.rev >= 5) {\r\ntmp = bcma_read32(dev, 0x1e0);\r\ntmp |= 0x100;\r\nbcma_write32(dev, 0x1e0, tmp);\r\nif (bcma_wait_bits(dev, 0x1e0, 1 << 24, 100))\r\nprintk(KERN_EMERG "Failed to enable misc PPL!\n");\r\nbcma_write32(dev, 0x200, 0x4ff);\r\nudelay(25);\r\nbcma_write32(dev, 0x200, 0x6ff);\r\nudelay(25);\r\nbcma_write32(dev, 0x524, 0x6b);\r\nudelay(50);\r\ntmp = bcma_read32(dev, 0x524);\r\nudelay(50);\r\nbcma_write32(dev, 0x524, 0xab);\r\nudelay(50);\r\ntmp = bcma_read32(dev, 0x524);\r\nudelay(50);\r\nbcma_write32(dev, 0x524, 0x2b);\r\nudelay(50);\r\ntmp = bcma_read32(dev, 0x524);\r\nudelay(50);\r\nbcma_write32(dev, 0x524, 0x10ab);\r\nudelay(50);\r\ntmp = bcma_read32(dev, 0x524);\r\nif (bcma_wait_bits(dev, 0x528, 0xc000, 10000)) {\r\ntmp = bcma_read32(dev, 0x528);\r\nprintk(KERN_EMERG\r\n"USB20H mdio_rddata 0x%08x\n", tmp);\r\n}\r\nbcma_write32(dev, 0x528, 0x80000000);\r\ntmp = bcma_read32(dev, 0x314);\r\nudelay(265);\r\nbcma_write32(dev, 0x200, 0x7ff);\r\nudelay(10);\r\nbcma_write32(dev, 0x510, 0);\r\n} else {\r\nbcma_write32(dev, 0x200, 0x7ff);\r\nudelay(1);\r\n}\r\nbcma_hcd_4716wa(dev);\r\n}\r\n}\r\nstatic int bcma_hcd_usb20_old_arm_init(struct bcma_hcd_device *usb_dev)\r\n{\r\nstruct bcma_device *core = usb_dev->core;\r\nstruct device *dev = &core->dev;\r\nstruct bcma_device *pmu_core;\r\nusleep_range(10000, 20000);\r\nif (core->id.rev < 5)\r\nreturn 0;\r\npmu_core = bcma_find_core(core->bus, BCMA_CORE_PMU);\r\nif (!pmu_core) {\r\ndev_err(dev, "Could not find PMU core\n");\r\nreturn -ENOENT;\r\n}\r\nbcma_awrite32(core, BCMA_IOCTL, BCMA_IOCTL_CLK | BCMA_IOCTL_FGC);\r\nusleep_range(100, 200);\r\nbcma_awrite32(core, BCMA_RESET_CTL, BCMA_RESET_CTL_RESET);\r\nusleep_range(100, 200);\r\nbcma_awrite32(core, BCMA_RESET_CTL, 0);\r\nusleep_range(100, 200);\r\nbcma_awrite32(core, BCMA_IOCTL, BCMA_IOCTL_CLK);\r\nusleep_range(100, 200);\r\nbcma_write32(core, BCMA_CLKCTLST, BCMA_CLKCTLST_FORCEHT |\r\nBCMA_CLKCTLST_HQCLKREQ |\r\nUSB_BCMA_CLKCTLST_USB_CLK_REQ);\r\nusleep_range(100, 200);\r\nbcma_write32(core, 0x510, 0xc7f85000);\r\nbcma_write32(core, 0x510, 0xc7f85003);\r\nusleep_range(300, 600);\r\nbcma_write32(pmu_core, BCMA_CC_PMU_PLLCTL_ADDR, 0x6);\r\nbcma_write32(pmu_core, BCMA_CC_PMU_PLLCTL_DATA, 0x005360c1);\r\nusleep_range(100, 200);\r\nbcma_write32(pmu_core, BCMA_CC_PMU_PLLCTL_ADDR, 0x7);\r\nbcma_write32(pmu_core, BCMA_CC_PMU_PLLCTL_DATA, 0x0);\r\nusleep_range(100, 200);\r\nbcma_set32(pmu_core, BCMA_CC_PMU_CTL, BCMA_CC_PMU_CTL_PLL_UPD);\r\nusleep_range(100, 200);\r\nbcma_write32(core, 0x510, 0x7f8d007);\r\nudelay(1000);\r\nbcma_write32(core, 0x200, 0x4ff);\r\nusleep_range(25, 50);\r\nbcma_write32(core, 0x200, 0x6ff);\r\nusleep_range(25, 50);\r\nbcma_write32(core, 0x200, 0x7ff);\r\nusleep_range(25, 50);\r\nof_platform_default_populate(dev->of_node, NULL, dev);\r\nreturn 0;\r\n}\r\nstatic void bcma_hcd_usb20_ns_init_hc(struct bcma_device *dev)\r\n{\r\nu32 val;\r\nval = bcma_read32(dev, 0x94);\r\nval &= 0xffff;\r\nval |= 0x80 << 16;\r\nbcma_write32(dev, 0x94, val);\r\nval = bcma_read32(dev, 0x9c);\r\nval |= 1;\r\nbcma_write32(dev, 0x9c, val);\r\nusleep_range(1000, 2000);\r\n}\r\nstatic int bcma_hcd_usb20_ns_init(struct bcma_hcd_device *bcma_hcd)\r\n{\r\nstruct bcma_device *core = bcma_hcd->core;\r\nstruct bcma_chipinfo *ci = &core->bus->chipinfo;\r\nstruct device *dev = &core->dev;\r\nbcma_core_enable(core, 0);\r\nif (ci->id == BCMA_CHIP_ID_BCM4707 ||\r\nci->id == BCMA_CHIP_ID_BCM53018)\r\nbcma_hcd_usb20_ns_init_hc(core);\r\nof_platform_default_populate(dev->of_node, NULL, dev);\r\nreturn 0;\r\n}\r\nstatic void bcma_hci_platform_power_gpio(struct bcma_device *dev, bool val)\r\n{\r\nstruct bcma_hcd_device *usb_dev = bcma_get_drvdata(dev);\r\nif (IS_ERR_OR_NULL(usb_dev->gpio_desc))\r\nreturn;\r\ngpiod_set_value(usb_dev->gpio_desc, val);\r\n}\r\nstatic struct platform_device *bcma_hcd_create_pdev(struct bcma_device *dev,\r\nconst char *name, u32 addr,\r\nconst void *data,\r\nsize_t size)\r\n{\r\nstruct platform_device *hci_dev;\r\nstruct resource hci_res[2];\r\nint ret;\r\nmemset(hci_res, 0, sizeof(hci_res));\r\nhci_res[0].start = addr;\r\nhci_res[0].end = hci_res[0].start + 0x1000 - 1;\r\nhci_res[0].flags = IORESOURCE_MEM;\r\nhci_res[1].start = dev->irq;\r\nhci_res[1].flags = IORESOURCE_IRQ;\r\nhci_dev = platform_device_alloc(name, 0);\r\nif (!hci_dev)\r\nreturn ERR_PTR(-ENOMEM);\r\nhci_dev->dev.parent = &dev->dev;\r\nhci_dev->dev.dma_mask = &hci_dev->dev.coherent_dma_mask;\r\nret = platform_device_add_resources(hci_dev, hci_res,\r\nARRAY_SIZE(hci_res));\r\nif (ret)\r\ngoto err_alloc;\r\nif (data)\r\nret = platform_device_add_data(hci_dev, data, size);\r\nif (ret)\r\ngoto err_alloc;\r\nret = platform_device_add(hci_dev);\r\nif (ret)\r\ngoto err_alloc;\r\nreturn hci_dev;\r\nerr_alloc:\r\nplatform_device_put(hci_dev);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic int bcma_hcd_usb20_init(struct bcma_hcd_device *usb_dev)\r\n{\r\nstruct bcma_device *dev = usb_dev->core;\r\nstruct bcma_chipinfo *chipinfo = &dev->bus->chipinfo;\r\nu32 ohci_addr;\r\nint err;\r\nif (dma_set_mask_and_coherent(dev->dma_dev, DMA_BIT_MASK(32)))\r\nreturn -EOPNOTSUPP;\r\nbcma_hcd_init_chip_mips(dev);\r\nohci_addr = dev->addr_s[0];\r\nif ((chipinfo->id == BCMA_CHIP_ID_BCM5357 ||\r\nchipinfo->id == BCMA_CHIP_ID_BCM4749)\r\n&& chipinfo->rev == 0)\r\nohci_addr = 0x18009000;\r\nusb_dev->ohci_dev = bcma_hcd_create_pdev(dev, "ohci-platform",\r\nohci_addr, &ohci_pdata,\r\nsizeof(ohci_pdata));\r\nif (IS_ERR(usb_dev->ohci_dev))\r\nreturn PTR_ERR(usb_dev->ohci_dev);\r\nusb_dev->ehci_dev = bcma_hcd_create_pdev(dev, "ehci-platform",\r\ndev->addr, &ehci_pdata,\r\nsizeof(ehci_pdata));\r\nif (IS_ERR(usb_dev->ehci_dev)) {\r\nerr = PTR_ERR(usb_dev->ehci_dev);\r\ngoto err_unregister_ohci_dev;\r\n}\r\nreturn 0;\r\nerr_unregister_ohci_dev:\r\nplatform_device_unregister(usb_dev->ohci_dev);\r\nreturn err;\r\n}\r\nstatic int bcma_hcd_usb30_init(struct bcma_hcd_device *bcma_hcd)\r\n{\r\nstruct bcma_device *core = bcma_hcd->core;\r\nstruct device *dev = &core->dev;\r\nbcma_core_enable(core, 0);\r\nof_platform_default_populate(dev->of_node, NULL, dev);\r\nreturn 0;\r\n}\r\nstatic int bcma_hcd_probe(struct bcma_device *core)\r\n{\r\nint err;\r\nstruct bcma_hcd_device *usb_dev;\r\nusb_dev = devm_kzalloc(&core->dev, sizeof(struct bcma_hcd_device),\r\nGFP_KERNEL);\r\nif (!usb_dev)\r\nreturn -ENOMEM;\r\nusb_dev->core = core;\r\nif (core->dev.of_node)\r\nusb_dev->gpio_desc = devm_gpiod_get(&core->dev, "vcc",\r\nGPIOD_OUT_HIGH);\r\nswitch (core->id.id) {\r\ncase BCMA_CORE_USB20_HOST:\r\nif (IS_ENABLED(CONFIG_ARM))\r\nerr = bcma_hcd_usb20_old_arm_init(usb_dev);\r\nelse if (IS_ENABLED(CONFIG_MIPS))\r\nerr = bcma_hcd_usb20_init(usb_dev);\r\nelse\r\nerr = -ENOTSUPP;\r\nbreak;\r\ncase BCMA_CORE_NS_USB20:\r\nerr = bcma_hcd_usb20_ns_init(usb_dev);\r\nbreak;\r\ncase BCMA_CORE_NS_USB30:\r\nerr = bcma_hcd_usb30_init(usb_dev);\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nif (err)\r\nreturn err;\r\nbcma_set_drvdata(core, usb_dev);\r\nreturn 0;\r\n}\r\nstatic void bcma_hcd_remove(struct bcma_device *dev)\r\n{\r\nstruct bcma_hcd_device *usb_dev = bcma_get_drvdata(dev);\r\nstruct platform_device *ohci_dev = usb_dev->ohci_dev;\r\nstruct platform_device *ehci_dev = usb_dev->ehci_dev;\r\nif (ohci_dev)\r\nplatform_device_unregister(ohci_dev);\r\nif (ehci_dev)\r\nplatform_device_unregister(ehci_dev);\r\nbcma_core_disable(dev, 0);\r\n}\r\nstatic void bcma_hcd_shutdown(struct bcma_device *dev)\r\n{\r\nbcma_hci_platform_power_gpio(dev, false);\r\nbcma_core_disable(dev, 0);\r\n}\r\nstatic int bcma_hcd_suspend(struct bcma_device *dev)\r\n{\r\nbcma_hci_platform_power_gpio(dev, false);\r\nbcma_core_disable(dev, 0);\r\nreturn 0;\r\n}\r\nstatic int bcma_hcd_resume(struct bcma_device *dev)\r\n{\r\nbcma_hci_platform_power_gpio(dev, true);\r\nbcma_core_enable(dev, 0);\r\nreturn 0;\r\n}\r\nstatic int __init bcma_hcd_init(void)\r\n{\r\nreturn bcma_driver_register(&bcma_hcd_driver);\r\n}\r\nstatic void __exit bcma_hcd_exit(void)\r\n{\r\nbcma_driver_unregister(&bcma_hcd_driver);\r\n}
