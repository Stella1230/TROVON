static int dln2_spi_enable(struct dln2_spi *dln2, bool enable)\r\n{\r\nu16 cmd;\r\nstruct {\r\nu8 port;\r\nu8 wait_for_completion;\r\n} tx;\r\nunsigned len = sizeof(tx);\r\ntx.port = dln2->port;\r\nif (enable) {\r\ncmd = DLN2_SPI_ENABLE;\r\nlen -= sizeof(tx.wait_for_completion);\r\n} else {\r\ntx.wait_for_completion = DLN2_TRANSFERS_WAIT_COMPLETE;\r\ncmd = DLN2_SPI_DISABLE;\r\n}\r\nreturn dln2_transfer_tx(dln2->pdev, cmd, &tx, len);\r\n}\r\nstatic int dln2_spi_cs_set(struct dln2_spi *dln2, u8 cs_mask)\r\n{\r\nstruct {\r\nu8 port;\r\nu8 cs;\r\n} tx;\r\ntx.port = dln2->port;\r\ntx.cs = ~cs_mask;\r\nreturn dln2_transfer_tx(dln2->pdev, DLN2_SPI_SET_SS, &tx, sizeof(tx));\r\n}\r\nstatic int dln2_spi_cs_set_one(struct dln2_spi *dln2, u8 cs)\r\n{\r\nreturn dln2_spi_cs_set(dln2, BIT(cs));\r\n}\r\nstatic int dln2_spi_cs_enable(struct dln2_spi *dln2, u8 cs_mask, bool enable)\r\n{\r\nstruct {\r\nu8 port;\r\nu8 cs;\r\n} tx;\r\nu16 cmd;\r\ntx.port = dln2->port;\r\ntx.cs = cs_mask;\r\ncmd = enable ? DLN2_SPI_SS_MULTI_ENABLE : DLN2_SPI_SS_MULTI_DISABLE;\r\nreturn dln2_transfer_tx(dln2->pdev, cmd, &tx, sizeof(tx));\r\n}\r\nstatic int dln2_spi_cs_enable_all(struct dln2_spi *dln2, bool enable)\r\n{\r\nu8 cs_mask = GENMASK(dln2->master->num_chipselect - 1, 0);\r\nreturn dln2_spi_cs_enable(dln2, cs_mask, enable);\r\n}\r\nstatic int dln2_spi_get_cs_num(struct dln2_spi *dln2, u16 *cs_num)\r\n{\r\nint ret;\r\nstruct {\r\nu8 port;\r\n} tx;\r\nstruct {\r\n__le16 cs_count;\r\n} rx;\r\nunsigned rx_len = sizeof(rx);\r\ntx.port = dln2->port;\r\nret = dln2_transfer(dln2->pdev, DLN2_SPI_GET_SS_COUNT, &tx, sizeof(tx),\r\n&rx, &rx_len);\r\nif (ret < 0)\r\nreturn ret;\r\nif (rx_len < sizeof(rx))\r\nreturn -EPROTO;\r\n*cs_num = le16_to_cpu(rx.cs_count);\r\ndev_dbg(&dln2->pdev->dev, "cs_num = %d\n", *cs_num);\r\nreturn 0;\r\n}\r\nstatic int dln2_spi_get_speed(struct dln2_spi *dln2, u16 cmd, u32 *freq)\r\n{\r\nint ret;\r\nstruct {\r\nu8 port;\r\n} tx;\r\nstruct {\r\n__le32 speed;\r\n} rx;\r\nunsigned rx_len = sizeof(rx);\r\ntx.port = dln2->port;\r\nret = dln2_transfer(dln2->pdev, cmd, &tx, sizeof(tx), &rx, &rx_len);\r\nif (ret < 0)\r\nreturn ret;\r\nif (rx_len < sizeof(rx))\r\nreturn -EPROTO;\r\n*freq = le32_to_cpu(rx.speed);\r\nreturn 0;\r\n}\r\nstatic int dln2_spi_get_speed_range(struct dln2_spi *dln2, u32 *fmin, u32 *fmax)\r\n{\r\nint ret;\r\nret = dln2_spi_get_speed(dln2, DLN2_SPI_GET_MIN_FREQUENCY, fmin);\r\nif (ret < 0)\r\nreturn ret;\r\nret = dln2_spi_get_speed(dln2, DLN2_SPI_GET_MAX_FREQUENCY, fmax);\r\nif (ret < 0)\r\nreturn ret;\r\ndev_dbg(&dln2->pdev->dev, "freq_min = %d, freq_max = %d\n",\r\n*fmin, *fmax);\r\nreturn 0;\r\n}\r\nstatic int dln2_spi_set_speed(struct dln2_spi *dln2, u32 speed)\r\n{\r\nint ret;\r\nstruct {\r\nu8 port;\r\n__le32 speed;\r\n} __packed tx;\r\nstruct {\r\n__le32 speed;\r\n} rx;\r\nint rx_len = sizeof(rx);\r\ntx.port = dln2->port;\r\ntx.speed = cpu_to_le32(speed);\r\nret = dln2_transfer(dln2->pdev, DLN2_SPI_SET_FREQUENCY, &tx, sizeof(tx),\r\n&rx, &rx_len);\r\nif (ret < 0)\r\nreturn ret;\r\nif (rx_len < sizeof(rx))\r\nreturn -EPROTO;\r\nreturn 0;\r\n}\r\nstatic int dln2_spi_set_mode(struct dln2_spi *dln2, u8 mode)\r\n{\r\nstruct {\r\nu8 port;\r\nu8 mode;\r\n} tx;\r\ntx.port = dln2->port;\r\ntx.mode = mode;\r\nreturn dln2_transfer_tx(dln2->pdev, DLN2_SPI_SET_MODE, &tx, sizeof(tx));\r\n}\r\nstatic int dln2_spi_set_bpw(struct dln2_spi *dln2, u8 bpw)\r\n{\r\nstruct {\r\nu8 port;\r\nu8 bpw;\r\n} tx;\r\ntx.port = dln2->port;\r\ntx.bpw = bpw;\r\nreturn dln2_transfer_tx(dln2->pdev, DLN2_SPI_SET_FRAME_SIZE,\r\n&tx, sizeof(tx));\r\n}\r\nstatic int dln2_spi_get_supported_frame_sizes(struct dln2_spi *dln2,\r\nu32 *bpw_mask)\r\n{\r\nint ret;\r\nstruct {\r\nu8 port;\r\n} tx;\r\nstruct {\r\nu8 count;\r\nu8 frame_sizes[36];\r\n} *rx = dln2->buf;\r\nunsigned rx_len = sizeof(*rx);\r\nint i;\r\ntx.port = dln2->port;\r\nret = dln2_transfer(dln2->pdev, DLN2_SPI_GET_SUPPORTED_FRAME_SIZES,\r\n&tx, sizeof(tx), rx, &rx_len);\r\nif (ret < 0)\r\nreturn ret;\r\nif (rx_len < sizeof(*rx))\r\nreturn -EPROTO;\r\nif (rx->count > ARRAY_SIZE(rx->frame_sizes))\r\nreturn -EPROTO;\r\n*bpw_mask = 0;\r\nfor (i = 0; i < rx->count; i++)\r\n*bpw_mask |= BIT(rx->frame_sizes[i] - 1);\r\ndev_dbg(&dln2->pdev->dev, "bpw_mask = 0x%X\n", *bpw_mask);\r\nreturn 0;\r\n}\r\nstatic int dln2_spi_copy_to_buf(u8 *dln2_buf, const u8 *src, u16 len, u8 bpw)\r\n{\r\n#ifdef __LITTLE_ENDIAN\r\nmemcpy(dln2_buf, src, len);\r\n#else\r\nif (bpw <= 8) {\r\nmemcpy(dln2_buf, src, len);\r\n} else if (bpw <= 16) {\r\n__le16 *d = (__le16 *)dln2_buf;\r\nu16 *s = (u16 *)src;\r\nlen = len / 2;\r\nwhile (len--)\r\n*d++ = cpu_to_le16p(s++);\r\n} else {\r\n__le32 *d = (__le32 *)dln2_buf;\r\nu32 *s = (u32 *)src;\r\nlen = len / 4;\r\nwhile (len--)\r\n*d++ = cpu_to_le32p(s++);\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int dln2_spi_copy_from_buf(u8 *dest, const u8 *dln2_buf, u16 len, u8 bpw)\r\n{\r\n#ifdef __LITTLE_ENDIAN\r\nmemcpy(dest, dln2_buf, len);\r\n#else\r\nif (bpw <= 8) {\r\nmemcpy(dest, dln2_buf, len);\r\n} else if (bpw <= 16) {\r\nu16 *d = (u16 *)dest;\r\n__le16 *s = (__le16 *)dln2_buf;\r\nlen = len / 2;\r\nwhile (len--)\r\n*d++ = le16_to_cpup(s++);\r\n} else {\r\nu32 *d = (u32 *)dest;\r\n__le32 *s = (__le32 *)dln2_buf;\r\nlen = len / 4;\r\nwhile (len--)\r\n*d++ = get_unaligned_le32(s++);\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int dln2_spi_write_one(struct dln2_spi *dln2, const u8 *data,\r\nu16 data_len, u8 attr)\r\n{\r\nstruct {\r\nu8 port;\r\n__le16 size;\r\nu8 attr;\r\nu8 buf[DLN2_SPI_MAX_XFER_SIZE];\r\n} __packed *tx = dln2->buf;\r\nunsigned tx_len;\r\nBUILD_BUG_ON(sizeof(*tx) > DLN2_SPI_BUF_SIZE);\r\nif (data_len > DLN2_SPI_MAX_XFER_SIZE)\r\nreturn -EINVAL;\r\ntx->port = dln2->port;\r\ntx->size = cpu_to_le16(data_len);\r\ntx->attr = attr;\r\ndln2_spi_copy_to_buf(tx->buf, data, data_len, dln2->bpw);\r\ntx_len = sizeof(*tx) + data_len - DLN2_SPI_MAX_XFER_SIZE;\r\nreturn dln2_transfer_tx(dln2->pdev, DLN2_SPI_WRITE, tx, tx_len);\r\n}\r\nstatic int dln2_spi_read_one(struct dln2_spi *dln2, u8 *data,\r\nu16 data_len, u8 attr)\r\n{\r\nint ret;\r\nstruct {\r\nu8 port;\r\n__le16 size;\r\nu8 attr;\r\n} __packed tx;\r\nstruct {\r\n__le16 size;\r\nu8 buf[DLN2_SPI_MAX_XFER_SIZE];\r\n} __packed *rx = dln2->buf;\r\nunsigned rx_len = sizeof(*rx);\r\nBUILD_BUG_ON(sizeof(*rx) > DLN2_SPI_BUF_SIZE);\r\nif (data_len > DLN2_SPI_MAX_XFER_SIZE)\r\nreturn -EINVAL;\r\ntx.port = dln2->port;\r\ntx.size = cpu_to_le16(data_len);\r\ntx.attr = attr;\r\nret = dln2_transfer(dln2->pdev, DLN2_SPI_READ, &tx, sizeof(tx),\r\nrx, &rx_len);\r\nif (ret < 0)\r\nreturn ret;\r\nif (rx_len < sizeof(rx->size) + data_len)\r\nreturn -EPROTO;\r\nif (le16_to_cpu(rx->size) != data_len)\r\nreturn -EPROTO;\r\ndln2_spi_copy_from_buf(data, rx->buf, data_len, dln2->bpw);\r\nreturn 0;\r\n}\r\nstatic int dln2_spi_read_write_one(struct dln2_spi *dln2, const u8 *tx_data,\r\nu8 *rx_data, u16 data_len, u8 attr)\r\n{\r\nint ret;\r\nstruct {\r\nu8 port;\r\n__le16 size;\r\nu8 attr;\r\nu8 buf[DLN2_SPI_MAX_XFER_SIZE];\r\n} __packed *tx;\r\nstruct {\r\n__le16 size;\r\nu8 buf[DLN2_SPI_MAX_XFER_SIZE];\r\n} __packed *rx;\r\nunsigned tx_len, rx_len;\r\nBUILD_BUG_ON(sizeof(*tx) > DLN2_SPI_BUF_SIZE ||\r\nsizeof(*rx) > DLN2_SPI_BUF_SIZE);\r\nif (data_len > DLN2_SPI_MAX_XFER_SIZE)\r\nreturn -EINVAL;\r\ntx = dln2->buf;\r\nrx = dln2->buf;\r\ntx->port = dln2->port;\r\ntx->size = cpu_to_le16(data_len);\r\ntx->attr = attr;\r\ndln2_spi_copy_to_buf(tx->buf, tx_data, data_len, dln2->bpw);\r\ntx_len = sizeof(*tx) + data_len - DLN2_SPI_MAX_XFER_SIZE;\r\nrx_len = sizeof(*rx);\r\nret = dln2_transfer(dln2->pdev, DLN2_SPI_READ_WRITE, tx, tx_len,\r\nrx, &rx_len);\r\nif (ret < 0)\r\nreturn ret;\r\nif (rx_len < sizeof(rx->size) + data_len)\r\nreturn -EPROTO;\r\nif (le16_to_cpu(rx->size) != data_len)\r\nreturn -EPROTO;\r\ndln2_spi_copy_from_buf(rx_data, rx->buf, data_len, dln2->bpw);\r\nreturn 0;\r\n}\r\nstatic int dln2_spi_rdwr(struct dln2_spi *dln2, const u8 *tx_data,\r\nu8 *rx_data, u16 data_len, u8 attr) {\r\nint ret;\r\nu16 len;\r\nu8 temp_attr;\r\nu16 remaining = data_len;\r\nu16 offset;\r\ndo {\r\nif (remaining > DLN2_SPI_MAX_XFER_SIZE) {\r\nlen = DLN2_SPI_MAX_XFER_SIZE;\r\ntemp_attr = DLN2_SPI_ATTR_LEAVE_SS_LOW;\r\n} else {\r\nlen = remaining;\r\ntemp_attr = attr;\r\n}\r\noffset = data_len - remaining;\r\nif (tx_data && rx_data) {\r\nret = dln2_spi_read_write_one(dln2,\r\ntx_data + offset,\r\nrx_data + offset,\r\nlen, temp_attr);\r\n} else if (tx_data) {\r\nret = dln2_spi_write_one(dln2,\r\ntx_data + offset,\r\nlen, temp_attr);\r\n} else if (rx_data) {\r\nret = dln2_spi_read_one(dln2,\r\nrx_data + offset,\r\nlen, temp_attr);\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nif (ret < 0)\r\nreturn ret;\r\nremaining -= len;\r\n} while (remaining);\r\nreturn 0;\r\n}\r\nstatic int dln2_spi_prepare_message(struct spi_master *master,\r\nstruct spi_message *message)\r\n{\r\nint ret;\r\nstruct dln2_spi *dln2 = spi_master_get_devdata(master);\r\nstruct spi_device *spi = message->spi;\r\nif (dln2->cs != spi->chip_select) {\r\nret = dln2_spi_cs_set_one(dln2, spi->chip_select);\r\nif (ret < 0)\r\nreturn ret;\r\ndln2->cs = spi->chip_select;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dln2_spi_transfer_setup(struct dln2_spi *dln2, u32 speed,\r\nu8 bpw, u8 mode)\r\n{\r\nint ret;\r\nbool bus_setup_change;\r\nbus_setup_change = dln2->speed != speed || dln2->mode != mode ||\r\ndln2->bpw != bpw;\r\nif (!bus_setup_change)\r\nreturn 0;\r\nret = dln2_spi_enable(dln2, false);\r\nif (ret < 0)\r\nreturn ret;\r\nif (dln2->speed != speed) {\r\nret = dln2_spi_set_speed(dln2, speed);\r\nif (ret < 0)\r\nreturn ret;\r\ndln2->speed = speed;\r\n}\r\nif (dln2->mode != mode) {\r\nret = dln2_spi_set_mode(dln2, mode & 0x3);\r\nif (ret < 0)\r\nreturn ret;\r\ndln2->mode = mode;\r\n}\r\nif (dln2->bpw != bpw) {\r\nret = dln2_spi_set_bpw(dln2, bpw);\r\nif (ret < 0)\r\nreturn ret;\r\ndln2->bpw = bpw;\r\n}\r\nreturn dln2_spi_enable(dln2, true);\r\n}\r\nstatic int dln2_spi_transfer_one(struct spi_master *master,\r\nstruct spi_device *spi,\r\nstruct spi_transfer *xfer)\r\n{\r\nstruct dln2_spi *dln2 = spi_master_get_devdata(master);\r\nint status;\r\nu8 attr = 0;\r\nstatus = dln2_spi_transfer_setup(dln2, xfer->speed_hz,\r\nxfer->bits_per_word,\r\nspi->mode);\r\nif (status < 0) {\r\ndev_err(&dln2->pdev->dev, "Cannot setup transfer\n");\r\nreturn status;\r\n}\r\nif (!xfer->cs_change && !spi_transfer_is_last(master, xfer))\r\nattr = DLN2_SPI_ATTR_LEAVE_SS_LOW;\r\nstatus = dln2_spi_rdwr(dln2, xfer->tx_buf, xfer->rx_buf,\r\nxfer->len, attr);\r\nif (status < 0)\r\ndev_err(&dln2->pdev->dev, "write/read failed!\n");\r\nreturn status;\r\n}\r\nstatic int dln2_spi_probe(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master;\r\nstruct dln2_spi *dln2;\r\nstruct dln2_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct device *dev = &pdev->dev;\r\nint ret;\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(*dln2));\r\nif (!master)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, master);\r\ndln2 = spi_master_get_devdata(master);\r\ndln2->buf = devm_kmalloc(&pdev->dev, DLN2_SPI_BUF_SIZE, GFP_KERNEL);\r\nif (!dln2->buf) {\r\nret = -ENOMEM;\r\ngoto exit_free_master;\r\n}\r\ndln2->master = master;\r\ndln2->master->dev.of_node = dev->of_node;\r\ndln2->pdev = pdev;\r\ndln2->port = pdata->port;\r\ndln2->cs = 0xff;\r\ndln2->mode = 0xff;\r\nret = dln2_spi_enable(dln2, false);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed to disable SPI module\n");\r\ngoto exit_free_master;\r\n}\r\nret = dln2_spi_get_cs_num(dln2, &master->num_chipselect);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed to get number of CS pins\n");\r\ngoto exit_free_master;\r\n}\r\nret = dln2_spi_get_speed_range(dln2,\r\n&master->min_speed_hz,\r\n&master->max_speed_hz);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed to read bus min/max freqs\n");\r\ngoto exit_free_master;\r\n}\r\nret = dln2_spi_get_supported_frame_sizes(dln2,\r\n&master->bits_per_word_mask);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed to read supported frame sizes\n");\r\ngoto exit_free_master;\r\n}\r\nret = dln2_spi_cs_enable_all(dln2, true);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed to enable CS pins\n");\r\ngoto exit_free_master;\r\n}\r\nmaster->bus_num = -1;\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA;\r\nmaster->prepare_message = dln2_spi_prepare_message;\r\nmaster->transfer_one = dln2_spi_transfer_one;\r\nmaster->auto_runtime_pm = true;\r\nret = dln2_spi_enable(dln2, true);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed to enable SPI module\n");\r\ngoto exit_free_master;\r\n}\r\npm_runtime_set_autosuspend_delay(&pdev->dev,\r\nDLN2_RPM_AUTOSUSPEND_TIMEOUT);\r\npm_runtime_use_autosuspend(&pdev->dev);\r\npm_runtime_set_active(&pdev->dev);\r\npm_runtime_enable(&pdev->dev);\r\nret = devm_spi_register_master(&pdev->dev, master);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed to register master\n");\r\ngoto exit_register;\r\n}\r\nreturn ret;\r\nexit_register:\r\npm_runtime_disable(&pdev->dev);\r\npm_runtime_set_suspended(&pdev->dev);\r\nif (dln2_spi_enable(dln2, false) < 0)\r\ndev_err(&pdev->dev, "Failed to disable SPI module\n");\r\nexit_free_master:\r\nspi_master_put(master);\r\nreturn ret;\r\n}\r\nstatic int dln2_spi_remove(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master = spi_master_get(platform_get_drvdata(pdev));\r\nstruct dln2_spi *dln2 = spi_master_get_devdata(master);\r\npm_runtime_disable(&pdev->dev);\r\nif (dln2_spi_enable(dln2, false) < 0)\r\ndev_err(&pdev->dev, "Failed to disable SPI module\n");\r\nreturn 0;\r\n}\r\nstatic int dln2_spi_suspend(struct device *dev)\r\n{\r\nint ret;\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct dln2_spi *dln2 = spi_master_get_devdata(master);\r\nret = spi_master_suspend(master);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!pm_runtime_suspended(dev)) {\r\nret = dln2_spi_enable(dln2, false);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\ndln2->cs = 0xff;\r\ndln2->speed = 0;\r\ndln2->bpw = 0;\r\ndln2->mode = 0xff;\r\nreturn 0;\r\n}\r\nstatic int dln2_spi_resume(struct device *dev)\r\n{\r\nint ret;\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct dln2_spi *dln2 = spi_master_get_devdata(master);\r\nif (!pm_runtime_suspended(dev)) {\r\nret = dln2_spi_cs_enable_all(dln2, true);\r\nif (ret < 0)\r\nreturn ret;\r\nret = dln2_spi_enable(dln2, true);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn spi_master_resume(master);\r\n}\r\nstatic int dln2_spi_runtime_suspend(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct dln2_spi *dln2 = spi_master_get_devdata(master);\r\nreturn dln2_spi_enable(dln2, false);\r\n}\r\nstatic int dln2_spi_runtime_resume(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct dln2_spi *dln2 = spi_master_get_devdata(master);\r\nreturn dln2_spi_enable(dln2, true);\r\n}
