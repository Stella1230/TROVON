static inline int ucsi_sync(struct ucsi *ucsi)\r\n{\r\nif (ucsi->ppm && ucsi->ppm->sync)\r\nreturn ucsi->ppm->sync(ucsi->ppm);\r\nreturn 0;\r\n}\r\nstatic int ucsi_command(struct ucsi *ucsi, struct ucsi_control *ctrl)\r\n{\r\nint ret;\r\ntrace_ucsi_command(ctrl);\r\nset_bit(COMMAND_PENDING, &ucsi->flags);\r\nret = ucsi->ppm->cmd(ucsi->ppm, ctrl);\r\nif (ret)\r\ngoto err_clear_flag;\r\nif (!wait_for_completion_timeout(&ucsi->complete,\r\nmsecs_to_jiffies(UCSI_TIMEOUT_MS))) {\r\ndev_warn(ucsi->dev, "PPM NOT RESPONDING\n");\r\nret = -ETIMEDOUT;\r\n}\r\nerr_clear_flag:\r\nclear_bit(COMMAND_PENDING, &ucsi->flags);\r\nreturn ret;\r\n}\r\nstatic int ucsi_ack(struct ucsi *ucsi, u8 ack)\r\n{\r\nstruct ucsi_control ctrl;\r\nint ret;\r\ntrace_ucsi_ack(ack);\r\nset_bit(ACK_PENDING, &ucsi->flags);\r\nUCSI_CMD_ACK(ctrl, ack);\r\nret = ucsi->ppm->cmd(ucsi->ppm, &ctrl);\r\nif (ret)\r\ngoto out_clear_bit;\r\nif (ack == UCSI_ACK_EVENT)\r\ngoto out_clear_bit;\r\nif (!wait_for_completion_timeout(&ucsi->complete,\r\nmsecs_to_jiffies(UCSI_TIMEOUT_MS)))\r\nret = -ETIMEDOUT;\r\nout_clear_bit:\r\nclear_bit(ACK_PENDING, &ucsi->flags);\r\nif (ret)\r\ndev_err(ucsi->dev, "%s: failed\n", __func__);\r\nreturn ret;\r\n}\r\nstatic int ucsi_run_command(struct ucsi *ucsi, struct ucsi_control *ctrl,\r\nvoid *data, size_t size)\r\n{\r\nstruct ucsi_control _ctrl;\r\nu8 data_length;\r\nu16 error;\r\nint ret;\r\nret = ucsi_command(ucsi, ctrl);\r\nif (ret)\r\ngoto err;\r\nswitch (ucsi->status) {\r\ncase UCSI_IDLE:\r\nret = ucsi_sync(ucsi);\r\nif (ret)\r\ndev_warn(ucsi->dev, "%s: sync failed\n", __func__);\r\nif (data)\r\nmemcpy(data, ucsi->ppm->data->message_in, size);\r\ndata_length = ucsi->ppm->data->cci.data_length;\r\nret = ucsi_ack(ucsi, UCSI_ACK_CMD);\r\nif (!ret)\r\nret = data_length;\r\nbreak;\r\ncase UCSI_BUSY:\r\nret = -EBUSY;\r\nbreak;\r\ncase UCSI_ERROR:\r\nret = ucsi_ack(ucsi, UCSI_ACK_CMD);\r\nif (ret)\r\nbreak;\r\n_ctrl.raw_cmd = 0;\r\n_ctrl.cmd.cmd = UCSI_GET_ERROR_STATUS;\r\nret = ucsi_command(ucsi, &_ctrl);\r\nif (ret) {\r\ndev_err(ucsi->dev, "reading error failed!\n");\r\nbreak;\r\n}\r\nmemcpy(&error, ucsi->ppm->data->message_in, sizeof(error));\r\nif (WARN_ON(ucsi->status == UCSI_ERROR)) {\r\nret = -ENODEV;\r\nbreak;\r\n}\r\nret = ucsi_ack(ucsi, UCSI_ACK_CMD);\r\nif (ret)\r\nbreak;\r\nswitch (error) {\r\ncase UCSI_ERROR_INCOMPATIBLE_PARTNER:\r\nret = -EOPNOTSUPP;\r\nbreak;\r\ncase UCSI_ERROR_CC_COMMUNICATION_ERR:\r\nret = -ECOMM;\r\nbreak;\r\ncase UCSI_ERROR_CONTRACT_NEGOTIATION_FAIL:\r\nret = -EPROTO;\r\nbreak;\r\ncase UCSI_ERROR_DEAD_BATTERY:\r\ndev_warn(ucsi->dev, "Dead battery condition!\n");\r\nret = -EPERM;\r\nbreak;\r\ncase UCSI_ERROR_INVALID_CON_NUM:\r\ncase UCSI_ERROR_UNREGONIZED_CMD:\r\ncase UCSI_ERROR_INVALID_CMD_ARGUMENT:\r\ndev_warn(ucsi->dev,\r\n"%s: possible UCSI driver bug - error 0x%x\n",\r\n__func__, error);\r\nret = -EINVAL;\r\nbreak;\r\ndefault:\r\ndev_warn(ucsi->dev,\r\n"%s: error without status\n", __func__);\r\nret = -EIO;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nerr:\r\ntrace_ucsi_run_command(ctrl, ret);\r\nreturn ret;\r\n}\r\nstatic void ucsi_pwr_opmode_change(struct ucsi_connector *con)\r\n{\r\nswitch (con->status.pwr_op_mode) {\r\ncase UCSI_CONSTAT_PWR_OPMODE_PD:\r\ntypec_set_pwr_opmode(con->port, TYPEC_PWR_MODE_PD);\r\nbreak;\r\ncase UCSI_CONSTAT_PWR_OPMODE_TYPEC1_5:\r\ntypec_set_pwr_opmode(con->port, TYPEC_PWR_MODE_1_5A);\r\nbreak;\r\ncase UCSI_CONSTAT_PWR_OPMODE_TYPEC3_0:\r\ntypec_set_pwr_opmode(con->port, TYPEC_PWR_MODE_3_0A);\r\nbreak;\r\ndefault:\r\ntypec_set_pwr_opmode(con->port, TYPEC_PWR_MODE_USB);\r\nbreak;\r\n}\r\n}\r\nstatic int ucsi_register_partner(struct ucsi_connector *con)\r\n{\r\nstruct typec_partner_desc partner;\r\nif (con->partner)\r\nreturn 0;\r\nmemset(&partner, 0, sizeof(partner));\r\nswitch (con->status.partner_type) {\r\ncase UCSI_CONSTAT_PARTNER_TYPE_DEBUG:\r\npartner.accessory = TYPEC_ACCESSORY_DEBUG;\r\nbreak;\r\ncase UCSI_CONSTAT_PARTNER_TYPE_AUDIO:\r\npartner.accessory = TYPEC_ACCESSORY_AUDIO;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\npartner.usb_pd = con->status.pwr_op_mode == UCSI_CONSTAT_PWR_OPMODE_PD;\r\ncon->partner = typec_register_partner(con->port, &partner);\r\nif (!con->partner) {\r\ndev_err(con->ucsi->dev, "con%d: failed to register partner\n",\r\ncon->num);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ucsi_unregister_partner(struct ucsi_connector *con)\r\n{\r\ntypec_unregister_partner(con->partner);\r\ncon->partner = NULL;\r\n}\r\nstatic void ucsi_connector_change(struct work_struct *work)\r\n{\r\nstruct ucsi_connector *con = container_of(work, struct ucsi_connector,\r\nwork);\r\nstruct ucsi *ucsi = con->ucsi;\r\nstruct ucsi_control ctrl;\r\nint ret;\r\nmutex_lock(&ucsi->ppm_lock);\r\nUCSI_CMD_GET_CONNECTOR_STATUS(ctrl, con->num);\r\nret = ucsi_run_command(ucsi, &ctrl, &con->status, sizeof(con->status));\r\nif (ret < 0) {\r\ndev_err(ucsi->dev, "%s: GET_CONNECTOR_STATUS failed (%d)\n",\r\n__func__, ret);\r\ngoto out_unlock;\r\n}\r\nif (con->status.change & UCSI_CONSTAT_POWER_OPMODE_CHANGE)\r\nucsi_pwr_opmode_change(con);\r\nif (con->status.change & UCSI_CONSTAT_POWER_DIR_CHANGE) {\r\ntypec_set_pwr_role(con->port, con->status.pwr_dir);\r\nif (!completion_done(&con->complete))\r\ncomplete(&con->complete);\r\n}\r\nif (con->status.change & UCSI_CONSTAT_PARTNER_CHANGE) {\r\nswitch (con->status.partner_type) {\r\ncase UCSI_CONSTAT_PARTNER_TYPE_UFP:\r\ntypec_set_data_role(con->port, TYPEC_HOST);\r\nbreak;\r\ncase UCSI_CONSTAT_PARTNER_TYPE_DFP:\r\ntypec_set_data_role(con->port, TYPEC_DEVICE);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (!completion_done(&con->complete))\r\ncomplete(&con->complete);\r\n}\r\nif (con->status.change & UCSI_CONSTAT_CONNECT_CHANGE) {\r\nif (con->status.connected)\r\nucsi_register_partner(con);\r\nelse\r\nucsi_unregister_partner(con);\r\n}\r\nret = ucsi_ack(ucsi, UCSI_ACK_EVENT);\r\nif (ret)\r\ndev_err(ucsi->dev, "%s: ACK failed (%d)", __func__, ret);\r\ntrace_ucsi_connector_change(con->num, &con->status);\r\nout_unlock:\r\nclear_bit(EVENT_PENDING, &ucsi->flags);\r\nmutex_unlock(&ucsi->ppm_lock);\r\n}\r\nvoid ucsi_notify(struct ucsi *ucsi)\r\n{\r\nstruct ucsi_cci *cci;\r\nucsi_sync(ucsi);\r\ncci = &ucsi->ppm->data->cci;\r\nif (cci->error)\r\nucsi->status = UCSI_ERROR;\r\nelse if (cci->busy)\r\nucsi->status = UCSI_BUSY;\r\nelse\r\nucsi->status = UCSI_IDLE;\r\nif (cci->cmd_complete && test_bit(COMMAND_PENDING, &ucsi->flags)) {\r\ncomplete(&ucsi->complete);\r\n} else if (cci->ack_complete && test_bit(ACK_PENDING, &ucsi->flags)) {\r\ncomplete(&ucsi->complete);\r\n} else if (cci->connector_change) {\r\nstruct ucsi_connector *con;\r\ncon = &ucsi->connector[cci->connector_change - 1];\r\nif (!test_and_set_bit(EVENT_PENDING, &ucsi->flags))\r\nschedule_work(&con->work);\r\n}\r\ntrace_ucsi_notify(ucsi->ppm->data->raw_cci);\r\n}\r\nstatic int ucsi_reset_connector(struct ucsi_connector *con, bool hard)\r\n{\r\nstruct ucsi_control ctrl;\r\nUCSI_CMD_CONNECTOR_RESET(ctrl, con, hard);\r\nreturn ucsi_run_command(con->ucsi, &ctrl, NULL, 0);\r\n}\r\nstatic int ucsi_reset_ppm(struct ucsi *ucsi)\r\n{\r\nstruct ucsi_control ctrl;\r\nunsigned long tmo;\r\nint ret;\r\nctrl.raw_cmd = 0;\r\nctrl.cmd.cmd = UCSI_PPM_RESET;\r\ntrace_ucsi_command(&ctrl);\r\nret = ucsi->ppm->cmd(ucsi->ppm, &ctrl);\r\nif (ret)\r\ngoto err;\r\ntmo = jiffies + msecs_to_jiffies(UCSI_TIMEOUT_MS);\r\ndo {\r\nret = ucsi_sync(ucsi);\r\nif (ret)\r\ngoto err;\r\nif (ucsi->ppm->data->cci.reset_complete)\r\nbreak;\r\nif (ucsi->ppm->data->raw_cci) {\r\ndev_warn_ratelimited(ucsi->dev,\r\n"Failed to reset PPM! Trying again..\n");\r\ntrace_ucsi_command(&ctrl);\r\nret = ucsi->ppm->cmd(ucsi->ppm, &ctrl);\r\nif (ret)\r\ngoto err;\r\n}\r\nmsleep(20);\r\nret = -ETIMEDOUT;\r\n} while (time_is_after_jiffies(tmo));\r\nerr:\r\ntrace_ucsi_reset_ppm(&ctrl, ret);\r\nreturn ret;\r\n}\r\nstatic int ucsi_role_cmd(struct ucsi_connector *con, struct ucsi_control *ctrl)\r\n{\r\nint ret;\r\nret = ucsi_run_command(con->ucsi, ctrl, NULL, 0);\r\nif (ret == -ETIMEDOUT) {\r\nstruct ucsi_control c;\r\nucsi_reset_ppm(con->ucsi);\r\nUCSI_CMD_SET_NTFY_ENABLE(c, UCSI_ENABLE_NTFY_ALL);\r\nucsi_run_command(con->ucsi, &c, NULL, 0);\r\nucsi_reset_connector(con, true);\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nucsi_dr_swap(const struct typec_capability *cap, enum typec_data_role role)\r\n{\r\nstruct ucsi_connector *con = to_ucsi_connector(cap);\r\nstruct ucsi_control ctrl;\r\nint ret = 0;\r\nif (!con->partner)\r\nreturn -ENOTCONN;\r\nmutex_lock(&con->ucsi->ppm_lock);\r\nif ((con->status.partner_type == UCSI_CONSTAT_PARTNER_TYPE_DFP &&\r\nrole == TYPEC_DEVICE) ||\r\n(con->status.partner_type == UCSI_CONSTAT_PARTNER_TYPE_UFP &&\r\nrole == TYPEC_HOST))\r\ngoto out_unlock;\r\nUCSI_CMD_SET_UOR(ctrl, con, role);\r\nret = ucsi_role_cmd(con, &ctrl);\r\nif (ret < 0)\r\ngoto out_unlock;\r\nmutex_unlock(&con->ucsi->ppm_lock);\r\nif (!wait_for_completion_timeout(&con->complete,\r\nmsecs_to_jiffies(UCSI_SWAP_TIMEOUT_MS)))\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\nout_unlock:\r\nmutex_unlock(&con->ucsi->ppm_lock);\r\nreturn ret;\r\n}\r\nstatic int\r\nucsi_pr_swap(const struct typec_capability *cap, enum typec_role role)\r\n{\r\nstruct ucsi_connector *con = to_ucsi_connector(cap);\r\nstruct ucsi_control ctrl;\r\nint ret = 0;\r\nif (!con->partner)\r\nreturn -ENOTCONN;\r\nmutex_lock(&con->ucsi->ppm_lock);\r\nif (con->status.pwr_dir == role)\r\ngoto out_unlock;\r\nUCSI_CMD_SET_PDR(ctrl, con, role);\r\nret = ucsi_role_cmd(con, &ctrl);\r\nif (ret < 0)\r\ngoto out_unlock;\r\nmutex_unlock(&con->ucsi->ppm_lock);\r\nif (!wait_for_completion_timeout(&con->complete,\r\nmsecs_to_jiffies(UCSI_SWAP_TIMEOUT_MS)))\r\nreturn -ETIMEDOUT;\r\nmutex_lock(&con->ucsi->ppm_lock);\r\nif (con->status.pwr_op_mode != UCSI_CONSTAT_PWR_OPMODE_PD) {\r\nucsi_reset_connector(con, true);\r\nret = -EPROTO;\r\n}\r\nout_unlock:\r\nmutex_unlock(&con->ucsi->ppm_lock);\r\nreturn ret;\r\n}\r\nstatic struct fwnode_handle *ucsi_find_fwnode(struct ucsi_connector *con)\r\n{\r\nstruct fwnode_handle *fwnode;\r\nint i = 1;\r\ndevice_for_each_child_node(con->ucsi->dev, fwnode)\r\nif (i++ == con->num)\r\nreturn fwnode;\r\nreturn NULL;\r\n}\r\nstatic int ucsi_register_port(struct ucsi *ucsi, int index)\r\n{\r\nstruct ucsi_connector *con = &ucsi->connector[index];\r\nstruct typec_capability *cap = &con->typec_cap;\r\nenum typec_accessory *accessory = cap->accessory;\r\nstruct ucsi_control ctrl;\r\nint ret;\r\nINIT_WORK(&con->work, ucsi_connector_change);\r\ninit_completion(&con->complete);\r\ncon->num = index + 1;\r\ncon->ucsi = ucsi;\r\nUCSI_CMD_GET_CONNECTOR_CAPABILITY(ctrl, con->num);\r\nret = ucsi_run_command(ucsi, &ctrl, &con->cap, sizeof(con->cap));\r\nif (ret < 0)\r\nreturn ret;\r\nif (con->cap.op_mode & UCSI_CONCAP_OPMODE_DRP)\r\ncap->type = TYPEC_PORT_DRP;\r\nelse if (con->cap.op_mode & UCSI_CONCAP_OPMODE_DFP)\r\ncap->type = TYPEC_PORT_DFP;\r\nelse if (con->cap.op_mode & UCSI_CONCAP_OPMODE_UFP)\r\ncap->type = TYPEC_PORT_UFP;\r\ncap->revision = ucsi->cap.typec_version;\r\ncap->pd_revision = ucsi->cap.pd_version;\r\ncap->prefer_role = TYPEC_NO_PREFERRED_ROLE;\r\nif (con->cap.op_mode & UCSI_CONCAP_OPMODE_AUDIO_ACCESSORY)\r\n*accessory++ = TYPEC_ACCESSORY_AUDIO;\r\nif (con->cap.op_mode & UCSI_CONCAP_OPMODE_DEBUG_ACCESSORY)\r\n*accessory = TYPEC_ACCESSORY_DEBUG;\r\ncap->fwnode = ucsi_find_fwnode(con);\r\ncap->dr_set = ucsi_dr_swap;\r\ncap->pr_set = ucsi_pr_swap;\r\ncon->port = typec_register_port(ucsi->dev, cap);\r\nif (!con->port)\r\nreturn -ENODEV;\r\nUCSI_CMD_GET_CONNECTOR_STATUS(ctrl, con->num);\r\nret = ucsi_run_command(ucsi, &ctrl, &con->status, sizeof(con->status));\r\nif (ret < 0) {\r\ndev_err(ucsi->dev, "con%d: failed to get status\n", con->num);\r\nreturn 0;\r\n}\r\nucsi_pwr_opmode_change(con);\r\ntypec_set_pwr_role(con->port, con->status.pwr_dir);\r\nswitch (con->status.partner_type) {\r\ncase UCSI_CONSTAT_PARTNER_TYPE_UFP:\r\ntypec_set_data_role(con->port, TYPEC_HOST);\r\nbreak;\r\ncase UCSI_CONSTAT_PARTNER_TYPE_DFP:\r\ntypec_set_data_role(con->port, TYPEC_DEVICE);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (con->status.connected)\r\nucsi_register_partner(con);\r\ntrace_ucsi_register_port(con->num, &con->status);\r\nreturn 0;\r\n}\r\nstatic void ucsi_init(struct work_struct *work)\r\n{\r\nstruct ucsi *ucsi = container_of(work, struct ucsi, work);\r\nstruct ucsi_connector *con;\r\nstruct ucsi_control ctrl;\r\nint ret;\r\nint i;\r\nmutex_lock(&ucsi->ppm_lock);\r\nret = ucsi_reset_ppm(ucsi);\r\nif (ret) {\r\ndev_err(ucsi->dev, "failed to reset PPM!\n");\r\ngoto err;\r\n}\r\nUCSI_CMD_SET_NTFY_ENABLE(ctrl, UCSI_ENABLE_NTFY_CMD_COMPLETE |\r\nUCSI_ENABLE_NTFY_ERROR);\r\nret = ucsi_run_command(ucsi, &ctrl, NULL, 0);\r\nif (ret < 0)\r\ngoto err_reset;\r\nUCSI_CMD_GET_CAPABILITY(ctrl);\r\nret = ucsi_run_command(ucsi, &ctrl, &ucsi->cap, sizeof(ucsi->cap));\r\nif (ret < 0)\r\ngoto err_reset;\r\nif (!ucsi->cap.num_connectors) {\r\nret = -ENODEV;\r\ngoto err_reset;\r\n}\r\nucsi->connector = kcalloc(ucsi->cap.num_connectors + 1,\r\nsizeof(*ucsi->connector), GFP_KERNEL);\r\nif (!ucsi->connector) {\r\nret = -ENOMEM;\r\ngoto err_reset;\r\n}\r\nfor (i = 0; i < ucsi->cap.num_connectors; i++) {\r\nret = ucsi_register_port(ucsi, i);\r\nif (ret)\r\ngoto err_unregister;\r\n}\r\nUCSI_CMD_SET_NTFY_ENABLE(ctrl, UCSI_ENABLE_NTFY_ALL);\r\nret = ucsi_run_command(ucsi, &ctrl, NULL, 0);\r\nif (ret < 0)\r\ngoto err_unregister;\r\nmutex_unlock(&ucsi->ppm_lock);\r\nreturn;\r\nerr_unregister:\r\nfor (con = ucsi->connector; con->port; con++) {\r\nucsi_unregister_partner(con);\r\ntypec_unregister_port(con->port);\r\ncon->port = NULL;\r\n}\r\nerr_reset:\r\nucsi_reset_ppm(ucsi);\r\nerr:\r\nmutex_unlock(&ucsi->ppm_lock);\r\ndev_err(ucsi->dev, "PPM init failed (%d)\n", ret);\r\n}\r\nstruct ucsi *ucsi_register_ppm(struct device *dev, struct ucsi_ppm *ppm)\r\n{\r\nstruct ucsi *ucsi;\r\nucsi = kzalloc(sizeof(*ucsi), GFP_KERNEL);\r\nif (!ucsi)\r\nreturn ERR_PTR(-ENOMEM);\r\nINIT_WORK(&ucsi->work, ucsi_init);\r\ninit_completion(&ucsi->complete);\r\nmutex_init(&ucsi->ppm_lock);\r\nucsi->dev = dev;\r\nucsi->ppm = ppm;\r\nqueue_work(system_long_wq, &ucsi->work);\r\nreturn ucsi;\r\n}\r\nvoid ucsi_unregister_ppm(struct ucsi *ucsi)\r\n{\r\nstruct ucsi_control ctrl;\r\nint i;\r\ncancel_work_sync(&ucsi->work);\r\nmutex_lock(&ucsi->ppm_lock);\r\nUCSI_CMD_SET_NTFY_ENABLE(ctrl, UCSI_ENABLE_NTFY_CMD_COMPLETE)\r\nucsi_run_command(ucsi, &ctrl, NULL, 0);\r\nmutex_unlock(&ucsi->ppm_lock);\r\nfor (i = 0; i < ucsi->cap.num_connectors; i++) {\r\ncancel_work_sync(&ucsi->connector[i].work);\r\nucsi_unregister_partner(&ucsi->connector[i]);\r\ntypec_unregister_port(ucsi->connector[i].port);\r\n}\r\nucsi_reset_ppm(ucsi);\r\nkfree(ucsi->connector);\r\nkfree(ucsi);\r\n}
