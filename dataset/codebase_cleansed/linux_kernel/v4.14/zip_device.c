static inline u32 zip_cmd_queue_consumed(struct zip_device *zip_dev, int queue)\r\n{\r\nreturn ((zip_dev->iq[queue].sw_head - zip_dev->iq[queue].sw_tail) *\r\nsizeof(u64 *));\r\n}\r\nu32 zip_load_instr(union zip_inst_s *instr,\r\nstruct zip_device *zip_dev)\r\n{\r\nunion zip_quex_doorbell dbell;\r\nu32 queue = 0;\r\nu32 consumed = 0;\r\nu64 *ncb_ptr = NULL;\r\nunion zip_nptr_s ncp;\r\nif (smp_processor_id() % 2 == 0)\r\nqueue = 0;\r\nelse\r\nqueue = 1;\r\nzip_dbg("CPU Core: %d Queue number:%d", smp_processor_id(), queue);\r\nspin_lock(&zip_dev->iq[queue].lock);\r\nzip_dbg("sw_head : %lx", zip_dev->iq[queue].sw_head);\r\nzip_dbg("sw_tail : %lx", zip_dev->iq[queue].sw_tail);\r\nconsumed = zip_cmd_queue_consumed(zip_dev, queue);\r\nif ((consumed + 128) == (ZIP_CMD_QBUF_SIZE - 8)) {\r\nzip_dbg("Cmd queue space available for single command");\r\nmemcpy((u8 *)zip_dev->iq[queue].sw_head, (u8 *)instr,\r\nsizeof(union zip_inst_s));\r\nzip_dev->iq[queue].sw_head += 16;\r\nncb_ptr = zip_dev->iq[queue].sw_head;\r\nzip_dbg("ncb addr :0x%lx sw_head addr :0x%lx",\r\nncb_ptr, zip_dev->iq[queue].sw_head - 16);\r\nzip_dev->iq[queue].sw_head = zip_dev->iq[queue].sw_tail;\r\nzip_dev->iq[queue].free_flag = 1;\r\nncp.u_reg64 = 0ull;\r\nncp.s.addr = __pa(zip_dev->iq[queue].sw_head);\r\n*ncb_ptr = ncp.u_reg64;\r\nzip_dbg("*ncb_ptr :0x%lx sw_head[phys] :0x%lx",\r\n*ncb_ptr, __pa(zip_dev->iq[queue].sw_head));\r\nzip_dev->iq[queue].pend_cnt++;\r\n} else {\r\nzip_dbg("Enough space is available for commands");\r\nmemcpy((u8 *)zip_dev->iq[queue].sw_head, (u8 *)instr,\r\nsizeof(union zip_inst_s));\r\nzip_dev->iq[queue].sw_head += 16;\r\nzip_dev->iq[queue].pend_cnt++;\r\n}\r\nzip_dbg("sw_head :0x%lx sw_tail :0x%lx hw_tail :0x%lx",\r\nzip_dev->iq[queue].sw_head, zip_dev->iq[queue].sw_tail,\r\nzip_dev->iq[queue].hw_tail);\r\nzip_dbg(" Pushed the new cmd : pend_cnt : %d",\r\nzip_dev->iq[queue].pend_cnt);\r\ndbell.u_reg64 = 0ull;\r\ndbell.s.dbell_cnt = 1;\r\nzip_reg_write(dbell.u_reg64,\r\n(zip_dev->reg_base + ZIP_QUEX_DOORBELL(queue)));\r\nspin_unlock(&zip_dev->iq[queue].lock);\r\nreturn queue;\r\n}\r\nvoid zip_update_cmd_bufs(struct zip_device *zip_dev, u32 queue)\r\n{\r\nspin_lock(&zip_dev->iq[queue].lock);\r\nif (zip_dev->iq[queue].free_flag == 1) {\r\nzip_dbg("Free flag. Free cmd buffer, adjust sw head and tail");\r\nzip_dev->iq[queue].free_flag = 0;\r\nzip_dev->iq[queue].hw_tail = zip_dev->iq[queue].sw_head;\r\n} else {\r\nzip_dbg("Free flag not set. increment hw tail");\r\nzip_dev->iq[queue].hw_tail += 16;\r\n}\r\nzip_dev->iq[queue].done_cnt++;\r\nzip_dev->iq[queue].pend_cnt--;\r\nzip_dbg("sw_head :0x%lx sw_tail :0x%lx hw_tail :0x%lx",\r\nzip_dev->iq[queue].sw_head, zip_dev->iq[queue].sw_tail,\r\nzip_dev->iq[queue].hw_tail);\r\nzip_dbg(" Got CC : pend_cnt : %d\n", zip_dev->iq[queue].pend_cnt);\r\nspin_unlock(&zip_dev->iq[queue].lock);\r\n}
