static int uniphier_clk_mux_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct uniphier_clk_mux *mux = to_uniphier_clk_mux(hw);\r\nreturn regmap_write_bits(mux->regmap, mux->reg, mux->masks[index],\r\nmux->vals[index]);\r\n}\r\nstatic u8 uniphier_clk_mux_get_parent(struct clk_hw *hw)\r\n{\r\nstruct uniphier_clk_mux *mux = to_uniphier_clk_mux(hw);\r\nint num_parents = clk_hw_get_num_parents(hw);\r\nint ret;\r\nunsigned int val;\r\nu8 i;\r\nret = regmap_read(mux->regmap, mux->reg, &val);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < num_parents; i++)\r\nif ((mux->masks[i] & val) == mux->vals[i])\r\nreturn i;\r\nreturn -EINVAL;\r\n}\r\nstruct clk_hw *uniphier_clk_register_mux(struct device *dev,\r\nstruct regmap *regmap,\r\nconst char *name,\r\nconst struct uniphier_clk_mux_data *data)\r\n{\r\nstruct uniphier_clk_mux *mux;\r\nstruct clk_init_data init;\r\nint ret;\r\nmux = devm_kzalloc(dev, sizeof(*mux), GFP_KERNEL);\r\nif (!mux)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = name;\r\ninit.ops = &uniphier_clk_mux_ops;\r\ninit.flags = CLK_SET_RATE_PARENT;\r\ninit.parent_names = data->parent_names;\r\ninit.num_parents = data->num_parents,\r\nmux->regmap = regmap;\r\nmux->reg = data->reg;\r\nmux->masks = data->masks;\r\nmux->vals = data->vals;\r\nmux->hw.init = &init;\r\nret = devm_clk_hw_register(dev, &mux->hw);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\nreturn &mux->hw;\r\n}
