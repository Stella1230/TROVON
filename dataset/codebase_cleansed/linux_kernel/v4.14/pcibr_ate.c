static void mark_ate(struct ate_resource *ate_resource, int start, int number,\r\nu64 value)\r\n{\r\nu64 *ate = ate_resource->ate;\r\nint index;\r\nint length = 0;\r\nfor (index = start; length < number; index++, length++)\r\nate[index] = value;\r\n}\r\nstatic int find_free_ate(struct ate_resource *ate_resource, int start,\r\nint count)\r\n{\r\nu64 *ate = ate_resource->ate;\r\nint index;\r\nint start_free;\r\nfor (index = start; index < ate_resource->num_ate;) {\r\nif (!ate[index]) {\r\nint i;\r\nint free;\r\nfree = 0;\r\nstart_free = index;\r\nfor (i = start_free; i < ate_resource->num_ate; i++) {\r\nif (!ate[i]) {\r\nif (++free == count)\r\nreturn start_free;\r\n} else {\r\nindex = i + 1;\r\nbreak;\r\n}\r\n}\r\nif (i >= ate_resource->num_ate)\r\nreturn -1;\r\n} else\r\nindex++;\r\n}\r\nreturn -1;\r\n}\r\nstatic inline void free_ate_resource(struct ate_resource *ate_resource,\r\nint start)\r\n{\r\nmark_ate(ate_resource, start, ate_resource->ate[start], 0);\r\nif ((ate_resource->lowest_free_index > start) ||\r\n(ate_resource->lowest_free_index < 0))\r\nate_resource->lowest_free_index = start;\r\n}\r\nstatic inline int alloc_ate_resource(struct ate_resource *ate_resource,\r\nint ate_needed)\r\n{\r\nint start_index;\r\nif (ate_resource->lowest_free_index < 0)\r\nreturn -1;\r\nstart_index =\r\nfind_free_ate(ate_resource, ate_resource->lowest_free_index,\r\nate_needed);\r\nif (start_index >= 0)\r\nmark_ate(ate_resource, start_index, ate_needed, ate_needed);\r\nate_resource->lowest_free_index =\r\nfind_free_ate(ate_resource, ate_resource->lowest_free_index, 1);\r\nreturn start_index;\r\n}\r\nint pcibr_ate_alloc(struct pcibus_info *pcibus_info, int count)\r\n{\r\nint status;\r\nunsigned long flags;\r\nspin_lock_irqsave(&pcibus_info->pbi_lock, flags);\r\nstatus = alloc_ate_resource(&pcibus_info->pbi_int_ate_resource, count);\r\nspin_unlock_irqrestore(&pcibus_info->pbi_lock, flags);\r\nreturn status;\r\n}\r\nstatic inline u64 __iomem *pcibr_ate_addr(struct pcibus_info *pcibus_info,\r\nint ate_index)\r\n{\r\nif (ate_index < pcibus_info->pbi_int_ate_size) {\r\nreturn pcireg_int_ate_addr(pcibus_info, ate_index);\r\n}\r\npanic("pcibr_ate_addr: invalid ate_index 0x%x", ate_index);\r\n}\r\ninline void\r\nate_write(struct pcibus_info *pcibus_info, int ate_index, int count,\r\nvolatile u64 ate)\r\n{\r\nwhile (count-- > 0) {\r\nif (ate_index < pcibus_info->pbi_int_ate_size) {\r\npcireg_int_ate_set(pcibus_info, ate_index, ate);\r\n} else {\r\npanic("ate_write: invalid ate_index 0x%x", ate_index);\r\n}\r\nate_index++;\r\nate += IOPGSIZE;\r\n}\r\npcireg_tflush_get(pcibus_info);\r\n}\r\nvoid pcibr_ate_free(struct pcibus_info *pcibus_info, int index)\r\n{\r\nvolatile u64 ate;\r\nint count;\r\nunsigned long flags;\r\nif (pcibr_invalidate_ate) {\r\nate = *pcibr_ate_addr(pcibus_info, index);\r\ncount = pcibus_info->pbi_int_ate_resource.ate[index];\r\nate_write(pcibus_info, index, count, (ate & ~PCI32_ATE_V));\r\n}\r\nspin_lock_irqsave(&pcibus_info->pbi_lock, flags);\r\nfree_ate_resource(&pcibus_info->pbi_int_ate_resource, index);\r\nspin_unlock_irqrestore(&pcibus_info->pbi_lock, flags);\r\n}
