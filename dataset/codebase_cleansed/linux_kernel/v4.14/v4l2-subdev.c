static int subdev_fh_init(struct v4l2_subdev_fh *fh, struct v4l2_subdev *sd)\r\n{\r\n#if defined(CONFIG_VIDEO_V4L2_SUBDEV_API)\r\nif (sd->entity.num_pads) {\r\nfh->pad = v4l2_subdev_alloc_pad_config(sd);\r\nif (fh->pad == NULL)\r\nreturn -ENOMEM;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void subdev_fh_free(struct v4l2_subdev_fh *fh)\r\n{\r\n#if defined(CONFIG_VIDEO_V4L2_SUBDEV_API)\r\nv4l2_subdev_free_pad_config(fh->pad);\r\nfh->pad = NULL;\r\n#endif\r\n}\r\nstatic int subdev_open(struct file *file)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct v4l2_subdev *sd = vdev_to_v4l2_subdev(vdev);\r\nstruct v4l2_subdev_fh *subdev_fh;\r\n#if defined(CONFIG_MEDIA_CONTROLLER)\r\nstruct media_entity *entity = NULL;\r\n#endif\r\nint ret;\r\nsubdev_fh = kzalloc(sizeof(*subdev_fh), GFP_KERNEL);\r\nif (subdev_fh == NULL)\r\nreturn -ENOMEM;\r\nret = subdev_fh_init(subdev_fh, sd);\r\nif (ret) {\r\nkfree(subdev_fh);\r\nreturn ret;\r\n}\r\nv4l2_fh_init(&subdev_fh->vfh, vdev);\r\nv4l2_fh_add(&subdev_fh->vfh);\r\nfile->private_data = &subdev_fh->vfh;\r\n#if defined(CONFIG_MEDIA_CONTROLLER)\r\nif (sd->v4l2_dev->mdev) {\r\nentity = media_entity_get(&sd->entity);\r\nif (!entity) {\r\nret = -EBUSY;\r\ngoto err;\r\n}\r\n}\r\n#endif\r\nif (sd->internal_ops && sd->internal_ops->open) {\r\nret = sd->internal_ops->open(sd, subdev_fh);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\n#if defined(CONFIG_MEDIA_CONTROLLER)\r\nmedia_entity_put(entity);\r\n#endif\r\nv4l2_fh_del(&subdev_fh->vfh);\r\nv4l2_fh_exit(&subdev_fh->vfh);\r\nsubdev_fh_free(subdev_fh);\r\nkfree(subdev_fh);\r\nreturn ret;\r\n}\r\nstatic int subdev_close(struct file *file)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct v4l2_subdev *sd = vdev_to_v4l2_subdev(vdev);\r\nstruct v4l2_fh *vfh = file->private_data;\r\nstruct v4l2_subdev_fh *subdev_fh = to_v4l2_subdev_fh(vfh);\r\nif (sd->internal_ops && sd->internal_ops->close)\r\nsd->internal_ops->close(sd, subdev_fh);\r\n#if defined(CONFIG_MEDIA_CONTROLLER)\r\nif (sd->v4l2_dev->mdev)\r\nmedia_entity_put(&sd->entity);\r\n#endif\r\nv4l2_fh_del(vfh);\r\nv4l2_fh_exit(vfh);\r\nsubdev_fh_free(subdev_fh);\r\nkfree(subdev_fh);\r\nfile->private_data = NULL;\r\nreturn 0;\r\n}\r\nstatic int check_format(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_format *format)\r\n{\r\nif (format->which != V4L2_SUBDEV_FORMAT_TRY &&\r\nformat->which != V4L2_SUBDEV_FORMAT_ACTIVE)\r\nreturn -EINVAL;\r\nif (format->pad >= sd->entity.num_pads)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int check_crop(struct v4l2_subdev *sd, struct v4l2_subdev_crop *crop)\r\n{\r\nif (crop->which != V4L2_SUBDEV_FORMAT_TRY &&\r\ncrop->which != V4L2_SUBDEV_FORMAT_ACTIVE)\r\nreturn -EINVAL;\r\nif (crop->pad >= sd->entity.num_pads)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int check_selection(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_selection *sel)\r\n{\r\nif (sel->which != V4L2_SUBDEV_FORMAT_TRY &&\r\nsel->which != V4L2_SUBDEV_FORMAT_ACTIVE)\r\nreturn -EINVAL;\r\nif (sel->pad >= sd->entity.num_pads)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int check_edid(struct v4l2_subdev *sd, struct v4l2_subdev_edid *edid)\r\n{\r\nif (edid->pad >= sd->entity.num_pads)\r\nreturn -EINVAL;\r\nif (edid->blocks && edid->edid == NULL)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic long subdev_do_ioctl(struct file *file, unsigned int cmd, void *arg)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct v4l2_subdev *sd = vdev_to_v4l2_subdev(vdev);\r\nstruct v4l2_fh *vfh = file->private_data;\r\n#if defined(CONFIG_VIDEO_V4L2_SUBDEV_API)\r\nstruct v4l2_subdev_fh *subdev_fh = to_v4l2_subdev_fh(vfh);\r\nint rval;\r\n#endif\r\nswitch (cmd) {\r\ncase VIDIOC_QUERYCTRL:\r\nreturn v4l2_queryctrl(vfh->ctrl_handler, arg);\r\ncase VIDIOC_QUERY_EXT_CTRL:\r\nreturn v4l2_query_ext_ctrl(vfh->ctrl_handler, arg);\r\ncase VIDIOC_QUERYMENU:\r\nreturn v4l2_querymenu(vfh->ctrl_handler, arg);\r\ncase VIDIOC_G_CTRL:\r\nreturn v4l2_g_ctrl(vfh->ctrl_handler, arg);\r\ncase VIDIOC_S_CTRL:\r\nreturn v4l2_s_ctrl(vfh, vfh->ctrl_handler, arg);\r\ncase VIDIOC_G_EXT_CTRLS:\r\nreturn v4l2_g_ext_ctrls(vfh->ctrl_handler, arg);\r\ncase VIDIOC_S_EXT_CTRLS:\r\nreturn v4l2_s_ext_ctrls(vfh, vfh->ctrl_handler, arg);\r\ncase VIDIOC_TRY_EXT_CTRLS:\r\nreturn v4l2_try_ext_ctrls(vfh->ctrl_handler, arg);\r\ncase VIDIOC_DQEVENT:\r\nif (!(sd->flags & V4L2_SUBDEV_FL_HAS_EVENTS))\r\nreturn -ENOIOCTLCMD;\r\nreturn v4l2_event_dequeue(vfh, arg, file->f_flags & O_NONBLOCK);\r\ncase VIDIOC_SUBSCRIBE_EVENT:\r\nreturn v4l2_subdev_call(sd, core, subscribe_event, vfh, arg);\r\ncase VIDIOC_UNSUBSCRIBE_EVENT:\r\nreturn v4l2_subdev_call(sd, core, unsubscribe_event, vfh, arg);\r\n#ifdef CONFIG_VIDEO_ADV_DEBUG\r\ncase VIDIOC_DBG_G_REGISTER:\r\n{\r\nstruct v4l2_dbg_register *p = arg;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nreturn v4l2_subdev_call(sd, core, g_register, p);\r\n}\r\ncase VIDIOC_DBG_S_REGISTER:\r\n{\r\nstruct v4l2_dbg_register *p = arg;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nreturn v4l2_subdev_call(sd, core, s_register, p);\r\n}\r\n#endif\r\ncase VIDIOC_LOG_STATUS: {\r\nint ret;\r\npr_info("%s: ================= START STATUS =================\n",\r\nsd->name);\r\nret = v4l2_subdev_call(sd, core, log_status);\r\npr_info("%s: ================== END STATUS ==================\n",\r\nsd->name);\r\nreturn ret;\r\n}\r\n#if defined(CONFIG_VIDEO_V4L2_SUBDEV_API)\r\ncase VIDIOC_SUBDEV_G_FMT: {\r\nstruct v4l2_subdev_format *format = arg;\r\nrval = check_format(sd, format);\r\nif (rval)\r\nreturn rval;\r\nreturn v4l2_subdev_call(sd, pad, get_fmt, subdev_fh->pad, format);\r\n}\r\ncase VIDIOC_SUBDEV_S_FMT: {\r\nstruct v4l2_subdev_format *format = arg;\r\nrval = check_format(sd, format);\r\nif (rval)\r\nreturn rval;\r\nreturn v4l2_subdev_call(sd, pad, set_fmt, subdev_fh->pad, format);\r\n}\r\ncase VIDIOC_SUBDEV_G_CROP: {\r\nstruct v4l2_subdev_crop *crop = arg;\r\nstruct v4l2_subdev_selection sel;\r\nrval = check_crop(sd, crop);\r\nif (rval)\r\nreturn rval;\r\nmemset(&sel, 0, sizeof(sel));\r\nsel.which = crop->which;\r\nsel.pad = crop->pad;\r\nsel.target = V4L2_SEL_TGT_CROP;\r\nrval = v4l2_subdev_call(\r\nsd, pad, get_selection, subdev_fh->pad, &sel);\r\ncrop->rect = sel.r;\r\nreturn rval;\r\n}\r\ncase VIDIOC_SUBDEV_S_CROP: {\r\nstruct v4l2_subdev_crop *crop = arg;\r\nstruct v4l2_subdev_selection sel;\r\nrval = check_crop(sd, crop);\r\nif (rval)\r\nreturn rval;\r\nmemset(&sel, 0, sizeof(sel));\r\nsel.which = crop->which;\r\nsel.pad = crop->pad;\r\nsel.target = V4L2_SEL_TGT_CROP;\r\nsel.r = crop->rect;\r\nrval = v4l2_subdev_call(\r\nsd, pad, set_selection, subdev_fh->pad, &sel);\r\ncrop->rect = sel.r;\r\nreturn rval;\r\n}\r\ncase VIDIOC_SUBDEV_ENUM_MBUS_CODE: {\r\nstruct v4l2_subdev_mbus_code_enum *code = arg;\r\nif (code->which != V4L2_SUBDEV_FORMAT_TRY &&\r\ncode->which != V4L2_SUBDEV_FORMAT_ACTIVE)\r\nreturn -EINVAL;\r\nif (code->pad >= sd->entity.num_pads)\r\nreturn -EINVAL;\r\nreturn v4l2_subdev_call(sd, pad, enum_mbus_code, subdev_fh->pad,\r\ncode);\r\n}\r\ncase VIDIOC_SUBDEV_ENUM_FRAME_SIZE: {\r\nstruct v4l2_subdev_frame_size_enum *fse = arg;\r\nif (fse->which != V4L2_SUBDEV_FORMAT_TRY &&\r\nfse->which != V4L2_SUBDEV_FORMAT_ACTIVE)\r\nreturn -EINVAL;\r\nif (fse->pad >= sd->entity.num_pads)\r\nreturn -EINVAL;\r\nreturn v4l2_subdev_call(sd, pad, enum_frame_size, subdev_fh->pad,\r\nfse);\r\n}\r\ncase VIDIOC_SUBDEV_G_FRAME_INTERVAL: {\r\nstruct v4l2_subdev_frame_interval *fi = arg;\r\nif (fi->pad >= sd->entity.num_pads)\r\nreturn -EINVAL;\r\nreturn v4l2_subdev_call(sd, video, g_frame_interval, arg);\r\n}\r\ncase VIDIOC_SUBDEV_S_FRAME_INTERVAL: {\r\nstruct v4l2_subdev_frame_interval *fi = arg;\r\nif (fi->pad >= sd->entity.num_pads)\r\nreturn -EINVAL;\r\nreturn v4l2_subdev_call(sd, video, s_frame_interval, arg);\r\n}\r\ncase VIDIOC_SUBDEV_ENUM_FRAME_INTERVAL: {\r\nstruct v4l2_subdev_frame_interval_enum *fie = arg;\r\nif (fie->which != V4L2_SUBDEV_FORMAT_TRY &&\r\nfie->which != V4L2_SUBDEV_FORMAT_ACTIVE)\r\nreturn -EINVAL;\r\nif (fie->pad >= sd->entity.num_pads)\r\nreturn -EINVAL;\r\nreturn v4l2_subdev_call(sd, pad, enum_frame_interval, subdev_fh->pad,\r\nfie);\r\n}\r\ncase VIDIOC_SUBDEV_G_SELECTION: {\r\nstruct v4l2_subdev_selection *sel = arg;\r\nrval = check_selection(sd, sel);\r\nif (rval)\r\nreturn rval;\r\nreturn v4l2_subdev_call(\r\nsd, pad, get_selection, subdev_fh->pad, sel);\r\n}\r\ncase VIDIOC_SUBDEV_S_SELECTION: {\r\nstruct v4l2_subdev_selection *sel = arg;\r\nrval = check_selection(sd, sel);\r\nif (rval)\r\nreturn rval;\r\nreturn v4l2_subdev_call(\r\nsd, pad, set_selection, subdev_fh->pad, sel);\r\n}\r\ncase VIDIOC_G_EDID: {\r\nstruct v4l2_subdev_edid *edid = arg;\r\nrval = check_edid(sd, edid);\r\nif (rval)\r\nreturn rval;\r\nreturn v4l2_subdev_call(sd, pad, get_edid, edid);\r\n}\r\ncase VIDIOC_S_EDID: {\r\nstruct v4l2_subdev_edid *edid = arg;\r\nrval = check_edid(sd, edid);\r\nif (rval)\r\nreturn rval;\r\nreturn v4l2_subdev_call(sd, pad, set_edid, edid);\r\n}\r\ncase VIDIOC_SUBDEV_DV_TIMINGS_CAP: {\r\nstruct v4l2_dv_timings_cap *cap = arg;\r\nif (cap->pad >= sd->entity.num_pads)\r\nreturn -EINVAL;\r\nreturn v4l2_subdev_call(sd, pad, dv_timings_cap, cap);\r\n}\r\ncase VIDIOC_SUBDEV_ENUM_DV_TIMINGS: {\r\nstruct v4l2_enum_dv_timings *dvt = arg;\r\nif (dvt->pad >= sd->entity.num_pads)\r\nreturn -EINVAL;\r\nreturn v4l2_subdev_call(sd, pad, enum_dv_timings, dvt);\r\n}\r\ncase VIDIOC_SUBDEV_QUERY_DV_TIMINGS:\r\nreturn v4l2_subdev_call(sd, video, query_dv_timings, arg);\r\ncase VIDIOC_SUBDEV_G_DV_TIMINGS:\r\nreturn v4l2_subdev_call(sd, video, g_dv_timings, arg);\r\ncase VIDIOC_SUBDEV_S_DV_TIMINGS:\r\nreturn v4l2_subdev_call(sd, video, s_dv_timings, arg);\r\n#endif\r\ndefault:\r\nreturn v4l2_subdev_call(sd, core, ioctl, cmd, arg);\r\n}\r\nreturn 0;\r\n}\r\nstatic long subdev_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nreturn video_usercopy(file, cmd, arg, subdev_do_ioctl);\r\n}\r\nstatic long subdev_compat_ioctl32(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct v4l2_subdev *sd = vdev_to_v4l2_subdev(vdev);\r\nreturn v4l2_subdev_call(sd, core, compat_ioctl32, cmd, arg);\r\n}\r\nstatic unsigned int subdev_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct v4l2_subdev *sd = vdev_to_v4l2_subdev(vdev);\r\nstruct v4l2_fh *fh = file->private_data;\r\nif (!(sd->flags & V4L2_SUBDEV_FL_HAS_EVENTS))\r\nreturn POLLERR;\r\npoll_wait(file, &fh->wait, wait);\r\nif (v4l2_event_pending(fh))\r\nreturn POLLPRI;\r\nreturn 0;\r\n}\r\nint v4l2_subdev_link_validate_default(struct v4l2_subdev *sd,\r\nstruct media_link *link,\r\nstruct v4l2_subdev_format *source_fmt,\r\nstruct v4l2_subdev_format *sink_fmt)\r\n{\r\nif (source_fmt->format.width != sink_fmt->format.width\r\n|| source_fmt->format.height != sink_fmt->format.height\r\n|| source_fmt->format.code != sink_fmt->format.code)\r\nreturn -EPIPE;\r\nif (source_fmt->format.field != sink_fmt->format.field &&\r\nsink_fmt->format.field != V4L2_FIELD_NONE)\r\nreturn -EPIPE;\r\nreturn 0;\r\n}\r\nstatic int\r\nv4l2_subdev_link_validate_get_format(struct media_pad *pad,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nif (is_media_entity_v4l2_subdev(pad->entity)) {\r\nstruct v4l2_subdev *sd =\r\nmedia_entity_to_v4l2_subdev(pad->entity);\r\nfmt->which = V4L2_SUBDEV_FORMAT_ACTIVE;\r\nfmt->pad = pad->index;\r\nreturn v4l2_subdev_call(sd, pad, get_fmt, NULL, fmt);\r\n}\r\nWARN(pad->entity->function != MEDIA_ENT_F_IO_V4L,\r\n"Driver bug! Wrong media entity type 0x%08x, entity %s\n",\r\npad->entity->function, pad->entity->name);\r\nreturn -EINVAL;\r\n}\r\nint v4l2_subdev_link_validate(struct media_link *link)\r\n{\r\nstruct v4l2_subdev *sink;\r\nstruct v4l2_subdev_format sink_fmt, source_fmt;\r\nint rval;\r\nrval = v4l2_subdev_link_validate_get_format(\r\nlink->source, &source_fmt);\r\nif (rval < 0)\r\nreturn 0;\r\nrval = v4l2_subdev_link_validate_get_format(\r\nlink->sink, &sink_fmt);\r\nif (rval < 0)\r\nreturn 0;\r\nsink = media_entity_to_v4l2_subdev(link->sink->entity);\r\nrval = v4l2_subdev_call(sink, pad, link_validate, link,\r\n&source_fmt, &sink_fmt);\r\nif (rval != -ENOIOCTLCMD)\r\nreturn rval;\r\nreturn v4l2_subdev_link_validate_default(\r\nsink, link, &source_fmt, &sink_fmt);\r\n}\r\nstruct v4l2_subdev_pad_config *\r\nv4l2_subdev_alloc_pad_config(struct v4l2_subdev *sd)\r\n{\r\nstruct v4l2_subdev_pad_config *cfg;\r\nint ret;\r\nif (!sd->entity.num_pads)\r\nreturn NULL;\r\ncfg = kvmalloc_array(sd->entity.num_pads, sizeof(*cfg),\r\nGFP_KERNEL | __GFP_ZERO);\r\nif (!cfg)\r\nreturn NULL;\r\nret = v4l2_subdev_call(sd, pad, init_cfg, cfg);\r\nif (ret < 0 && ret != -ENOIOCTLCMD) {\r\nkvfree(cfg);\r\nreturn NULL;\r\n}\r\nreturn cfg;\r\n}\r\nvoid v4l2_subdev_free_pad_config(struct v4l2_subdev_pad_config *cfg)\r\n{\r\nkvfree(cfg);\r\n}\r\nvoid v4l2_subdev_init(struct v4l2_subdev *sd, const struct v4l2_subdev_ops *ops)\r\n{\r\nINIT_LIST_HEAD(&sd->list);\r\nBUG_ON(!ops);\r\nsd->ops = ops;\r\nsd->v4l2_dev = NULL;\r\nsd->flags = 0;\r\nsd->name[0] = '\0';\r\nsd->grp_id = 0;\r\nsd->dev_priv = NULL;\r\nsd->host_priv = NULL;\r\n#if defined(CONFIG_MEDIA_CONTROLLER)\r\nsd->entity.name = sd->name;\r\nsd->entity.obj_type = MEDIA_ENTITY_TYPE_V4L2_SUBDEV;\r\nsd->entity.function = MEDIA_ENT_F_V4L2_SUBDEV_UNKNOWN;\r\n#endif\r\n}\r\nvoid v4l2_subdev_notify_event(struct v4l2_subdev *sd,\r\nconst struct v4l2_event *ev)\r\n{\r\nv4l2_event_queue(sd->devnode, ev);\r\nv4l2_subdev_notify(sd, V4L2_DEVICE_NOTIFY_EVENT, (void *)ev);\r\n}
