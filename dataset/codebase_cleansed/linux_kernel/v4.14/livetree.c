void add_label(struct label **labels, char *label)\r\n{\r\nstruct label *new;\r\nfor_each_label_withdel(*labels, new)\r\nif (streq(new->label, label)) {\r\nnew->deleted = 0;\r\nreturn;\r\n}\r\nnew = xmalloc(sizeof(*new));\r\nmemset(new, 0, sizeof(*new));\r\nnew->label = label;\r\nnew->next = *labels;\r\n*labels = new;\r\n}\r\nvoid delete_labels(struct label **labels)\r\n{\r\nstruct label *label;\r\nfor_each_label(*labels, label)\r\nlabel->deleted = 1;\r\n}\r\nstruct property *build_property(char *name, struct data val)\r\n{\r\nstruct property *new = xmalloc(sizeof(*new));\r\nmemset(new, 0, sizeof(*new));\r\nnew->name = name;\r\nnew->val = val;\r\nreturn new;\r\n}\r\nstruct property *build_property_delete(char *name)\r\n{\r\nstruct property *new = xmalloc(sizeof(*new));\r\nmemset(new, 0, sizeof(*new));\r\nnew->name = name;\r\nnew->deleted = 1;\r\nreturn new;\r\n}\r\nstruct property *chain_property(struct property *first, struct property *list)\r\n{\r\nassert(first->next == NULL);\r\nfirst->next = list;\r\nreturn first;\r\n}\r\nstruct property *reverse_properties(struct property *first)\r\n{\r\nstruct property *p = first;\r\nstruct property *head = NULL;\r\nstruct property *next;\r\nwhile (p) {\r\nnext = p->next;\r\np->next = head;\r\nhead = p;\r\np = next;\r\n}\r\nreturn head;\r\n}\r\nstruct node *build_node(struct property *proplist, struct node *children)\r\n{\r\nstruct node *new = xmalloc(sizeof(*new));\r\nstruct node *child;\r\nmemset(new, 0, sizeof(*new));\r\nnew->proplist = reverse_properties(proplist);\r\nnew->children = children;\r\nfor_each_child(new, child) {\r\nchild->parent = new;\r\n}\r\nreturn new;\r\n}\r\nstruct node *build_node_delete(void)\r\n{\r\nstruct node *new = xmalloc(sizeof(*new));\r\nmemset(new, 0, sizeof(*new));\r\nnew->deleted = 1;\r\nreturn new;\r\n}\r\nstruct node *name_node(struct node *node, char *name)\r\n{\r\nassert(node->name == NULL);\r\nnode->name = name;\r\nreturn node;\r\n}\r\nstruct node *merge_nodes(struct node *old_node, struct node *new_node)\r\n{\r\nstruct property *new_prop, *old_prop;\r\nstruct node *new_child, *old_child;\r\nstruct label *l;\r\nold_node->deleted = 0;\r\nfor_each_label_withdel(new_node->labels, l)\r\nadd_label(&old_node->labels, l->label);\r\nwhile (new_node->proplist) {\r\nnew_prop = new_node->proplist;\r\nnew_node->proplist = new_prop->next;\r\nnew_prop->next = NULL;\r\nif (new_prop->deleted) {\r\ndelete_property_by_name(old_node, new_prop->name);\r\nfree(new_prop);\r\ncontinue;\r\n}\r\nfor_each_property_withdel(old_node, old_prop) {\r\nif (streq(old_prop->name, new_prop->name)) {\r\nfor_each_label_withdel(new_prop->labels, l)\r\nadd_label(&old_prop->labels, l->label);\r\nold_prop->val = new_prop->val;\r\nold_prop->deleted = 0;\r\nfree(new_prop);\r\nnew_prop = NULL;\r\nbreak;\r\n}\r\n}\r\nif (new_prop)\r\nadd_property(old_node, new_prop);\r\n}\r\nwhile (new_node->children) {\r\nnew_child = new_node->children;\r\nnew_node->children = new_child->next_sibling;\r\nnew_child->parent = NULL;\r\nnew_child->next_sibling = NULL;\r\nif (new_child->deleted) {\r\ndelete_node_by_name(old_node, new_child->name);\r\nfree(new_child);\r\ncontinue;\r\n}\r\nfor_each_child_withdel(old_node, old_child) {\r\nif (streq(old_child->name, new_child->name)) {\r\nmerge_nodes(old_child, new_child);\r\nnew_child = NULL;\r\nbreak;\r\n}\r\n}\r\nif (new_child)\r\nadd_child(old_node, new_child);\r\n}\r\nfree(new_node);\r\nreturn old_node;\r\n}\r\nstruct node *chain_node(struct node *first, struct node *list)\r\n{\r\nassert(first->next_sibling == NULL);\r\nfirst->next_sibling = list;\r\nreturn first;\r\n}\r\nvoid add_property(struct node *node, struct property *prop)\r\n{\r\nstruct property **p;\r\nprop->next = NULL;\r\np = &node->proplist;\r\nwhile (*p)\r\np = &((*p)->next);\r\n*p = prop;\r\n}\r\nvoid delete_property_by_name(struct node *node, char *name)\r\n{\r\nstruct property *prop = node->proplist;\r\nwhile (prop) {\r\nif (streq(prop->name, name)) {\r\ndelete_property(prop);\r\nreturn;\r\n}\r\nprop = prop->next;\r\n}\r\n}\r\nvoid delete_property(struct property *prop)\r\n{\r\nprop->deleted = 1;\r\ndelete_labels(&prop->labels);\r\n}\r\nvoid add_child(struct node *parent, struct node *child)\r\n{\r\nstruct node **p;\r\nchild->next_sibling = NULL;\r\nchild->parent = parent;\r\np = &parent->children;\r\nwhile (*p)\r\np = &((*p)->next_sibling);\r\n*p = child;\r\n}\r\nvoid delete_node_by_name(struct node *parent, char *name)\r\n{\r\nstruct node *node = parent->children;\r\nwhile (node) {\r\nif (streq(node->name, name)) {\r\ndelete_node(node);\r\nreturn;\r\n}\r\nnode = node->next_sibling;\r\n}\r\n}\r\nvoid delete_node(struct node *node)\r\n{\r\nstruct property *prop;\r\nstruct node *child;\r\nnode->deleted = 1;\r\nfor_each_child(node, child)\r\ndelete_node(child);\r\nfor_each_property(node, prop)\r\ndelete_property(prop);\r\ndelete_labels(&node->labels);\r\n}\r\nvoid append_to_property(struct node *node,\r\nchar *name, const void *data, int len)\r\n{\r\nstruct data d;\r\nstruct property *p;\r\np = get_property(node, name);\r\nif (p) {\r\nd = data_append_data(p->val, data, len);\r\np->val = d;\r\n} else {\r\nd = data_append_data(empty_data, data, len);\r\np = build_property(name, d);\r\nadd_property(node, p);\r\n}\r\n}\r\nstruct reserve_info *build_reserve_entry(uint64_t address, uint64_t size)\r\n{\r\nstruct reserve_info *new = xmalloc(sizeof(*new));\r\nmemset(new, 0, sizeof(*new));\r\nnew->address = address;\r\nnew->size = size;\r\nreturn new;\r\n}\r\nstruct reserve_info *chain_reserve_entry(struct reserve_info *first,\r\nstruct reserve_info *list)\r\n{\r\nassert(first->next == NULL);\r\nfirst->next = list;\r\nreturn first;\r\n}\r\nstruct reserve_info *add_reserve_entry(struct reserve_info *list,\r\nstruct reserve_info *new)\r\n{\r\nstruct reserve_info *last;\r\nnew->next = NULL;\r\nif (! list)\r\nreturn new;\r\nfor (last = list; last->next; last = last->next)\r\n;\r\nlast->next = new;\r\nreturn list;\r\n}\r\nstruct dt_info *build_dt_info(unsigned int dtsflags,\r\nstruct reserve_info *reservelist,\r\nstruct node *tree, uint32_t boot_cpuid_phys)\r\n{\r\nstruct dt_info *dti;\r\ndti = xmalloc(sizeof(*dti));\r\ndti->dtsflags = dtsflags;\r\ndti->reservelist = reservelist;\r\ndti->dt = tree;\r\ndti->boot_cpuid_phys = boot_cpuid_phys;\r\nreturn dti;\r\n}\r\nconst char *get_unitname(struct node *node)\r\n{\r\nif (node->name[node->basenamelen] == '\0')\r\nreturn "";\r\nelse\r\nreturn node->name + node->basenamelen + 1;\r\n}\r\nstruct property *get_property(struct node *node, const char *propname)\r\n{\r\nstruct property *prop;\r\nfor_each_property(node, prop)\r\nif (streq(prop->name, propname))\r\nreturn prop;\r\nreturn NULL;\r\n}\r\ncell_t propval_cell(struct property *prop)\r\n{\r\nassert(prop->val.len == sizeof(cell_t));\r\nreturn fdt32_to_cpu(*((fdt32_t *)prop->val.val));\r\n}\r\nstruct property *get_property_by_label(struct node *tree, const char *label,\r\nstruct node **node)\r\n{\r\nstruct property *prop;\r\nstruct node *c;\r\n*node = tree;\r\nfor_each_property(tree, prop) {\r\nstruct label *l;\r\nfor_each_label(prop->labels, l)\r\nif (streq(l->label, label))\r\nreturn prop;\r\n}\r\nfor_each_child(tree, c) {\r\nprop = get_property_by_label(c, label, node);\r\nif (prop)\r\nreturn prop;\r\n}\r\n*node = NULL;\r\nreturn NULL;\r\n}\r\nstruct marker *get_marker_label(struct node *tree, const char *label,\r\nstruct node **node, struct property **prop)\r\n{\r\nstruct marker *m;\r\nstruct property *p;\r\nstruct node *c;\r\n*node = tree;\r\nfor_each_property(tree, p) {\r\n*prop = p;\r\nm = p->val.markers;\r\nfor_each_marker_of_type(m, LABEL)\r\nif (streq(m->ref, label))\r\nreturn m;\r\n}\r\nfor_each_child(tree, c) {\r\nm = get_marker_label(c, label, node, prop);\r\nif (m)\r\nreturn m;\r\n}\r\n*prop = NULL;\r\n*node = NULL;\r\nreturn NULL;\r\n}\r\nstruct node *get_subnode(struct node *node, const char *nodename)\r\n{\r\nstruct node *child;\r\nfor_each_child(node, child)\r\nif (streq(child->name, nodename))\r\nreturn child;\r\nreturn NULL;\r\n}\r\nstruct node *get_node_by_path(struct node *tree, const char *path)\r\n{\r\nconst char *p;\r\nstruct node *child;\r\nif (!path || ! (*path)) {\r\nif (tree->deleted)\r\nreturn NULL;\r\nreturn tree;\r\n}\r\nwhile (path[0] == '/')\r\npath++;\r\np = strchr(path, '/');\r\nfor_each_child(tree, child) {\r\nif (p && strneq(path, child->name, p-path))\r\nreturn get_node_by_path(child, p+1);\r\nelse if (!p && streq(path, child->name))\r\nreturn child;\r\n}\r\nreturn NULL;\r\n}\r\nstruct node *get_node_by_label(struct node *tree, const char *label)\r\n{\r\nstruct node *child, *node;\r\nstruct label *l;\r\nassert(label && (strlen(label) > 0));\r\nfor_each_label(tree->labels, l)\r\nif (streq(l->label, label))\r\nreturn tree;\r\nfor_each_child(tree, child) {\r\nnode = get_node_by_label(child, label);\r\nif (node)\r\nreturn node;\r\n}\r\nreturn NULL;\r\n}\r\nstruct node *get_node_by_phandle(struct node *tree, cell_t phandle)\r\n{\r\nstruct node *child, *node;\r\nassert((phandle != 0) && (phandle != -1));\r\nif (tree->phandle == phandle) {\r\nif (tree->deleted)\r\nreturn NULL;\r\nreturn tree;\r\n}\r\nfor_each_child(tree, child) {\r\nnode = get_node_by_phandle(child, phandle);\r\nif (node)\r\nreturn node;\r\n}\r\nreturn NULL;\r\n}\r\nstruct node *get_node_by_ref(struct node *tree, const char *ref)\r\n{\r\nif (streq(ref, "/"))\r\nreturn tree;\r\nelse if (ref[0] == '/')\r\nreturn get_node_by_path(tree, ref);\r\nelse\r\nreturn get_node_by_label(tree, ref);\r\n}\r\ncell_t get_node_phandle(struct node *root, struct node *node)\r\n{\r\nstatic cell_t phandle = 1;\r\nif ((node->phandle != 0) && (node->phandle != -1))\r\nreturn node->phandle;\r\nwhile (get_node_by_phandle(root, phandle))\r\nphandle++;\r\nnode->phandle = phandle;\r\nif (!get_property(node, "linux,phandle")\r\n&& (phandle_format & PHANDLE_LEGACY))\r\nadd_property(node,\r\nbuild_property("linux,phandle",\r\ndata_append_cell(empty_data, phandle)));\r\nif (!get_property(node, "phandle")\r\n&& (phandle_format & PHANDLE_EPAPR))\r\nadd_property(node,\r\nbuild_property("phandle",\r\ndata_append_cell(empty_data, phandle)));\r\nreturn node->phandle;\r\n}\r\nuint32_t guess_boot_cpuid(struct node *tree)\r\n{\r\nstruct node *cpus, *bootcpu;\r\nstruct property *reg;\r\ncpus = get_node_by_path(tree, "/cpus");\r\nif (!cpus)\r\nreturn 0;\r\nbootcpu = cpus->children;\r\nif (!bootcpu)\r\nreturn 0;\r\nreg = get_property(bootcpu, "reg");\r\nif (!reg || (reg->val.len != sizeof(uint32_t)))\r\nreturn 0;\r\nreturn propval_cell(reg);\r\n}\r\nstatic int cmp_reserve_info(const void *ax, const void *bx)\r\n{\r\nconst struct reserve_info *a, *b;\r\na = *((const struct reserve_info * const *)ax);\r\nb = *((const struct reserve_info * const *)bx);\r\nif (a->address < b->address)\r\nreturn -1;\r\nelse if (a->address > b->address)\r\nreturn 1;\r\nelse if (a->size < b->size)\r\nreturn -1;\r\nelse if (a->size > b->size)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic void sort_reserve_entries(struct dt_info *dti)\r\n{\r\nstruct reserve_info *ri, **tbl;\r\nint n = 0, i = 0;\r\nfor (ri = dti->reservelist;\r\nri;\r\nri = ri->next)\r\nn++;\r\nif (n == 0)\r\nreturn;\r\ntbl = xmalloc(n * sizeof(*tbl));\r\nfor (ri = dti->reservelist;\r\nri;\r\nri = ri->next)\r\ntbl[i++] = ri;\r\nqsort(tbl, n, sizeof(*tbl), cmp_reserve_info);\r\ndti->reservelist = tbl[0];\r\nfor (i = 0; i < (n-1); i++)\r\ntbl[i]->next = tbl[i+1];\r\ntbl[n-1]->next = NULL;\r\nfree(tbl);\r\n}\r\nstatic int cmp_prop(const void *ax, const void *bx)\r\n{\r\nconst struct property *a, *b;\r\na = *((const struct property * const *)ax);\r\nb = *((const struct property * const *)bx);\r\nreturn strcmp(a->name, b->name);\r\n}\r\nstatic void sort_properties(struct node *node)\r\n{\r\nint n = 0, i = 0;\r\nstruct property *prop, **tbl;\r\nfor_each_property_withdel(node, prop)\r\nn++;\r\nif (n == 0)\r\nreturn;\r\ntbl = xmalloc(n * sizeof(*tbl));\r\nfor_each_property_withdel(node, prop)\r\ntbl[i++] = prop;\r\nqsort(tbl, n, sizeof(*tbl), cmp_prop);\r\nnode->proplist = tbl[0];\r\nfor (i = 0; i < (n-1); i++)\r\ntbl[i]->next = tbl[i+1];\r\ntbl[n-1]->next = NULL;\r\nfree(tbl);\r\n}\r\nstatic int cmp_subnode(const void *ax, const void *bx)\r\n{\r\nconst struct node *a, *b;\r\na = *((const struct node * const *)ax);\r\nb = *((const struct node * const *)bx);\r\nreturn strcmp(a->name, b->name);\r\n}\r\nstatic void sort_subnodes(struct node *node)\r\n{\r\nint n = 0, i = 0;\r\nstruct node *subnode, **tbl;\r\nfor_each_child_withdel(node, subnode)\r\nn++;\r\nif (n == 0)\r\nreturn;\r\ntbl = xmalloc(n * sizeof(*tbl));\r\nfor_each_child_withdel(node, subnode)\r\ntbl[i++] = subnode;\r\nqsort(tbl, n, sizeof(*tbl), cmp_subnode);\r\nnode->children = tbl[0];\r\nfor (i = 0; i < (n-1); i++)\r\ntbl[i]->next_sibling = tbl[i+1];\r\ntbl[n-1]->next_sibling = NULL;\r\nfree(tbl);\r\n}\r\nstatic void sort_node(struct node *node)\r\n{\r\nstruct node *c;\r\nsort_properties(node);\r\nsort_subnodes(node);\r\nfor_each_child_withdel(node, c)\r\nsort_node(c);\r\n}\r\nvoid sort_tree(struct dt_info *dti)\r\n{\r\nsort_reserve_entries(dti);\r\nsort_node(dti->dt);\r\n}\r\nstatic struct node *build_and_name_child_node(struct node *parent, char *name)\r\n{\r\nstruct node *node;\r\nnode = build_node(NULL, NULL);\r\nname_node(node, xstrdup(name));\r\nadd_child(parent, node);\r\nreturn node;\r\n}\r\nstatic struct node *build_root_node(struct node *dt, char *name)\r\n{\r\nstruct node *an;\r\nan = get_subnode(dt, name);\r\nif (!an)\r\nan = build_and_name_child_node(dt, name);\r\nif (!an)\r\ndie("Could not build root node /%s\n", name);\r\nreturn an;\r\n}\r\nstatic bool any_label_tree(struct dt_info *dti, struct node *node)\r\n{\r\nstruct node *c;\r\nif (node->labels)\r\nreturn true;\r\nfor_each_child(node, c)\r\nif (any_label_tree(dti, c))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void generate_label_tree_internal(struct dt_info *dti,\r\nstruct node *an, struct node *node,\r\nbool allocph)\r\n{\r\nstruct node *dt = dti->dt;\r\nstruct node *c;\r\nstruct property *p;\r\nstruct label *l;\r\nif (node->labels) {\r\nfor_each_label(node->labels, l) {\r\np = get_property(an, l->label);\r\nif (p) {\r\nfprintf(stderr, "WARNING: label %s already"\r\n" exists in /%s", l->label,\r\nan->name);\r\ncontinue;\r\n}\r\np = build_property(l->label,\r\ndata_copy_mem(node->fullpath,\r\nstrlen(node->fullpath) + 1));\r\nadd_property(an, p);\r\n}\r\nif (allocph)\r\n(void)get_node_phandle(dt, node);\r\n}\r\nfor_each_child(node, c)\r\ngenerate_label_tree_internal(dti, an, c, allocph);\r\n}\r\nstatic bool any_fixup_tree(struct dt_info *dti, struct node *node)\r\n{\r\nstruct node *c;\r\nstruct property *prop;\r\nstruct marker *m;\r\nfor_each_property(node, prop) {\r\nm = prop->val.markers;\r\nfor_each_marker_of_type(m, REF_PHANDLE) {\r\nif (!get_node_by_ref(dti->dt, m->ref))\r\nreturn true;\r\n}\r\n}\r\nfor_each_child(node, c) {\r\nif (any_fixup_tree(dti, c))\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void add_fixup_entry(struct dt_info *dti, struct node *fn,\r\nstruct node *node, struct property *prop,\r\nstruct marker *m)\r\n{\r\nchar *entry;\r\nassert(m->type == REF_PHANDLE);\r\nif (strchr(node->fullpath, ':') || strchr(prop->name, ':'))\r\ndie("arguments should not contain ':'\n");\r\nxasprintf(&entry, "%s:%s:%u",\r\nnode->fullpath, prop->name, m->offset);\r\nappend_to_property(fn, m->ref, entry, strlen(entry) + 1);\r\nfree(entry);\r\n}\r\nstatic void generate_fixups_tree_internal(struct dt_info *dti,\r\nstruct node *fn,\r\nstruct node *node)\r\n{\r\nstruct node *dt = dti->dt;\r\nstruct node *c;\r\nstruct property *prop;\r\nstruct marker *m;\r\nstruct node *refnode;\r\nfor_each_property(node, prop) {\r\nm = prop->val.markers;\r\nfor_each_marker_of_type(m, REF_PHANDLE) {\r\nrefnode = get_node_by_ref(dt, m->ref);\r\nif (!refnode)\r\nadd_fixup_entry(dti, fn, node, prop, m);\r\n}\r\n}\r\nfor_each_child(node, c)\r\ngenerate_fixups_tree_internal(dti, fn, c);\r\n}\r\nstatic bool any_local_fixup_tree(struct dt_info *dti, struct node *node)\r\n{\r\nstruct node *c;\r\nstruct property *prop;\r\nstruct marker *m;\r\nfor_each_property(node, prop) {\r\nm = prop->val.markers;\r\nfor_each_marker_of_type(m, REF_PHANDLE) {\r\nif (get_node_by_ref(dti->dt, m->ref))\r\nreturn true;\r\n}\r\n}\r\nfor_each_child(node, c) {\r\nif (any_local_fixup_tree(dti, c))\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void add_local_fixup_entry(struct dt_info *dti,\r\nstruct node *lfn, struct node *node,\r\nstruct property *prop, struct marker *m,\r\nstruct node *refnode)\r\n{\r\nstruct node *wn, *nwn;\r\nfdt32_t value_32;\r\nchar **compp;\r\nint i, depth;\r\ndepth = 0;\r\nfor (wn = node; wn; wn = wn->parent)\r\ndepth++;\r\ncompp = xmalloc(sizeof(*compp) * depth);\r\nfor (wn = node, i = depth - 1; wn; wn = wn->parent, i--)\r\ncompp[i] = wn->name;\r\nfor (wn = lfn, i = 1; i < depth; i++, wn = nwn) {\r\nnwn = get_subnode(wn, compp[i]);\r\nif (!nwn)\r\nnwn = build_and_name_child_node(wn, compp[i]);\r\n}\r\nfree(compp);\r\nvalue_32 = cpu_to_fdt32(m->offset);\r\nappend_to_property(wn, prop->name, &value_32, sizeof(value_32));\r\n}\r\nstatic void generate_local_fixups_tree_internal(struct dt_info *dti,\r\nstruct node *lfn,\r\nstruct node *node)\r\n{\r\nstruct node *dt = dti->dt;\r\nstruct node *c;\r\nstruct property *prop;\r\nstruct marker *m;\r\nstruct node *refnode;\r\nfor_each_property(node, prop) {\r\nm = prop->val.markers;\r\nfor_each_marker_of_type(m, REF_PHANDLE) {\r\nrefnode = get_node_by_ref(dt, m->ref);\r\nif (refnode)\r\nadd_local_fixup_entry(dti, lfn, node, prop, m, refnode);\r\n}\r\n}\r\nfor_each_child(node, c)\r\ngenerate_local_fixups_tree_internal(dti, lfn, c);\r\n}\r\nvoid generate_label_tree(struct dt_info *dti, char *name, bool allocph)\r\n{\r\nif (!any_label_tree(dti, dti->dt))\r\nreturn;\r\ngenerate_label_tree_internal(dti, build_root_node(dti->dt, name),\r\ndti->dt, allocph);\r\n}\r\nvoid generate_fixups_tree(struct dt_info *dti, char *name)\r\n{\r\nif (!any_fixup_tree(dti, dti->dt))\r\nreturn;\r\ngenerate_fixups_tree_internal(dti, build_root_node(dti->dt, name),\r\ndti->dt);\r\n}\r\nvoid generate_local_fixups_tree(struct dt_info *dti, char *name)\r\n{\r\nif (!any_local_fixup_tree(dti, dti->dt))\r\nreturn;\r\ngenerate_local_fixups_tree_internal(dti, build_root_node(dti->dt, name),\r\ndti->dt);\r\n}
