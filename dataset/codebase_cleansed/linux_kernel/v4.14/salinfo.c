static long\r\nsalinfo_platform_oemdata_cpu(void *context)\r\n{\r\nstruct salinfo_platform_oemdata_parms *parms = context;\r\nreturn salinfo_platform_oemdata(parms->efi_guid, parms->oemdata, parms->oemdata_size);\r\n}\r\nstatic void\r\nshift1_data_saved (struct salinfo_data *data, int shift)\r\n{\r\nmemcpy(data->data_saved+shift, data->data_saved+shift+1,\r\n(ARRAY_SIZE(data->data_saved) - (shift+1)) * sizeof(data->data_saved[0]));\r\nmemset(data->data_saved + ARRAY_SIZE(data->data_saved) - 1, 0,\r\nsizeof(data->data_saved[0]));\r\n}\r\nvoid\r\nsalinfo_log_wakeup(int type, u8 *buffer, u64 size, int irqsafe)\r\n{\r\nstruct salinfo_data *data = salinfo_data + type;\r\nstruct salinfo_data_saved *data_saved;\r\nunsigned long flags = 0;\r\nint i;\r\nint saved_size = ARRAY_SIZE(data->data_saved);\r\nBUG_ON(type >= ARRAY_SIZE(salinfo_log_name));\r\nif (irqsafe)\r\nspin_lock_irqsave(&data_saved_lock, flags);\r\nif (buffer) {\r\nfor (i = 0, data_saved = data->data_saved; i < saved_size; ++i, ++data_saved) {\r\nif (!data_saved->buffer)\r\nbreak;\r\n}\r\nif (i == saved_size) {\r\nif (!data->saved_num) {\r\nshift1_data_saved(data, 0);\r\ndata_saved = data->data_saved + saved_size - 1;\r\n} else\r\ndata_saved = NULL;\r\n}\r\nif (data_saved) {\r\ndata_saved->cpu = smp_processor_id();\r\ndata_saved->id = ((sal_log_record_header_t *)buffer)->id;\r\ndata_saved->size = size;\r\ndata_saved->buffer = buffer;\r\n}\r\n}\r\ncpumask_set_cpu(smp_processor_id(), &data->cpu_event);\r\nif (irqsafe) {\r\nwake_up_interruptible(&data->read_wait);\r\nspin_unlock_irqrestore(&data_saved_lock, flags);\r\n}\r\n}\r\nstatic void\r\nsalinfo_timeout_check(struct salinfo_data *data)\r\n{\r\nif (!data->open)\r\nreturn;\r\nif (!cpumask_empty(&data->cpu_event))\r\nwake_up_interruptible(&data->read_wait);\r\n}\r\nstatic void\r\nsalinfo_timeout (unsigned long arg)\r\n{\r\nia64_mlogbuf_dump();\r\nsalinfo_timeout_check(salinfo_data + SAL_INFO_TYPE_MCA);\r\nsalinfo_timeout_check(salinfo_data + SAL_INFO_TYPE_INIT);\r\nsalinfo_timer.expires = jiffies + SALINFO_TIMER_DELAY;\r\nadd_timer(&salinfo_timer);\r\n}\r\nstatic int\r\nsalinfo_event_open(struct inode *inode, struct file *file)\r\n{\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nsalinfo_event_read(struct file *file, char __user *buffer, size_t count, loff_t *ppos)\r\n{\r\nstruct salinfo_data *data = PDE_DATA(file_inode(file));\r\nchar cmd[32];\r\nsize_t size;\r\nint i, n, cpu = -1;\r\nretry:\r\nif (cpumask_empty(&data->cpu_event)) {\r\nif (file->f_flags & O_NONBLOCK)\r\nreturn -EAGAIN;\r\nif (wait_event_interruptible(data->read_wait,\r\n!cpumask_empty(&data->cpu_event)))\r\nreturn -EINTR;\r\n}\r\nn = data->cpu_check;\r\nfor (i = 0; i < nr_cpu_ids; i++) {\r\nif (cpumask_test_cpu(n, &data->cpu_event)) {\r\nif (!cpu_online(n)) {\r\ncpumask_clear_cpu(n, &data->cpu_event);\r\ncontinue;\r\n}\r\ncpu = n;\r\nbreak;\r\n}\r\nif (++n == nr_cpu_ids)\r\nn = 0;\r\n}\r\nif (cpu == -1)\r\ngoto retry;\r\nia64_mlogbuf_dump();\r\ndata->cpu_check = cpu;\r\nif (++data->cpu_check == nr_cpu_ids)\r\ndata->cpu_check = 0;\r\nsnprintf(cmd, sizeof(cmd), "read %d\n", cpu);\r\nsize = strlen(cmd);\r\nif (size > count)\r\nsize = count;\r\nif (copy_to_user(buffer, cmd, size))\r\nreturn -EFAULT;\r\nreturn size;\r\n}\r\nstatic int\r\nsalinfo_log_open(struct inode *inode, struct file *file)\r\n{\r\nstruct salinfo_data *data = PDE_DATA(inode);\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nspin_lock(&data_lock);\r\nif (data->open) {\r\nspin_unlock(&data_lock);\r\nreturn -EBUSY;\r\n}\r\ndata->open = 1;\r\nspin_unlock(&data_lock);\r\nif (data->state == STATE_NO_DATA &&\r\n!(data->log_buffer = vmalloc(ia64_sal_get_state_info_size(data->type)))) {\r\ndata->open = 0;\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nsalinfo_log_release(struct inode *inode, struct file *file)\r\n{\r\nstruct salinfo_data *data = PDE_DATA(inode);\r\nif (data->state == STATE_NO_DATA) {\r\nvfree(data->log_buffer);\r\nvfree(data->oemdata);\r\ndata->log_buffer = NULL;\r\ndata->oemdata = NULL;\r\n}\r\nspin_lock(&data_lock);\r\ndata->open = 0;\r\nspin_unlock(&data_lock);\r\nreturn 0;\r\n}\r\nstatic long\r\nsalinfo_log_read_cpu(void *context)\r\n{\r\nstruct salinfo_data *data = context;\r\nsal_log_record_header_t *rh;\r\ndata->log_size = ia64_sal_get_state_info(data->type, (u64 *) data->log_buffer);\r\nrh = (sal_log_record_header_t *)(data->log_buffer);\r\nif (rh->severity == sal_log_severity_corrected)\r\nia64_sal_clear_state_info(data->type);\r\nreturn 0;\r\n}\r\nstatic void\r\nsalinfo_log_new_read(int cpu, struct salinfo_data *data)\r\n{\r\nstruct salinfo_data_saved *data_saved;\r\nunsigned long flags;\r\nint i;\r\nint saved_size = ARRAY_SIZE(data->data_saved);\r\ndata->saved_num = 0;\r\nspin_lock_irqsave(&data_saved_lock, flags);\r\nretry:\r\nfor (i = 0, data_saved = data->data_saved; i < saved_size; ++i, ++data_saved) {\r\nif (data_saved->buffer && data_saved->cpu == cpu) {\r\nsal_log_record_header_t *rh = (sal_log_record_header_t *)(data_saved->buffer);\r\ndata->log_size = data_saved->size;\r\nmemcpy(data->log_buffer, rh, data->log_size);\r\nbarrier();\r\nif (rh->id == data_saved->id) {\r\ndata->saved_num = i+1;\r\nbreak;\r\n}\r\nshift1_data_saved(data, i);\r\ngoto retry;\r\n}\r\n}\r\nspin_unlock_irqrestore(&data_saved_lock, flags);\r\nif (!data->saved_num)\r\nwork_on_cpu_safe(cpu, salinfo_log_read_cpu, data);\r\nif (!data->log_size) {\r\ndata->state = STATE_NO_DATA;\r\ncpumask_clear_cpu(cpu, &data->cpu_event);\r\n} else {\r\ndata->state = STATE_LOG_RECORD;\r\n}\r\n}\r\nstatic ssize_t\r\nsalinfo_log_read(struct file *file, char __user *buffer, size_t count, loff_t *ppos)\r\n{\r\nstruct salinfo_data *data = PDE_DATA(file_inode(file));\r\nu8 *buf;\r\nu64 bufsize;\r\nif (data->state == STATE_LOG_RECORD) {\r\nbuf = data->log_buffer;\r\nbufsize = data->log_size;\r\n} else if (data->state == STATE_OEMDATA) {\r\nbuf = data->oemdata;\r\nbufsize = data->oemdata_size;\r\n} else {\r\nbuf = NULL;\r\nbufsize = 0;\r\n}\r\nreturn simple_read_from_buffer(buffer, count, ppos, buf, bufsize);\r\n}\r\nstatic long\r\nsalinfo_log_clear_cpu(void *context)\r\n{\r\nstruct salinfo_data *data = context;\r\nia64_sal_clear_state_info(data->type);\r\nreturn 0;\r\n}\r\nstatic int\r\nsalinfo_log_clear(struct salinfo_data *data, int cpu)\r\n{\r\nsal_log_record_header_t *rh;\r\nunsigned long flags;\r\nspin_lock_irqsave(&data_saved_lock, flags);\r\ndata->state = STATE_NO_DATA;\r\nif (!cpumask_test_cpu(cpu, &data->cpu_event)) {\r\nspin_unlock_irqrestore(&data_saved_lock, flags);\r\nreturn 0;\r\n}\r\ncpumask_clear_cpu(cpu, &data->cpu_event);\r\nif (data->saved_num) {\r\nshift1_data_saved(data, data->saved_num - 1);\r\ndata->saved_num = 0;\r\n}\r\nspin_unlock_irqrestore(&data_saved_lock, flags);\r\nrh = (sal_log_record_header_t *)(data->log_buffer);\r\nif (rh->severity != sal_log_severity_corrected)\r\nwork_on_cpu_safe(cpu, salinfo_log_clear_cpu, data);\r\nsalinfo_log_new_read(cpu, data);\r\nif (data->state == STATE_LOG_RECORD) {\r\nspin_lock_irqsave(&data_saved_lock, flags);\r\ncpumask_set_cpu(cpu, &data->cpu_event);\r\nwake_up_interruptible(&data->read_wait);\r\nspin_unlock_irqrestore(&data_saved_lock, flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nsalinfo_log_write(struct file *file, const char __user *buffer, size_t count, loff_t *ppos)\r\n{\r\nstruct salinfo_data *data = PDE_DATA(file_inode(file));\r\nchar cmd[32];\r\nsize_t size;\r\nu32 offset;\r\nint cpu;\r\nsize = sizeof(cmd);\r\nif (count < size)\r\nsize = count;\r\nif (copy_from_user(cmd, buffer, size))\r\nreturn -EFAULT;\r\nif (sscanf(cmd, "read %d", &cpu) == 1) {\r\nsalinfo_log_new_read(cpu, data);\r\n} else if (sscanf(cmd, "clear %d", &cpu) == 1) {\r\nint ret;\r\nif ((ret = salinfo_log_clear(data, cpu)))\r\ncount = ret;\r\n} else if (sscanf(cmd, "oemdata %d %d", &cpu, &offset) == 2) {\r\nif (data->state != STATE_LOG_RECORD && data->state != STATE_OEMDATA)\r\nreturn -EINVAL;\r\nif (offset > data->log_size - sizeof(efi_guid_t))\r\nreturn -EINVAL;\r\ndata->state = STATE_OEMDATA;\r\nif (salinfo_platform_oemdata) {\r\nstruct salinfo_platform_oemdata_parms parms = {\r\n.efi_guid = data->log_buffer + offset,\r\n.oemdata = &data->oemdata,\r\n.oemdata_size = &data->oemdata_size\r\n};\r\ncount = work_on_cpu_safe(cpu, salinfo_platform_oemdata_cpu,\r\n&parms);\r\n} else\r\ndata->oemdata_size = 0;\r\n} else\r\nreturn -EINVAL;\r\nreturn count;\r\n}\r\nstatic int salinfo_cpu_online(unsigned int cpu)\r\n{\r\nunsigned int i, end = ARRAY_SIZE(salinfo_data);\r\nstruct salinfo_data *data;\r\nspin_lock_irq(&data_saved_lock);\r\nfor (i = 0, data = salinfo_data; i < end; ++i, ++data) {\r\ncpumask_set_cpu(cpu, &data->cpu_event);\r\nwake_up_interruptible(&data->read_wait);\r\n}\r\nspin_unlock_irq(&data_saved_lock);\r\nreturn 0;\r\n}\r\nstatic int salinfo_cpu_pre_down(unsigned int cpu)\r\n{\r\nunsigned int i, end = ARRAY_SIZE(salinfo_data);\r\nstruct salinfo_data *data;\r\nspin_lock_irq(&data_saved_lock);\r\nfor (i = 0, data = salinfo_data; i < end; ++i, ++data) {\r\nstruct salinfo_data_saved *data_saved;\r\nint j = ARRAY_SIZE(data->data_saved) - 1;\r\nfor (data_saved = data->data_saved + j; j >= 0;\r\n--j, --data_saved) {\r\nif (data_saved->buffer && data_saved->cpu == cpu)\r\nshift1_data_saved(data, j);\r\n}\r\ncpumask_clear_cpu(cpu, &data->cpu_event);\r\n}\r\nspin_unlock_irq(&data_saved_lock);\r\nreturn 0;\r\n}\r\nstatic int __init\r\nsalinfo_init(void)\r\n{\r\nstruct proc_dir_entry *salinfo_dir;\r\nstruct proc_dir_entry **sdir = salinfo_proc_entries;\r\nstruct proc_dir_entry *dir, *entry;\r\nstruct salinfo_data *data;\r\nint i;\r\nsalinfo_dir = proc_mkdir("sal", NULL);\r\nif (!salinfo_dir)\r\nreturn 0;\r\nfor (i=0; i < NR_SALINFO_ENTRIES; i++) {\r\n*sdir++ = proc_create_data(salinfo_entries[i].name, 0, salinfo_dir,\r\n&proc_salinfo_fops,\r\n(void *)salinfo_entries[i].feature);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(salinfo_log_name); i++) {\r\ndata = salinfo_data + i;\r\ndata->type = i;\r\ninit_waitqueue_head(&data->read_wait);\r\ndir = proc_mkdir(salinfo_log_name[i], salinfo_dir);\r\nif (!dir)\r\ncontinue;\r\nentry = proc_create_data("event", S_IRUSR, dir,\r\n&salinfo_event_fops, data);\r\nif (!entry)\r\ncontinue;\r\n*sdir++ = entry;\r\nentry = proc_create_data("data", S_IRUSR | S_IWUSR, dir,\r\n&salinfo_data_fops, data);\r\nif (!entry)\r\ncontinue;\r\n*sdir++ = entry;\r\n*sdir++ = dir;\r\n}\r\n*sdir++ = salinfo_dir;\r\ninit_timer(&salinfo_timer);\r\nsalinfo_timer.expires = jiffies + SALINFO_TIMER_DELAY;\r\nsalinfo_timer.function = &salinfo_timeout;\r\nadd_timer(&salinfo_timer);\r\ni = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, "ia64/salinfo:online",\r\nsalinfo_cpu_online, salinfo_cpu_pre_down);\r\nWARN_ON(i < 0);\r\nreturn 0;\r\n}\r\nstatic int proc_salinfo_show(struct seq_file *m, void *v)\r\n{\r\nunsigned long data = (unsigned long)v;\r\nseq_puts(m, (sal_platform_features & data) ? "1\n" : "0\n");\r\nreturn 0;\r\n}\r\nstatic int proc_salinfo_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, proc_salinfo_show, PDE_DATA(inode));\r\n}
