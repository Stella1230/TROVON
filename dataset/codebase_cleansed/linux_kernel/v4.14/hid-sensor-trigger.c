static ssize_t _hid_sensor_set_report_latency(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct hid_sensor_common *attrb = iio_device_get_drvdata(indio_dev);\r\nint integer, fract, ret;\r\nint latency;\r\nret = iio_str_to_fixpoint(buf, 100000, &integer, &fract);\r\nif (ret)\r\nreturn ret;\r\nlatency = integer * 1000 + fract / 1000;\r\nret = hid_sensor_set_report_latency(attrb, latency);\r\nif (ret < 0)\r\nreturn len;\r\nattrb->latency_ms = hid_sensor_get_report_latency(attrb);\r\nreturn len;\r\n}\r\nstatic ssize_t _hid_sensor_get_report_latency(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct hid_sensor_common *attrb = iio_device_get_drvdata(indio_dev);\r\nint latency;\r\nlatency = hid_sensor_get_report_latency(attrb);\r\nif (latency < 0)\r\nreturn latency;\r\nreturn sprintf(buf, "%d.%06u\n", latency / 1000, (latency % 1000) * 1000);\r\n}\r\nstatic ssize_t _hid_sensor_get_fifo_state(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct hid_sensor_common *attrb = iio_device_get_drvdata(indio_dev);\r\nint latency;\r\nlatency = hid_sensor_get_report_latency(attrb);\r\nif (latency < 0)\r\nreturn latency;\r\nreturn sprintf(buf, "%d\n", !!latency);\r\n}\r\nstatic void hid_sensor_setup_batch_mode(struct iio_dev *indio_dev,\r\nstruct hid_sensor_common *st)\r\n{\r\nif (!hid_sensor_batch_mode_supported(st))\r\nreturn;\r\niio_buffer_set_attrs(indio_dev->buffer, hid_sensor_fifo_attributes);\r\n}\r\nstatic int _hid_sensor_power_state(struct hid_sensor_common *st, bool state)\r\n{\r\nint state_val;\r\nint report_val;\r\ns32 poll_value = 0;\r\nif (state) {\r\nif (sensor_hub_device_open(st->hsdev))\r\nreturn -EIO;\r\natomic_inc(&st->data_ready);\r\nstate_val = hid_sensor_get_usage_index(st->hsdev,\r\nst->power_state.report_id,\r\nst->power_state.index,\r\nHID_USAGE_SENSOR_PROP_POWER_STATE_D0_FULL_POWER_ENUM);\r\nreport_val = hid_sensor_get_usage_index(st->hsdev,\r\nst->report_state.report_id,\r\nst->report_state.index,\r\nHID_USAGE_SENSOR_PROP_REPORTING_STATE_ALL_EVENTS_ENUM);\r\npoll_value = hid_sensor_read_poll_value(st);\r\n} else {\r\nint val;\r\nval = atomic_dec_if_positive(&st->data_ready);\r\nif (val < 0)\r\nreturn 0;\r\nsensor_hub_device_close(st->hsdev);\r\nstate_val = hid_sensor_get_usage_index(st->hsdev,\r\nst->power_state.report_id,\r\nst->power_state.index,\r\nHID_USAGE_SENSOR_PROP_POWER_STATE_D4_POWER_OFF_ENUM);\r\nreport_val = hid_sensor_get_usage_index(st->hsdev,\r\nst->report_state.report_id,\r\nst->report_state.index,\r\nHID_USAGE_SENSOR_PROP_REPORTING_STATE_NO_EVENTS_ENUM);\r\n}\r\nif (state_val >= 0) {\r\nstate_val += st->power_state.logical_minimum;\r\nsensor_hub_set_feature(st->hsdev, st->power_state.report_id,\r\nst->power_state.index, sizeof(state_val),\r\n&state_val);\r\n}\r\nif (report_val >= 0) {\r\nreport_val += st->report_state.logical_minimum;\r\nsensor_hub_set_feature(st->hsdev, st->report_state.report_id,\r\nst->report_state.index,\r\nsizeof(report_val),\r\n&report_val);\r\n}\r\npr_debug("HID_SENSOR %s set power_state %d report_state %d\n",\r\nst->pdev->name, state_val, report_val);\r\nsensor_hub_get_feature(st->hsdev, st->power_state.report_id,\r\nst->power_state.index,\r\nsizeof(state_val), &state_val);\r\nif (state && poll_value)\r\nmsleep_interruptible(poll_value * 2);\r\nreturn 0;\r\n}\r\nint hid_sensor_power_state(struct hid_sensor_common *st, bool state)\r\n{\r\n#ifdef CONFIG_PM\r\nint ret;\r\natomic_set(&st->user_requested_state, state);\r\nif (state)\r\nret = pm_runtime_get_sync(&st->pdev->dev);\r\nelse {\r\npm_runtime_mark_last_busy(&st->pdev->dev);\r\npm_runtime_use_autosuspend(&st->pdev->dev);\r\nret = pm_runtime_put_autosuspend(&st->pdev->dev);\r\n}\r\nif (ret < 0) {\r\nif (state)\r\npm_runtime_put_noidle(&st->pdev->dev);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n#else\r\natomic_set(&st->user_requested_state, state);\r\nreturn _hid_sensor_power_state(st, state);\r\n#endif\r\n}\r\nstatic void hid_sensor_set_power_work(struct work_struct *work)\r\n{\r\nstruct hid_sensor_common *attrb = container_of(work,\r\nstruct hid_sensor_common,\r\nwork);\r\nif (attrb->poll_interval >= 0)\r\nsensor_hub_set_feature(attrb->hsdev, attrb->poll.report_id,\r\nattrb->poll.index,\r\nsizeof(attrb->poll_interval),\r\n&attrb->poll_interval);\r\nif (attrb->raw_hystersis >= 0)\r\nsensor_hub_set_feature(attrb->hsdev,\r\nattrb->sensitivity.report_id,\r\nattrb->sensitivity.index,\r\nsizeof(attrb->raw_hystersis),\r\n&attrb->raw_hystersis);\r\nif (attrb->latency_ms > 0)\r\nhid_sensor_set_report_latency(attrb, attrb->latency_ms);\r\n_hid_sensor_power_state(attrb, true);\r\n}\r\nstatic int hid_sensor_data_rdy_trigger_set_state(struct iio_trigger *trig,\r\nbool state)\r\n{\r\nreturn hid_sensor_power_state(iio_trigger_get_drvdata(trig), state);\r\n}\r\nvoid hid_sensor_remove_trigger(struct hid_sensor_common *attrb)\r\n{\r\npm_runtime_disable(&attrb->pdev->dev);\r\npm_runtime_set_suspended(&attrb->pdev->dev);\r\npm_runtime_put_noidle(&attrb->pdev->dev);\r\ncancel_work_sync(&attrb->work);\r\niio_trigger_unregister(attrb->trigger);\r\niio_trigger_free(attrb->trigger);\r\n}\r\nint hid_sensor_setup_trigger(struct iio_dev *indio_dev, const char *name,\r\nstruct hid_sensor_common *attrb)\r\n{\r\nint ret;\r\nstruct iio_trigger *trig;\r\ntrig = iio_trigger_alloc("%s-dev%d", name, indio_dev->id);\r\nif (trig == NULL) {\r\ndev_err(&indio_dev->dev, "Trigger Allocate Failed\n");\r\nret = -ENOMEM;\r\ngoto error_ret;\r\n}\r\ntrig->dev.parent = indio_dev->dev.parent;\r\niio_trigger_set_drvdata(trig, attrb);\r\ntrig->ops = &hid_sensor_trigger_ops;\r\nret = iio_trigger_register(trig);\r\nif (ret) {\r\ndev_err(&indio_dev->dev, "Trigger Register Failed\n");\r\ngoto error_free_trig;\r\n}\r\nattrb->trigger = trig;\r\nindio_dev->trig = iio_trigger_get(trig);\r\nhid_sensor_setup_batch_mode(indio_dev, attrb);\r\nret = pm_runtime_set_active(&indio_dev->dev);\r\nif (ret)\r\ngoto error_unreg_trigger;\r\niio_device_set_drvdata(indio_dev, attrb);\r\nINIT_WORK(&attrb->work, hid_sensor_set_power_work);\r\npm_suspend_ignore_children(&attrb->pdev->dev, true);\r\npm_runtime_enable(&attrb->pdev->dev);\r\npm_runtime_set_autosuspend_delay(&attrb->pdev->dev,\r\n3000);\r\nreturn ret;\r\nerror_unreg_trigger:\r\niio_trigger_unregister(trig);\r\nerror_free_trig:\r\niio_trigger_free(trig);\r\nerror_ret:\r\nreturn ret;\r\n}\r\nstatic int __maybe_unused hid_sensor_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\r\nstruct hid_sensor_common *attrb = iio_device_get_drvdata(indio_dev);\r\nreturn _hid_sensor_power_state(attrb, false);\r\n}\r\nstatic int __maybe_unused hid_sensor_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\r\nstruct hid_sensor_common *attrb = iio_device_get_drvdata(indio_dev);\r\nschedule_work(&attrb->work);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused hid_sensor_runtime_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\r\nstruct hid_sensor_common *attrb = iio_device_get_drvdata(indio_dev);\r\nreturn _hid_sensor_power_state(attrb, true);\r\n}
