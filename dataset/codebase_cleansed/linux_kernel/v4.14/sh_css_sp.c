void\r\nstore_sp_group_data(void)\r\n{\r\nper_frame_data.sp_group_addr = sh_css_store_sp_group_to_ddr();\r\n}\r\nstatic void\r\ncopy_isp_stage_to_sp_stage(void)\r\n{\r\nsh_css_sp_stage.num_stripes = (uint8_t) sh_css_isp_stage.binary_info.iterator.num_stripes;\r\nsh_css_sp_stage.row_stripes_height = (uint16_t) sh_css_isp_stage.binary_info.iterator.row_stripes_height;\r\nsh_css_sp_stage.row_stripes_overlap_lines = (uint16_t) sh_css_isp_stage.binary_info.iterator.row_stripes_overlap_lines;\r\nsh_css_sp_stage.top_cropping = (uint16_t) sh_css_isp_stage.binary_info.pipeline.top_cropping;\r\nsh_css_sp_stage.enable.sdis = sh_css_isp_stage.binary_info.enable.dis;\r\nsh_css_sp_stage.enable.s3a = sh_css_isp_stage.binary_info.enable.s3a;\r\n#ifdef ISP2401\r\nsh_css_sp_stage.enable.lace_stats = sh_css_isp_stage.binary_info.enable.lace_stats;\r\n#endif\r\n}\r\nvoid\r\nstore_sp_stage_data(enum ia_css_pipe_id id, unsigned int pipe_num, unsigned stage)\r\n{\r\nunsigned int thread_id;\r\nia_css_pipeline_get_sp_thread_id(pipe_num, &thread_id);\r\ncopy_isp_stage_to_sp_stage();\r\nif (id != IA_CSS_PIPE_ID_COPY)\r\nsh_css_sp_stage.isp_stage_addr =\r\nsh_css_store_isp_stage_to_ddr(pipe_num, stage);\r\nsh_css_sp_group.pipe[thread_id].sp_stage_addr[stage] =\r\nsh_css_store_sp_stage_to_ddr(pipe_num, stage);\r\nsh_css_sp_stage.program_input_circuit = false;\r\n}\r\nstatic void\r\nstore_sp_per_frame_data(const struct ia_css_fw_info *fw)\r\n{\r\nunsigned int HIVE_ADDR_sp_per_frame_data = 0;\r\nassert(fw != NULL);\r\nswitch (fw->type) {\r\ncase ia_css_sp_firmware:\r\nHIVE_ADDR_sp_per_frame_data = fw->info.sp.per_frame_data;\r\nbreak;\r\ncase ia_css_acc_firmware:\r\nHIVE_ADDR_sp_per_frame_data = fw->info.acc.per_frame_data;\r\nbreak;\r\ncase ia_css_isp_firmware:\r\nreturn;\r\n}\r\nsp_dmem_store(SP0_ID,\r\n(unsigned int)sp_address_of(sp_per_frame_data),\r\n&per_frame_data,\r\nsizeof(per_frame_data));\r\n}\r\nstatic void\r\nsh_css_store_sp_per_frame_data(enum ia_css_pipe_id pipe_id,\r\nunsigned int pipe_num,\r\nconst struct ia_css_fw_info *sp_fw)\r\n{\r\nif (!sp_fw)\r\nsp_fw = &sh_css_sp_fw;\r\nstore_sp_stage_data(pipe_id, pipe_num, 0);\r\nstore_sp_group_data();\r\nstore_sp_per_frame_data(sp_fw);\r\n}\r\nvoid\r\nsh_css_sp_get_debug_state(struct sh_css_sp_debug_state *state)\r\n{\r\nconst struct ia_css_fw_info *fw = &sh_css_sp_fw;\r\nunsigned int HIVE_ADDR_sp_output = fw->info.sp.output;\r\nunsigned i;\r\nunsigned offset = (unsigned int)offsetof(struct sh_css_sp_output, debug)/sizeof(int);\r\nassert(state != NULL);\r\n(void)HIVE_ADDR_sp_output;\r\nfor (i = 0; i < sizeof(*state)/sizeof(int); i++)\r\n((unsigned *)state)[i] = load_sp_array_uint(sp_output, i+offset);\r\n}\r\nvoid\r\nsh_css_sp_start_binary_copy(unsigned int pipe_num, struct ia_css_frame *out_frame,\r\nunsigned two_ppc)\r\n{\r\nenum ia_css_pipe_id pipe_id;\r\nunsigned int thread_id;\r\nstruct sh_css_sp_pipeline *pipe;\r\nuint8_t stage_num = 0;\r\nassert(out_frame != NULL);\r\npipe_id = IA_CSS_PIPE_ID_CAPTURE;\r\nia_css_pipeline_get_sp_thread_id(pipe_num, &thread_id);\r\npipe = &sh_css_sp_group.pipe[thread_id];\r\npipe->copy.bin.bytes_available = out_frame->data_bytes;\r\npipe->num_stages = 1;\r\npipe->pipe_id = pipe_id;\r\npipe->pipe_num = pipe_num;\r\npipe->thread_id = thread_id;\r\npipe->pipe_config = 0x0;\r\npipe->pipe_qos_config = QOS_INVALID;\r\nif (pipe->inout_port_config == 0) {\r\nSH_CSS_PIPE_PORT_CONFIG_SET(pipe->inout_port_config,\r\n(uint8_t)SH_CSS_PORT_INPUT,\r\n(uint8_t)SH_CSS_HOST_TYPE, 1);\r\nSH_CSS_PIPE_PORT_CONFIG_SET(pipe->inout_port_config,\r\n(uint8_t)SH_CSS_PORT_OUTPUT,\r\n(uint8_t)SH_CSS_HOST_TYPE, 1);\r\n}\r\nIA_CSS_LOG("pipe_id %d port_config %08x",\r\npipe->pipe_id, pipe->inout_port_config);\r\n#if !defined(HAS_NO_INPUT_FORMATTER)\r\nsh_css_sp_group.config.input_formatter.isp_2ppc = (uint8_t)two_ppc;\r\n#else\r\n(void)two_ppc;\r\n#endif\r\nsh_css_sp_stage.num = stage_num;\r\nsh_css_sp_stage.stage_type = SH_CSS_SP_STAGE_TYPE;\r\nsh_css_sp_stage.func =\r\n(unsigned int)IA_CSS_PIPELINE_BIN_COPY;\r\nset_output_frame_buffer(out_frame, 0);\r\nsh_css_store_sp_per_frame_data(pipe_id, pipe_num, &sh_css_sp_fw);\r\n}\r\nstatic void\r\nsh_css_sp_start_raw_copy(struct ia_css_frame *out_frame,\r\nunsigned pipe_num,\r\nunsigned two_ppc,\r\nunsigned max_input_width,\r\nenum sh_css_pipe_config_override pipe_conf_override,\r\nunsigned int if_config_index)\r\n{\r\nenum ia_css_pipe_id pipe_id;\r\nunsigned int thread_id;\r\nuint8_t stage_num = 0;\r\nstruct sh_css_sp_pipeline *pipe;\r\nassert(out_frame != NULL);\r\n{\r\nuint8_t program_input_circuit;\r\nprogram_input_circuit = sh_css_sp_stage.program_input_circuit;\r\nmemset(&sh_css_sp_stage, 0, sizeof(sh_css_sp_stage));\r\nsh_css_sp_stage.program_input_circuit = program_input_circuit;\r\n}\r\npipe_id = IA_CSS_PIPE_ID_COPY;\r\nia_css_pipeline_get_sp_thread_id(pipe_num, &thread_id);\r\npipe = &sh_css_sp_group.pipe[thread_id];\r\npipe->copy.raw.height = out_frame->info.res.height;\r\npipe->copy.raw.width = out_frame->info.res.width;\r\npipe->copy.raw.padded_width = out_frame->info.padded_width;\r\npipe->copy.raw.raw_bit_depth = out_frame->info.raw_bit_depth;\r\npipe->copy.raw.max_input_width = max_input_width;\r\npipe->num_stages = 1;\r\npipe->pipe_id = pipe_id;\r\nif (pipe_conf_override == SH_CSS_PIPE_CONFIG_OVRD_NO_OVRD)\r\npipe->pipe_config =\r\n(SH_CSS_PIPE_CONFIG_SAMPLE_PARAMS << thread_id);\r\nelse\r\npipe->pipe_config = pipe_conf_override;\r\npipe->pipe_qos_config = QOS_INVALID;\r\nif (pipe->inout_port_config == 0) {\r\nSH_CSS_PIPE_PORT_CONFIG_SET(pipe->inout_port_config,\r\n(uint8_t)SH_CSS_PORT_INPUT,\r\n(uint8_t)SH_CSS_HOST_TYPE, 1);\r\nSH_CSS_PIPE_PORT_CONFIG_SET(pipe->inout_port_config,\r\n(uint8_t)SH_CSS_PORT_OUTPUT,\r\n(uint8_t)SH_CSS_HOST_TYPE, 1);\r\n}\r\nIA_CSS_LOG("pipe_id %d port_config %08x",\r\npipe->pipe_id, pipe->inout_port_config);\r\n#if !defined(HAS_NO_INPUT_FORMATTER)\r\nsh_css_sp_group.config.input_formatter.isp_2ppc = (uint8_t)two_ppc;\r\n#else\r\n(void)two_ppc;\r\n#endif\r\nsh_css_sp_stage.num = stage_num;\r\nsh_css_sp_stage.xmem_bin_addr = 0x0;\r\nsh_css_sp_stage.stage_type = SH_CSS_SP_STAGE_TYPE;\r\nsh_css_sp_stage.func = (unsigned int)IA_CSS_PIPELINE_RAW_COPY;\r\nsh_css_sp_stage.if_config_index = (uint8_t) if_config_index;\r\nset_output_frame_buffer(out_frame, 0);\r\nia_css_debug_pipe_graph_dump_sp_raw_copy(out_frame);\r\n}\r\nstatic void\r\nsh_css_sp_start_isys_copy(struct ia_css_frame *out_frame,\r\nunsigned pipe_num, unsigned max_input_width, unsigned int if_config_index)\r\n{\r\nenum ia_css_pipe_id pipe_id;\r\nunsigned int thread_id;\r\nuint8_t stage_num = 0;\r\nstruct sh_css_sp_pipeline *pipe;\r\n#if defined SH_CSS_ENABLE_METADATA\r\nenum sh_css_queue_id queue_id;\r\n#endif\r\nassert(out_frame != NULL);\r\n{\r\nuint8_t program_input_circuit;\r\nprogram_input_circuit = sh_css_sp_stage.program_input_circuit;\r\nmemset(&sh_css_sp_stage, 0, sizeof(sh_css_sp_stage));\r\nsh_css_sp_stage.program_input_circuit = program_input_circuit;\r\n}\r\npipe_id = IA_CSS_PIPE_ID_COPY;\r\nia_css_pipeline_get_sp_thread_id(pipe_num, &thread_id);\r\npipe = &sh_css_sp_group.pipe[thread_id];\r\npipe->copy.raw.height = out_frame->info.res.height;\r\npipe->copy.raw.width = out_frame->info.res.width;\r\npipe->copy.raw.padded_width = out_frame->info.padded_width;\r\npipe->copy.raw.raw_bit_depth = out_frame->info.raw_bit_depth;\r\npipe->copy.raw.max_input_width = max_input_width;\r\npipe->num_stages = 1;\r\npipe->pipe_id = pipe_id;\r\npipe->pipe_config = 0x0;\r\npipe->pipe_qos_config = QOS_INVALID;\r\ninitialize_stage_frames(&sh_css_sp_stage.frames);\r\nsh_css_sp_stage.num = stage_num;\r\nsh_css_sp_stage.xmem_bin_addr = 0x0;\r\nsh_css_sp_stage.stage_type = SH_CSS_SP_STAGE_TYPE;\r\nsh_css_sp_stage.func = (unsigned int)IA_CSS_PIPELINE_ISYS_COPY;\r\nsh_css_sp_stage.if_config_index = (uint8_t) if_config_index;\r\nset_output_frame_buffer(out_frame, 0);\r\n#if defined SH_CSS_ENABLE_METADATA\r\nif (pipe->metadata.height > 0) {\r\nia_css_query_internal_queue_id(IA_CSS_BUFFER_TYPE_METADATA, thread_id, &queue_id);\r\nsh_css_copy_buffer_attr_to_spbuffer(&sh_css_sp_stage.frames.metadata_buf, queue_id, mmgr_EXCEPTION, IA_CSS_BUFFER_TYPE_METADATA);\r\n}\r\n#endif\r\nia_css_debug_pipe_graph_dump_sp_raw_copy(out_frame);\r\n}\r\nunsigned int\r\nsh_css_sp_get_binary_copy_size(void)\r\n{\r\nconst struct ia_css_fw_info *fw = &sh_css_sp_fw;\r\nunsigned int HIVE_ADDR_sp_output = fw->info.sp.output;\r\nunsigned int offset = (unsigned int)offsetof(struct sh_css_sp_output,\r\nbin_copy_bytes_copied) / sizeof(int);\r\n(void)HIVE_ADDR_sp_output;\r\nreturn load_sp_array_uint(sp_output, offset);\r\n}\r\nunsigned int\r\nsh_css_sp_get_sw_interrupt_value(unsigned int irq)\r\n{\r\nconst struct ia_css_fw_info *fw = &sh_css_sp_fw;\r\nunsigned int HIVE_ADDR_sp_output = fw->info.sp.output;\r\nunsigned int offset = (unsigned int)offsetof(struct sh_css_sp_output, sw_interrupt_value)\r\n/ sizeof(int);\r\n(void)HIVE_ADDR_sp_output;\r\nreturn load_sp_array_uint(sp_output, offset+irq);\r\n}\r\nstatic void\r\nsh_css_copy_buffer_attr_to_spbuffer(struct ia_css_buffer_sp *dest_buf,\r\nconst enum sh_css_queue_id queue_id,\r\nconst hrt_vaddress xmem_addr,\r\nconst enum ia_css_buffer_type buf_type)\r\n{\r\nassert(buf_type < IA_CSS_NUM_BUFFER_TYPE);\r\nif (queue_id > SH_CSS_INVALID_QUEUE_ID) {\r\nassert(queue_id < SH_CSS_MAX_NUM_QUEUES);\r\nif ((queue_id < SH_CSS_MAX_NUM_QUEUES))\r\n{\r\ndest_buf->buf_src.queue_id = queue_id;\r\n}\r\n} else {\r\nassert(xmem_addr != mmgr_EXCEPTION);\r\ndest_buf->buf_src.xmem_addr = xmem_addr;\r\n}\r\ndest_buf->buf_type = buf_type;\r\n}\r\nstatic void\r\nsh_css_copy_frame_to_spframe(struct ia_css_frame_sp *sp_frame_out,\r\nconst struct ia_css_frame *frame_in)\r\n{\r\nassert(frame_in != NULL);\r\nia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,\r\n"sh_css_copy_frame_to_spframe():\n");\r\nsh_css_copy_buffer_attr_to_spbuffer(&sp_frame_out->buf_attr,\r\nframe_in->dynamic_queue_id,\r\nframe_in->data,\r\nframe_in->buf_type);\r\nia_css_frame_info_to_frame_sp_info(&sp_frame_out->info, &frame_in->info);\r\nswitch (frame_in->info.format) {\r\ncase IA_CSS_FRAME_FORMAT_RAW_PACKED:\r\ncase IA_CSS_FRAME_FORMAT_RAW:\r\nsp_frame_out->planes.raw.offset = frame_in->planes.raw.offset;\r\nbreak;\r\ncase IA_CSS_FRAME_FORMAT_RGB565:\r\ncase IA_CSS_FRAME_FORMAT_RGBA888:\r\nsp_frame_out->planes.rgb.offset = frame_in->planes.rgb.offset;\r\nbreak;\r\ncase IA_CSS_FRAME_FORMAT_PLANAR_RGB888:\r\nsp_frame_out->planes.planar_rgb.r.offset =\r\nframe_in->planes.planar_rgb.r.offset;\r\nsp_frame_out->planes.planar_rgb.g.offset =\r\nframe_in->planes.planar_rgb.g.offset;\r\nsp_frame_out->planes.planar_rgb.b.offset =\r\nframe_in->planes.planar_rgb.b.offset;\r\nbreak;\r\ncase IA_CSS_FRAME_FORMAT_YUYV:\r\ncase IA_CSS_FRAME_FORMAT_UYVY:\r\ncase IA_CSS_FRAME_FORMAT_CSI_MIPI_YUV420_8:\r\ncase IA_CSS_FRAME_FORMAT_CSI_MIPI_LEGACY_YUV420_8:\r\ncase IA_CSS_FRAME_FORMAT_YUV_LINE:\r\nsp_frame_out->planes.yuyv.offset = frame_in->planes.yuyv.offset;\r\nbreak;\r\ncase IA_CSS_FRAME_FORMAT_NV11:\r\ncase IA_CSS_FRAME_FORMAT_NV12:\r\ncase IA_CSS_FRAME_FORMAT_NV12_16:\r\ncase IA_CSS_FRAME_FORMAT_NV12_TILEY:\r\ncase IA_CSS_FRAME_FORMAT_NV21:\r\ncase IA_CSS_FRAME_FORMAT_NV16:\r\ncase IA_CSS_FRAME_FORMAT_NV61:\r\nsp_frame_out->planes.nv.y.offset =\r\nframe_in->planes.nv.y.offset;\r\nsp_frame_out->planes.nv.uv.offset =\r\nframe_in->planes.nv.uv.offset;\r\nbreak;\r\ncase IA_CSS_FRAME_FORMAT_YUV420:\r\ncase IA_CSS_FRAME_FORMAT_YUV422:\r\ncase IA_CSS_FRAME_FORMAT_YUV444:\r\ncase IA_CSS_FRAME_FORMAT_YUV420_16:\r\ncase IA_CSS_FRAME_FORMAT_YUV422_16:\r\ncase IA_CSS_FRAME_FORMAT_YV12:\r\ncase IA_CSS_FRAME_FORMAT_YV16:\r\nsp_frame_out->planes.yuv.y.offset =\r\nframe_in->planes.yuv.y.offset;\r\nsp_frame_out->planes.yuv.u.offset =\r\nframe_in->planes.yuv.u.offset;\r\nsp_frame_out->planes.yuv.v.offset =\r\nframe_in->planes.yuv.v.offset;\r\nbreak;\r\ncase IA_CSS_FRAME_FORMAT_QPLANE6:\r\nsp_frame_out->planes.plane6.r.offset =\r\nframe_in->planes.plane6.r.offset;\r\nsp_frame_out->planes.plane6.r_at_b.offset =\r\nframe_in->planes.plane6.r_at_b.offset;\r\nsp_frame_out->planes.plane6.gr.offset =\r\nframe_in->planes.plane6.gr.offset;\r\nsp_frame_out->planes.plane6.gb.offset =\r\nframe_in->planes.plane6.gb.offset;\r\nsp_frame_out->planes.plane6.b.offset =\r\nframe_in->planes.plane6.b.offset;\r\nsp_frame_out->planes.plane6.b_at_r.offset =\r\nframe_in->planes.plane6.b_at_r.offset;\r\nbreak;\r\ncase IA_CSS_FRAME_FORMAT_BINARY_8:\r\nsp_frame_out->planes.binary.data.offset =\r\nframe_in->planes.binary.data.offset;\r\nbreak;\r\ndefault:\r\nmemset(&sp_frame_out->planes, 0, sizeof(sp_frame_out->planes));\r\nbreak;\r\n}\r\n}\r\nstatic enum ia_css_err\r\nset_input_frame_buffer(const struct ia_css_frame *frame)\r\n{\r\nif (frame == NULL)\r\nreturn IA_CSS_ERR_INVALID_ARGUMENTS;\r\nswitch (frame->info.format) {\r\ncase IA_CSS_FRAME_FORMAT_QPLANE6:\r\ncase IA_CSS_FRAME_FORMAT_YUV420_16:\r\ncase IA_CSS_FRAME_FORMAT_RAW_PACKED:\r\ncase IA_CSS_FRAME_FORMAT_RAW:\r\ncase IA_CSS_FRAME_FORMAT_YUV420:\r\ncase IA_CSS_FRAME_FORMAT_YUYV:\r\ncase IA_CSS_FRAME_FORMAT_YUV_LINE:\r\ncase IA_CSS_FRAME_FORMAT_NV12:\r\ncase IA_CSS_FRAME_FORMAT_NV12_16:\r\ncase IA_CSS_FRAME_FORMAT_NV12_TILEY:\r\ncase IA_CSS_FRAME_FORMAT_NV21:\r\ncase IA_CSS_FRAME_FORMAT_CSI_MIPI_YUV420_8:\r\ncase IA_CSS_FRAME_FORMAT_CSI_MIPI_LEGACY_YUV420_8:\r\ncase IA_CSS_FRAME_FORMAT_CSI_MIPI_YUV420_10:\r\nbreak;\r\ndefault:\r\nreturn IA_CSS_ERR_INVALID_ARGUMENTS;\r\n}\r\nsh_css_copy_frame_to_spframe(&sh_css_sp_stage.frames.in, frame);\r\nreturn IA_CSS_SUCCESS;\r\n}\r\nstatic enum ia_css_err\r\nset_output_frame_buffer(const struct ia_css_frame *frame,\r\nunsigned idx)\r\n{\r\nif (frame == NULL)\r\nreturn IA_CSS_ERR_INVALID_ARGUMENTS;\r\nswitch (frame->info.format) {\r\ncase IA_CSS_FRAME_FORMAT_YUV420:\r\ncase IA_CSS_FRAME_FORMAT_YUV422:\r\ncase IA_CSS_FRAME_FORMAT_YUV444:\r\ncase IA_CSS_FRAME_FORMAT_YV12:\r\ncase IA_CSS_FRAME_FORMAT_YV16:\r\ncase IA_CSS_FRAME_FORMAT_YUV420_16:\r\ncase IA_CSS_FRAME_FORMAT_YUV422_16:\r\ncase IA_CSS_FRAME_FORMAT_NV11:\r\ncase IA_CSS_FRAME_FORMAT_NV12:\r\ncase IA_CSS_FRAME_FORMAT_NV12_16:\r\ncase IA_CSS_FRAME_FORMAT_NV12_TILEY:\r\ncase IA_CSS_FRAME_FORMAT_NV16:\r\ncase IA_CSS_FRAME_FORMAT_NV21:\r\ncase IA_CSS_FRAME_FORMAT_NV61:\r\ncase IA_CSS_FRAME_FORMAT_YUYV:\r\ncase IA_CSS_FRAME_FORMAT_UYVY:\r\ncase IA_CSS_FRAME_FORMAT_CSI_MIPI_YUV420_8:\r\ncase IA_CSS_FRAME_FORMAT_CSI_MIPI_LEGACY_YUV420_8:\r\ncase IA_CSS_FRAME_FORMAT_YUV_LINE:\r\ncase IA_CSS_FRAME_FORMAT_RGB565:\r\ncase IA_CSS_FRAME_FORMAT_RGBA888:\r\ncase IA_CSS_FRAME_FORMAT_PLANAR_RGB888:\r\ncase IA_CSS_FRAME_FORMAT_RAW:\r\ncase IA_CSS_FRAME_FORMAT_RAW_PACKED:\r\ncase IA_CSS_FRAME_FORMAT_QPLANE6:\r\ncase IA_CSS_FRAME_FORMAT_BINARY_8:\r\nbreak;\r\ndefault:\r\nreturn IA_CSS_ERR_INVALID_ARGUMENTS;\r\n}\r\nsh_css_copy_frame_to_spframe(&sh_css_sp_stage.frames.out[idx], frame);\r\nreturn IA_CSS_SUCCESS;\r\n}\r\nstatic enum ia_css_err\r\nset_view_finder_buffer(const struct ia_css_frame *frame)\r\n{\r\nif (frame == NULL)\r\nreturn IA_CSS_ERR_INVALID_ARGUMENTS;\r\nswitch (frame->info.format) {\r\ncase IA_CSS_FRAME_FORMAT_NV12:\r\ncase IA_CSS_FRAME_FORMAT_NV12_16:\r\ncase IA_CSS_FRAME_FORMAT_NV21:\r\ncase IA_CSS_FRAME_FORMAT_YUYV:\r\ncase IA_CSS_FRAME_FORMAT_UYVY:\r\ncase IA_CSS_FRAME_FORMAT_CSI_MIPI_YUV420_8:\r\ncase IA_CSS_FRAME_FORMAT_CSI_MIPI_LEGACY_YUV420_8:\r\ncase IA_CSS_FRAME_FORMAT_YUV420:\r\ncase IA_CSS_FRAME_FORMAT_YV12:\r\ncase IA_CSS_FRAME_FORMAT_NV12_TILEY:\r\ncase IA_CSS_FRAME_FORMAT_YUV_LINE:\r\nbreak;\r\ndefault:\r\nreturn IA_CSS_ERR_INVALID_ARGUMENTS;\r\n}\r\nsh_css_copy_frame_to_spframe(&sh_css_sp_stage.frames.out_vf, frame);\r\nreturn IA_CSS_SUCCESS;\r\n}\r\nvoid sh_css_sp_set_if_configs(\r\nconst input_formatter_cfg_t *config_a,\r\nconst input_formatter_cfg_t *config_b,\r\nconst uint8_t if_config_index\r\n)\r\n{\r\nassert(if_config_index < SH_CSS_MAX_IF_CONFIGS);\r\nassert(config_a != NULL);\r\nsh_css_sp_group.config.input_formatter.set[if_config_index].config_a = *config_a;\r\nsh_css_sp_group.config.input_formatter.a_changed = true;\r\nif (config_b != NULL) {\r\nsh_css_sp_group.config.input_formatter.set[if_config_index].config_b = *config_b;\r\nsh_css_sp_group.config.input_formatter.b_changed = true;\r\n}\r\nreturn;\r\n}\r\nvoid\r\nsh_css_sp_program_input_circuit(int fmt_type,\r\nint ch_id,\r\nenum ia_css_input_mode input_mode)\r\n{\r\nsh_css_sp_group.config.input_circuit.no_side_band = false;\r\nsh_css_sp_group.config.input_circuit.fmt_type = fmt_type;\r\nsh_css_sp_group.config.input_circuit.ch_id = ch_id;\r\nsh_css_sp_group.config.input_circuit.input_mode = input_mode;\r\nsh_css_sp_group.config.input_circuit_cfg_changed = true;\r\nsh_css_sp_stage.program_input_circuit = true;\r\n}\r\nvoid\r\nsh_css_sp_configure_sync_gen(int width, int height,\r\nint hblank_cycles,\r\nint vblank_cycles)\r\n{\r\nsh_css_sp_group.config.sync_gen.width = width;\r\nsh_css_sp_group.config.sync_gen.height = height;\r\nsh_css_sp_group.config.sync_gen.hblank_cycles = hblank_cycles;\r\nsh_css_sp_group.config.sync_gen.vblank_cycles = vblank_cycles;\r\n}\r\nvoid\r\nsh_css_sp_configure_tpg(int x_mask,\r\nint y_mask,\r\nint x_delta,\r\nint y_delta,\r\nint xy_mask)\r\n{\r\nsh_css_sp_group.config.tpg.x_mask = x_mask;\r\nsh_css_sp_group.config.tpg.y_mask = y_mask;\r\nsh_css_sp_group.config.tpg.x_delta = x_delta;\r\nsh_css_sp_group.config.tpg.y_delta = y_delta;\r\nsh_css_sp_group.config.tpg.xy_mask = xy_mask;\r\n}\r\nvoid\r\nsh_css_sp_configure_prbs(int seed)\r\n{\r\nsh_css_sp_group.config.prbs.seed = seed;\r\n}\r\nvoid\r\nsh_css_sp_configure_enable_raw_pool_locking(bool lock_all)\r\n{\r\nsh_css_sp_group.config.enable_raw_pool_locking = true;\r\nsh_css_sp_group.config.lock_all = lock_all;\r\n}\r\nvoid\r\nsh_css_sp_enable_isys_event_queue(bool enable)\r\n{\r\n#if !defined(HAS_NO_INPUT_SYSTEM)\r\nsh_css_sp_group.config.enable_isys_event_queue = enable;\r\n#else\r\n(void)enable;\r\n#endif\r\n}\r\nvoid\r\nsh_css_sp_set_disable_continuous_viewfinder(bool flag)\r\n{\r\nsh_css_sp_group.config.disable_cont_vf = flag;\r\n}\r\nstatic enum ia_css_err\r\nsh_css_sp_write_frame_pointers(const struct sh_css_binary_args *args)\r\n{\r\nenum ia_css_err err = IA_CSS_SUCCESS;\r\nint i;\r\nassert(args != NULL);\r\nif (args->in_frame)\r\nerr = set_input_frame_buffer(args->in_frame);\r\nif (err == IA_CSS_SUCCESS && args->out_vf_frame)\r\nerr = set_view_finder_buffer(args->out_vf_frame);\r\nfor (i = 0; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++) {\r\nif (err == IA_CSS_SUCCESS && args->out_frame[i])\r\nerr = set_output_frame_buffer(args->out_frame[i], i);\r\n}\r\nif (err != IA_CSS_SUCCESS) assert(false);\r\nreturn err;\r\n}\r\nstatic void\r\nsh_css_sp_init_group(bool two_ppc,\r\nenum ia_css_stream_format input_format,\r\nbool no_isp_sync,\r\nuint8_t if_config_index)\r\n{\r\n#if !defined(HAS_NO_INPUT_FORMATTER)\r\nsh_css_sp_group.config.input_formatter.isp_2ppc = two_ppc;\r\n#else\r\n(void)two_ppc;\r\n#endif\r\nsh_css_sp_group.config.no_isp_sync = (uint8_t)no_isp_sync;\r\nif (if_config_index == SH_CSS_IF_CONFIG_NOT_NEEDED) return;\r\n#if !defined(HAS_NO_INPUT_FORMATTER)\r\nassert(if_config_index < SH_CSS_MAX_IF_CONFIGS);\r\nsh_css_sp_group.config.input_formatter.set[if_config_index].stream_format = input_format;\r\n#else\r\n(void)input_format;\r\n#endif\r\n}\r\nvoid\r\nsh_css_stage_write_binary_info(struct ia_css_binary_info *info)\r\n{\r\nassert(info != NULL);\r\nsh_css_isp_stage.binary_info = *info;\r\n}\r\nstatic enum ia_css_err\r\ncopy_isp_mem_if_to_ddr(struct ia_css_binary *binary)\r\n{\r\nenum ia_css_err err;\r\nerr = ia_css_isp_param_copy_isp_mem_if_to_ddr(\r\n&binary->css_params,\r\n&binary->mem_params,\r\nIA_CSS_PARAM_CLASS_CONFIG);\r\nif (err != IA_CSS_SUCCESS)\r\nreturn err;\r\nerr = ia_css_isp_param_copy_isp_mem_if_to_ddr(\r\n&binary->css_params,\r\n&binary->mem_params,\r\nIA_CSS_PARAM_CLASS_STATE);\r\nif (err != IA_CSS_SUCCESS)\r\nreturn err;\r\nreturn IA_CSS_SUCCESS;\r\n}\r\nstatic bool\r\nis_sp_stage(struct ia_css_pipeline_stage *stage)\r\n{\r\nassert(stage != NULL);\r\nreturn stage->sp_func != IA_CSS_PIPELINE_NO_FUNC;\r\n}\r\nstatic enum ia_css_err\r\nconfigure_isp_from_args(\r\nconst struct sh_css_sp_pipeline *pipeline,\r\nconst struct ia_css_binary *binary,\r\nconst struct sh_css_binary_args *args,\r\nbool two_ppc,\r\nbool deinterleaved)\r\n{\r\nenum ia_css_err err = IA_CSS_SUCCESS;\r\n#ifdef ISP2401\r\nstruct ia_css_pipe *pipe = find_pipe_by_num(pipeline->pipe_num);\r\nconst struct ia_css_resolution *res;\r\n#endif\r\nia_css_fpn_configure(binary, &binary->in_frame_info);\r\nia_css_crop_configure(binary, &args->delay_frames[0]->info);\r\nia_css_qplane_configure(pipeline, binary, &binary->in_frame_info);\r\nia_css_output0_configure(binary, &args->out_frame[0]->info);\r\nia_css_output1_configure(binary, &args->out_vf_frame->info);\r\nia_css_copy_output_configure(binary, args->copy_output);\r\nia_css_output0_configure(binary, &args->out_frame[0]->info);\r\n#ifdef ISP2401\r\nia_css_sc_configure(binary, pipeline->shading.internal_frame_origin_x_bqs_on_sctbl,\r\npipeline->shading.internal_frame_origin_y_bqs_on_sctbl);\r\n#endif\r\nia_css_iterator_configure(binary, &args->in_frame->info);\r\nia_css_dvs_configure(binary, &args->out_frame[0]->info);\r\nia_css_output_configure(binary, &args->out_frame[0]->info);\r\nia_css_raw_configure(pipeline, binary, &args->in_frame->info, &binary->in_frame_info, two_ppc, deinterleaved);\r\nia_css_ref_configure(binary, (const struct ia_css_frame **)args->delay_frames, pipeline->dvs_frame_delay);\r\nia_css_tnr_configure(binary, (const struct ia_css_frame **)args->tnr_frames);\r\nia_css_bayer_io_config(binary, args);\r\nreturn err;\r\n}\r\nstatic void\r\ninitialize_isp_states(const struct ia_css_binary *binary)\r\n{\r\nunsigned int i;\r\nif (!binary->info->mem_offsets.offsets.state)\r\nreturn;\r\nfor (i = 0; i < IA_CSS_NUM_STATE_IDS; i++) {\r\nia_css_kernel_init_state[i](binary);\r\n}\r\n}\r\nstatic void\r\ninitialize_frame_buffer_attribute(struct ia_css_buffer_sp *buf_attr)\r\n{\r\nbuf_attr->buf_src.queue_id = SH_CSS_INVALID_QUEUE_ID;\r\nbuf_attr->buf_type = IA_CSS_BUFFER_TYPE_INVALID;\r\n}\r\nstatic void\r\ninitialize_stage_frames(struct ia_css_frames_sp *frames)\r\n{\r\nunsigned int i;\r\ninitialize_frame_buffer_attribute(&frames->in.buf_attr);\r\nfor (i = 0; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++) {\r\ninitialize_frame_buffer_attribute(&frames->out[i].buf_attr);\r\n}\r\ninitialize_frame_buffer_attribute(&frames->out_vf.buf_attr);\r\ninitialize_frame_buffer_attribute(&frames->s3a_buf);\r\ninitialize_frame_buffer_attribute(&frames->dvs_buf);\r\n#if defined SH_CSS_ENABLE_METADATA\r\ninitialize_frame_buffer_attribute(&frames->metadata_buf);\r\n#endif\r\n}\r\nstatic enum ia_css_err\r\nsp_init_stage(struct ia_css_pipeline_stage *stage,\r\nunsigned int pipe_num,\r\nbool xnr,\r\nunsigned int if_config_index,\r\nbool two_ppc)\r\n{\r\nstruct ia_css_binary *binary;\r\nconst struct ia_css_fw_info *firmware;\r\nconst struct sh_css_binary_args *args;\r\nunsigned stage_num;\r\nconst char *binary_name = "";\r\nconst struct ia_css_binary_xinfo *info = NULL;\r\nstatic struct ia_css_binary tmp_binary;\r\nconst struct ia_css_blob_info *blob_info = NULL;\r\nstruct ia_css_isp_param_css_segments isp_mem_if;\r\nstruct ia_css_isp_param_css_segments *mem_if = &isp_mem_if;\r\nenum ia_css_err err = IA_CSS_SUCCESS;\r\nassert(stage != NULL);\r\nbinary = stage->binary;\r\nfirmware = stage->firmware;\r\nargs = &stage->args;\r\nstage_num = stage->stage_num;\r\nif (binary) {\r\ninfo = binary->info;\r\nbinary_name = (const char *)(info->blob->name);\r\nblob_info = &info->blob->header.blob;\r\nia_css_init_memory_interface(mem_if, &binary->mem_params, &binary->css_params);\r\n} else if (firmware) {\r\nconst struct ia_css_frame_info *out_infos[IA_CSS_BINARY_MAX_OUTPUT_PORTS] = {NULL};\r\nif (args->out_frame[0])\r\nout_infos[0] = &args->out_frame[0]->info;\r\ninfo = &firmware->info.isp;\r\nia_css_binary_fill_info(info, false, false,\r\nIA_CSS_STREAM_FORMAT_RAW_10,\r\nargs->in_frame ? &args->in_frame->info : NULL,\r\nNULL,\r\nout_infos,\r\nargs->out_vf_frame ? &args->out_vf_frame->info\r\n: NULL,\r\n&tmp_binary,\r\nNULL,\r\n-1, true);\r\nbinary = &tmp_binary;\r\nbinary->info = info;\r\nbinary_name = IA_CSS_EXT_ISP_PROG_NAME(firmware);\r\nblob_info = &firmware->blob;\r\nmem_if = (struct ia_css_isp_param_css_segments *)&firmware->mem_initializers;\r\n} else {\r\nassert(stage->sp_func != IA_CSS_PIPELINE_NO_FUNC);\r\nreturn IA_CSS_ERR_INTERNAL_ERROR;\r\n}\r\nerr = sh_css_sp_init_stage(binary,\r\n(const char *)binary_name,\r\nblob_info,\r\nargs,\r\npipe_num,\r\nstage_num,\r\nxnr,\r\nmem_if,\r\nif_config_index,\r\ntwo_ppc);\r\nreturn err;\r\n}\r\nstatic void\r\nsp_init_sp_stage(struct ia_css_pipeline_stage *stage,\r\nunsigned pipe_num,\r\nbool two_ppc,\r\nenum sh_css_pipe_config_override copy_ovrd,\r\nunsigned int if_config_index)\r\n{\r\nconst struct sh_css_binary_args *args = &stage->args;\r\nassert(stage != NULL);\r\nswitch (stage->sp_func) {\r\ncase IA_CSS_PIPELINE_RAW_COPY:\r\nsh_css_sp_start_raw_copy(args->out_frame[0],\r\npipe_num, two_ppc,\r\nstage->max_input_width,\r\ncopy_ovrd, if_config_index);\r\nbreak;\r\ncase IA_CSS_PIPELINE_BIN_COPY:\r\nassert(false);\r\ncase IA_CSS_PIPELINE_ISYS_COPY:\r\nsh_css_sp_start_isys_copy(args->out_frame[0],\r\npipe_num, stage->max_input_width, if_config_index);\r\nbreak;\r\ncase IA_CSS_PIPELINE_NO_FUNC:\r\nassert(false);\r\n}\r\n}\r\nvoid\r\nsh_css_sp_init_pipeline(struct ia_css_pipeline *me,\r\nenum ia_css_pipe_id id,\r\nuint8_t pipe_num,\r\nbool xnr,\r\nbool two_ppc,\r\nbool continuous,\r\nbool offline,\r\nunsigned int required_bds_factor,\r\nenum sh_css_pipe_config_override copy_ovrd,\r\nenum ia_css_input_mode input_mode,\r\nconst struct ia_css_metadata_config *md_config,\r\nconst struct ia_css_metadata_info *md_info,\r\n#if !defined(HAS_NO_INPUT_SYSTEM)\r\nconst mipi_port_ID_t port_id\r\n#endif\r\n#ifdef ISP2401\r\n,\r\nconst struct ia_css_coordinate *internal_frame_origin_bqs_on_sctbl,\r\nconst struct ia_css_isp_parameters *params\r\n#endif\r\n)\r\n{\r\nstruct ia_css_pipeline_stage *stage = NULL;\r\nstruct ia_css_binary *first_binary = NULL;\r\nstruct ia_css_pipe *pipe = NULL;\r\nunsigned num;\r\nenum ia_css_pipe_id pipe_id = id;\r\nunsigned int thread_id;\r\nuint8_t if_config_index, tmp_if_config_index;\r\nassert(me != NULL);\r\n#if !defined(HAS_NO_INPUT_SYSTEM)\r\nassert(me->stages != NULL);\r\nfirst_binary = me->stages->binary;\r\nif (input_mode == IA_CSS_INPUT_MODE_SENSOR ||\r\ninput_mode == IA_CSS_INPUT_MODE_BUFFERED_SENSOR) {\r\nassert(port_id < N_MIPI_PORT_ID);\r\nif (port_id >= N_MIPI_PORT_ID)\r\nreturn;\r\nif_config_index = (uint8_t) (port_id - MIPI_PORT0_ID);\r\n} else if (input_mode == IA_CSS_INPUT_MODE_MEMORY) {\r\nif_config_index = SH_CSS_IF_CONFIG_NOT_NEEDED;\r\n} else {\r\nif_config_index = 0x0;\r\n}\r\n#else\r\n(void)input_mode;\r\nif_config_index = SH_CSS_IF_CONFIG_NOT_NEEDED;\r\n#endif\r\nia_css_pipeline_get_sp_thread_id(pipe_num, &thread_id);\r\nmemset(&sh_css_sp_group.pipe[thread_id], 0, sizeof(struct sh_css_sp_pipeline));\r\nfor (stage = me->stages, num = 0; stage; stage = stage->next, num++) {\r\nstage->stage_num = num;\r\nia_css_debug_pipe_graph_dump_stage(stage, id);\r\n}\r\nme->num_stages = num;\r\nif (first_binary != NULL) {\r\nsh_css_sp_init_group(two_ppc, first_binary->input_format,\r\noffline, if_config_index);\r\n}\r\n#if defined(USE_INPUT_SYSTEM_VERSION_2401) || defined(USE_INPUT_SYSTEM_VERSION_2)\r\nif ((me->num_stages == 1) && me->stages &&\r\n(me->stages->sp_func == IA_CSS_PIPELINE_ISYS_COPY))\r\nsh_css_sp_group.config.no_isp_sync = true;\r\n#endif\r\nsh_css_init_host2sp_frame_data();\r\nsh_css_sp_group.pipe[thread_id].num_stages = 0;\r\nsh_css_sp_group.pipe[thread_id].pipe_id = pipe_id;\r\nsh_css_sp_group.pipe[thread_id].thread_id = thread_id;\r\nsh_css_sp_group.pipe[thread_id].pipe_num = pipe_num;\r\nsh_css_sp_group.pipe[thread_id].num_execs = me->num_execs;\r\nsh_css_sp_group.pipe[thread_id].pipe_qos_config = me->pipe_qos_config;\r\nsh_css_sp_group.pipe[thread_id].required_bds_factor = required_bds_factor;\r\n#if !defined(HAS_NO_INPUT_SYSTEM)\r\nsh_css_sp_group.pipe[thread_id].input_system_mode\r\n= (uint32_t)input_mode;\r\nsh_css_sp_group.pipe[thread_id].port_id = port_id;\r\n#endif\r\nsh_css_sp_group.pipe[thread_id].dvs_frame_delay = (uint32_t)me->dvs_frame_delay;\r\nif (ia_css_pipeline_uses_params(me)) {\r\nsh_css_sp_group.pipe[thread_id].pipe_config =\r\nSH_CSS_PIPE_CONFIG_SAMPLE_PARAMS << thread_id;\r\n}\r\nif (continuous)\r\nsh_css_sp_group.pipe[thread_id].pipe_config = 0;\r\nsh_css_sp_group.pipe[thread_id].inout_port_config = me->inout_port_config;\r\npipe = find_pipe_by_num(pipe_num);\r\nassert(pipe != NULL);\r\nif (pipe == NULL) {\r\nreturn;\r\n}\r\nsh_css_sp_group.pipe[thread_id].scaler_pp_lut = sh_css_pipe_get_pp_gdc_lut(pipe);\r\n#if defined(SH_CSS_ENABLE_METADATA)\r\nif (md_info != NULL && md_info->size > 0) {\r\nsh_css_sp_group.pipe[thread_id].metadata.width = md_info->resolution.width;\r\nsh_css_sp_group.pipe[thread_id].metadata.height = md_info->resolution.height;\r\nsh_css_sp_group.pipe[thread_id].metadata.stride = md_info->stride;\r\nsh_css_sp_group.pipe[thread_id].metadata.size = md_info->size;\r\nia_css_isys_convert_stream_format_to_mipi_format(\r\nmd_config->data_type, MIPI_PREDICTOR_NONE,\r\n&sh_css_sp_group.pipe[thread_id].metadata.format);\r\n}\r\n#else\r\n(void)md_config;\r\n(void)md_info;\r\n#endif\r\n#if defined(SH_CSS_ENABLE_PER_FRAME_PARAMS)\r\nsh_css_sp_group.pipe[thread_id].output_frame_queue_id = (uint32_t)SH_CSS_INVALID_QUEUE_ID;\r\nif (IA_CSS_PIPE_ID_COPY != pipe_id) {\r\nia_css_query_internal_queue_id(IA_CSS_BUFFER_TYPE_OUTPUT_FRAME, thread_id, (enum sh_css_queue_id *)(&sh_css_sp_group.pipe[thread_id].output_frame_queue_id));\r\n}\r\n#endif\r\n#ifdef ISP2401\r\nif (internal_frame_origin_bqs_on_sctbl != NULL &&\r\nparams != NULL && params->shading_settings.enable_shading_table_conversion == 0) {\r\nsh_css_sp_group.pipe[thread_id].shading.internal_frame_origin_x_bqs_on_sctbl\r\n= (uint32_t)internal_frame_origin_bqs_on_sctbl->x;\r\nsh_css_sp_group.pipe[thread_id].shading.internal_frame_origin_y_bqs_on_sctbl\r\n= (uint32_t)internal_frame_origin_bqs_on_sctbl->y;\r\n} else {\r\nsh_css_sp_group.pipe[thread_id].shading.internal_frame_origin_x_bqs_on_sctbl = 0;\r\nsh_css_sp_group.pipe[thread_id].shading.internal_frame_origin_y_bqs_on_sctbl = 0;\r\n}\r\n#endif\r\nIA_CSS_LOG("pipe_id %d port_config %08x",\r\npipe_id, sh_css_sp_group.pipe[thread_id].inout_port_config);\r\nfor (stage = me->stages, num = 0; stage; stage = stage->next, num++) {\r\nsh_css_sp_group.pipe[thread_id].num_stages++;\r\nif (is_sp_stage(stage)) {\r\nsp_init_sp_stage(stage, pipe_num, two_ppc,\r\ncopy_ovrd, if_config_index);\r\n} else {\r\nif ((stage->stage_num != 0) || SH_CSS_PIPE_PORT_CONFIG_IS_CONTINUOUS(me->inout_port_config))\r\ntmp_if_config_index = SH_CSS_IF_CONFIG_NOT_NEEDED;\r\nelse\r\ntmp_if_config_index = if_config_index;\r\nsp_init_stage(stage, pipe_num,\r\nxnr, tmp_if_config_index, two_ppc);\r\n}\r\nstore_sp_stage_data(pipe_id, pipe_num, num);\r\n}\r\nsh_css_sp_group.pipe[thread_id].pipe_config |= (uint32_t)\r\n(me->acquire_isp_each_stage << IA_CSS_ACQUIRE_ISP_POS);\r\nstore_sp_group_data();\r\n}\r\nvoid\r\nsh_css_sp_uninit_pipeline(unsigned int pipe_num)\r\n{\r\nunsigned int thread_id;\r\nia_css_pipeline_get_sp_thread_id(pipe_num, &thread_id);\r\nsh_css_sp_group.pipe[thread_id].num_stages = 0;\r\n}\r\nbool sh_css_write_host2sp_command(enum host2sp_commands host2sp_command)\r\n{\r\nunsigned int HIVE_ADDR_host_sp_com = sh_css_sp_fw.info.sp.host_sp_com;\r\nunsigned int offset = (unsigned int)offsetof(struct host_sp_communication, host2sp_command)\r\n/ sizeof(int);\r\nenum host2sp_commands last_cmd = host2sp_cmd_error;\r\n(void)HIVE_ADDR_host_sp_com;\r\nlast_cmd = load_sp_array_uint(host_sp_com, offset);\r\nif (last_cmd != host2sp_cmd_ready)\r\nIA_CSS_ERROR("last host command not handled by SP(%d)", last_cmd);\r\nstore_sp_array_uint(host_sp_com, offset, host2sp_command);\r\nreturn (last_cmd == host2sp_cmd_ready);\r\n}\r\nenum host2sp_commands\r\nsh_css_read_host2sp_command(void)\r\n{\r\nunsigned int HIVE_ADDR_host_sp_com = sh_css_sp_fw.info.sp.host_sp_com;\r\nunsigned int offset = (unsigned int)offsetof(struct host_sp_communication, host2sp_command)\r\n/ sizeof(int);\r\n(void)HIVE_ADDR_host_sp_com;\r\nreturn (enum host2sp_commands)load_sp_array_uint(host_sp_com, offset);\r\n}\r\nvoid\r\nsh_css_init_host2sp_frame_data(void)\r\n{\r\nunsigned int HIVE_ADDR_host_sp_com = sh_css_sp_fw.info.sp.host_sp_com;\r\n(void)HIVE_ADDR_host_sp_com;\r\n}\r\nvoid\r\nsh_css_update_host2sp_offline_frame(\r\nunsigned frame_num,\r\nstruct ia_css_frame *frame,\r\nstruct ia_css_metadata *metadata)\r\n{\r\nunsigned int HIVE_ADDR_host_sp_com;\r\nunsigned int offset;\r\n(void)HIVE_ADDR_host_sp_com;\r\nassert(frame_num < NUM_CONTINUOUS_FRAMES);\r\nHIVE_ADDR_host_sp_com = sh_css_sp_fw.info.sp.host_sp_com;\r\noffset = (unsigned int)offsetof(struct host_sp_communication, host2sp_offline_frames)\r\n/ sizeof(int);\r\noffset += frame_num;\r\nstore_sp_array_uint(host_sp_com, offset, frame ? frame->data : 0);\r\noffset = (unsigned int)offsetof(struct host_sp_communication, host2sp_offline_metadata)\r\n/ sizeof(int);\r\noffset += frame_num;\r\nstore_sp_array_uint(host_sp_com, offset, metadata ? metadata->address : 0);\r\n}\r\nvoid\r\nsh_css_update_host2sp_mipi_frame(\r\nunsigned frame_num,\r\nstruct ia_css_frame *frame)\r\n{\r\nunsigned int HIVE_ADDR_host_sp_com;\r\nunsigned int offset;\r\n(void)HIVE_ADDR_host_sp_com;\r\nassert(frame_num < (N_CSI_PORTS * NUM_MIPI_FRAMES_PER_STREAM));\r\nHIVE_ADDR_host_sp_com = sh_css_sp_fw.info.sp.host_sp_com;\r\noffset = (unsigned int)offsetof(struct host_sp_communication, host2sp_mipi_frames)\r\n/ sizeof(int);\r\noffset += frame_num;\r\nstore_sp_array_uint(host_sp_com, offset,\r\nframe ? frame->data : 0);\r\n}\r\nvoid\r\nsh_css_update_host2sp_mipi_metadata(\r\nunsigned frame_num,\r\nstruct ia_css_metadata *metadata)\r\n{\r\nunsigned int HIVE_ADDR_host_sp_com;\r\nunsigned int o;\r\n(void)HIVE_ADDR_host_sp_com;\r\nassert(frame_num < (N_CSI_PORTS * NUM_MIPI_FRAMES_PER_STREAM));\r\nHIVE_ADDR_host_sp_com = sh_css_sp_fw.info.sp.host_sp_com;\r\no = offsetof(struct host_sp_communication, host2sp_mipi_metadata)\r\n/ sizeof(int);\r\no += frame_num;\r\nstore_sp_array_uint(host_sp_com, o,\r\nmetadata ? metadata->address : 0);\r\n}\r\nvoid\r\nsh_css_update_host2sp_num_mipi_frames(unsigned num_frames)\r\n{\r\nunsigned int HIVE_ADDR_host_sp_com;\r\nunsigned int offset;\r\n(void)HIVE_ADDR_host_sp_com;\r\nHIVE_ADDR_host_sp_com = sh_css_sp_fw.info.sp.host_sp_com;\r\noffset = (unsigned int)offsetof(struct host_sp_communication, host2sp_num_mipi_frames)\r\n/ sizeof(int);\r\nstore_sp_array_uint(host_sp_com, offset, num_frames);\r\n}\r\nvoid\r\nsh_css_update_host2sp_cont_num_raw_frames(unsigned num_frames, bool set_avail)\r\n{\r\nconst struct ia_css_fw_info *fw;\r\nunsigned int HIVE_ADDR_host_sp_com;\r\nunsigned int extra_num_frames, avail_num_frames;\r\nunsigned int offset, offset_extra;\r\n(void)HIVE_ADDR_host_sp_com;\r\nfw = &sh_css_sp_fw;\r\nHIVE_ADDR_host_sp_com = fw->info.sp.host_sp_com;\r\nif (set_avail) {\r\noffset = (unsigned int)offsetof(struct host_sp_communication, host2sp_cont_avail_num_raw_frames)\r\n/ sizeof(int);\r\navail_num_frames = load_sp_array_uint(host_sp_com, offset);\r\nextra_num_frames = num_frames - avail_num_frames;\r\noffset_extra = (unsigned int)offsetof(struct host_sp_communication, host2sp_cont_extra_num_raw_frames)\r\n/ sizeof(int);\r\nstore_sp_array_uint(host_sp_com, offset_extra, extra_num_frames);\r\n} else\r\noffset = (unsigned int)offsetof(struct host_sp_communication, host2sp_cont_target_num_raw_frames)\r\n/ sizeof(int);\r\nstore_sp_array_uint(host_sp_com, offset, num_frames);\r\n}\r\nvoid\r\nsh_css_event_init_irq_mask(void)\r\n{\r\nint i;\r\nunsigned int HIVE_ADDR_host_sp_com = sh_css_sp_fw.info.sp.host_sp_com;\r\nunsigned int offset;\r\nstruct sh_css_event_irq_mask event_irq_mask_init;\r\nevent_irq_mask_init.or_mask = IA_CSS_EVENT_TYPE_ALL;\r\nevent_irq_mask_init.and_mask = IA_CSS_EVENT_TYPE_NONE;\r\n(void)HIVE_ADDR_host_sp_com;\r\nassert(sizeof(event_irq_mask_init) % HRT_BUS_BYTES == 0);\r\nfor (i = 0; i < IA_CSS_PIPE_ID_NUM; i++) {\r\noffset = (unsigned int)offsetof(struct host_sp_communication,\r\nhost2sp_event_irq_mask[i]);\r\nassert(offset % HRT_BUS_BYTES == 0);\r\nsp_dmem_store(SP0_ID,\r\n(unsigned int)sp_address_of(host_sp_com) + offset,\r\n&event_irq_mask_init, sizeof(event_irq_mask_init));\r\n}\r\n}\r\nenum ia_css_err\r\nia_css_pipe_set_irq_mask(struct ia_css_pipe *pipe,\r\nunsigned int or_mask,\r\nunsigned int and_mask)\r\n{\r\nunsigned int HIVE_ADDR_host_sp_com = sh_css_sp_fw.info.sp.host_sp_com;\r\nunsigned int offset;\r\nstruct sh_css_event_irq_mask event_irq_mask;\r\nunsigned int pipe_num;\r\nassert(pipe != NULL);\r\nassert(IA_CSS_PIPE_ID_NUM == NR_OF_PIPELINES);\r\n#ifndef __KERNEL__\r\nassert(or_mask <= UINT16_MAX);\r\nassert(and_mask <= UINT16_MAX);\r\n#endif\r\n(void)HIVE_ADDR_host_sp_com;\r\nIA_CSS_LOG("or_mask=%x, and_mask=%x", or_mask, and_mask);\r\nevent_irq_mask.or_mask = (uint16_t)or_mask;\r\nevent_irq_mask.and_mask = (uint16_t)and_mask;\r\npipe_num = ia_css_pipe_get_pipe_num(pipe);\r\nif (pipe_num >= IA_CSS_PIPE_ID_NUM)\r\nreturn IA_CSS_ERR_INTERNAL_ERROR;\r\noffset = (unsigned int)offsetof(struct host_sp_communication,\r\nhost2sp_event_irq_mask[pipe_num]);\r\nassert(offset % HRT_BUS_BYTES == 0);\r\nsp_dmem_store(SP0_ID,\r\n(unsigned int)sp_address_of(host_sp_com) + offset,\r\n&event_irq_mask, sizeof(event_irq_mask));\r\nreturn IA_CSS_SUCCESS;\r\n}\r\nenum ia_css_err\r\nia_css_event_get_irq_mask(const struct ia_css_pipe *pipe,\r\nunsigned int *or_mask,\r\nunsigned int *and_mask)\r\n{\r\nunsigned int HIVE_ADDR_host_sp_com = sh_css_sp_fw.info.sp.host_sp_com;\r\nunsigned int offset;\r\nstruct sh_css_event_irq_mask event_irq_mask;\r\nunsigned int pipe_num;\r\n(void)HIVE_ADDR_host_sp_com;\r\nIA_CSS_ENTER_LEAVE("");\r\nassert(pipe != NULL);\r\nassert(IA_CSS_PIPE_ID_NUM == NR_OF_PIPELINES);\r\npipe_num = ia_css_pipe_get_pipe_num(pipe);\r\nif (pipe_num >= IA_CSS_PIPE_ID_NUM)\r\nreturn IA_CSS_ERR_INTERNAL_ERROR;\r\noffset = (unsigned int)offsetof(struct host_sp_communication,\r\nhost2sp_event_irq_mask[pipe_num]);\r\nassert(offset % HRT_BUS_BYTES == 0);\r\nsp_dmem_load(SP0_ID,\r\n(unsigned int)sp_address_of(host_sp_com) + offset,\r\n&event_irq_mask, sizeof(event_irq_mask));\r\nif (or_mask)\r\n*or_mask = event_irq_mask.or_mask;\r\nif (and_mask)\r\n*and_mask = event_irq_mask.and_mask;\r\nreturn IA_CSS_SUCCESS;\r\n}\r\nvoid\r\nsh_css_sp_set_sp_running(bool flag)\r\n{\r\nsp_running = flag;\r\n}\r\nbool\r\nsh_css_sp_is_running(void)\r\n{\r\nreturn sp_running;\r\n}\r\nvoid\r\nsh_css_sp_start_isp(void)\r\n{\r\nconst struct ia_css_fw_info *fw;\r\nunsigned int HIVE_ADDR_sp_sw_state;\r\nfw = &sh_css_sp_fw;\r\nHIVE_ADDR_sp_sw_state = fw->info.sp.sw_state;\r\nif (sp_running)\r\nreturn;\r\n(void)HIVE_ADDR_sp_sw_state;\r\nstore_sp_group_data();\r\nstore_sp_per_frame_data(fw);\r\nsp_dmem_store_uint32(SP0_ID,\r\n(unsigned int)sp_address_of(sp_sw_state),\r\n(uint32_t)(IA_CSS_SP_SW_TERMINATED));\r\nsp_running = true;\r\nia_css_mmu_invalidate_cache();\r\nmmu_invalidate_cache_all();\r\nia_css_spctrl_start(SP0_ID);\r\n}\r\nbool\r\nia_css_isp_has_started(void)\r\n{\r\nconst struct ia_css_fw_info *fw = &sh_css_sp_fw;\r\nunsigned int HIVE_ADDR_ia_css_ispctrl_sp_isp_started = fw->info.sp.isp_started;\r\n(void)HIVE_ADDR_ia_css_ispctrl_sp_isp_started;\r\nreturn (bool)load_sp_uint(ia_css_ispctrl_sp_isp_started);\r\n}\r\nbool\r\nsh_css_sp_init_dma_sw_reg(int dma_id)\r\n{\r\nint i;\r\nfor (i = 0; i < N_DMA_CHANNEL_ID; i++) {\r\nsh_css_sp_set_dma_sw_reg(dma_id,\r\ni,\r\n0,\r\ntrue);\r\nsh_css_sp_set_dma_sw_reg(dma_id,\r\ni,\r\n1,\r\ntrue);\r\n}\r\nreturn true;\r\n}\r\nbool\r\nsh_css_sp_set_dma_sw_reg(int dma_id,\r\nint channel_id,\r\nint request_type,\r\nbool enable)\r\n{\r\nuint32_t sw_reg;\r\nuint32_t bit_val;\r\nuint32_t bit_offset;\r\nuint32_t bit_mask;\r\n(void)dma_id;\r\nassert(channel_id >= 0 && channel_id < N_DMA_CHANNEL_ID);\r\nassert(request_type >= 0);\r\nsw_reg =\r\nsh_css_sp_group.debug.dma_sw_reg;\r\nbit_offset = (8 * request_type) + channel_id;\r\nbit_mask = ~(1 << bit_offset);\r\nsw_reg &= bit_mask;\r\nbit_val = enable ? 1 : 0;\r\nbit_val <<= bit_offset;\r\nsw_reg |= bit_val;\r\nsh_css_sp_group.debug.dma_sw_reg = sw_reg;\r\nreturn true;\r\n}\r\nvoid\r\nsh_css_sp_reset_global_vars(void)\r\n{\r\nmemset(&sh_css_sp_group, 0, sizeof(struct sh_css_sp_group));\r\nmemset(&sh_css_sp_stage, 0, sizeof(struct sh_css_sp_stage));\r\nmemset(&sh_css_isp_stage, 0, sizeof(struct sh_css_isp_stage));\r\nmemset(&sh_css_sp_output, 0, sizeof(struct sh_css_sp_output));\r\nmemset(&per_frame_data, 0, sizeof(struct sh_css_sp_per_frame_data));\r\n}
