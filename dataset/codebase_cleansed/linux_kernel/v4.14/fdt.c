void of_fdt_limit_memory(int limit)\r\n{\r\nint memory;\r\nint len;\r\nconst void *val;\r\nint nr_address_cells = OF_ROOT_NODE_ADDR_CELLS_DEFAULT;\r\nint nr_size_cells = OF_ROOT_NODE_SIZE_CELLS_DEFAULT;\r\nconst __be32 *addr_prop;\r\nconst __be32 *size_prop;\r\nint root_offset;\r\nint cell_size;\r\nroot_offset = fdt_path_offset(initial_boot_params, "/");\r\nif (root_offset < 0)\r\nreturn;\r\naddr_prop = fdt_getprop(initial_boot_params, root_offset,\r\n"#address-cells", NULL);\r\nif (addr_prop)\r\nnr_address_cells = fdt32_to_cpu(*addr_prop);\r\nsize_prop = fdt_getprop(initial_boot_params, root_offset,\r\n"#size-cells", NULL);\r\nif (size_prop)\r\nnr_size_cells = fdt32_to_cpu(*size_prop);\r\ncell_size = sizeof(uint32_t)*(nr_address_cells + nr_size_cells);\r\nmemory = fdt_path_offset(initial_boot_params, "/memory");\r\nif (memory > 0) {\r\nval = fdt_getprop(initial_boot_params, memory, "reg", &len);\r\nif (len > limit*cell_size) {\r\nlen = limit*cell_size;\r\npr_debug("Limiting number of entries to %d\n", limit);\r\nfdt_setprop(initial_boot_params, memory, "reg", val,\r\nlen);\r\n}\r\n}\r\n}\r\nstatic int of_fdt_is_compatible(const void *blob,\r\nunsigned long node, const char *compat)\r\n{\r\nconst char *cp;\r\nint cplen;\r\nunsigned long l, score = 0;\r\ncp = fdt_getprop(blob, node, "compatible", &cplen);\r\nif (cp == NULL)\r\nreturn 0;\r\nwhile (cplen > 0) {\r\nscore++;\r\nif (of_compat_cmp(cp, compat, strlen(compat)) == 0)\r\nreturn score;\r\nl = strlen(cp) + 1;\r\ncp += l;\r\ncplen -= l;\r\n}\r\nreturn 0;\r\n}\r\nbool of_fdt_is_big_endian(const void *blob, unsigned long node)\r\n{\r\nif (fdt_getprop(blob, node, "big-endian", NULL))\r\nreturn true;\r\nif (IS_ENABLED(CONFIG_CPU_BIG_ENDIAN) &&\r\nfdt_getprop(blob, node, "native-endian", NULL))\r\nreturn true;\r\nreturn false;\r\n}\r\nint of_fdt_match(const void *blob, unsigned long node,\r\nconst char *const *compat)\r\n{\r\nunsigned int tmp, score = 0;\r\nif (!compat)\r\nreturn 0;\r\nwhile (*compat) {\r\ntmp = of_fdt_is_compatible(blob, node, *compat);\r\nif (tmp && (score == 0 || (tmp < score)))\r\nscore = tmp;\r\ncompat++;\r\n}\r\nreturn score;\r\n}\r\nstatic void *unflatten_dt_alloc(void **mem, unsigned long size,\r\nunsigned long align)\r\n{\r\nvoid *res;\r\n*mem = PTR_ALIGN(*mem, align);\r\nres = *mem;\r\n*mem += size;\r\nreturn res;\r\n}\r\nstatic void populate_properties(const void *blob,\r\nint offset,\r\nvoid **mem,\r\nstruct device_node *np,\r\nconst char *nodename,\r\nbool dryrun)\r\n{\r\nstruct property *pp, **pprev = NULL;\r\nint cur;\r\nbool has_name = false;\r\npprev = &np->properties;\r\nfor (cur = fdt_first_property_offset(blob, offset);\r\ncur >= 0;\r\ncur = fdt_next_property_offset(blob, cur)) {\r\nconst __be32 *val;\r\nconst char *pname;\r\nu32 sz;\r\nval = fdt_getprop_by_offset(blob, cur, &pname, &sz);\r\nif (!val) {\r\npr_warn("Cannot locate property at 0x%x\n", cur);\r\ncontinue;\r\n}\r\nif (!pname) {\r\npr_warn("Cannot find property name at 0x%x\n", cur);\r\ncontinue;\r\n}\r\nif (!strcmp(pname, "name"))\r\nhas_name = true;\r\npp = unflatten_dt_alloc(mem, sizeof(struct property),\r\n__alignof__(struct property));\r\nif (dryrun)\r\ncontinue;\r\nif (!strcmp(pname, "phandle") ||\r\n!strcmp(pname, "linux,phandle")) {\r\nif (!np->phandle)\r\nnp->phandle = be32_to_cpup(val);\r\n}\r\nif (!strcmp(pname, "ibm,phandle"))\r\nnp->phandle = be32_to_cpup(val);\r\npp->name = (char *)pname;\r\npp->length = sz;\r\npp->value = (__be32 *)val;\r\n*pprev = pp;\r\npprev = &pp->next;\r\n}\r\nif (!has_name) {\r\nconst char *p = nodename, *ps = p, *pa = NULL;\r\nint len;\r\nwhile (*p) {\r\nif ((*p) == '@')\r\npa = p;\r\nelse if ((*p) == '/')\r\nps = p + 1;\r\np++;\r\n}\r\nif (pa < ps)\r\npa = p;\r\nlen = (pa - ps) + 1;\r\npp = unflatten_dt_alloc(mem, sizeof(struct property) + len,\r\n__alignof__(struct property));\r\nif (!dryrun) {\r\npp->name = "name";\r\npp->length = len;\r\npp->value = pp + 1;\r\n*pprev = pp;\r\npprev = &pp->next;\r\nmemcpy(pp->value, ps, len - 1);\r\n((char *)pp->value)[len - 1] = 0;\r\npr_debug("fixed up name for %s -> %s\n",\r\nnodename, (char *)pp->value);\r\n}\r\n}\r\nif (!dryrun)\r\n*pprev = NULL;\r\n}\r\nstatic unsigned int populate_node(const void *blob,\r\nint offset,\r\nvoid **mem,\r\nstruct device_node *dad,\r\nunsigned int fpsize,\r\nstruct device_node **pnp,\r\nbool dryrun)\r\n{\r\nstruct device_node *np;\r\nconst char *pathp;\r\nunsigned int l, allocl;\r\nint new_format = 0;\r\npathp = fdt_get_name(blob, offset, &l);\r\nif (!pathp) {\r\n*pnp = NULL;\r\nreturn 0;\r\n}\r\nallocl = ++l;\r\nif ((*pathp) != '/') {\r\nnew_format = 1;\r\nif (fpsize == 0) {\r\nfpsize = 1;\r\nallocl = 2;\r\nl = 1;\r\npathp = "";\r\n} else {\r\nfpsize += l;\r\nallocl = fpsize;\r\n}\r\n}\r\nnp = unflatten_dt_alloc(mem, sizeof(struct device_node) + allocl,\r\n__alignof__(struct device_node));\r\nif (!dryrun) {\r\nchar *fn;\r\nof_node_init(np);\r\nnp->full_name = fn = ((char *)np) + sizeof(*np);\r\nif (new_format) {\r\nif (dad && dad->parent) {\r\nstrcpy(fn, dad->full_name);\r\n#ifdef DEBUG\r\nif ((strlen(fn) + l + 1) != allocl) {\r\npr_debug("%s: p: %d, l: %d, a: %d\n",\r\npathp, (int)strlen(fn),\r\nl, allocl);\r\n}\r\n#endif\r\nfn += strlen(fn);\r\n}\r\n*(fn++) = '/';\r\n}\r\nmemcpy(fn, pathp, l);\r\nif (dad != NULL) {\r\nnp->parent = dad;\r\nnp->sibling = dad->child;\r\ndad->child = np;\r\n}\r\n}\r\npopulate_properties(blob, offset, mem, np, pathp, dryrun);\r\nif (!dryrun) {\r\nnp->name = of_get_property(np, "name", NULL);\r\nnp->type = of_get_property(np, "device_type", NULL);\r\nif (!np->name)\r\nnp->name = "<NULL>";\r\nif (!np->type)\r\nnp->type = "<NULL>";\r\n}\r\n*pnp = np;\r\nreturn fpsize;\r\n}\r\nstatic void reverse_nodes(struct device_node *parent)\r\n{\r\nstruct device_node *child, *next;\r\nchild = parent->child;\r\nwhile (child) {\r\nreverse_nodes(child);\r\nchild = child->sibling;\r\n}\r\nchild = parent->child;\r\nparent->child = NULL;\r\nwhile (child) {\r\nnext = child->sibling;\r\nchild->sibling = parent->child;\r\nparent->child = child;\r\nchild = next;\r\n}\r\n}\r\nstatic int unflatten_dt_nodes(const void *blob,\r\nvoid *mem,\r\nstruct device_node *dad,\r\nstruct device_node **nodepp)\r\n{\r\nstruct device_node *root;\r\nint offset = 0, depth = 0, initial_depth = 0;\r\n#define FDT_MAX_DEPTH 64\r\nunsigned int fpsizes[FDT_MAX_DEPTH];\r\nstruct device_node *nps[FDT_MAX_DEPTH];\r\nvoid *base = mem;\r\nbool dryrun = !base;\r\nif (nodepp)\r\n*nodepp = NULL;\r\nif (dad)\r\ndepth = initial_depth = 1;\r\nroot = dad;\r\nfpsizes[depth] = dad ? strlen(of_node_full_name(dad)) : 0;\r\nnps[depth] = dad;\r\nfor (offset = 0;\r\noffset >= 0 && depth >= initial_depth;\r\noffset = fdt_next_node(blob, offset, &depth)) {\r\nif (WARN_ON_ONCE(depth >= FDT_MAX_DEPTH))\r\ncontinue;\r\nfpsizes[depth+1] = populate_node(blob, offset, &mem,\r\nnps[depth],\r\nfpsizes[depth],\r\n&nps[depth+1], dryrun);\r\nif (!fpsizes[depth+1])\r\nreturn mem - base;\r\nif (!dryrun && nodepp && !*nodepp)\r\n*nodepp = nps[depth+1];\r\nif (!dryrun && !root)\r\nroot = nps[depth+1];\r\n}\r\nif (offset < 0 && offset != -FDT_ERR_NOTFOUND) {\r\npr_err("Error %d processing FDT\n", offset);\r\nreturn -EINVAL;\r\n}\r\nif (!dryrun)\r\nreverse_nodes(root);\r\nreturn mem - base;\r\n}\r\nvoid *__unflatten_device_tree(const void *blob,\r\nstruct device_node *dad,\r\nstruct device_node **mynodes,\r\nvoid *(*dt_alloc)(u64 size, u64 align),\r\nbool detached)\r\n{\r\nint size;\r\nvoid *mem;\r\npr_debug(" -> unflatten_device_tree()\n");\r\nif (!blob) {\r\npr_debug("No device tree pointer\n");\r\nreturn NULL;\r\n}\r\npr_debug("Unflattening device tree:\n");\r\npr_debug("magic: %08x\n", fdt_magic(blob));\r\npr_debug("size: %08x\n", fdt_totalsize(blob));\r\npr_debug("version: %08x\n", fdt_version(blob));\r\nif (fdt_check_header(blob)) {\r\npr_err("Invalid device tree blob header\n");\r\nreturn NULL;\r\n}\r\nsize = unflatten_dt_nodes(blob, NULL, dad, NULL);\r\nif (size < 0)\r\nreturn NULL;\r\nsize = ALIGN(size, 4);\r\npr_debug(" size is %d, allocating...\n", size);\r\nmem = dt_alloc(size + 4, __alignof__(struct device_node));\r\nif (!mem)\r\nreturn NULL;\r\nmemset(mem, 0, size);\r\n*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);\r\npr_debug(" unflattening %p...\n", mem);\r\nunflatten_dt_nodes(blob, mem, dad, mynodes);\r\nif (be32_to_cpup(mem + size) != 0xdeadbeef)\r\npr_warning("End of tree marker overwritten: %08x\n",\r\nbe32_to_cpup(mem + size));\r\nif (detached && mynodes) {\r\nof_node_set_flag(*mynodes, OF_DETACHED);\r\npr_debug("unflattened tree is detached\n");\r\n}\r\npr_debug(" <- unflatten_device_tree()\n");\r\nreturn mem;\r\n}\r\nstatic void *kernel_tree_alloc(u64 size, u64 align)\r\n{\r\nreturn kzalloc(size, GFP_KERNEL);\r\n}\r\nvoid *of_fdt_unflatten_tree(const unsigned long *blob,\r\nstruct device_node *dad,\r\nstruct device_node **mynodes)\r\n{\r\nvoid *mem;\r\nmutex_lock(&of_fdt_unflatten_mutex);\r\nmem = __unflatten_device_tree(blob, dad, mynodes, &kernel_tree_alloc,\r\ntrue);\r\nmutex_unlock(&of_fdt_unflatten_mutex);\r\nreturn mem;\r\n}\r\nstatic int __init __reserved_mem_reserve_reg(unsigned long node,\r\nconst char *uname)\r\n{\r\nint t_len = (dt_root_addr_cells + dt_root_size_cells) * sizeof(__be32);\r\nphys_addr_t base, size;\r\nint len;\r\nconst __be32 *prop;\r\nint nomap, first = 1;\r\nprop = of_get_flat_dt_prop(node, "reg", &len);\r\nif (!prop)\r\nreturn -ENOENT;\r\nif (len && len % t_len != 0) {\r\npr_err("Reserved memory: invalid reg property in '%s', skipping node.\n",\r\nuname);\r\nreturn -EINVAL;\r\n}\r\nnomap = of_get_flat_dt_prop(node, "no-map", NULL) != NULL;\r\nwhile (len >= t_len) {\r\nbase = dt_mem_next_cell(dt_root_addr_cells, &prop);\r\nsize = dt_mem_next_cell(dt_root_size_cells, &prop);\r\nif (size &&\r\nearly_init_dt_reserve_memory_arch(base, size, nomap) == 0)\r\npr_debug("Reserved memory: reserved region for node '%s': base %pa, size %ld MiB\n",\r\nuname, &base, (unsigned long)size / SZ_1M);\r\nelse\r\npr_info("Reserved memory: failed to reserve memory for node '%s': base %pa, size %ld MiB\n",\r\nuname, &base, (unsigned long)size / SZ_1M);\r\nlen -= t_len;\r\nif (first) {\r\nfdt_reserved_mem_save_node(node, uname, base, size);\r\nfirst = 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init __reserved_mem_check_root(unsigned long node)\r\n{\r\nconst __be32 *prop;\r\nprop = of_get_flat_dt_prop(node, "#size-cells", NULL);\r\nif (!prop || be32_to_cpup(prop) != dt_root_size_cells)\r\nreturn -EINVAL;\r\nprop = of_get_flat_dt_prop(node, "#address-cells", NULL);\r\nif (!prop || be32_to_cpup(prop) != dt_root_addr_cells)\r\nreturn -EINVAL;\r\nprop = of_get_flat_dt_prop(node, "ranges", NULL);\r\nif (!prop)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int __init __fdt_scan_reserved_mem(unsigned long node, const char *uname,\r\nint depth, void *data)\r\n{\r\nstatic int found;\r\nconst char *status;\r\nint err;\r\nif (!found && depth == 1 && strcmp(uname, "reserved-memory") == 0) {\r\nif (__reserved_mem_check_root(node) != 0) {\r\npr_err("Reserved memory: unsupported node format, ignoring\n");\r\nreturn 1;\r\n}\r\nfound = 1;\r\nreturn 0;\r\n} else if (!found) {\r\nreturn 0;\r\n} else if (found && depth < 2) {\r\nreturn 1;\r\n}\r\nstatus = of_get_flat_dt_prop(node, "status", NULL);\r\nif (status && strcmp(status, "okay") != 0 && strcmp(status, "ok") != 0)\r\nreturn 0;\r\nerr = __reserved_mem_reserve_reg(node, uname);\r\nif (err == -ENOENT && of_get_flat_dt_prop(node, "size", NULL))\r\nfdt_reserved_mem_save_node(node, uname, 0, 0);\r\nreturn 0;\r\n}\r\nvoid __init early_init_fdt_scan_reserved_mem(void)\r\n{\r\nint n;\r\nu64 base, size;\r\nif (!initial_boot_params)\r\nreturn;\r\nfor (n = 0; ; n++) {\r\nfdt_get_mem_rsv(initial_boot_params, n, &base, &size);\r\nif (!size)\r\nbreak;\r\nearly_init_dt_reserve_memory_arch(base, size, 0);\r\n}\r\nof_scan_flat_dt(__fdt_scan_reserved_mem, NULL);\r\nfdt_init_reserved_mem();\r\n}\r\nvoid __init early_init_fdt_reserve_self(void)\r\n{\r\nif (!initial_boot_params)\r\nreturn;\r\nearly_init_dt_reserve_memory_arch(__pa(initial_boot_params),\r\nfdt_totalsize(initial_boot_params),\r\n0);\r\n}\r\nint __init of_scan_flat_dt(int (*it)(unsigned long node,\r\nconst char *uname, int depth,\r\nvoid *data),\r\nvoid *data)\r\n{\r\nconst void *blob = initial_boot_params;\r\nconst char *pathp;\r\nint offset, rc = 0, depth = -1;\r\nif (!blob)\r\nreturn 0;\r\nfor (offset = fdt_next_node(blob, -1, &depth);\r\noffset >= 0 && depth >= 0 && !rc;\r\noffset = fdt_next_node(blob, offset, &depth)) {\r\npathp = fdt_get_name(blob, offset, NULL);\r\nif (*pathp == '/')\r\npathp = kbasename(pathp);\r\nrc = it(offset, pathp, depth, data);\r\n}\r\nreturn rc;\r\n}\r\nint __init of_scan_flat_dt_subnodes(unsigned long parent,\r\nint (*it)(unsigned long node,\r\nconst char *uname,\r\nvoid *data),\r\nvoid *data)\r\n{\r\nconst void *blob = initial_boot_params;\r\nint node;\r\nfdt_for_each_subnode(node, blob, parent) {\r\nconst char *pathp;\r\nint rc;\r\npathp = fdt_get_name(blob, node, NULL);\r\nif (*pathp == '/')\r\npathp = kbasename(pathp);\r\nrc = it(node, pathp, data);\r\nif (rc)\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nint of_get_flat_dt_subnode_by_name(unsigned long node, const char *uname)\r\n{\r\nreturn fdt_subnode_offset(initial_boot_params, node, uname);\r\n}\r\nunsigned long __init of_get_flat_dt_root(void)\r\n{\r\nreturn 0;\r\n}\r\nint __init of_get_flat_dt_size(void)\r\n{\r\nreturn fdt_totalsize(initial_boot_params);\r\n}\r\nconst void *__init of_get_flat_dt_prop(unsigned long node, const char *name,\r\nint *size)\r\n{\r\nreturn fdt_getprop(initial_boot_params, node, name, size);\r\n}\r\nint __init of_flat_dt_is_compatible(unsigned long node, const char *compat)\r\n{\r\nreturn of_fdt_is_compatible(initial_boot_params, node, compat);\r\n}\r\nint __init of_flat_dt_match(unsigned long node, const char *const *compat)\r\n{\r\nreturn of_fdt_match(initial_boot_params, node, compat);\r\n}\r\nuint32_t __init of_get_flat_dt_phandle(unsigned long node)\r\n{\r\nreturn fdt_get_phandle(initial_boot_params, node);\r\n}\r\nconst char * __init of_flat_dt_get_machine_name(void)\r\n{\r\nconst char *name;\r\nunsigned long dt_root = of_get_flat_dt_root();\r\nname = of_get_flat_dt_prop(dt_root, "model", NULL);\r\nif (!name)\r\nname = of_get_flat_dt_prop(dt_root, "compatible", NULL);\r\nreturn name;\r\n}\r\nconst void * __init of_flat_dt_match_machine(const void *default_match,\r\nconst void * (*get_next_compat)(const char * const**))\r\n{\r\nconst void *data = NULL;\r\nconst void *best_data = default_match;\r\nconst char *const *compat;\r\nunsigned long dt_root;\r\nunsigned int best_score = ~1, score = 0;\r\ndt_root = of_get_flat_dt_root();\r\nwhile ((data = get_next_compat(&compat))) {\r\nscore = of_flat_dt_match(dt_root, compat);\r\nif (score > 0 && score < best_score) {\r\nbest_data = data;\r\nbest_score = score;\r\n}\r\n}\r\nif (!best_data) {\r\nconst char *prop;\r\nint size;\r\npr_err("\n unrecognized device tree list:\n[ ");\r\nprop = of_get_flat_dt_prop(dt_root, "compatible", &size);\r\nif (prop) {\r\nwhile (size > 0) {\r\nprintk("'%s' ", prop);\r\nsize -= strlen(prop) + 1;\r\nprop += strlen(prop) + 1;\r\n}\r\n}\r\nprintk("]\n\n");\r\nreturn NULL;\r\n}\r\npr_info("Machine model: %s\n", of_flat_dt_get_machine_name());\r\nreturn best_data;\r\n}\r\nstatic void __early_init_dt_declare_initrd(unsigned long start,\r\nunsigned long end)\r\n{\r\ninitrd_start = (unsigned long)__va(start);\r\ninitrd_end = (unsigned long)__va(end);\r\ninitrd_below_start_ok = 1;\r\n}\r\nstatic void __init early_init_dt_check_for_initrd(unsigned long node)\r\n{\r\nu64 start, end;\r\nint len;\r\nconst __be32 *prop;\r\npr_debug("Looking for initrd properties... ");\r\nprop = of_get_flat_dt_prop(node, "linux,initrd-start", &len);\r\nif (!prop)\r\nreturn;\r\nstart = of_read_number(prop, len/4);\r\nprop = of_get_flat_dt_prop(node, "linux,initrd-end", &len);\r\nif (!prop)\r\nreturn;\r\nend = of_read_number(prop, len/4);\r\n__early_init_dt_declare_initrd(start, end);\r\npr_debug("initrd_start=0x%llx initrd_end=0x%llx\n",\r\n(unsigned long long)start, (unsigned long long)end);\r\n}\r\nstatic inline void early_init_dt_check_for_initrd(unsigned long node)\r\n{\r\n}\r\nint __init early_init_dt_scan_chosen_stdout(void)\r\n{\r\nint offset;\r\nconst char *p, *q, *options = NULL;\r\nint l;\r\nconst struct earlycon_id *match;\r\nconst void *fdt = initial_boot_params;\r\noffset = fdt_path_offset(fdt, "/chosen");\r\nif (offset < 0)\r\noffset = fdt_path_offset(fdt, "/chosen@0");\r\nif (offset < 0)\r\nreturn -ENOENT;\r\np = fdt_getprop(fdt, offset, "stdout-path", &l);\r\nif (!p)\r\np = fdt_getprop(fdt, offset, "linux,stdout-path", &l);\r\nif (!p || !l)\r\nreturn -ENOENT;\r\nq = strchrnul(p, ':');\r\nif (*q != '\0')\r\noptions = q + 1;\r\nl = q - p;\r\noffset = fdt_path_offset_namelen(fdt, p, l);\r\nif (offset < 0) {\r\npr_warn("earlycon: stdout-path %.*s not found\n", l, p);\r\nreturn 0;\r\n}\r\nfor (match = __earlycon_table; match < __earlycon_table_end; match++) {\r\nif (!match->compatible[0])\r\ncontinue;\r\nif (fdt_node_check_compatible(fdt, offset, match->compatible))\r\ncontinue;\r\nof_setup_earlycon(match, offset, options);\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nint __init early_init_dt_scan_root(unsigned long node, const char *uname,\r\nint depth, void *data)\r\n{\r\nconst __be32 *prop;\r\nif (depth != 0)\r\nreturn 0;\r\ndt_root_size_cells = OF_ROOT_NODE_SIZE_CELLS_DEFAULT;\r\ndt_root_addr_cells = OF_ROOT_NODE_ADDR_CELLS_DEFAULT;\r\nprop = of_get_flat_dt_prop(node, "#size-cells", NULL);\r\nif (prop)\r\ndt_root_size_cells = be32_to_cpup(prop);\r\npr_debug("dt_root_size_cells = %x\n", dt_root_size_cells);\r\nprop = of_get_flat_dt_prop(node, "#address-cells", NULL);\r\nif (prop)\r\ndt_root_addr_cells = be32_to_cpup(prop);\r\npr_debug("dt_root_addr_cells = %x\n", dt_root_addr_cells);\r\nreturn 1;\r\n}\r\nu64 __init dt_mem_next_cell(int s, const __be32 **cellp)\r\n{\r\nconst __be32 *p = *cellp;\r\n*cellp = p + s;\r\nreturn of_read_number(p, s);\r\n}\r\nint __init early_init_dt_scan_memory(unsigned long node, const char *uname,\r\nint depth, void *data)\r\n{\r\nconst char *type = of_get_flat_dt_prop(node, "device_type", NULL);\r\nconst __be32 *reg, *endp;\r\nint l;\r\nbool hotpluggable;\r\nif (type == NULL) {\r\nif (!IS_ENABLED(CONFIG_PPC32) || depth != 1 || strcmp(uname, "memory@0") != 0)\r\nreturn 0;\r\n} else if (strcmp(type, "memory") != 0)\r\nreturn 0;\r\nreg = of_get_flat_dt_prop(node, "linux,usable-memory", &l);\r\nif (reg == NULL)\r\nreg = of_get_flat_dt_prop(node, "reg", &l);\r\nif (reg == NULL)\r\nreturn 0;\r\nendp = reg + (l / sizeof(__be32));\r\nhotpluggable = of_get_flat_dt_prop(node, "hotpluggable", NULL);\r\npr_debug("memory scan node %s, reg size %d,\n", uname, l);\r\nwhile ((endp - reg) >= (dt_root_addr_cells + dt_root_size_cells)) {\r\nu64 base, size;\r\nbase = dt_mem_next_cell(dt_root_addr_cells, &reg);\r\nsize = dt_mem_next_cell(dt_root_size_cells, &reg);\r\nif (size == 0)\r\ncontinue;\r\npr_debug(" - %llx , %llx\n", (unsigned long long)base,\r\n(unsigned long long)size);\r\nearly_init_dt_add_memory_arch(base, size);\r\nif (!hotpluggable)\r\ncontinue;\r\nif (early_init_dt_mark_hotplug_memory_arch(base, size))\r\npr_warn("failed to mark hotplug range 0x%llx - 0x%llx\n",\r\nbase, base + size);\r\n}\r\nreturn 0;\r\n}\r\nint __init early_init_dt_scan_chosen(unsigned long node, const char *uname,\r\nint depth, void *data)\r\n{\r\nint l;\r\nconst char *p;\r\npr_debug("search \"chosen\", depth: %d, uname: %s\n", depth, uname);\r\nif (depth != 1 || !data ||\r\n(strcmp(uname, "chosen") != 0 && strcmp(uname, "chosen@0") != 0))\r\nreturn 0;\r\nearly_init_dt_check_for_initrd(node);\r\np = of_get_flat_dt_prop(node, "bootargs", &l);\r\nif (p != NULL && l > 0)\r\nstrlcpy(data, p, min((int)l, COMMAND_LINE_SIZE));\r\n#ifdef CONFIG_CMDLINE\r\n#if defined(CONFIG_CMDLINE_EXTEND)\r\nstrlcat(data, " ", COMMAND_LINE_SIZE);\r\nstrlcat(data, CONFIG_CMDLINE, COMMAND_LINE_SIZE);\r\n#elif defined(CONFIG_CMDLINE_FORCE)\r\nstrlcpy(data, CONFIG_CMDLINE, COMMAND_LINE_SIZE);\r\n#else\r\nif (!((char *)data)[0])\r\nstrlcpy(data, CONFIG_CMDLINE, COMMAND_LINE_SIZE);\r\n#endif\r\n#endif\r\npr_debug("Command line is: %s\n", (char*)data);\r\nreturn 1;\r\n}\r\nvoid __init __weak early_init_dt_add_memory_arch(u64 base, u64 size)\r\n{\r\nconst u64 phys_offset = MIN_MEMBLOCK_ADDR;\r\nif (!PAGE_ALIGNED(base)) {\r\nif (size < PAGE_SIZE - (base & ~PAGE_MASK)) {\r\npr_warn("Ignoring memory block 0x%llx - 0x%llx\n",\r\nbase, base + size);\r\nreturn;\r\n}\r\nsize -= PAGE_SIZE - (base & ~PAGE_MASK);\r\nbase = PAGE_ALIGN(base);\r\n}\r\nsize &= PAGE_MASK;\r\nif (base > MAX_MEMBLOCK_ADDR) {\r\npr_warning("Ignoring memory block 0x%llx - 0x%llx\n",\r\nbase, base + size);\r\nreturn;\r\n}\r\nif (base + size - 1 > MAX_MEMBLOCK_ADDR) {\r\npr_warning("Ignoring memory range 0x%llx - 0x%llx\n",\r\n((u64)MAX_MEMBLOCK_ADDR) + 1, base + size);\r\nsize = MAX_MEMBLOCK_ADDR - base + 1;\r\n}\r\nif (base + size < phys_offset) {\r\npr_warning("Ignoring memory block 0x%llx - 0x%llx\n",\r\nbase, base + size);\r\nreturn;\r\n}\r\nif (base < phys_offset) {\r\npr_warning("Ignoring memory range 0x%llx - 0x%llx\n",\r\nbase, phys_offset);\r\nsize -= phys_offset - base;\r\nbase = phys_offset;\r\n}\r\nmemblock_add(base, size);\r\n}\r\nint __init __weak early_init_dt_mark_hotplug_memory_arch(u64 base, u64 size)\r\n{\r\nreturn memblock_mark_hotplug(base, size);\r\n}\r\nint __init __weak early_init_dt_reserve_memory_arch(phys_addr_t base,\r\nphys_addr_t size, bool nomap)\r\n{\r\nif (nomap)\r\nreturn memblock_remove(base, size);\r\nreturn memblock_reserve(base, size);\r\n}\r\nvoid * __init __weak early_init_dt_alloc_memory_arch(u64 size, u64 align)\r\n{\r\nreturn __va(memblock_alloc(size, align));\r\n}\r\nvoid __init __weak early_init_dt_add_memory_arch(u64 base, u64 size)\r\n{\r\nWARN_ON(1);\r\n}\r\nint __init __weak early_init_dt_mark_hotplug_memory_arch(u64 base, u64 size)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nint __init __weak early_init_dt_reserve_memory_arch(phys_addr_t base,\r\nphys_addr_t size, bool nomap)\r\n{\r\npr_err("Reserved memory not supported, ignoring range %pa - %pa%s\n",\r\n&base, &size, nomap ? " (nomap)" : "");\r\nreturn -ENOSYS;\r\n}\r\nvoid * __init __weak early_init_dt_alloc_memory_arch(u64 size, u64 align)\r\n{\r\nWARN_ON(1);\r\nreturn NULL;\r\n}\r\nbool __init early_init_dt_verify(void *params)\r\n{\r\nif (!params)\r\nreturn false;\r\nif (fdt_check_header(params))\r\nreturn false;\r\ninitial_boot_params = params;\r\nof_fdt_crc32 = crc32_be(~0, initial_boot_params,\r\nfdt_totalsize(initial_boot_params));\r\nreturn true;\r\n}\r\nvoid __init early_init_dt_scan_nodes(void)\r\n{\r\nof_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line);\r\nof_scan_flat_dt(early_init_dt_scan_root, NULL);\r\nof_scan_flat_dt(early_init_dt_scan_memory, NULL);\r\n}\r\nbool __init early_init_dt_scan(void *params)\r\n{\r\nbool status;\r\nstatus = early_init_dt_verify(params);\r\nif (!status)\r\nreturn false;\r\nearly_init_dt_scan_nodes();\r\nreturn true;\r\n}\r\nvoid __init unflatten_device_tree(void)\r\n{\r\n__unflatten_device_tree(initial_boot_params, NULL, &of_root,\r\nearly_init_dt_alloc_memory_arch, false);\r\nof_alias_scan(early_init_dt_alloc_memory_arch);\r\nunittest_unflatten_overlay_base();\r\n}\r\nvoid __init unflatten_and_copy_device_tree(void)\r\n{\r\nint size;\r\nvoid *dt;\r\nif (!initial_boot_params) {\r\npr_warn("No valid device tree found, continuing without\n");\r\nreturn;\r\n}\r\nsize = fdt_totalsize(initial_boot_params);\r\ndt = early_init_dt_alloc_memory_arch(size,\r\nroundup_pow_of_two(FDT_V17_SIZE));\r\nif (dt) {\r\nmemcpy(dt, initial_boot_params, size);\r\ninitial_boot_params = dt;\r\n}\r\nunflatten_device_tree();\r\n}\r\nstatic ssize_t of_fdt_raw_read(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nmemcpy(buf, initial_boot_params + off, count);\r\nreturn count;\r\n}\r\nstatic int __init of_fdt_raw_init(void)\r\n{\r\nstatic struct bin_attribute of_fdt_raw_attr =\r\n__BIN_ATTR(fdt, S_IRUSR, of_fdt_raw_read, NULL, 0);\r\nif (!initial_boot_params)\r\nreturn 0;\r\nif (of_fdt_crc32 != crc32_be(~0, initial_boot_params,\r\nfdt_totalsize(initial_boot_params))) {\r\npr_warn("not creating '/sys/firmware/fdt': CRC check failed\n");\r\nreturn 0;\r\n}\r\nof_fdt_raw_attr.size = fdt_totalsize(initial_boot_params);\r\nreturn sysfs_create_bin_file(firmware_kobj, &of_fdt_raw_attr);\r\n}
