int\r\nbttv_risc_packed(struct bttv *btv, struct btcx_riscmem *risc,\r\nstruct scatterlist *sglist,\r\nunsigned int offset, unsigned int bpl,\r\nunsigned int padding, unsigned int skip_lines,\r\nunsigned int store_lines)\r\n{\r\nu32 instructions,line,todo;\r\nstruct scatterlist *sg;\r\n__le32 *rp;\r\nint rc;\r\ninstructions = skip_lines * 4;\r\ninstructions += (1 + ((bpl + padding) * store_lines)\r\n/ PAGE_SIZE + store_lines) * 8;\r\ninstructions += 2 * 8;\r\nif ((rc = btcx_riscmem_alloc(btv->c.pci,risc,instructions)) < 0)\r\nreturn rc;\r\nrp = risc->cpu;\r\n*(rp++) = cpu_to_le32(BT848_RISC_SYNC|BT848_FIFO_STATUS_FM1);\r\n*(rp++) = cpu_to_le32(0);\r\nwhile (skip_lines-- > 0) {\r\n*(rp++) = cpu_to_le32(BT848_RISC_SKIP | BT848_RISC_SOL |\r\nBT848_RISC_EOL | bpl);\r\n}\r\nsg = sglist;\r\nfor (line = 0; line < store_lines; line++) {\r\nif ((btv->opt_vcr_hack) &&\r\n(line >= (store_lines - VCR_HACK_LINES)))\r\ncontinue;\r\nwhile (offset && offset >= sg_dma_len(sg)) {\r\noffset -= sg_dma_len(sg);\r\nsg = sg_next(sg);\r\n}\r\nif (bpl <= sg_dma_len(sg)-offset) {\r\n*(rp++)=cpu_to_le32(BT848_RISC_WRITE|BT848_RISC_SOL|\r\nBT848_RISC_EOL|bpl);\r\n*(rp++)=cpu_to_le32(sg_dma_address(sg)+offset);\r\noffset+=bpl;\r\n} else {\r\ntodo = bpl;\r\n*(rp++)=cpu_to_le32(BT848_RISC_WRITE|BT848_RISC_SOL|\r\n(sg_dma_len(sg)-offset));\r\n*(rp++)=cpu_to_le32(sg_dma_address(sg)+offset);\r\ntodo -= (sg_dma_len(sg)-offset);\r\noffset = 0;\r\nsg = sg_next(sg);\r\nwhile (todo > sg_dma_len(sg)) {\r\n*(rp++)=cpu_to_le32(BT848_RISC_WRITE|\r\nsg_dma_len(sg));\r\n*(rp++)=cpu_to_le32(sg_dma_address(sg));\r\ntodo -= sg_dma_len(sg);\r\nsg = sg_next(sg);\r\n}\r\n*(rp++)=cpu_to_le32(BT848_RISC_WRITE|BT848_RISC_EOL|\r\ntodo);\r\n*(rp++)=cpu_to_le32(sg_dma_address(sg));\r\noffset += todo;\r\n}\r\noffset += padding;\r\n}\r\nrisc->jmp = rp;\r\nBUG_ON((risc->jmp - risc->cpu + 2) * sizeof(*risc->cpu) > risc->size);\r\nreturn 0;\r\n}\r\nstatic int\r\nbttv_risc_planar(struct bttv *btv, struct btcx_riscmem *risc,\r\nstruct scatterlist *sglist,\r\nunsigned int yoffset, unsigned int ybpl,\r\nunsigned int ypadding, unsigned int ylines,\r\nunsigned int uoffset, unsigned int voffset,\r\nunsigned int hshift, unsigned int vshift,\r\nunsigned int cpadding)\r\n{\r\nunsigned int instructions,line,todo,ylen,chroma;\r\n__le32 *rp;\r\nu32 ri;\r\nstruct scatterlist *ysg;\r\nstruct scatterlist *usg;\r\nstruct scatterlist *vsg;\r\nint topfield = (0 == yoffset);\r\nint rc;\r\ninstructions = ((3 + (ybpl + ypadding) * ylines * 2)\r\n/ PAGE_SIZE) + ylines;\r\ninstructions += 2;\r\nif ((rc = btcx_riscmem_alloc(btv->c.pci,risc,instructions*4*5)) < 0)\r\nreturn rc;\r\nrp = risc->cpu;\r\n*(rp++) = cpu_to_le32(BT848_RISC_SYNC|BT848_FIFO_STATUS_FM3);\r\n*(rp++) = cpu_to_le32(0);\r\nysg = sglist;\r\nusg = sglist;\r\nvsg = sglist;\r\nfor (line = 0; line < ylines; line++) {\r\nif ((btv->opt_vcr_hack) &&\r\n(line >= (ylines - VCR_HACK_LINES)))\r\ncontinue;\r\nswitch (vshift) {\r\ncase 0:\r\nchroma = 1;\r\nbreak;\r\ncase 1:\r\nif (topfield)\r\nchroma = ((line & 1) == 0);\r\nelse\r\nchroma = ((line & 1) == 1);\r\nbreak;\r\ncase 2:\r\nif (topfield)\r\nchroma = ((line & 3) == 0);\r\nelse\r\nchroma = ((line & 3) == 2);\r\nbreak;\r\ndefault:\r\nchroma = 0;\r\nbreak;\r\n}\r\nfor (todo = ybpl; todo > 0; todo -= ylen) {\r\nwhile (yoffset && yoffset >= sg_dma_len(ysg)) {\r\nyoffset -= sg_dma_len(ysg);\r\nysg = sg_next(ysg);\r\n}\r\nwhile (uoffset && uoffset >= sg_dma_len(usg)) {\r\nuoffset -= sg_dma_len(usg);\r\nusg = sg_next(usg);\r\n}\r\nwhile (voffset && voffset >= sg_dma_len(vsg)) {\r\nvoffset -= sg_dma_len(vsg);\r\nvsg = sg_next(vsg);\r\n}\r\nylen = todo;\r\nif (yoffset + ylen > sg_dma_len(ysg))\r\nylen = sg_dma_len(ysg) - yoffset;\r\nif (chroma) {\r\nif (uoffset + (ylen>>hshift) > sg_dma_len(usg))\r\nylen = (sg_dma_len(usg) - uoffset) << hshift;\r\nif (voffset + (ylen>>hshift) > sg_dma_len(vsg))\r\nylen = (sg_dma_len(vsg) - voffset) << hshift;\r\nri = BT848_RISC_WRITE123;\r\n} else {\r\nri = BT848_RISC_WRITE1S23;\r\n}\r\nif (ybpl == todo)\r\nri |= BT848_RISC_SOL;\r\nif (ylen == todo)\r\nri |= BT848_RISC_EOL;\r\n*(rp++)=cpu_to_le32(ri | ylen);\r\n*(rp++)=cpu_to_le32(((ylen >> hshift) << 16) |\r\n(ylen >> hshift));\r\n*(rp++)=cpu_to_le32(sg_dma_address(ysg)+yoffset);\r\nyoffset += ylen;\r\nif (chroma) {\r\n*(rp++)=cpu_to_le32(sg_dma_address(usg)+uoffset);\r\nuoffset += ylen >> hshift;\r\n*(rp++)=cpu_to_le32(sg_dma_address(vsg)+voffset);\r\nvoffset += ylen >> hshift;\r\n}\r\n}\r\nyoffset += ypadding;\r\nif (chroma) {\r\nuoffset += cpadding;\r\nvoffset += cpadding;\r\n}\r\n}\r\nrisc->jmp = rp;\r\nBUG_ON((risc->jmp - risc->cpu + 2) * sizeof(*risc->cpu) > risc->size);\r\nreturn 0;\r\n}\r\nstatic int\r\nbttv_risc_overlay(struct bttv *btv, struct btcx_riscmem *risc,\r\nconst struct bttv_format *fmt, struct bttv_overlay *ov,\r\nint skip_even, int skip_odd)\r\n{\r\nint dwords, rc, line, maxy, start, end;\r\nunsigned skip, nskips;\r\nstruct btcx_skiplist *skips;\r\n__le32 *rp;\r\nu32 ri,ra;\r\nu32 addr;\r\nif (NULL == (skips = kmalloc(sizeof(*skips) * ov->nclips,GFP_KERNEL)))\r\nreturn -ENOMEM;\r\ndwords = (3 * ov->nclips + 2) *\r\n((skip_even || skip_odd) ? (ov->w.height+1)>>1 : ov->w.height);\r\ndwords += 4;\r\nif ((rc = btcx_riscmem_alloc(btv->c.pci,risc,dwords*4)) < 0) {\r\nkfree(skips);\r\nreturn rc;\r\n}\r\nrp = risc->cpu;\r\n*(rp++) = cpu_to_le32(BT848_RISC_SYNC|BT848_FIFO_STATUS_FM1);\r\n*(rp++) = cpu_to_le32(0);\r\naddr = (unsigned long)btv->fbuf.base;\r\naddr += btv->fbuf.fmt.bytesperline * ov->w.top;\r\naddr += (fmt->depth >> 3) * ov->w.left;\r\nfor (maxy = -1, line = 0; line < ov->w.height;\r\nline++, addr += btv->fbuf.fmt.bytesperline) {\r\nif ((btv->opt_vcr_hack) &&\r\n(line >= (ov->w.height - VCR_HACK_LINES)))\r\ncontinue;\r\nif ((line%2) == 0 && skip_even)\r\ncontinue;\r\nif ((line%2) == 1 && skip_odd)\r\ncontinue;\r\nif (line > maxy)\r\nbtcx_calc_skips(line, ov->w.width, &maxy,\r\nskips, &nskips, ov->clips, ov->nclips);\r\nfor (start = 0, skip = 0; start < ov->w.width; start = end) {\r\nif (skip >= nskips) {\r\nri = BT848_RISC_WRITE;\r\nend = ov->w.width;\r\n} else if (start < skips[skip].start) {\r\nri = BT848_RISC_WRITE;\r\nend = skips[skip].start;\r\n} else {\r\nri = BT848_RISC_SKIP;\r\nend = skips[skip].end;\r\nskip++;\r\n}\r\nif (BT848_RISC_WRITE == ri)\r\nra = addr + (fmt->depth>>3)*start;\r\nelse\r\nra = 0;\r\nif (0 == start)\r\nri |= BT848_RISC_SOL;\r\nif (ov->w.width == end)\r\nri |= BT848_RISC_EOL;\r\nri |= (fmt->depth>>3) * (end-start);\r\n*(rp++)=cpu_to_le32(ri);\r\nif (0 != ra)\r\n*(rp++)=cpu_to_le32(ra);\r\n}\r\n}\r\nrisc->jmp = rp;\r\nBUG_ON((risc->jmp - risc->cpu + 2) * sizeof(*risc->cpu) > risc->size);\r\nkfree(skips);\r\nreturn 0;\r\n}\r\nstatic void\r\nbttv_calc_geo_old(struct bttv *btv, struct bttv_geometry *geo,\r\nint width, int height, int interleaved,\r\nconst struct bttv_tvnorm *tvnorm)\r\n{\r\nu32 xsf, sr;\r\nint vdelay;\r\nint swidth = tvnorm->swidth;\r\nint totalwidth = tvnorm->totalwidth;\r\nint scaledtwidth = tvnorm->scaledtwidth;\r\nif (btv->input == btv->dig) {\r\nswidth = 720;\r\ntotalwidth = 858;\r\nscaledtwidth = 858;\r\n}\r\nvdelay = tvnorm->vdelay;\r\nxsf = (width*scaledtwidth)/swidth;\r\ngeo->hscale = ((totalwidth*4096UL)/xsf-4096);\r\ngeo->hdelay = tvnorm->hdelayx1;\r\ngeo->hdelay = (geo->hdelay*width)/swidth;\r\ngeo->hdelay &= 0x3fe;\r\nsr = ((tvnorm->sheight >> (interleaved?0:1))*512)/height - 512;\r\ngeo->vscale = (0x10000UL-sr) & 0x1fff;\r\ngeo->crop = ((width>>8)&0x03) | ((geo->hdelay>>6)&0x0c) |\r\n((tvnorm->sheight>>4)&0x30) | ((vdelay>>2)&0xc0);\r\ngeo->vscale |= interleaved ? (BT848_VSCALE_INT<<8) : 0;\r\ngeo->vdelay = vdelay;\r\ngeo->width = width;\r\ngeo->sheight = tvnorm->sheight;\r\ngeo->vtotal = tvnorm->vtotal;\r\nif (btv->opt_combfilter) {\r\ngeo->vtc = (width < 193) ? 2 : ((width < 385) ? 1 : 0);\r\ngeo->comb = (width < 769) ? 1 : 0;\r\n} else {\r\ngeo->vtc = 0;\r\ngeo->comb = 0;\r\n}\r\n}\r\nstatic void\r\nbttv_calc_geo (struct bttv * btv,\r\nstruct bttv_geometry * geo,\r\nunsigned int width,\r\nunsigned int height,\r\nint both_fields,\r\nconst struct bttv_tvnorm * tvnorm,\r\nconst struct v4l2_rect * crop)\r\n{\r\nunsigned int c_width;\r\nunsigned int c_height;\r\nu32 sr;\r\nif ((crop->left == tvnorm->cropcap.defrect.left\r\n&& crop->top == tvnorm->cropcap.defrect.top\r\n&& crop->width == tvnorm->cropcap.defrect.width\r\n&& crop->height == tvnorm->cropcap.defrect.height\r\n&& width <= tvnorm->swidth )\r\n|| btv->input == btv->dig) {\r\nbttv_calc_geo_old(btv, geo, width, height,\r\nboth_fields, tvnorm);\r\nreturn;\r\n}\r\nc_width = min((unsigned int) crop->width, width * 16);\r\nc_height = min((unsigned int) crop->height, height * 16);\r\ngeo->width = width;\r\ngeo->hscale = (c_width * 4096U + (width >> 1)) / width - 4096;\r\ngeo->hdelay = ((crop->left * width + c_width) / c_width) & ~1;\r\ngeo->sheight = c_height;\r\ngeo->vdelay = crop->top - tvnorm->cropcap.bounds.top + MIN_VDELAY;\r\nsr = c_height >> !both_fields;\r\nsr = (sr * 512U + (height >> 1)) / height - 512;\r\ngeo->vscale = (0x10000UL - sr) & 0x1fff;\r\ngeo->vscale |= both_fields ? (BT848_VSCALE_INT << 8) : 0;\r\ngeo->vtotal = tvnorm->vtotal;\r\ngeo->crop = (((geo->width >> 8) & 0x03) |\r\n((geo->hdelay >> 6) & 0x0c) |\r\n((geo->sheight >> 4) & 0x30) |\r\n((geo->vdelay >> 2) & 0xc0));\r\nif (btv->opt_combfilter) {\r\ngeo->vtc = (width < 193) ? 2 : ((width < 385) ? 1 : 0);\r\ngeo->comb = (width < 769) ? 1 : 0;\r\n} else {\r\ngeo->vtc = 0;\r\ngeo->comb = 0;\r\n}\r\n}\r\nstatic void\r\nbttv_apply_geo(struct bttv *btv, struct bttv_geometry *geo, int odd)\r\n{\r\nint off = odd ? 0x80 : 0x00;\r\nif (geo->comb)\r\nbtor(BT848_VSCALE_COMB, BT848_E_VSCALE_HI+off);\r\nelse\r\nbtand(~BT848_VSCALE_COMB, BT848_E_VSCALE_HI+off);\r\nbtwrite(geo->vtc, BT848_E_VTC+off);\r\nbtwrite(geo->hscale >> 8, BT848_E_HSCALE_HI+off);\r\nbtwrite(geo->hscale & 0xff, BT848_E_HSCALE_LO+off);\r\nbtaor((geo->vscale>>8), 0xe0, BT848_E_VSCALE_HI+off);\r\nbtwrite(geo->vscale & 0xff, BT848_E_VSCALE_LO+off);\r\nbtwrite(geo->width & 0xff, BT848_E_HACTIVE_LO+off);\r\nbtwrite(geo->hdelay & 0xff, BT848_E_HDELAY_LO+off);\r\nbtwrite(geo->sheight & 0xff, BT848_E_VACTIVE_LO+off);\r\nbtwrite(geo->vdelay & 0xff, BT848_E_VDELAY_LO+off);\r\nbtwrite(geo->crop, BT848_E_CROP+off);\r\nbtwrite(geo->vtotal>>8, BT848_VTOTAL_HI);\r\nbtwrite(geo->vtotal & 0xff, BT848_VTOTAL_LO);\r\n}\r\nvoid\r\nbttv_set_dma(struct bttv *btv, int override)\r\n{\r\nunsigned long cmd;\r\nint capctl;\r\nbtv->cap_ctl = 0;\r\nif (NULL != btv->curr.top) btv->cap_ctl |= 0x02;\r\nif (NULL != btv->curr.bottom) btv->cap_ctl |= 0x01;\r\nif (NULL != btv->cvbi) btv->cap_ctl |= 0x0c;\r\ncapctl = 0;\r\ncapctl |= (btv->cap_ctl & 0x03) ? 0x03 : 0x00;\r\ncapctl |= (btv->cap_ctl & 0x0c) ? 0x0c : 0x00;\r\ncapctl |= override;\r\nd2printk("%d: capctl=%x lirq=%d top=%08llx/%08llx even=%08llx/%08llx\n",\r\nbtv->c.nr,capctl,btv->loop_irq,\r\nbtv->cvbi ? (unsigned long long)btv->cvbi->top.dma : 0,\r\nbtv->curr.top ? (unsigned long long)btv->curr.top->top.dma : 0,\r\nbtv->cvbi ? (unsigned long long)btv->cvbi->bottom.dma : 0,\r\nbtv->curr.bottom ? (unsigned long long)btv->curr.bottom->bottom.dma : 0);\r\ncmd = BT848_RISC_JUMP;\r\nif (btv->loop_irq) {\r\ncmd |= BT848_RISC_IRQ;\r\ncmd |= (btv->loop_irq & 0x0f) << 16;\r\ncmd |= (~btv->loop_irq & 0x0f) << 20;\r\n}\r\nif (btv->curr.frame_irq || btv->loop_irq || btv->cvbi) {\r\nmod_timer(&btv->timeout, jiffies+BTTV_TIMEOUT);\r\n} else {\r\ndel_timer(&btv->timeout);\r\n}\r\nbtv->main.cpu[RISC_SLOT_LOOP] = cpu_to_le32(cmd);\r\nbtaor(capctl, ~0x0f, BT848_CAP_CTL);\r\nif (capctl) {\r\nif (btv->dma_on)\r\nreturn;\r\nbtwrite(btv->main.dma, BT848_RISC_STRT_ADD);\r\nbtor(3, BT848_GPIO_DMA_CTL);\r\nbtv->dma_on = 1;\r\n} else {\r\nif (!btv->dma_on)\r\nreturn;\r\nbtand(~3, BT848_GPIO_DMA_CTL);\r\nbtv->dma_on = 0;\r\n}\r\nreturn;\r\n}\r\nint\r\nbttv_risc_init_main(struct bttv *btv)\r\n{\r\nint rc;\r\nif ((rc = btcx_riscmem_alloc(btv->c.pci,&btv->main,PAGE_SIZE)) < 0)\r\nreturn rc;\r\ndprintk("%d: risc main @ %08llx\n",\r\nbtv->c.nr, (unsigned long long)btv->main.dma);\r\nbtv->main.cpu[0] = cpu_to_le32(BT848_RISC_SYNC | BT848_RISC_RESYNC |\r\nBT848_FIFO_STATUS_VRE);\r\nbtv->main.cpu[1] = cpu_to_le32(0);\r\nbtv->main.cpu[2] = cpu_to_le32(BT848_RISC_JUMP);\r\nbtv->main.cpu[3] = cpu_to_le32(btv->main.dma + (4<<2));\r\nbtv->main.cpu[4] = cpu_to_le32(BT848_RISC_JUMP);\r\nbtv->main.cpu[5] = cpu_to_le32(btv->main.dma + (6<<2));\r\nbtv->main.cpu[6] = cpu_to_le32(BT848_RISC_JUMP);\r\nbtv->main.cpu[7] = cpu_to_le32(btv->main.dma + (8<<2));\r\nbtv->main.cpu[8] = cpu_to_le32(BT848_RISC_SYNC | BT848_RISC_RESYNC |\r\nBT848_FIFO_STATUS_VRO);\r\nbtv->main.cpu[9] = cpu_to_le32(0);\r\nbtv->main.cpu[10] = cpu_to_le32(BT848_RISC_JUMP);\r\nbtv->main.cpu[11] = cpu_to_le32(btv->main.dma + (12<<2));\r\nbtv->main.cpu[12] = cpu_to_le32(BT848_RISC_JUMP);\r\nbtv->main.cpu[13] = cpu_to_le32(btv->main.dma + (14<<2));\r\nbtv->main.cpu[14] = cpu_to_le32(BT848_RISC_JUMP);\r\nbtv->main.cpu[15] = cpu_to_le32(btv->main.dma + (0<<2));\r\nreturn 0;\r\n}\r\nint\r\nbttv_risc_hook(struct bttv *btv, int slot, struct btcx_riscmem *risc,\r\nint irqflags)\r\n{\r\nunsigned long cmd;\r\nunsigned long next = btv->main.dma + ((slot+2) << 2);\r\nif (NULL == risc) {\r\nd2printk("%d: risc=%p slot[%d]=NULL\n", btv->c.nr, risc, slot);\r\nbtv->main.cpu[slot+1] = cpu_to_le32(next);\r\n} else {\r\nd2printk("%d: risc=%p slot[%d]=%08llx irq=%d\n",\r\nbtv->c.nr, risc, slot,\r\n(unsigned long long)risc->dma, irqflags);\r\ncmd = BT848_RISC_JUMP;\r\nif (irqflags) {\r\ncmd |= BT848_RISC_IRQ;\r\ncmd |= (irqflags & 0x0f) << 16;\r\ncmd |= (~irqflags & 0x0f) << 20;\r\n}\r\nrisc->jmp[0] = cpu_to_le32(cmd);\r\nrisc->jmp[1] = cpu_to_le32(next);\r\nbtv->main.cpu[slot+1] = cpu_to_le32(risc->dma);\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nbttv_dma_free(struct videobuf_queue *q,struct bttv *btv, struct bttv_buffer *buf)\r\n{\r\nstruct videobuf_dmabuf *dma=videobuf_to_dma(&buf->vb);\r\nBUG_ON(in_interrupt());\r\nvideobuf_waiton(q, &buf->vb, 0, 0);\r\nvideobuf_dma_unmap(q->dev, dma);\r\nvideobuf_dma_free(dma);\r\nbtcx_riscmem_free(btv->c.pci,&buf->bottom);\r\nbtcx_riscmem_free(btv->c.pci,&buf->top);\r\nbuf->vb.state = VIDEOBUF_NEEDS_INIT;\r\n}\r\nint\r\nbttv_buffer_activate_vbi(struct bttv *btv,\r\nstruct bttv_buffer *vbi)\r\n{\r\nstruct btcx_riscmem *top;\r\nstruct btcx_riscmem *bottom;\r\nint top_irq_flags;\r\nint bottom_irq_flags;\r\ntop = NULL;\r\nbottom = NULL;\r\ntop_irq_flags = 0;\r\nbottom_irq_flags = 0;\r\nif (vbi) {\r\nunsigned int crop, vdelay;\r\nvbi->vb.state = VIDEOBUF_ACTIVE;\r\nlist_del(&vbi->vb.queue);\r\ncrop = btread(BT848_E_CROP);\r\nvdelay = btread(BT848_E_VDELAY_LO) + ((crop & 0xc0) << 2);\r\nif (vbi->geo.vdelay > vdelay) {\r\nvdelay = vbi->geo.vdelay & 0xfe;\r\ncrop = (crop & 0x3f) | ((vbi->geo.vdelay >> 2) & 0xc0);\r\nbtwrite(vdelay, BT848_E_VDELAY_LO);\r\nbtwrite(crop, BT848_E_CROP);\r\nbtwrite(vdelay, BT848_O_VDELAY_LO);\r\nbtwrite(crop, BT848_O_CROP);\r\n}\r\nif (vbi->vbi_count[0] > 0) {\r\ntop = &vbi->top;\r\ntop_irq_flags = 4;\r\n}\r\nif (vbi->vbi_count[1] > 0) {\r\ntop_irq_flags = 0;\r\nbottom = &vbi->bottom;\r\nbottom_irq_flags = 4;\r\n}\r\n}\r\nbttv_risc_hook(btv, RISC_SLOT_O_VBI, top, top_irq_flags);\r\nbttv_risc_hook(btv, RISC_SLOT_E_VBI, bottom, bottom_irq_flags);\r\nreturn 0;\r\n}\r\nint\r\nbttv_buffer_activate_video(struct bttv *btv,\r\nstruct bttv_buffer_set *set)\r\n{\r\nif (NULL != set->top && NULL != set->bottom) {\r\nif (set->top == set->bottom) {\r\nset->top->vb.state = VIDEOBUF_ACTIVE;\r\nif (set->top->vb.queue.next)\r\nlist_del(&set->top->vb.queue);\r\n} else {\r\nset->top->vb.state = VIDEOBUF_ACTIVE;\r\nset->bottom->vb.state = VIDEOBUF_ACTIVE;\r\nif (set->top->vb.queue.next)\r\nlist_del(&set->top->vb.queue);\r\nif (set->bottom->vb.queue.next)\r\nlist_del(&set->bottom->vb.queue);\r\n}\r\nbttv_apply_geo(btv, &set->top->geo, 1);\r\nbttv_apply_geo(btv, &set->bottom->geo,0);\r\nbttv_risc_hook(btv, RISC_SLOT_O_FIELD, &set->top->top,\r\nset->top_irq);\r\nbttv_risc_hook(btv, RISC_SLOT_E_FIELD, &set->bottom->bottom,\r\nset->frame_irq);\r\nbtaor((set->top->btformat & 0xf0) | (set->bottom->btformat & 0x0f),\r\n~0xff, BT848_COLOR_FMT);\r\nbtaor((set->top->btswap & 0x0a) | (set->bottom->btswap & 0x05),\r\n~0x0f, BT848_COLOR_CTL);\r\n} else if (NULL != set->top) {\r\nset->top->vb.state = VIDEOBUF_ACTIVE;\r\nif (set->top->vb.queue.next)\r\nlist_del(&set->top->vb.queue);\r\nbttv_apply_geo(btv, &set->top->geo,1);\r\nbttv_apply_geo(btv, &set->top->geo,0);\r\nbttv_risc_hook(btv, RISC_SLOT_O_FIELD, &set->top->top,\r\nset->frame_irq);\r\nbttv_risc_hook(btv, RISC_SLOT_E_FIELD, NULL, 0);\r\nbtaor(set->top->btformat & 0xff, ~0xff, BT848_COLOR_FMT);\r\nbtaor(set->top->btswap & 0x0f, ~0x0f, BT848_COLOR_CTL);\r\n} else if (NULL != set->bottom) {\r\nset->bottom->vb.state = VIDEOBUF_ACTIVE;\r\nif (set->bottom->vb.queue.next)\r\nlist_del(&set->bottom->vb.queue);\r\nbttv_apply_geo(btv, &set->bottom->geo,1);\r\nbttv_apply_geo(btv, &set->bottom->geo,0);\r\nbttv_risc_hook(btv, RISC_SLOT_O_FIELD, NULL, 0);\r\nbttv_risc_hook(btv, RISC_SLOT_E_FIELD, &set->bottom->bottom,\r\nset->frame_irq);\r\nbtaor(set->bottom->btformat & 0xff, ~0xff, BT848_COLOR_FMT);\r\nbtaor(set->bottom->btswap & 0x0f, ~0x0f, BT848_COLOR_CTL);\r\n} else {\r\nbttv_risc_hook(btv, RISC_SLOT_O_FIELD, NULL, 0);\r\nbttv_risc_hook(btv, RISC_SLOT_E_FIELD, NULL, 0);\r\n}\r\nreturn 0;\r\n}\r\nint\r\nbttv_buffer_risc(struct bttv *btv, struct bttv_buffer *buf)\r\n{\r\nconst struct bttv_tvnorm *tvnorm = bttv_tvnorms + buf->tvnorm;\r\nstruct videobuf_dmabuf *dma=videobuf_to_dma(&buf->vb);\r\ndprintk("%d: buffer field: %s format: %s size: %dx%d\n",\r\nbtv->c.nr, v4l2_field_names[buf->vb.field],\r\nbuf->fmt->name, buf->vb.width, buf->vb.height);\r\nif (buf->fmt->flags & FORMAT_FLAGS_PACKED) {\r\nint bpl = (buf->fmt->depth >> 3) * buf->vb.width;\r\nint bpf = bpl * (buf->vb.height >> 1);\r\nbttv_calc_geo(btv,&buf->geo,buf->vb.width,buf->vb.height,\r\nV4L2_FIELD_HAS_BOTH(buf->vb.field),\r\ntvnorm,&buf->crop);\r\nswitch (buf->vb.field) {\r\ncase V4L2_FIELD_TOP:\r\nbttv_risc_packed(btv,&buf->top,dma->sglist,\r\n0,bpl,\r\n0, 0,\r\nbuf->vb.height);\r\nbreak;\r\ncase V4L2_FIELD_BOTTOM:\r\nbttv_risc_packed(btv,&buf->bottom,dma->sglist,\r\n0,bpl,0,0,buf->vb.height);\r\nbreak;\r\ncase V4L2_FIELD_INTERLACED:\r\nbttv_risc_packed(btv,&buf->top,dma->sglist,\r\n0,bpl,bpl,0,buf->vb.height >> 1);\r\nbttv_risc_packed(btv,&buf->bottom,dma->sglist,\r\nbpl,bpl,bpl,0,buf->vb.height >> 1);\r\nbreak;\r\ncase V4L2_FIELD_SEQ_TB:\r\nbttv_risc_packed(btv,&buf->top,dma->sglist,\r\n0,bpl,0,0,buf->vb.height >> 1);\r\nbttv_risc_packed(btv,&buf->bottom,dma->sglist,\r\nbpf,bpl,0,0,buf->vb.height >> 1);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nif (buf->fmt->flags & FORMAT_FLAGS_PLANAR) {\r\nint uoffset, voffset;\r\nint ypadding, cpadding, lines;\r\nuoffset = buf->vb.width * buf->vb.height;\r\nvoffset = buf->vb.width * buf->vb.height;\r\nif (buf->fmt->flags & FORMAT_FLAGS_CrCb) {\r\nuoffset >>= buf->fmt->hshift;\r\nuoffset >>= buf->fmt->vshift;\r\nuoffset += voffset;\r\n} else {\r\nvoffset >>= buf->fmt->hshift;\r\nvoffset >>= buf->fmt->vshift;\r\nvoffset += uoffset;\r\n}\r\nswitch (buf->vb.field) {\r\ncase V4L2_FIELD_TOP:\r\nbttv_calc_geo(btv,&buf->geo,buf->vb.width,\r\nbuf->vb.height, 0,\r\ntvnorm,&buf->crop);\r\nbttv_risc_planar(btv, &buf->top, dma->sglist,\r\n0,buf->vb.width,0,buf->vb.height,\r\nuoffset,voffset,buf->fmt->hshift,\r\nbuf->fmt->vshift,0);\r\nbreak;\r\ncase V4L2_FIELD_BOTTOM:\r\nbttv_calc_geo(btv,&buf->geo,buf->vb.width,\r\nbuf->vb.height,0,\r\ntvnorm,&buf->crop);\r\nbttv_risc_planar(btv, &buf->bottom, dma->sglist,\r\n0,buf->vb.width,0,buf->vb.height,\r\nuoffset,voffset,buf->fmt->hshift,\r\nbuf->fmt->vshift,0);\r\nbreak;\r\ncase V4L2_FIELD_INTERLACED:\r\nbttv_calc_geo(btv,&buf->geo,buf->vb.width,\r\nbuf->vb.height,1,\r\ntvnorm,&buf->crop);\r\nlines = buf->vb.height >> 1;\r\nypadding = buf->vb.width;\r\ncpadding = buf->vb.width >> buf->fmt->hshift;\r\nbttv_risc_planar(btv,&buf->top,\r\ndma->sglist,\r\n0,buf->vb.width,ypadding,lines,\r\nuoffset,voffset,\r\nbuf->fmt->hshift,\r\nbuf->fmt->vshift,\r\ncpadding);\r\nbttv_risc_planar(btv,&buf->bottom,\r\ndma->sglist,\r\nypadding,buf->vb.width,ypadding,lines,\r\nuoffset+cpadding,\r\nvoffset+cpadding,\r\nbuf->fmt->hshift,\r\nbuf->fmt->vshift,\r\ncpadding);\r\nbreak;\r\ncase V4L2_FIELD_SEQ_TB:\r\nbttv_calc_geo(btv,&buf->geo,buf->vb.width,\r\nbuf->vb.height,1,\r\ntvnorm,&buf->crop);\r\nlines = buf->vb.height >> 1;\r\nypadding = buf->vb.width;\r\ncpadding = buf->vb.width >> buf->fmt->hshift;\r\nbttv_risc_planar(btv,&buf->top,\r\ndma->sglist,\r\n0,buf->vb.width,0,lines,\r\nuoffset >> 1,\r\nvoffset >> 1,\r\nbuf->fmt->hshift,\r\nbuf->fmt->vshift,\r\n0);\r\nbttv_risc_planar(btv,&buf->bottom,\r\ndma->sglist,\r\nlines * ypadding,buf->vb.width,0,lines,\r\nlines * ypadding + (uoffset >> 1),\r\nlines * ypadding + (voffset >> 1),\r\nbuf->fmt->hshift,\r\nbuf->fmt->vshift,\r\n0);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nif (buf->fmt->flags & FORMAT_FLAGS_RAW) {\r\nbuf->vb.field = V4L2_FIELD_SEQ_TB;\r\nbttv_calc_geo(btv,&buf->geo,tvnorm->swidth,tvnorm->sheight,\r\n1,tvnorm,&buf->crop);\r\nbttv_risc_packed(btv, &buf->top, dma->sglist,\r\n0, RAW_BPL, 0,\r\n0, RAW_LINES);\r\nbttv_risc_packed(btv, &buf->bottom, dma->sglist,\r\nbuf->vb.size/2 , RAW_BPL, 0, 0, RAW_LINES);\r\n}\r\nbuf->btformat = buf->fmt->btformat;\r\nbuf->btswap = buf->fmt->btswap;\r\nreturn 0;\r\n}\r\nint\r\nbttv_overlay_risc(struct bttv *btv,\r\nstruct bttv_overlay *ov,\r\nconst struct bttv_format *fmt,\r\nstruct bttv_buffer *buf)\r\n{\r\ndprintk("%d: overlay fields: %s format: %s size: %dx%d\n",\r\nbtv->c.nr, v4l2_field_names[buf->vb.field],\r\nfmt->name, ov->w.width, ov->w.height);\r\nbttv_calc_geo(btv,&buf->geo,ov->w.width,ov->w.height,\r\nV4L2_FIELD_HAS_BOTH(ov->field),\r\n&bttv_tvnorms[ov->tvnorm],&buf->crop);\r\nswitch (ov->field) {\r\ncase V4L2_FIELD_TOP:\r\nbttv_risc_overlay(btv, &buf->top, fmt, ov, 0, 0);\r\nbreak;\r\ncase V4L2_FIELD_BOTTOM:\r\nbttv_risc_overlay(btv, &buf->bottom, fmt, ov, 0, 0);\r\nbreak;\r\ncase V4L2_FIELD_INTERLACED:\r\nbttv_risc_overlay(btv, &buf->top, fmt, ov, 0, 1);\r\nbttv_risc_overlay(btv, &buf->bottom, fmt, ov, 1, 0);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nbuf->btformat = fmt->btformat;\r\nbuf->btswap = fmt->btswap;\r\nbuf->vb.field = ov->field;\r\nreturn 0;\r\n}
