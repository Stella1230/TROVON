static inline u32 nic7018_timeout(u32 period, u8 counter)\r\n{\r\nreturn period * counter - period / 2;\r\n}\r\nstatic const struct nic7018_config *nic7018_get_config(u32 timeout,\r\nu8 *counter)\r\n{\r\nconst struct nic7018_config *config;\r\nu8 count;\r\nif (timeout < 30 && timeout != 16) {\r\nconfig = &nic7018_configs[0];\r\ncount = timeout / 2 + 1;\r\n} else {\r\nconfig = &nic7018_configs[1];\r\ncount = DIV_ROUND_UP(timeout + 16, 32);\r\nif (count > WDT_MAX_COUNTER)\r\ncount = WDT_MAX_COUNTER;\r\n}\r\n*counter = count;\r\nreturn config;\r\n}\r\nstatic int nic7018_set_timeout(struct watchdog_device *wdd,\r\nunsigned int timeout)\r\n{\r\nstruct nic7018_wdt *wdt = watchdog_get_drvdata(wdd);\r\nconst struct nic7018_config *config;\r\nu8 counter;\r\nconfig = nic7018_get_config(timeout, &counter);\r\noutb(counter << 4 | config->divider,\r\nwdt->io_base + WDT_PRESET_PRESCALE);\r\nwdd->timeout = nic7018_timeout(config->period, counter);\r\nwdt->period = config->period;\r\nreturn 0;\r\n}\r\nstatic int nic7018_start(struct watchdog_device *wdd)\r\n{\r\nstruct nic7018_wdt *wdt = watchdog_get_drvdata(wdd);\r\nu8 control;\r\nnic7018_set_timeout(wdd, wdd->timeout);\r\ncontrol = inb(wdt->io_base + WDT_RELOAD_CTRL);\r\noutb(control | WDT_RELOAD_PORT_EN, wdt->io_base + WDT_RELOAD_CTRL);\r\noutb(1, wdt->io_base + WDT_RELOAD_PORT);\r\ncontrol = inb(wdt->io_base + WDT_CTRL);\r\noutb(control | WDT_CTRL_RESET_EN, wdt->io_base + WDT_CTRL);\r\nreturn 0;\r\n}\r\nstatic int nic7018_stop(struct watchdog_device *wdd)\r\n{\r\nstruct nic7018_wdt *wdt = watchdog_get_drvdata(wdd);\r\noutb(0, wdt->io_base + WDT_CTRL);\r\noutb(0, wdt->io_base + WDT_RELOAD_CTRL);\r\noutb(0xF0, wdt->io_base + WDT_PRESET_PRESCALE);\r\nreturn 0;\r\n}\r\nstatic int nic7018_ping(struct watchdog_device *wdd)\r\n{\r\nstruct nic7018_wdt *wdt = watchdog_get_drvdata(wdd);\r\noutb(1, wdt->io_base + WDT_RELOAD_PORT);\r\nreturn 0;\r\n}\r\nstatic unsigned int nic7018_get_timeleft(struct watchdog_device *wdd)\r\n{\r\nstruct nic7018_wdt *wdt = watchdog_get_drvdata(wdd);\r\nu8 count;\r\ncount = inb(wdt->io_base + WDT_COUNT) & 0xF;\r\nif (!count)\r\nreturn 0;\r\nreturn nic7018_timeout(wdt->period, count);\r\n}\r\nstatic int nic7018_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct watchdog_device *wdd;\r\nstruct nic7018_wdt *wdt;\r\nstruct resource *io_rc;\r\nint ret;\r\nwdt = devm_kzalloc(dev, sizeof(*wdt), GFP_KERNEL);\r\nif (!wdt)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, wdt);\r\nio_rc = platform_get_resource(pdev, IORESOURCE_IO, 0);\r\nif (!io_rc) {\r\ndev_err(dev, "missing IO resources\n");\r\nreturn -EINVAL;\r\n}\r\nif (!devm_request_region(dev, io_rc->start, resource_size(io_rc),\r\nKBUILD_MODNAME)) {\r\ndev_err(dev, "failed to get IO region\n");\r\nreturn -EBUSY;\r\n}\r\nwdt->io_base = io_rc->start;\r\nwdd = &wdt->wdd;\r\nwdd->info = &nic7018_wdd_info;\r\nwdd->ops = &nic7018_wdd_ops;\r\nwdd->min_timeout = WDT_MIN_TIMEOUT;\r\nwdd->max_timeout = WDT_MAX_TIMEOUT;\r\nwdd->timeout = WDT_DEFAULT_TIMEOUT;\r\nwdd->parent = dev;\r\nwatchdog_set_drvdata(wdd, wdt);\r\nwatchdog_set_nowayout(wdd, nowayout);\r\nret = watchdog_init_timeout(wdd, timeout, dev);\r\nif (ret)\r\ndev_warn(dev, "unable to set timeout value, using default\n");\r\noutb(UNLOCK, wdt->io_base + WDT_REG_LOCK);\r\nret = watchdog_register_device(wdd);\r\nif (ret) {\r\noutb(LOCK, wdt->io_base + WDT_REG_LOCK);\r\ndev_err(dev, "failed to register watchdog\n");\r\nreturn ret;\r\n}\r\ndev_dbg(dev, "io_base=0x%04X, timeout=%d, nowayout=%d\n",\r\nwdt->io_base, timeout, nowayout);\r\nreturn 0;\r\n}\r\nstatic int nic7018_remove(struct platform_device *pdev)\r\n{\r\nstruct nic7018_wdt *wdt = platform_get_drvdata(pdev);\r\nwatchdog_unregister_device(&wdt->wdd);\r\noutb(LOCK, wdt->io_base + WDT_REG_LOCK);\r\nreturn 0;\r\n}
