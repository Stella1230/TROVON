static inline void set_swim_mode(struct swim __iomem *base, int enable)\r\n{\r\nstruct iwm __iomem *iwm_base;\r\nunsigned long flags;\r\nif (!enable) {\r\nswim_write(base, mode0, 0xf8);\r\nreturn;\r\n}\r\niwm_base = (struct iwm __iomem *)base;\r\nlocal_irq_save(flags);\r\niwm_read(iwm_base, q7L);\r\niwm_read(iwm_base, mtrOff);\r\niwm_read(iwm_base, q6H);\r\niwm_write(iwm_base, q7H, 0x57);\r\niwm_write(iwm_base, q7H, 0x17);\r\niwm_write(iwm_base, q7H, 0x57);\r\niwm_write(iwm_base, q7H, 0x57);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic inline int get_swim_mode(struct swim __iomem *base)\r\n{\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nswim_write(base, phase, 0xf5);\r\nif (swim_read(base, phase) != 0xf5)\r\ngoto is_iwm;\r\nswim_write(base, phase, 0xf6);\r\nif (swim_read(base, phase) != 0xf6)\r\ngoto is_iwm;\r\nswim_write(base, phase, 0xf7);\r\nif (swim_read(base, phase) != 0xf7)\r\ngoto is_iwm;\r\nlocal_irq_restore(flags);\r\nreturn 1;\r\nis_iwm:\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nstatic inline void swim_select(struct swim __iomem *base, int sel)\r\n{\r\nswim_write(base, phase, RELAX);\r\nvia1_set_head(sel & 0x100);\r\nswim_write(base, phase, sel & CA_MASK);\r\n}\r\nstatic inline void swim_action(struct swim __iomem *base, int action)\r\n{\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nswim_select(base, action);\r\nudelay(1);\r\nswim_write(base, phase, (LSTRB<<4) | LSTRB);\r\nudelay(1);\r\nswim_write(base, phase, (LSTRB<<4) | ((~LSTRB) & 0x0F));\r\nudelay(1);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic inline int swim_readbit(struct swim __iomem *base, int bit)\r\n{\r\nint stat;\r\nswim_select(base, bit);\r\nudelay(10);\r\nstat = swim_read(base, handshake);\r\nreturn (stat & SENSE) == 0;\r\n}\r\nstatic inline void swim_drive(struct swim __iomem *base,\r\nenum drive_location location)\r\n{\r\nif (location == INTERNAL_DRIVE) {\r\nswim_write(base, mode0, EXTERNAL_DRIVE);\r\nswim_write(base, mode1, INTERNAL_DRIVE);\r\n} else if (location == EXTERNAL_DRIVE) {\r\nswim_write(base, mode0, INTERNAL_DRIVE);\r\nswim_write(base, mode1, EXTERNAL_DRIVE);\r\n}\r\n}\r\nstatic inline void swim_motor(struct swim __iomem *base,\r\nenum motor_action action)\r\n{\r\nif (action == ON) {\r\nint i;\r\nswim_action(base, MOTOR_ON);\r\nfor (i = 0; i < 2*HZ; i++) {\r\nswim_select(base, RELAX);\r\nif (swim_readbit(base, MOTOR_ON))\r\nbreak;\r\ncurrent->state = TASK_INTERRUPTIBLE;\r\nschedule_timeout(1);\r\n}\r\n} else if (action == OFF) {\r\nswim_action(base, MOTOR_OFF);\r\nswim_select(base, RELAX);\r\n}\r\n}\r\nstatic inline void swim_eject(struct swim __iomem *base)\r\n{\r\nint i;\r\nswim_action(base, EJECT);\r\nfor (i = 0; i < 2*HZ; i++) {\r\nswim_select(base, RELAX);\r\nif (!swim_readbit(base, DISK_IN))\r\nbreak;\r\ncurrent->state = TASK_INTERRUPTIBLE;\r\nschedule_timeout(1);\r\n}\r\nswim_select(base, RELAX);\r\n}\r\nstatic inline void swim_head(struct swim __iomem *base, enum head head)\r\n{\r\nif (head == UPPER_HEAD)\r\nswim_select(base, READ_DATA_1);\r\nelse if (head == LOWER_HEAD)\r\nswim_select(base, READ_DATA_0);\r\n}\r\nstatic inline int swim_step(struct swim __iomem *base)\r\n{\r\nint wait;\r\nswim_action(base, STEP);\r\nfor (wait = 0; wait < HZ; wait++) {\r\ncurrent->state = TASK_INTERRUPTIBLE;\r\nschedule_timeout(1);\r\nswim_select(base, RELAX);\r\nif (!swim_readbit(base, STEP))\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nstatic inline int swim_track00(struct swim __iomem *base)\r\n{\r\nint try;\r\nswim_action(base, SEEK_NEGATIVE);\r\nfor (try = 0; try < 100; try++) {\r\nswim_select(base, RELAX);\r\nif (swim_readbit(base, TRACK_ZERO))\r\nbreak;\r\nif (swim_step(base))\r\nreturn -1;\r\n}\r\nif (swim_readbit(base, TRACK_ZERO))\r\nreturn 0;\r\nreturn -1;\r\n}\r\nstatic inline int swim_seek(struct swim __iomem *base, int step)\r\n{\r\nif (step == 0)\r\nreturn 0;\r\nif (step < 0) {\r\nswim_action(base, SEEK_NEGATIVE);\r\nstep = -step;\r\n} else\r\nswim_action(base, SEEK_POSITIVE);\r\nfor ( ; step > 0; step--) {\r\nif (swim_step(base))\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int swim_track(struct floppy_state *fs, int track)\r\n{\r\nstruct swim __iomem *base = fs->swd->base;\r\nint ret;\r\nret = swim_seek(base, track - fs->track);\r\nif (ret == 0)\r\nfs->track = track;\r\nelse {\r\nswim_track00(base);\r\nfs->track = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int floppy_eject(struct floppy_state *fs)\r\n{\r\nstruct swim __iomem *base = fs->swd->base;\r\nswim_drive(base, fs->location);\r\nswim_motor(base, OFF);\r\nswim_eject(base);\r\nfs->disk_in = 0;\r\nfs->ejected = 1;\r\nreturn 0;\r\n}\r\nstatic inline int swim_read_sector(struct floppy_state *fs,\r\nint side, int track,\r\nint sector, unsigned char *buffer)\r\n{\r\nstruct swim __iomem *base = fs->swd->base;\r\nunsigned long flags;\r\nstruct sector_header header;\r\nint ret = -1;\r\nshort i;\r\nswim_track(fs, track);\r\nswim_write(base, mode1, MOTON);\r\nswim_head(base, side);\r\nswim_write(base, mode0, side);\r\nlocal_irq_save(flags);\r\nfor (i = 0; i < 36; i++) {\r\nret = swim_read_sector_header(base, &header);\r\nif (!ret && (header.sector == sector)) {\r\nret = swim_read_sector_data(base, buffer);\r\nbreak;\r\n}\r\n}\r\nlocal_irq_restore(flags);\r\nswim_write(base, mode0, MOTON);\r\nif ((header.side != side) || (header.track != track) ||\r\n(header.sector != sector))\r\nreturn 0;\r\nreturn ret;\r\n}\r\nstatic blk_status_t floppy_read_sectors(struct floppy_state *fs,\r\nint req_sector, int sectors_nb,\r\nunsigned char *buffer)\r\n{\r\nstruct swim __iomem *base = fs->swd->base;\r\nint ret;\r\nint side, track, sector;\r\nint i, try;\r\nswim_drive(base, fs->location);\r\nfor (i = req_sector; i < req_sector + sectors_nb; i++) {\r\nint x;\r\ntrack = i / fs->secpercyl;\r\nx = i % fs->secpercyl;\r\nside = x / fs->secpertrack;\r\nsector = x % fs->secpertrack + 1;\r\ntry = 5;\r\ndo {\r\nret = swim_read_sector(fs, side, track, sector,\r\nbuffer);\r\nif (try-- == 0)\r\nreturn BLK_STS_IOERR;\r\n} while (ret != 512);\r\nbuffer += ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct request *swim_next_request(struct swim_priv *swd)\r\n{\r\nstruct request_queue *q;\r\nstruct request *rq;\r\nint old_pos = swd->fdc_queue;\r\ndo {\r\nq = swd->unit[swd->fdc_queue].disk->queue;\r\nif (++swd->fdc_queue == swd->floppy_count)\r\nswd->fdc_queue = 0;\r\nif (q) {\r\nrq = blk_fetch_request(q);\r\nif (rq)\r\nreturn rq;\r\n}\r\n} while (swd->fdc_queue != old_pos);\r\nreturn NULL;\r\n}\r\nstatic void do_fd_request(struct request_queue *q)\r\n{\r\nstruct swim_priv *swd = q->queuedata;\r\nstruct request *req;\r\nstruct floppy_state *fs;\r\nreq = swim_next_request(swd);\r\nwhile (req) {\r\nblk_status_t err = BLK_STS_IOERR;\r\nfs = req->rq_disk->private_data;\r\nif (blk_rq_pos(req) >= fs->total_secs)\r\ngoto done;\r\nif (!fs->disk_in)\r\ngoto done;\r\nif (rq_data_dir(req) == WRITE && fs->write_protected)\r\ngoto done;\r\nswitch (rq_data_dir(req)) {\r\ncase WRITE:\r\nbreak;\r\ncase READ:\r\nerr = floppy_read_sectors(fs, blk_rq_pos(req),\r\nblk_rq_cur_sectors(req),\r\nbio_data(req->bio));\r\nbreak;\r\n}\r\ndone:\r\nif (!__blk_end_request_cur(req, err))\r\nreq = swim_next_request(swd);\r\n}\r\n}\r\nstatic int get_floppy_geometry(struct floppy_state *fs, int type,\r\nstruct floppy_struct **g)\r\n{\r\nif (type >= ARRAY_SIZE(floppy_type))\r\nreturn -EINVAL;\r\nif (type)\r\n*g = &floppy_type[type];\r\nelse if (fs->type == HD_MEDIA)\r\n*g = &floppy_type[3];\r\nelse if (fs->head_number == 2)\r\n*g = &floppy_type[2];\r\nelse\r\n*g = &floppy_type[1];\r\nreturn 0;\r\n}\r\nstatic void setup_medium(struct floppy_state *fs)\r\n{\r\nstruct swim __iomem *base = fs->swd->base;\r\nif (swim_readbit(base, DISK_IN)) {\r\nstruct floppy_struct *g;\r\nfs->disk_in = 1;\r\nfs->write_protected = swim_readbit(base, WRITE_PROT);\r\nfs->type = swim_readbit(base, ONEMEG_MEDIA);\r\nif (swim_track00(base))\r\nprintk(KERN_ERR\r\n"SWIM: cannot move floppy head to track 0\n");\r\nswim_track00(base);\r\nget_floppy_geometry(fs, 0, &g);\r\nfs->total_secs = g->size;\r\nfs->secpercyl = g->head * g->sect;\r\nfs->secpertrack = g->sect;\r\nfs->track = 0;\r\n} else {\r\nfs->disk_in = 0;\r\n}\r\n}\r\nstatic int floppy_open(struct block_device *bdev, fmode_t mode)\r\n{\r\nstruct floppy_state *fs = bdev->bd_disk->private_data;\r\nstruct swim __iomem *base = fs->swd->base;\r\nint err;\r\nif (fs->ref_count == -1 || (fs->ref_count && mode & FMODE_EXCL))\r\nreturn -EBUSY;\r\nif (mode & FMODE_EXCL)\r\nfs->ref_count = -1;\r\nelse\r\nfs->ref_count++;\r\nswim_write(base, setup, S_IBM_DRIVE | S_FCLK_DIV2);\r\nudelay(10);\r\nswim_drive(base, INTERNAL_DRIVE);\r\nswim_motor(base, ON);\r\nswim_action(base, SETMFM);\r\nif (fs->ejected)\r\nsetup_medium(fs);\r\nif (!fs->disk_in) {\r\nerr = -ENXIO;\r\ngoto out;\r\n}\r\nif (mode & FMODE_NDELAY)\r\nreturn 0;\r\nif (mode & (FMODE_READ|FMODE_WRITE)) {\r\ncheck_disk_change(bdev);\r\nif ((mode & FMODE_WRITE) && fs->write_protected) {\r\nerr = -EROFS;\r\ngoto out;\r\n}\r\n}\r\nreturn 0;\r\nout:\r\nif (fs->ref_count < 0)\r\nfs->ref_count = 0;\r\nelse if (fs->ref_count > 0)\r\n--fs->ref_count;\r\nif (fs->ref_count == 0)\r\nswim_motor(base, OFF);\r\nreturn err;\r\n}\r\nstatic int floppy_unlocked_open(struct block_device *bdev, fmode_t mode)\r\n{\r\nint ret;\r\nmutex_lock(&swim_mutex);\r\nret = floppy_open(bdev, mode);\r\nmutex_unlock(&swim_mutex);\r\nreturn ret;\r\n}\r\nstatic void floppy_release(struct gendisk *disk, fmode_t mode)\r\n{\r\nstruct floppy_state *fs = disk->private_data;\r\nstruct swim __iomem *base = fs->swd->base;\r\nmutex_lock(&swim_mutex);\r\nif (fs->ref_count < 0)\r\nfs->ref_count = 0;\r\nelse if (fs->ref_count > 0)\r\n--fs->ref_count;\r\nif (fs->ref_count == 0)\r\nswim_motor(base, OFF);\r\nmutex_unlock(&swim_mutex);\r\n}\r\nstatic int floppy_ioctl(struct block_device *bdev, fmode_t mode,\r\nunsigned int cmd, unsigned long param)\r\n{\r\nstruct floppy_state *fs = bdev->bd_disk->private_data;\r\nint err;\r\nif ((cmd & 0x80) && !capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nswitch (cmd) {\r\ncase FDEJECT:\r\nif (fs->ref_count != 1)\r\nreturn -EBUSY;\r\nmutex_lock(&swim_mutex);\r\nerr = floppy_eject(fs);\r\nmutex_unlock(&swim_mutex);\r\nreturn err;\r\ncase FDGETPRM:\r\nif (copy_to_user((void __user *) param, (void *) &floppy_type,\r\nsizeof(struct floppy_struct)))\r\nreturn -EFAULT;\r\nbreak;\r\ndefault:\r\nprintk(KERN_DEBUG "SWIM floppy_ioctl: unknown cmd %d\n",\r\ncmd);\r\nreturn -ENOSYS;\r\n}\r\nreturn 0;\r\n}\r\nstatic int floppy_getgeo(struct block_device *bdev, struct hd_geometry *geo)\r\n{\r\nstruct floppy_state *fs = bdev->bd_disk->private_data;\r\nstruct floppy_struct *g;\r\nint ret;\r\nret = get_floppy_geometry(fs, 0, &g);\r\nif (ret)\r\nreturn ret;\r\ngeo->heads = g->head;\r\ngeo->sectors = g->sect;\r\ngeo->cylinders = g->track;\r\nreturn 0;\r\n}\r\nstatic unsigned int floppy_check_events(struct gendisk *disk,\r\nunsigned int clearing)\r\n{\r\nstruct floppy_state *fs = disk->private_data;\r\nreturn fs->ejected ? DISK_EVENT_MEDIA_CHANGE : 0;\r\n}\r\nstatic int floppy_revalidate(struct gendisk *disk)\r\n{\r\nstruct floppy_state *fs = disk->private_data;\r\nstruct swim __iomem *base = fs->swd->base;\r\nswim_drive(base, fs->location);\r\nif (fs->ejected)\r\nsetup_medium(fs);\r\nif (!fs->disk_in)\r\nswim_motor(base, OFF);\r\nelse\r\nfs->ejected = 0;\r\nreturn !fs->disk_in;\r\n}\r\nstatic struct kobject *floppy_find(dev_t dev, int *part, void *data)\r\n{\r\nstruct swim_priv *swd = data;\r\nint drive = (*part & 3);\r\nif (drive > swd->floppy_count)\r\nreturn NULL;\r\n*part = 0;\r\nreturn get_disk(swd->unit[drive].disk);\r\n}\r\nstatic int swim_add_floppy(struct swim_priv *swd, enum drive_location location)\r\n{\r\nstruct floppy_state *fs = &swd->unit[swd->floppy_count];\r\nstruct swim __iomem *base = swd->base;\r\nfs->location = location;\r\nswim_drive(base, location);\r\nswim_motor(base, OFF);\r\nif (swim_readbit(base, SINGLE_SIDED))\r\nfs->head_number = 1;\r\nelse\r\nfs->head_number = 2;\r\nfs->ref_count = 0;\r\nfs->ejected = 1;\r\nswd->floppy_count++;\r\nreturn 0;\r\n}\r\nstatic int swim_floppy_init(struct swim_priv *swd)\r\n{\r\nint err;\r\nint drive;\r\nstruct swim __iomem *base = swd->base;\r\nswim_drive(base, INTERNAL_DRIVE);\r\nif (swim_readbit(base, DRIVE_PRESENT))\r\nswim_add_floppy(swd, INTERNAL_DRIVE);\r\nswim_drive(base, EXTERNAL_DRIVE);\r\nif (swim_readbit(base, DRIVE_PRESENT))\r\nswim_add_floppy(swd, EXTERNAL_DRIVE);\r\nerr = register_blkdev(FLOPPY_MAJOR, "fd");\r\nif (err) {\r\nprintk(KERN_ERR "Unable to get major %d for SWIM floppy\n",\r\nFLOPPY_MAJOR);\r\nreturn -EBUSY;\r\n}\r\nspin_lock_init(&swd->lock);\r\nfor (drive = 0; drive < swd->floppy_count; drive++) {\r\nswd->unit[drive].disk = alloc_disk(1);\r\nif (swd->unit[drive].disk == NULL) {\r\nerr = -ENOMEM;\r\ngoto exit_put_disks;\r\n}\r\nswd->unit[drive].disk->queue = blk_init_queue(do_fd_request,\r\n&swd->lock);\r\nif (!swd->unit[drive].disk->queue) {\r\nerr = -ENOMEM;\r\nput_disk(swd->unit[drive].disk);\r\ngoto exit_put_disks;\r\n}\r\nblk_queue_bounce_limit(swd->unit[drive].disk->queue,\r\nBLK_BOUNCE_HIGH);\r\nswd->unit[drive].disk->queue->queuedata = swd;\r\nswd->unit[drive].swd = swd;\r\n}\r\nfor (drive = 0; drive < swd->floppy_count; drive++) {\r\nswd->unit[drive].disk->flags = GENHD_FL_REMOVABLE;\r\nswd->unit[drive].disk->major = FLOPPY_MAJOR;\r\nswd->unit[drive].disk->first_minor = drive;\r\nsprintf(swd->unit[drive].disk->disk_name, "fd%d", drive);\r\nswd->unit[drive].disk->fops = &floppy_fops;\r\nswd->unit[drive].disk->private_data = &swd->unit[drive];\r\nset_capacity(swd->unit[drive].disk, 2880);\r\nadd_disk(swd->unit[drive].disk);\r\n}\r\nblk_register_region(MKDEV(FLOPPY_MAJOR, 0), 256, THIS_MODULE,\r\nfloppy_find, NULL, swd);\r\nreturn 0;\r\nexit_put_disks:\r\nunregister_blkdev(FLOPPY_MAJOR, "fd");\r\nwhile (drive--)\r\nput_disk(swd->unit[drive].disk);\r\nreturn err;\r\n}\r\nstatic int swim_probe(struct platform_device *dev)\r\n{\r\nstruct resource *res;\r\nstruct swim __iomem *swim_base;\r\nstruct swim_priv *swd;\r\nint ret;\r\nres = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nif (!request_mem_region(res->start, resource_size(res), CARDNAME)) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nswim_base = ioremap(res->start, resource_size(res));\r\nif (!swim_base) {\r\nret = -ENOMEM;\r\ngoto out_release_io;\r\n}\r\nset_swim_mode(swim_base, 1);\r\nif (!get_swim_mode(swim_base)) {\r\nprintk(KERN_INFO "SWIM device not found !\n");\r\nret = -ENODEV;\r\ngoto out_iounmap;\r\n}\r\nswd = kzalloc(sizeof(struct swim_priv), GFP_KERNEL);\r\nif (!swd) {\r\nret = -ENOMEM;\r\ngoto out_iounmap;\r\n}\r\nplatform_set_drvdata(dev, swd);\r\nswd->base = swim_base;\r\nret = swim_floppy_init(swd);\r\nif (ret)\r\ngoto out_kfree;\r\nreturn 0;\r\nout_kfree:\r\nkfree(swd);\r\nout_iounmap:\r\niounmap(swim_base);\r\nout_release_io:\r\nrelease_mem_region(res->start, resource_size(res));\r\nout:\r\nreturn ret;\r\n}\r\nstatic int swim_remove(struct platform_device *dev)\r\n{\r\nstruct swim_priv *swd = platform_get_drvdata(dev);\r\nint drive;\r\nstruct resource *res;\r\nblk_unregister_region(MKDEV(FLOPPY_MAJOR, 0), 256);\r\nfor (drive = 0; drive < swd->floppy_count; drive++) {\r\ndel_gendisk(swd->unit[drive].disk);\r\nblk_cleanup_queue(swd->unit[drive].disk->queue);\r\nput_disk(swd->unit[drive].disk);\r\n}\r\nunregister_blkdev(FLOPPY_MAJOR, "fd");\r\nfor (drive = 0; drive < swd->floppy_count; drive++)\r\nfloppy_eject(&swd->unit[drive]);\r\niounmap(swd->base);\r\nres = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\nif (res)\r\nrelease_mem_region(res->start, resource_size(res));\r\nkfree(swd);\r\nreturn 0;\r\n}\r\nstatic int __init swim_init(void)\r\n{\r\nprintk(KERN_INFO "SWIM floppy driver %s\n", DRIVER_VERSION);\r\nreturn platform_driver_register(&swim_driver);\r\n}\r\nstatic void __exit swim_exit(void)\r\n{\r\nplatform_driver_unregister(&swim_driver);\r\n}
