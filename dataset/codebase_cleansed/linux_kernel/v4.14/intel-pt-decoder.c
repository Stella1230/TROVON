static inline bool intel_pt_sample_time(enum intel_pt_pkt_state pkt_state)\r\n{\r\nswitch (pkt_state) {\r\ncase INTEL_PT_STATE_NO_PSB:\r\ncase INTEL_PT_STATE_NO_IP:\r\ncase INTEL_PT_STATE_ERR_RESYNC:\r\ncase INTEL_PT_STATE_IN_SYNC:\r\ncase INTEL_PT_STATE_TNT:\r\nreturn true;\r\ncase INTEL_PT_STATE_TIP:\r\ncase INTEL_PT_STATE_TIP_PGD:\r\ncase INTEL_PT_STATE_FUP:\r\ncase INTEL_PT_STATE_FUP_NO_TIP:\r\nreturn false;\r\ndefault:\r\nreturn true;\r\n};\r\n}\r\nstatic uint64_t intel_pt_lower_power_of_2(uint64_t x)\r\n{\r\nint i;\r\nfor (i = 0; x != 1; i++)\r\nx >>= 1;\r\nreturn x << i;\r\n}\r\nstatic void intel_pt_setup_period(struct intel_pt_decoder *decoder)\r\n{\r\nif (decoder->period_type == INTEL_PT_PERIOD_TICKS) {\r\nuint64_t period;\r\nperiod = intel_pt_lower_power_of_2(decoder->period);\r\ndecoder->period_mask = ~(period - 1);\r\ndecoder->period_ticks = period;\r\n}\r\n}\r\nstatic uint64_t multdiv(uint64_t t, uint32_t n, uint32_t d)\r\n{\r\nif (!d)\r\nreturn 0;\r\nreturn (t / d) * n + ((t % d) * n) / d;\r\n}\r\nstruct intel_pt_decoder *intel_pt_decoder_new(struct intel_pt_params *params)\r\n{\r\nstruct intel_pt_decoder *decoder;\r\nif (!params->get_trace || !params->walk_insn)\r\nreturn NULL;\r\ndecoder = zalloc(sizeof(struct intel_pt_decoder));\r\nif (!decoder)\r\nreturn NULL;\r\ndecoder->get_trace = params->get_trace;\r\ndecoder->walk_insn = params->walk_insn;\r\ndecoder->pgd_ip = params->pgd_ip;\r\ndecoder->data = params->data;\r\ndecoder->return_compression = params->return_compression;\r\ndecoder->branch_enable = params->branch_enable;\r\ndecoder->period = params->period;\r\ndecoder->period_type = params->period_type;\r\ndecoder->max_non_turbo_ratio = params->max_non_turbo_ratio;\r\ndecoder->max_non_turbo_ratio_fp = params->max_non_turbo_ratio;\r\nintel_pt_setup_period(decoder);\r\ndecoder->mtc_shift = params->mtc_period;\r\ndecoder->ctc_rem_mask = (1 << decoder->mtc_shift) - 1;\r\ndecoder->tsc_ctc_ratio_n = params->tsc_ctc_ratio_n;\r\ndecoder->tsc_ctc_ratio_d = params->tsc_ctc_ratio_d;\r\nif (!decoder->tsc_ctc_ratio_n)\r\ndecoder->tsc_ctc_ratio_d = 0;\r\nif (decoder->tsc_ctc_ratio_d) {\r\nif (!(decoder->tsc_ctc_ratio_n % decoder->tsc_ctc_ratio_d))\r\ndecoder->tsc_ctc_mult = decoder->tsc_ctc_ratio_n /\r\ndecoder->tsc_ctc_ratio_d;\r\ndecoder->tsc_slip = multdiv(2 << decoder->mtc_shift,\r\ndecoder->tsc_ctc_ratio_n,\r\ndecoder->tsc_ctc_ratio_d);\r\n}\r\nif (decoder->tsc_slip < 0x100)\r\ndecoder->tsc_slip = 0x100;\r\nintel_pt_log("timestamp: mtc_shift %u\n", decoder->mtc_shift);\r\nintel_pt_log("timestamp: tsc_ctc_ratio_n %u\n", decoder->tsc_ctc_ratio_n);\r\nintel_pt_log("timestamp: tsc_ctc_ratio_d %u\n", decoder->tsc_ctc_ratio_d);\r\nintel_pt_log("timestamp: tsc_ctc_mult %u\n", decoder->tsc_ctc_mult);\r\nintel_pt_log("timestamp: tsc_slip %#x\n", decoder->tsc_slip);\r\nreturn decoder;\r\n}\r\nstatic void intel_pt_pop_blk(struct intel_pt_stack *stack)\r\n{\r\nstruct intel_pt_blk *blk = stack->blk;\r\nstack->blk = blk->prev;\r\nif (!stack->spare)\r\nstack->spare = blk;\r\nelse\r\nfree(blk);\r\n}\r\nstatic uint64_t intel_pt_pop(struct intel_pt_stack *stack)\r\n{\r\nif (!stack->pos) {\r\nif (!stack->blk)\r\nreturn 0;\r\nintel_pt_pop_blk(stack);\r\nif (!stack->blk)\r\nreturn 0;\r\nstack->pos = INTEL_PT_BLK_SIZE;\r\n}\r\nreturn stack->blk->ip[--stack->pos];\r\n}\r\nstatic int intel_pt_alloc_blk(struct intel_pt_stack *stack)\r\n{\r\nstruct intel_pt_blk *blk;\r\nif (stack->spare) {\r\nblk = stack->spare;\r\nstack->spare = NULL;\r\n} else {\r\nblk = malloc(sizeof(struct intel_pt_blk));\r\nif (!blk)\r\nreturn -ENOMEM;\r\n}\r\nblk->prev = stack->blk;\r\nstack->blk = blk;\r\nstack->pos = 0;\r\nreturn 0;\r\n}\r\nstatic int intel_pt_push(struct intel_pt_stack *stack, uint64_t ip)\r\n{\r\nint err;\r\nif (!stack->blk || stack->pos == INTEL_PT_BLK_SIZE) {\r\nerr = intel_pt_alloc_blk(stack);\r\nif (err)\r\nreturn err;\r\n}\r\nstack->blk->ip[stack->pos++] = ip;\r\nreturn 0;\r\n}\r\nstatic void intel_pt_clear_stack(struct intel_pt_stack *stack)\r\n{\r\nwhile (stack->blk)\r\nintel_pt_pop_blk(stack);\r\nstack->pos = 0;\r\n}\r\nstatic void intel_pt_free_stack(struct intel_pt_stack *stack)\r\n{\r\nintel_pt_clear_stack(stack);\r\nzfree(&stack->blk);\r\nzfree(&stack->spare);\r\n}\r\nvoid intel_pt_decoder_free(struct intel_pt_decoder *decoder)\r\n{\r\nintel_pt_free_stack(&decoder->stack);\r\nfree(decoder);\r\n}\r\nstatic int intel_pt_ext_err(int code)\r\n{\r\nswitch (code) {\r\ncase -ENOMEM:\r\nreturn INTEL_PT_ERR_NOMEM;\r\ncase -ENOSYS:\r\nreturn INTEL_PT_ERR_INTERN;\r\ncase -EBADMSG:\r\nreturn INTEL_PT_ERR_BADPKT;\r\ncase -ENODATA:\r\nreturn INTEL_PT_ERR_NODATA;\r\ncase -EILSEQ:\r\nreturn INTEL_PT_ERR_NOINSN;\r\ncase -ENOENT:\r\nreturn INTEL_PT_ERR_MISMAT;\r\ncase -EOVERFLOW:\r\nreturn INTEL_PT_ERR_OVR;\r\ncase -ENOSPC:\r\nreturn INTEL_PT_ERR_LOST;\r\ncase -ELOOP:\r\nreturn INTEL_PT_ERR_NELOOP;\r\ndefault:\r\nreturn INTEL_PT_ERR_UNK;\r\n}\r\n}\r\nint intel_pt__strerror(int code, char *buf, size_t buflen)\r\n{\r\nif (code < 1 || code >= INTEL_PT_ERR_MAX)\r\ncode = INTEL_PT_ERR_UNK;\r\nstrlcpy(buf, intel_pt_err_msgs[code], buflen);\r\nreturn 0;\r\n}\r\nstatic uint64_t intel_pt_calc_ip(const struct intel_pt_pkt *packet,\r\nuint64_t last_ip)\r\n{\r\nuint64_t ip;\r\nswitch (packet->count) {\r\ncase 1:\r\nip = (last_ip & (uint64_t)0xffffffffffff0000ULL) |\r\npacket->payload;\r\nbreak;\r\ncase 2:\r\nip = (last_ip & (uint64_t)0xffffffff00000000ULL) |\r\npacket->payload;\r\nbreak;\r\ncase 3:\r\nip = packet->payload;\r\nif (ip & (uint64_t)0x800000000000ULL)\r\nip |= (uint64_t)0xffff000000000000ULL;\r\nbreak;\r\ncase 4:\r\nip = (last_ip & (uint64_t)0xffff000000000000ULL) |\r\npacket->payload;\r\nbreak;\r\ncase 6:\r\nip = packet->payload;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn ip;\r\n}\r\nstatic inline void intel_pt_set_last_ip(struct intel_pt_decoder *decoder)\r\n{\r\ndecoder->last_ip = intel_pt_calc_ip(&decoder->packet, decoder->last_ip);\r\ndecoder->have_last_ip = true;\r\n}\r\nstatic inline void intel_pt_set_ip(struct intel_pt_decoder *decoder)\r\n{\r\nintel_pt_set_last_ip(decoder);\r\ndecoder->ip = decoder->last_ip;\r\n}\r\nstatic void intel_pt_decoder_log_packet(struct intel_pt_decoder *decoder)\r\n{\r\nintel_pt_log_packet(&decoder->packet, decoder->pkt_len, decoder->pos,\r\ndecoder->buf);\r\n}\r\nstatic int intel_pt_bug(struct intel_pt_decoder *decoder)\r\n{\r\nintel_pt_log("ERROR: Internal error\n");\r\ndecoder->pkt_state = INTEL_PT_STATE_NO_PSB;\r\nreturn -ENOSYS;\r\n}\r\nstatic inline void intel_pt_clear_tx_flags(struct intel_pt_decoder *decoder)\r\n{\r\ndecoder->tx_flags = 0;\r\n}\r\nstatic inline void intel_pt_update_in_tx(struct intel_pt_decoder *decoder)\r\n{\r\ndecoder->tx_flags = decoder->packet.payload & INTEL_PT_IN_TX;\r\n}\r\nstatic int intel_pt_bad_packet(struct intel_pt_decoder *decoder)\r\n{\r\nintel_pt_clear_tx_flags(decoder);\r\ndecoder->have_tma = false;\r\ndecoder->pkt_len = 1;\r\ndecoder->pkt_step = 1;\r\nintel_pt_decoder_log_packet(decoder);\r\nif (decoder->pkt_state != INTEL_PT_STATE_NO_PSB) {\r\nintel_pt_log("ERROR: Bad packet\n");\r\ndecoder->pkt_state = INTEL_PT_STATE_ERR1;\r\n}\r\nreturn -EBADMSG;\r\n}\r\nstatic int intel_pt_get_data(struct intel_pt_decoder *decoder)\r\n{\r\nstruct intel_pt_buffer buffer = { .buf = 0, };\r\nint ret;\r\ndecoder->pkt_step = 0;\r\nintel_pt_log("Getting more data\n");\r\nret = decoder->get_trace(&buffer, decoder->data);\r\nif (ret)\r\nreturn ret;\r\ndecoder->buf = buffer.buf;\r\ndecoder->len = buffer.len;\r\nif (!decoder->len) {\r\nintel_pt_log("No more data\n");\r\nreturn -ENODATA;\r\n}\r\nif (!buffer.consecutive) {\r\ndecoder->ip = 0;\r\ndecoder->pkt_state = INTEL_PT_STATE_NO_PSB;\r\ndecoder->ref_timestamp = buffer.ref_timestamp;\r\ndecoder->timestamp = 0;\r\ndecoder->have_tma = false;\r\ndecoder->state.trace_nr = buffer.trace_nr;\r\nintel_pt_log("Reference timestamp 0x%" PRIx64 "\n",\r\ndecoder->ref_timestamp);\r\nreturn -ENOLINK;\r\n}\r\nreturn 0;\r\n}\r\nstatic int intel_pt_get_next_data(struct intel_pt_decoder *decoder)\r\n{\r\nif (!decoder->next_buf)\r\nreturn intel_pt_get_data(decoder);\r\ndecoder->buf = decoder->next_buf;\r\ndecoder->len = decoder->next_len;\r\ndecoder->next_buf = 0;\r\ndecoder->next_len = 0;\r\nreturn 0;\r\n}\r\nstatic int intel_pt_get_split_packet(struct intel_pt_decoder *decoder)\r\n{\r\nunsigned char *buf = decoder->temp_buf;\r\nsize_t old_len, len, n;\r\nint ret;\r\nold_len = decoder->len;\r\nlen = decoder->len;\r\nmemcpy(buf, decoder->buf, len);\r\nret = intel_pt_get_data(decoder);\r\nif (ret) {\r\ndecoder->pos += old_len;\r\nreturn ret < 0 ? ret : -EINVAL;\r\n}\r\nn = INTEL_PT_PKT_MAX_SZ - len;\r\nif (n > decoder->len)\r\nn = decoder->len;\r\nmemcpy(buf + len, decoder->buf, n);\r\nlen += n;\r\nret = intel_pt_get_packet(buf, len, &decoder->packet);\r\nif (ret < (int)old_len) {\r\ndecoder->next_buf = decoder->buf;\r\ndecoder->next_len = decoder->len;\r\ndecoder->buf = buf;\r\ndecoder->len = old_len;\r\nreturn intel_pt_bad_packet(decoder);\r\n}\r\ndecoder->next_buf = decoder->buf + (ret - old_len);\r\ndecoder->next_len = decoder->len - (ret - old_len);\r\ndecoder->buf = buf;\r\ndecoder->len = ret;\r\nreturn ret;\r\n}\r\nstatic int intel_pt_pkt_lookahead(struct intel_pt_decoder *decoder,\r\nintel_pt_pkt_cb_t cb, void *data)\r\n{\r\nstruct intel_pt_pkt_info pkt_info;\r\nconst unsigned char *buf = decoder->buf;\r\nsize_t len = decoder->len;\r\nint ret;\r\npkt_info.decoder = decoder;\r\npkt_info.pos = decoder->pos;\r\npkt_info.pkt_len = decoder->pkt_step;\r\npkt_info.last_packet_type = decoder->last_packet_type;\r\npkt_info.data = data;\r\nwhile (1) {\r\ndo {\r\npkt_info.pos += pkt_info.pkt_len;\r\nbuf += pkt_info.pkt_len;\r\nlen -= pkt_info.pkt_len;\r\nif (!len)\r\nreturn INTEL_PT_NEED_MORE_BYTES;\r\nret = intel_pt_get_packet(buf, len, &pkt_info.packet);\r\nif (!ret)\r\nreturn INTEL_PT_NEED_MORE_BYTES;\r\nif (ret < 0)\r\nreturn ret;\r\npkt_info.pkt_len = ret;\r\n} while (pkt_info.packet.type == INTEL_PT_PAD);\r\nret = cb(&pkt_info);\r\nif (ret)\r\nreturn 0;\r\npkt_info.last_packet_type = pkt_info.packet.type;\r\n}\r\n}\r\nstatic void intel_pt_fixup_last_mtc(uint32_t mtc, int mtc_shift,\r\nuint32_t *last_mtc)\r\n{\r\nuint32_t first_missing_bit = 1U << (16 - mtc_shift);\r\nuint32_t mask = ~(first_missing_bit - 1);\r\n*last_mtc |= mtc & mask;\r\nif (*last_mtc >= mtc) {\r\n*last_mtc -= first_missing_bit;\r\n*last_mtc &= 0xff;\r\n}\r\n}\r\nstatic int intel_pt_calc_cyc_cb(struct intel_pt_pkt_info *pkt_info)\r\n{\r\nstruct intel_pt_decoder *decoder = pkt_info->decoder;\r\nstruct intel_pt_calc_cyc_to_tsc_info *data = pkt_info->data;\r\nuint64_t timestamp;\r\ndouble cyc_to_tsc;\r\nunsigned int cbr;\r\nuint32_t mtc, mtc_delta, ctc, fc, ctc_rem;\r\nswitch (pkt_info->packet.type) {\r\ncase INTEL_PT_TNT:\r\ncase INTEL_PT_TIP_PGE:\r\ncase INTEL_PT_TIP:\r\ncase INTEL_PT_FUP:\r\ncase INTEL_PT_PSB:\r\ncase INTEL_PT_PIP:\r\ncase INTEL_PT_MODE_EXEC:\r\ncase INTEL_PT_MODE_TSX:\r\ncase INTEL_PT_PSBEND:\r\ncase INTEL_PT_PAD:\r\ncase INTEL_PT_VMCS:\r\ncase INTEL_PT_MNT:\r\ncase INTEL_PT_PTWRITE:\r\ncase INTEL_PT_PTWRITE_IP:\r\nreturn 0;\r\ncase INTEL_PT_MTC:\r\nif (!data->have_tma)\r\nreturn 0;\r\nmtc = pkt_info->packet.payload;\r\nif (decoder->mtc_shift > 8 && data->fixup_last_mtc) {\r\ndata->fixup_last_mtc = false;\r\nintel_pt_fixup_last_mtc(mtc, decoder->mtc_shift,\r\n&data->last_mtc);\r\n}\r\nif (mtc > data->last_mtc)\r\nmtc_delta = mtc - data->last_mtc;\r\nelse\r\nmtc_delta = mtc + 256 - data->last_mtc;\r\ndata->ctc_delta += mtc_delta << decoder->mtc_shift;\r\ndata->last_mtc = mtc;\r\nif (decoder->tsc_ctc_mult) {\r\ntimestamp = data->ctc_timestamp +\r\ndata->ctc_delta * decoder->tsc_ctc_mult;\r\n} else {\r\ntimestamp = data->ctc_timestamp +\r\nmultdiv(data->ctc_delta,\r\ndecoder->tsc_ctc_ratio_n,\r\ndecoder->tsc_ctc_ratio_d);\r\n}\r\nif (timestamp < data->timestamp)\r\nreturn 1;\r\nif (pkt_info->last_packet_type != INTEL_PT_CYC) {\r\ndata->timestamp = timestamp;\r\nreturn 0;\r\n}\r\nbreak;\r\ncase INTEL_PT_TSC:\r\nif (data->from_mtc)\r\nreturn 1;\r\ntimestamp = pkt_info->packet.payload |\r\n(data->timestamp & (0xffULL << 56));\r\nif (data->from_mtc && timestamp < data->timestamp &&\r\ndata->timestamp - timestamp < decoder->tsc_slip)\r\nreturn 1;\r\nif (timestamp < data->timestamp)\r\ntimestamp += (1ULL << 56);\r\nif (pkt_info->last_packet_type != INTEL_PT_CYC) {\r\nif (data->from_mtc)\r\nreturn 1;\r\ndata->tsc_timestamp = timestamp;\r\ndata->timestamp = timestamp;\r\nreturn 0;\r\n}\r\nbreak;\r\ncase INTEL_PT_TMA:\r\nif (data->from_mtc)\r\nreturn 1;\r\nif (!decoder->tsc_ctc_ratio_d)\r\nreturn 0;\r\nctc = pkt_info->packet.payload;\r\nfc = pkt_info->packet.count;\r\nctc_rem = ctc & decoder->ctc_rem_mask;\r\ndata->last_mtc = (ctc >> decoder->mtc_shift) & 0xff;\r\ndata->ctc_timestamp = data->tsc_timestamp - fc;\r\nif (decoder->tsc_ctc_mult) {\r\ndata->ctc_timestamp -= ctc_rem * decoder->tsc_ctc_mult;\r\n} else {\r\ndata->ctc_timestamp -=\r\nmultdiv(ctc_rem, decoder->tsc_ctc_ratio_n,\r\ndecoder->tsc_ctc_ratio_d);\r\n}\r\ndata->ctc_delta = 0;\r\ndata->have_tma = true;\r\ndata->fixup_last_mtc = true;\r\nreturn 0;\r\ncase INTEL_PT_CYC:\r\ndata->cycle_cnt += pkt_info->packet.payload;\r\nreturn 0;\r\ncase INTEL_PT_CBR:\r\ncbr = pkt_info->packet.payload;\r\nif (data->cbr && data->cbr != cbr)\r\nreturn 1;\r\ndata->cbr = cbr;\r\ndata->cbr_cyc_to_tsc = decoder->max_non_turbo_ratio_fp / cbr;\r\nreturn 0;\r\ncase INTEL_PT_TIP_PGD:\r\ncase INTEL_PT_TRACESTOP:\r\ncase INTEL_PT_EXSTOP:\r\ncase INTEL_PT_EXSTOP_IP:\r\ncase INTEL_PT_MWAIT:\r\ncase INTEL_PT_PWRE:\r\ncase INTEL_PT_PWRX:\r\ncase INTEL_PT_OVF:\r\ncase INTEL_PT_BAD:\r\ndefault:\r\nreturn 1;\r\n}\r\nif (!data->cbr && decoder->cbr) {\r\ndata->cbr = decoder->cbr;\r\ndata->cbr_cyc_to_tsc = decoder->cbr_cyc_to_tsc;\r\n}\r\nif (!data->cycle_cnt)\r\nreturn 1;\r\ncyc_to_tsc = (double)(timestamp - decoder->timestamp) / data->cycle_cnt;\r\nif (data->cbr && cyc_to_tsc > data->cbr_cyc_to_tsc &&\r\ncyc_to_tsc / data->cbr_cyc_to_tsc > 1.25) {\r\nintel_pt_log("Timestamp: calculated %g TSC ticks per cycle too big (c.f. CBR-based value %g), pos " x64_fmt "\n",\r\ncyc_to_tsc, data->cbr_cyc_to_tsc, pkt_info->pos);\r\nreturn 1;\r\n}\r\ndecoder->calc_cyc_to_tsc = cyc_to_tsc;\r\ndecoder->have_calc_cyc_to_tsc = true;\r\nif (data->cbr) {\r\nintel_pt_log("Timestamp: calculated %g TSC ticks per cycle c.f. CBR-based value %g, pos " x64_fmt "\n",\r\ncyc_to_tsc, data->cbr_cyc_to_tsc, pkt_info->pos);\r\n} else {\r\nintel_pt_log("Timestamp: calculated %g TSC ticks per cycle c.f. unknown CBR-based value, pos " x64_fmt "\n",\r\ncyc_to_tsc, pkt_info->pos);\r\n}\r\nreturn 1;\r\n}\r\nstatic void intel_pt_calc_cyc_to_tsc(struct intel_pt_decoder *decoder,\r\nbool from_mtc)\r\n{\r\nstruct intel_pt_calc_cyc_to_tsc_info data = {\r\n.cycle_cnt = 0,\r\n.cbr = 0,\r\n.last_mtc = decoder->last_mtc,\r\n.ctc_timestamp = decoder->ctc_timestamp,\r\n.ctc_delta = decoder->ctc_delta,\r\n.tsc_timestamp = decoder->tsc_timestamp,\r\n.timestamp = decoder->timestamp,\r\n.have_tma = decoder->have_tma,\r\n.fixup_last_mtc = decoder->fixup_last_mtc,\r\n.from_mtc = from_mtc,\r\n.cbr_cyc_to_tsc = 0,\r\n};\r\nif (!from_mtc)\r\nreturn;\r\nintel_pt_pkt_lookahead(decoder, intel_pt_calc_cyc_cb, &data);\r\n}\r\nstatic int intel_pt_get_next_packet(struct intel_pt_decoder *decoder)\r\n{\r\nint ret;\r\ndecoder->last_packet_type = decoder->packet.type;\r\ndo {\r\ndecoder->pos += decoder->pkt_step;\r\ndecoder->buf += decoder->pkt_step;\r\ndecoder->len -= decoder->pkt_step;\r\nif (!decoder->len) {\r\nret = intel_pt_get_next_data(decoder);\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = intel_pt_get_packet(decoder->buf, decoder->len,\r\n&decoder->packet);\r\nif (ret == INTEL_PT_NEED_MORE_BYTES &&\r\ndecoder->len < INTEL_PT_PKT_MAX_SZ && !decoder->next_buf) {\r\nret = intel_pt_get_split_packet(decoder);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (ret <= 0)\r\nreturn intel_pt_bad_packet(decoder);\r\ndecoder->pkt_len = ret;\r\ndecoder->pkt_step = ret;\r\nintel_pt_decoder_log_packet(decoder);\r\n} while (decoder->packet.type == INTEL_PT_PAD);\r\nreturn 0;\r\n}\r\nstatic uint64_t intel_pt_next_period(struct intel_pt_decoder *decoder)\r\n{\r\nuint64_t timestamp, masked_timestamp;\r\ntimestamp = decoder->timestamp + decoder->timestamp_insn_cnt;\r\nmasked_timestamp = timestamp & decoder->period_mask;\r\nif (decoder->continuous_period) {\r\nif (masked_timestamp != decoder->last_masked_timestamp)\r\nreturn 1;\r\n} else {\r\ntimestamp += 1;\r\nmasked_timestamp = timestamp & decoder->period_mask;\r\nif (masked_timestamp != decoder->last_masked_timestamp) {\r\ndecoder->last_masked_timestamp = masked_timestamp;\r\ndecoder->continuous_period = true;\r\n}\r\n}\r\nreturn decoder->period_ticks - (timestamp - masked_timestamp);\r\n}\r\nstatic uint64_t intel_pt_next_sample(struct intel_pt_decoder *decoder)\r\n{\r\nswitch (decoder->period_type) {\r\ncase INTEL_PT_PERIOD_INSTRUCTIONS:\r\nreturn decoder->period - decoder->period_insn_cnt;\r\ncase INTEL_PT_PERIOD_TICKS:\r\nreturn intel_pt_next_period(decoder);\r\ncase INTEL_PT_PERIOD_NONE:\r\ncase INTEL_PT_PERIOD_MTC:\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic void intel_pt_sample_insn(struct intel_pt_decoder *decoder)\r\n{\r\nuint64_t timestamp, masked_timestamp;\r\nswitch (decoder->period_type) {\r\ncase INTEL_PT_PERIOD_INSTRUCTIONS:\r\ndecoder->period_insn_cnt = 0;\r\nbreak;\r\ncase INTEL_PT_PERIOD_TICKS:\r\ntimestamp = decoder->timestamp + decoder->timestamp_insn_cnt;\r\nmasked_timestamp = timestamp & decoder->period_mask;\r\ndecoder->last_masked_timestamp = masked_timestamp;\r\nbreak;\r\ncase INTEL_PT_PERIOD_NONE:\r\ncase INTEL_PT_PERIOD_MTC:\r\ndefault:\r\nbreak;\r\n}\r\ndecoder->state.type |= INTEL_PT_INSTRUCTION;\r\n}\r\nstatic int intel_pt_walk_insn(struct intel_pt_decoder *decoder,\r\nstruct intel_pt_insn *intel_pt_insn, uint64_t ip)\r\n{\r\nuint64_t max_insn_cnt, insn_cnt = 0;\r\nint err;\r\nif (!decoder->mtc_insn)\r\ndecoder->mtc_insn = true;\r\nmax_insn_cnt = intel_pt_next_sample(decoder);\r\nerr = decoder->walk_insn(intel_pt_insn, &insn_cnt, &decoder->ip, ip,\r\nmax_insn_cnt, decoder->data);\r\ndecoder->tot_insn_cnt += insn_cnt;\r\ndecoder->timestamp_insn_cnt += insn_cnt;\r\ndecoder->sample_insn_cnt += insn_cnt;\r\ndecoder->period_insn_cnt += insn_cnt;\r\nif (err) {\r\ndecoder->no_progress = 0;\r\ndecoder->pkt_state = INTEL_PT_STATE_ERR2;\r\nintel_pt_log_at("ERROR: Failed to get instruction",\r\ndecoder->ip);\r\nif (err == -ENOENT)\r\nreturn -ENOLINK;\r\nreturn -EILSEQ;\r\n}\r\nif (ip && decoder->ip == ip) {\r\nerr = -EAGAIN;\r\ngoto out;\r\n}\r\nif (max_insn_cnt && insn_cnt >= max_insn_cnt)\r\nintel_pt_sample_insn(decoder);\r\nif (intel_pt_insn->branch == INTEL_PT_BR_NO_BRANCH) {\r\ndecoder->state.type = INTEL_PT_INSTRUCTION;\r\ndecoder->state.from_ip = decoder->ip;\r\ndecoder->state.to_ip = 0;\r\ndecoder->ip += intel_pt_insn->length;\r\nerr = INTEL_PT_RETURN;\r\ngoto out;\r\n}\r\nif (intel_pt_insn->op == INTEL_PT_OP_CALL) {\r\nif (intel_pt_insn->branch != INTEL_PT_BR_UNCONDITIONAL ||\r\nintel_pt_insn->rel) {\r\nerr = intel_pt_push(&decoder->stack, decoder->ip +\r\nintel_pt_insn->length);\r\nif (err)\r\ngoto out;\r\n}\r\n} else if (intel_pt_insn->op == INTEL_PT_OP_RET) {\r\ndecoder->ret_addr = intel_pt_pop(&decoder->stack);\r\n}\r\nif (intel_pt_insn->branch == INTEL_PT_BR_UNCONDITIONAL) {\r\nint cnt = decoder->no_progress++;\r\ndecoder->state.from_ip = decoder->ip;\r\ndecoder->ip += intel_pt_insn->length +\r\nintel_pt_insn->rel;\r\ndecoder->state.to_ip = decoder->ip;\r\nerr = INTEL_PT_RETURN;\r\nif (cnt) {\r\nif (cnt == 1) {\r\ndecoder->stuck_ip = decoder->state.to_ip;\r\ndecoder->stuck_ip_prd = 1;\r\ndecoder->stuck_ip_cnt = 1;\r\n} else if (cnt > INTEL_PT_MAX_LOOPS ||\r\ndecoder->state.to_ip == decoder->stuck_ip) {\r\nintel_pt_log_at("ERROR: Never-ending loop",\r\ndecoder->state.to_ip);\r\ndecoder->pkt_state = INTEL_PT_STATE_ERR_RESYNC;\r\nerr = -ELOOP;\r\ngoto out;\r\n} else if (!--decoder->stuck_ip_cnt) {\r\ndecoder->stuck_ip_prd += 1;\r\ndecoder->stuck_ip_cnt = decoder->stuck_ip_prd;\r\ndecoder->stuck_ip = decoder->state.to_ip;\r\n}\r\n}\r\ngoto out_no_progress;\r\n}\r\nout:\r\ndecoder->no_progress = 0;\r\nout_no_progress:\r\ndecoder->state.insn_op = intel_pt_insn->op;\r\ndecoder->state.insn_len = intel_pt_insn->length;\r\nmemcpy(decoder->state.insn, intel_pt_insn->buf,\r\nINTEL_PT_INSN_BUF_SZ);\r\nif (decoder->tx_flags & INTEL_PT_IN_TX)\r\ndecoder->state.flags |= INTEL_PT_IN_TX;\r\nreturn err;\r\n}\r\nstatic bool intel_pt_fup_event(struct intel_pt_decoder *decoder)\r\n{\r\nbool ret = false;\r\nif (decoder->set_fup_tx_flags) {\r\ndecoder->set_fup_tx_flags = false;\r\ndecoder->tx_flags = decoder->fup_tx_flags;\r\ndecoder->state.type = INTEL_PT_TRANSACTION;\r\ndecoder->state.from_ip = decoder->ip;\r\ndecoder->state.to_ip = 0;\r\ndecoder->state.flags = decoder->fup_tx_flags;\r\nreturn true;\r\n}\r\nif (decoder->set_fup_ptw) {\r\ndecoder->set_fup_ptw = false;\r\ndecoder->state.type = INTEL_PT_PTW;\r\ndecoder->state.flags |= INTEL_PT_FUP_IP;\r\ndecoder->state.from_ip = decoder->ip;\r\ndecoder->state.to_ip = 0;\r\ndecoder->state.ptw_payload = decoder->fup_ptw_payload;\r\nreturn true;\r\n}\r\nif (decoder->set_fup_mwait) {\r\ndecoder->set_fup_mwait = false;\r\ndecoder->state.type = INTEL_PT_MWAIT_OP;\r\ndecoder->state.from_ip = decoder->ip;\r\ndecoder->state.to_ip = 0;\r\ndecoder->state.mwait_payload = decoder->fup_mwait_payload;\r\nret = true;\r\n}\r\nif (decoder->set_fup_pwre) {\r\ndecoder->set_fup_pwre = false;\r\ndecoder->state.type |= INTEL_PT_PWR_ENTRY;\r\ndecoder->state.type &= ~INTEL_PT_BRANCH;\r\ndecoder->state.from_ip = decoder->ip;\r\ndecoder->state.to_ip = 0;\r\ndecoder->state.pwre_payload = decoder->fup_pwre_payload;\r\nret = true;\r\n}\r\nif (decoder->set_fup_exstop) {\r\ndecoder->set_fup_exstop = false;\r\ndecoder->state.type |= INTEL_PT_EX_STOP;\r\ndecoder->state.type &= ~INTEL_PT_BRANCH;\r\ndecoder->state.flags |= INTEL_PT_FUP_IP;\r\ndecoder->state.from_ip = decoder->ip;\r\ndecoder->state.to_ip = 0;\r\nret = true;\r\n}\r\nreturn ret;\r\n}\r\nstatic int intel_pt_walk_fup(struct intel_pt_decoder *decoder)\r\n{\r\nstruct intel_pt_insn intel_pt_insn;\r\nuint64_t ip;\r\nint err;\r\nip = decoder->last_ip;\r\nwhile (1) {\r\nerr = intel_pt_walk_insn(decoder, &intel_pt_insn, ip);\r\nif (err == INTEL_PT_RETURN)\r\nreturn 0;\r\nif (err == -EAGAIN) {\r\nif (intel_pt_fup_event(decoder))\r\nreturn 0;\r\nreturn err;\r\n}\r\ndecoder->set_fup_tx_flags = false;\r\nif (err)\r\nreturn err;\r\nif (intel_pt_insn.branch == INTEL_PT_BR_INDIRECT) {\r\nintel_pt_log_at("ERROR: Unexpected indirect branch",\r\ndecoder->ip);\r\ndecoder->pkt_state = INTEL_PT_STATE_ERR_RESYNC;\r\nreturn -ENOENT;\r\n}\r\nif (intel_pt_insn.branch == INTEL_PT_BR_CONDITIONAL) {\r\nintel_pt_log_at("ERROR: Unexpected conditional branch",\r\ndecoder->ip);\r\ndecoder->pkt_state = INTEL_PT_STATE_ERR_RESYNC;\r\nreturn -ENOENT;\r\n}\r\nintel_pt_bug(decoder);\r\n}\r\n}\r\nstatic int intel_pt_walk_tip(struct intel_pt_decoder *decoder)\r\n{\r\nstruct intel_pt_insn intel_pt_insn;\r\nint err;\r\nerr = intel_pt_walk_insn(decoder, &intel_pt_insn, 0);\r\nif (err == INTEL_PT_RETURN &&\r\ndecoder->pgd_ip &&\r\ndecoder->pkt_state == INTEL_PT_STATE_TIP_PGD &&\r\n(decoder->state.type & INTEL_PT_BRANCH) &&\r\ndecoder->pgd_ip(decoder->state.to_ip, decoder->data)) {\r\ndecoder->no_progress = 0;\r\ndecoder->pge = false;\r\ndecoder->continuous_period = false;\r\ndecoder->pkt_state = INTEL_PT_STATE_IN_SYNC;\r\ndecoder->state.to_ip = 0;\r\nreturn 0;\r\n}\r\nif (err == INTEL_PT_RETURN)\r\nreturn 0;\r\nif (err)\r\nreturn err;\r\nif (intel_pt_insn.branch == INTEL_PT_BR_INDIRECT) {\r\nif (decoder->pkt_state == INTEL_PT_STATE_TIP_PGD) {\r\ndecoder->pge = false;\r\ndecoder->continuous_period = false;\r\ndecoder->pkt_state = INTEL_PT_STATE_IN_SYNC;\r\ndecoder->state.from_ip = decoder->ip;\r\ndecoder->state.to_ip = 0;\r\nif (decoder->packet.count != 0)\r\ndecoder->ip = decoder->last_ip;\r\n} else {\r\ndecoder->pkt_state = INTEL_PT_STATE_IN_SYNC;\r\ndecoder->state.from_ip = decoder->ip;\r\nif (decoder->packet.count == 0) {\r\ndecoder->state.to_ip = 0;\r\n} else {\r\ndecoder->state.to_ip = decoder->last_ip;\r\ndecoder->ip = decoder->last_ip;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nif (intel_pt_insn.branch == INTEL_PT_BR_CONDITIONAL) {\r\nuint64_t to_ip = decoder->ip + intel_pt_insn.length +\r\nintel_pt_insn.rel;\r\nif (decoder->pgd_ip &&\r\ndecoder->pkt_state == INTEL_PT_STATE_TIP_PGD &&\r\ndecoder->pgd_ip(to_ip, decoder->data)) {\r\ndecoder->pge = false;\r\ndecoder->continuous_period = false;\r\ndecoder->pkt_state = INTEL_PT_STATE_IN_SYNC;\r\ndecoder->ip = to_ip;\r\ndecoder->state.from_ip = decoder->ip;\r\ndecoder->state.to_ip = 0;\r\nreturn 0;\r\n}\r\nintel_pt_log_at("ERROR: Conditional branch when expecting indirect branch",\r\ndecoder->ip);\r\ndecoder->pkt_state = INTEL_PT_STATE_ERR_RESYNC;\r\nreturn -ENOENT;\r\n}\r\nreturn intel_pt_bug(decoder);\r\n}\r\nstatic int intel_pt_walk_tnt(struct intel_pt_decoder *decoder)\r\n{\r\nstruct intel_pt_insn intel_pt_insn;\r\nint err;\r\nwhile (1) {\r\nerr = intel_pt_walk_insn(decoder, &intel_pt_insn, 0);\r\nif (err == INTEL_PT_RETURN)\r\nreturn 0;\r\nif (err)\r\nreturn err;\r\nif (intel_pt_insn.op == INTEL_PT_OP_RET) {\r\nif (!decoder->return_compression) {\r\nintel_pt_log_at("ERROR: RET when expecting conditional branch",\r\ndecoder->ip);\r\ndecoder->pkt_state = INTEL_PT_STATE_ERR3;\r\nreturn -ENOENT;\r\n}\r\nif (!decoder->ret_addr) {\r\nintel_pt_log_at("ERROR: Bad RET compression (stack empty)",\r\ndecoder->ip);\r\ndecoder->pkt_state = INTEL_PT_STATE_ERR3;\r\nreturn -ENOENT;\r\n}\r\nif (!(decoder->tnt.payload & BIT63)) {\r\nintel_pt_log_at("ERROR: Bad RET compression (TNT=N)",\r\ndecoder->ip);\r\ndecoder->pkt_state = INTEL_PT_STATE_ERR3;\r\nreturn -ENOENT;\r\n}\r\ndecoder->tnt.count -= 1;\r\nif (!decoder->tnt.count)\r\ndecoder->pkt_state = INTEL_PT_STATE_IN_SYNC;\r\ndecoder->tnt.payload <<= 1;\r\ndecoder->state.from_ip = decoder->ip;\r\ndecoder->ip = decoder->ret_addr;\r\ndecoder->state.to_ip = decoder->ip;\r\nreturn 0;\r\n}\r\nif (intel_pt_insn.branch == INTEL_PT_BR_INDIRECT) {\r\nerr = intel_pt_get_next_packet(decoder);\r\nif (err)\r\nreturn err;\r\nif (decoder->packet.type != INTEL_PT_TIP ||\r\ndecoder->packet.count == 0) {\r\nintel_pt_log_at("ERROR: Missing deferred TIP for indirect branch",\r\ndecoder->ip);\r\ndecoder->pkt_state = INTEL_PT_STATE_ERR3;\r\ndecoder->pkt_step = 0;\r\nreturn -ENOENT;\r\n}\r\nintel_pt_set_last_ip(decoder);\r\ndecoder->state.from_ip = decoder->ip;\r\ndecoder->state.to_ip = decoder->last_ip;\r\ndecoder->ip = decoder->last_ip;\r\nreturn 0;\r\n}\r\nif (intel_pt_insn.branch == INTEL_PT_BR_CONDITIONAL) {\r\ndecoder->tnt.count -= 1;\r\nif (!decoder->tnt.count)\r\ndecoder->pkt_state = INTEL_PT_STATE_IN_SYNC;\r\nif (decoder->tnt.payload & BIT63) {\r\ndecoder->tnt.payload <<= 1;\r\ndecoder->state.from_ip = decoder->ip;\r\ndecoder->ip += intel_pt_insn.length +\r\nintel_pt_insn.rel;\r\ndecoder->state.to_ip = decoder->ip;\r\nreturn 0;\r\n}\r\nif (decoder->state.type & INTEL_PT_INSTRUCTION) {\r\ndecoder->tnt.payload <<= 1;\r\ndecoder->state.type = INTEL_PT_INSTRUCTION;\r\ndecoder->state.from_ip = decoder->ip;\r\ndecoder->state.to_ip = 0;\r\ndecoder->ip += intel_pt_insn.length;\r\nreturn 0;\r\n}\r\ndecoder->ip += intel_pt_insn.length;\r\nif (!decoder->tnt.count)\r\nreturn -EAGAIN;\r\ndecoder->tnt.payload <<= 1;\r\ncontinue;\r\n}\r\nreturn intel_pt_bug(decoder);\r\n}\r\n}\r\nstatic int intel_pt_mode_tsx(struct intel_pt_decoder *decoder, bool *no_tip)\r\n{\r\nunsigned int fup_tx_flags;\r\nint err;\r\nfup_tx_flags = decoder->packet.payload &\r\n(INTEL_PT_IN_TX | INTEL_PT_ABORT_TX);\r\nerr = intel_pt_get_next_packet(decoder);\r\nif (err)\r\nreturn err;\r\nif (decoder->packet.type == INTEL_PT_FUP) {\r\ndecoder->fup_tx_flags = fup_tx_flags;\r\ndecoder->set_fup_tx_flags = true;\r\nif (!(decoder->fup_tx_flags & INTEL_PT_ABORT_TX))\r\n*no_tip = true;\r\n} else {\r\nintel_pt_log_at("ERROR: Missing FUP after MODE.TSX",\r\ndecoder->pos);\r\nintel_pt_update_in_tx(decoder);\r\n}\r\nreturn 0;\r\n}\r\nstatic void intel_pt_calc_tsc_timestamp(struct intel_pt_decoder *decoder)\r\n{\r\nuint64_t timestamp;\r\ndecoder->have_tma = false;\r\nif (decoder->ref_timestamp) {\r\ntimestamp = decoder->packet.payload |\r\n(decoder->ref_timestamp & (0xffULL << 56));\r\nif (timestamp < decoder->ref_timestamp) {\r\nif (decoder->ref_timestamp - timestamp > (1ULL << 55))\r\ntimestamp += (1ULL << 56);\r\n} else {\r\nif (timestamp - decoder->ref_timestamp > (1ULL << 55))\r\ntimestamp -= (1ULL << 56);\r\n}\r\ndecoder->tsc_timestamp = timestamp;\r\ndecoder->timestamp = timestamp;\r\ndecoder->ref_timestamp = 0;\r\ndecoder->timestamp_insn_cnt = 0;\r\n} else if (decoder->timestamp) {\r\ntimestamp = decoder->packet.payload |\r\n(decoder->timestamp & (0xffULL << 56));\r\ndecoder->tsc_timestamp = timestamp;\r\nif (timestamp < decoder->timestamp &&\r\ndecoder->timestamp - timestamp < decoder->tsc_slip) {\r\nintel_pt_log_to("Suppressing backwards timestamp",\r\ntimestamp);\r\ntimestamp = decoder->timestamp;\r\n}\r\nif (timestamp < decoder->timestamp) {\r\nintel_pt_log_to("Wraparound timestamp", timestamp);\r\ntimestamp += (1ULL << 56);\r\ndecoder->tsc_timestamp = timestamp;\r\n}\r\ndecoder->timestamp = timestamp;\r\ndecoder->timestamp_insn_cnt = 0;\r\n}\r\nif (decoder->last_packet_type == INTEL_PT_CYC) {\r\ndecoder->cyc_ref_timestamp = decoder->timestamp;\r\ndecoder->cycle_cnt = 0;\r\ndecoder->have_calc_cyc_to_tsc = false;\r\nintel_pt_calc_cyc_to_tsc(decoder, false);\r\n}\r\nintel_pt_log_to("Setting timestamp", decoder->timestamp);\r\n}\r\nstatic int intel_pt_overflow(struct intel_pt_decoder *decoder)\r\n{\r\nintel_pt_log("ERROR: Buffer overflow\n");\r\nintel_pt_clear_tx_flags(decoder);\r\ndecoder->have_tma = false;\r\ndecoder->cbr = 0;\r\ndecoder->pkt_state = INTEL_PT_STATE_ERR_RESYNC;\r\ndecoder->overflow = true;\r\nreturn -EOVERFLOW;\r\n}\r\nstatic void intel_pt_calc_tma(struct intel_pt_decoder *decoder)\r\n{\r\nuint32_t ctc = decoder->packet.payload;\r\nuint32_t fc = decoder->packet.count;\r\nuint32_t ctc_rem = ctc & decoder->ctc_rem_mask;\r\nif (!decoder->tsc_ctc_ratio_d)\r\nreturn;\r\ndecoder->last_mtc = (ctc >> decoder->mtc_shift) & 0xff;\r\ndecoder->ctc_timestamp = decoder->tsc_timestamp - fc;\r\nif (decoder->tsc_ctc_mult) {\r\ndecoder->ctc_timestamp -= ctc_rem * decoder->tsc_ctc_mult;\r\n} else {\r\ndecoder->ctc_timestamp -= multdiv(ctc_rem,\r\ndecoder->tsc_ctc_ratio_n,\r\ndecoder->tsc_ctc_ratio_d);\r\n}\r\ndecoder->ctc_delta = 0;\r\ndecoder->have_tma = true;\r\ndecoder->fixup_last_mtc = true;\r\nintel_pt_log("CTC timestamp " x64_fmt " last MTC %#x CTC rem %#x\n",\r\ndecoder->ctc_timestamp, decoder->last_mtc, ctc_rem);\r\n}\r\nstatic void intel_pt_calc_mtc_timestamp(struct intel_pt_decoder *decoder)\r\n{\r\nuint64_t timestamp;\r\nuint32_t mtc, mtc_delta;\r\nif (!decoder->have_tma)\r\nreturn;\r\nmtc = decoder->packet.payload;\r\nif (decoder->mtc_shift > 8 && decoder->fixup_last_mtc) {\r\ndecoder->fixup_last_mtc = false;\r\nintel_pt_fixup_last_mtc(mtc, decoder->mtc_shift,\r\n&decoder->last_mtc);\r\n}\r\nif (mtc > decoder->last_mtc)\r\nmtc_delta = mtc - decoder->last_mtc;\r\nelse\r\nmtc_delta = mtc + 256 - decoder->last_mtc;\r\ndecoder->ctc_delta += mtc_delta << decoder->mtc_shift;\r\nif (decoder->tsc_ctc_mult) {\r\ntimestamp = decoder->ctc_timestamp +\r\ndecoder->ctc_delta * decoder->tsc_ctc_mult;\r\n} else {\r\ntimestamp = decoder->ctc_timestamp +\r\nmultdiv(decoder->ctc_delta,\r\ndecoder->tsc_ctc_ratio_n,\r\ndecoder->tsc_ctc_ratio_d);\r\n}\r\nif (timestamp < decoder->timestamp)\r\nintel_pt_log("Suppressing MTC timestamp " x64_fmt " less than current timestamp " x64_fmt "\n",\r\ntimestamp, decoder->timestamp);\r\nelse\r\ndecoder->timestamp = timestamp;\r\ndecoder->timestamp_insn_cnt = 0;\r\ndecoder->last_mtc = mtc;\r\nif (decoder->last_packet_type == INTEL_PT_CYC) {\r\ndecoder->cyc_ref_timestamp = decoder->timestamp;\r\ndecoder->cycle_cnt = 0;\r\ndecoder->have_calc_cyc_to_tsc = false;\r\nintel_pt_calc_cyc_to_tsc(decoder, true);\r\n}\r\n}\r\nstatic void intel_pt_calc_cbr(struct intel_pt_decoder *decoder)\r\n{\r\nunsigned int cbr = decoder->packet.payload & 0xff;\r\ndecoder->cbr_payload = decoder->packet.payload;\r\nif (decoder->cbr == cbr)\r\nreturn;\r\ndecoder->cbr = cbr;\r\ndecoder->cbr_cyc_to_tsc = decoder->max_non_turbo_ratio_fp / cbr;\r\n}\r\nstatic void intel_pt_calc_cyc_timestamp(struct intel_pt_decoder *decoder)\r\n{\r\nuint64_t timestamp = decoder->cyc_ref_timestamp;\r\ndecoder->have_cyc = true;\r\ndecoder->cycle_cnt += decoder->packet.payload;\r\nif (!decoder->cyc_ref_timestamp)\r\nreturn;\r\nif (decoder->have_calc_cyc_to_tsc)\r\ntimestamp += decoder->cycle_cnt * decoder->calc_cyc_to_tsc;\r\nelse if (decoder->cbr)\r\ntimestamp += decoder->cycle_cnt * decoder->cbr_cyc_to_tsc;\r\nelse\r\nreturn;\r\nif (timestamp < decoder->timestamp)\r\nintel_pt_log("Suppressing CYC timestamp " x64_fmt " less than current timestamp " x64_fmt "\n",\r\ntimestamp, decoder->timestamp);\r\nelse\r\ndecoder->timestamp = timestamp;\r\ndecoder->timestamp_insn_cnt = 0;\r\n}\r\nstatic int intel_pt_walk_psbend(struct intel_pt_decoder *decoder)\r\n{\r\nint err;\r\nwhile (1) {\r\nerr = intel_pt_get_next_packet(decoder);\r\nif (err)\r\nreturn err;\r\nswitch (decoder->packet.type) {\r\ncase INTEL_PT_PSBEND:\r\nreturn 0;\r\ncase INTEL_PT_TIP_PGD:\r\ncase INTEL_PT_TIP_PGE:\r\ncase INTEL_PT_TIP:\r\ncase INTEL_PT_TNT:\r\ncase INTEL_PT_TRACESTOP:\r\ncase INTEL_PT_BAD:\r\ncase INTEL_PT_PSB:\r\ncase INTEL_PT_PTWRITE:\r\ncase INTEL_PT_PTWRITE_IP:\r\ncase INTEL_PT_EXSTOP:\r\ncase INTEL_PT_EXSTOP_IP:\r\ncase INTEL_PT_MWAIT:\r\ncase INTEL_PT_PWRE:\r\ncase INTEL_PT_PWRX:\r\ndecoder->have_tma = false;\r\nintel_pt_log("ERROR: Unexpected packet\n");\r\nreturn -EAGAIN;\r\ncase INTEL_PT_OVF:\r\nreturn intel_pt_overflow(decoder);\r\ncase INTEL_PT_TSC:\r\nintel_pt_calc_tsc_timestamp(decoder);\r\nbreak;\r\ncase INTEL_PT_TMA:\r\nintel_pt_calc_tma(decoder);\r\nbreak;\r\ncase INTEL_PT_CBR:\r\nintel_pt_calc_cbr(decoder);\r\nbreak;\r\ncase INTEL_PT_MODE_EXEC:\r\ndecoder->exec_mode = decoder->packet.payload;\r\nbreak;\r\ncase INTEL_PT_PIP:\r\ndecoder->cr3 = decoder->packet.payload & (BIT63 - 1);\r\nbreak;\r\ncase INTEL_PT_FUP:\r\ndecoder->pge = true;\r\nif (decoder->packet.count)\r\nintel_pt_set_last_ip(decoder);\r\nbreak;\r\ncase INTEL_PT_MODE_TSX:\r\nintel_pt_update_in_tx(decoder);\r\nbreak;\r\ncase INTEL_PT_MTC:\r\nintel_pt_calc_mtc_timestamp(decoder);\r\nif (decoder->period_type == INTEL_PT_PERIOD_MTC)\r\ndecoder->state.type |= INTEL_PT_INSTRUCTION;\r\nbreak;\r\ncase INTEL_PT_CYC:\r\ncase INTEL_PT_VMCS:\r\ncase INTEL_PT_MNT:\r\ncase INTEL_PT_PAD:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int intel_pt_walk_fup_tip(struct intel_pt_decoder *decoder)\r\n{\r\nint err;\r\nif (decoder->tx_flags & INTEL_PT_ABORT_TX) {\r\ndecoder->tx_flags = 0;\r\ndecoder->state.flags &= ~INTEL_PT_IN_TX;\r\ndecoder->state.flags |= INTEL_PT_ABORT_TX;\r\n} else {\r\ndecoder->state.flags |= INTEL_PT_ASYNC;\r\n}\r\nwhile (1) {\r\nerr = intel_pt_get_next_packet(decoder);\r\nif (err)\r\nreturn err;\r\nswitch (decoder->packet.type) {\r\ncase INTEL_PT_TNT:\r\ncase INTEL_PT_FUP:\r\ncase INTEL_PT_TRACESTOP:\r\ncase INTEL_PT_PSB:\r\ncase INTEL_PT_TSC:\r\ncase INTEL_PT_TMA:\r\ncase INTEL_PT_CBR:\r\ncase INTEL_PT_MODE_TSX:\r\ncase INTEL_PT_BAD:\r\ncase INTEL_PT_PSBEND:\r\ncase INTEL_PT_PTWRITE:\r\ncase INTEL_PT_PTWRITE_IP:\r\ncase INTEL_PT_EXSTOP:\r\ncase INTEL_PT_EXSTOP_IP:\r\ncase INTEL_PT_MWAIT:\r\ncase INTEL_PT_PWRE:\r\ncase INTEL_PT_PWRX:\r\nintel_pt_log("ERROR: Missing TIP after FUP\n");\r\ndecoder->pkt_state = INTEL_PT_STATE_ERR3;\r\nreturn -ENOENT;\r\ncase INTEL_PT_OVF:\r\nreturn intel_pt_overflow(decoder);\r\ncase INTEL_PT_TIP_PGD:\r\ndecoder->state.from_ip = decoder->ip;\r\ndecoder->state.to_ip = 0;\r\nif (decoder->packet.count != 0) {\r\nintel_pt_set_ip(decoder);\r\nintel_pt_log("Omitting PGD ip " x64_fmt "\n",\r\ndecoder->ip);\r\n}\r\ndecoder->pge = false;\r\ndecoder->continuous_period = false;\r\nreturn 0;\r\ncase INTEL_PT_TIP_PGE:\r\ndecoder->pge = true;\r\nintel_pt_log("Omitting PGE ip " x64_fmt "\n",\r\ndecoder->ip);\r\ndecoder->state.from_ip = 0;\r\nif (decoder->packet.count == 0) {\r\ndecoder->state.to_ip = 0;\r\n} else {\r\nintel_pt_set_ip(decoder);\r\ndecoder->state.to_ip = decoder->ip;\r\n}\r\nreturn 0;\r\ncase INTEL_PT_TIP:\r\ndecoder->state.from_ip = decoder->ip;\r\nif (decoder->packet.count == 0) {\r\ndecoder->state.to_ip = 0;\r\n} else {\r\nintel_pt_set_ip(decoder);\r\ndecoder->state.to_ip = decoder->ip;\r\n}\r\nreturn 0;\r\ncase INTEL_PT_PIP:\r\ndecoder->cr3 = decoder->packet.payload & (BIT63 - 1);\r\nbreak;\r\ncase INTEL_PT_MTC:\r\nintel_pt_calc_mtc_timestamp(decoder);\r\nif (decoder->period_type == INTEL_PT_PERIOD_MTC)\r\ndecoder->state.type |= INTEL_PT_INSTRUCTION;\r\nbreak;\r\ncase INTEL_PT_CYC:\r\nintel_pt_calc_cyc_timestamp(decoder);\r\nbreak;\r\ncase INTEL_PT_MODE_EXEC:\r\ndecoder->exec_mode = decoder->packet.payload;\r\nbreak;\r\ncase INTEL_PT_VMCS:\r\ncase INTEL_PT_MNT:\r\ncase INTEL_PT_PAD:\r\nbreak;\r\ndefault:\r\nreturn intel_pt_bug(decoder);\r\n}\r\n}\r\n}\r\nstatic int intel_pt_walk_trace(struct intel_pt_decoder *decoder)\r\n{\r\nbool no_tip = false;\r\nint err;\r\nwhile (1) {\r\nerr = intel_pt_get_next_packet(decoder);\r\nif (err)\r\nreturn err;\r\nnext:\r\nswitch (decoder->packet.type) {\r\ncase INTEL_PT_TNT:\r\nif (!decoder->packet.count)\r\nbreak;\r\ndecoder->tnt = decoder->packet;\r\ndecoder->pkt_state = INTEL_PT_STATE_TNT;\r\nerr = intel_pt_walk_tnt(decoder);\r\nif (err == -EAGAIN)\r\nbreak;\r\nreturn err;\r\ncase INTEL_PT_TIP_PGD:\r\nif (decoder->packet.count != 0)\r\nintel_pt_set_last_ip(decoder);\r\ndecoder->pkt_state = INTEL_PT_STATE_TIP_PGD;\r\nreturn intel_pt_walk_tip(decoder);\r\ncase INTEL_PT_TIP_PGE: {\r\ndecoder->pge = true;\r\nif (decoder->packet.count == 0) {\r\nintel_pt_log_at("Skipping zero TIP.PGE",\r\ndecoder->pos);\r\nbreak;\r\n}\r\nintel_pt_set_ip(decoder);\r\ndecoder->state.from_ip = 0;\r\ndecoder->state.to_ip = decoder->ip;\r\nreturn 0;\r\n}\r\ncase INTEL_PT_OVF:\r\nreturn intel_pt_overflow(decoder);\r\ncase INTEL_PT_TIP:\r\nif (decoder->packet.count != 0)\r\nintel_pt_set_last_ip(decoder);\r\ndecoder->pkt_state = INTEL_PT_STATE_TIP;\r\nreturn intel_pt_walk_tip(decoder);\r\ncase INTEL_PT_FUP:\r\nif (decoder->packet.count == 0) {\r\nintel_pt_log_at("Skipping zero FUP",\r\ndecoder->pos);\r\nno_tip = false;\r\nbreak;\r\n}\r\nintel_pt_set_last_ip(decoder);\r\nif (!decoder->branch_enable) {\r\ndecoder->ip = decoder->last_ip;\r\nif (intel_pt_fup_event(decoder))\r\nreturn 0;\r\nno_tip = false;\r\nbreak;\r\n}\r\nif (decoder->set_fup_mwait)\r\nno_tip = true;\r\nerr = intel_pt_walk_fup(decoder);\r\nif (err != -EAGAIN) {\r\nif (err)\r\nreturn err;\r\nif (no_tip)\r\ndecoder->pkt_state =\r\nINTEL_PT_STATE_FUP_NO_TIP;\r\nelse\r\ndecoder->pkt_state = INTEL_PT_STATE_FUP;\r\nreturn 0;\r\n}\r\nif (no_tip) {\r\nno_tip = false;\r\nbreak;\r\n}\r\nreturn intel_pt_walk_fup_tip(decoder);\r\ncase INTEL_PT_TRACESTOP:\r\ndecoder->pge = false;\r\ndecoder->continuous_period = false;\r\nintel_pt_clear_tx_flags(decoder);\r\ndecoder->have_tma = false;\r\nbreak;\r\ncase INTEL_PT_PSB:\r\ndecoder->last_ip = 0;\r\ndecoder->have_last_ip = true;\r\nintel_pt_clear_stack(&decoder->stack);\r\nerr = intel_pt_walk_psbend(decoder);\r\nif (err == -EAGAIN)\r\ngoto next;\r\nif (err)\r\nreturn err;\r\nbreak;\r\ncase INTEL_PT_PIP:\r\ndecoder->cr3 = decoder->packet.payload & (BIT63 - 1);\r\nbreak;\r\ncase INTEL_PT_MTC:\r\nintel_pt_calc_mtc_timestamp(decoder);\r\nif (decoder->period_type != INTEL_PT_PERIOD_MTC)\r\nbreak;\r\nif (!decoder->mtc_insn)\r\nbreak;\r\ndecoder->mtc_insn = false;\r\nif (!decoder->timestamp)\r\nbreak;\r\ndecoder->state.type = INTEL_PT_INSTRUCTION;\r\ndecoder->state.from_ip = decoder->ip;\r\ndecoder->state.to_ip = 0;\r\ndecoder->mtc_insn = false;\r\nreturn 0;\r\ncase INTEL_PT_TSC:\r\nintel_pt_calc_tsc_timestamp(decoder);\r\nbreak;\r\ncase INTEL_PT_TMA:\r\nintel_pt_calc_tma(decoder);\r\nbreak;\r\ncase INTEL_PT_CYC:\r\nintel_pt_calc_cyc_timestamp(decoder);\r\nbreak;\r\ncase INTEL_PT_CBR:\r\nintel_pt_calc_cbr(decoder);\r\nif (!decoder->branch_enable &&\r\ndecoder->cbr != decoder->cbr_seen) {\r\ndecoder->cbr_seen = decoder->cbr;\r\ndecoder->state.type = INTEL_PT_CBR_CHG;\r\ndecoder->state.from_ip = decoder->ip;\r\ndecoder->state.to_ip = 0;\r\ndecoder->state.cbr_payload =\r\ndecoder->packet.payload;\r\nreturn 0;\r\n}\r\nbreak;\r\ncase INTEL_PT_MODE_EXEC:\r\ndecoder->exec_mode = decoder->packet.payload;\r\nbreak;\r\ncase INTEL_PT_MODE_TSX:\r\nif (!decoder->pge) {\r\nintel_pt_update_in_tx(decoder);\r\nbreak;\r\n}\r\nerr = intel_pt_mode_tsx(decoder, &no_tip);\r\nif (err)\r\nreturn err;\r\ngoto next;\r\ncase INTEL_PT_BAD:\r\nreturn intel_pt_bug(decoder);\r\ncase INTEL_PT_PSBEND:\r\ncase INTEL_PT_VMCS:\r\ncase INTEL_PT_MNT:\r\ncase INTEL_PT_PAD:\r\nbreak;\r\ncase INTEL_PT_PTWRITE_IP:\r\ndecoder->fup_ptw_payload = decoder->packet.payload;\r\nerr = intel_pt_get_next_packet(decoder);\r\nif (err)\r\nreturn err;\r\nif (decoder->packet.type == INTEL_PT_FUP) {\r\ndecoder->set_fup_ptw = true;\r\nno_tip = true;\r\n} else {\r\nintel_pt_log_at("ERROR: Missing FUP after PTWRITE",\r\ndecoder->pos);\r\n}\r\ngoto next;\r\ncase INTEL_PT_PTWRITE:\r\ndecoder->state.type = INTEL_PT_PTW;\r\ndecoder->state.from_ip = decoder->ip;\r\ndecoder->state.to_ip = 0;\r\ndecoder->state.ptw_payload = decoder->packet.payload;\r\nreturn 0;\r\ncase INTEL_PT_MWAIT:\r\ndecoder->fup_mwait_payload = decoder->packet.payload;\r\ndecoder->set_fup_mwait = true;\r\nbreak;\r\ncase INTEL_PT_PWRE:\r\nif (decoder->set_fup_mwait) {\r\ndecoder->fup_pwre_payload =\r\ndecoder->packet.payload;\r\ndecoder->set_fup_pwre = true;\r\nbreak;\r\n}\r\ndecoder->state.type = INTEL_PT_PWR_ENTRY;\r\ndecoder->state.from_ip = decoder->ip;\r\ndecoder->state.to_ip = 0;\r\ndecoder->state.pwrx_payload = decoder->packet.payload;\r\nreturn 0;\r\ncase INTEL_PT_EXSTOP_IP:\r\nerr = intel_pt_get_next_packet(decoder);\r\nif (err)\r\nreturn err;\r\nif (decoder->packet.type == INTEL_PT_FUP) {\r\ndecoder->set_fup_exstop = true;\r\nno_tip = true;\r\n} else {\r\nintel_pt_log_at("ERROR: Missing FUP after EXSTOP",\r\ndecoder->pos);\r\n}\r\ngoto next;\r\ncase INTEL_PT_EXSTOP:\r\ndecoder->state.type = INTEL_PT_EX_STOP;\r\ndecoder->state.from_ip = decoder->ip;\r\ndecoder->state.to_ip = 0;\r\nreturn 0;\r\ncase INTEL_PT_PWRX:\r\ndecoder->state.type = INTEL_PT_PWR_EXIT;\r\ndecoder->state.from_ip = decoder->ip;\r\ndecoder->state.to_ip = 0;\r\ndecoder->state.pwrx_payload = decoder->packet.payload;\r\nreturn 0;\r\ndefault:\r\nreturn intel_pt_bug(decoder);\r\n}\r\n}\r\n}\r\nstatic inline bool intel_pt_have_ip(struct intel_pt_decoder *decoder)\r\n{\r\nreturn decoder->packet.count &&\r\n(decoder->have_last_ip || decoder->packet.count == 3 ||\r\ndecoder->packet.count == 6);\r\n}\r\nstatic int intel_pt_walk_psb(struct intel_pt_decoder *decoder)\r\n{\r\nint err;\r\nwhile (1) {\r\nerr = intel_pt_get_next_packet(decoder);\r\nif (err)\r\nreturn err;\r\nswitch (decoder->packet.type) {\r\ncase INTEL_PT_TIP_PGD:\r\ndecoder->continuous_period = false;\r\n__fallthrough;\r\ncase INTEL_PT_TIP_PGE:\r\ncase INTEL_PT_TIP:\r\ncase INTEL_PT_PTWRITE:\r\ncase INTEL_PT_PTWRITE_IP:\r\ncase INTEL_PT_EXSTOP:\r\ncase INTEL_PT_EXSTOP_IP:\r\ncase INTEL_PT_MWAIT:\r\ncase INTEL_PT_PWRE:\r\ncase INTEL_PT_PWRX:\r\nintel_pt_log("ERROR: Unexpected packet\n");\r\nreturn -ENOENT;\r\ncase INTEL_PT_FUP:\r\ndecoder->pge = true;\r\nif (intel_pt_have_ip(decoder)) {\r\nuint64_t current_ip = decoder->ip;\r\nintel_pt_set_ip(decoder);\r\nif (current_ip)\r\nintel_pt_log_to("Setting IP",\r\ndecoder->ip);\r\n}\r\nbreak;\r\ncase INTEL_PT_MTC:\r\nintel_pt_calc_mtc_timestamp(decoder);\r\nbreak;\r\ncase INTEL_PT_TSC:\r\nintel_pt_calc_tsc_timestamp(decoder);\r\nbreak;\r\ncase INTEL_PT_TMA:\r\nintel_pt_calc_tma(decoder);\r\nbreak;\r\ncase INTEL_PT_CYC:\r\nintel_pt_calc_cyc_timestamp(decoder);\r\nbreak;\r\ncase INTEL_PT_CBR:\r\nintel_pt_calc_cbr(decoder);\r\nbreak;\r\ncase INTEL_PT_PIP:\r\ndecoder->cr3 = decoder->packet.payload & (BIT63 - 1);\r\nbreak;\r\ncase INTEL_PT_MODE_EXEC:\r\ndecoder->exec_mode = decoder->packet.payload;\r\nbreak;\r\ncase INTEL_PT_MODE_TSX:\r\nintel_pt_update_in_tx(decoder);\r\nbreak;\r\ncase INTEL_PT_TRACESTOP:\r\ndecoder->pge = false;\r\ndecoder->continuous_period = false;\r\nintel_pt_clear_tx_flags(decoder);\r\n__fallthrough;\r\ncase INTEL_PT_TNT:\r\ndecoder->have_tma = false;\r\nintel_pt_log("ERROR: Unexpected packet\n");\r\nif (decoder->ip)\r\ndecoder->pkt_state = INTEL_PT_STATE_ERR4;\r\nelse\r\ndecoder->pkt_state = INTEL_PT_STATE_ERR3;\r\nreturn -ENOENT;\r\ncase INTEL_PT_BAD:\r\nreturn intel_pt_bug(decoder);\r\ncase INTEL_PT_OVF:\r\nreturn intel_pt_overflow(decoder);\r\ncase INTEL_PT_PSBEND:\r\nreturn 0;\r\ncase INTEL_PT_PSB:\r\ncase INTEL_PT_VMCS:\r\ncase INTEL_PT_MNT:\r\ncase INTEL_PT_PAD:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int intel_pt_walk_to_ip(struct intel_pt_decoder *decoder)\r\n{\r\nint err;\r\nwhile (1) {\r\nerr = intel_pt_get_next_packet(decoder);\r\nif (err)\r\nreturn err;\r\nswitch (decoder->packet.type) {\r\ncase INTEL_PT_TIP_PGD:\r\ndecoder->continuous_period = false;\r\n__fallthrough;\r\ncase INTEL_PT_TIP_PGE:\r\ncase INTEL_PT_TIP:\r\ndecoder->pge = decoder->packet.type != INTEL_PT_TIP_PGD;\r\nif (intel_pt_have_ip(decoder))\r\nintel_pt_set_ip(decoder);\r\nif (decoder->ip)\r\nreturn 0;\r\nbreak;\r\ncase INTEL_PT_FUP:\r\nif (intel_pt_have_ip(decoder))\r\nintel_pt_set_ip(decoder);\r\nif (decoder->ip)\r\nreturn 0;\r\nbreak;\r\ncase INTEL_PT_MTC:\r\nintel_pt_calc_mtc_timestamp(decoder);\r\nbreak;\r\ncase INTEL_PT_TSC:\r\nintel_pt_calc_tsc_timestamp(decoder);\r\nbreak;\r\ncase INTEL_PT_TMA:\r\nintel_pt_calc_tma(decoder);\r\nbreak;\r\ncase INTEL_PT_CYC:\r\nintel_pt_calc_cyc_timestamp(decoder);\r\nbreak;\r\ncase INTEL_PT_CBR:\r\nintel_pt_calc_cbr(decoder);\r\nbreak;\r\ncase INTEL_PT_PIP:\r\ndecoder->cr3 = decoder->packet.payload & (BIT63 - 1);\r\nbreak;\r\ncase INTEL_PT_MODE_EXEC:\r\ndecoder->exec_mode = decoder->packet.payload;\r\nbreak;\r\ncase INTEL_PT_MODE_TSX:\r\nintel_pt_update_in_tx(decoder);\r\nbreak;\r\ncase INTEL_PT_OVF:\r\nreturn intel_pt_overflow(decoder);\r\ncase INTEL_PT_BAD:\r\nreturn intel_pt_bug(decoder);\r\ncase INTEL_PT_TRACESTOP:\r\ndecoder->pge = false;\r\ndecoder->continuous_period = false;\r\nintel_pt_clear_tx_flags(decoder);\r\ndecoder->have_tma = false;\r\nbreak;\r\ncase INTEL_PT_PSB:\r\ndecoder->last_ip = 0;\r\ndecoder->have_last_ip = true;\r\nintel_pt_clear_stack(&decoder->stack);\r\nerr = intel_pt_walk_psb(decoder);\r\nif (err)\r\nreturn err;\r\nif (decoder->ip) {\r\ndecoder->state.type = 0;\r\nreturn 0;\r\n}\r\nbreak;\r\ncase INTEL_PT_TNT:\r\ncase INTEL_PT_PSBEND:\r\ncase INTEL_PT_VMCS:\r\ncase INTEL_PT_MNT:\r\ncase INTEL_PT_PAD:\r\ncase INTEL_PT_PTWRITE:\r\ncase INTEL_PT_PTWRITE_IP:\r\ncase INTEL_PT_EXSTOP:\r\ncase INTEL_PT_EXSTOP_IP:\r\ncase INTEL_PT_MWAIT:\r\ncase INTEL_PT_PWRE:\r\ncase INTEL_PT_PWRX:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int intel_pt_sync_ip(struct intel_pt_decoder *decoder)\r\n{\r\nint err;\r\ndecoder->set_fup_tx_flags = false;\r\ndecoder->set_fup_ptw = false;\r\ndecoder->set_fup_mwait = false;\r\ndecoder->set_fup_pwre = false;\r\ndecoder->set_fup_exstop = false;\r\nif (!decoder->branch_enable) {\r\ndecoder->pkt_state = INTEL_PT_STATE_IN_SYNC;\r\ndecoder->overflow = false;\r\ndecoder->state.type = 0;\r\nreturn 0;\r\n}\r\nintel_pt_log("Scanning for full IP\n");\r\nerr = intel_pt_walk_to_ip(decoder);\r\nif (err)\r\nreturn err;\r\ndecoder->pkt_state = INTEL_PT_STATE_IN_SYNC;\r\ndecoder->overflow = false;\r\ndecoder->state.from_ip = 0;\r\ndecoder->state.to_ip = decoder->ip;\r\nintel_pt_log_to("Setting IP", decoder->ip);\r\nreturn 0;\r\n}\r\nstatic int intel_pt_part_psb(struct intel_pt_decoder *decoder)\r\n{\r\nconst unsigned char *end = decoder->buf + decoder->len;\r\nsize_t i;\r\nfor (i = INTEL_PT_PSB_LEN - 1; i; i--) {\r\nif (i > decoder->len)\r\ncontinue;\r\nif (!memcmp(end - i, INTEL_PT_PSB_STR, i))\r\nreturn i;\r\n}\r\nreturn 0;\r\n}\r\nstatic int intel_pt_rest_psb(struct intel_pt_decoder *decoder, int part_psb)\r\n{\r\nsize_t rest_psb = INTEL_PT_PSB_LEN - part_psb;\r\nconst char *psb = INTEL_PT_PSB_STR;\r\nif (rest_psb > decoder->len ||\r\nmemcmp(decoder->buf, psb + part_psb, rest_psb))\r\nreturn 0;\r\nreturn rest_psb;\r\n}\r\nstatic int intel_pt_get_split_psb(struct intel_pt_decoder *decoder,\r\nint part_psb)\r\n{\r\nint rest_psb, ret;\r\ndecoder->pos += decoder->len;\r\ndecoder->len = 0;\r\nret = intel_pt_get_next_data(decoder);\r\nif (ret)\r\nreturn ret;\r\nrest_psb = intel_pt_rest_psb(decoder, part_psb);\r\nif (!rest_psb)\r\nreturn 0;\r\ndecoder->pos -= part_psb;\r\ndecoder->next_buf = decoder->buf + rest_psb;\r\ndecoder->next_len = decoder->len - rest_psb;\r\nmemcpy(decoder->temp_buf, INTEL_PT_PSB_STR, INTEL_PT_PSB_LEN);\r\ndecoder->buf = decoder->temp_buf;\r\ndecoder->len = INTEL_PT_PSB_LEN;\r\nreturn 0;\r\n}\r\nstatic int intel_pt_scan_for_psb(struct intel_pt_decoder *decoder)\r\n{\r\nunsigned char *next;\r\nint ret;\r\nintel_pt_log("Scanning for PSB\n");\r\nwhile (1) {\r\nif (!decoder->len) {\r\nret = intel_pt_get_next_data(decoder);\r\nif (ret)\r\nreturn ret;\r\n}\r\nnext = memmem(decoder->buf, decoder->len, INTEL_PT_PSB_STR,\r\nINTEL_PT_PSB_LEN);\r\nif (!next) {\r\nint part_psb;\r\npart_psb = intel_pt_part_psb(decoder);\r\nif (part_psb) {\r\nret = intel_pt_get_split_psb(decoder, part_psb);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\ndecoder->pos += decoder->len;\r\ndecoder->len = 0;\r\n}\r\ncontinue;\r\n}\r\ndecoder->pkt_step = next - decoder->buf;\r\nreturn intel_pt_get_next_packet(decoder);\r\n}\r\n}\r\nstatic int intel_pt_sync(struct intel_pt_decoder *decoder)\r\n{\r\nint err;\r\ndecoder->pge = false;\r\ndecoder->continuous_period = false;\r\ndecoder->have_last_ip = false;\r\ndecoder->last_ip = 0;\r\ndecoder->ip = 0;\r\nintel_pt_clear_stack(&decoder->stack);\r\nerr = intel_pt_scan_for_psb(decoder);\r\nif (err)\r\nreturn err;\r\ndecoder->have_last_ip = true;\r\ndecoder->pkt_state = INTEL_PT_STATE_NO_IP;\r\nerr = intel_pt_walk_psb(decoder);\r\nif (err)\r\nreturn err;\r\nif (decoder->ip) {\r\ndecoder->state.type = 0;\r\ndecoder->pkt_state = INTEL_PT_STATE_IN_SYNC;\r\n} else {\r\nreturn intel_pt_sync_ip(decoder);\r\n}\r\nreturn 0;\r\n}\r\nstatic uint64_t intel_pt_est_timestamp(struct intel_pt_decoder *decoder)\r\n{\r\nuint64_t est = decoder->sample_insn_cnt << 1;\r\nif (!decoder->cbr || !decoder->max_non_turbo_ratio)\r\ngoto out;\r\nest *= decoder->max_non_turbo_ratio;\r\nest /= decoder->cbr;\r\nout:\r\nreturn decoder->sample_timestamp + est;\r\n}\r\nconst struct intel_pt_state *intel_pt_decode(struct intel_pt_decoder *decoder)\r\n{\r\nint err;\r\ndo {\r\ndecoder->state.type = INTEL_PT_BRANCH;\r\ndecoder->state.flags = 0;\r\nswitch (decoder->pkt_state) {\r\ncase INTEL_PT_STATE_NO_PSB:\r\nerr = intel_pt_sync(decoder);\r\nbreak;\r\ncase INTEL_PT_STATE_NO_IP:\r\ndecoder->have_last_ip = false;\r\ndecoder->last_ip = 0;\r\ndecoder->ip = 0;\r\n__fallthrough;\r\ncase INTEL_PT_STATE_ERR_RESYNC:\r\nerr = intel_pt_sync_ip(decoder);\r\nbreak;\r\ncase INTEL_PT_STATE_IN_SYNC:\r\nerr = intel_pt_walk_trace(decoder);\r\nbreak;\r\ncase INTEL_PT_STATE_TNT:\r\nerr = intel_pt_walk_tnt(decoder);\r\nif (err == -EAGAIN)\r\nerr = intel_pt_walk_trace(decoder);\r\nbreak;\r\ncase INTEL_PT_STATE_TIP:\r\ncase INTEL_PT_STATE_TIP_PGD:\r\nerr = intel_pt_walk_tip(decoder);\r\nbreak;\r\ncase INTEL_PT_STATE_FUP:\r\ndecoder->pkt_state = INTEL_PT_STATE_IN_SYNC;\r\nerr = intel_pt_walk_fup(decoder);\r\nif (err == -EAGAIN)\r\nerr = intel_pt_walk_fup_tip(decoder);\r\nelse if (!err)\r\ndecoder->pkt_state = INTEL_PT_STATE_FUP;\r\nbreak;\r\ncase INTEL_PT_STATE_FUP_NO_TIP:\r\ndecoder->pkt_state = INTEL_PT_STATE_IN_SYNC;\r\nerr = intel_pt_walk_fup(decoder);\r\nif (err == -EAGAIN)\r\nerr = intel_pt_walk_trace(decoder);\r\nbreak;\r\ndefault:\r\nerr = intel_pt_bug(decoder);\r\nbreak;\r\n}\r\n} while (err == -ENOLINK);\r\nif (err) {\r\ndecoder->state.err = intel_pt_ext_err(err);\r\ndecoder->state.from_ip = decoder->ip;\r\ndecoder->sample_timestamp = decoder->timestamp;\r\ndecoder->sample_insn_cnt = decoder->timestamp_insn_cnt;\r\n} else {\r\ndecoder->state.err = 0;\r\nif (decoder->cbr != decoder->cbr_seen && decoder->state.type) {\r\ndecoder->cbr_seen = decoder->cbr;\r\ndecoder->state.type |= INTEL_PT_CBR_CHG;\r\ndecoder->state.cbr_payload = decoder->cbr_payload;\r\n}\r\nif (intel_pt_sample_time(decoder->pkt_state)) {\r\ndecoder->sample_timestamp = decoder->timestamp;\r\ndecoder->sample_insn_cnt = decoder->timestamp_insn_cnt;\r\n}\r\n}\r\ndecoder->state.timestamp = decoder->sample_timestamp;\r\ndecoder->state.est_timestamp = intel_pt_est_timestamp(decoder);\r\ndecoder->state.cr3 = decoder->cr3;\r\ndecoder->state.tot_insn_cnt = decoder->tot_insn_cnt;\r\nreturn &decoder->state;\r\n}\r\nstatic bool intel_pt_at_psb(unsigned char *buf, size_t len)\r\n{\r\nif (len < INTEL_PT_PSB_LEN)\r\nreturn false;\r\nreturn memmem(buf, INTEL_PT_PSB_LEN, INTEL_PT_PSB_STR,\r\nINTEL_PT_PSB_LEN);\r\n}\r\nstatic bool intel_pt_next_psb(unsigned char **buf, size_t *len)\r\n{\r\nunsigned char *next;\r\nnext = memmem(*buf, *len, INTEL_PT_PSB_STR, INTEL_PT_PSB_LEN);\r\nif (next) {\r\n*len -= next - *buf;\r\n*buf = next;\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool intel_pt_step_psb(unsigned char **buf, size_t *len)\r\n{\r\nunsigned char *next;\r\nif (!*len)\r\nreturn false;\r\nnext = memmem(*buf + 1, *len - 1, INTEL_PT_PSB_STR, INTEL_PT_PSB_LEN);\r\nif (next) {\r\n*len -= next - *buf;\r\n*buf = next;\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic unsigned char *intel_pt_last_psb(unsigned char *buf, size_t len)\r\n{\r\nconst char *n = INTEL_PT_PSB_STR;\r\nunsigned char *p;\r\nsize_t k;\r\nif (len < INTEL_PT_PSB_LEN)\r\nreturn NULL;\r\nk = len - INTEL_PT_PSB_LEN + 1;\r\nwhile (1) {\r\np = memrchr(buf, n[0], k);\r\nif (!p)\r\nreturn NULL;\r\nif (!memcmp(p + 1, n + 1, INTEL_PT_PSB_LEN - 1))\r\nreturn p;\r\nk = p - buf;\r\nif (!k)\r\nreturn NULL;\r\n}\r\n}\r\nstatic bool intel_pt_next_tsc(unsigned char *buf, size_t len, uint64_t *tsc)\r\n{\r\nstruct intel_pt_pkt packet;\r\nint ret;\r\nwhile (len) {\r\nret = intel_pt_get_packet(buf, len, &packet);\r\nif (ret <= 0)\r\nreturn false;\r\nif (packet.type == INTEL_PT_TSC) {\r\n*tsc = packet.payload;\r\nreturn true;\r\n}\r\nif (packet.type == INTEL_PT_PSBEND)\r\nreturn false;\r\nbuf += ret;\r\nlen -= ret;\r\n}\r\nreturn false;\r\n}\r\nstatic int intel_pt_tsc_cmp(uint64_t tsc1, uint64_t tsc2)\r\n{\r\nconst uint64_t halfway = (1ULL << 55);\r\nif (tsc1 == tsc2)\r\nreturn 0;\r\nif (tsc1 < tsc2) {\r\nif (tsc2 - tsc1 < halfway)\r\nreturn -1;\r\nelse\r\nreturn 1;\r\n} else {\r\nif (tsc1 - tsc2 < halfway)\r\nreturn 1;\r\nelse\r\nreturn -1;\r\n}\r\n}\r\nstatic unsigned char *intel_pt_find_overlap_tsc(unsigned char *buf_a,\r\nsize_t len_a,\r\nunsigned char *buf_b,\r\nsize_t len_b)\r\n{\r\nuint64_t tsc_a, tsc_b;\r\nunsigned char *p;\r\nsize_t len;\r\np = intel_pt_last_psb(buf_a, len_a);\r\nif (!p)\r\nreturn buf_b;\r\nlen = len_a - (p - buf_a);\r\nif (!intel_pt_next_tsc(p, len, &tsc_a)) {\r\nlen_a -= len;\r\np = intel_pt_last_psb(buf_a, len_a);\r\nif (!p)\r\nreturn buf_b;\r\nlen = len_a - (p - buf_a);\r\nif (!intel_pt_next_tsc(p, len, &tsc_a))\r\nreturn buf_b;\r\n}\r\nwhile (1) {\r\nif (intel_pt_next_tsc(buf_b, len_b, &tsc_b) &&\r\nintel_pt_tsc_cmp(tsc_a, tsc_b) < 0)\r\nreturn buf_b;\r\nif (!intel_pt_step_psb(&buf_b, &len_b))\r\nreturn buf_b + len_b;\r\n}\r\n}\r\nunsigned char *intel_pt_find_overlap(unsigned char *buf_a, size_t len_a,\r\nunsigned char *buf_b, size_t len_b,\r\nbool have_tsc)\r\n{\r\nunsigned char *found;\r\nif (!intel_pt_next_psb(&buf_b, &len_b))\r\nreturn buf_b + len_b;\r\nif (!intel_pt_next_psb(&buf_a, &len_a))\r\nreturn buf_b;\r\nif (have_tsc) {\r\nfound = intel_pt_find_overlap_tsc(buf_a, len_a, buf_b, len_b);\r\nif (found)\r\nreturn found;\r\n}\r\nwhile (len_b < len_a) {\r\nif (!intel_pt_step_psb(&buf_a, &len_a))\r\nreturn buf_b;\r\n}\r\nif (len_b > len_a) {\r\nwhile (!intel_pt_at_psb(buf_b + len_a, len_b - len_a)) {\r\nif (!intel_pt_step_psb(&buf_a, &len_a))\r\nreturn buf_b;\r\n}\r\n}\r\nwhile (1) {\r\nfound = memmem(buf_a, len_a, buf_b, len_a);\r\nif (found)\r\nreturn buf_b + len_a;\r\nif (!intel_pt_step_psb(&buf_a, &len_a))\r\nreturn buf_b;\r\nwhile (!intel_pt_at_psb(buf_b + len_a, len_b - len_a)) {\r\nif (!intel_pt_step_psb(&buf_a, &len_a))\r\nreturn buf_b;\r\n}\r\n}\r\n}
