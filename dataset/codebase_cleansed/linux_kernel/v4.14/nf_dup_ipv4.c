static bool nf_dup_ipv4_route(struct net *net, struct sk_buff *skb,\r\nconst struct in_addr *gw, int oif)\r\n{\r\nconst struct iphdr *iph = ip_hdr(skb);\r\nstruct rtable *rt;\r\nstruct flowi4 fl4;\r\nmemset(&fl4, 0, sizeof(fl4));\r\nif (oif != -1)\r\nfl4.flowi4_oif = oif;\r\nfl4.daddr = gw->s_addr;\r\nfl4.flowi4_tos = RT_TOS(iph->tos);\r\nfl4.flowi4_scope = RT_SCOPE_UNIVERSE;\r\nfl4.flowi4_flags = FLOWI_FLAG_KNOWN_NH;\r\nrt = ip_route_output_key(net, &fl4);\r\nif (IS_ERR(rt))\r\nreturn false;\r\nskb_dst_drop(skb);\r\nskb_dst_set(skb, &rt->dst);\r\nskb->dev = rt->dst.dev;\r\nskb->protocol = htons(ETH_P_IP);\r\nreturn true;\r\n}\r\nvoid nf_dup_ipv4(struct net *net, struct sk_buff *skb, unsigned int hooknum,\r\nconst struct in_addr *gw, int oif)\r\n{\r\nstruct iphdr *iph;\r\nif (this_cpu_read(nf_skb_duplicated))\r\nreturn;\r\nskb = pskb_copy(skb, GFP_ATOMIC);\r\nif (skb == NULL)\r\nreturn;\r\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\r\nnf_reset(skb);\r\nnf_ct_set(skb, NULL, IP_CT_UNTRACKED);\r\n#endif\r\niph = ip_hdr(skb);\r\niph->frag_off |= htons(IP_DF);\r\nif (hooknum == NF_INET_PRE_ROUTING ||\r\nhooknum == NF_INET_LOCAL_IN)\r\n--iph->ttl;\r\nif (nf_dup_ipv4_route(net, skb, gw, oif)) {\r\n__this_cpu_write(nf_skb_duplicated, true);\r\nip_local_out(net, skb->sk, skb);\r\n__this_cpu_write(nf_skb_duplicated, false);\r\n} else {\r\nkfree_skb(skb);\r\n}\r\n}
