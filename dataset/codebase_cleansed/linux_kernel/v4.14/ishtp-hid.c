static int ishtp_hid_parse(struct hid_device *hid)\r\n{\r\nstruct ishtp_hid_data *hid_data = hid->driver_data;\r\nstruct ishtp_cl_data *client_data = hid_data->client_data;\r\nint rv;\r\nrv = hid_parse_report(hid, client_data->report_descr[hid_data->index],\r\nclient_data->report_descr_size[hid_data->index]);\r\nif (rv)\r\nreturn rv;\r\nreturn 0;\r\n}\r\nstatic int ishtp_hid_start(struct hid_device *hid)\r\n{\r\nreturn 0;\r\n}\r\nstatic void ishtp_hid_stop(struct hid_device *hid)\r\n{\r\n}\r\nstatic int ishtp_hid_open(struct hid_device *hid)\r\n{\r\nreturn 0;\r\n}\r\nstatic void ishtp_hid_close(struct hid_device *hid)\r\n{\r\n}\r\nstatic int ishtp_raw_request(struct hid_device *hdev, unsigned char reportnum,\r\n__u8 *buf, size_t len, unsigned char rtype, int reqtype)\r\n{\r\nreturn 0;\r\n}\r\nstatic void ishtp_hid_request(struct hid_device *hid, struct hid_report *rep,\r\nint reqtype)\r\n{\r\nstruct ishtp_hid_data *hid_data = hid->driver_data;\r\nunsigned int len = ((rep->size - 1) >> 3) + 1 + (rep->id > 0);\r\nchar *buf;\r\nunsigned int header_size = sizeof(struct hostif_msg);\r\nlen += header_size;\r\nhid_data->request_done = false;\r\nswitch (reqtype) {\r\ncase HID_REQ_GET_REPORT:\r\nhid_ishtp_get_report(hid, rep->id, rep->type);\r\nbreak;\r\ncase HID_REQ_SET_REPORT:\r\nbuf = kzalloc(len + 7, GFP_KERNEL);\r\nif (!buf)\r\nreturn;\r\nhid_output_report(rep, buf + header_size);\r\nhid_ishtp_set_feature(hid, buf, len, rep->id);\r\nkfree(buf);\r\nbreak;\r\n}\r\n}\r\nstatic int ishtp_wait_for_response(struct hid_device *hid)\r\n{\r\nstruct ishtp_hid_data *hid_data = hid->driver_data;\r\nstruct ishtp_cl_data *client_data = hid_data->client_data;\r\nint rv;\r\nhid_ishtp_trace(client_data, "%s hid %p\n", __func__, hid);\r\nrv = ishtp_hid_link_ready_wait(hid_data->client_data);\r\nif (rv)\r\nreturn rv;\r\nif (!hid_data->request_done)\r\nwait_event_interruptible_timeout(hid_data->hid_wait,\r\nhid_data->request_done, 3 * HZ);\r\nif (!hid_data->request_done) {\r\nhid_err(hid,\r\n"timeout waiting for response from ISHTP device\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nhid_ishtp_trace(client_data, "%s hid %p done\n", __func__, hid);\r\nhid_data->request_done = false;\r\nreturn 0;\r\n}\r\nvoid ishtp_hid_wakeup(struct hid_device *hid)\r\n{\r\nstruct ishtp_hid_data *hid_data = hid->driver_data;\r\nhid_data->request_done = true;\r\nwake_up_interruptible(&hid_data->hid_wait);\r\n}\r\nint ishtp_hid_probe(unsigned int cur_hid_dev,\r\nstruct ishtp_cl_data *client_data)\r\n{\r\nint rv;\r\nstruct hid_device *hid;\r\nstruct ishtp_hid_data *hid_data;\r\nhid = hid_allocate_device();\r\nif (IS_ERR(hid)) {\r\nrv = PTR_ERR(hid);\r\nreturn -ENOMEM;\r\n}\r\nhid_data = kzalloc(sizeof(*hid_data), GFP_KERNEL);\r\nif (!hid_data) {\r\nrv = -ENOMEM;\r\ngoto err_hid_data;\r\n}\r\nhid_data->index = cur_hid_dev;\r\nhid_data->client_data = client_data;\r\ninit_waitqueue_head(&hid_data->hid_wait);\r\nhid->driver_data = hid_data;\r\nclient_data->hid_sensor_hubs[cur_hid_dev] = hid;\r\nhid->ll_driver = &ishtp_hid_ll_driver;\r\nhid->bus = BUS_INTEL_ISHTP;\r\nhid->dev.parent = &client_data->cl_device->dev;\r\nhid->version = le16_to_cpu(ISH_HID_VERSION);\r\nhid->vendor = le16_to_cpu(ISH_HID_VENDOR);\r\nhid->product = le16_to_cpu(ISH_HID_PRODUCT);\r\nsnprintf(hid->name, sizeof(hid->name), "%s %04X:%04X", "hid-ishtp",\r\nhid->vendor, hid->product);\r\nrv = hid_add_device(hid);\r\nif (rv)\r\ngoto err_hid_device;\r\nhid_ishtp_trace(client_data, "%s allocated hid %p\n", __func__, hid);\r\nreturn 0;\r\nerr_hid_device:\r\nkfree(hid_data);\r\nerr_hid_data:\r\nkfree(hid);\r\nreturn rv;\r\n}\r\nvoid ishtp_hid_remove(struct ishtp_cl_data *client_data)\r\n{\r\nint i;\r\nfor (i = 0; i < client_data->num_hid_devices; ++i) {\r\nif (client_data->hid_sensor_hubs[i]) {\r\nkfree(client_data->hid_sensor_hubs[i]->driver_data);\r\nhid_destroy_device(client_data->hid_sensor_hubs[i]);\r\nclient_data->hid_sensor_hubs[i] = NULL;\r\n}\r\n}\r\n}
