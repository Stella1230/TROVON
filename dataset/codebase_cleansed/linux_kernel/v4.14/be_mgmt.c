int beiscsi_modify_eq_delay(struct beiscsi_hba *phba,\r\nstruct be_set_eqd *set_eqd,\r\nint num)\r\n{\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_modify_eq_delay *req;\r\nunsigned int tag;\r\nint i;\r\nmutex_lock(&ctrl->mbox_lock);\r\nwrb = alloc_mcc_wrb(phba, &tag);\r\nif (!wrb) {\r\nmutex_unlock(&ctrl->mbox_lock);\r\nreturn 0;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_MODIFY_EQ_DELAY, sizeof(*req));\r\nreq->num_eq = cpu_to_le32(num);\r\nfor (i = 0; i < num; i++) {\r\nreq->delay[i].eq_id = cpu_to_le32(set_eqd[i].eq_id);\r\nreq->delay[i].phase = 0;\r\nreq->delay[i].delay_multiplier =\r\ncpu_to_le32(set_eqd[i].delay_multiplier);\r\n}\r\nset_bit(MCC_TAG_STATE_IGNORE, &ctrl->ptag_state[tag].tag_state);\r\nbe_mcc_notify(phba, tag);\r\nmutex_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nunsigned int mgmt_vendor_specific_fw_cmd(struct be_ctrl_info *ctrl,\r\nstruct beiscsi_hba *phba,\r\nstruct bsg_job *job,\r\nstruct be_dma_mem *nonemb_cmd)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_sge *mcc_sge;\r\nunsigned int tag = 0;\r\nstruct iscsi_bsg_request *bsg_req = job->request;\r\nstruct be_bsg_vendor_cmd *req = nonemb_cmd->va;\r\nunsigned short region, sector_size, sector, offset;\r\nnonemb_cmd->size = job->request_payload.payload_len;\r\nmemset(nonemb_cmd->va, 0, nonemb_cmd->size);\r\nregion = bsg_req->rqst_data.h_vendor.vendor_cmd[1];\r\nsector_size = bsg_req->rqst_data.h_vendor.vendor_cmd[2];\r\nsector = bsg_req->rqst_data.h_vendor.vendor_cmd[3];\r\noffset = bsg_req->rqst_data.h_vendor.vendor_cmd[4];\r\nreq->region = region;\r\nreq->sector = sector;\r\nreq->offset = offset;\r\nif (mutex_lock_interruptible(&ctrl->mbox_lock))\r\nreturn 0;\r\nswitch (bsg_req->rqst_data.h_vendor.vendor_cmd[0]) {\r\ncase BEISCSI_WRITE_FLASH:\r\noffset = sector * sector_size + offset;\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI,\r\nOPCODE_COMMON_WRITE_FLASH, sizeof(*req));\r\nsg_copy_to_buffer(job->request_payload.sg_list,\r\njob->request_payload.sg_cnt,\r\nnonemb_cmd->va + offset, job->request_len);\r\nbreak;\r\ncase BEISCSI_READ_FLASH:\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI,\r\nOPCODE_COMMON_READ_FLASH, sizeof(*req));\r\nbreak;\r\ndefault:\r\nbeiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_CONFIG,\r\n"BG_%d : Unsupported cmd = 0x%x\n\n",\r\nbsg_req->rqst_data.h_vendor.vendor_cmd[0]);\r\nmutex_unlock(&ctrl->mbox_lock);\r\nreturn -EPERM;\r\n}\r\nwrb = alloc_mcc_wrb(phba, &tag);\r\nif (!wrb) {\r\nmutex_unlock(&ctrl->mbox_lock);\r\nreturn 0;\r\n}\r\nmcc_sge = nonembedded_sgl(wrb);\r\nbe_wrb_hdr_prepare(wrb, nonemb_cmd->size, false,\r\njob->request_payload.sg_cnt);\r\nmcc_sge->pa_hi = cpu_to_le32(upper_32_bits(nonemb_cmd->dma));\r\nmcc_sge->pa_lo = cpu_to_le32(nonemb_cmd->dma & 0xFFFFFFFF);\r\nmcc_sge->len = cpu_to_le32(nonemb_cmd->size);\r\nbe_mcc_notify(phba, tag);\r\nmutex_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nint mgmt_open_connection(struct beiscsi_hba *phba,\r\nstruct sockaddr *dst_addr,\r\nstruct beiscsi_endpoint *beiscsi_ep,\r\nstruct be_dma_mem *nonemb_cmd)\r\n{\r\nstruct hwi_controller *phwi_ctrlr;\r\nstruct hwi_context_memory *phwi_context;\r\nstruct sockaddr_in *daddr_in = (struct sockaddr_in *)dst_addr;\r\nstruct sockaddr_in6 *daddr_in6 = (struct sockaddr_in6 *)dst_addr;\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nstruct be_mcc_wrb *wrb;\r\nstruct tcp_connect_and_offload_in_v1 *req;\r\nunsigned short def_hdr_id;\r\nunsigned short def_data_id;\r\nstruct phys_addr template_address = { 0, 0 };\r\nstruct phys_addr *ptemplate_address;\r\nunsigned int tag = 0;\r\nunsigned int i, ulp_num;\r\nunsigned short cid = beiscsi_ep->ep_cid;\r\nstruct be_sge *sge;\r\nif (dst_addr->sa_family != PF_INET && dst_addr->sa_family != PF_INET6) {\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\r\n"BG_%d : unknown addr family %d\n",\r\ndst_addr->sa_family);\r\nreturn -EINVAL;\r\n}\r\nphwi_ctrlr = phba->phwi_ctrlr;\r\nphwi_context = phwi_ctrlr->phwi_ctxt;\r\nulp_num = phwi_ctrlr->wrb_context[BE_GET_CRI_FROM_CID(cid)].ulp_num;\r\ndef_hdr_id = (unsigned short)HWI_GET_DEF_HDRQ_ID(phba, ulp_num);\r\ndef_data_id = (unsigned short)HWI_GET_DEF_BUFQ_ID(phba, ulp_num);\r\nptemplate_address = &template_address;\r\nISCSI_GET_PDU_TEMPLATE_ADDRESS(phba, ptemplate_address);\r\nif (mutex_lock_interruptible(&ctrl->mbox_lock))\r\nreturn 0;\r\nwrb = alloc_mcc_wrb(phba, &tag);\r\nif (!wrb) {\r\nmutex_unlock(&ctrl->mbox_lock);\r\nreturn 0;\r\n}\r\nsge = nonembedded_sgl(wrb);\r\nreq = nonemb_cmd->va;\r\nmemset(req, 0, sizeof(*req));\r\nbe_wrb_hdr_prepare(wrb, nonemb_cmd->size, false, 1);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI,\r\nOPCODE_COMMON_ISCSI_TCP_CONNECT_AND_OFFLOAD,\r\nnonemb_cmd->size);\r\nif (dst_addr->sa_family == PF_INET) {\r\n__be32 s_addr = daddr_in->sin_addr.s_addr;\r\nreq->ip_address.ip_type = BEISCSI_IP_TYPE_V4;\r\nreq->ip_address.addr[0] = s_addr & 0x000000ff;\r\nreq->ip_address.addr[1] = (s_addr & 0x0000ff00) >> 8;\r\nreq->ip_address.addr[2] = (s_addr & 0x00ff0000) >> 16;\r\nreq->ip_address.addr[3] = (s_addr & 0xff000000) >> 24;\r\nreq->tcp_port = ntohs(daddr_in->sin_port);\r\nbeiscsi_ep->dst_addr = daddr_in->sin_addr.s_addr;\r\nbeiscsi_ep->dst_tcpport = ntohs(daddr_in->sin_port);\r\nbeiscsi_ep->ip_type = BEISCSI_IP_TYPE_V4;\r\n} else {\r\nreq->ip_address.ip_type = BEISCSI_IP_TYPE_V6;\r\nmemcpy(&req->ip_address.addr,\r\n&daddr_in6->sin6_addr.in6_u.u6_addr8, 16);\r\nreq->tcp_port = ntohs(daddr_in6->sin6_port);\r\nbeiscsi_ep->dst_tcpport = ntohs(daddr_in6->sin6_port);\r\nmemcpy(&beiscsi_ep->dst6_addr,\r\n&daddr_in6->sin6_addr.in6_u.u6_addr8, 16);\r\nbeiscsi_ep->ip_type = BEISCSI_IP_TYPE_V6;\r\n}\r\nreq->cid = cid;\r\ni = phba->nxt_cqid++;\r\nif (phba->nxt_cqid == phba->num_cpus)\r\nphba->nxt_cqid = 0;\r\nreq->cq_id = phwi_context->be_cq[i].id;\r\nbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,\r\n"BG_%d : i=%d cq_id=%d\n", i, req->cq_id);\r\nreq->defq_id = def_hdr_id;\r\nreq->hdr_ring_id = def_hdr_id;\r\nreq->data_ring_id = def_data_id;\r\nreq->do_offload = 1;\r\nreq->dataout_template_pa.lo = ptemplate_address->lo;\r\nreq->dataout_template_pa.hi = ptemplate_address->hi;\r\nsge->pa_hi = cpu_to_le32(upper_32_bits(nonemb_cmd->dma));\r\nsge->pa_lo = cpu_to_le32(nonemb_cmd->dma & 0xFFFFFFFF);\r\nsge->len = cpu_to_le32(nonemb_cmd->size);\r\nif (!is_chip_be2_be3r(phba)) {\r\nreq->hdr.version = MBX_CMD_VER1;\r\nreq->tcp_window_size = 0x8000;\r\nreq->tcp_window_scale_count = 2;\r\n}\r\nbe_mcc_notify(phba, tag);\r\nmutex_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nstatic int mgmt_exec_nonemb_cmd(struct beiscsi_hba *phba,\r\nstruct be_dma_mem *nonemb_cmd, void *resp_buf,\r\nint resp_buf_len)\r\n{\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_sge *sge;\r\nunsigned int tag;\r\nint rc = 0;\r\nmutex_lock(&ctrl->mbox_lock);\r\nwrb = alloc_mcc_wrb(phba, &tag);\r\nif (!wrb) {\r\nmutex_unlock(&ctrl->mbox_lock);\r\nrc = -ENOMEM;\r\ngoto free_cmd;\r\n}\r\nsge = nonembedded_sgl(wrb);\r\nbe_wrb_hdr_prepare(wrb, nonemb_cmd->size, false, 1);\r\nsge->pa_hi = cpu_to_le32(upper_32_bits(nonemb_cmd->dma));\r\nsge->pa_lo = cpu_to_le32(lower_32_bits(nonemb_cmd->dma));\r\nsge->len = cpu_to_le32(nonemb_cmd->size);\r\nbe_mcc_notify(phba, tag);\r\nmutex_unlock(&ctrl->mbox_lock);\r\nrc = beiscsi_mccq_compl_wait(phba, tag, NULL, nonemb_cmd);\r\nif (resp_buf)\r\nmemcpy(resp_buf, nonemb_cmd->va, resp_buf_len);\r\nif (rc) {\r\nif (rc == -EAGAIN)\r\nreturn rc;\r\nbeiscsi_log(phba, KERN_WARNING,\r\nBEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,\r\n"BG_%d : mgmt_exec_nonemb_cmd Failed status\n");\r\nif (rc != -EBUSY)\r\ngoto free_cmd;\r\nelse\r\nreturn rc;\r\n}\r\nfree_cmd:\r\npci_free_consistent(ctrl->pdev, nonemb_cmd->size,\r\nnonemb_cmd->va, nonemb_cmd->dma);\r\nreturn rc;\r\n}\r\nstatic int mgmt_alloc_cmd_data(struct beiscsi_hba *phba, struct be_dma_mem *cmd,\r\nint iscsi_cmd, int size)\r\n{\r\ncmd->va = pci_zalloc_consistent(phba->ctrl.pdev, size, &cmd->dma);\r\nif (!cmd->va) {\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\r\n"BG_%d : Failed to allocate memory for if info\n");\r\nreturn -ENOMEM;\r\n}\r\ncmd->size = size;\r\nbe_cmd_hdr_prepare(cmd->va, CMD_SUBSYSTEM_ISCSI, iscsi_cmd, size);\r\nbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,\r\n"BG_%d : subsystem iSCSI cmd %d size %d\n",\r\niscsi_cmd, size);\r\nreturn 0;\r\n}\r\nunsigned int beiscsi_if_get_handle(struct beiscsi_hba *phba)\r\n{\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_get_all_if_id_req *req;\r\nstruct be_cmd_get_all_if_id_req *pbe_allid;\r\nunsigned int tag;\r\nint status = 0;\r\nif (mutex_lock_interruptible(&ctrl->mbox_lock))\r\nreturn -EINTR;\r\nwrb = alloc_mcc_wrb(phba, &tag);\r\nif (!wrb) {\r\nmutex_unlock(&ctrl->mbox_lock);\r\nreturn -ENOMEM;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI,\r\nOPCODE_COMMON_ISCSI_NTWK_GET_ALL_IF_ID,\r\nsizeof(*req));\r\nbe_mcc_notify(phba, tag);\r\nmutex_unlock(&ctrl->mbox_lock);\r\nstatus = beiscsi_mccq_compl_wait(phba, tag, &wrb, NULL);\r\nif (status) {\r\nbeiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_CONFIG,\r\n"BG_%d : %s failed: %d\n", __func__, status);\r\nreturn -EBUSY;\r\n}\r\npbe_allid = embedded_payload(wrb);\r\nphba->interface_handle = pbe_allid->if_hndl_list[0];\r\nreturn status;\r\n}\r\nstatic inline bool beiscsi_if_zero_ip(u8 *ip, u32 ip_type)\r\n{\r\nu32 len;\r\nlen = (ip_type < BEISCSI_IP_TYPE_V6) ? IP_V4_LEN : IP_V6_LEN;\r\nwhile (len && !ip[len - 1])\r\nlen--;\r\nreturn (len == 0);\r\n}\r\nstatic int beiscsi_if_mod_gw(struct beiscsi_hba *phba,\r\nu32 action, u32 ip_type, u8 *gw)\r\n{\r\nstruct be_cmd_set_def_gateway_req *req;\r\nstruct be_dma_mem nonemb_cmd;\r\nint rt_val;\r\nrt_val = mgmt_alloc_cmd_data(phba, &nonemb_cmd,\r\nOPCODE_COMMON_ISCSI_NTWK_MODIFY_DEFAULT_GATEWAY,\r\nsizeof(*req));\r\nif (rt_val)\r\nreturn rt_val;\r\nreq = nonemb_cmd.va;\r\nreq->action = action;\r\nreq->ip_addr.ip_type = ip_type;\r\nmemcpy(req->ip_addr.addr, gw,\r\n(ip_type < BEISCSI_IP_TYPE_V6) ? IP_V4_LEN : IP_V6_LEN);\r\nreturn mgmt_exec_nonemb_cmd(phba, &nonemb_cmd, NULL, 0);\r\n}\r\nint beiscsi_if_set_gw(struct beiscsi_hba *phba, u32 ip_type, u8 *gw)\r\n{\r\nstruct be_cmd_get_def_gateway_resp gw_resp;\r\nint rt_val;\r\nmemset(&gw_resp, 0, sizeof(gw_resp));\r\nrt_val = beiscsi_if_get_gw(phba, ip_type, &gw_resp);\r\nif (rt_val) {\r\nbeiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_CONFIG,\r\n"BG_%d : Failed to Get Gateway Addr\n");\r\nreturn rt_val;\r\n}\r\nif (!beiscsi_if_zero_ip(gw_resp.ip_addr.addr, ip_type)) {\r\nrt_val = beiscsi_if_mod_gw(phba, IP_ACTION_DEL, ip_type,\r\ngw_resp.ip_addr.addr);\r\nif (rt_val) {\r\nbeiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_CONFIG,\r\n"BG_%d : Failed to clear Gateway Addr Set\n");\r\nreturn rt_val;\r\n}\r\n}\r\nrt_val = beiscsi_if_mod_gw(phba, IP_ACTION_ADD, ip_type, gw);\r\nif (rt_val)\r\nbeiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_CONFIG,\r\n"BG_%d : Failed to Set Gateway Addr\n");\r\nreturn rt_val;\r\n}\r\nint beiscsi_if_get_gw(struct beiscsi_hba *phba, u32 ip_type,\r\nstruct be_cmd_get_def_gateway_resp *resp)\r\n{\r\nstruct be_cmd_get_def_gateway_req *req;\r\nstruct be_dma_mem nonemb_cmd;\r\nint rc;\r\nrc = mgmt_alloc_cmd_data(phba, &nonemb_cmd,\r\nOPCODE_COMMON_ISCSI_NTWK_GET_DEFAULT_GATEWAY,\r\nsizeof(*resp));\r\nif (rc)\r\nreturn rc;\r\nreq = nonemb_cmd.va;\r\nreq->ip_type = ip_type;\r\nreturn mgmt_exec_nonemb_cmd(phba, &nonemb_cmd, resp,\r\nsizeof(*resp));\r\n}\r\nstatic int\r\nbeiscsi_if_clr_ip(struct beiscsi_hba *phba,\r\nstruct be_cmd_get_if_info_resp *if_info)\r\n{\r\nstruct be_cmd_set_ip_addr_req *req;\r\nstruct be_dma_mem nonemb_cmd;\r\nint rc;\r\nrc = mgmt_alloc_cmd_data(phba, &nonemb_cmd,\r\nOPCODE_COMMON_ISCSI_NTWK_MODIFY_IP_ADDR,\r\nsizeof(*req));\r\nif (rc)\r\nreturn rc;\r\nreq = nonemb_cmd.va;\r\nreq->ip_params.record_entry_count = 1;\r\nreq->ip_params.ip_record.action = IP_ACTION_DEL;\r\nreq->ip_params.ip_record.interface_hndl =\r\nphba->interface_handle;\r\nreq->ip_params.ip_record.ip_addr.size_of_structure =\r\nsizeof(struct be_ip_addr_subnet_format);\r\nreq->ip_params.ip_record.ip_addr.ip_type = if_info->ip_addr.ip_type;\r\nmemcpy(req->ip_params.ip_record.ip_addr.addr,\r\nif_info->ip_addr.addr,\r\nsizeof(if_info->ip_addr.addr));\r\nmemcpy(req->ip_params.ip_record.ip_addr.subnet_mask,\r\nif_info->ip_addr.subnet_mask,\r\nsizeof(if_info->ip_addr.subnet_mask));\r\nrc = mgmt_exec_nonemb_cmd(phba, &nonemb_cmd, NULL, 0);\r\nif (rc < 0 || req->ip_params.ip_record.status) {\r\nbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,\r\n"BG_%d : failed to clear IP: rc %d status %d\n",\r\nrc, req->ip_params.ip_record.status);\r\n}\r\nreturn rc;\r\n}\r\nstatic int\r\nbeiscsi_if_set_ip(struct beiscsi_hba *phba, u8 *ip,\r\nu8 *subnet, u32 ip_type)\r\n{\r\nstruct be_cmd_set_ip_addr_req *req;\r\nstruct be_dma_mem nonemb_cmd;\r\nuint32_t ip_len;\r\nint rc;\r\nrc = mgmt_alloc_cmd_data(phba, &nonemb_cmd,\r\nOPCODE_COMMON_ISCSI_NTWK_MODIFY_IP_ADDR,\r\nsizeof(*req));\r\nif (rc)\r\nreturn rc;\r\nreq = nonemb_cmd.va;\r\nreq->ip_params.record_entry_count = 1;\r\nreq->ip_params.ip_record.action = IP_ACTION_ADD;\r\nreq->ip_params.ip_record.interface_hndl =\r\nphba->interface_handle;\r\nreq->ip_params.ip_record.ip_addr.size_of_structure =\r\nsizeof(struct be_ip_addr_subnet_format);\r\nreq->ip_params.ip_record.ip_addr.ip_type = ip_type;\r\nip_len = (ip_type < BEISCSI_IP_TYPE_V6) ? IP_V4_LEN : IP_V6_LEN;\r\nmemcpy(req->ip_params.ip_record.ip_addr.addr, ip, ip_len);\r\nif (subnet)\r\nmemcpy(req->ip_params.ip_record.ip_addr.subnet_mask,\r\nsubnet, ip_len);\r\nrc = mgmt_exec_nonemb_cmd(phba, &nonemb_cmd, NULL, 0);\r\nif (rc < 0 || req->ip_params.ip_record.status) {\r\n__beiscsi_log(phba, KERN_ERR,\r\n"BG_%d : failed to set IP: rc %d status %d\n",\r\nrc, req->ip_params.ip_record.status);\r\nif (req->ip_params.ip_record.status)\r\nrc = -EINVAL;\r\n}\r\nreturn rc;\r\n}\r\nint beiscsi_if_en_static(struct beiscsi_hba *phba, u32 ip_type,\r\nu8 *ip, u8 *subnet)\r\n{\r\nstruct be_cmd_get_if_info_resp *if_info;\r\nstruct be_cmd_rel_dhcp_req *reldhcp;\r\nstruct be_dma_mem nonemb_cmd;\r\nint rc;\r\nrc = beiscsi_if_get_info(phba, ip_type, &if_info);\r\nif (rc)\r\nreturn rc;\r\nif (if_info->dhcp_state) {\r\nrc = mgmt_alloc_cmd_data(phba, &nonemb_cmd,\r\nOPCODE_COMMON_ISCSI_NTWK_REL_STATELESS_IP_ADDR,\r\nsizeof(*reldhcp));\r\nif (rc)\r\ngoto exit;\r\nreldhcp = nonemb_cmd.va;\r\nreldhcp->interface_hndl = phba->interface_handle;\r\nreldhcp->ip_type = ip_type;\r\nrc = mgmt_exec_nonemb_cmd(phba, &nonemb_cmd, NULL, 0);\r\nif (rc < 0) {\r\nbeiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_CONFIG,\r\n"BG_%d : failed to release existing DHCP: %d\n",\r\nrc);\r\ngoto exit;\r\n}\r\n}\r\nif (!beiscsi_if_zero_ip(if_info->ip_addr.addr, ip_type)) {\r\nrc = beiscsi_if_clr_ip(phba, if_info);\r\nif (rc)\r\ngoto exit;\r\n}\r\nif (ip)\r\nrc = beiscsi_if_set_ip(phba, ip, subnet, ip_type);\r\nexit:\r\nkfree(if_info);\r\nreturn rc;\r\n}\r\nint beiscsi_if_en_dhcp(struct beiscsi_hba *phba, u32 ip_type)\r\n{\r\nstruct be_cmd_get_def_gateway_resp gw_resp;\r\nstruct be_cmd_get_if_info_resp *if_info;\r\nstruct be_cmd_set_dhcp_req *dhcpreq;\r\nstruct be_dma_mem nonemb_cmd;\r\nu8 *gw;\r\nint rc;\r\nrc = beiscsi_if_get_info(phba, ip_type, &if_info);\r\nif (rc)\r\nreturn rc;\r\nif (if_info->dhcp_state) {\r\nbeiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_CONFIG,\r\n"BG_%d : DHCP Already Enabled\n");\r\ngoto exit;\r\n}\r\nif (!beiscsi_if_zero_ip(if_info->ip_addr.addr, ip_type)) {\r\nrc = beiscsi_if_clr_ip(phba, if_info);\r\nif (rc)\r\ngoto exit;\r\n}\r\nmemset(&gw_resp, 0, sizeof(gw_resp));\r\nrc = beiscsi_if_get_gw(phba, if_info->ip_addr.ip_type, &gw_resp);\r\nif (rc) {\r\nbeiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_CONFIG,\r\n"BG_%d : Failed to Get Gateway Addr\n");\r\ngoto exit;\r\n}\r\ngw = (u8 *)&gw_resp.ip_addr.addr;\r\nif (!beiscsi_if_zero_ip(gw, if_info->ip_addr.ip_type)) {\r\nrc = beiscsi_if_mod_gw(phba, IP_ACTION_DEL,\r\nif_info->ip_addr.ip_type, gw);\r\nif (rc) {\r\nbeiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_CONFIG,\r\n"BG_%d : Failed to clear Gateway Addr Set\n");\r\ngoto exit;\r\n}\r\n}\r\nrc = mgmt_alloc_cmd_data(phba, &nonemb_cmd,\r\nOPCODE_COMMON_ISCSI_NTWK_CONFIG_STATELESS_IP_ADDR,\r\nsizeof(*dhcpreq));\r\nif (rc)\r\ngoto exit;\r\ndhcpreq = nonemb_cmd.va;\r\ndhcpreq->flags = 1;\r\ndhcpreq->retry_count = 1;\r\ndhcpreq->interface_hndl = phba->interface_handle;\r\ndhcpreq->ip_type = ip_type;\r\nrc = mgmt_exec_nonemb_cmd(phba, &nonemb_cmd, NULL, 0);\r\nexit:\r\nkfree(if_info);\r\nreturn rc;\r\n}\r\nint beiscsi_if_set_vlan(struct beiscsi_hba *phba, uint16_t vlan_tag)\r\n{\r\nint rc;\r\nunsigned int tag;\r\ntag = be_cmd_set_vlan(phba, vlan_tag);\r\nif (!tag) {\r\nbeiscsi_log(phba, KERN_ERR,\r\n(BEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX),\r\n"BG_%d : VLAN Setting Failed\n");\r\nreturn -EBUSY;\r\n}\r\nrc = beiscsi_mccq_compl_wait(phba, tag, NULL, NULL);\r\nif (rc) {\r\nbeiscsi_log(phba, KERN_ERR,\r\n(BEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX),\r\n"BS_%d : VLAN MBX Cmd Failed\n");\r\nreturn rc;\r\n}\r\nreturn rc;\r\n}\r\nint beiscsi_if_get_info(struct beiscsi_hba *phba, int ip_type,\r\nstruct be_cmd_get_if_info_resp **if_info)\r\n{\r\nstruct be_cmd_get_if_info_req *req;\r\nstruct be_dma_mem nonemb_cmd;\r\nuint32_t ioctl_size = sizeof(struct be_cmd_get_if_info_resp);\r\nint rc;\r\nrc = beiscsi_if_get_handle(phba);\r\nif (rc)\r\nreturn rc;\r\ndo {\r\nrc = mgmt_alloc_cmd_data(phba, &nonemb_cmd,\r\nOPCODE_COMMON_ISCSI_NTWK_GET_IF_INFO,\r\nioctl_size);\r\nif (rc)\r\nreturn rc;\r\nreq = nonemb_cmd.va;\r\nreq->interface_hndl = phba->interface_handle;\r\nreq->ip_type = ip_type;\r\n*if_info = kzalloc(ioctl_size, GFP_KERNEL);\r\nif (!*if_info) {\r\nbeiscsi_log(phba, KERN_ERR,\r\nBEISCSI_LOG_INIT | BEISCSI_LOG_CONFIG,\r\n"BG_%d : Memory Allocation Failure\n");\r\npci_free_consistent(phba->ctrl.pdev,\r\nnonemb_cmd.size,\r\nnonemb_cmd.va,\r\nnonemb_cmd.dma);\r\nreturn -ENOMEM;\r\n}\r\nrc = mgmt_exec_nonemb_cmd(phba, &nonemb_cmd, *if_info,\r\nioctl_size);\r\nif (rc == -EAGAIN) {\r\nioctl_size = ((struct be_cmd_resp_hdr *)\r\nnonemb_cmd.va)->actual_resp_len;\r\nioctl_size += sizeof(struct be_cmd_req_hdr);\r\npci_free_consistent(phba->ctrl.pdev, nonemb_cmd.size,\r\nnonemb_cmd.va,\r\nnonemb_cmd.dma);\r\nkfree(*if_info);\r\n} else\r\nbreak;\r\n} while (true);\r\nreturn rc;\r\n}\r\nint mgmt_get_nic_conf(struct beiscsi_hba *phba,\r\nstruct be_cmd_get_nic_conf_resp *nic)\r\n{\r\nstruct be_dma_mem nonemb_cmd;\r\nint rc;\r\nrc = mgmt_alloc_cmd_data(phba, &nonemb_cmd,\r\nOPCODE_COMMON_ISCSI_NTWK_GET_NIC_CONFIG,\r\nsizeof(*nic));\r\nif (rc)\r\nreturn rc;\r\nreturn mgmt_exec_nonemb_cmd(phba, &nonemb_cmd, nic, sizeof(*nic));\r\n}\r\nunsigned int be_cmd_get_initname(struct beiscsi_hba *phba)\r\n{\r\nunsigned int tag;\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_hba_name *req;\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nif (mutex_lock_interruptible(&ctrl->mbox_lock))\r\nreturn 0;\r\nwrb = alloc_mcc_wrb(phba, &tag);\r\nif (!wrb) {\r\nmutex_unlock(&ctrl->mbox_lock);\r\nreturn 0;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI_INI,\r\nOPCODE_ISCSI_INI_CFG_GET_HBA_NAME,\r\nsizeof(*req));\r\nbe_mcc_notify(phba, tag);\r\nmutex_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nstatic void beiscsi_boot_process_compl(struct beiscsi_hba *phba,\r\nunsigned int tag)\r\n{\r\nstruct be_cmd_get_boot_target_resp *boot_resp;\r\nstruct be_cmd_resp_logout_fw_sess *logo_resp;\r\nstruct be_cmd_get_session_resp *sess_resp;\r\nstruct be_mcc_wrb *wrb;\r\nstruct boot_struct *bs;\r\nint boot_work, status;\r\nif (!test_bit(BEISCSI_HBA_BOOT_WORK, &phba->state)) {\r\n__beiscsi_log(phba, KERN_ERR,\r\n"BG_%d : %s no boot work %lx\n",\r\n__func__, phba->state);\r\nreturn;\r\n}\r\nif (phba->boot_struct.tag != tag) {\r\n__beiscsi_log(phba, KERN_ERR,\r\n"BG_%d : %s tag mismatch %d:%d\n",\r\n__func__, tag, phba->boot_struct.tag);\r\nreturn;\r\n}\r\nbs = &phba->boot_struct;\r\nboot_work = 1;\r\nstatus = 0;\r\nswitch (bs->action) {\r\ncase BEISCSI_BOOT_REOPEN_SESS:\r\nstatus = __beiscsi_mcc_compl_status(phba, tag, NULL, NULL);\r\nif (!status)\r\nbs->action = BEISCSI_BOOT_GET_SHANDLE;\r\nelse\r\nbs->retry--;\r\nbreak;\r\ncase BEISCSI_BOOT_GET_SHANDLE:\r\nstatus = __beiscsi_mcc_compl_status(phba, tag, &wrb, NULL);\r\nif (!status) {\r\nboot_resp = embedded_payload(wrb);\r\nbs->s_handle = boot_resp->boot_session_handle;\r\n}\r\nif (bs->s_handle == BE_BOOT_INVALID_SHANDLE) {\r\nbs->action = BEISCSI_BOOT_REOPEN_SESS;\r\nbs->retry--;\r\n} else {\r\nbs->action = BEISCSI_BOOT_GET_SINFO;\r\n}\r\nbreak;\r\ncase BEISCSI_BOOT_GET_SINFO:\r\nstatus = __beiscsi_mcc_compl_status(phba, tag, NULL,\r\n&bs->nonemb_cmd);\r\nif (!status) {\r\nsess_resp = bs->nonemb_cmd.va;\r\nmemcpy(&bs->boot_sess, &sess_resp->session_info,\r\nsizeof(struct mgmt_session_info));\r\nbs->action = BEISCSI_BOOT_LOGOUT_SESS;\r\n} else {\r\n__beiscsi_log(phba, KERN_ERR,\r\n"BG_%d : get boot session info error : 0x%x\n",\r\nstatus);\r\nboot_work = 0;\r\n}\r\npci_free_consistent(phba->ctrl.pdev, bs->nonemb_cmd.size,\r\nbs->nonemb_cmd.va, bs->nonemb_cmd.dma);\r\nbs->nonemb_cmd.va = NULL;\r\nbreak;\r\ncase BEISCSI_BOOT_LOGOUT_SESS:\r\nstatus = __beiscsi_mcc_compl_status(phba, tag, &wrb, NULL);\r\nif (!status) {\r\nlogo_resp = embedded_payload(wrb);\r\nif (logo_resp->session_status != BE_SESS_STATUS_CLOSE) {\r\n__beiscsi_log(phba, KERN_ERR,\r\n"BG_%d : FW boot session logout error : 0x%x\n",\r\nlogo_resp->session_status);\r\n}\r\n}\r\nbs->action = BEISCSI_BOOT_CREATE_KSET;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbs->tag = 0;\r\nif (!bs->retry) {\r\nboot_work = 0;\r\n__beiscsi_log(phba, KERN_ERR,\r\n"BG_%d : failed to setup boot target: status %d action %d\n",\r\nstatus, bs->action);\r\n}\r\nif (!boot_work) {\r\nclear_bit(BEISCSI_HBA_BOOT_WORK, &phba->state);\r\nreturn;\r\n}\r\nschedule_work(&phba->boot_work);\r\n}\r\nunsigned int beiscsi_boot_logout_sess(struct beiscsi_hba *phba)\r\n{\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_logout_fw_sess *req;\r\nunsigned int tag;\r\nmutex_lock(&ctrl->mbox_lock);\r\nwrb = alloc_mcc_wrb(phba, &tag);\r\nif (!wrb) {\r\nmutex_unlock(&ctrl->mbox_lock);\r\nreturn 0;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI_INI,\r\nOPCODE_ISCSI_INI_SESSION_LOGOUT_TARGET,\r\nsizeof(struct be_cmd_req_logout_fw_sess));\r\nreq->session_handle = phba->boot_struct.boot_sess.session_handle;\r\nphba->boot_struct.tag = tag;\r\nset_bit(MCC_TAG_STATE_ASYNC, &ctrl->ptag_state[tag].tag_state);\r\nctrl->ptag_state[tag].cbfn = beiscsi_boot_process_compl;\r\nbe_mcc_notify(phba, tag);\r\nmutex_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nunsigned int beiscsi_boot_reopen_sess(struct beiscsi_hba *phba)\r\n{\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_reopen_session_req *req;\r\nunsigned int tag;\r\nmutex_lock(&ctrl->mbox_lock);\r\nwrb = alloc_mcc_wrb(phba, &tag);\r\nif (!wrb) {\r\nmutex_unlock(&ctrl->mbox_lock);\r\nreturn 0;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI_INI,\r\nOPCODE_ISCSI_INI_DRIVER_REOPEN_ALL_SESSIONS,\r\nsizeof(struct be_cmd_reopen_session_resp));\r\nreq->reopen_type = BE_REOPEN_BOOT_SESSIONS;\r\nreq->session_handle = BE_BOOT_INVALID_SHANDLE;\r\nphba->boot_struct.tag = tag;\r\nset_bit(MCC_TAG_STATE_ASYNC, &ctrl->ptag_state[tag].tag_state);\r\nctrl->ptag_state[tag].cbfn = beiscsi_boot_process_compl;\r\nbe_mcc_notify(phba, tag);\r\nmutex_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nunsigned int beiscsi_boot_get_sinfo(struct beiscsi_hba *phba)\r\n{\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nstruct be_cmd_get_session_req *req;\r\nstruct be_dma_mem *nonemb_cmd;\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_sge *sge;\r\nunsigned int tag;\r\nmutex_lock(&ctrl->mbox_lock);\r\nwrb = alloc_mcc_wrb(phba, &tag);\r\nif (!wrb) {\r\nmutex_unlock(&ctrl->mbox_lock);\r\nreturn 0;\r\n}\r\nnonemb_cmd = &phba->boot_struct.nonemb_cmd;\r\nnonemb_cmd->size = sizeof(struct be_cmd_get_session_resp);\r\nnonemb_cmd->va = pci_alloc_consistent(phba->ctrl.pdev,\r\nnonemb_cmd->size,\r\n&nonemb_cmd->dma);\r\nif (!nonemb_cmd->va) {\r\nmutex_unlock(&ctrl->mbox_lock);\r\nreturn 0;\r\n}\r\nreq = nonemb_cmd->va;\r\nmemset(req, 0, sizeof(*req));\r\nsge = nonembedded_sgl(wrb);\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), false, 1);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI_INI,\r\nOPCODE_ISCSI_INI_SESSION_GET_A_SESSION,\r\nsizeof(struct be_cmd_get_session_resp));\r\nreq->session_handle = phba->boot_struct.s_handle;\r\nsge->pa_hi = cpu_to_le32(upper_32_bits(nonemb_cmd->dma));\r\nsge->pa_lo = cpu_to_le32(nonemb_cmd->dma & 0xFFFFFFFF);\r\nsge->len = cpu_to_le32(nonemb_cmd->size);\r\nphba->boot_struct.tag = tag;\r\nset_bit(MCC_TAG_STATE_ASYNC, &ctrl->ptag_state[tag].tag_state);\r\nctrl->ptag_state[tag].cbfn = beiscsi_boot_process_compl;\r\nbe_mcc_notify(phba, tag);\r\nmutex_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nunsigned int __beiscsi_boot_get_shandle(struct beiscsi_hba *phba, int async)\r\n{\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_get_boot_target_req *req;\r\nunsigned int tag;\r\nmutex_lock(&ctrl->mbox_lock);\r\nwrb = alloc_mcc_wrb(phba, &tag);\r\nif (!wrb) {\r\nmutex_unlock(&ctrl->mbox_lock);\r\nreturn 0;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI_INI,\r\nOPCODE_ISCSI_INI_BOOT_GET_BOOT_TARGET,\r\nsizeof(struct be_cmd_get_boot_target_resp));\r\nif (async) {\r\nphba->boot_struct.tag = tag;\r\nset_bit(MCC_TAG_STATE_ASYNC, &ctrl->ptag_state[tag].tag_state);\r\nctrl->ptag_state[tag].cbfn = beiscsi_boot_process_compl;\r\n}\r\nbe_mcc_notify(phba, tag);\r\nmutex_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nint beiscsi_boot_get_shandle(struct beiscsi_hba *phba, unsigned int *s_handle)\r\n{\r\nstruct be_cmd_get_boot_target_resp *boot_resp;\r\nstruct be_mcc_wrb *wrb;\r\nunsigned int tag;\r\nint rc;\r\n*s_handle = BE_BOOT_INVALID_SHANDLE;\r\ntag = __beiscsi_boot_get_shandle(phba, 0);\r\nif (!tag) {\r\nbeiscsi_log(phba, KERN_ERR,\r\nBEISCSI_LOG_CONFIG | BEISCSI_LOG_INIT,\r\n"BG_%d : Getting Boot Target Info Failed\n");\r\nreturn -EAGAIN;\r\n}\r\nrc = beiscsi_mccq_compl_wait(phba, tag, &wrb, NULL);\r\nif (rc) {\r\nbeiscsi_log(phba, KERN_ERR,\r\nBEISCSI_LOG_INIT | BEISCSI_LOG_CONFIG,\r\n"BG_%d : MBX CMD get_boot_target Failed\n");\r\nreturn -EBUSY;\r\n}\r\nboot_resp = embedded_payload(wrb);\r\nif (!boot_resp->boot_session_count) {\r\n__beiscsi_log(phba, KERN_INFO,\r\n"BG_%d : No boot targets configured\n");\r\nreturn -ENXIO;\r\n}\r\n*s_handle = boot_resp->boot_session_handle;\r\nreturn 1;\r\n}\r\nssize_t\r\nbeiscsi_drvr_ver_disp(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, BE_NAME "\n");\r\n}\r\nssize_t\r\nbeiscsi_fw_ver_disp(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct beiscsi_hba *phba = iscsi_host_priv(shost);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", phba->fw_ver_str);\r\n}\r\nssize_t\r\nbeiscsi_active_session_disp(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct beiscsi_hba *phba = iscsi_host_priv(shost);\r\nuint16_t avlbl_cids = 0, ulp_num, len = 0, total_cids = 0;\r\nfor (ulp_num = 0; ulp_num < BEISCSI_ULP_COUNT; ulp_num++) {\r\nif (test_bit(ulp_num, (void *)&phba->fw_config.ulp_supported)) {\r\navlbl_cids = BEISCSI_ULP_AVLBL_CID(phba, ulp_num);\r\ntotal_cids = BEISCSI_GET_CID_COUNT(phba, ulp_num);\r\nlen += snprintf(buf+len, PAGE_SIZE - len,\r\n"ULP%d : %d\n", ulp_num,\r\n(total_cids - avlbl_cids));\r\n} else\r\nlen += snprintf(buf+len, PAGE_SIZE - len,\r\n"ULP%d : %d\n", ulp_num, 0);\r\n}\r\nreturn len;\r\n}\r\nssize_t\r\nbeiscsi_free_session_disp(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct beiscsi_hba *phba = iscsi_host_priv(shost);\r\nuint16_t ulp_num, len = 0;\r\nfor (ulp_num = 0; ulp_num < BEISCSI_ULP_COUNT; ulp_num++) {\r\nif (test_bit(ulp_num, (void *)&phba->fw_config.ulp_supported))\r\nlen += snprintf(buf+len, PAGE_SIZE - len,\r\n"ULP%d : %d\n", ulp_num,\r\nBEISCSI_ULP_AVLBL_CID(phba, ulp_num));\r\nelse\r\nlen += snprintf(buf+len, PAGE_SIZE - len,\r\n"ULP%d : %d\n", ulp_num, 0);\r\n}\r\nreturn len;\r\n}\r\nssize_t\r\nbeiscsi_adap_family_disp(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nuint16_t dev_id = 0;\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct beiscsi_hba *phba = iscsi_host_priv(shost);\r\ndev_id = phba->pcidev->device;\r\nswitch (dev_id) {\r\ncase BE_DEVICE_ID1:\r\ncase OC_DEVICE_ID1:\r\ncase OC_DEVICE_ID2:\r\nreturn snprintf(buf, PAGE_SIZE,\r\n"Obsolete/Unsupported BE2 Adapter Family\n");\r\nbreak;\r\ncase BE_DEVICE_ID2:\r\ncase OC_DEVICE_ID3:\r\nreturn snprintf(buf, PAGE_SIZE, "BE3-R Adapter Family\n");\r\nbreak;\r\ncase OC_SKH_ID1:\r\nreturn snprintf(buf, PAGE_SIZE, "Skyhawk-R Adapter Family\n");\r\nbreak;\r\ndefault:\r\nreturn snprintf(buf, PAGE_SIZE,\r\n"Unknown Adapter Family: 0x%x\n", dev_id);\r\nbreak;\r\n}\r\n}\r\nssize_t\r\nbeiscsi_phys_port_disp(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct beiscsi_hba *phba = iscsi_host_priv(shost);\r\nreturn snprintf(buf, PAGE_SIZE, "Port Identifier : %u\n",\r\nphba->fw_config.phys_port);\r\n}\r\nvoid beiscsi_offload_cxn_v0(struct beiscsi_offload_params *params,\r\nstruct wrb_handle *pwrb_handle,\r\nstruct be_mem_descriptor *mem_descr,\r\nstruct hwi_wrb_context *pwrb_context)\r\n{\r\nstruct iscsi_wrb *pwrb = pwrb_handle->pwrb;\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb,\r\nmax_send_data_segment_length, pwrb,\r\nparams->dw[offsetof(struct amap_beiscsi_offload_params,\r\nmax_send_data_segment_length) / 32]);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb, type, pwrb,\r\nBE_TGT_CTX_UPDT_CMD);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb,\r\nfirst_burst_length,\r\npwrb,\r\nparams->dw[offsetof(struct amap_beiscsi_offload_params,\r\nfirst_burst_length) / 32]);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb, erl, pwrb,\r\n(params->dw[offsetof(struct amap_beiscsi_offload_params,\r\nerl) / 32] & OFFLD_PARAMS_ERL));\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb, dde, pwrb,\r\n(params->dw[offsetof(struct amap_beiscsi_offload_params,\r\ndde) / 32] & OFFLD_PARAMS_DDE) >> 2);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb, hde, pwrb,\r\n(params->dw[offsetof(struct amap_beiscsi_offload_params,\r\nhde) / 32] & OFFLD_PARAMS_HDE) >> 3);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb, ir2t, pwrb,\r\n(params->dw[offsetof(struct amap_beiscsi_offload_params,\r\nir2t) / 32] & OFFLD_PARAMS_IR2T) >> 4);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb, imd, pwrb,\r\n(params->dw[offsetof(struct amap_beiscsi_offload_params,\r\nimd) / 32] & OFFLD_PARAMS_IMD) >> 5);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb, stat_sn,\r\npwrb,\r\n(params->dw[offsetof(struct amap_beiscsi_offload_params,\r\nexp_statsn) / 32] + 1));\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb, wrb_idx,\r\npwrb, pwrb_handle->wrb_index);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb,\r\nmax_burst_length, pwrb, params->dw[offsetof\r\n(struct amap_beiscsi_offload_params,\r\nmax_burst_length) / 32]);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb, ptr2nextwrb,\r\npwrb, pwrb_handle->wrb_index);\r\nif (pwrb_context->plast_wrb)\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb,\r\nptr2nextwrb,\r\npwrb_context->plast_wrb,\r\npwrb_handle->wrb_index);\r\npwrb_context->plast_wrb = pwrb;\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb,\r\nsession_state, pwrb, 0);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb, compltonack,\r\npwrb, 1);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb, notpredblq,\r\npwrb, 0);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb, mode, pwrb,\r\n0);\r\nmem_descr += ISCSI_MEM_GLOBAL_HEADER;\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb,\r\npad_buffer_addr_hi, pwrb,\r\nmem_descr->mem_array[0].bus_address.u.a32.address_hi);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb,\r\npad_buffer_addr_lo, pwrb,\r\nmem_descr->mem_array[0].bus_address.u.a32.address_lo);\r\n}\r\nvoid beiscsi_offload_cxn_v2(struct beiscsi_offload_params *params,\r\nstruct wrb_handle *pwrb_handle,\r\nstruct hwi_wrb_context *pwrb_context)\r\n{\r\nstruct iscsi_wrb *pwrb = pwrb_handle->pwrb;\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2,\r\nmax_burst_length, pwrb, params->dw[offsetof\r\n(struct amap_beiscsi_offload_params,\r\nmax_burst_length) / 32]);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2,\r\ntype, pwrb,\r\nBE_TGT_CTX_UPDT_CMD);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2,\r\nptr2nextwrb,\r\npwrb, pwrb_handle->wrb_index);\r\nif (pwrb_context->plast_wrb)\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2,\r\nptr2nextwrb,\r\npwrb_context->plast_wrb,\r\npwrb_handle->wrb_index);\r\npwrb_context->plast_wrb = pwrb;\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2, wrb_idx,\r\npwrb, pwrb_handle->wrb_index);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2,\r\nmax_send_data_segment_length, pwrb,\r\nparams->dw[offsetof(struct amap_beiscsi_offload_params,\r\nmax_send_data_segment_length) / 32]);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2,\r\nfirst_burst_length, pwrb,\r\nparams->dw[offsetof(struct amap_beiscsi_offload_params,\r\nfirst_burst_length) / 32]);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2,\r\nmax_recv_dataseg_len, pwrb,\r\nparams->dw[offsetof(struct amap_beiscsi_offload_params,\r\nmax_recv_data_segment_length) / 32]);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2,\r\nmax_cxns, pwrb, BEISCSI_MAX_CXNS);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2, erl, pwrb,\r\n(params->dw[offsetof(struct amap_beiscsi_offload_params,\r\nerl) / 32] & OFFLD_PARAMS_ERL));\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2, dde, pwrb,\r\n(params->dw[offsetof(struct amap_beiscsi_offload_params,\r\ndde) / 32] & OFFLD_PARAMS_DDE) >> 2);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2, hde, pwrb,\r\n(params->dw[offsetof(struct amap_beiscsi_offload_params,\r\nhde) / 32] & OFFLD_PARAMS_HDE) >> 3);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2,\r\nir2t, pwrb,\r\n(params->dw[offsetof(struct amap_beiscsi_offload_params,\r\nir2t) / 32] & OFFLD_PARAMS_IR2T) >> 4);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2, imd, pwrb,\r\n(params->dw[offsetof(struct amap_beiscsi_offload_params,\r\nimd) / 32] & OFFLD_PARAMS_IMD) >> 5);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2,\r\ndata_seq_inorder,\r\npwrb,\r\n(params->dw[offsetof(struct amap_beiscsi_offload_params,\r\ndata_seq_inorder) / 32] &\r\nOFFLD_PARAMS_DATA_SEQ_INORDER) >> 6);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2,\r\npdu_seq_inorder,\r\npwrb,\r\n(params->dw[offsetof(struct amap_beiscsi_offload_params,\r\npdu_seq_inorder) / 32] &\r\nOFFLD_PARAMS_PDU_SEQ_INORDER) >> 7);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2, max_r2t,\r\npwrb,\r\n(params->dw[offsetof(struct amap_beiscsi_offload_params,\r\nmax_r2t) / 32] &\r\nOFFLD_PARAMS_MAX_R2T) >> 8);\r\nAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2, stat_sn,\r\npwrb,\r\n(params->dw[offsetof(struct amap_beiscsi_offload_params,\r\nexp_statsn) / 32] + 1));\r\n}\r\nunsigned int beiscsi_invalidate_cxn(struct beiscsi_hba *phba,\r\nstruct beiscsi_endpoint *beiscsi_ep)\r\n{\r\nstruct be_invalidate_connection_params_in *req;\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nstruct be_mcc_wrb *wrb;\r\nunsigned int tag = 0;\r\nmutex_lock(&ctrl->mbox_lock);\r\nwrb = alloc_mcc_wrb(phba, &tag);\r\nif (!wrb) {\r\nmutex_unlock(&ctrl->mbox_lock);\r\nreturn 0;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_hdr_prepare(wrb, sizeof(union be_invalidate_connection_params),\r\ntrue, 0);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI_INI,\r\nOPCODE_ISCSI_INI_DRIVER_INVALIDATE_CONNECTION,\r\nsizeof(*req));\r\nreq->session_handle = beiscsi_ep->fw_handle;\r\nreq->cid = beiscsi_ep->ep_cid;\r\nif (beiscsi_ep->conn)\r\nreq->cleanup_type = BE_CLEANUP_TYPE_INVALIDATE;\r\nelse\r\nreq->cleanup_type = BE_CLEANUP_TYPE_ISSUE_TCP_RST;\r\nreq->save_cfg = 0;\r\nbe_mcc_notify(phba, tag);\r\nmutex_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nunsigned int beiscsi_upload_cxn(struct beiscsi_hba *phba,\r\nstruct beiscsi_endpoint *beiscsi_ep)\r\n{\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_tcp_upload_params_in *req;\r\nunsigned int tag;\r\nmutex_lock(&ctrl->mbox_lock);\r\nwrb = alloc_mcc_wrb(phba, &tag);\r\nif (!wrb) {\r\nmutex_unlock(&ctrl->mbox_lock);\r\nreturn 0;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_hdr_prepare(wrb, sizeof(union be_tcp_upload_params), true, 0);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_COMMON_TCP_UPLOAD,\r\nOPCODE_COMMON_TCP_UPLOAD, sizeof(*req));\r\nreq->id = beiscsi_ep->ep_cid;\r\nif (beiscsi_ep->conn)\r\nreq->upload_type = BE_UPLOAD_TYPE_GRACEFUL;\r\nelse\r\nreq->upload_type = BE_UPLOAD_TYPE_ABORT;\r\nbe_mcc_notify(phba, tag);\r\nmutex_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nint beiscsi_mgmt_invalidate_icds(struct beiscsi_hba *phba,\r\nstruct invldt_cmd_tbl *inv_tbl,\r\nunsigned int nents)\r\n{\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nstruct invldt_cmds_params_in *req;\r\nstruct be_dma_mem nonemb_cmd;\r\nstruct be_mcc_wrb *wrb;\r\nunsigned int i, tag;\r\nstruct be_sge *sge;\r\nint rc;\r\nif (!nents || nents > BE_INVLDT_CMD_TBL_SZ)\r\nreturn -EINVAL;\r\nnonemb_cmd.size = sizeof(union be_invldt_cmds_params);\r\nnonemb_cmd.va = pci_zalloc_consistent(phba->ctrl.pdev,\r\nnonemb_cmd.size,\r\n&nonemb_cmd.dma);\r\nif (!nonemb_cmd.va) {\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_EH,\r\n"BM_%d : invldt_cmds_params alloc failed\n");\r\nreturn -ENOMEM;\r\n}\r\nmutex_lock(&ctrl->mbox_lock);\r\nwrb = alloc_mcc_wrb(phba, &tag);\r\nif (!wrb) {\r\nmutex_unlock(&ctrl->mbox_lock);\r\npci_free_consistent(phba->ctrl.pdev, nonemb_cmd.size,\r\nnonemb_cmd.va, nonemb_cmd.dma);\r\nreturn -ENOMEM;\r\n}\r\nreq = nonemb_cmd.va;\r\nbe_wrb_hdr_prepare(wrb, nonemb_cmd.size, false, 1);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI,\r\nOPCODE_COMMON_ISCSI_ERROR_RECOVERY_INVALIDATE_COMMANDS,\r\nsizeof(*req));\r\nreq->ref_handle = 0;\r\nreq->cleanup_type = CMD_ISCSI_COMMAND_INVALIDATE;\r\nfor (i = 0; i < nents; i++) {\r\nreq->table[i].icd = inv_tbl[i].icd;\r\nreq->table[i].cid = inv_tbl[i].cid;\r\nreq->icd_count++;\r\n}\r\nsge = nonembedded_sgl(wrb);\r\nsge->pa_hi = cpu_to_le32(upper_32_bits(nonemb_cmd.dma));\r\nsge->pa_lo = cpu_to_le32(lower_32_bits(nonemb_cmd.dma));\r\nsge->len = cpu_to_le32(nonemb_cmd.size);\r\nbe_mcc_notify(phba, tag);\r\nmutex_unlock(&ctrl->mbox_lock);\r\nrc = beiscsi_mccq_compl_wait(phba, tag, NULL, &nonemb_cmd);\r\nif (rc != -EBUSY)\r\npci_free_consistent(phba->ctrl.pdev, nonemb_cmd.size,\r\nnonemb_cmd.va, nonemb_cmd.dma);\r\nreturn rc;\r\n}
