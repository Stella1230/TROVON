int execvp_noalloc(char *buf, const char *file, char *const argv[])\r\n{\r\nif (*file == '\0') {\r\nreturn -ENOENT;\r\n}\r\nif (strchr (file, '/') != NULL) {\r\nexecv(file, argv);\r\n} else {\r\nint got_eacces;\r\nsize_t len, pathlen;\r\nchar *name, *p;\r\nchar *path = getenv("PATH");\r\nif (path == NULL)\r\npath = ":/bin:/usr/bin";\r\nlen = strlen(file) + 1;\r\npathlen = strlen(path);\r\nname = memcpy(buf + pathlen + 1, file, len);\r\n*--name = '/';\r\ngot_eacces = 0;\r\np = path;\r\ndo {\r\nchar *startp;\r\npath = p;\r\np = strchr(path, ':');\r\nif (!p)\r\np = strchr(path, '\0');\r\nif (p == path)\r\nstartp = name + 1;\r\nelse\r\nstartp = memcpy(name - (p - path), path, p - path);\r\nexecv(startp, argv);\r\nswitch (errno) {\r\ncase EACCES:\r\ngot_eacces = 1;\r\ncase ENOENT:\r\ncase ESTALE:\r\ncase ENOTDIR:\r\ncase ENODEV:\r\ncase ETIMEDOUT:\r\ncase ENOEXEC:\r\nbreak;\r\ndefault:\r\nreturn -errno;\r\n}\r\n} while (*p++ != '\0');\r\nif (got_eacces)\r\nreturn -EACCES;\r\n}\r\nreturn -errno;\r\n}\r\nint main(int argc, char**argv)\r\n{\r\nchar buf[PATH_MAX];\r\nint ret;\r\nargc--;\r\nif (!argc) {\r\nos_warn("Not enough arguments\n");\r\nreturn 1;\r\n}\r\nargv++;\r\nif (ret = execvp_noalloc(buf, argv[0], argv)) {\r\nerrno = -ret;\r\nperror("execvp_noalloc");\r\n}\r\nreturn 0;\r\n}
