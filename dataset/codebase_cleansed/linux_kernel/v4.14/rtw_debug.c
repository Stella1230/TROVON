void dump_drv_version(void *sel)\r\n{\r\nDBG_871X_SEL_NL(sel, "%s %s\n", "rtl8723bs", DRIVERVERSION);\r\n}\r\nvoid dump_log_level(void *sel)\r\n{\r\nDBG_871X_SEL_NL(sel, "log_level:%d\n", GlobalDebugLevel);\r\n}\r\nvoid sd_f0_reg_dump(void *sel, struct adapter *adapter)\r\n{\r\nint i;\r\nfor (i = 0x0; i <= 0xff; i++) {\r\nif (i%16 == 0)\r\nDBG_871X_SEL_NL(sel, "0x%02x ", i);\r\nDBG_871X_SEL(sel, "%02x ", rtw_sd_f0_read8(adapter, i));\r\nif (i%16 == 15)\r\nDBG_871X_SEL(sel, "\n");\r\nelse if (i%8 == 7)\r\nDBG_871X_SEL(sel, "\t");\r\n}\r\n}\r\nvoid mac_reg_dump(void *sel, struct adapter *adapter)\r\n{\r\nint i, j = 1;\r\nDBG_871X_SEL_NL(sel, "======= MAC REG =======\n");\r\nfor (i = 0x0; i < 0x800; i += 4) {\r\nif (j%4 == 1)\r\nDBG_871X_SEL_NL(sel, "0x%03x", i);\r\nDBG_871X_SEL(sel, " 0x%08x ", rtw_read32(adapter, i));\r\nif ((j++)%4 == 0)\r\nDBG_871X_SEL(sel, "\n");\r\n}\r\n}\r\nvoid bb_reg_dump(void *sel, struct adapter *adapter)\r\n{\r\nint i, j = 1;\r\nDBG_871X_SEL_NL(sel, "======= BB REG =======\n");\r\nfor (i = 0x800; i < 0x1000 ; i += 4) {\r\nif (j%4 == 1)\r\nDBG_871X_SEL_NL(sel, "0x%03x", i);\r\nDBG_871X_SEL(sel, " 0x%08x ", rtw_read32(adapter, i));\r\nif ((j++)%4 == 0)\r\nDBG_871X_SEL(sel, "\n");\r\n}\r\n}\r\nvoid rf_reg_dump(void *sel, struct adapter *adapter)\r\n{\r\nint i, j = 1, path;\r\nu32 value;\r\nu8 rf_type = 0;\r\nu8 path_nums = 0;\r\nrtw_hal_get_hwreg(adapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));\r\nif ((RF_1T2R == rf_type) || (RF_1T1R == rf_type))\r\npath_nums = 1;\r\nelse\r\npath_nums = 2;\r\nDBG_871X_SEL_NL(sel, "======= RF REG =======\n");\r\nfor (path = 0; path < path_nums; path++) {\r\nDBG_871X_SEL_NL(sel, "RF_Path(%x)\n", path);\r\nfor (i = 0; i < 0x100; i++) {\r\nvalue = rtw_hal_read_rfreg(adapter, path, i, 0xffffffff);\r\nif (j%4 == 1)\r\nDBG_871X_SEL_NL(sel, "0x%02x ", i);\r\nDBG_871X_SEL(sel, " 0x%08x ", value);\r\nif ((j++)%4 == 0)\r\nDBG_871X_SEL(sel, "\n");\r\n}\r\n}\r\n}\r\nssize_t proc_set_write_reg(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)\r\n{\r\nstruct net_device *dev = data;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nchar tmp[32];\r\nu32 addr, val, len;\r\nif (count < 3) {\r\nDBG_871X("argument size is less than 3\n");\r\nreturn -EFAULT;\r\n}\r\nif (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {\r\nint num = sscanf(tmp, "%x %x %x", &addr, &val, &len);\r\nif (num != 3) {\r\nDBG_871X("invalid write_reg parameter!\n");\r\nreturn count;\r\n}\r\nswitch (len) {\r\ncase 1:\r\nrtw_write8(padapter, addr, (u8)val);\r\nbreak;\r\ncase 2:\r\nrtw_write16(padapter, addr, (u16)val);\r\nbreak;\r\ncase 4:\r\nrtw_write32(padapter, addr, val);\r\nbreak;\r\ndefault:\r\nDBG_871X("error write length =%d", len);\r\nbreak;\r\n}\r\n}\r\nreturn count;\r\n}\r\nint proc_get_read_reg(struct seq_file *m, void *v)\r\n{\r\nstruct net_device *dev = m->private;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nif (proc_get_read_addr == 0xeeeeeeee) {\r\nDBG_871X_SEL_NL(m, "address not initialized\n");\r\nreturn 0;\r\n}\r\nswitch (proc_get_read_len) {\r\ncase 1:\r\nDBG_871X_SEL_NL(m, "rtw_read8(0x%x) = 0x%x\n", proc_get_read_addr, rtw_read8(padapter, proc_get_read_addr));\r\nbreak;\r\ncase 2:\r\nDBG_871X_SEL_NL(m, "rtw_read16(0x%x) = 0x%x\n", proc_get_read_addr, rtw_read16(padapter, proc_get_read_addr));\r\nbreak;\r\ncase 4:\r\nDBG_871X_SEL_NL(m, "rtw_read32(0x%x) = 0x%x\n", proc_get_read_addr, rtw_read32(padapter, proc_get_read_addr));\r\nbreak;\r\ndefault:\r\nDBG_871X_SEL_NL(m, "error read length =%d\n", proc_get_read_len);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nssize_t proc_set_read_reg(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)\r\n{\r\nchar tmp[16];\r\nu32 addr, len;\r\nif (count < 2) {\r\nDBG_871X("argument size is less than 2\n");\r\nreturn -EFAULT;\r\n}\r\nif (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {\r\nint num = sscanf(tmp, "%x %x", &addr, &len);\r\nif (num != 2) {\r\nDBG_871X("invalid read_reg parameter!\n");\r\nreturn count;\r\n}\r\nproc_get_read_addr = addr;\r\nproc_get_read_len = len;\r\n}\r\nreturn count;\r\n}\r\nint proc_get_fwstate(struct seq_file *m, void *v)\r\n{\r\nstruct net_device *dev = m->private;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nDBG_871X_SEL_NL(m, "fwstate = 0x%x\n", get_fwstate(pmlmepriv));\r\nreturn 0;\r\n}\r\nint proc_get_sec_info(struct seq_file *m, void *v)\r\n{\r\nstruct net_device *dev = m->private;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct security_priv *sec = &padapter->securitypriv;\r\nDBG_871X_SEL_NL(m, "auth_alg = 0x%x, enc_alg = 0x%x, auth_type = 0x%x, enc_type = 0x%x\n",\r\nsec->dot11AuthAlgrthm, sec->dot11PrivacyAlgrthm,\r\nsec->ndisauthtype, sec->ndisencryptstatus);\r\nDBG_871X_SEL_NL(m, "hw_decrypted =%d\n", sec->hw_decrypted);\r\n#ifdef DBG_SW_SEC_CNT\r\nDBG_871X_SEL_NL(m, "wep_sw_enc_cnt =%llu, %llu, %llu\n"\r\n, sec->wep_sw_enc_cnt_bc, sec->wep_sw_enc_cnt_mc, sec->wep_sw_enc_cnt_uc);\r\nDBG_871X_SEL_NL(m, "wep_sw_dec_cnt =%llu, %llu, %llu\n"\r\n, sec->wep_sw_dec_cnt_bc, sec->wep_sw_dec_cnt_mc, sec->wep_sw_dec_cnt_uc);\r\nDBG_871X_SEL_NL(m, "tkip_sw_enc_cnt =%llu, %llu, %llu\n"\r\n, sec->tkip_sw_enc_cnt_bc, sec->tkip_sw_enc_cnt_mc, sec->tkip_sw_enc_cnt_uc);\r\nDBG_871X_SEL_NL(m, "tkip_sw_dec_cnt =%llu, %llu, %llu\n"\r\n, sec->tkip_sw_dec_cnt_bc, sec->tkip_sw_dec_cnt_mc, sec->tkip_sw_dec_cnt_uc);\r\nDBG_871X_SEL_NL(m, "aes_sw_enc_cnt =%llu, %llu, %llu\n"\r\n, sec->aes_sw_enc_cnt_bc, sec->aes_sw_enc_cnt_mc, sec->aes_sw_enc_cnt_uc);\r\nDBG_871X_SEL_NL(m, "aes_sw_dec_cnt =%llu, %llu, %llu\n"\r\n, sec->aes_sw_dec_cnt_bc, sec->aes_sw_dec_cnt_mc, sec->aes_sw_dec_cnt_uc);\r\n#endif\r\nreturn 0;\r\n}\r\nint proc_get_mlmext_state(struct seq_file *m, void *v)\r\n{\r\nstruct net_device *dev = m->private;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nDBG_871X_SEL_NL(m, "pmlmeinfo->state = 0x%x\n", pmlmeinfo->state);\r\nreturn 0;\r\n}\r\nint proc_get_roam_flags(struct seq_file *m, void *v)\r\n{\r\nstruct net_device *dev = m->private;\r\nstruct adapter *adapter = (struct adapter *)rtw_netdev_priv(dev);\r\nDBG_871X_SEL_NL(m, "0x%02x\n", rtw_roam_flags(adapter));\r\nreturn 0;\r\n}\r\nssize_t proc_set_roam_flags(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)\r\n{\r\nstruct net_device *dev = data;\r\nstruct adapter *adapter = (struct adapter *)rtw_netdev_priv(dev);\r\nchar tmp[32];\r\nu8 flags;\r\nif (count < 1)\r\nreturn -EFAULT;\r\nif (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {\r\nint num = sscanf(tmp, "%hhx", &flags);\r\nif (num == 1)\r\nrtw_assign_roam_flags(adapter, flags);\r\n}\r\nreturn count;\r\n}\r\nint proc_get_roam_param(struct seq_file *m, void *v)\r\n{\r\nstruct net_device *dev = m->private;\r\nstruct adapter *adapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct mlme_priv *mlme = &adapter->mlmepriv;\r\nDBG_871X_SEL_NL(m, "%12s %12s %11s\n", "rssi_diff_th", "scanr_exp_ms", "scan_int_ms");\r\nDBG_871X_SEL_NL(m, "%-12u %-12u %-11u\n"\r\n, mlme->roam_rssi_diff_th\r\n, mlme->roam_scanr_exp_ms\r\n, mlme->roam_scan_int_ms\r\n);\r\nreturn 0;\r\n}\r\nssize_t proc_set_roam_param(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)\r\n{\r\nstruct net_device *dev = data;\r\nstruct adapter *adapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct mlme_priv *mlme = &adapter->mlmepriv;\r\nchar tmp[32];\r\nu8 rssi_diff_th;\r\nu32 scanr_exp_ms;\r\nu32 scan_int_ms;\r\nif (count < 1)\r\nreturn -EFAULT;\r\nif (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {\r\nint num = sscanf(tmp, "%hhu %u %u", &rssi_diff_th, &scanr_exp_ms, &scan_int_ms);\r\nif (num >= 1)\r\nmlme->roam_rssi_diff_th = rssi_diff_th;\r\nif (num >= 2)\r\nmlme->roam_scanr_exp_ms = scanr_exp_ms;\r\nif (num >= 3)\r\nmlme->roam_scan_int_ms = scan_int_ms;\r\n}\r\nreturn count;\r\n}\r\nssize_t proc_set_roam_tgt_addr(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)\r\n{\r\nstruct net_device *dev = data;\r\nstruct adapter *adapter = (struct adapter *)rtw_netdev_priv(dev);\r\nchar tmp[32];\r\nu8 addr[ETH_ALEN];\r\nif (count < 1)\r\nreturn -EFAULT;\r\nif (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {\r\nint num = sscanf(tmp, "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx", addr, addr+1, addr+2, addr+3, addr+4, addr+5);\r\nif (num == 6)\r\nmemcpy(adapter->mlmepriv.roam_tgt_addr, addr, ETH_ALEN);\r\nDBG_871X("set roam_tgt_addr to "MAC_FMT"\n", MAC_ARG(adapter->mlmepriv.roam_tgt_addr));\r\n}\r\nreturn count;\r\n}\r\nint proc_get_qos_option(struct seq_file *m, void *v)\r\n{\r\nstruct net_device *dev = m->private;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nDBG_871X_SEL_NL(m, "qos_option =%d\n", pmlmepriv->qospriv.qos_option);\r\nreturn 0;\r\n}\r\nint proc_get_ht_option(struct seq_file *m, void *v)\r\n{\r\nstruct net_device *dev = m->private;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nDBG_871X_SEL_NL(m, "ht_option =%d\n", pmlmepriv->htpriv.ht_option);\r\nreturn 0;\r\n}\r\nint proc_get_rf_info(struct seq_file *m, void *v)\r\n{\r\nstruct net_device *dev = m->private;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nDBG_871X_SEL_NL(m, "cur_ch =%d, cur_bw =%d, cur_ch_offet =%d\n",\r\npmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);\r\nDBG_871X_SEL_NL(m, "oper_ch =%d, oper_bw =%d, oper_ch_offet =%d\n",\r\nrtw_get_oper_ch(padapter), rtw_get_oper_bw(padapter), rtw_get_oper_choffset(padapter));\r\nreturn 0;\r\n}\r\nint proc_get_survey_info(struct seq_file *m, void *v)\r\n{\r\nstruct net_device *dev = m->private;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nstruct __queue *queue = &(pmlmepriv->scanned_queue);\r\nstruct wlan_network *pnetwork = NULL;\r\nstruct list_head *plist, *phead;\r\ns32 notify_signal;\r\ns16 notify_noise = 0;\r\nu16 index = 0;\r\nspin_lock_bh(&(pmlmepriv->scanned_queue.lock));\r\nphead = get_list_head(queue);\r\nplist = phead ? get_next(phead) : NULL;\r\nif ((!phead) || (!plist)) {\r\nspin_unlock_bh(&(pmlmepriv->scanned_queue.lock));\r\nreturn 0;\r\n}\r\nDBG_871X_SEL_NL(m, "%5s %-17s %3s %-3s %-4s %-4s %5s %s\n", "index", "bssid", "ch", "RSSI", "SdBm", "Noise", "age", "ssid");\r\nwhile (1) {\r\nif (phead == plist)\r\nbreak;\r\npnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);\r\nif (!pnetwork)\r\nbreak;\r\nif (check_fwstate(pmlmepriv, _FW_LINKED) == true &&\r\nis_same_network(&pmlmepriv->cur_network.network, &pnetwork->network, 0)) {\r\nnotify_signal = translate_percentage_to_dbm(padapter->recvpriv.signal_strength);\r\n} else {\r\nnotify_signal = translate_percentage_to_dbm(pnetwork->network.PhyInfo.SignalStrength);\r\n}\r\n#if defined(CONFIG_SIGNAL_DISPLAY_DBM) && defined(CONFIG_BACKGROUND_NOISE_MONITOR)\r\nrtw_hal_get_odm_var(padapter, HAL_ODM_NOISE_MONITOR, &(pnetwork->network.Configuration.DSConfig), &(notify_noise));\r\n#endif\r\nDBG_871X_SEL_NL(m, "%5d "MAC_FMT" %3d %3d %4d %4d %5d %s\n",\r\n++index,\r\nMAC_ARG(pnetwork->network.MacAddress),\r\npnetwork->network.Configuration.DSConfig,\r\n(int)pnetwork->network.Rssi,\r\nnotify_signal,\r\nnotify_noise,\r\njiffies_to_msecs(jiffies - pnetwork->last_scanned),\r\npnetwork->network.Ssid.Ssid);\r\nplist = get_next(plist);\r\n}\r\nspin_unlock_bh(&(pmlmepriv->scanned_queue.lock));\r\nreturn 0;\r\n}\r\nint proc_get_ap_info(struct seq_file *m, void *v)\r\n{\r\nstruct net_device *dev = m->private;\r\nstruct sta_info *psta;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct wlan_network *cur_network = &(pmlmepriv->cur_network);\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\npsta = rtw_get_stainfo(pstapriv, cur_network->network.MacAddress);\r\nif (psta) {\r\nint i;\r\nstruct recv_reorder_ctrl *preorder_ctrl;\r\nDBG_871X_SEL_NL(m, "SSID =%s\n", cur_network->network.Ssid.Ssid);\r\nDBG_871X_SEL_NL(m, "sta's macaddr:" MAC_FMT "\n", MAC_ARG(psta->hwaddr));\r\nDBG_871X_SEL_NL(m, "cur_channel =%d, cur_bwmode =%d, cur_ch_offset =%d\n", pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);\r\nDBG_871X_SEL_NL(m, "wireless_mode = 0x%x, rtsen =%d, cts2slef =%d\n", psta->wireless_mode, psta->rtsen, psta->cts2self);\r\nDBG_871X_SEL_NL(m, "state = 0x%x, aid =%d, macid =%d, raid =%d\n", psta->state, psta->aid, psta->mac_id, psta->raid);\r\nDBG_871X_SEL_NL(m, "qos_en =%d, ht_en =%d, init_rate =%d\n", psta->qos_option, psta->htpriv.ht_option, psta->init_rate);\r\nDBG_871X_SEL_NL(m, "bwmode =%d, ch_offset =%d, sgi_20m =%d, sgi_40m =%d\n", psta->bw_mode, psta->htpriv.ch_offset, psta->htpriv.sgi_20m, psta->htpriv.sgi_40m);\r\nDBG_871X_SEL_NL(m, "ampdu_enable = %d\n", psta->htpriv.ampdu_enable);\r\nDBG_871X_SEL_NL(m, "agg_enable_bitmap =%x, candidate_tid_bitmap =%x\n", psta->htpriv.agg_enable_bitmap, psta->htpriv.candidate_tid_bitmap);\r\nDBG_871X_SEL_NL(m, "ldpc_cap = 0x%x, stbc_cap = 0x%x, beamform_cap = 0x%x\n", psta->htpriv.ldpc_cap, psta->htpriv.stbc_cap, psta->htpriv.beamform_cap);\r\nfor (i = 0; i < 16; i++) {\r\npreorder_ctrl = &psta->recvreorder_ctrl[i];\r\nif (preorder_ctrl->enable) {\r\nDBG_871X_SEL_NL(m, "tid =%d, indicate_seq =%d\n", i, preorder_ctrl->indicate_seq);\r\n}\r\n}\r\n} else{\r\nDBG_871X_SEL_NL(m, "can't get sta's macaddr, cur_network's macaddr:" MAC_FMT "\n", MAC_ARG(cur_network->network.MacAddress));\r\n}\r\nreturn 0;\r\n}\r\nint proc_get_adapter_state(struct seq_file *m, void *v)\r\n{\r\nstruct net_device *dev = m->private;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nDBG_871X_SEL_NL(m, "name =%s, bSurpriseRemoved =%d, bDriverStopped =%d\n",\r\ndev->name, padapter->bSurpriseRemoved, padapter->bDriverStopped);\r\nreturn 0;\r\n}\r\nint proc_get_trx_info(struct seq_file *m, void *v)\r\n{\r\nstruct net_device *dev = m->private;\r\nint i;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nstruct recv_priv *precvpriv = &padapter->recvpriv;\r\nstruct hw_xmit *phwxmit;\r\nDBG_871X_SEL_NL(m, "free_xmitbuf_cnt =%d, free_xmitframe_cnt =%d\n"\r\n, pxmitpriv->free_xmitbuf_cnt, pxmitpriv->free_xmitframe_cnt);\r\nDBG_871X_SEL_NL(m, "free_ext_xmitbuf_cnt =%d, free_xframe_ext_cnt =%d\n"\r\n, pxmitpriv->free_xmit_extbuf_cnt, pxmitpriv->free_xframe_ext_cnt);\r\nDBG_871X_SEL_NL(m, "free_recvframe_cnt =%d\n"\r\n, precvpriv->free_recvframe_cnt);\r\nfor (i = 0; i < 4; i++) {\r\nphwxmit = pxmitpriv->hwxmits + i;\r\nDBG_871X_SEL_NL(m, "%d, hwq.accnt =%d\n", i, phwxmit->accnt);\r\n}\r\nreturn 0;\r\n}\r\nint proc_get_rate_ctl(struct seq_file *m, void *v)\r\n{\r\nstruct net_device *dev = m->private;\r\nstruct adapter *adapter = (struct adapter *)rtw_netdev_priv(dev);\r\nif (adapter->fix_rate != 0xff) {\r\nDBG_871X_SEL_NL(m, "FIX\n");\r\nDBG_871X_SEL_NL(m, "0x%02x\n", adapter->fix_rate);\r\n} else {\r\nDBG_871X_SEL_NL(m, "RA\n");\r\n}\r\nreturn 0;\r\n}\r\nssize_t proc_set_rate_ctl(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)\r\n{\r\nstruct net_device *dev = data;\r\nstruct adapter *adapter = (struct adapter *)rtw_netdev_priv(dev);\r\nchar tmp[32];\r\nu8 fix_rate;\r\nif (count < 1)\r\nreturn -EFAULT;\r\nif (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {\r\nint num = sscanf(tmp, "%hhx", &fix_rate);\r\nif (num >= 1)\r\nadapter->fix_rate = fix_rate;\r\n}\r\nreturn count;\r\n}\r\nssize_t proc_set_fwdl_test_case(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)\r\n{\r\nchar tmp[32];\r\nif (count < 1)\r\nreturn -EFAULT;\r\nif (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {\r\nsscanf(tmp, "%hhu %hhu", &g_fwdl_chksum_fail, &g_fwdl_wintint_rdy_fail);\r\n}\r\nreturn count;\r\n}\r\nssize_t proc_set_wait_hiq_empty(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)\r\n{\r\nchar tmp[32];\r\nif (count < 1)\r\nreturn -EFAULT;\r\nif (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {\r\nsscanf(tmp, "%u", &g_wait_hiq_empty);\r\n}\r\nreturn count;\r\n}\r\nint proc_get_suspend_resume_info(struct seq_file *m, void *v)\r\n{\r\nstruct net_device *dev = m->private;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct dvobj_priv *dvobj = padapter->dvobj;\r\nstruct debug_priv *pdbgpriv = &dvobj->drv_dbg;\r\nDBG_871X_SEL_NL(m, "dbg_sdio_alloc_irq_cnt =%d\n", pdbgpriv->dbg_sdio_alloc_irq_cnt);\r\nDBG_871X_SEL_NL(m, "dbg_sdio_free_irq_cnt =%d\n", pdbgpriv->dbg_sdio_free_irq_cnt);\r\nDBG_871X_SEL_NL(m, "dbg_sdio_alloc_irq_error_cnt =%d\n", pdbgpriv->dbg_sdio_alloc_irq_error_cnt);\r\nDBG_871X_SEL_NL(m, "dbg_sdio_free_irq_error_cnt =%d\n", pdbgpriv->dbg_sdio_free_irq_error_cnt);\r\nDBG_871X_SEL_NL(m, "dbg_sdio_init_error_cnt =%d\n", pdbgpriv->dbg_sdio_init_error_cnt);\r\nDBG_871X_SEL_NL(m, "dbg_sdio_deinit_error_cnt =%d\n", pdbgpriv->dbg_sdio_deinit_error_cnt);\r\nDBG_871X_SEL_NL(m, "dbg_suspend_error_cnt =%d\n", pdbgpriv->dbg_suspend_error_cnt);\r\nDBG_871X_SEL_NL(m, "dbg_suspend_cnt =%d\n", pdbgpriv->dbg_suspend_cnt);\r\nDBG_871X_SEL_NL(m, "dbg_resume_cnt =%d\n", pdbgpriv->dbg_resume_cnt);\r\nDBG_871X_SEL_NL(m, "dbg_resume_error_cnt =%d\n", pdbgpriv->dbg_resume_error_cnt);\r\nDBG_871X_SEL_NL(m, "dbg_deinit_fail_cnt =%d\n", pdbgpriv->dbg_deinit_fail_cnt);\r\nDBG_871X_SEL_NL(m, "dbg_carddisable_cnt =%d\n", pdbgpriv->dbg_carddisable_cnt);\r\nDBG_871X_SEL_NL(m, "dbg_ps_insuspend_cnt =%d\n", pdbgpriv->dbg_ps_insuspend_cnt);\r\nDBG_871X_SEL_NL(m, "dbg_dev_unload_inIPS_cnt =%d\n", pdbgpriv->dbg_dev_unload_inIPS_cnt);\r\nDBG_871X_SEL_NL(m, "dbg_scan_pwr_state_cnt =%d\n", pdbgpriv->dbg_scan_pwr_state_cnt);\r\nDBG_871X_SEL_NL(m, "dbg_downloadfw_pwr_state_cnt =%d\n", pdbgpriv->dbg_downloadfw_pwr_state_cnt);\r\nDBG_871X_SEL_NL(m, "dbg_carddisable_error_cnt =%d\n", pdbgpriv->dbg_carddisable_error_cnt);\r\nDBG_871X_SEL_NL(m, "dbg_fw_read_ps_state_fail_cnt =%d\n", pdbgpriv->dbg_fw_read_ps_state_fail_cnt);\r\nDBG_871X_SEL_NL(m, "dbg_leave_ips_fail_cnt =%d\n", pdbgpriv->dbg_leave_ips_fail_cnt);\r\nDBG_871X_SEL_NL(m, "dbg_leave_lps_fail_cnt =%d\n", pdbgpriv->dbg_leave_lps_fail_cnt);\r\nDBG_871X_SEL_NL(m, "dbg_h2c_leave32k_fail_cnt =%d\n", pdbgpriv->dbg_h2c_leave32k_fail_cnt);\r\nDBG_871X_SEL_NL(m, "dbg_diswow_dload_fw_fail_cnt =%d\n", pdbgpriv->dbg_diswow_dload_fw_fail_cnt);\r\nDBG_871X_SEL_NL(m, "dbg_enwow_dload_fw_fail_cnt =%d\n", pdbgpriv->dbg_enwow_dload_fw_fail_cnt);\r\nDBG_871X_SEL_NL(m, "dbg_ips_drvopen_fail_cnt =%d\n", pdbgpriv->dbg_ips_drvopen_fail_cnt);\r\nDBG_871X_SEL_NL(m, "dbg_poll_fail_cnt =%d\n", pdbgpriv->dbg_poll_fail_cnt);\r\nDBG_871X_SEL_NL(m, "dbg_rpwm_toogle_cnt =%d\n", pdbgpriv->dbg_rpwm_toogle_cnt);\r\nDBG_871X_SEL_NL(m, "dbg_rpwm_timeout_fail_cnt =%d\n", pdbgpriv->dbg_rpwm_timeout_fail_cnt);\r\nreturn 0;\r\n}\r\nint proc_get_rx_logs(struct seq_file *m, void *v)\r\n{\r\nstruct net_device *dev = m->private;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct rx_logs *rx_logs = &padapter->rx_logs;\r\nDBG_871X_SEL_NL(m,\r\n"intf_rx =%d\n"\r\n"intf_rx_err_recvframe =%d\n"\r\n"intf_rx_err_skb =%d\n"\r\n"intf_rx_report =%d\n"\r\n"core_rx =%d\n"\r\n"core_rx_pre =%d\n"\r\n"core_rx_pre_ver_err =%d\n"\r\n"core_rx_pre_mgmt =%d\n"\r\n"core_rx_pre_mgmt_err_80211w =%d\n"\r\n"core_rx_pre_mgmt_err =%d\n"\r\n"core_rx_pre_ctrl =%d\n"\r\n"core_rx_pre_ctrl_err =%d\n"\r\n"core_rx_pre_data =%d\n"\r\n"core_rx_pre_data_wapi_seq_err =%d\n"\r\n"core_rx_pre_data_wapi_key_err =%d\n"\r\n"core_rx_pre_data_handled =%d\n"\r\n"core_rx_pre_data_err =%d\n"\r\n"core_rx_pre_data_unknown =%d\n"\r\n"core_rx_pre_unknown =%d\n"\r\n"core_rx_enqueue =%d\n"\r\n"core_rx_dequeue =%d\n"\r\n"core_rx_post =%d\n"\r\n"core_rx_post_decrypt =%d\n"\r\n"core_rx_post_decrypt_wep =%d\n"\r\n"core_rx_post_decrypt_tkip =%d\n"\r\n"core_rx_post_decrypt_aes =%d\n"\r\n"core_rx_post_decrypt_wapi =%d\n"\r\n"core_rx_post_decrypt_hw =%d\n"\r\n"core_rx_post_decrypt_unknown =%d\n"\r\n"core_rx_post_decrypt_err =%d\n"\r\n"core_rx_post_defrag_err =%d\n"\r\n"core_rx_post_portctrl_err =%d\n"\r\n"core_rx_post_indicate =%d\n"\r\n"core_rx_post_indicate_in_oder =%d\n"\r\n"core_rx_post_indicate_reoder =%d\n"\r\n"core_rx_post_indicate_err =%d\n"\r\n"os_indicate =%d\n"\r\n"os_indicate_ap_mcast =%d\n"\r\n"os_indicate_ap_forward =%d\n"\r\n"os_indicate_ap_self =%d\n"\r\n"os_indicate_err =%d\n"\r\n"os_netif_ok =%d\n"\r\n"os_netif_err =%d\n",\r\nrx_logs->intf_rx,\r\nrx_logs->intf_rx_err_recvframe,\r\nrx_logs->intf_rx_err_skb,\r\nrx_logs->intf_rx_report,\r\nrx_logs->core_rx,\r\nrx_logs->core_rx_pre,\r\nrx_logs->core_rx_pre_ver_err,\r\nrx_logs->core_rx_pre_mgmt,\r\nrx_logs->core_rx_pre_mgmt_err_80211w,\r\nrx_logs->core_rx_pre_mgmt_err,\r\nrx_logs->core_rx_pre_ctrl,\r\nrx_logs->core_rx_pre_ctrl_err,\r\nrx_logs->core_rx_pre_data,\r\nrx_logs->core_rx_pre_data_wapi_seq_err,\r\nrx_logs->core_rx_pre_data_wapi_key_err,\r\nrx_logs->core_rx_pre_data_handled,\r\nrx_logs->core_rx_pre_data_err,\r\nrx_logs->core_rx_pre_data_unknown,\r\nrx_logs->core_rx_pre_unknown,\r\nrx_logs->core_rx_enqueue,\r\nrx_logs->core_rx_dequeue,\r\nrx_logs->core_rx_post,\r\nrx_logs->core_rx_post_decrypt,\r\nrx_logs->core_rx_post_decrypt_wep,\r\nrx_logs->core_rx_post_decrypt_tkip,\r\nrx_logs->core_rx_post_decrypt_aes,\r\nrx_logs->core_rx_post_decrypt_wapi,\r\nrx_logs->core_rx_post_decrypt_hw,\r\nrx_logs->core_rx_post_decrypt_unknown,\r\nrx_logs->core_rx_post_decrypt_err,\r\nrx_logs->core_rx_post_defrag_err,\r\nrx_logs->core_rx_post_portctrl_err,\r\nrx_logs->core_rx_post_indicate,\r\nrx_logs->core_rx_post_indicate_in_oder,\r\nrx_logs->core_rx_post_indicate_reoder,\r\nrx_logs->core_rx_post_indicate_err,\r\nrx_logs->os_indicate,\r\nrx_logs->os_indicate_ap_mcast,\r\nrx_logs->os_indicate_ap_forward,\r\nrx_logs->os_indicate_ap_self,\r\nrx_logs->os_indicate_err,\r\nrx_logs->os_netif_ok,\r\nrx_logs->os_netif_err\r\n);\r\nreturn 0;\r\n}\r\nint proc_get_tx_logs(struct seq_file *m, void *v)\r\n{\r\nstruct net_device *dev = m->private;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct tx_logs *tx_logs = &padapter->tx_logs;\r\nDBG_871X_SEL_NL(m,\r\n"os_tx =%d\n"\r\n"os_tx_err_up =%d\n"\r\n"os_tx_err_xmit =%d\n"\r\n"os_tx_m2u =%d\n"\r\n"os_tx_m2u_ignore_fw_linked =%d\n"\r\n"os_tx_m2u_ignore_self =%d\n"\r\n"os_tx_m2u_entry =%d\n"\r\n"os_tx_m2u_entry_err_xmit =%d\n"\r\n"os_tx_m2u_entry_err_skb =%d\n"\r\n"os_tx_m2u_stop =%d\n"\r\n"core_tx =%d\n"\r\n"core_tx_err_pxmitframe =%d\n"\r\n"core_tx_err_brtx =%d\n"\r\n"core_tx_upd_attrib =%d\n"\r\n"core_tx_upd_attrib_adhoc =%d\n"\r\n"core_tx_upd_attrib_sta =%d\n"\r\n"core_tx_upd_attrib_ap =%d\n"\r\n"core_tx_upd_attrib_unknown =%d\n"\r\n"core_tx_upd_attrib_dhcp =%d\n"\r\n"core_tx_upd_attrib_icmp =%d\n"\r\n"core_tx_upd_attrib_active =%d\n"\r\n"core_tx_upd_attrib_err_ucast_sta =%d\n"\r\n"core_tx_upd_attrib_err_ucast_ap_link =%d\n"\r\n"core_tx_upd_attrib_err_sta =%d\n"\r\n"core_tx_upd_attrib_err_link =%d\n"\r\n"core_tx_upd_attrib_err_sec =%d\n"\r\n"core_tx_ap_enqueue_warn_fwstate =%d\n"\r\n"core_tx_ap_enqueue_warn_sta =%d\n"\r\n"core_tx_ap_enqueue_warn_nosta =%d\n"\r\n"core_tx_ap_enqueue_warn_link =%d\n"\r\n"core_tx_ap_enqueue_warn_trigger =%d\n"\r\n"core_tx_ap_enqueue_mcast =%d\n"\r\n"core_tx_ap_enqueue_ucast =%d\n"\r\n"core_tx_ap_enqueue =%d\n"\r\n"intf_tx =%d\n"\r\n"intf_tx_pending_ac =%d\n"\r\n"intf_tx_pending_fw_under_survey =%d\n"\r\n"intf_tx_pending_fw_under_linking =%d\n"\r\n"intf_tx_pending_xmitbuf =%d\n"\r\n"intf_tx_enqueue =%d\n"\r\n"core_tx_enqueue =%d\n"\r\n"core_tx_enqueue_class =%d\n"\r\n"core_tx_enqueue_class_err_sta =%d\n"\r\n"core_tx_enqueue_class_err_nosta =%d\n"\r\n"core_tx_enqueue_class_err_fwlink =%d\n"\r\n"intf_tx_direct =%d\n"\r\n"intf_tx_direct_err_coalesce =%d\n"\r\n"intf_tx_dequeue =%d\n"\r\n"intf_tx_dequeue_err_coalesce =%d\n"\r\n"intf_tx_dump_xframe =%d\n"\r\n"intf_tx_dump_xframe_err_txdesc =%d\n"\r\n"intf_tx_dump_xframe_err_port =%d\n",\r\ntx_logs->os_tx,\r\ntx_logs->os_tx_err_up,\r\ntx_logs->os_tx_err_xmit,\r\ntx_logs->os_tx_m2u,\r\ntx_logs->os_tx_m2u_ignore_fw_linked,\r\ntx_logs->os_tx_m2u_ignore_self,\r\ntx_logs->os_tx_m2u_entry,\r\ntx_logs->os_tx_m2u_entry_err_xmit,\r\ntx_logs->os_tx_m2u_entry_err_skb,\r\ntx_logs->os_tx_m2u_stop,\r\ntx_logs->core_tx,\r\ntx_logs->core_tx_err_pxmitframe,\r\ntx_logs->core_tx_err_brtx,\r\ntx_logs->core_tx_upd_attrib,\r\ntx_logs->core_tx_upd_attrib_adhoc,\r\ntx_logs->core_tx_upd_attrib_sta,\r\ntx_logs->core_tx_upd_attrib_ap,\r\ntx_logs->core_tx_upd_attrib_unknown,\r\ntx_logs->core_tx_upd_attrib_dhcp,\r\ntx_logs->core_tx_upd_attrib_icmp,\r\ntx_logs->core_tx_upd_attrib_active,\r\ntx_logs->core_tx_upd_attrib_err_ucast_sta,\r\ntx_logs->core_tx_upd_attrib_err_ucast_ap_link,\r\ntx_logs->core_tx_upd_attrib_err_sta,\r\ntx_logs->core_tx_upd_attrib_err_link,\r\ntx_logs->core_tx_upd_attrib_err_sec,\r\ntx_logs->core_tx_ap_enqueue_warn_fwstate,\r\ntx_logs->core_tx_ap_enqueue_warn_sta,\r\ntx_logs->core_tx_ap_enqueue_warn_nosta,\r\ntx_logs->core_tx_ap_enqueue_warn_link,\r\ntx_logs->core_tx_ap_enqueue_warn_trigger,\r\ntx_logs->core_tx_ap_enqueue_mcast,\r\ntx_logs->core_tx_ap_enqueue_ucast,\r\ntx_logs->core_tx_ap_enqueue,\r\ntx_logs->intf_tx,\r\ntx_logs->intf_tx_pending_ac,\r\ntx_logs->intf_tx_pending_fw_under_survey,\r\ntx_logs->intf_tx_pending_fw_under_linking,\r\ntx_logs->intf_tx_pending_xmitbuf,\r\ntx_logs->intf_tx_enqueue,\r\ntx_logs->core_tx_enqueue,\r\ntx_logs->core_tx_enqueue_class,\r\ntx_logs->core_tx_enqueue_class_err_sta,\r\ntx_logs->core_tx_enqueue_class_err_nosta,\r\ntx_logs->core_tx_enqueue_class_err_fwlink,\r\ntx_logs->intf_tx_direct,\r\ntx_logs->intf_tx_direct_err_coalesce,\r\ntx_logs->intf_tx_dequeue,\r\ntx_logs->intf_tx_dequeue_err_coalesce,\r\ntx_logs->intf_tx_dump_xframe,\r\ntx_logs->intf_tx_dump_xframe_err_txdesc,\r\ntx_logs->intf_tx_dump_xframe_err_port\r\n);\r\nreturn 0;\r\n}\r\nint proc_get_int_logs(struct seq_file *m, void *v)\r\n{\r\nstruct net_device *dev = m->private;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nDBG_871X_SEL_NL(m,\r\n"all =%d\n"\r\n"err =%d\n"\r\n"tbdok =%d\n"\r\n"tbder =%d\n"\r\n"bcnderr =%d\n"\r\n"bcndma =%d\n"\r\n"bcndma_e =%d\n"\r\n"rx =%d\n"\r\n"rx_rdu =%d\n"\r\n"rx_fovw =%d\n"\r\n"txfovw =%d\n"\r\n"mgntok =%d\n"\r\n"highdok =%d\n"\r\n"bkdok =%d\n"\r\n"bedok =%d\n"\r\n"vidok =%d\n"\r\n"vodok =%d\n",\r\npadapter->int_logs.all,\r\npadapter->int_logs.err,\r\npadapter->int_logs.tbdok,\r\npadapter->int_logs.tbder,\r\npadapter->int_logs.bcnderr,\r\npadapter->int_logs.bcndma,\r\npadapter->int_logs.bcndma_e,\r\npadapter->int_logs.rx,\r\npadapter->int_logs.rx_rdu,\r\npadapter->int_logs.rx_fovw,\r\npadapter->int_logs.txfovw,\r\npadapter->int_logs.mgntok,\r\npadapter->int_logs.highdok,\r\npadapter->int_logs.bkdok,\r\npadapter->int_logs.bedok,\r\npadapter->int_logs.vidok,\r\npadapter->int_logs.vodok\r\n);\r\nreturn 0;\r\n}\r\nint proc_get_rx_signal(struct seq_file *m, void *v)\r\n{\r\nstruct net_device *dev = m->private;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nDBG_871X_SEL_NL(m, "rssi:%d\n", padapter->recvpriv.rssi);\r\nDBG_871X_SEL_NL(m, "signal_strength:%u\n", padapter->recvpriv.signal_strength);\r\nDBG_871X_SEL_NL(m, "signal_qual:%u\n", padapter->recvpriv.signal_qual);\r\nDBG_871X_SEL_NL(m, "noise:%d\n", padapter->recvpriv.noise);\r\nrtw_odm_get_perpkt_rssi(m, padapter);\r\n#ifdef DBG_RX_SIGNAL_DISPLAY_RAW_DATA\r\nrtw_get_raw_rssi_info(m, padapter);\r\n#endif\r\nreturn 0;\r\n}\r\nint proc_get_hw_status(struct seq_file *m, void *v)\r\n{\r\nstruct net_device *dev = m->private;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct dvobj_priv *dvobj = padapter->dvobj;\r\nstruct debug_priv *pdbgpriv = &dvobj->drv_dbg;\r\nDBG_871X_SEL_NL(m, "RX FIFO full count: last_time =%lld, current_time =%lld, differential =%lld\n"\r\n, pdbgpriv->dbg_rx_fifo_last_overflow, pdbgpriv->dbg_rx_fifo_curr_overflow, pdbgpriv->dbg_rx_fifo_diff_overflow);\r\nreturn 0;\r\n}\r\nssize_t proc_set_rx_signal(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)\r\n{\r\nstruct net_device *dev = data;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nchar tmp[32];\r\nu32 is_signal_dbg, signal_strength;\r\nif (count < 1)\r\nreturn -EFAULT;\r\nif (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {\r\nint num = sscanf(tmp, "%u %u", &is_signal_dbg, &signal_strength);\r\nis_signal_dbg = is_signal_dbg == 0?0:1;\r\nif (is_signal_dbg && num != 2)\r\nreturn count;\r\nsignal_strength = signal_strength > 100?100:signal_strength;\r\npadapter->recvpriv.is_signal_dbg = is_signal_dbg;\r\npadapter->recvpriv.signal_strength_dbg = signal_strength;\r\nif (is_signal_dbg)\r\nDBG_871X("set %s %u\n", "DBG_SIGNAL_STRENGTH", signal_strength);\r\nelse\r\nDBG_871X("set %s\n", "HW_SIGNAL_STRENGTH");\r\n}\r\nreturn count;\r\n}\r\nint proc_get_ht_enable(struct seq_file *m, void *v)\r\n{\r\nstruct net_device *dev = m->private;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct registry_priv *pregpriv = &padapter->registrypriv;\r\nif (pregpriv)\r\nDBG_871X_SEL_NL(m, "%d\n", pregpriv->ht_enable);\r\nreturn 0;\r\n}\r\nssize_t proc_set_ht_enable(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)\r\n{\r\nstruct net_device *dev = data;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct registry_priv *pregpriv = &padapter->registrypriv;\r\nchar tmp[32];\r\nu32 mode;\r\nif (count < 1)\r\nreturn -EFAULT;\r\nif (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {\r\nsscanf(tmp, "%d ", &mode);\r\nif (pregpriv && mode < 2) {\r\npregpriv->ht_enable = mode;\r\nprintk("ht_enable =%d\n", pregpriv->ht_enable);\r\n}\r\n}\r\nreturn count;\r\n}\r\nint proc_get_bw_mode(struct seq_file *m, void *v)\r\n{\r\nstruct net_device *dev = m->private;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct registry_priv *pregpriv = &padapter->registrypriv;\r\nif (pregpriv)\r\nDBG_871X_SEL_NL(m, "0x%02x\n", pregpriv->bw_mode);\r\nreturn 0;\r\n}\r\nssize_t proc_set_bw_mode(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)\r\n{\r\nstruct net_device *dev = data;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct registry_priv *pregpriv = &padapter->registrypriv;\r\nchar tmp[32];\r\nu32 mode;\r\nif (count < 1)\r\nreturn -EFAULT;\r\nif (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {\r\nsscanf(tmp, "%d ", &mode);\r\nif (pregpriv && mode < 2) {\r\npregpriv->bw_mode = mode;\r\nprintk("bw_mode =%d\n", mode);\r\n}\r\n}\r\nreturn count;\r\n}\r\nint proc_get_ampdu_enable(struct seq_file *m, void *v)\r\n{\r\nstruct net_device *dev = m->private;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct registry_priv *pregpriv = &padapter->registrypriv;\r\nif (pregpriv)\r\nDBG_871X_SEL_NL(m, "%d\n", pregpriv->ampdu_enable);\r\nreturn 0;\r\n}\r\nssize_t proc_set_ampdu_enable(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)\r\n{\r\nstruct net_device *dev = data;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct registry_priv *pregpriv = &padapter->registrypriv;\r\nchar tmp[32];\r\nu32 mode;\r\nif (count < 1)\r\nreturn -EFAULT;\r\nif (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {\r\nsscanf(tmp, "%d ", &mode);\r\nif (pregpriv && mode < 3) {\r\npregpriv->ampdu_enable = mode;\r\nprintk("ampdu_enable =%d\n", mode);\r\n}\r\n}\r\nreturn count;\r\n}\r\nint proc_get_rx_ampdu(struct seq_file *m, void *v)\r\n{\r\nstruct net_device *dev = m->private;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct registry_priv *pregpriv = &padapter->registrypriv;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nif (pregpriv)\r\nDBG_871X_SEL_NL(m,\r\n"bAcceptAddbaReq = %d , 0:Reject AP's Add BA req, 1:Accept AP's Add BA req.\n", pmlmeinfo->bAcceptAddbaReq\r\n);\r\nreturn 0;\r\n}\r\nssize_t proc_set_rx_ampdu(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)\r\n{\r\nstruct net_device *dev = data;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct registry_priv *pregpriv = &padapter->registrypriv;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nchar tmp[32];\r\nu32 mode;\r\nif (count < 1)\r\nreturn -EFAULT;\r\nif (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {\r\nsscanf(tmp, "%d ", &mode);\r\nif (pregpriv && mode < 2) {\r\npmlmeinfo->bAcceptAddbaReq = mode;\r\nDBG_871X("pmlmeinfo->bAcceptAddbaReq =%d\n", pmlmeinfo->bAcceptAddbaReq);\r\nif (mode == 0) {\r\nsend_delba(padapter, 0, get_my_bssid(&(pmlmeinfo->network)));\r\n}\r\n}\r\n}\r\nreturn count;\r\n}\r\nint proc_get_en_fwps(struct seq_file *m, void *v)\r\n{\r\nstruct net_device *dev = m->private;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct registry_priv *pregpriv = &padapter->registrypriv;\r\nif (pregpriv)\r\nDBG_871X_SEL_NL(m, "check_fw_ps = %d , 1:enable get FW PS state , 0: disable get FW PS state\n"\r\n, pregpriv->check_fw_ps);\r\nreturn 0;\r\n}\r\nssize_t proc_set_en_fwps(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)\r\n{\r\nstruct net_device *dev = data;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct registry_priv *pregpriv = &padapter->registrypriv;\r\nchar tmp[32];\r\nu32 mode;\r\nif (count < 1)\r\nreturn -EFAULT;\r\nif (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {\r\nsscanf(tmp, "%d ", &mode);\r\nif (pregpriv && mode < 2) {\r\npregpriv->check_fw_ps = mode;\r\nDBG_871X("pregpriv->check_fw_ps =%d\n", pregpriv->check_fw_ps);\r\n}\r\n}\r\nreturn count;\r\n}\r\nint proc_get_rx_stbc(struct seq_file *m, void *v)\r\n{\r\nstruct net_device *dev = m->private;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct registry_priv *pregpriv = &padapter->registrypriv;\r\nif (pregpriv)\r\nDBG_871X_SEL_NL(m, "%d\n", pregpriv->rx_stbc);\r\nreturn 0;\r\n}\r\nssize_t proc_set_rx_stbc(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)\r\n{\r\nstruct net_device *dev = data;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct registry_priv *pregpriv = &padapter->registrypriv;\r\nchar tmp[32];\r\nu32 mode;\r\nif (count < 1)\r\nreturn -EFAULT;\r\nif (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {\r\nsscanf(tmp, "%d ", &mode);\r\nif (pregpriv && (mode == 0 || mode == 1 ||\r\nmode == 2 || mode == 3)) {\r\npregpriv->rx_stbc = mode;\r\nprintk("rx_stbc =%d\n", mode);\r\n}\r\n}\r\nreturn count;\r\n}\r\nint proc_get_rssi_disp(struct seq_file *m, void *v)\r\n{\r\nreturn 0;\r\n}\r\nssize_t proc_set_rssi_disp(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)\r\n{\r\nstruct net_device *dev = data;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nchar tmp[32];\r\nu32 enable = 0;\r\nif (count < 1) {\r\nDBG_8192C("argument size is less than 1\n");\r\nreturn -EFAULT;\r\n}\r\nif (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {\r\nint num = sscanf(tmp, "%x", &enable);\r\nif (num != 1) {\r\nDBG_8192C("invalid set_rssi_disp parameter!\n");\r\nreturn count;\r\n}\r\nif (enable) {\r\nDBG_8192C("Linked info Function Enable\n");\r\npadapter->bLinkInfoDump = enable;\r\n} else {\r\nDBG_8192C("Linked info Function Disable\n");\r\npadapter->bLinkInfoDump = 0;\r\n}\r\n}\r\nreturn count;\r\n}\r\nint proc_get_all_sta_info(struct seq_file *m, void *v)\r\n{\r\nstruct net_device *dev = m->private;\r\nstruct sta_info *psta;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nint i, j;\r\nstruct list_head *plist, *phead;\r\nstruct recv_reorder_ctrl *preorder_ctrl;\r\nDBG_871X_SEL_NL(m, "sta_dz_bitmap = 0x%x, tim_bitmap = 0x%x\n", pstapriv->sta_dz_bitmap, pstapriv->tim_bitmap);\r\nspin_lock_bh(&pstapriv->sta_hash_lock);\r\nfor (i = 0; i < NUM_STA; i++) {\r\nphead = &(pstapriv->sta_hash[i]);\r\nplist = get_next(phead);\r\nwhile (phead != plist) {\r\npsta = LIST_CONTAINOR(plist, struct sta_info, hash_list);\r\nplist = get_next(plist);\r\nDBG_871X_SEL_NL(m, "==============================\n");\r\nDBG_871X_SEL_NL(m, "sta's macaddr:" MAC_FMT "\n",\r\nMAC_ARG(psta->hwaddr));\r\nDBG_871X_SEL_NL(m, "rtsen =%d, cts2slef =%d\n",\r\npsta->rtsen, psta->cts2self);\r\nDBG_871X_SEL_NL(m, "state = 0x%x, aid =%d, macid =%d, raid =%d\n",\r\npsta->state, psta->aid, psta->mac_id,\r\npsta->raid);\r\nDBG_871X_SEL_NL(m, "qos_en =%d, ht_en =%d, init_rate =%d\n",\r\npsta->qos_option,\r\npsta->htpriv.ht_option,\r\npsta->init_rate);\r\nDBG_871X_SEL_NL(m, "bwmode =%d, ch_offset =%d, sgi_20m =%d, sgi_40m =%d\n",\r\npsta->bw_mode, psta->htpriv.ch_offset,\r\npsta->htpriv.sgi_20m,\r\npsta->htpriv.sgi_40m);\r\nDBG_871X_SEL_NL(m, "ampdu_enable = %d\n",\r\npsta->htpriv.ampdu_enable);\r\nDBG_871X_SEL_NL(m, "agg_enable_bitmap =%x, candidate_tid_bitmap =%x\n",\r\npsta->htpriv.agg_enable_bitmap,\r\npsta->htpriv.candidate_tid_bitmap);\r\nDBG_871X_SEL_NL(m, "sleepq_len =%d\n",\r\npsta->sleepq_len);\r\nDBG_871X_SEL_NL(m, "sta_xmitpriv.vo_q_qcnt =%d\n",\r\npsta->sta_xmitpriv.vo_q.qcnt);\r\nDBG_871X_SEL_NL(m, "sta_xmitpriv.vi_q_qcnt =%d\n",\r\npsta->sta_xmitpriv.vi_q.qcnt);\r\nDBG_871X_SEL_NL(m, "sta_xmitpriv.be_q_qcnt =%d\n",\r\npsta->sta_xmitpriv.be_q.qcnt);\r\nDBG_871X_SEL_NL(m, "sta_xmitpriv.bk_q_qcnt =%d\n",\r\npsta->sta_xmitpriv.bk_q.qcnt);\r\nDBG_871X_SEL_NL(m, "capability = 0x%x\n",\r\npsta->capability);\r\nDBG_871X_SEL_NL(m, "flags = 0x%x\n", psta->flags);\r\nDBG_871X_SEL_NL(m, "wpa_psk = 0x%x\n", psta->wpa_psk);\r\nDBG_871X_SEL_NL(m, "wpa2_group_cipher = 0x%x\n",\r\npsta->wpa2_group_cipher);\r\nDBG_871X_SEL_NL(m, "wpa2_pairwise_cipher = 0x%x\n",\r\npsta->wpa2_pairwise_cipher);\r\nDBG_871X_SEL_NL(m, "qos_info = 0x%x\n", psta->qos_info);\r\nDBG_871X_SEL_NL(m, "dot118021XPrivacy = 0x%x\n",\r\npsta->dot118021XPrivacy);\r\nfor (j = 0; j < 16; j++) {\r\npreorder_ctrl = &psta->recvreorder_ctrl[j];\r\nif (preorder_ctrl->enable)\r\nDBG_871X_SEL_NL(m, "tid =%d, indicate_seq =%d\n",\r\nj, preorder_ctrl->indicate_seq);\r\n}\r\nDBG_871X_SEL_NL(m, "==============================\n");\r\n}\r\n}\r\nspin_unlock_bh(&pstapriv->sta_hash_lock);\r\nreturn 0;\r\n}\r\nint proc_get_btcoex_dbg(struct seq_file *m, void *v)\r\n{\r\nstruct net_device *dev = m->private;\r\nstruct adapter *padapter;\r\nchar buf[512] = {0};\r\npadapter = (struct adapter *)rtw_netdev_priv(dev);\r\nrtw_btcoex_GetDBG(padapter, buf, 512);\r\nDBG_871X_SEL(m, "%s", buf);\r\nreturn 0;\r\n}\r\nssize_t proc_set_btcoex_dbg(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)\r\n{\r\nstruct net_device *dev = data;\r\nstruct adapter *padapter;\r\nu8 tmp[80] = {0};\r\nu32 module[2] = {0};\r\nu32 num;\r\npadapter = (struct adapter *)rtw_netdev_priv(dev);\r\nif (NULL == buffer) {\r\nDBG_871X(FUNC_ADPT_FMT ": input buffer is NULL!\n",\r\nFUNC_ADPT_ARG(padapter));\r\nreturn -EFAULT;\r\n}\r\nif (count < 1) {\r\nDBG_871X(FUNC_ADPT_FMT ": input length is 0!\n",\r\nFUNC_ADPT_ARG(padapter));\r\nreturn -EFAULT;\r\n}\r\nnum = count;\r\nif (num > (sizeof(tmp) - 1))\r\nnum = (sizeof(tmp) - 1);\r\nif (copy_from_user(tmp, buffer, num)) {\r\nDBG_871X(FUNC_ADPT_FMT ": copy buffer from user space FAIL!\n",\r\nFUNC_ADPT_ARG(padapter));\r\nreturn -EFAULT;\r\n}\r\nnum = sscanf(tmp, "%x %x", module, module+1);\r\nif (1 == num) {\r\nif (0 == module[0])\r\nmemset(module, 0, sizeof(module));\r\nelse\r\nmemset(module, 0xFF, sizeof(module));\r\n} else if (2 != num) {\r\nDBG_871X(FUNC_ADPT_FMT ": input(\"%s\") format incorrect!\n",\r\nFUNC_ADPT_ARG(padapter), tmp);\r\nif (0 == num)\r\nreturn -EFAULT;\r\n}\r\nDBG_871X(FUNC_ADPT_FMT ": input 0x%08X 0x%08X\n",\r\nFUNC_ADPT_ARG(padapter), module[0], module[1]);\r\nrtw_btcoex_SetDBG(padapter, module);\r\nreturn count;\r\n}\r\nint proc_get_btcoex_info(struct seq_file *m, void *v)\r\n{\r\nstruct net_device *dev = m->private;\r\nstruct adapter *padapter;\r\nconst u32 bufsize = 30*100;\r\nu8 *pbuf = NULL;\r\npadapter = (struct adapter *)rtw_netdev_priv(dev);\r\npbuf = rtw_zmalloc(bufsize);\r\nif (NULL == pbuf) {\r\nreturn -ENOMEM;\r\n}\r\nrtw_btcoex_DisplayBtCoexInfo(padapter, pbuf, bufsize);\r\nDBG_871X_SEL(m, "%s\n", pbuf);\r\nkfree(pbuf);\r\nreturn 0;\r\n}
