static inline struct bq24735 *to_bq24735(struct power_supply *psy)\r\n{\r\nreturn power_supply_get_drvdata(psy);\r\n}\r\nstatic int bq24735_charger_property_is_writeable(struct power_supply *psy,\r\nenum power_supply_property psp)\r\n{\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_STATUS:\r\nreturn 1;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int bq24735_write_word(struct i2c_client *client, u8 reg,\r\nu16 value)\r\n{\r\nreturn i2c_smbus_write_word_data(client, reg, value);\r\n}\r\nstatic inline int bq24735_read_word(struct i2c_client *client, u8 reg)\r\n{\r\nreturn i2c_smbus_read_word_data(client, reg);\r\n}\r\nstatic int bq24735_update_word(struct i2c_client *client, u8 reg,\r\nu16 mask, u16 value)\r\n{\r\nunsigned int tmp;\r\nint ret;\r\nret = bq24735_read_word(client, reg);\r\nif (ret < 0)\r\nreturn ret;\r\ntmp = ret & ~mask;\r\ntmp |= value & mask;\r\nreturn bq24735_write_word(client, reg, tmp);\r\n}\r\nstatic int bq24735_config_charger(struct bq24735 *charger)\r\n{\r\nstruct bq24735_platform *pdata = charger->pdata;\r\nint ret;\r\nu16 value;\r\nif (pdata->ext_control)\r\nreturn 0;\r\nif (pdata->charge_current) {\r\nvalue = pdata->charge_current & BQ24735_CHARGE_CURRENT_MASK;\r\nret = bq24735_write_word(charger->client,\r\nBQ24735_CHARGE_CURRENT, value);\r\nif (ret < 0) {\r\ndev_err(&charger->client->dev,\r\n"Failed to write charger current : %d\n",\r\nret);\r\nreturn ret;\r\n}\r\n}\r\nif (pdata->charge_voltage) {\r\nvalue = pdata->charge_voltage & BQ24735_CHARGE_VOLTAGE_MASK;\r\nret = bq24735_write_word(charger->client,\r\nBQ24735_CHARGE_VOLTAGE, value);\r\nif (ret < 0) {\r\ndev_err(&charger->client->dev,\r\n"Failed to write charger voltage : %d\n",\r\nret);\r\nreturn ret;\r\n}\r\n}\r\nif (pdata->input_current) {\r\nvalue = pdata->input_current & BQ24735_INPUT_CURRENT_MASK;\r\nret = bq24735_write_word(charger->client,\r\nBQ24735_INPUT_CURRENT, value);\r\nif (ret < 0) {\r\ndev_err(&charger->client->dev,\r\n"Failed to write input current : %d\n",\r\nret);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int bq24735_enable_charging(struct bq24735 *charger)\r\n{\r\nint ret;\r\nif (charger->pdata->ext_control)\r\nreturn 0;\r\nret = bq24735_config_charger(charger);\r\nif (ret)\r\nreturn ret;\r\nreturn bq24735_update_word(charger->client, BQ24735_CHG_OPT,\r\nBQ24735_CHG_OPT_CHARGE_DISABLE, 0);\r\n}\r\nstatic inline int bq24735_disable_charging(struct bq24735 *charger)\r\n{\r\nif (charger->pdata->ext_control)\r\nreturn 0;\r\nreturn bq24735_update_word(charger->client, BQ24735_CHG_OPT,\r\nBQ24735_CHG_OPT_CHARGE_DISABLE,\r\nBQ24735_CHG_OPT_CHARGE_DISABLE);\r\n}\r\nstatic bool bq24735_charger_is_present(struct bq24735 *charger)\r\n{\r\nif (charger->status_gpio) {\r\nreturn !gpiod_get_value_cansleep(charger->status_gpio);\r\n} else {\r\nint ac = 0;\r\nac = bq24735_read_word(charger->client, BQ24735_CHG_OPT);\r\nif (ac < 0) {\r\ndev_dbg(&charger->client->dev,\r\n"Failed to read charger options : %d\n",\r\nac);\r\nreturn false;\r\n}\r\nreturn (ac & BQ24735_CHG_OPT_AC_PRESENT) ? true : false;\r\n}\r\nreturn false;\r\n}\r\nstatic int bq24735_charger_is_charging(struct bq24735 *charger)\r\n{\r\nint ret;\r\nif (!bq24735_charger_is_present(charger))\r\nreturn 0;\r\nret = bq24735_read_word(charger->client, BQ24735_CHG_OPT);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn !(ret & BQ24735_CHG_OPT_CHARGE_DISABLE);\r\n}\r\nstatic void bq24735_update(struct bq24735 *charger)\r\n{\r\nmutex_lock(&charger->lock);\r\nif (charger->charging && bq24735_charger_is_present(charger))\r\nbq24735_enable_charging(charger);\r\nelse\r\nbq24735_disable_charging(charger);\r\nmutex_unlock(&charger->lock);\r\npower_supply_changed(charger->charger);\r\n}\r\nstatic irqreturn_t bq24735_charger_isr(int irq, void *devid)\r\n{\r\nstruct power_supply *psy = devid;\r\nstruct bq24735 *charger = to_bq24735(psy);\r\nbq24735_update(charger);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void bq24735_poll(struct work_struct *work)\r\n{\r\nstruct bq24735 *charger = container_of(work, struct bq24735, poll.work);\r\nbq24735_update(charger);\r\nschedule_delayed_work(&charger->poll,\r\nmsecs_to_jiffies(charger->poll_interval));\r\n}\r\nstatic int bq24735_charger_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct bq24735 *charger = to_bq24735(psy);\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_ONLINE:\r\nval->intval = bq24735_charger_is_present(charger) ? 1 : 0;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_STATUS:\r\nswitch (bq24735_charger_is_charging(charger)) {\r\ncase 1:\r\nval->intval = POWER_SUPPLY_STATUS_CHARGING;\r\nbreak;\r\ncase 0:\r\nval->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;\r\nbreak;\r\ndefault:\r\nval->intval = POWER_SUPPLY_STATUS_UNKNOWN;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bq24735_charger_set_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nconst union power_supply_propval *val)\r\n{\r\nstruct bq24735 *charger = to_bq24735(psy);\r\nint ret;\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_STATUS:\r\nswitch (val->intval) {\r\ncase POWER_SUPPLY_STATUS_CHARGING:\r\nmutex_lock(&charger->lock);\r\ncharger->charging = true;\r\nret = bq24735_enable_charging(charger);\r\nmutex_unlock(&charger->lock);\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ncase POWER_SUPPLY_STATUS_DISCHARGING:\r\ncase POWER_SUPPLY_STATUS_NOT_CHARGING:\r\nmutex_lock(&charger->lock);\r\ncharger->charging = false;\r\nret = bq24735_disable_charging(charger);\r\nmutex_unlock(&charger->lock);\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\npower_supply_changed(psy);\r\nbreak;\r\ndefault:\r\nreturn -EPERM;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct bq24735_platform *bq24735_parse_dt_data(struct i2c_client *client)\r\n{\r\nstruct bq24735_platform *pdata;\r\nstruct device_node *np = client->dev.of_node;\r\nu32 val;\r\nint ret;\r\npdata = devm_kzalloc(&client->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata) {\r\ndev_err(&client->dev,\r\n"Memory alloc for bq24735 pdata failed\n");\r\nreturn NULL;\r\n}\r\nret = of_property_read_u32(np, "ti,charge-current", &val);\r\nif (!ret)\r\npdata->charge_current = val;\r\nret = of_property_read_u32(np, "ti,charge-voltage", &val);\r\nif (!ret)\r\npdata->charge_voltage = val;\r\nret = of_property_read_u32(np, "ti,input-current", &val);\r\nif (!ret)\r\npdata->input_current = val;\r\npdata->ext_control = of_property_read_bool(np, "ti,external-control");\r\nreturn pdata;\r\n}\r\nstatic int bq24735_charger_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint ret;\r\nstruct bq24735 *charger;\r\nstruct power_supply_desc *supply_desc;\r\nstruct power_supply_config psy_cfg = {};\r\nchar *name;\r\ncharger = devm_kzalloc(&client->dev, sizeof(*charger), GFP_KERNEL);\r\nif (!charger)\r\nreturn -ENOMEM;\r\nmutex_init(&charger->lock);\r\ncharger->charging = true;\r\ncharger->pdata = client->dev.platform_data;\r\nif (IS_ENABLED(CONFIG_OF) && !charger->pdata && client->dev.of_node)\r\ncharger->pdata = bq24735_parse_dt_data(client);\r\nif (!charger->pdata) {\r\ndev_err(&client->dev, "no platform data provided\n");\r\nreturn -EINVAL;\r\n}\r\nname = (char *)charger->pdata->name;\r\nif (!name) {\r\nname = devm_kasprintf(&client->dev, GFP_KERNEL,\r\n"bq24735@%s",\r\ndev_name(&client->dev));\r\nif (!name) {\r\ndev_err(&client->dev, "Failed to alloc device name\n");\r\nreturn -ENOMEM;\r\n}\r\n}\r\ncharger->client = client;\r\nsupply_desc = &charger->charger_desc;\r\nsupply_desc->name = name;\r\nsupply_desc->type = POWER_SUPPLY_TYPE_MAINS;\r\nsupply_desc->properties = bq24735_charger_properties;\r\nsupply_desc->num_properties = ARRAY_SIZE(bq24735_charger_properties);\r\nsupply_desc->get_property = bq24735_charger_get_property;\r\nsupply_desc->set_property = bq24735_charger_set_property;\r\nsupply_desc->property_is_writeable =\r\nbq24735_charger_property_is_writeable;\r\npsy_cfg.supplied_to = charger->pdata->supplied_to;\r\npsy_cfg.num_supplicants = charger->pdata->num_supplicants;\r\npsy_cfg.of_node = client->dev.of_node;\r\npsy_cfg.drv_data = charger;\r\ni2c_set_clientdata(client, charger);\r\ncharger->status_gpio = devm_gpiod_get_optional(&client->dev,\r\n"ti,ac-detect",\r\nGPIOD_IN);\r\nif (IS_ERR(charger->status_gpio)) {\r\nret = PTR_ERR(charger->status_gpio);\r\ndev_err(&client->dev, "Getting gpio failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (bq24735_charger_is_present(charger)) {\r\nret = bq24735_read_word(client, BQ24735_MANUFACTURER_ID);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Failed to read manufacturer id : %d\n",\r\nret);\r\nreturn ret;\r\n} else if (ret != 0x0040) {\r\ndev_err(&client->dev,\r\n"manufacturer id mismatch. 0x0040 != 0x%04x\n", ret);\r\nreturn -ENODEV;\r\n}\r\nret = bq24735_read_word(client, BQ24735_DEVICE_ID);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Failed to read device id : %d\n", ret);\r\nreturn ret;\r\n} else if (ret != 0x000B) {\r\ndev_err(&client->dev,\r\n"device id mismatch. 0x000b != 0x%04x\n", ret);\r\nreturn -ENODEV;\r\n}\r\nret = bq24735_enable_charging(charger);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Failed to enable charging\n");\r\nreturn ret;\r\n}\r\n}\r\ncharger->charger = devm_power_supply_register(&client->dev, supply_desc,\r\n&psy_cfg);\r\nif (IS_ERR(charger->charger)) {\r\nret = PTR_ERR(charger->charger);\r\ndev_err(&client->dev, "Failed to register power supply: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nif (client->irq) {\r\nret = devm_request_threaded_irq(&client->dev, client->irq,\r\nNULL, bq24735_charger_isr,\r\nIRQF_TRIGGER_RISING |\r\nIRQF_TRIGGER_FALLING |\r\nIRQF_ONESHOT,\r\nsupply_desc->name,\r\ncharger->charger);\r\nif (ret) {\r\ndev_err(&client->dev,\r\n"Unable to register IRQ %d err %d\n",\r\nclient->irq, ret);\r\nreturn ret;\r\n}\r\n} else {\r\nret = device_property_read_u32(&client->dev, "poll-interval",\r\n&charger->poll_interval);\r\nif (ret)\r\nreturn 0;\r\nif (!charger->poll_interval)\r\nreturn 0;\r\nINIT_DELAYED_WORK(&charger->poll, bq24735_poll);\r\nschedule_delayed_work(&charger->poll,\r\nmsecs_to_jiffies(charger->poll_interval));\r\n}\r\nreturn 0;\r\n}\r\nstatic int bq24735_charger_remove(struct i2c_client *client)\r\n{\r\nstruct bq24735 *charger = i2c_get_clientdata(client);\r\nif (charger->poll_interval)\r\ncancel_delayed_work_sync(&charger->poll);\r\nreturn 0;\r\n}
