static asmlinkage void __exception_irq_entry\r\naic5_handle(struct pt_regs *regs)\r\n{\r\nstruct irq_chip_generic *bgc = irq_get_domain_generic_chip(aic5_domain, 0);\r\nu32 irqnr;\r\nu32 irqstat;\r\nirqnr = irq_reg_readl(bgc, AT91_AIC5_IVR);\r\nirqstat = irq_reg_readl(bgc, AT91_AIC5_ISR);\r\nif (!irqstat)\r\nirq_reg_writel(bgc, 0, AT91_AIC5_EOICR);\r\nelse\r\nhandle_domain_irq(aic5_domain, irqnr, regs);\r\n}\r\nstatic void aic5_mask(struct irq_data *d)\r\n{\r\nstruct irq_domain *domain = d->domain;\r\nstruct irq_chip_generic *bgc = irq_get_domain_generic_chip(domain, 0);\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nirq_gc_lock(bgc);\r\nirq_reg_writel(gc, d->hwirq, AT91_AIC5_SSR);\r\nirq_reg_writel(gc, 1, AT91_AIC5_IDCR);\r\ngc->mask_cache &= ~d->mask;\r\nirq_gc_unlock(bgc);\r\n}\r\nstatic void aic5_unmask(struct irq_data *d)\r\n{\r\nstruct irq_domain *domain = d->domain;\r\nstruct irq_chip_generic *bgc = irq_get_domain_generic_chip(domain, 0);\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nirq_gc_lock(bgc);\r\nirq_reg_writel(gc, d->hwirq, AT91_AIC5_SSR);\r\nirq_reg_writel(gc, 1, AT91_AIC5_IECR);\r\ngc->mask_cache |= d->mask;\r\nirq_gc_unlock(bgc);\r\n}\r\nstatic int aic5_retrigger(struct irq_data *d)\r\n{\r\nstruct irq_domain *domain = d->domain;\r\nstruct irq_chip_generic *bgc = irq_get_domain_generic_chip(domain, 0);\r\nirq_gc_lock(bgc);\r\nirq_reg_writel(bgc, d->hwirq, AT91_AIC5_SSR);\r\nirq_reg_writel(bgc, 1, AT91_AIC5_ISCR);\r\nirq_gc_unlock(bgc);\r\nreturn 0;\r\n}\r\nstatic int aic5_set_type(struct irq_data *d, unsigned type)\r\n{\r\nstruct irq_domain *domain = d->domain;\r\nstruct irq_chip_generic *bgc = irq_get_domain_generic_chip(domain, 0);\r\nunsigned int smr;\r\nint ret;\r\nirq_gc_lock(bgc);\r\nirq_reg_writel(bgc, d->hwirq, AT91_AIC5_SSR);\r\nsmr = irq_reg_readl(bgc, AT91_AIC5_SMR);\r\nret = aic_common_set_type(d, type, &smr);\r\nif (!ret)\r\nirq_reg_writel(bgc, smr, AT91_AIC5_SMR);\r\nirq_gc_unlock(bgc);\r\nreturn ret;\r\n}\r\nstatic void aic5_suspend(struct irq_data *d)\r\n{\r\nstruct irq_domain *domain = d->domain;\r\nstruct irq_domain_chip_generic *dgc = domain->gc;\r\nstruct irq_chip_generic *bgc = irq_get_domain_generic_chip(domain, 0);\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nint i;\r\nu32 mask;\r\nif (smr_cache)\r\nfor (i = 0; i < domain->revmap_size; i++) {\r\nirq_reg_writel(bgc, i, AT91_AIC5_SSR);\r\nsmr_cache[i] = irq_reg_readl(bgc, AT91_AIC5_SMR);\r\n}\r\nirq_gc_lock(bgc);\r\nfor (i = 0; i < dgc->irqs_per_chip; i++) {\r\nmask = 1 << i;\r\nif ((mask & gc->mask_cache) == (mask & gc->wake_active))\r\ncontinue;\r\nirq_reg_writel(bgc, i + gc->irq_base, AT91_AIC5_SSR);\r\nif (mask & gc->wake_active)\r\nirq_reg_writel(bgc, 1, AT91_AIC5_IECR);\r\nelse\r\nirq_reg_writel(bgc, 1, AT91_AIC5_IDCR);\r\n}\r\nirq_gc_unlock(bgc);\r\n}\r\nstatic void aic5_resume(struct irq_data *d)\r\n{\r\nstruct irq_domain *domain = d->domain;\r\nstruct irq_domain_chip_generic *dgc = domain->gc;\r\nstruct irq_chip_generic *bgc = irq_get_domain_generic_chip(domain, 0);\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nint i;\r\nu32 mask;\r\nirq_gc_lock(bgc);\r\nif (smr_cache) {\r\nirq_reg_writel(bgc, 0xffffffff, AT91_AIC5_SPU);\r\nfor (i = 0; i < domain->revmap_size; i++) {\r\nirq_reg_writel(bgc, i, AT91_AIC5_SSR);\r\nirq_reg_writel(bgc, i, AT91_AIC5_SVR);\r\nirq_reg_writel(bgc, smr_cache[i], AT91_AIC5_SMR);\r\n}\r\n}\r\nfor (i = 0; i < dgc->irqs_per_chip; i++) {\r\nmask = 1 << i;\r\nif (!smr_cache &&\r\n((mask & gc->mask_cache) == (mask & gc->wake_active)))\r\ncontinue;\r\nirq_reg_writel(bgc, i + gc->irq_base, AT91_AIC5_SSR);\r\nif (mask & gc->mask_cache)\r\nirq_reg_writel(bgc, 1, AT91_AIC5_IECR);\r\nelse\r\nirq_reg_writel(bgc, 1, AT91_AIC5_IDCR);\r\n}\r\nirq_gc_unlock(bgc);\r\n}\r\nstatic void aic5_pm_shutdown(struct irq_data *d)\r\n{\r\nstruct irq_domain *domain = d->domain;\r\nstruct irq_domain_chip_generic *dgc = domain->gc;\r\nstruct irq_chip_generic *bgc = irq_get_domain_generic_chip(domain, 0);\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nint i;\r\nirq_gc_lock(bgc);\r\nfor (i = 0; i < dgc->irqs_per_chip; i++) {\r\nirq_reg_writel(bgc, i + gc->irq_base, AT91_AIC5_SSR);\r\nirq_reg_writel(bgc, 1, AT91_AIC5_IDCR);\r\nirq_reg_writel(bgc, 1, AT91_AIC5_ICCR);\r\n}\r\nirq_gc_unlock(bgc);\r\n}\r\nstatic void __init aic5_hw_init(struct irq_domain *domain)\r\n{\r\nstruct irq_chip_generic *gc = irq_get_domain_generic_chip(domain, 0);\r\nint i;\r\nfor (i = 0; i < 8; i++)\r\nirq_reg_writel(gc, 0, AT91_AIC5_EOICR);\r\nirq_reg_writel(gc, 0xffffffff, AT91_AIC5_SPU);\r\nirq_reg_writel(gc, 0, AT91_AIC5_DCR);\r\nfor (i = 0; i < domain->revmap_size; i++) {\r\nirq_reg_writel(gc, i, AT91_AIC5_SSR);\r\nirq_reg_writel(gc, i, AT91_AIC5_SVR);\r\nirq_reg_writel(gc, 1, AT91_AIC5_IDCR);\r\nirq_reg_writel(gc, 1, AT91_AIC5_ICCR);\r\n}\r\n}\r\nstatic int aic5_irq_domain_xlate(struct irq_domain *d,\r\nstruct device_node *ctrlr,\r\nconst u32 *intspec, unsigned int intsize,\r\nirq_hw_number_t *out_hwirq,\r\nunsigned int *out_type)\r\n{\r\nstruct irq_chip_generic *bgc = irq_get_domain_generic_chip(d, 0);\r\nunsigned long flags;\r\nunsigned smr;\r\nint ret;\r\nif (!bgc)\r\nreturn -EINVAL;\r\nret = aic_common_irq_domain_xlate(d, ctrlr, intspec, intsize,\r\nout_hwirq, out_type);\r\nif (ret)\r\nreturn ret;\r\nirq_gc_lock_irqsave(bgc, flags);\r\nirq_reg_writel(bgc, *out_hwirq, AT91_AIC5_SSR);\r\nsmr = irq_reg_readl(bgc, AT91_AIC5_SMR);\r\naic_common_set_priority(intspec[2], &smr);\r\nirq_reg_writel(bgc, smr, AT91_AIC5_SMR);\r\nirq_gc_unlock_irqrestore(bgc, flags);\r\nreturn ret;\r\n}\r\nstatic void __init sama5d3_aic_irq_fixup(void)\r\n{\r\naic_common_rtc_irq_fixup();\r\n}\r\nstatic int __init aic5_of_init(struct device_node *node,\r\nstruct device_node *parent,\r\nint nirqs)\r\n{\r\nstruct irq_chip_generic *gc;\r\nstruct irq_domain *domain;\r\nint nchips;\r\nint i;\r\nif (nirqs > NR_AIC5_IRQS)\r\nreturn -EINVAL;\r\nif (aic5_domain)\r\nreturn -EEXIST;\r\ndomain = aic_common_of_init(node, &aic5_irq_ops, "atmel-aic5",\r\nnirqs, aic5_irq_fixups);\r\nif (IS_ERR(domain))\r\nreturn PTR_ERR(domain);\r\naic5_domain = domain;\r\nnchips = aic5_domain->revmap_size / 32;\r\nfor (i = 0; i < nchips; i++) {\r\ngc = irq_get_domain_generic_chip(domain, i * 32);\r\ngc->chip_types[0].regs.eoi = AT91_AIC5_EOICR;\r\ngc->chip_types[0].chip.irq_mask = aic5_mask;\r\ngc->chip_types[0].chip.irq_unmask = aic5_unmask;\r\ngc->chip_types[0].chip.irq_retrigger = aic5_retrigger;\r\ngc->chip_types[0].chip.irq_set_type = aic5_set_type;\r\ngc->chip_types[0].chip.irq_suspend = aic5_suspend;\r\ngc->chip_types[0].chip.irq_resume = aic5_resume;\r\ngc->chip_types[0].chip.irq_pm_shutdown = aic5_pm_shutdown;\r\n}\r\naic5_hw_init(domain);\r\nset_handle_irq(aic5_handle);\r\nreturn 0;\r\n}\r\nstatic int __init sama5d2_aic5_of_init(struct device_node *node,\r\nstruct device_node *parent)\r\n{\r\n#ifdef CONFIG_PM\r\nsmr_cache = kcalloc(DIV_ROUND_UP(NR_SAMA5D2_IRQS, 32) * 32,\r\nsizeof(*smr_cache), GFP_KERNEL);\r\nif (!smr_cache)\r\nreturn -ENOMEM;\r\n#endif\r\nreturn aic5_of_init(node, parent, NR_SAMA5D2_IRQS);\r\n}\r\nstatic int __init sama5d3_aic5_of_init(struct device_node *node,\r\nstruct device_node *parent)\r\n{\r\nreturn aic5_of_init(node, parent, NR_SAMA5D3_IRQS);\r\n}\r\nstatic int __init sama5d4_aic5_of_init(struct device_node *node,\r\nstruct device_node *parent)\r\n{\r\nreturn aic5_of_init(node, parent, NR_SAMA5D4_IRQS);\r\n}
