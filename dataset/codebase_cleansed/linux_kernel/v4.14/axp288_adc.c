static int axp288_adc_read_channel(int *val, unsigned long address,\r\nstruct regmap *regmap)\r\n{\r\nu8 buf[2];\r\nif (regmap_bulk_read(regmap, address, buf, 2))\r\nreturn -EIO;\r\n*val = (buf[0] << 4) + ((buf[1] >> 4) & 0x0F);\r\nreturn IIO_VAL_INT;\r\n}\r\nstatic int axp288_adc_set_ts(struct regmap *regmap, unsigned int mode,\r\nunsigned long address)\r\n{\r\nint ret;\r\nif (address != AXP288_GP_ADC_H)\r\nreturn 0;\r\nret = regmap_write(regmap, AXP288_ADC_TS_PIN_CTRL, mode);\r\nif (ret)\r\nreturn ret;\r\nif (mode == AXP288_ADC_TS_PIN_GPADC)\r\nusleep_range(6000, 10000);\r\nreturn 0;\r\n}\r\nstatic int axp288_adc_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2, long mask)\r\n{\r\nint ret;\r\nstruct axp288_adc_info *info = iio_priv(indio_dev);\r\nmutex_lock(&indio_dev->mlock);\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nif (axp288_adc_set_ts(info->regmap, AXP288_ADC_TS_PIN_GPADC,\r\nchan->address)) {\r\ndev_err(&indio_dev->dev, "GPADC mode\n");\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nret = axp288_adc_read_channel(val, chan->address, info->regmap);\r\nif (axp288_adc_set_ts(info->regmap, AXP288_ADC_TS_PIN_ON,\r\nchan->address))\r\ndev_err(&indio_dev->dev, "TS pin restore\n");\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\nstatic int axp288_adc_set_state(struct regmap *regmap)\r\n{\r\nif (regmap_write(regmap, AXP288_ADC_TS_PIN_CTRL, AXP288_ADC_TS_PIN_ON))\r\nreturn -EIO;\r\nreturn regmap_write(regmap, AXP20X_ADC_EN1, AXP288_ADC_EN_MASK);\r\n}\r\nstatic int axp288_adc_probe(struct platform_device *pdev)\r\n{\r\nint ret;\r\nstruct axp288_adc_info *info;\r\nstruct iio_dev *indio_dev;\r\nstruct axp20x_dev *axp20x = dev_get_drvdata(pdev->dev.parent);\r\nindio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*info));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\ninfo = iio_priv(indio_dev);\r\ninfo->irq = platform_get_irq(pdev, 0);\r\nif (info->irq < 0) {\r\ndev_err(&pdev->dev, "no irq resource?\n");\r\nreturn info->irq;\r\n}\r\nplatform_set_drvdata(pdev, indio_dev);\r\ninfo->regmap = axp20x->regmap;\r\nret = axp288_adc_set_state(axp20x->regmap);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to enable ADC device\n");\r\nreturn ret;\r\n}\r\nindio_dev->dev.parent = &pdev->dev;\r\nindio_dev->name = pdev->name;\r\nindio_dev->channels = axp288_adc_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(axp288_adc_channels);\r\nindio_dev->info = &axp288_adc_iio_info;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nret = iio_map_array_register(indio_dev, axp288_adc_default_maps);\r\nif (ret < 0)\r\nreturn ret;\r\nret = iio_device_register(indio_dev);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "unable to register iio device\n");\r\ngoto err_array_unregister;\r\n}\r\nreturn 0;\r\nerr_array_unregister:\r\niio_map_array_unregister(indio_dev);\r\nreturn ret;\r\n}\r\nstatic int axp288_adc_remove(struct platform_device *pdev)\r\n{\r\nstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\r\niio_device_unregister(indio_dev);\r\niio_map_array_unregister(indio_dev);\r\nreturn 0;\r\n}
