static void fd_end_request_cur(blk_status_t err)\r\n{\r\nif (!__blk_end_request_cur(fd_request, err))\r\nfd_request = NULL;\r\n}\r\nstatic inline void start_motor_off_timer(void)\r\n{\r\nmod_timer(&motor_off_timer, jiffies + FD_MOTOR_OFF_DELAY);\r\nMotorOffTrys = 0;\r\n}\r\nstatic inline void start_check_change_timer( void )\r\n{\r\nmod_timer(&fd_timer, jiffies + CHECK_CHANGE_DELAY);\r\n}\r\nstatic inline void start_timeout(void)\r\n{\r\nmod_timer(&timeout_timer, jiffies + FLOPPY_TIMEOUT);\r\n}\r\nstatic inline void stop_timeout(void)\r\n{\r\ndel_timer(&timeout_timer);\r\n}\r\nstatic void fd_select_side( int side )\r\n{\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nsound_ym.rd_data_reg_sel = 14;\r\nsound_ym.wd_data = (side == 0) ? sound_ym.rd_data_reg_sel | 0x01 :\r\nsound_ym.rd_data_reg_sel & 0xfe;\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void fd_select_drive( int drive )\r\n{\r\nunsigned long flags;\r\nunsigned char tmp;\r\nif (drive == SelectedDrive)\r\nreturn;\r\nlocal_irq_save(flags);\r\nsound_ym.rd_data_reg_sel = 14;\r\ntmp = sound_ym.rd_data_reg_sel;\r\nsound_ym.wd_data = (tmp | DSKDRVNONE) & ~(drive == 0 ? DSKDRV0 : DSKDRV1);\r\natari_dont_touch_floppy_select = 1;\r\nlocal_irq_restore(flags);\r\nFDC_WRITE( FDCREG_TRACK, UD.track );\r\nudelay(25);\r\nif (UDT)\r\nif (ATARIHW_PRESENT(FDCSPEED))\r\ndma_wd.fdc_speed = UDT->fdc_speed;\r\nSelectedDrive = drive;\r\n}\r\nstatic void fd_deselect( void )\r\n{\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\natari_dont_touch_floppy_select = 0;\r\nsound_ym.rd_data_reg_sel=14;\r\nsound_ym.wd_data = (sound_ym.rd_data_reg_sel |\r\n(MACH_IS_FALCON ? 3 : 7));\r\nSelectedDrive = -1;\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void fd_motor_off_timer( unsigned long dummy )\r\n{\r\nunsigned char status;\r\nif (SelectedDrive < 0)\r\nreturn;\r\nif (stdma_islocked())\r\ngoto retry;\r\nstatus = FDC_READ( FDCREG_STATUS );\r\nif (!(status & 0x80)) {\r\nMotorOn = 0;\r\nfd_deselect();\r\nreturn;\r\n}\r\nretry:\r\nmod_timer(&motor_off_timer,\r\njiffies + (MotorOffTrys++ < FD_MOTOR_OFF_MAXTRY ? HZ/20 : HZ/2));\r\n}\r\nstatic void check_change( unsigned long dummy )\r\n{\r\nstatic int drive = 0;\r\nunsigned long flags;\r\nunsigned char old_porta;\r\nint stat;\r\nif (++drive > 1 || !UD.connected)\r\ndrive = 0;\r\nlocal_irq_save(flags);\r\nif (!stdma_islocked()) {\r\nsound_ym.rd_data_reg_sel = 14;\r\nold_porta = sound_ym.rd_data_reg_sel;\r\nsound_ym.wd_data = (old_porta | DSKDRVNONE) &\r\n~(drive == 0 ? DSKDRV0 : DSKDRV1);\r\nstat = !!(FDC_READ( FDCREG_STATUS ) & FDCSTAT_WPROT);\r\nsound_ym.wd_data = old_porta;\r\nif (stat != UD.wpstat) {\r\nDPRINT(( "wpstat[%d] = %d\n", drive, stat ));\r\nUD.wpstat = stat;\r\nset_bit (drive, &changed_floppies);\r\n}\r\n}\r\nlocal_irq_restore(flags);\r\nstart_check_change_timer();\r\n}\r\nstatic inline void set_head_settle_flag(void)\r\n{\r\nHeadSettleFlag = FDCCMDADD_E;\r\n}\r\nstatic inline int get_head_settle_flag(void)\r\n{\r\nint tmp = HeadSettleFlag;\r\nHeadSettleFlag = 0;\r\nreturn( tmp );\r\n}\r\nstatic inline void copy_buffer(void *from, void *to)\r\n{\r\nulong *p1 = (ulong *)from, *p2 = (ulong *)to;\r\nint cnt;\r\nfor (cnt = 512/4; cnt; cnt--)\r\n*p2++ = *p1++;\r\n}\r\nstatic irqreturn_t floppy_irq (int irq, void *dummy)\r\n{\r\nunsigned char status;\r\nvoid (*handler)( int );\r\nhandler = xchg(&FloppyIRQHandler, NULL);\r\nif (handler) {\r\nnop();\r\nstatus = FDC_READ( FDCREG_STATUS );\r\nDPRINT(("FDC irq, status = %02x handler = %08lx\n",status,(unsigned long)handler));\r\nhandler( status );\r\n}\r\nelse {\r\nDPRINT(("FDC irq, no handler\n"));\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void fd_error( void )\r\n{\r\nif (IsFormatting) {\r\nIsFormatting = 0;\r\nFormatError = 1;\r\ncomplete(&format_wait);\r\nreturn;\r\n}\r\nif (!fd_request)\r\nreturn;\r\nfd_request->error_count++;\r\nif (fd_request->error_count >= MAX_ERRORS) {\r\nprintk(KERN_ERR "fd%d: too many errors.\n", SelectedDrive );\r\nfd_end_request_cur(BLK_STS_IOERR);\r\n}\r\nelse if (fd_request->error_count == RECALIBRATE_ERRORS) {\r\nprintk(KERN_WARNING "fd%d: recalibrating\n", SelectedDrive );\r\nif (SelectedDrive != -1)\r\nSUD.track = -1;\r\n}\r\nredo_fd_request();\r\n}\r\nstatic int do_format(int drive, int type, struct atari_format_descr *desc)\r\n{\r\nunsigned char *p;\r\nint sect, nsect;\r\nunsigned long flags;\r\nDPRINT(("do_format( dr=%d tr=%d he=%d offs=%d )\n",\r\ndrive, desc->track, desc->head, desc->sect_offset ));\r\nwait_event(fdc_wait, cmpxchg(&fdc_busy, 0, 1) == 0);\r\nlocal_irq_save(flags);\r\nstdma_lock(floppy_irq, NULL);\r\natari_turnon_irq( IRQ_MFP_FDC );\r\nlocal_irq_restore(flags);\r\nif (type) {\r\nif (--type >= NUM_DISK_MINORS ||\r\nminor2disktype[type].drive_types > DriveType) {\r\nredo_fd_request();\r\nreturn -EINVAL;\r\n}\r\ntype = minor2disktype[type].index;\r\nUDT = &atari_disk_type[type];\r\n}\r\nif (!UDT || desc->track >= UDT->blocks/UDT->spt/2 || desc->head >= 2) {\r\nredo_fd_request();\r\nreturn -EINVAL;\r\n}\r\nnsect = UDT->spt;\r\np = TrackBuffer;\r\nBufferDrive = -1;\r\ndel_timer( &motor_off_timer );\r\nFILL( 60 * (nsect / 9), 0x4e );\r\nfor( sect = 0; sect < nsect; ++sect ) {\r\nFILL( 12, 0 );\r\nFILL( 3, 0xf5 );\r\n*p++ = 0xfe;\r\n*p++ = desc->track;\r\n*p++ = desc->head;\r\n*p++ = (nsect + sect - desc->sect_offset) % nsect + 1;\r\n*p++ = 2;\r\n*p++ = 0xf7;\r\nFILL( 22, 0x4e );\r\nFILL( 12, 0 );\r\nFILL( 3, 0xf5 );\r\n*p++ = 0xfb;\r\nFILL( 512, 0xe5 );\r\n*p++ = 0xf7;\r\nFILL( 40, 0x4e );\r\n}\r\nFILL( TrackBuffer+BUFFER_SIZE-p, 0x4e );\r\nIsFormatting = 1;\r\nFormatError = 0;\r\nReqTrack = desc->track;\r\nReqSide = desc->head;\r\ndo_fd_action( drive );\r\nwait_for_completion(&format_wait);\r\nredo_fd_request();\r\nreturn( FormatError ? -EIO : 0 );\r\n}\r\nstatic void do_fd_action( int drive )\r\n{\r\nDPRINT(("do_fd_action\n"));\r\nif (UseTrackbuffer && !IsFormatting) {\r\nrepeat:\r\nif (IS_BUFFERED( drive, ReqSide, ReqTrack )) {\r\nif (ReqCmd == READ) {\r\ncopy_buffer( SECTOR_BUFFER(ReqSector), ReqData );\r\nif (++ReqCnt < blk_rq_cur_sectors(fd_request)) {\r\nsetup_req_params( drive );\r\ngoto repeat;\r\n}\r\nelse {\r\nfd_end_request_cur(BLK_STS_OK);\r\nredo_fd_request();\r\nreturn;\r\n}\r\n}\r\nelse {\r\ncopy_buffer( ReqData, SECTOR_BUFFER(ReqSector) );\r\n}\r\n}\r\n}\r\nif (SelectedDrive != drive)\r\nfd_select_drive( drive );\r\nif (UD.track == -1)\r\nfd_calibrate();\r\nelse if (UD.track != ReqTrack << UDT->stretch)\r\nfd_seek();\r\nelse if (IsFormatting)\r\nfd_writetrack();\r\nelse\r\nfd_rwsec();\r\n}\r\nstatic void fd_calibrate( void )\r\n{\r\nif (SUD.track >= 0) {\r\nfd_calibrate_done( 0 );\r\nreturn;\r\n}\r\nif (ATARIHW_PRESENT(FDCSPEED))\r\ndma_wd.fdc_speed = 0; ;\r\nDPRINT(("fd_calibrate\n"));\r\nSET_IRQ_HANDLER( fd_calibrate_done );\r\nFDC_WRITE( FDCREG_CMD, FDCCMD_RESTORE | SUD.steprate );\r\nNeedSeek = 1;\r\nMotorOn = 1;\r\nstart_timeout();\r\n}\r\nstatic void fd_calibrate_done( int status )\r\n{\r\nDPRINT(("fd_calibrate_done()\n"));\r\nstop_timeout();\r\nif (ATARIHW_PRESENT(FDCSPEED))\r\ndma_wd.fdc_speed = SUDT->fdc_speed;\r\nif (status & FDCSTAT_RECNF) {\r\nprintk(KERN_ERR "fd%d: restore failed\n", SelectedDrive );\r\nfd_error();\r\n}\r\nelse {\r\nSUD.track = 0;\r\nfd_seek();\r\n}\r\n}\r\nstatic void fd_seek( void )\r\n{\r\nif (SUD.track == ReqTrack << SUDT->stretch) {\r\nfd_seek_done( 0 );\r\nreturn;\r\n}\r\nif (ATARIHW_PRESENT(FDCSPEED)) {\r\ndma_wd.fdc_speed = 0;\r\nMFPDELAY();\r\n}\r\nDPRINT(("fd_seek() to track %d\n",ReqTrack));\r\nFDC_WRITE( FDCREG_DATA, ReqTrack << SUDT->stretch);\r\nudelay(25);\r\nSET_IRQ_HANDLER( fd_seek_done );\r\nFDC_WRITE( FDCREG_CMD, FDCCMD_SEEK | SUD.steprate );\r\nMotorOn = 1;\r\nset_head_settle_flag();\r\nstart_timeout();\r\n}\r\nstatic void fd_seek_done( int status )\r\n{\r\nDPRINT(("fd_seek_done()\n"));\r\nstop_timeout();\r\nif (ATARIHW_PRESENT(FDCSPEED))\r\ndma_wd.fdc_speed = SUDT->fdc_speed;\r\nif (status & FDCSTAT_RECNF) {\r\nprintk(KERN_ERR "fd%d: seek error (to track %d)\n",\r\nSelectedDrive, ReqTrack );\r\nSUD.track = -1;\r\nfd_error();\r\n}\r\nelse {\r\nSUD.track = ReqTrack << SUDT->stretch;\r\nNeedSeek = 0;\r\nif (IsFormatting)\r\nfd_writetrack();\r\nelse\r\nfd_rwsec();\r\n}\r\n}\r\nstatic void fd_rwsec( void )\r\n{\r\nunsigned long paddr, flags;\r\nunsigned int rwflag, old_motoron;\r\nunsigned int track;\r\nDPRINT(("fd_rwsec(), Sec=%d, Access=%c\n",ReqSector, ReqCmd == WRITE ? 'w' : 'r' ));\r\nif (ReqCmd == WRITE) {\r\nif (ATARIHW_PRESENT(EXTD_DMA)) {\r\npaddr = virt_to_phys(ReqData);\r\n}\r\nelse {\r\ncopy_buffer( ReqData, DMABuffer );\r\npaddr = PhysDMABuffer;\r\n}\r\ndma_cache_maintenance( paddr, 512, 1 );\r\nrwflag = 0x100;\r\n}\r\nelse {\r\nif (read_track)\r\npaddr = PhysTrackBuffer;\r\nelse\r\npaddr = ATARIHW_PRESENT(EXTD_DMA) ?\r\nvirt_to_phys(ReqData) : PhysDMABuffer;\r\nrwflag = 0;\r\n}\r\nfd_select_side( ReqSide );\r\nFDC_WRITE( FDCREG_SECTOR, read_track ? 1 : ReqSector );\r\nMFPDELAY();\r\nif (SUDT->stretch) {\r\ntrack = FDC_READ( FDCREG_TRACK);\r\nMFPDELAY();\r\nFDC_WRITE( FDCREG_TRACK, track >> SUDT->stretch);\r\n}\r\nudelay(25);\r\nlocal_irq_save(flags);\r\ndma_wd.dma_lo = (unsigned char)paddr;\r\nMFPDELAY();\r\npaddr >>= 8;\r\ndma_wd.dma_md = (unsigned char)paddr;\r\nMFPDELAY();\r\npaddr >>= 8;\r\nif (ATARIHW_PRESENT(EXTD_DMA))\r\nst_dma_ext_dmahi = (unsigned short)paddr;\r\nelse\r\ndma_wd.dma_hi = (unsigned char)paddr;\r\nMFPDELAY();\r\nlocal_irq_restore(flags);\r\ndma_wd.dma_mode_status = 0x90 | rwflag;\r\nMFPDELAY();\r\ndma_wd.dma_mode_status = 0x90 | (rwflag ^ 0x100);\r\nMFPDELAY();\r\ndma_wd.dma_mode_status = 0x90 | rwflag;\r\nMFPDELAY();\r\ndma_wd.fdc_acces_seccount = read_track ? SUDT->spt : 1;\r\nudelay(25);\r\ndma_wd.dma_mode_status = FDCSELREG_STP | rwflag;\r\nudelay(25);\r\nSET_IRQ_HANDLER( fd_rwsec_done );\r\ndma_wd.fdc_acces_seccount =\r\n(get_head_settle_flag() |\r\n(rwflag ? FDCCMD_WRSEC : (FDCCMD_RDSEC | (read_track ? FDCCMDADD_M : 0))));\r\nold_motoron = MotorOn;\r\nMotorOn = 1;\r\nNeedSeek = 1;\r\nif (read_track) {\r\nMultReadInProgress = 1;\r\nmod_timer(&readtrack_timer,\r\njiffies + HZ/5 + (old_motoron ? 0 : HZ));\r\n}\r\nstart_timeout();\r\n}\r\nstatic void fd_readtrack_check( unsigned long dummy )\r\n{\r\nunsigned long flags, addr, addr2;\r\nlocal_irq_save(flags);\r\nif (!MultReadInProgress) {\r\nlocal_irq_restore(flags);\r\nreturn;\r\n}\r\naddr = 0;\r\ndo {\r\naddr2 = addr;\r\naddr = dma_wd.dma_lo & 0xff;\r\nMFPDELAY();\r\naddr |= (dma_wd.dma_md & 0xff) << 8;\r\nMFPDELAY();\r\nif (ATARIHW_PRESENT( EXTD_DMA ))\r\naddr |= (st_dma_ext_dmahi & 0xffff) << 16;\r\nelse\r\naddr |= (dma_wd.dma_hi & 0xff) << 16;\r\nMFPDELAY();\r\n} while(addr != addr2);\r\nif (addr >= PhysTrackBuffer + SUDT->spt*512) {\r\nSET_IRQ_HANDLER( NULL );\r\nMultReadInProgress = 0;\r\nlocal_irq_restore(flags);\r\nDPRINT(("fd_readtrack_check(): done\n"));\r\nFDC_WRITE( FDCREG_CMD, FDCCMD_FORCI );\r\nudelay(25);\r\nfd_rwsec_done1(0);\r\n}\r\nelse {\r\nlocal_irq_restore(flags);\r\nDPRINT(("fd_readtrack_check(): not yet finished\n"));\r\nmod_timer(&readtrack_timer, jiffies + HZ/5/10);\r\n}\r\n}\r\nstatic void fd_rwsec_done( int status )\r\n{\r\nDPRINT(("fd_rwsec_done()\n"));\r\nif (read_track) {\r\ndel_timer(&readtrack_timer);\r\nif (!MultReadInProgress)\r\nreturn;\r\nMultReadInProgress = 0;\r\n}\r\nfd_rwsec_done1(status);\r\n}\r\nstatic void fd_rwsec_done1(int status)\r\n{\r\nunsigned int track;\r\nstop_timeout();\r\nif (SUDT->stretch) {\r\ntrack = FDC_READ( FDCREG_TRACK);\r\nMFPDELAY();\r\nFDC_WRITE( FDCREG_TRACK, track << SUDT->stretch);\r\n}\r\nif (!UseTrackbuffer) {\r\ndma_wd.dma_mode_status = 0x90;\r\nMFPDELAY();\r\nif (!(dma_wd.dma_mode_status & 0x01)) {\r\nprintk(KERN_ERR "fd%d: DMA error\n", SelectedDrive );\r\ngoto err_end;\r\n}\r\n}\r\nMFPDELAY();\r\nif (ReqCmd == WRITE && (status & FDCSTAT_WPROT)) {\r\nprintk(KERN_NOTICE "fd%d: is write protected\n", SelectedDrive );\r\ngoto err_end;\r\n}\r\nif ((status & FDCSTAT_RECNF) &&\r\n!(read_track && FDC_READ(FDCREG_SECTOR) > SUDT->spt)) {\r\nif (Probing) {\r\nif (SUDT > atari_disk_type) {\r\nif (SUDT[-1].blocks > ReqBlock) {\r\nSUDT--;\r\nset_capacity(unit[SelectedDrive].disk,\r\nSUDT->blocks);\r\n} else\r\nProbing = 0;\r\n}\r\nelse {\r\nif (SUD.flags & FTD_MSG)\r\nprintk(KERN_INFO "fd%d: Auto-detected floppy type %s\n",\r\nSelectedDrive, SUDT->name );\r\nProbing=0;\r\n}\r\n} else {\r\nif (SUD.autoprobe) {\r\nSUDT = atari_disk_type + StartDiskType[DriveType];\r\nset_capacity(unit[SelectedDrive].disk,\r\nSUDT->blocks);\r\nProbing = 1;\r\n}\r\n}\r\nif (Probing) {\r\nif (ATARIHW_PRESENT(FDCSPEED)) {\r\ndma_wd.fdc_speed = SUDT->fdc_speed;\r\nMFPDELAY();\r\n}\r\nsetup_req_params( SelectedDrive );\r\nBufferDrive = -1;\r\ndo_fd_action( SelectedDrive );\r\nreturn;\r\n}\r\nprintk(KERN_ERR "fd%d: sector %d not found (side %d, track %d)\n",\r\nSelectedDrive, FDC_READ (FDCREG_SECTOR), ReqSide, ReqTrack );\r\ngoto err_end;\r\n}\r\nif (status & FDCSTAT_CRC) {\r\nprintk(KERN_ERR "fd%d: CRC error (side %d, track %d, sector %d)\n",\r\nSelectedDrive, ReqSide, ReqTrack, FDC_READ (FDCREG_SECTOR) );\r\ngoto err_end;\r\n}\r\nif (status & FDCSTAT_LOST) {\r\nprintk(KERN_ERR "fd%d: lost data (side %d, track %d, sector %d)\n",\r\nSelectedDrive, ReqSide, ReqTrack, FDC_READ (FDCREG_SECTOR) );\r\ngoto err_end;\r\n}\r\nProbing = 0;\r\nif (ReqCmd == READ) {\r\nif (!read_track) {\r\nvoid *addr;\r\naddr = ATARIHW_PRESENT( EXTD_DMA ) ? ReqData : DMABuffer;\r\ndma_cache_maintenance( virt_to_phys(addr), 512, 0 );\r\nif (!ATARIHW_PRESENT( EXTD_DMA ))\r\ncopy_buffer (addr, ReqData);\r\n} else {\r\ndma_cache_maintenance( PhysTrackBuffer, MaxSectors[DriveType] * 512, 0 );\r\nBufferDrive = SelectedDrive;\r\nBufferSide = ReqSide;\r\nBufferTrack = ReqTrack;\r\ncopy_buffer (SECTOR_BUFFER (ReqSector), ReqData);\r\n}\r\n}\r\nif (++ReqCnt < blk_rq_cur_sectors(fd_request)) {\r\nsetup_req_params( SelectedDrive );\r\ndo_fd_action( SelectedDrive );\r\n}\r\nelse {\r\nfd_end_request_cur(BLK_STS_OK);\r\nredo_fd_request();\r\n}\r\nreturn;\r\nerr_end:\r\nBufferDrive = -1;\r\nfd_error();\r\n}\r\nstatic void fd_writetrack( void )\r\n{\r\nunsigned long paddr, flags;\r\nunsigned int track;\r\nDPRINT(("fd_writetrack() Tr=%d Si=%d\n", ReqTrack, ReqSide ));\r\npaddr = PhysTrackBuffer;\r\ndma_cache_maintenance( paddr, BUFFER_SIZE, 1 );\r\nfd_select_side( ReqSide );\r\nif (SUDT->stretch) {\r\ntrack = FDC_READ( FDCREG_TRACK);\r\nMFPDELAY();\r\nFDC_WRITE(FDCREG_TRACK,track >> SUDT->stretch);\r\n}\r\nudelay(40);\r\nlocal_irq_save(flags);\r\ndma_wd.dma_lo = (unsigned char)paddr;\r\nMFPDELAY();\r\npaddr >>= 8;\r\ndma_wd.dma_md = (unsigned char)paddr;\r\nMFPDELAY();\r\npaddr >>= 8;\r\nif (ATARIHW_PRESENT( EXTD_DMA ))\r\nst_dma_ext_dmahi = (unsigned short)paddr;\r\nelse\r\ndma_wd.dma_hi = (unsigned char)paddr;\r\nMFPDELAY();\r\nlocal_irq_restore(flags);\r\ndma_wd.dma_mode_status = 0x190;\r\nMFPDELAY();\r\ndma_wd.dma_mode_status = 0x90;\r\nMFPDELAY();\r\ndma_wd.dma_mode_status = 0x190;\r\nMFPDELAY();\r\ndma_wd.fdc_acces_seccount = BUFFER_SIZE/512;\r\nudelay(40);\r\ndma_wd.dma_mode_status = FDCSELREG_STP | 0x100;\r\nudelay(40);\r\nSET_IRQ_HANDLER( fd_writetrack_done );\r\ndma_wd.fdc_acces_seccount = FDCCMD_WRTRA | get_head_settle_flag();\r\nMotorOn = 1;\r\nstart_timeout();\r\n}\r\nstatic void fd_writetrack_done( int status )\r\n{\r\nDPRINT(("fd_writetrack_done()\n"));\r\nstop_timeout();\r\nif (status & FDCSTAT_WPROT) {\r\nprintk(KERN_NOTICE "fd%d: is write protected\n", SelectedDrive );\r\ngoto err_end;\r\n}\r\nif (status & FDCSTAT_LOST) {\r\nprintk(KERN_ERR "fd%d: lost data (side %d, track %d)\n",\r\nSelectedDrive, ReqSide, ReqTrack );\r\ngoto err_end;\r\n}\r\ncomplete(&format_wait);\r\nreturn;\r\nerr_end:\r\nfd_error();\r\n}\r\nstatic void fd_times_out( unsigned long dummy )\r\n{\r\natari_disable_irq( IRQ_MFP_FDC );\r\nif (!FloppyIRQHandler) goto end;\r\nSET_IRQ_HANDLER( NULL );\r\nif (UseTrackbuffer)\r\ndel_timer( &readtrack_timer );\r\nFDC_WRITE( FDCREG_CMD, FDCCMD_FORCI );\r\nudelay( 25 );\r\nprintk(KERN_ERR "floppy timeout\n" );\r\nfd_error();\r\nend:\r\natari_enable_irq( IRQ_MFP_FDC );\r\n}\r\nstatic void finish_fdc( void )\r\n{\r\nif (!NeedSeek) {\r\nfinish_fdc_done( 0 );\r\n}\r\nelse {\r\nDPRINT(("finish_fdc: dummy seek started\n"));\r\nFDC_WRITE (FDCREG_DATA, SUD.track);\r\nSET_IRQ_HANDLER( finish_fdc_done );\r\nFDC_WRITE (FDCREG_CMD, FDCCMD_SEEK);\r\nMotorOn = 1;\r\nstart_timeout();\r\n}\r\n}\r\nstatic void finish_fdc_done( int dummy )\r\n{\r\nunsigned long flags;\r\nDPRINT(("finish_fdc_done entered\n"));\r\nstop_timeout();\r\nNeedSeek = 0;\r\nif (timer_pending(&fd_timer) && time_before(fd_timer.expires, jiffies + 5))\r\nmod_timer(&fd_timer, jiffies + 5);\r\nelse\r\nstart_check_change_timer();\r\nstart_motor_off_timer();\r\nlocal_irq_save(flags);\r\nstdma_release();\r\nfdc_busy = 0;\r\nwake_up( &fdc_wait );\r\nlocal_irq_restore(flags);\r\nDPRINT(("finish_fdc() finished\n"));\r\n}\r\nstatic unsigned int floppy_check_events(struct gendisk *disk,\r\nunsigned int clearing)\r\n{\r\nstruct atari_floppy_struct *p = disk->private_data;\r\nunsigned int drive = p - unit;\r\nif (test_bit (drive, &fake_change)) {\r\nreturn DISK_EVENT_MEDIA_CHANGE;\r\n}\r\nif (test_bit (drive, &changed_floppies)) {\r\nreturn DISK_EVENT_MEDIA_CHANGE;\r\n}\r\nif (UD.wpstat) {\r\nreturn DISK_EVENT_MEDIA_CHANGE;\r\n}\r\nreturn 0;\r\n}\r\nstatic int floppy_revalidate(struct gendisk *disk)\r\n{\r\nstruct atari_floppy_struct *p = disk->private_data;\r\nunsigned int drive = p - unit;\r\nif (test_bit(drive, &changed_floppies) ||\r\ntest_bit(drive, &fake_change) ||\r\np->disktype == 0) {\r\nif (UD.flags & FTD_MSG)\r\nprintk(KERN_ERR "floppy: clear format %p!\n", UDT);\r\nBufferDrive = -1;\r\nclear_bit(drive, &fake_change);\r\nclear_bit(drive, &changed_floppies);\r\nif (default_params[drive].blocks == 0)\r\nUDT = NULL;\r\nelse\r\nUDT = &default_params[drive];\r\n}\r\nreturn 0;\r\n}\r\nstatic void setup_req_params( int drive )\r\n{\r\nint block = ReqBlock + ReqCnt;\r\nReqTrack = block / UDT->spt;\r\nReqSector = block - ReqTrack * UDT->spt + 1;\r\nReqSide = ReqTrack & 1;\r\nReqTrack >>= 1;\r\nReqData = ReqBuffer + 512 * ReqCnt;\r\nif (UseTrackbuffer)\r\nread_track = (ReqCmd == READ && fd_request->error_count == 0);\r\nelse\r\nread_track = 0;\r\nDPRINT(("Request params: Si=%d Tr=%d Se=%d Data=%08lx\n",ReqSide,\r\nReqTrack, ReqSector, (unsigned long)ReqData ));\r\n}\r\nstatic struct request *set_next_request(void)\r\n{\r\nstruct request_queue *q;\r\nint old_pos = fdc_queue;\r\nstruct request *rq = NULL;\r\ndo {\r\nq = unit[fdc_queue].disk->queue;\r\nif (++fdc_queue == FD_MAX_UNITS)\r\nfdc_queue = 0;\r\nif (q) {\r\nrq = blk_fetch_request(q);\r\nif (rq) {\r\nrq->error_count = 0;\r\nbreak;\r\n}\r\n}\r\n} while (fdc_queue != old_pos);\r\nreturn rq;\r\n}\r\nstatic void redo_fd_request(void)\r\n{\r\nint drive, type;\r\nstruct atari_floppy_struct *floppy;\r\nDPRINT(("redo_fd_request: fd_request=%p dev=%s fd_request->sector=%ld\n",\r\nfd_request, fd_request ? fd_request->rq_disk->disk_name : "",\r\nfd_request ? blk_rq_pos(fd_request) : 0 ));\r\nIsFormatting = 0;\r\nrepeat:\r\nif (!fd_request) {\r\nfd_request = set_next_request();\r\nif (!fd_request)\r\ngoto the_end;\r\n}\r\nfloppy = fd_request->rq_disk->private_data;\r\ndrive = floppy - unit;\r\ntype = floppy->type;\r\nif (!UD.connected) {\r\nprintk(KERN_ERR "Unknown Device: fd%d\n", drive );\r\nfd_end_request_cur(BLK_STS_IOERR);\r\ngoto repeat;\r\n}\r\nif (type == 0) {\r\nif (!UDT) {\r\nProbing = 1;\r\nUDT = atari_disk_type + StartDiskType[DriveType];\r\nset_capacity(floppy->disk, UDT->blocks);\r\nUD.autoprobe = 1;\r\n}\r\n}\r\nelse {\r\nif (--type >= NUM_DISK_MINORS) {\r\nprintk(KERN_WARNING "fd%d: invalid disk format", drive );\r\nfd_end_request_cur(BLK_STS_IOERR);\r\ngoto repeat;\r\n}\r\nif (minor2disktype[type].drive_types > DriveType) {\r\nprintk(KERN_WARNING "fd%d: unsupported disk format", drive );\r\nfd_end_request_cur(BLK_STS_IOERR);\r\ngoto repeat;\r\n}\r\ntype = minor2disktype[type].index;\r\nUDT = &atari_disk_type[type];\r\nset_capacity(floppy->disk, UDT->blocks);\r\nUD.autoprobe = 0;\r\n}\r\nif (blk_rq_pos(fd_request) + 1 > UDT->blocks) {\r\nfd_end_request_cur(BLK_STS_IOERR);\r\ngoto repeat;\r\n}\r\ndel_timer( &motor_off_timer );\r\nReqCnt = 0;\r\nReqCmd = rq_data_dir(fd_request);\r\nReqBlock = blk_rq_pos(fd_request);\r\nReqBuffer = bio_data(fd_request->bio);\r\nsetup_req_params( drive );\r\ndo_fd_action( drive );\r\nreturn;\r\nthe_end:\r\nfinish_fdc();\r\n}\r\nvoid do_fd_request(struct request_queue * q)\r\n{\r\nDPRINT(("do_fd_request for pid %d\n",current->pid));\r\nwait_event(fdc_wait, cmpxchg(&fdc_busy, 0, 1) == 0);\r\nstdma_lock(floppy_irq, NULL);\r\natari_disable_irq( IRQ_MFP_FDC );\r\nredo_fd_request();\r\natari_enable_irq( IRQ_MFP_FDC );\r\n}\r\nstatic int fd_locked_ioctl(struct block_device *bdev, fmode_t mode,\r\nunsigned int cmd, unsigned long param)\r\n{\r\nstruct gendisk *disk = bdev->bd_disk;\r\nstruct atari_floppy_struct *floppy = disk->private_data;\r\nint drive = floppy - unit;\r\nint type = floppy->type;\r\nstruct atari_format_descr fmt_desc;\r\nstruct atari_disk_type *dtp;\r\nstruct floppy_struct getprm;\r\nint settype;\r\nstruct floppy_struct setprm;\r\nvoid __user *argp = (void __user *)param;\r\nswitch (cmd) {\r\ncase FDGETPRM:\r\nif (type) {\r\nif (--type >= NUM_DISK_MINORS)\r\nreturn -ENODEV;\r\nif (minor2disktype[type].drive_types > DriveType)\r\nreturn -ENODEV;\r\ntype = minor2disktype[type].index;\r\ndtp = &atari_disk_type[type];\r\nif (UD.flags & FTD_MSG)\r\nprintk (KERN_ERR "floppy%d: found dtp %p name %s!\n",\r\ndrive, dtp, dtp->name);\r\n}\r\nelse {\r\nif (!UDT)\r\nreturn -ENXIO;\r\nelse\r\ndtp = UDT;\r\n}\r\nmemset((void *)&getprm, 0, sizeof(getprm));\r\ngetprm.size = dtp->blocks;\r\ngetprm.sect = dtp->spt;\r\ngetprm.head = 2;\r\ngetprm.track = dtp->blocks/dtp->spt/2;\r\ngetprm.stretch = dtp->stretch;\r\nif (copy_to_user(argp, &getprm, sizeof(getprm)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nswitch (cmd) {\r\ncase FDSETPRM:\r\ncase FDDEFPRM:\r\nif (floppy->ref != 1 && floppy->ref != -1)\r\nreturn -EBUSY;\r\nif (copy_from_user(&setprm, argp, sizeof(setprm)))\r\nreturn -EFAULT;\r\nif (floppy_check_events(disk, 0))\r\nfloppy_revalidate(disk);\r\nif (UD.flags & FTD_MSG)\r\nprintk (KERN_INFO "floppy%d: setting size %d spt %d str %d!\n",\r\ndrive, setprm.size, setprm.sect, setprm.stretch);\r\nif (type) {\r\nredo_fd_request();\r\nreturn -EINVAL;\r\n}\r\nfor (settype = 0; settype < NUM_DISK_MINORS; settype++) {\r\nint setidx = 0;\r\nif (minor2disktype[settype].drive_types > DriveType) {\r\ncontinue;\r\n}\r\nsetidx = minor2disktype[settype].index;\r\ndtp = &atari_disk_type[setidx];\r\nif ( dtp->blocks == setprm.size\r\n&& dtp->spt == setprm.sect\r\n&& dtp->stretch == setprm.stretch ) {\r\nif (UD.flags & FTD_MSG)\r\nprintk (KERN_INFO "floppy%d: setting %s %p!\n",\r\ndrive, dtp->name, dtp);\r\nUDT = dtp;\r\nset_capacity(floppy->disk, UDT->blocks);\r\nif (cmd == FDDEFPRM) {\r\ndefault_params[drive].name = dtp->name;\r\ndefault_params[drive].spt = dtp->spt;\r\ndefault_params[drive].blocks = dtp->blocks;\r\ndefault_params[drive].fdc_speed = dtp->fdc_speed;\r\ndefault_params[drive].stretch = dtp->stretch;\r\n}\r\nreturn 0;\r\n}\r\n}\r\nif (cmd == FDDEFPRM) {\r\ndtp = &default_params[drive];\r\n} else\r\ndtp = &user_params[drive];\r\ndtp->name = "user format";\r\ndtp->blocks = setprm.size;\r\ndtp->spt = setprm.sect;\r\nif (setprm.sect > 14)\r\ndtp->fdc_speed = 3;\r\nelse\r\ndtp->fdc_speed = 0;\r\ndtp->stretch = setprm.stretch;\r\nif (UD.flags & FTD_MSG)\r\nprintk (KERN_INFO "floppy%d: blk %d spt %d str %d!\n",\r\ndrive, dtp->blocks, dtp->spt, dtp->stretch);\r\nif (setprm.track != dtp->blocks/dtp->spt/2 ||\r\nsetprm.head != 2) {\r\nredo_fd_request();\r\nreturn -EINVAL;\r\n}\r\nUDT = dtp;\r\nset_capacity(floppy->disk, UDT->blocks);\r\nreturn 0;\r\ncase FDMSGON:\r\nUD.flags |= FTD_MSG;\r\nreturn 0;\r\ncase FDMSGOFF:\r\nUD.flags &= ~FTD_MSG;\r\nreturn 0;\r\ncase FDSETEMSGTRESH:\r\nreturn -EINVAL;\r\ncase FDFMTBEG:\r\nreturn 0;\r\ncase FDFMTTRK:\r\nif (floppy->ref != 1 && floppy->ref != -1)\r\nreturn -EBUSY;\r\nif (copy_from_user(&fmt_desc, argp, sizeof(fmt_desc)))\r\nreturn -EFAULT;\r\nreturn do_format(drive, type, &fmt_desc);\r\ncase FDCLRPRM:\r\nUDT = NULL;\r\ndefault_params[drive].blocks = 0;\r\nset_capacity(floppy->disk, MAX_DISK_SIZE * 2);\r\ncase FDFMTEND:\r\ncase FDFLUSH:\r\nBufferDrive = -1;\r\nset_bit(drive, &fake_change);\r\ncheck_disk_change(bdev);\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int fd_ioctl(struct block_device *bdev, fmode_t mode,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nint ret;\r\nmutex_lock(&ataflop_mutex);\r\nret = fd_locked_ioctl(bdev, mode, cmd, arg);\r\nmutex_unlock(&ataflop_mutex);\r\nreturn ret;\r\n}\r\nstatic void __init fd_probe( int drive )\r\n{\r\nUD.connected = 0;\r\nUDT = NULL;\r\nif (!fd_test_drive_present( drive ))\r\nreturn;\r\nUD.connected = 1;\r\nUD.track = 0;\r\nswitch( UserSteprate[drive] ) {\r\ncase 2:\r\nUD.steprate = FDCSTEP_2;\r\nbreak;\r\ncase 3:\r\nUD.steprate = FDCSTEP_3;\r\nbreak;\r\ncase 6:\r\nUD.steprate = FDCSTEP_6;\r\nbreak;\r\ncase 12:\r\nUD.steprate = FDCSTEP_12;\r\nbreak;\r\ndefault:\r\nif (ATARIHW_PRESENT( FDCSPEED ) || MACH_IS_MEDUSA)\r\nUD.steprate = FDCSTEP_3;\r\nelse\r\nUD.steprate = FDCSTEP_6;\r\nbreak;\r\n}\r\nMotorOn = 1;\r\n}\r\nstatic int __init fd_test_drive_present( int drive )\r\n{\r\nunsigned long timeout;\r\nunsigned char status;\r\nint ok;\r\nif (drive >= (MACH_IS_FALCON ? 1 : 2)) return( 0 );\r\nfd_select_drive( drive );\r\natari_turnoff_irq( IRQ_MFP_FDC );\r\nFDC_WRITE (FDCREG_TRACK, 0xff00);\r\nFDC_WRITE( FDCREG_CMD, FDCCMD_RESTORE | FDCCMDADD_H | FDCSTEP_6 );\r\ntimeout = jiffies + 2*HZ+HZ/2;\r\nwhile (time_before(jiffies, timeout))\r\nif (!(st_mfp.par_dt_reg & 0x20))\r\nbreak;\r\nstatus = FDC_READ( FDCREG_STATUS );\r\nok = (status & FDCSTAT_TR00) != 0;\r\nFDC_WRITE( FDCREG_CMD, FDCCMD_FORCI );\r\nudelay(500);\r\nstatus = FDC_READ( FDCREG_STATUS );\r\nudelay(20);\r\nif (ok) {\r\nFDC_WRITE( FDCREG_DATA, 0 );\r\nFDC_WRITE( FDCREG_CMD, FDCCMD_SEEK );\r\nwhile( st_mfp.par_dt_reg & 0x20 )\r\n;\r\nstatus = FDC_READ( FDCREG_STATUS );\r\n}\r\natari_turnon_irq( IRQ_MFP_FDC );\r\nreturn( ok );\r\n}\r\nstatic void __init config_types( void )\r\n{\r\nint drive, cnt = 0;\r\nif (ATARIHW_PRESENT(FDCSPEED))\r\ndma_wd.fdc_speed = 0;\r\nprintk(KERN_INFO "Probing floppy drive(s):\n");\r\nfor( drive = 0; drive < FD_MAX_UNITS; drive++ ) {\r\nfd_probe( drive );\r\nif (UD.connected) {\r\nprintk(KERN_INFO "fd%d\n", drive);\r\n++cnt;\r\n}\r\n}\r\nif (FDC_READ( FDCREG_STATUS ) & FDCSTAT_BUSY) {\r\nFDC_WRITE( FDCREG_CMD, FDCCMD_FORCI );\r\nudelay(500);\r\nFDC_READ( FDCREG_STATUS );\r\nudelay(20);\r\n}\r\nif (cnt > 0) {\r\nstart_motor_off_timer();\r\nif (cnt == 1) fd_select_drive( 0 );\r\nstart_check_change_timer();\r\n}\r\n}\r\nstatic int floppy_open(struct block_device *bdev, fmode_t mode)\r\n{\r\nstruct atari_floppy_struct *p = bdev->bd_disk->private_data;\r\nint type = MINOR(bdev->bd_dev) >> 2;\r\nDPRINT(("fd_open: type=%d\n",type));\r\nif (p->ref && p->type != type)\r\nreturn -EBUSY;\r\nif (p->ref == -1 || (p->ref && mode & FMODE_EXCL))\r\nreturn -EBUSY;\r\nif (mode & FMODE_EXCL)\r\np->ref = -1;\r\nelse\r\np->ref++;\r\np->type = type;\r\nif (mode & FMODE_NDELAY)\r\nreturn 0;\r\nif (mode & (FMODE_READ|FMODE_WRITE)) {\r\ncheck_disk_change(bdev);\r\nif (mode & FMODE_WRITE) {\r\nif (p->wpstat) {\r\nif (p->ref < 0)\r\np->ref = 0;\r\nelse\r\np->ref--;\r\nreturn -EROFS;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int floppy_unlocked_open(struct block_device *bdev, fmode_t mode)\r\n{\r\nint ret;\r\nmutex_lock(&ataflop_mutex);\r\nret = floppy_open(bdev, mode);\r\nmutex_unlock(&ataflop_mutex);\r\nreturn ret;\r\n}\r\nstatic void floppy_release(struct gendisk *disk, fmode_t mode)\r\n{\r\nstruct atari_floppy_struct *p = disk->private_data;\r\nmutex_lock(&ataflop_mutex);\r\nif (p->ref < 0)\r\np->ref = 0;\r\nelse if (!p->ref--) {\r\nprintk(KERN_ERR "floppy_release with fd_ref == 0");\r\np->ref = 0;\r\n}\r\nmutex_unlock(&ataflop_mutex);\r\n}\r\nstatic struct kobject *floppy_find(dev_t dev, int *part, void *data)\r\n{\r\nint drive = *part & 3;\r\nint type = *part >> 2;\r\nif (drive >= FD_MAX_UNITS || type > NUM_DISK_MINORS)\r\nreturn NULL;\r\n*part = 0;\r\nreturn get_disk(unit[drive].disk);\r\n}\r\nstatic int __init atari_floppy_init (void)\r\n{\r\nint i;\r\nif (!MACH_IS_ATARI)\r\nreturn -ENODEV;\r\nif (register_blkdev(FLOPPY_MAJOR,"fd"))\r\nreturn -EBUSY;\r\nfor (i = 0; i < FD_MAX_UNITS; i++) {\r\nunit[i].disk = alloc_disk(1);\r\nif (!unit[i].disk)\r\ngoto Enomem;\r\n}\r\nif (UseTrackbuffer < 0)\r\nUseTrackbuffer = !MACH_IS_MEDUSA;\r\nSelectedDrive = -1;\r\nBufferDrive = -1;\r\nDMABuffer = atari_stram_alloc(BUFFER_SIZE+512, "ataflop");\r\nif (!DMABuffer) {\r\nprintk(KERN_ERR "atari_floppy_init: cannot get dma buffer\n");\r\ngoto Enomem;\r\n}\r\nTrackBuffer = DMABuffer + 512;\r\nPhysDMABuffer = atari_stram_to_phys(DMABuffer);\r\nPhysTrackBuffer = virt_to_phys(TrackBuffer);\r\nBufferDrive = BufferSide = BufferTrack = -1;\r\nfor (i = 0; i < FD_MAX_UNITS; i++) {\r\nunit[i].track = -1;\r\nunit[i].flags = 0;\r\nunit[i].disk->major = FLOPPY_MAJOR;\r\nunit[i].disk->first_minor = i;\r\nsprintf(unit[i].disk->disk_name, "fd%d", i);\r\nunit[i].disk->fops = &floppy_fops;\r\nunit[i].disk->private_data = &unit[i];\r\nunit[i].disk->queue = blk_init_queue(do_fd_request,\r\n&ataflop_lock);\r\nif (!unit[i].disk->queue)\r\ngoto Enomem;\r\nset_capacity(unit[i].disk, MAX_DISK_SIZE * 2);\r\nadd_disk(unit[i].disk);\r\n}\r\nblk_register_region(MKDEV(FLOPPY_MAJOR, 0), 256, THIS_MODULE,\r\nfloppy_find, NULL, NULL);\r\nprintk(KERN_INFO "Atari floppy driver: max. %cD, %strack buffering\n",\r\nDriveType == 0 ? 'D' : DriveType == 1 ? 'H' : 'E',\r\nUseTrackbuffer ? "" : "no ");\r\nconfig_types();\r\nreturn 0;\r\nEnomem:\r\nwhile (i--) {\r\nstruct request_queue *q = unit[i].disk->queue;\r\nput_disk(unit[i].disk);\r\nif (q)\r\nblk_cleanup_queue(q);\r\n}\r\nunregister_blkdev(FLOPPY_MAJOR, "fd");\r\nreturn -ENOMEM;\r\n}\r\nstatic int __init atari_floppy_setup(char *str)\r\n{\r\nint ints[3 + FD_MAX_UNITS];\r\nint i;\r\nif (!MACH_IS_ATARI)\r\nreturn 0;\r\nstr = get_options(str, 3 + FD_MAX_UNITS, ints);\r\nif (ints[0] < 1) {\r\nprintk(KERN_ERR "ataflop_setup: no arguments!\n" );\r\nreturn 0;\r\n}\r\nelse if (ints[0] > 2+FD_MAX_UNITS) {\r\nprintk(KERN_ERR "ataflop_setup: too many arguments\n" );\r\n}\r\nif (ints[1] < 0 || ints[1] > 2)\r\nprintk(KERN_ERR "ataflop_setup: bad drive type\n" );\r\nelse\r\nDriveType = ints[1];\r\nif (ints[0] >= 2)\r\nUseTrackbuffer = (ints[2] > 0);\r\nfor( i = 3; i <= ints[0] && i-3 < FD_MAX_UNITS; ++i ) {\r\nif (ints[i] != 2 && ints[i] != 3 && ints[i] != 6 && ints[i] != 12)\r\nprintk(KERN_ERR "ataflop_setup: bad steprate\n" );\r\nelse\r\nUserSteprate[i-3] = ints[i];\r\n}\r\nreturn 1;\r\n}\r\nstatic void __exit atari_floppy_exit(void)\r\n{\r\nint i;\r\nblk_unregister_region(MKDEV(FLOPPY_MAJOR, 0), 256);\r\nfor (i = 0; i < FD_MAX_UNITS; i++) {\r\nstruct request_queue *q = unit[i].disk->queue;\r\ndel_gendisk(unit[i].disk);\r\nput_disk(unit[i].disk);\r\nblk_cleanup_queue(q);\r\n}\r\nunregister_blkdev(FLOPPY_MAJOR, "fd");\r\ndel_timer_sync(&fd_timer);\r\natari_stram_free( DMABuffer );\r\n}
