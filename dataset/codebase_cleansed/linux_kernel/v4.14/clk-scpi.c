static unsigned long scpi_clk_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct scpi_clk *clk = to_scpi_clk(hw);\r\nreturn clk->scpi_ops->clk_get_val(clk->id);\r\n}\r\nstatic long scpi_clk_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nreturn rate;\r\n}\r\nstatic int scpi_clk_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct scpi_clk *clk = to_scpi_clk(hw);\r\nreturn clk->scpi_ops->clk_set_val(clk->id, rate);\r\n}\r\nstatic long __scpi_dvfs_round_rate(struct scpi_clk *clk, unsigned long rate)\r\n{\r\nint idx;\r\nunsigned long fmin = 0, fmax = ~0, ftmp;\r\nconst struct scpi_opp *opp = clk->info->opps;\r\nfor (idx = 0; idx < clk->info->count; idx++, opp++) {\r\nftmp = opp->freq;\r\nif (ftmp >= rate) {\r\nif (ftmp <= fmax)\r\nfmax = ftmp;\r\nbreak;\r\n} else if (ftmp >= fmin) {\r\nfmin = ftmp;\r\n}\r\n}\r\nreturn fmax != ~0 ? fmax : fmin;\r\n}\r\nstatic unsigned long scpi_dvfs_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct scpi_clk *clk = to_scpi_clk(hw);\r\nint idx = clk->scpi_ops->dvfs_get_idx(clk->id);\r\nconst struct scpi_opp *opp;\r\nif (idx < 0)\r\nreturn 0;\r\nopp = clk->info->opps + idx;\r\nreturn opp->freq;\r\n}\r\nstatic long scpi_dvfs_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nstruct scpi_clk *clk = to_scpi_clk(hw);\r\nreturn __scpi_dvfs_round_rate(clk, rate);\r\n}\r\nstatic int __scpi_find_dvfs_index(struct scpi_clk *clk, unsigned long rate)\r\n{\r\nint idx, max_opp = clk->info->count;\r\nconst struct scpi_opp *opp = clk->info->opps;\r\nfor (idx = 0; idx < max_opp; idx++, opp++)\r\nif (opp->freq == rate)\r\nreturn idx;\r\nreturn -EINVAL;\r\n}\r\nstatic int scpi_dvfs_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct scpi_clk *clk = to_scpi_clk(hw);\r\nint ret = __scpi_find_dvfs_index(clk, rate);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn clk->scpi_ops->dvfs_set_idx(clk->id, (u8)ret);\r\n}\r\nstatic int\r\nscpi_clk_ops_init(struct device *dev, const struct of_device_id *match,\r\nstruct scpi_clk *sclk, const char *name)\r\n{\r\nstruct clk_init_data init;\r\nunsigned long min = 0, max = 0;\r\nint ret;\r\ninit.name = name;\r\ninit.flags = 0;\r\ninit.num_parents = 0;\r\ninit.ops = match->data;\r\nsclk->hw.init = &init;\r\nsclk->scpi_ops = get_scpi_ops();\r\nif (init.ops == &scpi_dvfs_ops) {\r\nsclk->info = sclk->scpi_ops->dvfs_get_info(sclk->id);\r\nif (IS_ERR(sclk->info))\r\nreturn PTR_ERR(sclk->info);\r\n} else if (init.ops == &scpi_clk_ops) {\r\nif (sclk->scpi_ops->clk_get_range(sclk->id, &min, &max) || !max)\r\nreturn -EINVAL;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nret = devm_clk_hw_register(dev, &sclk->hw);\r\nif (!ret && max)\r\nclk_hw_set_rate_range(&sclk->hw, min, max);\r\nreturn ret;\r\n}\r\nstatic struct clk_hw *\r\nscpi_of_clk_src_get(struct of_phandle_args *clkspec, void *data)\r\n{\r\nstruct scpi_clk *sclk;\r\nstruct scpi_clk_data *clk_data = data;\r\nunsigned int idx = clkspec->args[0], count;\r\nfor (count = 0; count < clk_data->clk_num; count++) {\r\nsclk = clk_data->clk[count];\r\nif (idx == sclk->id)\r\nreturn &sclk->hw;\r\n}\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nstatic int scpi_clk_add(struct device *dev, struct device_node *np,\r\nconst struct of_device_id *match)\r\n{\r\nint idx, count, err;\r\nstruct scpi_clk_data *clk_data;\r\ncount = of_property_count_strings(np, "clock-output-names");\r\nif (count < 0) {\r\ndev_err(dev, "%s: invalid clock output count\n", np->name);\r\nreturn -EINVAL;\r\n}\r\nclk_data = devm_kmalloc(dev, sizeof(*clk_data), GFP_KERNEL);\r\nif (!clk_data)\r\nreturn -ENOMEM;\r\nclk_data->clk_num = count;\r\nclk_data->clk = devm_kcalloc(dev, count, sizeof(*clk_data->clk),\r\nGFP_KERNEL);\r\nif (!clk_data->clk)\r\nreturn -ENOMEM;\r\nfor (idx = 0; idx < count; idx++) {\r\nstruct scpi_clk *sclk;\r\nconst char *name;\r\nu32 val;\r\nsclk = devm_kzalloc(dev, sizeof(*sclk), GFP_KERNEL);\r\nif (!sclk)\r\nreturn -ENOMEM;\r\nif (of_property_read_string_index(np, "clock-output-names",\r\nidx, &name)) {\r\ndev_err(dev, "invalid clock name @ %s\n", np->name);\r\nreturn -EINVAL;\r\n}\r\nif (of_property_read_u32_index(np, "clock-indices",\r\nidx, &val)) {\r\ndev_err(dev, "invalid clock index @ %s\n", np->name);\r\nreturn -EINVAL;\r\n}\r\nsclk->id = val;\r\nerr = scpi_clk_ops_init(dev, match, sclk, name);\r\nif (err) {\r\ndev_err(dev, "failed to register clock '%s'\n", name);\r\nreturn err;\r\n}\r\ndev_dbg(dev, "Registered clock '%s'\n", name);\r\nclk_data->clk[idx] = sclk;\r\n}\r\nreturn of_clk_add_hw_provider(np, scpi_of_clk_src_get, clk_data);\r\n}\r\nstatic int scpi_clocks_remove(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *child, *np = dev->of_node;\r\nif (cpufreq_dev) {\r\nplatform_device_unregister(cpufreq_dev);\r\ncpufreq_dev = NULL;\r\n}\r\nfor_each_available_child_of_node(np, child)\r\nof_clk_del_provider(np);\r\nreturn 0;\r\n}\r\nstatic int scpi_clocks_probe(struct platform_device *pdev)\r\n{\r\nint ret;\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *child, *np = dev->of_node;\r\nconst struct of_device_id *match;\r\nif (!get_scpi_ops())\r\nreturn -ENXIO;\r\nfor_each_available_child_of_node(np, child) {\r\nmatch = of_match_node(scpi_clk_match, child);\r\nif (!match)\r\ncontinue;\r\nret = scpi_clk_add(dev, child, match);\r\nif (ret) {\r\nscpi_clocks_remove(pdev);\r\nof_node_put(child);\r\nreturn ret;\r\n}\r\nif (match->data != &scpi_dvfs_ops)\r\ncontinue;\r\ncpufreq_dev = platform_device_register_simple("scpi-cpufreq",\r\n-1, NULL, 0);\r\nif (IS_ERR(cpufreq_dev))\r\npr_warn("unable to register cpufreq device");\r\n}\r\nreturn 0;\r\n}
