static void tm2_touchkey_led_brightness_set(struct led_classdev *led_dev,\r\nenum led_brightness brightness)\r\n{\r\nstruct tm2_touchkey_data *touchkey =\r\ncontainer_of(led_dev, struct tm2_touchkey_data, led_dev);\r\nu32 volt;\r\nu8 data;\r\nif (brightness == LED_OFF) {\r\nvolt = TM2_TOUCHKEY_LED_VOLTAGE_MIN;\r\ndata = TM2_TOUCHKEY_CMD_LED_OFF;\r\n} else {\r\nvolt = TM2_TOUCHKEY_LED_VOLTAGE_MAX;\r\ndata = TM2_TOUCHKEY_CMD_LED_ON;\r\n}\r\nregulator_set_voltage(touchkey->vdd, volt, volt);\r\ni2c_smbus_write_byte_data(touchkey->client,\r\nTM2_TOUCHKEY_BASE_REG, data);\r\n}\r\nstatic int tm2_touchkey_power_enable(struct tm2_touchkey_data *touchkey)\r\n{\r\nint error;\r\nerror = regulator_bulk_enable(ARRAY_SIZE(touchkey->regulators),\r\ntouchkey->regulators);\r\nif (error)\r\nreturn error;\r\nmsleep(150);\r\nreturn 0;\r\n}\r\nstatic void tm2_touchkey_power_disable(void *data)\r\n{\r\nstruct tm2_touchkey_data *touchkey = data;\r\nregulator_bulk_disable(ARRAY_SIZE(touchkey->regulators),\r\ntouchkey->regulators);\r\n}\r\nstatic irqreturn_t tm2_touchkey_irq_handler(int irq, void *devid)\r\n{\r\nstruct tm2_touchkey_data *touchkey = devid;\r\nint data;\r\nint key;\r\ndata = i2c_smbus_read_byte_data(touchkey->client,\r\nTM2_TOUCHKEY_KEYCODE_REG);\r\nif (data < 0) {\r\ndev_err(&touchkey->client->dev,\r\n"failed to read i2c data: %d\n", data);\r\ngoto out;\r\n}\r\nswitch (data & TM2_TOUCHKEY_BIT_KEYCODE) {\r\ncase TM2_TOUCHKEY_KEY_MENU:\r\nkey = KEY_PHONE;\r\nbreak;\r\ncase TM2_TOUCHKEY_KEY_BACK:\r\nkey = KEY_BACK;\r\nbreak;\r\ndefault:\r\ndev_warn(&touchkey->client->dev,\r\n"unhandled keycode, data %#02x\n", data);\r\ngoto out;\r\n}\r\nif (data & TM2_TOUCHKEY_BIT_PRESS_EV) {\r\ninput_report_key(touchkey->input_dev, KEY_PHONE, 0);\r\ninput_report_key(touchkey->input_dev, KEY_BACK, 0);\r\n} else {\r\ninput_report_key(touchkey->input_dev, key, 1);\r\n}\r\ninput_sync(touchkey->input_dev);\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int tm2_touchkey_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct tm2_touchkey_data *touchkey;\r\nint error;\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_BYTE | I2C_FUNC_SMBUS_BYTE_DATA)) {\r\ndev_err(&client->dev, "incompatible I2C adapter\n");\r\nreturn -EIO;\r\n}\r\ntouchkey = devm_kzalloc(&client->dev, sizeof(*touchkey), GFP_KERNEL);\r\nif (!touchkey)\r\nreturn -ENOMEM;\r\ntouchkey->client = client;\r\ni2c_set_clientdata(client, touchkey);\r\ntouchkey->regulators[0].supply = "vcc";\r\ntouchkey->regulators[1].supply = "vdd";\r\nerror = devm_regulator_bulk_get(&client->dev,\r\nARRAY_SIZE(touchkey->regulators),\r\ntouchkey->regulators);\r\nif (error) {\r\ndev_err(&client->dev, "failed to get regulators: %d\n", error);\r\nreturn error;\r\n}\r\ntouchkey->vdd = touchkey->regulators[1].consumer;\r\nerror = tm2_touchkey_power_enable(touchkey);\r\nif (error) {\r\ndev_err(&client->dev, "failed to power up device: %d\n", error);\r\nreturn error;\r\n}\r\nerror = devm_add_action_or_reset(&client->dev,\r\ntm2_touchkey_power_disable, touchkey);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"failed to install poweroff handler: %d\n", error);\r\nreturn error;\r\n}\r\ntouchkey->input_dev = devm_input_allocate_device(&client->dev);\r\nif (!touchkey->input_dev) {\r\ndev_err(&client->dev, "failed to allocate input device\n");\r\nreturn -ENOMEM;\r\n}\r\ntouchkey->input_dev->name = TM2_TOUCHKEY_DEV_NAME;\r\ntouchkey->input_dev->id.bustype = BUS_I2C;\r\ninput_set_capability(touchkey->input_dev, EV_KEY, KEY_PHONE);\r\ninput_set_capability(touchkey->input_dev, EV_KEY, KEY_BACK);\r\nerror = input_register_device(touchkey->input_dev);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"failed to register input device: %d\n", error);\r\nreturn error;\r\n}\r\nerror = devm_request_threaded_irq(&client->dev, client->irq,\r\nNULL, tm2_touchkey_irq_handler,\r\nIRQF_ONESHOT,\r\nTM2_TOUCHKEY_DEV_NAME, touchkey);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"failed to request threaded irq: %d\n", error);\r\nreturn error;\r\n}\r\ntouchkey->led_dev.name = TM2_TOUCHKEY_DEV_NAME;\r\ntouchkey->led_dev.brightness = LED_FULL;\r\ntouchkey->led_dev.max_brightness = LED_ON;\r\ntouchkey->led_dev.brightness_set = tm2_touchkey_led_brightness_set;\r\nerror = devm_led_classdev_register(&client->dev, &touchkey->led_dev);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"failed to register touchkey led: %d\n", error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused tm2_touchkey_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct tm2_touchkey_data *touchkey = i2c_get_clientdata(client);\r\ndisable_irq(client->irq);\r\ntm2_touchkey_power_disable(touchkey);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused tm2_touchkey_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct tm2_touchkey_data *touchkey = i2c_get_clientdata(client);\r\nint ret;\r\nenable_irq(client->irq);\r\nret = tm2_touchkey_power_enable(touchkey);\r\nif (ret)\r\ndev_err(dev, "failed to enable power: %d\n", ret);\r\nreturn ret;\r\n}
