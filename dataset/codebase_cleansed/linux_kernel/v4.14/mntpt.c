static struct dentry *afs_mntpt_lookup(struct inode *dir,\r\nstruct dentry *dentry,\r\nunsigned int flags)\r\n{\r\n_enter("%p,%p{%pd2}", dir, dentry, dentry);\r\nreturn ERR_PTR(-EREMOTE);\r\n}\r\nstatic int afs_mntpt_open(struct inode *inode, struct file *file)\r\n{\r\n_enter("%p,%p{%pD2}", inode, file, file);\r\nreturn -EREMOTE;\r\n}\r\nstatic struct vfsmount *afs_mntpt_do_automount(struct dentry *mntpt)\r\n{\r\nstruct afs_super_info *super;\r\nstruct vfsmount *mnt;\r\nstruct afs_vnode *vnode;\r\nstruct page *page;\r\nchar *devname, *options;\r\nbool rwpath = false;\r\nint ret;\r\n_enter("{%pd}", mntpt);\r\nBUG_ON(!d_inode(mntpt));\r\nret = -ENOMEM;\r\ndevname = (char *) get_zeroed_page(GFP_KERNEL);\r\nif (!devname)\r\ngoto error_no_devname;\r\noptions = (char *) get_zeroed_page(GFP_KERNEL);\r\nif (!options)\r\ngoto error_no_options;\r\nvnode = AFS_FS_I(d_inode(mntpt));\r\nif (test_bit(AFS_VNODE_PSEUDODIR, &vnode->flags)) {\r\nstatic const char afs_root_cell[] = ":root.cell.";\r\nunsigned size = mntpt->d_name.len;\r\nret = -ENOENT;\r\nif (size < 2 || size > AFS_MAXCELLNAME)\r\ngoto error_no_page;\r\nif (mntpt->d_name.name[0] == '.') {\r\ndevname[0] = '#';\r\nmemcpy(devname + 1, mntpt->d_name.name, size - 1);\r\nmemcpy(devname + size, afs_root_cell,\r\nsizeof(afs_root_cell));\r\nrwpath = true;\r\n} else {\r\ndevname[0] = '%';\r\nmemcpy(devname + 1, mntpt->d_name.name, size);\r\nmemcpy(devname + size + 1, afs_root_cell,\r\nsizeof(afs_root_cell));\r\n}\r\n} else {\r\nloff_t size = i_size_read(d_inode(mntpt));\r\nchar *buf;\r\nret = -EINVAL;\r\nif (size > PAGE_SIZE - 1)\r\ngoto error_no_page;\r\npage = read_mapping_page(d_inode(mntpt)->i_mapping, 0, NULL);\r\nif (IS_ERR(page)) {\r\nret = PTR_ERR(page);\r\ngoto error_no_page;\r\n}\r\nret = -EIO;\r\nif (PageError(page))\r\ngoto error;\r\nbuf = kmap_atomic(page);\r\nmemcpy(devname, buf, size);\r\nkunmap_atomic(buf);\r\nput_page(page);\r\npage = NULL;\r\n}\r\nsuper = AFS_FS_S(mntpt->d_sb);\r\nmemcpy(options, "cell=", 5);\r\nstrcpy(options + 5, super->volume->cell->name);\r\nif (super->volume->type == AFSVL_RWVOL || rwpath)\r\nstrcat(options, ",rwpath");\r\n_debug("--- attempting mount %s -o %s ---", devname, options);\r\nmnt = vfs_submount(mntpt, &afs_fs_type, devname, options);\r\n_debug("--- mount result %p ---", mnt);\r\nfree_page((unsigned long) devname);\r\nfree_page((unsigned long) options);\r\n_leave(" = %p", mnt);\r\nreturn mnt;\r\nerror:\r\nput_page(page);\r\nerror_no_page:\r\nfree_page((unsigned long) options);\r\nerror_no_options:\r\nfree_page((unsigned long) devname);\r\nerror_no_devname:\r\n_leave(" = %d", ret);\r\nreturn ERR_PTR(ret);\r\n}\r\nstruct vfsmount *afs_d_automount(struct path *path)\r\n{\r\nstruct vfsmount *newmnt;\r\n_enter("{%pd}", path->dentry);\r\nnewmnt = afs_mntpt_do_automount(path->dentry);\r\nif (IS_ERR(newmnt))\r\nreturn newmnt;\r\nmntget(newmnt);\r\nmnt_set_expiry(newmnt, &afs_vfsmounts);\r\nqueue_delayed_work(afs_wq, &afs_mntpt_expiry_timer,\r\nafs_mntpt_expiry_timeout * HZ);\r\n_leave(" = %p", newmnt);\r\nreturn newmnt;\r\n}\r\nstatic void afs_mntpt_expiry_timed_out(struct work_struct *work)\r\n{\r\n_enter("");\r\nif (!list_empty(&afs_vfsmounts)) {\r\nmark_mounts_for_expiry(&afs_vfsmounts);\r\nqueue_delayed_work(afs_wq, &afs_mntpt_expiry_timer,\r\nafs_mntpt_expiry_timeout * HZ);\r\n}\r\n_leave("");\r\n}\r\nvoid afs_mntpt_kill_timer(void)\r\n{\r\n_enter("");\r\nASSERT(list_empty(&afs_vfsmounts));\r\ncancel_delayed_work_sync(&afs_mntpt_expiry_timer);\r\n}
