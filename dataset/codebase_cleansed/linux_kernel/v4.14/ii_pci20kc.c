static void __iomem *ii20k_module_iobase(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nreturn dev->mmio + (s->index + 1) * II20K_MOD_OFFSET;\r\n}\r\nstatic int ii20k_ao_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nvoid __iomem *iobase = ii20k_module_iobase(dev, s);\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nint i;\r\nfor (i = 0; i < insn->n; i++) {\r\nunsigned int val = data[i];\r\ns->readback[chan] = val;\r\nval = comedi_offset_munge(s, val);\r\nwriteb(val & 0xff, iobase + II20K_AO_LSB_REG(chan));\r\nwriteb((val >> 8) & 0xff, iobase + II20K_AO_MSB_REG(chan));\r\nwriteb(0x00, iobase + II20K_AO_STRB_REG(chan));\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int ii20k_ai_eoc(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned long context)\r\n{\r\nvoid __iomem *iobase = ii20k_module_iobase(dev, s);\r\nunsigned char status;\r\nstatus = readb(iobase + II20K_AI_STATUS_REG);\r\nif ((status & II20K_AI_STATUS_INT) == 0)\r\nreturn 0;\r\nreturn -EBUSY;\r\n}\r\nstatic void ii20k_ai_setup(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int chanspec)\r\n{\r\nvoid __iomem *iobase = ii20k_module_iobase(dev, s);\r\nunsigned int chan = CR_CHAN(chanspec);\r\nunsigned int range = CR_RANGE(chanspec);\r\nunsigned char val;\r\nwriteb(II20K_AI_CONF_ENA, iobase + II20K_AI_CONF_REG);\r\nwriteb(0, iobase + II20K_AI_STATUS_CMD_REG);\r\nval = (range < 3) ? II20K_AI_OPT_TIMEBASE(0) : II20K_AI_OPT_TIMEBASE(2);\r\nwriteb(val, iobase + II20K_AI_OPT_REG);\r\nval = (range < 2) ? 0x58 : (range < 3) ? 0x93 : 0x99;\r\nwriteb(val, iobase + II20K_AI_SET_TIME_REG);\r\nwriteb(1, iobase + II20K_AI_LAST_CHAN_ADDR_REG);\r\nval = II20K_AI_CHANLIST_ONBOARD_ONLY |\r\nII20K_AI_CHANLIST_MUX_ENA |\r\nII20K_AI_CHANLIST_GAIN(range) |\r\nII20K_AI_CHANLIST_CHAN(chan);\r\nwriteb(val, iobase + II20K_AI_CHANLIST_REG);\r\nwriteb(0, iobase + II20K_AI_COUNT_RESET_REG);\r\nwriteb(0, iobase + II20K_AI_CHAN_RESET_REG);\r\n}\r\nstatic int ii20k_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nvoid __iomem *iobase = ii20k_module_iobase(dev, s);\r\nint ret;\r\nint i;\r\nii20k_ai_setup(dev, s, insn->chanspec);\r\nfor (i = 0; i < insn->n; i++) {\r\nunsigned int val;\r\nreadb(iobase + II20K_AI_PACER_RESET_REG);\r\nret = comedi_timeout(dev, s, insn, ii20k_ai_eoc, 0);\r\nif (ret)\r\nreturn ret;\r\nval = readb(iobase + II20K_AI_LSB_REG);\r\nval |= (readb(iobase + II20K_AI_MSB_REG) << 8);\r\ndata[i] = comedi_offset_munge(s, val);\r\n}\r\nreturn insn->n;\r\n}\r\nstatic void ii20k_dio_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nunsigned char ctrl01 = 0;\r\nunsigned char ctrl23 = 0;\r\nunsigned char dir_ena = 0;\r\nif (s->io_bits & 0x000000ff) {\r\nctrl01 &= ~II20K_CTRL01_DIO0_IN;\r\ndir_ena &= ~II20K_BUF_DISAB_DIO0;\r\ndir_ena |= II20K_DIR_DIO0_OUT;\r\n} else {\r\nctrl01 |= II20K_CTRL01_DIO0_IN;\r\ndir_ena &= ~II20K_DIR_DIO0_OUT;\r\n}\r\nif (s->io_bits & 0x0000ff00) {\r\nctrl01 &= ~II20K_CTRL01_DIO1_IN;\r\ndir_ena &= ~II20K_BUF_DISAB_DIO1;\r\ndir_ena |= II20K_DIR_DIO1_OUT;\r\n} else {\r\nctrl01 |= II20K_CTRL01_DIO1_IN;\r\ndir_ena &= ~II20K_DIR_DIO1_OUT;\r\n}\r\nif (s->io_bits & 0x00ff0000) {\r\nctrl23 &= ~II20K_CTRL23_DIO2_IN;\r\ndir_ena &= ~II20K_BUF_DISAB_DIO2;\r\ndir_ena |= II20K_DIR_DIO2_OUT;\r\n} else {\r\nctrl23 |= II20K_CTRL23_DIO2_IN;\r\ndir_ena &= ~II20K_DIR_DIO2_OUT;\r\n}\r\nif (s->io_bits & 0xff000000) {\r\nctrl23 &= ~II20K_CTRL23_DIO3_IN;\r\ndir_ena &= ~II20K_BUF_DISAB_DIO3;\r\ndir_ena |= II20K_DIR_DIO3_OUT;\r\n} else {\r\nctrl23 |= II20K_CTRL23_DIO3_IN;\r\ndir_ena &= ~II20K_DIR_DIO3_OUT;\r\n}\r\nctrl23 |= II20K_CTRL01_SET;\r\nctrl23 |= II20K_CTRL23_SET;\r\nwriteb(ctrl01, dev->mmio + II20K_CTRL01_REG);\r\nwriteb(ctrl23, dev->mmio + II20K_CTRL23_REG);\r\nwriteb(dir_ena, dev->mmio + II20K_DIR_ENA_REG);\r\n}\r\nstatic int ii20k_dio_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int mask;\r\nint ret;\r\nif (chan < 8)\r\nmask = 0x000000ff;\r\nelse if (chan < 16)\r\nmask = 0x0000ff00;\r\nelse if (chan < 24)\r\nmask = 0x00ff0000;\r\nelse\r\nmask = 0xff000000;\r\nret = comedi_dio_insn_config(dev, s, insn, data, mask);\r\nif (ret)\r\nreturn ret;\r\nii20k_dio_config(dev, s);\r\nreturn insn->n;\r\n}\r\nstatic int ii20k_dio_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int mask;\r\nmask = comedi_dio_update_state(s, data);\r\nif (mask) {\r\nif (mask & 0x000000ff)\r\nwriteb((s->state >> 0) & 0xff,\r\ndev->mmio + II20K_DIO0_REG);\r\nif (mask & 0x0000ff00)\r\nwriteb((s->state >> 8) & 0xff,\r\ndev->mmio + II20K_DIO1_REG);\r\nif (mask & 0x00ff0000)\r\nwriteb((s->state >> 16) & 0xff,\r\ndev->mmio + II20K_DIO2_REG);\r\nif (mask & 0xff000000)\r\nwriteb((s->state >> 24) & 0xff,\r\ndev->mmio + II20K_DIO3_REG);\r\n}\r\ndata[1] = readb(dev->mmio + II20K_DIO0_REG);\r\ndata[1] |= readb(dev->mmio + II20K_DIO1_REG) << 8;\r\ndata[1] |= readb(dev->mmio + II20K_DIO2_REG) << 16;\r\ndata[1] |= readb(dev->mmio + II20K_DIO3_REG) << 24;\r\nreturn insn->n;\r\n}\r\nstatic int ii20k_init_module(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nvoid __iomem *iobase = ii20k_module_iobase(dev, s);\r\nunsigned char id;\r\nint ret;\r\nid = readb(iobase + II20K_ID_REG);\r\nswitch (id) {\r\ncase II20K_ID_PCI20006M_1:\r\ncase II20K_ID_PCI20006M_2:\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE;\r\ns->n_chan = (id == II20K_ID_PCI20006M_2) ? 2 : 1;\r\ns->maxdata = 0xffff;\r\ns->range_table = &ii20k_ao_ranges;\r\ns->insn_write = ii20k_ao_insn_write;\r\nret = comedi_alloc_subdev_readback(s);\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ncase II20K_ID_PCI20341M_1:\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_DIFF;\r\ns->n_chan = 4;\r\ns->maxdata = 0xffff;\r\ns->range_table = &ii20k_ai_ranges;\r\ns->insn_read = ii20k_ai_insn_read;\r\nbreak;\r\ndefault:\r\ns->type = COMEDI_SUBD_UNUSED;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ii20k_attach(struct comedi_device *dev,\r\nstruct comedi_devconfig *it)\r\n{\r\nstruct comedi_subdevice *s;\r\nunsigned int membase;\r\nunsigned char id;\r\nbool has_dio;\r\nint ret;\r\nmembase = it->options[0];\r\nif (!membase || (membase & ~(0x100000 - II20K_SIZE))) {\r\ndev_warn(dev->class_dev,\r\n"%s: invalid memory address specified\n",\r\ndev->board_name);\r\nreturn -EINVAL;\r\n}\r\nif (!request_mem_region(membase, II20K_SIZE, dev->board_name)) {\r\ndev_warn(dev->class_dev, "%s: I/O mem conflict (%#x,%u)\n",\r\ndev->board_name, membase, II20K_SIZE);\r\nreturn -EIO;\r\n}\r\ndev->iobase = membase;\r\ndev->mmio = ioremap(membase, II20K_SIZE);\r\nif (!dev->mmio)\r\nreturn -ENOMEM;\r\nid = readb(dev->mmio + II20K_ID_REG);\r\nswitch (id & II20K_ID_MASK) {\r\ncase II20K_ID_PCI20001C_1A:\r\nhas_dio = false;\r\nbreak;\r\ncase II20K_ID_PCI20001C_2A:\r\nhas_dio = true;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nret = comedi_alloc_subdevices(dev, 4);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[0];\r\nif (id & II20K_ID_MOD1_EMPTY) {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n} else {\r\nret = ii20k_init_module(dev, s);\r\nif (ret)\r\nreturn ret;\r\n}\r\ns = &dev->subdevices[1];\r\nif (id & II20K_ID_MOD2_EMPTY) {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n} else {\r\nret = ii20k_init_module(dev, s);\r\nif (ret)\r\nreturn ret;\r\n}\r\ns = &dev->subdevices[2];\r\nif (id & II20K_ID_MOD3_EMPTY) {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n} else {\r\nret = ii20k_init_module(dev, s);\r\nif (ret)\r\nreturn ret;\r\n}\r\ns = &dev->subdevices[3];\r\nif (has_dio) {\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE;\r\ns->n_chan = 32;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = ii20k_dio_insn_bits;\r\ns->insn_config = ii20k_dio_insn_config;\r\nii20k_dio_config(dev, s);\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ii20k_detach(struct comedi_device *dev)\r\n{\r\nif (dev->mmio)\r\niounmap(dev->mmio);\r\nif (dev->iobase)\r\nrelease_mem_region(dev->iobase, II20K_SIZE);\r\n}
