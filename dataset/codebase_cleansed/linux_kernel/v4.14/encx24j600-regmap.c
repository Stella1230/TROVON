static inline bool is_bits_set(int value, int mask)\r\n{\r\nreturn (value & mask) == mask;\r\n}\r\nstatic int encx24j600_switch_bank(struct encx24j600_context *ctx,\r\nint bank)\r\n{\r\nint ret = 0;\r\nint bank_opcode = BANK_SELECT(bank);\r\nret = spi_write(ctx->spi, &bank_opcode, 1);\r\nif (ret == 0)\r\nctx->bank = bank;\r\nreturn ret;\r\n}\r\nstatic int encx24j600_cmdn(struct encx24j600_context *ctx, u8 opcode,\r\nconst void *buf, size_t len)\r\n{\r\nstruct spi_message m;\r\nstruct spi_transfer t[2] = { { .tx_buf = &opcode, .len = 1, },\r\n{ .tx_buf = buf, .len = len }, };\r\nspi_message_init(&m);\r\nspi_message_add_tail(&t[0], &m);\r\nspi_message_add_tail(&t[1], &m);\r\nreturn spi_sync(ctx->spi, &m);\r\n}\r\nstatic void regmap_lock_mutex(void *context)\r\n{\r\nstruct encx24j600_context *ctx = context;\r\nmutex_lock(&ctx->mutex);\r\n}\r\nstatic void regmap_unlock_mutex(void *context)\r\n{\r\nstruct encx24j600_context *ctx = context;\r\nmutex_unlock(&ctx->mutex);\r\n}\r\nstatic int regmap_encx24j600_sfr_read(void *context, u8 reg, u8 *val,\r\nsize_t len)\r\n{\r\nstruct encx24j600_context *ctx = context;\r\nu8 banked_reg = reg & ADDR_MASK;\r\nu8 bank = ((reg & BANK_MASK) >> BANK_SHIFT);\r\nu8 cmd = RCRU;\r\nint ret = 0;\r\nint i = 0;\r\nu8 tx_buf[2];\r\nif (reg < 0x80) {\r\ncmd = RCRCODE | banked_reg;\r\nif ((banked_reg < 0x16) && (ctx->bank != bank))\r\nret = encx24j600_switch_bank(ctx, bank);\r\nif (unlikely(ret))\r\nreturn ret;\r\n} else {\r\nswitch (reg) {\r\ncase EGPRDPT:\r\ncmd = RGPRDPT; break;\r\ncase EGPWRPT:\r\ncmd = RGPWRPT; break;\r\ncase ERXRDPT:\r\ncmd = RRXRDPT; break;\r\ncase ERXWRPT:\r\ncmd = RRXWRPT; break;\r\ncase EUDARDPT:\r\ncmd = RUDARDPT; break;\r\ncase EUDAWRPT:\r\ncmd = RUDAWRPT; break;\r\ncase EGPDATA:\r\ncase ERXDATA:\r\ncase EUDADATA:\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\ntx_buf[i++] = cmd;\r\nif (cmd == RCRU)\r\ntx_buf[i++] = reg;\r\nret = spi_write_then_read(ctx->spi, tx_buf, i, val, len);\r\nreturn ret;\r\n}\r\nstatic int regmap_encx24j600_sfr_update(struct encx24j600_context *ctx,\r\nu8 reg, u8 *val, size_t len,\r\nu8 unbanked_cmd, u8 banked_code)\r\n{\r\nu8 banked_reg = reg & ADDR_MASK;\r\nu8 bank = ((reg & BANK_MASK) >> BANK_SHIFT);\r\nu8 cmd = unbanked_cmd;\r\nstruct spi_message m;\r\nstruct spi_transfer t[3] = { { .tx_buf = &cmd, .len = sizeof(cmd), },\r\n{ .tx_buf = &reg, .len = sizeof(reg), },\r\n{ .tx_buf = val, .len = len }, };\r\nif (reg < 0x80) {\r\nint ret = 0;\r\ncmd = banked_code | banked_reg;\r\nif ((banked_reg < 0x16) && (ctx->bank != bank))\r\nret = encx24j600_switch_bank(ctx, bank);\r\nif (unlikely(ret))\r\nreturn ret;\r\n} else {\r\nswitch (reg) {\r\ncase EGPRDPT:\r\ncmd = WGPRDPT; break;\r\ncase EGPWRPT:\r\ncmd = WGPWRPT; break;\r\ncase ERXRDPT:\r\ncmd = WRXRDPT; break;\r\ncase ERXWRPT:\r\ncmd = WRXWRPT; break;\r\ncase EUDARDPT:\r\ncmd = WUDARDPT; break;\r\ncase EUDAWRPT:\r\ncmd = WUDAWRPT; break;\r\ncase EGPDATA:\r\ncase ERXDATA:\r\ncase EUDADATA:\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nspi_message_init(&m);\r\nspi_message_add_tail(&t[0], &m);\r\nif (cmd == unbanked_cmd) {\r\nt[1].tx_buf = &reg;\r\nspi_message_add_tail(&t[1], &m);\r\n}\r\nspi_message_add_tail(&t[2], &m);\r\nreturn spi_sync(ctx->spi, &m);\r\n}\r\nstatic int regmap_encx24j600_sfr_write(void *context, u8 reg, u8 *val,\r\nsize_t len)\r\n{\r\nstruct encx24j600_context *ctx = context;\r\nreturn regmap_encx24j600_sfr_update(ctx, reg, val, len, WCRU, WCRCODE);\r\n}\r\nstatic int regmap_encx24j600_sfr_set_bits(struct encx24j600_context *ctx,\r\nu8 reg, u8 val)\r\n{\r\nreturn regmap_encx24j600_sfr_update(ctx, reg, &val, 1, BFSU, BFSCODE);\r\n}\r\nstatic int regmap_encx24j600_sfr_clr_bits(struct encx24j600_context *ctx,\r\nu8 reg, u8 val)\r\n{\r\nreturn regmap_encx24j600_sfr_update(ctx, reg, &val, 1, BFCU, BFCCODE);\r\n}\r\nstatic int regmap_encx24j600_reg_update_bits(void *context, unsigned int reg,\r\nunsigned int mask,\r\nunsigned int val)\r\n{\r\nstruct encx24j600_context *ctx = context;\r\nint ret = 0;\r\nunsigned int set_mask = mask & val;\r\nunsigned int clr_mask = mask & ~val;\r\nif ((reg >= 0x40 && reg < 0x6c) || reg >= 0x80)\r\nreturn -EINVAL;\r\nif (set_mask & 0xff)\r\nret = regmap_encx24j600_sfr_set_bits(ctx, reg, set_mask);\r\nset_mask = (set_mask & 0xff00) >> 8;\r\nif ((set_mask & 0xff) && (ret == 0))\r\nret = regmap_encx24j600_sfr_set_bits(ctx, reg + 1, set_mask);\r\nif ((clr_mask & 0xff) && (ret == 0))\r\nret = regmap_encx24j600_sfr_clr_bits(ctx, reg, clr_mask);\r\nclr_mask = (clr_mask & 0xff00) >> 8;\r\nif ((clr_mask & 0xff) && (ret == 0))\r\nret = regmap_encx24j600_sfr_clr_bits(ctx, reg + 1, clr_mask);\r\nreturn ret;\r\n}\r\nint regmap_encx24j600_spi_write(void *context, u8 reg, const u8 *data,\r\nsize_t count)\r\n{\r\nstruct encx24j600_context *ctx = context;\r\nif (reg < 0xc0)\r\nreturn encx24j600_cmdn(ctx, reg, data, count);\r\nreturn spi_write(ctx->spi, &reg, 1);\r\n}\r\nint regmap_encx24j600_spi_read(void *context, u8 reg, u8 *data, size_t count)\r\n{\r\nstruct encx24j600_context *ctx = context;\r\nif (reg == RBSEL && count > 1)\r\ncount = 1;\r\nreturn spi_write_then_read(ctx->spi, &reg, sizeof(reg), data, count);\r\n}\r\nstatic int regmap_encx24j600_write(void *context, const void *data,\r\nsize_t len)\r\n{\r\nu8 *dout = (u8 *)data;\r\nu8 reg = dout[0];\r\n++dout;\r\n--len;\r\nif (reg > 0xa0)\r\nreturn regmap_encx24j600_spi_write(context, reg, dout, len);\r\nif (len > 2)\r\nreturn -EINVAL;\r\nreturn regmap_encx24j600_sfr_write(context, reg, dout, len);\r\n}\r\nstatic int regmap_encx24j600_read(void *context,\r\nconst void *reg_buf, size_t reg_size,\r\nvoid *val, size_t val_size)\r\n{\r\nu8 reg = *(const u8 *)reg_buf;\r\nif (reg_size != 1) {\r\npr_err("%s: reg=%02x reg_size=%zu\n", __func__, reg, reg_size);\r\nreturn -EINVAL;\r\n}\r\nif (reg > 0xa0)\r\nreturn regmap_encx24j600_spi_read(context, reg, val, val_size);\r\nif (val_size > 2) {\r\npr_err("%s: reg=%02x val_size=%zu\n", __func__, reg, val_size);\r\nreturn -EINVAL;\r\n}\r\nreturn regmap_encx24j600_sfr_read(context, reg, val, val_size);\r\n}\r\nstatic bool encx24j600_regmap_readable(struct device *dev, unsigned int reg)\r\n{\r\nif ((reg < 0x36) ||\r\n((reg >= 0x40) && (reg < 0x4c)) ||\r\n((reg >= 0x52) && (reg < 0x56)) ||\r\n((reg >= 0x60) && (reg < 0x66)) ||\r\n((reg >= 0x68) && (reg < 0x80)) ||\r\n((reg >= 0x86) && (reg < 0x92)) ||\r\n(reg == 0xc8))\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic bool encx24j600_regmap_writeable(struct device *dev, unsigned int reg)\r\n{\r\nif ((reg < 0x12) ||\r\n((reg >= 0x14) && (reg < 0x1a)) ||\r\n((reg >= 0x1c) && (reg < 0x36)) ||\r\n((reg >= 0x40) && (reg < 0x4c)) ||\r\n((reg >= 0x52) && (reg < 0x56)) ||\r\n((reg >= 0x60) && (reg < 0x68)) ||\r\n((reg >= 0x6c) && (reg < 0x80)) ||\r\n((reg >= 0x86) && (reg < 0x92)) ||\r\n((reg >= 0xc0) && (reg < 0xc8)) ||\r\n((reg >= 0xca) && (reg < 0xf0)))\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic bool encx24j600_regmap_volatile(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase ERXHEAD:\r\ncase EDMACS:\r\ncase ETXSTAT:\r\ncase ETXWIRE:\r\ncase ECON1:\r\ncase ECON2:\r\ncase ESTAT:\r\ncase EIR:\r\ncase MIRD:\r\ncase MISTAT:\r\nreturn true;\r\ndefault:\r\nbreak;\r\n}\r\nreturn false;\r\n}\r\nstatic bool encx24j600_regmap_precious(struct device *dev, unsigned int reg)\r\n{\r\nif (((reg >= 0xc0) && (reg < 0xc8)) ||\r\n((reg >= 0xca) && (reg < 0xf0)))\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic int regmap_encx24j600_phy_reg_read(void *context, unsigned int reg,\r\nunsigned int *val)\r\n{\r\nstruct encx24j600_context *ctx = context;\r\nint ret;\r\nunsigned int mistat;\r\nreg = MIREGADR_VAL | (reg & PHREG_MASK);\r\nret = regmap_write(ctx->regmap, MIREGADR, reg);\r\nif (unlikely(ret))\r\ngoto err_out;\r\nret = regmap_write(ctx->regmap, MICMD, MIIRD);\r\nif (unlikely(ret))\r\ngoto err_out;\r\nusleep_range(26, 100);\r\nwhile ((ret = regmap_read(ctx->regmap, MISTAT, &mistat) != 0) &&\r\n(mistat & BUSY))\r\ncpu_relax();\r\nif (unlikely(ret))\r\ngoto err_out;\r\nret = regmap_write(ctx->regmap, MICMD, 0);\r\nif (unlikely(ret))\r\ngoto err_out;\r\nret = regmap_read(ctx->regmap, MIRD, val);\r\nerr_out:\r\nif (ret)\r\npr_err("%s: error %d reading reg %02x\n", __func__, ret,\r\nreg & PHREG_MASK);\r\nreturn ret;\r\n}\r\nstatic int regmap_encx24j600_phy_reg_write(void *context, unsigned int reg,\r\nunsigned int val)\r\n{\r\nstruct encx24j600_context *ctx = context;\r\nint ret;\r\nunsigned int mistat;\r\nreg = MIREGADR_VAL | (reg & PHREG_MASK);\r\nret = regmap_write(ctx->regmap, MIREGADR, reg);\r\nif (unlikely(ret))\r\ngoto err_out;\r\nret = regmap_write(ctx->regmap, MIWR, val);\r\nif (unlikely(ret))\r\ngoto err_out;\r\nusleep_range(26, 100);\r\nwhile ((ret = regmap_read(ctx->regmap, MISTAT, &mistat) != 0) &&\r\n(mistat & BUSY))\r\ncpu_relax();\r\nerr_out:\r\nif (ret)\r\npr_err("%s: error %d writing reg %02x=%04x\n", __func__, ret,\r\nreg & PHREG_MASK, val);\r\nreturn ret;\r\n}\r\nstatic bool encx24j600_phymap_readable(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase PHCON1:\r\ncase PHSTAT1:\r\ncase PHANA:\r\ncase PHANLPA:\r\ncase PHANE:\r\ncase PHCON2:\r\ncase PHSTAT2:\r\ncase PHSTAT3:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool encx24j600_phymap_writeable(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase PHCON1:\r\ncase PHCON2:\r\ncase PHANA:\r\nreturn true;\r\ncase PHSTAT1:\r\ncase PHSTAT2:\r\ncase PHSTAT3:\r\ncase PHANLPA:\r\ncase PHANE:\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool encx24j600_phymap_volatile(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase PHSTAT1:\r\ncase PHSTAT2:\r\ncase PHSTAT3:\r\ncase PHANLPA:\r\ncase PHANE:\r\ncase PHCON2:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nvoid devm_regmap_init_encx24j600(struct device *dev,\r\nstruct encx24j600_context *ctx)\r\n{\r\nmutex_init(&ctx->mutex);\r\nregcfg.lock_arg = ctx;\r\nctx->regmap = devm_regmap_init(dev, &regmap_encx24j600, ctx, &regcfg);\r\nctx->phymap = devm_regmap_init(dev, &phymap_encx24j600, ctx, &phycfg);\r\n}
