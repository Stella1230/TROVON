wait_queue_head_t *bit_waitqueue(void *word, int bit)\r\n{\r\nconst int shift = BITS_PER_LONG == 32 ? 5 : 6;\r\nunsigned long val = (unsigned long)word << shift | bit;\r\nreturn bit_wait_table + hash_long(val, WAIT_TABLE_BITS);\r\n}\r\nint wake_bit_function(struct wait_queue_entry *wq_entry, unsigned mode, int sync, void *arg)\r\n{\r\nstruct wait_bit_key *key = arg;\r\nstruct wait_bit_queue_entry *wait_bit = container_of(wq_entry, struct wait_bit_queue_entry, wq_entry);\r\nif (wait_bit->key.flags != key->flags ||\r\nwait_bit->key.bit_nr != key->bit_nr ||\r\ntest_bit(key->bit_nr, key->flags))\r\nreturn 0;\r\nelse\r\nreturn autoremove_wake_function(wq_entry, mode, sync, key);\r\n}\r\nint __sched\r\n__wait_on_bit(struct wait_queue_head *wq_head, struct wait_bit_queue_entry *wbq_entry,\r\nwait_bit_action_f *action, unsigned mode)\r\n{\r\nint ret = 0;\r\ndo {\r\nprepare_to_wait(wq_head, &wbq_entry->wq_entry, mode);\r\nif (test_bit(wbq_entry->key.bit_nr, wbq_entry->key.flags))\r\nret = (*action)(&wbq_entry->key, mode);\r\n} while (test_bit(wbq_entry->key.bit_nr, wbq_entry->key.flags) && !ret);\r\nfinish_wait(wq_head, &wbq_entry->wq_entry);\r\nreturn ret;\r\n}\r\nint __sched out_of_line_wait_on_bit(void *word, int bit,\r\nwait_bit_action_f *action, unsigned mode)\r\n{\r\nstruct wait_queue_head *wq_head = bit_waitqueue(word, bit);\r\nDEFINE_WAIT_BIT(wq_entry, word, bit);\r\nreturn __wait_on_bit(wq_head, &wq_entry, action, mode);\r\n}\r\nint __sched out_of_line_wait_on_bit_timeout(\r\nvoid *word, int bit, wait_bit_action_f *action,\r\nunsigned mode, unsigned long timeout)\r\n{\r\nstruct wait_queue_head *wq_head = bit_waitqueue(word, bit);\r\nDEFINE_WAIT_BIT(wq_entry, word, bit);\r\nwq_entry.key.timeout = jiffies + timeout;\r\nreturn __wait_on_bit(wq_head, &wq_entry, action, mode);\r\n}\r\nint __sched\r\n__wait_on_bit_lock(struct wait_queue_head *wq_head, struct wait_bit_queue_entry *wbq_entry,\r\nwait_bit_action_f *action, unsigned mode)\r\n{\r\nint ret = 0;\r\nfor (;;) {\r\nprepare_to_wait_exclusive(wq_head, &wbq_entry->wq_entry, mode);\r\nif (test_bit(wbq_entry->key.bit_nr, wbq_entry->key.flags)) {\r\nret = action(&wbq_entry->key, mode);\r\nif (ret)\r\nfinish_wait(wq_head, &wbq_entry->wq_entry);\r\n}\r\nif (!test_and_set_bit(wbq_entry->key.bit_nr, wbq_entry->key.flags)) {\r\nif (!ret)\r\nfinish_wait(wq_head, &wbq_entry->wq_entry);\r\nreturn 0;\r\n} else if (ret) {\r\nreturn ret;\r\n}\r\n}\r\n}\r\nint __sched out_of_line_wait_on_bit_lock(void *word, int bit,\r\nwait_bit_action_f *action, unsigned mode)\r\n{\r\nstruct wait_queue_head *wq_head = bit_waitqueue(word, bit);\r\nDEFINE_WAIT_BIT(wq_entry, word, bit);\r\nreturn __wait_on_bit_lock(wq_head, &wq_entry, action, mode);\r\n}\r\nvoid __wake_up_bit(struct wait_queue_head *wq_head, void *word, int bit)\r\n{\r\nstruct wait_bit_key key = __WAIT_BIT_KEY_INITIALIZER(word, bit);\r\nif (waitqueue_active(wq_head))\r\n__wake_up(wq_head, TASK_NORMAL, 1, &key);\r\n}\r\nvoid wake_up_bit(void *word, int bit)\r\n{\r\n__wake_up_bit(bit_waitqueue(word, bit), word, bit);\r\n}\r\nstatic inline wait_queue_head_t *atomic_t_waitqueue(atomic_t *p)\r\n{\r\nif (BITS_PER_LONG == 64) {\r\nunsigned long q = (unsigned long)p;\r\nreturn bit_waitqueue((void *)(q & ~1), q & 1);\r\n}\r\nreturn bit_waitqueue(p, 0);\r\n}\r\nstatic int wake_atomic_t_function(struct wait_queue_entry *wq_entry, unsigned mode, int sync,\r\nvoid *arg)\r\n{\r\nstruct wait_bit_key *key = arg;\r\nstruct wait_bit_queue_entry *wait_bit = container_of(wq_entry, struct wait_bit_queue_entry, wq_entry);\r\natomic_t *val = key->flags;\r\nif (wait_bit->key.flags != key->flags ||\r\nwait_bit->key.bit_nr != key->bit_nr ||\r\natomic_read(val) != 0)\r\nreturn 0;\r\nreturn autoremove_wake_function(wq_entry, mode, sync, key);\r\n}\r\nstatic __sched\r\nint __wait_on_atomic_t(struct wait_queue_head *wq_head, struct wait_bit_queue_entry *wbq_entry,\r\nint (*action)(atomic_t *), unsigned mode)\r\n{\r\natomic_t *val;\r\nint ret = 0;\r\ndo {\r\nprepare_to_wait(wq_head, &wbq_entry->wq_entry, mode);\r\nval = wbq_entry->key.flags;\r\nif (atomic_read(val) == 0)\r\nbreak;\r\nret = (*action)(val);\r\n} while (!ret && atomic_read(val) != 0);\r\nfinish_wait(wq_head, &wbq_entry->wq_entry);\r\nreturn ret;\r\n}\r\n__sched int out_of_line_wait_on_atomic_t(atomic_t *p, int (*action)(atomic_t *),\r\nunsigned mode)\r\n{\r\nstruct wait_queue_head *wq_head = atomic_t_waitqueue(p);\r\nDEFINE_WAIT_ATOMIC_T(wq_entry, p);\r\nreturn __wait_on_atomic_t(wq_head, &wq_entry, action, mode);\r\n}\r\nvoid wake_up_atomic_t(atomic_t *p)\r\n{\r\n__wake_up_bit(atomic_t_waitqueue(p), p, WAIT_ATOMIC_T_BIT_NR);\r\n}\r\n__sched int bit_wait(struct wait_bit_key *word, int mode)\r\n{\r\nschedule();\r\nif (signal_pending_state(mode, current))\r\nreturn -EINTR;\r\nreturn 0;\r\n}\r\n__sched int bit_wait_io(struct wait_bit_key *word, int mode)\r\n{\r\nio_schedule();\r\nif (signal_pending_state(mode, current))\r\nreturn -EINTR;\r\nreturn 0;\r\n}\r\n__sched int bit_wait_timeout(struct wait_bit_key *word, int mode)\r\n{\r\nunsigned long now = READ_ONCE(jiffies);\r\nif (time_after_eq(now, word->timeout))\r\nreturn -EAGAIN;\r\nschedule_timeout(word->timeout - now);\r\nif (signal_pending_state(mode, current))\r\nreturn -EINTR;\r\nreturn 0;\r\n}\r\n__sched int bit_wait_io_timeout(struct wait_bit_key *word, int mode)\r\n{\r\nunsigned long now = READ_ONCE(jiffies);\r\nif (time_after_eq(now, word->timeout))\r\nreturn -EAGAIN;\r\nio_schedule_timeout(word->timeout - now);\r\nif (signal_pending_state(mode, current))\r\nreturn -EINTR;\r\nreturn 0;\r\n}\r\nvoid __init wait_bit_init(void)\r\n{\r\nint i;\r\nfor (i = 0; i < WAIT_TABLE_SIZE; i++)\r\ninit_waitqueue_head(bit_wait_table + i);\r\n}
