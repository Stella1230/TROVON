u32 dw_readl(struct dw_i2c_dev *dev, int offset)\r\n{\r\nu32 value;\r\nif (dev->flags & ACCESS_16BIT)\r\nvalue = readw_relaxed(dev->base + offset) |\r\n(readw_relaxed(dev->base + offset + 2) << 16);\r\nelse\r\nvalue = readl_relaxed(dev->base + offset);\r\nif (dev->flags & ACCESS_SWAP)\r\nreturn swab32(value);\r\nelse\r\nreturn value;\r\n}\r\nvoid dw_writel(struct dw_i2c_dev *dev, u32 b, int offset)\r\n{\r\nif (dev->flags & ACCESS_SWAP)\r\nb = swab32(b);\r\nif (dev->flags & ACCESS_16BIT) {\r\nwritew_relaxed((u16)b, dev->base + offset);\r\nwritew_relaxed((u16)(b >> 16), dev->base + offset + 2);\r\n} else {\r\nwritel_relaxed(b, dev->base + offset);\r\n}\r\n}\r\nu32 i2c_dw_scl_hcnt(u32 ic_clk, u32 tSYMBOL, u32 tf, int cond, int offset)\r\n{\r\nif (cond)\r\nreturn (ic_clk * tSYMBOL + 500000) / 1000000 - 8 + offset;\r\nelse\r\nreturn (ic_clk * (tSYMBOL + tf) + 500000) / 1000000\r\n- 3 + offset;\r\n}\r\nu32 i2c_dw_scl_lcnt(u32 ic_clk, u32 tLOW, u32 tf, int offset)\r\n{\r\nreturn ((ic_clk * (tLOW + tf) + 500000) / 1000000) - 1 + offset;\r\n}\r\nvoid __i2c_dw_enable(struct dw_i2c_dev *dev, bool enable)\r\n{\r\ndw_writel(dev, enable, DW_IC_ENABLE);\r\n}\r\nvoid __i2c_dw_enable_and_wait(struct dw_i2c_dev *dev, bool enable)\r\n{\r\nint timeout = 100;\r\ndo {\r\n__i2c_dw_enable(dev, enable);\r\nif ((dw_readl(dev, DW_IC_ENABLE_STATUS) & 1) == enable)\r\nreturn;\r\nusleep_range(25, 250);\r\n} while (timeout--);\r\ndev_warn(dev->dev, "timeout in %sabling adapter\n",\r\nenable ? "en" : "dis");\r\n}\r\nunsigned long i2c_dw_clk_rate(struct dw_i2c_dev *dev)\r\n{\r\nif (WARN_ON_ONCE(!dev->get_clk_rate_khz))\r\nreturn 0;\r\nreturn dev->get_clk_rate_khz(dev);\r\n}\r\nint i2c_dw_acquire_lock(struct dw_i2c_dev *dev)\r\n{\r\nint ret;\r\nif (!dev->acquire_lock)\r\nreturn 0;\r\nret = dev->acquire_lock(dev);\r\nif (!ret)\r\nreturn 0;\r\ndev_err(dev->dev, "couldn't acquire bus ownership\n");\r\nreturn ret;\r\n}\r\nvoid i2c_dw_release_lock(struct dw_i2c_dev *dev)\r\n{\r\nif (dev->release_lock)\r\ndev->release_lock(dev);\r\n}\r\nint i2c_dw_wait_bus_not_busy(struct dw_i2c_dev *dev)\r\n{\r\nint timeout = TIMEOUT;\r\nwhile (dw_readl(dev, DW_IC_STATUS) & DW_IC_STATUS_ACTIVITY) {\r\nif (timeout <= 0) {\r\ndev_warn(dev->dev, "timeout waiting for bus ready\n");\r\nreturn -ETIMEDOUT;\r\n}\r\ntimeout--;\r\nusleep_range(1000, 1100);\r\n}\r\nreturn 0;\r\n}\r\nint i2c_dw_handle_tx_abort(struct dw_i2c_dev *dev)\r\n{\r\nunsigned long abort_source = dev->abort_source;\r\nint i;\r\nif (abort_source & DW_IC_TX_ABRT_NOACK) {\r\nfor_each_set_bit(i, &abort_source, ARRAY_SIZE(abort_sources))\r\ndev_dbg(dev->dev,\r\n"%s: %s\n", __func__, abort_sources[i]);\r\nreturn -EREMOTEIO;\r\n}\r\nfor_each_set_bit(i, &abort_source, ARRAY_SIZE(abort_sources))\r\ndev_err(dev->dev, "%s: %s\n", __func__, abort_sources[i]);\r\nif (abort_source & DW_IC_TX_ARB_LOST)\r\nreturn -EAGAIN;\r\nelse if (abort_source & DW_IC_TX_ABRT_GCALL_READ)\r\nreturn -EINVAL;\r\nelse\r\nreturn -EIO;\r\n}\r\nu32 i2c_dw_func(struct i2c_adapter *adap)\r\n{\r\nstruct dw_i2c_dev *dev = i2c_get_adapdata(adap);\r\nreturn dev->functionality;\r\n}\r\nvoid i2c_dw_disable(struct dw_i2c_dev *dev)\r\n{\r\n__i2c_dw_enable_and_wait(dev, false);\r\ndw_writel(dev, 0, DW_IC_INTR_MASK);\r\ndw_readl(dev, DW_IC_CLR_INTR);\r\n}\r\nvoid i2c_dw_disable_int(struct dw_i2c_dev *dev)\r\n{\r\ndw_writel(dev, 0, DW_IC_INTR_MASK);\r\n}\r\nu32 i2c_dw_read_comp_param(struct dw_i2c_dev *dev)\r\n{\r\nreturn dw_readl(dev, DW_IC_COMP_PARAM_1);\r\n}
