static int tps65132_regulator_enable(struct regulator_dev *rdev)\r\n{\r\nstruct tps65132_regulator *tps = rdev_get_drvdata(rdev);\r\nint id = rdev_get_id(rdev);\r\nstruct tps65132_reg_pdata *rpdata = &tps->reg_pdata[id];\r\nint ret;\r\nif (!IS_ERR(rpdata->en_gpiod)) {\r\ngpiod_set_value_cansleep(rpdata->en_gpiod, 1);\r\nrpdata->ena_gpio_state = 1;\r\n}\r\nif (rdev->constraints->active_discharge ==\r\nREGULATOR_ACTIVE_DISCHARGE_DISABLE) {\r\nret = regulator_set_active_discharge_regmap(rdev, false);\r\nif (ret < 0) {\r\ndev_err(tps->dev, "Failed to disable active discharge: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int tps65132_regulator_disable(struct regulator_dev *rdev)\r\n{\r\nstruct tps65132_regulator *tps = rdev_get_drvdata(rdev);\r\nint id = rdev_get_id(rdev);\r\nstruct tps65132_reg_pdata *rpdata = &tps->reg_pdata[id];\r\nif (!IS_ERR(rpdata->en_gpiod)) {\r\ngpiod_set_value_cansleep(rpdata->en_gpiod, 0);\r\nrpdata->ena_gpio_state = 0;\r\n}\r\nif (!IS_ERR(rpdata->act_dis_gpiod)) {\r\ngpiod_set_value_cansleep(rpdata->act_dis_gpiod, 1);\r\nusleep_range(rpdata->act_dis_time_us, rpdata->act_dis_time_us +\r\nTPS65132_ACT_DIS_TIME_SLACK);\r\ngpiod_set_value_cansleep(rpdata->act_dis_gpiod, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int tps65132_regulator_is_enabled(struct regulator_dev *rdev)\r\n{\r\nstruct tps65132_regulator *tps = rdev_get_drvdata(rdev);\r\nint id = rdev_get_id(rdev);\r\nstruct tps65132_reg_pdata *rpdata = &tps->reg_pdata[id];\r\nif (!IS_ERR(rpdata->en_gpiod))\r\nreturn rpdata->ena_gpio_state;\r\nreturn 1;\r\n}\r\nstatic int tps65132_of_parse_cb(struct device_node *np,\r\nconst struct regulator_desc *desc,\r\nstruct regulator_config *config)\r\n{\r\nstruct tps65132_regulator *tps = config->driver_data;\r\nstruct tps65132_reg_pdata *rpdata = &tps->reg_pdata[desc->id];\r\nint ret;\r\nrpdata->en_gpiod = devm_fwnode_get_index_gpiod_from_child(tps->dev,\r\n"enable", 0, &np->fwnode, 0, "enable");\r\nif (IS_ERR(rpdata->en_gpiod)) {\r\nret = PTR_ERR(rpdata->en_gpiod);\r\nif (ret == -EPROBE_DEFER)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nrpdata->act_dis_gpiod = devm_fwnode_get_index_gpiod_from_child(\r\ntps->dev, "active-discharge", 0,\r\n&np->fwnode, 0, "active-discharge");\r\nif (IS_ERR(rpdata->act_dis_gpiod)) {\r\nret = PTR_ERR(rpdata->act_dis_gpiod);\r\nif (ret == -EPROBE_DEFER)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nret = of_property_read_u32(np, "ti,active-discharge-time-us",\r\n&rpdata->act_dis_time_us);\r\nif (ret < 0) {\r\ndev_err(tps->dev, "Failed to read active discharge time:%d\n",\r\nret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tps65132_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *client_id)\r\n{\r\nstruct device *dev = &client->dev;\r\nstruct tps65132_regulator *tps;\r\nstruct regulator_config config = { };\r\nint id;\r\nint ret;\r\ntps = devm_kzalloc(dev, sizeof(*tps), GFP_KERNEL);\r\nif (!tps)\r\nreturn -ENOMEM;\r\ntps->rmap = devm_regmap_init_i2c(client, &tps65132_regmap_config);\r\nif (IS_ERR(tps->rmap)) {\r\nret = PTR_ERR(tps->rmap);\r\ndev_err(dev, "regmap init failed: %d\n", ret);\r\nreturn ret;\r\n}\r\ni2c_set_clientdata(client, tps);\r\ntps->dev = dev;\r\nfor (id = 0; id < TPS65132_MAX_REGULATORS; ++id) {\r\ntps->rdesc[id] = &tps_regs_desc[id];\r\nconfig.regmap = tps->rmap;\r\nconfig.dev = dev;\r\nconfig.driver_data = tps;\r\ntps->rdev[id] = devm_regulator_register(dev,\r\ntps->rdesc[id], &config);\r\nif (IS_ERR(tps->rdev[id])) {\r\nret = PTR_ERR(tps->rdev[id]);\r\ndev_err(dev, "regulator %s register failed: %d\n",\r\ntps->rdesc[id]->name, ret);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}
