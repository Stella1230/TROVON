static void mvebu_armada_pm_enter(void __iomem *sdram_reg, u32 srcmd)\r\n{\r\nu32 reg, ackcmd;\r\nint i;\r\nreg = readl(gpio_ctrl);\r\nfor (i = 0; i < ARMADA_PIC_NR_GPIOS; i++)\r\nreg &= ~BIT(pic_raw_gpios[i]);\r\nreg |= BIT(pic_raw_gpios[0]);\r\nwritel(reg, gpio_ctrl);\r\nackcmd = readl(gpio_ctrl);\r\nfor (i = 0; i < ARMADA_PIC_NR_GPIOS; i++)\r\nackcmd |= BIT(pic_raw_gpios[i]);\r\nsrcmd = cpu_to_le32(srcmd);\r\nackcmd = cpu_to_le32(ackcmd);\r\nmdelay(3000);\r\nasm volatile (\r\n".balign 32\n\t"\r\n"str %[srcmd], [%[sdram_reg]]\n\t"\r\n"mov r1, #50\n\t"\r\n"1: subs r1, r1, #1\n\t"\r\n"bne 1b\n\t"\r\n"str %[ackcmd], [%[gpio_ctrl]]\n\t"\r\n"b .\n\t"\r\n: : [srcmd] "r" (srcmd), [sdram_reg] "r" (sdram_reg),\r\n[ackcmd] "r" (ackcmd), [gpio_ctrl] "r" (gpio_ctrl) : "r1");\r\n}\r\nstatic int __init mvebu_armada_pm_init(void)\r\n{\r\nstruct device_node *np;\r\nstruct device_node *gpio_ctrl_np;\r\nint ret = 0, i;\r\nif (!of_machine_is_compatible("marvell,axp-gp"))\r\nreturn -ENODEV;\r\nnp = of_find_node_by_name(NULL, "pm_pic");\r\nif (!np)\r\nreturn -ENODEV;\r\nfor (i = 0; i < ARMADA_PIC_NR_GPIOS; i++) {\r\nchar *name;\r\nstruct of_phandle_args args;\r\npic_gpios[i] = of_get_named_gpio(np, "ctrl-gpios", i);\r\nif (pic_gpios[i] < 0) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nname = kasprintf(GFP_KERNEL, "pic-pin%d", i);\r\nif (!name) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nret = gpio_request(pic_gpios[i], name);\r\nif (ret < 0) {\r\nkfree(name);\r\ngoto out;\r\n}\r\nret = gpio_direction_output(pic_gpios[i], 0);\r\nif (ret < 0) {\r\ngpio_free(pic_gpios[i]);\r\nkfree(name);\r\ngoto out;\r\n}\r\nret = of_parse_phandle_with_fixed_args(np, "ctrl-gpios", 2,\r\ni, &args);\r\nif (ret < 0) {\r\ngpio_free(pic_gpios[i]);\r\nkfree(name);\r\ngoto out;\r\n}\r\ngpio_ctrl_np = args.np;\r\npic_raw_gpios[i] = args.args[0];\r\n}\r\ngpio_ctrl = of_iomap(gpio_ctrl_np, 0);\r\nif (!gpio_ctrl)\r\nreturn -ENOMEM;\r\nmvebu_pm_suspend_init(mvebu_armada_pm_enter);\r\nout:\r\nof_node_put(np);\r\nreturn ret;\r\n}
