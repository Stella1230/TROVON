static void imx7d_adc_feature_config(struct imx7d_adc *info)\r\n{\r\ninfo->adc_feature.clk_pre_div = IMX7D_ADC_ANALOG_CLK_PRE_DIV_4;\r\ninfo->adc_feature.avg_num = IMX7D_ADC_AVERAGE_NUM_32;\r\ninfo->adc_feature.core_time_unit = 1;\r\ninfo->adc_feature.average_en = true;\r\n}\r\nstatic void imx7d_adc_sample_rate_set(struct imx7d_adc *info)\r\n{\r\nstruct imx7d_adc_feature *adc_feature = &info->adc_feature;\r\nstruct imx7d_adc_analogue_core_clk adc_analogure_clk;\r\nu32 i;\r\nu32 tmp_cfg1;\r\nu32 sample_rate = 0;\r\nfor (i = 0; i < 4; i++) {\r\ntmp_cfg1 =\r\nreadl(info->regs + i * IMX7D_EACH_CHANNEL_REG_OFFSET);\r\ntmp_cfg1 &= ~IMX7D_REG_ADC_CH_CFG1_CHANNEL_EN;\r\nwritel(tmp_cfg1,\r\ninfo->regs + i * IMX7D_EACH_CHANNEL_REG_OFFSET);\r\n}\r\nadc_analogure_clk = imx7d_adc_analogue_clk[adc_feature->clk_pre_div];\r\nsample_rate |= adc_analogure_clk.reg_config;\r\ninfo->pre_div_num = adc_analogure_clk.pre_div;\r\nsample_rate |= adc_feature->core_time_unit;\r\nwritel(sample_rate, info->regs + IMX7D_REG_ADC_TIMER_UNIT);\r\n}\r\nstatic void imx7d_adc_hw_init(struct imx7d_adc *info)\r\n{\r\nu32 cfg;\r\ncfg = readl(info->regs + IMX7D_REG_ADC_ADC_CFG);\r\ncfg &= ~(IMX7D_REG_ADC_ADC_CFG_ADC_CLK_DOWN |\r\nIMX7D_REG_ADC_ADC_CFG_ADC_POWER_DOWN);\r\ncfg |= IMX7D_REG_ADC_ADC_CFG_ADC_EN;\r\nwritel(cfg, info->regs + IMX7D_REG_ADC_ADC_CFG);\r\nwritel(IMX7D_REG_ADC_INT_CHANNEL_INT_EN,\r\ninfo->regs + IMX7D_REG_ADC_INT_SIG_EN);\r\nwritel(IMX7D_REG_ADC_INT_CHANNEL_INT_EN,\r\ninfo->regs + IMX7D_REG_ADC_INT_EN);\r\nimx7d_adc_sample_rate_set(info);\r\n}\r\nstatic void imx7d_adc_channel_set(struct imx7d_adc *info)\r\n{\r\nu32 cfg1 = 0;\r\nu32 cfg2;\r\nu32 channel;\r\nchannel = info->channel;\r\ncfg1 |= (IMX7D_REG_ADC_CH_CFG1_CHANNEL_EN |\r\nIMX7D_REG_ADC_CH_CFG1_CHANNEL_SINGLE);\r\nif (info->adc_feature.average_en)\r\ncfg1 |= IMX7D_REG_ADC_CH_CFG1_CHANNEL_AVG_EN;\r\ncfg1 |= IMX7D_REG_ADC_CH_CFG1_CHANNEL_SEL(channel);\r\ncfg2 = readl(info->regs + IMX7D_EACH_CHANNEL_REG_OFFSET * channel +\r\nIMX7D_REG_ADC_CHANNEL_CFG2_BASE);\r\ncfg2 |= imx7d_adc_average_num[info->adc_feature.avg_num];\r\nwritel(cfg2, info->regs + IMX7D_EACH_CHANNEL_REG_OFFSET * channel +\r\nIMX7D_REG_ADC_CHANNEL_CFG2_BASE);\r\nwritel(cfg1, info->regs + IMX7D_EACH_CHANNEL_REG_OFFSET * channel);\r\n}\r\nstatic u32 imx7d_adc_get_sample_rate(struct imx7d_adc *info)\r\n{\r\nu32 input_clk = 24000000;\r\nu32 analogue_core_clk;\r\nu32 core_time_unit = info->adc_feature.core_time_unit;\r\nu32 tmp;\r\nanalogue_core_clk = input_clk / info->pre_div_num;\r\ntmp = (core_time_unit + 1) * 6;\r\nreturn analogue_core_clk / tmp;\r\n}\r\nstatic int imx7d_adc_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val,\r\nint *val2,\r\nlong mask)\r\n{\r\nstruct imx7d_adc *info = iio_priv(indio_dev);\r\nu32 channel;\r\nlong ret;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nmutex_lock(&indio_dev->mlock);\r\nreinit_completion(&info->completion);\r\nchannel = chan->channel & 0x03;\r\ninfo->channel = channel;\r\nimx7d_adc_channel_set(info);\r\nret = wait_for_completion_interruptible_timeout\r\n(&info->completion, IMX7D_ADC_TIMEOUT);\r\nif (ret == 0) {\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn -ETIMEDOUT;\r\n}\r\nif (ret < 0) {\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\n*val = info->value;\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_SCALE:\r\ninfo->vref_uv = regulator_get_voltage(info->vref);\r\n*val = info->vref_uv / 1000;\r\n*val2 = 12;\r\nreturn IIO_VAL_FRACTIONAL_LOG2;\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\n*val = imx7d_adc_get_sample_rate(info);\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int imx7d_adc_read_data(struct imx7d_adc *info)\r\n{\r\nu32 channel;\r\nu32 value;\r\nchannel = info->channel & 0x03;\r\nif (channel < 2)\r\nvalue = readl(info->regs + IMX7D_REG_ADC_CHA_B_CNV_RSLT);\r\nelse\r\nvalue = readl(info->regs + IMX7D_REG_ADC_CHC_D_CNV_RSLT);\r\nif (channel & 0x1)\r\nvalue = (value >> 16) & 0xFFF;\r\nelse\r\nvalue &= 0xFFF;\r\nreturn value;\r\n}\r\nstatic irqreturn_t imx7d_adc_isr(int irq, void *dev_id)\r\n{\r\nstruct imx7d_adc *info = dev_id;\r\nint status;\r\nstatus = readl(info->regs + IMX7D_REG_ADC_INT_STATUS);\r\nif (status & IMX7D_REG_ADC_INT_STATUS_CHANNEL_INT_STATUS) {\r\ninfo->value = imx7d_adc_read_data(info);\r\ncomplete(&info->completion);\r\nstatus &= ~IMX7D_REG_ADC_INT_STATUS_CHANNEL_INT_STATUS;\r\nwritel(status, info->regs + IMX7D_REG_ADC_INT_STATUS);\r\n}\r\nif (status & IMX7D_REG_ADC_INT_STATUS_CHANNEL_CONV_TIME_OUT) {\r\npr_err("%s: ADC got conversion time out interrupt: 0x%08x\n",\r\ndev_name(info->dev), status);\r\nstatus &= ~IMX7D_REG_ADC_INT_STATUS_CHANNEL_CONV_TIME_OUT;\r\nwritel(status, info->regs + IMX7D_REG_ADC_INT_STATUS);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int imx7d_adc_reg_access(struct iio_dev *indio_dev,\r\nunsigned reg, unsigned writeval,\r\nunsigned *readval)\r\n{\r\nstruct imx7d_adc *info = iio_priv(indio_dev);\r\nif (!readval || reg % 4 || reg > IMX7D_REG_ADC_ADC_CFG)\r\nreturn -EINVAL;\r\n*readval = readl(info->regs + reg);\r\nreturn 0;\r\n}\r\nstatic void imx7d_adc_power_down(struct imx7d_adc *info)\r\n{\r\nu32 adc_cfg;\r\nadc_cfg = readl(info->regs + IMX7D_REG_ADC_ADC_CFG);\r\nadc_cfg |= IMX7D_REG_ADC_ADC_CFG_ADC_CLK_DOWN |\r\nIMX7D_REG_ADC_ADC_CFG_ADC_POWER_DOWN;\r\nadc_cfg &= ~IMX7D_REG_ADC_ADC_CFG_ADC_EN;\r\nwritel(adc_cfg, info->regs + IMX7D_REG_ADC_ADC_CFG);\r\n}\r\nstatic int imx7d_adc_probe(struct platform_device *pdev)\r\n{\r\nstruct imx7d_adc *info;\r\nstruct iio_dev *indio_dev;\r\nstruct resource *mem;\r\nint irq;\r\nint ret;\r\nindio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*info));\r\nif (!indio_dev) {\r\ndev_err(&pdev->dev, "Failed allocating iio device\n");\r\nreturn -ENOMEM;\r\n}\r\ninfo = iio_priv(indio_dev);\r\ninfo->dev = &pdev->dev;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ninfo->regs = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(info->regs)) {\r\nret = PTR_ERR(info->regs);\r\ndev_err(&pdev->dev,\r\n"Failed to remap adc memory, err = %d\n", ret);\r\nreturn ret;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "No irq resource?\n");\r\nreturn irq;\r\n}\r\ninfo->clk = devm_clk_get(&pdev->dev, "adc");\r\nif (IS_ERR(info->clk)) {\r\nret = PTR_ERR(info->clk);\r\ndev_err(&pdev->dev, "Failed getting clock, err = %d\n", ret);\r\nreturn ret;\r\n}\r\ninfo->vref = devm_regulator_get(&pdev->dev, "vref");\r\nif (IS_ERR(info->vref)) {\r\nret = PTR_ERR(info->vref);\r\ndev_err(&pdev->dev,\r\n"Failed getting reference voltage, err = %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regulator_enable(info->vref);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"Can't enable adc reference top voltage, err = %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, indio_dev);\r\ninit_completion(&info->completion);\r\nindio_dev->name = dev_name(&pdev->dev);\r\nindio_dev->dev.parent = &pdev->dev;\r\nindio_dev->info = &imx7d_adc_iio_info;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->channels = imx7d_adc_iio_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(imx7d_adc_iio_channels);\r\nret = clk_prepare_enable(info->clk);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"Could not prepare or enable the clock.\n");\r\ngoto error_adc_clk_enable;\r\n}\r\nret = devm_request_irq(info->dev, irq,\r\nimx7d_adc_isr, 0,\r\ndev_name(&pdev->dev), info);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed requesting irq, irq = %d\n", irq);\r\ngoto error_iio_device_register;\r\n}\r\nimx7d_adc_feature_config(info);\r\nimx7d_adc_hw_init(info);\r\nret = iio_device_register(indio_dev);\r\nif (ret) {\r\nimx7d_adc_power_down(info);\r\ndev_err(&pdev->dev, "Couldn't register the device.\n");\r\ngoto error_iio_device_register;\r\n}\r\nreturn 0;\r\nerror_iio_device_register:\r\nclk_disable_unprepare(info->clk);\r\nerror_adc_clk_enable:\r\nregulator_disable(info->vref);\r\nreturn ret;\r\n}\r\nstatic int imx7d_adc_remove(struct platform_device *pdev)\r\n{\r\nstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\r\nstruct imx7d_adc *info = iio_priv(indio_dev);\r\niio_device_unregister(indio_dev);\r\nimx7d_adc_power_down(info);\r\nclk_disable_unprepare(info->clk);\r\nregulator_disable(info->vref);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused imx7d_adc_suspend(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = dev_get_drvdata(dev);\r\nstruct imx7d_adc *info = iio_priv(indio_dev);\r\nimx7d_adc_power_down(info);\r\nclk_disable_unprepare(info->clk);\r\nregulator_disable(info->vref);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused imx7d_adc_resume(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = dev_get_drvdata(dev);\r\nstruct imx7d_adc *info = iio_priv(indio_dev);\r\nint ret;\r\nret = regulator_enable(info->vref);\r\nif (ret) {\r\ndev_err(info->dev,\r\n"Can't enable adc reference top voltage, err = %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(info->clk);\r\nif (ret) {\r\ndev_err(info->dev,\r\n"Could not prepare or enable clock.\n");\r\nregulator_disable(info->vref);\r\nreturn ret;\r\n}\r\nimx7d_adc_hw_init(info);\r\nreturn 0;\r\n}
