static int mct_u232_calculate_baud_rate(struct usb_serial *serial,\r\nspeed_t value, speed_t *result)\r\n{\r\n*result = value;\r\nif (le16_to_cpu(serial->dev->descriptor.idProduct) == MCT_U232_SITECOM_PID\r\n|| le16_to_cpu(serial->dev->descriptor.idProduct) == MCT_U232_BELKIN_F5U109_PID) {\r\nswitch (value) {\r\ncase 300:\r\nreturn 0x01;\r\ncase 600:\r\nreturn 0x02;\r\ncase 1200:\r\nreturn 0x03;\r\ncase 2400:\r\nreturn 0x04;\r\ncase 4800:\r\nreturn 0x06;\r\ncase 9600:\r\nreturn 0x08;\r\ncase 19200:\r\nreturn 0x09;\r\ncase 38400:\r\nreturn 0x0a;\r\ncase 57600:\r\nreturn 0x0b;\r\ncase 115200:\r\nreturn 0x0c;\r\ndefault:\r\n*result = 9600;\r\nreturn 0x08;\r\n}\r\n} else {\r\nswitch (value) {\r\ncase 300: break;\r\ncase 600: break;\r\ncase 1200: break;\r\ncase 2400: break;\r\ncase 4800: break;\r\ncase 9600: break;\r\ncase 19200: break;\r\ncase 38400: break;\r\ncase 57600: break;\r\ncase 115200: break;\r\ndefault:\r\nvalue = 9600;\r\n*result = 9600;\r\n}\r\nreturn 115200/value;\r\n}\r\n}\r\nstatic int mct_u232_set_baud_rate(struct tty_struct *tty,\r\nstruct usb_serial *serial, struct usb_serial_port *port, speed_t value)\r\n{\r\nunsigned int divisor;\r\nint rc;\r\nunsigned char *buf;\r\nunsigned char cts_enable_byte = 0;\r\nspeed_t speed;\r\nbuf = kmalloc(MCT_U232_MAX_SIZE, GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\ndivisor = mct_u232_calculate_baud_rate(serial, value, &speed);\r\nput_unaligned_le32(divisor, buf);\r\nrc = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\nMCT_U232_SET_BAUD_RATE_REQUEST,\r\nMCT_U232_SET_REQUEST_TYPE,\r\n0, 0, buf, MCT_U232_SET_BAUD_RATE_SIZE,\r\nWDR_TIMEOUT);\r\nif (rc < 0)\r\ndev_err(&port->dev, "Set BAUD RATE %d failed (error = %d)\n",\r\nvalue, rc);\r\nelse\r\ntty_encode_baud_rate(tty, speed, speed);\r\ndev_dbg(&port->dev, "set_baud_rate: value: 0x%x, divisor: 0x%x\n", value, divisor);\r\nbuf[0] = 0;\r\nrc = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\nMCT_U232_SET_UNKNOWN1_REQUEST,\r\nMCT_U232_SET_REQUEST_TYPE,\r\n0, 0, buf, MCT_U232_SET_UNKNOWN1_SIZE,\r\nWDR_TIMEOUT);\r\nif (rc < 0)\r\ndev_err(&port->dev, "Sending USB device request code %d "\r\n"failed (error = %d)\n", MCT_U232_SET_UNKNOWN1_REQUEST,\r\nrc);\r\nif (port && C_CRTSCTS(tty))\r\ncts_enable_byte = 1;\r\ndev_dbg(&port->dev, "set_baud_rate: send second control message, data = %02X\n",\r\ncts_enable_byte);\r\nbuf[0] = cts_enable_byte;\r\nrc = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\nMCT_U232_SET_CTS_REQUEST,\r\nMCT_U232_SET_REQUEST_TYPE,\r\n0, 0, buf, MCT_U232_SET_CTS_SIZE,\r\nWDR_TIMEOUT);\r\nif (rc < 0)\r\ndev_err(&port->dev, "Sending USB device request code %d "\r\n"failed (error = %d)\n", MCT_U232_SET_CTS_REQUEST, rc);\r\nkfree(buf);\r\nreturn rc;\r\n}\r\nstatic int mct_u232_set_line_ctrl(struct usb_serial_port *port,\r\nunsigned char lcr)\r\n{\r\nint rc;\r\nunsigned char *buf;\r\nbuf = kmalloc(MCT_U232_MAX_SIZE, GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\nbuf[0] = lcr;\r\nrc = usb_control_msg(port->serial->dev, usb_sndctrlpipe(port->serial->dev, 0),\r\nMCT_U232_SET_LINE_CTRL_REQUEST,\r\nMCT_U232_SET_REQUEST_TYPE,\r\n0, 0, buf, MCT_U232_SET_LINE_CTRL_SIZE,\r\nWDR_TIMEOUT);\r\nif (rc < 0)\r\ndev_err(&port->dev, "Set LINE CTRL 0x%x failed (error = %d)\n", lcr, rc);\r\ndev_dbg(&port->dev, "set_line_ctrl: 0x%x\n", lcr);\r\nkfree(buf);\r\nreturn rc;\r\n}\r\nstatic int mct_u232_set_modem_ctrl(struct usb_serial_port *port,\r\nunsigned int control_state)\r\n{\r\nint rc;\r\nunsigned char mcr;\r\nunsigned char *buf;\r\nbuf = kmalloc(MCT_U232_MAX_SIZE, GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\nmcr = MCT_U232_MCR_NONE;\r\nif (control_state & TIOCM_DTR)\r\nmcr |= MCT_U232_MCR_DTR;\r\nif (control_state & TIOCM_RTS)\r\nmcr |= MCT_U232_MCR_RTS;\r\nbuf[0] = mcr;\r\nrc = usb_control_msg(port->serial->dev, usb_sndctrlpipe(port->serial->dev, 0),\r\nMCT_U232_SET_MODEM_CTRL_REQUEST,\r\nMCT_U232_SET_REQUEST_TYPE,\r\n0, 0, buf, MCT_U232_SET_MODEM_CTRL_SIZE,\r\nWDR_TIMEOUT);\r\nkfree(buf);\r\ndev_dbg(&port->dev, "set_modem_ctrl: state=0x%x ==> mcr=0x%x\n", control_state, mcr);\r\nif (rc < 0) {\r\ndev_err(&port->dev, "Set MODEM CTRL 0x%x failed (error = %d)\n", mcr, rc);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mct_u232_get_modem_stat(struct usb_serial_port *port,\r\nunsigned char *msr)\r\n{\r\nint rc;\r\nunsigned char *buf;\r\nbuf = kmalloc(MCT_U232_MAX_SIZE, GFP_KERNEL);\r\nif (buf == NULL) {\r\n*msr = 0;\r\nreturn -ENOMEM;\r\n}\r\nrc = usb_control_msg(port->serial->dev, usb_rcvctrlpipe(port->serial->dev, 0),\r\nMCT_U232_GET_MODEM_STAT_REQUEST,\r\nMCT_U232_GET_REQUEST_TYPE,\r\n0, 0, buf, MCT_U232_GET_MODEM_STAT_SIZE,\r\nWDR_TIMEOUT);\r\nif (rc < MCT_U232_GET_MODEM_STAT_SIZE) {\r\ndev_err(&port->dev, "Get MODEM STATus failed (error = %d)\n", rc);\r\nif (rc >= 0)\r\nrc = -EIO;\r\n*msr = 0;\r\n} else {\r\n*msr = buf[0];\r\n}\r\ndev_dbg(&port->dev, "get_modem_stat: 0x%x\n", *msr);\r\nkfree(buf);\r\nreturn rc;\r\n}\r\nstatic void mct_u232_msr_to_icount(struct async_icount *icount,\r\nunsigned char msr)\r\n{\r\nif (msr & MCT_U232_MSR_DDSR)\r\nicount->dsr++;\r\nif (msr & MCT_U232_MSR_DCTS)\r\nicount->cts++;\r\nif (msr & MCT_U232_MSR_DRI)\r\nicount->rng++;\r\nif (msr & MCT_U232_MSR_DCD)\r\nicount->dcd++;\r\n}\r\nstatic void mct_u232_msr_to_state(struct usb_serial_port *port,\r\nunsigned int *control_state, unsigned char msr)\r\n{\r\nif (msr & MCT_U232_MSR_DSR)\r\n*control_state |= TIOCM_DSR;\r\nelse\r\n*control_state &= ~TIOCM_DSR;\r\nif (msr & MCT_U232_MSR_CTS)\r\n*control_state |= TIOCM_CTS;\r\nelse\r\n*control_state &= ~TIOCM_CTS;\r\nif (msr & MCT_U232_MSR_RI)\r\n*control_state |= TIOCM_RI;\r\nelse\r\n*control_state &= ~TIOCM_RI;\r\nif (msr & MCT_U232_MSR_CD)\r\n*control_state |= TIOCM_CD;\r\nelse\r\n*control_state &= ~TIOCM_CD;\r\ndev_dbg(&port->dev, "msr_to_state: msr=0x%x ==> state=0x%x\n", msr, *control_state);\r\n}\r\nstatic int mct_u232_port_probe(struct usb_serial_port *port)\r\n{\r\nstruct usb_serial *serial = port->serial;\r\nstruct mct_u232_private *priv;\r\nif (!serial->port[1] || !serial->port[1]->interrupt_in_urb) {\r\ndev_err(&port->dev, "expected endpoint missing\n");\r\nreturn -ENODEV;\r\n}\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->read_urb = serial->port[1]->interrupt_in_urb;\r\npriv->read_urb->context = port;\r\nspin_lock_init(&priv->lock);\r\nusb_set_serial_port_data(port, priv);\r\nreturn 0;\r\n}\r\nstatic int mct_u232_port_remove(struct usb_serial_port *port)\r\n{\r\nstruct mct_u232_private *priv;\r\npriv = usb_get_serial_port_data(port);\r\nkfree(priv);\r\nreturn 0;\r\n}\r\nstatic int mct_u232_open(struct tty_struct *tty, struct usb_serial_port *port)\r\n{\r\nstruct usb_serial *serial = port->serial;\r\nstruct mct_u232_private *priv = usb_get_serial_port_data(port);\r\nint retval = 0;\r\nunsigned int control_state;\r\nunsigned long flags;\r\nunsigned char last_lcr;\r\nunsigned char last_msr;\r\nif (le16_to_cpu(serial->dev->descriptor.idProduct)\r\n== MCT_U232_SITECOM_PID)\r\nport->bulk_out_size = 16;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (tty && C_BAUD(tty))\r\npriv->control_state = TIOCM_DTR | TIOCM_RTS;\r\nelse\r\npriv->control_state = 0;\r\npriv->last_lcr = (MCT_U232_DATA_BITS_8 |\r\nMCT_U232_PARITY_NONE |\r\nMCT_U232_STOP_BITS_1);\r\ncontrol_state = priv->control_state;\r\nlast_lcr = priv->last_lcr;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nmct_u232_set_modem_ctrl(port, control_state);\r\nmct_u232_set_line_ctrl(port, last_lcr);\r\nmct_u232_get_modem_stat(port, &last_msr);\r\nspin_lock_irqsave(&priv->lock, flags);\r\npriv->last_msr = last_msr;\r\nmct_u232_msr_to_state(port, &priv->control_state, priv->last_msr);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nretval = usb_submit_urb(priv->read_urb, GFP_KERNEL);\r\nif (retval) {\r\ndev_err(&port->dev,\r\n"usb_submit_urb(read) failed pipe 0x%x err %d\n",\r\nport->read_urb->pipe, retval);\r\ngoto error;\r\n}\r\nretval = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);\r\nif (retval) {\r\nusb_kill_urb(priv->read_urb);\r\ndev_err(&port->dev,\r\n"usb_submit_urb(read int) failed pipe 0x%x err %d",\r\nport->interrupt_in_urb->pipe, retval);\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\nreturn retval;\r\n}\r\nstatic void mct_u232_dtr_rts(struct usb_serial_port *port, int on)\r\n{\r\nunsigned int control_state;\r\nstruct mct_u232_private *priv = usb_get_serial_port_data(port);\r\nspin_lock_irq(&priv->lock);\r\nif (on)\r\npriv->control_state |= TIOCM_DTR | TIOCM_RTS;\r\nelse\r\npriv->control_state &= ~(TIOCM_DTR | TIOCM_RTS);\r\ncontrol_state = priv->control_state;\r\nspin_unlock_irq(&priv->lock);\r\nmct_u232_set_modem_ctrl(port, control_state);\r\n}\r\nstatic void mct_u232_close(struct usb_serial_port *port)\r\n{\r\nstruct mct_u232_private *priv = usb_get_serial_port_data(port);\r\nusb_kill_urb(priv->read_urb);\r\nusb_kill_urb(port->interrupt_in_urb);\r\nusb_serial_generic_close(port);\r\n}\r\nstatic void mct_u232_read_int_callback(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nstruct mct_u232_private *priv = usb_get_serial_port_data(port);\r\nunsigned char *data = urb->transfer_buffer;\r\nint retval;\r\nint status = urb->status;\r\nunsigned long flags;\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndev_dbg(&port->dev, "%s - urb shutting down with status: %d\n",\r\n__func__, status);\r\nreturn;\r\ndefault:\r\ndev_dbg(&port->dev, "%s - nonzero urb status received: %d\n",\r\n__func__, status);\r\ngoto exit;\r\n}\r\nusb_serial_debug_data(&port->dev, __func__, urb->actual_length, data);\r\nif (urb->transfer_buffer_length > 2) {\r\nif (urb->actual_length) {\r\ntty_insert_flip_string(&port->port, data,\r\nurb->actual_length);\r\ntty_flip_buffer_push(&port->port);\r\n}\r\ngoto exit;\r\n}\r\nspin_lock_irqsave(&priv->lock, flags);\r\npriv->last_msr = data[MCT_U232_MSR_INDEX];\r\nmct_u232_msr_to_state(port, &priv->control_state, priv->last_msr);\r\nmct_u232_msr_to_icount(&port->icount, priv->last_msr);\r\n#if 0\r\npriv->last_lsr = data[MCT_U232_LSR_INDEX];\r\nif (priv->last_lsr & MCT_U232_LSR_ERR) {\r\ntty = tty_port_tty_get(&port->port);\r\nif (priv->last_lsr & MCT_U232_LSR_OE) {\r\n}\r\nif (priv->last_lsr & MCT_U232_LSR_PE) {\r\n}\r\nif (priv->last_lsr & MCT_U232_LSR_FE) {\r\n}\r\nif (priv->last_lsr & MCT_U232_LSR_BI) {\r\n}\r\ntty_kref_put(tty);\r\n}\r\n#endif\r\nwake_up_interruptible(&port->port.delta_msr_wait);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nexit:\r\nretval = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (retval)\r\ndev_err(&port->dev,\r\n"%s - usb_submit_urb failed with result %d\n",\r\n__func__, retval);\r\n}\r\nstatic void mct_u232_set_termios(struct tty_struct *tty,\r\nstruct usb_serial_port *port,\r\nstruct ktermios *old_termios)\r\n{\r\nstruct usb_serial *serial = port->serial;\r\nstruct mct_u232_private *priv = usb_get_serial_port_data(port);\r\nstruct ktermios *termios = &tty->termios;\r\nunsigned int cflag = termios->c_cflag;\r\nunsigned int old_cflag = old_termios->c_cflag;\r\nunsigned long flags;\r\nunsigned int control_state;\r\nunsigned char last_lcr;\r\nspin_lock_irqsave(&priv->lock, flags);\r\ncontrol_state = priv->control_state;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nlast_lcr = 0;\r\nif ((old_cflag & CBAUD) == B0) {\r\ndev_dbg(&port->dev, "%s: baud was B0\n", __func__);\r\ncontrol_state |= TIOCM_DTR | TIOCM_RTS;\r\nmct_u232_set_modem_ctrl(port, control_state);\r\n}\r\nmct_u232_set_baud_rate(tty, serial, port, tty_get_baud_rate(tty));\r\nif ((cflag & CBAUD) == B0) {\r\ndev_dbg(&port->dev, "%s: baud is B0\n", __func__);\r\ncontrol_state &= ~(TIOCM_DTR | TIOCM_RTS);\r\nmct_u232_set_modem_ctrl(port, control_state);\r\n}\r\nif (cflag & PARENB)\r\nlast_lcr |= (cflag & PARODD) ?\r\nMCT_U232_PARITY_ODD : MCT_U232_PARITY_EVEN;\r\nelse\r\nlast_lcr |= MCT_U232_PARITY_NONE;\r\nswitch (cflag & CSIZE) {\r\ncase CS5:\r\nlast_lcr |= MCT_U232_DATA_BITS_5; break;\r\ncase CS6:\r\nlast_lcr |= MCT_U232_DATA_BITS_6; break;\r\ncase CS7:\r\nlast_lcr |= MCT_U232_DATA_BITS_7; break;\r\ncase CS8:\r\nlast_lcr |= MCT_U232_DATA_BITS_8; break;\r\ndefault:\r\ndev_err(&port->dev,\r\n"CSIZE was not CS5-CS8, using default of 8\n");\r\nlast_lcr |= MCT_U232_DATA_BITS_8;\r\nbreak;\r\n}\r\ntermios->c_cflag &= ~CMSPAR;\r\nlast_lcr |= (cflag & CSTOPB) ?\r\nMCT_U232_STOP_BITS_2 : MCT_U232_STOP_BITS_1;\r\nmct_u232_set_line_ctrl(port, last_lcr);\r\nspin_lock_irqsave(&priv->lock, flags);\r\npriv->control_state = control_state;\r\npriv->last_lcr = last_lcr;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nstatic void mct_u232_break_ctl(struct tty_struct *tty, int break_state)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct mct_u232_private *priv = usb_get_serial_port_data(port);\r\nunsigned char lcr;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nlcr = priv->last_lcr;\r\nif (break_state)\r\nlcr |= MCT_U232_SET_BREAK;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nmct_u232_set_line_ctrl(port, lcr);\r\n}\r\nstatic int mct_u232_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct mct_u232_private *priv = usb_get_serial_port_data(port);\r\nunsigned int control_state;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->lock, flags);\r\ncontrol_state = priv->control_state;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn control_state;\r\n}\r\nstatic int mct_u232_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct mct_u232_private *priv = usb_get_serial_port_data(port);\r\nunsigned int control_state;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->lock, flags);\r\ncontrol_state = priv->control_state;\r\nif (set & TIOCM_RTS)\r\ncontrol_state |= TIOCM_RTS;\r\nif (set & TIOCM_DTR)\r\ncontrol_state |= TIOCM_DTR;\r\nif (clear & TIOCM_RTS)\r\ncontrol_state &= ~TIOCM_RTS;\r\nif (clear & TIOCM_DTR)\r\ncontrol_state &= ~TIOCM_DTR;\r\npriv->control_state = control_state;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn mct_u232_set_modem_ctrl(port, control_state);\r\n}\r\nstatic void mct_u232_throttle(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct mct_u232_private *priv = usb_get_serial_port_data(port);\r\nunsigned int control_state;\r\nspin_lock_irq(&priv->lock);\r\npriv->rx_flags |= THROTTLED;\r\nif (C_CRTSCTS(tty)) {\r\npriv->control_state &= ~TIOCM_RTS;\r\ncontrol_state = priv->control_state;\r\nspin_unlock_irq(&priv->lock);\r\nmct_u232_set_modem_ctrl(port, control_state);\r\n} else {\r\nspin_unlock_irq(&priv->lock);\r\n}\r\n}\r\nstatic void mct_u232_unthrottle(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct mct_u232_private *priv = usb_get_serial_port_data(port);\r\nunsigned int control_state;\r\nspin_lock_irq(&priv->lock);\r\nif ((priv->rx_flags & THROTTLED) && C_CRTSCTS(tty)) {\r\npriv->rx_flags &= ~THROTTLED;\r\npriv->control_state |= TIOCM_RTS;\r\ncontrol_state = priv->control_state;\r\nspin_unlock_irq(&priv->lock);\r\nmct_u232_set_modem_ctrl(port, control_state);\r\n} else {\r\nspin_unlock_irq(&priv->lock);\r\n}\r\n}
