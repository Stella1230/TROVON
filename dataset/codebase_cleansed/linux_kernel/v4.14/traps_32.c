static inline void sign_extend(unsigned int count, unsigned char *dst)\r\n{\r\n#ifdef __LITTLE_ENDIAN__\r\nif ((count == 1) && dst[0] & 0x80) {\r\ndst[1] = 0xff;\r\ndst[2] = 0xff;\r\ndst[3] = 0xff;\r\n}\r\nif ((count == 2) && dst[1] & 0x80) {\r\ndst[2] = 0xff;\r\ndst[3] = 0xff;\r\n}\r\n#else\r\nif ((count == 1) && dst[3] & 0x80) {\r\ndst[2] = 0xff;\r\ndst[1] = 0xff;\r\ndst[0] = 0xff;\r\n}\r\nif ((count == 2) && dst[2] & 0x80) {\r\ndst[1] = 0xff;\r\ndst[0] = 0xff;\r\n}\r\n#endif\r\n}\r\nstatic int handle_unaligned_ins(insn_size_t instruction, struct pt_regs *regs,\r\nstruct mem_access *ma)\r\n{\r\nint ret, index, count;\r\nunsigned long *rm, *rn;\r\nunsigned char *src, *dst;\r\nunsigned char __user *srcu, *dstu;\r\nindex = (instruction>>8)&15;\r\nrn = &regs->regs[index];\r\nindex = (instruction>>4)&15;\r\nrm = &regs->regs[index];\r\ncount = 1<<(instruction&3);\r\nswitch (count) {\r\ncase 1: inc_unaligned_byte_access(); break;\r\ncase 2: inc_unaligned_word_access(); break;\r\ncase 4: inc_unaligned_dword_access(); break;\r\ncase 8: inc_unaligned_multi_access(); break;\r\n}\r\nret = -EFAULT;\r\nswitch (instruction>>12) {\r\ncase 0:\r\nif (instruction & 8) {\r\nsrcu = (unsigned char __user *)*rm;\r\nsrcu += regs->regs[0];\r\ndst = (unsigned char *)rn;\r\n*(unsigned long *)dst = 0;\r\n#if !defined(__LITTLE_ENDIAN__)\r\ndst += 4-count;\r\n#endif\r\nif (ma->from(dst, srcu, count))\r\ngoto fetch_fault;\r\nsign_extend(count, dst);\r\n} else {\r\nsrc = (unsigned char *)rm;\r\n#if !defined(__LITTLE_ENDIAN__)\r\nsrc += 4-count;\r\n#endif\r\ndstu = (unsigned char __user *)*rn;\r\ndstu += regs->regs[0];\r\nif (ma->to(dstu, src, count))\r\ngoto fetch_fault;\r\n}\r\nret = 0;\r\nbreak;\r\ncase 1:\r\nsrc = (unsigned char*) rm;\r\ndstu = (unsigned char __user *)*rn;\r\ndstu += (instruction&0x000F)<<2;\r\nif (ma->to(dstu, src, 4))\r\ngoto fetch_fault;\r\nret = 0;\r\nbreak;\r\ncase 2:\r\nif (instruction & 4)\r\n*rn -= count;\r\nsrc = (unsigned char*) rm;\r\ndstu = (unsigned char __user *)*rn;\r\n#if !defined(__LITTLE_ENDIAN__)\r\nsrc += 4-count;\r\n#endif\r\nif (ma->to(dstu, src, count))\r\ngoto fetch_fault;\r\nret = 0;\r\nbreak;\r\ncase 5:\r\nsrcu = (unsigned char __user *)*rm;\r\nsrcu += (instruction & 0x000F) << 2;\r\ndst = (unsigned char *)rn;\r\n*(unsigned long *)dst = 0;\r\nif (ma->from(dst, srcu, 4))\r\ngoto fetch_fault;\r\nret = 0;\r\nbreak;\r\ncase 6:\r\nsrcu = (unsigned char __user *)*rm;\r\nif (instruction & 4)\r\n*rm += count;\r\ndst = (unsigned char*) rn;\r\n*(unsigned long*)dst = 0;\r\n#if !defined(__LITTLE_ENDIAN__)\r\ndst += 4-count;\r\n#endif\r\nif (ma->from(dst, srcu, count))\r\ngoto fetch_fault;\r\nsign_extend(count, dst);\r\nret = 0;\r\nbreak;\r\ncase 8:\r\nswitch ((instruction&0xFF00)>>8) {\r\ncase 0x81:\r\nsrc = (unsigned char *) &regs->regs[0];\r\n#if !defined(__LITTLE_ENDIAN__)\r\nsrc += 2;\r\n#endif\r\ndstu = (unsigned char __user *)*rm;\r\ndstu += (instruction & 0x000F) << 1;\r\nif (ma->to(dstu, src, 2))\r\ngoto fetch_fault;\r\nret = 0;\r\nbreak;\r\ncase 0x85:\r\nsrcu = (unsigned char __user *)*rm;\r\nsrcu += (instruction & 0x000F) << 1;\r\ndst = (unsigned char *) &regs->regs[0];\r\n*(unsigned long *)dst = 0;\r\n#if !defined(__LITTLE_ENDIAN__)\r\ndst += 2;\r\n#endif\r\nif (ma->from(dst, srcu, 2))\r\ngoto fetch_fault;\r\nsign_extend(2, dst);\r\nret = 0;\r\nbreak;\r\n}\r\nbreak;\r\ncase 9:\r\nsrcu = (unsigned char __user *)regs->pc;\r\nsrcu += 4;\r\nsrcu += (instruction & 0x00FF) << 1;\r\ndst = (unsigned char *)rn;\r\n*(unsigned long *)dst = 0;\r\n#if !defined(__LITTLE_ENDIAN__)\r\ndst += 2;\r\n#endif\r\nif (ma->from(dst, srcu, 2))\r\ngoto fetch_fault;\r\nsign_extend(2, dst);\r\nret = 0;\r\nbreak;\r\ncase 0xd:\r\nsrcu = (unsigned char __user *)(regs->pc & ~0x3);\r\nsrcu += 4;\r\nsrcu += (instruction & 0x00FF) << 2;\r\ndst = (unsigned char *)rn;\r\n*(unsigned long *)dst = 0;\r\nif (ma->from(dst, srcu, 4))\r\ngoto fetch_fault;\r\nret = 0;\r\nbreak;\r\n}\r\nreturn ret;\r\nfetch_fault:\r\ndie_if_no_fixup("Fault in unaligned fixup", regs, 0);\r\nreturn -EFAULT;\r\n}\r\nstatic inline int handle_delayslot(struct pt_regs *regs,\r\ninsn_size_t old_instruction,\r\nstruct mem_access *ma)\r\n{\r\ninsn_size_t instruction;\r\nvoid __user *addr = (void __user *)(regs->pc +\r\ninstruction_size(old_instruction));\r\nif (copy_from_user(&instruction, addr, sizeof(instruction))) {\r\nif (user_mode(regs))\r\nreturn -EFAULT;\r\ndie("delay-slot-insn faulting in handle_unaligned_delayslot",\r\nregs, 0);\r\n}\r\nreturn handle_unaligned_ins(instruction, regs, ma);\r\n}\r\nint handle_unaligned_access(insn_size_t instruction, struct pt_regs *regs,\r\nstruct mem_access *ma, int expected,\r\nunsigned long address)\r\n{\r\nu_int rm;\r\nint ret, index;\r\nif (instruction_size(instruction) != 2)\r\nreturn -EINVAL;\r\nindex = (instruction>>8)&15;\r\nrm = regs->regs[index];\r\nif (!expected) {\r\nunaligned_fixups_notify(current, instruction, regs);\r\nperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1,\r\nregs, address);\r\n}\r\nret = -EFAULT;\r\nswitch (instruction&0xF000) {\r\ncase 0x0000:\r\nif (instruction==0x000B) {\r\nret = handle_delayslot(regs, instruction, ma);\r\nif (ret==0)\r\nregs->pc = regs->pr;\r\n}\r\nelse if ((instruction&0x00FF)==0x0023) {\r\nret = handle_delayslot(regs, instruction, ma);\r\nif (ret==0)\r\nregs->pc += rm + 4;\r\n}\r\nelse if ((instruction&0x00FF)==0x0003) {\r\nret = handle_delayslot(regs, instruction, ma);\r\nif (ret==0) {\r\nregs->pr = regs->pc + 4;\r\nregs->pc += rm + 4;\r\n}\r\n}\r\nelse {\r\ngoto simple;\r\n}\r\nbreak;\r\ncase 0x1000:\r\ngoto simple;\r\ncase 0x2000:\r\ngoto simple;\r\ncase 0x4000:\r\nif ((instruction&0x00FF)==0x002B) {\r\nret = handle_delayslot(regs, instruction, ma);\r\nif (ret==0)\r\nregs->pc = rm;\r\n}\r\nelse if ((instruction&0x00FF)==0x000B) {\r\nret = handle_delayslot(regs, instruction, ma);\r\nif (ret==0) {\r\nregs->pr = regs->pc + 4;\r\nregs->pc = rm;\r\n}\r\n}\r\nelse {\r\ngoto simple;\r\n}\r\nbreak;\r\ncase 0x5000:\r\ngoto simple;\r\ncase 0x6000:\r\ngoto simple;\r\ncase 0x8000:\r\nswitch (instruction&0x0F00) {\r\ncase 0x0100:\r\ngoto simple;\r\ncase 0x0500:\r\ngoto simple;\r\ncase 0x0B00:\r\nret = 0;\r\nbreak;\r\ncase 0x0F00:\r\nret = handle_delayslot(regs, instruction, ma);\r\nif (ret==0) {\r\n#if defined(CONFIG_CPU_SH4) || defined(CONFIG_SH7705_CACHE_32KB)\r\nif ((regs->sr & 0x00000001) != 0)\r\nregs->pc += 4;\r\nelse\r\n#endif\r\nregs->pc += SH_PC_8BIT_OFFSET(instruction);\r\n}\r\nbreak;\r\ncase 0x0900:\r\nret = 0;\r\nbreak;\r\ncase 0x0D00:\r\nret = handle_delayslot(regs, instruction, ma);\r\nif (ret==0) {\r\n#if defined(CONFIG_CPU_SH4) || defined(CONFIG_SH7705_CACHE_32KB)\r\nif ((regs->sr & 0x00000001) == 0)\r\nregs->pc += 4;\r\nelse\r\n#endif\r\nregs->pc += SH_PC_8BIT_OFFSET(instruction);\r\n}\r\nbreak;\r\n}\r\nbreak;\r\ncase 0x9000:\r\ngoto simple;\r\ncase 0xA000:\r\nret = handle_delayslot(regs, instruction, ma);\r\nif (ret==0)\r\nregs->pc += SH_PC_12BIT_OFFSET(instruction);\r\nbreak;\r\ncase 0xB000:\r\nret = handle_delayslot(regs, instruction, ma);\r\nif (ret==0) {\r\nregs->pr = regs->pc + 4;\r\nregs->pc += SH_PC_12BIT_OFFSET(instruction);\r\n}\r\nbreak;\r\ncase 0xD000:\r\ngoto simple;\r\n}\r\nreturn ret;\r\nsimple:\r\nret = handle_unaligned_ins(instruction, regs, ma);\r\nif (ret==0)\r\nregs->pc += instruction_size(instruction);\r\nreturn ret;\r\n}\r\nasmlinkage void do_address_error(struct pt_regs *regs,\r\nunsigned long writeaccess,\r\nunsigned long address)\r\n{\r\nunsigned long error_code = 0;\r\nmm_segment_t oldfs;\r\nsiginfo_t info;\r\ninsn_size_t instruction;\r\nint tmp;\r\n#ifdef CONFIG_CPU_HAS_SR_RB\r\nerror_code = lookup_exception_vector();\r\n#endif\r\noldfs = get_fs();\r\nif (user_mode(regs)) {\r\nint si_code = BUS_ADRERR;\r\nunsigned int user_action;\r\nlocal_irq_enable();\r\ninc_unaligned_user_access();\r\nset_fs(USER_DS);\r\nif (copy_from_user(&instruction, (insn_size_t *)(regs->pc & ~1),\r\nsizeof(instruction))) {\r\nset_fs(oldfs);\r\ngoto uspace_segv;\r\n}\r\nset_fs(oldfs);\r\nunaligned_fixups_notify(current, instruction, regs);\r\nuser_action = unaligned_user_action();\r\nif (user_action & UM_FIXUP)\r\ngoto fixup;\r\nif (user_action & UM_SIGNAL)\r\ngoto uspace_segv;\r\nelse {\r\nregs->pc += instruction_size(instruction);\r\nreturn;\r\n}\r\nfixup:\r\nif (regs->pc & 1) {\r\nsi_code = BUS_ADRALN;\r\ngoto uspace_segv;\r\n}\r\nset_fs(USER_DS);\r\ntmp = handle_unaligned_access(instruction, regs,\r\n&user_mem_access, 0,\r\naddress);\r\nset_fs(oldfs);\r\nif (tmp == 0)\r\nreturn;\r\nuspace_segv:\r\nprintk(KERN_NOTICE "Sending SIGBUS to \"%s\" due to unaligned "\r\n"access (PC %lx PR %lx)\n", current->comm, regs->pc,\r\nregs->pr);\r\ninfo.si_signo = SIGBUS;\r\ninfo.si_errno = 0;\r\ninfo.si_code = si_code;\r\ninfo.si_addr = (void __user *)address;\r\nforce_sig_info(SIGBUS, &info, current);\r\n} else {\r\ninc_unaligned_kernel_access();\r\nif (regs->pc & 1)\r\ndie("unaligned program counter", regs, error_code);\r\nset_fs(KERNEL_DS);\r\nif (copy_from_user(&instruction, (void __user *)(regs->pc),\r\nsizeof(instruction))) {\r\nset_fs(oldfs);\r\ndie("insn faulting in do_address_error", regs, 0);\r\n}\r\nunaligned_fixups_notify(current, instruction, regs);\r\nhandle_unaligned_access(instruction, regs, &user_mem_access,\r\n0, address);\r\nset_fs(oldfs);\r\n}\r\n}\r\nint is_dsp_inst(struct pt_regs *regs)\r\n{\r\nunsigned short inst = 0;\r\nif (!(current_cpu_data.flags & CPU_HAS_DSP) || (regs->sr & SR_DSP))\r\nreturn 0;\r\nget_user(inst, ((unsigned short *) regs->pc));\r\ninst &= 0xf000;\r\nif ((inst == 0xf000) || (inst == 0x4000))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nasmlinkage void do_divide_error(unsigned long r4)\r\n{\r\nsiginfo_t info;\r\nswitch (r4) {\r\ncase TRAP_DIVZERO_ERROR:\r\ninfo.si_code = FPE_INTDIV;\r\nbreak;\r\ncase TRAP_DIVOVF_ERROR:\r\ninfo.si_code = FPE_INTOVF;\r\nbreak;\r\n}\r\nforce_sig_info(SIGFPE, &info, current);\r\n}\r\nasmlinkage void do_reserved_inst(void)\r\n{\r\nstruct pt_regs *regs = current_pt_regs();\r\nunsigned long error_code;\r\nstruct task_struct *tsk = current;\r\n#ifdef CONFIG_SH_FPU_EMU\r\nunsigned short inst = 0;\r\nint err;\r\nget_user(inst, (unsigned short*)regs->pc);\r\nerr = do_fpu_inst(inst, regs);\r\nif (!err) {\r\nregs->pc += instruction_size(inst);\r\nreturn;\r\n}\r\n#endif\r\n#ifdef CONFIG_SH_DSP\r\nif (is_dsp_inst(regs)) {\r\nregs->sr |= SR_DSP;\r\ntsk->thread.dsp_status.status |= SR_DSP;\r\nreturn;\r\n}\r\n#endif\r\nerror_code = lookup_exception_vector();\r\nlocal_irq_enable();\r\nforce_sig(SIGILL, tsk);\r\ndie_if_no_fixup("reserved instruction", regs, error_code);\r\n}\r\nstatic int emulate_branch(unsigned short inst, struct pt_regs *regs)\r\n{\r\nif (((inst & 0xf000) == 0xb000) ||\r\n((inst & 0xf0ff) == 0x0003) ||\r\n((inst & 0xf0ff) == 0x400b))\r\nregs->pr = regs->pc + 4;\r\nif ((inst & 0xfd00) == 0x8d00) {\r\nregs->pc += SH_PC_8BIT_OFFSET(inst);\r\nreturn 0;\r\n}\r\nif ((inst & 0xe000) == 0xa000) {\r\nregs->pc += SH_PC_12BIT_OFFSET(inst);\r\nreturn 0;\r\n}\r\nif ((inst & 0xf0df) == 0x0003) {\r\nregs->pc += regs->regs[(inst & 0x0f00) >> 8] + 4;\r\nreturn 0;\r\n}\r\nif ((inst & 0xf0df) == 0x400b) {\r\nregs->pc = regs->regs[(inst & 0x0f00) >> 8];\r\nreturn 0;\r\n}\r\nif ((inst & 0xffff) == 0x000b) {\r\nregs->pc = regs->pr;\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nasmlinkage void do_illegal_slot_inst(void)\r\n{\r\nstruct pt_regs *regs = current_pt_regs();\r\nunsigned long inst;\r\nstruct task_struct *tsk = current;\r\nif (kprobe_handle_illslot(regs->pc) == 0)\r\nreturn;\r\n#ifdef CONFIG_SH_FPU_EMU\r\nget_user(inst, (unsigned short *)regs->pc + 1);\r\nif (!do_fpu_inst(inst, regs)) {\r\nget_user(inst, (unsigned short *)regs->pc);\r\nif (!emulate_branch(inst, regs))\r\nreturn;\r\n}\r\n#endif\r\ninst = lookup_exception_vector();\r\nlocal_irq_enable();\r\nforce_sig(SIGILL, tsk);\r\ndie_if_no_fixup("illegal slot instruction", regs, inst);\r\n}\r\nasmlinkage void do_exception_error(void)\r\n{\r\nlong ex;\r\nex = lookup_exception_vector();\r\ndie_if_kernel("exception", current_pt_regs(), ex);\r\n}\r\nvoid per_cpu_trap_init(void)\r\n{\r\nextern void *vbr_base;\r\nasm volatile("ldc %0, vbr"\r\n:\r\n: "r" (&vbr_base)\r\n: "memory");\r\nclear_bl_bit();\r\n}\r\nvoid *set_exception_table_vec(unsigned int vec, void *handler)\r\n{\r\nextern void *exception_handling_table[];\r\nvoid *old_handler;\r\nold_handler = exception_handling_table[vec];\r\nexception_handling_table[vec] = handler;\r\nreturn old_handler;\r\n}\r\nvoid __init trap_init(void)\r\n{\r\nset_exception_table_vec(TRAP_RESERVED_INST, do_reserved_inst);\r\nset_exception_table_vec(TRAP_ILLEGAL_SLOT_INST, do_illegal_slot_inst);\r\n#if defined(CONFIG_CPU_SH4) && !defined(CONFIG_SH_FPU) || \\r\ndefined(CONFIG_SH_FPU_EMU)\r\nset_exception_table_evt(0x800, do_reserved_inst);\r\nset_exception_table_evt(0x820, do_illegal_slot_inst);\r\n#elif defined(CONFIG_SH_FPU)\r\nset_exception_table_evt(0x800, fpu_state_restore_trap_handler);\r\nset_exception_table_evt(0x820, fpu_state_restore_trap_handler);\r\n#endif\r\n#ifdef CONFIG_CPU_SH2\r\nset_exception_table_vec(TRAP_ADDRESS_ERROR, address_error_trap_handler);\r\n#endif\r\n#ifdef CONFIG_CPU_SH2A\r\nset_exception_table_vec(TRAP_DIVZERO_ERROR, do_divide_error);\r\nset_exception_table_vec(TRAP_DIVOVF_ERROR, do_divide_error);\r\n#ifdef CONFIG_SH_FPU\r\nset_exception_table_vec(TRAP_FPU_ERROR, fpu_error_trap_handler);\r\n#endif\r\n#endif\r\n#ifdef TRAP_UBC\r\nset_exception_table_vec(TRAP_UBC, breakpoint_trap_handler);\r\n#endif\r\n}
