static int ad_read(ad1848_info * devc, int reg)\r\n{\r\nint x;\r\nint timeout = 900000;\r\nwhile (timeout > 0 && inb(devc->base) == 0x80)\r\ntimeout--;\r\nif(reg < 32)\r\n{\r\noutb(((unsigned char) (reg & 0xff) | devc->MCE_bit), io_Index_Addr(devc));\r\nx = inb(io_Indexed_Data(devc));\r\n}\r\nelse\r\n{\r\nint xreg, xra;\r\nxreg = (reg & 0xff) - 32;\r\nxra = (((xreg & 0x0f) << 4) & 0xf0) | 0x08 | ((xreg & 0x10) >> 2);\r\noutb(((unsigned char) (23 & 0xff) | devc->MCE_bit), io_Index_Addr(devc));\r\noutb(((unsigned char) (xra & 0xff)), io_Indexed_Data(devc));\r\nx = inb(io_Indexed_Data(devc));\r\n}\r\nreturn x;\r\n}\r\nstatic void ad_write(ad1848_info * devc, int reg, int data)\r\n{\r\nint timeout = 900000;\r\nwhile (timeout > 0 && inb(devc->base) == 0x80)\r\ntimeout--;\r\nif(reg < 32)\r\n{\r\noutb(((unsigned char) (reg & 0xff) | devc->MCE_bit), io_Index_Addr(devc));\r\noutb(((unsigned char) (data & 0xff)), io_Indexed_Data(devc));\r\n}\r\nelse\r\n{\r\nint xreg, xra;\r\nxreg = (reg & 0xff) - 32;\r\nxra = (((xreg & 0x0f) << 4) & 0xf0) | 0x08 | ((xreg & 0x10) >> 2);\r\noutb(((unsigned char) (23 & 0xff) | devc->MCE_bit), io_Index_Addr(devc));\r\noutb(((unsigned char) (xra & 0xff)), io_Indexed_Data(devc));\r\noutb((unsigned char) (data & 0xff), io_Indexed_Data(devc));\r\n}\r\n}\r\nstatic void wait_for_calibration(ad1848_info * devc)\r\n{\r\nint timeout;\r\ntimeout = 100000;\r\nwhile (timeout > 0 && inb(devc->base) == 0x80)\r\ntimeout--;\r\nif (inb(devc->base) & 0x80)\r\nprintk(KERN_WARNING "ad1848: Auto calibration timed out(1).\n");\r\ntimeout = 100;\r\nwhile (timeout > 0 && !(ad_read(devc, 11) & 0x20))\r\ntimeout--;\r\nif (!(ad_read(devc, 11) & 0x20))\r\nreturn;\r\ntimeout = 80000;\r\nwhile (timeout > 0 && (ad_read(devc, 11) & 0x20))\r\ntimeout--;\r\nif (ad_read(devc, 11) & 0x20)\r\nif ((devc->model != MD_1845) && (devc->model != MD_1845_SSCAPE))\r\nprintk(KERN_WARNING "ad1848: Auto calibration timed out(3).\n");\r\n}\r\nstatic void ad_mute(ad1848_info * devc)\r\n{\r\nint i;\r\nunsigned char prev;\r\nfor (i = 6; i < 8; i++)\r\n{\r\nprev = devc->saved_regs[i] = ad_read(devc, i);\r\n}\r\n}\r\nstatic void ad_unmute(ad1848_info * devc)\r\n{\r\n}\r\nstatic void ad_enter_MCE(ad1848_info * devc)\r\n{\r\nint timeout = 1000;\r\nunsigned short prev;\r\nwhile (timeout > 0 && inb(devc->base) == 0x80)\r\ntimeout--;\r\ndevc->MCE_bit = 0x40;\r\nprev = inb(io_Index_Addr(devc));\r\nif (prev & 0x40)\r\n{\r\nreturn;\r\n}\r\noutb((devc->MCE_bit), io_Index_Addr(devc));\r\n}\r\nstatic void ad_leave_MCE(ad1848_info * devc)\r\n{\r\nunsigned char prev, acal;\r\nint timeout = 1000;\r\nwhile (timeout > 0 && inb(devc->base) == 0x80)\r\ntimeout--;\r\nacal = ad_read(devc, 9);\r\ndevc->MCE_bit = 0x00;\r\nprev = inb(io_Index_Addr(devc));\r\noutb((0x00), io_Index_Addr(devc));\r\nif ((prev & 0x40) == 0)\r\n{\r\nreturn;\r\n}\r\noutb((0x00), io_Index_Addr(devc));\r\nif (acal & 0x08)\r\nwait_for_calibration(devc);\r\n}\r\nstatic int ad1848_set_recmask(ad1848_info * devc, int mask)\r\n{\r\nunsigned char recdev;\r\nint i, n;\r\nunsigned long flags;\r\nmask &= devc->supported_rec_devices;\r\nfor (i = 0; i < 32; i++)\r\n{\r\nif (devc->mixer_reroute[i] != i)\r\n{\r\nif (mask & (1 << i))\r\n{\r\nmask &= ~(1 << i);\r\nmask |= (1 << devc->mixer_reroute[i]);\r\n}\r\n}\r\n}\r\nn = 0;\r\nfor (i = 0; i < 32; i++)\r\nif (mask & (1 << i))\r\nn++;\r\nspin_lock_irqsave(&devc->lock,flags);\r\nif (!soundpro) {\r\nif (n == 0)\r\nmask = SOUND_MASK_MIC;\r\nelse if (n != 1) {\r\nmask &= ~devc->recmask;\r\nn = 0;\r\nfor (i = 0; i < 32; i++)\r\nif (mask & (1 << i))\r\nn++;\r\nif (n != 1)\r\nmask = SOUND_MASK_MIC;\r\n}\r\nswitch (mask) {\r\ncase SOUND_MASK_MIC:\r\nrecdev = 2;\r\nbreak;\r\ncase SOUND_MASK_LINE:\r\ncase SOUND_MASK_LINE3:\r\nrecdev = 0;\r\nbreak;\r\ncase SOUND_MASK_CD:\r\ncase SOUND_MASK_LINE1:\r\nrecdev = 1;\r\nbreak;\r\ncase SOUND_MASK_IMIX:\r\nrecdev = 3;\r\nbreak;\r\ndefault:\r\nmask = SOUND_MASK_MIC;\r\nrecdev = 2;\r\n}\r\nrecdev <<= 6;\r\nad_write(devc, 0, (ad_read(devc, 0) & 0x3f) | recdev);\r\nad_write(devc, 1, (ad_read(devc, 1) & 0x3f) | recdev);\r\n} else {\r\nunsigned char val;\r\nint set_rec_bit;\r\nint j;\r\nfor (i = 0; i < 32; i++) {\r\nif ((devc->supported_rec_devices & (1 << i)) == 0)\r\ncontinue;\r\nfor (j = LEFT_CHN; j <= RIGHT_CHN; j++) {\r\nif (devc->mix_devices[i][j].nbits == 0)\r\ncontinue;\r\nset_rec_bit = ((mask & (1 << i)) != 0) ^ devc->mix_devices[i][j].recpol;\r\nval = ad_read(devc, devc->mix_devices[i][j].recreg);\r\nval &= ~(1 << devc->mix_devices[i][j].recpos);\r\nval |= (set_rec_bit << devc->mix_devices[i][j].recpos);\r\nad_write(devc, devc->mix_devices[i][j].recreg, val);\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&devc->lock,flags);\r\nfor (i = 0; i < 32; i++)\r\n{\r\nif (devc->mixer_reroute[i] != i)\r\n{\r\nif (mask & (1 << devc->mixer_reroute[i]))\r\n{\r\nmask &= ~(1 << devc->mixer_reroute[i]);\r\nmask |= (1 << i);\r\n}\r\n}\r\n}\r\ndevc->recmask = mask;\r\nreturn mask;\r\n}\r\nstatic void oss_change_bits(ad1848_info *devc, unsigned char *regval,\r\nunsigned char *muteval, int dev, int chn, int newval)\r\n{\r\nunsigned char mask;\r\nint shift;\r\nint mute;\r\nint mutemask;\r\nint set_mute_bit;\r\nset_mute_bit = (newval == 0) ^ devc->mix_devices[dev][chn].mutepol;\r\nif (devc->mix_devices[dev][chn].polarity == 1)\r\nnewval = 100 - newval;\r\nmask = (1 << devc->mix_devices[dev][chn].nbits) - 1;\r\nshift = devc->mix_devices[dev][chn].bitpos;\r\nif (devc->mix_devices[dev][chn].mutepos == 8)\r\n{\r\nmute = 0;\r\nmutemask = ~0;\r\n}\r\nelse\r\n{\r\nmute = (set_mute_bit << devc->mix_devices[dev][chn].mutepos);\r\nmutemask = ~(1 << devc->mix_devices[dev][chn].mutepos);\r\n}\r\nnewval = (int) ((newval * mask) + 50) / 100;\r\n*regval &= ~(mask << shift);\r\n*regval |= (newval & mask) << shift;\r\n*muteval &= mutemask;\r\n*muteval |= mute;\r\n}\r\nstatic int ad1848_mixer_get(ad1848_info * devc, int dev)\r\n{\r\nif (!((1 << dev) & devc->supported_devices))\r\nreturn -EINVAL;\r\ndev = devc->mixer_reroute[dev];\r\nreturn devc->levels[dev];\r\n}\r\nstatic void ad1848_mixer_set_channel(ad1848_info *devc, int dev, int value, int channel)\r\n{\r\nint regoffs, muteregoffs;\r\nunsigned char val, muteval;\r\nunsigned long flags;\r\nregoffs = devc->mix_devices[dev][channel].regno;\r\nmuteregoffs = devc->mix_devices[dev][channel].mutereg;\r\nval = ad_read(devc, regoffs);\r\nif (muteregoffs != regoffs) {\r\nmuteval = ad_read(devc, muteregoffs);\r\noss_change_bits(devc, &val, &muteval, dev, channel, value);\r\n}\r\nelse\r\noss_change_bits(devc, &val, &val, dev, channel, value);\r\nspin_lock_irqsave(&devc->lock,flags);\r\nad_write(devc, regoffs, val);\r\ndevc->saved_regs[regoffs] = val;\r\nif (muteregoffs != regoffs) {\r\nad_write(devc, muteregoffs, muteval);\r\ndevc->saved_regs[muteregoffs] = muteval;\r\n}\r\nspin_unlock_irqrestore(&devc->lock,flags);\r\n}\r\nstatic int ad1848_mixer_set(ad1848_info * devc, int dev, int value)\r\n{\r\nint left = value & 0x000000ff;\r\nint right = (value & 0x0000ff00) >> 8;\r\nint retvol;\r\nif (dev > 31)\r\nreturn -EINVAL;\r\nif (!(devc->supported_devices & (1 << dev)))\r\nreturn -EINVAL;\r\ndev = devc->mixer_reroute[dev];\r\nif (devc->mix_devices[dev][LEFT_CHN].nbits == 0)\r\nreturn -EINVAL;\r\nif (left > 100)\r\nleft = 100;\r\nif (right > 100)\r\nright = 100;\r\nif (devc->mix_devices[dev][RIGHT_CHN].nbits == 0)\r\nright = left;\r\nretvol = left | (right << 8);\r\nleft = mix_cvt[left];\r\nright = mix_cvt[right];\r\ndevc->levels[dev] = retvol;\r\nad1848_mixer_set_channel(devc, dev, left, LEFT_CHN);\r\nif (devc->mix_devices[dev][RIGHT_CHN].nbits == 0)\r\ngoto out;\r\nad1848_mixer_set_channel(devc, dev, right, RIGHT_CHN);\r\nout:\r\nreturn retvol;\r\n}\r\nstatic void ad1848_mixer_reset(ad1848_info * devc)\r\n{\r\nint i;\r\nchar name[32];\r\nunsigned long flags;\r\ndevc->mix_devices = &(ad1848_mix_devices[0]);\r\nsprintf(name, "%s_%d", devc->chip_name, nr_ad1848_devs);\r\nfor (i = 0; i < 32; i++)\r\ndevc->mixer_reroute[i] = i;\r\ndevc->supported_rec_devices = MODE1_REC_DEVICES;\r\nswitch (devc->model)\r\n{\r\ncase MD_4231:\r\ncase MD_4231A:\r\ncase MD_1845:\r\ncase MD_1845_SSCAPE:\r\ndevc->supported_devices = MODE2_MIXER_DEVICES;\r\nbreak;\r\ncase MD_C930:\r\ndevc->supported_devices = C930_MIXER_DEVICES;\r\ndevc->mix_devices = &(c930_mix_devices[0]);\r\nbreak;\r\ncase MD_IWAVE:\r\ndevc->supported_devices = MODE3_MIXER_DEVICES;\r\ndevc->mix_devices = &(iwave_mix_devices[0]);\r\nbreak;\r\ncase MD_42xB:\r\ncase MD_4239:\r\ndevc->mix_devices = &(cs42xb_mix_devices[0]);\r\ndevc->supported_devices = MODE3_MIXER_DEVICES;\r\nbreak;\r\ncase MD_4232:\r\ncase MD_4235:\r\ncase MD_4236:\r\ndevc->supported_devices = MODE3_MIXER_DEVICES;\r\nbreak;\r\ncase MD_1848:\r\nif (soundpro) {\r\ndevc->supported_devices = SPRO_MIXER_DEVICES;\r\ndevc->supported_rec_devices = SPRO_REC_DEVICES;\r\ndevc->mix_devices = &(spro_mix_devices[0]);\r\nbreak;\r\n}\r\ndefault:\r\ndevc->supported_devices = MODE1_MIXER_DEVICES;\r\n}\r\ndevc->orig_devices = devc->supported_devices;\r\ndevc->orig_rec_devices = devc->supported_rec_devices;\r\ndevc->levels = load_mixer_volumes(name, default_mixer_levels, 1);\r\nfor (i = 0; i < SOUND_MIXER_NRDEVICES; i++)\r\n{\r\nif (devc->supported_devices & (1 << i))\r\nad1848_mixer_set(devc, i, devc->levels[i]);\r\n}\r\nad1848_set_recmask(devc, SOUND_MASK_MIC);\r\ndevc->mixer_output_port = devc->levels[31] | AUDIO_HEADPHONE | AUDIO_LINE_OUT;\r\nspin_lock_irqsave(&devc->lock,flags);\r\nif (!soundpro) {\r\nif (devc->mixer_output_port & AUDIO_SPEAKER)\r\nad_write(devc, 26, ad_read(devc, 26) & ~0x40);\r\nelse\r\nad_write(devc, 26, ad_read(devc, 26) | 0x40);\r\n} else {\r\nad_write(devc, 16, 0x60);\r\n}\r\nspin_unlock_irqrestore(&devc->lock,flags);\r\n}\r\nstatic int ad1848_mixer_ioctl(int dev, unsigned int cmd, void __user *arg)\r\n{\r\nad1848_info *devc = mixer_devs[dev]->devc;\r\nint val;\r\nif (cmd == SOUND_MIXER_PRIVATE1)\r\n{\r\nif (get_user(val, (int __user *)arg))\r\nreturn -EFAULT;\r\nif (val != 0xffff)\r\n{\r\nunsigned long flags;\r\nval &= (AUDIO_SPEAKER | AUDIO_HEADPHONE | AUDIO_LINE_OUT);\r\ndevc->mixer_output_port = val;\r\nval |= AUDIO_HEADPHONE | AUDIO_LINE_OUT;\r\ndevc->mixer_output_port = val;\r\nspin_lock_irqsave(&devc->lock,flags);\r\nif (val & AUDIO_SPEAKER)\r\nad_write(devc, 26, ad_read(devc, 26) & ~0x40);\r\nelse\r\nad_write(devc, 26, ad_read(devc, 26) | 0x40);\r\nspin_unlock_irqrestore(&devc->lock,flags);\r\n}\r\nval = devc->mixer_output_port;\r\nreturn put_user(val, (int __user *)arg);\r\n}\r\nif (cmd == SOUND_MIXER_PRIVATE2)\r\n{\r\nif (get_user(val, (int __user *)arg))\r\nreturn -EFAULT;\r\nreturn(ad1848_control(AD1848_MIXER_REROUTE, val));\r\n}\r\nif (((cmd >> 8) & 0xff) == 'M')\r\n{\r\nif (_SIOC_DIR(cmd) & _SIOC_WRITE)\r\n{\r\nswitch (cmd & 0xff)\r\n{\r\ncase SOUND_MIXER_RECSRC:\r\nif (get_user(val, (int __user *)arg))\r\nreturn -EFAULT;\r\nval = ad1848_set_recmask(devc, val);\r\nbreak;\r\ndefault:\r\nif (get_user(val, (int __user *)arg))\r\nreturn -EFAULT;\r\nval = ad1848_mixer_set(devc, cmd & 0xff, val);\r\nbreak;\r\n}\r\nreturn put_user(val, (int __user *)arg);\r\n}\r\nelse\r\n{\r\nswitch (cmd & 0xff)\r\n{\r\ncase SOUND_MIXER_RECSRC:\r\nval = devc->recmask;\r\nbreak;\r\ncase SOUND_MIXER_DEVMASK:\r\nval = devc->supported_devices;\r\nbreak;\r\ncase SOUND_MIXER_STEREODEVS:\r\nval = devc->supported_devices;\r\nif (devc->model != MD_C930)\r\nval &= ~(SOUND_MASK_SPEAKER | SOUND_MASK_IMIX);\r\nbreak;\r\ncase SOUND_MIXER_RECMASK:\r\nval = devc->supported_rec_devices;\r\nbreak;\r\ncase SOUND_MIXER_CAPS:\r\nval=SOUND_CAP_EXCL_INPUT;\r\nbreak;\r\ndefault:\r\nval = ad1848_mixer_get(devc, cmd & 0xff);\r\nbreak;\r\n}\r\nreturn put_user(val, (int __user *)arg);\r\n}\r\n}\r\nelse\r\nreturn -EINVAL;\r\n}\r\nstatic int ad1848_set_speed(int dev, int arg)\r\n{\r\nad1848_info *devc = (ad1848_info *) audio_devs[dev]->devc;\r\nad1848_port_info *portc = (ad1848_port_info *) audio_devs[dev]->portc;\r\ntypedef struct\r\n{\r\nint speed;\r\nunsigned char bits;\r\n}\r\nspeed_struct;\r\nstatic speed_struct speed_table[] =\r\n{\r\n{5510, (0 << 1) | 1},\r\n{5510, (0 << 1) | 1},\r\n{6620, (7 << 1) | 1},\r\n{8000, (0 << 1) | 0},\r\n{9600, (7 << 1) | 0},\r\n{11025, (1 << 1) | 1},\r\n{16000, (1 << 1) | 0},\r\n{18900, (2 << 1) | 1},\r\n{22050, (3 << 1) | 1},\r\n{27420, (2 << 1) | 0},\r\n{32000, (3 << 1) | 0},\r\n{33075, (6 << 1) | 1},\r\n{37800, (4 << 1) | 1},\r\n{44100, (5 << 1) | 1},\r\n{48000, (6 << 1) | 0}\r\n};\r\nint i, n, selected = -1;\r\nn = sizeof(speed_table) / sizeof(speed_struct);\r\nif (arg <= 0)\r\nreturn portc->speed;\r\nif (devc->model == MD_1845 || devc->model == MD_1845_SSCAPE)\r\n{\r\nif (arg < 4000)\r\narg = 4000;\r\nif (arg > 50000)\r\narg = 50000;\r\nportc->speed = arg;\r\nportc->speed_bits = speed_table[3].bits;\r\nreturn portc->speed;\r\n}\r\nif (arg < speed_table[0].speed)\r\nselected = 0;\r\nif (arg > speed_table[n - 1].speed)\r\nselected = n - 1;\r\nfor (i = 1 ; selected == -1 && i < n; i++)\r\n{\r\nif (speed_table[i].speed == arg)\r\nselected = i;\r\nelse if (speed_table[i].speed > arg)\r\n{\r\nint diff1, diff2;\r\ndiff1 = arg - speed_table[i - 1].speed;\r\ndiff2 = speed_table[i].speed - arg;\r\nif (diff1 < diff2)\r\nselected = i - 1;\r\nelse\r\nselected = i;\r\n}\r\n}\r\nif (selected == -1)\r\n{\r\nprintk(KERN_WARNING "ad1848: Can't find speed???\n");\r\nselected = 3;\r\n}\r\nportc->speed = speed_table[selected].speed;\r\nportc->speed_bits = speed_table[selected].bits;\r\nreturn portc->speed;\r\n}\r\nstatic short ad1848_set_channels(int dev, short arg)\r\n{\r\nad1848_port_info *portc = (ad1848_port_info *) audio_devs[dev]->portc;\r\nif (arg != 1 && arg != 2)\r\nreturn portc->channels;\r\nportc->channels = arg;\r\nreturn arg;\r\n}\r\nstatic unsigned int ad1848_set_bits(int dev, unsigned int arg)\r\n{\r\nad1848_info *devc = (ad1848_info *) audio_devs[dev]->devc;\r\nad1848_port_info *portc = (ad1848_port_info *) audio_devs[dev]->portc;\r\nstatic struct format_tbl\r\n{\r\nint format;\r\nunsigned char bits;\r\n}\r\nformat2bits[] =\r\n{\r\n{\r\n0, 0\r\n}\r\n,\r\n{\r\nAFMT_MU_LAW, 1\r\n}\r\n,\r\n{\r\nAFMT_A_LAW, 3\r\n}\r\n,\r\n{\r\nAFMT_IMA_ADPCM, 5\r\n}\r\n,\r\n{\r\nAFMT_U8, 0\r\n}\r\n,\r\n{\r\nAFMT_S16_LE, 2\r\n}\r\n,\r\n{\r\nAFMT_S16_BE, 6\r\n}\r\n,\r\n{\r\nAFMT_S8, 0\r\n}\r\n,\r\n{\r\nAFMT_U16_LE, 0\r\n}\r\n,\r\n{\r\nAFMT_U16_BE, 0\r\n}\r\n};\r\nint i, n = sizeof(format2bits) / sizeof(struct format_tbl);\r\nif (arg == 0)\r\nreturn portc->audio_format;\r\nif (!(arg & ad_format_mask[devc->model]))\r\narg = AFMT_U8;\r\nportc->audio_format = arg;\r\nfor (i = 0; i < n; i++)\r\nif (format2bits[i].format == arg)\r\n{\r\nif ((portc->format_bits = format2bits[i].bits) == 0)\r\nreturn portc->audio_format = AFMT_U8;\r\nreturn arg;\r\n}\r\nportc->format_bits = 0;\r\nreturn portc->audio_format = AFMT_U8;\r\n}\r\nstatic int ad1848_open(int dev, int mode)\r\n{\r\nad1848_info *devc;\r\nad1848_port_info *portc;\r\nunsigned long flags;\r\nif (dev < 0 || dev >= num_audiodevs)\r\nreturn -ENXIO;\r\ndevc = (ad1848_info *) audio_devs[dev]->devc;\r\nportc = (ad1848_port_info *) audio_devs[dev]->portc;\r\nspin_lock(&devc->lock);\r\nif (portc->open_mode || (devc->open_mode & mode))\r\n{\r\nspin_unlock(&devc->lock);\r\nreturn -EBUSY;\r\n}\r\ndevc->dual_dma = 0;\r\nif (audio_devs[dev]->flags & DMA_DUPLEX)\r\n{\r\ndevc->dual_dma = 1;\r\n}\r\ndevc->intr_active = 0;\r\ndevc->audio_mode = 0;\r\ndevc->open_mode |= mode;\r\nportc->open_mode = mode;\r\nspin_unlock(&devc->lock);\r\nad1848_trigger(dev, 0);\r\nif (mode & OPEN_READ)\r\ndevc->record_dev = dev;\r\nif (mode & OPEN_WRITE)\r\ndevc->playback_dev = dev;\r\nspin_lock_irqsave(&devc->lock,flags);\r\nad_mute(devc);\r\nspin_unlock_irqrestore(&devc->lock,flags);\r\nreturn 0;\r\n}\r\nstatic void ad1848_close(int dev)\r\n{\r\nunsigned long flags;\r\nad1848_info *devc = (ad1848_info *) audio_devs[dev]->devc;\r\nad1848_port_info *portc = (ad1848_port_info *) audio_devs[dev]->portc;\r\ndevc->intr_active = 0;\r\nad1848_halt(dev);\r\nspin_lock_irqsave(&devc->lock,flags);\r\ndevc->audio_mode = 0;\r\ndevc->open_mode &= ~portc->open_mode;\r\nportc->open_mode = 0;\r\nad_unmute(devc);\r\nspin_unlock_irqrestore(&devc->lock,flags);\r\n}\r\nstatic void ad1848_output_block(int dev, unsigned long buf, int count, int intrflag)\r\n{\r\nunsigned long flags, cnt;\r\nad1848_info *devc = (ad1848_info *) audio_devs[dev]->devc;\r\nad1848_port_info *portc = (ad1848_port_info *) audio_devs[dev]->portc;\r\ncnt = count;\r\nif (portc->audio_format == AFMT_IMA_ADPCM)\r\n{\r\ncnt /= 4;\r\n}\r\nelse\r\n{\r\nif (portc->audio_format & (AFMT_S16_LE | AFMT_S16_BE))\r\ncnt >>= 1;\r\n}\r\nif (portc->channels > 1)\r\ncnt >>= 1;\r\ncnt--;\r\nif ((devc->audio_mode & PCM_ENABLE_OUTPUT) && (audio_devs[dev]->flags & DMA_AUTOMODE) &&\r\nintrflag &&\r\ncnt == devc->xfer_count)\r\n{\r\ndevc->audio_mode |= PCM_ENABLE_OUTPUT;\r\ndevc->intr_active = 1;\r\nreturn;\r\n}\r\nspin_lock_irqsave(&devc->lock,flags);\r\nad_write(devc, 15, (unsigned char) (cnt & 0xff));\r\nad_write(devc, 14, (unsigned char) ((cnt >> 8) & 0xff));\r\ndevc->xfer_count = cnt;\r\ndevc->audio_mode |= PCM_ENABLE_OUTPUT;\r\ndevc->intr_active = 1;\r\nspin_unlock_irqrestore(&devc->lock,flags);\r\n}\r\nstatic void ad1848_start_input(int dev, unsigned long buf, int count, int intrflag)\r\n{\r\nunsigned long flags, cnt;\r\nad1848_info *devc = (ad1848_info *) audio_devs[dev]->devc;\r\nad1848_port_info *portc = (ad1848_port_info *) audio_devs[dev]->portc;\r\ncnt = count;\r\nif (portc->audio_format == AFMT_IMA_ADPCM)\r\n{\r\ncnt /= 4;\r\n}\r\nelse\r\n{\r\nif (portc->audio_format & (AFMT_S16_LE | AFMT_S16_BE))\r\ncnt >>= 1;\r\n}\r\nif (portc->channels > 1)\r\ncnt >>= 1;\r\ncnt--;\r\nif ((devc->audio_mode & PCM_ENABLE_INPUT) && (audio_devs[dev]->flags & DMA_AUTOMODE) &&\r\nintrflag &&\r\ncnt == devc->xfer_count)\r\n{\r\ndevc->audio_mode |= PCM_ENABLE_INPUT;\r\ndevc->intr_active = 1;\r\nreturn;\r\n}\r\nspin_lock_irqsave(&devc->lock,flags);\r\nif (devc->model == MD_1848)\r\n{\r\nad_write(devc, 15, (unsigned char) (cnt & 0xff));\r\nad_write(devc, 14, (unsigned char) ((cnt >> 8) & 0xff));\r\n}\r\nelse\r\n{\r\nad_write(devc, 31, (unsigned char) (cnt & 0xff));\r\nad_write(devc, 30, (unsigned char) ((cnt >> 8) & 0xff));\r\n}\r\nad_unmute(devc);\r\ndevc->xfer_count = cnt;\r\ndevc->audio_mode |= PCM_ENABLE_INPUT;\r\ndevc->intr_active = 1;\r\nspin_unlock_irqrestore(&devc->lock,flags);\r\n}\r\nstatic int ad1848_prepare_for_output(int dev, int bsize, int bcount)\r\n{\r\nint timeout;\r\nunsigned char fs, old_fs, tmp = 0;\r\nunsigned long flags;\r\nad1848_info *devc = (ad1848_info *) audio_devs[dev]->devc;\r\nad1848_port_info *portc = (ad1848_port_info *) audio_devs[dev]->portc;\r\nad_mute(devc);\r\nspin_lock_irqsave(&devc->lock,flags);\r\nfs = portc->speed_bits | (portc->format_bits << 5);\r\nif (portc->channels > 1)\r\nfs |= 0x10;\r\nad_enter_MCE(devc);\r\nif (devc->model == MD_1845 || devc->model == MD_1845_SSCAPE)\r\n{\r\nfs &= 0xf0;\r\nad_write(devc, 22, (portc->speed >> 8) & 0xff);\r\nad_write(devc, 23, portc->speed & 0xff);\r\n}\r\nold_fs = ad_read(devc, 8);\r\nif (devc->model == MD_4232 || devc->model >= MD_4236)\r\n{\r\ntmp = ad_read(devc, 16);\r\nad_write(devc, 16, tmp | 0x30);\r\n}\r\nif (devc->model == MD_IWAVE)\r\nad_write(devc, 17, 0xc2);\r\nad_write(devc, 8, fs);\r\ntimeout = 0;\r\nwhile (timeout < 100 && inb(devc->base) != 0x80)\r\ntimeout++;\r\ntimeout = 0;\r\nwhile (timeout < 10000 && inb(devc->base) == 0x80)\r\ntimeout++;\r\nif (devc->model >= MD_4232)\r\nad_write(devc, 16, tmp & ~0x30);\r\nad_leave_MCE(devc);\r\nspin_unlock_irqrestore(&devc->lock,flags);\r\ndevc->xfer_count = 0;\r\n#ifndef EXCLUDE_TIMERS\r\nif (dev == timer_installed && devc->timer_running)\r\nif ((fs & 0x01) != (old_fs & 0x01))\r\n{\r\nad1848_tmr_reprogram(dev);\r\n}\r\n#endif\r\nad1848_halt_output(dev);\r\nreturn 0;\r\n}\r\nstatic int ad1848_prepare_for_input(int dev, int bsize, int bcount)\r\n{\r\nint timeout;\r\nunsigned char fs, old_fs, tmp = 0;\r\nunsigned long flags;\r\nad1848_info *devc = (ad1848_info *) audio_devs[dev]->devc;\r\nad1848_port_info *portc = (ad1848_port_info *) audio_devs[dev]->portc;\r\nif (devc->audio_mode)\r\nreturn 0;\r\nspin_lock_irqsave(&devc->lock,flags);\r\nfs = portc->speed_bits | (portc->format_bits << 5);\r\nif (portc->channels > 1)\r\nfs |= 0x10;\r\nad_enter_MCE(devc);\r\nif ((devc->model == MD_1845) || (devc->model == MD_1845_SSCAPE))\r\n{\r\nfs &= 0xf0;\r\nad_write(devc, 22, (portc->speed >> 8) & 0xff);\r\nad_write(devc, 23, portc->speed & 0xff);\r\n}\r\nif (devc->model == MD_4232)\r\n{\r\ntmp = ad_read(devc, 16);\r\nad_write(devc, 16, tmp | 0x30);\r\n}\r\nif (devc->model == MD_IWAVE)\r\nad_write(devc, 17, 0xc2);\r\nif (devc->model != MD_1848)\r\n{\r\nold_fs = ad_read(devc, 28);\r\nad_write(devc, 28, fs);\r\ntimeout = 0;\r\nwhile (timeout < 100 && inb(devc->base) != 0x80)\r\ntimeout++;\r\ntimeout = 0;\r\nwhile (timeout < 10000 && inb(devc->base) == 0x80)\r\ntimeout++;\r\nif (devc->model != MD_1848 && devc->model != MD_1845 && devc->model != MD_1845_SSCAPE)\r\n{\r\nunsigned char tmp = portc->speed_bits | (ad_read(devc, 8) & 0xf0);\r\nad_write(devc, 8, tmp);\r\ntimeout = 0;\r\nwhile (timeout < 100 && inb(devc->base) != 0x80)\r\ntimeout++;\r\ntimeout = 0;\r\nwhile (timeout < 10000 && inb(devc->base) == 0x80)\r\ntimeout++;\r\n}\r\n}\r\nelse\r\n{\r\nold_fs = ad_read(devc, 8);\r\nad_write(devc, 8, fs);\r\ntimeout = 0;\r\nwhile (timeout < 100 && inb(devc->base) != 0x80)\r\ntimeout++;\r\ntimeout = 0;\r\nwhile (timeout < 10000 && inb(devc->base) == 0x80)\r\ntimeout++;\r\n}\r\nif (devc->model == MD_4232)\r\nad_write(devc, 16, tmp & ~0x30);\r\nad_leave_MCE(devc);\r\nspin_unlock_irqrestore(&devc->lock,flags);\r\ndevc->xfer_count = 0;\r\n#ifndef EXCLUDE_TIMERS\r\nif (dev == timer_installed && devc->timer_running)\r\n{\r\nif ((fs & 0x01) != (old_fs & 0x01))\r\n{\r\nad1848_tmr_reprogram(dev);\r\n}\r\n}\r\n#endif\r\nad1848_halt_input(dev);\r\nreturn 0;\r\n}\r\nstatic void ad1848_halt(int dev)\r\n{\r\nad1848_info *devc = (ad1848_info *) audio_devs[dev]->devc;\r\nad1848_port_info *portc = (ad1848_port_info *) audio_devs[dev]->portc;\r\nunsigned char bits = ad_read(devc, 9);\r\nif (bits & 0x01 && (portc->open_mode & OPEN_WRITE))\r\nad1848_halt_output(dev);\r\nif (bits & 0x02 && (portc->open_mode & OPEN_READ))\r\nad1848_halt_input(dev);\r\ndevc->audio_mode = 0;\r\n}\r\nstatic void ad1848_halt_input(int dev)\r\n{\r\nad1848_info *devc = (ad1848_info *) audio_devs[dev]->devc;\r\nunsigned long flags;\r\nif (!(ad_read(devc, 9) & 0x02))\r\nreturn;\r\nspin_lock_irqsave(&devc->lock,flags);\r\nad_mute(devc);\r\n{\r\nint tmout;\r\nif(!isa_dma_bridge_buggy)\r\ndisable_dma(audio_devs[dev]->dmap_in->dma);\r\nfor (tmout = 0; tmout < 100000; tmout++)\r\nif (ad_read(devc, 11) & 0x10)\r\nbreak;\r\nad_write(devc, 9, ad_read(devc, 9) & ~0x02);\r\nif(!isa_dma_bridge_buggy)\r\nenable_dma(audio_devs[dev]->dmap_in->dma);\r\ndevc->audio_mode &= ~PCM_ENABLE_INPUT;\r\n}\r\noutb(0, io_Status(devc));\r\noutb(0, io_Status(devc));\r\ndevc->audio_mode &= ~PCM_ENABLE_INPUT;\r\nspin_unlock_irqrestore(&devc->lock,flags);\r\n}\r\nstatic void ad1848_halt_output(int dev)\r\n{\r\nad1848_info *devc = (ad1848_info *) audio_devs[dev]->devc;\r\nunsigned long flags;\r\nif (!(ad_read(devc, 9) & 0x01))\r\nreturn;\r\nspin_lock_irqsave(&devc->lock,flags);\r\nad_mute(devc);\r\n{\r\nint tmout;\r\nif(!isa_dma_bridge_buggy)\r\ndisable_dma(audio_devs[dev]->dmap_out->dma);\r\nfor (tmout = 0; tmout < 100000; tmout++)\r\nif (ad_read(devc, 11) & 0x10)\r\nbreak;\r\nad_write(devc, 9, ad_read(devc, 9) & ~0x01);\r\nif(!isa_dma_bridge_buggy)\r\nenable_dma(audio_devs[dev]->dmap_out->dma);\r\ndevc->audio_mode &= ~PCM_ENABLE_OUTPUT;\r\n}\r\noutb((0), io_Status(devc));\r\noutb((0), io_Status(devc));\r\ndevc->audio_mode &= ~PCM_ENABLE_OUTPUT;\r\nspin_unlock_irqrestore(&devc->lock,flags);\r\n}\r\nstatic void ad1848_trigger(int dev, int state)\r\n{\r\nad1848_info *devc = (ad1848_info *) audio_devs[dev]->devc;\r\nad1848_port_info *portc = (ad1848_port_info *) audio_devs[dev]->portc;\r\nunsigned long flags;\r\nunsigned char tmp, old;\r\nspin_lock_irqsave(&devc->lock,flags);\r\nstate &= devc->audio_mode;\r\ntmp = old = ad_read(devc, 9);\r\nif (portc->open_mode & OPEN_READ)\r\n{\r\nif (state & PCM_ENABLE_INPUT)\r\ntmp |= 0x02;\r\nelse\r\ntmp &= ~0x02;\r\n}\r\nif (portc->open_mode & OPEN_WRITE)\r\n{\r\nif (state & PCM_ENABLE_OUTPUT)\r\ntmp |= 0x01;\r\nelse\r\ntmp &= ~0x01;\r\n}\r\nif (tmp != old)\r\n{\r\nad_write(devc, 9, tmp);\r\nad_unmute(devc);\r\n}\r\nspin_unlock_irqrestore(&devc->lock,flags);\r\n}\r\nstatic void ad1848_init_hw(ad1848_info * devc)\r\n{\r\nint i;\r\nint *init_values;\r\nstatic int init_values_a[] =\r\n{\r\n0xa8, 0xa8, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00,\r\n0x00, 0x0c, 0x02, 0x00, 0x8a, 0x01, 0x00, 0x00,\r\n0x80, 0x00, 0x10, 0x10, 0x00, 0x00, 0x1f, 0x40,\r\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\r\n};\r\nstatic int init_values_b[] =\r\n{\r\n0xa8, 0xa8, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00,\r\n0x00, 0x00, 0x06, 0x00, 0xe0, 0x01, 0x00, 0x00,\r\n0x80, 0x00, 0x10, 0x10, 0x00, 0x00, 0x1f, 0x40,\r\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\r\n};\r\ninit_values = init_values_a;\r\nif(devc->model >= MD_4236)\r\ninit_values = init_values_b;\r\nfor (i = 0; i < 16; i++)\r\nad_write(devc, i, init_values[i]);\r\nad_mute(devc);\r\nad_unmute(devc);\r\nif (devc->model > MD_1848)\r\n{\r\nif (devc->model == MD_1845_SSCAPE)\r\nad_write(devc, 12, ad_read(devc, 12) | 0x50);\r\nelse\r\nad_write(devc, 12, ad_read(devc, 12) | 0x40);\r\nif (devc->model == MD_IWAVE)\r\nad_write(devc, 12, 0x6c);\r\nif (devc->model != MD_1845_SSCAPE)\r\nfor (i = 16; i < 32; i++)\r\nad_write(devc, i, init_values[i]);\r\nif (devc->model == MD_IWAVE)\r\nad_write(devc, 16, 0x30);\r\n}\r\nif (devc->model > MD_1848)\r\n{\r\nif (devc->audio_flags & DMA_DUPLEX)\r\nad_write(devc, 9, ad_read(devc, 9) & ~0x04);\r\nelse\r\nad_write(devc, 9, ad_read(devc, 9) | 0x04);\r\nif (devc->model == MD_1845 || devc->model == MD_1845_SSCAPE)\r\nad_write(devc, 27, ad_read(devc, 27) | 0x08);\r\nif (devc->model == MD_IWAVE)\r\n{\r\nad_write(devc, 12, 0x6c);\r\nad_write(devc, 16, 0x30);\r\nad_write(devc, 17, 0xc2);\r\n}\r\n}\r\nelse\r\n{\r\ndevc->audio_flags &= ~DMA_DUPLEX;\r\nad_write(devc, 9, ad_read(devc, 9) | 0x04);\r\nif (soundpro)\r\nad_write(devc, 12, ad_read(devc, 12) | 0x40);\r\n}\r\noutb((0), io_Status(devc));\r\nad_enter_MCE(devc);\r\nad_leave_MCE(devc);\r\nad1848_mixer_reset(devc);\r\n}\r\nint ad1848_detect(struct resource *ports, int *ad_flags, int *osp)\r\n{\r\nunsigned char tmp;\r\nad1848_info *devc = &adev_info[nr_ad1848_devs];\r\nunsigned char tmp1 = 0xff, tmp2 = 0xff;\r\nint optiC930 = 0;\r\nint interwave = 0;\r\nint ad1847_flag = 0;\r\nint cs4248_flag = 0;\r\nint sscape_flag = 0;\r\nint io_base = ports->start;\r\nint i;\r\nDDB(printk("ad1848_detect(%x)\n", io_base));\r\nif (ad_flags)\r\n{\r\nif (*ad_flags == 0x12345678)\r\n{\r\ninterwave = 1;\r\n*ad_flags = 0;\r\n}\r\nif (*ad_flags == 0x87654321)\r\n{\r\nsscape_flag = 1;\r\n*ad_flags = 0;\r\n}\r\nif (*ad_flags == 0x12345677)\r\n{\r\ncs4248_flag = 1;\r\n*ad_flags = 0;\r\n}\r\n}\r\nif (nr_ad1848_devs >= MAX_AUDIO_DEV)\r\n{\r\nprintk(KERN_ERR "ad1848 - Too many audio devices\n");\r\nreturn 0;\r\n}\r\nspin_lock_init(&devc->lock);\r\ndevc->base = io_base;\r\ndevc->irq_ok = 0;\r\ndevc->timer_running = 0;\r\ndevc->MCE_bit = 0x40;\r\ndevc->irq = 0;\r\ndevc->open_mode = 0;\r\ndevc->chip_name = devc->name = "AD1848";\r\ndevc->model = MD_1848;\r\ndevc->levels = NULL;\r\ndevc->debug_flag = 0;\r\nif (inb(devc->base) == 0xff)\r\n{\r\nDDB(printk("ad1848_detect: The base I/O address appears to be dead\n"));\r\n}\r\nDDB(printk("ad1848_detect() - step 0\n"));\r\nfor (i = 0; i < 10000000; i++)\r\n{\r\nunsigned char x = inb(devc->base);\r\nif (x == 0xff || !(x & 0x80))\r\nbreak;\r\n}\r\nDDB(printk("ad1848_detect() - step A\n"));\r\nif (inb(devc->base) == 0x80)\r\nad_leave_MCE(devc);\r\nif ((inb(devc->base) & 0x80) != 0x00)\r\n{\r\nDDB(printk("ad1848 detect error - step A (%02x)\n", (int) inb(devc->base)));\r\nreturn 0;\r\n}\r\nDDB(printk("ad1848_detect() - step B\n"));\r\nad_write(devc, 0, 0xaa);\r\nad_write(devc, 1, 0x45);\r\nif ((tmp1 = ad_read(devc, 0)) != 0xaa || (tmp2 = ad_read(devc, 1)) != 0x45)\r\n{\r\nif (tmp2 == 0x65)\r\nad1847_flag = 1;\r\nelse\r\n{\r\nDDB(printk("ad1848 detect error - step B (%x/%x)\n", tmp1, tmp2));\r\nreturn 0;\r\n}\r\n}\r\nDDB(printk("ad1848_detect() - step C\n"));\r\nad_write(devc, 0, 0x45);\r\nad_write(devc, 1, 0xaa);\r\nif ((tmp1 = ad_read(devc, 0)) != 0x45 || (tmp2 = ad_read(devc, 1)) != 0xaa)\r\n{\r\nif (tmp2 == 0x8a)\r\nad1847_flag = 1;\r\nelse\r\n{\r\nDDB(printk("ad1848 detect error - step C (%x/%x)\n", tmp1, tmp2));\r\nreturn 0;\r\n}\r\n}\r\nDDB(printk("ad1848_detect() - step D\n"));\r\ntmp = ad_read(devc, 12);\r\nad_write(devc, 12, (~tmp) & 0x0f);\r\nif ((tmp & 0x0f) != ((tmp1 = ad_read(devc, 12)) & 0x0f))\r\n{\r\nDDB(printk("ad1848 detect error - step D (%x)\n", tmp1));\r\nreturn 0;\r\n}\r\nDDB(printk("ad1848_detect() - step F\n"));\r\nad_write(devc, 12, 0);\r\nfor (i = 0; i < 16; i++)\r\n{\r\nif ((tmp1 = ad_read(devc, i)) != (tmp2 = ad_read(devc, i + 16)))\r\n{\r\nDDB(printk("ad1848 detect step F(%d/%x/%x) - OPTi chip???\n", i, tmp1, tmp2));\r\nif (!ad1847_flag)\r\noptiC930 = 1;\r\nbreak;\r\n}\r\n}\r\nDDB(printk("ad1848_detect() - step G\n"));\r\nif (ad_flags && *ad_flags == 400)\r\n*ad_flags = 0;\r\nelse\r\nad_write(devc, 12, 0x40);\r\nif (ad_flags)\r\n*ad_flags = 0;\r\ntmp1 = ad_read(devc, 12);\r\nif (tmp1 & 0x80)\r\n{\r\nif (ad_flags)\r\n*ad_flags |= AD_F_CS4248;\r\ndevc->chip_name = "CS4248";\r\n}\r\nif (optiC930 || (tmp1 & 0xc0) == (0x80 | 0x40))\r\n{\r\nDDB(printk("ad1848_detect() - step H\n"));\r\nad_write(devc, 16, 0);\r\nad_write(devc, 0, 0x45);\r\nif ((tmp1 = ad_read(devc, 16)) != 0x45)\r\n{\r\nad_write(devc, 0, 0xaa);\r\nif ((tmp1 = ad_read(devc, 16)) == 0xaa)\r\n{\r\nDDB(printk("ad1848 detect error - step H(%x)\n", tmp1));\r\nreturn 0;\r\n}\r\nDDB(printk("ad1848_detect() - step I\n"));\r\ntmp1 = ad_read(devc, 25);\r\nad_write(devc, 25, ~tmp1);\r\nif ((ad_read(devc, 25) & 0xe7) == (tmp1 & 0xe7))\r\n{\r\nint id;\r\ndevc->chip_name = "CS4231";\r\ndevc->model = MD_4231;\r\nid = ad_read(devc, 25);\r\nif ((id & 0xe7) == 0x80)\r\nid = ad_read(devc, 25);\r\nif ((id & 0xe7) == 0x80)\r\nid = ad_read(devc, 25);\r\nDDB(printk("ad1848_detect() - step J (%02x/%02x)\n", id, ad_read(devc, 25)));\r\nif ((id & 0xe7) == 0x80) {\r\nunsigned char tmp = ad_read(devc, 23);\r\nad_write(devc, 23, ~tmp);\r\nif (interwave)\r\n{\r\ndevc->model = MD_IWAVE;\r\ndevc->chip_name = "IWave";\r\n}\r\nelse if (ad_read(devc, 23) != tmp)\r\n{\r\ndevc->chip_name = "AD1845";\r\ndevc->model = MD_1845;\r\n}\r\nelse if (cs4248_flag)\r\n{\r\nif (ad_flags)\r\n*ad_flags |= AD_F_CS4248;\r\ndevc->chip_name = "CS4248";\r\ndevc->model = MD_1848;\r\nad_write(devc, 12, ad_read(devc, 12) & ~0x40);\r\n}\r\nad_write(devc, 23, tmp);\r\n}\r\nelse\r\n{\r\nswitch (id & 0x1f) {\r\ncase 3:\r\n{\r\nint xid;\r\nad_write(devc, 12, ad_read(devc, 12) | 0x60);\r\nad_write(devc, 23, 0x9c);\r\nxid = inb(io_Indexed_Data(devc));\r\nad_write(devc, 12, ad_read(devc, 12) & ~0x60);\r\nswitch (xid & 0x1f)\r\n{\r\ncase 0x00:\r\ndevc->chip_name = "CS4237B(B)";\r\ndevc->model = MD_42xB;\r\nbreak;\r\ncase 0x08:\r\ndevc->chip_name = "CS4238";\r\ndevc->model = MD_42xB;\r\nbreak;\r\ncase 0x09:\r\ndevc->chip_name = "CS4238B";\r\ndevc->model = MD_42xB;\r\nbreak;\r\ncase 0x0b:\r\ndevc->chip_name = "CS4236B";\r\ndevc->model = MD_4236;\r\nbreak;\r\ncase 0x10:\r\ndevc->chip_name = "CS4237B";\r\ndevc->model = MD_42xB;\r\nbreak;\r\ncase 0x1d:\r\ndevc->chip_name = "CS4235";\r\ndevc->model = MD_4235;\r\nbreak;\r\ncase 0x1e:\r\ndevc->chip_name = "CS4239";\r\ndevc->model = MD_4239;\r\nbreak;\r\ndefault:\r\nprintk("Chip ident is %X.\n", xid&0x1F);\r\ndevc->chip_name = "CS42xx";\r\ndevc->model = MD_4232;\r\nbreak;\r\n}\r\n}\r\nbreak;\r\ncase 2:\r\ndevc->chip_name = "CS4232";\r\ndevc->model = MD_4232;\r\nbreak;\r\ncase 0:\r\nif ((id & 0xe0) == 0xa0)\r\n{\r\ndevc->chip_name = "CS4231A";\r\ndevc->model = MD_4231A;\r\n}\r\nelse\r\n{\r\ndevc->chip_name = "CS4321";\r\ndevc->model = MD_4231;\r\n}\r\nbreak;\r\ndefault:\r\nDDB(printk("ad1848: I25 = %02x/%02x\n", ad_read(devc, 25), ad_read(devc, 25) & 0xe7));\r\nif (optiC930)\r\n{\r\ndevc->chip_name = "82C930";\r\ndevc->model = MD_C930;\r\n}\r\nelse\r\n{\r\ndevc->chip_name = "CS4231";\r\ndevc->model = MD_4231;\r\n}\r\n}\r\n}\r\n}\r\nad_write(devc, 25, tmp1);\r\nDDB(printk("ad1848_detect() - step K\n"));\r\n}\r\n} else if (tmp1 == 0x0a) {\r\nfor (i = 0; i < 16; i++) {\r\nif ((tmp1 = ad_read(devc, i)) != (tmp2 = ad_read(devc, i + 16))) {\r\nDDB(printk("ad1848 detect step H(%d/%x/%x) - SoundPro chip?\n", i, tmp1, tmp2));\r\nsoundpro = 1;\r\ndevc->chip_name = "SoundPro CMI 8330";\r\nbreak;\r\n}\r\n}\r\n}\r\nDDB(printk("ad1848_detect() - step L\n"));\r\nif (ad_flags)\r\n{\r\nif (devc->model != MD_1848)\r\n*ad_flags |= AD_F_CS4231;\r\n}\r\nDDB(printk("ad1848_detect() - Detected OK\n"));\r\nif (devc->model == MD_1848 && ad1847_flag)\r\ndevc->chip_name = "AD1847";\r\nif (sscape_flag == 1)\r\ndevc->model = MD_1845_SSCAPE;\r\nreturn 1;\r\n}\r\nint ad1848_init (char *name, struct resource *ports, int irq, int dma_playback,\r\nint dma_capture, int share_dma, int *osp, struct module *owner)\r\n{\r\nint my_dev;\r\nchar dev_name[100];\r\nint e;\r\nad1848_info *devc = &adev_info[nr_ad1848_devs];\r\nad1848_port_info *portc = NULL;\r\ndevc->irq = (irq > 0) ? irq : 0;\r\ndevc->open_mode = 0;\r\ndevc->timer_ticks = 0;\r\ndevc->dma1 = dma_playback;\r\ndevc->dma2 = dma_capture;\r\ndevc->subtype = cfg.card_subtype;\r\ndevc->audio_flags = DMA_AUTOMODE;\r\ndevc->playback_dev = devc->record_dev = 0;\r\nif (name != NULL)\r\ndevc->name = name;\r\nif (name != NULL && name[0] != 0)\r\nsprintf(dev_name,\r\n"%s (%s)", name, devc->chip_name);\r\nelse\r\nsprintf(dev_name,\r\n"Generic audio codec (%s)", devc->chip_name);\r\nrename_region(ports, devc->name);\r\nconf_printf2(dev_name, devc->base, devc->irq, dma_playback, dma_capture);\r\nif (devc->model == MD_1848 || devc->model == MD_C930)\r\ndevc->audio_flags |= DMA_HARDSTOP;\r\nif (devc->model > MD_1848)\r\n{\r\nif (devc->dma1 == devc->dma2 || devc->dma2 == -1 || devc->dma1 == -1)\r\ndevc->audio_flags &= ~DMA_DUPLEX;\r\nelse\r\ndevc->audio_flags |= DMA_DUPLEX;\r\n}\r\nportc = kmalloc(sizeof(ad1848_port_info), GFP_KERNEL);\r\nif(portc==NULL) {\r\nrelease_region(devc->base, 4);\r\nreturn -1;\r\n}\r\nif ((my_dev = sound_install_audiodrv(AUDIO_DRIVER_VERSION,\r\ndev_name,\r\n&ad1848_audio_driver,\r\nsizeof(struct audio_driver),\r\ndevc->audio_flags,\r\nad_format_mask[devc->model],\r\ndevc,\r\ndma_playback,\r\ndma_capture)) < 0)\r\n{\r\nrelease_region(devc->base, 4);\r\nkfree(portc);\r\nreturn -1;\r\n}\r\naudio_devs[my_dev]->portc = portc;\r\naudio_devs[my_dev]->mixer_dev = -1;\r\nif (owner)\r\naudio_devs[my_dev]->d->owner = owner;\r\nmemset((char *) portc, 0, sizeof(*portc));\r\nnr_ad1848_devs++;\r\nad1848_init_hw(devc);\r\nif (irq > 0)\r\n{\r\ndevc->dev_no = my_dev;\r\nif (request_irq(devc->irq, adintr, 0, devc->name,\r\n(void *)(long)my_dev) < 0)\r\n{\r\nprintk(KERN_WARNING "ad1848: Unable to allocate IRQ\n");\r\ndevc->irq = 0;\r\n}\r\nif (capabilities[devc->model].flags & CAP_F_TIMER)\r\n{\r\n#ifndef CONFIG_SMP\r\nint x;\r\nunsigned char tmp = ad_read(devc, 16);\r\n#endif\r\ndevc->timer_ticks = 0;\r\nad_write(devc, 21, 0x00);\r\nad_write(devc, 20, 0x10);\r\n#ifndef CONFIG_SMP\r\nad_write(devc, 16, tmp | 0x40);\r\nfor (x = 0; x < 100000 && devc->timer_ticks == 0; x++);\r\nad_write(devc, 16, tmp & ~0x40);\r\nif (devc->timer_ticks == 0)\r\nprintk(KERN_WARNING "ad1848: Interrupt test failed (IRQ%d)\n", irq);\r\nelse\r\n{\r\nDDB(printk("Interrupt test OK\n"));\r\ndevc->irq_ok = 1;\r\n}\r\n#else\r\ndevc->irq_ok = 1;\r\n#endif\r\n}\r\nelse\r\ndevc->irq_ok = 1;\r\n} else if (irq < 0)\r\ndevc->dev_no = my_dev;\r\n#ifndef EXCLUDE_TIMERS\r\nif ((capabilities[devc->model].flags & CAP_F_TIMER) &&\r\ndevc->irq_ok)\r\nad1848_tmr_install(my_dev);\r\n#endif\r\nif (!share_dma)\r\n{\r\nif (sound_alloc_dma(dma_playback, devc->name))\r\nprintk(KERN_WARNING "ad1848.c: Can't allocate DMA%d\n", dma_playback);\r\nif (dma_capture != dma_playback)\r\nif (sound_alloc_dma(dma_capture, devc->name))\r\nprintk(KERN_WARNING "ad1848.c: Can't allocate DMA%d\n", dma_capture);\r\n}\r\nif ((e = sound_install_mixer(MIXER_DRIVER_VERSION,\r\ndev_name,\r\n&ad1848_mixer_operations,\r\nsizeof(struct mixer_operations),\r\ndevc)) >= 0)\r\n{\r\naudio_devs[my_dev]->mixer_dev = e;\r\nif (owner)\r\nmixer_devs[e]->owner = owner;\r\n}\r\nreturn my_dev;\r\n}\r\nint ad1848_control(int cmd, int arg)\r\n{\r\nad1848_info *devc;\r\nunsigned long flags;\r\nif (nr_ad1848_devs < 1)\r\nreturn -ENODEV;\r\ndevc = &adev_info[nr_ad1848_devs - 1];\r\nswitch (cmd)\r\n{\r\ncase AD1848_SET_XTAL:\r\nif (devc->model != MD_1845 && devc->model != MD_1845_SSCAPE)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&devc->lock,flags);\r\nad_enter_MCE(devc);\r\nad_write(devc, 29, (ad_read(devc, 29) & 0x1f) | (arg << 5));\r\nad_leave_MCE(devc);\r\nspin_unlock_irqrestore(&devc->lock,flags);\r\nbreak;\r\ncase AD1848_MIXER_REROUTE:\r\n{\r\nint o = (arg >> 8) & 0xff;\r\nint n = arg & 0xff;\r\nif (o < 0 || o >= SOUND_MIXER_NRDEVICES)\r\nreturn -EINVAL;\r\nif (!(devc->supported_devices & (1 << o)) &&\r\n!(devc->supported_rec_devices & (1 << o)))\r\nreturn -EINVAL;\r\nif (n == SOUND_MIXER_NONE)\r\n{\r\nad1848_mixer_set(devc, o, 0);\r\ndevc->supported_devices &= ~(1 << o);\r\ndevc->supported_rec_devices &= ~(1 << o);\r\nbreak;\r\n}\r\nif (n < 0 || n >= SOUND_MIXER_NRDEVICES)\r\nreturn -EINVAL;\r\ndevc->mixer_reroute[n] = o;\r\nif (devc->supported_devices & (1 << o))\r\ndevc->supported_devices |= (1 << n);\r\nif (devc->supported_rec_devices & (1 << o))\r\ndevc->supported_rec_devices |= (1 << n);\r\ndevc->supported_devices &= ~(1 << o);\r\ndevc->supported_rec_devices &= ~(1 << o);\r\n}\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nvoid ad1848_unload(int io_base, int irq, int dma_playback, int dma_capture, int share_dma)\r\n{\r\nint i, mixer, dev = 0;\r\nad1848_info *devc = NULL;\r\nfor (i = 0; devc == NULL && i < nr_ad1848_devs; i++)\r\n{\r\nif (adev_info[i].base == io_base)\r\n{\r\ndevc = &adev_info[i];\r\ndev = devc->dev_no;\r\n}\r\n}\r\nif (devc != NULL)\r\n{\r\nkfree(audio_devs[dev]->portc);\r\nrelease_region(devc->base, 4);\r\nif (!share_dma)\r\n{\r\nif (devc->irq > 0)\r\nfree_irq(devc->irq, (void *)(long)devc->dev_no);\r\nsound_free_dma(dma_playback);\r\nif (dma_playback != dma_capture)\r\nsound_free_dma(dma_capture);\r\n}\r\nmixer = audio_devs[devc->dev_no]->mixer_dev;\r\nif(mixer>=0)\r\nsound_unload_mixerdev(mixer);\r\nnr_ad1848_devs--;\r\nfor ( ; i < nr_ad1848_devs ; i++)\r\nadev_info[i] = adev_info[i+1];\r\n}\r\nelse\r\nprintk(KERN_ERR "ad1848: Can't find device to be unloaded. Base=%x\n", io_base);\r\n}\r\nstatic irqreturn_t adintr(int irq, void *dev_id)\r\n{\r\nunsigned char status;\r\nad1848_info *devc;\r\nint dev;\r\nint alt_stat = 0xff;\r\nunsigned char c930_stat = 0;\r\nint cnt = 0;\r\ndev = (long)dev_id;\r\ndevc = (ad1848_info *) audio_devs[dev]->devc;\r\ninterrupt_again:\r\nstatus = inb(io_Status(devc));\r\nif (status == 0x80)\r\nprintk(KERN_DEBUG "adintr: Why?\n");\r\nif (devc->model == MD_1848)\r\noutb((0), io_Status(devc));\r\nif (status & 0x01)\r\n{\r\nif (devc->model == MD_C930)\r\n{\r\nspin_lock(&devc->lock);\r\noutb(11, 0xe0e);\r\nc930_stat = inb(0xe0f);\r\noutb((~c930_stat), 0xe0f);\r\nspin_unlock(&devc->lock);\r\nalt_stat = (c930_stat << 2) & 0x30;\r\n}\r\nelse if (devc->model != MD_1848)\r\n{\r\nspin_lock(&devc->lock);\r\nalt_stat = ad_read(devc, 24);\r\nad_write(devc, 24, ad_read(devc, 24) & ~alt_stat);\r\nspin_unlock(&devc->lock);\r\n}\r\nif ((devc->open_mode & OPEN_READ) && (devc->audio_mode & PCM_ENABLE_INPUT) && (alt_stat & 0x20))\r\n{\r\nDMAbuf_inputintr(devc->record_dev);\r\n}\r\nif ((devc->open_mode & OPEN_WRITE) && (devc->audio_mode & PCM_ENABLE_OUTPUT) &&\r\n(alt_stat & 0x10))\r\n{\r\nDMAbuf_outputintr(devc->playback_dev, 1);\r\n}\r\nif (devc->model != MD_1848 && (alt_stat & 0x40))\r\n{\r\ndevc->timer_ticks++;\r\n#ifndef EXCLUDE_TIMERS\r\nif (timer_installed == dev && devc->timer_running)\r\nsound_timer_interrupt();\r\n#endif\r\n}\r\n}\r\nif (inb(io_Status(devc)) & 0x01 && cnt++ < 4)\r\n{\r\ngoto interrupt_again;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int init_deskpro_m(struct address_info *hw_config)\r\n{\r\nunsigned char tmp;\r\nif ((tmp = inb(0xc44)) == 0xff)\r\n{\r\nDDB(printk("init_deskpro_m: Dead port 0xc44\n"));\r\nreturn 0;\r\n}\r\noutb(0x10, 0xc44);\r\noutb(0x40, 0xc45);\r\noutb(0x00, 0xc46);\r\noutb(0xe8, 0xc47);\r\noutb(0x14, 0xc44);\r\noutb(0x40, 0xc45);\r\noutb(0x00, 0xc46);\r\noutb(0xe8, 0xc47);\r\noutb(0x10, 0xc44);\r\nreturn 1;\r\n}\r\nstatic int init_deskpro(struct address_info *hw_config)\r\n{\r\nunsigned char tmp;\r\nif ((tmp = inb(0xc44)) == 0xff)\r\n{\r\nDDB(printk("init_deskpro: Dead port 0xc44\n"));\r\nreturn 0;\r\n}\r\noutb((tmp | 0x04), 0xc44);\r\nif (inb(0xc44) != 0x04)\r\n{\r\nDDB(printk("init_deskpro: Invalid bank1 signature in port 0xc44\n"));\r\nreturn 0;\r\n}\r\n#ifdef DEBUGXL\r\nprintk("Port 0xc44 (before): ");\r\noutb((tmp & ~0x04), 0xc44);\r\nprintk("%02x ", inb(0xc44));\r\noutb((tmp | 0x04), 0xc44);\r\nprintk("%02x\n", inb(0xc44));\r\n#endif\r\ntmp = 0x58;\r\nswitch (hw_config->io_base)\r\n{\r\ncase 0x530:\r\ntmp |= 0x00;\r\nbreak;\r\ncase 0x604:\r\ntmp |= 0x01;\r\nbreak;\r\ncase 0xf40:\r\ntmp |= 0x02;\r\nbreak;\r\ncase 0xe80:\r\ntmp |= 0x03;\r\nbreak;\r\ndefault:\r\nDDB(printk("init_deskpro: Invalid MSS port %x\n", hw_config->io_base));\r\nreturn 0;\r\n}\r\noutb((tmp & ~0x04), 0xc44);\r\n#ifdef DEBUGXL\r\nprintk("Port 0xc44 (after): ");\r\noutb((tmp & ~0x04), 0xc44);\r\nprintk("%02x ", inb(0xc44));\r\noutb((tmp | 0x04), 0xc44);\r\nprintk("%02x\n", inb(0xc44));\r\n#endif\r\n#ifdef DEBUGXL\r\nprintk("Port 0xc45 (before): ");\r\noutb((tmp & ~0x04), 0xc44);\r\nprintk("%02x ", inb(0xc45));\r\noutb((tmp | 0x04), 0xc44);\r\nprintk("%02x\n", inb(0xc45));\r\n#endif\r\noutb((tmp & ~0x04), 0xc44);\r\noutb((0x88), 0xc45);\r\noutb((tmp | 0x04), 0xc44);\r\noutb((0x10), 0xc45);\r\n#ifdef DEBUGXL\r\nprintk("Port 0xc45 (after): ");\r\noutb((tmp & ~0x04), 0xc44);\r\nprintk("%02x ", inb(0xc45));\r\noutb((tmp | 0x04), 0xc44);\r\nprintk("%02x\n", inb(0xc45));\r\n#endif\r\n#ifdef DEBUGXL\r\nprintk("Port 0xc46 (before): ");\r\noutb((tmp & ~0x04), 0xc44);\r\nprintk("%02x ", inb(0xc46));\r\noutb((tmp | 0x04), 0xc44);\r\nprintk("%02x\n", inb(0xc46));\r\n#endif\r\noutb((tmp & ~0x04), 0xc44);\r\noutb((0x03), 0xc46);\r\noutb((tmp | 0x04), 0xc44);\r\noutb((0x11), 0xc46);\r\n#ifdef DEBUGXL\r\nprintk("Port 0xc46 (after): ");\r\noutb((tmp & ~0x04), 0xc44);\r\nprintk("%02x ", inb(0xc46));\r\noutb((tmp | 0x04), 0xc44);\r\nprintk("%02x\n", inb(0xc46));\r\n#endif\r\n#ifdef DEBUGXL\r\nprintk("Port 0xc47 (before): ");\r\noutb((tmp & ~0x04), 0xc44);\r\nprintk("%02x ", inb(0xc47));\r\noutb((tmp | 0x04), 0xc44);\r\nprintk("%02x\n", inb(0xc47));\r\n#endif\r\noutb((tmp & ~0x04), 0xc44);\r\noutb((0x7c), 0xc47);\r\noutb((tmp | 0x04), 0xc44);\r\noutb((0x00), 0xc47);\r\n#ifdef DEBUGXL\r\nprintk("Port 0xc47 (after): ");\r\noutb((tmp & ~0x04), 0xc44);\r\nprintk("%02x ", inb(0xc47));\r\noutb((tmp | 0x04), 0xc44);\r\nprintk("%02x\n", inb(0xc47));\r\n#endif\r\n#ifdef DEBUGXL\r\nprintk("Port 0xc6f (before) = %02x\n", inb(0xc6f));\r\n#endif\r\noutb((0x80), 0xc6f);\r\n#ifdef DEBUGXL\r\nprintk("Port 0xc6f (after) = %02x\n", inb(0xc6f));\r\n#endif\r\nreturn 1;\r\n}\r\nint probe_ms_sound(struct address_info *hw_config, struct resource *ports)\r\n{\r\nunsigned char tmp;\r\nDDB(printk("Entered probe_ms_sound(%x, %d)\n", hw_config->io_base, hw_config->card_subtype));\r\nif (hw_config->card_subtype == 1)\r\n{\r\nreturn ad1848_detect(ports, NULL, hw_config->osp);\r\n}\r\nif (deskpro_xl && hw_config->card_subtype == 2)\r\n{\r\nif (!init_deskpro(hw_config))\r\nreturn 0;\r\n}\r\nif (deskpro_m)\r\n{\r\nif (!init_deskpro_m(hw_config))\r\nreturn 0;\r\n}\r\nif ((tmp = inb(hw_config->io_base + 3)) == 0xff)\r\n{\r\nint ret;\r\nDDB(printk("I/O address is inactive (%x)\n", tmp));\r\nif (!(ret = ad1848_detect(ports, NULL, hw_config->osp)))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nDDB(printk("MSS signature = %x\n", tmp & 0x3f));\r\nif ((tmp & 0x3f) != 0x04 &&\r\n(tmp & 0x3f) != 0x0f &&\r\n(tmp & 0x3f) != 0x00)\r\n{\r\nint ret;\r\nMDB(printk(KERN_ERR "No MSS signature detected on port 0x%x (0x%x)\n", hw_config->io_base, (int) inb(hw_config->io_base + 3)));\r\nDDB(printk("Trying to detect codec anyway but IRQ/DMA may not work\n"));\r\nif (!(ret = ad1848_detect(ports, NULL, hw_config->osp)))\r\nreturn 0;\r\nhw_config->card_subtype = 1;\r\nreturn 1;\r\n}\r\nif ((hw_config->irq != 5) &&\r\n(hw_config->irq != 7) &&\r\n(hw_config->irq != 9) &&\r\n(hw_config->irq != 10) &&\r\n(hw_config->irq != 11) &&\r\n(hw_config->irq != 12))\r\n{\r\nprintk(KERN_ERR "MSS: Bad IRQ %d\n", hw_config->irq);\r\nreturn 0;\r\n}\r\nif (hw_config->dma != 0 && hw_config->dma != 1 && hw_config->dma != 3)\r\n{\r\nprintk(KERN_ERR "MSS: Bad DMA %d\n", hw_config->dma);\r\nreturn 0;\r\n}\r\nif (hw_config->dma == 0 && inb(hw_config->io_base + 3) & 0x80)\r\n{\r\nprintk(KERN_ERR "MSS: Can't use DMA0 with a 8 bit card/slot\n");\r\nreturn 0;\r\n}\r\nif (hw_config->irq > 7 && hw_config->irq != 9 && inb(hw_config->io_base + 3) & 0x80)\r\n{\r\nprintk(KERN_ERR "MSS: Can't use IRQ%d with a 8 bit card/slot\n", hw_config->irq);\r\nreturn 0;\r\n}\r\nreturn ad1848_detect(ports, NULL, hw_config->osp);\r\n}\r\nvoid attach_ms_sound(struct address_info *hw_config, struct resource *ports, struct module *owner)\r\n{\r\nstatic signed char interrupt_bits[12] =\r\n{\r\n-1, -1, -1, -1, -1, 0x00, -1, 0x08, -1, 0x10, 0x18, 0x20\r\n};\r\nsigned char bits;\r\nchar dma2_bit = 0;\r\nstatic char dma_bits[4] =\r\n{\r\n1, 2, 0, 3\r\n};\r\nint config_port = hw_config->io_base + 0;\r\nint version_port = hw_config->io_base + 3;\r\nint dma = hw_config->dma;\r\nint dma2 = hw_config->dma2;\r\nif (hw_config->card_subtype == 1)\r\n{\r\nhw_config->slots[0] = ad1848_init("MS Sound System", ports,\r\nhw_config->irq,\r\nhw_config->dma,\r\nhw_config->dma2, 0,\r\nhw_config->osp,\r\nowner);\r\nreturn;\r\n}\r\nbits = interrupt_bits[hw_config->irq];\r\nif (bits == -1)\r\n{\r\nprintk(KERN_ERR "MSS: Bad IRQ %d\n", hw_config->irq);\r\nrelease_region(ports->start, 4);\r\nrelease_region(ports->start - 4, 4);\r\nreturn;\r\n}\r\noutb((bits | 0x40), config_port);\r\nif ((inb(version_port) & 0x40) == 0)\r\nprintk(KERN_ERR "[MSS: IRQ Conflict?]\n");\r\nif (dma2 != -1 && dma2 != dma)\r\n{\r\nif (!((dma == 0 && dma2 == 1) ||\r\n(dma == 1 && dma2 == 0) ||\r\n(dma == 3 && dma2 == 0)))\r\n{\r\nint tmp = dma;\r\ndma = dma2;\r\ndma2 = tmp;\r\n}\r\nif ((dma == 0 && dma2 == 1) ||\r\n(dma == 1 && dma2 == 0) ||\r\n(dma == 3 && dma2 == 0))\r\n{\r\ndma2_bit = 0x04;\r\n}\r\nelse\r\n{\r\nprintk(KERN_WARNING "MSS: Invalid capture DMA\n");\r\ndma2 = dma;\r\n}\r\n}\r\nelse\r\n{\r\ndma2 = dma;\r\n}\r\nhw_config->dma = dma;\r\nhw_config->dma2 = dma2;\r\noutb((bits | dma_bits[dma] | dma2_bit), config_port);\r\nhw_config->slots[0] = ad1848_init("MS Sound System", ports,\r\nhw_config->irq,\r\ndma, dma2, 0,\r\nhw_config->osp,\r\nTHIS_MODULE);\r\n}\r\nvoid unload_ms_sound(struct address_info *hw_config)\r\n{\r\nad1848_unload(hw_config->io_base + 4,\r\nhw_config->irq,\r\nhw_config->dma,\r\nhw_config->dma2, 0);\r\nsound_unload_audiodev(hw_config->slots[0]);\r\nrelease_region(hw_config->io_base, 4);\r\n}\r\nstatic unsigned int ad1848_tmr_start(int dev, unsigned int usecs)\r\n{\r\nunsigned long flags;\r\nad1848_info *devc = (ad1848_info *) audio_devs[dev]->devc;\r\nunsigned long xtal_nsecs;\r\nunsigned long divider;\r\nspin_lock_irqsave(&devc->lock,flags);\r\nif (devc->model == MD_1845 || devc->model == MD_1845_SSCAPE)\r\nxtal_nsecs = 10050;\r\nelse if (ad_read(devc, 8) & 0x01)\r\nxtal_nsecs = 9920;\r\nelse\r\nxtal_nsecs = 9969;\r\ndivider = (usecs * 1000 + xtal_nsecs / 2) / xtal_nsecs;\r\nif (divider < 100)\r\ndivider = 100;\r\nif (divider > 65535)\r\ndivider = 65535;\r\nad_write(devc, 21, (divider >> 8) & 0xff);\r\nad_write(devc, 20, divider & 0xff);\r\nad_write(devc, 16, ad_read(devc, 16) | 0x40);\r\ndevc->timer_running = 1;\r\nspin_unlock_irqrestore(&devc->lock,flags);\r\nreturn current_interval = (divider * xtal_nsecs + 500) / 1000;\r\n}\r\nstatic void ad1848_tmr_reprogram(int dev)\r\n{\r\nad1848_tmr_start(dev, current_interval);\r\nsound_timer_syncinterval(current_interval);\r\n}\r\nstatic void ad1848_tmr_disable(int dev)\r\n{\r\nunsigned long flags;\r\nad1848_info *devc = (ad1848_info *) audio_devs[dev]->devc;\r\nspin_lock_irqsave(&devc->lock,flags);\r\nad_write(devc, 16, ad_read(devc, 16) & ~0x40);\r\ndevc->timer_running = 0;\r\nspin_unlock_irqrestore(&devc->lock,flags);\r\n}\r\nstatic void ad1848_tmr_restart(int dev)\r\n{\r\nunsigned long flags;\r\nad1848_info *devc = (ad1848_info *) audio_devs[dev]->devc;\r\nif (current_interval == 0)\r\nreturn;\r\nspin_lock_irqsave(&devc->lock,flags);\r\nad_write(devc, 16, ad_read(devc, 16) | 0x40);\r\ndevc->timer_running = 1;\r\nspin_unlock_irqrestore(&devc->lock,flags);\r\n}\r\nstatic int ad1848_tmr_install(int dev)\r\n{\r\nif (timer_installed != -1)\r\nreturn 0;\r\ntimer_installed = ad1848_tmr.dev = dev;\r\nsound_timer_init(&ad1848_tmr, audio_devs[dev]->name);\r\nreturn 1;\r\n}\r\nstatic struct pnp_dev *activate_dev(char *devname, char *resname, struct pnp_dev *dev)\r\n{\r\nint err;\r\nerr = pnp_device_attach(dev);\r\nif (err < 0)\r\nreturn(NULL);\r\nif((err = pnp_activate_dev(dev)) < 0) {\r\nprintk(KERN_ERR "ad1848: %s %s config failed (out of resources?)[%d]\n", devname, resname, err);\r\npnp_device_detach(dev);\r\nreturn(NULL);\r\n}\r\naudio_activated = 1;\r\nreturn(dev);\r\n}\r\nstatic struct pnp_dev __init *ad1848_init_generic(struct pnp_card *bus,\r\nstruct address_info *hw_config, int slot)\r\n{\r\nif((ad1848_dev = pnp_find_dev(bus, ad1848_isapnp_list[slot].vendor, ad1848_isapnp_list[slot].function, NULL)))\r\n{\r\nif((ad1848_dev = activate_dev(ad1848_isapnp_list[slot].name, "ad1848", ad1848_dev)))\r\n{\r\nhw_config->io_base = pnp_port_start(ad1848_dev, ad1848_isapnp_list[slot].mss_io);\r\nhw_config->irq = pnp_irq(ad1848_dev, ad1848_isapnp_list[slot].irq);\r\nhw_config->dma = pnp_dma(ad1848_dev, ad1848_isapnp_list[slot].dma);\r\nif(ad1848_isapnp_list[slot].dma2 != -1)\r\nhw_config->dma2 = pnp_dma(ad1848_dev, ad1848_isapnp_list[slot].dma2);\r\nelse\r\nhw_config->dma2 = -1;\r\nhw_config->card_subtype = ad1848_isapnp_list[slot].type;\r\n} else\r\nreturn(NULL);\r\n} else\r\nreturn(NULL);\r\nreturn(ad1848_dev);\r\n}\r\nstatic int __init ad1848_isapnp_init(struct address_info *hw_config, struct pnp_card *bus, int slot)\r\n{\r\nchar *busname = bus->name[0] ? bus->name : ad1848_isapnp_list[slot].name;\r\nif(ad1848_init_generic(bus, hw_config, slot)) {\r\nprintk(KERN_NOTICE "ad1848: PnP reports '%s' at i/o %#x, irq %d, dma %d, %d\n",\r\nbusname,\r\nhw_config->io_base, hw_config->irq, hw_config->dma,\r\nhw_config->dma2);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init ad1848_isapnp_probe(struct address_info *hw_config)\r\n{\r\nstatic int first = 1;\r\nint i;\r\nfor (i = 0; ad1848_isapnp_list[i].card_vendor != 0; i++);\r\ni--;\r\nif( isapnpjump < 0 || isapnpjump > i) {\r\nisapnpjump = reverse ? i : 0;\r\nprintk(KERN_ERR "ad1848: Valid range for isapnpjump is 0-%d. Adjusted to %d.\n", i, isapnpjump);\r\n}\r\nif(!first || !reverse)\r\ni = isapnpjump;\r\nfirst = 0;\r\nwhile(ad1848_isapnp_list[i].card_vendor != 0) {\r\nstatic struct pnp_card *bus = NULL;\r\nwhile ((bus = pnp_find_card(\r\nad1848_isapnp_list[i].card_vendor,\r\nad1848_isapnp_list[i].card_device,\r\nbus))) {\r\nif(ad1848_isapnp_init(hw_config, bus, i)) {\r\nisapnpjump = i;\r\nreturn 0;\r\n}\r\n}\r\ni += reverse ? -1 : 1;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int __init init_ad1848(void)\r\n{\r\nprintk(KERN_INFO "ad1848/cs4248 codec driver Copyright (C) by Hannu Savolainen 1993-1996\n");\r\n#ifdef CONFIG_PNP\r\nif(isapnp && (ad1848_isapnp_probe(&cfg) < 0) ) {\r\nprintk(KERN_NOTICE "ad1848: No ISAPnP cards found, trying standard ones...\n");\r\nisapnp = 0;\r\n}\r\n#endif\r\nif(io != -1) {\r\nstruct resource *ports;\r\nif( isapnp == 0 )\r\n{\r\nif(irq == -1 || dma == -1) {\r\nprintk(KERN_WARNING "ad1848: must give I/O , IRQ and DMA.\n");\r\nreturn -EINVAL;\r\n}\r\ncfg.irq = irq;\r\ncfg.io_base = io;\r\ncfg.dma = dma;\r\ncfg.dma2 = dma2;\r\ncfg.card_subtype = type;\r\n}\r\nports = request_region(io + 4, 4, "ad1848");\r\nif (!ports)\r\nreturn -EBUSY;\r\nif (!request_region(io, 4, "WSS config")) {\r\nrelease_region(io + 4, 4);\r\nreturn -EBUSY;\r\n}\r\nif (!probe_ms_sound(&cfg, ports)) {\r\nrelease_region(io + 4, 4);\r\nrelease_region(io, 4);\r\nreturn -ENODEV;\r\n}\r\nattach_ms_sound(&cfg, ports, THIS_MODULE);\r\nloaded = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit cleanup_ad1848(void)\r\n{\r\nif(loaded)\r\nunload_ms_sound(&cfg);\r\n#ifdef CONFIG_PNP\r\nif(ad1848_dev){\r\nif(audio_activated)\r\npnp_device_detach(ad1848_dev);\r\n}\r\n#endif\r\n}\r\nstatic int __init setup_ad1848(char *str)\r\n{\r\nint ints[6];\r\nstr = get_options(str, ARRAY_SIZE(ints), ints);\r\nio = ints[1];\r\nirq = ints[2];\r\ndma = ints[3];\r\ndma2 = ints[4];\r\ntype = ints[5];\r\nreturn 1;\r\n}
