int nft_redir_validate(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr,\r\nconst struct nft_data **data)\r\n{\r\nint err;\r\nerr = nft_chain_validate_dependency(ctx->chain, NFT_CHAIN_T_NAT);\r\nif (err < 0)\r\nreturn err;\r\nreturn nft_chain_validate_hooks(ctx->chain,\r\n(1 << NF_INET_PRE_ROUTING) |\r\n(1 << NF_INET_LOCAL_OUT));\r\n}\r\nint nft_redir_init(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr,\r\nconst struct nlattr * const tb[])\r\n{\r\nstruct nft_redir *priv = nft_expr_priv(expr);\r\nunsigned int plen;\r\nint err;\r\nplen = FIELD_SIZEOF(struct nf_nat_range, min_addr.all);\r\nif (tb[NFTA_REDIR_REG_PROTO_MIN]) {\r\npriv->sreg_proto_min =\r\nnft_parse_register(tb[NFTA_REDIR_REG_PROTO_MIN]);\r\nerr = nft_validate_register_load(priv->sreg_proto_min, plen);\r\nif (err < 0)\r\nreturn err;\r\nif (tb[NFTA_REDIR_REG_PROTO_MAX]) {\r\npriv->sreg_proto_max =\r\nnft_parse_register(tb[NFTA_REDIR_REG_PROTO_MAX]);\r\nerr = nft_validate_register_load(priv->sreg_proto_max,\r\nplen);\r\nif (err < 0)\r\nreturn err;\r\n} else {\r\npriv->sreg_proto_max = priv->sreg_proto_min;\r\n}\r\n}\r\nif (tb[NFTA_REDIR_FLAGS]) {\r\npriv->flags = ntohl(nla_get_be32(tb[NFTA_REDIR_FLAGS]));\r\nif (priv->flags & ~NF_NAT_RANGE_MASK)\r\nreturn -EINVAL;\r\n}\r\nreturn nf_ct_netns_get(ctx->net, ctx->afi->family);\r\n}\r\nint nft_redir_dump(struct sk_buff *skb, const struct nft_expr *expr)\r\n{\r\nconst struct nft_redir *priv = nft_expr_priv(expr);\r\nif (priv->sreg_proto_min) {\r\nif (nft_dump_register(skb, NFTA_REDIR_REG_PROTO_MIN,\r\npriv->sreg_proto_min))\r\ngoto nla_put_failure;\r\nif (nft_dump_register(skb, NFTA_REDIR_REG_PROTO_MAX,\r\npriv->sreg_proto_max))\r\ngoto nla_put_failure;\r\n}\r\nif (priv->flags != 0 &&\r\nnla_put_be32(skb, NFTA_REDIR_FLAGS, htonl(priv->flags)))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}
