static bool dpi_calc_dispc_cb(int lckd, int pckd, unsigned long lck,\r\nunsigned long pck, void *data)\r\n{\r\nstruct sdi_clk_calc_ctx *ctx = data;\r\nctx->dispc_cinfo.lck_div = lckd;\r\nctx->dispc_cinfo.pck_div = pckd;\r\nctx->dispc_cinfo.lck = lck;\r\nctx->dispc_cinfo.pck = pck;\r\nreturn true;\r\n}\r\nstatic bool dpi_calc_dss_cb(unsigned long fck, void *data)\r\n{\r\nstruct sdi_clk_calc_ctx *ctx = data;\r\nctx->fck = fck;\r\nreturn dispc_div_calc(fck, ctx->pck_min, ctx->pck_max,\r\ndpi_calc_dispc_cb, ctx);\r\n}\r\nstatic int sdi_calc_clock_div(unsigned long pclk,\r\nunsigned long *fck,\r\nstruct dispc_clock_info *dispc_cinfo)\r\n{\r\nint i;\r\nstruct sdi_clk_calc_ctx ctx;\r\nfor (i = 0; i < 10; ++i) {\r\nbool ok;\r\nmemset(&ctx, 0, sizeof(ctx));\r\nif (pclk > 1000 * i * i * i)\r\nctx.pck_min = max(pclk - 1000 * i * i * i, 0lu);\r\nelse\r\nctx.pck_min = 0;\r\nctx.pck_max = pclk + 1000 * i * i * i;\r\nok = dss_div_calc(pclk, ctx.pck_min, dpi_calc_dss_cb, &ctx);\r\nif (ok) {\r\n*fck = ctx.fck;\r\n*dispc_cinfo = ctx.dispc_cinfo;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void sdi_config_lcd_manager(struct omap_dss_device *dssdev)\r\n{\r\nenum omap_channel channel = dssdev->dispc_channel;\r\nsdi.mgr_config.io_pad_mode = DSS_IO_PAD_MODE_BYPASS;\r\nsdi.mgr_config.stallmode = false;\r\nsdi.mgr_config.fifohandcheck = false;\r\nsdi.mgr_config.video_port_width = 24;\r\nsdi.mgr_config.lcden_sig_polarity = 1;\r\ndss_mgr_set_lcd_config(channel, &sdi.mgr_config);\r\n}\r\nstatic int sdi_display_enable(struct omap_dss_device *dssdev)\r\n{\r\nstruct omap_dss_device *out = &sdi.output;\r\nenum omap_channel channel = dssdev->dispc_channel;\r\nstruct videomode *vm = &sdi.vm;\r\nunsigned long fck;\r\nstruct dispc_clock_info dispc_cinfo;\r\nunsigned long pck;\r\nint r;\r\nif (!out->dispc_channel_connected) {\r\nDSSERR("failed to enable display: no output/manager\n");\r\nreturn -ENODEV;\r\n}\r\nr = regulator_enable(sdi.vdds_sdi_reg);\r\nif (r)\r\ngoto err_reg_enable;\r\nr = dispc_runtime_get();\r\nif (r)\r\ngoto err_get_dispc;\r\nvm->flags |= DISPLAY_FLAGS_PIXDATA_POSEDGE | DISPLAY_FLAGS_SYNC_POSEDGE;\r\nr = sdi_calc_clock_div(vm->pixelclock, &fck, &dispc_cinfo);\r\nif (r)\r\ngoto err_calc_clock_div;\r\nsdi.mgr_config.clock_info = dispc_cinfo;\r\npck = fck / dispc_cinfo.lck_div / dispc_cinfo.pck_div;\r\nif (pck != vm->pixelclock) {\r\nDSSWARN("Could not find exact pixel clock. Requested %lu Hz, got %lu Hz\n",\r\nvm->pixelclock, pck);\r\nvm->pixelclock = pck;\r\n}\r\ndss_mgr_set_timings(channel, vm);\r\nr = dss_set_fck_rate(fck);\r\nif (r)\r\ngoto err_set_dss_clock_div;\r\nsdi_config_lcd_manager(dssdev);\r\ndispc_mgr_set_clock_div(channel, &sdi.mgr_config.clock_info);\r\ndss_sdi_init(sdi.datapairs);\r\nr = dss_sdi_enable();\r\nif (r)\r\ngoto err_sdi_enable;\r\nmdelay(2);\r\nr = dss_mgr_enable(channel);\r\nif (r)\r\ngoto err_mgr_enable;\r\nreturn 0;\r\nerr_mgr_enable:\r\ndss_sdi_disable();\r\nerr_sdi_enable:\r\nerr_set_dss_clock_div:\r\nerr_calc_clock_div:\r\ndispc_runtime_put();\r\nerr_get_dispc:\r\nregulator_disable(sdi.vdds_sdi_reg);\r\nerr_reg_enable:\r\nreturn r;\r\n}\r\nstatic void sdi_display_disable(struct omap_dss_device *dssdev)\r\n{\r\nenum omap_channel channel = dssdev->dispc_channel;\r\ndss_mgr_disable(channel);\r\ndss_sdi_disable();\r\ndispc_runtime_put();\r\nregulator_disable(sdi.vdds_sdi_reg);\r\n}\r\nstatic void sdi_set_timings(struct omap_dss_device *dssdev,\r\nstruct videomode *vm)\r\n{\r\nsdi.vm = *vm;\r\n}\r\nstatic void sdi_get_timings(struct omap_dss_device *dssdev,\r\nstruct videomode *vm)\r\n{\r\n*vm = sdi.vm;\r\n}\r\nstatic int sdi_check_timings(struct omap_dss_device *dssdev,\r\nstruct videomode *vm)\r\n{\r\nenum omap_channel channel = dssdev->dispc_channel;\r\nif (!dispc_mgr_timings_ok(channel, vm))\r\nreturn -EINVAL;\r\nif (vm->pixelclock == 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int sdi_init_regulator(void)\r\n{\r\nstruct regulator *vdds_sdi;\r\nif (sdi.vdds_sdi_reg)\r\nreturn 0;\r\nvdds_sdi = devm_regulator_get(&sdi.pdev->dev, "vdds_sdi");\r\nif (IS_ERR(vdds_sdi)) {\r\nif (PTR_ERR(vdds_sdi) != -EPROBE_DEFER)\r\nDSSERR("can't get VDDS_SDI regulator\n");\r\nreturn PTR_ERR(vdds_sdi);\r\n}\r\nsdi.vdds_sdi_reg = vdds_sdi;\r\nreturn 0;\r\n}\r\nstatic int sdi_connect(struct omap_dss_device *dssdev,\r\nstruct omap_dss_device *dst)\r\n{\r\nenum omap_channel channel = dssdev->dispc_channel;\r\nint r;\r\nr = sdi_init_regulator();\r\nif (r)\r\nreturn r;\r\nr = dss_mgr_connect(channel, dssdev);\r\nif (r)\r\nreturn r;\r\nr = omapdss_output_set_device(dssdev, dst);\r\nif (r) {\r\nDSSERR("failed to connect output to new device: %s\n",\r\ndst->name);\r\ndss_mgr_disconnect(channel, dssdev);\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nstatic void sdi_disconnect(struct omap_dss_device *dssdev,\r\nstruct omap_dss_device *dst)\r\n{\r\nenum omap_channel channel = dssdev->dispc_channel;\r\nWARN_ON(dst != dssdev->dst);\r\nif (dst != dssdev->dst)\r\nreturn;\r\nomapdss_output_unset_device(dssdev);\r\ndss_mgr_disconnect(channel, dssdev);\r\n}\r\nstatic void sdi_init_output(struct platform_device *pdev)\r\n{\r\nstruct omap_dss_device *out = &sdi.output;\r\nout->dev = &pdev->dev;\r\nout->id = OMAP_DSS_OUTPUT_SDI;\r\nout->output_type = OMAP_DISPLAY_TYPE_SDI;\r\nout->name = "sdi.0";\r\nout->dispc_channel = OMAP_DSS_CHANNEL_LCD;\r\nout->port_num = 1;\r\nout->ops.sdi = &sdi_ops;\r\nout->owner = THIS_MODULE;\r\nomapdss_register_output(out);\r\n}\r\nstatic void sdi_uninit_output(struct platform_device *pdev)\r\n{\r\nstruct omap_dss_device *out = &sdi.output;\r\nomapdss_unregister_output(out);\r\n}\r\nint sdi_init_port(struct platform_device *pdev, struct device_node *port)\r\n{\r\nstruct device_node *ep;\r\nu32 datapairs;\r\nint r;\r\nep = of_get_next_child(port, NULL);\r\nif (!ep)\r\nreturn 0;\r\nr = of_property_read_u32(ep, "datapairs", &datapairs);\r\nif (r) {\r\nDSSERR("failed to parse datapairs\n");\r\ngoto err_datapairs;\r\n}\r\nsdi.datapairs = datapairs;\r\nof_node_put(ep);\r\nsdi.pdev = pdev;\r\nsdi_init_output(pdev);\r\nsdi.port_initialized = true;\r\nreturn 0;\r\nerr_datapairs:\r\nof_node_put(ep);\r\nreturn r;\r\n}\r\nvoid sdi_uninit_port(struct device_node *port)\r\n{\r\nif (!sdi.port_initialized)\r\nreturn;\r\nsdi_uninit_output(sdi.pdev);\r\n}
