u32 buffer_icap_get_status(struct hwicap_drvdata *drvdata)\r\n{\r\nreturn in_be32(drvdata->base_address + XHI_STATUS_REG_OFFSET);\r\n}\r\nstatic inline u32 buffer_icap_get_bram(void __iomem *base_address,\r\nu32 offset)\r\n{\r\nreturn in_be32(base_address + (offset << 2));\r\n}\r\nstatic inline bool buffer_icap_busy(void __iomem *base_address)\r\n{\r\nu32 status = in_be32(base_address + XHI_STATUS_REG_OFFSET);\r\nreturn (status & 1) == XHI_NOT_FINISHED;\r\n}\r\nstatic inline void buffer_icap_set_size(void __iomem *base_address,\r\nu32 data)\r\n{\r\nout_be32(base_address + XHI_SIZE_REG_OFFSET, data);\r\n}\r\nstatic inline void buffer_icap_set_offset(void __iomem *base_address,\r\nu32 data)\r\n{\r\nout_be32(base_address + XHI_BRAM_OFFSET_REG_OFFSET, data);\r\n}\r\nstatic inline void buffer_icap_set_rnc(void __iomem *base_address,\r\nu32 data)\r\n{\r\nout_be32(base_address + XHI_RNC_REG_OFFSET, data);\r\n}\r\nstatic inline void buffer_icap_set_bram(void __iomem *base_address,\r\nu32 offset, u32 data)\r\n{\r\nout_be32(base_address + (offset << 2), data);\r\n}\r\nstatic int buffer_icap_device_read(struct hwicap_drvdata *drvdata,\r\nu32 offset, u32 count)\r\n{\r\ns32 retries = 0;\r\nvoid __iomem *base_address = drvdata->base_address;\r\nif (buffer_icap_busy(base_address))\r\nreturn -EBUSY;\r\nif ((offset + count) > XHI_MAX_BUFFER_INTS)\r\nreturn -EINVAL;\r\nbuffer_icap_set_size(base_address, (count << 2));\r\nbuffer_icap_set_offset(base_address, offset);\r\nbuffer_icap_set_rnc(base_address, XHI_READBACK);\r\nwhile (buffer_icap_busy(base_address)) {\r\nretries++;\r\nif (retries > XHI_MAX_RETRIES)\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int buffer_icap_device_write(struct hwicap_drvdata *drvdata,\r\nu32 offset, u32 count)\r\n{\r\ns32 retries = 0;\r\nvoid __iomem *base_address = drvdata->base_address;\r\nif (buffer_icap_busy(base_address))\r\nreturn -EBUSY;\r\nif ((offset + count) > XHI_MAX_BUFFER_INTS)\r\nreturn -EINVAL;\r\nbuffer_icap_set_size(base_address, count << 2);\r\nbuffer_icap_set_offset(base_address, offset);\r\nbuffer_icap_set_rnc(base_address, XHI_CONFIGURE);\r\nwhile (buffer_icap_busy(base_address)) {\r\nretries++;\r\nif (retries > XHI_MAX_RETRIES)\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nvoid buffer_icap_reset(struct hwicap_drvdata *drvdata)\r\n{\r\nout_be32(drvdata->base_address + XHI_STATUS_REG_OFFSET, 0xFEFE);\r\n}\r\nint buffer_icap_set_configuration(struct hwicap_drvdata *drvdata, u32 *data,\r\nu32 size)\r\n{\r\nint status;\r\ns32 buffer_count = 0;\r\nbool dirty = false;\r\nu32 i;\r\nvoid __iomem *base_address = drvdata->base_address;\r\nfor (i = 0, buffer_count = 0; i < size; i++) {\r\nbuffer_icap_set_bram(base_address, buffer_count, data[i]);\r\ndirty = true;\r\nif (buffer_count < XHI_MAX_BUFFER_INTS - 1) {\r\nbuffer_count++;\r\ncontinue;\r\n}\r\nstatus = buffer_icap_device_write(\r\ndrvdata,\r\nXHI_BUFFER_START,\r\nXHI_MAX_BUFFER_INTS);\r\nif (status != 0) {\r\nbuffer_icap_reset(drvdata);\r\nreturn status;\r\n}\r\nbuffer_count = 0;\r\ndirty = false;\r\n}\r\nif (dirty) {\r\nstatus = buffer_icap_device_write(drvdata, XHI_BUFFER_START,\r\nbuffer_count);\r\nif (status != 0) {\r\nbuffer_icap_reset(drvdata);\r\n}\r\nreturn status;\r\n}\r\nreturn 0;\r\n}\r\nint buffer_icap_get_configuration(struct hwicap_drvdata *drvdata, u32 *data,\r\nu32 size)\r\n{\r\nint status;\r\ns32 buffer_count = 0;\r\nu32 i;\r\nvoid __iomem *base_address = drvdata->base_address;\r\nfor (i = 0, buffer_count = XHI_MAX_BUFFER_INTS; i < size; i++) {\r\nif (buffer_count == XHI_MAX_BUFFER_INTS) {\r\nu32 words_remaining = size - i;\r\nu32 words_to_read =\r\nwords_remaining <\r\nXHI_MAX_BUFFER_INTS ? words_remaining :\r\nXHI_MAX_BUFFER_INTS;\r\nstatus = buffer_icap_device_read(\r\ndrvdata,\r\nXHI_BUFFER_START,\r\nwords_to_read);\r\nif (status != 0) {\r\nbuffer_icap_reset(drvdata);\r\nreturn status;\r\n}\r\nbuffer_count = 0;\r\n}\r\ndata[i] = buffer_icap_get_bram(base_address, buffer_count);\r\nbuffer_count++;\r\n}\r\nreturn 0;\r\n}
