static int mpc85xx_exclude_device(struct pci_controller *hose,\r\nu_char bus, u_char devfn)\r\n{\r\nif ((bus == 1) && (PCI_SLOT(devfn) == ARCADIA_2ND_BRIDGE_IDSEL))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nif ((bus == 0) && (PCI_SLOT(devfn) == ARCADIA_2ND_BRIDGE_IDSEL))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nelse\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int mpc85xx_cds_restart(struct notifier_block *this,\r\nunsigned long mode, void *cmd)\r\n{\r\nstruct pci_dev *dev;\r\nu_char tmp;\r\nif ((dev = pci_get_device(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_82C686,\r\nNULL))) {\r\npci_read_config_byte(dev, 0x47, &tmp);\r\npci_write_config_byte(dev, 0x47, tmp | 1);\r\npci_read_config_byte(dev, 0x47, &tmp);\r\npci_dev_put(dev);\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int mpc85xx_cds_restart_register(void)\r\n{\r\nstatic struct notifier_block restart_handler;\r\nrestart_handler.notifier_call = mpc85xx_cds_restart;\r\nrestart_handler.priority = 192;\r\nreturn register_restart_handler(&restart_handler);\r\n}\r\nstatic void __init mpc85xx_cds_pci_irq_fixup(struct pci_dev *dev)\r\n{\r\nu_char c;\r\nif (dev->vendor == PCI_VENDOR_ID_VIA) {\r\nswitch (dev->device) {\r\ncase PCI_DEVICE_ID_VIA_82C586_1:\r\npci_read_config_byte(dev, 0x40, &c);\r\nc |= 0x03;\r\npci_write_config_byte(dev, 0x40, c);\r\ndev->irq = 14;\r\npci_write_config_byte(dev, PCI_INTERRUPT_LINE, dev->irq);\r\nbreak;\r\ncase PCI_DEVICE_ID_VIA_82C586_2:\r\nif (PCI_FUNC(dev->devfn) == 3)\r\ndev->irq = 11;\r\nelse\r\ndev->irq = 10;\r\npci_write_config_byte(dev, PCI_INTERRUPT_LINE, dev->irq);\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void skip_fake_bridge(struct pci_dev *dev)\r\n{\r\ndev->hdr_type = 0x7f;\r\n}\r\nvoid mpc85xx_cds_fixup_bus(struct pci_bus *bus)\r\n{\r\nstruct pci_dev *dev = bus->self;\r\nstruct resource *res = bus->resource[0];\r\nif (dev != NULL &&\r\ndev->vendor == PCI_VENDOR_ID_IBM &&\r\ndev->device == PCI_DEVICE_ID_IDT_TSI310) {\r\nif (res) {\r\nres->start = 0;\r\nres->end = 0x1fff;\r\nres->flags = IORESOURCE_IO;\r\npr_info("mpc85xx_cds: PCI bridge resource fixup applied\n");\r\npr_info("mpc85xx_cds: %pR\n", res);\r\n}\r\n}\r\nfsl_pcibios_fixup_bus(bus);\r\n}\r\nstatic void mpc85xx_8259_cascade_handler(struct irq_desc *desc)\r\n{\r\nunsigned int cascade_irq = i8259_irq();\r\nif (cascade_irq)\r\ngeneric_handle_irq(cascade_irq);\r\nhandle_fasteoi_irq(desc);\r\n}\r\nstatic irqreturn_t mpc85xx_8259_cascade_action(int irq, void *dev_id)\r\n{\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void __init mpc85xx_cds_pic_init(void)\r\n{\r\nstruct mpic *mpic;\r\nmpic = mpic_alloc(NULL, 0, MPIC_BIG_ENDIAN,\r\n0, 256, " OpenPIC ");\r\nBUG_ON(mpic == NULL);\r\nmpic_init(mpic);\r\n}\r\nstatic int mpc85xx_cds_8259_attach(void)\r\n{\r\nint ret;\r\nstruct device_node *np = NULL;\r\nstruct device_node *cascade_node = NULL;\r\nint cascade_irq;\r\nfor_each_node_by_type(np, "interrupt-controller")\r\nif (of_device_is_compatible(np, "chrp,iic")) {\r\ncascade_node = np;\r\nbreak;\r\n}\r\nif (cascade_node == NULL) {\r\nprintk(KERN_DEBUG "Could not find i8259 PIC\n");\r\nreturn -ENODEV;\r\n}\r\ncascade_irq = irq_of_parse_and_map(cascade_node, 0);\r\nif (!cascade_irq) {\r\nprintk(KERN_ERR "Failed to map cascade interrupt\n");\r\nreturn -ENXIO;\r\n}\r\ni8259_init(cascade_node, 0);\r\nof_node_put(cascade_node);\r\nif ((ret = setup_irq(cascade_irq, &mpc85xxcds_8259_irqaction))) {\r\nprintk(KERN_ERR "Failed to setup cascade interrupt\n");\r\nreturn ret;\r\n}\r\nirq_set_handler(cascade_irq, mpc85xx_8259_cascade_handler);\r\nreturn 0;\r\n}\r\nstatic void mpc85xx_cds_pci_assign_primary(void)\r\n{\r\n#ifdef CONFIG_PCI\r\nstruct device_node *np;\r\nif (fsl_pci_primary)\r\nreturn;\r\nnp = of_find_node_by_name(NULL, "i8259");\r\nwhile ((fsl_pci_primary = of_get_parent(np))) {\r\nof_node_put(np);\r\nnp = fsl_pci_primary;\r\nif ((of_device_is_compatible(np, "fsl,mpc8540-pci") ||\r\nof_device_is_compatible(np, "fsl,mpc8548-pcie")) &&\r\nof_device_is_available(np))\r\nreturn;\r\n}\r\n#endif\r\n}\r\nstatic void __init mpc85xx_cds_setup_arch(void)\r\n{\r\nstruct device_node *np;\r\nint cds_pci_slot;\r\nif (ppc_md.progress)\r\nppc_md.progress("mpc85xx_cds_setup_arch()", 0);\r\nnp = of_find_compatible_node(NULL, NULL, "fsl,mpc8548cds-fpga");\r\nif (!np) {\r\npr_err("Could not find FPGA node.\n");\r\nreturn;\r\n}\r\ncadmus = of_iomap(np, 0);\r\nof_node_put(np);\r\nif (!cadmus) {\r\npr_err("Fail to map FPGA area.\n");\r\nreturn;\r\n}\r\nif (ppc_md.progress) {\r\nchar buf[40];\r\ncds_pci_slot = ((in_8(&cadmus->cm_csr) >> 6) & 0x3) + 1;\r\nsnprintf(buf, 40, "CDS Version = 0x%x in slot %d\n",\r\nin_8(&cadmus->cm_ver), cds_pci_slot);\r\nppc_md.progress(buf, 0);\r\n}\r\n#ifdef CONFIG_PCI\r\nppc_md.pci_irq_fixup = mpc85xx_cds_pci_irq_fixup;\r\nppc_md.pci_exclude_device = mpc85xx_exclude_device;\r\n#endif\r\nmpc85xx_cds_pci_assign_primary();\r\nfsl_pci_assign_primary();\r\n}\r\nstatic void mpc85xx_cds_show_cpuinfo(struct seq_file *m)\r\n{\r\nuint pvid, svid, phid1;\r\npvid = mfspr(SPRN_PVR);\r\nsvid = mfspr(SPRN_SVR);\r\nseq_printf(m, "Vendor\t\t: Freescale Semiconductor\n");\r\nseq_printf(m, "Machine\t\t: MPC85xx CDS (0x%x)\n",\r\nin_8(&cadmus->cm_ver));\r\nseq_printf(m, "PVR\t\t: 0x%x\n", pvid);\r\nseq_printf(m, "SVR\t\t: 0x%x\n", svid);\r\nphid1 = mfspr(SPRN_HID1);\r\nseq_printf(m, "PLL setting\t: 0x%x\n", ((phid1 >> 24) & 0x3f));\r\n}\r\nstatic int __init mpc85xx_cds_probe(void)\r\n{\r\nreturn of_machine_is_compatible("MPC85xxCDS");\r\n}
