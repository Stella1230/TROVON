static int gfs2_drevalidate(struct dentry *dentry, unsigned int flags)\r\n{\r\nstruct dentry *parent;\r\nstruct gfs2_sbd *sdp;\r\nstruct gfs2_inode *dip;\r\nstruct inode *inode;\r\nstruct gfs2_holder d_gh;\r\nstruct gfs2_inode *ip = NULL;\r\nint error;\r\nint had_lock = 0;\r\nif (flags & LOOKUP_RCU)\r\nreturn -ECHILD;\r\nparent = dget_parent(dentry);\r\nsdp = GFS2_SB(d_inode(parent));\r\ndip = GFS2_I(d_inode(parent));\r\ninode = d_inode(dentry);\r\nif (inode) {\r\nif (is_bad_inode(inode))\r\ngoto invalid;\r\nip = GFS2_I(inode);\r\n}\r\nif (sdp->sd_lockstruct.ls_ops->lm_mount == NULL)\r\ngoto valid;\r\nhad_lock = (gfs2_glock_is_locked_by_me(dip->i_gl) != NULL);\r\nif (!had_lock) {\r\nerror = gfs2_glock_nq_init(dip->i_gl, LM_ST_SHARED, 0, &d_gh);\r\nif (error)\r\ngoto fail;\r\n}\r\nerror = gfs2_dir_check(d_inode(parent), &dentry->d_name, ip);\r\nswitch (error) {\r\ncase 0:\r\nif (!inode)\r\ngoto invalid_gunlock;\r\nbreak;\r\ncase -ENOENT:\r\nif (!inode)\r\ngoto valid_gunlock;\r\ngoto invalid_gunlock;\r\ndefault:\r\ngoto fail_gunlock;\r\n}\r\nvalid_gunlock:\r\nif (!had_lock)\r\ngfs2_glock_dq_uninit(&d_gh);\r\nvalid:\r\ndput(parent);\r\nreturn 1;\r\ninvalid_gunlock:\r\nif (!had_lock)\r\ngfs2_glock_dq_uninit(&d_gh);\r\ninvalid:\r\ndput(parent);\r\nreturn 0;\r\nfail_gunlock:\r\ngfs2_glock_dq_uninit(&d_gh);\r\nfail:\r\ndput(parent);\r\nreturn 0;\r\n}\r\nstatic int gfs2_dhash(const struct dentry *dentry, struct qstr *str)\r\n{\r\nstr->hash = gfs2_disk_hash(str->name, str->len);\r\nreturn 0;\r\n}\r\nstatic int gfs2_dentry_delete(const struct dentry *dentry)\r\n{\r\nstruct gfs2_inode *ginode;\r\nif (d_really_is_negative(dentry))\r\nreturn 0;\r\nginode = GFS2_I(d_inode(dentry));\r\nif (!gfs2_holder_initialized(&ginode->i_iopen_gh))\r\nreturn 0;\r\nif (test_bit(GLF_DEMOTE, &ginode->i_iopen_gh.gh_gl->gl_flags))\r\nreturn 1;\r\nreturn 0;\r\n}
