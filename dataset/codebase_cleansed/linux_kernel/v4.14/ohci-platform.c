static int ohci_platform_power_on(struct platform_device *dev)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(dev);\r\nstruct ohci_platform_priv *priv = hcd_to_ohci_priv(hcd);\r\nint clk, ret, phy_num;\r\nfor (clk = 0; clk < OHCI_MAX_CLKS && priv->clks[clk]; clk++) {\r\nret = clk_prepare_enable(priv->clks[clk]);\r\nif (ret)\r\ngoto err_disable_clks;\r\n}\r\nfor (phy_num = 0; phy_num < priv->num_phys; phy_num++) {\r\nret = phy_init(priv->phys[phy_num]);\r\nif (ret)\r\ngoto err_exit_phy;\r\nret = phy_power_on(priv->phys[phy_num]);\r\nif (ret) {\r\nphy_exit(priv->phys[phy_num]);\r\ngoto err_exit_phy;\r\n}\r\n}\r\nreturn 0;\r\nerr_exit_phy:\r\nwhile (--phy_num >= 0) {\r\nphy_power_off(priv->phys[phy_num]);\r\nphy_exit(priv->phys[phy_num]);\r\n}\r\nerr_disable_clks:\r\nwhile (--clk >= 0)\r\nclk_disable_unprepare(priv->clks[clk]);\r\nreturn ret;\r\n}\r\nstatic void ohci_platform_power_off(struct platform_device *dev)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(dev);\r\nstruct ohci_platform_priv *priv = hcd_to_ohci_priv(hcd);\r\nint clk, phy_num;\r\nfor (phy_num = 0; phy_num < priv->num_phys; phy_num++) {\r\nphy_power_off(priv->phys[phy_num]);\r\nphy_exit(priv->phys[phy_num]);\r\n}\r\nfor (clk = OHCI_MAX_CLKS - 1; clk >= 0; clk--)\r\nif (priv->clks[clk])\r\nclk_disable_unprepare(priv->clks[clk]);\r\n}\r\nstatic int ohci_platform_probe(struct platform_device *dev)\r\n{\r\nstruct usb_hcd *hcd;\r\nstruct resource *res_mem;\r\nstruct usb_ohci_pdata *pdata = dev_get_platdata(&dev->dev);\r\nstruct ohci_platform_priv *priv;\r\nstruct ohci_hcd *ohci;\r\nint err, irq, phy_num, clk = 0, rst = 0;\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\nif (!pdata)\r\npdata = &ohci_platform_defaults;\r\nerr = dma_coerce_mask_and_coherent(&dev->dev, DMA_BIT_MASK(32));\r\nif (err)\r\nreturn err;\r\nirq = platform_get_irq(dev, 0);\r\nif (irq < 0) {\r\ndev_err(&dev->dev, "no irq provided");\r\nreturn irq;\r\n}\r\nhcd = usb_create_hcd(&ohci_platform_hc_driver, &dev->dev,\r\ndev_name(&dev->dev));\r\nif (!hcd)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(dev, hcd);\r\ndev->dev.platform_data = pdata;\r\npriv = hcd_to_ohci_priv(hcd);\r\nohci = hcd_to_ohci(hcd);\r\nif (pdata == &ohci_platform_defaults && dev->dev.of_node) {\r\nif (of_property_read_bool(dev->dev.of_node, "big-endian-regs"))\r\nohci->flags |= OHCI_QUIRK_BE_MMIO;\r\nif (of_property_read_bool(dev->dev.of_node, "big-endian-desc"))\r\nohci->flags |= OHCI_QUIRK_BE_DESC;\r\nif (of_property_read_bool(dev->dev.of_node, "big-endian"))\r\nohci->flags |= OHCI_QUIRK_BE_MMIO | OHCI_QUIRK_BE_DESC;\r\nif (of_property_read_bool(dev->dev.of_node, "no-big-frame-no"))\r\nohci->flags |= OHCI_QUIRK_FRAME_NO;\r\nif (of_property_read_bool(dev->dev.of_node,\r\n"remote-wakeup-connected"))\r\nohci->hc_control = OHCI_CTRL_RWC;\r\nof_property_read_u32(dev->dev.of_node, "num-ports",\r\n&ohci->num_ports);\r\npriv->num_phys = of_count_phandle_with_args(dev->dev.of_node,\r\n"phys", "#phy-cells");\r\nif (priv->num_phys > 0) {\r\npriv->phys = devm_kcalloc(&dev->dev, priv->num_phys,\r\nsizeof(struct phy *), GFP_KERNEL);\r\nif (!priv->phys)\r\nreturn -ENOMEM;\r\n} else\r\npriv->num_phys = 0;\r\nfor (phy_num = 0; phy_num < priv->num_phys; phy_num++) {\r\npriv->phys[phy_num] = devm_of_phy_get_by_index(\r\n&dev->dev, dev->dev.of_node, phy_num);\r\nif (IS_ERR(priv->phys[phy_num])) {\r\nerr = PTR_ERR(priv->phys[phy_num]);\r\ngoto err_put_hcd;\r\n} else if (!hcd->phy) {\r\nhcd->phy = priv->phys[phy_num];\r\n}\r\n}\r\nfor (clk = 0; clk < OHCI_MAX_CLKS; clk++) {\r\npriv->clks[clk] = of_clk_get(dev->dev.of_node, clk);\r\nif (IS_ERR(priv->clks[clk])) {\r\nerr = PTR_ERR(priv->clks[clk]);\r\nif (err == -EPROBE_DEFER)\r\ngoto err_put_clks;\r\npriv->clks[clk] = NULL;\r\nbreak;\r\n}\r\n}\r\nfor (rst = 0; rst < OHCI_MAX_RESETS; rst++) {\r\npriv->resets[rst] =\r\ndevm_reset_control_get_shared_by_index(\r\n&dev->dev, rst);\r\nif (IS_ERR(priv->resets[rst])) {\r\nerr = PTR_ERR(priv->resets[rst]);\r\nif (err == -EPROBE_DEFER)\r\ngoto err_reset;\r\npriv->resets[rst] = NULL;\r\nbreak;\r\n}\r\nerr = reset_control_deassert(priv->resets[rst]);\r\nif (err)\r\ngoto err_reset;\r\n}\r\n}\r\nif (pdata->big_endian_desc)\r\nohci->flags |= OHCI_QUIRK_BE_DESC;\r\nif (pdata->big_endian_mmio)\r\nohci->flags |= OHCI_QUIRK_BE_MMIO;\r\nif (pdata->no_big_frame_no)\r\nohci->flags |= OHCI_QUIRK_FRAME_NO;\r\nif (pdata->num_ports)\r\nohci->num_ports = pdata->num_ports;\r\n#ifndef CONFIG_USB_OHCI_BIG_ENDIAN_MMIO\r\nif (ohci->flags & OHCI_QUIRK_BE_MMIO) {\r\ndev_err(&dev->dev,\r\n"Error: CONFIG_USB_OHCI_BIG_ENDIAN_MMIO not set\n");\r\nerr = -EINVAL;\r\ngoto err_reset;\r\n}\r\n#endif\r\n#ifndef CONFIG_USB_OHCI_BIG_ENDIAN_DESC\r\nif (ohci->flags & OHCI_QUIRK_BE_DESC) {\r\ndev_err(&dev->dev,\r\n"Error: CONFIG_USB_OHCI_BIG_ENDIAN_DESC not set\n");\r\nerr = -EINVAL;\r\ngoto err_reset;\r\n}\r\n#endif\r\npm_runtime_set_active(&dev->dev);\r\npm_runtime_enable(&dev->dev);\r\nif (pdata->power_on) {\r\nerr = pdata->power_on(dev);\r\nif (err < 0)\r\ngoto err_reset;\r\n}\r\nres_mem = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\nhcd->regs = devm_ioremap_resource(&dev->dev, res_mem);\r\nif (IS_ERR(hcd->regs)) {\r\nerr = PTR_ERR(hcd->regs);\r\ngoto err_power;\r\n}\r\nhcd->rsrc_start = res_mem->start;\r\nhcd->rsrc_len = resource_size(res_mem);\r\nerr = usb_add_hcd(hcd, irq, IRQF_SHARED);\r\nif (err)\r\ngoto err_power;\r\ndevice_wakeup_enable(hcd->self.controller);\r\nplatform_set_drvdata(dev, hcd);\r\nreturn err;\r\nerr_power:\r\nif (pdata->power_off)\r\npdata->power_off(dev);\r\nerr_reset:\r\npm_runtime_disable(&dev->dev);\r\nwhile (--rst >= 0)\r\nreset_control_assert(priv->resets[rst]);\r\nerr_put_clks:\r\nwhile (--clk >= 0)\r\nclk_put(priv->clks[clk]);\r\nerr_put_hcd:\r\nif (pdata == &ohci_platform_defaults)\r\ndev->dev.platform_data = NULL;\r\nusb_put_hcd(hcd);\r\nreturn err;\r\n}\r\nstatic int ohci_platform_remove(struct platform_device *dev)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(dev);\r\nstruct usb_ohci_pdata *pdata = dev_get_platdata(&dev->dev);\r\nstruct ohci_platform_priv *priv = hcd_to_ohci_priv(hcd);\r\nint clk, rst;\r\npm_runtime_get_sync(&dev->dev);\r\nusb_remove_hcd(hcd);\r\nif (pdata->power_off)\r\npdata->power_off(dev);\r\nfor (rst = 0; rst < OHCI_MAX_RESETS && priv->resets[rst]; rst++)\r\nreset_control_assert(priv->resets[rst]);\r\nfor (clk = 0; clk < OHCI_MAX_CLKS && priv->clks[clk]; clk++)\r\nclk_put(priv->clks[clk]);\r\nusb_put_hcd(hcd);\r\npm_runtime_put_sync(&dev->dev);\r\npm_runtime_disable(&dev->dev);\r\nif (pdata == &ohci_platform_defaults)\r\ndev->dev.platform_data = NULL;\r\nreturn 0;\r\n}\r\nstatic int ohci_platform_suspend(struct device *dev)\r\n{\r\nstruct usb_hcd *hcd = dev_get_drvdata(dev);\r\nstruct usb_ohci_pdata *pdata = dev->platform_data;\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nbool do_wakeup = device_may_wakeup(dev);\r\nint ret;\r\nret = ohci_suspend(hcd, do_wakeup);\r\nif (ret)\r\nreturn ret;\r\nif (pdata->power_suspend)\r\npdata->power_suspend(pdev);\r\nreturn ret;\r\n}\r\nstatic int ohci_platform_resume(struct device *dev)\r\n{\r\nstruct usb_hcd *hcd = dev_get_drvdata(dev);\r\nstruct usb_ohci_pdata *pdata = dev_get_platdata(dev);\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nif (pdata->power_on) {\r\nint err = pdata->power_on(pdev);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nohci_resume(hcd, false);\r\nreturn 0;\r\n}\r\nstatic int __init ohci_platform_init(void)\r\n{\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\npr_info("%s: " DRIVER_DESC "\n", hcd_name);\r\nohci_init_driver(&ohci_platform_hc_driver, &platform_overrides);\r\nreturn platform_driver_register(&ohci_platform_driver);\r\n}\r\nstatic void __exit ohci_platform_cleanup(void)\r\n{\r\nplatform_driver_unregister(&ohci_platform_driver);\r\n}
