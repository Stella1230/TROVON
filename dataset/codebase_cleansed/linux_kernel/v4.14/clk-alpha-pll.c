static int wait_for_pll(struct clk_alpha_pll *pll, u32 mask, bool inverse,\r\nconst char *action)\r\n{\r\nu32 val, off;\r\nint count;\r\nint ret;\r\nconst char *name = clk_hw_get_name(&pll->clkr.hw);\r\noff = pll->offset;\r\nret = regmap_read(pll->clkr.regmap, off + PLL_MODE, &val);\r\nif (ret)\r\nreturn ret;\r\nfor (count = 100; count > 0; count--) {\r\nret = regmap_read(pll->clkr.regmap, off + PLL_MODE, &val);\r\nif (ret)\r\nreturn ret;\r\nif (inverse && !(val & mask))\r\nreturn 0;\r\nelse if ((val & mask) == mask)\r\nreturn 0;\r\nudelay(1);\r\n}\r\nWARN(1, "%s failed to %s!\n", name, action);\r\nreturn -ETIMEDOUT;\r\n}\r\nvoid clk_alpha_pll_configure(struct clk_alpha_pll *pll, struct regmap *regmap,\r\nconst struct alpha_pll_config *config)\r\n{\r\nu32 val, mask;\r\nu32 off = pll->offset;\r\nregmap_write(regmap, off + PLL_L_VAL, config->l);\r\nregmap_write(regmap, off + PLL_ALPHA_VAL, config->alpha);\r\nregmap_write(regmap, off + PLL_CONFIG_CTL, config->config_ctl_val);\r\nregmap_write(regmap, off + PLL_CONFIG_CTL_U, config->config_ctl_hi_val);\r\nval = config->main_output_mask;\r\nval |= config->aux_output_mask;\r\nval |= config->aux2_output_mask;\r\nval |= config->early_output_mask;\r\nval |= config->pre_div_val;\r\nval |= config->post_div_val;\r\nval |= config->vco_val;\r\nmask = config->main_output_mask;\r\nmask |= config->aux_output_mask;\r\nmask |= config->aux2_output_mask;\r\nmask |= config->early_output_mask;\r\nmask |= config->pre_div_mask;\r\nmask |= config->post_div_mask;\r\nmask |= config->vco_mask;\r\nregmap_update_bits(regmap, off + PLL_USER_CTL, mask, val);\r\nif (pll->flags & SUPPORTS_FSM_MODE)\r\nqcom_pll_set_fsm_mode(regmap, off + PLL_MODE, 6, 0);\r\n}\r\nstatic int clk_alpha_pll_hwfsm_enable(struct clk_hw *hw)\r\n{\r\nint ret;\r\nu32 val, off;\r\nstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\r\noff = pll->offset;\r\nret = regmap_read(pll->clkr.regmap, off + PLL_MODE, &val);\r\nif (ret)\r\nreturn ret;\r\nval |= PLL_FSM_ENA;\r\nif (pll->flags & SUPPORTS_OFFLINE_REQ)\r\nval &= ~PLL_OFFLINE_REQ;\r\nret = regmap_write(pll->clkr.regmap, off + PLL_MODE, val);\r\nif (ret)\r\nreturn ret;\r\nmb();\r\nreturn wait_for_pll_enable_active(pll);\r\n}\r\nstatic void clk_alpha_pll_hwfsm_disable(struct clk_hw *hw)\r\n{\r\nint ret;\r\nu32 val, off;\r\nstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\r\noff = pll->offset;\r\nret = regmap_read(pll->clkr.regmap, off + PLL_MODE, &val);\r\nif (ret)\r\nreturn;\r\nif (pll->flags & SUPPORTS_OFFLINE_REQ) {\r\nret = regmap_update_bits(pll->clkr.regmap, off + PLL_MODE,\r\nPLL_OFFLINE_REQ, PLL_OFFLINE_REQ);\r\nif (ret)\r\nreturn;\r\nret = wait_for_pll_offline(pll);\r\nif (ret)\r\nreturn;\r\n}\r\nret = regmap_update_bits(pll->clkr.regmap, off + PLL_MODE,\r\nPLL_FSM_ENA, 0);\r\nif (ret)\r\nreturn;\r\nwait_for_pll_disable(pll);\r\n}\r\nstatic int pll_is_enabled(struct clk_hw *hw, u32 mask)\r\n{\r\nint ret;\r\nu32 val, off;\r\nstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\r\noff = pll->offset;\r\nret = regmap_read(pll->clkr.regmap, off + PLL_MODE, &val);\r\nif (ret)\r\nreturn ret;\r\nreturn !!(val & mask);\r\n}\r\nstatic int clk_alpha_pll_hwfsm_is_enabled(struct clk_hw *hw)\r\n{\r\nreturn pll_is_enabled(hw, PLL_ACTIVE_FLAG);\r\n}\r\nstatic int clk_alpha_pll_is_enabled(struct clk_hw *hw)\r\n{\r\nreturn pll_is_enabled(hw, PLL_LOCK_DET);\r\n}\r\nstatic int clk_alpha_pll_enable(struct clk_hw *hw)\r\n{\r\nint ret;\r\nstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\r\nu32 val, mask, off;\r\noff = pll->offset;\r\nmask = PLL_OUTCTRL | PLL_RESET_N | PLL_BYPASSNL;\r\nret = regmap_read(pll->clkr.regmap, off + PLL_MODE, &val);\r\nif (ret)\r\nreturn ret;\r\nif (val & PLL_VOTE_FSM_ENA) {\r\nret = clk_enable_regmap(hw);\r\nif (ret)\r\nreturn ret;\r\nreturn wait_for_pll_enable_active(pll);\r\n}\r\nif ((val & mask) == mask)\r\nreturn 0;\r\nret = regmap_update_bits(pll->clkr.regmap, off + PLL_MODE,\r\nPLL_BYPASSNL, PLL_BYPASSNL);\r\nif (ret)\r\nreturn ret;\r\nmb();\r\nudelay(5);\r\nret = regmap_update_bits(pll->clkr.regmap, off + PLL_MODE,\r\nPLL_RESET_N, PLL_RESET_N);\r\nif (ret)\r\nreturn ret;\r\nret = wait_for_pll_enable_lock(pll);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_update_bits(pll->clkr.regmap, off + PLL_MODE,\r\nPLL_OUTCTRL, PLL_OUTCTRL);\r\nmb();\r\nreturn ret;\r\n}\r\nstatic void clk_alpha_pll_disable(struct clk_hw *hw)\r\n{\r\nint ret;\r\nstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\r\nu32 val, mask, off;\r\noff = pll->offset;\r\nret = regmap_read(pll->clkr.regmap, off + PLL_MODE, &val);\r\nif (ret)\r\nreturn;\r\nif (val & PLL_VOTE_FSM_ENA) {\r\nclk_disable_regmap(hw);\r\nreturn;\r\n}\r\nmask = PLL_OUTCTRL;\r\nregmap_update_bits(pll->clkr.regmap, off + PLL_MODE, mask, 0);\r\nmb();\r\nudelay(1);\r\nmask = PLL_RESET_N | PLL_BYPASSNL;\r\nregmap_update_bits(pll->clkr.regmap, off + PLL_MODE, mask, 0);\r\n}\r\nstatic unsigned long alpha_pll_calc_rate(u64 prate, u32 l, u32 a)\r\n{\r\nreturn (prate * l) + ((prate * a) >> ALPHA_BITWIDTH);\r\n}\r\nstatic unsigned long\r\nalpha_pll_round_rate(unsigned long rate, unsigned long prate, u32 *l, u64 *a)\r\n{\r\nu64 remainder;\r\nu64 quotient;\r\nquotient = rate;\r\nremainder = do_div(quotient, prate);\r\n*l = quotient;\r\nif (!remainder) {\r\n*a = 0;\r\nreturn rate;\r\n}\r\nquotient = remainder << ALPHA_BITWIDTH;\r\nremainder = do_div(quotient, prate);\r\nif (remainder)\r\nquotient++;\r\n*a = quotient;\r\nreturn alpha_pll_calc_rate(prate, *l, *a);\r\n}\r\nstatic const struct pll_vco *\r\nalpha_pll_find_vco(const struct clk_alpha_pll *pll, unsigned long rate)\r\n{\r\nconst struct pll_vco *v = pll->vco_table;\r\nconst struct pll_vco *end = v + pll->num_vco;\r\nfor (; v < end; v++)\r\nif (rate >= v->min_freq && rate <= v->max_freq)\r\nreturn v;\r\nreturn NULL;\r\n}\r\nstatic unsigned long\r\nclk_alpha_pll_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\r\n{\r\nu32 l, low, high, ctl;\r\nu64 a = 0, prate = parent_rate;\r\nstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\r\nu32 off = pll->offset;\r\nregmap_read(pll->clkr.regmap, off + PLL_L_VAL, &l);\r\nregmap_read(pll->clkr.regmap, off + PLL_USER_CTL, &ctl);\r\nif (ctl & PLL_ALPHA_EN) {\r\nregmap_read(pll->clkr.regmap, off + PLL_ALPHA_VAL, &low);\r\nif (pll->flags & SUPPORTS_16BIT_ALPHA) {\r\na = low & ALPHA_16BIT_MASK;\r\n} else {\r\nregmap_read(pll->clkr.regmap, off + PLL_ALPHA_VAL_U,\r\n&high);\r\na = (u64)high << 32 | low;\r\na >>= ALPHA_REG_BITWIDTH - ALPHA_BITWIDTH;\r\n}\r\n}\r\nreturn alpha_pll_calc_rate(prate, l, a);\r\n}\r\nstatic int clk_alpha_pll_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long prate)\r\n{\r\nstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\r\nconst struct pll_vco *vco;\r\nu32 l, off = pll->offset;\r\nu64 a;\r\nrate = alpha_pll_round_rate(rate, prate, &l, &a);\r\nvco = alpha_pll_find_vco(pll, rate);\r\nif (!vco) {\r\npr_err("alpha pll not in a valid vco range\n");\r\nreturn -EINVAL;\r\n}\r\nregmap_write(pll->clkr.regmap, off + PLL_L_VAL, l);\r\nif (pll->flags & SUPPORTS_16BIT_ALPHA) {\r\nregmap_write(pll->clkr.regmap, off + PLL_ALPHA_VAL,\r\na & ALPHA_16BIT_MASK);\r\n} else {\r\na <<= (ALPHA_REG_BITWIDTH - ALPHA_BITWIDTH);\r\nregmap_write(pll->clkr.regmap, off + PLL_ALPHA_VAL_U, a >> 32);\r\n}\r\nregmap_update_bits(pll->clkr.regmap, off + PLL_USER_CTL,\r\nPLL_VCO_MASK << PLL_VCO_SHIFT,\r\nvco->val << PLL_VCO_SHIFT);\r\nregmap_update_bits(pll->clkr.regmap, off + PLL_USER_CTL, PLL_ALPHA_EN,\r\nPLL_ALPHA_EN);\r\nreturn 0;\r\n}\r\nstatic long clk_alpha_pll_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nstruct clk_alpha_pll *pll = to_clk_alpha_pll(hw);\r\nu32 l;\r\nu64 a;\r\nunsigned long min_freq, max_freq;\r\nrate = alpha_pll_round_rate(rate, *prate, &l, &a);\r\nif (alpha_pll_find_vco(pll, rate))\r\nreturn rate;\r\nmin_freq = pll->vco_table[0].min_freq;\r\nmax_freq = pll->vco_table[pll->num_vco - 1].max_freq;\r\nreturn clamp(rate, min_freq, max_freq);\r\n}\r\nstatic unsigned long\r\nclk_alpha_pll_postdiv_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\r\n{\r\nstruct clk_alpha_pll_postdiv *pll = to_clk_alpha_pll_postdiv(hw);\r\nu32 ctl;\r\nregmap_read(pll->clkr.regmap, pll->offset + PLL_USER_CTL, &ctl);\r\nctl >>= PLL_POST_DIV_SHIFT;\r\nctl &= PLL_POST_DIV_MASK;\r\nreturn parent_rate >> fls(ctl);\r\n}\r\nstatic long\r\nclk_alpha_pll_postdiv_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nstruct clk_alpha_pll_postdiv *pll = to_clk_alpha_pll_postdiv(hw);\r\nreturn divider_round_rate(hw, rate, prate, clk_alpha_div_table,\r\npll->width, CLK_DIVIDER_POWER_OF_TWO);\r\n}\r\nstatic int clk_alpha_pll_postdiv_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_alpha_pll_postdiv *pll = to_clk_alpha_pll_postdiv(hw);\r\nint div;\r\ndiv = DIV_ROUND_UP_ULL((u64)parent_rate, rate) - 1;\r\nreturn regmap_update_bits(pll->clkr.regmap, pll->offset + PLL_USER_CTL,\r\nPLL_POST_DIV_MASK << PLL_POST_DIV_SHIFT,\r\ndiv << PLL_POST_DIV_SHIFT);\r\n}
