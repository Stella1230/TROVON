void falcon_txc_set_gpio_val(struct ef4_nic *efx, int pin, int on)\r\n{\r\nef4_mdio_set_flag(efx, MDIO_MMD_PHYXS, TXC_GPIO_OUTPUT, 1 << pin, on);\r\n}\r\nvoid falcon_txc_set_gpio_dir(struct ef4_nic *efx, int pin, int dir)\r\n{\r\nef4_mdio_set_flag(efx, MDIO_MMD_PHYXS, TXC_GPIO_DIR, 1 << pin, dir);\r\n}\r\nstatic int txc_reset_phy(struct ef4_nic *efx)\r\n{\r\nint rc = ef4_mdio_reset_mmd(efx, MDIO_MMD_PMAPMD,\r\nTXC_MAX_RESET_TIME / TXC_RESET_WAIT,\r\nTXC_RESET_WAIT);\r\nif (rc < 0)\r\ngoto fail;\r\nrc = ef4_mdio_check_mmds(efx, TXC_REQUIRED_DEVS);\r\nif (rc < 0)\r\ngoto fail;\r\nreturn 0;\r\nfail:\r\nnetif_err(efx, hw, efx->net_dev, TXCNAME ": reset timed out!\n");\r\nreturn rc;\r\n}\r\nstatic int txc_bist_one(struct ef4_nic *efx, int mmd, int test)\r\n{\r\nint ctrl, bctl;\r\nint lane;\r\nint rc = 0;\r\nctrl = ef4_mdio_read(efx, MDIO_MMD_PCS, TXC_MTDIABLO_CTRL);\r\nctrl |= (1 << TXC_MTDIABLO_CTRL_PMA_LOOP_LBN);\r\nef4_mdio_write(efx, MDIO_MMD_PCS, TXC_MTDIABLO_CTRL, ctrl);\r\nbctl = (test << TXC_BIST_CTRL_TYPE_LBN);\r\nef4_mdio_write(efx, mmd, TXC_BIST_CTL, bctl);\r\nbctl |= (1 << TXC_BIST_CTRL_ENAB_LBN);\r\nef4_mdio_write(efx, mmd, TXC_BIST_CTL, bctl);\r\nef4_mdio_write(efx, mmd, TXC_BIST_CTL,\r\nbctl | (1 << TXC_BIST_CTRL_STRT_LBN));\r\nudelay(TXC_BIST_DURATION);\r\nbctl |= (1 << TXC_BIST_CTRL_STOP_LBN);\r\nef4_mdio_write(efx, mmd, TXC_BIST_CTL, bctl);\r\nwhile (bctl & (1 << TXC_BIST_CTRL_STOP_LBN))\r\nbctl = ef4_mdio_read(efx, mmd, TXC_BIST_CTL);\r\nfor (lane = 0; lane < 4; lane++) {\r\nint count = ef4_mdio_read(efx, mmd, TXC_BIST_RX0ERRCNT + lane);\r\nif (count != 0) {\r\nnetif_err(efx, hw, efx->net_dev, TXCNAME": BIST error. "\r\n"Lane %d had %d errs\n", lane, count);\r\nrc = -EIO;\r\n}\r\ncount = ef4_mdio_read(efx, mmd, TXC_BIST_RX0FRMCNT + lane);\r\nif (count == 0) {\r\nnetif_err(efx, hw, efx->net_dev, TXCNAME": BIST error. "\r\n"Lane %d got 0 frames\n", lane);\r\nrc = -EIO;\r\n}\r\n}\r\nif (rc == 0)\r\nnetif_info(efx, hw, efx->net_dev, TXCNAME": BIST pass\n");\r\nef4_mdio_write(efx, mmd, TXC_BIST_CTL, 0);\r\nctrl &= ~(1 << TXC_MTDIABLO_CTRL_PMA_LOOP_LBN);\r\nef4_mdio_write(efx, MDIO_MMD_PCS, TXC_MTDIABLO_CTRL, ctrl);\r\nreturn rc;\r\n}\r\nstatic int txc_bist(struct ef4_nic *efx)\r\n{\r\nreturn txc_bist_one(efx, MDIO_MMD_PCS, TXC_BIST_CTRL_TYPE_TSD);\r\n}\r\nstatic void txc_apply_defaults(struct ef4_nic *efx)\r\n{\r\nint mctrl;\r\nef4_mdio_write(efx, MDIO_MMD_PHYXS, TXC_ALRGS_ATXPRE0, TXC_ATXPRE_NONE);\r\nef4_mdio_write(efx, MDIO_MMD_PHYXS, TXC_ALRGS_ATXPRE1, TXC_ATXPRE_NONE);\r\nef4_mdio_write(efx, MDIO_MMD_PHYXS,\r\nTXC_ALRGS_ATXAMP0, TXC_ATXAMP_0820_BOTH);\r\nef4_mdio_write(efx, MDIO_MMD_PHYXS,\r\nTXC_ALRGS_ATXAMP1, TXC_ATXAMP_0820_BOTH);\r\nef4_mdio_write(efx, MDIO_MMD_PMAPMD,\r\nTXC_ALRGS_ATXPRE0, TXC_ATXPRE_DEFAULT);\r\nef4_mdio_write(efx, MDIO_MMD_PMAPMD,\r\nTXC_ALRGS_ATXPRE1, TXC_ATXPRE_DEFAULT);\r\nef4_mdio_write(efx, MDIO_MMD_PMAPMD,\r\nTXC_ALRGS_ATXAMP0, TXC_ATXAMP_DEFAULT);\r\nef4_mdio_write(efx, MDIO_MMD_PMAPMD,\r\nTXC_ALRGS_ATXAMP1, TXC_ATXAMP_DEFAULT);\r\nmctrl = ef4_mdio_read(efx, MDIO_MMD_PHYXS, TXC_MRGS_CTL);\r\nmctrl &= ~((1 << TXC_MCTL_TXLED_LBN) | (1 << TXC_MCTL_RXLED_LBN));\r\nef4_mdio_write(efx, MDIO_MMD_PHYXS, TXC_MRGS_CTL, mctrl);\r\ntxc_reset_logic(efx);\r\nfalcon_board(efx)->type->init_phy(efx);\r\n}\r\nstatic int txc43128_phy_probe(struct ef4_nic *efx)\r\n{\r\nstruct txc43128_data *phy_data;\r\nphy_data = kzalloc(sizeof(*phy_data), GFP_KERNEL);\r\nif (!phy_data)\r\nreturn -ENOMEM;\r\nefx->phy_data = phy_data;\r\nphy_data->phy_mode = efx->phy_mode;\r\nefx->mdio.mmds = TXC_REQUIRED_DEVS;\r\nefx->mdio.mode_support = MDIO_SUPPORTS_C45 | MDIO_EMULATE_C22;\r\nefx->loopback_modes = TXC_LOOPBACKS | FALCON_XMAC_LOOPBACKS;\r\nreturn 0;\r\n}\r\nstatic int txc43128_phy_init(struct ef4_nic *efx)\r\n{\r\nint rc;\r\nrc = txc_reset_phy(efx);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = txc_bist(efx);\r\nif (rc < 0)\r\nreturn rc;\r\ntxc_apply_defaults(efx);\r\nreturn 0;\r\n}\r\nstatic void txc_glrgs_lane_power(struct ef4_nic *efx, int mmd)\r\n{\r\nint pd = (1 << TXC_GLCMD_L01PD_LBN) | (1 << TXC_GLCMD_L23PD_LBN);\r\nint ctl = ef4_mdio_read(efx, mmd, TXC_GLRGS_GLCMD);\r\nif (!(efx->phy_mode & PHY_MODE_LOW_POWER))\r\nctl &= ~pd;\r\nelse\r\nctl |= pd;\r\nef4_mdio_write(efx, mmd, TXC_GLRGS_GLCMD, ctl);\r\n}\r\nstatic void txc_analog_lane_power(struct ef4_nic *efx, int mmd)\r\n{\r\nint txpd = (1 << TXC_ATXCTL_TXPD3_LBN) | (1 << TXC_ATXCTL_TXPD2_LBN)\r\n| (1 << TXC_ATXCTL_TXPD1_LBN) | (1 << TXC_ATXCTL_TXPD0_LBN);\r\nint rxpd = (1 << TXC_ARXCTL_RXPD3_LBN) | (1 << TXC_ARXCTL_RXPD2_LBN)\r\n| (1 << TXC_ARXCTL_RXPD1_LBN) | (1 << TXC_ARXCTL_RXPD0_LBN);\r\nint txctl = ef4_mdio_read(efx, mmd, TXC_ALRGS_ATXCTL);\r\nint rxctl = ef4_mdio_read(efx, mmd, TXC_ALRGS_ARXCTL);\r\nif (!(efx->phy_mode & PHY_MODE_LOW_POWER)) {\r\ntxctl &= ~txpd;\r\nrxctl &= ~rxpd;\r\n} else {\r\ntxctl |= txpd;\r\nrxctl |= rxpd;\r\n}\r\nef4_mdio_write(efx, mmd, TXC_ALRGS_ATXCTL, txctl);\r\nef4_mdio_write(efx, mmd, TXC_ALRGS_ARXCTL, rxctl);\r\n}\r\nstatic void txc_set_power(struct ef4_nic *efx)\r\n{\r\nef4_mdio_set_mmds_lpower(efx,\r\n!!(efx->phy_mode & PHY_MODE_LOW_POWER),\r\nTXC_REQUIRED_DEVS);\r\ntxc_glrgs_lane_power(efx, MDIO_MMD_PCS);\r\ntxc_glrgs_lane_power(efx, MDIO_MMD_PHYXS);\r\ntxc_analog_lane_power(efx, MDIO_MMD_PMAPMD);\r\ntxc_analog_lane_power(efx, MDIO_MMD_PHYXS);\r\n}\r\nstatic void txc_reset_logic_mmd(struct ef4_nic *efx, int mmd)\r\n{\r\nint val = ef4_mdio_read(efx, mmd, TXC_GLRGS_GLCMD);\r\nint tries = 50;\r\nval |= (1 << TXC_GLCMD_LMTSWRST_LBN);\r\nef4_mdio_write(efx, mmd, TXC_GLRGS_GLCMD, val);\r\nwhile (--tries) {\r\nval = ef4_mdio_read(efx, mmd, TXC_GLRGS_GLCMD);\r\nif (!(val & (1 << TXC_GLCMD_LMTSWRST_LBN)))\r\nbreak;\r\nudelay(1);\r\n}\r\nif (!tries)\r\nnetif_info(efx, hw, efx->net_dev,\r\nTXCNAME " Logic reset timed out!\n");\r\n}\r\nstatic void txc_reset_logic(struct ef4_nic *efx)\r\n{\r\ntxc_reset_logic_mmd(efx, MDIO_MMD_PCS);\r\n}\r\nstatic bool txc43128_phy_read_link(struct ef4_nic *efx)\r\n{\r\nreturn ef4_mdio_links_ok(efx, TXC_REQUIRED_DEVS);\r\n}\r\nstatic int txc43128_phy_reconfigure(struct ef4_nic *efx)\r\n{\r\nstruct txc43128_data *phy_data = efx->phy_data;\r\nenum ef4_phy_mode mode_change = efx->phy_mode ^ phy_data->phy_mode;\r\nbool loop_change = LOOPBACK_CHANGED(phy_data, efx, TXC_LOOPBACKS);\r\nif (efx->phy_mode & mode_change & PHY_MODE_TX_DISABLED) {\r\ntxc_reset_phy(efx);\r\ntxc_apply_defaults(efx);\r\nfalcon_reset_xaui(efx);\r\nmode_change &= ~PHY_MODE_TX_DISABLED;\r\n}\r\nef4_mdio_transmit_disable(efx);\r\nef4_mdio_phy_reconfigure(efx);\r\nif (mode_change & PHY_MODE_LOW_POWER)\r\ntxc_set_power(efx);\r\nif (loop_change || mode_change)\r\ntxc_reset_logic(efx);\r\nphy_data->phy_mode = efx->phy_mode;\r\nphy_data->loopback_mode = efx->loopback_mode;\r\nreturn 0;\r\n}\r\nstatic void txc43128_phy_fini(struct ef4_nic *efx)\r\n{\r\nef4_mdio_write(efx, MDIO_MMD_PMAPMD, MDIO_PMA_LASI_CTRL, 0);\r\n}\r\nstatic void txc43128_phy_remove(struct ef4_nic *efx)\r\n{\r\nkfree(efx->phy_data);\r\nefx->phy_data = NULL;\r\n}\r\nstatic bool txc43128_phy_poll(struct ef4_nic *efx)\r\n{\r\nstruct txc43128_data *data = efx->phy_data;\r\nbool was_up = efx->link_state.up;\r\nefx->link_state.up = txc43128_phy_read_link(efx);\r\nefx->link_state.speed = 10000;\r\nefx->link_state.fd = true;\r\nefx->link_state.fc = efx->wanted_fc;\r\nif (efx->link_state.up || (efx->loopback_mode != LOOPBACK_NONE)) {\r\ndata->bug10934_timer = jiffies;\r\n} else {\r\nif (time_after_eq(jiffies, (data->bug10934_timer +\r\nBUG10934_RESET_INTERVAL))) {\r\ndata->bug10934_timer = jiffies;\r\ntxc_reset_logic(efx);\r\n}\r\n}\r\nreturn efx->link_state.up != was_up;\r\n}\r\nstatic const char *txc43128_test_name(struct ef4_nic *efx, unsigned int index)\r\n{\r\nif (index < ARRAY_SIZE(txc43128_test_names))\r\nreturn txc43128_test_names[index];\r\nreturn NULL;\r\n}\r\nstatic int txc43128_run_tests(struct ef4_nic *efx, int *results, unsigned flags)\r\n{\r\nint rc;\r\nif (!(flags & ETH_TEST_FL_OFFLINE))\r\nreturn 0;\r\nrc = txc_reset_phy(efx);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = txc_bist(efx);\r\ntxc_apply_defaults(efx);\r\nresults[0] = rc ? -1 : 1;\r\nreturn rc;\r\n}\r\nstatic void txc43128_get_link_ksettings(struct ef4_nic *efx,\r\nstruct ethtool_link_ksettings *cmd)\r\n{\r\nmdio45_ethtool_ksettings_get(&efx->mdio, cmd);\r\n}
