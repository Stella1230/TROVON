const char *irlmp_reason_str(LM_REASON reason)\r\n{\r\nreason = min_t(size_t, reason, ARRAY_SIZE(irlmp_reasons) - 1);\r\nreturn irlmp_reasons[reason];\r\n}\r\nint __init irlmp_init(void)\r\n{\r\nirlmp = kzalloc( sizeof(struct irlmp_cb), GFP_KERNEL);\r\nif (irlmp == NULL)\r\nreturn -ENOMEM;\r\nirlmp->magic = LMP_MAGIC;\r\nirlmp->clients = hashbin_new(HB_LOCK);\r\nirlmp->services = hashbin_new(HB_LOCK);\r\nirlmp->links = hashbin_new(HB_LOCK);\r\nirlmp->unconnected_lsaps = hashbin_new(HB_LOCK);\r\nirlmp->cachelog = hashbin_new(HB_NOLOCK);\r\nif ((irlmp->clients == NULL) ||\r\n(irlmp->services == NULL) ||\r\n(irlmp->links == NULL) ||\r\n(irlmp->unconnected_lsaps == NULL) ||\r\n(irlmp->cachelog == NULL)) {\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&irlmp->cachelog->hb_spinlock);\r\nirlmp->last_lsap_sel = 0x0f;\r\nstrcpy(sysctl_devname, "Linux");\r\ninit_timer(&irlmp->discovery_timer);\r\nif (sysctl_discovery)\r\nirlmp_start_discovery_timer(irlmp,\r\nsysctl_discovery_timeout*HZ);\r\nreturn 0;\r\n}\r\nvoid irlmp_cleanup(void)\r\n{\r\nIRDA_ASSERT(irlmp != NULL, return;);\r\nIRDA_ASSERT(irlmp->magic == LMP_MAGIC, return;);\r\ndel_timer(&irlmp->discovery_timer);\r\nhashbin_delete(irlmp->links, (FREE_FUNC) kfree);\r\nhashbin_delete(irlmp->unconnected_lsaps, (FREE_FUNC) kfree);\r\nhashbin_delete(irlmp->clients, (FREE_FUNC) kfree);\r\nhashbin_delete(irlmp->services, (FREE_FUNC) kfree);\r\nhashbin_delete(irlmp->cachelog, (FREE_FUNC) kfree);\r\nkfree(irlmp);\r\nirlmp = NULL;\r\n}\r\nstruct lsap_cb *irlmp_open_lsap(__u8 slsap_sel, notify_t *notify, __u8 pid)\r\n{\r\nstruct lsap_cb *self;\r\nIRDA_ASSERT(notify != NULL, return NULL;);\r\nIRDA_ASSERT(irlmp != NULL, return NULL;);\r\nIRDA_ASSERT(irlmp->magic == LMP_MAGIC, return NULL;);\r\nIRDA_ASSERT(notify->instance != NULL, return NULL;);\r\nif (slsap_sel == LSAP_ANY) {\r\nslsap_sel = irlmp_find_free_slsap();\r\nif (!slsap_sel)\r\nreturn NULL;\r\n} else if (irlmp_slsap_inuse(slsap_sel))\r\nreturn NULL;\r\nself = kzalloc(sizeof(struct lsap_cb), GFP_ATOMIC);\r\nif (self == NULL)\r\nreturn NULL;\r\nself->magic = LMP_LSAP_MAGIC;\r\nself->slsap_sel = slsap_sel;\r\nif (slsap_sel == LSAP_CONNLESS) {\r\n#ifdef CONFIG_IRDA_ULTRA\r\nself->dlsap_sel = LSAP_CONNLESS;\r\nself->pid = pid;\r\n#endif\r\n} else\r\nself->dlsap_sel = LSAP_ANY;\r\ninit_timer(&self->watchdog_timer);\r\nself->notify = *notify;\r\nself->lsap_state = LSAP_DISCONNECTED;\r\nhashbin_insert(irlmp->unconnected_lsaps, (irda_queue_t *) self,\r\n(long) self, NULL);\r\nreturn self;\r\n}\r\nstatic void __irlmp_close_lsap(struct lsap_cb *self)\r\n{\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LMP_LSAP_MAGIC, return;);\r\nself->magic = 0;\r\ndel_timer(&self->watchdog_timer);\r\nif (self->conn_skb)\r\ndev_kfree_skb(self->conn_skb);\r\nkfree(self);\r\n}\r\nvoid irlmp_close_lsap(struct lsap_cb *self)\r\n{\r\nstruct lap_cb *lap;\r\nstruct lsap_cb *lsap = NULL;\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LMP_LSAP_MAGIC, return;);\r\nlap = self->lap;\r\nif (lap) {\r\nIRDA_ASSERT(lap->magic == LMP_LAP_MAGIC, return;);\r\nif(self->lsap_state != LSAP_DISCONNECTED) {\r\nself->lsap_state = LSAP_DISCONNECTED;\r\nirlmp_do_lap_event(self->lap,\r\nLM_LAP_DISCONNECT_REQUEST, NULL);\r\n}\r\nlsap = hashbin_remove(lap->lsaps, (long) self, NULL);\r\n#ifdef CONFIG_IRDA_CACHE_LAST_LSAP\r\nlap->cache.valid = FALSE;\r\n#endif\r\n}\r\nself->lap = NULL;\r\nif (!lsap) {\r\nlsap = hashbin_remove(irlmp->unconnected_lsaps, (long) self,\r\nNULL);\r\n}\r\nif (!lsap) {\r\npr_debug("%s(), Looks like somebody has removed me already!\n",\r\n__func__);\r\nreturn;\r\n}\r\n__irlmp_close_lsap(self);\r\n}\r\nvoid irlmp_register_link(struct irlap_cb *irlap, __u32 saddr, notify_t *notify)\r\n{\r\nstruct lap_cb *lap;\r\nIRDA_ASSERT(irlmp != NULL, return;);\r\nIRDA_ASSERT(irlmp->magic == LMP_MAGIC, return;);\r\nIRDA_ASSERT(notify != NULL, return;);\r\nlap = kzalloc(sizeof(struct lap_cb), GFP_KERNEL);\r\nif (lap == NULL)\r\nreturn;\r\nlap->irlap = irlap;\r\nlap->magic = LMP_LAP_MAGIC;\r\nlap->saddr = saddr;\r\nlap->daddr = DEV_ADDR_ANY;\r\n#ifdef CONFIG_IRDA_CACHE_LAST_LSAP\r\nlap->cache.valid = FALSE;\r\n#endif\r\nlap->lsaps = hashbin_new(HB_LOCK);\r\nif (lap->lsaps == NULL) {\r\nnet_warn_ratelimited("%s(), unable to kmalloc lsaps\n",\r\n__func__);\r\nkfree(lap);\r\nreturn;\r\n}\r\nlap->lap_state = LAP_STANDBY;\r\ninit_timer(&lap->idle_timer);\r\nhashbin_insert(irlmp->links, (irda_queue_t *) lap, lap->saddr, NULL);\r\nirda_notify_init(notify);\r\nnotify->instance = lap;\r\n}\r\nvoid irlmp_unregister_link(__u32 saddr)\r\n{\r\nstruct lap_cb *link;\r\nlink = hashbin_remove(irlmp->links, saddr, NULL);\r\nif (link) {\r\nIRDA_ASSERT(link->magic == LMP_LAP_MAGIC, return;);\r\nlink->reason = LAP_DISC_INDICATION;\r\nlink->daddr = DEV_ADDR_ANY;\r\nirlmp_do_lap_event(link, LM_LAP_DISCONNECT_INDICATION, NULL);\r\nirlmp_expire_discoveries(irlmp->cachelog, link->saddr, TRUE);\r\ndel_timer(&link->idle_timer);\r\nlink->magic = 0;\r\nhashbin_delete(link->lsaps, (FREE_FUNC) __irlmp_close_lsap);\r\nkfree(link);\r\n}\r\n}\r\nint irlmp_connect_request(struct lsap_cb *self, __u8 dlsap_sel,\r\n__u32 saddr, __u32 daddr,\r\nstruct qos_info *qos, struct sk_buff *userdata)\r\n{\r\nstruct sk_buff *tx_skb = userdata;\r\nstruct lap_cb *lap;\r\nstruct lsap_cb *lsap;\r\nint ret;\r\nIRDA_ASSERT(self != NULL, return -EBADR;);\r\nIRDA_ASSERT(self->magic == LMP_LSAP_MAGIC, return -EBADR;);\r\npr_debug("%s(), slsap_sel=%02x, dlsap_sel=%02x, saddr=%08x, daddr=%08x\n",\r\n__func__, self->slsap_sel, dlsap_sel, saddr, daddr);\r\nif (test_bit(0, &self->connected)) {\r\nret = -EISCONN;\r\ngoto err;\r\n}\r\nif (!daddr) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nif (tx_skb == NULL) {\r\ntx_skb = alloc_skb(LMP_MAX_HEADER, GFP_ATOMIC);\r\nif (!tx_skb)\r\nreturn -ENOMEM;\r\nskb_reserve(tx_skb, LMP_MAX_HEADER);\r\n}\r\nIRDA_ASSERT(skb_headroom(tx_skb) >= LMP_CONTROL_HEADER, return -1;);\r\nskb_push(tx_skb, LMP_CONTROL_HEADER);\r\nself->dlsap_sel = dlsap_sel;\r\nif ((!saddr) || (saddr == DEV_ADDR_ANY)) {\r\ndiscovery_t *discovery;\r\nunsigned long flags;\r\nspin_lock_irqsave(&irlmp->cachelog->hb_spinlock, flags);\r\nif (daddr != DEV_ADDR_ANY)\r\ndiscovery = hashbin_find(irlmp->cachelog, daddr, NULL);\r\nelse {\r\npr_debug("%s(), no daddr\n", __func__);\r\ndiscovery = (discovery_t *)\r\nhashbin_get_first(irlmp->cachelog);\r\n}\r\nif (discovery) {\r\nsaddr = discovery->data.saddr;\r\ndaddr = discovery->data.daddr;\r\n}\r\nspin_unlock_irqrestore(&irlmp->cachelog->hb_spinlock, flags);\r\n}\r\nlap = hashbin_lock_find(irlmp->links, saddr, NULL);\r\nif (lap == NULL) {\r\npr_debug("%s(), Unable to find a usable link!\n", __func__);\r\nret = -EHOSTUNREACH;\r\ngoto err;\r\n}\r\nif (lap->daddr == DEV_ADDR_ANY)\r\nlap->daddr = daddr;\r\nelse if (lap->daddr != daddr) {\r\nif (HASHBIN_GET_SIZE(lap->lsaps) == 0) {\r\npr_debug("%s(), sorry, but I'm waiting for LAP to timeout!\n",\r\n__func__);\r\nret = -EAGAIN;\r\ngoto err;\r\n}\r\npr_debug("%s(), sorry, but link is busy!\n", __func__);\r\nret = -EBUSY;\r\ngoto err;\r\n}\r\nself->lap = lap;\r\nlsap = hashbin_remove(irlmp->unconnected_lsaps, (long) self, NULL);\r\nIRDA_ASSERT(lsap != NULL, return -1;);\r\nIRDA_ASSERT(lsap->magic == LMP_LSAP_MAGIC, return -1;);\r\nIRDA_ASSERT(lsap->lap != NULL, return -1;);\r\nIRDA_ASSERT(lsap->lap->magic == LMP_LAP_MAGIC, return -1;);\r\nhashbin_insert(self->lap->lsaps, (irda_queue_t *) self, (long) self,\r\nNULL);\r\nset_bit(0, &self->connected);\r\nif (qos)\r\nself->qos = *qos;\r\nirlmp_do_lsap_event(self, LM_CONNECT_REQUEST, tx_skb);\r\ndev_kfree_skb(tx_skb);\r\nreturn 0;\r\nerr:\r\nif(tx_skb)\r\ndev_kfree_skb(tx_skb);\r\nreturn ret;\r\n}\r\nvoid irlmp_connect_indication(struct lsap_cb *self, struct sk_buff *skb)\r\n{\r\nint max_seg_size;\r\nint lap_header_size;\r\nint max_header_size;\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LMP_LSAP_MAGIC, return;);\r\nIRDA_ASSERT(skb != NULL, return;);\r\nIRDA_ASSERT(self->lap != NULL, return;);\r\npr_debug("%s(), slsap_sel=%02x, dlsap_sel=%02x\n",\r\n__func__, self->slsap_sel, self->dlsap_sel);\r\nself->qos = *self->lap->qos;\r\nmax_seg_size = self->lap->qos->data_size.value-LMP_HEADER;\r\nlap_header_size = IRLAP_GET_HEADER_SIZE(self->lap->irlap);\r\nmax_header_size = LMP_HEADER + lap_header_size;\r\nskb_pull(skb, LMP_CONTROL_HEADER);\r\nif (self->notify.connect_indication) {\r\nskb_get(skb);\r\nself->notify.connect_indication(self->notify.instance, self,\r\n&self->qos, max_seg_size,\r\nmax_header_size, skb);\r\n}\r\n}\r\nint irlmp_connect_response(struct lsap_cb *self, struct sk_buff *userdata)\r\n{\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == LMP_LSAP_MAGIC, return -1;);\r\nIRDA_ASSERT(userdata != NULL, return -1;);\r\npr_debug("%s(), slsap_sel=%02x, dlsap_sel=%02x\n",\r\n__func__, self->slsap_sel, self->dlsap_sel);\r\nIRDA_ASSERT(skb_headroom(userdata) >= LMP_CONTROL_HEADER, return -1;);\r\nskb_push(userdata, LMP_CONTROL_HEADER);\r\nirlmp_do_lsap_event(self, LM_CONNECT_RESPONSE, userdata);\r\ndev_kfree_skb(userdata);\r\nreturn 0;\r\n}\r\nvoid irlmp_connect_confirm(struct lsap_cb *self, struct sk_buff *skb)\r\n{\r\nint max_header_size;\r\nint lap_header_size;\r\nint max_seg_size;\r\nIRDA_ASSERT(skb != NULL, return;);\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LMP_LSAP_MAGIC, return;);\r\nIRDA_ASSERT(self->lap != NULL, return;);\r\nself->qos = *self->lap->qos;\r\nmax_seg_size = self->lap->qos->data_size.value-LMP_HEADER;\r\nlap_header_size = IRLAP_GET_HEADER_SIZE(self->lap->irlap);\r\nmax_header_size = LMP_HEADER + lap_header_size;\r\npr_debug("%s(), max_header_size=%d\n",\r\n__func__, max_header_size);\r\nskb_pull(skb, LMP_CONTROL_HEADER);\r\nif (self->notify.connect_confirm) {\r\nskb_get(skb);\r\nself->notify.connect_confirm(self->notify.instance, self,\r\n&self->qos, max_seg_size,\r\nmax_header_size, skb);\r\n}\r\n}\r\nstruct lsap_cb *irlmp_dup(struct lsap_cb *orig, void *instance)\r\n{\r\nstruct lsap_cb *new;\r\nunsigned long flags;\r\nspin_lock_irqsave(&irlmp->unconnected_lsaps->hb_spinlock, flags);\r\nif ((!hashbin_find(irlmp->unconnected_lsaps, (long) orig, NULL)) ||\r\n(orig->lap == NULL)) {\r\npr_debug("%s(), invalid LSAP (wrong state)\n",\r\n__func__);\r\nspin_unlock_irqrestore(&irlmp->unconnected_lsaps->hb_spinlock,\r\nflags);\r\nreturn NULL;\r\n}\r\nnew = kmemdup(orig, sizeof(*new), GFP_ATOMIC);\r\nif (!new) {\r\npr_debug("%s(), unable to kmalloc\n", __func__);\r\nspin_unlock_irqrestore(&irlmp->unconnected_lsaps->hb_spinlock,\r\nflags);\r\nreturn NULL;\r\n}\r\nnew->conn_skb = NULL;\r\nspin_unlock_irqrestore(&irlmp->unconnected_lsaps->hb_spinlock, flags);\r\nnew->notify.instance = instance;\r\ninit_timer(&new->watchdog_timer);\r\nhashbin_insert(irlmp->unconnected_lsaps, (irda_queue_t *) new,\r\n(long) new, NULL);\r\n#ifdef CONFIG_IRDA_CACHE_LAST_LSAP\r\nnew->lap->cache.valid = FALSE;\r\n#endif\r\nreturn new;\r\n}\r\nint irlmp_disconnect_request(struct lsap_cb *self, struct sk_buff *userdata)\r\n{\r\nstruct lsap_cb *lsap;\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == LMP_LSAP_MAGIC, return -1;);\r\nIRDA_ASSERT(userdata != NULL, return -1;);\r\nif (! test_and_clear_bit(0, &self->connected)) {\r\npr_debug("%s(), already disconnected!\n", __func__);\r\ndev_kfree_skb(userdata);\r\nreturn -1;\r\n}\r\nskb_push(userdata, LMP_CONTROL_HEADER);\r\nirlmp_do_lsap_event(self, LM_DISCONNECT_REQUEST, userdata);\r\ndev_kfree_skb(userdata);\r\nIRDA_ASSERT(self->lap != NULL, return -1;);\r\nIRDA_ASSERT(self->lap->magic == LMP_LAP_MAGIC, return -1;);\r\nIRDA_ASSERT(self->lap->lsaps != NULL, return -1;);\r\nlsap = hashbin_remove(self->lap->lsaps, (long) self, NULL);\r\n#ifdef CONFIG_IRDA_CACHE_LAST_LSAP\r\nself->lap->cache.valid = FALSE;\r\n#endif\r\nIRDA_ASSERT(lsap != NULL, return -1;);\r\nIRDA_ASSERT(lsap->magic == LMP_LSAP_MAGIC, return -1;);\r\nIRDA_ASSERT(lsap == self, return -1;);\r\nhashbin_insert(irlmp->unconnected_lsaps, (irda_queue_t *) self,\r\n(long) self, NULL);\r\nself->dlsap_sel = LSAP_ANY;\r\nself->lap = NULL;\r\nreturn 0;\r\n}\r\nvoid irlmp_disconnect_indication(struct lsap_cb *self, LM_REASON reason,\r\nstruct sk_buff *skb)\r\n{\r\nstruct lsap_cb *lsap;\r\npr_debug("%s(), reason=%s [%d]\n", __func__,\r\nirlmp_reason_str(reason), reason);\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LMP_LSAP_MAGIC, return;);\r\npr_debug("%s(), slsap_sel=%02x, dlsap_sel=%02x\n",\r\n__func__, self->slsap_sel, self->dlsap_sel);\r\nif (! test_and_clear_bit(0, &self->connected)) {\r\npr_debug("%s(), already disconnected!\n", __func__);\r\nreturn;\r\n}\r\nIRDA_ASSERT(self->lap != NULL, return;);\r\nIRDA_ASSERT(self->lap->lsaps != NULL, return;);\r\nlsap = hashbin_remove(self->lap->lsaps, (long) self, NULL);\r\n#ifdef CONFIG_IRDA_CACHE_LAST_LSAP\r\nself->lap->cache.valid = FALSE;\r\n#endif\r\nIRDA_ASSERT(lsap != NULL, return;);\r\nIRDA_ASSERT(lsap == self, return;);\r\nhashbin_insert(irlmp->unconnected_lsaps, (irda_queue_t *) lsap,\r\n(long) lsap, NULL);\r\nself->dlsap_sel = LSAP_ANY;\r\nself->lap = NULL;\r\nif (self->notify.disconnect_indication) {\r\nif(skb)\r\nskb_get(skb);\r\nself->notify.disconnect_indication(self->notify.instance,\r\nself, reason, skb);\r\n} else {\r\npr_debug("%s(), no handler\n", __func__);\r\n}\r\n}\r\nvoid irlmp_do_expiry(void)\r\n{\r\nstruct lap_cb *lap;\r\nlap = (struct lap_cb *) hashbin_get_first(irlmp->links);\r\nwhile (lap != NULL) {\r\nIRDA_ASSERT(lap->magic == LMP_LAP_MAGIC, return;);\r\nif (lap->lap_state == LAP_STANDBY) {\r\nirlmp_expire_discoveries(irlmp->cachelog, lap->saddr,\r\nFALSE);\r\n}\r\nlap = (struct lap_cb *) hashbin_get_next(irlmp->links);\r\n}\r\n}\r\nvoid irlmp_do_discovery(int nslots)\r\n{\r\nstruct lap_cb *lap;\r\n__u16 *data_hintsp;\r\nif ((nslots != 1) && (nslots != 6) && (nslots != 8) && (nslots != 16)){\r\nnet_warn_ratelimited("%s: invalid value for number of slots!\n",\r\n__func__);\r\nnslots = sysctl_discovery_slots = 8;\r\n}\r\ndata_hintsp = (__u16 *) irlmp->discovery_cmd.data.hints;\r\nput_unaligned(irlmp->hints.word, data_hintsp);\r\nirlmp->discovery_cmd.data.charset = CS_ASCII;\r\nstrncpy(irlmp->discovery_cmd.data.info, sysctl_devname,\r\nNICKNAME_MAX_LEN);\r\nirlmp->discovery_cmd.name_len = strlen(irlmp->discovery_cmd.data.info);\r\nirlmp->discovery_cmd.nslots = nslots;\r\nlap = (struct lap_cb *) hashbin_get_first(irlmp->links);\r\nwhile (lap != NULL) {\r\nIRDA_ASSERT(lap->magic == LMP_LAP_MAGIC, return;);\r\nif (lap->lap_state == LAP_STANDBY) {\r\nirlmp_do_lap_event(lap, LM_LAP_DISCOVERY_REQUEST,\r\nNULL);\r\n}\r\nlap = (struct lap_cb *) hashbin_get_next(irlmp->links);\r\n}\r\n}\r\nvoid irlmp_discovery_request(int nslots)\r\n{\r\nirlmp_discovery_confirm(irlmp->cachelog, DISCOVERY_LOG);\r\nif (!sysctl_discovery) {\r\nif (nslots == DISCOVERY_DEFAULT_SLOTS)\r\nnslots = sysctl_discovery_slots;\r\nirlmp_do_discovery(nslots);\r\n}\r\n}\r\nstruct irda_device_info *irlmp_get_discoveries(int *pn, __u16 mask, int nslots)\r\n{\r\nif (!sysctl_discovery) {\r\nif (nslots == DISCOVERY_DEFAULT_SLOTS)\r\nnslots = sysctl_discovery_slots;\r\nirlmp_do_discovery(nslots);\r\n}\r\nreturn irlmp_copy_discoveries(irlmp->cachelog, pn, mask, TRUE);\r\n}\r\nstatic inline void\r\nirlmp_notify_client(irlmp_client_t *client,\r\nhashbin_t *log, DISCOVERY_MODE mode)\r\n{\r\ndiscinfo_t *discoveries;\r\nint number;\r\nint i;\r\nif (!client->disco_callback)\r\nreturn;\r\ndiscoveries = irlmp_copy_discoveries(log, &number,\r\nclient->hint_mask.word,\r\n(mode == DISCOVERY_LOG));\r\nif (discoveries == NULL)\r\nreturn;\r\nfor(i = 0; i < number; i++)\r\nclient->disco_callback(&(discoveries[i]), mode, client->priv);\r\nkfree(discoveries);\r\n}\r\nvoid irlmp_discovery_confirm(hashbin_t *log, DISCOVERY_MODE mode)\r\n{\r\nirlmp_client_t *client;\r\nirlmp_client_t *client_next;\r\nIRDA_ASSERT(log != NULL, return;);\r\nif (!(HASHBIN_GET_SIZE(log)))\r\nreturn;\r\nclient = (irlmp_client_t *) hashbin_get_first(irlmp->clients);\r\nwhile (NULL != hashbin_find_next(irlmp->clients, (long) client, NULL,\r\n(void *) &client_next) ) {\r\nirlmp_notify_client(client, log, mode);\r\nclient = client_next;\r\n}\r\n}\r\nvoid irlmp_discovery_expiry(discinfo_t *expiries, int number)\r\n{\r\nirlmp_client_t *client;\r\nirlmp_client_t *client_next;\r\nint i;\r\nIRDA_ASSERT(expiries != NULL, return;);\r\nclient = (irlmp_client_t *) hashbin_get_first(irlmp->clients);\r\nwhile (NULL != hashbin_find_next(irlmp->clients, (long) client, NULL,\r\n(void *) &client_next) ) {\r\nfor(i = 0; i < number; i++) {\r\nif ((client->expir_callback) &&\r\n(client->hint_mask.word &\r\nget_unaligned((__u16 *)expiries[i].hints)\r\n& 0x7f7f) )\r\nclient->expir_callback(&(expiries[i]),\r\nEXPIRY_TIMEOUT,\r\nclient->priv);\r\n}\r\nclient = client_next;\r\n}\r\n}\r\ndiscovery_t *irlmp_get_discovery_response(void)\r\n{\r\nIRDA_ASSERT(irlmp != NULL, return NULL;);\r\nput_unaligned(irlmp->hints.word, (__u16 *)irlmp->discovery_rsp.data.hints);\r\nirlmp->discovery_rsp.data.charset = CS_ASCII;\r\nstrncpy(irlmp->discovery_rsp.data.info, sysctl_devname,\r\nNICKNAME_MAX_LEN);\r\nirlmp->discovery_rsp.name_len = strlen(irlmp->discovery_rsp.data.info);\r\nreturn &irlmp->discovery_rsp;\r\n}\r\nint irlmp_data_request(struct lsap_cb *self, struct sk_buff *userdata)\r\n{\r\nint ret;\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == LMP_LSAP_MAGIC, return -1;);\r\nIRDA_ASSERT(skb_headroom(userdata) >= LMP_HEADER, return -1;);\r\nskb_push(userdata, LMP_HEADER);\r\nret = irlmp_do_lsap_event(self, LM_DATA_REQUEST, userdata);\r\ndev_kfree_skb(userdata);\r\nreturn ret;\r\n}\r\nvoid irlmp_data_indication(struct lsap_cb *self, struct sk_buff *skb)\r\n{\r\nskb_pull(skb, LMP_HEADER);\r\nif (self->notify.data_indication) {\r\nskb_get(skb);\r\nself->notify.data_indication(self->notify.instance, self, skb);\r\n}\r\n}\r\nint irlmp_udata_request(struct lsap_cb *self, struct sk_buff *userdata)\r\n{\r\nint ret;\r\nIRDA_ASSERT(userdata != NULL, return -1;);\r\nIRDA_ASSERT(skb_headroom(userdata) >= LMP_HEADER, return -1;);\r\nskb_push(userdata, LMP_HEADER);\r\nret = irlmp_do_lsap_event(self, LM_UDATA_REQUEST, userdata);\r\ndev_kfree_skb(userdata);\r\nreturn ret;\r\n}\r\nvoid irlmp_udata_indication(struct lsap_cb *self, struct sk_buff *skb)\r\n{\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LMP_LSAP_MAGIC, return;);\r\nIRDA_ASSERT(skb != NULL, return;);\r\nskb_pull(skb, LMP_HEADER);\r\nif (self->notify.udata_indication) {\r\nskb_get(skb);\r\nself->notify.udata_indication(self->notify.instance, self,\r\nskb);\r\n}\r\n}\r\nint irlmp_connless_data_request(struct lsap_cb *self, struct sk_buff *userdata,\r\n__u8 pid)\r\n{\r\nstruct sk_buff *clone_skb;\r\nstruct lap_cb *lap;\r\nIRDA_ASSERT(userdata != NULL, return -1;);\r\nIRDA_ASSERT(skb_headroom(userdata) >= LMP_HEADER+LMP_PID_HEADER,\r\nreturn -1;);\r\nskb_push(userdata, LMP_PID_HEADER);\r\nif(self != NULL)\r\nuserdata->data[0] = self->pid;\r\nelse\r\nuserdata->data[0] = pid;\r\nskb_push(userdata, LMP_HEADER);\r\nuserdata->data[0] = userdata->data[1] = LSAP_CONNLESS;\r\nlap = (struct lap_cb *) hashbin_get_first(irlmp->links);\r\nwhile (lap != NULL) {\r\nIRDA_ASSERT(lap->magic == LMP_LAP_MAGIC, return -1;);\r\nclone_skb = skb_clone(userdata, GFP_ATOMIC);\r\nif (!clone_skb) {\r\ndev_kfree_skb(userdata);\r\nreturn -ENOMEM;\r\n}\r\nirlap_unitdata_request(lap->irlap, clone_skb);\r\nlap = (struct lap_cb *) hashbin_get_next(irlmp->links);\r\n}\r\ndev_kfree_skb(userdata);\r\nreturn 0;\r\n}\r\nvoid irlmp_connless_data_indication(struct lsap_cb *self, struct sk_buff *skb)\r\n{\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LMP_LSAP_MAGIC, return;);\r\nIRDA_ASSERT(skb != NULL, return;);\r\nskb_pull(skb, LMP_HEADER+LMP_PID_HEADER);\r\nif (self->notify.udata_indication) {\r\nskb_get(skb);\r\nself->notify.udata_indication(self->notify.instance, self,\r\nskb);\r\n}\r\n}\r\nvoid irlmp_status_indication(struct lap_cb *self,\r\nLINK_STATUS link, LOCK_STATUS lock)\r\n{\r\nstruct lsap_cb *next;\r\nstruct lsap_cb *curr;\r\ncurr = (struct lsap_cb *) hashbin_get_first( self->lsaps);\r\nwhile (NULL != hashbin_find_next(self->lsaps, (long) curr, NULL,\r\n(void *) &next) ) {\r\nIRDA_ASSERT(curr->magic == LMP_LSAP_MAGIC, return;);\r\nif (curr->notify.status_indication != NULL)\r\ncurr->notify.status_indication(curr->notify.instance,\r\nlink, lock);\r\nelse\r\npr_debug("%s(), no handler\n", __func__);\r\ncurr = next;\r\n}\r\n}\r\nvoid irlmp_flow_indication(struct lap_cb *self, LOCAL_FLOW flow)\r\n{\r\nstruct lsap_cb *next;\r\nstruct lsap_cb *curr;\r\nint lsap_todo;\r\nIRDA_ASSERT(self->magic == LMP_LAP_MAGIC, return;);\r\nIRDA_ASSERT(flow == FLOW_START, return;);\r\nlsap_todo = HASHBIN_GET_SIZE(self->lsaps);\r\npr_debug("%s() : %d lsaps to scan\n", __func__, lsap_todo);\r\nwhile((lsap_todo--) &&\r\n(IRLAP_GET_TX_QUEUE_LEN(self->irlap) < LAP_HIGH_THRESHOLD)) {\r\nnext = self->flow_next;\r\nif(next == NULL)\r\nnext = (struct lsap_cb *) hashbin_get_first(self->lsaps);\r\ncurr = hashbin_find_next(self->lsaps, (long) next, NULL,\r\n(void *) &self->flow_next);\r\nif(curr == NULL)\r\nbreak;\r\npr_debug("%s() : curr is %p, next was %p and is now %p, still %d to go - queue len = %d\n",\r\n__func__, curr, next, self->flow_next, lsap_todo,\r\nIRLAP_GET_TX_QUEUE_LEN(self->irlap));\r\nif (curr->notify.flow_indication != NULL)\r\ncurr->notify.flow_indication(curr->notify.instance,\r\ncurr, flow);\r\nelse\r\npr_debug("%s(), no handler\n", __func__);\r\n}\r\n}\r\n__u16 irlmp_service_to_hint(int service)\r\n{\r\n__u16_host_order hint;\r\nhint.byte[0] = service_hint_mapping[service][0];\r\nhint.byte[1] = service_hint_mapping[service][1];\r\nreturn hint.word;\r\n}\r\nvoid *irlmp_register_service(__u16 hints)\r\n{\r\nirlmp_service_t *service;\r\npr_debug("%s(), hints = %04x\n", __func__, hints);\r\nservice = kmalloc(sizeof(irlmp_service_t), GFP_ATOMIC);\r\nif (!service)\r\nreturn NULL;\r\nservice->hints.word = hints;\r\nhashbin_insert(irlmp->services, (irda_queue_t *) service,\r\n(long) service, NULL);\r\nirlmp->hints.word |= hints;\r\nreturn (void *)service;\r\n}\r\nint irlmp_unregister_service(void *handle)\r\n{\r\nirlmp_service_t *service;\r\nunsigned long flags;\r\nif (!handle)\r\nreturn -1;\r\nservice = hashbin_lock_find(irlmp->services, (long) handle, NULL);\r\nif (!service) {\r\npr_debug("%s(), Unknown service!\n", __func__);\r\nreturn -1;\r\n}\r\nhashbin_remove_this(irlmp->services, (irda_queue_t *) service);\r\nkfree(service);\r\nirlmp->hints.word = 0;\r\nspin_lock_irqsave(&irlmp->services->hb_spinlock, flags);\r\nservice = (irlmp_service_t *) hashbin_get_first(irlmp->services);\r\nwhile (service) {\r\nirlmp->hints.word |= service->hints.word;\r\nservice = (irlmp_service_t *)hashbin_get_next(irlmp->services);\r\n}\r\nspin_unlock_irqrestore(&irlmp->services->hb_spinlock, flags);\r\nreturn 0;\r\n}\r\nvoid *irlmp_register_client(__u16 hint_mask, DISCOVERY_CALLBACK1 disco_clb,\r\nDISCOVERY_CALLBACK2 expir_clb, void *priv)\r\n{\r\nirlmp_client_t *client;\r\nIRDA_ASSERT(irlmp != NULL, return NULL;);\r\nclient = kmalloc(sizeof(irlmp_client_t), GFP_ATOMIC);\r\nif (!client)\r\nreturn NULL;\r\nclient->hint_mask.word = hint_mask;\r\nclient->disco_callback = disco_clb;\r\nclient->expir_callback = expir_clb;\r\nclient->priv = priv;\r\nhashbin_insert(irlmp->clients, (irda_queue_t *) client,\r\n(long) client, NULL);\r\nreturn (void *) client;\r\n}\r\nint irlmp_update_client(void *handle, __u16 hint_mask,\r\nDISCOVERY_CALLBACK1 disco_clb,\r\nDISCOVERY_CALLBACK2 expir_clb, void *priv)\r\n{\r\nirlmp_client_t *client;\r\nif (!handle)\r\nreturn -1;\r\nclient = hashbin_lock_find(irlmp->clients, (long) handle, NULL);\r\nif (!client) {\r\npr_debug("%s(), Unknown client!\n", __func__);\r\nreturn -1;\r\n}\r\nclient->hint_mask.word = hint_mask;\r\nclient->disco_callback = disco_clb;\r\nclient->expir_callback = expir_clb;\r\nclient->priv = priv;\r\nreturn 0;\r\n}\r\nint irlmp_unregister_client(void *handle)\r\n{\r\nstruct irlmp_client *client;\r\nif (!handle)\r\nreturn -1;\r\nclient = hashbin_lock_find(irlmp->clients, (long) handle, NULL);\r\nif (!client) {\r\npr_debug("%s(), Unknown client!\n", __func__);\r\nreturn -1;\r\n}\r\npr_debug("%s(), removing client!\n", __func__);\r\nhashbin_remove_this(irlmp->clients, (irda_queue_t *) client);\r\nkfree(client);\r\nreturn 0;\r\n}\r\nstatic int irlmp_slsap_inuse(__u8 slsap_sel)\r\n{\r\nstruct lsap_cb *self;\r\nstruct lap_cb *lap;\r\nunsigned long flags;\r\nIRDA_ASSERT(irlmp != NULL, return TRUE;);\r\nIRDA_ASSERT(irlmp->magic == LMP_MAGIC, return TRUE;);\r\nIRDA_ASSERT(slsap_sel != LSAP_ANY, return TRUE;);\r\n#ifdef CONFIG_IRDA_ULTRA\r\nif (slsap_sel == LSAP_CONNLESS)\r\nreturn FALSE;\r\n#endif\r\nif (slsap_sel > LSAP_MAX)\r\nreturn TRUE;\r\nspin_lock_irqsave_nested(&irlmp->links->hb_spinlock, flags,\r\nSINGLE_DEPTH_NESTING);\r\nlap = (struct lap_cb *) hashbin_get_first(irlmp->links);\r\nwhile (lap != NULL) {\r\nIRDA_ASSERT(lap->magic == LMP_LAP_MAGIC, goto errlap;);\r\nspin_lock(&lap->lsaps->hb_spinlock);\r\nself = (struct lsap_cb *) hashbin_get_first(lap->lsaps);\r\nwhile (self != NULL) {\r\nIRDA_ASSERT(self->magic == LMP_LSAP_MAGIC,\r\ngoto errlsap;);\r\nif ((self->slsap_sel == slsap_sel)) {\r\npr_debug("Source LSAP selector=%02x in use\n",\r\nself->slsap_sel);\r\ngoto errlsap;\r\n}\r\nself = (struct lsap_cb*) hashbin_get_next(lap->lsaps);\r\n}\r\nspin_unlock(&lap->lsaps->hb_spinlock);\r\nlap = (struct lap_cb *) hashbin_get_next(irlmp->links);\r\n}\r\nspin_unlock_irqrestore(&irlmp->links->hb_spinlock, flags);\r\nspin_lock_irqsave(&irlmp->unconnected_lsaps->hb_spinlock, flags);\r\nself = (struct lsap_cb *) hashbin_get_first(irlmp->unconnected_lsaps);\r\nwhile (self != NULL) {\r\nIRDA_ASSERT(self->magic == LMP_LSAP_MAGIC, goto erruncon;);\r\nif ((self->slsap_sel == slsap_sel)) {\r\npr_debug("Source LSAP selector=%02x in use (unconnected)\n",\r\nself->slsap_sel);\r\ngoto erruncon;\r\n}\r\nself = (struct lsap_cb*) hashbin_get_next(irlmp->unconnected_lsaps);\r\n}\r\nspin_unlock_irqrestore(&irlmp->unconnected_lsaps->hb_spinlock, flags);\r\nreturn FALSE;\r\nerrlsap:\r\nspin_unlock(&lap->lsaps->hb_spinlock);\r\nIRDA_ASSERT_LABEL(errlap:)\r\nspin_unlock_irqrestore(&irlmp->links->hb_spinlock, flags);\r\nreturn TRUE;\r\nerruncon:\r\nspin_unlock_irqrestore(&irlmp->unconnected_lsaps->hb_spinlock, flags);\r\nreturn TRUE;\r\n}\r\nstatic __u8 irlmp_find_free_slsap(void)\r\n{\r\n__u8 lsap_sel;\r\nint wrapped = 0;\r\nIRDA_ASSERT(irlmp != NULL, return -1;);\r\nIRDA_ASSERT(irlmp->magic == LMP_MAGIC, return -1;);\r\ndo {\r\nirlmp->last_lsap_sel++;\r\nif (irlmp->last_lsap_sel > LSAP_MAX) {\r\nirlmp->last_lsap_sel = 0x10;\r\nif (wrapped++) {\r\nnet_err_ratelimited("%s: no more free LSAPs !\n",\r\n__func__);\r\nreturn 0;\r\n}\r\n}\r\n} while (irlmp_slsap_inuse(irlmp->last_lsap_sel));\r\nlsap_sel = irlmp->last_lsap_sel;\r\npr_debug("%s(), found free lsap_sel=%02x\n",\r\n__func__, lsap_sel);\r\nreturn lsap_sel;\r\n}\r\nLM_REASON irlmp_convert_lap_reason( LAP_REASON lap_reason)\r\n{\r\nint reason = LM_LAP_DISCONNECT;\r\nswitch (lap_reason) {\r\ncase LAP_DISC_INDICATION:\r\npr_debug("%s(), LAP_DISC_INDICATION\n", __func__);\r\nreason = LM_USER_REQUEST;\r\nbreak;\r\ncase LAP_NO_RESPONSE:\r\npr_debug("%s(), LAP_NO_RESPONSE\n", __func__);\r\nreason = LM_LAP_DISCONNECT;\r\nbreak;\r\ncase LAP_RESET_INDICATION:\r\npr_debug("%s(), LAP_RESET_INDICATION\n", __func__);\r\nreason = LM_LAP_RESET;\r\nbreak;\r\ncase LAP_FOUND_NONE:\r\ncase LAP_MEDIA_BUSY:\r\ncase LAP_PRIMARY_CONFLICT:\r\npr_debug("%s(), LAP_FOUND_NONE, LAP_MEDIA_BUSY or LAP_PRIMARY_CONFLICT\n",\r\n__func__);\r\nreason = LM_CONNECT_FAILURE;\r\nbreak;\r\ndefault:\r\npr_debug("%s(), Unknown IrLAP disconnect reason %d!\n",\r\n__func__, lap_reason);\r\nreason = LM_LAP_DISCONNECT;\r\nbreak;\r\n}\r\nreturn reason;\r\n}\r\nstatic void *irlmp_seq_hb_idx(struct irlmp_iter_state *iter, loff_t *off)\r\n{\r\nvoid *element;\r\nspin_lock_irq(&iter->hashbin->hb_spinlock);\r\nfor (element = hashbin_get_first(iter->hashbin);\r\nelement != NULL;\r\nelement = hashbin_get_next(iter->hashbin)) {\r\nif (!off || (*off)-- == 0) {\r\nreturn element;\r\n}\r\n}\r\nspin_unlock_irq(&iter->hashbin->hb_spinlock);\r\niter->hashbin = NULL;\r\nreturn NULL;\r\n}\r\nstatic void *irlmp_seq_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nstruct irlmp_iter_state *iter = seq->private;\r\nvoid *v;\r\nloff_t off = *pos;\r\niter->hashbin = NULL;\r\nif (off-- == 0)\r\nreturn LSAP_START_TOKEN;\r\niter->hashbin = irlmp->unconnected_lsaps;\r\nv = irlmp_seq_hb_idx(iter, &off);\r\nif (v)\r\nreturn v;\r\nif (off-- == 0)\r\nreturn LINK_START_TOKEN;\r\niter->hashbin = irlmp->links;\r\nreturn irlmp_seq_hb_idx(iter, &off);\r\n}\r\nstatic void *irlmp_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nstruct irlmp_iter_state *iter = seq->private;\r\n++*pos;\r\nif (v == LSAP_START_TOKEN) {\r\niter->hashbin = irlmp->unconnected_lsaps;\r\nv = irlmp_seq_hb_idx(iter, NULL);\r\nreturn v ? v : LINK_START_TOKEN;\r\n}\r\nif (v == LINK_START_TOKEN) {\r\niter->hashbin = irlmp->links;\r\nreturn irlmp_seq_hb_idx(iter, NULL);\r\n}\r\nv = hashbin_get_next(iter->hashbin);\r\nif (v == NULL) {\r\nspin_unlock_irq(&iter->hashbin->hb_spinlock);\r\nif (iter->hashbin == irlmp->unconnected_lsaps)\r\nv = LINK_START_TOKEN;\r\niter->hashbin = NULL;\r\n}\r\nreturn v;\r\n}\r\nstatic void irlmp_seq_stop(struct seq_file *seq, void *v)\r\n{\r\nstruct irlmp_iter_state *iter = seq->private;\r\nif (iter->hashbin)\r\nspin_unlock_irq(&iter->hashbin->hb_spinlock);\r\n}\r\nstatic int irlmp_seq_show(struct seq_file *seq, void *v)\r\n{\r\nconst struct irlmp_iter_state *iter = seq->private;\r\nstruct lsap_cb *self = v;\r\nif (v == LSAP_START_TOKEN)\r\nseq_puts(seq, "Unconnected LSAPs:\n");\r\nelse if (v == LINK_START_TOKEN)\r\nseq_puts(seq, "\nRegistered Link Layers:\n");\r\nelse if (iter->hashbin == irlmp->unconnected_lsaps) {\r\nself = v;\r\nIRDA_ASSERT(self->magic == LMP_LSAP_MAGIC, return -EINVAL; );\r\nseq_printf(seq, "lsap state: %s, ",\r\nirlsap_state[ self->lsap_state]);\r\nseq_printf(seq,\r\n"slsap_sel: %#02x, dlsap_sel: %#02x, ",\r\nself->slsap_sel, self->dlsap_sel);\r\nseq_printf(seq, "(%s)", self->notify.name);\r\nseq_printf(seq, "\n");\r\n} else if (iter->hashbin == irlmp->links) {\r\nstruct lap_cb *lap = v;\r\nseq_printf(seq, "lap state: %s, ",\r\nirlmp_state[lap->lap_state]);\r\nseq_printf(seq, "saddr: %#08x, daddr: %#08x, ",\r\nlap->saddr, lap->daddr);\r\nseq_printf(seq, "num lsaps: %d",\r\nHASHBIN_GET_SIZE(lap->lsaps));\r\nseq_printf(seq, "\n");\r\nspin_lock(&lap->lsaps->hb_spinlock);\r\nseq_printf(seq, "\n Connected LSAPs:\n");\r\nfor (self = (struct lsap_cb *) hashbin_get_first(lap->lsaps);\r\nself != NULL;\r\nself = (struct lsap_cb *)hashbin_get_next(lap->lsaps)) {\r\nIRDA_ASSERT(self->magic == LMP_LSAP_MAGIC,\r\ngoto outloop;);\r\nseq_printf(seq, " lsap state: %s, ",\r\nirlsap_state[ self->lsap_state]);\r\nseq_printf(seq,\r\n"slsap_sel: %#02x, dlsap_sel: %#02x, ",\r\nself->slsap_sel, self->dlsap_sel);\r\nseq_printf(seq, "(%s)", self->notify.name);\r\nseq_putc(seq, '\n');\r\n}\r\nIRDA_ASSERT_LABEL(outloop:)\r\nspin_unlock(&lap->lsaps->hb_spinlock);\r\nseq_putc(seq, '\n');\r\n} else\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int irlmp_seq_open(struct inode *inode, struct file *file)\r\n{\r\nIRDA_ASSERT(irlmp != NULL, return -EINVAL;);\r\nreturn seq_open_private(file, &irlmp_seq_ops,\r\nsizeof(struct irlmp_iter_state));\r\n}
