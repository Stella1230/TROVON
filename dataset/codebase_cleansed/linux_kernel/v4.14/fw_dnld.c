static struct sk_buff *alloc_lc_skb(struct nfcmrvl_private *priv, uint8_t plen)\r\n{\r\nstruct sk_buff *skb;\r\nstruct nci_data_hdr *hdr;\r\nskb = nci_skb_alloc(priv->ndev, (NCI_DATA_HDR_SIZE + plen), GFP_KERNEL);\r\nif (!skb) {\r\npr_err("no memory for data\n");\r\nreturn NULL;\r\n}\r\nhdr = skb_put(skb, NCI_DATA_HDR_SIZE);\r\nhdr->conn_id = NCI_CORE_LC_CONNID_PROP_FW_DL;\r\nhdr->rfu = 0;\r\nhdr->plen = plen;\r\nnci_mt_set((__u8 *)hdr, NCI_MT_DATA_PKT);\r\nnci_pbf_set((__u8 *)hdr, NCI_PBF_LAST);\r\nreturn skb;\r\n}\r\nstatic void fw_dnld_over(struct nfcmrvl_private *priv, u32 error)\r\n{\r\nif (priv->fw_dnld.fw) {\r\nrelease_firmware(priv->fw_dnld.fw);\r\npriv->fw_dnld.fw = NULL;\r\npriv->fw_dnld.header = NULL;\r\npriv->fw_dnld.binary_config = NULL;\r\n}\r\natomic_set(&priv->ndev->cmd_cnt, 0);\r\nif (timer_pending(&priv->ndev->cmd_timer))\r\ndel_timer_sync(&priv->ndev->cmd_timer);\r\nif (timer_pending(&priv->fw_dnld.timer))\r\ndel_timer_sync(&priv->fw_dnld.timer);\r\nnfc_info(priv->dev, "FW loading over (%d)]\n", error);\r\nif (error != 0) {\r\nnfcmrvl_chip_halt(priv);\r\n}\r\nnfc_fw_download_done(priv->ndev->nfc_dev, priv->fw_dnld.name, error);\r\n}\r\nstatic void fw_dnld_timeout(unsigned long arg)\r\n{\r\nstruct nfcmrvl_private *priv = (struct nfcmrvl_private *) arg;\r\nnfc_err(priv->dev, "FW loading timeout");\r\npriv->fw_dnld.state = STATE_RESET;\r\nfw_dnld_over(priv, -ETIMEDOUT);\r\n}\r\nstatic int process_state_reset(struct nfcmrvl_private *priv,\r\nstruct sk_buff *skb)\r\n{\r\nif (sizeof(nci_pattern_core_reset_ntf) != skb->len ||\r\nmemcmp(skb->data, nci_pattern_core_reset_ntf,\r\nsizeof(nci_pattern_core_reset_ntf)))\r\nreturn -EINVAL;\r\nnfc_info(priv->dev, "BootROM reset, start fw download\n");\r\npriv->fw_dnld.state = STATE_INIT;\r\nnci_send_cmd(priv->ndev, NCI_OP_CORE_INIT_CMD, 0, NULL);\r\nreturn 0;\r\n}\r\nstatic int process_state_init(struct nfcmrvl_private *priv, struct sk_buff *skb)\r\n{\r\nstruct nci_core_set_config_cmd cmd;\r\nif (sizeof(nci_pattern_core_init_rsp) >= skb->len ||\r\nmemcmp(skb->data, nci_pattern_core_init_rsp,\r\nsizeof(nci_pattern_core_init_rsp)))\r\nreturn -EINVAL;\r\ncmd.num_params = 1;\r\ncmd.param.id = NFCMRVL_PROP_REF_CLOCK;\r\ncmd.param.len = 4;\r\nmemcpy(cmd.param.val, &priv->fw_dnld.header->ref_clock, 4);\r\nnci_send_cmd(priv->ndev, NCI_OP_CORE_SET_CONFIG_CMD, 3 + cmd.param.len,\r\n&cmd);\r\npriv->fw_dnld.state = STATE_SET_REF_CLOCK;\r\nreturn 0;\r\n}\r\nstatic void create_lc(struct nfcmrvl_private *priv)\r\n{\r\nuint8_t param[2] = { NCI_CORE_LC_PROP_FW_DL, 0x0 };\r\npriv->fw_dnld.state = STATE_OPEN_LC;\r\nnci_send_cmd(priv->ndev, NCI_OP_CORE_CONN_CREATE_CMD, 2, param);\r\n}\r\nstatic int process_state_set_ref_clock(struct nfcmrvl_private *priv,\r\nstruct sk_buff *skb)\r\n{\r\nstruct nci_core_set_config_cmd cmd;\r\nif (sizeof(nci_pattern_core_set_config_rsp) != skb->len ||\r\nmemcmp(skb->data, nci_pattern_core_set_config_rsp, skb->len))\r\nreturn -EINVAL;\r\ncmd.num_params = 1;\r\ncmd.param.id = NFCMRVL_PROP_SET_HI_CONFIG;\r\nswitch (priv->phy) {\r\ncase NFCMRVL_PHY_UART:\r\ncmd.param.len = 5;\r\nmemcpy(cmd.param.val,\r\n&priv->fw_dnld.binary_config->uart.baudrate,\r\n4);\r\ncmd.param.val[4] =\r\npriv->fw_dnld.binary_config->uart.flow_control;\r\nbreak;\r\ncase NFCMRVL_PHY_I2C:\r\ncmd.param.len = 5;\r\nmemcpy(cmd.param.val,\r\n&priv->fw_dnld.binary_config->i2c.clk,\r\n4);\r\ncmd.param.val[4] = 0;\r\nbreak;\r\ncase NFCMRVL_PHY_SPI:\r\ncmd.param.len = 5;\r\nmemcpy(cmd.param.val,\r\n&priv->fw_dnld.binary_config->spi.clk,\r\n4);\r\ncmd.param.val[4] = 0;\r\nbreak;\r\ndefault:\r\ncreate_lc(priv);\r\nreturn 0;\r\n}\r\npriv->fw_dnld.state = STATE_SET_HI_CONFIG;\r\nnci_send_cmd(priv->ndev, NCI_OP_CORE_SET_CONFIG_CMD, 3 + cmd.param.len,\r\n&cmd);\r\nreturn 0;\r\n}\r\nstatic int process_state_set_hi_config(struct nfcmrvl_private *priv,\r\nstruct sk_buff *skb)\r\n{\r\nif (sizeof(nci_pattern_core_set_config_rsp) != skb->len ||\r\nmemcmp(skb->data, nci_pattern_core_set_config_rsp, skb->len))\r\nreturn -EINVAL;\r\ncreate_lc(priv);\r\nreturn 0;\r\n}\r\nstatic int process_state_open_lc(struct nfcmrvl_private *priv,\r\nstruct sk_buff *skb)\r\n{\r\nif (sizeof(nci_pattern_core_conn_create_rsp) >= skb->len ||\r\nmemcmp(skb->data, nci_pattern_core_conn_create_rsp,\r\nsizeof(nci_pattern_core_conn_create_rsp)))\r\nreturn -EINVAL;\r\npriv->fw_dnld.state = STATE_FW_DNLD;\r\npriv->fw_dnld.substate = SUBSTATE_WAIT_COMMAND;\r\npriv->fw_dnld.offset = priv->fw_dnld.binary_config->offset;\r\nreturn 0;\r\n}\r\nstatic int process_state_fw_dnld(struct nfcmrvl_private *priv,\r\nstruct sk_buff *skb)\r\n{\r\nuint16_t len;\r\nuint16_t comp_len;\r\nstruct sk_buff *out_skb;\r\nswitch (priv->fw_dnld.substate) {\r\ncase SUBSTATE_WAIT_COMMAND:\r\nskb_pull(skb, 3);\r\nif (skb->data[0] != HELPER_CMD_PACKET_FORMAT || skb->len != 5) {\r\nnfc_err(priv->dev, "bad command");\r\nreturn -EINVAL;\r\n}\r\nskb_pull(skb, 1);\r\nlen = get_unaligned_le16(skb->data);\r\nskb_pull(skb, 2);\r\ncomp_len = get_unaligned_le16(skb->data);\r\nmemcpy(&comp_len, skb->data, 2);\r\nskb_pull(skb, 2);\r\nif (((~len) & 0xFFFF) != comp_len) {\r\nnfc_err(priv->dev, "bad len complement: %x %x %x",\r\nlen, comp_len, (~len & 0xFFFF));\r\nout_skb = alloc_lc_skb(priv, 1);\r\nif (!out_skb)\r\nreturn -ENOMEM;\r\nskb_put_u8(out_skb, 0xBF);\r\nnci_send_frame(priv->ndev, out_skb);\r\npriv->fw_dnld.substate = SUBSTATE_WAIT_NACK_CREDIT;\r\nreturn 0;\r\n}\r\npriv->fw_dnld.chunk_len = len;\r\nout_skb = alloc_lc_skb(priv, 1);\r\nif (!out_skb)\r\nreturn -ENOMEM;\r\nskb_put_u8(out_skb, HELPER_ACK_PACKET_FORMAT);\r\nnci_send_frame(priv->ndev, out_skb);\r\npriv->fw_dnld.substate = SUBSTATE_WAIT_ACK_CREDIT;\r\nbreak;\r\ncase SUBSTATE_WAIT_ACK_CREDIT:\r\nif (sizeof(nci_pattern_core_conn_credits_ntf) != skb->len ||\r\nmemcmp(nci_pattern_core_conn_credits_ntf, skb->data,\r\nskb->len)) {\r\nnfc_err(priv->dev, "bad packet: waiting for credit");\r\nreturn -EINVAL;\r\n}\r\nif (priv->fw_dnld.chunk_len == 0) {\r\nuint8_t conn_id = NCI_CORE_LC_CONNID_PROP_FW_DL;\r\npriv->fw_dnld.state = STATE_CLOSE_LC;\r\nnci_send_cmd(priv->ndev, NCI_OP_CORE_CONN_CLOSE_CMD,\r\n1, &conn_id);\r\n} else {\r\nout_skb = alloc_lc_skb(priv, priv->fw_dnld.chunk_len);\r\nif (!out_skb)\r\nreturn -ENOMEM;\r\nskb_put_data(out_skb,\r\n((uint8_t *)priv->fw_dnld.fw->data) + priv->fw_dnld.offset,\r\npriv->fw_dnld.chunk_len);\r\nnci_send_frame(priv->ndev, out_skb);\r\npriv->fw_dnld.substate = SUBSTATE_WAIT_DATA_CREDIT;\r\n}\r\nbreak;\r\ncase SUBSTATE_WAIT_DATA_CREDIT:\r\nif (sizeof(nci_pattern_core_conn_credits_ntf) != skb->len ||\r\nmemcmp(nci_pattern_core_conn_credits_ntf, skb->data,\r\nskb->len)) {\r\nnfc_err(priv->dev, "bad packet: waiting for credit");\r\nreturn -EINVAL;\r\n}\r\npriv->fw_dnld.offset += priv->fw_dnld.chunk_len;\r\npriv->fw_dnld.chunk_len = 0;\r\npriv->fw_dnld.substate = SUBSTATE_WAIT_COMMAND;\r\nbreak;\r\ncase SUBSTATE_WAIT_NACK_CREDIT:\r\nif (sizeof(nci_pattern_core_conn_credits_ntf) != skb->len ||\r\nmemcmp(nci_pattern_core_conn_credits_ntf, skb->data,\r\nskb->len)) {\r\nnfc_err(priv->dev, "bad packet: waiting for credit");\r\nreturn -EINVAL;\r\n}\r\npriv->fw_dnld.substate = SUBSTATE_WAIT_COMMAND;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int process_state_close_lc(struct nfcmrvl_private *priv,\r\nstruct sk_buff *skb)\r\n{\r\nif (sizeof(nci_pattern_core_conn_close_rsp) != skb->len ||\r\nmemcmp(skb->data, nci_pattern_core_conn_close_rsp, skb->len))\r\nreturn -EINVAL;\r\npriv->fw_dnld.state = STATE_BOOT;\r\nnci_send_cmd(priv->ndev, NCI_OP_PROPRIETARY_BOOT_CMD, 0, NULL);\r\nreturn 0;\r\n}\r\nstatic int process_state_boot(struct nfcmrvl_private *priv, struct sk_buff *skb)\r\n{\r\nif (sizeof(nci_pattern_proprietary_boot_rsp) != skb->len ||\r\nmemcmp(skb->data, nci_pattern_proprietary_boot_rsp, skb->len))\r\nreturn -EINVAL;\r\npriv->if_ops->nci_update_config(priv,\r\n&priv->fw_dnld.binary_config->config);\r\nif (priv->fw_dnld.binary_config == &priv->fw_dnld.header->helper) {\r\npriv->fw_dnld.state = STATE_RESET;\r\npriv->fw_dnld.binary_config = &priv->fw_dnld.header->firmware;\r\nnfc_info(priv->dev, "FW loading: helper loaded");\r\n} else {\r\nnfc_info(priv->dev, "FW loading: firmware loaded");\r\nfw_dnld_over(priv, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic void fw_dnld_rx_work(struct work_struct *work)\r\n{\r\nint ret;\r\nstruct sk_buff *skb;\r\nstruct nfcmrvl_fw_dnld *fw_dnld = container_of(work,\r\nstruct nfcmrvl_fw_dnld,\r\nrx_work);\r\nstruct nfcmrvl_private *priv = container_of(fw_dnld,\r\nstruct nfcmrvl_private,\r\nfw_dnld);\r\nwhile ((skb = skb_dequeue(&fw_dnld->rx_q))) {\r\nnfc_send_to_raw_sock(priv->ndev->nfc_dev, skb,\r\nRAW_PAYLOAD_NCI, NFC_DIRECTION_RX);\r\nswitch (fw_dnld->state) {\r\ncase STATE_RESET:\r\nret = process_state_reset(priv, skb);\r\nbreak;\r\ncase STATE_INIT:\r\nret = process_state_init(priv, skb);\r\nbreak;\r\ncase STATE_SET_REF_CLOCK:\r\nret = process_state_set_ref_clock(priv, skb);\r\nbreak;\r\ncase STATE_SET_HI_CONFIG:\r\nret = process_state_set_hi_config(priv, skb);\r\nbreak;\r\ncase STATE_OPEN_LC:\r\nret = process_state_open_lc(priv, skb);\r\nbreak;\r\ncase STATE_FW_DNLD:\r\nret = process_state_fw_dnld(priv, skb);\r\nbreak;\r\ncase STATE_CLOSE_LC:\r\nret = process_state_close_lc(priv, skb);\r\nbreak;\r\ncase STATE_BOOT:\r\nret = process_state_boot(priv, skb);\r\nbreak;\r\ndefault:\r\nret = -EFAULT;\r\n}\r\nkfree_skb(skb);\r\nif (ret != 0) {\r\nnfc_err(priv->dev, "FW loading error");\r\nfw_dnld_over(priv, ret);\r\nbreak;\r\n}\r\n}\r\n}\r\nint nfcmrvl_fw_dnld_init(struct nfcmrvl_private *priv)\r\n{\r\nchar name[32];\r\nINIT_WORK(&priv->fw_dnld.rx_work, fw_dnld_rx_work);\r\nsnprintf(name, sizeof(name), "%s_nfcmrvl_fw_dnld_rx_wq",\r\ndev_name(&priv->ndev->nfc_dev->dev));\r\npriv->fw_dnld.rx_wq = create_singlethread_workqueue(name);\r\nif (!priv->fw_dnld.rx_wq)\r\nreturn -ENOMEM;\r\nskb_queue_head_init(&priv->fw_dnld.rx_q);\r\nreturn 0;\r\n}\r\nvoid nfcmrvl_fw_dnld_deinit(struct nfcmrvl_private *priv)\r\n{\r\ndestroy_workqueue(priv->fw_dnld.rx_wq);\r\n}\r\nvoid nfcmrvl_fw_dnld_recv_frame(struct nfcmrvl_private *priv,\r\nstruct sk_buff *skb)\r\n{\r\nif (timer_pending(&priv->ndev->cmd_timer))\r\ndel_timer_sync(&priv->ndev->cmd_timer);\r\natomic_set(&priv->ndev->cmd_cnt, 1);\r\nskb_queue_tail(&priv->fw_dnld.rx_q, skb);\r\nqueue_work(priv->fw_dnld.rx_wq, &priv->fw_dnld.rx_work);\r\n}\r\nvoid nfcmrvl_fw_dnld_abort(struct nfcmrvl_private *priv)\r\n{\r\nfw_dnld_over(priv, -EHOSTDOWN);\r\n}\r\nint nfcmrvl_fw_dnld_start(struct nci_dev *ndev, const char *firmware_name)\r\n{\r\nstruct nfcmrvl_private *priv = nci_get_drvdata(ndev);\r\nstruct nfcmrvl_fw_dnld *fw_dnld = &priv->fw_dnld;\r\nint res;\r\nif (!priv->support_fw_dnld)\r\nreturn -ENOTSUPP;\r\nif (!firmware_name || !firmware_name[0])\r\nreturn -EINVAL;\r\nstrcpy(fw_dnld->name, firmware_name);\r\nres = request_firmware(&fw_dnld->fw, firmware_name,\r\n&ndev->nfc_dev->dev);\r\nif (res < 0) {\r\nnfc_err(priv->dev, "failed to retrieve FW %s", firmware_name);\r\nreturn -ENOENT;\r\n}\r\nfw_dnld->header = (const struct nfcmrvl_fw *) priv->fw_dnld.fw->data;\r\nif (fw_dnld->header->magic != NFCMRVL_FW_MAGIC ||\r\nfw_dnld->header->phy != priv->phy) {\r\nnfc_err(priv->dev, "bad firmware binary %s magic=0x%x phy=%d",\r\nfirmware_name, fw_dnld->header->magic,\r\nfw_dnld->header->phy);\r\nrelease_firmware(fw_dnld->fw);\r\nfw_dnld->header = NULL;\r\nreturn -EINVAL;\r\n}\r\nif (fw_dnld->header->helper.offset != 0) {\r\nnfc_info(priv->dev, "loading helper");\r\nfw_dnld->binary_config = &fw_dnld->header->helper;\r\n} else {\r\nnfc_info(priv->dev, "loading firmware");\r\nfw_dnld->binary_config = &fw_dnld->header->firmware;\r\n}\r\nsetup_timer(&priv->fw_dnld.timer, fw_dnld_timeout,\r\n(unsigned long) priv);\r\nmod_timer(&priv->fw_dnld.timer,\r\njiffies + msecs_to_jiffies(FW_DNLD_TIMEOUT));\r\npriv->if_ops->nci_update_config(priv,\r\n&fw_dnld->header->bootrom.config);\r\natomic_set(&priv->ndev->cmd_cnt, 1);\r\npriv->fw_dnld.state = STATE_RESET;\r\nnfcmrvl_chip_reset(priv);\r\nreturn 0;\r\n}
