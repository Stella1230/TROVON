static int max14656_read_reg(struct i2c_client *client, int reg, u8 *val)\r\n{\r\ns32 ret;\r\nret = i2c_smbus_read_byte_data(client, reg);\r\nif (ret < 0) {\r\ndev_err(&client->dev,\r\n"i2c read fail: can't read from %02x: %d\n",\r\nreg, ret);\r\nreturn ret;\r\n}\r\n*val = ret;\r\nreturn 0;\r\n}\r\nstatic int max14656_write_reg(struct i2c_client *client, int reg, u8 val)\r\n{\r\ns32 ret;\r\nret = i2c_smbus_write_byte_data(client, reg, val);\r\nif (ret < 0) {\r\ndev_err(&client->dev,\r\n"i2c write fail: can't write %02x to %02x: %d\n",\r\nval, reg, ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int max14656_read_block_reg(struct i2c_client *client, u8 reg,\r\nu8 length, u8 *val)\r\n{\r\nint ret;\r\nret = i2c_smbus_read_i2c_block_data(client, reg, length, val);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "failed to block read reg 0x%x: %d\n",\r\nreg, ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void max14656_irq_worker(struct work_struct *work)\r\n{\r\nstruct max14656_chip *chip =\r\ncontainer_of(work, struct max14656_chip, irq_work.work);\r\nu8 buf[REG_TOTAL_NUM];\r\nu8 chg_type;\r\nint ret = 0;\r\nret = max14656_read_block_reg(chip->client, MAX14656_DEVICE_ID,\r\nREG_TOTAL_NUM, buf);\r\nif ((buf[MAX14656_STATUS_1] & STATUS1_VB_VALID_MASK) &&\r\n(buf[MAX14656_STATUS_1] & STATUS1_CHG_TYPE_MASK)) {\r\nchg_type = buf[MAX14656_STATUS_1] & STATUS1_CHG_TYPE_MASK;\r\nif (chg_type < MAX14656_CHARGER_LAST)\r\nchip->psy_desc.type = chg_type_props[chg_type].type;\r\nelse\r\nchip->psy_desc.type = POWER_SUPPLY_TYPE_UNKNOWN;\r\nchip->online = 1;\r\n} else {\r\nchip->online = 0;\r\nchip->psy_desc.type = POWER_SUPPLY_TYPE_UNKNOWN;\r\n}\r\npower_supply_changed(chip->detect_psy);\r\n}\r\nstatic irqreturn_t max14656_irq(int irq, void *dev_id)\r\n{\r\nstruct max14656_chip *chip = dev_id;\r\nschedule_delayed_work(&chip->irq_work, msecs_to_jiffies(100));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int max14656_hw_init(struct max14656_chip *chip)\r\n{\r\nuint8_t val = 0;\r\nuint8_t rev;\r\nstruct i2c_client *client = chip->client;\r\nif (max14656_read_reg(client, MAX14656_DEVICE_ID, &val))\r\nreturn -ENODEV;\r\nif ((val & DEVICE_VENDOR_MASK) != 0x20) {\r\ndev_err(&client->dev, "wrong vendor ID %d\n",\r\n((val & DEVICE_VENDOR_MASK) >> 4));\r\nreturn -ENODEV;\r\n}\r\nrev = val & DEVICE_REV_MASK;\r\nif (max14656_write_reg(client, MAX14656_CONTROL_2, CONTROL2_ADC_EN))\r\nreturn -EINVAL;\r\nif (max14656_write_reg(client, MAX14656_CONTROL_1,\r\nCONTROL1_DEFAULT |\r\nCONTROL1_INT_EN |\r\nCONTROL1_INT_ACTIVE_HIGH |\r\nCONTROL1_EDGE))\r\nreturn -EINVAL;\r\nif (max14656_write_reg(client, MAX14656_INTMASK_1, 0x3))\r\nreturn -EINVAL;\r\nif (max14656_write_reg(client, MAX14656_INTMASK_2, 0x1))\r\nreturn -EINVAL;\r\ndev_info(&client->dev, "detected revision %d\n", rev);\r\nreturn 0;\r\n}\r\nstatic int max14656_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct max14656_chip *chip = power_supply_get_drvdata(psy);\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_ONLINE:\r\nval->intval = chip->online;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_MODEL_NAME:\r\nval->strval = MAX14656_NAME;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_MANUFACTURER:\r\nval->strval = MAX14656_MANUFACTURER;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int max14656_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);\r\nstruct device *dev = &client->dev;\r\nstruct power_supply_config psy_cfg = {};\r\nstruct max14656_chip *chip;\r\nint irq = client->irq;\r\nint ret = 0;\r\nif (irq <= 0) {\r\ndev_err(dev, "invalid irq number: %d\n", irq);\r\nreturn -ENODEV;\r\n}\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {\r\ndev_err(dev, "No support for SMBUS_BYTE_DATA\n");\r\nreturn -ENODEV;\r\n}\r\nchip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\npsy_cfg.drv_data = chip;\r\nchip->client = client;\r\nchip->online = 0;\r\nchip->psy_desc.name = MAX14656_NAME;\r\nchip->psy_desc.type = POWER_SUPPLY_TYPE_UNKNOWN;\r\nchip->psy_desc.properties = max14656_battery_props;\r\nchip->psy_desc.num_properties = ARRAY_SIZE(max14656_battery_props);\r\nchip->psy_desc.get_property = max14656_get_property;\r\nchip->irq = irq;\r\nret = max14656_hw_init(chip);\r\nif (ret)\r\nreturn -ENODEV;\r\nINIT_DELAYED_WORK(&chip->irq_work, max14656_irq_worker);\r\nret = devm_request_irq(dev, chip->irq, max14656_irq,\r\nIRQF_TRIGGER_FALLING,\r\nMAX14656_NAME, chip);\r\nif (ret) {\r\ndev_err(dev, "request_irq %d failed\n", chip->irq);\r\nreturn -EINVAL;\r\n}\r\nenable_irq_wake(chip->irq);\r\nchip->detect_psy = devm_power_supply_register(dev,\r\n&chip->psy_desc, &psy_cfg);\r\nif (IS_ERR(chip->detect_psy)) {\r\ndev_err(dev, "power_supply_register failed\n");\r\nreturn -EINVAL;\r\n}\r\nschedule_delayed_work(&chip->irq_work, msecs_to_jiffies(2000));\r\nreturn 0;\r\n}
