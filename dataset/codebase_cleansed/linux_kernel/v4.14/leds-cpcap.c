static u16 cpcap_led_val(u8 current_limit, u8 duty_cycle)\r\n{\r\ncurrent_limit &= 0x1f;\r\nduty_cycle &= 0x0f;\r\nreturn current_limit << 4 | duty_cycle;\r\n}\r\nstatic int cpcap_led_set_power(struct cpcap_led *led, bool status)\r\n{\r\nint err;\r\nif (status == led->powered)\r\nreturn 0;\r\nif (status)\r\nerr = regulator_enable(led->vdd);\r\nelse\r\nerr = regulator_disable(led->vdd);\r\nif (err) {\r\ndev_err(led->dev, "regulator failure: %d", err);\r\nreturn err;\r\n}\r\nled->powered = status;\r\nreturn 0;\r\n}\r\nstatic int cpcap_led_set(struct led_classdev *ledc, enum led_brightness value)\r\n{\r\nstruct cpcap_led *led = container_of(ledc, struct cpcap_led, led);\r\nint brightness;\r\nint err;\r\nmutex_lock(&led->update_lock);\r\nif (value > LED_OFF) {\r\nerr = cpcap_led_set_power(led, true);\r\nif (err)\r\ngoto exit;\r\n}\r\nif (value == LED_OFF) {\r\nerr = regmap_update_bits(led->regmap,\r\nled->info->reg, led->info->mask, CPCAP_LED_NO_CURRENT);\r\nif (err) {\r\ndev_err(led->dev, "regmap failed: %d", err);\r\ngoto exit;\r\n}\r\nbrightness = cpcap_led_val(value, LED_OFF);\r\n} else {\r\nbrightness = cpcap_led_val(value, LED_ON);\r\n}\r\nerr = regmap_update_bits(led->regmap, led->info->reg, led->info->mask,\r\nbrightness);\r\nif (err) {\r\ndev_err(led->dev, "regmap failed: %d", err);\r\ngoto exit;\r\n}\r\nif (value == LED_OFF) {\r\nerr = cpcap_led_set_power(led, false);\r\nif (err)\r\ngoto exit;\r\n}\r\nexit:\r\nmutex_unlock(&led->update_lock);\r\nreturn err;\r\n}\r\nstatic int cpcap_led_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *match;\r\nstruct cpcap_led *led;\r\nint err;\r\nmatch = of_match_device(of_match_ptr(cpcap_led_of_match), &pdev->dev);\r\nif (!match || !match->data)\r\nreturn -EINVAL;\r\nled = devm_kzalloc(&pdev->dev, sizeof(*led), GFP_KERNEL);\r\nif (!led)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, led);\r\nled->info = match->data;\r\nled->dev = &pdev->dev;\r\nif (led->info->reg == 0x0000) {\r\ndev_err(led->dev, "Unsupported LED");\r\nreturn -ENODEV;\r\n}\r\nled->regmap = dev_get_regmap(pdev->dev.parent, NULL);\r\nif (!led->regmap)\r\nreturn -ENODEV;\r\nled->vdd = devm_regulator_get(&pdev->dev, "vdd");\r\nif (IS_ERR(led->vdd)) {\r\nerr = PTR_ERR(led->vdd);\r\ndev_err(led->dev, "Couldn't get regulator: %d", err);\r\nreturn err;\r\n}\r\nerr = device_property_read_string(&pdev->dev, "label", &led->led.name);\r\nif (err) {\r\ndev_err(led->dev, "Couldn't read LED label: %d", err);\r\nreturn err;\r\n}\r\nif (led->info->init_mask) {\r\nerr = regmap_update_bits(led->regmap, led->info->reg,\r\nled->info->init_mask, led->info->init_val);\r\nif (err) {\r\ndev_err(led->dev, "regmap failed: %d", err);\r\nreturn err;\r\n}\r\n}\r\nmutex_init(&led->update_lock);\r\nled->led.max_brightness = led->info->limit;\r\nled->led.brightness_set_blocking = cpcap_led_set;\r\nerr = devm_led_classdev_register(&pdev->dev, &led->led);\r\nif (err) {\r\ndev_err(led->dev, "Couldn't register LED: %d", err);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}
