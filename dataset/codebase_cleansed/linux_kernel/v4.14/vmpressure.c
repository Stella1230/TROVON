static struct vmpressure *work_to_vmpressure(struct work_struct *work)\r\n{\r\nreturn container_of(work, struct vmpressure, work);\r\n}\r\nstatic struct vmpressure *vmpressure_parent(struct vmpressure *vmpr)\r\n{\r\nstruct cgroup_subsys_state *css = vmpressure_to_css(vmpr);\r\nstruct mem_cgroup *memcg = mem_cgroup_from_css(css);\r\nmemcg = parent_mem_cgroup(memcg);\r\nif (!memcg)\r\nreturn NULL;\r\nreturn memcg_to_vmpressure(memcg);\r\n}\r\nstatic enum vmpressure_levels vmpressure_level(unsigned long pressure)\r\n{\r\nif (pressure >= vmpressure_level_critical)\r\nreturn VMPRESSURE_CRITICAL;\r\nelse if (pressure >= vmpressure_level_med)\r\nreturn VMPRESSURE_MEDIUM;\r\nreturn VMPRESSURE_LOW;\r\n}\r\nstatic enum vmpressure_levels vmpressure_calc_level(unsigned long scanned,\r\nunsigned long reclaimed)\r\n{\r\nunsigned long scale = scanned + reclaimed;\r\nunsigned long pressure = 0;\r\nif (reclaimed >= scanned)\r\ngoto out;\r\npressure = scale - (reclaimed * scale / scanned);\r\npressure = pressure * 100 / scale;\r\nout:\r\npr_debug("%s: %3lu (s: %lu r: %lu)\n", __func__, pressure,\r\nscanned, reclaimed);\r\nreturn vmpressure_level(pressure);\r\n}\r\nstatic bool vmpressure_event(struct vmpressure *vmpr,\r\nconst enum vmpressure_levels level,\r\nbool ancestor, bool signalled)\r\n{\r\nstruct vmpressure_event *ev;\r\nbool ret = false;\r\nmutex_lock(&vmpr->events_lock);\r\nlist_for_each_entry(ev, &vmpr->events, node) {\r\nif (ancestor && ev->mode == VMPRESSURE_LOCAL)\r\ncontinue;\r\nif (signalled && ev->mode == VMPRESSURE_NO_PASSTHROUGH)\r\ncontinue;\r\nif (level < ev->level)\r\ncontinue;\r\neventfd_signal(ev->efd, 1);\r\nret = true;\r\n}\r\nmutex_unlock(&vmpr->events_lock);\r\nreturn ret;\r\n}\r\nstatic void vmpressure_work_fn(struct work_struct *work)\r\n{\r\nstruct vmpressure *vmpr = work_to_vmpressure(work);\r\nunsigned long scanned;\r\nunsigned long reclaimed;\r\nenum vmpressure_levels level;\r\nbool ancestor = false;\r\nbool signalled = false;\r\nspin_lock(&vmpr->sr_lock);\r\nscanned = vmpr->tree_scanned;\r\nif (!scanned) {\r\nspin_unlock(&vmpr->sr_lock);\r\nreturn;\r\n}\r\nreclaimed = vmpr->tree_reclaimed;\r\nvmpr->tree_scanned = 0;\r\nvmpr->tree_reclaimed = 0;\r\nspin_unlock(&vmpr->sr_lock);\r\nlevel = vmpressure_calc_level(scanned, reclaimed);\r\ndo {\r\nif (vmpressure_event(vmpr, level, ancestor, signalled))\r\nsignalled = true;\r\nancestor = true;\r\n} while ((vmpr = vmpressure_parent(vmpr)));\r\n}\r\nvoid vmpressure(gfp_t gfp, struct mem_cgroup *memcg, bool tree,\r\nunsigned long scanned, unsigned long reclaimed)\r\n{\r\nstruct vmpressure *vmpr = memcg_to_vmpressure(memcg);\r\nif (!(gfp & (__GFP_HIGHMEM | __GFP_MOVABLE | __GFP_IO | __GFP_FS)))\r\nreturn;\r\nif (!scanned)\r\nreturn;\r\nif (tree) {\r\nspin_lock(&vmpr->sr_lock);\r\nscanned = vmpr->tree_scanned += scanned;\r\nvmpr->tree_reclaimed += reclaimed;\r\nspin_unlock(&vmpr->sr_lock);\r\nif (scanned < vmpressure_win)\r\nreturn;\r\nschedule_work(&vmpr->work);\r\n} else {\r\nenum vmpressure_levels level;\r\nif (!memcg || memcg == root_mem_cgroup)\r\nreturn;\r\nspin_lock(&vmpr->sr_lock);\r\nscanned = vmpr->scanned += scanned;\r\nreclaimed = vmpr->reclaimed += reclaimed;\r\nif (scanned < vmpressure_win) {\r\nspin_unlock(&vmpr->sr_lock);\r\nreturn;\r\n}\r\nvmpr->scanned = vmpr->reclaimed = 0;\r\nspin_unlock(&vmpr->sr_lock);\r\nlevel = vmpressure_calc_level(scanned, reclaimed);\r\nif (level > VMPRESSURE_LOW) {\r\nmemcg->socket_pressure = jiffies + HZ;\r\n}\r\n}\r\n}\r\nvoid vmpressure_prio(gfp_t gfp, struct mem_cgroup *memcg, int prio)\r\n{\r\nif (prio > vmpressure_level_critical_prio)\r\nreturn;\r\nvmpressure(gfp, memcg, true, vmpressure_win, 0);\r\n}\r\nstatic enum vmpressure_levels str_to_level(const char *arg)\r\n{\r\nenum vmpressure_levels level;\r\nfor (level = 0; level < VMPRESSURE_NUM_LEVELS; level++)\r\nif (!strcmp(vmpressure_str_levels[level], arg))\r\nreturn level;\r\nreturn -1;\r\n}\r\nstatic enum vmpressure_modes str_to_mode(const char *arg)\r\n{\r\nenum vmpressure_modes mode;\r\nfor (mode = 0; mode < VMPRESSURE_NUM_MODES; mode++)\r\nif (!strcmp(vmpressure_str_modes[mode], arg))\r\nreturn mode;\r\nreturn -1;\r\n}\r\nint vmpressure_register_event(struct mem_cgroup *memcg,\r\nstruct eventfd_ctx *eventfd, const char *args)\r\n{\r\nstruct vmpressure *vmpr = memcg_to_vmpressure(memcg);\r\nstruct vmpressure_event *ev;\r\nenum vmpressure_modes mode = VMPRESSURE_NO_PASSTHROUGH;\r\nenum vmpressure_levels level = -1;\r\nchar *spec, *spec_orig;\r\nchar *token;\r\nint ret = 0;\r\nspec_orig = spec = kzalloc(MAX_VMPRESSURE_ARGS_LEN + 1, GFP_KERNEL);\r\nif (!spec) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nstrncpy(spec, args, MAX_VMPRESSURE_ARGS_LEN);\r\ntoken = strsep(&spec, ",");\r\nlevel = str_to_level(token);\r\nif (level == -1) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\ntoken = strsep(&spec, ",");\r\nif (token) {\r\nmode = str_to_mode(token);\r\nif (mode == -1) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\nev = kzalloc(sizeof(*ev), GFP_KERNEL);\r\nif (!ev) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nev->efd = eventfd;\r\nev->level = level;\r\nev->mode = mode;\r\nmutex_lock(&vmpr->events_lock);\r\nlist_add(&ev->node, &vmpr->events);\r\nmutex_unlock(&vmpr->events_lock);\r\nout:\r\nkfree(spec_orig);\r\nreturn ret;\r\n}\r\nvoid vmpressure_unregister_event(struct mem_cgroup *memcg,\r\nstruct eventfd_ctx *eventfd)\r\n{\r\nstruct vmpressure *vmpr = memcg_to_vmpressure(memcg);\r\nstruct vmpressure_event *ev;\r\nmutex_lock(&vmpr->events_lock);\r\nlist_for_each_entry(ev, &vmpr->events, node) {\r\nif (ev->efd != eventfd)\r\ncontinue;\r\nlist_del(&ev->node);\r\nkfree(ev);\r\nbreak;\r\n}\r\nmutex_unlock(&vmpr->events_lock);\r\n}\r\nvoid vmpressure_init(struct vmpressure *vmpr)\r\n{\r\nspin_lock_init(&vmpr->sr_lock);\r\nmutex_init(&vmpr->events_lock);\r\nINIT_LIST_HEAD(&vmpr->events);\r\nINIT_WORK(&vmpr->work, vmpressure_work_fn);\r\n}\r\nvoid vmpressure_cleanup(struct vmpressure *vmpr)\r\n{\r\nflush_work(&vmpr->work);\r\n}
