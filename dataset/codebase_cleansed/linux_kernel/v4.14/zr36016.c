static u8\r\nzr36016_read (struct zr36016 *ptr,\r\nu16 reg)\r\n{\r\nu8 value = 0;\r\nif (ptr->codec->master_data->readreg)\r\nvalue =\r\n(ptr->codec->master_data->\r\nreadreg(ptr->codec, reg)) & 0xFF;\r\nelse\r\ndprintk(1,\r\nKERN_ERR "%s: invalid I/O setup, nothing read!\n",\r\nptr->name);\r\ndprintk(4, "%s: reading from 0x%04x: %02x\n", ptr->name, reg,\r\nvalue);\r\nreturn value;\r\n}\r\nstatic void\r\nzr36016_write (struct zr36016 *ptr,\r\nu16 reg,\r\nu8 value)\r\n{\r\ndprintk(4, "%s: writing 0x%02x to 0x%04x\n", ptr->name, value,\r\nreg);\r\nif (ptr->codec->master_data->writereg) {\r\nptr->codec->master_data->writereg(ptr->codec, reg, value);\r\n} else\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: invalid I/O setup, nothing written!\n",\r\nptr->name);\r\n}\r\nstatic u8\r\nzr36016_readi (struct zr36016 *ptr,\r\nu16 reg)\r\n{\r\nu8 value = 0;\r\nif ((ptr->codec->master_data->writereg) &&\r\n(ptr->codec->master_data->readreg)) {\r\nptr->codec->master_data->writereg(ptr->codec, ZR016_IADDR, reg & 0x0F);\r\nvalue = (ptr->codec->master_data->readreg(ptr->codec, ZR016_IDATA)) & 0xFF;\r\n} else\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: invalid I/O setup, nothing read (i)!\n",\r\nptr->name);\r\ndprintk(4, "%s: reading indirect from 0x%04x: %02x\n", ptr->name,\r\nreg, value);\r\nreturn value;\r\n}\r\nstatic void\r\nzr36016_writei (struct zr36016 *ptr,\r\nu16 reg,\r\nu8 value)\r\n{\r\ndprintk(4, "%s: writing indirect 0x%02x to 0x%04x\n", ptr->name,\r\nvalue, reg);\r\nif (ptr->codec->master_data->writereg) {\r\nptr->codec->master_data->writereg(ptr->codec, ZR016_IADDR, reg & 0x0F);\r\nptr->codec->master_data->writereg(ptr->codec, ZR016_IDATA, value & 0x0FF);\r\n} else\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: invalid I/O setup, nothing written (i)!\n",\r\nptr->name);\r\n}\r\nstatic u8\r\nzr36016_read_version (struct zr36016 *ptr)\r\n{\r\nptr->version = zr36016_read(ptr, 0) >> 4;\r\nreturn ptr->version;\r\n}\r\nstatic int\r\nzr36016_basic_test (struct zr36016 *ptr)\r\n{\r\nif (debug) {\r\nint i;\r\nzr36016_writei(ptr, ZR016I_PAX_LO, 0x55);\r\ndprintk(1, KERN_INFO "%s: registers: ", ptr->name);\r\nfor (i = 0; i <= 0x0b; i++)\r\ndprintk(1, "%02x ", zr36016_readi(ptr, i));\r\ndprintk(1, "\n");\r\n}\r\nzr36016_writei(ptr, ZR016I_PAX_LO, 0x00);\r\nif (zr36016_readi(ptr, ZR016I_PAX_LO) != 0x0) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: attach failed, can't connect to vfe processor!\n",\r\nptr->name);\r\nreturn -ENXIO;\r\n}\r\nzr36016_writei(ptr, ZR016I_PAX_LO, 0x0d0);\r\nif (zr36016_readi(ptr, ZR016I_PAX_LO) != 0x0d0) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: attach failed, can't connect to vfe processor!\n",\r\nptr->name);\r\nreturn -ENXIO;\r\n}\r\nzr36016_read_version(ptr);\r\nif (ptr->version & 0x0c) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: attach failed, suspicious version %d found...\n",\r\nptr->name, ptr->version);\r\nreturn -ENXIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nzr36016_init (struct zr36016 *ptr)\r\n{\r\nzr36016_write(ptr, ZR016_GOSTOP, 0);\r\nzr36016_write(ptr, ZR016_MODE,\r\nZR016_YUV422 | ZR016_YUV422_YUV422 |\r\n(ptr->mode == CODEC_DO_COMPRESSION ?\r\nZR016_COMPRESSION : ZR016_EXPANSION));\r\nzr36016_writei(ptr, ZR016I_SETUP1,\r\n(ptr->xdec ? (ZR016_HRFL | ZR016_HORZ) : 0) |\r\n(ptr->ydec ? ZR016_VERT : 0) | ZR016_CNTI);\r\nzr36016_writei(ptr, ZR016I_SETUP2, ZR016_CCIR);\r\nzr36016_writei(ptr, ZR016I_PAX_HI, ptr->width >> 8);\r\nzr36016_writei(ptr, ZR016I_PAX_LO, ptr->width & 0xFF);\r\nzr36016_writei(ptr, ZR016I_PAY_HI, ptr->height >> 8);\r\nzr36016_writei(ptr, ZR016I_PAY_LO, ptr->height & 0xFF);\r\nzr36016_writei(ptr, ZR016I_NAX_HI, ptr->xoff >> 8);\r\nzr36016_writei(ptr, ZR016I_NAX_LO, ptr->xoff & 0xFF);\r\nzr36016_writei(ptr, ZR016I_NAY_HI, ptr->yoff >> 8);\r\nzr36016_writei(ptr, ZR016I_NAY_LO, ptr->yoff & 0xFF);\r\nzr36016_write(ptr, ZR016_GOSTOP, 1);\r\n}\r\nstatic int\r\nzr36016_set_mode (struct videocodec *codec,\r\nint mode)\r\n{\r\nstruct zr36016 *ptr = (struct zr36016 *) codec->data;\r\ndprintk(2, "%s: set_mode %d call\n", ptr->name, mode);\r\nif ((mode != CODEC_DO_EXPANSION) && (mode != CODEC_DO_COMPRESSION))\r\nreturn -EINVAL;\r\nptr->mode = mode;\r\nzr36016_init(ptr);\r\nreturn 0;\r\n}\r\nstatic int\r\nzr36016_set_video (struct videocodec *codec,\r\nstruct tvnorm *norm,\r\nstruct vfe_settings *cap,\r\nstruct vfe_polarity *pol)\r\n{\r\nstruct zr36016 *ptr = (struct zr36016 *) codec->data;\r\ndprintk(2, "%s: set_video %d.%d, %d/%d-%dx%d (0x%x) call\n",\r\nptr->name, norm->HStart, norm->VStart,\r\ncap->x, cap->y, cap->width, cap->height,\r\ncap->decimation);\r\nptr->width = cap->width;\r\nptr->height = cap->height;\r\nptr->xoff = (norm->HStart ? norm->HStart : 1) + cap->x;\r\nptr->yoff = norm->VStart + cap->y;\r\nptr->xdec = ((cap->decimation & 0xff) == 1) ? 0 : 1;\r\nptr->ydec = (((cap->decimation >> 8) & 0xff) == 1) ? 0 : 1;\r\nreturn 0;\r\n}\r\nstatic int\r\nzr36016_control (struct videocodec *codec,\r\nint type,\r\nint size,\r\nvoid *data)\r\n{\r\nstruct zr36016 *ptr = (struct zr36016 *) codec->data;\r\nint *ival = (int *) data;\r\ndprintk(2, "%s: control %d call with %d byte\n", ptr->name, type,\r\nsize);\r\nswitch (type) {\r\ncase CODEC_G_STATUS:\r\nif (size != sizeof(int))\r\nreturn -EFAULT;\r\n*ival = 0;\r\nbreak;\r\ncase CODEC_G_CODEC_MODE:\r\nif (size != sizeof(int))\r\nreturn -EFAULT;\r\n*ival = 0;\r\nbreak;\r\ncase CODEC_S_CODEC_MODE:\r\nif (size != sizeof(int))\r\nreturn -EFAULT;\r\nif (*ival != 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\ncase CODEC_G_VFE:\r\ncase CODEC_S_VFE:\r\nreturn 0;\r\ncase CODEC_S_MMAP:\r\nreturn -ENXIO;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn size;\r\n}\r\nstatic int\r\nzr36016_unset (struct videocodec *codec)\r\n{\r\nstruct zr36016 *ptr = codec->data;\r\nif (ptr) {\r\ndprintk(1, "%s: finished codec #%d\n", ptr->name,\r\nptr->num);\r\nkfree(ptr);\r\ncodec->data = NULL;\r\nzr36016_codecs--;\r\nreturn 0;\r\n}\r\nreturn -EFAULT;\r\n}\r\nstatic int\r\nzr36016_setup (struct videocodec *codec)\r\n{\r\nstruct zr36016 *ptr;\r\nint res;\r\ndprintk(2, "zr36016: initializing VFE subsystem #%d.\n",\r\nzr36016_codecs);\r\nif (zr36016_codecs == MAX_CODECS) {\r\ndprintk(1,\r\nKERN_ERR "zr36016: Can't attach more codecs!\n");\r\nreturn -ENOSPC;\r\n}\r\ncodec->data = ptr = kzalloc(sizeof(struct zr36016), GFP_KERNEL);\r\nif (NULL == ptr) {\r\ndprintk(1, KERN_ERR "zr36016: Can't get enough memory!\n");\r\nreturn -ENOMEM;\r\n}\r\nsnprintf(ptr->name, sizeof(ptr->name), "zr36016[%d]",\r\nzr36016_codecs);\r\nptr->num = zr36016_codecs++;\r\nptr->codec = codec;\r\nres = zr36016_basic_test(ptr);\r\nif (res < 0) {\r\nzr36016_unset(codec);\r\nreturn res;\r\n}\r\nptr->mode = CODEC_DO_COMPRESSION;\r\nptr->width = 768;\r\nptr->height = 288;\r\nptr->xdec = 1;\r\nptr->ydec = 0;\r\nzr36016_init(ptr);\r\ndprintk(1, KERN_INFO "%s: codec v%d attached and running\n",\r\nptr->name, ptr->version);\r\nreturn 0;\r\n}\r\nstatic int __init\r\nzr36016_init_module (void)\r\n{\r\nzr36016_codecs = 0;\r\nreturn videocodec_register(&zr36016_codec);\r\n}\r\nstatic void __exit\r\nzr36016_cleanup_module (void)\r\n{\r\nif (zr36016_codecs) {\r\ndprintk(1,\r\n"zr36016: something's wrong - %d codecs left somehow.\n",\r\nzr36016_codecs);\r\n}\r\nvideocodec_unregister(&zr36016_codec);\r\n}
