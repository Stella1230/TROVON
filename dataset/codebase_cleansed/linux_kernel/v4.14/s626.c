static void s626_mc_enable(struct comedi_device *dev,\r\nunsigned int cmd, unsigned int reg)\r\n{\r\nunsigned int val = (cmd << 16) | cmd;\r\nmmiowb();\r\nwritel(val, dev->mmio + reg);\r\n}\r\nstatic void s626_mc_disable(struct comedi_device *dev,\r\nunsigned int cmd, unsigned int reg)\r\n{\r\nwritel(cmd << 16, dev->mmio + reg);\r\nmmiowb();\r\n}\r\nstatic bool s626_mc_test(struct comedi_device *dev,\r\nunsigned int cmd, unsigned int reg)\r\n{\r\nunsigned int val;\r\nval = readl(dev->mmio + reg);\r\nreturn (val & cmd) ? true : false;\r\n}\r\nstatic void s626_debi_transfer(struct comedi_device *dev)\r\n{\r\nstatic const int timeout = 10000;\r\nint i;\r\ns626_mc_enable(dev, S626_MC2_UPLD_DEBI, S626_P_MC2);\r\nfor (i = 0; i < timeout; i++) {\r\nif (s626_mc_test(dev, S626_MC2_UPLD_DEBI, S626_P_MC2))\r\nbreak;\r\nudelay(1);\r\n}\r\nif (i == timeout)\r\ndev_err(dev->class_dev,\r\n"Timeout while uploading to DEBI control register\n");\r\nfor (i = 0; i < timeout; i++) {\r\nif (!(readl(dev->mmio + S626_P_PSR) & S626_PSR_DEBI_S))\r\nbreak;\r\nudelay(1);\r\n}\r\nif (i == timeout)\r\ndev_err(dev->class_dev, "DEBI transfer timeout\n");\r\n}\r\nstatic u16 s626_debi_read(struct comedi_device *dev, u16 addr)\r\n{\r\nwritel(S626_DEBI_CMD_RDWORD | addr, dev->mmio + S626_P_DEBICMD);\r\ns626_debi_transfer(dev);\r\nreturn readl(dev->mmio + S626_P_DEBIAD);\r\n}\r\nstatic void s626_debi_write(struct comedi_device *dev, u16 addr,\r\nu16 wdata)\r\n{\r\nwritel(S626_DEBI_CMD_WRWORD | addr, dev->mmio + S626_P_DEBICMD);\r\nwritel(wdata, dev->mmio + S626_P_DEBIAD);\r\ns626_debi_transfer(dev);\r\n}\r\nstatic void s626_debi_replace(struct comedi_device *dev, unsigned int addr,\r\nunsigned int mask, unsigned int wdata)\r\n{\r\nunsigned int val;\r\naddr &= 0xffff;\r\nwritel(S626_DEBI_CMD_RDWORD | addr, dev->mmio + S626_P_DEBICMD);\r\ns626_debi_transfer(dev);\r\nwritel(S626_DEBI_CMD_WRWORD | addr, dev->mmio + S626_P_DEBICMD);\r\nval = readl(dev->mmio + S626_P_DEBIAD);\r\nval &= mask;\r\nval |= wdata;\r\nwritel(val & 0xffff, dev->mmio + S626_P_DEBIAD);\r\ns626_debi_transfer(dev);\r\n}\r\nstatic int s626_i2c_handshake_eoc(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned long context)\r\n{\r\nbool status;\r\nstatus = s626_mc_test(dev, S626_MC2_UPLD_IIC, S626_P_MC2);\r\nif (status)\r\nreturn 0;\r\nreturn -EBUSY;\r\n}\r\nstatic int s626_i2c_handshake(struct comedi_device *dev, u32 val)\r\n{\r\nunsigned int ctrl;\r\nint ret;\r\nwritel(val, dev->mmio + S626_P_I2CCTRL);\r\ns626_mc_enable(dev, S626_MC2_UPLD_IIC, S626_P_MC2);\r\nret = comedi_timeout(dev, NULL, NULL, s626_i2c_handshake_eoc, 0);\r\nif (ret)\r\nreturn ret;\r\ndo {\r\nctrl = readl(dev->mmio + S626_P_I2CCTRL);\r\n} while ((ctrl & (S626_I2C_BUSY | S626_I2C_ERR)) == S626_I2C_BUSY);\r\nreturn ctrl & S626_I2C_ERR;\r\n}\r\nstatic u8 s626_i2c_read(struct comedi_device *dev, u8 addr)\r\n{\r\nstruct s626_private *devpriv = dev->private;\r\nif (s626_i2c_handshake(dev, S626_I2C_B2(S626_I2C_ATTRSTART,\r\ndevpriv->i2c_adrs) |\r\nS626_I2C_B1(S626_I2C_ATTRSTOP, addr) |\r\nS626_I2C_B0(S626_I2C_ATTRNOP, 0)))\r\nreturn 0;\r\nif (s626_i2c_handshake(dev, S626_I2C_B2(S626_I2C_ATTRSTART,\r\n(devpriv->i2c_adrs | 1)) |\r\nS626_I2C_B1(S626_I2C_ATTRSTOP, 0) |\r\nS626_I2C_B0(S626_I2C_ATTRNOP, 0)))\r\nreturn 0;\r\nreturn (readl(dev->mmio + S626_P_I2CCTRL) >> 16) & 0xff;\r\n}\r\nstatic int s626_send_dac_eoc(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned long context)\r\n{\r\nunsigned int status;\r\nswitch (context) {\r\ncase s626_send_dac_wait_not_mc1_a2out:\r\nstatus = readl(dev->mmio + S626_P_MC1);\r\nif (!(status & S626_MC1_A2OUT))\r\nreturn 0;\r\nbreak;\r\ncase s626_send_dac_wait_ssr_af2_out:\r\nstatus = readl(dev->mmio + S626_P_SSR);\r\nif (status & S626_SSR_AF2_OUT)\r\nreturn 0;\r\nbreak;\r\ncase s626_send_dac_wait_fb_buffer2_msb_00:\r\nstatus = readl(dev->mmio + S626_P_FB_BUFFER2);\r\nif (!(status & 0xff000000))\r\nreturn 0;\r\nbreak;\r\ncase s626_send_dac_wait_fb_buffer2_msb_ff:\r\nstatus = readl(dev->mmio + S626_P_FB_BUFFER2);\r\nif (status & 0xff000000)\r\nreturn 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn -EBUSY;\r\n}\r\nstatic int s626_send_dac(struct comedi_device *dev, u32 val)\r\n{\r\nstruct s626_private *devpriv = dev->private;\r\nint ret;\r\ns626_debi_write(dev, S626_LP_DACPOL, devpriv->dacpol);\r\n*devpriv->dac_wbuf = val;\r\ns626_mc_enable(dev, S626_MC1_A2OUT, S626_P_MC1);\r\nwritel(S626_ISR_AFOU, dev->mmio + S626_P_ISR);\r\nret = comedi_timeout(dev, NULL, NULL, s626_send_dac_eoc,\r\ns626_send_dac_wait_not_mc1_a2out);\r\nif (ret) {\r\ndev_err(dev->class_dev, "DMA transfer timeout\n");\r\nreturn ret;\r\n}\r\nwritel(S626_XSD2 | S626_RSD3 | S626_SIB_A2,\r\ndev->mmio + S626_VECTPORT(0));\r\nret = comedi_timeout(dev, NULL, NULL, s626_send_dac_eoc,\r\ns626_send_dac_wait_ssr_af2_out);\r\nif (ret) {\r\ndev_err(dev->class_dev,\r\n"TSL timeout waiting for slot 1 to execute\n");\r\nreturn ret;\r\n}\r\nwritel(S626_XSD2 | S626_XFIFO_2 | S626_RSD2 | S626_SIB_A2 | S626_EOS,\r\ndev->mmio + S626_VECTPORT(0));\r\nif (readl(dev->mmio + S626_P_FB_BUFFER2) & 0xff000000) {\r\nret = comedi_timeout(dev, NULL, NULL, s626_send_dac_eoc,\r\ns626_send_dac_wait_fb_buffer2_msb_00);\r\nif (ret) {\r\ndev_err(dev->class_dev,\r\n"TSL timeout waiting for slot 0 to execute\n");\r\nreturn ret;\r\n}\r\n}\r\nwritel(S626_RSD3 | S626_SIB_A2 | S626_EOS,\r\ndev->mmio + S626_VECTPORT(0));\r\nret = comedi_timeout(dev, NULL, NULL, s626_send_dac_eoc,\r\ns626_send_dac_wait_fb_buffer2_msb_ff);\r\nif (ret) {\r\ndev_err(dev->class_dev,\r\n"TSL timeout waiting for slot 0 to execute\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int s626_set_dac(struct comedi_device *dev,\r\nu16 chan, int16_t dacdata)\r\n{\r\nstruct s626_private *devpriv = dev->private;\r\nu16 signmask;\r\nu32 ws_image;\r\nu32 val;\r\nsignmask = 1 << chan;\r\nif (dacdata < 0) {\r\ndacdata = -dacdata;\r\ndevpriv->dacpol |= signmask;\r\n} else {\r\ndevpriv->dacpol &= ~signmask;\r\n}\r\nif ((u16)dacdata > 0x1FFF)\r\ndacdata = 0x1FFF;\r\nws_image = (chan & 2) ? S626_WS1 : S626_WS2;\r\nwritel(S626_XSD2 | S626_XFIFO_1 | ws_image,\r\ndev->mmio + S626_VECTPORT(2));\r\nwritel(S626_XSD2 | S626_XFIFO_0 | ws_image,\r\ndev->mmio + S626_VECTPORT(3));\r\nwritel(S626_XSD2 | S626_XFIFO_3 | S626_WS3,\r\ndev->mmio + S626_VECTPORT(4));\r\nwritel(S626_XSD2 | S626_XFIFO_2 | S626_WS3 | S626_EOS,\r\ndev->mmio + S626_VECTPORT(5));\r\nval = 0x0F000000;\r\nval |= 0x00004000;\r\nval |= ((u32)(chan & 1) << 15);\r\nval |= (u32)dacdata;\r\nreturn s626_send_dac(dev, val);\r\n}\r\nstatic int s626_write_trim_dac(struct comedi_device *dev,\r\nu8 logical_chan, u8 dac_data)\r\n{\r\nstruct s626_private *devpriv = dev->private;\r\nu32 chan;\r\ndevpriv->trim_setpoint[logical_chan] = dac_data;\r\nchan = s626_trimchan[logical_chan];\r\nwritel(S626_XSD2 | S626_XFIFO_1 | S626_WS3,\r\ndev->mmio + S626_VECTPORT(2));\r\nwritel(S626_XSD2 | S626_XFIFO_0 | S626_WS3,\r\ndev->mmio + S626_VECTPORT(3));\r\nwritel(S626_XSD2 | S626_XFIFO_3 | S626_WS1,\r\ndev->mmio + S626_VECTPORT(4));\r\nwritel(S626_XSD2 | S626_XFIFO_2 | S626_WS1 | S626_EOS,\r\ndev->mmio + S626_VECTPORT(5));\r\nreturn s626_send_dac(dev, (chan << 8) | dac_data);\r\n}\r\nstatic int s626_load_trim_dacs(struct comedi_device *dev)\r\n{\r\nu8 i;\r\nint ret;\r\nfor (i = 0; i < ARRAY_SIZE(s626_trimchan); i++) {\r\nret = s626_write_trim_dac(dev, i,\r\ns626_i2c_read(dev, s626_trimadrs[i]));\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void s626_set_latch_source(struct comedi_device *dev,\r\nunsigned int chan, u16 value)\r\n{\r\ns626_debi_replace(dev, S626_LP_CRB(chan),\r\n~(S626_CRBMSK_INTCTRL | S626_CRBMSK_LATCHSRC),\r\nS626_SET_CRB_LATCHSRC(value));\r\n}\r\nstatic void s626_preload(struct comedi_device *dev,\r\nunsigned int chan, u32 value)\r\n{\r\ns626_debi_write(dev, S626_LP_CNTR(chan), value);\r\ns626_debi_write(dev, S626_LP_CNTR(chan) + 2, value >> 16);\r\n}\r\nstatic void s626_reset_cap_flags(struct comedi_device *dev,\r\nunsigned int chan)\r\n{\r\nu16 set;\r\nset = S626_SET_CRB_INTRESETCMD(1);\r\nif (chan < 3)\r\nset |= S626_SET_CRB_INTRESET_A(1);\r\nelse\r\nset |= S626_SET_CRB_INTRESET_B(1);\r\ns626_debi_replace(dev, S626_LP_CRB(chan), ~S626_CRBMSK_INTCTRL, set);\r\n}\r\nstatic void s626_set_mode_a(struct comedi_device *dev,\r\nunsigned int chan, u16 setup,\r\nu16 disable_int_src)\r\n{\r\nstruct s626_private *devpriv = dev->private;\r\nu16 cra;\r\nu16 crb;\r\nunsigned int cntsrc, clkmult, clkpol;\r\ncra = S626_SET_CRA_LOADSRC_A(S626_GET_STD_LOADSRC(setup));\r\ncra |= S626_SET_CRA_INDXSRC_A(S626_GET_STD_INDXSRC(setup));\r\ncrb = S626_SET_CRB_INTRESETCMD(1) | S626_SET_CRB_INTRESET_A(1);\r\ncrb |= S626_SET_CRB_CLKENAB_A(S626_GET_STD_CLKENAB(setup));\r\nif (!disable_int_src)\r\ncra |= S626_SET_CRA_INTSRC_A(S626_GET_STD_INTSRC(setup));\r\nclkpol = S626_GET_STD_CLKPOL(setup);\r\nswitch (S626_GET_STD_ENCMODE(setup)) {\r\ncase S626_ENCMODE_EXTENDER:\r\ncase S626_ENCMODE_TIMER:\r\ncntsrc = S626_CNTSRC_SYSCLK;\r\ncntsrc |= clkpol;\r\nclkpol = 1;\r\nclkmult = S626_CLKMULT_1X;\r\nbreak;\r\ndefault:\r\ncntsrc = S626_CNTSRC_ENCODER;\r\nclkmult = S626_GET_STD_CLKMULT(setup);\r\nif (clkmult == S626_CLKMULT_SPECIAL)\r\nclkmult = S626_CLKMULT_1X;\r\nbreak;\r\n}\r\ncra |= S626_SET_CRA_CNTSRC_A(cntsrc) | S626_SET_CRA_CLKPOL_A(clkpol) |\r\nS626_SET_CRA_CLKMULT_A(clkmult);\r\nif (S626_GET_STD_INDXSRC(setup) != S626_INDXSRC_SOFT)\r\ncra |= S626_SET_CRA_INDXPOL_A(S626_GET_STD_INDXPOL(setup));\r\nif (disable_int_src)\r\ndevpriv->counter_int_enabs &= ~(S626_OVERMASK(chan) |\r\nS626_INDXMASK(chan));\r\ns626_debi_replace(dev, S626_LP_CRA(chan),\r\nS626_CRAMSK_INDXSRC_B | S626_CRAMSK_CNTSRC_B, cra);\r\ns626_debi_replace(dev, S626_LP_CRB(chan),\r\n~(S626_CRBMSK_INTCTRL | S626_CRBMSK_CLKENAB_A), crb);\r\n}\r\nstatic void s626_set_mode_b(struct comedi_device *dev,\r\nunsigned int chan, u16 setup,\r\nu16 disable_int_src)\r\n{\r\nstruct s626_private *devpriv = dev->private;\r\nu16 cra;\r\nu16 crb;\r\nunsigned int cntsrc, clkmult, clkpol;\r\ncra = S626_SET_CRA_INDXSRC_B(S626_GET_STD_INDXSRC(setup));\r\ncrb = S626_SET_CRB_INTRESETCMD(1) | S626_SET_CRB_INTRESET_B(1);\r\ncrb |= S626_SET_CRB_CLKENAB_B(S626_GET_STD_CLKENAB(setup));\r\ncrb |= S626_SET_CRB_LOADSRC_B(S626_GET_STD_LOADSRC(setup));\r\nif (!disable_int_src)\r\ncrb |= S626_SET_CRB_INTSRC_B(S626_GET_STD_INTSRC(setup));\r\nclkpol = S626_GET_STD_CLKPOL(setup);\r\nswitch (S626_GET_STD_ENCMODE(setup)) {\r\ncase S626_ENCMODE_TIMER:\r\ncntsrc = S626_CNTSRC_SYSCLK;\r\ncntsrc |= clkpol;\r\nclkpol = 1;\r\nclkmult = S626_CLKMULT_1X;\r\nbreak;\r\ncase S626_ENCMODE_EXTENDER:\r\ncntsrc = S626_CNTSRC_SYSCLK;\r\ncntsrc |= clkpol;\r\nclkpol = 1;\r\nclkmult = S626_CLKMULT_SPECIAL;\r\nbreak;\r\ndefault:\r\ncntsrc = S626_CNTSRC_ENCODER;\r\nclkmult = S626_GET_STD_CLKMULT(setup);\r\nif (clkmult == S626_CLKMULT_SPECIAL)\r\nclkmult = S626_CLKMULT_1X;\r\nbreak;\r\n}\r\ncra |= S626_SET_CRA_CNTSRC_B(cntsrc);\r\ncrb |= S626_SET_CRB_CLKPOL_B(clkpol) | S626_SET_CRB_CLKMULT_B(clkmult);\r\nif (S626_GET_STD_INDXSRC(setup) != S626_INDXSRC_SOFT)\r\ncrb |= S626_SET_CRB_INDXPOL_B(S626_GET_STD_INDXPOL(setup));\r\nif (disable_int_src)\r\ndevpriv->counter_int_enabs &= ~(S626_OVERMASK(chan) |\r\nS626_INDXMASK(chan));\r\ns626_debi_replace(dev, S626_LP_CRA(chan),\r\n~(S626_CRAMSK_INDXSRC_B | S626_CRAMSK_CNTSRC_B), cra);\r\ns626_debi_replace(dev, S626_LP_CRB(chan),\r\nS626_CRBMSK_CLKENAB_A | S626_CRBMSK_LATCHSRC, crb);\r\n}\r\nstatic void s626_set_mode(struct comedi_device *dev,\r\nunsigned int chan,\r\nu16 setup, u16 disable_int_src)\r\n{\r\nif (chan < 3)\r\ns626_set_mode_a(dev, chan, setup, disable_int_src);\r\nelse\r\ns626_set_mode_b(dev, chan, setup, disable_int_src);\r\n}\r\nstatic void s626_set_enable(struct comedi_device *dev,\r\nunsigned int chan, u16 enab)\r\n{\r\nunsigned int mask = S626_CRBMSK_INTCTRL;\r\nunsigned int set;\r\nif (chan < 3) {\r\nmask |= S626_CRBMSK_CLKENAB_A;\r\nset = S626_SET_CRB_CLKENAB_A(enab);\r\n} else {\r\nmask |= S626_CRBMSK_CLKENAB_B;\r\nset = S626_SET_CRB_CLKENAB_B(enab);\r\n}\r\ns626_debi_replace(dev, S626_LP_CRB(chan), ~mask, set);\r\n}\r\nstatic void s626_set_load_trig(struct comedi_device *dev,\r\nunsigned int chan, u16 trig)\r\n{\r\nu16 reg;\r\nu16 mask;\r\nu16 set;\r\nif (chan < 3) {\r\nreg = S626_LP_CRA(chan);\r\nmask = S626_CRAMSK_LOADSRC_A;\r\nset = S626_SET_CRA_LOADSRC_A(trig);\r\n} else {\r\nreg = S626_LP_CRB(chan);\r\nmask = S626_CRBMSK_LOADSRC_B | S626_CRBMSK_INTCTRL;\r\nset = S626_SET_CRB_LOADSRC_B(trig);\r\n}\r\ns626_debi_replace(dev, reg, ~mask, set);\r\n}\r\nstatic void s626_set_int_src(struct comedi_device *dev,\r\nunsigned int chan, u16 int_source)\r\n{\r\nstruct s626_private *devpriv = dev->private;\r\nu16 cra_reg = S626_LP_CRA(chan);\r\nu16 crb_reg = S626_LP_CRB(chan);\r\nif (chan < 3) {\r\ns626_debi_replace(dev, crb_reg, ~S626_CRBMSK_INTCTRL,\r\nS626_SET_CRB_INTRESETCMD(1) |\r\nS626_SET_CRB_INTRESET_A(1));\r\ns626_debi_replace(dev, cra_reg, ~S626_CRAMSK_INTSRC_A,\r\nS626_SET_CRA_INTSRC_A(int_source));\r\n} else {\r\nu16 crb;\r\ncrb = s626_debi_read(dev, crb_reg);\r\ncrb &= ~S626_CRBMSK_INTCTRL;\r\ns626_debi_write(dev, crb_reg,\r\ncrb | S626_SET_CRB_INTRESETCMD(1) |\r\nS626_SET_CRB_INTRESET_B(1));\r\ns626_debi_write(dev, crb_reg,\r\n(crb & ~S626_CRBMSK_INTSRC_B) |\r\nS626_SET_CRB_INTSRC_B(int_source));\r\n}\r\ndevpriv->counter_int_enabs &= ~(S626_OVERMASK(chan) |\r\nS626_INDXMASK(chan));\r\nswitch (int_source) {\r\ncase 0:\r\ndefault:\r\nbreak;\r\ncase 1:\r\ndevpriv->counter_int_enabs |= S626_OVERMASK(chan);\r\nbreak;\r\ncase 2:\r\ndevpriv->counter_int_enabs |= S626_INDXMASK(chan);\r\nbreak;\r\ncase 3:\r\ndevpriv->counter_int_enabs |= (S626_OVERMASK(chan) |\r\nS626_INDXMASK(chan));\r\nbreak;\r\n}\r\n}\r\nstatic void s626_pulse_index(struct comedi_device *dev,\r\nunsigned int chan)\r\n{\r\nif (chan < 3) {\r\nu16 cra;\r\ncra = s626_debi_read(dev, S626_LP_CRA(chan));\r\ns626_debi_write(dev, S626_LP_CRA(chan),\r\n(cra ^ S626_CRAMSK_INDXPOL_A));\r\ns626_debi_write(dev, S626_LP_CRA(chan), cra);\r\n} else {\r\nu16 crb;\r\ncrb = s626_debi_read(dev, S626_LP_CRB(chan));\r\ncrb &= ~S626_CRBMSK_INTCTRL;\r\ns626_debi_write(dev, S626_LP_CRB(chan),\r\n(crb ^ S626_CRBMSK_INDXPOL_B));\r\ns626_debi_write(dev, S626_LP_CRB(chan), crb);\r\n}\r\n}\r\nstatic unsigned int s626_ai_reg_to_uint(unsigned int data)\r\n{\r\nreturn ((data >> 18) & 0x3fff) ^ 0x2000;\r\n}\r\nstatic int s626_dio_set_irq(struct comedi_device *dev, unsigned int chan)\r\n{\r\nunsigned int group = chan / 16;\r\nunsigned int mask = 1 << (chan - (16 * group));\r\nunsigned int status;\r\nstatus = s626_debi_read(dev, S626_LP_RDEDGSEL(group));\r\ns626_debi_write(dev, S626_LP_WREDGSEL(group), mask | status);\r\nstatus = s626_debi_read(dev, S626_LP_RDINTSEL(group));\r\ns626_debi_write(dev, S626_LP_WRINTSEL(group), mask | status);\r\ns626_debi_write(dev, S626_LP_MISC1, S626_MISC1_EDCAP);\r\nstatus = s626_debi_read(dev, S626_LP_RDCAPSEL(group));\r\ns626_debi_write(dev, S626_LP_WRCAPSEL(group), mask | status);\r\nreturn 0;\r\n}\r\nstatic int s626_dio_reset_irq(struct comedi_device *dev, unsigned int group,\r\nunsigned int mask)\r\n{\r\ns626_debi_write(dev, S626_LP_MISC1, S626_MISC1_NOEDCAP);\r\ns626_debi_write(dev, S626_LP_WRCAPSEL(group), mask);\r\nreturn 0;\r\n}\r\nstatic int s626_dio_clear_irq(struct comedi_device *dev)\r\n{\r\nunsigned int group;\r\ns626_debi_write(dev, S626_LP_MISC1, S626_MISC1_NOEDCAP);\r\nfor (group = 0; group < S626_DIO_BANKS; group++)\r\ns626_debi_write(dev, S626_LP_WRCAPSEL(group), 0xffff);\r\nreturn 0;\r\n}\r\nstatic void s626_handle_dio_interrupt(struct comedi_device *dev,\r\nu16 irqbit, u8 group)\r\n{\r\nstruct s626_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\ns626_dio_reset_irq(dev, group, irqbit);\r\nif (devpriv->ai_cmd_running) {\r\nif ((irqbit >> (cmd->start_arg - (16 * group))) == 1 &&\r\ncmd->start_src == TRIG_EXT) {\r\ns626_mc_enable(dev, S626_MC1_ERPS1, S626_P_MC1);\r\nif (cmd->scan_begin_src == TRIG_EXT)\r\ns626_dio_set_irq(dev, cmd->scan_begin_arg);\r\n}\r\nif ((irqbit >> (cmd->scan_begin_arg - (16 * group))) == 1 &&\r\ncmd->scan_begin_src == TRIG_EXT) {\r\ns626_mc_enable(dev, S626_MC2_ADC_RPS, S626_P_MC2);\r\nif (cmd->convert_src == TRIG_EXT) {\r\ndevpriv->ai_convert_count = cmd->chanlist_len;\r\ns626_dio_set_irq(dev, cmd->convert_arg);\r\n}\r\nif (cmd->convert_src == TRIG_TIMER) {\r\ndevpriv->ai_convert_count = cmd->chanlist_len;\r\ns626_set_enable(dev, 5, S626_CLKENAB_ALWAYS);\r\n}\r\n}\r\nif ((irqbit >> (cmd->convert_arg - (16 * group))) == 1 &&\r\ncmd->convert_src == TRIG_EXT) {\r\ns626_mc_enable(dev, S626_MC2_ADC_RPS, S626_P_MC2);\r\ndevpriv->ai_convert_count--;\r\nif (devpriv->ai_convert_count > 0)\r\ns626_dio_set_irq(dev, cmd->convert_arg);\r\n}\r\n}\r\n}\r\nstatic void s626_check_dio_interrupts(struct comedi_device *dev)\r\n{\r\nu16 irqbit;\r\nu8 group;\r\nfor (group = 0; group < S626_DIO_BANKS; group++) {\r\nirqbit = s626_debi_read(dev, S626_LP_RDCAPFLG(group));\r\nif (irqbit) {\r\ns626_handle_dio_interrupt(dev, irqbit, group);\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic void s626_check_counter_interrupts(struct comedi_device *dev)\r\n{\r\nstruct s626_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nu16 irqbit;\r\nirqbit = s626_debi_read(dev, S626_LP_RDMISC2);\r\nif (irqbit & S626_IRQ_COINT1A) {\r\ns626_reset_cap_flags(dev, 0);\r\n}\r\nif (irqbit & S626_IRQ_COINT2A) {\r\ns626_reset_cap_flags(dev, 1);\r\n}\r\nif (irqbit & S626_IRQ_COINT3A) {\r\ns626_reset_cap_flags(dev, 2);\r\n}\r\nif (irqbit & S626_IRQ_COINT1B) {\r\ns626_reset_cap_flags(dev, 3);\r\n}\r\nif (irqbit & S626_IRQ_COINT2B) {\r\ns626_reset_cap_flags(dev, 4);\r\nif (devpriv->ai_convert_count > 0) {\r\ndevpriv->ai_convert_count--;\r\nif (devpriv->ai_convert_count == 0)\r\ns626_set_enable(dev, 4, S626_CLKENAB_INDEX);\r\nif (cmd->convert_src == TRIG_TIMER) {\r\ns626_mc_enable(dev, S626_MC2_ADC_RPS,\r\nS626_P_MC2);\r\n}\r\n}\r\n}\r\nif (irqbit & S626_IRQ_COINT3B) {\r\ns626_reset_cap_flags(dev, 5);\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\ns626_mc_enable(dev, S626_MC2_ADC_RPS, S626_P_MC2);\r\n}\r\nif (cmd->convert_src == TRIG_TIMER) {\r\ndevpriv->ai_convert_count = cmd->chanlist_len;\r\ns626_set_enable(dev, 4, S626_CLKENAB_ALWAYS);\r\n}\r\n}\r\n}\r\nstatic bool s626_handle_eos_interrupt(struct comedi_device *dev)\r\n{\r\nstruct s626_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nu32 *readaddr = (u32 *)devpriv->ana_buf.logical_base + 1;\r\nint i;\r\nfor (i = 0; i < cmd->chanlist_len; i++) {\r\nunsigned short tempdata;\r\ntempdata = s626_ai_reg_to_uint(*readaddr);\r\nreadaddr++;\r\ncomedi_buf_write_samples(s, &tempdata, 1);\r\n}\r\nif (cmd->stop_src == TRIG_COUNT && async->scans_done >= cmd->stop_arg)\r\nasync->events |= COMEDI_CB_EOA;\r\nif (async->events & COMEDI_CB_CANCEL_MASK)\r\ndevpriv->ai_cmd_running = 0;\r\nif (devpriv->ai_cmd_running && cmd->scan_begin_src == TRIG_EXT)\r\ns626_dio_set_irq(dev, cmd->scan_begin_arg);\r\ncomedi_handle_events(dev, s);\r\nreturn !devpriv->ai_cmd_running;\r\n}\r\nstatic irqreturn_t s626_irq_handler(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nunsigned long flags;\r\nu32 irqtype, irqstatus;\r\nif (!dev->attached)\r\nreturn IRQ_NONE;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\nirqstatus = readl(dev->mmio + S626_P_IER);\r\nirqtype = readl(dev->mmio + S626_P_ISR);\r\nwritel(0, dev->mmio + S626_P_IER);\r\nwritel(irqtype, dev->mmio + S626_P_ISR);\r\nswitch (irqtype) {\r\ncase S626_IRQ_RPS1:\r\nif (s626_handle_eos_interrupt(dev))\r\nirqstatus = 0;\r\nbreak;\r\ncase S626_IRQ_GPIO3:\r\ns626_check_dio_interrupts(dev);\r\ns626_check_counter_interrupts(dev);\r\nbreak;\r\n}\r\nwritel(irqstatus, dev->mmio + S626_P_IER);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void s626_reset_adc(struct comedi_device *dev, u8 *ppl)\r\n{\r\nstruct s626_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nu32 *rps;\r\nu32 jmp_adrs;\r\nu16 i;\r\nu16 n;\r\nu32 local_ppl;\r\ns626_mc_disable(dev, S626_MC1_ERPS1, S626_P_MC1);\r\nrps = (u32 *)devpriv->rps_buf.logical_base;\r\nwritel((u32)devpriv->rps_buf.physical_base,\r\ndev->mmio + S626_P_RPSADDR1);\r\nif (cmd->scan_begin_src != TRIG_FOLLOW) {\r\n*rps++ = S626_RPS_PAUSE | S626_RPS_SIGADC;\r\n*rps++ = S626_RPS_CLRSIGNAL | S626_RPS_SIGADC;\r\n}\r\n*rps++ = S626_RPS_LDREG | (S626_P_DEBICMD >> 2);\r\n*rps++ = S626_DEBI_CMD_WRWORD | S626_LP_GSEL;\r\n*rps++ = S626_RPS_LDREG | (S626_P_DEBIAD >> 2);\r\n*rps++ = S626_GSEL_BIPOLAR5V;\r\n*rps++ = S626_RPS_CLRSIGNAL | S626_RPS_DEBI;\r\n*rps++ = S626_RPS_UPLOAD | S626_RPS_DEBI;\r\n*rps++ = S626_RPS_PAUSE | S626_RPS_DEBI;\r\nfor (devpriv->adc_items = 0; devpriv->adc_items < 16;\r\ndevpriv->adc_items++) {\r\nlocal_ppl = (*ppl << 8) | (*ppl & 0x10 ? S626_GSEL_BIPOLAR5V :\r\nS626_GSEL_BIPOLAR10V);\r\n*rps++ = S626_RPS_LDREG | (S626_P_DEBICMD >> 2);\r\n*rps++ = S626_DEBI_CMD_WRWORD | S626_LP_GSEL;\r\n*rps++ = S626_RPS_LDREG | (S626_P_DEBIAD >> 2);\r\n*rps++ = local_ppl;\r\n*rps++ = S626_RPS_CLRSIGNAL | S626_RPS_DEBI;\r\n*rps++ = S626_RPS_UPLOAD | S626_RPS_DEBI;\r\n*rps++ = S626_RPS_PAUSE | S626_RPS_DEBI;\r\n*rps++ = S626_RPS_LDREG | (S626_P_DEBICMD >> 2);\r\n*rps++ = S626_DEBI_CMD_WRWORD | S626_LP_ISEL;\r\n*rps++ = S626_RPS_LDREG | (S626_P_DEBIAD >> 2);\r\n*rps++ = local_ppl;\r\n*rps++ = S626_RPS_CLRSIGNAL | S626_RPS_DEBI;\r\n*rps++ = S626_RPS_UPLOAD | S626_RPS_DEBI;\r\n*rps++ = S626_RPS_PAUSE | S626_RPS_DEBI;\r\njmp_adrs =\r\n(u32)devpriv->rps_buf.physical_base +\r\n(u32)((unsigned long)rps -\r\n(unsigned long)devpriv->\r\nrps_buf.logical_base);\r\nfor (i = 0; i < (10 * S626_RPSCLK_PER_US / 2); i++) {\r\njmp_adrs += 8;\r\n*rps++ = S626_RPS_JUMP;\r\n*rps++ = jmp_adrs;\r\n}\r\nif (cmd->convert_src != TRIG_NOW) {\r\n*rps++ = S626_RPS_PAUSE | S626_RPS_SIGADC;\r\n*rps++ = S626_RPS_CLRSIGNAL | S626_RPS_SIGADC;\r\n}\r\n*rps++ = S626_RPS_LDREG | (S626_P_GPIO >> 2);\r\n*rps++ = S626_GPIO_BASE | S626_GPIO1_LO;\r\n*rps++ = S626_RPS_NOP;\r\n*rps++ = S626_RPS_LDREG | (S626_P_GPIO >> 2);\r\n*rps++ = S626_GPIO_BASE | S626_GPIO1_HI;\r\n*rps++ = S626_RPS_PAUSE | S626_RPS_GPIO2;\r\n*rps++ = S626_RPS_STREG |\r\n(S626_BUGFIX_STREG(S626_P_FB_BUFFER1) >> 2);\r\n*rps++ = (u32)devpriv->ana_buf.physical_base +\r\n(devpriv->adc_items << 2);\r\nif (*ppl++ & S626_EOPL) {\r\ndevpriv->adc_items++;\r\nbreak;\r\n}\r\n}\r\nfor (n = 0; n < (2 * S626_RPSCLK_PER_US); n++)\r\n*rps++ = S626_RPS_NOP;\r\n*rps++ = S626_RPS_LDREG | (S626_P_GPIO >> 2);\r\n*rps++ = S626_GPIO_BASE | S626_GPIO1_LO;\r\n*rps++ = S626_RPS_NOP;\r\n*rps++ = S626_RPS_LDREG | (S626_P_GPIO >> 2);\r\n*rps++ = S626_GPIO_BASE | S626_GPIO1_HI;\r\n*rps++ = S626_RPS_PAUSE | S626_RPS_GPIO2;\r\n*rps++ = S626_RPS_STREG | (S626_BUGFIX_STREG(S626_P_FB_BUFFER1) >> 2);\r\n*rps++ = (u32)devpriv->ana_buf.physical_base +\r\n(devpriv->adc_items << 2);\r\nif (devpriv->ai_cmd_running == 1)\r\n*rps++ = S626_RPS_IRQ;\r\n*rps++ = S626_RPS_JUMP;\r\n*rps++ = (u32)devpriv->rps_buf.physical_base;\r\n}\r\nstatic int s626_ai_eoc(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned long context)\r\n{\r\nunsigned int status;\r\nstatus = readl(dev->mmio + S626_P_PSR);\r\nif (status & S626_PSR_GPIO2)\r\nreturn 0;\r\nreturn -EBUSY;\r\n}\r\nstatic int s626_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nu16 chan = CR_CHAN(insn->chanspec);\r\nu16 range = CR_RANGE(insn->chanspec);\r\nu16 adc_spec = 0;\r\nu32 gpio_image;\r\nu32 tmp;\r\nint ret;\r\nint n;\r\nif (range == 0)\r\nadc_spec = (chan << 8) | (S626_GSEL_BIPOLAR5V);\r\nelse\r\nadc_spec = (chan << 8) | (S626_GSEL_BIPOLAR10V);\r\ns626_debi_write(dev, S626_LP_GSEL, adc_spec);\r\ns626_debi_write(dev, S626_LP_ISEL, adc_spec);\r\nfor (n = 0; n < insn->n; n++) {\r\nusleep_range(10, 20);\r\ngpio_image = readl(dev->mmio + S626_P_GPIO);\r\nwritel(gpio_image & ~S626_GPIO1_HI, dev->mmio + S626_P_GPIO);\r\nwritel(gpio_image & ~S626_GPIO1_HI, dev->mmio + S626_P_GPIO);\r\nwritel(gpio_image & ~S626_GPIO1_HI, dev->mmio + S626_P_GPIO);\r\nwritel(gpio_image | S626_GPIO1_HI, dev->mmio + S626_P_GPIO);\r\nret = comedi_timeout(dev, s, insn, s626_ai_eoc, 0);\r\nif (ret)\r\nreturn ret;\r\nif (n != 0) {\r\ntmp = readl(dev->mmio + S626_P_FB_BUFFER1);\r\ndata[n - 1] = s626_ai_reg_to_uint(tmp);\r\n}\r\nudelay(4);\r\n}\r\ngpio_image = readl(dev->mmio + S626_P_GPIO);\r\nwritel(gpio_image & ~S626_GPIO1_HI, dev->mmio + S626_P_GPIO);\r\nwritel(gpio_image & ~S626_GPIO1_HI, dev->mmio + S626_P_GPIO);\r\nwritel(gpio_image & ~S626_GPIO1_HI, dev->mmio + S626_P_GPIO);\r\nwritel(gpio_image | S626_GPIO1_HI, dev->mmio + S626_P_GPIO);\r\nret = comedi_timeout(dev, s, insn, s626_ai_eoc, 0);\r\nif (ret)\r\nreturn ret;\r\nif (n != 0) {\r\ntmp = readl(dev->mmio + S626_P_FB_BUFFER1);\r\ndata[n - 1] = s626_ai_reg_to_uint(tmp);\r\n}\r\nreturn n;\r\n}\r\nstatic int s626_ai_load_polllist(u8 *ppl, struct comedi_cmd *cmd)\r\n{\r\nint n;\r\nfor (n = 0; n < cmd->chanlist_len; n++) {\r\nif (CR_RANGE(cmd->chanlist[n]) == 0)\r\nppl[n] = CR_CHAN(cmd->chanlist[n]) | S626_RANGE_5V;\r\nelse\r\nppl[n] = CR_CHAN(cmd->chanlist[n]) | S626_RANGE_10V;\r\n}\r\nif (n != 0)\r\nppl[n - 1] |= S626_EOPL;\r\nreturn n;\r\n}\r\nstatic int s626_ai_inttrig(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int trig_num)\r\n{\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nif (trig_num != cmd->start_arg)\r\nreturn -EINVAL;\r\ns626_mc_enable(dev, S626_MC1_ERPS1, S626_P_MC1);\r\ns->async->inttrig = NULL;\r\nreturn 1;\r\n}\r\nstatic int s626_ns_to_timer(unsigned int *nanosec, unsigned int flags)\r\n{\r\nint divider, base;\r\nbase = 500;\r\nswitch (flags & CMDF_ROUND_MASK) {\r\ncase CMDF_ROUND_NEAREST:\r\ndefault:\r\ndivider = DIV_ROUND_CLOSEST(*nanosec, base);\r\nbreak;\r\ncase CMDF_ROUND_DOWN:\r\ndivider = (*nanosec) / base;\r\nbreak;\r\ncase CMDF_ROUND_UP:\r\ndivider = DIV_ROUND_UP(*nanosec, base);\r\nbreak;\r\n}\r\n*nanosec = base * divider;\r\nreturn divider - 1;\r\n}\r\nstatic void s626_timer_load(struct comedi_device *dev,\r\nunsigned int chan, int tick)\r\n{\r\nu16 setup =\r\nS626_SET_STD_LOADSRC(S626_LOADSRC_INDX) |\r\nS626_SET_STD_INDXSRC(S626_INDXSRC_SOFT) |\r\nS626_SET_STD_ENCMODE(S626_ENCMODE_TIMER) |\r\nS626_SET_STD_CLKPOL(S626_CNTDIR_DOWN) |\r\nS626_SET_STD_CLKMULT(S626_CLKMULT_1X) |\r\nS626_SET_STD_CLKENAB(S626_CLKENAB_INDEX);\r\nu16 value_latchsrc = S626_LATCHSRC_A_INDXA;\r\ns626_set_mode(dev, chan, setup, false);\r\ns626_preload(dev, chan, tick);\r\ns626_set_load_trig(dev, chan, 0);\r\ns626_pulse_index(dev, chan);\r\ns626_set_load_trig(dev, chan, 1);\r\ns626_set_int_src(dev, chan, S626_INTSRC_OVER);\r\ns626_set_latch_source(dev, chan, value_latchsrc);\r\n}\r\nstatic int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct s626_private *devpriv = dev->private;\r\nu8 ppl[16];\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nint tick;\r\nif (devpriv->ai_cmd_running) {\r\ndev_err(dev->class_dev,\r\n"s626_ai_cmd: Another ai_cmd is running\n");\r\nreturn -EBUSY;\r\n}\r\nwritel(0, dev->mmio + S626_P_IER);\r\nwritel(S626_IRQ_RPS1 | S626_IRQ_GPIO3, dev->mmio + S626_P_ISR);\r\ns626_dio_clear_irq(dev);\r\ndevpriv->ai_cmd_running = 0;\r\ns626_ai_load_polllist(ppl, cmd);\r\ndevpriv->ai_cmd_running = 1;\r\ndevpriv->ai_convert_count = 0;\r\nswitch (cmd->scan_begin_src) {\r\ncase TRIG_FOLLOW:\r\nbreak;\r\ncase TRIG_TIMER:\r\ntick = s626_ns_to_timer(&cmd->scan_begin_arg, cmd->flags);\r\ns626_timer_load(dev, 5, tick);\r\ns626_set_enable(dev, 5, S626_CLKENAB_ALWAYS);\r\nbreak;\r\ncase TRIG_EXT:\r\nif (cmd->start_src != TRIG_EXT)\r\ns626_dio_set_irq(dev, cmd->scan_begin_arg);\r\nbreak;\r\n}\r\nswitch (cmd->convert_src) {\r\ncase TRIG_NOW:\r\nbreak;\r\ncase TRIG_TIMER:\r\ntick = s626_ns_to_timer(&cmd->convert_arg, cmd->flags);\r\ns626_timer_load(dev, 4, tick);\r\ns626_set_enable(dev, 4, S626_CLKENAB_INDEX);\r\nbreak;\r\ncase TRIG_EXT:\r\nif (cmd->scan_begin_src != TRIG_EXT &&\r\ncmd->start_src == TRIG_EXT)\r\ns626_dio_set_irq(dev, cmd->convert_arg);\r\nbreak;\r\n}\r\ns626_reset_adc(dev, ppl);\r\nswitch (cmd->start_src) {\r\ncase TRIG_NOW:\r\ns626_mc_enable(dev, S626_MC1_ERPS1, S626_P_MC1);\r\ns->async->inttrig = NULL;\r\nbreak;\r\ncase TRIG_EXT:\r\ns626_dio_set_irq(dev, cmd->start_arg);\r\ns->async->inttrig = NULL;\r\nbreak;\r\ncase TRIG_INT:\r\ns->async->inttrig = s626_ai_inttrig;\r\nbreak;\r\n}\r\nwritel(S626_IRQ_GPIO3 | S626_IRQ_RPS1, dev->mmio + S626_P_IER);\r\nreturn 0;\r\n}\r\nstatic int s626_ai_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_cmd *cmd)\r\n{\r\nint err = 0;\r\nunsigned int arg;\r\nerr |= comedi_check_trigger_src(&cmd->start_src,\r\nTRIG_NOW | TRIG_INT | TRIG_EXT);\r\nerr |= comedi_check_trigger_src(&cmd->scan_begin_src,\r\nTRIG_TIMER | TRIG_EXT | TRIG_FOLLOW);\r\nerr |= comedi_check_trigger_src(&cmd->convert_src,\r\nTRIG_TIMER | TRIG_EXT | TRIG_NOW);\r\nerr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\r\nif (err)\r\nreturn 1;\r\nerr |= comedi_check_trigger_is_unique(cmd->start_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->scan_begin_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->convert_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->stop_src);\r\nif (err)\r\nreturn 2;\r\nswitch (cmd->start_src) {\r\ncase TRIG_NOW:\r\ncase TRIG_INT:\r\nerr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\r\nbreak;\r\ncase TRIG_EXT:\r\nerr |= comedi_check_trigger_arg_max(&cmd->start_arg, 39);\r\nbreak;\r\n}\r\nif (cmd->scan_begin_src == TRIG_EXT)\r\nerr |= comedi_check_trigger_arg_max(&cmd->scan_begin_arg, 39);\r\nif (cmd->convert_src == TRIG_EXT)\r\nerr |= comedi_check_trigger_arg_max(&cmd->convert_arg, 39);\r\n#define S626_MAX_SPEED 200000\r\n#define S626_MIN_SPEED 2000000000\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nerr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,\r\nS626_MAX_SPEED);\r\nerr |= comedi_check_trigger_arg_max(&cmd->scan_begin_arg,\r\nS626_MIN_SPEED);\r\n} else {\r\n}\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nerr |= comedi_check_trigger_arg_min(&cmd->convert_arg,\r\nS626_MAX_SPEED);\r\nerr |= comedi_check_trigger_arg_max(&cmd->convert_arg,\r\nS626_MIN_SPEED);\r\n} else {\r\n}\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\r\ncmd->chanlist_len);\r\nif (cmd->stop_src == TRIG_COUNT)\r\nerr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\r\nelse\r\nerr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\r\nif (err)\r\nreturn 3;\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\narg = cmd->scan_begin_arg;\r\ns626_ns_to_timer(&arg, cmd->flags);\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, arg);\r\n}\r\nif (cmd->convert_src == TRIG_TIMER) {\r\narg = cmd->convert_arg;\r\ns626_ns_to_timer(&arg, cmd->flags);\r\nerr |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg);\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\narg = cmd->convert_arg * cmd->scan_end_arg;\r\nerr |= comedi_check_trigger_arg_min(&cmd->\r\nscan_begin_arg,\r\narg);\r\n}\r\n}\r\nif (err)\r\nreturn 4;\r\nreturn 0;\r\n}\r\nstatic int s626_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct s626_private *devpriv = dev->private;\r\ns626_mc_disable(dev, S626_MC1_ERPS1, S626_P_MC1);\r\nwritel(0, dev->mmio + S626_P_IER);\r\ndevpriv->ai_cmd_running = 0;\r\nreturn 0;\r\n}\r\nstatic int s626_ao_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nint i;\r\nfor (i = 0; i < insn->n; i++) {\r\ns16 dacdata = (s16)data[i];\r\nint ret;\r\ndacdata -= (0x1fff);\r\nret = s626_set_dac(dev, chan, dacdata);\r\nif (ret)\r\nreturn ret;\r\ns->readback[chan] = data[i];\r\n}\r\nreturn insn->n;\r\n}\r\nstatic void s626_dio_init(struct comedi_device *dev)\r\n{\r\nu16 group;\r\ns626_debi_write(dev, S626_LP_MISC1, S626_MISC1_NOEDCAP);\r\nfor (group = 0; group < S626_DIO_BANKS; group++) {\r\ns626_debi_write(dev, S626_LP_WRINTSEL(group), 0);\r\ns626_debi_write(dev, S626_LP_WRCAPSEL(group), 0xffff);\r\ns626_debi_write(dev, S626_LP_WREDGSEL(group), 0);\r\ns626_debi_write(dev, S626_LP_WRDOUT(group), 0);\r\n}\r\n}\r\nstatic int s626_dio_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned long group = (unsigned long)s->private;\r\nif (comedi_dio_update_state(s, data))\r\ns626_debi_write(dev, S626_LP_WRDOUT(group), s->state);\r\ndata[1] = s626_debi_read(dev, S626_LP_RDDIN(group));\r\nreturn insn->n;\r\n}\r\nstatic int s626_dio_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned long group = (unsigned long)s->private;\r\nint ret;\r\nret = comedi_dio_insn_config(dev, s, insn, data, 0);\r\nif (ret)\r\nreturn ret;\r\ns626_debi_write(dev, S626_LP_WRDOUT(group), s->io_bits);\r\nreturn insn->n;\r\n}\r\nstatic int s626_enc_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nu16 setup =\r\nS626_SET_STD_LOADSRC(S626_LOADSRC_INDX) |\r\nS626_SET_STD_INDXSRC(S626_INDXSRC_SOFT) |\r\nS626_SET_STD_ENCMODE(S626_ENCMODE_COUNTER) |\r\nS626_SET_STD_CLKPOL(S626_CLKPOL_POS) |\r\nS626_SET_STD_CLKMULT(S626_CLKMULT_1X) |\r\nS626_SET_STD_CLKENAB(S626_CLKENAB_INDEX);\r\nu16 value_latchsrc = S626_LATCHSRC_AB_READ;\r\nu16 enab = S626_CLKENAB_ALWAYS;\r\ns626_set_mode(dev, chan, setup, true);\r\ns626_preload(dev, chan, data[0]);\r\ns626_pulse_index(dev, chan);\r\ns626_set_latch_source(dev, chan, value_latchsrc);\r\ns626_set_enable(dev, chan, (enab != 0));\r\nreturn insn->n;\r\n}\r\nstatic int s626_enc_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nu16 cntr_latch_reg = S626_LP_CNTR(chan);\r\nint i;\r\nfor (i = 0; i < insn->n; i++) {\r\nunsigned int val;\r\nval = s626_debi_read(dev, cntr_latch_reg);\r\nval |= (s626_debi_read(dev, cntr_latch_reg + 2) << 16);\r\ndata[i] = val;\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int s626_enc_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\ns626_preload(dev, chan, data[0]);\r\ns626_set_load_trig(dev, chan, 0);\r\ns626_pulse_index(dev, chan);\r\ns626_set_load_trig(dev, chan, 2);\r\nreturn 1;\r\n}\r\nstatic void s626_write_misc2(struct comedi_device *dev, u16 new_image)\r\n{\r\ns626_debi_write(dev, S626_LP_MISC1, S626_MISC1_WENABLE);\r\ns626_debi_write(dev, S626_LP_WRMISC2, new_image);\r\ns626_debi_write(dev, S626_LP_MISC1, S626_MISC1_WDISABLE);\r\n}\r\nstatic void s626_counters_init(struct comedi_device *dev)\r\n{\r\nint chan;\r\nu16 setup =\r\nS626_SET_STD_LOADSRC(S626_LOADSRC_INDX) |\r\nS626_SET_STD_INDXSRC(S626_INDXSRC_SOFT) |\r\nS626_SET_STD_ENCMODE(S626_ENCMODE_COUNTER) |\r\nS626_SET_STD_CLKPOL(S626_CLKPOL_POS) |\r\nS626_SET_STD_CLKMULT(S626_CLKMULT_1X) |\r\nS626_SET_STD_CLKENAB(S626_CLKENAB_INDEX);\r\nfor (chan = 0; chan < S626_ENCODER_CHANNELS; chan++) {\r\ns626_set_mode(dev, chan, setup, true);\r\ns626_set_int_src(dev, chan, 0);\r\ns626_reset_cap_flags(dev, chan);\r\ns626_set_enable(dev, chan, S626_CLKENAB_ALWAYS);\r\n}\r\n}\r\nstatic int s626_allocate_dma_buffers(struct comedi_device *dev)\r\n{\r\nstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\r\nstruct s626_private *devpriv = dev->private;\r\nvoid *addr;\r\ndma_addr_t appdma;\r\naddr = pci_alloc_consistent(pcidev, S626_DMABUF_SIZE, &appdma);\r\nif (!addr)\r\nreturn -ENOMEM;\r\ndevpriv->ana_buf.logical_base = addr;\r\ndevpriv->ana_buf.physical_base = appdma;\r\naddr = pci_alloc_consistent(pcidev, S626_DMABUF_SIZE, &appdma);\r\nif (!addr)\r\nreturn -ENOMEM;\r\ndevpriv->rps_buf.logical_base = addr;\r\ndevpriv->rps_buf.physical_base = appdma;\r\nreturn 0;\r\n}\r\nstatic void s626_free_dma_buffers(struct comedi_device *dev)\r\n{\r\nstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\r\nstruct s626_private *devpriv = dev->private;\r\nif (!devpriv)\r\nreturn;\r\nif (devpriv->rps_buf.logical_base)\r\npci_free_consistent(pcidev, S626_DMABUF_SIZE,\r\ndevpriv->rps_buf.logical_base,\r\ndevpriv->rps_buf.physical_base);\r\nif (devpriv->ana_buf.logical_base)\r\npci_free_consistent(pcidev, S626_DMABUF_SIZE,\r\ndevpriv->ana_buf.logical_base,\r\ndevpriv->ana_buf.physical_base);\r\n}\r\nstatic int s626_initialize(struct comedi_device *dev)\r\n{\r\nstruct s626_private *devpriv = dev->private;\r\ndma_addr_t phys_buf;\r\nu16 chan;\r\nint i;\r\nint ret;\r\ns626_mc_enable(dev, S626_MC1_DEBI | S626_MC1_AUDIO | S626_MC1_I2C,\r\nS626_P_MC1);\r\nwritel(S626_DEBI_CFG_SLAVE16 |\r\n(S626_DEBI_TOUT << S626_DEBI_CFG_TOUT_BIT) | S626_DEBI_SWAP |\r\nS626_DEBI_CFG_INTEL, dev->mmio + S626_P_DEBICFG);\r\nwritel(S626_DEBI_PAGE_DISABLE, dev->mmio + S626_P_DEBIPAGE);\r\nwritel(S626_GPIO_BASE | S626_GPIO1_HI, dev->mmio + S626_P_GPIO);\r\ndevpriv->i2c_adrs = 0xA0;\r\nwritel(S626_I2C_CLKSEL | S626_I2C_ABORT,\r\ndev->mmio + S626_P_I2CSTAT);\r\ns626_mc_enable(dev, S626_MC2_UPLD_IIC, S626_P_MC2);\r\nret = comedi_timeout(dev, NULL, NULL, s626_i2c_handshake_eoc, 0);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < 2; i++) {\r\nwritel(S626_I2C_CLKSEL, dev->mmio + S626_P_I2CSTAT);\r\ns626_mc_enable(dev, S626_MC2_UPLD_IIC, S626_P_MC2);\r\nret = comedi_timeout(dev, NULL,\r\nNULL, s626_i2c_handshake_eoc, 0);\r\nif (ret)\r\nreturn ret;\r\n}\r\nwritel(S626_ACON2_INIT, dev->mmio + S626_P_ACON2);\r\nwritel(S626_RSD1 | S626_SIB_A1, dev->mmio + S626_P_TSL1);\r\nwritel(S626_RSD1 | S626_SIB_A1 | S626_EOS,\r\ndev->mmio + S626_P_TSL1 + 4);\r\nwritel(S626_ACON1_ADCSTART, dev->mmio + S626_P_ACON1);\r\nwritel((u32)devpriv->rps_buf.physical_base,\r\ndev->mmio + S626_P_RPSADDR1);\r\nwritel(0, dev->mmio + S626_P_RPSPAGE1);\r\nwritel(0, dev->mmio + S626_P_RPS1_TOUT);\r\n#if 0\r\n{\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nuint8_t poll_list;\r\nuint16_t adc_data;\r\nuint16_t start_val;\r\nuint16_t index;\r\nunsigned int data[16];\r\npoll_list = S626_EOPL;\r\ns626_reset_adc(dev, &poll_list);\r\ns626_ai_rinsn(dev, s, NULL, data);\r\nstart_val = data[0];\r\nfor (index = 0; index < 500; index++) {\r\ns626_ai_rinsn(dev, s, NULL, data);\r\nadc_data = data[0];\r\nif (adc_data != start_val)\r\nbreak;\r\n}\r\n}\r\n#endif\r\nwritel(0, dev->mmio + S626_P_PCI_BT_A);\r\nphys_buf = devpriv->ana_buf.physical_base +\r\n(S626_DAC_WDMABUF_OS * sizeof(u32));\r\nwritel((u32)phys_buf, dev->mmio + S626_P_BASEA2_OUT);\r\nwritel((u32)(phys_buf + sizeof(u32)),\r\ndev->mmio + S626_P_PROTA2_OUT);\r\ndevpriv->dac_wbuf = (u32 *)devpriv->ana_buf.logical_base +\r\nS626_DAC_WDMABUF_OS;\r\nwritel(8, dev->mmio + S626_P_PAGEA2_OUT);\r\nwritel(S626_XSD2 | S626_RSD3 | S626_SIB_A2 | S626_EOS,\r\ndev->mmio + S626_VECTPORT(0));\r\nwritel(S626_LF_A2, dev->mmio + S626_VECTPORT(1));\r\nwritel(S626_ACON1_DACSTART, dev->mmio + S626_P_ACON1);\r\ns626_load_trim_dacs(dev);\r\nret = s626_load_trim_dacs(dev);\r\nif (ret)\r\nreturn ret;\r\nfor (chan = 0; chan < S626_DAC_CHANNELS; chan++) {\r\nret = s626_set_dac(dev, chan, 0);\r\nif (ret)\r\nreturn ret;\r\n}\r\ns626_counters_init(dev);\r\ns626_write_misc2(dev, (s626_debi_read(dev, S626_LP_RDMISC2) &\r\nS626_MISC2_BATT_ENABLE));\r\ns626_dio_init(dev);\r\nreturn 0;\r\n}\r\nstatic int s626_auto_attach(struct comedi_device *dev,\r\nunsigned long context_unused)\r\n{\r\nstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\r\nstruct s626_private *devpriv;\r\nstruct comedi_subdevice *s;\r\nint ret;\r\ndevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\nret = comedi_pci_enable(dev);\r\nif (ret)\r\nreturn ret;\r\ndev->mmio = pci_ioremap_bar(pcidev, 0);\r\nif (!dev->mmio)\r\nreturn -ENOMEM;\r\nwritel(0, dev->mmio + S626_P_IER);\r\nwritel(S626_MC1_SOFT_RESET, dev->mmio + S626_P_MC1);\r\nret = s626_allocate_dma_buffers(dev);\r\nif (ret)\r\nreturn ret;\r\nif (pcidev->irq) {\r\nret = request_irq(pcidev->irq, s626_irq_handler, IRQF_SHARED,\r\ndev->board_name, dev);\r\nif (ret == 0)\r\ndev->irq = pcidev->irq;\r\n}\r\nret = comedi_alloc_subdevices(dev, 6);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[0];\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_DIFF;\r\ns->n_chan = S626_ADC_CHANNELS;\r\ns->maxdata = 0x3fff;\r\ns->range_table = &s626_range_table;\r\ns->len_chanlist = S626_ADC_CHANNELS;\r\ns->insn_read = s626_ai_insn_read;\r\nif (dev->irq) {\r\ndev->read_subdev = s;\r\ns->subdev_flags |= SDF_CMD_READ;\r\ns->do_cmd = s626_ai_cmd;\r\ns->do_cmdtest = s626_ai_cmdtest;\r\ns->cancel = s626_ai_cancel;\r\n}\r\ns = &dev->subdevices[1];\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE | SDF_READABLE;\r\ns->n_chan = S626_DAC_CHANNELS;\r\ns->maxdata = 0x3fff;\r\ns->range_table = &range_bipolar10;\r\ns->insn_write = s626_ao_insn_write;\r\nret = comedi_alloc_subdev_readback(s);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[2];\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags = SDF_WRITABLE | SDF_READABLE;\r\ns->n_chan = 16;\r\ns->maxdata = 1;\r\ns->io_bits = 0xffff;\r\ns->private = (void *)0;\r\ns->range_table = &range_digital;\r\ns->insn_config = s626_dio_insn_config;\r\ns->insn_bits = s626_dio_insn_bits;\r\ns = &dev->subdevices[3];\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags = SDF_WRITABLE | SDF_READABLE;\r\ns->n_chan = 16;\r\ns->maxdata = 1;\r\ns->io_bits = 0xffff;\r\ns->private = (void *)1;\r\ns->range_table = &range_digital;\r\ns->insn_config = s626_dio_insn_config;\r\ns->insn_bits = s626_dio_insn_bits;\r\ns = &dev->subdevices[4];\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags = SDF_WRITABLE | SDF_READABLE;\r\ns->n_chan = 16;\r\ns->maxdata = 1;\r\ns->io_bits = 0xffff;\r\ns->private = (void *)2;\r\ns->range_table = &range_digital;\r\ns->insn_config = s626_dio_insn_config;\r\ns->insn_bits = s626_dio_insn_bits;\r\ns = &dev->subdevices[5];\r\ns->type = COMEDI_SUBD_COUNTER;\r\ns->subdev_flags = SDF_WRITABLE | SDF_READABLE | SDF_LSAMPL;\r\ns->n_chan = S626_ENCODER_CHANNELS;\r\ns->maxdata = 0xffffff;\r\ns->range_table = &range_unknown;\r\ns->insn_config = s626_enc_insn_config;\r\ns->insn_read = s626_enc_insn_read;\r\ns->insn_write = s626_enc_insn_write;\r\nreturn s626_initialize(dev);\r\n}\r\nstatic void s626_detach(struct comedi_device *dev)\r\n{\r\nstruct s626_private *devpriv = dev->private;\r\nif (devpriv) {\r\ndevpriv->ai_cmd_running = 0;\r\nif (dev->mmio) {\r\nwritel(0, dev->mmio + S626_P_IER);\r\nwritel(S626_IRQ_GPIO3 | S626_IRQ_RPS1,\r\ndev->mmio + S626_P_ISR);\r\ns626_write_misc2(dev, 0);\r\nwritel(S626_MC1_SHUTDOWN, dev->mmio + S626_P_MC1);\r\nwritel(S626_ACON1_BASE, dev->mmio + S626_P_ACON1);\r\n}\r\n}\r\ncomedi_pci_detach(dev);\r\ns626_free_dma_buffers(dev);\r\n}\r\nstatic int s626_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nreturn comedi_pci_auto_config(dev, &s626_driver, id->driver_data);\r\n}
