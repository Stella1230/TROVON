static void nvec_kbd_toggle_led(void)\r\n{\r\nchar buf[] = { NVEC_KBD, SET_LEDS, 0 };\r\nkeys_dev.caps_lock = !keys_dev.caps_lock;\r\nif (keys_dev.caps_lock)\r\nbuf[2] = BIT(0) | BIT(1) | BIT(2);\r\nnvec_write_async(keys_dev.nvec, buf, sizeof(buf));\r\n}\r\nstatic int nvec_keys_notifier(struct notifier_block *nb,\r\nunsigned long event_type, void *data)\r\n{\r\nint code, state;\r\nunsigned char *msg = data;\r\nif (event_type == NVEC_KB_EVT) {\r\nint _size = (msg[0] & (3 << 5)) >> 5;\r\nif (_size == NVEC_VAR_SIZE)\r\nreturn NOTIFY_STOP;\r\nif (_size == NVEC_3BYTES)\r\nmsg++;\r\ncode = msg[1] & 0x7f;\r\nstate = msg[1] & 0x80;\r\nif (code_tabs[_size][code] == KEY_CAPSLOCK && state)\r\nnvec_kbd_toggle_led();\r\ninput_report_key(keys_dev.input, code_tabs[_size][code],\r\n!state);\r\ninput_sync(keys_dev.input);\r\nreturn NOTIFY_STOP;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int nvec_kbd_event(struct input_dev *dev, unsigned int type,\r\nunsigned int code, int value)\r\n{\r\nstruct nvec_chip *nvec = keys_dev.nvec;\r\nchar buf[] = { NVEC_KBD, SET_LEDS, 0 };\r\nif (type == EV_REP)\r\nreturn 0;\r\nif (type != EV_LED)\r\nreturn -1;\r\nif (code != LED_CAPSL)\r\nreturn -1;\r\nbuf[2] = !!value;\r\nnvec_write_async(nvec, buf, sizeof(buf));\r\nreturn 0;\r\n}\r\nstatic int nvec_kbd_probe(struct platform_device *pdev)\r\n{\r\nstruct nvec_chip *nvec = dev_get_drvdata(pdev->dev.parent);\r\nint i, j, err;\r\nstruct input_dev *idev;\r\nchar clear_leds[] = { NVEC_KBD, SET_LEDS, 0 },\r\nenable_kbd[] = { NVEC_KBD, ENABLE_KBD },\r\ncnfg_wake[] = { NVEC_KBD, CNFG_WAKE, true, true },\r\ncnfg_wake_key_reporting[] = { NVEC_KBD, CNFG_WAKE_KEY_REPORTING,\r\ntrue };\r\nj = 0;\r\nfor (i = 0; i < ARRAY_SIZE(code_tab_102us); ++i)\r\nkeycodes[j++] = code_tab_102us[i];\r\nfor (i = 0; i < ARRAY_SIZE(extcode_tab_us102); ++i)\r\nkeycodes[j++] = extcode_tab_us102[i];\r\nidev = devm_input_allocate_device(&pdev->dev);\r\nidev->name = "nvec keyboard";\r\nidev->phys = "nvec";\r\nidev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP) | BIT_MASK(EV_LED);\r\nidev->ledbit[0] = BIT_MASK(LED_CAPSL);\r\nidev->event = nvec_kbd_event;\r\nidev->keycode = keycodes;\r\nidev->keycodesize = sizeof(unsigned char);\r\nidev->keycodemax = ARRAY_SIZE(keycodes);\r\nfor (i = 0; i < ARRAY_SIZE(keycodes); ++i)\r\nset_bit(keycodes[i], idev->keybit);\r\nclear_bit(0, idev->keybit);\r\nerr = input_register_device(idev);\r\nif (err)\r\nreturn err;\r\nkeys_dev.input = idev;\r\nkeys_dev.notifier.notifier_call = nvec_keys_notifier;\r\nkeys_dev.nvec = nvec;\r\nnvec_register_notifier(nvec, &keys_dev.notifier, 0);\r\nnvec_write_async(nvec, enable_kbd, 2);\r\nnvec_write_async(nvec, cnfg_wake, 4);\r\nnvec_write_async(nvec, cnfg_wake_key_reporting, 3);\r\nnvec_write_async(nvec, clear_leds, sizeof(clear_leds));\r\nreturn 0;\r\n}\r\nstatic int nvec_kbd_remove(struct platform_device *pdev)\r\n{\r\nstruct nvec_chip *nvec = dev_get_drvdata(pdev->dev.parent);\r\nchar disable_kbd[] = { NVEC_KBD, DISABLE_KBD },\r\nuncnfg_wake_key_reporting[] = { NVEC_KBD, CNFG_WAKE_KEY_REPORTING,\r\nfalse };\r\nnvec_write_async(nvec, uncnfg_wake_key_reporting, 3);\r\nnvec_write_async(nvec, disable_kbd, 2);\r\nnvec_unregister_notifier(nvec, &keys_dev.notifier);\r\nreturn 0;\r\n}
