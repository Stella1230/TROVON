static struct rb_entry *__lookup_rb_tree_fast(struct rb_entry *cached_re,\r\nunsigned int ofs)\r\n{\r\nif (cached_re) {\r\nif (cached_re->ofs <= ofs &&\r\ncached_re->ofs + cached_re->len > ofs) {\r\nreturn cached_re;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct rb_entry *__lookup_rb_tree_slow(struct rb_root *root,\r\nunsigned int ofs)\r\n{\r\nstruct rb_node *node = root->rb_node;\r\nstruct rb_entry *re;\r\nwhile (node) {\r\nre = rb_entry(node, struct rb_entry, rb_node);\r\nif (ofs < re->ofs)\r\nnode = node->rb_left;\r\nelse if (ofs >= re->ofs + re->len)\r\nnode = node->rb_right;\r\nelse\r\nreturn re;\r\n}\r\nreturn NULL;\r\n}\r\nstruct rb_entry *__lookup_rb_tree(struct rb_root *root,\r\nstruct rb_entry *cached_re, unsigned int ofs)\r\n{\r\nstruct rb_entry *re;\r\nre = __lookup_rb_tree_fast(cached_re, ofs);\r\nif (!re)\r\nreturn __lookup_rb_tree_slow(root, ofs);\r\nreturn re;\r\n}\r\nstruct rb_node **__lookup_rb_tree_for_insert(struct f2fs_sb_info *sbi,\r\nstruct rb_root *root, struct rb_node **parent,\r\nunsigned int ofs)\r\n{\r\nstruct rb_node **p = &root->rb_node;\r\nstruct rb_entry *re;\r\nwhile (*p) {\r\n*parent = *p;\r\nre = rb_entry(*parent, struct rb_entry, rb_node);\r\nif (ofs < re->ofs)\r\np = &(*p)->rb_left;\r\nelse if (ofs >= re->ofs + re->len)\r\np = &(*p)->rb_right;\r\nelse\r\nf2fs_bug_on(sbi, 1);\r\n}\r\nreturn p;\r\n}\r\nstruct rb_entry *__lookup_rb_tree_ret(struct rb_root *root,\r\nstruct rb_entry *cached_re,\r\nunsigned int ofs,\r\nstruct rb_entry **prev_entry,\r\nstruct rb_entry **next_entry,\r\nstruct rb_node ***insert_p,\r\nstruct rb_node **insert_parent,\r\nbool force)\r\n{\r\nstruct rb_node **pnode = &root->rb_node;\r\nstruct rb_node *parent = NULL, *tmp_node;\r\nstruct rb_entry *re = cached_re;\r\n*insert_p = NULL;\r\n*insert_parent = NULL;\r\n*prev_entry = NULL;\r\n*next_entry = NULL;\r\nif (RB_EMPTY_ROOT(root))\r\nreturn NULL;\r\nif (re) {\r\nif (re->ofs <= ofs && re->ofs + re->len > ofs)\r\ngoto lookup_neighbors;\r\n}\r\nwhile (*pnode) {\r\nparent = *pnode;\r\nre = rb_entry(*pnode, struct rb_entry, rb_node);\r\nif (ofs < re->ofs)\r\npnode = &(*pnode)->rb_left;\r\nelse if (ofs >= re->ofs + re->len)\r\npnode = &(*pnode)->rb_right;\r\nelse\r\ngoto lookup_neighbors;\r\n}\r\n*insert_p = pnode;\r\n*insert_parent = parent;\r\nre = rb_entry(parent, struct rb_entry, rb_node);\r\ntmp_node = parent;\r\nif (parent && ofs > re->ofs)\r\ntmp_node = rb_next(parent);\r\n*next_entry = rb_entry_safe(tmp_node, struct rb_entry, rb_node);\r\ntmp_node = parent;\r\nif (parent && ofs < re->ofs)\r\ntmp_node = rb_prev(parent);\r\n*prev_entry = rb_entry_safe(tmp_node, struct rb_entry, rb_node);\r\nreturn NULL;\r\nlookup_neighbors:\r\nif (ofs == re->ofs || force) {\r\ntmp_node = rb_prev(&re->rb_node);\r\n*prev_entry = rb_entry_safe(tmp_node, struct rb_entry, rb_node);\r\n}\r\nif (ofs == re->ofs + re->len - 1 || force) {\r\ntmp_node = rb_next(&re->rb_node);\r\n*next_entry = rb_entry_safe(tmp_node, struct rb_entry, rb_node);\r\n}\r\nreturn re;\r\n}\r\nbool __check_rb_tree_consistence(struct f2fs_sb_info *sbi,\r\nstruct rb_root *root)\r\n{\r\n#ifdef CONFIG_F2FS_CHECK_FS\r\nstruct rb_node *cur = rb_first(root), *next;\r\nstruct rb_entry *cur_re, *next_re;\r\nif (!cur)\r\nreturn true;\r\nwhile (cur) {\r\nnext = rb_next(cur);\r\nif (!next)\r\nreturn true;\r\ncur_re = rb_entry(cur, struct rb_entry, rb_node);\r\nnext_re = rb_entry(next, struct rb_entry, rb_node);\r\nif (cur_re->ofs + cur_re->len > next_re->ofs) {\r\nf2fs_msg(sbi->sb, KERN_INFO, "inconsistent rbtree, "\r\n"cur(%u, %u) next(%u, %u)",\r\ncur_re->ofs, cur_re->len,\r\nnext_re->ofs, next_re->len);\r\nreturn false;\r\n}\r\ncur = next;\r\n}\r\n#endif\r\nreturn true;\r\n}\r\nstatic struct extent_node *__attach_extent_node(struct f2fs_sb_info *sbi,\r\nstruct extent_tree *et, struct extent_info *ei,\r\nstruct rb_node *parent, struct rb_node **p)\r\n{\r\nstruct extent_node *en;\r\nen = kmem_cache_alloc(extent_node_slab, GFP_ATOMIC);\r\nif (!en)\r\nreturn NULL;\r\nen->ei = *ei;\r\nINIT_LIST_HEAD(&en->list);\r\nen->et = et;\r\nrb_link_node(&en->rb_node, parent, p);\r\nrb_insert_color(&en->rb_node, &et->root);\r\natomic_inc(&et->node_cnt);\r\natomic_inc(&sbi->total_ext_node);\r\nreturn en;\r\n}\r\nstatic void __detach_extent_node(struct f2fs_sb_info *sbi,\r\nstruct extent_tree *et, struct extent_node *en)\r\n{\r\nrb_erase(&en->rb_node, &et->root);\r\natomic_dec(&et->node_cnt);\r\natomic_dec(&sbi->total_ext_node);\r\nif (et->cached_en == en)\r\net->cached_en = NULL;\r\nkmem_cache_free(extent_node_slab, en);\r\n}\r\nstatic void __release_extent_node(struct f2fs_sb_info *sbi,\r\nstruct extent_tree *et, struct extent_node *en)\r\n{\r\nspin_lock(&sbi->extent_lock);\r\nf2fs_bug_on(sbi, list_empty(&en->list));\r\nlist_del_init(&en->list);\r\nspin_unlock(&sbi->extent_lock);\r\n__detach_extent_node(sbi, et, en);\r\n}\r\nstatic struct extent_tree *__grab_extent_tree(struct inode *inode)\r\n{\r\nstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\r\nstruct extent_tree *et;\r\nnid_t ino = inode->i_ino;\r\nmutex_lock(&sbi->extent_tree_lock);\r\net = radix_tree_lookup(&sbi->extent_tree_root, ino);\r\nif (!et) {\r\net = f2fs_kmem_cache_alloc(extent_tree_slab, GFP_NOFS);\r\nf2fs_radix_tree_insert(&sbi->extent_tree_root, ino, et);\r\nmemset(et, 0, sizeof(struct extent_tree));\r\net->ino = ino;\r\net->root = RB_ROOT;\r\net->cached_en = NULL;\r\nrwlock_init(&et->lock);\r\nINIT_LIST_HEAD(&et->list);\r\natomic_set(&et->node_cnt, 0);\r\natomic_inc(&sbi->total_ext_tree);\r\n} else {\r\natomic_dec(&sbi->total_zombie_tree);\r\nlist_del_init(&et->list);\r\n}\r\nmutex_unlock(&sbi->extent_tree_lock);\r\nF2FS_I(inode)->extent_tree = et;\r\nreturn et;\r\n}\r\nstatic struct extent_node *__init_extent_tree(struct f2fs_sb_info *sbi,\r\nstruct extent_tree *et, struct extent_info *ei)\r\n{\r\nstruct rb_node **p = &et->root.rb_node;\r\nstruct extent_node *en;\r\nen = __attach_extent_node(sbi, et, ei, NULL, p);\r\nif (!en)\r\nreturn NULL;\r\net->largest = en->ei;\r\net->cached_en = en;\r\nreturn en;\r\n}\r\nstatic unsigned int __free_extent_tree(struct f2fs_sb_info *sbi,\r\nstruct extent_tree *et)\r\n{\r\nstruct rb_node *node, *next;\r\nstruct extent_node *en;\r\nunsigned int count = atomic_read(&et->node_cnt);\r\nnode = rb_first(&et->root);\r\nwhile (node) {\r\nnext = rb_next(node);\r\nen = rb_entry(node, struct extent_node, rb_node);\r\n__release_extent_node(sbi, et, en);\r\nnode = next;\r\n}\r\nreturn count - atomic_read(&et->node_cnt);\r\n}\r\nstatic void __drop_largest_extent(struct inode *inode,\r\npgoff_t fofs, unsigned int len)\r\n{\r\nstruct extent_info *largest = &F2FS_I(inode)->extent_tree->largest;\r\nif (fofs < largest->fofs + largest->len && fofs + len > largest->fofs) {\r\nlargest->len = 0;\r\nf2fs_mark_inode_dirty_sync(inode, true);\r\n}\r\n}\r\nstatic bool __f2fs_init_extent_tree(struct inode *inode, struct f2fs_extent *i_ext)\r\n{\r\nstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\r\nstruct extent_tree *et;\r\nstruct extent_node *en;\r\nstruct extent_info ei;\r\nif (!f2fs_may_extent_tree(inode)) {\r\nif (i_ext && i_ext->len) {\r\ni_ext->len = 0;\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\net = __grab_extent_tree(inode);\r\nif (!i_ext || !i_ext->len)\r\nreturn false;\r\nget_extent_info(&ei, i_ext);\r\nwrite_lock(&et->lock);\r\nif (atomic_read(&et->node_cnt))\r\ngoto out;\r\nen = __init_extent_tree(sbi, et, &ei);\r\nif (en) {\r\nspin_lock(&sbi->extent_lock);\r\nlist_add_tail(&en->list, &sbi->extent_list);\r\nspin_unlock(&sbi->extent_lock);\r\n}\r\nout:\r\nwrite_unlock(&et->lock);\r\nreturn false;\r\n}\r\nbool f2fs_init_extent_tree(struct inode *inode, struct f2fs_extent *i_ext)\r\n{\r\nbool ret = __f2fs_init_extent_tree(inode, i_ext);\r\nif (!F2FS_I(inode)->extent_tree)\r\nset_inode_flag(inode, FI_NO_EXTENT);\r\nreturn ret;\r\n}\r\nstatic bool f2fs_lookup_extent_tree(struct inode *inode, pgoff_t pgofs,\r\nstruct extent_info *ei)\r\n{\r\nstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\r\nstruct extent_tree *et = F2FS_I(inode)->extent_tree;\r\nstruct extent_node *en;\r\nbool ret = false;\r\nf2fs_bug_on(sbi, !et);\r\ntrace_f2fs_lookup_extent_tree_start(inode, pgofs);\r\nread_lock(&et->lock);\r\nif (et->largest.fofs <= pgofs &&\r\net->largest.fofs + et->largest.len > pgofs) {\r\n*ei = et->largest;\r\nret = true;\r\nstat_inc_largest_node_hit(sbi);\r\ngoto out;\r\n}\r\nen = (struct extent_node *)__lookup_rb_tree(&et->root,\r\n(struct rb_entry *)et->cached_en, pgofs);\r\nif (!en)\r\ngoto out;\r\nif (en == et->cached_en)\r\nstat_inc_cached_node_hit(sbi);\r\nelse\r\nstat_inc_rbtree_node_hit(sbi);\r\n*ei = en->ei;\r\nspin_lock(&sbi->extent_lock);\r\nif (!list_empty(&en->list)) {\r\nlist_move_tail(&en->list, &sbi->extent_list);\r\net->cached_en = en;\r\n}\r\nspin_unlock(&sbi->extent_lock);\r\nret = true;\r\nout:\r\nstat_inc_total_hit(sbi);\r\nread_unlock(&et->lock);\r\ntrace_f2fs_lookup_extent_tree_end(inode, pgofs, ei);\r\nreturn ret;\r\n}\r\nstatic struct extent_node *__try_merge_extent_node(struct inode *inode,\r\nstruct extent_tree *et, struct extent_info *ei,\r\nstruct extent_node *prev_ex,\r\nstruct extent_node *next_ex)\r\n{\r\nstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\r\nstruct extent_node *en = NULL;\r\nif (prev_ex && __is_back_mergeable(ei, &prev_ex->ei)) {\r\nprev_ex->ei.len += ei->len;\r\nei = &prev_ex->ei;\r\nen = prev_ex;\r\n}\r\nif (next_ex && __is_front_mergeable(ei, &next_ex->ei)) {\r\nnext_ex->ei.fofs = ei->fofs;\r\nnext_ex->ei.blk = ei->blk;\r\nnext_ex->ei.len += ei->len;\r\nif (en)\r\n__release_extent_node(sbi, et, prev_ex);\r\nen = next_ex;\r\n}\r\nif (!en)\r\nreturn NULL;\r\n__try_update_largest_extent(inode, et, en);\r\nspin_lock(&sbi->extent_lock);\r\nif (!list_empty(&en->list)) {\r\nlist_move_tail(&en->list, &sbi->extent_list);\r\net->cached_en = en;\r\n}\r\nspin_unlock(&sbi->extent_lock);\r\nreturn en;\r\n}\r\nstatic struct extent_node *__insert_extent_tree(struct inode *inode,\r\nstruct extent_tree *et, struct extent_info *ei,\r\nstruct rb_node **insert_p,\r\nstruct rb_node *insert_parent)\r\n{\r\nstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\r\nstruct rb_node **p = &et->root.rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct extent_node *en = NULL;\r\nif (insert_p && insert_parent) {\r\nparent = insert_parent;\r\np = insert_p;\r\ngoto do_insert;\r\n}\r\np = __lookup_rb_tree_for_insert(sbi, &et->root, &parent, ei->fofs);\r\ndo_insert:\r\nen = __attach_extent_node(sbi, et, ei, parent, p);\r\nif (!en)\r\nreturn NULL;\r\n__try_update_largest_extent(inode, et, en);\r\nspin_lock(&sbi->extent_lock);\r\nlist_add_tail(&en->list, &sbi->extent_list);\r\net->cached_en = en;\r\nspin_unlock(&sbi->extent_lock);\r\nreturn en;\r\n}\r\nstatic void f2fs_update_extent_tree_range(struct inode *inode,\r\npgoff_t fofs, block_t blkaddr, unsigned int len)\r\n{\r\nstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\r\nstruct extent_tree *et = F2FS_I(inode)->extent_tree;\r\nstruct extent_node *en = NULL, *en1 = NULL;\r\nstruct extent_node *prev_en = NULL, *next_en = NULL;\r\nstruct extent_info ei, dei, prev;\r\nstruct rb_node **insert_p = NULL, *insert_parent = NULL;\r\nunsigned int end = fofs + len;\r\nunsigned int pos = (unsigned int)fofs;\r\nif (!et)\r\nreturn;\r\ntrace_f2fs_update_extent_tree_range(inode, fofs, blkaddr, len);\r\nwrite_lock(&et->lock);\r\nif (is_inode_flag_set(inode, FI_NO_EXTENT)) {\r\nwrite_unlock(&et->lock);\r\nreturn;\r\n}\r\nprev = et->largest;\r\ndei.len = 0;\r\n__drop_largest_extent(inode, fofs, len);\r\nen = (struct extent_node *)__lookup_rb_tree_ret(&et->root,\r\n(struct rb_entry *)et->cached_en, fofs,\r\n(struct rb_entry **)&prev_en,\r\n(struct rb_entry **)&next_en,\r\n&insert_p, &insert_parent, false);\r\nif (!en)\r\nen = next_en;\r\nwhile (en && en->ei.fofs < end) {\r\nunsigned int org_end;\r\nint parts = 0;\r\nnext_en = en1 = NULL;\r\ndei = en->ei;\r\norg_end = dei.fofs + dei.len;\r\nf2fs_bug_on(sbi, pos >= org_end);\r\nif (pos > dei.fofs && pos - dei.fofs >= F2FS_MIN_EXTENT_LEN) {\r\nen->ei.len = pos - en->ei.fofs;\r\nprev_en = en;\r\nparts = 1;\r\n}\r\nif (end < org_end && org_end - end >= F2FS_MIN_EXTENT_LEN) {\r\nif (parts) {\r\nset_extent_info(&ei, end,\r\nend - dei.fofs + dei.blk,\r\norg_end - end);\r\nen1 = __insert_extent_tree(inode, et, &ei,\r\nNULL, NULL);\r\nnext_en = en1;\r\n} else {\r\nen->ei.fofs = end;\r\nen->ei.blk += end - dei.fofs;\r\nen->ei.len -= end - dei.fofs;\r\nnext_en = en;\r\n}\r\nparts++;\r\n}\r\nif (!next_en) {\r\nstruct rb_node *node = rb_next(&en->rb_node);\r\nnext_en = rb_entry_safe(node, struct extent_node,\r\nrb_node);\r\n}\r\nif (parts)\r\n__try_update_largest_extent(inode, et, en);\r\nelse\r\n__release_extent_node(sbi, et, en);\r\nif (parts != 1) {\r\ninsert_p = NULL;\r\ninsert_parent = NULL;\r\n}\r\nen = next_en;\r\n}\r\nif (blkaddr) {\r\nset_extent_info(&ei, fofs, blkaddr, len);\r\nif (!__try_merge_extent_node(inode, et, &ei, prev_en, next_en))\r\n__insert_extent_tree(inode, et, &ei,\r\ninsert_p, insert_parent);\r\nif (dei.len >= 1 &&\r\nprev.len < F2FS_MIN_EXTENT_LEN &&\r\net->largest.len < F2FS_MIN_EXTENT_LEN) {\r\n__drop_largest_extent(inode, 0, UINT_MAX);\r\nset_inode_flag(inode, FI_NO_EXTENT);\r\n}\r\n}\r\nif (is_inode_flag_set(inode, FI_NO_EXTENT))\r\n__free_extent_tree(sbi, et);\r\nwrite_unlock(&et->lock);\r\n}\r\nunsigned int f2fs_shrink_extent_tree(struct f2fs_sb_info *sbi, int nr_shrink)\r\n{\r\nstruct extent_tree *et, *next;\r\nstruct extent_node *en;\r\nunsigned int node_cnt = 0, tree_cnt = 0;\r\nint remained;\r\nif (!test_opt(sbi, EXTENT_CACHE))\r\nreturn 0;\r\nif (!atomic_read(&sbi->total_zombie_tree))\r\ngoto free_node;\r\nif (!mutex_trylock(&sbi->extent_tree_lock))\r\ngoto out;\r\nlist_for_each_entry_safe(et, next, &sbi->zombie_list, list) {\r\nif (atomic_read(&et->node_cnt)) {\r\nwrite_lock(&et->lock);\r\nnode_cnt += __free_extent_tree(sbi, et);\r\nwrite_unlock(&et->lock);\r\n}\r\nf2fs_bug_on(sbi, atomic_read(&et->node_cnt));\r\nlist_del_init(&et->list);\r\nradix_tree_delete(&sbi->extent_tree_root, et->ino);\r\nkmem_cache_free(extent_tree_slab, et);\r\natomic_dec(&sbi->total_ext_tree);\r\natomic_dec(&sbi->total_zombie_tree);\r\ntree_cnt++;\r\nif (node_cnt + tree_cnt >= nr_shrink)\r\ngoto unlock_out;\r\ncond_resched();\r\n}\r\nmutex_unlock(&sbi->extent_tree_lock);\r\nfree_node:\r\nif (!mutex_trylock(&sbi->extent_tree_lock))\r\ngoto out;\r\nremained = nr_shrink - (node_cnt + tree_cnt);\r\nspin_lock(&sbi->extent_lock);\r\nfor (; remained > 0; remained--) {\r\nif (list_empty(&sbi->extent_list))\r\nbreak;\r\nen = list_first_entry(&sbi->extent_list,\r\nstruct extent_node, list);\r\net = en->et;\r\nif (!write_trylock(&et->lock)) {\r\nlist_move_tail(&en->list, &sbi->extent_list);\r\ncontinue;\r\n}\r\nlist_del_init(&en->list);\r\nspin_unlock(&sbi->extent_lock);\r\n__detach_extent_node(sbi, et, en);\r\nwrite_unlock(&et->lock);\r\nnode_cnt++;\r\nspin_lock(&sbi->extent_lock);\r\n}\r\nspin_unlock(&sbi->extent_lock);\r\nunlock_out:\r\nmutex_unlock(&sbi->extent_tree_lock);\r\nout:\r\ntrace_f2fs_shrink_extent_tree(sbi, node_cnt, tree_cnt);\r\nreturn node_cnt + tree_cnt;\r\n}\r\nunsigned int f2fs_destroy_extent_node(struct inode *inode)\r\n{\r\nstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\r\nstruct extent_tree *et = F2FS_I(inode)->extent_tree;\r\nunsigned int node_cnt = 0;\r\nif (!et || !atomic_read(&et->node_cnt))\r\nreturn 0;\r\nwrite_lock(&et->lock);\r\nnode_cnt = __free_extent_tree(sbi, et);\r\nwrite_unlock(&et->lock);\r\nreturn node_cnt;\r\n}\r\nvoid f2fs_drop_extent_tree(struct inode *inode)\r\n{\r\nstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\r\nstruct extent_tree *et = F2FS_I(inode)->extent_tree;\r\nset_inode_flag(inode, FI_NO_EXTENT);\r\nwrite_lock(&et->lock);\r\n__free_extent_tree(sbi, et);\r\n__drop_largest_extent(inode, 0, UINT_MAX);\r\nwrite_unlock(&et->lock);\r\n}\r\nvoid f2fs_destroy_extent_tree(struct inode *inode)\r\n{\r\nstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\r\nstruct extent_tree *et = F2FS_I(inode)->extent_tree;\r\nunsigned int node_cnt = 0;\r\nif (!et)\r\nreturn;\r\nif (inode->i_nlink && !is_bad_inode(inode) &&\r\natomic_read(&et->node_cnt)) {\r\nmutex_lock(&sbi->extent_tree_lock);\r\nlist_add_tail(&et->list, &sbi->zombie_list);\r\natomic_inc(&sbi->total_zombie_tree);\r\nmutex_unlock(&sbi->extent_tree_lock);\r\nreturn;\r\n}\r\nnode_cnt = f2fs_destroy_extent_node(inode);\r\nmutex_lock(&sbi->extent_tree_lock);\r\nf2fs_bug_on(sbi, atomic_read(&et->node_cnt));\r\nradix_tree_delete(&sbi->extent_tree_root, inode->i_ino);\r\nkmem_cache_free(extent_tree_slab, et);\r\natomic_dec(&sbi->total_ext_tree);\r\nmutex_unlock(&sbi->extent_tree_lock);\r\nF2FS_I(inode)->extent_tree = NULL;\r\ntrace_f2fs_destroy_extent_tree(inode, node_cnt);\r\n}\r\nbool f2fs_lookup_extent_cache(struct inode *inode, pgoff_t pgofs,\r\nstruct extent_info *ei)\r\n{\r\nif (!f2fs_may_extent_tree(inode))\r\nreturn false;\r\nreturn f2fs_lookup_extent_tree(inode, pgofs, ei);\r\n}\r\nvoid f2fs_update_extent_cache(struct dnode_of_data *dn)\r\n{\r\npgoff_t fofs;\r\nblock_t blkaddr;\r\nif (!f2fs_may_extent_tree(dn->inode))\r\nreturn;\r\nif (dn->data_blkaddr == NEW_ADDR)\r\nblkaddr = NULL_ADDR;\r\nelse\r\nblkaddr = dn->data_blkaddr;\r\nfofs = start_bidx_of_node(ofs_of_node(dn->node_page), dn->inode) +\r\ndn->ofs_in_node;\r\nf2fs_update_extent_tree_range(dn->inode, fofs, blkaddr, 1);\r\n}\r\nvoid f2fs_update_extent_cache_range(struct dnode_of_data *dn,\r\npgoff_t fofs, block_t blkaddr, unsigned int len)\r\n{\r\nif (!f2fs_may_extent_tree(dn->inode))\r\nreturn;\r\nf2fs_update_extent_tree_range(dn->inode, fofs, blkaddr, len);\r\n}\r\nvoid init_extent_cache_info(struct f2fs_sb_info *sbi)\r\n{\r\nINIT_RADIX_TREE(&sbi->extent_tree_root, GFP_NOIO);\r\nmutex_init(&sbi->extent_tree_lock);\r\nINIT_LIST_HEAD(&sbi->extent_list);\r\nspin_lock_init(&sbi->extent_lock);\r\natomic_set(&sbi->total_ext_tree, 0);\r\nINIT_LIST_HEAD(&sbi->zombie_list);\r\natomic_set(&sbi->total_zombie_tree, 0);\r\natomic_set(&sbi->total_ext_node, 0);\r\n}\r\nint __init create_extent_cache(void)\r\n{\r\nextent_tree_slab = f2fs_kmem_cache_create("f2fs_extent_tree",\r\nsizeof(struct extent_tree));\r\nif (!extent_tree_slab)\r\nreturn -ENOMEM;\r\nextent_node_slab = f2fs_kmem_cache_create("f2fs_extent_node",\r\nsizeof(struct extent_node));\r\nif (!extent_node_slab) {\r\nkmem_cache_destroy(extent_tree_slab);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nvoid destroy_extent_cache(void)\r\n{\r\nkmem_cache_destroy(extent_node_slab);\r\nkmem_cache_destroy(extent_tree_slab);\r\n}
