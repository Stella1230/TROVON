static inline void schedule_mac_stats_update(struct adapter *ap, int secs)\r\n{\r\nschedule_delayed_work(&ap->stats_update_task, secs * HZ);\r\n}\r\nstatic inline void cancel_mac_stats_update(struct adapter *ap)\r\n{\r\ncancel_delayed_work(&ap->stats_update_task);\r\n}\r\nstatic void t1_set_rxmode(struct net_device *dev)\r\n{\r\nstruct adapter *adapter = dev->ml_priv;\r\nstruct cmac *mac = adapter->port[dev->if_port].mac;\r\nstruct t1_rx_mode rm;\r\nrm.dev = dev;\r\nmac->ops->set_rx_mode(mac, &rm);\r\n}\r\nstatic void link_report(struct port_info *p)\r\n{\r\nif (!netif_carrier_ok(p->dev))\r\nnetdev_info(p->dev, "link down\n");\r\nelse {\r\nconst char *s = "10Mbps";\r\nswitch (p->link_config.speed) {\r\ncase SPEED_10000: s = "10Gbps"; break;\r\ncase SPEED_1000: s = "1000Mbps"; break;\r\ncase SPEED_100: s = "100Mbps"; break;\r\n}\r\nnetdev_info(p->dev, "link up, %s, %s-duplex\n",\r\ns, p->link_config.duplex == DUPLEX_FULL\r\n? "full" : "half");\r\n}\r\n}\r\nvoid t1_link_negotiated(struct adapter *adapter, int port_id, int link_stat,\r\nint speed, int duplex, int pause)\r\n{\r\nstruct port_info *p = &adapter->port[port_id];\r\nif (link_stat != netif_carrier_ok(p->dev)) {\r\nif (link_stat)\r\nnetif_carrier_on(p->dev);\r\nelse\r\nnetif_carrier_off(p->dev);\r\nlink_report(p);\r\nif ((speed > 0) && (adapter->params.nports > 1)) {\r\nunsigned int sched_speed = 10;\r\nswitch (speed) {\r\ncase SPEED_1000:\r\nsched_speed = 1000;\r\nbreak;\r\ncase SPEED_100:\r\nsched_speed = 100;\r\nbreak;\r\ncase SPEED_10:\r\nsched_speed = 10;\r\nbreak;\r\n}\r\nt1_sched_update_parms(adapter->sge, port_id, 0, sched_speed);\r\n}\r\n}\r\n}\r\nstatic void link_start(struct port_info *p)\r\n{\r\nstruct cmac *mac = p->mac;\r\nmac->ops->reset(mac);\r\nif (mac->ops->macaddress_set)\r\nmac->ops->macaddress_set(mac, p->dev->dev_addr);\r\nt1_set_rxmode(p->dev);\r\nt1_link_start(p->phy, mac, &p->link_config);\r\nmac->ops->enable(mac, MAC_DIRECTION_RX | MAC_DIRECTION_TX);\r\n}\r\nstatic void enable_hw_csum(struct adapter *adapter)\r\n{\r\nif (adapter->port[0].dev->hw_features & NETIF_F_TSO)\r\nt1_tp_set_ip_checksum_offload(adapter->tp, 1);\r\nt1_tp_set_tcp_checksum_offload(adapter->tp, 1);\r\n}\r\nstatic int cxgb_up(struct adapter *adapter)\r\n{\r\nint err = 0;\r\nif (!(adapter->flags & FULL_INIT_DONE)) {\r\nerr = t1_init_hw_modules(adapter);\r\nif (err)\r\ngoto out_err;\r\nenable_hw_csum(adapter);\r\nadapter->flags |= FULL_INIT_DONE;\r\n}\r\nt1_interrupts_clear(adapter);\r\nadapter->params.has_msi = !disable_msi && !pci_enable_msi(adapter->pdev);\r\nerr = request_irq(adapter->pdev->irq, t1_interrupt,\r\nadapter->params.has_msi ? 0 : IRQF_SHARED,\r\nadapter->name, adapter);\r\nif (err) {\r\nif (adapter->params.has_msi)\r\npci_disable_msi(adapter->pdev);\r\ngoto out_err;\r\n}\r\nt1_sge_start(adapter->sge);\r\nt1_interrupts_enable(adapter);\r\nout_err:\r\nreturn err;\r\n}\r\nstatic void cxgb_down(struct adapter *adapter)\r\n{\r\nt1_sge_stop(adapter->sge);\r\nt1_interrupts_disable(adapter);\r\nfree_irq(adapter->pdev->irq, adapter);\r\nif (adapter->params.has_msi)\r\npci_disable_msi(adapter->pdev);\r\n}\r\nstatic int cxgb_open(struct net_device *dev)\r\n{\r\nint err;\r\nstruct adapter *adapter = dev->ml_priv;\r\nint other_ports = adapter->open_device_map & PORT_MASK;\r\nnapi_enable(&adapter->napi);\r\nif (!adapter->open_device_map && (err = cxgb_up(adapter)) < 0) {\r\nnapi_disable(&adapter->napi);\r\nreturn err;\r\n}\r\n__set_bit(dev->if_port, &adapter->open_device_map);\r\nlink_start(&adapter->port[dev->if_port]);\r\nnetif_start_queue(dev);\r\nif (!other_ports && adapter->params.stats_update_period)\r\nschedule_mac_stats_update(adapter,\r\nadapter->params.stats_update_period);\r\nt1_vlan_mode(adapter, dev->features);\r\nreturn 0;\r\n}\r\nstatic int cxgb_close(struct net_device *dev)\r\n{\r\nstruct adapter *adapter = dev->ml_priv;\r\nstruct port_info *p = &adapter->port[dev->if_port];\r\nstruct cmac *mac = p->mac;\r\nnetif_stop_queue(dev);\r\nnapi_disable(&adapter->napi);\r\nmac->ops->disable(mac, MAC_DIRECTION_TX | MAC_DIRECTION_RX);\r\nnetif_carrier_off(dev);\r\nclear_bit(dev->if_port, &adapter->open_device_map);\r\nif (adapter->params.stats_update_period &&\r\n!(adapter->open_device_map & PORT_MASK)) {\r\nsmp_mb__after_atomic();\r\nspin_lock(&adapter->work_lock);\r\nspin_unlock(&adapter->work_lock);\r\ncancel_mac_stats_update(adapter);\r\n}\r\nif (!adapter->open_device_map)\r\ncxgb_down(adapter);\r\nreturn 0;\r\n}\r\nstatic struct net_device_stats *t1_get_stats(struct net_device *dev)\r\n{\r\nstruct adapter *adapter = dev->ml_priv;\r\nstruct port_info *p = &adapter->port[dev->if_port];\r\nstruct net_device_stats *ns = &dev->stats;\r\nconst struct cmac_statistics *pstats;\r\npstats = p->mac->ops->statistics_update(p->mac,\r\nMAC_STATS_UPDATE_FULL);\r\nns->tx_packets = pstats->TxUnicastFramesOK +\r\npstats->TxMulticastFramesOK + pstats->TxBroadcastFramesOK;\r\nns->rx_packets = pstats->RxUnicastFramesOK +\r\npstats->RxMulticastFramesOK + pstats->RxBroadcastFramesOK;\r\nns->tx_bytes = pstats->TxOctetsOK;\r\nns->rx_bytes = pstats->RxOctetsOK;\r\nns->tx_errors = pstats->TxLateCollisions + pstats->TxLengthErrors +\r\npstats->TxUnderrun + pstats->TxFramesAbortedDueToXSCollisions;\r\nns->rx_errors = pstats->RxDataErrors + pstats->RxJabberErrors +\r\npstats->RxFCSErrors + pstats->RxAlignErrors +\r\npstats->RxSequenceErrors + pstats->RxFrameTooLongErrors +\r\npstats->RxSymbolErrors + pstats->RxRuntErrors;\r\nns->multicast = pstats->RxMulticastFramesOK;\r\nns->collisions = pstats->TxTotalCollisions;\r\nns->rx_length_errors = pstats->RxFrameTooLongErrors +\r\npstats->RxJabberErrors;\r\nns->rx_over_errors = 0;\r\nns->rx_crc_errors = pstats->RxFCSErrors;\r\nns->rx_frame_errors = pstats->RxAlignErrors;\r\nns->rx_fifo_errors = 0;\r\nns->rx_missed_errors = 0;\r\nns->tx_aborted_errors = pstats->TxFramesAbortedDueToXSCollisions;\r\nns->tx_carrier_errors = 0;\r\nns->tx_fifo_errors = pstats->TxUnderrun;\r\nns->tx_heartbeat_errors = 0;\r\nns->tx_window_errors = pstats->TxLateCollisions;\r\nreturn ns;\r\n}\r\nstatic u32 get_msglevel(struct net_device *dev)\r\n{\r\nstruct adapter *adapter = dev->ml_priv;\r\nreturn adapter->msg_enable;\r\n}\r\nstatic void set_msglevel(struct net_device *dev, u32 val)\r\n{\r\nstruct adapter *adapter = dev->ml_priv;\r\nadapter->msg_enable = val;\r\n}\r\nstatic int get_regs_len(struct net_device *dev)\r\n{\r\nreturn T2_REGMAP_SIZE;\r\n}\r\nstatic void get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\r\n{\r\nstruct adapter *adapter = dev->ml_priv;\r\nstrlcpy(info->driver, DRV_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_VERSION, sizeof(info->version));\r\nstrlcpy(info->bus_info, pci_name(adapter->pdev),\r\nsizeof(info->bus_info));\r\n}\r\nstatic int get_sset_count(struct net_device *dev, int sset)\r\n{\r\nswitch (sset) {\r\ncase ETH_SS_STATS:\r\nreturn ARRAY_SIZE(stats_strings);\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic void get_strings(struct net_device *dev, u32 stringset, u8 *data)\r\n{\r\nif (stringset == ETH_SS_STATS)\r\nmemcpy(data, stats_strings, sizeof(stats_strings));\r\n}\r\nstatic void get_stats(struct net_device *dev, struct ethtool_stats *stats,\r\nu64 *data)\r\n{\r\nstruct adapter *adapter = dev->ml_priv;\r\nstruct cmac *mac = adapter->port[dev->if_port].mac;\r\nconst struct cmac_statistics *s;\r\nconst struct sge_intr_counts *t;\r\nstruct sge_port_stats ss;\r\ns = mac->ops->statistics_update(mac, MAC_STATS_UPDATE_FULL);\r\nt = t1_sge_get_intr_counts(adapter->sge);\r\nt1_sge_get_port_stats(adapter->sge, dev->if_port, &ss);\r\n*data++ = s->TxOctetsOK;\r\n*data++ = s->TxOctetsBad;\r\n*data++ = s->TxUnicastFramesOK;\r\n*data++ = s->TxMulticastFramesOK;\r\n*data++ = s->TxBroadcastFramesOK;\r\n*data++ = s->TxPauseFrames;\r\n*data++ = s->TxFramesWithDeferredXmissions;\r\n*data++ = s->TxLateCollisions;\r\n*data++ = s->TxTotalCollisions;\r\n*data++ = s->TxFramesAbortedDueToXSCollisions;\r\n*data++ = s->TxUnderrun;\r\n*data++ = s->TxLengthErrors;\r\n*data++ = s->TxInternalMACXmitError;\r\n*data++ = s->TxFramesWithExcessiveDeferral;\r\n*data++ = s->TxFCSErrors;\r\n*data++ = s->TxJumboFramesOK;\r\n*data++ = s->TxJumboOctetsOK;\r\n*data++ = s->RxOctetsOK;\r\n*data++ = s->RxOctetsBad;\r\n*data++ = s->RxUnicastFramesOK;\r\n*data++ = s->RxMulticastFramesOK;\r\n*data++ = s->RxBroadcastFramesOK;\r\n*data++ = s->RxPauseFrames;\r\n*data++ = s->RxFCSErrors;\r\n*data++ = s->RxAlignErrors;\r\n*data++ = s->RxSymbolErrors;\r\n*data++ = s->RxDataErrors;\r\n*data++ = s->RxSequenceErrors;\r\n*data++ = s->RxRuntErrors;\r\n*data++ = s->RxJabberErrors;\r\n*data++ = s->RxInternalMACRcvError;\r\n*data++ = s->RxInRangeLengthErrors;\r\n*data++ = s->RxOutOfRangeLengthField;\r\n*data++ = s->RxFrameTooLongErrors;\r\n*data++ = s->RxJumboFramesOK;\r\n*data++ = s->RxJumboOctetsOK;\r\n*data++ = ss.rx_cso_good;\r\n*data++ = ss.tx_cso;\r\n*data++ = ss.tx_tso;\r\n*data++ = ss.vlan_xtract;\r\n*data++ = ss.vlan_insert;\r\n*data++ = ss.tx_need_hdrroom;\r\n*data++ = t->rx_drops;\r\n*data++ = t->pure_rsps;\r\n*data++ = t->unhandled_irqs;\r\n*data++ = t->respQ_empty;\r\n*data++ = t->respQ_overflow;\r\n*data++ = t->freelistQ_empty;\r\n*data++ = t->pkt_too_big;\r\n*data++ = t->pkt_mismatch;\r\n*data++ = t->cmdQ_full[0];\r\n*data++ = t->cmdQ_full[1];\r\nif (adapter->espi) {\r\nconst struct espi_intr_counts *e;\r\ne = t1_espi_get_intr_counts(adapter->espi);\r\n*data++ = e->DIP2_parity_err;\r\n*data++ = e->DIP4_err;\r\n*data++ = e->rx_drops;\r\n*data++ = e->tx_drops;\r\n*data++ = e->rx_ovflw;\r\n*data++ = e->parity_err;\r\n}\r\n}\r\nstatic inline void reg_block_dump(struct adapter *ap, void *buf,\r\nunsigned int start, unsigned int end)\r\n{\r\nu32 *p = buf + start;\r\nfor ( ; start <= end; start += sizeof(u32))\r\n*p++ = readl(ap->regs + start);\r\n}\r\nstatic void get_regs(struct net_device *dev, struct ethtool_regs *regs,\r\nvoid *buf)\r\n{\r\nstruct adapter *ap = dev->ml_priv;\r\nregs->version = 2;\r\nmemset(buf, 0, T2_REGMAP_SIZE);\r\nreg_block_dump(ap, buf, 0, A_SG_RESPACCUTIMER);\r\nreg_block_dump(ap, buf, A_MC3_CFG, A_MC4_INT_CAUSE);\r\nreg_block_dump(ap, buf, A_TPI_ADDR, A_TPI_PAR);\r\nreg_block_dump(ap, buf, A_TP_IN_CONFIG, A_TP_TX_DROP_COUNT);\r\nreg_block_dump(ap, buf, A_RAT_ROUTE_CONTROL, A_RAT_INTR_CAUSE);\r\nreg_block_dump(ap, buf, A_CSPI_RX_AE_WM, A_CSPI_INTR_ENABLE);\r\nreg_block_dump(ap, buf, A_ESPI_SCH_TOKEN0, A_ESPI_GOSTAT);\r\nreg_block_dump(ap, buf, A_ULP_ULIMIT, A_ULP_PIO_CTRL);\r\nreg_block_dump(ap, buf, A_PL_ENABLE, A_PL_CAUSE);\r\nreg_block_dump(ap, buf, A_MC5_CONFIG, A_MC5_MASK_WRITE_CMD);\r\n}\r\nstatic int get_link_ksettings(struct net_device *dev,\r\nstruct ethtool_link_ksettings *cmd)\r\n{\r\nstruct adapter *adapter = dev->ml_priv;\r\nstruct port_info *p = &adapter->port[dev->if_port];\r\nu32 supported, advertising;\r\nsupported = p->link_config.supported;\r\nadvertising = p->link_config.advertising;\r\nif (netif_carrier_ok(dev)) {\r\ncmd->base.speed = p->link_config.speed;\r\ncmd->base.duplex = p->link_config.duplex;\r\n} else {\r\ncmd->base.speed = SPEED_UNKNOWN;\r\ncmd->base.duplex = DUPLEX_UNKNOWN;\r\n}\r\ncmd->base.port = (supported & SUPPORTED_TP) ? PORT_TP : PORT_FIBRE;\r\ncmd->base.phy_address = p->phy->mdio.prtad;\r\ncmd->base.autoneg = p->link_config.autoneg;\r\nethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,\r\nsupported);\r\nethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.advertising,\r\nadvertising);\r\nreturn 0;\r\n}\r\nstatic int speed_duplex_to_caps(int speed, int duplex)\r\n{\r\nint cap = 0;\r\nswitch (speed) {\r\ncase SPEED_10:\r\nif (duplex == DUPLEX_FULL)\r\ncap = SUPPORTED_10baseT_Full;\r\nelse\r\ncap = SUPPORTED_10baseT_Half;\r\nbreak;\r\ncase SPEED_100:\r\nif (duplex == DUPLEX_FULL)\r\ncap = SUPPORTED_100baseT_Full;\r\nelse\r\ncap = SUPPORTED_100baseT_Half;\r\nbreak;\r\ncase SPEED_1000:\r\nif (duplex == DUPLEX_FULL)\r\ncap = SUPPORTED_1000baseT_Full;\r\nelse\r\ncap = SUPPORTED_1000baseT_Half;\r\nbreak;\r\ncase SPEED_10000:\r\nif (duplex == DUPLEX_FULL)\r\ncap = SUPPORTED_10000baseT_Full;\r\n}\r\nreturn cap;\r\n}\r\nstatic int set_link_ksettings(struct net_device *dev,\r\nconst struct ethtool_link_ksettings *cmd)\r\n{\r\nstruct adapter *adapter = dev->ml_priv;\r\nstruct port_info *p = &adapter->port[dev->if_port];\r\nstruct link_config *lc = &p->link_config;\r\nu32 advertising;\r\nethtool_convert_link_mode_to_legacy_u32(&advertising,\r\ncmd->link_modes.advertising);\r\nif (!(lc->supported & SUPPORTED_Autoneg))\r\nreturn -EOPNOTSUPP;\r\nif (cmd->base.autoneg == AUTONEG_DISABLE) {\r\nu32 speed = cmd->base.speed;\r\nint cap = speed_duplex_to_caps(speed, cmd->base.duplex);\r\nif (!(lc->supported & cap) || (speed == SPEED_1000))\r\nreturn -EINVAL;\r\nlc->requested_speed = speed;\r\nlc->requested_duplex = cmd->base.duplex;\r\nlc->advertising = 0;\r\n} else {\r\nadvertising &= ADVERTISED_MASK;\r\nif (advertising & (advertising - 1))\r\nadvertising = lc->supported;\r\nadvertising &= lc->supported;\r\nif (!advertising)\r\nreturn -EINVAL;\r\nlc->requested_speed = SPEED_INVALID;\r\nlc->requested_duplex = DUPLEX_INVALID;\r\nlc->advertising = advertising | ADVERTISED_Autoneg;\r\n}\r\nlc->autoneg = cmd->base.autoneg;\r\nif (netif_running(dev))\r\nt1_link_start(p->phy, p->mac, lc);\r\nreturn 0;\r\n}\r\nstatic void get_pauseparam(struct net_device *dev,\r\nstruct ethtool_pauseparam *epause)\r\n{\r\nstruct adapter *adapter = dev->ml_priv;\r\nstruct port_info *p = &adapter->port[dev->if_port];\r\nepause->autoneg = (p->link_config.requested_fc & PAUSE_AUTONEG) != 0;\r\nepause->rx_pause = (p->link_config.fc & PAUSE_RX) != 0;\r\nepause->tx_pause = (p->link_config.fc & PAUSE_TX) != 0;\r\n}\r\nstatic int set_pauseparam(struct net_device *dev,\r\nstruct ethtool_pauseparam *epause)\r\n{\r\nstruct adapter *adapter = dev->ml_priv;\r\nstruct port_info *p = &adapter->port[dev->if_port];\r\nstruct link_config *lc = &p->link_config;\r\nif (epause->autoneg == AUTONEG_DISABLE)\r\nlc->requested_fc = 0;\r\nelse if (lc->supported & SUPPORTED_Autoneg)\r\nlc->requested_fc = PAUSE_AUTONEG;\r\nelse\r\nreturn -EINVAL;\r\nif (epause->rx_pause)\r\nlc->requested_fc |= PAUSE_RX;\r\nif (epause->tx_pause)\r\nlc->requested_fc |= PAUSE_TX;\r\nif (lc->autoneg == AUTONEG_ENABLE) {\r\nif (netif_running(dev))\r\nt1_link_start(p->phy, p->mac, lc);\r\n} else {\r\nlc->fc = lc->requested_fc & (PAUSE_RX | PAUSE_TX);\r\nif (netif_running(dev))\r\np->mac->ops->set_speed_duplex_fc(p->mac, -1, -1,\r\nlc->fc);\r\n}\r\nreturn 0;\r\n}\r\nstatic void get_sge_param(struct net_device *dev, struct ethtool_ringparam *e)\r\n{\r\nstruct adapter *adapter = dev->ml_priv;\r\nint jumbo_fl = t1_is_T1B(adapter) ? 1 : 0;\r\ne->rx_max_pending = MAX_RX_BUFFERS;\r\ne->rx_jumbo_max_pending = MAX_RX_JUMBO_BUFFERS;\r\ne->tx_max_pending = MAX_CMDQ_ENTRIES;\r\ne->rx_pending = adapter->params.sge.freelQ_size[!jumbo_fl];\r\ne->rx_jumbo_pending = adapter->params.sge.freelQ_size[jumbo_fl];\r\ne->tx_pending = adapter->params.sge.cmdQ_size[0];\r\n}\r\nstatic int set_sge_param(struct net_device *dev, struct ethtool_ringparam *e)\r\n{\r\nstruct adapter *adapter = dev->ml_priv;\r\nint jumbo_fl = t1_is_T1B(adapter) ? 1 : 0;\r\nif (e->rx_pending > MAX_RX_BUFFERS || e->rx_mini_pending ||\r\ne->rx_jumbo_pending > MAX_RX_JUMBO_BUFFERS ||\r\ne->tx_pending > MAX_CMDQ_ENTRIES ||\r\ne->rx_pending < MIN_FL_ENTRIES ||\r\ne->rx_jumbo_pending < MIN_FL_ENTRIES ||\r\ne->tx_pending < (adapter->params.nports + 1) * (MAX_SKB_FRAGS + 1))\r\nreturn -EINVAL;\r\nif (adapter->flags & FULL_INIT_DONE)\r\nreturn -EBUSY;\r\nadapter->params.sge.freelQ_size[!jumbo_fl] = e->rx_pending;\r\nadapter->params.sge.freelQ_size[jumbo_fl] = e->rx_jumbo_pending;\r\nadapter->params.sge.cmdQ_size[0] = e->tx_pending;\r\nadapter->params.sge.cmdQ_size[1] = e->tx_pending > MAX_CMDQ1_ENTRIES ?\r\nMAX_CMDQ1_ENTRIES : e->tx_pending;\r\nreturn 0;\r\n}\r\nstatic int set_coalesce(struct net_device *dev, struct ethtool_coalesce *c)\r\n{\r\nstruct adapter *adapter = dev->ml_priv;\r\nadapter->params.sge.rx_coalesce_usecs = c->rx_coalesce_usecs;\r\nadapter->params.sge.coalesce_enable = c->use_adaptive_rx_coalesce;\r\nadapter->params.sge.sample_interval_usecs = c->rate_sample_interval;\r\nt1_sge_set_coalesce_params(adapter->sge, &adapter->params.sge);\r\nreturn 0;\r\n}\r\nstatic int get_coalesce(struct net_device *dev, struct ethtool_coalesce *c)\r\n{\r\nstruct adapter *adapter = dev->ml_priv;\r\nc->rx_coalesce_usecs = adapter->params.sge.rx_coalesce_usecs;\r\nc->rate_sample_interval = adapter->params.sge.sample_interval_usecs;\r\nc->use_adaptive_rx_coalesce = adapter->params.sge.coalesce_enable;\r\nreturn 0;\r\n}\r\nstatic int get_eeprom_len(struct net_device *dev)\r\n{\r\nstruct adapter *adapter = dev->ml_priv;\r\nreturn t1_is_asic(adapter) ? EEPROM_SIZE : 0;\r\n}\r\nstatic int get_eeprom(struct net_device *dev, struct ethtool_eeprom *e,\r\nu8 *data)\r\n{\r\nint i;\r\nu8 buf[EEPROM_SIZE] __attribute__((aligned(4)));\r\nstruct adapter *adapter = dev->ml_priv;\r\ne->magic = EEPROM_MAGIC(adapter);\r\nfor (i = e->offset & ~3; i < e->offset + e->len; i += sizeof(u32))\r\nt1_seeprom_read(adapter, i, (__le32 *)&buf[i]);\r\nmemcpy(data, buf + e->offset, e->len);\r\nreturn 0;\r\n}\r\nstatic int t1_ioctl(struct net_device *dev, struct ifreq *req, int cmd)\r\n{\r\nstruct adapter *adapter = dev->ml_priv;\r\nstruct mdio_if_info *mdio = &adapter->port[dev->if_port].phy->mdio;\r\nreturn mdio_mii_ioctl(mdio, if_mii(req), cmd);\r\n}\r\nstatic int t1_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nint ret;\r\nstruct adapter *adapter = dev->ml_priv;\r\nstruct cmac *mac = adapter->port[dev->if_port].mac;\r\nif (!mac->ops->set_mtu)\r\nreturn -EOPNOTSUPP;\r\nif ((ret = mac->ops->set_mtu(mac, new_mtu)))\r\nreturn ret;\r\ndev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nstatic int t1_set_mac_addr(struct net_device *dev, void *p)\r\n{\r\nstruct adapter *adapter = dev->ml_priv;\r\nstruct cmac *mac = adapter->port[dev->if_port].mac;\r\nstruct sockaddr *addr = p;\r\nif (!mac->ops->macaddress_set)\r\nreturn -EOPNOTSUPP;\r\nmemcpy(dev->dev_addr, addr->sa_data, dev->addr_len);\r\nmac->ops->macaddress_set(mac, dev->dev_addr);\r\nreturn 0;\r\n}\r\nstatic netdev_features_t t1_fix_features(struct net_device *dev,\r\nnetdev_features_t features)\r\n{\r\nif (features & NETIF_F_HW_VLAN_CTAG_RX)\r\nfeatures |= NETIF_F_HW_VLAN_CTAG_TX;\r\nelse\r\nfeatures &= ~NETIF_F_HW_VLAN_CTAG_TX;\r\nreturn features;\r\n}\r\nstatic int t1_set_features(struct net_device *dev, netdev_features_t features)\r\n{\r\nnetdev_features_t changed = dev->features ^ features;\r\nstruct adapter *adapter = dev->ml_priv;\r\nif (changed & NETIF_F_HW_VLAN_CTAG_RX)\r\nt1_vlan_mode(adapter, features);\r\nreturn 0;\r\n}\r\nstatic void t1_netpoll(struct net_device *dev)\r\n{\r\nunsigned long flags;\r\nstruct adapter *adapter = dev->ml_priv;\r\nlocal_irq_save(flags);\r\nt1_interrupt(adapter->pdev->irq, adapter);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void mac_stats_task(struct work_struct *work)\r\n{\r\nint i;\r\nstruct adapter *adapter =\r\ncontainer_of(work, struct adapter, stats_update_task.work);\r\nfor_each_port(adapter, i) {\r\nstruct port_info *p = &adapter->port[i];\r\nif (netif_running(p->dev))\r\np->mac->ops->statistics_update(p->mac,\r\nMAC_STATS_UPDATE_FAST);\r\n}\r\nspin_lock(&adapter->work_lock);\r\nif (adapter->open_device_map & PORT_MASK)\r\nschedule_mac_stats_update(adapter,\r\nadapter->params.stats_update_period);\r\nspin_unlock(&adapter->work_lock);\r\n}\r\nstatic void ext_intr_task(struct work_struct *work)\r\n{\r\nstruct adapter *adapter =\r\ncontainer_of(work, struct adapter, ext_intr_handler_task);\r\nt1_elmer0_ext_intr_handler(adapter);\r\nspin_lock_irq(&adapter->async_lock);\r\nadapter->slow_intr_mask |= F_PL_INTR_EXT;\r\nwritel(F_PL_INTR_EXT, adapter->regs + A_PL_CAUSE);\r\nwritel(adapter->slow_intr_mask | F_PL_INTR_SGE_DATA,\r\nadapter->regs + A_PL_ENABLE);\r\nspin_unlock_irq(&adapter->async_lock);\r\n}\r\nvoid t1_elmer0_ext_intr(struct adapter *adapter)\r\n{\r\nadapter->slow_intr_mask &= ~F_PL_INTR_EXT;\r\nwritel(adapter->slow_intr_mask | F_PL_INTR_SGE_DATA,\r\nadapter->regs + A_PL_ENABLE);\r\nschedule_work(&adapter->ext_intr_handler_task);\r\n}\r\nvoid t1_fatal_err(struct adapter *adapter)\r\n{\r\nif (adapter->flags & FULL_INIT_DONE) {\r\nt1_sge_stop(adapter->sge);\r\nt1_interrupts_disable(adapter);\r\n}\r\npr_alert("%s: encountered fatal error, operation suspended\n",\r\nadapter->name);\r\n}\r\nstatic int init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nint i, err, pci_using_dac = 0;\r\nunsigned long mmio_start, mmio_len;\r\nconst struct board_info *bi;\r\nstruct adapter *adapter = NULL;\r\nstruct port_info *pi;\r\npr_info_once("%s - version %s\n", DRV_DESCRIPTION, DRV_VERSION);\r\nerr = pci_enable_device(pdev);\r\nif (err)\r\nreturn err;\r\nif (!(pci_resource_flags(pdev, 0) & IORESOURCE_MEM)) {\r\npr_err("%s: cannot find PCI device memory base address\n",\r\npci_name(pdev));\r\nerr = -ENODEV;\r\ngoto out_disable_pdev;\r\n}\r\nif (!pci_set_dma_mask(pdev, DMA_BIT_MASK(64))) {\r\npci_using_dac = 1;\r\nif (pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(64))) {\r\npr_err("%s: unable to obtain 64-bit DMA for "\r\n"consistent allocations\n", pci_name(pdev));\r\nerr = -ENODEV;\r\ngoto out_disable_pdev;\r\n}\r\n} else if ((err = pci_set_dma_mask(pdev, DMA_BIT_MASK(32))) != 0) {\r\npr_err("%s: no usable DMA configuration\n", pci_name(pdev));\r\ngoto out_disable_pdev;\r\n}\r\nerr = pci_request_regions(pdev, DRV_NAME);\r\nif (err) {\r\npr_err("%s: cannot obtain PCI resources\n", pci_name(pdev));\r\ngoto out_disable_pdev;\r\n}\r\npci_set_master(pdev);\r\nmmio_start = pci_resource_start(pdev, 0);\r\nmmio_len = pci_resource_len(pdev, 0);\r\nbi = t1_get_board_info(ent->driver_data);\r\nfor (i = 0; i < bi->port_number; ++i) {\r\nstruct net_device *netdev;\r\nnetdev = alloc_etherdev(adapter ? 0 : sizeof(*adapter));\r\nif (!netdev) {\r\nerr = -ENOMEM;\r\ngoto out_free_dev;\r\n}\r\nSET_NETDEV_DEV(netdev, &pdev->dev);\r\nif (!adapter) {\r\nadapter = netdev_priv(netdev);\r\nadapter->pdev = pdev;\r\nadapter->port[0].dev = netdev;\r\nadapter->regs = ioremap(mmio_start, mmio_len);\r\nif (!adapter->regs) {\r\npr_err("%s: cannot map device registers\n",\r\npci_name(pdev));\r\nerr = -ENOMEM;\r\ngoto out_free_dev;\r\n}\r\nif (t1_get_board_rev(adapter, bi, &adapter->params)) {\r\nerr = -ENODEV;\r\ngoto out_free_dev;\r\n}\r\nadapter->name = pci_name(pdev);\r\nadapter->msg_enable = dflt_msg_enable;\r\nadapter->mmio_len = mmio_len;\r\nspin_lock_init(&adapter->tpi_lock);\r\nspin_lock_init(&adapter->work_lock);\r\nspin_lock_init(&adapter->async_lock);\r\nspin_lock_init(&adapter->mac_lock);\r\nINIT_WORK(&adapter->ext_intr_handler_task,\r\next_intr_task);\r\nINIT_DELAYED_WORK(&adapter->stats_update_task,\r\nmac_stats_task);\r\npci_set_drvdata(pdev, netdev);\r\n}\r\npi = &adapter->port[i];\r\npi->dev = netdev;\r\nnetif_carrier_off(netdev);\r\nnetdev->irq = pdev->irq;\r\nnetdev->if_port = i;\r\nnetdev->mem_start = mmio_start;\r\nnetdev->mem_end = mmio_start + mmio_len - 1;\r\nnetdev->ml_priv = adapter;\r\nnetdev->hw_features |= NETIF_F_SG | NETIF_F_IP_CSUM |\r\nNETIF_F_RXCSUM;\r\nnetdev->features |= NETIF_F_SG | NETIF_F_IP_CSUM |\r\nNETIF_F_RXCSUM | NETIF_F_LLTX;\r\nif (pci_using_dac)\r\nnetdev->features |= NETIF_F_HIGHDMA;\r\nif (vlan_tso_capable(adapter)) {\r\nnetdev->features |=\r\nNETIF_F_HW_VLAN_CTAG_TX |\r\nNETIF_F_HW_VLAN_CTAG_RX;\r\nnetdev->hw_features |= NETIF_F_HW_VLAN_CTAG_RX;\r\nif (!(is_T2(adapter)) || bi->port_number != 4) {\r\nnetdev->hw_features |= NETIF_F_TSO;\r\nnetdev->features |= NETIF_F_TSO;\r\n}\r\n}\r\nnetdev->netdev_ops = &cxgb_netdev_ops;\r\nnetdev->hard_header_len += (netdev->hw_features & NETIF_F_TSO) ?\r\nsizeof(struct cpl_tx_pkt_lso) : sizeof(struct cpl_tx_pkt);\r\nnetif_napi_add(netdev, &adapter->napi, t1_poll, 64);\r\nnetdev->ethtool_ops = &t1_ethtool_ops;\r\nswitch (bi->board) {\r\ncase CHBT_BOARD_CHT110:\r\ncase CHBT_BOARD_N110:\r\ncase CHBT_BOARD_N210:\r\ncase CHBT_BOARD_CHT210:\r\nnetdev->max_mtu = PM3393_MAX_FRAME_SIZE -\r\n(ETH_HLEN + ETH_FCS_LEN);\r\nbreak;\r\ncase CHBT_BOARD_CHN204:\r\nnetdev->max_mtu = VSC7326_MAX_MTU;\r\nbreak;\r\ndefault:\r\nnetdev->max_mtu = ETH_DATA_LEN;\r\nbreak;\r\n}\r\n}\r\nif (t1_init_sw_modules(adapter, bi) < 0) {\r\nerr = -ENODEV;\r\ngoto out_free_dev;\r\n}\r\nfor (i = 0; i < bi->port_number; ++i) {\r\nerr = register_netdev(adapter->port[i].dev);\r\nif (err)\r\npr_warn("%s: cannot register net device %s, skipping\n",\r\npci_name(pdev), adapter->port[i].dev->name);\r\nelse {\r\nif (!adapter->registered_device_map)\r\nadapter->name = adapter->port[i].dev->name;\r\n__set_bit(i, &adapter->registered_device_map);\r\n}\r\n}\r\nif (!adapter->registered_device_map) {\r\npr_err("%s: could not register any net devices\n",\r\npci_name(pdev));\r\ngoto out_release_adapter_res;\r\n}\r\npr_info("%s: %s (rev %d), %s %dMHz/%d-bit\n",\r\nadapter->name, bi->desc, adapter->params.chip_revision,\r\nadapter->params.pci.is_pcix ? "PCIX" : "PCI",\r\nadapter->params.pci.speed, adapter->params.pci.width);\r\nif (t1powersave)\r\nadapter->t1powersave = LCLOCK;\r\nelse\r\nadapter->t1powersave = HCLOCK;\r\nif (t1_is_T1B(adapter))\r\nt1_clock(adapter, t1powersave);\r\nreturn 0;\r\nout_release_adapter_res:\r\nt1_free_sw_modules(adapter);\r\nout_free_dev:\r\nif (adapter) {\r\nif (adapter->regs)\r\niounmap(adapter->regs);\r\nfor (i = bi->port_number - 1; i >= 0; --i)\r\nif (adapter->port[i].dev)\r\nfree_netdev(adapter->port[i].dev);\r\n}\r\npci_release_regions(pdev);\r\nout_disable_pdev:\r\npci_disable_device(pdev);\r\nreturn err;\r\n}\r\nstatic void bit_bang(struct adapter *adapter, int bitdata, int nbits)\r\n{\r\nint data;\r\nint i;\r\nu32 val;\r\nenum {\r\nS_CLOCK = 1 << 3,\r\nS_DATA = 1 << 4\r\n};\r\nfor (i = (nbits - 1); i > -1; i--) {\r\nudelay(50);\r\ndata = ((bitdata >> i) & 0x1);\r\n__t1_tpi_read(adapter, A_ELMER0_GPO, &val);\r\nif (data)\r\nval |= S_DATA;\r\nelse\r\nval &= ~S_DATA;\r\nudelay(50);\r\nval &= ~S_CLOCK;\r\n__t1_tpi_write(adapter, A_ELMER0_GPO, val);\r\nudelay(50);\r\nval |= S_CLOCK;\r\n__t1_tpi_write(adapter, A_ELMER0_GPO, val);\r\n}\r\n}\r\nstatic int t1_clock(struct adapter *adapter, int mode)\r\n{\r\nu32 val;\r\nint M_CORE_VAL;\r\nint M_MEM_VAL;\r\nenum {\r\nM_CORE_BITS = 9,\r\nT_CORE_VAL = 0,\r\nT_CORE_BITS = 2,\r\nN_CORE_VAL = 0,\r\nN_CORE_BITS = 2,\r\nM_MEM_BITS = 9,\r\nT_MEM_VAL = 0,\r\nT_MEM_BITS = 2,\r\nN_MEM_VAL = 0,\r\nN_MEM_BITS = 2,\r\nNP_LOAD = 1 << 17,\r\nS_LOAD_MEM = 1 << 5,\r\nS_LOAD_CORE = 1 << 6,\r\nS_CLOCK = 1 << 3\r\n};\r\nif (!t1_is_T1B(adapter))\r\nreturn -ENODEV;\r\nif (mode & 2)\r\nreturn 0;\r\nif ((adapter->t1powersave & 1) == (mode & 1))\r\nreturn -EALREADY;\r\nif ((mode & 1) == HCLOCK) {\r\nM_CORE_VAL = 0x14;\r\nM_MEM_VAL = 0x18;\r\nadapter->t1powersave = HCLOCK;\r\n} else {\r\nM_CORE_VAL = 0xe;\r\nM_MEM_VAL = 0x10;\r\nadapter->t1powersave = LCLOCK;\r\n}\r\nspin_lock(&adapter->tpi_lock);\r\n__t1_tpi_read(adapter, A_ELMER0_GPO, &val);\r\nval |= NP_LOAD;\r\nudelay(50);\r\n__t1_tpi_write(adapter, A_ELMER0_GPO, val);\r\nudelay(50);\r\n__t1_tpi_read(adapter, A_ELMER0_GPO, &val);\r\nval &= ~S_LOAD_CORE;\r\nval &= ~S_CLOCK;\r\n__t1_tpi_write(adapter, A_ELMER0_GPO, val);\r\nudelay(50);\r\nbit_bang(adapter, T_CORE_VAL, T_CORE_BITS);\r\nbit_bang(adapter, N_CORE_VAL, N_CORE_BITS);\r\nbit_bang(adapter, M_CORE_VAL, M_CORE_BITS);\r\nudelay(50);\r\n__t1_tpi_read(adapter, A_ELMER0_GPO, &val);\r\nval |= S_LOAD_CORE;\r\nudelay(50);\r\n__t1_tpi_write(adapter, A_ELMER0_GPO, val);\r\nudelay(50);\r\n__t1_tpi_read(adapter, A_ELMER0_GPO, &val);\r\nval &= ~S_LOAD_CORE;\r\nudelay(50);\r\n__t1_tpi_write(adapter, A_ELMER0_GPO, val);\r\nudelay(50);\r\n__t1_tpi_read(adapter, A_ELMER0_GPO, &val);\r\nval |= NP_LOAD;\r\nudelay(50);\r\n__t1_tpi_write(adapter, A_ELMER0_GPO, val);\r\nudelay(50);\r\n__t1_tpi_read(adapter, A_ELMER0_GPO, &val);\r\nval &= ~S_LOAD_MEM;\r\nval &= ~S_CLOCK;\r\nudelay(50);\r\n__t1_tpi_write(adapter, A_ELMER0_GPO, val);\r\nudelay(50);\r\nbit_bang(adapter, T_MEM_VAL, T_MEM_BITS);\r\nbit_bang(adapter, N_MEM_VAL, N_MEM_BITS);\r\nbit_bang(adapter, M_MEM_VAL, M_MEM_BITS);\r\nudelay(50);\r\n__t1_tpi_read(adapter, A_ELMER0_GPO, &val);\r\nval |= S_LOAD_MEM;\r\nudelay(50);\r\n__t1_tpi_write(adapter, A_ELMER0_GPO, val);\r\nudelay(50);\r\n__t1_tpi_read(adapter, A_ELMER0_GPO, &val);\r\nval &= ~S_LOAD_MEM;\r\nudelay(50);\r\n__t1_tpi_write(adapter, A_ELMER0_GPO, val);\r\nspin_unlock(&adapter->tpi_lock);\r\nreturn 0;\r\n}\r\nstatic inline void t1_sw_reset(struct pci_dev *pdev)\r\n{\r\npci_write_config_dword(pdev, A_PCICFG_PM_CSR, 3);\r\npci_write_config_dword(pdev, A_PCICFG_PM_CSR, 0);\r\n}\r\nstatic void remove_one(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct adapter *adapter = dev->ml_priv;\r\nint i;\r\nfor_each_port(adapter, i) {\r\nif (test_bit(i, &adapter->registered_device_map))\r\nunregister_netdev(adapter->port[i].dev);\r\n}\r\nt1_free_sw_modules(adapter);\r\niounmap(adapter->regs);\r\nwhile (--i >= 0) {\r\nif (adapter->port[i].dev)\r\nfree_netdev(adapter->port[i].dev);\r\n}\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\nt1_sw_reset(pdev);\r\n}
