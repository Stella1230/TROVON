static acpi_status setup_res(struct acpi_resource *acpi_res, void *data)\r\n{\r\nstruct resource *res = data;\r\nstruct resource_win win;\r\nmemset(&win, 0, sizeof(win));\r\nres->flags = 0;\r\nif (acpi_dev_filter_resource_type(acpi_res, IORESOURCE_MEM))\r\nreturn AE_OK;\r\nif (!acpi_dev_resource_memory(acpi_res, res)) {\r\nif (acpi_dev_resource_address_space(acpi_res, &win) ||\r\nacpi_dev_resource_ext_address_space(acpi_res, &win))\r\n*res = win.res;\r\n}\r\nif ((res->flags & IORESOURCE_PREFETCH) ||\r\n(res->flags & IORESOURCE_DISABLED))\r\nres->flags = 0;\r\nreturn AE_CTRL_TERMINATE;\r\n}\r\nstatic bool acpi_is_ioapic(acpi_handle handle, char **type)\r\n{\r\nacpi_status status;\r\nstruct acpi_device_info *info;\r\nchar *hid = NULL;\r\nbool match = false;\r\nif (!acpi_has_method(handle, "_GSB"))\r\nreturn false;\r\nstatus = acpi_get_object_info(handle, &info);\r\nif (ACPI_SUCCESS(status)) {\r\nif (info->valid & ACPI_VALID_HID)\r\nhid = info->hardware_id.string;\r\nif (hid) {\r\nif (strcmp(hid, "ACPI0009") == 0) {\r\n*type = "IOxAPIC";\r\nmatch = true;\r\n} else if (strcmp(hid, "ACPI000A") == 0) {\r\n*type = "IOAPIC";\r\nmatch = true;\r\n}\r\n}\r\nkfree(info);\r\n}\r\nreturn match;\r\n}\r\nstatic acpi_status handle_ioapic_add(acpi_handle handle, u32 lvl,\r\nvoid *context, void **rv)\r\n{\r\nacpi_status status;\r\nunsigned long long gsi_base;\r\nstruct acpi_pci_ioapic *ioapic;\r\nstruct pci_dev *dev = NULL;\r\nstruct resource *res = NULL, *pci_res = NULL, *crs_res;\r\nchar *type = NULL;\r\nif (!acpi_is_ioapic(handle, &type))\r\nreturn AE_OK;\r\nmutex_lock(&ioapic_list_lock);\r\nlist_for_each_entry(ioapic, &ioapic_list, list)\r\nif (ioapic->handle == handle) {\r\nmutex_unlock(&ioapic_list_lock);\r\nreturn AE_OK;\r\n}\r\nstatus = acpi_evaluate_integer(handle, "_GSB", NULL, &gsi_base);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_handle_warn(handle, "failed to evaluate _GSB method\n");\r\ngoto exit;\r\n}\r\nioapic = kzalloc(sizeof(*ioapic), GFP_KERNEL);\r\nif (!ioapic) {\r\npr_err("cannot allocate memory for new IOAPIC\n");\r\ngoto exit;\r\n} else {\r\nioapic->root_handle = (acpi_handle)context;\r\nioapic->handle = handle;\r\nioapic->gsi_base = (u32)gsi_base;\r\nINIT_LIST_HEAD(&ioapic->list);\r\n}\r\nif (acpi_ioapic_registered(handle, (u32)gsi_base))\r\ngoto done;\r\ndev = acpi_get_pci_dev(handle);\r\nif (dev && pci_resource_len(dev, 0)) {\r\nif (pci_enable_device(dev) < 0)\r\ngoto exit_put;\r\npci_set_master(dev);\r\nif (pci_request_region(dev, 0, type))\r\ngoto exit_disable;\r\npci_res = &dev->resource[0];\r\nioapic->pdev = dev;\r\n} else {\r\npci_dev_put(dev);\r\ndev = NULL;\r\n}\r\ncrs_res = &ioapic->res;\r\nacpi_walk_resources(handle, METHOD_NAME__CRS, setup_res, crs_res);\r\ncrs_res->name = type;\r\ncrs_res->flags |= IORESOURCE_BUSY;\r\nif (crs_res->flags == 0) {\r\nacpi_handle_warn(handle, "failed to get resource\n");\r\ngoto exit_release;\r\n} else if (insert_resource(&iomem_resource, crs_res)) {\r\nacpi_handle_warn(handle, "failed to insert resource\n");\r\ngoto exit_release;\r\n}\r\nres = pci_res;\r\nif (!res || !res->flags)\r\nres = crs_res;\r\nif (acpi_register_ioapic(handle, res->start, (u32)gsi_base)) {\r\nacpi_handle_warn(handle, "failed to register IOAPIC\n");\r\ngoto exit_release;\r\n}\r\ndone:\r\nlist_add(&ioapic->list, &ioapic_list);\r\nmutex_unlock(&ioapic_list_lock);\r\nif (dev)\r\ndev_info(&dev->dev, "%s at %pR, GSI %u\n",\r\ntype, res, (u32)gsi_base);\r\nelse\r\nacpi_handle_info(handle, "%s at %pR, GSI %u\n",\r\ntype, res, (u32)gsi_base);\r\nreturn AE_OK;\r\nexit_release:\r\nif (dev)\r\npci_release_region(dev, 0);\r\nif (ioapic->res.flags && ioapic->res.parent)\r\nrelease_resource(&ioapic->res);\r\nexit_disable:\r\nif (dev)\r\npci_disable_device(dev);\r\nexit_put:\r\npci_dev_put(dev);\r\nkfree(ioapic);\r\nexit:\r\nmutex_unlock(&ioapic_list_lock);\r\n*(acpi_status *)rv = AE_ERROR;\r\nreturn AE_OK;\r\n}\r\nint acpi_ioapic_add(acpi_handle root_handle)\r\n{\r\nacpi_status status, retval = AE_OK;\r\nstatus = acpi_walk_namespace(ACPI_TYPE_DEVICE, root_handle,\r\nUINT_MAX, handle_ioapic_add, NULL,\r\nroot_handle, (void **)&retval);\r\nreturn ACPI_SUCCESS(status) && ACPI_SUCCESS(retval) ? 0 : -ENODEV;\r\n}\r\nvoid pci_ioapic_remove(struct acpi_pci_root *root)\r\n{\r\nstruct acpi_pci_ioapic *ioapic, *tmp;\r\nmutex_lock(&ioapic_list_lock);\r\nlist_for_each_entry_safe(ioapic, tmp, &ioapic_list, list) {\r\nif (root->device->handle != ioapic->root_handle)\r\ncontinue;\r\nif (ioapic->pdev) {\r\npci_release_region(ioapic->pdev, 0);\r\npci_disable_device(ioapic->pdev);\r\npci_dev_put(ioapic->pdev);\r\n}\r\n}\r\nmutex_unlock(&ioapic_list_lock);\r\n}\r\nint acpi_ioapic_remove(struct acpi_pci_root *root)\r\n{\r\nint retval = 0;\r\nstruct acpi_pci_ioapic *ioapic, *tmp;\r\nmutex_lock(&ioapic_list_lock);\r\nlist_for_each_entry_safe(ioapic, tmp, &ioapic_list, list) {\r\nif (root->device->handle != ioapic->root_handle)\r\ncontinue;\r\nif (acpi_unregister_ioapic(ioapic->handle, ioapic->gsi_base))\r\nretval = -EBUSY;\r\nif (ioapic->res.flags && ioapic->res.parent)\r\nrelease_resource(&ioapic->res);\r\nlist_del(&ioapic->list);\r\nkfree(ioapic);\r\n}\r\nmutex_unlock(&ioapic_list_lock);\r\nreturn retval;\r\n}
