static void efi_free_all_buff_pages(struct capsule_info *cap_info)\r\n{\r\nwhile (cap_info->index > 0)\r\n__free_page(phys_to_page(cap_info->pages[--cap_info->index]));\r\ncap_info->index = NO_FURTHER_WRITE_ACTION;\r\n}\r\nint __efi_capsule_setup_info(struct capsule_info *cap_info)\r\n{\r\nsize_t pages_needed;\r\nint ret;\r\nvoid *temp_page;\r\npages_needed = ALIGN(cap_info->total_size, PAGE_SIZE) / PAGE_SIZE;\r\nif (pages_needed == 0) {\r\npr_err("invalid capsule size");\r\nreturn -EINVAL;\r\n}\r\nret = efi_capsule_supported(cap_info->header.guid,\r\ncap_info->header.flags,\r\ncap_info->header.imagesize,\r\n&cap_info->reset_type);\r\nif (ret) {\r\npr_err("capsule not supported\n");\r\nreturn ret;\r\n}\r\ntemp_page = krealloc(cap_info->pages,\r\npages_needed * sizeof(void *),\r\nGFP_KERNEL | __GFP_ZERO);\r\nif (!temp_page)\r\nreturn -ENOMEM;\r\ncap_info->pages = temp_page;\r\nreturn 0;\r\n}\r\nint __weak efi_capsule_setup_info(struct capsule_info *cap_info, void *kbuff,\r\nsize_t hdr_bytes)\r\n{\r\nif (hdr_bytes < sizeof(efi_capsule_header_t))\r\nreturn 0;\r\nmemcpy(&cap_info->header, kbuff, sizeof(cap_info->header));\r\ncap_info->total_size = cap_info->header.imagesize;\r\nreturn __efi_capsule_setup_info(cap_info);\r\n}\r\nstatic ssize_t efi_capsule_submit_update(struct capsule_info *cap_info)\r\n{\r\nint ret;\r\nret = efi_capsule_update(&cap_info->header, cap_info->pages);\r\nif (ret) {\r\npr_err("capsule update failed\n");\r\nreturn ret;\r\n}\r\ncap_info->index = NO_FURTHER_WRITE_ACTION;\r\npr_info("Successfully upload capsule file with reboot type '%s'\n",\r\n!cap_info->reset_type ? "RESET_COLD" :\r\ncap_info->reset_type == 1 ? "RESET_WARM" :\r\n"RESET_SHUTDOWN");\r\nreturn 0;\r\n}\r\nstatic ssize_t efi_capsule_write(struct file *file, const char __user *buff,\r\nsize_t count, loff_t *offp)\r\n{\r\nint ret = 0;\r\nstruct capsule_info *cap_info = file->private_data;\r\nstruct page *page;\r\nvoid *kbuff = NULL;\r\nsize_t write_byte;\r\nif (count == 0)\r\nreturn 0;\r\nif (cap_info->index < 0)\r\nreturn -EIO;\r\nif (!cap_info->page_bytes_remain) {\r\npage = alloc_page(GFP_KERNEL);\r\nif (!page) {\r\nret = -ENOMEM;\r\ngoto failed;\r\n}\r\ncap_info->pages[cap_info->index++] = page_to_phys(page);\r\ncap_info->page_bytes_remain = PAGE_SIZE;\r\n} else {\r\npage = phys_to_page(cap_info->pages[cap_info->index - 1]);\r\n}\r\nkbuff = kmap(page);\r\nkbuff += PAGE_SIZE - cap_info->page_bytes_remain;\r\nwrite_byte = min_t(size_t, count, cap_info->page_bytes_remain);\r\nif (copy_from_user(kbuff, buff, write_byte)) {\r\nret = -EFAULT;\r\ngoto fail_unmap;\r\n}\r\ncap_info->page_bytes_remain -= write_byte;\r\nif (cap_info->header.headersize == 0) {\r\nret = efi_capsule_setup_info(cap_info, kbuff - cap_info->count,\r\ncap_info->count + write_byte);\r\nif (ret)\r\ngoto fail_unmap;\r\n}\r\ncap_info->count += write_byte;\r\nkunmap(page);\r\nif (cap_info->header.headersize > 0 &&\r\ncap_info->count >= cap_info->total_size) {\r\nif (cap_info->count > cap_info->total_size) {\r\npr_err("capsule upload size exceeded header defined size\n");\r\nret = -EINVAL;\r\ngoto failed;\r\n}\r\nret = efi_capsule_submit_update(cap_info);\r\nif (ret)\r\ngoto failed;\r\n}\r\nreturn write_byte;\r\nfail_unmap:\r\nkunmap(page);\r\nfailed:\r\nefi_free_all_buff_pages(cap_info);\r\nreturn ret;\r\n}\r\nstatic int efi_capsule_flush(struct file *file, fl_owner_t id)\r\n{\r\nint ret = 0;\r\nstruct capsule_info *cap_info = file->private_data;\r\nif (cap_info->index > 0) {\r\npr_err("capsule upload not complete\n");\r\nefi_free_all_buff_pages(cap_info);\r\nret = -ECANCELED;\r\n}\r\nreturn ret;\r\n}\r\nstatic int efi_capsule_release(struct inode *inode, struct file *file)\r\n{\r\nstruct capsule_info *cap_info = file->private_data;\r\nkfree(cap_info->pages);\r\nkfree(file->private_data);\r\nfile->private_data = NULL;\r\nreturn 0;\r\n}\r\nstatic int efi_capsule_open(struct inode *inode, struct file *file)\r\n{\r\nstruct capsule_info *cap_info;\r\ncap_info = kzalloc(sizeof(*cap_info), GFP_KERNEL);\r\nif (!cap_info)\r\nreturn -ENOMEM;\r\ncap_info->pages = kzalloc(sizeof(void *), GFP_KERNEL);\r\nif (!cap_info->pages) {\r\nkfree(cap_info);\r\nreturn -ENOMEM;\r\n}\r\nfile->private_data = cap_info;\r\nreturn 0;\r\n}\r\nstatic int __init efi_capsule_loader_init(void)\r\n{\r\nint ret;\r\nif (!efi_enabled(EFI_RUNTIME_SERVICES))\r\nreturn -ENODEV;\r\nret = misc_register(&efi_capsule_misc);\r\nif (ret)\r\npr_err("Unable to register capsule loader device\n");\r\nreturn ret;\r\n}\r\nstatic void __exit efi_capsule_loader_exit(void)\r\n{\r\nmisc_deregister(&efi_capsule_misc);\r\n}
