static void venus_set_state(struct venus_hfi_device *hdev,\r\nenum venus_state state)\r\n{\r\nmutex_lock(&hdev->lock);\r\nhdev->state = state;\r\nmutex_unlock(&hdev->lock);\r\n}\r\nstatic bool venus_is_valid_state(struct venus_hfi_device *hdev)\r\n{\r\nreturn hdev->state != VENUS_STATE_DEINIT;\r\n}\r\nstatic void venus_dump_packet(struct venus_hfi_device *hdev, const void *packet)\r\n{\r\nsize_t pkt_size = *(u32 *)packet;\r\nif (!venus_pkt_debug)\r\nreturn;\r\nprint_hex_dump(KERN_DEBUG, "", DUMP_PREFIX_OFFSET, 16, 1, packet,\r\npkt_size, true);\r\n}\r\nstatic int venus_write_queue(struct venus_hfi_device *hdev,\r\nstruct iface_queue *queue,\r\nvoid *packet, u32 *rx_req)\r\n{\r\nstruct hfi_queue_header *qhdr;\r\nu32 dwords, new_wr_idx;\r\nu32 empty_space, rd_idx, wr_idx, qsize;\r\nu32 *wr_ptr;\r\nif (!queue->qmem.kva)\r\nreturn -EINVAL;\r\nqhdr = queue->qhdr;\r\nif (!qhdr)\r\nreturn -EINVAL;\r\nvenus_dump_packet(hdev, packet);\r\ndwords = (*(u32 *)packet) >> 2;\r\nif (!dwords)\r\nreturn -EINVAL;\r\nrd_idx = qhdr->read_idx;\r\nwr_idx = qhdr->write_idx;\r\nqsize = qhdr->q_size;\r\nrmb();\r\nif (wr_idx >= rd_idx)\r\nempty_space = qsize - (wr_idx - rd_idx);\r\nelse\r\nempty_space = rd_idx - wr_idx;\r\nif (empty_space <= dwords) {\r\nqhdr->tx_req = 1;\r\nwmb();\r\nreturn -ENOSPC;\r\n}\r\nqhdr->tx_req = 0;\r\nwmb();\r\nnew_wr_idx = wr_idx + dwords;\r\nwr_ptr = (u32 *)(queue->qmem.kva + (wr_idx << 2));\r\nif (new_wr_idx < qsize) {\r\nmemcpy(wr_ptr, packet, dwords << 2);\r\n} else {\r\nsize_t len;\r\nnew_wr_idx -= qsize;\r\nlen = (dwords - new_wr_idx) << 2;\r\nmemcpy(wr_ptr, packet, len);\r\nmemcpy(queue->qmem.kva, packet + len, new_wr_idx << 2);\r\n}\r\nwmb();\r\nqhdr->write_idx = new_wr_idx;\r\n*rx_req = qhdr->rx_req ? 1 : 0;\r\nmb();\r\nreturn 0;\r\n}\r\nstatic int venus_read_queue(struct venus_hfi_device *hdev,\r\nstruct iface_queue *queue, void *pkt, u32 *tx_req)\r\n{\r\nstruct hfi_queue_header *qhdr;\r\nu32 dwords, new_rd_idx;\r\nu32 rd_idx, wr_idx, type, qsize;\r\nu32 *rd_ptr;\r\nu32 recv_request = 0;\r\nint ret = 0;\r\nif (!queue->qmem.kva)\r\nreturn -EINVAL;\r\nqhdr = queue->qhdr;\r\nif (!qhdr)\r\nreturn -EINVAL;\r\ntype = qhdr->type;\r\nrd_idx = qhdr->read_idx;\r\nwr_idx = qhdr->write_idx;\r\nqsize = qhdr->q_size;\r\nrmb();\r\nif (type & HFI_CTRL_TO_HOST_MSG_Q)\r\nrecv_request = 1;\r\nif (rd_idx == wr_idx) {\r\nqhdr->rx_req = recv_request;\r\n*tx_req = 0;\r\nwmb();\r\nreturn -ENODATA;\r\n}\r\nrd_ptr = (u32 *)(queue->qmem.kva + (rd_idx << 2));\r\ndwords = *rd_ptr >> 2;\r\nif (!dwords)\r\nreturn -EINVAL;\r\nnew_rd_idx = rd_idx + dwords;\r\nif (((dwords << 2) <= IFACEQ_VAR_HUGE_PKT_SIZE) && rd_idx <= qsize) {\r\nif (new_rd_idx < qsize) {\r\nmemcpy(pkt, rd_ptr, dwords << 2);\r\n} else {\r\nsize_t len;\r\nnew_rd_idx -= qsize;\r\nlen = (dwords - new_rd_idx) << 2;\r\nmemcpy(pkt, rd_ptr, len);\r\nmemcpy(pkt + len, queue->qmem.kva, new_rd_idx << 2);\r\n}\r\n} else {\r\nnew_rd_idx = qhdr->write_idx;\r\nret = -EBADMSG;\r\n}\r\nrmb();\r\nqhdr->read_idx = new_rd_idx;\r\nwmb();\r\nrd_idx = qhdr->read_idx;\r\nwr_idx = qhdr->write_idx;\r\nrmb();\r\nif (rd_idx != wr_idx)\r\nqhdr->rx_req = 0;\r\nelse\r\nqhdr->rx_req = recv_request;\r\n*tx_req = qhdr->tx_req ? 1 : 0;\r\nmb();\r\nvenus_dump_packet(hdev, pkt);\r\nreturn ret;\r\n}\r\nstatic int venus_alloc(struct venus_hfi_device *hdev, struct mem_desc *desc,\r\nu32 size)\r\n{\r\nstruct device *dev = hdev->core->dev;\r\ndesc->attrs = DMA_ATTR_WRITE_COMBINE;\r\ndesc->size = ALIGN(size, SZ_4K);\r\ndesc->kva = dma_alloc_attrs(dev, size, &desc->da, GFP_KERNEL,\r\ndesc->attrs);\r\nif (!desc->kva)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void venus_free(struct venus_hfi_device *hdev, struct mem_desc *mem)\r\n{\r\nstruct device *dev = hdev->core->dev;\r\ndma_free_attrs(dev, mem->size, mem->kva, mem->da, mem->attrs);\r\n}\r\nstatic void venus_writel(struct venus_hfi_device *hdev, u32 reg, u32 value)\r\n{\r\nwritel(value, hdev->core->base + reg);\r\n}\r\nstatic u32 venus_readl(struct venus_hfi_device *hdev, u32 reg)\r\n{\r\nreturn readl(hdev->core->base + reg);\r\n}\r\nstatic void venus_set_registers(struct venus_hfi_device *hdev)\r\n{\r\nconst struct venus_resources *res = hdev->core->res;\r\nconst struct reg_val *tbl = res->reg_tbl;\r\nunsigned int count = res->reg_tbl_size;\r\nunsigned int i;\r\nfor (i = 0; i < count; i++)\r\nvenus_writel(hdev, tbl[i].reg, tbl[i].value);\r\n}\r\nstatic void venus_soft_int(struct venus_hfi_device *hdev)\r\n{\r\nvenus_writel(hdev, CPU_IC_SOFTINT, BIT(CPU_IC_SOFTINT_H2A_SHIFT));\r\n}\r\nstatic int venus_iface_cmdq_write_nolock(struct venus_hfi_device *hdev,\r\nvoid *pkt)\r\n{\r\nstruct device *dev = hdev->core->dev;\r\nstruct hfi_pkt_hdr *cmd_packet;\r\nstruct iface_queue *queue;\r\nu32 rx_req;\r\nint ret;\r\nif (!venus_is_valid_state(hdev))\r\nreturn -EINVAL;\r\ncmd_packet = (struct hfi_pkt_hdr *)pkt;\r\nhdev->last_packet_type = cmd_packet->pkt_type;\r\nqueue = &hdev->queues[IFACEQ_CMD_IDX];\r\nret = venus_write_queue(hdev, queue, pkt, &rx_req);\r\nif (ret) {\r\ndev_err(dev, "write to iface cmd queue failed (%d)\n", ret);\r\nreturn ret;\r\n}\r\nif (rx_req)\r\nvenus_soft_int(hdev);\r\nreturn 0;\r\n}\r\nstatic int venus_iface_cmdq_write(struct venus_hfi_device *hdev, void *pkt)\r\n{\r\nint ret;\r\nmutex_lock(&hdev->lock);\r\nret = venus_iface_cmdq_write_nolock(hdev, pkt);\r\nmutex_unlock(&hdev->lock);\r\nreturn ret;\r\n}\r\nstatic int venus_hfi_core_set_resource(struct venus_core *core, u32 id,\r\nu32 size, u32 addr, void *cookie)\r\n{\r\nstruct venus_hfi_device *hdev = to_hfi_priv(core);\r\nstruct hfi_sys_set_resource_pkt *pkt;\r\nu8 packet[IFACEQ_VAR_SMALL_PKT_SIZE];\r\nint ret;\r\nif (id == VIDC_RESOURCE_NONE)\r\nreturn 0;\r\npkt = (struct hfi_sys_set_resource_pkt *)packet;\r\nret = pkt_sys_set_resource(pkt, id, size, addr, cookie);\r\nif (ret)\r\nreturn ret;\r\nret = venus_iface_cmdq_write(hdev, pkt);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int venus_boot_core(struct venus_hfi_device *hdev)\r\n{\r\nstruct device *dev = hdev->core->dev;\r\nstatic const unsigned int max_tries = 100;\r\nu32 ctrl_status = 0;\r\nunsigned int count = 0;\r\nint ret = 0;\r\nvenus_writel(hdev, VIDC_CTRL_INIT, BIT(VIDC_CTRL_INIT_CTRL_SHIFT));\r\nvenus_writel(hdev, WRAPPER_INTR_MASK, WRAPPER_INTR_MASK_A2HVCODEC_MASK);\r\nvenus_writel(hdev, CPU_CS_SCIACMDARG3, 1);\r\nwhile (!ctrl_status && count < max_tries) {\r\nctrl_status = venus_readl(hdev, CPU_CS_SCIACMDARG0);\r\nif ((ctrl_status & CPU_CS_SCIACMDARG0_ERROR_STATUS_MASK) == 4) {\r\ndev_err(dev, "invalid setting for UC_REGION\n");\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nusleep_range(500, 1000);\r\ncount++;\r\n}\r\nif (count >= max_tries)\r\nret = -ETIMEDOUT;\r\nreturn ret;\r\n}\r\nstatic u32 venus_hwversion(struct venus_hfi_device *hdev)\r\n{\r\nstruct device *dev = hdev->core->dev;\r\nu32 ver = venus_readl(hdev, WRAPPER_HW_VERSION);\r\nu32 major, minor, step;\r\nmajor = ver & WRAPPER_HW_VERSION_MAJOR_VERSION_MASK;\r\nmajor = major >> WRAPPER_HW_VERSION_MAJOR_VERSION_SHIFT;\r\nminor = ver & WRAPPER_HW_VERSION_MINOR_VERSION_MASK;\r\nminor = minor >> WRAPPER_HW_VERSION_MINOR_VERSION_SHIFT;\r\nstep = ver & WRAPPER_HW_VERSION_STEP_VERSION_MASK;\r\ndev_dbg(dev, "venus hw version %x.%x.%x\n", major, minor, step);\r\nreturn major;\r\n}\r\nstatic int venus_run(struct venus_hfi_device *hdev)\r\n{\r\nstruct device *dev = hdev->core->dev;\r\nint ret;\r\nvenus_set_registers(hdev);\r\nvenus_writel(hdev, UC_REGION_ADDR, hdev->ifaceq_table.da);\r\nvenus_writel(hdev, UC_REGION_SIZE, SHARED_QSIZE);\r\nvenus_writel(hdev, CPU_CS_SCIACMDARG2, hdev->ifaceq_table.da);\r\nvenus_writel(hdev, CPU_CS_SCIACMDARG1, 0x01);\r\nif (hdev->sfr.da)\r\nvenus_writel(hdev, SFR_ADDR, hdev->sfr.da);\r\nret = venus_boot_core(hdev);\r\nif (ret) {\r\ndev_err(dev, "failed to reset venus core\n");\r\nreturn ret;\r\n}\r\nvenus_hwversion(hdev);\r\nreturn 0;\r\n}\r\nstatic int venus_halt_axi(struct venus_hfi_device *hdev)\r\n{\r\nvoid __iomem *base = hdev->core->base;\r\nstruct device *dev = hdev->core->dev;\r\nu32 val;\r\nint ret;\r\nval = venus_readl(hdev, VBIF_AXI_HALT_CTRL0);\r\nval |= VBIF_AXI_HALT_CTRL0_HALT_REQ;\r\nvenus_writel(hdev, VBIF_AXI_HALT_CTRL0, val);\r\nret = readl_poll_timeout(base + VBIF_AXI_HALT_CTRL1, val,\r\nval & VBIF_AXI_HALT_CTRL1_HALT_ACK,\r\nPOLL_INTERVAL_US,\r\nVBIF_AXI_HALT_ACK_TIMEOUT_US);\r\nif (ret) {\r\ndev_err(dev, "AXI bus port halt timeout\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int venus_power_off(struct venus_hfi_device *hdev)\r\n{\r\nint ret;\r\nif (!hdev->power_enabled)\r\nreturn 0;\r\nret = qcom_scm_set_remote_state(TZBSP_VIDEO_STATE_SUSPEND, 0);\r\nif (ret)\r\nreturn ret;\r\nret = venus_halt_axi(hdev);\r\nif (ret)\r\nreturn ret;\r\nhdev->power_enabled = false;\r\nreturn 0;\r\n}\r\nstatic int venus_power_on(struct venus_hfi_device *hdev)\r\n{\r\nint ret;\r\nif (hdev->power_enabled)\r\nreturn 0;\r\nret = qcom_scm_set_remote_state(TZBSP_VIDEO_STATE_RESUME, 0);\r\nif (ret)\r\ngoto err;\r\nret = venus_run(hdev);\r\nif (ret)\r\ngoto err_suspend;\r\nhdev->power_enabled = true;\r\nreturn 0;\r\nerr_suspend:\r\nqcom_scm_set_remote_state(TZBSP_VIDEO_STATE_SUSPEND, 0);\r\nerr:\r\nhdev->power_enabled = false;\r\nreturn ret;\r\n}\r\nstatic int venus_iface_msgq_read_nolock(struct venus_hfi_device *hdev,\r\nvoid *pkt)\r\n{\r\nstruct iface_queue *queue;\r\nu32 tx_req;\r\nint ret;\r\nif (!venus_is_valid_state(hdev))\r\nreturn -EINVAL;\r\nqueue = &hdev->queues[IFACEQ_MSG_IDX];\r\nret = venus_read_queue(hdev, queue, pkt, &tx_req);\r\nif (ret)\r\nreturn ret;\r\nif (tx_req)\r\nvenus_soft_int(hdev);\r\nreturn 0;\r\n}\r\nstatic int venus_iface_msgq_read(struct venus_hfi_device *hdev, void *pkt)\r\n{\r\nint ret;\r\nmutex_lock(&hdev->lock);\r\nret = venus_iface_msgq_read_nolock(hdev, pkt);\r\nmutex_unlock(&hdev->lock);\r\nreturn ret;\r\n}\r\nstatic int venus_iface_dbgq_read_nolock(struct venus_hfi_device *hdev,\r\nvoid *pkt)\r\n{\r\nstruct iface_queue *queue;\r\nu32 tx_req;\r\nint ret;\r\nret = venus_is_valid_state(hdev);\r\nif (!ret)\r\nreturn -EINVAL;\r\nqueue = &hdev->queues[IFACEQ_DBG_IDX];\r\nret = venus_read_queue(hdev, queue, pkt, &tx_req);\r\nif (ret)\r\nreturn ret;\r\nif (tx_req)\r\nvenus_soft_int(hdev);\r\nreturn 0;\r\n}\r\nstatic int venus_iface_dbgq_read(struct venus_hfi_device *hdev, void *pkt)\r\n{\r\nint ret;\r\nif (!pkt)\r\nreturn -EINVAL;\r\nmutex_lock(&hdev->lock);\r\nret = venus_iface_dbgq_read_nolock(hdev, pkt);\r\nmutex_unlock(&hdev->lock);\r\nreturn ret;\r\n}\r\nstatic void venus_set_qhdr_defaults(struct hfi_queue_header *qhdr)\r\n{\r\nqhdr->status = 1;\r\nqhdr->type = IFACEQ_DFLT_QHDR;\r\nqhdr->q_size = IFACEQ_QUEUE_SIZE / 4;\r\nqhdr->pkt_size = 0;\r\nqhdr->rx_wm = 1;\r\nqhdr->tx_wm = 1;\r\nqhdr->rx_req = 1;\r\nqhdr->tx_req = 0;\r\nqhdr->rx_irq_status = 0;\r\nqhdr->tx_irq_status = 0;\r\nqhdr->read_idx = 0;\r\nqhdr->write_idx = 0;\r\n}\r\nstatic void venus_interface_queues_release(struct venus_hfi_device *hdev)\r\n{\r\nmutex_lock(&hdev->lock);\r\nvenus_free(hdev, &hdev->ifaceq_table);\r\nvenus_free(hdev, &hdev->sfr);\r\nmemset(hdev->queues, 0, sizeof(hdev->queues));\r\nmemset(&hdev->ifaceq_table, 0, sizeof(hdev->ifaceq_table));\r\nmemset(&hdev->sfr, 0, sizeof(hdev->sfr));\r\nmutex_unlock(&hdev->lock);\r\n}\r\nstatic int venus_interface_queues_init(struct venus_hfi_device *hdev)\r\n{\r\nstruct hfi_queue_table_header *tbl_hdr;\r\nstruct iface_queue *queue;\r\nstruct hfi_sfr *sfr;\r\nstruct mem_desc desc = {0};\r\nunsigned int offset;\r\nunsigned int i;\r\nint ret;\r\nret = venus_alloc(hdev, &desc, ALIGNED_QUEUE_SIZE);\r\nif (ret)\r\nreturn ret;\r\nhdev->ifaceq_table.kva = desc.kva;\r\nhdev->ifaceq_table.da = desc.da;\r\nhdev->ifaceq_table.size = IFACEQ_TABLE_SIZE;\r\noffset = hdev->ifaceq_table.size;\r\nfor (i = 0; i < IFACEQ_NUM; i++) {\r\nqueue = &hdev->queues[i];\r\nqueue->qmem.da = desc.da + offset;\r\nqueue->qmem.kva = desc.kva + offset;\r\nqueue->qmem.size = IFACEQ_QUEUE_SIZE;\r\noffset += queue->qmem.size;\r\nqueue->qhdr =\r\nIFACEQ_GET_QHDR_START_ADDR(hdev->ifaceq_table.kva, i);\r\nvenus_set_qhdr_defaults(queue->qhdr);\r\nqueue->qhdr->start_addr = queue->qmem.da;\r\nif (i == IFACEQ_CMD_IDX)\r\nqueue->qhdr->type |= HFI_HOST_TO_CTRL_CMD_Q;\r\nelse if (i == IFACEQ_MSG_IDX)\r\nqueue->qhdr->type |= HFI_CTRL_TO_HOST_MSG_Q;\r\nelse if (i == IFACEQ_DBG_IDX)\r\nqueue->qhdr->type |= HFI_CTRL_TO_HOST_DBG_Q;\r\n}\r\ntbl_hdr = hdev->ifaceq_table.kva;\r\ntbl_hdr->version = 0;\r\ntbl_hdr->size = IFACEQ_TABLE_SIZE;\r\ntbl_hdr->qhdr0_offset = sizeof(struct hfi_queue_table_header);\r\ntbl_hdr->qhdr_size = sizeof(struct hfi_queue_header);\r\ntbl_hdr->num_q = IFACEQ_NUM;\r\ntbl_hdr->num_active_q = IFACEQ_NUM;\r\nqueue = &hdev->queues[IFACEQ_DBG_IDX];\r\nqueue->qhdr->rx_req = 0;\r\nret = venus_alloc(hdev, &desc, ALIGNED_SFR_SIZE);\r\nif (ret) {\r\nhdev->sfr.da = 0;\r\n} else {\r\nhdev->sfr.da = desc.da;\r\nhdev->sfr.kva = desc.kva;\r\nhdev->sfr.size = ALIGNED_SFR_SIZE;\r\nsfr = hdev->sfr.kva;\r\nsfr->buf_size = ALIGNED_SFR_SIZE;\r\n}\r\nwmb();\r\nreturn 0;\r\n}\r\nstatic int venus_sys_set_debug(struct venus_hfi_device *hdev, u32 debug)\r\n{\r\nstruct hfi_sys_set_property_pkt *pkt;\r\nu8 packet[IFACEQ_VAR_SMALL_PKT_SIZE];\r\nint ret;\r\npkt = (struct hfi_sys_set_property_pkt *)packet;\r\npkt_sys_debug_config(pkt, HFI_DEBUG_MODE_QUEUE, debug);\r\nret = venus_iface_cmdq_write(hdev, pkt);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int venus_sys_set_coverage(struct venus_hfi_device *hdev, u32 mode)\r\n{\r\nstruct hfi_sys_set_property_pkt *pkt;\r\nu8 packet[IFACEQ_VAR_SMALL_PKT_SIZE];\r\nint ret;\r\npkt = (struct hfi_sys_set_property_pkt *)packet;\r\npkt_sys_coverage_config(pkt, mode);\r\nret = venus_iface_cmdq_write(hdev, pkt);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int venus_sys_set_idle_message(struct venus_hfi_device *hdev,\r\nbool enable)\r\n{\r\nstruct hfi_sys_set_property_pkt *pkt;\r\nu8 packet[IFACEQ_VAR_SMALL_PKT_SIZE];\r\nint ret;\r\nif (!enable)\r\nreturn 0;\r\npkt = (struct hfi_sys_set_property_pkt *)packet;\r\npkt_sys_idle_indicator(pkt, enable);\r\nret = venus_iface_cmdq_write(hdev, pkt);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int venus_sys_set_power_control(struct venus_hfi_device *hdev,\r\nbool enable)\r\n{\r\nstruct hfi_sys_set_property_pkt *pkt;\r\nu8 packet[IFACEQ_VAR_SMALL_PKT_SIZE];\r\nint ret;\r\npkt = (struct hfi_sys_set_property_pkt *)packet;\r\npkt_sys_power_control(pkt, enable);\r\nret = venus_iface_cmdq_write(hdev, pkt);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int venus_get_queue_size(struct venus_hfi_device *hdev,\r\nunsigned int index)\r\n{\r\nstruct hfi_queue_header *qhdr;\r\nif (index >= IFACEQ_NUM)\r\nreturn -EINVAL;\r\nqhdr = hdev->queues[index].qhdr;\r\nif (!qhdr)\r\nreturn -EINVAL;\r\nreturn abs(qhdr->read_idx - qhdr->write_idx);\r\n}\r\nstatic int venus_sys_set_default_properties(struct venus_hfi_device *hdev)\r\n{\r\nstruct device *dev = hdev->core->dev;\r\nint ret;\r\nret = venus_sys_set_debug(hdev, venus_fw_debug);\r\nif (ret)\r\ndev_warn(dev, "setting fw debug msg ON failed (%d)\n", ret);\r\nret = venus_sys_set_idle_message(hdev, venus_sys_idle_indicator);\r\nif (ret)\r\ndev_warn(dev, "setting idle response ON failed (%d)\n", ret);\r\nret = venus_sys_set_power_control(hdev, venus_fw_low_power_mode);\r\nif (ret)\r\ndev_warn(dev, "setting hw power collapse ON failed (%d)\n",\r\nret);\r\nreturn ret;\r\n}\r\nstatic int venus_session_cmd(struct venus_inst *inst, u32 pkt_type)\r\n{\r\nstruct venus_hfi_device *hdev = to_hfi_priv(inst->core);\r\nstruct hfi_session_pkt pkt;\r\npkt_session_cmd(&pkt, pkt_type, inst);\r\nreturn venus_iface_cmdq_write(hdev, &pkt);\r\n}\r\nstatic void venus_flush_debug_queue(struct venus_hfi_device *hdev)\r\n{\r\nstruct device *dev = hdev->core->dev;\r\nvoid *packet = hdev->dbg_buf;\r\nwhile (!venus_iface_dbgq_read(hdev, packet)) {\r\nstruct hfi_msg_sys_coverage_pkt *pkt = packet;\r\nif (pkt->hdr.pkt_type != HFI_MSG_SYS_COV) {\r\nstruct hfi_msg_sys_debug_pkt *pkt = packet;\r\ndev_dbg(dev, "%s", pkt->msg_data);\r\n}\r\n}\r\n}\r\nstatic int venus_prepare_power_collapse(struct venus_hfi_device *hdev,\r\nbool wait)\r\n{\r\nunsigned long timeout = msecs_to_jiffies(venus_hw_rsp_timeout);\r\nstruct hfi_sys_pc_prep_pkt pkt;\r\nint ret;\r\ninit_completion(&hdev->pwr_collapse_prep);\r\npkt_sys_pc_prep(&pkt);\r\nret = venus_iface_cmdq_write(hdev, &pkt);\r\nif (ret)\r\nreturn ret;\r\nif (!wait)\r\nreturn 0;\r\nret = wait_for_completion_timeout(&hdev->pwr_collapse_prep, timeout);\r\nif (!ret) {\r\nvenus_flush_debug_queue(hdev);\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int venus_are_queues_empty(struct venus_hfi_device *hdev)\r\n{\r\nint ret1, ret2;\r\nret1 = venus_get_queue_size(hdev, IFACEQ_MSG_IDX);\r\nif (ret1 < 0)\r\nreturn ret1;\r\nret2 = venus_get_queue_size(hdev, IFACEQ_CMD_IDX);\r\nif (ret2 < 0)\r\nreturn ret2;\r\nif (!ret1 && !ret2)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void venus_sfr_print(struct venus_hfi_device *hdev)\r\n{\r\nstruct device *dev = hdev->core->dev;\r\nstruct hfi_sfr *sfr = hdev->sfr.kva;\r\nvoid *p;\r\nif (!sfr)\r\nreturn;\r\np = memchr(sfr->data, '\0', sfr->buf_size);\r\nif (!p)\r\nsfr->data[sfr->buf_size - 1] = '\0';\r\ndev_err_ratelimited(dev, "SFR message from FW: %s\n", sfr->data);\r\n}\r\nstatic void venus_process_msg_sys_error(struct venus_hfi_device *hdev,\r\nvoid *packet)\r\n{\r\nstruct hfi_msg_event_notify_pkt *event_pkt = packet;\r\nif (event_pkt->event_id != HFI_EVENT_SYS_ERROR)\r\nreturn;\r\nvenus_set_state(hdev, VENUS_STATE_DEINIT);\r\nvenus_halt_axi(hdev);\r\nvenus_sfr_print(hdev);\r\n}\r\nstatic irqreturn_t venus_isr_thread(struct venus_core *core)\r\n{\r\nstruct venus_hfi_device *hdev = to_hfi_priv(core);\r\nconst struct venus_resources *res;\r\nvoid *pkt;\r\nu32 msg_ret;\r\nif (!hdev)\r\nreturn IRQ_NONE;\r\nres = hdev->core->res;\r\npkt = hdev->pkt_buf;\r\nif (hdev->irq_status & WRAPPER_INTR_STATUS_A2HWD_MASK) {\r\nvenus_sfr_print(hdev);\r\nhfi_process_watchdog_timeout(core);\r\n}\r\nwhile (!venus_iface_msgq_read(hdev, pkt)) {\r\nmsg_ret = hfi_process_msg_packet(core, pkt);\r\nswitch (msg_ret) {\r\ncase HFI_MSG_EVENT_NOTIFY:\r\nvenus_process_msg_sys_error(hdev, pkt);\r\nbreak;\r\ncase HFI_MSG_SYS_INIT:\r\nvenus_hfi_core_set_resource(core, res->vmem_id,\r\nres->vmem_size,\r\nres->vmem_addr,\r\nhdev);\r\nbreak;\r\ncase HFI_MSG_SYS_RELEASE_RESOURCE:\r\ncomplete(&hdev->release_resource);\r\nbreak;\r\ncase HFI_MSG_SYS_PC_PREP:\r\ncomplete(&hdev->pwr_collapse_prep);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nvenus_flush_debug_queue(hdev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t venus_isr(struct venus_core *core)\r\n{\r\nstruct venus_hfi_device *hdev = to_hfi_priv(core);\r\nu32 status;\r\nif (!hdev)\r\nreturn IRQ_NONE;\r\nstatus = venus_readl(hdev, WRAPPER_INTR_STATUS);\r\nif (status & WRAPPER_INTR_STATUS_A2H_MASK ||\r\nstatus & WRAPPER_INTR_STATUS_A2HWD_MASK ||\r\nstatus & CPU_CS_SCIACMDARG0_INIT_IDLE_MSG_MASK)\r\nhdev->irq_status = status;\r\nvenus_writel(hdev, CPU_CS_A2HSOFTINTCLR, 1);\r\nvenus_writel(hdev, WRAPPER_INTR_CLEAR, status);\r\nreturn IRQ_WAKE_THREAD;\r\n}\r\nstatic int venus_core_init(struct venus_core *core)\r\n{\r\nstruct venus_hfi_device *hdev = to_hfi_priv(core);\r\nstruct device *dev = core->dev;\r\nstruct hfi_sys_get_property_pkt version_pkt;\r\nstruct hfi_sys_init_pkt pkt;\r\nint ret;\r\npkt_sys_init(&pkt, HFI_VIDEO_ARCH_OX);\r\nvenus_set_state(hdev, VENUS_STATE_INIT);\r\nret = venus_iface_cmdq_write(hdev, &pkt);\r\nif (ret)\r\nreturn ret;\r\npkt_sys_image_version(&version_pkt);\r\nret = venus_iface_cmdq_write(hdev, &version_pkt);\r\nif (ret)\r\ndev_warn(dev, "failed to send image version pkt to fw\n");\r\nreturn 0;\r\n}\r\nstatic int venus_core_deinit(struct venus_core *core)\r\n{\r\nstruct venus_hfi_device *hdev = to_hfi_priv(core);\r\nvenus_set_state(hdev, VENUS_STATE_DEINIT);\r\nhdev->suspended = true;\r\nhdev->power_enabled = false;\r\nreturn 0;\r\n}\r\nstatic int venus_core_ping(struct venus_core *core, u32 cookie)\r\n{\r\nstruct venus_hfi_device *hdev = to_hfi_priv(core);\r\nstruct hfi_sys_ping_pkt pkt;\r\npkt_sys_ping(&pkt, cookie);\r\nreturn venus_iface_cmdq_write(hdev, &pkt);\r\n}\r\nstatic int venus_core_trigger_ssr(struct venus_core *core, u32 trigger_type)\r\n{\r\nstruct venus_hfi_device *hdev = to_hfi_priv(core);\r\nstruct hfi_sys_test_ssr_pkt pkt;\r\nint ret;\r\nret = pkt_sys_ssr_cmd(&pkt, trigger_type);\r\nif (ret)\r\nreturn ret;\r\nreturn venus_iface_cmdq_write(hdev, &pkt);\r\n}\r\nstatic int venus_session_init(struct venus_inst *inst, u32 session_type,\r\nu32 codec)\r\n{\r\nstruct venus_hfi_device *hdev = to_hfi_priv(inst->core);\r\nstruct hfi_session_init_pkt pkt;\r\nint ret;\r\nret = venus_sys_set_default_properties(hdev);\r\nif (ret)\r\nreturn ret;\r\nret = pkt_session_init(&pkt, inst, session_type, codec);\r\nif (ret)\r\ngoto err;\r\nret = venus_iface_cmdq_write(hdev, &pkt);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nvenus_flush_debug_queue(hdev);\r\nreturn ret;\r\n}\r\nstatic int venus_session_end(struct venus_inst *inst)\r\n{\r\nstruct venus_hfi_device *hdev = to_hfi_priv(inst->core);\r\nstruct device *dev = hdev->core->dev;\r\nif (venus_fw_coverage) {\r\nif (venus_sys_set_coverage(hdev, venus_fw_coverage))\r\ndev_warn(dev, "fw coverage msg ON failed\n");\r\n}\r\nreturn venus_session_cmd(inst, HFI_CMD_SYS_SESSION_END);\r\n}\r\nstatic int venus_session_abort(struct venus_inst *inst)\r\n{\r\nstruct venus_hfi_device *hdev = to_hfi_priv(inst->core);\r\nvenus_flush_debug_queue(hdev);\r\nreturn venus_session_cmd(inst, HFI_CMD_SYS_SESSION_ABORT);\r\n}\r\nstatic int venus_session_flush(struct venus_inst *inst, u32 flush_mode)\r\n{\r\nstruct venus_hfi_device *hdev = to_hfi_priv(inst->core);\r\nstruct hfi_session_flush_pkt pkt;\r\nint ret;\r\nret = pkt_session_flush(&pkt, inst, flush_mode);\r\nif (ret)\r\nreturn ret;\r\nreturn venus_iface_cmdq_write(hdev, &pkt);\r\n}\r\nstatic int venus_session_start(struct venus_inst *inst)\r\n{\r\nreturn venus_session_cmd(inst, HFI_CMD_SESSION_START);\r\n}\r\nstatic int venus_session_stop(struct venus_inst *inst)\r\n{\r\nreturn venus_session_cmd(inst, HFI_CMD_SESSION_STOP);\r\n}\r\nstatic int venus_session_continue(struct venus_inst *inst)\r\n{\r\nreturn venus_session_cmd(inst, HFI_CMD_SESSION_CONTINUE);\r\n}\r\nstatic int venus_session_etb(struct venus_inst *inst,\r\nstruct hfi_frame_data *in_frame)\r\n{\r\nstruct venus_hfi_device *hdev = to_hfi_priv(inst->core);\r\nu32 session_type = inst->session_type;\r\nint ret;\r\nif (session_type == VIDC_SESSION_TYPE_DEC) {\r\nstruct hfi_session_empty_buffer_compressed_pkt pkt;\r\nret = pkt_session_etb_decoder(&pkt, inst, in_frame);\r\nif (ret)\r\nreturn ret;\r\nret = venus_iface_cmdq_write(hdev, &pkt);\r\n} else if (session_type == VIDC_SESSION_TYPE_ENC) {\r\nstruct hfi_session_empty_buffer_uncompressed_plane0_pkt pkt;\r\nret = pkt_session_etb_encoder(&pkt, inst, in_frame);\r\nif (ret)\r\nreturn ret;\r\nret = venus_iface_cmdq_write(hdev, &pkt);\r\n} else {\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int venus_session_ftb(struct venus_inst *inst,\r\nstruct hfi_frame_data *out_frame)\r\n{\r\nstruct venus_hfi_device *hdev = to_hfi_priv(inst->core);\r\nstruct hfi_session_fill_buffer_pkt pkt;\r\nint ret;\r\nret = pkt_session_ftb(&pkt, inst, out_frame);\r\nif (ret)\r\nreturn ret;\r\nreturn venus_iface_cmdq_write(hdev, &pkt);\r\n}\r\nstatic int venus_session_set_buffers(struct venus_inst *inst,\r\nstruct hfi_buffer_desc *bd)\r\n{\r\nstruct venus_hfi_device *hdev = to_hfi_priv(inst->core);\r\nstruct hfi_session_set_buffers_pkt *pkt;\r\nu8 packet[IFACEQ_VAR_LARGE_PKT_SIZE];\r\nint ret;\r\nif (bd->buffer_type == HFI_BUFFER_INPUT)\r\nreturn 0;\r\npkt = (struct hfi_session_set_buffers_pkt *)packet;\r\nret = pkt_session_set_buffers(pkt, inst, bd);\r\nif (ret)\r\nreturn ret;\r\nreturn venus_iface_cmdq_write(hdev, pkt);\r\n}\r\nstatic int venus_session_unset_buffers(struct venus_inst *inst,\r\nstruct hfi_buffer_desc *bd)\r\n{\r\nstruct venus_hfi_device *hdev = to_hfi_priv(inst->core);\r\nstruct hfi_session_release_buffer_pkt *pkt;\r\nu8 packet[IFACEQ_VAR_LARGE_PKT_SIZE];\r\nint ret;\r\nif (bd->buffer_type == HFI_BUFFER_INPUT)\r\nreturn 0;\r\npkt = (struct hfi_session_release_buffer_pkt *)packet;\r\nret = pkt_session_unset_buffers(pkt, inst, bd);\r\nif (ret)\r\nreturn ret;\r\nreturn venus_iface_cmdq_write(hdev, pkt);\r\n}\r\nstatic int venus_session_load_res(struct venus_inst *inst)\r\n{\r\nreturn venus_session_cmd(inst, HFI_CMD_SESSION_LOAD_RESOURCES);\r\n}\r\nstatic int venus_session_release_res(struct venus_inst *inst)\r\n{\r\nreturn venus_session_cmd(inst, HFI_CMD_SESSION_RELEASE_RESOURCES);\r\n}\r\nstatic int venus_session_parse_seq_hdr(struct venus_inst *inst, u32 seq_hdr,\r\nu32 seq_hdr_len)\r\n{\r\nstruct venus_hfi_device *hdev = to_hfi_priv(inst->core);\r\nstruct hfi_session_parse_sequence_header_pkt *pkt;\r\nu8 packet[IFACEQ_VAR_SMALL_PKT_SIZE];\r\nint ret;\r\npkt = (struct hfi_session_parse_sequence_header_pkt *)packet;\r\nret = pkt_session_parse_seq_header(pkt, inst, seq_hdr, seq_hdr_len);\r\nif (ret)\r\nreturn ret;\r\nret = venus_iface_cmdq_write(hdev, pkt);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int venus_session_get_seq_hdr(struct venus_inst *inst, u32 seq_hdr,\r\nu32 seq_hdr_len)\r\n{\r\nstruct venus_hfi_device *hdev = to_hfi_priv(inst->core);\r\nstruct hfi_session_get_sequence_header_pkt *pkt;\r\nu8 packet[IFACEQ_VAR_SMALL_PKT_SIZE];\r\nint ret;\r\npkt = (struct hfi_session_get_sequence_header_pkt *)packet;\r\nret = pkt_session_get_seq_hdr(pkt, inst, seq_hdr, seq_hdr_len);\r\nif (ret)\r\nreturn ret;\r\nreturn venus_iface_cmdq_write(hdev, pkt);\r\n}\r\nstatic int venus_session_set_property(struct venus_inst *inst, u32 ptype,\r\nvoid *pdata)\r\n{\r\nstruct venus_hfi_device *hdev = to_hfi_priv(inst->core);\r\nstruct hfi_session_set_property_pkt *pkt;\r\nu8 packet[IFACEQ_VAR_LARGE_PKT_SIZE];\r\nint ret;\r\npkt = (struct hfi_session_set_property_pkt *)packet;\r\nret = pkt_session_set_property(pkt, inst, ptype, pdata);\r\nif (ret)\r\nreturn ret;\r\nreturn venus_iface_cmdq_write(hdev, pkt);\r\n}\r\nstatic int venus_session_get_property(struct venus_inst *inst, u32 ptype)\r\n{\r\nstruct venus_hfi_device *hdev = to_hfi_priv(inst->core);\r\nstruct hfi_session_get_property_pkt pkt;\r\nint ret;\r\nret = pkt_session_get_property(&pkt, inst, ptype);\r\nif (ret)\r\nreturn ret;\r\nreturn venus_iface_cmdq_write(hdev, &pkt);\r\n}\r\nstatic int venus_resume(struct venus_core *core)\r\n{\r\nstruct venus_hfi_device *hdev = to_hfi_priv(core);\r\nint ret = 0;\r\nmutex_lock(&hdev->lock);\r\nif (!hdev->suspended)\r\ngoto unlock;\r\nret = venus_power_on(hdev);\r\nunlock:\r\nif (!ret)\r\nhdev->suspended = false;\r\nmutex_unlock(&hdev->lock);\r\nreturn ret;\r\n}\r\nstatic int venus_suspend_1xx(struct venus_core *core)\r\n{\r\nstruct venus_hfi_device *hdev = to_hfi_priv(core);\r\nstruct device *dev = core->dev;\r\nu32 ctrl_status;\r\nint ret;\r\nif (!hdev->power_enabled || hdev->suspended)\r\nreturn 0;\r\nmutex_lock(&hdev->lock);\r\nret = venus_is_valid_state(hdev);\r\nmutex_unlock(&hdev->lock);\r\nif (!ret) {\r\ndev_err(dev, "bad state, cannot suspend\n");\r\nreturn -EINVAL;\r\n}\r\nret = venus_prepare_power_collapse(hdev, true);\r\nif (ret) {\r\ndev_err(dev, "prepare for power collapse fail (%d)\n", ret);\r\nreturn ret;\r\n}\r\nmutex_lock(&hdev->lock);\r\nif (hdev->last_packet_type != HFI_CMD_SYS_PC_PREP) {\r\nmutex_unlock(&hdev->lock);\r\nreturn -EINVAL;\r\n}\r\nret = venus_are_queues_empty(hdev);\r\nif (ret < 0 || !ret) {\r\nmutex_unlock(&hdev->lock);\r\nreturn -EINVAL;\r\n}\r\nctrl_status = venus_readl(hdev, CPU_CS_SCIACMDARG0);\r\nif (!(ctrl_status & CPU_CS_SCIACMDARG0_PC_READY)) {\r\nmutex_unlock(&hdev->lock);\r\nreturn -EINVAL;\r\n}\r\nret = venus_power_off(hdev);\r\nif (ret) {\r\nmutex_unlock(&hdev->lock);\r\nreturn ret;\r\n}\r\nhdev->suspended = true;\r\nmutex_unlock(&hdev->lock);\r\nreturn 0;\r\n}\r\nstatic int venus_suspend_3xx(struct venus_core *core)\r\n{\r\nstruct venus_hfi_device *hdev = to_hfi_priv(core);\r\nstruct device *dev = core->dev;\r\nu32 ctrl_status, wfi_status;\r\nint ret;\r\nint cnt = 100;\r\nif (!hdev->power_enabled || hdev->suspended)\r\nreturn 0;\r\nmutex_lock(&hdev->lock);\r\nret = venus_is_valid_state(hdev);\r\nmutex_unlock(&hdev->lock);\r\nif (!ret) {\r\ndev_err(dev, "bad state, cannot suspend\n");\r\nreturn -EINVAL;\r\n}\r\nctrl_status = venus_readl(hdev, CPU_CS_SCIACMDARG0);\r\nif (!(ctrl_status & CPU_CS_SCIACMDARG0_PC_READY)) {\r\nwfi_status = venus_readl(hdev, WRAPPER_CPU_STATUS);\r\nctrl_status = venus_readl(hdev, CPU_CS_SCIACMDARG0);\r\nret = venus_prepare_power_collapse(hdev, false);\r\nif (ret) {\r\ndev_err(dev, "prepare for power collapse fail (%d)\n",\r\nret);\r\nreturn ret;\r\n}\r\ncnt = 100;\r\nwhile (cnt--) {\r\nwfi_status = venus_readl(hdev, WRAPPER_CPU_STATUS);\r\nctrl_status = venus_readl(hdev, CPU_CS_SCIACMDARG0);\r\nif (ctrl_status & CPU_CS_SCIACMDARG0_PC_READY &&\r\nwfi_status & BIT(0))\r\nbreak;\r\nusleep_range(1000, 1500);\r\n}\r\n}\r\nmutex_lock(&hdev->lock);\r\nret = venus_power_off(hdev);\r\nif (ret) {\r\ndev_err(dev, "venus_power_off (%d)\n", ret);\r\nmutex_unlock(&hdev->lock);\r\nreturn ret;\r\n}\r\nhdev->suspended = true;\r\nmutex_unlock(&hdev->lock);\r\nreturn 0;\r\n}\r\nstatic int venus_suspend(struct venus_core *core)\r\n{\r\nif (core->res->hfi_version == HFI_VERSION_3XX)\r\nreturn venus_suspend_3xx(core);\r\nreturn venus_suspend_1xx(core);\r\n}\r\nvoid venus_hfi_destroy(struct venus_core *core)\r\n{\r\nstruct venus_hfi_device *hdev = to_hfi_priv(core);\r\nvenus_interface_queues_release(hdev);\r\nmutex_destroy(&hdev->lock);\r\nkfree(hdev);\r\ncore->priv = NULL;\r\ncore->ops = NULL;\r\n}\r\nint venus_hfi_create(struct venus_core *core)\r\n{\r\nstruct venus_hfi_device *hdev;\r\nint ret;\r\nhdev = kzalloc(sizeof(*hdev), GFP_KERNEL);\r\nif (!hdev)\r\nreturn -ENOMEM;\r\nmutex_init(&hdev->lock);\r\nhdev->core = core;\r\nhdev->suspended = true;\r\ncore->priv = hdev;\r\ncore->ops = &venus_hfi_ops;\r\ncore->core_caps = ENC_ROTATION_CAPABILITY | ENC_SCALING_CAPABILITY |\r\nENC_DEINTERLACE_CAPABILITY |\r\nDEC_MULTI_STREAM_CAPABILITY;\r\nret = venus_interface_queues_init(hdev);\r\nif (ret)\r\ngoto err_kfree;\r\nreturn 0;\r\nerr_kfree:\r\nkfree(hdev);\r\ncore->priv = NULL;\r\ncore->ops = NULL;\r\nreturn ret;\r\n}
