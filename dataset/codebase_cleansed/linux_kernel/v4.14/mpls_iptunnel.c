static unsigned int mpls_encap_size(struct mpls_iptunnel_encap *en)\r\n{\r\nreturn en->labels * sizeof(struct mpls_shim_hdr);\r\n}\r\nstatic int mpls_xmit(struct sk_buff *skb)\r\n{\r\nstruct mpls_iptunnel_encap *tun_encap_info;\r\nstruct mpls_shim_hdr *hdr;\r\nstruct net_device *out_dev;\r\nunsigned int hh_len;\r\nunsigned int new_header_size;\r\nunsigned int mtu;\r\nstruct dst_entry *dst = skb_dst(skb);\r\nstruct rtable *rt = NULL;\r\nstruct rt6_info *rt6 = NULL;\r\nstruct mpls_dev *out_mdev;\r\nstruct net *net;\r\nint err = 0;\r\nbool bos;\r\nint i;\r\nunsigned int ttl;\r\nout_dev = dst->dev;\r\nnet = dev_net(out_dev);\r\nskb_orphan(skb);\r\nif (!mpls_output_possible(out_dev) ||\r\n!dst->lwtstate || skb_warn_if_lro(skb))\r\ngoto drop;\r\nskb_forward_csum(skb);\r\ntun_encap_info = mpls_lwtunnel_encap(dst->lwtstate);\r\nif (dst->ops->family == AF_INET) {\r\nif (tun_encap_info->ttl_propagate == MPLS_TTL_PROP_DISABLED)\r\nttl = tun_encap_info->default_ttl;\r\nelse if (tun_encap_info->ttl_propagate == MPLS_TTL_PROP_DEFAULT &&\r\n!net->mpls.ip_ttl_propagate)\r\nttl = net->mpls.default_ttl;\r\nelse\r\nttl = ip_hdr(skb)->ttl;\r\nrt = (struct rtable *)dst;\r\n} else if (dst->ops->family == AF_INET6) {\r\nif (tun_encap_info->ttl_propagate == MPLS_TTL_PROP_DISABLED)\r\nttl = tun_encap_info->default_ttl;\r\nelse if (tun_encap_info->ttl_propagate == MPLS_TTL_PROP_DEFAULT &&\r\n!net->mpls.ip_ttl_propagate)\r\nttl = net->mpls.default_ttl;\r\nelse\r\nttl = ipv6_hdr(skb)->hop_limit;\r\nrt6 = (struct rt6_info *)dst;\r\n} else {\r\ngoto drop;\r\n}\r\nnew_header_size = mpls_encap_size(tun_encap_info);\r\nmtu = mpls_dev_mtu(out_dev);\r\nif (mpls_pkt_too_big(skb, mtu - new_header_size))\r\ngoto drop;\r\nhh_len = LL_RESERVED_SPACE(out_dev);\r\nif (!out_dev->header_ops)\r\nhh_len = 0;\r\nif (skb_cow(skb, hh_len + new_header_size))\r\ngoto drop;\r\nskb_set_inner_protocol(skb, skb->protocol);\r\nskb_reset_inner_network_header(skb);\r\nskb_push(skb, new_header_size);\r\nskb_reset_network_header(skb);\r\nskb->dev = out_dev;\r\nskb->protocol = htons(ETH_P_MPLS_UC);\r\nhdr = mpls_hdr(skb);\r\nbos = true;\r\nfor (i = tun_encap_info->labels - 1; i >= 0; i--) {\r\nhdr[i] = mpls_entry_encode(tun_encap_info->label[i],\r\nttl, 0, bos);\r\nbos = false;\r\n}\r\nmpls_stats_inc_outucastpkts(out_dev, skb);\r\nif (rt)\r\nerr = neigh_xmit(NEIGH_ARP_TABLE, out_dev, &rt->rt_gateway,\r\nskb);\r\nelse if (rt6)\r\nerr = neigh_xmit(NEIGH_ND_TABLE, out_dev, &rt6->rt6i_gateway,\r\nskb);\r\nif (err)\r\nnet_dbg_ratelimited("%s: packet transmission failed: %d\n",\r\n__func__, err);\r\nreturn LWTUNNEL_XMIT_DONE;\r\ndrop:\r\nout_mdev = out_dev ? mpls_dev_get(out_dev) : NULL;\r\nif (out_mdev)\r\nMPLS_INC_STATS(out_mdev, tx_errors);\r\nkfree_skb(skb);\r\nreturn -EINVAL;\r\n}\r\nstatic int mpls_build_state(struct nlattr *nla,\r\nunsigned int family, const void *cfg,\r\nstruct lwtunnel_state **ts,\r\nstruct netlink_ext_ack *extack)\r\n{\r\nstruct mpls_iptunnel_encap *tun_encap_info;\r\nstruct nlattr *tb[MPLS_IPTUNNEL_MAX + 1];\r\nstruct lwtunnel_state *newts;\r\nu8 n_labels;\r\nint ret;\r\nret = nla_parse_nested(tb, MPLS_IPTUNNEL_MAX, nla,\r\nmpls_iptunnel_policy, extack);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!tb[MPLS_IPTUNNEL_DST]) {\r\nNL_SET_ERR_MSG(extack, "MPLS_IPTUNNEL_DST attribute is missing");\r\nreturn -EINVAL;\r\n}\r\nif (nla_get_labels(tb[MPLS_IPTUNNEL_DST], MAX_NEW_LABELS,\r\n&n_labels, NULL, extack))\r\nreturn -EINVAL;\r\nnewts = lwtunnel_state_alloc(sizeof(*tun_encap_info) +\r\nn_labels * sizeof(u32));\r\nif (!newts)\r\nreturn -ENOMEM;\r\ntun_encap_info = mpls_lwtunnel_encap(newts);\r\nret = nla_get_labels(tb[MPLS_IPTUNNEL_DST], n_labels,\r\n&tun_encap_info->labels, tun_encap_info->label,\r\nextack);\r\nif (ret)\r\ngoto errout;\r\ntun_encap_info->ttl_propagate = MPLS_TTL_PROP_DEFAULT;\r\nif (tb[MPLS_IPTUNNEL_TTL]) {\r\ntun_encap_info->default_ttl = nla_get_u8(tb[MPLS_IPTUNNEL_TTL]);\r\ntun_encap_info->ttl_propagate = tun_encap_info->default_ttl ?\r\nMPLS_TTL_PROP_DISABLED :\r\nMPLS_TTL_PROP_ENABLED;\r\n}\r\nnewts->type = LWTUNNEL_ENCAP_MPLS;\r\nnewts->flags |= LWTUNNEL_STATE_XMIT_REDIRECT;\r\nnewts->headroom = mpls_encap_size(tun_encap_info);\r\n*ts = newts;\r\nreturn 0;\r\nerrout:\r\nkfree(newts);\r\n*ts = NULL;\r\nreturn ret;\r\n}\r\nstatic int mpls_fill_encap_info(struct sk_buff *skb,\r\nstruct lwtunnel_state *lwtstate)\r\n{\r\nstruct mpls_iptunnel_encap *tun_encap_info;\r\ntun_encap_info = mpls_lwtunnel_encap(lwtstate);\r\nif (nla_put_labels(skb, MPLS_IPTUNNEL_DST, tun_encap_info->labels,\r\ntun_encap_info->label))\r\ngoto nla_put_failure;\r\nif (tun_encap_info->ttl_propagate != MPLS_TTL_PROP_DEFAULT &&\r\nnla_put_u8(skb, MPLS_IPTUNNEL_TTL, tun_encap_info->default_ttl))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int mpls_encap_nlsize(struct lwtunnel_state *lwtstate)\r\n{\r\nstruct mpls_iptunnel_encap *tun_encap_info;\r\nint nlsize;\r\ntun_encap_info = mpls_lwtunnel_encap(lwtstate);\r\nnlsize = nla_total_size(tun_encap_info->labels * 4);\r\nif (tun_encap_info->ttl_propagate != MPLS_TTL_PROP_DEFAULT)\r\nnlsize += nla_total_size(1);\r\nreturn nlsize;\r\n}\r\nstatic int mpls_encap_cmp(struct lwtunnel_state *a, struct lwtunnel_state *b)\r\n{\r\nstruct mpls_iptunnel_encap *a_hdr = mpls_lwtunnel_encap(a);\r\nstruct mpls_iptunnel_encap *b_hdr = mpls_lwtunnel_encap(b);\r\nint l;\r\nif (a_hdr->labels != b_hdr->labels ||\r\na_hdr->ttl_propagate != b_hdr->ttl_propagate ||\r\na_hdr->default_ttl != b_hdr->default_ttl)\r\nreturn 1;\r\nfor (l = 0; l < a_hdr->labels; l++)\r\nif (a_hdr->label[l] != b_hdr->label[l])\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int __init mpls_iptunnel_init(void)\r\n{\r\nreturn lwtunnel_encap_add_ops(&mpls_iptun_ops, LWTUNNEL_ENCAP_MPLS);\r\n}\r\nstatic void __exit mpls_iptunnel_exit(void)\r\n{\r\nlwtunnel_encap_del_ops(&mpls_iptun_ops, LWTUNNEL_ENCAP_MPLS);\r\n}
