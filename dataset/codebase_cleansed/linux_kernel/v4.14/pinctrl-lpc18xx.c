static int lpc18xx_pconf_get_usb1(enum pin_config_param param, int *arg, u32 reg)\r\n{\r\nswitch (param) {\r\ncase PIN_CONFIG_LOW_POWER_MODE:\r\nif (reg & LPC18XX_SCU_USB1_EPWR)\r\n*arg = 0;\r\nelse\r\n*arg = 1;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\nif (reg & LPC18XX_SCU_USB1_EPD)\r\nreturn -EINVAL;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\nif (reg & LPC18XX_SCU_USB1_EPD)\r\n*arg = 1;\r\nelse\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nreturn -ENOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lpc18xx_pconf_get_i2c0(enum pin_config_param param, int *arg, u32 reg,\r\nunsigned pin)\r\n{\r\nu8 shift;\r\nif (pin == PIN_I2C0_SCL)\r\nshift = LPC18XX_SCU_I2C0_SCL_SHIFT;\r\nelse\r\nshift = LPC18XX_SCU_I2C0_SDA_SHIFT;\r\nswitch (param) {\r\ncase PIN_CONFIG_INPUT_ENABLE:\r\nif (reg & (LPC18XX_SCU_I2C0_EZI << shift))\r\n*arg = 1;\r\nelse\r\nreturn -EINVAL;\r\nbreak;\r\ncase PIN_CONFIG_SLEW_RATE:\r\nif (reg & (LPC18XX_SCU_I2C0_EHD << shift))\r\n*arg = 1;\r\nelse\r\n*arg = 0;\r\nbreak;\r\ncase PIN_CONFIG_INPUT_SCHMITT:\r\nif (reg & (LPC18XX_SCU_I2C0_EFP << shift))\r\n*arg = 3;\r\nelse\r\n*arg = 50;\r\nbreak;\r\ncase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\r\nif (reg & (LPC18XX_SCU_I2C0_ZIF << shift))\r\nreturn -EINVAL;\r\nelse\r\n*arg = 1;\r\nbreak;\r\ndefault:\r\nreturn -ENOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lpc18xx_pin_to_gpio(struct pinctrl_dev *pctldev, unsigned pin)\r\n{\r\nstruct pinctrl_gpio_range *range;\r\nrange = pinctrl_find_gpio_range_from_pin_nolock(pctldev, pin);\r\nif (!range)\r\nreturn -EINVAL;\r\nreturn pin - range->pin_base + range->base;\r\n}\r\nstatic int lpc18xx_get_pintsel(void __iomem *addr, u32 val, int *arg)\r\n{\r\nu32 reg_val;\r\nint i;\r\nreg_val = readl(addr);\r\nfor (i = 0; i < LPC18XX_SCU_IRQ_PER_PINTSEL; i++) {\r\nif ((reg_val & LPC18XX_SCU_PINTSEL_VAL_MASK) == val)\r\nreturn 0;\r\nreg_val >>= BITS_PER_BYTE;\r\n*arg += 1;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic u32 lpc18xx_gpio_to_pintsel_val(int gpio)\r\n{\r\nunsigned int gpio_port, gpio_pin;\r\ngpio_port = gpio / LPC18XX_GPIO_PINS_PER_PORT;\r\ngpio_pin = gpio % LPC18XX_GPIO_PINS_PER_PORT;\r\nreturn gpio_pin | (gpio_port << LPC18XX_SCU_PINTSEL_PORT_SHIFT);\r\n}\r\nstatic int lpc18xx_pconf_get_gpio_pin_int(struct pinctrl_dev *pctldev,\r\nint *arg, unsigned pin)\r\n{\r\nstruct lpc18xx_scu_data *scu = pinctrl_dev_get_drvdata(pctldev);\r\nint gpio, ret;\r\nu32 val;\r\ngpio = lpc18xx_pin_to_gpio(pctldev, pin);\r\nif (gpio < 0)\r\nreturn -ENOTSUPP;\r\nval = lpc18xx_gpio_to_pintsel_val(gpio);\r\n*arg = 0;\r\nret = lpc18xx_get_pintsel(scu->base + LPC18XX_SCU_PINTSEL0, val, arg);\r\nif (ret == 0)\r\nreturn ret;\r\nreturn lpc18xx_get_pintsel(scu->base + LPC18XX_SCU_PINTSEL1, val, arg);\r\n}\r\nstatic int lpc18xx_pconf_get_pin(struct pinctrl_dev *pctldev, unsigned param,\r\nint *arg, u32 reg, unsigned pin,\r\nstruct lpc18xx_pin_caps *pin_cap)\r\n{\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\nif ((!(reg & LPC18XX_SCU_PIN_EPD)) && (reg & LPC18XX_SCU_PIN_EPUN))\r\n;\r\nelse\r\nreturn -EINVAL;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\nif (reg & LPC18XX_SCU_PIN_EPUN)\r\nreturn -EINVAL;\r\nelse\r\n*arg = 1;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\nif (reg & LPC18XX_SCU_PIN_EPD)\r\n*arg = 1;\r\nelse\r\nreturn -EINVAL;\r\nbreak;\r\ncase PIN_CONFIG_INPUT_ENABLE:\r\nif (reg & LPC18XX_SCU_PIN_EZI)\r\n*arg = 1;\r\nelse\r\nreturn -EINVAL;\r\nbreak;\r\ncase PIN_CONFIG_SLEW_RATE:\r\nif (pin_cap->type == TYPE_HD)\r\nreturn -ENOTSUPP;\r\nif (reg & LPC18XX_SCU_PIN_EHS)\r\n*arg = 1;\r\nelse\r\n*arg = 0;\r\nbreak;\r\ncase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\r\nif (reg & LPC18XX_SCU_PIN_ZIF)\r\nreturn -EINVAL;\r\nelse\r\n*arg = 1;\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_STRENGTH:\r\nif (pin_cap->type != TYPE_HD)\r\nreturn -ENOTSUPP;\r\n*arg = (reg & LPC18XX_SCU_PIN_EHD_MASK) >> LPC18XX_SCU_PIN_EHD_POS;\r\nswitch (*arg) {\r\ncase 3: *arg += 5;\r\ncase 2: *arg += 5;\r\ncase 1: *arg += 3;\r\ncase 0: *arg += 4;\r\n}\r\nbreak;\r\ncase PIN_CONFIG_GPIO_PIN_INT:\r\nreturn lpc18xx_pconf_get_gpio_pin_int(pctldev, arg, pin);\r\ndefault:\r\nreturn -ENOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct lpc18xx_pin_caps *lpc18xx_get_pin_caps(unsigned pin)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(lpc18xx_pins); i++) {\r\nif (lpc18xx_pins[i].number == pin)\r\nreturn lpc18xx_pins[i].drv_data;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int lpc18xx_pconf_get(struct pinctrl_dev *pctldev, unsigned pin,\r\nunsigned long *config)\r\n{\r\nstruct lpc18xx_scu_data *scu = pinctrl_dev_get_drvdata(pctldev);\r\nenum pin_config_param param = pinconf_to_config_param(*config);\r\nstruct lpc18xx_pin_caps *pin_cap;\r\nint ret, arg = 0;\r\nu32 reg;\r\npin_cap = lpc18xx_get_pin_caps(pin);\r\nif (!pin_cap)\r\nreturn -EINVAL;\r\nreg = readl(scu->base + pin_cap->offset);\r\nif (pin_cap->type == TYPE_I2C0)\r\nret = lpc18xx_pconf_get_i2c0(param, &arg, reg, pin);\r\nelse if (pin_cap->type == TYPE_USB1)\r\nret = lpc18xx_pconf_get_usb1(param, &arg, reg);\r\nelse\r\nret = lpc18xx_pconf_get_pin(pctldev, param, &arg, reg, pin, pin_cap);\r\nif (ret < 0)\r\nreturn ret;\r\n*config = pinconf_to_config_packed(param, (u16)arg);\r\nreturn 0;\r\n}\r\nstatic int lpc18xx_pconf_set_usb1(struct pinctrl_dev *pctldev,\r\nenum pin_config_param param,\r\nu32 param_val, u32 *reg)\r\n{\r\nswitch (param) {\r\ncase PIN_CONFIG_LOW_POWER_MODE:\r\nif (param_val)\r\n*reg &= ~LPC18XX_SCU_USB1_EPWR;\r\nelse\r\n*reg |= LPC18XX_SCU_USB1_EPWR;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\n*reg &= ~LPC18XX_SCU_USB1_EPD;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\n*reg |= LPC18XX_SCU_USB1_EPD;\r\nbreak;\r\ndefault:\r\ndev_err(pctldev->dev, "Property not supported\n");\r\nreturn -ENOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lpc18xx_pconf_set_i2c0(struct pinctrl_dev *pctldev,\r\nenum pin_config_param param,\r\nu32 param_val, u32 *reg,\r\nunsigned pin)\r\n{\r\nu8 shift;\r\nif (pin == PIN_I2C0_SCL)\r\nshift = LPC18XX_SCU_I2C0_SCL_SHIFT;\r\nelse\r\nshift = LPC18XX_SCU_I2C0_SDA_SHIFT;\r\nswitch (param) {\r\ncase PIN_CONFIG_INPUT_ENABLE:\r\nif (param_val)\r\n*reg |= (LPC18XX_SCU_I2C0_EZI << shift);\r\nelse\r\n*reg &= ~(LPC18XX_SCU_I2C0_EZI << shift);\r\nbreak;\r\ncase PIN_CONFIG_SLEW_RATE:\r\nif (param_val)\r\n*reg |= (LPC18XX_SCU_I2C0_EHD << shift);\r\nelse\r\n*reg &= ~(LPC18XX_SCU_I2C0_EHD << shift);\r\nbreak;\r\ncase PIN_CONFIG_INPUT_SCHMITT:\r\nif (param_val == 3)\r\n*reg |= (LPC18XX_SCU_I2C0_EFP << shift);\r\nelse if (param_val == 50)\r\n*reg &= ~(LPC18XX_SCU_I2C0_EFP << shift);\r\nelse\r\nreturn -ENOTSUPP;\r\nbreak;\r\ncase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\r\nif (param_val)\r\n*reg &= ~(LPC18XX_SCU_I2C0_ZIF << shift);\r\nelse\r\n*reg |= (LPC18XX_SCU_I2C0_ZIF << shift);\r\nbreak;\r\ndefault:\r\ndev_err(pctldev->dev, "Property not supported\n");\r\nreturn -ENOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lpc18xx_pconf_set_gpio_pin_int(struct pinctrl_dev *pctldev,\r\nu32 param_val, unsigned pin)\r\n{\r\nstruct lpc18xx_scu_data *scu = pinctrl_dev_get_drvdata(pctldev);\r\nu32 val, reg_val, reg_offset = LPC18XX_SCU_PINTSEL0;\r\nint gpio;\r\nif (param_val >= LPC18XX_GPIO_PIN_INT_MAX)\r\nreturn -EINVAL;\r\ngpio = lpc18xx_pin_to_gpio(pctldev, pin);\r\nif (gpio < 0)\r\nreturn -ENOTSUPP;\r\nval = lpc18xx_gpio_to_pintsel_val(gpio);\r\nreg_offset += (param_val / LPC18XX_SCU_IRQ_PER_PINTSEL) * sizeof(u32);\r\nreg_val = readl(scu->base + reg_offset);\r\nreg_val &= ~LPC18XX_SCU_PINTSEL_VAL(LPC18XX_SCU_PINTSEL_VAL_MASK, param_val);\r\nreg_val |= LPC18XX_SCU_PINTSEL_VAL(val, param_val);\r\nwritel(reg_val, scu->base + reg_offset);\r\nreturn 0;\r\n}\r\nstatic int lpc18xx_pconf_set_pin(struct pinctrl_dev *pctldev, unsigned param,\r\nu32 param_val, u32 *reg, unsigned pin,\r\nstruct lpc18xx_pin_caps *pin_cap)\r\n{\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\n*reg &= ~LPC18XX_SCU_PIN_EPD;\r\n*reg |= LPC18XX_SCU_PIN_EPUN;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\n*reg &= ~LPC18XX_SCU_PIN_EPUN;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\n*reg |= LPC18XX_SCU_PIN_EPD;\r\nbreak;\r\ncase PIN_CONFIG_INPUT_ENABLE:\r\nif (param_val)\r\n*reg |= LPC18XX_SCU_PIN_EZI;\r\nelse\r\n*reg &= ~LPC18XX_SCU_PIN_EZI;\r\nbreak;\r\ncase PIN_CONFIG_SLEW_RATE:\r\nif (pin_cap->type == TYPE_HD) {\r\ndev_err(pctldev->dev, "Slew rate unsupported on high-drive pins\n");\r\nreturn -ENOTSUPP;\r\n}\r\nif (param_val == 0)\r\n*reg &= ~LPC18XX_SCU_PIN_EHS;\r\nelse\r\n*reg |= LPC18XX_SCU_PIN_EHS;\r\nbreak;\r\ncase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\r\nif (param_val)\r\n*reg &= ~LPC18XX_SCU_PIN_ZIF;\r\nelse\r\n*reg |= LPC18XX_SCU_PIN_ZIF;\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_STRENGTH:\r\nif (pin_cap->type != TYPE_HD) {\r\ndev_err(pctldev->dev, "Drive strength available only on high-drive pins\n");\r\nreturn -ENOTSUPP;\r\n}\r\n*reg &= ~LPC18XX_SCU_PIN_EHD_MASK;\r\nswitch (param_val) {\r\ncase 20: param_val -= 5;\r\ncase 14: param_val -= 5;\r\ncase 8: param_val -= 3;\r\ncase 4: param_val -= 4;\r\nbreak;\r\ndefault:\r\ndev_err(pctldev->dev, "Drive strength %u unsupported\n", param_val);\r\nreturn -ENOTSUPP;\r\n}\r\n*reg |= param_val << LPC18XX_SCU_PIN_EHD_POS;\r\nbreak;\r\ncase PIN_CONFIG_GPIO_PIN_INT:\r\nreturn lpc18xx_pconf_set_gpio_pin_int(pctldev, param_val, pin);\r\ndefault:\r\ndev_err(pctldev->dev, "Property not supported\n");\r\nreturn -ENOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lpc18xx_pconf_set(struct pinctrl_dev *pctldev, unsigned pin,\r\nunsigned long *configs, unsigned num_configs)\r\n{\r\nstruct lpc18xx_scu_data *scu = pinctrl_dev_get_drvdata(pctldev);\r\nstruct lpc18xx_pin_caps *pin_cap;\r\nenum pin_config_param param;\r\nu32 param_val;\r\nu32 reg;\r\nint ret;\r\nint i;\r\npin_cap = lpc18xx_get_pin_caps(pin);\r\nif (!pin_cap)\r\nreturn -EINVAL;\r\nreg = readl(scu->base + pin_cap->offset);\r\nfor (i = 0; i < num_configs; i++) {\r\nparam = pinconf_to_config_param(configs[i]);\r\nparam_val = pinconf_to_config_argument(configs[i]);\r\nif (pin_cap->type == TYPE_I2C0)\r\nret = lpc18xx_pconf_set_i2c0(pctldev, param, param_val, &reg, pin);\r\nelse if (pin_cap->type == TYPE_USB1)\r\nret = lpc18xx_pconf_set_usb1(pctldev, param, param_val, &reg);\r\nelse\r\nret = lpc18xx_pconf_set_pin(pctldev, param, param_val, &reg, pin, pin_cap);\r\nif (ret)\r\nreturn ret;\r\n}\r\nwritel(reg, scu->base + pin_cap->offset);\r\nreturn 0;\r\n}\r\nstatic int lpc18xx_pmx_get_funcs_count(struct pinctrl_dev *pctldev)\r\n{\r\nreturn ARRAY_SIZE(lpc18xx_function_names);\r\n}\r\nstatic const char *lpc18xx_pmx_get_func_name(struct pinctrl_dev *pctldev,\r\nunsigned function)\r\n{\r\nreturn lpc18xx_function_names[function];\r\n}\r\nstatic int lpc18xx_pmx_get_func_groups(struct pinctrl_dev *pctldev,\r\nunsigned function,\r\nconst char *const **groups,\r\nunsigned *const num_groups)\r\n{\r\nstruct lpc18xx_scu_data *scu = pinctrl_dev_get_drvdata(pctldev);\r\n*groups = scu->func[function].groups;\r\n*num_groups = scu->func[function].ngroups;\r\nreturn 0;\r\n}\r\nstatic int lpc18xx_pmx_set(struct pinctrl_dev *pctldev, unsigned function,\r\nunsigned group)\r\n{\r\nstruct lpc18xx_scu_data *scu = pinctrl_dev_get_drvdata(pctldev);\r\nstruct lpc18xx_pin_caps *pin = lpc18xx_pins[group].drv_data;\r\nint func;\r\nu32 reg;\r\nif (pin->type == TYPE_USB1) {\r\nif (function == FUNC_USB1)\r\nreturn 0;\r\ngoto fail;\r\n}\r\nif (pin->type == TYPE_I2C0) {\r\nif (function == FUNC_I2C0)\r\nreturn 0;\r\ngoto fail;\r\n}\r\nif (function == FUNC_ADC && (pin->analog & LPC18XX_ANALOG_PIN)) {\r\nu32 offset;\r\nwritel(LPC18XX_SCU_ANALOG_PIN_CFG, scu->base + pin->offset);\r\nif (LPC18XX_ANALOG_ADC(pin->analog) == 0)\r\noffset = LPC18XX_SCU_REG_ENAIO0;\r\nelse\r\noffset = LPC18XX_SCU_REG_ENAIO1;\r\nreg = readl(scu->base + offset);\r\nreg |= pin->analog & LPC18XX_ANALOG_BIT_MASK;\r\nwritel(reg, scu->base + offset);\r\nreturn 0;\r\n}\r\nif (function == FUNC_DAC && (pin->analog & LPC18XX_ANALOG_PIN)) {\r\nwritel(LPC18XX_SCU_ANALOG_PIN_CFG, scu->base + pin->offset);\r\nreg = readl(scu->base + LPC18XX_SCU_REG_ENAIO2);\r\nreg |= LPC18XX_SCU_REG_ENAIO2_DAC;\r\nwritel(reg, scu->base + LPC18XX_SCU_REG_ENAIO2);\r\nreturn 0;\r\n}\r\nfor (func = 0; func < LPC18XX_SCU_FUNC_PER_PIN; func++) {\r\nif (function == pin->functions[func])\r\nbreak;\r\n}\r\nif (func >= LPC18XX_SCU_FUNC_PER_PIN)\r\ngoto fail;\r\nreg = readl(scu->base + pin->offset);\r\nreg &= ~LPC18XX_SCU_PIN_MODE_MASK;\r\nwritel(reg | func, scu->base + pin->offset);\r\nreturn 0;\r\nfail:\r\ndev_err(pctldev->dev, "Pin %s can't be %s\n", lpc18xx_pins[group].name,\r\nlpc18xx_function_names[function]);\r\nreturn -EINVAL;\r\n}\r\nstatic int lpc18xx_pctl_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nreturn ARRAY_SIZE(lpc18xx_pins);\r\n}\r\nstatic const char *lpc18xx_pctl_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned group)\r\n{\r\nreturn lpc18xx_pins[group].name;\r\n}\r\nstatic int lpc18xx_pctl_get_group_pins(struct pinctrl_dev *pctldev,\r\nunsigned group,\r\nconst unsigned **pins,\r\nunsigned *num_pins)\r\n{\r\n*pins = &lpc18xx_pins[group].number;\r\n*num_pins = 1;\r\nreturn 0;\r\n}\r\nstatic bool lpc18xx_valid_pin_function(unsigned pin, unsigned function)\r\n{\r\nstruct lpc18xx_pin_caps *p = lpc18xx_pins[pin].drv_data;\r\nint i;\r\nif (function == FUNC_DAC && p->analog == DAC)\r\nreturn true;\r\nif (function == FUNC_ADC && p->analog)\r\nreturn true;\r\nif (function == FUNC_I2C0 && p->type == TYPE_I2C0)\r\nreturn true;\r\nif (function == FUNC_USB1 && p->type == TYPE_USB1)\r\nreturn true;\r\nfor (i = 0; i < LPC18XX_SCU_FUNC_PER_PIN; i++) {\r\nif (function == p->functions[i])\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int lpc18xx_create_group_func_map(struct device *dev,\r\nstruct lpc18xx_scu_data *scu)\r\n{\r\nu16 pins[ARRAY_SIZE(lpc18xx_pins)];\r\nint func, ngroups, i;\r\nfor (func = 0; func < FUNC_MAX; func++) {\r\nfor (ngroups = 0, i = 0; i < ARRAY_SIZE(lpc18xx_pins); i++) {\r\nif (lpc18xx_valid_pin_function(i, func))\r\npins[ngroups++] = i;\r\n}\r\nscu->func[func].ngroups = ngroups;\r\nscu->func[func].groups = devm_kzalloc(dev, ngroups *\r\nsizeof(char *), GFP_KERNEL);\r\nif (!scu->func[func].groups)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < ngroups; i++)\r\nscu->func[func].groups[i] = lpc18xx_pins[pins[i]].name;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lpc18xx_scu_probe(struct platform_device *pdev)\r\n{\r\nstruct lpc18xx_scu_data *scu;\r\nstruct resource *res;\r\nint ret;\r\nscu = devm_kzalloc(&pdev->dev, sizeof(*scu), GFP_KERNEL);\r\nif (!scu)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nscu->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(scu->base))\r\nreturn PTR_ERR(scu->base);\r\nscu->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(scu->clk)) {\r\ndev_err(&pdev->dev, "Input clock not found.\n");\r\nreturn PTR_ERR(scu->clk);\r\n}\r\nret = lpc18xx_create_group_func_map(&pdev->dev, scu);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Unable to create group func map.\n");\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(scu->clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Unable to enable clock.\n");\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, scu);\r\nscu->pctl = devm_pinctrl_register(&pdev->dev, &lpc18xx_scu_desc, scu);\r\nif (IS_ERR(scu->pctl)) {\r\ndev_err(&pdev->dev, "Could not register pinctrl driver\n");\r\nclk_disable_unprepare(scu->clk);\r\nreturn PTR_ERR(scu->pctl);\r\n}\r\nreturn 0;\r\n}
