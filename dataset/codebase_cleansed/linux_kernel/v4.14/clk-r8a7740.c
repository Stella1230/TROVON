static struct clk * __init\r\nr8a7740_cpg_register_clock(struct device_node *np, struct r8a7740_cpg *cpg,\r\nconst char *name)\r\n{\r\nconst struct clk_div_table *table = NULL;\r\nconst char *parent_name;\r\nunsigned int shift, reg;\r\nunsigned int mult = 1;\r\nunsigned int div = 1;\r\nif (!strcmp(name, "r")) {\r\nswitch (cpg_mode & (BIT(2) | BIT(1))) {\r\ncase BIT(1) | BIT(2):\r\nparent_name = of_clk_get_parent_name(np, 0);\r\ndiv = 2048;\r\nbreak;\r\ncase BIT(2):\r\nparent_name = of_clk_get_parent_name(np, 0);\r\ndiv = 1024;\r\nbreak;\r\ndefault:\r\nparent_name = of_clk_get_parent_name(np, 2);\r\nbreak;\r\n}\r\n} else if (!strcmp(name, "system")) {\r\nparent_name = of_clk_get_parent_name(np, 0);\r\nif (cpg_mode & BIT(1))\r\ndiv = 2;\r\n} else if (!strcmp(name, "pllc0")) {\r\nu32 value = clk_readl(cpg->reg + CPG_FRQCRC);\r\nparent_name = "system";\r\nmult = ((value >> 24) & 0x7f) + 1;\r\n} else if (!strcmp(name, "pllc1")) {\r\nu32 value = clk_readl(cpg->reg + CPG_FRQCRA);\r\nparent_name = "system";\r\nmult = ((value >> 24) & 0x7f) + 1;\r\ndiv = 2;\r\n} else if (!strcmp(name, "pllc2")) {\r\nu32 value = clk_readl(cpg->reg + CPG_PLLC2CR);\r\nparent_name = "system";\r\nmult = ((value >> 24) & 0x3f) + 1;\r\n} else if (!strcmp(name, "usb24s")) {\r\nu32 value = clk_readl(cpg->reg + CPG_USBCKCR);\r\nif (value & BIT(7))\r\nparent_name = of_clk_get_parent_name(np, 1);\r\nelse\r\nparent_name = "system";\r\nif (!(value & BIT(6)))\r\ndiv = 2;\r\n} else {\r\nstruct div4_clk *c;\r\nfor (c = div4_clks; c->name; c++) {\r\nif (!strcmp(name, c->name)) {\r\nparent_name = "pllc1";\r\ntable = div4_div_table;\r\nreg = c->reg;\r\nshift = c->shift;\r\nbreak;\r\n}\r\n}\r\nif (!c->name)\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (!table) {\r\nreturn clk_register_fixed_factor(NULL, name, parent_name, 0,\r\nmult, div);\r\n} else {\r\nreturn clk_register_divider_table(NULL, name, parent_name, 0,\r\ncpg->reg + reg, shift, 4, 0,\r\ntable, &cpg->lock);\r\n}\r\n}\r\nstatic void __init r8a7740_cpg_clocks_init(struct device_node *np)\r\n{\r\nstruct r8a7740_cpg *cpg;\r\nstruct clk **clks;\r\nunsigned int i;\r\nint num_clks;\r\nif (of_property_read_u32(np, "renesas,mode", &cpg_mode))\r\npr_warn("%s: missing renesas,mode property\n", __func__);\r\nnum_clks = of_property_count_strings(np, "clock-output-names");\r\nif (num_clks < 0) {\r\npr_err("%s: failed to count clocks\n", __func__);\r\nreturn;\r\n}\r\ncpg = kzalloc(sizeof(*cpg), GFP_KERNEL);\r\nclks = kzalloc(num_clks * sizeof(*clks), GFP_KERNEL);\r\nif (cpg == NULL || clks == NULL) {\r\nreturn;\r\n}\r\nspin_lock_init(&cpg->lock);\r\ncpg->data.clks = clks;\r\ncpg->data.clk_num = num_clks;\r\ncpg->reg = of_iomap(np, 0);\r\nif (WARN_ON(cpg->reg == NULL))\r\nreturn;\r\nfor (i = 0; i < num_clks; ++i) {\r\nconst char *name;\r\nstruct clk *clk;\r\nof_property_read_string_index(np, "clock-output-names", i,\r\n&name);\r\nclk = r8a7740_cpg_register_clock(np, cpg, name);\r\nif (IS_ERR(clk))\r\npr_err("%s: failed to register %s %s clock (%ld)\n",\r\n__func__, np->name, name, PTR_ERR(clk));\r\nelse\r\ncpg->data.clks[i] = clk;\r\n}\r\nof_clk_add_provider(np, of_clk_src_onecell_get, &cpg->data);\r\n}
