static int mlxsw_sp_counter_pool_validate(struct mlxsw_sp *mlxsw_sp)\r\n{\r\nunsigned int total_bank_config = 0;\r\nunsigned int pool_size;\r\nint i;\r\npool_size = MLXSW_CORE_RES_GET(mlxsw_sp->core, COUNTER_POOL_SIZE);\r\nfor (i = 0; i < ARRAY_SIZE(mlxsw_sp_counter_sub_pools); i++)\r\ntotal_bank_config += mlxsw_sp_counter_sub_pools[i].bank_count;\r\nif (total_bank_config > pool_size / MLXSW_SP_COUNTER_POOL_BANK_SIZE + 1)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int mlxsw_sp_counter_sub_pools_prepare(struct mlxsw_sp *mlxsw_sp)\r\n{\r\nstruct mlxsw_sp_counter_sub_pool *sub_pool;\r\nsub_pool = &mlxsw_sp_counter_sub_pools[MLXSW_SP_COUNTER_SUB_POOL_FLOW];\r\nif (!MLXSW_CORE_RES_VALID(mlxsw_sp->core, COUNTER_SIZE_PACKETS_BYTES))\r\nreturn -EIO;\r\nsub_pool->entry_size = MLXSW_CORE_RES_GET(mlxsw_sp->core,\r\nCOUNTER_SIZE_PACKETS_BYTES);\r\nsub_pool = &mlxsw_sp_counter_sub_pools[MLXSW_SP_COUNTER_SUB_POOL_RIF];\r\nif (!MLXSW_CORE_RES_VALID(mlxsw_sp->core, COUNTER_SIZE_ROUTER_BASIC))\r\nreturn -EIO;\r\nsub_pool->entry_size = MLXSW_CORE_RES_GET(mlxsw_sp->core,\r\nCOUNTER_SIZE_ROUTER_BASIC);\r\nreturn 0;\r\n}\r\nint mlxsw_sp_counter_pool_init(struct mlxsw_sp *mlxsw_sp)\r\n{\r\nstruct mlxsw_sp_counter_sub_pool *sub_pool;\r\nstruct mlxsw_sp_counter_pool *pool;\r\nunsigned int base_index;\r\nunsigned int map_size;\r\nint i;\r\nint err;\r\nif (!MLXSW_CORE_RES_VALID(mlxsw_sp->core, COUNTER_POOL_SIZE))\r\nreturn -EIO;\r\nerr = mlxsw_sp_counter_pool_validate(mlxsw_sp);\r\nif (err)\r\nreturn err;\r\nerr = mlxsw_sp_counter_sub_pools_prepare(mlxsw_sp);\r\nif (err)\r\nreturn err;\r\npool = kzalloc(sizeof(*pool), GFP_KERNEL);\r\nif (!pool)\r\nreturn -ENOMEM;\r\npool->pool_size = MLXSW_CORE_RES_GET(mlxsw_sp->core, COUNTER_POOL_SIZE);\r\nmap_size = BITS_TO_LONGS(pool->pool_size) * sizeof(unsigned long);\r\npool->usage = kzalloc(map_size, GFP_KERNEL);\r\nif (!pool->usage) {\r\nerr = -ENOMEM;\r\ngoto err_usage_alloc;\r\n}\r\npool->sub_pools = mlxsw_sp_counter_sub_pools;\r\nbase_index = 0;\r\nfor (i = 0; i < ARRAY_SIZE(mlxsw_sp_counter_sub_pools); i++) {\r\nsub_pool = &pool->sub_pools[i];\r\nsub_pool->size = sub_pool->bank_count *\r\nMLXSW_SP_COUNTER_POOL_BANK_SIZE;\r\nsub_pool->base_index = base_index;\r\nbase_index += sub_pool->size;\r\nif (sub_pool->base_index + sub_pool->size > pool->pool_size)\r\nsub_pool->size = pool->pool_size - sub_pool->base_index;\r\n}\r\nmlxsw_sp->counter_pool = pool;\r\nreturn 0;\r\nerr_usage_alloc:\r\nkfree(pool);\r\nreturn err;\r\n}\r\nvoid mlxsw_sp_counter_pool_fini(struct mlxsw_sp *mlxsw_sp)\r\n{\r\nstruct mlxsw_sp_counter_pool *pool = mlxsw_sp->counter_pool;\r\nWARN_ON(find_first_bit(pool->usage, pool->pool_size) !=\r\npool->pool_size);\r\nkfree(pool->usage);\r\nkfree(pool);\r\n}\r\nint mlxsw_sp_counter_alloc(struct mlxsw_sp *mlxsw_sp,\r\nenum mlxsw_sp_counter_sub_pool_id sub_pool_id,\r\nunsigned int *p_counter_index)\r\n{\r\nstruct mlxsw_sp_counter_pool *pool = mlxsw_sp->counter_pool;\r\nstruct mlxsw_sp_counter_sub_pool *sub_pool;\r\nunsigned int entry_index;\r\nunsigned int stop_index;\r\nint i;\r\nsub_pool = &mlxsw_sp_counter_sub_pools[sub_pool_id];\r\nstop_index = sub_pool->base_index + sub_pool->size;\r\nentry_index = sub_pool->base_index;\r\nentry_index = find_next_zero_bit(pool->usage, stop_index, entry_index);\r\nif (entry_index == stop_index)\r\nreturn -ENOBUFS;\r\nif (entry_index + sub_pool->entry_size > stop_index)\r\nreturn -ENOBUFS;\r\nfor (i = 0; i < sub_pool->entry_size; i++)\r\n__set_bit(entry_index + i, pool->usage);\r\n*p_counter_index = entry_index;\r\nreturn 0;\r\n}\r\nvoid mlxsw_sp_counter_free(struct mlxsw_sp *mlxsw_sp,\r\nenum mlxsw_sp_counter_sub_pool_id sub_pool_id,\r\nunsigned int counter_index)\r\n{\r\nstruct mlxsw_sp_counter_pool *pool = mlxsw_sp->counter_pool;\r\nstruct mlxsw_sp_counter_sub_pool *sub_pool;\r\nint i;\r\nif (WARN_ON(counter_index >= pool->pool_size))\r\nreturn;\r\nsub_pool = &mlxsw_sp_counter_sub_pools[sub_pool_id];\r\nfor (i = 0; i < sub_pool->entry_size; i++)\r\n__clear_bit(counter_index + i, pool->usage);\r\n}
