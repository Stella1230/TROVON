static inline struct stm32_pwm *to_stm32_pwm_dev(struct pwm_chip *chip)\r\n{\r\nreturn container_of(chip, struct stm32_pwm, chip);\r\n}\r\nstatic u32 active_channels(struct stm32_pwm *dev)\r\n{\r\nu32 ccer;\r\nregmap_read(dev->regmap, TIM_CCER, &ccer);\r\nreturn ccer & TIM_CCER_CCXE;\r\n}\r\nstatic int write_ccrx(struct stm32_pwm *dev, int ch, u32 value)\r\n{\r\nswitch (ch) {\r\ncase 0:\r\nreturn regmap_write(dev->regmap, TIM_CCR1, value);\r\ncase 1:\r\nreturn regmap_write(dev->regmap, TIM_CCR2, value);\r\ncase 2:\r\nreturn regmap_write(dev->regmap, TIM_CCR3, value);\r\ncase 3:\r\nreturn regmap_write(dev->regmap, TIM_CCR4, value);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int stm32_pwm_config(struct stm32_pwm *priv, int ch,\r\nint duty_ns, int period_ns)\r\n{\r\nunsigned long long prd, div, dty;\r\nunsigned int prescaler = 0;\r\nu32 ccmr, mask, shift;\r\ndiv = (unsigned long long)clk_get_rate(priv->clk) * period_ns;\r\ndo_div(div, NSEC_PER_SEC);\r\nprd = div;\r\nwhile (div > priv->max_arr) {\r\nprescaler++;\r\ndiv = prd;\r\ndo_div(div, prescaler + 1);\r\n}\r\nprd = div;\r\nif (prescaler > MAX_TIM_PSC)\r\nreturn -EINVAL;\r\nif (active_channels(priv) & ~(1 << ch * 4)) {\r\nu32 psc, arr;\r\nregmap_read(priv->regmap, TIM_PSC, &psc);\r\nregmap_read(priv->regmap, TIM_ARR, &arr);\r\nif ((psc != prescaler) || (arr != prd - 1))\r\nreturn -EBUSY;\r\n}\r\nregmap_write(priv->regmap, TIM_PSC, prescaler);\r\nregmap_write(priv->regmap, TIM_ARR, prd - 1);\r\nregmap_update_bits(priv->regmap, TIM_CR1, TIM_CR1_ARPE, TIM_CR1_ARPE);\r\ndty = prd * duty_ns;\r\ndo_div(dty, period_ns);\r\nwrite_ccrx(priv, ch, dty);\r\nshift = (ch & 0x1) * CCMR_CHANNEL_SHIFT;\r\nccmr = (TIM_CCMR_PE | TIM_CCMR_M1) << shift;\r\nmask = CCMR_CHANNEL_MASK << shift;\r\nif (ch < 2)\r\nregmap_update_bits(priv->regmap, TIM_CCMR1, mask, ccmr);\r\nelse\r\nregmap_update_bits(priv->regmap, TIM_CCMR2, mask, ccmr);\r\nregmap_update_bits(priv->regmap, TIM_BDTR,\r\nTIM_BDTR_MOE | TIM_BDTR_AOE,\r\nTIM_BDTR_MOE | TIM_BDTR_AOE);\r\nreturn 0;\r\n}\r\nstatic int stm32_pwm_set_polarity(struct stm32_pwm *priv, int ch,\r\nenum pwm_polarity polarity)\r\n{\r\nu32 mask;\r\nmask = TIM_CCER_CC1P << (ch * 4);\r\nif (priv->have_complementary_output)\r\nmask |= TIM_CCER_CC1NP << (ch * 4);\r\nregmap_update_bits(priv->regmap, TIM_CCER, mask,\r\npolarity == PWM_POLARITY_NORMAL ? 0 : mask);\r\nreturn 0;\r\n}\r\nstatic int stm32_pwm_enable(struct stm32_pwm *priv, int ch)\r\n{\r\nu32 mask;\r\nint ret;\r\nret = clk_enable(priv->clk);\r\nif (ret)\r\nreturn ret;\r\nmask = TIM_CCER_CC1E << (ch * 4);\r\nif (priv->have_complementary_output)\r\nmask |= TIM_CCER_CC1NE << (ch * 4);\r\nregmap_update_bits(priv->regmap, TIM_CCER, mask, mask);\r\nregmap_update_bits(priv->regmap, TIM_EGR, TIM_EGR_UG, TIM_EGR_UG);\r\nregmap_update_bits(priv->regmap, TIM_CR1, TIM_CR1_CEN, TIM_CR1_CEN);\r\nreturn 0;\r\n}\r\nstatic void stm32_pwm_disable(struct stm32_pwm *priv, int ch)\r\n{\r\nu32 mask;\r\nmask = TIM_CCER_CC1E << (ch * 4);\r\nif (priv->have_complementary_output)\r\nmask |= TIM_CCER_CC1NE << (ch * 4);\r\nregmap_update_bits(priv->regmap, TIM_CCER, mask, 0);\r\nif (!active_channels(priv))\r\nregmap_update_bits(priv->regmap, TIM_CR1, TIM_CR1_CEN, 0);\r\nclk_disable(priv->clk);\r\n}\r\nstatic int stm32_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\r\nstruct pwm_state *state)\r\n{\r\nbool enabled;\r\nstruct stm32_pwm *priv = to_stm32_pwm_dev(chip);\r\nint ret;\r\nenabled = pwm->state.enabled;\r\nif (enabled && !state->enabled) {\r\nstm32_pwm_disable(priv, pwm->hwpwm);\r\nreturn 0;\r\n}\r\nif (state->polarity != pwm->state.polarity)\r\nstm32_pwm_set_polarity(priv, pwm->hwpwm, state->polarity);\r\nret = stm32_pwm_config(priv, pwm->hwpwm,\r\nstate->duty_cycle, state->period);\r\nif (ret)\r\nreturn ret;\r\nif (!enabled && state->enabled)\r\nret = stm32_pwm_enable(priv, pwm->hwpwm);\r\nreturn ret;\r\n}\r\nstatic int stm32_pwm_set_breakinput(struct stm32_pwm *priv,\r\nint index, int level, int filter)\r\n{\r\nu32 bke = (index == 0) ? TIM_BDTR_BKE : TIM_BDTR_BK2E;\r\nint shift = (index == 0) ? TIM_BDTR_BKF_SHIFT : TIM_BDTR_BK2F_SHIFT;\r\nu32 mask = (index == 0) ? TIM_BDTR_BKE | TIM_BDTR_BKP | TIM_BDTR_BKF\r\n: TIM_BDTR_BK2E | TIM_BDTR_BK2P | TIM_BDTR_BK2F;\r\nu32 bdtr = bke;\r\nif (level)\r\nbdtr |= TIM_BDTR_BKP | TIM_BDTR_BK2P;\r\nbdtr |= (filter & TIM_BDTR_BKF_MASK) << shift;\r\nregmap_update_bits(priv->regmap, TIM_BDTR, mask, bdtr);\r\nregmap_read(priv->regmap, TIM_BDTR, &bdtr);\r\nreturn (bdtr & bke) ? 0 : -EINVAL;\r\n}\r\nstatic int stm32_pwm_apply_breakinputs(struct stm32_pwm *priv,\r\nstruct device_node *np)\r\n{\r\nstruct stm32_breakinput breakinput[MAX_BREAKINPUT];\r\nint nb, ret, i, array_size;\r\nnb = of_property_count_elems_of_size(np, "st,breakinput",\r\nsizeof(struct stm32_breakinput));\r\nif (nb <= 0)\r\nreturn 0;\r\nif (nb > MAX_BREAKINPUT)\r\nreturn -EINVAL;\r\narray_size = nb * sizeof(struct stm32_breakinput) / sizeof(u32);\r\nret = of_property_read_u32_array(np, "st,breakinput",\r\n(u32 *)breakinput, array_size);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < nb && !ret; i++) {\r\nret = stm32_pwm_set_breakinput(priv,\r\nbreakinput[i].index,\r\nbreakinput[i].level,\r\nbreakinput[i].filter);\r\n}\r\nreturn ret;\r\n}\r\nstatic void stm32_pwm_detect_complementary(struct stm32_pwm *priv)\r\n{\r\nu32 ccer;\r\nregmap_update_bits(priv->regmap,\r\nTIM_CCER, TIM_CCER_CC1NE, TIM_CCER_CC1NE);\r\nregmap_read(priv->regmap, TIM_CCER, &ccer);\r\nregmap_update_bits(priv->regmap, TIM_CCER, TIM_CCER_CC1NE, 0);\r\npriv->have_complementary_output = (ccer != 0);\r\n}\r\nstatic int stm32_pwm_detect_channels(struct stm32_pwm *priv)\r\n{\r\nu32 ccer;\r\nint npwm = 0;\r\nregmap_update_bits(priv->regmap,\r\nTIM_CCER, TIM_CCER_CCXE, TIM_CCER_CCXE);\r\nregmap_read(priv->regmap, TIM_CCER, &ccer);\r\nregmap_update_bits(priv->regmap, TIM_CCER, TIM_CCER_CCXE, 0);\r\nif (ccer & TIM_CCER_CC1E)\r\nnpwm++;\r\nif (ccer & TIM_CCER_CC2E)\r\nnpwm++;\r\nif (ccer & TIM_CCER_CC3E)\r\nnpwm++;\r\nif (ccer & TIM_CCER_CC4E)\r\nnpwm++;\r\nreturn npwm;\r\n}\r\nstatic int stm32_pwm_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np = dev->of_node;\r\nstruct stm32_timers *ddata = dev_get_drvdata(pdev->dev.parent);\r\nstruct stm32_pwm *priv;\r\nint ret;\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->regmap = ddata->regmap;\r\npriv->clk = ddata->clk;\r\npriv->max_arr = ddata->max_arr;\r\nif (!priv->regmap || !priv->clk)\r\nreturn -EINVAL;\r\nret = stm32_pwm_apply_breakinputs(priv, np);\r\nif (ret)\r\nreturn ret;\r\nstm32_pwm_detect_complementary(priv);\r\npriv->chip.base = -1;\r\npriv->chip.dev = dev;\r\npriv->chip.ops = &stm32pwm_ops;\r\npriv->chip.npwm = stm32_pwm_detect_channels(priv);\r\nret = pwmchip_add(&priv->chip);\r\nif (ret < 0)\r\nreturn ret;\r\nplatform_set_drvdata(pdev, priv);\r\nreturn 0;\r\n}\r\nstatic int stm32_pwm_remove(struct platform_device *pdev)\r\n{\r\nstruct stm32_pwm *priv = platform_get_drvdata(pdev);\r\nunsigned int i;\r\nfor (i = 0; i < priv->chip.npwm; i++)\r\npwm_disable(&priv->chip.pwms[i]);\r\npwmchip_remove(&priv->chip);\r\nreturn 0;\r\n}
