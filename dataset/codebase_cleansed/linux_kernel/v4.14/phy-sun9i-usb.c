static void sun9i_usb_phy_passby(struct sun9i_usb_phy *phy, int enable)\r\n{\r\nu32 bits, reg_value;\r\nbits = SUNXI_AHB_INCR16_BURST_EN | SUNXI_AHB_INCR8_BURST_EN |\r\nSUNXI_AHB_INCR4_BURST_EN | SUNXI_AHB_INCRX_ALIGN_EN |\r\nSUNXI_ULPI_BYPASS_EN;\r\nif (phy->type == USBPHY_INTERFACE_MODE_HSIC)\r\nbits |= SUNXI_HSIC | SUNXI_EHCI_HS_FORCE |\r\nSUNXI_HSIC_CONNECT_DET | SUNXI_HSIC_CONNECT_INT;\r\nreg_value = readl(phy->pmu);\r\nif (enable)\r\nreg_value |= bits;\r\nelse\r\nreg_value &= ~bits;\r\nwritel(reg_value, phy->pmu);\r\n}\r\nstatic int sun9i_usb_phy_init(struct phy *_phy)\r\n{\r\nstruct sun9i_usb_phy *phy = phy_get_drvdata(_phy);\r\nint ret;\r\nret = clk_prepare_enable(phy->clk);\r\nif (ret)\r\ngoto err_clk;\r\nret = clk_prepare_enable(phy->hsic_clk);\r\nif (ret)\r\ngoto err_hsic_clk;\r\nret = reset_control_deassert(phy->reset);\r\nif (ret)\r\ngoto err_reset;\r\nsun9i_usb_phy_passby(phy, 1);\r\nreturn 0;\r\nerr_reset:\r\nclk_disable_unprepare(phy->hsic_clk);\r\nerr_hsic_clk:\r\nclk_disable_unprepare(phy->clk);\r\nerr_clk:\r\nreturn ret;\r\n}\r\nstatic int sun9i_usb_phy_exit(struct phy *_phy)\r\n{\r\nstruct sun9i_usb_phy *phy = phy_get_drvdata(_phy);\r\nsun9i_usb_phy_passby(phy, 0);\r\nreset_control_assert(phy->reset);\r\nclk_disable_unprepare(phy->hsic_clk);\r\nclk_disable_unprepare(phy->clk);\r\nreturn 0;\r\n}\r\nstatic int sun9i_usb_phy_probe(struct platform_device *pdev)\r\n{\r\nstruct sun9i_usb_phy *phy;\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np = dev->of_node;\r\nstruct phy_provider *phy_provider;\r\nstruct resource *res;\r\nphy = devm_kzalloc(dev, sizeof(*phy), GFP_KERNEL);\r\nif (!phy)\r\nreturn -ENOMEM;\r\nphy->type = of_usb_get_phy_mode(np);\r\nif (phy->type == USBPHY_INTERFACE_MODE_HSIC) {\r\nphy->clk = devm_clk_get(dev, "hsic_480M");\r\nif (IS_ERR(phy->clk)) {\r\ndev_err(dev, "failed to get hsic_480M clock\n");\r\nreturn PTR_ERR(phy->clk);\r\n}\r\nphy->hsic_clk = devm_clk_get(dev, "hsic_12M");\r\nif (IS_ERR(phy->hsic_clk)) {\r\ndev_err(dev, "failed to get hsic_12M clock\n");\r\nreturn PTR_ERR(phy->hsic_clk);\r\n}\r\nphy->reset = devm_reset_control_get(dev, "hsic");\r\nif (IS_ERR(phy->reset)) {\r\ndev_err(dev, "failed to get reset control\n");\r\nreturn PTR_ERR(phy->reset);\r\n}\r\n} else {\r\nphy->clk = devm_clk_get(dev, "phy");\r\nif (IS_ERR(phy->clk)) {\r\ndev_err(dev, "failed to get phy clock\n");\r\nreturn PTR_ERR(phy->clk);\r\n}\r\nphy->reset = devm_reset_control_get(dev, "phy");\r\nif (IS_ERR(phy->reset)) {\r\ndev_err(dev, "failed to get reset control\n");\r\nreturn PTR_ERR(phy->reset);\r\n}\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nphy->pmu = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(phy->pmu))\r\nreturn PTR_ERR(phy->pmu);\r\nphy->phy = devm_phy_create(dev, NULL, &sun9i_usb_phy_ops);\r\nif (IS_ERR(phy->phy)) {\r\ndev_err(dev, "failed to create PHY\n");\r\nreturn PTR_ERR(phy->phy);\r\n}\r\nphy_set_drvdata(phy->phy, phy);\r\nphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\r\nreturn PTR_ERR_OR_ZERO(phy_provider);\r\n}
