static int tur_done(struct scsi_device *sdev, struct hp_sw_dh_data *h,\r\nstruct scsi_sense_hdr *sshdr)\r\n{\r\nint ret = SCSI_DH_IO;\r\nswitch (sshdr->sense_key) {\r\ncase UNIT_ATTENTION:\r\nret = SCSI_DH_IMM_RETRY;\r\nbreak;\r\ncase NOT_READY:\r\nif (sshdr->asc == 0x04 && sshdr->ascq == 2) {\r\nh->path_state = HP_SW_PATH_PASSIVE;\r\nret = SCSI_DH_OK;\r\nbreak;\r\n}\r\ndefault:\r\nsdev_printk(KERN_WARNING, sdev,\r\n"%s: sending tur failed, sense %x/%x/%x\n",\r\nHP_SW_NAME, sshdr->sense_key, sshdr->asc,\r\nsshdr->ascq);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int hp_sw_tur(struct scsi_device *sdev, struct hp_sw_dh_data *h)\r\n{\r\nunsigned char cmd[6] = { TEST_UNIT_READY };\r\nstruct scsi_sense_hdr sshdr;\r\nint ret = SCSI_DH_OK, res;\r\nu64 req_flags = REQ_FAILFAST_DEV | REQ_FAILFAST_TRANSPORT |\r\nREQ_FAILFAST_DRIVER;\r\nretry:\r\nres = scsi_execute(sdev, cmd, DMA_NONE, NULL, 0, NULL, &sshdr,\r\nHP_SW_TIMEOUT, HP_SW_RETRIES, req_flags, 0, NULL);\r\nif (res) {\r\nif (scsi_sense_valid(&sshdr))\r\nret = tur_done(sdev, h, &sshdr);\r\nelse {\r\nsdev_printk(KERN_WARNING, sdev,\r\n"%s: sending tur failed with %x\n",\r\nHP_SW_NAME, res);\r\nret = SCSI_DH_IO;\r\n}\r\n} else {\r\nh->path_state = HP_SW_PATH_ACTIVE;\r\nret = SCSI_DH_OK;\r\n}\r\nif (ret == SCSI_DH_IMM_RETRY)\r\ngoto retry;\r\nreturn ret;\r\n}\r\nstatic int hp_sw_start_stop(struct hp_sw_dh_data *h)\r\n{\r\nunsigned char cmd[6] = { START_STOP, 0, 0, 0, 1, 0 };\r\nstruct scsi_sense_hdr sshdr;\r\nstruct scsi_device *sdev = h->sdev;\r\nint res, rc = SCSI_DH_OK;\r\nint retry_cnt = HP_SW_RETRIES;\r\nu64 req_flags = REQ_FAILFAST_DEV | REQ_FAILFAST_TRANSPORT |\r\nREQ_FAILFAST_DRIVER;\r\nretry:\r\nres = scsi_execute(sdev, cmd, DMA_NONE, NULL, 0, NULL, &sshdr,\r\nHP_SW_TIMEOUT, HP_SW_RETRIES, req_flags, 0, NULL);\r\nif (res) {\r\nif (!scsi_sense_valid(&sshdr)) {\r\nsdev_printk(KERN_WARNING, sdev,\r\n"%s: sending start_stop_unit failed, "\r\n"no sense available\n", HP_SW_NAME);\r\nreturn SCSI_DH_IO;\r\n}\r\nswitch (sshdr.sense_key) {\r\ncase NOT_READY:\r\nif (sshdr.asc == 0x04 && sshdr.ascq == 3) {\r\nif (--retry_cnt)\r\ngoto retry;\r\nrc = SCSI_DH_RETRY;\r\nbreak;\r\n}\r\ndefault:\r\nsdev_printk(KERN_WARNING, sdev,\r\n"%s: sending start_stop_unit failed, "\r\n"sense %x/%x/%x\n", HP_SW_NAME,\r\nsshdr.sense_key, sshdr.asc, sshdr.ascq);\r\nrc = SCSI_DH_IO;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int hp_sw_prep_fn(struct scsi_device *sdev, struct request *req)\r\n{\r\nstruct hp_sw_dh_data *h = sdev->handler_data;\r\nint ret = BLKPREP_OK;\r\nif (h->path_state != HP_SW_PATH_ACTIVE) {\r\nret = BLKPREP_KILL;\r\nreq->rq_flags |= RQF_QUIET;\r\n}\r\nreturn ret;\r\n}\r\nstatic int hp_sw_activate(struct scsi_device *sdev,\r\nactivate_complete fn, void *data)\r\n{\r\nint ret = SCSI_DH_OK;\r\nstruct hp_sw_dh_data *h = sdev->handler_data;\r\nret = hp_sw_tur(sdev, h);\r\nif (ret == SCSI_DH_OK && h->path_state == HP_SW_PATH_PASSIVE)\r\nret = hp_sw_start_stop(h);\r\nif (fn)\r\nfn(data, ret);\r\nreturn 0;\r\n}\r\nstatic int hp_sw_bus_attach(struct scsi_device *sdev)\r\n{\r\nstruct hp_sw_dh_data *h;\r\nint ret;\r\nh = kzalloc(sizeof(*h), GFP_KERNEL);\r\nif (!h)\r\nreturn -ENOMEM;\r\nh->path_state = HP_SW_PATH_UNINITIALIZED;\r\nh->retries = HP_SW_RETRIES;\r\nh->sdev = sdev;\r\nret = hp_sw_tur(sdev, h);\r\nif (ret != SCSI_DH_OK || h->path_state == HP_SW_PATH_UNINITIALIZED)\r\ngoto failed;\r\nsdev_printk(KERN_INFO, sdev, "%s: attached to %s path\n",\r\nHP_SW_NAME, h->path_state == HP_SW_PATH_ACTIVE?\r\n"active":"passive");\r\nsdev->handler_data = h;\r\nreturn 0;\r\nfailed:\r\nkfree(h);\r\nreturn -EINVAL;\r\n}\r\nstatic void hp_sw_bus_detach( struct scsi_device *sdev )\r\n{\r\nkfree(sdev->handler_data);\r\nsdev->handler_data = NULL;\r\n}\r\nstatic int __init hp_sw_init(void)\r\n{\r\nreturn scsi_register_device_handler(&hp_sw_dh);\r\n}\r\nstatic void __exit hp_sw_exit(void)\r\n{\r\nscsi_unregister_device_handler(&hp_sw_dh);\r\n}
