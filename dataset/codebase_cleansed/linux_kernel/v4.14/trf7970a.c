static int trf7970a_cmd(struct trf7970a *trf, u8 opcode)\r\n{\r\nu8 cmd = TRF7970A_CMD_BIT_CTRL | TRF7970A_CMD_BIT_OPCODE(opcode);\r\nint ret;\r\ndev_dbg(trf->dev, "cmd: 0x%x\n", cmd);\r\nret = spi_write(trf->spi, &cmd, 1);\r\nif (ret)\r\ndev_err(trf->dev, "%s - cmd: 0x%x, ret: %d\n", __func__, cmd,\r\nret);\r\nreturn ret;\r\n}\r\nstatic int trf7970a_read(struct trf7970a *trf, u8 reg, u8 *val)\r\n{\r\nu8 addr = TRF7970A_CMD_BIT_RW | reg;\r\nint ret;\r\nret = spi_write_then_read(trf->spi, &addr, 1, val, 1);\r\nif (ret)\r\ndev_err(trf->dev, "%s - addr: 0x%x, ret: %d\n", __func__, addr,\r\nret);\r\ndev_dbg(trf->dev, "read(0x%x): 0x%x\n", addr, *val);\r\nreturn ret;\r\n}\r\nstatic int trf7970a_read_cont(struct trf7970a *trf, u8 reg, u8 *buf,\r\nsize_t len)\r\n{\r\nu8 addr = reg | TRF7970A_CMD_BIT_RW | TRF7970A_CMD_BIT_CONTINUOUS;\r\nstruct spi_transfer t[2];\r\nstruct spi_message m;\r\nint ret;\r\ndev_dbg(trf->dev, "read_cont(0x%x, %zd)\n", addr, len);\r\nspi_message_init(&m);\r\nmemset(&t, 0, sizeof(t));\r\nt[0].tx_buf = &addr;\r\nt[0].len = sizeof(addr);\r\nspi_message_add_tail(&t[0], &m);\r\nt[1].rx_buf = buf;\r\nt[1].len = len;\r\nspi_message_add_tail(&t[1], &m);\r\nret = spi_sync(trf->spi, &m);\r\nif (ret)\r\ndev_err(trf->dev, "%s - addr: 0x%x, ret: %d\n", __func__, addr,\r\nret);\r\nreturn ret;\r\n}\r\nstatic int trf7970a_write(struct trf7970a *trf, u8 reg, u8 val)\r\n{\r\nu8 buf[2] = { reg, val };\r\nint ret;\r\ndev_dbg(trf->dev, "write(0x%x): 0x%x\n", reg, val);\r\nret = spi_write(trf->spi, buf, 2);\r\nif (ret)\r\ndev_err(trf->dev, "%s - write: 0x%x 0x%x, ret: %d\n", __func__,\r\nbuf[0], buf[1], ret);\r\nreturn ret;\r\n}\r\nstatic int trf7970a_read_irqstatus(struct trf7970a *trf, u8 *status)\r\n{\r\nint ret;\r\nu8 buf[2];\r\nu8 addr;\r\naddr = TRF7970A_IRQ_STATUS | TRF7970A_CMD_BIT_RW;\r\nif (trf->quirks & TRF7970A_QUIRK_IRQ_STATUS_READ) {\r\naddr |= TRF7970A_CMD_BIT_CONTINUOUS;\r\nret = spi_write_then_read(trf->spi, &addr, 1, buf, 2);\r\n} else {\r\nret = spi_write_then_read(trf->spi, &addr, 1, buf, 1);\r\n}\r\nif (ret)\r\ndev_err(trf->dev, "%s - irqstatus: Status read failed: %d\n",\r\n__func__, ret);\r\nelse\r\n*status = buf[0];\r\nreturn ret;\r\n}\r\nstatic int trf7970a_read_target_proto(struct trf7970a *trf, u8 *target_proto)\r\n{\r\nint ret;\r\nu8 buf[2];\r\nu8 addr;\r\naddr = TRF79070A_NFC_TARGET_PROTOCOL | TRF7970A_CMD_BIT_RW |\r\nTRF7970A_CMD_BIT_CONTINUOUS;\r\nret = spi_write_then_read(trf->spi, &addr, 1, buf, 2);\r\nif (ret)\r\ndev_err(trf->dev, "%s - target_proto: Read failed: %d\n",\r\n__func__, ret);\r\nelse\r\n*target_proto = buf[0];\r\nreturn ret;\r\n}\r\nstatic int trf7970a_mode_detect(struct trf7970a *trf, u8 *rf_tech)\r\n{\r\nint ret;\r\nu8 target_proto, tech;\r\nret = trf7970a_read_target_proto(trf, &target_proto);\r\nif (ret)\r\nreturn ret;\r\nswitch (target_proto) {\r\ncase TRF79070A_NFC_TARGET_PROTOCOL_106A:\r\ntech = NFC_DIGITAL_RF_TECH_106A;\r\nbreak;\r\ncase TRF79070A_NFC_TARGET_PROTOCOL_106B:\r\ntech = NFC_DIGITAL_RF_TECH_106B;\r\nbreak;\r\ncase TRF79070A_NFC_TARGET_PROTOCOL_212F:\r\ntech = NFC_DIGITAL_RF_TECH_212F;\r\nbreak;\r\ncase TRF79070A_NFC_TARGET_PROTOCOL_424F:\r\ntech = NFC_DIGITAL_RF_TECH_424F;\r\nbreak;\r\ndefault:\r\ndev_dbg(trf->dev, "%s - mode_detect: target_proto: 0x%x\n",\r\n__func__, target_proto);\r\nreturn -EIO;\r\n}\r\n*rf_tech = tech;\r\nreturn ret;\r\n}\r\nstatic void trf7970a_send_upstream(struct trf7970a *trf)\r\n{\r\ndev_kfree_skb_any(trf->tx_skb);\r\ntrf->tx_skb = NULL;\r\nif (trf->rx_skb && !IS_ERR(trf->rx_skb) && !trf->aborting)\r\nprint_hex_dump_debug("trf7970a rx data: ", DUMP_PREFIX_NONE,\r\n16, 1, trf->rx_skb->data, trf->rx_skb->len,\r\nfalse);\r\ntrf->state = TRF7970A_ST_IDLE;\r\nif (trf->aborting) {\r\ndev_dbg(trf->dev, "Abort process complete\n");\r\nif (!IS_ERR(trf->rx_skb)) {\r\nkfree_skb(trf->rx_skb);\r\ntrf->rx_skb = ERR_PTR(-ECANCELED);\r\n}\r\ntrf->aborting = false;\r\n}\r\ntrf->cb(trf->ddev, trf->cb_arg, trf->rx_skb);\r\ntrf->rx_skb = NULL;\r\n}\r\nstatic void trf7970a_send_err_upstream(struct trf7970a *trf, int errno)\r\n{\r\ndev_dbg(trf->dev, "Error - state: %d, errno: %d\n", trf->state, errno);\r\ncancel_delayed_work(&trf->timeout_work);\r\nkfree_skb(trf->rx_skb);\r\ntrf->rx_skb = ERR_PTR(errno);\r\ntrf7970a_send_upstream(trf);\r\n}\r\nstatic int trf7970a_transmit(struct trf7970a *trf, struct sk_buff *skb,\r\nunsigned int len, u8 *prefix,\r\nunsigned int prefix_len)\r\n{\r\nstruct spi_transfer t[2];\r\nstruct spi_message m;\r\nunsigned int timeout;\r\nint ret;\r\nprint_hex_dump_debug("trf7970a tx data: ", DUMP_PREFIX_NONE,\r\n16, 1, skb->data, len, false);\r\nspi_message_init(&m);\r\nmemset(&t, 0, sizeof(t));\r\nt[0].tx_buf = prefix;\r\nt[0].len = prefix_len;\r\nspi_message_add_tail(&t[0], &m);\r\nt[1].tx_buf = skb->data;\r\nt[1].len = len;\r\nspi_message_add_tail(&t[1], &m);\r\nret = spi_sync(trf->spi, &m);\r\nif (ret) {\r\ndev_err(trf->dev, "%s - Can't send tx data: %d\n", __func__,\r\nret);\r\nreturn ret;\r\n}\r\nskb_pull(skb, len);\r\nif (skb->len > 0) {\r\ntrf->state = TRF7970A_ST_WAIT_FOR_TX_FIFO;\r\ntimeout = TRF7970A_WAIT_FOR_FIFO_DRAIN_TIMEOUT;\r\n} else {\r\nif (trf->issue_eof) {\r\ntrf->state = TRF7970A_ST_WAIT_TO_ISSUE_EOF;\r\ntimeout = TRF7970A_WAIT_TO_ISSUE_ISO15693_EOF;\r\n} else {\r\ntrf->state = TRF7970A_ST_WAIT_FOR_RX_DATA;\r\nif (!trf->timeout)\r\ntimeout = TRF7970A_WAIT_FOR_TX_IRQ;\r\nelse\r\ntimeout = trf->timeout;\r\n}\r\n}\r\ndev_dbg(trf->dev, "Setting timeout for %d ms, state: %d\n", timeout,\r\ntrf->state);\r\nschedule_delayed_work(&trf->timeout_work, msecs_to_jiffies(timeout));\r\nreturn 0;\r\n}\r\nstatic void trf7970a_fill_fifo(struct trf7970a *trf)\r\n{\r\nstruct sk_buff *skb = trf->tx_skb;\r\nunsigned int len;\r\nint ret;\r\nu8 fifo_bytes;\r\nu8 prefix;\r\nret = trf7970a_read(trf, TRF7970A_FIFO_STATUS, &fifo_bytes);\r\nif (ret) {\r\ntrf7970a_send_err_upstream(trf, ret);\r\nreturn;\r\n}\r\ndev_dbg(trf->dev, "Filling FIFO - fifo_bytes: 0x%x\n", fifo_bytes);\r\nfifo_bytes &= ~TRF7970A_FIFO_STATUS_OVERFLOW;\r\nlen = TRF7970A_FIFO_SIZE - fifo_bytes;\r\nif (!len) {\r\nschedule_delayed_work(&trf->timeout_work,\r\nmsecs_to_jiffies(TRF7970A_WAIT_FOR_FIFO_DRAIN_TIMEOUT));\r\nreturn;\r\n}\r\nlen = min(skb->len, len);\r\nprefix = TRF7970A_CMD_BIT_CONTINUOUS | TRF7970A_FIFO_IO_REGISTER;\r\nret = trf7970a_transmit(trf, skb, len, &prefix, sizeof(prefix));\r\nif (ret)\r\ntrf7970a_send_err_upstream(trf, ret);\r\n}\r\nstatic void trf7970a_drain_fifo(struct trf7970a *trf, u8 status)\r\n{\r\nstruct sk_buff *skb = trf->rx_skb;\r\nint ret;\r\nu8 fifo_bytes;\r\nif (status & TRF7970A_IRQ_STATUS_ERROR) {\r\ntrf7970a_send_err_upstream(trf, -EIO);\r\nreturn;\r\n}\r\nret = trf7970a_read(trf, TRF7970A_FIFO_STATUS, &fifo_bytes);\r\nif (ret) {\r\ntrf7970a_send_err_upstream(trf, ret);\r\nreturn;\r\n}\r\ndev_dbg(trf->dev, "Draining FIFO - fifo_bytes: 0x%x\n", fifo_bytes);\r\nfifo_bytes &= ~TRF7970A_FIFO_STATUS_OVERFLOW;\r\nif (!fifo_bytes)\r\ngoto no_rx_data;\r\nif (fifo_bytes > skb_tailroom(skb)) {\r\nskb = skb_copy_expand(skb, skb_headroom(skb),\r\nmax_t(int, fifo_bytes,\r\nTRF7970A_RX_SKB_ALLOC_SIZE),\r\nGFP_KERNEL);\r\nif (!skb) {\r\ntrf7970a_send_err_upstream(trf, -ENOMEM);\r\nreturn;\r\n}\r\nkfree_skb(trf->rx_skb);\r\ntrf->rx_skb = skb;\r\n}\r\nret = trf7970a_read_cont(trf, TRF7970A_FIFO_IO_REGISTER,\r\nskb_put(skb, fifo_bytes), fifo_bytes);\r\nif (ret) {\r\ntrf7970a_send_err_upstream(trf, ret);\r\nreturn;\r\n}\r\nif ((trf->framing == NFC_DIGITAL_FRAMING_NFCA_T2T) && (skb->len == 1) &&\r\n(trf->special_fcn_reg1 == TRF7970A_SPECIAL_FCN_REG1_4_BIT_RX)) {\r\nskb->data[0] >>= 4;\r\nstatus = TRF7970A_IRQ_STATUS_SRX;\r\n} else {\r\ntrf->state = TRF7970A_ST_WAIT_FOR_RX_DATA_CONT;\r\nret = trf7970a_read(trf, TRF7970A_FIFO_STATUS, &fifo_bytes);\r\nif (ret) {\r\ntrf7970a_send_err_upstream(trf, ret);\r\nreturn;\r\n}\r\nfifo_bytes &= ~TRF7970A_FIFO_STATUS_OVERFLOW;\r\nif (fifo_bytes)\r\nstatus = 0;\r\n}\r\nno_rx_data:\r\nif (status == TRF7970A_IRQ_STATUS_SRX) {\r\ntrf7970a_send_upstream(trf);\r\nreturn;\r\n}\r\ndev_dbg(trf->dev, "Setting timeout for %d ms\n",\r\nTRF7970A_WAIT_FOR_RX_DATA_TIMEOUT);\r\nschedule_delayed_work(&trf->timeout_work,\r\nmsecs_to_jiffies(TRF7970A_WAIT_FOR_RX_DATA_TIMEOUT));\r\n}\r\nstatic irqreturn_t trf7970a_irq(int irq, void *dev_id)\r\n{\r\nstruct trf7970a *trf = dev_id;\r\nint ret;\r\nu8 status, fifo_bytes, iso_ctrl;\r\nmutex_lock(&trf->lock);\r\nif (trf->state == TRF7970A_ST_RF_OFF) {\r\nmutex_unlock(&trf->lock);\r\nreturn IRQ_NONE;\r\n}\r\nret = trf7970a_read_irqstatus(trf, &status);\r\nif (ret) {\r\nmutex_unlock(&trf->lock);\r\nreturn IRQ_NONE;\r\n}\r\ndev_dbg(trf->dev, "IRQ - state: %d, status: 0x%x\n", trf->state,\r\nstatus);\r\nif (!status) {\r\nmutex_unlock(&trf->lock);\r\nreturn IRQ_NONE;\r\n}\r\nswitch (trf->state) {\r\ncase TRF7970A_ST_IDLE:\r\ncase TRF7970A_ST_IDLE_RX_BLOCKED:\r\nif (trf->is_initiator && (status & TRF7970A_IRQ_STATUS_ERROR)) {\r\ntrf7970a_cmd(trf, TRF7970A_CMD_BLOCK_RX);\r\ntrf->state = TRF7970A_ST_IDLE_RX_BLOCKED;\r\n}\r\ntrf7970a_cmd(trf, TRF7970A_CMD_FIFO_RESET);\r\nbreak;\r\ncase TRF7970A_ST_WAIT_FOR_TX_FIFO:\r\nif (status & TRF7970A_IRQ_STATUS_TX) {\r\ntrf->ignore_timeout =\r\n!cancel_delayed_work(&trf->timeout_work);\r\ntrf7970a_fill_fifo(trf);\r\n} else {\r\ntrf7970a_send_err_upstream(trf, -EIO);\r\n}\r\nbreak;\r\ncase TRF7970A_ST_WAIT_FOR_RX_DATA:\r\ncase TRF7970A_ST_WAIT_FOR_RX_DATA_CONT:\r\nif (status & TRF7970A_IRQ_STATUS_SRX) {\r\ntrf->ignore_timeout =\r\n!cancel_delayed_work(&trf->timeout_work);\r\ntrf7970a_drain_fifo(trf, status);\r\n} else if (status & TRF7970A_IRQ_STATUS_FIFO) {\r\nret = trf7970a_read(trf, TRF7970A_FIFO_STATUS,\r\n&fifo_bytes);\r\nfifo_bytes &= ~TRF7970A_FIFO_STATUS_OVERFLOW;\r\nif (ret)\r\ntrf7970a_send_err_upstream(trf, ret);\r\nelse if (!fifo_bytes)\r\ntrf7970a_cmd(trf, TRF7970A_CMD_FIFO_RESET);\r\n} else if ((status == TRF7970A_IRQ_STATUS_TX) ||\r\n(!trf->is_initiator &&\r\n(status == (TRF7970A_IRQ_STATUS_TX |\r\nTRF7970A_IRQ_STATUS_NFC_RF)))) {\r\ntrf7970a_cmd(trf, TRF7970A_CMD_FIFO_RESET);\r\nif (!trf->timeout) {\r\ntrf->ignore_timeout =\r\n!cancel_delayed_work(&trf->timeout_work);\r\ntrf->rx_skb = ERR_PTR(0);\r\ntrf7970a_send_upstream(trf);\r\nbreak;\r\n}\r\nif (trf->is_initiator)\r\nbreak;\r\niso_ctrl = trf->iso_ctrl;\r\nswitch (trf->framing) {\r\ncase NFC_DIGITAL_FRAMING_NFCA_STANDARD:\r\ntrf->tx_cmd = TRF7970A_CMD_TRANSMIT_NO_CRC;\r\niso_ctrl |= TRF7970A_ISO_CTRL_RX_CRC_N;\r\ntrf->iso_ctrl = 0xff;\r\nbreak;\r\ncase NFC_DIGITAL_FRAMING_NFCA_STANDARD_WITH_CRC_A:\r\ntrf->tx_cmd = TRF7970A_CMD_TRANSMIT;\r\niso_ctrl &= ~TRF7970A_ISO_CTRL_RX_CRC_N;\r\ntrf->iso_ctrl = 0xff;\r\nbreak;\r\ncase NFC_DIGITAL_FRAMING_NFCA_ANTICOL_COMPLETE:\r\nret = trf7970a_write(trf,\r\nTRF7970A_SPECIAL_FCN_REG1,\r\nTRF7970A_SPECIAL_FCN_REG1_14_ANTICOLL);\r\nif (ret)\r\ngoto err_unlock_exit;\r\ntrf->special_fcn_reg1 =\r\nTRF7970A_SPECIAL_FCN_REG1_14_ANTICOLL;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (iso_ctrl != trf->iso_ctrl) {\r\nret = trf7970a_write(trf, TRF7970A_ISO_CTRL,\r\niso_ctrl);\r\nif (ret)\r\ngoto err_unlock_exit;\r\ntrf->iso_ctrl = iso_ctrl;\r\n}\r\n} else {\r\ntrf7970a_send_err_upstream(trf, -EIO);\r\n}\r\nbreak;\r\ncase TRF7970A_ST_WAIT_TO_ISSUE_EOF:\r\nif (status != TRF7970A_IRQ_STATUS_TX)\r\ntrf7970a_send_err_upstream(trf, -EIO);\r\nbreak;\r\ncase TRF7970A_ST_LISTENING:\r\nif (status & TRF7970A_IRQ_STATUS_SRX) {\r\ntrf->ignore_timeout =\r\n!cancel_delayed_work(&trf->timeout_work);\r\ntrf7970a_drain_fifo(trf, status);\r\n} else if (!(status & TRF7970A_IRQ_STATUS_NFC_RF)) {\r\ntrf7970a_send_err_upstream(trf, -EIO);\r\n}\r\nbreak;\r\ncase TRF7970A_ST_LISTENING_MD:\r\nif (status & TRF7970A_IRQ_STATUS_SRX) {\r\ntrf->ignore_timeout =\r\n!cancel_delayed_work(&trf->timeout_work);\r\nret = trf7970a_mode_detect(trf, &trf->md_rf_tech);\r\nif (ret) {\r\ntrf7970a_send_err_upstream(trf, ret);\r\n} else {\r\ntrf->state = TRF7970A_ST_LISTENING;\r\ntrf7970a_drain_fifo(trf, status);\r\n}\r\n} else if (!(status & TRF7970A_IRQ_STATUS_NFC_RF)) {\r\ntrf7970a_send_err_upstream(trf, -EIO);\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(trf->dev, "%s - Driver in invalid state: %d\n",\r\n__func__, trf->state);\r\n}\r\nerr_unlock_exit:\r\nmutex_unlock(&trf->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void trf7970a_issue_eof(struct trf7970a *trf)\r\n{\r\nint ret;\r\ndev_dbg(trf->dev, "Issuing EOF\n");\r\nret = trf7970a_cmd(trf, TRF7970A_CMD_FIFO_RESET);\r\nif (ret)\r\ntrf7970a_send_err_upstream(trf, ret);\r\nret = trf7970a_cmd(trf, TRF7970A_CMD_EOF);\r\nif (ret)\r\ntrf7970a_send_err_upstream(trf, ret);\r\ntrf->state = TRF7970A_ST_WAIT_FOR_RX_DATA;\r\ndev_dbg(trf->dev, "Setting timeout for %d ms, state: %d\n",\r\ntrf->timeout, trf->state);\r\nschedule_delayed_work(&trf->timeout_work,\r\nmsecs_to_jiffies(trf->timeout));\r\n}\r\nstatic void trf7970a_timeout_work_handler(struct work_struct *work)\r\n{\r\nstruct trf7970a *trf = container_of(work, struct trf7970a,\r\ntimeout_work.work);\r\ndev_dbg(trf->dev, "Timeout - state: %d, ignore_timeout: %d\n",\r\ntrf->state, trf->ignore_timeout);\r\nmutex_lock(&trf->lock);\r\nif (trf->ignore_timeout)\r\ntrf->ignore_timeout = false;\r\nelse if (trf->state == TRF7970A_ST_WAIT_FOR_RX_DATA_CONT)\r\ntrf7970a_drain_fifo(trf, TRF7970A_IRQ_STATUS_SRX);\r\nelse if (trf->state == TRF7970A_ST_WAIT_TO_ISSUE_EOF)\r\ntrf7970a_issue_eof(trf);\r\nelse\r\ntrf7970a_send_err_upstream(trf, -ETIMEDOUT);\r\nmutex_unlock(&trf->lock);\r\n}\r\nstatic int trf7970a_init(struct trf7970a *trf)\r\n{\r\nint ret;\r\ndev_dbg(trf->dev, "Initializing device - state: %d\n", trf->state);\r\nret = trf7970a_cmd(trf, TRF7970A_CMD_SOFT_INIT);\r\nif (ret)\r\ngoto err_out;\r\nret = trf7970a_cmd(trf, TRF7970A_CMD_IDLE);\r\nif (ret)\r\ngoto err_out;\r\nret = trf7970a_write(trf, TRF7970A_REG_IO_CTRL,\r\ntrf->io_ctrl | TRF7970A_REG_IO_CTRL_VRS(0x1));\r\nif (ret)\r\ngoto err_out;\r\nret = trf7970a_write(trf, TRF7970A_NFC_TARGET_LEVEL, 0);\r\nif (ret)\r\ngoto err_out;\r\nusleep_range(1000, 2000);\r\ntrf->chip_status_ctrl &= ~TRF7970A_CHIP_STATUS_RF_ON;\r\nret = trf7970a_write(trf, TRF7970A_MODULATOR_SYS_CLK_CTRL,\r\ntrf->modulator_sys_clk_ctrl);\r\nif (ret)\r\ngoto err_out;\r\nret = trf7970a_write(trf, TRF7970A_ADJUTABLE_FIFO_IRQ_LEVELS,\r\nTRF7970A_ADJUTABLE_FIFO_IRQ_LEVELS_WLH_96 |\r\nTRF7970A_ADJUTABLE_FIFO_IRQ_LEVELS_WLL_32);\r\nif (ret)\r\ngoto err_out;\r\nret = trf7970a_write(trf, TRF7970A_SPECIAL_FCN_REG1, 0);\r\nif (ret)\r\ngoto err_out;\r\ntrf->special_fcn_reg1 = 0;\r\ntrf->iso_ctrl = 0xff;\r\nreturn 0;\r\nerr_out:\r\ndev_dbg(trf->dev, "Couldn't init device: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic void trf7970a_switch_rf_off(struct trf7970a *trf)\r\n{\r\nif ((trf->state == TRF7970A_ST_PWR_OFF) ||\r\n(trf->state == TRF7970A_ST_RF_OFF))\r\nreturn;\r\ndev_dbg(trf->dev, "Switching rf off\n");\r\ntrf->chip_status_ctrl &= ~TRF7970A_CHIP_STATUS_RF_ON;\r\ntrf7970a_write(trf, TRF7970A_CHIP_STATUS_CTRL, trf->chip_status_ctrl);\r\ntrf->aborting = false;\r\ntrf->state = TRF7970A_ST_RF_OFF;\r\npm_runtime_mark_last_busy(trf->dev);\r\npm_runtime_put_autosuspend(trf->dev);\r\n}\r\nstatic int trf7970a_switch_rf_on(struct trf7970a *trf)\r\n{\r\nint ret;\r\ndev_dbg(trf->dev, "Switching rf on\n");\r\npm_runtime_get_sync(trf->dev);\r\nif (trf->state != TRF7970A_ST_RF_OFF) {\r\ndev_err(trf->dev, "%s - Incorrect state: %d\n", __func__,\r\ntrf->state);\r\nreturn -EINVAL;\r\n}\r\nret = trf7970a_init(trf);\r\nif (ret) {\r\ndev_err(trf->dev, "%s - Can't initialize: %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\ntrf->state = TRF7970A_ST_IDLE;\r\nreturn 0;\r\n}\r\nstatic int trf7970a_switch_rf(struct nfc_digital_dev *ddev, bool on)\r\n{\r\nstruct trf7970a *trf = nfc_digital_get_drvdata(ddev);\r\nint ret = 0;\r\ndev_dbg(trf->dev, "Switching RF - state: %d, on: %d\n", trf->state, on);\r\nmutex_lock(&trf->lock);\r\nif (on) {\r\nswitch (trf->state) {\r\ncase TRF7970A_ST_PWR_OFF:\r\ncase TRF7970A_ST_RF_OFF:\r\nret = trf7970a_switch_rf_on(trf);\r\nbreak;\r\ncase TRF7970A_ST_IDLE:\r\ncase TRF7970A_ST_IDLE_RX_BLOCKED:\r\nbreak;\r\ndefault:\r\ndev_err(trf->dev, "%s - Invalid request: %d %d\n",\r\n__func__, trf->state, on);\r\ntrf7970a_switch_rf_off(trf);\r\nret = -EINVAL;\r\n}\r\n} else {\r\nswitch (trf->state) {\r\ncase TRF7970A_ST_PWR_OFF:\r\ncase TRF7970A_ST_RF_OFF:\r\nbreak;\r\ndefault:\r\ndev_err(trf->dev, "%s - Invalid request: %d %d\n",\r\n__func__, trf->state, on);\r\nret = -EINVAL;\r\ncase TRF7970A_ST_IDLE:\r\ncase TRF7970A_ST_IDLE_RX_BLOCKED:\r\ncase TRF7970A_ST_WAIT_FOR_RX_DATA:\r\ncase TRF7970A_ST_WAIT_FOR_RX_DATA_CONT:\r\ntrf7970a_switch_rf_off(trf);\r\n}\r\n}\r\nmutex_unlock(&trf->lock);\r\nreturn ret;\r\n}\r\nstatic int trf7970a_in_config_rf_tech(struct trf7970a *trf, int tech)\r\n{\r\nint ret = 0;\r\ndev_dbg(trf->dev, "rf technology: %d\n", tech);\r\nswitch (tech) {\r\ncase NFC_DIGITAL_RF_TECH_106A:\r\ntrf->iso_ctrl_tech = TRF7970A_ISO_CTRL_14443A_106;\r\ntrf->modulator_sys_clk_ctrl =\r\n(trf->modulator_sys_clk_ctrl & 0xf8) |\r\nTRF7970A_MODULATOR_DEPTH_OOK;\r\ntrf->guard_time = TRF7970A_GUARD_TIME_NFCA;\r\nbreak;\r\ncase NFC_DIGITAL_RF_TECH_106B:\r\ntrf->iso_ctrl_tech = TRF7970A_ISO_CTRL_14443B_106;\r\ntrf->modulator_sys_clk_ctrl =\r\n(trf->modulator_sys_clk_ctrl & 0xf8) |\r\nTRF7970A_MODULATOR_DEPTH_ASK10;\r\ntrf->guard_time = TRF7970A_GUARD_TIME_NFCB;\r\nbreak;\r\ncase NFC_DIGITAL_RF_TECH_212F:\r\ntrf->iso_ctrl_tech = TRF7970A_ISO_CTRL_FELICA_212;\r\ntrf->modulator_sys_clk_ctrl =\r\n(trf->modulator_sys_clk_ctrl & 0xf8) |\r\nTRF7970A_MODULATOR_DEPTH_ASK10;\r\ntrf->guard_time = TRF7970A_GUARD_TIME_NFCF;\r\nbreak;\r\ncase NFC_DIGITAL_RF_TECH_424F:\r\ntrf->iso_ctrl_tech = TRF7970A_ISO_CTRL_FELICA_424;\r\ntrf->modulator_sys_clk_ctrl =\r\n(trf->modulator_sys_clk_ctrl & 0xf8) |\r\nTRF7970A_MODULATOR_DEPTH_ASK10;\r\ntrf->guard_time = TRF7970A_GUARD_TIME_NFCF;\r\nbreak;\r\ncase NFC_DIGITAL_RF_TECH_ISO15693:\r\ntrf->iso_ctrl_tech = TRF7970A_ISO_CTRL_15693_SGL_1OF4_2648;\r\ntrf->modulator_sys_clk_ctrl =\r\n(trf->modulator_sys_clk_ctrl & 0xf8) |\r\nTRF7970A_MODULATOR_DEPTH_OOK;\r\ntrf->guard_time = TRF7970A_GUARD_TIME_15693;\r\nbreak;\r\ndefault:\r\ndev_dbg(trf->dev, "Unsupported rf technology: %d\n", tech);\r\nreturn -EINVAL;\r\n}\r\ntrf->technology = tech;\r\nif (trf->iso_ctrl == 0xff)\r\nret = trf7970a_write(trf, TRF7970A_NFC_TARGET_LEVEL, 0);\r\nreturn ret;\r\n}\r\nstatic int trf7970a_is_rf_field(struct trf7970a *trf, bool *is_rf_field)\r\n{\r\nint ret;\r\nu8 rssi;\r\nret = trf7970a_write(trf, TRF7970A_CHIP_STATUS_CTRL,\r\ntrf->chip_status_ctrl |\r\nTRF7970A_CHIP_STATUS_REC_ON);\r\nif (ret)\r\nreturn ret;\r\nret = trf7970a_cmd(trf, TRF7970A_CMD_TEST_EXT_RF);\r\nif (ret)\r\nreturn ret;\r\nusleep_range(50, 60);\r\nret = trf7970a_read(trf, TRF7970A_RSSI_OSC_STATUS, &rssi);\r\nif (ret)\r\nreturn ret;\r\nret = trf7970a_write(trf, TRF7970A_CHIP_STATUS_CTRL,\r\ntrf->chip_status_ctrl);\r\nif (ret)\r\nreturn ret;\r\nif (rssi & TRF7970A_RSSI_OSC_STATUS_RSSI_MASK)\r\n*is_rf_field = true;\r\nelse\r\n*is_rf_field = false;\r\nreturn 0;\r\n}\r\nstatic int trf7970a_in_config_framing(struct trf7970a *trf, int framing)\r\n{\r\nu8 iso_ctrl = trf->iso_ctrl_tech;\r\nbool is_rf_field = false;\r\nint ret;\r\ndev_dbg(trf->dev, "framing: %d\n", framing);\r\nswitch (framing) {\r\ncase NFC_DIGITAL_FRAMING_NFCA_SHORT:\r\ncase NFC_DIGITAL_FRAMING_NFCA_STANDARD:\r\ntrf->tx_cmd = TRF7970A_CMD_TRANSMIT_NO_CRC;\r\niso_ctrl |= TRF7970A_ISO_CTRL_RX_CRC_N;\r\nbreak;\r\ncase NFC_DIGITAL_FRAMING_NFCA_STANDARD_WITH_CRC_A:\r\ncase NFC_DIGITAL_FRAMING_NFCA_T4T:\r\ncase NFC_DIGITAL_FRAMING_NFCB:\r\ncase NFC_DIGITAL_FRAMING_NFCB_T4T:\r\ncase NFC_DIGITAL_FRAMING_NFCF:\r\ncase NFC_DIGITAL_FRAMING_NFCF_T3T:\r\ncase NFC_DIGITAL_FRAMING_ISO15693_INVENTORY:\r\ncase NFC_DIGITAL_FRAMING_ISO15693_T5T:\r\ncase NFC_DIGITAL_FRAMING_NFCA_NFC_DEP:\r\ncase NFC_DIGITAL_FRAMING_NFCF_NFC_DEP:\r\ntrf->tx_cmd = TRF7970A_CMD_TRANSMIT;\r\niso_ctrl &= ~TRF7970A_ISO_CTRL_RX_CRC_N;\r\nbreak;\r\ncase NFC_DIGITAL_FRAMING_NFCA_T2T:\r\ntrf->tx_cmd = TRF7970A_CMD_TRANSMIT;\r\niso_ctrl |= TRF7970A_ISO_CTRL_RX_CRC_N;\r\nbreak;\r\ndefault:\r\ndev_dbg(trf->dev, "Unsupported Framing: %d\n", framing);\r\nreturn -EINVAL;\r\n}\r\ntrf->framing = framing;\r\nif (!(trf->chip_status_ctrl & TRF7970A_CHIP_STATUS_RF_ON)) {\r\nret = trf7970a_is_rf_field(trf, &is_rf_field);\r\nif (ret)\r\nreturn ret;\r\nif (is_rf_field)\r\nreturn -EBUSY;\r\n}\r\nif (iso_ctrl != trf->iso_ctrl) {\r\nret = trf7970a_write(trf, TRF7970A_ISO_CTRL, iso_ctrl);\r\nif (ret)\r\nreturn ret;\r\ntrf->iso_ctrl = iso_ctrl;\r\nret = trf7970a_write(trf, TRF7970A_MODULATOR_SYS_CLK_CTRL,\r\ntrf->modulator_sys_clk_ctrl);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (!(trf->chip_status_ctrl & TRF7970A_CHIP_STATUS_RF_ON)) {\r\nret = trf7970a_write(trf, TRF7970A_CHIP_STATUS_CTRL,\r\ntrf->chip_status_ctrl |\r\nTRF7970A_CHIP_STATUS_RF_ON);\r\nif (ret)\r\nreturn ret;\r\ntrf->chip_status_ctrl |= TRF7970A_CHIP_STATUS_RF_ON;\r\nusleep_range(trf->guard_time, trf->guard_time + 1000);\r\n}\r\nreturn 0;\r\n}\r\nstatic int trf7970a_in_configure_hw(struct nfc_digital_dev *ddev, int type,\r\nint param)\r\n{\r\nstruct trf7970a *trf = nfc_digital_get_drvdata(ddev);\r\nint ret;\r\ndev_dbg(trf->dev, "Configure hw - type: %d, param: %d\n", type, param);\r\nmutex_lock(&trf->lock);\r\ntrf->is_initiator = true;\r\nif ((trf->state == TRF7970A_ST_PWR_OFF) ||\r\n(trf->state == TRF7970A_ST_RF_OFF)) {\r\nret = trf7970a_switch_rf_on(trf);\r\nif (ret)\r\ngoto err_unlock;\r\n}\r\nswitch (type) {\r\ncase NFC_DIGITAL_CONFIG_RF_TECH:\r\nret = trf7970a_in_config_rf_tech(trf, param);\r\nbreak;\r\ncase NFC_DIGITAL_CONFIG_FRAMING:\r\nret = trf7970a_in_config_framing(trf, param);\r\nbreak;\r\ndefault:\r\ndev_dbg(trf->dev, "Unknown type: %d\n", type);\r\nret = -EINVAL;\r\n}\r\nerr_unlock:\r\nmutex_unlock(&trf->lock);\r\nreturn ret;\r\n}\r\nstatic int trf7970a_is_iso15693_write_or_lock(u8 cmd)\r\n{\r\nswitch (cmd) {\r\ncase ISO15693_CMD_WRITE_SINGLE_BLOCK:\r\ncase ISO15693_CMD_LOCK_BLOCK:\r\ncase ISO15693_CMD_WRITE_MULTIPLE_BLOCK:\r\ncase ISO15693_CMD_WRITE_AFI:\r\ncase ISO15693_CMD_LOCK_AFI:\r\ncase ISO15693_CMD_WRITE_DSFID:\r\ncase ISO15693_CMD_LOCK_DSFID:\r\nreturn 1;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int trf7970a_per_cmd_config(struct trf7970a *trf, struct sk_buff *skb)\r\n{\r\nu8 *req = skb->data;\r\nu8 special_fcn_reg1, iso_ctrl;\r\nint ret;\r\ntrf->issue_eof = false;\r\nif ((trf->technology == NFC_DIGITAL_RF_TECH_106A) &&\r\n(trf->framing == NFC_DIGITAL_FRAMING_NFCA_T2T)) {\r\nif (req[0] == NFC_T2T_CMD_READ)\r\nspecial_fcn_reg1 = 0;\r\nelse\r\nspecial_fcn_reg1 = TRF7970A_SPECIAL_FCN_REG1_4_BIT_RX;\r\nif (special_fcn_reg1 != trf->special_fcn_reg1) {\r\nret = trf7970a_write(trf, TRF7970A_SPECIAL_FCN_REG1,\r\nspecial_fcn_reg1);\r\nif (ret)\r\nreturn ret;\r\ntrf->special_fcn_reg1 = special_fcn_reg1;\r\n}\r\n} else if (trf->technology == NFC_DIGITAL_RF_TECH_ISO15693) {\r\niso_ctrl = trf->iso_ctrl & ~TRF7970A_ISO_CTRL_RFID_SPEED_MASK;\r\nswitch (req[0] & ISO15693_REQ_FLAG_SPEED_MASK) {\r\ncase 0x00:\r\niso_ctrl |= TRF7970A_ISO_CTRL_15693_SGL_1OF4_662;\r\nbreak;\r\ncase ISO15693_REQ_FLAG_SUB_CARRIER:\r\niso_ctrl |= TRF7970A_ISO_CTRL_15693_DBL_1OF4_667a;\r\nbreak;\r\ncase ISO15693_REQ_FLAG_DATA_RATE:\r\niso_ctrl |= TRF7970A_ISO_CTRL_15693_SGL_1OF4_2648;\r\nbreak;\r\ncase (ISO15693_REQ_FLAG_SUB_CARRIER |\r\nISO15693_REQ_FLAG_DATA_RATE):\r\niso_ctrl |= TRF7970A_ISO_CTRL_15693_DBL_1OF4_2669;\r\nbreak;\r\n}\r\nif (iso_ctrl != trf->iso_ctrl) {\r\nret = trf7970a_write(trf, TRF7970A_ISO_CTRL, iso_ctrl);\r\nif (ret)\r\nreturn ret;\r\ntrf->iso_ctrl = iso_ctrl;\r\n}\r\nif ((trf->framing == NFC_DIGITAL_FRAMING_ISO15693_T5T) &&\r\ntrf7970a_is_iso15693_write_or_lock(req[1]) &&\r\n(req[0] & ISO15693_REQ_FLAG_OPTION))\r\ntrf->issue_eof = true;\r\n}\r\nreturn 0;\r\n}\r\nstatic int trf7970a_send_cmd(struct nfc_digital_dev *ddev,\r\nstruct sk_buff *skb, u16 timeout,\r\nnfc_digital_cmd_complete_t cb, void *arg)\r\n{\r\nstruct trf7970a *trf = nfc_digital_get_drvdata(ddev);\r\nu8 prefix[5];\r\nunsigned int len;\r\nint ret;\r\nu8 status;\r\ndev_dbg(trf->dev, "New request - state: %d, timeout: %d ms, len: %d\n",\r\ntrf->state, timeout, skb->len);\r\nif (skb->len > TRF7970A_TX_MAX)\r\nreturn -EINVAL;\r\nmutex_lock(&trf->lock);\r\nif ((trf->state != TRF7970A_ST_IDLE) &&\r\n(trf->state != TRF7970A_ST_IDLE_RX_BLOCKED)) {\r\ndev_err(trf->dev, "%s - Bogus state: %d\n", __func__,\r\ntrf->state);\r\nret = -EIO;\r\ngoto out_err;\r\n}\r\nif (trf->aborting) {\r\ndev_dbg(trf->dev, "Abort process complete\n");\r\ntrf->aborting = false;\r\nret = -ECANCELED;\r\ngoto out_err;\r\n}\r\nif (timeout) {\r\ntrf->rx_skb = nfc_alloc_recv_skb(TRF7970A_RX_SKB_ALLOC_SIZE,\r\nGFP_KERNEL);\r\nif (!trf->rx_skb) {\r\ndev_dbg(trf->dev, "Can't alloc rx_skb\n");\r\nret = -ENOMEM;\r\ngoto out_err;\r\n}\r\n}\r\nif (trf->state == TRF7970A_ST_IDLE_RX_BLOCKED) {\r\nret = trf7970a_cmd(trf, TRF7970A_CMD_ENABLE_RX);\r\nif (ret)\r\ngoto out_err;\r\ntrf->state = TRF7970A_ST_IDLE;\r\n}\r\nif (trf->is_initiator) {\r\nret = trf7970a_per_cmd_config(trf, skb);\r\nif (ret)\r\ngoto out_err;\r\n}\r\ntrf->ddev = ddev;\r\ntrf->tx_skb = skb;\r\ntrf->cb = cb;\r\ntrf->cb_arg = arg;\r\ntrf->timeout = timeout;\r\ntrf->ignore_timeout = false;\r\nlen = skb->len;\r\nprefix[0] = TRF7970A_CMD_BIT_CTRL |\r\nTRF7970A_CMD_BIT_OPCODE(TRF7970A_CMD_FIFO_RESET);\r\nprefix[1] = TRF7970A_CMD_BIT_CTRL |\r\nTRF7970A_CMD_BIT_OPCODE(trf->tx_cmd);\r\nprefix[2] = TRF7970A_CMD_BIT_CONTINUOUS | TRF7970A_TX_LENGTH_BYTE1;\r\nif (trf->framing == NFC_DIGITAL_FRAMING_NFCA_SHORT) {\r\nprefix[3] = 0x00;\r\nprefix[4] = 0x0f;\r\n} else {\r\nprefix[3] = (len & 0xf00) >> 4;\r\nprefix[3] |= ((len & 0xf0) >> 4);\r\nprefix[4] = ((len & 0x0f) << 4);\r\n}\r\nlen = min_t(int, skb->len, TRF7970A_FIFO_SIZE);\r\nret = trf7970a_read_irqstatus(trf, &status);\r\nif (ret)\r\ngoto out_err;\r\nret = trf7970a_transmit(trf, skb, len, prefix, sizeof(prefix));\r\nif (ret) {\r\nkfree_skb(trf->rx_skb);\r\ntrf->rx_skb = NULL;\r\n}\r\nout_err:\r\nmutex_unlock(&trf->lock);\r\nreturn ret;\r\n}\r\nstatic int trf7970a_tg_config_rf_tech(struct trf7970a *trf, int tech)\r\n{\r\nint ret = 0;\r\ndev_dbg(trf->dev, "rf technology: %d\n", tech);\r\nswitch (tech) {\r\ncase NFC_DIGITAL_RF_TECH_106A:\r\ntrf->iso_ctrl_tech = TRF7970A_ISO_CTRL_NFC_NFC_CE_MODE |\r\nTRF7970A_ISO_CTRL_NFC_CE | TRF7970A_ISO_CTRL_NFC_CE_14443A;\r\ntrf->modulator_sys_clk_ctrl =\r\n(trf->modulator_sys_clk_ctrl & 0xf8) |\r\nTRF7970A_MODULATOR_DEPTH_OOK;\r\nbreak;\r\ncase NFC_DIGITAL_RF_TECH_212F:\r\ntrf->iso_ctrl_tech = TRF7970A_ISO_CTRL_NFC_NFC_CE_MODE |\r\nTRF7970A_ISO_CTRL_NFC_NFCF_212;\r\ntrf->modulator_sys_clk_ctrl =\r\n(trf->modulator_sys_clk_ctrl & 0xf8) |\r\nTRF7970A_MODULATOR_DEPTH_ASK10;\r\nbreak;\r\ncase NFC_DIGITAL_RF_TECH_424F:\r\ntrf->iso_ctrl_tech = TRF7970A_ISO_CTRL_NFC_NFC_CE_MODE |\r\nTRF7970A_ISO_CTRL_NFC_NFCF_424;\r\ntrf->modulator_sys_clk_ctrl =\r\n(trf->modulator_sys_clk_ctrl & 0xf8) |\r\nTRF7970A_MODULATOR_DEPTH_ASK10;\r\nbreak;\r\ndefault:\r\ndev_dbg(trf->dev, "Unsupported rf technology: %d\n", tech);\r\nreturn -EINVAL;\r\n}\r\ntrf->technology = tech;\r\nif ((trf->framing == NFC_DIGITAL_FRAMING_NFC_DEP_ACTIVATED) &&\r\n(trf->iso_ctrl_tech != trf->iso_ctrl)) {\r\nret = trf7970a_write(trf, TRF7970A_ISO_CTRL,\r\ntrf->iso_ctrl_tech);\r\ntrf->iso_ctrl = trf->iso_ctrl_tech;\r\n}\r\nreturn ret;\r\n}\r\nstatic int trf7970a_tg_config_framing(struct trf7970a *trf, int framing)\r\n{\r\nu8 iso_ctrl = trf->iso_ctrl_tech;\r\nint ret;\r\ndev_dbg(trf->dev, "framing: %d\n", framing);\r\nswitch (framing) {\r\ncase NFC_DIGITAL_FRAMING_NFCA_NFC_DEP:\r\ntrf->tx_cmd = TRF7970A_CMD_TRANSMIT_NO_CRC;\r\niso_ctrl |= TRF7970A_ISO_CTRL_RX_CRC_N;\r\nbreak;\r\ncase NFC_DIGITAL_FRAMING_NFCA_STANDARD:\r\ncase NFC_DIGITAL_FRAMING_NFCA_STANDARD_WITH_CRC_A:\r\ncase NFC_DIGITAL_FRAMING_NFCA_ANTICOL_COMPLETE:\r\niso_ctrl = trf->iso_ctrl;\r\nbreak;\r\ncase NFC_DIGITAL_FRAMING_NFCF_NFC_DEP:\r\ntrf->tx_cmd = TRF7970A_CMD_TRANSMIT;\r\niso_ctrl &= ~TRF7970A_ISO_CTRL_RX_CRC_N;\r\nbreak;\r\ncase NFC_DIGITAL_FRAMING_NFC_DEP_ACTIVATED:\r\ntrf->tx_cmd = TRF7970A_CMD_TRANSMIT;\r\niso_ctrl &= ~TRF7970A_ISO_CTRL_RX_CRC_N;\r\nbreak;\r\ndefault:\r\ndev_dbg(trf->dev, "Unsupported Framing: %d\n", framing);\r\nreturn -EINVAL;\r\n}\r\ntrf->framing = framing;\r\nif (iso_ctrl != trf->iso_ctrl) {\r\nret = trf7970a_write(trf, TRF7970A_ISO_CTRL, iso_ctrl);\r\nif (ret)\r\nreturn ret;\r\ntrf->iso_ctrl = iso_ctrl;\r\nret = trf7970a_write(trf, TRF7970A_MODULATOR_SYS_CLK_CTRL,\r\ntrf->modulator_sys_clk_ctrl);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (!(trf->chip_status_ctrl & TRF7970A_CHIP_STATUS_RF_ON)) {\r\nret = trf7970a_write(trf, TRF7970A_CHIP_STATUS_CTRL,\r\ntrf->chip_status_ctrl |\r\nTRF7970A_CHIP_STATUS_RF_ON);\r\nif (ret)\r\nreturn ret;\r\ntrf->chip_status_ctrl |= TRF7970A_CHIP_STATUS_RF_ON;\r\n}\r\nreturn 0;\r\n}\r\nstatic int trf7970a_tg_configure_hw(struct nfc_digital_dev *ddev, int type,\r\nint param)\r\n{\r\nstruct trf7970a *trf = nfc_digital_get_drvdata(ddev);\r\nint ret;\r\ndev_dbg(trf->dev, "Configure hw - type: %d, param: %d\n", type, param);\r\nmutex_lock(&trf->lock);\r\ntrf->is_initiator = false;\r\nif ((trf->state == TRF7970A_ST_PWR_OFF) ||\r\n(trf->state == TRF7970A_ST_RF_OFF)) {\r\nret = trf7970a_switch_rf_on(trf);\r\nif (ret)\r\ngoto err_unlock;\r\n}\r\nswitch (type) {\r\ncase NFC_DIGITAL_CONFIG_RF_TECH:\r\nret = trf7970a_tg_config_rf_tech(trf, param);\r\nbreak;\r\ncase NFC_DIGITAL_CONFIG_FRAMING:\r\nret = trf7970a_tg_config_framing(trf, param);\r\nbreak;\r\ndefault:\r\ndev_dbg(trf->dev, "Unknown type: %d\n", type);\r\nret = -EINVAL;\r\n}\r\nerr_unlock:\r\nmutex_unlock(&trf->lock);\r\nreturn ret;\r\n}\r\nstatic int _trf7970a_tg_listen(struct nfc_digital_dev *ddev, u16 timeout,\r\nnfc_digital_cmd_complete_t cb, void *arg,\r\nbool mode_detect)\r\n{\r\nstruct trf7970a *trf = nfc_digital_get_drvdata(ddev);\r\nint ret;\r\nmutex_lock(&trf->lock);\r\nif ((trf->state != TRF7970A_ST_IDLE) &&\r\n(trf->state != TRF7970A_ST_IDLE_RX_BLOCKED)) {\r\ndev_err(trf->dev, "%s - Bogus state: %d\n", __func__,\r\ntrf->state);\r\nret = -EIO;\r\ngoto out_err;\r\n}\r\nif (trf->aborting) {\r\ndev_dbg(trf->dev, "Abort process complete\n");\r\ntrf->aborting = false;\r\nret = -ECANCELED;\r\ngoto out_err;\r\n}\r\ntrf->rx_skb = nfc_alloc_recv_skb(TRF7970A_RX_SKB_ALLOC_SIZE,\r\nGFP_KERNEL);\r\nif (!trf->rx_skb) {\r\ndev_dbg(trf->dev, "Can't alloc rx_skb\n");\r\nret = -ENOMEM;\r\ngoto out_err;\r\n}\r\nret = trf7970a_write(trf, TRF7970A_RX_SPECIAL_SETTINGS,\r\nTRF7970A_RX_SPECIAL_SETTINGS_HBT |\r\nTRF7970A_RX_SPECIAL_SETTINGS_M848 |\r\nTRF7970A_RX_SPECIAL_SETTINGS_C424 |\r\nTRF7970A_RX_SPECIAL_SETTINGS_C212);\r\nif (ret)\r\ngoto out_err;\r\nret = trf7970a_write(trf, TRF7970A_REG_IO_CTRL,\r\ntrf->io_ctrl | TRF7970A_REG_IO_CTRL_VRS(0x1));\r\nif (ret)\r\ngoto out_err;\r\nret = trf7970a_write(trf, TRF7970A_NFC_LOW_FIELD_LEVEL,\r\nTRF7970A_NFC_LOW_FIELD_LEVEL_RFDET(0x3));\r\nif (ret)\r\ngoto out_err;\r\nret = trf7970a_write(trf, TRF7970A_NFC_TARGET_LEVEL,\r\nTRF7970A_NFC_TARGET_LEVEL_RFDET(0x7));\r\nif (ret)\r\ngoto out_err;\r\ntrf->ddev = ddev;\r\ntrf->cb = cb;\r\ntrf->cb_arg = arg;\r\ntrf->timeout = timeout;\r\ntrf->ignore_timeout = false;\r\nret = trf7970a_cmd(trf, TRF7970A_CMD_ENABLE_RX);\r\nif (ret)\r\ngoto out_err;\r\ntrf->state = mode_detect ? TRF7970A_ST_LISTENING_MD :\r\nTRF7970A_ST_LISTENING;\r\nschedule_delayed_work(&trf->timeout_work, msecs_to_jiffies(timeout));\r\nout_err:\r\nmutex_unlock(&trf->lock);\r\nreturn ret;\r\n}\r\nstatic int trf7970a_tg_listen(struct nfc_digital_dev *ddev, u16 timeout,\r\nnfc_digital_cmd_complete_t cb, void *arg)\r\n{\r\nstruct trf7970a *trf = nfc_digital_get_drvdata(ddev);\r\ndev_dbg(trf->dev, "Listen - state: %d, timeout: %d ms\n",\r\ntrf->state, timeout);\r\nreturn _trf7970a_tg_listen(ddev, timeout, cb, arg, false);\r\n}\r\nstatic int trf7970a_tg_listen_md(struct nfc_digital_dev *ddev,\r\nu16 timeout, nfc_digital_cmd_complete_t cb,\r\nvoid *arg)\r\n{\r\nstruct trf7970a *trf = nfc_digital_get_drvdata(ddev);\r\nint ret;\r\ndev_dbg(trf->dev, "Listen MD - state: %d, timeout: %d ms\n",\r\ntrf->state, timeout);\r\nret = trf7970a_tg_configure_hw(ddev, NFC_DIGITAL_CONFIG_RF_TECH,\r\nNFC_DIGITAL_RF_TECH_106A);\r\nif (ret)\r\nreturn ret;\r\nret = trf7970a_tg_configure_hw(ddev, NFC_DIGITAL_CONFIG_FRAMING,\r\nNFC_DIGITAL_FRAMING_NFCA_NFC_DEP);\r\nif (ret)\r\nreturn ret;\r\nreturn _trf7970a_tg_listen(ddev, timeout, cb, arg, true);\r\n}\r\nstatic int trf7970a_tg_get_rf_tech(struct nfc_digital_dev *ddev, u8 *rf_tech)\r\n{\r\nstruct trf7970a *trf = nfc_digital_get_drvdata(ddev);\r\ndev_dbg(trf->dev, "Get RF Tech - state: %d, rf_tech: %d\n",\r\ntrf->state, trf->md_rf_tech);\r\n*rf_tech = trf->md_rf_tech;\r\nreturn 0;\r\n}\r\nstatic void trf7970a_abort_cmd(struct nfc_digital_dev *ddev)\r\n{\r\nstruct trf7970a *trf = nfc_digital_get_drvdata(ddev);\r\ndev_dbg(trf->dev, "Abort process initiated\n");\r\nmutex_lock(&trf->lock);\r\nswitch (trf->state) {\r\ncase TRF7970A_ST_WAIT_FOR_TX_FIFO:\r\ncase TRF7970A_ST_WAIT_FOR_RX_DATA:\r\ncase TRF7970A_ST_WAIT_FOR_RX_DATA_CONT:\r\ncase TRF7970A_ST_WAIT_TO_ISSUE_EOF:\r\ntrf->aborting = true;\r\nbreak;\r\ncase TRF7970A_ST_LISTENING:\r\ntrf->ignore_timeout = !cancel_delayed_work(&trf->timeout_work);\r\ntrf7970a_send_err_upstream(trf, -ECANCELED);\r\ndev_dbg(trf->dev, "Abort process complete\n");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nmutex_unlock(&trf->lock);\r\n}\r\nstatic int trf7970a_power_up(struct trf7970a *trf)\r\n{\r\nint ret;\r\ndev_dbg(trf->dev, "Powering up - state: %d\n", trf->state);\r\nif (trf->state != TRF7970A_ST_PWR_OFF)\r\nreturn 0;\r\nret = regulator_enable(trf->regulator);\r\nif (ret) {\r\ndev_err(trf->dev, "%s - Can't enable VIN: %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nusleep_range(5000, 6000);\r\nif (trf->en2_gpiod &&\r\n!(trf->quirks & TRF7970A_QUIRK_EN2_MUST_STAY_LOW)) {\r\ngpiod_set_value_cansleep(trf->en2_gpiod, 1);\r\nusleep_range(1000, 2000);\r\n}\r\ngpiod_set_value_cansleep(trf->en_gpiod, 1);\r\nusleep_range(20000, 21000);\r\ntrf->state = TRF7970A_ST_RF_OFF;\r\nreturn 0;\r\n}\r\nstatic int trf7970a_power_down(struct trf7970a *trf)\r\n{\r\nint ret;\r\ndev_dbg(trf->dev, "Powering down - state: %d\n", trf->state);\r\nif (trf->state == TRF7970A_ST_PWR_OFF)\r\nreturn 0;\r\nif (trf->state != TRF7970A_ST_RF_OFF) {\r\ndev_dbg(trf->dev, "Can't power down - not RF_OFF state (%d)\n",\r\ntrf->state);\r\nreturn -EBUSY;\r\n}\r\ngpiod_set_value_cansleep(trf->en_gpiod, 0);\r\nif (trf->en2_gpiod && !(trf->quirks & TRF7970A_QUIRK_EN2_MUST_STAY_LOW))\r\ngpiod_set_value_cansleep(trf->en2_gpiod, 0);\r\nret = regulator_disable(trf->regulator);\r\nif (ret)\r\ndev_err(trf->dev, "%s - Can't disable VIN: %d\n", __func__,\r\nret);\r\ntrf->state = TRF7970A_ST_PWR_OFF;\r\nreturn ret;\r\n}\r\nstatic int trf7970a_startup(struct trf7970a *trf)\r\n{\r\nint ret;\r\nret = trf7970a_power_up(trf);\r\nif (ret)\r\nreturn ret;\r\npm_runtime_set_active(trf->dev);\r\npm_runtime_enable(trf->dev);\r\npm_runtime_mark_last_busy(trf->dev);\r\nreturn 0;\r\n}\r\nstatic void trf7970a_shutdown(struct trf7970a *trf)\r\n{\r\nswitch (trf->state) {\r\ncase TRF7970A_ST_WAIT_FOR_TX_FIFO:\r\ncase TRF7970A_ST_WAIT_FOR_RX_DATA:\r\ncase TRF7970A_ST_WAIT_FOR_RX_DATA_CONT:\r\ncase TRF7970A_ST_WAIT_TO_ISSUE_EOF:\r\ncase TRF7970A_ST_LISTENING:\r\ntrf7970a_send_err_upstream(trf, -ECANCELED);\r\ncase TRF7970A_ST_IDLE:\r\ncase TRF7970A_ST_IDLE_RX_BLOCKED:\r\ntrf7970a_switch_rf_off(trf);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\npm_runtime_disable(trf->dev);\r\npm_runtime_set_suspended(trf->dev);\r\ntrf7970a_power_down(trf);\r\n}\r\nstatic int trf7970a_get_autosuspend_delay(struct device_node *np)\r\n{\r\nint autosuspend_delay, ret;\r\nret = of_property_read_u32(np, "autosuspend-delay", &autosuspend_delay);\r\nif (ret)\r\nautosuspend_delay = TRF7970A_AUTOSUSPEND_DELAY;\r\nreturn autosuspend_delay;\r\n}\r\nstatic int trf7970a_probe(struct spi_device *spi)\r\n{\r\nstruct device_node *np = spi->dev.of_node;\r\nstruct trf7970a *trf;\r\nint uvolts, autosuspend_delay, ret;\r\nu32 clk_freq = TRF7970A_13MHZ_CLOCK_FREQUENCY;\r\nif (!np) {\r\ndev_err(&spi->dev, "No Device Tree entry\n");\r\nreturn -EINVAL;\r\n}\r\ntrf = devm_kzalloc(&spi->dev, sizeof(*trf), GFP_KERNEL);\r\nif (!trf)\r\nreturn -ENOMEM;\r\ntrf->state = TRF7970A_ST_PWR_OFF;\r\ntrf->dev = &spi->dev;\r\ntrf->spi = spi;\r\nspi->mode = SPI_MODE_1;\r\nspi->bits_per_word = 8;\r\nret = spi_setup(spi);\r\nif (ret < 0) {\r\ndev_err(trf->dev, "Can't set up SPI Communication\n");\r\nreturn ret;\r\n}\r\nif (of_property_read_bool(np, "irq-status-read-quirk"))\r\ntrf->quirks |= TRF7970A_QUIRK_IRQ_STATUS_READ;\r\ntrf->en_gpiod = devm_gpiod_get_index(trf->dev, "ti,enable", 0,\r\nGPIOD_OUT_LOW);\r\nif (IS_ERR(trf->en_gpiod)) {\r\ndev_err(trf->dev, "No EN GPIO property\n");\r\nreturn PTR_ERR(trf->en_gpiod);\r\n}\r\ntrf->en2_gpiod = devm_gpiod_get_index_optional(trf->dev, "ti,enable", 1,\r\nGPIOD_OUT_LOW);\r\nif (!trf->en2_gpiod) {\r\ndev_info(trf->dev, "No EN2 GPIO property\n");\r\n} else if (IS_ERR(trf->en2_gpiod)) {\r\ndev_err(trf->dev, "Error getting EN2 GPIO property: %ld\n",\r\nPTR_ERR(trf->en2_gpiod));\r\nreturn PTR_ERR(trf->en2_gpiod);\r\n} else if (of_property_read_bool(np, "en2-rf-quirk")) {\r\ntrf->quirks |= TRF7970A_QUIRK_EN2_MUST_STAY_LOW;\r\n}\r\nof_property_read_u32(np, "clock-frequency", &clk_freq);\r\nif ((clk_freq != TRF7970A_27MHZ_CLOCK_FREQUENCY) &&\r\n(clk_freq != TRF7970A_13MHZ_CLOCK_FREQUENCY)) {\r\ndev_err(trf->dev,\r\n"clock-frequency (%u Hz) unsupported\n", clk_freq);\r\nreturn -EINVAL;\r\n}\r\nif (clk_freq == TRF7970A_27MHZ_CLOCK_FREQUENCY) {\r\ntrf->modulator_sys_clk_ctrl = TRF7970A_MODULATOR_27MHZ;\r\ndev_dbg(trf->dev, "trf7970a configured for 27MHz crystal\n");\r\n} else {\r\ntrf->modulator_sys_clk_ctrl = 0;\r\n}\r\nret = devm_request_threaded_irq(trf->dev, spi->irq, NULL,\r\ntrf7970a_irq,\r\nIRQF_TRIGGER_RISING | IRQF_ONESHOT,\r\n"trf7970a", trf);\r\nif (ret) {\r\ndev_err(trf->dev, "Can't request IRQ#%d: %d\n", spi->irq, ret);\r\nreturn ret;\r\n}\r\nmutex_init(&trf->lock);\r\nINIT_DELAYED_WORK(&trf->timeout_work, trf7970a_timeout_work_handler);\r\ntrf->regulator = devm_regulator_get(&spi->dev, "vin");\r\nif (IS_ERR(trf->regulator)) {\r\nret = PTR_ERR(trf->regulator);\r\ndev_err(trf->dev, "Can't get VIN regulator: %d\n", ret);\r\ngoto err_destroy_lock;\r\n}\r\nret = regulator_enable(trf->regulator);\r\nif (ret) {\r\ndev_err(trf->dev, "Can't enable VIN: %d\n", ret);\r\ngoto err_destroy_lock;\r\n}\r\nuvolts = regulator_get_voltage(trf->regulator);\r\nif (uvolts > 4000000)\r\ntrf->chip_status_ctrl = TRF7970A_CHIP_STATUS_VRS5_3;\r\ntrf->regulator = devm_regulator_get(&spi->dev, "vdd-io");\r\nif (IS_ERR(trf->regulator)) {\r\nret = PTR_ERR(trf->regulator);\r\ndev_err(trf->dev, "Can't get VDD_IO regulator: %d\n", ret);\r\ngoto err_destroy_lock;\r\n}\r\nret = regulator_enable(trf->regulator);\r\nif (ret) {\r\ndev_err(trf->dev, "Can't enable VDD_IO: %d\n", ret);\r\ngoto err_destroy_lock;\r\n}\r\nif (regulator_get_voltage(trf->regulator) == 1800000) {\r\ntrf->io_ctrl = TRF7970A_REG_IO_CTRL_IO_LOW;\r\ndev_dbg(trf->dev, "trf7970a config vdd_io to 1.8V\n");\r\n}\r\ntrf->ddev = nfc_digital_allocate_device(&trf7970a_nfc_ops,\r\nTRF7970A_SUPPORTED_PROTOCOLS,\r\nNFC_DIGITAL_DRV_CAPS_IN_CRC |\r\nNFC_DIGITAL_DRV_CAPS_TG_CRC, 0,\r\n0);\r\nif (!trf->ddev) {\r\ndev_err(trf->dev, "Can't allocate NFC digital device\n");\r\nret = -ENOMEM;\r\ngoto err_disable_regulator;\r\n}\r\nnfc_digital_set_parent_dev(trf->ddev, trf->dev);\r\nnfc_digital_set_drvdata(trf->ddev, trf);\r\nspi_set_drvdata(spi, trf);\r\nautosuspend_delay = trf7970a_get_autosuspend_delay(np);\r\npm_runtime_set_autosuspend_delay(trf->dev, autosuspend_delay);\r\npm_runtime_use_autosuspend(trf->dev);\r\nret = trf7970a_startup(trf);\r\nif (ret)\r\ngoto err_free_ddev;\r\nret = nfc_digital_register_device(trf->ddev);\r\nif (ret) {\r\ndev_err(trf->dev, "Can't register NFC digital device: %d\n",\r\nret);\r\ngoto err_shutdown;\r\n}\r\nreturn 0;\r\nerr_shutdown:\r\ntrf7970a_shutdown(trf);\r\nerr_free_ddev:\r\nnfc_digital_free_device(trf->ddev);\r\nerr_disable_regulator:\r\nregulator_disable(trf->regulator);\r\nerr_destroy_lock:\r\nmutex_destroy(&trf->lock);\r\nreturn ret;\r\n}\r\nstatic int trf7970a_remove(struct spi_device *spi)\r\n{\r\nstruct trf7970a *trf = spi_get_drvdata(spi);\r\nmutex_lock(&trf->lock);\r\ntrf7970a_shutdown(trf);\r\nmutex_unlock(&trf->lock);\r\nnfc_digital_unregister_device(trf->ddev);\r\nnfc_digital_free_device(trf->ddev);\r\nregulator_disable(trf->regulator);\r\nmutex_destroy(&trf->lock);\r\nreturn 0;\r\n}\r\nstatic int trf7970a_suspend(struct device *dev)\r\n{\r\nstruct spi_device *spi = to_spi_device(dev);\r\nstruct trf7970a *trf = spi_get_drvdata(spi);\r\ndev_dbg(dev, "Suspend\n");\r\nmutex_lock(&trf->lock);\r\ntrf7970a_shutdown(trf);\r\nmutex_unlock(&trf->lock);\r\nreturn 0;\r\n}\r\nstatic int trf7970a_resume(struct device *dev)\r\n{\r\nstruct spi_device *spi = to_spi_device(dev);\r\nstruct trf7970a *trf = spi_get_drvdata(spi);\r\nint ret;\r\ndev_dbg(dev, "Resume\n");\r\nmutex_lock(&trf->lock);\r\nret = trf7970a_startup(trf);\r\nmutex_unlock(&trf->lock);\r\nreturn ret;\r\n}\r\nstatic int trf7970a_pm_runtime_suspend(struct device *dev)\r\n{\r\nstruct spi_device *spi = to_spi_device(dev);\r\nstruct trf7970a *trf = spi_get_drvdata(spi);\r\nint ret;\r\ndev_dbg(dev, "Runtime suspend\n");\r\nmutex_lock(&trf->lock);\r\nret = trf7970a_power_down(trf);\r\nmutex_unlock(&trf->lock);\r\nreturn ret;\r\n}\r\nstatic int trf7970a_pm_runtime_resume(struct device *dev)\r\n{\r\nstruct spi_device *spi = to_spi_device(dev);\r\nstruct trf7970a *trf = spi_get_drvdata(spi);\r\nint ret;\r\ndev_dbg(dev, "Runtime resume\n");\r\nret = trf7970a_power_up(trf);\r\nif (!ret)\r\npm_runtime_mark_last_busy(dev);\r\nreturn ret;\r\n}
