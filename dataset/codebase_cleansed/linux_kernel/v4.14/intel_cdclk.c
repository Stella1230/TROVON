static void fixed_133mhz_get_cdclk(struct drm_i915_private *dev_priv,\r\nstruct intel_cdclk_state *cdclk_state)\r\n{\r\ncdclk_state->cdclk = 133333;\r\n}\r\nstatic void fixed_200mhz_get_cdclk(struct drm_i915_private *dev_priv,\r\nstruct intel_cdclk_state *cdclk_state)\r\n{\r\ncdclk_state->cdclk = 200000;\r\n}\r\nstatic void fixed_266mhz_get_cdclk(struct drm_i915_private *dev_priv,\r\nstruct intel_cdclk_state *cdclk_state)\r\n{\r\ncdclk_state->cdclk = 266667;\r\n}\r\nstatic void fixed_333mhz_get_cdclk(struct drm_i915_private *dev_priv,\r\nstruct intel_cdclk_state *cdclk_state)\r\n{\r\ncdclk_state->cdclk = 333333;\r\n}\r\nstatic void fixed_400mhz_get_cdclk(struct drm_i915_private *dev_priv,\r\nstruct intel_cdclk_state *cdclk_state)\r\n{\r\ncdclk_state->cdclk = 400000;\r\n}\r\nstatic void fixed_450mhz_get_cdclk(struct drm_i915_private *dev_priv,\r\nstruct intel_cdclk_state *cdclk_state)\r\n{\r\ncdclk_state->cdclk = 450000;\r\n}\r\nstatic void i85x_get_cdclk(struct drm_i915_private *dev_priv,\r\nstruct intel_cdclk_state *cdclk_state)\r\n{\r\nstruct pci_dev *pdev = dev_priv->drm.pdev;\r\nu16 hpllcc = 0;\r\nif (pdev->revision == 0x1) {\r\ncdclk_state->cdclk = 133333;\r\nreturn;\r\n}\r\npci_bus_read_config_word(pdev->bus,\r\nPCI_DEVFN(0, 3), HPLLCC, &hpllcc);\r\nswitch (hpllcc & GC_CLOCK_CONTROL_MASK) {\r\ncase GC_CLOCK_133_200:\r\ncase GC_CLOCK_133_200_2:\r\ncase GC_CLOCK_100_200:\r\ncdclk_state->cdclk = 200000;\r\nbreak;\r\ncase GC_CLOCK_166_250:\r\ncdclk_state->cdclk = 250000;\r\nbreak;\r\ncase GC_CLOCK_100_133:\r\ncdclk_state->cdclk = 133333;\r\nbreak;\r\ncase GC_CLOCK_133_266:\r\ncase GC_CLOCK_133_266_2:\r\ncase GC_CLOCK_166_266:\r\ncdclk_state->cdclk = 266667;\r\nbreak;\r\n}\r\n}\r\nstatic void i915gm_get_cdclk(struct drm_i915_private *dev_priv,\r\nstruct intel_cdclk_state *cdclk_state)\r\n{\r\nstruct pci_dev *pdev = dev_priv->drm.pdev;\r\nu16 gcfgc = 0;\r\npci_read_config_word(pdev, GCFGC, &gcfgc);\r\nif (gcfgc & GC_LOW_FREQUENCY_ENABLE) {\r\ncdclk_state->cdclk = 133333;\r\nreturn;\r\n}\r\nswitch (gcfgc & GC_DISPLAY_CLOCK_MASK) {\r\ncase GC_DISPLAY_CLOCK_333_320_MHZ:\r\ncdclk_state->cdclk = 333333;\r\nbreak;\r\ndefault:\r\ncase GC_DISPLAY_CLOCK_190_200_MHZ:\r\ncdclk_state->cdclk = 190000;\r\nbreak;\r\n}\r\n}\r\nstatic void i945gm_get_cdclk(struct drm_i915_private *dev_priv,\r\nstruct intel_cdclk_state *cdclk_state)\r\n{\r\nstruct pci_dev *pdev = dev_priv->drm.pdev;\r\nu16 gcfgc = 0;\r\npci_read_config_word(pdev, GCFGC, &gcfgc);\r\nif (gcfgc & GC_LOW_FREQUENCY_ENABLE) {\r\ncdclk_state->cdclk = 133333;\r\nreturn;\r\n}\r\nswitch (gcfgc & GC_DISPLAY_CLOCK_MASK) {\r\ncase GC_DISPLAY_CLOCK_333_320_MHZ:\r\ncdclk_state->cdclk = 320000;\r\nbreak;\r\ndefault:\r\ncase GC_DISPLAY_CLOCK_190_200_MHZ:\r\ncdclk_state->cdclk = 200000;\r\nbreak;\r\n}\r\n}\r\nstatic unsigned int intel_hpll_vco(struct drm_i915_private *dev_priv)\r\n{\r\nstatic const unsigned int blb_vco[8] = {\r\n[0] = 3200000,\r\n[1] = 4000000,\r\n[2] = 5333333,\r\n[3] = 4800000,\r\n[4] = 6400000,\r\n};\r\nstatic const unsigned int pnv_vco[8] = {\r\n[0] = 3200000,\r\n[1] = 4000000,\r\n[2] = 5333333,\r\n[3] = 4800000,\r\n[4] = 2666667,\r\n};\r\nstatic const unsigned int cl_vco[8] = {\r\n[0] = 3200000,\r\n[1] = 4000000,\r\n[2] = 5333333,\r\n[3] = 6400000,\r\n[4] = 3333333,\r\n[5] = 3566667,\r\n[6] = 4266667,\r\n};\r\nstatic const unsigned int elk_vco[8] = {\r\n[0] = 3200000,\r\n[1] = 4000000,\r\n[2] = 5333333,\r\n[3] = 4800000,\r\n};\r\nstatic const unsigned int ctg_vco[8] = {\r\n[0] = 3200000,\r\n[1] = 4000000,\r\n[2] = 5333333,\r\n[3] = 6400000,\r\n[4] = 2666667,\r\n[5] = 4266667,\r\n};\r\nconst unsigned int *vco_table;\r\nunsigned int vco;\r\nuint8_t tmp = 0;\r\nif (IS_GM45(dev_priv))\r\nvco_table = ctg_vco;\r\nelse if (IS_G45(dev_priv))\r\nvco_table = elk_vco;\r\nelse if (IS_I965GM(dev_priv))\r\nvco_table = cl_vco;\r\nelse if (IS_PINEVIEW(dev_priv))\r\nvco_table = pnv_vco;\r\nelse if (IS_G33(dev_priv))\r\nvco_table = blb_vco;\r\nelse\r\nreturn 0;\r\ntmp = I915_READ(IS_MOBILE(dev_priv) ? HPLLVCO_MOBILE : HPLLVCO);\r\nvco = vco_table[tmp & 0x7];\r\nif (vco == 0)\r\nDRM_ERROR("Bad HPLL VCO (HPLLVCO=0x%02x)\n", tmp);\r\nelse\r\nDRM_DEBUG_KMS("HPLL VCO %u kHz\n", vco);\r\nreturn vco;\r\n}\r\nstatic void g33_get_cdclk(struct drm_i915_private *dev_priv,\r\nstruct intel_cdclk_state *cdclk_state)\r\n{\r\nstruct pci_dev *pdev = dev_priv->drm.pdev;\r\nstatic const uint8_t div_3200[] = { 12, 10, 8, 7, 5, 16 };\r\nstatic const uint8_t div_4000[] = { 14, 12, 10, 8, 6, 20 };\r\nstatic const uint8_t div_4800[] = { 20, 14, 12, 10, 8, 24 };\r\nstatic const uint8_t div_5333[] = { 20, 16, 12, 12, 8, 28 };\r\nconst uint8_t *div_table;\r\nunsigned int cdclk_sel;\r\nuint16_t tmp = 0;\r\ncdclk_state->vco = intel_hpll_vco(dev_priv);\r\npci_read_config_word(pdev, GCFGC, &tmp);\r\ncdclk_sel = (tmp >> 4) & 0x7;\r\nif (cdclk_sel >= ARRAY_SIZE(div_3200))\r\ngoto fail;\r\nswitch (cdclk_state->vco) {\r\ncase 3200000:\r\ndiv_table = div_3200;\r\nbreak;\r\ncase 4000000:\r\ndiv_table = div_4000;\r\nbreak;\r\ncase 4800000:\r\ndiv_table = div_4800;\r\nbreak;\r\ncase 5333333:\r\ndiv_table = div_5333;\r\nbreak;\r\ndefault:\r\ngoto fail;\r\n}\r\ncdclk_state->cdclk = DIV_ROUND_CLOSEST(cdclk_state->vco,\r\ndiv_table[cdclk_sel]);\r\nreturn;\r\nfail:\r\nDRM_ERROR("Unable to determine CDCLK. HPLL VCO=%u kHz, CFGC=0x%08x\n",\r\ncdclk_state->vco, tmp);\r\ncdclk_state->cdclk = 190476;\r\n}\r\nstatic void pnv_get_cdclk(struct drm_i915_private *dev_priv,\r\nstruct intel_cdclk_state *cdclk_state)\r\n{\r\nstruct pci_dev *pdev = dev_priv->drm.pdev;\r\nu16 gcfgc = 0;\r\npci_read_config_word(pdev, GCFGC, &gcfgc);\r\nswitch (gcfgc & GC_DISPLAY_CLOCK_MASK) {\r\ncase GC_DISPLAY_CLOCK_267_MHZ_PNV:\r\ncdclk_state->cdclk = 266667;\r\nbreak;\r\ncase GC_DISPLAY_CLOCK_333_MHZ_PNV:\r\ncdclk_state->cdclk = 333333;\r\nbreak;\r\ncase GC_DISPLAY_CLOCK_444_MHZ_PNV:\r\ncdclk_state->cdclk = 444444;\r\nbreak;\r\ncase GC_DISPLAY_CLOCK_200_MHZ_PNV:\r\ncdclk_state->cdclk = 200000;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknown pnv display core clock 0x%04x\n", gcfgc);\r\ncase GC_DISPLAY_CLOCK_133_MHZ_PNV:\r\ncdclk_state->cdclk = 133333;\r\nbreak;\r\ncase GC_DISPLAY_CLOCK_167_MHZ_PNV:\r\ncdclk_state->cdclk = 166667;\r\nbreak;\r\n}\r\n}\r\nstatic void i965gm_get_cdclk(struct drm_i915_private *dev_priv,\r\nstruct intel_cdclk_state *cdclk_state)\r\n{\r\nstruct pci_dev *pdev = dev_priv->drm.pdev;\r\nstatic const uint8_t div_3200[] = { 16, 10, 8 };\r\nstatic const uint8_t div_4000[] = { 20, 12, 10 };\r\nstatic const uint8_t div_5333[] = { 24, 16, 14 };\r\nconst uint8_t *div_table;\r\nunsigned int cdclk_sel;\r\nuint16_t tmp = 0;\r\ncdclk_state->vco = intel_hpll_vco(dev_priv);\r\npci_read_config_word(pdev, GCFGC, &tmp);\r\ncdclk_sel = ((tmp >> 8) & 0x1f) - 1;\r\nif (cdclk_sel >= ARRAY_SIZE(div_3200))\r\ngoto fail;\r\nswitch (cdclk_state->vco) {\r\ncase 3200000:\r\ndiv_table = div_3200;\r\nbreak;\r\ncase 4000000:\r\ndiv_table = div_4000;\r\nbreak;\r\ncase 5333333:\r\ndiv_table = div_5333;\r\nbreak;\r\ndefault:\r\ngoto fail;\r\n}\r\ncdclk_state->cdclk = DIV_ROUND_CLOSEST(cdclk_state->vco,\r\ndiv_table[cdclk_sel]);\r\nreturn;\r\nfail:\r\nDRM_ERROR("Unable to determine CDCLK. HPLL VCO=%u kHz, CFGC=0x%04x\n",\r\ncdclk_state->vco, tmp);\r\ncdclk_state->cdclk = 200000;\r\n}\r\nstatic void gm45_get_cdclk(struct drm_i915_private *dev_priv,\r\nstruct intel_cdclk_state *cdclk_state)\r\n{\r\nstruct pci_dev *pdev = dev_priv->drm.pdev;\r\nunsigned int cdclk_sel;\r\nuint16_t tmp = 0;\r\ncdclk_state->vco = intel_hpll_vco(dev_priv);\r\npci_read_config_word(pdev, GCFGC, &tmp);\r\ncdclk_sel = (tmp >> 12) & 0x1;\r\nswitch (cdclk_state->vco) {\r\ncase 2666667:\r\ncase 4000000:\r\ncase 5333333:\r\ncdclk_state->cdclk = cdclk_sel ? 333333 : 222222;\r\nbreak;\r\ncase 3200000:\r\ncdclk_state->cdclk = cdclk_sel ? 320000 : 228571;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unable to determine CDCLK. HPLL VCO=%u, CFGC=0x%04x\n",\r\ncdclk_state->vco, tmp);\r\ncdclk_state->cdclk = 222222;\r\nbreak;\r\n}\r\n}\r\nstatic void hsw_get_cdclk(struct drm_i915_private *dev_priv,\r\nstruct intel_cdclk_state *cdclk_state)\r\n{\r\nuint32_t lcpll = I915_READ(LCPLL_CTL);\r\nuint32_t freq = lcpll & LCPLL_CLK_FREQ_MASK;\r\nif (lcpll & LCPLL_CD_SOURCE_FCLK)\r\ncdclk_state->cdclk = 800000;\r\nelse if (I915_READ(FUSE_STRAP) & HSW_CDCLK_LIMIT)\r\ncdclk_state->cdclk = 450000;\r\nelse if (freq == LCPLL_CLK_FREQ_450)\r\ncdclk_state->cdclk = 450000;\r\nelse if (IS_HSW_ULT(dev_priv))\r\ncdclk_state->cdclk = 337500;\r\nelse\r\ncdclk_state->cdclk = 540000;\r\n}\r\nstatic int vlv_calc_cdclk(struct drm_i915_private *dev_priv,\r\nint max_pixclk)\r\n{\r\nint freq_320 = (dev_priv->hpll_freq << 1) % 320000 != 0 ?\r\n333333 : 320000;\r\nint limit = IS_CHERRYVIEW(dev_priv) ? 95 : 90;\r\nif (!IS_CHERRYVIEW(dev_priv) &&\r\nmax_pixclk > freq_320*limit/100)\r\nreturn 400000;\r\nelse if (max_pixclk > 266667*limit/100)\r\nreturn freq_320;\r\nelse if (max_pixclk > 0)\r\nreturn 266667;\r\nelse\r\nreturn 200000;\r\n}\r\nstatic void vlv_get_cdclk(struct drm_i915_private *dev_priv,\r\nstruct intel_cdclk_state *cdclk_state)\r\n{\r\ncdclk_state->vco = vlv_get_hpll_vco(dev_priv);\r\ncdclk_state->cdclk = vlv_get_cck_clock(dev_priv, "cdclk",\r\nCCK_DISPLAY_CLOCK_CONTROL,\r\ncdclk_state->vco);\r\n}\r\nstatic void vlv_program_pfi_credits(struct drm_i915_private *dev_priv)\r\n{\r\nunsigned int credits, default_credits;\r\nif (IS_CHERRYVIEW(dev_priv))\r\ndefault_credits = PFI_CREDIT(12);\r\nelse\r\ndefault_credits = PFI_CREDIT(8);\r\nif (dev_priv->cdclk.hw.cdclk >= dev_priv->czclk_freq) {\r\nif (IS_CHERRYVIEW(dev_priv))\r\ncredits = PFI_CREDIT_63;\r\nelse\r\ncredits = PFI_CREDIT(15);\r\n} else {\r\ncredits = default_credits;\r\n}\r\nI915_WRITE(GCI_CONTROL, VGA_FAST_MODE_DISABLE |\r\ndefault_credits);\r\nI915_WRITE(GCI_CONTROL, VGA_FAST_MODE_DISABLE |\r\ncredits | PFI_CREDIT_RESEND);\r\nWARN_ON(I915_READ(GCI_CONTROL) & PFI_CREDIT_RESEND);\r\n}\r\nstatic void vlv_set_cdclk(struct drm_i915_private *dev_priv,\r\nconst struct intel_cdclk_state *cdclk_state)\r\n{\r\nint cdclk = cdclk_state->cdclk;\r\nu32 val, cmd;\r\nintel_display_power_get(dev_priv, POWER_DOMAIN_PIPE_A);\r\nif (cdclk >= 320000)\r\ncmd = 2;\r\nelse if (cdclk == 266667)\r\ncmd = 1;\r\nelse\r\ncmd = 0;\r\nmutex_lock(&dev_priv->rps.hw_lock);\r\nval = vlv_punit_read(dev_priv, PUNIT_REG_DSPFREQ);\r\nval &= ~DSPFREQGUAR_MASK;\r\nval |= (cmd << DSPFREQGUAR_SHIFT);\r\nvlv_punit_write(dev_priv, PUNIT_REG_DSPFREQ, val);\r\nif (wait_for((vlv_punit_read(dev_priv, PUNIT_REG_DSPFREQ) &\r\nDSPFREQSTAT_MASK) == (cmd << DSPFREQSTAT_SHIFT),\r\n50)) {\r\nDRM_ERROR("timed out waiting for CDclk change\n");\r\n}\r\nmutex_unlock(&dev_priv->rps.hw_lock);\r\nmutex_lock(&dev_priv->sb_lock);\r\nif (cdclk == 400000) {\r\nu32 divider;\r\ndivider = DIV_ROUND_CLOSEST(dev_priv->hpll_freq << 1,\r\ncdclk) - 1;\r\nval = vlv_cck_read(dev_priv, CCK_DISPLAY_CLOCK_CONTROL);\r\nval &= ~CCK_FREQUENCY_VALUES;\r\nval |= divider;\r\nvlv_cck_write(dev_priv, CCK_DISPLAY_CLOCK_CONTROL, val);\r\nif (wait_for((vlv_cck_read(dev_priv, CCK_DISPLAY_CLOCK_CONTROL) &\r\nCCK_FREQUENCY_STATUS) == (divider << CCK_FREQUENCY_STATUS_SHIFT),\r\n50))\r\nDRM_ERROR("timed out waiting for CDclk change\n");\r\n}\r\nval = vlv_bunit_read(dev_priv, BUNIT_REG_BISOC);\r\nval &= ~0x7f;\r\nif (cdclk == 400000)\r\nval |= 4500 / 250;\r\nelse\r\nval |= 3000 / 250;\r\nvlv_bunit_write(dev_priv, BUNIT_REG_BISOC, val);\r\nmutex_unlock(&dev_priv->sb_lock);\r\nintel_update_cdclk(dev_priv);\r\nvlv_program_pfi_credits(dev_priv);\r\nintel_display_power_put(dev_priv, POWER_DOMAIN_PIPE_A);\r\n}\r\nstatic void chv_set_cdclk(struct drm_i915_private *dev_priv,\r\nconst struct intel_cdclk_state *cdclk_state)\r\n{\r\nint cdclk = cdclk_state->cdclk;\r\nu32 val, cmd;\r\nswitch (cdclk) {\r\ncase 333333:\r\ncase 320000:\r\ncase 266667:\r\ncase 200000:\r\nbreak;\r\ndefault:\r\nMISSING_CASE(cdclk);\r\nreturn;\r\n}\r\nintel_display_power_get(dev_priv, POWER_DOMAIN_PIPE_A);\r\ncmd = DIV_ROUND_CLOSEST(dev_priv->hpll_freq << 1, cdclk) - 1;\r\nmutex_lock(&dev_priv->rps.hw_lock);\r\nval = vlv_punit_read(dev_priv, PUNIT_REG_DSPFREQ);\r\nval &= ~DSPFREQGUAR_MASK_CHV;\r\nval |= (cmd << DSPFREQGUAR_SHIFT_CHV);\r\nvlv_punit_write(dev_priv, PUNIT_REG_DSPFREQ, val);\r\nif (wait_for((vlv_punit_read(dev_priv, PUNIT_REG_DSPFREQ) &\r\nDSPFREQSTAT_MASK_CHV) == (cmd << DSPFREQSTAT_SHIFT_CHV),\r\n50)) {\r\nDRM_ERROR("timed out waiting for CDclk change\n");\r\n}\r\nmutex_unlock(&dev_priv->rps.hw_lock);\r\nintel_update_cdclk(dev_priv);\r\nvlv_program_pfi_credits(dev_priv);\r\nintel_display_power_put(dev_priv, POWER_DOMAIN_PIPE_A);\r\n}\r\nstatic int bdw_calc_cdclk(int max_pixclk)\r\n{\r\nif (max_pixclk > 540000)\r\nreturn 675000;\r\nelse if (max_pixclk > 450000)\r\nreturn 540000;\r\nelse if (max_pixclk > 337500)\r\nreturn 450000;\r\nelse\r\nreturn 337500;\r\n}\r\nstatic void bdw_get_cdclk(struct drm_i915_private *dev_priv,\r\nstruct intel_cdclk_state *cdclk_state)\r\n{\r\nuint32_t lcpll = I915_READ(LCPLL_CTL);\r\nuint32_t freq = lcpll & LCPLL_CLK_FREQ_MASK;\r\nif (lcpll & LCPLL_CD_SOURCE_FCLK)\r\ncdclk_state->cdclk = 800000;\r\nelse if (I915_READ(FUSE_STRAP) & HSW_CDCLK_LIMIT)\r\ncdclk_state->cdclk = 450000;\r\nelse if (freq == LCPLL_CLK_FREQ_450)\r\ncdclk_state->cdclk = 450000;\r\nelse if (freq == LCPLL_CLK_FREQ_54O_BDW)\r\ncdclk_state->cdclk = 540000;\r\nelse if (freq == LCPLL_CLK_FREQ_337_5_BDW)\r\ncdclk_state->cdclk = 337500;\r\nelse\r\ncdclk_state->cdclk = 675000;\r\n}\r\nstatic void bdw_set_cdclk(struct drm_i915_private *dev_priv,\r\nconst struct intel_cdclk_state *cdclk_state)\r\n{\r\nint cdclk = cdclk_state->cdclk;\r\nuint32_t val, data;\r\nint ret;\r\nif (WARN((I915_READ(LCPLL_CTL) &\r\n(LCPLL_PLL_DISABLE | LCPLL_PLL_LOCK |\r\nLCPLL_CD_CLOCK_DISABLE | LCPLL_ROOT_CD_CLOCK_DISABLE |\r\nLCPLL_CD2X_CLOCK_DISABLE | LCPLL_POWER_DOWN_ALLOW |\r\nLCPLL_CD_SOURCE_FCLK)) != LCPLL_PLL_LOCK,\r\n"trying to change cdclk frequency with cdclk not enabled\n"))\r\nreturn;\r\nmutex_lock(&dev_priv->rps.hw_lock);\r\nret = sandybridge_pcode_write(dev_priv,\r\nBDW_PCODE_DISPLAY_FREQ_CHANGE_REQ, 0x0);\r\nmutex_unlock(&dev_priv->rps.hw_lock);\r\nif (ret) {\r\nDRM_ERROR("failed to inform pcode about cdclk change\n");\r\nreturn;\r\n}\r\nval = I915_READ(LCPLL_CTL);\r\nval |= LCPLL_CD_SOURCE_FCLK;\r\nI915_WRITE(LCPLL_CTL, val);\r\nif (wait_for_us(I915_READ(LCPLL_CTL) &\r\nLCPLL_CD_SOURCE_FCLK_DONE, 1))\r\nDRM_ERROR("Switching to FCLK failed\n");\r\nval = I915_READ(LCPLL_CTL);\r\nval &= ~LCPLL_CLK_FREQ_MASK;\r\nswitch (cdclk) {\r\ncase 450000:\r\nval |= LCPLL_CLK_FREQ_450;\r\ndata = 0;\r\nbreak;\r\ncase 540000:\r\nval |= LCPLL_CLK_FREQ_54O_BDW;\r\ndata = 1;\r\nbreak;\r\ncase 337500:\r\nval |= LCPLL_CLK_FREQ_337_5_BDW;\r\ndata = 2;\r\nbreak;\r\ncase 675000:\r\nval |= LCPLL_CLK_FREQ_675_BDW;\r\ndata = 3;\r\nbreak;\r\ndefault:\r\nWARN(1, "invalid cdclk frequency\n");\r\nreturn;\r\n}\r\nI915_WRITE(LCPLL_CTL, val);\r\nval = I915_READ(LCPLL_CTL);\r\nval &= ~LCPLL_CD_SOURCE_FCLK;\r\nI915_WRITE(LCPLL_CTL, val);\r\nif (wait_for_us((I915_READ(LCPLL_CTL) &\r\nLCPLL_CD_SOURCE_FCLK_DONE) == 0, 1))\r\nDRM_ERROR("Switching back to LCPLL failed\n");\r\nmutex_lock(&dev_priv->rps.hw_lock);\r\nsandybridge_pcode_write(dev_priv, HSW_PCODE_DE_WRITE_FREQ_REQ, data);\r\nmutex_unlock(&dev_priv->rps.hw_lock);\r\nI915_WRITE(CDCLK_FREQ, DIV_ROUND_CLOSEST(cdclk, 1000) - 1);\r\nintel_update_cdclk(dev_priv);\r\nWARN(cdclk != dev_priv->cdclk.hw.cdclk,\r\n"cdclk requested %d kHz but got %d kHz\n",\r\ncdclk, dev_priv->cdclk.hw.cdclk);\r\n}\r\nstatic int skl_calc_cdclk(int max_pixclk, int vco)\r\n{\r\nif (vco == 8640000) {\r\nif (max_pixclk > 540000)\r\nreturn 617143;\r\nelse if (max_pixclk > 432000)\r\nreturn 540000;\r\nelse if (max_pixclk > 308571)\r\nreturn 432000;\r\nelse\r\nreturn 308571;\r\n} else {\r\nif (max_pixclk > 540000)\r\nreturn 675000;\r\nelse if (max_pixclk > 450000)\r\nreturn 540000;\r\nelse if (max_pixclk > 337500)\r\nreturn 450000;\r\nelse\r\nreturn 337500;\r\n}\r\n}\r\nstatic void skl_dpll0_update(struct drm_i915_private *dev_priv,\r\nstruct intel_cdclk_state *cdclk_state)\r\n{\r\nu32 val;\r\ncdclk_state->ref = 24000;\r\ncdclk_state->vco = 0;\r\nval = I915_READ(LCPLL1_CTL);\r\nif ((val & LCPLL_PLL_ENABLE) == 0)\r\nreturn;\r\nif (WARN_ON((val & LCPLL_PLL_LOCK) == 0))\r\nreturn;\r\nval = I915_READ(DPLL_CTRL1);\r\nif (WARN_ON((val & (DPLL_CTRL1_HDMI_MODE(SKL_DPLL0) |\r\nDPLL_CTRL1_SSC(SKL_DPLL0) |\r\nDPLL_CTRL1_OVERRIDE(SKL_DPLL0))) !=\r\nDPLL_CTRL1_OVERRIDE(SKL_DPLL0)))\r\nreturn;\r\nswitch (val & DPLL_CTRL1_LINK_RATE_MASK(SKL_DPLL0)) {\r\ncase DPLL_CTRL1_LINK_RATE(DPLL_CTRL1_LINK_RATE_810, SKL_DPLL0):\r\ncase DPLL_CTRL1_LINK_RATE(DPLL_CTRL1_LINK_RATE_1350, SKL_DPLL0):\r\ncase DPLL_CTRL1_LINK_RATE(DPLL_CTRL1_LINK_RATE_1620, SKL_DPLL0):\r\ncase DPLL_CTRL1_LINK_RATE(DPLL_CTRL1_LINK_RATE_2700, SKL_DPLL0):\r\ncdclk_state->vco = 8100000;\r\nbreak;\r\ncase DPLL_CTRL1_LINK_RATE(DPLL_CTRL1_LINK_RATE_1080, SKL_DPLL0):\r\ncase DPLL_CTRL1_LINK_RATE(DPLL_CTRL1_LINK_RATE_2160, SKL_DPLL0):\r\ncdclk_state->vco = 8640000;\r\nbreak;\r\ndefault:\r\nMISSING_CASE(val & DPLL_CTRL1_LINK_RATE_MASK(SKL_DPLL0));\r\nbreak;\r\n}\r\n}\r\nstatic void skl_get_cdclk(struct drm_i915_private *dev_priv,\r\nstruct intel_cdclk_state *cdclk_state)\r\n{\r\nu32 cdctl;\r\nskl_dpll0_update(dev_priv, cdclk_state);\r\ncdclk_state->cdclk = cdclk_state->ref;\r\nif (cdclk_state->vco == 0)\r\nreturn;\r\ncdctl = I915_READ(CDCLK_CTL);\r\nif (cdclk_state->vco == 8640000) {\r\nswitch (cdctl & CDCLK_FREQ_SEL_MASK) {\r\ncase CDCLK_FREQ_450_432:\r\ncdclk_state->cdclk = 432000;\r\nbreak;\r\ncase CDCLK_FREQ_337_308:\r\ncdclk_state->cdclk = 308571;\r\nbreak;\r\ncase CDCLK_FREQ_540:\r\ncdclk_state->cdclk = 540000;\r\nbreak;\r\ncase CDCLK_FREQ_675_617:\r\ncdclk_state->cdclk = 617143;\r\nbreak;\r\ndefault:\r\nMISSING_CASE(cdctl & CDCLK_FREQ_SEL_MASK);\r\nbreak;\r\n}\r\n} else {\r\nswitch (cdctl & CDCLK_FREQ_SEL_MASK) {\r\ncase CDCLK_FREQ_450_432:\r\ncdclk_state->cdclk = 450000;\r\nbreak;\r\ncase CDCLK_FREQ_337_308:\r\ncdclk_state->cdclk = 337500;\r\nbreak;\r\ncase CDCLK_FREQ_540:\r\ncdclk_state->cdclk = 540000;\r\nbreak;\r\ncase CDCLK_FREQ_675_617:\r\ncdclk_state->cdclk = 675000;\r\nbreak;\r\ndefault:\r\nMISSING_CASE(cdctl & CDCLK_FREQ_SEL_MASK);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int skl_cdclk_decimal(int cdclk)\r\n{\r\nreturn DIV_ROUND_CLOSEST(cdclk - 1000, 500);\r\n}\r\nstatic void skl_set_preferred_cdclk_vco(struct drm_i915_private *dev_priv,\r\nint vco)\r\n{\r\nbool changed = dev_priv->skl_preferred_vco_freq != vco;\r\ndev_priv->skl_preferred_vco_freq = vco;\r\nif (changed)\r\nintel_update_max_cdclk(dev_priv);\r\n}\r\nstatic void skl_dpll0_enable(struct drm_i915_private *dev_priv, int vco)\r\n{\r\nint min_cdclk = skl_calc_cdclk(0, vco);\r\nu32 val;\r\nWARN_ON(vco != 8100000 && vco != 8640000);\r\nval = CDCLK_FREQ_337_308 | skl_cdclk_decimal(min_cdclk);\r\nI915_WRITE(CDCLK_CTL, val);\r\nPOSTING_READ(CDCLK_CTL);\r\nval = I915_READ(DPLL_CTRL1);\r\nval &= ~(DPLL_CTRL1_HDMI_MODE(SKL_DPLL0) | DPLL_CTRL1_SSC(SKL_DPLL0) |\r\nDPLL_CTRL1_LINK_RATE_MASK(SKL_DPLL0));\r\nval |= DPLL_CTRL1_OVERRIDE(SKL_DPLL0);\r\nif (vco == 8640000)\r\nval |= DPLL_CTRL1_LINK_RATE(DPLL_CTRL1_LINK_RATE_1080,\r\nSKL_DPLL0);\r\nelse\r\nval |= DPLL_CTRL1_LINK_RATE(DPLL_CTRL1_LINK_RATE_810,\r\nSKL_DPLL0);\r\nI915_WRITE(DPLL_CTRL1, val);\r\nPOSTING_READ(DPLL_CTRL1);\r\nI915_WRITE(LCPLL1_CTL, I915_READ(LCPLL1_CTL) | LCPLL_PLL_ENABLE);\r\nif (intel_wait_for_register(dev_priv,\r\nLCPLL1_CTL, LCPLL_PLL_LOCK, LCPLL_PLL_LOCK,\r\n5))\r\nDRM_ERROR("DPLL0 not locked\n");\r\ndev_priv->cdclk.hw.vco = vco;\r\nskl_set_preferred_cdclk_vco(dev_priv, vco);\r\n}\r\nstatic void skl_dpll0_disable(struct drm_i915_private *dev_priv)\r\n{\r\nI915_WRITE(LCPLL1_CTL, I915_READ(LCPLL1_CTL) & ~LCPLL_PLL_ENABLE);\r\nif (intel_wait_for_register(dev_priv,\r\nLCPLL1_CTL, LCPLL_PLL_LOCK, 0,\r\n1))\r\nDRM_ERROR("Couldn't disable DPLL0\n");\r\ndev_priv->cdclk.hw.vco = 0;\r\n}\r\nstatic void skl_set_cdclk(struct drm_i915_private *dev_priv,\r\nconst struct intel_cdclk_state *cdclk_state)\r\n{\r\nint cdclk = cdclk_state->cdclk;\r\nint vco = cdclk_state->vco;\r\nu32 freq_select, pcu_ack;\r\nint ret;\r\nWARN_ON((cdclk == 24000) != (vco == 0));\r\nmutex_lock(&dev_priv->rps.hw_lock);\r\nret = skl_pcode_request(dev_priv, SKL_PCODE_CDCLK_CONTROL,\r\nSKL_CDCLK_PREPARE_FOR_CHANGE,\r\nSKL_CDCLK_READY_FOR_CHANGE,\r\nSKL_CDCLK_READY_FOR_CHANGE, 3);\r\nmutex_unlock(&dev_priv->rps.hw_lock);\r\nif (ret) {\r\nDRM_ERROR("Failed to inform PCU about cdclk change (%d)\n",\r\nret);\r\nreturn;\r\n}\r\nswitch (cdclk) {\r\ncase 450000:\r\ncase 432000:\r\nfreq_select = CDCLK_FREQ_450_432;\r\npcu_ack = 1;\r\nbreak;\r\ncase 540000:\r\nfreq_select = CDCLK_FREQ_540;\r\npcu_ack = 2;\r\nbreak;\r\ncase 308571:\r\ncase 337500:\r\ndefault:\r\nfreq_select = CDCLK_FREQ_337_308;\r\npcu_ack = 0;\r\nbreak;\r\ncase 617143:\r\ncase 675000:\r\nfreq_select = CDCLK_FREQ_675_617;\r\npcu_ack = 3;\r\nbreak;\r\n}\r\nif (dev_priv->cdclk.hw.vco != 0 &&\r\ndev_priv->cdclk.hw.vco != vco)\r\nskl_dpll0_disable(dev_priv);\r\nif (dev_priv->cdclk.hw.vco != vco)\r\nskl_dpll0_enable(dev_priv, vco);\r\nI915_WRITE(CDCLK_CTL, freq_select | skl_cdclk_decimal(cdclk));\r\nPOSTING_READ(CDCLK_CTL);\r\nmutex_lock(&dev_priv->rps.hw_lock);\r\nsandybridge_pcode_write(dev_priv, SKL_PCODE_CDCLK_CONTROL, pcu_ack);\r\nmutex_unlock(&dev_priv->rps.hw_lock);\r\nintel_update_cdclk(dev_priv);\r\n}\r\nstatic void skl_sanitize_cdclk(struct drm_i915_private *dev_priv)\r\n{\r\nuint32_t cdctl, expected;\r\nif ((I915_READ(SWF_ILK(0x18)) & 0x00FFFFFF) == 0)\r\ngoto sanitize;\r\nintel_update_cdclk(dev_priv);\r\nif (dev_priv->cdclk.hw.vco == 0 ||\r\ndev_priv->cdclk.hw.cdclk == dev_priv->cdclk.hw.ref)\r\ngoto sanitize;\r\ncdctl = I915_READ(CDCLK_CTL);\r\nexpected = (cdctl & CDCLK_FREQ_SEL_MASK) |\r\nskl_cdclk_decimal(dev_priv->cdclk.hw.cdclk);\r\nif (cdctl == expected)\r\nreturn;\r\nsanitize:\r\nDRM_DEBUG_KMS("Sanitizing cdclk programmed by pre-os\n");\r\ndev_priv->cdclk.hw.cdclk = 0;\r\ndev_priv->cdclk.hw.vco = -1;\r\n}\r\nvoid skl_init_cdclk(struct drm_i915_private *dev_priv)\r\n{\r\nstruct intel_cdclk_state cdclk_state;\r\nskl_sanitize_cdclk(dev_priv);\r\nif (dev_priv->cdclk.hw.cdclk != 0 &&\r\ndev_priv->cdclk.hw.vco != 0) {\r\nif (dev_priv->skl_preferred_vco_freq == 0)\r\nskl_set_preferred_cdclk_vco(dev_priv,\r\ndev_priv->cdclk.hw.vco);\r\nreturn;\r\n}\r\ncdclk_state = dev_priv->cdclk.hw;\r\ncdclk_state.vco = dev_priv->skl_preferred_vco_freq;\r\nif (cdclk_state.vco == 0)\r\ncdclk_state.vco = 8100000;\r\ncdclk_state.cdclk = skl_calc_cdclk(0, cdclk_state.vco);\r\nskl_set_cdclk(dev_priv, &cdclk_state);\r\n}\r\nvoid skl_uninit_cdclk(struct drm_i915_private *dev_priv)\r\n{\r\nstruct intel_cdclk_state cdclk_state = dev_priv->cdclk.hw;\r\ncdclk_state.cdclk = cdclk_state.ref;\r\ncdclk_state.vco = 0;\r\nskl_set_cdclk(dev_priv, &cdclk_state);\r\n}\r\nstatic int bxt_calc_cdclk(int max_pixclk)\r\n{\r\nif (max_pixclk > 576000)\r\nreturn 624000;\r\nelse if (max_pixclk > 384000)\r\nreturn 576000;\r\nelse if (max_pixclk > 288000)\r\nreturn 384000;\r\nelse if (max_pixclk > 144000)\r\nreturn 288000;\r\nelse\r\nreturn 144000;\r\n}\r\nstatic int glk_calc_cdclk(int max_pixclk)\r\n{\r\nif (max_pixclk > DIV_ROUND_UP(2 * 158400 * 99, 100))\r\nreturn 316800;\r\nelse if (max_pixclk > DIV_ROUND_UP(2 * 79200 * 99, 100))\r\nreturn 158400;\r\nelse\r\nreturn 79200;\r\n}\r\nstatic int bxt_de_pll_vco(struct drm_i915_private *dev_priv, int cdclk)\r\n{\r\nint ratio;\r\nif (cdclk == dev_priv->cdclk.hw.ref)\r\nreturn 0;\r\nswitch (cdclk) {\r\ndefault:\r\nMISSING_CASE(cdclk);\r\ncase 144000:\r\ncase 288000:\r\ncase 384000:\r\ncase 576000:\r\nratio = 60;\r\nbreak;\r\ncase 624000:\r\nratio = 65;\r\nbreak;\r\n}\r\nreturn dev_priv->cdclk.hw.ref * ratio;\r\n}\r\nstatic int glk_de_pll_vco(struct drm_i915_private *dev_priv, int cdclk)\r\n{\r\nint ratio;\r\nif (cdclk == dev_priv->cdclk.hw.ref)\r\nreturn 0;\r\nswitch (cdclk) {\r\ndefault:\r\nMISSING_CASE(cdclk);\r\ncase 79200:\r\ncase 158400:\r\ncase 316800:\r\nratio = 33;\r\nbreak;\r\n}\r\nreturn dev_priv->cdclk.hw.ref * ratio;\r\n}\r\nstatic void bxt_de_pll_update(struct drm_i915_private *dev_priv,\r\nstruct intel_cdclk_state *cdclk_state)\r\n{\r\nu32 val;\r\ncdclk_state->ref = 19200;\r\ncdclk_state->vco = 0;\r\nval = I915_READ(BXT_DE_PLL_ENABLE);\r\nif ((val & BXT_DE_PLL_PLL_ENABLE) == 0)\r\nreturn;\r\nif (WARN_ON((val & BXT_DE_PLL_LOCK) == 0))\r\nreturn;\r\nval = I915_READ(BXT_DE_PLL_CTL);\r\ncdclk_state->vco = (val & BXT_DE_PLL_RATIO_MASK) * cdclk_state->ref;\r\n}\r\nstatic void bxt_get_cdclk(struct drm_i915_private *dev_priv,\r\nstruct intel_cdclk_state *cdclk_state)\r\n{\r\nu32 divider;\r\nint div;\r\nbxt_de_pll_update(dev_priv, cdclk_state);\r\ncdclk_state->cdclk = cdclk_state->ref;\r\nif (cdclk_state->vco == 0)\r\nreturn;\r\ndivider = I915_READ(CDCLK_CTL) & BXT_CDCLK_CD2X_DIV_SEL_MASK;\r\nswitch (divider) {\r\ncase BXT_CDCLK_CD2X_DIV_SEL_1:\r\ndiv = 2;\r\nbreak;\r\ncase BXT_CDCLK_CD2X_DIV_SEL_1_5:\r\nWARN(IS_GEMINILAKE(dev_priv), "Unsupported divider\n");\r\ndiv = 3;\r\nbreak;\r\ncase BXT_CDCLK_CD2X_DIV_SEL_2:\r\ndiv = 4;\r\nbreak;\r\ncase BXT_CDCLK_CD2X_DIV_SEL_4:\r\ndiv = 8;\r\nbreak;\r\ndefault:\r\nMISSING_CASE(divider);\r\nreturn;\r\n}\r\ncdclk_state->cdclk = DIV_ROUND_CLOSEST(cdclk_state->vco, div);\r\n}\r\nstatic void bxt_de_pll_disable(struct drm_i915_private *dev_priv)\r\n{\r\nI915_WRITE(BXT_DE_PLL_ENABLE, 0);\r\nif (intel_wait_for_register(dev_priv,\r\nBXT_DE_PLL_ENABLE, BXT_DE_PLL_LOCK, 0,\r\n1))\r\nDRM_ERROR("timeout waiting for DE PLL unlock\n");\r\ndev_priv->cdclk.hw.vco = 0;\r\n}\r\nstatic void bxt_de_pll_enable(struct drm_i915_private *dev_priv, int vco)\r\n{\r\nint ratio = DIV_ROUND_CLOSEST(vco, dev_priv->cdclk.hw.ref);\r\nu32 val;\r\nval = I915_READ(BXT_DE_PLL_CTL);\r\nval &= ~BXT_DE_PLL_RATIO_MASK;\r\nval |= BXT_DE_PLL_RATIO(ratio);\r\nI915_WRITE(BXT_DE_PLL_CTL, val);\r\nI915_WRITE(BXT_DE_PLL_ENABLE, BXT_DE_PLL_PLL_ENABLE);\r\nif (intel_wait_for_register(dev_priv,\r\nBXT_DE_PLL_ENABLE,\r\nBXT_DE_PLL_LOCK,\r\nBXT_DE_PLL_LOCK,\r\n1))\r\nDRM_ERROR("timeout waiting for DE PLL lock\n");\r\ndev_priv->cdclk.hw.vco = vco;\r\n}\r\nstatic void bxt_set_cdclk(struct drm_i915_private *dev_priv,\r\nconst struct intel_cdclk_state *cdclk_state)\r\n{\r\nint cdclk = cdclk_state->cdclk;\r\nint vco = cdclk_state->vco;\r\nu32 val, divider;\r\nint ret;\r\nswitch (DIV_ROUND_CLOSEST(vco, cdclk)) {\r\ncase 8:\r\ndivider = BXT_CDCLK_CD2X_DIV_SEL_4;\r\nbreak;\r\ncase 4:\r\ndivider = BXT_CDCLK_CD2X_DIV_SEL_2;\r\nbreak;\r\ncase 3:\r\nWARN(IS_GEMINILAKE(dev_priv), "Unsupported divider\n");\r\ndivider = BXT_CDCLK_CD2X_DIV_SEL_1_5;\r\nbreak;\r\ncase 2:\r\ndivider = BXT_CDCLK_CD2X_DIV_SEL_1;\r\nbreak;\r\ndefault:\r\nWARN_ON(cdclk != dev_priv->cdclk.hw.ref);\r\nWARN_ON(vco != 0);\r\ndivider = BXT_CDCLK_CD2X_DIV_SEL_1;\r\nbreak;\r\n}\r\nmutex_lock(&dev_priv->rps.hw_lock);\r\nret = sandybridge_pcode_write(dev_priv, HSW_PCODE_DE_WRITE_FREQ_REQ,\r\n0x80000000);\r\nmutex_unlock(&dev_priv->rps.hw_lock);\r\nif (ret) {\r\nDRM_ERROR("PCode CDCLK freq change notify failed (err %d, freq %d)\n",\r\nret, cdclk);\r\nreturn;\r\n}\r\nif (dev_priv->cdclk.hw.vco != 0 &&\r\ndev_priv->cdclk.hw.vco != vco)\r\nbxt_de_pll_disable(dev_priv);\r\nif (dev_priv->cdclk.hw.vco != vco)\r\nbxt_de_pll_enable(dev_priv, vco);\r\nval = divider | skl_cdclk_decimal(cdclk);\r\nval |= BXT_CDCLK_CD2X_PIPE_NONE;\r\nif (cdclk >= 500000)\r\nval |= BXT_CDCLK_SSA_PRECHARGE_ENABLE;\r\nI915_WRITE(CDCLK_CTL, val);\r\nmutex_lock(&dev_priv->rps.hw_lock);\r\nret = sandybridge_pcode_write(dev_priv, HSW_PCODE_DE_WRITE_FREQ_REQ,\r\nDIV_ROUND_UP(cdclk, 25000));\r\nmutex_unlock(&dev_priv->rps.hw_lock);\r\nif (ret) {\r\nDRM_ERROR("PCode CDCLK freq set failed, (err %d, freq %d)\n",\r\nret, cdclk);\r\nreturn;\r\n}\r\nintel_update_cdclk(dev_priv);\r\n}\r\nstatic void bxt_sanitize_cdclk(struct drm_i915_private *dev_priv)\r\n{\r\nu32 cdctl, expected;\r\nintel_update_cdclk(dev_priv);\r\nif (dev_priv->cdclk.hw.vco == 0 ||\r\ndev_priv->cdclk.hw.cdclk == dev_priv->cdclk.hw.ref)\r\ngoto sanitize;\r\ncdctl = I915_READ(CDCLK_CTL);\r\ncdctl &= ~BXT_CDCLK_CD2X_PIPE_NONE;\r\nexpected = (cdctl & BXT_CDCLK_CD2X_DIV_SEL_MASK) |\r\nskl_cdclk_decimal(dev_priv->cdclk.hw.cdclk);\r\nif (dev_priv->cdclk.hw.cdclk >= 500000)\r\nexpected |= BXT_CDCLK_SSA_PRECHARGE_ENABLE;\r\nif (cdctl == expected)\r\nreturn;\r\nsanitize:\r\nDRM_DEBUG_KMS("Sanitizing cdclk programmed by pre-os\n");\r\ndev_priv->cdclk.hw.cdclk = 0;\r\ndev_priv->cdclk.hw.vco = -1;\r\n}\r\nvoid bxt_init_cdclk(struct drm_i915_private *dev_priv)\r\n{\r\nstruct intel_cdclk_state cdclk_state;\r\nbxt_sanitize_cdclk(dev_priv);\r\nif (dev_priv->cdclk.hw.cdclk != 0 &&\r\ndev_priv->cdclk.hw.vco != 0)\r\nreturn;\r\ncdclk_state = dev_priv->cdclk.hw;\r\nif (IS_GEMINILAKE(dev_priv)) {\r\ncdclk_state.cdclk = glk_calc_cdclk(0);\r\ncdclk_state.vco = glk_de_pll_vco(dev_priv, cdclk_state.cdclk);\r\n} else {\r\ncdclk_state.cdclk = bxt_calc_cdclk(0);\r\ncdclk_state.vco = bxt_de_pll_vco(dev_priv, cdclk_state.cdclk);\r\n}\r\nbxt_set_cdclk(dev_priv, &cdclk_state);\r\n}\r\nvoid bxt_uninit_cdclk(struct drm_i915_private *dev_priv)\r\n{\r\nstruct intel_cdclk_state cdclk_state = dev_priv->cdclk.hw;\r\ncdclk_state.cdclk = cdclk_state.ref;\r\ncdclk_state.vco = 0;\r\nbxt_set_cdclk(dev_priv, &cdclk_state);\r\n}\r\nstatic int cnl_calc_cdclk(int max_pixclk)\r\n{\r\nif (max_pixclk > 336000)\r\nreturn 528000;\r\nelse if (max_pixclk > 168000)\r\nreturn 336000;\r\nelse\r\nreturn 168000;\r\n}\r\nstatic void cnl_cdclk_pll_update(struct drm_i915_private *dev_priv,\r\nstruct intel_cdclk_state *cdclk_state)\r\n{\r\nu32 val;\r\nif (I915_READ(SKL_DSSM) & CNL_DSSM_CDCLK_PLL_REFCLK_24MHz)\r\ncdclk_state->ref = 24000;\r\nelse\r\ncdclk_state->ref = 19200;\r\ncdclk_state->vco = 0;\r\nval = I915_READ(BXT_DE_PLL_ENABLE);\r\nif ((val & BXT_DE_PLL_PLL_ENABLE) == 0)\r\nreturn;\r\nif (WARN_ON((val & BXT_DE_PLL_LOCK) == 0))\r\nreturn;\r\ncdclk_state->vco = (val & CNL_CDCLK_PLL_RATIO_MASK) * cdclk_state->ref;\r\n}\r\nstatic void cnl_get_cdclk(struct drm_i915_private *dev_priv,\r\nstruct intel_cdclk_state *cdclk_state)\r\n{\r\nu32 divider;\r\nint div;\r\ncnl_cdclk_pll_update(dev_priv, cdclk_state);\r\ncdclk_state->cdclk = cdclk_state->ref;\r\nif (cdclk_state->vco == 0)\r\nreturn;\r\ndivider = I915_READ(CDCLK_CTL) & BXT_CDCLK_CD2X_DIV_SEL_MASK;\r\nswitch (divider) {\r\ncase BXT_CDCLK_CD2X_DIV_SEL_1:\r\ndiv = 2;\r\nbreak;\r\ncase BXT_CDCLK_CD2X_DIV_SEL_2:\r\ndiv = 4;\r\nbreak;\r\ndefault:\r\nMISSING_CASE(divider);\r\nreturn;\r\n}\r\ncdclk_state->cdclk = DIV_ROUND_CLOSEST(cdclk_state->vco, div);\r\n}\r\nstatic void cnl_cdclk_pll_disable(struct drm_i915_private *dev_priv)\r\n{\r\nu32 val;\r\nval = I915_READ(BXT_DE_PLL_ENABLE);\r\nval &= ~BXT_DE_PLL_PLL_ENABLE;\r\nI915_WRITE(BXT_DE_PLL_ENABLE, val);\r\nif (wait_for((I915_READ(BXT_DE_PLL_ENABLE) & BXT_DE_PLL_LOCK) == 0, 1))\r\nDRM_ERROR("timout waiting for CDCLK PLL unlock\n");\r\ndev_priv->cdclk.hw.vco = 0;\r\n}\r\nstatic void cnl_cdclk_pll_enable(struct drm_i915_private *dev_priv, int vco)\r\n{\r\nint ratio = DIV_ROUND_CLOSEST(vco, dev_priv->cdclk.hw.ref);\r\nu32 val;\r\nval = CNL_CDCLK_PLL_RATIO(ratio);\r\nI915_WRITE(BXT_DE_PLL_ENABLE, val);\r\nval |= BXT_DE_PLL_PLL_ENABLE;\r\nI915_WRITE(BXT_DE_PLL_ENABLE, val);\r\nif (wait_for((I915_READ(BXT_DE_PLL_ENABLE) & BXT_DE_PLL_LOCK) != 0, 1))\r\nDRM_ERROR("timout waiting for CDCLK PLL lock\n");\r\ndev_priv->cdclk.hw.vco = vco;\r\n}\r\nstatic void cnl_set_cdclk(struct drm_i915_private *dev_priv,\r\nconst struct intel_cdclk_state *cdclk_state)\r\n{\r\nint cdclk = cdclk_state->cdclk;\r\nint vco = cdclk_state->vco;\r\nu32 val, divider, pcu_ack;\r\nint ret;\r\nmutex_lock(&dev_priv->rps.hw_lock);\r\nret = skl_pcode_request(dev_priv, SKL_PCODE_CDCLK_CONTROL,\r\nSKL_CDCLK_PREPARE_FOR_CHANGE,\r\nSKL_CDCLK_READY_FOR_CHANGE,\r\nSKL_CDCLK_READY_FOR_CHANGE, 3);\r\nmutex_unlock(&dev_priv->rps.hw_lock);\r\nif (ret) {\r\nDRM_ERROR("Failed to inform PCU about cdclk change (%d)\n",\r\nret);\r\nreturn;\r\n}\r\nswitch (DIV_ROUND_CLOSEST(vco, cdclk)) {\r\ncase 4:\r\ndivider = BXT_CDCLK_CD2X_DIV_SEL_2;\r\nbreak;\r\ncase 2:\r\ndivider = BXT_CDCLK_CD2X_DIV_SEL_1;\r\nbreak;\r\ndefault:\r\nWARN_ON(cdclk != dev_priv->cdclk.hw.ref);\r\nWARN_ON(vco != 0);\r\ndivider = BXT_CDCLK_CD2X_DIV_SEL_1;\r\nbreak;\r\n}\r\nswitch (cdclk) {\r\ncase 528000:\r\npcu_ack = 2;\r\nbreak;\r\ncase 336000:\r\npcu_ack = 1;\r\nbreak;\r\ncase 168000:\r\ndefault:\r\npcu_ack = 0;\r\nbreak;\r\n}\r\nif (dev_priv->cdclk.hw.vco != 0 &&\r\ndev_priv->cdclk.hw.vco != vco)\r\ncnl_cdclk_pll_disable(dev_priv);\r\nif (dev_priv->cdclk.hw.vco != vco)\r\ncnl_cdclk_pll_enable(dev_priv, vco);\r\nval = divider | skl_cdclk_decimal(cdclk);\r\nval |= BXT_CDCLK_CD2X_PIPE_NONE;\r\nI915_WRITE(CDCLK_CTL, val);\r\nmutex_lock(&dev_priv->rps.hw_lock);\r\nsandybridge_pcode_write(dev_priv, SKL_PCODE_CDCLK_CONTROL, pcu_ack);\r\nmutex_unlock(&dev_priv->rps.hw_lock);\r\nintel_update_cdclk(dev_priv);\r\n}\r\nstatic int cnl_cdclk_pll_vco(struct drm_i915_private *dev_priv, int cdclk)\r\n{\r\nint ratio;\r\nif (cdclk == dev_priv->cdclk.hw.ref)\r\nreturn 0;\r\nswitch (cdclk) {\r\ndefault:\r\nMISSING_CASE(cdclk);\r\ncase 168000:\r\ncase 336000:\r\nratio = dev_priv->cdclk.hw.ref == 19200 ? 35 : 28;\r\nbreak;\r\ncase 528000:\r\nratio = dev_priv->cdclk.hw.ref == 19200 ? 55 : 44;\r\nbreak;\r\n}\r\nreturn dev_priv->cdclk.hw.ref * ratio;\r\n}\r\nstatic void cnl_sanitize_cdclk(struct drm_i915_private *dev_priv)\r\n{\r\nu32 cdctl, expected;\r\nintel_update_cdclk(dev_priv);\r\nif (dev_priv->cdclk.hw.vco == 0 ||\r\ndev_priv->cdclk.hw.cdclk == dev_priv->cdclk.hw.ref)\r\ngoto sanitize;\r\ncdctl = I915_READ(CDCLK_CTL);\r\ncdctl &= ~BXT_CDCLK_CD2X_PIPE_NONE;\r\nexpected = (cdctl & BXT_CDCLK_CD2X_DIV_SEL_MASK) |\r\nskl_cdclk_decimal(dev_priv->cdclk.hw.cdclk);\r\nif (cdctl == expected)\r\nreturn;\r\nsanitize:\r\nDRM_DEBUG_KMS("Sanitizing cdclk programmed by pre-os\n");\r\ndev_priv->cdclk.hw.cdclk = 0;\r\ndev_priv->cdclk.hw.vco = -1;\r\n}\r\nvoid cnl_init_cdclk(struct drm_i915_private *dev_priv)\r\n{\r\nstruct intel_cdclk_state cdclk_state;\r\ncnl_sanitize_cdclk(dev_priv);\r\nif (dev_priv->cdclk.hw.cdclk != 0 &&\r\ndev_priv->cdclk.hw.vco != 0)\r\nreturn;\r\ncdclk_state = dev_priv->cdclk.hw;\r\ncdclk_state.cdclk = cnl_calc_cdclk(0);\r\ncdclk_state.vco = cnl_cdclk_pll_vco(dev_priv, cdclk_state.cdclk);\r\ncnl_set_cdclk(dev_priv, &cdclk_state);\r\n}\r\nvoid cnl_uninit_cdclk(struct drm_i915_private *dev_priv)\r\n{\r\nstruct intel_cdclk_state cdclk_state = dev_priv->cdclk.hw;\r\ncdclk_state.cdclk = cdclk_state.ref;\r\ncdclk_state.vco = 0;\r\ncnl_set_cdclk(dev_priv, &cdclk_state);\r\n}\r\nbool intel_cdclk_state_compare(const struct intel_cdclk_state *a,\r\nconst struct intel_cdclk_state *b)\r\n{\r\nreturn memcmp(a, b, sizeof(*a)) == 0;\r\n}\r\nvoid intel_set_cdclk(struct drm_i915_private *dev_priv,\r\nconst struct intel_cdclk_state *cdclk_state)\r\n{\r\nif (intel_cdclk_state_compare(&dev_priv->cdclk.hw, cdclk_state))\r\nreturn;\r\nif (WARN_ON_ONCE(!dev_priv->display.set_cdclk))\r\nreturn;\r\nDRM_DEBUG_DRIVER("Changing CDCLK to %d kHz, VCO %d kHz, ref %d kHz\n",\r\ncdclk_state->cdclk, cdclk_state->vco,\r\ncdclk_state->ref);\r\ndev_priv->display.set_cdclk(dev_priv, cdclk_state);\r\n}\r\nstatic int bdw_adjust_min_pipe_pixel_rate(struct intel_crtc_state *crtc_state,\r\nint pixel_rate)\r\n{\r\nstruct drm_i915_private *dev_priv =\r\nto_i915(crtc_state->base.crtc->dev);\r\nif (IS_BROADWELL(dev_priv) && crtc_state->ips_enabled)\r\npixel_rate = DIV_ROUND_UP(pixel_rate * 100, 95);\r\nif (intel_crtc_has_dp_encoder(crtc_state) &&\r\ncrtc_state->has_audio &&\r\ncrtc_state->port_clock >= 540000 &&\r\ncrtc_state->lane_count == 4) {\r\nif (IS_CANNONLAKE(dev_priv))\r\npixel_rate = max(316800, pixel_rate);\r\nelse if (IS_GEMINILAKE(dev_priv))\r\npixel_rate = max(2 * 316800, pixel_rate);\r\nelse\r\npixel_rate = max(432000, pixel_rate);\r\n}\r\nif (crtc_state->has_audio && INTEL_GEN(dev_priv) >= 9) {\r\nif (IS_GEMINILAKE(dev_priv))\r\npixel_rate = max(2 * 2 * 96000, pixel_rate);\r\nelse\r\npixel_rate = max(2 * 96000, pixel_rate);\r\n}\r\nreturn pixel_rate;\r\n}\r\nstatic int intel_max_pixel_rate(struct drm_atomic_state *state)\r\n{\r\nstruct intel_atomic_state *intel_state = to_intel_atomic_state(state);\r\nstruct drm_i915_private *dev_priv = to_i915(state->dev);\r\nstruct drm_crtc *crtc;\r\nstruct drm_crtc_state *cstate;\r\nstruct intel_crtc_state *crtc_state;\r\nunsigned int max_pixel_rate = 0, i;\r\nenum pipe pipe;\r\nmemcpy(intel_state->min_pixclk, dev_priv->min_pixclk,\r\nsizeof(intel_state->min_pixclk));\r\nfor_each_new_crtc_in_state(state, crtc, cstate, i) {\r\nint pixel_rate;\r\ncrtc_state = to_intel_crtc_state(cstate);\r\nif (!crtc_state->base.enable) {\r\nintel_state->min_pixclk[i] = 0;\r\ncontinue;\r\n}\r\npixel_rate = crtc_state->pixel_rate;\r\nif (IS_BROADWELL(dev_priv) || INTEL_GEN(dev_priv) >= 9)\r\npixel_rate =\r\nbdw_adjust_min_pipe_pixel_rate(crtc_state,\r\npixel_rate);\r\nintel_state->min_pixclk[i] = pixel_rate;\r\n}\r\nfor_each_pipe(dev_priv, pipe)\r\nmax_pixel_rate = max(intel_state->min_pixclk[pipe],\r\nmax_pixel_rate);\r\nreturn max_pixel_rate;\r\n}\r\nstatic int vlv_modeset_calc_cdclk(struct drm_atomic_state *state)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(state->dev);\r\nint max_pixclk = intel_max_pixel_rate(state);\r\nstruct intel_atomic_state *intel_state =\r\nto_intel_atomic_state(state);\r\nint cdclk;\r\ncdclk = vlv_calc_cdclk(dev_priv, max_pixclk);\r\nif (cdclk > dev_priv->max_cdclk_freq) {\r\nDRM_DEBUG_KMS("requested cdclk (%d kHz) exceeds max (%d kHz)\n",\r\ncdclk, dev_priv->max_cdclk_freq);\r\nreturn -EINVAL;\r\n}\r\nintel_state->cdclk.logical.cdclk = cdclk;\r\nif (!intel_state->active_crtcs) {\r\ncdclk = vlv_calc_cdclk(dev_priv, 0);\r\nintel_state->cdclk.actual.cdclk = cdclk;\r\n} else {\r\nintel_state->cdclk.actual =\r\nintel_state->cdclk.logical;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bdw_modeset_calc_cdclk(struct drm_atomic_state *state)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(state->dev);\r\nstruct intel_atomic_state *intel_state = to_intel_atomic_state(state);\r\nint max_pixclk = intel_max_pixel_rate(state);\r\nint cdclk;\r\ncdclk = bdw_calc_cdclk(max_pixclk);\r\nif (cdclk > dev_priv->max_cdclk_freq) {\r\nDRM_DEBUG_KMS("requested cdclk (%d kHz) exceeds max (%d kHz)\n",\r\ncdclk, dev_priv->max_cdclk_freq);\r\nreturn -EINVAL;\r\n}\r\nintel_state->cdclk.logical.cdclk = cdclk;\r\nif (!intel_state->active_crtcs) {\r\ncdclk = bdw_calc_cdclk(0);\r\nintel_state->cdclk.actual.cdclk = cdclk;\r\n} else {\r\nintel_state->cdclk.actual =\r\nintel_state->cdclk.logical;\r\n}\r\nreturn 0;\r\n}\r\nstatic int skl_modeset_calc_cdclk(struct drm_atomic_state *state)\r\n{\r\nstruct intel_atomic_state *intel_state = to_intel_atomic_state(state);\r\nstruct drm_i915_private *dev_priv = to_i915(state->dev);\r\nconst int max_pixclk = intel_max_pixel_rate(state);\r\nint cdclk, vco;\r\nvco = intel_state->cdclk.logical.vco;\r\nif (!vco)\r\nvco = dev_priv->skl_preferred_vco_freq;\r\ncdclk = skl_calc_cdclk(max_pixclk, vco);\r\nif (cdclk > dev_priv->max_cdclk_freq) {\r\nDRM_DEBUG_KMS("requested cdclk (%d kHz) exceeds max (%d kHz)\n",\r\ncdclk, dev_priv->max_cdclk_freq);\r\nreturn -EINVAL;\r\n}\r\nintel_state->cdclk.logical.vco = vco;\r\nintel_state->cdclk.logical.cdclk = cdclk;\r\nif (!intel_state->active_crtcs) {\r\ncdclk = skl_calc_cdclk(0, vco);\r\nintel_state->cdclk.actual.vco = vco;\r\nintel_state->cdclk.actual.cdclk = cdclk;\r\n} else {\r\nintel_state->cdclk.actual =\r\nintel_state->cdclk.logical;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bxt_modeset_calc_cdclk(struct drm_atomic_state *state)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(state->dev);\r\nint max_pixclk = intel_max_pixel_rate(state);\r\nstruct intel_atomic_state *intel_state =\r\nto_intel_atomic_state(state);\r\nint cdclk, vco;\r\nif (IS_GEMINILAKE(dev_priv)) {\r\ncdclk = glk_calc_cdclk(max_pixclk);\r\nvco = glk_de_pll_vco(dev_priv, cdclk);\r\n} else {\r\ncdclk = bxt_calc_cdclk(max_pixclk);\r\nvco = bxt_de_pll_vco(dev_priv, cdclk);\r\n}\r\nif (cdclk > dev_priv->max_cdclk_freq) {\r\nDRM_DEBUG_KMS("requested cdclk (%d kHz) exceeds max (%d kHz)\n",\r\ncdclk, dev_priv->max_cdclk_freq);\r\nreturn -EINVAL;\r\n}\r\nintel_state->cdclk.logical.vco = vco;\r\nintel_state->cdclk.logical.cdclk = cdclk;\r\nif (!intel_state->active_crtcs) {\r\nif (IS_GEMINILAKE(dev_priv)) {\r\ncdclk = glk_calc_cdclk(0);\r\nvco = glk_de_pll_vco(dev_priv, cdclk);\r\n} else {\r\ncdclk = bxt_calc_cdclk(0);\r\nvco = bxt_de_pll_vco(dev_priv, cdclk);\r\n}\r\nintel_state->cdclk.actual.vco = vco;\r\nintel_state->cdclk.actual.cdclk = cdclk;\r\n} else {\r\nintel_state->cdclk.actual =\r\nintel_state->cdclk.logical;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cnl_modeset_calc_cdclk(struct drm_atomic_state *state)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(state->dev);\r\nstruct intel_atomic_state *intel_state =\r\nto_intel_atomic_state(state);\r\nint max_pixclk = intel_max_pixel_rate(state);\r\nint cdclk, vco;\r\ncdclk = cnl_calc_cdclk(max_pixclk);\r\nvco = cnl_cdclk_pll_vco(dev_priv, cdclk);\r\nif (cdclk > dev_priv->max_cdclk_freq) {\r\nDRM_DEBUG_KMS("requested cdclk (%d kHz) exceeds max (%d kHz)\n",\r\ncdclk, dev_priv->max_cdclk_freq);\r\nreturn -EINVAL;\r\n}\r\nintel_state->cdclk.logical.vco = vco;\r\nintel_state->cdclk.logical.cdclk = cdclk;\r\nif (!intel_state->active_crtcs) {\r\ncdclk = cnl_calc_cdclk(0);\r\nvco = cnl_cdclk_pll_vco(dev_priv, cdclk);\r\nintel_state->cdclk.actual.vco = vco;\r\nintel_state->cdclk.actual.cdclk = cdclk;\r\n} else {\r\nintel_state->cdclk.actual =\r\nintel_state->cdclk.logical;\r\n}\r\nreturn 0;\r\n}\r\nstatic int intel_compute_max_dotclk(struct drm_i915_private *dev_priv)\r\n{\r\nint max_cdclk_freq = dev_priv->max_cdclk_freq;\r\nif (IS_GEMINILAKE(dev_priv))\r\nreturn 2 * max_cdclk_freq * 99 / 100;\r\nelse if (INTEL_INFO(dev_priv)->gen >= 9 ||\r\nIS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv))\r\nreturn max_cdclk_freq;\r\nelse if (IS_CHERRYVIEW(dev_priv))\r\nreturn max_cdclk_freq*95/100;\r\nelse if (INTEL_INFO(dev_priv)->gen < 4)\r\nreturn 2*max_cdclk_freq*90/100;\r\nelse\r\nreturn max_cdclk_freq*90/100;\r\n}\r\nvoid intel_update_max_cdclk(struct drm_i915_private *dev_priv)\r\n{\r\nif (IS_CANNONLAKE(dev_priv)) {\r\ndev_priv->max_cdclk_freq = 528000;\r\n} else if (IS_GEN9_BC(dev_priv)) {\r\nu32 limit = I915_READ(SKL_DFSM) & SKL_DFSM_CDCLK_LIMIT_MASK;\r\nint max_cdclk, vco;\r\nvco = dev_priv->skl_preferred_vco_freq;\r\nWARN_ON(vco != 8100000 && vco != 8640000);\r\nif (limit == SKL_DFSM_CDCLK_LIMIT_675)\r\nmax_cdclk = 617143;\r\nelse if (limit == SKL_DFSM_CDCLK_LIMIT_540)\r\nmax_cdclk = 540000;\r\nelse if (limit == SKL_DFSM_CDCLK_LIMIT_450)\r\nmax_cdclk = 432000;\r\nelse\r\nmax_cdclk = 308571;\r\ndev_priv->max_cdclk_freq = skl_calc_cdclk(max_cdclk, vco);\r\n} else if (IS_GEMINILAKE(dev_priv)) {\r\ndev_priv->max_cdclk_freq = 316800;\r\n} else if (IS_BROXTON(dev_priv)) {\r\ndev_priv->max_cdclk_freq = 624000;\r\n} else if (IS_BROADWELL(dev_priv)) {\r\nif (I915_READ(FUSE_STRAP) & HSW_CDCLK_LIMIT)\r\ndev_priv->max_cdclk_freq = 450000;\r\nelse if (IS_BDW_ULX(dev_priv))\r\ndev_priv->max_cdclk_freq = 450000;\r\nelse if (IS_BDW_ULT(dev_priv))\r\ndev_priv->max_cdclk_freq = 540000;\r\nelse\r\ndev_priv->max_cdclk_freq = 675000;\r\n} else if (IS_CHERRYVIEW(dev_priv)) {\r\ndev_priv->max_cdclk_freq = 320000;\r\n} else if (IS_VALLEYVIEW(dev_priv)) {\r\ndev_priv->max_cdclk_freq = 400000;\r\n} else {\r\ndev_priv->max_cdclk_freq = dev_priv->cdclk.hw.cdclk;\r\n}\r\ndev_priv->max_dotclk_freq = intel_compute_max_dotclk(dev_priv);\r\nDRM_DEBUG_DRIVER("Max CD clock rate: %d kHz\n",\r\ndev_priv->max_cdclk_freq);\r\nDRM_DEBUG_DRIVER("Max dotclock rate: %d kHz\n",\r\ndev_priv->max_dotclk_freq);\r\n}\r\nvoid intel_update_cdclk(struct drm_i915_private *dev_priv)\r\n{\r\ndev_priv->display.get_cdclk(dev_priv, &dev_priv->cdclk.hw);\r\nDRM_DEBUG_DRIVER("Current CD clock rate: %d kHz, VCO: %d kHz, ref: %d kHz\n",\r\ndev_priv->cdclk.hw.cdclk, dev_priv->cdclk.hw.vco,\r\ndev_priv->cdclk.hw.ref);\r\nif (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))\r\nI915_WRITE(GMBUSFREQ_VLV,\r\nDIV_ROUND_UP(dev_priv->cdclk.hw.cdclk, 1000));\r\n}\r\nstatic int cnp_rawclk(struct drm_i915_private *dev_priv)\r\n{\r\nu32 rawclk;\r\nint divider, fraction;\r\nif (I915_READ(SFUSE_STRAP) & SFUSE_STRAP_RAW_FREQUENCY) {\r\ndivider = 24000;\r\nfraction = 0;\r\n} else {\r\ndivider = 19000;\r\nfraction = 200;\r\n}\r\nrawclk = CNP_RAWCLK_DIV((divider / 1000) - 1);\r\nif (fraction)\r\nrawclk |= CNP_RAWCLK_FRAC(DIV_ROUND_CLOSEST(1000,\r\nfraction) - 1);\r\nI915_WRITE(PCH_RAWCLK_FREQ, rawclk);\r\nreturn divider + fraction;\r\n}\r\nstatic int pch_rawclk(struct drm_i915_private *dev_priv)\r\n{\r\nreturn (I915_READ(PCH_RAWCLK_FREQ) & RAWCLK_FREQ_MASK) * 1000;\r\n}\r\nstatic int vlv_hrawclk(struct drm_i915_private *dev_priv)\r\n{\r\nreturn vlv_get_cck_clock_hpll(dev_priv, "hrawclk",\r\nCCK_DISPLAY_REF_CLOCK_CONTROL);\r\n}\r\nstatic int g4x_hrawclk(struct drm_i915_private *dev_priv)\r\n{\r\nuint32_t clkcfg;\r\nclkcfg = I915_READ(CLKCFG);\r\nswitch (clkcfg & CLKCFG_FSB_MASK) {\r\ncase CLKCFG_FSB_400:\r\nreturn 100000;\r\ncase CLKCFG_FSB_533:\r\nreturn 133333;\r\ncase CLKCFG_FSB_667:\r\nreturn 166667;\r\ncase CLKCFG_FSB_800:\r\nreturn 200000;\r\ncase CLKCFG_FSB_1067:\r\ncase CLKCFG_FSB_1067_ALT:\r\nreturn 266667;\r\ncase CLKCFG_FSB_1333:\r\ncase CLKCFG_FSB_1333_ALT:\r\nreturn 333333;\r\ndefault:\r\nreturn 133333;\r\n}\r\n}\r\nvoid intel_update_rawclk(struct drm_i915_private *dev_priv)\r\n{\r\nif (HAS_PCH_CNP(dev_priv))\r\ndev_priv->rawclk_freq = cnp_rawclk(dev_priv);\r\nelse if (HAS_PCH_SPLIT(dev_priv))\r\ndev_priv->rawclk_freq = pch_rawclk(dev_priv);\r\nelse if (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))\r\ndev_priv->rawclk_freq = vlv_hrawclk(dev_priv);\r\nelse if (IS_G4X(dev_priv) || IS_PINEVIEW(dev_priv))\r\ndev_priv->rawclk_freq = g4x_hrawclk(dev_priv);\r\nelse\r\nreturn;\r\nDRM_DEBUG_DRIVER("rawclk rate: %d kHz\n", dev_priv->rawclk_freq);\r\n}\r\nvoid intel_init_cdclk_hooks(struct drm_i915_private *dev_priv)\r\n{\r\nif (IS_CHERRYVIEW(dev_priv)) {\r\ndev_priv->display.set_cdclk = chv_set_cdclk;\r\ndev_priv->display.modeset_calc_cdclk =\r\nvlv_modeset_calc_cdclk;\r\n} else if (IS_VALLEYVIEW(dev_priv)) {\r\ndev_priv->display.set_cdclk = vlv_set_cdclk;\r\ndev_priv->display.modeset_calc_cdclk =\r\nvlv_modeset_calc_cdclk;\r\n} else if (IS_BROADWELL(dev_priv)) {\r\ndev_priv->display.set_cdclk = bdw_set_cdclk;\r\ndev_priv->display.modeset_calc_cdclk =\r\nbdw_modeset_calc_cdclk;\r\n} else if (IS_GEN9_LP(dev_priv)) {\r\ndev_priv->display.set_cdclk = bxt_set_cdclk;\r\ndev_priv->display.modeset_calc_cdclk =\r\nbxt_modeset_calc_cdclk;\r\n} else if (IS_GEN9_BC(dev_priv)) {\r\ndev_priv->display.set_cdclk = skl_set_cdclk;\r\ndev_priv->display.modeset_calc_cdclk =\r\nskl_modeset_calc_cdclk;\r\n} else if (IS_CANNONLAKE(dev_priv)) {\r\ndev_priv->display.set_cdclk = cnl_set_cdclk;\r\ndev_priv->display.modeset_calc_cdclk =\r\ncnl_modeset_calc_cdclk;\r\n}\r\nif (IS_CANNONLAKE(dev_priv))\r\ndev_priv->display.get_cdclk = cnl_get_cdclk;\r\nelse if (IS_GEN9_BC(dev_priv))\r\ndev_priv->display.get_cdclk = skl_get_cdclk;\r\nelse if (IS_GEN9_LP(dev_priv))\r\ndev_priv->display.get_cdclk = bxt_get_cdclk;\r\nelse if (IS_BROADWELL(dev_priv))\r\ndev_priv->display.get_cdclk = bdw_get_cdclk;\r\nelse if (IS_HASWELL(dev_priv))\r\ndev_priv->display.get_cdclk = hsw_get_cdclk;\r\nelse if (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))\r\ndev_priv->display.get_cdclk = vlv_get_cdclk;\r\nelse if (IS_GEN6(dev_priv) || IS_IVYBRIDGE(dev_priv))\r\ndev_priv->display.get_cdclk = fixed_400mhz_get_cdclk;\r\nelse if (IS_GEN5(dev_priv))\r\ndev_priv->display.get_cdclk = fixed_450mhz_get_cdclk;\r\nelse if (IS_GM45(dev_priv))\r\ndev_priv->display.get_cdclk = gm45_get_cdclk;\r\nelse if (IS_G45(dev_priv))\r\ndev_priv->display.get_cdclk = g33_get_cdclk;\r\nelse if (IS_I965GM(dev_priv))\r\ndev_priv->display.get_cdclk = i965gm_get_cdclk;\r\nelse if (IS_I965G(dev_priv))\r\ndev_priv->display.get_cdclk = fixed_400mhz_get_cdclk;\r\nelse if (IS_PINEVIEW(dev_priv))\r\ndev_priv->display.get_cdclk = pnv_get_cdclk;\r\nelse if (IS_G33(dev_priv))\r\ndev_priv->display.get_cdclk = g33_get_cdclk;\r\nelse if (IS_I945GM(dev_priv))\r\ndev_priv->display.get_cdclk = i945gm_get_cdclk;\r\nelse if (IS_I945G(dev_priv))\r\ndev_priv->display.get_cdclk = fixed_400mhz_get_cdclk;\r\nelse if (IS_I915GM(dev_priv))\r\ndev_priv->display.get_cdclk = i915gm_get_cdclk;\r\nelse if (IS_I915G(dev_priv))\r\ndev_priv->display.get_cdclk = fixed_333mhz_get_cdclk;\r\nelse if (IS_I865G(dev_priv))\r\ndev_priv->display.get_cdclk = fixed_266mhz_get_cdclk;\r\nelse if (IS_I85X(dev_priv))\r\ndev_priv->display.get_cdclk = i85x_get_cdclk;\r\nelse if (IS_I845G(dev_priv))\r\ndev_priv->display.get_cdclk = fixed_200mhz_get_cdclk;\r\nelse {\r\nWARN(!IS_I830(dev_priv),\r\n"Unknown platform. Assuming 133 MHz CDCLK\n");\r\ndev_priv->display.get_cdclk = fixed_133mhz_get_cdclk;\r\n}\r\n}
