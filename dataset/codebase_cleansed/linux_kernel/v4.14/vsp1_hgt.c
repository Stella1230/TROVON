static inline u32 vsp1_hgt_read(struct vsp1_hgt *hgt, u32 reg)\r\n{\r\nreturn vsp1_read(hgt->histo.entity.vsp1, reg);\r\n}\r\nstatic inline void vsp1_hgt_write(struct vsp1_hgt *hgt, struct vsp1_dl_list *dl,\r\nu32 reg, u32 data)\r\n{\r\nvsp1_dl_list_write(dl, reg, data);\r\n}\r\nvoid vsp1_hgt_frame_end(struct vsp1_entity *entity)\r\n{\r\nstruct vsp1_hgt *hgt = to_hgt(&entity->subdev);\r\nstruct vsp1_histogram_buffer *buf;\r\nunsigned int m;\r\nunsigned int n;\r\nu32 *data;\r\nbuf = vsp1_histogram_buffer_get(&hgt->histo);\r\nif (!buf)\r\nreturn;\r\ndata = buf->addr;\r\n*data++ = vsp1_hgt_read(hgt, VI6_HGT_MAXMIN);\r\n*data++ = vsp1_hgt_read(hgt, VI6_HGT_SUM);\r\nfor (m = 0; m < 6; ++m)\r\nfor (n = 0; n < 32; ++n)\r\n*data++ = vsp1_hgt_read(hgt, VI6_HGT_HISTO(m, n));\r\nvsp1_histogram_buffer_complete(&hgt->histo, buf, HGT_DATA_SIZE);\r\n}\r\nstatic int hgt_hue_areas_try_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nconst u8 *values = ctrl->p_new.p_u8;\r\nunsigned int i;\r\nfor (i = 1; i < (HGT_NUM_HUE_AREAS * 2) - 1; ++i) {\r\nif (values[i] > values[i+1])\r\nreturn -EINVAL;\r\n}\r\nif (values[0] > values[1] && values[11] > values[0])\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int hgt_hue_areas_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct vsp1_hgt *hgt = container_of(ctrl->handler, struct vsp1_hgt,\r\nctrls);\r\nmemcpy(hgt->hue_areas, ctrl->p_new.p_u8, sizeof(hgt->hue_areas));\r\nreturn 0;\r\n}\r\nstatic void hgt_configure(struct vsp1_entity *entity,\r\nstruct vsp1_pipeline *pipe,\r\nstruct vsp1_dl_list *dl,\r\nenum vsp1_entity_params params)\r\n{\r\nstruct vsp1_hgt *hgt = to_hgt(&entity->subdev);\r\nstruct v4l2_rect *compose;\r\nstruct v4l2_rect *crop;\r\nunsigned int hratio;\r\nunsigned int vratio;\r\nu8 lower;\r\nu8 upper;\r\nunsigned int i;\r\nif (params != VSP1_ENTITY_PARAMS_INIT)\r\nreturn;\r\ncrop = vsp1_entity_get_pad_selection(entity, entity->config,\r\nHISTO_PAD_SINK, V4L2_SEL_TGT_CROP);\r\ncompose = vsp1_entity_get_pad_selection(entity, entity->config,\r\nHISTO_PAD_SINK,\r\nV4L2_SEL_TGT_COMPOSE);\r\nvsp1_hgt_write(hgt, dl, VI6_HGT_REGRST, VI6_HGT_REGRST_RCLEA);\r\nvsp1_hgt_write(hgt, dl, VI6_HGT_OFFSET,\r\n(crop->left << VI6_HGT_OFFSET_HOFFSET_SHIFT) |\r\n(crop->top << VI6_HGT_OFFSET_VOFFSET_SHIFT));\r\nvsp1_hgt_write(hgt, dl, VI6_HGT_SIZE,\r\n(crop->width << VI6_HGT_SIZE_HSIZE_SHIFT) |\r\n(crop->height << VI6_HGT_SIZE_VSIZE_SHIFT));\r\nmutex_lock(hgt->ctrls.lock);\r\nfor (i = 0; i < HGT_NUM_HUE_AREAS; ++i) {\r\nlower = hgt->hue_areas[i*2 + 0];\r\nupper = hgt->hue_areas[i*2 + 1];\r\nvsp1_hgt_write(hgt, dl, VI6_HGT_HUE_AREA(i),\r\n(lower << VI6_HGT_HUE_AREA_LOWER_SHIFT) |\r\n(upper << VI6_HGT_HUE_AREA_UPPER_SHIFT));\r\n}\r\nmutex_unlock(hgt->ctrls.lock);\r\nhratio = crop->width * 2 / compose->width / 3;\r\nvratio = crop->height * 2 / compose->height / 3;\r\nvsp1_hgt_write(hgt, dl, VI6_HGT_MODE,\r\n(hratio << VI6_HGT_MODE_HRATIO_SHIFT) |\r\n(vratio << VI6_HGT_MODE_VRATIO_SHIFT));\r\n}\r\nstruct vsp1_hgt *vsp1_hgt_create(struct vsp1_device *vsp1)\r\n{\r\nstruct vsp1_hgt *hgt;\r\nint ret;\r\nhgt = devm_kzalloc(vsp1->dev, sizeof(*hgt), GFP_KERNEL);\r\nif (hgt == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nv4l2_ctrl_handler_init(&hgt->ctrls, 1);\r\nv4l2_ctrl_new_custom(&hgt->ctrls, &hgt_hue_areas, NULL);\r\nhgt->histo.entity.subdev.ctrl_handler = &hgt->ctrls;\r\nret = vsp1_histogram_init(vsp1, &hgt->histo, VSP1_ENTITY_HGT, "hgt",\r\n&hgt_entity_ops, hgt_mbus_formats,\r\nARRAY_SIZE(hgt_mbus_formats),\r\nHGT_DATA_SIZE, V4L2_META_FMT_VSP1_HGT);\r\nif (ret < 0) {\r\nvsp1_entity_destroy(&hgt->histo.entity);\r\nreturn ERR_PTR(ret);\r\n}\r\nv4l2_ctrl_handler_setup(&hgt->ctrls);\r\nreturn hgt;\r\n}
