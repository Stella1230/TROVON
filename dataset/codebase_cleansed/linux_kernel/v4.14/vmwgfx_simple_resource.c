static int vmw_simple_resource_init(struct vmw_private *dev_priv,\r\nstruct vmw_simple_resource *simple,\r\nvoid *data,\r\nvoid (*res_free)(struct vmw_resource *res))\r\n{\r\nstruct vmw_resource *res = &simple->res;\r\nint ret;\r\nret = vmw_resource_init(dev_priv, res, false, res_free,\r\n&simple->func->res_func);\r\nif (ret) {\r\nres_free(res);\r\nreturn ret;\r\n}\r\nret = simple->func->init(res, data);\r\nif (ret) {\r\nvmw_resource_unreference(&res);\r\nreturn ret;\r\n}\r\nvmw_resource_activate(&simple->res, simple->func->hw_destroy);\r\nreturn 0;\r\n}\r\nstatic void vmw_simple_resource_free(struct vmw_resource *res)\r\n{\r\nstruct vmw_user_simple_resource *usimple =\r\ncontainer_of(res, struct vmw_user_simple_resource,\r\nsimple.res);\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nsize_t size = usimple->account_size;\r\nttm_base_object_kfree(usimple, base);\r\nttm_mem_global_free(vmw_mem_glob(dev_priv), size);\r\n}\r\nstatic void vmw_simple_resource_base_release(struct ttm_base_object **p_base)\r\n{\r\nstruct ttm_base_object *base = *p_base;\r\nstruct vmw_user_simple_resource *usimple =\r\ncontainer_of(base, struct vmw_user_simple_resource, base);\r\nstruct vmw_resource *res = &usimple->simple.res;\r\n*p_base = NULL;\r\nvmw_resource_unreference(&res);\r\n}\r\nint\r\nvmw_simple_resource_create_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv,\r\nconst struct vmw_simple_resource_func *func)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(dev);\r\nstruct vmw_user_simple_resource *usimple;\r\nstruct vmw_resource *res;\r\nstruct vmw_resource *tmp;\r\nstruct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;\r\nsize_t alloc_size;\r\nsize_t account_size;\r\nint ret;\r\nalloc_size = offsetof(struct vmw_user_simple_resource, simple) +\r\nfunc->size;\r\naccount_size = ttm_round_pot(alloc_size) + VMW_IDA_ACC_SIZE;\r\nret = ttm_read_lock(&dev_priv->reservation_sem, true);\r\nif (ret)\r\nreturn ret;\r\nret = ttm_mem_global_alloc(vmw_mem_glob(dev_priv), account_size,\r\nfalse, true);\r\nttm_read_unlock(&dev_priv->reservation_sem);\r\nif (ret) {\r\nif (ret != -ERESTARTSYS)\r\nDRM_ERROR("Out of graphics memory for %s"\r\n" creation.\n", func->res_func.type_name);\r\ngoto out_ret;\r\n}\r\nusimple = kzalloc(alloc_size, GFP_KERNEL);\r\nif (!usimple) {\r\nttm_mem_global_free(vmw_mem_glob(dev_priv),\r\naccount_size);\r\nret = -ENOMEM;\r\ngoto out_ret;\r\n}\r\nusimple->simple.func = func;\r\nusimple->account_size = account_size;\r\nres = &usimple->simple.res;\r\nusimple->base.shareable = false;\r\nusimple->base.tfile = NULL;\r\nret = vmw_simple_resource_init(dev_priv, &usimple->simple,\r\ndata, vmw_simple_resource_free);\r\nif (ret)\r\ngoto out_ret;\r\ntmp = vmw_resource_reference(res);\r\nret = ttm_base_object_init(tfile, &usimple->base, false,\r\nfunc->ttm_res_type,\r\n&vmw_simple_resource_base_release, NULL);\r\nif (ret) {\r\nvmw_resource_unreference(&tmp);\r\ngoto out_err;\r\n}\r\nfunc->set_arg_handle(data, usimple->base.hash.key);\r\nout_err:\r\nvmw_resource_unreference(&res);\r\nout_ret:\r\nreturn ret;\r\n}\r\nstruct vmw_resource *\r\nvmw_simple_resource_lookup(struct ttm_object_file *tfile,\r\nuint32_t handle,\r\nconst struct vmw_simple_resource_func *func)\r\n{\r\nstruct vmw_user_simple_resource *usimple;\r\nstruct ttm_base_object *base;\r\nstruct vmw_resource *res;\r\nbase = ttm_base_object_lookup(tfile, handle);\r\nif (!base) {\r\nDRM_ERROR("Invalid %s handle 0x%08lx.\n",\r\nfunc->res_func.type_name,\r\n(unsigned long) handle);\r\nreturn ERR_PTR(-ESRCH);\r\n}\r\nif (ttm_base_object_type(base) != func->ttm_res_type) {\r\nttm_base_object_unref(&base);\r\nDRM_ERROR("Invalid type of %s handle 0x%08lx.\n",\r\nfunc->res_func.type_name,\r\n(unsigned long) handle);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nusimple = container_of(base, typeof(*usimple), base);\r\nres = vmw_resource_reference(&usimple->simple.res);\r\nttm_base_object_unref(&base);\r\nreturn res;\r\n}
