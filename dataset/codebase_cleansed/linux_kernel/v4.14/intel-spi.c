static void intel_spi_dump_regs(struct intel_spi *ispi)\r\n{\r\nu32 value;\r\nint i;\r\ndev_dbg(ispi->dev, "BFPREG=0x%08x\n", readl(ispi->base + BFPREG));\r\nvalue = readl(ispi->base + HSFSTS_CTL);\r\ndev_dbg(ispi->dev, "HSFSTS_CTL=0x%08x\n", value);\r\nif (value & HSFSTS_CTL_FLOCKDN)\r\ndev_dbg(ispi->dev, "-> Locked\n");\r\ndev_dbg(ispi->dev, "FADDR=0x%08x\n", readl(ispi->base + FADDR));\r\ndev_dbg(ispi->dev, "DLOCK=0x%08x\n", readl(ispi->base + DLOCK));\r\nfor (i = 0; i < 16; i++)\r\ndev_dbg(ispi->dev, "FDATA(%d)=0x%08x\n",\r\ni, readl(ispi->base + FDATA(i)));\r\ndev_dbg(ispi->dev, "FRACC=0x%08x\n", readl(ispi->base + FRACC));\r\nfor (i = 0; i < ispi->nregions; i++)\r\ndev_dbg(ispi->dev, "FREG(%d)=0x%08x\n", i,\r\nreadl(ispi->base + FREG(i)));\r\nfor (i = 0; i < PR_NUM; i++)\r\ndev_dbg(ispi->dev, "PR(%d)=0x%08x\n", i,\r\nreadl(ispi->pregs + PR(i)));\r\nvalue = readl(ispi->sregs + SSFSTS_CTL);\r\ndev_dbg(ispi->dev, "SSFSTS_CTL=0x%08x\n", value);\r\ndev_dbg(ispi->dev, "PREOP_OPTYPE=0x%08x\n",\r\nreadl(ispi->sregs + PREOP_OPTYPE));\r\ndev_dbg(ispi->dev, "OPMENU0=0x%08x\n", readl(ispi->sregs + OPMENU0));\r\ndev_dbg(ispi->dev, "OPMENU1=0x%08x\n", readl(ispi->sregs + OPMENU1));\r\nif (ispi->info->type == INTEL_SPI_BYT)\r\ndev_dbg(ispi->dev, "BCR=0x%08x\n", readl(ispi->base + BYT_BCR));\r\ndev_dbg(ispi->dev, "Protected regions:\n");\r\nfor (i = 0; i < PR_NUM; i++) {\r\nu32 base, limit;\r\nvalue = readl(ispi->pregs + PR(i));\r\nif (!(value & (PR_WPE | PR_RPE)))\r\ncontinue;\r\nlimit = (value & PR_LIMIT_MASK) >> PR_LIMIT_SHIFT;\r\nbase = value & PR_BASE_MASK;\r\ndev_dbg(ispi->dev, " %02d base: 0x%08x limit: 0x%08x [%c%c]\n",\r\ni, base << 12, (limit << 12) | 0xfff,\r\nvalue & PR_WPE ? 'W' : '.',\r\nvalue & PR_RPE ? 'R' : '.');\r\n}\r\ndev_dbg(ispi->dev, "Flash regions:\n");\r\nfor (i = 0; i < ispi->nregions; i++) {\r\nu32 region, base, limit;\r\nregion = readl(ispi->base + FREG(i));\r\nbase = region & FREG_BASE_MASK;\r\nlimit = (region & FREG_LIMIT_MASK) >> FREG_LIMIT_SHIFT;\r\nif (base >= limit || (i > 0 && limit == 0))\r\ndev_dbg(ispi->dev, " %02d disabled\n", i);\r\nelse\r\ndev_dbg(ispi->dev, " %02d base: 0x%08x limit: 0x%08x\n",\r\ni, base << 12, (limit << 12) | 0xfff);\r\n}\r\ndev_dbg(ispi->dev, "Using %cW sequencer for register access\n",\r\nispi->swseq ? 'S' : 'H');\r\n}\r\nstatic int intel_spi_read_block(struct intel_spi *ispi, void *buf, size_t size)\r\n{\r\nsize_t bytes;\r\nint i = 0;\r\nif (size > INTEL_SPI_FIFO_SZ)\r\nreturn -EINVAL;\r\nwhile (size > 0) {\r\nbytes = min_t(size_t, size, 4);\r\nmemcpy_fromio(buf, ispi->base + FDATA(i), bytes);\r\nsize -= bytes;\r\nbuf += bytes;\r\ni++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int intel_spi_write_block(struct intel_spi *ispi, const void *buf,\r\nsize_t size)\r\n{\r\nsize_t bytes;\r\nint i = 0;\r\nif (size > INTEL_SPI_FIFO_SZ)\r\nreturn -EINVAL;\r\nwhile (size > 0) {\r\nbytes = min_t(size_t, size, 4);\r\nmemcpy_toio(ispi->base + FDATA(i), buf, bytes);\r\nsize -= bytes;\r\nbuf += bytes;\r\ni++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int intel_spi_wait_hw_busy(struct intel_spi *ispi)\r\n{\r\nu32 val;\r\nreturn readl_poll_timeout(ispi->base + HSFSTS_CTL, val,\r\n!(val & HSFSTS_CTL_SCIP), 0,\r\nINTEL_SPI_TIMEOUT * 1000);\r\n}\r\nstatic int intel_spi_wait_sw_busy(struct intel_spi *ispi)\r\n{\r\nu32 val;\r\nreturn readl_poll_timeout(ispi->sregs + SSFSTS_CTL, val,\r\n!(val & SSFSTS_CTL_SCIP), 0,\r\nINTEL_SPI_TIMEOUT * 1000);\r\n}\r\nstatic int intel_spi_init(struct intel_spi *ispi)\r\n{\r\nu32 opmenu0, opmenu1, val;\r\nint i;\r\nswitch (ispi->info->type) {\r\ncase INTEL_SPI_BYT:\r\nispi->sregs = ispi->base + BYT_SSFSTS_CTL;\r\nispi->pregs = ispi->base + BYT_PR;\r\nispi->nregions = BYT_FREG_NUM;\r\nif (writeable) {\r\nval = readl(ispi->base + BYT_BCR);\r\nif (!(val & BYT_BCR_WPD)) {\r\nval |= BYT_BCR_WPD;\r\nwritel(val, ispi->base + BYT_BCR);\r\nval = readl(ispi->base + BYT_BCR);\r\n}\r\nispi->writeable = !!(val & BYT_BCR_WPD);\r\n}\r\nbreak;\r\ncase INTEL_SPI_LPT:\r\nispi->sregs = ispi->base + LPT_SSFSTS_CTL;\r\nispi->pregs = ispi->base + LPT_PR;\r\nispi->nregions = LPT_FREG_NUM;\r\nbreak;\r\ncase INTEL_SPI_BXT:\r\nispi->sregs = ispi->base + BXT_SSFSTS_CTL;\r\nispi->pregs = ispi->base + BXT_PR;\r\nispi->nregions = BXT_FREG_NUM;\r\nispi->erase_64k = true;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nval = readl(ispi->base + HSFSTS_CTL);\r\nval &= ~HSFSTS_CTL_FSMIE;\r\nwritel(val, ispi->base + HSFSTS_CTL);\r\nopmenu0 = readl(ispi->sregs + OPMENU0);\r\nopmenu1 = readl(ispi->sregs + OPMENU1);\r\nif (opmenu0 && opmenu1) {\r\nfor (i = 0; i < ARRAY_SIZE(ispi->opcodes) / 2; i++) {\r\nispi->opcodes[i] = opmenu0 >> i * 8;\r\nispi->opcodes[i + 4] = opmenu1 >> i * 8;\r\n}\r\nval = readl(ispi->sregs + PREOP_OPTYPE);\r\nispi->preopcodes[0] = val;\r\nispi->preopcodes[1] = val >> 8;\r\nval = readl(ispi->sregs + SSFSTS_CTL);\r\nval &= ~SSFSTS_CTL_FSMIE;\r\nwritel(val, ispi->sregs + SSFSTS_CTL);\r\nispi->swseq = true;\r\n}\r\nintel_spi_dump_regs(ispi);\r\nreturn 0;\r\n}\r\nstatic int intel_spi_opcode_index(struct intel_spi *ispi, u8 opcode)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(ispi->opcodes); i++)\r\nif (ispi->opcodes[i] == opcode)\r\nreturn i;\r\nreturn -EINVAL;\r\n}\r\nstatic int intel_spi_hw_cycle(struct intel_spi *ispi, u8 opcode, u8 *buf,\r\nint len)\r\n{\r\nu32 val, status;\r\nint ret;\r\nval = readl(ispi->base + HSFSTS_CTL);\r\nval &= ~(HSFSTS_CTL_FCYCLE_MASK | HSFSTS_CTL_FDBC_MASK);\r\nswitch (opcode) {\r\ncase SPINOR_OP_RDID:\r\nval |= HSFSTS_CTL_FCYCLE_RDID;\r\nbreak;\r\ncase SPINOR_OP_WRSR:\r\nval |= HSFSTS_CTL_FCYCLE_WRSR;\r\nbreak;\r\ncase SPINOR_OP_RDSR:\r\nval |= HSFSTS_CTL_FCYCLE_RDSR;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nval |= (len - 1) << HSFSTS_CTL_FDBC_SHIFT;\r\nval |= HSFSTS_CTL_FCERR | HSFSTS_CTL_FDONE;\r\nval |= HSFSTS_CTL_FGO;\r\nwritel(val, ispi->base + HSFSTS_CTL);\r\nret = intel_spi_wait_hw_busy(ispi);\r\nif (ret)\r\nreturn ret;\r\nstatus = readl(ispi->base + HSFSTS_CTL);\r\nif (status & HSFSTS_CTL_FCERR)\r\nreturn -EIO;\r\nelse if (status & HSFSTS_CTL_AEL)\r\nreturn -EACCES;\r\nreturn 0;\r\n}\r\nstatic int intel_spi_sw_cycle(struct intel_spi *ispi, u8 opcode, u8 *buf,\r\nint len)\r\n{\r\nu32 val, status;\r\nint ret;\r\nret = intel_spi_opcode_index(ispi, opcode);\r\nif (ret < 0)\r\nreturn ret;\r\nval = (len << SSFSTS_CTL_DBC_SHIFT) | SSFSTS_CTL_DS;\r\nval |= ret << SSFSTS_CTL_COP_SHIFT;\r\nval |= SSFSTS_CTL_FCERR | SSFSTS_CTL_FDONE;\r\nval |= SSFSTS_CTL_SCGO;\r\nwritel(val, ispi->sregs + SSFSTS_CTL);\r\nret = intel_spi_wait_sw_busy(ispi);\r\nif (ret)\r\nreturn ret;\r\nstatus = readl(ispi->base + SSFSTS_CTL);\r\nif (status & SSFSTS_CTL_FCERR)\r\nreturn -EIO;\r\nelse if (status & SSFSTS_CTL_AEL)\r\nreturn -EACCES;\r\nreturn 0;\r\n}\r\nstatic int intel_spi_read_reg(struct spi_nor *nor, u8 opcode, u8 *buf, int len)\r\n{\r\nstruct intel_spi *ispi = nor->priv;\r\nint ret;\r\nwritel(0, ispi->base + FADDR);\r\nif (ispi->swseq)\r\nret = intel_spi_sw_cycle(ispi, opcode, buf, len);\r\nelse\r\nret = intel_spi_hw_cycle(ispi, opcode, buf, len);\r\nif (ret)\r\nreturn ret;\r\nreturn intel_spi_read_block(ispi, buf, len);\r\n}\r\nstatic int intel_spi_write_reg(struct spi_nor *nor, u8 opcode, u8 *buf, int len)\r\n{\r\nstruct intel_spi *ispi = nor->priv;\r\nint ret;\r\nif (opcode == SPINOR_OP_WREN)\r\nreturn 0;\r\nwritel(0, ispi->base + FADDR);\r\nret = intel_spi_write_block(ispi, buf, len);\r\nif (ret)\r\nreturn ret;\r\nif (ispi->swseq)\r\nreturn intel_spi_sw_cycle(ispi, opcode, buf, len);\r\nreturn intel_spi_hw_cycle(ispi, opcode, buf, len);\r\n}\r\nstatic ssize_t intel_spi_read(struct spi_nor *nor, loff_t from, size_t len,\r\nu_char *read_buf)\r\n{\r\nstruct intel_spi *ispi = nor->priv;\r\nsize_t block_size, retlen = 0;\r\nu32 val, status;\r\nssize_t ret;\r\nswitch (nor->read_opcode) {\r\ncase SPINOR_OP_READ:\r\ncase SPINOR_OP_READ_FAST:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nwhile (len > 0) {\r\nblock_size = min_t(size_t, len, INTEL_SPI_FIFO_SZ);\r\nwritel(from, ispi->base + FADDR);\r\nval = readl(ispi->base + HSFSTS_CTL);\r\nval &= ~(HSFSTS_CTL_FDBC_MASK | HSFSTS_CTL_FCYCLE_MASK);\r\nval |= HSFSTS_CTL_AEL | HSFSTS_CTL_FCERR | HSFSTS_CTL_FDONE;\r\nval |= (block_size - 1) << HSFSTS_CTL_FDBC_SHIFT;\r\nval |= HSFSTS_CTL_FCYCLE_READ;\r\nval |= HSFSTS_CTL_FGO;\r\nwritel(val, ispi->base + HSFSTS_CTL);\r\nret = intel_spi_wait_hw_busy(ispi);\r\nif (ret)\r\nreturn ret;\r\nstatus = readl(ispi->base + HSFSTS_CTL);\r\nif (status & HSFSTS_CTL_FCERR)\r\nret = -EIO;\r\nelse if (status & HSFSTS_CTL_AEL)\r\nret = -EACCES;\r\nif (ret < 0) {\r\ndev_err(ispi->dev, "read error: %llx: %#x\n", from,\r\nstatus);\r\nreturn ret;\r\n}\r\nret = intel_spi_read_block(ispi, read_buf, block_size);\r\nif (ret)\r\nreturn ret;\r\nlen -= block_size;\r\nfrom += block_size;\r\nretlen += block_size;\r\nread_buf += block_size;\r\n}\r\nreturn retlen;\r\n}\r\nstatic ssize_t intel_spi_write(struct spi_nor *nor, loff_t to, size_t len,\r\nconst u_char *write_buf)\r\n{\r\nstruct intel_spi *ispi = nor->priv;\r\nsize_t block_size, retlen = 0;\r\nu32 val, status;\r\nssize_t ret;\r\nwhile (len > 0) {\r\nblock_size = min_t(size_t, len, INTEL_SPI_FIFO_SZ);\r\nwritel(to, ispi->base + FADDR);\r\nval = readl(ispi->base + HSFSTS_CTL);\r\nval &= ~(HSFSTS_CTL_FDBC_MASK | HSFSTS_CTL_FCYCLE_MASK);\r\nval |= HSFSTS_CTL_AEL | HSFSTS_CTL_FCERR | HSFSTS_CTL_FDONE;\r\nval |= (block_size - 1) << HSFSTS_CTL_FDBC_SHIFT;\r\nval |= HSFSTS_CTL_FCYCLE_WRITE;\r\nif (ispi->preopcodes[1] == SPINOR_OP_WREN)\r\nval |= SSFSTS_CTL_SPOP;\r\nval |= SSFSTS_CTL_ACS;\r\nwritel(val, ispi->base + HSFSTS_CTL);\r\nret = intel_spi_write_block(ispi, write_buf, block_size);\r\nif (ret) {\r\ndev_err(ispi->dev, "failed to write block\n");\r\nreturn ret;\r\n}\r\nval = readl(ispi->base + HSFSTS_CTL);\r\nwritel(val | HSFSTS_CTL_FGO, ispi->base + HSFSTS_CTL);\r\nret = intel_spi_wait_hw_busy(ispi);\r\nif (ret) {\r\ndev_err(ispi->dev, "timeout\n");\r\nreturn ret;\r\n}\r\nstatus = readl(ispi->base + HSFSTS_CTL);\r\nif (status & HSFSTS_CTL_FCERR)\r\nret = -EIO;\r\nelse if (status & HSFSTS_CTL_AEL)\r\nret = -EACCES;\r\nif (ret < 0) {\r\ndev_err(ispi->dev, "write error: %llx: %#x\n", to,\r\nstatus);\r\nreturn ret;\r\n}\r\nlen -= block_size;\r\nto += block_size;\r\nretlen += block_size;\r\nwrite_buf += block_size;\r\n}\r\nreturn retlen;\r\n}\r\nstatic int intel_spi_erase(struct spi_nor *nor, loff_t offs)\r\n{\r\nsize_t erase_size, len = nor->mtd.erasesize;\r\nstruct intel_spi *ispi = nor->priv;\r\nu32 val, status, cmd;\r\nint ret;\r\nif (len >= SZ_64K && ispi->erase_64k) {\r\ncmd = HSFSTS_CTL_FCYCLE_ERASE_64K;\r\nerase_size = SZ_64K;\r\n} else {\r\ncmd = HSFSTS_CTL_FCYCLE_ERASE;\r\nerase_size = SZ_4K;\r\n}\r\nwhile (len > 0) {\r\nwritel(offs, ispi->base + FADDR);\r\nval = readl(ispi->base + HSFSTS_CTL);\r\nval &= ~(HSFSTS_CTL_FDBC_MASK | HSFSTS_CTL_FCYCLE_MASK);\r\nval |= HSFSTS_CTL_AEL | HSFSTS_CTL_FCERR | HSFSTS_CTL_FDONE;\r\nval |= cmd;\r\nval |= HSFSTS_CTL_FGO;\r\nwritel(val, ispi->base + HSFSTS_CTL);\r\nret = intel_spi_wait_hw_busy(ispi);\r\nif (ret)\r\nreturn ret;\r\nstatus = readl(ispi->base + HSFSTS_CTL);\r\nif (status & HSFSTS_CTL_FCERR)\r\nreturn -EIO;\r\nelse if (status & HSFSTS_CTL_AEL)\r\nreturn -EACCES;\r\noffs += erase_size;\r\nlen -= erase_size;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool intel_spi_is_protected(const struct intel_spi *ispi,\r\nunsigned int base, unsigned int limit)\r\n{\r\nint i;\r\nfor (i = 0; i < PR_NUM; i++) {\r\nu32 pr_base, pr_limit, pr_value;\r\npr_value = readl(ispi->pregs + PR(i));\r\nif (!(pr_value & (PR_WPE | PR_RPE)))\r\ncontinue;\r\npr_limit = (pr_value & PR_LIMIT_MASK) >> PR_LIMIT_SHIFT;\r\npr_base = pr_value & PR_BASE_MASK;\r\nif (pr_base >= base && pr_limit <= limit)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void intel_spi_fill_partition(struct intel_spi *ispi,\r\nstruct mtd_partition *part)\r\n{\r\nu64 end;\r\nint i;\r\nmemset(part, 0, sizeof(*part));\r\npart->size = 4096;\r\npart->name = "BIOS";\r\nfor (i = 1; i < ispi->nregions; i++) {\r\nu32 region, base, limit;\r\nregion = readl(ispi->base + FREG(i));\r\nbase = region & FREG_BASE_MASK;\r\nlimit = (region & FREG_LIMIT_MASK) >> FREG_LIMIT_SHIFT;\r\nif (base >= limit || limit == 0)\r\ncontinue;\r\nif (intel_spi_is_protected(ispi, base, limit))\r\nispi->writeable = false;\r\nend = (limit << 12) + 4096;\r\nif (end > part->size)\r\npart->size = end;\r\n}\r\n}\r\nstruct intel_spi *intel_spi_probe(struct device *dev,\r\nstruct resource *mem, const struct intel_spi_boardinfo *info)\r\n{\r\nconst struct spi_nor_hwcaps hwcaps = {\r\n.mask = SNOR_HWCAPS_READ |\r\nSNOR_HWCAPS_READ_FAST |\r\nSNOR_HWCAPS_PP,\r\n};\r\nstruct mtd_partition part;\r\nstruct intel_spi *ispi;\r\nint ret;\r\nif (!info || !mem)\r\nreturn ERR_PTR(-EINVAL);\r\nispi = devm_kzalloc(dev, sizeof(*ispi), GFP_KERNEL);\r\nif (!ispi)\r\nreturn ERR_PTR(-ENOMEM);\r\nispi->base = devm_ioremap_resource(dev, mem);\r\nif (IS_ERR(ispi->base))\r\nreturn ERR_CAST(ispi->base);\r\nispi->dev = dev;\r\nispi->info = info;\r\nispi->writeable = info->writeable;\r\nret = intel_spi_init(ispi);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\nispi->nor.dev = ispi->dev;\r\nispi->nor.priv = ispi;\r\nispi->nor.read_reg = intel_spi_read_reg;\r\nispi->nor.write_reg = intel_spi_write_reg;\r\nispi->nor.read = intel_spi_read;\r\nispi->nor.write = intel_spi_write;\r\nispi->nor.erase = intel_spi_erase;\r\nret = spi_nor_scan(&ispi->nor, NULL, &hwcaps);\r\nif (ret) {\r\ndev_info(dev, "failed to locate the chip\n");\r\nreturn ERR_PTR(ret);\r\n}\r\nintel_spi_fill_partition(ispi, &part);\r\nif (!ispi->writeable || !writeable)\r\nispi->nor.mtd.flags &= ~MTD_WRITEABLE;\r\nret = mtd_device_parse_register(&ispi->nor.mtd, NULL, NULL, &part, 1);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\nreturn ispi;\r\n}\r\nint intel_spi_remove(struct intel_spi *ispi)\r\n{\r\nreturn mtd_device_unregister(&ispi->nor.mtd);\r\n}
