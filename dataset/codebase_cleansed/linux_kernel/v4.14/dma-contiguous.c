static int __init early_cma(char *p)\r\n{\r\npr_debug("%s(%s)\n", __func__, p);\r\nsize_cmdline = memparse(p, &p);\r\nif (*p != '@')\r\nreturn 0;\r\nbase_cmdline = memparse(p + 1, &p);\r\nif (*p != '-') {\r\nlimit_cmdline = base_cmdline + size_cmdline;\r\nreturn 0;\r\n}\r\nlimit_cmdline = memparse(p + 1, &p);\r\nreturn 0;\r\n}\r\nstatic phys_addr_t __init __maybe_unused cma_early_percent_memory(void)\r\n{\r\nstruct memblock_region *reg;\r\nunsigned long total_pages = 0;\r\nfor_each_memblock(memory, reg)\r\ntotal_pages += memblock_region_memory_end_pfn(reg) -\r\nmemblock_region_memory_base_pfn(reg);\r\nreturn (total_pages * CONFIG_CMA_SIZE_PERCENTAGE / 100) << PAGE_SHIFT;\r\n}\r\nstatic inline __maybe_unused phys_addr_t cma_early_percent_memory(void)\r\n{\r\nreturn 0;\r\n}\r\nvoid __init dma_contiguous_reserve(phys_addr_t limit)\r\n{\r\nphys_addr_t selected_size = 0;\r\nphys_addr_t selected_base = 0;\r\nphys_addr_t selected_limit = limit;\r\nbool fixed = false;\r\npr_debug("%s(limit %08lx)\n", __func__, (unsigned long)limit);\r\nif (size_cmdline != -1) {\r\nselected_size = size_cmdline;\r\nselected_base = base_cmdline;\r\nselected_limit = min_not_zero(limit_cmdline, limit);\r\nif (base_cmdline + size_cmdline == limit_cmdline)\r\nfixed = true;\r\n} else {\r\n#ifdef CONFIG_CMA_SIZE_SEL_MBYTES\r\nselected_size = size_bytes;\r\n#elif defined(CONFIG_CMA_SIZE_SEL_PERCENTAGE)\r\nselected_size = cma_early_percent_memory();\r\n#elif defined(CONFIG_CMA_SIZE_SEL_MIN)\r\nselected_size = min(size_bytes, cma_early_percent_memory());\r\n#elif defined(CONFIG_CMA_SIZE_SEL_MAX)\r\nselected_size = max(size_bytes, cma_early_percent_memory());\r\n#endif\r\n}\r\nif (selected_size && !dma_contiguous_default_area) {\r\npr_debug("%s: reserving %ld MiB for global area\n", __func__,\r\n(unsigned long)selected_size / SZ_1M);\r\ndma_contiguous_reserve_area(selected_size, selected_base,\r\nselected_limit,\r\n&dma_contiguous_default_area,\r\nfixed);\r\n}\r\n}\r\nint __init dma_contiguous_reserve_area(phys_addr_t size, phys_addr_t base,\r\nphys_addr_t limit, struct cma **res_cma,\r\nbool fixed)\r\n{\r\nint ret;\r\nret = cma_declare_contiguous(base, size, limit, 0, 0, fixed,\r\n"reserved", res_cma);\r\nif (ret)\r\nreturn ret;\r\ndma_contiguous_early_fixup(cma_get_base(*res_cma),\r\ncma_get_size(*res_cma));\r\nreturn 0;\r\n}\r\nstruct page *dma_alloc_from_contiguous(struct device *dev, size_t count,\r\nunsigned int align, gfp_t gfp_mask)\r\n{\r\nif (align > CONFIG_CMA_ALIGNMENT)\r\nalign = CONFIG_CMA_ALIGNMENT;\r\nreturn cma_alloc(dev_get_cma_area(dev), count, align, gfp_mask);\r\n}\r\nbool dma_release_from_contiguous(struct device *dev, struct page *pages,\r\nint count)\r\n{\r\nreturn cma_release(dev_get_cma_area(dev), pages, count);\r\n}\r\nstatic int rmem_cma_device_init(struct reserved_mem *rmem, struct device *dev)\r\n{\r\ndev_set_cma_area(dev, rmem->priv);\r\nreturn 0;\r\n}\r\nstatic void rmem_cma_device_release(struct reserved_mem *rmem,\r\nstruct device *dev)\r\n{\r\ndev_set_cma_area(dev, NULL);\r\n}\r\nstatic int __init rmem_cma_setup(struct reserved_mem *rmem)\r\n{\r\nphys_addr_t align = PAGE_SIZE << max(MAX_ORDER - 1, pageblock_order);\r\nphys_addr_t mask = align - 1;\r\nunsigned long node = rmem->fdt_node;\r\nstruct cma *cma;\r\nint err;\r\nif (!of_get_flat_dt_prop(node, "reusable", NULL) ||\r\nof_get_flat_dt_prop(node, "no-map", NULL))\r\nreturn -EINVAL;\r\nif ((rmem->base & mask) || (rmem->size & mask)) {\r\npr_err("Reserved memory: incorrect alignment of CMA region\n");\r\nreturn -EINVAL;\r\n}\r\nerr = cma_init_reserved_mem(rmem->base, rmem->size, 0, rmem->name, &cma);\r\nif (err) {\r\npr_err("Reserved memory: unable to setup CMA region\n");\r\nreturn err;\r\n}\r\ndma_contiguous_early_fixup(rmem->base, rmem->size);\r\nif (of_get_flat_dt_prop(node, "linux,cma-default", NULL))\r\ndma_contiguous_set_default(cma);\r\nrmem->ops = &rmem_cma_ops;\r\nrmem->priv = cma;\r\npr_info("Reserved memory: created CMA memory pool at %pa, size %ld MiB\n",\r\n&rmem->base, (unsigned long)rmem->size / SZ_1M);\r\nreturn 0;\r\n}
