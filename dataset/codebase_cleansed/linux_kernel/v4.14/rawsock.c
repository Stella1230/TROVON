static void nfc_sock_link(struct nfc_sock_list *l, struct sock *sk)\r\n{\r\nwrite_lock(&l->lock);\r\nsk_add_node(sk, &l->head);\r\nwrite_unlock(&l->lock);\r\n}\r\nstatic void nfc_sock_unlink(struct nfc_sock_list *l, struct sock *sk)\r\n{\r\nwrite_lock(&l->lock);\r\nsk_del_node_init(sk);\r\nwrite_unlock(&l->lock);\r\n}\r\nstatic void rawsock_write_queue_purge(struct sock *sk)\r\n{\r\npr_debug("sk=%p\n", sk);\r\nspin_lock_bh(&sk->sk_write_queue.lock);\r\n__skb_queue_purge(&sk->sk_write_queue);\r\nnfc_rawsock(sk)->tx_work_scheduled = false;\r\nspin_unlock_bh(&sk->sk_write_queue.lock);\r\n}\r\nstatic void rawsock_report_error(struct sock *sk, int err)\r\n{\r\npr_debug("sk=%p err=%d\n", sk, err);\r\nsk->sk_shutdown = SHUTDOWN_MASK;\r\nsk->sk_err = -err;\r\nsk->sk_error_report(sk);\r\nrawsock_write_queue_purge(sk);\r\n}\r\nstatic int rawsock_release(struct socket *sock)\r\n{\r\nstruct sock *sk = sock->sk;\r\npr_debug("sock=%p sk=%p\n", sock, sk);\r\nif (!sk)\r\nreturn 0;\r\nif (sock->type == SOCK_RAW)\r\nnfc_sock_unlink(&raw_sk_list, sk);\r\nsock_orphan(sk);\r\nsock_put(sk);\r\nreturn 0;\r\n}\r\nstatic int rawsock_connect(struct socket *sock, struct sockaddr *_addr,\r\nint len, int flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct sockaddr_nfc *addr = (struct sockaddr_nfc *)_addr;\r\nstruct nfc_dev *dev;\r\nint rc = 0;\r\npr_debug("sock=%p sk=%p flags=%d\n", sock, sk, flags);\r\nif (!addr || len < sizeof(struct sockaddr_nfc) ||\r\naddr->sa_family != AF_NFC)\r\nreturn -EINVAL;\r\npr_debug("addr dev_idx=%u target_idx=%u protocol=%u\n",\r\naddr->dev_idx, addr->target_idx, addr->nfc_protocol);\r\nlock_sock(sk);\r\nif (sock->state == SS_CONNECTED) {\r\nrc = -EISCONN;\r\ngoto error;\r\n}\r\ndev = nfc_get_device(addr->dev_idx);\r\nif (!dev) {\r\nrc = -ENODEV;\r\ngoto error;\r\n}\r\nif (addr->target_idx > dev->target_next_idx - 1 ||\r\naddr->target_idx < dev->target_next_idx - dev->n_targets) {\r\nrc = -EINVAL;\r\ngoto error;\r\n}\r\nrc = nfc_activate_target(dev, addr->target_idx, addr->nfc_protocol);\r\nif (rc)\r\ngoto put_dev;\r\nnfc_rawsock(sk)->dev = dev;\r\nnfc_rawsock(sk)->target_idx = addr->target_idx;\r\nsock->state = SS_CONNECTED;\r\nsk->sk_state = TCP_ESTABLISHED;\r\nsk->sk_state_change(sk);\r\nrelease_sock(sk);\r\nreturn 0;\r\nput_dev:\r\nnfc_put_device(dev);\r\nerror:\r\nrelease_sock(sk);\r\nreturn rc;\r\n}\r\nstatic int rawsock_add_header(struct sk_buff *skb)\r\n{\r\n*(u8 *)skb_push(skb, NFC_HEADER_SIZE) = 0;\r\nreturn 0;\r\n}\r\nstatic void rawsock_data_exchange_complete(void *context, struct sk_buff *skb,\r\nint err)\r\n{\r\nstruct sock *sk = (struct sock *) context;\r\nBUG_ON(in_irq());\r\npr_debug("sk=%p err=%d\n", sk, err);\r\nif (err)\r\ngoto error;\r\nerr = rawsock_add_header(skb);\r\nif (err)\r\ngoto error_skb;\r\nerr = sock_queue_rcv_skb(sk, skb);\r\nif (err)\r\ngoto error_skb;\r\nspin_lock_bh(&sk->sk_write_queue.lock);\r\nif (!skb_queue_empty(&sk->sk_write_queue))\r\nschedule_work(&nfc_rawsock(sk)->tx_work);\r\nelse\r\nnfc_rawsock(sk)->tx_work_scheduled = false;\r\nspin_unlock_bh(&sk->sk_write_queue.lock);\r\nsock_put(sk);\r\nreturn;\r\nerror_skb:\r\nkfree_skb(skb);\r\nerror:\r\nrawsock_report_error(sk, err);\r\nsock_put(sk);\r\n}\r\nstatic void rawsock_tx_work(struct work_struct *work)\r\n{\r\nstruct sock *sk = to_rawsock_sk(work);\r\nstruct nfc_dev *dev = nfc_rawsock(sk)->dev;\r\nu32 target_idx = nfc_rawsock(sk)->target_idx;\r\nstruct sk_buff *skb;\r\nint rc;\r\npr_debug("sk=%p target_idx=%u\n", sk, target_idx);\r\nif (sk->sk_shutdown & SEND_SHUTDOWN) {\r\nrawsock_write_queue_purge(sk);\r\nreturn;\r\n}\r\nskb = skb_dequeue(&sk->sk_write_queue);\r\nsock_hold(sk);\r\nrc = nfc_data_exchange(dev, target_idx, skb,\r\nrawsock_data_exchange_complete, sk);\r\nif (rc) {\r\nrawsock_report_error(sk, rc);\r\nsock_put(sk);\r\n}\r\n}\r\nstatic int rawsock_sendmsg(struct socket *sock, struct msghdr *msg, size_t len)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct nfc_dev *dev = nfc_rawsock(sk)->dev;\r\nstruct sk_buff *skb;\r\nint rc;\r\npr_debug("sock=%p sk=%p len=%zu\n", sock, sk, len);\r\nif (msg->msg_namelen)\r\nreturn -EOPNOTSUPP;\r\nif (sock->state != SS_CONNECTED)\r\nreturn -ENOTCONN;\r\nskb = nfc_alloc_send_skb(dev, sk, msg->msg_flags, len, &rc);\r\nif (skb == NULL)\r\nreturn rc;\r\nrc = memcpy_from_msg(skb_put(skb, len), msg, len);\r\nif (rc < 0) {\r\nkfree_skb(skb);\r\nreturn rc;\r\n}\r\nspin_lock_bh(&sk->sk_write_queue.lock);\r\n__skb_queue_tail(&sk->sk_write_queue, skb);\r\nif (!nfc_rawsock(sk)->tx_work_scheduled) {\r\nschedule_work(&nfc_rawsock(sk)->tx_work);\r\nnfc_rawsock(sk)->tx_work_scheduled = true;\r\n}\r\nspin_unlock_bh(&sk->sk_write_queue.lock);\r\nreturn len;\r\n}\r\nstatic int rawsock_recvmsg(struct socket *sock, struct msghdr *msg, size_t len,\r\nint flags)\r\n{\r\nint noblock = flags & MSG_DONTWAIT;\r\nstruct sock *sk = sock->sk;\r\nstruct sk_buff *skb;\r\nint copied;\r\nint rc;\r\npr_debug("sock=%p sk=%p len=%zu flags=%d\n", sock, sk, len, flags);\r\nskb = skb_recv_datagram(sk, flags, noblock, &rc);\r\nif (!skb)\r\nreturn rc;\r\ncopied = skb->len;\r\nif (len < copied) {\r\nmsg->msg_flags |= MSG_TRUNC;\r\ncopied = len;\r\n}\r\nrc = skb_copy_datagram_msg(skb, 0, msg, copied);\r\nskb_free_datagram(sk, skb);\r\nreturn rc ? : copied;\r\n}\r\nstatic void rawsock_destruct(struct sock *sk)\r\n{\r\npr_debug("sk=%p\n", sk);\r\nif (sk->sk_state == TCP_ESTABLISHED) {\r\nnfc_deactivate_target(nfc_rawsock(sk)->dev,\r\nnfc_rawsock(sk)->target_idx,\r\nNFC_TARGET_MODE_IDLE);\r\nnfc_put_device(nfc_rawsock(sk)->dev);\r\n}\r\nskb_queue_purge(&sk->sk_receive_queue);\r\nif (!sock_flag(sk, SOCK_DEAD)) {\r\npr_err("Freeing alive NFC raw socket %p\n", sk);\r\nreturn;\r\n}\r\n}\r\nstatic int rawsock_create(struct net *net, struct socket *sock,\r\nconst struct nfc_protocol *nfc_proto, int kern)\r\n{\r\nstruct sock *sk;\r\npr_debug("sock=%p\n", sock);\r\nif ((sock->type != SOCK_SEQPACKET) && (sock->type != SOCK_RAW))\r\nreturn -ESOCKTNOSUPPORT;\r\nif (sock->type == SOCK_RAW)\r\nsock->ops = &rawsock_raw_ops;\r\nelse\r\nsock->ops = &rawsock_ops;\r\nsk = sk_alloc(net, PF_NFC, GFP_ATOMIC, nfc_proto->proto, kern);\r\nif (!sk)\r\nreturn -ENOMEM;\r\nsock_init_data(sock, sk);\r\nsk->sk_protocol = nfc_proto->id;\r\nsk->sk_destruct = rawsock_destruct;\r\nsock->state = SS_UNCONNECTED;\r\nif (sock->type == SOCK_RAW)\r\nnfc_sock_link(&raw_sk_list, sk);\r\nelse {\r\nINIT_WORK(&nfc_rawsock(sk)->tx_work, rawsock_tx_work);\r\nnfc_rawsock(sk)->tx_work_scheduled = false;\r\n}\r\nreturn 0;\r\n}\r\nvoid nfc_send_to_raw_sock(struct nfc_dev *dev, struct sk_buff *skb,\r\nu8 payload_type, u8 direction)\r\n{\r\nstruct sk_buff *skb_copy = NULL, *nskb;\r\nstruct sock *sk;\r\nu8 *data;\r\nread_lock(&raw_sk_list.lock);\r\nsk_for_each(sk, &raw_sk_list.head) {\r\nif (!skb_copy) {\r\nskb_copy = __pskb_copy_fclone(skb, NFC_RAW_HEADER_SIZE,\r\nGFP_ATOMIC, true);\r\nif (!skb_copy)\r\ncontinue;\r\ndata = skb_push(skb_copy, NFC_RAW_HEADER_SIZE);\r\ndata[0] = dev ? dev->idx : 0xFF;\r\ndata[1] = direction & 0x01;\r\ndata[1] |= (payload_type << 1);\r\n}\r\nnskb = skb_clone(skb_copy, GFP_ATOMIC);\r\nif (!nskb)\r\ncontinue;\r\nif (sock_queue_rcv_skb(sk, nskb))\r\nkfree_skb(nskb);\r\n}\r\nread_unlock(&raw_sk_list.lock);\r\nkfree_skb(skb_copy);\r\n}\r\nint __init rawsock_init(void)\r\n{\r\nint rc;\r\nrc = nfc_proto_register(&rawsock_nfc_proto);\r\nreturn rc;\r\n}\r\nvoid rawsock_exit(void)\r\n{\r\nnfc_proto_unregister(&rawsock_nfc_proto);\r\n}
