static inline void put_be32(__be32 val, __be32 __iomem * p)\r\n{\r\n__raw_writel((__force __u32) val, (__force void __iomem *)p);\r\n}\r\nstatic void set_fw_name(struct myri10ge_priv *mgp, char *name, bool allocated)\r\n{\r\nif (mgp->fw_name_allocated)\r\nkfree(mgp->fw_name);\r\nmgp->fw_name = name;\r\nmgp->fw_name_allocated = allocated;\r\n}\r\nstatic int\r\nmyri10ge_send_cmd(struct myri10ge_priv *mgp, u32 cmd,\r\nstruct myri10ge_cmd *data, int atomic)\r\n{\r\nstruct mcp_cmd *buf;\r\nchar buf_bytes[sizeof(*buf) + 8];\r\nstruct mcp_cmd_response *response = mgp->cmd;\r\nchar __iomem *cmd_addr = mgp->sram + MXGEFW_ETH_CMD;\r\nu32 dma_low, dma_high, result, value;\r\nint sleep_total = 0;\r\nbuf = (struct mcp_cmd *)ALIGN((unsigned long)buf_bytes, 8);\r\nbuf->data0 = htonl(data->data0);\r\nbuf->data1 = htonl(data->data1);\r\nbuf->data2 = htonl(data->data2);\r\nbuf->cmd = htonl(cmd);\r\ndma_low = MYRI10GE_LOWPART_TO_U32(mgp->cmd_bus);\r\ndma_high = MYRI10GE_HIGHPART_TO_U32(mgp->cmd_bus);\r\nbuf->response_addr.low = htonl(dma_low);\r\nbuf->response_addr.high = htonl(dma_high);\r\nresponse->result = htonl(MYRI10GE_NO_RESPONSE_RESULT);\r\nmb();\r\nmyri10ge_pio_copy(cmd_addr, buf, sizeof(*buf));\r\nif (atomic) {\r\nfor (sleep_total = 0;\r\nsleep_total < 1000 &&\r\nresponse->result == htonl(MYRI10GE_NO_RESPONSE_RESULT);\r\nsleep_total += 10) {\r\nudelay(10);\r\nmb();\r\n}\r\n} else {\r\nfor (sleep_total = 0;\r\nsleep_total < 15 &&\r\nresponse->result == htonl(MYRI10GE_NO_RESPONSE_RESULT);\r\nsleep_total++)\r\nmsleep(1);\r\n}\r\nresult = ntohl(response->result);\r\nvalue = ntohl(response->data);\r\nif (result != MYRI10GE_NO_RESPONSE_RESULT) {\r\nif (result == 0) {\r\ndata->data0 = value;\r\nreturn 0;\r\n} else if (result == MXGEFW_CMD_UNKNOWN) {\r\nreturn -ENOSYS;\r\n} else if (result == MXGEFW_CMD_ERROR_UNALIGNED) {\r\nreturn -E2BIG;\r\n} else if (result == MXGEFW_CMD_ERROR_RANGE &&\r\ncmd == MXGEFW_CMD_ENABLE_RSS_QUEUES &&\r\n(data->\r\ndata1 & MXGEFW_SLICE_ENABLE_MULTIPLE_TX_QUEUES) !=\r\n0) {\r\nreturn -ERANGE;\r\n} else {\r\ndev_err(&mgp->pdev->dev,\r\n"command %d failed, result = %d\n",\r\ncmd, result);\r\nreturn -ENXIO;\r\n}\r\n}\r\ndev_err(&mgp->pdev->dev, "command %d timed out, result = %d\n",\r\ncmd, result);\r\nreturn -EAGAIN;\r\n}\r\nstatic int myri10ge_read_mac_addr(struct myri10ge_priv *mgp)\r\n{\r\nchar *ptr, *limit;\r\nint i;\r\nptr = mgp->eeprom_strings;\r\nlimit = mgp->eeprom_strings + MYRI10GE_EEPROM_STRINGS_SIZE;\r\nwhile (*ptr != '\0' && ptr < limit) {\r\nif (memcmp(ptr, "MAC=", 4) == 0) {\r\nptr += 4;\r\nmgp->mac_addr_string = ptr;\r\nfor (i = 0; i < 6; i++) {\r\nif ((ptr + 2) > limit)\r\ngoto abort;\r\nmgp->mac_addr[i] =\r\nsimple_strtoul(ptr, &ptr, 16);\r\nptr += 1;\r\n}\r\n}\r\nif (memcmp(ptr, "PC=", 3) == 0) {\r\nptr += 3;\r\nmgp->product_code_string = ptr;\r\n}\r\nif (memcmp((const void *)ptr, "SN=", 3) == 0) {\r\nptr += 3;\r\nmgp->serial_number = simple_strtoul(ptr, &ptr, 10);\r\n}\r\nwhile (ptr < limit && *ptr++) ;\r\n}\r\nreturn 0;\r\nabort:\r\ndev_err(&mgp->pdev->dev, "failed to parse eeprom_strings\n");\r\nreturn -ENXIO;\r\n}\r\nstatic void myri10ge_dummy_rdma(struct myri10ge_priv *mgp, int enable)\r\n{\r\nchar __iomem *submit;\r\n__be32 buf[16] __attribute__ ((__aligned__(8)));\r\nu32 dma_low, dma_high;\r\nint i;\r\nmgp->cmd->data = 0;\r\nmb();\r\ndma_low = MYRI10GE_LOWPART_TO_U32(mgp->cmd_bus);\r\ndma_high = MYRI10GE_HIGHPART_TO_U32(mgp->cmd_bus);\r\nbuf[0] = htonl(dma_high);\r\nbuf[1] = htonl(dma_low);\r\nbuf[2] = MYRI10GE_NO_CONFIRM_DATA;\r\nbuf[3] = htonl(dma_high);\r\nbuf[4] = htonl(dma_low);\r\nbuf[5] = htonl(enable);\r\nsubmit = mgp->sram + MXGEFW_BOOT_DUMMY_RDMA;\r\nmyri10ge_pio_copy(submit, &buf, sizeof(buf));\r\nfor (i = 0; mgp->cmd->data != MYRI10GE_NO_CONFIRM_DATA && i < 20; i++)\r\nmsleep(1);\r\nif (mgp->cmd->data != MYRI10GE_NO_CONFIRM_DATA)\r\ndev_err(&mgp->pdev->dev, "dummy rdma %s failed\n",\r\n(enable ? "enable" : "disable"));\r\n}\r\nstatic int\r\nmyri10ge_validate_firmware(struct myri10ge_priv *mgp,\r\nstruct mcp_gen_header *hdr)\r\n{\r\nstruct device *dev = &mgp->pdev->dev;\r\nif (ntohl(hdr->mcp_type) != MCP_TYPE_ETH) {\r\ndev_err(dev, "Bad firmware type: 0x%x\n", ntohl(hdr->mcp_type));\r\nreturn -EINVAL;\r\n}\r\nstrncpy(mgp->fw_version, hdr->version, sizeof(mgp->fw_version));\r\nmgp->fw_version[sizeof(mgp->fw_version) - 1] = '\0';\r\nsscanf(mgp->fw_version, "%d.%d.%d", &mgp->fw_ver_major,\r\n&mgp->fw_ver_minor, &mgp->fw_ver_tiny);\r\nif (!(mgp->fw_ver_major == MXGEFW_VERSION_MAJOR &&\r\nmgp->fw_ver_minor == MXGEFW_VERSION_MINOR)) {\r\ndev_err(dev, "Found firmware version %s\n", mgp->fw_version);\r\ndev_err(dev, "Driver needs %d.%d\n", MXGEFW_VERSION_MAJOR,\r\nMXGEFW_VERSION_MINOR);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int myri10ge_load_hotplug_firmware(struct myri10ge_priv *mgp, u32 * size)\r\n{\r\nunsigned crc, reread_crc;\r\nconst struct firmware *fw;\r\nstruct device *dev = &mgp->pdev->dev;\r\nunsigned char *fw_readback;\r\nstruct mcp_gen_header *hdr;\r\nsize_t hdr_offset;\r\nint status;\r\nunsigned i;\r\nif ((status = request_firmware(&fw, mgp->fw_name, dev)) < 0) {\r\ndev_err(dev, "Unable to load %s firmware image via hotplug\n",\r\nmgp->fw_name);\r\nstatus = -EINVAL;\r\ngoto abort_with_nothing;\r\n}\r\nif (fw->size >= mgp->sram_size - MYRI10GE_FW_OFFSET ||\r\nfw->size < MCP_HEADER_PTR_OFFSET + 4) {\r\ndev_err(dev, "Firmware size invalid:%d\n", (int)fw->size);\r\nstatus = -EINVAL;\r\ngoto abort_with_fw;\r\n}\r\nhdr_offset = ntohl(*(__be32 *) (fw->data + MCP_HEADER_PTR_OFFSET));\r\nif ((hdr_offset & 3) || hdr_offset + sizeof(*hdr) > fw->size) {\r\ndev_err(dev, "Bad firmware file\n");\r\nstatus = -EINVAL;\r\ngoto abort_with_fw;\r\n}\r\nhdr = (void *)(fw->data + hdr_offset);\r\nstatus = myri10ge_validate_firmware(mgp, hdr);\r\nif (status != 0)\r\ngoto abort_with_fw;\r\ncrc = crc32(~0, fw->data, fw->size);\r\nfor (i = 0; i < fw->size; i += 256) {\r\nmyri10ge_pio_copy(mgp->sram + MYRI10GE_FW_OFFSET + i,\r\nfw->data + i,\r\nmin(256U, (unsigned)(fw->size - i)));\r\nmb();\r\nreadb(mgp->sram);\r\n}\r\nfw_readback = vmalloc(fw->size);\r\nif (!fw_readback) {\r\nstatus = -ENOMEM;\r\ngoto abort_with_fw;\r\n}\r\nmemcpy_fromio(fw_readback, mgp->sram + MYRI10GE_FW_OFFSET, fw->size);\r\nreread_crc = crc32(~0, fw_readback, fw->size);\r\nvfree(fw_readback);\r\nif (crc != reread_crc) {\r\ndev_err(dev, "CRC failed(fw-len=%u), got 0x%x (expect 0x%x)\n",\r\n(unsigned)fw->size, reread_crc, crc);\r\nstatus = -EIO;\r\ngoto abort_with_fw;\r\n}\r\n*size = (u32) fw->size;\r\nabort_with_fw:\r\nrelease_firmware(fw);\r\nabort_with_nothing:\r\nreturn status;\r\n}\r\nstatic int myri10ge_adopt_running_firmware(struct myri10ge_priv *mgp)\r\n{\r\nstruct mcp_gen_header *hdr;\r\nstruct device *dev = &mgp->pdev->dev;\r\nconst size_t bytes = sizeof(struct mcp_gen_header);\r\nsize_t hdr_offset;\r\nint status;\r\nhdr_offset = swab32(readl(mgp->sram + MCP_HEADER_PTR_OFFSET));\r\nif ((hdr_offset & 3) || hdr_offset + sizeof(*hdr) > mgp->sram_size) {\r\ndev_err(dev, "Running firmware has bad header offset (%d)\n",\r\n(int)hdr_offset);\r\nreturn -EIO;\r\n}\r\nhdr = kmalloc(bytes, GFP_KERNEL);\r\nif (hdr == NULL)\r\nreturn -ENOMEM;\r\nmemcpy_fromio(hdr, mgp->sram + hdr_offset, bytes);\r\nstatus = myri10ge_validate_firmware(mgp, hdr);\r\nkfree(hdr);\r\nif (mgp->fw_ver_major == 1 && mgp->fw_ver_minor == 4 &&\r\nmgp->fw_ver_tiny >= 4 && mgp->fw_ver_tiny <= 11) {\r\nmgp->adopted_rx_filter_bug = 1;\r\ndev_warn(dev, "Adopting fw %d.%d.%d: "\r\n"working around rx filter bug\n",\r\nmgp->fw_ver_major, mgp->fw_ver_minor,\r\nmgp->fw_ver_tiny);\r\n}\r\nreturn status;\r\n}\r\nstatic int myri10ge_get_firmware_capabilities(struct myri10ge_priv *mgp)\r\n{\r\nstruct myri10ge_cmd cmd;\r\nint status;\r\nmgp->features = NETIF_F_SG | NETIF_F_HW_CSUM | NETIF_F_TSO;\r\nstatus = myri10ge_send_cmd(mgp, MXGEFW_CMD_GET_MAX_TSO6_HDR_SIZE,\r\n&cmd, 0);\r\nif (status == 0) {\r\nmgp->max_tso6 = cmd.data0;\r\nmgp->features |= NETIF_F_TSO6;\r\n}\r\nstatus = myri10ge_send_cmd(mgp, MXGEFW_CMD_GET_RX_RING_SIZE, &cmd, 0);\r\nif (status != 0) {\r\ndev_err(&mgp->pdev->dev,\r\n"failed MXGEFW_CMD_GET_RX_RING_SIZE\n");\r\nreturn -ENXIO;\r\n}\r\nmgp->max_intr_slots = 2 * (cmd.data0 / sizeof(struct mcp_dma_addr));\r\nreturn 0;\r\n}\r\nstatic int myri10ge_load_firmware(struct myri10ge_priv *mgp, int adopt)\r\n{\r\nchar __iomem *submit;\r\n__be32 buf[16] __attribute__ ((__aligned__(8)));\r\nu32 dma_low, dma_high, size;\r\nint status, i;\r\nsize = 0;\r\nstatus = myri10ge_load_hotplug_firmware(mgp, &size);\r\nif (status) {\r\nif (!adopt)\r\nreturn status;\r\ndev_warn(&mgp->pdev->dev, "hotplug firmware loading failed\n");\r\nif (status == -EIO)\r\nreturn status;\r\nstatus = myri10ge_adopt_running_firmware(mgp);\r\nif (status != 0) {\r\ndev_err(&mgp->pdev->dev,\r\n"failed to adopt running firmware\n");\r\nreturn status;\r\n}\r\ndev_info(&mgp->pdev->dev,\r\n"Successfully adopted running firmware\n");\r\nif (mgp->tx_boundary == 4096) {\r\ndev_warn(&mgp->pdev->dev,\r\n"Using firmware currently running on NIC"\r\n". For optimal\n");\r\ndev_warn(&mgp->pdev->dev,\r\n"performance consider loading optimized "\r\n"firmware\n");\r\ndev_warn(&mgp->pdev->dev, "via hotplug\n");\r\n}\r\nset_fw_name(mgp, "adopted", false);\r\nmgp->tx_boundary = 2048;\r\nmyri10ge_dummy_rdma(mgp, 1);\r\nstatus = myri10ge_get_firmware_capabilities(mgp);\r\nreturn status;\r\n}\r\nmgp->cmd->data = 0;\r\nmb();\r\ndma_low = MYRI10GE_LOWPART_TO_U32(mgp->cmd_bus);\r\ndma_high = MYRI10GE_HIGHPART_TO_U32(mgp->cmd_bus);\r\nbuf[0] = htonl(dma_high);\r\nbuf[1] = htonl(dma_low);\r\nbuf[2] = MYRI10GE_NO_CONFIRM_DATA;\r\nbuf[3] = htonl(MYRI10GE_FW_OFFSET + 8);\r\nbuf[4] = htonl(size - 8);\r\nbuf[5] = htonl(8);\r\nbuf[6] = htonl(0);\r\nsubmit = mgp->sram + MXGEFW_BOOT_HANDOFF;\r\nmyri10ge_pio_copy(submit, &buf, sizeof(buf));\r\nmb();\r\nmsleep(1);\r\nmb();\r\ni = 0;\r\nwhile (mgp->cmd->data != MYRI10GE_NO_CONFIRM_DATA && i < 9) {\r\nmsleep(1 << i);\r\ni++;\r\n}\r\nif (mgp->cmd->data != MYRI10GE_NO_CONFIRM_DATA) {\r\ndev_err(&mgp->pdev->dev, "handoff failed\n");\r\nreturn -ENXIO;\r\n}\r\nmyri10ge_dummy_rdma(mgp, 1);\r\nstatus = myri10ge_get_firmware_capabilities(mgp);\r\nreturn status;\r\n}\r\nstatic int myri10ge_update_mac_address(struct myri10ge_priv *mgp, u8 * addr)\r\n{\r\nstruct myri10ge_cmd cmd;\r\nint status;\r\ncmd.data0 = ((addr[0] << 24) | (addr[1] << 16)\r\n| (addr[2] << 8) | addr[3]);\r\ncmd.data1 = ((addr[4] << 8) | (addr[5]));\r\nstatus = myri10ge_send_cmd(mgp, MXGEFW_SET_MAC_ADDRESS, &cmd, 0);\r\nreturn status;\r\n}\r\nstatic int myri10ge_change_pause(struct myri10ge_priv *mgp, int pause)\r\n{\r\nstruct myri10ge_cmd cmd;\r\nint status, ctl;\r\nctl = pause ? MXGEFW_ENABLE_FLOW_CONTROL : MXGEFW_DISABLE_FLOW_CONTROL;\r\nstatus = myri10ge_send_cmd(mgp, ctl, &cmd, 0);\r\nif (status) {\r\nnetdev_err(mgp->dev, "Failed to set flow control mode\n");\r\nreturn status;\r\n}\r\nmgp->pause = pause;\r\nreturn 0;\r\n}\r\nstatic void\r\nmyri10ge_change_promisc(struct myri10ge_priv *mgp, int promisc, int atomic)\r\n{\r\nstruct myri10ge_cmd cmd;\r\nint status, ctl;\r\nctl = promisc ? MXGEFW_ENABLE_PROMISC : MXGEFW_DISABLE_PROMISC;\r\nstatus = myri10ge_send_cmd(mgp, ctl, &cmd, atomic);\r\nif (status)\r\nnetdev_err(mgp->dev, "Failed to set promisc mode\n");\r\n}\r\nstatic int myri10ge_dma_test(struct myri10ge_priv *mgp, int test_type)\r\n{\r\nstruct myri10ge_cmd cmd;\r\nint status;\r\nu32 len;\r\nstruct page *dmatest_page;\r\ndma_addr_t dmatest_bus;\r\nchar *test = " ";\r\ndmatest_page = alloc_page(GFP_KERNEL);\r\nif (!dmatest_page)\r\nreturn -ENOMEM;\r\ndmatest_bus = pci_map_page(mgp->pdev, dmatest_page, 0, PAGE_SIZE,\r\nDMA_BIDIRECTIONAL);\r\nif (unlikely(pci_dma_mapping_error(mgp->pdev, dmatest_bus))) {\r\n__free_page(dmatest_page);\r\nreturn -ENOMEM;\r\n}\r\nlen = mgp->tx_boundary;\r\ncmd.data0 = MYRI10GE_LOWPART_TO_U32(dmatest_bus);\r\ncmd.data1 = MYRI10GE_HIGHPART_TO_U32(dmatest_bus);\r\ncmd.data2 = len * 0x10000;\r\nstatus = myri10ge_send_cmd(mgp, test_type, &cmd, 0);\r\nif (status != 0) {\r\ntest = "read";\r\ngoto abort;\r\n}\r\nmgp->read_dma = ((cmd.data0 >> 16) * len * 2) / (cmd.data0 & 0xffff);\r\ncmd.data0 = MYRI10GE_LOWPART_TO_U32(dmatest_bus);\r\ncmd.data1 = MYRI10GE_HIGHPART_TO_U32(dmatest_bus);\r\ncmd.data2 = len * 0x1;\r\nstatus = myri10ge_send_cmd(mgp, test_type, &cmd, 0);\r\nif (status != 0) {\r\ntest = "write";\r\ngoto abort;\r\n}\r\nmgp->write_dma = ((cmd.data0 >> 16) * len * 2) / (cmd.data0 & 0xffff);\r\ncmd.data0 = MYRI10GE_LOWPART_TO_U32(dmatest_bus);\r\ncmd.data1 = MYRI10GE_HIGHPART_TO_U32(dmatest_bus);\r\ncmd.data2 = len * 0x10001;\r\nstatus = myri10ge_send_cmd(mgp, test_type, &cmd, 0);\r\nif (status != 0) {\r\ntest = "read/write";\r\ngoto abort;\r\n}\r\nmgp->read_write_dma = ((cmd.data0 >> 16) * len * 2 * 2) /\r\n(cmd.data0 & 0xffff);\r\nabort:\r\npci_unmap_page(mgp->pdev, dmatest_bus, PAGE_SIZE, DMA_BIDIRECTIONAL);\r\nput_page(dmatest_page);\r\nif (status != 0 && test_type != MXGEFW_CMD_UNALIGNED_TEST)\r\ndev_warn(&mgp->pdev->dev, "DMA %s benchmark failed: %d\n",\r\ntest, status);\r\nreturn status;\r\n}\r\nstatic int myri10ge_reset(struct myri10ge_priv *mgp)\r\n{\r\nstruct myri10ge_cmd cmd;\r\nstruct myri10ge_slice_state *ss;\r\nint i, status;\r\nsize_t bytes;\r\n#ifdef CONFIG_MYRI10GE_DCA\r\nunsigned long dca_tag_off;\r\n#endif\r\nmemset(&cmd, 0, sizeof(cmd));\r\nstatus = myri10ge_send_cmd(mgp, MXGEFW_CMD_RESET, &cmd, 0);\r\nif (status != 0) {\r\ndev_err(&mgp->pdev->dev, "failed reset\n");\r\nreturn -ENXIO;\r\n}\r\n(void)myri10ge_dma_test(mgp, MXGEFW_DMA_TEST);\r\ncmd.data0 = MXGEFW_RSS_MCP_SLOT_TYPE_MIN;\r\n(void)myri10ge_send_cmd(mgp, MXGEFW_CMD_SET_RSS_MCP_SLOT_TYPE, &cmd, 0);\r\nbytes = mgp->max_intr_slots * sizeof(*mgp->ss[0].rx_done.entry);\r\ncmd.data0 = (u32) bytes;\r\nstatus = myri10ge_send_cmd(mgp, MXGEFW_CMD_SET_INTRQ_SIZE, &cmd, 0);\r\nif (mgp->num_slices > 1) {\r\nstatus = myri10ge_send_cmd(mgp, MXGEFW_CMD_GET_MAX_RSS_QUEUES,\r\n&cmd, 0);\r\nif (status != 0) {\r\ndev_err(&mgp->pdev->dev,\r\n"failed to get number of slices\n");\r\n}\r\ncmd.data0 = mgp->num_slices;\r\ncmd.data1 = MXGEFW_SLICE_INTR_MODE_ONE_PER_SLICE;\r\nif (mgp->dev->real_num_tx_queues > 1)\r\ncmd.data1 |= MXGEFW_SLICE_ENABLE_MULTIPLE_TX_QUEUES;\r\nstatus = myri10ge_send_cmd(mgp, MXGEFW_CMD_ENABLE_RSS_QUEUES,\r\n&cmd, 0);\r\nif (status != 0 && mgp->dev->real_num_tx_queues > 1) {\r\nnetif_set_real_num_tx_queues(mgp->dev, 1);\r\ncmd.data0 = mgp->num_slices;\r\ncmd.data1 = MXGEFW_SLICE_INTR_MODE_ONE_PER_SLICE;\r\nstatus = myri10ge_send_cmd(mgp,\r\nMXGEFW_CMD_ENABLE_RSS_QUEUES,\r\n&cmd, 0);\r\n}\r\nif (status != 0) {\r\ndev_err(&mgp->pdev->dev,\r\n"failed to set number of slices\n");\r\nreturn status;\r\n}\r\n}\r\nfor (i = 0; i < mgp->num_slices; i++) {\r\nss = &mgp->ss[i];\r\ncmd.data0 = MYRI10GE_LOWPART_TO_U32(ss->rx_done.bus);\r\ncmd.data1 = MYRI10GE_HIGHPART_TO_U32(ss->rx_done.bus);\r\ncmd.data2 = i;\r\nstatus |= myri10ge_send_cmd(mgp, MXGEFW_CMD_SET_INTRQ_DMA,\r\n&cmd, 0);\r\n}\r\nstatus |=\r\nmyri10ge_send_cmd(mgp, MXGEFW_CMD_GET_IRQ_ACK_OFFSET, &cmd, 0);\r\nfor (i = 0; i < mgp->num_slices; i++) {\r\nss = &mgp->ss[i];\r\nss->irq_claim =\r\n(__iomem __be32 *) (mgp->sram + cmd.data0 + 8 * i);\r\n}\r\nstatus |= myri10ge_send_cmd(mgp, MXGEFW_CMD_GET_IRQ_DEASSERT_OFFSET,\r\n&cmd, 0);\r\nmgp->irq_deassert = (__iomem __be32 *) (mgp->sram + cmd.data0);\r\nstatus |= myri10ge_send_cmd\r\n(mgp, MXGEFW_CMD_GET_INTR_COAL_DELAY_OFFSET, &cmd, 0);\r\nmgp->intr_coal_delay_ptr = (__iomem __be32 *) (mgp->sram + cmd.data0);\r\nif (status != 0) {\r\ndev_err(&mgp->pdev->dev, "failed set interrupt parameters\n");\r\nreturn status;\r\n}\r\nput_be32(htonl(mgp->intr_coal_delay), mgp->intr_coal_delay_ptr);\r\n#ifdef CONFIG_MYRI10GE_DCA\r\nstatus = myri10ge_send_cmd(mgp, MXGEFW_CMD_GET_DCA_OFFSET, &cmd, 0);\r\ndca_tag_off = cmd.data0;\r\nfor (i = 0; i < mgp->num_slices; i++) {\r\nss = &mgp->ss[i];\r\nif (status == 0) {\r\nss->dca_tag = (__iomem __be32 *)\r\n(mgp->sram + dca_tag_off + 4 * i);\r\n} else {\r\nss->dca_tag = NULL;\r\n}\r\n}\r\n#endif\r\nmgp->link_changes = 0;\r\nfor (i = 0; i < mgp->num_slices; i++) {\r\nss = &mgp->ss[i];\r\nmemset(ss->rx_done.entry, 0, bytes);\r\nss->tx.req = 0;\r\nss->tx.done = 0;\r\nss->tx.pkt_start = 0;\r\nss->tx.pkt_done = 0;\r\nss->rx_big.cnt = 0;\r\nss->rx_small.cnt = 0;\r\nss->rx_done.idx = 0;\r\nss->rx_done.cnt = 0;\r\nss->tx.wake_queue = 0;\r\nss->tx.stop_queue = 0;\r\n}\r\nstatus = myri10ge_update_mac_address(mgp, mgp->dev->dev_addr);\r\nmyri10ge_change_pause(mgp, mgp->pause);\r\nmyri10ge_set_multicast_list(mgp->dev);\r\nreturn status;\r\n}\r\nstatic int myri10ge_toggle_relaxed(struct pci_dev *pdev, int on)\r\n{\r\nint ret;\r\nu16 ctl;\r\npcie_capability_read_word(pdev, PCI_EXP_DEVCTL, &ctl);\r\nret = (ctl & PCI_EXP_DEVCTL_RELAX_EN) >> 4;\r\nif (ret != on) {\r\nctl &= ~PCI_EXP_DEVCTL_RELAX_EN;\r\nctl |= (on << 4);\r\npcie_capability_write_word(pdev, PCI_EXP_DEVCTL, ctl);\r\n}\r\nreturn ret;\r\n}\r\nstatic void\r\nmyri10ge_write_dca(struct myri10ge_slice_state *ss, int cpu, int tag)\r\n{\r\nss->cached_dca_tag = tag;\r\nput_be32(htonl(tag), ss->dca_tag);\r\n}\r\nstatic inline void myri10ge_update_dca(struct myri10ge_slice_state *ss)\r\n{\r\nint cpu = get_cpu();\r\nint tag;\r\nif (cpu != ss->cpu) {\r\ntag = dca3_get_tag(&ss->mgp->pdev->dev, cpu);\r\nif (ss->cached_dca_tag != tag)\r\nmyri10ge_write_dca(ss, cpu, tag);\r\nss->cpu = cpu;\r\n}\r\nput_cpu();\r\n}\r\nstatic void myri10ge_setup_dca(struct myri10ge_priv *mgp)\r\n{\r\nint err, i;\r\nstruct pci_dev *pdev = mgp->pdev;\r\nif (mgp->ss[0].dca_tag == NULL || mgp->dca_enabled)\r\nreturn;\r\nif (!myri10ge_dca) {\r\ndev_err(&pdev->dev, "dca disabled by administrator\n");\r\nreturn;\r\n}\r\nerr = dca_add_requester(&pdev->dev);\r\nif (err) {\r\nif (err != -ENODEV)\r\ndev_err(&pdev->dev,\r\n"dca_add_requester() failed, err=%d\n", err);\r\nreturn;\r\n}\r\nmgp->relaxed_order = myri10ge_toggle_relaxed(pdev, 0);\r\nmgp->dca_enabled = 1;\r\nfor (i = 0; i < mgp->num_slices; i++) {\r\nmgp->ss[i].cpu = -1;\r\nmgp->ss[i].cached_dca_tag = -1;\r\nmyri10ge_update_dca(&mgp->ss[i]);\r\n}\r\n}\r\nstatic void myri10ge_teardown_dca(struct myri10ge_priv *mgp)\r\n{\r\nstruct pci_dev *pdev = mgp->pdev;\r\nif (!mgp->dca_enabled)\r\nreturn;\r\nmgp->dca_enabled = 0;\r\nif (mgp->relaxed_order)\r\nmyri10ge_toggle_relaxed(pdev, 1);\r\ndca_remove_requester(&pdev->dev);\r\n}\r\nstatic int myri10ge_notify_dca_device(struct device *dev, void *data)\r\n{\r\nstruct myri10ge_priv *mgp;\r\nunsigned long event;\r\nmgp = dev_get_drvdata(dev);\r\nevent = *(unsigned long *)data;\r\nif (event == DCA_PROVIDER_ADD)\r\nmyri10ge_setup_dca(mgp);\r\nelse if (event == DCA_PROVIDER_REMOVE)\r\nmyri10ge_teardown_dca(mgp);\r\nreturn 0;\r\n}\r\nstatic inline void\r\nmyri10ge_submit_8rx(struct mcp_kreq_ether_recv __iomem * dst,\r\nstruct mcp_kreq_ether_recv *src)\r\n{\r\n__be32 low;\r\nlow = src->addr_low;\r\nsrc->addr_low = htonl(DMA_BIT_MASK(32));\r\nmyri10ge_pio_copy(dst, src, 4 * sizeof(*src));\r\nmb();\r\nmyri10ge_pio_copy(dst + 4, src + 4, 4 * sizeof(*src));\r\nmb();\r\nsrc->addr_low = low;\r\nput_be32(low, &dst->addr_low);\r\nmb();\r\n}\r\nstatic inline void myri10ge_vlan_ip_csum(struct sk_buff *skb, __wsum hw_csum)\r\n{\r\nstruct vlan_hdr *vh = (struct vlan_hdr *)(skb->data);\r\nif ((skb->protocol == htons(ETH_P_8021Q)) &&\r\n(vh->h_vlan_encapsulated_proto == htons(ETH_P_IP) ||\r\nvh->h_vlan_encapsulated_proto == htons(ETH_P_IPV6))) {\r\nskb->csum = hw_csum;\r\nskb->ip_summed = CHECKSUM_COMPLETE;\r\n}\r\n}\r\nstatic void\r\nmyri10ge_alloc_rx_pages(struct myri10ge_priv *mgp, struct myri10ge_rx_buf *rx,\r\nint bytes, int watchdog)\r\n{\r\nstruct page *page;\r\ndma_addr_t bus;\r\nint idx;\r\n#if MYRI10GE_ALLOC_SIZE > 4096\r\nint end_offset;\r\n#endif\r\nif (unlikely(rx->watchdog_needed && !watchdog))\r\nreturn;\r\nwhile (rx->fill_cnt != (rx->cnt + rx->mask + 1)) {\r\nidx = rx->fill_cnt & rx->mask;\r\nif (rx->page_offset + bytes <= MYRI10GE_ALLOC_SIZE) {\r\nget_page(rx->page);\r\n} else {\r\npage =\r\nalloc_pages(GFP_ATOMIC | __GFP_COMP,\r\nMYRI10GE_ALLOC_ORDER);\r\nif (unlikely(page == NULL)) {\r\nif (rx->fill_cnt - rx->cnt < 16)\r\nrx->watchdog_needed = 1;\r\nreturn;\r\n}\r\nbus = pci_map_page(mgp->pdev, page, 0,\r\nMYRI10GE_ALLOC_SIZE,\r\nPCI_DMA_FROMDEVICE);\r\nif (unlikely(pci_dma_mapping_error(mgp->pdev, bus))) {\r\n__free_pages(page, MYRI10GE_ALLOC_ORDER);\r\nif (rx->fill_cnt - rx->cnt < 16)\r\nrx->watchdog_needed = 1;\r\nreturn;\r\n}\r\nrx->page = page;\r\nrx->page_offset = 0;\r\nrx->bus = bus;\r\n}\r\nrx->info[idx].page = rx->page;\r\nrx->info[idx].page_offset = rx->page_offset;\r\ndma_unmap_addr_set(&rx->info[idx], bus, rx->bus);\r\nrx->shadow[idx].addr_low =\r\nhtonl(MYRI10GE_LOWPART_TO_U32(rx->bus) + rx->page_offset);\r\nrx->shadow[idx].addr_high =\r\nhtonl(MYRI10GE_HIGHPART_TO_U32(rx->bus));\r\nrx->page_offset += SKB_DATA_ALIGN(bytes);\r\n#if MYRI10GE_ALLOC_SIZE > 4096\r\nend_offset = rx->page_offset + bytes - 1;\r\nif ((unsigned)(rx->page_offset ^ end_offset) > 4095)\r\nrx->page_offset = end_offset & ~4095;\r\n#endif\r\nrx->fill_cnt++;\r\nif ((idx & 7) == 7) {\r\nmyri10ge_submit_8rx(&rx->lanai[idx - 7],\r\n&rx->shadow[idx - 7]);\r\n}\r\n}\r\n}\r\nstatic inline void\r\nmyri10ge_unmap_rx_page(struct pci_dev *pdev,\r\nstruct myri10ge_rx_buffer_state *info, int bytes)\r\n{\r\nif (bytes >= MYRI10GE_ALLOC_SIZE / 2 ||\r\n(info->page_offset + 2 * bytes) > MYRI10GE_ALLOC_SIZE) {\r\npci_unmap_page(pdev, (dma_unmap_addr(info, bus)\r\n& ~(MYRI10GE_ALLOC_SIZE - 1)),\r\nMYRI10GE_ALLOC_SIZE, PCI_DMA_FROMDEVICE);\r\n}\r\n}\r\nstatic inline void\r\nmyri10ge_vlan_rx(struct net_device *dev, void *addr, struct sk_buff *skb)\r\n{\r\nu8 *va;\r\nstruct vlan_ethhdr *veh;\r\nstruct skb_frag_struct *frag;\r\n__wsum vsum;\r\nva = addr;\r\nva += MXGEFW_PAD;\r\nveh = (struct vlan_ethhdr *)va;\r\nif ((dev->features & NETIF_F_HW_VLAN_CTAG_RX) ==\r\nNETIF_F_HW_VLAN_CTAG_RX &&\r\nveh->h_vlan_proto == htons(ETH_P_8021Q)) {\r\nif (skb->ip_summed == CHECKSUM_COMPLETE) {\r\nvsum = csum_partial(va + ETH_HLEN, VLAN_HLEN, 0);\r\nskb->csum = csum_sub(skb->csum, vsum);\r\n}\r\n__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), ntohs(veh->h_vlan_TCI));\r\nmemmove(va + VLAN_HLEN, va, 2 * ETH_ALEN);\r\nskb->len -= VLAN_HLEN;\r\nskb->data_len -= VLAN_HLEN;\r\nfrag = skb_shinfo(skb)->frags;\r\nfrag->page_offset += VLAN_HLEN;\r\nskb_frag_size_set(frag, skb_frag_size(frag) - VLAN_HLEN);\r\n}\r\n}\r\nstatic inline int\r\nmyri10ge_rx_done(struct myri10ge_slice_state *ss, int len, __wsum csum)\r\n{\r\nstruct myri10ge_priv *mgp = ss->mgp;\r\nstruct sk_buff *skb;\r\nstruct skb_frag_struct *rx_frags;\r\nstruct myri10ge_rx_buf *rx;\r\nint i, idx, remainder, bytes;\r\nstruct pci_dev *pdev = mgp->pdev;\r\nstruct net_device *dev = mgp->dev;\r\nu8 *va;\r\nif (len <= mgp->small_bytes) {\r\nrx = &ss->rx_small;\r\nbytes = mgp->small_bytes;\r\n} else {\r\nrx = &ss->rx_big;\r\nbytes = mgp->big_bytes;\r\n}\r\nlen += MXGEFW_PAD;\r\nidx = rx->cnt & rx->mask;\r\nva = page_address(rx->info[idx].page) + rx->info[idx].page_offset;\r\nprefetch(va);\r\nskb = napi_get_frags(&ss->napi);\r\nif (unlikely(skb == NULL)) {\r\nss->stats.rx_dropped++;\r\nfor (i = 0, remainder = len; remainder > 0; i++) {\r\nmyri10ge_unmap_rx_page(pdev, &rx->info[idx], bytes);\r\nput_page(rx->info[idx].page);\r\nrx->cnt++;\r\nidx = rx->cnt & rx->mask;\r\nremainder -= MYRI10GE_ALLOC_SIZE;\r\n}\r\nreturn 0;\r\n}\r\nrx_frags = skb_shinfo(skb)->frags;\r\nfor (i = 0, remainder = len; remainder > 0; i++) {\r\nmyri10ge_unmap_rx_page(pdev, &rx->info[idx], bytes);\r\nskb_fill_page_desc(skb, i, rx->info[idx].page,\r\nrx->info[idx].page_offset,\r\nremainder < MYRI10GE_ALLOC_SIZE ?\r\nremainder : MYRI10GE_ALLOC_SIZE);\r\nrx->cnt++;\r\nidx = rx->cnt & rx->mask;\r\nremainder -= MYRI10GE_ALLOC_SIZE;\r\n}\r\nrx_frags[0].page_offset += MXGEFW_PAD;\r\nrx_frags[0].size -= MXGEFW_PAD;\r\nlen -= MXGEFW_PAD;\r\nskb->len = len;\r\nskb->data_len = len;\r\nskb->truesize += len;\r\nif (dev->features & NETIF_F_RXCSUM) {\r\nskb->ip_summed = CHECKSUM_COMPLETE;\r\nskb->csum = csum;\r\n}\r\nmyri10ge_vlan_rx(mgp->dev, va, skb);\r\nskb_record_rx_queue(skb, ss - &mgp->ss[0]);\r\nnapi_gro_frags(&ss->napi);\r\nreturn 1;\r\n}\r\nstatic inline void\r\nmyri10ge_tx_done(struct myri10ge_slice_state *ss, int mcp_index)\r\n{\r\nstruct pci_dev *pdev = ss->mgp->pdev;\r\nstruct myri10ge_tx_buf *tx = &ss->tx;\r\nstruct netdev_queue *dev_queue;\r\nstruct sk_buff *skb;\r\nint idx, len;\r\nwhile (tx->pkt_done != mcp_index) {\r\nidx = tx->done & tx->mask;\r\nskb = tx->info[idx].skb;\r\ntx->info[idx].skb = NULL;\r\nif (tx->info[idx].last) {\r\ntx->pkt_done++;\r\ntx->info[idx].last = 0;\r\n}\r\ntx->done++;\r\nlen = dma_unmap_len(&tx->info[idx], len);\r\ndma_unmap_len_set(&tx->info[idx], len, 0);\r\nif (skb) {\r\nss->stats.tx_bytes += skb->len;\r\nss->stats.tx_packets++;\r\ndev_kfree_skb_irq(skb);\r\nif (len)\r\npci_unmap_single(pdev,\r\ndma_unmap_addr(&tx->info[idx],\r\nbus), len,\r\nPCI_DMA_TODEVICE);\r\n} else {\r\nif (len)\r\npci_unmap_page(pdev,\r\ndma_unmap_addr(&tx->info[idx],\r\nbus), len,\r\nPCI_DMA_TODEVICE);\r\n}\r\n}\r\ndev_queue = netdev_get_tx_queue(ss->dev, ss - ss->mgp->ss);\r\nif ((ss->mgp->dev->real_num_tx_queues > 1) &&\r\n__netif_tx_trylock(dev_queue)) {\r\nif (tx->req == tx->done) {\r\ntx->queue_active = 0;\r\nput_be32(htonl(1), tx->send_stop);\r\nmb();\r\nmmiowb();\r\n}\r\n__netif_tx_unlock(dev_queue);\r\n}\r\nif (netif_tx_queue_stopped(dev_queue) &&\r\ntx->req - tx->done < (tx->mask >> 1) &&\r\nss->mgp->running == MYRI10GE_ETH_RUNNING) {\r\ntx->wake_queue++;\r\nnetif_tx_wake_queue(dev_queue);\r\n}\r\n}\r\nstatic inline int\r\nmyri10ge_clean_rx_done(struct myri10ge_slice_state *ss, int budget)\r\n{\r\nstruct myri10ge_rx_done *rx_done = &ss->rx_done;\r\nstruct myri10ge_priv *mgp = ss->mgp;\r\nunsigned long rx_bytes = 0;\r\nunsigned long rx_packets = 0;\r\nunsigned long rx_ok;\r\nint idx = rx_done->idx;\r\nint cnt = rx_done->cnt;\r\nint work_done = 0;\r\nu16 length;\r\n__wsum checksum;\r\nwhile (rx_done->entry[idx].length != 0 && work_done < budget) {\r\nlength = ntohs(rx_done->entry[idx].length);\r\nrx_done->entry[idx].length = 0;\r\nchecksum = csum_unfold(rx_done->entry[idx].checksum);\r\nrx_ok = myri10ge_rx_done(ss, length, checksum);\r\nrx_packets += rx_ok;\r\nrx_bytes += rx_ok * (unsigned long)length;\r\ncnt++;\r\nidx = cnt & (mgp->max_intr_slots - 1);\r\nwork_done++;\r\n}\r\nrx_done->idx = idx;\r\nrx_done->cnt = cnt;\r\nss->stats.rx_packets += rx_packets;\r\nss->stats.rx_bytes += rx_bytes;\r\nif (ss->rx_small.fill_cnt - ss->rx_small.cnt < myri10ge_fill_thresh)\r\nmyri10ge_alloc_rx_pages(mgp, &ss->rx_small,\r\nmgp->small_bytes + MXGEFW_PAD, 0);\r\nif (ss->rx_big.fill_cnt - ss->rx_big.cnt < myri10ge_fill_thresh)\r\nmyri10ge_alloc_rx_pages(mgp, &ss->rx_big, mgp->big_bytes, 0);\r\nreturn work_done;\r\n}\r\nstatic inline void myri10ge_check_statblock(struct myri10ge_priv *mgp)\r\n{\r\nstruct mcp_irq_data *stats = mgp->ss[0].fw_stats;\r\nif (unlikely(stats->stats_updated)) {\r\nunsigned link_up = ntohl(stats->link_up);\r\nif (mgp->link_state != link_up) {\r\nmgp->link_state = link_up;\r\nif (mgp->link_state == MXGEFW_LINK_UP) {\r\nnetif_info(mgp, link, mgp->dev, "link up\n");\r\nnetif_carrier_on(mgp->dev);\r\nmgp->link_changes++;\r\n} else {\r\nnetif_info(mgp, link, mgp->dev, "link %s\n",\r\n(link_up == MXGEFW_LINK_MYRINET ?\r\n"mismatch (Myrinet detected)" :\r\n"down"));\r\nnetif_carrier_off(mgp->dev);\r\nmgp->link_changes++;\r\n}\r\n}\r\nif (mgp->rdma_tags_available !=\r\nntohl(stats->rdma_tags_available)) {\r\nmgp->rdma_tags_available =\r\nntohl(stats->rdma_tags_available);\r\nnetdev_warn(mgp->dev, "RDMA timed out! %d tags left\n",\r\nmgp->rdma_tags_available);\r\n}\r\nmgp->down_cnt += stats->link_down;\r\nif (stats->link_down)\r\nwake_up(&mgp->down_wq);\r\n}\r\n}\r\nstatic int myri10ge_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct myri10ge_slice_state *ss =\r\ncontainer_of(napi, struct myri10ge_slice_state, napi);\r\nint work_done;\r\n#ifdef CONFIG_MYRI10GE_DCA\r\nif (ss->mgp->dca_enabled)\r\nmyri10ge_update_dca(ss);\r\n#endif\r\nwork_done = myri10ge_clean_rx_done(ss, budget);\r\nif (work_done < budget) {\r\nnapi_complete_done(napi, work_done);\r\nput_be32(htonl(3), ss->irq_claim);\r\n}\r\nreturn work_done;\r\n}\r\nstatic irqreturn_t myri10ge_intr(int irq, void *arg)\r\n{\r\nstruct myri10ge_slice_state *ss = arg;\r\nstruct myri10ge_priv *mgp = ss->mgp;\r\nstruct mcp_irq_data *stats = ss->fw_stats;\r\nstruct myri10ge_tx_buf *tx = &ss->tx;\r\nu32 send_done_count;\r\nint i;\r\nif ((mgp->dev->real_num_tx_queues == 1) && (ss != mgp->ss)) {\r\nnapi_schedule(&ss->napi);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (unlikely(!stats->valid))\r\nreturn IRQ_NONE;\r\nif (stats->valid & 1)\r\nnapi_schedule(&ss->napi);\r\nif (!mgp->msi_enabled && !mgp->msix_enabled) {\r\nput_be32(0, mgp->irq_deassert);\r\nif (!myri10ge_deassert_wait)\r\nstats->valid = 0;\r\nmb();\r\n} else\r\nstats->valid = 0;\r\ni = 0;\r\nwhile (1) {\r\ni++;\r\nsend_done_count = ntohl(stats->send_done_count);\r\nif (send_done_count != tx->pkt_done)\r\nmyri10ge_tx_done(ss, (int)send_done_count);\r\nif (unlikely(i > myri10ge_max_irq_loops)) {\r\nnetdev_warn(mgp->dev, "irq stuck?\n");\r\nstats->valid = 0;\r\nschedule_work(&mgp->watchdog_work);\r\n}\r\nif (likely(stats->valid == 0))\r\nbreak;\r\ncpu_relax();\r\nbarrier();\r\n}\r\nif (ss == mgp->ss)\r\nmyri10ge_check_statblock(mgp);\r\nput_be32(htonl(3), ss->irq_claim + 1);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int\r\nmyri10ge_get_link_ksettings(struct net_device *netdev,\r\nstruct ethtool_link_ksettings *cmd)\r\n{\r\nstruct myri10ge_priv *mgp = netdev_priv(netdev);\r\nchar *ptr;\r\nint i;\r\ncmd->base.autoneg = AUTONEG_DISABLE;\r\ncmd->base.speed = SPEED_10000;\r\ncmd->base.duplex = DUPLEX_FULL;\r\nptr = mgp->product_code_string;\r\nif (ptr == NULL) {\r\nnetdev_err(netdev, "Missing product code\n");\r\nreturn 0;\r\n}\r\nfor (i = 0; i < 3; i++, ptr++) {\r\nptr = strchr(ptr, '-');\r\nif (ptr == NULL) {\r\nnetdev_err(netdev, "Invalid product code %s\n",\r\nmgp->product_code_string);\r\nreturn 0;\r\n}\r\n}\r\nif (*ptr == '2')\r\nptr++;\r\nif (*ptr == 'R' || *ptr == 'Q' || *ptr == 'S') {\r\ncmd->base.port = PORT_FIBRE;\r\nethtool_link_ksettings_add_link_mode(cmd, supported, FIBRE);\r\nethtool_link_ksettings_add_link_mode(cmd, advertising, FIBRE);\r\n} else {\r\ncmd->base.port = PORT_OTHER;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nmyri10ge_get_drvinfo(struct net_device *netdev, struct ethtool_drvinfo *info)\r\n{\r\nstruct myri10ge_priv *mgp = netdev_priv(netdev);\r\nstrlcpy(info->driver, "myri10ge", sizeof(info->driver));\r\nstrlcpy(info->version, MYRI10GE_VERSION_STR, sizeof(info->version));\r\nstrlcpy(info->fw_version, mgp->fw_version, sizeof(info->fw_version));\r\nstrlcpy(info->bus_info, pci_name(mgp->pdev), sizeof(info->bus_info));\r\n}\r\nstatic int\r\nmyri10ge_get_coalesce(struct net_device *netdev, struct ethtool_coalesce *coal)\r\n{\r\nstruct myri10ge_priv *mgp = netdev_priv(netdev);\r\ncoal->rx_coalesce_usecs = mgp->intr_coal_delay;\r\nreturn 0;\r\n}\r\nstatic int\r\nmyri10ge_set_coalesce(struct net_device *netdev, struct ethtool_coalesce *coal)\r\n{\r\nstruct myri10ge_priv *mgp = netdev_priv(netdev);\r\nmgp->intr_coal_delay = coal->rx_coalesce_usecs;\r\nput_be32(htonl(mgp->intr_coal_delay), mgp->intr_coal_delay_ptr);\r\nreturn 0;\r\n}\r\nstatic void\r\nmyri10ge_get_pauseparam(struct net_device *netdev,\r\nstruct ethtool_pauseparam *pause)\r\n{\r\nstruct myri10ge_priv *mgp = netdev_priv(netdev);\r\npause->autoneg = 0;\r\npause->rx_pause = mgp->pause;\r\npause->tx_pause = mgp->pause;\r\n}\r\nstatic int\r\nmyri10ge_set_pauseparam(struct net_device *netdev,\r\nstruct ethtool_pauseparam *pause)\r\n{\r\nstruct myri10ge_priv *mgp = netdev_priv(netdev);\r\nif (pause->tx_pause != mgp->pause)\r\nreturn myri10ge_change_pause(mgp, pause->tx_pause);\r\nif (pause->rx_pause != mgp->pause)\r\nreturn myri10ge_change_pause(mgp, pause->rx_pause);\r\nif (pause->autoneg != 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void\r\nmyri10ge_get_ringparam(struct net_device *netdev,\r\nstruct ethtool_ringparam *ring)\r\n{\r\nstruct myri10ge_priv *mgp = netdev_priv(netdev);\r\nring->rx_mini_max_pending = mgp->ss[0].rx_small.mask + 1;\r\nring->rx_max_pending = mgp->ss[0].rx_big.mask + 1;\r\nring->rx_jumbo_max_pending = 0;\r\nring->tx_max_pending = mgp->ss[0].tx.mask + 1;\r\nring->rx_mini_pending = ring->rx_mini_max_pending;\r\nring->rx_pending = ring->rx_max_pending;\r\nring->rx_jumbo_pending = ring->rx_jumbo_max_pending;\r\nring->tx_pending = ring->tx_max_pending;\r\n}\r\nstatic void\r\nmyri10ge_get_strings(struct net_device *netdev, u32 stringset, u8 * data)\r\n{\r\nstruct myri10ge_priv *mgp = netdev_priv(netdev);\r\nint i;\r\nswitch (stringset) {\r\ncase ETH_SS_STATS:\r\nmemcpy(data, *myri10ge_gstrings_main_stats,\r\nsizeof(myri10ge_gstrings_main_stats));\r\ndata += sizeof(myri10ge_gstrings_main_stats);\r\nfor (i = 0; i < mgp->num_slices; i++) {\r\nmemcpy(data, *myri10ge_gstrings_slice_stats,\r\nsizeof(myri10ge_gstrings_slice_stats));\r\ndata += sizeof(myri10ge_gstrings_slice_stats);\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic int myri10ge_get_sset_count(struct net_device *netdev, int sset)\r\n{\r\nstruct myri10ge_priv *mgp = netdev_priv(netdev);\r\nswitch (sset) {\r\ncase ETH_SS_STATS:\r\nreturn MYRI10GE_MAIN_STATS_LEN +\r\nmgp->num_slices * MYRI10GE_SLICE_STATS_LEN;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic void\r\nmyri10ge_get_ethtool_stats(struct net_device *netdev,\r\nstruct ethtool_stats *stats, u64 * data)\r\n{\r\nstruct myri10ge_priv *mgp = netdev_priv(netdev);\r\nstruct myri10ge_slice_state *ss;\r\nstruct rtnl_link_stats64 link_stats;\r\nint slice;\r\nint i;\r\nmemset(&link_stats, 0, sizeof(link_stats));\r\n(void)myri10ge_get_stats(netdev, &link_stats);\r\nfor (i = 0; i < MYRI10GE_NET_STATS_LEN; i++)\r\ndata[i] = ((u64 *)&link_stats)[i];\r\ndata[i++] = (unsigned int)mgp->tx_boundary;\r\ndata[i++] = (unsigned int)mgp->pdev->irq;\r\ndata[i++] = (unsigned int)mgp->msi_enabled;\r\ndata[i++] = (unsigned int)mgp->msix_enabled;\r\ndata[i++] = (unsigned int)mgp->read_dma;\r\ndata[i++] = (unsigned int)mgp->write_dma;\r\ndata[i++] = (unsigned int)mgp->read_write_dma;\r\ndata[i++] = (unsigned int)mgp->serial_number;\r\ndata[i++] = (unsigned int)mgp->watchdog_resets;\r\n#ifdef CONFIG_MYRI10GE_DCA\r\ndata[i++] = (unsigned int)(mgp->ss[0].dca_tag != NULL);\r\ndata[i++] = (unsigned int)(mgp->dca_enabled);\r\n#endif\r\ndata[i++] = (unsigned int)mgp->link_changes;\r\nss = &mgp->ss[0];\r\ndata[i++] = (unsigned int)ntohl(ss->fw_stats->link_up);\r\ndata[i++] = (unsigned int)ntohl(ss->fw_stats->dropped_link_overflow);\r\ndata[i++] =\r\n(unsigned int)ntohl(ss->fw_stats->dropped_link_error_or_filtered);\r\ndata[i++] = (unsigned int)ntohl(ss->fw_stats->dropped_pause);\r\ndata[i++] = (unsigned int)ntohl(ss->fw_stats->dropped_bad_phy);\r\ndata[i++] = (unsigned int)ntohl(ss->fw_stats->dropped_bad_crc32);\r\ndata[i++] = (unsigned int)ntohl(ss->fw_stats->dropped_unicast_filtered);\r\ndata[i++] =\r\n(unsigned int)ntohl(ss->fw_stats->dropped_multicast_filtered);\r\ndata[i++] = (unsigned int)ntohl(ss->fw_stats->dropped_runt);\r\ndata[i++] = (unsigned int)ntohl(ss->fw_stats->dropped_overrun);\r\ndata[i++] = (unsigned int)ntohl(ss->fw_stats->dropped_no_small_buffer);\r\ndata[i++] = (unsigned int)ntohl(ss->fw_stats->dropped_no_big_buffer);\r\nfor (slice = 0; slice < mgp->num_slices; slice++) {\r\nss = &mgp->ss[slice];\r\ndata[i++] = slice;\r\ndata[i++] = (unsigned int)ss->tx.pkt_start;\r\ndata[i++] = (unsigned int)ss->tx.pkt_done;\r\ndata[i++] = (unsigned int)ss->tx.req;\r\ndata[i++] = (unsigned int)ss->tx.done;\r\ndata[i++] = (unsigned int)ss->rx_small.cnt;\r\ndata[i++] = (unsigned int)ss->rx_big.cnt;\r\ndata[i++] = (unsigned int)ss->tx.wake_queue;\r\ndata[i++] = (unsigned int)ss->tx.stop_queue;\r\ndata[i++] = (unsigned int)ss->tx.linearized;\r\n}\r\n}\r\nstatic void myri10ge_set_msglevel(struct net_device *netdev, u32 value)\r\n{\r\nstruct myri10ge_priv *mgp = netdev_priv(netdev);\r\nmgp->msg_enable = value;\r\n}\r\nstatic u32 myri10ge_get_msglevel(struct net_device *netdev)\r\n{\r\nstruct myri10ge_priv *mgp = netdev_priv(netdev);\r\nreturn mgp->msg_enable;\r\n}\r\nstatic int myri10ge_led(struct myri10ge_priv *mgp, int on)\r\n{\r\nstruct mcp_gen_header *hdr;\r\nstruct device *dev = &mgp->pdev->dev;\r\nsize_t hdr_off, pattern_off, hdr_len;\r\nu32 pattern = 0xfffffffe;\r\nhdr_off = swab32(readl(mgp->sram + MCP_HEADER_PTR_OFFSET));\r\nif ((hdr_off & 3) || hdr_off + sizeof(*hdr) > mgp->sram_size) {\r\ndev_err(dev, "Running firmware has bad header offset (%d)\n",\r\n(int)hdr_off);\r\nreturn -EIO;\r\n}\r\nhdr_len = swab32(readl(mgp->sram + hdr_off +\r\noffsetof(struct mcp_gen_header, header_length)));\r\npattern_off = hdr_off + offsetof(struct mcp_gen_header, led_pattern);\r\nif (pattern_off >= (hdr_len + hdr_off)) {\r\ndev_info(dev, "Firmware does not support LED identification\n");\r\nreturn -EINVAL;\r\n}\r\nif (!on)\r\npattern = swab32(readl(mgp->sram + pattern_off + 4));\r\nwritel(swab32(pattern), mgp->sram + pattern_off);\r\nreturn 0;\r\n}\r\nstatic int\r\nmyri10ge_phys_id(struct net_device *netdev, enum ethtool_phys_id_state state)\r\n{\r\nstruct myri10ge_priv *mgp = netdev_priv(netdev);\r\nint rc;\r\nswitch (state) {\r\ncase ETHTOOL_ID_ACTIVE:\r\nrc = myri10ge_led(mgp, 1);\r\nbreak;\r\ncase ETHTOOL_ID_INACTIVE:\r\nrc = myri10ge_led(mgp, 0);\r\nbreak;\r\ndefault:\r\nrc = -EINVAL;\r\n}\r\nreturn rc;\r\n}\r\nstatic int myri10ge_allocate_rings(struct myri10ge_slice_state *ss)\r\n{\r\nstruct myri10ge_priv *mgp = ss->mgp;\r\nstruct myri10ge_cmd cmd;\r\nstruct net_device *dev = mgp->dev;\r\nint tx_ring_size, rx_ring_size;\r\nint tx_ring_entries, rx_ring_entries;\r\nint i, slice, status;\r\nsize_t bytes;\r\nslice = ss - mgp->ss;\r\ncmd.data0 = slice;\r\nstatus = myri10ge_send_cmd(mgp, MXGEFW_CMD_GET_SEND_RING_SIZE, &cmd, 0);\r\ntx_ring_size = cmd.data0;\r\ncmd.data0 = slice;\r\nstatus |= myri10ge_send_cmd(mgp, MXGEFW_CMD_GET_RX_RING_SIZE, &cmd, 0);\r\nif (status != 0)\r\nreturn status;\r\nrx_ring_size = cmd.data0;\r\ntx_ring_entries = tx_ring_size / sizeof(struct mcp_kreq_ether_send);\r\nrx_ring_entries = rx_ring_size / sizeof(struct mcp_dma_addr);\r\nss->tx.mask = tx_ring_entries - 1;\r\nss->rx_small.mask = ss->rx_big.mask = rx_ring_entries - 1;\r\nstatus = -ENOMEM;\r\nbytes = 8 + (MYRI10GE_MAX_SEND_DESC_TSO + 4)\r\n* sizeof(*ss->tx.req_list);\r\nss->tx.req_bytes = kzalloc(bytes, GFP_KERNEL);\r\nif (ss->tx.req_bytes == NULL)\r\ngoto abort_with_nothing;\r\nss->tx.req_list = (struct mcp_kreq_ether_send *)\r\nALIGN((unsigned long)ss->tx.req_bytes, 8);\r\nss->tx.queue_active = 0;\r\nbytes = rx_ring_entries * sizeof(*ss->rx_small.shadow);\r\nss->rx_small.shadow = kzalloc(bytes, GFP_KERNEL);\r\nif (ss->rx_small.shadow == NULL)\r\ngoto abort_with_tx_req_bytes;\r\nbytes = rx_ring_entries * sizeof(*ss->rx_big.shadow);\r\nss->rx_big.shadow = kzalloc(bytes, GFP_KERNEL);\r\nif (ss->rx_big.shadow == NULL)\r\ngoto abort_with_rx_small_shadow;\r\nbytes = tx_ring_entries * sizeof(*ss->tx.info);\r\nss->tx.info = kzalloc(bytes, GFP_KERNEL);\r\nif (ss->tx.info == NULL)\r\ngoto abort_with_rx_big_shadow;\r\nbytes = rx_ring_entries * sizeof(*ss->rx_small.info);\r\nss->rx_small.info = kzalloc(bytes, GFP_KERNEL);\r\nif (ss->rx_small.info == NULL)\r\ngoto abort_with_tx_info;\r\nbytes = rx_ring_entries * sizeof(*ss->rx_big.info);\r\nss->rx_big.info = kzalloc(bytes, GFP_KERNEL);\r\nif (ss->rx_big.info == NULL)\r\ngoto abort_with_rx_small_info;\r\nss->rx_big.cnt = 0;\r\nss->rx_small.cnt = 0;\r\nss->rx_big.fill_cnt = 0;\r\nss->rx_small.fill_cnt = 0;\r\nss->rx_small.page_offset = MYRI10GE_ALLOC_SIZE;\r\nss->rx_big.page_offset = MYRI10GE_ALLOC_SIZE;\r\nss->rx_small.watchdog_needed = 0;\r\nss->rx_big.watchdog_needed = 0;\r\nif (mgp->small_bytes == 0) {\r\nss->rx_small.fill_cnt = ss->rx_small.mask + 1;\r\n} else {\r\nmyri10ge_alloc_rx_pages(mgp, &ss->rx_small,\r\nmgp->small_bytes + MXGEFW_PAD, 0);\r\n}\r\nif (ss->rx_small.fill_cnt < ss->rx_small.mask + 1) {\r\nnetdev_err(dev, "slice-%d: alloced only %d small bufs\n",\r\nslice, ss->rx_small.fill_cnt);\r\ngoto abort_with_rx_small_ring;\r\n}\r\nmyri10ge_alloc_rx_pages(mgp, &ss->rx_big, mgp->big_bytes, 0);\r\nif (ss->rx_big.fill_cnt < ss->rx_big.mask + 1) {\r\nnetdev_err(dev, "slice-%d: alloced only %d big bufs\n",\r\nslice, ss->rx_big.fill_cnt);\r\ngoto abort_with_rx_big_ring;\r\n}\r\nreturn 0;\r\nabort_with_rx_big_ring:\r\nfor (i = ss->rx_big.cnt; i < ss->rx_big.fill_cnt; i++) {\r\nint idx = i & ss->rx_big.mask;\r\nmyri10ge_unmap_rx_page(mgp->pdev, &ss->rx_big.info[idx],\r\nmgp->big_bytes);\r\nput_page(ss->rx_big.info[idx].page);\r\n}\r\nabort_with_rx_small_ring:\r\nif (mgp->small_bytes == 0)\r\nss->rx_small.fill_cnt = ss->rx_small.cnt;\r\nfor (i = ss->rx_small.cnt; i < ss->rx_small.fill_cnt; i++) {\r\nint idx = i & ss->rx_small.mask;\r\nmyri10ge_unmap_rx_page(mgp->pdev, &ss->rx_small.info[idx],\r\nmgp->small_bytes + MXGEFW_PAD);\r\nput_page(ss->rx_small.info[idx].page);\r\n}\r\nkfree(ss->rx_big.info);\r\nabort_with_rx_small_info:\r\nkfree(ss->rx_small.info);\r\nabort_with_tx_info:\r\nkfree(ss->tx.info);\r\nabort_with_rx_big_shadow:\r\nkfree(ss->rx_big.shadow);\r\nabort_with_rx_small_shadow:\r\nkfree(ss->rx_small.shadow);\r\nabort_with_tx_req_bytes:\r\nkfree(ss->tx.req_bytes);\r\nss->tx.req_bytes = NULL;\r\nss->tx.req_list = NULL;\r\nabort_with_nothing:\r\nreturn status;\r\n}\r\nstatic void myri10ge_free_rings(struct myri10ge_slice_state *ss)\r\n{\r\nstruct myri10ge_priv *mgp = ss->mgp;\r\nstruct sk_buff *skb;\r\nstruct myri10ge_tx_buf *tx;\r\nint i, len, idx;\r\nif (ss->tx.req_list == NULL)\r\nreturn;\r\nfor (i = ss->rx_big.cnt; i < ss->rx_big.fill_cnt; i++) {\r\nidx = i & ss->rx_big.mask;\r\nif (i == ss->rx_big.fill_cnt - 1)\r\nss->rx_big.info[idx].page_offset = MYRI10GE_ALLOC_SIZE;\r\nmyri10ge_unmap_rx_page(mgp->pdev, &ss->rx_big.info[idx],\r\nmgp->big_bytes);\r\nput_page(ss->rx_big.info[idx].page);\r\n}\r\nif (mgp->small_bytes == 0)\r\nss->rx_small.fill_cnt = ss->rx_small.cnt;\r\nfor (i = ss->rx_small.cnt; i < ss->rx_small.fill_cnt; i++) {\r\nidx = i & ss->rx_small.mask;\r\nif (i == ss->rx_small.fill_cnt - 1)\r\nss->rx_small.info[idx].page_offset =\r\nMYRI10GE_ALLOC_SIZE;\r\nmyri10ge_unmap_rx_page(mgp->pdev, &ss->rx_small.info[idx],\r\nmgp->small_bytes + MXGEFW_PAD);\r\nput_page(ss->rx_small.info[idx].page);\r\n}\r\ntx = &ss->tx;\r\nwhile (tx->done != tx->req) {\r\nidx = tx->done & tx->mask;\r\nskb = tx->info[idx].skb;\r\ntx->info[idx].skb = NULL;\r\ntx->done++;\r\nlen = dma_unmap_len(&tx->info[idx], len);\r\ndma_unmap_len_set(&tx->info[idx], len, 0);\r\nif (skb) {\r\nss->stats.tx_dropped++;\r\ndev_kfree_skb_any(skb);\r\nif (len)\r\npci_unmap_single(mgp->pdev,\r\ndma_unmap_addr(&tx->info[idx],\r\nbus), len,\r\nPCI_DMA_TODEVICE);\r\n} else {\r\nif (len)\r\npci_unmap_page(mgp->pdev,\r\ndma_unmap_addr(&tx->info[idx],\r\nbus), len,\r\nPCI_DMA_TODEVICE);\r\n}\r\n}\r\nkfree(ss->rx_big.info);\r\nkfree(ss->rx_small.info);\r\nkfree(ss->tx.info);\r\nkfree(ss->rx_big.shadow);\r\nkfree(ss->rx_small.shadow);\r\nkfree(ss->tx.req_bytes);\r\nss->tx.req_bytes = NULL;\r\nss->tx.req_list = NULL;\r\n}\r\nstatic int myri10ge_request_irq(struct myri10ge_priv *mgp)\r\n{\r\nstruct pci_dev *pdev = mgp->pdev;\r\nstruct myri10ge_slice_state *ss;\r\nstruct net_device *netdev = mgp->dev;\r\nint i;\r\nint status;\r\nmgp->msi_enabled = 0;\r\nmgp->msix_enabled = 0;\r\nstatus = 0;\r\nif (myri10ge_msi) {\r\nif (mgp->num_slices > 1) {\r\nstatus = pci_enable_msix_range(pdev, mgp->msix_vectors,\r\nmgp->num_slices, mgp->num_slices);\r\nif (status < 0) {\r\ndev_err(&pdev->dev,\r\n"Error %d setting up MSI-X\n", status);\r\nreturn status;\r\n}\r\nmgp->msix_enabled = 1;\r\n}\r\nif (mgp->msix_enabled == 0) {\r\nstatus = pci_enable_msi(pdev);\r\nif (status != 0) {\r\ndev_err(&pdev->dev,\r\n"Error %d setting up MSI; falling back to xPIC\n",\r\nstatus);\r\n} else {\r\nmgp->msi_enabled = 1;\r\n}\r\n}\r\n}\r\nif (mgp->msix_enabled) {\r\nfor (i = 0; i < mgp->num_slices; i++) {\r\nss = &mgp->ss[i];\r\nsnprintf(ss->irq_desc, sizeof(ss->irq_desc),\r\n"%s:slice-%d", netdev->name, i);\r\nstatus = request_irq(mgp->msix_vectors[i].vector,\r\nmyri10ge_intr, 0, ss->irq_desc,\r\nss);\r\nif (status != 0) {\r\ndev_err(&pdev->dev,\r\n"slice %d failed to allocate IRQ\n", i);\r\ni--;\r\nwhile (i >= 0) {\r\nfree_irq(mgp->msix_vectors[i].vector,\r\n&mgp->ss[i]);\r\ni--;\r\n}\r\npci_disable_msix(pdev);\r\nreturn status;\r\n}\r\n}\r\n} else {\r\nstatus = request_irq(pdev->irq, myri10ge_intr, IRQF_SHARED,\r\nmgp->dev->name, &mgp->ss[0]);\r\nif (status != 0) {\r\ndev_err(&pdev->dev, "failed to allocate IRQ\n");\r\nif (mgp->msi_enabled)\r\npci_disable_msi(pdev);\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic void myri10ge_free_irq(struct myri10ge_priv *mgp)\r\n{\r\nstruct pci_dev *pdev = mgp->pdev;\r\nint i;\r\nif (mgp->msix_enabled) {\r\nfor (i = 0; i < mgp->num_slices; i++)\r\nfree_irq(mgp->msix_vectors[i].vector, &mgp->ss[i]);\r\n} else {\r\nfree_irq(pdev->irq, &mgp->ss[0]);\r\n}\r\nif (mgp->msi_enabled)\r\npci_disable_msi(pdev);\r\nif (mgp->msix_enabled)\r\npci_disable_msix(pdev);\r\n}\r\nstatic int myri10ge_get_txrx(struct myri10ge_priv *mgp, int slice)\r\n{\r\nstruct myri10ge_cmd cmd;\r\nstruct myri10ge_slice_state *ss;\r\nint status;\r\nss = &mgp->ss[slice];\r\nstatus = 0;\r\nif (slice == 0 || (mgp->dev->real_num_tx_queues > 1)) {\r\ncmd.data0 = slice;\r\nstatus = myri10ge_send_cmd(mgp, MXGEFW_CMD_GET_SEND_OFFSET,\r\n&cmd, 0);\r\nss->tx.lanai = (struct mcp_kreq_ether_send __iomem *)\r\n(mgp->sram + cmd.data0);\r\n}\r\ncmd.data0 = slice;\r\nstatus |= myri10ge_send_cmd(mgp, MXGEFW_CMD_GET_SMALL_RX_OFFSET,\r\n&cmd, 0);\r\nss->rx_small.lanai = (struct mcp_kreq_ether_recv __iomem *)\r\n(mgp->sram + cmd.data0);\r\ncmd.data0 = slice;\r\nstatus |= myri10ge_send_cmd(mgp, MXGEFW_CMD_GET_BIG_RX_OFFSET, &cmd, 0);\r\nss->rx_big.lanai = (struct mcp_kreq_ether_recv __iomem *)\r\n(mgp->sram + cmd.data0);\r\nss->tx.send_go = (__iomem __be32 *)\r\n(mgp->sram + MXGEFW_ETH_SEND_GO + 64 * slice);\r\nss->tx.send_stop = (__iomem __be32 *)\r\n(mgp->sram + MXGEFW_ETH_SEND_STOP + 64 * slice);\r\nreturn status;\r\n}\r\nstatic int myri10ge_set_stats(struct myri10ge_priv *mgp, int slice)\r\n{\r\nstruct myri10ge_cmd cmd;\r\nstruct myri10ge_slice_state *ss;\r\nint status;\r\nss = &mgp->ss[slice];\r\ncmd.data0 = MYRI10GE_LOWPART_TO_U32(ss->fw_stats_bus);\r\ncmd.data1 = MYRI10GE_HIGHPART_TO_U32(ss->fw_stats_bus);\r\ncmd.data2 = sizeof(struct mcp_irq_data) | (slice << 16);\r\nstatus = myri10ge_send_cmd(mgp, MXGEFW_CMD_SET_STATS_DMA_V2, &cmd, 0);\r\nif (status == -ENOSYS) {\r\ndma_addr_t bus = ss->fw_stats_bus;\r\nif (slice != 0)\r\nreturn -EINVAL;\r\nbus += offsetof(struct mcp_irq_data, send_done_count);\r\ncmd.data0 = MYRI10GE_LOWPART_TO_U32(bus);\r\ncmd.data1 = MYRI10GE_HIGHPART_TO_U32(bus);\r\nstatus = myri10ge_send_cmd(mgp,\r\nMXGEFW_CMD_SET_STATS_DMA_OBSOLETE,\r\n&cmd, 0);\r\nmgp->fw_multicast_support = 0;\r\n} else {\r\nmgp->fw_multicast_support = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int myri10ge_open(struct net_device *dev)\r\n{\r\nstruct myri10ge_slice_state *ss;\r\nstruct myri10ge_priv *mgp = netdev_priv(dev);\r\nstruct myri10ge_cmd cmd;\r\nint i, status, big_pow2, slice;\r\nu8 __iomem *itable;\r\nif (mgp->running != MYRI10GE_ETH_STOPPED)\r\nreturn -EBUSY;\r\nmgp->running = MYRI10GE_ETH_STARTING;\r\nstatus = myri10ge_reset(mgp);\r\nif (status != 0) {\r\nnetdev_err(dev, "failed reset\n");\r\ngoto abort_with_nothing;\r\n}\r\nif (mgp->num_slices > 1) {\r\ncmd.data0 = mgp->num_slices;\r\ncmd.data1 = MXGEFW_SLICE_INTR_MODE_ONE_PER_SLICE;\r\nif (mgp->dev->real_num_tx_queues > 1)\r\ncmd.data1 |= MXGEFW_SLICE_ENABLE_MULTIPLE_TX_QUEUES;\r\nstatus = myri10ge_send_cmd(mgp, MXGEFW_CMD_ENABLE_RSS_QUEUES,\r\n&cmd, 0);\r\nif (status != 0) {\r\nnetdev_err(dev, "failed to set number of slices\n");\r\ngoto abort_with_nothing;\r\n}\r\ncmd.data0 = mgp->num_slices;\r\nstatus = myri10ge_send_cmd(mgp, MXGEFW_CMD_SET_RSS_TABLE_SIZE,\r\n&cmd, 0);\r\nstatus |= myri10ge_send_cmd(mgp,\r\nMXGEFW_CMD_GET_RSS_TABLE_OFFSET,\r\n&cmd, 0);\r\nif (status != 0) {\r\nnetdev_err(dev, "failed to setup rss tables\n");\r\ngoto abort_with_nothing;\r\n}\r\nitable = mgp->sram + cmd.data0;\r\nfor (i = 0; i < mgp->num_slices; i++)\r\n__raw_writeb(i, &itable[i]);\r\ncmd.data0 = 1;\r\ncmd.data1 = myri10ge_rss_hash;\r\nstatus = myri10ge_send_cmd(mgp, MXGEFW_CMD_SET_RSS_ENABLE,\r\n&cmd, 0);\r\nif (status != 0) {\r\nnetdev_err(dev, "failed to enable slices\n");\r\ngoto abort_with_nothing;\r\n}\r\n}\r\nstatus = myri10ge_request_irq(mgp);\r\nif (status != 0)\r\ngoto abort_with_nothing;\r\nif (dev->mtu <= ETH_DATA_LEN)\r\nmgp->small_bytes = (128 > SMP_CACHE_BYTES)\r\n? (128 - MXGEFW_PAD)\r\n: (SMP_CACHE_BYTES - MXGEFW_PAD);\r\nelse\r\nmgp->small_bytes = VLAN_ETH_FRAME_LEN;\r\nif (myri10ge_small_bytes >= 0)\r\nmgp->small_bytes = myri10ge_small_bytes;\r\nbig_pow2 = dev->mtu + ETH_HLEN + VLAN_HLEN + MXGEFW_PAD;\r\nif (big_pow2 < MYRI10GE_ALLOC_SIZE / 2) {\r\nwhile (!is_power_of_2(big_pow2))\r\nbig_pow2++;\r\nmgp->big_bytes = dev->mtu + ETH_HLEN + VLAN_HLEN + MXGEFW_PAD;\r\n} else {\r\nbig_pow2 = MYRI10GE_ALLOC_SIZE;\r\nmgp->big_bytes = big_pow2;\r\n}\r\nfor (slice = 0; slice < mgp->num_slices; slice++) {\r\nss = &mgp->ss[slice];\r\nstatus = myri10ge_get_txrx(mgp, slice);\r\nif (status != 0) {\r\nnetdev_err(dev, "failed to get ring sizes or locations\n");\r\ngoto abort_with_rings;\r\n}\r\nstatus = myri10ge_allocate_rings(ss);\r\nif (status != 0)\r\ngoto abort_with_rings;\r\nif (slice == 0 || mgp->dev->real_num_tx_queues > 1)\r\nstatus = myri10ge_set_stats(mgp, slice);\r\nif (status) {\r\nnetdev_err(dev, "Couldn't set stats DMA\n");\r\ngoto abort_with_rings;\r\n}\r\nnapi_enable(&(ss)->napi);\r\n}\r\ncmd.data0 = dev->mtu + ETH_HLEN + VLAN_HLEN;\r\nstatus = myri10ge_send_cmd(mgp, MXGEFW_CMD_SET_MTU, &cmd, 0);\r\ncmd.data0 = mgp->small_bytes;\r\nstatus |=\r\nmyri10ge_send_cmd(mgp, MXGEFW_CMD_SET_SMALL_BUFFER_SIZE, &cmd, 0);\r\ncmd.data0 = big_pow2;\r\nstatus |=\r\nmyri10ge_send_cmd(mgp, MXGEFW_CMD_SET_BIG_BUFFER_SIZE, &cmd, 0);\r\nif (status) {\r\nnetdev_err(dev, "Couldn't set buffer sizes\n");\r\ngoto abort_with_rings;\r\n}\r\ncmd.data0 = 0;\r\nstatus = myri10ge_send_cmd(mgp, MXGEFW_CMD_SET_TSO_MODE, &cmd, 0);\r\nif (status && status != -ENOSYS) {\r\nnetdev_err(dev, "Couldn't set TSO mode\n");\r\ngoto abort_with_rings;\r\n}\r\nmgp->link_state = ~0U;\r\nmgp->rdma_tags_available = 15;\r\nstatus = myri10ge_send_cmd(mgp, MXGEFW_CMD_ETHERNET_UP, &cmd, 0);\r\nif (status) {\r\nnetdev_err(dev, "Couldn't bring up link\n");\r\ngoto abort_with_rings;\r\n}\r\nmgp->running = MYRI10GE_ETH_RUNNING;\r\nmgp->watchdog_timer.expires = jiffies + myri10ge_watchdog_timeout * HZ;\r\nadd_timer(&mgp->watchdog_timer);\r\nnetif_tx_wake_all_queues(dev);\r\nreturn 0;\r\nabort_with_rings:\r\nwhile (slice) {\r\nslice--;\r\nnapi_disable(&mgp->ss[slice].napi);\r\n}\r\nfor (i = 0; i < mgp->num_slices; i++)\r\nmyri10ge_free_rings(&mgp->ss[i]);\r\nmyri10ge_free_irq(mgp);\r\nabort_with_nothing:\r\nmgp->running = MYRI10GE_ETH_STOPPED;\r\nreturn -ENOMEM;\r\n}\r\nstatic int myri10ge_close(struct net_device *dev)\r\n{\r\nstruct myri10ge_priv *mgp = netdev_priv(dev);\r\nstruct myri10ge_cmd cmd;\r\nint status, old_down_cnt;\r\nint i;\r\nif (mgp->running != MYRI10GE_ETH_RUNNING)\r\nreturn 0;\r\nif (mgp->ss[0].tx.req_bytes == NULL)\r\nreturn 0;\r\ndel_timer_sync(&mgp->watchdog_timer);\r\nmgp->running = MYRI10GE_ETH_STOPPING;\r\nfor (i = 0; i < mgp->num_slices; i++)\r\nnapi_disable(&mgp->ss[i].napi);\r\nnetif_carrier_off(dev);\r\nnetif_tx_stop_all_queues(dev);\r\nif (mgp->rebooted == 0) {\r\nold_down_cnt = mgp->down_cnt;\r\nmb();\r\nstatus =\r\nmyri10ge_send_cmd(mgp, MXGEFW_CMD_ETHERNET_DOWN, &cmd, 0);\r\nif (status)\r\nnetdev_err(dev, "Couldn't bring down link\n");\r\nwait_event_timeout(mgp->down_wq, old_down_cnt != mgp->down_cnt,\r\nHZ);\r\nif (old_down_cnt == mgp->down_cnt)\r\nnetdev_err(dev, "never got down irq\n");\r\n}\r\nnetif_tx_disable(dev);\r\nmyri10ge_free_irq(mgp);\r\nfor (i = 0; i < mgp->num_slices; i++)\r\nmyri10ge_free_rings(&mgp->ss[i]);\r\nmgp->running = MYRI10GE_ETH_STOPPED;\r\nreturn 0;\r\n}\r\nstatic inline void\r\nmyri10ge_submit_req_backwards(struct myri10ge_tx_buf *tx,\r\nstruct mcp_kreq_ether_send *src, int cnt)\r\n{\r\nint idx, starting_slot;\r\nstarting_slot = tx->req;\r\nwhile (cnt > 1) {\r\ncnt--;\r\nidx = (starting_slot + cnt) & tx->mask;\r\nmyri10ge_pio_copy(&tx->lanai[idx], &src[cnt], sizeof(*src));\r\nmb();\r\n}\r\n}\r\nstatic inline void\r\nmyri10ge_submit_req(struct myri10ge_tx_buf *tx, struct mcp_kreq_ether_send *src,\r\nint cnt)\r\n{\r\nint idx, i;\r\nstruct mcp_kreq_ether_send __iomem *dstp, *dst;\r\nstruct mcp_kreq_ether_send *srcp;\r\nu8 last_flags;\r\nidx = tx->req & tx->mask;\r\nlast_flags = src->flags;\r\nsrc->flags = 0;\r\nmb();\r\ndst = dstp = &tx->lanai[idx];\r\nsrcp = src;\r\nif ((idx + cnt) < tx->mask) {\r\nfor (i = 0; i < (cnt - 1); i += 2) {\r\nmyri10ge_pio_copy(dstp, srcp, 2 * sizeof(*src));\r\nmb();\r\nsrcp += 2;\r\ndstp += 2;\r\n}\r\n} else {\r\nmyri10ge_submit_req_backwards(tx, src, cnt);\r\ni = 0;\r\n}\r\nif (i < cnt) {\r\nmyri10ge_pio_copy(dstp, srcp, sizeof(*src));\r\nmb();\r\n}\r\nsrc->flags = last_flags;\r\nput_be32(*((__be32 *) src + 3), (__be32 __iomem *) dst + 3);\r\ntx->req += cnt;\r\nmb();\r\n}\r\nstatic void myri10ge_unmap_tx_dma(struct myri10ge_priv *mgp,\r\nstruct myri10ge_tx_buf *tx, int idx)\r\n{\r\nunsigned int len;\r\nint last_idx;\r\nlast_idx = (idx + 1) & tx->mask;\r\nidx = tx->req & tx->mask;\r\ndo {\r\nlen = dma_unmap_len(&tx->info[idx], len);\r\nif (len) {\r\nif (tx->info[idx].skb != NULL)\r\npci_unmap_single(mgp->pdev,\r\ndma_unmap_addr(&tx->info[idx],\r\nbus), len,\r\nPCI_DMA_TODEVICE);\r\nelse\r\npci_unmap_page(mgp->pdev,\r\ndma_unmap_addr(&tx->info[idx],\r\nbus), len,\r\nPCI_DMA_TODEVICE);\r\ndma_unmap_len_set(&tx->info[idx], len, 0);\r\ntx->info[idx].skb = NULL;\r\n}\r\nidx = (idx + 1) & tx->mask;\r\n} while (idx != last_idx);\r\n}\r\nstatic netdev_tx_t myri10ge_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct myri10ge_priv *mgp = netdev_priv(dev);\r\nstruct myri10ge_slice_state *ss;\r\nstruct mcp_kreq_ether_send *req;\r\nstruct myri10ge_tx_buf *tx;\r\nstruct skb_frag_struct *frag;\r\nstruct netdev_queue *netdev_queue;\r\ndma_addr_t bus;\r\nu32 low;\r\n__be32 high_swapped;\r\nunsigned int len;\r\nint idx, avail, frag_cnt, frag_idx, count, mss, max_segments;\r\nu16 pseudo_hdr_offset, cksum_offset, queue;\r\nint cum_len, seglen, boundary, rdma_count;\r\nu8 flags, odd_flag;\r\nqueue = skb_get_queue_mapping(skb);\r\nss = &mgp->ss[queue];\r\nnetdev_queue = netdev_get_tx_queue(mgp->dev, queue);\r\ntx = &ss->tx;\r\nagain:\r\nreq = tx->req_list;\r\navail = tx->mask - 1 - (tx->req - tx->done);\r\nmss = 0;\r\nmax_segments = MXGEFW_MAX_SEND_DESC;\r\nif (skb_is_gso(skb)) {\r\nmss = skb_shinfo(skb)->gso_size;\r\nmax_segments = MYRI10GE_MAX_SEND_DESC_TSO;\r\n}\r\nif ((unlikely(avail < max_segments))) {\r\ntx->stop_queue++;\r\nnetif_tx_stop_queue(netdev_queue);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\ncksum_offset = 0;\r\npseudo_hdr_offset = 0;\r\nodd_flag = 0;\r\nflags = (MXGEFW_FLAGS_NO_TSO | MXGEFW_FLAGS_FIRST);\r\nif (likely(skb->ip_summed == CHECKSUM_PARTIAL)) {\r\ncksum_offset = skb_checksum_start_offset(skb);\r\npseudo_hdr_offset = cksum_offset + skb->csum_offset;\r\nif (unlikely(!mss && (cksum_offset > 255 ||\r\npseudo_hdr_offset > 127))) {\r\nif (skb_checksum_help(skb))\r\ngoto drop;\r\ncksum_offset = 0;\r\npseudo_hdr_offset = 0;\r\n} else {\r\nodd_flag = MXGEFW_FLAGS_ALIGN_ODD;\r\nflags |= MXGEFW_FLAGS_CKSUM;\r\n}\r\n}\r\ncum_len = 0;\r\nif (mss) {\r\nflags = (MXGEFW_FLAGS_TSO_HDR | MXGEFW_FLAGS_FIRST);\r\ncum_len = -(skb_transport_offset(skb) + tcp_hdrlen(skb));\r\nif (skb_is_gso_v6(skb)) {\r\ncksum_offset = tcp_hdrlen(skb);\r\nif (unlikely(-cum_len > mgp->max_tso6))\r\nreturn myri10ge_sw_tso(skb, dev);\r\n}\r\npseudo_hdr_offset = mss;\r\n} else\r\nif (skb->len <= MXGEFW_SEND_SMALL_SIZE) {\r\nflags |= MXGEFW_FLAGS_SMALL;\r\nif (eth_skb_pad(skb)) {\r\nss->stats.tx_dropped += 1;\r\nreturn NETDEV_TX_OK;\r\n}\r\n}\r\nlen = skb_headlen(skb);\r\nbus = pci_map_single(mgp->pdev, skb->data, len, PCI_DMA_TODEVICE);\r\nif (unlikely(pci_dma_mapping_error(mgp->pdev, bus)))\r\ngoto drop;\r\nidx = tx->req & tx->mask;\r\ntx->info[idx].skb = skb;\r\ndma_unmap_addr_set(&tx->info[idx], bus, bus);\r\ndma_unmap_len_set(&tx->info[idx], len, len);\r\nfrag_cnt = skb_shinfo(skb)->nr_frags;\r\nfrag_idx = 0;\r\ncount = 0;\r\nrdma_count = 0;\r\nwhile (1) {\r\nlow = MYRI10GE_LOWPART_TO_U32(bus);\r\nhigh_swapped = htonl(MYRI10GE_HIGHPART_TO_U32(bus));\r\nwhile (len) {\r\nu8 flags_next;\r\nint cum_len_next;\r\nif (unlikely(count == max_segments))\r\ngoto abort_linearize;\r\nboundary =\r\n(low + mgp->tx_boundary) & ~(mgp->tx_boundary - 1);\r\nseglen = boundary - low;\r\nif (seglen > len)\r\nseglen = len;\r\nflags_next = flags & ~MXGEFW_FLAGS_FIRST;\r\ncum_len_next = cum_len + seglen;\r\nif (mss) {\r\n(req - rdma_count)->rdma_count = rdma_count + 1;\r\nif (likely(cum_len >= 0)) {\r\nint next_is_first, chop;\r\nchop = (cum_len_next > mss);\r\ncum_len_next = cum_len_next % mss;\r\nnext_is_first = (cum_len_next == 0);\r\nflags |= chop * MXGEFW_FLAGS_TSO_CHOP;\r\nflags_next |= next_is_first *\r\nMXGEFW_FLAGS_FIRST;\r\nrdma_count |= -(chop | next_is_first);\r\nrdma_count += chop & ~next_is_first;\r\n} else if (likely(cum_len_next >= 0)) {\r\nint small;\r\nrdma_count = -1;\r\ncum_len_next = 0;\r\nseglen = -cum_len;\r\nsmall = (mss <= MXGEFW_SEND_SMALL_SIZE);\r\nflags_next = MXGEFW_FLAGS_TSO_PLD |\r\nMXGEFW_FLAGS_FIRST |\r\n(small * MXGEFW_FLAGS_SMALL);\r\n}\r\n}\r\nreq->addr_high = high_swapped;\r\nreq->addr_low = htonl(low);\r\nreq->pseudo_hdr_offset = htons(pseudo_hdr_offset);\r\nreq->pad = 0;\r\nreq->rdma_count = 1;\r\nreq->length = htons(seglen);\r\nreq->cksum_offset = cksum_offset;\r\nreq->flags = flags | ((cum_len & 1) * odd_flag);\r\nlow += seglen;\r\nlen -= seglen;\r\ncum_len = cum_len_next;\r\nflags = flags_next;\r\nreq++;\r\ncount++;\r\nrdma_count++;\r\nif (cksum_offset != 0 && !(mss && skb_is_gso_v6(skb))) {\r\nif (unlikely(cksum_offset > seglen))\r\ncksum_offset -= seglen;\r\nelse\r\ncksum_offset = 0;\r\n}\r\n}\r\nif (frag_idx == frag_cnt)\r\nbreak;\r\nfrag = &skb_shinfo(skb)->frags[frag_idx];\r\nfrag_idx++;\r\nlen = skb_frag_size(frag);\r\nbus = skb_frag_dma_map(&mgp->pdev->dev, frag, 0, len,\r\nDMA_TO_DEVICE);\r\nif (unlikely(pci_dma_mapping_error(mgp->pdev, bus))) {\r\nmyri10ge_unmap_tx_dma(mgp, tx, idx);\r\ngoto drop;\r\n}\r\nidx = (count + tx->req) & tx->mask;\r\ndma_unmap_addr_set(&tx->info[idx], bus, bus);\r\ndma_unmap_len_set(&tx->info[idx], len, len);\r\n}\r\n(req - rdma_count)->rdma_count = rdma_count;\r\nif (mss)\r\ndo {\r\nreq--;\r\nreq->flags |= MXGEFW_FLAGS_TSO_LAST;\r\n} while (!(req->flags & (MXGEFW_FLAGS_TSO_CHOP |\r\nMXGEFW_FLAGS_FIRST)));\r\nidx = ((count - 1) + tx->req) & tx->mask;\r\ntx->info[idx].last = 1;\r\nmyri10ge_submit_req(tx, tx->req_list, count);\r\nif ((mgp->dev->real_num_tx_queues > 1) && tx->queue_active == 0) {\r\ntx->queue_active = 1;\r\nput_be32(htonl(1), tx->send_go);\r\nmb();\r\nmmiowb();\r\n}\r\ntx->pkt_start++;\r\nif ((avail - count) < MXGEFW_MAX_SEND_DESC) {\r\ntx->stop_queue++;\r\nnetif_tx_stop_queue(netdev_queue);\r\n}\r\nreturn NETDEV_TX_OK;\r\nabort_linearize:\r\nmyri10ge_unmap_tx_dma(mgp, tx, idx);\r\nif (skb_is_gso(skb)) {\r\nnetdev_err(mgp->dev, "TSO but wanted to linearize?!?!?\n");\r\ngoto drop;\r\n}\r\nif (skb_linearize(skb))\r\ngoto drop;\r\ntx->linearized++;\r\ngoto again;\r\ndrop:\r\ndev_kfree_skb_any(skb);\r\nss->stats.tx_dropped += 1;\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic netdev_tx_t myri10ge_sw_tso(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct sk_buff *segs, *curr;\r\nstruct myri10ge_priv *mgp = netdev_priv(dev);\r\nstruct myri10ge_slice_state *ss;\r\nnetdev_tx_t status;\r\nsegs = skb_gso_segment(skb, dev->features & ~NETIF_F_TSO6);\r\nif (IS_ERR(segs))\r\ngoto drop;\r\nwhile (segs) {\r\ncurr = segs;\r\nsegs = segs->next;\r\ncurr->next = NULL;\r\nstatus = myri10ge_xmit(curr, dev);\r\nif (status != 0) {\r\ndev_kfree_skb_any(curr);\r\nif (segs != NULL) {\r\ncurr = segs;\r\nsegs = segs->next;\r\ncurr->next = NULL;\r\ndev_kfree_skb_any(segs);\r\n}\r\ngoto drop;\r\n}\r\n}\r\ndev_kfree_skb_any(skb);\r\nreturn NETDEV_TX_OK;\r\ndrop:\r\nss = &mgp->ss[skb_get_queue_mapping(skb)];\r\ndev_kfree_skb_any(skb);\r\nss->stats.tx_dropped += 1;\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void myri10ge_get_stats(struct net_device *dev,\r\nstruct rtnl_link_stats64 *stats)\r\n{\r\nconst struct myri10ge_priv *mgp = netdev_priv(dev);\r\nconst struct myri10ge_slice_netstats *slice_stats;\r\nint i;\r\nfor (i = 0; i < mgp->num_slices; i++) {\r\nslice_stats = &mgp->ss[i].stats;\r\nstats->rx_packets += slice_stats->rx_packets;\r\nstats->tx_packets += slice_stats->tx_packets;\r\nstats->rx_bytes += slice_stats->rx_bytes;\r\nstats->tx_bytes += slice_stats->tx_bytes;\r\nstats->rx_dropped += slice_stats->rx_dropped;\r\nstats->tx_dropped += slice_stats->tx_dropped;\r\n}\r\n}\r\nstatic void myri10ge_set_multicast_list(struct net_device *dev)\r\n{\r\nstruct myri10ge_priv *mgp = netdev_priv(dev);\r\nstruct myri10ge_cmd cmd;\r\nstruct netdev_hw_addr *ha;\r\n__be32 data[2] = { 0, 0 };\r\nint err;\r\nmyri10ge_change_promisc(mgp, dev->flags & IFF_PROMISC, 1);\r\nif (!mgp->fw_multicast_support)\r\nreturn;\r\nerr = myri10ge_send_cmd(mgp, MXGEFW_ENABLE_ALLMULTI, &cmd, 1);\r\nif (err != 0) {\r\nnetdev_err(dev, "Failed MXGEFW_ENABLE_ALLMULTI, error status: %d\n",\r\nerr);\r\ngoto abort;\r\n}\r\nif ((dev->flags & IFF_ALLMULTI) || mgp->adopted_rx_filter_bug) {\r\nreturn;\r\n}\r\nerr = myri10ge_send_cmd(mgp, MXGEFW_LEAVE_ALL_MULTICAST_GROUPS,\r\n&cmd, 1);\r\nif (err != 0) {\r\nnetdev_err(dev, "Failed MXGEFW_LEAVE_ALL_MULTICAST_GROUPS, error status: %d\n",\r\nerr);\r\ngoto abort;\r\n}\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nmemcpy(data, &ha->addr, ETH_ALEN);\r\ncmd.data0 = ntohl(data[0]);\r\ncmd.data1 = ntohl(data[1]);\r\nerr = myri10ge_send_cmd(mgp, MXGEFW_JOIN_MULTICAST_GROUP,\r\n&cmd, 1);\r\nif (err != 0) {\r\nnetdev_err(dev, "Failed MXGEFW_JOIN_MULTICAST_GROUP, error status:%d %pM\n",\r\nerr, ha->addr);\r\ngoto abort;\r\n}\r\n}\r\nerr = myri10ge_send_cmd(mgp, MXGEFW_DISABLE_ALLMULTI, &cmd, 1);\r\nif (err != 0) {\r\nnetdev_err(dev, "Failed MXGEFW_DISABLE_ALLMULTI, error status: %d\n",\r\nerr);\r\ngoto abort;\r\n}\r\nreturn;\r\nabort:\r\nreturn;\r\n}\r\nstatic int myri10ge_set_mac_address(struct net_device *dev, void *addr)\r\n{\r\nstruct sockaddr *sa = addr;\r\nstruct myri10ge_priv *mgp = netdev_priv(dev);\r\nint status;\r\nif (!is_valid_ether_addr(sa->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nstatus = myri10ge_update_mac_address(mgp, sa->sa_data);\r\nif (status != 0) {\r\nnetdev_err(dev, "changing mac address failed with %d\n",\r\nstatus);\r\nreturn status;\r\n}\r\nmemcpy(dev->dev_addr, sa->sa_data, ETH_ALEN);\r\nreturn 0;\r\n}\r\nstatic int myri10ge_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nstruct myri10ge_priv *mgp = netdev_priv(dev);\r\nint error = 0;\r\nnetdev_info(dev, "changing mtu from %d to %d\n", dev->mtu, new_mtu);\r\nif (mgp->running) {\r\nmyri10ge_close(dev);\r\ndev->mtu = new_mtu;\r\nmyri10ge_open(dev);\r\n} else\r\ndev->mtu = new_mtu;\r\nreturn error;\r\n}\r\nstatic void myri10ge_enable_ecrc(struct myri10ge_priv *mgp)\r\n{\r\nstruct pci_dev *bridge = mgp->pdev->bus->self;\r\nstruct device *dev = &mgp->pdev->dev;\r\nint cap;\r\nunsigned err_cap;\r\nint ret;\r\nif (!myri10ge_ecrc_enable || !bridge)\r\nreturn;\r\nif (pci_pcie_type(bridge) != PCI_EXP_TYPE_ROOT_PORT) {\r\nif (myri10ge_ecrc_enable > 1) {\r\nstruct pci_dev *prev_bridge, *old_bridge = bridge;\r\ndo {\r\nprev_bridge = bridge;\r\nbridge = bridge->bus->self;\r\nif (!bridge || prev_bridge == bridge) {\r\ndev_err(dev,\r\n"Failed to find root port"\r\n" to force ECRC\n");\r\nreturn;\r\n}\r\n} while (pci_pcie_type(bridge) !=\r\nPCI_EXP_TYPE_ROOT_PORT);\r\ndev_info(dev,\r\n"Forcing ECRC on non-root port %s"\r\n" (enabling on root port %s)\n",\r\npci_name(old_bridge), pci_name(bridge));\r\n} else {\r\ndev_err(dev,\r\n"Not enabling ECRC on non-root port %s\n",\r\npci_name(bridge));\r\nreturn;\r\n}\r\n}\r\ncap = pci_find_ext_capability(bridge, PCI_EXT_CAP_ID_ERR);\r\nif (!cap)\r\nreturn;\r\nret = pci_read_config_dword(bridge, cap + PCI_ERR_CAP, &err_cap);\r\nif (ret) {\r\ndev_err(dev, "failed reading ext-conf-space of %s\n",\r\npci_name(bridge));\r\ndev_err(dev, "\t pci=nommconf in use? "\r\n"or buggy/incomplete/absent ACPI MCFG attr?\n");\r\nreturn;\r\n}\r\nif (!(err_cap & PCI_ERR_CAP_ECRC_GENC))\r\nreturn;\r\nerr_cap |= PCI_ERR_CAP_ECRC_GENE;\r\npci_write_config_dword(bridge, cap + PCI_ERR_CAP, err_cap);\r\ndev_info(dev, "Enabled ECRC on upstream bridge %s\n", pci_name(bridge));\r\n}\r\nstatic void myri10ge_firmware_probe(struct myri10ge_priv *mgp)\r\n{\r\nstruct pci_dev *pdev = mgp->pdev;\r\nstruct device *dev = &pdev->dev;\r\nint status;\r\nmgp->tx_boundary = 4096;\r\nstatus = pcie_get_readrq(pdev);\r\nif (status < 0) {\r\ndev_err(dev, "Couldn't read max read req size: %d\n", status);\r\ngoto abort;\r\n}\r\nif (status != 4096) {\r\ndev_warn(dev, "Max Read Request size != 4096 (%d)\n", status);\r\nmgp->tx_boundary = 2048;\r\n}\r\nset_fw_name(mgp, myri10ge_fw_aligned, false);\r\nstatus = myri10ge_load_firmware(mgp, 1);\r\nif (status != 0) {\r\ngoto abort;\r\n}\r\nmyri10ge_enable_ecrc(mgp);\r\nstatus = myri10ge_dma_test(mgp, MXGEFW_CMD_UNALIGNED_TEST);\r\nif (status == 0)\r\nreturn;\r\nif (status != -E2BIG)\r\ndev_warn(dev, "DMA test failed: %d\n", status);\r\nif (status == -ENOSYS)\r\ndev_warn(dev, "Falling back to ethp! "\r\n"Please install up to date fw\n");\r\nabort:\r\nmgp->tx_boundary = 2048;\r\nset_fw_name(mgp, myri10ge_fw_unaligned, false);\r\n}\r\nstatic void myri10ge_select_firmware(struct myri10ge_priv *mgp)\r\n{\r\nint overridden = 0;\r\nif (myri10ge_force_firmware == 0) {\r\nint link_width;\r\nu16 lnk;\r\npcie_capability_read_word(mgp->pdev, PCI_EXP_LNKSTA, &lnk);\r\nlink_width = (lnk >> 4) & 0x3f;\r\nif (link_width < 8) {\r\ndev_info(&mgp->pdev->dev, "PCIE x%d Link\n",\r\nlink_width);\r\nmgp->tx_boundary = 4096;\r\nset_fw_name(mgp, myri10ge_fw_aligned, false);\r\n} else {\r\nmyri10ge_firmware_probe(mgp);\r\n}\r\n} else {\r\nif (myri10ge_force_firmware == 1) {\r\ndev_info(&mgp->pdev->dev,\r\n"Assuming aligned completions (forced)\n");\r\nmgp->tx_boundary = 4096;\r\nset_fw_name(mgp, myri10ge_fw_aligned, false);\r\n} else {\r\ndev_info(&mgp->pdev->dev,\r\n"Assuming unaligned completions (forced)\n");\r\nmgp->tx_boundary = 2048;\r\nset_fw_name(mgp, myri10ge_fw_unaligned, false);\r\n}\r\n}\r\nkernel_param_lock(THIS_MODULE);\r\nif (myri10ge_fw_name != NULL) {\r\nchar *fw_name = kstrdup(myri10ge_fw_name, GFP_KERNEL);\r\nif (fw_name) {\r\noverridden = 1;\r\nset_fw_name(mgp, fw_name, true);\r\n}\r\n}\r\nkernel_param_unlock(THIS_MODULE);\r\nif (mgp->board_number < MYRI10GE_MAX_BOARDS &&\r\nmyri10ge_fw_names[mgp->board_number] != NULL &&\r\nstrlen(myri10ge_fw_names[mgp->board_number])) {\r\nset_fw_name(mgp, myri10ge_fw_names[mgp->board_number], false);\r\noverridden = 1;\r\n}\r\nif (overridden)\r\ndev_info(&mgp->pdev->dev, "overriding firmware to %s\n",\r\nmgp->fw_name);\r\n}\r\nstatic void myri10ge_mask_surprise_down(struct pci_dev *pdev)\r\n{\r\nstruct pci_dev *bridge = pdev->bus->self;\r\nint cap;\r\nu32 mask;\r\nif (bridge == NULL)\r\nreturn;\r\ncap = pci_find_ext_capability(bridge, PCI_EXT_CAP_ID_ERR);\r\nif (cap) {\r\npci_read_config_dword(bridge, cap + PCI_ERR_UNCOR_MASK, &mask);\r\nmask |= 0x20;\r\npci_write_config_dword(bridge, cap + PCI_ERR_UNCOR_MASK, mask);\r\n}\r\n}\r\nstatic int myri10ge_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct myri10ge_priv *mgp;\r\nstruct net_device *netdev;\r\nmgp = pci_get_drvdata(pdev);\r\nif (mgp == NULL)\r\nreturn -EINVAL;\r\nnetdev = mgp->dev;\r\nnetif_device_detach(netdev);\r\nif (netif_running(netdev)) {\r\nnetdev_info(netdev, "closing\n");\r\nrtnl_lock();\r\nmyri10ge_close(netdev);\r\nrtnl_unlock();\r\n}\r\nmyri10ge_dummy_rdma(mgp, 0);\r\npci_save_state(pdev);\r\npci_disable_device(pdev);\r\nreturn pci_set_power_state(pdev, pci_choose_state(pdev, state));\r\n}\r\nstatic int myri10ge_resume(struct pci_dev *pdev)\r\n{\r\nstruct myri10ge_priv *mgp;\r\nstruct net_device *netdev;\r\nint status;\r\nu16 vendor;\r\nmgp = pci_get_drvdata(pdev);\r\nif (mgp == NULL)\r\nreturn -EINVAL;\r\nnetdev = mgp->dev;\r\npci_set_power_state(pdev, PCI_D0);\r\nmsleep(5);\r\npci_read_config_word(mgp->pdev, PCI_VENDOR_ID, &vendor);\r\nif (vendor == 0xffff) {\r\nnetdev_err(mgp->dev, "device disappeared!\n");\r\nreturn -EIO;\r\n}\r\npci_restore_state(pdev);\r\nstatus = pci_enable_device(pdev);\r\nif (status) {\r\ndev_err(&pdev->dev, "failed to enable device\n");\r\nreturn status;\r\n}\r\npci_set_master(pdev);\r\nmyri10ge_reset(mgp);\r\nmyri10ge_dummy_rdma(mgp, 1);\r\npci_save_state(pdev);\r\nif (netif_running(netdev)) {\r\nrtnl_lock();\r\nstatus = myri10ge_open(netdev);\r\nrtnl_unlock();\r\nif (status != 0)\r\ngoto abort_with_enabled;\r\n}\r\nnetif_device_attach(netdev);\r\nreturn 0;\r\nabort_with_enabled:\r\npci_disable_device(pdev);\r\nreturn -EIO;\r\n}\r\nstatic u32 myri10ge_read_reboot(struct myri10ge_priv *mgp)\r\n{\r\nstruct pci_dev *pdev = mgp->pdev;\r\nint vs = mgp->vendor_specific_offset;\r\nu32 reboot;\r\npci_write_config_byte(pdev, vs + 0x10, 0x3);\r\npci_write_config_dword(pdev, vs + 0x18, 0xfffffff0);\r\npci_read_config_dword(pdev, vs + 0x14, &reboot);\r\nreturn reboot;\r\n}\r\nstatic void\r\nmyri10ge_check_slice(struct myri10ge_slice_state *ss, int *reset_needed,\r\nint *busy_slice_cnt, u32 rx_pause_cnt)\r\n{\r\nstruct myri10ge_priv *mgp = ss->mgp;\r\nint slice = ss - mgp->ss;\r\nif (ss->tx.req != ss->tx.done &&\r\nss->tx.done == ss->watchdog_tx_done &&\r\nss->watchdog_tx_req != ss->watchdog_tx_done) {\r\nif (rx_pause_cnt != mgp->watchdog_pause) {\r\nif (net_ratelimit())\r\nnetdev_warn(mgp->dev, "slice %d: TX paused, "\r\n"check link partner\n", slice);\r\n} else {\r\nnetdev_warn(mgp->dev,\r\n"slice %d: TX stuck %d %d %d %d %d %d\n",\r\nslice, ss->tx.queue_active, ss->tx.req,\r\nss->tx.done, ss->tx.pkt_start,\r\nss->tx.pkt_done,\r\n(int)ntohl(mgp->ss[slice].fw_stats->\r\nsend_done_count));\r\n*reset_needed = 1;\r\nss->stuck = 1;\r\n}\r\n}\r\nif (ss->watchdog_tx_done != ss->tx.done ||\r\nss->watchdog_rx_done != ss->rx_done.cnt) {\r\n*busy_slice_cnt += 1;\r\n}\r\nss->watchdog_tx_done = ss->tx.done;\r\nss->watchdog_tx_req = ss->tx.req;\r\nss->watchdog_rx_done = ss->rx_done.cnt;\r\n}\r\nstatic void myri10ge_watchdog(struct work_struct *work)\r\n{\r\nstruct myri10ge_priv *mgp =\r\ncontainer_of(work, struct myri10ge_priv, watchdog_work);\r\nstruct myri10ge_slice_state *ss;\r\nu32 reboot, rx_pause_cnt;\r\nint status, rebooted;\r\nint i;\r\nint reset_needed = 0;\r\nint busy_slice_cnt = 0;\r\nu16 cmd, vendor;\r\nmgp->watchdog_resets++;\r\npci_read_config_word(mgp->pdev, PCI_COMMAND, &cmd);\r\nrebooted = 0;\r\nif ((cmd & PCI_COMMAND_MASTER) == 0) {\r\nreboot = myri10ge_read_reboot(mgp);\r\nnetdev_err(mgp->dev, "NIC rebooted (0x%x),%s resetting\n",\r\nreboot, myri10ge_reset_recover ? "" : " not");\r\nif (myri10ge_reset_recover == 0)\r\nreturn;\r\nrtnl_lock();\r\nmgp->rebooted = 1;\r\nrebooted = 1;\r\nmyri10ge_close(mgp->dev);\r\nmyri10ge_reset_recover--;\r\nmgp->rebooted = 0;\r\npci_restore_state(mgp->pdev);\r\npci_save_state(mgp->pdev);\r\n} else {\r\nif (cmd == 0xffff) {\r\npci_read_config_word(mgp->pdev, PCI_VENDOR_ID, &vendor);\r\nif (vendor == 0xffff) {\r\nnetdev_err(mgp->dev, "device disappeared!\n");\r\nreturn;\r\n}\r\n}\r\nrx_pause_cnt = ntohl(mgp->ss[0].fw_stats->dropped_pause);\r\nfor (i = 0; i < mgp->num_slices; i++) {\r\nss = mgp->ss;\r\nif (ss->stuck) {\r\nmyri10ge_check_slice(ss, &reset_needed,\r\n&busy_slice_cnt,\r\nrx_pause_cnt);\r\nss->stuck = 0;\r\n}\r\n}\r\nif (!reset_needed) {\r\nnetdev_dbg(mgp->dev, "not resetting\n");\r\nreturn;\r\n}\r\nnetdev_err(mgp->dev, "device timeout, resetting\n");\r\n}\r\nif (!rebooted) {\r\nrtnl_lock();\r\nmyri10ge_close(mgp->dev);\r\n}\r\nstatus = myri10ge_load_firmware(mgp, 1);\r\nif (status != 0)\r\nnetdev_err(mgp->dev, "failed to load firmware\n");\r\nelse\r\nmyri10ge_open(mgp->dev);\r\nrtnl_unlock();\r\n}\r\nstatic void myri10ge_watchdog_timer(unsigned long arg)\r\n{\r\nstruct myri10ge_priv *mgp;\r\nstruct myri10ge_slice_state *ss;\r\nint i, reset_needed, busy_slice_cnt;\r\nu32 rx_pause_cnt;\r\nu16 cmd;\r\nmgp = (struct myri10ge_priv *)arg;\r\nrx_pause_cnt = ntohl(mgp->ss[0].fw_stats->dropped_pause);\r\nbusy_slice_cnt = 0;\r\nfor (i = 0, reset_needed = 0;\r\ni < mgp->num_slices && reset_needed == 0; ++i) {\r\nss = &mgp->ss[i];\r\nif (ss->rx_small.watchdog_needed) {\r\nmyri10ge_alloc_rx_pages(mgp, &ss->rx_small,\r\nmgp->small_bytes + MXGEFW_PAD,\r\n1);\r\nif (ss->rx_small.fill_cnt - ss->rx_small.cnt >=\r\nmyri10ge_fill_thresh)\r\nss->rx_small.watchdog_needed = 0;\r\n}\r\nif (ss->rx_big.watchdog_needed) {\r\nmyri10ge_alloc_rx_pages(mgp, &ss->rx_big,\r\nmgp->big_bytes, 1);\r\nif (ss->rx_big.fill_cnt - ss->rx_big.cnt >=\r\nmyri10ge_fill_thresh)\r\nss->rx_big.watchdog_needed = 0;\r\n}\r\nmyri10ge_check_slice(ss, &reset_needed, &busy_slice_cnt,\r\nrx_pause_cnt);\r\n}\r\nif (busy_slice_cnt == 0) {\r\npci_read_config_word(mgp->pdev, PCI_COMMAND, &cmd);\r\nif ((cmd & PCI_COMMAND_MASTER) == 0) {\r\nreset_needed = 1;\r\n}\r\n}\r\nmgp->watchdog_pause = rx_pause_cnt;\r\nif (reset_needed) {\r\nschedule_work(&mgp->watchdog_work);\r\n} else {\r\nmod_timer(&mgp->watchdog_timer,\r\njiffies + myri10ge_watchdog_timeout * HZ);\r\n}\r\n}\r\nstatic void myri10ge_free_slices(struct myri10ge_priv *mgp)\r\n{\r\nstruct myri10ge_slice_state *ss;\r\nstruct pci_dev *pdev = mgp->pdev;\r\nsize_t bytes;\r\nint i;\r\nif (mgp->ss == NULL)\r\nreturn;\r\nfor (i = 0; i < mgp->num_slices; i++) {\r\nss = &mgp->ss[i];\r\nif (ss->rx_done.entry != NULL) {\r\nbytes = mgp->max_intr_slots *\r\nsizeof(*ss->rx_done.entry);\r\ndma_free_coherent(&pdev->dev, bytes,\r\nss->rx_done.entry, ss->rx_done.bus);\r\nss->rx_done.entry = NULL;\r\n}\r\nif (ss->fw_stats != NULL) {\r\nbytes = sizeof(*ss->fw_stats);\r\ndma_free_coherent(&pdev->dev, bytes,\r\nss->fw_stats, ss->fw_stats_bus);\r\nss->fw_stats = NULL;\r\n}\r\nnapi_hash_del(&ss->napi);\r\nnetif_napi_del(&ss->napi);\r\n}\r\nsynchronize_rcu();\r\nkfree(mgp->ss);\r\nmgp->ss = NULL;\r\n}\r\nstatic int myri10ge_alloc_slices(struct myri10ge_priv *mgp)\r\n{\r\nstruct myri10ge_slice_state *ss;\r\nstruct pci_dev *pdev = mgp->pdev;\r\nsize_t bytes;\r\nint i;\r\nbytes = sizeof(*mgp->ss) * mgp->num_slices;\r\nmgp->ss = kzalloc(bytes, GFP_KERNEL);\r\nif (mgp->ss == NULL) {\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < mgp->num_slices; i++) {\r\nss = &mgp->ss[i];\r\nbytes = mgp->max_intr_slots * sizeof(*ss->rx_done.entry);\r\nss->rx_done.entry = dma_zalloc_coherent(&pdev->dev, bytes,\r\n&ss->rx_done.bus,\r\nGFP_KERNEL);\r\nif (ss->rx_done.entry == NULL)\r\ngoto abort;\r\nbytes = sizeof(*ss->fw_stats);\r\nss->fw_stats = dma_alloc_coherent(&pdev->dev, bytes,\r\n&ss->fw_stats_bus,\r\nGFP_KERNEL);\r\nif (ss->fw_stats == NULL)\r\ngoto abort;\r\nss->mgp = mgp;\r\nss->dev = mgp->dev;\r\nnetif_napi_add(ss->dev, &ss->napi, myri10ge_poll,\r\nmyri10ge_napi_weight);\r\n}\r\nreturn 0;\r\nabort:\r\nmyri10ge_free_slices(mgp);\r\nreturn -ENOMEM;\r\n}\r\nstatic void myri10ge_probe_slices(struct myri10ge_priv *mgp)\r\n{\r\nstruct myri10ge_cmd cmd;\r\nstruct pci_dev *pdev = mgp->pdev;\r\nchar *old_fw;\r\nbool old_allocated;\r\nint i, status, ncpus;\r\nmgp->num_slices = 1;\r\nncpus = netif_get_num_default_rss_queues();\r\nif (myri10ge_max_slices == 1 || !pdev->msix_cap ||\r\n(myri10ge_max_slices == -1 && ncpus < 2))\r\nreturn;\r\nold_fw = mgp->fw_name;\r\nold_allocated = mgp->fw_name_allocated;\r\nmgp->fw_name_allocated = false;\r\nif (myri10ge_fw_name != NULL) {\r\ndev_info(&mgp->pdev->dev, "overriding rss firmware to %s\n",\r\nmyri10ge_fw_name);\r\nset_fw_name(mgp, myri10ge_fw_name, false);\r\n} else if (old_fw == myri10ge_fw_aligned)\r\nset_fw_name(mgp, myri10ge_fw_rss_aligned, false);\r\nelse\r\nset_fw_name(mgp, myri10ge_fw_rss_unaligned, false);\r\nstatus = myri10ge_load_firmware(mgp, 0);\r\nif (status != 0) {\r\ndev_info(&pdev->dev, "Rss firmware not found\n");\r\nif (old_allocated)\r\nkfree(old_fw);\r\nreturn;\r\n}\r\nmemset(&cmd, 0, sizeof(cmd));\r\nstatus = myri10ge_send_cmd(mgp, MXGEFW_CMD_RESET, &cmd, 0);\r\nif (status != 0) {\r\ndev_err(&mgp->pdev->dev, "failed reset\n");\r\ngoto abort_with_fw;\r\n}\r\nmgp->max_intr_slots = cmd.data0 / sizeof(struct mcp_slot);\r\ncmd.data0 = mgp->max_intr_slots * sizeof(struct mcp_slot);\r\nstatus = myri10ge_send_cmd(mgp, MXGEFW_CMD_SET_INTRQ_SIZE, &cmd, 0);\r\nif (status != 0) {\r\ndev_err(&mgp->pdev->dev, "failed MXGEFW_CMD_SET_INTRQ_SIZE\n");\r\ngoto abort_with_fw;\r\n}\r\nstatus = myri10ge_send_cmd(mgp, MXGEFW_CMD_GET_MAX_RSS_QUEUES, &cmd, 0);\r\nif (status != 0)\r\ngoto abort_with_fw;\r\nelse\r\nmgp->num_slices = cmd.data0;\r\nif (!myri10ge_msi) {\r\ngoto abort_with_fw;\r\n}\r\nif (myri10ge_max_slices == -1)\r\nmyri10ge_max_slices = ncpus;\r\nif (mgp->num_slices > myri10ge_max_slices)\r\nmgp->num_slices = myri10ge_max_slices;\r\nmgp->msix_vectors = kcalloc(mgp->num_slices, sizeof(*mgp->msix_vectors),\r\nGFP_KERNEL);\r\nif (mgp->msix_vectors == NULL)\r\ngoto no_msix;\r\nfor (i = 0; i < mgp->num_slices; i++) {\r\nmgp->msix_vectors[i].entry = i;\r\n}\r\nwhile (mgp->num_slices > 1) {\r\nmgp->num_slices = rounddown_pow_of_two(mgp->num_slices);\r\nif (mgp->num_slices == 1)\r\ngoto no_msix;\r\nstatus = pci_enable_msix_range(pdev,\r\nmgp->msix_vectors,\r\nmgp->num_slices,\r\nmgp->num_slices);\r\nif (status < 0)\r\ngoto no_msix;\r\npci_disable_msix(pdev);\r\nif (status == mgp->num_slices) {\r\nif (old_allocated)\r\nkfree(old_fw);\r\nreturn;\r\n} else {\r\nmgp->num_slices = status;\r\n}\r\n}\r\nno_msix:\r\nif (mgp->msix_vectors != NULL) {\r\nkfree(mgp->msix_vectors);\r\nmgp->msix_vectors = NULL;\r\n}\r\nabort_with_fw:\r\nmgp->num_slices = 1;\r\nset_fw_name(mgp, old_fw, old_allocated);\r\nmyri10ge_load_firmware(mgp, 0);\r\n}\r\nstatic int myri10ge_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nstruct net_device *netdev;\r\nstruct myri10ge_priv *mgp;\r\nstruct device *dev = &pdev->dev;\r\nint i;\r\nint status = -ENXIO;\r\nint dac_enabled;\r\nunsigned hdr_offset, ss_offset;\r\nstatic int board_number;\r\nnetdev = alloc_etherdev_mq(sizeof(*mgp), MYRI10GE_MAX_SLICES);\r\nif (netdev == NULL)\r\nreturn -ENOMEM;\r\nSET_NETDEV_DEV(netdev, &pdev->dev);\r\nmgp = netdev_priv(netdev);\r\nmgp->dev = netdev;\r\nmgp->pdev = pdev;\r\nmgp->pause = myri10ge_flow_control;\r\nmgp->intr_coal_delay = myri10ge_intr_coal_delay;\r\nmgp->msg_enable = netif_msg_init(myri10ge_debug, MYRI10GE_MSG_DEFAULT);\r\nmgp->board_number = board_number;\r\ninit_waitqueue_head(&mgp->down_wq);\r\nif (pci_enable_device(pdev)) {\r\ndev_err(&pdev->dev, "pci_enable_device call failed\n");\r\nstatus = -ENODEV;\r\ngoto abort_with_netdev;\r\n}\r\nmgp->vendor_specific_offset\r\n= pci_find_capability(pdev, PCI_CAP_ID_VNDR);\r\nstatus = pcie_set_readrq(pdev, 4096);\r\nif (status != 0) {\r\ndev_err(&pdev->dev, "Error %d writing PCI_EXP_DEVCTL\n",\r\nstatus);\r\ngoto abort_with_enabled;\r\n}\r\nmyri10ge_mask_surprise_down(pdev);\r\npci_set_master(pdev);\r\ndac_enabled = 1;\r\nstatus = pci_set_dma_mask(pdev, DMA_BIT_MASK(64));\r\nif (status != 0) {\r\ndac_enabled = 0;\r\ndev_err(&pdev->dev,\r\n"64-bit pci address mask was refused, "\r\n"trying 32-bit\n");\r\nstatus = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\n}\r\nif (status != 0) {\r\ndev_err(&pdev->dev, "Error %d setting DMA mask\n", status);\r\ngoto abort_with_enabled;\r\n}\r\n(void)pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(64));\r\nmgp->cmd = dma_alloc_coherent(&pdev->dev, sizeof(*mgp->cmd),\r\n&mgp->cmd_bus, GFP_KERNEL);\r\nif (!mgp->cmd) {\r\nstatus = -ENOMEM;\r\ngoto abort_with_enabled;\r\n}\r\nmgp->board_span = pci_resource_len(pdev, 0);\r\nmgp->iomem_base = pci_resource_start(pdev, 0);\r\nmgp->wc_cookie = arch_phys_wc_add(mgp->iomem_base, mgp->board_span);\r\nmgp->sram = ioremap_wc(mgp->iomem_base, mgp->board_span);\r\nif (mgp->sram == NULL) {\r\ndev_err(&pdev->dev, "ioremap failed for %ld bytes at 0x%lx\n",\r\nmgp->board_span, mgp->iomem_base);\r\nstatus = -ENXIO;\r\ngoto abort_with_mtrr;\r\n}\r\nhdr_offset =\r\nswab32(readl(mgp->sram + MCP_HEADER_PTR_OFFSET)) & 0xffffc;\r\nss_offset = hdr_offset + offsetof(struct mcp_gen_header, string_specs);\r\nmgp->sram_size = swab32(readl(mgp->sram + ss_offset));\r\nif (mgp->sram_size > mgp->board_span ||\r\nmgp->sram_size <= MYRI10GE_FW_OFFSET) {\r\ndev_err(&pdev->dev,\r\n"invalid sram_size %dB or board span %ldB\n",\r\nmgp->sram_size, mgp->board_span);\r\ngoto abort_with_ioremap;\r\n}\r\nmemcpy_fromio(mgp->eeprom_strings,\r\nmgp->sram + mgp->sram_size, MYRI10GE_EEPROM_STRINGS_SIZE);\r\nmemset(mgp->eeprom_strings + MYRI10GE_EEPROM_STRINGS_SIZE - 2, 0, 2);\r\nstatus = myri10ge_read_mac_addr(mgp);\r\nif (status)\r\ngoto abort_with_ioremap;\r\nfor (i = 0; i < ETH_ALEN; i++)\r\nnetdev->dev_addr[i] = mgp->mac_addr[i];\r\nmyri10ge_select_firmware(mgp);\r\nstatus = myri10ge_load_firmware(mgp, 1);\r\nif (status != 0) {\r\ndev_err(&pdev->dev, "failed to load firmware\n");\r\ngoto abort_with_ioremap;\r\n}\r\nmyri10ge_probe_slices(mgp);\r\nstatus = myri10ge_alloc_slices(mgp);\r\nif (status != 0) {\r\ndev_err(&pdev->dev, "failed to alloc slice state\n");\r\ngoto abort_with_firmware;\r\n}\r\nnetif_set_real_num_tx_queues(netdev, mgp->num_slices);\r\nnetif_set_real_num_rx_queues(netdev, mgp->num_slices);\r\nstatus = myri10ge_reset(mgp);\r\nif (status != 0) {\r\ndev_err(&pdev->dev, "failed reset\n");\r\ngoto abort_with_slices;\r\n}\r\n#ifdef CONFIG_MYRI10GE_DCA\r\nmyri10ge_setup_dca(mgp);\r\n#endif\r\npci_set_drvdata(pdev, mgp);\r\nnetdev->min_mtu = ETH_MIN_MTU;\r\nnetdev->max_mtu = MYRI10GE_MAX_ETHER_MTU - ETH_HLEN;\r\nif (myri10ge_initial_mtu > netdev->max_mtu)\r\nmyri10ge_initial_mtu = netdev->max_mtu;\r\nif (myri10ge_initial_mtu < netdev->min_mtu)\r\nmyri10ge_initial_mtu = netdev->min_mtu;\r\nnetdev->mtu = myri10ge_initial_mtu;\r\nnetdev->netdev_ops = &myri10ge_netdev_ops;\r\nnetdev->hw_features = mgp->features | NETIF_F_RXCSUM;\r\nnetdev->hw_features |= NETIF_F_HW_VLAN_CTAG_RX;\r\nnetdev->features = netdev->hw_features;\r\nif (dac_enabled)\r\nnetdev->features |= NETIF_F_HIGHDMA;\r\nnetdev->vlan_features |= mgp->features;\r\nif (mgp->fw_ver_tiny < 37)\r\nnetdev->vlan_features &= ~NETIF_F_TSO6;\r\nif (mgp->fw_ver_tiny < 32)\r\nnetdev->vlan_features &= ~NETIF_F_TSO;\r\nstatus = myri10ge_request_irq(mgp);\r\nif (status != 0)\r\ngoto abort_with_firmware;\r\nmyri10ge_free_irq(mgp);\r\npci_save_state(pdev);\r\nsetup_timer(&mgp->watchdog_timer, myri10ge_watchdog_timer,\r\n(unsigned long)mgp);\r\nnetdev->ethtool_ops = &myri10ge_ethtool_ops;\r\nINIT_WORK(&mgp->watchdog_work, myri10ge_watchdog);\r\nstatus = register_netdev(netdev);\r\nif (status != 0) {\r\ndev_err(&pdev->dev, "register_netdev failed: %d\n", status);\r\ngoto abort_with_state;\r\n}\r\nif (mgp->msix_enabled)\r\ndev_info(dev, "%d MSI-X IRQs, tx bndry %d, fw %s, MTRR %s, WC Enabled\n",\r\nmgp->num_slices, mgp->tx_boundary, mgp->fw_name,\r\n(mgp->wc_cookie > 0 ? "Enabled" : "Disabled"));\r\nelse\r\ndev_info(dev, "%s IRQ %d, tx bndry %d, fw %s, MTRR %s, WC Enabled\n",\r\nmgp->msi_enabled ? "MSI" : "xPIC",\r\npdev->irq, mgp->tx_boundary, mgp->fw_name,\r\n(mgp->wc_cookie > 0 ? "Enabled" : "Disabled"));\r\nboard_number++;\r\nreturn 0;\r\nabort_with_state:\r\npci_restore_state(pdev);\r\nabort_with_slices:\r\nmyri10ge_free_slices(mgp);\r\nabort_with_firmware:\r\nmyri10ge_dummy_rdma(mgp, 0);\r\nabort_with_ioremap:\r\nif (mgp->mac_addr_string != NULL)\r\ndev_err(&pdev->dev,\r\n"myri10ge_probe() failed: MAC=%s, SN=%ld\n",\r\nmgp->mac_addr_string, mgp->serial_number);\r\niounmap(mgp->sram);\r\nabort_with_mtrr:\r\narch_phys_wc_del(mgp->wc_cookie);\r\ndma_free_coherent(&pdev->dev, sizeof(*mgp->cmd),\r\nmgp->cmd, mgp->cmd_bus);\r\nabort_with_enabled:\r\npci_disable_device(pdev);\r\nabort_with_netdev:\r\nset_fw_name(mgp, NULL, false);\r\nfree_netdev(netdev);\r\nreturn status;\r\n}\r\nstatic void myri10ge_remove(struct pci_dev *pdev)\r\n{\r\nstruct myri10ge_priv *mgp;\r\nstruct net_device *netdev;\r\nmgp = pci_get_drvdata(pdev);\r\nif (mgp == NULL)\r\nreturn;\r\ncancel_work_sync(&mgp->watchdog_work);\r\nnetdev = mgp->dev;\r\nunregister_netdev(netdev);\r\n#ifdef CONFIG_MYRI10GE_DCA\r\nmyri10ge_teardown_dca(mgp);\r\n#endif\r\nmyri10ge_dummy_rdma(mgp, 0);\r\npci_restore_state(pdev);\r\niounmap(mgp->sram);\r\narch_phys_wc_del(mgp->wc_cookie);\r\nmyri10ge_free_slices(mgp);\r\nkfree(mgp->msix_vectors);\r\ndma_free_coherent(&pdev->dev, sizeof(*mgp->cmd),\r\nmgp->cmd, mgp->cmd_bus);\r\nset_fw_name(mgp, NULL, false);\r\nfree_netdev(netdev);\r\npci_disable_device(pdev);\r\n}\r\nstatic int\r\nmyri10ge_notify_dca(struct notifier_block *nb, unsigned long event, void *p)\r\n{\r\nint err = driver_for_each_device(&myri10ge_driver.driver,\r\nNULL, &event,\r\nmyri10ge_notify_dca_device);\r\nif (err)\r\nreturn NOTIFY_BAD;\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic __init int myri10ge_init_module(void)\r\n{\r\npr_info("Version %s\n", MYRI10GE_VERSION_STR);\r\nif (myri10ge_rss_hash > MXGEFW_RSS_HASH_TYPE_MAX) {\r\npr_err("Illegal rssh hash type %d, defaulting to source port\n",\r\nmyri10ge_rss_hash);\r\nmyri10ge_rss_hash = MXGEFW_RSS_HASH_TYPE_SRC_PORT;\r\n}\r\n#ifdef CONFIG_MYRI10GE_DCA\r\ndca_register_notify(&myri10ge_dca_notifier);\r\n#endif\r\nif (myri10ge_max_slices > MYRI10GE_MAX_SLICES)\r\nmyri10ge_max_slices = MYRI10GE_MAX_SLICES;\r\nreturn pci_register_driver(&myri10ge_driver);\r\n}\r\nstatic __exit void myri10ge_cleanup_module(void)\r\n{\r\n#ifdef CONFIG_MYRI10GE_DCA\r\ndca_unregister_notify(&myri10ge_dca_notifier);\r\n#endif\r\npci_unregister_driver(&myri10ge_driver);\r\n}
