static void pismo_set_vpp(struct platform_device *pdev, int on)\r\n{\r\nstruct i2c_client *client = to_i2c_client(pdev->dev.parent);\r\nstruct pismo_data *pismo = i2c_get_clientdata(client);\r\npismo->vpp(pismo->vpp_data, on);\r\n}\r\nstatic unsigned int pismo_width_to_bytes(unsigned int width)\r\n{\r\nwidth &= 15;\r\nif (width > 2)\r\nreturn 0;\r\nreturn 1 << width;\r\n}\r\nstatic int pismo_eeprom_read(struct i2c_client *client, void *buf, u8 addr,\r\nsize_t size)\r\n{\r\nint ret;\r\nstruct i2c_msg msg[] = {\r\n{\r\n.addr = client->addr,\r\n.len = sizeof(addr),\r\n.buf = &addr,\r\n}, {\r\n.addr = client->addr,\r\n.flags = I2C_M_RD,\r\n.len = size,\r\n.buf = buf,\r\n},\r\n};\r\nret = i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg));\r\nreturn ret == ARRAY_SIZE(msg) ? size : -EIO;\r\n}\r\nstatic int pismo_add_device(struct pismo_data *pismo, int i,\r\nstruct pismo_mem *region, const char *name,\r\nvoid *pdata, size_t psize)\r\n{\r\nstruct platform_device *dev;\r\nstruct resource res = { };\r\nphys_addr_t base = region->base;\r\nint ret;\r\nif (base == ~0)\r\nreturn -ENXIO;\r\nres.start = base;\r\nres.end = base + region->size - 1;\r\nres.flags = IORESOURCE_MEM;\r\ndev = platform_device_alloc(name, i);\r\nif (!dev)\r\nreturn -ENOMEM;\r\ndev->dev.parent = &pismo->client->dev;\r\ndo {\r\nret = platform_device_add_resources(dev, &res, 1);\r\nif (ret)\r\nbreak;\r\nret = platform_device_add_data(dev, pdata, psize);\r\nif (ret)\r\nbreak;\r\nret = platform_device_add(dev);\r\nif (ret)\r\nbreak;\r\npismo->dev[i] = dev;\r\nreturn 0;\r\n} while (0);\r\nplatform_device_put(dev);\r\nreturn ret;\r\n}\r\nstatic int pismo_add_nor(struct pismo_data *pismo, int i,\r\nstruct pismo_mem *region)\r\n{\r\nstruct physmap_flash_data data = {\r\n.width = region->width,\r\n};\r\nif (pismo->vpp)\r\ndata.set_vpp = pismo_set_vpp;\r\nreturn pismo_add_device(pismo, i, region, "physmap-flash",\r\n&data, sizeof(data));\r\n}\r\nstatic int pismo_add_sram(struct pismo_data *pismo, int i,\r\nstruct pismo_mem *region)\r\n{\r\nstruct platdata_mtd_ram data = {\r\n.bankwidth = region->width,\r\n};\r\nreturn pismo_add_device(pismo, i, region, "mtd-ram",\r\n&data, sizeof(data));\r\n}\r\nstatic void pismo_add_one(struct pismo_data *pismo, int i,\r\nconst struct pismo_cs_block *cs, phys_addr_t base)\r\n{\r\nstruct device *dev = &pismo->client->dev;\r\nstruct pismo_mem region;\r\nregion.base = base;\r\nregion.type = cs->type;\r\nregion.width = pismo_width_to_bytes(cs->width);\r\nregion.access = le16_to_cpu(cs->access);\r\nregion.size = le32_to_cpu(cs->size);\r\nif (region.width == 0) {\r\ndev_err(dev, "cs%u: bad width: %02x, ignoring\n", i, cs->width);\r\nreturn;\r\n}\r\ndev_info(dev, "cs%u: %.32s: type %02x access %u00ps size %uK\n",\r\ni, cs->device, region.type, region.access, region.size / 1024);\r\nswitch (region.type) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\nbreak;\r\ncase 2:\r\npismo_add_nor(pismo, i, &region);\r\nbreak;\r\ncase 3:\r\npismo_add_sram(pismo, i, &region);\r\nbreak;\r\n}\r\n}\r\nstatic int pismo_remove(struct i2c_client *client)\r\n{\r\nstruct pismo_data *pismo = i2c_get_clientdata(client);\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(pismo->dev); i++)\r\nplatform_device_unregister(pismo->dev[i]);\r\nkfree(pismo);\r\nreturn 0;\r\n}\r\nstatic int pismo_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);\r\nstruct pismo_pdata *pdata = client->dev.platform_data;\r\nstruct pismo_eeprom eeprom;\r\nstruct pismo_data *pismo;\r\nint ret, i;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_I2C)) {\r\ndev_err(&client->dev, "functionality mismatch\n");\r\nreturn -EIO;\r\n}\r\npismo = kzalloc(sizeof(*pismo), GFP_KERNEL);\r\nif (!pismo)\r\nreturn -ENOMEM;\r\npismo->client = client;\r\nif (pdata) {\r\npismo->vpp = pdata->set_vpp;\r\npismo->vpp_data = pdata->vpp_data;\r\n}\r\ni2c_set_clientdata(client, pismo);\r\nret = pismo_eeprom_read(client, &eeprom, 0, sizeof(eeprom));\r\nif (ret < 0) {\r\ndev_err(&client->dev, "error reading EEPROM: %d\n", ret);\r\ngoto exit_free;\r\n}\r\ndev_info(&client->dev, "%.15s board found\n", eeprom.board);\r\nfor (i = 0; i < ARRAY_SIZE(eeprom.cs); i++)\r\nif (eeprom.cs[i].type != 0xff)\r\npismo_add_one(pismo, i, &eeprom.cs[i],\r\npdata->cs_addrs[i]);\r\nreturn 0;\r\nexit_free:\r\nkfree(pismo);\r\nreturn ret;\r\n}\r\nstatic int __init pismo_init(void)\r\n{\r\nBUILD_BUG_ON(sizeof(struct pismo_cs_block) != 48);\r\nBUILD_BUG_ON(sizeof(struct pismo_eeprom) != 256);\r\nreturn i2c_add_driver(&pismo_driver);\r\n}\r\nstatic void __exit pismo_exit(void)\r\n{\r\ni2c_del_driver(&pismo_driver);\r\n}
