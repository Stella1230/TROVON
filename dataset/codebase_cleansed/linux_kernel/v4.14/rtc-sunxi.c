static irqreturn_t sunxi_rtc_alarmirq(int irq, void *id)\r\n{\r\nstruct sunxi_rtc_dev *chip = (struct sunxi_rtc_dev *) id;\r\nu32 val;\r\nval = readl(chip->base + SUNXI_ALRM_IRQ_STA);\r\nif (val & SUNXI_ALRM_IRQ_STA_CNT_IRQ_PEND) {\r\nval |= SUNXI_ALRM_IRQ_STA_CNT_IRQ_PEND;\r\nwritel(val, chip->base + SUNXI_ALRM_IRQ_STA);\r\nrtc_update_irq(chip->rtc, 1, RTC_AF | RTC_IRQF);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic void sunxi_rtc_setaie(unsigned int to, struct sunxi_rtc_dev *chip)\r\n{\r\nu32 alrm_val = 0;\r\nu32 alrm_irq_val = 0;\r\nif (to) {\r\nalrm_val = readl(chip->base + SUNXI_ALRM_EN);\r\nalrm_val |= SUNXI_ALRM_EN_CNT_EN;\r\nalrm_irq_val = readl(chip->base + SUNXI_ALRM_IRQ_EN);\r\nalrm_irq_val |= SUNXI_ALRM_IRQ_EN_CNT_IRQ_EN;\r\n} else {\r\nwritel(SUNXI_ALRM_IRQ_STA_CNT_IRQ_PEND,\r\nchip->base + SUNXI_ALRM_IRQ_STA);\r\n}\r\nwritel(alrm_val, chip->base + SUNXI_ALRM_EN);\r\nwritel(alrm_irq_val, chip->base + SUNXI_ALRM_IRQ_EN);\r\n}\r\nstatic int sunxi_rtc_getalarm(struct device *dev, struct rtc_wkalrm *wkalrm)\r\n{\r\nstruct sunxi_rtc_dev *chip = dev_get_drvdata(dev);\r\nstruct rtc_time *alrm_tm = &wkalrm->time;\r\nu32 alrm;\r\nu32 alrm_en;\r\nu32 date;\r\nalrm = readl(chip->base + SUNXI_ALRM_DHMS);\r\ndate = readl(chip->base + SUNXI_RTC_YMD);\r\nalrm_tm->tm_sec = SUNXI_ALRM_GET_SEC_VALUE(alrm);\r\nalrm_tm->tm_min = SUNXI_ALRM_GET_MIN_VALUE(alrm);\r\nalrm_tm->tm_hour = SUNXI_ALRM_GET_HOUR_VALUE(alrm);\r\nalrm_tm->tm_mday = SUNXI_DATE_GET_DAY_VALUE(date);\r\nalrm_tm->tm_mon = SUNXI_DATE_GET_MON_VALUE(date);\r\nalrm_tm->tm_year = SUNXI_DATE_GET_YEAR_VALUE(date,\r\nchip->data_year->mask);\r\nalrm_tm->tm_mon -= 1;\r\nalrm_tm->tm_year += SUNXI_YEAR_OFF(chip->data_year);\r\nalrm_en = readl(chip->base + SUNXI_ALRM_IRQ_EN);\r\nif (alrm_en & SUNXI_ALRM_EN_CNT_EN)\r\nwkalrm->enabled = 1;\r\nreturn 0;\r\n}\r\nstatic int sunxi_rtc_gettime(struct device *dev, struct rtc_time *rtc_tm)\r\n{\r\nstruct sunxi_rtc_dev *chip = dev_get_drvdata(dev);\r\nu32 date, time;\r\ndo {\r\ndate = readl(chip->base + SUNXI_RTC_YMD);\r\ntime = readl(chip->base + SUNXI_RTC_HMS);\r\n} while ((date != readl(chip->base + SUNXI_RTC_YMD)) ||\r\n(time != readl(chip->base + SUNXI_RTC_HMS)));\r\nrtc_tm->tm_sec = SUNXI_TIME_GET_SEC_VALUE(time);\r\nrtc_tm->tm_min = SUNXI_TIME_GET_MIN_VALUE(time);\r\nrtc_tm->tm_hour = SUNXI_TIME_GET_HOUR_VALUE(time);\r\nrtc_tm->tm_mday = SUNXI_DATE_GET_DAY_VALUE(date);\r\nrtc_tm->tm_mon = SUNXI_DATE_GET_MON_VALUE(date);\r\nrtc_tm->tm_year = SUNXI_DATE_GET_YEAR_VALUE(date,\r\nchip->data_year->mask);\r\nrtc_tm->tm_mon -= 1;\r\nrtc_tm->tm_year += SUNXI_YEAR_OFF(chip->data_year);\r\nreturn rtc_valid_tm(rtc_tm);\r\n}\r\nstatic int sunxi_rtc_setalarm(struct device *dev, struct rtc_wkalrm *wkalrm)\r\n{\r\nstruct sunxi_rtc_dev *chip = dev_get_drvdata(dev);\r\nstruct rtc_time *alrm_tm = &wkalrm->time;\r\nstruct rtc_time tm_now;\r\nu32 alrm;\r\ntime64_t diff;\r\nunsigned long time_gap;\r\nunsigned long time_gap_day;\r\nunsigned long time_gap_hour;\r\nunsigned long time_gap_min;\r\nint ret;\r\nret = sunxi_rtc_gettime(dev, &tm_now);\r\nif (ret < 0) {\r\ndev_err(dev, "Error in getting time\n");\r\nreturn -EINVAL;\r\n}\r\ndiff = rtc_tm_sub(alrm_tm, &tm_now);\r\nif (diff <= 0) {\r\ndev_err(dev, "Date to set in the past\n");\r\nreturn -EINVAL;\r\n}\r\nif (diff > 255 * SEC_IN_DAY) {\r\ndev_err(dev, "Day must be in the range 0 - 255\n");\r\nreturn -EINVAL;\r\n}\r\ntime_gap = diff;\r\ntime_gap_day = time_gap / SEC_IN_DAY;\r\ntime_gap -= time_gap_day * SEC_IN_DAY;\r\ntime_gap_hour = time_gap / SEC_IN_HOUR;\r\ntime_gap -= time_gap_hour * SEC_IN_HOUR;\r\ntime_gap_min = time_gap / SEC_IN_MIN;\r\ntime_gap -= time_gap_min * SEC_IN_MIN;\r\nsunxi_rtc_setaie(0, chip);\r\nwritel(0, chip->base + SUNXI_ALRM_DHMS);\r\nusleep_range(100, 300);\r\nalrm = SUNXI_ALRM_SET_SEC_VALUE(time_gap) |\r\nSUNXI_ALRM_SET_MIN_VALUE(time_gap_min) |\r\nSUNXI_ALRM_SET_HOUR_VALUE(time_gap_hour) |\r\nSUNXI_ALRM_SET_DAY_VALUE(time_gap_day);\r\nwritel(alrm, chip->base + SUNXI_ALRM_DHMS);\r\nwritel(0, chip->base + SUNXI_ALRM_IRQ_EN);\r\nwritel(SUNXI_ALRM_IRQ_EN_CNT_IRQ_EN, chip->base + SUNXI_ALRM_IRQ_EN);\r\nsunxi_rtc_setaie(wkalrm->enabled, chip);\r\nreturn 0;\r\n}\r\nstatic int sunxi_rtc_wait(struct sunxi_rtc_dev *chip, int offset,\r\nunsigned int mask, unsigned int ms_timeout)\r\n{\r\nconst unsigned long timeout = jiffies + msecs_to_jiffies(ms_timeout);\r\nu32 reg;\r\ndo {\r\nreg = readl(chip->base + offset);\r\nreg &= mask;\r\nif (reg == mask)\r\nreturn 0;\r\n} while (time_before(jiffies, timeout));\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int sunxi_rtc_settime(struct device *dev, struct rtc_time *rtc_tm)\r\n{\r\nstruct sunxi_rtc_dev *chip = dev_get_drvdata(dev);\r\nu32 date = 0;\r\nu32 time = 0;\r\nunsigned int year;\r\nyear = rtc_tm->tm_year + 1900;\r\nif (year < chip->data_year->min || year > chip->data_year->max) {\r\ndev_err(dev, "rtc only supports year in range %u - %u\n",\r\nchip->data_year->min, chip->data_year->max);\r\nreturn -EINVAL;\r\n}\r\nrtc_tm->tm_year -= SUNXI_YEAR_OFF(chip->data_year);\r\nrtc_tm->tm_mon += 1;\r\ndate = SUNXI_DATE_SET_DAY_VALUE(rtc_tm->tm_mday) |\r\nSUNXI_DATE_SET_MON_VALUE(rtc_tm->tm_mon) |\r\nSUNXI_DATE_SET_YEAR_VALUE(rtc_tm->tm_year,\r\nchip->data_year->mask);\r\nif (is_leap_year(year))\r\ndate |= SUNXI_LEAP_SET_VALUE(1, chip->data_year->leap_shift);\r\ntime = SUNXI_TIME_SET_SEC_VALUE(rtc_tm->tm_sec) |\r\nSUNXI_TIME_SET_MIN_VALUE(rtc_tm->tm_min) |\r\nSUNXI_TIME_SET_HOUR_VALUE(rtc_tm->tm_hour);\r\nwritel(0, chip->base + SUNXI_RTC_HMS);\r\nwritel(0, chip->base + SUNXI_RTC_YMD);\r\nwritel(time, chip->base + SUNXI_RTC_HMS);\r\nif (sunxi_rtc_wait(chip, SUNXI_LOSC_CTRL,\r\nSUNXI_LOSC_CTRL_RTC_HMS_ACC, 50)) {\r\ndev_err(dev, "Failed to set rtc time.\n");\r\nreturn -1;\r\n}\r\nwritel(date, chip->base + SUNXI_RTC_YMD);\r\nif (sunxi_rtc_wait(chip, SUNXI_LOSC_CTRL,\r\nSUNXI_LOSC_CTRL_RTC_YMD_ACC, 50)) {\r\ndev_err(dev, "Failed to set rtc time.\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sunxi_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\r\n{\r\nstruct sunxi_rtc_dev *chip = dev_get_drvdata(dev);\r\nif (!enabled)\r\nsunxi_rtc_setaie(enabled, chip);\r\nreturn 0;\r\n}\r\nstatic int sunxi_rtc_probe(struct platform_device *pdev)\r\n{\r\nstruct sunxi_rtc_dev *chip;\r\nstruct resource *res;\r\nint ret;\r\nchip = devm_kzalloc(&pdev->dev, sizeof(*chip), GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, chip);\r\nchip->dev = &pdev->dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nchip->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(chip->base))\r\nreturn PTR_ERR(chip->base);\r\nchip->irq = platform_get_irq(pdev, 0);\r\nif (chip->irq < 0) {\r\ndev_err(&pdev->dev, "No IRQ resource\n");\r\nreturn chip->irq;\r\n}\r\nret = devm_request_irq(&pdev->dev, chip->irq, sunxi_rtc_alarmirq,\r\n0, dev_name(&pdev->dev), chip);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Could not request IRQ\n");\r\nreturn ret;\r\n}\r\nchip->data_year = of_device_get_match_data(&pdev->dev);\r\nif (!chip->data_year) {\r\ndev_err(&pdev->dev, "Unable to setup RTC data\n");\r\nreturn -ENODEV;\r\n}\r\nwritel(0, chip->base + SUNXI_ALRM_DHMS);\r\nwritel(0, chip->base + SUNXI_ALRM_EN);\r\nwritel(0, chip->base + SUNXI_ALRM_IRQ_EN);\r\nwritel(SUNXI_ALRM_IRQ_STA_CNT_IRQ_PEND, chip->base +\r\nSUNXI_ALRM_IRQ_STA);\r\nchip->rtc = rtc_device_register("rtc-sunxi", &pdev->dev,\r\n&sunxi_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(chip->rtc)) {\r\ndev_err(&pdev->dev, "unable to register device\n");\r\nreturn PTR_ERR(chip->rtc);\r\n}\r\ndev_info(&pdev->dev, "RTC enabled\n");\r\nreturn 0;\r\n}\r\nstatic int sunxi_rtc_remove(struct platform_device *pdev)\r\n{\r\nstruct sunxi_rtc_dev *chip = platform_get_drvdata(pdev);\r\nrtc_device_unregister(chip->rtc);\r\nreturn 0;\r\n}
