int stv06xx_write_bridge(struct sd *sd, u16 address, u16 i2c_data)\r\n{\r\nint err;\r\nstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\r\nstruct usb_device *udev = sd->gspca_dev.dev;\r\n__u8 *buf = sd->gspca_dev.usb_buf;\r\nu8 len = (i2c_data > 0xff) ? 2 : 1;\r\nbuf[0] = i2c_data & 0xff;\r\nbuf[1] = (i2c_data >> 8) & 0xff;\r\nerr = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\r\n0x04, 0x40, address, 0, buf, len,\r\nSTV06XX_URB_MSG_TIMEOUT);\r\nPDEBUG(D_CONF, "Written 0x%x to address 0x%x, status: %d",\r\ni2c_data, address, err);\r\nreturn (err < 0) ? err : 0;\r\n}\r\nint stv06xx_read_bridge(struct sd *sd, u16 address, u8 *i2c_data)\r\n{\r\nint err;\r\nstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\r\nstruct usb_device *udev = sd->gspca_dev.dev;\r\n__u8 *buf = sd->gspca_dev.usb_buf;\r\nerr = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\r\n0x04, 0xc0, address, 0, buf, 1,\r\nSTV06XX_URB_MSG_TIMEOUT);\r\n*i2c_data = buf[0];\r\nPDEBUG(D_CONF, "Reading 0x%x from address 0x%x, status %d",\r\n*i2c_data, address, err);\r\nreturn (err < 0) ? err : 0;\r\n}\r\nint stv06xx_write_sensor(struct sd *sd, u8 address, u16 value)\r\n{\r\nif (sd->sensor->i2c_len == 2) {\r\nu16 data[2] = { address, value };\r\nreturn stv06xx_write_sensor_words(sd, data, 1);\r\n} else {\r\nu8 data[2] = { address, value };\r\nreturn stv06xx_write_sensor_bytes(sd, data, 1);\r\n}\r\n}\r\nstatic int stv06xx_write_sensor_finish(struct sd *sd)\r\n{\r\nint err = 0;\r\nif (sd->bridge == BRIDGE_STV610) {\r\nstruct usb_device *udev = sd->gspca_dev.dev;\r\n__u8 *buf = sd->gspca_dev.usb_buf;\r\nbuf[0] = 0;\r\nerr = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\r\n0x04, 0x40, 0x1704, 0, buf, 1,\r\nSTV06XX_URB_MSG_TIMEOUT);\r\n}\r\nreturn (err < 0) ? err : 0;\r\n}\r\nint stv06xx_write_sensor_bytes(struct sd *sd, const u8 *data, u8 len)\r\n{\r\nint err, i, j;\r\nstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\r\nstruct usb_device *udev = sd->gspca_dev.dev;\r\n__u8 *buf = sd->gspca_dev.usb_buf;\r\nPDEBUG(D_CONF, "I2C: Command buffer contains %d entries", len);\r\nfor (i = 0; i < len;) {\r\nmemset(buf, 0, I2C_BUFFER_LENGTH);\r\nfor (j = 0; j < I2C_MAX_BYTES && i < len; j++, i++) {\r\nbuf[j] = data[2*i];\r\nbuf[0x10 + j] = data[2*i+1];\r\nPDEBUG(D_CONF, "I2C: Writing 0x%02x to reg 0x%02x",\r\ndata[2*i+1], data[2*i]);\r\n}\r\nbuf[0x20] = sd->sensor->i2c_addr;\r\nbuf[0x21] = j - 1;\r\nbuf[0x22] = I2C_WRITE_CMD;\r\nerr = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\r\n0x04, 0x40, 0x0400, 0, buf,\r\nI2C_BUFFER_LENGTH,\r\nSTV06XX_URB_MSG_TIMEOUT);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn stv06xx_write_sensor_finish(sd);\r\n}\r\nint stv06xx_write_sensor_words(struct sd *sd, const u16 *data, u8 len)\r\n{\r\nint err, i, j;\r\nstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\r\nstruct usb_device *udev = sd->gspca_dev.dev;\r\n__u8 *buf = sd->gspca_dev.usb_buf;\r\nPDEBUG(D_CONF, "I2C: Command buffer contains %d entries", len);\r\nfor (i = 0; i < len;) {\r\nmemset(buf, 0, I2C_BUFFER_LENGTH);\r\nfor (j = 0; j < I2C_MAX_WORDS && i < len; j++, i++) {\r\nbuf[j] = data[2*i];\r\nbuf[0x10 + j * 2] = data[2*i+1];\r\nbuf[0x10 + j * 2 + 1] = data[2*i+1] >> 8;\r\nPDEBUG(D_CONF, "I2C: Writing 0x%04x to reg 0x%02x",\r\ndata[2*i+1], data[2*i]);\r\n}\r\nbuf[0x20] = sd->sensor->i2c_addr;\r\nbuf[0x21] = j - 1;\r\nbuf[0x22] = I2C_WRITE_CMD;\r\nerr = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\r\n0x04, 0x40, 0x0400, 0, buf,\r\nI2C_BUFFER_LENGTH,\r\nSTV06XX_URB_MSG_TIMEOUT);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn stv06xx_write_sensor_finish(sd);\r\n}\r\nint stv06xx_read_sensor(struct sd *sd, const u8 address, u16 *value)\r\n{\r\nint err;\r\nstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\r\nstruct usb_device *udev = sd->gspca_dev.dev;\r\n__u8 *buf = sd->gspca_dev.usb_buf;\r\nerr = stv06xx_write_bridge(sd, STV_I2C_FLUSH, sd->sensor->i2c_flush);\r\nif (err < 0)\r\nreturn err;\r\nmemset(buf, 0, I2C_BUFFER_LENGTH);\r\nbuf[0] = address;\r\nbuf[0x20] = sd->sensor->i2c_addr;\r\nbuf[0x21] = 0;\r\nbuf[0x22] = I2C_READ_CMD;\r\nerr = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\r\n0x04, 0x40, 0x1400, 0, buf, I2C_BUFFER_LENGTH,\r\nSTV06XX_URB_MSG_TIMEOUT);\r\nif (err < 0) {\r\npr_err("I2C: Read error writing address: %d\n", err);\r\nreturn err;\r\n}\r\nerr = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\r\n0x04, 0xc0, 0x1410, 0, buf, sd->sensor->i2c_len,\r\nSTV06XX_URB_MSG_TIMEOUT);\r\nif (sd->sensor->i2c_len == 2)\r\n*value = buf[0] | (buf[1] << 8);\r\nelse\r\n*value = buf[0];\r\nPDEBUG(D_CONF, "I2C: Read 0x%x from address 0x%x, status: %d",\r\n*value, address, err);\r\nreturn (err < 0) ? err : 0;\r\n}\r\nstatic void stv06xx_dump_bridge(struct sd *sd)\r\n{\r\nint i;\r\nu8 data, buf;\r\npr_info("Dumping all stv06xx bridge registers\n");\r\nfor (i = 0x1400; i < 0x160f; i++) {\r\nstv06xx_read_bridge(sd, i, &data);\r\npr_info("Read 0x%x from address 0x%x\n", data, i);\r\n}\r\npr_info("Testing stv06xx bridge registers for writability\n");\r\nfor (i = 0x1400; i < 0x160f; i++) {\r\nstv06xx_read_bridge(sd, i, &data);\r\nbuf = data;\r\nstv06xx_write_bridge(sd, i, 0xff);\r\nstv06xx_read_bridge(sd, i, &data);\r\nif (data == 0xff)\r\npr_info("Register 0x%x is read/write\n", i);\r\nelse if (data != buf)\r\npr_info("Register 0x%x is read/write, but only partially\n",\r\ni);\r\nelse\r\npr_info("Register 0x%x is read-only\n", i);\r\nstv06xx_write_bridge(sd, i, buf);\r\n}\r\n}\r\nstatic int stv06xx_init(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint err;\r\nPDEBUG(D_PROBE, "Initializing camera");\r\nmsleep(250);\r\nerr = sd->sensor->init(sd);\r\nif (dump_sensor && sd->sensor->dump)\r\nsd->sensor->dump(sd);\r\nreturn (err < 0) ? err : 0;\r\n}\r\nstatic int stv06xx_init_controls(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nPDEBUG(D_PROBE, "Initializing controls");\r\ngspca_dev->vdev.ctrl_handler = &gspca_dev->ctrl_handler;\r\nreturn sd->sensor->init_controls(sd);\r\n}\r\nstatic int stv06xx_start(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct usb_host_interface *alt;\r\nstruct usb_interface *intf;\r\nint err, packet_size;\r\nintf = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);\r\nalt = usb_altnum_to_altsetting(intf, sd->gspca_dev.alt);\r\nif (!alt) {\r\nPERR("Couldn't get altsetting");\r\nreturn -EIO;\r\n}\r\npacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\r\nerr = stv06xx_write_bridge(sd, STV_ISO_SIZE_L, packet_size);\r\nif (err < 0)\r\nreturn err;\r\nerr = sd->sensor->start(sd);\r\nif (err < 0)\r\ngoto out;\r\nerr = stv06xx_write_bridge(sd, STV_ISO_ENABLE, 1);\r\nout:\r\nif (err < 0)\r\nPDEBUG(D_STREAM, "Starting stream failed");\r\nelse\r\nPDEBUG(D_STREAM, "Started streaming");\r\nreturn (err < 0) ? err : 0;\r\n}\r\nstatic int stv06xx_isoc_init(struct gspca_dev *gspca_dev)\r\n{\r\nstruct usb_host_interface *alt;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nalt = &gspca_dev->dev->actconfig->intf_cache[0]->altsetting[1];\r\nalt->endpoint[0].desc.wMaxPacketSize =\r\ncpu_to_le16(sd->sensor->max_packet_size[gspca_dev->curr_mode]);\r\nreturn 0;\r\n}\r\nstatic int stv06xx_isoc_nego(struct gspca_dev *gspca_dev)\r\n{\r\nint ret, packet_size, min_packet_size;\r\nstruct usb_host_interface *alt;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nalt = &gspca_dev->dev->actconfig->intf_cache[0]->altsetting[1];\r\npacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\r\nmin_packet_size = sd->sensor->min_packet_size[gspca_dev->curr_mode];\r\nif (packet_size <= min_packet_size)\r\nreturn -EIO;\r\npacket_size -= 100;\r\nif (packet_size < min_packet_size)\r\npacket_size = min_packet_size;\r\nalt->endpoint[0].desc.wMaxPacketSize = cpu_to_le16(packet_size);\r\nret = usb_set_interface(gspca_dev->dev, gspca_dev->iface, 1);\r\nif (ret < 0)\r\nPERR("set alt 1 err %d", ret);\r\nreturn ret;\r\n}\r\nstatic void stv06xx_stopN(struct gspca_dev *gspca_dev)\r\n{\r\nint err;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nerr = stv06xx_write_bridge(sd, STV_ISO_ENABLE, 0);\r\nif (err < 0)\r\ngoto out;\r\nerr = sd->sensor->stop(sd);\r\nout:\r\nif (err < 0)\r\nPDEBUG(D_STREAM, "Failed to stop stream");\r\nelse\r\nPDEBUG(D_STREAM, "Stopped streaming");\r\n}\r\nstatic void stv06xx_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *data,\r\nint len)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nPDEBUG(D_PACK, "Packet of length %d arrived", len);\r\nwhile (len) {\r\nint id, chunk_len;\r\nif (len < 4) {\r\nPDEBUG(D_PACK, "Packet is smaller than 4 bytes");\r\nreturn;\r\n}\r\nid = (data[0] << 8) | data[1];\r\nchunk_len = (data[2] << 8) | data[3];\r\nPDEBUG(D_PACK, "Chunk id: %x, length: %d", id, chunk_len);\r\ndata += 4;\r\nlen -= 4;\r\nif (len < chunk_len) {\r\nPERR("URB packet length is smaller than the specified chunk length");\r\ngspca_dev->last_packet_type = DISCARD_PACKET;\r\nreturn;\r\n}\r\nif (sd->bridge == BRIDGE_ST6422 && (id & 0xff00) == 0x0200)\r\ngoto frame_data;\r\nswitch (id) {\r\ncase 0x0200:\r\ncase 0x4200:\r\nframe_data:\r\nPDEBUG(D_PACK, "Frame data packet detected");\r\nif (sd->to_skip) {\r\nint skip = (sd->to_skip < chunk_len) ?\r\nsd->to_skip : chunk_len;\r\ndata += skip;\r\nlen -= skip;\r\nchunk_len -= skip;\r\nsd->to_skip -= skip;\r\n}\r\ngspca_frame_add(gspca_dev, INTER_PACKET,\r\ndata, chunk_len);\r\nbreak;\r\ncase 0x8001:\r\ncase 0x8005:\r\ncase 0xc001:\r\ncase 0xc005:\r\nPDEBUG(D_PACK, "Starting new frame");\r\ngspca_frame_add(gspca_dev, FIRST_PACKET,\r\nNULL, 0);\r\nif (sd->bridge == BRIDGE_ST6422)\r\nsd->to_skip = gspca_dev->pixfmt.width * 4;\r\nif (chunk_len)\r\nPERR("Chunk length is non-zero on a SOF");\r\nbreak;\r\ncase 0x8002:\r\ncase 0x8006:\r\ncase 0xc002:\r\nPDEBUG(D_PACK, "End of frame detected");\r\ngspca_frame_add(gspca_dev, LAST_PACKET,\r\nNULL, 0);\r\nif (chunk_len)\r\nPERR("Chunk length is non-zero on a EOF");\r\nbreak;\r\ncase 0x0005:\r\nPDEBUG(D_PACK, "Chunk 0x005 detected");\r\nbreak;\r\ncase 0x0100:\r\nPDEBUG(D_PACK, "Chunk 0x0100 detected");\r\nbreak;\r\ncase 0x42ff:\r\nPDEBUG(D_PACK, "Chunk 0x42ff detected");\r\nbreak;\r\ndefault:\r\nPDEBUG(D_PACK, "Unknown chunk 0x%04x detected", id);\r\n}\r\ndata += chunk_len;\r\nlen -= chunk_len;\r\n}\r\n}\r\nstatic int sd_int_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *data,\r\nint len)\r\n{\r\nint ret = -EINVAL;\r\nif (len == 1 && (data[0] == 0x80 || data[0] == 0x10)) {\r\ninput_report_key(gspca_dev->input_dev, KEY_CAMERA, 1);\r\ninput_sync(gspca_dev->input_dev);\r\nret = 0;\r\n}\r\nif (len == 1 && (data[0] == 0x88 || data[0] == 0x11)) {\r\ninput_report_key(gspca_dev->input_dev, KEY_CAMERA, 0);\r\ninput_sync(gspca_dev->input_dev);\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int stv06xx_config(struct gspca_dev *gspca_dev,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nPDEBUG(D_PROBE, "Configuring camera");\r\nsd->bridge = id->driver_info;\r\ngspca_dev->sd_desc = &sd_desc;\r\nif (dump_bridge)\r\nstv06xx_dump_bridge(sd);\r\nsd->sensor = &stv06xx_sensor_st6422;\r\nif (!sd->sensor->probe(sd))\r\nreturn 0;\r\nsd->sensor = &stv06xx_sensor_vv6410;\r\nif (!sd->sensor->probe(sd))\r\nreturn 0;\r\nsd->sensor = &stv06xx_sensor_hdcs1x00;\r\nif (!sd->sensor->probe(sd))\r\nreturn 0;\r\nsd->sensor = &stv06xx_sensor_hdcs1020;\r\nif (!sd->sensor->probe(sd))\r\nreturn 0;\r\nsd->sensor = &stv06xx_sensor_pb0100;\r\nif (!sd->sensor->probe(sd))\r\nreturn 0;\r\nsd->sensor = NULL;\r\nreturn -ENODEV;\r\n}\r\nstatic int sd_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\r\nTHIS_MODULE);\r\n}\r\nstatic void sd_disconnect(struct usb_interface *intf)\r\n{\r\nstruct gspca_dev *gspca_dev = usb_get_intfdata(intf);\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nvoid *priv = sd->sensor_priv;\r\nPDEBUG(D_PROBE, "Disconnecting the stv06xx device");\r\nsd->sensor = NULL;\r\ngspca_disconnect(intf);\r\nkfree(priv);\r\n}
