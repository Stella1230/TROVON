static int rockchip_usb_phy_power(struct rockchip_usb_phy *phy,\r\nbool siddq)\r\n{\r\nu32 val = HIWORD_UPDATE(siddq ? UOC_CON0_SIDDQ : 0, UOC_CON0_SIDDQ);\r\nreturn regmap_write(phy->base->reg_base, phy->reg_offset, val);\r\n}\r\nstatic unsigned long rockchip_usb_phy480m_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nreturn 480000000;\r\n}\r\nstatic void rockchip_usb_phy480m_disable(struct clk_hw *hw)\r\n{\r\nstruct rockchip_usb_phy *phy = container_of(hw,\r\nstruct rockchip_usb_phy,\r\nclk480m_hw);\r\nif (phy->vbus)\r\nregulator_disable(phy->vbus);\r\nrockchip_usb_phy_power(phy, 1);\r\n}\r\nstatic int rockchip_usb_phy480m_enable(struct clk_hw *hw)\r\n{\r\nstruct rockchip_usb_phy *phy = container_of(hw,\r\nstruct rockchip_usb_phy,\r\nclk480m_hw);\r\nreturn rockchip_usb_phy_power(phy, 0);\r\n}\r\nstatic int rockchip_usb_phy480m_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct rockchip_usb_phy *phy = container_of(hw,\r\nstruct rockchip_usb_phy,\r\nclk480m_hw);\r\nint ret;\r\nu32 val;\r\nret = regmap_read(phy->base->reg_base, phy->reg_offset, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn (val & UOC_CON0_SIDDQ) ? 0 : 1;\r\n}\r\nstatic int rockchip_usb_phy_power_off(struct phy *_phy)\r\n{\r\nstruct rockchip_usb_phy *phy = phy_get_drvdata(_phy);\r\nif (phy->uart_enabled)\r\nreturn -EBUSY;\r\nclk_disable_unprepare(phy->clk480m);\r\nreturn 0;\r\n}\r\nstatic int rockchip_usb_phy_power_on(struct phy *_phy)\r\n{\r\nstruct rockchip_usb_phy *phy = phy_get_drvdata(_phy);\r\nif (phy->uart_enabled)\r\nreturn -EBUSY;\r\nif (phy->vbus) {\r\nint ret;\r\nret = regulator_enable(phy->vbus);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn clk_prepare_enable(phy->clk480m);\r\n}\r\nstatic int rockchip_usb_phy_reset(struct phy *_phy)\r\n{\r\nstruct rockchip_usb_phy *phy = phy_get_drvdata(_phy);\r\nif (phy->reset) {\r\nreset_control_assert(phy->reset);\r\nudelay(10);\r\nreset_control_deassert(phy->reset);\r\n}\r\nreturn 0;\r\n}\r\nstatic void rockchip_usb_phy_action(void *data)\r\n{\r\nstruct rockchip_usb_phy *rk_phy = data;\r\nif (!rk_phy->uart_enabled) {\r\nof_clk_del_provider(rk_phy->np);\r\nclk_unregister(rk_phy->clk480m);\r\n}\r\nif (rk_phy->clk)\r\nclk_put(rk_phy->clk);\r\n}\r\nstatic int rockchip_usb_phy_init(struct rockchip_usb_phy_base *base,\r\nstruct device_node *child)\r\n{\r\nstruct rockchip_usb_phy *rk_phy;\r\nunsigned int reg_offset;\r\nconst char *clk_name;\r\nstruct clk_init_data init;\r\nint err, i;\r\nrk_phy = devm_kzalloc(base->dev, sizeof(*rk_phy), GFP_KERNEL);\r\nif (!rk_phy)\r\nreturn -ENOMEM;\r\nrk_phy->base = base;\r\nrk_phy->np = child;\r\nif (of_property_read_u32(child, "reg", &reg_offset)) {\r\ndev_err(base->dev, "missing reg property in node %s\n",\r\nchild->name);\r\nreturn -EINVAL;\r\n}\r\nrk_phy->reset = of_reset_control_get(child, "phy-reset");\r\nif (IS_ERR(rk_phy->reset))\r\nrk_phy->reset = NULL;\r\nrk_phy->reg_offset = reg_offset;\r\nrk_phy->clk = of_clk_get_by_name(child, "phyclk");\r\nif (IS_ERR(rk_phy->clk))\r\nrk_phy->clk = NULL;\r\ni = 0;\r\ninit.name = NULL;\r\nwhile (base->pdata->phys[i].reg) {\r\nif (base->pdata->phys[i].reg == reg_offset) {\r\ninit.name = base->pdata->phys[i].pll_name;\r\nbreak;\r\n}\r\ni++;\r\n}\r\nif (!init.name) {\r\ndev_err(base->dev, "phy data not found\n");\r\nreturn -EINVAL;\r\n}\r\nif (enable_usb_uart && base->pdata->usb_uart_phy == i) {\r\ndev_dbg(base->dev, "phy%d used as uart output\n", i);\r\nrk_phy->uart_enabled = true;\r\n} else {\r\nif (rk_phy->clk) {\r\nclk_name = __clk_get_name(rk_phy->clk);\r\ninit.flags = 0;\r\ninit.parent_names = &clk_name;\r\ninit.num_parents = 1;\r\n} else {\r\ninit.flags = 0;\r\ninit.parent_names = NULL;\r\ninit.num_parents = 0;\r\n}\r\ninit.ops = &rockchip_usb_phy480m_ops;\r\nrk_phy->clk480m_hw.init = &init;\r\nrk_phy->clk480m = clk_register(base->dev, &rk_phy->clk480m_hw);\r\nif (IS_ERR(rk_phy->clk480m)) {\r\nerr = PTR_ERR(rk_phy->clk480m);\r\ngoto err_clk;\r\n}\r\nerr = of_clk_add_provider(child, of_clk_src_simple_get,\r\nrk_phy->clk480m);\r\nif (err < 0)\r\ngoto err_clk_prov;\r\n}\r\nerr = devm_add_action_or_reset(base->dev, rockchip_usb_phy_action,\r\nrk_phy);\r\nif (err)\r\nreturn err;\r\nrk_phy->phy = devm_phy_create(base->dev, child, &ops);\r\nif (IS_ERR(rk_phy->phy)) {\r\ndev_err(base->dev, "failed to create PHY\n");\r\nreturn PTR_ERR(rk_phy->phy);\r\n}\r\nphy_set_drvdata(rk_phy->phy, rk_phy);\r\nrk_phy->vbus = devm_regulator_get_optional(&rk_phy->phy->dev, "vbus");\r\nif (IS_ERR(rk_phy->vbus)) {\r\nif (PTR_ERR(rk_phy->vbus) == -EPROBE_DEFER)\r\nreturn PTR_ERR(rk_phy->vbus);\r\nrk_phy->vbus = NULL;\r\n}\r\nif (rk_phy->uart_enabled)\r\nreturn clk_prepare_enable(rk_phy->clk);\r\nelse\r\nreturn rockchip_usb_phy_power(rk_phy, 1);\r\nerr_clk_prov:\r\nif (!rk_phy->uart_enabled)\r\nclk_unregister(rk_phy->clk480m);\r\nerr_clk:\r\nif (rk_phy->clk)\r\nclk_put(rk_phy->clk);\r\nreturn err;\r\n}\r\nstatic int __init rk3288_init_usb_uart(struct regmap *grf)\r\n{\r\nu32 val;\r\nint ret;\r\nval = HIWORD_UPDATE(RK3288_UOC0_CON0_COMMON_ON_N\r\n| RK3288_UOC0_CON0_DISABLE\r\n| UOC_CON0_SIDDQ,\r\nRK3288_UOC0_CON0_COMMON_ON_N\r\n| RK3288_UOC0_CON0_DISABLE\r\n| UOC_CON0_SIDDQ);\r\nret = regmap_write(grf, RK3288_UOC0_CON0, val);\r\nif (ret)\r\nreturn ret;\r\nval = HIWORD_UPDATE(RK3288_UOC0_CON2_SOFT_CON_SEL,\r\nRK3288_UOC0_CON2_SOFT_CON_SEL);\r\nret = regmap_write(grf, RK3288_UOC0_CON2, val);\r\nif (ret)\r\nreturn ret;\r\nval = HIWORD_UPDATE(RK3288_UOC0_CON3_UTMI_OPMODE_NODRIVING\r\n| RK3288_UOC0_CON3_UTMI_XCVRSEELCT_FSTRANSC\r\n| RK3288_UOC0_CON3_UTMI_TERMSEL_FULLSPEED,\r\nRK3288_UOC0_CON3_UTMI_SUSPENDN\r\n| RK3288_UOC0_CON3_UTMI_OPMODE_MASK\r\n| RK3288_UOC0_CON3_UTMI_XCVRSEELCT_MASK\r\n| RK3288_UOC0_CON3_UTMI_TERMSEL_FULLSPEED);\r\nret = regmap_write(grf, RK3288_UOC0_CON3, val);\r\nif (ret)\r\nreturn ret;\r\nval = HIWORD_UPDATE(RK3288_UOC0_CON3_BYPASSSEL\r\n| RK3288_UOC0_CON3_BYPASSDMEN,\r\nRK3288_UOC0_CON3_BYPASSSEL\r\n| RK3288_UOC0_CON3_BYPASSDMEN);\r\nret = regmap_write(grf, RK3288_UOC0_CON3, val);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int rockchip_usb_phy_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct rockchip_usb_phy_base *phy_base;\r\nstruct phy_provider *phy_provider;\r\nconst struct of_device_id *match;\r\nstruct device_node *child;\r\nint err;\r\nphy_base = devm_kzalloc(dev, sizeof(*phy_base), GFP_KERNEL);\r\nif (!phy_base)\r\nreturn -ENOMEM;\r\nmatch = of_match_device(dev->driver->of_match_table, dev);\r\nif (!match || !match->data) {\r\ndev_err(dev, "missing phy data\n");\r\nreturn -EINVAL;\r\n}\r\nphy_base->pdata = match->data;\r\nphy_base->dev = dev;\r\nphy_base->reg_base = ERR_PTR(-ENODEV);\r\nif (dev->parent && dev->parent->of_node)\r\nphy_base->reg_base = syscon_node_to_regmap(\r\ndev->parent->of_node);\r\nif (IS_ERR(phy_base->reg_base))\r\nphy_base->reg_base = syscon_regmap_lookup_by_phandle(\r\ndev->of_node, "rockchip,grf");\r\nif (IS_ERR(phy_base->reg_base)) {\r\ndev_err(&pdev->dev, "Missing rockchip,grf property\n");\r\nreturn PTR_ERR(phy_base->reg_base);\r\n}\r\nfor_each_available_child_of_node(dev->of_node, child) {\r\nerr = rockchip_usb_phy_init(phy_base, child);\r\nif (err) {\r\nof_node_put(child);\r\nreturn err;\r\n}\r\n}\r\nphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\r\nreturn PTR_ERR_OR_ZERO(phy_provider);\r\n}\r\nstatic int __init rockchip_init_usb_uart(void)\r\n{\r\nconst struct of_device_id *match;\r\nconst struct rockchip_usb_phy_pdata *data;\r\nstruct device_node *np;\r\nstruct regmap *grf;\r\nint ret;\r\nif (!enable_usb_uart)\r\nreturn 0;\r\nnp = of_find_matching_node_and_match(NULL, rockchip_usb_phy_dt_ids,\r\n&match);\r\nif (!np) {\r\npr_err("%s: failed to find usbphy node\n", __func__);\r\nreturn -ENOTSUPP;\r\n}\r\npr_debug("%s: using settings for %s\n", __func__, match->compatible);\r\ndata = match->data;\r\nif (!data->init_usb_uart) {\r\npr_err("%s: usb-uart not available on %s\n",\r\n__func__, match->compatible);\r\nreturn -ENOTSUPP;\r\n}\r\ngrf = ERR_PTR(-ENODEV);\r\nif (np->parent)\r\ngrf = syscon_node_to_regmap(np->parent);\r\nif (IS_ERR(grf))\r\ngrf = syscon_regmap_lookup_by_phandle(np, "rockchip,grf");\r\nif (IS_ERR(grf)) {\r\npr_err("%s: Missing rockchip,grf property, %lu\n",\r\n__func__, PTR_ERR(grf));\r\nreturn PTR_ERR(grf);\r\n}\r\nret = data->init_usb_uart(grf);\r\nif (ret) {\r\npr_err("%s: could not init usb_uart, %d\n", __func__, ret);\r\nenable_usb_uart = 0;\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init rockchip_usb_uart(char *buf)\r\n{\r\nenable_usb_uart = true;\r\nreturn 0;\r\n}
