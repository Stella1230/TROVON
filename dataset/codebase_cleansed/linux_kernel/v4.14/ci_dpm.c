static u8 ci_get_memory_module_index(struct amdgpu_device *adev)\r\n{\r\nreturn (u8) ((RREG32(mmBIOS_SCRATCH_4) >> 16) & 0xff);\r\n}\r\nstatic int ci_copy_and_switch_arb_sets(struct amdgpu_device *adev,\r\nu32 arb_freq_src, u32 arb_freq_dest)\r\n{\r\nu32 mc_arb_dram_timing;\r\nu32 mc_arb_dram_timing2;\r\nu32 burst_time;\r\nu32 mc_cg_config;\r\nswitch (arb_freq_src) {\r\ncase MC_CG_ARB_FREQ_F0:\r\nmc_arb_dram_timing = RREG32(mmMC_ARB_DRAM_TIMING);\r\nmc_arb_dram_timing2 = RREG32(mmMC_ARB_DRAM_TIMING2);\r\nburst_time = (RREG32(mmMC_ARB_BURST_TIME) & MC_ARB_BURST_TIME__STATE0_MASK) >>\r\nMC_ARB_BURST_TIME__STATE0__SHIFT;\r\nbreak;\r\ncase MC_CG_ARB_FREQ_F1:\r\nmc_arb_dram_timing = RREG32(mmMC_ARB_DRAM_TIMING_1);\r\nmc_arb_dram_timing2 = RREG32(mmMC_ARB_DRAM_TIMING2_1);\r\nburst_time = (RREG32(mmMC_ARB_BURST_TIME) & MC_ARB_BURST_TIME__STATE1_MASK) >>\r\nMC_ARB_BURST_TIME__STATE1__SHIFT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (arb_freq_dest) {\r\ncase MC_CG_ARB_FREQ_F0:\r\nWREG32(mmMC_ARB_DRAM_TIMING, mc_arb_dram_timing);\r\nWREG32(mmMC_ARB_DRAM_TIMING2, mc_arb_dram_timing2);\r\nWREG32_P(mmMC_ARB_BURST_TIME, (burst_time << MC_ARB_BURST_TIME__STATE0__SHIFT),\r\n~MC_ARB_BURST_TIME__STATE0_MASK);\r\nbreak;\r\ncase MC_CG_ARB_FREQ_F1:\r\nWREG32(mmMC_ARB_DRAM_TIMING_1, mc_arb_dram_timing);\r\nWREG32(mmMC_ARB_DRAM_TIMING2_1, mc_arb_dram_timing2);\r\nWREG32_P(mmMC_ARB_BURST_TIME, (burst_time << MC_ARB_BURST_TIME__STATE1__SHIFT),\r\n~MC_ARB_BURST_TIME__STATE1_MASK);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nmc_cg_config = RREG32(mmMC_CG_CONFIG) | 0x0000000F;\r\nWREG32(mmMC_CG_CONFIG, mc_cg_config);\r\nWREG32_P(mmMC_ARB_CG, (arb_freq_dest) << MC_ARB_CG__CG_ARB_REQ__SHIFT,\r\n~MC_ARB_CG__CG_ARB_REQ_MASK);\r\nreturn 0;\r\n}\r\nstatic u8 ci_get_ddr3_mclk_frequency_ratio(u32 memory_clock)\r\n{\r\nu8 mc_para_index;\r\nif (memory_clock < 10000)\r\nmc_para_index = 0;\r\nelse if (memory_clock >= 80000)\r\nmc_para_index = 0x0f;\r\nelse\r\nmc_para_index = (u8)((memory_clock - 10000) / 5000 + 1);\r\nreturn mc_para_index;\r\n}\r\nstatic u8 ci_get_mclk_frequency_ratio(u32 memory_clock, bool strobe_mode)\r\n{\r\nu8 mc_para_index;\r\nif (strobe_mode) {\r\nif (memory_clock < 12500)\r\nmc_para_index = 0x00;\r\nelse if (memory_clock > 47500)\r\nmc_para_index = 0x0f;\r\nelse\r\nmc_para_index = (u8)((memory_clock - 10000) / 2500);\r\n} else {\r\nif (memory_clock < 65000)\r\nmc_para_index = 0x00;\r\nelse if (memory_clock > 135000)\r\nmc_para_index = 0x0f;\r\nelse\r\nmc_para_index = (u8)((memory_clock - 60000) / 5000);\r\n}\r\nreturn mc_para_index;\r\n}\r\nstatic void ci_trim_voltage_table_to_fit_state_table(struct amdgpu_device *adev,\r\nu32 max_voltage_steps,\r\nstruct atom_voltage_table *voltage_table)\r\n{\r\nunsigned int i, diff;\r\nif (voltage_table->count <= max_voltage_steps)\r\nreturn;\r\ndiff = voltage_table->count - max_voltage_steps;\r\nfor (i = 0; i < max_voltage_steps; i++)\r\nvoltage_table->entries[i] = voltage_table->entries[i + diff];\r\nvoltage_table->count = max_voltage_steps;\r\n}\r\nstatic struct ci_power_info *ci_get_pi(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = adev->pm.dpm.priv;\r\nreturn pi;\r\n}\r\nstatic struct ci_ps *ci_get_ps(struct amdgpu_ps *rps)\r\n{\r\nstruct ci_ps *ps = rps->ps_priv;\r\nreturn ps;\r\n}\r\nstatic void ci_initialize_powertune_defaults(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nswitch (adev->pdev->device) {\r\ncase 0x6649:\r\ncase 0x6650:\r\ncase 0x6651:\r\ncase 0x6658:\r\ncase 0x665C:\r\ncase 0x665D:\r\ndefault:\r\npi->powertune_defaults = &defaults_bonaire_xt;\r\nbreak;\r\ncase 0x6640:\r\ncase 0x6641:\r\ncase 0x6646:\r\ncase 0x6647:\r\npi->powertune_defaults = &defaults_saturn_xt;\r\nbreak;\r\ncase 0x67B8:\r\ncase 0x67B0:\r\npi->powertune_defaults = &defaults_hawaii_xt;\r\nbreak;\r\ncase 0x67BA:\r\ncase 0x67B1:\r\npi->powertune_defaults = &defaults_hawaii_pro;\r\nbreak;\r\ncase 0x67A0:\r\ncase 0x67A1:\r\ncase 0x67A2:\r\ncase 0x67A8:\r\ncase 0x67A9:\r\ncase 0x67AA:\r\ncase 0x67B9:\r\ncase 0x67BE:\r\npi->powertune_defaults = &defaults_bonaire_xt;\r\nbreak;\r\n}\r\npi->dte_tj_offset = 0;\r\npi->caps_power_containment = true;\r\npi->caps_cac = false;\r\npi->caps_sq_ramping = false;\r\npi->caps_db_ramping = false;\r\npi->caps_td_ramping = false;\r\npi->caps_tcp_ramping = false;\r\nif (pi->caps_power_containment) {\r\npi->caps_cac = true;\r\nif (adev->asic_type == CHIP_HAWAII)\r\npi->enable_bapm_feature = false;\r\nelse\r\npi->enable_bapm_feature = true;\r\npi->enable_tdc_limit_feature = true;\r\npi->enable_pkg_pwr_tracking_feature = true;\r\n}\r\n}\r\nstatic u8 ci_convert_to_vid(u16 vddc)\r\n{\r\nreturn (6200 - (vddc * VOLTAGE_SCALE)) / 25;\r\n}\r\nstatic int ci_populate_bapm_vddc_vid_sidd(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nu8 *hi_vid = pi->smc_powertune_table.BapmVddCVidHiSidd;\r\nu8 *lo_vid = pi->smc_powertune_table.BapmVddCVidLoSidd;\r\nu8 *hi2_vid = pi->smc_powertune_table.BapmVddCVidHiSidd2;\r\nu32 i;\r\nif (adev->pm.dpm.dyn_state.cac_leakage_table.entries == NULL)\r\nreturn -EINVAL;\r\nif (adev->pm.dpm.dyn_state.cac_leakage_table.count > 8)\r\nreturn -EINVAL;\r\nif (adev->pm.dpm.dyn_state.cac_leakage_table.count !=\r\nadev->pm.dpm.dyn_state.vddc_dependency_on_sclk.count)\r\nreturn -EINVAL;\r\nfor (i = 0; i < adev->pm.dpm.dyn_state.cac_leakage_table.count; i++) {\r\nif (adev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_EVV) {\r\nlo_vid[i] = ci_convert_to_vid(adev->pm.dpm.dyn_state.cac_leakage_table.entries[i].vddc1);\r\nhi_vid[i] = ci_convert_to_vid(adev->pm.dpm.dyn_state.cac_leakage_table.entries[i].vddc2);\r\nhi2_vid[i] = ci_convert_to_vid(adev->pm.dpm.dyn_state.cac_leakage_table.entries[i].vddc3);\r\n} else {\r\nlo_vid[i] = ci_convert_to_vid(adev->pm.dpm.dyn_state.cac_leakage_table.entries[i].vddc);\r\nhi_vid[i] = ci_convert_to_vid((u16)adev->pm.dpm.dyn_state.cac_leakage_table.entries[i].leakage);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ci_populate_vddc_vid(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nu8 *vid = pi->smc_powertune_table.VddCVid;\r\nu32 i;\r\nif (pi->vddc_voltage_table.count > 8)\r\nreturn -EINVAL;\r\nfor (i = 0; i < pi->vddc_voltage_table.count; i++)\r\nvid[i] = ci_convert_to_vid(pi->vddc_voltage_table.entries[i].value);\r\nreturn 0;\r\n}\r\nstatic int ci_populate_svi_load_line(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nconst struct ci_pt_defaults *pt_defaults = pi->powertune_defaults;\r\npi->smc_powertune_table.SviLoadLineEn = pt_defaults->svi_load_line_en;\r\npi->smc_powertune_table.SviLoadLineVddC = pt_defaults->svi_load_line_vddc;\r\npi->smc_powertune_table.SviLoadLineTrimVddC = 3;\r\npi->smc_powertune_table.SviLoadLineOffsetVddC = 0;\r\nreturn 0;\r\n}\r\nstatic int ci_populate_tdc_limit(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nconst struct ci_pt_defaults *pt_defaults = pi->powertune_defaults;\r\nu16 tdc_limit;\r\ntdc_limit = adev->pm.dpm.dyn_state.cac_tdp_table->tdc * 256;\r\npi->smc_powertune_table.TDC_VDDC_PkgLimit = cpu_to_be16(tdc_limit);\r\npi->smc_powertune_table.TDC_VDDC_ThrottleReleaseLimitPerc =\r\npt_defaults->tdc_vddc_throttle_release_limit_perc;\r\npi->smc_powertune_table.TDC_MAWt = pt_defaults->tdc_mawt;\r\nreturn 0;\r\n}\r\nstatic int ci_populate_dw8(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nconst struct ci_pt_defaults *pt_defaults = pi->powertune_defaults;\r\nint ret;\r\nret = amdgpu_ci_read_smc_sram_dword(adev,\r\nSMU7_FIRMWARE_HEADER_LOCATION +\r\noffsetof(SMU7_Firmware_Header, PmFuseTable) +\r\noffsetof(SMU7_Discrete_PmFuses, TdcWaterfallCtl),\r\n(u32 *)&pi->smc_powertune_table.TdcWaterfallCtl,\r\npi->sram_end);\r\nif (ret)\r\nreturn -EINVAL;\r\nelse\r\npi->smc_powertune_table.TdcWaterfallCtl = pt_defaults->tdc_waterfall_ctl;\r\nreturn 0;\r\n}\r\nstatic int ci_populate_fuzzy_fan(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nif ((adev->pm.dpm.fan.fan_output_sensitivity & (1 << 15)) ||\r\n(adev->pm.dpm.fan.fan_output_sensitivity == 0))\r\nadev->pm.dpm.fan.fan_output_sensitivity =\r\nadev->pm.dpm.fan.default_fan_output_sensitivity;\r\npi->smc_powertune_table.FuzzyFan_PwmSetDelta =\r\ncpu_to_be16(adev->pm.dpm.fan.fan_output_sensitivity);\r\nreturn 0;\r\n}\r\nstatic int ci_min_max_v_gnbl_pm_lid_from_bapm_vddc(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nu8 *hi_vid = pi->smc_powertune_table.BapmVddCVidHiSidd;\r\nu8 *lo_vid = pi->smc_powertune_table.BapmVddCVidLoSidd;\r\nint i, min, max;\r\nmin = max = hi_vid[0];\r\nfor (i = 0; i < 8; i++) {\r\nif (0 != hi_vid[i]) {\r\nif (min > hi_vid[i])\r\nmin = hi_vid[i];\r\nif (max < hi_vid[i])\r\nmax = hi_vid[i];\r\n}\r\nif (0 != lo_vid[i]) {\r\nif (min > lo_vid[i])\r\nmin = lo_vid[i];\r\nif (max < lo_vid[i])\r\nmax = lo_vid[i];\r\n}\r\n}\r\nif ((min == 0) || (max == 0))\r\nreturn -EINVAL;\r\npi->smc_powertune_table.GnbLPMLMaxVid = (u8)max;\r\npi->smc_powertune_table.GnbLPMLMinVid = (u8)min;\r\nreturn 0;\r\n}\r\nstatic int ci_populate_bapm_vddc_base_leakage_sidd(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nu16 hi_sidd = pi->smc_powertune_table.BapmVddCBaseLeakageHiSidd;\r\nu16 lo_sidd = pi->smc_powertune_table.BapmVddCBaseLeakageLoSidd;\r\nstruct amdgpu_cac_tdp_table *cac_tdp_table =\r\nadev->pm.dpm.dyn_state.cac_tdp_table;\r\nhi_sidd = cac_tdp_table->high_cac_leakage / 100 * 256;\r\nlo_sidd = cac_tdp_table->low_cac_leakage / 100 * 256;\r\npi->smc_powertune_table.BapmVddCBaseLeakageHiSidd = cpu_to_be16(hi_sidd);\r\npi->smc_powertune_table.BapmVddCBaseLeakageLoSidd = cpu_to_be16(lo_sidd);\r\nreturn 0;\r\n}\r\nstatic int ci_populate_bapm_parameters_in_dpm_table(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nconst struct ci_pt_defaults *pt_defaults = pi->powertune_defaults;\r\nSMU7_Discrete_DpmTable *dpm_table = &pi->smc_state_table;\r\nstruct amdgpu_cac_tdp_table *cac_tdp_table =\r\nadev->pm.dpm.dyn_state.cac_tdp_table;\r\nstruct amdgpu_ppm_table *ppm = adev->pm.dpm.dyn_state.ppm_table;\r\nint i, j, k;\r\nconst u16 *def1;\r\nconst u16 *def2;\r\ndpm_table->DefaultTdp = cac_tdp_table->tdp * 256;\r\ndpm_table->TargetTdp = cac_tdp_table->configurable_tdp * 256;\r\ndpm_table->DTETjOffset = (u8)pi->dte_tj_offset;\r\ndpm_table->GpuTjMax =\r\n(u8)(pi->thermal_temp_setting.temperature_high / 1000);\r\ndpm_table->GpuTjHyst = 8;\r\ndpm_table->DTEAmbientTempBase = pt_defaults->dte_ambient_temp_base;\r\nif (ppm) {\r\ndpm_table->PPM_PkgPwrLimit = cpu_to_be16((u16)ppm->dgpu_tdp * 256 / 1000);\r\ndpm_table->PPM_TemperatureLimit = cpu_to_be16((u16)ppm->tj_max * 256);\r\n} else {\r\ndpm_table->PPM_PkgPwrLimit = cpu_to_be16(0);\r\ndpm_table->PPM_TemperatureLimit = cpu_to_be16(0);\r\n}\r\ndpm_table->BAPM_TEMP_GRADIENT = cpu_to_be32(pt_defaults->bapm_temp_gradient);\r\ndef1 = pt_defaults->bapmti_r;\r\ndef2 = pt_defaults->bapmti_rc;\r\nfor (i = 0; i < SMU7_DTE_ITERATIONS; i++) {\r\nfor (j = 0; j < SMU7_DTE_SOURCES; j++) {\r\nfor (k = 0; k < SMU7_DTE_SINKS; k++) {\r\ndpm_table->BAPMTI_R[i][j][k] = cpu_to_be16(*def1);\r\ndpm_table->BAPMTI_RC[i][j][k] = cpu_to_be16(*def2);\r\ndef1++;\r\ndef2++;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ci_populate_pm_base(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nu32 pm_fuse_table_offset;\r\nint ret;\r\nif (pi->caps_power_containment) {\r\nret = amdgpu_ci_read_smc_sram_dword(adev,\r\nSMU7_FIRMWARE_HEADER_LOCATION +\r\noffsetof(SMU7_Firmware_Header, PmFuseTable),\r\n&pm_fuse_table_offset, pi->sram_end);\r\nif (ret)\r\nreturn ret;\r\nret = ci_populate_bapm_vddc_vid_sidd(adev);\r\nif (ret)\r\nreturn ret;\r\nret = ci_populate_vddc_vid(adev);\r\nif (ret)\r\nreturn ret;\r\nret = ci_populate_svi_load_line(adev);\r\nif (ret)\r\nreturn ret;\r\nret = ci_populate_tdc_limit(adev);\r\nif (ret)\r\nreturn ret;\r\nret = ci_populate_dw8(adev);\r\nif (ret)\r\nreturn ret;\r\nret = ci_populate_fuzzy_fan(adev);\r\nif (ret)\r\nreturn ret;\r\nret = ci_min_max_v_gnbl_pm_lid_from_bapm_vddc(adev);\r\nif (ret)\r\nreturn ret;\r\nret = ci_populate_bapm_vddc_base_leakage_sidd(adev);\r\nif (ret)\r\nreturn ret;\r\nret = amdgpu_ci_copy_bytes_to_smc(adev, pm_fuse_table_offset,\r\n(u8 *)&pi->smc_powertune_table,\r\nsizeof(SMU7_Discrete_PmFuses), pi->sram_end);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ci_do_enable_didt(struct amdgpu_device *adev, const bool enable)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nu32 data;\r\nif (pi->caps_sq_ramping) {\r\ndata = RREG32_DIDT(ixDIDT_SQ_CTRL0);\r\nif (enable)\r\ndata |= DIDT_SQ_CTRL0__DIDT_CTRL_EN_MASK;\r\nelse\r\ndata &= ~DIDT_SQ_CTRL0__DIDT_CTRL_EN_MASK;\r\nWREG32_DIDT(ixDIDT_SQ_CTRL0, data);\r\n}\r\nif (pi->caps_db_ramping) {\r\ndata = RREG32_DIDT(ixDIDT_DB_CTRL0);\r\nif (enable)\r\ndata |= DIDT_DB_CTRL0__DIDT_CTRL_EN_MASK;\r\nelse\r\ndata &= ~DIDT_DB_CTRL0__DIDT_CTRL_EN_MASK;\r\nWREG32_DIDT(ixDIDT_DB_CTRL0, data);\r\n}\r\nif (pi->caps_td_ramping) {\r\ndata = RREG32_DIDT(ixDIDT_TD_CTRL0);\r\nif (enable)\r\ndata |= DIDT_TD_CTRL0__DIDT_CTRL_EN_MASK;\r\nelse\r\ndata &= ~DIDT_TD_CTRL0__DIDT_CTRL_EN_MASK;\r\nWREG32_DIDT(ixDIDT_TD_CTRL0, data);\r\n}\r\nif (pi->caps_tcp_ramping) {\r\ndata = RREG32_DIDT(ixDIDT_TCP_CTRL0);\r\nif (enable)\r\ndata |= DIDT_TCP_CTRL0__DIDT_CTRL_EN_MASK;\r\nelse\r\ndata &= ~DIDT_TCP_CTRL0__DIDT_CTRL_EN_MASK;\r\nWREG32_DIDT(ixDIDT_TCP_CTRL0, data);\r\n}\r\n}\r\nstatic int ci_program_pt_config_registers(struct amdgpu_device *adev,\r\nconst struct ci_pt_config_reg *cac_config_regs)\r\n{\r\nconst struct ci_pt_config_reg *config_regs = cac_config_regs;\r\nu32 data;\r\nu32 cache = 0;\r\nif (config_regs == NULL)\r\nreturn -EINVAL;\r\nwhile (config_regs->offset != 0xFFFFFFFF) {\r\nif (config_regs->type == CISLANDS_CONFIGREG_CACHE) {\r\ncache |= ((config_regs->value << config_regs->shift) & config_regs->mask);\r\n} else {\r\nswitch (config_regs->type) {\r\ncase CISLANDS_CONFIGREG_SMC_IND:\r\ndata = RREG32_SMC(config_regs->offset);\r\nbreak;\r\ncase CISLANDS_CONFIGREG_DIDT_IND:\r\ndata = RREG32_DIDT(config_regs->offset);\r\nbreak;\r\ndefault:\r\ndata = RREG32(config_regs->offset);\r\nbreak;\r\n}\r\ndata &= ~config_regs->mask;\r\ndata |= ((config_regs->value << config_regs->shift) & config_regs->mask);\r\ndata |= cache;\r\nswitch (config_regs->type) {\r\ncase CISLANDS_CONFIGREG_SMC_IND:\r\nWREG32_SMC(config_regs->offset, data);\r\nbreak;\r\ncase CISLANDS_CONFIGREG_DIDT_IND:\r\nWREG32_DIDT(config_regs->offset, data);\r\nbreak;\r\ndefault:\r\nWREG32(config_regs->offset, data);\r\nbreak;\r\n}\r\ncache = 0;\r\n}\r\nconfig_regs++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ci_enable_didt(struct amdgpu_device *adev, bool enable)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nint ret;\r\nif (pi->caps_sq_ramping || pi->caps_db_ramping ||\r\npi->caps_td_ramping || pi->caps_tcp_ramping) {\r\nadev->gfx.rlc.funcs->enter_safe_mode(adev);\r\nif (enable) {\r\nret = ci_program_pt_config_registers(adev, didt_config_ci);\r\nif (ret) {\r\nadev->gfx.rlc.funcs->exit_safe_mode(adev);\r\nreturn ret;\r\n}\r\n}\r\nci_do_enable_didt(adev, enable);\r\nadev->gfx.rlc.funcs->exit_safe_mode(adev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ci_enable_power_containment(struct amdgpu_device *adev, bool enable)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nPPSMC_Result smc_result;\r\nint ret = 0;\r\nif (enable) {\r\npi->power_containment_features = 0;\r\nif (pi->caps_power_containment) {\r\nif (pi->enable_bapm_feature) {\r\nsmc_result = amdgpu_ci_send_msg_to_smc(adev, PPSMC_MSG_EnableDTE);\r\nif (smc_result != PPSMC_Result_OK)\r\nret = -EINVAL;\r\nelse\r\npi->power_containment_features |= POWERCONTAINMENT_FEATURE_BAPM;\r\n}\r\nif (pi->enable_tdc_limit_feature) {\r\nsmc_result = amdgpu_ci_send_msg_to_smc(adev, PPSMC_MSG_TDCLimitEnable);\r\nif (smc_result != PPSMC_Result_OK)\r\nret = -EINVAL;\r\nelse\r\npi->power_containment_features |= POWERCONTAINMENT_FEATURE_TDCLimit;\r\n}\r\nif (pi->enable_pkg_pwr_tracking_feature) {\r\nsmc_result = amdgpu_ci_send_msg_to_smc(adev, PPSMC_MSG_PkgPwrLimitEnable);\r\nif (smc_result != PPSMC_Result_OK) {\r\nret = -EINVAL;\r\n} else {\r\nstruct amdgpu_cac_tdp_table *cac_tdp_table =\r\nadev->pm.dpm.dyn_state.cac_tdp_table;\r\nu32 default_pwr_limit =\r\n(u32)(cac_tdp_table->maximum_power_delivery_limit * 256);\r\npi->power_containment_features |= POWERCONTAINMENT_FEATURE_PkgPwrLimit;\r\nci_set_power_limit(adev, default_pwr_limit);\r\n}\r\n}\r\n}\r\n} else {\r\nif (pi->caps_power_containment && pi->power_containment_features) {\r\nif (pi->power_containment_features & POWERCONTAINMENT_FEATURE_TDCLimit)\r\namdgpu_ci_send_msg_to_smc(adev, PPSMC_MSG_TDCLimitDisable);\r\nif (pi->power_containment_features & POWERCONTAINMENT_FEATURE_BAPM)\r\namdgpu_ci_send_msg_to_smc(adev, PPSMC_MSG_DisableDTE);\r\nif (pi->power_containment_features & POWERCONTAINMENT_FEATURE_PkgPwrLimit)\r\namdgpu_ci_send_msg_to_smc(adev, PPSMC_MSG_PkgPwrLimitDisable);\r\npi->power_containment_features = 0;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int ci_enable_smc_cac(struct amdgpu_device *adev, bool enable)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nPPSMC_Result smc_result;\r\nint ret = 0;\r\nif (pi->caps_cac) {\r\nif (enable) {\r\nsmc_result = amdgpu_ci_send_msg_to_smc(adev, PPSMC_MSG_EnableCac);\r\nif (smc_result != PPSMC_Result_OK) {\r\nret = -EINVAL;\r\npi->cac_enabled = false;\r\n} else {\r\npi->cac_enabled = true;\r\n}\r\n} else if (pi->cac_enabled) {\r\namdgpu_ci_send_msg_to_smc(adev, PPSMC_MSG_DisableCac);\r\npi->cac_enabled = false;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int ci_enable_thermal_based_sclk_dpm(struct amdgpu_device *adev,\r\nbool enable)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nPPSMC_Result smc_result = PPSMC_Result_OK;\r\nif (pi->thermal_sclk_dpm_enabled) {\r\nif (enable)\r\nsmc_result = amdgpu_ci_send_msg_to_smc(adev, PPSMC_MSG_ENABLE_THERMAL_DPM);\r\nelse\r\nsmc_result = amdgpu_ci_send_msg_to_smc(adev, PPSMC_MSG_DISABLE_THERMAL_DPM);\r\n}\r\nif (smc_result == PPSMC_Result_OK)\r\nreturn 0;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nstatic int ci_power_control_set_level(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nstruct amdgpu_cac_tdp_table *cac_tdp_table =\r\nadev->pm.dpm.dyn_state.cac_tdp_table;\r\ns32 adjust_percent;\r\ns32 target_tdp;\r\nint ret = 0;\r\nbool adjust_polarity = false;\r\nif (pi->caps_power_containment) {\r\nadjust_percent = adjust_polarity ?\r\nadev->pm.dpm.tdp_adjustment : (-1 * adev->pm.dpm.tdp_adjustment);\r\ntarget_tdp = ((100 + adjust_percent) *\r\n(s32)cac_tdp_table->configurable_tdp) / 100;\r\nret = ci_set_overdrive_target_tdp(adev, (u32)target_tdp);\r\n}\r\nreturn ret;\r\n}\r\nstatic void ci_dpm_powergate_uvd(struct amdgpu_device *adev, bool gate)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\npi->uvd_power_gated = gate;\r\nif (gate) {\r\namdgpu_set_powergating_state(adev, AMD_IP_BLOCK_TYPE_UVD,\r\nAMD_PG_STATE_GATE);\r\nci_update_uvd_dpm(adev, gate);\r\n} else {\r\namdgpu_set_powergating_state(adev, AMD_IP_BLOCK_TYPE_UVD,\r\nAMD_PG_STATE_UNGATE);\r\nci_update_uvd_dpm(adev, gate);\r\n}\r\n}\r\nstatic bool ci_dpm_vblank_too_short(struct amdgpu_device *adev)\r\n{\r\nu32 vblank_time = amdgpu_dpm_get_vblank_time(adev);\r\nu32 switch_limit = adev->mc.vram_type == AMDGPU_VRAM_TYPE_GDDR5 ? 450 : 300;\r\nif (amdgpu_dpm_get_vrefresh(adev) > 120)\r\nreturn true;\r\nif (vblank_time < switch_limit)\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic void ci_apply_state_adjust_rules(struct amdgpu_device *adev,\r\nstruct amdgpu_ps *rps)\r\n{\r\nstruct ci_ps *ps = ci_get_ps(rps);\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nstruct amdgpu_clock_and_voltage_limits *max_limits;\r\nbool disable_mclk_switching;\r\nu32 sclk, mclk;\r\nint i;\r\nif (rps->vce_active) {\r\nrps->evclk = adev->pm.dpm.vce_states[adev->pm.dpm.vce_level].evclk;\r\nrps->ecclk = adev->pm.dpm.vce_states[adev->pm.dpm.vce_level].ecclk;\r\n} else {\r\nrps->evclk = 0;\r\nrps->ecclk = 0;\r\n}\r\nif ((adev->pm.dpm.new_active_crtc_count > 1) ||\r\nci_dpm_vblank_too_short(adev))\r\ndisable_mclk_switching = true;\r\nelse\r\ndisable_mclk_switching = false;\r\nif ((rps->class & ATOM_PPLIB_CLASSIFICATION_UI_MASK) == ATOM_PPLIB_CLASSIFICATION_UI_BATTERY)\r\npi->battery_state = true;\r\nelse\r\npi->battery_state = false;\r\nif (adev->pm.dpm.ac_power)\r\nmax_limits = &adev->pm.dpm.dyn_state.max_clock_voltage_on_ac;\r\nelse\r\nmax_limits = &adev->pm.dpm.dyn_state.max_clock_voltage_on_dc;\r\nif (adev->pm.dpm.ac_power == false) {\r\nfor (i = 0; i < ps->performance_level_count; i++) {\r\nif (ps->performance_levels[i].mclk > max_limits->mclk)\r\nps->performance_levels[i].mclk = max_limits->mclk;\r\nif (ps->performance_levels[i].sclk > max_limits->sclk)\r\nps->performance_levels[i].sclk = max_limits->sclk;\r\n}\r\n}\r\nif (disable_mclk_switching) {\r\nmclk = ps->performance_levels[ps->performance_level_count - 1].mclk;\r\nsclk = ps->performance_levels[0].sclk;\r\n} else {\r\nmclk = ps->performance_levels[0].mclk;\r\nsclk = ps->performance_levels[0].sclk;\r\n}\r\nif (adev->pm.pm_display_cfg.min_core_set_clock > sclk)\r\nsclk = adev->pm.pm_display_cfg.min_core_set_clock;\r\nif (adev->pm.pm_display_cfg.min_mem_set_clock > mclk)\r\nmclk = adev->pm.pm_display_cfg.min_mem_set_clock;\r\nif (rps->vce_active) {\r\nif (sclk < adev->pm.dpm.vce_states[adev->pm.dpm.vce_level].sclk)\r\nsclk = adev->pm.dpm.vce_states[adev->pm.dpm.vce_level].sclk;\r\nif (mclk < adev->pm.dpm.vce_states[adev->pm.dpm.vce_level].mclk)\r\nmclk = adev->pm.dpm.vce_states[adev->pm.dpm.vce_level].mclk;\r\n}\r\nps->performance_levels[0].sclk = sclk;\r\nps->performance_levels[0].mclk = mclk;\r\nif (ps->performance_levels[1].sclk < ps->performance_levels[0].sclk)\r\nps->performance_levels[1].sclk = ps->performance_levels[0].sclk;\r\nif (disable_mclk_switching) {\r\nif (ps->performance_levels[0].mclk < ps->performance_levels[1].mclk)\r\nps->performance_levels[0].mclk = ps->performance_levels[1].mclk;\r\n} else {\r\nif (ps->performance_levels[1].mclk < ps->performance_levels[0].mclk)\r\nps->performance_levels[1].mclk = ps->performance_levels[0].mclk;\r\n}\r\n}\r\nstatic int ci_thermal_set_temperature_range(struct amdgpu_device *adev,\r\nint min_temp, int max_temp)\r\n{\r\nint low_temp = 0 * 1000;\r\nint high_temp = 255 * 1000;\r\nu32 tmp;\r\nif (low_temp < min_temp)\r\nlow_temp = min_temp;\r\nif (high_temp > max_temp)\r\nhigh_temp = max_temp;\r\nif (high_temp < low_temp) {\r\nDRM_ERROR("invalid thermal range: %d - %d\n", low_temp, high_temp);\r\nreturn -EINVAL;\r\n}\r\ntmp = RREG32_SMC(ixCG_THERMAL_INT);\r\ntmp &= ~(CG_THERMAL_INT__DIG_THERM_INTH_MASK | CG_THERMAL_INT__DIG_THERM_INTL_MASK);\r\ntmp |= ((high_temp / 1000) << CG_THERMAL_INT__DIG_THERM_INTH__SHIFT) |\r\n((low_temp / 1000)) << CG_THERMAL_INT__DIG_THERM_INTL__SHIFT;\r\nWREG32_SMC(ixCG_THERMAL_INT, tmp);\r\n#if 0\r\ntmp = RREG32_SMC(ixCG_THERMAL_CTRL);\r\ntmp &= DIG_THERM_DPM_MASK;\r\ntmp |= DIG_THERM_DPM(high_temp / 1000);\r\nWREG32_SMC(ixCG_THERMAL_CTRL, tmp);\r\n#endif\r\nadev->pm.dpm.thermal.min_temp = low_temp;\r\nadev->pm.dpm.thermal.max_temp = high_temp;\r\nreturn 0;\r\n}\r\nstatic int ci_thermal_enable_alert(struct amdgpu_device *adev,\r\nbool enable)\r\n{\r\nu32 thermal_int = RREG32_SMC(ixCG_THERMAL_INT);\r\nPPSMC_Result result;\r\nif (enable) {\r\nthermal_int &= ~(CG_THERMAL_INT_CTRL__THERM_INTH_MASK_MASK |\r\nCG_THERMAL_INT_CTRL__THERM_INTL_MASK_MASK);\r\nWREG32_SMC(ixCG_THERMAL_INT, thermal_int);\r\nresult = amdgpu_ci_send_msg_to_smc(adev, PPSMC_MSG_Thermal_Cntl_Enable);\r\nif (result != PPSMC_Result_OK) {\r\nDRM_DEBUG_KMS("Could not enable thermal interrupts.\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nthermal_int |= CG_THERMAL_INT_CTRL__THERM_INTH_MASK_MASK |\r\nCG_THERMAL_INT_CTRL__THERM_INTL_MASK_MASK;\r\nWREG32_SMC(ixCG_THERMAL_INT, thermal_int);\r\nresult = amdgpu_ci_send_msg_to_smc(adev, PPSMC_MSG_Thermal_Cntl_Disable);\r\nif (result != PPSMC_Result_OK) {\r\nDRM_DEBUG_KMS("Could not disable thermal interrupts.\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void ci_fan_ctrl_set_static_mode(struct amdgpu_device *adev, u32 mode)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nu32 tmp;\r\nif (pi->fan_ctrl_is_in_default_mode) {\r\ntmp = (RREG32_SMC(ixCG_FDO_CTRL2) & CG_FDO_CTRL2__FDO_PWM_MODE_MASK)\r\n>> CG_FDO_CTRL2__FDO_PWM_MODE__SHIFT;\r\npi->fan_ctrl_default_mode = tmp;\r\ntmp = (RREG32_SMC(ixCG_FDO_CTRL2) & CG_FDO_CTRL2__TMIN_MASK)\r\n>> CG_FDO_CTRL2__TMIN__SHIFT;\r\npi->t_min = tmp;\r\npi->fan_ctrl_is_in_default_mode = false;\r\n}\r\ntmp = RREG32_SMC(ixCG_FDO_CTRL2) & ~CG_FDO_CTRL2__TMIN_MASK;\r\ntmp |= 0 << CG_FDO_CTRL2__TMIN__SHIFT;\r\nWREG32_SMC(ixCG_FDO_CTRL2, tmp);\r\ntmp = RREG32_SMC(ixCG_FDO_CTRL2) & ~CG_FDO_CTRL2__FDO_PWM_MODE_MASK;\r\ntmp |= mode << CG_FDO_CTRL2__FDO_PWM_MODE__SHIFT;\r\nWREG32_SMC(ixCG_FDO_CTRL2, tmp);\r\n}\r\nstatic int ci_thermal_setup_fan_table(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nSMU7_Discrete_FanTable fan_table = { FDO_MODE_HARDWARE };\r\nu32 duty100;\r\nu32 t_diff1, t_diff2, pwm_diff1, pwm_diff2;\r\nu16 fdo_min, slope1, slope2;\r\nu32 reference_clock, tmp;\r\nint ret;\r\nu64 tmp64;\r\nif (!pi->fan_table_start) {\r\nadev->pm.dpm.fan.ucode_fan_control = false;\r\nreturn 0;\r\n}\r\nduty100 = (RREG32_SMC(ixCG_FDO_CTRL1) & CG_FDO_CTRL1__FMAX_DUTY100_MASK)\r\n>> CG_FDO_CTRL1__FMAX_DUTY100__SHIFT;\r\nif (duty100 == 0) {\r\nadev->pm.dpm.fan.ucode_fan_control = false;\r\nreturn 0;\r\n}\r\ntmp64 = (u64)adev->pm.dpm.fan.pwm_min * duty100;\r\ndo_div(tmp64, 10000);\r\nfdo_min = (u16)tmp64;\r\nt_diff1 = adev->pm.dpm.fan.t_med - adev->pm.dpm.fan.t_min;\r\nt_diff2 = adev->pm.dpm.fan.t_high - adev->pm.dpm.fan.t_med;\r\npwm_diff1 = adev->pm.dpm.fan.pwm_med - adev->pm.dpm.fan.pwm_min;\r\npwm_diff2 = adev->pm.dpm.fan.pwm_high - adev->pm.dpm.fan.pwm_med;\r\nslope1 = (u16)((50 + ((16 * duty100 * pwm_diff1) / t_diff1)) / 100);\r\nslope2 = (u16)((50 + ((16 * duty100 * pwm_diff2) / t_diff2)) / 100);\r\nfan_table.TempMin = cpu_to_be16((50 + adev->pm.dpm.fan.t_min) / 100);\r\nfan_table.TempMed = cpu_to_be16((50 + adev->pm.dpm.fan.t_med) / 100);\r\nfan_table.TempMax = cpu_to_be16((50 + adev->pm.dpm.fan.t_max) / 100);\r\nfan_table.Slope1 = cpu_to_be16(slope1);\r\nfan_table.Slope2 = cpu_to_be16(slope2);\r\nfan_table.FdoMin = cpu_to_be16(fdo_min);\r\nfan_table.HystDown = cpu_to_be16(adev->pm.dpm.fan.t_hyst);\r\nfan_table.HystUp = cpu_to_be16(1);\r\nfan_table.HystSlope = cpu_to_be16(1);\r\nfan_table.TempRespLim = cpu_to_be16(5);\r\nreference_clock = amdgpu_asic_get_xclk(adev);\r\nfan_table.RefreshPeriod = cpu_to_be32((adev->pm.dpm.fan.cycle_delay *\r\nreference_clock) / 1600);\r\nfan_table.FdoMax = cpu_to_be16((u16)duty100);\r\ntmp = (RREG32_SMC(ixCG_MULT_THERMAL_CTRL) & CG_MULT_THERMAL_CTRL__TEMP_SEL_MASK)\r\n>> CG_MULT_THERMAL_CTRL__TEMP_SEL__SHIFT;\r\nfan_table.TempSrc = (uint8_t)tmp;\r\nret = amdgpu_ci_copy_bytes_to_smc(adev,\r\npi->fan_table_start,\r\n(u8 *)(&fan_table),\r\nsizeof(fan_table),\r\npi->sram_end);\r\nif (ret) {\r\nDRM_ERROR("Failed to load fan table to the SMC.");\r\nadev->pm.dpm.fan.ucode_fan_control = false;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ci_fan_ctrl_start_smc_fan_control(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nPPSMC_Result ret;\r\nif (pi->caps_od_fuzzy_fan_control_support) {\r\nret = amdgpu_ci_send_msg_to_smc_with_parameter(adev,\r\nPPSMC_StartFanControl,\r\nFAN_CONTROL_FUZZY);\r\nif (ret != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\nret = amdgpu_ci_send_msg_to_smc_with_parameter(adev,\r\nPPSMC_MSG_SetFanPwmMax,\r\nadev->pm.dpm.fan.default_max_fan_pwm);\r\nif (ret != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\n} else {\r\nret = amdgpu_ci_send_msg_to_smc_with_parameter(adev,\r\nPPSMC_StartFanControl,\r\nFAN_CONTROL_TABLE);\r\nif (ret != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\n}\r\npi->fan_is_controlled_by_smc = true;\r\nreturn 0;\r\n}\r\nstatic int ci_fan_ctrl_stop_smc_fan_control(struct amdgpu_device *adev)\r\n{\r\nPPSMC_Result ret;\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nret = amdgpu_ci_send_msg_to_smc(adev, PPSMC_StopFanControl);\r\nif (ret == PPSMC_Result_OK) {\r\npi->fan_is_controlled_by_smc = false;\r\nreturn 0;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int ci_dpm_get_fan_speed_percent(struct amdgpu_device *adev,\r\nu32 *speed)\r\n{\r\nu32 duty, duty100;\r\nu64 tmp64;\r\nif (adev->pm.no_fan)\r\nreturn -ENOENT;\r\nduty100 = (RREG32_SMC(ixCG_FDO_CTRL1) & CG_FDO_CTRL1__FMAX_DUTY100_MASK)\r\n>> CG_FDO_CTRL1__FMAX_DUTY100__SHIFT;\r\nduty = (RREG32_SMC(ixCG_THERMAL_STATUS) & CG_THERMAL_STATUS__FDO_PWM_DUTY_MASK)\r\n>> CG_THERMAL_STATUS__FDO_PWM_DUTY__SHIFT;\r\nif (duty100 == 0)\r\nreturn -EINVAL;\r\ntmp64 = (u64)duty * 100;\r\ndo_div(tmp64, duty100);\r\n*speed = (u32)tmp64;\r\nif (*speed > 100)\r\n*speed = 100;\r\nreturn 0;\r\n}\r\nstatic int ci_dpm_set_fan_speed_percent(struct amdgpu_device *adev,\r\nu32 speed)\r\n{\r\nu32 tmp;\r\nu32 duty, duty100;\r\nu64 tmp64;\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nif (adev->pm.no_fan)\r\nreturn -ENOENT;\r\nif (pi->fan_is_controlled_by_smc)\r\nreturn -EINVAL;\r\nif (speed > 100)\r\nreturn -EINVAL;\r\nduty100 = (RREG32_SMC(ixCG_FDO_CTRL1) & CG_FDO_CTRL1__FMAX_DUTY100_MASK)\r\n>> CG_FDO_CTRL1__FMAX_DUTY100__SHIFT;\r\nif (duty100 == 0)\r\nreturn -EINVAL;\r\ntmp64 = (u64)speed * duty100;\r\ndo_div(tmp64, 100);\r\nduty = (u32)tmp64;\r\ntmp = RREG32_SMC(ixCG_FDO_CTRL0) & ~CG_FDO_CTRL0__FDO_STATIC_DUTY_MASK;\r\ntmp |= duty << CG_FDO_CTRL0__FDO_STATIC_DUTY__SHIFT;\r\nWREG32_SMC(ixCG_FDO_CTRL0, tmp);\r\nreturn 0;\r\n}\r\nstatic void ci_dpm_set_fan_control_mode(struct amdgpu_device *adev, u32 mode)\r\n{\r\nswitch (mode) {\r\ncase AMD_FAN_CTRL_NONE:\r\nif (adev->pm.dpm.fan.ucode_fan_control)\r\nci_fan_ctrl_stop_smc_fan_control(adev);\r\nci_dpm_set_fan_speed_percent(adev, 100);\r\nbreak;\r\ncase AMD_FAN_CTRL_MANUAL:\r\nif (adev->pm.dpm.fan.ucode_fan_control)\r\nci_fan_ctrl_stop_smc_fan_control(adev);\r\nbreak;\r\ncase AMD_FAN_CTRL_AUTO:\r\nif (adev->pm.dpm.fan.ucode_fan_control)\r\nci_thermal_start_smc_fan_control(adev);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic u32 ci_dpm_get_fan_control_mode(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nif (pi->fan_is_controlled_by_smc)\r\nreturn AMD_FAN_CTRL_AUTO;\r\nelse\r\nreturn AMD_FAN_CTRL_MANUAL;\r\n}\r\nstatic void ci_fan_ctrl_set_default_mode(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nu32 tmp;\r\nif (!pi->fan_ctrl_is_in_default_mode) {\r\ntmp = RREG32_SMC(ixCG_FDO_CTRL2) & ~CG_FDO_CTRL2__FDO_PWM_MODE_MASK;\r\ntmp |= pi->fan_ctrl_default_mode << CG_FDO_CTRL2__FDO_PWM_MODE__SHIFT;\r\nWREG32_SMC(ixCG_FDO_CTRL2, tmp);\r\ntmp = RREG32_SMC(ixCG_FDO_CTRL2) & ~CG_FDO_CTRL2__TMIN_MASK;\r\ntmp |= pi->t_min << CG_FDO_CTRL2__TMIN__SHIFT;\r\nWREG32_SMC(ixCG_FDO_CTRL2, tmp);\r\npi->fan_ctrl_is_in_default_mode = true;\r\n}\r\n}\r\nstatic void ci_thermal_start_smc_fan_control(struct amdgpu_device *adev)\r\n{\r\nif (adev->pm.dpm.fan.ucode_fan_control) {\r\nci_fan_ctrl_start_smc_fan_control(adev);\r\nci_fan_ctrl_set_static_mode(adev, FDO_PWM_MODE_STATIC);\r\n}\r\n}\r\nstatic void ci_thermal_initialize(struct amdgpu_device *adev)\r\n{\r\nu32 tmp;\r\nif (adev->pm.fan_pulses_per_revolution) {\r\ntmp = RREG32_SMC(ixCG_TACH_CTRL) & ~CG_TACH_CTRL__EDGE_PER_REV_MASK;\r\ntmp |= (adev->pm.fan_pulses_per_revolution - 1)\r\n<< CG_TACH_CTRL__EDGE_PER_REV__SHIFT;\r\nWREG32_SMC(ixCG_TACH_CTRL, tmp);\r\n}\r\ntmp = RREG32_SMC(ixCG_FDO_CTRL2) & ~CG_FDO_CTRL2__TACH_PWM_RESP_RATE_MASK;\r\ntmp |= 0x28 << CG_FDO_CTRL2__TACH_PWM_RESP_RATE__SHIFT;\r\nWREG32_SMC(ixCG_FDO_CTRL2, tmp);\r\n}\r\nstatic int ci_thermal_start_thermal_controller(struct amdgpu_device *adev)\r\n{\r\nint ret;\r\nci_thermal_initialize(adev);\r\nret = ci_thermal_set_temperature_range(adev, CISLANDS_TEMP_RANGE_MIN, CISLANDS_TEMP_RANGE_MAX);\r\nif (ret)\r\nreturn ret;\r\nret = ci_thermal_enable_alert(adev, true);\r\nif (ret)\r\nreturn ret;\r\nif (adev->pm.dpm.fan.ucode_fan_control) {\r\nret = ci_thermal_setup_fan_table(adev);\r\nif (ret)\r\nreturn ret;\r\nci_thermal_start_smc_fan_control(adev);\r\n}\r\nreturn 0;\r\n}\r\nstatic void ci_thermal_stop_thermal_controller(struct amdgpu_device *adev)\r\n{\r\nif (!adev->pm.no_fan)\r\nci_fan_ctrl_set_default_mode(adev);\r\n}\r\nstatic int ci_read_smc_soft_register(struct amdgpu_device *adev,\r\nu16 reg_offset, u32 *value)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nreturn amdgpu_ci_read_smc_sram_dword(adev,\r\npi->soft_regs_start + reg_offset,\r\nvalue, pi->sram_end);\r\n}\r\nstatic int ci_write_smc_soft_register(struct amdgpu_device *adev,\r\nu16 reg_offset, u32 value)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nreturn amdgpu_ci_write_smc_sram_dword(adev,\r\npi->soft_regs_start + reg_offset,\r\nvalue, pi->sram_end);\r\n}\r\nstatic void ci_init_fps_limits(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nSMU7_Discrete_DpmTable *table = &pi->smc_state_table;\r\nif (pi->caps_fps) {\r\nu16 tmp;\r\ntmp = 45;\r\ntable->FpsHighT = cpu_to_be16(tmp);\r\ntmp = 30;\r\ntable->FpsLowT = cpu_to_be16(tmp);\r\n}\r\n}\r\nstatic int ci_update_sclk_t(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nint ret = 0;\r\nu32 low_sclk_interrupt_t = 0;\r\nif (pi->caps_sclk_throttle_low_notification) {\r\nlow_sclk_interrupt_t = cpu_to_be32(pi->low_sclk_interrupt_t);\r\nret = amdgpu_ci_copy_bytes_to_smc(adev,\r\npi->dpm_table_start +\r\noffsetof(SMU7_Discrete_DpmTable, LowSclkInterruptT),\r\n(u8 *)&low_sclk_interrupt_t,\r\nsizeof(u32), pi->sram_end);\r\n}\r\nreturn ret;\r\n}\r\nstatic void ci_get_leakage_voltages(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nu16 leakage_id, virtual_voltage_id;\r\nu16 vddc, vddci;\r\nint i;\r\npi->vddc_leakage.count = 0;\r\npi->vddci_leakage.count = 0;\r\nif (adev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_EVV) {\r\nfor (i = 0; i < CISLANDS_MAX_LEAKAGE_COUNT; i++) {\r\nvirtual_voltage_id = ATOM_VIRTUAL_VOLTAGE_ID0 + i;\r\nif (amdgpu_atombios_get_voltage_evv(adev, virtual_voltage_id, &vddc) != 0)\r\ncontinue;\r\nif (vddc != 0 && vddc != virtual_voltage_id) {\r\npi->vddc_leakage.actual_voltage[pi->vddc_leakage.count] = vddc;\r\npi->vddc_leakage.leakage_id[pi->vddc_leakage.count] = virtual_voltage_id;\r\npi->vddc_leakage.count++;\r\n}\r\n}\r\n} else if (amdgpu_atombios_get_leakage_id_from_vbios(adev, &leakage_id) == 0) {\r\nfor (i = 0; i < CISLANDS_MAX_LEAKAGE_COUNT; i++) {\r\nvirtual_voltage_id = ATOM_VIRTUAL_VOLTAGE_ID0 + i;\r\nif (amdgpu_atombios_get_leakage_vddc_based_on_leakage_params(adev, &vddc, &vddci,\r\nvirtual_voltage_id,\r\nleakage_id) == 0) {\r\nif (vddc != 0 && vddc != virtual_voltage_id) {\r\npi->vddc_leakage.actual_voltage[pi->vddc_leakage.count] = vddc;\r\npi->vddc_leakage.leakage_id[pi->vddc_leakage.count] = virtual_voltage_id;\r\npi->vddc_leakage.count++;\r\n}\r\nif (vddci != 0 && vddci != virtual_voltage_id) {\r\npi->vddci_leakage.actual_voltage[pi->vddci_leakage.count] = vddci;\r\npi->vddci_leakage.leakage_id[pi->vddci_leakage.count] = virtual_voltage_id;\r\npi->vddci_leakage.count++;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic void ci_set_dpm_event_sources(struct amdgpu_device *adev, u32 sources)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nbool want_thermal_protection;\r\nenum amdgpu_dpm_event_src dpm_event_src;\r\nu32 tmp;\r\nswitch (sources) {\r\ncase 0:\r\ndefault:\r\nwant_thermal_protection = false;\r\nbreak;\r\ncase (1 << AMDGPU_DPM_AUTO_THROTTLE_SRC_THERMAL):\r\nwant_thermal_protection = true;\r\ndpm_event_src = AMDGPU_DPM_EVENT_SRC_DIGITAL;\r\nbreak;\r\ncase (1 << AMDGPU_DPM_AUTO_THROTTLE_SRC_EXTERNAL):\r\nwant_thermal_protection = true;\r\ndpm_event_src = AMDGPU_DPM_EVENT_SRC_EXTERNAL;\r\nbreak;\r\ncase ((1 << AMDGPU_DPM_AUTO_THROTTLE_SRC_EXTERNAL) |\r\n(1 << AMDGPU_DPM_AUTO_THROTTLE_SRC_THERMAL)):\r\nwant_thermal_protection = true;\r\ndpm_event_src = AMDGPU_DPM_EVENT_SRC_DIGIAL_OR_EXTERNAL;\r\nbreak;\r\n}\r\nif (want_thermal_protection) {\r\n#if 0\r\ntmp = RREG32_SMC(ixCG_THERMAL_CTRL);\r\ntmp &= DPM_EVENT_SRC_MASK;\r\ntmp |= DPM_EVENT_SRC(dpm_event_src);\r\nWREG32_SMC(ixCG_THERMAL_CTRL, tmp);\r\n#endif\r\ntmp = RREG32_SMC(ixGENERAL_PWRMGT);\r\nif (pi->thermal_protection)\r\ntmp &= ~GENERAL_PWRMGT__THERMAL_PROTECTION_DIS_MASK;\r\nelse\r\ntmp |= GENERAL_PWRMGT__THERMAL_PROTECTION_DIS_MASK;\r\nWREG32_SMC(ixGENERAL_PWRMGT, tmp);\r\n} else {\r\ntmp = RREG32_SMC(ixGENERAL_PWRMGT);\r\ntmp |= GENERAL_PWRMGT__THERMAL_PROTECTION_DIS_MASK;\r\nWREG32_SMC(ixGENERAL_PWRMGT, tmp);\r\n}\r\n}\r\nstatic void ci_enable_auto_throttle_source(struct amdgpu_device *adev,\r\nenum amdgpu_dpm_auto_throttle_src source,\r\nbool enable)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nif (enable) {\r\nif (!(pi->active_auto_throttle_sources & (1 << source))) {\r\npi->active_auto_throttle_sources |= 1 << source;\r\nci_set_dpm_event_sources(adev, pi->active_auto_throttle_sources);\r\n}\r\n} else {\r\nif (pi->active_auto_throttle_sources & (1 << source)) {\r\npi->active_auto_throttle_sources &= ~(1 << source);\r\nci_set_dpm_event_sources(adev, pi->active_auto_throttle_sources);\r\n}\r\n}\r\n}\r\nstatic void ci_enable_vr_hot_gpio_interrupt(struct amdgpu_device *adev)\r\n{\r\nif (adev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_REGULATOR_HOT)\r\namdgpu_ci_send_msg_to_smc(adev, PPSMC_MSG_EnableVRHotGPIOInterrupt);\r\n}\r\nstatic int ci_unfreeze_sclk_mclk_dpm(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nPPSMC_Result smc_result;\r\nif (!pi->need_update_smu7_dpm_table)\r\nreturn 0;\r\nif ((!pi->sclk_dpm_key_disabled) &&\r\n(pi->need_update_smu7_dpm_table & (DPMTABLE_OD_UPDATE_SCLK | DPMTABLE_UPDATE_SCLK))) {\r\nsmc_result = amdgpu_ci_send_msg_to_smc(adev, PPSMC_MSG_SCLKDPM_UnfreezeLevel);\r\nif (smc_result != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\n}\r\nif ((!pi->mclk_dpm_key_disabled) &&\r\n(pi->need_update_smu7_dpm_table & DPMTABLE_OD_UPDATE_MCLK)) {\r\nsmc_result = amdgpu_ci_send_msg_to_smc(adev, PPSMC_MSG_MCLKDPM_UnfreezeLevel);\r\nif (smc_result != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\n}\r\npi->need_update_smu7_dpm_table = 0;\r\nreturn 0;\r\n}\r\nstatic int ci_enable_sclk_mclk_dpm(struct amdgpu_device *adev, bool enable)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nPPSMC_Result smc_result;\r\nif (enable) {\r\nif (!pi->sclk_dpm_key_disabled) {\r\nsmc_result = amdgpu_ci_send_msg_to_smc(adev, PPSMC_MSG_DPM_Enable);\r\nif (smc_result != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\n}\r\nif (!pi->mclk_dpm_key_disabled) {\r\nsmc_result = amdgpu_ci_send_msg_to_smc(adev, PPSMC_MSG_MCLKDPM_Enable);\r\nif (smc_result != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\nWREG32_P(mmMC_SEQ_CNTL_3, MC_SEQ_CNTL_3__CAC_EN_MASK,\r\n~MC_SEQ_CNTL_3__CAC_EN_MASK);\r\nWREG32_SMC(ixLCAC_MC0_CNTL, 0x05);\r\nWREG32_SMC(ixLCAC_MC1_CNTL, 0x05);\r\nWREG32_SMC(ixLCAC_CPL_CNTL, 0x100005);\r\nudelay(10);\r\nWREG32_SMC(ixLCAC_MC0_CNTL, 0x400005);\r\nWREG32_SMC(ixLCAC_MC1_CNTL, 0x400005);\r\nWREG32_SMC(ixLCAC_CPL_CNTL, 0x500005);\r\n}\r\n} else {\r\nif (!pi->sclk_dpm_key_disabled) {\r\nsmc_result = amdgpu_ci_send_msg_to_smc(adev, PPSMC_MSG_DPM_Disable);\r\nif (smc_result != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\n}\r\nif (!pi->mclk_dpm_key_disabled) {\r\nsmc_result = amdgpu_ci_send_msg_to_smc(adev, PPSMC_MSG_MCLKDPM_Disable);\r\nif (smc_result != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ci_start_dpm(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nPPSMC_Result smc_result;\r\nint ret;\r\nu32 tmp;\r\ntmp = RREG32_SMC(ixGENERAL_PWRMGT);\r\ntmp |= GENERAL_PWRMGT__GLOBAL_PWRMGT_EN_MASK;\r\nWREG32_SMC(ixGENERAL_PWRMGT, tmp);\r\ntmp = RREG32_SMC(ixSCLK_PWRMGT_CNTL);\r\ntmp |= SCLK_PWRMGT_CNTL__DYNAMIC_PM_EN_MASK;\r\nWREG32_SMC(ixSCLK_PWRMGT_CNTL, tmp);\r\nci_write_smc_soft_register(adev, offsetof(SMU7_SoftRegisters, VoltageChangeTimeout), 0x1000);\r\nWREG32_P(mmBIF_LNCNT_RESET, 0, ~BIF_LNCNT_RESET__RESET_LNCNT_EN_MASK);\r\nsmc_result = amdgpu_ci_send_msg_to_smc(adev, PPSMC_MSG_Voltage_Cntl_Enable);\r\nif (smc_result != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\nret = ci_enable_sclk_mclk_dpm(adev, true);\r\nif (ret)\r\nreturn ret;\r\nif (!pi->pcie_dpm_key_disabled) {\r\nsmc_result = amdgpu_ci_send_msg_to_smc(adev, PPSMC_MSG_PCIeDPM_Enable);\r\nif (smc_result != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ci_freeze_sclk_mclk_dpm(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nPPSMC_Result smc_result;\r\nif (!pi->need_update_smu7_dpm_table)\r\nreturn 0;\r\nif ((!pi->sclk_dpm_key_disabled) &&\r\n(pi->need_update_smu7_dpm_table & (DPMTABLE_OD_UPDATE_SCLK | DPMTABLE_UPDATE_SCLK))) {\r\nsmc_result = amdgpu_ci_send_msg_to_smc(adev, PPSMC_MSG_SCLKDPM_FreezeLevel);\r\nif (smc_result != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\n}\r\nif ((!pi->mclk_dpm_key_disabled) &&\r\n(pi->need_update_smu7_dpm_table & DPMTABLE_OD_UPDATE_MCLK)) {\r\nsmc_result = amdgpu_ci_send_msg_to_smc(adev, PPSMC_MSG_MCLKDPM_FreezeLevel);\r\nif (smc_result != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ci_stop_dpm(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nPPSMC_Result smc_result;\r\nint ret;\r\nu32 tmp;\r\ntmp = RREG32_SMC(ixGENERAL_PWRMGT);\r\ntmp &= ~GENERAL_PWRMGT__GLOBAL_PWRMGT_EN_MASK;\r\nWREG32_SMC(ixGENERAL_PWRMGT, tmp);\r\ntmp = RREG32_SMC(ixSCLK_PWRMGT_CNTL);\r\ntmp &= ~SCLK_PWRMGT_CNTL__DYNAMIC_PM_EN_MASK;\r\nWREG32_SMC(ixSCLK_PWRMGT_CNTL, tmp);\r\nif (!pi->pcie_dpm_key_disabled) {\r\nsmc_result = amdgpu_ci_send_msg_to_smc(adev, PPSMC_MSG_PCIeDPM_Disable);\r\nif (smc_result != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\n}\r\nret = ci_enable_sclk_mclk_dpm(adev, false);\r\nif (ret)\r\nreturn ret;\r\nsmc_result = amdgpu_ci_send_msg_to_smc(adev, PPSMC_MSG_Voltage_Cntl_Disable);\r\nif (smc_result != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void ci_enable_sclk_control(struct amdgpu_device *adev, bool enable)\r\n{\r\nu32 tmp = RREG32_SMC(ixSCLK_PWRMGT_CNTL);\r\nif (enable)\r\ntmp &= ~SCLK_PWRMGT_CNTL__SCLK_PWRMGT_OFF_MASK;\r\nelse\r\ntmp |= SCLK_PWRMGT_CNTL__SCLK_PWRMGT_OFF_MASK;\r\nWREG32_SMC(ixSCLK_PWRMGT_CNTL, tmp);\r\n}\r\nstatic PPSMC_Result amdgpu_ci_send_msg_to_smc_with_parameter(struct amdgpu_device *adev,\r\nPPSMC_Msg msg, u32 parameter)\r\n{\r\nWREG32(mmSMC_MSG_ARG_0, parameter);\r\nreturn amdgpu_ci_send_msg_to_smc(adev, msg);\r\n}\r\nstatic PPSMC_Result amdgpu_ci_send_msg_to_smc_return_parameter(struct amdgpu_device *adev,\r\nPPSMC_Msg msg, u32 *parameter)\r\n{\r\nPPSMC_Result smc_result;\r\nsmc_result = amdgpu_ci_send_msg_to_smc(adev, msg);\r\nif ((smc_result == PPSMC_Result_OK) && parameter)\r\n*parameter = RREG32(mmSMC_MSG_ARG_0);\r\nreturn smc_result;\r\n}\r\nstatic int ci_dpm_force_state_sclk(struct amdgpu_device *adev, u32 n)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nif (!pi->sclk_dpm_key_disabled) {\r\nPPSMC_Result smc_result =\r\namdgpu_ci_send_msg_to_smc_with_parameter(adev, PPSMC_MSG_SCLKDPM_SetEnabledMask, 1 << n);\r\nif (smc_result != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ci_dpm_force_state_mclk(struct amdgpu_device *adev, u32 n)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nif (!pi->mclk_dpm_key_disabled) {\r\nPPSMC_Result smc_result =\r\namdgpu_ci_send_msg_to_smc_with_parameter(adev, PPSMC_MSG_MCLKDPM_SetEnabledMask, 1 << n);\r\nif (smc_result != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ci_dpm_force_state_pcie(struct amdgpu_device *adev, u32 n)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nif (!pi->pcie_dpm_key_disabled) {\r\nPPSMC_Result smc_result =\r\namdgpu_ci_send_msg_to_smc_with_parameter(adev, PPSMC_MSG_PCIeDPM_ForceLevel, n);\r\nif (smc_result != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ci_set_power_limit(struct amdgpu_device *adev, u32 n)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nif (pi->power_containment_features & POWERCONTAINMENT_FEATURE_PkgPwrLimit) {\r\nPPSMC_Result smc_result =\r\namdgpu_ci_send_msg_to_smc_with_parameter(adev, PPSMC_MSG_PkgPwrSetLimit, n);\r\nif (smc_result != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ci_set_overdrive_target_tdp(struct amdgpu_device *adev,\r\nu32 target_tdp)\r\n{\r\nPPSMC_Result smc_result =\r\namdgpu_ci_send_msg_to_smc_with_parameter(adev, PPSMC_MSG_OverDriveSetTargetTdp, target_tdp);\r\nif (smc_result != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic u32 ci_get_average_sclk_freq(struct amdgpu_device *adev)\r\n{\r\nu32 sclk_freq;\r\nPPSMC_Result smc_result =\r\namdgpu_ci_send_msg_to_smc_return_parameter(adev,\r\nPPSMC_MSG_API_GetSclkFrequency,\r\n&sclk_freq);\r\nif (smc_result != PPSMC_Result_OK)\r\nsclk_freq = 0;\r\nreturn sclk_freq;\r\n}\r\nstatic u32 ci_get_average_mclk_freq(struct amdgpu_device *adev)\r\n{\r\nu32 mclk_freq;\r\nPPSMC_Result smc_result =\r\namdgpu_ci_send_msg_to_smc_return_parameter(adev,\r\nPPSMC_MSG_API_GetMclkFrequency,\r\n&mclk_freq);\r\nif (smc_result != PPSMC_Result_OK)\r\nmclk_freq = 0;\r\nreturn mclk_freq;\r\n}\r\nstatic void ci_dpm_start_smc(struct amdgpu_device *adev)\r\n{\r\nint i;\r\namdgpu_ci_program_jump_on_start(adev);\r\namdgpu_ci_start_smc_clock(adev);\r\namdgpu_ci_start_smc(adev);\r\nfor (i = 0; i < adev->usec_timeout; i++) {\r\nif (RREG32_SMC(ixFIRMWARE_FLAGS) & FIRMWARE_FLAGS__INTERRUPTS_ENABLED_MASK)\r\nbreak;\r\n}\r\n}\r\nstatic void ci_dpm_stop_smc(struct amdgpu_device *adev)\r\n{\r\namdgpu_ci_reset_smc(adev);\r\namdgpu_ci_stop_smc_clock(adev);\r\n}\r\nstatic int ci_process_firmware_header(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nu32 tmp;\r\nint ret;\r\nret = amdgpu_ci_read_smc_sram_dword(adev,\r\nSMU7_FIRMWARE_HEADER_LOCATION +\r\noffsetof(SMU7_Firmware_Header, DpmTable),\r\n&tmp, pi->sram_end);\r\nif (ret)\r\nreturn ret;\r\npi->dpm_table_start = tmp;\r\nret = amdgpu_ci_read_smc_sram_dword(adev,\r\nSMU7_FIRMWARE_HEADER_LOCATION +\r\noffsetof(SMU7_Firmware_Header, SoftRegisters),\r\n&tmp, pi->sram_end);\r\nif (ret)\r\nreturn ret;\r\npi->soft_regs_start = tmp;\r\nret = amdgpu_ci_read_smc_sram_dword(adev,\r\nSMU7_FIRMWARE_HEADER_LOCATION +\r\noffsetof(SMU7_Firmware_Header, mcRegisterTable),\r\n&tmp, pi->sram_end);\r\nif (ret)\r\nreturn ret;\r\npi->mc_reg_table_start = tmp;\r\nret = amdgpu_ci_read_smc_sram_dword(adev,\r\nSMU7_FIRMWARE_HEADER_LOCATION +\r\noffsetof(SMU7_Firmware_Header, FanTable),\r\n&tmp, pi->sram_end);\r\nif (ret)\r\nreturn ret;\r\npi->fan_table_start = tmp;\r\nret = amdgpu_ci_read_smc_sram_dword(adev,\r\nSMU7_FIRMWARE_HEADER_LOCATION +\r\noffsetof(SMU7_Firmware_Header, mcArbDramTimingTable),\r\n&tmp, pi->sram_end);\r\nif (ret)\r\nreturn ret;\r\npi->arb_table_start = tmp;\r\nreturn 0;\r\n}\r\nstatic void ci_read_clock_registers(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\npi->clock_registers.cg_spll_func_cntl =\r\nRREG32_SMC(ixCG_SPLL_FUNC_CNTL);\r\npi->clock_registers.cg_spll_func_cntl_2 =\r\nRREG32_SMC(ixCG_SPLL_FUNC_CNTL_2);\r\npi->clock_registers.cg_spll_func_cntl_3 =\r\nRREG32_SMC(ixCG_SPLL_FUNC_CNTL_3);\r\npi->clock_registers.cg_spll_func_cntl_4 =\r\nRREG32_SMC(ixCG_SPLL_FUNC_CNTL_4);\r\npi->clock_registers.cg_spll_spread_spectrum =\r\nRREG32_SMC(ixCG_SPLL_SPREAD_SPECTRUM);\r\npi->clock_registers.cg_spll_spread_spectrum_2 =\r\nRREG32_SMC(ixCG_SPLL_SPREAD_SPECTRUM_2);\r\npi->clock_registers.dll_cntl = RREG32(mmDLL_CNTL);\r\npi->clock_registers.mclk_pwrmgt_cntl = RREG32(mmMCLK_PWRMGT_CNTL);\r\npi->clock_registers.mpll_ad_func_cntl = RREG32(mmMPLL_AD_FUNC_CNTL);\r\npi->clock_registers.mpll_dq_func_cntl = RREG32(mmMPLL_DQ_FUNC_CNTL);\r\npi->clock_registers.mpll_func_cntl = RREG32(mmMPLL_FUNC_CNTL);\r\npi->clock_registers.mpll_func_cntl_1 = RREG32(mmMPLL_FUNC_CNTL_1);\r\npi->clock_registers.mpll_func_cntl_2 = RREG32(mmMPLL_FUNC_CNTL_2);\r\npi->clock_registers.mpll_ss1 = RREG32(mmMPLL_SS1);\r\npi->clock_registers.mpll_ss2 = RREG32(mmMPLL_SS2);\r\n}\r\nstatic void ci_init_sclk_t(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\npi->low_sclk_interrupt_t = 0;\r\n}\r\nstatic void ci_enable_thermal_protection(struct amdgpu_device *adev,\r\nbool enable)\r\n{\r\nu32 tmp = RREG32_SMC(ixGENERAL_PWRMGT);\r\nif (enable)\r\ntmp &= ~GENERAL_PWRMGT__THERMAL_PROTECTION_DIS_MASK;\r\nelse\r\ntmp |= GENERAL_PWRMGT__THERMAL_PROTECTION_DIS_MASK;\r\nWREG32_SMC(ixGENERAL_PWRMGT, tmp);\r\n}\r\nstatic void ci_enable_acpi_power_management(struct amdgpu_device *adev)\r\n{\r\nu32 tmp = RREG32_SMC(ixGENERAL_PWRMGT);\r\ntmp |= GENERAL_PWRMGT__STATIC_PM_EN_MASK;\r\nWREG32_SMC(ixGENERAL_PWRMGT, tmp);\r\n}\r\nstatic int ci_notify_smc_display_change(struct amdgpu_device *adev,\r\nbool has_display)\r\n{\r\nPPSMC_Msg msg = has_display ? PPSMC_MSG_HasDisplay : PPSMC_MSG_NoDisplay;\r\nreturn (amdgpu_ci_send_msg_to_smc(adev, msg) == PPSMC_Result_OK) ? 0 : -EINVAL;\r\n}\r\nstatic int ci_enable_ds_master_switch(struct amdgpu_device *adev,\r\nbool enable)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nif (enable) {\r\nif (pi->caps_sclk_ds) {\r\nif (amdgpu_ci_send_msg_to_smc(adev, PPSMC_MSG_MASTER_DeepSleep_ON) != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\n} else {\r\nif (amdgpu_ci_send_msg_to_smc(adev, PPSMC_MSG_MASTER_DeepSleep_OFF) != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nif (pi->caps_sclk_ds) {\r\nif (amdgpu_ci_send_msg_to_smc(adev, PPSMC_MSG_MASTER_DeepSleep_OFF) != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void ci_program_display_gap(struct amdgpu_device *adev)\r\n{\r\nu32 tmp = RREG32_SMC(ixCG_DISPLAY_GAP_CNTL);\r\nu32 pre_vbi_time_in_us;\r\nu32 frame_time_in_us;\r\nu32 ref_clock = adev->clock.spll.reference_freq;\r\nu32 refresh_rate = amdgpu_dpm_get_vrefresh(adev);\r\nu32 vblank_time = amdgpu_dpm_get_vblank_time(adev);\r\ntmp &= ~CG_DISPLAY_GAP_CNTL__DISP_GAP_MASK;\r\nif (adev->pm.dpm.new_active_crtc_count > 0)\r\ntmp |= (AMDGPU_PM_DISPLAY_GAP_VBLANK_OR_WM << CG_DISPLAY_GAP_CNTL__DISP_GAP__SHIFT);\r\nelse\r\ntmp |= (AMDGPU_PM_DISPLAY_GAP_IGNORE << CG_DISPLAY_GAP_CNTL__DISP_GAP__SHIFT);\r\nWREG32_SMC(ixCG_DISPLAY_GAP_CNTL, tmp);\r\nif (refresh_rate == 0)\r\nrefresh_rate = 60;\r\nif (vblank_time == 0xffffffff)\r\nvblank_time = 500;\r\nframe_time_in_us = 1000000 / refresh_rate;\r\npre_vbi_time_in_us =\r\nframe_time_in_us - 200 - vblank_time;\r\ntmp = pre_vbi_time_in_us * (ref_clock / 100);\r\nWREG32_SMC(ixCG_DISPLAY_GAP_CNTL2, tmp);\r\nci_write_smc_soft_register(adev, offsetof(SMU7_SoftRegisters, PreVBlankGap), 0x64);\r\nci_write_smc_soft_register(adev, offsetof(SMU7_SoftRegisters, VBlankTimeout), (frame_time_in_us - pre_vbi_time_in_us));\r\nci_notify_smc_display_change(adev, (adev->pm.dpm.new_active_crtc_count == 1));\r\n}\r\nstatic void ci_enable_spread_spectrum(struct amdgpu_device *adev, bool enable)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nu32 tmp;\r\nif (enable) {\r\nif (pi->caps_sclk_ss_support) {\r\ntmp = RREG32_SMC(ixGENERAL_PWRMGT);\r\ntmp |= GENERAL_PWRMGT__DYN_SPREAD_SPECTRUM_EN_MASK;\r\nWREG32_SMC(ixGENERAL_PWRMGT, tmp);\r\n}\r\n} else {\r\ntmp = RREG32_SMC(ixCG_SPLL_SPREAD_SPECTRUM);\r\ntmp &= ~CG_SPLL_SPREAD_SPECTRUM__SSEN_MASK;\r\nWREG32_SMC(ixCG_SPLL_SPREAD_SPECTRUM, tmp);\r\ntmp = RREG32_SMC(ixGENERAL_PWRMGT);\r\ntmp &= ~GENERAL_PWRMGT__DYN_SPREAD_SPECTRUM_EN_MASK;\r\nWREG32_SMC(ixGENERAL_PWRMGT, tmp);\r\n}\r\n}\r\nstatic void ci_program_sstp(struct amdgpu_device *adev)\r\n{\r\nWREG32_SMC(ixCG_STATIC_SCREEN_PARAMETER,\r\n((CISLANDS_SSTU_DFLT << CG_STATIC_SCREEN_PARAMETER__STATIC_SCREEN_THRESHOLD_UNIT__SHIFT) |\r\n(CISLANDS_SST_DFLT << CG_STATIC_SCREEN_PARAMETER__STATIC_SCREEN_THRESHOLD__SHIFT)));\r\n}\r\nstatic void ci_enable_display_gap(struct amdgpu_device *adev)\r\n{\r\nu32 tmp = RREG32_SMC(ixCG_DISPLAY_GAP_CNTL);\r\ntmp &= ~(CG_DISPLAY_GAP_CNTL__DISP_GAP_MASK |\r\nCG_DISPLAY_GAP_CNTL__DISP_GAP_MCHG_MASK);\r\ntmp |= ((AMDGPU_PM_DISPLAY_GAP_IGNORE << CG_DISPLAY_GAP_CNTL__DISP_GAP__SHIFT) |\r\n(AMDGPU_PM_DISPLAY_GAP_VBLANK << CG_DISPLAY_GAP_CNTL__DISP_GAP_MCHG__SHIFT));\r\nWREG32_SMC(ixCG_DISPLAY_GAP_CNTL, tmp);\r\n}\r\nstatic void ci_program_vc(struct amdgpu_device *adev)\r\n{\r\nu32 tmp;\r\ntmp = RREG32_SMC(ixSCLK_PWRMGT_CNTL);\r\ntmp &= ~(SCLK_PWRMGT_CNTL__RESET_SCLK_CNT_MASK | SCLK_PWRMGT_CNTL__RESET_BUSY_CNT_MASK);\r\nWREG32_SMC(ixSCLK_PWRMGT_CNTL, tmp);\r\nWREG32_SMC(ixCG_FREQ_TRAN_VOTING_0, CISLANDS_VRC_DFLT0);\r\nWREG32_SMC(ixCG_FREQ_TRAN_VOTING_1, CISLANDS_VRC_DFLT1);\r\nWREG32_SMC(ixCG_FREQ_TRAN_VOTING_2, CISLANDS_VRC_DFLT2);\r\nWREG32_SMC(ixCG_FREQ_TRAN_VOTING_3, CISLANDS_VRC_DFLT3);\r\nWREG32_SMC(ixCG_FREQ_TRAN_VOTING_4, CISLANDS_VRC_DFLT4);\r\nWREG32_SMC(ixCG_FREQ_TRAN_VOTING_5, CISLANDS_VRC_DFLT5);\r\nWREG32_SMC(ixCG_FREQ_TRAN_VOTING_6, CISLANDS_VRC_DFLT6);\r\nWREG32_SMC(ixCG_FREQ_TRAN_VOTING_7, CISLANDS_VRC_DFLT7);\r\n}\r\nstatic void ci_clear_vc(struct amdgpu_device *adev)\r\n{\r\nu32 tmp;\r\ntmp = RREG32_SMC(ixSCLK_PWRMGT_CNTL);\r\ntmp |= (SCLK_PWRMGT_CNTL__RESET_SCLK_CNT_MASK | SCLK_PWRMGT_CNTL__RESET_BUSY_CNT_MASK);\r\nWREG32_SMC(ixSCLK_PWRMGT_CNTL, tmp);\r\nWREG32_SMC(ixCG_FREQ_TRAN_VOTING_0, 0);\r\nWREG32_SMC(ixCG_FREQ_TRAN_VOTING_1, 0);\r\nWREG32_SMC(ixCG_FREQ_TRAN_VOTING_2, 0);\r\nWREG32_SMC(ixCG_FREQ_TRAN_VOTING_3, 0);\r\nWREG32_SMC(ixCG_FREQ_TRAN_VOTING_4, 0);\r\nWREG32_SMC(ixCG_FREQ_TRAN_VOTING_5, 0);\r\nWREG32_SMC(ixCG_FREQ_TRAN_VOTING_6, 0);\r\nWREG32_SMC(ixCG_FREQ_TRAN_VOTING_7, 0);\r\n}\r\nstatic int ci_upload_firmware(struct amdgpu_device *adev)\r\n{\r\nint i, ret;\r\nif (amdgpu_ci_is_smc_running(adev)) {\r\nDRM_INFO("smc is running, no need to load smc firmware\n");\r\nreturn 0;\r\n}\r\nfor (i = 0; i < adev->usec_timeout; i++) {\r\nif (RREG32_SMC(ixRCU_UC_EVENTS) & RCU_UC_EVENTS__boot_seq_done_MASK)\r\nbreak;\r\n}\r\nWREG32_SMC(ixSMC_SYSCON_MISC_CNTL, 1);\r\namdgpu_ci_stop_smc_clock(adev);\r\namdgpu_ci_reset_smc(adev);\r\nret = amdgpu_ci_load_smc_ucode(adev, SMC_RAM_END);\r\nreturn ret;\r\n}\r\nstatic int ci_get_svi2_voltage_table(struct amdgpu_device *adev,\r\nstruct amdgpu_clock_voltage_dependency_table *voltage_dependency_table,\r\nstruct atom_voltage_table *voltage_table)\r\n{\r\nu32 i;\r\nif (voltage_dependency_table == NULL)\r\nreturn -EINVAL;\r\nvoltage_table->mask_low = 0;\r\nvoltage_table->phase_delay = 0;\r\nvoltage_table->count = voltage_dependency_table->count;\r\nfor (i = 0; i < voltage_table->count; i++) {\r\nvoltage_table->entries[i].value = voltage_dependency_table->entries[i].v;\r\nvoltage_table->entries[i].smio_low = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ci_construct_voltage_tables(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nint ret;\r\nif (pi->voltage_control == CISLANDS_VOLTAGE_CONTROL_BY_GPIO) {\r\nret = amdgpu_atombios_get_voltage_table(adev, VOLTAGE_TYPE_VDDC,\r\nVOLTAGE_OBJ_GPIO_LUT,\r\n&pi->vddc_voltage_table);\r\nif (ret)\r\nreturn ret;\r\n} else if (pi->voltage_control == CISLANDS_VOLTAGE_CONTROL_BY_SVID2) {\r\nret = ci_get_svi2_voltage_table(adev,\r\n&adev->pm.dpm.dyn_state.vddc_dependency_on_mclk,\r\n&pi->vddc_voltage_table);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (pi->vddc_voltage_table.count > SMU7_MAX_LEVELS_VDDC)\r\nci_trim_voltage_table_to_fit_state_table(adev, SMU7_MAX_LEVELS_VDDC,\r\n&pi->vddc_voltage_table);\r\nif (pi->vddci_control == CISLANDS_VOLTAGE_CONTROL_BY_GPIO) {\r\nret = amdgpu_atombios_get_voltage_table(adev, VOLTAGE_TYPE_VDDCI,\r\nVOLTAGE_OBJ_GPIO_LUT,\r\n&pi->vddci_voltage_table);\r\nif (ret)\r\nreturn ret;\r\n} else if (pi->vddci_control == CISLANDS_VOLTAGE_CONTROL_BY_SVID2) {\r\nret = ci_get_svi2_voltage_table(adev,\r\n&adev->pm.dpm.dyn_state.vddci_dependency_on_mclk,\r\n&pi->vddci_voltage_table);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (pi->vddci_voltage_table.count > SMU7_MAX_LEVELS_VDDCI)\r\nci_trim_voltage_table_to_fit_state_table(adev, SMU7_MAX_LEVELS_VDDCI,\r\n&pi->vddci_voltage_table);\r\nif (pi->mvdd_control == CISLANDS_VOLTAGE_CONTROL_BY_GPIO) {\r\nret = amdgpu_atombios_get_voltage_table(adev, VOLTAGE_TYPE_MVDDC,\r\nVOLTAGE_OBJ_GPIO_LUT,\r\n&pi->mvdd_voltage_table);\r\nif (ret)\r\nreturn ret;\r\n} else if (pi->mvdd_control == CISLANDS_VOLTAGE_CONTROL_BY_SVID2) {\r\nret = ci_get_svi2_voltage_table(adev,\r\n&adev->pm.dpm.dyn_state.mvdd_dependency_on_mclk,\r\n&pi->mvdd_voltage_table);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (pi->mvdd_voltage_table.count > SMU7_MAX_LEVELS_MVDD)\r\nci_trim_voltage_table_to_fit_state_table(adev, SMU7_MAX_LEVELS_MVDD,\r\n&pi->mvdd_voltage_table);\r\nreturn 0;\r\n}\r\nstatic void ci_populate_smc_voltage_table(struct amdgpu_device *adev,\r\nstruct atom_voltage_table_entry *voltage_table,\r\nSMU7_Discrete_VoltageLevel *smc_voltage_table)\r\n{\r\nint ret;\r\nret = ci_get_std_voltage_value_sidd(adev, voltage_table,\r\n&smc_voltage_table->StdVoltageHiSidd,\r\n&smc_voltage_table->StdVoltageLoSidd);\r\nif (ret) {\r\nsmc_voltage_table->StdVoltageHiSidd = voltage_table->value * VOLTAGE_SCALE;\r\nsmc_voltage_table->StdVoltageLoSidd = voltage_table->value * VOLTAGE_SCALE;\r\n}\r\nsmc_voltage_table->Voltage = cpu_to_be16(voltage_table->value * VOLTAGE_SCALE);\r\nsmc_voltage_table->StdVoltageHiSidd =\r\ncpu_to_be16(smc_voltage_table->StdVoltageHiSidd);\r\nsmc_voltage_table->StdVoltageLoSidd =\r\ncpu_to_be16(smc_voltage_table->StdVoltageLoSidd);\r\n}\r\nstatic int ci_populate_smc_vddc_table(struct amdgpu_device *adev,\r\nSMU7_Discrete_DpmTable *table)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nunsigned int count;\r\ntable->VddcLevelCount = pi->vddc_voltage_table.count;\r\nfor (count = 0; count < table->VddcLevelCount; count++) {\r\nci_populate_smc_voltage_table(adev,\r\n&pi->vddc_voltage_table.entries[count],\r\n&table->VddcLevel[count]);\r\nif (pi->voltage_control == CISLANDS_VOLTAGE_CONTROL_BY_GPIO)\r\ntable->VddcLevel[count].Smio |=\r\npi->vddc_voltage_table.entries[count].smio_low;\r\nelse\r\ntable->VddcLevel[count].Smio = 0;\r\n}\r\ntable->VddcLevelCount = cpu_to_be32(table->VddcLevelCount);\r\nreturn 0;\r\n}\r\nstatic int ci_populate_smc_vddci_table(struct amdgpu_device *adev,\r\nSMU7_Discrete_DpmTable *table)\r\n{\r\nunsigned int count;\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\ntable->VddciLevelCount = pi->vddci_voltage_table.count;\r\nfor (count = 0; count < table->VddciLevelCount; count++) {\r\nci_populate_smc_voltage_table(adev,\r\n&pi->vddci_voltage_table.entries[count],\r\n&table->VddciLevel[count]);\r\nif (pi->vddci_control == CISLANDS_VOLTAGE_CONTROL_BY_GPIO)\r\ntable->VddciLevel[count].Smio |=\r\npi->vddci_voltage_table.entries[count].smio_low;\r\nelse\r\ntable->VddciLevel[count].Smio = 0;\r\n}\r\ntable->VddciLevelCount = cpu_to_be32(table->VddciLevelCount);\r\nreturn 0;\r\n}\r\nstatic int ci_populate_smc_mvdd_table(struct amdgpu_device *adev,\r\nSMU7_Discrete_DpmTable *table)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nunsigned int count;\r\ntable->MvddLevelCount = pi->mvdd_voltage_table.count;\r\nfor (count = 0; count < table->MvddLevelCount; count++) {\r\nci_populate_smc_voltage_table(adev,\r\n&pi->mvdd_voltage_table.entries[count],\r\n&table->MvddLevel[count]);\r\nif (pi->mvdd_control == CISLANDS_VOLTAGE_CONTROL_BY_GPIO)\r\ntable->MvddLevel[count].Smio |=\r\npi->mvdd_voltage_table.entries[count].smio_low;\r\nelse\r\ntable->MvddLevel[count].Smio = 0;\r\n}\r\ntable->MvddLevelCount = cpu_to_be32(table->MvddLevelCount);\r\nreturn 0;\r\n}\r\nstatic int ci_populate_smc_voltage_tables(struct amdgpu_device *adev,\r\nSMU7_Discrete_DpmTable *table)\r\n{\r\nint ret;\r\nret = ci_populate_smc_vddc_table(adev, table);\r\nif (ret)\r\nreturn ret;\r\nret = ci_populate_smc_vddci_table(adev, table);\r\nif (ret)\r\nreturn ret;\r\nret = ci_populate_smc_mvdd_table(adev, table);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int ci_populate_mvdd_value(struct amdgpu_device *adev, u32 mclk,\r\nSMU7_Discrete_VoltageLevel *voltage)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nu32 i = 0;\r\nif (pi->mvdd_control != CISLANDS_VOLTAGE_CONTROL_NONE) {\r\nfor (i = 0; i < adev->pm.dpm.dyn_state.mvdd_dependency_on_mclk.count; i++) {\r\nif (mclk <= adev->pm.dpm.dyn_state.mvdd_dependency_on_mclk.entries[i].clk) {\r\nvoltage->Voltage = pi->mvdd_voltage_table.entries[i].value;\r\nbreak;\r\n}\r\n}\r\nif (i >= adev->pm.dpm.dyn_state.mvdd_dependency_on_mclk.count)\r\nreturn -EINVAL;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ci_get_std_voltage_value_sidd(struct amdgpu_device *adev,\r\nstruct atom_voltage_table_entry *voltage_table,\r\nu16 *std_voltage_hi_sidd, u16 *std_voltage_lo_sidd)\r\n{\r\nu16 v_index, idx;\r\nbool voltage_found = false;\r\n*std_voltage_hi_sidd = voltage_table->value * VOLTAGE_SCALE;\r\n*std_voltage_lo_sidd = voltage_table->value * VOLTAGE_SCALE;\r\nif (adev->pm.dpm.dyn_state.vddc_dependency_on_sclk.entries == NULL)\r\nreturn -EINVAL;\r\nif (adev->pm.dpm.dyn_state.cac_leakage_table.entries) {\r\nfor (v_index = 0; (u32)v_index < adev->pm.dpm.dyn_state.vddc_dependency_on_sclk.count; v_index++) {\r\nif (voltage_table->value ==\r\nadev->pm.dpm.dyn_state.vddc_dependency_on_sclk.entries[v_index].v) {\r\nvoltage_found = true;\r\nif ((u32)v_index < adev->pm.dpm.dyn_state.cac_leakage_table.count)\r\nidx = v_index;\r\nelse\r\nidx = adev->pm.dpm.dyn_state.cac_leakage_table.count - 1;\r\n*std_voltage_lo_sidd =\r\nadev->pm.dpm.dyn_state.cac_leakage_table.entries[idx].vddc * VOLTAGE_SCALE;\r\n*std_voltage_hi_sidd =\r\nadev->pm.dpm.dyn_state.cac_leakage_table.entries[idx].leakage * VOLTAGE_SCALE;\r\nbreak;\r\n}\r\n}\r\nif (!voltage_found) {\r\nfor (v_index = 0; (u32)v_index < adev->pm.dpm.dyn_state.vddc_dependency_on_sclk.count; v_index++) {\r\nif (voltage_table->value <=\r\nadev->pm.dpm.dyn_state.vddc_dependency_on_sclk.entries[v_index].v) {\r\nvoltage_found = true;\r\nif ((u32)v_index < adev->pm.dpm.dyn_state.cac_leakage_table.count)\r\nidx = v_index;\r\nelse\r\nidx = adev->pm.dpm.dyn_state.cac_leakage_table.count - 1;\r\n*std_voltage_lo_sidd =\r\nadev->pm.dpm.dyn_state.cac_leakage_table.entries[idx].vddc * VOLTAGE_SCALE;\r\n*std_voltage_hi_sidd =\r\nadev->pm.dpm.dyn_state.cac_leakage_table.entries[idx].leakage * VOLTAGE_SCALE;\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void ci_populate_phase_value_based_on_sclk(struct amdgpu_device *adev,\r\nconst struct amdgpu_phase_shedding_limits_table *limits,\r\nu32 sclk,\r\nu32 *phase_shedding)\r\n{\r\nunsigned int i;\r\n*phase_shedding = 1;\r\nfor (i = 0; i < limits->count; i++) {\r\nif (sclk < limits->entries[i].sclk) {\r\n*phase_shedding = i;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void ci_populate_phase_value_based_on_mclk(struct amdgpu_device *adev,\r\nconst struct amdgpu_phase_shedding_limits_table *limits,\r\nu32 mclk,\r\nu32 *phase_shedding)\r\n{\r\nunsigned int i;\r\n*phase_shedding = 1;\r\nfor (i = 0; i < limits->count; i++) {\r\nif (mclk < limits->entries[i].mclk) {\r\n*phase_shedding = i;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int ci_init_arb_table_index(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nu32 tmp;\r\nint ret;\r\nret = amdgpu_ci_read_smc_sram_dword(adev, pi->arb_table_start,\r\n&tmp, pi->sram_end);\r\nif (ret)\r\nreturn ret;\r\ntmp &= 0x00FFFFFF;\r\ntmp |= MC_CG_ARB_FREQ_F1 << 24;\r\nreturn amdgpu_ci_write_smc_sram_dword(adev, pi->arb_table_start,\r\ntmp, pi->sram_end);\r\n}\r\nstatic int ci_get_dependency_volt_by_clk(struct amdgpu_device *adev,\r\nstruct amdgpu_clock_voltage_dependency_table *allowed_clock_voltage_table,\r\nu32 clock, u32 *voltage)\r\n{\r\nu32 i = 0;\r\nif (allowed_clock_voltage_table->count == 0)\r\nreturn -EINVAL;\r\nfor (i = 0; i < allowed_clock_voltage_table->count; i++) {\r\nif (allowed_clock_voltage_table->entries[i].clk >= clock) {\r\n*voltage = allowed_clock_voltage_table->entries[i].v;\r\nreturn 0;\r\n}\r\n}\r\n*voltage = allowed_clock_voltage_table->entries[i-1].v;\r\nreturn 0;\r\n}\r\nstatic u8 ci_get_sleep_divider_id_from_clock(u32 sclk, u32 min_sclk_in_sr)\r\n{\r\nu32 i;\r\nu32 tmp;\r\nu32 min = max(min_sclk_in_sr, (u32)CISLAND_MINIMUM_ENGINE_CLOCK);\r\nif (sclk < min)\r\nreturn 0;\r\nfor (i = CISLAND_MAX_DEEPSLEEP_DIVIDER_ID; ; i--) {\r\ntmp = sclk >> i;\r\nif (tmp >= min || i == 0)\r\nbreak;\r\n}\r\nreturn (u8)i;\r\n}\r\nstatic int ci_initial_switch_from_arb_f0_to_f1(struct amdgpu_device *adev)\r\n{\r\nreturn ci_copy_and_switch_arb_sets(adev, MC_CG_ARB_FREQ_F0, MC_CG_ARB_FREQ_F1);\r\n}\r\nstatic int ci_reset_to_default(struct amdgpu_device *adev)\r\n{\r\nreturn (amdgpu_ci_send_msg_to_smc(adev, PPSMC_MSG_ResetToDefaults) == PPSMC_Result_OK) ?\r\n0 : -EINVAL;\r\n}\r\nstatic int ci_force_switch_to_arb_f0(struct amdgpu_device *adev)\r\n{\r\nu32 tmp;\r\ntmp = (RREG32_SMC(ixSMC_SCRATCH9) & 0x0000ff00) >> 8;\r\nif (tmp == MC_CG_ARB_FREQ_F0)\r\nreturn 0;\r\nreturn ci_copy_and_switch_arb_sets(adev, tmp, MC_CG_ARB_FREQ_F0);\r\n}\r\nstatic void ci_register_patching_mc_arb(struct amdgpu_device *adev,\r\nconst u32 engine_clock,\r\nconst u32 memory_clock,\r\nu32 *dram_timimg2)\r\n{\r\nbool patch;\r\nu32 tmp, tmp2;\r\ntmp = RREG32(mmMC_SEQ_MISC0);\r\npatch = ((tmp & 0x0000f00) == 0x300) ? true : false;\r\nif (patch &&\r\n((adev->pdev->device == 0x67B0) ||\r\n(adev->pdev->device == 0x67B1))) {\r\nif ((memory_clock > 100000) && (memory_clock <= 125000)) {\r\ntmp2 = (((0x31 * engine_clock) / 125000) - 1) & 0xff;\r\n*dram_timimg2 &= ~0x00ff0000;\r\n*dram_timimg2 |= tmp2 << 16;\r\n} else if ((memory_clock > 125000) && (memory_clock <= 137500)) {\r\ntmp2 = (((0x36 * engine_clock) / 137500) - 1) & 0xff;\r\n*dram_timimg2 &= ~0x00ff0000;\r\n*dram_timimg2 |= tmp2 << 16;\r\n}\r\n}\r\n}\r\nstatic int ci_populate_memory_timing_parameters(struct amdgpu_device *adev,\r\nu32 sclk,\r\nu32 mclk,\r\nSMU7_Discrete_MCArbDramTimingTableEntry *arb_regs)\r\n{\r\nu32 dram_timing;\r\nu32 dram_timing2;\r\nu32 burst_time;\r\namdgpu_atombios_set_engine_dram_timings(adev, sclk, mclk);\r\ndram_timing = RREG32(mmMC_ARB_DRAM_TIMING);\r\ndram_timing2 = RREG32(mmMC_ARB_DRAM_TIMING2);\r\nburst_time = RREG32(mmMC_ARB_BURST_TIME) & MC_ARB_BURST_TIME__STATE0_MASK;\r\nci_register_patching_mc_arb(adev, sclk, mclk, &dram_timing2);\r\narb_regs->McArbDramTiming = cpu_to_be32(dram_timing);\r\narb_regs->McArbDramTiming2 = cpu_to_be32(dram_timing2);\r\narb_regs->McArbBurstTime = (u8)burst_time;\r\nreturn 0;\r\n}\r\nstatic int ci_do_program_memory_timing_parameters(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nSMU7_Discrete_MCArbDramTimingTable arb_regs;\r\nu32 i, j;\r\nint ret = 0;\r\nmemset(&arb_regs, 0, sizeof(SMU7_Discrete_MCArbDramTimingTable));\r\nfor (i = 0; i < pi->dpm_table.sclk_table.count; i++) {\r\nfor (j = 0; j < pi->dpm_table.mclk_table.count; j++) {\r\nret = ci_populate_memory_timing_parameters(adev,\r\npi->dpm_table.sclk_table.dpm_levels[i].value,\r\npi->dpm_table.mclk_table.dpm_levels[j].value,\r\n&arb_regs.entries[i][j]);\r\nif (ret)\r\nbreak;\r\n}\r\n}\r\nif (ret == 0)\r\nret = amdgpu_ci_copy_bytes_to_smc(adev,\r\npi->arb_table_start,\r\n(u8 *)&arb_regs,\r\nsizeof(SMU7_Discrete_MCArbDramTimingTable),\r\npi->sram_end);\r\nreturn ret;\r\n}\r\nstatic int ci_program_memory_timing_parameters(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nif (pi->need_update_smu7_dpm_table == 0)\r\nreturn 0;\r\nreturn ci_do_program_memory_timing_parameters(adev);\r\n}\r\nstatic void ci_populate_smc_initial_state(struct amdgpu_device *adev,\r\nstruct amdgpu_ps *amdgpu_boot_state)\r\n{\r\nstruct ci_ps *boot_state = ci_get_ps(amdgpu_boot_state);\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nu32 level = 0;\r\nfor (level = 0; level < adev->pm.dpm.dyn_state.vddc_dependency_on_sclk.count; level++) {\r\nif (adev->pm.dpm.dyn_state.vddc_dependency_on_sclk.entries[level].clk >=\r\nboot_state->performance_levels[0].sclk) {\r\npi->smc_state_table.GraphicsBootLevel = level;\r\nbreak;\r\n}\r\n}\r\nfor (level = 0; level < adev->pm.dpm.dyn_state.vddc_dependency_on_mclk.count; level++) {\r\nif (adev->pm.dpm.dyn_state.vddc_dependency_on_mclk.entries[level].clk >=\r\nboot_state->performance_levels[0].mclk) {\r\npi->smc_state_table.MemoryBootLevel = level;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic u32 ci_get_dpm_level_enable_mask_value(struct ci_single_dpm_table *dpm_table)\r\n{\r\nu32 i;\r\nu32 mask_value = 0;\r\nfor (i = dpm_table->count; i > 0; i--) {\r\nmask_value = mask_value << 1;\r\nif (dpm_table->dpm_levels[i-1].enabled)\r\nmask_value |= 0x1;\r\nelse\r\nmask_value &= 0xFFFFFFFE;\r\n}\r\nreturn mask_value;\r\n}\r\nstatic void ci_populate_smc_link_level(struct amdgpu_device *adev,\r\nSMU7_Discrete_DpmTable *table)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nstruct ci_dpm_table *dpm_table = &pi->dpm_table;\r\nu32 i;\r\nfor (i = 0; i < dpm_table->pcie_speed_table.count; i++) {\r\ntable->LinkLevel[i].PcieGenSpeed =\r\n(u8)dpm_table->pcie_speed_table.dpm_levels[i].value;\r\ntable->LinkLevel[i].PcieLaneCount =\r\namdgpu_encode_pci_lane_width(dpm_table->pcie_speed_table.dpm_levels[i].param1);\r\ntable->LinkLevel[i].EnabledForActivity = 1;\r\ntable->LinkLevel[i].DownT = cpu_to_be32(5);\r\ntable->LinkLevel[i].UpT = cpu_to_be32(30);\r\n}\r\npi->smc_state_table.LinkLevelCount = (u8)dpm_table->pcie_speed_table.count;\r\npi->dpm_level_enable_mask.pcie_dpm_enable_mask =\r\nci_get_dpm_level_enable_mask_value(&dpm_table->pcie_speed_table);\r\n}\r\nstatic int ci_populate_smc_uvd_level(struct amdgpu_device *adev,\r\nSMU7_Discrete_DpmTable *table)\r\n{\r\nu32 count;\r\nstruct atom_clock_dividers dividers;\r\nint ret = -EINVAL;\r\ntable->UvdLevelCount =\r\nadev->pm.dpm.dyn_state.uvd_clock_voltage_dependency_table.count;\r\nfor (count = 0; count < table->UvdLevelCount; count++) {\r\ntable->UvdLevel[count].VclkFrequency =\r\nadev->pm.dpm.dyn_state.uvd_clock_voltage_dependency_table.entries[count].vclk;\r\ntable->UvdLevel[count].DclkFrequency =\r\nadev->pm.dpm.dyn_state.uvd_clock_voltage_dependency_table.entries[count].dclk;\r\ntable->UvdLevel[count].MinVddc =\r\nadev->pm.dpm.dyn_state.uvd_clock_voltage_dependency_table.entries[count].v * VOLTAGE_SCALE;\r\ntable->UvdLevel[count].MinVddcPhases = 1;\r\nret = amdgpu_atombios_get_clock_dividers(adev,\r\nCOMPUTE_GPUCLK_INPUT_FLAG_DEFAULT_GPUCLK,\r\ntable->UvdLevel[count].VclkFrequency, false, &dividers);\r\nif (ret)\r\nreturn ret;\r\ntable->UvdLevel[count].VclkDivider = (u8)dividers.post_divider;\r\nret = amdgpu_atombios_get_clock_dividers(adev,\r\nCOMPUTE_GPUCLK_INPUT_FLAG_DEFAULT_GPUCLK,\r\ntable->UvdLevel[count].DclkFrequency, false, &dividers);\r\nif (ret)\r\nreturn ret;\r\ntable->UvdLevel[count].DclkDivider = (u8)dividers.post_divider;\r\ntable->UvdLevel[count].VclkFrequency = cpu_to_be32(table->UvdLevel[count].VclkFrequency);\r\ntable->UvdLevel[count].DclkFrequency = cpu_to_be32(table->UvdLevel[count].DclkFrequency);\r\ntable->UvdLevel[count].MinVddc = cpu_to_be16(table->UvdLevel[count].MinVddc);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ci_populate_smc_vce_level(struct amdgpu_device *adev,\r\nSMU7_Discrete_DpmTable *table)\r\n{\r\nu32 count;\r\nstruct atom_clock_dividers dividers;\r\nint ret = -EINVAL;\r\ntable->VceLevelCount =\r\nadev->pm.dpm.dyn_state.vce_clock_voltage_dependency_table.count;\r\nfor (count = 0; count < table->VceLevelCount; count++) {\r\ntable->VceLevel[count].Frequency =\r\nadev->pm.dpm.dyn_state.vce_clock_voltage_dependency_table.entries[count].evclk;\r\ntable->VceLevel[count].MinVoltage =\r\n(u16)adev->pm.dpm.dyn_state.vce_clock_voltage_dependency_table.entries[count].v * VOLTAGE_SCALE;\r\ntable->VceLevel[count].MinPhases = 1;\r\nret = amdgpu_atombios_get_clock_dividers(adev,\r\nCOMPUTE_GPUCLK_INPUT_FLAG_DEFAULT_GPUCLK,\r\ntable->VceLevel[count].Frequency, false, &dividers);\r\nif (ret)\r\nreturn ret;\r\ntable->VceLevel[count].Divider = (u8)dividers.post_divider;\r\ntable->VceLevel[count].Frequency = cpu_to_be32(table->VceLevel[count].Frequency);\r\ntable->VceLevel[count].MinVoltage = cpu_to_be16(table->VceLevel[count].MinVoltage);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ci_populate_smc_acp_level(struct amdgpu_device *adev,\r\nSMU7_Discrete_DpmTable *table)\r\n{\r\nu32 count;\r\nstruct atom_clock_dividers dividers;\r\nint ret = -EINVAL;\r\ntable->AcpLevelCount = (u8)\r\n(adev->pm.dpm.dyn_state.acp_clock_voltage_dependency_table.count);\r\nfor (count = 0; count < table->AcpLevelCount; count++) {\r\ntable->AcpLevel[count].Frequency =\r\nadev->pm.dpm.dyn_state.acp_clock_voltage_dependency_table.entries[count].clk;\r\ntable->AcpLevel[count].MinVoltage =\r\nadev->pm.dpm.dyn_state.acp_clock_voltage_dependency_table.entries[count].v;\r\ntable->AcpLevel[count].MinPhases = 1;\r\nret = amdgpu_atombios_get_clock_dividers(adev,\r\nCOMPUTE_GPUCLK_INPUT_FLAG_DEFAULT_GPUCLK,\r\ntable->AcpLevel[count].Frequency, false, &dividers);\r\nif (ret)\r\nreturn ret;\r\ntable->AcpLevel[count].Divider = (u8)dividers.post_divider;\r\ntable->AcpLevel[count].Frequency = cpu_to_be32(table->AcpLevel[count].Frequency);\r\ntable->AcpLevel[count].MinVoltage = cpu_to_be16(table->AcpLevel[count].MinVoltage);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ci_populate_smc_samu_level(struct amdgpu_device *adev,\r\nSMU7_Discrete_DpmTable *table)\r\n{\r\nu32 count;\r\nstruct atom_clock_dividers dividers;\r\nint ret = -EINVAL;\r\ntable->SamuLevelCount =\r\nadev->pm.dpm.dyn_state.samu_clock_voltage_dependency_table.count;\r\nfor (count = 0; count < table->SamuLevelCount; count++) {\r\ntable->SamuLevel[count].Frequency =\r\nadev->pm.dpm.dyn_state.samu_clock_voltage_dependency_table.entries[count].clk;\r\ntable->SamuLevel[count].MinVoltage =\r\nadev->pm.dpm.dyn_state.samu_clock_voltage_dependency_table.entries[count].v * VOLTAGE_SCALE;\r\ntable->SamuLevel[count].MinPhases = 1;\r\nret = amdgpu_atombios_get_clock_dividers(adev,\r\nCOMPUTE_GPUCLK_INPUT_FLAG_DEFAULT_GPUCLK,\r\ntable->SamuLevel[count].Frequency, false, &dividers);\r\nif (ret)\r\nreturn ret;\r\ntable->SamuLevel[count].Divider = (u8)dividers.post_divider;\r\ntable->SamuLevel[count].Frequency = cpu_to_be32(table->SamuLevel[count].Frequency);\r\ntable->SamuLevel[count].MinVoltage = cpu_to_be16(table->SamuLevel[count].MinVoltage);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ci_calculate_mclk_params(struct amdgpu_device *adev,\r\nu32 memory_clock,\r\nSMU7_Discrete_MemoryLevel *mclk,\r\nbool strobe_mode,\r\nbool dll_state_on)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nu32 dll_cntl = pi->clock_registers.dll_cntl;\r\nu32 mclk_pwrmgt_cntl = pi->clock_registers.mclk_pwrmgt_cntl;\r\nu32 mpll_ad_func_cntl = pi->clock_registers.mpll_ad_func_cntl;\r\nu32 mpll_dq_func_cntl = pi->clock_registers.mpll_dq_func_cntl;\r\nu32 mpll_func_cntl = pi->clock_registers.mpll_func_cntl;\r\nu32 mpll_func_cntl_1 = pi->clock_registers.mpll_func_cntl_1;\r\nu32 mpll_func_cntl_2 = pi->clock_registers.mpll_func_cntl_2;\r\nu32 mpll_ss1 = pi->clock_registers.mpll_ss1;\r\nu32 mpll_ss2 = pi->clock_registers.mpll_ss2;\r\nstruct atom_mpll_param mpll_param;\r\nint ret;\r\nret = amdgpu_atombios_get_memory_pll_dividers(adev, memory_clock, strobe_mode, &mpll_param);\r\nif (ret)\r\nreturn ret;\r\nmpll_func_cntl &= ~MPLL_FUNC_CNTL__BWCTRL_MASK;\r\nmpll_func_cntl |= (mpll_param.bwcntl << MPLL_FUNC_CNTL__BWCTRL__SHIFT);\r\nmpll_func_cntl_1 &= ~(MPLL_FUNC_CNTL_1__CLKF_MASK | MPLL_FUNC_CNTL_1__CLKFRAC_MASK |\r\nMPLL_FUNC_CNTL_1__VCO_MODE_MASK);\r\nmpll_func_cntl_1 |= (mpll_param.clkf) << MPLL_FUNC_CNTL_1__CLKF__SHIFT |\r\n(mpll_param.clkfrac << MPLL_FUNC_CNTL_1__CLKFRAC__SHIFT) |\r\n(mpll_param.vco_mode << MPLL_FUNC_CNTL_1__VCO_MODE__SHIFT);\r\nmpll_ad_func_cntl &= ~MPLL_AD_FUNC_CNTL__YCLK_POST_DIV_MASK;\r\nmpll_ad_func_cntl |= (mpll_param.post_div << MPLL_AD_FUNC_CNTL__YCLK_POST_DIV__SHIFT);\r\nif (adev->mc.vram_type == AMDGPU_VRAM_TYPE_GDDR5) {\r\nmpll_dq_func_cntl &= ~(MPLL_DQ_FUNC_CNTL__YCLK_SEL_MASK |\r\nMPLL_AD_FUNC_CNTL__YCLK_POST_DIV_MASK);\r\nmpll_dq_func_cntl |= (mpll_param.yclk_sel << MPLL_DQ_FUNC_CNTL__YCLK_SEL__SHIFT) |\r\n(mpll_param.post_div << MPLL_AD_FUNC_CNTL__YCLK_POST_DIV__SHIFT);\r\n}\r\nif (pi->caps_mclk_ss_support) {\r\nstruct amdgpu_atom_ss ss;\r\nu32 freq_nom;\r\nu32 tmp;\r\nu32 reference_clock = adev->clock.mpll.reference_freq;\r\nif (mpll_param.qdr == 1)\r\nfreq_nom = memory_clock * 4 * (1 << mpll_param.post_div);\r\nelse\r\nfreq_nom = memory_clock * 2 * (1 << mpll_param.post_div);\r\ntmp = (freq_nom / reference_clock);\r\ntmp = tmp * tmp;\r\nif (amdgpu_atombios_get_asic_ss_info(adev, &ss,\r\nASIC_INTERNAL_MEMORY_SS, freq_nom)) {\r\nu32 clks = reference_clock * 5 / ss.rate;\r\nu32 clkv = (u32)((((131 * ss.percentage * ss.rate) / 100) * tmp) / freq_nom);\r\nmpll_ss1 &= ~MPLL_SS1__CLKV_MASK;\r\nmpll_ss1 |= (clkv << MPLL_SS1__CLKV__SHIFT);\r\nmpll_ss2 &= ~MPLL_SS2__CLKS_MASK;\r\nmpll_ss2 |= (clks << MPLL_SS2__CLKS__SHIFT);\r\n}\r\n}\r\nmclk_pwrmgt_cntl &= ~MCLK_PWRMGT_CNTL__DLL_SPEED_MASK;\r\nmclk_pwrmgt_cntl |= (mpll_param.dll_speed << MCLK_PWRMGT_CNTL__DLL_SPEED__SHIFT);\r\nif (dll_state_on)\r\nmclk_pwrmgt_cntl |= MCLK_PWRMGT_CNTL__MRDCK0_PDNB_MASK |\r\nMCLK_PWRMGT_CNTL__MRDCK1_PDNB_MASK;\r\nelse\r\nmclk_pwrmgt_cntl &= ~(MCLK_PWRMGT_CNTL__MRDCK0_PDNB_MASK |\r\nMCLK_PWRMGT_CNTL__MRDCK1_PDNB_MASK);\r\nmclk->MclkFrequency = memory_clock;\r\nmclk->MpllFuncCntl = mpll_func_cntl;\r\nmclk->MpllFuncCntl_1 = mpll_func_cntl_1;\r\nmclk->MpllFuncCntl_2 = mpll_func_cntl_2;\r\nmclk->MpllAdFuncCntl = mpll_ad_func_cntl;\r\nmclk->MpllDqFuncCntl = mpll_dq_func_cntl;\r\nmclk->MclkPwrmgtCntl = mclk_pwrmgt_cntl;\r\nmclk->DllCntl = dll_cntl;\r\nmclk->MpllSs1 = mpll_ss1;\r\nmclk->MpllSs2 = mpll_ss2;\r\nreturn 0;\r\n}\r\nstatic int ci_populate_single_memory_level(struct amdgpu_device *adev,\r\nu32 memory_clock,\r\nSMU7_Discrete_MemoryLevel *memory_level)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nint ret;\r\nbool dll_state_on;\r\nif (adev->pm.dpm.dyn_state.vddc_dependency_on_mclk.entries) {\r\nret = ci_get_dependency_volt_by_clk(adev,\r\n&adev->pm.dpm.dyn_state.vddc_dependency_on_mclk,\r\nmemory_clock, &memory_level->MinVddc);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (adev->pm.dpm.dyn_state.vddci_dependency_on_mclk.entries) {\r\nret = ci_get_dependency_volt_by_clk(adev,\r\n&adev->pm.dpm.dyn_state.vddci_dependency_on_mclk,\r\nmemory_clock, &memory_level->MinVddci);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (adev->pm.dpm.dyn_state.mvdd_dependency_on_mclk.entries) {\r\nret = ci_get_dependency_volt_by_clk(adev,\r\n&adev->pm.dpm.dyn_state.mvdd_dependency_on_mclk,\r\nmemory_clock, &memory_level->MinMvdd);\r\nif (ret)\r\nreturn ret;\r\n}\r\nmemory_level->MinVddcPhases = 1;\r\nif (pi->vddc_phase_shed_control)\r\nci_populate_phase_value_based_on_mclk(adev,\r\n&adev->pm.dpm.dyn_state.phase_shedding_limits_table,\r\nmemory_clock,\r\n&memory_level->MinVddcPhases);\r\nmemory_level->EnabledForActivity = 1;\r\nmemory_level->EnabledForThrottle = 1;\r\nmemory_level->UpH = 0;\r\nmemory_level->DownH = 100;\r\nmemory_level->VoltageDownH = 0;\r\nmemory_level->ActivityLevel = (u16)pi->mclk_activity_target;\r\nmemory_level->StutterEnable = false;\r\nmemory_level->StrobeEnable = false;\r\nmemory_level->EdcReadEnable = false;\r\nmemory_level->EdcWriteEnable = false;\r\nmemory_level->RttEnable = false;\r\nmemory_level->DisplayWatermark = PPSMC_DISPLAY_WATERMARK_LOW;\r\nif (pi->mclk_stutter_mode_threshold &&\r\n(memory_clock <= pi->mclk_stutter_mode_threshold) &&\r\n(!pi->uvd_enabled) &&\r\n(RREG32(mmDPG_PIPE_STUTTER_CONTROL) & DPG_PIPE_STUTTER_CONTROL__STUTTER_ENABLE_MASK) &&\r\n(adev->pm.dpm.new_active_crtc_count <= 2))\r\nmemory_level->StutterEnable = true;\r\nif (pi->mclk_strobe_mode_threshold &&\r\n(memory_clock <= pi->mclk_strobe_mode_threshold))\r\nmemory_level->StrobeEnable = 1;\r\nif (adev->mc.vram_type == AMDGPU_VRAM_TYPE_GDDR5) {\r\nmemory_level->StrobeRatio =\r\nci_get_mclk_frequency_ratio(memory_clock, memory_level->StrobeEnable);\r\nif (pi->mclk_edc_enable_threshold &&\r\n(memory_clock > pi->mclk_edc_enable_threshold))\r\nmemory_level->EdcReadEnable = true;\r\nif (pi->mclk_edc_wr_enable_threshold &&\r\n(memory_clock > pi->mclk_edc_wr_enable_threshold))\r\nmemory_level->EdcWriteEnable = true;\r\nif (memory_level->StrobeEnable) {\r\nif (ci_get_mclk_frequency_ratio(memory_clock, true) >=\r\n((RREG32(mmMC_SEQ_MISC7) >> 16) & 0xf))\r\ndll_state_on = ((RREG32(mmMC_SEQ_MISC5) >> 1) & 0x1) ? true : false;\r\nelse\r\ndll_state_on = ((RREG32(mmMC_SEQ_MISC6) >> 1) & 0x1) ? true : false;\r\n} else {\r\ndll_state_on = pi->dll_default_on;\r\n}\r\n} else {\r\nmemory_level->StrobeRatio = ci_get_ddr3_mclk_frequency_ratio(memory_clock);\r\ndll_state_on = ((RREG32(mmMC_SEQ_MISC5) >> 1) & 0x1) ? true : false;\r\n}\r\nret = ci_calculate_mclk_params(adev, memory_clock, memory_level, memory_level->StrobeEnable, dll_state_on);\r\nif (ret)\r\nreturn ret;\r\nmemory_level->MinVddc = cpu_to_be32(memory_level->MinVddc * VOLTAGE_SCALE);\r\nmemory_level->MinVddcPhases = cpu_to_be32(memory_level->MinVddcPhases);\r\nmemory_level->MinVddci = cpu_to_be32(memory_level->MinVddci * VOLTAGE_SCALE);\r\nmemory_level->MinMvdd = cpu_to_be32(memory_level->MinMvdd * VOLTAGE_SCALE);\r\nmemory_level->MclkFrequency = cpu_to_be32(memory_level->MclkFrequency);\r\nmemory_level->ActivityLevel = cpu_to_be16(memory_level->ActivityLevel);\r\nmemory_level->MpllFuncCntl = cpu_to_be32(memory_level->MpllFuncCntl);\r\nmemory_level->MpllFuncCntl_1 = cpu_to_be32(memory_level->MpllFuncCntl_1);\r\nmemory_level->MpllFuncCntl_2 = cpu_to_be32(memory_level->MpllFuncCntl_2);\r\nmemory_level->MpllAdFuncCntl = cpu_to_be32(memory_level->MpllAdFuncCntl);\r\nmemory_level->MpllDqFuncCntl = cpu_to_be32(memory_level->MpllDqFuncCntl);\r\nmemory_level->MclkPwrmgtCntl = cpu_to_be32(memory_level->MclkPwrmgtCntl);\r\nmemory_level->DllCntl = cpu_to_be32(memory_level->DllCntl);\r\nmemory_level->MpllSs1 = cpu_to_be32(memory_level->MpllSs1);\r\nmemory_level->MpllSs2 = cpu_to_be32(memory_level->MpllSs2);\r\nreturn 0;\r\n}\r\nstatic int ci_populate_smc_acpi_level(struct amdgpu_device *adev,\r\nSMU7_Discrete_DpmTable *table)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nstruct atom_clock_dividers dividers;\r\nSMU7_Discrete_VoltageLevel voltage_level;\r\nu32 spll_func_cntl = pi->clock_registers.cg_spll_func_cntl;\r\nu32 spll_func_cntl_2 = pi->clock_registers.cg_spll_func_cntl_2;\r\nu32 dll_cntl = pi->clock_registers.dll_cntl;\r\nu32 mclk_pwrmgt_cntl = pi->clock_registers.mclk_pwrmgt_cntl;\r\nint ret;\r\ntable->ACPILevel.Flags &= ~PPSMC_SWSTATE_FLAG_DC;\r\nif (pi->acpi_vddc)\r\ntable->ACPILevel.MinVddc = cpu_to_be32(pi->acpi_vddc * VOLTAGE_SCALE);\r\nelse\r\ntable->ACPILevel.MinVddc = cpu_to_be32(pi->min_vddc_in_pp_table * VOLTAGE_SCALE);\r\ntable->ACPILevel.MinVddcPhases = pi->vddc_phase_shed_control ? 0 : 1;\r\ntable->ACPILevel.SclkFrequency = adev->clock.spll.reference_freq;\r\nret = amdgpu_atombios_get_clock_dividers(adev,\r\nCOMPUTE_GPUCLK_INPUT_FLAG_SCLK,\r\ntable->ACPILevel.SclkFrequency, false, &dividers);\r\nif (ret)\r\nreturn ret;\r\ntable->ACPILevel.SclkDid = (u8)dividers.post_divider;\r\ntable->ACPILevel.DisplayWatermark = PPSMC_DISPLAY_WATERMARK_LOW;\r\ntable->ACPILevel.DeepSleepDivId = 0;\r\nspll_func_cntl &= ~CG_SPLL_FUNC_CNTL__SPLL_PWRON_MASK;\r\nspll_func_cntl |= CG_SPLL_FUNC_CNTL__SPLL_RESET_MASK;\r\nspll_func_cntl_2 &= ~CG_SPLL_FUNC_CNTL_2__SCLK_MUX_SEL_MASK;\r\nspll_func_cntl_2 |= (4 << CG_SPLL_FUNC_CNTL_2__SCLK_MUX_SEL__SHIFT);\r\ntable->ACPILevel.CgSpllFuncCntl = spll_func_cntl;\r\ntable->ACPILevel.CgSpllFuncCntl2 = spll_func_cntl_2;\r\ntable->ACPILevel.CgSpllFuncCntl3 = pi->clock_registers.cg_spll_func_cntl_3;\r\ntable->ACPILevel.CgSpllFuncCntl4 = pi->clock_registers.cg_spll_func_cntl_4;\r\ntable->ACPILevel.SpllSpreadSpectrum = pi->clock_registers.cg_spll_spread_spectrum;\r\ntable->ACPILevel.SpllSpreadSpectrum2 = pi->clock_registers.cg_spll_spread_spectrum_2;\r\ntable->ACPILevel.CcPwrDynRm = 0;\r\ntable->ACPILevel.CcPwrDynRm1 = 0;\r\ntable->ACPILevel.Flags = cpu_to_be32(table->ACPILevel.Flags);\r\ntable->ACPILevel.MinVddcPhases = cpu_to_be32(table->ACPILevel.MinVddcPhases);\r\ntable->ACPILevel.SclkFrequency = cpu_to_be32(table->ACPILevel.SclkFrequency);\r\ntable->ACPILevel.CgSpllFuncCntl = cpu_to_be32(table->ACPILevel.CgSpllFuncCntl);\r\ntable->ACPILevel.CgSpllFuncCntl2 = cpu_to_be32(table->ACPILevel.CgSpllFuncCntl2);\r\ntable->ACPILevel.CgSpllFuncCntl3 = cpu_to_be32(table->ACPILevel.CgSpllFuncCntl3);\r\ntable->ACPILevel.CgSpllFuncCntl4 = cpu_to_be32(table->ACPILevel.CgSpllFuncCntl4);\r\ntable->ACPILevel.SpllSpreadSpectrum = cpu_to_be32(table->ACPILevel.SpllSpreadSpectrum);\r\ntable->ACPILevel.SpllSpreadSpectrum2 = cpu_to_be32(table->ACPILevel.SpllSpreadSpectrum2);\r\ntable->ACPILevel.CcPwrDynRm = cpu_to_be32(table->ACPILevel.CcPwrDynRm);\r\ntable->ACPILevel.CcPwrDynRm1 = cpu_to_be32(table->ACPILevel.CcPwrDynRm1);\r\ntable->MemoryACPILevel.MinVddc = table->ACPILevel.MinVddc;\r\ntable->MemoryACPILevel.MinVddcPhases = table->ACPILevel.MinVddcPhases;\r\nif (pi->vddci_control != CISLANDS_VOLTAGE_CONTROL_NONE) {\r\nif (pi->acpi_vddci)\r\ntable->MemoryACPILevel.MinVddci =\r\ncpu_to_be32(pi->acpi_vddci * VOLTAGE_SCALE);\r\nelse\r\ntable->MemoryACPILevel.MinVddci =\r\ncpu_to_be32(pi->min_vddci_in_pp_table * VOLTAGE_SCALE);\r\n}\r\nif (ci_populate_mvdd_value(adev, 0, &voltage_level))\r\ntable->MemoryACPILevel.MinMvdd = 0;\r\nelse\r\ntable->MemoryACPILevel.MinMvdd =\r\ncpu_to_be32(voltage_level.Voltage * VOLTAGE_SCALE);\r\nmclk_pwrmgt_cntl |= MCLK_PWRMGT_CNTL__MRDCK0_RESET_MASK |\r\nMCLK_PWRMGT_CNTL__MRDCK1_RESET_MASK;\r\nmclk_pwrmgt_cntl &= ~(MCLK_PWRMGT_CNTL__MRDCK0_PDNB_MASK |\r\nMCLK_PWRMGT_CNTL__MRDCK1_PDNB_MASK);\r\ndll_cntl &= ~(DLL_CNTL__MRDCK0_BYPASS_MASK | DLL_CNTL__MRDCK1_BYPASS_MASK);\r\ntable->MemoryACPILevel.DllCntl = cpu_to_be32(dll_cntl);\r\ntable->MemoryACPILevel.MclkPwrmgtCntl = cpu_to_be32(mclk_pwrmgt_cntl);\r\ntable->MemoryACPILevel.MpllAdFuncCntl =\r\ncpu_to_be32(pi->clock_registers.mpll_ad_func_cntl);\r\ntable->MemoryACPILevel.MpllDqFuncCntl =\r\ncpu_to_be32(pi->clock_registers.mpll_dq_func_cntl);\r\ntable->MemoryACPILevel.MpllFuncCntl =\r\ncpu_to_be32(pi->clock_registers.mpll_func_cntl);\r\ntable->MemoryACPILevel.MpllFuncCntl_1 =\r\ncpu_to_be32(pi->clock_registers.mpll_func_cntl_1);\r\ntable->MemoryACPILevel.MpllFuncCntl_2 =\r\ncpu_to_be32(pi->clock_registers.mpll_func_cntl_2);\r\ntable->MemoryACPILevel.MpllSs1 = cpu_to_be32(pi->clock_registers.mpll_ss1);\r\ntable->MemoryACPILevel.MpllSs2 = cpu_to_be32(pi->clock_registers.mpll_ss2);\r\ntable->MemoryACPILevel.EnabledForThrottle = 0;\r\ntable->MemoryACPILevel.EnabledForActivity = 0;\r\ntable->MemoryACPILevel.UpH = 0;\r\ntable->MemoryACPILevel.DownH = 100;\r\ntable->MemoryACPILevel.VoltageDownH = 0;\r\ntable->MemoryACPILevel.ActivityLevel =\r\ncpu_to_be16((u16)pi->mclk_activity_target);\r\ntable->MemoryACPILevel.StutterEnable = false;\r\ntable->MemoryACPILevel.StrobeEnable = false;\r\ntable->MemoryACPILevel.EdcReadEnable = false;\r\ntable->MemoryACPILevel.EdcWriteEnable = false;\r\ntable->MemoryACPILevel.RttEnable = false;\r\nreturn 0;\r\n}\r\nstatic int ci_enable_ulv(struct amdgpu_device *adev, bool enable)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nstruct ci_ulv_parm *ulv = &pi->ulv;\r\nif (ulv->supported) {\r\nif (enable)\r\nreturn (amdgpu_ci_send_msg_to_smc(adev, PPSMC_MSG_EnableULV) == PPSMC_Result_OK) ?\r\n0 : -EINVAL;\r\nelse\r\nreturn (amdgpu_ci_send_msg_to_smc(adev, PPSMC_MSG_DisableULV) == PPSMC_Result_OK) ?\r\n0 : -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ci_populate_ulv_level(struct amdgpu_device *adev,\r\nSMU7_Discrete_Ulv *state)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nu16 ulv_voltage = adev->pm.dpm.backbias_response_time;\r\nstate->CcPwrDynRm = 0;\r\nstate->CcPwrDynRm1 = 0;\r\nif (ulv_voltage == 0) {\r\npi->ulv.supported = false;\r\nreturn 0;\r\n}\r\nif (pi->voltage_control != CISLANDS_VOLTAGE_CONTROL_BY_SVID2) {\r\nif (ulv_voltage > adev->pm.dpm.dyn_state.vddc_dependency_on_sclk.entries[0].v)\r\nstate->VddcOffset = 0;\r\nelse\r\nstate->VddcOffset =\r\nadev->pm.dpm.dyn_state.vddc_dependency_on_sclk.entries[0].v - ulv_voltage;\r\n} else {\r\nif (ulv_voltage > adev->pm.dpm.dyn_state.vddc_dependency_on_sclk.entries[0].v)\r\nstate->VddcOffsetVid = 0;\r\nelse\r\nstate->VddcOffsetVid = (u8)\r\n((adev->pm.dpm.dyn_state.vddc_dependency_on_sclk.entries[0].v - ulv_voltage) *\r\nVOLTAGE_VID_OFFSET_SCALE2 / VOLTAGE_VID_OFFSET_SCALE1);\r\n}\r\nstate->VddcPhase = pi->vddc_phase_shed_control ? 0 : 1;\r\nstate->CcPwrDynRm = cpu_to_be32(state->CcPwrDynRm);\r\nstate->CcPwrDynRm1 = cpu_to_be32(state->CcPwrDynRm1);\r\nstate->VddcOffset = cpu_to_be16(state->VddcOffset);\r\nreturn 0;\r\n}\r\nstatic int ci_calculate_sclk_params(struct amdgpu_device *adev,\r\nu32 engine_clock,\r\nSMU7_Discrete_GraphicsLevel *sclk)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nstruct atom_clock_dividers dividers;\r\nu32 spll_func_cntl_3 = pi->clock_registers.cg_spll_func_cntl_3;\r\nu32 spll_func_cntl_4 = pi->clock_registers.cg_spll_func_cntl_4;\r\nu32 cg_spll_spread_spectrum = pi->clock_registers.cg_spll_spread_spectrum;\r\nu32 cg_spll_spread_spectrum_2 = pi->clock_registers.cg_spll_spread_spectrum_2;\r\nu32 reference_clock = adev->clock.spll.reference_freq;\r\nu32 reference_divider;\r\nu32 fbdiv;\r\nint ret;\r\nret = amdgpu_atombios_get_clock_dividers(adev,\r\nCOMPUTE_GPUCLK_INPUT_FLAG_SCLK,\r\nengine_clock, false, &dividers);\r\nif (ret)\r\nreturn ret;\r\nreference_divider = 1 + dividers.ref_div;\r\nfbdiv = dividers.fb_div & 0x3FFFFFF;\r\nspll_func_cntl_3 &= ~CG_SPLL_FUNC_CNTL_3__SPLL_FB_DIV_MASK;\r\nspll_func_cntl_3 |= (fbdiv << CG_SPLL_FUNC_CNTL_3__SPLL_FB_DIV__SHIFT);\r\nspll_func_cntl_3 |= CG_SPLL_FUNC_CNTL_3__SPLL_DITHEN_MASK;\r\nif (pi->caps_sclk_ss_support) {\r\nstruct amdgpu_atom_ss ss;\r\nu32 vco_freq = engine_clock * dividers.post_div;\r\nif (amdgpu_atombios_get_asic_ss_info(adev, &ss,\r\nASIC_INTERNAL_ENGINE_SS, vco_freq)) {\r\nu32 clk_s = reference_clock * 5 / (reference_divider * ss.rate);\r\nu32 clk_v = 4 * ss.percentage * fbdiv / (clk_s * 10000);\r\ncg_spll_spread_spectrum &= ~(CG_SPLL_SPREAD_SPECTRUM__CLKS_MASK | CG_SPLL_SPREAD_SPECTRUM__SSEN_MASK);\r\ncg_spll_spread_spectrum |= (clk_s << CG_SPLL_SPREAD_SPECTRUM__CLKS__SHIFT);\r\ncg_spll_spread_spectrum |= (1 << CG_SPLL_SPREAD_SPECTRUM__SSEN__SHIFT);\r\ncg_spll_spread_spectrum_2 &= ~CG_SPLL_SPREAD_SPECTRUM_2__CLKV_MASK;\r\ncg_spll_spread_spectrum_2 |= (clk_v << CG_SPLL_SPREAD_SPECTRUM_2__CLKV__SHIFT);\r\n}\r\n}\r\nsclk->SclkFrequency = engine_clock;\r\nsclk->CgSpllFuncCntl3 = spll_func_cntl_3;\r\nsclk->CgSpllFuncCntl4 = spll_func_cntl_4;\r\nsclk->SpllSpreadSpectrum = cg_spll_spread_spectrum;\r\nsclk->SpllSpreadSpectrum2 = cg_spll_spread_spectrum_2;\r\nsclk->SclkDid = (u8)dividers.post_divider;\r\nreturn 0;\r\n}\r\nstatic int ci_populate_single_graphic_level(struct amdgpu_device *adev,\r\nu32 engine_clock,\r\nu16 sclk_activity_level_t,\r\nSMU7_Discrete_GraphicsLevel *graphic_level)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nint ret;\r\nret = ci_calculate_sclk_params(adev, engine_clock, graphic_level);\r\nif (ret)\r\nreturn ret;\r\nret = ci_get_dependency_volt_by_clk(adev,\r\n&adev->pm.dpm.dyn_state.vddc_dependency_on_sclk,\r\nengine_clock, &graphic_level->MinVddc);\r\nif (ret)\r\nreturn ret;\r\ngraphic_level->SclkFrequency = engine_clock;\r\ngraphic_level->Flags = 0;\r\ngraphic_level->MinVddcPhases = 1;\r\nif (pi->vddc_phase_shed_control)\r\nci_populate_phase_value_based_on_sclk(adev,\r\n&adev->pm.dpm.dyn_state.phase_shedding_limits_table,\r\nengine_clock,\r\n&graphic_level->MinVddcPhases);\r\ngraphic_level->ActivityLevel = sclk_activity_level_t;\r\ngraphic_level->CcPwrDynRm = 0;\r\ngraphic_level->CcPwrDynRm1 = 0;\r\ngraphic_level->EnabledForThrottle = 1;\r\ngraphic_level->UpH = 0;\r\ngraphic_level->DownH = 0;\r\ngraphic_level->VoltageDownH = 0;\r\ngraphic_level->PowerThrottle = 0;\r\nif (pi->caps_sclk_ds)\r\ngraphic_level->DeepSleepDivId = ci_get_sleep_divider_id_from_clock(engine_clock,\r\nCISLAND_MINIMUM_ENGINE_CLOCK);\r\ngraphic_level->DisplayWatermark = PPSMC_DISPLAY_WATERMARK_LOW;\r\ngraphic_level->Flags = cpu_to_be32(graphic_level->Flags);\r\ngraphic_level->MinVddc = cpu_to_be32(graphic_level->MinVddc * VOLTAGE_SCALE);\r\ngraphic_level->MinVddcPhases = cpu_to_be32(graphic_level->MinVddcPhases);\r\ngraphic_level->SclkFrequency = cpu_to_be32(graphic_level->SclkFrequency);\r\ngraphic_level->ActivityLevel = cpu_to_be16(graphic_level->ActivityLevel);\r\ngraphic_level->CgSpllFuncCntl3 = cpu_to_be32(graphic_level->CgSpllFuncCntl3);\r\ngraphic_level->CgSpllFuncCntl4 = cpu_to_be32(graphic_level->CgSpllFuncCntl4);\r\ngraphic_level->SpllSpreadSpectrum = cpu_to_be32(graphic_level->SpllSpreadSpectrum);\r\ngraphic_level->SpllSpreadSpectrum2 = cpu_to_be32(graphic_level->SpllSpreadSpectrum2);\r\ngraphic_level->CcPwrDynRm = cpu_to_be32(graphic_level->CcPwrDynRm);\r\ngraphic_level->CcPwrDynRm1 = cpu_to_be32(graphic_level->CcPwrDynRm1);\r\nreturn 0;\r\n}\r\nstatic int ci_populate_all_graphic_levels(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nstruct ci_dpm_table *dpm_table = &pi->dpm_table;\r\nu32 level_array_address = pi->dpm_table_start +\r\noffsetof(SMU7_Discrete_DpmTable, GraphicsLevel);\r\nu32 level_array_size = sizeof(SMU7_Discrete_GraphicsLevel) *\r\nSMU7_MAX_LEVELS_GRAPHICS;\r\nSMU7_Discrete_GraphicsLevel *levels = pi->smc_state_table.GraphicsLevel;\r\nu32 i, ret;\r\nmemset(levels, 0, level_array_size);\r\nfor (i = 0; i < dpm_table->sclk_table.count; i++) {\r\nret = ci_populate_single_graphic_level(adev,\r\ndpm_table->sclk_table.dpm_levels[i].value,\r\n(u16)pi->activity_target[i],\r\n&pi->smc_state_table.GraphicsLevel[i]);\r\nif (ret)\r\nreturn ret;\r\nif (i > 1)\r\npi->smc_state_table.GraphicsLevel[i].DeepSleepDivId = 0;\r\nif (i == (dpm_table->sclk_table.count - 1))\r\npi->smc_state_table.GraphicsLevel[i].DisplayWatermark =\r\nPPSMC_DISPLAY_WATERMARK_HIGH;\r\n}\r\npi->smc_state_table.GraphicsLevel[0].EnabledForActivity = 1;\r\npi->smc_state_table.GraphicsDpmLevelCount = (u8)dpm_table->sclk_table.count;\r\npi->dpm_level_enable_mask.sclk_dpm_enable_mask =\r\nci_get_dpm_level_enable_mask_value(&dpm_table->sclk_table);\r\nret = amdgpu_ci_copy_bytes_to_smc(adev, level_array_address,\r\n(u8 *)levels, level_array_size,\r\npi->sram_end);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int ci_populate_ulv_state(struct amdgpu_device *adev,\r\nSMU7_Discrete_Ulv *ulv_level)\r\n{\r\nreturn ci_populate_ulv_level(adev, ulv_level);\r\n}\r\nstatic int ci_populate_all_memory_levels(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nstruct ci_dpm_table *dpm_table = &pi->dpm_table;\r\nu32 level_array_address = pi->dpm_table_start +\r\noffsetof(SMU7_Discrete_DpmTable, MemoryLevel);\r\nu32 level_array_size = sizeof(SMU7_Discrete_MemoryLevel) *\r\nSMU7_MAX_LEVELS_MEMORY;\r\nSMU7_Discrete_MemoryLevel *levels = pi->smc_state_table.MemoryLevel;\r\nu32 i, ret;\r\nmemset(levels, 0, level_array_size);\r\nfor (i = 0; i < dpm_table->mclk_table.count; i++) {\r\nif (dpm_table->mclk_table.dpm_levels[i].value == 0)\r\nreturn -EINVAL;\r\nret = ci_populate_single_memory_level(adev,\r\ndpm_table->mclk_table.dpm_levels[i].value,\r\n&pi->smc_state_table.MemoryLevel[i]);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif ((dpm_table->mclk_table.count >= 2) &&\r\n((adev->pdev->device == 0x67B0) || (adev->pdev->device == 0x67B1))) {\r\npi->smc_state_table.MemoryLevel[1].MinVddc =\r\npi->smc_state_table.MemoryLevel[0].MinVddc;\r\npi->smc_state_table.MemoryLevel[1].MinVddcPhases =\r\npi->smc_state_table.MemoryLevel[0].MinVddcPhases;\r\n}\r\npi->smc_state_table.MemoryLevel[0].ActivityLevel = cpu_to_be16(0x1F);\r\npi->smc_state_table.MemoryDpmLevelCount = (u8)dpm_table->mclk_table.count;\r\npi->dpm_level_enable_mask.mclk_dpm_enable_mask =\r\nci_get_dpm_level_enable_mask_value(&dpm_table->mclk_table);\r\npi->smc_state_table.MemoryLevel[dpm_table->mclk_table.count - 1].DisplayWatermark =\r\nPPSMC_DISPLAY_WATERMARK_HIGH;\r\nret = amdgpu_ci_copy_bytes_to_smc(adev, level_array_address,\r\n(u8 *)levels, level_array_size,\r\npi->sram_end);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic void ci_reset_single_dpm_table(struct amdgpu_device *adev,\r\nstruct ci_single_dpm_table* dpm_table,\r\nu32 count)\r\n{\r\nu32 i;\r\ndpm_table->count = count;\r\nfor (i = 0; i < MAX_REGULAR_DPM_NUMBER; i++)\r\ndpm_table->dpm_levels[i].enabled = false;\r\n}\r\nstatic void ci_setup_pcie_table_entry(struct ci_single_dpm_table* dpm_table,\r\nu32 index, u32 pcie_gen, u32 pcie_lanes)\r\n{\r\ndpm_table->dpm_levels[index].value = pcie_gen;\r\ndpm_table->dpm_levels[index].param1 = pcie_lanes;\r\ndpm_table->dpm_levels[index].enabled = true;\r\n}\r\nstatic int ci_setup_default_pcie_tables(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nif (!pi->use_pcie_performance_levels && !pi->use_pcie_powersaving_levels)\r\nreturn -EINVAL;\r\nif (pi->use_pcie_performance_levels && !pi->use_pcie_powersaving_levels) {\r\npi->pcie_gen_powersaving = pi->pcie_gen_performance;\r\npi->pcie_lane_powersaving = pi->pcie_lane_performance;\r\n} else if (!pi->use_pcie_performance_levels && pi->use_pcie_powersaving_levels) {\r\npi->pcie_gen_performance = pi->pcie_gen_powersaving;\r\npi->pcie_lane_performance = pi->pcie_lane_powersaving;\r\n}\r\nci_reset_single_dpm_table(adev,\r\n&pi->dpm_table.pcie_speed_table,\r\nSMU7_MAX_LEVELS_LINK);\r\nif (adev->asic_type == CHIP_BONAIRE)\r\nci_setup_pcie_table_entry(&pi->dpm_table.pcie_speed_table, 0,\r\npi->pcie_gen_powersaving.min,\r\npi->pcie_lane_powersaving.max);\r\nelse\r\nci_setup_pcie_table_entry(&pi->dpm_table.pcie_speed_table, 0,\r\npi->pcie_gen_powersaving.min,\r\npi->pcie_lane_powersaving.min);\r\nci_setup_pcie_table_entry(&pi->dpm_table.pcie_speed_table, 1,\r\npi->pcie_gen_performance.min,\r\npi->pcie_lane_performance.min);\r\nci_setup_pcie_table_entry(&pi->dpm_table.pcie_speed_table, 2,\r\npi->pcie_gen_powersaving.min,\r\npi->pcie_lane_powersaving.max);\r\nci_setup_pcie_table_entry(&pi->dpm_table.pcie_speed_table, 3,\r\npi->pcie_gen_performance.min,\r\npi->pcie_lane_performance.max);\r\nci_setup_pcie_table_entry(&pi->dpm_table.pcie_speed_table, 4,\r\npi->pcie_gen_powersaving.max,\r\npi->pcie_lane_powersaving.max);\r\nci_setup_pcie_table_entry(&pi->dpm_table.pcie_speed_table, 5,\r\npi->pcie_gen_performance.max,\r\npi->pcie_lane_performance.max);\r\npi->dpm_table.pcie_speed_table.count = 6;\r\nreturn 0;\r\n}\r\nstatic int ci_setup_default_dpm_tables(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nstruct amdgpu_clock_voltage_dependency_table *allowed_sclk_vddc_table =\r\n&adev->pm.dpm.dyn_state.vddc_dependency_on_sclk;\r\nstruct amdgpu_clock_voltage_dependency_table *allowed_mclk_table =\r\n&adev->pm.dpm.dyn_state.vddc_dependency_on_mclk;\r\nstruct amdgpu_cac_leakage_table *std_voltage_table =\r\n&adev->pm.dpm.dyn_state.cac_leakage_table;\r\nu32 i;\r\nif (allowed_sclk_vddc_table == NULL)\r\nreturn -EINVAL;\r\nif (allowed_sclk_vddc_table->count < 1)\r\nreturn -EINVAL;\r\nif (allowed_mclk_table == NULL)\r\nreturn -EINVAL;\r\nif (allowed_mclk_table->count < 1)\r\nreturn -EINVAL;\r\nmemset(&pi->dpm_table, 0, sizeof(struct ci_dpm_table));\r\nci_reset_single_dpm_table(adev,\r\n&pi->dpm_table.sclk_table,\r\nSMU7_MAX_LEVELS_GRAPHICS);\r\nci_reset_single_dpm_table(adev,\r\n&pi->dpm_table.mclk_table,\r\nSMU7_MAX_LEVELS_MEMORY);\r\nci_reset_single_dpm_table(adev,\r\n&pi->dpm_table.vddc_table,\r\nSMU7_MAX_LEVELS_VDDC);\r\nci_reset_single_dpm_table(adev,\r\n&pi->dpm_table.vddci_table,\r\nSMU7_MAX_LEVELS_VDDCI);\r\nci_reset_single_dpm_table(adev,\r\n&pi->dpm_table.mvdd_table,\r\nSMU7_MAX_LEVELS_MVDD);\r\npi->dpm_table.sclk_table.count = 0;\r\nfor (i = 0; i < allowed_sclk_vddc_table->count; i++) {\r\nif ((i == 0) ||\r\n(pi->dpm_table.sclk_table.dpm_levels[pi->dpm_table.sclk_table.count-1].value !=\r\nallowed_sclk_vddc_table->entries[i].clk)) {\r\npi->dpm_table.sclk_table.dpm_levels[pi->dpm_table.sclk_table.count].value =\r\nallowed_sclk_vddc_table->entries[i].clk;\r\npi->dpm_table.sclk_table.dpm_levels[pi->dpm_table.sclk_table.count].enabled =\r\n(i == 0) ? true : false;\r\npi->dpm_table.sclk_table.count++;\r\n}\r\n}\r\npi->dpm_table.mclk_table.count = 0;\r\nfor (i = 0; i < allowed_mclk_table->count; i++) {\r\nif ((i == 0) ||\r\n(pi->dpm_table.mclk_table.dpm_levels[pi->dpm_table.mclk_table.count-1].value !=\r\nallowed_mclk_table->entries[i].clk)) {\r\npi->dpm_table.mclk_table.dpm_levels[pi->dpm_table.mclk_table.count].value =\r\nallowed_mclk_table->entries[i].clk;\r\npi->dpm_table.mclk_table.dpm_levels[pi->dpm_table.mclk_table.count].enabled =\r\n(i == 0) ? true : false;\r\npi->dpm_table.mclk_table.count++;\r\n}\r\n}\r\nfor (i = 0; i < allowed_sclk_vddc_table->count; i++) {\r\npi->dpm_table.vddc_table.dpm_levels[i].value =\r\nallowed_sclk_vddc_table->entries[i].v;\r\npi->dpm_table.vddc_table.dpm_levels[i].param1 =\r\nstd_voltage_table->entries[i].leakage;\r\npi->dpm_table.vddc_table.dpm_levels[i].enabled = true;\r\n}\r\npi->dpm_table.vddc_table.count = allowed_sclk_vddc_table->count;\r\nallowed_mclk_table = &adev->pm.dpm.dyn_state.vddci_dependency_on_mclk;\r\nif (allowed_mclk_table) {\r\nfor (i = 0; i < allowed_mclk_table->count; i++) {\r\npi->dpm_table.vddci_table.dpm_levels[i].value =\r\nallowed_mclk_table->entries[i].v;\r\npi->dpm_table.vddci_table.dpm_levels[i].enabled = true;\r\n}\r\npi->dpm_table.vddci_table.count = allowed_mclk_table->count;\r\n}\r\nallowed_mclk_table = &adev->pm.dpm.dyn_state.mvdd_dependency_on_mclk;\r\nif (allowed_mclk_table) {\r\nfor (i = 0; i < allowed_mclk_table->count; i++) {\r\npi->dpm_table.mvdd_table.dpm_levels[i].value =\r\nallowed_mclk_table->entries[i].v;\r\npi->dpm_table.mvdd_table.dpm_levels[i].enabled = true;\r\n}\r\npi->dpm_table.mvdd_table.count = allowed_mclk_table->count;\r\n}\r\nci_setup_default_pcie_tables(adev);\r\nmemcpy(&(pi->golden_dpm_table), &(pi->dpm_table),\r\nsizeof(struct ci_dpm_table));\r\nreturn 0;\r\n}\r\nstatic int ci_find_boot_level(struct ci_single_dpm_table *table,\r\nu32 value, u32 *boot_level)\r\n{\r\nu32 i;\r\nint ret = -EINVAL;\r\nfor(i = 0; i < table->count; i++) {\r\nif (value == table->dpm_levels[i].value) {\r\n*boot_level = i;\r\nret = 0;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void ci_save_default_power_profile(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nstruct SMU7_Discrete_GraphicsLevel *levels =\r\npi->smc_state_table.GraphicsLevel;\r\nuint32_t min_level = 0;\r\npi->default_gfx_power_profile.activity_threshold =\r\nbe16_to_cpu(levels[0].ActivityLevel);\r\npi->default_gfx_power_profile.up_hyst = levels[0].UpH;\r\npi->default_gfx_power_profile.down_hyst = levels[0].DownH;\r\npi->default_gfx_power_profile.type = AMD_PP_GFX_PROFILE;\r\npi->default_compute_power_profile = pi->default_gfx_power_profile;\r\npi->default_compute_power_profile.type = AMD_PP_COMPUTE_PROFILE;\r\nif (pi->smc_state_table.GraphicsDpmLevelCount > 2)\r\nmin_level = pi->smc_state_table.GraphicsDpmLevelCount - 2;\r\nelse if (pi->smc_state_table.GraphicsDpmLevelCount == 2)\r\nmin_level = 1;\r\npi->default_compute_power_profile.min_sclk =\r\nbe32_to_cpu(levels[min_level].SclkFrequency);\r\npi->default_compute_power_profile.up_hyst = 0;\r\npi->default_compute_power_profile.down_hyst = 5;\r\npi->gfx_power_profile = pi->default_gfx_power_profile;\r\npi->compute_power_profile = pi->default_compute_power_profile;\r\n}\r\nstatic int ci_init_smc_table(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nstruct ci_ulv_parm *ulv = &pi->ulv;\r\nstruct amdgpu_ps *amdgpu_boot_state = adev->pm.dpm.boot_ps;\r\nSMU7_Discrete_DpmTable *table = &pi->smc_state_table;\r\nint ret;\r\nret = ci_setup_default_dpm_tables(adev);\r\nif (ret)\r\nreturn ret;\r\nif (pi->voltage_control != CISLANDS_VOLTAGE_CONTROL_NONE)\r\nci_populate_smc_voltage_tables(adev, table);\r\nci_init_fps_limits(adev);\r\nif (adev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_HARDWAREDC)\r\ntable->SystemFlags |= PPSMC_SYSTEMFLAG_GPIO_DC;\r\nif (adev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_STEPVDDC)\r\ntable->SystemFlags |= PPSMC_SYSTEMFLAG_STEPVDDC;\r\nif (adev->mc.vram_type == AMDGPU_VRAM_TYPE_GDDR5)\r\ntable->SystemFlags |= PPSMC_SYSTEMFLAG_GDDR5;\r\nif (ulv->supported) {\r\nret = ci_populate_ulv_state(adev, &pi->smc_state_table.Ulv);\r\nif (ret)\r\nreturn ret;\r\nWREG32_SMC(ixCG_ULV_PARAMETER, ulv->cg_ulv_parameter);\r\n}\r\nret = ci_populate_all_graphic_levels(adev);\r\nif (ret)\r\nreturn ret;\r\nret = ci_populate_all_memory_levels(adev);\r\nif (ret)\r\nreturn ret;\r\nci_populate_smc_link_level(adev, table);\r\nret = ci_populate_smc_acpi_level(adev, table);\r\nif (ret)\r\nreturn ret;\r\nret = ci_populate_smc_vce_level(adev, table);\r\nif (ret)\r\nreturn ret;\r\nret = ci_populate_smc_acp_level(adev, table);\r\nif (ret)\r\nreturn ret;\r\nret = ci_populate_smc_samu_level(adev, table);\r\nif (ret)\r\nreturn ret;\r\nret = ci_do_program_memory_timing_parameters(adev);\r\nif (ret)\r\nreturn ret;\r\nret = ci_populate_smc_uvd_level(adev, table);\r\nif (ret)\r\nreturn ret;\r\ntable->UvdBootLevel = 0;\r\ntable->VceBootLevel = 0;\r\ntable->AcpBootLevel = 0;\r\ntable->SamuBootLevel = 0;\r\ntable->GraphicsBootLevel = 0;\r\ntable->MemoryBootLevel = 0;\r\nret = ci_find_boot_level(&pi->dpm_table.sclk_table,\r\npi->vbios_boot_state.sclk_bootup_value,\r\n(u32 *)&pi->smc_state_table.GraphicsBootLevel);\r\nret = ci_find_boot_level(&pi->dpm_table.mclk_table,\r\npi->vbios_boot_state.mclk_bootup_value,\r\n(u32 *)&pi->smc_state_table.MemoryBootLevel);\r\ntable->BootVddc = pi->vbios_boot_state.vddc_bootup_value;\r\ntable->BootVddci = pi->vbios_boot_state.vddci_bootup_value;\r\ntable->BootMVdd = pi->vbios_boot_state.mvdd_bootup_value;\r\nci_populate_smc_initial_state(adev, amdgpu_boot_state);\r\nret = ci_populate_bapm_parameters_in_dpm_table(adev);\r\nif (ret)\r\nreturn ret;\r\ntable->UVDInterval = 1;\r\ntable->VCEInterval = 1;\r\ntable->ACPInterval = 1;\r\ntable->SAMUInterval = 1;\r\ntable->GraphicsVoltageChangeEnable = 1;\r\ntable->GraphicsThermThrottleEnable = 1;\r\ntable->GraphicsInterval = 1;\r\ntable->VoltageInterval = 1;\r\ntable->ThermalInterval = 1;\r\ntable->TemperatureLimitHigh = (u16)((pi->thermal_temp_setting.temperature_high *\r\nCISLANDS_Q88_FORMAT_CONVERSION_UNIT) / 1000);\r\ntable->TemperatureLimitLow = (u16)((pi->thermal_temp_setting.temperature_low *\r\nCISLANDS_Q88_FORMAT_CONVERSION_UNIT) / 1000);\r\ntable->MemoryVoltageChangeEnable = 1;\r\ntable->MemoryInterval = 1;\r\ntable->VoltageResponseTime = 0;\r\ntable->VddcVddciDelta = 4000;\r\ntable->PhaseResponseTime = 0;\r\ntable->MemoryThermThrottleEnable = 1;\r\ntable->PCIeBootLinkLevel = pi->dpm_table.pcie_speed_table.count - 1;\r\ntable->PCIeGenInterval = 1;\r\nif (pi->voltage_control == CISLANDS_VOLTAGE_CONTROL_BY_SVID2)\r\ntable->SVI2Enable = 1;\r\nelse\r\ntable->SVI2Enable = 0;\r\ntable->ThermGpio = 17;\r\ntable->SclkStepSize = 0x4000;\r\ntable->SystemFlags = cpu_to_be32(table->SystemFlags);\r\ntable->SmioMaskVddcVid = cpu_to_be32(table->SmioMaskVddcVid);\r\ntable->SmioMaskVddcPhase = cpu_to_be32(table->SmioMaskVddcPhase);\r\ntable->SmioMaskVddciVid = cpu_to_be32(table->SmioMaskVddciVid);\r\ntable->SmioMaskMvddVid = cpu_to_be32(table->SmioMaskMvddVid);\r\ntable->SclkStepSize = cpu_to_be32(table->SclkStepSize);\r\ntable->TemperatureLimitHigh = cpu_to_be16(table->TemperatureLimitHigh);\r\ntable->TemperatureLimitLow = cpu_to_be16(table->TemperatureLimitLow);\r\ntable->VddcVddciDelta = cpu_to_be16(table->VddcVddciDelta);\r\ntable->VoltageResponseTime = cpu_to_be16(table->VoltageResponseTime);\r\ntable->PhaseResponseTime = cpu_to_be16(table->PhaseResponseTime);\r\ntable->BootVddc = cpu_to_be16(table->BootVddc * VOLTAGE_SCALE);\r\ntable->BootVddci = cpu_to_be16(table->BootVddci * VOLTAGE_SCALE);\r\ntable->BootMVdd = cpu_to_be16(table->BootMVdd * VOLTAGE_SCALE);\r\nret = amdgpu_ci_copy_bytes_to_smc(adev,\r\npi->dpm_table_start +\r\noffsetof(SMU7_Discrete_DpmTable, SystemFlags),\r\n(u8 *)&table->SystemFlags,\r\nsizeof(SMU7_Discrete_DpmTable) - 3 * sizeof(SMU7_PIDController),\r\npi->sram_end);\r\nif (ret)\r\nreturn ret;\r\nci_save_default_power_profile(adev);\r\nreturn 0;\r\n}\r\nstatic void ci_trim_single_dpm_states(struct amdgpu_device *adev,\r\nstruct ci_single_dpm_table *dpm_table,\r\nu32 low_limit, u32 high_limit)\r\n{\r\nu32 i;\r\nfor (i = 0; i < dpm_table->count; i++) {\r\nif ((dpm_table->dpm_levels[i].value < low_limit) ||\r\n(dpm_table->dpm_levels[i].value > high_limit))\r\ndpm_table->dpm_levels[i].enabled = false;\r\nelse\r\ndpm_table->dpm_levels[i].enabled = true;\r\n}\r\n}\r\nstatic void ci_trim_pcie_dpm_states(struct amdgpu_device *adev,\r\nu32 speed_low, u32 lanes_low,\r\nu32 speed_high, u32 lanes_high)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nstruct ci_single_dpm_table *pcie_table = &pi->dpm_table.pcie_speed_table;\r\nu32 i, j;\r\nfor (i = 0; i < pcie_table->count; i++) {\r\nif ((pcie_table->dpm_levels[i].value < speed_low) ||\r\n(pcie_table->dpm_levels[i].param1 < lanes_low) ||\r\n(pcie_table->dpm_levels[i].value > speed_high) ||\r\n(pcie_table->dpm_levels[i].param1 > lanes_high))\r\npcie_table->dpm_levels[i].enabled = false;\r\nelse\r\npcie_table->dpm_levels[i].enabled = true;\r\n}\r\nfor (i = 0; i < pcie_table->count; i++) {\r\nif (pcie_table->dpm_levels[i].enabled) {\r\nfor (j = i + 1; j < pcie_table->count; j++) {\r\nif (pcie_table->dpm_levels[j].enabled) {\r\nif ((pcie_table->dpm_levels[i].value == pcie_table->dpm_levels[j].value) &&\r\n(pcie_table->dpm_levels[i].param1 == pcie_table->dpm_levels[j].param1))\r\npcie_table->dpm_levels[j].enabled = false;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic int ci_trim_dpm_states(struct amdgpu_device *adev,\r\nstruct amdgpu_ps *amdgpu_state)\r\n{\r\nstruct ci_ps *state = ci_get_ps(amdgpu_state);\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nu32 high_limit_count;\r\nif (state->performance_level_count < 1)\r\nreturn -EINVAL;\r\nif (state->performance_level_count == 1)\r\nhigh_limit_count = 0;\r\nelse\r\nhigh_limit_count = 1;\r\nci_trim_single_dpm_states(adev,\r\n&pi->dpm_table.sclk_table,\r\nstate->performance_levels[0].sclk,\r\nstate->performance_levels[high_limit_count].sclk);\r\nci_trim_single_dpm_states(adev,\r\n&pi->dpm_table.mclk_table,\r\nstate->performance_levels[0].mclk,\r\nstate->performance_levels[high_limit_count].mclk);\r\nci_trim_pcie_dpm_states(adev,\r\nstate->performance_levels[0].pcie_gen,\r\nstate->performance_levels[0].pcie_lane,\r\nstate->performance_levels[high_limit_count].pcie_gen,\r\nstate->performance_levels[high_limit_count].pcie_lane);\r\nreturn 0;\r\n}\r\nstatic int ci_apply_disp_minimum_voltage_request(struct amdgpu_device *adev)\r\n{\r\nstruct amdgpu_clock_voltage_dependency_table *disp_voltage_table =\r\n&adev->pm.dpm.dyn_state.vddc_dependency_on_dispclk;\r\nstruct amdgpu_clock_voltage_dependency_table *vddc_table =\r\n&adev->pm.dpm.dyn_state.vddc_dependency_on_sclk;\r\nu32 requested_voltage = 0;\r\nu32 i;\r\nif (disp_voltage_table == NULL)\r\nreturn -EINVAL;\r\nif (!disp_voltage_table->count)\r\nreturn -EINVAL;\r\nfor (i = 0; i < disp_voltage_table->count; i++) {\r\nif (adev->clock.current_dispclk == disp_voltage_table->entries[i].clk)\r\nrequested_voltage = disp_voltage_table->entries[i].v;\r\n}\r\nfor (i = 0; i < vddc_table->count; i++) {\r\nif (requested_voltage <= vddc_table->entries[i].v) {\r\nrequested_voltage = vddc_table->entries[i].v;\r\nreturn (amdgpu_ci_send_msg_to_smc_with_parameter(adev,\r\nPPSMC_MSG_VddC_Request,\r\nrequested_voltage * VOLTAGE_SCALE) == PPSMC_Result_OK) ?\r\n0 : -EINVAL;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ci_upload_dpm_level_enable_mask(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nPPSMC_Result result;\r\nci_apply_disp_minimum_voltage_request(adev);\r\nif (!pi->sclk_dpm_key_disabled) {\r\nif (pi->dpm_level_enable_mask.sclk_dpm_enable_mask) {\r\nresult = amdgpu_ci_send_msg_to_smc_with_parameter(adev,\r\nPPSMC_MSG_SCLKDPM_SetEnabledMask,\r\npi->dpm_level_enable_mask.sclk_dpm_enable_mask);\r\nif (result != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (!pi->mclk_dpm_key_disabled) {\r\nif (pi->dpm_level_enable_mask.mclk_dpm_enable_mask) {\r\nresult = amdgpu_ci_send_msg_to_smc_with_parameter(adev,\r\nPPSMC_MSG_MCLKDPM_SetEnabledMask,\r\npi->dpm_level_enable_mask.mclk_dpm_enable_mask);\r\nif (result != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\n}\r\n}\r\n#if 0\r\nif (!pi->pcie_dpm_key_disabled) {\r\nif (pi->dpm_level_enable_mask.pcie_dpm_enable_mask) {\r\nresult = amdgpu_ci_send_msg_to_smc_with_parameter(adev,\r\nPPSMC_MSG_PCIeDPM_SetEnabledMask,\r\npi->dpm_level_enable_mask.pcie_dpm_enable_mask);\r\nif (result != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\n}\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void ci_find_dpm_states_clocks_in_dpm_table(struct amdgpu_device *adev,\r\nstruct amdgpu_ps *amdgpu_state)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nstruct ci_ps *state = ci_get_ps(amdgpu_state);\r\nstruct ci_single_dpm_table *sclk_table = &pi->dpm_table.sclk_table;\r\nu32 sclk = state->performance_levels[state->performance_level_count-1].sclk;\r\nstruct ci_single_dpm_table *mclk_table = &pi->dpm_table.mclk_table;\r\nu32 mclk = state->performance_levels[state->performance_level_count-1].mclk;\r\nu32 i;\r\npi->need_update_smu7_dpm_table = 0;\r\nfor (i = 0; i < sclk_table->count; i++) {\r\nif (sclk == sclk_table->dpm_levels[i].value)\r\nbreak;\r\n}\r\nif (i >= sclk_table->count) {\r\npi->need_update_smu7_dpm_table |= DPMTABLE_OD_UPDATE_SCLK;\r\n} else {\r\nif (CISLAND_MINIMUM_ENGINE_CLOCK != CISLAND_MINIMUM_ENGINE_CLOCK)\r\npi->need_update_smu7_dpm_table |= DPMTABLE_UPDATE_SCLK;\r\n}\r\nfor (i = 0; i < mclk_table->count; i++) {\r\nif (mclk == mclk_table->dpm_levels[i].value)\r\nbreak;\r\n}\r\nif (i >= mclk_table->count)\r\npi->need_update_smu7_dpm_table |= DPMTABLE_OD_UPDATE_MCLK;\r\nif (adev->pm.dpm.current_active_crtc_count !=\r\nadev->pm.dpm.new_active_crtc_count)\r\npi->need_update_smu7_dpm_table |= DPMTABLE_UPDATE_MCLK;\r\n}\r\nstatic int ci_populate_and_upload_sclk_mclk_dpm_levels(struct amdgpu_device *adev,\r\nstruct amdgpu_ps *amdgpu_state)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nstruct ci_ps *state = ci_get_ps(amdgpu_state);\r\nu32 sclk = state->performance_levels[state->performance_level_count-1].sclk;\r\nu32 mclk = state->performance_levels[state->performance_level_count-1].mclk;\r\nstruct ci_dpm_table *dpm_table = &pi->dpm_table;\r\nint ret;\r\nif (!pi->need_update_smu7_dpm_table)\r\nreturn 0;\r\nif (pi->need_update_smu7_dpm_table & DPMTABLE_OD_UPDATE_SCLK)\r\ndpm_table->sclk_table.dpm_levels[dpm_table->sclk_table.count-1].value = sclk;\r\nif (pi->need_update_smu7_dpm_table & DPMTABLE_OD_UPDATE_MCLK)\r\ndpm_table->mclk_table.dpm_levels[dpm_table->mclk_table.count-1].value = mclk;\r\nif (pi->need_update_smu7_dpm_table & (DPMTABLE_OD_UPDATE_SCLK | DPMTABLE_UPDATE_SCLK)) {\r\nret = ci_populate_all_graphic_levels(adev);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (pi->need_update_smu7_dpm_table & (DPMTABLE_OD_UPDATE_MCLK | DPMTABLE_UPDATE_MCLK)) {\r\nret = ci_populate_all_memory_levels(adev);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ci_enable_uvd_dpm(struct amdgpu_device *adev, bool enable)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nconst struct amdgpu_clock_and_voltage_limits *max_limits;\r\nint i;\r\nif (adev->pm.dpm.ac_power)\r\nmax_limits = &adev->pm.dpm.dyn_state.max_clock_voltage_on_ac;\r\nelse\r\nmax_limits = &adev->pm.dpm.dyn_state.max_clock_voltage_on_dc;\r\nif (enable) {\r\npi->dpm_level_enable_mask.uvd_dpm_enable_mask = 0;\r\nfor (i = adev->pm.dpm.dyn_state.uvd_clock_voltage_dependency_table.count - 1; i >= 0; i--) {\r\nif (adev->pm.dpm.dyn_state.uvd_clock_voltage_dependency_table.entries[i].v <= max_limits->vddc) {\r\npi->dpm_level_enable_mask.uvd_dpm_enable_mask |= 1 << i;\r\nif (!pi->caps_uvd_dpm)\r\nbreak;\r\n}\r\n}\r\namdgpu_ci_send_msg_to_smc_with_parameter(adev,\r\nPPSMC_MSG_UVDDPM_SetEnabledMask,\r\npi->dpm_level_enable_mask.uvd_dpm_enable_mask);\r\nif (pi->last_mclk_dpm_enable_mask & 0x1) {\r\npi->uvd_enabled = true;\r\npi->dpm_level_enable_mask.mclk_dpm_enable_mask &= 0xFFFFFFFE;\r\namdgpu_ci_send_msg_to_smc_with_parameter(adev,\r\nPPSMC_MSG_MCLKDPM_SetEnabledMask,\r\npi->dpm_level_enable_mask.mclk_dpm_enable_mask);\r\n}\r\n} else {\r\nif (pi->uvd_enabled) {\r\npi->uvd_enabled = false;\r\npi->dpm_level_enable_mask.mclk_dpm_enable_mask |= 1;\r\namdgpu_ci_send_msg_to_smc_with_parameter(adev,\r\nPPSMC_MSG_MCLKDPM_SetEnabledMask,\r\npi->dpm_level_enable_mask.mclk_dpm_enable_mask);\r\n}\r\n}\r\nreturn (amdgpu_ci_send_msg_to_smc(adev, enable ?\r\nPPSMC_MSG_UVDDPM_Enable : PPSMC_MSG_UVDDPM_Disable) == PPSMC_Result_OK) ?\r\n0 : -EINVAL;\r\n}\r\nstatic int ci_enable_vce_dpm(struct amdgpu_device *adev, bool enable)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nconst struct amdgpu_clock_and_voltage_limits *max_limits;\r\nint i;\r\nif (adev->pm.dpm.ac_power)\r\nmax_limits = &adev->pm.dpm.dyn_state.max_clock_voltage_on_ac;\r\nelse\r\nmax_limits = &adev->pm.dpm.dyn_state.max_clock_voltage_on_dc;\r\nif (enable) {\r\npi->dpm_level_enable_mask.vce_dpm_enable_mask = 0;\r\nfor (i = adev->pm.dpm.dyn_state.vce_clock_voltage_dependency_table.count - 1; i >= 0; i--) {\r\nif (adev->pm.dpm.dyn_state.vce_clock_voltage_dependency_table.entries[i].v <= max_limits->vddc) {\r\npi->dpm_level_enable_mask.vce_dpm_enable_mask |= 1 << i;\r\nif (!pi->caps_vce_dpm)\r\nbreak;\r\n}\r\n}\r\namdgpu_ci_send_msg_to_smc_with_parameter(adev,\r\nPPSMC_MSG_VCEDPM_SetEnabledMask,\r\npi->dpm_level_enable_mask.vce_dpm_enable_mask);\r\n}\r\nreturn (amdgpu_ci_send_msg_to_smc(adev, enable ?\r\nPPSMC_MSG_VCEDPM_Enable : PPSMC_MSG_VCEDPM_Disable) == PPSMC_Result_OK) ?\r\n0 : -EINVAL;\r\n}\r\nstatic int ci_update_uvd_dpm(struct amdgpu_device *adev, bool gate)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nu32 tmp;\r\nint ret = 0;\r\nif (!gate) {\r\nif (pi->caps_uvd_dpm ||\r\n(adev->pm.dpm.dyn_state.uvd_clock_voltage_dependency_table.count <= 0))\r\npi->smc_state_table.UvdBootLevel = 0;\r\nelse\r\npi->smc_state_table.UvdBootLevel =\r\nadev->pm.dpm.dyn_state.uvd_clock_voltage_dependency_table.count - 1;\r\ntmp = RREG32_SMC(ixDPM_TABLE_475);\r\ntmp &= ~DPM_TABLE_475__UvdBootLevel_MASK;\r\ntmp |= (pi->smc_state_table.UvdBootLevel << DPM_TABLE_475__UvdBootLevel__SHIFT);\r\nWREG32_SMC(ixDPM_TABLE_475, tmp);\r\nret = ci_enable_uvd_dpm(adev, true);\r\n} else {\r\nret = ci_enable_uvd_dpm(adev, false);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic u8 ci_get_vce_boot_level(struct amdgpu_device *adev)\r\n{\r\nu8 i;\r\nu32 min_evclk = 30000;\r\nstruct amdgpu_vce_clock_voltage_dependency_table *table =\r\n&adev->pm.dpm.dyn_state.vce_clock_voltage_dependency_table;\r\nfor (i = 0; i < table->count; i++) {\r\nif (table->entries[i].evclk >= min_evclk)\r\nreturn i;\r\n}\r\nreturn table->count - 1;\r\n}\r\nstatic int ci_update_vce_dpm(struct amdgpu_device *adev,\r\nstruct amdgpu_ps *amdgpu_new_state,\r\nstruct amdgpu_ps *amdgpu_current_state)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nint ret = 0;\r\nu32 tmp;\r\nif (amdgpu_current_state->evclk != amdgpu_new_state->evclk) {\r\nif (amdgpu_new_state->evclk) {\r\npi->smc_state_table.VceBootLevel = ci_get_vce_boot_level(adev);\r\ntmp = RREG32_SMC(ixDPM_TABLE_475);\r\ntmp &= ~DPM_TABLE_475__VceBootLevel_MASK;\r\ntmp |= (pi->smc_state_table.VceBootLevel << DPM_TABLE_475__VceBootLevel__SHIFT);\r\nWREG32_SMC(ixDPM_TABLE_475, tmp);\r\nret = ci_enable_vce_dpm(adev, true);\r\n} else {\r\nret = ci_enable_vce_dpm(adev, false);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int ci_generate_dpm_level_enable_mask(struct amdgpu_device *adev,\r\nstruct amdgpu_ps *amdgpu_state)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nint ret;\r\nret = ci_trim_dpm_states(adev, amdgpu_state);\r\nif (ret)\r\nreturn ret;\r\npi->dpm_level_enable_mask.sclk_dpm_enable_mask =\r\nci_get_dpm_level_enable_mask_value(&pi->dpm_table.sclk_table);\r\npi->dpm_level_enable_mask.mclk_dpm_enable_mask =\r\nci_get_dpm_level_enable_mask_value(&pi->dpm_table.mclk_table);\r\npi->last_mclk_dpm_enable_mask =\r\npi->dpm_level_enable_mask.mclk_dpm_enable_mask;\r\nif (pi->uvd_enabled) {\r\nif (pi->dpm_level_enable_mask.mclk_dpm_enable_mask & 1)\r\npi->dpm_level_enable_mask.mclk_dpm_enable_mask &= 0xFFFFFFFE;\r\n}\r\npi->dpm_level_enable_mask.pcie_dpm_enable_mask =\r\nci_get_dpm_level_enable_mask_value(&pi->dpm_table.pcie_speed_table);\r\nreturn 0;\r\n}\r\nstatic u32 ci_get_lowest_enabled_level(struct amdgpu_device *adev,\r\nu32 level_mask)\r\n{\r\nu32 level = 0;\r\nwhile ((level_mask & (1 << level)) == 0)\r\nlevel++;\r\nreturn level;\r\n}\r\nstatic int ci_dpm_force_performance_level(struct amdgpu_device *adev,\r\nenum amd_dpm_forced_level level)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nu32 tmp, levels, i;\r\nint ret;\r\nif (level == AMD_DPM_FORCED_LEVEL_HIGH) {\r\nif ((!pi->pcie_dpm_key_disabled) &&\r\npi->dpm_level_enable_mask.pcie_dpm_enable_mask) {\r\nlevels = 0;\r\ntmp = pi->dpm_level_enable_mask.pcie_dpm_enable_mask;\r\nwhile (tmp >>= 1)\r\nlevels++;\r\nif (levels) {\r\nret = ci_dpm_force_state_pcie(adev, level);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < adev->usec_timeout; i++) {\r\ntmp = (RREG32_SMC(ixTARGET_AND_CURRENT_PROFILE_INDEX_1) &\r\nTARGET_AND_CURRENT_PROFILE_INDEX_1__CURR_PCIE_INDEX_MASK) >>\r\nTARGET_AND_CURRENT_PROFILE_INDEX_1__CURR_PCIE_INDEX__SHIFT;\r\nif (tmp == levels)\r\nbreak;\r\nudelay(1);\r\n}\r\n}\r\n}\r\nif ((!pi->sclk_dpm_key_disabled) &&\r\npi->dpm_level_enable_mask.sclk_dpm_enable_mask) {\r\nlevels = 0;\r\ntmp = pi->dpm_level_enable_mask.sclk_dpm_enable_mask;\r\nwhile (tmp >>= 1)\r\nlevels++;\r\nif (levels) {\r\nret = ci_dpm_force_state_sclk(adev, levels);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < adev->usec_timeout; i++) {\r\ntmp = (RREG32_SMC(ixTARGET_AND_CURRENT_PROFILE_INDEX) &\r\nTARGET_AND_CURRENT_PROFILE_INDEX__CURR_SCLK_INDEX_MASK) >>\r\nTARGET_AND_CURRENT_PROFILE_INDEX__CURR_SCLK_INDEX__SHIFT;\r\nif (tmp == levels)\r\nbreak;\r\nudelay(1);\r\n}\r\n}\r\n}\r\nif ((!pi->mclk_dpm_key_disabled) &&\r\npi->dpm_level_enable_mask.mclk_dpm_enable_mask) {\r\nlevels = 0;\r\ntmp = pi->dpm_level_enable_mask.mclk_dpm_enable_mask;\r\nwhile (tmp >>= 1)\r\nlevels++;\r\nif (levels) {\r\nret = ci_dpm_force_state_mclk(adev, levels);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < adev->usec_timeout; i++) {\r\ntmp = (RREG32_SMC(ixTARGET_AND_CURRENT_PROFILE_INDEX) &\r\nTARGET_AND_CURRENT_PROFILE_INDEX__CURR_MCLK_INDEX_MASK) >>\r\nTARGET_AND_CURRENT_PROFILE_INDEX__CURR_MCLK_INDEX__SHIFT;\r\nif (tmp == levels)\r\nbreak;\r\nudelay(1);\r\n}\r\n}\r\n}\r\n} else if (level == AMD_DPM_FORCED_LEVEL_LOW) {\r\nif ((!pi->sclk_dpm_key_disabled) &&\r\npi->dpm_level_enable_mask.sclk_dpm_enable_mask) {\r\nlevels = ci_get_lowest_enabled_level(adev,\r\npi->dpm_level_enable_mask.sclk_dpm_enable_mask);\r\nret = ci_dpm_force_state_sclk(adev, levels);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < adev->usec_timeout; i++) {\r\ntmp = (RREG32_SMC(ixTARGET_AND_CURRENT_PROFILE_INDEX) &\r\nTARGET_AND_CURRENT_PROFILE_INDEX__CURR_SCLK_INDEX_MASK) >>\r\nTARGET_AND_CURRENT_PROFILE_INDEX__CURR_SCLK_INDEX__SHIFT;\r\nif (tmp == levels)\r\nbreak;\r\nudelay(1);\r\n}\r\n}\r\nif ((!pi->mclk_dpm_key_disabled) &&\r\npi->dpm_level_enable_mask.mclk_dpm_enable_mask) {\r\nlevels = ci_get_lowest_enabled_level(adev,\r\npi->dpm_level_enable_mask.mclk_dpm_enable_mask);\r\nret = ci_dpm_force_state_mclk(adev, levels);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < adev->usec_timeout; i++) {\r\ntmp = (RREG32_SMC(ixTARGET_AND_CURRENT_PROFILE_INDEX) &\r\nTARGET_AND_CURRENT_PROFILE_INDEX__CURR_MCLK_INDEX_MASK) >>\r\nTARGET_AND_CURRENT_PROFILE_INDEX__CURR_MCLK_INDEX__SHIFT;\r\nif (tmp == levels)\r\nbreak;\r\nudelay(1);\r\n}\r\n}\r\nif ((!pi->pcie_dpm_key_disabled) &&\r\npi->dpm_level_enable_mask.pcie_dpm_enable_mask) {\r\nlevels = ci_get_lowest_enabled_level(adev,\r\npi->dpm_level_enable_mask.pcie_dpm_enable_mask);\r\nret = ci_dpm_force_state_pcie(adev, levels);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < adev->usec_timeout; i++) {\r\ntmp = (RREG32_SMC(ixTARGET_AND_CURRENT_PROFILE_INDEX_1) &\r\nTARGET_AND_CURRENT_PROFILE_INDEX_1__CURR_PCIE_INDEX_MASK) >>\r\nTARGET_AND_CURRENT_PROFILE_INDEX_1__CURR_PCIE_INDEX__SHIFT;\r\nif (tmp == levels)\r\nbreak;\r\nudelay(1);\r\n}\r\n}\r\n} else if (level == AMD_DPM_FORCED_LEVEL_AUTO) {\r\nif (!pi->pcie_dpm_key_disabled) {\r\nPPSMC_Result smc_result;\r\nsmc_result = amdgpu_ci_send_msg_to_smc(adev,\r\nPPSMC_MSG_PCIeDPM_UnForceLevel);\r\nif (smc_result != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\n}\r\nret = ci_upload_dpm_level_enable_mask(adev);\r\nif (ret)\r\nreturn ret;\r\n}\r\nadev->pm.dpm.forced_level = level;\r\nreturn 0;\r\n}\r\nstatic int ci_set_mc_special_registers(struct amdgpu_device *adev,\r\nstruct ci_mc_reg_table *table)\r\n{\r\nu8 i, j, k;\r\nu32 temp_reg;\r\nfor (i = 0, j = table->last; i < table->last; i++) {\r\nif (j >= SMU7_DISCRETE_MC_REGISTER_ARRAY_SIZE)\r\nreturn -EINVAL;\r\nswitch(table->mc_reg_address[i].s1) {\r\ncase mmMC_SEQ_MISC1:\r\ntemp_reg = RREG32(mmMC_PMG_CMD_EMRS);\r\ntable->mc_reg_address[j].s1 = mmMC_PMG_CMD_EMRS;\r\ntable->mc_reg_address[j].s0 = mmMC_SEQ_PMG_CMD_EMRS_LP;\r\nfor (k = 0; k < table->num_entries; k++) {\r\ntable->mc_reg_table_entry[k].mc_data[j] =\r\n((temp_reg & 0xffff0000)) | ((table->mc_reg_table_entry[k].mc_data[i] & 0xffff0000) >> 16);\r\n}\r\nj++;\r\nif (j >= SMU7_DISCRETE_MC_REGISTER_ARRAY_SIZE)\r\nreturn -EINVAL;\r\ntemp_reg = RREG32(mmMC_PMG_CMD_MRS);\r\ntable->mc_reg_address[j].s1 = mmMC_PMG_CMD_MRS;\r\ntable->mc_reg_address[j].s0 = mmMC_SEQ_PMG_CMD_MRS_LP;\r\nfor (k = 0; k < table->num_entries; k++) {\r\ntable->mc_reg_table_entry[k].mc_data[j] =\r\n(temp_reg & 0xffff0000) | (table->mc_reg_table_entry[k].mc_data[i] & 0x0000ffff);\r\nif (adev->mc.vram_type != AMDGPU_VRAM_TYPE_GDDR5)\r\ntable->mc_reg_table_entry[k].mc_data[j] |= 0x100;\r\n}\r\nj++;\r\nif (j > SMU7_DISCRETE_MC_REGISTER_ARRAY_SIZE)\r\nreturn -EINVAL;\r\nif (adev->mc.vram_type != AMDGPU_VRAM_TYPE_GDDR5) {\r\ntable->mc_reg_address[j].s1 = mmMC_PMG_AUTO_CMD;\r\ntable->mc_reg_address[j].s0 = mmMC_PMG_AUTO_CMD;\r\nfor (k = 0; k < table->num_entries; k++) {\r\ntable->mc_reg_table_entry[k].mc_data[j] =\r\n(table->mc_reg_table_entry[k].mc_data[i] & 0xffff0000) >> 16;\r\n}\r\nj++;\r\nif (j > SMU7_DISCRETE_MC_REGISTER_ARRAY_SIZE)\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase mmMC_SEQ_RESERVE_M:\r\ntemp_reg = RREG32(mmMC_PMG_CMD_MRS1);\r\ntable->mc_reg_address[j].s1 = mmMC_PMG_CMD_MRS1;\r\ntable->mc_reg_address[j].s0 = mmMC_SEQ_PMG_CMD_MRS1_LP;\r\nfor (k = 0; k < table->num_entries; k++) {\r\ntable->mc_reg_table_entry[k].mc_data[j] =\r\n(temp_reg & 0xffff0000) | (table->mc_reg_table_entry[k].mc_data[i] & 0x0000ffff);\r\n}\r\nj++;\r\nif (j > SMU7_DISCRETE_MC_REGISTER_ARRAY_SIZE)\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\ntable->last = j;\r\nreturn 0;\r\n}\r\nstatic bool ci_check_s0_mc_reg_index(u16 in_reg, u16 *out_reg)\r\n{\r\nbool result = true;\r\nswitch(in_reg) {\r\ncase mmMC_SEQ_RAS_TIMING:\r\n*out_reg = mmMC_SEQ_RAS_TIMING_LP;\r\nbreak;\r\ncase mmMC_SEQ_DLL_STBY:\r\n*out_reg = mmMC_SEQ_DLL_STBY_LP;\r\nbreak;\r\ncase mmMC_SEQ_G5PDX_CMD0:\r\n*out_reg = mmMC_SEQ_G5PDX_CMD0_LP;\r\nbreak;\r\ncase mmMC_SEQ_G5PDX_CMD1:\r\n*out_reg = mmMC_SEQ_G5PDX_CMD1_LP;\r\nbreak;\r\ncase mmMC_SEQ_G5PDX_CTRL:\r\n*out_reg = mmMC_SEQ_G5PDX_CTRL_LP;\r\nbreak;\r\ncase mmMC_SEQ_CAS_TIMING:\r\n*out_reg = mmMC_SEQ_CAS_TIMING_LP;\r\nbreak;\r\ncase mmMC_SEQ_MISC_TIMING:\r\n*out_reg = mmMC_SEQ_MISC_TIMING_LP;\r\nbreak;\r\ncase mmMC_SEQ_MISC_TIMING2:\r\n*out_reg = mmMC_SEQ_MISC_TIMING2_LP;\r\nbreak;\r\ncase mmMC_SEQ_PMG_DVS_CMD:\r\n*out_reg = mmMC_SEQ_PMG_DVS_CMD_LP;\r\nbreak;\r\ncase mmMC_SEQ_PMG_DVS_CTL:\r\n*out_reg = mmMC_SEQ_PMG_DVS_CTL_LP;\r\nbreak;\r\ncase mmMC_SEQ_RD_CTL_D0:\r\n*out_reg = mmMC_SEQ_RD_CTL_D0_LP;\r\nbreak;\r\ncase mmMC_SEQ_RD_CTL_D1:\r\n*out_reg = mmMC_SEQ_RD_CTL_D1_LP;\r\nbreak;\r\ncase mmMC_SEQ_WR_CTL_D0:\r\n*out_reg = mmMC_SEQ_WR_CTL_D0_LP;\r\nbreak;\r\ncase mmMC_SEQ_WR_CTL_D1:\r\n*out_reg = mmMC_SEQ_WR_CTL_D1_LP;\r\nbreak;\r\ncase mmMC_PMG_CMD_EMRS:\r\n*out_reg = mmMC_SEQ_PMG_CMD_EMRS_LP;\r\nbreak;\r\ncase mmMC_PMG_CMD_MRS:\r\n*out_reg = mmMC_SEQ_PMG_CMD_MRS_LP;\r\nbreak;\r\ncase mmMC_PMG_CMD_MRS1:\r\n*out_reg = mmMC_SEQ_PMG_CMD_MRS1_LP;\r\nbreak;\r\ncase mmMC_SEQ_PMG_TIMING:\r\n*out_reg = mmMC_SEQ_PMG_TIMING_LP;\r\nbreak;\r\ncase mmMC_PMG_CMD_MRS2:\r\n*out_reg = mmMC_SEQ_PMG_CMD_MRS2_LP;\r\nbreak;\r\ncase mmMC_SEQ_WR_CTL_2:\r\n*out_reg = mmMC_SEQ_WR_CTL_2_LP;\r\nbreak;\r\ndefault:\r\nresult = false;\r\nbreak;\r\n}\r\nreturn result;\r\n}\r\nstatic void ci_set_valid_flag(struct ci_mc_reg_table *table)\r\n{\r\nu8 i, j;\r\nfor (i = 0; i < table->last; i++) {\r\nfor (j = 1; j < table->num_entries; j++) {\r\nif (table->mc_reg_table_entry[j-1].mc_data[i] !=\r\ntable->mc_reg_table_entry[j].mc_data[i]) {\r\ntable->valid_flag |= 1 << i;\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nstatic void ci_set_s0_mc_reg_index(struct ci_mc_reg_table *table)\r\n{\r\nu32 i;\r\nu16 address;\r\nfor (i = 0; i < table->last; i++) {\r\ntable->mc_reg_address[i].s0 =\r\nci_check_s0_mc_reg_index(table->mc_reg_address[i].s1, &address) ?\r\naddress : table->mc_reg_address[i].s1;\r\n}\r\n}\r\nstatic int ci_copy_vbios_mc_reg_table(const struct atom_mc_reg_table *table,\r\nstruct ci_mc_reg_table *ci_table)\r\n{\r\nu8 i, j;\r\nif (table->last > SMU7_DISCRETE_MC_REGISTER_ARRAY_SIZE)\r\nreturn -EINVAL;\r\nif (table->num_entries > MAX_AC_TIMING_ENTRIES)\r\nreturn -EINVAL;\r\nfor (i = 0; i < table->last; i++)\r\nci_table->mc_reg_address[i].s1 = table->mc_reg_address[i].s1;\r\nci_table->last = table->last;\r\nfor (i = 0; i < table->num_entries; i++) {\r\nci_table->mc_reg_table_entry[i].mclk_max =\r\ntable->mc_reg_table_entry[i].mclk_max;\r\nfor (j = 0; j < table->last; j++)\r\nci_table->mc_reg_table_entry[i].mc_data[j] =\r\ntable->mc_reg_table_entry[i].mc_data[j];\r\n}\r\nci_table->num_entries = table->num_entries;\r\nreturn 0;\r\n}\r\nstatic int ci_register_patching_mc_seq(struct amdgpu_device *adev,\r\nstruct ci_mc_reg_table *table)\r\n{\r\nu8 i, k;\r\nu32 tmp;\r\nbool patch;\r\ntmp = RREG32(mmMC_SEQ_MISC0);\r\npatch = ((tmp & 0x0000f00) == 0x300) ? true : false;\r\nif (patch &&\r\n((adev->pdev->device == 0x67B0) ||\r\n(adev->pdev->device == 0x67B1))) {\r\nfor (i = 0; i < table->last; i++) {\r\nif (table->last >= SMU7_DISCRETE_MC_REGISTER_ARRAY_SIZE)\r\nreturn -EINVAL;\r\nswitch (table->mc_reg_address[i].s1) {\r\ncase mmMC_SEQ_MISC1:\r\nfor (k = 0; k < table->num_entries; k++) {\r\nif ((table->mc_reg_table_entry[k].mclk_max == 125000) ||\r\n(table->mc_reg_table_entry[k].mclk_max == 137500))\r\ntable->mc_reg_table_entry[k].mc_data[i] =\r\n(table->mc_reg_table_entry[k].mc_data[i] & 0xFFFFFFF8) |\r\n0x00000007;\r\n}\r\nbreak;\r\ncase mmMC_SEQ_WR_CTL_D0:\r\nfor (k = 0; k < table->num_entries; k++) {\r\nif ((table->mc_reg_table_entry[k].mclk_max == 125000) ||\r\n(table->mc_reg_table_entry[k].mclk_max == 137500))\r\ntable->mc_reg_table_entry[k].mc_data[i] =\r\n(table->mc_reg_table_entry[k].mc_data[i] & 0xFFFF0F00) |\r\n0x0000D0DD;\r\n}\r\nbreak;\r\ncase mmMC_SEQ_WR_CTL_D1:\r\nfor (k = 0; k < table->num_entries; k++) {\r\nif ((table->mc_reg_table_entry[k].mclk_max == 125000) ||\r\n(table->mc_reg_table_entry[k].mclk_max == 137500))\r\ntable->mc_reg_table_entry[k].mc_data[i] =\r\n(table->mc_reg_table_entry[k].mc_data[i] & 0xFFFF0F00) |\r\n0x0000D0DD;\r\n}\r\nbreak;\r\ncase mmMC_SEQ_WR_CTL_2:\r\nfor (k = 0; k < table->num_entries; k++) {\r\nif ((table->mc_reg_table_entry[k].mclk_max == 125000) ||\r\n(table->mc_reg_table_entry[k].mclk_max == 137500))\r\ntable->mc_reg_table_entry[k].mc_data[i] = 0;\r\n}\r\nbreak;\r\ncase mmMC_SEQ_CAS_TIMING:\r\nfor (k = 0; k < table->num_entries; k++) {\r\nif (table->mc_reg_table_entry[k].mclk_max == 125000)\r\ntable->mc_reg_table_entry[k].mc_data[i] =\r\n(table->mc_reg_table_entry[k].mc_data[i] & 0xFFE0FE0F) |\r\n0x000C0140;\r\nelse if (table->mc_reg_table_entry[k].mclk_max == 137500)\r\ntable->mc_reg_table_entry[k].mc_data[i] =\r\n(table->mc_reg_table_entry[k].mc_data[i] & 0xFFE0FE0F) |\r\n0x000C0150;\r\n}\r\nbreak;\r\ncase mmMC_SEQ_MISC_TIMING:\r\nfor (k = 0; k < table->num_entries; k++) {\r\nif (table->mc_reg_table_entry[k].mclk_max == 125000)\r\ntable->mc_reg_table_entry[k].mc_data[i] =\r\n(table->mc_reg_table_entry[k].mc_data[i] & 0xFFFFFFE0) |\r\n0x00000030;\r\nelse if (table->mc_reg_table_entry[k].mclk_max == 137500)\r\ntable->mc_reg_table_entry[k].mc_data[i] =\r\n(table->mc_reg_table_entry[k].mc_data[i] & 0xFFFFFFE0) |\r\n0x00000035;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nWREG32(mmMC_SEQ_IO_DEBUG_INDEX, 3);\r\ntmp = RREG32(mmMC_SEQ_IO_DEBUG_DATA);\r\ntmp = (tmp & 0xFFF8FFFF) | (1 << 16);\r\nWREG32(mmMC_SEQ_IO_DEBUG_INDEX, 3);\r\nWREG32(mmMC_SEQ_IO_DEBUG_DATA, tmp);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ci_initialize_mc_reg_table(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nstruct atom_mc_reg_table *table;\r\nstruct ci_mc_reg_table *ci_table = &pi->mc_reg_table;\r\nu8 module_index = ci_get_memory_module_index(adev);\r\nint ret;\r\ntable = kzalloc(sizeof(struct atom_mc_reg_table), GFP_KERNEL);\r\nif (!table)\r\nreturn -ENOMEM;\r\nWREG32(mmMC_SEQ_RAS_TIMING_LP, RREG32(mmMC_SEQ_RAS_TIMING));\r\nWREG32(mmMC_SEQ_CAS_TIMING_LP, RREG32(mmMC_SEQ_CAS_TIMING));\r\nWREG32(mmMC_SEQ_DLL_STBY_LP, RREG32(mmMC_SEQ_DLL_STBY));\r\nWREG32(mmMC_SEQ_G5PDX_CMD0_LP, RREG32(mmMC_SEQ_G5PDX_CMD0));\r\nWREG32(mmMC_SEQ_G5PDX_CMD1_LP, RREG32(mmMC_SEQ_G5PDX_CMD1));\r\nWREG32(mmMC_SEQ_G5PDX_CTRL_LP, RREG32(mmMC_SEQ_G5PDX_CTRL));\r\nWREG32(mmMC_SEQ_PMG_DVS_CMD_LP, RREG32(mmMC_SEQ_PMG_DVS_CMD));\r\nWREG32(mmMC_SEQ_PMG_DVS_CTL_LP, RREG32(mmMC_SEQ_PMG_DVS_CTL));\r\nWREG32(mmMC_SEQ_MISC_TIMING_LP, RREG32(mmMC_SEQ_MISC_TIMING));\r\nWREG32(mmMC_SEQ_MISC_TIMING2_LP, RREG32(mmMC_SEQ_MISC_TIMING2));\r\nWREG32(mmMC_SEQ_PMG_CMD_EMRS_LP, RREG32(mmMC_PMG_CMD_EMRS));\r\nWREG32(mmMC_SEQ_PMG_CMD_MRS_LP, RREG32(mmMC_PMG_CMD_MRS));\r\nWREG32(mmMC_SEQ_PMG_CMD_MRS1_LP, RREG32(mmMC_PMG_CMD_MRS1));\r\nWREG32(mmMC_SEQ_WR_CTL_D0_LP, RREG32(mmMC_SEQ_WR_CTL_D0));\r\nWREG32(mmMC_SEQ_WR_CTL_D1_LP, RREG32(mmMC_SEQ_WR_CTL_D1));\r\nWREG32(mmMC_SEQ_RD_CTL_D0_LP, RREG32(mmMC_SEQ_RD_CTL_D0));\r\nWREG32(mmMC_SEQ_RD_CTL_D1_LP, RREG32(mmMC_SEQ_RD_CTL_D1));\r\nWREG32(mmMC_SEQ_PMG_TIMING_LP, RREG32(mmMC_SEQ_PMG_TIMING));\r\nWREG32(mmMC_SEQ_PMG_CMD_MRS2_LP, RREG32(mmMC_PMG_CMD_MRS2));\r\nWREG32(mmMC_SEQ_WR_CTL_2_LP, RREG32(mmMC_SEQ_WR_CTL_2));\r\nret = amdgpu_atombios_init_mc_reg_table(adev, module_index, table);\r\nif (ret)\r\ngoto init_mc_done;\r\nret = ci_copy_vbios_mc_reg_table(table, ci_table);\r\nif (ret)\r\ngoto init_mc_done;\r\nci_set_s0_mc_reg_index(ci_table);\r\nret = ci_register_patching_mc_seq(adev, ci_table);\r\nif (ret)\r\ngoto init_mc_done;\r\nret = ci_set_mc_special_registers(adev, ci_table);\r\nif (ret)\r\ngoto init_mc_done;\r\nci_set_valid_flag(ci_table);\r\ninit_mc_done:\r\nkfree(table);\r\nreturn ret;\r\n}\r\nstatic int ci_populate_mc_reg_addresses(struct amdgpu_device *adev,\r\nSMU7_Discrete_MCRegisters *mc_reg_table)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nu32 i, j;\r\nfor (i = 0, j = 0; j < pi->mc_reg_table.last; j++) {\r\nif (pi->mc_reg_table.valid_flag & (1 << j)) {\r\nif (i >= SMU7_DISCRETE_MC_REGISTER_ARRAY_SIZE)\r\nreturn -EINVAL;\r\nmc_reg_table->address[i].s0 = cpu_to_be16(pi->mc_reg_table.mc_reg_address[j].s0);\r\nmc_reg_table->address[i].s1 = cpu_to_be16(pi->mc_reg_table.mc_reg_address[j].s1);\r\ni++;\r\n}\r\n}\r\nmc_reg_table->last = (u8)i;\r\nreturn 0;\r\n}\r\nstatic void ci_convert_mc_registers(const struct ci_mc_reg_entry *entry,\r\nSMU7_Discrete_MCRegisterSet *data,\r\nu32 num_entries, u32 valid_flag)\r\n{\r\nu32 i, j;\r\nfor (i = 0, j = 0; j < num_entries; j++) {\r\nif (valid_flag & (1 << j)) {\r\ndata->value[i] = cpu_to_be32(entry->mc_data[j]);\r\ni++;\r\n}\r\n}\r\n}\r\nstatic void ci_convert_mc_reg_table_entry_to_smc(struct amdgpu_device *adev,\r\nconst u32 memory_clock,\r\nSMU7_Discrete_MCRegisterSet *mc_reg_table_data)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nu32 i = 0;\r\nfor(i = 0; i < pi->mc_reg_table.num_entries; i++) {\r\nif (memory_clock <= pi->mc_reg_table.mc_reg_table_entry[i].mclk_max)\r\nbreak;\r\n}\r\nif ((i == pi->mc_reg_table.num_entries) && (i > 0))\r\n--i;\r\nci_convert_mc_registers(&pi->mc_reg_table.mc_reg_table_entry[i],\r\nmc_reg_table_data, pi->mc_reg_table.last,\r\npi->mc_reg_table.valid_flag);\r\n}\r\nstatic void ci_convert_mc_reg_table_to_smc(struct amdgpu_device *adev,\r\nSMU7_Discrete_MCRegisters *mc_reg_table)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nu32 i;\r\nfor (i = 0; i < pi->dpm_table.mclk_table.count; i++)\r\nci_convert_mc_reg_table_entry_to_smc(adev,\r\npi->dpm_table.mclk_table.dpm_levels[i].value,\r\n&mc_reg_table->data[i]);\r\n}\r\nstatic int ci_populate_initial_mc_reg_table(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nint ret;\r\nmemset(&pi->smc_mc_reg_table, 0, sizeof(SMU7_Discrete_MCRegisters));\r\nret = ci_populate_mc_reg_addresses(adev, &pi->smc_mc_reg_table);\r\nif (ret)\r\nreturn ret;\r\nci_convert_mc_reg_table_to_smc(adev, &pi->smc_mc_reg_table);\r\nreturn amdgpu_ci_copy_bytes_to_smc(adev,\r\npi->mc_reg_table_start,\r\n(u8 *)&pi->smc_mc_reg_table,\r\nsizeof(SMU7_Discrete_MCRegisters),\r\npi->sram_end);\r\n}\r\nstatic int ci_update_and_upload_mc_reg_table(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nif (!(pi->need_update_smu7_dpm_table & DPMTABLE_OD_UPDATE_MCLK))\r\nreturn 0;\r\nmemset(&pi->smc_mc_reg_table, 0, sizeof(SMU7_Discrete_MCRegisters));\r\nci_convert_mc_reg_table_to_smc(adev, &pi->smc_mc_reg_table);\r\nreturn amdgpu_ci_copy_bytes_to_smc(adev,\r\npi->mc_reg_table_start +\r\noffsetof(SMU7_Discrete_MCRegisters, data[0]),\r\n(u8 *)&pi->smc_mc_reg_table.data[0],\r\nsizeof(SMU7_Discrete_MCRegisterSet) *\r\npi->dpm_table.mclk_table.count,\r\npi->sram_end);\r\n}\r\nstatic void ci_enable_voltage_control(struct amdgpu_device *adev)\r\n{\r\nu32 tmp = RREG32_SMC(ixGENERAL_PWRMGT);\r\ntmp |= GENERAL_PWRMGT__VOLT_PWRMGT_EN_MASK;\r\nWREG32_SMC(ixGENERAL_PWRMGT, tmp);\r\n}\r\nstatic enum amdgpu_pcie_gen ci_get_maximum_link_speed(struct amdgpu_device *adev,\r\nstruct amdgpu_ps *amdgpu_state)\r\n{\r\nstruct ci_ps *state = ci_get_ps(amdgpu_state);\r\nint i;\r\nu16 pcie_speed, max_speed = 0;\r\nfor (i = 0; i < state->performance_level_count; i++) {\r\npcie_speed = state->performance_levels[i].pcie_gen;\r\nif (max_speed < pcie_speed)\r\nmax_speed = pcie_speed;\r\n}\r\nreturn max_speed;\r\n}\r\nstatic u16 ci_get_current_pcie_speed(struct amdgpu_device *adev)\r\n{\r\nu32 speed_cntl = 0;\r\nspeed_cntl = RREG32_PCIE(ixPCIE_LC_SPEED_CNTL) &\r\nPCIE_LC_SPEED_CNTL__LC_CURRENT_DATA_RATE_MASK;\r\nspeed_cntl >>= PCIE_LC_SPEED_CNTL__LC_CURRENT_DATA_RATE__SHIFT;\r\nreturn (u16)speed_cntl;\r\n}\r\nstatic int ci_get_current_pcie_lane_number(struct amdgpu_device *adev)\r\n{\r\nu32 link_width = 0;\r\nlink_width = RREG32_PCIE(ixPCIE_LC_LINK_WIDTH_CNTL) &\r\nPCIE_LC_LINK_WIDTH_CNTL__LC_LINK_WIDTH_RD_MASK;\r\nlink_width >>= PCIE_LC_LINK_WIDTH_CNTL__LC_LINK_WIDTH_RD__SHIFT;\r\nswitch (link_width) {\r\ncase 1:\r\nreturn 1;\r\ncase 2:\r\nreturn 2;\r\ncase 3:\r\nreturn 4;\r\ncase 4:\r\nreturn 8;\r\ncase 0:\r\ncase 6:\r\ndefault:\r\nreturn 16;\r\n}\r\n}\r\nstatic void ci_request_link_speed_change_before_state_change(struct amdgpu_device *adev,\r\nstruct amdgpu_ps *amdgpu_new_state,\r\nstruct amdgpu_ps *amdgpu_current_state)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nenum amdgpu_pcie_gen target_link_speed =\r\nci_get_maximum_link_speed(adev, amdgpu_new_state);\r\nenum amdgpu_pcie_gen current_link_speed;\r\nif (pi->force_pcie_gen == AMDGPU_PCIE_GEN_INVALID)\r\ncurrent_link_speed = ci_get_maximum_link_speed(adev, amdgpu_current_state);\r\nelse\r\ncurrent_link_speed = pi->force_pcie_gen;\r\npi->force_pcie_gen = AMDGPU_PCIE_GEN_INVALID;\r\npi->pspp_notify_required = false;\r\nif (target_link_speed > current_link_speed) {\r\nswitch (target_link_speed) {\r\n#ifdef CONFIG_ACPI\r\ncase AMDGPU_PCIE_GEN3:\r\nif (amdgpu_acpi_pcie_performance_request(adev, PCIE_PERF_REQ_PECI_GEN3, false) == 0)\r\nbreak;\r\npi->force_pcie_gen = AMDGPU_PCIE_GEN2;\r\nif (current_link_speed == AMDGPU_PCIE_GEN2)\r\nbreak;\r\ncase AMDGPU_PCIE_GEN2:\r\nif (amdgpu_acpi_pcie_performance_request(adev, PCIE_PERF_REQ_PECI_GEN2, false) == 0)\r\nbreak;\r\n#endif\r\ndefault:\r\npi->force_pcie_gen = ci_get_current_pcie_speed(adev);\r\nbreak;\r\n}\r\n} else {\r\nif (target_link_speed < current_link_speed)\r\npi->pspp_notify_required = true;\r\n}\r\n}\r\nstatic void ci_notify_link_speed_change_after_state_change(struct amdgpu_device *adev,\r\nstruct amdgpu_ps *amdgpu_new_state,\r\nstruct amdgpu_ps *amdgpu_current_state)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nenum amdgpu_pcie_gen target_link_speed =\r\nci_get_maximum_link_speed(adev, amdgpu_new_state);\r\nu8 request;\r\nif (pi->pspp_notify_required) {\r\nif (target_link_speed == AMDGPU_PCIE_GEN3)\r\nrequest = PCIE_PERF_REQ_PECI_GEN3;\r\nelse if (target_link_speed == AMDGPU_PCIE_GEN2)\r\nrequest = PCIE_PERF_REQ_PECI_GEN2;\r\nelse\r\nrequest = PCIE_PERF_REQ_PECI_GEN1;\r\nif ((request == PCIE_PERF_REQ_PECI_GEN1) &&\r\n(ci_get_current_pcie_speed(adev) > 0))\r\nreturn;\r\n#ifdef CONFIG_ACPI\r\namdgpu_acpi_pcie_performance_request(adev, request, false);\r\n#endif\r\n}\r\n}\r\nstatic int ci_set_private_data_variables_based_on_pptable(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nstruct amdgpu_clock_voltage_dependency_table *allowed_sclk_vddc_table =\r\n&adev->pm.dpm.dyn_state.vddc_dependency_on_sclk;\r\nstruct amdgpu_clock_voltage_dependency_table *allowed_mclk_vddc_table =\r\n&adev->pm.dpm.dyn_state.vddc_dependency_on_mclk;\r\nstruct amdgpu_clock_voltage_dependency_table *allowed_mclk_vddci_table =\r\n&adev->pm.dpm.dyn_state.vddci_dependency_on_mclk;\r\nif (allowed_sclk_vddc_table == NULL)\r\nreturn -EINVAL;\r\nif (allowed_sclk_vddc_table->count < 1)\r\nreturn -EINVAL;\r\nif (allowed_mclk_vddc_table == NULL)\r\nreturn -EINVAL;\r\nif (allowed_mclk_vddc_table->count < 1)\r\nreturn -EINVAL;\r\nif (allowed_mclk_vddci_table == NULL)\r\nreturn -EINVAL;\r\nif (allowed_mclk_vddci_table->count < 1)\r\nreturn -EINVAL;\r\npi->min_vddc_in_pp_table = allowed_sclk_vddc_table->entries[0].v;\r\npi->max_vddc_in_pp_table =\r\nallowed_sclk_vddc_table->entries[allowed_sclk_vddc_table->count - 1].v;\r\npi->min_vddci_in_pp_table = allowed_mclk_vddci_table->entries[0].v;\r\npi->max_vddci_in_pp_table =\r\nallowed_mclk_vddci_table->entries[allowed_mclk_vddci_table->count - 1].v;\r\nadev->pm.dpm.dyn_state.max_clock_voltage_on_ac.sclk =\r\nallowed_sclk_vddc_table->entries[allowed_sclk_vddc_table->count - 1].clk;\r\nadev->pm.dpm.dyn_state.max_clock_voltage_on_ac.mclk =\r\nallowed_mclk_vddc_table->entries[allowed_sclk_vddc_table->count - 1].clk;\r\nadev->pm.dpm.dyn_state.max_clock_voltage_on_ac.vddc =\r\nallowed_sclk_vddc_table->entries[allowed_sclk_vddc_table->count - 1].v;\r\nadev->pm.dpm.dyn_state.max_clock_voltage_on_ac.vddci =\r\nallowed_mclk_vddci_table->entries[allowed_mclk_vddci_table->count - 1].v;\r\nreturn 0;\r\n}\r\nstatic void ci_patch_with_vddc_leakage(struct amdgpu_device *adev, u16 *vddc)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nstruct ci_leakage_voltage *leakage_table = &pi->vddc_leakage;\r\nu32 leakage_index;\r\nfor (leakage_index = 0; leakage_index < leakage_table->count; leakage_index++) {\r\nif (leakage_table->leakage_id[leakage_index] == *vddc) {\r\n*vddc = leakage_table->actual_voltage[leakage_index];\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void ci_patch_with_vddci_leakage(struct amdgpu_device *adev, u16 *vddci)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nstruct ci_leakage_voltage *leakage_table = &pi->vddci_leakage;\r\nu32 leakage_index;\r\nfor (leakage_index = 0; leakage_index < leakage_table->count; leakage_index++) {\r\nif (leakage_table->leakage_id[leakage_index] == *vddci) {\r\n*vddci = leakage_table->actual_voltage[leakage_index];\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void ci_patch_clock_voltage_dependency_table_with_vddc_leakage(struct amdgpu_device *adev,\r\nstruct amdgpu_clock_voltage_dependency_table *table)\r\n{\r\nu32 i;\r\nif (table) {\r\nfor (i = 0; i < table->count; i++)\r\nci_patch_with_vddc_leakage(adev, &table->entries[i].v);\r\n}\r\n}\r\nstatic void ci_patch_clock_voltage_dependency_table_with_vddci_leakage(struct amdgpu_device *adev,\r\nstruct amdgpu_clock_voltage_dependency_table *table)\r\n{\r\nu32 i;\r\nif (table) {\r\nfor (i = 0; i < table->count; i++)\r\nci_patch_with_vddci_leakage(adev, &table->entries[i].v);\r\n}\r\n}\r\nstatic void ci_patch_vce_clock_voltage_dependency_table_with_vddc_leakage(struct amdgpu_device *adev,\r\nstruct amdgpu_vce_clock_voltage_dependency_table *table)\r\n{\r\nu32 i;\r\nif (table) {\r\nfor (i = 0; i < table->count; i++)\r\nci_patch_with_vddc_leakage(adev, &table->entries[i].v);\r\n}\r\n}\r\nstatic void ci_patch_uvd_clock_voltage_dependency_table_with_vddc_leakage(struct amdgpu_device *adev,\r\nstruct amdgpu_uvd_clock_voltage_dependency_table *table)\r\n{\r\nu32 i;\r\nif (table) {\r\nfor (i = 0; i < table->count; i++)\r\nci_patch_with_vddc_leakage(adev, &table->entries[i].v);\r\n}\r\n}\r\nstatic void ci_patch_vddc_phase_shed_limit_table_with_vddc_leakage(struct amdgpu_device *adev,\r\nstruct amdgpu_phase_shedding_limits_table *table)\r\n{\r\nu32 i;\r\nif (table) {\r\nfor (i = 0; i < table->count; i++)\r\nci_patch_with_vddc_leakage(adev, &table->entries[i].voltage);\r\n}\r\n}\r\nstatic void ci_patch_clock_voltage_limits_with_vddc_leakage(struct amdgpu_device *adev,\r\nstruct amdgpu_clock_and_voltage_limits *table)\r\n{\r\nif (table) {\r\nci_patch_with_vddc_leakage(adev, (u16 *)&table->vddc);\r\nci_patch_with_vddci_leakage(adev, (u16 *)&table->vddci);\r\n}\r\n}\r\nstatic void ci_patch_cac_leakage_table_with_vddc_leakage(struct amdgpu_device *adev,\r\nstruct amdgpu_cac_leakage_table *table)\r\n{\r\nu32 i;\r\nif (table) {\r\nfor (i = 0; i < table->count; i++)\r\nci_patch_with_vddc_leakage(adev, &table->entries[i].vddc);\r\n}\r\n}\r\nstatic void ci_patch_dependency_tables_with_leakage(struct amdgpu_device *adev)\r\n{\r\nci_patch_clock_voltage_dependency_table_with_vddc_leakage(adev,\r\n&adev->pm.dpm.dyn_state.vddc_dependency_on_sclk);\r\nci_patch_clock_voltage_dependency_table_with_vddc_leakage(adev,\r\n&adev->pm.dpm.dyn_state.vddc_dependency_on_mclk);\r\nci_patch_clock_voltage_dependency_table_with_vddc_leakage(adev,\r\n&adev->pm.dpm.dyn_state.vddc_dependency_on_dispclk);\r\nci_patch_clock_voltage_dependency_table_with_vddci_leakage(adev,\r\n&adev->pm.dpm.dyn_state.vddci_dependency_on_mclk);\r\nci_patch_vce_clock_voltage_dependency_table_with_vddc_leakage(adev,\r\n&adev->pm.dpm.dyn_state.vce_clock_voltage_dependency_table);\r\nci_patch_uvd_clock_voltage_dependency_table_with_vddc_leakage(adev,\r\n&adev->pm.dpm.dyn_state.uvd_clock_voltage_dependency_table);\r\nci_patch_clock_voltage_dependency_table_with_vddc_leakage(adev,\r\n&adev->pm.dpm.dyn_state.samu_clock_voltage_dependency_table);\r\nci_patch_clock_voltage_dependency_table_with_vddc_leakage(adev,\r\n&adev->pm.dpm.dyn_state.acp_clock_voltage_dependency_table);\r\nci_patch_vddc_phase_shed_limit_table_with_vddc_leakage(adev,\r\n&adev->pm.dpm.dyn_state.phase_shedding_limits_table);\r\nci_patch_clock_voltage_limits_with_vddc_leakage(adev,\r\n&adev->pm.dpm.dyn_state.max_clock_voltage_on_ac);\r\nci_patch_clock_voltage_limits_with_vddc_leakage(adev,\r\n&adev->pm.dpm.dyn_state.max_clock_voltage_on_dc);\r\nci_patch_cac_leakage_table_with_vddc_leakage(adev,\r\n&adev->pm.dpm.dyn_state.cac_leakage_table);\r\n}\r\nstatic void ci_update_current_ps(struct amdgpu_device *adev,\r\nstruct amdgpu_ps *rps)\r\n{\r\nstruct ci_ps *new_ps = ci_get_ps(rps);\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\npi->current_rps = *rps;\r\npi->current_ps = *new_ps;\r\npi->current_rps.ps_priv = &pi->current_ps;\r\nadev->pm.dpm.current_ps = &pi->current_rps;\r\n}\r\nstatic void ci_update_requested_ps(struct amdgpu_device *adev,\r\nstruct amdgpu_ps *rps)\r\n{\r\nstruct ci_ps *new_ps = ci_get_ps(rps);\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\npi->requested_rps = *rps;\r\npi->requested_ps = *new_ps;\r\npi->requested_rps.ps_priv = &pi->requested_ps;\r\nadev->pm.dpm.requested_ps = &pi->requested_rps;\r\n}\r\nstatic int ci_dpm_pre_set_power_state(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nstruct amdgpu_ps requested_ps = *adev->pm.dpm.requested_ps;\r\nstruct amdgpu_ps *new_ps = &requested_ps;\r\nci_update_requested_ps(adev, new_ps);\r\nci_apply_state_adjust_rules(adev, &pi->requested_rps);\r\nreturn 0;\r\n}\r\nstatic void ci_dpm_post_set_power_state(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nstruct amdgpu_ps *new_ps = &pi->requested_rps;\r\nci_update_current_ps(adev, new_ps);\r\n}\r\nstatic void ci_dpm_setup_asic(struct amdgpu_device *adev)\r\n{\r\nci_read_clock_registers(adev);\r\nci_enable_acpi_power_management(adev);\r\nci_init_sclk_t(adev);\r\n}\r\nstatic int ci_dpm_enable(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nstruct amdgpu_ps *boot_ps = adev->pm.dpm.boot_ps;\r\nint ret;\r\nif (pi->voltage_control != CISLANDS_VOLTAGE_CONTROL_NONE) {\r\nci_enable_voltage_control(adev);\r\nret = ci_construct_voltage_tables(adev);\r\nif (ret) {\r\nDRM_ERROR("ci_construct_voltage_tables failed\n");\r\nreturn ret;\r\n}\r\n}\r\nif (pi->caps_dynamic_ac_timing) {\r\nret = ci_initialize_mc_reg_table(adev);\r\nif (ret)\r\npi->caps_dynamic_ac_timing = false;\r\n}\r\nif (pi->dynamic_ss)\r\nci_enable_spread_spectrum(adev, true);\r\nif (pi->thermal_protection)\r\nci_enable_thermal_protection(adev, true);\r\nci_program_sstp(adev);\r\nci_enable_display_gap(adev);\r\nci_program_vc(adev);\r\nret = ci_upload_firmware(adev);\r\nif (ret) {\r\nDRM_ERROR("ci_upload_firmware failed\n");\r\nreturn ret;\r\n}\r\nret = ci_process_firmware_header(adev);\r\nif (ret) {\r\nDRM_ERROR("ci_process_firmware_header failed\n");\r\nreturn ret;\r\n}\r\nret = ci_initial_switch_from_arb_f0_to_f1(adev);\r\nif (ret) {\r\nDRM_ERROR("ci_initial_switch_from_arb_f0_to_f1 failed\n");\r\nreturn ret;\r\n}\r\nret = ci_init_smc_table(adev);\r\nif (ret) {\r\nDRM_ERROR("ci_init_smc_table failed\n");\r\nreturn ret;\r\n}\r\nret = ci_init_arb_table_index(adev);\r\nif (ret) {\r\nDRM_ERROR("ci_init_arb_table_index failed\n");\r\nreturn ret;\r\n}\r\nif (pi->caps_dynamic_ac_timing) {\r\nret = ci_populate_initial_mc_reg_table(adev);\r\nif (ret) {\r\nDRM_ERROR("ci_populate_initial_mc_reg_table failed\n");\r\nreturn ret;\r\n}\r\n}\r\nret = ci_populate_pm_base(adev);\r\nif (ret) {\r\nDRM_ERROR("ci_populate_pm_base failed\n");\r\nreturn ret;\r\n}\r\nci_dpm_start_smc(adev);\r\nci_enable_vr_hot_gpio_interrupt(adev);\r\nret = ci_notify_smc_display_change(adev, false);\r\nif (ret) {\r\nDRM_ERROR("ci_notify_smc_display_change failed\n");\r\nreturn ret;\r\n}\r\nci_enable_sclk_control(adev, true);\r\nret = ci_enable_ulv(adev, true);\r\nif (ret) {\r\nDRM_ERROR("ci_enable_ulv failed\n");\r\nreturn ret;\r\n}\r\nret = ci_enable_ds_master_switch(adev, true);\r\nif (ret) {\r\nDRM_ERROR("ci_enable_ds_master_switch failed\n");\r\nreturn ret;\r\n}\r\nret = ci_start_dpm(adev);\r\nif (ret) {\r\nDRM_ERROR("ci_start_dpm failed\n");\r\nreturn ret;\r\n}\r\nret = ci_enable_didt(adev, true);\r\nif (ret) {\r\nDRM_ERROR("ci_enable_didt failed\n");\r\nreturn ret;\r\n}\r\nret = ci_enable_smc_cac(adev, true);\r\nif (ret) {\r\nDRM_ERROR("ci_enable_smc_cac failed\n");\r\nreturn ret;\r\n}\r\nret = ci_enable_power_containment(adev, true);\r\nif (ret) {\r\nDRM_ERROR("ci_enable_power_containment failed\n");\r\nreturn ret;\r\n}\r\nret = ci_power_control_set_level(adev);\r\nif (ret) {\r\nDRM_ERROR("ci_power_control_set_level failed\n");\r\nreturn ret;\r\n}\r\nci_enable_auto_throttle_source(adev, AMDGPU_DPM_AUTO_THROTTLE_SRC_THERMAL, true);\r\nret = ci_enable_thermal_based_sclk_dpm(adev, true);\r\nif (ret) {\r\nDRM_ERROR("ci_enable_thermal_based_sclk_dpm failed\n");\r\nreturn ret;\r\n}\r\nci_thermal_start_thermal_controller(adev);\r\nci_update_current_ps(adev, boot_ps);\r\nreturn 0;\r\n}\r\nstatic void ci_dpm_disable(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nstruct amdgpu_ps *boot_ps = adev->pm.dpm.boot_ps;\r\namdgpu_irq_put(adev, &adev->pm.dpm.thermal.irq,\r\nAMDGPU_THERMAL_IRQ_LOW_TO_HIGH);\r\namdgpu_irq_put(adev, &adev->pm.dpm.thermal.irq,\r\nAMDGPU_THERMAL_IRQ_HIGH_TO_LOW);\r\nci_dpm_powergate_uvd(adev, true);\r\nif (!amdgpu_ci_is_smc_running(adev))\r\nreturn;\r\nci_thermal_stop_thermal_controller(adev);\r\nif (pi->thermal_protection)\r\nci_enable_thermal_protection(adev, false);\r\nci_enable_power_containment(adev, false);\r\nci_enable_smc_cac(adev, false);\r\nci_enable_didt(adev, false);\r\nci_enable_spread_spectrum(adev, false);\r\nci_enable_auto_throttle_source(adev, AMDGPU_DPM_AUTO_THROTTLE_SRC_THERMAL, false);\r\nci_stop_dpm(adev);\r\nci_enable_ds_master_switch(adev, false);\r\nci_enable_ulv(adev, false);\r\nci_clear_vc(adev);\r\nci_reset_to_default(adev);\r\nci_dpm_stop_smc(adev);\r\nci_force_switch_to_arb_f0(adev);\r\nci_enable_thermal_based_sclk_dpm(adev, false);\r\nci_update_current_ps(adev, boot_ps);\r\n}\r\nstatic int ci_dpm_set_power_state(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nstruct amdgpu_ps *new_ps = &pi->requested_rps;\r\nstruct amdgpu_ps *old_ps = &pi->current_rps;\r\nint ret;\r\nci_find_dpm_states_clocks_in_dpm_table(adev, new_ps);\r\nif (pi->pcie_performance_request)\r\nci_request_link_speed_change_before_state_change(adev, new_ps, old_ps);\r\nret = ci_freeze_sclk_mclk_dpm(adev);\r\nif (ret) {\r\nDRM_ERROR("ci_freeze_sclk_mclk_dpm failed\n");\r\nreturn ret;\r\n}\r\nret = ci_populate_and_upload_sclk_mclk_dpm_levels(adev, new_ps);\r\nif (ret) {\r\nDRM_ERROR("ci_populate_and_upload_sclk_mclk_dpm_levels failed\n");\r\nreturn ret;\r\n}\r\nret = ci_generate_dpm_level_enable_mask(adev, new_ps);\r\nif (ret) {\r\nDRM_ERROR("ci_generate_dpm_level_enable_mask failed\n");\r\nreturn ret;\r\n}\r\nret = ci_update_vce_dpm(adev, new_ps, old_ps);\r\nif (ret) {\r\nDRM_ERROR("ci_update_vce_dpm failed\n");\r\nreturn ret;\r\n}\r\nret = ci_update_sclk_t(adev);\r\nif (ret) {\r\nDRM_ERROR("ci_update_sclk_t failed\n");\r\nreturn ret;\r\n}\r\nif (pi->caps_dynamic_ac_timing) {\r\nret = ci_update_and_upload_mc_reg_table(adev);\r\nif (ret) {\r\nDRM_ERROR("ci_update_and_upload_mc_reg_table failed\n");\r\nreturn ret;\r\n}\r\n}\r\nret = ci_program_memory_timing_parameters(adev);\r\nif (ret) {\r\nDRM_ERROR("ci_program_memory_timing_parameters failed\n");\r\nreturn ret;\r\n}\r\nret = ci_unfreeze_sclk_mclk_dpm(adev);\r\nif (ret) {\r\nDRM_ERROR("ci_unfreeze_sclk_mclk_dpm failed\n");\r\nreturn ret;\r\n}\r\nret = ci_upload_dpm_level_enable_mask(adev);\r\nif (ret) {\r\nDRM_ERROR("ci_upload_dpm_level_enable_mask failed\n");\r\nreturn ret;\r\n}\r\nif (pi->pcie_performance_request)\r\nci_notify_link_speed_change_after_state_change(adev, new_ps, old_ps);\r\nreturn 0;\r\n}\r\nstatic void ci_dpm_display_configuration_changed(struct amdgpu_device *adev)\r\n{\r\nci_program_display_gap(adev);\r\n}\r\nstatic void ci_parse_pplib_non_clock_info(struct amdgpu_device *adev,\r\nstruct amdgpu_ps *rps,\r\nstruct _ATOM_PPLIB_NONCLOCK_INFO *non_clock_info,\r\nu8 table_rev)\r\n{\r\nrps->caps = le32_to_cpu(non_clock_info->ulCapsAndSettings);\r\nrps->class = le16_to_cpu(non_clock_info->usClassification);\r\nrps->class2 = le16_to_cpu(non_clock_info->usClassification2);\r\nif (ATOM_PPLIB_NONCLOCKINFO_VER1 < table_rev) {\r\nrps->vclk = le32_to_cpu(non_clock_info->ulVCLK);\r\nrps->dclk = le32_to_cpu(non_clock_info->ulDCLK);\r\n} else {\r\nrps->vclk = 0;\r\nrps->dclk = 0;\r\n}\r\nif (rps->class & ATOM_PPLIB_CLASSIFICATION_BOOT)\r\nadev->pm.dpm.boot_ps = rps;\r\nif (rps->class & ATOM_PPLIB_CLASSIFICATION_UVDSTATE)\r\nadev->pm.dpm.uvd_ps = rps;\r\n}\r\nstatic void ci_parse_pplib_clock_info(struct amdgpu_device *adev,\r\nstruct amdgpu_ps *rps, int index,\r\nunion pplib_clock_info *clock_info)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nstruct ci_ps *ps = ci_get_ps(rps);\r\nstruct ci_pl *pl = &ps->performance_levels[index];\r\nps->performance_level_count = index + 1;\r\npl->sclk = le16_to_cpu(clock_info->ci.usEngineClockLow);\r\npl->sclk |= clock_info->ci.ucEngineClockHigh << 16;\r\npl->mclk = le16_to_cpu(clock_info->ci.usMemoryClockLow);\r\npl->mclk |= clock_info->ci.ucMemoryClockHigh << 16;\r\npl->pcie_gen = amdgpu_get_pcie_gen_support(adev,\r\npi->sys_pcie_mask,\r\npi->vbios_boot_state.pcie_gen_bootup_value,\r\nclock_info->ci.ucPCIEGen);\r\npl->pcie_lane = amdgpu_get_pcie_lane_support(adev,\r\npi->vbios_boot_state.pcie_lane_bootup_value,\r\nle16_to_cpu(clock_info->ci.usPCIELane));\r\nif (rps->class & ATOM_PPLIB_CLASSIFICATION_ACPI) {\r\npi->acpi_pcie_gen = pl->pcie_gen;\r\n}\r\nif (rps->class2 & ATOM_PPLIB_CLASSIFICATION2_ULV) {\r\npi->ulv.supported = true;\r\npi->ulv.pl = *pl;\r\npi->ulv.cg_ulv_parameter = CISLANDS_CGULVPARAMETER_DFLT;\r\n}\r\nif (rps->class & ATOM_PPLIB_CLASSIFICATION_BOOT) {\r\npl->mclk = pi->vbios_boot_state.mclk_bootup_value;\r\npl->sclk = pi->vbios_boot_state.sclk_bootup_value;\r\npl->pcie_gen = pi->vbios_boot_state.pcie_gen_bootup_value;\r\npl->pcie_lane = pi->vbios_boot_state.pcie_lane_bootup_value;\r\n}\r\nswitch (rps->class & ATOM_PPLIB_CLASSIFICATION_UI_MASK) {\r\ncase ATOM_PPLIB_CLASSIFICATION_UI_BATTERY:\r\npi->use_pcie_powersaving_levels = true;\r\nif (pi->pcie_gen_powersaving.max < pl->pcie_gen)\r\npi->pcie_gen_powersaving.max = pl->pcie_gen;\r\nif (pi->pcie_gen_powersaving.min > pl->pcie_gen)\r\npi->pcie_gen_powersaving.min = pl->pcie_gen;\r\nif (pi->pcie_lane_powersaving.max < pl->pcie_lane)\r\npi->pcie_lane_powersaving.max = pl->pcie_lane;\r\nif (pi->pcie_lane_powersaving.min > pl->pcie_lane)\r\npi->pcie_lane_powersaving.min = pl->pcie_lane;\r\nbreak;\r\ncase ATOM_PPLIB_CLASSIFICATION_UI_PERFORMANCE:\r\npi->use_pcie_performance_levels = true;\r\nif (pi->pcie_gen_performance.max < pl->pcie_gen)\r\npi->pcie_gen_performance.max = pl->pcie_gen;\r\nif (pi->pcie_gen_performance.min > pl->pcie_gen)\r\npi->pcie_gen_performance.min = pl->pcie_gen;\r\nif (pi->pcie_lane_performance.max < pl->pcie_lane)\r\npi->pcie_lane_performance.max = pl->pcie_lane;\r\nif (pi->pcie_lane_performance.min > pl->pcie_lane)\r\npi->pcie_lane_performance.min = pl->pcie_lane;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int ci_parse_power_table(struct amdgpu_device *adev)\r\n{\r\nstruct amdgpu_mode_info *mode_info = &adev->mode_info;\r\nstruct _ATOM_PPLIB_NONCLOCK_INFO *non_clock_info;\r\nunion pplib_power_state *power_state;\r\nint i, j, k, non_clock_array_index, clock_array_index;\r\nunion pplib_clock_info *clock_info;\r\nstruct _StateArray *state_array;\r\nstruct _ClockInfoArray *clock_info_array;\r\nstruct _NonClockInfoArray *non_clock_info_array;\r\nunion power_info *power_info;\r\nint index = GetIndexIntoMasterTable(DATA, PowerPlayInfo);\r\nu16 data_offset;\r\nu8 frev, crev;\r\nu8 *power_state_offset;\r\nstruct ci_ps *ps;\r\nif (!amdgpu_atom_parse_data_header(mode_info->atom_context, index, NULL,\r\n&frev, &crev, &data_offset))\r\nreturn -EINVAL;\r\npower_info = (union power_info *)(mode_info->atom_context->bios + data_offset);\r\namdgpu_add_thermal_controller(adev);\r\nstate_array = (struct _StateArray *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(power_info->pplib.usStateArrayOffset));\r\nclock_info_array = (struct _ClockInfoArray *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(power_info->pplib.usClockInfoArrayOffset));\r\nnon_clock_info_array = (struct _NonClockInfoArray *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(power_info->pplib.usNonClockInfoArrayOffset));\r\nadev->pm.dpm.ps = kzalloc(sizeof(struct amdgpu_ps) *\r\nstate_array->ucNumEntries, GFP_KERNEL);\r\nif (!adev->pm.dpm.ps)\r\nreturn -ENOMEM;\r\npower_state_offset = (u8 *)state_array->states;\r\nfor (i = 0; i < state_array->ucNumEntries; i++) {\r\nu8 *idx;\r\npower_state = (union pplib_power_state *)power_state_offset;\r\nnon_clock_array_index = power_state->v2.nonClockInfoIndex;\r\nnon_clock_info = (struct _ATOM_PPLIB_NONCLOCK_INFO *)\r\n&non_clock_info_array->nonClockInfo[non_clock_array_index];\r\nps = kzalloc(sizeof(struct ci_ps), GFP_KERNEL);\r\nif (ps == NULL) {\r\nkfree(adev->pm.dpm.ps);\r\nreturn -ENOMEM;\r\n}\r\nadev->pm.dpm.ps[i].ps_priv = ps;\r\nci_parse_pplib_non_clock_info(adev, &adev->pm.dpm.ps[i],\r\nnon_clock_info,\r\nnon_clock_info_array->ucEntrySize);\r\nk = 0;\r\nidx = (u8 *)&power_state->v2.clockInfoIndex[0];\r\nfor (j = 0; j < power_state->v2.ucNumDPMLevels; j++) {\r\nclock_array_index = idx[j];\r\nif (clock_array_index >= clock_info_array->ucNumEntries)\r\ncontinue;\r\nif (k >= CISLANDS_MAX_HARDWARE_POWERLEVELS)\r\nbreak;\r\nclock_info = (union pplib_clock_info *)\r\n((u8 *)&clock_info_array->clockInfo[0] +\r\n(clock_array_index * clock_info_array->ucEntrySize));\r\nci_parse_pplib_clock_info(adev,\r\n&adev->pm.dpm.ps[i], k,\r\nclock_info);\r\nk++;\r\n}\r\npower_state_offset += 2 + power_state->v2.ucNumDPMLevels;\r\n}\r\nadev->pm.dpm.num_ps = state_array->ucNumEntries;\r\nfor (i = 0; i < adev->pm.dpm.num_of_vce_states; i++) {\r\nu32 sclk, mclk;\r\nclock_array_index = adev->pm.dpm.vce_states[i].clk_idx;\r\nclock_info = (union pplib_clock_info *)\r\n&clock_info_array->clockInfo[clock_array_index * clock_info_array->ucEntrySize];\r\nsclk = le16_to_cpu(clock_info->ci.usEngineClockLow);\r\nsclk |= clock_info->ci.ucEngineClockHigh << 16;\r\nmclk = le16_to_cpu(clock_info->ci.usMemoryClockLow);\r\nmclk |= clock_info->ci.ucMemoryClockHigh << 16;\r\nadev->pm.dpm.vce_states[i].sclk = sclk;\r\nadev->pm.dpm.vce_states[i].mclk = mclk;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ci_get_vbios_boot_values(struct amdgpu_device *adev,\r\nstruct ci_vbios_boot_state *boot_state)\r\n{\r\nstruct amdgpu_mode_info *mode_info = &adev->mode_info;\r\nint index = GetIndexIntoMasterTable(DATA, FirmwareInfo);\r\nATOM_FIRMWARE_INFO_V2_2 *firmware_info;\r\nu8 frev, crev;\r\nu16 data_offset;\r\nif (amdgpu_atom_parse_data_header(mode_info->atom_context, index, NULL,\r\n&frev, &crev, &data_offset)) {\r\nfirmware_info =\r\n(ATOM_FIRMWARE_INFO_V2_2 *)(mode_info->atom_context->bios +\r\ndata_offset);\r\nboot_state->mvdd_bootup_value = le16_to_cpu(firmware_info->usBootUpMVDDCVoltage);\r\nboot_state->vddc_bootup_value = le16_to_cpu(firmware_info->usBootUpVDDCVoltage);\r\nboot_state->vddci_bootup_value = le16_to_cpu(firmware_info->usBootUpVDDCIVoltage);\r\nboot_state->pcie_gen_bootup_value = ci_get_current_pcie_speed(adev);\r\nboot_state->pcie_lane_bootup_value = ci_get_current_pcie_lane_number(adev);\r\nboot_state->sclk_bootup_value = le32_to_cpu(firmware_info->ulDefaultEngineClock);\r\nboot_state->mclk_bootup_value = le32_to_cpu(firmware_info->ulDefaultMemoryClock);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void ci_dpm_fini(struct amdgpu_device *adev)\r\n{\r\nint i;\r\nfor (i = 0; i < adev->pm.dpm.num_ps; i++) {\r\nkfree(adev->pm.dpm.ps[i].ps_priv);\r\n}\r\nkfree(adev->pm.dpm.ps);\r\nkfree(adev->pm.dpm.priv);\r\nkfree(adev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries);\r\namdgpu_free_extended_power_table(adev);\r\n}\r\nstatic int ci_dpm_init_microcode(struct amdgpu_device *adev)\r\n{\r\nconst char *chip_name;\r\nchar fw_name[30];\r\nint err;\r\nDRM_DEBUG("\n");\r\nswitch (adev->asic_type) {\r\ncase CHIP_BONAIRE:\r\nif ((adev->pdev->revision == 0x80) ||\r\n(adev->pdev->revision == 0x81) ||\r\n(adev->pdev->device == 0x665f))\r\nchip_name = "bonaire_k";\r\nelse\r\nchip_name = "bonaire";\r\nbreak;\r\ncase CHIP_HAWAII:\r\nif (adev->pdev->revision == 0x80)\r\nchip_name = "hawaii_k";\r\nelse\r\nchip_name = "hawaii";\r\nbreak;\r\ncase CHIP_KAVERI:\r\ncase CHIP_KABINI:\r\ncase CHIP_MULLINS:\r\ndefault: BUG();\r\n}\r\nsnprintf(fw_name, sizeof(fw_name), "radeon/%s_smc.bin", chip_name);\r\nerr = request_firmware(&adev->pm.fw, fw_name, adev->dev);\r\nif (err)\r\ngoto out;\r\nerr = amdgpu_ucode_validate(adev->pm.fw);\r\nout:\r\nif (err) {\r\npr_err("cik_smc: Failed to load firmware \"%s\"\n", fw_name);\r\nrelease_firmware(adev->pm.fw);\r\nadev->pm.fw = NULL;\r\n}\r\nreturn err;\r\n}\r\nstatic int ci_dpm_init(struct amdgpu_device *adev)\r\n{\r\nint index = GetIndexIntoMasterTable(DATA, ASIC_InternalSS_Info);\r\nSMU7_Discrete_DpmTable *dpm_table;\r\nstruct amdgpu_gpio_rec gpio;\r\nu16 data_offset, size;\r\nu8 frev, crev;\r\nstruct ci_power_info *pi;\r\nint ret;\r\npi = kzalloc(sizeof(struct ci_power_info), GFP_KERNEL);\r\nif (pi == NULL)\r\nreturn -ENOMEM;\r\nadev->pm.dpm.priv = pi;\r\npi->sys_pcie_mask =\r\n(adev->pm.pcie_gen_mask & CAIL_PCIE_LINK_SPEED_SUPPORT_MASK) >>\r\nCAIL_PCIE_LINK_SPEED_SUPPORT_SHIFT;\r\npi->force_pcie_gen = AMDGPU_PCIE_GEN_INVALID;\r\npi->pcie_gen_performance.max = AMDGPU_PCIE_GEN1;\r\npi->pcie_gen_performance.min = AMDGPU_PCIE_GEN3;\r\npi->pcie_gen_powersaving.max = AMDGPU_PCIE_GEN1;\r\npi->pcie_gen_powersaving.min = AMDGPU_PCIE_GEN3;\r\npi->pcie_lane_performance.max = 0;\r\npi->pcie_lane_performance.min = 16;\r\npi->pcie_lane_powersaving.max = 0;\r\npi->pcie_lane_powersaving.min = 16;\r\nret = ci_get_vbios_boot_values(adev, &pi->vbios_boot_state);\r\nif (ret) {\r\nci_dpm_fini(adev);\r\nreturn ret;\r\n}\r\nret = amdgpu_get_platform_caps(adev);\r\nif (ret) {\r\nci_dpm_fini(adev);\r\nreturn ret;\r\n}\r\nret = amdgpu_parse_extended_power_table(adev);\r\nif (ret) {\r\nci_dpm_fini(adev);\r\nreturn ret;\r\n}\r\nret = ci_parse_power_table(adev);\r\nif (ret) {\r\nci_dpm_fini(adev);\r\nreturn ret;\r\n}\r\npi->dll_default_on = false;\r\npi->sram_end = SMC_RAM_END;\r\npi->activity_target[0] = CISLAND_TARGETACTIVITY_DFLT;\r\npi->activity_target[1] = CISLAND_TARGETACTIVITY_DFLT;\r\npi->activity_target[2] = CISLAND_TARGETACTIVITY_DFLT;\r\npi->activity_target[3] = CISLAND_TARGETACTIVITY_DFLT;\r\npi->activity_target[4] = CISLAND_TARGETACTIVITY_DFLT;\r\npi->activity_target[5] = CISLAND_TARGETACTIVITY_DFLT;\r\npi->activity_target[6] = CISLAND_TARGETACTIVITY_DFLT;\r\npi->activity_target[7] = CISLAND_TARGETACTIVITY_DFLT;\r\npi->mclk_activity_target = CISLAND_MCLK_TARGETACTIVITY_DFLT;\r\npi->sclk_dpm_key_disabled = 0;\r\npi->mclk_dpm_key_disabled = 0;\r\npi->pcie_dpm_key_disabled = 0;\r\npi->thermal_sclk_dpm_enabled = 0;\r\nif (amdgpu_pp_feature_mask & SCLK_DEEP_SLEEP_MASK)\r\npi->caps_sclk_ds = true;\r\nelse\r\npi->caps_sclk_ds = false;\r\npi->mclk_strobe_mode_threshold = 40000;\r\npi->mclk_stutter_mode_threshold = 40000;\r\npi->mclk_edc_enable_threshold = 40000;\r\npi->mclk_edc_wr_enable_threshold = 40000;\r\nci_initialize_powertune_defaults(adev);\r\npi->caps_fps = false;\r\npi->caps_sclk_throttle_low_notification = false;\r\npi->caps_uvd_dpm = true;\r\npi->caps_vce_dpm = true;\r\nci_get_leakage_voltages(adev);\r\nci_patch_dependency_tables_with_leakage(adev);\r\nci_set_private_data_variables_based_on_pptable(adev);\r\nadev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries =\r\nkzalloc(4 * sizeof(struct amdgpu_clock_voltage_dependency_entry), GFP_KERNEL);\r\nif (!adev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries) {\r\nci_dpm_fini(adev);\r\nreturn -ENOMEM;\r\n}\r\nadev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.count = 4;\r\nadev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[0].clk = 0;\r\nadev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[0].v = 0;\r\nadev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[1].clk = 36000;\r\nadev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[1].v = 720;\r\nadev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[2].clk = 54000;\r\nadev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[2].v = 810;\r\nadev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[3].clk = 72000;\r\nadev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[3].v = 900;\r\nadev->pm.dpm.dyn_state.mclk_sclk_ratio = 4;\r\nadev->pm.dpm.dyn_state.sclk_mclk_delta = 15000;\r\nadev->pm.dpm.dyn_state.vddc_vddci_delta = 200;\r\nadev->pm.dpm.dyn_state.valid_sclk_values.count = 0;\r\nadev->pm.dpm.dyn_state.valid_sclk_values.values = NULL;\r\nadev->pm.dpm.dyn_state.valid_mclk_values.count = 0;\r\nadev->pm.dpm.dyn_state.valid_mclk_values.values = NULL;\r\nif (adev->asic_type == CHIP_HAWAII) {\r\npi->thermal_temp_setting.temperature_low = 94500;\r\npi->thermal_temp_setting.temperature_high = 95000;\r\npi->thermal_temp_setting.temperature_shutdown = 104000;\r\n} else {\r\npi->thermal_temp_setting.temperature_low = 99500;\r\npi->thermal_temp_setting.temperature_high = 100000;\r\npi->thermal_temp_setting.temperature_shutdown = 104000;\r\n}\r\npi->uvd_enabled = false;\r\ndpm_table = &pi->smc_state_table;\r\ngpio = amdgpu_atombios_lookup_gpio(adev, VDDC_VRHOT_GPIO_PINID);\r\nif (gpio.valid) {\r\ndpm_table->VRHotGpio = gpio.shift;\r\nadev->pm.dpm.platform_caps |= ATOM_PP_PLATFORM_CAP_REGULATOR_HOT;\r\n} else {\r\ndpm_table->VRHotGpio = CISLANDS_UNUSED_GPIO_PIN;\r\nadev->pm.dpm.platform_caps &= ~ATOM_PP_PLATFORM_CAP_REGULATOR_HOT;\r\n}\r\ngpio = amdgpu_atombios_lookup_gpio(adev, PP_AC_DC_SWITCH_GPIO_PINID);\r\nif (gpio.valid) {\r\ndpm_table->AcDcGpio = gpio.shift;\r\nadev->pm.dpm.platform_caps |= ATOM_PP_PLATFORM_CAP_HARDWAREDC;\r\n} else {\r\ndpm_table->AcDcGpio = CISLANDS_UNUSED_GPIO_PIN;\r\nadev->pm.dpm.platform_caps &= ~ATOM_PP_PLATFORM_CAP_HARDWAREDC;\r\n}\r\ngpio = amdgpu_atombios_lookup_gpio(adev, VDDC_PCC_GPIO_PINID);\r\nif (gpio.valid) {\r\nu32 tmp = RREG32_SMC(ixCNB_PWRMGT_CNTL);\r\nswitch (gpio.shift) {\r\ncase 0:\r\ntmp &= ~CNB_PWRMGT_CNTL__GNB_SLOW_MODE_MASK;\r\ntmp |= 1 << CNB_PWRMGT_CNTL__GNB_SLOW_MODE__SHIFT;\r\nbreak;\r\ncase 1:\r\ntmp &= ~CNB_PWRMGT_CNTL__GNB_SLOW_MODE_MASK;\r\ntmp |= 2 << CNB_PWRMGT_CNTL__GNB_SLOW_MODE__SHIFT;\r\nbreak;\r\ncase 2:\r\ntmp |= CNB_PWRMGT_CNTL__GNB_SLOW_MASK;\r\nbreak;\r\ncase 3:\r\ntmp |= CNB_PWRMGT_CNTL__FORCE_NB_PS1_MASK;\r\nbreak;\r\ncase 4:\r\ntmp |= CNB_PWRMGT_CNTL__DPM_ENABLED_MASK;\r\nbreak;\r\ndefault:\r\nDRM_INFO("Invalid PCC GPIO: %u!\n", gpio.shift);\r\nbreak;\r\n}\r\nWREG32_SMC(ixCNB_PWRMGT_CNTL, tmp);\r\n}\r\npi->voltage_control = CISLANDS_VOLTAGE_CONTROL_NONE;\r\npi->vddci_control = CISLANDS_VOLTAGE_CONTROL_NONE;\r\npi->mvdd_control = CISLANDS_VOLTAGE_CONTROL_NONE;\r\nif (amdgpu_atombios_is_voltage_gpio(adev, VOLTAGE_TYPE_VDDC, VOLTAGE_OBJ_GPIO_LUT))\r\npi->voltage_control = CISLANDS_VOLTAGE_CONTROL_BY_GPIO;\r\nelse if (amdgpu_atombios_is_voltage_gpio(adev, VOLTAGE_TYPE_VDDC, VOLTAGE_OBJ_SVID2))\r\npi->voltage_control = CISLANDS_VOLTAGE_CONTROL_BY_SVID2;\r\nif (adev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_VDDCI_CONTROL) {\r\nif (amdgpu_atombios_is_voltage_gpio(adev, VOLTAGE_TYPE_VDDCI, VOLTAGE_OBJ_GPIO_LUT))\r\npi->vddci_control = CISLANDS_VOLTAGE_CONTROL_BY_GPIO;\r\nelse if (amdgpu_atombios_is_voltage_gpio(adev, VOLTAGE_TYPE_VDDCI, VOLTAGE_OBJ_SVID2))\r\npi->vddci_control = CISLANDS_VOLTAGE_CONTROL_BY_SVID2;\r\nelse\r\nadev->pm.dpm.platform_caps &= ~ATOM_PP_PLATFORM_CAP_VDDCI_CONTROL;\r\n}\r\nif (adev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_MVDDCONTROL) {\r\nif (amdgpu_atombios_is_voltage_gpio(adev, VOLTAGE_TYPE_MVDDC, VOLTAGE_OBJ_GPIO_LUT))\r\npi->mvdd_control = CISLANDS_VOLTAGE_CONTROL_BY_GPIO;\r\nelse if (amdgpu_atombios_is_voltage_gpio(adev, VOLTAGE_TYPE_MVDDC, VOLTAGE_OBJ_SVID2))\r\npi->mvdd_control = CISLANDS_VOLTAGE_CONTROL_BY_SVID2;\r\nelse\r\nadev->pm.dpm.platform_caps &= ~ATOM_PP_PLATFORM_CAP_MVDDCONTROL;\r\n}\r\npi->vddc_phase_shed_control = true;\r\n#if defined(CONFIG_ACPI)\r\npi->pcie_performance_request =\r\namdgpu_acpi_is_pcie_performance_request_supported(adev);\r\n#else\r\npi->pcie_performance_request = false;\r\n#endif\r\nif (amdgpu_atom_parse_data_header(adev->mode_info.atom_context, index, &size,\r\n&frev, &crev, &data_offset)) {\r\npi->caps_sclk_ss_support = true;\r\npi->caps_mclk_ss_support = true;\r\npi->dynamic_ss = true;\r\n} else {\r\npi->caps_sclk_ss_support = false;\r\npi->caps_mclk_ss_support = false;\r\npi->dynamic_ss = true;\r\n}\r\nif (adev->pm.int_thermal_type != THERMAL_TYPE_NONE)\r\npi->thermal_protection = true;\r\nelse\r\npi->thermal_protection = false;\r\npi->caps_dynamic_ac_timing = true;\r\npi->uvd_power_gated = true;\r\nif ((adev->pm.dpm.dyn_state.max_clock_voltage_on_dc.sclk == 0) ||\r\n(adev->pm.dpm.dyn_state.max_clock_voltage_on_dc.mclk == 0))\r\nadev->pm.dpm.dyn_state.max_clock_voltage_on_dc =\r\nadev->pm.dpm.dyn_state.max_clock_voltage_on_ac;\r\npi->fan_ctrl_is_in_default_mode = true;\r\nreturn 0;\r\n}\r\nstatic void\r\nci_dpm_debugfs_print_current_performance_level(struct amdgpu_device *adev,\r\nstruct seq_file *m)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nstruct amdgpu_ps *rps = &pi->current_rps;\r\nu32 sclk = ci_get_average_sclk_freq(adev);\r\nu32 mclk = ci_get_average_mclk_freq(adev);\r\nu32 activity_percent = 50;\r\nint ret;\r\nret = ci_read_smc_soft_register(adev, offsetof(SMU7_SoftRegisters, AverageGraphicsA),\r\n&activity_percent);\r\nif (ret == 0) {\r\nactivity_percent += 0x80;\r\nactivity_percent >>= 8;\r\nactivity_percent = activity_percent > 100 ? 100 : activity_percent;\r\n}\r\nseq_printf(m, "uvd %sabled\n", pi->uvd_power_gated ? "dis" : "en");\r\nseq_printf(m, "vce %sabled\n", rps->vce_active ? "en" : "dis");\r\nseq_printf(m, "power level avg sclk: %u mclk: %u\n",\r\nsclk, mclk);\r\nseq_printf(m, "GPU load: %u %%\n", activity_percent);\r\n}\r\nstatic void ci_dpm_print_power_state(struct amdgpu_device *adev,\r\nstruct amdgpu_ps *rps)\r\n{\r\nstruct ci_ps *ps = ci_get_ps(rps);\r\nstruct ci_pl *pl;\r\nint i;\r\namdgpu_dpm_print_class_info(rps->class, rps->class2);\r\namdgpu_dpm_print_cap_info(rps->caps);\r\nprintk("\tuvd vclk: %d dclk: %d\n", rps->vclk, rps->dclk);\r\nfor (i = 0; i < ps->performance_level_count; i++) {\r\npl = &ps->performance_levels[i];\r\nprintk("\t\tpower level %d sclk: %u mclk: %u pcie gen: %u pcie lanes: %u\n",\r\ni, pl->sclk, pl->mclk, pl->pcie_gen + 1, pl->pcie_lane);\r\n}\r\namdgpu_dpm_print_ps_status(adev, rps);\r\n}\r\nstatic inline bool ci_are_power_levels_equal(const struct ci_pl *ci_cpl1,\r\nconst struct ci_pl *ci_cpl2)\r\n{\r\nreturn ((ci_cpl1->mclk == ci_cpl2->mclk) &&\r\n(ci_cpl1->sclk == ci_cpl2->sclk) &&\r\n(ci_cpl1->pcie_gen == ci_cpl2->pcie_gen) &&\r\n(ci_cpl1->pcie_lane == ci_cpl2->pcie_lane));\r\n}\r\nstatic int ci_check_state_equal(struct amdgpu_device *adev,\r\nstruct amdgpu_ps *cps,\r\nstruct amdgpu_ps *rps,\r\nbool *equal)\r\n{\r\nstruct ci_ps *ci_cps;\r\nstruct ci_ps *ci_rps;\r\nint i;\r\nif (adev == NULL || cps == NULL || rps == NULL || equal == NULL)\r\nreturn -EINVAL;\r\nci_cps = ci_get_ps(cps);\r\nci_rps = ci_get_ps(rps);\r\nif (ci_cps == NULL) {\r\n*equal = false;\r\nreturn 0;\r\n}\r\nif (ci_cps->performance_level_count != ci_rps->performance_level_count) {\r\n*equal = false;\r\nreturn 0;\r\n}\r\nfor (i = 0; i < ci_cps->performance_level_count; i++) {\r\nif (!ci_are_power_levels_equal(&(ci_cps->performance_levels[i]),\r\n&(ci_rps->performance_levels[i]))) {\r\n*equal = false;\r\nreturn 0;\r\n}\r\n}\r\n*equal = ((cps->vclk == rps->vclk) && (cps->dclk == rps->dclk));\r\n*equal &= ((cps->evclk == rps->evclk) && (cps->ecclk == rps->ecclk));\r\nreturn 0;\r\n}\r\nstatic u32 ci_dpm_get_sclk(struct amdgpu_device *adev, bool low)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nstruct ci_ps *requested_state = ci_get_ps(&pi->requested_rps);\r\nif (low)\r\nreturn requested_state->performance_levels[0].sclk;\r\nelse\r\nreturn requested_state->performance_levels[requested_state->performance_level_count - 1].sclk;\r\n}\r\nstatic u32 ci_dpm_get_mclk(struct amdgpu_device *adev, bool low)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nstruct ci_ps *requested_state = ci_get_ps(&pi->requested_rps);\r\nif (low)\r\nreturn requested_state->performance_levels[0].mclk;\r\nelse\r\nreturn requested_state->performance_levels[requested_state->performance_level_count - 1].mclk;\r\n}\r\nstatic int ci_dpm_get_temp(struct amdgpu_device *adev)\r\n{\r\nu32 temp;\r\nint actual_temp = 0;\r\ntemp = (RREG32_SMC(ixCG_MULT_THERMAL_STATUS) & CG_MULT_THERMAL_STATUS__CTF_TEMP_MASK) >>\r\nCG_MULT_THERMAL_STATUS__CTF_TEMP__SHIFT;\r\nif (temp & 0x200)\r\nactual_temp = 255;\r\nelse\r\nactual_temp = temp & 0x1ff;\r\nactual_temp = actual_temp * 1000;\r\nreturn actual_temp;\r\n}\r\nstatic int ci_set_temperature_range(struct amdgpu_device *adev)\r\n{\r\nint ret;\r\nret = ci_thermal_enable_alert(adev, false);\r\nif (ret)\r\nreturn ret;\r\nret = ci_thermal_set_temperature_range(adev, CISLANDS_TEMP_RANGE_MIN,\r\nCISLANDS_TEMP_RANGE_MAX);\r\nif (ret)\r\nreturn ret;\r\nret = ci_thermal_enable_alert(adev, true);\r\nif (ret)\r\nreturn ret;\r\nreturn ret;\r\n}\r\nstatic int ci_dpm_early_init(void *handle)\r\n{\r\nstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\r\nci_dpm_set_dpm_funcs(adev);\r\nci_dpm_set_irq_funcs(adev);\r\nreturn 0;\r\n}\r\nstatic int ci_dpm_late_init(void *handle)\r\n{\r\nint ret;\r\nstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\r\nif (!amdgpu_dpm)\r\nreturn 0;\r\nret = amdgpu_pm_sysfs_init(adev);\r\nif (ret)\r\nreturn ret;\r\nret = ci_set_temperature_range(adev);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int ci_dpm_sw_init(void *handle)\r\n{\r\nint ret;\r\nstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\r\nret = amdgpu_irq_add_id(adev, AMDGPU_IH_CLIENTID_LEGACY, 230,\r\n&adev->pm.dpm.thermal.irq);\r\nif (ret)\r\nreturn ret;\r\nret = amdgpu_irq_add_id(adev, AMDGPU_IH_CLIENTID_LEGACY, 231,\r\n&adev->pm.dpm.thermal.irq);\r\nif (ret)\r\nreturn ret;\r\nadev->pm.dpm.state = POWER_STATE_TYPE_BALANCED;\r\nadev->pm.dpm.user_state = POWER_STATE_TYPE_BALANCED;\r\nadev->pm.dpm.forced_level = AMD_DPM_FORCED_LEVEL_AUTO;\r\nadev->pm.default_sclk = adev->clock.default_sclk;\r\nadev->pm.default_mclk = adev->clock.default_mclk;\r\nadev->pm.current_sclk = adev->clock.default_sclk;\r\nadev->pm.current_mclk = adev->clock.default_mclk;\r\nadev->pm.int_thermal_type = THERMAL_TYPE_NONE;\r\nret = ci_dpm_init_microcode(adev);\r\nif (ret)\r\nreturn ret;\r\nif (amdgpu_dpm == 0)\r\nreturn 0;\r\nINIT_WORK(&adev->pm.dpm.thermal.work, amdgpu_dpm_thermal_work_handler);\r\nmutex_lock(&adev->pm.mutex);\r\nret = ci_dpm_init(adev);\r\nif (ret)\r\ngoto dpm_failed;\r\nadev->pm.dpm.current_ps = adev->pm.dpm.requested_ps = adev->pm.dpm.boot_ps;\r\nif (amdgpu_dpm == 1)\r\namdgpu_pm_print_power_states(adev);\r\nmutex_unlock(&adev->pm.mutex);\r\nDRM_INFO("amdgpu: dpm initialized\n");\r\nreturn 0;\r\ndpm_failed:\r\nci_dpm_fini(adev);\r\nmutex_unlock(&adev->pm.mutex);\r\nDRM_ERROR("amdgpu: dpm initialization failed\n");\r\nreturn ret;\r\n}\r\nstatic int ci_dpm_sw_fini(void *handle)\r\n{\r\nstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\r\nflush_work(&adev->pm.dpm.thermal.work);\r\nmutex_lock(&adev->pm.mutex);\r\namdgpu_pm_sysfs_fini(adev);\r\nci_dpm_fini(adev);\r\nmutex_unlock(&adev->pm.mutex);\r\nrelease_firmware(adev->pm.fw);\r\nadev->pm.fw = NULL;\r\nreturn 0;\r\n}\r\nstatic int ci_dpm_hw_init(void *handle)\r\n{\r\nint ret;\r\nstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\r\nif (!amdgpu_dpm) {\r\nret = ci_upload_firmware(adev);\r\nif (ret) {\r\nDRM_ERROR("ci_upload_firmware failed\n");\r\nreturn ret;\r\n}\r\nci_dpm_start_smc(adev);\r\nreturn 0;\r\n}\r\nmutex_lock(&adev->pm.mutex);\r\nci_dpm_setup_asic(adev);\r\nret = ci_dpm_enable(adev);\r\nif (ret)\r\nadev->pm.dpm_enabled = false;\r\nelse\r\nadev->pm.dpm_enabled = true;\r\nmutex_unlock(&adev->pm.mutex);\r\nreturn ret;\r\n}\r\nstatic int ci_dpm_hw_fini(void *handle)\r\n{\r\nstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\r\nif (adev->pm.dpm_enabled) {\r\nmutex_lock(&adev->pm.mutex);\r\nci_dpm_disable(adev);\r\nmutex_unlock(&adev->pm.mutex);\r\n} else {\r\nci_dpm_stop_smc(adev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ci_dpm_suspend(void *handle)\r\n{\r\nstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\r\nif (adev->pm.dpm_enabled) {\r\nmutex_lock(&adev->pm.mutex);\r\namdgpu_irq_put(adev, &adev->pm.dpm.thermal.irq,\r\nAMDGPU_THERMAL_IRQ_LOW_TO_HIGH);\r\namdgpu_irq_put(adev, &adev->pm.dpm.thermal.irq,\r\nAMDGPU_THERMAL_IRQ_HIGH_TO_LOW);\r\nadev->pm.dpm.last_user_state = adev->pm.dpm.user_state;\r\nadev->pm.dpm.last_state = adev->pm.dpm.state;\r\nadev->pm.dpm.user_state = POWER_STATE_TYPE_INTERNAL_BOOT;\r\nadev->pm.dpm.state = POWER_STATE_TYPE_INTERNAL_BOOT;\r\nmutex_unlock(&adev->pm.mutex);\r\namdgpu_pm_compute_clocks(adev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ci_dpm_resume(void *handle)\r\n{\r\nint ret;\r\nstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\r\nif (adev->pm.dpm_enabled) {\r\nmutex_lock(&adev->pm.mutex);\r\nci_dpm_setup_asic(adev);\r\nret = ci_dpm_enable(adev);\r\nif (ret)\r\nadev->pm.dpm_enabled = false;\r\nelse\r\nadev->pm.dpm_enabled = true;\r\nadev->pm.dpm.user_state = adev->pm.dpm.last_user_state;\r\nadev->pm.dpm.state = adev->pm.dpm.last_state;\r\nmutex_unlock(&adev->pm.mutex);\r\nif (adev->pm.dpm_enabled)\r\namdgpu_pm_compute_clocks(adev);\r\n}\r\nreturn 0;\r\n}\r\nstatic bool ci_dpm_is_idle(void *handle)\r\n{\r\nreturn true;\r\n}\r\nstatic int ci_dpm_wait_for_idle(void *handle)\r\n{\r\nreturn 0;\r\n}\r\nstatic int ci_dpm_soft_reset(void *handle)\r\n{\r\nreturn 0;\r\n}\r\nstatic int ci_dpm_set_interrupt_state(struct amdgpu_device *adev,\r\nstruct amdgpu_irq_src *source,\r\nunsigned type,\r\nenum amdgpu_interrupt_state state)\r\n{\r\nu32 cg_thermal_int;\r\nswitch (type) {\r\ncase AMDGPU_THERMAL_IRQ_LOW_TO_HIGH:\r\nswitch (state) {\r\ncase AMDGPU_IRQ_STATE_DISABLE:\r\ncg_thermal_int = RREG32_SMC(ixCG_THERMAL_INT);\r\ncg_thermal_int |= CG_THERMAL_INT_CTRL__THERM_INTH_MASK_MASK;\r\nWREG32_SMC(ixCG_THERMAL_INT, cg_thermal_int);\r\nbreak;\r\ncase AMDGPU_IRQ_STATE_ENABLE:\r\ncg_thermal_int = RREG32_SMC(ixCG_THERMAL_INT);\r\ncg_thermal_int &= ~CG_THERMAL_INT_CTRL__THERM_INTH_MASK_MASK;\r\nWREG32_SMC(ixCG_THERMAL_INT, cg_thermal_int);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase AMDGPU_THERMAL_IRQ_HIGH_TO_LOW:\r\nswitch (state) {\r\ncase AMDGPU_IRQ_STATE_DISABLE:\r\ncg_thermal_int = RREG32_SMC(ixCG_THERMAL_INT);\r\ncg_thermal_int |= CG_THERMAL_INT_CTRL__THERM_INTL_MASK_MASK;\r\nWREG32_SMC(ixCG_THERMAL_INT, cg_thermal_int);\r\nbreak;\r\ncase AMDGPU_IRQ_STATE_ENABLE:\r\ncg_thermal_int = RREG32_SMC(ixCG_THERMAL_INT);\r\ncg_thermal_int &= ~CG_THERMAL_INT_CTRL__THERM_INTL_MASK_MASK;\r\nWREG32_SMC(ixCG_THERMAL_INT, cg_thermal_int);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ci_dpm_process_interrupt(struct amdgpu_device *adev,\r\nstruct amdgpu_irq_src *source,\r\nstruct amdgpu_iv_entry *entry)\r\n{\r\nbool queue_thermal = false;\r\nif (entry == NULL)\r\nreturn -EINVAL;\r\nswitch (entry->src_id) {\r\ncase 230:\r\nDRM_DEBUG("IH: thermal low to high\n");\r\nadev->pm.dpm.thermal.high_to_low = false;\r\nqueue_thermal = true;\r\nbreak;\r\ncase 231:\r\nDRM_DEBUG("IH: thermal high to low\n");\r\nadev->pm.dpm.thermal.high_to_low = true;\r\nqueue_thermal = true;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (queue_thermal)\r\nschedule_work(&adev->pm.dpm.thermal.work);\r\nreturn 0;\r\n}\r\nstatic int ci_dpm_set_clockgating_state(void *handle,\r\nenum amd_clockgating_state state)\r\n{\r\nreturn 0;\r\n}\r\nstatic int ci_dpm_set_powergating_state(void *handle,\r\nenum amd_powergating_state state)\r\n{\r\nreturn 0;\r\n}\r\nstatic int ci_dpm_print_clock_levels(struct amdgpu_device *adev,\r\nenum pp_clock_type type, char *buf)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nstruct ci_single_dpm_table *sclk_table = &pi->dpm_table.sclk_table;\r\nstruct ci_single_dpm_table *mclk_table = &pi->dpm_table.mclk_table;\r\nstruct ci_single_dpm_table *pcie_table = &pi->dpm_table.pcie_speed_table;\r\nint i, now, size = 0;\r\nuint32_t clock, pcie_speed;\r\nswitch (type) {\r\ncase PP_SCLK:\r\namdgpu_ci_send_msg_to_smc(adev, PPSMC_MSG_API_GetSclkFrequency);\r\nclock = RREG32(mmSMC_MSG_ARG_0);\r\nfor (i = 0; i < sclk_table->count; i++) {\r\nif (clock > sclk_table->dpm_levels[i].value)\r\ncontinue;\r\nbreak;\r\n}\r\nnow = i;\r\nfor (i = 0; i < sclk_table->count; i++)\r\nsize += sprintf(buf + size, "%d: %uMhz %s\n",\r\ni, sclk_table->dpm_levels[i].value / 100,\r\n(i == now) ? "*" : "");\r\nbreak;\r\ncase PP_MCLK:\r\namdgpu_ci_send_msg_to_smc(adev, PPSMC_MSG_API_GetMclkFrequency);\r\nclock = RREG32(mmSMC_MSG_ARG_0);\r\nfor (i = 0; i < mclk_table->count; i++) {\r\nif (clock > mclk_table->dpm_levels[i].value)\r\ncontinue;\r\nbreak;\r\n}\r\nnow = i;\r\nfor (i = 0; i < mclk_table->count; i++)\r\nsize += sprintf(buf + size, "%d: %uMhz %s\n",\r\ni, mclk_table->dpm_levels[i].value / 100,\r\n(i == now) ? "*" : "");\r\nbreak;\r\ncase PP_PCIE:\r\npcie_speed = ci_get_current_pcie_speed(adev);\r\nfor (i = 0; i < pcie_table->count; i++) {\r\nif (pcie_speed != pcie_table->dpm_levels[i].value)\r\ncontinue;\r\nbreak;\r\n}\r\nnow = i;\r\nfor (i = 0; i < pcie_table->count; i++)\r\nsize += sprintf(buf + size, "%d: %s %s\n", i,\r\n(pcie_table->dpm_levels[i].value == 0) ? "2.5GB, x1" :\r\n(pcie_table->dpm_levels[i].value == 1) ? "5.0GB, x16" :\r\n(pcie_table->dpm_levels[i].value == 2) ? "8.0GB, x16" : "",\r\n(i == now) ? "*" : "");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn size;\r\n}\r\nstatic int ci_dpm_force_clock_level(struct amdgpu_device *adev,\r\nenum pp_clock_type type, uint32_t mask)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nif (adev->pm.dpm.forced_level & (AMD_DPM_FORCED_LEVEL_AUTO |\r\nAMD_DPM_FORCED_LEVEL_LOW |\r\nAMD_DPM_FORCED_LEVEL_HIGH))\r\nreturn -EINVAL;\r\nswitch (type) {\r\ncase PP_SCLK:\r\nif (!pi->sclk_dpm_key_disabled)\r\namdgpu_ci_send_msg_to_smc_with_parameter(adev,\r\nPPSMC_MSG_SCLKDPM_SetEnabledMask,\r\npi->dpm_level_enable_mask.sclk_dpm_enable_mask & mask);\r\nbreak;\r\ncase PP_MCLK:\r\nif (!pi->mclk_dpm_key_disabled)\r\namdgpu_ci_send_msg_to_smc_with_parameter(adev,\r\nPPSMC_MSG_MCLKDPM_SetEnabledMask,\r\npi->dpm_level_enable_mask.mclk_dpm_enable_mask & mask);\r\nbreak;\r\ncase PP_PCIE:\r\n{\r\nuint32_t tmp = mask & pi->dpm_level_enable_mask.pcie_dpm_enable_mask;\r\nuint32_t level = 0;\r\nwhile (tmp >>= 1)\r\nlevel++;\r\nif (!pi->pcie_dpm_key_disabled)\r\namdgpu_ci_send_msg_to_smc_with_parameter(adev,\r\nPPSMC_MSG_PCIeDPM_ForceLevel,\r\nlevel);\r\nbreak;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ci_dpm_get_sclk_od(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nstruct ci_single_dpm_table *sclk_table = &(pi->dpm_table.sclk_table);\r\nstruct ci_single_dpm_table *golden_sclk_table =\r\n&(pi->golden_dpm_table.sclk_table);\r\nint value;\r\nvalue = (sclk_table->dpm_levels[sclk_table->count - 1].value -\r\ngolden_sclk_table->dpm_levels[golden_sclk_table->count - 1].value) *\r\n100 /\r\ngolden_sclk_table->dpm_levels[golden_sclk_table->count - 1].value;\r\nreturn value;\r\n}\r\nstatic int ci_dpm_set_sclk_od(struct amdgpu_device *adev, uint32_t value)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nstruct ci_ps *ps = ci_get_ps(adev->pm.dpm.requested_ps);\r\nstruct ci_single_dpm_table *golden_sclk_table =\r\n&(pi->golden_dpm_table.sclk_table);\r\nif (value > 20)\r\nvalue = 20;\r\nps->performance_levels[ps->performance_level_count - 1].sclk =\r\ngolden_sclk_table->dpm_levels[golden_sclk_table->count - 1].value *\r\nvalue / 100 +\r\ngolden_sclk_table->dpm_levels[golden_sclk_table->count - 1].value;\r\nreturn 0;\r\n}\r\nstatic int ci_dpm_get_mclk_od(struct amdgpu_device *adev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nstruct ci_single_dpm_table *mclk_table = &(pi->dpm_table.mclk_table);\r\nstruct ci_single_dpm_table *golden_mclk_table =\r\n&(pi->golden_dpm_table.mclk_table);\r\nint value;\r\nvalue = (mclk_table->dpm_levels[mclk_table->count - 1].value -\r\ngolden_mclk_table->dpm_levels[golden_mclk_table->count - 1].value) *\r\n100 /\r\ngolden_mclk_table->dpm_levels[golden_mclk_table->count - 1].value;\r\nreturn value;\r\n}\r\nstatic int ci_dpm_set_mclk_od(struct amdgpu_device *adev, uint32_t value)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nstruct ci_ps *ps = ci_get_ps(adev->pm.dpm.requested_ps);\r\nstruct ci_single_dpm_table *golden_mclk_table =\r\n&(pi->golden_dpm_table.mclk_table);\r\nif (value > 20)\r\nvalue = 20;\r\nps->performance_levels[ps->performance_level_count - 1].mclk =\r\ngolden_mclk_table->dpm_levels[golden_mclk_table->count - 1].value *\r\nvalue / 100 +\r\ngolden_mclk_table->dpm_levels[golden_mclk_table->count - 1].value;\r\nreturn 0;\r\n}\r\nstatic int ci_dpm_get_power_profile_state(struct amdgpu_device *adev,\r\nstruct amd_pp_profile *query)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nif (!pi || !query)\r\nreturn -EINVAL;\r\nif (query->type == AMD_PP_GFX_PROFILE)\r\nmemcpy(query, &pi->gfx_power_profile,\r\nsizeof(struct amd_pp_profile));\r\nelse if (query->type == AMD_PP_COMPUTE_PROFILE)\r\nmemcpy(query, &pi->compute_power_profile,\r\nsizeof(struct amd_pp_profile));\r\nelse\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int ci_populate_requested_graphic_levels(struct amdgpu_device *adev,\r\nstruct amd_pp_profile *request)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nstruct ci_dpm_table *dpm_table = &(pi->dpm_table);\r\nstruct SMU7_Discrete_GraphicsLevel *levels =\r\npi->smc_state_table.GraphicsLevel;\r\nuint32_t array = pi->dpm_table_start +\r\noffsetof(SMU7_Discrete_DpmTable, GraphicsLevel);\r\nuint32_t array_size = sizeof(struct SMU7_Discrete_GraphicsLevel) *\r\nSMU7_MAX_LEVELS_GRAPHICS;\r\nuint32_t i;\r\nfor (i = 0; i < dpm_table->sclk_table.count; i++) {\r\nlevels[i].ActivityLevel =\r\ncpu_to_be16(request->activity_threshold);\r\nlevels[i].EnabledForActivity = 1;\r\nlevels[i].UpH = request->up_hyst;\r\nlevels[i].DownH = request->down_hyst;\r\n}\r\nreturn amdgpu_ci_copy_bytes_to_smc(adev, array, (uint8_t *)levels,\r\narray_size, pi->sram_end);\r\n}\r\nstatic void ci_find_min_clock_masks(struct amdgpu_device *adev,\r\nuint32_t *sclk_mask, uint32_t *mclk_mask,\r\nuint32_t min_sclk, uint32_t min_mclk)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nstruct ci_dpm_table *dpm_table = &(pi->dpm_table);\r\nuint32_t i;\r\nfor (i = 0; i < dpm_table->sclk_table.count; i++) {\r\nif (dpm_table->sclk_table.dpm_levels[i].enabled &&\r\ndpm_table->sclk_table.dpm_levels[i].value >= min_sclk)\r\n*sclk_mask |= 1 << i;\r\n}\r\nfor (i = 0; i < dpm_table->mclk_table.count; i++) {\r\nif (dpm_table->mclk_table.dpm_levels[i].enabled &&\r\ndpm_table->mclk_table.dpm_levels[i].value >= min_mclk)\r\n*mclk_mask |= 1 << i;\r\n}\r\n}\r\nstatic int ci_set_power_profile_state(struct amdgpu_device *adev,\r\nstruct amd_pp_profile *request)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nint tmp_result, result = 0;\r\nuint32_t sclk_mask = 0, mclk_mask = 0;\r\ntmp_result = ci_freeze_sclk_mclk_dpm(adev);\r\nif (tmp_result) {\r\nDRM_ERROR("Failed to freeze SCLK MCLK DPM!");\r\nresult = tmp_result;\r\n}\r\ntmp_result = ci_populate_requested_graphic_levels(adev,\r\nrequest);\r\nif (tmp_result) {\r\nDRM_ERROR("Failed to populate requested graphic levels!");\r\nresult = tmp_result;\r\n}\r\ntmp_result = ci_unfreeze_sclk_mclk_dpm(adev);\r\nif (tmp_result) {\r\nDRM_ERROR("Failed to unfreeze SCLK MCLK DPM!");\r\nresult = tmp_result;\r\n}\r\nci_find_min_clock_masks(adev, &sclk_mask, &mclk_mask,\r\nrequest->min_sclk, request->min_mclk);\r\nif (sclk_mask) {\r\nif (!pi->sclk_dpm_key_disabled)\r\namdgpu_ci_send_msg_to_smc_with_parameter(\r\nadev,\r\nPPSMC_MSG_SCLKDPM_SetEnabledMask,\r\npi->dpm_level_enable_mask.\r\nsclk_dpm_enable_mask &\r\nsclk_mask);\r\n}\r\nif (mclk_mask) {\r\nif (!pi->mclk_dpm_key_disabled)\r\namdgpu_ci_send_msg_to_smc_with_parameter(\r\nadev,\r\nPPSMC_MSG_MCLKDPM_SetEnabledMask,\r\npi->dpm_level_enable_mask.\r\nmclk_dpm_enable_mask &\r\nmclk_mask);\r\n}\r\nreturn result;\r\n}\r\nstatic int ci_dpm_set_power_profile_state(struct amdgpu_device *adev,\r\nstruct amd_pp_profile *request)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nint ret = -1;\r\nif (!pi || !request)\r\nreturn -EINVAL;\r\nif (adev->pm.dpm.forced_level !=\r\nAMD_DPM_FORCED_LEVEL_AUTO)\r\nreturn -EINVAL;\r\nif (request->min_sclk ||\r\nrequest->min_mclk ||\r\nrequest->activity_threshold ||\r\nrequest->up_hyst ||\r\nrequest->down_hyst) {\r\nif (request->type == AMD_PP_GFX_PROFILE)\r\nmemcpy(&pi->gfx_power_profile, request,\r\nsizeof(struct amd_pp_profile));\r\nelse if (request->type == AMD_PP_COMPUTE_PROFILE)\r\nmemcpy(&pi->compute_power_profile, request,\r\nsizeof(struct amd_pp_profile));\r\nelse\r\nreturn -EINVAL;\r\nif (request->type == pi->current_power_profile)\r\nret = ci_set_power_profile_state(\r\nadev,\r\nrequest);\r\n} else {\r\nswitch (request->type) {\r\ncase AMD_PP_GFX_PROFILE:\r\nret = ci_set_power_profile_state(\r\nadev,\r\n&pi->gfx_power_profile);\r\nbreak;\r\ncase AMD_PP_COMPUTE_PROFILE:\r\nret = ci_set_power_profile_state(\r\nadev,\r\n&pi->compute_power_profile);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (!ret)\r\npi->current_power_profile = request->type;\r\nreturn 0;\r\n}\r\nstatic int ci_dpm_reset_power_profile_state(struct amdgpu_device *adev,\r\nstruct amd_pp_profile *request)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nif (!pi || !request)\r\nreturn -EINVAL;\r\nif (request->type == AMD_PP_GFX_PROFILE) {\r\npi->gfx_power_profile = pi->default_gfx_power_profile;\r\nreturn ci_dpm_set_power_profile_state(adev,\r\n&pi->gfx_power_profile);\r\n} else if (request->type == AMD_PP_COMPUTE_PROFILE) {\r\npi->compute_power_profile =\r\npi->default_compute_power_profile;\r\nreturn ci_dpm_set_power_profile_state(adev,\r\n&pi->compute_power_profile);\r\n} else\r\nreturn -EINVAL;\r\n}\r\nstatic int ci_dpm_switch_power_profile(struct amdgpu_device *adev,\r\nenum amd_pp_profile_type type)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(adev);\r\nstruct amd_pp_profile request = {0};\r\nif (!pi)\r\nreturn -EINVAL;\r\nif (pi->current_power_profile != type) {\r\nrequest.type = type;\r\nreturn ci_dpm_set_power_profile_state(adev, &request);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ci_dpm_read_sensor(struct amdgpu_device *adev, int idx,\r\nvoid *value, int *size)\r\n{\r\nu32 activity_percent = 50;\r\nint ret;\r\nif (*size < 4)\r\nreturn -EINVAL;\r\nswitch (idx) {\r\ncase AMDGPU_PP_SENSOR_GFX_SCLK:\r\n*((uint32_t *)value) = ci_get_average_sclk_freq(adev);\r\n*size = 4;\r\nreturn 0;\r\ncase AMDGPU_PP_SENSOR_GFX_MCLK:\r\n*((uint32_t *)value) = ci_get_average_mclk_freq(adev);\r\n*size = 4;\r\nreturn 0;\r\ncase AMDGPU_PP_SENSOR_GPU_TEMP:\r\n*((uint32_t *)value) = ci_dpm_get_temp(adev);\r\n*size = 4;\r\nreturn 0;\r\ncase AMDGPU_PP_SENSOR_GPU_LOAD:\r\nret = ci_read_smc_soft_register(adev,\r\noffsetof(SMU7_SoftRegisters,\r\nAverageGraphicsA),\r\n&activity_percent);\r\nif (ret == 0) {\r\nactivity_percent += 0x80;\r\nactivity_percent >>= 8;\r\nactivity_percent =\r\nactivity_percent > 100 ? 100 : activity_percent;\r\n}\r\n*((uint32_t *)value) = activity_percent;\r\n*size = 4;\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic void ci_dpm_set_dpm_funcs(struct amdgpu_device *adev)\r\n{\r\nif (adev->pm.funcs == NULL)\r\nadev->pm.funcs = &ci_dpm_funcs;\r\n}\r\nstatic void ci_dpm_set_irq_funcs(struct amdgpu_device *adev)\r\n{\r\nadev->pm.dpm.thermal.irq.num_types = AMDGPU_THERMAL_IRQ_LAST;\r\nadev->pm.dpm.thermal.irq.funcs = &ci_dpm_irq_funcs;\r\n}
