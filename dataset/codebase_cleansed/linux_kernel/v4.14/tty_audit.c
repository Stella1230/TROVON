static struct tty_audit_buf *tty_audit_buf_ref(void)\r\n{\r\nstruct tty_audit_buf *buf;\r\nbuf = current->signal->tty_audit_buf;\r\nWARN_ON(buf == ERR_PTR(-ESRCH));\r\nreturn buf;\r\n}\r\nstatic struct tty_audit_buf *tty_audit_buf_alloc(void)\r\n{\r\nstruct tty_audit_buf *buf;\r\nbuf = kmalloc(sizeof(*buf), GFP_KERNEL);\r\nif (!buf)\r\ngoto err;\r\nbuf->data = kmalloc(N_TTY_BUF_SIZE, GFP_KERNEL);\r\nif (!buf->data)\r\ngoto err_buf;\r\nmutex_init(&buf->mutex);\r\nbuf->dev = MKDEV(0, 0);\r\nbuf->icanon = 0;\r\nbuf->valid = 0;\r\nreturn buf;\r\nerr_buf:\r\nkfree(buf);\r\nerr:\r\nreturn NULL;\r\n}\r\nstatic void tty_audit_buf_free(struct tty_audit_buf *buf)\r\n{\r\nWARN_ON(buf->valid != 0);\r\nkfree(buf->data);\r\nkfree(buf);\r\n}\r\nstatic void tty_audit_log(const char *description, dev_t dev,\r\nunsigned char *data, size_t size)\r\n{\r\nstruct audit_buffer *ab;\r\nstruct task_struct *tsk = current;\r\npid_t pid = task_pid_nr(tsk);\r\nuid_t uid = from_kuid(&init_user_ns, task_uid(tsk));\r\nuid_t loginuid = from_kuid(&init_user_ns, audit_get_loginuid(tsk));\r\nunsigned int sessionid = audit_get_sessionid(tsk);\r\nab = audit_log_start(NULL, GFP_KERNEL, AUDIT_TTY);\r\nif (ab) {\r\nchar name[sizeof(tsk->comm)];\r\naudit_log_format(ab, "%s pid=%u uid=%u auid=%u ses=%u major=%d"\r\n" minor=%d comm=", description, pid, uid,\r\nloginuid, sessionid, MAJOR(dev), MINOR(dev));\r\nget_task_comm(name, tsk);\r\naudit_log_untrustedstring(ab, name);\r\naudit_log_format(ab, " data=");\r\naudit_log_n_hex(ab, data, size);\r\naudit_log_end(ab);\r\n}\r\n}\r\nstatic void tty_audit_buf_push(struct tty_audit_buf *buf)\r\n{\r\nif (buf->valid == 0)\r\nreturn;\r\nif (audit_enabled == 0) {\r\nbuf->valid = 0;\r\nreturn;\r\n}\r\ntty_audit_log("tty", buf->dev, buf->data, buf->valid);\r\nbuf->valid = 0;\r\n}\r\nvoid tty_audit_exit(void)\r\n{\r\nstruct tty_audit_buf *buf;\r\nbuf = xchg(&current->signal->tty_audit_buf, ERR_PTR(-ESRCH));\r\nif (!buf)\r\nreturn;\r\ntty_audit_buf_push(buf);\r\ntty_audit_buf_free(buf);\r\n}\r\nvoid tty_audit_fork(struct signal_struct *sig)\r\n{\r\nsig->audit_tty = current->signal->audit_tty;\r\n}\r\nvoid tty_audit_tiocsti(struct tty_struct *tty, char ch)\r\n{\r\ndev_t dev;\r\ndev = MKDEV(tty->driver->major, tty->driver->minor_start) + tty->index;\r\nif (tty_audit_push())\r\nreturn;\r\nif (audit_enabled)\r\ntty_audit_log("ioctl=TIOCSTI", dev, &ch, 1);\r\n}\r\nint tty_audit_push(void)\r\n{\r\nstruct tty_audit_buf *buf;\r\nif (~current->signal->audit_tty & AUDIT_TTY_ENABLE)\r\nreturn -EPERM;\r\nbuf = tty_audit_buf_ref();\r\nif (!IS_ERR_OR_NULL(buf)) {\r\nmutex_lock(&buf->mutex);\r\ntty_audit_buf_push(buf);\r\nmutex_unlock(&buf->mutex);\r\n}\r\nreturn 0;\r\n}\r\nstatic struct tty_audit_buf *tty_audit_buf_get(void)\r\n{\r\nstruct tty_audit_buf *buf;\r\nbuf = tty_audit_buf_ref();\r\nif (buf)\r\nreturn buf;\r\nbuf = tty_audit_buf_alloc();\r\nif (buf == NULL) {\r\naudit_log_lost("out of memory in TTY auditing");\r\nreturn NULL;\r\n}\r\nif (cmpxchg(&current->signal->tty_audit_buf, NULL, buf) != NULL)\r\ntty_audit_buf_free(buf);\r\nreturn tty_audit_buf_ref();\r\n}\r\nvoid tty_audit_add_data(struct tty_struct *tty, const void *data, size_t size)\r\n{\r\nstruct tty_audit_buf *buf;\r\nunsigned int icanon = !!L_ICANON(tty);\r\nunsigned int audit_tty;\r\ndev_t dev;\r\naudit_tty = READ_ONCE(current->signal->audit_tty);\r\nif (~audit_tty & AUDIT_TTY_ENABLE)\r\nreturn;\r\nif (unlikely(size == 0))\r\nreturn;\r\nif (tty->driver->type == TTY_DRIVER_TYPE_PTY\r\n&& tty->driver->subtype == PTY_TYPE_MASTER)\r\nreturn;\r\nif ((~audit_tty & AUDIT_TTY_LOG_PASSWD) && icanon && !L_ECHO(tty))\r\nreturn;\r\nbuf = tty_audit_buf_get();\r\nif (IS_ERR_OR_NULL(buf))\r\nreturn;\r\nmutex_lock(&buf->mutex);\r\ndev = MKDEV(tty->driver->major, tty->driver->minor_start) + tty->index;\r\nif (buf->dev != dev || buf->icanon != icanon) {\r\ntty_audit_buf_push(buf);\r\nbuf->dev = dev;\r\nbuf->icanon = icanon;\r\n}\r\ndo {\r\nsize_t run;\r\nrun = N_TTY_BUF_SIZE - buf->valid;\r\nif (run > size)\r\nrun = size;\r\nmemcpy(buf->data + buf->valid, data, run);\r\nbuf->valid += run;\r\ndata += run;\r\nsize -= run;\r\nif (buf->valid == N_TTY_BUF_SIZE)\r\ntty_audit_buf_push(buf);\r\n} while (size != 0);\r\nmutex_unlock(&buf->mutex);\r\n}
