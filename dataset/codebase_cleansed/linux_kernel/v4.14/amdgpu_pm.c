void amdgpu_pm_acpi_event_handler(struct amdgpu_device *adev)\r\n{\r\nif (adev->pp_enabled)\r\nreturn;\r\nif (adev->pm.dpm_enabled) {\r\nmutex_lock(&adev->pm.mutex);\r\nif (power_supply_is_system_supplied() > 0)\r\nadev->pm.dpm.ac_power = true;\r\nelse\r\nadev->pm.dpm.ac_power = false;\r\nif (adev->pm.funcs->enable_bapm)\r\namdgpu_dpm_enable_bapm(adev, adev->pm.dpm.ac_power);\r\nmutex_unlock(&adev->pm.mutex);\r\n}\r\n}\r\nstatic ssize_t amdgpu_get_dpm_state(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct drm_device *ddev = dev_get_drvdata(dev);\r\nstruct amdgpu_device *adev = ddev->dev_private;\r\nenum amd_pm_state_type pm;\r\nif (adev->pp_enabled) {\r\npm = amdgpu_dpm_get_current_power_state(adev);\r\n} else\r\npm = adev->pm.dpm.user_state;\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n",\r\n(pm == POWER_STATE_TYPE_BATTERY) ? "battery" :\r\n(pm == POWER_STATE_TYPE_BALANCED) ? "balanced" : "performance");\r\n}\r\nstatic ssize_t amdgpu_set_dpm_state(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct drm_device *ddev = dev_get_drvdata(dev);\r\nstruct amdgpu_device *adev = ddev->dev_private;\r\nenum amd_pm_state_type state;\r\nif (strncmp("battery", buf, strlen("battery")) == 0)\r\nstate = POWER_STATE_TYPE_BATTERY;\r\nelse if (strncmp("balanced", buf, strlen("balanced")) == 0)\r\nstate = POWER_STATE_TYPE_BALANCED;\r\nelse if (strncmp("performance", buf, strlen("performance")) == 0)\r\nstate = POWER_STATE_TYPE_PERFORMANCE;\r\nelse {\r\ncount = -EINVAL;\r\ngoto fail;\r\n}\r\nif (adev->pp_enabled) {\r\namdgpu_dpm_dispatch_task(adev, AMD_PP_EVENT_ENABLE_USER_STATE, &state, NULL);\r\n} else {\r\nmutex_lock(&adev->pm.mutex);\r\nadev->pm.dpm.user_state = state;\r\nmutex_unlock(&adev->pm.mutex);\r\nif (!(adev->flags & AMD_IS_PX) ||\r\n(ddev->switch_power_state == DRM_SWITCH_POWER_ON))\r\namdgpu_pm_compute_clocks(adev);\r\n}\r\nfail:\r\nreturn count;\r\n}\r\nstatic ssize_t amdgpu_get_dpm_forced_performance_level(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct drm_device *ddev = dev_get_drvdata(dev);\r\nstruct amdgpu_device *adev = ddev->dev_private;\r\nenum amd_dpm_forced_level level;\r\nif ((adev->flags & AMD_IS_PX) &&\r\n(ddev->switch_power_state != DRM_SWITCH_POWER_ON))\r\nreturn snprintf(buf, PAGE_SIZE, "off\n");\r\nlevel = amdgpu_dpm_get_performance_level(adev);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n",\r\n(level == AMD_DPM_FORCED_LEVEL_AUTO) ? "auto" :\r\n(level == AMD_DPM_FORCED_LEVEL_LOW) ? "low" :\r\n(level == AMD_DPM_FORCED_LEVEL_HIGH) ? "high" :\r\n(level == AMD_DPM_FORCED_LEVEL_MANUAL) ? "manual" :\r\n(level == AMD_DPM_FORCED_LEVEL_PROFILE_STANDARD) ? "profile_standard" :\r\n(level == AMD_DPM_FORCED_LEVEL_PROFILE_MIN_SCLK) ? "profile_min_sclk" :\r\n(level == AMD_DPM_FORCED_LEVEL_PROFILE_MIN_MCLK) ? "profile_min_mclk" :\r\n(level == AMD_DPM_FORCED_LEVEL_PROFILE_PEAK) ? "profile_peak" :\r\n"unknown");\r\n}\r\nstatic ssize_t amdgpu_set_dpm_forced_performance_level(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct drm_device *ddev = dev_get_drvdata(dev);\r\nstruct amdgpu_device *adev = ddev->dev_private;\r\nenum amd_dpm_forced_level level;\r\nenum amd_dpm_forced_level current_level;\r\nint ret = 0;\r\nif ((adev->flags & AMD_IS_PX) &&\r\n(ddev->switch_power_state != DRM_SWITCH_POWER_ON))\r\nreturn -EINVAL;\r\ncurrent_level = amdgpu_dpm_get_performance_level(adev);\r\nif (strncmp("low", buf, strlen("low")) == 0) {\r\nlevel = AMD_DPM_FORCED_LEVEL_LOW;\r\n} else if (strncmp("high", buf, strlen("high")) == 0) {\r\nlevel = AMD_DPM_FORCED_LEVEL_HIGH;\r\n} else if (strncmp("auto", buf, strlen("auto")) == 0) {\r\nlevel = AMD_DPM_FORCED_LEVEL_AUTO;\r\n} else if (strncmp("manual", buf, strlen("manual")) == 0) {\r\nlevel = AMD_DPM_FORCED_LEVEL_MANUAL;\r\n} else if (strncmp("profile_exit", buf, strlen("profile_exit")) == 0) {\r\nlevel = AMD_DPM_FORCED_LEVEL_PROFILE_EXIT;\r\n} else if (strncmp("profile_standard", buf, strlen("profile_standard")) == 0) {\r\nlevel = AMD_DPM_FORCED_LEVEL_PROFILE_STANDARD;\r\n} else if (strncmp("profile_min_sclk", buf, strlen("profile_min_sclk")) == 0) {\r\nlevel = AMD_DPM_FORCED_LEVEL_PROFILE_MIN_SCLK;\r\n} else if (strncmp("profile_min_mclk", buf, strlen("profile_min_mclk")) == 0) {\r\nlevel = AMD_DPM_FORCED_LEVEL_PROFILE_MIN_MCLK;\r\n} else if (strncmp("profile_peak", buf, strlen("profile_peak")) == 0) {\r\nlevel = AMD_DPM_FORCED_LEVEL_PROFILE_PEAK;\r\n} else {\r\ncount = -EINVAL;\r\ngoto fail;\r\n}\r\nif (current_level == level)\r\nreturn count;\r\nif (adev->pp_enabled)\r\namdgpu_dpm_force_performance_level(adev, level);\r\nelse {\r\nmutex_lock(&adev->pm.mutex);\r\nif (adev->pm.dpm.thermal_active) {\r\ncount = -EINVAL;\r\nmutex_unlock(&adev->pm.mutex);\r\ngoto fail;\r\n}\r\nret = amdgpu_dpm_force_performance_level(adev, level);\r\nif (ret)\r\ncount = -EINVAL;\r\nelse\r\nadev->pm.dpm.forced_level = level;\r\nmutex_unlock(&adev->pm.mutex);\r\n}\r\nfail:\r\nreturn count;\r\n}\r\nstatic ssize_t amdgpu_get_pp_num_states(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct drm_device *ddev = dev_get_drvdata(dev);\r\nstruct amdgpu_device *adev = ddev->dev_private;\r\nstruct pp_states_info data;\r\nint i, buf_len;\r\nif (adev->pp_enabled)\r\namdgpu_dpm_get_pp_num_states(adev, &data);\r\nbuf_len = snprintf(buf, PAGE_SIZE, "states: %d\n", data.nums);\r\nfor (i = 0; i < data.nums; i++)\r\nbuf_len += snprintf(buf + buf_len, PAGE_SIZE, "%d %s\n", i,\r\n(data.states[i] == POWER_STATE_TYPE_INTERNAL_BOOT) ? "boot" :\r\n(data.states[i] == POWER_STATE_TYPE_BATTERY) ? "battery" :\r\n(data.states[i] == POWER_STATE_TYPE_BALANCED) ? "balanced" :\r\n(data.states[i] == POWER_STATE_TYPE_PERFORMANCE) ? "performance" : "default");\r\nreturn buf_len;\r\n}\r\nstatic ssize_t amdgpu_get_pp_cur_state(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct drm_device *ddev = dev_get_drvdata(dev);\r\nstruct amdgpu_device *adev = ddev->dev_private;\r\nstruct pp_states_info data;\r\nenum amd_pm_state_type pm = 0;\r\nint i = 0;\r\nif (adev->pp_enabled) {\r\npm = amdgpu_dpm_get_current_power_state(adev);\r\namdgpu_dpm_get_pp_num_states(adev, &data);\r\nfor (i = 0; i < data.nums; i++) {\r\nif (pm == data.states[i])\r\nbreak;\r\n}\r\nif (i == data.nums)\r\ni = -EINVAL;\r\n}\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", i);\r\n}\r\nstatic ssize_t amdgpu_get_pp_force_state(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct drm_device *ddev = dev_get_drvdata(dev);\r\nstruct amdgpu_device *adev = ddev->dev_private;\r\nstruct pp_states_info data;\r\nenum amd_pm_state_type pm = 0;\r\nint i;\r\nif (adev->pp_force_state_enabled && adev->pp_enabled) {\r\npm = amdgpu_dpm_get_current_power_state(adev);\r\namdgpu_dpm_get_pp_num_states(adev, &data);\r\nfor (i = 0; i < data.nums; i++) {\r\nif (pm == data.states[i])\r\nbreak;\r\n}\r\nif (i == data.nums)\r\ni = -EINVAL;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", i);\r\n} else\r\nreturn snprintf(buf, PAGE_SIZE, "\n");\r\n}\r\nstatic ssize_t amdgpu_set_pp_force_state(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct drm_device *ddev = dev_get_drvdata(dev);\r\nstruct amdgpu_device *adev = ddev->dev_private;\r\nenum amd_pm_state_type state = 0;\r\nunsigned long idx;\r\nint ret;\r\nif (strlen(buf) == 1)\r\nadev->pp_force_state_enabled = false;\r\nelse if (adev->pp_enabled) {\r\nstruct pp_states_info data;\r\nret = kstrtoul(buf, 0, &idx);\r\nif (ret || idx >= ARRAY_SIZE(data.states)) {\r\ncount = -EINVAL;\r\ngoto fail;\r\n}\r\namdgpu_dpm_get_pp_num_states(adev, &data);\r\nstate = data.states[idx];\r\nif (state != POWER_STATE_TYPE_INTERNAL_BOOT &&\r\nstate != POWER_STATE_TYPE_DEFAULT) {\r\namdgpu_dpm_dispatch_task(adev,\r\nAMD_PP_EVENT_ENABLE_USER_STATE, &state, NULL);\r\nadev->pp_force_state_enabled = true;\r\n}\r\n}\r\nfail:\r\nreturn count;\r\n}\r\nstatic ssize_t amdgpu_get_pp_table(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct drm_device *ddev = dev_get_drvdata(dev);\r\nstruct amdgpu_device *adev = ddev->dev_private;\r\nchar *table = NULL;\r\nint size;\r\nif (adev->pp_enabled)\r\nsize = amdgpu_dpm_get_pp_table(adev, &table);\r\nelse\r\nreturn 0;\r\nif (size >= PAGE_SIZE)\r\nsize = PAGE_SIZE - 1;\r\nmemcpy(buf, table, size);\r\nreturn size;\r\n}\r\nstatic ssize_t amdgpu_set_pp_table(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct drm_device *ddev = dev_get_drvdata(dev);\r\nstruct amdgpu_device *adev = ddev->dev_private;\r\nif (adev->pp_enabled)\r\namdgpu_dpm_set_pp_table(adev, buf, count);\r\nreturn count;\r\n}\r\nstatic ssize_t amdgpu_get_pp_dpm_sclk(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct drm_device *ddev = dev_get_drvdata(dev);\r\nstruct amdgpu_device *adev = ddev->dev_private;\r\nssize_t size = 0;\r\nif (adev->pp_enabled)\r\nsize = amdgpu_dpm_print_clock_levels(adev, PP_SCLK, buf);\r\nelse if (adev->pm.funcs->print_clock_levels)\r\nsize = adev->pm.funcs->print_clock_levels(adev, PP_SCLK, buf);\r\nreturn size;\r\n}\r\nstatic ssize_t amdgpu_set_pp_dpm_sclk(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct drm_device *ddev = dev_get_drvdata(dev);\r\nstruct amdgpu_device *adev = ddev->dev_private;\r\nint ret;\r\nlong level;\r\nuint32_t i, mask = 0;\r\nchar sub_str[2];\r\nfor (i = 0; i < strlen(buf); i++) {\r\nif (*(buf + i) == '\n')\r\ncontinue;\r\nsub_str[0] = *(buf + i);\r\nsub_str[1] = '\0';\r\nret = kstrtol(sub_str, 0, &level);\r\nif (ret) {\r\ncount = -EINVAL;\r\ngoto fail;\r\n}\r\nmask |= 1 << level;\r\n}\r\nif (adev->pp_enabled)\r\namdgpu_dpm_force_clock_level(adev, PP_SCLK, mask);\r\nelse if (adev->pm.funcs->force_clock_level)\r\nadev->pm.funcs->force_clock_level(adev, PP_SCLK, mask);\r\nfail:\r\nreturn count;\r\n}\r\nstatic ssize_t amdgpu_get_pp_dpm_mclk(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct drm_device *ddev = dev_get_drvdata(dev);\r\nstruct amdgpu_device *adev = ddev->dev_private;\r\nssize_t size = 0;\r\nif (adev->pp_enabled)\r\nsize = amdgpu_dpm_print_clock_levels(adev, PP_MCLK, buf);\r\nelse if (adev->pm.funcs->print_clock_levels)\r\nsize = adev->pm.funcs->print_clock_levels(adev, PP_MCLK, buf);\r\nreturn size;\r\n}\r\nstatic ssize_t amdgpu_set_pp_dpm_mclk(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct drm_device *ddev = dev_get_drvdata(dev);\r\nstruct amdgpu_device *adev = ddev->dev_private;\r\nint ret;\r\nlong level;\r\nuint32_t i, mask = 0;\r\nchar sub_str[2];\r\nfor (i = 0; i < strlen(buf); i++) {\r\nif (*(buf + i) == '\n')\r\ncontinue;\r\nsub_str[0] = *(buf + i);\r\nsub_str[1] = '\0';\r\nret = kstrtol(sub_str, 0, &level);\r\nif (ret) {\r\ncount = -EINVAL;\r\ngoto fail;\r\n}\r\nmask |= 1 << level;\r\n}\r\nif (adev->pp_enabled)\r\namdgpu_dpm_force_clock_level(adev, PP_MCLK, mask);\r\nelse if (adev->pm.funcs->force_clock_level)\r\nadev->pm.funcs->force_clock_level(adev, PP_MCLK, mask);\r\nfail:\r\nreturn count;\r\n}\r\nstatic ssize_t amdgpu_get_pp_dpm_pcie(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct drm_device *ddev = dev_get_drvdata(dev);\r\nstruct amdgpu_device *adev = ddev->dev_private;\r\nssize_t size = 0;\r\nif (adev->pp_enabled)\r\nsize = amdgpu_dpm_print_clock_levels(adev, PP_PCIE, buf);\r\nelse if (adev->pm.funcs->print_clock_levels)\r\nsize = adev->pm.funcs->print_clock_levels(adev, PP_PCIE, buf);\r\nreturn size;\r\n}\r\nstatic ssize_t amdgpu_set_pp_dpm_pcie(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct drm_device *ddev = dev_get_drvdata(dev);\r\nstruct amdgpu_device *adev = ddev->dev_private;\r\nint ret;\r\nlong level;\r\nuint32_t i, mask = 0;\r\nchar sub_str[2];\r\nfor (i = 0; i < strlen(buf); i++) {\r\nif (*(buf + i) == '\n')\r\ncontinue;\r\nsub_str[0] = *(buf + i);\r\nsub_str[1] = '\0';\r\nret = kstrtol(sub_str, 0, &level);\r\nif (ret) {\r\ncount = -EINVAL;\r\ngoto fail;\r\n}\r\nmask |= 1 << level;\r\n}\r\nif (adev->pp_enabled)\r\namdgpu_dpm_force_clock_level(adev, PP_PCIE, mask);\r\nelse if (adev->pm.funcs->force_clock_level)\r\nadev->pm.funcs->force_clock_level(adev, PP_PCIE, mask);\r\nfail:\r\nreturn count;\r\n}\r\nstatic ssize_t amdgpu_get_pp_sclk_od(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct drm_device *ddev = dev_get_drvdata(dev);\r\nstruct amdgpu_device *adev = ddev->dev_private;\r\nuint32_t value = 0;\r\nif (adev->pp_enabled)\r\nvalue = amdgpu_dpm_get_sclk_od(adev);\r\nelse if (adev->pm.funcs->get_sclk_od)\r\nvalue = adev->pm.funcs->get_sclk_od(adev);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", value);\r\n}\r\nstatic ssize_t amdgpu_set_pp_sclk_od(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct drm_device *ddev = dev_get_drvdata(dev);\r\nstruct amdgpu_device *adev = ddev->dev_private;\r\nint ret;\r\nlong int value;\r\nret = kstrtol(buf, 0, &value);\r\nif (ret) {\r\ncount = -EINVAL;\r\ngoto fail;\r\n}\r\nif (adev->pp_enabled) {\r\namdgpu_dpm_set_sclk_od(adev, (uint32_t)value);\r\namdgpu_dpm_dispatch_task(adev, AMD_PP_EVENT_READJUST_POWER_STATE, NULL, NULL);\r\n} else if (adev->pm.funcs->set_sclk_od) {\r\nadev->pm.funcs->set_sclk_od(adev, (uint32_t)value);\r\nadev->pm.dpm.current_ps = adev->pm.dpm.boot_ps;\r\namdgpu_pm_compute_clocks(adev);\r\n}\r\nfail:\r\nreturn count;\r\n}\r\nstatic ssize_t amdgpu_get_pp_mclk_od(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct drm_device *ddev = dev_get_drvdata(dev);\r\nstruct amdgpu_device *adev = ddev->dev_private;\r\nuint32_t value = 0;\r\nif (adev->pp_enabled)\r\nvalue = amdgpu_dpm_get_mclk_od(adev);\r\nelse if (adev->pm.funcs->get_mclk_od)\r\nvalue = adev->pm.funcs->get_mclk_od(adev);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", value);\r\n}\r\nstatic ssize_t amdgpu_set_pp_mclk_od(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct drm_device *ddev = dev_get_drvdata(dev);\r\nstruct amdgpu_device *adev = ddev->dev_private;\r\nint ret;\r\nlong int value;\r\nret = kstrtol(buf, 0, &value);\r\nif (ret) {\r\ncount = -EINVAL;\r\ngoto fail;\r\n}\r\nif (adev->pp_enabled) {\r\namdgpu_dpm_set_mclk_od(adev, (uint32_t)value);\r\namdgpu_dpm_dispatch_task(adev, AMD_PP_EVENT_READJUST_POWER_STATE, NULL, NULL);\r\n} else if (adev->pm.funcs->set_mclk_od) {\r\nadev->pm.funcs->set_mclk_od(adev, (uint32_t)value);\r\nadev->pm.dpm.current_ps = adev->pm.dpm.boot_ps;\r\namdgpu_pm_compute_clocks(adev);\r\n}\r\nfail:\r\nreturn count;\r\n}\r\nstatic ssize_t amdgpu_get_pp_power_profile(struct device *dev,\r\nchar *buf, struct amd_pp_profile *query)\r\n{\r\nstruct drm_device *ddev = dev_get_drvdata(dev);\r\nstruct amdgpu_device *adev = ddev->dev_private;\r\nint ret = 0;\r\nif (adev->pp_enabled)\r\nret = amdgpu_dpm_get_power_profile_state(\r\nadev, query);\r\nelse if (adev->pm.funcs->get_power_profile_state)\r\nret = adev->pm.funcs->get_power_profile_state(\r\nadev, query);\r\nif (ret)\r\nreturn ret;\r\nreturn snprintf(buf, PAGE_SIZE,\r\n"%d %d %d %d %d\n",\r\nquery->min_sclk / 100,\r\nquery->min_mclk / 100,\r\nquery->activity_threshold,\r\nquery->up_hyst,\r\nquery->down_hyst);\r\n}\r\nstatic ssize_t amdgpu_get_pp_gfx_power_profile(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct amd_pp_profile query = {0};\r\nquery.type = AMD_PP_GFX_PROFILE;\r\nreturn amdgpu_get_pp_power_profile(dev, buf, &query);\r\n}\r\nstatic ssize_t amdgpu_get_pp_compute_power_profile(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct amd_pp_profile query = {0};\r\nquery.type = AMD_PP_COMPUTE_PROFILE;\r\nreturn amdgpu_get_pp_power_profile(dev, buf, &query);\r\n}\r\nstatic ssize_t amdgpu_set_pp_power_profile(struct device *dev,\r\nconst char *buf,\r\nsize_t count,\r\nstruct amd_pp_profile *request)\r\n{\r\nstruct drm_device *ddev = dev_get_drvdata(dev);\r\nstruct amdgpu_device *adev = ddev->dev_private;\r\nuint32_t loop = 0;\r\nchar *sub_str, buf_cpy[128], *tmp_str;\r\nconst char delimiter[3] = {' ', '\n', '\0'};\r\nlong int value;\r\nint ret = 0;\r\nif (strncmp("reset", buf, strlen("reset")) == 0) {\r\nif (adev->pp_enabled)\r\nret = amdgpu_dpm_reset_power_profile_state(\r\nadev, request);\r\nelse if (adev->pm.funcs->reset_power_profile_state)\r\nret = adev->pm.funcs->reset_power_profile_state(\r\nadev, request);\r\nif (ret) {\r\ncount = -EINVAL;\r\ngoto fail;\r\n}\r\nreturn count;\r\n}\r\nif (strncmp("set", buf, strlen("set")) == 0) {\r\nif (adev->pp_enabled)\r\nret = amdgpu_dpm_set_power_profile_state(\r\nadev, request);\r\nelse if (adev->pm.funcs->set_power_profile_state)\r\nret = adev->pm.funcs->set_power_profile_state(\r\nadev, request);\r\nif (ret) {\r\ncount = -EINVAL;\r\ngoto fail;\r\n}\r\nreturn count;\r\n}\r\nif (count + 1 >= 128) {\r\ncount = -EINVAL;\r\ngoto fail;\r\n}\r\nmemcpy(buf_cpy, buf, count + 1);\r\ntmp_str = buf_cpy;\r\nwhile (tmp_str[0]) {\r\nsub_str = strsep(&tmp_str, delimiter);\r\nret = kstrtol(sub_str, 0, &value);\r\nif (ret) {\r\ncount = -EINVAL;\r\ngoto fail;\r\n}\r\nswitch (loop) {\r\ncase 0:\r\nrequest->min_sclk = (uint32_t)value * 100;\r\nbreak;\r\ncase 1:\r\nrequest->min_mclk = (uint32_t)value * 100;\r\nbreak;\r\ncase 2:\r\nrequest->activity_threshold = (uint16_t)value;\r\nbreak;\r\ncase 3:\r\nrequest->up_hyst = (uint8_t)value;\r\nbreak;\r\ncase 4:\r\nrequest->down_hyst = (uint8_t)value;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nloop++;\r\n}\r\nif (adev->pp_enabled)\r\nret = amdgpu_dpm_set_power_profile_state(\r\nadev, request);\r\nelse if (adev->pm.funcs->set_power_profile_state)\r\nret = adev->pm.funcs->set_power_profile_state(\r\nadev, request);\r\nif (ret)\r\ncount = -EINVAL;\r\nfail:\r\nreturn count;\r\n}\r\nstatic ssize_t amdgpu_set_pp_gfx_power_profile(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct amd_pp_profile request = {0};\r\nrequest.type = AMD_PP_GFX_PROFILE;\r\nreturn amdgpu_set_pp_power_profile(dev, buf, count, &request);\r\n}\r\nstatic ssize_t amdgpu_set_pp_compute_power_profile(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct amd_pp_profile request = {0};\r\nrequest.type = AMD_PP_COMPUTE_PROFILE;\r\nreturn amdgpu_set_pp_power_profile(dev, buf, count, &request);\r\n}\r\nstatic ssize_t amdgpu_hwmon_show_temp(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct amdgpu_device *adev = dev_get_drvdata(dev);\r\nstruct drm_device *ddev = adev->ddev;\r\nint temp;\r\nif ((adev->flags & AMD_IS_PX) &&\r\n(ddev->switch_power_state != DRM_SWITCH_POWER_ON))\r\nreturn -EINVAL;\r\nif (!adev->pp_enabled && !adev->pm.funcs->get_temperature)\r\ntemp = 0;\r\nelse\r\ntemp = amdgpu_dpm_get_temperature(adev);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", temp);\r\n}\r\nstatic ssize_t amdgpu_hwmon_show_temp_thresh(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct amdgpu_device *adev = dev_get_drvdata(dev);\r\nint hyst = to_sensor_dev_attr(attr)->index;\r\nint temp;\r\nif (hyst)\r\ntemp = adev->pm.dpm.thermal.min_temp;\r\nelse\r\ntemp = adev->pm.dpm.thermal.max_temp;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", temp);\r\n}\r\nstatic ssize_t amdgpu_hwmon_get_pwm1_enable(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct amdgpu_device *adev = dev_get_drvdata(dev);\r\nu32 pwm_mode = 0;\r\nif (!adev->pp_enabled && !adev->pm.funcs->get_fan_control_mode)\r\nreturn -EINVAL;\r\npwm_mode = amdgpu_dpm_get_fan_control_mode(adev);\r\nreturn sprintf(buf, "%i\n", pwm_mode);\r\n}\r\nstatic ssize_t amdgpu_hwmon_set_pwm1_enable(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct amdgpu_device *adev = dev_get_drvdata(dev);\r\nint err;\r\nint value;\r\nif (!adev->pp_enabled && !adev->pm.funcs->set_fan_control_mode)\r\nreturn -EINVAL;\r\nerr = kstrtoint(buf, 10, &value);\r\nif (err)\r\nreturn err;\r\namdgpu_dpm_set_fan_control_mode(adev, value);\r\nreturn count;\r\n}\r\nstatic ssize_t amdgpu_hwmon_get_pwm1_min(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "%i\n", 0);\r\n}\r\nstatic ssize_t amdgpu_hwmon_get_pwm1_max(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "%i\n", 255);\r\n}\r\nstatic ssize_t amdgpu_hwmon_set_pwm1(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct amdgpu_device *adev = dev_get_drvdata(dev);\r\nint err;\r\nu32 value;\r\nerr = kstrtou32(buf, 10, &value);\r\nif (err)\r\nreturn err;\r\nvalue = (value * 100) / 255;\r\nerr = amdgpu_dpm_set_fan_speed_percent(adev, value);\r\nif (err)\r\nreturn err;\r\nreturn count;\r\n}\r\nstatic ssize_t amdgpu_hwmon_get_pwm1(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct amdgpu_device *adev = dev_get_drvdata(dev);\r\nint err;\r\nu32 speed;\r\nerr = amdgpu_dpm_get_fan_speed_percent(adev, &speed);\r\nif (err)\r\nreturn err;\r\nspeed = (speed * 255) / 100;\r\nreturn sprintf(buf, "%i\n", speed);\r\n}\r\nstatic ssize_t amdgpu_hwmon_get_fan1_input(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct amdgpu_device *adev = dev_get_drvdata(dev);\r\nint err;\r\nu32 speed;\r\nerr = amdgpu_dpm_get_fan_speed_rpm(adev, &speed);\r\nif (err)\r\nreturn err;\r\nreturn sprintf(buf, "%i\n", speed);\r\n}\r\nstatic umode_t hwmon_attributes_visible(struct kobject *kobj,\r\nstruct attribute *attr, int index)\r\n{\r\nstruct device *dev = kobj_to_dev(kobj);\r\nstruct amdgpu_device *adev = dev_get_drvdata(dev);\r\numode_t effective_mode = attr->mode;\r\nif (!adev->pm.dpm_enabled &&\r\n(attr == &sensor_dev_attr_temp1_crit.dev_attr.attr ||\r\nattr == &sensor_dev_attr_temp1_crit_hyst.dev_attr.attr ||\r\nattr == &sensor_dev_attr_pwm1.dev_attr.attr ||\r\nattr == &sensor_dev_attr_pwm1_enable.dev_attr.attr ||\r\nattr == &sensor_dev_attr_pwm1_max.dev_attr.attr ||\r\nattr == &sensor_dev_attr_pwm1_min.dev_attr.attr))\r\nreturn 0;\r\nif (adev->pp_enabled)\r\nreturn effective_mode;\r\nif (adev->pm.no_fan &&\r\n(attr == &sensor_dev_attr_pwm1.dev_attr.attr ||\r\nattr == &sensor_dev_attr_pwm1_enable.dev_attr.attr ||\r\nattr == &sensor_dev_attr_pwm1_max.dev_attr.attr ||\r\nattr == &sensor_dev_attr_pwm1_min.dev_attr.attr))\r\nreturn 0;\r\nif ((!adev->pm.funcs->get_fan_speed_percent &&\r\nattr == &sensor_dev_attr_pwm1.dev_attr.attr) ||\r\n(!adev->pm.funcs->get_fan_control_mode &&\r\nattr == &sensor_dev_attr_pwm1_enable.dev_attr.attr))\r\neffective_mode &= ~S_IRUGO;\r\nif ((!adev->pm.funcs->set_fan_speed_percent &&\r\nattr == &sensor_dev_attr_pwm1.dev_attr.attr) ||\r\n(!adev->pm.funcs->set_fan_control_mode &&\r\nattr == &sensor_dev_attr_pwm1_enable.dev_attr.attr))\r\neffective_mode &= ~S_IWUSR;\r\nif ((!adev->pm.funcs->set_fan_speed_percent &&\r\n!adev->pm.funcs->get_fan_speed_percent) &&\r\n(attr == &sensor_dev_attr_pwm1_max.dev_attr.attr ||\r\nattr == &sensor_dev_attr_pwm1_min.dev_attr.attr))\r\nreturn 0;\r\nif (attr == &sensor_dev_attr_fan1_input.dev_attr.attr)\r\nreturn 0;\r\nreturn effective_mode;\r\n}\r\nvoid amdgpu_dpm_thermal_work_handler(struct work_struct *work)\r\n{\r\nstruct amdgpu_device *adev =\r\ncontainer_of(work, struct amdgpu_device,\r\npm.dpm.thermal.work);\r\nenum amd_pm_state_type dpm_state = POWER_STATE_TYPE_INTERNAL_THERMAL;\r\nif (!adev->pm.dpm_enabled)\r\nreturn;\r\nif (adev->pm.funcs->get_temperature) {\r\nint temp = amdgpu_dpm_get_temperature(adev);\r\nif (temp < adev->pm.dpm.thermal.min_temp)\r\ndpm_state = adev->pm.dpm.user_state;\r\n} else {\r\nif (adev->pm.dpm.thermal.high_to_low)\r\ndpm_state = adev->pm.dpm.user_state;\r\n}\r\nmutex_lock(&adev->pm.mutex);\r\nif (dpm_state == POWER_STATE_TYPE_INTERNAL_THERMAL)\r\nadev->pm.dpm.thermal_active = true;\r\nelse\r\nadev->pm.dpm.thermal_active = false;\r\nadev->pm.dpm.state = dpm_state;\r\nmutex_unlock(&adev->pm.mutex);\r\namdgpu_pm_compute_clocks(adev);\r\n}\r\nstatic struct amdgpu_ps *amdgpu_dpm_pick_power_state(struct amdgpu_device *adev,\r\nenum amd_pm_state_type dpm_state)\r\n{\r\nint i;\r\nstruct amdgpu_ps *ps;\r\nu32 ui_class;\r\nbool single_display = (adev->pm.dpm.new_active_crtc_count < 2) ?\r\ntrue : false;\r\nif (single_display && adev->pm.funcs->vblank_too_short) {\r\nif (amdgpu_dpm_vblank_too_short(adev))\r\nsingle_display = false;\r\n}\r\nif (dpm_state == POWER_STATE_TYPE_PERFORMANCE)\r\ndpm_state = POWER_STATE_TYPE_INTERNAL_3DPERF;\r\nif (dpm_state == POWER_STATE_TYPE_BALANCED)\r\ndpm_state = POWER_STATE_TYPE_PERFORMANCE;\r\nrestart_search:\r\nfor (i = 0; i < adev->pm.dpm.num_ps; i++) {\r\nps = &adev->pm.dpm.ps[i];\r\nui_class = ps->class & ATOM_PPLIB_CLASSIFICATION_UI_MASK;\r\nswitch (dpm_state) {\r\ncase POWER_STATE_TYPE_BATTERY:\r\nif (ui_class == ATOM_PPLIB_CLASSIFICATION_UI_BATTERY) {\r\nif (ps->caps & ATOM_PPLIB_SINGLE_DISPLAY_ONLY) {\r\nif (single_display)\r\nreturn ps;\r\n} else\r\nreturn ps;\r\n}\r\nbreak;\r\ncase POWER_STATE_TYPE_BALANCED:\r\nif (ui_class == ATOM_PPLIB_CLASSIFICATION_UI_BALANCED) {\r\nif (ps->caps & ATOM_PPLIB_SINGLE_DISPLAY_ONLY) {\r\nif (single_display)\r\nreturn ps;\r\n} else\r\nreturn ps;\r\n}\r\nbreak;\r\ncase POWER_STATE_TYPE_PERFORMANCE:\r\nif (ui_class == ATOM_PPLIB_CLASSIFICATION_UI_PERFORMANCE) {\r\nif (ps->caps & ATOM_PPLIB_SINGLE_DISPLAY_ONLY) {\r\nif (single_display)\r\nreturn ps;\r\n} else\r\nreturn ps;\r\n}\r\nbreak;\r\ncase POWER_STATE_TYPE_INTERNAL_UVD:\r\nif (adev->pm.dpm.uvd_ps)\r\nreturn adev->pm.dpm.uvd_ps;\r\nelse\r\nbreak;\r\ncase POWER_STATE_TYPE_INTERNAL_UVD_SD:\r\nif (ps->class & ATOM_PPLIB_CLASSIFICATION_SDSTATE)\r\nreturn ps;\r\nbreak;\r\ncase POWER_STATE_TYPE_INTERNAL_UVD_HD:\r\nif (ps->class & ATOM_PPLIB_CLASSIFICATION_HDSTATE)\r\nreturn ps;\r\nbreak;\r\ncase POWER_STATE_TYPE_INTERNAL_UVD_HD2:\r\nif (ps->class & ATOM_PPLIB_CLASSIFICATION_HD2STATE)\r\nreturn ps;\r\nbreak;\r\ncase POWER_STATE_TYPE_INTERNAL_UVD_MVC:\r\nif (ps->class2 & ATOM_PPLIB_CLASSIFICATION2_MVC)\r\nreturn ps;\r\nbreak;\r\ncase POWER_STATE_TYPE_INTERNAL_BOOT:\r\nreturn adev->pm.dpm.boot_ps;\r\ncase POWER_STATE_TYPE_INTERNAL_THERMAL:\r\nif (ps->class & ATOM_PPLIB_CLASSIFICATION_THERMAL)\r\nreturn ps;\r\nbreak;\r\ncase POWER_STATE_TYPE_INTERNAL_ACPI:\r\nif (ps->class & ATOM_PPLIB_CLASSIFICATION_ACPI)\r\nreturn ps;\r\nbreak;\r\ncase POWER_STATE_TYPE_INTERNAL_ULV:\r\nif (ps->class2 & ATOM_PPLIB_CLASSIFICATION2_ULV)\r\nreturn ps;\r\nbreak;\r\ncase POWER_STATE_TYPE_INTERNAL_3DPERF:\r\nif (ps->class & ATOM_PPLIB_CLASSIFICATION_3DPERFORMANCE)\r\nreturn ps;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nswitch (dpm_state) {\r\ncase POWER_STATE_TYPE_INTERNAL_UVD_SD:\r\ndpm_state = POWER_STATE_TYPE_INTERNAL_UVD_HD;\r\ngoto restart_search;\r\ncase POWER_STATE_TYPE_INTERNAL_UVD_HD:\r\ncase POWER_STATE_TYPE_INTERNAL_UVD_HD2:\r\ncase POWER_STATE_TYPE_INTERNAL_UVD_MVC:\r\nif (adev->pm.dpm.uvd_ps) {\r\nreturn adev->pm.dpm.uvd_ps;\r\n} else {\r\ndpm_state = POWER_STATE_TYPE_PERFORMANCE;\r\ngoto restart_search;\r\n}\r\ncase POWER_STATE_TYPE_INTERNAL_THERMAL:\r\ndpm_state = POWER_STATE_TYPE_INTERNAL_ACPI;\r\ngoto restart_search;\r\ncase POWER_STATE_TYPE_INTERNAL_ACPI:\r\ndpm_state = POWER_STATE_TYPE_BATTERY;\r\ngoto restart_search;\r\ncase POWER_STATE_TYPE_BATTERY:\r\ncase POWER_STATE_TYPE_BALANCED:\r\ncase POWER_STATE_TYPE_INTERNAL_3DPERF:\r\ndpm_state = POWER_STATE_TYPE_PERFORMANCE;\r\ngoto restart_search;\r\ndefault:\r\nbreak;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void amdgpu_dpm_change_power_state_locked(struct amdgpu_device *adev)\r\n{\r\nstruct amdgpu_ps *ps;\r\nenum amd_pm_state_type dpm_state;\r\nint ret;\r\nbool equal;\r\nif (!adev->pm.dpm_enabled)\r\nreturn;\r\nif (adev->pm.dpm.user_state != adev->pm.dpm.state) {\r\nif ((!adev->pm.dpm.thermal_active) &&\r\n(!adev->pm.dpm.uvd_active))\r\nadev->pm.dpm.state = adev->pm.dpm.user_state;\r\n}\r\ndpm_state = adev->pm.dpm.state;\r\nps = amdgpu_dpm_pick_power_state(adev, dpm_state);\r\nif (ps)\r\nadev->pm.dpm.requested_ps = ps;\r\nelse\r\nreturn;\r\nif (amdgpu_dpm == 1) {\r\nprintk("switching from power state:\n");\r\namdgpu_dpm_print_power_state(adev, adev->pm.dpm.current_ps);\r\nprintk("switching to power state:\n");\r\namdgpu_dpm_print_power_state(adev, adev->pm.dpm.requested_ps);\r\n}\r\nps->vce_active = adev->pm.dpm.vce_active;\r\namdgpu_dpm_display_configuration_changed(adev);\r\nret = amdgpu_dpm_pre_set_power_state(adev);\r\nif (ret)\r\nreturn;\r\nif ((0 != amgdpu_dpm_check_state_equal(adev, adev->pm.dpm.current_ps, adev->pm.dpm.requested_ps, &equal)))\r\nequal = false;\r\nif (equal)\r\nreturn;\r\namdgpu_dpm_set_power_state(adev);\r\namdgpu_dpm_post_set_power_state(adev);\r\nadev->pm.dpm.current_active_crtcs = adev->pm.dpm.new_active_crtcs;\r\nadev->pm.dpm.current_active_crtc_count = adev->pm.dpm.new_active_crtc_count;\r\nif (adev->pm.funcs->force_performance_level) {\r\nif (adev->pm.dpm.thermal_active) {\r\nenum amd_dpm_forced_level level = adev->pm.dpm.forced_level;\r\namdgpu_dpm_force_performance_level(adev, AMD_DPM_FORCED_LEVEL_LOW);\r\nadev->pm.dpm.forced_level = level;\r\n} else {\r\namdgpu_dpm_force_performance_level(adev, adev->pm.dpm.forced_level);\r\n}\r\n}\r\n}\r\nvoid amdgpu_dpm_enable_uvd(struct amdgpu_device *adev, bool enable)\r\n{\r\nif (adev->pp_enabled || adev->pm.funcs->powergate_uvd) {\r\nmutex_lock(&adev->pm.mutex);\r\namdgpu_dpm_powergate_uvd(adev, !enable);\r\nmutex_unlock(&adev->pm.mutex);\r\n} else {\r\nif (enable) {\r\nmutex_lock(&adev->pm.mutex);\r\nadev->pm.dpm.uvd_active = true;\r\nadev->pm.dpm.state = POWER_STATE_TYPE_INTERNAL_UVD;\r\nmutex_unlock(&adev->pm.mutex);\r\n} else {\r\nmutex_lock(&adev->pm.mutex);\r\nadev->pm.dpm.uvd_active = false;\r\nmutex_unlock(&adev->pm.mutex);\r\n}\r\namdgpu_pm_compute_clocks(adev);\r\n}\r\n}\r\nvoid amdgpu_dpm_enable_vce(struct amdgpu_device *adev, bool enable)\r\n{\r\nif (adev->pp_enabled || adev->pm.funcs->powergate_vce) {\r\nmutex_lock(&adev->pm.mutex);\r\namdgpu_dpm_powergate_vce(adev, !enable);\r\nmutex_unlock(&adev->pm.mutex);\r\n} else {\r\nif (enable) {\r\nmutex_lock(&adev->pm.mutex);\r\nadev->pm.dpm.vce_active = true;\r\nadev->pm.dpm.vce_level = AMD_VCE_LEVEL_AC_ALL;\r\nmutex_unlock(&adev->pm.mutex);\r\namdgpu_set_clockgating_state(adev, AMD_IP_BLOCK_TYPE_VCE,\r\nAMD_CG_STATE_UNGATE);\r\namdgpu_set_powergating_state(adev, AMD_IP_BLOCK_TYPE_VCE,\r\nAMD_PG_STATE_UNGATE);\r\namdgpu_pm_compute_clocks(adev);\r\n} else {\r\namdgpu_set_powergating_state(adev, AMD_IP_BLOCK_TYPE_VCE,\r\nAMD_PG_STATE_GATE);\r\namdgpu_set_clockgating_state(adev, AMD_IP_BLOCK_TYPE_VCE,\r\nAMD_CG_STATE_GATE);\r\nmutex_lock(&adev->pm.mutex);\r\nadev->pm.dpm.vce_active = false;\r\nmutex_unlock(&adev->pm.mutex);\r\namdgpu_pm_compute_clocks(adev);\r\n}\r\n}\r\n}\r\nvoid amdgpu_pm_print_power_states(struct amdgpu_device *adev)\r\n{\r\nint i;\r\nif (adev->pp_enabled)\r\nreturn;\r\nfor (i = 0; i < adev->pm.dpm.num_ps; i++)\r\namdgpu_dpm_print_power_state(adev, &adev->pm.dpm.ps[i]);\r\n}\r\nint amdgpu_pm_sysfs_init(struct amdgpu_device *adev)\r\n{\r\nint ret;\r\nif (adev->pm.sysfs_initialized)\r\nreturn 0;\r\nif (!adev->pp_enabled) {\r\nif (adev->pm.funcs->get_temperature == NULL)\r\nreturn 0;\r\n}\r\nadev->pm.int_hwmon_dev = hwmon_device_register_with_groups(adev->dev,\r\nDRIVER_NAME, adev,\r\nhwmon_groups);\r\nif (IS_ERR(adev->pm.int_hwmon_dev)) {\r\nret = PTR_ERR(adev->pm.int_hwmon_dev);\r\ndev_err(adev->dev,\r\n"Unable to register hwmon device: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = device_create_file(adev->dev, &dev_attr_power_dpm_state);\r\nif (ret) {\r\nDRM_ERROR("failed to create device file for dpm state\n");\r\nreturn ret;\r\n}\r\nret = device_create_file(adev->dev, &dev_attr_power_dpm_force_performance_level);\r\nif (ret) {\r\nDRM_ERROR("failed to create device file for dpm state\n");\r\nreturn ret;\r\n}\r\nif (adev->pp_enabled) {\r\nret = device_create_file(adev->dev, &dev_attr_pp_num_states);\r\nif (ret) {\r\nDRM_ERROR("failed to create device file pp_num_states\n");\r\nreturn ret;\r\n}\r\nret = device_create_file(adev->dev, &dev_attr_pp_cur_state);\r\nif (ret) {\r\nDRM_ERROR("failed to create device file pp_cur_state\n");\r\nreturn ret;\r\n}\r\nret = device_create_file(adev->dev, &dev_attr_pp_force_state);\r\nif (ret) {\r\nDRM_ERROR("failed to create device file pp_force_state\n");\r\nreturn ret;\r\n}\r\nret = device_create_file(adev->dev, &dev_attr_pp_table);\r\nif (ret) {\r\nDRM_ERROR("failed to create device file pp_table\n");\r\nreturn ret;\r\n}\r\n}\r\nret = device_create_file(adev->dev, &dev_attr_pp_dpm_sclk);\r\nif (ret) {\r\nDRM_ERROR("failed to create device file pp_dpm_sclk\n");\r\nreturn ret;\r\n}\r\nret = device_create_file(adev->dev, &dev_attr_pp_dpm_mclk);\r\nif (ret) {\r\nDRM_ERROR("failed to create device file pp_dpm_mclk\n");\r\nreturn ret;\r\n}\r\nret = device_create_file(adev->dev, &dev_attr_pp_dpm_pcie);\r\nif (ret) {\r\nDRM_ERROR("failed to create device file pp_dpm_pcie\n");\r\nreturn ret;\r\n}\r\nret = device_create_file(adev->dev, &dev_attr_pp_sclk_od);\r\nif (ret) {\r\nDRM_ERROR("failed to create device file pp_sclk_od\n");\r\nreturn ret;\r\n}\r\nret = device_create_file(adev->dev, &dev_attr_pp_mclk_od);\r\nif (ret) {\r\nDRM_ERROR("failed to create device file pp_mclk_od\n");\r\nreturn ret;\r\n}\r\nret = device_create_file(adev->dev,\r\n&dev_attr_pp_gfx_power_profile);\r\nif (ret) {\r\nDRM_ERROR("failed to create device file "\r\n"pp_gfx_power_profile\n");\r\nreturn ret;\r\n}\r\nret = device_create_file(adev->dev,\r\n&dev_attr_pp_compute_power_profile);\r\nif (ret) {\r\nDRM_ERROR("failed to create device file "\r\n"pp_compute_power_profile\n");\r\nreturn ret;\r\n}\r\nret = amdgpu_debugfs_pm_init(adev);\r\nif (ret) {\r\nDRM_ERROR("Failed to register debugfs file for dpm!\n");\r\nreturn ret;\r\n}\r\nadev->pm.sysfs_initialized = true;\r\nreturn 0;\r\n}\r\nvoid amdgpu_pm_sysfs_fini(struct amdgpu_device *adev)\r\n{\r\nif (adev->pm.int_hwmon_dev)\r\nhwmon_device_unregister(adev->pm.int_hwmon_dev);\r\ndevice_remove_file(adev->dev, &dev_attr_power_dpm_state);\r\ndevice_remove_file(adev->dev, &dev_attr_power_dpm_force_performance_level);\r\nif (adev->pp_enabled) {\r\ndevice_remove_file(adev->dev, &dev_attr_pp_num_states);\r\ndevice_remove_file(adev->dev, &dev_attr_pp_cur_state);\r\ndevice_remove_file(adev->dev, &dev_attr_pp_force_state);\r\ndevice_remove_file(adev->dev, &dev_attr_pp_table);\r\n}\r\ndevice_remove_file(adev->dev, &dev_attr_pp_dpm_sclk);\r\ndevice_remove_file(adev->dev, &dev_attr_pp_dpm_mclk);\r\ndevice_remove_file(adev->dev, &dev_attr_pp_dpm_pcie);\r\ndevice_remove_file(adev->dev, &dev_attr_pp_sclk_od);\r\ndevice_remove_file(adev->dev, &dev_attr_pp_mclk_od);\r\ndevice_remove_file(adev->dev,\r\n&dev_attr_pp_gfx_power_profile);\r\ndevice_remove_file(adev->dev,\r\n&dev_attr_pp_compute_power_profile);\r\n}\r\nvoid amdgpu_pm_compute_clocks(struct amdgpu_device *adev)\r\n{\r\nstruct drm_device *ddev = adev->ddev;\r\nstruct drm_crtc *crtc;\r\nstruct amdgpu_crtc *amdgpu_crtc;\r\nint i = 0;\r\nif (!adev->pm.dpm_enabled)\r\nreturn;\r\nif (adev->mode_info.num_crtc)\r\namdgpu_display_bandwidth_update(adev);\r\nfor (i = 0; i < AMDGPU_MAX_RINGS; i++) {\r\nstruct amdgpu_ring *ring = adev->rings[i];\r\nif (ring && ring->ready)\r\namdgpu_fence_wait_empty(ring);\r\n}\r\nif (adev->pp_enabled) {\r\namdgpu_dpm_dispatch_task(adev, AMD_PP_EVENT_DISPLAY_CONFIG_CHANGE, NULL, NULL);\r\n} else {\r\nmutex_lock(&adev->pm.mutex);\r\nadev->pm.dpm.new_active_crtcs = 0;\r\nadev->pm.dpm.new_active_crtc_count = 0;\r\nif (adev->mode_info.num_crtc && adev->mode_info.mode_config_initialized) {\r\nlist_for_each_entry(crtc,\r\n&ddev->mode_config.crtc_list, head) {\r\namdgpu_crtc = to_amdgpu_crtc(crtc);\r\nif (crtc->enabled) {\r\nadev->pm.dpm.new_active_crtcs |= (1 << amdgpu_crtc->crtc_id);\r\nadev->pm.dpm.new_active_crtc_count++;\r\n}\r\n}\r\n}\r\nif (power_supply_is_system_supplied() > 0)\r\nadev->pm.dpm.ac_power = true;\r\nelse\r\nadev->pm.dpm.ac_power = false;\r\namdgpu_dpm_change_power_state_locked(adev);\r\nmutex_unlock(&adev->pm.mutex);\r\n}\r\n}\r\nstatic int amdgpu_debugfs_pm_info_pp(struct seq_file *m, struct amdgpu_device *adev)\r\n{\r\nuint32_t value;\r\nstruct pp_gpu_power query = {0};\r\nint size;\r\nif (!(adev->powerplay.pp_funcs &&\r\nadev->powerplay.pp_funcs->read_sensor))\r\nreturn -EINVAL;\r\nsize = sizeof(value);\r\nseq_printf(m, "GFX Clocks and Power:\n");\r\nif (!amdgpu_dpm_read_sensor(adev, AMDGPU_PP_SENSOR_GFX_MCLK, (void *)&value, &size))\r\nseq_printf(m, "\t%u MHz (MCLK)\n", value/100);\r\nif (!amdgpu_dpm_read_sensor(adev, AMDGPU_PP_SENSOR_GFX_SCLK, (void *)&value, &size))\r\nseq_printf(m, "\t%u MHz (SCLK)\n", value/100);\r\nif (!amdgpu_dpm_read_sensor(adev, AMDGPU_PP_SENSOR_VDDGFX, (void *)&value, &size))\r\nseq_printf(m, "\t%u mV (VDDGFX)\n", value);\r\nif (!amdgpu_dpm_read_sensor(adev, AMDGPU_PP_SENSOR_VDDNB, (void *)&value, &size))\r\nseq_printf(m, "\t%u mV (VDDNB)\n", value);\r\nsize = sizeof(query);\r\nif (!amdgpu_dpm_read_sensor(adev, AMDGPU_PP_SENSOR_GPU_POWER, (void *)&query, &size)) {\r\nseq_printf(m, "\t%u.%u W (VDDC)\n", query.vddc_power >> 8,\r\nquery.vddc_power & 0xff);\r\nseq_printf(m, "\t%u.%u W (VDDCI)\n", query.vddci_power >> 8,\r\nquery.vddci_power & 0xff);\r\nseq_printf(m, "\t%u.%u W (max GPU)\n", query.max_gpu_power >> 8,\r\nquery.max_gpu_power & 0xff);\r\nseq_printf(m, "\t%u.%u W (average GPU)\n", query.average_gpu_power >> 8,\r\nquery.average_gpu_power & 0xff);\r\n}\r\nsize = sizeof(value);\r\nseq_printf(m, "\n");\r\nif (!amdgpu_dpm_read_sensor(adev, AMDGPU_PP_SENSOR_GPU_TEMP, (void *)&value, &size))\r\nseq_printf(m, "GPU Temperature: %u C\n", value/1000);\r\nif (!amdgpu_dpm_read_sensor(adev, AMDGPU_PP_SENSOR_GPU_LOAD, (void *)&value, &size))\r\nseq_printf(m, "GPU Load: %u %%\n", value);\r\nseq_printf(m, "\n");\r\nif (!amdgpu_dpm_read_sensor(adev, AMDGPU_PP_SENSOR_UVD_POWER, (void *)&value, &size)) {\r\nif (!value) {\r\nseq_printf(m, "UVD: Disabled\n");\r\n} else {\r\nseq_printf(m, "UVD: Enabled\n");\r\nif (!amdgpu_dpm_read_sensor(adev, AMDGPU_PP_SENSOR_UVD_DCLK, (void *)&value, &size))\r\nseq_printf(m, "\t%u MHz (DCLK)\n", value/100);\r\nif (!amdgpu_dpm_read_sensor(adev, AMDGPU_PP_SENSOR_UVD_VCLK, (void *)&value, &size))\r\nseq_printf(m, "\t%u MHz (VCLK)\n", value/100);\r\n}\r\n}\r\nseq_printf(m, "\n");\r\nif (!amdgpu_dpm_read_sensor(adev, AMDGPU_PP_SENSOR_VCE_POWER, (void *)&value, &size)) {\r\nif (!value) {\r\nseq_printf(m, "VCE: Disabled\n");\r\n} else {\r\nseq_printf(m, "VCE: Enabled\n");\r\nif (!amdgpu_dpm_read_sensor(adev, AMDGPU_PP_SENSOR_VCE_ECCLK, (void *)&value, &size))\r\nseq_printf(m, "\t%u MHz (ECCLK)\n", value/100);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void amdgpu_parse_cg_state(struct seq_file *m, u32 flags)\r\n{\r\nint i;\r\nfor (i = 0; clocks[i].flag; i++)\r\nseq_printf(m, "\t%s: %s\n", clocks[i].name,\r\n(flags & clocks[i].flag) ? "On" : "Off");\r\n}\r\nstatic int amdgpu_debugfs_pm_info(struct seq_file *m, void *data)\r\n{\r\nstruct drm_info_node *node = (struct drm_info_node *) m->private;\r\nstruct drm_device *dev = node->minor->dev;\r\nstruct amdgpu_device *adev = dev->dev_private;\r\nstruct drm_device *ddev = adev->ddev;\r\nu32 flags = 0;\r\namdgpu_get_clockgating_state(adev, &flags);\r\nseq_printf(m, "Clock Gating Flags Mask: 0x%x\n", flags);\r\namdgpu_parse_cg_state(m, flags);\r\nseq_printf(m, "\n");\r\nif (!adev->pm.dpm_enabled) {\r\nseq_printf(m, "dpm not enabled\n");\r\nreturn 0;\r\n}\r\nif ((adev->flags & AMD_IS_PX) &&\r\n(ddev->switch_power_state != DRM_SWITCH_POWER_ON)) {\r\nseq_printf(m, "PX asic powered off\n");\r\n} else if (adev->pp_enabled) {\r\nreturn amdgpu_debugfs_pm_info_pp(m, adev);\r\n} else {\r\nmutex_lock(&adev->pm.mutex);\r\nif (adev->pm.funcs->debugfs_print_current_performance_level)\r\nadev->pm.funcs->debugfs_print_current_performance_level(adev, m);\r\nelse\r\nseq_printf(m, "Debugfs support not implemented for this asic\n");\r\nmutex_unlock(&adev->pm.mutex);\r\n}\r\nreturn 0;\r\n}\r\nstatic int amdgpu_debugfs_pm_init(struct amdgpu_device *adev)\r\n{\r\n#if defined(CONFIG_DEBUG_FS)\r\nreturn amdgpu_debugfs_add_files(adev, amdgpu_pm_info_list, ARRAY_SIZE(amdgpu_pm_info_list));\r\n#else\r\nreturn 0;\r\n#endif\r\n}
