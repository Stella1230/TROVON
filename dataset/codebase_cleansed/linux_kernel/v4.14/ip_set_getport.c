static bool\r\nget_port(const struct sk_buff *skb, int protocol, unsigned int protooff,\r\nbool src, __be16 *port, u8 *proto)\r\n{\r\nswitch (protocol) {\r\ncase IPPROTO_TCP: {\r\nstruct tcphdr _tcph;\r\nconst struct tcphdr *th;\r\nth = skb_header_pointer(skb, protooff, sizeof(_tcph), &_tcph);\r\nif (!th)\r\nreturn false;\r\n*port = src ? th->source : th->dest;\r\nbreak;\r\n}\r\ncase IPPROTO_SCTP: {\r\nstruct sctphdr _sh;\r\nconst struct sctphdr *sh;\r\nsh = skb_header_pointer(skb, protooff, sizeof(_sh), &_sh);\r\nif (!sh)\r\nreturn false;\r\n*port = src ? sh->source : sh->dest;\r\nbreak;\r\n}\r\ncase IPPROTO_UDP:\r\ncase IPPROTO_UDPLITE: {\r\nstruct udphdr _udph;\r\nconst struct udphdr *uh;\r\nuh = skb_header_pointer(skb, protooff, sizeof(_udph), &_udph);\r\nif (!uh)\r\nreturn false;\r\n*port = src ? uh->source : uh->dest;\r\nbreak;\r\n}\r\ncase IPPROTO_ICMP: {\r\nstruct icmphdr _ich;\r\nconst struct icmphdr *ic;\r\nic = skb_header_pointer(skb, protooff, sizeof(_ich), &_ich);\r\nif (!ic)\r\nreturn false;\r\n*port = (__force __be16)htons((ic->type << 8) | ic->code);\r\nbreak;\r\n}\r\ncase IPPROTO_ICMPV6: {\r\nstruct icmp6hdr _ich;\r\nconst struct icmp6hdr *ic;\r\nic = skb_header_pointer(skb, protooff, sizeof(_ich), &_ich);\r\nif (!ic)\r\nreturn false;\r\n*port = (__force __be16)\r\nhtons((ic->icmp6_type << 8) | ic->icmp6_code);\r\nbreak;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\n*proto = protocol;\r\nreturn true;\r\n}\r\nbool\r\nip_set_get_ip4_port(const struct sk_buff *skb, bool src,\r\n__be16 *port, u8 *proto)\r\n{\r\nconst struct iphdr *iph = ip_hdr(skb);\r\nunsigned int protooff = skb_network_offset(skb) + ip_hdrlen(skb);\r\nint protocol = iph->protocol;\r\nif (protocol <= 0)\r\nreturn false;\r\nif (ntohs(iph->frag_off) & IP_OFFSET)\r\nswitch (protocol) {\r\ncase IPPROTO_TCP:\r\ncase IPPROTO_SCTP:\r\ncase IPPROTO_UDP:\r\ncase IPPROTO_UDPLITE:\r\ncase IPPROTO_ICMP:\r\nreturn false;\r\ndefault:\r\n*proto = protocol;\r\nreturn true;\r\n}\r\nreturn get_port(skb, protocol, protooff, src, port, proto);\r\n}\r\nbool\r\nip_set_get_ip6_port(const struct sk_buff *skb, bool src,\r\n__be16 *port, u8 *proto)\r\n{\r\nint protoff;\r\nu8 nexthdr;\r\n__be16 frag_off = 0;\r\nnexthdr = ipv6_hdr(skb)->nexthdr;\r\nprotoff = ipv6_skip_exthdr(skb,\r\nskb_network_offset(skb) +\r\nsizeof(struct ipv6hdr), &nexthdr,\r\n&frag_off);\r\nif (protoff < 0 || (frag_off & htons(~0x7)) != 0)\r\nreturn false;\r\nreturn get_port(skb, nexthdr, protoff, src, port, proto);\r\n}\r\nbool\r\nip_set_get_ip_port(const struct sk_buff *skb, u8 pf, bool src, __be16 *port)\r\n{\r\nbool ret;\r\nu8 proto;\r\nswitch (pf) {\r\ncase NFPROTO_IPV4:\r\nret = ip_set_get_ip4_port(skb, src, port, &proto);\r\nbreak;\r\ncase NFPROTO_IPV6:\r\nret = ip_set_get_ip6_port(skb, src, port, &proto);\r\nbreak;\r\ndefault:\r\nreturn false;\r\n}\r\nif (!ret)\r\nreturn ret;\r\nswitch (proto) {\r\ncase IPPROTO_TCP:\r\ncase IPPROTO_UDP:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}
