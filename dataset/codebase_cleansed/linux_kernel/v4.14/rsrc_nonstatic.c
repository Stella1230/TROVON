static struct resource *\r\nclaim_region(struct pcmcia_socket *s, resource_size_t base,\r\nresource_size_t size, int type, char *name)\r\n{\r\nstruct resource *res, *parent;\r\nparent = type & IORESOURCE_MEM ? &iomem_resource : &ioport_resource;\r\nres = pcmcia_make_resource(base, size, type | IORESOURCE_BUSY, name);\r\nif (res) {\r\n#ifdef CONFIG_PCI\r\nif (s && s->cb_dev)\r\nparent = pci_find_parent_resource(s->cb_dev, res);\r\n#endif\r\nif (!parent || request_resource(parent, res)) {\r\nkfree(res);\r\nres = NULL;\r\n}\r\n}\r\nreturn res;\r\n}\r\nstatic void free_region(struct resource *res)\r\n{\r\nif (res) {\r\nrelease_resource(res);\r\nkfree(res);\r\n}\r\n}\r\nstatic int add_interval(struct resource_map *map, u_long base, u_long num)\r\n{\r\nstruct resource_map *p, *q;\r\nfor (p = map; ; p = p->next) {\r\nif ((p != map) && (p->base+p->num >= base)) {\r\np->num = max(num + base - p->base, p->num);\r\nreturn 0;\r\n}\r\nif ((p->next == map) || (p->next->base > base+num-1))\r\nbreak;\r\n}\r\nq = kmalloc(sizeof(struct resource_map), GFP_KERNEL);\r\nif (!q) {\r\nprintk(KERN_WARNING "out of memory to update resources\n");\r\nreturn -ENOMEM;\r\n}\r\nq->base = base; q->num = num;\r\nq->next = p->next; p->next = q;\r\nreturn 0;\r\n}\r\nstatic int sub_interval(struct resource_map *map, u_long base, u_long num)\r\n{\r\nstruct resource_map *p, *q;\r\nfor (p = map; ; p = q) {\r\nq = p->next;\r\nif (q == map)\r\nbreak;\r\nif ((q->base+q->num > base) && (base+num > q->base)) {\r\nif (q->base >= base) {\r\nif (q->base+q->num <= base+num) {\r\np->next = q->next;\r\nkfree(q);\r\nq = p;\r\n} else {\r\nq->num = q->base + q->num - base - num;\r\nq->base = base + num;\r\n}\r\n} else if (q->base+q->num <= base+num) {\r\nq->num = base - q->base;\r\n} else {\r\np = kmalloc(sizeof(struct resource_map),\r\nGFP_KERNEL);\r\nif (!p) {\r\nprintk(KERN_WARNING "out of memory to update resources\n");\r\nreturn -ENOMEM;\r\n}\r\np->base = base+num;\r\np->num = q->base+q->num - p->base;\r\nq->num = base - q->base;\r\np->next = q->next ; q->next = p;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void do_io_probe(struct pcmcia_socket *s, unsigned int base,\r\nunsigned int num)\r\n{\r\nstruct resource *res;\r\nstruct socket_data *s_data = s->resource_data;\r\nunsigned int i, j, bad;\r\nint any;\r\nu_char *b, hole, most;\r\ndev_info(&s->dev, "cs: IO port probe %#x-%#x:", base, base+num-1);\r\nb = kzalloc(256, GFP_KERNEL);\r\nif (!b) {\r\npr_cont("\n");\r\ndev_err(&s->dev, "do_io_probe: unable to kmalloc 256 bytes\n");\r\nreturn;\r\n}\r\nfor (i = base, most = 0; i < base+num; i += 8) {\r\nres = claim_region(s, i, 8, IORESOURCE_IO, "PCMCIA ioprobe");\r\nif (!res)\r\ncontinue;\r\nhole = inb(i);\r\nfor (j = 1; j < 8; j++)\r\nif (inb(i+j) != hole)\r\nbreak;\r\nfree_region(res);\r\nif ((j == 8) && (++b[hole] > b[most]))\r\nmost = hole;\r\nif (b[most] == 127)\r\nbreak;\r\n}\r\nkfree(b);\r\nbad = any = 0;\r\nfor (i = base; i < base+num; i += 8) {\r\nres = claim_region(s, i, 8, IORESOURCE_IO, "PCMCIA ioprobe");\r\nif (!res) {\r\nif (!any)\r\npr_cont(" excluding");\r\nif (!bad)\r\nbad = any = i;\r\ncontinue;\r\n}\r\nfor (j = 0; j < 8; j++)\r\nif (inb(i+j) != most)\r\nbreak;\r\nfree_region(res);\r\nif (j < 8) {\r\nif (!any)\r\npr_cont(" excluding");\r\nif (!bad)\r\nbad = any = i;\r\n} else {\r\nif (bad) {\r\nsub_interval(&s_data->io_db, bad, i-bad);\r\npr_cont(" %#x-%#x", bad, i-1);\r\nbad = 0;\r\n}\r\n}\r\n}\r\nif (bad) {\r\nif ((num > 16) && (bad == base) && (i == base+num)) {\r\nsub_interval(&s_data->io_db, bad, i-bad);\r\npr_cont(" nothing: probe failed.\n");\r\nreturn;\r\n} else {\r\nsub_interval(&s_data->io_db, bad, i-bad);\r\npr_cont(" %#x-%#x", bad, i-1);\r\n}\r\n}\r\npr_cont("%s\n", !any ? " clean" : "");\r\n}\r\nstatic int readable(struct pcmcia_socket *s, struct resource *res,\r\nunsigned int *count)\r\n{\r\nint ret = -EINVAL;\r\nif (s->fake_cis) {\r\ndev_dbg(&s->dev, "fake CIS is being used: can't validate mem\n");\r\nreturn 0;\r\n}\r\ns->cis_mem.res = res;\r\ns->cis_virt = ioremap(res->start, s->map_size);\r\nif (s->cis_virt) {\r\nmutex_unlock(&s->ops_mutex);\r\nif (s->callback->validate)\r\nret = s->callback->validate(s, count);\r\nmutex_lock(&s->ops_mutex);\r\niounmap(s->cis_virt);\r\ns->cis_virt = NULL;\r\n}\r\ns->cis_mem.res = NULL;\r\nif ((ret) || (*count == 0))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int checksum(struct pcmcia_socket *s, struct resource *res,\r\nunsigned int *value)\r\n{\r\npccard_mem_map map;\r\nint i, a = 0, b = -1, d;\r\nvoid __iomem *virt;\r\nvirt = ioremap(res->start, s->map_size);\r\nif (virt) {\r\nmap.map = 0;\r\nmap.flags = MAP_ACTIVE;\r\nmap.speed = 0;\r\nmap.res = res;\r\nmap.card_start = 0;\r\ns->ops->set_mem_map(s, &map);\r\nfor (i = 0; i < s->map_size; i += 44) {\r\nd = readl(virt+i);\r\na += d;\r\nb &= d;\r\n}\r\nmap.flags = 0;\r\ns->ops->set_mem_map(s, &map);\r\niounmap(virt);\r\n}\r\nif (b == -1)\r\nreturn -EINVAL;\r\n*value = a;\r\nreturn 0;\r\n}\r\nstatic int do_validate_mem(struct pcmcia_socket *s,\r\nunsigned long base, unsigned long size,\r\nint validate (struct pcmcia_socket *s,\r\nstruct resource *res,\r\nunsigned int *value))\r\n{\r\nstruct socket_data *s_data = s->resource_data;\r\nstruct resource *res1, *res2;\r\nunsigned int info1 = 1, info2 = 1;\r\nint ret = -EINVAL;\r\nres1 = claim_region(s, base, size/2, IORESOURCE_MEM, "PCMCIA memprobe");\r\nres2 = claim_region(s, base + size/2, size/2, IORESOURCE_MEM,\r\n"PCMCIA memprobe");\r\nif (res1 && res2) {\r\nret = 0;\r\nif (validate) {\r\nret = validate(s, res1, &info1);\r\nret += validate(s, res2, &info2);\r\n}\r\n}\r\ndev_dbg(&s->dev, "cs: memory probe 0x%06lx-0x%06lx: %p %p %u %u %u",\r\nbase, base+size-1, res1, res2, ret, info1, info2);\r\nfree_region(res2);\r\nfree_region(res1);\r\nif ((ret) || (info1 != info2) || (info1 == 0))\r\nreturn -EINVAL;\r\nif (validate && !s->fake_cis) {\r\nadd_interval(&s_data->mem_db_valid, base, size);\r\nsub_interval(&s_data->mem_db, base, size);\r\n}\r\nreturn 0;\r\n}\r\nstatic int do_mem_probe(struct pcmcia_socket *s, u_long base, u_long num,\r\nint validate (struct pcmcia_socket *s,\r\nstruct resource *res,\r\nunsigned int *value),\r\nint fallback (struct pcmcia_socket *s,\r\nstruct resource *res,\r\nunsigned int *value))\r\n{\r\nstruct socket_data *s_data = s->resource_data;\r\nu_long i, j, bad, fail, step;\r\ndev_info(&s->dev, "cs: memory probe 0x%06lx-0x%06lx:",\r\nbase, base+num-1);\r\nbad = fail = 0;\r\nstep = (num < 0x20000) ? 0x2000 : ((num>>4) & ~0x1fff);\r\nif (step > 0x800000)\r\nstep = 0x800000;\r\nif (step < 2 * s->map_size)\r\nstep = 2 * s->map_size;\r\nfor (i = j = base; i < base+num; i = j + step) {\r\nif (!fail) {\r\nfor (j = i; j < base+num; j += step) {\r\nif (!do_validate_mem(s, j, step, validate))\r\nbreak;\r\n}\r\nfail = ((i == base) && (j == base+num));\r\n}\r\nif ((fail) && (fallback)) {\r\nfor (j = i; j < base+num; j += step)\r\nif (!do_validate_mem(s, j, step, fallback))\r\nbreak;\r\n}\r\nif (i != j) {\r\nif (!bad)\r\npr_cont(" excluding");\r\npr_cont(" %#05lx-%#05lx", i, j-1);\r\nsub_interval(&s_data->mem_db, i, j-i);\r\nbad += j-i;\r\n}\r\n}\r\npr_cont("%s\n", !bad ? " clean" : "");\r\nreturn num - bad;\r\n}\r\nstatic u_long inv_probe(struct resource_map *m, struct pcmcia_socket *s)\r\n{\r\nstruct socket_data *s_data = s->resource_data;\r\nu_long ok;\r\nif (m == &s_data->mem_db)\r\nreturn 0;\r\nok = inv_probe(m->next, s);\r\nif (ok) {\r\nif (m->base >= 0x100000)\r\nsub_interval(&s_data->mem_db, m->base, m->num);\r\nreturn ok;\r\n}\r\nif (m->base < 0x100000)\r\nreturn 0;\r\nreturn do_mem_probe(s, m->base, m->num, readable, checksum);\r\n}\r\nstatic int validate_mem(struct pcmcia_socket *s, unsigned int probe_mask)\r\n{\r\nstruct resource_map *m, mm;\r\nstatic unsigned char order[] = { 0xd0, 0xe0, 0xc0, 0xf0 };\r\nunsigned long b, i, ok = 0;\r\nstruct socket_data *s_data = s->resource_data;\r\nif (probe_mask & MEM_PROBE_HIGH) {\r\nif (inv_probe(s_data->mem_db.next, s) > 0)\r\nreturn 0;\r\nif (s_data->mem_db_valid.next != &s_data->mem_db_valid)\r\nreturn 0;\r\ndev_notice(&s->dev,\r\n"cs: warning: no high memory space available!\n");\r\nreturn -ENODEV;\r\n}\r\nfor (m = s_data->mem_db.next; m != &s_data->mem_db; m = mm.next) {\r\nmm = *m;\r\nif (mm.base >= 0x100000)\r\ncontinue;\r\nif ((mm.base | mm.num) & 0xffff) {\r\nok += do_mem_probe(s, mm.base, mm.num, readable,\r\nchecksum);\r\ncontinue;\r\n}\r\nfor (i = 0; i < 4; i++) {\r\nb = order[i] << 12;\r\nif ((b >= mm.base) && (b+0x10000 <= mm.base+mm.num)) {\r\nif (ok >= mem_limit)\r\nsub_interval(&s_data->mem_db, b, 0x10000);\r\nelse\r\nok += do_mem_probe(s, b, 0x10000,\r\nreadable, checksum);\r\n}\r\n}\r\n}\r\nif (ok > 0)\r\nreturn 0;\r\nreturn -ENODEV;\r\n}\r\nstatic int validate_mem(struct pcmcia_socket *s, unsigned int probe_mask)\r\n{\r\nstruct resource_map *m, mm;\r\nstruct socket_data *s_data = s->resource_data;\r\nunsigned long ok = 0;\r\nfor (m = s_data->mem_db.next; m != &s_data->mem_db; m = mm.next) {\r\nmm = *m;\r\nok += do_mem_probe(s, mm.base, mm.num, readable, checksum);\r\n}\r\nif (ok > 0)\r\nreturn 0;\r\nreturn -ENODEV;\r\n}\r\nstatic int pcmcia_nonstatic_validate_mem(struct pcmcia_socket *s)\r\n{\r\nstruct socket_data *s_data = s->resource_data;\r\nunsigned int probe_mask = MEM_PROBE_LOW;\r\nint ret;\r\nif (!probe_mem || !(s->state & SOCKET_PRESENT))\r\nreturn 0;\r\nif (s->features & SS_CAP_PAGE_REGS)\r\nprobe_mask = MEM_PROBE_HIGH;\r\nret = validate_mem(s, probe_mask);\r\nif (s_data->mem_db_valid.next != &s_data->mem_db_valid)\r\nreturn 0;\r\nreturn ret;\r\n}\r\nstatic resource_size_t pcmcia_common_align(struct pcmcia_align_data *align_data,\r\nresource_size_t start)\r\n{\r\nresource_size_t ret;\r\nret = (start & ~align_data->mask) + align_data->offset;\r\nif (ret < start)\r\nret += align_data->mask + 1;\r\nreturn ret;\r\n}\r\nstatic resource_size_t\r\npcmcia_align(void *align_data, const struct resource *res,\r\nresource_size_t size, resource_size_t align)\r\n{\r\nstruct pcmcia_align_data *data = align_data;\r\nstruct resource_map *m;\r\nresource_size_t start;\r\nstart = pcmcia_common_align(data, res->start);\r\nfor (m = data->map->next; m != data->map; m = m->next) {\r\nunsigned long map_start = m->base;\r\nunsigned long map_end = m->base + m->num - 1;\r\nif (start < map_start)\r\nstart = pcmcia_common_align(data, map_start);\r\nif (start >= res->end)\r\nbreak;\r\nif ((start + size - 1) <= map_end)\r\nbreak;\r\n}\r\nif (m == data->map)\r\nstart = res->end;\r\nreturn start;\r\n}\r\nstatic int __nonstatic_adjust_io_region(struct pcmcia_socket *s,\r\nunsigned long r_start,\r\nunsigned long r_end)\r\n{\r\nstruct resource_map *m;\r\nstruct socket_data *s_data = s->resource_data;\r\nint ret = -ENOMEM;\r\nfor (m = s_data->io_db.next; m != &s_data->io_db; m = m->next) {\r\nunsigned long start = m->base;\r\nunsigned long end = m->base + m->num - 1;\r\nif (start > r_start || r_end > end)\r\ncontinue;\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic struct resource *__nonstatic_find_io_region(struct pcmcia_socket *s,\r\nunsigned long base, int num,\r\nunsigned long align)\r\n{\r\nstruct resource *res = pcmcia_make_resource(0, num, IORESOURCE_IO,\r\ndev_name(&s->dev));\r\nstruct socket_data *s_data = s->resource_data;\r\nstruct pcmcia_align_data data;\r\nunsigned long min = base;\r\nint ret;\r\ndata.mask = align - 1;\r\ndata.offset = base & data.mask;\r\ndata.map = &s_data->io_db;\r\n#ifdef CONFIG_PCI\r\nif (s->cb_dev) {\r\nret = pci_bus_alloc_resource(s->cb_dev->bus, res, num, 1,\r\nmin, 0, pcmcia_align, &data);\r\n} else\r\n#endif\r\nret = allocate_resource(&ioport_resource, res, num, min, ~0UL,\r\n1, pcmcia_align, &data);\r\nif (ret != 0) {\r\nkfree(res);\r\nres = NULL;\r\n}\r\nreturn res;\r\n}\r\nstatic int nonstatic_find_io(struct pcmcia_socket *s, unsigned int attr,\r\nunsigned int *base, unsigned int num,\r\nunsigned int align, struct resource **parent)\r\n{\r\nint i, ret = 0;\r\nfor (i = 0; i < MAX_IO_WIN; i++) {\r\nif (!s->io[i].res)\r\ncontinue;\r\nif (!*base)\r\ncontinue;\r\nif ((s->io[i].res->start & (align-1)) == *base)\r\nreturn -EBUSY;\r\n}\r\nfor (i = 0; i < MAX_IO_WIN; i++) {\r\nstruct resource *res = s->io[i].res;\r\nunsigned int try;\r\nif (res && (res->flags & IORESOURCE_BITS) !=\r\n(attr & IORESOURCE_BITS))\r\ncontinue;\r\nif (!res) {\r\nif (align == 0)\r\nalign = 0x10000;\r\nres = s->io[i].res = __nonstatic_find_io_region(s,\r\n*base, num,\r\nalign);\r\nif (!res)\r\nreturn -EINVAL;\r\n*base = res->start;\r\ns->io[i].res->flags =\r\n((res->flags & ~IORESOURCE_BITS) |\r\n(attr & IORESOURCE_BITS));\r\ns->io[i].InUse = num;\r\n*parent = res;\r\nreturn 0;\r\n}\r\ntry = res->end + 1;\r\nif ((*base == 0) || (*base == try)) {\r\nret = __nonstatic_adjust_io_region(s, res->start,\r\nres->end + num);\r\nif (!ret) {\r\nret = adjust_resource(s->io[i].res, res->start,\r\nresource_size(res) + num);\r\nif (ret)\r\ncontinue;\r\n*base = try;\r\ns->io[i].InUse += num;\r\n*parent = res;\r\nreturn 0;\r\n}\r\n}\r\ntry = res->start - num;\r\nif ((*base == 0) || (*base == try)) {\r\nret = __nonstatic_adjust_io_region(s,\r\nres->start - num,\r\nres->end);\r\nif (!ret) {\r\nret = adjust_resource(s->io[i].res,\r\nres->start - num,\r\nresource_size(res) + num);\r\nif (ret)\r\ncontinue;\r\n*base = try;\r\ns->io[i].InUse += num;\r\n*parent = res;\r\nreturn 0;\r\n}\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic struct resource *nonstatic_find_mem_region(u_long base, u_long num,\r\nu_long align, int low, struct pcmcia_socket *s)\r\n{\r\nstruct resource *res = pcmcia_make_resource(0, num, IORESOURCE_MEM,\r\ndev_name(&s->dev));\r\nstruct socket_data *s_data = s->resource_data;\r\nstruct pcmcia_align_data data;\r\nunsigned long min, max;\r\nint ret, i, j;\r\nlow = low || !(s->features & SS_CAP_PAGE_REGS);\r\ndata.mask = align - 1;\r\ndata.offset = base & data.mask;\r\nfor (i = 0; i < 2; i++) {\r\ndata.map = &s_data->mem_db_valid;\r\nif (low) {\r\nmax = 0x100000UL;\r\nmin = base < max ? base : 0;\r\n} else {\r\nmax = ~0UL;\r\nmin = 0x100000UL + base;\r\n}\r\nfor (j = 0; j < 2; j++) {\r\n#ifdef CONFIG_PCI\r\nif (s->cb_dev) {\r\nret = pci_bus_alloc_resource(s->cb_dev->bus,\r\nres, num, 1, min, 0,\r\npcmcia_align, &data);\r\n} else\r\n#endif\r\n{\r\nret = allocate_resource(&iomem_resource,\r\nres, num, min, max, 1,\r\npcmcia_align, &data);\r\n}\r\nif (ret == 0)\r\nbreak;\r\ndata.map = &s_data->mem_db;\r\n}\r\nif (ret == 0 || low)\r\nbreak;\r\nlow = 1;\r\n}\r\nif (ret != 0) {\r\nkfree(res);\r\nres = NULL;\r\n}\r\nreturn res;\r\n}\r\nstatic int adjust_memory(struct pcmcia_socket *s, unsigned int action, unsigned long start, unsigned long end)\r\n{\r\nstruct socket_data *data = s->resource_data;\r\nunsigned long size = end - start + 1;\r\nint ret = 0;\r\nif (end < start)\r\nreturn -EINVAL;\r\nswitch (action) {\r\ncase ADD_MANAGED_RESOURCE:\r\nret = add_interval(&data->mem_db, start, size);\r\nif (!ret)\r\ndo_mem_probe(s, start, size, NULL, NULL);\r\nbreak;\r\ncase REMOVE_MANAGED_RESOURCE:\r\nret = sub_interval(&data->mem_db, start, size);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int adjust_io(struct pcmcia_socket *s, unsigned int action, unsigned long start, unsigned long end)\r\n{\r\nstruct socket_data *data = s->resource_data;\r\nunsigned long size;\r\nint ret = 0;\r\n#if defined(CONFIG_X86)\r\nif (start < 0x100)\r\nstart = 0x100;\r\n#endif\r\nsize = end - start + 1;\r\nif (end < start)\r\nreturn -EINVAL;\r\nif (end > IO_SPACE_LIMIT)\r\nreturn -EINVAL;\r\nswitch (action) {\r\ncase ADD_MANAGED_RESOURCE:\r\nif (add_interval(&data->io_db, start, size) != 0) {\r\nret = -EBUSY;\r\nbreak;\r\n}\r\n#ifdef CONFIG_PCMCIA_PROBE\r\nif (probe_io)\r\ndo_io_probe(s, start, size);\r\n#endif\r\nbreak;\r\ncase REMOVE_MANAGED_RESOURCE:\r\nsub_interval(&data->io_db, start, size);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic inline int nonstatic_autoadd_resources(struct pcmcia_socket *s)\r\n{\r\nreturn -ENODEV;\r\n}\r\nstatic int nonstatic_init(struct pcmcia_socket *s)\r\n{\r\nstruct socket_data *data;\r\ndata = kzalloc(sizeof(struct socket_data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->mem_db.next = &data->mem_db;\r\ndata->mem_db_valid.next = &data->mem_db_valid;\r\ndata->io_db.next = &data->io_db;\r\ns->resource_data = (void *) data;\r\nnonstatic_autoadd_resources(s);\r\nreturn 0;\r\n}\r\nstatic void nonstatic_release_resource_db(struct pcmcia_socket *s)\r\n{\r\nstruct socket_data *data = s->resource_data;\r\nstruct resource_map *p, *q;\r\nfor (p = data->mem_db_valid.next; p != &data->mem_db_valid; p = q) {\r\nq = p->next;\r\nkfree(p);\r\n}\r\nfor (p = data->mem_db.next; p != &data->mem_db; p = q) {\r\nq = p->next;\r\nkfree(p);\r\n}\r\nfor (p = data->io_db.next; p != &data->io_db; p = q) {\r\nq = p->next;\r\nkfree(p);\r\n}\r\n}\r\nstatic ssize_t show_io_db(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct pcmcia_socket *s = dev_get_drvdata(dev);\r\nstruct socket_data *data;\r\nstruct resource_map *p;\r\nssize_t ret = 0;\r\nmutex_lock(&s->ops_mutex);\r\ndata = s->resource_data;\r\nfor (p = data->io_db.next; p != &data->io_db; p = p->next) {\r\nif (ret > (PAGE_SIZE - 10))\r\ncontinue;\r\nret += snprintf(&buf[ret], (PAGE_SIZE - ret - 1),\r\n"0x%08lx - 0x%08lx\n",\r\n((unsigned long) p->base),\r\n((unsigned long) p->base + p->num - 1));\r\n}\r\nmutex_unlock(&s->ops_mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t store_io_db(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct pcmcia_socket *s = dev_get_drvdata(dev);\r\nunsigned long start_addr, end_addr;\r\nunsigned int add = ADD_MANAGED_RESOURCE;\r\nssize_t ret = 0;\r\nret = sscanf(buf, "+ 0x%lx - 0x%lx", &start_addr, &end_addr);\r\nif (ret != 2) {\r\nret = sscanf(buf, "- 0x%lx - 0x%lx", &start_addr, &end_addr);\r\nadd = REMOVE_MANAGED_RESOURCE;\r\nif (ret != 2) {\r\nret = sscanf(buf, "0x%lx - 0x%lx", &start_addr,\r\n&end_addr);\r\nadd = ADD_MANAGED_RESOURCE;\r\nif (ret != 2)\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (end_addr < start_addr)\r\nreturn -EINVAL;\r\nmutex_lock(&s->ops_mutex);\r\nret = adjust_io(s, add, start_addr, end_addr);\r\nmutex_unlock(&s->ops_mutex);\r\nreturn ret ? ret : count;\r\n}\r\nstatic ssize_t show_mem_db(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct pcmcia_socket *s = dev_get_drvdata(dev);\r\nstruct socket_data *data;\r\nstruct resource_map *p;\r\nssize_t ret = 0;\r\nmutex_lock(&s->ops_mutex);\r\ndata = s->resource_data;\r\nfor (p = data->mem_db_valid.next; p != &data->mem_db_valid;\r\np = p->next) {\r\nif (ret > (PAGE_SIZE - 10))\r\ncontinue;\r\nret += snprintf(&buf[ret], (PAGE_SIZE - ret - 1),\r\n"0x%08lx - 0x%08lx\n",\r\n((unsigned long) p->base),\r\n((unsigned long) p->base + p->num - 1));\r\n}\r\nfor (p = data->mem_db.next; p != &data->mem_db; p = p->next) {\r\nif (ret > (PAGE_SIZE - 10))\r\ncontinue;\r\nret += snprintf(&buf[ret], (PAGE_SIZE - ret - 1),\r\n"0x%08lx - 0x%08lx\n",\r\n((unsigned long) p->base),\r\n((unsigned long) p->base + p->num - 1));\r\n}\r\nmutex_unlock(&s->ops_mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t store_mem_db(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct pcmcia_socket *s = dev_get_drvdata(dev);\r\nunsigned long start_addr, end_addr;\r\nunsigned int add = ADD_MANAGED_RESOURCE;\r\nssize_t ret = 0;\r\nret = sscanf(buf, "+ 0x%lx - 0x%lx", &start_addr, &end_addr);\r\nif (ret != 2) {\r\nret = sscanf(buf, "- 0x%lx - 0x%lx", &start_addr, &end_addr);\r\nadd = REMOVE_MANAGED_RESOURCE;\r\nif (ret != 2) {\r\nret = sscanf(buf, "0x%lx - 0x%lx", &start_addr,\r\n&end_addr);\r\nadd = ADD_MANAGED_RESOURCE;\r\nif (ret != 2)\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (end_addr < start_addr)\r\nreturn -EINVAL;\r\nmutex_lock(&s->ops_mutex);\r\nret = adjust_memory(s, add, start_addr, end_addr);\r\nmutex_unlock(&s->ops_mutex);\r\nreturn ret ? ret : count;\r\n}\r\nstatic int pccard_sysfs_add_rsrc(struct device *dev,\r\nstruct class_interface *class_intf)\r\n{\r\nstruct pcmcia_socket *s = dev_get_drvdata(dev);\r\nif (s->resource_ops != &pccard_nonstatic_ops)\r\nreturn 0;\r\nreturn sysfs_create_group(&dev->kobj, &rsrc_attributes);\r\n}\r\nstatic void pccard_sysfs_remove_rsrc(struct device *dev,\r\nstruct class_interface *class_intf)\r\n{\r\nstruct pcmcia_socket *s = dev_get_drvdata(dev);\r\nif (s->resource_ops != &pccard_nonstatic_ops)\r\nreturn;\r\nsysfs_remove_group(&dev->kobj, &rsrc_attributes);\r\n}\r\nstatic int __init nonstatic_sysfs_init(void)\r\n{\r\nreturn class_interface_register(&pccard_rsrc_interface);\r\n}\r\nstatic void __exit nonstatic_sysfs_exit(void)\r\n{\r\nclass_interface_unregister(&pccard_rsrc_interface);\r\n}
