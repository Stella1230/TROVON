static void pblk_gc_free_gc_rq(struct pblk_gc_rq *gc_rq)\r\n{\r\nvfree(gc_rq->data);\r\nkfree(gc_rq);\r\n}\r\nstatic int pblk_gc_write(struct pblk *pblk)\r\n{\r\nstruct pblk_gc *gc = &pblk->gc;\r\nstruct pblk_gc_rq *gc_rq, *tgc_rq;\r\nLIST_HEAD(w_list);\r\nspin_lock(&gc->w_lock);\r\nif (list_empty(&gc->w_list)) {\r\nspin_unlock(&gc->w_lock);\r\nreturn 1;\r\n}\r\nlist_cut_position(&w_list, &gc->w_list, gc->w_list.prev);\r\ngc->w_entries = 0;\r\nspin_unlock(&gc->w_lock);\r\nlist_for_each_entry_safe(gc_rq, tgc_rq, &w_list, list) {\r\npblk_write_gc_to_cache(pblk, gc_rq->data, gc_rq->lba_list,\r\ngc_rq->nr_secs, gc_rq->secs_to_gc,\r\ngc_rq->line, PBLK_IOTYPE_GC);\r\nlist_del(&gc_rq->list);\r\nkref_put(&gc_rq->line->ref, pblk_line_put);\r\npblk_gc_free_gc_rq(gc_rq);\r\n}\r\nreturn 0;\r\n}\r\nstatic void pblk_gc_writer_kick(struct pblk_gc *gc)\r\n{\r\nwake_up_process(gc->gc_writer_ts);\r\n}\r\nstatic int pblk_gc_move_valid_secs(struct pblk *pblk, struct pblk_gc_rq *gc_rq)\r\n{\r\nstruct nvm_tgt_dev *dev = pblk->dev;\r\nstruct nvm_geo *geo = &dev->geo;\r\nstruct pblk_gc *gc = &pblk->gc;\r\nstruct pblk_line *line = gc_rq->line;\r\nvoid *data;\r\nunsigned int secs_to_gc;\r\nint ret = 0;\r\ndata = vmalloc(gc_rq->nr_secs * geo->sec_size);\r\nif (!data) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nif (pblk_submit_read_gc(pblk, gc_rq->lba_list, data, gc_rq->nr_secs,\r\n&secs_to_gc, line)) {\r\nret = -EFAULT;\r\ngoto free_data;\r\n}\r\nif (!secs_to_gc)\r\ngoto free_rq;\r\ngc_rq->data = data;\r\ngc_rq->secs_to_gc = secs_to_gc;\r\nretry:\r\nspin_lock(&gc->w_lock);\r\nif (gc->w_entries >= PBLK_GC_W_QD) {\r\nspin_unlock(&gc->w_lock);\r\npblk_gc_writer_kick(&pblk->gc);\r\nusleep_range(128, 256);\r\ngoto retry;\r\n}\r\ngc->w_entries++;\r\nlist_add_tail(&gc_rq->list, &gc->w_list);\r\nspin_unlock(&gc->w_lock);\r\npblk_gc_writer_kick(&pblk->gc);\r\nreturn 0;\r\nfree_rq:\r\nkfree(gc_rq);\r\nfree_data:\r\nvfree(data);\r\nout:\r\nkref_put(&line->ref, pblk_line_put);\r\nreturn ret;\r\n}\r\nstatic void pblk_put_line_back(struct pblk *pblk, struct pblk_line *line)\r\n{\r\nstruct pblk_line_mgmt *l_mg = &pblk->l_mg;\r\nstruct list_head *move_list;\r\nspin_lock(&line->lock);\r\nWARN_ON(line->state != PBLK_LINESTATE_GC);\r\nline->state = PBLK_LINESTATE_CLOSED;\r\nmove_list = pblk_line_gc_list(pblk, line);\r\nspin_unlock(&line->lock);\r\nif (move_list) {\r\nspin_lock(&l_mg->gc_lock);\r\nlist_add_tail(&line->list, move_list);\r\nspin_unlock(&l_mg->gc_lock);\r\n}\r\n}\r\nstatic void pblk_gc_line_ws(struct work_struct *work)\r\n{\r\nstruct pblk_line_ws *line_rq_ws = container_of(work,\r\nstruct pblk_line_ws, ws);\r\nstruct pblk *pblk = line_rq_ws->pblk;\r\nstruct pblk_gc *gc = &pblk->gc;\r\nstruct pblk_line *line = line_rq_ws->line;\r\nstruct pblk_gc_rq *gc_rq = line_rq_ws->priv;\r\nup(&gc->gc_sem);\r\nif (pblk_gc_move_valid_secs(pblk, gc_rq)) {\r\npr_err("pblk: could not GC all sectors: line:%d (%d/%d)\n",\r\nline->id, *line->vsc,\r\ngc_rq->nr_secs);\r\n}\r\nmempool_free(line_rq_ws, pblk->line_ws_pool);\r\n}\r\nstatic void pblk_gc_line_prepare_ws(struct work_struct *work)\r\n{\r\nstruct pblk_line_ws *line_ws = container_of(work, struct pblk_line_ws,\r\nws);\r\nstruct pblk *pblk = line_ws->pblk;\r\nstruct pblk_line *line = line_ws->line;\r\nstruct pblk_line_mgmt *l_mg = &pblk->l_mg;\r\nstruct pblk_line_meta *lm = &pblk->lm;\r\nstruct pblk_gc *gc = &pblk->gc;\r\nstruct line_emeta *emeta_buf;\r\nstruct pblk_line_ws *line_rq_ws;\r\nstruct pblk_gc_rq *gc_rq;\r\n__le64 *lba_list;\r\nint sec_left, nr_secs, bit;\r\nint ret;\r\nemeta_buf = pblk_malloc(lm->emeta_len[0], l_mg->emeta_alloc_type,\r\nGFP_KERNEL);\r\nif (!emeta_buf) {\r\npr_err("pblk: cannot use GC emeta\n");\r\nreturn;\r\n}\r\nret = pblk_line_read_emeta(pblk, line, emeta_buf);\r\nif (ret) {\r\npr_err("pblk: line %d read emeta failed (%d)\n", line->id, ret);\r\ngoto fail_free_emeta;\r\n}\r\nlba_list = pblk_recov_get_lba_list(pblk, emeta_buf);\r\nif (!lba_list) {\r\npr_err("pblk: could not interpret emeta (line %d)\n", line->id);\r\ngoto fail_free_emeta;\r\n}\r\nsec_left = pblk_line_vsc(line);\r\nif (sec_left < 0) {\r\npr_err("pblk: corrupted GC line (%d)\n", line->id);\r\ngoto fail_free_emeta;\r\n}\r\nbit = -1;\r\nnext_rq:\r\ngc_rq = kmalloc(sizeof(struct pblk_gc_rq), GFP_KERNEL);\r\nif (!gc_rq)\r\ngoto fail_free_emeta;\r\nnr_secs = 0;\r\ndo {\r\nbit = find_next_zero_bit(line->invalid_bitmap, lm->sec_per_line,\r\nbit + 1);\r\nif (bit > line->emeta_ssec)\r\nbreak;\r\ngc_rq->lba_list[nr_secs++] = le64_to_cpu(lba_list[bit]);\r\n} while (nr_secs < pblk->max_write_pgs);\r\nif (unlikely(!nr_secs)) {\r\nkfree(gc_rq);\r\ngoto out;\r\n}\r\ngc_rq->nr_secs = nr_secs;\r\ngc_rq->line = line;\r\nline_rq_ws = mempool_alloc(pblk->line_ws_pool, GFP_KERNEL);\r\nif (!line_rq_ws)\r\ngoto fail_free_gc_rq;\r\nline_rq_ws->pblk = pblk;\r\nline_rq_ws->line = line;\r\nline_rq_ws->priv = gc_rq;\r\ndown(&gc->gc_sem);\r\nkref_get(&line->ref);\r\nINIT_WORK(&line_rq_ws->ws, pblk_gc_line_ws);\r\nqueue_work(gc->gc_line_reader_wq, &line_rq_ws->ws);\r\nsec_left -= nr_secs;\r\nif (sec_left > 0)\r\ngoto next_rq;\r\nout:\r\npblk_mfree(emeta_buf, l_mg->emeta_alloc_type);\r\nmempool_free(line_ws, pblk->line_ws_pool);\r\nkref_put(&line->ref, pblk_line_put);\r\natomic_dec(&gc->inflight_gc);\r\nreturn;\r\nfail_free_gc_rq:\r\nkfree(gc_rq);\r\nfail_free_emeta:\r\npblk_mfree(emeta_buf, l_mg->emeta_alloc_type);\r\npblk_put_line_back(pblk, line);\r\nkref_put(&line->ref, pblk_line_put);\r\nmempool_free(line_ws, pblk->line_ws_pool);\r\natomic_dec(&gc->inflight_gc);\r\npr_err("pblk: Failed to GC line %d\n", line->id);\r\n}\r\nstatic int pblk_gc_line(struct pblk *pblk, struct pblk_line *line)\r\n{\r\nstruct pblk_gc *gc = &pblk->gc;\r\nstruct pblk_line_ws *line_ws;\r\npr_debug("pblk: line '%d' being reclaimed for GC\n", line->id);\r\nline_ws = mempool_alloc(pblk->line_ws_pool, GFP_KERNEL);\r\nif (!line_ws)\r\nreturn -ENOMEM;\r\nline_ws->pblk = pblk;\r\nline_ws->line = line;\r\nINIT_WORK(&line_ws->ws, pblk_gc_line_prepare_ws);\r\nqueue_work(gc->gc_reader_wq, &line_ws->ws);\r\nreturn 0;\r\n}\r\nstatic int pblk_gc_read(struct pblk *pblk)\r\n{\r\nstruct pblk_gc *gc = &pblk->gc;\r\nstruct pblk_line *line;\r\nspin_lock(&gc->r_lock);\r\nif (list_empty(&gc->r_list)) {\r\nspin_unlock(&gc->r_lock);\r\nreturn 1;\r\n}\r\nline = list_first_entry(&gc->r_list, struct pblk_line, list);\r\nlist_del(&line->list);\r\nspin_unlock(&gc->r_lock);\r\npblk_gc_kick(pblk);\r\nif (pblk_gc_line(pblk, line))\r\npr_err("pblk: failed to GC line %d\n", line->id);\r\nreturn 0;\r\n}\r\nstatic void pblk_gc_reader_kick(struct pblk_gc *gc)\r\n{\r\nwake_up_process(gc->gc_reader_ts);\r\n}\r\nstatic struct pblk_line *pblk_gc_get_victim_line(struct pblk *pblk,\r\nstruct list_head *group_list)\r\n{\r\nstruct pblk_line *line, *victim;\r\nint line_vsc, victim_vsc;\r\nvictim = list_first_entry(group_list, struct pblk_line, list);\r\nlist_for_each_entry(line, group_list, list) {\r\nline_vsc = le32_to_cpu(*line->vsc);\r\nvictim_vsc = le32_to_cpu(*victim->vsc);\r\nif (line_vsc < victim_vsc)\r\nvictim = line;\r\n}\r\nreturn victim;\r\n}\r\nstatic bool pblk_gc_should_run(struct pblk_gc *gc, struct pblk_rl *rl)\r\n{\r\nunsigned int nr_blocks_free, nr_blocks_need;\r\nnr_blocks_need = pblk_rl_high_thrs(rl);\r\nnr_blocks_free = pblk_rl_nr_free_blks(rl);\r\nreturn ((gc->gc_active) && (nr_blocks_need > nr_blocks_free));\r\n}\r\nstatic void pblk_gc_run(struct pblk *pblk)\r\n{\r\nstruct pblk_line_mgmt *l_mg = &pblk->l_mg;\r\nstruct pblk_gc *gc = &pblk->gc;\r\nstruct pblk_line *line;\r\nstruct list_head *group_list;\r\nbool run_gc;\r\nint inflight_gc, gc_group = 0, prev_group = 0;\r\ndo {\r\nspin_lock(&l_mg->gc_lock);\r\nif (list_empty(&l_mg->gc_full_list)) {\r\nspin_unlock(&l_mg->gc_lock);\r\nbreak;\r\n}\r\nline = list_first_entry(&l_mg->gc_full_list,\r\nstruct pblk_line, list);\r\nspin_lock(&line->lock);\r\nWARN_ON(line->state != PBLK_LINESTATE_CLOSED);\r\nline->state = PBLK_LINESTATE_GC;\r\nspin_unlock(&line->lock);\r\nlist_del(&line->list);\r\nspin_unlock(&l_mg->gc_lock);\r\nkref_put(&line->ref, pblk_line_put);\r\n} while (1);\r\nrun_gc = pblk_gc_should_run(&pblk->gc, &pblk->rl);\r\nif (!run_gc || (atomic_read(&gc->inflight_gc) >= PBLK_GC_L_QD))\r\nreturn;\r\nnext_gc_group:\r\ngroup_list = l_mg->gc_lists[gc_group++];\r\ndo {\r\nspin_lock(&l_mg->gc_lock);\r\nif (list_empty(group_list)) {\r\nspin_unlock(&l_mg->gc_lock);\r\nbreak;\r\n}\r\nline = pblk_gc_get_victim_line(pblk, group_list);\r\nspin_lock(&line->lock);\r\nWARN_ON(line->state != PBLK_LINESTATE_CLOSED);\r\nline->state = PBLK_LINESTATE_GC;\r\nspin_unlock(&line->lock);\r\nlist_del(&line->list);\r\nspin_unlock(&l_mg->gc_lock);\r\nspin_lock(&gc->r_lock);\r\nlist_add_tail(&line->list, &gc->r_list);\r\nspin_unlock(&gc->r_lock);\r\ninflight_gc = atomic_inc_return(&gc->inflight_gc);\r\npblk_gc_reader_kick(gc);\r\nprev_group = 1;\r\nrun_gc = pblk_gc_should_run(&pblk->gc, &pblk->rl);\r\nif (!run_gc || inflight_gc >= PBLK_GC_L_QD)\r\nbreak;\r\n} while (1);\r\nif (!prev_group && pblk->rl.rb_state > gc_group &&\r\ngc_group < PBLK_GC_NR_LISTS)\r\ngoto next_gc_group;\r\n}\r\nvoid pblk_gc_kick(struct pblk *pblk)\r\n{\r\nstruct pblk_gc *gc = &pblk->gc;\r\nwake_up_process(gc->gc_ts);\r\npblk_gc_writer_kick(gc);\r\npblk_gc_reader_kick(gc);\r\nmod_timer(&gc->gc_timer, jiffies + msecs_to_jiffies(GC_TIME_MSECS));\r\n}\r\nstatic void pblk_gc_timer(unsigned long data)\r\n{\r\nstruct pblk *pblk = (struct pblk *)data;\r\npblk_gc_kick(pblk);\r\n}\r\nstatic int pblk_gc_ts(void *data)\r\n{\r\nstruct pblk *pblk = data;\r\nwhile (!kthread_should_stop()) {\r\npblk_gc_run(pblk);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nio_schedule();\r\n}\r\nreturn 0;\r\n}\r\nstatic int pblk_gc_writer_ts(void *data)\r\n{\r\nstruct pblk *pblk = data;\r\nwhile (!kthread_should_stop()) {\r\nif (!pblk_gc_write(pblk))\r\ncontinue;\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nio_schedule();\r\n}\r\nreturn 0;\r\n}\r\nstatic int pblk_gc_reader_ts(void *data)\r\n{\r\nstruct pblk *pblk = data;\r\nwhile (!kthread_should_stop()) {\r\nif (!pblk_gc_read(pblk))\r\ncontinue;\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nio_schedule();\r\n}\r\nreturn 0;\r\n}\r\nstatic void pblk_gc_start(struct pblk *pblk)\r\n{\r\npblk->gc.gc_active = 1;\r\npr_debug("pblk: gc start\n");\r\n}\r\nvoid pblk_gc_should_start(struct pblk *pblk)\r\n{\r\nstruct pblk_gc *gc = &pblk->gc;\r\nif (gc->gc_enabled && !gc->gc_active)\r\npblk_gc_start(pblk);\r\npblk_gc_kick(pblk);\r\n}\r\nstatic void pblk_gc_stop(struct pblk *pblk, int flush_wq)\r\n{\r\npblk->gc.gc_active = 0;\r\npr_debug("pblk: gc stop\n");\r\n}\r\nvoid pblk_gc_should_stop(struct pblk *pblk)\r\n{\r\nstruct pblk_gc *gc = &pblk->gc;\r\nif (gc->gc_active && !gc->gc_forced)\r\npblk_gc_stop(pblk, 0);\r\n}\r\nvoid pblk_gc_sysfs_state_show(struct pblk *pblk, int *gc_enabled,\r\nint *gc_active)\r\n{\r\nstruct pblk_gc *gc = &pblk->gc;\r\nspin_lock(&gc->lock);\r\n*gc_enabled = gc->gc_enabled;\r\n*gc_active = gc->gc_active;\r\nspin_unlock(&gc->lock);\r\n}\r\nint pblk_gc_sysfs_force(struct pblk *pblk, int force)\r\n{\r\nstruct pblk_gc *gc = &pblk->gc;\r\nif (force < 0 || force > 1)\r\nreturn -EINVAL;\r\nspin_lock(&gc->lock);\r\ngc->gc_forced = force;\r\nif (force)\r\ngc->gc_enabled = 1;\r\nelse\r\ngc->gc_enabled = 0;\r\nspin_unlock(&gc->lock);\r\npblk_gc_should_start(pblk);\r\nreturn 0;\r\n}\r\nint pblk_gc_init(struct pblk *pblk)\r\n{\r\nstruct pblk_gc *gc = &pblk->gc;\r\nint ret;\r\ngc->gc_ts = kthread_create(pblk_gc_ts, pblk, "pblk-gc-ts");\r\nif (IS_ERR(gc->gc_ts)) {\r\npr_err("pblk: could not allocate GC main kthread\n");\r\nreturn PTR_ERR(gc->gc_ts);\r\n}\r\ngc->gc_writer_ts = kthread_create(pblk_gc_writer_ts, pblk,\r\n"pblk-gc-writer-ts");\r\nif (IS_ERR(gc->gc_writer_ts)) {\r\npr_err("pblk: could not allocate GC writer kthread\n");\r\nret = PTR_ERR(gc->gc_writer_ts);\r\ngoto fail_free_main_kthread;\r\n}\r\ngc->gc_reader_ts = kthread_create(pblk_gc_reader_ts, pblk,\r\n"pblk-gc-reader-ts");\r\nif (IS_ERR(gc->gc_reader_ts)) {\r\npr_err("pblk: could not allocate GC reader kthread\n");\r\nret = PTR_ERR(gc->gc_reader_ts);\r\ngoto fail_free_writer_kthread;\r\n}\r\nsetup_timer(&gc->gc_timer, pblk_gc_timer, (unsigned long)pblk);\r\nmod_timer(&gc->gc_timer, jiffies + msecs_to_jiffies(GC_TIME_MSECS));\r\ngc->gc_active = 0;\r\ngc->gc_forced = 0;\r\ngc->gc_enabled = 1;\r\ngc->w_entries = 0;\r\natomic_set(&gc->inflight_gc, 0);\r\ngc->gc_line_reader_wq = alloc_workqueue("pblk-gc-line-reader-wq",\r\nWQ_MEM_RECLAIM | WQ_UNBOUND, PBLK_GC_MAX_READERS);\r\nif (!gc->gc_line_reader_wq) {\r\npr_err("pblk: could not allocate GC line reader workqueue\n");\r\nret = -ENOMEM;\r\ngoto fail_free_reader_kthread;\r\n}\r\ngc->gc_reader_wq = alloc_workqueue("pblk-gc-line_wq",\r\nWQ_MEM_RECLAIM | WQ_UNBOUND, 1);\r\nif (!gc->gc_reader_wq) {\r\npr_err("pblk: could not allocate GC reader workqueue\n");\r\nret = -ENOMEM;\r\ngoto fail_free_reader_line_wq;\r\n}\r\nspin_lock_init(&gc->lock);\r\nspin_lock_init(&gc->w_lock);\r\nspin_lock_init(&gc->r_lock);\r\nsema_init(&gc->gc_sem, 128);\r\nINIT_LIST_HEAD(&gc->w_list);\r\nINIT_LIST_HEAD(&gc->r_list);\r\nreturn 0;\r\nfail_free_reader_line_wq:\r\ndestroy_workqueue(gc->gc_line_reader_wq);\r\nfail_free_reader_kthread:\r\nkthread_stop(gc->gc_reader_ts);\r\nfail_free_writer_kthread:\r\nkthread_stop(gc->gc_writer_ts);\r\nfail_free_main_kthread:\r\nkthread_stop(gc->gc_ts);\r\nreturn ret;\r\n}\r\nvoid pblk_gc_exit(struct pblk *pblk)\r\n{\r\nstruct pblk_gc *gc = &pblk->gc;\r\nflush_workqueue(gc->gc_reader_wq);\r\nflush_workqueue(gc->gc_line_reader_wq);\r\ndel_timer(&gc->gc_timer);\r\npblk_gc_stop(pblk, 1);\r\nif (gc->gc_ts)\r\nkthread_stop(gc->gc_ts);\r\nif (gc->gc_reader_wq)\r\ndestroy_workqueue(gc->gc_reader_wq);\r\nif (gc->gc_line_reader_wq)\r\ndestroy_workqueue(gc->gc_line_reader_wq);\r\nif (gc->gc_writer_ts)\r\nkthread_stop(gc->gc_writer_ts);\r\nif (gc->gc_reader_ts)\r\nkthread_stop(gc->gc_reader_ts);\r\n}
