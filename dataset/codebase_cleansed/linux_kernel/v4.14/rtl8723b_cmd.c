static u8 _is_fw_read_cmd_down(struct adapter *padapter, u8 msgbox_num)\r\n{\r\nu8 read_down = false;\r\nint retry_cnts = 100;\r\nu8 valid;\r\ndo {\r\nvalid = rtw_read8(padapter, REG_HMETFR) & BIT(msgbox_num);\r\nif (0 == valid) {\r\nread_down = true;\r\n}\r\n#ifdef CONFIG_WOWLAN\r\nelse\r\nmsleep(1);\r\n#endif\r\n} while ((!read_down) && (retry_cnts--));\r\nreturn read_down;\r\n}\r\ns32 FillH2CCmd8723B(struct adapter *padapter, u8 ElementID, u32 CmdLen, u8 *pCmdBuffer)\r\n{\r\nu8 h2c_box_num;\r\nu32 msgbox_addr;\r\nu32 msgbox_ex_addr = 0;\r\nstruct hal_com_data *pHalData;\r\nu32 h2c_cmd = 0;\r\nu32 h2c_cmd_ex = 0;\r\ns32 ret = _FAIL;\r\npadapter = GET_PRIMARY_ADAPTER(padapter);\r\npHalData = GET_HAL_DATA(padapter);\r\nif (mutex_lock_interruptible(&(adapter_to_dvobj(padapter)->h2c_fwcmd_mutex)))\r\nreturn ret;\r\nif (!pCmdBuffer) {\r\ngoto exit;\r\n}\r\nif (CmdLen > RTL8723B_MAX_CMD_LEN) {\r\ngoto exit;\r\n}\r\nif (padapter->bSurpriseRemoved == true)\r\ngoto exit;\r\ndo {\r\nh2c_box_num = pHalData->LastHMEBoxNum;\r\nif (!_is_fw_read_cmd_down(padapter, h2c_box_num)) {\r\nDBG_8192C(" fw read cmd failed...\n");\r\ngoto exit;\r\n}\r\nif (CmdLen <= 3)\r\nmemcpy((u8 *)(&h2c_cmd)+1, pCmdBuffer, CmdLen);\r\nelse {\r\nmemcpy((u8 *)(&h2c_cmd)+1, pCmdBuffer, 3);\r\nmemcpy((u8 *)(&h2c_cmd_ex), pCmdBuffer+3, CmdLen-3);\r\n}\r\n*(u8 *)(&h2c_cmd) |= ElementID;\r\nif (CmdLen > 3) {\r\nmsgbox_ex_addr = REG_HMEBOX_EXT0_8723B + (h2c_box_num*RTL8723B_EX_MESSAGE_BOX_SIZE);\r\nrtw_write32(padapter, msgbox_ex_addr, h2c_cmd_ex);\r\n}\r\nmsgbox_addr = REG_HMEBOX_0 + (h2c_box_num*MESSAGE_BOX_SIZE);\r\nrtw_write32(padapter, msgbox_addr, h2c_cmd);\r\npHalData->LastHMEBoxNum = (h2c_box_num+1) % MAX_H2C_BOX_NUMS;\r\n} while (0);\r\nret = _SUCCESS;\r\nexit:\r\nmutex_unlock(&(adapter_to_dvobj(padapter)->h2c_fwcmd_mutex));\r\nreturn ret;\r\n}\r\nstatic void ConstructBeacon(struct adapter *padapter, u8 *pframe, u32 *pLength)\r\n{\r\nstruct ieee80211_hdr *pwlanhdr;\r\n__le16 *fctrl;\r\nu32 rate_len, pktlen;\r\nstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nstruct wlan_bssid_ex *cur_network = &(pmlmeinfo->network);\r\nu8 bc_addr[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\r\npwlanhdr = (struct ieee80211_hdr *)pframe;\r\nfctrl = &(pwlanhdr->frame_control);\r\n*(fctrl) = 0;\r\nmemcpy(pwlanhdr->addr1, bc_addr, ETH_ALEN);\r\nmemcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);\r\nmemcpy(pwlanhdr->addr3, get_my_bssid(cur_network), ETH_ALEN);\r\nSetSeqNum(pwlanhdr, 0);\r\nSetFrameSubType(pframe, WIFI_BEACON);\r\npframe += sizeof(struct ieee80211_hdr_3addr);\r\npktlen = sizeof (struct ieee80211_hdr_3addr);\r\npframe += 8;\r\npktlen += 8;\r\nmemcpy(pframe, (unsigned char *)(rtw_get_beacon_interval_from_ie(cur_network->IEs)), 2);\r\npframe += 2;\r\npktlen += 2;\r\nmemcpy(pframe, (unsigned char *)(rtw_get_capability_from_ie(cur_network->IEs)), 2);\r\npframe += 2;\r\npktlen += 2;\r\nif ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE) {\r\npktlen += cur_network->IELength - sizeof(struct ndis_802_11_fix_ie);\r\nmemcpy(pframe, cur_network->IEs+sizeof(struct ndis_802_11_fix_ie), pktlen);\r\ngoto _ConstructBeacon;\r\n}\r\npframe = rtw_set_ie(pframe, _SSID_IE_, cur_network->Ssid.SsidLength, cur_network->Ssid.Ssid, &pktlen);\r\nrate_len = rtw_get_rateset_len(cur_network->SupportedRates);\r\npframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_, ((rate_len > 8) ? 8 : rate_len), cur_network->SupportedRates, &pktlen);\r\npframe = rtw_set_ie(pframe, _DSSET_IE_, 1, (unsigned char *)&(cur_network->Configuration.DSConfig), &pktlen);\r\nif ((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) {\r\nu32 ATIMWindow;\r\nATIMWindow = 0;\r\npframe = rtw_set_ie(pframe, _IBSS_PARA_IE_, 2, (unsigned char *)(&ATIMWindow), &pktlen);\r\n}\r\nif (rate_len > 8)\r\npframe = rtw_set_ie(pframe, _EXT_SUPPORTEDRATES_IE_, (rate_len - 8), (cur_network->SupportedRates + 8), &pktlen);\r\n_ConstructBeacon:\r\nif ((pktlen + TXDESC_SIZE) > 512) {\r\nDBG_871X("beacon frame too large\n");\r\nreturn;\r\n}\r\n*pLength = pktlen;\r\n}\r\nstatic void ConstructPSPoll(struct adapter *padapter, u8 *pframe, u32 *pLength)\r\n{\r\nstruct ieee80211_hdr *pwlanhdr;\r\n__le16 *fctrl;\r\nstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\npwlanhdr = (struct ieee80211_hdr *)pframe;\r\nfctrl = &(pwlanhdr->frame_control);\r\n*(fctrl) = 0;\r\nSetPwrMgt(fctrl);\r\nSetFrameSubType(pframe, WIFI_PSPOLL);\r\nSetDuration(pframe, (pmlmeinfo->aid | 0xc000));\r\nmemcpy(pwlanhdr->addr1, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);\r\nmemcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);\r\n*pLength = 16;\r\n}\r\nstatic void ConstructNullFunctionData(\r\nstruct adapter *padapter,\r\nu8 *pframe,\r\nu32 *pLength,\r\nu8 *StaAddr,\r\nu8 bQoS,\r\nu8 AC,\r\nu8 bEosp,\r\nu8 bForcePowerSave\r\n)\r\n{\r\nstruct ieee80211_hdr *pwlanhdr;\r\n__le16 *fctrl;\r\nu32 pktlen;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct wlan_network *cur_network = &pmlmepriv->cur_network;\r\nstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\npwlanhdr = (struct ieee80211_hdr *)pframe;\r\nfctrl = &pwlanhdr->frame_control;\r\n*(fctrl) = 0;\r\nif (bForcePowerSave)\r\nSetPwrMgt(fctrl);\r\nswitch (cur_network->network.InfrastructureMode) {\r\ncase Ndis802_11Infrastructure:\r\nSetToDs(fctrl);\r\nmemcpy(pwlanhdr->addr1, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);\r\nmemcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);\r\nmemcpy(pwlanhdr->addr3, StaAddr, ETH_ALEN);\r\nbreak;\r\ncase Ndis802_11APMode:\r\nSetFrDs(fctrl);\r\nmemcpy(pwlanhdr->addr1, StaAddr, ETH_ALEN);\r\nmemcpy(pwlanhdr->addr2, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);\r\nmemcpy(pwlanhdr->addr3, myid(&(padapter->eeprompriv)), ETH_ALEN);\r\nbreak;\r\ncase Ndis802_11IBSS:\r\ndefault:\r\nmemcpy(pwlanhdr->addr1, StaAddr, ETH_ALEN);\r\nmemcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);\r\nmemcpy(pwlanhdr->addr3, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);\r\nbreak;\r\n}\r\nSetSeqNum(pwlanhdr, 0);\r\nif (bQoS == true) {\r\nstruct ieee80211_qos_hdr *pwlanqoshdr;\r\nSetFrameSubType(pframe, WIFI_QOS_DATA_NULL);\r\npwlanqoshdr = (struct ieee80211_qos_hdr *)pframe;\r\nSetPriority(&pwlanqoshdr->qos_ctrl, AC);\r\nSetEOSP(&pwlanqoshdr->qos_ctrl, bEosp);\r\npktlen = sizeof(struct ieee80211_qos_hdr);\r\n} else {\r\nSetFrameSubType(pframe, WIFI_DATA_NULL);\r\npktlen = sizeof(struct ieee80211_hdr_3addr);\r\n}\r\n*pLength = pktlen;\r\n}\r\nstatic void ConstructARPResponse(\r\nstruct adapter *padapter,\r\nu8 *pframe,\r\nu32 *pLength,\r\nu8 *pIPAddress\r\n)\r\n{\r\nstruct ieee80211_hdr *pwlanhdr;\r\n__le16 *fctrl;\r\nstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nstatic u8 ARPLLCHeader[8] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0x00, 0x08, 0x06};\r\nu8 *pARPRspPkt = pframe;\r\nu8 *payload = pframe;\r\nu8 EncryptionHeadOverhead = 0;\r\npwlanhdr = (struct ieee80211_hdr *)pframe;\r\nfctrl = &pwlanhdr->frame_control;\r\n*(fctrl) = 0;\r\nSetFrameType(fctrl, WIFI_DATA);\r\nSetToDs(fctrl);\r\nmemcpy(pwlanhdr->addr1, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);\r\nmemcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);\r\nmemcpy(pwlanhdr->addr3, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);\r\nSetSeqNum(pwlanhdr, 0);\r\nSetDuration(pwlanhdr, 0);\r\n*pLength = 24;\r\nswitch (psecuritypriv->dot11PrivacyAlgrthm) {\r\ncase _WEP40_:\r\ncase _WEP104_:\r\nEncryptionHeadOverhead = 4;\r\nbreak;\r\ncase _TKIP_:\r\nEncryptionHeadOverhead = 8;\r\nbreak;\r\ncase _AES_:\r\nEncryptionHeadOverhead = 8;\r\nbreak;\r\ndefault:\r\nEncryptionHeadOverhead = 0;\r\n}\r\nif (EncryptionHeadOverhead > 0) {\r\nmemset(&(pframe[*pLength]), 0, EncryptionHeadOverhead);\r\n*pLength += EncryptionHeadOverhead;\r\nSetPrivacy(fctrl);\r\n}\r\npARPRspPkt = (u8 *)(pframe + *pLength);\r\npayload = pARPRspPkt;\r\nmemcpy(pARPRspPkt, ARPLLCHeader, 8);\r\n*pLength += 8;\r\npARPRspPkt += 8;\r\nSET_ARP_PKT_HW(pARPRspPkt, 0x0100);\r\nSET_ARP_PKT_PROTOCOL(pARPRspPkt, 0x0008);\r\nSET_ARP_PKT_HW_ADDR_LEN(pARPRspPkt, 6);\r\nSET_ARP_PKT_PROTOCOL_ADDR_LEN(pARPRspPkt, 4);\r\nSET_ARP_PKT_OPERATION(pARPRspPkt, 0x0200);\r\nSET_ARP_PKT_SENDER_MAC_ADDR(pARPRspPkt, myid(&(padapter->eeprompriv)));\r\nSET_ARP_PKT_SENDER_IP_ADDR(pARPRspPkt, pIPAddress);\r\n{\r\nSET_ARP_PKT_TARGET_MAC_ADDR(pARPRspPkt, get_my_bssid(&(pmlmeinfo->network)));\r\nSET_ARP_PKT_TARGET_IP_ADDR(pARPRspPkt, pIPAddress);\r\nDBG_871X("%s Target Mac Addr:" MAC_FMT "\n", __func__, MAC_ARG(get_my_bssid(&(pmlmeinfo->network))));\r\nDBG_871X("%s Target IP Addr" IP_FMT "\n", __func__, IP_ARG(pIPAddress));\r\n}\r\n*pLength += 28;\r\nif (psecuritypriv->dot11PrivacyAlgrthm == _TKIP_) {\r\nu8 mic[8];\r\nstruct mic_data micdata;\r\nstruct sta_info *psta = NULL;\r\nu8 priority[4] = {\r\n0x0, 0x0, 0x0, 0x0\r\n};\r\nu8 null_key[16] = {\r\n0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\r\n0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0\r\n};\r\nDBG_871X("%s(): Add MIC\n", __func__);\r\npsta = rtw_get_stainfo(&padapter->stapriv, get_my_bssid(&(pmlmeinfo->network)));\r\nif (psta != NULL) {\r\nif (!memcmp(&psta->dot11tkiptxmickey.skey[0], null_key, 16)) {\r\nDBG_871X("%s(): STA dot11tkiptxmickey == 0\n", __func__);\r\n}\r\nrtw_secmicsetkey(&micdata, &psta->dot11tkiptxmickey.skey[0]);\r\n}\r\nrtw_secmicappend(&micdata, pwlanhdr->addr3, 6);\r\nrtw_secmicappend(&micdata, pwlanhdr->addr2, 6);\r\npriority[0] = 0;\r\nrtw_secmicappend(&micdata, &priority[0], 4);\r\nrtw_secmicappend(&micdata, payload, 36);\r\nrtw_secgetmic(&micdata, &(mic[0]));\r\npARPRspPkt += 28;\r\nmemcpy(pARPRspPkt, &(mic[0]), 8);\r\n*pLength += 8;\r\n}\r\n}\r\nstatic void ConstructPnoInfo(\r\nstruct adapter *padapter, u8 *pframe, u32 *pLength\r\n)\r\n{\r\nstruct pwrctrl_priv *pwrctl = adapter_to_pwrctl(padapter);\r\nu8 *pPnoInfoPkt = pframe;\r\npPnoInfoPkt = (u8 *)(pframe + *pLength);\r\nmemcpy(pPnoInfoPkt, &pwrctl->pnlo_info->ssid_num, 4);\r\n*pLength += 4;\r\npPnoInfoPkt += 4;\r\nmemcpy(pPnoInfoPkt, &pwrctl->pnlo_info->fast_scan_period, 4);\r\n*pLength += 4;\r\npPnoInfoPkt += 4;\r\nmemcpy(pPnoInfoPkt, &pwrctl->pnlo_info->fast_scan_iterations, 4);\r\n*pLength += 4;\r\npPnoInfoPkt += 4;\r\nmemcpy(pPnoInfoPkt, &pwrctl->pnlo_info->slow_scan_period, 4);\r\n*pLength += 4;\r\npPnoInfoPkt += 4;\r\nmemcpy(pPnoInfoPkt, &pwrctl->pnlo_info->ssid_length,\r\nMAX_PNO_LIST_COUNT);\r\n*pLength += MAX_PNO_LIST_COUNT;\r\npPnoInfoPkt += MAX_PNO_LIST_COUNT;\r\nmemcpy(pPnoInfoPkt, &pwrctl->pnlo_info->ssid_cipher_info,\r\nMAX_PNO_LIST_COUNT);\r\n*pLength += MAX_PNO_LIST_COUNT;\r\npPnoInfoPkt += MAX_PNO_LIST_COUNT;\r\nmemcpy(pPnoInfoPkt, &pwrctl->pnlo_info->ssid_channel_info,\r\nMAX_PNO_LIST_COUNT);\r\n*pLength += MAX_PNO_LIST_COUNT;\r\npPnoInfoPkt += MAX_PNO_LIST_COUNT;\r\n}\r\nstatic void ConstructSSIDList(\r\nstruct adapter *padapter, u8 *pframe, u32 *pLength\r\n)\r\n{\r\nint i = 0;\r\nu8 *pSSIDListPkt = pframe;\r\nstruct pwrctrl_priv *pwrctl = adapter_to_pwrctl(padapter);\r\npSSIDListPkt = (u8 *)(pframe + *pLength);\r\nfor (i = 0; i < pwrctl->pnlo_info->ssid_num ; i++) {\r\nmemcpy(pSSIDListPkt, &pwrctl->pno_ssid_list->node[i].SSID,\r\npwrctl->pnlo_info->ssid_length[i]);\r\n*pLength += WLAN_SSID_MAXLEN;\r\npSSIDListPkt += WLAN_SSID_MAXLEN;\r\n}\r\n}\r\nstatic void ConstructScanInfo(\r\nstruct adapter *padapter, u8 *pframe, u32 *pLength\r\n)\r\n{\r\nint i = 0;\r\nu8 *pScanInfoPkt = pframe;\r\nstruct pwrctrl_priv *pwrctl = adapter_to_pwrctl(padapter);\r\npScanInfoPkt = (u8 *)(pframe + *pLength);\r\nmemcpy(pScanInfoPkt, &pwrctl->pscan_info->channel_num, 1);\r\n*pLength += 1;\r\npScanInfoPkt += 1;\r\nmemcpy(pScanInfoPkt, &pwrctl->pscan_info->orig_ch, 1);\r\n*pLength += 1;\r\npScanInfoPkt += 1;\r\nmemcpy(pScanInfoPkt, &pwrctl->pscan_info->orig_bw, 1);\r\n*pLength += 1;\r\npScanInfoPkt += 1;\r\nmemcpy(pScanInfoPkt, &pwrctl->pscan_info->orig_40_offset, 1);\r\n*pLength += 1;\r\npScanInfoPkt += 1;\r\nmemcpy(pScanInfoPkt, &pwrctl->pscan_info->orig_80_offset, 1);\r\n*pLength += 1;\r\npScanInfoPkt += 1;\r\nmemcpy(pScanInfoPkt, &pwrctl->pscan_info->periodScan, 1);\r\n*pLength += 1;\r\npScanInfoPkt += 1;\r\nmemcpy(pScanInfoPkt, &pwrctl->pscan_info->period_scan_time, 1);\r\n*pLength += 1;\r\npScanInfoPkt += 1;\r\nmemcpy(pScanInfoPkt, &pwrctl->pscan_info->enableRFE, 1);\r\n*pLength += 1;\r\npScanInfoPkt += 1;\r\nmemcpy(pScanInfoPkt, &pwrctl->pscan_info->rfe_type, 8);\r\n*pLength += 8;\r\npScanInfoPkt += 8;\r\nfor (i = 0; i < MAX_SCAN_LIST_COUNT; i++) {\r\nmemcpy(pScanInfoPkt, &pwrctl->pscan_info->ssid_channel_info[i], 4);\r\n*pLength += 4;\r\npScanInfoPkt += 4;\r\n}\r\n}\r\nstatic void ConstructGTKResponse(\r\nstruct adapter *padapter, u8 *pframe, u32 *pLength\r\n)\r\n{\r\nstruct ieee80211_hdr *pwlanhdr;\r\nu16 *fctrl;\r\nstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nstatic u8 LLCHeader[8] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0x00, 0x88, 0x8E};\r\nstatic u8 GTKbody_a[11] = {0x01, 0x03, 0x00, 0x5F, 0x02, 0x03, 0x12, 0x00, 0x10, 0x42, 0x0B};\r\nu8 *pGTKRspPkt = pframe;\r\nu8 EncryptionHeadOverhead = 0;\r\npwlanhdr = (struct ieee80211_hdr *)pframe;\r\nfctrl = &pwlanhdr->frame_control;\r\n*(fctrl) = 0;\r\nSetFrameType(fctrl, WIFI_DATA);\r\nSetToDs(fctrl);\r\nmemcpy(pwlanhdr->addr1, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);\r\nmemcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);\r\nmemcpy(pwlanhdr->addr3, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);\r\nSetSeqNum(pwlanhdr, 0);\r\nSetDuration(pwlanhdr, 0);\r\n*pLength = 24;\r\nswitch (psecuritypriv->dot11PrivacyAlgrthm) {\r\ncase _WEP40_:\r\ncase _WEP104_:\r\nEncryptionHeadOverhead = 4;\r\nbreak;\r\ncase _TKIP_:\r\nEncryptionHeadOverhead = 8;\r\nbreak;\r\ncase _AES_:\r\nEncryptionHeadOverhead = 8;\r\nbreak;\r\ndefault:\r\nEncryptionHeadOverhead = 0;\r\n}\r\nif (EncryptionHeadOverhead > 0) {\r\nmemset(&(pframe[*pLength]), 0, EncryptionHeadOverhead);\r\n*pLength += EncryptionHeadOverhead;\r\n}\r\npGTKRspPkt = (u8 *)(pframe + *pLength);\r\nmemcpy(pGTKRspPkt, LLCHeader, 8);\r\n*pLength += 8;\r\npGTKRspPkt += 8;\r\nmemcpy(pGTKRspPkt, GTKbody_a, 11);\r\n*pLength += 11;\r\npGTKRspPkt += 11;\r\nmemset(&(pframe[*pLength]), 0, 88);\r\n*pLength += 88;\r\npGTKRspPkt += 88;\r\n}\r\nstatic void ConstructProbeReq(struct adapter *padapter, u8 *pframe, u32 *pLength)\r\n{\r\nstruct ieee80211_hdr *pwlanhdr;\r\nu16 *fctrl;\r\nu32 pktlen;\r\nunsigned char *mac;\r\nunsigned char bssrate[NumRates];\r\nstruct xmit_priv *pxmitpriv = &(padapter->xmitpriv);\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nint bssrate_len = 0;\r\nu8 bc_addr[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\r\npwlanhdr = (struct ieee80211_hdr *)pframe;\r\nmac = myid(&(padapter->eeprompriv));\r\nfctrl = &(pwlanhdr->frame_control);\r\n*(fctrl) = 0;\r\nmemcpy(pwlanhdr->addr1, bc_addr, ETH_ALEN);\r\nmemcpy(pwlanhdr->addr3, bc_addr, ETH_ALEN);\r\nmemcpy(pwlanhdr->addr2, mac, ETH_ALEN);\r\nSetSeqNum(pwlanhdr, 0);\r\nSetFrameSubType(pframe, WIFI_PROBEREQ);\r\npktlen = sizeof(struct ieee80211_hdr_3addr);\r\npframe += pktlen;\r\npframe = rtw_set_ie(pframe, _SSID_IE_, 0, NULL, &pktlen);\r\nget_rate_set(padapter, bssrate, &bssrate_len);\r\nif (bssrate_len > 8) {\r\npframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_, 8, bssrate, &pktlen);\r\npframe = rtw_set_ie(pframe, _EXT_SUPPORTEDRATES_IE_, (bssrate_len - 8), (bssrate + 8), &pktlen);\r\n} else\r\npframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_, bssrate_len, bssrate, &pktlen);\r\n*pLength = pktlen;\r\n}\r\nstatic void ConstructProbeRsp(struct adapter *padapter, u8 *pframe, u32 *pLength, u8 *StaAddr, bool bHideSSID)\r\n{\r\nstruct ieee80211_hdr *pwlanhdr;\r\nu16 *fctrl;\r\nu8 *mac, *bssid;\r\nu32 pktlen;\r\nstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nstruct wlan_bssid_ex *cur_network = &(pmlmeinfo->network);\r\nu8 *pwps_ie;\r\nuint wps_ielen;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\npwlanhdr = (struct ieee80211_hdr *)pframe;\r\nmac = myid(&(padapter->eeprompriv));\r\nbssid = cur_network->MacAddress;\r\nfctrl = &(pwlanhdr->frame_control);\r\n*(fctrl) = 0;\r\nmemcpy(pwlanhdr->addr1, StaAddr, ETH_ALEN);\r\nmemcpy(pwlanhdr->addr2, mac, ETH_ALEN);\r\nmemcpy(pwlanhdr->addr3, bssid, ETH_ALEN);\r\nDBG_871X("%s FW Mac Addr:" MAC_FMT "\n", __func__, MAC_ARG(mac));\r\nDBG_871X("%s FW IP Addr" IP_FMT "\n", __func__, IP_ARG(StaAddr));\r\nSetSeqNum(pwlanhdr, 0);\r\nSetFrameSubType(fctrl, WIFI_PROBERSP);\r\npktlen = sizeof(struct ieee80211_hdr_3addr);\r\npframe += pktlen;\r\nif (cur_network->IELength > MAX_IE_SZ)\r\nreturn;\r\npwps_ie = rtw_get_wps_ie(cur_network->IEs+_FIXED_IE_LENGTH_,\r\ncur_network->IELength-_FIXED_IE_LENGTH_, NULL, &wps_ielen);\r\nif ((pmlmepriv->wps_probe_resp_ie != NULL) && pwps_ie && (wps_ielen > 0)) {\r\nuint wps_offset, remainder_ielen;\r\nu8 *premainder_ie;\r\nwps_offset = (uint)(pwps_ie - cur_network->IEs);\r\npremainder_ie = pwps_ie + wps_ielen;\r\nremainder_ielen = cur_network->IELength - wps_offset - wps_ielen;\r\nmemcpy(pframe, cur_network->IEs, wps_offset);\r\npframe += wps_offset;\r\npktlen += wps_offset;\r\nwps_ielen = (uint)pmlmepriv->wps_probe_resp_ie[1];\r\nif ((wps_offset+wps_ielen+2) <= MAX_IE_SZ) {\r\nmemcpy(pframe, pmlmepriv->wps_probe_resp_ie, wps_ielen+2);\r\npframe += wps_ielen+2;\r\npktlen += wps_ielen+2;\r\n}\r\nif ((wps_offset+wps_ielen+2+remainder_ielen) <= MAX_IE_SZ) {\r\nmemcpy(pframe, premainder_ie, remainder_ielen);\r\npframe += remainder_ielen;\r\npktlen += remainder_ielen;\r\n}\r\n} else {\r\nmemcpy(pframe, cur_network->IEs, cur_network->IELength);\r\npframe += cur_network->IELength;\r\npktlen += cur_network->IELength;\r\n}\r\n{\r\nu8 *ssid_ie;\r\nsint ssid_ielen;\r\nsint ssid_ielen_diff;\r\nu8 buf[MAX_IE_SZ];\r\nu8 *ies = pframe + sizeof(struct ieee80211_hdr_3addr);\r\nssid_ie = rtw_get_ie(ies+_FIXED_IE_LENGTH_, _SSID_IE_, &ssid_ielen,\r\n(pframe-ies)-_FIXED_IE_LENGTH_);\r\nssid_ielen_diff = cur_network->Ssid.SsidLength - ssid_ielen;\r\nif (ssid_ie && cur_network->Ssid.SsidLength) {\r\nuint remainder_ielen;\r\nu8 *remainder_ie;\r\nremainder_ie = ssid_ie+2;\r\nremainder_ielen = (pframe-remainder_ie);\r\nif (remainder_ielen > MAX_IE_SZ) {\r\nDBG_871X_LEVEL(_drv_warning_, FUNC_ADPT_FMT" remainder_ielen > MAX_IE_SZ\n", FUNC_ADPT_ARG(padapter));\r\nremainder_ielen = MAX_IE_SZ;\r\n}\r\nmemcpy(buf, remainder_ie, remainder_ielen);\r\nmemcpy(remainder_ie+ssid_ielen_diff, buf, remainder_ielen);\r\n*(ssid_ie+1) = cur_network->Ssid.SsidLength;\r\nmemcpy(ssid_ie+2, cur_network->Ssid.Ssid, cur_network->Ssid.SsidLength);\r\npframe += ssid_ielen_diff;\r\npktlen += ssid_ielen_diff;\r\n}\r\n}\r\n*pLength = pktlen;\r\n}\r\nvoid CheckFwRsvdPageContent(struct adapter *Adapter)\r\n{\r\n}\r\nstatic void rtl8723b_set_FwRsvdPage_cmd(struct adapter *padapter, PRSVDPAGE_LOC rsvdpageloc)\r\n{\r\nu8 u1H2CRsvdPageParm[H2C_RSVDPAGE_LOC_LEN] = {0};\r\nDBG_871X("8723BRsvdPageLoc: ProbeRsp =%d PsPoll =%d Null =%d QoSNull =%d BTNull =%d\n",\r\nrsvdpageloc->LocProbeRsp, rsvdpageloc->LocPsPoll,\r\nrsvdpageloc->LocNullData, rsvdpageloc->LocQosNull,\r\nrsvdpageloc->LocBTQosNull);\r\nSET_8723B_H2CCMD_RSVDPAGE_LOC_PROBE_RSP(u1H2CRsvdPageParm, rsvdpageloc->LocProbeRsp);\r\nSET_8723B_H2CCMD_RSVDPAGE_LOC_PSPOLL(u1H2CRsvdPageParm, rsvdpageloc->LocPsPoll);\r\nSET_8723B_H2CCMD_RSVDPAGE_LOC_NULL_DATA(u1H2CRsvdPageParm, rsvdpageloc->LocNullData);\r\nSET_8723B_H2CCMD_RSVDPAGE_LOC_QOS_NULL_DATA(u1H2CRsvdPageParm, rsvdpageloc->LocQosNull);\r\nSET_8723B_H2CCMD_RSVDPAGE_LOC_BT_QOS_NULL_DATA(u1H2CRsvdPageParm, rsvdpageloc->LocBTQosNull);\r\nRT_PRINT_DATA(_module_hal_init_c_, _drv_always_, "u1H2CRsvdPageParm:", u1H2CRsvdPageParm, H2C_RSVDPAGE_LOC_LEN);\r\nFillH2CCmd8723B(padapter, H2C_8723B_RSVD_PAGE, H2C_RSVDPAGE_LOC_LEN, u1H2CRsvdPageParm);\r\n}\r\nstatic void rtl8723b_set_FwAoacRsvdPage_cmd(struct adapter *padapter, PRSVDPAGE_LOC rsvdpageloc)\r\n{\r\n#ifdef CONFIG_WOWLAN\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nu8 u1H2CAoacRsvdPageParm[H2C_AOAC_RSVDPAGE_LOC_LEN] = {0};\r\nDBG_871X("8723BAOACRsvdPageLoc: RWC =%d ArpRsp =%d NbrAdv =%d GtkRsp =%d GtkInfo =%d ProbeReq =%d NetworkList =%d\n",\r\nrsvdpageloc->LocRemoteCtrlInfo, rsvdpageloc->LocArpRsp,\r\nrsvdpageloc->LocNbrAdv, rsvdpageloc->LocGTKRsp,\r\nrsvdpageloc->LocGTKInfo, rsvdpageloc->LocProbeReq,\r\nrsvdpageloc->LocNetList);\r\nif (check_fwstate(pmlmepriv, _FW_LINKED)) {\r\nSET_H2CCMD_AOAC_RSVDPAGE_LOC_REMOTE_WAKE_CTRL_INFO(u1H2CAoacRsvdPageParm, rsvdpageloc->LocRemoteCtrlInfo);\r\nSET_H2CCMD_AOAC_RSVDPAGE_LOC_ARP_RSP(u1H2CAoacRsvdPageParm, rsvdpageloc->LocArpRsp);\r\nSET_H2CCMD_AOAC_RSVDPAGE_LOC_GTK_RSP(u1H2CAoacRsvdPageParm, rsvdpageloc->LocGTKRsp);\r\nSET_H2CCMD_AOAC_RSVDPAGE_LOC_GTK_INFO(u1H2CAoacRsvdPageParm, rsvdpageloc->LocGTKInfo);\r\n#ifdef CONFIG_GTK_OL\r\nSET_H2CCMD_AOAC_RSVDPAGE_LOC_GTK_EXT_MEM(u1H2CAoacRsvdPageParm, rsvdpageloc->LocGTKEXTMEM);\r\n#endif\r\nRT_PRINT_DATA(_module_hal_init_c_, _drv_always_, "u1H2CAoacRsvdPageParm:", u1H2CAoacRsvdPageParm, H2C_AOAC_RSVDPAGE_LOC_LEN);\r\nFillH2CCmd8723B(padapter, H2C_8723B_AOAC_RSVD_PAGE, H2C_AOAC_RSVDPAGE_LOC_LEN, u1H2CAoacRsvdPageParm);\r\n} else {\r\n#ifdef CONFIG_PNO_SUPPORT\r\nif (!pwrpriv->pno_in_resume) {\r\nDBG_871X("NLO_INFO =%d\n", rsvdpageloc->LocPNOInfo);\r\nmemset(&u1H2CAoacRsvdPageParm, 0, sizeof(u1H2CAoacRsvdPageParm));\r\nSET_H2CCMD_AOAC_RSVDPAGE_LOC_NLO_INFO(u1H2CAoacRsvdPageParm, rsvdpageloc->LocPNOInfo);\r\nFillH2CCmd8723B(padapter, H2C_AOAC_RSVDPAGE3, H2C_AOAC_RSVDPAGE_LOC_LEN, u1H2CAoacRsvdPageParm);\r\nmsleep(10);\r\n}\r\n#endif\r\n}\r\n#endif\r\n}\r\nstatic void rtl8723b_set_ap_wow_rsvdpage_cmd(\r\nstruct adapter *padapter, PRSVDPAGE_LOC rsvdpageloc\r\n)\r\n{\r\nu8 header;\r\nu8 rsvdparm[H2C_AOAC_RSVDPAGE_LOC_LEN] = {0};\r\nheader = rtw_read8(padapter, REG_BCNQ_BDNY);\r\nDBG_871X("%s: beacon: %d, probeRsp: %d, header:0x%02x\n", __func__,\r\nrsvdpageloc->LocApOffloadBCN,\r\nrsvdpageloc->LocProbeRsp,\r\nheader);\r\nSET_H2CCMD_AP_WOWLAN_RSVDPAGE_LOC_BCN(rsvdparm,\r\nrsvdpageloc->LocApOffloadBCN + header);\r\nFillH2CCmd8723B(padapter, H2C_8723B_BCN_RSVDPAGE,\r\nH2C_BCN_RSVDPAGE_LEN, rsvdparm);\r\nmsleep(10);\r\nmemset(&rsvdparm, 0, sizeof(rsvdparm));\r\nSET_H2CCMD_AP_WOWLAN_RSVDPAGE_LOC_ProbeRsp(\r\nrsvdparm,\r\nrsvdpageloc->LocProbeRsp + header);\r\nFillH2CCmd8723B(padapter, H2C_8723B_PROBERSP_RSVDPAGE,\r\nH2C_PROBERSP_RSVDPAGE_LEN, rsvdparm);\r\nmsleep(10);\r\n}\r\nvoid rtl8723b_set_FwMediaStatusRpt_cmd(struct adapter *padapter, u8 mstatus, u8 macid)\r\n{\r\nu8 u1H2CMediaStatusRptParm[H2C_MEDIA_STATUS_RPT_LEN] = {0};\r\nu8 macid_end = 0;\r\nDBG_871X("%s(): mstatus = %d macid =%d\n", __func__, mstatus, macid);\r\nSET_8723B_H2CCMD_MSRRPT_PARM_OPMODE(u1H2CMediaStatusRptParm, mstatus);\r\nSET_8723B_H2CCMD_MSRRPT_PARM_MACID_IND(u1H2CMediaStatusRptParm, 0);\r\nSET_8723B_H2CCMD_MSRRPT_PARM_MACID(u1H2CMediaStatusRptParm, macid);\r\nSET_8723B_H2CCMD_MSRRPT_PARM_MACID_END(u1H2CMediaStatusRptParm, macid_end);\r\nRT_PRINT_DATA(_module_hal_init_c_, _drv_always_, "u1H2CMediaStatusRptParm:", u1H2CMediaStatusRptParm, H2C_MEDIA_STATUS_RPT_LEN);\r\nFillH2CCmd8723B(padapter, H2C_8723B_MEDIA_STATUS_RPT, H2C_MEDIA_STATUS_RPT_LEN, u1H2CMediaStatusRptParm);\r\n}\r\nstatic void rtl8723b_set_FwKeepAlive_cmd(struct adapter *padapter, u8 benable, u8 pkt_type)\r\n{\r\nu8 u1H2CKeepAliveParm[H2C_KEEP_ALIVE_CTRL_LEN] = {0};\r\nu8 adopt = 1, check_period = 5;\r\nDBG_871X("%s(): benable = %d\n", __func__, benable);\r\nSET_8723B_H2CCMD_KEEPALIVE_PARM_ENABLE(u1H2CKeepAliveParm, benable);\r\nSET_8723B_H2CCMD_KEEPALIVE_PARM_ADOPT(u1H2CKeepAliveParm, adopt);\r\nSET_8723B_H2CCMD_KEEPALIVE_PARM_PKT_TYPE(u1H2CKeepAliveParm, pkt_type);\r\nSET_8723B_H2CCMD_KEEPALIVE_PARM_CHECK_PERIOD(u1H2CKeepAliveParm, check_period);\r\nRT_PRINT_DATA(_module_hal_init_c_, _drv_always_, "u1H2CKeepAliveParm:", u1H2CKeepAliveParm, H2C_KEEP_ALIVE_CTRL_LEN);\r\nFillH2CCmd8723B(padapter, H2C_8723B_KEEP_ALIVE, H2C_KEEP_ALIVE_CTRL_LEN, u1H2CKeepAliveParm);\r\n}\r\nstatic void rtl8723b_set_FwDisconDecision_cmd(struct adapter *padapter, u8 benable)\r\n{\r\nu8 u1H2CDisconDecisionParm[H2C_DISCON_DECISION_LEN] = {0};\r\nu8 adopt = 1, check_period = 10, trypkt_num = 0;\r\nDBG_871X("%s(): benable = %d\n", __func__, benable);\r\nSET_8723B_H2CCMD_DISCONDECISION_PARM_ENABLE(u1H2CDisconDecisionParm, benable);\r\nSET_8723B_H2CCMD_DISCONDECISION_PARM_ADOPT(u1H2CDisconDecisionParm, adopt);\r\nSET_8723B_H2CCMD_DISCONDECISION_PARM_CHECK_PERIOD(u1H2CDisconDecisionParm, check_period);\r\nSET_8723B_H2CCMD_DISCONDECISION_PARM_TRY_PKT_NUM(u1H2CDisconDecisionParm, trypkt_num);\r\nRT_PRINT_DATA(_module_hal_init_c_, _drv_always_, "u1H2CDisconDecisionParm:", u1H2CDisconDecisionParm, H2C_DISCON_DECISION_LEN);\r\nFillH2CCmd8723B(padapter, H2C_8723B_DISCON_DECISION, H2C_DISCON_DECISION_LEN, u1H2CDisconDecisionParm);\r\n}\r\nvoid rtl8723b_set_FwMacIdConfig_cmd(struct adapter *padapter, u8 mac_id, u8 raid, u8 bw, u8 sgi, u32 mask)\r\n{\r\nu8 u1H2CMacIdConfigParm[H2C_MACID_CFG_LEN] = {0};\r\nDBG_871X("%s(): mac_id =%d raid = 0x%x bw =%d mask = 0x%x\n", __func__, mac_id, raid, bw, mask);\r\nSET_8723B_H2CCMD_MACID_CFG_MACID(u1H2CMacIdConfigParm, mac_id);\r\nSET_8723B_H2CCMD_MACID_CFG_RAID(u1H2CMacIdConfigParm, raid);\r\nSET_8723B_H2CCMD_MACID_CFG_SGI_EN(u1H2CMacIdConfigParm, sgi ? 1 : 0);\r\nSET_8723B_H2CCMD_MACID_CFG_BW(u1H2CMacIdConfigParm, bw);\r\nSET_8723B_H2CCMD_MACID_CFG_RATE_MASK0(u1H2CMacIdConfigParm, (u8)(mask & 0x000000ff));\r\nSET_8723B_H2CCMD_MACID_CFG_RATE_MASK1(u1H2CMacIdConfigParm, (u8)((mask & 0x0000ff00) >> 8));\r\nSET_8723B_H2CCMD_MACID_CFG_RATE_MASK2(u1H2CMacIdConfigParm, (u8)((mask & 0x00ff0000) >> 16));\r\nSET_8723B_H2CCMD_MACID_CFG_RATE_MASK3(u1H2CMacIdConfigParm, (u8)((mask & 0xff000000) >> 24));\r\nRT_PRINT_DATA(_module_hal_init_c_, _drv_always_, "u1H2CMacIdConfigParm:", u1H2CMacIdConfigParm, H2C_MACID_CFG_LEN);\r\nFillH2CCmd8723B(padapter, H2C_8723B_MACID_CFG, H2C_MACID_CFG_LEN, u1H2CMacIdConfigParm);\r\n}\r\nstatic void rtl8723b_set_FwRssiSetting_cmd(struct adapter *padapter, u8 *param)\r\n{\r\nu8 u1H2CRssiSettingParm[H2C_RSSI_SETTING_LEN] = {0};\r\nu8 mac_id = *param;\r\nu8 rssi = *(param+2);\r\nu8 uldl_state = 0;\r\nSET_8723B_H2CCMD_RSSI_SETTING_MACID(u1H2CRssiSettingParm, mac_id);\r\nSET_8723B_H2CCMD_RSSI_SETTING_RSSI(u1H2CRssiSettingParm, rssi);\r\nSET_8723B_H2CCMD_RSSI_SETTING_ULDL_STATE(u1H2CRssiSettingParm, uldl_state);\r\nRT_PRINT_DATA(_module_hal_init_c_, _drv_notice_, "u1H2CRssiSettingParm:", u1H2CRssiSettingParm, H2C_RSSI_SETTING_LEN);\r\nFillH2CCmd8723B(padapter, H2C_8723B_RSSI_SETTING, H2C_RSSI_SETTING_LEN, u1H2CRssiSettingParm);\r\n}\r\nvoid rtl8723b_set_FwPwrMode_cmd(struct adapter *padapter, u8 psmode)\r\n{\r\nint i;\r\nstruct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nu8 u1H2CPwrModeParm[H2C_PWRMODE_LEN] = {0};\r\nu8 PowerState = 0, awake_intvl = 1, byte5 = 0, rlbm = 0;\r\nif (pwrpriv->dtim > 0)\r\nDBG_871X("%s(): FW LPS mode = %d, SmartPS =%d, dtim =%d\n", __func__, psmode, pwrpriv->smart_ps, pwrpriv->dtim);\r\nelse\r\nDBG_871X("%s(): FW LPS mode = %d, SmartPS =%d\n", __func__, psmode, pwrpriv->smart_ps);\r\n#ifdef CONFIG_WOWLAN\r\nif (psmode == PS_MODE_DTIM) {\r\nawake_intvl = 3;\r\nrlbm = 2;\r\n} else\r\n#endif\r\n{\r\nif (pwrpriv->dtim > 0 && pwrpriv->dtim < 16)\r\nawake_intvl = pwrpriv->dtim+1;\r\nelse\r\nawake_intvl = 3;\r\nrlbm = 2;\r\n}\r\nif (padapter->registrypriv.wifi_spec == 1) {\r\nawake_intvl = 2;\r\nrlbm = 2;\r\n}\r\nif (psmode > 0) {\r\nif (rtw_btcoex_IsBtControlLps(padapter) == true) {\r\nPowerState = rtw_btcoex_RpwmVal(padapter);\r\nbyte5 = rtw_btcoex_LpsVal(padapter);\r\nif ((rlbm == 2) && (byte5 & BIT(4))) {\r\nawake_intvl = 2;\r\nrlbm = 2;\r\n}\r\n} else {\r\nPowerState = 0x00;\r\nbyte5 = 0x40;\r\n}\r\n} else {\r\nPowerState = 0x0C;\r\nbyte5 = 0x40;\r\n}\r\nSET_8723B_H2CCMD_PWRMODE_PARM_MODE(u1H2CPwrModeParm, (psmode > 0) ? 1 : 0);\r\nSET_8723B_H2CCMD_PWRMODE_PARM_SMART_PS(u1H2CPwrModeParm, pwrpriv->smart_ps);\r\nSET_8723B_H2CCMD_PWRMODE_PARM_RLBM(u1H2CPwrModeParm, rlbm);\r\nSET_8723B_H2CCMD_PWRMODE_PARM_BCN_PASS_TIME(u1H2CPwrModeParm, awake_intvl);\r\nSET_8723B_H2CCMD_PWRMODE_PARM_ALL_QUEUE_UAPSD(u1H2CPwrModeParm, padapter->registrypriv.uapsd_enable);\r\nSET_8723B_H2CCMD_PWRMODE_PARM_PWR_STATE(u1H2CPwrModeParm, PowerState);\r\nSET_8723B_H2CCMD_PWRMODE_PARM_BYTE5(u1H2CPwrModeParm, byte5);\r\nif (psmode != PS_MODE_ACTIVE) {\r\nif (pmlmeext->adaptive_tsf_done == false && pmlmeext->bcn_cnt > 0) {\r\nu8 ratio_20_delay, ratio_80_delay;\r\nratio_20_delay = 0;\r\nratio_80_delay = 0;\r\npmlmeext->DrvBcnEarly = 0xff;\r\npmlmeext->DrvBcnTimeOut = 0xff;\r\nDBG_871X("%s(): bcn_cnt = %d\n", __func__, pmlmeext->bcn_cnt);\r\nfor (i = 0; i < 9; i++) {\r\npmlmeext->bcn_delay_ratio[i] = (pmlmeext->bcn_delay_cnt[i]*100)/pmlmeext->bcn_cnt;\r\nDBG_871X(\r\n"%s(): bcn_delay_cnt[%d]=%d, bcn_delay_ratio[%d] = %d\n",\r\n__func__,\r\ni,\r\npmlmeext->bcn_delay_cnt[i],\r\ni,\r\npmlmeext->bcn_delay_ratio[i]\r\n);\r\nratio_20_delay += pmlmeext->bcn_delay_ratio[i];\r\nratio_80_delay += pmlmeext->bcn_delay_ratio[i];\r\nif (ratio_20_delay > 20 && pmlmeext->DrvBcnEarly == 0xff) {\r\npmlmeext->DrvBcnEarly = i;\r\nDBG_871X("%s(): DrvBcnEarly = %d\n", __func__, pmlmeext->DrvBcnEarly);\r\n}\r\nif (ratio_80_delay > 80 && pmlmeext->DrvBcnTimeOut == 0xff) {\r\npmlmeext->DrvBcnTimeOut = i;\r\nDBG_871X("%s(): DrvBcnTimeOut = %d\n", __func__, pmlmeext->DrvBcnTimeOut);\r\n}\r\npmlmeext->bcn_delay_cnt[i] = 0;\r\npmlmeext->bcn_delay_ratio[i] = 0;\r\n}\r\npmlmeext->bcn_cnt = 0;\r\npmlmeext->adaptive_tsf_done = true;\r\n} else {\r\nDBG_871X("%s(): DrvBcnEarly = %d\n", __func__, pmlmeext->DrvBcnEarly);\r\nDBG_871X("%s(): DrvBcnTimeOut = %d\n", __func__, pmlmeext->DrvBcnTimeOut);\r\n}\r\n}\r\nrtw_btcoex_RecordPwrMode(padapter, u1H2CPwrModeParm, H2C_PWRMODE_LEN);\r\nRT_PRINT_DATA(_module_hal_init_c_, _drv_always_, "u1H2CPwrModeParm:", u1H2CPwrModeParm, H2C_PWRMODE_LEN);\r\nFillH2CCmd8723B(padapter, H2C_8723B_SET_PWR_MODE, H2C_PWRMODE_LEN, u1H2CPwrModeParm);\r\n}\r\nvoid rtl8723b_set_FwPsTuneParam_cmd(struct adapter *padapter)\r\n{\r\nu8 u1H2CPsTuneParm[H2C_PSTUNEPARAM_LEN] = {0};\r\nu8 bcn_to_limit = 10;\r\nu8 dtim_timeout = 5;\r\nu8 ps_timeout = 20;\r\nu8 dtim_period = 3;\r\nSET_8723B_H2CCMD_PSTUNE_PARM_BCN_TO_LIMIT(u1H2CPsTuneParm, bcn_to_limit);\r\nSET_8723B_H2CCMD_PSTUNE_PARM_DTIM_TIMEOUT(u1H2CPsTuneParm, dtim_timeout);\r\nSET_8723B_H2CCMD_PSTUNE_PARM_PS_TIMEOUT(u1H2CPsTuneParm, ps_timeout);\r\nSET_8723B_H2CCMD_PSTUNE_PARM_ADOPT(u1H2CPsTuneParm, 1);\r\nSET_8723B_H2CCMD_PSTUNE_PARM_DTIM_PERIOD(u1H2CPsTuneParm, dtim_period);\r\nRT_PRINT_DATA(_module_hal_init_c_, _drv_always_, "u1H2CPsTuneParm:", u1H2CPsTuneParm, H2C_PSTUNEPARAM_LEN);\r\nFillH2CCmd8723B(padapter, H2C_8723B_PS_TUNING_PARA, H2C_PSTUNEPARAM_LEN, u1H2CPsTuneParm);\r\n}\r\nvoid rtl8723b_set_FwPwrModeInIPS_cmd(struct adapter *padapter, u8 cmd_param)\r\n{\r\nDBG_871X("%s()\n", __func__);\r\nFillH2CCmd8723B(padapter, H2C_8723B_FWLPS_IN_IPS_, 1, &cmd_param);\r\n}\r\nstatic void rtl8723b_set_FwWoWlanCtrl_Cmd(struct adapter *padapter, u8 bFuncEn)\r\n{\r\nstruct security_priv *psecpriv = &padapter->securitypriv;\r\nu8 u1H2CWoWlanCtrlParm[H2C_WOWLAN_LEN] = {0};\r\nu8 discont_wake = 1, gpionum = 0, gpio_dur = 0, hw_unicast = 0;\r\nu8 sdio_wakeup_enable = 1;\r\nu8 gpio_high_active = 0;\r\nu8 magic_pkt = 0;\r\n#ifdef CONFIG_GPIO_WAKEUP\r\ngpionum = WAKEUP_GPIO_IDX;\r\nsdio_wakeup_enable = 0;\r\n#endif\r\n#ifdef CONFIG_PNO_SUPPORT\r\nif (!ppwrpriv->wowlan_pno_enable)\r\nmagic_pkt = 1;\r\n#endif\r\nif (psecpriv->dot11PrivacyAlgrthm == _WEP40_ || psecpriv->dot11PrivacyAlgrthm == _WEP104_)\r\nhw_unicast = 1;\r\nDBG_871X("%s(): bFuncEn =%d\n", __func__, bFuncEn);\r\nSET_H2CCMD_WOWLAN_FUNC_ENABLE(u1H2CWoWlanCtrlParm, bFuncEn);\r\nSET_H2CCMD_WOWLAN_PATTERN_MATCH_ENABLE(u1H2CWoWlanCtrlParm, 0);\r\nSET_H2CCMD_WOWLAN_MAGIC_PKT_ENABLE(u1H2CWoWlanCtrlParm, magic_pkt);\r\nSET_H2CCMD_WOWLAN_UNICAST_PKT_ENABLE(u1H2CWoWlanCtrlParm, hw_unicast);\r\nSET_H2CCMD_WOWLAN_ALL_PKT_DROP(u1H2CWoWlanCtrlParm, 0);\r\nSET_H2CCMD_WOWLAN_GPIO_ACTIVE(u1H2CWoWlanCtrlParm, gpio_high_active);\r\nSET_H2CCMD_WOWLAN_DISCONNECT_WAKE_UP(u1H2CWoWlanCtrlParm, discont_wake);\r\nSET_H2CCMD_WOWLAN_GPIONUM(u1H2CWoWlanCtrlParm, gpionum);\r\nSET_H2CCMD_WOWLAN_DATAPIN_WAKE_UP(u1H2CWoWlanCtrlParm, sdio_wakeup_enable);\r\nSET_H2CCMD_WOWLAN_GPIO_DURATION(u1H2CWoWlanCtrlParm, gpio_dur);\r\nSET_H2CCMD_WOWLAN_GPIO_PULSE_COUNT(u1H2CWoWlanCtrlParm, 0x09);\r\nRT_PRINT_DATA(_module_hal_init_c_, _drv_always_, "u1H2CWoWlanCtrlParm:", u1H2CWoWlanCtrlParm, H2C_WOWLAN_LEN);\r\nFillH2CCmd8723B(padapter, H2C_8723B_WOWLAN, H2C_WOWLAN_LEN, u1H2CWoWlanCtrlParm);\r\n}\r\nstatic void rtl8723b_set_FwRemoteWakeCtrl_Cmd(struct adapter *padapter, u8 benable)\r\n{\r\nu8 u1H2CRemoteWakeCtrlParm[H2C_REMOTE_WAKE_CTRL_LEN] = {0};\r\nstruct security_priv *psecuritypriv = &(padapter->securitypriv);\r\nstruct pwrctrl_priv *ppwrpriv = adapter_to_pwrctl(padapter);\r\nDBG_871X("%s(): Enable =%d\n", __func__, benable);\r\nif (!ppwrpriv->wowlan_pno_enable) {\r\nSET_H2CCMD_REMOTE_WAKECTRL_ENABLE(u1H2CRemoteWakeCtrlParm, benable);\r\nSET_H2CCMD_REMOTE_WAKE_CTRL_ARP_OFFLOAD_EN(u1H2CRemoteWakeCtrlParm, 1);\r\n#ifdef CONFIG_GTK_OL\r\nif (psecuritypriv->binstallKCK_KEK &&\r\npsecuritypriv->dot11PrivacyAlgrthm == _AES_) {\r\nSET_H2CCMD_REMOTE_WAKE_CTRL_GTK_OFFLOAD_EN(u1H2CRemoteWakeCtrlParm, 1);\r\n} else {\r\nDBG_871X("no kck or security is not AES\n");\r\nSET_H2CCMD_REMOTE_WAKE_CTRL_GTK_OFFLOAD_EN(u1H2CRemoteWakeCtrlParm, 0);\r\n}\r\n#endif\r\nSET_H2CCMD_REMOTE_WAKE_CTRL_FW_UNICAST_EN(u1H2CRemoteWakeCtrlParm, 1);\r\nif ((psecuritypriv->dot11PrivacyAlgrthm == _AES_) ||\r\n(psecuritypriv->dot11PrivacyAlgrthm == _NO_PRIVACY_))\r\nSET_H2CCMD_REMOTE_WAKE_CTRL_ARP_ACTION(u1H2CRemoteWakeCtrlParm, 0);\r\nelse\r\nSET_H2CCMD_REMOTE_WAKE_CTRL_ARP_ACTION(u1H2CRemoteWakeCtrlParm, 1);\r\n}\r\n#ifdef CONFIG_PNO_SUPPORT\r\nelse {\r\nSET_H2CCMD_REMOTE_WAKECTRL_ENABLE(u1H2CRemoteWakeCtrlParm, benable);\r\nSET_H2CCMD_REMOTE_WAKE_CTRL_NLO_OFFLOAD_EN(u1H2CRemoteWakeCtrlParm, benable);\r\n}\r\n#endif\r\nRT_PRINT_DATA(_module_hal_init_c_, _drv_always_, "u1H2CRemoteWakeCtrlParm:", u1H2CRemoteWakeCtrlParm, H2C_REMOTE_WAKE_CTRL_LEN);\r\nFillH2CCmd8723B(padapter, H2C_8723B_REMOTE_WAKE_CTRL,\r\nH2C_REMOTE_WAKE_CTRL_LEN, u1H2CRemoteWakeCtrlParm);\r\n#ifdef CONFIG_PNO_SUPPORT\r\nif (ppwrpriv->wowlan_pno_enable && ppwrpriv->pno_in_resume == false) {\r\nres = rtw_read8(padapter, REG_PNO_STATUS);\r\nDBG_871X("cmd: 0x81 REG_PNO_STATUS: 0x%02x\n", res);\r\nwhile (!(res&BIT(7)) && count < 25) {\r\nDBG_871X("[%d] cmd: 0x81 REG_PNO_STATUS: 0x%02x\n", count, res);\r\nres = rtw_read8(padapter, REG_PNO_STATUS);\r\ncount++;\r\nmsleep(2);\r\n}\r\nDBG_871X("cmd: 0x81 REG_PNO_STATUS: 0x%02x\n", res);\r\n}\r\n#endif\r\n}\r\nstatic void rtl8723b_set_FwAOACGlobalInfo_Cmd(struct adapter *padapter, u8 group_alg, u8 pairwise_alg)\r\n{\r\nu8 u1H2CAOACGlobalInfoParm[H2C_AOAC_GLOBAL_INFO_LEN] = {0};\r\nDBG_871X("%s(): group_alg =%d pairwise_alg =%d\n", __func__, group_alg, pairwise_alg);\r\nSET_H2CCMD_AOAC_GLOBAL_INFO_PAIRWISE_ENC_ALG(u1H2CAOACGlobalInfoParm, pairwise_alg);\r\nSET_H2CCMD_AOAC_GLOBAL_INFO_GROUP_ENC_ALG(u1H2CAOACGlobalInfoParm, group_alg);\r\nRT_PRINT_DATA(_module_hal_init_c_, _drv_always_, "u1H2CAOACGlobalInfoParm:", u1H2CAOACGlobalInfoParm, H2C_AOAC_GLOBAL_INFO_LEN);\r\nFillH2CCmd8723B(padapter, H2C_8723B_AOAC_GLOBAL_INFO, H2C_AOAC_GLOBAL_INFO_LEN, u1H2CAOACGlobalInfoParm);\r\n}\r\nstatic void rtl8723b_set_FwScanOffloadInfo_cmd(struct adapter *padapter, PRSVDPAGE_LOC rsvdpageloc, u8 enable)\r\n{\r\nu8 u1H2CScanOffloadInfoParm[H2C_SCAN_OFFLOAD_CTRL_LEN] = {0};\r\nu8 res = 0, count = 0;\r\nstruct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);\r\nDBG_871X("%s: loc_probe_packet:%d, loc_scan_info: %d loc_ssid_info:%d\n",\r\n__func__, rsvdpageloc->LocProbePacket, rsvdpageloc->LocScanInfo, rsvdpageloc->LocSSIDInfo);\r\nSET_H2CCMD_AOAC_NLO_FUN_EN(u1H2CScanOffloadInfoParm, enable);\r\nSET_H2CCMD_AOAC_RSVDPAGE_LOC_SCAN_INFO(u1H2CScanOffloadInfoParm, rsvdpageloc->LocScanInfo);\r\nSET_H2CCMD_AOAC_RSVDPAGE_LOC_PROBE_PACKET(u1H2CScanOffloadInfoParm, rsvdpageloc->LocProbePacket);\r\nSET_H2CCMD_AOAC_RSVDPAGE_LOC_SSID_INFO(u1H2CScanOffloadInfoParm, rsvdpageloc->LocSSIDInfo);\r\nRT_PRINT_DATA(_module_hal_init_c_, _drv_always_, "u1H2CScanOffloadInfoParm:", u1H2CScanOffloadInfoParm, H2C_SCAN_OFFLOAD_CTRL_LEN);\r\nFillH2CCmd8723B(padapter, H2C_8723B_D0_SCAN_OFFLOAD_INFO, H2C_SCAN_OFFLOAD_CTRL_LEN, u1H2CScanOffloadInfoParm);\r\nmsleep(20);\r\n}\r\nstatic void rtl8723b_set_FwWoWlanRelated_cmd(struct adapter *padapter, u8 enable)\r\n{\r\nstruct security_priv *psecpriv = &padapter->securitypriv;\r\nstruct pwrctrl_priv *ppwrpriv = adapter_to_pwrctl(padapter);\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct sta_info *psta = NULL;\r\nu8 pkt_type = 0;\r\nDBG_871X_LEVEL(_drv_always_, "+%s()+: enable =%d\n", __func__, enable);\r\nif (enable) {\r\nrtl8723b_set_FwAOACGlobalInfo_Cmd(padapter, psecpriv->dot118021XGrpPrivacy, psecpriv->dot11PrivacyAlgrthm);\r\nrtl8723b_set_FwJoinBssRpt_cmd(padapter, RT_MEDIA_CONNECT);\r\nif (!(ppwrpriv->wowlan_pno_enable)) {\r\npsta = rtw_get_stainfo(&padapter->stapriv, get_bssid(pmlmepriv));\r\nif (psta != NULL)\r\nrtl8723b_set_FwMediaStatusRpt_cmd(padapter, RT_MEDIA_CONNECT, psta->mac_id);\r\n} else\r\nDBG_871X("%s(): Disconnected, no FwMediaStatusRpt CONNECT\n", __func__);\r\nmsleep(2);\r\nif (!(ppwrpriv->wowlan_pno_enable)) {\r\nrtl8723b_set_FwDisconDecision_cmd(padapter, enable);\r\nmsleep(2);\r\nif ((psecpriv->dot11PrivacyAlgrthm != _WEP40_) || (psecpriv->dot11PrivacyAlgrthm != _WEP104_))\r\npkt_type = 1;\r\nrtl8723b_set_FwKeepAlive_cmd(padapter, enable, pkt_type);\r\nmsleep(2);\r\n}\r\nrtl8723b_set_FwWoWlanCtrl_Cmd(padapter, enable);\r\nmsleep(2);\r\nrtl8723b_set_FwRemoteWakeCtrl_Cmd(padapter, enable);\r\n} else {\r\nrtl8723b_set_FwRemoteWakeCtrl_Cmd(padapter, enable);\r\nmsleep(2);\r\nrtl8723b_set_FwWoWlanCtrl_Cmd(padapter, enable);\r\n}\r\nDBG_871X_LEVEL(_drv_always_, "-%s()-\n", __func__);\r\n}\r\nvoid rtl8723b_set_wowlan_cmd(struct adapter *padapter, u8 enable)\r\n{\r\nrtl8723b_set_FwWoWlanRelated_cmd(padapter, enable);\r\n}\r\nstatic void rtl8723b_set_FwAPWoWlanCtrl_Cmd(struct adapter *padapter, u8 bFuncEn)\r\n{\r\nu8 u1H2CAPWoWlanCtrlParm[H2C_WOWLAN_LEN] = {0};\r\nu8 gpionum = 0, gpio_dur = 0;\r\nu8 gpio_high_active = 1;\r\nu8 gpio_pulse = bFuncEn;\r\n#ifdef CONFIG_GPIO_WAKEUP\r\ngpionum = WAKEUP_GPIO_IDX;\r\n#endif\r\nDBG_871X("%s(): bFuncEn =%d\n", __func__, bFuncEn);\r\nif (bFuncEn)\r\ngpio_dur = 16;\r\nelse\r\ngpio_dur = 0;\r\nSET_H2CCMD_AP_WOW_GPIO_CTRL_INDEX(u1H2CAPWoWlanCtrlParm,\r\ngpionum);\r\nSET_H2CCMD_AP_WOW_GPIO_CTRL_PLUS(u1H2CAPWoWlanCtrlParm,\r\ngpio_pulse);\r\nSET_H2CCMD_AP_WOW_GPIO_CTRL_HIGH_ACTIVE(u1H2CAPWoWlanCtrlParm,\r\ngpio_high_active);\r\nSET_H2CCMD_AP_WOW_GPIO_CTRL_EN(u1H2CAPWoWlanCtrlParm,\r\nbFuncEn);\r\nSET_H2CCMD_AP_WOW_GPIO_CTRL_DURATION(u1H2CAPWoWlanCtrlParm,\r\ngpio_dur);\r\nFillH2CCmd8723B(padapter, H2C_8723B_AP_WOW_GPIO_CTRL,\r\nH2C_AP_WOW_GPIO_CTRL_LEN, u1H2CAPWoWlanCtrlParm);\r\n}\r\nstatic void rtl8723b_set_Fw_AP_Offload_Cmd(struct adapter *padapter, u8 bFuncEn)\r\n{\r\nu8 u1H2CAPOffloadCtrlParm[H2C_WOWLAN_LEN] = {0};\r\nDBG_871X("%s(): bFuncEn =%d\n", __func__, bFuncEn);\r\nSET_H2CCMD_AP_WOWLAN_EN(u1H2CAPOffloadCtrlParm, bFuncEn);\r\nFillH2CCmd8723B(padapter, H2C_8723B_AP_OFFLOAD,\r\nH2C_AP_OFFLOAD_LEN, u1H2CAPOffloadCtrlParm);\r\n}\r\nstatic void rtl8723b_set_AP_FwWoWlan_cmd(struct adapter *padapter, u8 enable)\r\n{\r\nDBG_871X_LEVEL(_drv_always_, "+%s()+: enable =%d\n", __func__, enable);\r\nif (enable) {\r\nrtl8723b_set_FwJoinBssRpt_cmd(padapter, RT_MEDIA_CONNECT);\r\nissue_beacon(padapter, 0);\r\n}\r\nrtl8723b_set_FwAPWoWlanCtrl_Cmd(padapter, enable);\r\nmsleep(10);\r\nrtl8723b_set_Fw_AP_Offload_Cmd(padapter, enable);\r\nmsleep(10);\r\nDBG_871X_LEVEL(_drv_always_, "-%s()-\n", __func__);\r\nreturn ;\r\n}\r\nvoid rtl8723b_set_ap_wowlan_cmd(struct adapter *padapter, u8 enable)\r\n{\r\nrtl8723b_set_AP_FwWoWlan_cmd(padapter, enable);\r\n}\r\nstatic void rtl8723b_set_FwRsvdPagePkt(\r\nstruct adapter *padapter, bool bDLFinished\r\n)\r\n{\r\nstruct hal_com_data *pHalData;\r\nstruct xmit_frame *pcmdframe;\r\nstruct pkt_attrib *pattrib;\r\nstruct xmit_priv *pxmitpriv;\r\nstruct mlme_ext_priv *pmlmeext;\r\nstruct mlme_ext_info *pmlmeinfo;\r\nstruct pwrctrl_priv *pwrctl;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nu32 BeaconLength = 0, PSPollLength = 0;\r\nu32 NullDataLength = 0, QosNullLength = 0, BTQosNullLength = 0;\r\nu8 *ReservedPagePacket;\r\nu8 TxDescLen = TXDESC_SIZE, TxDescOffset = TXDESC_OFFSET;\r\nu8 TotalPageNum = 0, CurtPktPageNum = 0, RsvdPageNum = 0;\r\nu16 BufIndex, PageSize = 128;\r\nu32 TotalPacketLen, MaxRsvdPageBufSize = 0;\r\nRSVDPAGE_LOC RsvdPageLoc;\r\n#ifdef CONFIG_WOWLAN\r\nu32 ARPLegnth = 0, GTKLegnth = 0;\r\nu8 currentip[4];\r\nu8 cur_dot11txpn[8];\r\n#ifdef CONFIG_GTK_OL\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct sta_info *psta;\r\nu8 kek[RTW_KEK_LEN];\r\nu8 kck[RTW_KCK_LEN];\r\n#endif\r\n#endif\r\npHalData = GET_HAL_DATA(padapter);\r\npxmitpriv = &padapter->xmitpriv;\r\npmlmeext = &padapter->mlmeextpriv;\r\npmlmeinfo = &pmlmeext->mlmext_info;\r\npwrctl = adapter_to_pwrctl(padapter);\r\nRsvdPageNum = BCNQ_PAGE_NUM_8723B + WOWLAN_PAGE_NUM_8723B;\r\nMaxRsvdPageBufSize = RsvdPageNum*PageSize;\r\npcmdframe = rtw_alloc_cmdxmitframe(pxmitpriv);\r\nif (pcmdframe == NULL) {\r\nDBG_871X("%s: alloc ReservedPagePacket fail!\n", __func__);\r\nreturn;\r\n}\r\nReservedPagePacket = pcmdframe->buf_addr;\r\nmemset(&RsvdPageLoc, 0, sizeof(RSVDPAGE_LOC));\r\nBufIndex = TxDescOffset;\r\nConstructBeacon(padapter, &ReservedPagePacket[BufIndex], &BeaconLength);\r\nCurtPktPageNum = (u8)PageNum_128(TxDescLen + BeaconLength);\r\nif (CurtPktPageNum == 1)\r\nCurtPktPageNum += 1;\r\nTotalPageNum += CurtPktPageNum;\r\nBufIndex += (CurtPktPageNum*PageSize);\r\nRsvdPageLoc.LocPsPoll = TotalPageNum;\r\nConstructPSPoll(padapter, &ReservedPagePacket[BufIndex], &PSPollLength);\r\nrtl8723b_fill_fake_txdesc(padapter, &ReservedPagePacket[BufIndex-TxDescLen], PSPollLength, true, false, false);\r\nCurtPktPageNum = (u8)PageNum_128(TxDescLen + PSPollLength);\r\nTotalPageNum += CurtPktPageNum;\r\nBufIndex += (CurtPktPageNum*PageSize);\r\nRsvdPageLoc.LocNullData = TotalPageNum;\r\nConstructNullFunctionData(\r\npadapter,\r\n&ReservedPagePacket[BufIndex],\r\n&NullDataLength,\r\nget_my_bssid(&pmlmeinfo->network),\r\nfalse, 0, 0, false\r\n);\r\nrtl8723b_fill_fake_txdesc(padapter, &ReservedPagePacket[BufIndex-TxDescLen], NullDataLength, false, false, false);\r\nCurtPktPageNum = (u8)PageNum_128(TxDescLen + NullDataLength);\r\nTotalPageNum += CurtPktPageNum;\r\nBufIndex += (CurtPktPageNum*PageSize);\r\nRsvdPageLoc.LocQosNull = TotalPageNum;\r\nConstructNullFunctionData(\r\npadapter,\r\n&ReservedPagePacket[BufIndex],\r\n&QosNullLength,\r\nget_my_bssid(&pmlmeinfo->network),\r\ntrue, 0, 0, false\r\n);\r\nrtl8723b_fill_fake_txdesc(padapter, &ReservedPagePacket[BufIndex-TxDescLen], QosNullLength, false, false, false);\r\nCurtPktPageNum = (u8)PageNum_128(TxDescLen + QosNullLength);\r\nTotalPageNum += CurtPktPageNum;\r\nBufIndex += (CurtPktPageNum*PageSize);\r\nRsvdPageLoc.LocBTQosNull = TotalPageNum;\r\nConstructNullFunctionData(\r\npadapter,\r\n&ReservedPagePacket[BufIndex],\r\n&BTQosNullLength,\r\nget_my_bssid(&pmlmeinfo->network),\r\ntrue, 0, 0, false\r\n);\r\nrtl8723b_fill_fake_txdesc(padapter, &ReservedPagePacket[BufIndex-TxDescLen], BTQosNullLength, false, true, false);\r\nCurtPktPageNum = (u8)PageNum_128(TxDescLen + BTQosNullLength);\r\nTotalPageNum += CurtPktPageNum;\r\nBufIndex += (CurtPktPageNum*PageSize);\r\n#ifdef CONFIG_WOWLAN\r\nif (check_fwstate(pmlmepriv, _FW_LINKED)) {\r\nrtw_get_current_ip_address(padapter, currentip);\r\nRsvdPageLoc.LocArpRsp = TotalPageNum;\r\n{\r\nConstructARPResponse(\r\npadapter,\r\n&ReservedPagePacket[BufIndex],\r\n&ARPLegnth,\r\ncurrentip\r\n);\r\nrtl8723b_fill_fake_txdesc(padapter, &ReservedPagePacket[BufIndex-TxDescLen], ARPLegnth, false, false, true);\r\nCurtPktPageNum = (u8)PageNum_128(TxDescLen + ARPLegnth);\r\n}\r\nTotalPageNum += CurtPktPageNum;\r\nBufIndex += (CurtPktPageNum*PageSize);\r\nrtw_get_sec_iv(padapter, cur_dot11txpn, get_my_bssid(&pmlmeinfo->network));\r\nRsvdPageLoc.LocRemoteCtrlInfo = TotalPageNum;\r\nmemcpy(ReservedPagePacket+BufIndex-TxDescLen, cur_dot11txpn, _AES_IV_LEN_);\r\nCurtPktPageNum = (u8)PageNum_128(_AES_IV_LEN_);\r\nTotalPageNum += CurtPktPageNum;\r\n#ifdef CONFIG_GTK_OL\r\nBufIndex += (CurtPktPageNum*PageSize);\r\npsta = rtw_get_stainfo(pstapriv, get_bssid(pmlmepriv));\r\nif (psta == NULL) {\r\nmemset(kek, 0, RTW_KEK_LEN);\r\nmemset(kck, 0, RTW_KCK_LEN);\r\nDBG_8192C("%s, KEK, KCK download rsvd page all zero\n", __func__);\r\n} else {\r\nmemcpy(kek, psta->kek, RTW_KEK_LEN);\r\nmemcpy(kck, psta->kck, RTW_KCK_LEN);\r\n}\r\nRsvdPageLoc.LocGTKInfo = TotalPageNum;\r\nmemcpy(ReservedPagePacket+BufIndex-TxDescLen, kck, RTW_KCK_LEN);\r\nmemcpy(ReservedPagePacket+BufIndex-TxDescLen+RTW_KCK_LEN, kek, RTW_KEK_LEN);\r\nCurtPktPageNum = (u8)PageNum_128(TxDescLen + RTW_KCK_LEN + RTW_KEK_LEN);\r\nTotalPageNum += CurtPktPageNum;\r\nBufIndex += (CurtPktPageNum*PageSize);\r\nRsvdPageLoc.LocGTKRsp = TotalPageNum;\r\nConstructGTKResponse(\r\npadapter,\r\n&ReservedPagePacket[BufIndex],\r\n&GTKLegnth\r\n);\r\nrtl8723b_fill_fake_txdesc(padapter, &ReservedPagePacket[BufIndex-TxDescLen], GTKLegnth, false, false, true);\r\nCurtPktPageNum = (u8)PageNum_128(TxDescLen + GTKLegnth);\r\nTotalPageNum += CurtPktPageNum;\r\nBufIndex += (CurtPktPageNum*PageSize);\r\nRsvdPageLoc.LocGTKEXTMEM = TotalPageNum;\r\nCurtPktPageNum = 2;\r\nTotalPageNum += CurtPktPageNum;\r\nTotalPacketLen = BufIndex-TxDescLen + 256;\r\n#else\r\nTotalPacketLen = BufIndex-TxDescLen + sizeof (union pn48);\r\n#endif\r\n} else\r\n#endif\r\n{\r\n#ifdef CONFIG_PNO_SUPPORT\r\nif (pwrctl->pno_in_resume == false && pwrctl->pno_inited == true) {\r\nRsvdPageLoc.LocProbePacket = TotalPageNum;\r\nConstructProbeReq(\r\npadapter,\r\n&ReservedPagePacket[BufIndex],\r\n&ProbeReqLength);\r\nrtl8723b_fill_fake_txdesc(padapter,\r\n&ReservedPagePacket[BufIndex-TxDescLen],\r\nProbeReqLength, false, false, false);\r\n#ifdef CONFIG_PNO_SET_DEBUG\r\n{\r\nint gj;\r\nprintk("probe req pkt =>\n");\r\nfor (gj = 0; gj < ProbeReqLength+TxDescLen; gj++) {\r\nprintk(" %02x ", ReservedPagePacket[BufIndex-TxDescLen+gj]);\r\nif ((gj+1)%8 == 0)\r\nprintk("\n");\r\n}\r\nprintk(" <=end\n");\r\n}\r\n#endif\r\nCurtPktPageNum =\r\n(u8)PageNum_128(TxDescLen + ProbeReqLength);\r\nTotalPageNum += CurtPktPageNum;\r\nBufIndex += (CurtPktPageNum*PageSize);\r\nRsvdPageLoc.LocPNOInfo = TotalPageNum;\r\nConstructPnoInfo(padapter, &ReservedPagePacket[BufIndex-TxDescLen], &PNOLength);\r\n#ifdef CONFIG_PNO_SET_DEBUG\r\n{\r\nint gj;\r\nprintk("PNO pkt =>\n");\r\nfor (gj = 0; gj < PNOLength; gj++) {\r\nprintk(" %02x ", ReservedPagePacket[BufIndex-TxDescLen+gj]);\r\nif ((gj + 1)%8 == 0)\r\nprintk("\n");\r\n}\r\nprintk(" <=end\n");\r\n}\r\n#endif\r\nCurtPktPageNum = (u8)PageNum_128(PNOLength);\r\nTotalPageNum += CurtPktPageNum;\r\nBufIndex += (CurtPktPageNum*PageSize);\r\nRsvdPageLoc.LocSSIDInfo = TotalPageNum;\r\nConstructSSIDList(padapter, &ReservedPagePacket[BufIndex-TxDescLen], &SSIDLegnth);\r\n#ifdef CONFIG_PNO_SET_DEBUG\r\n{\r\nint gj;\r\nprintk("SSID list pkt =>\n");\r\nfor (gj = 0; gj < SSIDLegnth; gj++) {\r\nprintk(" %02x ", ReservedPagePacket[BufIndex-TxDescLen+gj]);\r\nif ((gj + 1)%8 == 0)\r\nprintk("\n");\r\n}\r\nprintk(" <=end\n");\r\n}\r\n#endif\r\nCurtPktPageNum = (u8)PageNum_128(SSIDLegnth);\r\nTotalPageNum += CurtPktPageNum;\r\nBufIndex += (CurtPktPageNum*PageSize);\r\nRsvdPageLoc.LocScanInfo = TotalPageNum;\r\nConstructScanInfo(padapter, &ReservedPagePacket[BufIndex-TxDescLen], &ScanInfoLength);\r\n#ifdef CONFIG_PNO_SET_DEBUG\r\n{\r\nint gj;\r\nprintk("Scan info pkt =>\n");\r\nfor (gj = 0; gj < ScanInfoLength; gj++) {\r\nprintk(" %02x ", ReservedPagePacket[BufIndex-TxDescLen+gj]);\r\nif ((gj + 1)%8 == 0)\r\nprintk("\n");\r\n}\r\nprintk(" <=end\n");\r\n}\r\n#endif\r\nCurtPktPageNum = (u8)PageNum_128(ScanInfoLength);\r\nTotalPageNum += CurtPktPageNum;\r\nBufIndex += (CurtPktPageNum*PageSize);\r\nTotalPacketLen = BufIndex + ScanInfoLength;\r\n} else {\r\nTotalPacketLen = BufIndex + BTQosNullLength;\r\n}\r\n#else\r\nTotalPacketLen = BufIndex + BTQosNullLength;\r\n#endif\r\n}\r\nif (TotalPacketLen > MaxRsvdPageBufSize) {\r\nDBG_871X("%s(): ERROR: The rsvd page size is not enough!!TotalPacketLen %d, MaxRsvdPageBufSize %d\n", __func__,\r\nTotalPacketLen, MaxRsvdPageBufSize);\r\ngoto error;\r\n} else {\r\npattrib = &pcmdframe->attrib;\r\nupdate_mgntframe_attrib(padapter, pattrib);\r\npattrib->qsel = 0x10;\r\npattrib->pktlen = pattrib->last_txcmdsz = TotalPacketLen - TxDescOffset;\r\ndump_mgntframe_and_wait(padapter, pcmdframe, 100);\r\n}\r\nDBG_871X("%s: Set RSVD page location to Fw , TotalPacketLen(%d), TotalPageNum(%d)\n", __func__, TotalPacketLen, TotalPageNum);\r\nif (check_fwstate(pmlmepriv, _FW_LINKED)) {\r\nrtl8723b_set_FwRsvdPage_cmd(padapter, &RsvdPageLoc);\r\nrtl8723b_set_FwAoacRsvdPage_cmd(padapter, &RsvdPageLoc);\r\n} else {\r\nrtl8723b_set_FwAoacRsvdPage_cmd(padapter, &RsvdPageLoc);\r\n#ifdef CONFIG_PNO_SUPPORT\r\nif (pwrctl->pno_in_resume)\r\nrtl8723b_set_FwScanOffloadInfo_cmd(padapter,\r\n&RsvdPageLoc, 0);\r\nelse\r\nrtl8723b_set_FwScanOffloadInfo_cmd(padapter,\r\n&RsvdPageLoc, 1);\r\n#endif\r\n}\r\nreturn;\r\nerror:\r\nrtw_free_xmitframe(pxmitpriv, pcmdframe);\r\n}\r\nstatic void rtl8723b_set_AP_FwRsvdPagePkt(\r\nstruct adapter *padapter, bool bDLFinished\r\n)\r\n{\r\nstruct hal_com_data *pHalData;\r\nstruct xmit_frame *pcmdframe;\r\nstruct pkt_attrib *pattrib;\r\nstruct xmit_priv *pxmitpriv;\r\nstruct mlme_ext_priv *pmlmeext;\r\nstruct mlme_ext_info *pmlmeinfo;\r\nstruct pwrctrl_priv *pwrctl;\r\nu32 BeaconLength = 0, ProbeRspLength = 0;\r\nu8 *ReservedPagePacket;\r\nu8 TxDescLen = TXDESC_SIZE, TxDescOffset = TXDESC_OFFSET;\r\nu8 TotalPageNum = 0, CurtPktPageNum = 0, RsvdPageNum = 0;\r\nu8 currentip[4];\r\nu16 BufIndex, PageSize = 128;\r\nu32 TotalPacketLen = 0, MaxRsvdPageBufSize = 0;\r\nRSVDPAGE_LOC RsvdPageLoc;\r\nDBG_8192C("+" FUNC_ADPT_FMT ": iface_type =%d\n",\r\nFUNC_ADPT_ARG(padapter), get_iface_type(padapter));\r\npHalData = GET_HAL_DATA(padapter);\r\npxmitpriv = &padapter->xmitpriv;\r\npmlmeext = &padapter->mlmeextpriv;\r\npmlmeinfo = &pmlmeext->mlmext_info;\r\npwrctl = adapter_to_pwrctl(padapter);\r\nRsvdPageNum = BCNQ_PAGE_NUM_8723B + AP_WOWLAN_PAGE_NUM_8723B;\r\nMaxRsvdPageBufSize = RsvdPageNum*PageSize;\r\npcmdframe = rtw_alloc_cmdxmitframe(pxmitpriv);\r\nif (pcmdframe == NULL) {\r\nDBG_871X("%s: alloc ReservedPagePacket fail!\n", __func__);\r\nreturn;\r\n}\r\nReservedPagePacket = pcmdframe->buf_addr;\r\nmemset(&RsvdPageLoc, 0, sizeof(RSVDPAGE_LOC));\r\nBufIndex = TxDescOffset;\r\nConstructBeacon(padapter, &ReservedPagePacket[BufIndex], &BeaconLength);\r\nCurtPktPageNum = (u8)PageNum_128(TxDescLen + BeaconLength);\r\nif (CurtPktPageNum == 1)\r\nCurtPktPageNum += 1;\r\nTotalPageNum += CurtPktPageNum;\r\nBufIndex += (CurtPktPageNum*PageSize);\r\nRsvdPageLoc.LocProbeRsp = TotalPageNum;\r\nrtw_get_current_ip_address(padapter, currentip);\r\nConstructProbeRsp(\r\npadapter,\r\n&ReservedPagePacket[BufIndex],\r\n&ProbeRspLength,\r\ncurrentip,\r\nfalse);\r\nrtl8723b_fill_fake_txdesc(padapter,\r\n&ReservedPagePacket[BufIndex-TxDescLen],\r\nProbeRspLength,\r\nfalse, false, false);\r\nDBG_871X("%s(): HW_VAR_SET_TX_CMD: PROBE RSP %p %d\n",\r\n__func__, &ReservedPagePacket[BufIndex-TxDescLen],\r\n(ProbeRspLength+TxDescLen));\r\nCurtPktPageNum = (u8)PageNum_128(TxDescLen + ProbeRspLength);\r\nTotalPageNum += CurtPktPageNum;\r\nBufIndex += (CurtPktPageNum*PageSize);\r\nTotalPacketLen = BufIndex + ProbeRspLength;\r\nif (TotalPacketLen > MaxRsvdPageBufSize) {\r\nDBG_871X("%s(): ERROR: The rsvd page size is not enough \\r\n!!TotalPacketLen %d, MaxRsvdPageBufSize %d\n",\r\n__func__, TotalPacketLen, MaxRsvdPageBufSize);\r\ngoto error;\r\n} else {\r\npattrib = &pcmdframe->attrib;\r\nupdate_mgntframe_attrib(padapter, pattrib);\r\npattrib->qsel = 0x10;\r\npattrib->pktlen = TotalPacketLen - TxDescOffset;\r\npattrib->last_txcmdsz = TotalPacketLen - TxDescOffset;\r\ndump_mgntframe_and_wait(padapter, pcmdframe, 100);\r\n}\r\nDBG_871X("%s: Set RSVD page location to Fw , TotalPacketLen(%d), TotalPageNum(%d)\n", __func__, TotalPacketLen, TotalPageNum);\r\nrtl8723b_set_ap_wow_rsvdpage_cmd(padapter, &RsvdPageLoc);\r\nreturn;\r\nerror:\r\nrtw_free_xmitframe(pxmitpriv, pcmdframe);\r\n}\r\nvoid rtl8723b_download_rsvd_page(struct adapter *padapter, u8 mstatus)\r\n{\r\nstruct hal_com_data *pHalData = GET_HAL_DATA(padapter);\r\n#ifdef CONFIG_AP_WOWLAN\r\nstruct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);\r\n#endif\r\nstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nbool bcn_valid = false;\r\nu8 DLBcnCount = 0;\r\nu32 poll = 0;\r\nu8 val8;\r\nDBG_8192C("+" FUNC_ADPT_FMT ": iface_type =%d mstatus(%x)\n",\r\nFUNC_ADPT_ARG(padapter), get_iface_type(padapter), mstatus);\r\nif (mstatus == RT_MEDIA_CONNECT) {\r\nbool bRecover = false;\r\nu8 v8;\r\nrtw_write16(padapter, REG_BCN_PSR_RPT, (0xC000|pmlmeinfo->aid));\r\nv8 = rtw_read8(padapter, REG_CR+1);\r\nv8 |= BIT(0);\r\nrtw_write8(padapter, REG_CR+1, v8);\r\nval8 = rtw_read8(padapter, REG_BCN_CTRL);\r\nval8 &= ~EN_BCN_FUNCTION;\r\nval8 |= DIS_TSF_UDT;\r\nrtw_write8(padapter, REG_BCN_CTRL, val8);\r\nif (pHalData->RegFwHwTxQCtrl & BIT(6))\r\nbRecover = true;\r\nrtw_write8(padapter, REG_FWHW_TXQ_CTRL+2, pHalData->RegFwHwTxQCtrl & ~BIT(6));\r\npHalData->RegFwHwTxQCtrl &= ~BIT(6);\r\nrtw_hal_set_hwreg(padapter, HW_VAR_BCN_VALID, NULL);\r\nrtw_hal_set_hwreg(padapter, HW_VAR_DL_BCN_SEL, NULL);\r\nDLBcnCount = 0;\r\npoll = 0;\r\ndo {\r\n#ifdef CONFIG_AP_WOWLAN\r\nif (pwrpriv->wowlan_ap_mode)\r\nrtl8723b_set_AP_FwRsvdPagePkt(padapter, 0);\r\nelse\r\nrtl8723b_set_FwRsvdPagePkt(padapter, 0);\r\n#else\r\nrtl8723b_set_FwRsvdPagePkt(padapter, 0);\r\n#endif\r\nDLBcnCount++;\r\ndo {\r\nyield();\r\nrtw_hal_get_hwreg(padapter, HW_VAR_BCN_VALID, (u8 *)(&bcn_valid));\r\npoll++;\r\n} while (!bcn_valid && (poll%10) != 0 && !padapter->bSurpriseRemoved && !padapter->bDriverStopped);\r\n} while (!bcn_valid && DLBcnCount <= 100 && !padapter->bSurpriseRemoved && !padapter->bDriverStopped);\r\nif (padapter->bSurpriseRemoved || padapter->bDriverStopped) {\r\n} else if (!bcn_valid)\r\nDBG_871X(ADPT_FMT": 1 DL RSVD page failed! DLBcnCount:%u, poll:%u\n",\r\nADPT_ARG(padapter), DLBcnCount, poll);\r\nelse {\r\nstruct pwrctrl_priv *pwrctl = adapter_to_pwrctl(padapter);\r\npwrctl->fw_psmode_iface_id = padapter->iface_id;\r\nDBG_871X(ADPT_FMT": 1 DL RSVD page success! DLBcnCount:%u, poll:%u\n",\r\nADPT_ARG(padapter), DLBcnCount, poll);\r\n}\r\nval8 = rtw_read8(padapter, REG_BCN_CTRL);\r\nval8 |= EN_BCN_FUNCTION;\r\nval8 &= ~DIS_TSF_UDT;\r\nrtw_write8(padapter, REG_BCN_CTRL, val8);\r\nif (bRecover) {\r\nrtw_write8(padapter, REG_FWHW_TXQ_CTRL+2, pHalData->RegFwHwTxQCtrl | BIT(6));\r\npHalData->RegFwHwTxQCtrl |= BIT(6);\r\n}\r\nv8 = rtw_read8(padapter, REG_CR+1);\r\nv8 &= ~BIT(0);\r\nrtw_write8(padapter, REG_CR+1, v8);\r\n}\r\n}\r\nvoid rtl8723b_set_rssi_cmd(struct adapter *padapter, u8 *param)\r\n{\r\nrtl8723b_set_FwRssiSetting_cmd(padapter, param);\r\n}\r\nvoid rtl8723b_set_FwJoinBssRpt_cmd(struct adapter *padapter, u8 mstatus)\r\n{\r\nif (mstatus == 1)\r\nrtl8723b_download_rsvd_page(padapter, RT_MEDIA_CONNECT);\r\n}\r\nvoid rtl8723b_Add_RateATid(\r\nstruct adapter *padapter,\r\nu32 bitmap,\r\nu8 *arg,\r\nu8 rssi_level\r\n)\r\n{\r\nstruct hal_com_data *pHalData = GET_HAL_DATA(padapter);\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nstruct sta_info *psta;\r\nu8 mac_id = arg[0];\r\nu8 raid = arg[1];\r\nu8 shortGI = arg[2];\r\nu8 bw;\r\nu32 mask = bitmap&0x0FFFFFFF;\r\npsta = pmlmeinfo->FW_sta_info[mac_id].psta;\r\nif (psta == NULL)\r\nreturn;\r\nbw = psta->bw_mode;\r\nif (rssi_level != DM_RATR_STA_INIT)\r\nmask = ODM_Get_Rate_Bitmap(&pHalData->odmpriv, mac_id, mask, rssi_level);\r\nDBG_871X("%s(): mac_id =%d raid = 0x%x bw =%d mask = 0x%x\n", __func__, mac_id, raid, bw, mask);\r\nrtl8723b_set_FwMacIdConfig_cmd(padapter, mac_id, raid, bw, shortGI, mask);\r\n}\r\nstatic void ConstructBtNullFunctionData(\r\nstruct adapter *padapter,\r\nu8 *pframe,\r\nu32 *pLength,\r\nu8 *StaAddr,\r\nu8 bQoS,\r\nu8 AC,\r\nu8 bEosp,\r\nu8 bForcePowerSave\r\n)\r\n{\r\nstruct ieee80211_hdr *pwlanhdr;\r\n__le16 *fctrl;\r\nu32 pktlen;\r\nstruct mlme_ext_priv *pmlmeext;\r\nstruct mlme_ext_info *pmlmeinfo;\r\nu8 bssid[ETH_ALEN];\r\nDBG_871X("+" FUNC_ADPT_FMT ": qos =%d eosp =%d ps =%d\n",\r\nFUNC_ADPT_ARG(padapter), bQoS, bEosp, bForcePowerSave);\r\npwlanhdr = (struct ieee80211_hdr *)pframe;\r\npmlmeext = &padapter->mlmeextpriv;\r\npmlmeinfo = &pmlmeext->mlmext_info;\r\nif (NULL == StaAddr) {\r\nmemcpy(bssid, myid(&padapter->eeprompriv), ETH_ALEN);\r\nStaAddr = bssid;\r\n}\r\nfctrl = &pwlanhdr->frame_control;\r\n*fctrl = 0;\r\nif (bForcePowerSave)\r\nSetPwrMgt(fctrl);\r\nSetFrDs(fctrl);\r\nmemcpy(pwlanhdr->addr1, StaAddr, ETH_ALEN);\r\nmemcpy(pwlanhdr->addr2, myid(&padapter->eeprompriv), ETH_ALEN);\r\nmemcpy(pwlanhdr->addr3, myid(&padapter->eeprompriv), ETH_ALEN);\r\nSetDuration(pwlanhdr, 0);\r\nSetSeqNum(pwlanhdr, 0);\r\nif (bQoS == true) {\r\nstruct ieee80211_qos_hdr *pwlanqoshdr;\r\nSetFrameSubType(pframe, WIFI_QOS_DATA_NULL);\r\npwlanqoshdr = (struct ieee80211_qos_hdr *)pframe;\r\nSetPriority(&pwlanqoshdr->qos_ctrl, AC);\r\nSetEOSP(&pwlanqoshdr->qos_ctrl, bEosp);\r\npktlen = sizeof(struct ieee80211_qos_hdr);\r\n} else {\r\nSetFrameSubType(pframe, WIFI_DATA_NULL);\r\npktlen = sizeof(struct ieee80211_hdr_3addr);\r\n}\r\n*pLength = pktlen;\r\n}\r\nstatic void SetFwRsvdPagePkt_BTCoex(struct adapter *padapter)\r\n{\r\nstruct hal_com_data *pHalData;\r\nstruct xmit_frame *pcmdframe;\r\nstruct pkt_attrib *pattrib;\r\nstruct xmit_priv *pxmitpriv;\r\nstruct mlme_ext_priv *pmlmeext;\r\nstruct mlme_ext_info *pmlmeinfo;\r\nu32 BeaconLength = 0;\r\nu32 BTQosNullLength = 0;\r\nu8 *ReservedPagePacket;\r\nu8 TxDescLen, TxDescOffset;\r\nu8 TotalPageNum = 0, CurtPktPageNum = 0, RsvdPageNum = 0;\r\nu16 BufIndex, PageSize;\r\nu32 TotalPacketLen, MaxRsvdPageBufSize = 0;\r\nRSVDPAGE_LOC RsvdPageLoc;\r\npHalData = GET_HAL_DATA(padapter);\r\npxmitpriv = &padapter->xmitpriv;\r\npmlmeext = &padapter->mlmeextpriv;\r\npmlmeinfo = &pmlmeext->mlmext_info;\r\nTxDescLen = TXDESC_SIZE;\r\nTxDescOffset = TXDESC_OFFSET;\r\nPageSize = PAGE_SIZE_TX_8723B;\r\nRsvdPageNum = BCNQ_PAGE_NUM_8723B;\r\nMaxRsvdPageBufSize = RsvdPageNum*PageSize;\r\npcmdframe = rtw_alloc_cmdxmitframe(pxmitpriv);\r\nif (pcmdframe == NULL) {\r\nDBG_8192C("%s: alloc ReservedPagePacket fail!\n", __func__);\r\nreturn;\r\n}\r\nReservedPagePacket = pcmdframe->buf_addr;\r\nmemset(&RsvdPageLoc, 0, sizeof(RSVDPAGE_LOC));\r\nBufIndex = TxDescOffset;\r\nConstructBeacon(padapter, &ReservedPagePacket[BufIndex], &BeaconLength);\r\nCurtPktPageNum = (u8)PageNum_128(TxDescLen + BeaconLength);\r\nif (CurtPktPageNum == 1)\r\nCurtPktPageNum += 1;\r\nTotalPageNum += CurtPktPageNum;\r\nBufIndex += (CurtPktPageNum*PageSize);\r\nif (BufIndex < (MaxRsvdPageBufSize - PageSize)) {\r\nBufIndex = TxDescOffset + (MaxRsvdPageBufSize - PageSize);\r\nTotalPageNum = BCNQ_PAGE_NUM_8723B - 1;\r\n}\r\nRsvdPageLoc.LocBTQosNull = TotalPageNum;\r\nConstructBtNullFunctionData(\r\npadapter,\r\n&ReservedPagePacket[BufIndex],\r\n&BTQosNullLength,\r\nNULL,\r\ntrue, 0, 0, false\r\n);\r\nrtl8723b_fill_fake_txdesc(padapter, &ReservedPagePacket[BufIndex-TxDescLen], BTQosNullLength, false, true, false);\r\nCurtPktPageNum = (u8)PageNum_128(TxDescLen + BTQosNullLength);\r\nTotalPageNum += CurtPktPageNum;\r\nTotalPacketLen = BufIndex + BTQosNullLength;\r\nif (TotalPacketLen > MaxRsvdPageBufSize) {\r\nDBG_8192C(FUNC_ADPT_FMT ": ERROR: The rsvd page size is not enough!!TotalPacketLen %d, MaxRsvdPageBufSize %d\n",\r\nFUNC_ADPT_ARG(padapter), TotalPacketLen, MaxRsvdPageBufSize);\r\ngoto error;\r\n}\r\npattrib = &pcmdframe->attrib;\r\nupdate_mgntframe_attrib(padapter, pattrib);\r\npattrib->qsel = 0x10;\r\npattrib->pktlen = pattrib->last_txcmdsz = TotalPacketLen - TxDescOffset;\r\ndump_mgntframe_and_wait(padapter, pcmdframe, 100);\r\nrtl8723b_set_FwRsvdPage_cmd(padapter, &RsvdPageLoc);\r\nrtl8723b_set_FwAoacRsvdPage_cmd(padapter, &RsvdPageLoc);\r\nreturn;\r\nerror:\r\nrtw_free_xmitframe(pxmitpriv, pcmdframe);\r\n}\r\nvoid rtl8723b_download_BTCoex_AP_mode_rsvd_page(struct adapter *padapter)\r\n{\r\nstruct hal_com_data *pHalData;\r\nstruct mlme_ext_priv *pmlmeext;\r\nstruct mlme_ext_info *pmlmeinfo;\r\nu8 bRecover = false;\r\nu8 bcn_valid = false;\r\nu8 DLBcnCount = 0;\r\nu32 poll = 0;\r\nu8 val8;\r\nDBG_8192C("+" FUNC_ADPT_FMT ": iface_type =%d fw_state = 0x%08X\n",\r\nFUNC_ADPT_ARG(padapter), get_iface_type(padapter), get_fwstate(&padapter->mlmepriv));\r\n#ifdef DEBUG\r\nif (check_fwstate(&padapter->mlmepriv, WIFI_AP_STATE) == false) {\r\nDBG_8192C(FUNC_ADPT_FMT ": [WARNING] not in AP mode!!\n",\r\nFUNC_ADPT_ARG(padapter));\r\n}\r\n#endif\r\npHalData = GET_HAL_DATA(padapter);\r\npmlmeext = &padapter->mlmeextpriv;\r\npmlmeinfo = &pmlmeext->mlmext_info;\r\nrtw_write16(padapter, REG_BCN_PSR_RPT, (0xC000|pmlmeinfo->aid));\r\nval8 = rtw_read8(padapter, REG_CR+1);\r\nval8 |= BIT(0);\r\nrtw_write8(padapter, REG_CR+1, val8);\r\nval8 = rtw_read8(padapter, REG_BCN_CTRL);\r\nval8 &= ~EN_BCN_FUNCTION;\r\nval8 |= DIS_TSF_UDT;\r\nrtw_write8(padapter, REG_BCN_CTRL, val8);\r\nif (pHalData->RegFwHwTxQCtrl & BIT(6))\r\nbRecover = true;\r\npHalData->RegFwHwTxQCtrl &= ~BIT(6);\r\nrtw_write8(padapter, REG_FWHW_TXQ_CTRL+2, pHalData->RegFwHwTxQCtrl);\r\nrtw_hal_set_hwreg(padapter, HW_VAR_BCN_VALID, NULL);\r\nrtw_hal_set_hwreg(padapter, HW_VAR_DL_BCN_SEL, NULL);\r\nDLBcnCount = 0;\r\npoll = 0;\r\ndo {\r\nSetFwRsvdPagePkt_BTCoex(padapter);\r\nDLBcnCount++;\r\ndo {\r\nyield();\r\nrtw_hal_get_hwreg(padapter, HW_VAR_BCN_VALID, &bcn_valid);\r\npoll++;\r\n} while (!bcn_valid && (poll%10) != 0 && !padapter->bSurpriseRemoved && !padapter->bDriverStopped);\r\n} while (!bcn_valid && (DLBcnCount <= 100) && !padapter->bSurpriseRemoved && !padapter->bDriverStopped);\r\nif (true == bcn_valid) {\r\nstruct pwrctrl_priv *pwrctl = adapter_to_pwrctl(padapter);\r\npwrctl->fw_psmode_iface_id = padapter->iface_id;\r\nDBG_8192C(ADPT_FMT": DL RSVD page success! DLBcnCount:%d, poll:%d\n",\r\nADPT_ARG(padapter), DLBcnCount, poll);\r\n} else {\r\nDBG_8192C(ADPT_FMT": DL RSVD page fail! DLBcnCount:%d, poll:%d\n",\r\nADPT_ARG(padapter), DLBcnCount, poll);\r\nDBG_8192C(ADPT_FMT": DL RSVD page fail! bSurpriseRemoved =%d\n",\r\nADPT_ARG(padapter), padapter->bSurpriseRemoved);\r\nDBG_8192C(ADPT_FMT": DL RSVD page fail! bDriverStopped =%d\n",\r\nADPT_ARG(padapter), padapter->bDriverStopped);\r\n}\r\nval8 = rtw_read8(padapter, REG_BCN_CTRL);\r\nval8 |= EN_BCN_FUNCTION;\r\nval8 &= ~DIS_TSF_UDT;\r\nrtw_write8(padapter, REG_BCN_CTRL, val8);\r\nif (bRecover) {\r\npHalData->RegFwHwTxQCtrl |= BIT(6);\r\nrtw_write8(padapter, REG_FWHW_TXQ_CTRL+2, pHalData->RegFwHwTxQCtrl);\r\n}\r\nval8 = rtw_read8(padapter, REG_CR+1);\r\nval8 &= ~BIT(0);\r\nrtw_write8(padapter, REG_CR+1, val8);\r\n}
