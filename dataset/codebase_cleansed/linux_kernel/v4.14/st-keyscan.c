static irqreturn_t keyscan_isr(int irq, void *dev_id)\r\n{\r\nstruct st_keyscan *keypad = dev_id;\r\nunsigned short *keycode = keypad->input_dev->keycode;\r\nunsigned long state, change;\r\nint bit_nr;\r\nstate = readl(keypad->base + KEYSCAN_MATRIX_STATE_OFF) & 0xffff;\r\nchange = keypad->last_state ^ state;\r\nkeypad->last_state = state;\r\nfor_each_set_bit(bit_nr, &change, BITS_PER_LONG)\r\ninput_report_key(keypad->input_dev,\r\nkeycode[bit_nr], state & BIT(bit_nr));\r\ninput_sync(keypad->input_dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int keyscan_start(struct st_keyscan *keypad)\r\n{\r\nint error;\r\nerror = clk_enable(keypad->clk);\r\nif (error)\r\nreturn error;\r\nwritel(keypad->debounce_us * (clk_get_rate(keypad->clk) / 1000000),\r\nkeypad->base + KEYSCAN_DEBOUNCE_TIME_OFF);\r\nwritel(((keypad->n_cols - 1) << KEYSCAN_MATRIX_DIM_X_SHIFT) |\r\n((keypad->n_rows - 1) << KEYSCAN_MATRIX_DIM_Y_SHIFT),\r\nkeypad->base + KEYSCAN_MATRIX_DIM_OFF);\r\nwritel(KEYSCAN_CONFIG_ENABLE, keypad->base + KEYSCAN_CONFIG_OFF);\r\nreturn 0;\r\n}\r\nstatic void keyscan_stop(struct st_keyscan *keypad)\r\n{\r\nwritel(0, keypad->base + KEYSCAN_CONFIG_OFF);\r\nclk_disable(keypad->clk);\r\n}\r\nstatic int keyscan_open(struct input_dev *dev)\r\n{\r\nstruct st_keyscan *keypad = input_get_drvdata(dev);\r\nreturn keyscan_start(keypad);\r\n}\r\nstatic void keyscan_close(struct input_dev *dev)\r\n{\r\nstruct st_keyscan *keypad = input_get_drvdata(dev);\r\nkeyscan_stop(keypad);\r\n}\r\nstatic int keypad_matrix_key_parse_dt(struct st_keyscan *keypad_data)\r\n{\r\nstruct device *dev = keypad_data->input_dev->dev.parent;\r\nstruct device_node *np = dev->of_node;\r\nint error;\r\nerror = matrix_keypad_parse_properties(dev, &keypad_data->n_rows,\r\n&keypad_data->n_cols);\r\nif (error) {\r\ndev_err(dev, "failed to parse keypad params\n");\r\nreturn error;\r\n}\r\nof_property_read_u32(np, "st,debounce-us", &keypad_data->debounce_us);\r\ndev_dbg(dev, "n_rows=%d n_col=%d debounce=%d\n",\r\nkeypad_data->n_rows, keypad_data->n_cols,\r\nkeypad_data->debounce_us);\r\nreturn 0;\r\n}\r\nstatic int keyscan_probe(struct platform_device *pdev)\r\n{\r\nstruct st_keyscan *keypad_data;\r\nstruct input_dev *input_dev;\r\nstruct resource *res;\r\nint error;\r\nif (!pdev->dev.of_node) {\r\ndev_err(&pdev->dev, "no DT data present\n");\r\nreturn -EINVAL;\r\n}\r\nkeypad_data = devm_kzalloc(&pdev->dev, sizeof(*keypad_data),\r\nGFP_KERNEL);\r\nif (!keypad_data)\r\nreturn -ENOMEM;\r\ninput_dev = devm_input_allocate_device(&pdev->dev);\r\nif (!input_dev) {\r\ndev_err(&pdev->dev, "failed to allocate the input device\n");\r\nreturn -ENOMEM;\r\n}\r\ninput_dev->name = pdev->name;\r\ninput_dev->phys = "keyscan-keys/input0";\r\ninput_dev->dev.parent = &pdev->dev;\r\ninput_dev->open = keyscan_open;\r\ninput_dev->close = keyscan_close;\r\ninput_dev->id.bustype = BUS_HOST;\r\nerror = keypad_matrix_key_parse_dt(keypad_data);\r\nif (error)\r\nreturn error;\r\nerror = matrix_keypad_build_keymap(NULL, NULL,\r\nkeypad_data->n_rows,\r\nkeypad_data->n_cols,\r\nNULL, input_dev);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed to build keymap\n");\r\nreturn error;\r\n}\r\ninput_set_drvdata(input_dev, keypad_data);\r\nkeypad_data->input_dev = input_dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nkeypad_data->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(keypad_data->base))\r\nreturn PTR_ERR(keypad_data->base);\r\nkeypad_data->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(keypad_data->clk)) {\r\ndev_err(&pdev->dev, "cannot get clock\n");\r\nreturn PTR_ERR(keypad_data->clk);\r\n}\r\nerror = clk_enable(keypad_data->clk);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed to enable clock\n");\r\nreturn error;\r\n}\r\nkeyscan_stop(keypad_data);\r\nkeypad_data->irq = platform_get_irq(pdev, 0);\r\nif (keypad_data->irq < 0) {\r\ndev_err(&pdev->dev, "no IRQ specified\n");\r\nreturn -EINVAL;\r\n}\r\nerror = devm_request_irq(&pdev->dev, keypad_data->irq, keyscan_isr, 0,\r\npdev->name, keypad_data);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed to request IRQ\n");\r\nreturn error;\r\n}\r\nerror = input_register_device(input_dev);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed to register input device\n");\r\nreturn error;\r\n}\r\nplatform_set_drvdata(pdev, keypad_data);\r\ndevice_set_wakeup_capable(&pdev->dev, 1);\r\nreturn 0;\r\n}\r\nstatic int keyscan_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct st_keyscan *keypad = platform_get_drvdata(pdev);\r\nstruct input_dev *input = keypad->input_dev;\r\nmutex_lock(&input->mutex);\r\nif (device_may_wakeup(dev))\r\nenable_irq_wake(keypad->irq);\r\nelse if (input->users)\r\nkeyscan_stop(keypad);\r\nmutex_unlock(&input->mutex);\r\nreturn 0;\r\n}\r\nstatic int keyscan_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct st_keyscan *keypad = platform_get_drvdata(pdev);\r\nstruct input_dev *input = keypad->input_dev;\r\nint retval = 0;\r\nmutex_lock(&input->mutex);\r\nif (device_may_wakeup(dev))\r\ndisable_irq_wake(keypad->irq);\r\nelse if (input->users)\r\nretval = keyscan_start(keypad);\r\nmutex_unlock(&input->mutex);\r\nreturn retval;\r\n}
