static int palmas_smps_read(struct palmas *palmas, unsigned int reg,\r\nunsigned int *dest)\r\n{\r\nunsigned int addr;\r\naddr = PALMAS_BASE_TO_REG(PALMAS_SMPS_BASE, reg);\r\nreturn regmap_read(palmas->regmap[REGULATOR_SLAVE], addr, dest);\r\n}\r\nstatic int palmas_smps_write(struct palmas *palmas, unsigned int reg,\r\nunsigned int value)\r\n{\r\nunsigned int addr;\r\naddr = PALMAS_BASE_TO_REG(PALMAS_SMPS_BASE, reg);\r\nreturn regmap_write(palmas->regmap[REGULATOR_SLAVE], addr, value);\r\n}\r\nstatic int palmas_ldo_read(struct palmas *palmas, unsigned int reg,\r\nunsigned int *dest)\r\n{\r\nunsigned int addr;\r\naddr = PALMAS_BASE_TO_REG(PALMAS_LDO_BASE, reg);\r\nreturn regmap_read(palmas->regmap[REGULATOR_SLAVE], addr, dest);\r\n}\r\nstatic int palmas_ldo_write(struct palmas *palmas, unsigned int reg,\r\nunsigned int value)\r\n{\r\nunsigned int addr;\r\naddr = PALMAS_BASE_TO_REG(PALMAS_LDO_BASE, reg);\r\nreturn regmap_write(palmas->regmap[REGULATOR_SLAVE], addr, value);\r\n}\r\nstatic int palmas_set_mode_smps(struct regulator_dev *dev, unsigned int mode)\r\n{\r\nint id = rdev_get_id(dev);\r\nstruct palmas_pmic *pmic = rdev_get_drvdata(dev);\r\nstruct palmas_pmic_driver_data *ddata = pmic->palmas->pmic_ddata;\r\nstruct palmas_regs_info *rinfo = &ddata->palmas_regs_info[id];\r\nunsigned int reg;\r\nbool rail_enable = true;\r\npalmas_smps_read(pmic->palmas, rinfo->ctrl_addr, &reg);\r\nreg &= ~PALMAS_SMPS12_CTRL_MODE_ACTIVE_MASK;\r\nif (reg == SMPS_CTRL_MODE_OFF)\r\nrail_enable = false;\r\nswitch (mode) {\r\ncase REGULATOR_MODE_NORMAL:\r\nreg |= SMPS_CTRL_MODE_ON;\r\nbreak;\r\ncase REGULATOR_MODE_IDLE:\r\nreg |= SMPS_CTRL_MODE_ECO;\r\nbreak;\r\ncase REGULATOR_MODE_FAST:\r\nreg |= SMPS_CTRL_MODE_PWM;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\npmic->current_reg_mode[id] = reg & PALMAS_SMPS12_CTRL_MODE_ACTIVE_MASK;\r\nif (rail_enable)\r\npalmas_smps_write(pmic->palmas, rinfo->ctrl_addr, reg);\r\npmic->desc[id].enable_val = pmic->current_reg_mode[id];\r\nreturn 0;\r\n}\r\nstatic unsigned int palmas_get_mode_smps(struct regulator_dev *dev)\r\n{\r\nstruct palmas_pmic *pmic = rdev_get_drvdata(dev);\r\nint id = rdev_get_id(dev);\r\nunsigned int reg;\r\nreg = pmic->current_reg_mode[id] & PALMAS_SMPS12_CTRL_MODE_ACTIVE_MASK;\r\nswitch (reg) {\r\ncase SMPS_CTRL_MODE_ON:\r\nreturn REGULATOR_MODE_NORMAL;\r\ncase SMPS_CTRL_MODE_ECO:\r\nreturn REGULATOR_MODE_IDLE;\r\ncase SMPS_CTRL_MODE_PWM:\r\nreturn REGULATOR_MODE_FAST;\r\n}\r\nreturn 0;\r\n}\r\nstatic int palmas_smps_set_ramp_delay(struct regulator_dev *rdev,\r\nint ramp_delay)\r\n{\r\nint id = rdev_get_id(rdev);\r\nstruct palmas_pmic *pmic = rdev_get_drvdata(rdev);\r\nstruct palmas_pmic_driver_data *ddata = pmic->palmas->pmic_ddata;\r\nstruct palmas_regs_info *rinfo = &ddata->palmas_regs_info[id];\r\nunsigned int reg = 0;\r\nint ret;\r\nswitch (id) {\r\ncase PALMAS_REG_SMPS3:\r\ncase PALMAS_REG_SMPS7:\r\nreturn 0;\r\n}\r\nif (ramp_delay <= 0)\r\nreg = 0;\r\nelse if (ramp_delay <= 2500)\r\nreg = 3;\r\nelse if (ramp_delay <= 5000)\r\nreg = 2;\r\nelse\r\nreg = 1;\r\nret = palmas_smps_write(pmic->palmas, rinfo->tstep_addr, reg);\r\nif (ret < 0) {\r\ndev_err(pmic->palmas->dev, "TSTEP write failed: %d\n", ret);\r\nreturn ret;\r\n}\r\npmic->ramp_delay[id] = palmas_smps_ramp_delay[reg];\r\nreturn ret;\r\n}\r\nstatic int palmas_is_enabled_ldo(struct regulator_dev *dev)\r\n{\r\nint id = rdev_get_id(dev);\r\nstruct palmas_pmic *pmic = rdev_get_drvdata(dev);\r\nstruct palmas_pmic_driver_data *ddata = pmic->palmas->pmic_ddata;\r\nstruct palmas_regs_info *rinfo = &ddata->palmas_regs_info[id];\r\nunsigned int reg;\r\npalmas_ldo_read(pmic->palmas, rinfo->ctrl_addr, &reg);\r\nreg &= PALMAS_LDO1_CTRL_STATUS;\r\nreturn !!(reg);\r\n}\r\nstatic int palmas_regulator_config_external(struct palmas *palmas, int id,\r\nstruct palmas_reg_init *reg_init)\r\n{\r\nstruct palmas_pmic_driver_data *ddata = palmas->pmic_ddata;\r\nstruct palmas_regs_info *rinfo = &ddata->palmas_regs_info[id];\r\nint ret;\r\nret = palmas_ext_control_req_config(palmas, rinfo->sleep_id,\r\nreg_init->roof_floor, true);\r\nif (ret < 0)\r\ndev_err(palmas->dev,\r\n"Ext control config for regulator %d failed %d\n",\r\nid, ret);\r\nreturn ret;\r\n}\r\nstatic int palmas_smps_init(struct palmas *palmas, int id,\r\nstruct palmas_reg_init *reg_init)\r\n{\r\nunsigned int reg;\r\nint ret;\r\nstruct palmas_pmic_driver_data *ddata = palmas->pmic_ddata;\r\nstruct palmas_regs_info *rinfo = &ddata->palmas_regs_info[id];\r\nunsigned int addr = rinfo->ctrl_addr;\r\nret = palmas_smps_read(palmas, addr, &reg);\r\nif (ret)\r\nreturn ret;\r\nswitch (id) {\r\ncase PALMAS_REG_SMPS10_OUT1:\r\ncase PALMAS_REG_SMPS10_OUT2:\r\nreg &= ~PALMAS_SMPS10_CTRL_MODE_SLEEP_MASK;\r\nif (reg_init->mode_sleep)\r\nreg |= reg_init->mode_sleep <<\r\nPALMAS_SMPS10_CTRL_MODE_SLEEP_SHIFT;\r\nbreak;\r\ndefault:\r\nif (reg_init->warm_reset)\r\nreg |= PALMAS_SMPS12_CTRL_WR_S;\r\nelse\r\nreg &= ~PALMAS_SMPS12_CTRL_WR_S;\r\nif (reg_init->roof_floor)\r\nreg |= PALMAS_SMPS12_CTRL_ROOF_FLOOR_EN;\r\nelse\r\nreg &= ~PALMAS_SMPS12_CTRL_ROOF_FLOOR_EN;\r\nreg &= ~PALMAS_SMPS12_CTRL_MODE_SLEEP_MASK;\r\nif (reg_init->mode_sleep)\r\nreg |= reg_init->mode_sleep <<\r\nPALMAS_SMPS12_CTRL_MODE_SLEEP_SHIFT;\r\n}\r\nret = palmas_smps_write(palmas, addr, reg);\r\nif (ret)\r\nreturn ret;\r\nif (rinfo->vsel_addr && reg_init->vsel) {\r\nreg = reg_init->vsel;\r\nret = palmas_smps_write(palmas, rinfo->vsel_addr, reg);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (reg_init->roof_floor && (id != PALMAS_REG_SMPS10_OUT1) &&\r\n(id != PALMAS_REG_SMPS10_OUT2)) {\r\nret = palmas_smps_read(palmas, addr, &reg);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!(reg & PALMAS_SMPS12_CTRL_MODE_ACTIVE_MASK)) {\r\nreg |= SMPS_CTRL_MODE_ON;\r\nret = palmas_smps_write(palmas, addr, reg);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn palmas_regulator_config_external(palmas, id, reg_init);\r\n}\r\nreturn 0;\r\n}\r\nstatic int palmas_ldo_init(struct palmas *palmas, int id,\r\nstruct palmas_reg_init *reg_init)\r\n{\r\nunsigned int reg;\r\nunsigned int addr;\r\nint ret;\r\nstruct palmas_pmic_driver_data *ddata = palmas->pmic_ddata;\r\nstruct palmas_regs_info *rinfo = &ddata->palmas_regs_info[id];\r\naddr = rinfo->ctrl_addr;\r\nret = palmas_ldo_read(palmas, addr, &reg);\r\nif (ret)\r\nreturn ret;\r\nif (reg_init->warm_reset)\r\nreg |= PALMAS_LDO1_CTRL_WR_S;\r\nelse\r\nreg &= ~PALMAS_LDO1_CTRL_WR_S;\r\nif (reg_init->mode_sleep)\r\nreg |= PALMAS_LDO1_CTRL_MODE_SLEEP;\r\nelse\r\nreg &= ~PALMAS_LDO1_CTRL_MODE_SLEEP;\r\nret = palmas_ldo_write(palmas, addr, reg);\r\nif (ret)\r\nreturn ret;\r\nif (reg_init->roof_floor) {\r\nret = palmas_update_bits(palmas, PALMAS_LDO_BASE,\r\naddr, PALMAS_LDO1_CTRL_MODE_ACTIVE,\r\nPALMAS_LDO1_CTRL_MODE_ACTIVE);\r\nif (ret < 0) {\r\ndev_err(palmas->dev,\r\n"LDO Register 0x%02x update failed %d\n",\r\naddr, ret);\r\nreturn ret;\r\n}\r\nreturn palmas_regulator_config_external(palmas, id, reg_init);\r\n}\r\nreturn 0;\r\n}\r\nstatic int palmas_extreg_init(struct palmas *palmas, int id,\r\nstruct palmas_reg_init *reg_init)\r\n{\r\nunsigned int addr;\r\nint ret;\r\nunsigned int val = 0;\r\nstruct palmas_pmic_driver_data *ddata = palmas->pmic_ddata;\r\nstruct palmas_regs_info *rinfo = &ddata->palmas_regs_info[id];\r\naddr = rinfo->ctrl_addr;\r\nif (reg_init->mode_sleep)\r\nval = PALMAS_REGEN1_CTRL_MODE_SLEEP;\r\nret = palmas_update_bits(palmas, PALMAS_RESOURCE_BASE,\r\naddr, PALMAS_REGEN1_CTRL_MODE_SLEEP, val);\r\nif (ret < 0) {\r\ndev_err(palmas->dev, "Resource reg 0x%02x update failed %d\n",\r\naddr, ret);\r\nreturn ret;\r\n}\r\nif (reg_init->roof_floor) {\r\nret = palmas_update_bits(palmas, PALMAS_RESOURCE_BASE,\r\naddr, PALMAS_REGEN1_CTRL_MODE_ACTIVE,\r\nPALMAS_REGEN1_CTRL_MODE_ACTIVE);\r\nif (ret < 0) {\r\ndev_err(palmas->dev,\r\n"Resource Register 0x%02x update failed %d\n",\r\naddr, ret);\r\nreturn ret;\r\n}\r\nreturn palmas_regulator_config_external(palmas, id, reg_init);\r\n}\r\nreturn 0;\r\n}\r\nstatic void palmas_enable_ldo8_track(struct palmas *palmas)\r\n{\r\nunsigned int reg;\r\nunsigned int addr;\r\nint ret;\r\nstruct palmas_pmic_driver_data *ddata = palmas->pmic_ddata;\r\nstruct palmas_regs_info *rinfo;\r\nrinfo = &ddata->palmas_regs_info[PALMAS_REG_LDO8];\r\naddr = rinfo->ctrl_addr;\r\nret = palmas_ldo_read(palmas, addr, &reg);\r\nif (ret) {\r\ndev_err(palmas->dev, "Error in reading ldo8 control reg\n");\r\nreturn;\r\n}\r\nreg |= PALMAS_LDO8_CTRL_LDO_TRACKING_EN;\r\nret = palmas_ldo_write(palmas, addr, reg);\r\nif (ret < 0) {\r\ndev_err(palmas->dev, "Error in enabling tracking mode\n");\r\nreturn;\r\n}\r\naddr = rinfo->vsel_addr;\r\nret = palmas_ldo_read(palmas, addr, &reg);\r\nif (ret) {\r\ndev_err(palmas->dev, "Error in reading ldo8 voltage reg\n");\r\nreturn;\r\n}\r\nreg = (reg << 1) & PALMAS_LDO8_VOLTAGE_VSEL_MASK;\r\nret = palmas_ldo_write(palmas, addr, reg);\r\nif (ret < 0)\r\ndev_err(palmas->dev, "Error in setting ldo8 voltage reg\n");\r\nreturn;\r\n}\r\nstatic int palmas_ldo_registration(struct palmas_pmic *pmic,\r\nstruct palmas_pmic_driver_data *ddata,\r\nstruct palmas_pmic_platform_data *pdata,\r\nconst char *pdev_name,\r\nstruct regulator_config config)\r\n{\r\nint id, ret;\r\nstruct regulator_dev *rdev;\r\nstruct palmas_reg_init *reg_init;\r\nstruct palmas_regs_info *rinfo;\r\nstruct regulator_desc *desc;\r\nfor (id = ddata->ldo_begin; id < ddata->max_reg; id++) {\r\nif (pdata && pdata->reg_init[id])\r\nreg_init = pdata->reg_init[id];\r\nelse\r\nreg_init = NULL;\r\nrinfo = &ddata->palmas_regs_info[id];\r\ndesc = &pmic->desc[id];\r\ndesc->name = rinfo->name;\r\ndesc->id = id;\r\ndesc->type = REGULATOR_VOLTAGE;\r\ndesc->owner = THIS_MODULE;\r\nif (id < PALMAS_REG_REGEN1) {\r\ndesc->n_voltages = PALMAS_LDO_NUM_VOLTAGES;\r\nif (reg_init && reg_init->roof_floor)\r\ndesc->ops = &palmas_ops_ext_control_ldo;\r\nelse\r\ndesc->ops = &palmas_ops_ldo;\r\ndesc->min_uV = 900000;\r\ndesc->uV_step = 50000;\r\ndesc->linear_min_sel = 1;\r\ndesc->enable_time = 500;\r\ndesc->vsel_reg = PALMAS_BASE_TO_REG(PALMAS_LDO_BASE,\r\nrinfo->vsel_addr);\r\ndesc->vsel_mask = PALMAS_LDO1_VOLTAGE_VSEL_MASK;\r\ndesc->enable_reg = PALMAS_BASE_TO_REG(PALMAS_LDO_BASE,\r\nrinfo->ctrl_addr);\r\ndesc->enable_mask = PALMAS_LDO1_CTRL_MODE_ACTIVE;\r\nif (pdata && (id == PALMAS_REG_LDO8) &&\r\npdata->enable_ldo8_tracking) {\r\npalmas_enable_ldo8_track(pmic->palmas);\r\ndesc->min_uV = 450000;\r\ndesc->uV_step = 25000;\r\n}\r\nif (pdata && pdata->ldo6_vibrator &&\r\n(id == PALMAS_REG_LDO6))\r\ndesc->enable_time = 2000;\r\nif (id == PALMAS_REG_LDO9) {\r\ndesc->ops = &palmas_ops_ldo9;\r\ndesc->bypass_reg = desc->enable_reg;\r\ndesc->bypass_val_on =\r\nPALMAS_LDO9_CTRL_LDO_BYPASS_EN;\r\ndesc->bypass_mask =\r\nPALMAS_LDO9_CTRL_LDO_BYPASS_EN;\r\n}\r\n} else {\r\nif (!ddata->has_regen3 && id == PALMAS_REG_REGEN3)\r\ncontinue;\r\ndesc->n_voltages = 1;\r\nif (reg_init && reg_init->roof_floor)\r\ndesc->ops = &palmas_ops_ext_control_extreg;\r\nelse\r\ndesc->ops = &palmas_ops_extreg;\r\ndesc->enable_reg =\r\nPALMAS_BASE_TO_REG(PALMAS_RESOURCE_BASE,\r\nrinfo->ctrl_addr);\r\ndesc->enable_mask = PALMAS_REGEN1_CTRL_MODE_ACTIVE;\r\n}\r\nif (pdata)\r\nconfig.init_data = pdata->reg_data[id];\r\nelse\r\nconfig.init_data = NULL;\r\ndesc->supply_name = rinfo->sname;\r\nconfig.of_node = ddata->palmas_matches[id].of_node;\r\nrdev = devm_regulator_register(pmic->dev, desc, &config);\r\nif (IS_ERR(rdev)) {\r\ndev_err(pmic->dev,\r\n"failed to register %s regulator\n",\r\npdev_name);\r\nreturn PTR_ERR(rdev);\r\n}\r\npmic->rdev[id] = rdev;\r\nif (pdata) {\r\nreg_init = pdata->reg_init[id];\r\nif (reg_init) {\r\nif (id <= ddata->ldo_end)\r\nret = palmas_ldo_init(pmic->palmas, id,\r\nreg_init);\r\nelse\r\nret = palmas_extreg_init(pmic->palmas,\r\nid, reg_init);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int tps65917_ldo_registration(struct palmas_pmic *pmic,\r\nstruct palmas_pmic_driver_data *ddata,\r\nstruct palmas_pmic_platform_data *pdata,\r\nconst char *pdev_name,\r\nstruct regulator_config config)\r\n{\r\nint id, ret;\r\nstruct regulator_dev *rdev;\r\nstruct palmas_reg_init *reg_init;\r\nstruct palmas_regs_info *rinfo;\r\nstruct regulator_desc *desc;\r\nfor (id = ddata->ldo_begin; id < ddata->max_reg; id++) {\r\nif (pdata && pdata->reg_init[id])\r\nreg_init = pdata->reg_init[id];\r\nelse\r\nreg_init = NULL;\r\nrinfo = &ddata->palmas_regs_info[id];\r\ndesc = &pmic->desc[id];\r\ndesc->name = rinfo->name;\r\ndesc->id = id;\r\ndesc->type = REGULATOR_VOLTAGE;\r\ndesc->owner = THIS_MODULE;\r\nif (id < TPS65917_REG_REGEN1) {\r\ndesc->n_voltages = PALMAS_LDO_NUM_VOLTAGES;\r\nif (reg_init && reg_init->roof_floor)\r\ndesc->ops = &palmas_ops_ext_control_ldo;\r\nelse\r\ndesc->ops = &tps65917_ops_ldo;\r\ndesc->min_uV = 900000;\r\ndesc->uV_step = 50000;\r\ndesc->linear_min_sel = 1;\r\ndesc->enable_time = 500;\r\ndesc->vsel_reg = PALMAS_BASE_TO_REG(PALMAS_LDO_BASE,\r\nrinfo->vsel_addr);\r\ndesc->vsel_mask = PALMAS_LDO1_VOLTAGE_VSEL_MASK;\r\ndesc->enable_reg = PALMAS_BASE_TO_REG(PALMAS_LDO_BASE,\r\nrinfo->ctrl_addr);\r\ndesc->enable_mask = PALMAS_LDO1_CTRL_MODE_ACTIVE;\r\ndesc->ramp_delay = 2500;\r\nif (id == TPS65917_REG_LDO1 ||\r\nid == TPS65917_REG_LDO2) {\r\ndesc->ops = &tps65917_ops_ldo_1_2;\r\ndesc->bypass_reg = desc->enable_reg;\r\ndesc->bypass_val_on =\r\nTPS65917_LDO1_CTRL_BYPASS_EN;\r\ndesc->bypass_mask =\r\nTPS65917_LDO1_CTRL_BYPASS_EN;\r\n}\r\n} else {\r\ndesc->n_voltages = 1;\r\nif (reg_init && reg_init->roof_floor)\r\ndesc->ops = &palmas_ops_ext_control_extreg;\r\nelse\r\ndesc->ops = &palmas_ops_extreg;\r\ndesc->enable_reg =\r\nPALMAS_BASE_TO_REG(PALMAS_RESOURCE_BASE,\r\nrinfo->ctrl_addr);\r\ndesc->enable_mask = PALMAS_REGEN1_CTRL_MODE_ACTIVE;\r\n}\r\nif (pdata)\r\nconfig.init_data = pdata->reg_data[id];\r\nelse\r\nconfig.init_data = NULL;\r\ndesc->supply_name = rinfo->sname;\r\nconfig.of_node = ddata->palmas_matches[id].of_node;\r\nrdev = devm_regulator_register(pmic->dev, desc, &config);\r\nif (IS_ERR(rdev)) {\r\ndev_err(pmic->dev,\r\n"failed to register %s regulator\n",\r\npdev_name);\r\nreturn PTR_ERR(rdev);\r\n}\r\npmic->rdev[id] = rdev;\r\nif (pdata) {\r\nreg_init = pdata->reg_init[id];\r\nif (reg_init) {\r\nif (id < TPS65917_REG_REGEN1)\r\nret = palmas_ldo_init(pmic->palmas,\r\nid, reg_init);\r\nelse\r\nret = palmas_extreg_init(pmic->palmas,\r\nid, reg_init);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int palmas_smps_registration(struct palmas_pmic *pmic,\r\nstruct palmas_pmic_driver_data *ddata,\r\nstruct palmas_pmic_platform_data *pdata,\r\nconst char *pdev_name,\r\nstruct regulator_config config)\r\n{\r\nint id, ret;\r\nunsigned int addr, reg;\r\nstruct regulator_dev *rdev;\r\nstruct palmas_reg_init *reg_init;\r\nstruct palmas_regs_info *rinfo;\r\nstruct regulator_desc *desc;\r\nfor (id = ddata->smps_start; id <= ddata->smps_end; id++) {\r\nbool ramp_delay_support = false;\r\nswitch (id) {\r\ncase PALMAS_REG_SMPS12:\r\ncase PALMAS_REG_SMPS3:\r\nif (pmic->smps123)\r\ncontinue;\r\nif (id == PALMAS_REG_SMPS12)\r\nramp_delay_support = true;\r\nbreak;\r\ncase PALMAS_REG_SMPS123:\r\nif (!pmic->smps123)\r\ncontinue;\r\nramp_delay_support = true;\r\nbreak;\r\ncase PALMAS_REG_SMPS45:\r\ncase PALMAS_REG_SMPS7:\r\nif (pmic->smps457)\r\ncontinue;\r\nif (id == PALMAS_REG_SMPS45)\r\nramp_delay_support = true;\r\nbreak;\r\ncase PALMAS_REG_SMPS457:\r\nif (!pmic->smps457)\r\ncontinue;\r\nramp_delay_support = true;\r\nbreak;\r\ncase PALMAS_REG_SMPS10_OUT1:\r\ncase PALMAS_REG_SMPS10_OUT2:\r\nif (!PALMAS_PMIC_HAS(pmic->palmas, SMPS10_BOOST))\r\ncontinue;\r\n}\r\nrinfo = &ddata->palmas_regs_info[id];\r\ndesc = &pmic->desc[id];\r\nif ((id == PALMAS_REG_SMPS6) || (id == PALMAS_REG_SMPS8))\r\nramp_delay_support = true;\r\nif (ramp_delay_support) {\r\naddr = rinfo->tstep_addr;\r\nret = palmas_smps_read(pmic->palmas, addr, &reg);\r\nif (ret < 0) {\r\ndev_err(pmic->dev,\r\n"reading TSTEP reg failed: %d\n", ret);\r\nreturn ret;\r\n}\r\ndesc->ramp_delay = palmas_smps_ramp_delay[reg & 0x3];\r\npmic->ramp_delay[id] = desc->ramp_delay;\r\n}\r\nif (pdata && pdata->reg_init[id]) {\r\nreg_init = pdata->reg_init[id];\r\nret = palmas_smps_init(pmic->palmas, id, reg_init);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\nreg_init = NULL;\r\n}\r\ndesc->name = rinfo->name;\r\ndesc->id = id;\r\nswitch (id) {\r\ncase PALMAS_REG_SMPS10_OUT1:\r\ncase PALMAS_REG_SMPS10_OUT2:\r\ndesc->n_voltages = PALMAS_SMPS10_NUM_VOLTAGES;\r\ndesc->ops = &palmas_ops_smps10;\r\ndesc->vsel_reg = PALMAS_BASE_TO_REG(PALMAS_SMPS_BASE,\r\nPALMAS_SMPS10_CTRL);\r\ndesc->vsel_mask = SMPS10_VSEL;\r\ndesc->enable_reg = PALMAS_BASE_TO_REG(PALMAS_SMPS_BASE,\r\nPALMAS_SMPS10_CTRL);\r\nif (id == PALMAS_REG_SMPS10_OUT1)\r\ndesc->enable_mask = SMPS10_SWITCH_EN;\r\nelse\r\ndesc->enable_mask = SMPS10_BOOST_EN;\r\ndesc->bypass_reg = PALMAS_BASE_TO_REG(PALMAS_SMPS_BASE,\r\nPALMAS_SMPS10_CTRL);\r\ndesc->bypass_val_on = SMPS10_BYPASS_EN;\r\ndesc->bypass_mask = SMPS10_BYPASS_EN;\r\ndesc->min_uV = 3750000;\r\ndesc->uV_step = 1250000;\r\nbreak;\r\ndefault:\r\naddr = rinfo->vsel_addr;\r\ndesc->n_linear_ranges = 3;\r\nret = palmas_smps_read(pmic->palmas, addr, &reg);\r\nif (ret)\r\nreturn ret;\r\nif (reg & PALMAS_SMPS12_VOLTAGE_RANGE)\r\npmic->range[id] = 1;\r\nif (pmic->range[id])\r\ndesc->linear_ranges = smps_high_ranges;\r\nelse\r\ndesc->linear_ranges = smps_low_ranges;\r\nif (reg_init && reg_init->roof_floor)\r\ndesc->ops = &palmas_ops_ext_control_smps;\r\nelse\r\ndesc->ops = &palmas_ops_smps;\r\ndesc->n_voltages = PALMAS_SMPS_NUM_VOLTAGES;\r\ndesc->vsel_reg = PALMAS_BASE_TO_REG(PALMAS_SMPS_BASE,\r\nrinfo->vsel_addr);\r\ndesc->vsel_mask = PALMAS_SMPS12_VOLTAGE_VSEL_MASK;\r\naddr = rinfo->ctrl_addr;\r\nret = palmas_smps_read(pmic->palmas, addr, &reg);\r\nif (ret)\r\nreturn ret;\r\npmic->current_reg_mode[id] = reg &\r\nPALMAS_SMPS12_CTRL_MODE_ACTIVE_MASK;\r\ndesc->enable_reg = PALMAS_BASE_TO_REG(PALMAS_SMPS_BASE,\r\nrinfo->ctrl_addr);\r\ndesc->enable_mask = PALMAS_SMPS12_CTRL_MODE_ACTIVE_MASK;\r\ndesc->enable_val = SMPS_CTRL_MODE_ON;\r\n}\r\ndesc->type = REGULATOR_VOLTAGE;\r\ndesc->owner = THIS_MODULE;\r\nif (pdata)\r\nconfig.init_data = pdata->reg_data[id];\r\nelse\r\nconfig.init_data = NULL;\r\ndesc->supply_name = rinfo->sname;\r\nconfig.of_node = ddata->palmas_matches[id].of_node;\r\nrdev = devm_regulator_register(pmic->dev, desc, &config);\r\nif (IS_ERR(rdev)) {\r\ndev_err(pmic->dev,\r\n"failed to register %s regulator\n",\r\npdev_name);\r\nreturn PTR_ERR(rdev);\r\n}\r\npmic->rdev[id] = rdev;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tps65917_smps_registration(struct palmas_pmic *pmic,\r\nstruct palmas_pmic_driver_data *ddata,\r\nstruct palmas_pmic_platform_data *pdata,\r\nconst char *pdev_name,\r\nstruct regulator_config config)\r\n{\r\nint id, ret;\r\nunsigned int addr, reg;\r\nstruct regulator_dev *rdev;\r\nstruct palmas_reg_init *reg_init;\r\nstruct palmas_regs_info *rinfo;\r\nstruct regulator_desc *desc;\r\nfor (id = ddata->smps_start; id <= ddata->smps_end; id++) {\r\ndesc = &pmic->desc[id];\r\ndesc->n_linear_ranges = 3;\r\nif ((id == TPS65917_REG_SMPS2 || id == TPS65917_REG_SMPS1) &&\r\npmic->smps12)\r\ncontinue;\r\nif (pdata && pdata->reg_init[id]) {\r\nreg_init = pdata->reg_init[id];\r\nret = palmas_smps_init(pmic->palmas, id, reg_init);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\nreg_init = NULL;\r\n}\r\nrinfo = &ddata->palmas_regs_info[id];\r\ndesc->name = rinfo->name;\r\ndesc->id = id;\r\naddr = rinfo->vsel_addr;\r\nret = palmas_smps_read(pmic->palmas, addr, &reg);\r\nif (ret)\r\nreturn ret;\r\nif (reg & TPS65917_SMPS1_VOLTAGE_RANGE)\r\npmic->range[id] = 1;\r\nif (pmic->range[id])\r\ndesc->linear_ranges = smps_high_ranges;\r\nelse\r\ndesc->linear_ranges = smps_low_ranges;\r\nif (reg_init && reg_init->roof_floor)\r\ndesc->ops = &tps65917_ops_ext_control_smps;\r\nelse\r\ndesc->ops = &tps65917_ops_smps;\r\ndesc->n_voltages = PALMAS_SMPS_NUM_VOLTAGES;\r\ndesc->vsel_reg = PALMAS_BASE_TO_REG(PALMAS_SMPS_BASE,\r\nrinfo->vsel_addr);\r\ndesc->vsel_mask = PALMAS_SMPS12_VOLTAGE_VSEL_MASK;\r\ndesc->ramp_delay = 2500;\r\naddr = rinfo->ctrl_addr;\r\nret = palmas_smps_read(pmic->palmas, addr, &reg);\r\nif (ret)\r\nreturn ret;\r\npmic->current_reg_mode[id] = reg &\r\nPALMAS_SMPS12_CTRL_MODE_ACTIVE_MASK;\r\ndesc->enable_reg = PALMAS_BASE_TO_REG(PALMAS_SMPS_BASE,\r\nrinfo->ctrl_addr);\r\ndesc->enable_mask = PALMAS_SMPS12_CTRL_MODE_ACTIVE_MASK;\r\ndesc->enable_val = SMPS_CTRL_MODE_ON;\r\ndesc->type = REGULATOR_VOLTAGE;\r\ndesc->owner = THIS_MODULE;\r\nif (pdata)\r\nconfig.init_data = pdata->reg_data[id];\r\nelse\r\nconfig.init_data = NULL;\r\ndesc->supply_name = rinfo->sname;\r\nconfig.of_node = ddata->palmas_matches[id].of_node;\r\nrdev = devm_regulator_register(pmic->dev, desc, &config);\r\nif (IS_ERR(rdev)) {\r\ndev_err(pmic->dev,\r\n"failed to register %s regulator\n",\r\npdev_name);\r\nreturn PTR_ERR(rdev);\r\n}\r\npmic->rdev[id] = rdev;\r\n}\r\nreturn 0;\r\n}\r\nstatic int palmas_dt_to_pdata(struct device *dev,\r\nstruct device_node *node,\r\nstruct palmas_pmic_platform_data *pdata,\r\nstruct palmas_pmic_driver_data *ddata)\r\n{\r\nstruct device_node *regulators;\r\nu32 prop;\r\nint idx, ret;\r\nregulators = of_get_child_by_name(node, "regulators");\r\nif (!regulators) {\r\ndev_info(dev, "regulator node not found\n");\r\nreturn 0;\r\n}\r\nret = of_regulator_match(dev, regulators, ddata->palmas_matches,\r\nddata->max_reg);\r\nof_node_put(regulators);\r\nif (ret < 0) {\r\ndev_err(dev, "Error parsing regulator init data: %d\n", ret);\r\nreturn 0;\r\n}\r\nfor (idx = 0; idx < ddata->max_reg; idx++) {\r\nstruct of_regulator_match *match;\r\nstruct palmas_reg_init *rinit;\r\nstruct device_node *np;\r\nmatch = &ddata->palmas_matches[idx];\r\nnp = match->of_node;\r\nif (!match->init_data || !np)\r\ncontinue;\r\nrinit = devm_kzalloc(dev, sizeof(*rinit), GFP_KERNEL);\r\nif (!rinit)\r\nreturn -ENOMEM;\r\npdata->reg_data[idx] = match->init_data;\r\npdata->reg_init[idx] = rinit;\r\nrinit->warm_reset = of_property_read_bool(np, "ti,warm-reset");\r\nret = of_property_read_u32(np, "ti,roof-floor", &prop);\r\nif (ret != -EINVAL) {\r\nint econtrol;\r\necontrol = PALMAS_EXT_CONTROL_NSLEEP;\r\nif (!ret) {\r\nswitch (prop) {\r\ncase 1:\r\necontrol = PALMAS_EXT_CONTROL_ENABLE1;\r\nbreak;\r\ncase 2:\r\necontrol = PALMAS_EXT_CONTROL_ENABLE2;\r\nbreak;\r\ncase 3:\r\necontrol = PALMAS_EXT_CONTROL_NSLEEP;\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\ndev_warn(dev,\r\n"%s: Invalid roof-floor option: %u\n",\r\nmatch->name, prop);\r\nbreak;\r\n}\r\n}\r\nrinit->roof_floor = econtrol;\r\n}\r\nret = of_property_read_u32(np, "ti,mode-sleep", &prop);\r\nif (!ret)\r\nrinit->mode_sleep = prop;\r\nret = of_property_read_bool(np, "ti,smps-range");\r\nif (ret)\r\nrinit->vsel = PALMAS_SMPS12_VOLTAGE_RANGE;\r\nif (idx == PALMAS_REG_LDO8)\r\npdata->enable_ldo8_tracking = of_property_read_bool(\r\nnp, "ti,enable-ldo8-tracking");\r\n}\r\npdata->ldo6_vibrator = of_property_read_bool(node, "ti,ldo6-vibrator");\r\nreturn 0;\r\n}\r\nstatic int palmas_regulators_probe(struct platform_device *pdev)\r\n{\r\nstruct palmas *palmas = dev_get_drvdata(pdev->dev.parent);\r\nstruct palmas_pmic_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct palmas_pmic_driver_data *driver_data;\r\nstruct regulator_config config = { };\r\nstruct palmas_pmic *pmic;\r\nconst char *pdev_name;\r\nconst struct of_device_id *match;\r\nint ret = 0;\r\nunsigned int reg;\r\nmatch = of_match_device(of_match_ptr(of_palmas_match_tbl), &pdev->dev);\r\nif (!match)\r\nreturn -ENODATA;\r\ndriver_data = (struct palmas_pmic_driver_data *)match->data;\r\npdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\npmic = devm_kzalloc(&pdev->dev, sizeof(*pmic), GFP_KERNEL);\r\nif (!pmic)\r\nreturn -ENOMEM;\r\nif (of_device_is_compatible(node, "ti,tps659038-pmic")) {\r\npalmas_generic_regs_info[PALMAS_REG_REGEN2].ctrl_addr =\r\nTPS659038_REGEN2_CTRL;\r\npalmas_ddata.has_regen3 = false;\r\n}\r\npmic->dev = &pdev->dev;\r\npmic->palmas = palmas;\r\npalmas->pmic = pmic;\r\nplatform_set_drvdata(pdev, pmic);\r\npmic->palmas->pmic_ddata = driver_data;\r\nret = palmas_dt_to_pdata(&pdev->dev, node, pdata, driver_data);\r\nif (ret)\r\nreturn ret;\r\nret = palmas_smps_read(palmas, PALMAS_SMPS_CTRL, &reg);\r\nif (ret)\r\nreturn ret;\r\nif (reg & PALMAS_SMPS_CTRL_SMPS12_SMPS123_EN) {\r\npmic->smps123 = 1;\r\npmic->smps12 = 1;\r\n}\r\nif (reg & PALMAS_SMPS_CTRL_SMPS45_SMPS457_EN)\r\npmic->smps457 = 1;\r\nconfig.regmap = palmas->regmap[REGULATOR_SLAVE];\r\nconfig.dev = &pdev->dev;\r\nconfig.driver_data = pmic;\r\npdev_name = pdev->name;\r\nret = driver_data->smps_register(pmic, driver_data, pdata, pdev_name,\r\nconfig);\r\nif (ret)\r\nreturn ret;\r\nret = driver_data->ldo_register(pmic, driver_data, pdata, pdev_name,\r\nconfig);\r\nreturn ret;\r\n}\r\nstatic int __init palmas_init(void)\r\n{\r\nreturn platform_driver_register(&palmas_driver);\r\n}\r\nstatic void __exit palmas_exit(void)\r\n{\r\nplatform_driver_unregister(&palmas_driver);\r\n}
