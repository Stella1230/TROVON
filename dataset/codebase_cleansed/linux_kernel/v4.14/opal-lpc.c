static u8 opal_lpc_inb(unsigned long port)\r\n{\r\nint64_t rc;\r\n__be32 data;\r\nif (opal_lpc_chip_id < 0 || port > 0xffff)\r\nreturn 0xff;\r\nrc = opal_lpc_read(opal_lpc_chip_id, OPAL_LPC_IO, port, &data, 1);\r\nreturn rc ? 0xff : be32_to_cpu(data);\r\n}\r\nstatic __le16 __opal_lpc_inw(unsigned long port)\r\n{\r\nint64_t rc;\r\n__be32 data;\r\nif (opal_lpc_chip_id < 0 || port > 0xfffe)\r\nreturn 0xffff;\r\nif (port & 1)\r\nreturn (__le16)opal_lpc_inb(port) << 8 | opal_lpc_inb(port + 1);\r\nrc = opal_lpc_read(opal_lpc_chip_id, OPAL_LPC_IO, port, &data, 2);\r\nreturn rc ? 0xffff : be32_to_cpu(data);\r\n}\r\nstatic u16 opal_lpc_inw(unsigned long port)\r\n{\r\nreturn le16_to_cpu(__opal_lpc_inw(port));\r\n}\r\nstatic __le32 __opal_lpc_inl(unsigned long port)\r\n{\r\nint64_t rc;\r\n__be32 data;\r\nif (opal_lpc_chip_id < 0 || port > 0xfffc)\r\nreturn 0xffffffff;\r\nif (port & 3)\r\nreturn (__le32)opal_lpc_inb(port ) << 24 |\r\n(__le32)opal_lpc_inb(port + 1) << 16 |\r\n(__le32)opal_lpc_inb(port + 2) << 8 |\r\nopal_lpc_inb(port + 3);\r\nrc = opal_lpc_read(opal_lpc_chip_id, OPAL_LPC_IO, port, &data, 4);\r\nreturn rc ? 0xffffffff : be32_to_cpu(data);\r\n}\r\nstatic u32 opal_lpc_inl(unsigned long port)\r\n{\r\nreturn le32_to_cpu(__opal_lpc_inl(port));\r\n}\r\nstatic void opal_lpc_outb(u8 val, unsigned long port)\r\n{\r\nif (opal_lpc_chip_id < 0 || port > 0xffff)\r\nreturn;\r\nopal_lpc_write(opal_lpc_chip_id, OPAL_LPC_IO, port, val, 1);\r\n}\r\nstatic void __opal_lpc_outw(__le16 val, unsigned long port)\r\n{\r\nif (opal_lpc_chip_id < 0 || port > 0xfffe)\r\nreturn;\r\nif (port & 1) {\r\nopal_lpc_outb(val >> 8, port);\r\nopal_lpc_outb(val , port + 1);\r\nreturn;\r\n}\r\nopal_lpc_write(opal_lpc_chip_id, OPAL_LPC_IO, port, val, 2);\r\n}\r\nstatic void opal_lpc_outw(u16 val, unsigned long port)\r\n{\r\n__opal_lpc_outw(cpu_to_le16(val), port);\r\n}\r\nstatic void __opal_lpc_outl(__le32 val, unsigned long port)\r\n{\r\nif (opal_lpc_chip_id < 0 || port > 0xfffc)\r\nreturn;\r\nif (port & 3) {\r\nopal_lpc_outb(val >> 24, port);\r\nopal_lpc_outb(val >> 16, port + 1);\r\nopal_lpc_outb(val >> 8, port + 2);\r\nopal_lpc_outb(val , port + 3);\r\nreturn;\r\n}\r\nopal_lpc_write(opal_lpc_chip_id, OPAL_LPC_IO, port, val, 4);\r\n}\r\nstatic void opal_lpc_outl(u32 val, unsigned long port)\r\n{\r\n__opal_lpc_outl(cpu_to_le32(val), port);\r\n}\r\nstatic void opal_lpc_insb(unsigned long p, void *b, unsigned long c)\r\n{\r\nu8 *ptr = b;\r\nwhile(c--)\r\n*(ptr++) = opal_lpc_inb(p);\r\n}\r\nstatic void opal_lpc_insw(unsigned long p, void *b, unsigned long c)\r\n{\r\n__le16 *ptr = b;\r\nwhile(c--)\r\n*(ptr++) = __opal_lpc_inw(p);\r\n}\r\nstatic void opal_lpc_insl(unsigned long p, void *b, unsigned long c)\r\n{\r\n__le32 *ptr = b;\r\nwhile(c--)\r\n*(ptr++) = __opal_lpc_inl(p);\r\n}\r\nstatic void opal_lpc_outsb(unsigned long p, const void *b, unsigned long c)\r\n{\r\nconst u8 *ptr = b;\r\nwhile(c--)\r\nopal_lpc_outb(*(ptr++), p);\r\n}\r\nstatic void opal_lpc_outsw(unsigned long p, const void *b, unsigned long c)\r\n{\r\nconst __le16 *ptr = b;\r\nwhile(c--)\r\n__opal_lpc_outw(*(ptr++), p);\r\n}\r\nstatic void opal_lpc_outsl(unsigned long p, const void *b, unsigned long c)\r\n{\r\nconst __le32 *ptr = b;\r\nwhile(c--)\r\n__opal_lpc_outl(*(ptr++), p);\r\n}\r\nstatic ssize_t lpc_debug_read(struct file *filp, char __user *ubuf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct lpc_debugfs_entry *lpc = filp->private_data;\r\nu32 data, pos, len, todo;\r\nint rc;\r\nif (!access_ok(VERIFY_WRITE, ubuf, count))\r\nreturn -EFAULT;\r\ntodo = count;\r\nwhile (todo) {\r\npos = *ppos;\r\nlen = 1;\r\nif (lpc->lpc_type == OPAL_LPC_FW) {\r\nif (todo > 3 && (pos & 3) == 0)\r\nlen = 4;\r\nelse if (todo > 1 && (pos & 1) == 0)\r\nlen = 2;\r\n}\r\nrc = opal_lpc_read(opal_lpc_chip_id, lpc->lpc_type, pos,\r\n&data, len);\r\nif (rc)\r\nreturn -ENXIO;\r\nswitch(len) {\r\ncase 4:\r\nrc = __put_user((u32)data, (u32 __user *)ubuf);\r\nbreak;\r\ncase 2:\r\n#ifdef __LITTLE_ENDIAN__\r\ndata >>= 16;\r\n#endif\r\nrc = __put_user((u16)data, (u16 __user *)ubuf);\r\nbreak;\r\ndefault:\r\n#ifdef __LITTLE_ENDIAN__\r\ndata >>= 24;\r\n#endif\r\nrc = __put_user((u8)data, (u8 __user *)ubuf);\r\nbreak;\r\n}\r\nif (rc)\r\nreturn -EFAULT;\r\n*ppos += len;\r\nubuf += len;\r\ntodo -= len;\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t lpc_debug_write(struct file *filp, const char __user *ubuf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct lpc_debugfs_entry *lpc = filp->private_data;\r\nu32 data, pos, len, todo;\r\nint rc;\r\nif (!access_ok(VERIFY_READ, ubuf, count))\r\nreturn -EFAULT;\r\ntodo = count;\r\nwhile (todo) {\r\npos = *ppos;\r\nlen = 1;\r\nif (lpc->lpc_type == OPAL_LPC_FW) {\r\nif (todo > 3 && (pos & 3) == 0)\r\nlen = 4;\r\nelse if (todo > 1 && (pos & 1) == 0)\r\nlen = 2;\r\n}\r\nswitch(len) {\r\ncase 4:\r\nrc = __get_user(data, (u32 __user *)ubuf);\r\ndata = cpu_to_be32(data);\r\nbreak;\r\ncase 2:\r\nrc = __get_user(data, (u16 __user *)ubuf);\r\ndata = cpu_to_be16(data);\r\nbreak;\r\ndefault:\r\nrc = __get_user(data, (u8 __user *)ubuf);\r\nbreak;\r\n}\r\nif (rc)\r\nreturn -EFAULT;\r\nrc = opal_lpc_write(opal_lpc_chip_id, lpc->lpc_type, pos,\r\ndata, len);\r\nif (rc)\r\nreturn -ENXIO;\r\n*ppos += len;\r\nubuf += len;\r\ntodo -= len;\r\n}\r\nreturn count;\r\n}\r\nstatic int opal_lpc_debugfs_create_type(struct dentry *folder,\r\nconst char *fname,\r\nenum OpalLPCAddressType type)\r\n{\r\nstruct lpc_debugfs_entry *entry;\r\nentry = kzalloc(sizeof(*entry), GFP_KERNEL);\r\nif (!entry)\r\nreturn -ENOMEM;\r\nentry->lpc_type = type;\r\ndebugfs_create_file(fname, 0600, folder, entry, &lpc_fops);\r\nreturn 0;\r\n}\r\nstatic int opal_lpc_init_debugfs(void)\r\n{\r\nstruct dentry *root;\r\nint rc = 0;\r\nif (opal_lpc_chip_id < 0)\r\nreturn -ENODEV;\r\nroot = debugfs_create_dir("lpc", powerpc_debugfs_root);\r\nrc |= opal_lpc_debugfs_create_type(root, "io", OPAL_LPC_IO);\r\nrc |= opal_lpc_debugfs_create_type(root, "mem", OPAL_LPC_MEM);\r\nrc |= opal_lpc_debugfs_create_type(root, "fw", OPAL_LPC_FW);\r\nreturn rc;\r\n}\r\nvoid __init opal_lpc_init(void)\r\n{\r\nstruct device_node *np;\r\nfor_each_compatible_node(np, NULL, "ibm,power8-lpc") {\r\nif (!of_device_is_available(np))\r\ncontinue;\r\nif (!of_get_property(np, "primary", NULL))\r\ncontinue;\r\nopal_lpc_chip_id = of_get_ibm_chip_id(np);\r\nbreak;\r\n}\r\nif (opal_lpc_chip_id < 0)\r\nreturn;\r\nif (of_get_property(np, "ranges", NULL)) {\r\npr_info("OPAL: Found memory mapped LPC bus on chip %d\n",\r\nopal_lpc_chip_id);\r\nisa_bridge_init_non_pci(np);\r\n} else {\r\npr_info("OPAL: Found non-mapped LPC bus on chip %d\n",\r\nopal_lpc_chip_id);\r\nppc_pci_io = opal_lpc_io;\r\nisa_io_special = true;\r\n}\r\n}
