void mon_reader_add(struct mon_bus *mbus, struct mon_reader *r)\r\n{\r\nunsigned long flags;\r\nstruct list_head *p;\r\nspin_lock_irqsave(&mbus->lock, flags);\r\nif (mbus->nreaders == 0) {\r\nif (mbus == &mon_bus0) {\r\nlist_for_each (p, &mon_buses) {\r\nstruct mon_bus *m1;\r\nm1 = list_entry(p, struct mon_bus, bus_link);\r\nm1->u_bus->monitored = 1;\r\n}\r\n} else {\r\nmbus->u_bus->monitored = 1;\r\n}\r\n}\r\nmbus->nreaders++;\r\nlist_add_tail(&r->r_link, &mbus->r_list);\r\nspin_unlock_irqrestore(&mbus->lock, flags);\r\nkref_get(&mbus->ref);\r\n}\r\nvoid mon_reader_del(struct mon_bus *mbus, struct mon_reader *r)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&mbus->lock, flags);\r\nlist_del(&r->r_link);\r\n--mbus->nreaders;\r\nif (mbus->nreaders == 0)\r\nmon_stop(mbus);\r\nspin_unlock_irqrestore(&mbus->lock, flags);\r\nkref_put(&mbus->ref, mon_bus_drop);\r\n}\r\nstatic void mon_bus_submit(struct mon_bus *mbus, struct urb *urb)\r\n{\r\nunsigned long flags;\r\nstruct list_head *pos;\r\nstruct mon_reader *r;\r\nspin_lock_irqsave(&mbus->lock, flags);\r\nmbus->cnt_events++;\r\nlist_for_each (pos, &mbus->r_list) {\r\nr = list_entry(pos, struct mon_reader, r_link);\r\nr->rnf_submit(r->r_data, urb);\r\n}\r\nspin_unlock_irqrestore(&mbus->lock, flags);\r\n}\r\nstatic void mon_submit(struct usb_bus *ubus, struct urb *urb)\r\n{\r\nstruct mon_bus *mbus;\r\nmbus = ubus->mon_bus;\r\nif (mbus != NULL)\r\nmon_bus_submit(mbus, urb);\r\nmon_bus_submit(&mon_bus0, urb);\r\n}\r\nstatic void mon_bus_submit_error(struct mon_bus *mbus, struct urb *urb, int error)\r\n{\r\nunsigned long flags;\r\nstruct list_head *pos;\r\nstruct mon_reader *r;\r\nspin_lock_irqsave(&mbus->lock, flags);\r\nmbus->cnt_events++;\r\nlist_for_each (pos, &mbus->r_list) {\r\nr = list_entry(pos, struct mon_reader, r_link);\r\nr->rnf_error(r->r_data, urb, error);\r\n}\r\nspin_unlock_irqrestore(&mbus->lock, flags);\r\n}\r\nstatic void mon_submit_error(struct usb_bus *ubus, struct urb *urb, int error)\r\n{\r\nstruct mon_bus *mbus;\r\nmbus = ubus->mon_bus;\r\nif (mbus != NULL)\r\nmon_bus_submit_error(mbus, urb, error);\r\nmon_bus_submit_error(&mon_bus0, urb, error);\r\n}\r\nstatic void mon_bus_complete(struct mon_bus *mbus, struct urb *urb, int status)\r\n{\r\nunsigned long flags;\r\nstruct list_head *pos;\r\nstruct mon_reader *r;\r\nspin_lock_irqsave(&mbus->lock, flags);\r\nmbus->cnt_events++;\r\nlist_for_each (pos, &mbus->r_list) {\r\nr = list_entry(pos, struct mon_reader, r_link);\r\nr->rnf_complete(r->r_data, urb, status);\r\n}\r\nspin_unlock_irqrestore(&mbus->lock, flags);\r\n}\r\nstatic void mon_complete(struct usb_bus *ubus, struct urb *urb, int status)\r\n{\r\nstruct mon_bus *mbus;\r\nmbus = ubus->mon_bus;\r\nif (mbus != NULL)\r\nmon_bus_complete(mbus, urb, status);\r\nmon_bus_complete(&mon_bus0, urb, status);\r\n}\r\nstatic void mon_stop(struct mon_bus *mbus)\r\n{\r\nstruct usb_bus *ubus;\r\nstruct list_head *p;\r\nif (mbus == &mon_bus0) {\r\nlist_for_each (p, &mon_buses) {\r\nmbus = list_entry(p, struct mon_bus, bus_link);\r\nif (mbus->nreaders == 0 && (ubus = mbus->u_bus) != NULL)\r\nubus->monitored = 0;\r\n}\r\n} else {\r\nif (mon_bus0.nreaders == 0 && (ubus = mbus->u_bus) != NULL) {\r\nubus->monitored = 0;\r\nmb();\r\n}\r\n}\r\n}\r\nstatic void mon_bus_add(struct usb_bus *ubus)\r\n{\r\nmon_bus_init(ubus);\r\nmutex_lock(&mon_lock);\r\nif (mon_bus0.nreaders != 0)\r\nubus->monitored = 1;\r\nmutex_unlock(&mon_lock);\r\n}\r\nstatic void mon_bus_remove(struct usb_bus *ubus)\r\n{\r\nstruct mon_bus *mbus = ubus->mon_bus;\r\nmutex_lock(&mon_lock);\r\nlist_del(&mbus->bus_link);\r\nif (mbus->text_inited)\r\nmon_text_del(mbus);\r\nif (mbus->bin_inited)\r\nmon_bin_del(mbus);\r\nmon_dissolve(mbus, ubus);\r\nkref_put(&mbus->ref, mon_bus_drop);\r\nmutex_unlock(&mon_lock);\r\n}\r\nstatic int mon_notify(struct notifier_block *self, unsigned long action,\r\nvoid *dev)\r\n{\r\nswitch (action) {\r\ncase USB_BUS_ADD:\r\nmon_bus_add(dev);\r\nbreak;\r\ncase USB_BUS_REMOVE:\r\nmon_bus_remove(dev);\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic void mon_dissolve(struct mon_bus *mbus, struct usb_bus *ubus)\r\n{\r\nif (ubus->monitored) {\r\nubus->monitored = 0;\r\nmb();\r\n}\r\nubus->mon_bus = NULL;\r\nmbus->u_bus = NULL;\r\nmb();\r\n}\r\nstatic void mon_bus_drop(struct kref *r)\r\n{\r\nstruct mon_bus *mbus = container_of(r, struct mon_bus, ref);\r\nkfree(mbus);\r\n}\r\nstatic void mon_bus_init(struct usb_bus *ubus)\r\n{\r\nstruct mon_bus *mbus;\r\nmbus = kzalloc(sizeof(struct mon_bus), GFP_KERNEL);\r\nif (mbus == NULL)\r\ngoto err_alloc;\r\nkref_init(&mbus->ref);\r\nspin_lock_init(&mbus->lock);\r\nINIT_LIST_HEAD(&mbus->r_list);\r\nmbus->u_bus = ubus;\r\nubus->mon_bus = mbus;\r\nmbus->text_inited = mon_text_add(mbus, ubus);\r\nmbus->bin_inited = mon_bin_add(mbus, ubus);\r\nmutex_lock(&mon_lock);\r\nlist_add_tail(&mbus->bus_link, &mon_buses);\r\nmutex_unlock(&mon_lock);\r\nreturn;\r\nerr_alloc:\r\nreturn;\r\n}\r\nstatic void mon_bus0_init(void)\r\n{\r\nstruct mon_bus *mbus = &mon_bus0;\r\nkref_init(&mbus->ref);\r\nspin_lock_init(&mbus->lock);\r\nINIT_LIST_HEAD(&mbus->r_list);\r\nmbus->text_inited = mon_text_add(mbus, NULL);\r\nmbus->bin_inited = mon_bin_add(mbus, NULL);\r\n}\r\nstruct mon_bus *mon_bus_lookup(unsigned int num)\r\n{\r\nstruct list_head *p;\r\nstruct mon_bus *mbus;\r\nif (num == 0) {\r\nreturn &mon_bus0;\r\n}\r\nlist_for_each (p, &mon_buses) {\r\nmbus = list_entry(p, struct mon_bus, bus_link);\r\nif (mbus->u_bus->busnum == num) {\r\nreturn mbus;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic int __init mon_init(void)\r\n{\r\nstruct usb_bus *ubus;\r\nint rc, id;\r\nif ((rc = mon_text_init()) != 0)\r\ngoto err_text;\r\nif ((rc = mon_bin_init()) != 0)\r\ngoto err_bin;\r\nmon_bus0_init();\r\nif (usb_mon_register(&mon_ops_0) != 0) {\r\nprintk(KERN_NOTICE TAG ": unable to register with the core\n");\r\nrc = -ENODEV;\r\ngoto err_reg;\r\n}\r\nmutex_lock(&usb_bus_idr_lock);\r\nidr_for_each_entry(&usb_bus_idr, ubus, id)\r\nmon_bus_init(ubus);\r\nusb_register_notify(&mon_nb);\r\nmutex_unlock(&usb_bus_idr_lock);\r\nreturn 0;\r\nerr_reg:\r\nmon_bin_exit();\r\nerr_bin:\r\nmon_text_exit();\r\nerr_text:\r\nreturn rc;\r\n}\r\nstatic void __exit mon_exit(void)\r\n{\r\nstruct mon_bus *mbus;\r\nstruct list_head *p;\r\nusb_unregister_notify(&mon_nb);\r\nusb_mon_deregister();\r\nmutex_lock(&mon_lock);\r\nwhile (!list_empty(&mon_buses)) {\r\np = mon_buses.next;\r\nmbus = list_entry(p, struct mon_bus, bus_link);\r\nlist_del(p);\r\nif (mbus->text_inited)\r\nmon_text_del(mbus);\r\nif (mbus->bin_inited)\r\nmon_bin_del(mbus);\r\nif (mbus->nreaders) {\r\nprintk(KERN_ERR TAG\r\n": Outstanding opens (%d) on usb%d, leaking...\n",\r\nmbus->nreaders, mbus->u_bus->busnum);\r\nkref_get(&mbus->ref);\r\n}\r\nmon_dissolve(mbus, mbus->u_bus);\r\nkref_put(&mbus->ref, mon_bus_drop);\r\n}\r\nmbus = &mon_bus0;\r\nif (mbus->text_inited)\r\nmon_text_del(mbus);\r\nif (mbus->bin_inited)\r\nmon_bin_del(mbus);\r\nmutex_unlock(&mon_lock);\r\nmon_text_exit();\r\nmon_bin_exit();\r\n}
