static bool\r\nnv40_fifo_dma_engine(struct nvkm_engine *engine, u32 *reg, u32 *ctx)\r\n{\r\nswitch (engine->subdev.index) {\r\ncase NVKM_ENGINE_DMAOBJ:\r\ncase NVKM_ENGINE_SW:\r\nreturn false;\r\ncase NVKM_ENGINE_GR:\r\n*reg = 0x0032e0;\r\n*ctx = 0x38;\r\nreturn true;\r\ncase NVKM_ENGINE_MPEG:\r\nif (engine->subdev.device->chipset < 0x44)\r\nreturn false;\r\n*reg = 0x00330c;\r\n*ctx = 0x54;\r\nreturn true;\r\ndefault:\r\nWARN_ON(1);\r\nreturn false;\r\n}\r\n}\r\nstatic int\r\nnv40_fifo_dma_engine_fini(struct nvkm_fifo_chan *base,\r\nstruct nvkm_engine *engine, bool suspend)\r\n{\r\nstruct nv04_fifo_chan *chan = nv04_fifo_chan(base);\r\nstruct nv04_fifo *fifo = chan->fifo;\r\nstruct nvkm_device *device = fifo->base.engine.subdev.device;\r\nstruct nvkm_instmem *imem = device->imem;\r\nunsigned long flags;\r\nu32 reg, ctx;\r\nint chid;\r\nif (!nv40_fifo_dma_engine(engine, &reg, &ctx))\r\nreturn 0;\r\nspin_lock_irqsave(&fifo->base.lock, flags);\r\nnvkm_mask(device, 0x002500, 0x00000001, 0x00000000);\r\nchid = nvkm_rd32(device, 0x003204) & (fifo->base.nr - 1);\r\nif (chid == chan->base.chid)\r\nnvkm_wr32(device, reg, 0x00000000);\r\nnvkm_kmap(imem->ramfc);\r\nnvkm_wo32(imem->ramfc, chan->ramfc + ctx, 0x00000000);\r\nnvkm_done(imem->ramfc);\r\nnvkm_mask(device, 0x002500, 0x00000001, 0x00000001);\r\nspin_unlock_irqrestore(&fifo->base.lock, flags);\r\nreturn 0;\r\n}\r\nstatic int\r\nnv40_fifo_dma_engine_init(struct nvkm_fifo_chan *base,\r\nstruct nvkm_engine *engine)\r\n{\r\nstruct nv04_fifo_chan *chan = nv04_fifo_chan(base);\r\nstruct nv04_fifo *fifo = chan->fifo;\r\nstruct nvkm_device *device = fifo->base.engine.subdev.device;\r\nstruct nvkm_instmem *imem = device->imem;\r\nunsigned long flags;\r\nu32 inst, reg, ctx;\r\nint chid;\r\nif (!nv40_fifo_dma_engine(engine, &reg, &ctx))\r\nreturn 0;\r\ninst = chan->engn[engine->subdev.index]->addr >> 4;\r\nspin_lock_irqsave(&fifo->base.lock, flags);\r\nnvkm_mask(device, 0x002500, 0x00000001, 0x00000000);\r\nchid = nvkm_rd32(device, 0x003204) & (fifo->base.nr - 1);\r\nif (chid == chan->base.chid)\r\nnvkm_wr32(device, reg, inst);\r\nnvkm_kmap(imem->ramfc);\r\nnvkm_wo32(imem->ramfc, chan->ramfc + ctx, inst);\r\nnvkm_done(imem->ramfc);\r\nnvkm_mask(device, 0x002500, 0x00000001, 0x00000001);\r\nspin_unlock_irqrestore(&fifo->base.lock, flags);\r\nreturn 0;\r\n}\r\nstatic void\r\nnv40_fifo_dma_engine_dtor(struct nvkm_fifo_chan *base,\r\nstruct nvkm_engine *engine)\r\n{\r\nstruct nv04_fifo_chan *chan = nv04_fifo_chan(base);\r\nnvkm_gpuobj_del(&chan->engn[engine->subdev.index]);\r\n}\r\nstatic int\r\nnv40_fifo_dma_engine_ctor(struct nvkm_fifo_chan *base,\r\nstruct nvkm_engine *engine,\r\nstruct nvkm_object *object)\r\n{\r\nstruct nv04_fifo_chan *chan = nv04_fifo_chan(base);\r\nconst int engn = engine->subdev.index;\r\nu32 reg, ctx;\r\nif (!nv40_fifo_dma_engine(engine, &reg, &ctx))\r\nreturn 0;\r\nreturn nvkm_object_bind(object, NULL, 0, &chan->engn[engn]);\r\n}\r\nstatic int\r\nnv40_fifo_dma_object_ctor(struct nvkm_fifo_chan *base,\r\nstruct nvkm_object *object)\r\n{\r\nstruct nv04_fifo_chan *chan = nv04_fifo_chan(base);\r\nstruct nvkm_instmem *imem = chan->fifo->base.engine.subdev.device->imem;\r\nu32 context = chan->base.chid << 23;\r\nu32 handle = object->handle;\r\nint hash;\r\nswitch (object->engine->subdev.index) {\r\ncase NVKM_ENGINE_DMAOBJ:\r\ncase NVKM_ENGINE_SW : context |= 0x00000000; break;\r\ncase NVKM_ENGINE_GR : context |= 0x00100000; break;\r\ncase NVKM_ENGINE_MPEG : context |= 0x00200000; break;\r\ndefault:\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&chan->fifo->base.engine.subdev.mutex);\r\nhash = nvkm_ramht_insert(imem->ramht, object, chan->base.chid, 4,\r\nhandle, context);\r\nmutex_unlock(&chan->fifo->base.engine.subdev.mutex);\r\nreturn hash;\r\n}\r\nstatic int\r\nnv40_fifo_dma_new(struct nvkm_fifo *base, const struct nvkm_oclass *oclass,\r\nvoid *data, u32 size, struct nvkm_object **pobject)\r\n{\r\nstruct nvkm_object *parent = oclass->parent;\r\nunion {\r\nstruct nv03_channel_dma_v0 v0;\r\n} *args = data;\r\nstruct nv04_fifo *fifo = nv04_fifo(base);\r\nstruct nv04_fifo_chan *chan = NULL;\r\nstruct nvkm_device *device = fifo->base.engine.subdev.device;\r\nstruct nvkm_instmem *imem = device->imem;\r\nint ret = -ENOSYS;\r\nnvif_ioctl(parent, "create channel dma size %d\n", size);\r\nif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {\r\nnvif_ioctl(parent, "create channel dma vers %d pushbuf %llx "\r\n"offset %08x\n", args->v0.version,\r\nargs->v0.pushbuf, args->v0.offset);\r\nif (!args->v0.pushbuf)\r\nreturn -EINVAL;\r\n} else\r\nreturn ret;\r\nif (!(chan = kzalloc(sizeof(*chan), GFP_KERNEL)))\r\nreturn -ENOMEM;\r\n*pobject = &chan->base.object;\r\nret = nvkm_fifo_chan_ctor(&nv40_fifo_dma_func, &fifo->base,\r\n0x1000, 0x1000, false, 0, args->v0.pushbuf,\r\n(1ULL << NVKM_ENGINE_DMAOBJ) |\r\n(1ULL << NVKM_ENGINE_GR) |\r\n(1ULL << NVKM_ENGINE_MPEG) |\r\n(1ULL << NVKM_ENGINE_SW),\r\n0, 0xc00000, 0x1000, oclass, &chan->base);\r\nchan->fifo = fifo;\r\nif (ret)\r\nreturn ret;\r\nargs->v0.chid = chan->base.chid;\r\nchan->ramfc = chan->base.chid * 128;\r\nnvkm_kmap(imem->ramfc);\r\nnvkm_wo32(imem->ramfc, chan->ramfc + 0x00, args->v0.offset);\r\nnvkm_wo32(imem->ramfc, chan->ramfc + 0x04, args->v0.offset);\r\nnvkm_wo32(imem->ramfc, chan->ramfc + 0x0c, chan->base.push->addr >> 4);\r\nnvkm_wo32(imem->ramfc, chan->ramfc + 0x18, 0x30000000 |\r\nNV_PFIFO_CACHE1_DMA_FETCH_TRIG_128_BYTES |\r\nNV_PFIFO_CACHE1_DMA_FETCH_SIZE_128_BYTES |\r\n#ifdef __BIG_ENDIAN\r\nNV_PFIFO_CACHE1_BIG_ENDIAN |\r\n#endif\r\nNV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_8);\r\nnvkm_wo32(imem->ramfc, chan->ramfc + 0x3c, 0x0001ffff);\r\nnvkm_done(imem->ramfc);\r\nreturn 0;\r\n}
