static u8 crc8(u16 data)\r\n{\r\nint i;\r\nfor (i = 0; i < 8; i++) {\r\nif (data & 0x8000)\r\ndata = data ^ POLY;\r\ndata = data << 1;\r\n}\r\nreturn (u8)(data >> 8);\r\n}\r\nstatic u8 i2c_smbus_pec(u8 crc, u8 *p, size_t count)\r\n{\r\nint i;\r\nfor (i = 0; i < count; i++)\r\ncrc = crc8((crc ^ p[i]) << 8);\r\nreturn crc;\r\n}\r\nstatic u8 i2c_smbus_msg_pec(u8 pec, struct i2c_msg *msg)\r\n{\r\nu8 addr = i2c_8bit_addr_from_msg(msg);\r\npec = i2c_smbus_pec(pec, &addr, 1);\r\nreturn i2c_smbus_pec(pec, msg->buf, msg->len);\r\n}\r\nstatic inline void i2c_smbus_add_pec(struct i2c_msg *msg)\r\n{\r\nmsg->buf[msg->len] = i2c_smbus_msg_pec(0, msg);\r\nmsg->len++;\r\n}\r\nstatic int i2c_smbus_check_pec(u8 cpec, struct i2c_msg *msg)\r\n{\r\nu8 rpec = msg->buf[--msg->len];\r\ncpec = i2c_smbus_msg_pec(cpec, msg);\r\nif (rpec != cpec) {\r\npr_debug("Bad PEC 0x%02x vs. 0x%02x\n",\r\nrpec, cpec);\r\nreturn -EBADMSG;\r\n}\r\nreturn 0;\r\n}\r\ns32 i2c_smbus_read_byte(const struct i2c_client *client)\r\n{\r\nunion i2c_smbus_data data;\r\nint status;\r\nstatus = i2c_smbus_xfer(client->adapter, client->addr, client->flags,\r\nI2C_SMBUS_READ, 0,\r\nI2C_SMBUS_BYTE, &data);\r\nreturn (status < 0) ? status : data.byte;\r\n}\r\ns32 i2c_smbus_write_byte(const struct i2c_client *client, u8 value)\r\n{\r\nreturn i2c_smbus_xfer(client->adapter, client->addr, client->flags,\r\nI2C_SMBUS_WRITE, value, I2C_SMBUS_BYTE, NULL);\r\n}\r\ns32 i2c_smbus_read_byte_data(const struct i2c_client *client, u8 command)\r\n{\r\nunion i2c_smbus_data data;\r\nint status;\r\nstatus = i2c_smbus_xfer(client->adapter, client->addr, client->flags,\r\nI2C_SMBUS_READ, command,\r\nI2C_SMBUS_BYTE_DATA, &data);\r\nreturn (status < 0) ? status : data.byte;\r\n}\r\ns32 i2c_smbus_write_byte_data(const struct i2c_client *client, u8 command,\r\nu8 value)\r\n{\r\nunion i2c_smbus_data data;\r\ndata.byte = value;\r\nreturn i2c_smbus_xfer(client->adapter, client->addr, client->flags,\r\nI2C_SMBUS_WRITE, command,\r\nI2C_SMBUS_BYTE_DATA, &data);\r\n}\r\ns32 i2c_smbus_read_word_data(const struct i2c_client *client, u8 command)\r\n{\r\nunion i2c_smbus_data data;\r\nint status;\r\nstatus = i2c_smbus_xfer(client->adapter, client->addr, client->flags,\r\nI2C_SMBUS_READ, command,\r\nI2C_SMBUS_WORD_DATA, &data);\r\nreturn (status < 0) ? status : data.word;\r\n}\r\ns32 i2c_smbus_write_word_data(const struct i2c_client *client, u8 command,\r\nu16 value)\r\n{\r\nunion i2c_smbus_data data;\r\ndata.word = value;\r\nreturn i2c_smbus_xfer(client->adapter, client->addr, client->flags,\r\nI2C_SMBUS_WRITE, command,\r\nI2C_SMBUS_WORD_DATA, &data);\r\n}\r\ns32 i2c_smbus_read_block_data(const struct i2c_client *client, u8 command,\r\nu8 *values)\r\n{\r\nunion i2c_smbus_data data;\r\nint status;\r\nstatus = i2c_smbus_xfer(client->adapter, client->addr, client->flags,\r\nI2C_SMBUS_READ, command,\r\nI2C_SMBUS_BLOCK_DATA, &data);\r\nif (status)\r\nreturn status;\r\nmemcpy(values, &data.block[1], data.block[0]);\r\nreturn data.block[0];\r\n}\r\ns32 i2c_smbus_write_block_data(const struct i2c_client *client, u8 command,\r\nu8 length, const u8 *values)\r\n{\r\nunion i2c_smbus_data data;\r\nif (length > I2C_SMBUS_BLOCK_MAX)\r\nlength = I2C_SMBUS_BLOCK_MAX;\r\ndata.block[0] = length;\r\nmemcpy(&data.block[1], values, length);\r\nreturn i2c_smbus_xfer(client->adapter, client->addr, client->flags,\r\nI2C_SMBUS_WRITE, command,\r\nI2C_SMBUS_BLOCK_DATA, &data);\r\n}\r\ns32 i2c_smbus_read_i2c_block_data(const struct i2c_client *client, u8 command,\r\nu8 length, u8 *values)\r\n{\r\nunion i2c_smbus_data data;\r\nint status;\r\nif (length > I2C_SMBUS_BLOCK_MAX)\r\nlength = I2C_SMBUS_BLOCK_MAX;\r\ndata.block[0] = length;\r\nstatus = i2c_smbus_xfer(client->adapter, client->addr, client->flags,\r\nI2C_SMBUS_READ, command,\r\nI2C_SMBUS_I2C_BLOCK_DATA, &data);\r\nif (status < 0)\r\nreturn status;\r\nmemcpy(values, &data.block[1], data.block[0]);\r\nreturn data.block[0];\r\n}\r\ns32 i2c_smbus_write_i2c_block_data(const struct i2c_client *client, u8 command,\r\nu8 length, const u8 *values)\r\n{\r\nunion i2c_smbus_data data;\r\nif (length > I2C_SMBUS_BLOCK_MAX)\r\nlength = I2C_SMBUS_BLOCK_MAX;\r\ndata.block[0] = length;\r\nmemcpy(data.block + 1, values, length);\r\nreturn i2c_smbus_xfer(client->adapter, client->addr, client->flags,\r\nI2C_SMBUS_WRITE, command,\r\nI2C_SMBUS_I2C_BLOCK_DATA, &data);\r\n}\r\nstatic s32 i2c_smbus_xfer_emulated(struct i2c_adapter *adapter, u16 addr,\r\nunsigned short flags,\r\nchar read_write, u8 command, int size,\r\nunion i2c_smbus_data *data)\r\n{\r\nunsigned char msgbuf0[I2C_SMBUS_BLOCK_MAX+3];\r\nunsigned char msgbuf1[I2C_SMBUS_BLOCK_MAX+2];\r\nint num = read_write == I2C_SMBUS_READ ? 2 : 1;\r\nint i;\r\nu8 partial_pec = 0;\r\nint status;\r\nstruct i2c_msg msg[2] = {\r\n{\r\n.addr = addr,\r\n.flags = flags,\r\n.len = 1,\r\n.buf = msgbuf0,\r\n}, {\r\n.addr = addr,\r\n.flags = flags | I2C_M_RD,\r\n.len = 0,\r\n.buf = msgbuf1,\r\n},\r\n};\r\nmsgbuf0[0] = command;\r\nswitch (size) {\r\ncase I2C_SMBUS_QUICK:\r\nmsg[0].len = 0;\r\nmsg[0].flags = flags | (read_write == I2C_SMBUS_READ ?\r\nI2C_M_RD : 0);\r\nnum = 1;\r\nbreak;\r\ncase I2C_SMBUS_BYTE:\r\nif (read_write == I2C_SMBUS_READ) {\r\nmsg[0].flags = I2C_M_RD | flags;\r\nnum = 1;\r\n}\r\nbreak;\r\ncase I2C_SMBUS_BYTE_DATA:\r\nif (read_write == I2C_SMBUS_READ)\r\nmsg[1].len = 1;\r\nelse {\r\nmsg[0].len = 2;\r\nmsgbuf0[1] = data->byte;\r\n}\r\nbreak;\r\ncase I2C_SMBUS_WORD_DATA:\r\nif (read_write == I2C_SMBUS_READ)\r\nmsg[1].len = 2;\r\nelse {\r\nmsg[0].len = 3;\r\nmsgbuf0[1] = data->word & 0xff;\r\nmsgbuf0[2] = data->word >> 8;\r\n}\r\nbreak;\r\ncase I2C_SMBUS_PROC_CALL:\r\nnum = 2;\r\nread_write = I2C_SMBUS_READ;\r\nmsg[0].len = 3;\r\nmsg[1].len = 2;\r\nmsgbuf0[1] = data->word & 0xff;\r\nmsgbuf0[2] = data->word >> 8;\r\nbreak;\r\ncase I2C_SMBUS_BLOCK_DATA:\r\nif (read_write == I2C_SMBUS_READ) {\r\nmsg[1].flags |= I2C_M_RECV_LEN;\r\nmsg[1].len = 1;\r\n} else {\r\nmsg[0].len = data->block[0] + 2;\r\nif (msg[0].len > I2C_SMBUS_BLOCK_MAX + 2) {\r\ndev_err(&adapter->dev,\r\n"Invalid block write size %d\n",\r\ndata->block[0]);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 1; i < msg[0].len; i++)\r\nmsgbuf0[i] = data->block[i-1];\r\n}\r\nbreak;\r\ncase I2C_SMBUS_BLOCK_PROC_CALL:\r\nnum = 2;\r\nread_write = I2C_SMBUS_READ;\r\nif (data->block[0] > I2C_SMBUS_BLOCK_MAX) {\r\ndev_err(&adapter->dev,\r\n"Invalid block write size %d\n",\r\ndata->block[0]);\r\nreturn -EINVAL;\r\n}\r\nmsg[0].len = data->block[0] + 2;\r\nfor (i = 1; i < msg[0].len; i++)\r\nmsgbuf0[i] = data->block[i-1];\r\nmsg[1].flags |= I2C_M_RECV_LEN;\r\nmsg[1].len = 1;\r\nbreak;\r\ncase I2C_SMBUS_I2C_BLOCK_DATA:\r\nif (read_write == I2C_SMBUS_READ) {\r\nmsg[1].len = data->block[0];\r\n} else {\r\nmsg[0].len = data->block[0] + 1;\r\nif (msg[0].len > I2C_SMBUS_BLOCK_MAX + 1) {\r\ndev_err(&adapter->dev,\r\n"Invalid block write size %d\n",\r\ndata->block[0]);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 1; i <= data->block[0]; i++)\r\nmsgbuf0[i] = data->block[i];\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(&adapter->dev, "Unsupported transaction %d\n", size);\r\nreturn -EOPNOTSUPP;\r\n}\r\ni = ((flags & I2C_CLIENT_PEC) && size != I2C_SMBUS_QUICK\r\n&& size != I2C_SMBUS_I2C_BLOCK_DATA);\r\nif (i) {\r\nif (!(msg[0].flags & I2C_M_RD)) {\r\nif (num == 1)\r\ni2c_smbus_add_pec(&msg[0]);\r\nelse\r\npartial_pec = i2c_smbus_msg_pec(0, &msg[0]);\r\n}\r\nif (msg[num-1].flags & I2C_M_RD)\r\nmsg[num-1].len++;\r\n}\r\nstatus = i2c_transfer(adapter, msg, num);\r\nif (status < 0)\r\nreturn status;\r\nif (i && (msg[num-1].flags & I2C_M_RD)) {\r\nstatus = i2c_smbus_check_pec(partial_pec, &msg[num-1]);\r\nif (status < 0)\r\nreturn status;\r\n}\r\nif (read_write == I2C_SMBUS_READ)\r\nswitch (size) {\r\ncase I2C_SMBUS_BYTE:\r\ndata->byte = msgbuf0[0];\r\nbreak;\r\ncase I2C_SMBUS_BYTE_DATA:\r\ndata->byte = msgbuf1[0];\r\nbreak;\r\ncase I2C_SMBUS_WORD_DATA:\r\ncase I2C_SMBUS_PROC_CALL:\r\ndata->word = msgbuf1[0] | (msgbuf1[1] << 8);\r\nbreak;\r\ncase I2C_SMBUS_I2C_BLOCK_DATA:\r\nfor (i = 0; i < data->block[0]; i++)\r\ndata->block[i+1] = msgbuf1[i];\r\nbreak;\r\ncase I2C_SMBUS_BLOCK_DATA:\r\ncase I2C_SMBUS_BLOCK_PROC_CALL:\r\nfor (i = 0; i < msgbuf1[0] + 1; i++)\r\ndata->block[i] = msgbuf1[i];\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\ns32 i2c_smbus_xfer(struct i2c_adapter *adapter, u16 addr, unsigned short flags,\r\nchar read_write, u8 command, int protocol,\r\nunion i2c_smbus_data *data)\r\n{\r\nunsigned long orig_jiffies;\r\nint try;\r\ns32 res;\r\ntrace_smbus_write(adapter, addr, flags, read_write,\r\ncommand, protocol, data);\r\ntrace_smbus_read(adapter, addr, flags, read_write,\r\ncommand, protocol);\r\nflags &= I2C_M_TEN | I2C_CLIENT_PEC | I2C_CLIENT_SCCB;\r\nif (adapter->algo->smbus_xfer) {\r\ni2c_lock_bus(adapter, I2C_LOCK_SEGMENT);\r\norig_jiffies = jiffies;\r\nfor (res = 0, try = 0; try <= adapter->retries; try++) {\r\nres = adapter->algo->smbus_xfer(adapter, addr, flags,\r\nread_write, command,\r\nprotocol, data);\r\nif (res != -EAGAIN)\r\nbreak;\r\nif (time_after(jiffies,\r\norig_jiffies + adapter->timeout))\r\nbreak;\r\n}\r\ni2c_unlock_bus(adapter, I2C_LOCK_SEGMENT);\r\nif (res != -EOPNOTSUPP || !adapter->algo->master_xfer)\r\ngoto trace;\r\n}\r\nres = i2c_smbus_xfer_emulated(adapter, addr, flags, read_write,\r\ncommand, protocol, data);\r\ntrace:\r\ntrace_smbus_reply(adapter, addr, flags, read_write,\r\ncommand, protocol, data);\r\ntrace_smbus_result(adapter, addr, flags, read_write,\r\ncommand, protocol, res);\r\nreturn res;\r\n}\r\ns32 i2c_smbus_read_i2c_block_data_or_emulated(const struct i2c_client *client,\r\nu8 command, u8 length, u8 *values)\r\n{\r\nu8 i = 0;\r\nint status;\r\nif (length > I2C_SMBUS_BLOCK_MAX)\r\nlength = I2C_SMBUS_BLOCK_MAX;\r\nif (i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_READ_I2C_BLOCK))\r\nreturn i2c_smbus_read_i2c_block_data(client, command, length, values);\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_READ_BYTE_DATA))\r\nreturn -EOPNOTSUPP;\r\nif (i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_READ_WORD_DATA)) {\r\nwhile ((i + 2) <= length) {\r\nstatus = i2c_smbus_read_word_data(client, command + i);\r\nif (status < 0)\r\nreturn status;\r\nvalues[i] = status & 0xff;\r\nvalues[i + 1] = status >> 8;\r\ni += 2;\r\n}\r\n}\r\nwhile (i < length) {\r\nstatus = i2c_smbus_read_byte_data(client, command + i);\r\nif (status < 0)\r\nreturn status;\r\nvalues[i] = status;\r\ni++;\r\n}\r\nreturn i;\r\n}
