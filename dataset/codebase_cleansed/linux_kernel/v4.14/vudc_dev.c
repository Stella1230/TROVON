static void free_urb(struct urb *urb)\r\n{\r\nif (!urb)\r\nreturn;\r\nkfree(urb->setup_packet);\r\nurb->setup_packet = NULL;\r\nkfree(urb->transfer_buffer);\r\nurb->transfer_buffer = NULL;\r\nusb_free_urb(urb);\r\n}\r\nstruct urbp *alloc_urbp(void)\r\n{\r\nstruct urbp *urb_p;\r\nurb_p = kzalloc(sizeof(*urb_p), GFP_KERNEL);\r\nif (!urb_p)\r\nreturn urb_p;\r\nurb_p->urb = NULL;\r\nurb_p->ep = NULL;\r\nINIT_LIST_HEAD(&urb_p->urb_entry);\r\nreturn urb_p;\r\n}\r\nstatic void free_urbp(struct urbp *urb_p)\r\n{\r\nkfree(urb_p);\r\n}\r\nvoid free_urbp_and_urb(struct urbp *urb_p)\r\n{\r\nif (!urb_p)\r\nreturn;\r\nfree_urb(urb_p->urb);\r\nfree_urbp(urb_p);\r\n}\r\nstatic void nuke(struct vudc *udc, struct vep *ep)\r\n{\r\nstruct vrequest *req;\r\nwhile (!list_empty(&ep->req_queue)) {\r\nreq = list_first_entry(&ep->req_queue, struct vrequest,\r\nreq_entry);\r\nlist_del_init(&req->req_entry);\r\nreq->req.status = -ESHUTDOWN;\r\nspin_unlock(&udc->lock);\r\nusb_gadget_giveback_request(&ep->ep, &req->req);\r\nspin_lock(&udc->lock);\r\n}\r\n}\r\nstatic void stop_activity(struct vudc *udc)\r\n{\r\nint i;\r\nstruct urbp *urb_p, *tmp;\r\nudc->address = 0;\r\nfor (i = 0; i < VIRTUAL_ENDPOINTS; i++)\r\nnuke(udc, &udc->ep[i]);\r\nlist_for_each_entry_safe(urb_p, tmp, &udc->urb_queue, urb_entry) {\r\nlist_del(&urb_p->urb_entry);\r\nfree_urbp_and_urb(urb_p);\r\n}\r\n}\r\nstruct vep *vudc_find_endpoint(struct vudc *udc, u8 address)\r\n{\r\nint i;\r\nif ((address & ~USB_DIR_IN) == 0)\r\nreturn &udc->ep[0];\r\nfor (i = 1; i < VIRTUAL_ENDPOINTS; i++) {\r\nstruct vep *ep = &udc->ep[i];\r\nif (!ep->desc)\r\ncontinue;\r\nif (ep->desc->bEndpointAddress == address)\r\nreturn ep;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int vgadget_get_frame(struct usb_gadget *_gadget)\r\n{\r\nstruct timeval now;\r\nstruct vudc *udc = usb_gadget_to_vudc(_gadget);\r\ndo_gettimeofday(&now);\r\nreturn ((now.tv_sec - udc->start_time.tv_sec) * 1000 +\r\n(now.tv_usec - udc->start_time.tv_usec) / 1000)\r\n% 0x7FF;\r\n}\r\nstatic int vgadget_set_selfpowered(struct usb_gadget *_gadget, int value)\r\n{\r\nstruct vudc *udc = usb_gadget_to_vudc(_gadget);\r\nif (value)\r\nudc->devstatus |= (1 << USB_DEVICE_SELF_POWERED);\r\nelse\r\nudc->devstatus &= ~(1 << USB_DEVICE_SELF_POWERED);\r\nreturn 0;\r\n}\r\nstatic int vgadget_pullup(struct usb_gadget *_gadget, int value)\r\n{\r\nstruct vudc *udc = usb_gadget_to_vudc(_gadget);\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nvalue = !!value;\r\nif (value == udc->pullup)\r\ngoto unlock;\r\nudc->pullup = value;\r\nif (value) {\r\nudc->gadget.speed = min_t(u8, USB_SPEED_HIGH,\r\nudc->driver->max_speed);\r\nudc->ep[0].ep.maxpacket = 64;\r\nret = get_gadget_descs(udc);\r\nif (ret) {\r\ndev_err(&udc->gadget.dev, "Unable go get desc: %d", ret);\r\ngoto unlock;\r\n}\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nusbip_start_eh(&udc->ud);\r\n} else {\r\nudc->desc_cached = 0;\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nusbip_event_add(&udc->ud, VUDC_EVENT_REMOVED);\r\nusbip_stop_eh(&udc->ud);\r\n}\r\nreturn 0;\r\nunlock:\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int vgadget_udc_start(struct usb_gadget *g,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct vudc *udc = usb_gadget_to_vudc(g);\r\nunsigned long flags;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nudc->driver = driver;\r\nudc->pullup = udc->connected = udc->desc_cached = 0;\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int vgadget_udc_stop(struct usb_gadget *g)\r\n{\r\nstruct vudc *udc = usb_gadget_to_vudc(g);\r\nunsigned long flags;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nudc->driver = NULL;\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int vep_enable(struct usb_ep *_ep,\r\nconst struct usb_endpoint_descriptor *desc)\r\n{\r\nstruct vep *ep;\r\nstruct vudc *udc;\r\nunsigned int maxp;\r\nunsigned long flags;\r\nep = to_vep(_ep);\r\nudc = ep_to_vudc(ep);\r\nif (!_ep || !desc || ep->desc || _ep->caps.type_control\r\n|| desc->bDescriptorType != USB_DT_ENDPOINT)\r\nreturn -EINVAL;\r\nif (!udc->driver)\r\nreturn -ESHUTDOWN;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nmaxp = usb_endpoint_maxp(desc);\r\n_ep->maxpacket = maxp;\r\nep->desc = desc;\r\nep->type = usb_endpoint_type(desc);\r\nep->halted = ep->wedged = 0;\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int vep_disable(struct usb_ep *_ep)\r\n{\r\nstruct vep *ep;\r\nstruct vudc *udc;\r\nunsigned long flags;\r\nep = to_vep(_ep);\r\nudc = ep_to_vudc(ep);\r\nif (!_ep || !ep->desc || _ep->caps.type_control)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nep->desc = NULL;\r\nnuke(udc, ep);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic struct usb_request *vep_alloc_request(struct usb_ep *_ep,\r\ngfp_t mem_flags)\r\n{\r\nstruct vep *ep;\r\nstruct vrequest *req;\r\nif (!_ep)\r\nreturn NULL;\r\nep = to_vep(_ep);\r\nreq = kzalloc(sizeof(*req), mem_flags);\r\nif (!req)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&req->req_entry);\r\nreturn &req->req;\r\n}\r\nstatic void vep_free_request(struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\nstruct vrequest *req;\r\nif (WARN_ON(!_ep || !_req))\r\nreturn;\r\nreq = to_vrequest(_req);\r\nkfree(req);\r\n}\r\nstatic int vep_queue(struct usb_ep *_ep, struct usb_request *_req,\r\ngfp_t mem_flags)\r\n{\r\nstruct vep *ep;\r\nstruct vrequest *req;\r\nstruct vudc *udc;\r\nunsigned long flags;\r\nif (!_ep || !_req)\r\nreturn -EINVAL;\r\nep = to_vep(_ep);\r\nreq = to_vrequest(_req);\r\nudc = ep_to_vudc(ep);\r\nspin_lock_irqsave(&udc->lock, flags);\r\n_req->actual = 0;\r\n_req->status = -EINPROGRESS;\r\nlist_add_tail(&req->req_entry, &ep->req_queue);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int vep_dequeue(struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\nstruct vep *ep;\r\nstruct vrequest *req;\r\nstruct vudc *udc;\r\nstruct vrequest *lst;\r\nunsigned long flags;\r\nint ret = -EINVAL;\r\nif (!_ep || !_req)\r\nreturn ret;\r\nep = to_vep(_ep);\r\nreq = to_vrequest(_req);\r\nudc = req->udc;\r\nif (!udc->driver)\r\nreturn -ESHUTDOWN;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nlist_for_each_entry(lst, &ep->req_queue, req_entry) {\r\nif (&lst->req == _req) {\r\nlist_del_init(&lst->req_entry);\r\n_req->status = -ECONNRESET;\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nif (ret == 0)\r\nusb_gadget_giveback_request(_ep, _req);\r\nreturn ret;\r\n}\r\nstatic int\r\nvep_set_halt_and_wedge(struct usb_ep *_ep, int value, int wedged)\r\n{\r\nstruct vep *ep;\r\nstruct vudc *udc;\r\nunsigned long flags;\r\nint ret = 0;\r\nep = to_vep(_ep);\r\nif (!_ep)\r\nreturn -EINVAL;\r\nudc = ep_to_vudc(ep);\r\nif (!udc->driver)\r\nreturn -ESHUTDOWN;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nif (!value)\r\nep->halted = ep->wedged = 0;\r\nelse if (ep->desc && (ep->desc->bEndpointAddress & USB_DIR_IN) &&\r\n!list_empty(&ep->req_queue))\r\nret = -EAGAIN;\r\nelse {\r\nep->halted = 1;\r\nif (wedged)\r\nep->wedged = 1;\r\n}\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int\r\nvep_set_halt(struct usb_ep *_ep, int value)\r\n{\r\nreturn vep_set_halt_and_wedge(_ep, value, 0);\r\n}\r\nstatic int vep_set_wedge(struct usb_ep *_ep)\r\n{\r\nreturn vep_set_halt_and_wedge(_ep, 1, 1);\r\n}\r\nstatic void vudc_shutdown(struct usbip_device *ud)\r\n{\r\nstruct vudc *udc = container_of(ud, struct vudc, ud);\r\nint call_disconnect = 0;\r\nunsigned long flags;\r\ndev_dbg(&udc->pdev->dev, "device shutdown");\r\nif (ud->tcp_socket)\r\nkernel_sock_shutdown(ud->tcp_socket, SHUT_RDWR);\r\nif (ud->tcp_rx) {\r\nkthread_stop_put(ud->tcp_rx);\r\nud->tcp_rx = NULL;\r\n}\r\nif (ud->tcp_tx) {\r\nkthread_stop_put(ud->tcp_tx);\r\nud->tcp_tx = NULL;\r\n}\r\nif (ud->tcp_socket) {\r\nsockfd_put(ud->tcp_socket);\r\nud->tcp_socket = NULL;\r\n}\r\nspin_lock_irqsave(&udc->lock, flags);\r\nstop_activity(udc);\r\nif (udc->connected && udc->driver->disconnect)\r\ncall_disconnect = 1;\r\nudc->connected = 0;\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nif (call_disconnect)\r\nudc->driver->disconnect(&udc->gadget);\r\n}\r\nstatic void vudc_device_reset(struct usbip_device *ud)\r\n{\r\nstruct vudc *udc = container_of(ud, struct vudc, ud);\r\nunsigned long flags;\r\ndev_dbg(&udc->pdev->dev, "device reset");\r\nspin_lock_irqsave(&udc->lock, flags);\r\nstop_activity(udc);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nif (udc->driver)\r\nusb_gadget_udc_reset(&udc->gadget, udc->driver);\r\nspin_lock_irqsave(&ud->lock, flags);\r\nud->status = SDEV_ST_AVAILABLE;\r\nspin_unlock_irqrestore(&ud->lock, flags);\r\n}\r\nstatic void vudc_device_unusable(struct usbip_device *ud)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ud->lock, flags);\r\nud->status = SDEV_ST_ERROR;\r\nspin_unlock_irqrestore(&ud->lock, flags);\r\n}\r\nstruct vudc_device *alloc_vudc_device(int devid)\r\n{\r\nstruct vudc_device *udc_dev = NULL;\r\nudc_dev = kzalloc(sizeof(*udc_dev), GFP_KERNEL);\r\nif (!udc_dev)\r\ngoto out;\r\nINIT_LIST_HEAD(&udc_dev->dev_entry);\r\nudc_dev->pdev = platform_device_alloc(GADGET_NAME, devid);\r\nif (!udc_dev->pdev) {\r\nkfree(udc_dev);\r\nudc_dev = NULL;\r\n}\r\nout:\r\nreturn udc_dev;\r\n}\r\nvoid put_vudc_device(struct vudc_device *udc_dev)\r\n{\r\nplatform_device_put(udc_dev->pdev);\r\nkfree(udc_dev);\r\n}\r\nstatic int init_vudc_hw(struct vudc *udc)\r\n{\r\nint i;\r\nstruct usbip_device *ud = &udc->ud;\r\nstruct vep *ep;\r\nudc->ep = kcalloc(VIRTUAL_ENDPOINTS, sizeof(*udc->ep), GFP_KERNEL);\r\nif (!udc->ep)\r\ngoto nomem_ep;\r\nINIT_LIST_HEAD(&udc->gadget.ep_list);\r\nfor (i = 0; i < VIRTUAL_ENDPOINTS; ++i) {\r\nint is_out = i % 2;\r\nint num = (i + 1) / 2;\r\nep = &udc->ep[i];\r\nsprintf(ep->name, "ep%d%s", num,\r\ni ? (is_out ? "out" : "in") : "");\r\nep->ep.name = ep->name;\r\nep->ep.ops = &vep_ops;\r\nusb_ep_set_maxpacket_limit(&ep->ep, ~0);\r\nep->ep.max_streams = 16;\r\nep->gadget = &udc->gadget;\r\nINIT_LIST_HEAD(&ep->req_queue);\r\nif (i == 0) {\r\nep->ep.caps.type_control = true;\r\nep->ep.caps.dir_out = true;\r\nep->ep.caps.dir_in = true;\r\nudc->gadget.ep0 = &ep->ep;\r\n} else {\r\nep->ep.caps.type_iso = true;\r\nep->ep.caps.type_int = true;\r\nep->ep.caps.type_bulk = true;\r\nif (is_out)\r\nep->ep.caps.dir_out = true;\r\nelse\r\nep->ep.caps.dir_in = true;\r\nlist_add_tail(&ep->ep.ep_list, &udc->gadget.ep_list);\r\n}\r\n}\r\nspin_lock_init(&udc->lock);\r\nspin_lock_init(&udc->lock_tx);\r\nINIT_LIST_HEAD(&udc->urb_queue);\r\nINIT_LIST_HEAD(&udc->tx_queue);\r\ninit_waitqueue_head(&udc->tx_waitq);\r\nspin_lock_init(&ud->lock);\r\nud->status = SDEV_ST_AVAILABLE;\r\nud->side = USBIP_VUDC;\r\nud->eh_ops.shutdown = vudc_shutdown;\r\nud->eh_ops.reset = vudc_device_reset;\r\nud->eh_ops.unusable = vudc_device_unusable;\r\nv_init_timer(udc);\r\nreturn 0;\r\nnomem_ep:\r\nreturn -ENOMEM;\r\n}\r\nstatic void cleanup_vudc_hw(struct vudc *udc)\r\n{\r\nkfree(udc->ep);\r\n}\r\nint vudc_probe(struct platform_device *pdev)\r\n{\r\nstruct vudc *udc;\r\nint ret = -ENOMEM;\r\nudc = kzalloc(sizeof(*udc), GFP_KERNEL);\r\nif (!udc)\r\ngoto out;\r\nudc->gadget.name = GADGET_NAME;\r\nudc->gadget.ops = &vgadget_ops;\r\nudc->gadget.max_speed = USB_SPEED_HIGH;\r\nudc->gadget.dev.parent = &pdev->dev;\r\nudc->pdev = pdev;\r\nret = init_vudc_hw(udc);\r\nif (ret)\r\ngoto err_init_vudc_hw;\r\nret = usb_add_gadget_udc(&pdev->dev, &udc->gadget);\r\nif (ret < 0)\r\ngoto err_add_udc;\r\nret = sysfs_create_group(&pdev->dev.kobj, &vudc_attr_group);\r\nif (ret) {\r\ndev_err(&udc->pdev->dev, "create sysfs files\n");\r\ngoto err_sysfs;\r\n}\r\nplatform_set_drvdata(pdev, udc);\r\nreturn ret;\r\nerr_sysfs:\r\nusb_del_gadget_udc(&udc->gadget);\r\nerr_add_udc:\r\ncleanup_vudc_hw(udc);\r\nerr_init_vudc_hw:\r\nkfree(udc);\r\nout:\r\nreturn ret;\r\n}\r\nint vudc_remove(struct platform_device *pdev)\r\n{\r\nstruct vudc *udc = platform_get_drvdata(pdev);\r\nsysfs_remove_group(&pdev->dev.kobj, &vudc_attr_group);\r\nusb_del_gadget_udc(&udc->gadget);\r\ncleanup_vudc_hw(udc);\r\nkfree(udc);\r\nreturn 0;\r\n}
